head	1.114;
access;
symbols
	ansi-20040405-merged:1.107.2.2
	postmerge-20040405-ansi:1.112
	premerge-20040404-ansi:1.111
	postmerge-autoconf:1.111
	autoconf-freeze:1.110.6.2
	premerge-autoconf:1.111
	ansi-20040316-freeze:1.107.2.1
	postmerge-20040315-windows:1.111
	premerge-20040315-windows:1.111
	windows-20040315-freeze:1.107.4.1
	autoconf-20031203:1.110
	autoconf-20031202:1.110
	autoconf-branch:1.110.0.6
	phong-branch:1.110.0.4
	photonmap-branch:1.110.0.2
	rel-6-1-DP:1.107
	windows-branch:1.107.0.4
	rel-6-0-2:1.104.2.1
	ansi-branch:1.107.0.2
	rel-6-0-1-branch:1.104.0.2
	hartley-6-0-post:1.105
	hartley-6-0-pre:1.104
	rel-6-0-1:1.104
	rel-6-0:1.104
	rel-5-4:1.86.2.1
	offsite-5-3-pre:1.95
	rel-5-3:1.86.2.1
	rel-5-2:1.86.2.1
	rel-5-1-branch:1.86.0.2
	rel-5-1:1.86
	rel-5-0:1.61
	rel-5-0-beta:1.61
	rel-4-5:1.29
	ctj-4-5-post:1.19
	ctj-4-5-pre:1.19;
locks; strict;
comment	@ * @;


1.114
date	2004.05.21.18.07.35;	author morrison;	state dead;
branches;
next	1.113;

1.113
date	2004.05.10.15.30.47;	author erikg;	state Exp;
branches;
next	1.112;

1.112
date	2004.04.05.08.48.58;	author morrison;	state Exp;
branches;
next	1.111;

1.111
date	2004.02.02.17.39.29;	author morrison;	state Exp;
branches;
next	1.110;

1.110
date	2003.04.09.20.15.29;	author jra;	state Exp;
branches
	1.110.6.1;
next	1.109;

1.109
date	2003.04.01.19.14.48;	author jra;	state Exp;
branches;
next	1.108;

1.108
date	2002.12.10.14.10.44;	author jra;	state Exp;
branches;
next	1.107;

1.107
date	2002.09.04.20.32.26;	author jra;	state Exp;
branches
	1.107.2.1
	1.107.4.1;
next	1.106;

1.106
date	2002.08.20.17.08.10;	author jra;	state Exp;
branches;
next	1.105;

1.105
date	2002.08.15.20.55.21;	author hartley;	state Exp;
branches;
next	1.104;

1.104
date	2001.12.17.07.48.25;	author butler;	state Exp;
branches
	1.104.2.1;
next	1.103;

1.103
date	2001.10.02.17.54.12;	author jra;	state Exp;
branches;
next	1.102;

1.102
date	2001.07.27.23.05.25;	author butler;	state Exp;
branches;
next	1.101;

1.101
date	2001.07.17.13.27.19;	author jra;	state Exp;
branches;
next	1.100;

1.100
date	2001.06.21.18.07.25;	author jra;	state Exp;
branches;
next	1.99;

1.99
date	2001.06.19.18.18.49;	author jra;	state Exp;
branches;
next	1.98;

1.98
date	2001.05.30.21.08.33;	author jra;	state Exp;
branches;
next	1.97;

1.97
date	2001.04.20.22.29.56;	author morrison;	state Exp;
branches;
next	1.96;

1.96
date	2001.03.22.20.27.36;	author bparker;	state Exp;
branches;
next	1.95;

1.95
date	2000.09.09.04.30.47;	author mike;	state Exp;
branches;
next	1.94;

1.94
date	2000.09.08.05.54.43;	author mike;	state Exp;
branches;
next	1.93;

1.93
date	2000.08.31.18.57.07;	author bparker;	state Exp;
branches;
next	1.92;

1.92
date	2000.08.29.22.37.24;	author mike;	state Exp;
branches;
next	1.91;

1.91
date	2000.08.29.03.58.10;	author mike;	state Exp;
branches;
next	1.90;

1.90
date	2000.08.19.00.50.02;	author mike;	state Exp;
branches;
next	1.89;

1.89
date	2000.08.15.04.49.40;	author mike;	state Exp;
branches;
next	1.88;

1.88
date	2000.07.12.01.58.14;	author mike;	state Exp;
branches;
next	1.87;

1.87
date	2000.07.10.23.01.49;	author mike;	state Exp;
branches;
next	1.86;

1.86
date	2000.05.23.21.57.29;	author mike;	state Exp;
branches
	1.86.2.1;
next	1.85;

1.85
date	2000.05.23.05.24.20;	author mike;	state Exp;
branches;
next	1.84;

1.84
date	2000.05.18.21.47.08;	author mike;	state Exp;
branches;
next	1.83;

1.83
date	2000.04.20.21.22.18;	author bparker;	state Exp;
branches;
next	1.82;

1.82
date	2000.04.12.01.17.45;	author mike;	state Exp;
branches;
next	1.81;

1.81
date	2000.04.12.01.11.50;	author mike;	state Exp;
branches;
next	1.80;

1.80
date	2000.03.22.02.17.11;	author mike;	state Exp;
branches;
next	1.79;

1.79
date	99.12.30.21.59.32;	author mike;	state Exp;
branches;
next	1.78;

1.78
date	99.12.30.15.59.52;	author jra;	state Exp;
branches;
next	1.77;

1.77
date	99.12.27.19.01.30;	author bparker;	state Exp;
branches;
next	1.76;

1.76
date	99.12.20.20.51.56;	author bparker;	state Exp;
branches;
next	1.75;

1.75
date	99.12.18.02.11.05;	author mike;	state Exp;
branches;
next	1.74;

1.74
date	99.12.01.16.01.47;	author bparker;	state Exp;
branches;
next	1.73;

1.73
date	99.11.19.02.34.14;	author mike;	state Exp;
branches;
next	1.72;

1.72
date	99.11.19.01.52.00;	author mike;	state Exp;
branches;
next	1.71;

1.71
date	99.11.18.23.17.34;	author mike;	state Exp;
branches;
next	1.70;

1.70
date	99.11.18.21.10.19;	author mike;	state Exp;
branches;
next	1.69;

1.69
date	99.11.18.20.49.39;	author mike;	state Exp;
branches;
next	1.68;

1.68
date	99.11.18.19.54.32;	author mike;	state Exp;
branches;
next	1.67;

1.67
date	99.11.18.03.51.08;	author mike;	state Exp;
branches;
next	1.66;

1.66
date	99.11.18.03.22.33;	author mike;	state Exp;
branches;
next	1.65;

1.65
date	99.11.18.02.42.18;	author mike;	state Exp;
branches;
next	1.64;

1.64
date	99.11.17.04.39.21;	author mike;	state Exp;
branches;
next	1.63;

1.63
date	99.11.17.03.44.16;	author mike;	state Exp;
branches;
next	1.62;

1.62
date	99.10.12.13.58.13;	author jra;	state Exp;
branches;
next	1.61;

1.61
date	99.05.10.21.30.48;	author mike;	state Exp;
branches;
next	1.60;

1.60
date	99.05.06.18.48.03;	author bparker;	state Exp;
branches;
next	1.59;

1.59
date	99.04.12.19.52.12;	author bparker;	state Exp;
branches;
next	1.58;

1.58
date	99.04.02.21.18.12;	author bparker;	state Exp;
branches;
next	1.57;

1.57
date	99.01.25.14.29.23;	author jra;	state Exp;
branches;
next	1.56;

1.56
date	99.01.21.19.41.43;	author jra;	state Exp;
branches;
next	1.55;

1.55
date	99.01.21.16.31.35;	author jra;	state Exp;
branches;
next	1.54;

1.54
date	99.01.12.01.53.24;	author mike;	state Exp;
branches;
next	1.53;

1.53
date	98.12.21.19.00.08;	author bparker;	state Exp;
branches;
next	1.52;

1.52
date	98.12.17.04.19.10;	author mike;	state Exp;
branches;
next	1.51;

1.51
date	98.08.12.20.58.46;	author bparker;	state Exp;
branches;
next	1.50;

1.50
date	98.08.12.20.21.38;	author jra;	state Exp;
branches;
next	1.49;

1.49
date	98.06.25.07.46.30;	author mike;	state Exp;
branches;
next	1.48;

1.48
date	98.05.12.17.44.20;	author mike;	state Exp;
branches;
next	1.47;

1.47
date	98.05.04.17.19.43;	author jra;	state Exp;
branches;
next	1.46;

1.46
date	98.03.26.07.44.54;	author mike;	state Exp;
branches;
next	1.45;

1.45
date	98.03.24.09.46.44;	author mike;	state Exp;
branches;
next	1.44;

1.44
date	98.03.24.09.18.54;	author mike;	state Exp;
branches;
next	1.43;

1.43
date	98.03.24.08.38.27;	author mike;	state Exp;
branches;
next	1.42;

1.42
date	98.03.24.07.13.22;	author mike;	state Exp;
branches;
next	1.41;

1.41
date	98.03.24.05.35.30;	author mike;	state Exp;
branches;
next	1.40;

1.40
date	98.03.24.05.11.02;	author mike;	state Exp;
branches;
next	1.39;

1.39
date	98.03.19.14.42.24;	author mike;	state Exp;
branches;
next	1.38;

1.38
date	98.03.19.14.08.40;	author mike;	state Exp;
branches;
next	1.37;

1.37
date	98.03.19.12.25.30;	author mike;	state Exp;
branches;
next	1.36;

1.36
date	98.03.19.12.19.22;	author mike;	state Exp;
branches;
next	1.35;

1.35
date	98.03.19.11.26.30;	author mike;	state Exp;
branches;
next	1.34;

1.34
date	98.03.19.11.17.06;	author mike;	state Exp;
branches;
next	1.33;

1.33
date	98.03.19.09.54.32;	author mike;	state Exp;
branches;
next	1.32;

1.32
date	98.03.19.09.39.57;	author mike;	state Exp;
branches;
next	1.31;

1.31
date	98.03.19.08.33.05;	author mike;	state Exp;
branches;
next	1.30;

1.30
date	98.03.19.07.25.39;	author mike;	state Exp;
branches;
next	1.29;

1.29
date	98.01.28.06.31.13;	author mike;	state Exp;
branches;
next	1.28;

1.28
date	97.12.23.06.00.13;	author mike;	state Exp;
branches;
next	1.27;

1.27
date	97.12.18.05.30.24;	author mike;	state Exp;
branches;
next	1.26;

1.26
date	97.12.18.05.15.26;	author mike;	state Exp;
branches;
next	1.25;

1.25
date	97.12.18.03.39.58;	author mike;	state Exp;
branches;
next	1.24;

1.24
date	97.11.21.06.12.02;	author mike;	state Exp;
branches;
next	1.23;

1.23
date	97.11.14.20.34.08;	author bparker;	state Exp;
branches;
next	1.22;

1.22
date	97.11.05.19.08.17;	author jra;	state Exp;
branches;
next	1.21;

1.21
date	97.11.05.15.16.51;	author mike;	state Exp;
branches;
next	1.20;

1.20
date	97.11.05.15.10.36;	author mike;	state Exp;
branches;
next	1.19;

1.19
date	97.06.30.13.46.28;	author gdurf;	state Exp;
branches;
next	1.18;

1.18
date	97.06.25.04.44.33;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	97.06.25.04.24.00;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	97.06.25.03.00.16;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	97.06.24.21.25.48;	author gdurf;	state Exp;
branches;
next	1.14;

1.14
date	97.06.20.03.48.12;	author gdurf;	state Exp;
branches;
next	1.13;

1.13
date	97.06.20.00.49.43;	author gdurf;	state Exp;
branches;
next	1.12;

1.12
date	97.06.04.20.16.48;	author gdurf;	state Exp;
branches;
next	1.11;

1.11
date	97.05.22.09.29.51;	author butler;	state Exp;
branches;
next	1.10;

1.10
date	97.03.12.17.29.00;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	97.03.07.10.43.42;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	97.03.07.10.32.36;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	97.03.07.10.30.45;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	97.03.07.10.28.04;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	97.03.07.08.37.07;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	97.03.06.08.40.58;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	97.03.06.07.34.23;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	97.03.05.06.43.47;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	97.03.05.04.04.45;	author mike;	state Exp;
branches;
next	;

1.86.2.1
date	2000.09.01.17.30.33;	author bparker;	state Exp;
branches;
next	;

1.104.2.1
date	2002.09.13.20.49.05;	author jra;	state Exp;
branches;
next	;

1.107.2.1
date	2002.09.19.18.01.47;	author morrison;	state Exp;
branches;
next	1.107.2.2;

1.107.2.2
date	2004.03.17.21.19.00;	author morrison;	state Exp;
branches;
next	;

1.107.4.1
date	2004.03.11.23.43.46;	author morrison;	state Exp;
branches;
next	;

1.110.6.1
date	2004.02.12.18.37.47;	author erikg;	state Exp;
branches;
next	1.110.6.2;

1.110.6.2
date	2004.03.15.14.07.30;	author erikg;	state Exp;
branches;
next	;


desc
@Tcl interfaces to LIBRT
@


1.114
log
@moved to src/
@
text
@/*
 *			T C L . C
 *
 *  Tcl interfaces to LIBRT routines.
 *
 *  LIBRT routines are not for casual command-line use;
 *  as a result, the Tcl name for the function should be exactly
 *  the same as the C name for the underlying function.
 *  Typing "rt_" is no hardship when writing Tcl procs, and
 *  clarifies the origin of the routine.
 *
 *  Authors -
 *	Michael John Muuss
 *      Glenn Durfee
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1997-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/tcl.c,v 1.113 2004/05/10 15:30:47 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <ctype.h>
#include <math.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "tcl.h"

#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "rtgeom.h"
#include "raytrace.h"
#include "externs.h"

#include "./debug.h"

/* defined in wdb_obj.c */
extern int Wdb_Init(Tcl_Interp *interp);

/* defined in dg_obj.c */
extern int Dgo_Init(Tcl_Interp *interp);

/* defined in view_obj.c */
extern int Vo_Init(Tcl_Interp *interp);

/************************************************************************
 *									*
 *		Tcl interface to Ray-tracing				*
 *									*
 ************************************************************************/

struct dbcmdstruct {
	char *cmdname;
	int (*cmdfunc)();
};

/*
 *			R T _ T C L _ P A R S E _ R A Y
 *
 *  Allow specification of a ray to trace, in two convenient formats.
 *
 *  Examples -
 *	{0 0 0} dir {0 0 -1}
 *	{20 -13.5 20} at {10 .5 3}
 */
int
rt_tcl_parse_ray( Tcl_Interp *interp, struct xray *rp, const char *const*argv )
{
	if( bn_decode_vect( rp->r_pt,  argv[0] ) != 3 )  {
		Tcl_AppendResult( interp,
			"badly formatted point: ", argv[0], (char *)NULL );
		return TCL_ERROR;
	}
	if( bn_decode_vect( rp->r_dir, argv[2] ) != 3 )  {
		Tcl_AppendResult( interp,
			"badly formatted vector: ", argv[2], (char *)NULL );
		return TCL_ERROR;
	}
	switch( argv[1][0] )  {
	case 'd':
		/* [2] is direction vector */
		break;
	case 'a':
		/* [2] is target point, build a vector from start pt */
		VSUB2( rp->r_dir, rp->r_dir, rp->r_pt );
		break;
	default:
		Tcl_AppendResult( interp,
				"wrong ray keyword: '", argv[1],
				"', should be one of 'dir' or 'at'",
				(char *)NULL );
		return TCL_ERROR;
	}
	VUNITIZE( rp->r_dir );
	return TCL_OK;
}

/*
 *			R T _ T C L _ P R _ C U T T E R
 *
 *  Format a "union cutter" structure in a TCL-friendly format.
 *  Useful for debugging space partitioning
 *
 *  Examples -
 *	type cutnode
 *	type boxnode
 *	type nugridnode
 */
void
rt_tcl_pr_cutter( Tcl_Interp *interp, const union cutter *cutp )
{
	static const char xyz[4] = "XYZ";
	struct bu_vls	str;
	int i;

	bu_vls_init(&str);

	switch( cutp->cut_type )  {
	case CUT_CUTNODE:
		bu_vls_printf( &str,
			"type cutnode axis %c point %.25G",
			xyz[cutp->cn.cn_axis], cutp->cn.cn_point );
		break;
	case CUT_BOXNODE:
		bu_vls_printf( &str,
			"type boxnode min {%.25G %.25G %.25G}",
			V3ARGS(cutp->bn.bn_min) );
		bu_vls_printf( &str,
			" max {%.25G %.25G %.25G}",
			V3ARGS(cutp->bn.bn_max) );
		bu_vls_printf( &str, " solids {");
		for( i=0; i < cutp->bn.bn_len; i++ )  {
			bu_vls_strcat( &str, cutp->bn.bn_list[i]->st_name );
			bu_vls_putc( &str, ' ' );
		}
		bu_vls_printf( &str, "} pieces {");
		for( i = 0; i < cutp->bn.bn_piecelen; i++ )  {
			struct rt_piecelist *plp = &cutp->bn.bn_piecelist[i];
			int j;
			RT_CK_PIECELIST(plp);
			/* These can be taken by user positionally */
			bu_vls_printf( &str, "{%s {", plp->stp->st_name );
			for( j=0; j < plp->npieces; j++ )  {
				bu_vls_printf( &str, "%ld ", plp->pieces[j] );
			}
			bu_vls_strcat( &str, "} } " );
		}
		bu_vls_strcat( &str, "}" );
		break;
	case CUT_NUGRIDNODE:
		bu_vls_printf( &str,
			"type nugridnode", (char *)NULL );
		for( i = 0; i < 3; i++ )  {
			bu_vls_printf( &str, " %c {", xyz[i] );
			bu_vls_printf( &str, "spos %.25G epos %.25G width %.25g",
				cutp->nugn.nu_axis[i]->nu_spos,
				cutp->nugn.nu_axis[i]->nu_epos,
				cutp->nugn.nu_axis[i]->nu_width );
			bu_vls_printf( &str, " cells_per_axis %d",
				cutp->nugn.nu_cells_per_axis );	
			bu_vls_printf( &str, " stepsize %d}",
				cutp->nugn.nu_stepsize );
		}
		break;
	default:
		bu_vls_printf( &str, "rt_tcl_pr_cutter() bad pointer cutp=x%x",
			cutp);
		break;
	}
	Tcl_AppendResult( interp, bu_vls_addr(&str), (char *)NULL );
	bu_vls_free( &str );
}

/*
 *			R T _ T C L _ C U T T E R
 *
 *  Obtain the 'n'th space partitioning cell along the given ray,
 *  and return that to the user.
 *
 *  Example -
 *	.rt cutter 7 {0 0 0} dir {0 0 -1}
 */
int
rt_tcl_cutter( ClientData clientData, Tcl_Interp *interp, int argc, const char *const*argv )
{
	struct application	*ap = (struct application *)clientData;
	struct rt_i		*rtip;
	const union cutter	*cutp;
	int			n;

	if( argc != 6 )  {
		Tcl_AppendResult( interp,
				"wrong # args: should be \"",
				argv[0], " ", argv[1], "cutnum {P} dir|at {V}\"",
				(char *)NULL );
		return TCL_ERROR;
	}

	RT_CK_AP_TCL(interp, ap);
	rtip = ap->a_rt_i;
	RT_CK_RTI_TCL(interp,rtip);

	n = atoi(argv[2]);
	if( rt_tcl_parse_ray( interp, &ap->a_ray, &argv[3] ) == TCL_ERROR )
		return TCL_ERROR;

	cutp = rt_cell_n_on_ray( ap, n );
	if( cutp == CUTTER_NULL )  {
		Tcl_AppendResult( interp, "rt_cell_n_on_ray() failed to find cell ", argv[2], (char *)NULL );
		return TCL_ERROR;
	}
	rt_tcl_pr_cutter( interp, cutp );
	return TCL_OK;
}

/*
 *			R T _ T C L _ P R _ H I T
 *
 *  Format a hit in a TCL-friendly format.
 *
 *  It is possible that a solid may have been removed from the
 *  directory after this database was prepped, so check pointers
 *  carefully.
 *
 *  It might be beneficial to use some format other than %g to
 *  give the user more precision.
 */
void
rt_tcl_pr_hit( Tcl_Interp *interp, struct hit *hitp, const struct seg *segp, const struct xray	*rayp, int flipflag )
{
	struct bu_vls	str;
	vect_t		norm;
	struct soltab	*stp;
	const struct directory	*dp;
	struct curvature crv;

	RT_CK_SEG(segp);
	stp = segp->seg_stp;
	RT_CK_SOLTAB(stp);
	dp = stp->st_dp;
	RT_CK_DIR(dp);

	RT_HIT_NORMAL( norm, hitp, stp, rayp, flipflag );
	RT_CURVATURE( &crv, hitp, flipflag, stp );

	bu_vls_init(&str);
	bu_vls_printf( &str, " {dist %g point {", hitp->hit_dist);
	bn_encode_vect( &str, hitp->hit_point );
	bu_vls_printf( &str, "} normal {" );
	bn_encode_vect( &str, norm );
	bu_vls_printf( &str, "} c1 %g c2 %g pdir {",
		crv.crv_c1, crv.crv_c2 );
	bn_encode_vect( &str, crv.crv_pdir );
	bu_vls_printf( &str, "} surfno %d", hitp->hit_surfno );
	if( stp->st_path.magic == DB_FULL_PATH_MAGIC )  {
		/* Magic is left 0 if the path is not filled in. */
		char	*sofar = db_path_to_string(&stp->st_path);
		bu_vls_printf( &str, " path ");
		bu_vls_strcat( &str, sofar );
		bu_free( (genptr_t)sofar, "path string" );
	}
	bu_vls_printf( &str, " solid %s}", dp->d_namep );

	Tcl_AppendResult( interp, bu_vls_addr( &str ), (char *)NULL );
	bu_vls_free( &str );
}

/*
 *			R T _ T C L _ A _ H I T
 */
int
rt_tcl_a_hit( struct application *ap,
	struct partition *PartHeadp,
	struct seg *segHeadp )
{
	Tcl_Interp *interp = (Tcl_Interp *)ap->a_uptr;
	register struct partition *pp;

	RT_CK_PT_HD(PartHeadp);

	for( pp=PartHeadp->pt_forw; pp != PartHeadp; pp = pp->pt_forw )  {
		RT_CK_PT(pp);
		Tcl_AppendResult( interp, "{in", (char *)NULL );
		rt_tcl_pr_hit( interp, pp->pt_inhit, pp->pt_inseg,
			&ap->a_ray, pp->pt_inflip );
		Tcl_AppendResult( interp, "\nout", (char *)NULL );
		rt_tcl_pr_hit( interp, pp->pt_outhit, pp->pt_outseg,
			&ap->a_ray, pp->pt_outflip );
		Tcl_AppendResult( interp,
			"\nregion ",
			pp->pt_regionp->reg_name,
			(char *)NULL );
		Tcl_AppendResult( interp, "}\n", (char *)NULL );
	}

	return 1;
}

/*
 *			R T _ T C L _ A _ M I S S
 */
int
rt_tcl_a_miss( struct application *ap )
{
	return 0;
}

/*
 *			R T _ T C L _ S H O O T R A Y
 *
 *  Usage -
 *	procname shootray [-R] {P} dir|at {V}
 *		-R option specifries no overlap reporting
 *
 *  Example -
 *	set glob_compat_mode 0
 *	.inmem rt_gettrees .rt all.g
 *	.rt shootray -R {0 0 0} dir {0 0 -1}
 *
 *	set tgt [bu_get_value_by_keyword V [concat type [.inmem get LIGHT]]]
 *	.rt shootray {20 -13.5 20} at $tgt
 *		
 *
 *  Returns -
 *	This "shootray" operation returns a nested set of lists. It returns
 *	a list of zero or more partitions. Inside each partition is a list
 *	containing an in, out, and region keyword, each with an associated
 *	value. The associated value for each "inhit" and "outhit" is itself
 *	a list containing a dist, point, normal, surfno, and solid keyword,
 *	each with an associated value.
 */
int
rt_tcl_rt_shootray(ClientData clientData, Tcl_Interp *interp, int argc, const char *const *argv)
{
	struct application	*ap = (struct application *)clientData;
	struct rt_i		*rtip;
	int			index;

	if( (argc != 5 && argc != 6) || (argc == 6 && strcmp( argv[2], "-R"))  )  {
		Tcl_AppendResult( interp,
				"wrong # args: should be \"",
				argv[0], " ", argv[1], " [-R] {P} dir|at {V}\"",
				(char *)NULL );
		return TCL_ERROR;
	}

	if( argc == 6 ) {
		ap->a_logoverlap = rt_silent_logoverlap;
		index = 3;
	} else {
		index = 2;
	}

	RT_CK_AP_TCL(interp, ap);
	rtip = ap->a_rt_i;
	RT_CK_RTI_TCL(interp,rtip);

	if( rt_tcl_parse_ray( interp, &ap->a_ray, &argv[index] ) == TCL_ERROR )
		return TCL_ERROR;
	ap->a_hit = rt_tcl_a_hit;
	ap->a_miss = rt_tcl_a_miss;
	ap->a_uptr = (genptr_t)interp;

	(void)rt_shootray( ap );

	return TCL_OK;
}

/*
 *			R T _ T C L _ R T _ O N E H I T
 *  Usage -
 *	procname onehit
 *	procname onehit #
 */
int
rt_tcl_rt_onehit(ClientData clientData, Tcl_Interp *interp, int argc, const char *const *argv)
{
	struct application	*ap = (struct application *)clientData;
	struct rt_i		*rtip;
	char			buf[64];

	if( argc < 2 || argc > 3 )  {
		Tcl_AppendResult( interp,
				"wrong # args: should be \"",
				argv[0], " ", argv[1], " [#]\"",
				(char *)NULL );
		return TCL_ERROR;
	}

	RT_CK_AP_TCL(interp, ap);
	rtip = ap->a_rt_i;
	RT_CK_RTI_TCL(interp,rtip);

	if( argc == 3 )  {
		ap->a_onehit = atoi(argv[2]);
	}
	sprintf(buf, "%d", ap->a_onehit );
	Tcl_AppendResult( interp, buf, (char *)NULL );
	return TCL_OK;
}

/*
 *			R T _ T C L _ R T _ N O _ B O O L
 *  Usage -
 *	procname no_bool
 *	procname no_bool #
 */
int
rt_tcl_rt_no_bool(ClientData clientData, Tcl_Interp *interp, int argc, const char *const *argv)
{
	struct application	*ap = (struct application *)clientData;
	struct rt_i		*rtip;
	char			buf[64];

	if( argc < 2 || argc > 3 )  {
		Tcl_AppendResult( interp,
				"wrong # args: should be \"",
				argv[0], " ", argv[1], " [#]\"",
				(char *)NULL );
		return TCL_ERROR;
	}

	RT_CK_AP_TCL(interp, ap);
	rtip = ap->a_rt_i;
	RT_CK_RTI_TCL(interp,rtip);

	if( argc == 3 )  {
		ap->a_no_booleans = atoi(argv[2]);
	}
	sprintf(buf, "%d", ap->a_no_booleans );
	Tcl_AppendResult( interp, buf, (char *)NULL );
	return TCL_OK;
}

/*
 *			R T _ T C L _ R T _ C H E C K
 *
 *  Run some of the internal consistency checkers over the data structures.
 *
 *  Usage -
 *	procname check
 */
int
rt_tcl_rt_check(ClientData clientData, Tcl_Interp *interp, int argc, const char *const *argv)
{
	struct application	*ap = (struct application *)clientData;
	struct rt_i		*rtip;

	if( argc != 2 )  {
		Tcl_AppendResult( interp,
				"wrong # args: should be \"",
				argv[0], " ", argv[1], "\"",
				(char *)NULL );
		return TCL_ERROR;
	}

	RT_CK_AP_TCL(interp, ap);
	rtip = ap->a_rt_i;
	RT_CK_RTI_TCL(interp,rtip);

	rt_ck(rtip);

	return TCL_OK;
}

/*
 *			R T _ T C L _ R T _ P R E P
 *
 *  When run with no args, just prints current status of prepping.
 *
 *  Usage -
 *	procname prep
 *	procname prep use_air [hasty_prep]
 */
int
rt_tcl_rt_prep(ClientData clientData, Tcl_Interp *interp, int argc, const char *const *argv)
{
	struct application	*ap = (struct application *)clientData;
	struct rt_i		*rtip;
	struct bu_vls		str;

	if( argc < 2 || argc > 4 )  {
		Tcl_AppendResult( interp,
				"wrong # args: should be \"",
				argv[0], " ", argv[1],
				" [hasty_prep]\"",
				(char *)NULL );
		return TCL_ERROR;
	}

	RT_CK_AP_TCL(interp, ap);
	rtip = ap->a_rt_i;
	RT_CK_RTI_TCL(interp,rtip);

	if( argc >= 3 && !rtip->needprep )  {
		Tcl_AppendResult( interp,
			argv[0], " ", argv[1],
			" invoked when model has already been prepped.\n",
			(char *)NULL );
		return TCL_ERROR;
	}

	if( argc == 4 )  rtip->rti_hasty_prep = atoi(argv[3]);

	/* If args were given, prep now. */
	if( argc >= 3 )  rt_prep_parallel( rtip, 1 );

	/* Now, describe the current state */
	bu_vls_init( &str );
	bu_vls_printf( &str, "hasty_prep %d dont_instance %d useair %d needprep %d",
		rtip->rti_hasty_prep,
		rtip->rti_dont_instance,
		rtip->useair,
		rtip->needprep
	);

	bu_vls_printf( &str, " space_partition_type %s n_nugridnode %d n_cutnode %d n_boxnode %d n_empty %d",
		rtip->rti_space_partition == RT_PART_NUGRID ?
			"NUGrid" : "NUBSP",
		rtip->rti_ncut_by_type[CUT_NUGRIDNODE],
		rtip->rti_ncut_by_type[CUT_CUTNODE],
		rtip->rti_ncut_by_type[CUT_BOXNODE],
		rtip->nempty_cells );
	bu_vls_printf( &str, " maxdepth %d maxlen %d",
		rtip->rti_cut_maxdepth,
		rtip->rti_cut_maxlen );
	if( rtip->rti_ncut_by_type[CUT_BOXNODE] )  bu_vls_printf( &str, " avglen %g",
		((double)rtip->rti_cut_totobj) /
		rtip->rti_ncut_by_type[CUT_BOXNODE] );

	Tcl_AppendResult( interp, bu_vls_addr(&str), (char *)NULL );
	bu_vls_free( &str );
	return TCL_OK;
}

static struct dbcmdstruct rt_tcl_rt_cmds[] = {
	{"shootray",	rt_tcl_rt_shootray},
	{"onehit",	rt_tcl_rt_onehit},
	{"no_bool",	rt_tcl_rt_no_bool},
	{"check",	rt_tcl_rt_check},
	{"prep",	rt_tcl_rt_prep},
	{"cutter",	rt_tcl_cutter},
	{(char *)0,	(int (*)())0}
};

/*
 *			R T _ T C L _ R T
 *
 * Generic interface for the LIBRT_class manipulation routines.
 * Usage:
 *        procname dbCmdName ?args?
 * Returns: result of cmdName LIBRT operation.
 *
 * Objects of type 'procname' must have been previously created by 
 * the 'rt_gettrees' operation performed on a database object.
 *
 * Example -
 *	.inmem rt_gettrees .rt all.g
 *	.rt shootray {0 0 0} dir {0 0 -1}
 */
int
rt_tcl_rt(ClientData clientData, Tcl_Interp *interp, int argc, const char *const *argv)
{
	struct dbcmdstruct	*dbcmd;

	if( argc < 2 ) {
		Tcl_AppendResult( interp,
				  "wrong # args: should be \"", argv[0],
				  " command [args...]\"",
				  (char *)NULL );
		return TCL_ERROR;
	}

	for( dbcmd = rt_tcl_rt_cmds; dbcmd->cmdname != NULL; dbcmd++ ) {
		if( strcmp(dbcmd->cmdname, argv[1]) == 0 ) {
			return (*dbcmd->cmdfunc)( clientData, interp,
						  argc, argv );
		}
	}


	Tcl_AppendResult( interp, "unknown LIBRT command '",
			argv[1], "'; must be one of:",
			(char *)NULL );
	for( dbcmd = rt_tcl_rt_cmds; dbcmd->cmdname != NULL; dbcmd++ ) {
		Tcl_AppendResult( interp, " ", dbcmd->cmdname, (char *)NULL );
	}
	return TCL_ERROR;
}

/************************************************************************
 *									*
 *		Tcl interface to Combination import/export		*
 *									*
 ************************************************************************/

/*
 *		D B _ T C L _ T R E E _ D E S C R I B E
 *
 * Fills a Tcl_DString with a representation of the given tree appropriate
 * for processing by Tcl scripts.  The reason we use Tcl_DStrings instead
 * of bu_vlses is that Tcl_DStrings provide "start/end sublist" commands
 * and automatic escaping of Tcl-special characters.
 *
 * A tree 't' is represented in the following manner:
 *
 *	t := { l dbobjname { mat } }
 *	   | { l dbobjname }
 *	   | { u t1 t2 }
 * 	   | { n t1 t2 }
 *	   | { - t1 t2 }
 *	   | { ^ t1 t2 }
 *         | { ! t1 }
 *	   | { G t1 }
 *	   | { X t1 }
 *	   | { N }
 *	   | {}
 *
 * where 'dbobjname' is a string containing the name of a database object,
 *       'mat'       is the matrix preceeding a leaf,
 *       't1', 't2'  are trees (recursively defined).
 *
 * Notice that in most cases, this tree will be grossly unbalanced.
 */

void
db_tcl_tree_describe(Tcl_DString *dsp, const union tree *tp)
{
	if( !tp ) return;

	RT_CK_TREE(tp);
	switch( tp->tr_op ) {
	case OP_DB_LEAF:
		Tcl_DStringAppendElement( dsp, "l" );
		Tcl_DStringAppendElement( dsp, tp->tr_l.tl_name );
		if( tp->tr_l.tl_mat )  {
			struct bu_vls vls;
			bu_vls_init( &vls );
			bn_encode_mat( &vls, tp->tr_l.tl_mat );
			Tcl_DStringAppendElement( dsp, bu_vls_addr(&vls) );
			bu_vls_free( &vls );
		}
		break;

		/* This node is known to be a binary op */
	case OP_UNION:
		Tcl_DStringAppendElement( dsp, "u" );
		goto bin;
	case OP_INTERSECT:
		Tcl_DStringAppendElement( dsp, "n" );
		goto bin;
	case OP_SUBTRACT:
		Tcl_DStringAppendElement( dsp, "-" );
		goto bin;
	case OP_XOR:
		Tcl_DStringAppendElement( dsp, "^" );
	bin:
		Tcl_DStringStartSublist( dsp );
		db_tcl_tree_describe( dsp, tp->tr_b.tb_left );
		Tcl_DStringEndSublist( dsp );

		Tcl_DStringStartSublist( dsp );
		db_tcl_tree_describe( dsp, tp->tr_b.tb_right );
		Tcl_DStringEndSublist( dsp );

		break;

		/* This node is known to be a unary op */
	case OP_NOT:
		Tcl_DStringAppendElement( dsp, "!" );
		goto unary;
	case OP_GUARD:
		Tcl_DStringAppendElement( dsp, "G" );
		goto unary;
	case OP_XNOP:
		Tcl_DStringAppendElement( dsp, "X" );
	unary:
		Tcl_DStringStartSublist( dsp );
		db_tcl_tree_describe( dsp, tp->tr_b.tb_left );
		Tcl_DStringEndSublist( dsp );
		break;
			
	case OP_NOP:
		Tcl_DStringAppendElement( dsp, "N" );
		break;

	default:
		bu_log("db_tcl_tree_describe: bad op %d\n", tp->tr_op);
		bu_bomb("db_tcl_tree_describe\n");
	}
}

/*
 *			D B _ T C L _ T R E E _ P A R S E
 *
 *  Take a TCL-style string description of a binary tree, as produced by
 *  db_tcl_tree_describe(), and reconstruct
 *  the in-memory form of that tree.
 */
union tree *
db_tcl_tree_parse( Tcl_Interp *interp, const char *str, struct resource *resp )
{
	int	argc;
	char	**argv;
	union tree	*tp = TREE_NULL;

	/* Skip over leading spaces in input */
	while( *str && isspace(*str) ) str++;

	if( Tcl_SplitList( interp, str, &argc, (const char ***)&argv ) != TCL_OK )
		return TREE_NULL;

	if( argc <= 0 || argc > 3 )  {
		Tcl_AppendResult( interp, "db_tcl_tree_parse: tree node does not have 1, 2 or 2 elements: ",
			str, "\n", (char *)NULL );
		goto out;
	}

#if 0
Tcl_AppendResult( interp, "\n\ndb_tcl_tree_parse(): ", str, "\n", NULL );

Tcl_AppendResult( interp, "db_tcl_tree_parse() arg0=", argv[0], NULL );
if(argc > 1 ) Tcl_AppendResult( interp, "\n\targ1=", argv[1], NULL );
if(argc > 2 ) Tcl_AppendResult( interp, "\n\targ2=", argv[2], NULL );
Tcl_AppendResult( interp, "\n\n", NULL);
#endif

	if( argv[0][1] != '\0' )  {
		Tcl_AppendResult( interp, "db_tcl_tree_parse() operator is not single character: ",
			argv[0], (char *)NULL );
		goto out;
	}

	switch( argv[0][0] )  {
	case 'l':
		/* Leaf node: {l name {mat}} */
		RT_GET_TREE( tp, resp );
		tp->tr_l.magic = RT_TREE_MAGIC;
		tp->tr_op = OP_DB_LEAF;
		tp->tr_l.tl_name = bu_strdup( argv[1] );
		/* If matrix not specified, NULL pointer ==> identity matrix */
		tp->tr_l.tl_mat = NULL;
		if( argc == 3 )  {
			mat_t	m;
			/* decode also recognizes "I" notation for identity */
			if( bn_decode_mat( m, argv[2] ) != 16 )  {
				Tcl_AppendResult( interp, "db_tcl_tree_parse: unable to parse matrix '",
					argv[2], "', using identity", (char *)NULL );
				break;
			}
			if( bn_mat_is_identity(m) )
				break;
			if( bn_mat_ck( "db_tcl_tree_parse", m ) )  {
				Tcl_AppendResult( interp, "db_tcl_tree_parse: matrix '",
					argv[2],
					"', does not preserve axis perpendicularity, using identity", (char *)NULL );
				break;
			}
			/* Finall, a good non-identity matrix, dup & save it */
			tp->tr_l.tl_mat = bn_mat_dup(m);
		}
		break;

	case 'u':
		/* Binary: Union: {u {lhs} {rhs}} */
		RT_GET_TREE( tp, resp );
		tp->tr_b.tb_op = OP_UNION;
		goto binary;
	case 'n':
		/* Binary: Intersection */
		RT_GET_TREE( tp, resp );
		tp->tr_b.tb_op = OP_INTERSECT;
		goto binary;
	case '-':
		/* Binary: Union */
		RT_GET_TREE( tp, resp );
		tp->tr_b.tb_op = OP_SUBTRACT;
		goto binary;
	case '^':
		/* Binary: Xor */
		RT_GET_TREE( tp, resp );
		tp->tr_b.tb_op = OP_XOR;
		goto binary;
binary:
		tp->tr_b.magic = RT_TREE_MAGIC;
		if( argv[1] == (char *)NULL || argv[2] == (char *)NULL )  {
			Tcl_AppendResult( interp, "db_tcl_tree_parse: binary operator ",
				argv[0], " has insufficient operands in ",
				str, (char *)NULL );
			RT_FREE_TREE( tp, resp );
			tp = TREE_NULL;
			goto out;
		}
		tp->tr_b.tb_left = db_tcl_tree_parse( interp, argv[1], resp );
		if( tp->tr_b.tb_left == TREE_NULL )  {
			RT_FREE_TREE( tp, resp );
			tp = TREE_NULL;
			goto out;
		}
		tp->tr_b.tb_right = db_tcl_tree_parse( interp, argv[2], resp );
		if( tp->tr_b.tb_left == TREE_NULL )  {
			db_free_tree( tp->tr_b.tb_left, resp );
			RT_FREE_TREE( tp, resp );
			tp = TREE_NULL;
			goto out;
		}
		break;

	case '!':
		/* Unary: not {! {lhs}} */
		RT_GET_TREE( tp, resp );
		tp->tr_b.tb_op = OP_NOT;
		goto unary;
	case 'G':
		/* Unary: GUARD {G {lhs}} */
		RT_GET_TREE( tp, resp );
		tp->tr_b.tb_op = OP_GUARD;
		goto unary;
	case 'X':
		/* Unary: XNOP {X {lhs}} */
		RT_GET_TREE( tp, resp );
		tp->tr_b.tb_op = OP_XNOP;
		goto unary;
unary:
		tp->tr_b.magic = RT_TREE_MAGIC;
		if( argv[1] == (char *)NULL )  {
			Tcl_AppendResult( interp, "db_tcl_tree_parse: unary operator ",
				argv[0], " has insufficient operands in ",
				str, "\n", (char *)NULL );
			bu_free( (char *)tp, "union tree" );
			tp = TREE_NULL;
			goto out;
		}
		tp->tr_b.tb_left = db_tcl_tree_parse( interp, argv[1], resp );
		if( tp->tr_b.tb_left == TREE_NULL )  {
			bu_free( (char *)tp, "union tree" );
			tp = TREE_NULL;
			goto out;
		}
		break;

	case 'N':
		/* NOP: no args.  {N} */
		RT_GET_TREE( tp, resp );
		tp->tr_b.tb_op = OP_XNOP;
		tp->tr_b.magic = RT_TREE_MAGIC;
		break;

	default:
		Tcl_AppendResult( interp, "db_tcl_tree_parse: unable to interpret operator '",
			argv[1], "'\n", (char *)NULL );
	}

out:
	free( (char *)argv);		/* not bu_free() */
	return tp;
}

/*
 *			R T _ C O M B _ T C L G E T
 *
 *  Sets the interp->result string to a description of the given combination.
 *  Entered via rt_functab[].ft_tclget().
 */
int
rt_comb_tclget(Tcl_Interp *interp, const struct rt_db_internal *intern, const char *item)
{
	const struct rt_comb_internal *comb;
	char buf[128];
	Tcl_DString	ds;

	RT_CK_DB_INTERNAL(intern);
	comb = (struct rt_comb_internal *)intern->idb_ptr;
	RT_CK_COMB_TCL(interp,comb);

	if( item==0 ) {
		/* Print out the whole combination. */
		Tcl_DStringInit( &ds );

		Tcl_DStringAppendElement( &ds, "comb" );
		Tcl_DStringAppendElement( &ds, "region" );
		if( comb->region_flag ) {
			Tcl_DStringAppendElement( &ds, "yes" );

			Tcl_DStringAppendElement( &ds, "id" );
			sprintf( buf, "%d", comb->region_id );
			Tcl_DStringAppendElement( &ds, buf );

			if( comb->aircode )  {
				Tcl_DStringAppendElement( &ds, "air" );
				sprintf( buf, "%d", comb->aircode );
				Tcl_DStringAppendElement( &ds, buf );
			}
			if( comb->los )  {
				Tcl_DStringAppendElement( &ds, "los" );
				sprintf( buf, "%d", comb->los );
				Tcl_DStringAppendElement( &ds, buf );
			}

			if( comb->GIFTmater )  {
				Tcl_DStringAppendElement( &ds, "GIFTmater" );
				sprintf( buf, "%d", comb->GIFTmater );
				Tcl_DStringAppendElement( &ds, buf );
			}
		} else {
			Tcl_DStringAppendElement( &ds, "no" );
		}
		
		if( comb->rgb_valid ) {
			Tcl_DStringAppendElement( &ds, "rgb" );
			sprintf( buf, "%d %d %d", V3ARGS(comb->rgb) );
			Tcl_DStringAppendElement( &ds, buf );
		}

		if( bu_vls_strlen(&comb->shader) > 0 )  {
			Tcl_DStringAppendElement( &ds, "shader" );
			Tcl_DStringAppendElement( &ds, bu_vls_addr(&comb->shader) );
		}

		if( bu_vls_strlen(&comb->material) > 0 )  {
			Tcl_DStringAppendElement( &ds, "material" );
			Tcl_DStringAppendElement( &ds, bu_vls_addr(&comb->material) );
		}

		if( comb->inherit ) {
			Tcl_DStringAppendElement( &ds, "inherit" );
			Tcl_DStringAppendElement( &ds, "yes" );
		}

		Tcl_DStringAppendElement( &ds, "tree" );
		Tcl_DStringStartSublist( &ds );
		db_tcl_tree_describe( &ds, comb->tree );
		Tcl_DStringEndSublist( &ds );

		Tcl_DStringResult( interp, &ds );
		Tcl_DStringFree( &ds );

		return TCL_OK;
	} else {
		/* Print out only the requested item. */
		register int i;
		char itemlwr[128];

		for( i = 0; i < 128 && item[i]; i++ ) {
			itemlwr[i] = (isupper(item[i]) ? tolower(item[i]) :
				      item[i]);
		}
		itemlwr[i] = 0;

		if( strcmp(itemlwr, "region")==0 ) {
			strcpy( buf, comb->region_flag ? "yes" : "no" );
		} else if( strcmp(itemlwr, "id")==0 ) {
			if( !comb->region_flag ) goto not_region;
			sprintf( buf, "%d", comb->region_id );
		} else if( strcmp(itemlwr, "air")==0 ) {
			if( !comb->region_flag ) goto not_region;
			sprintf( buf, "%d", comb->aircode );
		} else if( strcmp(itemlwr, "los")==0 ) {
			if( !comb->region_flag ) goto not_region;
			sprintf( buf, "%d", comb->los );
		} else if( strcmp(itemlwr, "giftmater")==0 ) {
			if( !comb->region_flag ) goto not_region;
			sprintf( buf, "%d", comb->GIFTmater );
		} else if( strcmp(itemlwr, "rgb")==0 ) {
			if( comb->rgb_valid )
				sprintf( buf, "%d %d %d", V3ARGS(comb->rgb) );
			else
				strcpy( buf, "invalid" );
		} else if( strcmp(itemlwr, "shader")==0 ) {
			Tcl_AppendResult( interp, bu_vls_addr(&comb->shader),
					  (char *)NULL );
			return TCL_OK;
		} else if( strcmp(itemlwr, "material")==0 ) {
			Tcl_AppendResult( interp, bu_vls_addr(&comb->material),
					  (char *)NULL );
			return TCL_OK;
		} else if( strcmp(itemlwr, "inherit")==0 ) {
			strcpy( buf, comb->inherit ? "yes" : "no" );
		} else if( strcmp(itemlwr, "tree")==0 ) {
			Tcl_DStringInit( &ds );
			db_tcl_tree_describe( &ds, comb->tree );
			Tcl_DStringResult( interp, &ds );
			Tcl_DStringFree( &ds );
			return TCL_OK;
		} else {
			Tcl_AppendResult( interp, "no such attribute",
					  (char *)NULL );
			return TCL_ERROR;
		}

		Tcl_AppendResult( interp, buf, (char *)NULL );
		return TCL_OK;

	not_region:
		Tcl_AppendResult( interp, "item not valid for non-region",
				  (char *)NULL );
		return TCL_ERROR;
	}
}


/*
 *			R T _ C O M B _ T C L A D J U S T
 *
 *  Example -
 *	rgb "1 2 3" ...
 *
 *  Invoked via rt_functab[ID_COMBINATION].ft_tcladjust()
 */
int
rt_comb_tcladjust(
	Tcl_Interp		*interp,
	struct rt_db_internal	*intern,
	int			argc,
	char			**argv,
	struct resource		*resp )
{
	struct rt_comb_internal	       *comb;
	char	buf[128];
	int	i;
	double	d;

	RT_CK_DB_INTERNAL(intern);
	RT_CK_RESOURCE(resp);
	comb = (struct rt_comb_internal *)intern->idb_ptr;
	RT_CK_COMB(comb);

	while( argc >= 2 ) {
		/* Force to lower case */
		for( i=0; i<128 && argv[0][i]!='\0'; i++ )
			buf[i] = isupper(argv[0][i])?tolower(argv[0][i]):argv[0][i];
		buf[i] = 0;

		if( strcmp(buf, "region")==0 ) {
			if( strcmp( argv[1], "none" ) == 0 )
				comb->region_flag = 0;
			else
			{
				if( Tcl_GetBoolean( interp, argv[1], &i )!= TCL_OK )
					return TCL_ERROR;
				comb->region_flag = (char)i;
			}
		} else if( strcmp(buf, "temp")==0 ) {
			if( !comb->region_flag ) goto not_region;
			if( strcmp( argv[1], "none" ) == 0 )
				comb->temperature = 0.0;
			else
			{
				if( Tcl_GetDouble( interp, argv[1], &d ) != TCL_OK )
					return TCL_ERROR;
				comb->temperature = (float)d;
			}
		} else if( strcmp(buf, "id")==0 ) {
			if( !comb->region_flag ) goto not_region;
			if( strcmp( argv[1], "none" ) == 0 )
				comb->region_id = 0;
			else
			{
				if( Tcl_GetInt( interp, argv[1], &i ) != TCL_OK )
					return TCL_ERROR;
				comb->region_id = (short)i;
			}
		} else if( strcmp(buf, "air")==0 ) {
			if( !comb->region_flag ) goto not_region;
			if( strcmp( argv[1], "none" ) == 0 )
				comb->aircode = 0;
			else
			{
				if( Tcl_GetInt( interp, argv[1], &i ) != TCL_OK)
					return TCL_ERROR;
				comb->aircode = (short)i;
			}
		} else if( strcmp(buf, "los")==0 ) {
			if( !comb->region_flag ) goto not_region;
			if( strcmp( argv[1], "none" ) == 0 )
				comb->los = 0;
			else
			{
				if( Tcl_GetInt( interp, argv[1], &i ) != TCL_OK )
					return TCL_ERROR;
				comb->los = (short)i;
			}
		} else if( strcmp(buf, "giftmater")==0 ) {
			if( !comb->region_flag ) goto not_region;
			if( strcmp( argv[1], "none" ) == 0 )
				comb->GIFTmater = 0;
			else
			{
				if( Tcl_GetInt( interp, argv[1], &i ) != TCL_OK )
					return TCL_ERROR;
				comb->GIFTmater = (short)i;
			}
		} else if( strcmp(buf, "rgb")==0 ) {
			if( strcmp(argv[1], "invalid")==0 || strcmp( argv[1], "none" ) == 0 ) {
				comb->rgb[0] = comb->rgb[1] =
					comb->rgb[2] = 0;
				comb->rgb_valid = 0;
			} else {
				unsigned int r, g, b;
				i = sscanf( argv[1], "%u %u %u",
					&r, &g, &b );
				if( i != 3 )   {
					Tcl_AppendResult( interp, "adjust rgb ",
						argv[1], ": not valid rgb 3-tuple\n", (char *)NULL );
					return TCL_ERROR;
				}
				comb->rgb[0] = (unsigned char)r;
				comb->rgb[1] = (unsigned char)g;
				comb->rgb[2] = (unsigned char)b;
				comb->rgb_valid = 1;
			}
		} else if( strcmp(buf, "shader" )==0 ) {
			bu_vls_trunc( &comb->shader, 0 );
			if( strcmp( argv[1], "none" ) )
			{
				bu_vls_strcat( &comb->shader, argv[1] );
				/* Leading spaces boggle the combination exporter */
				bu_vls_trimspace( &comb->shader );
			}
		} else if( strcmp(buf, "material" )==0 ) {
			bu_vls_trunc( &comb->material, 0 );
			if( strcmp( argv[1], "none" ) )
			{
				bu_vls_strcat( &comb->material, argv[1] );
				bu_vls_trimspace( &comb->material );
			}
		} else if( strcmp(buf, "inherit" )==0 ) {
			if( strcmp( argv[1], "none" ) == 0 )
				comb->inherit = 0;
			else
			{
				if( Tcl_GetBoolean( interp, argv[1], &i ) != TCL_OK )
					return TCL_ERROR;
				comb->inherit = (char)i;
			}
		} else if( strcmp(buf, "tree" )==0 ) {
			union tree	*new;

			if( *argv[1] == '\0' || strcmp( argv[1], "none" ) == 0 )
			{
				if( comb->tree ) {
					db_free_tree( comb->tree, resp );
				}
				comb->tree = TREE_NULL;
			}
			else
			{
				new = db_tcl_tree_parse( interp, argv[1], resp );
				if( new == TREE_NULL )  {
					Tcl_AppendResult( interp, "db adjust tree: bad tree '",
						argv[1], "'\n", (char *)NULL );
					return TCL_ERROR;
				}
				if( comb->tree )
					db_free_tree( comb->tree, resp );
				comb->tree = new;
			}
		} else {
			Tcl_AppendResult( interp, "db adjust ", buf,
					  ": no such attribute",
					  (char *)NULL );
			return TCL_ERROR;
		}
		argc -= 2;
		argv += 2;
	}

	return TCL_OK;

 not_region:
	Tcl_AppendResult( interp, "adjusting attribute ",
		buf, " is not valid for a non-region combination.",
			  (char *)NULL );
	return TCL_ERROR;
}

/************************************************************************************************
 *												*
 *			Tcl interface to the Database						*
 *												*
 ************************************************************************************************/

/*
 *			R T _ T C L _ I M P O R T _ F R O M _ P A T H
 *
 *  Given the name of a database object or a full path to a leaf object,
 *  obtain the internal form of that leaf.
 *  Packaged separately mainly to make available nice Tcl error handling.
 *
 *  Returns -
 *	TCL_OK
 *	TCL_ERROR
 */
int
rt_tcl_import_from_path(Tcl_Interp *interp, struct rt_db_internal *ip, const char *path, struct rt_wdb *wdb)
{
	struct db_i	*dbip;
	int		status;

	/* Can't run RT_CK_DB_INTERNAL(ip), it hasn't been filled in yet */
	RT_CK_WDB(wdb);
	dbip = wdb->dbip;
	RT_CK_DBI(dbip);

#if 0
	dp = db_lookup( dbip, path, LOOKUP_QUIET );
	if( dp == NULL ) {
		Tcl_AppendResult( interp, path, ": not found\n",
				  (char *)NULL );
		return TCL_ERROR;
	}

	status = rt_db_get_internal( ip, dp, dbip, (matp_t)NULL );
	if( status < 0 ) {
		Tcl_AppendResult( interp, "rt_tcl_import_from_path failure: ",
				  path, (char *)NULL );
		return TCL_ERROR;
	}
#else
	if( strchr( path, '/' ) )
	{
		/* This is a path */
		struct db_tree_state	ts;
		struct db_full_path	old_path;
		struct db_full_path	new_path;
		struct directory	*dp_curr;
		int			ret;

		db_init_db_tree_state( &ts, dbip, &rt_uniresource );
		db_full_path_init(&old_path);
		db_full_path_init(&new_path);

		if( db_string_to_path( &new_path, dbip, path ) < 0 )  {
			Tcl_AppendResult(interp, "rt_tcl_import_from_path: '",
				path, "' contains unknown object names\n", (char *)NULL);
			return TCL_ERROR;
		}

		dp_curr = DB_FULL_PATH_CUR_DIR( &new_path );
		ret = db_follow_path( &ts, &old_path, &new_path, LOOKUP_NOISY, 0 );
		db_free_full_path( &old_path );
		db_free_full_path( &new_path );

		if( ret < 0 )  {
			Tcl_AppendResult(interp, "rt_tcl_import_from_path: '",
				path, "' is a bad path\n", (char *)NULL );
			return TCL_ERROR;
		}

		status = wdb_import( wdb, ip, dp_curr->d_namep, ts.ts_mat );
		if( status == -4 )  {
			Tcl_AppendResult( interp, dp_curr->d_namep,
					" not found in path ", path, "\n",
					(char *)NULL );
			return TCL_ERROR;
		}
		if( status < 0 ) {
			Tcl_AppendResult( interp, "wdb_import failure: ",
					  dp_curr->d_namep, (char *)NULL );
			return TCL_ERROR;
		}
	}
	else
	{
		status = wdb_import( wdb, ip, path, (matp_t)NULL );
		if( status == -4 )  {
			Tcl_AppendResult( interp, path, ": not found\n",
					  (char *)NULL );
			return TCL_ERROR;
		}
		if( status < 0 ) {
			Tcl_AppendResult( interp, "wdb_import failure: ",
					  path, (char *)NULL );
			return TCL_ERROR;
		}
	}
#endif
	return TCL_OK;
}

/*
 *			R T _ P A R S E T A B _ T C L G E T
 *
 *  This is the generic routine to be listed in rt_functab[].ft_tclget
 *  for those solid types which are fully described by their ft_parsetab
 *  entry.
 *
 *  'attr' is specified to retrieve only one attribute, rather than all.
 *  Example:  "db get ell.s B" to get only the B vector.
 */
int
rt_parsetab_tclget(Tcl_Interp *interp, const struct rt_db_internal *intern, const char *attr)
{
	register const struct bu_structparse	*sp = NULL;
	register const struct rt_functab	*ftp;
	int                     status;
	Tcl_DString             ds;
	struct bu_vls           str;

	RT_CK_DB_INTERNAL( intern );
	ftp = intern->idb_meth;
	RT_CK_FUNCTAB(ftp);

	sp = ftp->ft_parsetab;
	if( !sp )  {
		Tcl_AppendResult( interp, ftp->ft_label,
 " {a Tcl output routine for this type of object has not yet been implemented}",
		  (char *)NULL );
		return TCL_ERROR;
	}

	bu_vls_init( &str );
	Tcl_DStringInit( &ds );

	if( attr == (char *)0 ) {
		/* Print out solid type and all attributes */
		Tcl_DStringAppendElement( &ds, ftp->ft_label );
		while( sp->sp_name != NULL ) {
			Tcl_DStringAppendElement( &ds, sp->sp_name );
			bu_vls_trunc( &str, 0 );
			bu_vls_struct_item( &str, sp,
					 (char *)intern->idb_ptr, ' ' );
			Tcl_DStringAppendElement( &ds, bu_vls_addr(&str) );
			++sp;
		}
		status = TCL_OK;
	} else {
		if( bu_vls_struct_item_named( &str, sp, attr,
				   (char *)intern->idb_ptr, ' ') < 0 ) {
			bu_vls_printf(&str,
				"Objects of type %s do not have a %s attribute.",
				ftp->ft_label, attr);
			status = TCL_ERROR;
		} else {
			status = TCL_OK;
		}
		Tcl_DStringAppend( &ds, bu_vls_addr(&str), -1 );
	}

	Tcl_DStringResult( interp, &ds );
	Tcl_DStringFree( &ds );
	bu_vls_free( &str );

	return status;
}

/*
 *			R T _ C O M B _ T C L F O R M
 */
int
rt_comb_tclform(const struct rt_functab *ftp, Tcl_Interp *interp)
{
	RT_CK_FUNCTAB(ftp);

	Tcl_AppendResult( interp,
"region {%s} id {%d} air {%d} los {%d} GIFTmater {%d} rgb {%d %d %d} \
shader {%s} material {%s} inherit {%s} tree {%s}", (char *)NULL );
	return TCL_OK;
}

/*
 *			R T _ C O M B _ M A K E
 *
 *  Create a blank combination with appropriate values.
 *
 *  Called via rt_functab[ID_COMBINATION].ft_make().
 */
void
rt_comb_make(const struct rt_functab *ftp, struct rt_db_internal *intern, double diameter)
{
	struct rt_comb_internal *comb;

	intern->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	intern->idb_type = ID_COMBINATION;
	intern->idb_meth = &rt_functab[ID_COMBINATION];
	intern->idb_ptr = bu_calloc( sizeof(struct rt_comb_internal), 1,
					    "rt_comb_internal" );

	comb = (struct rt_comb_internal *)intern->idb_ptr;
	comb->magic = (long)RT_COMB_MAGIC;
	comb->temperature = -1;
	comb->tree = (union tree *)0;
	comb->region_flag = 1;
	comb->region_id = 0;
	comb->aircode = 0;
	comb->GIFTmater = 0;
	comb->los = 0;
	comb->rgb_valid = 0;
	comb->rgb[0] = comb->rgb[1] = comb->rgb[2] = 0;
	bu_vls_init( &comb->shader );
	bu_vls_init( &comb->material );
	comb->inherit = 0;
}

/*
 *			R T _ G E N E R I C _ M A K E
 *
 *  This one assumes that making all the parameters null is fine.
 *  (More generally, diameter == 0 means make 'em all zero, otherwise
 *  build something interesting to look at.)
 */
void
rt_generic_make(const struct rt_functab *ftp, struct rt_db_internal *intern, double diameter)
{
	intern->idb_type = ftp - rt_functab;
	intern->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	BU_ASSERT(&rt_functab[intern->idb_type] == ftp);

	intern->idb_meth = ftp;
	intern->idb_ptr = bu_calloc( ftp->ft_internal_size, 1, "rt_generic_make");
	*((long *)(intern->idb_ptr)) = ftp->ft_internal_magic;
}

/*
 *			R T _ P A R S E T A B _ T C L A D J U S T
 *
 *  For those solids entirely defined by their parsetab.
 *  Invoked via rt_functab[].ft_tcladjust()
 */
int
rt_parsetab_tcladjust(Tcl_Interp *interp, struct rt_db_internal *intern, int argc, char **argv)
{
	const struct rt_functab	*ftp;

	RT_CK_DB_INTERNAL(intern);
	ftp = intern->idb_meth;
	RT_CK_FUNCTAB(ftp);

	if( ftp->ft_parsetab == (struct bu_structparse *)NULL ) {
		Tcl_AppendResult( interp, ftp->ft_label,
			  " type objects do not yet have a 'db put' (tcladjust) handler.",
			  (char *)NULL );
		return TCL_ERROR;
	}

	return bu_structparse_argv(interp, argc, argv, ftp->ft_parsetab,
				(char *)intern->idb_ptr );
}

/*
 *			R T _ P A R S E T A B _ T C L F O R M
 *
 *  Invoked via rt_functab[].ft_tclform()
 *  on solid types which are fully described by their bu_structparse table
 *  in ft_parsetab.
 */
int
rt_parsetab_tclform(const struct rt_functab *ftp, Tcl_Interp *interp)
{
	RT_CK_FUNCTAB(ftp);

	if( ftp->ft_parsetab )  {
		bu_structparse_get_terse_form( interp, ftp->ft_parsetab );
		return TCL_OK;
	}
	Tcl_AppendResult(interp, ftp->ft_label,
		" is a valid object type, but a 'form' routine has not yet been implemented.",
		(char *)NULL );
	return TCL_ERROR;
}


/*
 *			R T _ T C L _ S E T U P
 *
 *  Add all the supported Tcl interfaces to LIBRT routines to
 *  the list of commands known by the given interpreter.
 *
 *  wdb_open creates database "objects" which appear as Tcl procs,
 *  which respond to many operations.
 *  The "db rt_gettrees" operation in turn creates a ray-traceable object
 *  as yet another Tcl proc, which responds to additional operations.
 *
 *  Note that the MGED mainline C code automatically runs
 *  "wdb_open db" and "wdb_open .inmem" on behalf of the MGED user,
 *  which exposes all of this power.
 */
void
rt_tcl_setup(Tcl_Interp *interp)
{
	extern int rt_bot_minpieces;	/* from g_bot.c */
	extern int rt_bot_tri_per_piece;	/* from g_bot.c */

	/* initialize database objects */
	Wdb_Init(interp);

	/* initialize drawable geometry objects */
	Dgo_Init(interp);

	/* initialize view objects */
	Vo_Init(interp);

	Tcl_SetVar(interp, "rt_version", (char *)rt_version+5, TCL_GLOBAL_ONLY);
	Tcl_LinkVar(interp, "rt_bot_minpieces", (char *)&rt_bot_minpieces, TCL_LINK_INT);
	
	Tcl_LinkVar(interp, "rt_bot_tri_per_piece", 
		    (char *)&rt_bot_tri_per_piece, TCL_LINK_INT);
}


/*
 *			R T _ I N I T
 *
 *  Allows LIBRT to be dynamically loade to a vanilla tclsh/wish with
 *  "load /usr/brlcad/lib/libbu.so"
 *  "load /usr/brlcad/lib/libbn.so"
 *  "load /usr/brlcad/lib/librt.so"
 */
int
Rt_Init(Tcl_Interp *interp)
{
	const char *version_number;

	/*XXX how much will this break? */
	if (BU_LIST_UNINITIALIZED(&rt_g.rtg_vlfree)) {
		if (bu_avail_cpus() > 1) {
			rt_g.rtg_parallel = 1;
			bu_semaphore_init(RT_SEM_LAST);
		}

		/* initialize RT's global state */
		BU_LIST_INIT(&rt_g.rtg_vlfree);
		BU_LIST_INIT(&rt_g.rtg_headwdb.l);
		rt_init_resource(&rt_uniresource, 0, NULL);
	}

	rt_tcl_setup(interp);
	Tcl_Eval(interp, "lindex $rt_version 2");
	version_number = Tcl_GetStringResult(interp);
	Tcl_PkgProvide(interp,  "Rt", version_number);

	return TCL_OK;
}


/* ====================================================================== */

/* TCL-oriented C support for LIBRT */


/*
 * (db_path.c)
 *			D B _ F U L L _ P A T H _ A P P E N D R E S U L T
 *
 *  Take a db_full_path and append it to the TCL result string.
 */
void
db_full_path_appendresult( Tcl_Interp *interp, const struct db_full_path *pp )
{
	register int i;

	RT_CK_FULL_PATH(pp);

	for( i=0; i<pp->fp_len; i++ )  {
		Tcl_AppendResult(interp, "/", pp->fp_names[i]->d_namep, (char *)NULL );
	}
}

/*
 *		T C L _ O B J _ T O _ I N T _ A R R A Y
 *
 *	Expects the Tcl_obj argument (list) to be a Tcl list and
 *	extracts list elements, converts them to int, and stores
 *	them in the passed in array. If the array_len argument is zero,
 *	a new array of approriate length is allocated. The return value
 *	is the number of elements converted.
 */
int
tcl_obj_to_int_array(Tcl_Interp *interp, Tcl_Obj *list, int **array, int *array_len)
{
	Tcl_Obj **obj_array;
	int len, i;

	if( Tcl_ListObjGetElements( interp, list, &len, &obj_array ) != TCL_OK )
		return( 0 );

	if( len < 1 )
		return( 0 );

	if( *array_len < 1 )
	{
		*array = (int *)bu_calloc( len, sizeof( int ), "array" );
		*array_len = len;
	}

	for( i=0 ; i<len && i<*array_len ; i++ ) {
		(*array)[i] = atoi( Tcl_GetStringFromObj( obj_array[i], NULL ) );
		Tcl_DecrRefCount( obj_array[i] );
	}

	return( len < *array_len ? len : *array_len );
}

/*	T C L _ L I S T _ T O _ I N T _ A R R A Y
 *
 *	interface to above tcl_obj_to_int_array() routine. This routine
 *	expects a character string instead of a Tcl_Obj.
 *
 *	Returns the number of elements converted.
 */

int
tcl_list_to_int_array(Tcl_Interp *interp, char *char_list, int **array, int *array_len)
{
	Tcl_Obj *obj;
	int ret;

	obj = Tcl_NewStringObj( char_list, -1 );

	ret = tcl_obj_to_int_array( interp, obj, array, array_len );

	return( ret );
}

/*
 *		T C L _ O B J _ T O _ F A S T F _ A R R A Y
 *
 *	Expects the Tcl_obj argument (list) to be a Tcl list and
 *	extracts list elements, converts them to fastf_t, and stores
 *	them in the passed in array. If the array_len argument is zero,
 *	a new array of approriate length is allocated. The return value
 *	is the number of elements converted.
 */

int
tcl_obj_to_fastf_array(Tcl_Interp *interp, Tcl_Obj *list, fastf_t **array, int *array_len)
{
	Tcl_Obj **obj_array;
	int len, i;
	int ret;

	if( (ret=Tcl_ListObjGetElements( interp, list, &len, &obj_array )) != TCL_OK )
		return( ret );

	if( len < 1 )
		return( 0 );

	if( *array_len < 1 )
	{
		*array = (fastf_t *)bu_calloc( len, sizeof( fastf_t ), "array" );
		*array_len = len;
	}

	for( i=0 ; i<len && i<*array_len ; i++ ) {
		(*array)[i] = atof( Tcl_GetStringFromObj( obj_array[i], NULL ) );
		Tcl_DecrRefCount( obj_array[i] );
	}

	return( len < *array_len ? len : *array_len );
}

/*	T C L _ L I S T _ T O _ F A S T F _ A R R A Y
 *
 *	interface to above tcl_obj_to_fastf_array() routine. This routine
 *	expects a character string instead of a Tcl_Obj.
 *
 *	Returns the number of elements converted.
 */

int
tcl_list_to_fastf_array(Tcl_Interp *interp, char *char_list, fastf_t **array, int *array_len)
{
	Tcl_Obj *obj;
	int ret;

	obj = Tcl_NewStringObj( char_list, -1 );

	ret = tcl_obj_to_fastf_array( interp, obj, array, array_len );

	return( ret );
}
@


1.113
log
@change conf.h to a wrapped config.h
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/librt/tcl.c,v 1.112 2004/04/05 08:48:58 morrison Exp $ (ARL)";
@


1.112
log
@merge of ansi-6-0-branch into HEAD
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d33 5
a37 1
#include "conf.h"
@


1.111
log
@update copyright to include span through 2003
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tcl.c,v 1.110 2003/04/09 20:15:29 jra Exp $ (ARL)";
d57 1
a57 1
extern int Wdb_Init();
d60 1
a60 1
extern int Dgo_Init();
d63 1
a63 1
extern int Vo_Init();
d352 1
a352 5
rt_tcl_rt_shootray( clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int argc;
const char *const*argv;
d395 1
a395 5
rt_tcl_rt_onehit( clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int argc;
const char *const*argv;
d428 1
a428 5
rt_tcl_rt_no_bool( clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int argc;
const char *const*argv;
d463 1
a463 5
rt_tcl_rt_check( clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int argc;
const char *const*argv;
d495 1
a495 5
rt_tcl_rt_prep( clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int argc;
const char *const*argv;
d581 1
a581 5
rt_tcl_rt( clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int argc;
const char *const*argv;
d646 1
a646 3
db_tcl_tree_describe( dsp, tp )
Tcl_DString		*dsp;
const union tree		*tp;
d885 1
a885 4
rt_comb_tclget( interp, intern, item )
Tcl_Interp			*interp;
const struct rt_db_internal	*intern;
const char			*item;
d1214 1
a1214 5
rt_tcl_import_from_path( interp, ip, path, wdb )
Tcl_Interp		*interp;
struct rt_db_internal	*ip;
const char		*path;
struct rt_wdb		*wdb;
d1311 1
a1311 4
rt_parsetab_tclget( interp, intern, attr )
Tcl_Interp			*interp;
const struct rt_db_internal	*intern;
const char			*attr;
d1370 1
a1370 3
rt_comb_tclform( ftp, interp )
const struct rt_functab *ftp;
Tcl_Interp		*interp;
d1388 1
a1388 4
rt_comb_make( ftp, intern, diameter )
const struct rt_functab	*ftp;
struct rt_db_internal	*intern;
double			diameter;
d1422 1
a1422 4
rt_generic_make( ftp, intern, diameter )
const struct rt_functab	*ftp;
struct rt_db_internal	*intern;
double			diameter;
d1440 1
a1440 5
rt_parsetab_tcladjust( interp, intern, argc, argv )
Tcl_Interp		*interp;
struct rt_db_internal	*intern;
int			argc;
char			**argv;
d1467 1
a1467 3
rt_parsetab_tclform( ftp, interp)
const struct rt_functab	*ftp;
Tcl_Interp		*interp;
d1588 1
a1588 5
tcl_obj_to_int_array( interp, list, array, array_len )
Tcl_Interp *interp;
Tcl_Obj *list;
int **array;
int *array_len;
d1622 1
a1622 5
tcl_list_to_int_array( interp, char_list, array, array_len )
Tcl_Interp *interp;
char *char_list;
int **array;
int *array_len;
d1645 1
a1645 5
tcl_obj_to_fastf_array( interp, list, array, array_len )
Tcl_Interp *interp;
Tcl_Obj *list;
fastf_t **array;
int *array_len;
d1680 1
a1680 5
tcl_list_to_fastf_array( interp, char_list, array, array_len )
Tcl_Interp *interp;
char *char_list;
fastf_t **array;
int *array_len;
@


1.110
log
@rt_parsetab_tclget() now returns a string when a single
attribute is requested. (Used to be a list)
@
text
@d26 1
a26 1
 *	This software is Copyright (C) 1997 by the United States Army
d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tcl.c,v 1.109 2003/04/01 19:14:48 jra Exp $ (ARL)";
@


1.110.6.1
log
@merge from HEAD
@
text
@d26 1
a26 1
 *	This software is Copyright (C) 1997-2004 by the United States Army
d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tcl.c,v 1.111 2004/02/02 17:39:29 morrison Exp $ (ARL)";
@


1.110.6.2
log
@merge from head
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tcl.c,v 1.110.6.1 2004/02/12 18:37:47 erikg Exp $ (ARL)";
@


1.109
log
@Added some "const" qualifiers to quiet the compiler
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tcl.c,v 1.108 2002/12/10 14:10:44 jra Exp $ (ARL)";
d1392 1
a1392 1
		Tcl_DStringAppendElement( &ds, bu_vls_addr(&str) );
@


1.108
log
@Added "-R" option to rt_tcl_rt_shootray() for no overlap reporting
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tcl.c,v 1.107 2002/09/04 20:32:26 jra Exp $ (ARL)";
d755 1
a755 1
	if( Tcl_SplitList( interp, str, &argc, &argv ) != TCL_OK )
d1581 1
a1581 1
	char *version_number;
@


1.107
log
@rt_comb_tcladjust() was not properly handling empty trees
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tcl.c,v 1.106 2002/08/20 17:08:10 jra Exp $ (ARL)";
d331 2
a332 1
 *	procname shootray {P} dir|at {V}
d337 1
a337 1
 *	.rt shootray {0 0 0} dir {0 0 -1}
d360 1
d362 1
a362 1
	if( argc != 5 )  {
d365 1
a365 1
				argv[0], " ", argv[1], " {P} dir|at {V}\"",
d370 7
d381 1
a381 1
	if( rt_tcl_parse_ray( interp, &ap->a_ray, &argv[2] ) == TCL_ERROR )
@


1.107.4.1
log
@sync to HEAD...
@
text
@d26 1
a26 1
 *	This software is Copyright (C) 1997-2004 by the United States Army
d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/tcl.c,v 1.111 2004/02/02 17:39:29 morrison Exp $ (ARL)";
d331 1
a331 2
 *	procname shootray [-R] {P} dir|at {V}
 *		-R option specifries no overlap reporting
d336 1
a336 1
 *	.rt shootray -R {0 0 0} dir {0 0 -1}
a358 1
	int			index;
d360 1
a360 1
	if( (argc != 5 && argc != 6) || (argc == 6 && strcmp( argv[2], "-R"))  )  {
d363 1
a363 1
				argv[0], " ", argv[1], " [-R] {P} dir|at {V}\"",
a367 7
	if( argc == 6 ) {
		ap->a_logoverlap = rt_silent_logoverlap;
		index = 3;
	} else {
		index = 2;
	}

d372 1
a372 1
	if( rt_tcl_parse_ray( interp, &ap->a_ray, &argv[index] ) == TCL_ERROR )
d746 1
a746 1
	if( Tcl_SplitList( interp, str, &argc, (const char ***)&argv ) != TCL_OK )
d1383 1
a1383 1
		Tcl_DStringAppend( &ds, bu_vls_addr(&str), -1 );
d1572 1
a1572 1
	const char *version_number;
@


1.107.2.1
log
@Initial ANSIfication
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tcl.c,v 1.107 2002/09/04 20:32:26 jra Exp $ (ARL)";
d57 1
a57 1
extern int Wdb_Init(Tcl_Interp *interp);
d60 1
a60 1
extern int Dgo_Init(Tcl_Interp *interp);
d63 1
a63 1
extern int Vo_Init(Tcl_Interp *interp);
d351 5
a355 1
rt_tcl_rt_shootray(ClientData clientData, Tcl_Interp *interp, int argc, const char *const *argv)
d390 5
a394 1
rt_tcl_rt_onehit(ClientData clientData, Tcl_Interp *interp, int argc, const char *const *argv)
d427 5
a431 1
rt_tcl_rt_no_bool(ClientData clientData, Tcl_Interp *interp, int argc, const char *const *argv)
d466 5
a470 1
rt_tcl_rt_check(ClientData clientData, Tcl_Interp *interp, int argc, const char *const *argv)
d502 5
a506 1
rt_tcl_rt_prep(ClientData clientData, Tcl_Interp *interp, int argc, const char *const *argv)
d592 5
a596 1
rt_tcl_rt(ClientData clientData, Tcl_Interp *interp, int argc, const char *const *argv)
d661 3
a663 1
db_tcl_tree_describe(Tcl_DString *dsp, const union tree *tp)
d902 4
a905 1
rt_comb_tclget(Tcl_Interp *interp, const struct rt_db_internal *intern, const char *item)
d1234 5
a1238 1
rt_tcl_import_from_path(Tcl_Interp *interp, struct rt_db_internal *ip, const char *path, struct rt_wdb *wdb)
d1335 4
a1338 1
rt_parsetab_tclget(Tcl_Interp *interp, const struct rt_db_internal *intern, const char *attr)
d1397 3
a1399 1
rt_comb_tclform(const struct rt_functab *ftp, Tcl_Interp *interp)
d1417 4
a1420 1
rt_comb_make(const struct rt_functab *ftp, struct rt_db_internal *intern, double diameter)
d1454 4
a1457 1
rt_generic_make(const struct rt_functab *ftp, struct rt_db_internal *intern, double diameter)
d1475 5
a1479 1
rt_parsetab_tcladjust(Tcl_Interp *interp, struct rt_db_internal *intern, int argc, char **argv)
d1506 3
a1508 1
rt_parsetab_tclform(const struct rt_functab *ftp, Tcl_Interp *interp)
d1629 5
a1633 1
tcl_obj_to_int_array(Tcl_Interp *interp, Tcl_Obj *list, int **array, int *array_len)
d1667 5
a1671 1
tcl_list_to_int_array(Tcl_Interp *interp, char *char_list, int **array, int *array_len)
d1694 5
a1698 1
tcl_obj_to_fastf_array(Tcl_Interp *interp, Tcl_Obj *list, fastf_t **array, int *array_len)
d1733 5
a1737 1
tcl_list_to_fastf_array(Tcl_Interp *interp, char *char_list, fastf_t **array, int *array_len)
@


1.107.2.2
log
@sync branch with HEAD
@
text
@d26 1
a26 1
 *	This software is Copyright (C) 1997-2004 by the United States Army
d30 1
a30 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d331 1
a331 2
 *	procname shootray [-R] {P} dir|at {V}
 *		-R option specifries no overlap reporting
d336 1
a336 1
 *	.rt shootray -R {0 0 0} dir {0 0 -1}
a354 1
	int			index;
d356 1
a356 1
	if( (argc != 5 && argc != 6) || (argc == 6 && strcmp( argv[2], "-R"))  )  {
d359 1
a359 1
				argv[0], " ", argv[1], " [-R] {P} dir|at {V}\"",
a363 7
	if( argc == 6 ) {
		ap->a_logoverlap = rt_silent_logoverlap;
		index = 3;
	} else {
		index = 2;
	}

d368 1
a368 1
	if( rt_tcl_parse_ray( interp, &ap->a_ray, &argv[index] ) == TCL_ERROR )
d720 1
a720 1
	if( Tcl_SplitList( interp, str, &argc, (const char ***)&argv ) != TCL_OK )
d1347 1
a1347 1
		Tcl_DStringAppend( &ds, bu_vls_addr(&str), -1 );
d1522 1
a1522 1
	const char *version_number;
@


1.106
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tcl.c,v 1.104 2001/12/17 07:48:25 butler Exp $ (ARL)";
d1178 1
a1178 1
			if( strcmp( argv[1], "none" ) == 0 )
d1180 3
a1182 1
				db_free_tree( comb->tree, resp );
@


1.105
log
@Converted from K&R to ANSI C - RFH
@
text
@d57 1
a57 1
extern int Wdb_Init(Tcl_Interp *interp);
d60 1
a60 1
extern int Dgo_Init(Tcl_Interp *interp);
d63 1
a63 1
extern int Vo_Init(Tcl_Interp *interp);
d351 5
a355 1
rt_tcl_rt_shootray(ClientData clientData, Tcl_Interp *interp, int argc, const char *const *argv)
d390 5
a394 1
rt_tcl_rt_onehit(ClientData clientData, Tcl_Interp *interp, int argc, const char *const *argv)
d427 5
a431 1
rt_tcl_rt_no_bool(ClientData clientData, Tcl_Interp *interp, int argc, const char *const *argv)
d466 5
a470 1
rt_tcl_rt_check(ClientData clientData, Tcl_Interp *interp, int argc, const char *const *argv)
d502 5
a506 1
rt_tcl_rt_prep(ClientData clientData, Tcl_Interp *interp, int argc, const char *const *argv)
d592 5
a596 1
rt_tcl_rt(ClientData clientData, Tcl_Interp *interp, int argc, const char *const *argv)
d661 3
a663 1
db_tcl_tree_describe(Tcl_DString *dsp, const union tree *tp)
d902 4
a905 1
rt_comb_tclget(Tcl_Interp *interp, const struct rt_db_internal *intern, const char *item)
d1232 5
a1236 1
rt_tcl_import_from_path(Tcl_Interp *interp, struct rt_db_internal *ip, const char *path, struct rt_wdb *wdb)
d1333 4
a1336 1
rt_parsetab_tclget(Tcl_Interp *interp, const struct rt_db_internal *intern, const char *attr)
d1395 3
a1397 1
rt_comb_tclform(const struct rt_functab *ftp, Tcl_Interp *interp)
d1415 4
a1418 1
rt_comb_make(const struct rt_functab *ftp, struct rt_db_internal *intern, double diameter)
d1452 4
a1455 1
rt_generic_make(const struct rt_functab *ftp, struct rt_db_internal *intern, double diameter)
d1473 5
a1477 1
rt_parsetab_tcladjust(Tcl_Interp *interp, struct rt_db_internal *intern, int argc, char **argv)
d1504 3
a1506 1
rt_parsetab_tclform(const struct rt_functab *ftp, Tcl_Interp *interp)
d1627 5
a1631 1
tcl_obj_to_int_array(Tcl_Interp *interp, Tcl_Obj *list, int **array, int *array_len)
d1665 5
a1669 1
tcl_list_to_int_array(Tcl_Interp *interp, char *char_list, int **array, int *array_len)
d1692 5
a1696 1
tcl_obj_to_fastf_array(Tcl_Interp *interp, Tcl_Obj *list, fastf_t **array, int *array_len)
d1731 5
a1735 1
tcl_list_to_fastf_array(Tcl_Interp *interp, char *char_list, fastf_t **array, int *array_len)
@


1.104
log
@Added rt_bot_tri_per_piece to Tcl
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tcl.c,v 1.103 2001/10/02 17:54:12 jra Exp $ (ARL)";
d57 1
a57 1
extern int Wdb_Init();
d60 1
a60 1
extern int Dgo_Init();
d63 1
a63 1
extern int Vo_Init();
d351 1
a351 5
rt_tcl_rt_shootray( clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int argc;
const char *const*argv;
d386 1
a386 5
rt_tcl_rt_onehit( clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int argc;
const char *const*argv;
d419 1
a419 5
rt_tcl_rt_no_bool( clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int argc;
const char *const*argv;
d454 1
a454 5
rt_tcl_rt_check( clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int argc;
const char *const*argv;
d486 1
a486 5
rt_tcl_rt_prep( clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int argc;
const char *const*argv;
d572 1
a572 5
rt_tcl_rt( clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int argc;
const char *const*argv;
d637 1
a637 3
db_tcl_tree_describe( dsp, tp )
Tcl_DString		*dsp;
const union tree		*tp;
d876 1
a876 4
rt_comb_tclget( interp, intern, item )
Tcl_Interp			*interp;
const struct rt_db_internal	*intern;
const char			*item;
d1203 1
a1203 5
rt_tcl_import_from_path( interp, ip, path, wdb )
Tcl_Interp		*interp;
struct rt_db_internal	*ip;
const char		*path;
struct rt_wdb		*wdb;
d1300 1
a1300 4
rt_parsetab_tclget( interp, intern, attr )
Tcl_Interp			*interp;
const struct rt_db_internal	*intern;
const char			*attr;
d1359 1
a1359 3
rt_comb_tclform( ftp, interp )
const struct rt_functab *ftp;
Tcl_Interp		*interp;
d1377 1
a1377 4
rt_comb_make( ftp, intern, diameter )
const struct rt_functab	*ftp;
struct rt_db_internal	*intern;
double			diameter;
d1411 1
a1411 4
rt_generic_make( ftp, intern, diameter )
const struct rt_functab	*ftp;
struct rt_db_internal	*intern;
double			diameter;
d1429 1
a1429 5
rt_parsetab_tcladjust( interp, intern, argc, argv )
Tcl_Interp		*interp;
struct rt_db_internal	*intern;
int			argc;
char			**argv;
d1456 1
a1456 3
rt_parsetab_tclform( ftp, interp)
const struct rt_functab	*ftp;
Tcl_Interp		*interp;
d1577 1
a1577 5
tcl_obj_to_int_array( interp, list, array, array_len )
Tcl_Interp *interp;
Tcl_Obj *list;
int **array;
int *array_len;
d1611 1
a1611 5
tcl_list_to_int_array( interp, char_list, array, array_len )
Tcl_Interp *interp;
char *char_list;
int **array;
int *array_len;
d1634 1
a1634 5
tcl_obj_to_fastf_array( interp, list, array, array_len )
Tcl_Interp *interp;
Tcl_Obj *list;
fastf_t **array;
int *array_len;
d1669 1
a1669 5
tcl_list_to_fastf_array( interp, char_list, array, array_len )
Tcl_Interp *interp;
char *char_list;
fastf_t **array;
int *array_len;
@


1.104.2.1
log
@rt_comb_tcladjust() was not properly handling empty trees
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tcl.c,v 1.104 2001/12/17 07:48:25 butler Exp $ (ARL)";
d1178 1
a1178 1
			if( *argv[1] == '\0' || strcmp( argv[1], "none" ) == 0 )
d1180 1
a1180 3
				if( comb->tree ) {
					db_free_tree( comb->tree, resp );
				}
@


1.103
log
@rt_xxx_make() routines were not setting idb_major_type
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tcl.c,v 1.102 2001/07/27 23:05:25 butler Exp $ (ARL)";
d1540 1
d1553 3
@


1.102
log
@Removed unused variable
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tcl.c,v 1.101 2001/07/17 13:27:19 jra Exp $ (ARL)";
d1422 1
d1458 1
@


1.101
log
@fixed bug in return from tcl_obj_to_int_array()
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tcl.c,v 1.100 2001/06/21 18:07:25 jra Exp $ (ARL)";
a1628 1
	int ret;
@


1.100
log
@Continueing to add tcladjust and tclget support
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tcl.c,v 1.99 2001/06/19 18:18:49 jra Exp $ (ARL)";
d1631 2
a1632 2
	if( (ret=Tcl_ListObjGetElements( interp, list, &len, &obj_array )) != TCL_OK )
		return( ret );
@


1.99
log
@More confusion about Tcl_DecrRefCount() for tcl_obj_to_fastf_array() and tcl_list_to_fastf_array()
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tcl.c,v 1.98 2001/05/30 21:08:33 jra Exp $ (ARL)";
d1611 9
d1635 1
a1635 1
		return( TCL_OK );
d1643 1
a1643 1
	for( i=0 ; i<len && i<*array_len ; i++ )
d1645 2
d1648 1
a1648 1
	return( TCL_OK );
d1651 8
a1672 2
	Tcl_DecrRefCount( obj );

d1676 10
d1701 1
a1701 1
		return( TCL_OK );
d1714 1
a1714 1
	return( TCL_OK );
d1716 8
@


1.98
log
@Simplified tcl_list_to_int_array() and tcl_list_to_fastf_array()
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tcl.c,v 1.97 2001/04/20 22:29:56 morrison Exp $ (ARL)";
d1682 1
a1682 1
	for( i=0 ; i<len && i<*array_len ; i++ )
d1684 2
a1702 2

	Tcl_DecrRefCount( obj );
@


1.97
log
@CONST to const
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tcl.c,v 1.96 2001/03/22 20:27:36 bparker Exp $ (ARL)";
d1647 1
a1647 1
	Tcl_Obj *obj, *list;
a1650 7
	list = Tcl_NewListObj( 0, NULL );
	if( (ret=Tcl_ListObjAppendList( interp, list, obj )) != TCL_OK )
	{
		Tcl_DecrRefCount( list );
		Tcl_DecrRefCount( obj );
		return( ret );
	}
d1652 1
a1652 1
	ret = tcl_obj_to_int_array( interp, list, array, array_len );
a1653 1
	Tcl_DecrRefCount( list );
d1695 1
a1695 1
	Tcl_Obj *obj, *list;
a1698 7
	list = Tcl_NewListObj( 0, NULL );
	if( (ret=Tcl_ListObjAppendList( interp, list, obj )) != TCL_OK )
	{
		Tcl_DecrRefCount( list );
		Tcl_DecrRefCount( obj );
		return( ret );
	}
d1700 1
a1700 1
	ret = tcl_obj_to_fastf_array( interp, list, array, array_len );
a1701 1
	Tcl_DecrRefCount( list );
@


1.96
log
@*- modified Rt_Init to initialize rt_uniresource
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/librt/tcl.c,v 1.95 2000/09/09 04:30:47 mike Exp $ (ARL)";
d86 1
a86 1
rt_tcl_parse_ray( Tcl_Interp *interp, struct xray *rp, CONST char *CONST*argv )
d129 1
a129 1
rt_tcl_pr_cutter( Tcl_Interp *interp, CONST union cutter *cutp )
d131 1
a131 1
	static CONST char xyz[4] = "XYZ";
d207 1
a207 1
	CONST union cutter	*cutp;
d253 1
a253 1
	CONST struct directory	*dp;
d904 2
a905 2
CONST struct rt_db_internal	*intern;
CONST char			*item;
d907 1
a907 1
	CONST struct rt_comb_internal *comb;
d1235 1
a1235 1
CONST char		*path;
d1335 2
a1336 2
CONST struct rt_db_internal	*intern;
CONST char			*attr;
d1338 2
a1339 2
	register CONST struct bu_structparse	*sp = NULL;
	register CONST struct rt_functab	*ftp;
d1396 1
a1396 1
CONST struct rt_functab *ftp;
d1416 1
a1416 1
CONST struct rt_functab	*ftp;
d1452 1
a1452 1
CONST struct rt_functab	*ftp;
d1477 1
a1477 1
	CONST struct rt_functab	*ftp;
d1503 1
a1503 1
CONST struct rt_functab	*ftp;
@


1.95
log
@
Struct db_tree_state finally got a magic number. Added resource argument
to ft_describe(), db_region_mat(), db_shader_mat(),
db_init_db_tree_state(), and db_path_to_mat().
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tcl.c,v 1.94 2000/09/08 05:54:43 mike Exp $ (ARL)";
d1576 1
@


1.94
log
@
Modified tree routines to take resource pointer.
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tcl.c,v 1.93 2000/08/31 18:57:07 bparker Exp $ (ARL)";
d1270 1
a1270 1
		db_init_db_tree_state( &ts, dbip );
@


1.93
log
@Mods to Rt_Init(): initialize RT's global state.
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tcl.c,v 1.92 2000/08/29 22:37:24 mike Exp $ (ARL)";
d737 1
a737 3
db_tcl_tree_parse( interp, str )
Tcl_Interp	*interp;
char		*str;
d773 1
a773 1
		BU_GETUNION( tp, tree );
d802 1
a802 1
		BU_GETUNION( tp, tree );
d807 1
a807 1
		BU_GETUNION( tp, tree );
d812 1
a812 1
		BU_GETUNION( tp, tree );
d817 1
a817 1
		BU_GETUNION( tp, tree );
d826 1
a826 1
			bu_free( (char *)tp, "union tree" );
d830 1
a830 1
		tp->tr_b.tb_left = db_tcl_tree_parse( interp, argv[1] );
d832 1
a832 1
			bu_free( (char *)tp, "union tree" );
d836 1
a836 1
		tp->tr_b.tb_right = db_tcl_tree_parse( interp, argv[2] );
d838 2
a839 2
			db_free_tree( tp->tr_b.tb_left );
			bu_free( (char *)tp, "union tree" );
d847 1
a847 1
		BU_GETUNION( tp, tree );
d852 1
a852 1
		BU_GETUNION( tp, tree );
d857 1
a857 1
		BU_GETUNION( tp, tree );
d870 1
a870 1
		tp->tr_b.tb_left = db_tcl_tree_parse( interp, argv[1] );
d880 1
a880 1
		BU_GETUNION( tp, tree );
d1047 1
a1047 1
 *  Invoked via rt_functab[].ft_tcladjust()
d1050 6
a1055 5
rt_comb_tcladjust( interp, intern, argc, argv )
Tcl_Interp		*interp;
struct rt_db_internal	*intern;
int			argc;
char			**argv;
d1063 1
d1180 1
a1180 1
				db_free_tree( comb->tree );
d1185 1
a1185 1
				new = db_tcl_tree_parse( interp, argv[1] );
d1192 1
a1192 1
					db_free_tree( comb->tree );
@


1.92
log
@
Fixed lint.
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tcl.c,v 1.91 2000/08/29 03:58:10 mike Exp $ (ARL)";
d1565 12
@


1.91
log
@
externs for librt/tcl.c
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tcl.c,v 1.90 2000/08/19 00:50:02 mike Exp $ (ARL)";
d291 3
a293 4
rt_tcl_a_hit( ap, PartHeadp, segHeadp )
struct application	*ap;
const struct partition	*PartHeadp;
const struct seg		*segHeadp;
d322 1
a322 2
rt_tcl_a_miss( ap )
const struct application	*ap;
@


1.90
log
@
Fixed to carefully check user-provided matricies before stashing them
in a combination's arc.
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tcl.c,v 1.89 2000/08/15 04:49:40 mike Exp $ (ARL)";
d86 1
a86 4
rt_tcl_parse_ray( interp, rp, argv )
Tcl_Interp *interp;
struct xray *rp;
CONST char *CONST*argv;
d129 1
a129 3
rt_tcl_pr_cutter( interp, cutp )
Tcl_Interp		*interp;
CONST union cutter	*cutp;
d203 1
a203 5
rt_tcl_cutter( clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d248 1
a248 6
rt_tcl_pr_hit( interp, hitp, segp, rayp, flipflag )
Tcl_Interp	*interp;
struct hit	*hitp;
struct seg	*segp;
struct xray	*rayp;
int		flipflag;
d293 2
a294 2
struct partition	*PartHeadp;
struct seg		*segHeadp;
d324 1
a324 1
struct application	*ap;
d357 1
a357 1
char **argv;
d396 1
a396 1
char **argv;
d433 1
a433 1
char **argv;
d472 1
a472 1
char **argv;
d508 1
a508 1
char **argv;
d598 1
a598 1
char **argv;
d665 1
a665 1
union tree		*tp;
d1537 1
a1537 2
rt_tcl_setup(interp)
     Tcl_Interp *interp;
d1564 1
a1564 2
Rt_Init(interp)
Tcl_Interp *interp;
d1589 1
a1589 3
db_full_path_appendresult( interp, pp )
Tcl_Interp			*interp;
CONST struct db_full_path	*pp;
@


1.89
log
@
Added comment.
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tcl.c,v 1.88 2000/07/12 01:58:14 mike Exp $ (ARL)";
d36 1
d583 7
a589 7
	"shootray",	rt_tcl_rt_shootray,
	"onehit",	rt_tcl_rt_onehit,
	"no_bool",	rt_tcl_rt_no_bool,
	"check",	rt_tcl_rt_check,
	"prep",		rt_tcl_rt_prep,
	"cutter",	rt_tcl_cutter,
	(char *)0,	(int (*)())0
d795 2
d798 3
a800 2
			tp->tr_l.tl_mat = (matp_t)bu_malloc( sizeof(mat_t), "tl_mat");
			if( bn_decode_mat( tp->tr_l.tl_mat, argv[2] ) != 16 )  {
d802 2
a803 2
					argv[2], "', using all-zeros", (char *)NULL );
				bn_mat_zero( tp->tr_l.tl_mat );
d805 10
@


1.88
log
@
Added missing arg.
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tcl.c,v 1.87 2000/07/10 23:01:49 mike Exp $ (ARL)";
d1500 2
@


1.87
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tcl.c,v 1.86 2000/05/23 21:57:29 mike Exp $ (ARL)";
d1283 1
a1283 1
		ret = db_follow_path( &ts, &old_path, &new_path, LOOKUP_NOISY );
@


1.86
log
@
Added rt_bot_minpieces as a Tcl accessible variable.
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tcl.c,v 1.85 2000/05/23 05:24:20 mike Exp $ (ARL)";
@


1.86.2.1
log
@Modified Rt_Init to initialize RT's global state.
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tcl.c,v 1.86 2000/05/23 21:57:29 mike Exp $ (ARL)";
a1566 12

	/*XXX how much will this break? */
	if (BU_LIST_UNINITIALIZED(&rt_g.rtg_vlfree)) {
		if (bu_avail_cpus() > 1) {
			rt_g.rtg_parallel = 1;
			bu_semaphore_init(RT_SEM_LAST);
		}

		/* initialize RT's global state */
		BU_LIST_INIT(&rt_g.rtg_vlfree);
		BU_LIST_INIT(&rt_g.rtg_headwdb.l);
	}
@


1.85
log
@
Added more debug output to Tcl "prep" directive.
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tcl.c,v 1.84 2000/05/18 21:47:08 mike Exp $ (ARL)";
d1538 2
d1550 1
@


1.84
log
@
Added support for "cutter" operation on ".rt" type ray-trace objects.
Added support for TCLifying "union cut" structures.
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tcl.c,v 1.83 2000/04/20 21:22:18 bparker Exp $ (ARL)";
d561 14
@


1.83
log
@*- call Tcl_PkgProvide
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tcl.c,v 1.82 2000/04/12 01:17:45 mike Exp $ (ARL)";
d76 168
a341 1

d383 1
a383 2
	/* Could core dump */
	RT_AP_CHECK(ap);
d387 1
a387 4
	if( bn_decode_vect( ap->a_ray.r_pt,  argv[2] ) != 3 ||
	    bn_decode_vect( ap->a_ray.r_dir, argv[4] ) != 3 )  {
		Tcl_AppendResult( interp,
			"badly formatted vector", (char *)NULL );
a388 17
	}
	switch( argv[3][0] )  {
	case 'd':
		/* [4] is direction vector */
		break;
	case 'a':
		/* [4] is target point, build a vector from start pt */
		VSUB2( ap->a_ray.r_dir, ap->a_ray.r_dir, ap->a_ray.r_pt );
		break;
	default:
		Tcl_AppendResult( interp,
				"wrong keyword: '", argv[4],
				"', should be one of 'dir' or 'at'",
				(char *)NULL );
		return TCL_ERROR;
	}
	VUNITIZE( ap->a_ray.r_dir );	/* sanity */
d423 1
a423 2
	/* Could core dump */
	RT_AP_CHECK(ap);
d460 1
a460 2
	/* Could core dump */
	RT_AP_CHECK(ap);
d498 1
a498 2
	/* Could core dump */
	RT_AP_CHECK(ap);
d536 1
a536 2
	/* Could core dump */
	RT_AP_CHECK(ap);
d573 1
d617 3
a619 2
	Tcl_AppendResult( interp, "unknown LIBRT command; must be one of:",
			  (char *)NULL );
@


1.82
log
@
Moved TCL support from g_sketch.c to tcl.c
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tcl.c,v 1.81 2000/04/12 01:11:50 mike Exp $ (ARL)";
d1405 2
d1408 4
@


1.81
log
@
Removed unnecessary UNIX include files
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tcl.c,v 1.80 2000/03/22 02:17:11 mike Exp $ (ARL)";
d1433 112
@


1.80
log
@
Added Rt_Init() to allow use with Tcl's built-in "load" command.
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tcl.c,v 1.79 1999/12/30 21:59:32 mike Exp $ (ARL)";
a34 2
#include <fcntl.h>
#include <sys/errno.h>
a35 1
#include <ctype.h>
@


1.79
log
@
Added db_full_path_appendresult()
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tcl.c,v 1.78 1999/12/30 15:59:52 jra Exp $ (ARL)";
d1393 17
@


1.78
log
@Eliminated some unused variables
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tcl.c,v 1.77 1999/12/27 19:01:30 bparker Exp $ (ARL)";
d1393 26
@


1.77
log
@*- initialize drawable geometry objects
*- initialize view objects
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tcl.c,v 1.76 1999/12/20 20:51:56 bparker Exp $ (ARL)";
a173 2
	Tcl_Interp *interp = (Tcl_Interp *)ap->a_uptr;

a347 1
	char			buf[64];
a603 2
	union tree	*lhs;
	union tree	*rhs;
@


1.76
log
@*- moved database routines to wdb_obj.c
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tcl.c,v 1.74 1999/12/01 16:01:47 bparker Exp $ (ARL)";
d61 6
d1386 1
a1386 1
Tcl_Interp *interp;
d1388 1
d1390 7
@


1.75
log
@
Added an extra comment to further illustrate.
@
text
@d35 2
d58 3
d1060 5
a1064 47
/************************************************************************
 *									*
 *		Tcl interface to the Database				*
 *									*
 ************************************************************************/

/*
 *			R T _ D B _ M A T C H
 *
 * Returns (in interp->result) a list (possibly empty) of all matches to
 * the (possibly wildcard-containing) arguments given.
 * Does *NOT* return tokens that do not match anything, unlike the
 * "expand" command.
 */

int
rt_db_match( clientData, interp, argc, argv )
ClientData	clientData;
Tcl_Interp     *interp;
int		argc;
char	      **argv;
{
	struct rt_wdb  *wdb = (struct rt_wdb *)clientData;
	struct bu_vls	matches;

	--argc;
	++argv;

	RT_CK_WDB_TCL(interp,wdb);
	
	/* Verify that this wdb supports lookup operations
	   (non-null dbip) */
	if( wdb->dbip == 0 ) {
		Tcl_AppendResult( interp, "this database does not support lookup operations" );
		return TCL_ERROR;
	}

	bu_vls_init( &matches );
	for( ++argv; *argv != NULL; ++argv ) {
		if( db_regexp_match_all( &matches, wdb->dbip, *argv ) > 0 )
			bu_vls_strcat( &matches, " " );
	}
	bu_vls_trimspace( &matches );
	Tcl_AppendResult( interp, bu_vls_addr(&matches), (char *)NULL );
	bu_vls_free( &matches );
	return TCL_OK;
}
a1237 57
 *			R T _ D B _ G E T
 *
 **
 ** For use with Tcl, this routine accepts as its first argument the name
 ** of an object in the database.  If only one argument is given, this routine
 ** then fills the result string with the (minimal) attributes of the item.
 ** If a second, optional, argument is provided, this function looks up the
 ** property with that name of the item given, and returns it as the result
 ** string.
 **/

int
rt_db_get( clientData, interp, argc, argv )
ClientData	clientData;
Tcl_Interp     *interp;
int		argc;
char	      **argv;
{
	register struct directory	       *dp;
	register struct bu_structparse	       *sp = NULL;
	int			id, status;
	struct rt_db_internal	intern;
	char			objecttype;
	char		       *objname;
	struct rt_wdb	       *wdb = (struct rt_wdb *)clientData;
	Tcl_DString		ds;
	struct bu_vls		str;
	char			*curr_elem;

	--argc;
	++argv;

	if( argc < 2 || argc > 3) {
		Tcl_AppendResult( interp,
				  "wrong # args: should be \"", argv[0],
				  " objName ?attr?\"", (char *)NULL );
		return TCL_ERROR;
	}

	/* Verify that this wdb supports lookup operations
	   (non-null dbip) */
	if( wdb->dbip==0 ) {
		Tcl_AppendResult( interp,
				  "db does not support lookup operations",
				  (char *)NULL );
		return TCL_ERROR;
	}

	if( rt_tcl_import_from_path( interp, &intern, argv[1], wdb ) == TCL_ERROR )
		return TCL_ERROR;

	status = intern.idb_meth->ft_tclget( interp, &intern, argv[2] );
	intern.idb_meth->ft_ifree( &intern );
	return status;
}

/*
a1340 157
 *			R T _ D B _ P U T
 **
 ** Creates an object and stuffs it into the databse.
 ** All arguments must be specified.  Object cannot already exist.
 **/

int
rt_db_put(clientData, interp, argc, argv)
ClientData	clientData;
Tcl_Interp     *interp;
int		argc;
char	      **argv;
{
	struct rt_db_internal			intern;
	register CONST struct rt_functab	*ftp;
	register struct directory	       *dp;
	int					status, ngran, i;
	char				       *name;
	struct rt_wdb			  *wdb = (struct rt_wdb *)clientData;
	char				        type[16];

	--argc;
	++argv;

	if( argc < 2 ) {
		Tcl_AppendResult( interp,
 	               "wrong # args: should be db put objName objType attrs",
				  (char *)NULL );
		return TCL_ERROR;
	}

	name = argv[1];
    
	/* Verify that this wdb supports lookup operations (non-null dbip).
	 * stdout/file wdb objects don't, but can still be written to.
	 * If not, just skip the lookup test and write the object
	 */
	if( wdb->dbip && db_lookup(wdb->dbip, argv[1], LOOKUP_QUIET) != DIR_NULL ) {
		Tcl_AppendResult(interp, argv[1], " already exists",
				 (char *)NULL);
		return TCL_ERROR;
	}

	RT_INIT_DB_INTERNAL(&intern);

	for( i = 0; argv[2][i] != 0 && i < 16; i++ ) {
		type[i] = isupper(argv[2][i]) ? tolower(argv[2][i]) :
			  argv[2][i];
	}
	type[i] = 0;

	ftp = rt_get_functab_by_label( type );
	if( ftp == NULL ) {
		Tcl_AppendResult( interp, type,
				  " is an unknown object type.",
				  (char *)NULL );
		return TCL_ERROR;
	}

	if( ftp->ft_make )  {
		ftp->ft_make( ftp, &intern, 0.0 );
	} else {
		rt_generic_make( ftp, &intern, 0.0 );
	}

	if( ftp->ft_tcladjust( interp, &intern, argc-3, argv+3 ) == TCL_ERROR ) {
		rt_db_free_internal( &intern );
		return TCL_ERROR;
	}

	if( wdb_export( wdb, name, intern.idb_ptr, intern.idb_type,
			1.0 ) < 0 )  {
		Tcl_AppendResult( interp, "wdb_export(", argv[1],
				  ") failure\n", (char *)NULL );
		rt_db_free_internal( &intern );
		return TCL_ERROR;
	}

	rt_db_free_internal( &intern );
	return TCL_OK;
}

/*
 *			R T _ D B _ A D J U S T
 *
 **
 ** For use with Tcl, this routine accepts as its first argument an item in
 ** the database; as its remaining arguments it takes the properties that
 ** need to be changed and their values.
 *
 *  Example of adjust operation on a solid:
 *	.inmem adjust LIGHT V { -46 -13 5 }
 *
 *  Example of adjust operation on a combination:
 *	.inmem adjust light.r rgb { 255 255 255 }
 */

int
rt_db_adjust( clientData, interp, argc, argv )
ClientData	clientData;
Tcl_Interp     *interp;
int		argc;
char	      **argv;
{
	register struct directory	*dp;
	register CONST struct bu_structparse	*sp = NULL;
	int				 id, status, i;
	char				*name;
	struct rt_db_internal		 intern;
	mat_t				 idn;
	char				 objecttype;
	struct rt_wdb		        *wdb = (struct rt_wdb *)clientData;

	if( argc < 5 ) {
		Tcl_AppendResult( interp,
		"wrong # args: should be \"db adjust objName attr value ?attr? ?value?...\"",
				  (char *)NULL );
		return TCL_ERROR;
	}
	name = argv[2];

	/* Verify that this wdb supports lookup operations (non-null dbip) */
	RT_CK_DBI_TCL(interp,wdb->dbip);

	dp = db_lookup( wdb->dbip, name, LOOKUP_QUIET );
	if( dp == DIR_NULL ) {
		Tcl_AppendResult( interp, name, ": not found\n",
				  (char *)NULL );
		return TCL_ERROR;
	}

	status = rt_db_get_internal( &intern, dp, wdb->dbip, (matp_t)NULL );
	if( status < 0 ) {
		Tcl_AppendResult( interp, "rt_db_get_internal(", name,
				  ") failure\n", (char *)NULL );
		return TCL_ERROR;
	}
	RT_CK_DB_INTERNAL( &intern );

	/* Find out what type of object we are dealing with and tweak it. */
	id = intern.idb_type;
	RT_CK_FUNCTAB(intern.idb_meth);

	status = intern.idb_meth->ft_tcladjust( interp, &intern, argc-3, argv+3 );
	if( status == TCL_OK && wdb_export( wdb, name, intern.idb_ptr,
					    intern.idb_type, 1.0 ) < 0 )  {
		Tcl_AppendResult( interp, "wdb_export(", name,
				  ") failure\n", (char *)NULL );
		rt_db_free_internal( &intern );
		return TCL_ERROR;
	}

	rt_db_free_internal( &intern );
	return status;
}

/*
a1363 390
 *			R T _ D B _ F O R M
 */
int
rt_db_form( clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
	CONST struct bu_structparse	*sp = NULL;
	CONST struct rt_functab		*ftp;

	--argc;
	++argv;

	if (argc != 2) {
		Tcl_AppendResult(interp, "wrong # args: should be \"db form objType\"",
				 (char *)NULL);
		return TCL_ERROR;
	}

	if( (ftp = rt_get_functab_by_label(argv[1])) == NULL )  {
		Tcl_AppendResult(interp, "There is no geometric object type \"",
			argv[1], "\".", (char *)NULL);
		return TCL_ERROR;
	}
	return ftp->ft_tclform( ftp, interp );
}

/*
 *			R T _ D B _ T O P S
 */

int
rt_db_tops( clientData, interp, argc, argv )
ClientData	clientData;
Tcl_Interp     *interp;
int		argc;
char	      **argv;
{
	struct rt_wdb *wdp = (struct rt_wdb *)clientData;
	register struct directory *dp;
	register int i;

	RT_CK_WDB_TCL(interp, wdp );
	RT_CK_DBI_TCL(interp, wdp->dbip );

	/* Can this be executed only sometimes?
	   Perhaps a "dirty bit" on the database? */
	db_update_nref( wdp->dbip );
	
	for( i = 0; i < RT_DBNHASH; i++ )
		for( dp = wdp->dbip->dbi_Head[i];
		     dp != DIR_NULL;
		     dp = dp->d_forw )
			if( dp->d_nref == 0 )
				Tcl_AppendElement( interp, dp->d_namep );
	return TCL_OK;
}

/*
 *			R T _ T C L _ D E L E T E P R O C _ R T
 *
 *  Called when the named proc created by rt_gettrees() is destroyed.
 */
void
rt_tcl_deleteproc_rt(clientData)
ClientData clientData;
{
	struct application	*ap = (struct application *)clientData;
	struct rt_i		*rtip;

	RT_AP_CHECK(ap);
	rtip = ap->a_rt_i;
	RT_CK_RTI(rtip);

	rt_free_rti(rtip);
	ap->a_rt_i = (struct rt_i *)NULL;

	bu_free( (genptr_t)ap, "struct application" );
}

/*
 *			R T _ D B _ R T _ G E T T R E E S
 *
 *  Given an instance of a database and the name of some treetops,
 *  create a named "ray-tracing" object (proc) which will respond to
 *  subsequent operations.
 *  Returns new proc name as result.
 *
 *  Example:
 *	.inmem rt_gettrees .rt all.g light.r
 */
int
rt_db_rt_gettrees( clientData, interp, argc, argv )
ClientData	clientData;
Tcl_Interp     *interp;
int		argc;
char	      **argv;
{
	struct rt_wdb *wdp = (struct rt_wdb *)clientData;
	struct rt_i	*rtip;
	struct application	*ap;
	struct resource		*resp;
	char		*newprocname;
	char		buf[64];

	RT_CK_WDB_TCL(interp, wdp );
	RT_CK_DBI_TCL(interp, wdp->dbip );

	if( argc < 4 )  {
		Tcl_AppendResult( interp,
			"rt_gettrees: wrong # args: should be \"",
			argv[0], " ", argv[1],
			" newprocname [-i] [-u] treetops...\"\n", (char *)NULL );
		return TCL_ERROR;
	}

	rtip = rt_new_rti( wdp->dbip );
	newprocname = argv[2];

	/* Delete previous proc (if any) to release all that memory, first */
	(void)Tcl_DeleteCommand( interp, newprocname );

	while( argv[3][0] == '-' )  {
		if( strcmp( argv[3], "-i" ) == 0 )  {
			rtip->rti_dont_instance = 1;
			argc--;
			argv++;
			continue;
		}
		if( strcmp( argv[3], "-u" ) == 0 )  {
			rtip->useair = 1;
			argc--;
			argv++;
			continue;
		}
		break;
	}

	if( rt_gettrees( rtip, argc-3, (CONST char **)&argv[3], 1 ) < 0 )  {
		Tcl_AppendResult( interp,
			"rt_gettrees() returned error\n", (char *)NULL );
		rt_free_rti( rtip );
		return TCL_ERROR;
	}

	/* Establish defaults for this rt_i */
	rtip->rti_hasty_prep = 1;	/* Tcl isn't going to fire many rays */

	/*
	 *  In case of multiple instances of the library, make sure that
	 *  each instance has a separate resource structure,
	 *  because the bit vector lengths depend on # of solids.
	 *  And the "overwrite" sequence in Tcl is to create the new
	 *  proc before running the Tcl_CmdDeleteProc on the old one,
	 *  which in this case would trash rt_uniresource.
	 *  Once on the rti_resources list, rt_clean() will clean 'em up.
	 */
	BU_GETSTRUCT( resp, resource );
	rt_init_resource( resp, 0 );
	bu_ptbl_ins_unique( &rtip->rti_resources, (long *)resp );

	BU_GETSTRUCT( ap, application );
	ap->a_resource = resp;
	ap->a_rt_i = rtip;
	ap->a_purpose = "Conquest!";

	rt_ck(rtip);

	/* Instantiate the proc, with clientData of wdb */
	/* Beware, returns a "token", not TCL_OK. */
	(void)Tcl_CreateCommand( interp, newprocname, rt_tcl_rt,
				 (ClientData)ap, rt_tcl_deleteproc_rt );

	/* Return new function name as result */
	Tcl_AppendResult( interp, newprocname, (char *)NULL );

	return TCL_OK;

}

/*
 *			R T _ D B _ D U M P
 *
 *  Write the current state of a database object out to a file.
 *
 *  Example:
 *	.inmem dump "/tmp/foo.g"
 */
int
rt_db_dump( clientData, interp, argc, argv )
ClientData	clientData;
Tcl_Interp     *interp;
int		argc;
char	      **argv;
{
	struct rt_wdb	*wdp = (struct rt_wdb *)clientData;
	struct rt_wdb	*op;
	int		ret;

	RT_CK_WDB_TCL(interp, wdp );
	RT_CK_DBI_TCL(interp, wdp->dbip );

	if( argc != 3 )  {
		Tcl_AppendResult( interp,
			"dump: wrong # args: should be \"",
			argv[0], "dump filename.g\n", (char *)NULL );
		return TCL_ERROR;
	}

	if( (op = wdb_fopen( argv[2] )) == RT_WDB_NULL )  {
		Tcl_AppendResult( interp,
			argv[0], " dump:  ", argv[2], ": cannot create\n",
			(char *)NULL );
		return TCL_ERROR;
	}
	ret = db_dump( op, wdp->dbip );
	wdb_close( op );
	if( ret < 0 )  {
		Tcl_AppendResult( interp,
			argv[0], " dump ", argv[2], ": db_dump() error\n",
			(char *)NULL );
		return TCL_ERROR;
	}
	return TCL_OK;
}

static struct dbcmdstruct rt_db_cmds[] = {
	"match",	rt_db_match,
	"get",		rt_db_get,
	"put",		rt_db_put,
	"adjust",	rt_db_adjust,
	"form",		rt_db_form,
	"tops",		rt_db_tops,
	"rt_gettrees",	rt_db_rt_gettrees,
	"dump",		rt_db_dump,
	(char *)0,	(int (*)())0
};

/*
 *			R T _ D B
 *
 * Generic interface for the database_class manipulation routines.
 * Usage:
 *        procname dbCmdName ?args?
 * Returns: result of cmdName database command.
 */

int
rt_db( clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
	struct dbcmdstruct	*dbcmd;
	struct rt_wdb		*wdb = (struct rt_wdb *)clientData;

	if( argc < 2 ) {
		Tcl_AppendResult( interp,
				  "wrong # args: should be \"", argv[0],
				  " command [args...]\"",
				  (char *)NULL );
		return TCL_ERROR;
	}

	/* Could core dump */
	RT_CK_WDB_TCL(interp,wdb);

	for( dbcmd = rt_db_cmds; dbcmd->cmdname != NULL; dbcmd++ ) {
		if( strcmp(dbcmd->cmdname, argv[1]) == 0 ) {
			return (*dbcmd->cmdfunc)( clientData, interp,
						  argc, argv );
		}
	}


	Tcl_AppendResult( interp, "unknown database command; must be one of:",
			  (char *)NULL );
	for( dbcmd = rt_db_cmds; dbcmd->cmdname != NULL; dbcmd++ ) {
		Tcl_AppendResult( interp, " ", dbcmd->cmdname, (char *)NULL );
	}
	Tcl_AppendResult( interp, "\n", (char *)NULL );
	return TCL_ERROR;
}

/*
 *			R T _ T C L _ D E L E T E P R O C _ W D B
 *
 *  Called when the named proc created by wdb_open() is destroyed.
 *  This is used instead of a "close" operation on the object.
 */
void
rt_tcl_deleteproc_wdb(clientData)
ClientData clientData;
{
	struct rt_wdb	*wdbp = (struct rt_wdb *)clientData;
	RT_CK_WDB(wdbp);

	wdb_close(wdbp);
}

/*
 *			W D B _ O P E N
 *
 *  A TCL interface to wdb_fopen() and wdb_dbopen().
 *
 *  Implicit return -
 *	Creates a new TCL proc which responds to get/put/etc. arguments
 *	when invoked.  clientData of that proc will be wdb pointer
 *	for this instance of the database.
 *	Easily allows keeping track of multiple databases.
 *
 *  Explicit return -
 *	wdb pointer, for more traditional C-style interfacing.
 *
 *  Example -
 *	set wdbp [wdb_open .inmem inmem $dbip]
 *	.inmem get box.s
 *	.inmem close
 *
 *	wdb_open db file "bob.g"
 *	db get white.r
 *	db close
 */
int
wdb_open( clientData, interp, argc, argv )
ClientData	clientData;
Tcl_Interp	*interp;
int		argc;
char		**argv;
{
	struct rt_wdb	*wdb;
	char		buf[32];

	if( argc != 4 )  {
		Tcl_AppendResult(interp, "\
Usage: wdb_open newprocname file filename\n\
       wdb_open newprocname disk $dbip\n\
       wdb_open newprocname disk_append $dbip\n\
       wdb_open newprocname inmem $dbip\n\
       wdb_open newprocname inmem_append $dbip\n",
		NULL);
		return TCL_ERROR;
	}

	/* Delete previous proc (if any) to release all that memory, first */
	(void)Tcl_DeleteCommand( interp, argv[1] );

	if( strcmp( argv[2], "file" ) == 0 )  {
		wdb = wdb_fopen( argv[3] );
	} else {
		struct db_i	*dbip;

		dbip = (struct db_i *)atol( argv[3] );
		/* Could core dump */
		RT_CK_DBI_TCL(interp,dbip);

		if( strcmp( argv[2], "disk" ) == 0 )  {
			wdb = wdb_dbopen( dbip, RT_WDB_TYPE_DB_DISK );
		} else if( strcmp( argv[2], "disk_append" ) == 0 )  {
			wdb = wdb_dbopen( dbip, RT_WDB_TYPE_DB_DISK_APPEND_ONLY );
		} else if( strcmp( argv[2], "inmem" ) == 0 )  {
			wdb = wdb_dbopen( dbip, RT_WDB_TYPE_DB_INMEM );
		} else if( strcmp( argv[2], "inmem_append" ) == 0 )  {
			wdb = wdb_dbopen( dbip, RT_WDB_TYPE_DB_INMEM_APPEND_ONLY );
		} else {
			Tcl_AppendResult(interp, "wdb_open ", argv[2],
				" target type not recognized\n", NULL);
			return TCL_ERROR;
		}
	}
	if( wdb == RT_WDB_NULL )  {
		Tcl_AppendResult(interp, "wdb_open ", argv[1], " failed\n", NULL);
		return TCL_ERROR;
	}

	/* Instantiate the newprocname, with clientData of wdb */
	/* Beware, returns a "token", not TCL_OK. */
	(void)Tcl_CreateCommand( interp, argv[1], rt_db,
				 (ClientData)wdb, rt_tcl_deleteproc_wdb );

	/* Return new function name as result */
	Tcl_AppendResult( interp, argv[1], (char *)NULL );
	
	return TCL_OK;
}

/*
d1382 1
a1382 2
	(void)Tcl_CreateCommand(interp, "wdb_open", wdb_open,
		(ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);
@


1.74
log
@*- moved a few macros to raytrace.h
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tcl.c,v 1.73 1999/11/19 02:34:14 mike Exp $ (ARL)";
d1936 4
@


1.73
log
@
Fully committed to ft_tclget() et.al.
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tcl.c,v 1.72 1999/11/19 01:52:00 mike Exp $ (ARL)";
a55 5
#define RT_CK_DBI_TCL(_p)	BU_CKMAG_TCL(interp,_p,DBI_MAGIC,"struct db_i")
#define RT_CK_RTI_TCL(_p)	BU_CKMAG_TCL(interp,_p,RTI_MAGIC,"struct rt_i")
#define RT_CK_WDB_TCL(_p)	BU_CKMAG_TCL(interp,_p,RT_WDB_MAGIC,"struct rt_wdb")
#define RT_CK_COMB_TCL(_p)	BU_CKMAG_TCL(interp,_p,RT_COMB_MAGIC, "rt_comb_internal" )

d213 1
a213 1
	RT_CK_RTI_TCL(rtip);
d274 1
a274 1
	RT_CK_RTI_TCL(rtip);
d312 1
a312 1
	RT_CK_RTI_TCL(rtip);
d352 1
a352 1
	RT_CK_RTI_TCL(rtip);
d391 1
a391 1
	RT_CK_RTI_TCL(rtip);
d756 1
a756 1
	RT_CK_COMB_TCL(comb);
d1083 1
a1083 1
	RT_CK_WDB_TCL(wdb);
d1557 1
a1557 1
	RT_CK_DBI_TCL(wdb->dbip);
d1659 2
a1660 2
	RT_CK_WDB_TCL( wdp );
	RT_CK_DBI_TCL( wdp->dbip );
d1722 2
a1723 2
	RT_CK_WDB_TCL( wdp );
	RT_CK_DBI_TCL( wdp->dbip );
d1816 2
a1817 2
	RT_CK_WDB_TCL( wdp );
	RT_CK_DBI_TCL( wdp->dbip );
d1883 1
a1883 1
	RT_CK_WDB_TCL(wdb);
d1968 1
a1968 1
		RT_CK_DBI_TCL(dbip);
@


1.72
log
@
Very initial support for ft_tclget / ft_tcladjust / ft_tclform / ft_make
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tcl.c,v 1.71 1999/11/18 23:17:34 mike Exp $ (ARL)";
d1216 3
d1222 3
a1224 3
Tcl_Interp		*interp;
struct rt_db_internal	*intern;
CONST char		*attr;
a1279 47
 *			R T _ D B _ R E P O R T
 *
 *  Report on a particular object from the database.
 *  Used to support "db get".
 *  Also used in MGED for get_edit_solid.
 *  'attr' is specified to retrieve only one attribute, rather than all.
 *  Example:  "db get ell.s B" to get only the B vector.
 *  XXX This routine should go away soon, and be replaced by
 *  XXX idb_meth->ft_tclget().
 */
int
rt_db_report( interp, intern, attr )
Tcl_Interp		*interp;
CONST struct rt_db_internal	*intern;
CONST char		*attr;
{
	register CONST struct bu_structparse	*sp = NULL;
	register CONST struct rt_functab	*ftp;
	int                     id, status;

	RT_CK_DB_INTERNAL( intern );

       /* Find out what type of object we are dealing with and report on it. */
	id = intern->idb_type;
	ftp = intern->idb_meth;
	RT_CK_FUNCTAB(ftp);

	/* return ftp->ft_tclget( interp, intern, attr ); */

	switch( id ) {
	case ID_COMBINATION:
		status = rt_comb_tclget( interp, intern, attr );
		break;
	default:
		if( ftp->ft_parsetab == (struct bu_structparse *)NULL ) {
			Tcl_AppendResult( interp, ftp->ft_label,
 " {a Tcl output routine for this type of object has not yet been implemented}",
				  (char *)NULL );
			return TCL_OK;
		}
		status = rt_parsetab_tclget( interp, intern, attr );
	}

	return status;
}

/*
d1331 1
a1331 6
	if( intern.idb_meth->ft_tclget )  {
		status = intern.idb_meth->ft_tclget( interp, &intern, argv[2] );
	} else {
		status = rt_db_report( interp, &intern, argv[2] );
	}

d1410 1
a1410 1
 *			R T _ G E N E R I C _ T C L A D J U S T
d1416 1
a1416 1
rt_generic_tcladjust( interp, intern, argc, argv )
d1505 3
a1507 11
	if( ftp->ft_tcladjust )  {
		if( ftp->ft_tcladjust( interp, &intern, argc-3,
					argv+3 ) == TCL_ERROR ) {
			rt_db_free_internal( &intern );
			return TCL_ERROR;
		}
	} else {
		if( rt_generic_tcladjust( interp, &intern, argc-3, argv+3 ) == TCL_ERROR )  {
			rt_db_free_internal(&intern);
			return TCL_ERROR;
		}
d1583 1
a1583 7
	/* status = ftp->ft_tcladjust( interp, &intern, argc-3, argv+3 ) */
	if( intern.idb_meth->ft_tcladjust )  {
		status = intern.idb_meth->ft_tcladjust( interp, &intern, argc-3, argv+3 );
	} else {
		status = rt_generic_tcladjust( interp, &intern, argc-3, argv+3 );
	}

d1597 23
d1646 1
a1646 14
	if( ftp->ft_tclform )
		return ftp->ft_tclform( ftp, interp );

	sp = ftp->ft_parsetab;
    
	if (sp != NULL)
		bu_structparse_get_terse_form(interp, sp);
	else {
		Tcl_AppendResult(interp, argv[1],
			" is a valid object type, but a 'form' routine has not yet been implemented.",
			(char *)NULL );
		return TCL_ERROR;
	}
	return TCL_OK;
@


1.71
log
@
Further factored out the TCL interface, in preparation for
accessing it via rt_functab methods.
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tcl.c,v 1.70 1999/11/18 21:10:19 mike Exp $ (ARL)";
d1375 5
a1379 2
	status = rt_db_report( interp, &intern, argv[2] );
	/* status = intern.idb_meth->ft_tclget( interp, &intern, argv[2] ); */
d1386 16
d1548 5
a1552 3
	if( strcmp(type, "comb")==0 ) {
		rt_comb_make( ftp, &intern, 0.0 );
		/* ftp->ft_make( ftp, &intern, 0.0 ); */
d1554 2
a1555 3
		/* ftp->ft_tcladjust( interp, &intern, argc-3, argv+3 ) */

		if( rt_comb_tcladjust( interp, &intern, argc-3,
a1560 5
		rt_generic_make( ftp, &intern, 0.0 );
		/* ftp->ft_make( ftp, &intern, 0.0 ); */

		/* ftp->ft_tcladjust( interp, intern, argc-3, argv+3 ) */

d1586 7
a1592 2
 **	.inmem adjust LIGHT V { -46 -13 5 }
 **/
d1640 3
a1642 4
	/* status = ftp->ft_tcladjust( interp, intern, argc-3, argv+3 ) */
	if( id == ID_COMBINATION ) {
		/* .inmem adjust light.r rgb { 255 255 255 } */
		status = rt_comb_tcladjust( interp, &intern, argc-3, argv+3 );
a1643 1
		/* .inmem adjust LIGHT V { -46 -13 5 } */
d1686 3
@


1.70
log
@
Removed obsolete code.
Documented the "great chain of being" which begins with wdb_open
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tcl.c,v 1.69 1999/11/18 20:49:39 mike Exp $ (ARL)";
d56 10
a65 3
#define RT_CK_DBI_TCL(_p)	BU_CKMAG_TCL(interp,_p,(long)DBI_MAGIC,"struct db_i")
#define RT_CK_RTI_TCL(_p)	BU_CKMAG_TCL(interp,_p,(long)RTI_MAGIC,"struct rt_i")
#define RT_CK_WDB_TCL(_p)	BU_CKMAG_TCL(interp,_p,(long)RT_WDB_MAGIC,"struct rt_wdb")
d482 6
d744 1
a744 1
 *		D B _ T C L _ C O M B _ D E S C R I B E
d746 2
a747 1
 * Sets the interp->result string to a description of the given combination.
a748 1

d750 4
a753 4
db_tcl_comb_describe( interp, comb, item )
Tcl_Interp		*interp;
struct rt_comb_internal *comb;
CONST char		*item;
d755 1
d758 4
a761 6
	
	if( !comb ) {
		Tcl_AppendResult( interp, "error: null combination",
				  (char *)NULL );
		return TCL_ERROR;
	}
d890 1
a890 1
 *			D B _ T C L _ C O M B _ A D J U S T
d892 1
a892 1
 *  Invocation:
d894 2
a896 1

d898 5
a902 5
db_tcl_comb_adjust( comb, interp, argc, argv )
struct rt_comb_internal	       *comb;
Tcl_Interp		       *interp;
int				argc;
char			      **argv;
d904 1
d908 4
a911 2
	
	RT_CK_COMB( comb );
d1054 2
a1055 1
	Tcl_AppendResult( interp, "attribute not valid for non-region",
d1060 6
d1211 66
d1284 2
d1290 1
a1290 1
struct rt_db_internal	*intern;
a1294 1

a1295 2
	Tcl_DString             ds;
	struct bu_vls           str;
d1304 2
d1308 1
a1308 3
		status = db_tcl_comb_describe( interp,
			       (struct rt_comb_internal *)intern->idb_ptr,
					       attr );
d1317 1
a1317 34

		bu_vls_init( &str );
		Tcl_DStringInit( &ds );

		sp = ftp->ft_parsetab;
		if( attr == (char *)0 ) {
			/* Print out solid type and all attributes */
			Tcl_DStringAppendElement( &ds, ftp->ft_label );
			while( sp->sp_name != NULL ) {
				Tcl_DStringAppendElement( &ds, sp->sp_name );
				bu_vls_trunc( &str, 0 );
				bu_vls_struct_item( &str, sp,
						 (char *)intern->idb_ptr, ' ' );
				Tcl_DStringAppendElement( &ds,
							  bu_vls_addr(&str) );
				++sp;
			}
			status = TCL_OK;
		} else {
			if( bu_vls_struct_item_named( &str, sp, attr,
					   (char *)intern->idb_ptr, ' ') < 0 ) {
				bu_vls_printf(&str,
					"Objects of type %s do not have a %s attribute.",
					ftp->ft_label, attr);
				status = TCL_ERROR;
			} else {
				status = TCL_OK;
			}
			Tcl_DStringAppendElement( &ds, bu_vls_addr(&str) );
		}

		Tcl_DStringResult( interp, &ds );
		Tcl_DStringFree( &ds );
		bu_vls_free( &str );
d1376 1
d1383 87
d1503 5
a1507 5
	/* XXX
	   Verify that this wdb supports lookup operations (non-null dbip) */
	/* If not, just skip the lookup test and write the object */

	if( db_lookup(wdb->dbip, argv[1], LOOKUP_QUIET) != DIR_NULL ) {
d1521 8
d1530 2
a1531 19
		struct rt_comb_internal *comb;
		intern.idb_type = ID_COMBINATION;
		intern.idb_ptr = bu_calloc( sizeof(struct rt_comb_internal), 1,
					    "rt_db_put" );
		/* Create combination with appropriate values */
		comb = (struct rt_comb_internal *)intern.idb_ptr;
		comb->magic = (long)RT_COMB_MAGIC;
		comb->temperature = -1;
		comb->tree = (union tree *)0;
		comb->region_flag = 1;
		comb->region_id = 0;
		comb->aircode = 0;
		comb->GIFTmater = 0;
		comb->los = 0;
		comb->rgb_valid = 0;
		comb->rgb[0] = comb->rgb[1] = comb->rgb[2] = 0;
		bu_vls_init( &comb->shader );
		bu_vls_init( &comb->material );
		comb->inherit = 0;
d1533 3
a1535 1
		if( db_tcl_comb_adjust( comb, interp, argc-3,
d1541 2
a1542 7
		ftp = rt_get_functab_by_label( type );
		if( ftp == NULL ) {
			Tcl_AppendResult( interp, type,
					  " is an unknown object type.",
					  (char *)NULL );
			return TCL_ERROR;
		}
d1544 1
a1544 6
		if( ftp->ft_parsetab == (struct bu_structparse *)NULL ) {
			Tcl_AppendResult( interp, type,
					  " type objects do not yet have a 'db put' handler.",
					  (char *)NULL );
			return TCL_ERROR;
		}
d1546 1
a1546 8
		intern.idb_type = ftp - rt_functab;
		BU_ASSERT(&rt_functab[intern.idb_type] == ftp);
		intern.idb_meth = ftp;
		intern.idb_ptr = bu_calloc( ftp->ft_internal_size, 1,
					    "rt_db_put" );
		*((long *)intern.idb_ptr) = ftp->ft_internal_magic;
		if( bu_structparse_argv(interp, argc-3, argv+3, ftp->ft_parsetab,
					(char *)intern.idb_ptr )==TCL_ERROR ) {
d1598 1
a1598 2
	/* XXX
	   Verify that this wdb supports lookup operations (non-null dbip) */
d1620 1
a1621 4
		struct rt_comb_internal *comb =
			(struct rt_comb_internal *)intern.idb_ptr;
		RT_CK_COMB(comb);

d1623 1
a1623 8
		status = db_tcl_comb_adjust( comb, interp, argc-3, argv+3 );
	} else if( (sp = intern.idb_meth->ft_parsetab) == NULL )  {
		Tcl_AppendResult( interp,
	           "Manipulation routines for objects of type ",
		   intern.idb_meth->ft_label,
		   " have not yet been implemented.",
				  (char *)NULL );
		status = TCL_ERROR;
a1624 4
		/* If we were able to find an entry in the strutparse "cheat sheet",
		   just use the handy parse functions to return the object.
		   Pass first attribute as argv[0].
		 */
d1626 1
a1626 5
		status = bu_structparse_argv( interp, argc-3, argv+3, sp,
					      (char *)intern.idb_ptr );
		if( status != TCL_OK )  Tcl_AppendResult( interp,
			"bu_structparse_argv(", name, ") failure\n", (char *)NULL );
		/* fall through */
@


1.69
log
@
Cleaned up the code.
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tcl.c,v 1.68 1999/11/18 19:54:32 mike Exp $ (ARL)";
a1937 155
 *			D B _ T C L _ F O L L O W _ P A T H
 *
 *  Provides the same format output as a "db get" operation on a
 *  combination, as much as possible.
 */
int
db_tcl_follow_path( clientData, interp, argc, argv )
ClientData	clientData;
Tcl_Interp	*interp;
int		argc;
char		**argv;
{
	struct db_i		*dbip;
	struct db_tree_state	ts;
	struct db_full_path	old_path;
	struct db_full_path	new_path;
	Tcl_DString		ds;
	char			buf[128];
	int			ret;

	if( argc != 3 )  {
		Tcl_AppendResult(interp, "Usage: db_follow_path [get_dbip] path\n", NULL);
		return TCL_ERROR;
	}

	dbip = (struct db_i *)atol( argv[1] );
	/* Could core dump */
	RT_CK_DBI_TCL(dbip);

	db_init_db_tree_state( &ts, dbip );
	db_full_path_init(&old_path);
	db_full_path_init(&new_path);

	if( db_string_to_path( &new_path, dbip, argv[2] ) < 0 )  {
		Tcl_AppendResult(interp, "tcl_follow_path: '",
			argv[2], "' contains unknown object names\n", (char *)NULL);
		return TCL_ERROR;
	}
	ret = db_follow_path( &ts, &old_path, &new_path, LOOKUP_NOISY );
	db_free_full_path( &old_path );
	db_free_full_path( &new_path );

	if( ret < 0 )  {
		Tcl_AppendResult(interp, "tcl_follow_path: '",
			argv[2], "' is a bad path\n", (char *)NULL );
		return TCL_ERROR;
	}

	/* Could be called db_tcl_tree_state_describe() */
	Tcl_DStringInit( &ds );

	Tcl_DStringAppendElement( &ds, "region" );
	if( ts.ts_sofar & TS_SOFAR_REGION ) {
		Tcl_DStringAppendElement( &ds, "yes" );

		Tcl_DStringAppendElement( &ds, "id" );
		sprintf( buf, "%d", ts.ts_regionid );
		Tcl_DStringAppendElement( &ds, buf );

		if( ts.ts_aircode )  {
			Tcl_DStringAppendElement( &ds, "air" );
			sprintf( buf, "%d", ts.ts_aircode );
			Tcl_DStringAppendElement( &ds, buf );
		}

		if( ts.ts_los )  {
			Tcl_DStringAppendElement( &ds, "los" );
			sprintf( buf, "%d", ts.ts_los );
			Tcl_DStringAppendElement( &ds, buf );
		}

		if( ts.ts_gmater )  {
			Tcl_DStringAppendElement( &ds, "GIFTmater" );
			sprintf( buf, "%d", ts.ts_gmater );
			Tcl_DStringAppendElement( &ds, buf );
		}
	} else {
		Tcl_DStringAppendElement( &ds, "no" );
	}
		
	if( ts.ts_mater.ma_color_valid ) {
		Tcl_DStringAppendElement( &ds, "rgb" );
		sprintf( buf, "%d %d %d",
			(int)(ts.ts_mater.ma_color[0]*255),
			(int)(ts.ts_mater.ma_color[1]*255),
			(int)(ts.ts_mater.ma_color[2]*255) );
		Tcl_DStringAppendElement( &ds, buf );
	}

	if( ts.ts_mater.ma_temperature > 0 )  {
		Tcl_DStringAppendElement( &ds, "temp" );
		sprintf( buf, "%g", ts.ts_mater.ma_temperature );
		Tcl_DStringAppendElement( &ds, buf );
	}

	if( ts.ts_mater.ma_shader && strlen( ts.ts_mater.ma_shader ) > 0 )  {
		Tcl_DStringAppendElement( &ds, "shader" );
		Tcl_DStringAppendElement( &ds, ts.ts_mater.ma_shader );
	}

#if 0
	Tcl_DStringAppendElement( &ds, "material" );
	Tcl_DStringAppendElement( &ds, bu_vls_addr(&comb->material) );
#endif
	if( ts.ts_mater.ma_minherit )
		Tcl_DStringAppendElement( &ds, "inherit" );

	if ( !bn_mat_is_identity( ts.ts_mat ) )  {
		struct bu_vls	str;
		Tcl_DStringAppendElement( &ds, "mat" );
		bu_vls_init(&str);
		bn_encode_mat( &str, ts.ts_mat );
		Tcl_DStringAppendElement( &ds, bu_vls_addr(&str) );
		bu_vls_free(&str);
	}

	db_free_db_tree_state( &ts );

	Tcl_DStringResult( interp, &ds );
	Tcl_DStringFree( &ds );

	return TCL_OK;
}

/*
 *  XXX This interface is deprecated.  Used "wdb_open" instead.
 */
int
rt_tcl_db_open( clientData, interp, argc, argv )
ClientData	clientData;
Tcl_Interp	*interp;
int		argc;
char		**argv;
{
  char buf[128];
  struct db_i *dbip = DBI_NULL;

  if(argc != 2)
    return TCL_ERROR;

  if( ((dbip = db_open( argv[1], "r+w" )) == DBI_NULL ) &&
      ((dbip = db_open( argv[1], "r"   )) == DBI_NULL ) )  {
    return TCL_ERROR;
  }

  /* --- Scan geometry database and build in-memory directory --- */
  db_scan( dbip, (int (*)())db_diradd, 1);

  sprintf( buf, "%ld", (long)(*((void **)&dbip)) );
  Tcl_AppendResult( interp, buf, (char *)NULL );

  return TCL_OK;
}

/*
d1942 9
a1956 4
		(ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);
	(void)Tcl_CreateCommand(interp, "rt_db_open", rt_tcl_db_open,
		(ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);
	(void)Tcl_CreateCommand(interp, "db_follow_path", db_tcl_follow_path,
@


1.68
log
@
Improved commenting
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tcl.c,v 1.67 1999/11/18 03:51:08 mike Exp $ (ARL)";
d1086 102
d1193 2
d1200 1
a1200 1
char			*attr;
d1250 3
a1252 2
				Tcl_DStringAppend( &ds, "no such attribute",
						   17 );
a1254 2
				Tcl_DStringAppendElement( &ds,
							  bu_vls_addr(&str) );
d1257 1
d1317 1
a1317 5
#if 0
	dp = db_lookup( wdb->dbip, argv[1], LOOKUP_QUIET );
	if( dp == NULL ) {
		Tcl_AppendResult( interp, argv[1], ": not found\n",
				  (char *)NULL );
a1318 1
	}
a1319 64
	status = rt_db_get_internal( &intern, dp, wdb->dbip, (matp_t)NULL );
	if( status < 0 ) {
		Tcl_AppendResult( interp, "rt_db_get_internal failure: ",
				  argv[1], (char *)NULL );
		return TCL_ERROR;
	}
#else
	if( strchr( argv[1], '/' ) )
	{
		/* This is a path */
		struct db_tree_state	ts;
		struct db_full_path	old_path;
		struct db_full_path	new_path;
		struct directory	*dp_curr;
		int			ret;

		db_init_db_tree_state( &ts, wdb->dbip );
		db_full_path_init(&old_path);
		db_full_path_init(&new_path);

		if( db_string_to_path( &new_path, wdb->dbip, argv[1] ) < 0 )  {
			Tcl_AppendResult(interp, "tcl_follow_path: '",
				argv[1], "' contains unknown object names\n", (char *)NULL);
			return TCL_ERROR;
		}

		dp_curr = DB_FULL_PATH_CUR_DIR( &new_path );
		ret = db_follow_path( &ts, &old_path, &new_path, LOOKUP_NOISY );
		db_free_full_path( &old_path );
		db_free_full_path( &new_path );

		if( ret < 0 )  {
			Tcl_AppendResult(interp, "tcl_follow_path: '",
				argv[1], "' is a bad path\n", (char *)NULL );
			return TCL_ERROR;
		}

		status = wdb_import( wdb, &intern, dp_curr->d_namep, ts.ts_mat );
		if( status == -4 )  {
			Tcl_AppendResult( interp, dp_curr->d_namep, ": not found\n",
					  (char *)NULL );
			return TCL_ERROR;
		}
		if( status < 0 ) {
			Tcl_AppendResult( interp, "wdb_import failure: ",
					  dp_curr->d_namep, (char *)NULL );
			return TCL_ERROR;
		}
	}
	else
	{
		status = wdb_import( wdb, &intern, argv[1], (matp_t)NULL );
		if( status == -4 )  {
			Tcl_AppendResult( interp, argv[1], ": not found\n",
					  (char *)NULL );
			return TCL_ERROR;
		}
		if( status < 0 ) {
			Tcl_AppendResult( interp, "wdb_import failure: ",
					  argv[1], (char *)NULL );
			return TCL_ERROR;
		}
	}
#endif
@


1.67
log
@
Cleanup -- removed unnecessary externs.
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tcl.c,v 1.66 1999/11/18 03:22:33 mike Exp $ (ARL)";
d434 7
@


1.66
log
@
Changed from using internal table about solids to using
information from rt_functab[], as located by rt_get_functab_by_label().
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tcl.c,v 1.65 1999/11/18 02:42:18 mike Exp $ (ARL)";
a59 30
extern struct bu_structparse rt_tor_parse[];
extern struct bu_structparse rt_tgc_parse[];
extern struct bu_structparse rt_ell_parse[];
extern struct bu_structparse rt_arb_parse[];
/* ARS -- not supported yet */
extern struct bu_structparse rt_hlf_parse[];
/* REC -- subsumed by TGC */
/* POLY -- not supported yet */
/* BSPLINE -- not supported yet */
/* SPH -- not supported yet */
/* NMG -- not supported yet */
extern struct bu_structparse rt_ebm_parse[];
extern struct bu_structparse rt_vol_parse[];
/* ARBN -- not supported yet */
/* PIPE -- not supported yet */
extern struct bu_structparse rt_part_parse[];
extern struct bu_structparse rt_rpc_parse[];
extern struct bu_structparse rt_rhc_parse[];
extern struct bu_structparse rt_epa_parse[];
extern struct bu_structparse rt_ehy_parse[];
extern struct bu_structparse rt_eto_parse[];
/* GRIP -- not supported yet */
/* JOINT -- not supported yet */
extern struct bu_structparse rt_hf_parse[];
extern struct bu_structparse rt_dsp_parse[];
extern struct bu_structparse rt_fgp_parse[];
/* COMB -- supported below */

static struct db_i *dbip = DBI_NULL;

d1083 1
d2020 3
d2031 1
@


1.65
log
@
Pushed bu_structparse_get_terse_form() into libbu
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tcl.c,v 1.64 1999/11/17 04:39:21 mike Exp $ (ARL)";
a89 34
/* XXX This should probably become part of the rt_functab in librt/table.c */

struct rt_solid_type_lookup {
	char			id;
	size_t			db_internal_size;
	long			magic;
	char		       *label;
	struct bu_structparse  *parsetab;
} rt_solid_type_lookup[] = {
	{ ID_TOR,     sizeof(struct rt_tor_internal), (long)RT_TOR_INTERNAL_MAGIC, "tor", rt_tor_parse },
	{ ID_TGC,     sizeof(struct rt_tgc_internal), (long)RT_TGC_INTERNAL_MAGIC, "tgc", rt_tgc_parse },
	{ ID_ELL,     sizeof(struct rt_ell_internal), (long)RT_ELL_INTERNAL_MAGIC, "ell", rt_ell_parse },
	{ ID_ARB8,    sizeof(struct rt_arb_internal), (long)RT_ARB_INTERNAL_MAGIC, "arb8", rt_arb_parse },
	{ ID_HALF,    sizeof(struct rt_half_internal),(long)RT_HALF_INTERNAL_MAGIC,"half", rt_hlf_parse },
	{ ID_REC,     sizeof(struct rt_tgc_internal), (long)RT_TGC_INTERNAL_MAGIC, "rec", rt_tgc_parse },
	{ ID_ELL,     sizeof(struct rt_ell_internal), (long)RT_ELL_INTERNAL_MAGIC, "sph", rt_ell_parse },
	{ ID_EBM,     sizeof(struct rt_ebm_internal), (long)RT_EBM_INTERNAL_MAGIC, "ebm", rt_ebm_parse },
	{ ID_VOL,     sizeof(struct rt_vol_internal), (long)RT_VOL_INTERNAL_MAGIC, "vol", rt_vol_parse },
	{ ID_PARTICLE,sizeof(struct rt_part_internal),(long)RT_PART_INTERNAL_MAGIC,"part", rt_part_parse },
	{ ID_RPC,     sizeof(struct rt_rpc_internal), (long)RT_RPC_INTERNAL_MAGIC, "rpc", rt_rpc_parse },
	{ ID_RHC,     sizeof(struct rt_rhc_internal), (long)RT_RHC_INTERNAL_MAGIC, "rhc", rt_rhc_parse },
	{ ID_EPA,     sizeof(struct rt_epa_internal), (long)RT_EPA_INTERNAL_MAGIC, "epa", rt_epa_parse },
	{ ID_EHY,     sizeof(struct rt_ehy_internal), (long)RT_EHY_INTERNAL_MAGIC, "ehy", rt_ehy_parse },
	{ ID_ETO,     sizeof(struct rt_eto_internal), (long)RT_ETO_INTERNAL_MAGIC, "eto", rt_eto_parse },
	{ ID_HF,      sizeof(struct rt_hf_internal),  (long)RT_HF_INTERNAL_MAGIC,  "hf",  rt_hf_parse },
	{ ID_DSP,     sizeof(struct rt_dsp_internal), (long)RT_DSP_INTERNAL_MAGIC, "dsp", rt_dsp_parse },
	{ ID_ARS, 0, 0, "ars", 0 },
	{ ID_NMG, 0, 0, "nmg", 0 },
	{ ID_PIPE, 0, 0, "pipe", 0 },
	{ ID_VOL, 0, 0, "vol", 0 },
	{ ID_FGP,   sizeof( struct rt_fgp_internal), (long)RT_FGP_INTERNAL_MAGIC, "fgp", rt_fgp_parse },
	{ 0, 0, 0, 0 }
};

a498 36
 *		R T _ G E T _ P A R S E T A B _ B Y _ I D
 */

struct rt_solid_type_lookup *
rt_get_parsetab_by_id( s_id )
int s_id;
{
	register struct rt_solid_type_lookup   *stlp;
	static struct rt_solid_type_lookup	solid_type;

	for( stlp = rt_solid_type_lookup; stlp->id != 0; stlp++ )
		if( stlp->id == s_id )
			return stlp;

	return NULL;
}

/*
 *		R T _ G E T _ P A R S E T A B _ B Y _ N A M E
 */

struct rt_solid_type_lookup *
rt_get_parsetab_by_name( s_type )
char *s_type;
{
	register int				i;
	register struct rt_solid_type_lookup   *stlp;

	for( stlp = rt_solid_type_lookup; stlp->id != 0; stlp++ )
		if( strcmp(s_type, stlp->label) == 0 )
			return stlp;

	return NULL;
}

/*
d1108 6
d1120 3
a1122 2
	register struct bu_structparse         *sp = NULL;
	register struct rt_solid_type_lookup   *stlp;
d1131 3
d1141 3
a1143 10
		if( (stlp=rt_get_parsetab_by_id(id)) == NULL ) {
			Tcl_AppendResult( interp,
 "invalid {an output routine for this data type has not yet been implemented}",
				  (char *)NULL );
			return TCL_OK;
		}

		if( stlp->parsetab == (struct bu_structparse *)NULL ) {
			Tcl_AppendResult( interp, stlp->label,
 " {an output routine for this data type has not yet been implemented}",
d1151 1
a1151 1
		sp = stlp->parsetab;
d1154 1
a1154 1
			Tcl_DStringAppendElement( &ds, stlp->label );
d1309 1
a1309 1
	rt_functab[intern.idb_type].ft_ifree( &intern );
d1328 1
a1328 1
	register struct rt_solid_type_lookup   *stlp;
d1330 1
a1330 1
	int					status, ngran, id, i;
d1367 1
a1367 1
		id = intern.idb_type = ID_COMBINATION;
d1392 4
a1395 4
		stlp = rt_get_parsetab_by_name( type );
		if( stlp == NULL ) {
			Tcl_AppendResult( interp,
					  "unknown object type",
d1400 3
a1402 3
		if( stlp->parsetab == (struct bu_structparse *)NULL ) {
			Tcl_AppendResult( interp, stlp->label,
					  " object type not supported",
d1407 4
a1410 3
		id = intern.idb_type = stlp->id;
		intern.idb_meth = &rt_functab[id];
		intern.idb_ptr = bu_calloc( stlp->db_internal_size, 1,
d1412 2
a1413 2
		*((long *)intern.idb_ptr) = stlp->magic;
		if( bu_structparse_argv(interp, argc-3, argv+3, stlp->parsetab,
d1450 1
a1450 1
	register struct bu_structparse	*sp = NULL;
d1487 1
d1496 1
a1496 2
	} else if( rt_get_parsetab_by_id(id) == NULL ||
		   (sp=rt_get_parsetab_by_id(id)->parsetab) == NULL ) {
d1498 3
a1500 1
           "manipulation routines for this type have not yet been implemented",
d1538 2
a1539 2
	register struct bu_structparse *sp = NULL;
	struct rt_solid_type_lookup	*stlp = NULL;
d1550 1
a1550 1
	if( (stlp = rt_get_parsetab_by_name(argv[1])) == NULL )  {
d1555 1
a1555 1
	sp = stlp->parsetab;
@


1.64
log
@
Added 3 new fields to rt_functab, in order to better support the TCL
interface to db get and db put.
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tcl.c,v 1.63 1999/11/17 03:44:16 mike Exp $ (ARL)";
d1603 1
a1603 4
	register struct rt_solid_type_lookup *stlp;
	register int i;
	struct bu_vls str;
	register char *cp;
d1614 6
a1619 3
	bu_vls_init(&str);
	sp = rt_get_parsetab_by_name(argv[1]) == NULL ? NULL :
		rt_get_parsetab_by_name(argv[1])->parsetab;
d1622 1
a1622 17
		while (sp->sp_name != NULL) {
			Tcl_AppendElement(interp, sp->sp_name);
			bu_vls_trunc(&str, 0);
			if (strcmp(sp->sp_fmt, "%c") == 0 ||
			    strcmp(sp->sp_fmt, "%s") == 0) {
				if (sp->sp_count > 1)
					bu_vls_printf(&str, "%%%ds", sp->sp_count);
				else
					bu_vls_printf(&str, "%%c");
			} else {
				bu_vls_printf(&str, "%s", sp->sp_fmt);
				for (i = 1; i < sp->sp_count; i++)
					bu_vls_printf(&str, " %s", sp->sp_fmt);
			}
			Tcl_AppendElement(interp, bu_vls_addr(&str));
			++sp;
		}
d1624 4
a1627 3
		Tcl_AppendResult(interp, "a form routine for this data type has not \
yet been implemented", (char *)NULL);
		goto error;
a1628 2

	bu_vls_free(&str);
a1629 4

error:
	bu_vls_free(&str);
	return TCL_ERROR;
@


1.63
log
@
Added idb_meth init
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tcl.c,v 1.62 1999/10/12 13:58:13 jra Exp $ (ARL)";
d63 1
a63 1
extern struct bu_structparse rt_arb8_parse[];
d65 1
a65 1
extern struct bu_structparse rt_half_parse[];
d102 2
a103 2
	{ ID_ARB8,    sizeof(struct rt_arb_internal), (long)RT_ARB_INTERNAL_MAGIC, "arb8", rt_arb8_parse },
	{ ID_HALF,    sizeof(struct rt_half_internal),(long)RT_HALF_INTERNAL_MAGIC,"half", rt_half_parse },
@


1.62
log
@Added fgp solid (FastGen Plate mode)
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tcl.c,v 1.61 1999/05/10 21:30:48 mike Exp $ (ARL)";
d1475 1
@


1.61
log
@Variable name changed from ma_override to ma_color_valid
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tcl.c,v 1.60 1999/05/06 18:48:03 bparker Exp $ (ARL)";
d85 1
d120 1
@


1.60
log
@*- mods to cause rt_db_report to include the solid type for
	known solids that do not have a parsetab

	- add to rt_solid_type_lookup[]
	- handle new array members who have a NULL parsetab
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tcl.c,v 1.59 1999/04/12 19:52:12 bparker Exp $ (ARL)";
d2087 1
a2087 1
	if( ts.ts_mater.ma_override ) {
@


1.59
log
@*- exterminated bugs in rt_tcl_rt_prep
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tcl.c,v 1.58 1999/04/02 21:18:12 bparker Exp $ (ARL)";
d101 2
a102 2
	{ ID_ARB8,    sizeof(struct rt_arb_internal), (long)RT_ARB_INTERNAL_MAGIC, "arb8",rt_arb8_parse },
	{ ID_HALF,    sizeof(struct rt_half_internal),(long)RT_HALF_INTERNAL_MAGIC,"half",rt_half_parse },
d107 1
a107 1
	{ ID_PARTICLE,sizeof(struct rt_part_internal),(long)RT_PART_INTERNAL_MAGIC,"part",rt_part_parse },
d115 4
d1206 7
a1271 1
	register struct rt_solid_type_lookup   *stlp;
d1461 7
@


1.58
log
@*- add rt_tcl_db_open
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tcl.c,v 1.57 1999/01/25 14:29:23 jra Exp $ (ARL)";
d435 1
a435 1
	if( argc < 2 || argc > 5 )  {
d457 1
a457 1
	if( argc >= 3 )  rtip->rti_hasty_prep = atoi(argv[3]);
@


1.57
log
@Modified db_tcl_comb_adjust() so that a parameter value of "none" means "set this parameter to
its not used value or its default.
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tcl.c,v 1.56 1999/01/21 19:41:43 jra Exp $ (ARL)";
d87 2
d2114 26
d2151 2
@


1.56
log
@A slight improvment to the previous cahnge for db_tcl_comb_describe().
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tcl.c,v 1.55 1999/01/21 16:31:35 jra Exp $ (ARL)";
d989 8
a996 3
			if( Tcl_GetBoolean( interp, argv[1], &i )!= TCL_OK )
				return TCL_ERROR;
			comb->region_flag = (char)i;
d999 8
a1006 3
			if( Tcl_GetDouble( interp, argv[1], &d ) != TCL_OK )
				return TCL_ERROR;
			comb->temperature = (float)d;
d1009 8
a1016 3
			if( Tcl_GetInt( interp, argv[1], &i ) != TCL_OK )
				return TCL_ERROR;
			comb->region_id = (short)i;
d1019 8
a1026 3
			if( Tcl_GetInt( interp, argv[1], &i ) != TCL_OK)
				return TCL_ERROR;
			comb->aircode = (short)i;
d1029 8
a1036 3
			if( Tcl_GetInt( interp, argv[1], &i ) != TCL_OK )
				return TCL_ERROR;
			comb->los = (short)i;
d1039 8
a1046 3
			if( Tcl_GetInt( interp, argv[1], &i ) != TCL_OK )
				return TCL_ERROR;
			comb->GIFTmater = (short)i;
d1048 1
a1048 1
			if( strcmp(argv[1], "invalid")==0 ) {
d1068 6
a1073 3
			bu_vls_strcat( &comb->shader, argv[1] );
			/* Leading spaces boggle the combination exporter */
			bu_vls_trimspace( &comb->shader );
d1076 5
a1080 2
			bu_vls_strcat( &comb->material, argv[1] );
			bu_vls_trimspace( &comb->material );
d1082 8
a1089 3
			if( Tcl_GetBoolean( interp, argv[1], &i ) != TCL_OK )
				return TCL_ERROR;
			comb->inherit = (char)i;
d1093 16
a1108 5
			new = db_tcl_tree_parse( interp, argv[1] );
			if( new == TREE_NULL )  {
				Tcl_AppendResult( interp, "db adjust tree: bad tree '",
					argv[1], "'\n", (char *)NULL );
				return TCL_ERROR;
a1109 3
			if( comb->tree )
				db_free_tree( comb->tree );
			comb->tree = new;
@


1.55
log
@db_tcl_comb_describe() was not adding the "yes" or "no" for inheritance.
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tcl.c,v 1.54 1999/01/12 01:53:24 mike Exp $ (ARL)";
d885 1
a885 2
		if( comb->inherit )
		{
d887 1
a887 2
			strcpy( buf, comb->inherit ? "yes" : "no" );
			Tcl_DStringAppendElement( &ds, buf );
@


1.54
log
@When constructing structures in "db put", need to use bu_calloc() to make
sure that uninitialized structure members start out as NULL.
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tcl.c,v 1.53 1998/12/21 19:00:08 bparker Exp $ (ARL)";
d886 1
d888 3
@


1.53
log
@*- changed ID_SPH to ID_ELL in rt_solid_type_lookup table
	(i.e "db put my_sph sph sph_attrs" was failing)
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tcl.c,v 1.52 1998/12/17 04:19:10 mike Exp $ (ARL)";
d1370 1
a1370 1
		intern.idb_ptr = bu_malloc( sizeof(struct rt_comb_internal),
d1403 1
a1403 1
		intern.idb_ptr = bu_malloc( stlp->db_internal_size,
@


1.52
log
@Regions now have an associated temperature
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tcl.c,v 1.51 1998/08/12 20:58:46 bparker Exp $ (ARL)";
d102 1
a102 1
	{ ID_SPH,     sizeof(struct rt_ell_internal), (long)RT_ELL_INTERNAL_MAGIC, "sph", rt_ell_parse },
@


1.51
log
@*- took the formatting code from rt_db_get and stuffed it into
   a new routine called rt_db_report. MGED uses this to
   format es_int.
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tcl.c,v 1.50 1998/08/12 20:21:38 jra Exp $ (ARL)";
d976 1
d990 5
d1375 1
d2023 6
@


1.50
log
@"db get" will now handle paths.
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tcl.c,v 1.49 1998/06/25 07:46:30 mike Exp $ (ARL)";
d1113 68
d1303 1
a1303 52
	RT_CK_DB_INTERNAL( &intern );

       /* Find out what type of object we are dealing with and report on it. */
	id = intern.idb_type;
	switch( id ) {
	case ID_COMBINATION:
		status = db_tcl_comb_describe( interp,
			       (struct rt_comb_internal *)intern.idb_ptr,
					       argv[2] );
		break;
	default:
		if( (stlp=rt_get_parsetab_by_id(id)) == NULL ) {
			Tcl_AppendResult( interp,
 "invalid {an output routine for this data type has not yet been implemented}",
				  (char *)NULL );
			return TCL_OK;
		}

		bu_vls_init( &str );
		Tcl_DStringInit( &ds );

		sp = stlp->parsetab;
		if( argc == 2 ) {
			/* Print out solid type and all attributes */
			Tcl_DStringAppendElement( &ds, stlp->label );
			while( sp->sp_name != NULL ) {
				Tcl_DStringAppendElement( &ds, sp->sp_name );
				bu_vls_trunc( &str, 0 );
				bu_vls_struct_item( &str, sp,
						 (char *)intern.idb_ptr, ' ' );
				Tcl_DStringAppendElement( &ds,
							  bu_vls_addr(&str) );
				++sp;
			}
			status = TCL_OK;
		} else {
			if( bu_vls_struct_item_named( &str, sp, argv[2],
					   (char *)intern.idb_ptr, ' ') < 0 ) {
				Tcl_DStringAppend( &ds, "no such attribute",
						   17 );
				status = TCL_ERROR;
			} else {
				Tcl_DStringAppendElement( &ds,
							  bu_vls_addr(&str) );
				status = TCL_OK;
			}
		}

		Tcl_DStringResult( interp, &ds );
		Tcl_DStringFree( &ds );
		bu_vls_free( &str );
	}
d1305 1
a1305 1
	rt_functab[id].ft_ifree( &intern );
@


1.49
log
@Port to sun4
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/tcl.c,v 1.48 1998/05/12 17:44:20 mike Exp $ (ARL)";
d1142 1
d1178 41
a1218 5
	status = wdb_import( wdb, &intern, argv[1], (matp_t)NULL );
	if( status == -4 )  {
		Tcl_AppendResult( interp, argv[1], ": not found\n",
				  (char *)NULL );
		return TCL_ERROR;
d1220 13
a1232 4
	if( status < 0 ) {
		Tcl_AppendResult( interp, "wdb_import failure: ",
				  argv[1], (char *)NULL );
		return TCL_ERROR;
@


1.48
log
@Added ".inmem dump" directive to Tcl interface,
to write the current state of a database out to a file.
Added db_dump() as underlying C implementation.
Added wdb_export_external() for a clean path out via LIBWDB.
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tcl.c,v 1.47 1998/05/04 17:19:43 jra Exp mike $ (ARL)";
d1972 1
a1972 1
		bn_encode_mat( &str, &ts.ts_mat );
@


1.47
log
@db_tcl_comb_adjust() was freeing "comb->tree" without checking if it was NULL first!!.
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tcl.c,v 1.46 1998/03/26 07:44:54 mike Exp jra $ (ARL)";
d1663 46
d1717 1
@


1.46
log
@db_close() now honors dbi_uses use-count protocol.
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tcl.c,v 1.45 1998/03/24 09:46:44 mike Exp mike $ (ARL)";
d1050 2
a1051 1
			db_free_tree( comb->tree );
@


1.45
log
@Oops, forgot to change option letter to -u
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tcl.c,v 1.44 1998/03/24 09:18:54 mike Exp mike $ (ARL)";
a1554 1
	rt_ck(rtip);
a1555 2
#if 0
	/* Warning!  This calls db_close()!  Clobber city. */
a1556 5
#else
	rt_clean( rtip );
	rtip->rti_dbip = (struct db_i *)NULL;
	bu_free( (genptr_t)rtip, "struct rt_i" );
#endif
d1558 1
a1622 2
#if 0
		/* Warning!  This calls db_close()!  Clobber city. */
a1623 5
#else
		rt_clean( rtip );
		rtip->rti_dbip = (struct db_i *)NULL;
		bu_free( (genptr_t)rtip, "struct rt_i" );
#endif
@


1.44
log
@Oops, useair has to be set before walking the trees, too.
Ergo, a -u option.
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tcl.c,v 1.43 1998/03/24 08:38:27 mike Exp mike $ (ARL)";
d1618 1
a1618 1
		if( strcmp( argv[3], "-i" ) == 0 )  {
@


1.43
log
@Added "check" operation to LIBRT object.
Changed LIBRT and database objects to release memory for previous
object of identical name before consuming memory for the new one.
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tcl.c,v 1.42 1998/03/24 07:13:22 mike Exp mike $ (ARL)";
d437 1
a437 1
				" [use_air [hasty_prep]]\"",
d455 1
a455 2
	if( argc >= 3 )  rtip->useair = atoi(argv[2]);
	if( argc >= 4 )  rtip->rti_hasty_prep = atoi(argv[3]);
d462 1
a462 2
	bu_vls_printf( &str, "useair %d hasty_prep %d dont_instance %d needprep %d",
		rtip->useair,
d465 1
d1601 1
a1601 1
			" newprocname [-i] treetops...\"\n", (char *)NULL );
d1611 14
a1624 4
	if( strcmp( argv[3], "-i" ) == 0 )  {
		rtip->rti_dont_instance = 1;
		argc--;
		argv++;
@


1.42
log
@Added "no_bool" operation to LIBRT object.
Further refinement of resource struct allocation.
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tcl.c,v 1.41 1998/03/24 05:35:30 mike Exp mike $ (ARL)";
d377 37
d479 1
d1556 1
d1609 3
d1653 2
a1655 1
	/* XXX should we see if it exists first? default=overwrite */
d1662 1
a1662 1
	
d1781 3
a1812 1
	/* XXX should we see if it exists first? default=overwrite */
@


1.41
log
@Don't use rt_uniresource, use per-LIBRT-instance resource struct.
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tcl.c,v 1.40 1998/03/24 05:11:02 mike Exp mike $ (ARL)";
d339 38
d441 1
a1518 5
	RT_CK_RESOURCE(ap->a_resource);
	rt_free_resource(rtip, ap->a_resource);
	bu_free( (genptr_t)ap->a_resource, "a_resource" );
	ap->a_resource = (struct resource *)NULL;

d1527 1
d1600 1
d1604 1
@


1.40
log
@Changed terminology from "widget" to "newprocname", as
these procs have nothing to do with Tk widgets.
Needed to move "dont_instance" flag out of "prep" and into "rt_gettrees",
as it has to be set _before_ doing the treewalking.
Now it's a -i option to rt_gettrees.
If st_path has been set in a soltab, print it.
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tcl.c,v 1.39 1998/03/19 14:42:24 mike Exp mike $ (ARL)";
d1480 5
d1517 1
d1558 11
d1570 1
@


1.39
log
@Oops, rt_free_rti() clobbers dbip.
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tcl.c,v 1.38 1998/03/19 14:08:40 mike Exp $ (ARL)";
d164 9
a172 3
	bu_vls_printf( &str, "} surfno %d solid %s}",
		hitp->hit_surfno,
		dp->d_namep );
d227 1
a227 1
 *	widgetname shootray {P} dir|at {V}
d303 2
a304 2
 *	widgetname onehit
 *	widgetname onehit #
d340 3
d344 2
a345 2
 *	widgetname prep
 *	widgetname prep use_air [hasty_prep [dont_instance]]
d362 1
a362 1
				" [use_air [hasty_prep [dont_instance]]]\"",
a381 1
	if( argc >= 5 )  rtip->rti_dont_instance = atoi(argv[4]);
d388 1
a388 2
	bu_vls_printf( &str, "needprep %d useair %d hasty_prep %d dont_instance %d",
		rtip->needprep,
d391 3
a393 1
		rtip->rti_dont_instance );
d410 1
a410 1
 * Generic interface for the database_class manipulation routines.
d412 2
a413 2
 *        widget_command dbCmdName ?args?
 * Returns: result of cmdName database command.
d1495 1
a1495 1
 *  create a named "ray-tracing" object which will respond to
d1497 1
a1497 1
 *  Returns new function name as result.
d1512 1
d1522 1
a1522 1
			"widgetname treetops...\"\n", (char *)NULL );
d1527 7
d1556 1
a1556 1
	/* Instantiate the widget_command, with clientData of wdb */
d1559 1
a1559 1
	(void)Tcl_CreateCommand( interp, argv[2], rt_tcl_rt,
d1563 1
a1563 1
	Tcl_AppendResult( interp, argv[2], (char *)NULL );
d1585 1
a1585 1
 *        widget_command dbCmdName ?args?
d1674 5
a1678 5
Usage: wdb_open widget_command file filename\n\
       wdb_open widget_command disk $dbip\n\
       wdb_open widget_command disk_append $dbip\n\
       wdb_open widget_command inmem $dbip\n\
       wdb_open widget_command inmem_append $dbip\n",
d1711 1
a1711 1
	/* Instantiate the widget_command, with clientData of wdb */
@


1.38
log
@Added curvature data at PJT's suggestion
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tcl.c,v 1.37 1998/03/19 12:25:30 mike Exp mike $ (ARL)";
d1521 2
d1524 5
@


1.37
log
@Make hasty_prep mode the default for Tcl ray-tracing.
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tcl.c,v 1.36 1998/03/19 12:19:22 mike Exp mike $ (ARL)";
d145 1
d154 1
d161 3
@


1.36
log
@Added ".rt prep" directive.
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tcl.c,v 1.35 1998/03/19 11:26:30 mike Exp mike $ (ARL)";
d1519 3
@


1.35
log
@Added "onehit" directive to the LIBRT Tcl object.
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tcl.c,v 1.34 1998/03/19 11:17:06 mike Exp mike $ (ARL)";
d327 59
d389 1
a389 3
#if 0
	"prep",		rt_tcl_rt_prep,		/* haste | efficient, useair, elaborate_instances */
#endif
@


1.34
log
@Improved documentation
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tcl.c,v 1.33 1998/03/19 09:54:32 mike Exp mike $ (ARL)";
d289 38
d329 1
a331 1
	"onehit",	rt_tcl_onehit,
@


1.33
log
@Improved shootray output formatting slightly, for benefit of humans
like me!
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tcl.c,v 1.32 1998/03/19 09:39:57 mike Exp mike $ (ARL)";
d228 6
a233 4
 *	A list of zero or more partitions.
 *	Each partition is a list containing an in, out, and region keyword.
 *	Each segment is a list containing a
 *		dist, point, normal, surfno, and solid keyword.
d292 1
a292 2
	"prep",		rt_tcl_rt_prep,		/* haste | efficient */
	"useair",	rt_tcl_useair,
@


1.32
log
@Added dir|at option to shootray.
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tcl.c,v 1.31 1998/03/19 08:33:05 mike Exp mike $ (ARL)";
d183 1
a183 1
		Tcl_AppendResult( interp, " {in ", (char *)NULL );
d186 1
a186 1
		Tcl_AppendResult( interp, " out ", (char *)NULL );
d190 1
a190 1
			" region ",
d193 1
a193 1
		Tcl_AppendResult( interp, "}", (char *)NULL );
d224 1
a224 1
 *	.rt shootray {0 0 0} at $tgt
@


1.31
log
@Framework for LIBRT interface from TCL
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tcl.c,v 1.30 1998/03/19 07:25:39 mike Exp mike $ (ARL)";
d122 47
d177 3
d181 14
a194 1
	Tcl_AppendResult( interp, "hit!\n", (char *)NULL );
d196 1
a196 1
	return 0;
d200 1
a207 2
	Tcl_AppendResult( interp, "miss!\n", (char *)NULL );

d215 17
a231 2
 *  Usage:
 *	.rt shootray {P} {V}
d243 1
a243 1
	if( argc != 4 )  {
d246 1
a246 1
				argv[0], " ", argv[1], " {P} {V}\"",
d257 1
a257 1
	    bn_decode_vect( ap->a_ray.r_dir, argv[3] ) != 3 )  {
d259 16
a274 1
			"badly formatted vector\n", (char *)NULL );
a281 1
rt_g.debug |= DEBUG_ALLRAYS;
d292 1
a334 1
	Tcl_AppendResult( interp, "\n", (char *)NULL );
d498 1
a498 1
			str, (char *)NULL );
d513 1
a513 1
			argv[0], "\n", (char *)NULL );
d528 1
a528 1
					argv[2], "', using all-zeros\n", (char *)NULL );
d559 1
a559 1
				str, "\n", (char *)NULL );
@


1.30
log
@Added cmddeleteproc for wdb_open
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tcl.c,v 1.29 1998/01/28 06:31:13 mike Exp mike $ (ARL)";
d54 2
d116 131
a1232 24
 *			R T _ D B _ C L O S E
 */
int
rt_db_close( clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
	struct rt_wdb		        *wdbp = (struct rt_wdb *)clientData;

	RT_CK_WDB_TCL(wdbp);

	wdb_close(wdbp);		/* frees memory */
	wdbp = NULL;

	/* De-register Tcl command */
bu_log("De-registering Tcl command '%s'\n", argv[0] );
	Tcl_DeleteCommand( interp, argv[0] );
	return TCL_OK;
}


/*
d1263 88
a1350 4
static struct dbcmdstruct {
	char *cmdname;
	int (*cmdfunc)();
} rt_db_cmds[] = {
d1357 1
a1357 1
	"close",	rt_db_close,
a1390 2
	Tcl_AppendResult( interp, "unknown database command; must be one of:",
			  (char *)NULL );
a1392 2
			/* hack: dispose of error msg if OK */
			Tcl_ResetResult( interp );
d1396 6
d1404 1
a1404 1

d1412 1
a1493 1
	/* XXX Should provide CmdDeleteProc also, to free up wdb */
@


1.29
log
@Changed to use wdb_import
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tcl.c,v 1.28 1997/12/23 06:00:13 mike Exp mike $ (ARL)";
d1214 15
d1301 1
a1301 1
				 (ClientData)wdb, (Tcl_CmdDeleteProc *)NULL );
@


1.28
log
@Added db_follow_path command, and harmonized output of "db get"
and "db_follow_path".
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tcl.c,v 1.27 1997/12/18 05:30:24 mike Exp mike $ (ARL)";
d751 1
d765 13
@


1.27
log
@Now have working "db adjust comb_name tree {tree_stuff}"
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tcl.c,v 1.26 1997/12/18 05:15:26 mike Exp mike $ (ARL)";
d434 1
d438 17
a454 9
			Tcl_DStringAppendElement( &ds, "air" );
			sprintf( buf, "%d", comb->aircode );
			Tcl_DStringAppendElement( &ds, buf );
			Tcl_DStringAppendElement( &ds, "los" );
			sprintf( buf, "%d", comb->los );
			Tcl_DStringAppendElement( &ds, buf );
			Tcl_DStringAppendElement( &ds, "GIFTmater" );
			sprintf( buf, "%d", comb->GIFTmater );
			Tcl_DStringAppendElement( &ds, buf );
a458 1
		Tcl_DStringAppendElement( &ds, "rgb" );
d460 1
d463 1
a463 2
		} else
			Tcl_DStringAppendElement( &ds, "invalid" );
d465 4
a468 4
		Tcl_DStringAppendElement( &ds, "shader" );
		Tcl_DStringAppendElement( &ds, bu_vls_addr(&comb->shader) );
		Tcl_DStringAppendElement( &ds, "material" );
		Tcl_DStringAppendElement( &ds, bu_vls_addr(&comb->material) );
d470 5
d1281 119
a1408 4
	/* XXX All these are temporary hacks, don't get dependent on
	 * XXX them just yet.  -Mike.
	 */

d1410 2
@


1.26
log
@This version can do a "db adjust tree" on a combination,
and replace the tree!
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tcl.c,v 1.25 1997/12/18 03:39:58 mike Exp mike $ (ARL)";
d249 5
d273 1
a273 1
		Tcl_AppendResult( interp, "db_tcl_tree_parse: argc <=0 or >3 on this subtree: ",
d278 1
d285 1
d353 40
@


1.25
log
@For tcl "db get" of a combination, only encode matrix if it is
non-identity.
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tcl.c,v 1.24 1997/11/21 06:12:02 mike Exp mike $ (ARL)";
d249 110
d572 10
a581 1
			;
d583 1
a583 1
			Tcl_AppendResult( interp, buf,
@


1.24
log
@Rationalized passing of args to bu_structparse_argv()
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tcl.c,v 1.23 1997/11/14 20:34:08 bparker Exp mike $ (ARL)";
d85 2
d160 2
a161 1
 *	t := { l dbobjname mat }
d188 1
a188 2
	case OP_DB_LEAF: {
		struct bu_vls vls;
d191 8
a198 5
		bu_vls_init( &vls );
		bn_encode_mat( &vls, tp->tr_l.tl_mat );
		Tcl_DStringAppendElement( dsp, bu_vls_addr(&vls) );
		bu_vls_free( &vls );
		break; }
@


1.23
log
@mods to eliminate use of argv[-1]
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tcl.c,v 1.22 1997/11/05 19:08:17 jra Exp bparker $ (ARL)";
d753 1
d766 1
a766 1
	char			        *name = argv[1];
d772 1
a772 4
	--argc;
	++argv;

	if( argc < 4 ) {
d778 1
d784 1
a784 1
	dp = db_lookup( wdb->dbip, argv[1], LOOKUP_QUIET );
d786 1
a786 1
		Tcl_AppendResult( interp, argv[1], ": not found\n",
d793 1
a793 1
		Tcl_AppendResult( interp, "rt_db_get_internal(", argv[1],
d807 2
a808 1
		status = db_tcl_comb_adjust( comb, interp, argc-2, argv+2 );
d816 6
a821 4
		/* If we were able to find an entry in on the "cheat sheet",
		   just use the handy parse functions to return the object. */

		status = bu_structparse_argv( interp, argc-2, argv+2, sp,
d823 3
@


1.22
log
@Mods to get it to compile on a SUN4.
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tcl.c,v 1.21 1997/11/05 15:16:51 mike Exp jra $ (ARL)";
d495 3
d548 3
d659 3
a661 1
    
d771 3
d851 3
d914 2
a915 2
bu_log("De-registering Tcl command '%s'\n", argv[-1] );
	Tcl_DeleteCommand( interp, argv[-1] );
d1002 1
a1002 1
						  argc-1, argv+1 );
@


1.21
log
@Moved badmagic and Tcl structparse to libbu.
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tcl.c,v 1.20 1997/11/05 15:10:36 mike Exp mike $ (ARL)";
d937 14
a968 13
	struct dbcmdstruct {
		char *cmdname;
		int (*cmdfunc)();
	} rt_db_cmds[] = {
		"match",	rt_db_match,
		"get",		rt_db_get,
		"put",		rt_db_put,
		"adjust",	rt_db_adjust,
		"form",		rt_db_form,
		"tops",		rt_db_tops,
		"close",	rt_db_close,
		(char *)0,	(int (*)())0
	};
@


1.20
log
@Fixed bug in lower-caseing code which was clobbering comb ptr.
Fixed invocation of db_tcl_comb_adjust()
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tcl.c,v 1.19 1997/06/30 13:46:28 gdurf Exp mike $ (ARL)";
a148 368
 *			B U _ B A D M A G I C _ T C L
 */

void
bu_badmagic_tcl( interp, ptr, magic, str, file, line )
Tcl_Interp	*interp;
CONST long	*ptr;
long		magic;
CONST char	*str;
CONST char	*file;
int		line;
{
	char	buf[256];

	if( !(ptr) )  { 
		sprintf(buf, "ERROR: NULL %s pointer, file %s, line %d\n", 
			str, file, line ); 
		Tcl_AppendResult(interp, buf, NULL);
		return;
	}
	if( *((long *)(ptr)) != (magic) )  { 
		sprintf(buf, "ERROR: bad pointer x%x: s/b %s(x%lx), was %s(x%lx), file %s, line %d\n", 
			ptr,
			str, magic,
			bu_identify_magic( *(ptr) ), *(ptr),
			file, line ); 
		Tcl_AppendResult(interp, buf, NULL);
		return;
	}
	Tcl_AppendResult(interp, "bu_badmagic_tcl() mysterious error condition, ", str, " pointer, ", file, "\n", NULL);
}



/*
 *			B U _ S T R U C T P A R S E _ A R G V
 *
 * Support routine for db adjust and db put.  Much like bu_structparse routine,
 * but takes the arguments as lists, a more Tcl-friendly method.
 * Also knows about the Tcl result string, so it can make more informative
 * error messages.
 * XXX move to libbu/bu_tcl.c
 */

int
bu_structparse_argv( interp, argc, argv, desc, base )
Tcl_Interp			*interp;
int				 argc;
char			       **argv;
CONST struct bu_structparse	*desc;		/* structure description */
char				*base;		/* base addr of users struct */
{
	register char				*cp, *loc;
	register CONST struct bu_structparse	*sdp;
	register int				 i, j;
	struct bu_vls				 str;

	if( desc == (struct bu_structparse *)NULL ) {
		bu_log( "bu_structparse_argv: NULL desc pointer\n" );
		Tcl_AppendResult( interp, "NULL desc pointer", (char *)NULL );
		return TCL_ERROR;
	}

	/* Run through each of the attributes and their arguments. */

	bu_vls_init( &str );
	while( argc > 0 ) {
		/* Find the attribute which matches this argument. */
		for( sdp = desc; sdp->sp_name != NULL; sdp++ ) {
			if( strcmp(sdp->sp_name, *argv) != 0 )
				continue;

			/* if we get this far, we've got a name match
			 * with a name in the structure description
			 */

#if CRAY && !__STDC__
			loc = (char *)(base+((int)sdp->sp_offset*sizeof(int)));
#else
			loc = (char *)(base+((int)sdp->sp_offset));
#endif
			if( sdp->sp_fmt[0] != '%' ) {
				bu_log( "bu_structparse_argv: unknown format\n" );
				bu_vls_free( &str );
				Tcl_AppendResult( interp, "unknown format",
						  (char *)NULL );
				return TCL_ERROR;
			}

			--argc;
			++argv;

			switch( sdp->sp_fmt[1] )  {
			case 'c':
			case 's':
				/* copy the string, converting escaped
				 * double quotes to just double quotes
				 */
				if( argc < 1 ) {
					bu_vls_trunc( &str, 0 );
					bu_vls_printf( &str,
			 "not enough values for \"%s\" argument: should be %d",
						       sdp->sp_name,
						       sdp->sp_count );
					Tcl_AppendResult( interp,
							  bu_vls_addr(&str),
							  (char *)NULL );
					bu_vls_free( &str );
					return TCL_ERROR;
				}
				for( i = j = 0;
				     j < sdp->sp_count && argv[0][i] != '\0';
				     loc[j++] = argv[0][i++] )
					;
				if( sdp->sp_count > 1 ) {
					loc[sdp->sp_count-1] = '\0';
					Tcl_AppendResult( interp,
							  sdp->sp_name, " ",
							  loc, " ",
							  (char *)NULL );
				} else {
					bu_vls_trunc( &str, 0 );
					bu_vls_printf( &str, "%s %c ",
						       sdp->sp_name, *loc );
					Tcl_AppendResult( interp,
							  bu_vls_addr(&str),
							  (char *)NULL );
				}
				--argc;
				++argv;
				break;
			case 'i':
				bu_log(
			 "Error: %%i not implemented. Contact developers.\n" );
				Tcl_AppendResult( interp,
						  "%%i not implemented yet",
						  (char *)NULL );
				bu_vls_free( &str );
				return TCL_ERROR;
			case 'd': {
				register int *ip = (int *)loc;
				register int tmpi;
				register char CONST *cp;

				if( argc < 1 ) {
					bu_vls_trunc( &str, 0 );
					bu_vls_printf( &str,
      "not enough values for \"%s\" argument: should have %d, only %d given",
						       sdp->sp_name,
						       sdp->sp_count, i );
					Tcl_AppendResult( interp,
							  bu_vls_addr(&str),
							  (char *)NULL );
					bu_vls_free( &str );
					return TCL_ERROR;
				}

				Tcl_AppendResult( interp, sdp->sp_name, " ",
						  (char *)NULL );

				/* Special case:  '=!' toggles a boolean */
				if( argv[0][0] == '!' ) {
					*ip = *ip ? 0 : 1;
					bu_vls_trunc( &str, 0 );
					bu_vls_printf( &str, "%d ", *ip );
					Tcl_AppendResult( interp,
							  bu_vls_addr(&str),
							  (char *)NULL );
					++argv;
					--argc;
					break;
				}
				/* Normal case: an integer */
				cp = *argv;
				for( i = 0; i < sdp->sp_count; ++i ) {
					if( *cp == '\0' ) {
						bu_vls_trunc( &str, 0 );
						bu_vls_printf( &str,
		      "not enough values for \"%s\" argument: should have %d",
							       sdp->sp_name,
							       sdp->sp_count );
						Tcl_AppendResult( interp,
							    bu_vls_addr(&str),
							    (char *)NULL );
						bu_vls_free( &str );
						return TCL_ERROR;
					}

					while( (*cp == ' ' || *cp == '\n' ||
						*cp == '\t') && *cp )
						++cp;
			
					tmpi = atoi( cp );
					if( *cp && (*cp == '+' || *cp == '-') )
						cp++;
					while( *cp && isdigit(*cp) )
						cp++; 
					/* make sure we actually had an
					 * integer out there
					 */

					if( cp == *argv ||
					    (cp == *argv+1 &&
					     (argv[0][0] == '+' ||
					      argv[0][0] == '-')) ) {
						bu_vls_trunc( &str, 0 );
						bu_vls_printf( &str, 
			       "value \"%s\" to argument %s isn't an integer",
							       argv,
							       sdp->sp_name );
						Tcl_AppendResult( interp,
							    bu_vls_addr(&str),
							    (char *)NULL );
						bu_vls_free( &str );
						return TCL_ERROR;
					} else {
						*(ip++) = tmpi;
					}
					/* Skip the separator(s) */
					while( (*cp == ' ' || *cp == '\n' ||
						*cp == '\t') && *cp ) 
						++cp;
				}
				Tcl_AppendResult( interp,
						  sdp->sp_count > 1 ? "{" : "",
						  argv[0],
						  sdp->sp_count > 1 ? "}" : "",
						  " ", (char *)NULL);
				--argc;
				++argv;
				break; }
			case 'f': {
				int		dot_seen;
				double		tmp_double;
				register double *dp;
				char		*numstart;

				dp = (double *)loc;

				if( argc < 1 ) {
					bu_vls_trunc( &str, 0 );
					bu_vls_printf( &str,
       "not enough values for \"%s\" argument: should have %d, only %d given",
						       sdp->sp_name,
						       sdp->sp_count, argc );
					Tcl_AppendResult( interp,
							  bu_vls_addr(&str),
							  (char *)NULL );
					bu_vls_free( &str );
					return TCL_ERROR;
				}

				Tcl_AppendResult( interp, sdp->sp_name, " ",
						  (char *)NULL );

				cp = *argv;
				for( i = 0; i < sdp->sp_count; i++ ) {
					if( *cp == '\0' ) {
						bu_vls_trunc( &str, 0 );
						bu_vls_printf( &str,
       "not enough values for \"%s\" argument: should have %d, only %d given",
							       sdp->sp_name,
							       sdp->sp_count,
							       i );
						Tcl_AppendResult( interp,
							    bu_vls_addr(&str),
							    (char *)NULL );
						bu_vls_free( &str );
						return TCL_ERROR;
					}
					
					while( (*cp == ' ' || *cp == '\n' ||
						*cp == '\t') && *cp )
						++cp;

					numstart = cp;
					if( *cp == '-' || *cp == '+' ) cp++;

					/* skip matissa */
					dot_seen = 0;
					for( ; *cp ; cp++ ) {
						if( *cp == '.' && !dot_seen ) {
							dot_seen = 1;
							continue;
						}
						if( !isdigit(*cp) )
							break;
					}

					/* If no mantissa seen,
					   then there is no float here */
					if( cp == (numstart + dot_seen) ) {
						bu_vls_trunc( &str, 0 );
						bu_vls_printf( &str, 
	                           "value \"%s\" to argument %s isn't a float",
							       argv[0],
							       sdp->sp_name );
						Tcl_AppendResult( interp,
							    bu_vls_addr(&str),
							    (char *)NULL );
						bu_vls_free( &str );
						return TCL_ERROR;
					}

					/* there was a mantissa,
					   so we may have an exponent */
					if( *cp == 'E' || *cp == 'e' ) {
						cp++;

						/* skip exponent sign */
						if (*cp == '+' || *cp == '-')
							cp++;
						while( isdigit(*cp) )
							cp++;
					}

					bu_vls_trunc( &str, 0 );
					bu_vls_strcpy( &str, numstart );
					bu_vls_trunc( &str, cp-numstart );
					if( sscanf(bu_vls_addr(&str),
						   "%lf", &tmp_double) != 1 ) {
						bu_vls_trunc( &str, 0 );
						bu_vls_printf( &str, 
				  "value \"%s\" to argument %s isn't a float",
							       numstart,
							       sdp->sp_name );
						Tcl_AppendResult( interp,
							    bu_vls_addr(&str),
							    (char *)NULL );
						bu_vls_free( &str );
						return TCL_ERROR;
					}
					
					*dp++ = tmp_double;

					while( (*cp == ' ' || *cp == '\n' ||
						*cp == '\t') && *cp )
						++cp;
				}
				Tcl_AppendResult( interp,
						  sdp->sp_count > 1 ? "{" : "",
						  argv[0],
						  sdp->sp_count > 1 ? "}" : "",
						  " ", (char *)NULL );
				--argc;
				++argv;
				break; }
			default:
				Tcl_AppendResult( interp, "unknown format",
						  (char *)NULL );
				return TCL_ERROR;
			}
			break;
		}
		
		if( sdp->sp_name == NULL ) {
			bu_vls_trunc( &str, 0 );
			bu_vls_printf( &str, "invalid attribute %s", argv[0] );
			Tcl_AppendResult( interp, bu_vls_addr(&str),
					  (char *)NULL );
			bu_vls_free( &str );
			return TCL_ERROR;
		}
	}
	return TCL_OK;
}

/*
d1065 1
a1065 1
	/* XXX Should provide delete proc to free up wdb */
@


1.19
log
@db_tcl_comb_adjust() added to simplify code.
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tcl.c,v 1.18 1997/06/25 04:44:33 mike Exp gdurf $ (ARL)";
d745 3
a760 1
	
d762 5
a766 3
	for( i=0; i<128 && argv[0]!=0; i++ )
		buf[i] = isupper(argv[0][i])?tolower(argv[0][i]):argv[0][i];
	buf[i] = 0;
a767 1
	while( argc >= 2 ) {
d799 1
a799 1
				sscanf( argv[1], "%u %u %u",
d801 5
d827 1
a827 1
			Tcl_AppendResult( interp, argv[0],
d1165 1
a1165 1
		status = db_tcl_comb_adjust( comb, interp, argc+2, argv-2 );
@


1.18
log
@Added case for disk_append mode
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tcl.c,v 1.17 1997/06/25 04:24:00 mike Exp mike $ (ARL)";
d54 3
a56 3
#define RT_CK_DBI_TCL(_p)	BU_CKMAG_TCL(interp,_p,DBI_MAGIC,"struct db_i")
#define RT_CK_RTI_TCL(_p)	BU_CKMAG_TCL(interp,_p,RTI_MAGIC,"struct rt_i")
#define RT_CK_WDB_TCL(_p)	BU_CKMAG_TCL(interp,_p,RT_WDB_MAGIC,"struct rt_wdb")
d744 93
d1009 1
a1009 1
	char				       *newargv[4], *name;
d1061 2
a1062 4
		if( wdb_export( wdb, name, intern.idb_ptr, intern.idb_type,
				1.0 ) < 0 )  {
			Tcl_AppendResult( interp, "wdb_export(", argv[1],
					  ") failure\n", (char *)NULL );
a1065 19
		rt_db_free_internal( &intern );

		/* Update attributes */
		newargv[0] = "adjust";
		newargv[1] = name;
		argv += 3;
		argc -= 3;
		while( argv[0] != 0 ) {
			newargv[2] = argv[0];
			newargv[3] = argv[1];
			bu_log( "executing db %s %s %s %s\n",
				newargv[0], newargv[1], newargv[2],
				newargv[3] );
			rt_db_adjust( clientData,
				      interp,
				      4, newargv );
			argc -= 2;
			argv += 2;
		}
d1084 8
a1091 8
		
		if( wdb_export( wdb, name, intern.idb_ptr, intern.idb_type,
				1.0 ) < 0 )  {
			Tcl_AppendResult( interp, "wdb_export(", argv[1],
					  ") failure\n", (char *)NULL );
			rt_db_free_internal( &intern );
			return TCL_ERROR;
		}
d1117 1
d1125 1
a1125 1
		"wrong # args: should be \"db adjust objName attr value...\"",
d1157 1
a1157 66
		if( strcmp(argv[2], "region")==0 ) {
			if( Tcl_GetBoolean( interp, argv[3], &i )!= TCL_OK )
				goto error;
			comb->region_flag = (char)i;
		} else if( strcmp(argv[2], "id")==0 ) {
			if( !comb->region_flag ) goto not_region;
			if( Tcl_GetInt( interp, argv[3], &i ) != TCL_OK )
				goto error;
			comb->region_id = (short)i;
		} else if( strcmp(argv[2], "air")==0 ) {
			if( !comb->region_flag ) goto not_region;
			if( Tcl_GetInt( interp, argv[3], &i ) != TCL_OK)
				goto error;
			comb->aircode = (short)i;
		} else if( strcmp(argv[2], "los")==0 ) {
			if( !comb->region_flag ) goto not_region;
			if( Tcl_GetInt( interp, argv[3], &i ) != TCL_OK )
				goto error;
			comb->los = (short)i;
		} else if( strcmp(argv[2], "GIFTmater")==0 ||
			   strcmp(argv[2], "giftmater")==0 ) {
			if( !comb->region_flag ) goto not_region;
			if( Tcl_GetInt( interp, argv[3], &i ) != TCL_OK )
				goto error;
			comb->GIFTmater = (short)i;
		} else if( strcmp(argv[2], "rgb")==0 ) {
			if( argc == 6 ) {
				comb->rgb[0] = (unsigned char)atoi(argv[3+0]);
				comb->rgb[1] = (unsigned char)atoi(argv[3+1]);
				comb->rgb[2] = (unsigned char)atoi(argv[3+2]);
				comb->rgb_valid = 1;
			} else {
				if( strcmp(argv[3], "invalid")==0 ) {
					comb->rgb[0] = comb->rgb[1] =
						comb->rgb[2] = 0;
					comb->rgb_valid = 0;
				} else {
					unsigned int r, g, b;
					sscanf( argv[3], "%u %u %u",
						&r, &g, &b );
					comb->rgb[0] = (unsigned char)r;
					comb->rgb[1] = (unsigned char)g;
					comb->rgb[2] = (unsigned char)b;
					comb->rgb_valid = 1;
				}
			}
		} else if( strcmp(argv[2], "shader" )==0 ) {
			bu_vls_trunc( &comb->shader, 0 );
			bu_vls_strcat( &comb->shader, argv[3] );
			/* Leading spaces boggle the combination exporter */
			bu_vls_trimspace( &comb->shader );
		} else if( strcmp(argv[2], "material" )==0 ) {
			bu_vls_trunc( &comb->material, 0 );
			bu_vls_strcat( &comb->material, argv[3] );
			bu_vls_trimspace( &comb->material );
		} else if( strcmp(argv[2], "inherit" )==0 ) {
			if( Tcl_GetBoolean( interp, argv[3], &i ) != TCL_OK )
				goto error;
			comb->inherit = (char)i;
		} else if( strcmp(argv[2], "tree" )==0 ) {
			;
		} else {
			Tcl_SetResult( interp, "no such attribute",
				       TCL_STATIC );
			goto error;
		}
d1163 1
a1163 1
		goto error;
d1168 2
a1169 3
		if( bu_structparse_argv( interp, argc-2, argv+2, sp,
					 (char *)intern.idb_ptr ) != TCL_OK )
			goto error;
d1172 3
a1174 3
	if( wdb_export( wdb, argv[1], intern.idb_ptr,
			intern.idb_type, 1.0 ) < 0 )  {
		Tcl_AppendResult( interp, "wdb_export(", argv[1],
d1181 1
a1181 8
	return TCL_OK;

 not_region:
	Tcl_AppendResult( interp, "attribute not valid for non-region",
			  (char *)NULL );
 error:
	rt_db_free_internal( &intern );
	return TCL_ERROR;
d1265 32
d1324 1
a1435 118
#if 0

/*
 *			R T _ T C L _ G E T _ C O M B
 */
struct rt_comb_internal *
rt_tcl_get_comb(ip, interp, wdbp_str, name, wdbpp)
struct rt_db_internal	*ip;
Tcl_Interp		*interp;
CONST char		*wdbp_str;
CONST char		*name;
struct rt_wdb		**wdbpp;
{
	struct directory	*dp;
	struct db_i		*dbip;
	struct rt_comb_internal	*comb;

	*wdbpp = (struct rt_wdb *)atoi(wdbp_str);
	/* RT_CK_WDB_TCL */
	if( !(*wdbpp) || *((long *)(*wdbpp)) != RT_WDB_MAGIC )  {
		bu_badmagic_tcl(interp, (long *)(*wdbpp), RT_WDB_MAGIC, "struct rt_wdb", __FILE__, __LINE__);
		return NULL;
	}

	dbip = (*wdbpp)->dbip;
	RT_CK_DBI(dbip);

	if( (dp = db_lookup( dbip, name, LOOKUP_NOISY)) == DIR_NULL )
		return NULL;
	if( (dp->d_flags & DIR_COMB) == 0 )  {
		Tcl_AppendResult(interp, dp->d_namep, ": not a combination\n", (char *)NULL);
		return NULL;
	}

	if( rt_db_get_internal( ip, dp, dbip, (mat_t *)NULL ) < 0 )  {
		Tcl_AppendResult(interp, "rt_db_get_internal ", dp->d_namep, " failure\n", NULL);
		return NULL;
	}
	comb = (struct rt_comb_internal *)ip->idb_ptr;
	RT_CK_COMB(comb);
	return comb;
}

/*
 *			R T _ W D B _ I N M E M _ R G B
 *
 *  XXX A hack until "db adjust" works on combinations.
 *  XXX Bad name, no longer restricted to inmem databases.
 */
int
rt_wdb_inmem_rgb( clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
	struct rt_db_internal	intern;
	struct rt_comb_internal	*comb;
	struct rt_wdb		*wdbp;

	if( argc != 6 )  {
		Tcl_AppendResult(interp, "Usage: rt_wdb_inmem_rgb $wdbp comb r g b\n", NULL);
		return TCL_ERROR;
	}

	if( !(comb = rt_tcl_get_comb( &intern, interp, argv[1], argv[2], &wdbp )) )
		return TCL_ERROR;

	/* Make mods to comb here */
	comb->rgb[0] = atoi(argv[3+0]);
	comb->rgb[1] = atoi(argv[3+1]);
	comb->rgb[2] = atoi(argv[3+2]);

	if( wdb_export( wdbp, argv[2], intern.idb_ptr, intern.idb_type, 1.0 ) < 0 )  {
		Tcl_AppendResult(interp, "wdb_export ", argv[2], " failure\n", NULL);
		rt_db_free_internal( &intern );
		return TCL_ERROR;
	}
	rt_db_free_internal( &intern );
	return TCL_OK;
}

/*
 *			R T _ W D B _ I N M E M _ S H A D E R
 */
rt_wdb_inmem_shader( clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
	struct rt_db_internal	intern;
	struct rt_comb_internal	*comb;
	struct rt_wdb		*wdbp;

	if( argc < 4 )  {
		Tcl_AppendResult(interp, "Usage: rt_wdb_inmem_shader $wdbp comb shader [params]\n", NULL);
		return TCL_ERROR;
	}

	if( !(comb = rt_tcl_get_comb( &intern, interp, argv[1], argv[2], &wdbp )) )
		return TCL_ERROR;

	/* Make mods to comb here */
	bu_vls_trunc( &comb->shader, 0 );
	bu_vls_from_argv( &comb->shader, argc-3, &argv[3] );

	if( wdb_export( wdbp, argv[2], intern.idb_ptr, intern.idb_type, 1.0 ) < 0 )  {
		Tcl_AppendResult(interp, "wdb_export ", argv[2], " failure\n", NULL);
		rt_db_free_internal( &intern );
		return TCL_ERROR;
	}
	rt_db_free_internal( &intern );
	return TCL_OK;
}

#endif

a1451 6
#if 0
	(void)Tcl_CreateCommand(interp, "rt_wdb_inmem_rgb", rt_wdb_inmem_rgb,
		(ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);
 	(void)Tcl_CreateCommand(interp, "rt_wdb_inmem_shader", rt_wdb_inmem_shader,
		(ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);
#endif
@


1.17
log
@Spaces on the front of the shader string confuse the export routine!
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tcl.c,v 1.16 1997/06/25 03:00:16 mike Exp mike $ (ARL)";
d1355 1
d1373 2
@


1.16
log
@Added "close" operation to wdb_open'ed objects, like "db" and ".inmem".
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tcl.c,v 1.15 1997/06/24 21:25:48 gdurf Exp mike $ (ARL)";
d1059 1
d1133 2
d1138 1
@


1.15
log
@Improved get/put handling of combinations
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tcl.c,v 1.14 1997/06/20 03:48:12 gdurf Exp gdurf $ (ARL)";
d1239 23
d1288 1
d1335 1
a1369 5
			/* TEMPORARY: Prevent accidents in MGED */
			if( wdb && !dbip->dbi_read_only )  {
				Tcl_AppendResult(interp, "(database changed to read-only)\n", NULL);
				dbip->dbi_read_only = 1;
			}
@


1.14
log
@New dbip handling.  Much cleaner.
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tcl.c,v 1.13 1997/06/20 00:49:43 gdurf Exp gdurf $ (ARL)";
d112 4
d130 4
a139 5
	char				       type[16];

	for( i = 0; s_type[i] != 0 && i < 16; i++ )
		type[i] = isupper(s_type[i]) ? tolower(s_type[i]) : s_type[i];
	type[i] = 0;
d142 1
a142 1
		if( strcmp(type, stlp->label) == 0 )
d151 1
d549 1
a549 3
	Tcl_DStringStartSublist( dsp );
	
	if( !tp ) goto done; /* empty list */
d561 1
a561 1
		goto done; }
d576 1
d578 3
d582 3
a584 1
		goto done;
d596 1
d598 2
a599 1
		goto done;
d603 1
a603 1
		goto done;
a608 4

 done:
	Tcl_DStringEndSublist( dsp );

a614 6
 * If the combination is a region, the result is of the form
 *   region id %d air %d los %d GIFTmater %d rgb invalid|{%d %d %d} \
 *          shader %s material %s inherit yes|no tree %t
 * where %t is of the form produced by db_tcl_tree_describe.
 * If the combination is not a region, the result is of the form
 *   comb rgb invalid|{%d %d %d} shader %s material %s inherit yes|no tree %t
d623 1
d625 1
a625 2
	char		buf[128];

d633 1
d635 5
a639 5
		
		if( !comb->region_flag )
			Tcl_DStringAppendElement( &ds, "comb" );
		else {
			Tcl_DStringAppendElement( &ds, "region" );
d652 2
d655 1
a655 1

d664 1
a664 1
		Tcl_DStringAppendElement( &ds, rt_vls_addr(&comb->shader) );
d666 1
a666 1
		Tcl_DStringAppendElement( &ds, rt_vls_addr(&comb->material) );
d668 2
a669 2
		Tcl_DStringAppendElement( &ds, "inherit" );
		Tcl_DStringAppendElement( &ds, comb->inherit ? "yes" : "no" );
d672 1
d674 1
d678 2
d681 1
d683 1
a683 2
		char itemlwr[16];
		char buf[128];
d685 1
a685 1
		for( i = 0; i < 16 && item[i]; i++ ) {
d689 1
d691 3
a693 1
		if( strcmp(itemlwr, "id")==0 ) {
d702 1
a702 1
		} else if( strcmp(itemlwr, "GIFTmater")==0 ) {
d711 1
a711 1
			Tcl_AppendResult( interp, rt_vls_addr(&comb->shader),
d715 1
a715 1
			Tcl_AppendResult( interp, rt_vls_addr(&comb->material),
d726 4
a805 2
	struct bu_vls		str;
	mat_t			idn;
d809 2
d819 8
a826 4
	bu_vls_init( &str );

	/* XXX Verify that this wdb supports lookup operations
	       (non-null dbip) */
d845 17
a861 3
	stlp = rt_get_parsetab_by_id( id );
	if( stlp != NULL ) {
		bu_vls_strcat( &str, stlp->label );
d863 6
a868 4
		if( argc == 2 ) while( sp->sp_name != NULL ) {
			bu_vls_printf( &str, " %s ", sp->sp_name );
			if( sp->sp_count > 1 ) {
				bu_vls_putc( &str, '{' );
d871 3
a873 4
				bu_vls_putc( &str, '}' );
			} else {
				bu_vls_struct_item( &str, sp,
						 (char *)intern.idb_ptr, ' ' );
d875 1
a875 1
			++sp;
a876 1
			bu_vls_trunc( &str, 0 );
d878 8
a885 5
					 (char *)intern.idb_ptr, ' ') < 0 ) {
				Tcl_AppendResult( interp, "no such attribute",
						  (char *)NULL );
				rt_functab[id].ft_ifree( &intern );
				goto error;
d888 4
a891 8
	} else {
		if( id == ID_COMBINATION ) {
			bu_vls_free( &str );
			(void)db_tcl_comb_describe( interp,
		          (struct rt_comb_internal *)intern.idb_ptr, argv[2] );
			rt_functab[id].ft_ifree( &intern );
			return TCL_OK;
		}
d895 1
a895 16

	if( bu_vls_strlen(&str)==0 ) {
		Tcl_AppendResult( interp,
	 "an output routine for this data type has not yet been implemented",
				  (char *)NULL );
		goto error;
	}


	Tcl_AppendResult( interp, bu_vls_addr(&str), (char *)NULL );
	bu_vls_free( &str );
	return TCL_OK;

 error:
	bu_vls_free( &str );
	return TCL_ERROR;
d907 4
a910 4
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d912 8
a919 6
	struct rt_db_internal intern;
	register struct rt_solid_type_lookup *stlp;
	register struct directory *dp;
	int status, ngran, id;
	char *newargv[3];
	struct rt_wdb	*wdb = (struct rt_wdb *)clientData;
d921 4
a924 4
	if (argc < 2) {
		Tcl_AppendResult(interp,
				 "wrong # args: should be db put objName objType attrs",
				 (char *)NULL);
d927 2
d930 2
a931 1
	/* XXX Verify that this wdb supports lookup operations (non-null dbip) */
d934 3
a936 2
	if (db_lookup(wdb->dbip, argv[1], LOOKUP_QUIET) != DIR_NULL) {
		Tcl_AppendResult(interp, argv[1], " already exists", (char *)NULL);
d942 3
a944 4
	stlp = rt_get_parsetab_by_name(argv[2]);
	if (stlp == NULL) {
		Tcl_AppendResult(interp, "unknown object type", (char *)NULL);
		return TCL_ERROR;
d946 56
d1003 17
a1019 7
	id = intern.idb_type = stlp->id;
	intern.idb_ptr = bu_malloc(stlp->db_internal_size, "rt_db_put");
	*((long *)intern.idb_ptr) = stlp->magic;
	if (bu_structparse_argv(interp, argc-3, argv+3, stlp->parsetab,
				(char *)intern.idb_ptr) == TCL_ERROR) {
		rt_db_free_internal(&intern);
		return TCL_ERROR;
d1022 1
a1022 6
	if( wdb_export( wdb, argv[1], intern.idb_ptr, intern.idb_type, 1.0 ) < 0 )  {
		Tcl_AppendResult(interp, "wdb_export(", argv[1], ") failure\n", (char *)NULL);
		rt_db_free_internal(&intern);
		return TCL_ERROR;
	}
	rt_db_free_internal(&intern);
d1030 1
a1030 1
 ** For use with Tcl, this routine accepts as its first argument, an item in
d1037 4
a1040 4
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d1042 7
a1048 8
	register struct directory *dp;
	register struct bu_structparse *sp = NULL;
	int id, status;
	register int i;
	struct rt_db_internal intern;
	mat_t idn;
	char objecttype;
	struct rt_wdb	*wdb = (struct rt_wdb *)clientData;
d1051 3
a1053 3
		Tcl_AppendResult(interp,
				 "wrong # args: should be \"db adjust objName attr value...\"",
				 (char *)NULL);
d1057 2
a1058 1
	/* XXX Verify that this wdb supports lookup operations (non-null dbip) */
d1060 4
a1063 3
	dp = db_lookup(wdb->dbip, argv[1], LOOKUP_QUIET);
	if (dp == DIR_NULL) {
		Tcl_AppendResult(interp, argv[1], ": not found\n", (char *)NULL);
d1067 4
a1070 3
	status = rt_db_get_internal(&intern, dp, wdb->dbip, (matp_t)NULL );
	if (status < 0) {
		Tcl_AppendResult(interp, "rt_db_get_internal(", argv[1], ") failure\n", (char *)NULL);
d1073 1
a1073 1
	RT_CK_DB_INTERNAL(&intern);
d1083 26
a1108 1
		if( strcmp(argv[2], "rgb")==0 ) {
d1110 3
a1112 3
				comb->rgb[0] = atoi(argv[3+0]);
				comb->rgb[1] = atoi(argv[3+1]);
				comb->rgb[2] = atoi(argv[3+2]);
d1115 3
a1117 1
				if( strcmp(argv[3], "invalid")==0 )
d1119 7
a1125 5
				else {
					sscanf( argv[3], "%d %d %d",
						&comb->rgb[0],
						&comb->rgb[1],
						&comb->rgb[2] );
d1132 9
d1142 1
a1142 1
			Tcl_SetResult( interp, "not supported yet",
d1144 1
a1144 1
			return TCL_ERROR;
d1146 6
a1151 6
	} else if (rt_get_parsetab_by_id(id) == NULL ||
	    (sp = rt_get_parsetab_by_id(id)->parsetab) == NULL) {
		Tcl_AppendResult(interp, "manipulation routines for this type \
have not yet been implemented", (char *)NULL);
		rt_db_free_internal(&intern);
		return TCL_ERROR;
d1153 2
a1154 2
		/* If we were able to find an entry in on the "cheat sheet", just
		   use the handy parse functions to return the object. */
d1156 3
a1158 5
		if (bu_structparse_argv(interp, argc-2, argv+2, sp,
					(char *)intern.idb_ptr) == TCL_ERROR) {
			rt_db_free_internal(&intern);
			return TCL_ERROR;
		}
d1163 3
a1165 3
		Tcl_AppendResult(interp, "wdb_export(", argv[1],
				 ") failure\n", (char *)NULL);
		rt_db_free_internal(&intern);
d1169 1
a1169 1
	rt_db_free_internal(&intern);
d1171 7
a1236 3



@


1.13
log
@Added db register support.
@
text
@d12 1
a12 1
 *  Author -
d14 1
d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tcl.c,v 1.12 1997/06/04 20:16:48 gdurf Exp gdurf $ (ARL)";
d56 1
a56 478
#define RT_CK_WDB_TCL(_p)	BU_CKMAG_TCL(interp,_p,WDB_MAGIC,"struct rt_wdb")

#if defined(USE_PROTOTYPES)
Tcl_CmdProc rt_db;
#else
int rt_db();
#endif

BU_EXTERN(void	bu_badmagic_tcl, (Tcl_Interp *interp, CONST long *ptr,
				long magic, CONST char *str,
				CONST char *file, int line));

/*
 *			B U _ B A D M A G I C _ T C L
 */
void
bu_badmagic_tcl( interp, ptr, magic, str, file, line )
Tcl_Interp	*interp;
CONST long	*ptr;
long		magic;
CONST char	*str;
CONST char	*file;
int		line;
{
	char	buf[256];

	if( !(ptr) )  { 
		sprintf(buf, "ERROR: NULL %s pointer, file %s, line %d\n", 
			str, file, line ); 
		Tcl_AppendResult(interp, buf, NULL);
		return;
	}
	if( *((long *)(ptr)) != (magic) )  { 
		sprintf(buf, "ERROR: bad pointer x%x: s/b %s(x%lx), was %s(x%lx), file %s, line %d\n", 
			ptr,
			str, magic,
			bu_identify_magic( *(ptr) ), *(ptr),
			file, line ); 
		Tcl_AppendResult(interp, buf, NULL);
		return;
	}
	Tcl_AppendResult(interp, "bu_badmagic_tcl() mysterious error condition, ", str, " pointer, ", file, "\n", NULL);
}

int num_dbih = 0, max_num_dbih;
struct db_i **dbip_list = 0;

/*
 *			D B _ T C L _ R E G I S T E R
 *
 *  Registers a DB_I pointer with the Tcl interface subsystem.
 *  Returns a handle that can be used by Tcl scripts to refer to this
 *  pointer.
 */

int
db_tcl_register( dbip )
struct db_i *dbip;
{
	int dbih = num_dbih;

	if( num_dbih == 0 ) {
		max_num_dbih = 8;
		dbip_list = (struct db_i **)bu_calloc( max_num_dbih,
						    sizeof(struct db_i *),
						    "first dbi pointer list" );
	} else if( num_dbih == max_num_dbih ) {
		struct db_i **old_dbip_list = dbip_list;
		dbip_list = (struct db_i **)bu_calloc( max_num_dbih*2,
						      sizeof(struct db_i *),
						      "new dbi pointer list" );
		bcopy( (char *)old_dbip_list, (char *)dbip_list,
		       max_num_dbih*sizeof(struct db_i *) );
		bu_free( old_dbip_list, "old dbi pointer list" );
		max_num_dbih *= 2;
	}

	++num_dbih;
	dbip_list[dbih] = dbip;

	return dbih + 1000;
}


/*
 *		D B _ T C L _ U N R E G I S T E R
 *
 *  Notifies the Tcl interface subsystem that the given dbi handle is
 *  no longer valid.
 */

void
db_tcl_unregister( dbih )
int	dbih;
{
	dbih -= 1000;

	if( dbih<0 || dbih>=num_dbih )
		rt_bomb( "db_tcl_unregister: handle out of range" );
	if( dbip_list[dbih] == 0 )
		rt_bomb( "db_tcl_unregister: handle unregistered twice" );
	dbip_list[dbih] = 0;
}


/*
 *		D B _ T C L _ C H A N G E _ R E G I S T E R E D
 *
 *  Changes the database instance to which the given handle points.
 */

void
db_tcl_change_registered( dbih, dbip )
int		dbih;
struct db_i    *dbip;
{
	dbih -= 1000;

	if( dbih<0 || dbih>=num_dbih )
		rt_bomb( "db_tcl_change_registered: handle out of range" );
	dbip_list[dbih] = dbip;
}
 

/*
 		D B _ T C L _ G E T _ R E G I S T E R E D
 *
 *  Looks for the dbip associated with a given handle and implicitly
 *  returns it. 
 *  If none exists, puts an appropriate error message in interp->result.
 *  For the exclusive use of the routines in this file.
 */

int
db_tcl_get_registered( interp, dbih, dbip_return )
Tcl_Interp	*interp;
int		 dbih;
struct db_i    **dbip_return;
{
	register int i;
	
	dbih -= 1000;
	
	if( dbih<0 || dbih>=num_dbih ) {
		Tcl_AppendResult( interp, "db handle out of range",
				  TCL_STATIC );
		return TCL_ERROR;
	}
	if( dbip_list[dbih] == 0 ) {
		Tcl_AppendResult( interp, "db handle no longer valid",
				  TCL_STATIC );
		return TCL_ERROR;
	}
	
	if( dbip_return ) *dbip_return = dbip_list[dbih];
	return TCL_OK;
}	


/*
 *			W D B _ O P E N
 *
 *  A TCL interface to wdb_fopen() and wdb_dbopen().
 *
 *  Implicit return -
 *	Creates a new TCL proc which responds to get/put/etc. arguments
 *	when invoked.  clientData of that proc will be wdb pointer
 *	for this instance of the database.
 *	Easily allows keeping track of multiple databases.
 *
 *  Explicit return -
 *	wdb pointer, for more traditional C-style interfacing.
 *
 *  Example -
 *	set wdbp [wdb_open .inmem inmem $dbip]
 *	.inmem get box.s
 */
int
wdb_open( clientData, interp, argc, argv )
ClientData	clientData;
Tcl_Interp	*interp;
int		argc;
char		**argv;
{
	struct rt_wdb	*wdb;
	char		buf[32];

	if( argc != 4 )  {
		Tcl_AppendResult(interp, "\
Usage: wdb_open widget_command file filename\n\
       wdb_open widget_command disk $dbip\n\
       wdb_open widget_command inmem $dbip\n\
       wdb_open widget_command inmem_append $dbip\n",
		NULL);
		return TCL_ERROR;
	}

	if( strcmp( argv[2], "file" ) == 0 )  {
		wdb = wdb_fopen( argv[3] );
	} else {
		struct db_i	*dbip;

		if( db_tcl_get_registered( interp,
					   atoi(argv[3]), &dbip ) != TCL_OK )
			return TCL_ERROR;

		/* This should always succeed */
		RT_CK_DBI_TCL(dbip);

		if( strcmp( argv[2], "disk" ) == 0 )  {
			wdb = wdb_dbopen( dbip, WDB_TYPE_DB_DISK );
		} else if( strcmp( argv[2], "inmem" ) == 0 )  {
			wdb = wdb_dbopen( dbip, WDB_TYPE_DB_INMEM );
			/* TEMPORARY: Prevent accidents in MGED */
			if( wdb && !dbip->dbi_read_only )  {
				Tcl_AppendResult(interp, "(database changed to read-only)\n", NULL);
				dbip->dbi_read_only = 1;
			}
		} else if( strcmp( argv[2], "inmem_append" ) == 0 )  {
			wdb = wdb_dbopen( dbip, WDB_TYPE_DB_INMEM_APPEND_ONLY );
		} else {
			Tcl_AppendResult(interp, "wdb_open ", argv[2],
				" target type not recognized\n", NULL);
			return TCL_ERROR;
		}
	}
	if( wdb == WDB_NULL )  {
		Tcl_AppendResult(interp, "wdb_open ", argv[1], " failed\n", NULL);
		return TCL_ERROR;
	}

	/* Instantiate the widget_command, with clientData of wdb */
	/* XXX should we see if it exists first? default=overwrite */
	/* XXX Should provide delete proc to free up wdb */
	/* Beware, returns a "token", not TCL_OK. */
	(void)Tcl_CreateCommand( interp, argv[1], rt_db,
				 (ClientData)wdb, (Tcl_CmdDeleteProc *)NULL );

#ifndef WHY_WOULD_YOU_WANT_TO_DO_THIS_QUESTION_MARK
	sprintf(buf, "%d", wdb);
	Tcl_AppendResult(interp, buf, NULL);
#else
	Tcl_AppendResult( interp, argv[1], (char *)NULL );
#endif	
	
	return TCL_OK;
}

/*
 *			R T _ T C L _ G E T _ C O M B
 */
struct rt_comb_internal *
rt_tcl_get_comb(ip, interp, wdbp_str, name, wdbpp)
struct rt_db_internal	*ip;
Tcl_Interp		*interp;
CONST char		*wdbp_str;
CONST char		*name;
struct rt_wdb		**wdbpp;
{
	struct directory	*dp;
	struct db_i		*dbip;
	struct rt_comb_internal	*comb;

	*wdbpp = (struct rt_wdb *)atoi(wdbp_str);
	/* RT_CK_WDB_TCL */
	if( !(*wdbpp) || *((long *)(*wdbpp)) != WDB_MAGIC )  {
		bu_badmagic_tcl(interp, (long *)(*wdbpp), WDB_MAGIC, "struct rt_wdb", __FILE__, __LINE__);
		return NULL;
	}

	dbip = (*wdbpp)->dbip;
	RT_CK_DBI(dbip);

	if( (dp = db_lookup( dbip, name, LOOKUP_NOISY)) == DIR_NULL )
		return NULL;
	if( (dp->d_flags & DIR_COMB) == 0 )  {
		Tcl_AppendResult(interp, dp->d_namep, ": not a combination\n", (char *)NULL);
		return NULL;
	}

	if( rt_db_get_internal( ip, dp, dbip, (mat_t *)NULL ) < 0 )  {
		Tcl_AppendResult(interp, "rt_db_get_internal ", dp->d_namep, " failure\n", NULL);
		return NULL;
	}
	comb = (struct rt_comb_internal *)ip->idb_ptr;
	RT_CK_COMB(comb);
	return comb;
}

/*
 *			R T _ W D B _ I N M E M _ R G B
 *
 *  XXX A hack until "db adjust" works on combinations.
 *  XXX Bad name, no longer restricted to inmem databases.
 */
int
rt_wdb_inmem_rgb( clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
	struct rt_db_internal	intern;
	struct rt_comb_internal	*comb;
	struct rt_wdb		*wdbp;

	if( argc != 6 )  {
		Tcl_AppendResult(interp, "Usage: rt_wdb_inmem_rgb $wdbp comb r g b\n", NULL);
		return TCL_ERROR;
	}

	if( !(comb = rt_tcl_get_comb( &intern, interp, argv[1], argv[2], &wdbp )) )
		return TCL_ERROR;

	/* Make mods to comb here */
	comb->rgb[0] = atoi(argv[3+0]);
	comb->rgb[1] = atoi(argv[3+1]);
	comb->rgb[2] = atoi(argv[3+2]);

	if( wdb_export( wdbp, argv[2], intern.idb_ptr, intern.idb_type, 1.0 ) < 0 )  {
		Tcl_AppendResult(interp, "wdb_export ", argv[2], " failure\n", NULL);
		rt_db_free_internal( &intern );
		return TCL_ERROR;
	}
	rt_db_free_internal( &intern );
	return TCL_OK;
}

/*
 *			R T _ W D B _ I N M E M _ S H A D E R
 */
rt_wdb_inmem_shader( clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
	struct rt_db_internal	intern;
	struct rt_comb_internal	*comb;
	struct rt_wdb		*wdbp;

	if( argc < 4 )  {
		Tcl_AppendResult(interp, "Usage: rt_wdb_inmem_shader $wdbp comb shader [params]\n", NULL);
		return TCL_ERROR;
	}

	if( !(comb = rt_tcl_get_comb( &intern, interp, argv[1], argv[2], &wdbp )) )
		return TCL_ERROR;

	/* Make mods to comb here */
	bu_vls_trunc( &comb->shader, 0 );
	bu_vls_from_argv( &comb->shader, argc-3, &argv[3] );

	if( wdb_export( wdbp, argv[2], intern.idb_ptr, intern.idb_type, 1.0 ) < 0 )  {
		Tcl_AppendResult(interp, "wdb_export ", argv[2], " failure\n", NULL);
		rt_db_free_internal( &intern );
		return TCL_ERROR;
	}
	rt_db_free_internal( &intern );
	return TCL_OK;
}

/*
 *                     D B . C
 *
 * Source file for primitive database manipulation routines.
 *
 * Rather than being run directly (like the mged "db" command),
 * will be run as a widget_command instantiation of the "database class".
 * clientData will have wdb pointer.
 *
 * Author -
 *      Glenn Durfee
 */

#if defined(USE_PROTOTYPES)
Tcl_CmdProc rt_db_match, rt_db_get, rt_db_put, rt_db_adjust, rt_db_form;
#else
int rt_db_match(), rt_db_get(), rt_db_put(), rt_db_adjust(), rt_db_form();
#endif

struct dbcmdstruct {
	char *cmdname;
	int (*cmdfunc)();
} rt_db_cmds[] = {
	"match",	rt_db_match,
	"get",		rt_db_get,
	"put",		rt_db_put,
	"adjust",	rt_db_adjust,
	"form",		rt_db_form,
	(char *)0,	(int (*)())0
};

/*
 *			R T _ D B
 *
 * Generic interface for the database_class manipulation routines.
 * Usage:
 *        widget_command dbCmdName ?args?
 * Returns: result of cmdName database command.
 */

int
rt_db( clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
	struct dbcmdstruct	*dbcmd;
	struct rt_wdb		*wdb = (struct rt_wdb *)clientData;

	if( argc < 2 ) {
		Tcl_AppendResult( interp,
				  "wrong # args: should be \"", argv[0],
				  " command [args...]\"",
				  (char *)NULL );
		return TCL_ERROR;
	}

	/* Could core dump */
	RT_CK_WDB_TCL(wdb);

	Tcl_AppendResult( interp, "unknown database command; must be one of:",
			  (char *)NULL );
	for( dbcmd = rt_db_cmds; dbcmd->cmdname != NULL; dbcmd++ ) {
		if( strcmp(dbcmd->cmdname, argv[1]) == 0 ) {
			/* hack: dispose of error msg if OK */
			Tcl_ResetResult( interp );
			return (*dbcmd->cmdfunc)( clientData, interp,
						  argc-1, argv+1 );
		}
		Tcl_AppendResult( interp, " ", dbcmd->cmdname, (char *)NULL );
	}

	return TCL_ERROR;
}



/*
 *			R T _ D B _ M A T C H
 *
 * Returns (in interp->result) a list (possibly empty) of all matches to
 * the (possibly wildcard-containing) arguments given.
 * Does *NOT* return tokens that do not match anything, unlike the
 * "expand" command.
 */

int
rt_db_match( clientData, interp, argc, argv )
ClientData	clientData;
Tcl_Interp     *interp;
int		argc;
char	      **argv;
{
	struct rt_wdb  *wdb = (struct rt_wdb *)clientData;
	struct bu_vls	matches;

	RT_CK_WDB_TCL(wdb);
	
	/* Verify that this wdb supports lookup operations
	   (non-null dbip) */
	if( wdb->dbip == 0 ) {
		Tcl_AppendResult( interp, "this database does not support lookup operations" );
		return TCL_ERROR;
	}

	bu_vls_init( &matches );
	for( ++argv; *argv != NULL; ++argv ) {
		if( db_regexp_match_all( &matches, wdb->dbip, *argv ) > 0 )
			bu_vls_strcat( &matches, " " );
	}
	bu_vls_trimspace( &matches );
	Tcl_AppendResult( interp, bu_vls_addr(&matches), (char *)NULL );
	bu_vls_free( &matches );
	return TCL_OK;
}
d146 10
a155 17
 *			R T _ D B _ G E T
 *
 **
 ** For use with Tcl, this routine accepts as its first argument the name
 ** of an object in the database.  If only one argument is given, this routine
 ** then fills the result string with the (minimal) attributes of the item.
 ** If a second, optional, argument is provided, this function looks up the
 ** property with that name of the item given, and returns it as the result
 ** string.
 **/

int
rt_db_get( clientData, interp, argc, argv )
ClientData	clientData;
Tcl_Interp     *interp;
int		argc;
char	      **argv;
d157 1
a157 10
	register struct directory	       *dp;
	register struct bu_structparse	       *sp = NULL;
	register struct rt_solid_type_lookup   *stlp;
	int			id, status;
	struct rt_db_internal	intern;
	struct bu_vls		str;
	mat_t			idn;
	char			objecttype;
	char		       *objname;
	struct rt_wdb	       *wdb = (struct rt_wdb *)clientData;
d159 5
a163 5
	if( argc < 2 || argc > 3) {
		Tcl_AppendResult( interp,
				  "wrong # args: should be \"", argv[0],
				  " objName ?attr?\"", (char *)NULL );
		return TCL_ERROR;
d165 8
a172 11

	bu_vls_init( &str );

	/* XXX Verify that this wdb supports lookup operations
	       (non-null dbip) */

	dp = db_lookup( wdb->dbip, argv[1], LOOKUP_QUIET );
	if( dp == NULL ) {
		Tcl_AppendResult( interp, argv[1], ": not found\n",
				  (char *)NULL );
		return TCL_ERROR;
d174 2
a175 55

	status = rt_db_get_internal( &intern, dp, wdb->dbip, (matp_t)NULL );
	if( status < 0 ) {
		Tcl_AppendResult( interp, "rt_db_get_internal failure: ",
				  argv[1], (char *)NULL );
		return TCL_ERROR;
	}
	RT_CK_DB_INTERNAL( &intern );

       /* Find out what type of object we are dealing with and report on it. */
	id = intern.idb_type;
	stlp = rt_get_parsetab_by_id( id );
	if( stlp != NULL ) {
		bu_vls_strcat( &str, stlp->label );
		sp = stlp->parsetab;
		if( argc == 2 ) while( sp->sp_name != NULL ) {
			bu_vls_printf( &str, " %s ", sp->sp_name );
			if( sp->sp_count > 1 ) {
				bu_vls_putc( &str, '{' );
				bu_vls_struct_item( &str, sp,
						 (char *)intern.idb_ptr, ' ' );
				bu_vls_putc( &str, '}' );
			} else {
				bu_vls_struct_item( &str, sp,
						 (char *)intern.idb_ptr, ' ' );
			}
			++sp;
		} else {
			bu_vls_trunc( &str, 0 );
			if( bu_vls_struct_item_named( &str, sp, argv[2],
					 (char *)intern.idb_ptr, ' ') < 0 ) {
				Tcl_AppendResult( interp, "no such attribute",
						  (char *)NULL );
				rt_functab[id].ft_ifree( &intern );
				goto error;
			}
		}
	} else {
		if( id == ID_COMBINATION ) {
			bu_vls_free( &str );
			(void)db_tcl_comb_describe( interp,
		          (struct rt_comb_internal *)intern.idb_ptr, argv[2] );
			rt_functab[id].ft_ifree( &intern );
			return TCL_OK;
		}
	}

	rt_functab[id].ft_ifree( &intern );

	if( bu_vls_strlen(&str)==0 ) {
		Tcl_AppendResult( interp,
	 "an output routine for this data type has not yet been implemented",
				  (char *)NULL );
		goto error;
	}
a177 8
	Tcl_AppendResult( interp, bu_vls_addr(&str), (char *)NULL );
	bu_vls_free( &str );
	return TCL_OK;

 error:
	bu_vls_free( &str );
	return TCL_ERROR;
}
d513 370
d896 6
a901 6
    struct rt_db_internal intern;
    register struct rt_solid_type_lookup *stlp;
    register struct directory *dp;
    int status, ngran, id;
    char *newargv[3];
    struct rt_wdb	*wdb = (struct rt_wdb *)clientData;
d903 6
a908 6
    if (argc < 2) {
	Tcl_AppendResult(interp,
		      "wrong # args: should be db put objName objType attrs",
		      (char *)NULL);
	return TCL_ERROR;
    }
d913 4
a916 4
    if (db_lookup(wdb->dbip, argv[1], LOOKUP_QUIET) != DIR_NULL) {
	Tcl_AppendResult(interp, argv[1], " already exists", (char *)NULL);
	return TCL_ERROR;
    }
d918 1
a918 1
    RT_INIT_DB_INTERNAL(&intern);
d920 5
a924 5
    stlp = rt_get_parsetab_by_name(argv[2]);
    if (stlp == NULL) {
	Tcl_AppendResult(interp, "unknown object type", (char *)NULL);
	return TCL_ERROR;
    }
d926 8
a933 8
    id = intern.idb_type = stlp->id;
    intern.idb_ptr = bu_malloc(stlp->db_internal_size, "rt_db_put");
    *((long *)intern.idb_ptr) = stlp->magic;
    if (bu_structparse_argv(interp, argc-3, argv+3, stlp->parsetab,
			 (char *)intern.idb_ptr) == TCL_ERROR) {
	rt_db_free_internal(&intern);
	return TCL_ERROR;
    }
d960 15
a974 15
    register struct directory *dp;
    register struct bu_structparse *sp = NULL;
    int id, status;
    register int i;
    struct rt_db_internal intern;
    mat_t idn;
    char objecttype;
    struct rt_wdb	*wdb = (struct rt_wdb *)clientData;

    if( argc < 4 ) {
	Tcl_AppendResult(interp,
                 "wrong # args: should be \"db adjust objName attr value...\"",
		 (char *)NULL);
	return TCL_ERROR;
    }
d978 55
a1032 5
    dp = db_lookup(wdb->dbip, argv[1], LOOKUP_QUIET);
    if (dp == DIR_NULL) {
	Tcl_AppendResult(interp, argv[1], ": not found\n", (char *)NULL);
	return TCL_ERROR;
    }
d1034 6
a1039 6
    status = rt_db_get_internal(&intern, dp, wdb->dbip, (matp_t)NULL );
    if (status < 0) {
	Tcl_AppendResult(interp, "rt_db_get_internal(", argv[1], ") failure\n", (char *)NULL);
	return TCL_ERROR;
    }
    RT_CK_DB_INTERNAL(&intern);
d1041 7
a1047 2
    /* Find out what type of object we are dealing with and tweak it. */
    id = intern.idb_type;
d1049 2
a1050 24
    if (rt_get_parsetab_by_id(id) == NULL ||
	(sp = rt_get_parsetab_by_id(id)->parsetab) == NULL) {
	    Tcl_AppendResult(interp, "manipulation routines for this type \
			     have not yet been implemented", (char *)NULL);
	    rt_db_free_internal(&intern);
	    return TCL_ERROR;
    } else {
	    /* If we were able to find an entry in on the "cheat sheet", just
	       use the handy parse functions to return the object. */

	    if (bu_structparse_argv(interp, argc-2, argv+2, sp,
				    (char *)intern.idb_ptr) == TCL_ERROR) {
		    rt_db_free_internal(&intern);
		    return TCL_ERROR;
	    }

	    if( wdb_export( wdb, argv[1], intern.idb_ptr, intern.idb_type, 1.0 ) < 0 )  {
		    Tcl_AppendResult(interp, "wdb_export(", argv[1], ") failure\n", (char *)NULL);
		    rt_db_free_internal(&intern);
		    return TCL_ERROR;
	    }
	    rt_db_free_internal(&intern);
	    return TCL_OK;
    }
d1063 104
a1166 9
    register struct bu_structparse *sp = NULL;
    register struct rt_solid_type_lookup *stlp;
    register int i;
    struct bu_vls str;
    register char *cp;

    if (argc != 2) {
	Tcl_AppendResult(interp, "wrong # args: should be \"db form objType\"",
		      (char *)NULL);
d1168 143
a1310 1
    }
d1312 3
a1314 21
    bu_vls_init(&str);
    sp = rt_get_parsetab_by_name(argv[1]) == NULL ? NULL :
	    rt_get_parsetab_by_name(argv[1])->parsetab;
    
    if (sp != NULL)
	while (sp->sp_name != NULL) {
	    Tcl_AppendElement(interp, sp->sp_name);
	    bu_vls_trunc(&str, 0);
	    if (strcmp(sp->sp_fmt, "%c") == 0 ||
		strcmp(sp->sp_fmt, "%s") == 0) {
		if (sp->sp_count > 1)
		    bu_vls_printf(&str, "%%%ds", sp->sp_count);
		else
		    bu_vls_printf(&str, "%%c");
	    } else {
		bu_vls_printf(&str, "%s", sp->sp_fmt);
		for (i = 1; i < sp->sp_count; i++)
		    bu_vls_printf(&str, " %s", sp->sp_fmt);
	    }
	    Tcl_AppendElement(interp, bu_vls_addr(&str));
	    ++sp;
d1316 3
a1318 5
    else {
	Tcl_AppendResult(interp, "a form routine for this data type has not \
yet been implemented", (char *)NULL);
	goto error;
    }
d1320 4
a1323 2
    bu_vls_free(&str);
    return TCL_OK;
d1325 7
a1331 3
 error:
    bu_vls_free(&str);
    return TCL_ERROR;
d1334 24
d1359 8
d1368 1
d1386 1
a1386 1

d1391 1
a1391 1

@


1.12
log
@The return of rt_get_parsetab_xxx wasn't checked for NULL in a couple
of places, leading to some embarrasing core dumps.  This has been corrected.
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tcl.c,v 1.11 1997/05/22 09:29:51 butler Exp gdurf $ (ARL)";
a31 1

d99 113
a211 13
/* XXX swiped from wdb.c */
struct rt_wdb  {
	long		magic;
	int		type;
	FILE		*fp;
	struct db_i	*dbip;
};
#define	WDB_MAGIC	0x5f576462
#define WDB_NULL	((struct rt_wdb *)NULL)
#define WDB_TYPE_FILE			1
#define WDB_TYPE_DB_DISK		2
#define WDB_TYPE_DB_INMEM		3
#define WDB_TYPE_DB_INMEM_APPEND_ONLY	4
a212 2
extern struct rt_wdb *wdb_dbopen();
extern struct rt_wdb *wdb_fopen();
d257 5
a261 2
		dbip = (struct db_i *)atoi(argv[3]);
		/* This can still dump core if it's an unmapped address */
d290 2
a291 2
	(void)Tcl_CreateCommand(interp, argv[1], rt_db,
	    (ClientData)wdb, (Tcl_CmdDeleteProc *)NULL);
d293 1
d296 4
d437 2
a438 2
    char *cmdname;
    int (*cmdfunc)();
d440 6
a445 6
    "match", rt_db_match,
    "get", rt_db_get,
    "put", rt_db_put,
    "adjust", rt_db_adjust,
    "form", rt_db_form,
    (char *)0, (int (*)())0
d464 2
a465 2
    struct dbcmdstruct *dbcmd;
    struct rt_wdb	*wdb = (struct rt_wdb *)clientData;
d467 7
a473 6
    if( argc < 2 ) {
	Tcl_AppendResult( interp,
		      "wrong # args: should be \"db command [args...]\"",
		      (char *)NULL );
	return TCL_ERROR;
    }
d475 1
d478 10
a487 6
    Tcl_AppendResult( interp, "unknown database command; must be one of:",
		   (char *)NULL );
    for( dbcmd = rt_db_cmds; dbcmd->cmdname != NULL; dbcmd++ ) {
	if( strcmp(dbcmd->cmdname, argv[1]) == 0 ) {
	    Tcl_ResetResult( interp );	/* hack: dispose of error msg if OK */
	    return (*dbcmd->cmdfunc)( clientData, interp, argc-1, argv+1 );
a488 2
	Tcl_AppendResult( interp, " ", dbcmd->cmdname, (char *)NULL );
    }
d490 1
a490 1
    return TCL_ERROR;
d494 1
d505 5
a509 5
rt_db_match(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d511 2
a512 2
    struct bu_vls matches;
    int nummatch;
d514 8
a521 1
	/* XXX Verify that this wdb supports lookup operations (non-null dbip) */
d523 4
a526 18
#if 1
	/* regexp_match_all() needs to take a dbip arg, be moved into LIBRT, new name, for this to work. */
	Tcl_AppendResult(interp,"rt_db_match needs to be reimplemented.\n", NULL);
	return TCL_ERROR;
#else
    bu_vls_init( &matches );
    ++argv;
    nummatch = 0;
    while( nummatch == 0 && *argv != NULL )
	nummatch = regexp_match_all( &matches, *argv++ );
    Tcl_AppendResult( interp, bu_vls_addr(&matches), (char *)NULL );
    bu_vls_trunc( &matches, 0 );
    while( *argv != NULL ) {
	nummatch = regexp_match_all( &matches, *argv++ );
	if( nummatch > 0 ) {
	    Tcl_AppendResult( interp, " ", bu_vls_addr(&matches),
			      (char *)NULL );
	    bu_vls_trunc( &matches, 0 );
d528 4
a531 5
    }

    bu_vls_free( &matches );
    return TCL_OK;
#endif
d534 11
a544 86
struct bu_structparse rt_tor_parse[] = {
    { "%f", 3, "V",   offsetof(struct rt_tor_internal, v[X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 3, "H",   offsetof(struct rt_tor_internal, h[X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 1, "r_a", offsetof(struct rt_tor_internal, r_a),  BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 1, "r_h", offsetof(struct rt_tor_internal, r_h),  BU_STRUCTPARSE_FUNC_NULL },
    {0} };

struct bu_structparse rt_tgc_parse[] = {
    { "%f", 3, "V", offsetof(struct rt_tgc_internal, v[X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 3, "H", offsetof(struct rt_tgc_internal, h[X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 3, "A", offsetof(struct rt_tgc_internal, a[X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 3, "B", offsetof(struct rt_tgc_internal, b[X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 3, "C", offsetof(struct rt_tgc_internal, c[X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 3, "D", offsetof(struct rt_tgc_internal, d[X]), BU_STRUCTPARSE_FUNC_NULL },
    { 0 } };

struct bu_structparse rt_ell_parse[] = {
    { "%f", 3, "V", offsetof(struct rt_ell_internal, v[X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 3, "A", offsetof(struct rt_ell_internal, a[X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 3, "B", offsetof(struct rt_ell_internal, b[X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 3, "C", offsetof(struct rt_ell_internal, c[X]), BU_STRUCTPARSE_FUNC_NULL },
    {0} };

struct bu_structparse rt_arb8_parse[] = {
    { "%f", 3, "V1", offsetof(struct rt_arb_internal, pt[0][X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 3, "V2", offsetof(struct rt_arb_internal, pt[1][X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 3, "V3", offsetof(struct rt_arb_internal, pt[2][X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 3, "V4", offsetof(struct rt_arb_internal, pt[3][X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 3, "V5", offsetof(struct rt_arb_internal, pt[4][X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 3, "V6", offsetof(struct rt_arb_internal, pt[5][X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 3, "V7", offsetof(struct rt_arb_internal, pt[6][X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 3, "V8", offsetof(struct rt_arb_internal, pt[7][X]), BU_STRUCTPARSE_FUNC_NULL },
    {0} };

struct bu_structparse rt_half_parse[] = {
    { "%f", 3, "N", offsetof(struct rt_half_internal, eqn[X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 1, "d", offsetof(struct rt_half_internal, eqn[3]), BU_STRUCTPARSE_FUNC_NULL },
    {0} };

struct bu_structparse rt_part_parse[] = {
    { "%f", 3, "V",  offsetof(struct rt_part_internal, part_V[X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 3, "H",  offsetof(struct rt_part_internal, part_H[X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 1, "r_v",offsetof(struct rt_part_internal, part_vrad), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 1, "r_h",offsetof(struct rt_part_internal, part_hrad), BU_STRUCTPARSE_FUNC_NULL },
    {0} };
	    
struct bu_structparse rt_rpc_parse[] = {
    { "%f", 3, "V", offsetof(struct rt_rpc_internal, rpc_V[X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 3, "H", offsetof(struct rt_rpc_internal, rpc_H[X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 3, "B", offsetof(struct rt_rpc_internal, rpc_B[X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 1, "r", offsetof(struct rt_rpc_internal, rpc_r),    BU_STRUCTPARSE_FUNC_NULL },
    {0} };
	    
struct bu_structparse rt_rhc_parse[] = {
    { "%f", 3, "V", offsetof(struct rt_rhc_internal, rhc_V[X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 3, "H", offsetof(struct rt_rhc_internal, rhc_H[X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 3, "B", offsetof(struct rt_rhc_internal, rhc_B[X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 1, "r", offsetof(struct rt_rhc_internal, rhc_r),    BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 1, "c", offsetof(struct rt_rhc_internal, rhc_c),    BU_STRUCTPARSE_FUNC_NULL },
    {0} };
	    
struct bu_structparse rt_epa_parse[] = {
    { "%f", 3, "V",   offsetof(struct rt_epa_internal, epa_V[X]),  BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 3, "H",   offsetof(struct rt_epa_internal, epa_H[X]),  BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 3, "A",   offsetof(struct rt_epa_internal, epa_Au[X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 1, "r_1", offsetof(struct rt_epa_internal, epa_r1),    BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 1, "r_2", offsetof(struct rt_epa_internal, epa_r2),    BU_STRUCTPARSE_FUNC_NULL },
    {0} };

struct bu_structparse rt_ehy_parse[] = {
    { "%f", 3, "V",   offsetof(struct rt_ehy_internal, ehy_V[X]),  BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 3, "H",   offsetof(struct rt_ehy_internal, ehy_H[X]),  BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 3, "A",   offsetof(struct rt_ehy_internal, ehy_Au[X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 1, "r_1", offsetof(struct rt_ehy_internal, ehy_r1),    BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 1, "r_2", offsetof(struct rt_ehy_internal, ehy_r2),    BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 1, "c",   offsetof(struct rt_ehy_internal, ehy_c),     BU_STRUCTPARSE_FUNC_NULL },
    {0} };

struct bu_structparse rt_eto_parse[] = {
    { "%f", 3, "V",   offsetof(struct rt_eto_internal, eto_V[X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 3, "N",   offsetof(struct rt_eto_internal, eto_N[X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 3, "C",   offsetof(struct rt_eto_internal, eto_C[X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 1, "r",   offsetof(struct rt_eto_internal, eto_r),    BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 1, "r_d", offsetof(struct rt_eto_internal, eto_rd),   BU_STRUCTPARSE_FUNC_NULL },
    {0} };

d546 12
d559 1
a559 2
extern struct bu_structparse rt_hf_parse[];
extern struct bu_structparse rt_vol_parse[];
d562 5
a566 5
    char id;
    size_t db_internal_size;
    long magic;
    char *label;
    struct bu_structparse *parsetab;
d568 18
a585 14
    { ID_TOR,     sizeof(struct rt_tor_internal), (long)RT_TOR_INTERNAL_MAGIC, "tor", rt_tor_parse },
    { ID_TGC,     sizeof(struct rt_tgc_internal), (long)RT_TGC_INTERNAL_MAGIC, "tgc", rt_tgc_parse },
    { ID_REC,     sizeof(struct rt_tgc_internal), (long)RT_TGC_INTERNAL_MAGIC, "rec", rt_tgc_parse },
    { ID_ELL,     sizeof(struct rt_ell_internal), (long)RT_ELL_INTERNAL_MAGIC, "ell", rt_ell_parse },
    { ID_SPH,     sizeof(struct rt_ell_internal), (long)RT_ELL_INTERNAL_MAGIC, "sph", rt_ell_parse },
    { ID_ARB8,    sizeof(struct rt_arb_internal), (long)RT_ARB_INTERNAL_MAGIC, "arb8", rt_arb8_parse },
    { ID_HALF,    sizeof(struct rt_half_internal),(long)RT_HALF_INTERNAL_MAGIC,"half", rt_half_parse },
    { ID_PARTICLE,sizeof(struct rt_part_internal),(long)RT_PART_INTERNAL_MAGIC,"part", rt_part_parse },
    { ID_RPC,     sizeof(struct rt_rpc_internal), (long)RT_RPC_INTERNAL_MAGIC, "rpc", rt_rpc_parse },
    { ID_RHC,     sizeof(struct rt_rhc_internal), (long)RT_RHC_INTERNAL_MAGIC, "rhc", rt_rhc_parse },
    { ID_EPA,     sizeof(struct rt_epa_internal), (long)RT_EPA_INTERNAL_MAGIC, "epa", rt_epa_parse },
    { ID_EHY,     sizeof(struct rt_ehy_internal), (long)RT_EHY_INTERNAL_MAGIC, "ehy", rt_ehy_parse },
    { ID_ETO,     sizeof(struct rt_eto_internal), (long)RT_ETO_INTERNAL_MAGIC, "eto", rt_eto_parse },
    { 0, 0, 0, 0 }
d589 1
a589 1
rt_get_parsetab_by_id(s_id)
d592 2
a593 2
    register struct rt_solid_type_lookup *stlp;
    static struct rt_solid_type_lookup solid_type;
d595 3
a597 33
    if (s_id == ID_EBM) {
	solid_type.id = ID_EBM;
	solid_type.db_internal_size = sizeof(struct rt_ebm_internal);
	solid_type.magic = RT_EBM_INTERNAL_MAGIC;
	solid_type.label = "ebm";
	solid_type.parsetab = rt_ebm_parse;
	return &solid_type;
    } else if (s_id == ID_DSP) {
	solid_type.id = ID_DSP;
	solid_type.db_internal_size = sizeof(struct rt_dsp_internal);
	solid_type.magic = RT_DSP_INTERNAL_MAGIC;
	solid_type.label = "dsp";
	solid_type.parsetab = rt_dsp_parse;
	return &solid_type;
    } else if (s_id == ID_VOL) {
	solid_type.id = ID_VOL;
	solid_type.db_internal_size = sizeof(struct rt_vol_internal);
	solid_type.magic = RT_VOL_INTERNAL_MAGIC;
	solid_type.label = "vol";
	solid_type.parsetab = rt_vol_parse;
	return &solid_type;
    } else if (s_id == ID_HF) {
	solid_type.id = ID_HF;
	solid_type.db_internal_size = sizeof(struct rt_hf_internal);
	solid_type.magic = RT_HF_INTERNAL_MAGIC;
	solid_type.label = "hf";
	solid_type.parsetab = rt_hf_parse;
	return &solid_type;
    }

    for (stlp = rt_solid_type_lookup; stlp->id != 0; stlp++)
	if (stlp->id == s_id)
	    break;
a598 1
    if (stlp->id == 0)
a599 2
    
    return stlp;
a601 2
/*
 */
d603 1
a603 1
rt_get_parsetab_by_name(s_type)
d606 11
a616 27
    register int i;
    register struct rt_solid_type_lookup *stlp;
    char *type;

    type = (char *)bu_malloc(strlen(s_type)+1, "lowercase solid type");
    for (i = 0; s_type[i] != 0; i++)
	type[i] = isupper(s_type[i]) ? tolower(s_type[i]) : s_type[i];

    type[i] = 0;

    if (strcmp(type, "ebm") == 0) {
	bu_free((genptr_t)type, "lowercase solid type");
	return rt_get_parsetab_by_id(ID_EBM);
    } else if (strcmp(type, "dsp") == 0) {
	bu_free((genptr_t)type, "lowercase solid type");
	return rt_get_parsetab_by_id(ID_DSP);
    } else if (strcmp(type, "vol") == 0) {
	bu_free((genptr_t)type, "lowercase solid type");
	return rt_get_parsetab_by_id(ID_VOL);
    } else if (strcmp(type, "hf") == 0) {
	bu_free((genptr_t)type, "lowercase solid type");
	return rt_get_parsetab_by_id(ID_HF);
    }

    for (stlp = rt_solid_type_lookup; stlp->id != 0; stlp++)
	if (strcmp(type, stlp->label) == 0)
	    break;
a617 2
    bu_free((genptr_t)type, "lowercase solid type");
    if (stlp->id == 0)
a618 2
    
    return stlp;
d635 4
a638 4
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d640 17
a656 17
    register struct directory *dp;
    register struct bu_structparse *sp = NULL;
    register struct rt_solid_type_lookup *stlp;
    int id, status;
    struct rt_db_internal intern;
    struct bu_vls str;
    mat_t idn;
    char objecttype;
    char *objname;
    struct rt_wdb	*wdb = (struct rt_wdb *)clientData;

    if( argc < 2 || argc > 3) {
	Tcl_AppendResult(interp,
		      "wrong # args: should be \"db get objName ?attr?\"",
		      (char *)NULL);
	return TCL_ERROR;
    }
d658 1
a658 1
    bu_vls_init(&str);
d660 2
a661 1
	/* XXX Verify that this wdb supports lookup operations (non-null dbip) */
d663 6
a668 5
    dp = db_lookup(wdb->dbip, argv[1], LOOKUP_QUIET);
    if (dp == NULL) {
	Tcl_AppendResult(interp, argv[1], ": not found\n", (char *)NULL);
	return TCL_ERROR;
    }
d670 7
a676 6
    status = rt_db_get_internal(&intern, dp, wdb->dbip, (matp_t)NULL);
    if (status < 0) {
	Tcl_AppendResult(interp, "rt_db_get_internal failure: ", argv[1], (char *)NULL);
	return TCL_ERROR;
    }
    RT_CK_DB_INTERNAL(&intern);
d678 1
a678 1
    /* Find out what type of object we are dealing with and report on it. */
d680 25
a704 15
	stlp = rt_get_parsetab_by_id(id);
	if (stlp != NULL) {
	    bu_vls_strcat(&str, stlp->label);
	    sp = stlp->parsetab;
	    if (argc == 2) {
		while (sp->sp_name != NULL) {
		    bu_vls_printf(&str, " %s ", sp->sp_name);
		    if (sp->sp_count > 1) {
			bu_vls_putc(&str, '{');
			bu_vls_struct_item(&str,sp,(char *)intern.idb_ptr,' ');
			bu_vls_putc(&str, '}');
		    }
		    else
			bu_vls_struct_item(&str,sp,(char *)intern.idb_ptr,' ');
		    ++sp;
d706 7
a712 7
	    } else {
		bu_vls_trunc(&str, 0);
		if (bu_vls_struct_item_named(&str, sp, argv[2],
					 (char *)intern.idb_ptr, ' ') < 0) {
		    Tcl_AppendResult(interp, "no such attribute", (char *)NULL);
		    rt_functab[id].ft_ifree(&intern);
		    goto error;
a713 1
	    }
d716 8
a723 1
    rt_functab[id].ft_ifree(&intern);
a724 5
    if( bu_vls_strlen(&str)==0 ) {
	Tcl_AppendResult(interp, "an output routine for this data type has not \
yet been implemented", (char *)NULL);
	goto error;
    }
d726 3
a728 3
    Tcl_AppendResult(interp, bu_vls_addr(&str), (char *)NULL);
    bu_vls_free(&str);
    return TCL_OK;
d731 2
a732 2
    bu_vls_free(&str);
    return TCL_ERROR;
d747 3
a749 3
Tcl_Interp *interp;
int argc;
char **argv;
d753 10
a762 10
    register char *cp, *loc;
    register CONST struct bu_structparse *sdp;
    register int i, j;
    struct bu_vls str;

    if (desc == (struct bu_structparse *)NULL) {
	bu_log("bu_structparse_argv: NULL desc pointer\n");
	Tcl_AppendResult(interp, "NULL desc pointer", (char *)NULL);
	return TCL_ERROR;
    }
d764 1
a764 1
    /* Run through each of the attributes and their arguments. */
d766 10
a775 10
    bu_vls_init(&str);
    while (argc > 0) {
	/* Find the attribute which matches this argument. */
	for (sdp = desc; sdp->sp_name != NULL; sdp++) {
	    if (strcmp(sdp->sp_name, *argv) != 0)
		continue;

	    /* if we get this far, we've got a name match
	     * with a name in the structure description
	     */
d778 1
a778 1
	    loc = (char *)(base + ((int)sdp->sp_offset*sizeof(int)));
d780 1
a780 1
	    loc = (char *)(base + ((int)sdp->sp_offset));
d782 7
a788 61
	    if (sdp->sp_fmt[0] != '%') {
		bu_log("bu_structparse_argv: unknown format\n");
		bu_vls_free(&str);
		Tcl_AppendResult(interp, "unknown format", (char *)NULL);
		return TCL_ERROR;
	    }

	    --argc;
	    ++argv;

	    switch( sdp->sp_fmt[1] )  {
	    case 'c':
	    case 's':
		/* copy the string, converting escaped
		 * double quotes to just double quotes
		 */
		if (argc < 1) {
		    bu_vls_trunc(&str, 0);
		    bu_vls_printf(&str,
		  "not enough values for \"%s\" argument: should be %d",
				  sdp->sp_name, sdp->sp_count);
		    Tcl_AppendResult(interp, bu_vls_addr(&str), (char *)NULL);
		    bu_vls_free(&str);
		    return TCL_ERROR;
		}
		for (i = j = 0;
		     j < sdp->sp_count && argv[0][i] != '\0' ;
		     loc[j++] = argv[0][i++])
		    ;
		if (sdp->sp_count > 1) {
		    loc[sdp->sp_count-1] = '\0';
		    Tcl_AppendResult(interp, sdp->sp_name, " ", loc, " ",
				     (char *)NULL);
		} else {
		    bu_vls_trunc(&str, 0);
		    bu_vls_printf(&str, "%s %c ", sdp->sp_name, *loc);
		    Tcl_AppendResult(interp, bu_vls_addr(&str), (char *)NULL);
		}
		--argc;
		++argv;
		break;
	    case 'i':
		bu_log("Error: %%i not implemented. Contact developers.\n");
		Tcl_AppendResult(interp, "%%i not implemented yet", (char *)NULL);
		bu_vls_free(&str);
		return TCL_ERROR;
	    case 'd': {
		register int *ip = (int *)loc;
		register int tmpi;
		register char CONST *cp;

		if (argc < 1) {
		    bu_vls_trunc(&str, 0);
		    bu_vls_printf(&str,
		      "not enough values for \"%s\" argument: should have %d, \
only %d given",
				      sdp->sp_name, sdp->sp_count, i);
		    Tcl_AppendResult(interp, bu_vls_addr(&str), (char *)NULL);
		    bu_vls_free(&str);
		    return TCL_ERROR;
		}
d790 2
a791 1
		Tcl_AppendResult(interp, sdp->sp_name, " ", (char *)NULL);
d793 86
a878 16
		/* Special case:  '=!' toggles a boolean */
		if( argv[0][0] == '!' )  {
		    *ip = *ip ? 0 : 1;
		    bu_vls_trunc(&str, 0);
		    bu_vls_printf(&str, "%d ", *ip);
		    Tcl_AppendResult(interp, bu_vls_addr(&str), (char *)NULL);
		    ++argv;
		    --argc;
		    break;
		}
		/* Normal case: an integer */
		cp = *argv;
		for (i = 0; i < sdp->sp_count; ++i) {
		    if (*cp == '\0') {
			bu_vls_trunc(&str, 0);
			bu_vls_printf(&str,
d880 12
a891 8
				      sdp->sp_name, sdp->sp_count);
			Tcl_AppendResult(interp, bu_vls_addr(&str), (char *)NULL);
			bu_vls_free(&str);
			return TCL_ERROR;
		    }

		    while ((*cp == ' ' || *cp == '\n' || *cp == '\t') && *cp)
			++cp;
d893 161
a1053 49
		    tmpi = atoi(cp);
		    if (*cp && (*cp == '+' || *cp == '-'))
			cp++;
		    while (*cp && isdigit(*cp) )
			cp++; 
		    /* make sure we actually had an
		     * integer out there
		     */

		    if (cp == *argv ||
			(cp == *argv+1 &&
			 (argv[0][0] == '+' || argv[0][0] == '-'))) {
			bu_vls_trunc(&str, 0);
			bu_vls_printf(&str, 
	                        "value \"%s\" to argument %s isn't an integer",
				      argv, sdp->sp_name);
			Tcl_AppendResult(interp, bu_vls_addr(&str), (char *)NULL);
			bu_vls_free(&str);
			return TCL_ERROR;
		    } else {
			*(ip++) = tmpi;
		    }
		    /* Skip the separator(s) */
		    while ((*cp == ' ' || *cp == '\n' || *cp == '\t') && *cp) 
			++cp;
		}
		Tcl_AppendResult(interp, sdp->sp_count > 1 ? "{" : "",
				 argv[0], sdp->sp_count > 1 ? "}" : "",
				 " ", (char *)NULL);
		--argc;
		++argv;
		break; }
	    case 'f': {
		int	dot_seen;
		double	tmp_double;
		register double *dp;
		char *numstart;

		dp = (double *)loc;

		if (argc < 1) {
		    bu_vls_trunc(&str, 0);
		    bu_vls_printf(&str,
		  "not enough values for \"%s\" argument: should be %d, only \
%d given",
				  sdp->sp_name, sdp->sp_count, argc);
		    Tcl_AppendResult(interp, bu_vls_addr(&str), (char *)NULL);
		    bu_vls_free(&str);
		    return TCL_ERROR;
d1055 7
a1061 65

		Tcl_AppendResult(interp, sdp->sp_name, " ", (char *)NULL);

		cp = *argv;
		for (i = 0; i < sdp->sp_count; i++) {
		    if (*cp == '\0') {
			bu_vls_trunc(&str, 0);
			bu_vls_printf(&str,
		      "not enough values for \"%s\" argument: should have %d, \
only %d given",
				      sdp->sp_name, sdp->sp_count, i);
			Tcl_AppendResult(interp, bu_vls_addr(&str), (char *)NULL);
			bu_vls_free(&str);
			return TCL_ERROR;
		    }

		    while ((*cp == ' ' || *cp == '\n' || *cp == '\t') && *cp)
			++cp;

		    numstart = cp;
		    if (*cp == '-' || *cp == '+') cp++;

		    /* skip matissa */
		    dot_seen = 0;
		    for (; *cp ; cp++ ) {
			if (*cp == '.' && !dot_seen) {
			    dot_seen = 1;
			    continue;
			}
			if (!isdigit(*cp))
			    break;			    
		    }

		    /* If no mantissa seen, then there is no float here */
		    if (cp == (numstart + dot_seen)) {
			bu_vls_trunc(&str, 0);
			bu_vls_printf(&str, 
	                           "value \"%s\" to argument %s isn't a float",
				      argv[0], sdp->sp_name);
			Tcl_AppendResult(interp, bu_vls_addr(&str), (char *)NULL);
			bu_vls_free(&str);
			return TCL_ERROR;
		    }

		    /* there was a mantissa, so we may have an exponent */
		    if (*cp == 'E' || *cp == 'e') {
			cp++;

			/* skip exponent sign */
		    	if (*cp == '+' || *cp == '-')
			    cp++;
			while (isdigit(*cp))
			    cp++;
		    }

		    bu_vls_trunc(&str, 0);
		    bu_vls_strcpy(&str, numstart);
		    bu_vls_trunc(&str, cp-numstart);
		    if (sscanf(bu_vls_addr(&str), "%lf", &tmp_double) != 1 ) {
			bu_vls_trunc(&str, 0);
			bu_vls_printf(&str, 
	                           "value \"%s\" to argument %s isn't a float",
				      numstart, sdp->sp_name);
			Tcl_AppendResult(interp, bu_vls_addr(&str), (char *)NULL);
			bu_vls_free(&str);
a1062 6
		    }

		    *dp++ = tmp_double;

		    while ((*cp == ' ' || *cp == '\n' || *cp == '\t') && *cp)
			++cp;
a1063 19
		Tcl_AppendResult(interp, sdp->sp_count > 1 ? "{" : "",
				 argv[0], sdp->sp_count > 1 ? "}" : "",
				 " ", (char *)NULL);
		--argc;
		++argv;
		break; }
	    default:
		Tcl_AppendResult(interp, "unknown format", (char *)NULL);
		return TCL_ERROR;
	    }
	    break;
	}

	if (sdp->sp_name == NULL) {
	    bu_vls_trunc(&str, 0);
	    bu_vls_printf(&str, "invalid attribute %s", argv[0]);
	    Tcl_AppendResult(interp, bu_vls_addr(&str), (char *)NULL);
	    bu_vls_free(&str);
	    return TCL_ERROR;
d1065 1
a1065 2
    }
    return TCL_OK;
@


1.11
log
@added dsp solid
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tcl.c,v 1.10 1997/03/12 17:29:00 mike Exp $ (ARL)";
d1130 9
a1138 4
	sp = rt_get_parsetab_by_id(id)->parsetab;

	/* If we were able to find an entry in on the "cheat sheet", just
	   use the handy parse functions to return the object. */
a1139 1
	if (sp != NULL) {
d1141 3
a1143 3
				 (char *)intern.idb_ptr) == TCL_ERROR) {
		rt_db_free_internal(&intern);
		return TCL_ERROR;
a1144 8
	}
    	else
    	{
		Tcl_AppendResult(interp, "manipulation routines for this type have \
			not yet been implemented", (char *)NULL);
    		rt_db_free_internal(&intern);
    		return TCL_ERROR;
    	}
d1146 8
a1153 7
	if( wdb_export( wdb, argv[1], intern.idb_ptr, intern.idb_type, 1.0 ) < 0 )  {
		Tcl_AppendResult(interp, "wdb_export(", argv[1], ") failure\n", (char *)NULL);
		rt_db_free_internal(&intern);
		return TCL_ERROR;
	}
	rt_db_free_internal(&intern);
	return TCL_OK;
d1179 2
a1180 1
    sp = rt_get_parsetab_by_name(argv[1])->parsetab;
d1236 1
a1236 1
	(void)Tcl_CreateCommand(interp, "rt_wdb_inmem_shader", rt_wdb_inmem_shader,
@


1.10
log
@Irix 6
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tcl.c,v 1.9 1997/03/07 10:43:42 mike Exp mike $ (ARL)";
d519 1
d560 7
d612 3
@


1.9
log
@Final batch of name changes
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tcl.c,v 1.8 1997/03/07 10:32:36 mike Exp mike $ (ARL)";
d55 2
a56 2
#define RT_CK_RTI_TCL(_p)	BU_CKMAG_TCL(interp,_p, RTI_MAGIC, "struct rt_i")
#define RT_CK_WDB_TCL(_p)	BU_CKMAG_TCL(interp,_p,WDB_MAGIC, "struct rt_wdb")
d64 4
d162 1
a162 1
		RT_CK_DBI_TCL(dbip)
@


1.8
log
@More name changes
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tcl.c,v 1.7 1997/03/07 10:30:45 mike Exp mike $ (ARL)";
d237 3
d342 1
a342 1
 * Generic interface for the database manipulation routines.
d400 2
d518 1
a518 1
struct solid_type_lookup {
d524 1
a524 1
} solid_type_lookup[] = {
d541 2
a542 2
struct solid_type_lookup *
get_parsetab_by_id(s_id)
d545 2
a546 2
    register struct solid_type_lookup *stlp;
    static struct solid_type_lookup solid_type;
d571 1
a571 1
    for (stlp = solid_type_lookup; stlp->id != 0; stlp++)
d581 4
a584 2
struct solid_type_lookup *
get_parsetab_by_name(s_type)
d588 1
a588 1
    register struct solid_type_lookup *stlp;
d599 1
a599 1
	return get_parsetab_by_id(ID_EBM);
d602 1
a602 1
	return get_parsetab_by_id(ID_VOL);
d605 1
a605 1
	return get_parsetab_by_id(ID_HF);
d608 1
a608 1
    for (stlp = solid_type_lookup; stlp->id != 0; stlp++)
d619 3
a621 2
/** 
 ** rt_db_get 
d640 1
a640 1
    register struct solid_type_lookup *stlp;
d658 2
d675 1
a675 1
	stlp = get_parsetab_by_id(id);
d720 1
a720 1
 *                  S T R U C T P A R S E _ A R G V
d726 1
d1003 2
a1004 2
/**
 ** rt_db_put
d1018 1
a1018 1
    register struct solid_type_lookup *stlp;
d1031 3
d1041 1
a1041 1
    stlp = get_parsetab_by_name(argv[2]);
d1048 1
a1048 1
    intern.idb_ptr = (genptr_t)bu_malloc(stlp->db_internal_size, "rt_db_put");
d1065 3
a1067 2
/** 
 ** rt_db_adjust
d1097 2
d1115 1
a1115 1
	sp = get_parsetab_by_id(id)->parsetab;
d1155 1
a1155 1
    register struct solid_type_lookup *stlp;
d1167 1
a1167 1
    sp = get_parsetab_by_name(argv[1])->parsetab;
@


1.7
log
@Name changing begins
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tcl.c,v 1.6 1997/03/07 10:28:04 mike Exp mike $ (ARL)";
d423 1
a423 1
struct bu_structparse db_tor_parse[] = {
d430 1
a430 1
struct bu_structparse db_tgc_parse[] = {
d439 1
a439 1
struct bu_structparse db_ell_parse[] = {
d446 1
a446 1
struct bu_structparse db_arb8_parse[] = {
d457 1
a457 1
struct bu_structparse db_half_parse[] = {
d462 1
a462 1
struct bu_structparse db_part_parse[] = {
d469 1
a469 1
struct bu_structparse db_rpc_parse[] = {
d476 1
a476 1
struct bu_structparse db_rhc_parse[] = {
d484 1
a484 1
struct bu_structparse db_epa_parse[] = {
d492 1
a492 1
struct bu_structparse db_ehy_parse[] = {
d501 1
a501 1
struct bu_structparse db_eto_parse[] = {
d520 13
a532 13
    { ID_TOR,     sizeof(struct rt_tor_internal), (long)RT_TOR_INTERNAL_MAGIC, "tor", db_tor_parse },
    { ID_TGC,     sizeof(struct rt_tgc_internal), (long)RT_TGC_INTERNAL_MAGIC, "tgc", db_tgc_parse },
    { ID_REC,     sizeof(struct rt_tgc_internal), (long)RT_TGC_INTERNAL_MAGIC, "rec", db_tgc_parse },
    { ID_ELL,     sizeof(struct rt_ell_internal), (long)RT_ELL_INTERNAL_MAGIC, "ell", db_ell_parse },
    { ID_SPH,     sizeof(struct rt_ell_internal), (long)RT_ELL_INTERNAL_MAGIC, "sph", db_ell_parse },
    { ID_ARB8,    sizeof(struct rt_arb_internal), (long)RT_ARB_INTERNAL_MAGIC, "arb8",db_arb8_parse },
    { ID_HALF,    sizeof(struct rt_half_internal),(long)RT_HALF_INTERNAL_MAGIC,"half",db_half_parse },
    { ID_PARTICLE,sizeof(struct rt_part_internal),(long)RT_PART_INTERNAL_MAGIC,"part",db_part_parse },
    { ID_RPC,     sizeof(struct rt_rpc_internal), (long)RT_RPC_INTERNAL_MAGIC, "rpc", db_rpc_parse },
    { ID_RHC,     sizeof(struct rt_rhc_internal), (long)RT_RHC_INTERNAL_MAGIC, "rhc", db_rhc_parse },
    { ID_EPA,     sizeof(struct rt_epa_internal), (long)RT_EPA_INTERNAL_MAGIC, "epa", db_epa_parse },
    { ID_EHY,     sizeof(struct rt_ehy_internal), (long)RT_EHY_INTERNAL_MAGIC, "ehy", db_ehy_parse },
    { ID_ETO,     sizeof(struct rt_eto_internal), (long)RT_ETO_INTERNAL_MAGIC, "eto", db_eto_parse },
@


1.6
log
@Initial working version
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tcl.c,v 1.5 1997/03/07 08:37:07 mike Exp mike $ (ARL)";
d327 1
a327 1
} db_cmds[] = {
d337 1
a337 1
 * rt_db
d341 1
a341 1
 *        db dbCmdName ?args?
d366 1
a366 1
    for( dbcmd = db_cmds; dbcmd->cmdname != NULL; dbcmd++ ) {
d379 1
a379 1
 * rt_db_match
d719 1
a719 1
structparse_argv( interp, argc, argv, desc, base )
d732 1
a732 1
	bu_log("structparse_argv: NULL desc pointer\n");
d756 1
a756 1
		bu_log("structparse_argv: unknown format\n");
d1036 1
a1036 1
    if (structparse_argv(interp, argc-3, argv+3, stlp->parsetab,
d1104 1
a1104 1
	    if (structparse_argv(interp, argc-2, argv+2, sp,
@


1.5
log
@Absorbed mged/db.c
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tcl.c,v 1.4 1997/03/06 08:40:58 mike Exp mike $ (ARL)";
d56 1
d58 6
d110 2
d113 27
a139 1
static struct rt_wdb *mike_wdb;
d141 9
a149 1
extern struct rt_wdb *wdb_dbopen();
d151 43
d198 1
a198 1
rt_tcl_get_comb(ip, interp, dbi_str, name)
d201 1
a201 1
CONST char		*dbi_str;
d203 1
d209 4
a212 5
	dbip = (struct db_i *)atoi(dbi_str);
	/* This can still dump core if it's an unmapped address */
	/* RT_CK_DBI_TCL(dbip) */
	if( !dbip || *((long *)dbip) != DBI_MAGIC )  {
		bu_badmagic_tcl(interp, (long *)dbip, DBI_MAGIC, "struct db_i", __FILE__, __LINE__);
d216 3
a218 11
	if( !mike_wdb )  {
		if( !(mike_wdb = wdb_dbopen( dbip, WDB_TYPE_DB_INMEM )) )  {
			Tcl_AppendResult(interp, "wdb_dbopen failed\n", NULL);
			return NULL;
		}
		/* Prevent accidents */
		if( !dbip->dbi_read_only )  {
			Tcl_AppendResult(interp, "(database changed to read-only)\n", NULL);
			dbip->dbi_read_only = 1;
		}
	}
d238 1
d247 1
d250 1
a250 1
		Tcl_AppendResult(interp, "Usage: rt_wdb_inmem_rgb $dbip comb r g b\n", NULL);
d254 1
a254 1
	if( !(comb = rt_tcl_get_comb( &intern, interp, argv[1], argv[2] )) )
d262 1
a262 1
	if( wdb_export( mike_wdb, argv[2], intern.idb_ptr, intern.idb_type, 1.0 ) < 0 )  {
d282 1
d285 1
a285 1
		Tcl_AppendResult(interp, "Usage: rt_wdb_inmem_shader $dbip comb shader [params]\n", NULL);
d289 1
a289 1
	if( !(comb = rt_tcl_get_comb( &intern, interp, argv[1], argv[2] )) )
d296 1
a296 1
	if( wdb_export( mike_wdb, argv[2], intern.idb_ptr, intern.idb_type, 1.0 ) < 0 )  {
d310 3
a312 3
 * XXX rather than being a "db" command, will be instantiations
 * XXX from a "wdb_open db_var_name" command, like Tk "window win_name".
 * XXX So that clientData will have wdb pointer.
d353 1
d362 1
a362 6
	/* XXX MAJOR HACK ***/
	if( !mike_wdb )  {
		Tcl_AppendResult(interp, "wdb_dbopen not yet called\n", NULL);
		return TCL_ERROR;
	}
	clientData = (ClientData)mike_wdb;
d1127 3
d1201 1
a1201 2
	/* This one is more temporary than the rest! */
	(void)Tcl_CreateCommand(interp, "rt_db", rt_db,
@


1.4
log
@rt_directchange_rgb is now sh_directchange_rgb, in the rt/ directory.
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tcl.c,v 1.3 1997/03/06 07:34:23 mike Exp mike $ (ARL)";
d36 1
d50 1
d89 15
a105 1
#define WDB_TYPE_DB_INMEM		3
d224 12
d237 5
d243 11
d256 852
d1117 8
@


1.3
log
@More formal names for things.
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tcl.c,v 1.2 1997/03/05 06:43:47 mike Exp mike $ (ARL)";
d53 1
a54 1

a55 10
 *  Macros to check and validate a structure pointer, given that
 *  the first entry in the structure is a magic number.
 */
#define BU_CKMAG_TCL(_interp, _ptr, _magic, _str)	\
	if( !(_ptr) || *((long *)(_ptr)) != (_magic) )  { \
		bu_badmagic_tcl( (_interp), (long *)(_ptr), _magic, _str, __FILE__, __LINE__ ); \
		return TCL_ERROR; \
	}

/*
d106 1
a106 1
	sscanf( dbi_str, "%d", &dbip );
a141 32
 *			R T _ D I R E C T C H A N G E _ R G B
 *
 *  Go poke the rgb values of a region, on the fly.
 *  This does not update the inmemory database, and will vanish on next re-prep.
 */
rt_directchange_rgb( clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
	if( argc != 6 )  {
		Tcl_AppendResult(interp, "Usage: rt_directchange_rgb $rtip comb r g b\n", NULL);
		return TCL_ERROR;
	}

	/* Validate rtip */
	/* Ensure rti has been prepped */
	/* Find all region names which match /comb/ pattern */
	/* Modify their color */

#if 0
	/* Make mods to comb here */
	comb->rgb[0] = atoi(argv[3+0]);
	comb->rgb[1] = atoi(argv[3+1]);
	comb->rgb[2] = atoi(argv[3+2]);
#endif

	return TCL_OK;
}

/*
a220 2
	(void)Tcl_CreateCommand(interp, "rt_directchange_rgb", rt_directchange_rgb,
		(ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);
@


1.2
log
@Initial experiments in dynamic geometry via a Tcl interface to
the new LIBWDB.
@
text
@d6 6
d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/tcl.c,v 1.1 1997/03/05 04:04:45 mike Exp mike $ (ARL)";
d152 4
a155 1
 *			R T _ I N M E M _ R G B
d157 1
a157 1
rt_inmem_rgb( clientData, interp, argc, argv )
d163 29
d196 1
a196 1
		Tcl_AppendResult(interp, "Usage: inmem_rgb $dbip comb r g b\n", NULL);
d218 1
a218 1
 *			R T _ I N M E M _ S H A D E R
d220 1
a220 1
rt_inmem_shader( clientData, interp, argc, argv )
d230 1
a230 1
		Tcl_AppendResult(interp, "Usage: inmem_shader $dbip comb shader [params]\n", NULL);
d263 1
a263 1
	(void)Tcl_CreateCommand(interp, "inmem_rgb", rt_inmem_rgb,
d265 3
a267 1
	(void)Tcl_CreateCommand(interp, "inmem_shader", rt_inmem_shader,
@


1.1
log
@Initial revision
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
d43 2
d46 3
d50 166
d225 6
@
