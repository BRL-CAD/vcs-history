head	1.26;
access;
symbols
	ansi-20040405-merged:1.22.2.2
	postmerge-20040405-ansi:1.24
	premerge-20040404-ansi:1.23
	postmerge-autoconf:1.23
	autoconf-freeze:1.22.10.2
	premerge-autoconf:1.23
	ansi-20040316-freeze:1.22.2.1
	postmerge-20040315-windows:1.23
	premerge-20040315-windows:1.23
	windows-20040315-freeze:1.22.4.1
	autoconf-20031203:1.22
	autoconf-20031202:1.22
	autoconf-branch:1.22.0.10
	phong-branch:1.22.0.8
	photonmap-branch:1.22.0.6
	rel-6-1-DP:1.22
	windows-branch:1.22.0.4
	rel-6-0-2:1.20
	ansi-branch:1.22.0.2
	rel-6-0-1-branch:1.20.0.2
	hartley-6-0-post:1.21
	hartley-6-0-pre:1.20
	rel-6-0-1:1.20
	rel-6-0:1.18
	offsite-5-3-pre:1.4;
locks; strict;
comment	@ * @;


1.26
date	2004.05.21.18.07.29;	author morrison;	state dead;
branches;
next	1.25;

1.25
date	2004.05.10.15.30.45;	author erikg;	state Exp;
branches;
next	1.24;

1.24
date	2004.04.05.08.48.56;	author morrison;	state Exp;
branches;
next	1.23;

1.23
date	2004.02.02.17.39.15;	author morrison;	state Exp;
branches;
next	1.22;

1.22
date	2002.08.20.17.07.56;	author jra;	state Exp;
branches
	1.22.2.1
	1.22.4.1
	1.22.10.1;
next	1.21;

1.21
date	2002.08.15.20.55.08;	author hartley;	state Exp;
branches;
next	1.20;

1.20
date	2002.05.10.13.02.07;	author jra;	state Exp;
branches;
next	1.19;

1.19
date	2002.05.09.19.01.03;	author jra;	state Exp;
branches;
next	1.18;

1.18
date	2002.02.22.02.44.23;	author morrison;	state Exp;
branches;
next	1.17;

1.17
date	2001.11.13.22.21.41;	author jra;	state Exp;
branches;
next	1.16;

1.16
date	2001.10.02.17.57.15;	author jra;	state Exp;
branches;
next	1.15;

1.15
date	2001.08.02.17.40.41;	author jra;	state Exp;
branches;
next	1.14;

1.14
date	2001.05.17.20.05.23;	author morrison;	state Exp;
branches;
next	1.13;

1.13
date	2001.04.20.22.29.40;	author morrison;	state Exp;
branches;
next	1.12;

1.12
date	2001.04.20.21.34.38;	author bparker;	state Exp;
branches;
next	1.11;

1.11
date	2001.04.02.13.04.52;	author jra;	state Exp;
branches;
next	1.10;

1.10
date	2001.03.23.22.34.30;	author butler;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.21.21.43.18;	author pjt;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.21.18.59.03;	author pjt;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.21.16.11.15;	author butler;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.21.15.25.57;	author pjt;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.20.21.54.41;	author pjt;	state Exp;
branches;
next	1.4;

1.4
date	2000.10.19.19.19.46;	author butler;	state Exp;
branches;
next	1.3;

1.3
date	2000.08.21.02.02.29;	author butler;	state Exp;
branches;
next	1.2;

1.2
date	2000.07.08.01.20.56;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	2000.06.30.17.24.34;	author pjt;	state Exp;
branches;
next	;

1.22.2.1
date	2002.09.19.18.01.29;	author morrison;	state Exp;
branches;
next	1.22.2.2;

1.22.2.2
date	2004.03.17.21.18.42;	author morrison;	state Exp;
branches;
next	;

1.22.4.1
date	2004.03.11.23.43.35;	author morrison;	state Exp;
branches;
next	;

1.22.10.1
date	2004.02.12.18.37.38;	author erikg;	state Exp;
branches;
next	1.22.10.2;

1.22.10.2
date	2004.03.15.14.07.17;	author erikg;	state Exp;
branches;
next	;


desc
@@


1.26
log
@moved to src/
@
text
@/*
 *			D B 5 _ B I N . C
 *
 *  Purpose -
 *	Handle bulk binary objects
 *
 *  Author -
 *	Paul J. Tanenbaum
 *
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 2000-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSell[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/db5_bin.c,v 1.25 2004/05/10 15:30:45 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#include <string.h>
#include <ctype.h>
#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "db5.h"
#include "nmg.h"
#include "raytrace.h"
#include "nurb.h"
#include "rtgeom.h"
#include "./debug.h"

/* this array depends on the values of the definitions of the DB5_MINORTYPE_BINU_... in db5.h */
const char *binu_types[]={
	NULL,
	NULL,
	"binary(float)",
	"binary(double)",
	"binary(u_8bit_int)",
	"binary(u_16bit_int)",
	"binary(u_32bit_int)",
	"binary(u_64bit_int)",
	NULL,
	NULL,
	NULL,
	NULL,
	"binary(8bit_int)",
	"binary(16bit_int)",
	"binary(32bit_int)",
	"binary(64bit_int)"
};

/* size of each element (in bytes) for the different BINUNIF types */
/* this array depends on the values of the definitions of the DB5_MINORTYPE_BINU_... in db5.h */
const int binu_sizes[]={
	0,
	0,
	SIZEOF_NETWORK_FLOAT,
	SIZEOF_NETWORK_DOUBLE,
	1,
	2,
	4,
	8,
	0,
	0,
	0,
	0,
	1,
	2,
	4,
	8
};
/*
 * XXX these are the interface routines needed for table.c
 */
int
rt_bin_expm_export5(struct bu_external *ep,
			const struct rt_db_internal *ip,
			double local2mm,
			const struct db_i *dbip,
			struct resource *resp)
{
	bu_log("rt_bin_expm_export5() not implemented\n");
	return -1;
}

int
rt_bin_unif_export5(struct bu_external *ep,
			const struct rt_db_internal *ip,
			double local2mm,
			const struct db_i *dbip,
			struct resource *resp)
{
	bu_log("rt_bin_unif_export5() not implemented\n");
	return -1;
}
int
rt_bin_unif_import5(struct rt_db_internal * ip,
 			const struct bu_external *ep,
 			const mat_t mat,
			const struct db_i *dbip,
			      struct resource *resp)
{
	bu_log("rt_bin_unif_import5() not implemented\n");
	return -1;
}
int
rt_bin_expm_import5(struct rt_db_internal * ip,
 			const struct bu_external *ep,
 			const mat_t mat,
			const struct db_i *dbip,
			      struct resource *resp)
{
	bu_log("rt_bin_expm_import5() not implemented\n");
	return -1;
}

int
rt_bin_mime_import5(struct rt_db_internal * ip,
 			const struct bu_external *ep,
 			const mat_t mat,
			const struct db_i *dbip,
			      struct resource *resp)
{
	bu_log("rt_bin_mime_import5() not implemented\n");
	return -1;
}

/*
 *			R T _ B I N U N I F _ I M P O R T 5
 *
 *  Import a uniform-array binary object from the database format to
 *  the internal structure.
 */
int
rt_binunif_import5( struct rt_db_internal	*ip,
		    const struct bu_external	*ep,
		    const mat_t			mat,
		    const struct db_i		*dbip,
		    struct resource		*resp,
		    const int			minor_type)
{
	struct rt_binunif_internal	*bip;
	int				i;
	unsigned char			*srcp;
	unsigned long			*ldestp;
	int				in_cookie, out_cookie;
	int				gotten;

	BU_CK_EXTERNAL( ep );

	/*
	 *	There's no particular size to expect
	 *
	 * BU_ASSERT_LONG( ep->ext_nbytes, ==, SIZEOF_NETWORK_DOUBLE * 3*4 );
	 */

	RT_CK_DB_INTERNAL( ip );
	ip->idb_major_type = DB5_MAJORTYPE_BINARY_UNIF;
	ip->idb_minor_type = minor_type;
	ip->idb_meth = &rt_functab[ID_BINUNIF];
	ip->idb_ptr = bu_malloc( sizeof(struct rt_binunif_internal),
	    "rt_binunif_internal");

	bip = (struct rt_binunif_internal *)ip->idb_ptr;
	bip->magic = RT_BINUNIF_INTERNAL_MAGIC;
	bip->type = minor_type;

	/*
	 * Convert from database (network) to internal (host) format
	 */
	switch (bip->type) {
	    case DB5_MINORTYPE_BINU_FLOAT:
		bip->count = ep->ext_nbytes/SIZEOF_NETWORK_FLOAT;
		bip->u.uint8 = (unsigned char *) bu_malloc( bip->count * sizeof(float),
		    "rt_binunif_internal" );
		ntohf( (unsigned char *) bip->u.uint8,
			ep->ext_buf, bip->count );
		break;
	    case DB5_MINORTYPE_BINU_DOUBLE:
		bip->count = ep->ext_nbytes/SIZEOF_NETWORK_DOUBLE;
		bip->u.uint8 = (unsigned char *) bu_malloc( bip->count * sizeof(double),
		    "rt_binunif_internal" );
		ntohd( (unsigned char *) bip->u.uint8,
			ep->ext_buf, bip->count );
		break;
	    case DB5_MINORTYPE_BINU_8BITINT:
	    case DB5_MINORTYPE_BINU_8BITINT_U:
		bip->count = ep->ext_nbytes;
		bip->u.uint8 = (unsigned char *) bu_malloc( ep->ext_nbytes,
		    "rt_binunif_internal" );
		bcopy( (char *) ep->ext_buf, (char *) bip->u.uint8, ep->ext_nbytes );
		break;
	    case DB5_MINORTYPE_BINU_16BITINT:
	    case DB5_MINORTYPE_BINU_16BITINT_U:
		bip->count = ep->ext_nbytes/2;
		bip->u.uint8 = (unsigned char *) bu_malloc( ep->ext_nbytes,
		    "rt_binunif_internal" );
#if 0
		srcp = (unsigned char *) ep->ext_buf;
		sdestp = (unsigned short *) bip->u.uint8;
		for (i = 0; i < bip->count; ++i, ++sdestp, srcp += 2) {
		    *sdestp = bu_gshort( srcp );
		    bu_log("Just got %d", *sdestp);
		}
#endif
		in_cookie = bu_cv_cookie("nus");
		out_cookie = bu_cv_cookie("hus");
		if (bu_cv_optimize(in_cookie) != bu_cv_optimize(out_cookie)) {
		    gotten =
		    bu_cv_w_cookie((genptr_t)bip->u.uint8, out_cookie,
				   ep->ext_nbytes,
				   ep->ext_buf, in_cookie, bip->count);
		    if (gotten != bip->count) {
			bu_log("%s:%d: Tried to convert %d, did %d",
			    __FILE__, __LINE__, bip->count, gotten);
			bu_bomb("\n");
		    }
		} else
		    bcopy( (char *) ep->ext_buf, (char *) bip->u.uint8,
			ep->ext_nbytes );
		break;
	    case DB5_MINORTYPE_BINU_32BITINT:
	    case DB5_MINORTYPE_BINU_32BITINT_U:
		bip->count = ep->ext_nbytes/4;
		bip->u.uint8 = (unsigned char *) bu_malloc( ep->ext_nbytes,
		    "rt_binunif_internal" );
		srcp = (unsigned char *) ep->ext_buf;
		ldestp = (unsigned long *) bip->u.uint8;
		for (i = 0; i < bip->count; ++i, ++ldestp, srcp += 4) {
		    *ldestp = bu_glong( srcp );
		    bu_log("Just got %ld", *ldestp);
		}
		break;
	    case DB5_MINORTYPE_BINU_64BITINT:
	    case DB5_MINORTYPE_BINU_64BITINT_U:
		bu_log("rt_binunif_import5() Can't handle 64-bit integers yet\n");
		return -1;
	}

	return 0;		/* OK */
}

/*
 *			R T _ B I N U N I F _ D U M P
 *
 *  Diagnostic routine
 */
void
rt_binunif_dump( struct rt_binunif_internal *bip) {
    RT_CK_BINUNIF(bip);
    bu_log("rt_bin_unif_internal <%x>...\n", bip);
    bu_log("  type = x%x = %d", bip -> type, bip -> type);
    bu_log("  count = %ld  first = 0x%02x", bip -> count,
	   bip->u.uint8[0] & 0x0ff);
    bu_log("- - - - -\n");
}


/*
 *			R T _ B I N E X P M _ I M P O R T 5
 *
 *  Import an experimental binary object from the database format to
 *  the internal structure.
 */
int
rt_binexpm_import5( struct rt_db_internal	*ip,
		    const unsigned char		minor_type,
		    const struct bu_external	*ep,
		    const struct db_i		*dbip )
{
	bu_log("rt_binexpm_import5() not implemented yet\n");
	return -1;
}


/*
 *			R T _ B I N M I M E _ I M P O R T 5
 *
 *  Import a MIME-typed binary object from the database format to
 *  the internal structure.
 */
int
rt_binmime_import5( struct rt_db_internal	*ip,
		    const unsigned char		minor_type,
		    const struct bu_external	*ep,
		    const struct db_i		*dbip )
{
	bu_log("rt_binmime_import5() not implemented yet\n");
	return -1;
}


/*
 *			R T _ B I N _ I M P O R T 5
 *
 *  Wrapper for importing binary objects from the database format to
 *  the internal structure.
 */
int
rt_bin_import5( struct rt_db_internal		*ip,
		const unsigned char		major_type,
		const unsigned char		minor_type,
		const struct bu_external	*ep,
		const struct db_i		*dbip )
{
    RT_CK_DB_INTERNAL(ip);

    switch (major_type) {
	case DB5_MAJORTYPE_BINARY_EXPM:
	    return rt_binexpm_import5( ip, minor_type, ep, dbip );
	case DB5_MAJORTYPE_BINARY_UNIF:
	    return rt_binunif_import5( ip, ep, 0, dbip, 0, minor_type );
	case DB5_MAJORTYPE_BINARY_MIME:
	    return rt_binmime_import5( ip, minor_type, ep, dbip );
    }
    return -1;
}

/*
 *			R T _ B I N U N I F _ E X P O R T 5
 *
 *	Create the "body" portion of external form
 */
int
rt_binunif_export5( struct bu_external		*ep,
		    const struct rt_db_internal	*ip,
		    double			local2mm,	/* we ignore */
		    const struct db_i		*dbip,
		    struct resource		*resp,
		    const int			minor_type )
{
	struct rt_binunif_internal	*bip;
	int				i;
	unsigned char			*destp;
	unsigned long			*lsrcp;
	int				in_cookie, out_cookie;
	int				gotten;

	RT_CK_DB_INTERNAL(ip);
	if( ip->idb_minor_type != minor_type ) {
		bu_log("ip->idb_minor_type(%d) != minor_type(%d)\n",
		       ip->idb_minor_type, minor_type );
		return -1;
	}
	bip = (struct rt_binunif_internal *)ip->idb_ptr;
	RT_CK_BINUNIF(bip);
	if( bip->type != minor_type ) {
		bu_log("bip->type(%d) != minor_type(%d)\n",
		       bip->type, minor_type );
		return -1;
	}

	BU_INIT_EXTERNAL(ep);

	/*
	 * Convert from internal (host) to database (network) format
	 */
	switch (bip->type) {
	    case DB5_MINORTYPE_BINU_FLOAT:
		ep->ext_nbytes = bip->count * SIZEOF_NETWORK_FLOAT;
		ep->ext_buf = (genptr_t)bu_malloc( ep->ext_nbytes,
		    "binunif external");
		htonf( ep->ext_buf, (unsigned char *) bip->u.uint8, bip->count );
		break;
	    case DB5_MINORTYPE_BINU_DOUBLE:
		ep->ext_nbytes = bip->count * SIZEOF_NETWORK_DOUBLE;
		ep->ext_buf = (genptr_t)bu_malloc( ep->ext_nbytes,
		    "binunif external");
		htond( ep->ext_buf, (unsigned char *) bip->u.uint8, bip->count );
		break;
	    case DB5_MINORTYPE_BINU_8BITINT:
	    case DB5_MINORTYPE_BINU_8BITINT_U:
		ep->ext_nbytes = bip->count;
		ep->ext_buf = (genptr_t)bu_malloc( ep->ext_nbytes,
		    "binunif external");
		bcopy( (char *) bip->u.uint8, (char *) ep->ext_buf, bip->count );
		break;
	    case DB5_MINORTYPE_BINU_16BITINT:
	    case DB5_MINORTYPE_BINU_16BITINT_U:
		ep->ext_nbytes = bip->count * 2;
		ep->ext_buf = (genptr_t)bu_malloc( ep->ext_nbytes,
		    "binunif external");
#if 0
		ssrcp = (unsigned short *) bip->u.uint8;
		destp = (unsigned char *) ep->ext_buf;
		for (i = 0; i < bip->count; ++i, ++destp, ++ssrcp) {
		    (void) bu_pshort( destp, *ssrcp );
		    bu_log("Just put from %d", *ssrcp);
		}
#else
		in_cookie = bu_cv_cookie("hus");
		out_cookie = bu_cv_cookie("nus");
		if (bu_cv_optimize(in_cookie) != bu_cv_optimize(out_cookie)) {
		    gotten =
			    bu_cv_w_cookie(ep->ext_buf, out_cookie,
					   ep->ext_nbytes,
					   (genptr_t) bip->u.uint8, in_cookie,
					   bip->count);

		    if (gotten != bip->count) {
			bu_log("%s:%d: Tried to convert %d, did %d",
			    __FILE__, __LINE__, bip->count, gotten);
			bu_bomb("\n");
		    }
		} else {
		    bcopy( (char *) bip->u.uint8, (char *) ep->ext_buf,
			ep->ext_nbytes );
		}
#endif
		break;
	    case DB5_MINORTYPE_BINU_32BITINT:
	    case DB5_MINORTYPE_BINU_32BITINT_U:
		ep->ext_nbytes = bip->count * 4;
		ep->ext_buf = (genptr_t)bu_malloc( ep->ext_nbytes,
		    "binunif external");

		lsrcp = (unsigned long *) bip->u.uint8;
		destp = (unsigned char *) ep->ext_buf;
		for (i = 0; i < bip->count; ++i, ++destp, ++lsrcp) {
		    (void) bu_plong( destp, *lsrcp );
		    bu_log("Just put from %ld", *lsrcp);
		}
		break;
	    case DB5_MINORTYPE_BINU_64BITINT:
	    case DB5_MINORTYPE_BINU_64BITINT_U:
		bu_log("rt_binunif_export5() Can't handle 64-bit integers yet\n");
		return -1;
	}

	return 0;
}

/*
 *			R T _ B I N U N I F _ D E S C R I B E
 *
 *  Make human-readable formatted presentation of this object.
 *  First line describes type of object.
 *  Additional lines are indented one tab, and give parameter values.
 */
int
rt_binunif_describe( struct bu_vls		*str,
		    const struct rt_db_internal	*ip,
		    int				verbose,
		    double			mm2local )
{
	register struct rt_binunif_internal	*bip;
	char					buf[256];
	unsigned short				wid;

	bip = (struct rt_binunif_internal *) ip->idb_ptr;
	RT_CK_BINUNIF(bip);
	bu_vls_strcat( str, "uniform-array binary object (BINUNIF)\n");
	wid = (bip->type & DB5_MINORTYPE_BINU_WID_MASK) >> 4;
	switch (wid) {
	    case 0:
		sprintf( buf, "%ld ", bip->count ); break;
	    case 1:
		sprintf( buf, "%ld pairs of ", bip->count / 2 ); break;
	    case 2:
		sprintf( buf, "%ld triples of ", bip->count / 3 ); break;
	    case 3:
		sprintf( buf, "%ld quadruples of ", bip->count / 4 ); break;
	}
	bu_vls_strcat( str, buf );
	switch (bip->type & DB5_MINORTYPE_BINU_ATM_MASK) {
	    case DB5_MINORTYPE_BINU_FLOAT:
		bu_vls_strcat( str, "floats\n"); break;
	    case DB5_MINORTYPE_BINU_DOUBLE:
		bu_vls_strcat( str, "doubles\n"); break;
	    case DB5_MINORTYPE_BINU_8BITINT:
		bu_vls_strcat( str, "8-bit ints\n"); break;
	    case DB5_MINORTYPE_BINU_16BITINT:
		bu_vls_strcat( str, "16-bit ints\n"); break;
	    case DB5_MINORTYPE_BINU_32BITINT:
		bu_vls_strcat( str, "32-bit ints\n"); break;
	    case DB5_MINORTYPE_BINU_64BITINT:
		bu_vls_strcat( str, "64-bit ints\n"); break;
	    case DB5_MINORTYPE_BINU_8BITINT_U:
		bu_vls_strcat( str, "unsigned 8-bit ints\n"); break;
	    case DB5_MINORTYPE_BINU_16BITINT_U:
		bu_vls_strcat( str, "unsigned 16-bit ints\n"); break;
	    case DB5_MINORTYPE_BINU_32BITINT_U:
		bu_vls_strcat( str, "unsigned 32-bit ints\n"); break;
	    case DB5_MINORTYPE_BINU_64BITINT_U:
		bu_vls_strcat( str, "unsigned 64-bit ints\n"); break;
	    default:
		bu_log("%s:%d: This shouldn't happen", __FILE__, __LINE__);
		return(1);
	}

	return(0);
}

/*
 *		R T _ B I N U N I F _ F R E E 
 *
 *	Free the storage associated with a binunif_internal object
 */
void
rt_binunif_free( struct rt_binunif_internal *bip) {
	RT_CK_BINUNIF(bip);
	bu_free( (genptr_t) bip->u.uint8, "binunif free uint8" );
	bu_free( bip, "binunif free");
	bip = GENPTR_NULL; /* sanity */
}

/*
 *			R T _ B I N U N I F _ I F R E E
 *
 *  Free the storage associated with the rt_db_internal version of this thing.
 */
void
rt_binunif_ifree( struct rt_db_internal	*ip )
{
	struct rt_binunif_internal	*bip;

	RT_CK_DB_INTERNAL(ip);
	bip = (struct rt_binunif_internal *)ip->idb_ptr;
	RT_CK_BINUNIF(bip);
	bu_free( (genptr_t) bip->u.uint8, "binunif ifree" );
	bu_free( ip->idb_ptr, "binunif ifree" );
	ip->idb_ptr = GENPTR_NULL;
}


int
rt_retrieve_binunif(struct rt_db_internal *intern,
		    struct db_i	*dbip,
		    char *name)
{
	register struct directory	*dp;
	struct rt_binunif_internal	*bip;
	struct bu_external		ext;
	struct db5_raw_internal		raw;
	char				*tmp;

	/*
	 *	Find the guy we're told to write
	 */
	if( (dp = db_lookup( dbip, name, LOOKUP_NOISY)) == DIR_NULL )
		return -1;

	RT_INIT_DB_INTERNAL(intern);
	if ( rt_db_get_internal5( intern, dp, dbip, NULL, &rt_uniresource) 
	     != ID_BINUNIF     || db_get_external( &ext, dp, dbip ) < 0 )
		return -1;

	if (db5_get_raw_internal_ptr(&raw, ext.ext_buf) == NULL) {
	    bu_log("%s:%d\n", __FILE__, __LINE__);
		bu_free_external( &ext );
		return -1;
	}
	if (db5_type_descrip_from_codes(&tmp, raw.major_type, raw.minor_type))
		tmp = 0;

	if (RT_G_DEBUG & DEBUG_VOL)
		bu_log("get_body() sees type (%d, %d)='%s'\n",
		       raw.major_type, raw.minor_type, tmp);

	if (raw.major_type != DB5_MAJORTYPE_BINARY_UNIF)
		return -1;

	bip = intern->idb_ptr;
	RT_CK_BINUNIF(bip);
	if (RT_G_DEBUG & DEBUG_HF)
		rt_binunif_dump(bip);

	if (RT_G_DEBUG & DEBUG_VOL)
		bu_log("cmd_export_body() thinks bip->count=%d\n",
		       bip->count);

	switch (bip -> type) {
	case DB5_MINORTYPE_BINU_FLOAT:
		if (RT_G_DEBUG & DEBUG_VOL)
			bu_log("bip->type switch... float");
		break;
	case DB5_MINORTYPE_BINU_DOUBLE:
		if (RT_G_DEBUG & DEBUG_VOL)
			bu_log("bip->type switch... double");
		break;
	case DB5_MINORTYPE_BINU_8BITINT:
		if (RT_G_DEBUG & DEBUG_VOL)
			bu_log("bip->type switch... 8bitint");
		break;
	case DB5_MINORTYPE_BINU_8BITINT_U:
		if (RT_G_DEBUG & DEBUG_VOL)
			bu_log("bip->type switch... 8bituint");
		break;
	case DB5_MINORTYPE_BINU_16BITINT:
		if (RT_G_DEBUG & DEBUG_VOL)
			bu_log("bip->type switch... 16bituint");
		break;
	case DB5_MINORTYPE_BINU_16BITINT_U:
		if (RT_G_DEBUG & DEBUG_VOL)
			bu_log("bip->type switch... 16bitint");
		break;
	case DB5_MINORTYPE_BINU_32BITINT:
	case DB5_MINORTYPE_BINU_32BITINT_U:
		if (RT_G_DEBUG & DEBUG_VOL)
			bu_log("bip->type switch... 32bitint");
		break;
	case DB5_MINORTYPE_BINU_64BITINT:
	case DB5_MINORTYPE_BINU_64BITINT_U:
		if (RT_G_DEBUG & DEBUG_VOL)
			bu_log("bip->type switch... 64bitint");
		break;
	default:
		/* XXX	This shouln't happen!!    */
		bu_log("bip->type switch... default");
		break;
	}

	bu_free_external( &ext );

	return 0;
}

void
rt_binunif_make(const struct rt_functab *ftp, struct rt_db_internal *intern, double diameter)
{
	struct rt_binunif_internal *bip;

	intern->idb_type = DB5_MINORTYPE_BINU_8BITINT;
	intern->idb_major_type = DB5_MAJORTYPE_BINARY_UNIF;
	BU_ASSERT(&rt_functab[ID_BINUNIF] == ftp);

	intern->idb_meth = ftp;
	bip = (struct rt_binunif_internal *)bu_calloc( sizeof( struct rt_binunif_internal), 1,
						       "rt_binunif_make");
	intern->idb_ptr = (genptr_t) bip;
	bip->magic = RT_BINUNIF_INTERNAL_MAGIC;
	bip->type = DB5_MINORTYPE_BINU_8BITINT;
	bip->count = 0;
	bip->u.int8 = NULL;
}

int
rt_binunif_tclget(Tcl_Interp *interp, const struct rt_db_internal *intern, const char *attr )
{
	register struct rt_binunif_internal *bip=(struct rt_binunif_internal *)intern->idb_ptr;
	struct bu_external	ext;
	Tcl_DString		ds;
	struct bu_vls		vls;
	int			status=TCL_OK;
	int			i;
	unsigned char		*c;

	RT_CHECK_BINUNIF( bip );

	Tcl_DStringInit( &ds );
	bu_vls_init( &vls );

	if( attr == (char *)NULL )
	{
		/* export the object to get machine independent form */
		if( rt_binunif_export5( &ext, intern, 1.0, NULL, NULL, intern->idb_minor_type ) ) {
			bu_vls_strcpy( &vls, "Failed to export binary object!!\n" );
			status = TCL_ERROR;
		} else {
			bu_vls_strcpy( &vls, "binunif" );
			bu_vls_printf( &vls, " T %d D {", bip->type );
			c = ext.ext_buf;
			for( i=0 ; i<ext.ext_nbytes ; i++,c++ ) {
				if( i%40 == 0 ) bu_vls_strcat( &vls, "\n" );
				bu_vls_printf( &vls, "%2.2x", *c );
			}
			bu_vls_strcat( &vls, "}" );
			bu_free_external( &ext );
		}

	} else {
		if( !strcmp( attr, "T" ) ) {
			bu_vls_printf( &vls, "%d", bip->type );
		} else if( !strcmp( attr, "D" ) ) {
			/* export the object to get machine independent form */
			if( rt_binunif_export5( &ext, intern, 1.0, NULL, NULL,
						intern->idb_minor_type ) ) {
				bu_vls_strcpy( &vls, "Failed to export binary object!!\n" );
				status = TCL_ERROR;
			} else {
				c = ext.ext_buf;
				for( i=0 ; i<ext.ext_nbytes ; i++,c++ ) {
					if( i != 0 && i%40 == 0 ) bu_vls_strcat( &vls, "\n" );
					bu_vls_printf( &vls, "%2.2x", *c );
				}
				bu_free_external( &ext );
			}
		} else {
			bu_vls_printf( &vls, "Binary object has no attribute '%s'", attr );
			status = TCL_ERROR;
		}
	}

	Tcl_DStringAppend( &ds, bu_vls_addr( &vls ), -1 );
	Tcl_DStringResult( interp, &ds );
	Tcl_DStringFree( &ds );
	bu_vls_free( &vls );

	return( status );
}

int
rt_binunif_tcladjust( Tcl_Interp *interp, struct rt_db_internal *intern, int argc, char **argv )
{
	struct rt_binunif_internal *bip;
	int i;

	RT_CK_DB_INTERNAL( intern );
	bip = (struct rt_binunif_internal *)intern->idb_ptr;
	RT_CHECK_BINUNIF( bip );

	while( argc >= 2 ) {
		if( !strcmp( argv[0], "T" ) ) {
			int new_type=-1;
			char *c;
			int type_is_digit=1;

			c = argv[1];
			while( *c != '\0' ) {
				if( !isdigit( *c ) ) {
					type_is_digit = 0;
					break;
				}
				c++;
			}

			if( type_is_digit ) {
				new_type = atoi( argv[1] );
			} else {
				if( argv[1][1] != '\0' ) {
					Tcl_AppendResult( interp, "Illegal type: ",
					   argv[1],
					   ", must be 'f', 'd', 'c', 'i', 'l', 'C', 'S', 'I', or 'L'",
					   (char *)NULL );
					return TCL_ERROR;
				}
				switch( argv[1][0] ) {
					case 'f':
						new_type = 2;
						break;
					case 'd':
						new_type = 3;
						break;
					case 'c':
						new_type = 4;
						break;
					case 's':
						new_type = 5;
						break;
					case 'i':
						new_type = 6;
						break;
					case 'l':
						new_type = 7;
						break;
					case 'C':
						new_type = 12;
						break;
					case 'S':
						new_type = 13;
						break;
					case 'I':
						new_type = 14;
						break;
					case 'L':
						new_type = 15;
						break;
				}
			}
			if( new_type < 0 ||
			    new_type > DB5_MINORTYPE_BINU_64BITINT ||
			    binu_types[new_type] == NULL ) {
				/* Illegal value for type */
				Tcl_AppendResult( interp, "Illegal value for binary type: ", argv[1],
						  (char *)NULL );
				return TCL_ERROR;
			} else {
				if( bip->u.uint8 ) {
					int new_count;
					int old_byte_count, new_byte_count;
					int remainder;

					old_byte_count = bip->count * binu_sizes[bip->type];
					new_count = old_byte_count / binu_sizes[new_type];
					remainder = old_byte_count % binu_sizes[new_type];
					if( remainder ) {
						new_count++;
						new_byte_count = new_count * binu_sizes[new_type];
					} else {
						new_byte_count = old_byte_count;
					}

					if( new_byte_count != old_byte_count ) {
						bip->u.uint8 = bu_realloc( bip->u.uint8,
									   new_byte_count,
									   "new bytes for binunif" );
						/* zero out the new bytes */
						for( i=old_byte_count ; i<new_byte_count ; i++ ) {
							bip->u.uint8[i] = 0;
						}
					}
					bip->count = new_count;
				}
				bip->type = new_type;
				intern->idb_type = new_type;
			}
		} else if( !strcmp( argv[0], "D" ) ) {
			Tcl_Obj *obj, *list, **obj_array;
			int list_len;
			unsigned char *buf, *d;
			char *s;
			int hexlen;
			unsigned int h;

			obj = Tcl_NewStringObj( argv[1], -1 );
			list = Tcl_NewListObj( 0, NULL );
			Tcl_ListObjAppendList( interp, list, obj );
			(void)Tcl_ListObjGetElements( interp, list, &list_len, &obj_array );

			hexlen = 0;
			for( i=0 ; i<list_len ; i++ ) {
				hexlen += Tcl_GetCharLength( obj_array[i] );
			}

			if( hexlen % 2 ) {
				Tcl_AppendResult( interp,
				    "Hex form of binary data must have an even number of hex digits",
				    (char *)NULL );
				return TCL_ERROR;
			}

			buf = (unsigned char *)bu_malloc( hexlen / 2, "tcladjust binary data" );
			d = buf;
			for( i=0 ; i<list_len ; i++ ) {
				s = Tcl_GetString( obj_array[i] );
				while( *s ) {
					sscanf( s, "%2x", &h );
					*d++ = h;
					s += 2;
				}
			}
			Tcl_DecrRefCount( list );

			if( bip->u.uint8 ) {
				bu_free( bip->u.uint8, "binary data" );
			}
			bip->u.uint8 = buf;
			bip->count = hexlen / 2 / binu_sizes[bip->type];
		}

		argc -= 2;
		argv += 2;
	}

	return TCL_OK;
}
@


1.25
log
@change conf.h to a wrapped config.h
@
text
@d19 1
a19 1
static const char RCSell[] = "@@(#)$Header: /cvs/brlcad/librt/db5_bin.c,v 1.24 2004/04/05 08:48:56 morrison Exp $ (BRL)";
@


1.24
log
@merge of ansi-6-0-branch into HEAD
@
text
@d19 1
a19 1
static const char RCSell[] = "@@(#)$Header$ (BRL)";
d22 5
a26 1
#include "conf.h"
@


1.23
log
@update copyright to include span through 2003
@
text
@d19 1
a19 1
static const char RCSell[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_bin.c,v 1.22 2002/08/20 17:07:56 jra Exp $ (BRL)";
d625 1
a625 4
rt_binunif_make( ftp, intern, diameter )
const struct rt_functab	*ftp;
struct rt_db_internal	*intern;
double			diameter;
@


1.22
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d15 1
a15 1
 *	This software is Copyright (C) 2000 by the United States Army.
d19 1
a19 1
static const char RCSell[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_bin.c,v 1.20 2002/05/10 13:02:07 jra Exp $ (BRL)";
@


1.22.4.1
log
@sync to HEAD...
@
text
@d15 1
a15 1
 *	This software is Copyright (C) 2000-2004 by the United States Army.
d19 1
a19 1
static const char RCSell[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/db5_bin.c,v 1.23 2004/02/02 17:39:15 morrison Exp $ (BRL)";
@


1.22.10.1
log
@merge from HEAD
@
text
@d15 1
a15 1
 *	This software is Copyright (C) 2000-2004 by the United States Army.
d19 1
a19 1
static const char RCSell[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_bin.c,v 1.23 2004/02/02 17:39:15 morrison Exp $ (BRL)";
@


1.22.10.2
log
@merge from head
@
text
@d19 1
a19 1
static const char RCSell[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_bin.c,v 1.22.10.1 2004/02/12 18:37:38 erikg Exp $ (BRL)";
@


1.22.2.1
log
@Initial ANSIfication
@
text
@d19 1
a19 1
static const char RCSell[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_bin.c,v 1.22 2002/08/20 17:07:56 jra Exp $ (BRL)";
d625 4
a628 1
rt_binunif_make(const struct rt_functab *ftp, struct rt_db_internal *intern, double diameter)
@


1.22.2.2
log
@sync branch with HEAD
@
text
@d15 1
a15 1
 *	This software is Copyright (C) 2000-2004 by the United States Army.
d19 1
a19 1
static const char RCSell[] = "@@(#)$Header$ (BRL)";
@


1.21
log
@Converted from K&R to ANSI C - RFH
@
text
@d625 4
a628 1
rt_binunif_make(const struct rt_functab *ftp, struct rt_db_internal *intern, double diameter)
@


1.20
log
@tcladjust now accepts the same one character minor types as does "dbbinary" command
@
text
@d19 1
a19 1
static const char RCSell[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_bin.c,v 1.19 2002/05/09 19:01:03 jra Exp $ (BRL)";
d625 1
a625 4
rt_binunif_make( ftp, intern, diameter )
const struct rt_functab	*ftp;
struct rt_db_internal	*intern;
double			diameter;
@


1.19
log
@Added tcl adjust abd tclget support for binary objects
@
text
@d19 1
a19 1
static const char RCSell[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_bin.c,v 1.18 2002/02/22 02:44:23 morrison Exp $ (BRL)";
d27 1
d723 12
a734 1
			int new_type;
d736 43
a778 1
			new_type = atoi( argv[1] );
@


1.18
log
@Added rt_binunif_free() call (did not exist\!) to free up a struct rt_binunif_internal object (like all the other objects have)
@
text
@d19 1
a19 1
static const char RCSell[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_bin.c,v 1.17 2001/11/13 22:21:41 jra Exp $ (BRL)";
d57 20
d629 3
a631 1
	intern->idb_type = 0;
d633 1
a633 1
	BU_ASSERT(&rt_functab[intern->idb_type] == ftp);
d636 175
a810 2
	intern->idb_ptr = bu_calloc( ftp->ft_internal_size, 1, "rt_generic_make");
	*((long *)(intern->idb_ptr)) = ftp->ft_internal_magic;
@


1.17
log
@Added binu_types[] array
@
text
@d19 1
a19 1
static const char RCSell[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_bin.c,v 1.16 2001/10/02 17:57:15 jra Exp $ (BRL)";
d477 13
@


1.16
log
@Added rt_binunif_make() routine
@
text
@d19 1
a19 1
static const char RCSell[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_bin.c,v 1.15 2001/08/02 17:40:41 jra Exp $ (BRL)";
d36 20
@


1.15
log
@Added db_diradd5()
@
text
@d19 1
a19 1
static const char RCSell[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_bin.c,v 1.14 2001/05/17 20:05:23 morrison Exp $ (BRL)";
d568 15
@


1.14
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d19 1
a19 1
static const char RCSell[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_bin.c,v 1.13 2001/04/20 22:29:40 morrison Exp $ (BRL)";
d286 2
a302 2

	bu_log("rt_binunif_export5\n");
@


1.13
log
@CONST to const
@
text
@d19 1
a19 1
static const char RCSell[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_bin.c,v 1.12 2001/04/20 21:34:38 bparker Exp $ (BRL)";
d508 1
a508 1
	if (rt_g.debug & DEBUG_VOL)
d517 1
a517 1
	if (rt_g.debug & DEBUG_HF)
d520 1
a520 1
	if (rt_g.debug & DEBUG_VOL)
d526 1
a526 1
		if (rt_g.debug & DEBUG_VOL)
d530 1
a530 1
		if (rt_g.debug & DEBUG_VOL)
d534 1
a534 1
		if (rt_g.debug & DEBUG_VOL)
d538 1
a538 1
		if (rt_g.debug & DEBUG_VOL)
d542 1
a542 1
		if (rt_g.debug & DEBUG_VOL)
d546 1
a546 1
		if (rt_g.debug & DEBUG_VOL)
d551 1
a551 1
		if (rt_g.debug & DEBUG_VOL)
d556 1
a556 1
		if (rt_g.debug & DEBUG_VOL)
@


1.12
log
@*- mods for handling return value of db5_get_raw_internal_ptr()
   differently. Previous code tested for <0 to indicate
   a failed attempt. However, this routine never returns
   values less than 0. It returns NULL (0) for failure and >0
   for success.
@
text
@d19 1
a19 1
static const char RCSell[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_bin.c,v 1.11 2001/04/02 13:04:52 jra Exp $ (BRL)";
d42 1
a42 1
			CONST struct rt_db_internal *ip,
d44 1
a44 1
			CONST struct db_i *dbip,
d53 1
a53 1
			CONST struct rt_db_internal *ip,
d55 1
a55 1
			CONST struct db_i *dbip,
d63 3
a65 3
 			CONST struct bu_external *ep,
 			CONST mat_t mat,
			CONST struct db_i *dbip,
d73 3
a75 3
 			CONST struct bu_external *ep,
 			CONST mat_t mat,
			CONST struct db_i *dbip,
d84 3
a86 3
 			CONST struct bu_external *ep,
 			CONST mat_t mat,
			CONST struct db_i *dbip,
d101 3
a103 3
		    CONST struct bu_external	*ep,
		    CONST mat_t			mat,
		    CONST struct db_i		*dbip,
d105 1
a105 1
		    CONST int			minor_type)
d232 3
a234 3
		    CONST unsigned char		minor_type,
		    CONST struct bu_external	*ep,
		    CONST struct db_i		*dbip )
d249 3
a251 3
		    CONST unsigned char		minor_type,
		    CONST struct bu_external	*ep,
		    CONST struct db_i		*dbip )
d266 4
a269 4
		CONST unsigned char		major_type,
		CONST unsigned char		minor_type,
		CONST struct bu_external	*ep,
		CONST struct db_i		*dbip )
d289 1
a289 1
		    CONST struct rt_db_internal	*ip,
d291 1
a291 1
		    CONST struct db_i		*dbip,
d293 1
a293 1
		    CONST int			minor_type )
d407 1
a407 1
		    CONST struct rt_db_internal	*ip,
@


1.11
log
@Lint
@
text
@d19 1
a19 1
static const char RCSell[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_bin.c,v 1.10 2001/03/23 22:34:30 butler Exp $ (BRL)";
d500 1
a500 1
	if ( db5_get_raw_internal_ptr( &raw, ext.ext_buf ) < 0 ) {
@


1.10
log
@Changes to support new DSP primitive representation
@
text
@d19 1
a19 1
static const char RCSell[] = "@@(#)$Header: /n/tgm/d/CVS/brlcad/librt/db5_bin.c,v 1.9 2001/03/21 21:43:18 pjt Exp $ (BRL)";
a484 1
	size_t				nbytes; /* not really needed */
a527 1
		nbytes = (size_t) (bip->count * sizeof(float));
a531 1
		nbytes = (size_t) (bip->count * sizeof(double));
a535 1
		nbytes = (size_t) (bip->count);
a539 1
		nbytes = (size_t) (bip->count);
a543 1
		nbytes = (size_t) (bip->count * 2);
a547 1
		nbytes = (size_t) (bip->count * 2);
a552 1
		nbytes = (size_t) (bip->count * 4);
a557 1
		nbytes = (size_t) (bip->count * 8);
@


1.9
log
@It's starting to work
@
text
@d19 1
a19 1
static const char RCSell[] = "@@(#)$Header: /d/CVS/brlcad/librt/db5_bin.c,v 1.8 2001/03/21 18:59:03 pjt Exp $ (BRL)";
a110 1
	unsigned short			*sdestp;
d175 3
a177 2
		    bu_cv_w_cookie(ep->ext_buf, in_cookie, bip->count,
			(genptr_t) bip->u.uint8, out_cookie, ep->ext_nbytes);
d216 1
a216 1
    bu_log("rt_bin_unif_internal <%x>...", bip);
d218 3
a220 2
    bu_log("  count = %ld", bip -> count);
    bu_log("- - - - -");
a298 1
	unsigned short			*ssrcp;
d302 2
d355 1
a355 1
#endif
d360 5
a364 3
		    bu_cv_w_cookie((genptr_t) bip->u.uint8, in_cookie,
			bip->count,
			ep->ext_buf, out_cookie, ep->ext_nbytes);
d374 1
d475 102
@


1.8
log
@Hey, at least it doesn't bomb
@
text
@d19 1
a19 1
static const char RCSell[] = "@@(#)$Header: /d/CVS/brlcad/librt/db5_bin.c,v 1.7 2001/03/21 16:11:15 butler Exp $ (BRL)";
d112 2
d143 1
a143 1
			ep->ext_buf, ep->ext_nbytes/SIZEOF_NETWORK_FLOAT );
d147 1
a147 1
		bip->u.uint8 = (unsigned char *) bu_malloc( bip->count * sizeof(float),
d150 1
a150 1
			ep->ext_buf, ep->ext_nbytes/SIZEOF_NETWORK_DOUBLE );
d157 1
a157 1
		bcopy( (char *) bip->u.uint8, (char *) ep->ext_buf, ep->ext_nbytes );
d164 1
d168 2
a169 1
		    *sdestp = bu_gshort( (unsigned char *) srcp );
d171 15
d195 2
a196 1
		    *ldestp = bu_glong( (unsigned char *) srcp );
d299 2
d339 1
a339 1
		bcopy( (char *) ep->ext_buf, (char *) bip->u.uint8, bip->count );
d346 1
a346 1

d349 1
a349 1
		for (i = 0; i < bip->count; ++i, ++destp, ssrcp += 2)
d351 19
d379 1
a379 1
		for (i = 0; i < bip->count; ++i, ++destp, lsrcp += 4)
d381 2
a411 1
	rt_binunif_dump(bip);
a413 1
	bu_log("bip->count is %d\n", bip->count);
a449 1
	bu_log("str contains: '%s'\n", bu_vls_addr(str));
@


1.7
log
@extra debugging logs & minor type fixes
@
text
@d19 1
a19 1
static const char RCSell[] = "@@(#)$Header: /n/tgm/d/CVS/brlcad/librt/db5_bin.c,v 1.6 2001/03/21 15:25:57 pjt Exp $ (BRL)";
d122 2
a123 1
	ip->idb_type = ID_BINUNIF;
d281 3
a283 3
	if( ip->idb_type != minor_type ) {
		bu_log("ip->idb_type(%d) != minor_type(%d)\n",
		       ip->idb_type, minor_type );
a366 1
	bu_made_it();
a371 1
	bu_made_it();
a382 1
	bu_made_it();
a383 1
	bu_made_it();
a408 1
	bu_made_it();
d417 1
a417 1
 *  Free the storage associated with the rt_db_internal version of this solid.
@


1.6
log
@Added a "This shouldn't happen" branch to case stmt
@
text
@d19 1
a19 1
static const char RCSell[] = "@@(#)$Header: /d/CVS/brlcad/librt/db5_bin.c,v 1.5 2001/03/20 21:54:41 pjt Exp $ (BRL)";
d280 5
a284 1
	if( ip->idb_type != ID_BINUNIF )  return -1;
d287 5
@


1.5
log
@COB 20 Mar 2001
@
text
@d19 1
a19 1
static const char RCSell[] = "@@(#)$Header: /d/CVS/brlcad/librt/db5_bin.c,v 1.4 2000/10/19 19:19:46 butler Exp $ (BRL)";
d399 3
@


1.4
log
@Changes to compile under RedHat 7.0
@
text
@d19 1
a19 1
static const char RCSell[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_bin.c,v 1.3 2000/08/21 02:02:29 butler Exp $ (BRL)";
a100 1
		    CONST unsigned char		minor_type,
d102 4
a105 1
		    CONST struct db_i		*dbip )
d123 1
a123 1
	ip->idb_meth = 0;
d187 13
a199 1

d249 2
d255 1
a255 1
	    return rt_binunif_import5( ip, minor_type, ep, dbip );
d268 4
a271 1
		    CONST struct db_i		*dbip )
d343 2
a344 2
 *  Make human-readable formatted presentation of this solid.
 *  First line describes type of solid.
d357 1
d360 1
d363 2
d375 1
d377 1
d384 1
a384 1
		bu_vls_strcat( str, "chars\n"); break;
d392 1
a392 1
		bu_vls_strcat( str, "unsigned chars\n"); break;
d400 2
@


1.3
log
@Massive compilation warnings eliminated
@
text
@d19 1
a19 1
static const char RCSell[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_bin.c,v 1.2 2000/07/08 01:20:56 mike Exp $ (BRL)";
d38 56
d185 3
d204 1
d220 1
@


1.2
log
@
Removed lint
@
text
@d19 1
a19 1
static const char RCSell[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_bin.c,v 1.1 2000/06/30 17:24:34 pjt Exp $ (BRL)";
d26 1
@


1.1
log
@Support for bulk binary objects
@
text
@d9 1
d19 1
a19 1
static char RCSell[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ell.c,v 11.20 2000/06/27 14:44:55 mike Exp $ (BRL)";
d181 1
d282 1
a282 1
		sprintf( buf, "%d ", bip->count ); break;
d284 1
a284 1
		sprintf( buf, "%d pairs of ", bip->count / 2 ); break;
d286 1
a286 1
		sprintf( buf, "%d triples of ", bip->count / 3 ); break;
d288 1
a288 1
		sprintf( buf, "%d quadruples of ", bip->count / 4 ); break;
@

