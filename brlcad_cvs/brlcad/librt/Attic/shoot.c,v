head	11.113;
access;
symbols
	ansi-20040405-merged:11.103.2.3
	postmerge-20040405-ansi:11.111
	premerge-20040404-ansi:11.110
	postmerge-autoconf:11.110
	autoconf-freeze:11.108.4.3
	premerge-autoconf:11.110
	ansi-20040316-freeze:11.103.2.1
	postmerge-20040315-windows:11.110
	premerge-20040315-windows:11.110
	windows-20040315-freeze:11.103.4.1
	autoconf-20031203:11.108.4.1
	autoconf-20031202:11.108
	autoconf-branch:11.108.0.4
	phong-branch:11.108.0.2
	photonmap-branch:11.106.0.2
	rel-6-1-DP:11.104
	windows-branch:11.103.0.4
	rel-6-0-2:11.101
	ansi-branch:11.103.0.2
	rel-6-0-1-branch:11.101.0.2
	hartley-6-0-post:11.102
	hartley-6-0-pre:11.101
	rel-6-0-1:11.101
	rel-6-0:11.101
	rel-5-4:11.85.2.1
	offsite-5-3-pre:11.94
	rel-5-3:11.85.2.1
	rel-5-2:11.85
	rel-5-1-branch:11.85.0.2
	rel-5-1:11.85
	rel-5-0:11.45
	rel-5-0-beta:11.45
	rel-4-5:11.42
	ctj-4-5-post:11.36
	ctj-4-5-pre:11.33
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.2
	rel-1-10:4.1
	rt-2:2.1;
locks; strict;
comment	@ * @;


11.113
date	2004.05.21.18.07.35;	author morrison;	state dead;
branches;
next	11.112;

11.112
date	2004.05.10.15.30.47;	author erikg;	state Exp;
branches;
next	11.111;

11.111
date	2004.04.05.08.48.58;	author morrison;	state Exp;
branches;
next	11.110;

11.110
date	2004.02.02.17.39.29;	author morrison;	state Exp;
branches;
next	11.109;

11.109
date	2003.10.29.15.54.22;	author jra;	state Exp;
branches;
next	11.108;

11.108
date	2003.07.11.14.16.20;	author jra;	state Exp;
branches
	11.108.4.1;
next	11.107;

11.107
date	2003.07.01.12.18.37;	author jra;	state Exp;
branches;
next	11.106;

11.106
date	2003.03.28.02.45.33;	author jra;	state Exp;
branches
	11.106.2.1;
next	11.105;

11.105
date	2003.01.20.02.06.59;	author jra;	state Exp;
branches;
next	11.104;

11.104
date	2002.10.19.01.54.15;	author jra;	state Exp;
branches;
next	11.103;

11.103
date	2002.08.20.17.08.09;	author jra;	state Exp;
branches
	11.103.2.1
	11.103.4.1;
next	11.102;

11.102
date	2002.08.15.20.55.21;	author hartley;	state Exp;
branches;
next	11.101;

11.101
date	2002.02.28.02.47.37;	author jra;	state Exp;
branches;
next	11.100;

11.100
date	2002.01.10.18.12.41;	author butler;	state Exp;
branches;
next	11.99;

11.99
date	2001.08.22.14.30.00;	author jra;	state Exp;
branches;
next	11.98;

11.98
date	2001.06.27.18.00.26;	author butler;	state Exp;
branches;
next	11.97;

11.97
date	2001.05.17.20.05.25;	author morrison;	state Exp;
branches;
next	11.96;

11.96
date	2001.05.16.21.38.04;	author morrison;	state Exp;
branches;
next	11.95;

11.95
date	2001.04.20.22.29.56;	author morrison;	state Exp;
branches;
next	11.94;

11.94
date	2000.11.01.06.46.13;	author mike;	state Exp;
branches;
next	11.93;

11.93
date	2000.09.20.03.44.26;	author mike;	state Exp;
branches;
next	11.92;

11.92
date	2000.09.20.03.25.09;	author mike;	state Exp;
branches;
next	11.91;

11.91
date	2000.09.08.05.54.42;	author mike;	state Exp;
branches;
next	11.90;

11.90
date	2000.08.29.22.21.58;	author mike;	state Exp;
branches;
next	11.89;

11.89
date	2000.08.29.22.08.29;	author mike;	state Exp;
branches;
next	11.88;

11.88
date	2000.08.29.21.54.47;	author mike;	state Exp;
branches;
next	11.87;

11.87
date	2000.07.12.04.21.17;	author cjohnson;	state Exp;
branches;
next	11.86;

11.86
date	2000.07.10.23.01.48;	author mike;	state Exp;
branches;
next	11.85;

11.85
date	2000.06.07.02.14.33;	author mike;	state Exp;
branches
	11.85.2.1;
next	11.84;

11.84
date	2000.06.07.02.05.48;	author mike;	state Exp;
branches;
next	11.83;

11.83
date	2000.06.07.01.28.54;	author mike;	state Exp;
branches;
next	11.82;

11.82
date	2000.06.07.00.51.36;	author mike;	state Exp;
branches;
next	11.81;

11.81
date	2000.06.07.00.37.19;	author mike;	state Exp;
branches;
next	11.80;

11.80
date	2000.06.07.00.06.45;	author mike;	state Exp;
branches;
next	11.79;

11.79
date	2000.05.24.05.48.59;	author mike;	state Exp;
branches;
next	11.78;

11.78
date	2000.05.24.01.00.08;	author mike;	state Exp;
branches;
next	11.77;

11.77
date	2000.05.23.03.00.55;	author mike;	state Exp;
branches;
next	11.76;

11.76
date	2000.05.22.16.02.49;	author bparker;	state Exp;
branches;
next	11.75;

11.75
date	2000.05.22.05.17.23;	author mike;	state Exp;
branches;
next	11.74;

11.74
date	2000.05.22.00.04.08;	author mike;	state Exp;
branches;
next	11.73;

11.73
date	2000.05.19.03.08.06;	author mike;	state Exp;
branches;
next	11.72;

11.72
date	2000.05.18.23.52.35;	author mike;	state Exp;
branches;
next	11.71;

11.71
date	2000.05.18.16.19.49;	author mike;	state Exp;
branches;
next	11.70;

11.70
date	2000.05.18.02.14.18;	author mike;	state Exp;
branches;
next	11.69;

11.69
date	2000.05.18.01.33.35;	author mike;	state Exp;
branches;
next	11.68;

11.68
date	2000.05.16.19.24.50;	author mike;	state Exp;
branches;
next	11.67;

11.67
date	2000.05.12.20.35.41;	author mike;	state Exp;
branches;
next	11.66;

11.66
date	2000.05.12.01.29.45;	author mike;	state Exp;
branches;
next	11.65;

11.65
date	2000.05.12.01.10.59;	author mike;	state Exp;
branches;
next	11.64;

11.64
date	2000.05.12.00.33.02;	author mike;	state Exp;
branches;
next	11.63;

11.63
date	2000.05.11.21.44.10;	author mike;	state Exp;
branches;
next	11.62;

11.62
date	2000.05.11.21.06.32;	author mike;	state Exp;
branches;
next	11.61;

11.61
date	2000.05.11.03.19.17;	author mike;	state Exp;
branches;
next	11.60;

11.60
date	2000.05.11.00.19.00;	author mike;	state Exp;
branches;
next	11.59;

11.59
date	2000.05.10.01.46.12;	author mike;	state Exp;
branches;
next	11.58;

11.58
date	2000.05.08.20.46.56;	author mike;	state Exp;
branches;
next	11.57;

11.57
date	2000.04.24.16.40.50;	author mike;	state Exp;
branches;
next	11.56;

11.56
date	2000.04.15.02.04.42;	author mike;	state Exp;
branches;
next	11.55;

11.55
date	2000.03.29.18.28.03;	author mike;	state Exp;
branches;
next	11.54;

11.54
date	2000.03.28.20.50.45;	author mike;	state Exp;
branches;
next	11.53;

11.53
date	2000.02.11.23.38.01;	author mike;	state Exp;
branches;
next	11.52;

11.52
date	2000.01.29.04.23.38;	author mike;	state Exp;
branches;
next	11.51;

11.51
date	2000.01.22.04.02.38;	author mike;	state Exp;
branches;
next	11.50;

11.50
date	99.12.23.06.00.35;	author mike;	state Exp;
branches;
next	11.49;

11.49
date	99.11.24.23.04.50;	author mike;	state Exp;
branches;
next	11.48;

11.48
date	99.11.02.02.30.36;	author mike;	state Exp;
branches;
next	11.47;

11.47
date	99.10.30.04.05.13;	author mike;	state Exp;
branches;
next	11.46;

11.46
date	99.10.28.03.33.36;	author mike;	state Exp;
branches;
next	11.45;

11.45
date	98.09.22.02.36.04;	author mike;	state Exp;
branches;
next	11.44;

11.44
date	98.04.15.06.13.52;	author mike;	state Exp;
branches;
next	11.43;

11.43
date	98.03.26.06.45.23;	author mike;	state Exp;
branches;
next	11.42;

11.42
date	98.01.22.04.47.32;	author mike;	state Exp;
branches;
next	11.41;

11.41
date	98.01.09.09.09.50;	author mike;	state Exp;
branches;
next	11.40;

11.40
date	97.12.16.00.14.40;	author mike;	state Exp;
branches;
next	11.39;

11.39
date	97.10.06.15.32.15;	author mike;	state Exp;
branches;
next	11.38;

11.38
date	97.09.18.20.32.45;	author jra;	state Exp;
branches;
next	11.37;

11.37
date	97.09.10.18.47.09;	author gdurf;	state Exp;
branches;
next	11.36;

11.36
date	97.09.04.21.21.32;	author gdurf;	state Exp;
branches;
next	11.35;

11.35
date	97.09.02.17.59.41;	author gdurf;	state Exp;
branches;
next	11.34;

11.34
date	97.08.29.00.56.11;	author gdurf;	state Exp;
branches;
next	11.33;

11.33
date	97.07.23.06.52.59;	author gdurf;	state Exp;
branches;
next	11.32;

11.32
date	97.07.23.03.37.00;	author mike;	state Exp;
branches;
next	11.31;

11.31
date	97.07.23.02.41.56;	author gdurf;	state Exp;
branches;
next	11.30;

11.30
date	97.07.16.19.55.04;	author gdurf;	state Exp;
branches;
next	11.29;

11.29
date	97.07.16.17.38.28;	author gdurf;	state Exp;
branches;
next	11.28;

11.28
date	97.07.15.17.21.23;	author gdurf;	state Exp;
branches;
next	11.27;

11.27
date	97.06.18.17.21.26;	author gdurf;	state Exp;
branches;
next	11.26;

11.26
date	97.06.13.02.51.43;	author gdurf;	state Exp;
branches;
next	11.25;

11.25
date	97.06.12.17.36.54;	author gdurf;	state Exp;
branches;
next	11.24;

11.24
date	97.06.12.15.27.51;	author gdurf;	state Exp;
branches;
next	11.23;

11.23
date	97.02.14.06.12.41;	author mike;	state Exp;
branches;
next	11.22;

11.22
date	97.01.30.01.45.39;	author mike;	state Exp;
branches;
next	11.21;

11.21
date	97.01.10.15.29.57;	author jra;	state Exp;
branches;
next	11.20;

11.20
date	96.11.22.08.49.41;	author mike;	state Exp;
branches;
next	11.19;

11.19
date	96.11.22.07.37.34;	author mike;	state Exp;
branches;
next	11.18;

11.18
date	96.09.27.08.32.21;	author mike;	state Exp;
branches;
next	11.17;

11.17
date	96.09.27.08.27.30;	author mike;	state Exp;
branches;
next	11.16;

11.16
date	96.08.31.04.20.54;	author mike;	state Exp;
branches;
next	11.15;

11.15
date	96.08.31.03.15.29;	author mike;	state Exp;
branches;
next	11.14;

11.14
date	96.08.29.06.34.21;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	96.08.28.10.03.46;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	96.08.28.04.02.56;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	96.08.27.02.42.09;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	96.08.27.02.29.24;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	96.08.27.02.25.16;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	96.06.14.12.25.45;	author jra;	state Exp;
branches;
next	11.7;

11.7
date	96.06.12.17.03.17;	author jra;	state Exp;
branches;
next	11.6;

11.6
date	96.06.12.13.34.02;	author jra;	state Exp;
branches;
next	11.5;

11.5
date	95.11.02.18.34.33;	author cjohnson;	state Exp;
branches;
next	11.4;

11.4
date	95.08.23.02.56.11;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	95.06.30.15.55.05;	author gdurf;	state Exp;
branches;
next	11.2;

11.2
date	95.06.16.17.29.09;	author pjt;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.58.37;	author mike;	state Rel4_4;
branches;
next	10.8;

10.8
date	94.12.27.18.42.54;	author mike;	state Exp;
branches;
next	10.7;

10.7
date	94.12.27.16.29.46;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	94.11.04.05.38.04;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	94.09.16.20.20.07;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	94.08.10.19.59.10;	author gdurf;	state Exp;
branches;
next	10.3;

10.3
date	94.05.06.03.39.40;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	93.03.02.17.29.18;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.41.00;	author mike;	state Rel4_0;
branches;
next	9.38;

9.38
date	91.10.01.02.47.28;	author mike;	state Exp;
branches;
next	9.37;

9.37
date	91.08.30.03.28.12;	author mike;	state Exp;
branches;
next	9.36;

9.36
date	91.07.25.06.04.32;	author butler;	state Exp;
branches;
next	9.35;

9.35
date	91.07.25.01.48.19;	author mike;	state Exp;
branches;
next	9.34;

9.34
date	91.07.24.22.59.52;	author mike;	state Exp;
branches;
next	9.33;

9.33
date	91.07.23.15.45.16;	author mike;	state Exp;
branches;
next	9.32;

9.32
date	91.06.29.21.40.31;	author mike;	state Exp;
branches;
next	9.31;

9.31
date	91.06.23.02.21.13;	author mike;	state Exp;
branches;
next	9.30;

9.30
date	91.06.23.02.16.08;	author mike;	state Exp;
branches;
next	9.29;

9.29
date	91.06.23.00.14.21;	author mike;	state Exp;
branches;
next	9.28;

9.28
date	91.06.22.22.30.49;	author mike;	state Exp;
branches;
next	9.27;

9.27
date	91.06.22.06.06.09;	author mike;	state Exp;
branches;
next	9.26;

9.26
date	91.06.22.06.04.19;	author mike;	state Exp;
branches;
next	9.25;

9.25
date	91.06.22.06.01.09;	author mike;	state Exp;
branches;
next	9.24;

9.24
date	91.06.22.05.23.21;	author mike;	state Exp;
branches;
next	9.23;

9.23
date	91.06.22.05.19.18;	author mike;	state Exp;
branches;
next	9.22;

9.22
date	91.06.04.22.59.27;	author mike;	state Exp;
branches;
next	9.21;

9.21
date	91.05.18.03.03.39;	author mike;	state Exp;
branches;
next	9.20;

9.20
date	91.05.16.23.11.21;	author mike;	state Exp;
branches;
next	9.19;

9.19
date	91.03.15.23.13.47;	author mike;	state Exp;
branches;
next	9.18;

9.18
date	91.03.13.20.59.21;	author mike;	state Exp;
branches;
next	9.17;

9.17
date	91.01.25.16.05.29;	author mike;	state Exp;
branches;
next	9.16;

9.16
date	90.12.26.20.34.42;	author mike;	state Exp;
branches;
next	9.15;

9.15
date	90.12.26.20.21.41;	author mike;	state Exp;
branches;
next	9.14;

9.14
date	90.12.22.02.25.43;	author mike;	state Exp;
branches;
next	9.13;

9.13
date	90.12.19.06.21.08;	author mike;	state Exp;
branches;
next	9.12;

9.12
date	90.10.07.21.35.05;	author mike;	state Exp;
branches;
next	9.11;

9.11
date	90.10.07.19.05.47;	author mike;	state Exp;
branches;
next	9.10;

9.10
date	90.10.06.02.05.42;	author mike;	state Exp;
branches;
next	9.9;

9.9
date	90.10.05.19.56.11;	author mike;	state Exp;
branches;
next	9.8;

9.8
date	90.01.11.06.45.43;	author mike;	state Exp;
branches;
next	9.7;

9.7
date	90.01.06.04.51.53;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	90.01.06.04.50.14;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	90.01.06.04.17.14;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	89.12.31.07.44.10;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	89.12.30.05.20.12;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	89.05.30.07.53.27;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.57.05;	author mike;	state Rel3_5;
branches
	9.1.1.1;
next	8.4;

8.4
date	89.05.05.01.58.12;	author mike;	state Exp;
branches;
next	8.3;

8.3
date	89.04.13.05.21.27;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	89.04.03.21.38.29;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.31.39;	author mike;	state Rel3_0;
branches;
next	7.8;

7.8
date	88.09.17.07.45.14;	author mike;	state Exp;
branches;
next	7.7;

7.7
date	88.08.20.07.01.44;	author mike;	state Exp;
branches;
next	7.6;

7.6
date	88.08.20.00.45.45;	author mike;	state Exp;
branches;
next	7.5;

7.5
date	88.08.09.04.54.31;	author phil;	state Exp;
branches;
next	7.4;

7.4
date	88.06.22.01.09.30;	author mike;	state Exp;
branches;
next	7.3;

7.3
date	88.01.23.05.21.16;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	88.01.22.22.54.15;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.34.05;	author mike;	state Rel;
branches;
next	6.3;

6.3
date	87.10.20.00.01.25;	author mike;	state Exp;
branches;
next	6.2;

6.2
date	87.09.17.07.01.22;	author mike;	state Exp;
branches;
next	6.1;

6.1
date	87.07.11.07.56.24;	author mike;	state Rel;
branches;
next	5.2;

5.2
date	87.07.08.00.59.59;	author mike;	state Exp;
branches;
next	5.1;

5.1
date	87.06.24.22.12.14;	author mike;	state Rel;
branches;
next	4.5;

4.5
date	87.04.10.13.11.18;	author moss;	state Exp;
branches;
next	4.4;

4.4
date	87.03.23.23.41.32;	author mike;	state Exp;
branches;
next	4.3;

4.3
date	87.03.10.23.43.33;	author mike;	state Exp;
branches;
next	4.2;

4.2
date	87.02.12.22.11.48;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.45.51;	author mike;	state Rel1;
branches;
next	3.16;

3.16
date	86.12.26.18.39.19;	author mike;	state Exp;
branches;
next	3.15;

3.15
date	86.12.24.08.06.03;	author mike;	state Exp;
branches;
next	3.14;

3.14
date	86.12.13.05.42.06;	author mike;	state Exp;
branches;
next	3.13;

3.13
date	86.11.07.00.51.59;	author mike;	state Exp;
branches;
next	3.12;

3.12
date	86.11.07.00.40.29;	author mike;	state Exp;
branches;
next	3.11;

3.11
date	86.08.12.04.16.20;	author mike;	state Exp;
branches;
next	3.10;

3.10
date	86.08.09.02.17.41;	author mike;	state Exp;
branches;
next	3.9;

3.9
date	86.07.31.03.20.30;	author mike;	state Exp;
branches;
next	3.8;

3.8
date	86.07.30.00.45.23;	author mike;	state Exp;
branches;
next	3.7;

3.7
date	86.07.29.03.11.00;	author mike;	state Exp;
branches;
next	3.6;

3.6
date	86.07.29.01.49.35;	author mike;	state Exp;
branches;
next	3.5;

3.5
date	86.07.24.06.20.41;	author mike;	state Exp;
branches;
next	3.4;

3.4
date	86.07.22.04.20.20;	author mike;	state Exp;
branches;
next	3.3;

3.3
date	86.07.22.03.21.05;	author mike;	state Exp;
branches;
next	3.2;

3.2
date	86.07.19.04.42.45;	author mike;	state Exp;
branches;
next	3.1;

3.1
date	86.07.11.01.32.35;	author mike;	state Exp;
branches;
next	3.0;

3.0
date	86.06.10.01.33.39;	author mike;	state Exp;
branches;
next	2.10;

2.10
date	86.06.09.21.50.53;	author mike;	state Exp;
branches;
next	2.9;

2.9
date	86.05.29.01.48.31;	author mike;	state Exp;
branches;
next	2.8;

2.8
date	86.03.14.21.07.09;	author mike;	state Exp;
branches;
next	2.7;

2.7
date	86.02.21.16.49.43;	author mike;	state Exp;
branches;
next	2.6;

2.6
date	86.01.24.11.54.23;	author mike;	state Exp;
branches;
next	2.5;

2.5
date	85.09.18.01.29.11;	author mike;	state Exp;
branches;
next	2.4;

2.4
date	85.09.14.05.27.47;	author mike;	state Exp;
branches;
next	2.3;

2.3
date	85.09.11.01.03.25;	author mike;	state Exp;
branches;
next	2.2;

2.2
date	85.09.05.02.20.14;	author mike;	state Exp;
branches;
next	2.1;

2.1
date	85.08.31.06.06.16;	author mike;	state Exp;
branches;
next	1.22;

1.22
date	85.07.30.05.55.14;	author mike;	state Exp;
branches;
next	1.21;

1.21
date	85.06.07.01.42.29;	author mike;	state Exp;
branches;
next	1.20;

1.20
date	85.06.05.00.24.26;	author mike;	state Exp;
branches;
next	1.19;

1.19
date	85.06.04.23.24.32;	author mike;	state Exp;
branches;
next	1.18;

1.18
date	85.05.29.00.15.19;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	85.05.01.16.16.54;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	85.03.25.11.46.55;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	85.02.01.22.13.25;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	85.01.31.21.11.42;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	84.11.30.04.04.18;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	84.11.29.07.03.34;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	84.11.27.07.01.42;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	84.11.24.03.03.25;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	84.11.23.20.54.33;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	84.11.20.20.14.48;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	84.11.16.06.29.12;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	84.11.15.21.48.04;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	84.10.19.01.38.32;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	84.10.19.00.07.57;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	84.08.28.03.08.31;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	84.08.21.01.19.27;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	84.05.04.09.11.44;	author mike;	state Exp;
branches;
next	;

9.1.1.1
date	91.03.15.23.16.06;	author mike;	state Exp;
branches;
next	;

11.85.2.1
date	2000.11.01.18.43.54;	author jra;	state Exp;
branches;
next	;

11.103.2.1
date	2002.09.19.18.01.46;	author morrison;	state Exp;
branches;
next	11.103.2.2;

11.103.2.2
date	2004.03.17.21.18.59;	author morrison;	state Exp;
branches;
next	11.103.2.3;

11.103.2.3
date	2004.04.01.04.18.58;	author morrison;	state Exp;
branches;
next	;

11.103.4.1
date	2004.03.11.23.43.46;	author morrison;	state Exp;
branches;
next	;

11.106.2.1
date	2003.08.26.14.03.36;	author justin;	state Exp;
branches;
next	;

11.108.4.1
date	2003.12.03.16.24.07;	author erikg;	state Exp;
branches;
next	11.108.4.2;

11.108.4.2
date	2004.02.12.18.37.47;	author erikg;	state Exp;
branches;
next	11.108.4.3;

11.108.4.3
date	2004.03.15.14.07.29;	author erikg;	state Exp;
branches;
next	;


desc
@Pruning code to manage shots into the model.
@


11.113
log
@moved to src/
@
text
@/*
 *			S H O O T . C
 *
 *	Ray Tracing program shot coordinator.
 *
 *  This is the heart of LIBRT's ray-tracing capability.
 *  
 *  Given a ray, shoot it at all the relevant parts of the model,
 *  (building the finished_segs chain), and then call rt_boolregions()
 *  to build and evaluate the partition chain.
 *  If the ray actually hit anything, call the application's
 *  a_hit() routine with a pointer to the partition chain,
 *  otherwise, call the application's a_miss() routine.
 *
 *  It is important to note that rays extend infinitely only in the
 *  positive direction.  The ray is composed of all points P, where
 *
 *	P = r_pt + K * r_dir
 *
 *  for K ranging from 0 to +infinity.  There is no looking backwards.
 *
 *  Authors -
 *	Michael John Muuss
 *	Glenn Durfee
 *
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" license agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 2000-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */
#ifndef lint
static const char RCSshoot[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/shoot.c,v 11.112 2004/05/10 15:30:47 erikg Exp $ (BRL)";
#endif

char rt_CopyRight_Notice[] = "@@(#) Copyright (C) 1985,1991,2000 by the United States Army";

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#ifdef HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include "machine.h"
#include "vmath.h"
#include "bu.h"
#include "raytrace.h"
#include "plot3.h"
#include "./debug.h"

struct resource rt_uniresource;		/* Resources for uniprocessor */

extern void	rt_plot_cell(const union cutter *cutp, const struct rt_shootray_status *ssp, struct bu_list *waiting_segs_hd, struct rt_i *rtip);		/* at end of file */
		
#define V3PT_DEPARTING_RPP(_step, _lo, _hi, _pt ) \
		PT_DEPARTING_RPP(_step, _lo, _hi, (_pt)[X], (_pt)[Y], (_pt)[Z] )
#define PT_DEPARTING_RPP(_step, _lo, _hi, _px, _py, _pz ) \
		(   ((_step)[X] <= 0 && (_px) < (_lo)[X]) || \
		    ((_step)[X] >= 0 && (_px) > (_hi)[X]) || \
		    ((_step)[Y] <= 0 && (_py) < (_lo)[Y]) || \
		    ((_step)[Y] >= 0 && (_py) > (_hi)[Y]) || \
		    ((_step)[Z] <= 0 && (_pz) < (_lo)[Z]) || \
		    ((_step)[Z] >= 0 && (_pz) > (_hi)[Z])   )

/*
 *			R T _ R E S _ P I E C E S _ I N I T
 *
 *  Allocate the per-processor state variables needed
 *  to support rt_shootray()'s use of 'solid pieces'.
 */
void
rt_res_pieces_init(struct resource *resp, struct rt_i *rtip)
{
	struct rt_piecestate	*psptab;
	struct rt_piecestate	*psp;
	struct soltab		*stp;

	RT_CK_RESOURCE(resp);
	RT_CK_RTI(rtip);

	psptab = bu_calloc( sizeof(struct rt_piecestate),
		rtip->rti_nsolids_with_pieces, "re_pieces[]" );
	resp->re_pieces = psptab;

	RT_VISIT_ALL_SOLTABS_START( stp, rtip )  {
		RT_CK_SOLTAB(stp);
		if( stp->st_npieces <= 1 )  continue;
		psp = &psptab[stp->st_piecestate_num];
		psp->magic = RT_PIECESTATE_MAGIC;
		psp->stp = stp;
		psp->shot = bu_bitv_new(stp->st_npieces);
		rt_htbl_init( &psp->htab, 8, "psp->htab" );
		psp->cutp = CUTTER_NULL;
	} RT_VISIT_ALL_SOLTABS_END
}

/*
 *			R T _ R E S _ P I E C E S _ C L E A N
 */
void
rt_res_pieces_clean(struct resource *resp, struct rt_i *rtip)
{
	struct rt_piecestate	*psp;
	int			i;

	RT_CK_RESOURCE(resp);
	RT_CK_RTI(rtip);

	if( !resp->re_pieces ) {
		rtip->rti_nsolids_with_pieces = 0;
		return;
	}
	for( i = rtip->rti_nsolids_with_pieces-1; i >= 0; i-- )  {
		psp = &resp->re_pieces[i];
		RT_CK_PIECESTATE(psp);
		rt_htbl_free(&psp->htab);
		bu_bitv_free(psp->shot);
		psp->shot = NULL;	/* sanity */
		psp->magic = 0;
	}
	bu_free( (char *)resp->re_pieces, "re_pieces[]" );
	resp->re_pieces = NULL;

	bu_ptbl_free( &resp->re_pieces_pending );

	rtip->rti_nsolids_with_pieces = 0;
}

/*
 *			R T _ F I N D _ N U G R I D
 *
 *  Along the given axis, find which NUgrid cell this value lies in.
 *  Use method of binary subdivision.
 */
int
rt_find_nugrid(const struct nugridnode *nugnp, int axis, fastf_t val)
{
	int	min;
	int	max;
	int	lim = nugnp->nu_cells_per_axis[axis]-1;
	int	cur;

	if( val < nugnp->nu_axis[axis][0].nu_spos ||
	    val > nugnp->nu_axis[axis][lim].nu_epos )
		return -1;

	min = 0;
	max = lim;
again:
	cur = (min + max) / 2;

	if( cur <= 0 )  return 0;
	if( cur >= lim )  return lim;

	if( val < nugnp->nu_axis[axis][cur].nu_spos )  {
		max = cur;
		goto again;
	}
	if( val > nugnp->nu_axis[axis][cur+1].nu_epos )  {
		min = cur+1;
		goto again;
	}
	if( val < nugnp->nu_axis[axis][cur].nu_epos )
		return cur;
	else
		return cur+1;
}


/*
 *			R T _ A D V A N C E _ T O _ N E X T _ C E L L
 */

const union cutter *
rt_advance_to_next_cell(register struct rt_shootray_status *ssp)
{
	register const union cutter		*cutp, *curcut = ssp->curcut;
	register const struct application	*ap = ssp->ap;
	register fastf_t			t0, px, py, pz;
	int					push_flag = 0;
	double					fraction;
	int					exponent;

	ssp->box_num++;

	if( curcut == &ssp->ap->a_rt_i->rti_inf_box )  {
		/* Last pass did the infinite solids, there is nothing more */
		ssp->curcut = CUTTER_NULL;
		return CUTTER_NULL;
	}

#if EXTRA_SAFETY	
	if( curcut == CUTTER_NULL ) {
		bu_log(
		   "rt_advance_to_next_cell: warning: ssp->curcut not set\n" );
		ssp->curcut = curcut = &ap->a_rt_i->rti_CutHead;
	}
#endif	

	for( ;; ) {
		/* Set cutp to CUTTER_NULL.  If it fails to become set in the
		   following switch statement, we know that we have exited the
		   subnode.  If this subnode is the highest-level node, then
		   we are done advancing the ray through the model. */
		cutp = CUTTER_NULL;
		push_flag = 0;

		/*
		 *  The point corresponding to the box_start distance
		 *  may not be in the "right" place,
		 *  due to the effects of floating point fuzz:
		 *  1)  The point might lie just outside
		 *	the model RPP, resulting in the point not
		 *	falling within the RPP of the indicated cell,
		 *	or
		 *  2)	The poing might lie just a little bit on the
		 *	wrong side of the cell wall, resulting in
		 *	the ray getting "stuck", and needing rescuing
		 *	all the time by the error recovery code below.
		 *  Therefore, "nudge" the point just slightly into the
		 *  next cell by adding OFFSET_DIST.
		 *  XXX At present, a cell is never less than 1mm wide.
		 *  XXX The value of OFFSET_DIST should be some
		 *	percentage of the cell's smallest dimension,
		 *	rather than an absolute distance in mm.
		 *	This will prevent doing microscopic models.
		 */
		t0 = ssp->box_start;
		/* NB: can't compute px,py,pz here since t0 may advance
		   in the following statement! */
		
top:		switch( curcut->cut_type ) {
		case CUT_NUGRIDNODE: {
			/*
			 ****************************************************************************************
			 *
			 *  This portion implements Gigante's non-uniform 3-D space grid/mesh discretization.
			 *
			 ****************************************************************************************
			 */
			register int out_axis;
			register const struct nu_axis  **nu_axis =
			     (const struct nu_axis **)&curcut->nugn.nu_axis[0];
			register const int		*nu_stepsize =
			     &curcut->nugn.nu_stepsize[0];
			register const int	        *nu_cells_per_axis =
			     &curcut->nugn.nu_cells_per_axis[0];
			register const union cutter	*nu_grid =
			     curcut->nugn.nu_grid;

			if( ssp->lastcell == CUTTER_NULL ) {
				/* We have just started into this NUgrid.  We
				   must find our location and set up the
				   NUgrid traversal state variables. */
				register int x, y, z;
				
				px = ap->a_ray.r_pt[X] + t0*ap->a_ray.r_dir[X];
				py = ap->a_ray.r_pt[Y] + t0*ap->a_ray.r_dir[Y];
				pz = ap->a_ray.r_pt[Z] + t0*ap->a_ray.r_dir[Z];

				/* Must find cell that contains newray.r_pt.
				   We do this by binary subdivision.
				   If any are out of bounds, we have left the
				   NUgrid and will pop a level off the stack
				   in the outer loop (if applicable).  */
				x = rt_find_nugrid( &curcut->nugn, X, px );
				if( x<0 ) break;
				y = rt_find_nugrid( &curcut->nugn, Y, py );
				if( y<0 ) break;
				z = rt_find_nugrid( &curcut->nugn, Z, pz );
				if( z<0 ) break;

				cutp = &nu_grid[z*nu_stepsize[Z] +
					        y*nu_stepsize[Y] +
					        x*nu_stepsize[X]];

				ssp->igrid[X] = x;
				ssp->igrid[Y] = y;
				ssp->igrid[Z] = z;
			
				NUGRID_T_SETUP( X, px, x );
				NUGRID_T_SETUP( Y, py, y );
				NUGRID_T_SETUP( Z, pz, z );
			} else {
				/* Advance from previous cell to next cell */
				/* Take next step, finding ray entry distance*/
				cutp = ssp->lastcell;
				out_axis = ssp->out_axis;

				/* We may be simply advancing to the next box
				   in the *same* NUgrid cell (if, for instance,
				   the NUgrid cell is a cutnode with
				   boxnode leaves).  So if t0 hasn't advanced
				   past the end of the box, advance
				   a tiny bit (less than rt_ct_optim makes
				   boxnodes) and be handled by tree-traversing
				   code below. */

				if( cutp->cut_type == CUT_CUTNODE &&
				    t0 + OFFSET_DIST < ssp->tv[out_axis] ) {
					t0 += OFFSET_DIST;
					break;
				}

				/* Advance to the next cell as appropriate,
				   bailing out with cutp=CUTTER_NULL
				   if we run past the end of the NUgrid
				   array. */
					
again:				t0 = ssp->tv[out_axis];
				if( ssp->rstep[out_axis] > 0 ) {
					if( ++(ssp->igrid[out_axis]) >=
					    nu_cells_per_axis[out_axis] ) {
						cutp = CUTTER_NULL;
						break;
					}
					cutp += nu_stepsize[out_axis];
				} else {
					if( --(ssp->igrid[out_axis]) < 0 ) {
						cutp = CUTTER_NULL;
						break;
					}
					cutp -= nu_stepsize[out_axis];
				}

				/* Update t advancement value for this axis */
				NUGRID_T_ADV( out_axis, ssp->igrid[out_axis] );
			}
			
			/* find minimum exit t value */
			if( ssp->tv[X] < ssp->tv[Y] )  {
				if( ssp->tv[Z] < ssp->tv[X] )  {
					out_axis = Z;
				} else {
					out_axis = X;
				}
			} else {
				if( ssp->tv[Z] < ssp->tv[Y] )  {
					out_axis = Z;
				} else {
					out_axis = Y;
				}
			}

			/* Zip through empty cells. */
			if( cutp->cut_type == CUT_BOXNODE &&
			    cutp->bn.bn_len <= 0 &&
			    cutp->bn.bn_piecelen <= 0 ) {
				++ssp->resp->re_nempty_cells;
				goto again;
			}

			ssp->out_axis = out_axis;
			ssp->lastcell = cutp;
			
			if( RT_G_DEBUG&DEBUG_ADVANCE )
				bu_log( "t0=%g found in cell (%d,%d,%d), out_axis=%c at %g; cell is %s\n",
					t0,
					ssp->igrid[X], ssp->igrid[Y],
					ssp->igrid[Z],
					"XYZ*"[ssp->out_axis],
					ssp->tv[out_axis],
					cutp->cut_type==CUT_CUTNODE?"cut":
					cutp->cut_type==CUT_BOXNODE?"box":
					cutp->cut_type==CUT_NUGRIDNODE?"nu":
					"?" );
			break; }
		case CUT_CUTNODE:
			/* fall through */
		case CUT_BOXNODE:
			/*
			 ****************************************************************************************
			 *
			 *  This portion implements Muuss' non-uniform binary space partitioning tree.
			 *
			 ****************************************************************************************
			 */
			t0 += OFFSET_DIST;
			cutp = curcut;
			break;
		default:
			rt_bomb(
		       "rt_advance_to_next_cell: unknown high-level cutnode" );
		}

		if( cutp==CUTTER_NULL ) {
pop_space_stack:
			/*
			 *  Pop the stack of nested space partitioning methods.
			 *  Move up out of the current node, or return if there
			 *  is nothing left to do.
			 */
			{
				register struct rt_shootray_status *old = ssp->old_status;

				if( old == NULL ) goto escaped_from_model;
				*ssp = *old;		/* struct copy */
				bu_free( old, "old rt_shootray_status" );
				curcut = ssp->curcut;
				cutp = CUTTER_NULL;
				continue;
			}
		}

		/* Compute position and bail if we're outside of the current level. */
		px = ap->a_ray.r_pt[X] + t0*ap->a_ray.r_dir[X];
		py = ap->a_ray.r_pt[Y] + t0*ap->a_ray.r_dir[Y];
		pz = ap->a_ray.r_pt[Z] + t0*ap->a_ray.r_dir[Z];

		/* Optimization: when it's a boxnode in a nugrid, just return. */
		if( cutp->cut_type == CUT_BOXNODE &&
		    curcut->cut_type == CUT_NUGRIDNODE ) {
			ssp->newray.r_pt[X] = px;
			ssp->newray.r_pt[Y] = py;
			ssp->newray.r_pt[Z] = pz;
			ssp->newray.r_min = 0;
			ssp->newray.r_max = ssp->tv[ssp->out_axis] - t0;
			goto done_return_cutp;
		}

		/*  Given direction of travel, see if point is outside bound.
		 *  This will be the model RPP for NUBSP.
		 */
		if( PT_DEPARTING_RPP( ssp->rstep, ssp->curmin, ssp->curmax, px, py, pz ) )
			goto pop_space_stack;
		
		if( RT_G_DEBUG&DEBUG_ADVANCE ) {
			bu_log(
	           "rt_advance_to_next_cell() dist_corr=%g, pt=(%g, %g, %g)\n",
				t0 /*ssp->dist_corr*/, px, py, pz );
		}

		while( cutp->cut_type == CUT_CUTNODE ) {
			switch( cutp->cn.cn_axis )  {
			case X:
				if( px >= cutp->cn.cn_point )  {
					cutp=cutp->cn.cn_r;
				}  else  {
					cutp=cutp->cn.cn_l;
				}
				break;
			case Y:
				if( py >= cutp->cn.cn_point )  {
					cutp=cutp->cn.cn_r;
				}  else  {
					cutp=cutp->cn.cn_l;
				}
				break;
			case Z:
				if( pz >= cutp->cn.cn_point )  {
					cutp=cutp->cn.cn_r;
				}  else  {
					cutp=cutp->cn.cn_l;
				}
				break;
			}
		}

		if( cutp == CUTTER_NULL )
			rt_bomb( "rt_advance_to_next_cell: leaf is NULL!" );

		switch( cutp->cut_type ) {
		case CUT_BOXNODE:
			if( RT_G_DEBUG&DEBUG_ADVANCE && 
			    PT_DEPARTING_RPP( ssp->rstep, ssp->curmin, ssp->curmax, px, py, pz )
			) {
				/* This cell is old news. */
				bu_log(
	  "rt_advance_to_next_cell(): point not in cell, advancing\n   pt (%.20e,%.20e,%.20e)\n",
					px, py, pz );
				bu_log(	"  min (%.20e,%.20e,%.20e)\n",
					V3ARGS(cutp->bn.bn_min) );
				bu_log( "  max (%.20e,%.20e,%.20e)\n",
					V3ARGS(cutp->bn.bn_max) );
				bu_log( "pt=(%g,%g,%g)\n",px, py, pz );
				rt_pr_cut( cutp, 0 );

				/*
				 * Move newray point further into new box.
				 * Try again.
				 */
				t0 += OFFSET_DIST;
				goto top;
			}
			/* Don't get stuck within the same box for long */
			if( cutp==ssp->lastcut ) {
				fastf_t	delta;
push_to_next_box:				;	
				if( RT_G_DEBUG & DEBUG_ADVANCE ) {
					bu_log(
						"%d,%d box push odist_corr=%.20e n=%.20e model_end=%.20e\n",
						ap->a_x, ap->a_y,
						ssp->odist_corr,
						t0 /*ssp->dist_corr*/,
						ssp->model_end );
					bu_log(
						"box_start o=%.20e n=%.20e\nbox_end   o=%.20e n=%.20e\n",
						ssp->obox_start,
						ssp->box_start,
						ssp->obox_end,
						ssp->box_end );
					bu_log( "Point=(%g,%g,%g)\n",
						px, py, pz );
					VPRINT( "Dir",
						ssp->newray.r_dir );
					rt_pr_cut( cutp, 0 );
				}

				/* Advance 1mm, or smallest value that hardware
				 * floating point resolution will allow.
				 */
				fraction = frexp( ssp->box_end,
						  &exponent );

				if( RT_G_DEBUG & DEBUG_ADVANCE ) {
					bu_log(
						"exp=%d, fraction=%.20e\n",
						exponent, fraction );
				}
				if( sizeof(fastf_t) <= 4 )
					fraction += 1.0e-5;
				else
					fraction += 1.0e-14;
				delta = ldexp( fraction, exponent );
				if( RT_G_DEBUG & DEBUG_ADVANCE ) {
					bu_log(
						"ldexp: delta=%g, fract=%g, exp=%d\n",
						delta,
						fraction,
						exponent );
				}

				/* Never advance less than 1mm */
				if( delta < 1 ) delta = 1.0;
				ssp->box_start = ssp->box_end + delta;
				ssp->box_end = ssp->box_start + delta;
				
				if( RT_G_DEBUG & DEBUG_ADVANCE ) {
					bu_log(
						"push%d: was=%.20e, now=%.20e\n\n",
						push_flag,
						ssp->box_end,
						ssp->box_start );
				}
				push_flag++;
				if( push_flag > 3 ) {
					bu_log( "rt_advance_to_next_cell(): INTERNAL ERROR: infinite loop aborted, ray %d,%d truncated\n",
						ap->a_x, ap->a_y );
					goto pop_space_stack;
				}
				/* See if point marched outside model RPP */
				if( ssp->box_start > ssp->model_end )
					goto pop_space_stack;
				t0 = ssp->box_start + OFFSET_DIST;
				goto top;
			}
			if( push_flag ) {
				push_flag = 0;
				if( RT_G_DEBUG & DEBUG_ADVANCE ) {
					bu_log(
						"%d,%d Escaped %d. dist_corr=%g, box_start=%g, box_end=%g\n",
						ap->a_x, ap->a_y,
						push_flag,
						t0 /*ssp->dist_corr*/,
						ssp->box_start,
						ssp->box_end );
				}
			}
			if( RT_G_DEBUG & DEBUG_ADVANCE ) {
				bu_log(
					"rt_advance_to_next_cell()=x%x lastcut=x%x\n",
					cutp, ssp->lastcut);
			}

			ssp->newray.r_pt[X] = px;
			ssp->newray.r_pt[Y] = py;
			ssp->newray.r_pt[Z] = pz;
			if( !rt_in_rpp( &ssp->newray, ssp->inv_dir,
					cutp->bn.bn_min,
					cutp->bn.bn_max) )  {
				bu_log("rt_advance_to_next_cell():  MISSED BOX\nrmin,rmax(%.20e,%.20e) box(%.20e,%.20e)\n",
				       ssp->newray.r_min,
				       ssp->newray.r_max,
				       ssp->box_start, ssp->box_end );
				goto push_to_next_box;
			}

done_return_cutp:	ssp->lastcut = cutp;
#if EXTRA_SAFETY
			/* Diagnostic purposes only */
			ssp->odist_corr = ssp->dist_corr;
			ssp->obox_start = ssp->box_start;
			ssp->obox_end = ssp->box_end;
#endif			
			ssp->dist_corr = t0;
			ssp->box_start = t0 + ssp->newray.r_min;
			ssp->box_end = t0 + ssp->newray.r_max;
			if( RT_G_DEBUG & DEBUG_ADVANCE )  {
				bu_log(
				"rt_advance_to_next_cell() box=(%g, %g)\n",
					ssp->box_start, ssp->box_end );
			}
			return cutp;
		case CUT_NUGRIDNODE: {
			struct rt_shootray_status *old;

			BU_GETSTRUCT( old, rt_shootray_status );
			*old = *ssp;	/* struct copy */

			/* Descend into node */
			ssp->old_status = old;
			ssp->lastcut = ssp->lastcell = CUTTER_NULL;
			curcut = ssp->curcut = cutp;
			VSET( ssp->curmin, cutp->nugn.nu_axis[X][0].nu_spos,
					   cutp->nugn.nu_axis[Y][0].nu_spos,
					   cutp->nugn.nu_axis[Z][0].nu_spos );
			VSET( ssp->curmax, ssp->curcut->nugn.nu_axis[X][ssp->curcut->nugn.nu_cells_per_axis[X]-1].nu_epos,
				 ssp->curcut->nugn.nu_axis[Y][ssp->curcut->nugn.nu_cells_per_axis[Y]-1].nu_epos,
				 ssp->curcut->nugn.nu_axis[Z][ssp->curcut->nugn.nu_cells_per_axis[Z]-1].nu_epos );
			break; }	
		case CUT_CUTNODE:
			rt_bomb( "rt_advance_to_next_cell: impossible: cutnote as leaf!" );
			break;
		default:
			rt_bomb( "rt_advance_to_next_cell: unknown spt node" );
			break;
		}			

		/* Continue with the current space partitioning algorithm. */
	}
	/* NOTREACHED */
	/*	bu_bomb("rt_advance_to_next_cell: escaped for(;;) loop: impossible!"); */

	/*
	 *  If ray has escaped from model RPP, and there are infinite solids
	 *  in the model, there is one more (special) BOXNODE for the
	 *  caller to process.
	 */
escaped_from_model:
	curcut = &ssp->ap->a_rt_i->rti_inf_box;
	if( curcut->bn.bn_len <= 0 && curcut->bn.bn_piecelen <= 0 )
		curcut = CUTTER_NULL;
	ssp->curcut = curcut;
	return curcut;
}

/*		R T _ F I N D _ B A C K I N G _ D I S T
 *
 *	This routine traces a ray from its start point to model exit through the space partitioning tree.
 *	The objective is to find all primitives that use "pieces" and also have a bounding box that
 *	extends behind the ray start point. The minimum (most negative) intersection with such a bounding
 *	box is returned. The "backbits" bit vector (provided by the caller) gets a bit set for every
 *	primitive that meets the above criteria.
 *	No primitive intersections are performed.
 *
 *	XXXX This routine does not work for NUGRID XXXX
 */
fastf_t
rt_find_backing_dist( struct rt_shootray_status *ss, struct bu_bitv *backbits ) {
	fastf_t min_backing_dist=BACKING_DIST;
	fastf_t cur_dist=0.0;
	point_t cur_pt;
	union cutter *cutp;
	struct bu_bitv *solidbits;
	struct xray ray;
	struct resource	*resp;
	struct rt_i *rtip;
	int i;

	resp = ss->ap->a_resource;
	rtip = ss->ap->a_rt_i;

	/* get a bit vector of our own to avoid duplicate bounding box intersection calculations */
	solidbits = get_solidbitv( rtip->nsolids, resp );
	bu_bitv_clear(solidbits);

	ray = ss->ap->a_ray;	/* struct copy, don't mess with the original */

	/* cur_dist keeps track of where we are along the ray */
	/* stop when cur_dist reaches far intersection of ray and model bounding box */
	while( cur_dist <= ss->ap->a_ray.r_max ) {
		/* calculate the current point along the ray */
		VJOIN1( cur_pt, ss->ap->a_ray.r_pt, cur_dist, ss->ap->a_ray.r_dir );

		/* descend into the space partitioning tree based on this point */
		cutp = &ss->ap->a_rt_i->rti_CutHead;
		while( cutp->cut_type == CUT_CUTNODE ) {
			if( cur_pt[cutp->cn.cn_axis] >= cutp->cn.cn_point )  {
				cutp=cutp->cn.cn_r;
			}  else  {
				cutp=cutp->cn.cn_l;
			}
		}

		/* we are now at the box node for the current point */
		/* check if the ray intersects this box */
		if( !rt_in_rpp( &ray, ss->inv_dir, cutp->bn.bn_min, cutp->bn.bn_max ) ) {
			/* ray does not intersect this cell
			 * one of two situations must exist:
			 *	1. ray starts outside model bounding box (no need for these calculations)
			 *	2. we have proceeded beyond end of model bounding box (we are done)
			 * in either case, we are finished
			 */
			goto done;
		} else {
			/* increment cur_dist into next cell for next execution of this loop */
			cur_dist = ray.r_max + OFFSET_DIST;
		}

		/* process this box node (look at all the pieces) */
		for( i=0 ; i<cutp->bn.bn_piecelen ; i++ ) {
			struct rt_piecelist *plp=&cutp->bn.bn_piecelist[i];

			if( BU_BITTEST( solidbits, plp->stp->st_bit ) == 0 ) {
				/* we haven't looked at this primitive before */
				if( rt_in_rpp( &ray, ss->inv_dir, plp->stp->st_min, plp->stp->st_max ) ) {
					/* ray intersects this primitive bounding box */

					if( ray.r_min < BACKING_DIST ) {
						if( ray.r_min < min_backing_dist ) {
							/* move our backing distance back to catch this one */
							min_backing_dist = ray.r_min;
						}

						/* add this one to our list of primitives to check */
						BU_BITSET( backbits, plp->stp->st_bit );
					}
				}
				/* set bit so we don't repeat this calculation */
				BU_BITSET( solidbits, plp->stp->st_bit );
			}
		}
	}
 done:
	/* put our bit vector on the resource list */
	BU_CK_BITV(solidbits);
	BU_LIST_APPEND( &resp->re_solid_bitv, &solidbits->l );

	/* return our minimum backing distance */
	return min_backing_dist;
}

/*
 *			R T _ S H O O T R A Y
 *
 *  Note that the direction vector r_dir
 *  must have unit length;  this is mandatory, and is not ordinarily checked,
 *  in the name of efficiency.
 *
 *  Input:  Pointer to an application structure, with these mandatory fields:
 *	a_ray.r_pt	Starting point of ray to be fired
 *	a_ray.r_dir	UNIT VECTOR with direction to fire in (dir cosines)
 *	a_hit		Routine to call when something is hit
 *	a_miss		Routine to call when ray misses everything
 *
 *  Calls user's a_miss() or a_hit() routine as appropriate.
 *  Passes a_hit() routine list of partitions, with only hit_dist
 *  fields valid.  Normal computation deferred to user code,
 *  to avoid needless computation here.
 *
 *  Formal Return: whatever the application function returns (an int).
 *
 *  NOTE:  The appliction functions may call rt_shootray() recursively.
 *	Thus, none of the local variables may be static.
 *
 *  To prevent having to lock the statistics variables in a PARALLEL
 *  environment, all the statistics variables have been moved into
 *  the 'resource' structure, which is allocated per-CPU.
 */

int
rt_shootray(register struct application *ap)
{
	struct rt_shootray_status	ss;
	struct seg		new_segs;	/* from solid intersections */
	struct seg		waiting_segs;	/* awaiting rt_boolweave() */
	struct seg		finished_segs;	/* processed by rt_boolweave() */
	fastf_t			last_bool_start;
	struct bu_bitv		*solidbits;	/* bits for all solids shot so far */
	struct bu_bitv		*backbits=NULL;	/* bits for all solids using pieces that need to be intersected behind
						   the the ray start point */
	struct bu_ptbl		*regionbits;	/* table of all involved regions */
	char			*status;
	auto struct partition	InitialPart;	/* Head of Initial Partitions */
	auto struct partition	FinalPart;	/* Head of Final Partitions */
	struct soltab		**stpp;
	register const union cutter *cutp;
	struct resource		*resp;
	struct rt_i		*rtip;
	const int		debug_shoot = RT_G_DEBUG & DEBUG_SHOOT;
	fastf_t			pending_hit = 0; /* dist of closest odd hit pending */

	RT_AP_CHECK(ap);
	if( ap->a_magic )  {
		RT_CK_AP(ap);
	} else {
		ap->a_magic = RT_AP_MAGIC;
	}
	if( ap->a_ray.magic )  {
		RT_CK_RAY(&(ap->a_ray));
	} else {
		ap->a_ray.magic = RT_RAY_MAGIC;
	}
	if( ap->a_resource == RESOURCE_NULL )  {
		ap->a_resource = &rt_uniresource;
		if(RT_G_DEBUG)bu_log("rt_shootray:  defaulting a_resource to &rt_uniresource\n");
		if( rt_uniresource.re_magic == 0 )
			rt_init_resource( &rt_uniresource, 0, ap->a_rt_i );
	}
	ss.ap = ap;
	rtip = ap->a_rt_i;
	RT_CK_RTI( rtip );
	resp = ap->a_resource;
	RT_RESOURCE_CHECK(resp);
	ss.resp = resp;

	if(RT_G_DEBUG&(DEBUG_ALLRAYS|DEBUG_SHOOT|DEBUG_PARTITION|DEBUG_ALLHITS)) {
		bu_log_indent_delta(2);
		bu_log("\n**********shootray cpu=%d  %d,%d lvl=%d a_onehit=%d (%s)\n",
			resp->re_cpu,
			ap->a_x, ap->a_y,
			ap->a_level,
			ap->a_onehit,
			ap->a_purpose != (char *)0 ? ap->a_purpose : "?" );
		bu_log("Pnt (%.20G, %.20G, %.20G)\nDir (%.20G, %.20G, %.20G)\n",
			V3ARGS(ap->a_ray.r_pt),
			V3ARGS(ap->a_ray.r_dir) );
	}
#ifndef NO_BADRAY_CHECKING
	if(RT_BADVEC(ap->a_ray.r_pt)||RT_BADVEC(ap->a_ray.r_dir))  {
		bu_log("\n**********shootray cpu=%d  %d,%d lvl=%d (%s)\n",
			resp->re_cpu,
			ap->a_x, ap->a_y,
			ap->a_level,
			ap->a_purpose != (char *)0 ? ap->a_purpose : "?" );
		VPRINT(" r_pt", ap->a_ray.r_pt);
		VPRINT("r_dir", ap->a_ray.r_dir);
		rt_bomb("rt_shootray() bad ray\n");
	}
#endif

	if( rtip->needprep )
		rt_prep_parallel(rtip, 1);	/* Stay on our CPU */

	InitialPart.pt_forw = InitialPart.pt_back = &InitialPart;
	InitialPart.pt_magic = PT_HD_MAGIC;
	FinalPart.pt_forw = FinalPart.pt_back = &FinalPart;
	FinalPart.pt_magic = PT_HD_MAGIC;
	ap->a_Final_Part_hdp = &FinalPart;

	BU_LIST_INIT( &new_segs.l );
	BU_LIST_INIT( &waiting_segs.l );
	BU_LIST_INIT( &finished_segs.l );
	ap->a_finished_segs_hdp = &finished_segs;

	if( BU_LIST_UNINITIALIZED( &resp->re_parthead ) )  {
		/* XXX This shouldn't happen any more */
		bu_log("rt_shootray() resp=x%x uninitialized, fixing it\n", resp);
		/*
		 *  We've been handed a mostly un-initialized resource struct,
		 *  with only a magic number and a cpu number filled in.
		 *  Init it and add it to the table.
		 *  This is how application-provided resource structures
		 *  are remembered for later cleanup by the library.
		 */
		rt_init_resource( resp, resp->re_cpu, rtip );
	}
	/* Ensure that this CPU's resource structure is registered */
	if( resp != &rt_uniresource )
		BU_ASSERT_PTR( BU_PTBL_GET(&rtip->rti_resources, resp->re_cpu), !=, NULL );

	solidbits = get_solidbitv( rtip->nsolids, resp );
	bu_bitv_clear(solidbits);

	if( BU_LIST_IS_EMPTY( &resp->re_region_ptbl ) )  {
		BU_GETSTRUCT( regionbits, bu_ptbl );
		bu_ptbl_init( regionbits, 7, "rt_shootray() regionbits ptbl" );
	} else {
		regionbits = BU_LIST_FIRST( bu_ptbl, &resp->re_region_ptbl );
		BU_LIST_DEQUEUE( &regionbits->l );
		BU_CK_PTBL(regionbits);
	}

	if( !resp->re_pieces && rtip->rti_nsolids_with_pieces > 0 )  {
		/* Initialize this processors 'solid pieces' state */
		rt_res_pieces_init( resp, rtip );
	}
	if( BU_LIST_MAGIC_WRONG( &resp->re_pieces_pending.l, BU_PTBL_MAGIC ) )
		bu_ptbl_init( &resp->re_pieces_pending, 100, "re_pieces_pending" );
	bu_ptbl_reset( &resp->re_pieces_pending );

	/* Verify that direction vector has unit length */
	if(RT_G_DEBUG) {
		FAST fastf_t f, diff;
		/* Fancy version of BN_VEC_NON_UNIT_LEN() */
		f = MAGSQ(ap->a_ray.r_dir);
		if( NEAR_ZERO(f, 0.0001) )  {
			rt_bomb("rt_shootray:  zero length dir vector\n");
			return(0);
		}
		diff = f - 1;
		if( !NEAR_ZERO( diff, 0.0001 ) )  {
			bu_log("rt_shootray: non-unit dir vect (x%d y%d lvl%d)\n",
				ap->a_x, ap->a_y, ap->a_level );
			f = 1/f;
			VSCALE( ap->a_ray.r_dir, ap->a_ray.r_dir, f );
		}
	}

	/*
	 *  Record essential statistics in per-processor data structure.
	 */
	resp->re_nshootray++;

	/* Compute the inverse of the direction cosines */
	if( ap->a_ray.r_dir[X] < -SQRT_SMALL_FASTF )  {
		ss.abs_inv_dir[X] = -(ss.inv_dir[X]=1.0/ap->a_ray.r_dir[X]);
		ss.rstep[X] = -1;
	} else if( ap->a_ray.r_dir[X] > SQRT_SMALL_FASTF )  {
		ss.abs_inv_dir[X] =  (ss.inv_dir[X]=1.0/ap->a_ray.r_dir[X]);
		ss.rstep[X] = 1;
	} else {
		ap->a_ray.r_dir[X] = 0.0;
		ss.abs_inv_dir[X] = ss.inv_dir[X] = INFINITY;
		ss.rstep[X] = 0;
	}
	if( ap->a_ray.r_dir[Y] < -SQRT_SMALL_FASTF )  {
		ss.abs_inv_dir[Y] = -(ss.inv_dir[Y]=1.0/ap->a_ray.r_dir[Y]);
		ss.rstep[Y] = -1;
	} else if( ap->a_ray.r_dir[Y] > SQRT_SMALL_FASTF )  {
		ss.abs_inv_dir[Y] =  (ss.inv_dir[Y]=1.0/ap->a_ray.r_dir[Y]);
		ss.rstep[Y] = 1;
	} else {
		ap->a_ray.r_dir[Y] = 0.0;
		ss.abs_inv_dir[Y] = ss.inv_dir[Y] = INFINITY;
		ss.rstep[Y] = 0;
	}
	if( ap->a_ray.r_dir[Z] < -SQRT_SMALL_FASTF )  {
		ss.abs_inv_dir[Z] = -(ss.inv_dir[Z]=1.0/ap->a_ray.r_dir[Z]);
		ss.rstep[Z] = -1;
	} else if( ap->a_ray.r_dir[Z] > SQRT_SMALL_FASTF )  {
		ss.abs_inv_dir[Z] =  (ss.inv_dir[Z]=1.0/ap->a_ray.r_dir[Z]);
		ss.rstep[Z] = 1;
	} else {
		ap->a_ray.r_dir[Z] = 0.0;
		ss.abs_inv_dir[Z] = ss.inv_dir[Z] = INFINITY;
		ss.rstep[Z] = 0;
	}
	VMOVE( ap->a_inv_dir, ss.inv_dir );

	/*
	 *  If ray does not enter the model RPP, skip on.
	 *  If ray ends exactly at the model RPP, trace it.
	 */
	if( !rt_in_rpp( &ap->a_ray, ss.inv_dir, rtip->mdl_min, rtip->mdl_max )  ||
	    ap->a_ray.r_max < 0.0 )  {
		cutp = &ap->a_rt_i->rti_inf_box;
	    	if( cutp->bn.bn_len > 0 )  {
	    		/* Model has infinite solids, need to fire at them. */
			ss.box_start = BACKING_DIST;
			ss.model_start = 0;
			ss.box_end = ss.model_end = INFINITY;
			ss.lastcut = CUTTER_NULL;
			ss.old_status = (struct rt_shootray_status *)NULL;
			ss.curcut = cutp;
	    		ss.lastcell = ss.curcut;
			VMOVE( ss.curmin, rtip->mdl_min );
			VMOVE( ss.curmax, rtip->mdl_max );
			last_bool_start = BACKING_DIST;
			ss.newray = ap->a_ray;		/* struct copy */
			ss.odist_corr = ss.obox_start = ss.obox_end = -99;
	    		ss.dist_corr = 0.0;
	    		goto start_cell;
	    	}
		resp->re_nmiss_model++;
		ap->a_return = ap->a_miss( ap );
		status = "MISS model";
		goto out;
	}

	/*
	 *  The interesting part of the ray starts at distance 0.
	 *  If the ray enters the model at a negative distance,
	 *  (ie, the ray starts within the model RPP),
	 *  we only look at little bit behind (BACKING_DIST) to see if we are
	 *  just coming out of something, but never further back than
	 *  the intersection with the model RPP.
	 *  If the ray enters the model at a positive distance,
	 *  we always start there.
	 *  It is vital that we never pick a start point outside the
	 *  model RPP, or the space partitioning tree will pick the
	 *  wrong box and the ray will miss it.
	 *
	 *  BACKING_DIST should probably be determined by floating point
	 *  noise factor due to model RPP size -vs- number of bits of
	 *  floating point mantissa significance, rather than a constant,
	 *  but that is too hideous to think about here.
	 *  Also note that applications that really depend on knowing
	 *  what region they are leaving from should probably back their
	 *  own start-point up, rather than depending on it here, but
	 *  it isn't much trouble here.
	 *
	 *  Modification by JRA for pieces methodology:
	 *	The original algorithm here assumed that if we encountered any primitive
	 *	along the positive direction of the ray, ALL its intersections would be calculated.
	 *	With pieces, we may see only an exit hit if the entrance piece is in a space partition cell
	 *	that is more than "BACKING_DIST" behind the ray start point (leading to incorrect results).
	 *	I have modified the setting of "ss.box_start" (when pieces are present and the ray start point is
	 *	inside the model bounding box) as follows (see rt_find_backing_dist()):
	 *		The ray is traced through the space partitioning tree
	 *		The ray is intersected with the bounding box of each primitive using pieces in each cell
	 *		The minimum of all these intersections is set as the initial "ss.box_start".
	 *		The "backbits" bit vector has a bit set for each of the primitives using pieces that have
	 *			bounding boxes that extend behind the ray start point
	 *	Further below (in the "pieces" loop), I have added code to ignore primitives that do not have a bit
	 *	set in the backbits vector when we are behind the ray start point.
	 */

	/* these two values set the point where the ray tracing actually begins and ends */
	ss.box_start = ss.model_start = ap->a_ray.r_min;
	ss.box_end = ss.model_end = ap->a_ray.r_max;

	if( ap->a_rt_i->rti_nsolids_with_pieces > 0 ) {
		/* pieces are present */
		if( ss.box_start < BACKING_DIST ) {
			/* the first ray intersection with the model bounding box is more than BACKING_DIST
			 * behind the ray start point
			 */

			/* get a bit vector to keep track of which primitives need to be intersected
			 * behind the ray start point (those having bounding boxes extending behind the
			 * ray start point and using pieces)
			 */
			backbits = get_solidbitv( rtip->nsolids, resp );
			bu_bitv_clear(backbits);

			/* call "rt_find_backing_dist()" to calculate the required
			 * start point for calculation, and to fill in the "backbits" bit vector
			 */
			ss.box_start = rt_find_backing_dist( &ss, backbits );
		}
	} else {
		/* no pieces present, use the old scheme */
		if( ss.box_start < BACKING_DIST )
			ss.box_start = BACKING_DIST; /* Only look a little bit behind */
	}

	ss.lastcut = CUTTER_NULL;
	ss.old_status = (struct rt_shootray_status *)NULL;
	ss.curcut = &ap->a_rt_i->rti_CutHead;
	if( ss.curcut->cut_type == CUT_NUGRIDNODE ) {
		ss.lastcell = CUTTER_NULL;
		VSET( ss.curmin, ss.curcut->nugn.nu_axis[X][0].nu_spos,
				 ss.curcut->nugn.nu_axis[Y][0].nu_spos,
				 ss.curcut->nugn.nu_axis[Z][0].nu_spos );
		VSET( ss.curmax, ss.curcut->nugn.nu_axis[X][ss.curcut->nugn.nu_cells_per_axis[X]-1].nu_epos,
				 ss.curcut->nugn.nu_axis[Y][ss.curcut->nugn.nu_cells_per_axis[Y]-1].nu_epos,
				 ss.curcut->nugn.nu_axis[Z][ss.curcut->nugn.nu_cells_per_axis[Z]-1].nu_epos );
	} else if( ss.curcut->cut_type == CUT_CUTNODE ||
		   ss.curcut->cut_type == CUT_BOXNODE ) {
		ss.lastcell = ss.curcut;
		VMOVE( ss.curmin, rtip->mdl_min );
		VMOVE( ss.curmax, rtip->mdl_max );
	}

	last_bool_start = BACKING_DIST;
	ss.newray = ap->a_ray;		/* struct copy */
	ss.odist_corr = ss.obox_start = ss.obox_end = -99;
	ss.dist_corr = 0.0;
	ss.box_num = 0;

	/*
	 *  While the ray remains inside model space,
	 *  push from box to box until ray emerges from
	 *  model space again (or first hit is found, if user is impatient).
	 *  It is vitally important to always stay within the model RPP, or
	 *  the space partitoning tree will pick wrong boxes & miss them.
	 */
	while( (cutp = rt_advance_to_next_cell( &ss )) != CUTTER_NULL )  {
start_cell:
		if(debug_shoot) {
			bu_log("BOX #%d interval is %g..%g\n", ss.box_num, ss.box_start, ss.box_end);
			rt_pr_cut( cutp, 0 );
		}

		if( cutp->bn.bn_len <= 0 && cutp->bn.bn_piecelen <= 0 )  {
			/* Push ray onwards to next box */
			ss.box_start = ss.box_end;
			resp->re_nempty_cells++;
			continue;
		}

		/* Consider all "pieces" of all solids within the box */
		pending_hit = ss.box_end;
		if( cutp->bn.bn_piecelen > 0 )  {
			register struct rt_piecelist *plp;

			plp = &(cutp->bn.bn_piecelist[cutp->bn.bn_piecelen-1]);
			for( ; plp >= cutp->bn.bn_piecelist; plp-- )  {
				struct rt_piecestate *psp;
				struct soltab	*stp;
				int ret;
				int had_hits_before;

				RT_CK_PIECELIST(plp);

				/* Consider all pieces of this one solid in this cell */
				stp = plp->stp;
				RT_CK_SOLTAB(stp);

				if( backbits && ss.box_end < BACKING_DIST && BU_BITTEST( backbits, stp->st_bit ) == 0 ) {
					/* we are behind the ray start point and this primitive is not one
					 * that we need to intersect back here
					 */
					continue;
				}

				psp = &(resp->re_pieces[stp->st_piecestate_num]);
				RT_CK_PIECESTATE(psp);
				if( psp->ray_seqno != resp->re_nshootray )  {
					/* state is from an earlier ray, scrub */
					BU_BITV_ZEROALL(psp->shot);
					psp->ray_seqno = resp->re_nshootray;
					rt_htbl_reset( &psp->htab );

					/* Compute ray entry and exit to entire solid's bounding box */
					if( !rt_in_rpp( &ss.newray, ss.inv_dir,
					    stp->st_min, stp->st_max ) )  {
						if(debug_shoot)bu_log("rpp miss %s (all pieces)\n", stp->st_name);
						resp->re_prune_solrpp++;
						BU_BITSET( solidbits, stp->st_bit );
						continue;	/* MISS */
					}
					psp->mindist = ss.newray.r_min + ss.dist_corr;
					psp->maxdist = ss.newray.r_max + ss.dist_corr;
					if(debug_shoot) bu_log("%s mindist=%g, maxdist=%g\n", stp->st_name, psp->mindist, psp->maxdist);
					had_hits_before = 0;
				} else {
					if( BU_BITTEST( solidbits, stp->st_bit ) )  {
						/* we missed the solid RPP in an earlier cell */
						resp->re_ndup++;
						continue;	/* already shot */
					}
					had_hits_before = psp->htab.end;
				}

				/*
				 *  Allow this solid to shoot at all of its
				 *  'pieces' in this cell, all at once.
				 *  'newray' has been transformed to be near
				 *  to this cell, and
				 *  'dist_corr' is the additive correction
				 *  factor that ft_piece_shot() must apply
				 *  to hits calculated using 'newray'.
				 */
				resp->re_piece_shots++;
				psp->cutp = cutp;
				if( (ret = stp->st_meth->ft_piece_shot(
				    psp, plp, ss.dist_corr, &ss.newray, ap, &waiting_segs )) <= 0 )  {
				    	/* No hits at all */
					resp->re_piece_shot_miss++;
				} else {
					resp->re_piece_shot_hit++;
				}
				if(debug_shoot)bu_log("shooting %s pieces, nhit=%d\n", stp->st_name, ret);

				/*  See if this solid has been fully processed yet.
				 *  If ray has passed through bounding volume, we're done.
				 *  ft_piece_hitsegs() will only be called once per ray.
				 */
				if( ss.box_end > psp->maxdist && psp->htab.end > 0 ) {
					/* Convert hits into segs */
					if(debug_shoot)bu_log("shooting %s pieces complete, making segs\n", stp->st_name);
					/* Distance correction was handled in ft_piece_shot */
					stp->st_meth->ft_piece_hitsegs( psp, &waiting_segs, ap );
					rt_htbl_reset( &psp->htab );
					BU_BITSET( solidbits, stp->st_bit );

					if( had_hits_before )
    						bu_ptbl_rm( &resp->re_pieces_pending, (long *)psp );
				} else {
					if( !had_hits_before )
						bu_ptbl_ins_unique( &resp->re_pieces_pending, (long *)psp );
				}
			}
		}

		/* Consider all solids within the box */
		if( cutp->bn.bn_len > 0 && ss.box_end >= BACKING_DIST )  {
			stpp = &(cutp->bn.bn_list[cutp->bn.bn_len-1]);
			for( ; stpp >= cutp->bn.bn_list; stpp-- )  {
				register struct soltab *stp = *stpp;

				if( BU_BITTEST( solidbits, stp->st_bit ) )  {
					resp->re_ndup++;
					continue;	/* already shot */
				}

				/* Shoot a ray */
				BU_BITSET( solidbits, stp->st_bit );

				/* Check against bounding RPP, if desired by solid */
				if( stp->st_meth->ft_use_rpp )  {
					if( !rt_in_rpp( &ss.newray, ss.inv_dir,
					    stp->st_min, stp->st_max ) )  {
						if(debug_shoot)bu_log("rpp miss %s\n", stp->st_name);
						resp->re_prune_solrpp++;
						continue;	/* MISS */
					}
					if( ss.dist_corr + ss.newray.r_max < BACKING_DIST )  {
						if(debug_shoot)bu_log("rpp skip %s, dist_corr=%g, r_max=%g\n", stp->st_name, ss.dist_corr, ss.newray.r_max);
						resp->re_prune_solrpp++;
						continue;	/* MISS */
					}
				}
				
				if(debug_shoot)bu_log("shooting %s\n", stp->st_name);
				resp->re_shots++;
				BU_LIST_INIT( &(new_segs.l) );
				if( stp->st_meth->ft_shot( 
				    stp, &ss.newray, ap, &new_segs ) <= 0 )  {
					resp->re_shot_miss++;
					continue;	/* MISS */
				}

				/* Add seg chain to list awaiting rt_boolweave() */
				{
					register struct seg *s2;
					while(BU_LIST_WHILE(s2,seg,&(new_segs.l)))  {
						BU_LIST_DEQUEUE( &(s2->l) );
						/* Restore to original distance */
						s2->seg_in.hit_dist += ss.dist_corr;
						s2->seg_out.hit_dist += ss.dist_corr;
						s2->seg_in.hit_rayp = s2->seg_out.hit_rayp = &ap->a_ray;
						BU_LIST_INSERT( &(waiting_segs.l), &(s2->l) );
					}
				}
				resp->re_shot_hit++;
			}
		}
		if( RT_G_DEBUG & DEBUG_ADVANCE )
			rt_plot_cell( cutp, &ss, &(waiting_segs.l), rtip);

		/*
		 *  If a_onehit == 0 and a_ray_length <= 0, then the ray
		 *  is traced to +infinity.
		 *
		 *  If a_onehit != 0, then it indicates how many hit points
		 *  (which are greater than the ray start point of 0.0)
		 *  the application requires, ie, partitions with inhit >= 0.
		 *  (If negative, indicates number of non-air hits needed).
		 *  If this box yielded additional segments,
		 *  immediately weave them into the partition list,
		 *  and perform final boolean evaluation.
		 *  If this results in the required number of final
		 *  partitions, then cease ray-tracing and hand the
		 *  partitions over to the application.
		 *  All partitions will have valid in and out distances.
		 *  a_ray_length is treated similarly to a_onehit.
		 */
		if( BU_LIST_NON_EMPTY( &(waiting_segs.l) ) )  {
			if(debug_shoot)  {
				struct seg *segp;
				bu_log("Waiting segs:\n");
				for( BU_LIST_FOR( segp, seg, &(waiting_segs.l) ) )  {
					rt_pr_seg(segp);
				}
			}
			if( ap->a_onehit != 0 )  {
				int	done;

				/* Weave these segments into partition list */
				rt_boolweave( &finished_segs, &waiting_segs, &InitialPart, ap );

				if( BU_PTBL_LEN( &resp->re_pieces_pending ) > 0 )  {
					/* Find the lowest pending mindist, that's as far as boolfinal can progress to */
					struct rt_piecestate **psp;
					for( BU_PTBL_FOR( psp, (struct rt_piecestate **), &resp->re_pieces_pending ) )  {
						FAST fastf_t dist;
						
						dist = (*psp)->mindist;
						BU_ASSERT_DOUBLE( dist, <, INFINITY );
						if( dist < pending_hit )  {
							pending_hit = dist;
							if(debug_shoot) bu_log("pending_hit lowered to %g by %s\n", pending_hit, (*psp)->stp->st_name);
						}
					}
				}

				/* Evaluate regions upto end of good segs */
				if( ss.box_end < pending_hit )  pending_hit = ss.box_end;
				done = rt_boolfinal( &InitialPart, &FinalPart,
					last_bool_start, pending_hit, regionbits, ap, solidbits );
				last_bool_start = pending_hit;

				/* See if enough partitions have been acquired */
				if( done > 0 )  goto hitit;
			}
		}

		if( ap->a_ray_length > 0.0 &&
		    ss.box_end >= ap->a_ray_length &&
		    ap->a_ray_length < pending_hit )
			goto weave;

		/* Push ray onwards to next box */
		ss.box_start = ss.box_end;
	}

	/*
	 *  Ray has finally left known space --
	 *  Weave any remaining segments into the partition list.
	 */
weave:
	if( RT_G_DEBUG&DEBUG_ADVANCE )
		bu_log( "rt_shootray: ray has left known space\n" );

	/* Process any pending hits into segs */
	if( BU_PTBL_LEN( &resp->re_pieces_pending ) > 0 )  {
		struct rt_piecestate **psp;
		for( BU_PTBL_FOR( psp, (struct rt_piecestate **), &resp->re_pieces_pending ) )  {
			if( (*psp)->htab.end > 0 )  {
				/* Convert any pending hits into segs */
				/* Distance correction was handled in ft_piece_shot */
				(*psp)->stp->st_meth->ft_piece_hitsegs( *psp, &waiting_segs, ap );
				rt_htbl_reset( &(*psp)->htab );
			}
			*psp = NULL;
		}
		bu_ptbl_reset( &resp->re_pieces_pending );
	}
	
	if( BU_LIST_NON_EMPTY( &(waiting_segs.l) ) )  {
		rt_boolweave( &finished_segs, &waiting_segs, &InitialPart, ap );
	}

	/* finished_segs chain now has all segments hit by this ray */
	if( BU_LIST_IS_EMPTY( &(finished_segs.l) ) )  {
		ap->a_return = ap->a_miss( ap );
		status = "MISS prims";
		goto out;
	}

	/*
	 *  All intersections of the ray with the model have
	 *  been computed.  Evaluate the boolean trees over each partition.
	 */
	(void)rt_boolfinal( &InitialPart, &FinalPart, BACKING_DIST,
		INFINITY,
		regionbits, ap, solidbits);

	if( FinalPart.pt_forw == &FinalPart )  {
		ap->a_return = ap->a_miss( ap );
		status = "MISS bool";
		RT_FREE_PT_LIST( &InitialPart, resp );
		RT_FREE_SEG_LIST( &finished_segs, resp );
		goto out;
	}

	/*
	 *  Ray/model intersections exist.  Pass the list to the
	 *  user's a_hit() routine.  Note that only the hit_dist
	 *  elements of pt_inhit and pt_outhit have been computed yet.
	 *  To compute both hit_point and hit_normal, use the
	 *
	 *  	RT_HIT_NORM( hitp, stp, rayp )
	 *
	 *  macro.  To compute just hit_point, use
	 *
	 *  VJOIN1( hitp->hit_point, rp->r_pt, hitp->hit_dist, rp->r_dir );
	 */
hitit:
	if(debug_shoot)  rt_pr_partitions(rtip,&FinalPart,"a_hit()");

	/*
	 *  Before recursing, release storage for unused Initial partitions.
	 *  finished_segs can not be released yet, because FinalPart
	 *  partitions will point to hits in those segments.
	 */
	RT_FREE_PT_LIST( &InitialPart, resp );

	/*
	 *  finished_segs is only used by special hit routines
	 *  which don't follow the traditional solid modeling paradigm.
	 */
	if(RT_G_DEBUG&DEBUG_ALLHITS) rt_pr_partitions(rtip,&FinalPart,"Partition list passed to a_hit() routine");
	ap->a_return = ap->a_hit( ap, &FinalPart, &finished_segs );
	status = "HIT";

	RT_FREE_SEG_LIST( &finished_segs, resp );
	RT_FREE_PT_LIST( &FinalPart, resp );

	/*
	 * Processing of this ray is complete.
	 */
out:
	/*  Return dynamic resources to their freelists.  */
	BU_CK_BITV(solidbits);
	BU_LIST_APPEND( &resp->re_solid_bitv, &solidbits->l );
	if( backbits ) {
		BU_CK_BITV(backbits);
		BU_LIST_APPEND( &resp->re_solid_bitv, &backbits->l );
	}
	BU_CK_PTBL(regionbits);
	BU_LIST_APPEND( &resp->re_region_ptbl, &regionbits->l );

	/* Clean up any pending hits */
	if( BU_PTBL_LEN( &resp->re_pieces_pending ) > 0 )  {
		struct rt_piecestate **psp;
		for( BU_PTBL_FOR( psp, (struct rt_piecestate **), &resp->re_pieces_pending ) )  {
			if( (*psp)->htab.end > 0 )
				rt_htbl_reset( &(*psp)->htab );
		}
		bu_ptbl_reset( &resp->re_pieces_pending );
	}

	/* Terminate any logging */
	if(RT_G_DEBUG&(DEBUG_ALLRAYS|DEBUG_SHOOT|DEBUG_PARTITION|DEBUG_ALLHITS))  {
		bu_log_indent_delta(-2);
		bu_log("----------shootray cpu=%d  %d,%d lvl=%d (%s) %s ret=%d\n",
			resp->re_cpu,
			ap->a_x, ap->a_y,
			ap->a_level,
			ap->a_purpose != (char *)0 ? ap->a_purpose : "?",
			status, ap->a_return);
	}
	return( ap->a_return );
}

/*
 *			R T _ C E L L _ N _ O N _ R A Y
 *
 *  Return pointer to cell 'n' along a given ray.
 *  Used for debugging of how space partitioning interacts with shootray.
 *  Intended to mirror the operation of rt_shootray().
 *  The first cell is 0.
 */
const union cutter *
rt_cell_n_on_ray(register struct application *ap, int n)
                                
   	  		/* First cell is #0 */
{
	struct rt_shootray_status	ss;
	register const union cutter *cutp;
	struct resource		*resp;
	struct rt_i		*rtip;
	const int		debug_shoot = RT_G_DEBUG & DEBUG_SHOOT;

	RT_AP_CHECK(ap);
	if( ap->a_magic )  {
		RT_CK_AP(ap);
	} else {
		ap->a_magic = RT_AP_MAGIC;
	}
	if( ap->a_ray.magic )  {
		RT_CK_RAY(&(ap->a_ray));
	} else {
		ap->a_ray.magic = RT_RAY_MAGIC;
	}
	if( ap->a_resource == RESOURCE_NULL )  {
		ap->a_resource = &rt_uniresource;
		if(RT_G_DEBUG)bu_log("rt_cell_n_on_ray:  defaulting a_resource to &rt_uniresource\n");
		if( rt_uniresource.re_magic == 0 )
			rt_init_resource( &rt_uniresource, 0, ap->a_rt_i );
	}
	ss.ap = ap;
	rtip = ap->a_rt_i;
	RT_CK_RTI( rtip );
	resp = ap->a_resource;
	RT_RESOURCE_CHECK(resp);
	ss.resp = resp;

	if(RT_G_DEBUG&(DEBUG_ALLRAYS|DEBUG_SHOOT|DEBUG_PARTITION|DEBUG_ALLHITS)) {
		bu_log_indent_delta(2);
		bu_log("\n**********cell_n_on_ray cpu=%d  %d,%d lvl=%d (%s), n=%d\n",
			resp->re_cpu,
			ap->a_x, ap->a_y,
			ap->a_level,
			ap->a_purpose != (char *)0 ? ap->a_purpose : "?", n );
		bu_log("Pnt (%g, %g, %g) a_onehit=%d\n",
			V3ARGS(ap->a_ray.r_pt),
			ap->a_onehit );
		VPRINT("Dir", ap->a_ray.r_dir);
	}
#ifndef NO_BADRAY_CHECKING
	if(RT_BADVEC(ap->a_ray.r_pt)||RT_BADVEC(ap->a_ray.r_dir))  {
		bu_log("\n**********cell_n_on_ray cpu=%d  %d,%d lvl=%d (%s)\n",
			resp->re_cpu,
			ap->a_x, ap->a_y,
			ap->a_level,
			ap->a_purpose != (char *)0 ? ap->a_purpose : "?" );
		VPRINT(" r_pt", ap->a_ray.r_pt);
		VPRINT("r_dir", ap->a_ray.r_dir);
		rt_bomb("rt_cell_n_on_ray() bad ray\n");
	}
#endif

	if( rtip->needprep )
		rt_prep_parallel(rtip, 1);	/* Stay on our CPU */

	if( BU_LIST_UNINITIALIZED( &resp->re_parthead ) )  {
		/* XXX This shouldn't happen any more */
		bu_log("rt_cell_n_on_ray() resp=x%x uninitialized, fixing it\n", resp);
		/*
		 *  We've been handed a mostly un-initialized resource struct,
		 *  with only a magic number and a cpu number filled in.
		 *  Init it and add it to the table.
		 *  This is how application-provided resource structures
		 *  are remembered for later cleanup by the library.
		 */
		rt_init_resource( resp, resp->re_cpu, rtip );
	}
	/* Ensure that this CPU's resource structure is registered */
	BU_ASSERT_PTR( BU_PTBL_GET(&rtip->rti_resources, resp->re_cpu), !=, NULL );

	/* Verify that direction vector has unit length */
	if(RT_G_DEBUG) {
		FAST fastf_t f, diff;
		/* Fancy version of BN_VEC_NON_UNIT_LEN() */
		f = MAGSQ(ap->a_ray.r_dir);
		if( NEAR_ZERO(f, 0.0001) )  {
			rt_bomb("rt_cell_n_on_ray:  zero length dir vector\n");
			return CUTTER_NULL;
		}
		diff = f - 1;
		if( !NEAR_ZERO( diff, 0.0001 ) )  {
			bu_log("rt_cell_n_on_ray: non-unit dir vect (x%d y%d lvl%d)\n",
				ap->a_x, ap->a_y, ap->a_level );
			f = 1/f;
			VSCALE( ap->a_ray.r_dir, ap->a_ray.r_dir, f );
		}
	}

	/* Compute the inverse of the direction cosines */
	if( ap->a_ray.r_dir[X] < -SQRT_SMALL_FASTF )  {
		ss.abs_inv_dir[X] = -(ss.inv_dir[X]=1.0/ap->a_ray.r_dir[X]);
		ss.rstep[X] = -1;
	} else if( ap->a_ray.r_dir[X] > SQRT_SMALL_FASTF )  {
		ss.abs_inv_dir[X] =  (ss.inv_dir[X]=1.0/ap->a_ray.r_dir[X]);
		ss.rstep[X] = 1;
	} else {
		ap->a_ray.r_dir[X] = 0.0;
		ss.abs_inv_dir[X] = ss.inv_dir[X] = INFINITY;
		ss.rstep[X] = 0;
	}
	if( ap->a_ray.r_dir[Y] < -SQRT_SMALL_FASTF )  {
		ss.abs_inv_dir[Y] = -(ss.inv_dir[Y]=1.0/ap->a_ray.r_dir[Y]);
		ss.rstep[Y] = -1;
	} else if( ap->a_ray.r_dir[Y] > SQRT_SMALL_FASTF )  {
		ss.abs_inv_dir[Y] =  (ss.inv_dir[Y]=1.0/ap->a_ray.r_dir[Y]);
		ss.rstep[Y] = 1;
	} else {
		ap->a_ray.r_dir[Y] = 0.0;
		ss.abs_inv_dir[Y] = ss.inv_dir[Y] = INFINITY;
		ss.rstep[Y] = 0;
	}
	if( ap->a_ray.r_dir[Z] < -SQRT_SMALL_FASTF )  {
		ss.abs_inv_dir[Z] = -(ss.inv_dir[Z]=1.0/ap->a_ray.r_dir[Z]);
		ss.rstep[Z] = -1;
	} else if( ap->a_ray.r_dir[Z] > SQRT_SMALL_FASTF )  {
		ss.abs_inv_dir[Z] =  (ss.inv_dir[Z]=1.0/ap->a_ray.r_dir[Z]);
		ss.rstep[Z] = 1;
	} else {
		ap->a_ray.r_dir[Z] = 0.0;
		ss.abs_inv_dir[Z] = ss.inv_dir[Z] = INFINITY;
		ss.rstep[Z] = 0;
	}

	/*
	 *  If ray does not enter the model RPP, skip on.
	 *  If ray ends exactly at the model RPP, trace it.
	 */
	if( !rt_in_rpp( &ap->a_ray, ss.inv_dir, rtip->mdl_min, rtip->mdl_max )  ||
	    ap->a_ray.r_max < 0.0 )  {
		cutp = &ap->a_rt_i->rti_inf_box;
	    	if( cutp->bn.bn_len > 0 )  {
	    		if( n == 0 )  return cutp;
	    	}
    		return CUTTER_NULL;
	}

	/*
	 *  The interesting part of the ray starts at distance 0.
	 *  If the ray enters the model at a negative distance,
	 *  (ie, the ray starts within the model RPP),
	 *  we only look at little bit behind (BACKING_DIST) to see if we are
	 *  just coming out of something, but never further back than
	 *  the intersection with the model RPP.
	 *  If the ray enters the model at a positive distance,
	 *  we always start there.
	 *  It is vital that we never pick a start point outside the
	 *  model RPP, or the space partitioning tree will pick the
	 *  wrong box and the ray will miss it.
	 *
	 *  BACKING_DIST should probably be determined by floating point
	 *  noise factor due to model RPP size -vs- number of bits of
	 *  floating point mantissa significance, rather than a constant,
	 *  but that is too hideous to think about here.
	 *  Also note that applications that really depend on knowing
	 *  what region they are leaving from should probably back their
	 *  own start-point up, rather than depending on it here, but
	 *  it isn't much trouble here.
	 */
	ss.box_start = ss.model_start = ap->a_ray.r_min;
	ss.box_end = ss.model_end = ap->a_ray.r_max;

	if( ss.box_start < BACKING_DIST )
		ss.box_start = BACKING_DIST; /* Only look a little bit behind */

	ss.lastcut = CUTTER_NULL;
	ss.old_status = (struct rt_shootray_status *)NULL;
	ss.curcut = &ap->a_rt_i->rti_CutHead;
	if( ss.curcut->cut_type == CUT_NUGRIDNODE ) {
		ss.lastcell = CUTTER_NULL;
		VSET( ss.curmin, ss.curcut->nugn.nu_axis[X][0].nu_spos,
				 ss.curcut->nugn.nu_axis[Y][0].nu_spos,
				 ss.curcut->nugn.nu_axis[Z][0].nu_spos );
		VSET( ss.curmax, ss.curcut->nugn.nu_axis[X][ss.curcut->nugn.nu_cells_per_axis[X]-1].nu_epos,
				 ss.curcut->nugn.nu_axis[Y][ss.curcut->nugn.nu_cells_per_axis[Y]-1].nu_epos,
				 ss.curcut->nugn.nu_axis[Z][ss.curcut->nugn.nu_cells_per_axis[Z]-1].nu_epos );
	} else if( ss.curcut->cut_type == CUT_CUTNODE ||
		   ss.curcut->cut_type == CUT_BOXNODE ) {
		ss.lastcell = ss.curcut;
		VMOVE( ss.curmin, rtip->mdl_min );
		VMOVE( ss.curmax, rtip->mdl_max );
	}

	ss.newray = ap->a_ray;		/* struct copy */
	ss.odist_corr = ss.obox_start = ss.obox_end = -99;
	ss.dist_corr = 0.0;

	/*
	 *  While the ray remains inside model space,
	 *  push from box to box until ray emerges from
	 *  model space again (or first hit is found, if user is impatient).
	 *  It is vitally important to always stay within the model RPP, or
	 *  the space partitoning tree will pick wrong boxes & miss them.
	 */
	while( (cutp = rt_advance_to_next_cell( &ss )) != CUTTER_NULL )  {
		if(debug_shoot) {
			rt_pr_cut( cutp, 0 );
		}
		if( --n <= 0 )  return cutp;

		/* Push ray onwards to next box */
		ss.box_start = ss.box_end;
	}
	return CUTTER_NULL;
}

/*
 *			R T _ I N _ R P P
 *
 *  Compute the intersections of a ray with a rectangular parallelpiped (RPP)
 *  that has faces parallel to the coordinate planes
 *
 *  The algorithm here was developed by Gary Kuehl for GIFT.
 *  A good description of the approach used can be found in
 *  "??" by XYZZY and Barsky,
 *  ACM Transactions on Graphics, Vol 3 No 1, January 1984.
 *
 * Note -
 *  The computation of entry and exit distance is mandatory, as the final
 *  test catches the majority of misses.
 *
 * Note -
 *  A hit is returned if the intersect is behind the start point.
 *
 *  Returns -
 *	 0  if ray does not hit RPP,
 *	!0  if ray hits RPP.
 *
 *  Implicit return -
 *	rp->r_min = dist from start of ray to point at which ray ENTERS solid
 *	rp->r_max = dist from start of ray to point at which ray LEAVES solid
 */
int
rt_in_rpp(struct xray		*rp,
	  register const fastf_t *invdir,	/* inverses of rp->r_dir[] */
	  register const fastf_t *min,
	  register const fastf_t *max)
{
	register const fastf_t	*pt = &rp->r_pt[0];
	register fastf_t	sv;
#define st sv			/* reuse the register */
	register fastf_t	rmin = -INFINITY;
	register fastf_t	rmax =  INFINITY;

	/* Start with infinite ray, and trim it down */

	/* X axis */
	if( *invdir < 0.0 )  {
		/* Heading towards smaller numbers */
		/* if( *min > *pt )  miss */
		if(rmax > (sv = (*min - *pt) * *invdir) )
			rmax = sv;
		if( rmin < (st = (*max - *pt) * *invdir) )
			rmin = st;
	}  else if( *invdir > 0.0 )  {
		/* Heading towards larger numbers */
		/* if( *max < *pt )  miss */
		if(rmax > (st = (*max - *pt) * *invdir) )
			rmax = st;
		if( rmin < ((sv = (*min - *pt) * *invdir)) )
			rmin = sv;
	}  else  {
		/*
		 *  Direction cosines along this axis is NEAR 0,
		 *  which implies that the ray is perpendicular to the axis,
		 *  so merely check position against the boundaries.
		 */
		if( (*min > *pt) || (*max < *pt) )
			return(0);	/* MISS */
	}

	/* Y axis */
	pt++; invdir++; max++; min++;
	if( *invdir < 0.0 )  {
		if(rmax > (sv = (*min - *pt) * *invdir) )
			rmax = sv;
		if( rmin < (st = (*max - *pt) * *invdir) )
			rmin = st;
	}  else if( *invdir > 0.0 )  {
		if(rmax > (st = (*max - *pt) * *invdir) )
			rmax = st;
		if( rmin < ((sv = (*min - *pt) * *invdir)) )
			rmin = sv;
	}  else  {
		if( (*min > *pt) || (*max < *pt) )
			return(0);	/* MISS */
	}

	/* Z axis */
	pt++; invdir++; max++; min++;
	if( *invdir < 0.0 )  {
		if(rmax > (sv = (*min - *pt) * *invdir) )
			rmax = sv;
		if( rmin < (st = (*max - *pt) * *invdir) )
			rmin = st;
	}  else if( *invdir > 0.0 )  {
		if(rmax > (st = (*max - *pt) * *invdir) )
			rmax = st;
		if( rmin < ((sv = (*min - *pt) * *invdir)) )
			rmin = sv;
	}  else  {
		if( (*min > *pt) || (*max < *pt) )
			return(0);	/* MISS */
	}

	/* If equal, RPP is actually a plane */
	if( rmin > rmax )
		return(0);	/* MISS */

	/* HIT.  Only now do rp->r_min and rp->r_max have to be written */
	rp->r_min = rmin;
	rp->r_max = rmax;
	return(1);		/* HIT */
}

/* For debugging */
int
rt_DB_rpp(register struct xray *rp, register const fastf_t *invdir, register const fastf_t *min, register const fastf_t *max)
                         
                               	/* inverses of rp->r_dir[] */
                            
                            
{
	register const fastf_t *pt = &rp->r_pt[0];
	FAST fastf_t sv;

	/* Start with infinite ray, and trim it down */
	rp->r_min = -INFINITY;
	rp->r_max = INFINITY;

VPRINT("r_pt ", pt);
VPRINT("r_dir", rp->r_dir);
VPRINT("min  ", min);
VPRINT("max  ", max);
	/* X axis */
	if( rp->r_dir[X] < 0.0 )  {
		/* Heading towards smaller numbers */
		/* if( *min > *pt )  miss */
		sv = (*min - *pt) * *invdir;
bu_log("sv=%g, r_max=%g\n", sv, rp->r_max);
		if(rp->r_max > sv)
			rp->r_max = sv;
		st = (*max - *pt) * *invdir;
bu_log("st=%g, r_min=%g\n", st, rp->r_min);
		if( rp->r_min < st )
			rp->r_min = st;
bu_log("r_min=%g, r_max=%g\n", rp->r_min, rp->r_max);
	}  else if( rp->r_dir[X] > 0.0 )  {
		/* Heading towards larger numbers */
		/* if( *max < *pt )  miss */
		st = (*max - *pt) * *invdir;
bu_log("st=%g, r_max=%g\n", st, rp->r_max);
		if(rp->r_max > st)
			rp->r_max = st;
		sv = (*min - *pt) * *invdir;
bu_log("sv=%g, r_min=%g\n", sv, rp->r_min);
		if( rp->r_min < sv )
			rp->r_min = sv;
bu_log("r_min=%g, r_max=%g\n", rp->r_min, rp->r_max);
	}  else  {
		/*
		 *  Direction cosines along this axis is NEAR 0,
		 *  which implies that the ray is perpendicular to the axis,
		 *  so merely check position against the boundaries.
		 */
		if( (*min > *pt) || (*max < *pt) )
			goto miss;
	}

	/* Y axis */
	pt++; invdir++; max++; min++;
	if( rp->r_dir[Y] < 0.0 )  {
		/* Heading towards smaller numbers */
		/* if( *min > *pt )  miss */
		sv = (*min - *pt) * *invdir;
bu_log("sv=%g, r_max=%g\n", sv, rp->r_max);
		if(rp->r_max > sv)
			rp->r_max = sv;
		st = (*max - *pt) * *invdir;
bu_log("st=%g, r_min=%g\n", st, rp->r_min);
		if( rp->r_min < st )
			rp->r_min = st;
bu_log("r_min=%g, r_max=%g\n", rp->r_min, rp->r_max);
	}  else if( rp->r_dir[Y] > 0.0 )  {
		/* Heading towards larger numbers */
		/* if( *max < *pt )  miss */
		st = (*max - *pt) * *invdir;
bu_log("st=%g, r_max=%g\n", st, rp->r_max);
		if(rp->r_max > st)
			rp->r_max = st;
		sv = (*min - *pt) * *invdir;
bu_log("sv=%g, r_min=%g\n", sv, rp->r_min);
		if( rp->r_min < sv )
			rp->r_min = sv;
bu_log("r_min=%g, r_max=%g\n", rp->r_min, rp->r_max);
	}  else  {
		if( (*min > *pt) || (*max < *pt) )
			goto miss;
	}

	/* Z axis */
	pt++; invdir++; max++; min++;
	if( rp->r_dir[Z] < 0.0 )  {
		/* Heading towards smaller numbers */
		/* if( *min > *pt )  miss */
		sv = (*min - *pt) * *invdir;
bu_log("sv=%g, r_max=%g\n", sv, rp->r_max);
		if(rp->r_max > sv)
			rp->r_max = sv;
		st = (*max - *pt) * *invdir;
bu_log("st=%g, r_min=%g\n", st, rp->r_min);
		if( rp->r_min < st )
			rp->r_min = st;
bu_log("r_min=%g, r_max=%g\n", rp->r_min, rp->r_max);
	}  else if( rp->r_dir[Z] > 0.0 )  {
		/* Heading towards larger numbers */
		/* if( *max < *pt )  miss */
		st = (*max - *pt) * *invdir;
bu_log("st=%g, r_max=%g\n", st, rp->r_max);
		if(rp->r_max > st)
			rp->r_max = st;
		sv = (*min - *pt) * *invdir;
bu_log("sv=%g, r_min=%g\n", sv, rp->r_min);
		if( rp->r_min < sv )
			rp->r_min = sv;
bu_log("r_min=%g, r_max=%g\n", rp->r_min, rp->r_max);
	}  else  {
		if( (*min > *pt) || (*max < *pt) )
			goto miss;
	}

	/* If equal, RPP is actually a plane */
	if( rp->r_min > rp->r_max )
		goto miss;
	bu_log("HIT:  %g..%g\n", rp->r_min, rp->r_max );
	return(1);		/* HIT */
miss:
	bu_log("MISS\n");
	return(0);		/* MISS */
}

#undef st


#define SEG_MISS(SEG)		(SEG).seg_stp=(struct soltab *) 0;	

/* Stub function which will "similate" a call to a vector shot routine */
void
rt_vstub(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		  	       /* Number of ray/object pairs */
                  	     /* pointer to an application */
{
	register int    i;
	register struct seg *tmp_seg;
	struct seg	seghead;

	BU_LIST_INIT( &(seghead.l) );

	/* go through each ray/solid pair and call a scalar function */
	for (i = 0; i < n; i++) {
		if (stp[i] != 0){ /* skip call if solid table pointer is NULL */
			/* do scalar call, place results in segp array */
			if( rt_functab[stp[i]->st_id].ft_shot(stp[i], rp[i], ap, &seghead) <= 0 )  {
				SEG_MISS(segp[i]);
			} else {
				tmp_seg = BU_LIST_FIRST(seg, &(seghead.l) );
				BU_LIST_DEQUEUE( &(tmp_seg->l) );
				segp[i] = *tmp_seg; /* structure copy */
				RT_FREE_SEG(tmp_seg, ap->a_resource);
			}
		}
	}
}

/*
 *			R T _ P R _ L I B R A R Y _ V E R S I O N
 *
 *  In case anyone actually cares, print out library's compilation version.
 */
void
rt_pr_library_version(void)
{
	bu_log("%s", rt_version);
}

void
rt_zero_res_stats( struct resource *resp )
{
	RT_CK_RESOURCE( resp );

	resp->re_nshootray = 0;
	resp->re_nmiss_model = 0;

	resp->re_shots = 0;
	resp->re_shot_hit = 0;
	resp->re_shot_miss = 0;

	resp->re_prune_solrpp = 0;

	resp->re_ndup = 0;
	resp->re_nempty_cells = 0;

	resp->re_piece_shots = 0;
	resp->re_piece_shot_hit = 0;
	resp->re_piece_shot_miss = 0;
	resp->re_piece_ndup = 0;
}

/*
 *			R T _ A D D _ R E S _ S T A T S
 *
 *  To be called only in non-parallel mode, to tally up the statistics
 *  from the resource structure(s) into the rt instance structure.
 *
 *  Non-parallel programs should call
 *	rt_add_res_stats( rtip, RESOURCE_NULL );
 *  to have the default resource results tallied in.
 */
void
rt_add_res_stats(register struct rt_i *rtip, register struct resource *resp)
{
	RT_CK_RTI( rtip );

	if( resp == RESOURCE_NULL )  resp = &rt_uniresource;
	RT_CK_RESOURCE( resp );

	rtip->rti_nrays += resp->re_nshootray;
	rtip->nmiss_model += resp->re_nmiss_model;

	rtip->nshots += resp->re_shots + resp->re_piece_shots;
	rtip->nhits += resp->re_shot_hit + resp->re_piece_shot_hit;
	rtip->nmiss += resp->re_shot_miss + resp->re_piece_shot_miss;

	rtip->nmiss_solid += resp->re_prune_solrpp;

	rtip->ndup += resp->re_ndup + resp->re_piece_ndup;
	rtip->nempty_cells += resp->re_nempty_cells;

	/* Zero out resource totals, so repeated calls are not harmful */
	rt_zero_res_stats( resp );
}

/*
 *  Routines for plotting the progress of one ray through the model.  -Mike
 */
void
rt_3move_raydist(FILE *fp, struct xray *rayp, double dist)
{
	point_t	p;

	VJOIN1( p, rayp->r_pt, dist, rayp->r_dir );
	pdv_3move( fp, p );
}

void
rt_3cont_raydist(FILE *fp, struct xray *rayp, double dist)
{
	point_t	p;

	VJOIN1( p, rayp->r_pt, dist, rayp->r_dir );
	pdv_3cont( fp, p );
}

/*
		rt_plot_cell( cutp, &ss, &(waiting_segs.l), rtip);
 */
void
rt_plot_cell(const union cutter *cutp, const struct rt_shootray_status *ssp, struct bu_list *waiting_segs_hd, struct rt_i *rtip)
{
	char		buf[128];
	static int	fnum = 0;
	FILE		*fp;
	struct soltab	**stpp;
	struct application	*ap;

	RT_CK_RTI(rtip);
	RT_AP_CHECK(ssp->ap);
	RT_CK_RTI(ssp->ap->a_rt_i);
	ap = ssp->ap;

	sprintf( buf, "cell%d.pl", fnum++ );
	if( (fp = fopen( buf, "w" )) == NULL )  {
		perror(buf);
	}

	pl_color( fp, 0, 100, 0 );		/* green box for model RPP */

	/* Plot the model RPP, to provide some context */
	pdv_3space( fp, rtip->rti_pmin, rtip->rti_pmax );
	pdv_3box( fp, rtip->rti_pmin, rtip->rti_pmax );

	/* Plot the outline of this one cell */
	pl_color( fp, 80, 80, 250 );
	switch( cutp->cut_type )  {
	case CUT_BOXNODE:
		pdv_3box( fp, cutp->bn.bn_min, cutp->bn.bn_max );
		break;
	default:
		bu_log("cut_type = %d\n", cutp->cut_type );
		bu_bomb("Unknown cut_type\n");
	}

	if( cutp->bn.bn_len > 0 ) {
		/* Plot every solid listed in this cell */
		stpp = &(cutp->bn.bn_list[cutp->bn.bn_len-1]);
		for( ; stpp >= cutp->bn.bn_list; stpp-- )  {
			register struct soltab *stp = *stpp;

			rt_plot_solid( fp, rtip, stp, ap->a_resource );
		}
	}

	/* Plot interval of ray in box, in green */
	pl_color( fp, 100, 255, 200 );
	rt_3move_raydist( fp, &ap->a_ray, ssp->box_start );
	rt_3cont_raydist( fp, &ap->a_ray, ssp->box_end );

	if( bu_list_len( waiting_segs_hd ) <= 0 )  {
		/* No segments, just plot the whole ray */
		pl_color( fp, 255, 255, 0 );	/* yellow -- no segs */
		rt_3move_raydist( fp, &ap->a_ray, ssp->model_start );
		rt_3cont_raydist( fp, &ap->a_ray, ssp->box_start );
		rt_3move_raydist( fp, &ap->a_ray, ssp->box_end );
		rt_3cont_raydist( fp, &ap->a_ray, ssp->model_end );
	} else {
		/* Plot the segments awaiting boolweave. */
		struct seg	*segp;

		for( BU_LIST_FOR( segp, seg, waiting_segs_hd ) )  {
			RT_CK_SEG(segp);
			pl_color( fp, 255, 0, 0 );	/* red */
			rt_3move_raydist( fp, &ap->a_ray, segp->seg_in.hit_dist );
			rt_3cont_raydist( fp, &ap->a_ray, segp->seg_out.hit_dist );
		}
	}

	fclose(fp);
	bu_log("wrote %s\n", buf);
}
@


11.112
log
@change conf.h to a wrapped config.h
@
text
@d40 1
a40 1
static const char RCSshoot[] = "@@(#)$Header: /cvs/brlcad/librt/shoot.c,v 11.111 2004/04/05 08:48:58 morrison Exp $ (BRL)";
@


11.111
log
@merge of ansi-6-0-branch into HEAD
@
text
@d40 1
a40 1
static const char RCSshoot[] = "@@(#)$Header$ (BRL)";
d45 5
a49 1
#include "conf.h"
@


11.110
log
@update copyright to include span through 2003
@
text
@d40 1
a40 1
static const char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.109 2003/10/29 15:54:22 jra Exp $ (BRL)";
d63 1
a63 1
extern void	rt_plot_cell();		/* at end of file */
d82 1
a82 3
rt_res_pieces_init( resp, rtip )
struct resource	*resp;
struct rt_i	*rtip;
d111 1
a111 3
rt_res_pieces_clean( resp, rtip )
struct resource	*resp;
struct rt_i	*rtip;
d146 1
a146 4
rt_find_nugrid( nugnp, axis, val )
struct nugridnode	*nugnp;
int			 axis;
fastf_t			 val;
d185 1
a185 2
rt_advance_to_next_cell( ssp )
register struct rt_shootray_status	*ssp;
d782 1
a782 2
rt_shootray( ap )
register struct application *ap;
d1449 3
a1451 3
rt_cell_n_on_ray( ap, n )
register struct application *ap;
int	n;		/* First cell is #0 */
d1772 5
a1776 5
rt_DB_rpp( rp, invdir, min, max )
register struct xray *rp;
register const fastf_t *invdir;	/* inverses of rp->r_dir[] */
register const fastf_t *min;
register const fastf_t *max;
d1903 6
a1908 6
rt_vstub( stp, rp, segp, n, ap )
struct soltab	       *stp[]; /* An array of solid pointers */
struct xray		*rp[]; /* An array of ray pointers */
struct  seg            segp[]; /* array of segs (results returned) */
int		  	    n; /* Number of ray/object pairs */
struct application	*ap; /* pointer to an application */
d1938 1
a1938 1
rt_pr_library_version()
d1977 1
a1977 3
rt_add_res_stats( rtip, resp )
register struct rt_i		*rtip;
register struct resource	*resp;
d2004 1
a2004 4
rt_3move_raydist( fp, rayp, dist )
FILE		*fp;
struct xray	*rayp;
double		dist;
d2013 1
a2013 4
rt_3cont_raydist( fp, rayp, dist )
FILE		*fp;
struct xray	*rayp;
double		dist;
d2025 1
a2025 5
rt_plot_cell( cutp, ssp, waiting_segs_hd, rtip )
union cutter		*cutp;
struct rt_shootray_status	*ssp;
struct bu_list		*waiting_segs_hd;
struct rt_i		*rtip;
@


11.109
log
@replaced code blocks with calls to get_solidbitv()
new routine added: rt_zero_res_stats() to zero resource stats.
@
text
@d36 1
a36 1
 *	This software is Copyright (C) 2000 by the United States Army
d40 1
a40 1
static const char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.108 2003/07/11 14:16:20 jra Exp $ (BRL)";
@


11.108
log
@Mods to rt_shootray(). When a primitive had "pieces" behind the ray start point, we were getting
incorrect results. This modification looks behind the ray start point at pieces from primitives
that have bounding boxes extending behind the ray start point.
@
text
@d40 1
a40 1
static const char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.107 2003/07/01 12:18:37 jra Exp $ (BRL)";
d692 1
a692 8
	if( BU_LIST_IS_EMPTY( &resp->re_solid_bitv ) )  {
		solidbits = bu_bitv_new( rtip->nsolids );
	} else {
		solidbits = BU_LIST_FIRST( bu_bitv, &resp->re_solid_bitv );
		BU_LIST_DEQUEUE( &solidbits->l );
		BU_CK_BITV(solidbits);
		BU_BITV_NBITS_CHECK( solidbits, rtip->nsolids );
	}
d891 1
a891 8
	if( BU_LIST_IS_EMPTY( &resp->re_solid_bitv ) )  {
		solidbits = bu_bitv_new( rtip->nsolids );
	} else {
		solidbits = BU_LIST_FIRST( bu_bitv, &resp->re_solid_bitv );
		BU_LIST_DEQUEUE( &solidbits->l );
		BU_CK_BITV(solidbits);
		BU_BITV_NBITS_CHECK( solidbits, rtip->nsolids );
	}
d1053 1
a1053 9
			if( BU_LIST_IS_EMPTY( &resp->re_solid_bitv ) )  {
				backbits = bu_bitv_new( rtip->nsolids );
				BU_CK_BITV(backbits);
			} else {
				backbits = BU_LIST_FIRST( bu_bitv, &resp->re_solid_bitv );
				BU_LIST_DEQUEUE( &backbits->l );
				BU_CK_BITV(backbits);
				BU_BITV_NBITS_CHECK( backbits, rtip->nsolids );
			}
d1952 23
d2008 1
a2008 16
	resp->re_nshootray = 0;
	resp->re_nmiss_model = 0;

	resp->re_shots = 0;
	resp->re_shot_hit = 0;
	resp->re_shot_miss = 0;

	resp->re_prune_solrpp = 0;

	resp->re_ndup = 0;
	resp->re_nempty_cells = 0;

	resp->re_piece_shots = 0;
	resp->re_piece_shot_hit = 0;
	resp->re_piece_shot_miss = 0;
	resp->re_piece_ndup = 0;
@


11.108.4.1
log
@updates from HEAD, part 1
@
text
@d40 1
a40 1
static const char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.109 2003/10/29 15:54:22 jra Exp $ (BRL)";
d692 8
a699 1
	solidbits = get_solidbitv( rtip->nsolids, resp );
d898 8
a905 1
	solidbits = get_solidbitv( rtip->nsolids, resp );
d1067 9
a1075 1
			backbits = get_solidbitv( rtip->nsolids, resp );
a1973 23
void
rt_zero_res_stats( struct resource *resp )
{
	RT_CK_RESOURCE( resp );

	resp->re_nshootray = 0;
	resp->re_nmiss_model = 0;

	resp->re_shots = 0;
	resp->re_shot_hit = 0;
	resp->re_shot_miss = 0;

	resp->re_prune_solrpp = 0;

	resp->re_ndup = 0;
	resp->re_nempty_cells = 0;

	resp->re_piece_shots = 0;
	resp->re_piece_shot_hit = 0;
	resp->re_piece_shot_miss = 0;
	resp->re_piece_ndup = 0;
}

d2007 16
a2022 1
	rt_zero_res_stats( resp );
@


11.108.4.2
log
@merge from HEAD
@
text
@d36 1
a36 1
 *	This software is Copyright (C) 2000-2004 by the United States Army
d40 1
a40 1
static const char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.110 2004/02/02 17:39:29 morrison Exp $ (BRL)";
@


11.108.4.3
log
@merge from head
@
text
@d40 1
a40 1
static const char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.108.4.2 2004/02/12 18:37:47 erikg Exp $ (BRL)";
@


11.107
log
@Mod to rt_shootray(). If we have pieces present, start tracing the ray at the model
minimum to avoid missing entrance hits at negative distances.
@
text
@d40 1
a40 1
static const char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.106 2003/03/28 02:45:33 jra Exp $ (BRL)";
d665 103
d806 2
d1038 1
a1038 1
	 *	along the positive direction of the ray, all its intersections would be calculated.
d1041 9
a1049 4
	 *	I have modified the setting of "ss.box_start", to allow it to remain at the model minimum
	 *	if we have solids with pieces present. This means that we will trace the ray through the
	 *	entire model if there are any "pieces" in the model (performance loss for the sake of
	 *	correct results).
d1051 2
d1055 33
a1087 2
	if( ss.box_start < BACKING_DIST && ap->a_rt_i->rti_nsolids_with_pieces < 1 )
		ss.box_start = BACKING_DIST; /* Only look a little bit behind */
d1152 7
a1198 1

d1230 1
a1230 1
		if( cutp->bn.bn_len > 0 )  {
d1441 4
@


11.106
log
@rt_plot_cell() was trying to plot solids in a space partition cell even if there are no solids in it
@
text
@d40 1
a40 1
static const char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.105 2003/01/20 02:06:59 jra Exp $ (BRL)";
d930 10
d943 1
a943 2

	if( ss.box_start < BACKING_DIST )
@


11.106.2.1
log
@updated for merging
@
text
@d40 1
a40 1
static const char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.108 2003/07/11 14:16:20 jra Exp $ (BRL)";
a664 103
/*		R T _ F I N D _ B A C K I N G _ D I S T
 *
 *	This routine traces a ray from its start point to model exit through the space partitioning tree.
 *	The objective is to find all primitives that use "pieces" and also have a bounding box that
 *	extends behind the ray start point. The minimum (most negative) intersection with such a bounding
 *	box is returned. The "backbits" bit vector (provided by the caller) gets a bit set for every
 *	primitive that meets the above criteria.
 *	No primitive intersections are performed.
 *
 *	XXXX This routine does not work for NUGRID XXXX
 */
fastf_t
rt_find_backing_dist( struct rt_shootray_status *ss, struct bu_bitv *backbits ) {
	fastf_t min_backing_dist=BACKING_DIST;
	fastf_t cur_dist=0.0;
	point_t cur_pt;
	union cutter *cutp;
	struct bu_bitv *solidbits;
	struct xray ray;
	struct resource	*resp;
	struct rt_i *rtip;
	int i;

	resp = ss->ap->a_resource;
	rtip = ss->ap->a_rt_i;

	/* get a bit vector of our own to avoid duplicate bounding box intersection calculations */
	if( BU_LIST_IS_EMPTY( &resp->re_solid_bitv ) )  {
		solidbits = bu_bitv_new( rtip->nsolids );
	} else {
		solidbits = BU_LIST_FIRST( bu_bitv, &resp->re_solid_bitv );
		BU_LIST_DEQUEUE( &solidbits->l );
		BU_CK_BITV(solidbits);
		BU_BITV_NBITS_CHECK( solidbits, rtip->nsolids );
	}
	bu_bitv_clear(solidbits);

	ray = ss->ap->a_ray;	/* struct copy, don't mess with the original */

	/* cur_dist keeps track of where we are along the ray */
	/* stop when cur_dist reaches far intersection of ray and model bounding box */
	while( cur_dist <= ss->ap->a_ray.r_max ) {
		/* calculate the current point along the ray */
		VJOIN1( cur_pt, ss->ap->a_ray.r_pt, cur_dist, ss->ap->a_ray.r_dir );

		/* descend into the space partitioning tree based on this point */
		cutp = &ss->ap->a_rt_i->rti_CutHead;
		while( cutp->cut_type == CUT_CUTNODE ) {
			if( cur_pt[cutp->cn.cn_axis] >= cutp->cn.cn_point )  {
				cutp=cutp->cn.cn_r;
			}  else  {
				cutp=cutp->cn.cn_l;
			}
		}

		/* we are now at the box node for the current point */
		/* check if the ray intersects this box */
		if( !rt_in_rpp( &ray, ss->inv_dir, cutp->bn.bn_min, cutp->bn.bn_max ) ) {
			/* ray does not intersect this cell
			 * one of two situations must exist:
			 *	1. ray starts outside model bounding box (no need for these calculations)
			 *	2. we have proceeded beyond end of model bounding box (we are done)
			 * in either case, we are finished
			 */
			goto done;
		} else {
			/* increment cur_dist into next cell for next execution of this loop */
			cur_dist = ray.r_max + OFFSET_DIST;
		}

		/* process this box node (look at all the pieces) */
		for( i=0 ; i<cutp->bn.bn_piecelen ; i++ ) {
			struct rt_piecelist *plp=&cutp->bn.bn_piecelist[i];

			if( BU_BITTEST( solidbits, plp->stp->st_bit ) == 0 ) {
				/* we haven't looked at this primitive before */
				if( rt_in_rpp( &ray, ss->inv_dir, plp->stp->st_min, plp->stp->st_max ) ) {
					/* ray intersects this primitive bounding box */

					if( ray.r_min < BACKING_DIST ) {
						if( ray.r_min < min_backing_dist ) {
							/* move our backing distance back to catch this one */
							min_backing_dist = ray.r_min;
						}

						/* add this one to our list of primitives to check */
						BU_BITSET( backbits, plp->stp->st_bit );
					}
				}
				/* set bit so we don't repeat this calculation */
				BU_BITSET( solidbits, plp->stp->st_bit );
			}
		}
	}
 done:
	/* put our bit vector on the resource list */
	BU_CK_BITV(solidbits);
	BU_LIST_APPEND( &resp->re_solid_bitv, &solidbits->l );

	/* return our minimum backing distance */
	return min_backing_dist;
}

a702 2
	struct bu_bitv		*backbits=NULL;	/* bits for all solids using pieces that need to be intersected behind
						   the the ray start point */
a929 15
	 *
	 *  Modification by JRA for pieces methodology:
	 *	The original algorithm here assumed that if we encountered any primitive
	 *	along the positive direction of the ray, ALL its intersections would be calculated.
	 *	With pieces, we may see only an exit hit if the entrance piece is in a space partition cell
	 *	that is more than "BACKING_DIST" behind the ray start point (leading to incorrect results).
	 *	I have modified the setting of "ss.box_start" (when pieces are present and the ray start point is
	 *	inside the model bounding box) as follows (see rt_find_backing_dist()):
	 *		The ray is traced through the space partitioning tree
	 *		The ray is intersected with the bounding box of each primitive using pieces in each cell
	 *		The minimum of all these intersections is set as the initial "ss.box_start".
	 *		The "backbits" bit vector has a bit set for each of the primitives using pieces that have
	 *			bounding boxes that extend behind the ray start point
	 *	Further below (in the "pieces" loop), I have added code to ignore primitives that do not have a bit
	 *	set in the backbits vector when we are behind the ray start point.
a930 2

	/* these two values set the point where the ray tracing actually begins and ends */
d934 2
a935 32
	if( ap->a_rt_i->rti_nsolids_with_pieces > 0 ) {
		/* pieces are present */
		if( ss.box_start < BACKING_DIST ) {
			/* the first ray intersection with the model bounding box is more than BACKING_DIST
			 * behind the ray start point
			 */

			/* get a bit vector to keep track of which primitives need to be intersected
			 * behind the ray start point (those having bounding boxes extending behind the
			 * ray start point and using pieces)
			 */
			if( BU_LIST_IS_EMPTY( &resp->re_solid_bitv ) )  {
				backbits = bu_bitv_new( rtip->nsolids );
				BU_CK_BITV(backbits);
			} else {
				backbits = BU_LIST_FIRST( bu_bitv, &resp->re_solid_bitv );
				BU_LIST_DEQUEUE( &backbits->l );
				BU_CK_BITV(backbits);
				BU_BITV_NBITS_CHECK( backbits, rtip->nsolids );
			}
			bu_bitv_clear(backbits);

			/* call "rt_find_backing_dist()" to calculate the required
			 * start point for calculation, and to fill in the "backbits" bit vector
			 */
			ss.box_start = rt_find_backing_dist( &ss, backbits );
		}
	} else {
		/* no pieces present, use the old scheme */
		if( ss.box_start < BACKING_DIST )
			ss.box_start = BACKING_DIST; /* Only look a little bit behind */
	}
a999 7
				if( backbits && ss.box_end < BACKING_DIST && BU_BITTEST( backbits, stp->st_bit ) == 0 ) {
					/* we are behind the ray start point and this primitive is not one
					 * that we need to intersect back here
					 */
					continue;
				}

d1040 1
d1072 1
a1072 1
		if( cutp->bn.bn_len > 0 && ss.box_end >= BACKING_DIST )  {
a1282 4
	if( backbits ) {
		BU_CK_BITV(backbits);
		BU_LIST_APPEND( &resp->re_solid_bitv, &backbits->l );
	}
@


11.105
log
@calculation (in rt_shootray) and use (in rt_bot_shot) of new applictaion structure field (a_inv_dir)
@
text
@d40 1
a40 1
static const char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.104 2002/10/19 01:54:15 jra Exp $ (BRL)";
d1933 5
a1937 4
	/* Plot every solid listed in this cell */
	stpp = &(cutp->bn.bn_list[cutp->bn.bn_len-1]);
	for( ; stpp >= cutp->bn.bn_list; stpp-- )  {
		register struct soltab *stp = *stpp;
d1939 2
a1940 1
		rt_plot_solid( fp, rtip, stp, ap->a_resource );
@


11.104
log
@rt_shootray was calculating new "pending_hit" distance at the wrong place,
resulting in value being overwritten before use. Value is now calculated immediately
befoere use.
@
text
@d40 1
a40 1
static const char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.103 2002/08/20 17:08:09 jra Exp $ (BRL)";
d877 1
@


11.103
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d40 1
a40 1
static const char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.101 2002/02/28 02:47:37 jra Exp $ (BRL)";
a1067 14
			if( ap->a_onehit != 0 && BU_PTBL_LEN( &resp->re_pieces_pending ) > 0 )  {
				/* Find the lowest pending mindist, that's as far as boolfinal can progress to */
				struct rt_piecestate **psp;
				for( BU_PTBL_FOR( psp, (struct rt_piecestate **), &resp->re_pieces_pending ) )  {
					FAST fastf_t dist;

					dist = (*psp)->mindist;
					BU_ASSERT_DOUBLE( dist, <, INFINITY );
					if( dist < pending_hit )  {
						pending_hit = dist;
						if(debug_shoot) bu_log("pending_hit lowered to %g by %s\n", pending_hit, (*psp)->stp->st_name);
					}
				}
			}
d1156 15
@


11.103.4.1
log
@sync to HEAD...
@
text
@d36 1
a36 1
 *	This software is Copyright (C) 2000-2004 by the United States Army
d40 1
a40 1
static const char RCSshoot[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/shoot.c,v 11.110 2004/02/02 17:39:29 morrison Exp $ (BRL)";
a664 96
/*		R T _ F I N D _ B A C K I N G _ D I S T
 *
 *	This routine traces a ray from its start point to model exit through the space partitioning tree.
 *	The objective is to find all primitives that use "pieces" and also have a bounding box that
 *	extends behind the ray start point. The minimum (most negative) intersection with such a bounding
 *	box is returned. The "backbits" bit vector (provided by the caller) gets a bit set for every
 *	primitive that meets the above criteria.
 *	No primitive intersections are performed.
 *
 *	XXXX This routine does not work for NUGRID XXXX
 */
fastf_t
rt_find_backing_dist( struct rt_shootray_status *ss, struct bu_bitv *backbits ) {
	fastf_t min_backing_dist=BACKING_DIST;
	fastf_t cur_dist=0.0;
	point_t cur_pt;
	union cutter *cutp;
	struct bu_bitv *solidbits;
	struct xray ray;
	struct resource	*resp;
	struct rt_i *rtip;
	int i;

	resp = ss->ap->a_resource;
	rtip = ss->ap->a_rt_i;

	/* get a bit vector of our own to avoid duplicate bounding box intersection calculations */
	solidbits = get_solidbitv( rtip->nsolids, resp );
	bu_bitv_clear(solidbits);

	ray = ss->ap->a_ray;	/* struct copy, don't mess with the original */

	/* cur_dist keeps track of where we are along the ray */
	/* stop when cur_dist reaches far intersection of ray and model bounding box */
	while( cur_dist <= ss->ap->a_ray.r_max ) {
		/* calculate the current point along the ray */
		VJOIN1( cur_pt, ss->ap->a_ray.r_pt, cur_dist, ss->ap->a_ray.r_dir );

		/* descend into the space partitioning tree based on this point */
		cutp = &ss->ap->a_rt_i->rti_CutHead;
		while( cutp->cut_type == CUT_CUTNODE ) {
			if( cur_pt[cutp->cn.cn_axis] >= cutp->cn.cn_point )  {
				cutp=cutp->cn.cn_r;
			}  else  {
				cutp=cutp->cn.cn_l;
			}
		}

		/* we are now at the box node for the current point */
		/* check if the ray intersects this box */
		if( !rt_in_rpp( &ray, ss->inv_dir, cutp->bn.bn_min, cutp->bn.bn_max ) ) {
			/* ray does not intersect this cell
			 * one of two situations must exist:
			 *	1. ray starts outside model bounding box (no need for these calculations)
			 *	2. we have proceeded beyond end of model bounding box (we are done)
			 * in either case, we are finished
			 */
			goto done;
		} else {
			/* increment cur_dist into next cell for next execution of this loop */
			cur_dist = ray.r_max + OFFSET_DIST;
		}

		/* process this box node (look at all the pieces) */
		for( i=0 ; i<cutp->bn.bn_piecelen ; i++ ) {
			struct rt_piecelist *plp=&cutp->bn.bn_piecelist[i];

			if( BU_BITTEST( solidbits, plp->stp->st_bit ) == 0 ) {
				/* we haven't looked at this primitive before */
				if( rt_in_rpp( &ray, ss->inv_dir, plp->stp->st_min, plp->stp->st_max ) ) {
					/* ray intersects this primitive bounding box */

					if( ray.r_min < BACKING_DIST ) {
						if( ray.r_min < min_backing_dist ) {
							/* move our backing distance back to catch this one */
							min_backing_dist = ray.r_min;
						}

						/* add this one to our list of primitives to check */
						BU_BITSET( backbits, plp->stp->st_bit );
					}
				}
				/* set bit so we don't repeat this calculation */
				BU_BITSET( solidbits, plp->stp->st_bit );
			}
		}
	}
 done:
	/* put our bit vector on the resource list */
	BU_CK_BITV(solidbits);
	BU_LIST_APPEND( &resp->re_solid_bitv, &solidbits->l );

	/* return our minimum backing distance */
	return min_backing_dist;
}

a702 2
	struct bu_bitv		*backbits=NULL;	/* bits for all solids using pieces that need to be intersected behind
						   the the ray start point */
d793 8
a800 1
	solidbits = get_solidbitv( rtip->nsolids, resp );
a876 1
	VMOVE( ap->a_inv_dir, ss.inv_dir );
a928 15
	 *
	 *  Modification by JRA for pieces methodology:
	 *	The original algorithm here assumed that if we encountered any primitive
	 *	along the positive direction of the ray, ALL its intersections would be calculated.
	 *	With pieces, we may see only an exit hit if the entrance piece is in a space partition cell
	 *	that is more than "BACKING_DIST" behind the ray start point (leading to incorrect results).
	 *	I have modified the setting of "ss.box_start" (when pieces are present and the ray start point is
	 *	inside the model bounding box) as follows (see rt_find_backing_dist()):
	 *		The ray is traced through the space partitioning tree
	 *		The ray is intersected with the bounding box of each primitive using pieces in each cell
	 *		The minimum of all these intersections is set as the initial "ss.box_start".
	 *		The "backbits" bit vector has a bit set for each of the primitives using pieces that have
	 *			bounding boxes that extend behind the ray start point
	 *	Further below (in the "pieces" loop), I have added code to ignore primitives that do not have a bit
	 *	set in the backbits vector when we are behind the ray start point.
a929 2

	/* these two values set the point where the ray tracing actually begins and ends */
d933 2
a934 24
	if( ap->a_rt_i->rti_nsolids_with_pieces > 0 ) {
		/* pieces are present */
		if( ss.box_start < BACKING_DIST ) {
			/* the first ray intersection with the model bounding box is more than BACKING_DIST
			 * behind the ray start point
			 */

			/* get a bit vector to keep track of which primitives need to be intersected
			 * behind the ray start point (those having bounding boxes extending behind the
			 * ray start point and using pieces)
			 */
			backbits = get_solidbitv( rtip->nsolids, resp );
			bu_bitv_clear(backbits);

			/* call "rt_find_backing_dist()" to calculate the required
			 * start point for calculation, and to fill in the "backbits" bit vector
			 */
			ss.box_start = rt_find_backing_dist( &ss, backbits );
		}
	} else {
		/* no pieces present, use the old scheme */
		if( ss.box_start < BACKING_DIST )
			ss.box_start = BACKING_DIST; /* Only look a little bit behind */
	}
a998 7
				if( backbits && ss.box_end < BACKING_DIST && BU_BITTEST( backbits, stp->st_bit ) == 0 ) {
					/* we are behind the ray start point and this primitive is not one
					 * that we need to intersect back here
					 */
					continue;
				}

d1039 1
d1068 14
d1085 1
a1085 1
		if( cutp->bn.bn_len > 0 && ss.box_end >= BACKING_DIST )  {
a1170 15
				if( BU_PTBL_LEN( &resp->re_pieces_pending ) > 0 )  {
					/* Find the lowest pending mindist, that's as far as boolfinal can progress to */
					struct rt_piecestate **psp;
					for( BU_PTBL_FOR( psp, (struct rt_piecestate **), &resp->re_pieces_pending ) )  {
						FAST fastf_t dist;
						
						dist = (*psp)->mindist;
						BU_ASSERT_DOUBLE( dist, <, INFINITY );
						if( dist < pending_hit )  {
							pending_hit = dist;
							if(debug_shoot) bu_log("pending_hit lowered to %g by %s\n", pending_hit, (*psp)->stp->st_name);
						}
					}
				}

a1280 4
	if( backbits ) {
		BU_CK_BITV(backbits);
		BU_LIST_APPEND( &resp->re_solid_bitv, &backbits->l );
	}
a1809 23
void
rt_zero_res_stats( struct resource *resp )
{
	RT_CK_RESOURCE( resp );

	resp->re_nshootray = 0;
	resp->re_nmiss_model = 0;

	resp->re_shots = 0;
	resp->re_shot_hit = 0;
	resp->re_shot_miss = 0;

	resp->re_prune_solrpp = 0;

	resp->re_ndup = 0;
	resp->re_nempty_cells = 0;

	resp->re_piece_shots = 0;
	resp->re_piece_shot_hit = 0;
	resp->re_piece_shot_miss = 0;
	resp->re_piece_ndup = 0;
}

d1843 16
a1858 1
	rt_zero_res_stats( resp );
d1931 4
a1934 5
	if( cutp->bn.bn_len > 0 ) {
		/* Plot every solid listed in this cell */
		stpp = &(cutp->bn.bn_list[cutp->bn.bn_len-1]);
		for( ; stpp >= cutp->bn.bn_list; stpp-- )  {
			register struct soltab *stp = *stpp;
d1936 1
a1936 2
			rt_plot_solid( fp, rtip, stp, ap->a_resource );
		}
@


11.103.2.1
log
@Initial ANSIfication
@
text
@d40 1
a40 1
static const char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.103 2002/08/20 17:08:09 jra Exp $ (BRL)";
d63 1
a63 1
extern void	rt_plot_cell(const union cutter *cutp, struct rt_shootray_status *ssp, struct bu_list *waiting_segs_hd, struct rt_i *rtip);		/* at end of file */
d82 3
a84 1
rt_res_pieces_init(struct resource *resp, struct rt_i *rtip)
d113 3
a115 1
rt_res_pieces_clean(struct resource *resp, struct rt_i *rtip)
d150 4
a153 1
rt_find_nugrid(const struct nugridnode *nugnp, int axis, fastf_t val)
d192 2
a193 1
rt_advance_to_next_cell(register struct rt_shootray_status *ssp)
d694 2
a695 1
rt_shootray(register struct application *ap)
d1316 3
a1318 3
rt_cell_n_on_ray(register struct application *ap, int n)
                                
   	  		/* First cell is #0 */
d1639 5
a1643 5
rt_DB_rpp(register struct xray *rp, register const fastf_t *invdir, register const fastf_t *min, register const fastf_t *max)
                         
                               	/* inverses of rp->r_dir[] */
                            
                            
d1770 6
a1775 6
rt_vstub(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		  	       /* Number of ray/object pairs */
                  	     /* pointer to an application */
d1805 1
a1805 1
rt_pr_library_version(void)
d1821 3
a1823 1
rt_add_res_stats(register struct rt_i *rtip, register struct resource *resp)
d1865 4
a1868 1
rt_3move_raydist(FILE *fp, struct xray *rayp, double dist)
d1877 4
a1880 1
rt_3cont_raydist(FILE *fp, struct xray *rayp, double dist)
d1892 5
a1896 1
rt_plot_cell(const union cutter *cutp, struct rt_shootray_status *ssp, struct bu_list *waiting_segs_hd, struct rt_i *rtip)
@


11.103.2.2
log
@sync branch with HEAD
@
text
@d36 1
a36 1
 *	This software is Copyright (C) 2000-2004 by the United States Army
d40 1
a40 1
static const char RCSshoot[] = "@@(#)$Header$ (BRL)";
a656 96
/*		R T _ F I N D _ B A C K I N G _ D I S T
 *
 *	This routine traces a ray from its start point to model exit through the space partitioning tree.
 *	The objective is to find all primitives that use "pieces" and also have a bounding box that
 *	extends behind the ray start point. The minimum (most negative) intersection with such a bounding
 *	box is returned. The "backbits" bit vector (provided by the caller) gets a bit set for every
 *	primitive that meets the above criteria.
 *	No primitive intersections are performed.
 *
 *	XXXX This routine does not work for NUGRID XXXX
 */
fastf_t
rt_find_backing_dist( struct rt_shootray_status *ss, struct bu_bitv *backbits ) {
	fastf_t min_backing_dist=BACKING_DIST;
	fastf_t cur_dist=0.0;
	point_t cur_pt;
	union cutter *cutp;
	struct bu_bitv *solidbits;
	struct xray ray;
	struct resource	*resp;
	struct rt_i *rtip;
	int i;

	resp = ss->ap->a_resource;
	rtip = ss->ap->a_rt_i;

	/* get a bit vector of our own to avoid duplicate bounding box intersection calculations */
	solidbits = get_solidbitv( rtip->nsolids, resp );
	bu_bitv_clear(solidbits);

	ray = ss->ap->a_ray;	/* struct copy, don't mess with the original */

	/* cur_dist keeps track of where we are along the ray */
	/* stop when cur_dist reaches far intersection of ray and model bounding box */
	while( cur_dist <= ss->ap->a_ray.r_max ) {
		/* calculate the current point along the ray */
		VJOIN1( cur_pt, ss->ap->a_ray.r_pt, cur_dist, ss->ap->a_ray.r_dir );

		/* descend into the space partitioning tree based on this point */
		cutp = &ss->ap->a_rt_i->rti_CutHead;
		while( cutp->cut_type == CUT_CUTNODE ) {
			if( cur_pt[cutp->cn.cn_axis] >= cutp->cn.cn_point )  {
				cutp=cutp->cn.cn_r;
			}  else  {
				cutp=cutp->cn.cn_l;
			}
		}

		/* we are now at the box node for the current point */
		/* check if the ray intersects this box */
		if( !rt_in_rpp( &ray, ss->inv_dir, cutp->bn.bn_min, cutp->bn.bn_max ) ) {
			/* ray does not intersect this cell
			 * one of two situations must exist:
			 *	1. ray starts outside model bounding box (no need for these calculations)
			 *	2. we have proceeded beyond end of model bounding box (we are done)
			 * in either case, we are finished
			 */
			goto done;
		} else {
			/* increment cur_dist into next cell for next execution of this loop */
			cur_dist = ray.r_max + OFFSET_DIST;
		}

		/* process this box node (look at all the pieces) */
		for( i=0 ; i<cutp->bn.bn_piecelen ; i++ ) {
			struct rt_piecelist *plp=&cutp->bn.bn_piecelist[i];

			if( BU_BITTEST( solidbits, plp->stp->st_bit ) == 0 ) {
				/* we haven't looked at this primitive before */
				if( rt_in_rpp( &ray, ss->inv_dir, plp->stp->st_min, plp->stp->st_max ) ) {
					/* ray intersects this primitive bounding box */

					if( ray.r_min < BACKING_DIST ) {
						if( ray.r_min < min_backing_dist ) {
							/* move our backing distance back to catch this one */
							min_backing_dist = ray.r_min;
						}

						/* add this one to our list of primitives to check */
						BU_BITSET( backbits, plp->stp->st_bit );
					}
				}
				/* set bit so we don't repeat this calculation */
				BU_BITSET( solidbits, plp->stp->st_bit );
			}
		}
	}
 done:
	/* put our bit vector on the resource list */
	BU_CK_BITV(solidbits);
	BU_LIST_APPEND( &resp->re_solid_bitv, &solidbits->l );

	/* return our minimum backing distance */
	return min_backing_dist;
}

a693 2
	struct bu_bitv		*backbits=NULL;	/* bits for all solids using pieces that need to be intersected behind
						   the the ray start point */
d784 8
a791 1
	solidbits = get_solidbitv( rtip->nsolids, resp );
a867 1
	VMOVE( ap->a_inv_dir, ss.inv_dir );
a919 15
	 *
	 *  Modification by JRA for pieces methodology:
	 *	The original algorithm here assumed that if we encountered any primitive
	 *	along the positive direction of the ray, ALL its intersections would be calculated.
	 *	With pieces, we may see only an exit hit if the entrance piece is in a space partition cell
	 *	that is more than "BACKING_DIST" behind the ray start point (leading to incorrect results).
	 *	I have modified the setting of "ss.box_start" (when pieces are present and the ray start point is
	 *	inside the model bounding box) as follows (see rt_find_backing_dist()):
	 *		The ray is traced through the space partitioning tree
	 *		The ray is intersected with the bounding box of each primitive using pieces in each cell
	 *		The minimum of all these intersections is set as the initial "ss.box_start".
	 *		The "backbits" bit vector has a bit set for each of the primitives using pieces that have
	 *			bounding boxes that extend behind the ray start point
	 *	Further below (in the "pieces" loop), I have added code to ignore primitives that do not have a bit
	 *	set in the backbits vector when we are behind the ray start point.
a920 2

	/* these two values set the point where the ray tracing actually begins and ends */
d924 2
a925 24
	if( ap->a_rt_i->rti_nsolids_with_pieces > 0 ) {
		/* pieces are present */
		if( ss.box_start < BACKING_DIST ) {
			/* the first ray intersection with the model bounding box is more than BACKING_DIST
			 * behind the ray start point
			 */

			/* get a bit vector to keep track of which primitives need to be intersected
			 * behind the ray start point (those having bounding boxes extending behind the
			 * ray start point and using pieces)
			 */
			backbits = get_solidbitv( rtip->nsolids, resp );
			bu_bitv_clear(backbits);

			/* call "rt_find_backing_dist()" to calculate the required
			 * start point for calculation, and to fill in the "backbits" bit vector
			 */
			ss.box_start = rt_find_backing_dist( &ss, backbits );
		}
	} else {
		/* no pieces present, use the old scheme */
		if( ss.box_start < BACKING_DIST )
			ss.box_start = BACKING_DIST; /* Only look a little bit behind */
	}
a989 7
				if( backbits && ss.box_end < BACKING_DIST && BU_BITTEST( backbits, stp->st_bit ) == 0 ) {
					/* we are behind the ray start point and this primitive is not one
					 * that we need to intersect back here
					 */
					continue;
				}

d1030 1
d1059 14
d1076 1
a1076 1
		if( cutp->bn.bn_len > 0 && ss.box_end >= BACKING_DIST )  {
a1161 15
				if( BU_PTBL_LEN( &resp->re_pieces_pending ) > 0 )  {
					/* Find the lowest pending mindist, that's as far as boolfinal can progress to */
					struct rt_piecestate **psp;
					for( BU_PTBL_FOR( psp, (struct rt_piecestate **), &resp->re_pieces_pending ) )  {
						FAST fastf_t dist;
						
						dist = (*psp)->mindist;
						BU_ASSERT_DOUBLE( dist, <, INFINITY );
						if( dist < pending_hit )  {
							pending_hit = dist;
							if(debug_shoot) bu_log("pending_hit lowered to %g by %s\n", pending_hit, (*psp)->stp->st_name);
						}
					}
				}

a1271 4
	if( backbits ) {
		BU_CK_BITV(backbits);
		BU_LIST_APPEND( &resp->re_solid_bitv, &backbits->l );
	}
a1800 23
void
rt_zero_res_stats( struct resource *resp )
{
	RT_CK_RESOURCE( resp );

	resp->re_nshootray = 0;
	resp->re_nmiss_model = 0;

	resp->re_shots = 0;
	resp->re_shot_hit = 0;
	resp->re_shot_miss = 0;

	resp->re_prune_solrpp = 0;

	resp->re_ndup = 0;
	resp->re_nempty_cells = 0;

	resp->re_piece_shots = 0;
	resp->re_piece_shot_hit = 0;
	resp->re_piece_shot_miss = 0;
	resp->re_piece_ndup = 0;
}

d1832 16
a1847 1
	rt_zero_res_stats( resp );
d1910 4
a1913 5
	if( cutp->bn.bn_len > 0 ) {
		/* Plot every solid listed in this cell */
		stpp = &(cutp->bn.bn_list[cutp->bn.bn_len-1]);
		for( ; stpp >= cutp->bn.bn_list; stpp-- )  {
			register struct soltab *stp = *stpp;
d1915 1
a1915 2
			rt_plot_solid( fp, rtip, stp, ap->a_resource );
		}
@


11.103.2.3
log
@clean up head merge into ansi
@
text
@d63 1
a63 1
extern void	rt_plot_cell(const union cutter *cutp, const struct rt_shootray_status *ssp, struct bu_list *waiting_segs_hd, struct rt_i *rtip);		/* at end of file */
d2025 1
a2025 1
rt_plot_cell(const union cutter *cutp, const struct rt_shootray_status *ssp, struct bu_list *waiting_segs_hd, struct rt_i *rtip)
@


11.102
log
@Converted from K&R to ANSI C - RFH
@
text
@d63 1
a63 1
extern void	rt_plot_cell(const union cutter *cutp, struct rt_shootray_status *ssp, struct bu_list *waiting_segs_hd, struct rt_i *rtip);		/* at end of file */
d82 3
a84 1
rt_res_pieces_init(struct resource *resp, struct rt_i *rtip)
d113 3
a115 1
rt_res_pieces_clean(struct resource *resp, struct rt_i *rtip)
d150 4
a153 1
rt_find_nugrid(const struct nugridnode *nugnp, int axis, fastf_t val)
d192 2
a193 1
rt_advance_to_next_cell(register struct rt_shootray_status *ssp)
d694 2
a695 1
rt_shootray(register struct application *ap)
d1316 3
a1318 3
rt_cell_n_on_ray(register struct application *ap, int n)
                                
   	  		/* First cell is #0 */
d1639 5
a1643 5
rt_DB_rpp(register struct xray *rp, register const fastf_t *invdir, register const fastf_t *min, register const fastf_t *max)
                         
                               	/* inverses of rp->r_dir[] */
                            
                            
d1770 6
a1775 6
rt_vstub(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		  	       /* Number of ray/object pairs */
                  	     /* pointer to an application */
d1805 1
a1805 1
rt_pr_library_version(void)
d1821 3
a1823 1
rt_add_res_stats(register struct rt_i *rtip, register struct resource *resp)
d1865 4
a1868 1
rt_3move_raydist(FILE *fp, struct xray *rayp, double dist)
d1877 4
a1880 1
rt_3cont_raydist(FILE *fp, struct xray *rayp, double dist)
d1892 5
a1896 1
rt_plot_cell(const union cutter *cutp, struct rt_shootray_status *ssp, struct bu_list *waiting_segs_hd, struct rt_i *rtip)
@


11.101
log
@rt_res_pieces_clean() now sets rtip->rti_nsolids_with_pieces to zero
@
text
@d40 1
a40 1
static const char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.100 2002/01/10 18:12:41 butler Exp $ (BRL)";
d63 1
a63 1
extern void	rt_plot_cell();		/* at end of file */
d82 1
a82 3
rt_res_pieces_init( resp, rtip )
struct resource	*resp;
struct rt_i	*rtip;
d111 1
a111 3
rt_res_pieces_clean( resp, rtip )
struct resource	*resp;
struct rt_i	*rtip;
d146 1
a146 4
rt_find_nugrid( nugnp, axis, val )
struct nugridnode	*nugnp;
int			 axis;
fastf_t			 val;
d185 1
a185 2
rt_advance_to_next_cell( ssp )
register struct rt_shootray_status	*ssp;
d686 1
a686 2
rt_shootray( ap )
register struct application *ap;
d1307 3
a1309 3
rt_cell_n_on_ray( ap, n )
register struct application *ap;
int	n;		/* First cell is #0 */
d1630 5
a1634 5
rt_DB_rpp( rp, invdir, min, max )
register struct xray *rp;
register const fastf_t *invdir;	/* inverses of rp->r_dir[] */
register const fastf_t *min;
register const fastf_t *max;
d1761 6
a1766 6
rt_vstub( stp, rp, segp, n, ap )
struct soltab	       *stp[]; /* An array of solid pointers */
struct xray		*rp[]; /* An array of ray pointers */
struct  seg            segp[]; /* array of segs (results returned) */
int		  	    n; /* Number of ray/object pairs */
struct application	*ap; /* pointer to an application */
d1796 1
a1796 1
rt_pr_library_version()
d1812 1
a1812 3
rt_add_res_stats( rtip, resp )
register struct rt_i		*rtip;
register struct resource	*resp;
d1854 1
a1854 4
rt_3move_raydist( fp, rayp, dist )
FILE		*fp;
struct xray	*rayp;
double		dist;
d1863 1
a1863 4
rt_3cont_raydist( fp, rayp, dist )
FILE		*fp;
struct xray	*rayp;
double		dist;
d1875 1
a1875 5
rt_plot_cell( cutp, ssp, waiting_segs_hd, rtip )
union cutter		*cutp;
struct rt_shootray_status	*ssp;
struct bu_list		*waiting_segs_hd;
struct rt_i		*rtip;
@


11.100
log
@Changed word "solids" to indicate "prims" or primitives"
@
text
@d40 1
a40 1
static const char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.99 2001/08/22 14:30:00 jra Exp $ (BRL)";
d123 4
a126 2
	if( !resp->re_pieces )  return;

d139 2
@


11.99
log
@commented out an unreachable statement
@
text
@d40 1
a40 1
static const char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.98 2001/06/27 18:00:26 butler Exp $ (BRL)";
d1217 1
a1217 1
		status = "MISS solids";
@


11.98
log
@Switch routine from K&R style to ANSI style args
@
text
@d40 1
a40 1
static const char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.97 2001/05/17 20:05:25 morrison Exp $ (BRL)";
d646 1
a646 1
	bu_bomb("rt_advance_to_next_cell: escaped for(;;) loop: impossible!");
@


11.97
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d40 1
a40 1
static const char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.96 2001/05/16 21:38:04 morrison Exp $ (BRL)";
d1551 4
a1554 5
rt_in_rpp( rp, invdir, min, max )
struct xray		*rp;
register const fastf_t *invdir;	/* inverses of rp->r_dir[] */
register const fastf_t *min;
register const fastf_t *max;
@


11.96
log
@PRODUCTION optimizations
@
text
@d40 1
a40 1
static const char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.95 2001/04/20 22:29:56 morrison Exp $ (BRL)";
d370 1
a370 1
			if( rt_g.debug&DEBUG_ADVANCE )
d441 1
a441 1
		if( rt_g.debug&DEBUG_ADVANCE ) {
d478 1
a478 1
			if( rt_g.debug&DEBUG_ADVANCE && 
d503 1
a503 1
				if( rt_g.debug & DEBUG_ADVANCE ) {
d529 1
a529 1
				if( rt_g.debug & DEBUG_ADVANCE ) {
d539 1
a539 1
				if( rt_g.debug & DEBUG_ADVANCE ) {
d552 1
a552 1
				if( rt_g.debug & DEBUG_ADVANCE ) {
d573 1
a573 1
				if( rt_g.debug & DEBUG_ADVANCE ) {
d583 1
a583 1
			if( rt_g.debug & DEBUG_ADVANCE ) {
d612 1
a612 1
			if( rt_g.debug & DEBUG_ADVANCE )  {
d707 1
a707 1
	const int		debug_shoot = rt_g.debug & DEBUG_SHOOT;
d723 1
a723 1
		if(rt_g.debug)bu_log("rt_shootray:  defaulting a_resource to &rt_uniresource\n");
d734 1
a734 1
	if(rt_g.debug&(DEBUG_ALLRAYS|DEBUG_SHOOT|DEBUG_PARTITION|DEBUG_ALLHITS)) {
d817 1
a817 1
	if(rt_g.debug) {
d1133 1
a1133 1
		if( rt_g.debug & DEBUG_ADVANCE )
d1192 1
a1192 1
	if( rt_g.debug&DEBUG_ADVANCE )
d1263 1
a1263 1
	if(rt_g.debug&DEBUG_ALLHITS) rt_pr_partitions(rtip,&FinalPart,"Partition list passed to a_hit() routine");
d1291 1
a1291 1
	if(rt_g.debug&(DEBUG_ALLRAYS|DEBUG_SHOOT|DEBUG_PARTITION|DEBUG_ALLHITS))  {
d1320 1
a1320 1
	const int		debug_shoot = rt_g.debug & DEBUG_SHOOT;
d1335 1
a1335 1
		if(rt_g.debug)bu_log("rt_cell_n_on_ray:  defaulting a_resource to &rt_uniresource\n");
d1346 1
a1346 1
	if(rt_g.debug&(DEBUG_ALLRAYS|DEBUG_SHOOT|DEBUG_PARTITION|DEBUG_ALLHITS)) {
d1390 1
a1390 1
	if(rt_g.debug) {
@


11.95
log
@CONST to const
@
text
@d40 1
a40 1
static const char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.94 2000/11/01 06:46:13 mike Exp $ (BRL)";
d746 1
d757 1
d1358 1
d1369 1
@


11.94
log
@
Needed seghead paramater to ft_piece_shot() to properly handle
PLATE-mode intersections, where one hit yeilds two hits
and a complete segment, all at once.
@
text
@d40 1
a40 1
static const char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.93 2000/09/20 03:44:26 mike Exp $ (BRL)";
d187 1
a187 1
CONST union cutter *
d191 2
a192 2
	register CONST union cutter		*cutp, *curcut = ssp->curcut;
	register CONST struct application	*ap = ssp->ap;
d256 3
a258 3
			register CONST struct nu_axis  **nu_axis =
			     (CONST struct nu_axis **)&curcut->nugn.nu_axis[0];
			register CONST int		*nu_stepsize =
d260 1
a260 1
			register CONST int	        *nu_cells_per_axis =
d262 1
a262 1
			register CONST union cutter	*nu_grid =
d704 1
a704 1
	register CONST union cutter *cutp;
d707 1
a707 1
	CONST int		debug_shoot = rt_g.debug & DEBUG_SHOOT;
d1309 1
a1309 1
CONST union cutter *
d1315 1
a1315 1
	register CONST union cutter *cutp;
d1318 1
a1318 1
	CONST int		debug_shoot = rt_g.debug & DEBUG_SHOOT;
d1549 3
a1551 3
register CONST fastf_t *invdir;	/* inverses of rp->r_dir[] */
register CONST fastf_t *min;
register CONST fastf_t *max;
d1553 1
a1553 1
	register CONST fastf_t	*pt = &rp->r_pt[0];
d1634 3
a1636 3
register CONST fastf_t *invdir;	/* inverses of rp->r_dir[] */
register CONST fastf_t *min;
register CONST fastf_t *max;
d1638 1
a1638 1
	register CONST fastf_t *pt = &rp->r_pt[0];
@


11.93
log
@
Improved initialization of rt_uniresource.
@
text
@d40 1
a40 1
static const char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.92 2000/09/20 03:25:09 mike Exp $ (BRL)";
d1035 1
a1035 1
				    psp, plp, ss.dist_corr, &ss.newray, ap )) <= 0 )  {
@


11.92
log
@
Special handling for rt_uniresource
@
text
@d40 1
a40 1
static const char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.91 2000/09/08 05:54:42 mike Exp $ (BRL)";
a722 1
		rt_uniresource.re_magic = RESOURCE_MAGIC;
d724 2
a1332 1
		rt_uniresource.re_magic = RESOURCE_MAGIC;
d1334 2
@


11.91
log
@
Modified tree routines to take resource pointer.
@
text
@d40 1
a40 1
static const char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.90 2000/08/29 22:21:58 mike Exp $ (BRL)";
d783 2
a784 1
	BU_ASSERT_PTR( BU_PTBL_GET(&rtip->rti_resources, resp->re_cpu), !=, NULL );
@


11.90
log
@
Added comment.
@
text
@d40 1
a40 1
static const char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.89 2000/08/29 22:08:29 mike Exp $ (BRL)";
d771 2
d780 1
a780 1
		rt_init_resource( resp, resp->re_cpu );
d783 1
a783 3
	if( BU_PTBL_GET(&rtip->rti_resources, resp->re_cpu) == NULL )  {
		BU_PTBL_GET(&rtip->rti_resources, resp->re_cpu) = (long *)resp;
	}
d1368 2
d1377 1
a1377 1
		rt_init_resource( resp, resp->re_cpu );
d1380 1
a1380 3
	if( BU_PTBL_GET(&rtip->rti_resources, resp->re_cpu) == NULL )  {
		BU_PTBL_GET(&rtip->rti_resources, resp->re_cpu) = (long *)resp;
	}
d1926 1
a1926 1
		rt_plot_solid( fp, rtip, stp );
@


11.89
log
@
Improved comments for ft_piece_shot() arguments.
@
text
@d40 1
a40 1
static const char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.88 2000/08/29 21:54:47 mike Exp $ (BRL)";
d999 1
a999 1
					/* Compute ray entry and exit */
d1043 1
@


11.88
log
@
Provide rt_piecestate variable cutp
@
text
@d40 1
a40 1
static const char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.87 2000/07/12 04:21:17 cjohnson Exp $ (BRL)";
d1020 9
a1028 1
				/* Allow solid to shoot all pieces in this cell at once */
@


11.87
log
@LINT from gcc -Wall.
@
text
@d40 1
a40 1
static const char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.86 2000/07/10 23:01:48 mike Exp $ (BRL)";
d105 1
d1022 1
@


11.86
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d40 1
a40 1
static const char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.85 2000/06/07 02:14:33 mike Exp $ (BRL)";
d49 5
d58 1
a116 1
	struct soltab		*stp;
a707 1
	int			odd_hits_pending = 0;	/* boolean.  are odd hits pending? */
a980 1
				int piecenum;
d1532 1
d1617 1
@


11.85
log
@
Made some goto labels more descriptive.
They've been bugging me.
@
text
@d40 1
a40 1
static char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.84 2000/06/07 02:05:48 mike Exp $ (BRL)";
@


11.85.2.1
log
@Mike's changes to handle plate mode BOTS in renderings
@
text
@d40 1
a40 1
static char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.85 2000/06/07 02:14:33 mike Exp $ (BRL)";
d1020 1
a1020 1
				    psp, plp, ss.dist_corr, &ss.newray, ap, &waiting_segs )) <= 0 )  {
@


11.84
log
@
Fixed problem with getting stuck in rt_advance_to_next_cell()
when there was only a single boxnode in the entire space
partitioning tree.
Bug was reported by JRA on model hev2.fastgen4
@
text
@d40 1
a40 1
static char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.83 2000/06/07 01:28:54 mike Exp $ (BRL)";
d426 1
a426 1
			goto done;
d496 1
a496 1
push:				;	
d593 1
a593 1
				goto push;
d596 1
a596 1
done:			ssp->lastcut = cutp;
@


11.83
log
@
Added macro.
@
text
@d40 1
a40 1
static char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.82 2000/06/07 00:51:36 mike Exp $ (BRL)";
d242 7
a248 3
/*
 *  This version uses Gigante's non-uniform 3-D space grid/mesh discretization.
 */
d379 7
a385 3
/*
 *  This version uses Muuss' non-uniform binary space partitioning tree.
 */
d394 17
a410 10
test:		if( cutp==CUTTER_NULL ) {
			/* Move up out of the current node, or return if there
			   is nothing left to do. */
			register struct rt_shootray_status *old = ssp->old_status;

			if( old == NULL ) goto escaped_from_model;
			*ssp = *old;		/* struct copy -- XXX SLOW! */
			bu_free( old, "old rt_shootray_status" );
			curcut = ssp->curcut;
			continue;
d432 2
a433 4
		if( PT_DEPARTING_RPP( ssp->rstep, ssp->curmin, ssp->curmax, px, py, pz ) )  {
			cutp = CUTTER_NULL;
			goto test;
		}
d557 1
a557 2
					cutp = CUTTER_NULL;
					goto escaped_from_model;
d559 3
@


11.82
log
@
When error is detected, don't go detect it a second time, give up.
@
text
@d40 1
a40 1
static char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.81 2000/06/07 00:37:19 mike Exp $ (BRL)";
d58 10
d398 1
a398 2
		/* Compute position and bail if we're outside of the
		   current level. */
d403 1
a403 2
		/* Optimization: when it's a boxnode in a nugrid,
		   just return. */
d413 5
a417 7
		
		if( (ssp->rstep[X] <= 0 && px < ssp->curmin[X]) ||
		    (ssp->rstep[X] >= 0 && px > ssp->curmax[X]) ||
		    (ssp->rstep[Y] <= 0 && py < ssp->curmin[Y]) ||
		    (ssp->rstep[Y] >= 0 && py > ssp->curmax[Y]) ||
		    (ssp->rstep[Z] <= 0 && pz < ssp->curmin[Z]) ||
		    (ssp->rstep[Z] >= 0 && pz > ssp->curmax[Z]) ) {
d459 3
a461 5
			if( rt_g.debug&DEBUG_ADVANCE && (
			    (px < cutp->bn.bn_min[X]) || (px > cutp->bn.bn_max[X]) ||
			    (py < cutp->bn.bn_min[Y]) || (py > cutp->bn.bn_max[Y]) ||
			    (pz < cutp->bn.bn_min[Z]) || (pz > cutp->bn.bn_max[Z]) 
			) ) {
@


11.81
log
@
Tidy up debugging
@
text
@d5 2
d22 1
a22 1
 *  Author -
d24 1
d27 2
a28 3
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
d30 5
d36 2
a37 2
 *	This software is Copyright (C) 1985,1991 by the United States Army.
 *	All rights reserved.
d40 1
a40 1
static char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.80 2000/06/07 00:06:45 mike Exp $ (BRL)";
d541 1
a541 1
					break;
@


11.80
log
@
Enhanced copyright notice
@
text
@d33 1
a33 1
static char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.79 2000/05/24 05:48:59 mike Exp $ (BRL)";
d446 5
a450 7
#if EXTRA_SAFETY
			if( (ssp->rstep[X] <= 0 && px < cutp->bn.bn_min[X]) ||
			    (ssp->rstep[X] >= 0 && px > cutp->bn.bn_max[X]) ||
			    (ssp->rstep[Y] <= 0 && py < cutp->bn.bn_min[Y]) ||
			    (ssp->rstep[Y] >= 0 && py > cutp->bn.bn_max[Y]) ||
			    (ssp->rstep[Z] <= 0 && pz < cutp->bn.bn_min[Z]) ||
			    (ssp->rstep[Z] >= 0 && pz > cutp->bn.bn_max[Z]) ) {
d453 8
a460 11
		  "rt_advance_to_next_cell(): point not in cell, advancing\n");
				if( rt_g.debug & DEBUG_ADVANCE ) {
					bu_log( " pt (%.20e,%.20e,%.20e)\n",
						px, py, pz );
					bu_log(	"  min (%.20e,%.20e,%.20e)\n",
						V3ARGS(cutp->bn.bn_min) );
					bu_log( "  max (%.20e,%.20e,%.20e)\n",
						V3ARGS(cutp->bn.bn_max) );
					bu_log( "pt=(%g,%g,%g)\n",px, py, pz );
					rt_pr_cut( cutp, 0 );
				}
d469 1
a469 3
#endif			
			/* Don't get stuck within the same box for
			   long */
a508 2
#define MUCHO_DIAGS	1
#if MUCHO_DIAGS
d516 1
a516 1
#endif
@


11.79
log
@
Eliminted "streaks" in the pictures by properly cleaning up
pending hit structures. :-)
@
text
@d33 1
a33 1
static char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.78 2000/05/24 01:00:08 mike Exp $ (BRL)";
d36 1
a36 1
char rt_CopyRight_Notice[] = "@@(#) Copyright (C) 1985,1991 by the United States Army";
@


11.78
log
@
Revised how 'solid pieces' state is managed from cell to cell.
Added "struct rt_htbl" to collect up hit state.
Added new method to rt_functab, ft_piece_hitsegs.
Changed args to method ft_piece_shot (removed unnecessary args).
@
text
@d33 1
a33 1
static char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.77 2000/05/23 03:00:55 mike Exp $ (BRL)";
d1160 11
a1170 10
	/* Comment on any dangling (odd) hits leftover from solid pieces */
	if( rtip->rti_nsolids_with_pieces > 0 )  {
		struct rt_piecestate *psp;
		for( psp = &(resp->re_pieces[rtip->rti_nsolids_with_pieces-1]);
		     psp >= resp->re_pieces; psp-- )
		{
			if( psp->htab.end <= 0 )  continue;
			/* Convert any pending hits into segs */
			/* Distance correction was handled in ft_piece_shot */
			psp->stp->st_meth->ft_piece_hitsegs( psp, &waiting_segs, ap );
d1172 1
a1173 1

d1244 10
@


11.77
log
@
Added some extra debug printing.
Left some NaN-catching code in place, but commented out.
@
text
@d33 1
a33 1
static char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.76 2000/05/22 16:02:49 bparker Exp $ (BRL)";
d81 1
a81 1
		psp->oddhit.hit_dist = INFINITY;	/* mark unused */
d105 1
d175 2
d928 1
d940 1
a940 1
			bu_log("\tBOX interval is %g..%g\n", ss.box_start, ss.box_end);
d952 1
a952 1
		pending_hit = INFINITY;
d962 1
a962 1
				int started_with_oddhit;
d976 21
a996 6
					psp->oddhit.hit_dist = INFINITY;
					started_with_oddhit = 0;
				} else if( psp->oddhit.hit_dist < INFINITY )  {
					/* Adjust to local distance for this cell */
					psp->oddhit.hit_dist -= ss.dist_corr;
					started_with_oddhit = 1;
d999 1
a999 1
				/* Allow solid to shoot all pieces at once */
a1000 1
				BU_LIST_INIT( &(new_segs.l) );
d1002 2
a1003 3
				if( (ret = rt_functab[stp->st_id].ft_piece_shot(
				    psp, plp,
				    &ss.newray, ap, &new_segs, resp )) <= 0 )  {
a1006 23
					/* Add seg chain to list awaiting rt_boolweave() */
					register struct seg *s2;
					while(BU_LIST_WHILE(s2,seg,&(new_segs.l)))  {
						BU_LIST_DEQUEUE( &(s2->l) );
#if 0
						/* This code catches NaNs */
						if( !(s2->seg_in.hit_dist >= -INFINITY &&
						    s2->seg_out.hit_dist <= INFINITY) )  {
						    	bu_log("rt_shootray:  Defective %s segment %s (%.18e,%.18e) %d,%d\n",
						    		rt_functab[s2->seg_stp->st_id].ft_name,
								s2->seg_stp->st_name,
								s2->seg_in.hit_dist,
								s2->seg_out.hit_dist,
								s2->seg_in.hit_surfno,
								s2->seg_out.hit_surfno );
						}
#endif
						/* Restore to original distance */
						s2->seg_in.hit_dist += ss.dist_corr;
						s2->seg_out.hit_dist += ss.dist_corr;
						s2->seg_in.hit_rayp = s2->seg_out.hit_rayp = &ap->a_ray;
						BU_LIST_INSERT( &(waiting_segs.l), &(s2->l) );
					}
d1009 17
a1025 10
				if(debug_shoot)bu_log("shooting %s pieces, hit %d\n", stp->st_name, ret);
				/* There may still be an odd hit left over */
				if( psp->oddhit.hit_dist < INFINITY )  {
					/* Restore to proper (absolute) distance */
					psp->oddhit.hit_dist += ss.dist_corr;
					if(debug_shoot)bu_log("oddhit cached: %s piece %d, dist=%g\n",
						stp->st_name,
						psp->oddhit.hit_surfno,
						psp->oddhit.hit_dist);
					if( started_with_oddhit == 0 )  {
a1026 8
					} else {
						/* Even if the oddhit changed, the psp is still listed */
					}
				} else {
					/* No hit cached any more */
					if( started_with_oddhit )  {
						bu_ptbl_rm( &resp->re_pieces_pending, (long *)psp );
					}
d1029 2
a1030 2
			if( BU_PTBL_LEN( &resp->re_pieces_pending ) > 0 )  {
				/* Find the lowest pending hit, that's as far as boolfinal can progress to */
d1035 1
a1035 1
					dist = (*psp)->oddhit.hit_dist;
d1037 1
a1037 1
					if( dist < pending_hit )
d1039 2
a1041 1
				if(debug_shoot) bu_log("pending_hit set to %g\n", pending_hit);
d1060 1
a1060 1
				if( rt_functab[stp->st_id].ft_use_rpp )  {
d1077 1
a1077 1
				if( rt_functab[stp->st_id].ft_shot( 
d1164 6
a1169 8
		     psp >= resp->re_pieces; psp-- )  {
			if( psp->oddhit.hit_dist >= INFINITY )  continue;
			bu_log("rt_shootray(%s) %d,%d odd hit, surf=%d dist=%g ignored\n",
				psp->stp->st_name,
				ap->a_x, ap->a_y,
				psp->oddhit.hit_surfno,
				psp->oddhit.hit_dist );
			psp->oddhit.hit_dist = INFINITY;
@


11.76
log
@*- takes care of complaint under Linux
   about initializer being non-constant
@
text
@d33 1
a33 1
static char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.75 2000/05/22 05:17:23 mike Exp $ (BRL)";
d994 13
d1124 10
a1133 13
		if( ap->a_onehit != 0 &&
		    BU_LIST_NON_EMPTY( &(waiting_segs.l) )
		)  {
			int	done;

			/* Weave these segments into partition list */
			rt_boolweave( &finished_segs, &waiting_segs, &InitialPart, ap );

			/* Evaluate regions upto end of good segs */
			if( ss.box_end < pending_hit )  pending_hit = ss.box_end;
			done = rt_boolfinal( &InitialPart, &FinalPart,
				last_bool_start, pending_hit, regionbits, ap, solidbits );
			last_bool_start = pending_hit;
d1135 12
a1146 2
			/* See if enough partitions have been acquired */
			if( done > 0 )  goto hitit;
@


11.75
log
@
Added code to correctly determine how far along the ray rt_boolfinal()
can proceed.  Need to track all the pending odd hits.
@
text
@d33 1
a33 1
static char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.74 2000/05/22 00:04:08 mike Exp $ (BRL)";
d1027 3
a1029 1
					FAST fastf_t dist = (*psp)->oddhit.hit_dist;
@


11.74
log
@
Added re_pieces_pending ptbl
@
text
@d33 1
a33 1
static char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.73 2000/05/19 03:08:06 mike Exp $ (BRL)";
a82 2

	bu_ptbl_init( &resp->re_pieces_pending, 100, "re_pieces_pending" );
d111 2
d683 1
d783 3
d936 1
d951 1
d958 1
d973 1
d977 1
d1007 24
a1030 2
					if( psp->oddhit.hit_dist < pending_hit )
						pending_hit = psp->oddhit.hit_dist;
d1032 1
@


11.73
log
@
Added missing line of code
@
text
@d33 1
a33 1
static char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.72 2000/05/18 23:52:35 mike Exp $ (BRL)";
d83 2
@


11.72
log
@
Improved accuracy of main ray debug print.
@
text
@d33 1
a33 1
static char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.71 2000/05/18 16:19:49 mike Exp $ (BRL)";
d1420 3
@


11.71
log
@
Added debug routine to extract a single cell along a ray.
@
text
@d33 1
a33 1
static char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.70 2000/05/18 02:14:18 mike Exp $ (BRL)";
d707 1
a707 1
		bu_log("\n**********shootray cpu=%d  %d,%d lvl=%d (%s)\n",
d711 1
d713 1
a713 1
		bu_log("Pnt (%g, %g, %g) a_onehit=%d\n",
d715 1
a715 2
			ap->a_onehit );
		VPRINT("Dir", ap->a_ray.r_dir);
@


11.70
log
@
Added debugging for shooting solid pieces.
@
text
@d33 1
a33 1
static char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.69 2000/05/18 01:33:35 mike Exp $ (BRL)";
d1207 215
@


11.69
log
@
If a solid piece has a pending oddhit being buffered, don't evaluate
boolean expressions beyond that distance along the ray -- there may
be another seg still to come when we enter the next space partitioning cell.
@
text
@d33 1
a33 1
static char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.68 2000/05/16 19:24:50 mike Exp $ (BRL)";
d949 1
a969 1
				if(debug_shoot)bu_log("shooting %s pieces\n", stp->st_name);
d973 1
a973 1
				if( rt_functab[stp->st_id].ft_piece_shot(
d975 1
a975 1
				    &ss.newray, ap, &new_segs, resp ) <= 0 )  {
d991 1
@


11.68
log
@
Fixed core dump problem when no solids with pieces are participating.
@
text
@d33 1
a33 1
static char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.67 2000/05/12 20:35:41 mike Exp $ (BRL)";
d680 1
d941 1
d995 2
d1074 3
a1076 1
		if( ap->a_onehit != 0 && BU_LIST_NON_EMPTY( &(waiting_segs.l) ) )  {
d1082 2
a1083 1
			/* Evaluate regions upto box_end */
d1085 2
a1086 2
				last_bool_start, ss.box_end, regionbits, ap, solidbits );
			last_bool_start = ss.box_end;
d1092 3
a1094 1
		if( ap->a_ray_length > 0.0 && ss.box_end >= ap->a_ray_length )
@


11.67
log
@
Added error message when odd hit is being discarded.
@
text
@d33 1
a33 1
static char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.66 2000/05/12 01:29:45 mike Exp $ (BRL)";
d1101 1
a1101 1
	{
@


11.66
log
@
Corrected accounting for shots, hits, and misses when pieces are involved.
@
text
@d33 1
a33 1
static char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.65 2000/05/12 01:10:59 mike Exp $ (BRL)";
d1100 14
a1113 1
/* XXX Need to rescue any dangling hits from solid pieces */
@


11.65
log
@
Call rt_res_pieces_clean()
@
text
@d33 1
a33 1
static char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.64 2000/05/12 00:33:02 mike Exp $ (BRL)";
d967 2
d1490 3
a1492 3
	rtip->nshots += resp->re_shots;
	rtip->nhits += resp->re_shot_hit;
	rtip->nmiss += resp->re_shot_miss;
d1496 1
a1496 1
	rtip->ndup += resp->re_ndup;
d1511 5
@


11.64
log
@
Need to do and undo translations for each piece for each cell.
@
text
@d33 1
a33 1
static char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.63 2000/05/11 21:44:10 mike Exp $ (BRL)";
d83 28
@


11.63
log
@
Removed debug print
@
text
@d33 1
a33 1
static char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.62 2000/05/11 21:06:32 mike Exp $ (BRL)";
d933 3
d946 2
a947 5
					continue;	/* MISS */
				}

				/* Add seg chain to list awaiting rt_boolweave() */
				{
d957 1
d960 4
a963 1
				resp->re_piece_shot_hit++;
@


11.62
log
@
boxnodes may have only pieces, and no vanilla solids.
Changed to not dump core in this circumstance. :-)
@
text
@d33 1
a33 1
static char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.61 2000/05/11 03:19:17 mike Exp $ (BRL)";
a913 1
bu_log("rt_shootray(): bn_piecelen=%d\n", cutp->bn.bn_piecelen );
@


11.61
log
@
Pieces code starting to take shape.
@
text
@d33 1
a33 1
static char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.60 2000/05/11 00:19:00 mike Exp $ (BRL)";
d965 26
a990 19
		stpp = &(cutp->bn.bn_list[cutp->bn.bn_len-1]);
		for( ; stpp >= cutp->bn.bn_list; stpp-- )  {
			register struct soltab *stp = *stpp;

			if( BU_BITTEST( solidbits, stp->st_bit ) )  {
				resp->re_ndup++;
				continue;	/* already shot */
			}

			/* Shoot a ray */
			BU_BITSET( solidbits, stp->st_bit );

			/* Check against bounding RPP, if desired by solid */
			if( rt_functab[stp->st_id].ft_use_rpp )  {
				if( !rt_in_rpp( &ss.newray, ss.inv_dir,
				    stp->st_min, stp->st_max ) )  {
					if(debug_shoot)bu_log("rpp miss %s\n", stp->st_name);
					resp->re_prune_solrpp++;
					continue;	/* MISS */
d992 7
a998 3
				if( ss.dist_corr + ss.newray.r_max < BACKING_DIST )  {
					if(debug_shoot)bu_log("rpp skip %s, dist_corr=%g, r_max=%g\n", stp->st_name, ss.dist_corr, ss.newray.r_max);
					resp->re_prune_solrpp++;
a1000 1
			}
d1002 11
a1012 19
			if(debug_shoot)bu_log("shooting %s\n", stp->st_name);
			resp->re_shots++;
			BU_LIST_INIT( &(new_segs.l) );
			if( rt_functab[stp->st_id].ft_shot( 
			    stp, &ss.newray, ap, &new_segs ) <= 0 )  {
				resp->re_shot_miss++;
				continue;	/* MISS */
			}

			/* Add seg chain to list awaiting rt_boolweave() */
			{
				register struct seg *s2;
				while(BU_LIST_WHILE(s2,seg,&(new_segs.l)))  {
					BU_LIST_DEQUEUE( &(s2->l) );
					/* Restore to original distance */
					s2->seg_in.hit_dist += ss.dist_corr;
					s2->seg_out.hit_dist += ss.dist_corr;
					s2->seg_in.hit_rayp = s2->seg_out.hit_rayp = &ap->a_ray;
					BU_LIST_INSERT( &(waiting_segs.l), &(s2->l) );
d1014 1
a1015 1
			resp->re_shot_hit++;
@


11.60
log
@
m35 and sphflake benchmarks work again.
Infinite solids are fully handled again, but
now in a better manner than previously.
@
text
@d33 1
a33 1
static char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.59 2000/05/10 01:46:12 mike Exp $ (BRL)";
d301 2
a302 1
			    cutp->bn.bn_len <= 0 ) {
d599 2
a600 1
	if( curcut->bn.bn_len <= 0 )  curcut = CUTTER_NULL;
d904 1
a904 1
		if( cutp->bn.bn_len <= 0 )  {
d912 23
a934 24
#if 0	/* pieces*/
  {
		struct rt_piecelist **plpp;
		plpp = &(cutp->bn.bn_piecelist[cutp->bn.bn_piecelen-1]);
		for( ; plpp >= cutp->bn.bn_piecelist; plpp-- )  {
			register struct rt_piecelist *plp = *plpp;
			struct rt_piecestate *psp;
			struct soltab	*stp;
			int piecenum;

			RT_CK_PIECELIST(plp);

			/* Consider all pieces of this one solid in this cell */
			stp = plp->stp;
			RT_CK_SOLTAB(stp);

			psp = &(resp->re_pieces[stp->st_piecestate_num]);
			RT_CK_PIECESTATE(psp);
			if( psp->ray_seqno != resp->re_nshootray )  {
				/* state is from an earlier ray, scrub */
				BU_BITV_ZEROALL(psp->shot);
				psp->ray_seqno = resp->re_nshootray;
				psp->oddhit.hit_dist = INFINITY;
			}
d936 2
a937 2
			/* Allow solid to shoot all pieces at once */
			BU_LIST_INIT( &(new_segs.l) );
d939 7
a945 7
			if( rt_functab[stp->st_id].ft_piece_shot(
			    psp, plp,
			    &ss.newray, ap, &new_segs, resp ) <= 0 )  {
			    	/* No hits at all */
				resp->re_piece_shot_miss++;
				continue;	/* MISS */
			}
d947 11
a957 10
			/* Add seg chain to list awaiting rt_boolweave() */
			{
				register struct seg *s2;
				while(BU_LIST_WHILE(s2,seg,&(new_segs.l)))  {
					BU_LIST_DEQUEUE( &(s2->l) );
					/* Restore to original distance */
					s2->seg_in.hit_dist += ss.dist_corr;
					s2->seg_out.hit_dist += ss.dist_corr;
					s2->seg_in.hit_rayp = s2->seg_out.hit_rayp = &ap->a_ray;
					BU_LIST_INSERT( &(waiting_segs.l), &(s2->l) );
d959 2
a961 2
			/* There may still be an odd hit left over */
			resp->re_piece_shot_hit++;
a962 2
  }
#endif /* pieces*/
d1064 3
@


11.59
log
@
Eliminated the special space-partitioning box for infinite solids.
Eliminated rti_inf_box
Thanks to Glenn's having implemented the per-solid classification method.
@
text
@d33 1
a33 1
static char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.58 2000/05/08 20:46:56 mike Exp $ (BRL)";
d144 6
d340 1
a340 1
			if( old == NULL ) return CUTTER_NULL;
d590 11
d814 18
d897 1
@


11.58
log
@
Further progress in implementing solid "pieces"
@
text
@d33 1
a33 1
static char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.57 2000/04/24 16:40:50 mike Exp $ (BRL)";
a791 38
	 *  If there are infinite solids in the model,
	 *  shoot at all of them, all of the time
	 *  (until per-solid classification is implemented)
	 *  before considering the model RPP.
	 *  This code is a streamlined version of the real version.
	 */
	if( rtip->rti_inf_box.bn.bn_len > 0 )  {
		/* Consider all objects within the box */
		cutp = &(rtip->rti_inf_box);
		stpp = &(cutp->bn.bn_list[cutp->bn.bn_len-1]);
		for( ; stpp >= cutp->bn.bn_list; stpp-- )  {
			register struct soltab *stp = *stpp;

			/* Shoot a ray */
			if(debug_shoot)bu_log("shooting %s\n", stp->st_name);
			BU_BITSET( solidbits, stp->st_bit );
			resp->re_shots++;
			BU_LIST_INIT( &(new_segs.l) );
			if( rt_functab[stp->st_id].ft_shot( 
			    stp, &ap->a_ray, ap, &new_segs ) <= 0 )  {
				resp->re_shot_miss++;
				continue;	/* MISS */
			}

			/* Add seg chain to list awaiting rt_boolweave() */
			{
				register struct seg *s2;
				while(BU_LIST_WHILE(s2,seg,&(new_segs.l)))  {
					BU_LIST_DEQUEUE( &(s2->l) );
					s2->seg_in.hit_rayp = s2->seg_out.hit_rayp = &ap->a_ray;
					BU_LIST_INSERT( &(waiting_segs.l), &(s2->l) );
				}
			}
			resp->re_shot_hit++;
		}
	}

	/*
a796 9
	    	/* XXX it would be better to do the infinite objects here,
	    	 * XXX and let rt_advance_to_next_cell mention them otherwise,
	    	 * XXX such as when rays escape from the model RPP.
	    	 */
	    	if( BU_LIST_NON_EMPTY( &waiting_segs.l ) )  {
	    		/* Go handle the infinite objects we hit */
	    		ss.model_end = INFINITY;
	    		goto weave;
	    	}
@


11.57
log
@
More stuff for solid pieces.
@
text
@d33 1
a33 1
static char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.56 2000/04/15 02:04:42 mike Exp $ (BRL)";
d920 4
a923 3
		/* Consider all "pieces" of solids within the box */
#if 0
		struct bn_piecelist **plpp;
d926 3
a928 2
			register struct bn_piecelist *plp = *plpp;
			struct bn_piecestate *psp;
d932 6
a937 2
			piecenum = plp->stp->st_piecestate_num;
			psp = &(resp->re_pieces[piecenum]);
a940 3
/* XXX move to h/bu.h */
#define BU_BITV_ZEROALL(_bv)	\
	{ bzero( (char *)((_bv)->bits), BU_BITS2BYTES( (_bv)->nbits ) ); }
d946 2
a947 4
			if( BU_BITTEST( psp->shot, plp->stp->st_piecestate_num ) )  {
				resp->re_ndup++;
				continue;	/* already shot */
			}
d949 5
a953 10
			/* Shoot a ray */
			BU_BITSET( psp->shot, piecenum );

			if(debug_shoot)bu_log("shooting %s piece %d\n", stp->st_name, piecenum );
			resp->re_shots++;
			BU_LIST_INIT( &(new_segs.l) );
	/* XXX */
			if( rt_functab[stp->st_id].ft_shot( 
			    stp, &ss.newray, ap, &new_segs ) <= 0 )  {
				resp->re_shot_miss++;
d969 2
a970 2
			resp->re_shot_hit++;

d972 2
a973 1
#endif
@


11.56
log
@
Code to suport solid 'pieces'.
@
text
@d33 1
a33 1
static char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.55 2000/03/29 18:28:03 mike Exp $ (BRL)";
d751 5
d920 59
a978 1
		/* Consider all objects within the box */
a1147 5

	/*
	 *  Record essential statistics in per-processor data structure.
	 */
	resp->re_nshootray++;
@


11.55
log
@
Got rid of AUTO define
@
text
@d33 1
a33 1
static char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.54 2000/03/28 20:50:45 mike Exp $ (BRL)";
d53 33
d726 5
@


11.54
log
@
Moved shootray_status to raytrace.h, added rt_ prefix
@
text
@d33 1
a33 1
static char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.53 2000/02/11 23:38:01 mike Exp $ (BRL)";
a51 6
#ifdef CRAY
#define AUTO register
#else
#define AUTO /*let the compiler decide*/
#endif

d589 1
a589 1
	AUTO fastf_t		last_bool_start;
d592 1
a592 1
	AUTO char		*status;
d595 1
a595 1
	AUTO struct soltab	**stpp;
d598 1
a598 1
	AUTO struct rt_i	*rtip;
@


11.53
log
@
Added comment
@
text
@d33 1
a33 1
static char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.52 2000/01/29 04:23:38 mike Exp $ (BRL)";
a57 44
#define NUGRID_T_SETUP(_ax,_cval,_cno) \
	if( ssp->rstep[_ax] > 0 ) { \
		ssp->tv[_ax] = t0 + (nu_axis[_ax][_cno].nu_epos - _cval) * \
					    ssp->inv_dir[_ax]; \
	} else if( ssp->rstep[_ax] < 0 ) { \
		ssp->tv[_ax] = t0 + (nu_axis[_ax][_cno].nu_spos - _cval) * \
					    ssp->inv_dir[_ax]; \
	} else { \
		ssp->tv[_ax] = INFINITY; \
	}
#define NUGRID_T_ADV(_ax,_cno) \
	if( ssp->rstep[_ax] != 0 )  { \
		ssp->tv[_ax] += nu_axis[_ax][_cno].nu_width * \
			ssp->abs_inv_dir[_ax]; \
	}

#define BACKING_DIST	(-2.0)		/* mm to look behind start point */
#define OFFSET_DIST	0.01		/* mm to advance point into box */

struct shootray_status {
	fastf_t			dist_corr;	/* correction distance */
	fastf_t			odist_corr;
	fastf_t			box_start;
	fastf_t			obox_start; 
	fastf_t			box_end;
	fastf_t			obox_end;
	fastf_t			model_start;
	fastf_t			model_end;
	struct xray		newray;		/* closer ray start */
	struct application	*ap;
	struct resource		*resp;
	vect_t			inv_dir;      /* inverses of ap->a_ray.r_dir */
	vect_t			abs_inv_dir;  /* absolute values of inv_dir */
	int			rstep[3];     /* -/0/+ dir of ray in axis */
	CONST union cutter	*lastcut, *lastcell;
	CONST union cutter	*curcut;
	vect_t			curmin, curmax;
	int			igrid[3];     /* integer cell coordinates */
	vect_t			tv;	      /* next t intercept values */
	int			out_axis;     /* axis ray will leave through */
	struct shootray_status	*old_status;
};


d108 1
a108 1
register struct shootray_status	*ssp;
d305 1
a305 1
			register struct shootray_status *old = ssp->old_status;
d309 1
a309 1
			bu_free( old, "old shootray_status" );
d529 1
a529 1
			struct shootray_status *old;
d531 1
a531 1
			BU_GETSTRUCT( old, shootray_status );
d591 1
a591 1
	struct shootray_status	ss;
d842 1
a842 1
	ss.old_status = (struct shootray_status *)NULL;
d1432 1
a1432 1
struct shootray_status	*ssp;
@


11.52
log
@Fixed the 2 bugs that Lee detected while doing the Impact Flash
animation:

1)  Progressively fewer instanced solids were having their stp
re-referenced because d_uses was not being zeroed by the "clean" command
in the animation script at the start of each new frame.

2) rt_clean() wasn't calling rt_clean_resource() for the per-CPU
resource structures (including the list of bu_bitv structures used for
re_solid_bitv) because of using the wrong macro to see if there were any
to do.  While fixing it I changed tactics so that a semaphored critical
section is no longer needed for this.
@
text
@d33 1
a33 1
static char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.51 2000/01/22 04:02:38 mike Exp $ (BRL)";
d748 1
@


11.51
log
@
Made handling of seg list from infinite solids more general and robust.
@
text
@d33 1
a33 1
static char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.50 1999/12/23 06:00:35 mike Exp $ (BRL)";
d720 5
a725 4
		bu_semaphore_acquire(RT_SEM_MODEL);
		bu_ptbl_ins_unique( &rtip->rti_resources, (long *)resp );
		bu_semaphore_release(RT_SEM_MODEL);
	}
@


11.50
log
@
Saved a compat subroutine call.
@
text
@d33 1
a33 1
static char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.49 1999/11/24 23:04:50 mike Exp $ (BRL)";
d814 1
d816 1
a816 1
			    stp, &ap->a_ray, ap, &waiting_segs ) <= 0 )  {
d820 2
a821 1
			resp->re_shot_hit++;
d823 6
a828 3
				register struct seg *segp =
					BU_LIST_FIRST(seg, &waiting_segs.l);
				segp->seg_in.hit_rayp = segp->seg_out.hit_rayp = &ap->a_ray;
d830 1
@


11.49
log
@
Added missing #undef
@
text
@d33 1
a33 1
static char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.48 1999/11/02 02:30:36 mike Exp $ (BRL)";
d698 1
a698 1
		rt_prep(rtip);
@


11.48
log
@
Fixed spelling error in debug message
@
text
@d33 1
a33 1
static char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.47 1999/10/30 04:05:13 mike Exp $ (BRL)";
d1341 3
@


11.47
log
@
Processing for new magic numbers.
@
text
@d33 1
a33 1
static char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.46 1999/10/28 03:33:36 mike Exp $ (BRL)";
d1073 1
a1073 1
	if(rt_g.debug&DEBUG_ALLHITS) rt_pr_partitions(rtip,&FinalPart,"Parition list passed to a_hit() routine");
@


11.46
log
@
Added hit_rayp
Added hit_rayp
@
text
@d33 1
a33 1
static char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.45 1998/09/22 02:36:04 mike Exp $ (BRL)";
d652 10
d820 5
a922 1

@


11.45
log
@Eliminated a "notreached" message
@
text
@d33 1
a33 1
static char RCSshoot[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.44 1998/04/15 06:13:52 mike Exp $ (BRL)";
d950 1
@


11.44
log
@Fill in 2 new fields in application structure, for g_submodel.c
@
text
@d33 1
a33 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 11.43 1998/03/26 06:45:23 mike Exp mike $ (BRL)";
d599 2
a600 4

	rt_bomb("rt_advance_to_next_cell: escaped for(;;) loop: impossible!");
	return CUTTER_NULL; /* not reached */

@


11.43
log
@renamed rt_free_resource()
to be rt_clean_resource(), as that is all it does, and I've added some
clarifying comments.  Also, it makes more sense to truncate the
rti_resources ptbl than to free it as part of the cleanup operation.
@
text
@d33 1
a33 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 11.42 1998/01/22 04:47:32 mike Exp mike $ (BRL)";
d696 1
d701 1
@


11.42
log
@For final computation, always call rt_boolfinal() with infinity.
@
text
@d33 1
a33 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 11.41 1998/01/09 09:09:50 mike Exp mike $ (BRL)";
a701 20
		int i;

		BU_LIST_INIT( &resp->re_parthead );

		/* If one is, they all probably are.  Runs once per processor. */
		if( BU_LIST_UNINITIALIZED( &resp->re_solid_bitv ) )
			BU_LIST_INIT(  &resp->re_solid_bitv );
		if( BU_LIST_UNINITIALIZED( &resp->re_region_ptbl ) )
			BU_LIST_INIT(  &resp->re_region_ptbl );
		if( BU_LIST_UNINITIALIZED( &resp->re_nmgfree ) )
			BU_LIST_INIT(  &resp->re_nmgfree );

		for( i=0 ; i<RT_PM_NBUCKETS ; i++ )
		{
			resp->re_pmem.buckets[i].q_forw = &resp->re_pmem.buckets[i];
			resp->re_pmem.buckets[i].q_back = &resp->re_pmem.buckets[i];
		}
		resp->re_pmem.adjhead.q_forw = &resp->re_pmem.adjhead;
		resp->re_pmem.adjhead.q_back = &resp->re_pmem.adjhead;

d703 5
a707 2
		 *  Add this resource structure to the table.
		 *  This is how per-cpu resource structures are discovered.
d709 2
@


11.41
log
@rt_boolfinal() needed an extra parameter.
@
text
@d33 1
a33 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 11.40 1997/12/16 00:14:40 mike Exp mike $ (BRL)";
d1036 1
a1036 1
		rtip->rti_inf_box.bn.bn_len > 0 ? INFINITY : ss.model_end,
@


11.40
log
@Converted to bu_semaphore_acquire()
@
text
@d33 1
a33 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 11.39 1997/10/06 15:32:15 mike Exp mike $ (BRL)";
d998 1
a998 1
				last_bool_start, ss.box_end, regionbits, ap );
d1037 1
a1037 1
		regionbits, ap);
@


11.39
log
@Name changed to prevent system conflicts
@
text
@d33 1
a33 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 11.38 1997/09/18 20:32:45 jra Exp mike $ (BRL)";
d726 1
a726 1
		RES_ACQUIRE(&rt_g.res_model);
d728 1
a728 1
		RES_RELEASE(&rt_g.res_model);
@


11.38
log
@Mods for use of pmalloc in TNURB raytracing.
@
text
@d33 1
a33 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 11.37 1997/09/10 18:47:09 gdurf Exp jra $ (BRL)";
d714 1
a714 1
		for( i=0 ; i<NBUCKETS ; i++ )
@


11.37
log
@nugrid cleanups
@
text
@d33 1
a33 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 11.36 1997/09/04 21:21:32 gdurf Exp gdurf $ (BRL)";
d702 2
d713 8
@


11.36
log
@Improvements (?) to hierarchical space partitioning
@
text
@d33 1
a33 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 11.35 1997/09/02 17:59:41 gdurf Exp gdurf $ (BRL)";
a73 2
/* end NUgrid XXX */

a332 1
			t0 += OFFSET_DIST;
d338 1
d376 6
a381 3
		if( px < ssp->curmin[X] || px > ssp->curmax[X] ||
		    py < ssp->curmin[Y] || py > ssp->curmax[Y] ||
		    pz < ssp->curmin[Z] || pz > ssp->curmax[Z] ) {
d423 8
a430 8
#if UNNECESSARY			
		    /* Ensure point is located in the indicated cell */
			if( px < cutp->bn.bn_min[X] ||
			    px > cutp->bn.bn_max[X] ||
			    py < cutp->bn.bn_min[Y] ||
			    py > cutp->bn.bn_max[Y] ||
			    pz < cutp->bn.bn_min[Z] ||
			    pz > cutp->bn.bn_max[Z] ) {
a1486 17
#if 0
	case CUT_NUGRIDNODE:
		{
			point_t	a, b;

			VSET( a,
				cutp->nugn.nu_axis[X]->spos,
				cutp->nugn.nu_axis[Y]->spos,
				cutp->nugn.nu_axis[Z]->spos );
			VSET( b,
				cutp->nugn.nu_axis[X]->epos,
				cutp->nugn.nu_axis[Y]->epos,
				cutp->nugn.nu_axis[Z]->epos );
			pdv_3box( fp, a, b );
		}
		break;
#endif
@


11.35
log
@reorganized to better support hierarchical space partitioning methods
@
text
@d33 1
a33 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 11.33 1997/07/23 06:52:59 gdurf Exp gdurf $ (BRL)";
d162 2
a163 1
	
d169 1
d199 1
a199 1
		t0 = ssp->box_start + OFFSET_DIST;
d203 1
a203 1
		switch( curcut->cut_type ) {
a207 1
			CONST struct rt_i	*a_rt_i = ap->a_rt_i;
d209 1
a209 1
			CONST struct nu_axis  **nu_axis =
d211 1
a211 1
			CONST int		*nu_stepsize =
d213 1
a213 1
			CONST int	        *nu_cells_per_axis =
d215 1
a215 1
			CONST union cutter	*nu_grid =
d229 4
a232 1
				   We do this by binary subdivision. */
d234 1
d236 1
d238 1
a239 5
				/* If any are out of bounds, we have left the
				   NUgrid and will pop a level off the stack
				   in the outer loop (if applicable).  */
				if( x<0 || y<0 || z<0 ) break;
				
d261 10
a270 3
				   past the end of the box, stay here. */

				if( t0 < ssp->tv[out_axis] ) break;
d277 2
a278 1
again:				if( ssp->rstep[out_axis] > 0 ) {
a315 1
				t0 = ssp->tv[out_axis] + OFFSET_DIST;
d323 4
a326 1
				bu_log( "Exit axis is %c, t1=%g\n",
d328 5
a332 1
					ssp->tv[out_axis] );
d334 3
a337 1
		case CUT_CUTNODE:
d348 1
a348 1
top:		if( cutp==CUTTER_NULL ) {
d382 1
a382 1
			goto top;
d422 1
d450 1
a450 1

d556 1
a556 1
#if 1
a561 1

d866 1
a866 1
	ss.lastcut = ss.lastcell = CUTTER_NULL;
d870 1
d879 1
@


11.34
log
@DEBUG_ALLHITS added
@
text
@d58 1
a58 1
#define NUGRID_T_SETUP(_ax,_cval,_cno)	\
d68 1
a68 1
#define NUGRID_T_ADV(_ax,_cno)  \
a83 1
	fastf_t			first_box_start;
d93 2
a94 2
	int			rstep[3];
	CONST union cutter	*lastcut;
d96 1
d100 1
a100 1
	struct shootray_status  *old_status;  /* for descending recursively */
d158 5
a162 1

d175 1
d177 24
a206 1
			register fastf_t t0, t1;
d217 1
a217 6
			/* We add in OFFSET_DIST in order to get the
			   same results as NUBSPT.  XXX This may want
			   to go away eventually. */

			t0 = ssp->box_start /* + OFFSET_DIST */;
			if( ssp->lastcut == CUTTER_NULL ) {
a220 1
				register fastf_t px, py, pz;
d222 1
a222 1

d226 1
a226 1
				
a228 1

a235 1

d250 3
a252 3
				
			/* Advance from previous cell to next cell */
			/* Take next step, finding ray entry distance*/
d254 14
a267 1
				cutp = ssp->lastcut;
d283 1
d301 2
a302 1
#if 1
d306 1
a306 1
				t0 = ssp->tv[out_axis];
a308 1
#endif			
d311 2
a312 2
			t1 = ssp->tv[out_axis];
#if 1
d315 2
a316 35
					"XYZ*"[ssp->out_axis], t1 );
#endif
			
			
#if 0
		
			ssp->odist_corr = ssp->dist_corr;
			ssp->obox_start = ssp->box_start;
			ssp->obox_end = ssp->box_end;
#endif

#if 1
			VJOIN1( ssp->newray.r_pt,
				ap->a_ray.r_pt, t0, ap->a_ray.r_dir );
			ssp->newray.r_min = 0.0;
			ssp->newray.r_max = t1 - t0;
			ssp->dist_corr = t0;
#else
			ssp->newray.r_min = t0;
			ssp->newray.r_max = t1;
#endif
			ssp->box_start = ssp->dist_corr + ssp->newray.r_min;
			ssp->box_end = ssp->dist_corr + ssp->newray.r_max;

			if( rt_g.debug&DEBUG_ADVANCE ) {
				bu_log( "rt_advance_to_next_cell() box=(%g, %g)\n",
					ssp->box_start, ssp->box_end );
			}

			/* Minor optimization */
			if( cutp->cut_type == CUT_BOXNODE ) {
				ssp->lastcut = cutp;
				return cutp;
			}
			
d318 2
a319 2
		case CUT_NUBSPTNODE: {
#define MUCHO_DIAGS	1
d323 18
a340 38
			int			push_flag = 0;
			double			fraction;
			int			exponent;
			register fastf_t	px, py, pz;

			/*
			 *  The point corresponding to the box_start distance
			 *  may not be in the "right" place,
			 *  due to the effects of floating point fuzz:
			 *  1)  The point might lie just outside
			 *	the model RPP, resulting in the point not
			 *	falling within the RPP of the indicated cell,
			 *	or
			 *  2)	The poing might lie just a little bit on the
			 *	wrong side of the cell wall, resulting in
			 *	the ray getting "stuck", and needing rescuing
			 *	all the time by the error recovery code below.
			 *  Therefore, "nudge" the point just slightly into the
			 *  next cell by adding OFFSET_DIST.
			 *  XXX At present, a cell is never less than 1mm wide.
			 *  XXX The value of OFFSET_DIST should be some
			 *	percentage of the cell's smallest dimension,
			 *	rather than an absolute distance in mm.
			 *	This will prevent doing microscopic models.
			 */
			ssp->dist_corr = ssp->box_start + OFFSET_DIST;
		top:
			px = ap->a_ray.r_pt[X] +
				ssp->dist_corr * ap->a_ray.r_dir[X];
			py = ap->a_ray.r_pt[Y] +
				ssp->dist_corr * ap->a_ray.r_dir[Y];
			pz = ap->a_ray.r_pt[Z] +
				ssp->dist_corr * ap->a_ray.r_dir[Z];
			if( rt_g.debug&DEBUG_ADVANCE ) {
				bu_log(
	          "rt_advance_to_next_cell() dist_corr=%g, pt=(%g, %g, %g)\n",
					ssp->dist_corr, px, py, pz );
			}
d342 30
a371 13
			/* !RT_POINT_IN_RPP() */
			if( !(
				( px >= curcut->nubn.nu_min[X] &&
				  px <= curcut->nubn.nu_max[X] ) &&
				( py >= curcut->nubn.nu_min[Y] &&
				  py <= curcut->nubn.nu_max[Y] ) &&
				( pz >= curcut->nubn.nu_min[Z] &&
				  pz <= curcut->nubn.nu_max[Z] )
				)
				) {
				/* Point outside NUBSPT RPP */
				break;	/* done! */
			}
d373 21
a393 24
			cutp = curcut->nubn.first_cut;
			while( cutp->cut_type == CUT_CUTNODE ) {
				switch( cutp->cn.cn_axis )  {
				case X:
					if( px >= cutp->cn.cn_point )  {
						cutp=cutp->cn.cn_r;
					}  else  {
						cutp=cutp->cn.cn_l;
					}
					break;
				case Y:
					if( py >= cutp->cn.cn_point )  {
						cutp=cutp->cn.cn_r;
					}  else  {
						cutp=cutp->cn.cn_l;
					}
					break;
				case Z:
					if( pz >= cutp->cn.cn_point )  {
						cutp=cutp->cn.cn_r;
					}  else  {
						cutp=cutp->cn.cn_l;
					}
					break;
d395 1
d397 1
d399 2
a400 2
			if( cutp == CUTTER_NULL )
			   rt_bomb( "rt_advance_to_next_cell: leaf is NULL!" );
d402 10
a411 9
			if( cutp->cut_type == CUT_BOXNODE ) {
			    /* Ensure point is located in the indicated cell */
				if( px < cutp->bn.bn_min[X] ||
				    px > cutp->bn.bn_max[X] ||
				    py < cutp->bn.bn_min[Y] ||
				    py > cutp->bn.bn_max[Y] ||
				    pz < cutp->bn.bn_min[Z] ||
				    pz > cutp->bn.bn_max[Z] ) {
					bu_log(
d413 11
a423 14
					if( rt_g.debug & DEBUG_ADVANCE ) {
						bu_log(
						  " pt (%.20e,%.20e,%.20e)\n",
							px, py, pz );
						bu_log(
						"  min (%.20e,%.20e,%.20e)\n",
						   V3ARGS(cutp->bn.bn_min) );
						bu_log(
						"  max (%.20e,%.20e,%.20e)\n",
						   V3ARGS(cutp->bn.bn_max) );
						bu_log( "pt=(%g,%g,%g)\n",
							px, py, pz );
						rt_pr_cut( cutp, 0 );
					}
d428 27
a454 2
					ssp->dist_corr += OFFSET_DIST;
					goto top;
a456 25
				/* Don't get stuck within the same box for
				   long */
				if( cutp==ssp->lastcut ) {
					fastf_t	delta;
				push:	;				
					if( rt_g.debug & DEBUG_ADVANCE ) {
						bu_log(
		"%d,%d box push odist_corr=%.20e n=%.20e model_end=%.20e\n",
							ap->a_x, ap->a_y,
							ssp->odist_corr,
							ssp->dist_corr,
							ssp->model_end );
						bu_log(
		"box_start o=%.20e n=%.20e\nbox_end   o=%.20e n=%.20e\n",
							ssp->obox_start,
							ssp->box_start,
							ssp->obox_end,
							ssp->box_end );
						bu_log( "Point=(%g,%g,%g)\n",
							px, py, pz );
						VPRINT( "Dir",
							ssp->newray.r_dir );
						rt_pr_cut( cutp, 0 );
					}

d460 2
a461 2
					fraction = frexp( ssp->box_end,
							  &exponent );
d463 11
a473 10
					if( rt_g.debug & DEBUG_ADVANCE ) {
						bu_log(
						   "exp=%d, fraction=%.20e\n",
							exponent, fraction );
					}
					if( sizeof(fastf_t) <= 4 )
						fraction += 1.0e-5;
					else
						fraction += 1.0e-14;
					delta = ldexp( fraction, exponent );
d475 7
a481 7
					if( rt_g.debug & DEBUG_ADVANCE ) {
						bu_log(
					"ldexp: delta=%g, fract=%g, exp=%d\n",
							delta,
							fraction,
							exponent );
					}
d484 3
a486 3
					if( delta < 1 ) delta = 1.0;
					ssp->box_start = ssp->box_end + delta;
					ssp->box_end = ssp->box_start + delta;
a487 30
					if( rt_g.debug & DEBUG_ADVANCE ) {
						bu_log(
					   "push%d: was=%.20e, now=%.20e\n\n",
							push_flag,
							ssp->box_end,
							ssp->box_start );
					}
					push_flag++;
					if( push_flag > 3 ) {
						bu_log( "rt_advance_to_next_cell(): INTERNAL ERROR: infinite loop aborted, ray %d,%d truncated\n",
							ap->a_x, ap->a_y );
						cutp = CUTTER_NULL;
						break;
					}
					ssp->dist_corr = ssp->box_start +
						OFFSET_DIST;
					goto top;
				}
				if( push_flag ) {
					push_flag = 0;
					if( rt_g.debug & DEBUG_ADVANCE ) {
						bu_log(
		"%d,%d Escaped %d. dist_corr=%g, box_start=%g, box_end=%g\n",
							ap->a_x, ap->a_y,
							push_flag,
							ssp->dist_corr,
							ssp->box_start,
							ssp->box_end );
					}
				}
d490 4
a493 2
				"rt_advance_to_next_cell()=x%x lastcut=x%x\n",
						cutp, ssp->lastcut);
d495 6
a500 12

				ssp->newray.r_pt[X] = px;
				ssp->newray.r_pt[Y] = py;
				ssp->newray.r_pt[Z] = pz;
				if( !rt_in_rpp( &ssp->newray, ssp->inv_dir,
						cutp->bn.bn_min,
						cutp->bn.bn_max) )  {
					bu_log("rt_advance_to_next_cell():  MISSED BOX\nrmin,rmax(%.20e,%.20e) box(%.20e,%.20e)\n",
					       ssp->newray.r_min,
					       ssp->newray.r_max,
					       ssp->box_start, ssp->box_end );
					goto push;
d502 6
a507 8
				ssp->odist_corr = ssp->dist_corr;
				ssp->obox_start = ssp->box_start;
				ssp->obox_end = ssp->box_end;
				ssp->box_start = ssp->dist_corr +
					ssp->newray.r_min;
				ssp->box_end = ssp->dist_corr +
					ssp->newray.r_max;
				if( rt_g.debug & DEBUG_ADVANCE )  {
d509 6
a514 2
				  "rt_advance_to_next_cell() box=(%g, %g)\n",
						ssp->box_start, ssp->box_end );
d517 5
a521 6
		
			break; }
		default:
			rt_bomb(
		       "rt_advance_to_next_cell: unknown high-level cutnode" );
		}
d523 12
a534 8
		if( cutp!=CUTTER_NULL && cutp==ssp->lastcut ) {
			/* This should never happen; the above error-handling
			   code should take care if it for the NUBSPT. */
			bu_log( "rt_advance_to_next_cell(): stuck in the same cell, cutp = %p, ssp->lastcut = %p, type = %c\n", cutp, ssp->lastcut, cutp?"0CBMG"[cutp->cut_type]:'n');
			rt_bomb( "rt_advance_to_next_cell(): stuck in the same cell" );
		}
	
		ssp->lastcut = cutp;
d536 7
a542 4
		if( cutp==CUTTER_NULL ) {
			/* Move up out of the current node, or return if there
			   is nothing left to do. */
			register struct shootray_status *old = ssp->old_status;
d544 7
a550 41
			if( old == NULL ) return CUTTER_NULL;
			*ssp = *old;		/* struct copy */
			bu_free( old, "old shootray_status" );
			curcut = ssp->curcut;
		} else {
			/* We end up here only if we have encountered a
			   high-level node that we need to descend into or
			   we are at a boxnode that we should return. */
			switch( cutp->cut_type ) {
			case CUT_BOXNODE:
				/* We have found a boxnode.  Return it, after
				   setting up ray intersection information. */
				if( cutp->bn.bn_len <= 0 ) {
				/*
				 * Automatically skip past empty containers.
				 */
					++ssp->resp->re_nempty_cells;
					ssp->box_start = ssp->box_end;
					break;
				}
				return cutp;
			case CUT_NUGRIDNODE:
			case CUT_NUBSPTNODE: {
				struct shootray_status *old;

				BU_GETSTRUCT( old, shootray_status );
				*old = *ssp;	/* struct copy */

				/* Descend into node */
				ssp->old_status = old;
				ssp->lastcut = CUTTER_NULL;
				curcut = ssp->curcut = cutp;
				if( cutp->cut_type == CUT_NUGRIDNODE )
					ssp->dist_corr = 0.0;
				break; }	
			case CUT_CUTNODE:
				rt_bomb(
		 "rt_advance_to_next_cell: cutnode where there shouldn't be" );
			default:
				rt_bomb(
			         "rt_advance_to_next_cell: unknown cut type" );
d552 25
a576 1
		}
d583 1
d613 1
d848 1
a848 2
	ss.first_box_start = ss.box_start;
	ss.lastcut = CUTTER_NULL;
d851 13
d1042 1
a1042 1
	if(rt_g.debug&DEBUG_ALLHITS)  rt_pr_partitions(rtip,&FinalPart,"Partition list passed to a_hit() routine");
d1065 1
a1065 1
	if(rt_g.debug&(DEBUG_ALLRAYS|DEBUG_SHOOT|DEBUG_PARTITION))  {
a1451 1
		return;
@


11.33
log
@Great big bug found!
tv[...] now filled with correct values, allowing one_hit=1 to work correctly.
@
text
@d33 1
a33 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 11.32 1997/07/23 03:37:00 mike Exp gdurf $ (BRL)";
d50 2
d685 1
a685 1
	if(rt_g.debug&(DEBUG_ALLRAYS|DEBUG_SHOOT|DEBUG_PARTITION)) {
d1068 1
d1457 1
a1457 1
/*void*/
@


11.32
log
@Added plotting capability
@
text
@d33 1
a33 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 11.31 1997/07/23 02:41:56 gdurf Exp mike $ (BRL)";
d58 1
a58 1
		ssp->tv[_ax] = (nu_axis[_ax][_cno].nu_epos - _cval) * \
d61 1
a61 1
		ssp->tv[_ax] = (nu_axis[_ax][_cno].nu_spos - _cval) * \
@


11.31
log
@More NUgrid optimizations
@
text
@d33 1
a33 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 11.30 1997/07/16 19:55:04 gdurf Exp gdurf $ (BRL)";
d963 2
d1422 124
@


11.30
log
@Optimized skipping over empty cells.
@
text
@d33 1
a33 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 11.29 1997/07/16 17:38:28 gdurf Exp gdurf $ (BRL)";
d187 5
a191 1
			t0 = ssp->box_start;
a198 6
				/* We add in OFFSET_DIST in order to get the
				   same results as NUBSPT.  XXX This may want
				   to go away eventually. */
#if 0				
				t0 += OFFSET_DIST;
#endif				
d265 1
a265 1

d269 1
d272 1
d276 1
a276 1
#if 0
a288 1
#if 0
d290 1
d299 15
a313 2
#endif			
			ssp->box_end = t1;
d373 1
a373 1
			cutp = (union cutter *)curcut->nubn.first_cut;
d570 1
a570 1
			struct shootray_status *old = ssp->old_status;
d575 1
d603 1
a603 1
				ssp->curcut = cutp;
d917 1
a917 1
			/* On m35.g, this block of code eats 15% of CPU! */
@


11.29
log
@More optmizations
@
text
@d33 1
a33 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 11.28 1997/07/15 17:21:23 gdurf Exp gdurf $ (BRL)";
d175 4
a178 2
			register CONST struct rt_i	*a_rt_i = ap->a_rt_i;
			register CONST struct nu_axis  **nu_axis =
d180 1
a180 1
			register CONST int		*nu_stepsize =
d182 1
a182 1
			register CONST int	        *nu_cells_per_axis =
d184 1
a184 1
			register CONST union cutter	*nu_grid =
a185 1
			register fastf_t t0, t1;
a229 1
				register int out_axis = ssp->out_axis;
d233 3
a235 2

				if( ssp->rstep[out_axis] > 0 ) {
d237 2
a238 1
					    nu_cells_per_axis[out_axis] )
d240 2
a241 2
					cutp = ssp->lastcut +
						nu_stepsize[out_axis];
d243 2
a244 1
					if( --(ssp->igrid[out_axis]) < 0 )
d246 2
a247 2
					cutp = ssp->lastcut -
						nu_stepsize[out_axis];
d256 1
a256 2
					ssp->out_axis = Z;
					t1 = ssp->tv[Z];
d258 1
a258 2
					ssp->out_axis = X;
					t1 = ssp->tv[X];
d262 1
a262 2
					ssp->out_axis = Z;
					t1 = ssp->tv[Z];
d264 1
a264 2
					ssp->out_axis = Y;
					t1 = ssp->tv[Y];
d267 9
@


11.28
log
@Added support for recursive space partitioning,
and a bunch of optimizations.
@
text
@d33 1
a33 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 11.27 1997/06/18 17:21:26 gdurf Exp gdurf $ (BRL)";
d56 8
a63 2
#define NUGRID_T_SETUP(_ax,_cno)	\
	if( ssp->rstep[_ax] == 0 )  { \
a64 6
	} else if( ssp->rstep[_ax] > 0 ) { \
		ssp->tv[_ax] = (nu_axis[_ax][_cno].nu_epos - \
				ssp->newray.r_pt[_ax]) * ssp->inv_dir[_ax]; \
	} else { \
		ssp->tv[_ax] = (nu_axis[_ax][_cno].nu_spos - \
				ssp->newray.r_pt[_ax]) * ssp->inv_dir[_ax]; \
a156 1
#if 1
d164 5
a168 6
	/* Set cutp to CUTTER_NULL.
	   If it fails to become set in the following switch statement, we know
	   that we have exited the subnode.
	   If this subnode is the highest-level node, then we are done
	   advancing the ray through the model. */
	cutp = CUTTER_NULL;
d170 2
a171 2
	switch( curcut->cut_type ) {
	case CUT_NUGRIDNODE: {
d175 28
a202 263
		register CONST struct rt_i	*a_rt_i = ap->a_rt_i;
		register CONST struct nu_axis  **nu_axis =
			(CONST struct nu_axis **)&curcut->nugn.nu_axis[0];
		register CONST int *nu_stepsize = &curcut->nugn.nu_stepsize[0];
		register CONST int *nu_cells_per_axis =
			&curcut->nugn.nu_cells_per_axis[0];
		register CONST union cutter *nu_grid = curcut->nugn.nu_grid;
		register fastf_t t0, t1, px, py, pz;

		t0 = ssp->box_start;
		if( ssp->lastcut == CUTTER_NULL ) {
			/* We have just started into this NUgrid.
			   We must find our location and set up the
			   NUgrid traversal state variables. */
			register int x, y, z;

			/* We add in OFFSET_DIST in order to get the same
			   results as NUBSPT.
			   XXX This may want to go away eventually. */
			t0 += OFFSET_DIST;
			
			px = ap->a_ray.r_pt[X] + t0*ap->a_ray.r_dir[X];
			py = ap->a_ray.r_pt[Y] + t0*ap->a_ray.r_dir[Y];
			pz = ap->a_ray.r_pt[Z] + t0*ap->a_ray.r_dir[Z];
			
			/* Must find cell that contains newray.r_pt.
			   We do this by binary subdivision. */

			x = rt_find_nugrid( (struct nugridnode *)curcut,X,px );
			y = rt_find_nugrid( (struct nugridnode *)curcut,Y,py );
			z = rt_find_nugrid( (struct nugridnode *)curcut,Z,pz );

			/* If any are out of bounds, we have left the NUgrid
			   and will pop a level off the stack in the outer
			   loop (if applicable).  */

			if( x<0 || y<0 || z<0 ) break;

			cutp = &nu_grid[z*nu_stepsize[Z] +
				        y*nu_stepsize[Y] +
				        x*nu_stepsize[X]];

			ssp->igrid[X] = x;
			ssp->igrid[Y] = y;
			ssp->igrid[Z] = z;
			
			NUGRID_T_SETUP( X, x );
			NUGRID_T_SETUP( Y, y );
			NUGRID_T_SETUP( Z, z );
		} else {
			register int out_axis = ssp->out_axis;
				
			/* Advance from previous cell to next cell */
			/* Take next step, finding ray entry distance*/

			if( ssp->rstep[out_axis] > 0 ) {
				if( ++(ssp->igrid[out_axis]) >=
				    nu_cells_per_axis[out_axis] ) break;
				cutp = ssp->lastcut + nu_stepsize[out_axis];
			} else {
				if( --(ssp->igrid[out_axis]) < 0 ) break;
				cutp = ssp->lastcut - nu_stepsize[out_axis];
			}

			NUGRID_T_ADV( out_axis, ssp->igrid[out_axis] );
		}
			
		/* find minimum exit t value */
		if( ssp->tv[X] < ssp->tv[Y] )  {
			if( ssp->tv[Z] < ssp->tv[X] )  {
				ssp->out_axis = Z;
				t1 = ssp->tv[Z];
			} else {
				ssp->out_axis = X;
				t1 = ssp->tv[X];
			}
		} else {
			if( ssp->tv[Z] < ssp->tv[Y] )  {
				ssp->out_axis = Z;
				t1 = ssp->tv[Z];
			} else {
				ssp->out_axis = Y;
				t1 = ssp->tv[Y];
			}
		}

		if( rt_g.debug&DEBUG_ADVANCE )
			bu_log( "Exit axis is %c, t1=%g\n",
				"XYZ*"[ssp->out_axis], t1 );
#if 0
		
		ssp->odist_corr = ssp->dist_corr;
		ssp->obox_start = ssp->box_start;
		ssp->obox_end = ssp->box_end;
#endif
		VJOIN1( ssp->newray.r_pt, ap->a_ray.r_pt, t0, ap->a_ray.r_dir);
		ssp->newray.r_min = 0.0;
		ssp->newray.r_max = t1 - t0;
		ssp->dist_corr = t0;
		ssp->box_end = t1;
		break; }
	case CUT_NUBSPTNODE: {
#define MUCHO_DIAGS	1
/*
 *  This version uses Muuss' non-uniform binary space partitioning tree.
 */
		int			push_flag = 0;
		double			fraction;
		int			exponent;
		register fastf_t	px, py, pz;

		/*
		 *  The point corresponding to the box_start distance
		 *  may not be in the "right" place,
		 *  due to the effects of floating point fuzz:
		 *  1)  The point might lie just outside
		 *	the model RPP, resulting in the point not
		 *	falling within the RPP of the indicated cell, or
		 *  2)	The poing might lie just a little bit on the
		 *	wrong side of the cell wall, resulting in
		 *	the ray getting "stuck", and needing rescuing
		 *	all the time by the error recovery code below.
		 *  Therefore, "nudge" the point just slightly into the
		 *  next cell by adding OFFSET_DIST.
		 *  XXX At present, a cell is never less than 1mm wide.
		 *  XXX The value of OFFSET_DIST should be some percentage
		 *	of the cell's smallest dimension,
		 *	rather than an absolute distance in mm.
		 *	This will prevent doing microscopic models.
		 */
		ssp->dist_corr = ssp->box_start + OFFSET_DIST;
top:
		px = ap->a_ray.r_pt[X] + ssp->dist_corr * ap->a_ray.r_dir[X];
		py = ap->a_ray.r_pt[Y] + ssp->dist_corr * ap->a_ray.r_dir[Y];
		pz = ap->a_ray.r_pt[Z] + ssp->dist_corr * ap->a_ray.r_dir[Z];
		if( rt_g.debug&DEBUG_ADVANCE ) {
			bu_log(
		  "rt_advance_to_next_cell() dist_corr=%g, pt=(%g, %g, %g)\n",
		               ssp->dist_corr, px, py, pz );
		}

		/* !RT_POINT_IN_RPP() */
		if( !(
		       ( px >= curcut->nubn.nu_min[X] &&
			 px <= curcut->nubn.nu_max[X] ) &&
		       ( py >= curcut->nubn.nu_min[Y] &&
			 py <= curcut->nubn.nu_max[Y] ) &&
		       ( pz >= curcut->nubn.nu_min[Z] &&
			 pz <= curcut->nubn.nu_max[Z] )
		     )
		) {
			/* Point outside NUBSPT RPP */
			break;	/* done! */
		}

		cutp = (union cutter *)curcut->nubn.first_cut;
		while( cutp->cut_type == CUT_CUTNODE ) {
			switch( cutp->cn.cn_axis )  {
			case X:
				if( px >= cutp->cn.cn_point )  {
					cutp=cutp->cn.cn_r;
				}  else  {
					cutp=cutp->cn.cn_l;
				}
				break;
			case Y:
				if( py >= cutp->cn.cn_point )  {
					cutp=cutp->cn.cn_r;
				}  else  {
					cutp=cutp->cn.cn_l;
				}
				break;
			case Z:
				if( pz >= cutp->cn.cn_point )  {
					cutp=cutp->cn.cn_r;
				}  else  {
					cutp=cutp->cn.cn_l;
				}
				break;
			}
		}

		if( cutp == CUTTER_NULL )
			rt_bomb( "rt_advance_to_next_cell: leaf is NULL!" );

		if(cutp==ssp->lastcut)
			bu_log( "Odd. cutp==ssp->lastcut. XXX\n" );
		if( cutp->cut_type == CUT_BOXNODE ) {
			/* Ensure point is located in the indicated cell */
			if( px < cutp->bn.bn_min[X] ||
			    px > cutp->bn.bn_max[X] ||
			    py < cutp->bn.bn_min[Y] ||
			    py > cutp->bn.bn_max[Y] ||
			    pz < cutp->bn.bn_min[Z] ||
			    pz > cutp->bn.bn_max[Z] ) {
				bu_log(
	          "rt_advance_to_next_cell(): point not in cell, advancing\n");
				if( rt_g.debug & DEBUG_ADVANCE ) {
					bu_log( " pt (%.20e,%.20e,%.20e)\n",
						px, py, pz );
					bu_log( "  min (%.20e,%.20e,%.20e)\n",
						V3ARGS(cutp->bn.bn_min) );
					bu_log( "  max (%.20e,%.20e,%.20e)\n",
						V3ARGS(cutp->bn.bn_max) );
					bu_log( "pt=(%g,%g,%g)\n", px, py, pz);
					rt_pr_cut( cutp, 0 );
				}
				/*
				 * Move newray point further into new box.
				 * Try again.
				 */
				ssp->dist_corr += OFFSET_DIST;
				goto top;
			}

			/* Don't get stuck within the same box for long */
			if( cutp==ssp->lastcut ) {
				fastf_t	delta;
/*				bu_log( "rt_advance_to_next_cell: stuck in same cell, advancing (push_flag = %d)\n", push_flag ); */
push:				;				
				if( rt_g.debug & DEBUG_ADVANCE ) {
					bu_log(
		  "%d,%d box push odist_corr=%.20e n=%.20e model_end=%.20e\n",
					        ap->a_x, ap->a_y,
					        ssp->odist_corr,
						ssp->dist_corr,
					        ssp->model_end );
					bu_log(
		     "box_start o=%.20e n=%.20e\nbox_end   o=%.20e n=%.20e\n",
						ssp->obox_start,
						ssp->box_start,
						ssp->obox_end, ssp->box_end );
					bu_log( "Point=(%g,%g,%g)\n",
						px, py, pz );
					VPRINT( "Dir", ssp->newray.r_dir );
					rt_pr_cut( cutp, 0 );
				}

				/* Advance 1mm, or smallest value that hardware
				 * floating point resolution will allow.
				 */
				fraction = frexp( ssp->box_end, &exponent );

				if( rt_g.debug & DEBUG_ADVANCE ) {
					bu_log( "exp=%d, fraction=%.20e\n",
						exponent, fraction );
				}
				if( sizeof(fastf_t) <= 4 )
					fraction += 1.0e-5;
				else
					fraction += 1.0e-14;
				delta = ldexp( fraction, exponent );
#if MUCHO_DIAGS
				if( rt_g.debug & DEBUG_ADVANCE ) {
					bu_log(
				       "ldexp: delta=%g, fract=%g, exp=%d\n",
				                delta, fraction, exponent );
				}
#endif
				/* Never advance less than 1mm */
				if( delta < 1 ) delta = 1.0;
				ssp->box_start = ssp->box_end + delta;
				ssp->box_end = ssp->box_start + delta;
a203 154
				if( rt_g.debug & DEBUG_ADVANCE ) {
					bu_log(
					   "push%d: was=%.20e, now=%.20e\n\n",
					        push_flag,
						ssp->box_end, ssp->box_start);
				}
				push_flag++;
				if( push_flag > 3 ) {
					bu_log( "rt_advance_to_next_cell(): INTERNAL ERROR: infinite loop aborted, ray %d,%d truncated\n",
						ap->a_x, ap->a_y );
					cutp = CUTTER_NULL;
					break;
				}
				ssp->dist_corr = ssp->box_start + OFFSET_DIST;
				goto top;
			}
			if( push_flag ) {
				push_flag = 0;
				if( rt_g.debug & DEBUG_ADVANCE ) {
					bu_log(
	         "%d,%d Escaped %d. dist_corr=%g, box_start=%g, box_end=%g\n",
						ap->a_x, ap->a_y, push_flag,
						ssp->dist_corr,
						ssp->box_start, ssp->box_end );
				}
			}
			if( rt_g.debug & DEBUG_ADVANCE ) {
				bu_log(
			        "rt_advance_to_next_cell()=x%x lastcut=x%x\n",
					cutp, ssp->lastcut);
			}

			ssp->newray.r_pt[X] = px;
			ssp->newray.r_pt[Y] = py;
			ssp->newray.r_pt[Z] = pz;
			if( !rt_in_rpp( &ssp->newray, ssp->inv_dir,
					cutp->bn.bn_min, cutp->bn.bn_max) )  {
				bu_log("rt_advance_to_next_cell():  MISSED BOX\nrmin,rmax(%.20e,%.20e) box(%.20e,%.20e)\n",
				       ssp->newray.r_min, ssp->newray.r_max,
				       ssp->box_start, ssp->box_end);
				goto push;
			}
			ssp->odist_corr = ssp->dist_corr;
			ssp->obox_start = ssp->box_start;
			ssp->obox_end = ssp->box_end;
			ssp->box_start = ssp->dist_corr + ssp->newray.r_min;
			ssp->box_end = ssp->dist_corr + ssp->newray.r_max;
			if( rt_g.debug & DEBUG_ADVANCE )  {
			bu_log("rt_advance_to_next_cell() box=(%g, %g)\n",
				       ssp->box_start, ssp->box_end );
			}
			if(cutp==ssp->lastcut)
				bu_log( "Odd. cutp==ssp->lastcut.\n" );
		}
		
		break; }
	default:
		rt_bomb("rt_advance_to_next_cell: unknown high-level cutnode");
	}

	if( cutp!=CUTTER_NULL && cutp==ssp->lastcut ) {
		/* This should never happen; the above error-handling code
		   should take care if it for the NUBSPT. */
		bu_log( "rt_advance_to_next_cell(): stuck in the same cell, cutp = %p, ssp->lastcut = %p, type = %c\n", cutp, ssp->lastcut, cutp?"0CBMG"[cutp->cut_type]:'n');
		rt_bomb( "rt_advance_to_next_cell(): stuck in the same cell" );
	}
	
	ssp->lastcut = cutp;

	if( cutp==CUTTER_NULL ) {
		/* Move up out of the current node, or return if there
		   is nothing left to do. */
		struct shootray_status *old = ssp->old_status;

		if( old == NULL ) return CUTTER_NULL;
		*ssp = *old;		/* struct copy */
		bu_free( old, "old shootray_status" );
	} else {
		switch( cutp->cut_type ) {
		case CUT_BOXNODE:
			/* We have found a boxnode.  Return it,
			   after setting up ray intersection information. */
			if( cutp->bn.bn_len <= 0 ) {
				/*
				 * Automatically skip past empty containers.
				 */
				++ssp->resp->re_nempty_cells;
				ssp->box_start = ssp->box_end;
				break;
			}

			/*
			 *  To make life easier on the ray/solid intersectors,
			 *  give them a point "near" their solid, by
			 *  concocting a point roughly in this cell.
			 *  NOTE:  floating point error may cause this point to
			 *  be slightly outside the cell, which does not matter
			 */
			
			if( rt_g.debug&DEBUG_ADVANCE ) {
				bu_log( "rt_advance_to_next_cell() returning: dist_corr=%g\n", ssp->dist_corr );
				bu_log( "rt_advance_to_next_cell() returning: newray.r_pt=(%g, %g, %g)\n", V3ARGS( ssp->newray.r_pt ) );
				bu_log( "rt_advance_to_next_cell() returning: box=(%g, %g)\n", ssp->box_start, ssp->box_end );
				bu_log( "rt_advance_to_next_cell() returning: cutp = %p\n", cutp );
			}
			return cutp;
		case CUT_CUTNODE:
			rt_bomb( "rt_advance_to_next_cell: cutnode where there shouldn't be" );
		case CUT_NUGRIDNODE:
		case CUT_NUBSPTNODE: {
			struct shootray_status *old;

			BU_GETSTRUCT( old, shootray_status );
			*old = *ssp;	/* struct copy */

			/* Descend into node */
			ssp->old_status = old;
			ssp->lastcut = CUTTER_NULL;
			ssp->curcut = cutp;
			break; }	
		default:
			rt_bomb( "rt_advance_to_next_cell: unknown cut type" );
		}
	}
	}

	rt_bomb( "rt_advance_to_next_cell: escaped for(;;) loop" );
	return CUTTER_NULL;

#else

	if( ap->a_rt_i->rti_space_partition == RT_PART_NUGRID ) {
			
/*
 *  This version uses Gigante's non-uniform 3-D space grid/mesh discretization.
 */
		register CONST struct rt_i	*a_rt_i = ap->a_rt_i;
		register CONST struct nu_axis  **nu_axis =
			(CONST struct nu_axis **)&a_rt_i->rti_CutHead.nugn.nu_axis[0];
		register CONST int		*nu_stepsize =
			&a_rt_i->rti_CutHead.nugn.nu_stepsize[0];
		register CONST int		*nu_cells_per_axis =
			&a_rt_i->rti_CutHead.nugn.nu_cells_per_axis[0];
		register CONST union cutter	*nu_grid =
			a_rt_i->rti_CutHead.nugn.nu_grid;

		for(;;) {
			if( ssp->lastcut == CUTTER_NULL )  {
				register int	x, y, z;

				ssp->dist_corr = ssp->first_box_start;
				VJOIN1( ssp->newray.r_pt, ap->a_ray.r_pt,
					ssp->dist_corr, ap->a_ray.r_dir );

d207 7
a213 6
				x = rt_find_nugrid( &a_rt_i->rti_CutHead, X,
						    ssp->newray.r_pt[X] );
				y = rt_find_nugrid( &a_rt_i->rti_CutHead, Y,
						    ssp->newray.r_pt[Y] );
				z = rt_find_nugrid( &a_rt_i->rti_CutHead, Z,
						    ssp->newray.r_pt[Z] );
d216 1
a216 1

d224 4
a227 6

				NUGRID_T_SETUP( X, x );
				NUGRID_T_SETUP( Y, y );
				NUGRID_T_SETUP( Z, z );

				ssp->t0 = 0.0;
d231 2
a232 3
				/* Advance from previous cell to next cell */
				/* Take next step, finding ray entry distance*/
				cutp = ssp->lastcut;
d234 1
a234 2
				ssp->t0 = ssp->t1;
				if( ap->a_ray.r_dir[out_axis] > 0.0 ) {
d238 2
a239 1
					cutp += nu_stepsize[out_axis];
d243 2
a244 1
					cutp -= nu_stepsize[out_axis];
d249 1
d254 1
a254 1
					ssp->t1 = ssp->tv[Z];
d257 1
a257 1
					ssp->t1 = ssp->tv[X];
d262 1
a262 1
					ssp->t1 = ssp->tv[Z];
d265 1
a265 1
					ssp->t1 = ssp->tv[Y];
d268 14
d283 20
a302 10
			if(rt_g.debug&DEBUG_ADVANCE)bu_log("Exit axis is %c, t1=%g\n", "XYZ*"[ssp->out_axis], ssp->t1);

			if(cutp==CUTTER_NULL || cutp->cut_type != CUT_BOXNODE)
				rt_bomb("rt_advance_to_next_cell(): leaf not boxnode");

			/* Don't get stuck within the same box */
			if( cutp==ssp->lastcut )  {
				rt_bomb("rt_advance_to_next_cell():  stuck in same cell\n");
			}
			ssp->lastcut = cutp;
d305 18
a322 1
			 * Automatically skip past empty containers.
d324 12
a335 3
			if( cutp->bn.bn_len <= 0 ) {
				ssp->resp->re_nempty_cells++;
				continue;
d338 39
a376 15
			/*
			 *  To make life easier on the ray/solid intersectors,
			 *  give them a point "near" their solid, by
			 *  concocting a point roughly in this cell.
			 *  NOTE:  floating point error may cause this point to
			 *  be slightly outside the cell, which does not matter.
			 */
			ssp->dist_corr = ssp->model_start + ssp->t0;
			VJOIN1( ssp->newray.r_pt, ap->a_ray.r_pt,
				ssp->dist_corr, ap->a_ray.r_dir );
			if( rt_g.debug&DEBUG_ADVANCE) {
				bu_log("rt_advance_to_next_cell() dist_corr=%g\n",
				       ssp->dist_corr );
				bu_log("rt_advance_to_next_cell() newray.r_pt=(%g, %g, %g)\n",
				       V3ARGS( ssp->newray.r_pt ) );
d379 2
a380 2
			ssp->newray.r_min = 0.0;
			ssp->newray.r_max = ssp->t1 - ssp->t0;
d382 31
a412 24
			ssp->box_start = ssp->first_box_start + ssp->t0;
			ssp->box_end = ssp->first_box_start + ssp->t1;
			if( rt_g.debug & DEBUG_ADVANCE )  {
				bu_log("rt_advance_to_next_cell() box=(%g, %g)\n",
				       ssp->box_start, ssp->box_end );
			}
			return(cutp);
		}
		/* Off the end of the model RPP */
# if 0
		if( ap->a_rt_i->rti_inf_box.bn.bn_len > 0 )  {
			if( rt_g.debug & DEBUG_ADVANCE )  {
				bu_log("rt_advance_to_next_cell(): escaped model RPP, checking infinite solids\n");
			}
			ssp->lastcut = &(ap->a_rt_i->rti_inf_box);
			return &(ap->a_rt_i->rti_inf_box);
		}
# endif
		if( rt_g.debug & DEBUG_ADVANCE )  {
			bu_log("rt_advance_to_next_cell(): escaped model RPP\n");
		}
		ssp->lastcut = CUTTER_NULL;
		return(CUTTER_NULL);
	} else {
d414 24
a437 1
#define MUCHO_DIAGS	1
d439 5
a443 4
	    int			push_flag = 0;
	    double		fraction;
	    int			exponent;
	    register fastf_t	px, py, pz;	/* Adjusted ray pt */
d445 53
a497 49
	    for(;;)  {
		/*
		 *  The point corresponding to the box_start distance
		 *  may not be in the "right" place,
		 *  due to the effects of floating point fuzz:
		 *  1)  The point might lie just outside
		 *	the model RPP, resulting in the point not
		 *	falling within the RPP of the indicated cell, or
		 *  2)	The poing might lie just a little bit on the
		 *	wrong side of the cell wall, resulting in
		 *	the ray getting "stuck", and needing rescuing
		 *	all the time by the error recovery code below.
		 *  Therefore, "nudge" the point just slightly into the
		 *  next cell by adding OFFSET_DIST.
		 *  XXX At present, a cell is never less than 1mm wide.
		 *  XXX The value of OFFSET_DIST should be some percentage
		 *	of the cell's smallest dimension,
		 *	rather than an absolute distance in mm.
		 *	This will prevent doing microscopic models.
		 */
		ssp->dist_corr = ssp->box_start + OFFSET_DIST;
top:
		/* VJOIN1( pt, ap->a_ray.r_pt, ssp->dist_corr, ap->a_ray.r_dir ); */
		px = ap->a_ray.r_pt[X] + ssp->dist_corr * ap->a_ray.r_dir[X];
		py = ap->a_ray.r_pt[Y] + ssp->dist_corr * ap->a_ray.r_dir[Y];
		pz = ap->a_ray.r_pt[Z] + ssp->dist_corr * ap->a_ray.r_dir[Z];
		if( rt_g.debug&DEBUG_ADVANCE) {
			bu_log("rt_advance_to_next_cell() dist_corr=%g, pt=(%g, %g, %g)\n",
				ssp->dist_corr, px, py, pz );
		}
		/* !RT_POINT_IN_RPP() */
		if( !(
		       ( px >= ap->a_rt_i->mdl_min[X] && px <= ap->a_rt_i->mdl_max[X] ) &&
		       ( py >= ap->a_rt_i->mdl_min[Y] && py <= ap->a_rt_i->mdl_max[Y] ) &&
		       ( pz >= ap->a_rt_i->mdl_min[Z] && pz <= ap->a_rt_i->mdl_max[Z] )
		     )
		) {
			/* Point outside model RPP */
			break;	/* done! */
		}

		cutp = &(ap->a_rt_i->rti_CutHead);
		while( cutp->cut_type == CUT_CUTNODE )  {
			switch( cutp->cn.cn_axis )  {
			case X:
				if( px >= cutp->cn.cn_point )  {
					cutp=cutp->cn.cn_r;
				}  else  {
					cutp=cutp->cn.cn_l;
d499 4
a502 6
				break;
			case Y:
				if( py >= cutp->cn.cn_point )  {
					cutp=cutp->cn.cn_r;
				}  else  {
					cutp=cutp->cn.cn_l;
d504 24
a527 6
				break;
			case Z:
				if( pz >= cutp->cn.cn_point )  {
					cutp=cutp->cn.cn_r;
				}  else  {
					cutp=cutp->cn.cn_l;
a528 1
				break;
d530 5
d537 5
a541 20
		if(cutp==CUTTER_NULL || cutp->cut_type != CUT_BOXNODE)
			rt_bomb("rt_advance_to_next_cell(): leaf not boxnode");

		/* Ensure point is located in the indicated cell */
		if( px < cutp->bn.bn_min[X] || px > cutp->bn.bn_max[X] ||
		    py < cutp->bn.bn_min[Y] || py > cutp->bn.bn_max[Y] ||
		    pz < cutp->bn.bn_min[Z] || pz > cutp->bn.bn_max[Z] )  {
			bu_log("rt_advance_to_next_cell(): point not in cell, advancing\n");
		     	if( rt_g.debug & DEBUG_ADVANCE )  {
			    	bu_log(" pt (%.20e,%.20e,%.20e)\n", px, py, pz );
			    	bu_log("  min (%.20e,%.20e,%.20e)\n", V3ARGS(cutp->bn.bn_min) );
			    	bu_log("  max (%.20e,%.20e,%.20e)\n", V3ARGS(cutp->bn.bn_max) );
				bu_log("pt=(%g,%g,%g)\n", px, py, pz );
			     	rt_pr_cut( cutp, 0 );
		     	}
			/*
			 * Move newray point further into new box.  Try again.
			 */
			ssp->dist_corr += OFFSET_DIST;
		    	goto top;
d543 2
d546 45
a590 49
		/* Don't get stuck within the same box for long */
		if( cutp==ssp->lastcut )  {
			fastf_t	delta;
push:			;
		     	if( rt_g.debug & DEBUG_ADVANCE )  {
				bu_log("%d,%d box push odist_corr=%.20e n=%.20e model_end=%.20e\n",
					ap->a_x, ap->a_y,
					ssp->odist_corr, ssp->dist_corr, ssp->model_end );
				bu_log("box_start o=%.20e n=%.20e\nbox_end   o=%.20e n=%.20e\n",
					ssp->obox_start, ssp->box_start,
					ssp->obox_end, ssp->box_end );
				bu_log("Point=(%g,%g,%g)\n", px, py, pz );
				VPRINT("Dir", ssp->newray.r_dir);
			     	rt_pr_cut( cutp, 0 );
		     	}

			/* Advance 1mm, or smallest value that hardware
			 * floating point resolution will allow.
			 */
			fraction = frexp( ssp->box_end, &exponent );

			if( rt_g.debug & DEBUG_ADVANCE )  {
				bu_log("exp=%d, fraction=%.20e\n", exponent, fraction);
			}
			if( sizeof(fastf_t) <= 4 )
				fraction += 1.0e-5;
			else
				fraction += 1.0e-14;
			delta = ldexp( fraction, exponent );
#if MUCHO_DIAGS
		     	if( rt_g.debug & DEBUG_ADVANCE )  {
				bu_log("ldexp: delta=%g, fract=%g, exp=%d\n", delta, fraction, exponent);
		     	}
#endif
			/* Never advance less than 1mm */
			if( delta < 1 )  delta = 1.0;
			ssp->box_start = ssp->box_end + delta;
			ssp->box_end = ssp->box_start + delta;

			if( rt_g.debug & DEBUG_ADVANCE )  {
				bu_log("push%d: was=%.20e, now=%.20e\n\n",
					push_flag,
					ssp->box_end, ssp->box_start);
			}
			push_flag++;
			if( push_flag > 3 )  {
		     		bu_log("rt_advance_to_next_cell(): INTERNAL ERROR: infinite loop aborted, ray %d,%d truncated\n",
					ap->a_x, ap->a_y);
				return CUTTER_NULL;
a591 1
			continue;
a592 13
		if( push_flag )  {
			push_flag = 0;
		     	if( rt_g.debug & DEBUG_ADVANCE )  {
				bu_log("%d,%d Escaped %d. dist_corr=%g, box_start=%g, box_end=%g\n",
					ap->a_x, ap->a_y, push_flag,
					ssp->dist_corr, ssp->box_start, ssp->box_end );
		     	}
		}
	     	if( rt_g.debug & DEBUG_ADVANCE )  {
			bu_log("rt_advance_to_next_cell()=x%x lastcut=x%x\n",
	     			cutp, ssp->lastcut);
	     	}
		ssp->lastcut = cutp;
d594 1
a594 21
		ssp->newray.r_pt[X] = px;
		ssp->newray.r_pt[Y] = py;
		ssp->newray.r_pt[Z] = pz;

		if( !rt_in_rpp(&ssp->newray, ssp->inv_dir,
		     cutp->bn.bn_min, cutp->bn.bn_max) )  {
			bu_log("\nrt_advance_to_next_cell():  MISSED BOX\nrmin,rmax(%.20e,%.20e) box(%.20e,%.20e)\n",
				ssp->newray.r_min, ssp->newray.r_max,
				ssp->box_start, ssp->box_end);
		     	goto push;
		}
		ssp->odist_corr = ssp->dist_corr;
		ssp->obox_start = ssp->box_start;
		ssp->obox_end = ssp->box_end;
		ssp->box_start = ssp->dist_corr + ssp->newray.r_min;
		ssp->box_end = ssp->dist_corr + ssp->newray.r_max;
	     	if( rt_g.debug & DEBUG_ADVANCE )  {
			bu_log("rt_advance_to_next_cell() box=(%g, %g)\n",
				ssp->box_start, ssp->box_end );
	     	}
		return(cutp);
d596 3
a598 10
	/* Off the end of the model RPP */
     	if( rt_g.debug & DEBUG_ADVANCE )  {
		bu_log("rt_advance_to_next_cell()=NULL lastcut=x%x: escaped model RPP\n",
 			ssp->lastcut);
     		VPRINT("mdl_min", ap->a_rt_i->mdl_min);
     		VPRINT("mdl_max", ap->a_rt_i->mdl_max);
     	}
	return(CUTTER_NULL);
	}
#endif
d869 1
@


11.27
log
@Cleaned up macros that were failing to compile on the sun4 port.
@
text
@d33 1
a33 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 11.26 1997/06/13 02:51:43 gdurf Exp gdurf $ (BRL)";
d57 1
a57 1
	if( ap->a_ray.r_dir[_ax] == 0.0 )  { \
d59 2
a60 2
	} else if( ap->a_ray.r_dir[_ax] > 0 ) { \
		ssp->tv[_ax] = (ap->a_rt_i->rti_nu_axis[_ax][_cno].nu_epos - \
d63 1
a63 1
		ssp->tv[_ax] = (ap->a_rt_i->rti_nu_axis[_ax][_cno].nu_spos - \
d67 2
a68 2
	if( ap->a_ray.r_dir[_ax] != 0 )  { \
		ssp->tv[_ax] += ap->a_rt_i->rti_nu_axis[_ax][_cno].nu_width * \
d81 1
a81 1
	fastf_t			obox_start;
d89 4
d94 5
a98 8
	vect_t			inv_dir;	/* inverses of ap->a_ray.r_dir */
	/* Begin NUgrid additions */
	vect_t			abs_inv_dir;	/* absolute value of inv_dir */
	int			igrid[3];	/* integer cell coordinates */
	vect_t			tv;		/* next t intercept values */
	double			t0;		/* t val of cell "in" pt */
	double			t1;		/* t val of cell "out" pt */
	int			out_axis;	/* axis ray will leave through */
d103 44
a147 1
 *
d149 1
d154 1
a154 1
	register CONST union cutter		*cutp;
d157 17
a173 1
	if( ap->a_rt_i->rti_space_partition == RT_PART_NUGRID ) {
d177 25
a201 15
		if( ssp->lastcut == &(ap->a_rt_i->rti_inf_box) )  {
			if( rt_g.debug & DEBUG_ADVANCE )  {
				bu_log("rt_advance_to_next_cell(): finished infinite solids\n");
			}
			return(CUTTER_NULL);
		}
		
		for(;;) {
		    if( ssp->lastcut == CUTTER_NULL )  {
			register int	i, x, y, z;

			ssp->dist_corr = ssp->first_box_start;
			VJOIN1( ssp->newray.r_pt, ap->a_ray.r_pt,
				ssp->dist_corr, ap->a_ray.r_dir );

d205 7
a211 3
			x = rt_find_nugrid(ap->a_rt_i, X, ssp->newray.r_pt[X]);
			y = rt_find_nugrid(ap->a_rt_i, Y, ssp->newray.r_pt[Y]);
			z = rt_find_nugrid(ap->a_rt_i, Z, ssp->newray.r_pt[Z]);
d215 3
a217 3
			cutp = &ap->a_rt_i->rti_nu_grid[z*ap->a_rt_i->rti_nu_stepsize[Z] +
					    y*ap->a_rt_i->rti_nu_stepsize[Y] +
					    x*ap->a_rt_i->rti_nu_stepsize[X]];
d222 1
a222 1

d226 2
a227 2

			ssp->t0 = 0.0;
a228 2
if(rt_g.debug&DEBUG_ADVANCE)bu_log("igrid=(%d, %d, %d)\n", ssp->igrid[X], ssp->igrid[Y], ssp->igrid[Z]);
		    } else {
d230 1
a230 2
			/* Take next step, finding ray entry distance */
			cutp = ssp->lastcut;
d232 4
a235 6
			ssp->t0 = ssp->t1;
			if( ap->a_ray.r_dir[ssp->out_axis] > 0.0 ) {
				if( ++(ssp->igrid[ssp->out_axis]) >=
			     ap->a_rt_i->rti_nu_cells_per_axis[ssp->out_axis] )
					break;
				cutp += ap->a_rt_i->rti_nu_stepsize[ssp->out_axis];
d237 2
a238 3
				if( --(ssp->igrid[ssp->out_axis]) < 0 )
					break;
				cutp -= ap->a_rt_i->rti_nu_stepsize[ssp->out_axis];
a239 22
			NUGRID_T_ADV( ssp->out_axis, ssp->igrid[ssp->out_axis] );
if(rt_g.debug&DEBUG_ADVANCE)bu_log("igrid=(%d, %d, %d)\n", ssp->igrid[X], ssp->igrid[Y], ssp->igrid[Z]);
		    }
		    /* find minimum exit t value */
		    if( ssp->tv[X] < ssp->tv[Y] )  {
			    if( ssp->tv[Z] < ssp->tv[X] )  {
				    ssp->out_axis = Z;
				    ssp->t1 = ssp->tv[Z];
			    } else {
				    ssp->out_axis = X;
				    ssp->t1 = ssp->tv[X];
			    }
		    } else {
			    if( ssp->tv[Z] < ssp->tv[Y] )  {
				    ssp->out_axis = Z;
				    ssp->t1 = ssp->tv[Z];
			    } else {
				    ssp->out_axis = Y;
				    ssp->t1 = ssp->tv[Y];
			    }
		    }
if(rt_g.debug&DEBUG_ADVANCE)bu_log("Exit axis is %c, t1=%g\n", "XYZ*"[ssp->out_axis], ssp->t1);
d241 21
a261 2
		    if(cutp==CUTTER_NULL || cutp->cut_type != CUT_BOXNODE)
			rt_bomb("rt_advance_to_next_cell(): leaf not boxnode");
d263 24
a286 5
		    /* Don't get stuck within the same box */
		    if( cutp==ssp->lastcut )  {
			    rt_bomb("rt_advance_to_next_cell():  stuck in same cell\n");
		    }
		    ssp->lastcut = cutp;
d289 17
a305 1
		 * Automatically skip past empty containers.
d307 262
d570 125
a694 2
		    if( cutp->bn.bn_len <= 0 )
			    continue;
d696 10
a705 27
		/*
		 *  To make life easier on the ray/solid intersectors,
		 *  give them a point "near" their solid, by
		 *  concocting a point roughly in this cell.
		 *  NOTE:  floating point error may cause this point to
		 *  be slightly outside the cell, which does not matter.
		 */
		    ssp->dist_corr = ssp->model_start + ssp->t0;
		    VJOIN1( ssp->newray.r_pt, ap->a_ray.r_pt,
			    ssp->dist_corr, ap->a_ray.r_dir );
		    if( rt_g.debug&DEBUG_ADVANCE) {
			    bu_log("rt_advance_to_next_cell() dist_corr=%g\n",
				   ssp->dist_corr );
			    bu_log("rt_advance_to_next_cell() newray.r_pt=(%g, %g, %g)\n",
				   V3ARGS( ssp->newray.r_pt ) );
		    }

		    ssp->newray.r_min = 0.0;
		    ssp->newray.r_max = ssp->t1 - ssp->t0;

		    ssp->box_start = ssp->first_box_start + ssp->t0;
		    ssp->box_end = ssp->first_box_start + ssp->t1;
		    if( rt_g.debug & DEBUG_ADVANCE )  {
			    bu_log("rt_advance_to_next_cell() box=(%g, %g)\n",
				   ssp->box_start, ssp->box_end );
		    }
		    return(cutp);
a725 3
/*
 *  This version uses Muuss' non-uniform binary space partitioning tree.
 */
d918 1
d979 1
d1074 1
d1077 1
d1081 1
d1085 1
d1088 1
d1092 1
d1096 1
d1099 1
d1103 1
d1184 2
d1205 1
d1216 1
d1305 3
d1702 3
d1714 3
@


11.26
log
@Cleaned up NUgrid code.
Now the NUgrid information is stored on a per-rti basis.
@
text
@d33 1
a33 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 11.25 1997/06/12 17:36:54 gdurf Exp gdurf $ (BRL)";
d60 1
a60 1
		ssp->tv[_ax] = (rti_nu_axis[_ax][_cno].nu_epos - \
d63 1
a63 1
		ssp->tv[_ax] = (rti_nu_axis[_ax][_cno].nu_spos - \
d68 1
a68 1
		ssp->tv[_ax] += rti_nu_axis[_ax][_cno].nu_width * \
a115 5

#define rti_nu_axis		(ap->a_rt_i->rti_nu_axis)
#define rti_nu_cells_per_axis	(ap->a_rt_i->rti_nu_cells_per_axis)
#define rti_nu_stepsize 	(ap->a_rt_i->rti_nu_stepsize)
#define rti_nu_grid		(ap->a_rt_i->rti_nu_grid)			
d140 3
a142 3
			cutp = &rti_nu_grid[z*rti_nu_stepsize[Z] +
					    y*rti_nu_stepsize[Y] +
					    x*rti_nu_stepsize[X]];
d163 1
a163 1
				    rti_nu_cells_per_axis[ssp->out_axis] )
d165 1
a165 1
				cutp += rti_nu_stepsize[ssp->out_axis];
d169 1
a169 1
				cutp -= rti_nu_stepsize[ssp->out_axis];
@


11.25
log
@Finished NUgrid fixes
@
text
@a0 1
#define NUgrid 1
d33 1
a33 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 11.24 1997/06/12 15:27:51 gdurf Exp gdurf $ (BRL)";
a55 13
/* start NUgrid XXX  --  associated with cut.c */
#define RT_NUGRID_CELL(_array,_x,_y,_z)		(&(_array)[ \
	((((_z)*rt_nu_cells_per_axis[Y])+(_y))*rt_nu_cells_per_axis[X])+(_x) ])

struct nu_axis {
	fastf_t	nu_spos;	/* cell start pos */
	fastf_t	nu_epos;	/* cell end pos */
	fastf_t	nu_width;	/* voxel size (end-start) */
};
extern struct nu_axis	*rt_nu_axis[3];
extern int		rt_nu_cells_per_axis[3];
extern union cutter	*rt_nu_grid;

d60 2
a61 2
		ssp->tv[_ax] = (rt_nu_axis[_ax][_cno].nu_epos - ssp->newray.r_pt[_ax]) * \
			ssp->inv_dir[_ax]; \
d63 2
a64 2
		ssp->tv[_ax] = (rt_nu_axis[_ax][_cno].nu_spos - ssp->newray.r_pt[_ax]) * \
			ssp->inv_dir[_ax]; \
d68 1
a68 1
		ssp->tv[_ax] += rt_nu_axis[_ax][_cno].nu_width * \
a100 1
#if NUgrid
a103 1
 *  This version uses Gigante's non-uniform 3-D space grid/mesh discretization.
d109 7
a115 5
	register CONST union cutter	*cutp;
	int			push_flag = 0;
	double			fraction;
	int			exponent;
	register CONST struct application *ap = ssp->ap;
d117 14
a130 16
	if( ssp->lastcut == &(ap->a_rt_i->rti_inf_box) )  {
	     	if( rt_g.debug & DEBUG_ADVANCE )  {
	     		bu_log("rt_advance_to_next_cell(): finished infinite solids\n");
	     	}
		return(CUTTER_NULL);
	}
	for(;;)  {
		if( ssp->lastcut == CUTTER_NULL )  {
			/*
			 *  First time through -- find starting cell.
			 *  For now, linear search to find x,y,z cell indices.
			 *  This should become a binary search
			 *  All distance values (t0, etc) are expressed
			 *  relative to ssp->first_box_start.
			 */
			register int	x, y, z;
a134 14
			if( rt_g.debug&DEBUG_ADVANCE) {
				bu_log("rt_advance_to_next_cell() dist_corr=%g\n",
					ssp->dist_corr );
				bu_log("rt_advance_to_next_cell() newray.r_pt=(%g, %g, %g)\n",
					V3ARGS( ssp->newray.r_pt ) );
			}

			if( ssp->newray.r_pt[X] < rt_nu_axis[X][0].nu_spos )
				break;
			for( x=0; x < rt_nu_cells_per_axis[X]; x++ )  {
				if( ssp->newray.r_pt[X] < rt_nu_axis[X][x].nu_epos )
					break;
			}
			if( x >= rt_nu_cells_per_axis[X] )  break;
d136 2
a137 7
			if( ssp->newray.r_pt[Y] < rt_nu_axis[Y][0].nu_spos )
				break;
			for( y=0; y < rt_nu_cells_per_axis[Y]; y++ )  {
				if( ssp->newray.r_pt[Y] < rt_nu_axis[Y][y].nu_epos )
					break;
			}
			if( y >= rt_nu_cells_per_axis[Y] )  break;
d139 9
a147 8
			if( ssp->newray.r_pt[Z] < rt_nu_axis[Z][0].nu_spos )
				break;
			for( z=0; z < rt_nu_cells_per_axis[Z]; z++ )  {
				if( ssp->newray.r_pt[Z] < rt_nu_axis[Z][z].nu_epos )
					break;
			}
			if( z >= rt_nu_cells_per_axis[Z] )  break;
			cutp = RT_NUGRID_CELL( rt_nu_grid, x, y, z );
a148 4
			/*
			 *  Prepare for efficient advancing from
			 *  cell to cell.
			 */
a151 1
if(rt_g.debug&DEBUG_ADVANCE)bu_log("igrid=(%d, %d, %d)\n", ssp->igrid[X], ssp->igrid[Y], ssp->igrid[Z]);
a152 1
			/* tv[] has intercepts with walls of first cell on ray path */
d157 4
a160 2
			ssp->t0 = 0.0; /* XXX somebody please doublecheck this */
		} else {
d163 2
d166 3
a168 2
			if( ap->a_ray.r_dir[ssp->out_axis] > 0 ) {
				if( ++(ssp->igrid[ssp->out_axis]) >= rt_nu_cells_per_axis[ssp->out_axis] )
d170 1
d174 1
d178 19
a196 22
			/* XXX This too can be optimized */
			cutp = RT_NUGRID_CELL( rt_nu_grid,
				ssp->igrid[X], ssp->igrid[Y], ssp->igrid[Z] );
		}
		/* find minimum exit t value */
		if( ssp->tv[X] < ssp->tv[Y] )  {
			if( ssp->tv[Z] < ssp->tv[X] )  {
				ssp->out_axis = Z;
				ssp->t1 = ssp->tv[Z];
			} else {
				ssp->out_axis = X;
				ssp->t1 = ssp->tv[X];
			}
		} else {
			if( ssp->tv[Z] < ssp->tv[Y] )  {
				ssp->out_axis = Z;
				ssp->t1 = ssp->tv[Z];
			} else {
				ssp->out_axis = Y;
				ssp->t1 = ssp->tv[Y];
			}
		}
d199 1
a199 1
		if(cutp==CUTTER_NULL || cutp->cut_type != CUT_BOXNODE)
d202 12
a213 5
		/* Don't get stuck within the same box */
		if( cutp==ssp->lastcut )  {
			rt_bomb("rt_advance_to_next_cel():  stuck in same cell\n");
		}
		ssp->lastcut = cutp;
d222 20
a241 8
		ssp->dist_corr = ssp->model_start + ssp->t0;
		VJOIN1( ssp->newray.r_pt, ap->a_ray.r_pt,
			ssp->dist_corr, ap->a_ray.r_dir );
		if( rt_g.debug&DEBUG_ADVANCE) {
			bu_log("rt_advance_to_next_cell() dist_corr=%g\n",
				ssp->dist_corr );
			bu_log("rt_advance_to_next_cell() newray.r_pt=(%g, %g, %g)\n",
				V3ARGS( ssp->newray.r_pt ) );
d243 1
a243 13

		ssp->newray.r_min = 0.0;
		ssp->newray.r_max = ssp->t1 - ssp->t0;

		ssp->box_start = ssp->first_box_start + ssp->t0;
		ssp->box_end = ssp->first_box_start + ssp->t1;
	     	if( rt_g.debug & DEBUG_ADVANCE )  {
			bu_log("rt_advance_to_next_cell() box=(%g, %g)\n",
				ssp->box_start, ssp->box_end );
	     	}
		return(cutp);
	}
	/* Off the end of the model RPP */
d245 7
a251 7
	if( ap->a_rt_i->rti_inf_box.bn.bn_len > 0 )  {
	     	if( rt_g.debug & DEBUG_ADVANCE )  {
	     		bu_log("rt_advance_to_next_cell(): escaped model RPP, checking infinite solids\n");
	     	}
		ssp->lastcut = &(ap->a_rt_i->rti_inf_box);
		return &(ap->a_rt_i->rti_inf_box);
	}
d253 6
a258 7
     	if( rt_g.debug & DEBUG_ADVANCE )  {
     		bu_log("rt_advance_to_next_cell(): escaped model RPP\n");
     	}
	ssp->lastcut = CUTTER_NULL;
	return(CUTTER_NULL);
}
#else
d261 1
a262 2
 *			R T _ A D V A N C E _ T O _ N E X T _ C E L L
 *
d265 4
a268 10
CONST union cutter *
rt_advance_to_next_cell( ssp )
register struct shootray_status	*ssp;
{
	register CONST union cutter	*cutp;
	int			push_flag = 0;
	double			fraction;
	int			exponent;
	register CONST struct application *ap = ssp->ap;
	register fastf_t	px, py, pz;	/* Adjusted ray pt */
d270 1
a270 1
	for(;;)  {
d456 1
a457 1
#endif
@


11.24
log
@NUgrid fixes
@
text
@d1 1
a1 1
#define NUgrid 0
d34 1
a34 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 11.23 1997/02/14 06:12:41 mike Exp gdurf $ (BRL)";
a146 2
			int	in_axis;
			int	j;
d197 1
a197 2
			ssp->t0 = 0; /* XXX somebody please doublecheck this */
			}
d233 1
a233 1
if(rt_g.debug&DEBUG_ADVANCE)bu_log("Exit axis is %s, t1=%g\n", ssp->out_axis==X ? "X" : (ssp->out_axis==Y?"Y":"Z"), ssp->t1);
d261 1
a261 1
		ssp->newray.r_min = 0;
d285 1
@


11.23
log
@Defined negative value of a_onehit to specify the number of
non-air hits required.
@
text
@d34 1
a34 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 11.22 1997/01/30 01:45:39 mike Exp mike $ (BRL)";
d61 1
a61 1
struct rt_nu_axis {
d73 1
a73 1
	} else if( ap->a_ray.r_dir[_ax] < 0 ) { \
d199 1
a199 57
			/*
			 *  Find face (axis) of entry into first cell
			 *  using Cyrus&Beck -- max initial t value.
			 */
			if( ssp->tv[X] >= ssp->tv[Y] && ssp->tv[X] < INFINITY )  {
				in_axis = X;
				ssp->t0 = ssp->tv[X];
			} else {
				in_axis = Y;
				ssp->t0 = ssp->tv[Y];
			}
			if( ssp->tv[Z] > ssp->t0 && ssp->tv[Z] < INFINITY)  {
				in_axis = Z;
				ssp->t0 = ssp->tv[Z];
			}
if(rt_g.debug&DEBUG_ADVANCE) VPRINT("Entry tv[]", ssp->tv);
if(rt_g.debug&DEBUG_ADVANCE)bu_log("Entry axis is %s, t0=%g\n", in_axis==X ? "X" : (in_axis==Y?"Y":"Z"), ssp->t0);

			/* Advance to next exits */
			NUGRID_T_ADV( X, x );
			NUGRID_T_ADV( Y, y );
			NUGRID_T_ADV( Z, z );
if(rt_g.debug&DEBUG_ADVANCE) VPRINT("Exit tv[]", ssp->tv);

			/* XXX?Ensure that next exit is after first entrance */
			while( ssp->tv[X] < ssp->t0 && ap->a_ray.r_dir[X] != 0.0 )  {
				bu_log("*** at t=%g, pt[X]=%g\n",
					ssp->tv[X], ssp->newray.r_pt[X] + ssp->tv[X] *
					ap->a_ray.r_dir[X] );
				NUGRID_T_ADV( X, x );
				bu_log("*** advancing tv[X] to %g\n", ssp->tv[X]);
				bu_log("*** at t=%g, pt[X]=%g\n",
					ssp->tv[X], ssp->newray.r_pt[X] + ssp->tv[X] *
					ap->a_ray.r_dir[X] );
				rt_bomb("advancing\n");
			}
			while( ssp->tv[Y] < ssp->t0 && ap->a_ray.r_dir[Y] != 0.0 )  {
				bu_log("*** at t=%g, pt[Y]=%g\n",
					ssp->tv[Y], ssp->newray.r_pt[Y] + ssp->tv[Y] *
					ap->a_ray.r_dir[Y] );
				NUGRID_T_ADV( Y, y );
				bu_log("*** advancing tv[Y] to %g\n", ssp->tv[Y]);
				bu_log("*** at t=%g, pt[Y]=%g\n",
					ssp->tv[Y], ssp->newray.r_pt[Y] + ssp->tv[Y] *
					ap->a_ray.r_dir[Y] );
				rt_bomb("advancing\n");
			}
			while( ssp->tv[Z] < ssp->t0 && ap->a_ray.r_dir[Z] != 0.0 )  {
				bu_log("*** at t=%g, pt[Z]=%g\n",
					ssp->tv[Z], ssp->newray.r_pt[Z] + ssp->tv[Z] *
					ap->a_ray.r_dir[Z] );
				NUGRID_T_ADV( Z, z );
				bu_log("*** advancing tv[Z] to %g\n", ssp->tv[Z]);
				bu_log("*** at t=%g, pt[Z]=%g\n",
					ssp->tv[Z], ssp->newray.r_pt[Z] + ssp->tv[Z] *
					ap->a_ray.r_dir[Z] );
				rt_bomb("advancing\n");
a204 1
			NUGRID_T_ADV( ssp->out_axis, ssp->igrid[ssp->out_axis] );
d212 1
@


11.22
log
@Improved advance-to-next-cell debug messages
@
text
@d34 1
a34 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 11.21 1997/01/10 15:29:57 jra Exp mike $ (BRL)";
d881 1
a881 1
		 *  If a_onehit <= 0 and a_ray_length <= 0, then the ray
d884 1
a884 1
		 *  If a_onehit > 0, then it indicates how many hit points
d887 1
d897 1
a897 1
		if( ap->a_onehit > 0 && BU_LIST_NON_EMPTY( &(waiting_segs.l) ) )  {
@


11.21
log
@Added re_nmgfree freelist for "hitmiss" structures.
@
text
@d34 1
a34 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 11.20 1996/11/22 08:49:41 mike Exp jra $ (BRL)";
d515 4
d545 2
a546 1
     		bu_log("rt_advance_to_next_cell(): escaped model RPP\n");
@


11.20
log
@Improved "box push" handling.
NOTE:  It still depends on much too much of this.
Example:
rtshot -x 00800003 -p -49, -68, 63 -d 0, 1, 0 ../.db.6d/moss.g all.g
@
text
@d34 1
a34 1
static char RCSshoot[] = "@@(#)$Header: /n/vapor/m/cad/librt/RCS/shoot.c,v 11.19 1996/11/22 07:37:34 mike Exp mike $ (BRL)";
d651 2
@


11.19
log
@Improved debugging prints,
added check for infinite loops.
@
text
@d34 1
a34 1
static char RCSshoot[] = "@@(#)$Header: /n/vapor/m/cad/librt/RCS/shoot.c,v 11.18 1996/09/27 08:32:21 mike Exp mike $ (BRL)";
d348 1
a348 1
#define MUCHO_DIAGS	0
a386 2
		if( ssp->dist_corr >= ssp->model_end )
			break;	/* done! */
d395 10
d457 1
d463 1
a463 1
				bu_log("box_start o=%.20e n=%.20e, box_end o=%.20e n=%.20e\n",
a467 1
#if MUCHO_DIAGS
a468 1
#endif
d475 9
d486 1
a486 1
				bu_log("frexp: box_end=%g, fract=%g, exp=%d\n", ssp->box_end, fraction, exponent);
d489 5
a493 18
			if( exponent <= 0 )  {
				/* Never advance less than 1mm */
				ssp->box_start = ssp->box_end + 1.0;
			} else {
				if( rt_g.debug & DEBUG_ADVANCE )  {
					bu_log("exp=%d, fraction=%.20e\n", exponent, fraction);
				}
				if( sizeof(fastf_t) <= 4 )
					fraction += 1.0e-5;
				else
					fraction += 1.0e-14;
				ssp->box_start = ldexp( fraction, exponent );
#if MUCHO_DIAGS
		     	if( rt_g.debug & DEBUG_ADVANCE )  {
				bu_log("ldexp: box_end=%g, fract=%g, exp=%d\n", ssp->box_end, fraction, exponent);
		     	}
#endif
			}
d495 2
a496 1
				bu_log("push: was=%.20e, now=%.20e\n",
d500 2
a501 2
			if( push_flag > 7 )  {
		     		bu_log("rt_advance_to_next_cell(): internal ERROR: infinite loop aborted, ray %d,%d truncated\n",
d542 2
@


11.18
log
@Double BU_
@
text
@d34 1
a34 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 11.17 1996/09/27 08:27:30 mike Exp mike $ (BRL)";
d347 2
d433 7
a439 7
#if 0
		    	bu_log(" pt (%.20e,%.20e,%.20e)\n", px, py, pz );
		    	bu_log("  min (%.20e,%.20e,%.20e)\n", V3ARGS(cutp->bn.bn_min) );
		    	bu_log("  max (%.20e,%.20e,%.20e)\n", V3ARGS(cutp->bn.bn_max) );
			bu_log("pt=(%g,%g,%g)\n", px, py, pz );
		     	rt_pr_cut( cutp, 0 );
#endif
d450 11
a460 13
#if 0
			bu_log("%d,%d box push odist_corr=%.20e n=%.20e model_end=%.20e\n",
				ap->a_x, ap->a_y,
				ssp->odist_corr, ssp->dist_corr, ssp->model_end );
			bu_log("box_start o=%.20e n=%.20e, box_end o=%.20e n=%.20e\n",
				ssp->obox_start, ssp->box_start,
				ssp->obox_end, ssp->box_end );
#endif
#if 0
			VPRINT("a_ray.r_pt", ap->a_ray.r_pt);
			bu_log("Point=(%g,%g,%g)\n", px, py, pz );
			VPRINT("Dir", ssp->newray.r_dir);
		     	rt_pr_cut( cutp, 0 );
d462 1
d468 4
a471 2
#if 0
bu_log("frexp: box_end=%g, fract=%g, exp=%d\n", ssp->box_end, fraction, exponent);
d485 4
a488 2
#if 0
bu_log("ldexp: box_end=%g, fract=%g, exp=%d\n", ssp->box_end, fraction, exponent);
d496 5
d505 5
a509 5
#if 0
			bu_log("%d,%d Escaped %d. dist_corr=%g, box_start=%g, box_end=%g\n",
				ap->a_x, ap->a_y, push_flag,
				ssp->dist_corr, ssp->box_start, ssp->box_end );
#endif
@


11.17
log
@Converted to using proper routine names for LIBBU and LIBBN routines.
@
text
@d34 1
a34 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 11.16 1996/08/31 04:20:54 mike Exp mike $ (BRL)";
d655 1
a655 1
		BU_BU_GETSTRUCT( regionbits, bu_ptbl );
@


11.16
log
@Changed calling sequence to bu_ptbl_init() to have reason string
for bu_malloc() tracking
@
text
@d34 1
a34 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 11.15 1996/08/31 03:15:29 mike Exp mike $ (BRL)";
d623 3
a625 3
	RT_LIST_INIT( &new_segs.l );
	RT_LIST_INIT( &waiting_segs.l );
	RT_LIST_INIT( &finished_segs.l );
d627 2
a628 2
	if( RT_LIST_UNINITIALIZED( &resp->re_parthead ) )  {
		RT_LIST_INIT( &resp->re_parthead );
d631 4
a634 4
		if( RT_LIST_UNINITIALIZED( &resp->re_solid_bitv ) )
			RT_LIST_INIT(  &resp->re_solid_bitv );
		if( RT_LIST_UNINITIALIZED( &resp->re_region_ptbl ) )
			RT_LIST_INIT(  &resp->re_region_ptbl );
d644 1
a644 1
	if( RT_LIST_IS_EMPTY( &resp->re_solid_bitv ) )  {
d647 2
a648 2
		solidbits = RT_LIST_FIRST( bu_bitv, &resp->re_solid_bitv );
		RT_LIST_DEQUEUE( &solidbits->l );
d654 2
a655 2
	if( RT_LIST_IS_EMPTY( &resp->re_region_ptbl ) )  {
		BU_GETSTRUCT( regionbits, bu_ptbl );
d658 2
a659 2
		regionbits = RT_LIST_FIRST( bu_ptbl, &resp->re_region_ptbl );
		RT_LIST_DEQUEUE( &regionbits->l );
d743 1
a743 1
	    	if( RT_LIST_NON_EMPTY( &waiting_segs.l ) )  {
d836 1
a836 1
			RT_LIST_INIT( &(new_segs.l) );
d846 2
a847 2
				while(RT_LIST_WHILE(s2,seg,&(new_segs.l)))  {
					RT_LIST_DEQUEUE( &(s2->l) );
d851 1
a851 1
					RT_LIST_INSERT( &(waiting_segs.l), &(s2->l) );
d873 1
a873 1
		if( ap->a_onehit > 0 && RT_LIST_NON_EMPTY( &(waiting_segs.l) ) )  {
d900 1
a900 1
	if( RT_LIST_NON_EMPTY( &(waiting_segs.l) ) )  {
d905 1
a905 1
	if( RT_LIST_IS_EMPTY( &(finished_segs.l) ) )  {
d965 1
a965 1
	RT_LIST_APPEND( &resp->re_solid_bitv, &solidbits->l );
d967 1
a967 1
	RT_LIST_APPEND( &resp->re_region_ptbl, &regionbits->l );
d1236 1
a1236 1
	RT_LIST_INIT( &(seghead.l) );
d1245 2
a1246 2
				tmp_seg = RT_LIST_FIRST(seg, &(seghead.l) );
				RT_LIST_DEQUEUE( &(tmp_seg->l) );
@


11.15
log
@Added rti_resources, and rt_free_resource(), to allow returning
all the per-CPU memory allocations.
@
text
@d34 1
a34 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 11.14 1996/08/29 06:34:21 mike Exp mike $ (BRL)";
d656 1
a656 1
		bu_ptbl_init( regionbits, 7 );
@


11.14
log
@More initializations needed for new partition structure freelist.
@
text
@d34 1
a34 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 11.13 1996/08/28 10:03:46 mike Exp mike $ (BRL)";
d633 10
a642 2
		if( RT_LIST_UNINITIALIZED( &resp->re_region_bitv ) )
			RT_LIST_INIT(  &resp->re_region_bitv );
d654 1
a654 1
	if( RT_LIST_IS_EMPTY( &resp->re_region_bitv ) )  {
d658 1
a658 1
		regionbits = RT_LIST_FIRST( bu_ptbl, &resp->re_region_bitv );
d967 1
a967 1
	RT_LIST_APPEND( &resp->re_region_bitv, &regionbits->l );
@


11.13
log
@st_regions is now a bu_ptbl, not a bitvector.
"regionbits" is also a bu_ptbl, not a bitvector.
@
text
@d34 1
a34 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 11.12 1996/08/28 04:02:56 mike Exp mike $ (BRL)";
d627 9
a635 2
	if( RT_LIST_UNINITIALIZED( &resp->re_solid_bitv ) )
		RT_LIST_INIT(  &resp->re_solid_bitv );
a645 2
	if( RT_LIST_UNINITIALIZED( &resp->re_region_bitv ) )
		RT_LIST_INIT(  &resp->re_region_bitv );
@


11.12
log
@Changed to use bu_bitv() routines
@
text
@d34 1
a34 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 11.11 1996/08/27 02:42:09 mike Exp mike $ (BRL)";
d569 2
a570 2
	AUTO struct bu_bitv	*solidbits;	/* bits for all solids shot so far */
	AUTO struct bu_bitv	*regionbits;	/* bits for all involved regions */
d642 2
a643 1
		regionbits = bu_bitv_new( rtip->nregions );
d645 1
a645 1
		regionbits = RT_LIST_FIRST( bu_bitv, &resp->re_region_bitv );
d647 1
a647 2
		BU_CK_BITV(regionbits);
		BU_BITV_NBITS_CHECK( regionbits, rtip->nregions );
d950 1
a950 1
	/*  Free dynamic resources.  */
d953 1
a953 1
	BU_CK_BITV(regionbits);
@


11.11
log
@Last minute name change.
@
text
@d34 1
a34 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 11.10 1996/08/27 02:29:24 mike Exp mike $ (BRL)";
d569 2
a570 2
	AUTO union bitv_elem	*solidbits;	/* bits for all solids shot so far */
	AUTO bitv_t		*regionbits;	/* bits for all involved regions */
d627 11
a637 5
	/* see rt_get_bitv() for details on how bitvector len is set. */
	GET_BITV( rtip, solidbits, resp );
	bzero( (char *)solidbits, rtip->rti_bv_bytes );
	regionbits = &solidbits->be_v[
		2+RT_BITV_BITS2WORDS(rtip->nsolids)];
d639 11
d709 1
a709 1
			BITSET( solidbits->be_v, stp->st_bit );
d799 1
a799 1
			if( BITTEST( solidbits->be_v, stp->st_bit ) )  {
d804 1
a804 1
			BITSET( solidbits->be_v, stp->st_bit );
d951 4
a954 3
	if( solidbits != BITV_NULL)  {
		FREE_BITV( solidbits, resp );
	}
a1080 61
}

/*
 *			R T _ B I T V _ O R
 */
void
rt_bitv_or( out, in, nbits )
register bitv_t *out;
register bitv_t *in;
int nbits;
{
	register int words;

	words = RT_BITV_BITS2WORDS(nbits);
#ifdef VECTORIZE
#	include "noalias.h"
	for( --words; words >= 0; words-- )
		out[words] |= in[words];
#else
	while( words-- > 0 )
		*out++ |= *in++;
#endif
}

/*
 *  			R T _ G E T _ B I T V
 *  
 *  This routine is called by the GET_BITV macro when the freelist
 *  is exhausted.  Rather than simply getting one additional structure,
 *  we get a whole batch, saving overhead.  When this routine is called,
 *  the bitv resource must already be locked.
 *  malloc() locking is done in rt_malloc.
 *
 *  Also note that there is a bit of trickery going on here:
 *  the *real* size of be_v[] array is determined at runtime, here.
 */
void
rt_get_bitv(rtip, res)
struct rt_i		*rtip;
register struct resource *res;
{
	register char *cp;
	register int bytes;
	register int size;		/* size of structure to really get */

	RT_CK_RTI(rtip);
	RT_RESOURCE_CHECK(res);

	size = rtip->rti_bv_bytes;
	if( size < 1 )  rt_bomb("rt_get_bitv");
	size = (size+sizeof(long)-1) & ~(sizeof(long)-1);
	bytes = bu_malloc_len_roundup(16*size);
	cp = (char *)bu_malloc(bytes, "rt_get_bitv");

	while( bytes >= size )  {
		((union bitv_elem *)cp)->be_next = res->re_bitv;
		res->re_bitv = (union bitv_elem *)cp;
		res->re_bitvlen++;
		cp += size;
		bytes -= size;
	}
@


11.10
log
@bu.h
@
text
@d34 1
a34 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 11.9 1996/08/27 02:25:16 mike Exp mike $ (BRL)";
d593 1
a593 1
		bu_log_indent(2);
d945 1
a945 1
		bu_log_indent(-2);
@


11.9
log
@Changed calling sequence of a_hit for Lee and Paul to do
non-solid modeling stuff.
@
text
@d34 1
a34 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 11.8 1996/06/14 12:25:45 jra Exp mike $ (BRL)";
d45 1
d133 1
a133 1
	     		rt_log("rt_advance_to_next_cell(): finished infinite solids\n");
d154 1
a154 1
				rt_log("rt_advance_to_next_cell() dist_corr=%g\n",
d156 1
a156 1
				rt_log("rt_advance_to_next_cell() newray.r_pt=(%g, %g, %g)\n",
d192 1
a192 1
if(rt_g.debug&DEBUG_ADVANCE)rt_log("igrid=(%d, %d, %d)\n", ssp->igrid[X], ssp->igrid[Y], ssp->igrid[Z]);
d215 1
a215 1
if(rt_g.debug&DEBUG_ADVANCE)rt_log("Entry axis is %s, t0=%g\n", in_axis==X ? "X" : (in_axis==Y?"Y":"Z"), ssp->t0);
d225 1
a225 1
				rt_log("*** at t=%g, pt[X]=%g\n",
d229 2
a230 2
				rt_log("*** advancing tv[X] to %g\n", ssp->tv[X]);
				rt_log("*** at t=%g, pt[X]=%g\n",
d236 1
a236 1
				rt_log("*** at t=%g, pt[Y]=%g\n",
d240 2
a241 2
				rt_log("*** advancing tv[Y] to %g\n", ssp->tv[Y]);
				rt_log("*** at t=%g, pt[Y]=%g\n",
d247 1
a247 1
				rt_log("*** at t=%g, pt[Z]=%g\n",
d251 2
a252 2
				rt_log("*** advancing tv[Z] to %g\n", ssp->tv[Z]);
				rt_log("*** at t=%g, pt[Z]=%g\n",
d269 1
a269 1
if(rt_g.debug&DEBUG_ADVANCE)rt_log("igrid=(%d, %d, %d)\n", ssp->igrid[X], ssp->igrid[Y], ssp->igrid[Z]);
d292 1
a292 1
if(rt_g.debug&DEBUG_ADVANCE)rt_log("Exit axis is %s, t1=%g\n", ssp->out_axis==X ? "X" : (ssp->out_axis==Y?"Y":"Z"), ssp->t1);
d314 1
a314 1
			rt_log("rt_advance_to_next_cell() dist_corr=%g\n",
d316 1
a316 1
			rt_log("rt_advance_to_next_cell() newray.r_pt=(%g, %g, %g)\n",
d326 1
a326 1
			rt_log("rt_advance_to_next_cell() box=(%g, %g)\n",
d335 1
a335 1
	     		rt_log("rt_advance_to_next_cell(): escaped model RPP, checking infinite solids\n");
d342 1
a342 1
     		rt_log("rt_advance_to_next_cell(): escaped model RPP\n");
d392 1
a392 1
			rt_log("rt_advance_to_next_cell() dist_corr=%g, pt=(%g, %g, %g)\n",
d430 1
a430 1
			rt_log("rt_advance_to_next_cell(): point not in cell, advancing\n");
d432 4
a435 4
		    	rt_log(" pt (%.20e,%.20e,%.20e)\n", px, py, pz );
		    	rt_log("  min (%.20e,%.20e,%.20e)\n", V3ARGS(cutp->bn.bn_min) );
		    	rt_log("  max (%.20e,%.20e,%.20e)\n", V3ARGS(cutp->bn.bn_max) );
			rt_log("pt=(%g,%g,%g)\n", px, py, pz );
d449 1
a449 1
			rt_log("%d,%d box push odist_corr=%.20e n=%.20e model_end=%.20e\n",
d452 1
a452 1
			rt_log("box_start o=%.20e n=%.20e, box_end o=%.20e n=%.20e\n",
d458 1
a458 1
			rt_log("Point=(%g,%g,%g)\n", px, py, pz );
d468 1
a468 1
rt_log("frexp: box_end=%g, fract=%g, exp=%d\n", ssp->box_end, fraction, exponent);
d475 1
a475 1
					rt_log("exp=%d, fraction=%.20e\n", exponent, fraction);
d483 1
a483 1
rt_log("ldexp: box_end=%g, fract=%g, exp=%d\n", ssp->box_end, fraction, exponent);
d487 1
a487 1
				rt_log("push: was=%.20e, now=%.20e\n",
d496 1
a496 1
			rt_log("%d,%d Escaped %d. dist_corr=%g, box_start=%g, box_end=%g\n",
d509 1
a509 1
			rt_log("\nrt_advance_to_next_cell():  MISSED BOX\nrmin,rmax(%.20e,%.20e) box(%.20e,%.20e)\n",
d520 1
a520 1
			rt_log("rt_advance_to_next_cell() box=(%g, %g)\n",
d527 1
a527 1
     		rt_log("rt_advance_to_next_cell(): escaped model RPP\n");
d584 1
a584 1
		if(rt_g.debug)rt_log("rt_shootray:  defaulting a_resource to &rt_uniresource\n");
d593 2
a594 2
		rt_g.rtg_logindent += 2;
		rt_log("\n**********shootray cpu=%d  %d,%d lvl=%d (%s)\n",
d599 1
a599 1
		rt_log("Pnt (%g, %g, %g) a_onehit=%d\n",
d605 1
a605 1
		rt_log("\n**********shootray cpu=%d  %d,%d lvl=%d (%s)\n",
d643 1
a643 1
			rt_log("rt_shootray: non-unit dir vect (x%d y%d lvl%d)\n",
d691 1
a691 1
			if(debug_shoot)rt_log("shooting %s\n", stp->st_name);
d793 1
a793 1
					if(debug_shoot)rt_log("rpp miss %s\n", stp->st_name);
d798 1
a798 1
					if(debug_shoot)rt_log("rpp skip %s, dist_corr=%g, r_max=%g\n", stp->st_name, ss.dist_corr, ss.newray.r_max);
d804 1
a804 1
			if(debug_shoot)rt_log("shooting %s\n", stp->st_name);
d945 2
a946 5
		if( rt_g.rtg_logindent > 0 )
			rt_g.rtg_logindent -= 2;
		else
			rt_g.rtg_logindent = 0;
		rt_log("----------shootray cpu=%d  %d,%d lvl=%d (%s) %s ret=%d\n",
d1114 2
a1115 2
	bytes = rt_byte_roundup(16*size);
	cp = rt_malloc(bytes, "rt_get_bitv");
d1149 1
a1149 1
rt_log("sv=%g, r_max=%g\n", sv, rp->r_max);
d1153 1
a1153 1
rt_log("st=%g, r_min=%g\n", st, rp->r_min);
d1156 1
a1156 1
rt_log("r_min=%g, r_max=%g\n", rp->r_min, rp->r_max);
d1161 1
a1161 1
rt_log("st=%g, r_max=%g\n", st, rp->r_max);
d1165 1
a1165 1
rt_log("sv=%g, r_min=%g\n", sv, rp->r_min);
d1168 1
a1168 1
rt_log("r_min=%g, r_max=%g\n", rp->r_min, rp->r_max);
d1185 1
a1185 1
rt_log("sv=%g, r_max=%g\n", sv, rp->r_max);
d1189 1
a1189 1
rt_log("st=%g, r_min=%g\n", st, rp->r_min);
d1192 1
a1192 1
rt_log("r_min=%g, r_max=%g\n", rp->r_min, rp->r_max);
d1197 1
a1197 1
rt_log("st=%g, r_max=%g\n", st, rp->r_max);
d1201 1
a1201 1
rt_log("sv=%g, r_min=%g\n", sv, rp->r_min);
d1204 1
a1204 1
rt_log("r_min=%g, r_max=%g\n", rp->r_min, rp->r_max);
d1216 1
a1216 1
rt_log("sv=%g, r_max=%g\n", sv, rp->r_max);
d1220 1
a1220 1
rt_log("st=%g, r_min=%g\n", st, rp->r_min);
d1223 1
a1223 1
rt_log("r_min=%g, r_max=%g\n", rp->r_min, rp->r_max);
d1228 1
a1228 1
rt_log("st=%g, r_max=%g\n", st, rp->r_max);
d1232 1
a1232 1
rt_log("sv=%g, r_min=%g\n", sv, rp->r_min);
d1235 1
a1235 1
rt_log("r_min=%g, r_max=%g\n", rp->r_min, rp->r_max);
d1244 1
a1244 1
	rt_log("HIT:  %g..%g\n", rp->r_min, rp->r_max );
d1247 1
a1247 1
	rt_log("MISS\n");
d1292 1
a1292 1
	rt_log("%s", rt_version);
@


11.8
log
@Change to insure that rays stopped by a_ray_length handle misses correctly.
@
text
@d34 1
a34 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 11.7 1996/06/12 17:03:17 jra Exp $ (BRL)";
d918 5
a922 1
	ap->a_return = ap->a_hit( ap, &FinalPart );
@


11.7
log
@Improved the way ap.a_ray_length is handled.
@
text
@d34 1
a34 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 11.6 1996/06/12 13:34:02 jra Exp jra $ (BRL)";
d858 1
a858 11
		{
			/* Weave these segments into partition list */
			rt_boolweave( &finished_segs, &waiting_segs, &InitialPart, ap );

			/* Evaluate regions upto box_end */
			(void)rt_boolfinal( &InitialPart, &FinalPart,
				last_bool_start, ss.box_end, regionbits, ap );
			last_bool_start = ss.box_end;

			goto hitit;
		}
@


11.6
log
@Added code to rt_shootray() to stop when ray has been traced requested length.
@
text
@d34 1
a34 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 11.5 1995/11/02 18:34:33 cjohnson Exp jra $ (BRL)";
d842 1
a842 1
		if( (ap->a_onehit > 0 || ap->a_ray_length > 0.0) && RT_LIST_NON_EMPTY( &(waiting_segs.l) ) )  {
d855 13
@


11.5
log
@rt_malloc rt_bombs when there is no more memory, no need for if test.
@
text
@d34 1
a34 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 11.4 1995/08/23 02:56:11 mike Exp cjohnson $ (BRL)";
d827 2
a828 1
		 *  If a_onehit <= 0, then the ray is traced to +infinity.
d840 1
d842 1
a842 1
		if( ap->a_onehit > 0 && RT_LIST_NON_EMPTY( &(waiting_segs.l) ) )  {
@


11.4
log
@Print a_onehit
@
text
@d34 1
a34 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 11.3 1995/06/30 15:55:05 gdurf Exp mike $ (BRL)";
d1108 2
a1109 4
	if( (cp = rt_malloc(bytes, "rt_get_bitv")) == (char *)0 )  {
		rt_log("rt_get_bitv: malloc failure\n");
		exit(17);
	}
@


11.3
log
@Fixed goofy extern
@
text
@d34 1
a34 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 11.2 1995/06/16 17:29:09 pjt Exp gdurf $ (BRL)";
d598 3
a600 1
		VPRINT("Pnt", ap->a_ray.r_pt);
@


11.2
log
@Added magic number setting and checking to partition heads.
@
text
@d34 1
a34 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 11.1 1995/01/04 09:58:37 mike Rel4_4 pjt $ (BRL)";
a37 2

extern char rt_version[];	/* Refer to compilation version in vers.c */
@


11.1
log
@Release_4.4
@
text
@d34 1
a34 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 10.8 94/12/27 18:42:54 mike Exp $ (BRL)";
d618 1
d620 1
@


10.8
log
@nu_grid to rt_nu_grid
@
text
@d34 1
a34 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 10.7 94/12/27 16:29:46 mike Exp Locker: mike $ (BRL)";
@


10.7
log
@added rt_ prefix to NUgrid variables
@
text
@d34 1
a34 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 10.6 94/11/04 05:38:04 mike Exp Locker: mike $ (BRL)";
d69 1
a69 1
extern union cutter	*nu_grid;
d184 1
a184 1
			cutp = RT_NUGRID_CELL( nu_grid, x, y, z );
d272 1
a272 1
			cutp = RT_NUGRID_CELL( nu_grid,
@


10.6
log
@Irix 6
@
text
@d34 1
a34 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 10.5 94/09/16 20:20:07 mike Exp Locker: mike $ (BRL)";
d60 1
a60 1
	((((_z)*nu_cells_per_axis[Y])+(_y))*nu_cells_per_axis[X])+(_x) ])
d62 1
a62 1
struct nu_axis {
d67 2
a68 2
extern struct nu_axis	*nu_axis[3];
extern int		nu_cells_per_axis[3];
d75 1
a75 1
		ssp->tv[_ax] = (nu_axis[_ax][_cno].nu_epos - ssp->newray.r_pt[_ax]) * \
d78 1
a78 1
		ssp->tv[_ax] = (nu_axis[_ax][_cno].nu_spos - ssp->newray.r_pt[_ax]) * \
d83 1
a83 1
		ssp->tv[_ax] += nu_axis[_ax][_cno].nu_width * \
d161 1
a161 1
			if( ssp->newray.r_pt[X] < nu_axis[X][0].nu_spos )
d163 2
a164 2
			for( x=0; x < nu_cells_per_axis[X]; x++ )  {
				if( ssp->newray.r_pt[X] < nu_axis[X][x].nu_epos )
d167 1
a167 1
			if( x >= nu_cells_per_axis[X] )  break;
d169 1
a169 1
			if( ssp->newray.r_pt[Y] < nu_axis[Y][0].nu_spos )
d171 2
a172 2
			for( y=0; y < nu_cells_per_axis[Y]; y++ )  {
				if( ssp->newray.r_pt[Y] < nu_axis[Y][y].nu_epos )
d175 1
a175 1
			if( y >= nu_cells_per_axis[Y] )  break;
d177 1
a177 1
			if( ssp->newray.r_pt[Z] < nu_axis[Z][0].nu_spos )
d179 2
a180 2
			for( z=0; z < nu_cells_per_axis[Z]; z++ )  {
				if( ssp->newray.r_pt[Z] < nu_axis[Z][z].nu_epos )
d183 1
a183 1
			if( z >= nu_cells_per_axis[Z] )  break;
d264 1
a264 1
				if( ++(ssp->igrid[ssp->out_axis]) >= nu_cells_per_axis[ssp->out_axis] )
@


10.5
log
@Moved macros to raytrace.h
@
text
@d34 1
a34 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 10.4 94/08/10 19:59:10 gdurf Exp Locker: mike $ (BRL)";
a577 1
	int			end_free_len;
@


10.4
log
@Added include of conf.h
@
text
@a0 4
/* XXX Move to raytrace.h */
#define	RT_BADNUM(n)	(!((n) >= -INFINITY && (n) <= INFINITY))
#define RT_BADVEC(v)	(RT_BADNUM((v)[X]) || RT_BADNUM((v)[Y]) || RT_BADNUM((v)[Z]))

d34 1
a34 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 10.3 1994/05/06 03:39:40 mike Exp gdurf $ (BRL)";
@


10.3
log
@Added extra checking for illegal r_pt and r_dir values.
@
text
@d38 1
a38 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 10.2 93/03/02 17:29:18 mike Exp Locker: mike $ (BRL)";
d44 2
@


10.2
log
@RT_LIST_LOOP is now RT_LIST_WHILE
@
text
@d1 4
d38 1
a38 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 10.1 91/10/12 06:41:00 mike Rel4_0 Locker: mike $ (BRL)";
d559 3
a561 2
 *  An open issue for execution in a PARALLEL environment is locking
 *  of the statistics variables.
a589 1
	RT_RESOURCE_CHECK(ap->a_resource);
d592 1
d594 1
d606 10
d1101 3
@


10.1
log
@Release_4.0
@
text
@d34 1
a34 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 9.38 91/10/01 02:47:28 mike Exp $ (BRL)";
d800 1
a800 1
				while(RT_LIST_LOOP(s2,seg,&(new_segs.l)))  {
@


9.38
log
@Significant performance win on the SGI, by eliminating use of
 RES_ACQUIRE( &rt_g.res_stats );
entirely, and using per-cpu statistics, hidden away in the
resource structure
@
text
@d34 1
a34 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 9.37 91/08/30 03:28:12 mike Exp Locker: mike $ (BRL)";
@


9.37
log
@Fixed bug reported by Moss.
Was too aggressive about returning storage.
@
text
@d34 1
a34 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 9.36 91/07/25 06:04:32 butler Exp $ (BRL)";
d574 1
a577 3
	int			l_nshots = 0;
	int			l_nmiss = 0;
	int			l_nhits = 0;
d588 1
d593 1
a593 1
			ap->a_resource->re_cpu,
d612 1
a612 1
	GET_BITV( rtip, solidbits, ap->a_resource );
d677 1
a677 1
			l_nshots++;
d680 1
a680 1
				l_nmiss++;
d683 1
a683 1
			l_nhits++;
d702 1
a702 1
		rtip->nmiss_model++;
d778 1
a778 1
					rtip->nmiss_solid++;
d783 1
a783 1
					rtip->nmiss_solid++;
d789 1
a789 1
			l_nshots++;
d793 1
a793 1
				l_nmiss++;
d808 1
a808 1
			l_nhits++;
d871 2
a872 2
		RT_FREE_PT_LIST( &InitialPart, ap->a_resource );
		RT_FREE_SEG_LIST( &finished_segs, ap->a_resource );
d896 1
a896 1
	RT_FREE_PT_LIST( &InitialPart, ap->a_resource );
d901 2
a902 2
	RT_FREE_SEG_LIST( &finished_segs, ap->a_resource );
	RT_FREE_PT_LIST( &FinalPart, ap->a_resource );
d910 1
a910 1
		FREE_BITV( solidbits, ap->a_resource );
d914 1
a914 2
	 *  Record essential statistics in a critical section.
	 *  rti_nrays provides the RTFM, so it must be accurate.
d916 1
a916 6
	RES_ACQUIRE( &rt_g.res_stats );
	rtip->rti_nrays++;
	rtip->nshots += l_nshots;
	rtip->nmiss += l_nmiss;
	rtip->nhits += l_nhits;
	RES_RELEASE( &rt_g.res_stats );
d925 1
a925 1
			ap->a_resource->re_cpu,
d1270 40
@


9.36
log
@#if'd out some debugging traces
@
text
@d34 1
a34 1
static char RCSshoot[] = "@@(#)$Header: /n/wolf/m/cad/librt/RCS/shoot.c,v 9.35 91/07/25 01:48:19 mike Exp $ (BRL)";
d893 3
a895 3
	 *  Before recursing, release storage for unused Initial partitions
	 *  and segments.  Otherwise, this can amount to a source of
	 *  persistent memory growth.
a897 1
	RT_FREE_SEG_LIST( &finished_segs, ap->a_resource );
d902 1
@


9.35
log
@Added rt_pr_library_version
@
text
@d34 1
a34 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 9.34 91/07/24 22:59:52 mike Exp $ (BRL)";
d447 1
d454 1
d466 1
d468 1
d481 1
d483 1
d494 1
d498 1
@


9.34
log
@Added reference to rt_version string
@
text
@d34 1
a34 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 9.33 91/07/23 15:45:16 mike Exp $ (BRL)";
d1258 11
@


9.33
log
@Updated copyright date
@
text
@d34 1
a34 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 9.32 91/06/29 21:40:31 mike Exp $ (BRL)";
d38 2
@


9.32
log
@ANSI lint
@
text
@d30 1
a30 1
 *	This software is Copyright (C) 1985 by the United States Army.
d34 1
a34 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 9.31 91/06/23 02:21:13 mike Exp $ (BRL)";
d37 1
a37 1
char rt_CopyRight_Notice[] = "@@(#) Copyright (C) 1985 by the United States Army";
@


9.31
log
@By using more CONST's, rt_in_rpp should go even faster.
@
text
@d34 1
a34 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 9.30 91/06/23 02:16:08 mike Exp $ (BRL)";
d100 1
a100 1
	union cutter		*lastcut;
d118 1
a118 1
union cutter *
d349 1
a349 1
union cutter *
d563 1
a563 1
	register union cutter	*cutp;
d663 1
a663 1
			register CONST struct soltab *stp = *stpp;
d754 1
a754 1
			register CONST struct soltab *stp = *stpp;
@


9.30
log
@Minor efficiency
@
text
@d34 1
a34 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 9.29 91/06/23 00:14:21 mike Exp $ (BRL)";
d963 1
a963 1
	register fastf_t	*pt = &rp->r_pt[0];
d972 1
a972 1
	if( rp->r_dir[X] < 0.0 )  {
d979 1
a979 1
	}  else if( rp->r_dir[X] > 0.0 )  {
d998 1
a998 1
	if( rp->r_dir[Y] < 0.0 )  {
d1003 1
a1003 1
	}  else if( rp->r_dir[Y] > 0.0 )  {
d1015 1
a1015 1
	if( rp->r_dir[Z] < 0.0 )  {
d1020 1
a1020 1
	}  else if( rp->r_dir[Z] > 0.0 )  {
@


9.29
log
@Moved ssp->newray.r_pt into register variables, for efficiency.
Moved some macros to raytrace.h
@
text
@d34 1
a34 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 9.28 91/06/22 22:30:49 mike Exp $ (BRL)";
d663 1
a663 2
			register struct soltab *stp;
			register struct seg *newseg;
a664 1
			stp = *stpp;
d754 1
a754 2
			register struct soltab *stp;
			register struct seg *newseg;
d756 1
a756 1
			stp = *stpp;
a757 2
				if(debug_shoot)rt_log("eff skip %s\n", stp->st_name);
				rtip->nmiss_tree++;
@


9.28
log
@Tolerance can be had from ap->a_rt_i->rti_tol, so it is no longer
passed as a parameter on ft_prep, ft_shot, or ft_vshot.
ft_vshot calling sequence also changed to use application structure.
@
text
@d34 1
a34 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 9.27 91/06/22 06:06:09 mike Exp $ (BRL)";
a53 11
/* compare two bounding RPPs;  return true if disjoint */
#define RT_2RPP_DISJOINT(_l1, _h1, _l2, _h2) \
      ( (_l1)[0] > (_h2)[0] || (_l1)[1] > (_h2)[1] || (_l1)[2] > (_h2)[2] || \
	(_l2)[0] > (_h1)[0] || (_l2)[1] > (_h1)[1] || (_l2)[2] > (_h1)[2] )

/* Test for point being inside or on an RPP */
#define RT_POINT_IN_RPP(_pt, _min, _max)	\
	( ( (_pt)[X] >= (_min)[X] && (_pt)[X] <= (_max)[X] ) &&  \
	  ( (_pt)[Y] >= (_min)[Y] && (_pt)[Y] <= (_max)[Y] ) &&  \
	  ( (_pt)[Z] >= (_min)[Z] && (_pt)[Z] <= (_max)[Z] ) )

d116 1
d347 1
d353 1
a353 1
	register union cutter	*cutp;
d358 1
a358 1
	register fastf_t	*pt = ssp->newray.r_pt;
d384 4
a387 2
		VJOIN1( pt, ap->a_ray.r_pt,
			ssp->dist_corr, ap->a_ray.r_dir );
d390 1
a390 1
				ssp->dist_corr, V3ARGS( pt ) );
d395 22
a416 4
			if( pt[cutp->cn.cn_axis] >= cutp->cn.cn_point )  {
				cutp=cutp->cn.cn_r;
			}  else  {
				cutp=cutp->cn.cn_l;
d424 3
a426 1
		if( ! RT_POINT_IN_RPP( pt, cutp->bn.bn_min, cutp->bn.bn_max ) )  {
d429 1
a429 1
		    	rt_log(" newray.r_pt (%.20e,%.20e,%.20e)\n", V3ARGS(pt) );
d432 1
a432 1
		    	VPRINT(" newray.r_pt", pt);
d453 1
a453 1
		     	VPRINT("Point", pt);
d491 4
@


9.27
log
@If not forcing register, leave AUTO as /**/;  let compiler decide.
@
text
@d34 1
a34 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 9.26 91/06/22 06:04:19 mike Exp $ (BRL)";
d655 1
a655 2
			    stp, &ap->a_ray, ap, &waiting_segs,
			    &rtip->rti_tol ) <= 0 )  {
d771 1
a771 2
			    stp, &ss.newray, ap, &new_segs,
			    &rtip->rti_tol ) <= 0 )  {
d1216 2
a1217 2
/*void*/
rt_vstub( stp, rp, segp, n, ap, tol )
d1222 1
a1222 2
struct application        *ap; /* pointer to an application */
CONST struct rt_tol	*tol;
d1234 1
a1234 1
			if( rt_functab[stp[i]->st_id].ft_shot(stp[i], rp[i], ap, &seghead, tol) <= 0 )  {
@


9.26
log
@One more CONST pointer.  Efficiency!
@
text
@d34 1
a34 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 9.25 91/06/22 06:01:09 mike Exp $ (BRL)";
d51 1
a51 1
#define AUTO auto
@


9.25
log
@Efficiency modification to rt_in_rpp.  It should be especially
valuable on machines with several extra double precision registers.
Also, made overall statistics gathering (nrays, nshots, nhits, nmiss)
all reliable, via a semaphored critical section.
@
text
@d34 1
a34 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 9.24 91/06/22 05:23:21 mike Exp $ (BRL)";
d132 1
a132 1
	register union cutter	*cutp;
@


9.24
log
@Added CONSTs.
Collapsed "box push" error recovery into one set of code by using
a goto.  This has important implications for cache thrashing.
The point is now *always* tested against the RPP of the current cell.
@
text
@d34 1
a34 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 9.22 91/06/04 22:59:27 mike Exp $ (BRL)";
d549 4
a552 1
	int			debug_shoot = rt_g.debug & DEBUG_SHOOT;
a574 5
	/* Since this count provides the RTFM, it must be semaphored */
	RES_ACQUIRE( &rt_g.res_stats );
	rtip->rti_nrays++;
	RES_RELEASE( &rt_g.res_stats );

d653 1
a653 1
			rtip->nshots++;
d656 2
a657 2
			    &ap->a_rt_i->rti_tol ) <= 0 )  {
				rtip->nmiss++;
d660 1
a660 1
			rtip->nhits++;
d726 1
a726 4
	for(;;)  {
		if( (cutp = rt_advance_to_next_cell( &ss )) == CUTTER_NULL )
			break;

d769 1
a769 1
			rtip->nshots++;
d773 2
a774 2
			    &ap->a_rt_i->rti_tol ) <= 0 )  {
				rtip->nmiss++;
d789 1
a789 1
			rtip->nhits++;
d886 1
a886 1
	 * Processing of this ray is complete.  Free dynamic resources.
d889 1
d893 13
d948 1
a948 1
register struct xray *rp;
d953 2
a954 2
	register fastf_t *pt = &rp->r_pt[0];
	FAST fastf_t sv;
d956 2
a959 2
	rp->r_min = -INFINITY;
	rp->r_max = INFINITY;
d965 4
a968 4
		if(rp->r_max > (sv = (*min - *pt) * *invdir) )
			rp->r_max = sv;
		if( rp->r_min < (st = (*max - *pt) * *invdir) )
			rp->r_min = st;
d972 4
a975 4
		if(rp->r_max > (st = (*max - *pt) * *invdir) )
			rp->r_max = st;
		if( rp->r_min < ((sv = (*min - *pt) * *invdir)) )
			rp->r_min = sv;
d989 4
a992 4
		if(rp->r_max > (sv = (*min - *pt) * *invdir) )
			rp->r_max = sv;
		if( rp->r_min < (st = (*max - *pt) * *invdir) )
			rp->r_min = st;
d994 4
a997 4
		if(rp->r_max > (st = (*max - *pt) * *invdir) )
			rp->r_max = st;
		if( rp->r_min < ((sv = (*min - *pt) * *invdir)) )
			rp->r_min = sv;
d1006 4
a1009 4
		if(rp->r_max > (sv = (*min - *pt) * *invdir) )
			rp->r_max = sv;
		if( rp->r_min < (st = (*max - *pt) * *invdir) )
			rp->r_min = st;
d1011 4
a1014 4
		if(rp->r_max > (st = (*max - *pt) * *invdir) )
			rp->r_max = st;
		if( rp->r_min < ((sv = (*min - *pt) * *invdir)) )
			rp->r_min = sv;
d1021 1
a1021 1
	if( rp->r_min > rp->r_max )
d1023 4
@


9.23
log
@Fixed problem noted in revision 9.17.
Need to advance into cell slightly, even on first cell along ray.
@
text
@d136 1
a136 1
	register struct application *ap = ssp->ap;
d366 1
a366 1
	register struct application *ap = ssp->ap;
d371 17
a387 3
		 * Move newray point (not box_start)
		 * slightly into the new box.
		 * Note that a box is never less than 1mm wide per axis.
d390 1
d396 2
a397 4
			rt_log("rt_advance_to_next_cell() dist_corr=%g\n",
				ssp->dist_corr );
			rt_log("rt_advance_to_next_cell() newray.r_pt=(%g, %g, %g)\n",
				V3ARGS( pt ) );
d413 7
a419 4
		if( (rt_g.debug & DEBUG_ADVANCE) &&
		    ! RT_POINT_IN_RPP( pt,
		    cutp->bn.bn_min, cutp->bn.bn_max ) )  {
		    	VPRINT( "newray.r_pt", pt );
d421 6
a426 1
			rt_bomb("rt_advance_to_next_cell(): point not in cell\n");
d431 7
d439 4
a442 3
			if( rt_g.debug & DEBUG_ADVANCE )  {
#else
			{
a443 11
				rt_log("%d,%d box push dist_corr o=%e n=%e model_end=%e\n",
					ap->a_x, ap->a_y,
					ssp->odist_corr, ssp->dist_corr, ssp->model_end );
				rt_log("box_start o=%e n=%e, box_end o=%e n=%e\n",
					ssp->obox_start, ssp->box_start,
					ssp->obox_end, ssp->box_end );
				VPRINT("a_ray.r_pt", ap->a_ray.r_pt);
			     	VPRINT("Point", pt);
				VPRINT("Dir", ssp->newray.r_dir);
			     	rt_pr_cut( cutp, 0 );
			}
d449 1
d462 1
d473 1
a473 1
			rt_log("%d,%d Escaped %d. dist_corr=%e, box_start=%e, box_end=%e\n",
d481 1
a481 2
			rt_log("\nrt_advance_to_next_cell():  MISSED BOX\n");
			rt_log("rmin,rmax(%g,%g) box(%g,%g)\n",
d484 1
a484 29
/**		     	if( rt_g.debug & DEBUG_ADVANCE )  ***/
			{
				VPRINT("a_ray.r_pt", ap->a_ray.r_pt);
			     	VPRINT("Point", pt);
				VPRINT("Dir", ssp->newray.r_dir);
				VPRINT("inv_dir", ssp->inv_dir);
			     	rt_pr_cut( cutp, 0 );
				(void)rt_DB_rpp(&ssp->newray, ssp->inv_dir,
				     cutp->bn.bn_min, cutp->bn.bn_max);
		     	}
		     	if( ssp->box_end >= INFINITY )
				break;	/* off end of model RPP */
			ssp->box_start = ssp->box_end;

			/* Advance 1mm, or smallest value that hardware
			 * floating point resolution will allow.
			 */
			fraction = frexp( ssp->box_end, &exponent );
			if( exponent <= 0 )  {
				/* Never advance less than 1mm */
				ssp->box_end += 1.0;
			} else {
				if( sizeof(fastf_t) <= 4 )
					fraction += 1.0e-5;
				else
					fraction += 1.0e-14;
				ssp->box_end = ldexp( fraction, exponent );
			}
		     	continue;
d940 3
a942 3
register fastf_t *invdir;	/* inverses of rp->r_dir[] */
register fastf_t *min;
register fastf_t *max;
d1080 3
a1082 3
register fastf_t *invdir;	/* inverses of rp->r_dir[] */
register fastf_t *min;
register fastf_t *max;
d1084 1
a1084 1
	register fastf_t *pt = &rp->r_pt[0];
@


9.22
log
@Moved tolerance info into struct rt_i (rti_tol).
It is now invented in rt_dirbuild(), rather than in rt_shootray().
@
text
@d34 1
a34 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 9.21 91/05/18 03:03:39 mike Exp $ (BRL)";
d723 1
a723 1
	ss.box_start -= OFFSET_DIST;	/* Compensate for OFFSET_DIST in rt_advance_to_next_cell on 1st loop */
@


9.21
log
@Converted to new tolerance interface
@
text
@d34 1
a34 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 9.20 91/05/16 23:11:21 mike Exp $ (BRL)";
a558 1
	struct rt_tol		tol;
a580 7
	/* XXX These need to be improved */
	tol.magic = RT_TOL_MAGIC;
	tol.dist = 0.005;
	tol.dist_sq = tol.dist * tol.dist;
	tol.perp = 1e-6;
	tol.para = 1 - tol.perp;

d666 2
a667 1
			    stp, &ap->a_ray, ap, &waiting_segs, &tol ) <= 0 )  {
d786 2
a787 1
			    stp, &ss.newray, ap, &new_segs, &tol ) <= 0 )  {
@


9.20
log
@Changed to store return code in a_return as well.
@
text
@d34 1
a34 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 9.19 91/03/15 23:13:47 mike Exp $ (BRL)";
d559 1
d582 7
d674 1
a674 1
			    stp, &ap->a_ray, ap, &waiting_segs ) <= 0 )  {
d793 1
a793 1
			    stp, &ss.newray, ap, &new_segs ) <= 0 )  {
d1221 1
a1221 1
rt_vstub( stp, rp, segp, n, ap)
d1227 1
d1239 1
a1239 1
			if( rt_functab[stp[i]->st_id].ft_shot(stp[i], rp[i], ap, &seghead) <= 0 )  {
@


9.19
log
@Robert Rabiner pointed out that the rti_nrays variable was not
reliable when using multiple processors.
@
text
@d34 1
a34 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 9.18 91/03/13 20:59:21 mike Exp $ (BRL)";
a547 1
	AUTO int		ret;
d690 1
a690 1
		ret = ap->a_miss( ap );
d848 1
a848 1
		ret = ap->a_miss( ap );
d862 1
a862 1
		ret = ap->a_miss( ap );
d892 1
a892 1
	ret = ap->a_hit( ap, &FinalPart );
d914 1
a914 1
			status, ret);
d916 1
a916 1
	return( ret );
@


9.18
log
@Minor optimization
@
text
@d34 1
a34 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 9.17 91/01/25 16:05:29 mike Exp $ (BRL)";
d582 2
d585 2
@


9.17
log
@Improved debugging.
Note that there is something sour with the non-NUgrid stuff that
shows up on the ordinary moss benchmark (needs DEBUG_ADVANCE to see it).
@
text
@d34 1
a34 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 9.16 90/12/26 20:34:42 mike Exp $ (BRL)";
d130 1
a130 1
struct shootray_status	*ssp;
d133 1
a133 1
	AUTO int		push_flag = 0;
d360 1
a360 1
struct shootray_status	*ssp;
d363 1
a363 1
	AUTO int		push_flag = 0;
d367 1
d378 1
a378 1
		VJOIN1( ssp->newray.r_pt, ap->a_ray.r_pt,
d384 1
a384 1
				V3ARGS( ssp->newray.r_pt ) );
d389 1
a389 2
			if( ssp->newray.r_pt[cutp->cn.cn_axis] >=
			    cutp->cn.cn_point )  {
d401 1
a401 1
		    ! RT_POINT_IN_RPP( ssp->newray.r_pt,
d403 1
a403 1
		    	VPRINT( "newray.r_pt", ssp->newray.r_pt );
d410 1
d412 3
d422 1
a422 1
			     	VPRINT("Point", ssp->newray.r_pt);
d468 1
a468 1
			     	VPRINT("Point", ssp->newray.r_pt);
@


9.16
log
@This version of rt_in_rpp returns a "hit" even if the intersect
is behind the start point.
@
text
@d34 1
a34 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 9.15 90/12/26 20:21:41 mike Exp $ (BRL)";
d400 2
a401 1
		if( rt_g.debug && ! RT_POINT_IN_RPP( ssp->newray.r_pt,
d403 1
@


9.15
log
@An odd property of rt_in_rpp() is documented:
If the ray enters the RPP *behind* the start point, a "miss" is returned.
In general, this is not a good idea!
@
text
@d34 1
a34 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 9.14 90/12/22 02:25:43 mike Exp $ (BRL)";
d925 2
a926 3
 * Important note -
 *  This version is optimized to return a "miss" if the ray enters the
 *  RPP *behind* the start point.  In general this is not a good idea.
d954 1
a954 3
		if( (sv = (*min - *pt) * *invdir) < 0.0 )
			return(0);	/* MISS */
		if(rp->r_max > sv)
d961 1
a961 3
		if( (st = (*max - *pt) * *invdir) < 0.0 )
			return(0);	/* MISS */
		if(rp->r_max > st)
d978 1
a978 3
		if( (sv = (*min - *pt) * *invdir) < 0.0 )
			return(0);	/* MISS */
		if(rp->r_max > sv)
d983 1
a983 3
		if( (st = (*max - *pt) * *invdir) < 0.0 )
			return(0);	/* MISS */
		if(rp->r_max > st)
d995 1
a995 3
		if( (sv = (*min - *pt) * *invdir) < 0.0 )
			return(0);	/* MISS */
		if(rp->r_max > sv)
d1000 1
a1000 3
		if( (st = (*max - *pt) * *invdir) < 0.0 )
			return(0);	/* MISS */
		if(rp->r_max > st)
a1098 2
		if( sv < 0.0 )
			goto miss;
a1110 2
		if( st < 0.0 )
			goto miss;
a1134 2
		if( sv < 0.0 )
			goto miss;
a1146 2
		if( st < 0.0 )
			goto miss;
a1165 2
		if( sv < 0.0 )
			goto miss;
a1177 2
		if( st < 0.0 )
			goto miss;
@


9.14
log
@Additional work on the NUgrid.
This version does not work properly (if you #define NUgrid),
but is OK as checked in.
Contains abs_inv_dir[] calcuations,
removed bad call to rt_pr_seg().
@
text
@d34 1
a34 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 9.13 90/12/19 06:21:08 mike Exp $ (BRL)";
d925 4
d1102 4
a1106 1
rt_log("r_dir[X] = %g\n", rp->r_dir[X]);
a1146 1
rt_log("r_dir[Y] = %g\n", rp->r_dir[Y]);
a1181 1
rt_log("r_dir[Z] = %g\n", rp->r_dir[Z]);
@


9.13
log
@Has beginnings of NUgrid algorithm.
For now, enabled only by #define.
@
text
@d34 1
a34 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 9.12 90/10/07 21:35:05 mike Exp $ (BRL)";
d54 11
d68 1
d70 3
a72 2
	fastf_t	nu_pos;		/* cell start pos */
	fastf_t	nu_width;	/* voxel size */
d77 17
d104 1
d107 1
d113 7
d123 1
d138 6
a144 17
		/*
		 * Move newray point (not box_start)
		 * slightly into the new box.
		 * Note that a box is never less than 1mm wide per axis.
		 */
		ssp->dist_corr = ssp->box_start + OFFSET_DIST;
		if( ssp->dist_corr >= ssp->model_end )
			break;	/* done! */
		VJOIN1( ssp->newray.r_pt, ap->a_ray.r_pt,
			ssp->dist_corr, ap->a_ray.r_dir );
		if( rt_g.debug&DEBUG_ADVANCE) {
			rt_log("rt_advance_to_next_cell() dist_corr=%g\n",
				ssp->dist_corr);
		}

#if NUgrid
# if 0
a145 3
# else
		if(1) {
# endif
d148 1
a148 1
			 *  For now, linear search to find x,y,z index.
d150 2
d154 2
d157 11
a167 1
			if( ssp->newray.r_pt[X] < nu_axis[X][0].nu_pos )
d170 1
a170 2
				if( ssp->newray.r_pt[X] < nu_axis[X][x].nu_pos +
					nu_axis[X][x].nu_width )
d175 1
a175 1
			if( ssp->newray.r_pt[Y] < nu_axis[Y][0].nu_pos )
d178 1
a178 2
				if( ssp->newray.r_pt[Y] < nu_axis[Y][y].nu_pos +
					nu_axis[Y][y].nu_width )
d183 1
a183 1
			if( ssp->newray.r_pt[Z] < nu_axis[Z][0].nu_pos )
d186 1
a186 2
				if( ssp->newray.r_pt[Z] < nu_axis[Z][z].nu_pos +
					nu_axis[Z][z].nu_width )
d191 73
d266 14
a279 2
			/* Finds new ray segment end distance, for free */
			rt_bomb("NUgrid advance\n");
d281 72
d354 32
d395 1
a395 1
#endif
d399 7
d495 2
a496 5
			rt_log("rt_advance_to_next_cell() box=(%g, %g) new pt=(%g,%g,%g)\n",
				ssp->box_start, ssp->box_end,
	     			ssp->newray.r_pt[X],
	     			ssp->newray.r_pt[Y],
	     			ssp->newray.r_pt[Z] );
d506 1
d611 4
a614 2
	if( !NEAR_ZERO( ap->a_ray.r_dir[X], SQRT_SMALL_FASTF ) )  {
		ss.inv_dir[X]=1.0/ap->a_ray.r_dir[X];
a615 1
		ss.inv_dir[X] = INFINITY;
d617 1
d619 4
a622 2
	if( !NEAR_ZERO( ap->a_ray.r_dir[Y], SQRT_SMALL_FASTF ) )  {
		ss.inv_dir[Y]=1.0/ap->a_ray.r_dir[Y];
a623 1
		ss.inv_dir[Y] = INFINITY;
d625 1
d627 4
a630 2
	if( !NEAR_ZERO( ap->a_ray.r_dir[Z], SQRT_SMALL_FASTF ) )  {
		ss.inv_dir[Z]=1.0/ap->a_ray.r_dir[Z];
a631 1
		ss.inv_dir[Z] = INFINITY;
d633 1
a635 1
#if !NUgrid
a660 1
			if(debug_shoot)  rt_pr_seg(&waiting_segs);
a663 1
#endif
d671 4
d708 3
a710 1
	ss.box_start = ap->a_ray.r_min;
d714 1
a714 1
	ss.box_end = ss.model_end = ap->a_ray.r_max;
@


9.12
log
@Needed to account for the fact that seg structs are now structures,
not structure pointers.  On CRAY, local definition AUTO puts things
into registers, and that isn't appropriate for structures placed
into registers.
@
text
@d1 1
d34 1
a34 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 9.11 90/10/07 19:05:47 mike Exp $ (BRL)";
d37 1
a37 1
char CopyRight_Notice[] = "@@(#) Copyright (C) 1985 by the United States Army";
d54 12
d114 46
d169 1
d196 3
d205 4
d222 2
a223 1
rt_log("\nrt_advance_to_next_cell():  missed box: rmin,rmax(%g,%g) box(%g,%g)\n",
d399 1
d429 1
d473 1
a473 1
	ss.box_start -= OFFSET_DIST;	/* Compensate for OFFSET_DIST below on 1st loop */
d493 6
@


9.11
log
@Oops, got sense of test wrong for infinite solids.
@
text
@d33 1
a33 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 9.10 90/10/06 02:05:42 mike Exp $ (BRL)";
d47 1
a47 1
#ifdef cray
d239 4
a242 4
	AUTO struct shootray_status ss;
	AUTO struct seg		new_segs;	/* from solid intersections */
	AUTO struct seg		waiting_segs;	/* awaiting rt_boolweave() */
	AUTO struct seg		finished_segs;	/* processed by rt_boolweave() */
@


9.10
log
@Converted seg structures to use doubly linked lists.
@
text
@d33 1
a33 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 9.9 90/10/05 19:56:11 mike Exp $ (BRL)";
d367 1
a367 1
	    	if( RT_LIST_IS_EMPTY( &waiting_segs.l ) )  {
@


9.9
log
@Split out rt_advance_to_next_cell().
@
text
@d7 1
a7 1
 *  (building the HeadSeg chain), and then call rt_boolregions()
d33 1
a33 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 9.8 90/01/11 06:45:43 mike Exp $ (BRL)";
d240 3
a242 1
	AUTO struct seg		*HeadSeg;
a249 1
	AUTO struct seg		*waitsegs;	/* segs awaiting rt_boolweave() */
d284 3
a286 2
	HeadSeg = SEG_NULL;
	waitsegs = SEG_NULL;
d351 2
a352 3
			if( (newseg = rt_functab[stp->st_id].ft_shot( 
				stp, &ap->a_ray, ap )
			     ) == SEG_NULL )  {
d356 1
a356 9
			if(debug_shoot)  rt_pr_seg(newseg);
			/* Add seg chain to list awaiting rt_boolweave() */
			{
				register struct seg *seg2 = newseg;
				while( seg2->seg_next != SEG_NULL )
					seg2 = seg2->seg_next;
				seg2->seg_next = waitsegs;
				waitsegs = newseg;
			}
d367 1
a367 1
	    	if( waitsegs != SEG_NULL )  {
d458 3
a460 3
			if( (newseg = rt_functab[stp->st_id].ft_shot( 
				stp, &ss.newray, ap )
			     ) == SEG_NULL )  {
d467 3
a469 2
				register struct seg *seg2 = newseg;
				for(;;)  {
d471 3
a473 5
					seg2->seg_in.hit_dist += ss.dist_corr;
					seg2->seg_out.hit_dist += ss.dist_corr;
					if( seg2->seg_next == SEG_NULL )
						break;
					seg2 = seg2->seg_next;
a474 3
				if(debug_shoot)  rt_pr_seg(newseg);
				seg2->seg_next = waitsegs;
				waitsegs = newseg;
d493 1
a493 1
		if( ap->a_onehit > 0 && waitsegs != SEG_NULL )  {
d497 1
a497 1
			rt_boolweave( waitsegs, &InitialPart, ap );
a498 10
			/* Add segment chain to list of used segments */
			{
				register struct seg *seg2 = waitsegs;
				while( seg2->seg_next != SEG_NULL )
					seg2 = seg2->seg_next;
				seg2->seg_next = HeadSeg;
				HeadSeg = waitsegs;
				waitsegs = SEG_NULL;
			}

d517 2
a518 11
	if( waitsegs != SEG_NULL )  {
		register struct seg *seg2 = waitsegs;

		rt_boolweave( waitsegs, &InitialPart, ap );

		/* Add segment chain to list of used segments */
		while( seg2->seg_next != SEG_NULL )
			seg2 = seg2->seg_next;
		seg2->seg_next = HeadSeg;
		HeadSeg = waitsegs;
		waitsegs = SEG_NULL;
d521 2
a522 2
	/* HeadSeg chain now has all segments hit by this ray */
	if( HeadSeg == SEG_NULL )  {
d540 1
a540 1
		RT_FREE_SEG_LIST( HeadSeg, ap->a_resource );
d565 1
a565 1
	RT_FREE_SEG_LIST( HeadSeg, ap->a_resource );
d917 1
d919 2
d924 2
a925 6
			/* do scalar call */
			tmp_seg =
			    rt_functab[stp[i]->st_id].ft_shot(stp[i], rp[i], ap);

			/* place results in segp array */
			if ( tmp_seg == 0) {
d927 3
a929 2
			}
			else {
d931 1
a931 1
				FREE_SEG(tmp_seg, ap->a_resource);
@


9.8
log
@Simplified two parts into registers.
Eliminated check for st_id in center of inner loop.
@
text
@d4 8
a11 1
 * Ray Tracing program shot coordinator.
d13 7
d33 1
a33 1
static char RCSshoot[] = "@@(#)$Header: shoot.c,v 9.7 90/01/06 04:51:53 mike Locked $ (BRL)";
d53 18
d72 138
a210 7
 *  
 *  Given a ray, shoot it at all the relevant parts of the model,
 *  (building the HeadSeg chain), and then call rt_boolregions()
 *  to build and evaluate the partition chain.
 *  If the ray actually hit anything, call the application's
 *  a_hit() routine with a pointer to the partition chain,
 *  otherwise, call the application's a_miss() routine.
d212 1
a212 8
 *  It is important to note that rays extend infinitely only in the
 *  positive direction.  The ray is composed of all points P, where
 *
 *	P = r_pt + K * r_dir
 *
 *  for K ranging from 0 to +infinity.  There is no looking backwards.
 *
 *  It is also important to note that the direction vector r_dir
d227 1
a227 1
 *  Returns: whatever the application function returns (an int).
d239 1
a241 2
	auto vect_t		inv_dir;	/* inverses of ap->a_ray.r_dir */
	AUTO fastf_t		box_start, box_end, model_end;
a245 1
	AUTO union cutter	*lastcut;
a249 2
	auto struct xray	newray;		/* closer ray start */
	AUTO fastf_t		dist_corr;	/* correction distance */
a250 4
	AUTO fastf_t		odist_corr, obox_start, obox_end;	/* temp */
	AUTO int		push_flag = 0;
	double			fraction;
	int			exponent;
d262 1
d311 1
a311 1
		inv_dir[X]=1.0/ap->a_ray.r_dir[X];
d313 1
a313 1
		inv_dir[X] = INFINITY;
d317 1
a317 1
		inv_dir[Y]=1.0/ap->a_ray.r_dir[Y];
d319 1
a319 1
		inv_dir[Y] = INFINITY;
d323 1
a323 1
		inv_dir[Z]=1.0/ap->a_ray.r_dir[Z];
d325 1
a325 1
		inv_dir[Z] = INFINITY;
d372 1
a372 1
	if( !rt_in_rpp( &ap->a_ray, inv_dir, rtip->mdl_min, rtip->mdl_max )  ||
d376 1
a376 1
	    		model_end = INFINITY;
d407 6
a412 8
#define BACKING_DIST	(-2.0)		/* mm to look behind start point */
#define OFFSET_DIST	0.01		/* mm to advance point into box */
	box_start = ap->a_ray.r_min;
	if( box_start < BACKING_DIST )
		box_start = BACKING_DIST; /* Only look a little bit behind */
	box_start -= OFFSET_DIST;	/* Compensate for OFFSET_DIST below on 1st loop */
	box_end = model_end = ap->a_ray.r_max;
	lastcut = CUTTER_NULL;
d414 2
a415 2
	newray = ap->a_ray;		/* struct copy */
	odist_corr = obox_start = obox_end = -99;
d425 2
a426 14
		/*
		 * Move newray point (not box_start)
		 * slightly into the new box.
		 * Note that a box is never less than 1mm wide per axis.
		 */
		dist_corr = box_start + OFFSET_DIST;
		if( dist_corr >= model_end )
			break;	/* done! */
		VJOIN1( newray.r_pt, ap->a_ray.r_pt,
			dist_corr, ap->a_ray.r_dir );
		if( rt_g.debug&DEBUG_BOXING) {
			rt_log("dist_corr=%g\n", dist_corr);
			VPRINT("newray.r_pt", newray.r_pt);
		}
a427 92
		cutp = &(rtip->rti_CutHead);
		while( cutp->cut_type == CUT_CUTNODE )  {
			if( newray.r_pt[cutp->cn.cn_axis] >=
			    cutp->cn.cn_point )  {
				cutp=cutp->cn.cn_r;
			}  else  {
				cutp=cutp->cn.cn_l;
			}
		}
		if(cutp==CUTTER_NULL || cutp->cut_type != CUT_BOXNODE)
			rt_bomb("leaf not boxnode");

		/* Don't get stuck within the same box for long */
		if( cutp==lastcut )  {
			if( debug_shoot )  {
				rt_log("%d,%d box push dist_corr o=%e n=%e model_end=%e\n",
					ap->a_x, ap->a_y,
					odist_corr, dist_corr, model_end );
				rt_log("box_start o=%e n=%e, box_end o=%e n=%e\n",
					obox_start, box_start,
					obox_end, box_end );
				VPRINT("a_ray.r_pt", ap->a_ray.r_pt);
			     	VPRINT("Point", newray.r_pt);
				VPRINT("Dir", newray.r_dir);
			     	rt_pr_cut( cutp, 0 );
			}

			/* Advance 1mm, or smallest value that hardware
			 * floating point resolution will allow.
			 */
			fraction = frexp( box_end, &exponent );
			if( exponent <= 0 )  {
				/* Never advance less than 1mm */
				box_start = box_end + 1.0;
			} else {
				if( sizeof(fastf_t) <= 4 )
					fraction += 1.0e-5;
				else
					fraction += 1.0e-14;
				box_start = ldexp( fraction, exponent );
			}
			push_flag++;
			continue;
		}
		if( push_flag )  {
			push_flag = 0;
			rt_log("%d,%d Escaped %d. dist_corr=%e, box_start=%e, box_end=%e\n",
				ap->a_x, ap->a_y, push_flag,
				dist_corr, box_start, box_end );
		}
		lastcut = cutp;

		if( !rt_in_rpp(&newray, inv_dir,
		     cutp->bn.bn_min, cutp->bn.bn_max) )  {
rt_log("\nrt_shootray:  missed box: rmin,rmax(%g,%g) box(%g,%g)\n",
				newray.r_min, newray.r_max,
				box_start, box_end);
/**		     	if(debug_shoot)  ***/
			{
				VPRINT("a_ray.r_pt", ap->a_ray.r_pt);
			     	VPRINT("Point", newray.r_pt);
				VPRINT("Dir", newray.r_dir);
				VPRINT("inv_dir", inv_dir);
			     	rt_pr_cut( cutp, 0 );
				(void)rt_DB_rpp(&newray, inv_dir,
				     cutp->bn.bn_min, cutp->bn.bn_max);
		     	}
		     	if( box_end >= INFINITY )  break;
			box_start = box_end;

			/* Advance 1mm, or smallest value that hardware
			 * floating point resolution will allow.
			 */
			fraction = frexp( box_end, &exponent );
			if( exponent <= 0 )  {
				/* Never advance less than 1mm */
				box_end += 1.0;
			} else {
				if( sizeof(fastf_t) <= 4 )
					fraction += 1.0e-5;
				else
					fraction += 1.0e-14;
				box_end = ldexp( fraction, exponent );
			}
		     	continue;
		}
		odist_corr = dist_corr;
		obox_start = box_start;
		obox_end = box_end;
		box_start = dist_corr + newray.r_min;
		box_end = dist_corr + newray.r_max;

a428 2
			rt_log("ray (%g, %g) %g\n", box_start, box_end, model_end);
			VPRINT("Point", newray.r_pt);
d450 1
a450 1
				if( !rt_in_rpp( &newray, inv_dir,
d456 2
a457 2
				if( dist_corr + newray.r_max < BACKING_DIST )  {
					if(debug_shoot)rt_log("rpp skip %s, dist_corr=%g, r_max=%g\n", stp->st_name, dist_corr, newray.r_max);
d466 1
a466 1
				stp, &newray, ap )
d477 2
a478 2
					seg2->seg_in.hit_dist += dist_corr;
					seg2->seg_out.hit_dist += dist_corr;
d522 2
a523 2
				last_bool_start, box_end, regionbits, ap );
			last_bool_start = box_end;
d530 1
a530 1
		box_start = box_end;
d563 1
a563 1
		rtip->rti_inf_box.bn.bn_len > 0 ? INFINITY : model_end,
@


9.7
log
@Went back to having 4 words of padding;
2 after solid bit vector, 2 more after region bit vector.
@
text
@d19 1
a19 1
static char RCSshoot[] = "@@(#)$Header: shoot.c,v 9.6 90/01/06 04:50:14 mike Locked $ (BRL)";
d104 2
d114 1
d127 3
a129 3
	ap->a_rt_i->rti_nrays++;
	if( ap->a_rt_i->needprep )
		rt_prep(ap->a_rt_i);
d137 3
a139 2
	GET_BITV( ap->a_rt_i, solidbits, ap->a_resource );	/* see rt_get_bitv() for details */
	bzero( (char *)solidbits, ap->a_rt_i->rti_bv_bytes );
d141 1
a141 1
		2+RT_BITV_BITS2WORDS(ap->a_rt_i->nsolids)];
d187 1
a187 1
	if( ap->a_rt_i->rti_inf_box.bn.bn_len > 0 )  {
d189 1
a189 1
		cutp = &(ap->a_rt_i->rti_inf_box);
a195 3
			if( stp->st_id < 0 || stp->st_id >= rt_nfunctab )
				rt_bomb("rt_shootray:  bad st_id 1");

d197 1
a197 1
			if(rt_g.debug&DEBUG_SHOOT)rt_log("shooting %s\n", stp->st_name);
d199 1
a199 1
			ap->a_rt_i->nshots++;
d203 1
a203 1
				ap->a_rt_i->nmiss++;
d206 1
a206 1
			if(rt_g.debug&DEBUG_SHOOT)  rt_pr_seg(newseg);
d215 1
a215 1
			ap->a_rt_i->nhits++;
d223 1
a223 1
	if( !rt_in_rpp( &ap->a_ray, inv_dir, ap->a_rt_i->mdl_min, ap->a_rt_i->mdl_max )  ||
d230 1
a230 1
		ap->a_rt_i->nmiss_model++;
d293 1
a293 1
		cutp = &(ap->a_rt_i->rti_CutHead);
d307 1
a307 1
			if( rt_g.debug&DEBUG_SHOOT )  {
d350 1
a350 1
/**		     	if(rt_g.debug&DEBUG_SHOOT)  ***/
d385 1
a385 1
		if(rt_g.debug&DEBUG_SHOOT) {
a397 3
			if( stp->st_id < 0 || stp->st_id >= rt_nfunctab )
				rt_bomb("rt_shootray:  bad st_id 2");

d399 2
a400 2
				if(rt_g.debug&DEBUG_SHOOT)rt_log("eff skip %s\n", stp->st_name);
				ap->a_rt_i->nmiss_tree++;
d411 2
a412 2
					if(rt_g.debug&DEBUG_SHOOT)rt_log("rpp miss %s\n", stp->st_name);
					ap->a_rt_i->nmiss_solid++;
d416 2
a417 2
					if(rt_g.debug&DEBUG_SHOOT)rt_log("rpp skip %s, dist_corr=%g, r_max=%g\n", stp->st_name, dist_corr, newray.r_max);
					ap->a_rt_i->nmiss_solid++;
d422 2
a423 2
			if(rt_g.debug&DEBUG_SHOOT)rt_log("shooting %s\n", stp->st_name);
			ap->a_rt_i->nshots++;
d427 1
a427 1
				ap->a_rt_i->nmiss++;
d442 1
a442 1
				if(rt_g.debug&DEBUG_SHOOT)  rt_pr_seg(newseg);
d446 1
a446 1
			ap->a_rt_i->nhits++;
d522 1
a522 1
		ap->a_rt_i->rti_inf_box.bn.bn_len > 0 ? INFINITY : model_end,
d528 3
a530 1
		goto freeup;
d546 1
a546 1
	if(rt_g.debug&DEBUG_SHOOT)  rt_pr_partitions(ap->a_rt_i,&FinalPart,"a_hit()");
d555 1
d559 2
a563 5
freeup:
	RT_FREE_PT_LIST( &InitialPart, ap->a_resource );
	RT_FREE_PT_LIST( &FinalPart, ap->a_resource );
	RT_FREE_SEG_LIST( HeadSeg, ap->a_resource );

@


9.6
log
@Changed to using new macros RT_FREE_{SEG|PT}_LIST macros.
@
text
@d19 1
a19 1
static char RCSshoot[] = "@@(#)$Header: shoot.c,v 9.5 90/01/06 04:17:14 mike Locked $ (BRL)";
d137 1
a137 1
		1+RT_BITV_BITS2WORDS(ap->a_rt_i->nsolids)];
@


9.5
log
@Changed to use RT_BITV_BITS2WORDS(), tweak to rt_bitv_or().
@
text
@d19 1
a19 1
static char RCSshoot[] = "@@(#)$Header: shoot.c,v 9.4 89/12/31 07:44:10 mike Locked $ (BRL)";
d553 2
a554 21
	{
		register struct partition *pp;

		for( pp = InitialPart.pt_forw; pp != &InitialPart;  )  {
			register struct partition *newpp;
			newpp = pp;
			pp = pp->pt_forw;
			FREE_PT(newpp, ap->a_resource);
		}
		InitialPart.pt_forw = InitialPart.pt_back = &InitialPart;
	}
	{
		register struct seg *segp;

		while( HeadSeg != SEG_NULL )  {
			segp = HeadSeg->seg_next;
			FREE_SEG( HeadSeg, ap->a_resource );
			HeadSeg = segp;
		}
		HeadSeg = SEG_NULL;
	}
d562 3
a564 2
	{
		register struct partition *pp;
a565 24
		/* Free up initial partition list */
		for( pp = InitialPart.pt_forw; pp != &InitialPart;  )  {
			register struct partition *newpp;
			newpp = pp;
			pp = pp->pt_forw;
			FREE_PT(newpp, ap->a_resource);
		}
		/* Free up final partition list */
		for( pp = FinalPart.pt_forw; pp != &FinalPart;  )  {
			register struct partition *newpp;
			newpp = pp;
			pp = pp->pt_forw;
			FREE_PT(newpp, ap->a_resource);
		}
	}
	{
		register struct seg *segp;

		while( HeadSeg != SEG_NULL )  {
			segp = HeadSeg->seg_next;
			FREE_SEG( HeadSeg, ap->a_resource );
			HeadSeg = segp;
		}
	}
a581 12

#if 0
	/* For now, a good sanity check XXX */
	end_free_len = rt_partition_len( &ap->a_resource->re_parthead );
	if( ap->a_level == 0 &&
	    ap->a_purpose && strcmp( ap->a_purpose, "main ray" ) == 0 &&
	    end_free_len != ap->a_resource->re_partlen ) {
		rt_log("PP free error, qlen=%d, s/b=%d (%s)\n",
			end_free_len, ap->a_resource->re_partlen,
			ap->a_purpose != (char *)0 ? ap->a_purpose : "?" );
	}
#endif
@


9.4
log
@Implemented a new meaning to a_onehit:  how many hit points
need to be accurately determined.
This provides a big performance "win" to the reflect/refract code,
which needs 3 hits, and was forced to compute the ray to +infinity,
which was *very* costly.

Alas, somehow I seem to have made things in general slow down.
The larger the model, the worse it gets.
This must be pursued further.
@
text
@d19 1
a19 1
static char RCSshoot[] = "@@(#)$Header: shoot.c,v 9.3 89/12/30 05:20:12 mike Locked $ (BRL)";
a133 1
	/* XXX WARNING this needs attention for multiple rt_i sizes */
d136 2
a137 1
	regionbits = &solidbits->be_v[2+(BITS2BYTES(ap->a_rt_i->nsolids)/sizeof(bitv_t))];
d764 1
a764 1
	words = (nbits+BITV_MASK)>>BITV_SHIFT;/*BITS2BYTES()/sizeof(bitv_t)*/
d767 2
a768 2
	for( ; words > 0; words-- )
		out[words-1] |= in[words-1];
@


9.3
log
@Moved merging st_regions[] into regionbits[] from rt_shootray(),
where it was being done once for all regions crossed by a ray,
into rt_boolfinal(), where it is now built separately for each
partition.

In models where the ray may traverse quite a few regions, this
should result in a substantial savings, mostly from less calling
of rt_booleval().
@
text
@d19 1
a19 1
static char RCSshoot[] = "@@(#)$Header: shoot.c,v 9.2 89/05/30 07:53:27 mike Locked $ (BRL)";
a89 1
	AUTO int		trybool;
d103 1
a265 1
	trybool = 0;
a275 1
RT_RESOURCE_CHECK(ap->a_resource);	/* XXX */
d349 2
a350 1
/**		     	if(rt_g.debug&DEBUG_SHOOT)  { ***/ {
a447 1
			trybool++;	/* flag to rerun bool, below */
d451 17
a467 4
		/* Special case for efficiency -- first hit only */
		/* Only run this every three hits, to balance cost/benefit */
		if( trybool>=3 && ap->a_onehit && waitsegs != SEG_NULL )  {
RT_RESOURCE_CHECK(ap->a_resource);	/* XXX */
d480 1
d482 1
a482 1
			rt_boolfinal( &InitialPart, &FinalPart,
d484 1
d486 2
a487 6
			/* If anything was found, it's a hit! */
			if( FinalPart.pt_forw != &FinalPart )
				goto hitit;

			last_bool_start = box_end;
			trybool = 0;
d523 1
a523 1
	rt_boolfinal( &InitialPart, &FinalPart, BACKING_DIST,
d548 26
a573 1
RT_RESOURCE_CHECK(ap->a_resource);	/* XXX */
d624 12
@


9.2
log
@Made uniresource print conditional on debugging.
@
text
@d19 1
a19 1
static char RCSshoot[] = "@@(#)$Header: shoot.c,v 9.1 89/05/19 05:57:05 mike Locked $ (BRL)";
a213 19
			/* Would be even better done by per-partition bitv */
			{
				register int words;
				register bitv_t *in = stp->st_regions;
				register bitv_t *out = regionbits;
				/* BITS2BYTES() / sizeof(bitv_t) */
				words = (stp->st_maxreg+BITV_MASK)>>BITV_SHIFT;
#				ifdef VECTORIZE
#					include "noalias.h"
					for( ; words > 0; words-- )
						regionbits[words-1] |= in[words-1];
#				else
					while( words-- > 0 )
						*out++ |= *in++;
#				endif
			}

			if(rt_g.debug&DEBUG_PARTITION)
				rt_pr_bitv( "shoot Regionbits", regionbits, ap->a_rt_i->nregions);
a449 20

			/* Would be even better done by per-partition bitv */
			{
				register int words;
				register bitv_t *in = stp->st_regions;
				register bitv_t *out = regionbits;
				/* BITS2BYTES() / sizeof(bitv_t) */
				words = (stp->st_maxreg+BITV_MASK)>>BITV_SHIFT;
#				ifdef VECTORIZE
#					include "noalias.h"
					for( ; words > 0; words-- )
						regionbits[words-1] |= in[words-1];
#				else
					while( words-- > 0 )
						*out++ |= *in++;
#				endif
			}

			if(rt_g.debug&DEBUG_PARTITION)
				rt_pr_bitv( "shoot Regionbits", regionbits, ap->a_rt_i->nregions);
@


9.1
log
@Release_3.5
@
text
@d19 1
a19 1
static char RCSshoot[] = "@@(#)$Header: shoot.c,v 8.4 89/05/05 01:58:12 mike Exp $ (BRL)";
d109 1
a109 1
rt_log("rt_shootray:  defaulting a_resource to &rt_uniresource\n");
@


9.1.1.1
log
@Same fix as in revision 9.19.
Robert Rabiner pointed out that rti_nrays is not semaphored,
and it used to calculate the RTFM figures.
@
text
@d19 1
a19 1
static char RCSshoot[] = "@@(#)$Header: /m/cad/librt/RCS/shoot.c,v 9.1 89/05/19 05:57:05 mike Rel3_5 $ (BRL)";
a123 2
	/* Since this count provides the RTFM, it must be semaphored */
	RES_ACQUIRE( &rt_g.res_stats );
a124 2
	RES_RELEASE( &rt_g.res_stats );

@


8.4
log
@Error checking.
@
text
@d19 1
a19 1
static char RCSshoot[] = "@@(#)$Header: shoot.c,v 8.3 89/04/13 05:21:27 mike Locked $ (BRL)";
@


8.3
log
@Added RESOURCE_MAGIC initialization
@
text
@d19 1
a19 1
static char RCSshoot[] = "@@(#)$Header: shoot.c,v 8.2 89/04/03 21:38:29 mike Locked $ (BRL)";
d790 1
@


8.2
log
@Added application struct validity checking.
@
text
@d19 1
a19 1
static char RCSshoot[] = "@@(#)$Header: shoot.c,v 8.1 88/10/05 00:31:39 mike Locked $ (BRL)";
d106 1
a106 1
	if( ap->a_resource == RESOURCE_NULL )
d108 4
d296 1
d495 1
d578 1
d939 33
@


8.1
log
@Release_3.0
@
text
@d19 1
a19 1
static char RCSshoot[] = "@@(#)$Header: shoot.c,v 7.8 88/09/17 07:45:14 mike Exp $ (BRL)";
d105 1
a105 1

@


7.8
log
@Vectorized and (manually) inlined rt_bitv_or().
@
text
@d19 1
a19 1
static char RCSshoot[] = "@@(#)$Header: shoot.c,v 7.7 88/08/20 07:01:44 mike Locked $ (BRL)";
@


7.7
log
@Added indentation code that takes advantage of rt_g.rtg_logindent
feature in rt_log().
@
text
@d19 1
a19 1
static char RCSshoot[] = "@@(#)$Header: shoot.c,v 7.6 88/08/20 00:45:45 mike Locked $ (BRL)";
d211 16
a226 1
			rt_bitv_or( regionbits, stp->st_regions, stp->st_maxreg);
d466 16
a481 2
			/* XXX do this inline? */
			rt_bitv_or( regionbits, stp->st_regions, stp->st_maxreg);
d751 5
d758 1
@


7.6
log
@mildly improved printf on exit from rt_shootray()
@
text
@d19 1
a19 1
static char RCSshoot[] = "@@(#)$Header: shoot.c,v 7.5 88/08/09 04:54:31 mike Locked $ (BRL)";
d110 2
a111 1
		rt_log("**********shootray cpu=%d  %d,%d lvl=%d (%s)\n",
d582 4
@


7.5
log
@needed to include math.h for frexp() and ldexp()!
attempted to improve the small box edge nibbling problem by reducing
the offset - this code is still unsatisfactory.
@
text
@d19 1
a19 1
static char RCSshoot[] = "@@(#)$Header: shoot.c,v 7.4 88/06/22 01:09:30 phil Locked $ (BRL)";
d580 8
a587 2
	if(rt_g.debug&(DEBUG_SHOOT|DEBUG_ALLRAYS))
		rt_log( "%s, ret%d\n", status, ret);
@


7.4
log
@Unified handling of the BACKING_DIST, which fixes the problem
with improperly detecting overlaps behind the ray start point.
@
text
@d19 1
a19 1
static char RCSshoot[] = "@@(#)$Header: shoot.c,v 7.3 88/01/23 05:21:16 mike Locked $ (BRL)";
d25 1
d257 1
a257 1
#define OFFSET_DIST	0.75		/* mm to advance point into box */
@


7.3
log
@Replaced explicit code with reference to MAGSQ macro
@
text
@d19 1
a19 1
static char RCSshoot[] = "@@(#)$Header: shoot.c,v 7.1 87/11/02 23:34:05 mike Locked $ (BRL)";
d237 3
a239 2
	 *  we only look at little bit behind to see if we are just
	 *  coming out of something, but never further back than dist 0.
d245 9
d255 2
d258 2
a259 3
	if( box_start < 0.0 )
		box_start = 0.0;
#define OFFSET_DIST	0.75		/* mm */
d263 1
a263 1
	last_bool_start = -10.0;
d407 13
a419 10
			/* If ray does not strike the bounding RPP, skip on */
			if(
			   rt_functab[stp->st_id].ft_use_rpp &&
			   ( !rt_in_rpp( &newray, inv_dir,
			      stp->st_min, stp->st_max ) ||
			      dist_corr + newray.r_max < -10.0 )
			)  {
				if(rt_g.debug&DEBUG_SHOOT)rt_log("rpp skip %s\n", stp->st_name);
				ap->a_rt_i->nmiss_solid++;
				continue;	/* MISS */
d516 1
a516 1
	rt_boolfinal( &InitialPart, &FinalPart, -10.0,
@


7.2
log
@Added extra DEBUG_SHOOT debugging print to discriminate between
efficiency culled rays, and RPP culled rays.
@
text
@d136 1
a136 3
		f = ap->a_ray.r_dir[X] * ap->a_ray.r_dir[X] +
			ap->a_ray.r_dir[Y] * ap->a_ray.r_dir[Y] +
			ap->a_ray.r_dir[Z] * ap->a_ray.r_dir[Z];
@


7.1
log
@Release 2.3
@
text
@d19 1
a19 1
static char RCSshoot[] = "@@(#)$Header: shoot.c,v 6.3 87/10/20 00:01:25 mike Exp $ (BRL)";
d390 1
a390 1
				if(rt_g.debug&DEBUG_SHOOT)rt_log("skipping %s\n", stp->st_name);
a395 1
			if(rt_g.debug&DEBUG_SHOOT)rt_log("shooting %s\n", stp->st_name);
d405 1
d410 1
@


6.3
log
@A significantly better solution to the problem of limited precision
of floating point on the SGI (doubles become floats).
Use frexp and ldexp to manipulate mantissa in known ways.
@
text
@d19 1
a19 1
static char RCSshoot[] = "@@(#)$Header: shoot.c,v 6.2 87/09/17 07:01:22 mike Exp $ (BRL)";
@


6.2
log
@Improved dist_corr handling.
@
text
@d19 1
a19 1
static char RCSshoot[] = "@@(#)$Header: shoot.c,v 6.1 87/07/11 07:56:24 mike Locked $ (BRL)";
d101 2
d104 1
d296 28
a323 12
			rt_log("%d,%d box push dist_corr o=%e n=%e model_end=%e\n",
				ap->a_x, ap->a_y,
				odist_corr, dist_corr, model_end );
			rt_log("box_start o=%e n=%e, box_end o=%e n=%e\n",
				obox_start, box_start,
				obox_end, box_end );
			VPRINT("a_ray.r_pt", ap->a_ray.r_pt);
		     	VPRINT("Point", newray.r_pt);
			VPRINT("Dir", newray.r_dir);
		     	rt_pr_cut( cutp, 0 );
			box_start = box_end + 1.0;/* Advance 1mm */
			push_flag = 1;
d328 2
a329 1
			rt_log("Finally escaped with dist_corr=%e, box_start=%e, box_end=%e\n",
d350 15
a364 1
			box_end += 1.0;		/* Advance 1mm */
@


6.1
log
@Release 2.0
@
text
@d19 1
a19 1
static char RCSshoot[] = "@@(#)$Header: shoot.c,v 5.2 87/07/08 00:59:59 mike Exp $ (BRL)";
d247 2
a248 1
	box_start -= 0.99;	/* Compensate for 0.99 below on 1st loop */
d269 1
a269 1
		dist_corr = box_start + 0.99;
a383 2
			if(rt_g.debug&DEBUG_SHOOT)  rt_pr_seg(newseg);

d395 1
d402 1
@


5.2
log
@Added support for printing a_purpose string when debugging.
@
text
@d19 1
a19 1
static char RCSshoot[] = "@@(#)$Header: shoot.c,v 5.1 87/06/24 22:12:14 mike Locked $ (BRL)";
@


5.1
log
@Release 1.24
@
text
@d19 1
a19 1
static char RCSshoot[] = "@@(#)$Header: shoot.c,v 4.5 87/04/10 13:11:18 moss Exp $ (BRL)";
d106 1
a106 1
		rt_log("**********shootray cpu=%d  %d,%d lvl=%d\n",
d109 2
a110 1
			ap->a_level );
@


4.5
log
@Fixed call to rt_pr_partitions(), was missing 1st arg.
@
text
@d19 1
a19 1
static char RCSshoot[] = "@@(#)$Header: shoot.c,v 4.4 87/03/23 23:41:32 moss Locked $ (BRL)";
@


4.4
log
@New version that supports multiframe animation,
and post-raytrace cleanups.
@
text
@d19 1
a19 1
static char RCSshoot[] = "@@(#)$Header: shoot.c,v 4.3 87/03/10 23:43:33 mike Exp $ (BRL)";
d490 1
a490 1
	if(rt_g.debug&DEBUG_SHOOT)  rt_pr_partitions(&FinalPart,"a_hit()");
@


4.3
log
@Changed 3rd arg of ft_shoot() to be application structure, for splines.
@
text
@d19 1
a19 1
static char RCSshoot[] = "@@(#)$Header: shoot.c,v 4.2 87/02/12 22:11:48 mike Locked $ (BRL)";
d123 4
a126 1
	GET_BITV( solidbits, ap->a_resource );	/* see rt_get_bitv() for details */
a127 2
	BITZERO(solidbits->be_v,ap->a_rt_i->nsolids);
	BITZERO(regionbits,ap->a_rt_i->nregions);
d184 3
d350 3
d411 1
a411 1
			rt_boolweave( waitsegs, &InitialPart, ap->a_resource );
d446 1
a446 1
		rt_boolweave( waitsegs, &InitialPart, ap->a_resource );
d678 2
a679 1
rt_get_bitv(res)
d686 1
a686 1
	size = BITS2BYTES(rt_i.nsolids) + BITS2BYTES(rt_i.nregions) + 4*sizeof(bitv_t);
@


4.2
log
@Release 1.20 -- First Formal Release
@
text
@d19 1
a19 1
static char RCSshoot[] = "@@(#)$Header: shoot.c,v 4.1 86/12/29 03:45:51 mike Rel1 $ (BRL)";
d188 1
a188 1
				stp, &ap->a_ray, ap->a_resource )
d369 1
a369 1
				stp, &newray, ap->a_resource )
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d19 1
a19 1
static char RCSshoot[] = "@@(#)$Header: shoot.c,v 3.16 86/12/26 18:39:19 mike Locked $ (BRL)";
@


3.16
log
@Added missing parameter to xxx_shot call
@
text
@d19 1
a19 1
static char RCSshoot[] = "@@(#)$Header: shoot.c,v 3.15 86/12/24 08:06:03 mike Locked $ (BRL)";
@


3.15
log
@Revised for resource structure.
@
text
@d19 1
a19 1
static char RCSshoot[] = "@@(#)$Header: shoot.c,v 3.14 86/12/13 05:42:06 mike Locked $ (BRL)";
d188 1
a188 1
				stp, &ap->a_ray )
@


3.14
log
@Improved handling of machine epsilon with some new defines.
@
text
@d19 1
a19 1
static char RCSshoot[] = "@@(#)$Header: shoot.c,v 3.13 86/11/07 00:51:59 mike Locked $ (BRL)";
d30 8
d82 19
a100 19
	auto struct seg *HeadSeg;
	auto int ret;
	auto vect_t inv_dir;		/* inverses of ap->a_ray.r_dir */
	auto fastf_t	box_start, box_end, model_end;
	auto fastf_t	last_bool_start;
	auto union bitv_elem *solidbits;/* bits for all solids shot so far */
	auto bitv_t *regionbits;	/* bits for all involved regions */
	auto int trybool;
	auto char *status;
	auto union cutter *lastcut;
	auto struct partition InitialPart; /* Head of Initial Partitions */
	auto struct partition FinalPart;	/* Head of Final Partitions */
	auto struct seg *waitsegs;	/* segs awaiting rt_boolweave() */
	auto struct soltab **stpp;
	auto struct xray newray;	/* closer ray start */
	auto fastf_t dist_corr;		/* correction distance */
	register union cutter *cutp;
	fastf_t odist_corr, obox_start, obox_end;	/* temp */
	int push_flag = 0;
d102 3
d106 4
a109 2
		rt_log("**********shootray  %d,%d lvl=%d\n",
			ap->a_x, ap->a_y, ap->a_level );
d123 1
a123 1
	GET_BITV( solidbits );	/* see rt_get_bitv() for details */
d369 1
a369 1
				stp, &newray )
d404 1
a404 1
			rt_boolweave( waitsegs, &InitialPart );
d439 1
a439 1
		rt_boolweave( waitsegs, &InitialPart );
d500 1
a500 1
			FREE_PT(newpp);
d507 1
a507 1
			FREE_PT(newpp);
d515 1
a515 1
			FREE_SEG( HeadSeg );
d521 1
a521 1
		FREE_BITV( solidbits );
d671 3
a673 1
rt_get_bitv()  {
d686 3
a688 2
		((union bitv_elem *)cp)->be_next = rt_i.FreeBitv;
		rt_i.FreeBitv = (union bitv_elem *)cp;
@


3.13
log
@Eliminated automatic computation of hit_point and hit_normal
values in rt_shootray();  user obtains these values when
needed by calling RT_HIT_NORM macro to fill in slots.
@
text
@d19 1
a19 1
static char RCSshoot[] = "@@(#)$Header: shoot.c,v 3.12 86/11/07 00:40:29 mike Locked $ (BRL)";
d135 1
a135 2
#define ZERO_COS	1.0e-20
	if( !NEAR_ZERO( ap->a_ray.r_dir[X], ZERO_COS ) )  {
d141 1
a141 1
	if( !NEAR_ZERO( ap->a_ray.r_dir[Y], ZERO_COS ) )  {
d147 1
a147 1
	if( !NEAR_ZERO( ap->a_ray.r_dir[Z], ZERO_COS ) )  {
@


3.12
log
@Converted to RT_HIT_NORM macro
@
text
@d19 1
a19 1
static char RCSshoot[] = "@@(#)$Header: shoot.c,v 3.11 86/08/12 04:16:20 mike Exp $ (BRL)";
d48 1
a48 1
 *  must have unit length;  this is mandatory, and is not checked
d57 5
d66 3
a98 1
		fflush(stderr);		/* In case of instant death */
d459 10
a468 5
	 *  A DIRECT HIT.
	 *  Last chance to compute exact hit points and surface normals.
	 *  Then hand final partitioned intersection list to the application.
	 * ---- computing normals should probably be moved into the
	 * application, to prevent wasteful computation.
a470 14
	{
		register struct partition *pp;
		for( pp=FinalPart.pt_forw; pp != &FinalPart; pp=pp->pt_forw ){
			register struct soltab *stp;

			stp = pp->pt_inseg->seg_stp;
			RT_HIT_NORM( pp->pt_inhit, stp, &(ap->a_ray) );

			if( ap->a_onehit && pp->pt_inhit->hit_dist >= 0.0 )
				break;
			stp = pp->pt_outseg->seg_stp;
			RT_HIT_NORM( pp->pt_outhit, stp, &(ap->a_ray) );
		}
	}
d499 1
a499 1
		register struct seg *segp;	/* XXX */
a512 1
	if( rt_g.debug )  fflush(stderr);
@


3.11
log
@Changed #include directives for use with CC -I convention
@
text
@d19 1
a19 1
static char RCSshoot[] = "@@(#)$Header: shoot.c,v 3.10 86/08/09 02:17:41 mike Exp $ (BRL)";
d465 1
a465 2
			rt_functab[stp->st_id].ft_norm(
				pp->pt_inhit, stp, &(ap->a_ray) );
d470 1
a470 2
			rt_functab[stp->st_id].ft_norm(
				pp->pt_outhit, stp, &(ap->a_ray) );
@


3.10
log
@Fixed problem with ray missing box so frequently.
@
text
@d19 1
a19 1
static char RCSshoot[] = "@@(#)$Header: shoot.c,v 3.9 86/07/31 03:20:30 mike Exp $ (BRL)";
d25 4
a28 4
#include "../h/machine.h"
#include "../h/vmath.h"
#include "../h/raytrace.h"
#include "debug.h"
@


3.9
log
@Prevents missing objects immediately in front of ray.
Fix for non-FLEXNAMES.
@
text
@d19 1
a19 1
static char RCSshoot[] = "@@(#)$Header: shoot.c,v 3.8 86/07/30 00:45:23 mike Exp $ (BRL)";
d208 16
a223 2
	/* Push ray starting point to edge of model RPP */
	box_start = ap->a_ray.r_min - 1.0;	/* to compensate for 0.99 below */
a224 5
	/* If we are very near the edge, step back just a little
	 * so we don't miss coming out of something.
	 */
	if( box_start <= 0.0 )
		box_start = -10.0;
d229 1
a229 1
odist_corr = obox_start = obox_end = -99;
d235 2
d291 3
a293 1
			rt_log("\nrt_shootray:  ray misses box? (%g,%g) (%g,%g) \n",newray.r_min, newray.r_max, box_start, box_end);
d298 1
d300 2
d682 136
@


3.8
log
@Version with annoying "box push failed" trouble
dramaticly reduced.  Problem was due to fuzz in
value for model_end, resulting in difficulty
realizing that we had left the last box.
@
text
@d19 1
a19 1
static char RCSshoot[] = "@@(#)$Header: shoot.c,v 3.7 86/07/29 03:11:00 mike Exp $ (BRL)";
d83 2
a84 2
fastf_t old_dist_corr, old_box_start, old_box_end;
int push_flag = 0;
d193 1
d196 1
a196 1
	    ap->a_ray.r_max <= 0.0 )  {
d209 1
a209 1
	box_start = ap->a_ray.r_min;
d211 5
a215 2
	if( box_start < -10.0 )
		box_start = -10.0;	/* don't look back far */
d220 1
a220 1
old_dist_corr = old_box_start = old_box_end = -99;
d238 4
d259 1
a259 1
				old_dist_corr, dist_corr, model_end );
d261 2
a262 2
				old_box_start, box_start,
				old_box_end, box_end );
d292 3
a294 3
		old_dist_corr = dist_corr;
		old_box_start = box_start;
		old_box_end = box_end;
@


3.7
log
@Working version with hack repaired.
@
text
@d19 1
a19 1
static char RCSshoot[] = "@@(#)$Header: shoot.c,v 3.6 86/07/29 01:49:35 mike Exp $ (BRL)";
a68 1
	auto vect_t point;
d80 2
d83 2
d128 1
a128 1
#define ZERO_COS	1.0e-10
d215 2
d223 11
a233 1
	while( box_start < model_end )  {
a234 6
		/* Move point (not box_start) slightly into the new box */
		{
			FAST fastf_t f;
			f = box_start + 0.005;
			VJOIN1( point, ap->a_ray.r_pt, f, ap->a_ray.r_dir );
		}
d237 2
a238 1
			if( point[cutp->cn.cn_axis] >= cutp->cn.cn_point )  {
d249 12
a260 4
			rt_log("%d,%d box push failed %g,%g\n",
				ap->a_x, ap->a_y, box_start, box_end);
			box_end += 1.0;		/* Advance 1mm */
			box_start = box_end;
d263 5
d270 1
a270 1
		if( !rt_in_rpp(&ap->a_ray, inv_dir,
d272 5
a276 5
			rt_log("\nrt_shootray:  ray misses box? (%g,%g) (%g,%g) \n",ap->a_ray.r_min, ap->a_ray.r_max, box_start, box_end);
		     	if(rt_g.debug&DEBUG_SHOOT)  {
				VPRINT("r_pt", ap->a_ray.r_pt);
			     	VPRINT("Point", point);
				VPRINT("Dir", ap->a_ray.r_dir);
d280 1
a281 1
			box_start = box_end;
d284 5
a288 1
		box_end = ap->a_ray.r_max;	
d292 1
a292 1
			VPRINT("Point", point);
d316 1
a316 1
			   ( !rt_in_rpp( &ap->a_ray, inv_dir,
d318 1
a318 1
			      ap->a_ray.r_max < -10.0 )
d326 1
a326 1
				stp, &ap->a_ray )
d331 1
a332 1
			trybool++;	/* flag to rerun bool, below */
d337 6
a342 1
				while( seg2->seg_next != SEG_NULL )
d344 1
d348 2
d431 2
@


3.6
log
@Some optimization by code rearrangement.
May be suspect.
@
text
@d19 1
a19 1
static char RCSshoot[] = "@@(#)$Header: shoot.c,v 3.5 86/07/24 06:20:41 mike Exp $ (BRL)";
d80 1
a81 1
	auto int hack_flag;
d83 8
d99 5
a103 1
	solidbits = BITV_NULL;		/* not allocated yet */
a104 8
	if(rt_g.debug&(DEBUG_ALLRAYS|DEBUG_SHOOT|DEBUG_PARTITION)) {
		rt_log("**********shootray  %d,%d lvl=%d\n",
			ap->a_x, ap->a_y, ap->a_level );
		VPRINT("Pnt", ap->a_ray.r_pt);
		VPRINT("Dir", ap->a_ray.r_dir);
		fflush(stderr);		/* In case of instant death */
	}

d146 43
a190 1
	hack_flag = 0;
d193 4
a196 12
	    	if( ap->a_rt_i->rti_inf_box.bn.bn_len > 0 )  {
	    		/*
	    		 *  Because there are some infinite solids in this
	    		 *  model, we need to shoot at them even outside
	    		 *  the model RPP.  Thus, this hack.
	    		 */
	    		hack_flag = 1;
	    	}  else  {
			ap->a_rt_i->nmiss_model++;
			ret = ap->a_miss( ap );
			status = "MISS model";
			goto out;
d198 4
d204 7
a210 25
top:
	if(rt_g.debug&DEBUG_SHOOT) rt_log("rt_shootray:  loop top, hack=%d\n", hack_flag);
	if( hack_flag == 0 )  {
		/* Push ray starting point to edge of model RPP */
		box_start = ap->a_ray.r_min;
		model_end = ap->a_ray.r_max;
		if( box_start < -10.0 )
			box_start = -10.0;	/* don't look back far */
		lastcut = CUTTER_NULL;
	}  else  {
		cutp = &(ap->a_rt_i->rti_inf_box);
		lastcut = cutp;
    		box_start = -100000;
		box_end = ap->a_ray.r_max = INFINITY;
    		model_end = box_end * 0.99999;
		waitsegs = SEG_NULL;
	}
	last_bool_start = box_start;

	if( solidbits == BITV_NULL )  {
		GET_BITV( solidbits );	/* see rt_get_bitv() for details */
		regionbits = &solidbits->be_v[2+(BITS2BYTES(ap->a_rt_i->nsolids)/sizeof(bitv_t))];
		BITZERO(solidbits->be_v,ap->a_rt_i->nsolids);
		BITZERO(regionbits,ap->a_rt_i->nregions);
	}
a211 1
	if( hack_flag )  goto middle;
a218 1
		struct soltab **stpp;
a219 2
		waitsegs = SEG_NULL;

d239 2
a240 1
			rt_log("%d,%d box push failed %g\n", ap->a_x, ap->a_y, box_end);
a260 1
middle:
d352 1
d357 1
d359 2
d364 5
a368 8
		{
			register struct seg *seg2 = waitsegs;
			while( seg2->seg_next != SEG_NULL )
				seg2 = seg2->seg_next;
			seg2->seg_next = HeadSeg;
			HeadSeg = waitsegs;
			waitsegs = SEG_NULL;
		}
a374 9
		if( hack_flag == 0 && ap->a_rt_i->rti_inf_box.bn.bn_len > 0 )  {
	    		/*
	    		 *  Because there are some infinite solids in this
	    		 *  model, we need to shoot at them even outside
	    		 *  the model RPP.  Thus, this hack.
	    		 */
	    		hack_flag = 1;
			goto top;
		}
d382 3
a384 1
	rt_boolfinal( &InitialPart, &FinalPart, 0.0, model_end, regionbits, ap);
a388 9
		if( hack_flag == 0 && ap->a_rt_i->rti_inf_box.bn.bn_len > 0 )  {
	    		/*
	    		 *  Because there are some infinite solids in this
	    		 *  model, we need to shoot at them even outside
	    		 *  the model RPP.  Thus, this hack.
	    		 */
	    		hack_flag = 1;
			goto top;
		}
d407 2
a408 1
			if( ap->a_onehit )  break;
@


3.5
log
@Enhanced logging print.
@
text
@d19 1
a19 1
static char RCSshoot[] = "@@(#)$Header: shoot.c,v 3.4 86/07/22 04:20:20 mike Exp $ (BRL)";
d229 10
a238 5
			VPRINT("r_pt", ap->a_ray.r_pt);
		     	VPRINT("Point", point);
			VPRINT("Dir", ap->a_ray.r_dir);
		     	rt_pr_cut( cutp, 0 );
			break;
a284 12

			/* Discard seg entirely behind start point of ray */
			while( newseg != SEG_NULL && 
				newseg->seg_out.hit_dist < -10.0 )  {
				register struct seg *seg2 = newseg->seg_next;
				FREE_SEG( newseg );
				newseg = seg2;
			}
			if( newseg == SEG_NULL )  {
				ap->a_rt_i->nmiss++;
				continue;	/* MISS */
			}
d302 4
a305 5
		/*
		 *  Weave these segments into the partition list.
		 *  Done once per box.
		 */
		if( waitsegs != SEG_NULL )  {
a316 5
		}

		/* Special case for efficiency -- first hit only */
		/* Only run this every three hits, to balance cost/benefit */
		if( trybool>=3 && ap->a_onehit )  {
d332 17
a348 1
	/* Ray has finally left known space -- do final computations */
@


3.4
log
@Minor cleanups
@
text
@d19 1
a19 1
static char RCSshoot[] = "@@(#)$Header: shoot.c,v 3.3 86/07/22 03:21:05 mike Exp $ (BRL)";
d94 3
a96 1
		VPRINT("\nPnt", ap->a_ray.r_pt);
@


3.3
log
@Slight additional error checking
@
text
@d19 1
a19 1
static char RCSshoot[] = "@@(#)$Header: shoot.c,v 3.2 86/07/19 04:42:45 mike Exp $ (BRL)";
d228 1
a228 1
			VPRINT("point", point);
d237 2
a238 2
			rt_log("ray (%f, %f) %f\n", box_start, box_end, model_end);
			VPRINT( "point", point );
d261 1
a261 2
			   stp->st_id != ID_HALF &&
			   stp->st_id != ID_ARB8 &&
@


3.2
log
@Added special support for infinite solids.
@
text
@d19 1
a19 1
static char RCSshoot[] = "@@(#)$Header: shoot.c,v 3.1 86/07/11 01:32:35 mike Exp $ (BRL)";
d67 1
a67 1
	register int ret;
d161 1
d168 1
d171 1
a184 1
	lastcut = CUTTER_NULL;
d194 1
a194 1
		struct soltab *stp;
d217 1
a217 1
			rt_log("straight box push failed %g\n", box_end);
d226 5
a230 1
			rt_log("rt_shootray:  ray misses box?\n");
a234 1
		ret = cutp->bn.bn_len;		/* loop count, below */
d243 3
a245 1
		while( --ret >= 0 )  {
d248 1
a248 1
			stp = cutp->bn.bn_list[ret];
a278 12

			/* First, some checking */
			if( newseg->seg_in.hit_dist > newseg->seg_out.hit_dist )  {
				LOCAL struct hit temp;		/* XXX */
				rt_log("ERROR %s: in/out rev (%f,%f)\n",
					newseg->seg_stp->st_name,
					newseg->seg_in.hit_dist,
					newseg->seg_out.hit_dist );
				temp = newseg->seg_in;	/* struct copy */
				newseg->seg_in = newseg->seg_out;/* struct copy */
				newseg->seg_out = temp;	/* struct copy */
			}
@


3.1
log
@Cleanups inspired by the crummy compiler on the Cray XMP
@
text
@d19 1
a19 1
static char RCSshoot[] = "@@(#)$Header: shoot.c,v 3.0 86/06/10 01:33:39 mike Exp $ (BRL)";
a28 1
#include "cut.h"
d79 3
d83 3
a85 1
	if( rt_i.needprep )  rt_prep();		/* so things will work */
d90 1
d142 2
a143 1
	if( !rt_in_rpp( &ap->a_ray, inv_dir, rt_i.mdl_min, rt_i.mdl_max )  ||
d145 13
a157 4
		rt_i.nmiss_model++;
		ret = ap->a_miss( ap );
		status = "MISS model";
		goto out;
d160 14
a173 5
	/* Push ray starting point to edge of model RPP */
	box_start = ap->a_ray.r_min;
	model_end = ap->a_ray.r_max;
	if( box_start < 0.0 )
		box_start = 0.0;	/* don't look back */
d176 6
a181 5
	GET_BITV( solidbits );	/* see rt_get_bitv() for details */
	regionbits = &solidbits->be_v[2+(BITS2BYTES(rt_i.nsolids)/sizeof(bitv_t))];
	BITZERO(solidbits->be_v,rt_i.nsolids);
	BITZERO(regionbits,rt_i.nregions);
	HeadSeg = SEG_NULL;
d184 1
a191 1
		register union cutter *cutp;
a192 1
		struct seg *waitsegs;	/* segs awaiting rt_boolweave() */
d202 1
a202 1
		cutp = &CutHead;
d227 1
d244 1
a244 1
				rt_i.nmiss_tree++;
d254 2
a255 1
			     /*  stp->st_id != ID_ARB8 && */
d258 1
a258 1
			      ap->a_ray.r_max < -0.005 )
d260 1
a260 1
				rt_i.nmiss_solid++;
d264 1
a264 1
			rt_i.nshots++;
d268 1
a268 1
				rt_i.nmiss++;
d287 1
a287 1
				newseg->seg_out.hit_dist < -0.005 )  {
d293 1
a293 1
				rt_i.nmiss++;
d309 2
a310 2
				rt_pr_bitv( "shoot Regionbits", regionbits, rt_i.nregions);
			rt_i.nhits++;
d355 9
d376 9
@


3.0
log
@rt/ and librt/ separated,
global datastructures simplified.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: shoot.c,v 2.10 86/06/09 21:50:53 mike Exp $ (BRL)";
d35 1
a35 1
 *  (building the HeadSeg chain), and then call rt_bool_regions()
d100 1
a100 1
		if( NEAR_ZERO(f) )  {
d105 1
a105 1
		if( !NEAR_ZERO( diff ) )  {
d115 1
a115 1
	if(ap->a_ray.r_dir[X] > ZERO_COS || ap->a_ray.r_dir[X] < -ZERO_COS) {
d121 1
a121 1
	if(ap->a_ray.r_dir[Y] > ZERO_COS || ap->a_ray.r_dir[Y] < -ZERO_COS) {
d127 1
a127 1
	if(ap->a_ray.r_dir[Z] > ZERO_COS || ap->a_ray.r_dir[Z] < -ZERO_COS) {
d168 1
a168 1
		struct seg *waitsegs;	/* segs awaiting rt_bool_weave() */
d175 1
a175 1
			f = box_start + EPSILON;
d189 1
a189 1
		/* Make sure we don't get stuck within the same box twice */
d191 2
a192 3
			rt_log("straight box push failed\n");
			/* Advance 0.01% of last box size */
			box_end += (box_end-box_start)*0.0001;
d232 1
a232 1
			      ap->a_ray.r_max < -EPSILON )
d261 1
a261 1
				newseg->seg_out.hit_dist < -EPSILON )  {
d272 1
a272 1
			/* Add seg chain to list awaiting rt_bool_weave() */
d292 1
a292 1
			rt_bool_weave( waitsegs, &InitialPart );
d309 1
a309 1
			rt_bool_final( &InitialPart, &FinalPart,
d336 1
a336 1
	rt_bool_final( &InitialPart, &FinalPart, 0.0, model_end, regionbits, ap);
@


2.10
log
@rt and librt separated
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: shoot.c,v 2.9 86/05/29 01:48:31 mike Exp $ (BRL)";
a28 1

a30 33
int debug = DEBUG_OFF;	/* non-zero for debugging, see debug.h */
long nsolids;		/* total # of solids participating */
long nregions;		/* total # of regions participating */
long nshots;		/* # of calls to ft_shot() */
long nmiss_model;	/* rays missed model RPP */
long nmiss_tree;	/* rays missed sub-tree RPP */
long nmiss_solid;	/* rays missed solid RPP */
long nmiss;		/* solid ft_shot() returned a miss */
long nhits;		/* solid ft_shot() returned a hit */
int rt_needprep = 1;	/* rt_prep() needs calling */
struct soltab *HeadSolid = SOLTAB_NULL;
struct seg *FreeSeg = SEG_NULL;		/* Head of freelist */

HIDDEN int shoot_tree();

void get_bitv();
union bitv_elem {
	union bitv_elem	*be_next;
	bitv_t		be_v[2];
};
union bitv_elem *FreeBitv;		/* Head of freelist */
#define BITV_NULL	((union bitv_elem *)0)

#define GET_BITV(p)    {	RES_ACQUIRE(&res_bitv); \
			while( ((p)=FreeBitv) == BITV_NULL ) \
				get_bitv(); \
			FreeBitv = (p)->be_next; \
			p->be_next = BITV_NULL; \
			RES_RELEASE(&res_bitv); }
#define FREE_BITV(p)   {	RES_ACQUIRE(&res_bitv); \
			(p)->be_next = FreeBitv; FreeBitv = (p); \
			RES_RELEASE(&res_bitv); }

d32 1
a32 1
 *  			S H O O T R A Y
d35 1
a35 1
 *  (building the HeadSeg chain), and then call bool_regions()
d60 1
a60 1
 *  NOTE:  The appliction functions may call shootray() recursively.
d64 1
a64 1
shootray( ap )
d81 1
a81 1
	if( rt_needprep )  rt_prep();		/* so things will work */
d88 1
a88 1
	if(debug&(DEBUG_ALLRAYS|DEBUG_SHOOT|DEBUG_PARTITION)) {
d95 1
a95 1
	if(debug) {
d101 1
a101 1
			rtbomb("shootray:  zero length dir vector\n");
d106 1
a106 1
			rtlog("shootray: non-unit dir vect (x%d y%d lvl%d)\n",
d137 1
a137 1
	if( !in_rpp( &ap->a_ray, inv_dir, mdl_min, mdl_max )  ||
d139 1
a139 1
		nmiss_model++;
d152 4
a155 4
	GET_BITV( solidbits );	/* see get_bitv() for details */
	regionbits = &solidbits->be_v[2+(BITS2BYTES(nsolids)/sizeof(bitv_t))];
	BITZERO(solidbits->be_v,nsolids);
	BITZERO(regionbits,nregions);
d168 1
a168 1
		struct seg *waitsegs;	/* segs awaiting bool_weave() */
d187 1
a187 1
			rtbomb("leaf not boxnode");
d191 1
a191 1
			rtlog("straight box push failed\n");
d199 1
a199 1
		if( !in_rpp(&ap->a_ray, inv_dir,
d201 1
a201 1
			rtlog("shootray:  ray misses box?\n");
d207 2
a208 2
		if(debug&DEBUG_SHOOT) {
			rtlog("ray (%f, %f) %f\n", box_start, box_end, model_end);
d210 1
a210 1
			pr_cut( cutp, 0 );
d219 2
a220 2
				if(debug&DEBUG_SHOOT)rtlog("skipping %s\n", stp->st_name);
				nmiss_tree++;
d225 1
a225 1
			if(debug&DEBUG_SHOOT)rtlog("shooting %s\n", stp->st_name);
d231 1
a231 1
			   ( !in_rpp( &ap->a_ray, inv_dir,
d235 1
a235 1
				nmiss_solid++;
d239 2
a240 2
			nshots++;
			if( (newseg = functab[stp->st_id].ft_shot( 
d243 1
a243 1
				nmiss++;
d246 1
a246 1
			if(debug&DEBUG_SHOOT)  pr_seg(newseg);
d251 1
a251 1
				rtlog("ERROR %s: in/out rev (%f,%f)\n",
d268 1
a268 1
				nmiss++;
d273 1
a273 1
			/* Add seg chain to list awaiting bool_weave() */
d282 4
a285 3
			bitv_or( regionbits, stp->st_regions, stp->st_maxreg);
			if(debug&DEBUG_PARTITION) pr_bitv( "shoot Regionbits", regionbits, nregions);
			nhits++;	/* global counter */
d293 1
a293 1
			bool_weave( waitsegs, &InitialPart );
d310 1
a310 1
			bool_final( &InitialPart, &FinalPart,
d337 1
a337 1
	bool_final( &InitialPart, &FinalPart, 0.0, model_end, regionbits, ap);
d357 1
a357 1
			functab[stp->st_id].ft_norm(
d362 1
a362 1
			functab[stp->st_id].ft_norm(
d366 1
a366 1
	if(debug&DEBUG_SHOOT)  pr_partitions(&FinalPart,"a_hit()");
d406 3
a408 3
	if(debug&(DEBUG_SHOOT|DEBUG_ALLRAYS))
		rtlog( "%s, ret%d\n", status, ret);
	if( debug )  fflush(stderr);
d413 1
a413 1
 *			I N _ R P P
d435 1
a435 1
in_rpp( rp, invdir, min, max )
d526 5
a530 1
bitv_or( out, in, nbits )
d543 1
a543 1
 *  			G E T _ B I T V
d549 1
a549 1
 *  malloc() locking is done in vmalloc.
d555 1
a555 1
get_bitv()  {
d560 1
a560 1
	size = BITS2BYTES(nsolids) + BITS2BYTES(nregions) + 4*sizeof(bitv_t);
d562 3
a564 3
	bytes = byte_roundup(16*size);
	if( (cp = vmalloc(bytes, "get_bitv")) == (char *)0 )  {
		rtlog("get_bitv: malloc failure\n");
d568 2
a569 2
		((union bitv_elem *)cp)->be_next = FreeBitv;
		FreeBitv = (union bitv_elem *)cp;
@


2.9
log
@Improved direction cosine tolerancing, inspired by Moss.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: shoot.c,v 2.8 86/03/14 21:07:09 mike Exp $ (BRL)";
d27 1
a27 1
#include "raytrace.h"
@


2.8
log
@Improved commenting.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: shoot.c,v 2.7 86/02/21 16:49:43 mike Exp $ (BRL)";
d147 20
a166 4
	inv_dir[X] = inv_dir[Y] = inv_dir[Z] = INFINITY;
	if(!NEAR_ZERO(ap->a_ray.r_dir[X])) inv_dir[X]=1.0/ap->a_ray.r_dir[X];
	if(!NEAR_ZERO(ap->a_ray.r_dir[Y])) inv_dir[Y]=1.0/ap->a_ray.r_dir[Y];
	if(!NEAR_ZERO(ap->a_ray.r_dir[Z])) inv_dir[Z]=1.0/ap->a_ray.r_dir[Z];
d267 1
a267 1
			      ap->a_ray.r_max <= 0.0 )
d483 1
a483 1
	if( rp->r_dir[X] < -EPSILON )  {
d492 1
a492 1
	}  else if( rp->r_dir[X] > EPSILON )  {
d508 1
a508 1
			return(0);	/* MISS */;
d513 1
a513 1
	if( rp->r_dir[Y] < -EPSILON )  {
d520 1
a520 1
	}  else if( rp->r_dir[Y] > EPSILON )  {
d529 1
a529 1
			return(0);	/* MISS */;
d534 1
a534 1
	if( rp->r_dir[Z] < -EPSILON )  {
d541 1
a541 1
	}  else if( rp->r_dir[Z] > EPSILON )  {
d550 1
a550 1
			return(0);	/* MISS */;
@


2.7
log
@Bug fix from Paul Stay to make in_rpp() handle a degenerate
RPP (ie, a plane).
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: shoot.c,v 2.6 86/01/24 11:54:23 mike Exp $ (BRL)";
d468 2
d477 2
d487 3
a489 2
		 *  Direction along this axis is NEAR 0, (ray aligned
		 *  with axis), merely check pos against the boundaries.
a511 4
		/*
		 *  Direction along this axis is NEAR 0, (ray aligned
		 *  with axis), merely check against the boundaries.
		 */
a532 4
		/*
		 *  Direction along this axis is NEAR 0, (ray aligned
		 *  with axis), merely check against the boundaries.
		 */
@


2.6
log
@Adjusted get_bitv to preserve alignment.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: shoot.c,v 2.5 85/09/18 01:29:11 mike Exp $ (BRL)";
d540 2
a541 1
	if( rp->r_min >= rp->r_max )
@


2.5
log
@Changed shootray() to have bitvector free queues, rather than
calling vmalloc() and vfree() all the time.  While not too costly
on serial machines, this is inside the critical section on parallel
machines like the HEP, and was a serious performance bottleneck.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: shoot.c,v 2.4 85/09/14 05:27:47 mike Exp $ (BRL)";
d576 1
@


2.4
log
@Created new macro BITS2BYTES to unify sizing of bit vectors.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: shoot.c,v 2.3 85/09/11 01:03:25 mike Exp $ (BRL)";
d47 18
d107 1
a107 1
	auto bitv_t *solidbits;		/* bits for all solids shot so far */
d120 1
a120 1
	solidbits = (bitv_t *)0;		/* not allocated yet */
d170 3
a172 5
	solidbits = (bitv_t *)vmalloc(
		BITS2BYTES(nsolids) + BITS2BYTES(nregions) + 4*sizeof(bitv_t),
		"solidbits+regionbits");
	regionbits = &solidbits[2+(BITS2BYTES(nsolids)/sizeof(bitv_t))];
	BITZERO(solidbits,nsolids);
d236 1
a236 1
			if( BITTEST( solidbits, stp->st_bit ) )  {
d244 1
a244 1
			BITSET( solidbits, stp->st_bit );
d420 3
a422 2
	if( solidbits != (bitv_t *)0)
		vfree((char *)solidbits, "solidbits");
d555 32
@


2.3
log
@Added extra checking.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: shoot.c,v 2.2 85/09/05 02:20:14 mike Exp $ (BRL)";
a151 1
	ret = nsolids+nregions+2*8*sizeof(bitv_t)-2;	/* # aligned bits */
d153 1
a153 1
		3*sizeof(bitv_t) + (ret/sizeof(bitv_t)),
d155 1
a155 1
	regionbits = &solidbits[2+(nsolids/sizeof(bitv_t))]; /* safe */
d535 1
a535 1
	words = (nbits+BITV_MASK)>>BITV_SHIFT;
@


2.2
log
@If debugging, verify that direction vector has unit length.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: shoot.c,v 2.1 85/08/31 06:06:16 mike Exp $ (BRL)";
d116 4
@


2.1
log
@Version 2 of RT
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: shoot.c,v 1.22 85/07/30 05:55:14 mike Exp $ (BRL)";
d108 15
@


1.22
log
@Changes for merged GED & RT vmath.h
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: shoot.c,v 1.21 85/06/07 01:42:29 mike Exp $ (BRL)";
d30 2
d41 1
d77 1
a78 6
struct shootwork {
	struct application	*sw_ap;
	struct seg		*sw_HeadSeg;
	int			sw_curbin;
};

d83 1
a83 3
	extern struct region *HeadRegion;	/* read-only */
	register struct region *rp;
	auto struct shootwork sw;	/* must NOT be static (recursion) */
d85 11
d97 18
a116 4
	 *  For models with non-cubical shape, this test
	 *  actually trims off a substantial number of rays,
	 *  and is well worth it.  When the model fills the view,
	 *  then this is just wasted time;  perhaps a flag is needed?
d118 1
a118 1
	if( !in_rpp( &ap->a_ray, mdl_min, mdl_max )  ||
d121 3
a123 1
		return( ap->a_miss( ap ) );
d126 6
a131 5
	if(debug&DEBUG_ALLRAYS) {
		VPRINT("\nRay Start", ap->a_ray.r_pt);
		VPRINT("Ray Direction", ap->a_ray.r_dir);
		fflush(stderr);		/* In case of instant death */
	}
d133 10
a142 3
	sw.sw_ap = ap;
	sw.sw_HeadSeg = SEG_NULL;
	sw.sw_curbin = 0;				/* bin 0 is always FALSE */
d144 127
a270 2
	/* For now, consider every region in the model */
	for( rp=HeadRegion; rp != REGION_NULL; rp = rp->reg_forw )  {
d272 2
a273 2
		 * Boolean TRUE signals hit of 1 or more solids in tree
		 * At leaf node, it will call ft_shot & add to seg chain.
d275 31
a305 1
		(void)shoot_tree( rp->reg_treetop, &sw );
d307 1
d310 1
a310 1
	if( sw.sw_HeadSeg == SEG_NULL )  {
d312 3
a314 7
	}  else  {
		auto struct partition PartHead;
		/*
		 *  All intersections of the ray with the model have
		 *  been computed.  Evaluate the boolean functions.
		 */
		bool_regions( sw.sw_HeadSeg, &PartHead );
d316 5
a320 9
		if( PartHead.pt_forw == &PartHead )  {
			ret = ap->a_miss( ap );
		}  else  {
			register struct partition *pp;
			/*
			 * Hand final partitioned intersection list
			 * to the application.
			 */
			ret = ap->a_hit( ap, &PartHead );
d322 25
a346 7
			/* Free up partition list */
			for( pp = PartHead.pt_forw; pp != &PartHead;  )  {
				register struct partition *newpp;
				newpp = pp;
				pp = pp->pt_forw;
				FREE_PT(newpp);
			}
d348 2
d351 2
a352 9
		/*
		 * Processing of this ray is complete.
		 * Put zeros in the bin #s of all solids used,
		 * and release resources.
		 */
		{
			register struct seg *segp;	/* XXX */
			for( segp = sw.sw_HeadSeg; segp != SEG_NULL; segp = segp->seg_next )
				segp->seg_stp->st_bin = 0;
d354 13
a366 5
			while( sw.sw_HeadSeg != SEG_NULL )  {
				segp = sw.sw_HeadSeg->seg_next;
				FREE_SEG( sw.sw_HeadSeg );
				sw.sw_HeadSeg = segp;
			}
d368 7
d376 14
d417 1
a417 1
in_rpp( rp, min, max )
d419 3
a421 1
register fastf_t *min, *max;
a422 2
	LOCAL fastf_t sv;
	LOCAL fastf_t st;
d424 2
a425 2
	register fastf_t *dir = &rp->r_dir[0];
	register int i;
d427 1
d431 22
a452 24
	for( i=0; i < 3; i++, pt++, dir++, max++, min++ )  {
		if( *dir < -EPSILON )  {
			if( (sv = (*min - *pt) / *dir) < 0.0 )
				return(0);	/* MISS */
			if(rp->r_max > sv)
				rp->r_max = sv;
			if( rp->r_min < (st = (*max - *pt) / *dir) )
				rp->r_min = st;
		}  else if( *dir > EPSILON )  {
			if( (st = (*max - *pt) / *dir) < 0.0 )
				return(0);	/* MISS */
			if(rp->r_max > st)
				rp->r_max = st;
			if( rp->r_min < ((sv = (*min - *pt) / *dir)) )
				rp->r_min = sv;
		}  else  {
			/*
			 *  If direction component along this axis is NEAR 0,
			 *  (ie, this ray is aligned with this axis),
			 *  merely check against the boundaries.
			 */
			if( (*min > *pt) || (*max < *pt) )
				return(0);	/* MISS */;
		}
d454 51
d510 4
a513 15
/* Boolean values.  Not easy to change, but defined symbolicly */
#define FALSE	0
#define TRUE	1

/*
 *  			S H O O T _ T R E E
 *
 *  Returns FALSE when there is definitely NO HIT.
 *  Returns TRUE when there is the Potential for a hit;
 *  bool_regions() must ultimately decide.
 */
HIDDEN int
shoot_tree( tp, swp )
register struct tree *tp;
register struct shootwork *swp;
d515 1
a515 2
	if( tp->tr_op == OP_SOLID )  {
		register struct seg *newseg;
d517 3
a519 109
		if( tp->tr_stp->st_bin )
			return( TRUE );		/* sol has already been hit */

		/* If ray does not strike the bounding RPP, skip on */
		if( !in_rpp( &(swp->sw_ap->a_ray), tp->tr_min, tp->tr_max )  ||
		    swp->sw_ap->a_ray.r_max <= 0.0 )  {
			nmiss_solid++;
			return( FALSE );	/* MISS subtree */
		}

#	ifdef never
		/* Consider bounding sphere */
		VSUB2( diff, stp->st_center, swp->sw_ap->a_ray.r_pt );
		distsq = VDOT(swp->sw_ap->a_ray.r_dir, diff);
		if( (MAGSQ(diff) - distsq*distsq) > stp->st_radsq ) {
			nmiss_solid++;
			continue;
		}
#	endif

		nshots++;
		if( (newseg = functab[tp->tr_stp->st_id].ft_shot(
			tp->tr_stp,
			&(swp->sw_ap->a_ray) )
		     ) == SEG_NULL )  {
			nmiss++;
			return( FALSE );	/* MISS */
		}

		/* Expunge this line of code when regions die */
		newseg->seg_tp = tp;	/* associate seg with this tree */

		/* First, some checking */
		if( newseg->seg_in.hit_dist > newseg->seg_out.hit_dist )  {
			LOCAL struct hit temp;		/* XXX */
			fprintf(stderr,"ERROR %s: in/out reversal (%f,%f)\n",
				newseg->seg_stp->st_name,
				newseg->seg_in.hit_dist,
				newseg->seg_out.hit_dist );
			temp = newseg->seg_in;		/* struct copy */
			newseg->seg_in = newseg->seg_out; /* struct copy */
			newseg->seg_out = temp;		/* struct copy */
		}

		/* Discard seg entirely behind the start point of the ray */
		if( newseg->seg_out.hit_dist < -EPSILON )  {
			FREE_SEG( newseg );
			return( FALSE );	/* MISS */
		}

		/* Add segment chain to list */
		{
			register struct seg *seg2 = newseg;
			while( seg2->seg_next != SEG_NULL )
				seg2 = seg2->seg_next;
			seg2->seg_next = swp->sw_HeadSeg;
			swp->sw_HeadSeg = newseg;
		}

		if( newseg->seg_stp->st_bin == 0 )  {
			if( swp->sw_curbin++ >= NBINS )
				rtbomb("shoot_tree:  need > NBINS bins");
			/* The negative bin number is flag to bool_regions */
			newseg->seg_stp->st_bin = -(swp->sw_curbin);
		}
		nhits++;
		return( TRUE );		/* HIT, solid added */
	}

	/* If ray does not strike the bounding RPP, skip on */
	if( !in_rpp( &(swp->sw_ap->a_ray), tp->tr_min, tp->tr_max )  ||
	    swp->sw_ap->a_ray.r_max <= 0.0 )  {
		nmiss_tree++;
		return( FALSE );	/* MISS subtree */
	}

    {
	register int flag;

	switch( tp->tr_op )  {

	case OP_UNION:
		/* NOTE:  It is important to always evaluate both */
		flag = shoot_tree( tp->tr_left, swp );
		if( shoot_tree( tp->tr_right, swp ) == FALSE  &&
		    flag == FALSE )
			return(FALSE);
		return(TRUE);			/* May have a hit */

	case OP_INTERSECT:
		return(	shoot_tree( tp->tr_left, swp )  &&
			shoot_tree( tp->tr_right, swp )  );

	case OP_SUBTRACT:
		if( shoot_tree( tp->tr_left, swp ) == FALSE )
			return(FALSE);		/* FALSE = FALSE - X */
		/* If ray hit left solid, we MUST compute potential
		 *  hit with right solid, as only bool_regions()
		 *  can really tell the final story.  Always give TRUE.
		 */
		shoot_tree( tp->tr_right, swp );
		return( TRUE );		/* May have a hit */

	default:
		fprintf(stderr,"shoot_tree: bad op=x%x", tp->tr_op );
		return( FALSE );
	  }
    }
	/* NOTREACHED */
@


1.21
log
@Cosmetic
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: shoot.c,v 1.20 85/06/05 00:24:26 mike Exp $ (BRL)";
d25 2
a26 1
#include "vmath.h"
@


1.20
log
@Modifications to eliminate curbin as a global static.
Created shootwork structure instead.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: shoot.c,v 1.19 85/06/04 23:24:32 mike Exp $ (BRL)";
d41 2
d84 1
a84 1
	extern struct region *HeadRegion;
d249 1
@


1.19
log
@Various little changed needed to make the HEP version work.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: shoot.c,v 1.18 85/05/29 00:15:19 mike Exp $ (BRL)";
d72 5
a76 1
static int curbin;	/* NOT PARALLEL;  needs fixing */
d84 1
a84 1
	auto struct seg *HeadSeg;	/* must NOT be static (recursion) */
d106 3
a108 2
	HeadSeg = SEG_NULL;
	curbin = 0;				/* bin 0 is always FALSE */
d116 1
a116 1
		(void)shoot_tree( ap, rp->reg_treetop, &HeadSeg );
d120 1
a120 1
	if( HeadSeg == SEG_NULL )  {
d128 1
a128 1
		bool_regions( HeadSeg, &PartHead );
d156 1
a156 1
			for( segp = HeadSeg; segp != SEG_NULL; segp = segp->seg_next )
d159 4
a162 4
			while( HeadSeg != SEG_NULL )  {
				segp = HeadSeg->seg_next;
				FREE_SEG( HeadSeg );
				HeadSeg = segp;
d247 1
a247 2
shoot_tree( ap, tp, HeadSegp )
register struct application *ap;
d249 1
a249 1
struct seg **HeadSegp;
d258 2
a259 2
		if( !in_rpp( &ap->a_ray, tp->tr_min, tp->tr_max )  ||
		    ap->a_ray.r_max <= 0.0 )  {
d266 2
a267 2
		VSUB2( diff, stp->st_center, ap->a_ray.r_pt );
		distsq = VDOT(ap->a_ray.r_dir, diff);
d277 1
a277 1
			&ap->a_ray )
d309 2
a310 2
			seg2->seg_next = (*HeadSegp);
			(*HeadSegp) = newseg;
d314 1
a314 1
			if( curbin++ >= NBINS )
d317 1
a317 1
			newseg->seg_stp->st_bin = -curbin;
d324 2
a325 2
	if( !in_rpp( &ap->a_ray, tp->tr_min, tp->tr_max )  ||
	    ap->a_ray.r_max <= 0.0 )  {
d337 2
a338 2
		flag = shoot_tree( ap, tp->tr_left, HeadSegp );
		if( shoot_tree( ap, tp->tr_right, HeadSegp ) == FALSE  &&
d344 2
a345 2
		return(	shoot_tree( ap, tp->tr_left, HeadSegp )  &&
			shoot_tree( ap, tp->tr_right, HeadSegp )  );
d348 1
a348 1
		if( shoot_tree( ap, tp->tr_left, HeadSegp ) == FALSE )
d354 1
a354 1
		shoot_tree( ap, tp->tr_right, HeadSegp );
@


1.18
log
@Moved region and material pointer from solid structure to tree (leaf)
nodes, added path matrix and use count to solid structure, to permit
solids referenced with identical path matrices to "share",
resulting in far greater speed.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: shoot.c,v 1.17 85/05/01 16:16:54 mike Exp $ (BRL)";
d90 1
a90 1
	if( !in_rpp( &ap->a_ray, model_min, model_max )  ||
@


1.17
log
@Fix from Gary Moss to fix problem with ray start points exactly
on a solid surface.
.,
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: shoot.c,v 1.16 85/03/25 11:46:55 mike Exp $ (BRL)";
d72 2
d103 1
d145 3
a147 1
		 * Processing of this ray is complete, so release resources.
d149 4
a152 2
		while( HeadSeg != SEG_NULL )  {
			register struct seg *hsp;	/* XXX */
d154 5
a158 3
			hsp = HeadSeg->seg_next;
			FREE_SEG( HeadSeg );
			HeadSeg = hsp;
d250 3
d279 3
d307 7
@


1.16
log
@Housekeeping
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: shoot.c,v 1.15 85/02/01 22:13:25 mike Exp $ (BRL)";
d280 1
a280 1
		if( newseg->seg_out.hit_dist < 0 )  {
@


1.15
log
@Fixed "optimization" with UNIONs to give correct results.
@
text
@d6 1
a6 1
 * Author -
d9 8
a16 4
 *	U. S. Army Ballistic Research Laboratory
 *	May 1, 1984
 *
 * $Revision: 1.14 $
d19 1
a19 1
static char RCSid[] = "@@(#)$Header: shoot.c,v 1.14 85/01/31 21:11:42 mike Exp $ (BRL)";
d21 2
@


1.14
log
@Added code to discard segments entirely behind start point.
@
text
@d12 1
a12 1
 * $Revision: 1.13 $
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: shoot.c,v 1.13 84/11/30 04:04:18 mike Exp $ (BRL)";
d298 3
d305 3
a307 2
		if(	shoot_tree( ap, tp->tr_left, HeadSegp ) == FALSE &&
			shoot_tree( ap, tp->tr_right, HeadSegp ) == FALSE )
d328 2
a329 1
	}
@


1.13
log
@Added more statistics on success of pruning algorithm.
@
text
@d12 1
a12 1
 * $Revision: 1.12 $
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: shoot.c,v 1.12 84/11/29 07:03:34 mike Exp $ (BRL)";
d271 6
@


1.12
log
@Now committed to the bounding RPP tree-descent strategy.
@
text
@d12 1
a12 1
 * $Revision: 1.11 $
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: shoot.c,v 1.11 84/11/27 07:01:42 mike Exp $ (BRL)";
d26 6
a31 2
long nshots;		/* # of ray-meets-solid "shots" */
long nmiss;		/* # of ray-misses-solid's-sphere "shots" */
d84 1
a84 1
		nmiss++;
d98 4
a101 12
		
		/* Check region bounding RPP */
		if( !in_rpp(
			&ap->a_ray, rp->reg_treetop->tr_min,
			rp->reg_treetop->tr_max )  ||
		    ap->a_ray.r_max <= 0.0 )  {
			nmiss++;
			continue;
		}

		/* Boolean TRUE signals hit of 1 or more solids in tree */
		/* At leaf node, it will calll ft_shot & add to chain */
d187 1
a187 12
		if( NEAR_ZERO( *dir ) )  {
			/*
			 *  If direction component along this axis is 0,
			 *  (ie, this ray is aligned with this axis),
			 *  merely check against the boundaries.
			 */
			if( (*min > *pt) || (*max < *pt) )
				return(0);	/* MISS */;
			continue;
		}

		if( *dir < 0.0 )  {
d194 1
a194 1
		}  else  {
d201 8
d232 2
d235 6
a240 4
	/* If ray does not strike the bounding RPP, skip on */
	if( !in_rpp( &ap->a_ray, tp->tr_min, tp->tr_max )  ||
	    ap->a_ray.r_max <= 0.0 )
		return( FALSE );	/* MISS subtree */
a241 6
	switch( tp->tr_op )  {

	case OP_SOLID:
	    {
		register struct seg *newseg;

d247 1
a247 1
			nmiss++;
d253 7
a259 3
		newseg = functab[tp->tr_stp->st_id].ft_shot( tp->tr_stp, &ap->a_ray );
		if( newseg == SEG_NULL )
			return( FALSE );/* MISS subtree (solid) */
d281 1
d283 1
a283 1
	    }
d285 9
a294 7
	case OP_INTERSECT:
	case OP_SUBTRACT:
		shoot_tree( ap, tp->tr_left, HeadSegp );
		shoot_tree( ap, tp->tr_right, HeadSegp );
		return(TRUE);
#ifdef never
	case OP_UNION:
a313 1
#endif
@


1.11
log
@New recursive tree descent algorithm which is region driven,
offering the potential for much faster operation.
@
text
@d12 1
a12 1
 * $Revision: 1.10 $
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: shoot.c,v 1.10 84/11/24 03:03:25 mike Exp $ (BRL)";
d35 5
a39 2
 *  building the HeadSeg chain, and calling the appropriate application
 *  routine (a_hit, a_miss).
d41 2
a42 2
 *  This is where higher-level pruning should be done.
 *  This code is executed more often than any other part of the RT library.
d44 17
a60 1
 *  WARNING:  The appliction functions may call shootray() recursively.
d62 1
a62 1
void
d66 4
a69 4
	LOCAL vect_t diff;	/* diff between shot base & solid center */
	FAST fastf_t distsq;	/* distance**2 */
	auto struct seg *HeadSeg; /* must NOT be static (recursion ) */
	LOCAL fastf_t inout[2];	/* entry_dist, exit_dist for bounding RPP */
d71 9
a79 4

	/* If ray does not enter the model RPP, skip on */
	if( !in_rpp( &ap->a_ray, model_min, model_max, inout )  ||
	    inout[1] < 0.0 )  {
d81 1
a81 2
		ap->a_miss( ap );
		return;
d92 1
a92 5
#ifndef Tree_Method
  {
	register struct region *rp;
	extern struct region *HeadRegion;

d98 2
a99 2
			rp->reg_treetop->tr_max, inout )  ||
		    inout[1] < 0.0 )  {
d106 1
a106 3
		if( !shoot_tree( ap, rp->reg_treetop, &HeadSeg ) )
			continue;
		/* If any solid hit, add this region to active chain */
a107 4
 }
#else
 {
	register struct soltab *stp;
a108 60
	/*
	 * For now, shoot at all solids in model.
	 */
	for( stp=HeadSolid; stp != SOLTAB_NULL; stp=stp->st_forw ) {
		register struct seg *newseg;		/* XXX */

#	ifndef never
		/* Consider bounding sphere */
		VSUB2( diff, stp->st_center, ap->a_ray.r_pt );
		distsq = VDOT(ap->a_ray.r_dir, diff);
		if( (MAGSQ(diff) - distsq*distsq) > stp->st_radsq ) {
			nmiss++;
			continue;
		}
#	endif

		/* If ray does not strike the bounding RPP, skip on */
		if( !in_rpp( &ap->a_ray, stp->st_min, stp->st_max, inout ) ) {
			nmiss++;
			continue;
		}

		/*
		 * Rays have direction.  If ray enters and exits this
		 * solid entirely behind the start point, skip on.
		 */
		if( inout[1] < 0.0 )  {
			nmiss++;
			continue;	/* enters & exits behind eye */
		}

		nshots++;
		newseg = functab[stp->st_id].ft_shot( stp, &ap->a_ray );
		if( newseg == SEG_NULL )
			continue;

		/* First, some checking */
		if( newseg->seg_in.hit_dist > newseg->seg_out.hit_dist )  {
			LOCAL struct hit temp;		/* XXX */
			fprintf(stderr,"ERROR %s %s: in/out reversal (%f,%f)\n",
				functab[stp->st_id].ft_name,
				newseg->seg_stp->st_name,
				newseg->seg_in.hit_dist,
				newseg->seg_out.hit_dist );
			temp = newseg->seg_in;		/* struct copy */
			newseg->seg_in = newseg->seg_out; /* struct copy */
			newseg->seg_out = temp;		/* struct copy */
		}
		/* Add segment chain to list */
		{
			register struct seg *seg2 = newseg;
			while( seg2->seg_next != SEG_NULL )
				seg2 = seg2->seg_next;
			seg2->seg_next = HeadSeg;
			HeadSeg = newseg;
		}
	}
 }
#endif

d111 1
a111 1
		ap->a_miss( ap );
d121 1
a121 1
			ap->a_miss( ap );
d128 1
a128 1
			ap->a_hit( ap, &PartHead );
d151 1
d172 4
a175 2
 *	bounds[0] = dist from start of ray to point at which ray ENTERS solid
 *	bounds[1] = dist from start of ray to point at which ray LEAVES solid
d177 2
a178 2
in_rpp( rp, min, max, bounds )
struct xray *rp;
a179 1
register fastf_t *bounds;
d187 2
a188 2
	*bounds = -INFINITY;
	bounds[1] = INFINITY;
d205 4
a208 4
			if(bounds[1] > sv)
				bounds[1] = sv;
			if( *bounds < (st = (*max - *pt) / *dir) )
				*bounds = st;
d212 4
a215 4
			if(bounds[1] > st)
				bounds[1] = st;
			if( *bounds < ((sv = (*min - *pt) / *dir)) )
				*bounds = sv;
d218 1
a218 1
	if( *bounds >= bounds[1] )
a238 1
	LOCAL vect_t inout;
d241 2
a242 2
	if( !in_rpp( &ap->a_ray, tp->tr_min, tp->tr_max, inout )  ||
	    inout[1] < 0.0 )
d251 10
d265 12
@


1.10
log
@Improved bounding RPP code, deactivated bounding sphere code.
@
text
@d12 1
a12 1
 * $Revision: 1.9 $
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: shoot.c,v 1.9 84/11/23 20:54:33 mike Exp $ (BRL)";
a46 1
	register struct soltab *stp;
d49 2
a50 1
	auto struct seg *HeadSeg;
d52 9
d69 27
d102 1
a102 1
#ifndef never
d110 1
a110 1
#endif
d112 2
a113 2
		/* Here we also consider the bounding RPP */
		if( !in_rpp( &ap->a_ray, stp->st_min, stp->st_max ) )  {
d118 9
d153 2
d201 1
a201 1
 *			I N _ R P P . C
d207 3
a210 3
 * enter_dist = distance from start of ray to point at which ray enters solid
 * exit_dist  = distance from start of ray to point at which ray leaves solid
 *
d218 2
d221 1
a221 1
in_rpp( rp, min, max )
d224 1
a225 1
	LOCAL fastf_t enter_dist, exit_dist;
d232 2
a233 2
	enter_dist = -INFINITY;
	exit_dist = INFINITY;
d250 4
a253 4
			if(exit_dist > sv)
				exit_dist = sv;
			if( enter_dist < (st = (*max - *pt) / *dir) )
				enter_dist = st;
d257 4
a260 4
			if(exit_dist > st)
				exit_dist = st;
			if( enter_dist < ((sv = (*min - *pt) / *dir)) )
				enter_dist = sv;
d263 1
a263 1
	if( enter_dist >= exit_dist )
d266 81
@


1.9
log
@Added LOCAL, fastf_t declarations.
Made shootray() recursive.
@
text
@d12 1
a12 1
 * $Revision: 1.8 $
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: shoot.c,v 1.8 84/11/20 20:14:48 mike Exp $ (BRL)";
d66 1
d74 1
a75 2
#ifdef never
/*** First, we have to computer the bounding RPPs right! ** */
a80 1
#endif
d164 4
d173 2
a174 2
register struct xray *rp;
register vect_t min, max;
d179 2
d186 2
a187 2
	for( i=0; i < 3; i++ )  {
		if( NEAR_ZERO( rp->r_dir[i] ) )  {
d193 1
a193 1
			if( (min[i] > rp->r_pt[i]) || (max[i] < rp->r_pt[i]) )
d198 2
a199 3
		if( rp->r_dir[i] < 0.0 )  {
			sv = (min[i] - rp->r_pt[i]) / rp->r_dir[i];
			if(sv < 0.0)
a200 1
			st = (max[i] - rp->r_pt[i]) / rp->r_dir[i];
d203 1
a203 1
			if(enter_dist < st)
d206 1
a206 2
			st = (max[i] - rp->r_pt[i]) / rp->r_dir[i];
			if(st < 0.)
a207 1
			sv = (min[i] - rp->r_pt[i]) / rp->r_dir[i];
d210 1
a210 1
			if(enter_dist < sv)
d214 1
a214 2
#define	TOL .0001
	if( enter_dist+TOL >= exit_dist )
@


1.8
log
@General cleanup
@
text
@d12 1
a12 1
 * $Revision: 1.7 $
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: shoot.c,v 1.7 84/11/16 06:29:12 mike Exp $ (BRL)";
a30 2
extern struct partition *bool_regions();

d35 2
a36 2
 *  building the HeadSeg chain (which is the implicit return
 *  from this routine).
d39 1
d41 1
a41 1
 *  This code is executed more often than any other part, generally.
d48 1
a48 1
	static vect_t diff;	/* diff between shot base & solid center */
d50 1
a50 1
	static struct seg *HeadSeg;
d74 8
a81 1
		/* Here we should also consider the bounding RPP */
d90 1
a90 1
			static struct hit temp;		/* XXX */
d114 1
a114 1
		register struct partition *PartHeadp;
d119 1
a119 1
		PartHeadp = bool_regions( HeadSeg );
d121 1
a121 1
		if( PartHeadp->pt_forw == PartHeadp )  {
d129 1
a129 1
			ap->a_hit( ap, PartHeadp );
d132 1
a132 1
			for( pp = PartHeadp->pt_forw; pp != PartHeadp;  )  {
d152 65
@


1.7
log
@struct ray --> struct xray
Bounding RPP
@
text
@d12 1
a12 1
 * $Revision: 1.6 $
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: shoot.c,v 1.6 84/11/15 21:48:04 mike Exp $ (BRL)";
d23 7
a29 4
extern long nsolids;		/* total # of solids participating */
extern long nregions;		/* total # of regions participating */
extern long nshots;		/* # of ray-meets-solid "shots" */
extern long nmiss;		/* # of ray-misses-solid's-sphere "shots" */
a30 3
extern struct soltab *HeadSolid;
extern struct functab functab[];

d44 1
d56 1
a56 1
		fflush(stdout);		/* In case of instant death */
d85 1
a85 1
			printf("ERROR %s %s: in/out reversal (%f,%f)\n",
d145 1
a145 1
	if( debug )  fflush(stdout);
@


1.6
log
@Minor bug fixes.
@
text
@d12 1
a12 1
 * $Revision: 1.5 $
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: shoot.c,v 1.5 84/10/19 01:38:32 mike Exp $ (BRL)";
d20 1
a20 1
#include "ray.h"
a49 1
	static struct partition *PartHeadp, *pp;
a58 1
	PartHeadp = PT_NULL;
d73 3
d83 1
a83 1
			static struct hit temp;	/* XXX */
d106 7
a112 2
		goto done;
	}
d114 9
a122 5
	/*
	 *  All intersections of the ray with the model have
	 *  been computed.  Evaluate the boolean functions.
	 */
	PartHeadp = bool_regions( HeadSeg );
d124 8
a131 6
	if( PartHeadp->pt_forw == PartHeadp )  {
		ap->a_miss( ap );
	}  else  {
		/* Hand final partitioned intersection list to application. */
		ap->a_hit( ap, PartHeadp );
	}
d133 5
a137 8
	/*
	 * Processing of this ray is complete, so release resources.
	 *
	 * Free up Seg memory.
	 */
done:
	while( HeadSeg != SEG_NULL )  {
		register struct seg *hsp;	/* XXX */
d139 3
a141 11
		hsp = HeadSeg->seg_next;
		FREE_SEG( HeadSeg );
		HeadSeg = hsp;
	}
	/* Free up partition list */
	if( PartHeadp != PT_NULL)  {
		for( pp = PartHeadp->pt_forw; pp != PartHeadp;  )  {
			register struct partition *newpp;
			newpp = pp;
			pp = pp->pt_forw;
			FREE_PT(newpp);
@


1.5
log
@Lint corrections
@
text
@d12 1
a12 1
 * $Revision: 1.4 $
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: shoot.c,v 1.4 84/10/19 00:07:57 mike Exp $ (BRL)";
d60 1
d76 1
a76 1
		newseg = functab[stp->st_id].ft_shot( stp, ap->a_ray );
d92 1
a92 1
		/* Add to list */
d135 7
a141 5
	for( pp = PartHeadp->pt_forw; pp != PartHeadp;  )  {
		register struct partition *newpp;
		newpp = pp;
		pp = pp->pt_forw;
		FREE_PT(newpp);
@


1.4
log
@Reorganization of functions for separation of application from ray functions.
@
text
@d12 1
a12 1
 * $Revision: 1.3 $
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: shoot.c,v 1.3 84/08/28 03:08:31 mike Exp $ (BRL)";
d138 1
a138 1
		FREE_PART(newpp);
@


1.3
log
@Improved debugging slightly
@
text
@d12 1
a12 1
 * $Revision: 1.2 $
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: shoot.c,v 1.2 84/08/21 01:19:27 mike Exp $ (BRL)";
a29 1
extern struct seg *HeadSeg;
d31 2
d44 2
a45 2
shootray( rayp )
register struct ray *rayp;
d50 2
d54 2
a55 2
		VPRINT("\nRay Start", rayp->r_pt);
		VPRINT("Ray Direction", rayp->r_dir);
d59 1
a59 1
	HeadSeg = SEG_NULL;	/* Should check, actually */
d68 2
a69 2
		VSUB2( diff, stp->st_center, rayp->r_pt );
		distsq = VDOT(rayp->r_dir, diff);
d75 1
a75 1
		newseg = functab[stp->st_id].ft_shot( stp, rayp );
d100 41
@


1.2
log
@Fixed bug with multiple SEG struct chain being returned from X_shot().
@
text
@d12 1
a12 1
 * $Revision: 1.1 $
d15 1
a15 1
static char RCSid[] = "@@(#)$Header: shoot.c,v 1.1 84/05/04 09:11:44 mike Exp $ (BRL)";
d53 1
@


1.1
log
@Initial revision
@
text
@d12 1
a12 1
 * $Revision$
d15 1
a15 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d88 7
a94 2
		newseg->seg_next = HeadSeg;
		HeadSeg = newseg;
@
