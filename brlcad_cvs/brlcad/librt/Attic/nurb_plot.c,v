head	11.12;
access;
symbols
	ansi-20040405-merged:11.8.2.2
	postmerge-20040405-ansi:11.10
	premerge-20040404-ansi:11.9
	postmerge-autoconf:11.9
	autoconf-freeze:11.8.10.1
	premerge-autoconf:11.9
	ansi-20040316-freeze:11.8.2.1
	postmerge-20040315-windows:11.9
	premerge-20040315-windows:11.9
	windows-20040315-freeze:11.8.4.1
	autoconf-20031203:11.8
	autoconf-20031202:11.8
	autoconf-branch:11.8.0.10
	phong-branch:11.8.0.8
	photonmap-branch:11.8.0.6
	rel-6-1-DP:11.8
	windows-branch:11.8.0.4
	rel-6-0-2:11.6
	ansi-branch:11.8.0.2
	rel-6-0-1-branch:11.6.0.2
	hartley-6-0-post:11.7
	hartley-6-0-pre:11.6
	rel-6-0-1:11.6
	rel-6-0:11.6
	rel-5-4:11.4
	offsite-5-3-pre:11.5
	rel-5-3:11.4
	rel-5-2:11.4
	rel-5-1-branch:11.4.0.2
	rel-5-1:11.4
	rel-5-0:11.4
	rel-5-0-beta:11.4
	rel-4-5:11.4
	ctj-4-5-post:11.4
	ctj-4-5-pre:11.4
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.12
date	2004.05.21.18.07.34;	author morrison;	state dead;
branches;
next	11.11;

11.11
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.10;

11.10
date	2004.04.05.08.48.58;	author morrison;	state Exp;
branches;
next	11.9;

11.9
date	2004.02.02.17.39.28;	author morrison;	state Exp;
branches;
next	11.8;

11.8
date	2002.08.20.17.08.07;	author jra;	state Exp;
branches
	11.8.2.1
	11.8.4.1
	11.8.10.1;
next	11.7;

11.7
date	2002.08.15.20.55.19;	author hartley;	state Exp;
branches;
next	11.6;

11.6
date	2001.04.20.22.29.54;	author morrison;	state Exp;
branches;
next	11.5;

11.5
date	2000.08.21.02.02.34;	author butler;	state Exp;
branches;
next	11.4;

11.4
date	96.07.10.20.15.50;	author jra;	state Exp;
branches;
next	11.3;

11.3
date	95.12.01.02.49.33;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	95.09.20.13.03.25;	author stay;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.53.50;	author mike;	state Rel4_4;
branches
	11.1.1.1;
next	10.7;

10.7
date	94.11.08.05.09.16;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	94.11.08.02.26.48;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	94.11.05.00.22.03;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	94.08.11.01.14.37;	author gdurf;	state Exp;
branches;
next	10.3;

10.3
date	92.05.29.01.20.05;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	92.05.28.22.12.11;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.39.09;	author mike;	state Rel4_0;
branches;
next	1.2;

1.2
date	91.06.14.09.42.17;	author stay;	state Exp;
branches;
next	1.1;

1.1
date	91.05.18.02.35.40;	author stay;	state Exp;
branches;
next	;

11.1.1.1
date	98.01.29.06.43.38;	author mike;	state Rel4_5;
branches;
next	;

11.8.2.1
date	2002.09.19.18.01.45;	author morrison;	state Exp;
branches;
next	11.8.2.2;

11.8.2.2
date	2004.03.17.21.18.56;	author morrison;	state Exp;
branches;
next	;

11.8.4.1
date	2004.03.11.23.43.44;	author morrison;	state Exp;
branches;
next	;

11.8.10.1
date	2004.02.12.18.37.46;	author erikg;	state Exp;
branches;
next	;


desc
@Plotting
@


11.12
log
@moved to src/
@
text
@/* 	N U R B _ P L O T . C
 *
 *  Function -
 *	Utilities for spline debuging
 *
 *  Author -
 *	Paul Randal Stay
 *
 *
 *  Source -
 * 	SECAD/VLD Computing Consortium, Bldg 394
 *	The U.S. Army Ballistic Research Laboratory
 * 	Aberdeen Proving Ground, Maryland 21005
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1986-2004 by the United States Army.
 *	All rights reserved.
 */

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <sys/types.h>
#include <fcntl.h>

#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "nurb.h"
#include "plot3.h"

/*
 *			R T _ N U R B _ P L O T _ S N U R B
 */
void
rt_nurb_plot_snurb(FILE *fp, const struct face_g_snurb *srf)
{
	int i,j;
	const fastf_t * m_ptr = srf->ctl_points;
	int evp = RT_NURB_EXTRACT_COORDS( srf->pt_type);
	int rat = RT_NURB_IS_PT_RATIONAL( srf->pt_type);
	point_t pt;

	NMG_CK_SNURB(srf);

	for( i = 0; i < srf->s_size[0]; i++)
	{
		for( j = 0; j < srf->s_size[1]; j++)
		{
                       if ( rat )
                        {
                                pt[0] = m_ptr[0]/ m_ptr[3];
                                pt[1] = m_ptr[1]/ m_ptr[3];
                                pt[2] = m_ptr[2]/ m_ptr[3];
                        } else
                        {
                                pt[0] = m_ptr[0];
                                pt[1] = m_ptr[1];
                                pt[2] = m_ptr[2];

                        }

			if( j == 0)
			{
				pdv_3move( fp, pt );
			} else
				pdv_3cont( fp, pt );

			m_ptr += evp;
		}
	}

	for( j = 0; j < srf->s_size[1]; j++)
	{
		int stride;
		stride = srf->s_size[1] * evp;
		m_ptr = &srf->ctl_points[j * evp];
		for( i = 0; i < srf->s_size[0]; i++)
		{
                        if ( rat )
                        {
                                pt[0] = m_ptr[0]/ m_ptr[3];
                                pt[1] = m_ptr[1]/ m_ptr[3];
                                pt[2] = m_ptr[2]/ m_ptr[3];
                        } else
                        {
                                pt[0] = m_ptr[0];
                                pt[1] = m_ptr[1];
                                pt[2] = m_ptr[2];

                        }


			if( i == 0)
				pdv_3move( fp, pt );
			else
				pdv_3cont( fp, pt );

			m_ptr += stride;
		}
	}
}

/*
 *			R T _ N U R B _ P L O T _ C N U R B
 */
void
rt_nurb_plot_cnurb(FILE *fp, const struct edge_g_cnurb *crv)
{
	register int	i, k;
	const fastf_t * m_ptr = crv->ctl_points;
	int evp = RT_NURB_EXTRACT_COORDS( crv->pt_type);
	int rat = RT_NURB_IS_PT_RATIONAL( crv->pt_type);
	point_t ptr;

	for( i = 0; i < crv->c_size; i++)  {
		if( rat )
		{
			for(k = 0; k < evp; k++)
				ptr[k] = m_ptr[k] / m_ptr[evp-1];

		} else
		{
			for(k = 0; k < evp; k++)
				ptr[k] = m_ptr[k];

		}
		if( i == 0 )
			pdv_3move( fp, ptr );
		else
			pdv_3cont( fp, ptr );
		m_ptr += evp;
	}
}

/* Old routines included for backwards compat.  Don't use in new code. */
void rt_nurb_setfile(int n)
{
	pl_color(stdout, n * 25 % 255, n * 50 % 255, n * 75 %255);
}

void
rt_nurb_closefile(void)
{
}

void rt_nurb_s_plot(const struct face_g_snurb *srf)
{
	rt_nurb_plot_snurb( stdout, srf );
}
@


11.11
log
@change conf.h to a wrapped config.h
@
text
@@


11.10
log
@merge of ansi-6-0-branch into HEAD
@
text
@d20 5
a24 1
#include "conf.h"
@


11.9
log
@update copyright to include span through 2003
@
text
@d36 1
a36 3
rt_nurb_plot_snurb( fp, srf )
FILE	*fp;
const struct face_g_snurb	*srf;
d108 1
a108 3
rt_nurb_plot_cnurb( fp, crv )
FILE	*fp;
const struct edge_g_cnurb	*crv;
d137 1
a137 2
void rt_nurb_setfile(n)
int n;
d143 1
a143 1
rt_nurb_closefile()
d147 1
a147 2
void rt_nurb_s_plot( srf )
const struct face_g_snurb * srf;
@


11.8
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1986 by the United States Army.
@


11.8.4.1
log
@sync to HEAD...
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
@


11.8.10.1
log
@merge from HEAD
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
@


11.8.2.1
log
@Initial ANSIfication
@
text
@d36 3
a38 1
rt_nurb_plot_snurb(FILE *fp, const struct face_g_snurb *srf)
d110 3
a112 1
rt_nurb_plot_cnurb(FILE *fp, const struct edge_g_cnurb *crv)
d141 2
a142 1
void rt_nurb_setfile(int n)
d148 1
a148 1
rt_nurb_closefile(void)
d152 2
a153 1
void rt_nurb_s_plot(const struct face_g_snurb *srf)
@


11.8.2.2
log
@sync branch with HEAD
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
@


11.7
log
@Converted from K&R to ANSI C - RFH
@
text
@d36 3
a38 1
rt_nurb_plot_snurb(FILE *fp, const struct face_g_snurb *srf)
d110 3
a112 1
rt_nurb_plot_cnurb(FILE *fp, const struct edge_g_cnurb *crv)
d141 2
a142 1
void rt_nurb_setfile(int n)
d148 1
a148 1
rt_nurb_closefile(void)
d152 2
a153 1
void rt_nurb_s_plot(const struct face_g_snurb *srf)
@


11.6
log
@CONST to const
@
text
@d36 1
a36 3
rt_nurb_plot_snurb( fp, srf )
FILE	*fp;
const struct face_g_snurb	*srf;
d108 1
a108 3
rt_nurb_plot_cnurb( fp, crv )
FILE	*fp;
const struct edge_g_cnurb	*crv;
d137 1
a137 2
void rt_nurb_setfile(n)
int n;
d143 1
a143 1
rt_nurb_closefile()
d147 1
a147 2
void rt_nurb_s_plot( srf )
const struct face_g_snurb * srf;
@


11.5
log
@Massive compilation warnings eliminated
@
text
@d38 1
a38 1
CONST struct face_g_snurb	*srf;
d41 1
a41 1
	CONST fastf_t * m_ptr = srf->ctl_points;
d112 1
a112 1
CONST struct edge_g_cnurb	*crv;
d115 1
a115 1
	CONST fastf_t * m_ptr = crv->ctl_points;
d153 1
a153 1
CONST struct face_g_snurb * srf;
@


11.4
log
@Fixed declaration problems for IRIX 6.2
@
text
@d30 1
@


11.3
log
@LIBNURB data structures have been fully merged withNMG data structures.
@
text
@d146 1
@


11.2
log
@*** empty log message ***
@
text
@d37 1
a37 1
CONST struct snurb	*srf;
d111 1
a111 1
CONST struct cnurb	*crv;
d151 1
a151 1
CONST struct snurb * srf;
@


11.1
log
@Release_4.4
@
text
@d42 2
d51 13
d66 1
a66 1
				pdv_3move( fp, m_ptr );
d68 1
a68 1
				pdv_3cont( fp, m_ptr );
d81 14
d96 1
a96 1
				pdv_3move( fp, m_ptr );
d98 1
a98 1
				pdv_3cont( fp, m_ptr );
d113 1
a113 1
	register int	i;
d116 2
d120 11
d132 1
a132 1
			pdv_3move( fp, m_ptr );
d134 1
a134 1
			pdv_3cont( fp, m_ptr );
@


11.1.1.1
log
@Release_4.5
@
text
@d37 1
a37 1
CONST struct face_g_snurb	*srf;
a41 2
	int rat = RT_NURB_IS_PT_RATIONAL( srf->pt_type);
	point_t pt;
a48 13
                       if ( rat )
                        {
                                pt[0] = m_ptr[0]/ m_ptr[3];
                                pt[1] = m_ptr[1]/ m_ptr[3];
                                pt[2] = m_ptr[2]/ m_ptr[3];
                        } else
                        {
                                pt[0] = m_ptr[0];
                                pt[1] = m_ptr[1];
                                pt[2] = m_ptr[2];

                        }

d51 1
a51 1
				pdv_3move( fp, pt );
d53 1
a53 1
				pdv_3cont( fp, pt );
a65 14
                        if ( rat )
                        {
                                pt[0] = m_ptr[0]/ m_ptr[3];
                                pt[1] = m_ptr[1]/ m_ptr[3];
                                pt[2] = m_ptr[2]/ m_ptr[3];
                        } else
                        {
                                pt[0] = m_ptr[0];
                                pt[1] = m_ptr[1];
                                pt[2] = m_ptr[2];

                        }


d67 1
a67 1
				pdv_3move( fp, pt );
d69 1
a69 1
				pdv_3cont( fp, pt );
d82 1
a82 1
CONST struct edge_g_cnurb	*crv;
d84 1
a84 1
	register int	i, k;
a86 2
	int rat = RT_NURB_IS_PT_RATIONAL( crv->pt_type);
	point_t ptr;
a88 11
		if( rat )
		{
			for(k = 0; k < evp; k++)
				ptr[k] = m_ptr[k] / m_ptr[evp-1];

		} else
		{
			for(k = 0; k < evp; k++)
				ptr[k] = m_ptr[k];

		}
d90 1
a90 1
			pdv_3move( fp, ptr );
d92 1
a92 1
			pdv_3cont( fp, ptr );
a103 1
void
d109 1
a109 1
CONST struct face_g_snurb * srf;
@


10.7
log
@Reorg to get types right.
@
text
@@


10.6
log
@Added routine to draw curves, too.
@
text
@d31 3
a33 17
void rt_nurb_setfile(n)
int n;
{
	pl_color(stdout, n * 25 % 255, n * 50 % 255, n * 75 %255);
}

rt_nurb_closefile()
{

}

void rt_nurb_s_plot( srf )
CONST struct snurb * srf;
{
	rt_nurb_plot_snurb( stdout, srf );
}

d76 3
d95 17
@


10.5
log
@Irix 6
@
text
@d43 1
a43 1
struct snurb * srf;
d45 8
d54 1
a54 1
	fastf_t * m_ptr = srf->ctl_points;
d57 2
d65 1
a65 1
				pd_3move( stdout, m_ptr[0], m_ptr[1], m_ptr[2]);
d67 2
a68 2
				pd_3cont( stdout, m_ptr[0], m_ptr[1], m_ptr[2]);
			
d81 1
a81 1
				pd_3move( stdout, m_ptr[0], m_ptr[1], m_ptr[2]);
d83 1
a83 1
				pd_3cont( stdout, m_ptr[0], m_ptr[1], m_ptr[2]);
d87 18
@


10.4
log
@Added includes
@
text
@d45 1
a45 1
	int i,j,k;
@


10.3
log
@Control polygon/mesh is now just part of the cnurb/snurb structures,
rather than being a separate structure of their own.
@
text
@d20 2
d28 1
@


10.2
log
@Expanded names of manifest constants
@
text
@a27 2
static FILE * plotfile;

d39 1
a39 1
void rt_nurb_s_plot( srf)
a41 7

	rt_nurb_m_plot( srf->mesh);
}

rt_nurb_m_plot( m )
struct s_mesh * m;
{
d43 2
a44 2
	fastf_t * m_ptr = m->ctl_points;
	int evp = RT_NURB_EXTRACT_COORDS( m->pt_type);
d46 1
a46 1
	for( i = 0; i < m->s_size[0]; i++)
d48 1
a48 1
		for( j = 0; j < m->s_size[1]; j++)
d60 1
a60 1
	for( j = 0; j < m->s_size[1]; j++)
d63 3
a65 3
		stride = m->s_size[1] * evp;
		m_ptr = &m->ctl_points[j * evp];
		for( i = 0; i < m->s_size[0]; i++)
@


10.1
log
@Release_4.0
@
text
@d53 1
a53 1
	int evp = EXTRACT_COORDS( m->pt_type);
@


1.2
log
@fixed nurb.h
@
text
@@


1.1
log
@Initial revision
@
text
@d26 1
a26 1
#include "./nurb.h"
@
