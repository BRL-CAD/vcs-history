head	11.32;
access;
symbols
	ansi-20040405-merged:11.28.2.2
	postmerge-20040405-ansi:11.30
	premerge-20040404-ansi:11.29
	postmerge-autoconf:11.29
	autoconf-freeze:11.28.10.2
	premerge-autoconf:11.29
	ansi-20040316-freeze:11.28.2.1
	postmerge-20040315-windows:11.29
	premerge-20040315-windows:11.29
	windows-20040315-freeze:11.28.4.1
	autoconf-20031203:11.28
	autoconf-20031202:11.28
	autoconf-branch:11.28.0.10
	phong-branch:11.28.0.8
	photonmap-branch:11.28.0.6
	rel-6-1-DP:11.28
	windows-branch:11.28.0.4
	rel-6-0-2:11.26
	ansi-branch:11.28.0.2
	rel-6-0-1-branch:11.26.0.2
	hartley-6-0-post:11.27
	hartley-6-0-pre:11.26
	rel-6-0-1:11.26
	rel-6-0:11.26
	rel-5-4:11.19.2.1
	offsite-5-3-pre:11.24
	rel-5-3:11.19.2.1
	rel-5-2:11.19
	rel-5-1-branch:11.19.0.2
	rel-5-1:11.19
	rel-5-0:11.13
	rel-5-0-beta:11.12
	rel-4-5:11.8
	ctj-4-5-post:11.8
	ctj-4-5-pre:11.8
	rel-4-4:11.1;
locks; strict;
comment	@ * @;


11.32
date	2004.05.21.18.07.35;	author morrison;	state dead;
branches;
next	11.31;

11.31
date	2004.05.10.15.30.47;	author erikg;	state Exp;
branches;
next	11.30;

11.30
date	2004.04.05.08.48.58;	author morrison;	state Exp;
branches;
next	11.29;

11.29
date	2004.02.02.17.39.29;	author morrison;	state Exp;
branches;
next	11.28;

11.28
date	2002.08.20.17.08.10;	author jra;	state Exp;
branches
	11.28.2.1
	11.28.4.1
	11.28.10.1;
next	11.27;

11.27
date	2002.08.15.20.55.22;	author hartley;	state Exp;
branches;
next	11.26;

11.26
date	2001.04.20.22.29.57;	author morrison;	state Exp;
branches;
next	11.25;

11.25
date	2001.03.31.01.57.12;	author morrison;	state Exp;
branches;
next	11.24;

11.24
date	2001.01.22.18.16.49;	author bparker;	state Exp;
branches;
next	11.23;

11.23
date	2000.08.24.03.12.20;	author mike;	state Exp;
branches;
next	11.22;

11.22
date	2000.08.22.21.24.53;	author mike;	state Exp;
branches;
next	11.21;

11.21
date	2000.08.21.02.02.34;	author butler;	state Exp;
branches;
next	11.20;

11.20
date	2000.07.10.23.01.51;	author mike;	state Exp;
branches;
next	11.19;

11.19
date	2000.05.19.02.08.59;	author mike;	state Exp;
branches
	11.19.2.1;
next	11.18;

11.18
date	2000.01.14.23.03.54;	author bparker;	state Exp;
branches;
next	11.17;

11.17
date	99.12.30.15.07.55;	author jra;	state Exp;
branches;
next	11.16;

11.16
date	99.11.24.21.44.30;	author mike;	state Exp;
branches;
next	11.15;

11.15
date	99.11.08.16.43.22;	author bparker;	state Exp;
branches;
next	11.14;

11.14
date	99.10.29.17.22.56;	author bparker;	state Exp;
branches;
next	11.13;

11.13
date	99.08.16.14.39.44;	author bparker;	state Exp;
branches;
next	11.12;

11.12
date	99.05.28.01.07.56;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	99.05.27.21.52.13;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	99.05.27.21.16.38;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	99.01.13.21.46.16;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	97.06.13.21.27.12;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	97.06.13.21.07.22;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	97.06.13.21.05.39;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	96.10.03.00.29.15;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	96.07.11.20.09.49;	author jra;	state Exp;
branches;
next	11.3;

11.3
date	96.07.11.17.20.27;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	95.03.02.17.41.12;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.58.56;	author mike;	state Rel4_4;
branches;
next	1.14;

1.14
date	94.12.29.16.32.43;	author jra;	state Exp;
branches;
next	1.13;

1.13
date	94.12.27.15.14.38;	author jra;	state Exp;
branches;
next	1.12;

1.12
date	94.11.04.06.08.17;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	94.08.27.03.12.24;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	94.08.10.20.22.54;	author gdurf;	state Exp;
branches;
next	1.9;

1.9
date	94.03.18.01.37.56;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	94.03.18.01.30.25;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	94.03.18.01.26.02;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	94.03.18.01.18.09;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	94.03.18.01.10.49;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	94.03.11.20.31.46;	author butler;	state Exp;
branches;
next	1.3;

1.3
date	93.10.28.23.46.55;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	92.10.27.16.29.51;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	92.04.16.23.35.39;	author mike;	state Exp;
branches;
next	;

11.19.2.1
date	2001.01.22.18.20.08;	author bparker;	state Exp;
branches;
next	;

11.28.2.1
date	2002.09.19.18.01.48;	author morrison;	state Exp;
branches;
next	11.28.2.2;

11.28.2.2
date	2004.03.17.21.19.00;	author morrison;	state Exp;
branches;
next	;

11.28.4.1
date	2004.03.11.23.43.47;	author morrison;	state Exp;
branches;
next	;

11.28.10.1
date	2004.02.12.18.37.48;	author erikg;	state Exp;
branches;
next	11.28.10.2;

11.28.10.2
date	2004.03.15.14.07.30;	author erikg;	state Exp;
branches;
next	;


desc
@Routines to convert vlist to/from external binary format
@


11.32
log
@moved to src/
@
text
@/*
 *			V L I S T . C
 *
 *  Routines for the import and export of vlist chains as:
 *	Network independent binary,
 *	BRL-extended UNIX-Plot files.
 *
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1992-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/vlist.c,v 11.31 2004/05/10 15:30:47 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#include <string.h>
#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "bu.h"
#include "bn.h"
#include "raytrace.h"
#include "plot3.h"

/************************************************************************
 *									*
 *			Generic VLBLOCK routines			*
 *									*
 ************************************************************************/

/*
 *			B N _ V L B L O C K _ I N I T
 */
struct bn_vlblock *
bn_vlblock_init(
	struct bu_list	*free_vlist_hd,		/* where to get/put free vlists */
	int		max_ent)
{
	struct bn_vlblock *vbp;
	int	i;

	if (BU_LIST_UNINITIALIZED( free_vlist_hd ))
		BU_LIST_INIT( free_vlist_hd );

	BU_GETSTRUCT( vbp, bn_vlblock );
	vbp->magic = BN_VLBLOCK_MAGIC;
	vbp->free_vlist_hd = free_vlist_hd;
	vbp->max = max_ent;
	vbp->head = (struct bu_list *)bu_calloc( vbp->max,
		sizeof(struct bu_list), "head[]" );
	vbp->rgb = (long *)bu_calloc( vbp->max,
		sizeof(long), "rgb[]" );

	for( i=0; i < vbp->max; i++ )  {
		vbp->rgb[i] = 0;
		BU_LIST_INIT( &(vbp->head[i]) );
	}

	vbp->rgb[0] = 0xFFFF00L;	/* Yellow, default */
	vbp->rgb[1] = 0xFFFFFFL;	/* White */
	vbp->nused = 2;

	return(vbp);
}

/*
 *			R T _ V L B L O C K _ I N I T
 */
struct bn_vlblock *
rt_vlblock_init(void)
{
	return bn_vlblock_init( &rt_g.rtg_vlfree, 32 );
}

/*
 *			R T _ V L B L O C K _ F R E E
 */
void
rt_vlblock_free(struct bn_vlblock *vbp)
{
	int	i;

	BN_CK_VLBLOCK(vbp);
	for( i=0; i < vbp->nused; i++ )  {
		/* Release any remaining vlist storage */
		if( vbp->rgb[i] == 0 )  continue;
		if( BU_LIST_IS_EMPTY( &(vbp->head[i]) ) )  continue;
		BN_FREE_VLIST( vbp->free_vlist_hd, &(vbp->head[i]) );
	}

	bu_free( (char *)(vbp->head), "head[]" );
	bu_free( (char *)(vbp->rgb), "rgb[]" );
	bu_free( (char *)vbp, "bn_vlblock" );
}

/*
 *			R T _ V L B L O C K _ F I N D
 */
struct bu_list *
rt_vlblock_find(struct bn_vlblock *vbp, int r, int g, int b)
{
	long	new;
	int	n;
	int	omax;		/* old max */

	BN_CK_VLBLOCK(vbp);

	new = ((r&0xFF)<<16)|((g&0xFF)<<8)|(b&0xFF);

	for( n=0; n < vbp->nused; n++ )  {
		if( vbp->rgb[n] == new )
			return( &(vbp->head[n]) );
	}
	if( vbp->nused < vbp->max )  {
		/* Allocate empty slot */
		n = vbp->nused++;
		vbp->rgb[n] = new;
		return( &(vbp->head[n]) );
	}

	/************** enlarge the table ****************/
	omax = vbp->max;
	vbp->max *= 2;

	/* Look for empty lists and mark for use below. */
	for (n=0; n < omax; n++)
		if (BU_LIST_IS_EMPTY(&vbp->head[n]))
			vbp->head[n].forw = BU_LIST_NULL;

	vbp->head = (struct bu_list *)bu_realloc((genptr_t)vbp->head,
						 vbp->max * sizeof(struct bu_list),
						 "head[]");
	vbp->rgb = (long *)bu_realloc((genptr_t)vbp->rgb,
				      vbp->max * sizeof(long),
				      "rgb[]");

	/* re-initialize pointers in lower half */
	for (n=0; n < omax; n++) {
		/* 
		 * Check to see if list is empty
		 * (i.e. yellow and/or white are not used).
		 * Note - we can't use BU_LIST_IS_EMPTY here because
		 * the addresses of the list heads have possibly changed.
		 */
		if (vbp->head[n].forw == BU_LIST_NULL) {
			vbp->head[n].forw = &vbp->head[n];
			vbp->head[n].back = &vbp->head[n];
		} else {
			vbp->head[n].forw->back = &vbp->head[n];
			vbp->head[n].back->forw = &vbp->head[n];
		}
	}

	/* initialize upper half of memory */
	for (n=omax; n < vbp->max; n++) {
		vbp->rgb[n] = 0;
		BU_LIST_INIT(&vbp->head[n]);
	}

	/* here we go again */
	return rt_vlblock_find(vbp, r, g, b);
}

/************************************************************************
 *									*
 *			Generic BN_VLIST routines			*
 *									*
 ************************************************************************/
const char *rt_vlist_cmd_descriptions[] = {
	"line move ",
	"line draw ",
	"poly start",
	"poly move ",
	"poly draw ",
	"poly end  ",
	"poly vnorm",
	"**unknown*"
};

/*
 *			R T _ C K _ V L I S T
 *
 *  Validate an bn_vlist chain for having reasonable
 *  values inside.  Calls bu_bomb() if not.
 *
 *  Returns -
 *	npts	Number of point/command sets in use.
 */
int
rt_ck_vlist( const struct bu_list *vhead )
{
	register struct bn_vlist	*vp;
	int			npts = 0;

	for( BU_LIST_FOR( vp, bn_vlist, vhead ) )  {
		register int	i;
		register int	nused = vp->nused;
		register int	*cmd = vp->cmd;
		register point_t *pt = vp->pt;

		BN_CK_VLIST( vp );
		npts += nused;

		for( i = 0; i < nused; i++,cmd++,pt++ )  {
			register int	j;

			for( j=0; j < 3; j++ )  {
				/*
				 *  If (*pt)[j] is an IEEE NaN, then all comparisons
				 *  between it and any genuine number will return
				 *  FALSE.  This test is formulated so that NaN
				 *  values will activate the "else" clause.
				 */
				if( (*pt)[j] > -INFINITY && (*pt)[j] < INFINITY )  {
					/* Number is good */
				} else {
					bu_log("  %s (%g, %g, %g)\n",
						rt_vlist_cmd_descriptions[*cmd],
						V3ARGS( *pt ) );
					bu_bomb("rt_ck_vlist() bad coordinate value\n");
				}
				/* XXX Need a define for largest command number */
				if( *cmd < 0 || *cmd > BN_VLIST_POLY_VERTNORM )  {
					bu_log("cmd = x%x (%d.)\n", *cmd, *cmd);
					bu_bomb("rt_ck_vlist() bad vlist command\n");
				}
			}
		}
	}
	return npts;
}

/*
 *			R T _ V L I S T _ C O P Y
 *
 *  Duplicate the contents of a vlist.  Note that the copy may be more
 *  densely packed than the source.
 */
void
rt_vlist_copy( struct bu_list *dest, const struct bu_list *src )
{
	struct bn_vlist	*vp;

	for( BU_LIST_FOR( vp, bn_vlist, src ) )  {
		register int	i;
		register int	nused = vp->nused;
		register int	*cmd = vp->cmd;
		register point_t *pt = vp->pt;
		for( i = 0; i < nused; i++,cmd++,pt++ )  {
			BN_ADD_VLIST( &rt_g.rtg_vlfree, dest, *pt, *cmd );
		}
	}
}

/*
 *			B N _ V L I S T _ C L E A N U P
 *
 *  The macro RT_FREE_VLIST() simply appends to the list &rt_g.rtg_vlfree.
 *  Now, give those structures back to bu_free().
 */
void
bn_vlist_cleanup( struct bu_list *hd )
{
	register struct bn_vlist	*vp;

	if (BU_LIST_UNINITIALIZED( hd ))  {
		BU_LIST_INIT( hd );
		return;
	}

	while( BU_LIST_WHILE( vp, bn_vlist, hd ) )  {
		BN_CK_VLIST( vp );
		BU_LIST_DEQUEUE( &(vp->l) );
		bu_free( (char *)vp, "bn_vlist" );
	}
}

/*  XXX This needs to remain a LIBRT function. */
void
rt_vlist_cleanup(void)
{
	bn_vlist_cleanup( &rt_g.rtg_vlfree );
}

/*
 *			B N _ V L I S T _ R P P
 *
 *  Given an RPP, draw the outline of it into the vlist.
 */
void
bn_vlist_rpp( struct bu_list *hd, const point_t minn, const point_t maxx )
{
	point_t	p;

	VSET( p, minn[X], minn[Y], minn[Z] );
	BN_ADD_VLIST( &rt_g.rtg_vlfree, hd, p, BN_VLIST_LINE_MOVE )

	/* first side */
	VSET( p, minn[X], maxx[Y], minn[Z] );
	BN_ADD_VLIST( &rt_g.rtg_vlfree, hd, p, BN_VLIST_LINE_DRAW )
	VSET( p, minn[X], maxx[Y], maxx[Z] );
	BN_ADD_VLIST( &rt_g.rtg_vlfree, hd, p, BN_VLIST_LINE_DRAW )
	VSET( p, minn[X], minn[Y], maxx[Z] );
	BN_ADD_VLIST( &rt_g.rtg_vlfree, hd, p, BN_VLIST_LINE_DRAW )
	VSET( p, minn[X], minn[Y], minn[Z] );
	BN_ADD_VLIST( &rt_g.rtg_vlfree, hd, p, BN_VLIST_LINE_DRAW )

	/* across */
	VSET( p, maxx[X], minn[Y], minn[Z] );
	BN_ADD_VLIST( &rt_g.rtg_vlfree, hd, p, BN_VLIST_LINE_DRAW )

	/* second side */
	VSET( p, maxx[X], maxx[Y], minn[Z] );
	BN_ADD_VLIST( &rt_g.rtg_vlfree, hd, p, BN_VLIST_LINE_DRAW )
	VSET( p, maxx[X], maxx[Y], maxx[Z] );
	BN_ADD_VLIST( &rt_g.rtg_vlfree, hd, p, BN_VLIST_LINE_DRAW )
	VSET( p, maxx[X], minn[Y], maxx[Z] );
	BN_ADD_VLIST( &rt_g.rtg_vlfree, hd, p, BN_VLIST_LINE_DRAW )
	VSET( p, maxx[X], minn[Y], minn[Z] );
	BN_ADD_VLIST( &rt_g.rtg_vlfree, hd, p, BN_VLIST_LINE_DRAW )

	/* front edge */
	VSET( p, minn[X], maxx[Y], minn[Z] );
	BN_ADD_VLIST( &rt_g.rtg_vlfree, hd, p, BN_VLIST_LINE_MOVE )
	VSET( p, maxx[X], maxx[Y], minn[Z] );
	BN_ADD_VLIST( &rt_g.rtg_vlfree, hd, p, BN_VLIST_LINE_DRAW )

	/* bottom back */
	VSET( p, minn[X], minn[Y], maxx[Z] );
	BN_ADD_VLIST( &rt_g.rtg_vlfree, hd, p, BN_VLIST_LINE_MOVE )
	VSET( p, maxx[X], minn[Y], maxx[Z] );
	BN_ADD_VLIST( &rt_g.rtg_vlfree, hd, p, BN_VLIST_LINE_DRAW )

	/* top back */
	VSET( p, minn[X], maxx[Y], maxx[Z] );
	BN_ADD_VLIST( &rt_g.rtg_vlfree, hd, p, BN_VLIST_LINE_MOVE )
	VSET( p, maxx[X], maxx[Y], maxx[Z] );
	BN_ADD_VLIST( &rt_g.rtg_vlfree, hd, p, BN_VLIST_LINE_DRAW )
}

/************************************************************************
 *									*
 *			Binary VLIST import/export routines		*
 *									*
 ************************************************************************/

/*
 *			R T _ V L I S T _ E X P O R T
 *
 *  Convert a vlist chain into a blob of network-independent binary,
 *  for transmission to another machine.
 *  The result is stored in a vls string, so that both the address
 *  and length are available conveniently.
 */
void
rt_vlist_export(struct bu_vls *vls, struct bu_list *hp, const char *name)
{
	register struct bn_vlist	*vp;
	int		nelem;
	int		namelen;
	int		nbytes;
	unsigned char	*buf;
	unsigned char	*bp;

	BU_CK_VLS(vls);

	/* Count number of element in the vlist */
	nelem = 0;
	for( BU_LIST_FOR( vp, bn_vlist, hp ) )  {
		nelem += vp->nused;
	}

	/* Build output buffer for binary transmission
	 * nelem[4], String[n+1], cmds[nelem*1], pts[3*nelem*8]
	 */
	namelen = strlen(name)+1;
	nbytes = namelen + 4 + nelem * (1+3*8) + 2;

	bu_vls_setlen( vls, nbytes );
	buf = (unsigned char *)bu_vls_addr(vls);
	bp = bu_plong( buf, nelem );
	strncpy( (char *)bp, name, namelen );
	bp += namelen;

	/* Output cmds, as bytes */
	for( BU_LIST_FOR( vp, bn_vlist, hp ) )  {
		register int	i;
		register int	nused = vp->nused;
		register int	*cmd = vp->cmd;
		for( i = 0; i < nused; i++ )  {
			*bp++ = *cmd++;
		}
	}

	/* Output points, as three 8-byte doubles */
	for( BU_LIST_FOR( vp, bn_vlist, hp ) )  {
		register int	i;
		register int	nused = vp->nused;
		register point_t *pt = vp->pt;
		for( i = 0; i < nused; i++,pt++ )  {
			htond( bp, (unsigned char *)pt, 3 );
			bp += 3*8;
		}
	}
}

/*
 *			R T _ V L I S T _ I M P O R T
 *
 *  Convert a blob of network-independent binary prepared by vls_vlist()
 *  and received from another machine, into a vlist chain.
 */
void
rt_vlist_import(struct bu_list *hp, struct bu_vls *namevls, const unsigned char *buf)
{
	register const unsigned char	*bp;
	const unsigned char		*pp;		/* point pointer */
	int		nelem;
	int		namelen;
	int		i;
	point_t		point;

	BU_CK_VLS(namevls);

	nelem = bu_glong( buf );
	bp = buf+4;

	namelen = strlen((char *)bp)+1;
	bu_vls_strncpy( namevls, (char *)bp, namelen );
	bp += namelen;

	pp = bp + nelem*1;

	for( i=0; i < nelem; i++ )  {
		int	cmd;

		cmd = *bp++;
		ntohd( (unsigned char *)point, pp, 3 );
		pp += 3*8;
		BN_ADD_VLIST( &rt_g.rtg_vlfree, hp, point, cmd );
	}
}

/************************************************************************
 *									*
 *			UNIX-Plot VLIST import/export routines		*
 *									*
 ************************************************************************/

/*
 *			R T _ P L O T _ V L B L O C K
 *
 *  Output a bn_vlblock object in extended UNIX-plot format,
 *  including color.
 */
void
rt_plot_vlblock(FILE *fp, const struct bn_vlblock *vbp)
{
	int	i;

	BN_CK_VLBLOCK(vbp);

	for( i=0; i < vbp->nused; i++ )  {
		if( vbp->rgb[i] == 0 )  continue;
		if( BU_LIST_IS_EMPTY( &(vbp->head[i]) ) )  continue;
		pl_color( fp,
			(vbp->rgb[i]>>16) & 0xFF,
			(vbp->rgb[i]>> 8) & 0xFF,
			(vbp->rgb[i]    ) & 0xFF );
		rt_vlist_to_uplot( fp, &(vbp->head[i]) );
	}
}

/*
 *			R T _ V L I S T _ T O _ U P L O T
 *
 *  Output a vlist as an extended 3-D floating point UNIX-Plot file.
 *  You provide the file.
 *  Uses libplot3 routines to create the UNIX-Plot output.
 */
void
rt_vlist_to_uplot(FILE *fp, const struct bu_list *vhead)
{
	register struct bn_vlist	*vp;

	for( BU_LIST_FOR( vp, bn_vlist, vhead ) )  {
		register int		i;
		register int		nused = vp->nused;
		register const int	*cmd = vp->cmd;
		register point_t	 *pt = vp->pt;

		for( i = 0; i < nused; i++,cmd++,pt++ )  {
			switch( *cmd )  {
			case BN_VLIST_POLY_START:
				break;
			case BN_VLIST_POLY_MOVE:
			case BN_VLIST_LINE_MOVE:
				pdv_3move( fp, *pt );
				break;
			case BN_VLIST_POLY_DRAW:
			case BN_VLIST_POLY_END:
			case BN_VLIST_LINE_DRAW:
				pdv_3cont( fp, *pt );
				break;
			default:
				bu_log("rt_vlist_to_uplot: unknown vlist cmd x%x\n",
					*cmd );
			}
		}
	}
}


#define	TBAD	0	/* no such command */
#define TNONE	1	/* no arguments */
#define TSHORT	2	/* Vax 16-bit short */
#define	TIEEE	3	/* IEEE 64-bit floating */
#define	TCHAR	4	/* unsigned chars */
#define	TSTRING	5	/* linefeed terminated string */

struct uplot {
	int	targ;		/* type of args */
	int	narg;		/* number or args */
	char	desc[14];	/* description */
};
static const struct uplot rt_uplot_error = { 0, 0, "error" };
static const struct uplot rt_uplot_letters[] = {
/*A*/	{ 0, 0, "" },
/*B*/	{ 0, 0, "" },
/*C*/	{ TCHAR, 3, "color" },
/*D*/	{ 0, 0, "" },
/*E*/	{ 0, 0, "" },
/*F*/	{ TNONE, 0, "flush" },
/*G*/	{ 0, 0, "" },
/*H*/	{ 0, 0, "" },
/*I*/	{ 0, 0, "" },
/*J*/	{ 0, 0, "" },
/*K*/	{ 0, 0, "" },
/*L*/	{ TSHORT, 6, "3line" },
/*M*/	{ TSHORT, 3, "3move" },
/*N*/	{ TSHORT, 3, "3cont" },
/*O*/	{ TIEEE, 3, "d_3move" },
/*P*/	{ TSHORT, 3, "3point" },
/*Q*/	{ TIEEE, 3, "d_3cont" },
/*R*/	{ 0, 0, "" },
/*S*/	{ TSHORT, 6, "3space" },
/*T*/	{ 0, 0, "" },
/*U*/	{ 0, 0, "" },
/*V*/	{ TIEEE, 6, "d_3line" },
/*W*/	{ TIEEE, 6, "d_3space" },
/*X*/	{ TIEEE, 3, "d_3point" },
/*Y*/	{ 0, 0, "" },
/*Z*/	{ 0, 0, "" },
/*[*/	{ 0, 0, "" },
/*\*/	{ 0, 0, "" },
/*]*/	{ 0, 0, "" },
/*^*/	{ 0, 0, "" },
/*_*/	{ 0, 0, "" },
/*`*/	{ 0, 0, "" },
/*a*/	{ TSHORT, 6, "arc" },
/*b*/	{ 0, 0, "" },
/*c*/	{ TSHORT, 3, "circle" },
/*d*/	{ 0, 0, "" },
/*e*/	{ TNONE, 0, "erase" },
/*f*/	{ TSTRING, 1, "linmod" },
/*g*/	{ 0, 0, "" },
/*h*/	{ 0, 0, "" },
/*i*/	{ TIEEE, 3, "d_circle" },
/*j*/	{ 0, 0, "" },
/*k*/	{ 0, 0, "" },
/*l*/	{ TSHORT, 4, "line" },
/*m*/	{ TSHORT, 2, "move" },
/*n*/	{ TSHORT, 2, "cont" },
/*o*/	{ TIEEE, 2, "d_move" },
/*p*/	{ TSHORT, 2, "point" },
/*q*/	{ TIEEE, 2, "d_cont" },
/*r*/	{ TIEEE, 6, "d_arc" },
/*s*/	{ TSHORT, 4, "space" },
/*t*/	{ TSTRING, 1, "label" },
/*u*/	{ 0, 0, "" },
/*v*/	{ TIEEE, 4, "d_line" },
/*w*/	{ TIEEE, 4, "d_space" },
/*x*/	{ TIEEE, 2, "d_point" },
/*y*/	{ 0, 0, "" },
/*z*/	{ 0, 0, "" }
};

/*
 *	getshort		Read VAX-order 16-bit number
 */
static int
getshort(FILE *fp)
{
	register long	v, w;

	v = getc(fp);
	v |= (getc(fp)<<8);	/* order is important! */

	/* worry about sign extension - sigh */
	if( v <= 0x7FFF )  return(v);
	w = -1;
	w &= ~0x7FFF;
	return( w | v );
}

static void
rt_uplot_get_args(FILE *fp, const struct uplot *up, char *carg, fastf_t *arg)
{
	int	i, j;
	int	cc;
	char	inbuf[8];

	for( i = 0; i < up->narg; i++ ) {
	switch( up->targ ){
		case TSHORT:
			arg[i] = getshort( fp );
			break;
		case TIEEE:
			fread( inbuf, 8, 1, fp );
			ntohd( (unsigned char *)&arg[i],
			       (unsigned char *)inbuf, 1 );
	       		break;
		case TSTRING:
			j = 0;
			while( (cc = getc(fp)) != '\n'
			    && cc != EOF )
				carg[j++] = cc;
			carg[j] = '\0';
			break;
		case TCHAR:
			carg[i] = getc(fp);
			arg[i] = 0;
			break;
		case TNONE:
		default:
			arg[i] = 0;	/* ? */
			break;
		}
	}
}

int
rt_process_uplot_value(register struct bu_list **vhead, struct bn_vlblock *vbp, FILE *fp, register int c, double char_size)
                       	        
                 	     
    			    
            		  		/* the value to process */
      			          
{
	mat_t			mat;
	const struct uplot	*up;
	char			carg[256];
	fastf_t			arg[6];
	vect_t			a,b;
	point_t			last_pos;
	static point_t		lpnt;		/* last point of a move/draw series */
	static int		moved = 0;	/* moved since color change */

	/* look it up */
	if( c < 'A' || c > 'z' ) {
		up = &rt_uplot_error;
	} else {
		up = &rt_uplot_letters[ c - 'A' ];
	}

	if( up->targ == TBAD ) {
		fprintf( stderr, "Bad command '%c' (0x%02x)\n", c, c );
		return(-1);
	}

	if( up->narg > 0 )  {
		rt_uplot_get_args( fp, up, carg, arg );
	}

	switch( c ) {
	case 's':
	case 'w':
	case 'S':
	case 'W':
		/* Space commands, do nothing. */
		break;
	case 'm':
	case 'o':
		/* 2-D move */
		arg[Z] = 0;
		BN_ADD_VLIST( vbp->free_vlist_hd, *vhead, arg, BN_VLIST_LINE_MOVE );
		VMOVE(lpnt, arg);
		moved = 1;
		break;
	case 'M':
	case 'O':
		/* 3-D move */
		BN_ADD_VLIST( vbp->free_vlist_hd, *vhead, arg, BN_VLIST_LINE_MOVE );
		VMOVE(lpnt, arg);
		moved = 1;
		break;
	case 'n':
	case 'q':
		/*
		 * If no move command was issued since the last color change,
		 * insert one now using the last point from a move/draw.
		 */
		if (!moved) {
			BN_ADD_VLIST( vbp->free_vlist_hd, *vhead, lpnt, BN_VLIST_LINE_MOVE );
			moved = 1;
		}

		/* 2-D draw */
		arg[Z] = 0;
		BN_ADD_VLIST( vbp->free_vlist_hd, *vhead, arg, BN_VLIST_LINE_DRAW );
		VMOVE(lpnt, arg);
		break;
	case 'N':
	case 'Q':
		/*
		 * If no move command was issued since the last color change,
		 * insert one now using the last point from a move/draw.
		 */
		if (!moved) {
			BN_ADD_VLIST( vbp->free_vlist_hd, *vhead, lpnt, BN_VLIST_LINE_MOVE );
			moved = 1;
		}

		/* 3-D draw */
		BN_ADD_VLIST( vbp->free_vlist_hd, *vhead, arg, BN_VLIST_LINE_DRAW );
		VMOVE(lpnt, arg);
		break;
	case 'l':
	case 'v':
		/* 2-D line */
		VSET( a, arg[0], arg[1], 0.0 );
		VSET( b, arg[2], arg[3], 0.0 );
		BN_ADD_VLIST( vbp->free_vlist_hd, *vhead, a, BN_VLIST_LINE_MOVE );
		BN_ADD_VLIST( vbp->free_vlist_hd, *vhead, b, BN_VLIST_LINE_DRAW );
		break;
	case 'L':
	case 'V':
		/* 3-D line */
		VSET( a, arg[0], arg[1], arg[2] );
		VSET( b, arg[3], arg[4], arg[5] );
		BN_ADD_VLIST( vbp->free_vlist_hd, *vhead, a, BN_VLIST_LINE_MOVE );
		BN_ADD_VLIST( vbp->free_vlist_hd, *vhead, b, BN_VLIST_LINE_DRAW );
		break;
	case 'p':
	case 'x':
		/* 2-D point */
		arg[Z] = 0;
		BN_ADD_VLIST( vbp->free_vlist_hd, *vhead, arg, BN_VLIST_LINE_MOVE );
		BN_ADD_VLIST( vbp->free_vlist_hd, *vhead, arg, BN_VLIST_LINE_DRAW );
		break;
	case 'P':
	case 'X':
		/* 3-D point */
		BN_ADD_VLIST( vbp->free_vlist_hd, *vhead, arg, BN_VLIST_LINE_MOVE );
		BN_ADD_VLIST( vbp->free_vlist_hd, *vhead, arg, BN_VLIST_LINE_DRAW );
		break;
	case 'C':
		/* Color */
		*vhead = rt_vlblock_find( vbp,
			carg[0], carg[1], carg[2] );
		moved = 0;
		break;
	case 't':
		/* Text string */
		MAT_IDN(mat);
		if( BU_LIST_NON_EMPTY( *vhead ) )  {
			struct bn_vlist *vlp;
			/* Use coordinates of last op */
			vlp = BU_LIST_LAST( bn_vlist, *vhead );
			VMOVE( last_pos, vlp->pt[vlp->nused-1] );
		} else {
			VSETALL( last_pos, 0 );
		}
		bn_vlist_3string( *vhead, vbp->free_vlist_hd, carg, last_pos, mat, char_size );
		break;
	}

	return(0);
}

/*
 *			R T _ U P L O T _ T O _ V L I S T
 *
 *  Read a BRL-style 3-D UNIX-plot file into a vector list.
 *  For now, discard color information, only extract vectors.
 *  This might be more naturally located in mged/plot.c
 */
int
rt_uplot_to_vlist(struct bn_vlblock *vbp, register FILE *fp, double char_size)
{
	struct bu_list	*vhead;
	register int	c;

	vhead = rt_vlblock_find( vbp, 0xFF, 0xFF, 0x00 );	/* Yellow */

	while( (c = getc(fp)) != EOF ) {
	       int ret;

	       /* pass the address of vhead so it can be updated */
	       ret = rt_process_uplot_value( &vhead,
					     vbp,
					     fp,
					     c,
					     char_size );
	       if ( ret )
		  return(ret);
	}

	return(0);
}

/*
 *			R T _ L A B E L _ V L I S T _ V E R T S
 *
 *  Used by MGED's "labelvert" command.
 */
void
rt_label_vlist_verts(struct bn_vlblock *vbp, struct bu_list *src, fastf_t *mat, double sz, double mm2local)
{
	struct bn_vlist	*vp;
	struct bu_list	*vhead;
	char		label[256];

	vhead = rt_vlblock_find( vbp, 255, 255, 255 );	/* white */

	for( BU_LIST_FOR( vp, bn_vlist, src ) )  {
		register int	i;
		register int	nused = vp->nused;
		register int	*cmd = vp->cmd;
		register point_t *pt = vp->pt;
		for( i = 0; i < nused; i++,cmd++,pt++ )  {
			/* XXX Skip polygon markers? */
			sprintf( label, " %g, %g, %g",
				(*pt)[0]*mm2local, (*pt)[1]*mm2local, (*pt)[2]*mm2local );
			bn_vlist_3string( vhead, vbp->free_vlist_hd, label, (*pt), mat, sz );
		}
	}
}
@


11.31
log
@change conf.h to a wrapped config.h
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/librt/vlist.c,v 11.30 2004/04/05 08:48:58 morrison Exp $ (BRL)";
@


11.30
log
@merge of ansi-6-0-branch into HEAD
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d24 5
a28 1
#include "conf.h"
@


11.29
log
@update copyright to include span through 2003
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/vlist.c,v 11.28 2002/08/20 17:08:10 jra Exp $ (BRL)";
d82 1
a82 1
rt_vlblock_init()
d91 1
a91 2
rt_vlblock_free(vbp)
struct bn_vlblock *vbp;
d112 1
a112 3
rt_vlblock_find( vbp, r, g, b )
struct bn_vlblock *vbp;
int	r, g, b;
d292 1
a292 1
rt_vlist_cleanup()
d368 1
a368 4
rt_vlist_export( vls, hp, name )
struct bu_vls	*vls;
struct bu_list	*hp;
const char	*name;
d426 1
a426 4
rt_vlist_import( hp, namevls, buf )
struct bu_list	*hp;
struct bu_vls	*namevls;
const unsigned char	*buf;
d469 1
a469 3
rt_plot_vlblock( fp, vbp )
FILE			*fp;
const struct bn_vlblock	*vbp;
d494 1
a494 3
rt_vlist_to_uplot( fp, vhead )
FILE			*fp;
const struct bu_list	*vhead;
d604 1
a604 2
getshort(fp)
FILE	*fp;
d619 1
a619 5
rt_uplot_get_args( fp, up, carg, arg )
FILE			*fp;
const struct uplot	*up;
char			*carg;
fastf_t			*arg;
d655 6
a660 6
rt_process_uplot_value( vhead, vbp, fp, c, char_size )
register struct bu_list	**vhead;
struct bn_vlblock	*vbp;
FILE			*fp;
register int		c;		/* the value to process */
double			char_size;
d801 1
a801 4
rt_uplot_to_vlist( vbp, fp, char_size )
struct bn_vlblock	*vbp;
register FILE		*fp;
double			char_size;
d830 1
a830 6
rt_label_vlist_verts( vbp, src, mat, sz, mm2local )
struct bn_vlblock	*vbp;
struct bu_list		*src;
mat_t			mat;
double			sz;
double			mm2local;
@


11.28
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1992 by the United States Army.
d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/vlist.c,v 11.26 2001/04/20 22:29:57 morrison Exp $ (BRL)";
@


11.28.4.1
log
@sync to HEAD...
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1992-2004 by the United States Army.
d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/vlist.c,v 11.29 2004/02/02 17:39:29 morrison Exp $ (BRL)";
@


11.28.10.1
log
@merge from HEAD
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1992-2004 by the United States Army.
d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/vlist.c,v 11.29 2004/02/02 17:39:29 morrison Exp $ (BRL)";
@


11.28.10.2
log
@merge from head
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/vlist.c,v 11.28.10.1 2004/02/12 18:37:48 erikg Exp $ (BRL)";
@


11.28.2.1
log
@Initial ANSIfication
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/vlist.c,v 11.28 2002/08/20 17:08:10 jra Exp $ (BRL)";
d82 1
a82 1
rt_vlblock_init(void)
d91 2
a92 1
rt_vlblock_free(struct bn_vlblock *vbp)
d113 3
a115 1
rt_vlblock_find(struct bn_vlblock *vbp, int r, int g, int b)
d295 1
a295 1
rt_vlist_cleanup(void)
d371 4
a374 1
rt_vlist_export(struct bu_vls *vls, struct bu_list *hp, const char *name)
d432 4
a435 1
rt_vlist_import(struct bu_list *hp, struct bu_vls *namevls, const unsigned char *buf)
d478 3
a480 1
rt_plot_vlblock(FILE *fp, const struct bn_vlblock *vbp)
d505 3
a507 1
rt_vlist_to_uplot(FILE *fp, const struct bu_list *vhead)
d617 2
a618 1
getshort(FILE *fp)
d633 5
a637 1
rt_uplot_get_args(FILE *fp, const struct uplot *up, char *carg, fastf_t *arg)
d673 6
a678 6
rt_process_uplot_value(register struct bu_list **vhead, struct bn_vlblock *vbp, FILE *fp, register int c, double char_size)
                       	        
                 	     
    			    
            		  		/* the value to process */
      			          
d819 4
a822 1
rt_uplot_to_vlist(struct bn_vlblock *vbp, register FILE *fp, double char_size)
d851 6
a856 1
rt_label_vlist_verts(struct bn_vlblock *vbp, struct bu_list *src, fastf_t *mat, double sz, double mm2local)
@


11.28.2.2
log
@sync branch with HEAD
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1992-2004 by the United States Army.
d21 1
a21 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.27
log
@Converted from K&R to ANSI C - RFH
@
text
@d82 1
a82 1
rt_vlblock_init(void)
d91 2
a92 1
rt_vlblock_free(struct bn_vlblock *vbp)
d113 3
a115 1
rt_vlblock_find(struct bn_vlblock *vbp, int r, int g, int b)
d295 1
a295 1
rt_vlist_cleanup(void)
d371 4
a374 1
rt_vlist_export(struct bu_vls *vls, struct bu_list *hp, const char *name)
d432 4
a435 1
rt_vlist_import(struct bu_list *hp, struct bu_vls *namevls, const unsigned char *buf)
d478 3
a480 1
rt_plot_vlblock(FILE *fp, const struct bn_vlblock *vbp)
d505 3
a507 1
rt_vlist_to_uplot(FILE *fp, const struct bu_list *vhead)
d617 2
a618 1
getshort(FILE *fp)
d633 5
a637 1
rt_uplot_get_args(FILE *fp, const struct uplot *up, char *carg, fastf_t *arg)
d673 6
a678 6
rt_process_uplot_value(register struct bu_list **vhead, struct bn_vlblock *vbp, FILE *fp, register int c, double char_size)
                       	        
                 	     
    			    
            		  		/* the value to process */
      			          
d819 4
a822 1
rt_uplot_to_vlist(struct bn_vlblock *vbp, register FILE *fp, double char_size)
d851 6
a856 1
rt_label_vlist_verts(struct bn_vlblock *vbp, struct bu_list *src, fastf_t *mat, double sz, double mm2local)
@


11.26
log
@CONST to const
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/vlist.c,v 11.25 2001/03/31 01:57:12 morrison Exp $ (BRL)";
d82 1
a82 1
rt_vlblock_init()
d91 1
a91 2
rt_vlblock_free(vbp)
struct bn_vlblock *vbp;
d112 1
a112 3
rt_vlblock_find( vbp, r, g, b )
struct bn_vlblock *vbp;
int	r, g, b;
d292 1
a292 1
rt_vlist_cleanup()
d368 1
a368 4
rt_vlist_export( vls, hp, name )
struct bu_vls	*vls;
struct bu_list	*hp;
const char	*name;
d426 1
a426 4
rt_vlist_import( hp, namevls, buf )
struct bu_list	*hp;
struct bu_vls	*namevls;
const unsigned char	*buf;
d469 1
a469 3
rt_plot_vlblock( fp, vbp )
FILE			*fp;
const struct bn_vlblock	*vbp;
d494 1
a494 3
rt_vlist_to_uplot( fp, vhead )
FILE			*fp;
const struct bu_list	*vhead;
d604 1
a604 2
getshort(fp)
FILE	*fp;
d619 1
a619 5
rt_uplot_get_args( fp, up, carg, arg )
FILE			*fp;
const struct uplot	*up;
char			*carg;
fastf_t			*arg;
d655 6
a660 6
rt_process_uplot_value( vhead, vbp, fp, c, char_size )
register struct bu_list	**vhead;
struct bn_vlblock	*vbp;
FILE			*fp;
register int		c;		/* the value to process */
double			char_size;
d801 1
a801 4
rt_uplot_to_vlist( vbp, fp, char_size )
struct bn_vlblock	*vbp;
register FILE		*fp;
double			char_size;
d830 1
a830 6
rt_label_vlist_verts( vbp, src, mat, sz, mm2local )
struct bn_vlblock	*vbp;
struct bu_list		*src;
mat_t			mat;
double			sz;
double			mm2local;
@


11.25
log
@Deprecated bn_mat_idn() and bn_mat_zero(), updated calls to h/vmath.h's MAT_IDN() and MAT_ZERO() performance improved macros.
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/vlist.c,v 11.24 2001/01/22 18:16:49 bparker Exp $ (BRL)";
d306 1
a306 1
bn_vlist_rpp( struct bu_list *hd, const point_t minn, CONST point_t maxx )
d374 1
a374 1
CONST char	*name;
d435 1
a435 1
CONST unsigned char	*buf;
d437 2
a438 2
	register CONST unsigned char	*bp;
	CONST unsigned char		*pp;		/* point pointer */
d480 1
a480 1
CONST struct bn_vlblock	*vbp;
d507 1
a507 1
CONST struct bu_list	*vhead;
d514 1
a514 1
		register CONST int	*cmd = vp->cmd;
d551 2
a552 2
static CONST struct uplot rt_uplot_error = { 0, 0, "error" };
static CONST struct uplot rt_uplot_letters[] = {
d635 1
a635 1
CONST struct uplot	*up;
d681 1
a681 1
	CONST struct uplot	*up;
@


11.24
log
@*- mods to insert a "move" command before doing
   a "draw" if the color changed and there has
   been no move since that time.
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/vlist.c,v 11.23 2000/08/24 03:12:20 mike Exp $ (BRL)";
d795 1
a795 1
		bn_mat_idn(mat);
@


11.23
log
@
librt/vlist.c externs
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/vlist.c,v 11.22 2000/08/22 21:24:53 mike Exp $ (BRL)";
d680 1
a680 1
	mat_t	mat;
d682 6
a687 4
	char	carg[256];
	fastf_t	arg[6];
	vect_t	a,b;
	point_t	last_pos;
d717 2
d724 2
d729 9
d741 1
d745 9
d756 1
d791 1
@


11.22
log
@
Lint
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/vlist.c,v 11.21 2000/08/21 02:02:34 butler Exp $ (BRL)";
d47 3
a49 3
bn_vlblock_init( free_vlist_hd, max_ent )
struct bu_list	*free_vlist_hd;		/* where to get/put free vlists */
int		max_ent;
d78 3
d184 1
a184 1
CONST char *rt_vlist_cmd_descriptions[] = {
d205 1
a205 2
rt_ck_vlist( vhead )
CONST struct bu_list	*vhead;
d255 1
a255 3
rt_vlist_copy( dest, src )
struct bu_list	*dest;
CONST struct bu_list	*src;
d277 1
a277 2
bn_vlist_cleanup(hd)
struct bu_list	*hd;
d301 3
d306 1
a306 4
bn_vlist_rpp(hd, minn, maxx)
struct bu_list	*hd;
CONST point_t	minn;
CONST point_t	maxx;
@


11.21
log
@Massive compilation warnings eliminated
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/vlist.c,v 11.20 2000/07/10 23:01:51 mike Exp $ (BRL)";
d554 2
a555 2
/*A*/	{ 0, 0, 0 },
/*B*/	{ 0, 0, 0 },
d557 2
a558 2
/*D*/	{ 0, 0, 0 },
/*E*/	{ 0, 0, 0 },
d560 5
a564 5
/*G*/	{ 0, 0, 0 },
/*H*/	{ 0, 0, 0 },
/*I*/	{ 0, 0, 0 },
/*J*/	{ 0, 0, 0 },
/*K*/	{ 0, 0, 0 },
d571 1
a571 1
/*R*/	{ 0, 0, 0 },
d573 2
a574 2
/*T*/	{ 0, 0, 0 },
/*U*/	{ 0, 0, 0 },
d578 8
a585 8
/*Y*/	{ 0, 0, 0 },
/*Z*/	{ 0, 0, 0 },
/*[*/	{ 0, 0, 0 },
/*\*/	{ 0, 0, 0 },
/*]*/	{ 0, 0, 0 },
/*^*/	{ 0, 0, 0 },
/*_*/	{ 0, 0, 0 },
/*`*/	{ 0, 0, 0 },
d587 1
a587 1
/*b*/	{ 0, 0, 0 },
d589 1
a589 1
/*d*/	{ 0, 0, 0 },
d592 2
a593 2
/*g*/	{ 0, 0, 0 },
/*h*/	{ 0, 0, 0 },
d595 2
a596 2
/*j*/	{ 0, 0, 0 },
/*k*/	{ 0, 0, 0 },
d606 1
a606 1
/*u*/	{ 0, 0, 0 },
d610 2
a611 2
/*y*/	{ 0, 0, 0 },
/*z*/	{ 0, 0, 0 }
@


11.20
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/vlist.c,v 11.19 2000/05/19 02:08:59 mike Exp $ (BRL)";
d28 1
d35 1
@


11.19
log
@
Added bn_vlist_rpp()
(There is no libbn/vlist.c yet, this should move someday)
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/vlist.c,v 11.18 2000/01/14 23:03:54 bparker Exp $ (BRL)";
@


11.19.2.1
log
@*- mods to insert a "move" command before doing
   a "draw" if the color changed and there has
   been no move since that time
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/vlist.c,v 11.19 2000/05/19 02:08:59 mike Exp $ (BRL)";
d679 1
a679 1
	mat_t			mat;
d681 4
a684 6
	char			carg[256];
	fastf_t			arg[6];
	vect_t			a,b;
	point_t			last_pos;
	static point_t		lpnt;		/* last point of a move/draw series */
	static int		moved = 0;	/* moved since color change */
a713 2
		VMOVE(lpnt, arg);
		moved = 1;
a718 2
		VMOVE(lpnt, arg);
		moved = 1;
a721 9
		/*
		 * If no move command was issued since the last color change,
		 * insert one now using the last point from a move/draw.
		 */
		if (!moved) {
			BN_ADD_VLIST( vbp->free_vlist_hd, *vhead, lpnt, BN_VLIST_LINE_MOVE );
			moved = 1;
		}

a724 1
		VMOVE(lpnt, arg);
a727 9
		/*
		 * If no move command was issued since the last color change,
		 * insert one now using the last point from a move/draw.
		 */
		if (!moved) {
			BN_ADD_VLIST( vbp->free_vlist_hd, *vhead, lpnt, BN_VLIST_LINE_MOVE );
			moved = 1;
		}

a729 1
		VMOVE(lpnt, arg);
a763 1
		moved = 0;
@


11.18
log
@*- modified rt_vlblock_find to enlarge the table
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/vlist.c,v 11.17 1999/12/30 15:07:55 jra Exp $ (BRL)";
d297 56
@


11.17
log
@Eliminated an unused variable
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/vlist.c,v 11.16 1999/11/24 21:44:30 mike Exp $ (BRL)";
d65 1
a65 1
		vbp->rgb[i] = 0;	/* black, unused */
d68 1
d114 1
a119 5
#if 0
	/* Map black plots into default color (yellow) */
	if( new == 0 ) return( &(vbp->head[0]) );
#endif

d130 42
a171 5
	/*  RGB does not match any existing entry, and table is full.
	 *  Eventually, enlarge table.
	 *  For now, just default to yellow.
	 */
	return( &(vbp->head[0]) );
@


11.16
log
@
Removed includes of compat header files rtstring.h and rtlist.h
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/vlist.c,v 11.15 1999/11/08 16:43:22 bparker Exp $ (BRL)";
a168 1
	register int		i;
@


11.15
log
@*- modified rt_vlblock_find to use black when
   asking for black.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/vlist.c,v 11.14 1999/10/29 17:22:56 bparker Exp $ (BRL)";
a30 1
#include "rtlist.h"
@


11.14
log
@*- pass the address of vhead to rt_process_uplot_value()
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/vlist.c,v 11.13 1999/08/16 14:39:44 bparker Exp $ (BRL)";
d119 1
d122 1
@


11.13
log
@*- mods to rt_uplot_to_vlist
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/vlist.c,v 11.12 1999/05/28 01:07:56 mike Exp $ (BRL)";
d583 1
a583 1
register struct bu_list	*vhead;
d623 1
a623 1
		BN_ADD_VLIST( vbp->free_vlist_hd, vhead, arg, BN_VLIST_LINE_MOVE );
d628 1
a628 1
		BN_ADD_VLIST( vbp->free_vlist_hd, vhead, arg, BN_VLIST_LINE_MOVE );
d634 1
a634 1
		BN_ADD_VLIST( vbp->free_vlist_hd, vhead, arg, BN_VLIST_LINE_DRAW );
d639 1
a639 1
		BN_ADD_VLIST( vbp->free_vlist_hd, vhead, arg, BN_VLIST_LINE_DRAW );
d646 2
a647 2
		BN_ADD_VLIST( vbp->free_vlist_hd, vhead, a, BN_VLIST_LINE_MOVE );
		BN_ADD_VLIST( vbp->free_vlist_hd, vhead, b, BN_VLIST_LINE_DRAW );
d654 2
a655 2
		BN_ADD_VLIST( vbp->free_vlist_hd, vhead, a, BN_VLIST_LINE_MOVE );
		BN_ADD_VLIST( vbp->free_vlist_hd, vhead, b, BN_VLIST_LINE_DRAW );
d661 2
a662 2
		BN_ADD_VLIST( vbp->free_vlist_hd, vhead, arg, BN_VLIST_LINE_MOVE );
		BN_ADD_VLIST( vbp->free_vlist_hd, vhead, arg, BN_VLIST_LINE_DRAW );
d667 2
a668 2
		BN_ADD_VLIST( vbp->free_vlist_hd, vhead, arg, BN_VLIST_LINE_MOVE );
		BN_ADD_VLIST( vbp->free_vlist_hd, vhead, arg, BN_VLIST_LINE_DRAW );
d672 1
a672 1
		vhead = rt_vlblock_find( vbp,
d678 1
a678 1
		if( BU_LIST_NON_EMPTY( vhead ) )  {
d681 1
a681 1
			vlp = BU_LIST_LAST( bn_vlist, vhead );
d686 1
a686 1
		bn_vlist_3string( vhead, vbp->free_vlist_hd, carg, last_pos, mat, char_size );
d706 1
a706 1
	register struct bu_list	*vhead;
d714 2
a715 1
	       ret = rt_process_uplot_value( vhead,
@


11.12
log
@
Parameter type error
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/vlist.c,v 11.11 1999/05/27 21:52:13 mike Exp $ (BRL)";
d541 152
a707 10
	mat_t	mat;
	CONST struct uplot	*up;
	char	carg[256];
	fastf_t	arg[6];
	char	inbuf[8];
	vect_t	a,b;
	point_t	last_pos;
	int	cc;
	int	i;
	int	j;
d712 1
a712 6
		/* look it up */
		if( c < 'A' || c > 'z' ) {
			up = &rt_uplot_error;
		} else {
			up = &rt_uplot_letters[ c - 'A' ];
		}
d714 8
a721 34
		if( up->targ == TBAD ) {
			fprintf( stderr, "Bad command '%c' (0x%02x)\n", c, c );
			return(-1);
		}

		if( up->narg > 0 )  {
			for( i = 0; i < up->narg; i++ ) {
			switch( up->targ ){
				case TSHORT:
					arg[i] = getshort(fp);
					break;
				case TIEEE:
					fread( inbuf, 8, 1, fp );
					ntohd( (unsigned char *)&arg[i],
					    (unsigned char *)inbuf, 1 );
					break;
				case TSTRING:
					j = 0;
					while( (cc = getc(fp)) != '\n'
					    && cc != EOF )
						carg[j++] = cc;
					carg[j] = '\0';
					break;
				case TCHAR:
					carg[i] = getc(fp);
					arg[i] = 0;
					break;
				case TNONE:
				default:
					arg[i] = 0;	/* ? */
					break;
				}
			}
		}
a722 78
		switch( c ) {
		case 's':
		case 'w':
		case 'S':
		case 'W':
			/* Space commands, do nothing. */
			break;
		case 'm':
		case 'o':
			/* 2-D move */
			arg[Z] = 0;
			BN_ADD_VLIST( vbp->free_vlist_hd, vhead, arg, BN_VLIST_LINE_MOVE );
			break;
		case 'M':
		case 'O':
			/* 3-D move */
			BN_ADD_VLIST( vbp->free_vlist_hd, vhead, arg, BN_VLIST_LINE_MOVE );
			break;
		case 'n':
		case 'q':
			/* 2-D draw */
			arg[Z] = 0;
			BN_ADD_VLIST( vbp->free_vlist_hd, vhead, arg, BN_VLIST_LINE_DRAW );
			break;
		case 'N':
		case 'Q':
			/* 3-D draw */
			BN_ADD_VLIST( vbp->free_vlist_hd, vhead, arg, BN_VLIST_LINE_DRAW );
			break;
		case 'l':
		case 'v':
			/* 2-D line */
			VSET( a, arg[0], arg[1], 0.0 );
			VSET( b, arg[2], arg[3], 0.0 );
			BN_ADD_VLIST( vbp->free_vlist_hd, vhead, a, BN_VLIST_LINE_MOVE );
			BN_ADD_VLIST( vbp->free_vlist_hd, vhead, b, BN_VLIST_LINE_DRAW );
			break;
		case 'L':
		case 'V':
			/* 3-D line */
			VSET( a, arg[0], arg[1], arg[2] );
			VSET( b, arg[3], arg[4], arg[5] );
			BN_ADD_VLIST( vbp->free_vlist_hd, vhead, a, BN_VLIST_LINE_MOVE );
			BN_ADD_VLIST( vbp->free_vlist_hd, vhead, b, BN_VLIST_LINE_DRAW );
			break;
		case 'p':
		case 'x':
			/* 2-D point */
			arg[Z] = 0;
			BN_ADD_VLIST( vbp->free_vlist_hd, vhead, arg, BN_VLIST_LINE_MOVE );
			BN_ADD_VLIST( vbp->free_vlist_hd, vhead, arg, BN_VLIST_LINE_DRAW );
			break;
		case 'P':
		case 'X':
			/* 3-D point */
			BN_ADD_VLIST( vbp->free_vlist_hd, vhead, arg, BN_VLIST_LINE_MOVE );
			BN_ADD_VLIST( vbp->free_vlist_hd, vhead, arg, BN_VLIST_LINE_DRAW );
			break;
		case 'C':
			/* Color */
			vhead = rt_vlblock_find( vbp,
				carg[0], carg[1], carg[2] );
			break;
		case 't':
			/* Text string */
			bn_mat_idn(mat);
			if( BU_LIST_NON_EMPTY( vhead ) )  {
				struct bn_vlist *vlp;
				/* Use coordinates of last op */
				vlp = BU_LIST_LAST( bn_vlist, vhead );
				VMOVE( last_pos, vlp->pt[vlp->nused-1] );
			} else {
				VSETALL( last_pos, 0 );
			}
			bn_vlist_3string( vhead, vbp->free_vlist_hd, carg, last_pos, mat, char_size );
			break;
		}
	}
@


11.11
log
@
About to move librt/font.c to libbn/font.c
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/vlist.c,v 11.10 1999/05/27 21:16:38 mike Exp $ (BRL)";
d721 1
a721 1
			bn_vlist_3string( vhead, vbp->free_vlist_hd, label, pt, mat, sz );
@


11.10
log
@
Changed partway over to vlist being in LIBBN
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/vlist.c,v 11.9 1999/01/13 21:46:16 mike Exp $ (BRL)";
d46 3
a48 1
rt_vlblock_init()
d53 2
a54 2
	if (BU_LIST_UNINITIALIZED( &rt_g.rtg_vlfree ))
		BU_LIST_INIT( &rt_g.rtg_vlfree );
d58 2
a59 1
	vbp->max = 32;
d76 6
d96 1
a96 1
		BN_FREE_VLIST( &rt_g.rtg_vlfree, &(vbp->head[i]) );
d229 1
a229 1
			RT_ADD_VLIST( dest, *pt, *cmd );
d235 1
a235 1
 *			R T _ V L I S T _ C L E A N U P
a369 1
		/* This macro might be expanded inline, for performance */
d623 1
a623 1
			BN_ADD_VLIST( &rt_g.rtg_vlfree, vhead, arg, BN_VLIST_LINE_MOVE );
d628 1
a628 1
			BN_ADD_VLIST( &rt_g.rtg_vlfree, vhead, arg, BN_VLIST_LINE_MOVE );
d634 1
a634 1
			BN_ADD_VLIST( &rt_g.rtg_vlfree, vhead, arg, BN_VLIST_LINE_DRAW );
d639 1
a639 1
			BN_ADD_VLIST( &rt_g.rtg_vlfree, vhead, arg, BN_VLIST_LINE_DRAW );
d646 2
a647 2
			BN_ADD_VLIST( &rt_g.rtg_vlfree, vhead, a, BN_VLIST_LINE_MOVE );
			BN_ADD_VLIST( &rt_g.rtg_vlfree, vhead, b, BN_VLIST_LINE_DRAW );
d654 2
a655 2
			BN_ADD_VLIST( &rt_g.rtg_vlfree, vhead, a, BN_VLIST_LINE_MOVE );
			BN_ADD_VLIST( &rt_g.rtg_vlfree, vhead, b, BN_VLIST_LINE_DRAW );
d661 2
a662 2
			BN_ADD_VLIST( &rt_g.rtg_vlfree, vhead, arg, BN_VLIST_LINE_MOVE );
			BN_ADD_VLIST( &rt_g.rtg_vlfree, vhead, arg, BN_VLIST_LINE_DRAW );
d667 2
a668 2
			BN_ADD_VLIST( &rt_g.rtg_vlfree, vhead, arg, BN_VLIST_LINE_MOVE );
			BN_ADD_VLIST( &rt_g.rtg_vlfree, vhead, arg, BN_VLIST_LINE_DRAW );
d686 1
a686 1
			rt_vlist_3string( vhead, carg, last_pos, mat, char_size );
d721 1
a721 1
			rt_vlist_3string( vhead, label, pt, mat, sz );
@


11.9
log
@htond arg typing
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/vlist.c,v 11.8 1997/06/13 21:27:12 mike Exp $ (BRL)";
d43 1
a43 1
 *			R T _ V L B L O C K _ I N I T
d45 1
a45 1
struct rt_vlblock *
d48 1
a48 1
	struct rt_vlblock *vbp;
d54 2
a55 2
	BU_GETSTRUCT( vbp, rt_vlblock );
	vbp->magic = RT_VLBLOCK_MAGIC;
d78 1
a78 1
struct rt_vlblock *vbp;
d82 1
a82 1
	RT_CK_VLBLOCK(vbp);
d87 1
a87 1
		RT_FREE_VLIST( &(vbp->head[i]) );
d92 1
a92 1
	bu_free( (char *)vbp, "rt_vlblock" );
d100 1
a100 1
struct rt_vlblock *vbp;
d106 1
a106 1
	RT_CK_VLBLOCK(vbp);
d132 1
a132 1
 *			Generic RT_VLIST routines			*
d149 1
a149 1
 *  Validate an rt_vlist chain for having reasonable
d160 1
a160 1
	register struct rt_vlist	*vp;
d163 1
a163 1
	for( BU_LIST_FOR( vp, rt_vlist, vhead ) )  {
d169 1
a169 1
		RT_CK_VLIST( vp );
d191 1
a191 1
				if( *cmd < 0 || *cmd > RT_VLIST_POLY_VERTNORM )  {
d212 1
a212 1
	struct rt_vlist	*vp;
d214 1
a214 1
	for( BU_LIST_FOR( vp, rt_vlist, src ) )  {
d232 2
a233 1
rt_vlist_cleanup()
d235 1
a235 1
	register struct rt_vlist	*vp;
d237 2
a238 2
	if (BU_LIST_UNINITIALIZED( &rt_g.rtg_vlfree ))  {
		BU_LIST_INIT( &rt_g.rtg_vlfree );
d242 2
a243 2
	while( BU_LIST_WHILE( vp, rt_vlist, &rt_g.rtg_vlfree ) )  {
		RT_CK_VLIST( vp );
d245 1
a245 1
		bu_free( (char *)vp, "rt_vlist" );
d249 7
d276 1
a276 1
	register struct rt_vlist	*vp;
d287 1
a287 1
	for( BU_LIST_FOR( vp, rt_vlist, hp ) )  {
d304 1
a304 1
	for( BU_LIST_FOR( vp, rt_vlist, hp ) )  {
d314 1
a314 1
	for( BU_LIST_FOR( vp, rt_vlist, hp ) )  {
d362 1
a362 1
		RT_ADD_VLIST( hp, point, cmd );
d375 1
a375 1
 *  Output a rt_vlblock object in extended UNIX-plot format,
d381 1
a381 1
CONST struct rt_vlblock	*vbp;
d385 1
a385 1
	RT_CK_VLBLOCK(vbp);
d410 1
a410 1
	register struct rt_vlist	*vp;
d412 1
a412 1
	for( BU_LIST_FOR( vp, rt_vlist, vhead ) )  {
d420 1
a420 1
			case RT_VLIST_POLY_START:
d422 2
a423 2
			case RT_VLIST_POLY_MOVE:
			case RT_VLIST_LINE_MOVE:
d426 3
a428 3
			case RT_VLIST_POLY_DRAW:
			case RT_VLIST_POLY_END:
			case RT_VLIST_LINE_DRAW:
d542 1
a542 1
struct rt_vlblock	*vbp;
d615 1
a615 1
			RT_ADD_VLIST( vhead, arg, RT_VLIST_LINE_MOVE );
d620 1
a620 1
			RT_ADD_VLIST( vhead, arg, RT_VLIST_LINE_MOVE );
d626 1
a626 1
			RT_ADD_VLIST( vhead, arg, RT_VLIST_LINE_DRAW );
d631 1
a631 1
			RT_ADD_VLIST( vhead, arg, RT_VLIST_LINE_DRAW );
d638 2
a639 2
			RT_ADD_VLIST( vhead, a, RT_VLIST_LINE_MOVE );
			RT_ADD_VLIST( vhead, b, RT_VLIST_LINE_DRAW );
d646 2
a647 2
			RT_ADD_VLIST( vhead, a, RT_VLIST_LINE_MOVE );
			RT_ADD_VLIST( vhead, b, RT_VLIST_LINE_DRAW );
d653 2
a654 2
			RT_ADD_VLIST( vhead, arg, RT_VLIST_LINE_MOVE );
			RT_ADD_VLIST( vhead, arg, RT_VLIST_LINE_DRAW );
d659 2
a660 2
			RT_ADD_VLIST( vhead, arg, RT_VLIST_LINE_MOVE );
			RT_ADD_VLIST( vhead, arg, RT_VLIST_LINE_DRAW );
d671 1
a671 1
				struct rt_vlist *vlp;
d673 1
a673 1
				vlp = BU_LIST_LAST( rt_vlist, vhead );
d692 1
a692 1
struct rt_vlblock	*vbp;
d698 1
a698 1
	struct rt_vlist	*vp;
d704 1
a704 1
	for( BU_LIST_FOR( vp, rt_vlist, src ) )  {
@


11.8
log
@Changed from old rt_ names to new bu_ names
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/vlist.c,v 11.7 1997/06/13 21:07:22 mike Exp mike $ (BRL)";
d311 1
a311 1
			htond( bp, (char *)pt, 3 );
d351 1
a351 1
		ntohd( (char *)point, pp, 3 );
d574 2
a575 1
					ntohd( &arg[i], inbuf, 1 );
@


11.7
log
@Comments
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/vlist.c,v 11.6 1997/06/13 21:05:39 mike Exp mike $ (BRL)";
d57 1
a57 1
	vbp->head = (struct bu_list *)rt_calloc( vbp->max,
d59 1
a59 1
	vbp->rgb = (long *)rt_calloc( vbp->max,
d90 3
a92 3
	rt_free( (char *)(vbp->head), "head[]" );
	rt_free( (char *)(vbp->rgb), "rgb[]" );
	rt_free( (char *)vbp, "rt_vlblock" );
d229 1
a229 1
 *  Now, give those structures back to rt_free().
d244 1
a244 1
		rt_free( (char *)vp, "rt_vlist" );
@


11.6
log
@Solaris
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/vlist.c,v 11.5 1996/10/03 00:29:15 mike Exp mike $ (BRL)";
d42 3
d73 3
d95 3
@


11.5
log
@LIBBN
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/vlist.c,v 11.4 1996/07/11 20:09:49 jra Exp $ (BRL)";
d34 1
d48 2
a49 2
	if (RT_LIST_UNINITIALIZED( &rt_g.rtg_vlfree ))
		RT_LIST_INIT( &rt_g.rtg_vlfree );
d51 1
a51 1
	GETSTRUCT( vbp, rt_vlblock );
d54 2
a55 2
	vbp->head = (struct rt_list *)rt_calloc( vbp->max,
		sizeof(struct rt_list), "head[]" );
d61 1
a61 1
		RT_LIST_INIT( &(vbp->head[i]) );
d80 1
a80 1
		if( RT_LIST_IS_EMPTY( &(vbp->head[i]) ) )  continue;
d89 1
a89 1
struct rt_list *
d148 1
a148 1
CONST struct rt_list	*vhead;
d154 1
a154 1
	for( RT_LIST_FOR( vp, rt_vlist, vhead ) )  {
d176 1
a176 1
					rt_log("  %s (%g, %g, %g)\n",
d183 1
a183 1
					rt_log("cmd = x%x (%d.)\n", *cmd, *cmd);
d200 2
a201 2
struct rt_list	*dest;
CONST struct rt_list	*src;
d205 1
a205 1
	for( RT_LIST_FOR( vp, rt_vlist, src ) )  {
d227 2
a228 2
	if (RT_LIST_UNINITIALIZED( &rt_g.rtg_vlfree ))  {
		RT_LIST_INIT( &rt_g.rtg_vlfree );
d232 1
a232 1
	while( RT_LIST_WHILE( vp, rt_vlist, &rt_g.rtg_vlfree ) )  {
d234 1
a234 1
		RT_LIST_DEQUEUE( &(vp->l) );
d255 2
a256 2
struct rt_vls	*vls;
struct rt_list	*hp;
d266 1
a266 1
	RT_VLS_CHECK(vls);
d270 1
a270 1
	for( RT_LIST_FOR( vp, rt_vlist, hp ) )  {
d280 3
a282 3
	rt_vls_setlen( vls, nbytes );
	buf = (unsigned char *)rt_vls_addr(vls);
	bp = rt_plong( buf, nelem );
d287 1
a287 1
	for( RT_LIST_FOR( vp, rt_vlist, hp ) )  {
d297 1
a297 1
	for( RT_LIST_FOR( vp, rt_vlist, hp ) )  {
d316 2
a317 2
struct rt_list	*hp;
struct rt_vls	*namevls;
d327 1
a327 1
	RT_VLS_CHECK(namevls);
d329 1
a329 1
	nelem = rt_glong( buf );
d333 1
a333 1
	rt_vls_strncpy( namevls, (char *)bp, namelen );
d372 1
a372 1
		if( RT_LIST_IS_EMPTY( &(vbp->head[i]) ) )  continue;
d391 1
a391 1
CONST struct rt_list	*vhead;
d395 1
a395 1
	for( RT_LIST_FOR( vp, rt_vlist, vhead ) )  {
d415 1
a415 1
				rt_log("rt_vlist_to_uplot: unknown vlist cmd x%x\n",
d529 1
a529 1
	register struct rt_list	*vhead;
d651 2
a652 2
			mat_idn(mat);
			if( RT_LIST_NON_EMPTY( vhead ) )  {
d655 1
a655 1
				vlp = RT_LIST_LAST( rt_vlist, vhead );
d675 1
a675 1
struct rt_list		*src;
d681 1
a681 1
	struct rt_list	*vhead;
d686 1
a686 1
	for( RT_LIST_FOR( vp, rt_vlist, src ) )  {
@


11.4
log
@Minor mods for IRIX 6.2
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/vlist.c,v 11.3 1996/07/11 17:20:27 jra Exp jra $ (BRL)";
d29 1
d31 3
a33 3
#include "rtstring.h"
#include "raytrace.h"
#include "externs.h"
a36 48
 *			Generic RT_LIST routines			*
 *									*
 ************************************************************************/

/*
 *			R T _ L I S T _ L E N
 *
 *  Returns the number of elements on an rt_list brand linked list.
 */
int
rt_list_len( hd )
register CONST struct rt_list	*hd;
{
	register int			count = 0;
	register CONST struct rt_list	*ep;

	for( RT_LIST_FOR( ep, rt_list, hd ) )  {
		count++;
	}
	return count;
}

/*
 *			R T _ L I S T _ R E V E R S E
 *
 *	Reverses the order of elements in an rt_list linked list.
 */
void
rt_list_reverse( hd )
register struct rt_list   *hd;
{
	struct rt_list tmp_hd;
	register struct rt_list *ep;

	RT_CK_LIST_HEAD( hd );

	RT_LIST_INIT( &tmp_hd );
	RT_LIST_INSERT_LIST( &tmp_hd, hd );

	while( RT_LIST_WHILE( ep, rt_list, &tmp_hd ) )
	{
		RT_LIST_DEQUEUE( ep );
		RT_LIST_APPEND( hd, ep );
	}
}

/************************************************************************
 *									*
d140 1
a140 1
 *  values inside.  Calls rt_bomb() if not.
d178 1
a178 1
					rt_bomb("rt_ck_vlist() bad coordinate value\n");
d183 1
a183 1
					rt_bomb("rt_ck_vlist() bad vlist command\n");
@


11.3
log
@Minor Mods for IRIX 6.2
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/vlist.c,v 11.2 1995/03/02 17:41:12 jra Exp jra $ (BRL)";
d329 1
a329 1
	strncpy( bp, name, namelen );
d378 1
a378 1
	namelen = strlen(bp)+1;
@


11.2
log
@added rt_reverse_list().
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/vlist.c,v 11.1 95/01/04 09:58:56 mike Rel4_4 Locker: jra $ (BRL)";
d366 1
a366 1
	CONST register unsigned char	*bp;
@


11.1
log
@Release_4.4
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/vlist.c,v 1.14 94/12/29 16:32:43 jra Exp $ (BRL)";
d56 25
a80 1
}	
@


1.14
log
@MIKE added rt_ck_vlist.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/librt/RCS/vlist.c,v 1.13 94/12/27 15:14:38 jra Exp Locker: jra $ (BRL)";
@


1.13
log
@Modified rt_label_vlist_verts to accept a "mm2local" arg.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/vlist.c,v 1.12 94/11/04 06:08:17 mike Exp Locker: jra $ (BRL)";
d148 65
@


1.12
log
@Irix 6
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/vlist.c,v 1.11 94/08/27 03:12:24 mike Exp Locker: mike $ (BRL)";
d630 1
a630 1
rt_label_vlist_verts( vbp, src, mat, sz )
d635 1
d651 1
a651 1
				V3ARGS(*pt) );
@


1.11
log
@Added rt_list_len(), rt_vlist_copy().
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/vlist.c,v 1.10 94/08/10 20:22:54 gdurf Exp Locker: mike $ (BRL)";
a276 1
	register struct rt_vlist	*vp;
a638 1
	fastf_t		scale;
@


1.10
log
@Added include of conf.h
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/vlist.c,v 1.9 1994/03/18 01:37:56 mike Exp gdurf $ (BRL)";
d36 24
d141 30
@


1.9
log
@Moved location of one routine, added CONST.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/vlist.c,v 1.8 94/03/18 01:30:25 mike Exp Locker: mike $ (BRL)";
d23 2
@


1.8
log
@Moved some common routines used by many callers from nmg_plot.c to here.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/vlist.c,v 1.7 94/03/18 01:26:02 mike Exp Locker: mike $ (BRL)";
a117 26
 *			R T _ P L O T _ V L B L O C K
 *
 *  Output a rt_vlblock object in extended UNIX-plot format,
 *  including color.
 */
void
rt_plot_vlblock( fp, vbp )
FILE			*fp;
CONST struct rt_vlblock	*vbp;
{
	int	i;

	RT_CK_VLBLOCK(vbp);

	for( i=0; i < vbp->nused; i++ )  {
		if( vbp->rgb[i] == 0 )  continue;
		if( RT_LIST_IS_EMPTY( &(vbp->head[i]) ) )  continue;
		pl_color( fp,
			(vbp->rgb[i]>>16) & 0xFF,
			(vbp->rgb[i]>> 8) & 0xFF,
			(vbp->rgb[i]    ) & 0xFF );
		rt_vlist_to_uplot( fp, &(vbp->head[i]) );
	}
}

/*
d258 26
d292 2
a293 2
FILE		*fp;
struct rt_list	*vhead;
@


1.7
log
@Got extra arg on rt_uplot_to_vlist
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/vlist.c,v 1.6 94/03/18 01:18:09 mike Exp Locker: mike $ (BRL)";
d32 85
d118 55
d277 5
a281 17
/*
 *			R T _ V L I S T _ C L E A N U P
 *
 *  The macro RT_FREE_VLIST() simply appends to the list &rt_g.rtg_vlfree.
 *  Now, give those structures back to rt_free().
 */
void
rt_vlist_cleanup()
{
	register struct rt_vlist	*vp;

	while( RT_LIST_WHILE( vp, rt_vlist, &rt_g.rtg_vlfree ) )  {
		RT_CK_VLIST( vp );
		RT_LIST_DEQUEUE( &(vp->l) );
		rt_free( (char *)vp, "rt_vlist" );
	}
}
@


1.6
log
@Imported commonly useful routines from MGED.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/vlist.c,v 1.5 94/03/18 01:10:49 mike Exp $ (BRL)";
d160 1
d205 3
a207 3
	int	targ;	/* type of args */
	int	narg;	/* number or args */
	char	*desc;	/* description */
d209 2
a210 2
struct uplot uplot_error = { 0, 0, 0 };
struct uplot uplot_letters[] = {
d298 1
a298 1
rt_uplot_to_vlist( vbp, fp )
d301 1
d306 1
a306 1
	struct	uplot *up;
d321 1
a321 1
			up = &uplot_error;
d323 1
a323 1
			up = &uplot_letters[ c - 'A' ];
d434 1
a434 1
			rt_vlist_3string( vhead, carg, last_pos, mat, Viewscale * 0.01 );
@


1.5
log
@Moved rt_vlist_to_uplot() from prep.c to vlist.c
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/vlist.c,v 1.4 94/03/11 20:31:46 butler Exp Locker: mike $ (BRL)";
d191 277
@


1.4
log
@moved RT_CK_VLIST macro to raytrace.h
@
text
@d4 3
a6 1
 *  Routines for the import and export of vlist chains.
d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/vlist.c,v 1.3 93/10/28 23:46:55 mike Exp Locker: butler $ (BRL)";
d152 40
@


1.3
log
@Added rt_vlist_cleanup(), to give the free vlist back to rt_free().
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/vlist.c,v 1.2 92/10/27 16:29:51 mike Exp Locker: mike $ (BRL)";
a133 3

/* XXX move to raytrace.h */
#define RT_CK_VLIST(_p)		RT_CKMAG(_p, RT_VLIST_MAGIC, "rt_vlist")
@


1.2
log
@Added extern declarations to raytrace.h, added some CONST declarations.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/vlist.c,v 1.1 92/04/16 23:35:39 mike Exp Locker: mike $ (BRL)";
d132 21
@


1.1
log
@Initial revision
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
a29 3
/* Should move to raytrace.h */
RT_EXTERN( unsigned char *rt_plong, (unsigned char *msgp, unsigned long l) );

d42 1
a42 1
char		*name;
d103 1
a103 1
unsigned char	*buf;
d106 2
a107 2
	unsigned char	*bp;
	unsigned char	*pp;		/* point pointer */
@
