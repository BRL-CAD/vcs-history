head	1.120;
access;
symbols
	ansi-20040405-merged:1.109.2.2
	postmerge-20040405-ansi:1.118
	premerge-20040404-ansi:1.117
	postmerge-autoconf:1.117
	autoconf-freeze:1.116.4.2
	premerge-autoconf:1.117
	ansi-20040316-freeze:1.109.2.1
	postmerge-20040315-windows:1.117
	premerge-20040315-windows:1.117
	windows-20040315-freeze:1.109.4.1
	autoconf-20031203:1.116
	autoconf-20031202:1.116
	autoconf-branch:1.116.0.4
	phong-branch:1.116.0.2
	photonmap-branch:1.111.0.2
	rel-6-1-DP:1.109
	windows-branch:1.109.0.4
	rel-6-0-2:1.105
	ansi-branch:1.109.0.2
	rel-6-0-1-branch:1.105.0.2
	hartley-6-0-post:1.107
	hartley-6-0-pre:1.105
	rel-6-0-1:1.105
	rel-6-0:1.101
	rel-5-4:1.59.2.2
	offsite-5-3-pre:1.73
	rel-5-3:1.59.2.2
	rel-5-2:1.59
	rel-5-1-branch:1.59.0.2
	rel-5-1:1.59
	rel-5-0:1.41
	rel-5-0-beta:1.40
	rel-4-5:1.37
	ctj-4-5-post:1.31
	ctj-4-5-pre:1.27;
locks; strict;
comment	@ * @;


1.120
date	2004.05.21.18.07.30;	author morrison;	state dead;
branches;
next	1.119;

1.119
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	1.118;

1.118
date	2004.04.05.08.48.56;	author morrison;	state Exp;
branches;
next	1.117;

1.117
date	2004.02.02.17.39.20;	author morrison;	state Exp;
branches;
next	1.116;

1.116
date	2003.08.02.23.14.23;	author butler;	state Exp;
branches
	1.116.4.1;
next	1.115;

1.115
date	2003.07.28.20.30.31;	author butler;	state Exp;
branches;
next	1.114;

1.114
date	2003.07.19.22.53.24;	author butler;	state Exp;
branches;
next	1.113;

1.113
date	2003.07.19.22.26.33;	author butler;	state Exp;
branches;
next	1.112;

1.112
date	2003.04.15.21.23.25;	author butler;	state Exp;
branches;
next	1.111;

1.111
date	2003.04.08.22.20.56;	author butler;	state Exp;
branches
	1.111.2.1;
next	1.110;

1.110
date	2002.11.26.21.08.00;	author morrison;	state Exp;
branches;
next	1.109;

1.109
date	2002.09.05.04.10.30;	author butler;	state Exp;
branches
	1.109.2.1
	1.109.4.1;
next	1.108;

1.108
date	2002.08.20.17.07.59;	author jra;	state Exp;
branches;
next	1.107;

1.107
date	2002.08.16.21.38.49;	author morrison;	state Exp;
branches;
next	1.106;

1.106
date	2002.08.15.20.55.11;	author hartley;	state Exp;
branches;
next	1.105;

1.105
date	2002.07.12.21.41.44;	author butler;	state Exp;
branches;
next	1.104;

1.104
date	2002.07.12.21.29.32;	author butler;	state Exp;
branches;
next	1.103;

1.103
date	2002.06.19.20.13.50;	author butler;	state Exp;
branches;
next	1.102;

1.102
date	2002.06.08.00.28.58;	author butler;	state Exp;
branches;
next	1.101;

1.101
date	2002.02.26.20.40.36;	author morrison;	state Exp;
branches;
next	1.100;

1.100
date	2001.11.22.02.13.19;	author butler;	state Exp;
branches;
next	1.99;

1.99
date	2001.11.19.22.19.22;	author butler;	state Exp;
branches;
next	1.98;

1.98
date	2001.11.19.19.33.26;	author butler;	state Exp;
branches;
next	1.97;

1.97
date	2001.11.14.23.47.06;	author butler;	state Exp;
branches;
next	1.96;

1.96
date	2001.11.02.05.02.42;	author butler;	state Exp;
branches;
next	1.95;

1.95
date	2001.11.02.01.02.58;	author butler;	state Exp;
branches;
next	1.94;

1.94
date	2001.10.31.23.01.00;	author butler;	state Exp;
branches;
next	1.93;

1.93
date	2001.10.26.20.48.33;	author bparker;	state Exp;
branches;
next	1.92;

1.92
date	2001.10.25.02.23.22;	author butler;	state Exp;
branches;
next	1.91;

1.91
date	2001.10.15.19.58.04;	author morrison;	state Exp;
branches;
next	1.90;

1.90
date	2001.10.04.14.19.57;	author butler;	state Exp;
branches;
next	1.89;

1.89
date	2001.10.02.19.24.28;	author jra;	state Exp;
branches;
next	1.88;

1.88
date	2001.09.09.00.42.09;	author butler;	state Exp;
branches;
next	1.87;

1.87
date	2001.09.08.03.31.26;	author butler;	state Exp;
branches;
next	1.86;

1.86
date	2001.09.07.22.35.42;	author butler;	state Exp;
branches;
next	1.85;

1.85
date	2001.09.07.01.00.05;	author butler;	state Exp;
branches;
next	1.84;

1.84
date	2001.09.06.23.20.07;	author butler;	state Exp;
branches;
next	1.83;

1.83
date	2001.09.04.17.27.24;	author butler;	state Exp;
branches;
next	1.82;

1.82
date	2001.08.29.23.06.57;	author butler;	state Exp;
branches;
next	1.81;

1.81
date	2001.08.11.13.16.50;	author butler;	state Exp;
branches;
next	1.80;

1.80
date	2001.05.17.20.05.24;	author morrison;	state Exp;
branches;
next	1.79;

1.79
date	2001.04.20.22.29.43;	author morrison;	state Exp;
branches;
next	1.78;

1.78
date	2001.04.05.13.07.44;	author jra;	state Exp;
branches;
next	1.77;

1.77
date	2001.04.02.21.38.08;	author morrison;	state Exp;
branches;
next	1.76;

1.76
date	2001.03.31.01.57.06;	author morrison;	state Exp;
branches;
next	1.75;

1.75
date	2001.03.23.22.34.31;	author butler;	state Exp;
branches;
next	1.74;

1.74
date	2001.03.19.20.03.33;	author butler;	state Exp;
branches;
next	1.73;

1.73
date	2000.10.24.00.02.25;	author butler;	state Exp;
branches;
next	1.72;

1.72
date	2000.08.23.00.35.58;	author butler;	state Exp;
branches;
next	1.71;

1.71
date	2000.08.21.02.02.29;	author butler;	state Exp;
branches;
next	1.70;

1.70
date	2000.08.11.00.42.23;	author mike;	state Exp;
branches;
next	1.69;

1.69
date	2000.07.25.17.54.40;	author butler;	state Exp;
branches;
next	1.68;

1.68
date	2000.07.14.19.43.51;	author butler;	state Exp;
branches;
next	1.67;

1.67
date	2000.07.10.23.01.30;	author mike;	state Exp;
branches;
next	1.66;

1.66
date	2000.07.08.01.29.29;	author mike;	state Exp;
branches;
next	1.65;

1.65
date	2000.06.30.20.10.32;	author butler;	state Exp;
branches;
next	1.64;

1.64
date	2000.06.30.15.38.02;	author mike;	state Exp;
branches;
next	1.63;

1.63
date	2000.06.30.15.31.14;	author mike;	state Exp;
branches;
next	1.62;

1.62
date	2000.06.29.20.43.52;	author butler;	state Exp;
branches;
next	1.61;

1.61
date	2000.06.29.19.45.57;	author butler;	state Exp;
branches;
next	1.60;

1.60
date	2000.06.29.14.52.03;	author butler;	state Exp;
branches;
next	1.59;

1.59
date	2000.04.12.02.34.31;	author mike;	state Exp;
branches
	1.59.2.1;
next	1.58;

1.58
date	2000.03.28.21.59.04;	author mike;	state Exp;
branches;
next	1.57;

1.57
date	2000.03.28.21.27.51;	author mike;	state Exp;
branches;
next	1.56;

1.56
date	2000.03.03.01.05.03;	author mike;	state Exp;
branches;
next	1.55;

1.55
date	2000.03.02.02.31.11;	author butler;	state Exp;
branches;
next	1.54;

1.54
date	2000.03.02.00.43.52;	author mike;	state Exp;
branches;
next	1.53;

1.53
date	2000.02.20.06.40.50;	author butler;	state Exp;
branches;
next	1.52;

1.52
date	2000.02.19.21.06.32;	author butler;	state Exp;
branches;
next	1.51;

1.51
date	2000.02.11.20.23.13;	author butler;	state Exp;
branches;
next	1.50;

1.50
date	99.12.30.15.07.16;	author jra;	state Exp;
branches;
next	1.49;

1.49
date	99.12.10.15.08.58;	author butler;	state Exp;
branches;
next	1.48;

1.48
date	99.12.10.14.10.20;	author butler;	state Exp;
branches;
next	1.47;

1.47
date	99.12.09.16.14.42;	author mike;	state Exp;
branches;
next	1.46;

1.46
date	99.12.03.20.54.11;	author butler;	state Exp;
branches;
next	1.45;

1.45
date	99.11.26.22.02.53;	author mike;	state Exp;
branches;
next	1.44;

1.44
date	99.11.26.21.46.45;	author mike;	state Exp;
branches;
next	1.43;

1.43
date	99.11.24.23.12.06;	author mike;	state Exp;
branches;
next	1.42;

1.42
date	99.11.17.02.41.57;	author mike;	state Exp;
branches;
next	1.41;

1.41
date	99.07.02.22.19.22;	author mike;	state Exp;
branches;
next	1.40;

1.40
date	99.05.27.19.10.36;	author mike;	state Exp;
branches;
next	1.39;

1.39
date	99.01.08.21.31.46;	author butler;	state Exp;
branches;
next	1.38;

1.38
date	98.06.15.13.18.42;	author butler;	state Exp;
branches;
next	1.37;

1.37
date	98.01.21.11.08.47;	author butler;	state Exp;
branches;
next	1.36;

1.36
date	98.01.21.10.36.56;	author butler;	state Exp;
branches;
next	1.35;

1.35
date	98.01.21.08.54.09;	author butler;	state Exp;
branches;
next	1.34;

1.34
date	97.12.16.00.13.37;	author mike;	state Exp;
branches;
next	1.33;

1.33
date	97.11.05.18.55.34;	author jra;	state Exp;
branches;
next	1.32;

1.32
date	97.10.28.02.35.28;	author butler;	state Exp;
branches;
next	1.31;

1.31
date	97.08.01.17.58.29;	author jra;	state Exp;
branches;
next	1.30;

1.30
date	97.08.01.12.20.26;	author jra;	state Exp;
branches;
next	1.29;

1.29
date	97.07.31.20.10.13;	author butler;	state Exp;
branches;
next	1.28;

1.28
date	97.07.23.21.32.19;	author butler;	state Exp;
branches;
next	1.27;

1.27
date	97.07.22.23.55.41;	author butler;	state Exp;
branches;
next	1.26;

1.26
date	97.07.22.16.50.27;	author butler;	state Exp;
branches;
next	1.25;

1.25
date	97.07.22.01.02.22;	author butler;	state Exp;
branches;
next	1.24;

1.24
date	97.07.02.02.59.28;	author butler;	state Exp;
branches;
next	1.23;

1.23
date	97.07.01.21.39.09;	author butler;	state Exp;
branches;
next	1.22;

1.22
date	97.06.30.19.27.04;	author butler;	state Exp;
branches;
next	1.21;

1.21
date	97.06.30.16.10.40;	author butler;	state Exp;
branches;
next	1.20;

1.20
date	97.06.27.18.46.16;	author butler;	state Exp;
branches;
next	1.19;

1.19
date	97.06.26.22.30.19;	author butler;	state Exp;
branches;
next	1.18;

1.18
date	97.06.26.03.27.08;	author butler;	state Exp;
branches;
next	1.17;

1.17
date	97.06.26.03.10.17;	author butler;	state Exp;
branches;
next	1.16;

1.16
date	97.06.26.00.00.33;	author butler;	state Exp;
branches;
next	1.15;

1.15
date	97.06.25.22.55.33;	author butler;	state Exp;
branches;
next	1.14;

1.14
date	97.06.18.01.04.47;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	97.06.17.05.26.58;	author butler;	state Exp;
branches;
next	1.12;

1.12
date	97.06.16.20.59.37;	author butler;	state Exp;
branches;
next	1.11;

1.11
date	97.06.13.22.50.18;	author butler;	state Exp;
branches;
next	1.10;

1.10
date	97.06.11.03.08.01;	author butler;	state Exp;
branches;
next	1.9;

1.9
date	97.06.10.13.07.06;	author jra;	state Exp;
branches;
next	1.8;

1.8
date	97.06.09.22.22.03;	author butler;	state Exp;
branches;
next	1.7;

1.7
date	97.06.06.04.43.06;	author butler;	state Exp;
branches;
next	1.6;

1.6
date	97.06.04.23.07.04;	author butler;	state Exp;
branches;
next	1.5;

1.5
date	97.05.30.05.11.46;	author butler;	state Exp;
branches;
next	1.4;

1.4
date	97.05.22.09.28.06;	author butler;	state Exp;
branches;
next	1.3;

1.3
date	97.05.22.02.49.51;	author butler;	state Exp;
branches;
next	1.2;

1.2
date	97.05.22.02.30.43;	author butler;	state Exp;
branches;
next	1.1;

1.1
date	97.05.22.02.09.07;	author butler;	state Exp;
branches;
next	;

1.59.2.1
date	2001.01.09.22.53.09;	author butler;	state Exp;
branches;
next	1.59.2.2;

1.59.2.2
date	2001.03.01.02.48.14;	author butler;	state Exp;
branches;
next	;

1.109.2.1
date	2002.09.19.18.01.32;	author morrison;	state Exp;
branches;
next	1.109.2.2;

1.109.2.2
date	2004.03.17.21.18.45;	author morrison;	state Exp;
branches;
next	;

1.109.4.1
date	2004.03.11.23.43.37;	author morrison;	state Exp;
branches;
next	;

1.111.2.1
date	2003.08.26.14.03.35;	author justin;	state Exp;
branches;
next	;

1.116.4.1
date	2004.02.12.18.37.40;	author erikg;	state Exp;
branches;
next	1.116.4.2;

1.116.4.2
date	2004.03.15.14.07.18;	author erikg;	state Exp;
branches;
next	;


desc
@displacement map solid
@


1.120
log
@moved to src/
@
text
@#define FULL_DSP_DEBUGGING 1
/*
 *			G _ D S P . C
 *
 *  Purpose -
 *	Intersect a ray with a displacement map
 *
 *  The bounding box planes (in dsp coordinates) are numbered 0 .. 5
 *
 *  For purposes of the "struct hit" surface number, the "non-elevation" 
 *  surfaces are numbered 0 .. 7 where:
 *
 *	     Plane #	Name  plane dist
 *	--------------------------------------------------
 *		0	XMIN (dist = 0)
 *		1	XMAX (dist = xsiz)
 *		2	YMIN (dist = 0)
 *		3	YMAX (dist = ysiz)
 *		4	ZMIN (dist = 0)
 *		5	ZMAX (dsp_max)
 *
 *		6	ZMID (dsp_min)
 *		7	ZTOP (computed)
 *
 *  if the "struct hit" surfno surface is ZMAX, then 
 *  	hit_vpriv[X,Y] holds the cell that was hit.
 * 	hit_vpriv[Z] is 0 if this was an in-hit.  1 if an out-hit
 *
 *
 *  Authors -
 *  	Lee A. Butler
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1990-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSdsp[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/g_dsp.c,v 1.119 2004/05/10 15:30:46 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <string.h>
#include <math.h>
#include "machine.h"
#include "vmath.h"
#include "db.h"
#include "nmg.h"
#include "raytrace.h"
#include "rtgeom.h"
#include "./debug.h"
#include "plot3.h"
#include <setjmp.h>

#define ORDERED_ISECT 1
/* #define FULL_DSP_DEBUGGING 1 */

#define DIM_BB_CHILDREN 4
#define NUM_BB_CHILDREN (DIM_BB_CHILDREN*DIM_BB_CHILDREN)

struct dsp_rpp {
    unsigned short dsp_min[3];
    unsigned short dsp_max[3];
};

/* This structure contains a bounding box for a portion of the DSP
 * along with information about sub-bounding boxes, and what layer
 * (resolution) of the DSP this box bounds
 */
struct dsp_bb {
    long	magic;
    struct dsp_rpp	dspb_rpp;	/* our bounding box */
    /*
     * the next two elements indicate the number and locations of
     * sub-bounding rpps.
     *
     * dsp_b_ch_dim is typically DIM_BB_CHILDREN,DIM_BB_CHILDREN
     * except for "border" areas of the array
     */
    unsigned short	dspb_subcell_size;/* XXX This is not yet computed */
    unsigned short	dspb_ch_dim[2];	/* dimensions of children[] */
    struct dsp_bb	*dspb_children[NUM_BB_CHILDREN];
};
#define MAGIC_dsp_bb 234
#define DSP_BB_CK(_p) BU_CKMAG(_p, MAGIC_dsp_bb, "dsp_bb")
/* 
 * This structure provides a handle to all of the bounding boxes for the DSP
 * at a particular resolution.
 */
#define LAYER(l, x,y) l->p[l->dim[1]*y+x]
struct dsp_bb_layer {
    int	dim[2];		/* the dimensions of the array at element p */
    struct dsp_bb *p;	/* array of dsp_bb's for this level */
};



extern int rt_retrieve_binunif(struct rt_db_internal *intern,
			       const struct db_i	*dbip,
			       const char *name);

extern void rt_binunif_ifree( struct rt_db_internal	*ip );


#define dlog if (RT_G_DEBUG & DEBUG_HF) bu_log	


#define BBOX_PLANES	7	/* 2 tops & 5 other sides */
#define XMIN 0
#define XMAX 1
#define YMIN 2
#define YMAX 3
#define ZMIN 4
#define ZMAX 5
#define ZMID 6
#define ZTOP 7



/* per-solid ray tracing form of solid, including precomputed terms
 *
 * The dsp_i element MUST BE FIRST so that we can cast a pointer to 
 *  a dsp_specific to a rt_dsp_intermal.
 */
struct dsp_specific {
    struct rt_dsp_internal dsp_i;	/* MUST BE FIRST */
    double		dsp_pl_dist[BBOX_PLANES];
    int		xsiz;
    int		ysiz;
    int		layers;
    struct dsp_bb_layer *layer;
    struct dsp_bb *bb_array;
};



/* access to the array */
#ifdef FULL_DSP_DEBUGGING
#define DSP(_p,_x,_y) dsp_val(_p, _x, _y, __FILE__, __LINE__)
unsigned short
dsp_val(struct rt_dsp_internal *dsp_i, unsigned x, unsigned y, char *file, int line)
{
    RT_DSP_CK_MAGIC(dsp_i);

    if (x >= dsp_i->dsp_xcnt || y >= dsp_i->dsp_ycnt) {
	bu_log("%s:%d xy: %u,%u cnt: %u,%u\n",
	       file, line, x, y, dsp_i->dsp_xcnt, dsp_i->dsp_ycnt);
	bu_bomb("");
    }

    return dsp_i->dsp_buf[ y * dsp_i->dsp_xcnt + x ];
} 
#else
# define DSP(_p,_x,_y) ( \
	( \
	 (unsigned short *) \
	  ((_p)->dsp_buf) \
	)[ \
	     (_y) * ((struct rt_dsp_internal *)_p)->dsp_xcnt + (_x) ] )
#endif

# define XCNT(_p) (((struct rt_dsp_internal *)_p)->dsp_xcnt)
# define YCNT(_p) (((struct rt_dsp_internal *)_p)->dsp_ycnt)
# define XSIZ(_p) (_p->dsp_i.dsp_xcnt - 1)
# define YSIZ(_p) (_p->dsp_i.dsp_ycnt - 1)




struct bbox_isect {
    double	in_dist;
    double	out_dist;
    int	in_surf;
    int	out_surf;
};


/* per-ray ray tracing information
 *
 */
struct isect_stuff {
    struct dsp_specific	*dsp;
    struct bu_list	seglist;	/* list of segments */
    struct xray		r;		/* solid space ray */
    vect_t 		inv_dir;	/* inverses of ray direction */
    struct application	*ap;
    struct soltab	*stp;
    struct bn_tol	*tol;

    struct bbox_isect	bbox;
    struct bbox_isect	minbox;

    int			num_segs;
    int			dmin, dmax;	/* for dsp_in_rpp , {X,Y,Z}MIN/MAX */
};




/* plane equations (minus offset distances) for bounding RPP */
static const vect_t	dsp_pl[BBOX_PLANES] = {
    {-1.0, 0.0, 0.0},
    { 1.0, 0.0, 0.0},

    {0.0, -1.0, 0.0},
    {0.0,  1.0, 0.0},

    {0.0, 0.0, -1.0},
    {0.0, 0.0,  1.0},
    {0.0, 0.0,  1.0},
};

/*
 * This function computes the DSP mtos matrix from the stom matrix
 * whenever the stom matrix is parsed using a bu_structparse.
 */
static void
hook_mtos_from_stom(
		    const struct bu_structparse	*ip,
		    const char 			*sp_name,
		    genptr_t			base,		    
		    char			*p)
{
    struct rt_dsp_internal *dsp_ip = (struct rt_dsp_internal *)base;

    bn_mat_inv(dsp_ip->dsp_mtos, dsp_ip->dsp_stom);
}
static void
hook_file(
	  const struct bu_structparse	*ip,
	  const char 			*sp_name,
	  genptr_t			base,		    
	  char			*p)
{
    struct rt_dsp_internal *dsp_ip = (struct rt_dsp_internal *)base;

    dsp_ip->dsp_datasrc = RT_DSP_SRC_V4_FILE;
    dsp_ip->dsp_bip = (struct rt_db_internal *)NULL;
}

#define DSP_O(m) offsetof(struct rt_dsp_internal, m)
#define DSP_AO(a) bu_offsetofarray(struct rt_dsp_internal, a)

/*
 *	These are only used when editing a v4 database
 */
const struct bu_structparse rt_dsp_parse[] = {
    {"%S",	1, "file", DSP_O(dsp_name), hook_file },
    {"%i",	1, "sm", DSP_O(dsp_smooth), BU_STRUCTPARSE_FUNC_NULL },
    {"%d",	1, "w", DSP_O(dsp_xcnt), BU_STRUCTPARSE_FUNC_NULL },
    {"%d",	1, "n", DSP_O(dsp_ycnt), BU_STRUCTPARSE_FUNC_NULL },
    {"%f",     16, "stom", DSP_AO(dsp_stom), hook_mtos_from_stom },
    {"",	0, (char *)0, 0,	BU_STRUCTPARSE_FUNC_NULL }
};

const struct bu_structparse rt_dsp_ptab[] = {
    {"%S",	1, "file", DSP_O(dsp_name), BU_STRUCTPARSE_FUNC_NULL },
    {"%i",	1, "sm", DSP_O(dsp_smooth), BU_STRUCTPARSE_FUNC_NULL },
    {"%d",	1, "w", DSP_O(dsp_xcnt), BU_STRUCTPARSE_FUNC_NULL },
    {"%d",	1, "n", DSP_O(dsp_ycnt), BU_STRUCTPARSE_FUNC_NULL },
    {"%f",     16, "stom", DSP_AO(dsp_stom), BU_STRUCTPARSE_FUNC_NULL },
    {"",	0, (char *)0, 0,	BU_STRUCTPARSE_FUNC_NULL }
};

/*
 *	This one is used by the rt_dsp_tclget()
 */


static int plot_file_num=0;


/*	P L O T _ R P P
 *
 * Plot an RPP to a file in the given color
 */
static void
plot_rpp(FILE *fp, struct bound_rpp *rpp, int r, int g, int b)
{
    pl_color(fp, r, g, b);

    pd_3move(fp, rpp->min[X], rpp->min[Y], rpp->min[Z]);
    pd_3cont(fp, rpp->max[X], rpp->min[Y], rpp->min[Z]);
    pd_3cont(fp, rpp->max[X], rpp->max[Y], rpp->min[Z]);
    pd_3cont(fp, rpp->min[X], rpp->max[Y], rpp->min[Z]);
    pd_3cont(fp, rpp->min[X], rpp->min[Y], rpp->min[Z]);

    pd_3cont(fp, rpp->min[X], rpp->min[Y], rpp->max[Z]);
    pd_3cont(fp, rpp->max[X], rpp->min[Y], rpp->max[Z]);
    pd_3cont(fp, rpp->max[X], rpp->max[Y], rpp->max[Z]);
    pd_3cont(fp, rpp->min[X], rpp->max[Y], rpp->max[Z]);
    pd_3cont(fp, rpp->min[X], rpp->min[Y], rpp->max[Z]);
}


/*	P L O T _ D S P _ B B
 *
 *  Plot a dsp_bb structure
 */
static void
plot_dsp_bb(FILE *fp, struct dsp_bb *dsp_bb,
	    struct dsp_specific *dsp,
	    int r, int g, int b, int blather)
{
    fastf_t *stom = &dsp->dsp_i.dsp_stom[0];
    struct bound_rpp rpp;
    point_t pt;

    DSP_BB_CK(dsp_bb);

    VMOVE(pt, dsp_bb->dspb_rpp.dsp_min); /* int->float conversion */
    MAT4X3PNT(rpp.min, stom, pt);

    VMOVE(pt, dsp_bb->dspb_rpp.dsp_max); /* int->float conversion */
    MAT4X3PNT(rpp.max, stom, pt);

    if (blather)
	bu_log(" (%g %g %g) (%g %g %g)\n",
	       V3ARGS(rpp.min), V3ARGS(rpp.max) );

    plot_rpp(fp, &rpp, r, g, b);
}
/*
 * drawing support for isect_ray_dsp_bb()
 */
static FILE *
draw_dsp_bb(int *plotnum,
	    struct dsp_bb *dsp_bb,
	    struct dsp_specific *dsp,
	    int r, int g, int b)
{
    char buf[64];
    FILE *fp;
    struct dsp_bb bb;

    sprintf(buf, "dsp_bb%03d.pl", (*plotnum)++);
    if ( (fp=fopen(buf, "w")) == (FILE *)NULL) {
	perror(buf);
	bu_bomb("");
    }

    bu_log("plotting %s", buf);
    bb = *dsp_bb; /* struct copy */
    bb.dspb_rpp.dsp_min[Z] = 0.0;
    plot_dsp_bb(fp, &bb, dsp, r, g, b, 1);

    return fp;
}

#define PLOT_LAYERS
#ifdef PLOT_LAYERS
/*	P L O T _ L A Y E R S
 *
 *
 *  Plot the bounding box layers for a dsp
 */
static void
plot_layers(struct dsp_specific *dsp_sp)
{
    FILE *fp;
    int l, x, y, n;
    char buf[32];
    static int colors[7][3] = {
	{255, 0, 0},
	{0, 255, 0},
	{0, 0, 255},
	{255, 255, 0},
	{255, 0, 255},
	{0, 255, 255},
	{255, 255, 255}
    };
    int r, g, b, c;
    struct dsp_bb *d_bb;

    for (l=0 ; l < dsp_sp->layers ; l++) {
	bu_semaphore_acquire( BU_SEM_SYSCALL);
	sprintf(buf, "Dsp_layer%d.pl", l);
	fp=fopen(buf, "w");
	bu_semaphore_release( BU_SEM_SYSCALL);
	if ( fp == (FILE *)NULL ) {
	    bu_log("%s:%d error opening %s\n", __FILE__, __LINE__,
		   buf);
	    return;
	} else 
	    bu_log("plotting \"%s\" dim:%d,%d\n", buf, 
		   dsp_sp->layer[l].dim[X],
		   dsp_sp->layer[l].dim[Y]);		
	c = l % 6;
	r = colors[c][0];
	g = colors[c][1];
	b = colors[c][2];

	for (y=0 ; y < dsp_sp->layer[l].dim[Y] ; y+= 2 ) {
	    for (x=0 ; x < dsp_sp->layer[l].dim[X] ; x+= 2 ) {
		n = y * dsp_sp->layer[l].dim[X] + x;
		d_bb = &dsp_sp->layer[l].p[n];
		plot_dsp_bb(fp, d_bb, dsp_sp, r, g, b, 0);

#if 0
		if (RT_G_DEBUG & DEBUG_HF)
		    bu_log("\t%d,%d ch_dim:%d,%d  min:(%d %d %d)  max:(%d %d %d)\n",
			   x, y,
			   d_bb->dspb_ch_dim[X],
			   d_bb->dspb_ch_dim[Y],
			   V3ARGS(d_bb->dspb_rpp.dsp_min),
			   V3ARGS(d_bb->dspb_rpp.dsp_max));
#endif
	    }
	}
	fclose(fp);
    }
}
#endif

/*	P L O T _ C E L L _ T O P 
 *
 *	Plot the results of intersecting a ray with the top of a cell
 *
 */
static void
plot_cell_top(struct isect_stuff *isect, 
	      struct dsp_bb *dsp_bb,
	      point_t A,
	      point_t B,
	      point_t C,
	      point_t D,
	      struct hit hitlist[],
	      int hitflags,
	      int style)	/* plot diagonal */
{
    fastf_t *stom = &isect->dsp->dsp_i.dsp_stom[0];
    char buf[64];
    static int plotcnt = 0;
    static int cnt = 0;
    FILE *fp;
    point_t p1, p2, p3, p4;
    int i;
    int in_seg;
    static unsigned char colors[4][3] = {
	{255, 255, 128},
	{255, 128, 255},
	{128, 255, 128},
	{128, 255, 255},
    };

    DSP_BB_CK(dsp_bb);

    bu_semaphore_acquire( BU_SEM_SYSCALL);
    if (style)
	sprintf(buf, "dsp_cell_isect%04d.pl", cnt++);
    else
	sprintf(buf, "dsp_cell_top%04d.pl", plotcnt++);

    fp=fopen(buf, "w");

    bu_semaphore_release( BU_SEM_SYSCALL);

    if ( fp == (FILE *)NULL) {
	bu_log("error opening \"%s\"\n", buf);
	return;
    } else {
	bu_log("plotting %s flags 0x%x\n\t", buf, hitflags);
    }

    plot_dsp_bb(fp, dsp_bb, isect->dsp, 128, 128, 128, 1);

    /* plot the triangulation */
    pl_color(fp, 255, 255, 255);
    MAT4X3PNT(p1, stom, A);
    MAT4X3PNT(p2, stom, B);
    MAT4X3PNT(p3, stom, C);
    MAT4X3PNT(p4, stom, D);

    pdv_3move(fp, p1);
    if (style) {
	pdv_3cont(fp, p2);
	pdv_3cont(fp, p4);
	pdv_3cont(fp, p1);
	pdv_3cont(fp, p3);
	pdv_3cont(fp, p4);	
    } else {
	pdv_3cont(fp, p2);
	pdv_3cont(fp, p4);
	pdv_3cont(fp, p3);
	pdv_3cont(fp, p1);
    }

    /* plot the hit points */

    for (in_seg = 0, i = 0 ; i < 4 ; i++ ) {
	if (hitflags & (1<<i)) {
	    if (in_seg) {
		in_seg = 0;
		MAT4X3PNT(p1, stom, hitlist[i].hit_point);
		pdv_3cont(fp, p1);
	    } else {
		in_seg = 1;
		pl_color(fp, colors[i][0], colors[i][1], colors[i][2]);
		MAT4X3PNT(p1, stom, hitlist[i].hit_point);
		pdv_3move(fp, p1);
	    }
	}
    }
    fclose(fp);
}

/*	D S P _ P R I N T _ V 4
 *
 *
 */
static void
dsp_print_v4(struct bu_vls *vls, const struct rt_dsp_internal *dsp_ip)
{
    point_t pt, v;
    RT_DSP_CK_MAGIC(dsp_ip);
    BU_CK_VLS(&dsp_ip->dsp_name);
    BU_CK_VLS(vls);

    bu_vls_printf( vls, "Displacement Map\n  file='%s' w=%d n=%d sm=%d",
		   bu_vls_addr(&dsp_ip->dsp_name),
		   dsp_ip->dsp_xcnt,
		   dsp_ip->dsp_ycnt,
		   dsp_ip->dsp_smooth);

    VSETALL(pt, 0.0);

    MAT4X3PNT(v, dsp_ip->dsp_stom, pt);

    bu_vls_printf( vls, " (origin at %g %g %g)mm\n", V3ARGS(v));

    bu_vls_printf( vls, "  stom=\n");
    bu_vls_printf( vls, "  %8.3f %8.3f %8.3f %8.3f\n",
		   V4ARGS(dsp_ip->dsp_stom) );

    bu_vls_printf( vls, "  %8.3f %8.3f %8.3f %8.3f\n",
		   V4ARGS( &dsp_ip->dsp_stom[4]) );

    bu_vls_printf( vls, "  %8.3f %8.3f %8.3f %8.3f\n",
		   V4ARGS( &dsp_ip->dsp_stom[8]) );

    bu_vls_printf( vls, "  %8.3f %8.3f %8.3f %8.3f\n",
		   V4ARGS( &dsp_ip->dsp_stom[12]) );
}

/*	D S P _ P R I N T _ V 5
 *
 *
 */
static void
dsp_print_v5(struct bu_vls *vls,
	     const struct rt_dsp_internal *dsp_ip)
{
    point_t pt, v;

    BU_CK_VLS(vls);

    RT_DSP_CK_MAGIC(dsp_ip);
    BU_CK_VLS(&dsp_ip->dsp_name);


    bu_vls_printf( vls, "Displacement Map\n" );

    switch (dsp_ip->dsp_datasrc) {
    case RT_DSP_SRC_V4_FILE:
			bu_vls_printf( vls, "  Error Error Error");
			break;
    case RT_DSP_SRC_FILE:
			bu_vls_printf( vls, "  file");
			break;
    case RT_DSP_SRC_OBJ:
			bu_vls_printf( vls, "  obj");
			break;
    default:
			bu_vls_printf( vls, "unk src type'%c'", dsp_ip->dsp_datasrc);
			break;
    }
		
    bu_vls_printf( vls, "='%s'\n  w=%d n=%d sm=%d ",
									 bu_vls_addr(&dsp_ip->dsp_name),
									 dsp_ip->dsp_xcnt,
									 dsp_ip->dsp_ycnt,
									 dsp_ip->dsp_smooth);
		
    switch (dsp_ip->dsp_cuttype) {
    case DSP_CUT_DIR_ADAPT:
			bu_vls_printf( vls, "cut=ad" ); break;
    case DSP_CUT_DIR_llUR:
			bu_vls_printf( vls, "cut=lR" ); break;
    case DSP_CUT_DIR_ULlr:
			bu_vls_printf( vls, "cut=Lr" ); break;
    default:
			bu_vls_printf( vls, "cut bogus('%c'/%d)",
										 dsp_ip->dsp_cuttype,
										 dsp_ip->dsp_cuttype ); break;
    }
		
		
    VSETALL(pt, 0.0);
		
    MAT4X3PNT(v, dsp_ip->dsp_stom, pt);

    bu_vls_printf( vls, " (origin at %g %g %g)mm\n", V3ARGS(v));
		
    bu_vls_printf( vls, "  stom=\n");
    bu_vls_printf( vls, "  %8.3f %8.3f %8.3f %8.3f\n",
									 V4ARGS(dsp_ip->dsp_stom) );
		
    bu_vls_printf( vls, "  %8.3f %8.3f %8.3f %8.3f\n",
									 V4ARGS( &dsp_ip->dsp_stom[4]) );
		
    bu_vls_printf( vls, "  %8.3f %8.3f %8.3f %8.3f\n",
									 V4ARGS( &dsp_ip->dsp_stom[8]) );
		
    bu_vls_printf( vls, "  %8.3f %8.3f %8.3f %8.3f\n",
									 V4ARGS( &dsp_ip->dsp_stom[12]) );
}

/*
 *			R T _ D S P _ P R I N T
 */
void
rt_dsp_print(register const struct soltab *stp)
{
	register const struct dsp_specific *dsp =
		(struct dsp_specific *)stp->st_specific;
	struct bu_vls vls;
 

	RT_DSP_CK_MAGIC(dsp);
	BU_CK_VLS(&dsp->dsp_i.dsp_name);
	
	bu_vls_init( &vls );
	BU_CK_VLS(&vls);
	
	bu_vls_printf(&vls, "\n---------db version: %d----------\n",
								stp->st_rtip->rti_dbip->dbi_version );
	
	switch (stp->st_rtip->rti_dbip->dbi_version) {
	case 4: 
		BU_CK_VLS(&vls);
		dsp_print_v4(&vls, &(dsp->dsp_i) );
		break;
	case 5:
		BU_CK_VLS(&vls);
		dsp_print_v5(&vls, &(dsp->dsp_i) );
		break;
	}
	
	bu_log("%s", bu_vls_addr( &vls));
	
	if (BU_VLS_IS_INITIALIZED( &vls )) bu_vls_free( &vls );
	
}


/*
 *	compute bounding boxes for each cell, then compute bounding boxes
 *	for collections of bounding boxes
 */
static void
dsp_layers(struct dsp_specific *dsp, unsigned short *d_min, unsigned short *d_max)
{
	int idx, i, j, k, curr_layer, x, y, xs, ys, xv, yv, tot;
	unsigned short dsp_min, dsp_max, cell_min, cell_max;
	unsigned short elev;
	struct dsp_bb *dsp_bb;
	struct dsp_rpp *t;
	struct dsp_bb_layer *curr, *prev;
	unsigned short subcell_size;
	
	/* First we compute the total number of struct dsp_bb's we will need */
	xs = dsp->xsiz;
	ys = dsp->ysiz;
	tot = xs * ys;
	/*    bu_log("layer %d   %dx%d\n", 0, xs, ys); */
	dsp->layers = 1;
	while ( xs > 1 || ys > 1 ) {
		xv = xs / DIM_BB_CHILDREN;
		yv = ys / DIM_BB_CHILDREN;
		if (xs % DIM_BB_CHILDREN) xv++;
		if (ys % DIM_BB_CHILDREN) yv++;
		
#ifdef FULL_DSP_DEBUGGING
		if (RT_G_DEBUG & DEBUG_HF)
	    bu_log("layer %d   %dx%d\n", dsp->layers, xv, yv);
#endif
		tot += xv * yv;
		
		if (xv > 0) xs = xv;
		else xs = 1;
		
		if (yv > 0) ys = yv;
		else ys = 1;
		dsp->layers++;
	}
	
	
#ifdef FULL_DSP_DEBUGGING
	if (RT_G_DEBUG & DEBUG_HF)
		bu_log("%d layers total\n", dsp->layers);
#endif
	
	/* allocate the struct dsp_bb's we will need */
	dsp->layer = bu_malloc(dsp->layers * sizeof(struct dsp_bb_layer),
												 "dsp_bb_layers array");
	dsp->bb_array = bu_malloc(tot * sizeof(struct dsp_bb), "dsp_bb array");
	
	/* now we fill in the "lowest" layer of struct dsp_bb's from the
	 * raw data
	 */
	dsp->layer[0].dim[X] = dsp->xsiz;
	dsp->layer[0].dim[Y] = dsp->ysiz;
	dsp->layer[0].p = dsp->bb_array;
	
	xs = dsp->xsiz;
	ys = dsp->ysiz;
	
	dsp_min = 0xffff;
	dsp_max = 0;
	
	for (y=0 ; y < YSIZ(dsp) ; y++) {
		
		cell_min = 0xffff;
		cell_max = 0;
		
		for (x=0 ; x < XSIZ(dsp) ; x++) {
			
#if 0
	    if (RT_G_DEBUG & DEBUG_HF)
				bu_log("filling %d,%d\n", x, y);
#endif
	    elev = DSP(&dsp->dsp_i, x, y);
	    cell_min = cell_max = elev;
			
	    elev = DSP(&dsp->dsp_i, x+1, y);
	    V_MIN(cell_min, elev);
	    V_MAX(cell_max, elev);
			
	    elev = DSP(&dsp->dsp_i, x, y+1);
	    V_MIN(cell_min, elev);
	    V_MAX(cell_max, elev);
			
	    elev = DSP(&dsp->dsp_i, x+1, y+1);
	    V_MIN(cell_min, elev);
	    V_MAX(cell_max, elev);
			
	    /* factor the cell min/max into the overall min/max */
	    V_MIN(dsp_min, cell_min);
	    V_MAX(dsp_max, cell_max);
			
	    /* fill in the dsp_rpp cell min/max */
	    i = y*XSIZ(dsp) + x;
	    dsp_bb = &dsp->layer[0].p[i];
	    VSET(dsp_bb->dspb_rpp.dsp_min, x, y, cell_min);
	    VSET(dsp_bb->dspb_rpp.dsp_max, x+1, y+1, cell_max);
			
	    dsp_bb->dspb_subcell_size = 0;
			
	    /* There are no "children" of a layer 0 element */
	    dsp_bb->dspb_ch_dim[X] = 0;
	    dsp_bb->dspb_ch_dim[Y] = 0;
	    for (k=0 ; k < NUM_BB_CHILDREN ; k++ ) {
				dsp_bb->dspb_children[k] = 
					(struct dsp_bb *)NULL;
	    }
	    dsp_bb->magic = MAGIC_dsp_bb;
#if 0
	    dlog("cell %d,%d min: %d,%d,%d  max: %d,%d,%d\n",
					 x, y, V3ARGS(dsp_bb->dspb_rpp.dsp_min),
					 V3ARGS(dsp_bb->dspb_rpp.dsp_max) );
#endif
			
	    /* XXX should we compute the triangle orientation and
	     * save it here too?
	     */
		}
	}
	
	*d_min = dsp_min;
	*d_max = dsp_max;
	
	
	if (RT_G_DEBUG & DEBUG_HF)
		bu_log("layer 0 filled\n");
	
	subcell_size = 1;
	
	/* now we compute successive layers from the initial layer */
	for (curr_layer = 1 ; curr_layer < dsp->layers ; curr_layer++ ) {
		/* compute the number of cells in each direction for this layer */
		
		xs = dsp->layer[curr_layer-1].dim[X];
		if (xs % DIM_BB_CHILDREN)  
	    dsp->layer[curr_layer].dim[X] =
				xs / DIM_BB_CHILDREN + 1;
		else			  
	    dsp->layer[curr_layer].dim[X] =
				xs / DIM_BB_CHILDREN;
		
		ys = dsp->layer[curr_layer-1].dim[Y];
		if (ys % DIM_BB_CHILDREN) 
	    dsp->layer[curr_layer].dim[Y] = 
				ys / DIM_BB_CHILDREN + 1;
		else			  
	    dsp->layer[curr_layer].dim[Y] = 
				ys / DIM_BB_CHILDREN;
		
		/* set the start of the array for this layer */
		dsp->layer[curr_layer].p = 
	    &dsp->layer[curr_layer-1].p[dsp->layer[curr_layer-1].dim[X] *	dsp->layer[curr_layer-1].dim[Y] ];
		
		curr = &dsp->layer[curr_layer];
		prev = &dsp->layer[curr_layer-1];
		
		if (RT_G_DEBUG & DEBUG_HF)
	    bu_log("layer %d  subcell size %d\n", curr_layer, subcell_size);
		
		/* walk the grid and fill in the values for this layer */
		for (y=0 ; y < curr->dim[Y] ; y++ ) {
	    for (x=0 ; x < curr->dim[X] ; x++ ) {
				int n, xp, yp;
				/* x,y are in the coordinates in the current
				 * layer.  xp,yp are the coordinates of the
				 * same area in the previous (lower) layer.
				 */
				xp = x * DIM_BB_CHILDREN;
				yp = y * DIM_BB_CHILDREN;
				
				/* initialize the current dsp_bb cell */
				dsp_bb = &curr->p[y*curr->dim[X]+x];
				dsp_bb->magic = MAGIC_dsp_bb;
				n = (int)pow( (double)DIM_BB_CHILDREN, (double)curr_layer);
				VSET(dsp_bb->dspb_rpp.dsp_min,
						 x * n, y * n, 0x0ffff);
				VSET(dsp_bb->dspb_rpp.dsp_max,
						 x * n, y * n, 0);
				
				/* record the dimensions of our children */
				dsp_bb->dspb_subcell_size = subcell_size;
				
				
				tot = 0;
#if 0
				dlog("  cell %d,%d  (%d,%d-%d,%d)\n", x, y, 
						 dsp_bb->dspb_rpp.dsp_min[X],
						 dsp_bb->dspb_rpp.dsp_min[Y],
						 (x+1) * n, (y+1)*n);
#endif
				i=0;
				for (j=0 ; j<DIM_BB_CHILDREN && (yp+j)<prev->dim[Y] ; j++) {
					for (i=0 ; i<DIM_BB_CHILDREN && (xp+i)<prev->dim[X]; i++) {
						
						idx = (yp+j) * prev->dim[X] + xp+i;
						
						t = &prev->p[ idx ].dspb_rpp;
						
						VMINMAX(dsp_bb->dspb_rpp.dsp_min,
										dsp_bb->dspb_rpp.dsp_max, t->dsp_min);
						VMINMAX(dsp_bb->dspb_rpp.dsp_min,
										dsp_bb->dspb_rpp.dsp_max, t->dsp_max);
						
						dsp_bb->dspb_children[tot++] = &prev->p[ idx ];
						
#if 0
						dlog("\t\tsubcell %d,%d min: %d,%d,%d  max: %d,%d,%d\n",
								 xp+i, yp+j, V3ARGS(t->dsp_min), V3ARGS(t->dsp_max) );
						
						if (RT_G_DEBUG & DEBUG_HF) 
							if (i+1 >= DIM_BB_CHILDREN || xp+i+1 >= prev->dim[X])
								bu_log("\n");
#endif
					}
				}
#if 0
				dlog("\t\txy: %d,%d, ij:%d,%d min:%d,%d,%d max:%d,%d,%d\n",
						 x, y, i, j,
						 V3ARGS(dsp_bb->dspb_rpp.dsp_min),
						 V3ARGS(dsp_bb->dspb_rpp.dsp_max) );
#endif
				
				dsp_bb->dspb_ch_dim[X] = i;
				dsp_bb->dspb_ch_dim[Y] = j;
	    }
		}
		subcell_size *= DIM_BB_CHILDREN;
	}
	
#ifdef PLOT_LAYERS
	if (RT_G_DEBUG & DEBUG_HF) {
		plot_layers(dsp);
		bu_log("_  x:%d y:%d min %d max %d\n",
					 XCNT(dsp), YCNT(dsp), dsp_min, dsp_max);
	}
#endif
}


/*
 *  			R T _ D S P _ P R E P
 *  
 *  Given a pointer to a GED database record, and a transformation matrix,
 *  determine if this is a valid DSP, and if so, precompute various
 *  terms of the formula.
 *  
 *  Returns -
 *  	0	DSP is OK
 *  	!0	Error in description
 *  
 *  Implicit return -
 *  	A struct dsp_specific is created, and it's address is stored in
 *  	stp->st_specific for use by dsp_shot().
 */
int
rt_dsp_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
{
	struct rt_dsp_internal		*dsp_ip;
	register struct dsp_specific	*dsp;
	unsigned short dsp_min, dsp_max;
	point_t pt, bbpt;
	vect_t work;
	fastf_t f;
	
	if (RT_G_DEBUG & DEBUG_HF)
		bu_log("rt_dsp_prep()\n");
	
	RT_CK_DB_INTERNAL(ip);
	dsp_ip = (struct rt_dsp_internal *)ip->idb_ptr;
	RT_DSP_CK_MAGIC(dsp_ip);
	BU_CK_VLS(&dsp_ip->dsp_name);
	
	switch (dsp_ip->dsp_datasrc) {
	case RT_DSP_SRC_V4_FILE: 
	case RT_DSP_SRC_FILE:
		BU_CK_MAPPED_FILE(dsp_ip->dsp_mp);
		
		/* we do this here and now because we will need it for the
		 * dsp_specific structure in a few lines
		 */
		bu_semaphore_acquire( RT_SEM_MODEL);
		++dsp_ip->dsp_mp->uses;
		bu_semaphore_release( RT_SEM_MODEL);
		break;
	case RT_DSP_SRC_OBJ:
		RT_CK_DB_INTERNAL(dsp_ip->dsp_bip);
		RT_CK_BINUNIF(dsp_ip->dsp_bip->idb_ptr);
		break;
	}
	
	
	BU_GETSTRUCT( dsp, dsp_specific );
	stp->st_specific = (genptr_t) dsp;
	
	/* this works ok, because the mapped file keeps track of the number of
	 * uses.  However, the binunif interface does not.  We'll
	 * have to copy the data for that one.
	 */
	dsp->dsp_i = *dsp_ip;		/* struct copy */
	
	/* this keeps the binary internal object from being freed */
	dsp_ip->dsp_bip = (struct rt_db_internal *)NULL;	
	
	
	dsp->xsiz = dsp_ip->dsp_xcnt-1;	/* size is # cells or values-1 */
	dsp->ysiz = dsp_ip->dsp_ycnt-1;	/* size is # cells or values-1 */
	
	
	/* compute the multi-resolution bounding boxes */
	dsp_layers(dsp, &dsp_min, &dsp_max);
	
	
	/* record the distance to each of the bounding planes */
	dsp->dsp_pl_dist[XMIN] = 0.0;
	dsp->dsp_pl_dist[XMAX] = (fastf_t)dsp->xsiz;
	dsp->dsp_pl_dist[YMIN] = 0.0;
	dsp->dsp_pl_dist[YMAX] = (fastf_t)dsp->ysiz;
	dsp->dsp_pl_dist[ZMIN] = 0.0;
	dsp->dsp_pl_dist[ZMAX] = (fastf_t)dsp_max;
	dsp->dsp_pl_dist[ZMID] = (fastf_t)dsp_min;
	
	/* compute enlarged bounding box and spere */
	
#define BBOX_PT(_x, _y, _z) \
	VSET(pt, (fastf_t)_x, (fastf_t)_y, (fastf_t)_z); \
	MAT4X3PNT(bbpt, dsp_ip->dsp_stom, pt); \
	VMINMAX( stp->st_min, stp->st_max, bbpt)
	
	BBOX_PT(-.1,		    -.1,		        -.1);
	BBOX_PT(dsp_ip->dsp_xcnt+.1, -.1,		        -.1);
	BBOX_PT(dsp_ip->dsp_xcnt+.1, dsp_ip->dsp_ycnt+.1, -1);
	BBOX_PT(-.1,		    dsp_ip->dsp_ycnt+.1, -1);
	BBOX_PT(-.1,		    -.1,		        dsp_max+.1);
	BBOX_PT(dsp_ip->dsp_xcnt+.1, -.1,		        dsp_max+.1);
	BBOX_PT(dsp_ip->dsp_xcnt+.1, dsp_ip->dsp_ycnt+.1, dsp_max+.1);
	BBOX_PT(-.1,		    dsp_ip->dsp_ycnt+.1, dsp_max+.1);
	
#undef BBOX_PT
	
	VADD2SCALE( stp->st_center, stp->st_min, stp->st_max, 0.5 );
	VSUB2SCALE( work, stp->st_max, stp->st_min, 0.5 );
	
	f = work[X];
	if (work[Y] > f )  f = work[Y];
	if (work[Z] > f )  f = work[Z];
	stp->st_aradius = f;
	stp->st_bradius = MAGNITUDE(work);
	
	if (RT_G_DEBUG & DEBUG_HF) {
		bu_log("  model space bbox (%g %g %g) (%g %g %g)\n",
					 V3ARGS(stp->st_min),
					 V3ARGS(stp->st_max));
	}
	
	
	switch (dsp_ip->dsp_datasrc) {
	case RT_DSP_SRC_V4_FILE: 
	case RT_DSP_SRC_FILE:
		BU_CK_MAPPED_FILE(dsp->dsp_i.dsp_mp);
		break;
	case RT_DSP_SRC_OBJ:
		RT_CK_DB_INTERNAL(dsp->dsp_i.dsp_bip);
		RT_CK_BINUNIF(dsp->dsp_i.dsp_bip->idb_ptr);
		break;
	}
	
	return 0;
}

static void
plot_seg(struct isect_stuff *isect,
				 struct hit *in_hit,
				 struct hit *out_hit,
				 const point_t bbmin,/* The bounding box of what you are adding ... */
				 const point_t bbmax,/* ... */
				 int r, int g, int b)/* ... this is strictly for debug plot purposes */
{
	fastf_t *stom = &isect->dsp->dsp_i.dsp_stom[0];
	struct bound_rpp rpp;
	char fname[32];
	FILE *fp;
	static int segnum =0;
	
	/* plot the bounding box and the seg */
	bu_semaphore_acquire( BU_SEM_SYSCALL);
	sprintf(fname, "dsp_seg%04d.pl", segnum++);
	fp=fopen(fname, "w");
	bu_semaphore_release( BU_SEM_SYSCALL);
	
	if (fp != (FILE *)NULL) {
		bu_log("plotting %s\n", fname);
		
		MAT4X3PNT(rpp.min, stom, bbmin);
		MAT4X3PNT(rpp.max, stom, bbmax);
		plot_rpp(fp, &rpp, r/2, g/2, b/2);
		
		/* re-use the rpp for the points for the segment */
		MAT4X3PNT(rpp.min, stom, in_hit->hit_point);
		MAT4X3PNT(rpp.max, stom, out_hit->hit_point);
		
		pl_color(fp, r, g, b);
		pdv_3line(fp, rpp.min, rpp.max);
		
		bu_semaphore_acquire( BU_SEM_SYSCALL);
		fclose(fp);
		bu_semaphore_release( BU_SEM_SYSCALL);
	}
}

/*	A D D _ S E G
 *
 *  Add a segment to the list of intersections in DSP space
 *
 *	Return:
 *	0	continue to intersect
 *	1	All intersections computed, terminate intersection processing
 */
#define ADD_SEG(isect, in, out, min, max, r, g, b) \
	add_seg(isect, in, out, min, max, r, g, b, __LINE__)


static int
add_seg(struct isect_stuff *isect,
	struct hit *in_hit,
	struct hit *out_hit,
	const point_t bbmin,/* The bounding box of what you are adding ... */
	const point_t bbmax,/* ... */
	int r, int g, int b,/* ... this is strictly for debug plot purposes */
	int line)

{
    struct seg *seg;
    double tt = isect->tol->dist;
    double delta;
#ifndef ORDERED_ISECT
    struct bu_list *spot;
#endif

    dlog("add_seg %g %g line %d vpriv:%g %g\n", in_hit->hit_dist, out_hit->hit_dist, line, in_hit->hit_vpriv[X], in_hit->hit_vpriv[Y]);

    tt *= tt;

#ifdef ORDERED_ISECT
    if (BU_LIST_NON_EMPTY(&isect->seglist) ) {
	/* if the new in-distance equals the old out distance
	 * we just extend the old segment 
	 */
	seg = BU_LIST_LAST(seg, &isect->seglist);
	if ( fabs(seg->seg_out.hit_dist - in_hit->hit_dist) <= tt) {

#if 0
	    seg->seg_out = *out_hit; /* struct copy  most expensive line */
	    seg->seg_out.hit_magic = RT_HIT_MAGIC;
#else
	    seg->seg_out.hit_dist = out_hit->hit_dist;
	    seg->seg_out.hit_surfno = out_hit->hit_surfno;
	    VMOVE(seg->seg_out.hit_normal, out_hit->hit_normal);
#endif
	    if (out_hit->hit_surfno == ZTOP) {
		seg->seg_out.hit_vpriv[X] = out_hit->hit_vpriv[X];
		seg->seg_out.hit_vpriv[Y] = out_hit->hit_vpriv[Y];
	    }
	    seg->seg_out.hit_vpriv[Z] = 1.0; /* flag as out-hit */

	    if (RT_G_DEBUG & DEBUG_HF) {
		bu_log("extending previous seg to %g\n", out_hit->hit_dist);
		plot_seg(isect, in_hit, out_hit, bbmin, bbmax, r, g, b);
	    }
	    return 0;
	}
    }
#else
    /* insert the segment in the list by in-hit distance */
    dlog("searching for insertion point for seg w in/out dist %g %g\n",
	       in_hit->hit_dist, out_hit->hit_dist);

    for ( BU_LIST_FOR(seg, seg, &isect->seglist) ) {
	dlog("checking %g->%g seg\n", seg->seg_in.hit_dist,
	     seg->seg_out.hit_dist);
	/* found the spot for this one */
	if ( fabs(seg->seg_out.hit_dist - in_hit->hit_dist) <= tt ) {
	    seg->seg_out = *out_hit; /* struct copy */
	    seg->seg_out.hit_magic = RT_HIT_MAGIC;
	    seg->seg_out.hit_vpriv[Z] = 1.0; /* flag as out-hit */

	    if (RT_G_DEBUG & DEBUG_HF) {
		bu_log("extending previous seg to %g\n",
		       out_hit->hit_dist);
		plot_seg(isect, in_hit, out_hit, bbmin, bbmax, r, g, b);
	    }
	    return 0;
	}
	if (in_hit->hit_dist < seg->seg_in.hit_dist) {
	    spot = &seg->l;
	    dlog("insert before this one\n");
	    goto found_spot;
	}
    }
    spot = &isect->seglist;
    seg = BU_LIST_LAST(seg, &isect->seglist);
    dlog("insert at end\n");
 found_spot:
#endif


    /* if both points are on the "floor" of the DSP, then we
     * don't have a hit segment
     */
    if (NEAR_ZERO(in_hit->hit_point[Z], isect->tol->dist) &&
	NEAR_ZERO(out_hit->hit_point[Z], isect->tol->dist) ) {
	return 0;
    }

    /* throw away any zero length segments, 
     * mostly to avoid seeing inside-out segments 
     */
    delta = out_hit->hit_dist - in_hit->hit_dist;


    if (delta == 0.0) {
	bu_log("short seg %g\n", delta);
	return 0;
    }

    /* if the segment is inside-out, we need to say something about it */
    if (delta < 0.0 && !NEAR_ZERO(delta, isect->tol->dist)) {
	bu_log(" %s:%dDSP:  Adding inside-out seg in:%g out:%g\n",
	       __FILE__, __LINE__,
	       in_hit->hit_dist, out_hit->hit_dist);

	VPRINT("\tin_pt", in_hit->hit_point);
	VPRINT("\tout_pt", out_hit->hit_point);
    }




    RT_GET_SEG(seg, isect->ap->a_resource);

#if 0
    seg->seg_in = *in_hit; /* struct copy */
    seg->seg_in.hit_magic = RT_HIT_MAGIC;
    seg->seg_out = *out_hit; /* struct copy */
    seg->seg_out.hit_magic = RT_HIT_MAGIC;

#else
    seg->seg_in.hit_dist    = in_hit->hit_dist;
    seg->seg_out.hit_dist   = out_hit->hit_dist;

    seg->seg_in.hit_surfno  = in_hit->hit_surfno;
    seg->seg_out.hit_surfno = out_hit->hit_surfno;

    VMOVE(seg->seg_in.hit_normal, in_hit->hit_normal);
    VMOVE(seg->seg_out.hit_normal, out_hit->hit_normal);

#endif
    if (in_hit->hit_surfno >= ZMAX) {
	seg->seg_in.hit_vpriv[X] = in_hit->hit_vpriv[X];
	seg->seg_in.hit_vpriv[Y] = in_hit->hit_vpriv[Y];
    }

    if (out_hit->hit_surfno >= ZMAX) {
	seg->seg_out.hit_vpriv[X] = out_hit->hit_vpriv[X];
	seg->seg_out.hit_vpriv[Y] = out_hit->hit_vpriv[Y];
    }

    seg->seg_in.hit_vpriv[Z] = 0.0; /* flag as in-hit */
    seg->seg_out.hit_vpriv[Z] = 1.0; /* flag as out-hit */

    seg->seg_stp = isect->stp;

#ifdef FULL_DSP_DEBUGGING
    if (VDOT(seg->seg_in.hit_normal, isect->r.r_dir) > 0 ) {
	bu_log("----------------------------------------------------------\n");
	bu_log("pixel %d,%d bogus seg in, inward normal\nN: %g %g %g\nd: %g %g %g\n",
	       isect->ap->a_x, isect->ap->a_y,
	       V3ARGS(seg->seg_in.hit_normal), V3ARGS(isect->r.r_dir) );
	bu_bomb("");
    }
    if (VDOT(seg->seg_out.hit_normal, isect->r.r_dir) < 0 ) {
	bu_log("----------------------------------------------------------\n");
	bu_log("pixel %d,%d bogus seg out, inward normal\nN: %g %g %g\nd: %g %g %g\n",
	       isect->ap->a_x, isect->ap->a_y,
	       V3ARGS(seg->seg_out.hit_normal), V3ARGS(isect->r.r_dir) );
	bu_bomb("");
    }
#endif

#ifdef ORDERED_ISECT
    BU_LIST_INSERT(&isect->seglist, &seg->l);
#else
    BU_LIST_INSERT(spot, &seg->l);
#endif




    if (RT_G_DEBUG & DEBUG_HF)
	plot_seg(isect, in_hit, out_hit, bbmin, bbmax, r, g, b);


    if (seg->seg_in.hit_dist > 0.0 || seg->seg_out.hit_dist > 0.0) {
	return (++isect->num_segs > isect->ap->a_onehit);
    }
    return 0;
}


/*	I S E C T _ R A Y _ T R I A N G L E
 *
 * Side Effects:
 *	dist and P may be set
 *
 * Return:
 *	1	Ray intersects triangle 
 *	0	Ray misses triangle
 *	-1	Ray/plane parallel
 */
static int
isect_ray_triangle(struct isect_stuff *isect, 
		   point_t A,
		   point_t B,
		   point_t C,
		   struct hit *hitp,
		   double alphabbeta[])
{
    point_t P;		/* plane intercept point */
    vect_t AB, AC, AP;
    plane_t N;		/* Normal for plane of triangle */
    double NdotDir;
    double alpha, beta;	/* barycentric distances */
    double hitdist;	/* distance to ray/trianlge intercept */
    double toldist;	/* distance tolerance from isect->tol */

#ifdef FULL_DSP_DEBUGGING
    if (RT_G_DEBUG & DEBUG_HF) {
	fastf_t *stom = &isect->dsp->dsp_i.dsp_stom[0];

	MAT4X3PNT(P, stom, A);
	bu_log("isect_ray_triangle...\n  A %g %g %g  (%g %g %g)\n",
	       V3ARGS(A), V3ARGS(P));

	MAT4X3PNT(P, stom, B);
	bu_log("  B %g %g %g  (%g %g %g)\n",
	       V3ARGS(B), V3ARGS(P));

	MAT4X3PNT(P, stom, C);
	bu_log("  C %g %g %g  (%g %g %g)\n",
	       V3ARGS(C), V3ARGS(P));

    }
#endif
    VSUB2(AB, B, A);
    VSUB2(AC, C, A);

    /* Compute the plane equation of the triangle */
    VCROSS(N, AB, AC);
    VUNITIZE(N);
    N[H] = VDOT(N, A);


    /* intersect ray with plane */
    NdotDir = VDOT(N, isect->r.r_dir);
    if ( BN_VECT_ARE_PERP(NdotDir, isect->tol) ) {
	/* Ray perpendicular to plane of triangle */
	return -1;
    }

    /* dist to plane icept */
    hitdist = (N[H]-VDOT(N, isect->r.r_pt)) / NdotDir;

    VJOIN1(P, isect->r.r_pt, hitdist, isect->r.r_dir);

#ifdef FULL_DSP_DEBUGGING
    if (RT_G_DEBUG & DEBUG_HF) {
	FILE *fp;
	char buf[32];
	static int plotnum = 0;
	fastf_t *stom = &isect->dsp->dsp_i.dsp_stom[0];
	point_t p1, p2;

	bu_semaphore_acquire( BU_SEM_SYSCALL);
	sprintf(buf, "dsp_tri%03d.pl", plotnum++);
	fp=fopen(buf, "w");
	bu_semaphore_release( BU_SEM_SYSCALL);

	if ( fp == (FILE *)NULL) {
	    bu_log("%s:%d error opening \"%s\"\n", __FILE__, __LINE__, buf);
	    bu_bomb("");
	} else
	    bu_log("  plotting %s\n", buf);


	pl_color(fp, 255, 255, 255);
	MAT4X3PNT(p1, stom, A); pdv_3move(fp, p1);
	MAT4X3PNT(p2, stom, B);	pdv_3cont(fp, p2);
	MAT4X3PNT(p2, stom, C);	pdv_3cont(fp, p2);
	pdv_3cont(fp, p1);

	/* plot the ray */
	pl_color(fp, 255, 255, 0);
	MAT4X3PNT(p1, stom, P);
	MAT4X3PNT(p2, stom, isect->r.r_pt);
	pdv_3line(fp, p1, p2);

	bu_semaphore_acquire( BU_SEM_SYSCALL);
	fclose(fp);
	bu_semaphore_release( BU_SEM_SYSCALL);

	bu_log("  dist:%g plane point: %g %g %g\n", hitdist, V3ARGS(p2));
    }
#endif
    /* We project the system into the XY plane at this point to determine
     * if the ray_plane_isect_pt is within the bounds of the triangle
     *
     * The general idea here is to project the vector AP onto both sides of the
     * triangle.  The distances along each side can be used to determine if
     * we are inside/outside the triangle.
     *
     *    VSUB2(AP, P, A);
     *    alpha = VDOT(AP, AB);
     *    beta = VDOT(AP, AC);
     *
     *		  C
     *		  |
     *		  |
     *		  |
     *----	  |--- P
     *	|	  |   /
     *	|	  |  / |
     * alpha	  | /  | 
     *	|	  |/   |
     *----	  A---------B
     *
     *		    b
     *		  |-e--|
     *		    t
     *		    a
     *
     *	To save on computation, we do this calculation in 2D.
     *
     * See: "Graphics Gems",  Andrew S. Glassner ed.  PP390-393 for details
     */

    toldist = isect->tol->dist;


    VSUB2(AP, P, A);
#ifdef FULL_DSP_DEBUGGING
    if (RT_G_DEBUG & DEBUG_HF) {
	VPRINT("  AP", AP);
	VPRINT("  AB", AB);
	VPRINT("  AC", AC);
    }
#endif
    /*	Oridnarily, in 2D we would say:
     *
     *    beta = AB[X] * AP[X] + AB[Y] * AP[Y];
     *    alpha = AC[X] * AP[X] + AC[Y] * AP[Y];
     *
     *	However, in this case, we know that AB and AC will always be
     *  axis-aligned, so we can short-cut.  
     *  XXX consider: we know that AB and AC
     *  will be unit length, so only the sign counts.
     */

    if (AB[X] == 0) {
	beta = AB[Y] * AP[Y];
    } else {
	beta = AB[X] * AP[X];
    }

    if (AC[X] == 0) {
	alpha = AC[Y] * AP[Y];
    } else {
	alpha = AC[X] * AP[X];
    }

    /* return 1 if we hit the triangle */
    alphabbeta[0] = alpha;
    alphabbeta[1] = beta;

#ifdef FULL_DSP_DEBUGGING
    if (alpha < -toldist ) {
	dlog("alpha < 0\n");
	return 0;
    }
    if (beta < -toldist ) {
	dlog("beta < 0\n");
	return 0;
    }
    if ( (alpha+beta) > (1.0 + toldist) ) {
	dlog("alpha+beta > 1\n");
	return 0;
    }
#else
    if (alpha < -toldist || beta < -toldist || (alpha+beta) > (1.0 + toldist))
	return 0;
#endif

    hitp->hit_dist = hitdist;
    VMOVE(hitp->hit_normal, N);
    VMOVE(hitp->hit_point, P);
    return 1;
}

/*	P E R M U T E _ C E L L
 *
 *	For adaptive diagonal selection or for Upper-Left to lower right
 *	cell cut, we must permute the verticies of the cell before handing
 *	them to the intersection algorithm.  That's what this function does.
 */
static int
permute_cell(point_t A, 
	     point_t B, 
	     point_t C, 
	     point_t D, 
	     struct dsp_specific *dsp,
	     struct dsp_rpp *dsp_rpp)
{
    int x, y;


#ifdef FULL_DSP_DEBUGGING
    if (RT_G_DEBUG & DEBUG_HF) {
	VPRINT("\tA", A);
	VPRINT("\tB", B);
	VPRINT("\tC", C);
	VPRINT("\tD", D);
    }
#endif

    switch (dsp->dsp_i.dsp_cuttype) {
    case DSP_CUT_DIR_llUR:
	return  DSP_CUT_DIR_llUR;
	break;

    case DSP_CUT_DIR_ADAPT: {
	int lo[2], hi[2];
	point_t tmp;
	double h1, h2, h3, h4;
	double cAD, cBC;  /* curvature in direction AD, and BC */

	if (RT_G_DEBUG & DEBUG_HF)
	    bu_log("cell %d,%d adaptive triangulation... ",
		   dsp_rpp->dsp_min[X],
		   dsp_rpp->dsp_min[Y]);

	/*
	 *  We look at the points in the diagonal next cells to determine
	 *  the curvature along each diagonal of this cell.  This cell is
	 *  divided into two triangles by cutting across the cell in the
	 *  direction of least curvature.
	 *
	 *	*  *  *	 *
	 *	 \      /
	 *	  \C  D/
	 *	*  *--*  *
	 *	   |\/|
	 *	   |/\|
	 *	*  *--*  *
	 *	  /A  B\
	 *	 /	\
	 *	*  *  *	 *
	 */

	lo[X] = dsp_rpp->dsp_min[X] - 1;
	lo[Y] = dsp_rpp->dsp_min[Y] - 1;
	hi[X] = dsp_rpp->dsp_max[X] + 1;
	hi[Y] = dsp_rpp->dsp_max[Y] + 1;

	/* a little bounds checking */
	if (lo[X] < 0) lo[X] = 0;
	if (lo[Y] < 0) lo[Y] = 0;
	if (hi[X] > dsp->xsiz) 
	    hi[X] = dsp->xsiz;

	if (hi[Y] > dsp->ysiz)
	    hi[Y] = dsp->ysiz;

	/* compute curvature along the A->D direction */
	h1 = DSP(&dsp->dsp_i, lo[X], lo[Y]);
	h2 = A[Z];
	h3 = D[Z];
	h4 = DSP(&dsp->dsp_i, hi[X], hi[Y]);

	cAD = fabs(h3 + h1 - 2*h2 ) + fabs( h4 + h2 - 2*h3 );


	/* compute curvature along the B->C direction */
	h1 = DSP(&dsp->dsp_i, hi[X], lo[Y]);
	h2 = B[Z];
	h3 = C[Z];
	h4 = DSP(&dsp->dsp_i, lo[X], hi[Y]);

	cBC = fabs(h3 + h1 - 2*h2 ) + fabs( h4 + h2 - 2*h3 );

	if ( cAD < cBC ) {
	    /* A-D cut is fine, no need to permute */
	    if (RT_G_DEBUG & DEBUG_HF)
		bu_log("A-D cut\n");

	    return  DSP_CUT_DIR_llUR;

	}

	/* prefer the B-C cut */
	VMOVE(tmp, A);
	VMOVE(A, B);
	VMOVE(B, D);
	VMOVE(D, C);
	VMOVE(C, tmp);
	if (RT_G_DEBUG & DEBUG_HF)
	    bu_log("B-C cut\n");

	return  DSP_CUT_DIR_ULlr;

	break;
    }
    case DSP_CUT_DIR_ULlr:
	/* assign the values for the corner points
	 *
	 *  D----C
	 *  |    |
	 *  |    |
	 *  |    |
	 *  B----A
	 */
	x = dsp_rpp->dsp_min[X];
	y = dsp_rpp->dsp_min[Y];
	VSET(B, x, y, DSP(&dsp->dsp_i, x, y) );

	x = dsp_rpp->dsp_max[X];
	VSET(A, x, y, DSP(&dsp->dsp_i, x, y) );

	y = dsp_rpp->dsp_max[Y];
	VSET(C, x, y, DSP(&dsp->dsp_i, x, y) );

	x = dsp_rpp->dsp_min[X];
	VSET(D, x, y, DSP(&dsp->dsp_i, x, y) );

	return DSP_CUT_DIR_ULlr;
	break;
    }
    bu_log("%s:%d Unknown DSP cut direction: %d\n",
	   __FILE__, __LINE__, dsp->dsp_i.dsp_cuttype);
    bu_bomb("");
    /* not reached */
    return -1;
}

/*
 *	C H E C K _ B B _ E L E V A T I O N
 *
 *	determine if a point P is above/below the slope line on the
 *	bounding box.  eg:
 *
 *	Bounding box side view:
 *
 *	+-------+
 *	|	|
 *	|	*	Determine if P ( or Q ) is above the
 *	|      /|	diagonal from the two * points at the corners
 *	| P.  /	|	of the bounding box.
 *	|    /	|
 *	|   /	|
 *	|  /  .	|
 *	| /   Q	|
 *	|/	|
 *	*	|
 *	|	|
 *	+-------+
 *
 *	Return
 *		0 if pt above line (such as P in diagram)
 *		1 if pt at/below line (such as Q in diagram)
 */
static int
check_bbpt_hit_elev(int i,	/* indicates face of cell */
		    point_t A,
		    point_t B,
		    point_t C,
		    point_t D,
		    point_t P)
{
    double slope = 0.0;
    double delta = 0.0;
    double origin = 0.0;

#ifdef FULL_DSP_DEBUGGING
    dlog("check_bbpt_hit_elev(");
#endif
    switch (i) {
    case XMIN:
	/* the minimal YZ plane.  Top view:	*   *
	 *					|    
	 *					*   *		
	 */
#ifdef FULL_DSP_DEBUGGING
	dlog("XMIN)\n");
#endif
	slope = C[Z] - A[Z];
	delta = P[Y] - A[Y];
	origin = A[Z];
	break;
    case XMAX:
	/* the maximal YZ plane.   Top view:	*   *
	 *					    |    
	 *					*   *
	 */
#ifdef FULL_DSP_DEBUGGING
	dlog("XMAX)\n");
#endif
	slope = D[Z] - B[Z];
	delta = P[Y] - B[Y];
	origin = B[Z];
	break;
    case YMIN:
	/* the minimal XZ plane.   Top view:	*   *
	 *
	 *					* - *
	 */
#ifdef FULL_DSP_DEBUGGING
	dlog("YMIN)\n");
#endif
	slope = B[Z] - A[Z];
	delta = P[X] - A[X];
	origin = A[Z];
	break;
    case YMAX:
	/* the maximal XZ plane.   Top view:	* - *
	 *	    
	 *					*   *
	 */
#ifdef FULL_DSP_DEBUGGING
	dlog("YMAX)\n");
#endif
	slope = D[Z] - C[Z];
	delta = P[X] - C[X];
	origin = C[Z];
	break;
    case ZMIN:
#ifdef FULL_DSP_DEBUGGING
	dlog("ZMIN)\n");
#endif
	return 1;
	break;
    case ZMAX:
#ifdef FULL_DSP_DEBUGGING
	dlog("ZMAX)\n");
#endif
	return 0;
	break;
    default:
	bu_log("%s:%d Coding error, bad face %d\n", __FILE__, __LINE__, i);
	bu_bomb("");
	break;
    }

    if ( (origin + slope * delta) < P[Z] ) return 0;

    return 1;
}

/*
 *	I S E C T _ R A Y _ C E L L _ T O P 
 *
 *  Return
 *	0	continue intesection calculations
 *	1	Terminate intesection computation
 */
static int
isect_ray_cell_top(struct isect_stuff *isect, struct dsp_bb *dsp_bb)
{
    point_t A, B, C, D, P;
    int x, y;
    double ab_first[2], ab_second[2];
    struct hit hits[4];	/* list of hits that are valid */
    struct hit *hitp;
    int hitf = 0;	/* bit flags for valid hits in hits */
    int cond, i;
    int hitcount = 0;
    point_t bbmin, bbmax;
    double dot, dot2;


    dlog("isect_ray_cell_top\n");
    DSP_BB_CK(dsp_bb);

    /* assign the values for the corner points
     *
     *  C----D
     *  |    |
     *  |    |
     *  |    |
     *  A----B
     */
    x = dsp_bb->dspb_rpp.dsp_min[X];
    y = dsp_bb->dspb_rpp.dsp_min[Y];
    VSET(A, x, y, DSP(&isect->dsp->dsp_i, x, y) );
    
    x = dsp_bb->dspb_rpp.dsp_max[X];
    VSET(B, x, y, DSP(&isect->dsp->dsp_i, x, y) );

    y = dsp_bb->dspb_rpp.dsp_max[Y];
    VSET(D, x, y, DSP(&isect->dsp->dsp_i, x, y) );

    x = dsp_bb->dspb_rpp.dsp_min[X];
    VSET(C, x, y, DSP(&isect->dsp->dsp_i, x, y) );


#ifdef DEBUG_FULL
    if (RT_G_DEBUG & DEBUG_HF) {
	point_t p1, p2;

	VJOIN1(p1, isect->r.r_pt, isect->r.r_min, isect->r.r_dir);
	VMOVE(hits[0].hit_point, p1);
	hits[0].hit_dist = isect->r.r_min;

	VJOIN1(p2, isect->r.r_pt, isect->r.r_max, isect->r.r_dir);
	VMOVE(hits[1].hit_point, p2);
	hits[1].hit_dist = isect->r.r_max;

	plot_cell_top(isect, dsp_bb, A, B, C, D, hits, 3, 0);
    }
#endif


    /* first order of business is to discard any "fake" hits on the 
     * bounding box, and fill in any "real" hits in our list
     */
    VJOIN1(P, isect->r.r_pt, isect->r.r_min, isect->r.r_dir);
    if ( check_bbpt_hit_elev(isect->dmin, A, B, C, D, P) ) {
	hits[0].hit_dist = isect->r.r_min;
	VMOVE(hits[0].hit_point, P);
	VMOVE(hits[0].hit_normal, dsp_pl[isect->dmin]);
	/* vpriv */
	hits[0].hit_vpriv[X] = dsp_bb->dspb_rpp.dsp_min[X];
	hits[0].hit_vpriv[Y] = dsp_bb->dspb_rpp.dsp_min[Y];
	/* private */
	hits[0].hit_surfno = isect->dmin;

	hitcount++;

	hitf = 1;
	if (RT_G_DEBUG & DEBUG_HF) {
	    dot = VDOT(hits[0].hit_normal, isect->r.r_dir);
	    bu_log("hit ray/bb min  Normal: %g %g %g %s\n", 
		   V3ARGS(hits[0].hit_normal), 
		   ((dot > 0.0) ? "outbound" : "inbound"));
	}
    } else {
	dlog("miss ray/bb min\n");
    }


    /* make sure the point P is below the cell top */
    VJOIN1(P, isect->r.r_pt, isect->r.r_max, isect->r.r_dir);
    if (check_bbpt_hit_elev(isect->dmax, A, B, C, D, P) ) {
	/* P is at or below the top surface */
	hits[3].hit_dist = isect->r.r_max;
	VMOVE(hits[3].hit_point, P);
	VMOVE(hits[3].hit_normal, dsp_pl[isect->dmax]);
	/* vpriv */
	hits[3].hit_vpriv[X] = dsp_bb->dspb_rpp.dsp_min[X];
	hits[3].hit_vpriv[Y] = dsp_bb->dspb_rpp.dsp_min[Y];
	/* private */
	hits[3].hit_surfno = isect->dmax;

	hitcount++;

	hitf |= 8;
	if (RT_G_DEBUG & DEBUG_HF) {
	    dot = VDOT(hits[3].hit_normal, isect->r.r_dir);
	    bu_log("hit ray/bb max  Normal: %g %g %g  %s\n", 
		   V3ARGS(hits[3].hit_normal),
		   ((dot > 0.0) ? "outbound" : "inbound"));
	}
    } else {
	dlog("miss ray/bb max\n");
    }



    (void)permute_cell(A, B, C, D, isect->dsp, &dsp_bb->dspb_rpp);

    if ((cond=isect_ray_triangle(isect, B, D, A, &hits[1], ab_first)) > 0.0){
	/* hit triangle */

	/* record cell */
	hits[1].hit_vpriv[X] = dsp_bb->dspb_rpp.dsp_min[X];
	hits[1].hit_vpriv[Y] = dsp_bb->dspb_rpp.dsp_min[Y];
	hits[1].hit_surfno = ZTOP; /* indicate we hit the top */

	hitcount++;
	hitf |= 2; 
	dlog("  hit triangle 1 (alpha: %g beta:%g alpha+beta: %g) vpriv %g %g\n",
	     ab_first[0], ab_first[1], ab_first[0] + ab_first[1],
	     hits[1].hit_vpriv[X], hits[1].hit_vpriv[Y]);
    } else {
	dlog("  miss triangle 1 (alpha: %g beta:%g a+b: %g) cond:%d\n",
	     ab_first[0], ab_first[1], ab_first[0] + ab_first[1], cond);
    }
    if ((cond=isect_ray_triangle(isect, C, A, D, &hits[2], ab_second)) > 0.0) {
	/* hit triangle */

	/* record cell */
	hits[2].hit_vpriv[X] = dsp_bb->dspb_rpp.dsp_min[X];
	hits[2].hit_vpriv[Y] = dsp_bb->dspb_rpp.dsp_min[Y];
	hits[2].hit_surfno = ZTOP; /* indicate we hit the top */

	hitcount++;

	hitf |= 4;
	dlog("  hit triangle 2 (alpha: %g beta:%g alpha+beta: %g) vpriv %g %g\n",
	     ab_second[0], ab_second[1], ab_second[0] + ab_second[1],
	     hits[2].hit_vpriv[X], hits[2].hit_vpriv[Y]);

	if (hitf & 2) {
	    /* if this hit occurs before the hit on the other triangle
	     * swap the order
	     */
	    if (hits[1].hit_dist > hits[2].hit_dist) {
		struct hit tmp;
		tmp = hits[1]; /* struct copy */
		hits[1] = hits[2]; /* struct copy */
		hits[2] = tmp; /* struct copy */
		dlog("re-ordered triangle hits\n");

	    } else 
		dlog("triangle hits in order\n");
	}


    } else {
	dlog("  miss triangle 2 (alpha: %g beta:%g alpha+beta: %g) cond:%d\n",
	     ab_second[0], ab_second[1], ab_second[0] + ab_second[1], cond);
    }

    if (RT_G_DEBUG & DEBUG_HF) {
	bu_log("hitcount: %d flags: 0x%0x\n", hitcount, hitf);

	plot_cell_top(isect, dsp_bb, A, B, C, D, hits, hitf, 1);
	for (i=0 ; i < 4 ; i++) {
	    if (hitf & (1<<i)) {
		double v = VDOT(isect->r.r_dir, hits[i].hit_normal);

		bu_log("%d dist:%g N:%g %g %g ", 
		       i, hits[i].hit_dist, V3ARGS(hits[i].hit_normal));
	
		if (v > 0.0) bu_log("outbound\n");
		else if (v < 0.0)  bu_log("inbound\n");
		else bu_log("perp\n");
	    }
	}
	bu_log("assembling segs\n");
    }


    /* fill out the segment structures */

    hitp = 0;
    for (i = 0 ; i < 4 ; i++ ) {
	if (hitf & (1<<i)) {
	    if (hitp) {

		dot2 = VDOT(isect->r.r_dir, hits[i].hit_normal);

		/* if we have two entry points then pick the first one */
		if ( dot2 < 0.0 ) {
		    dlog("dot2(%g) < 0.0\n", dot2);
		    if (hitp->hit_dist > hits[i].hit_dist) {
			dlog("skipping duplicate entry point at dist %g\n",
			     hitp->hit_dist);

			hitp = &hits[i];
		    } else {
			dlog("skipping duplicate entry point at dist %g\n",
			     hits[i].hit_dist);
		    }

		    continue;
		}

		/* create seg with hits[i].hit_point); as out point */
		if (RT_G_DEBUG & DEBUG_HF) {
		    /* int/float conv */
		    VMOVE(bbmin, dsp_bb->dspb_rpp.dsp_min);
		    VMOVE(bbmax, dsp_bb->dspb_rpp.dsp_max);
		}
		
		if (ADD_SEG(isect, hitp, &hits[i], bbmin, bbmax,255, 255, 255))
		    return 1;

		hitp = 0;
	    } else {
		dot = VDOT(isect->r.r_dir, hits[i].hit_normal);
		if (dot >= 0.0)
		    continue;
		
		/* remember hits[i].hit_point); as in point */
		if (RT_G_DEBUG & DEBUG_HF) {
		    bu_log("in-hit at dist %g\n", hits[i].hit_dist);
		}
		hitp = &hits[i];
	    }
	}
    }

    if (hitp && hitcount > 1) {
	point_t p1, p2;
	
	bu_log("----------------ERROR incomplete segment-------------\n");
	bu_log("  pixel %d %d\n", isect->ap->a_x, isect->ap->a_y);

	VJOIN1(p1, isect->r.r_pt, isect->r.r_min, isect->r.r_dir);
	VMOVE(hits[0].hit_point, p1);
	hits[0].hit_dist = isect->r.r_min;

	VJOIN1(p2, isect->r.r_pt, isect->r.r_max, isect->r.r_dir);
	VMOVE(hits[1].hit_point, p2);
	hits[1].hit_dist = isect->r.r_max;

	if (RT_G_DEBUG & DEBUG_HF)
	    plot_cell_top(isect, dsp_bb, A, B, C, D, hits, 3, 0);
    }
    return 0;
}

/*
 *			D S P _ I N _ R P P
 *
 *  Compute the intersections of a ray with a rectangular parallelpiped (RPP)
 *  that has faces parallel to the coordinate planes
 *
 *  The algorithm here was developed by Gary Kuehl for GIFT.
 *  A good description of the approach used can be found in
 *  "??" by XYZZY and Barsky,
 *  ACM Transactions on Graphics, Vol 3 No 1, January 1984.
 *
 * Note -
 *  The computation of entry and exit distance is mandatory, as the final
 *  test catches the majority of misses.
 *
 * Note -
 *  A hit is returned if the intersect is behind the start point.
 *
 *  Returns -
 *	 0  if ray does not hit RPP,
 *	!0  if ray hits RPP.
 *
 *  Implicit return -
 *	rp->r_min = dist from start of ray to point at which ray ENTERS solid
 *	rp->r_max = dist from start of ray to point at which ray LEAVES solid
 *	isect->dmin
 *	isect->dmax
 */
int
dsp_in_rpp(struct isect_stuff *isect,
	   register const fastf_t *min,
	   register const fastf_t *max)
{
    struct xray		*rp = &isect->r;    
    /* inverses of rp->r_dir[] */
    register const fastf_t *invdir = isect->inv_dir;
    register const fastf_t	*pt = &rp->r_pt[0];
    register fastf_t	sv;
    register fastf_t	rmin = -INFINITY;
    register fastf_t	rmax =  INFINITY;
    int dmin = -1;
    int dmax = -1;

    /* Start with infinite ray, and trim it down */

    /* X axis */
    if( *invdir < 0.0 )  {
	/* Heading towards smaller numbers */
	/* if( *min > *pt )  miss */
	if(rmax > (sv = (*min - *pt) * *invdir) ) {
	    rmax = sv;
	    dmax = XMIN;
	}
	if( rmin < (sv = (*max - *pt) * *invdir) ) {
	    rmin = sv;
	    dmin = XMAX;
	}
    }  else if( *invdir > 0.0 )  {
	/* Heading towards larger numbers */
	/* if( *max < *pt )  miss */
	if (rmax > (sv = (*max - *pt) * *invdir) ) {
	    rmax = sv;
	    dmax = XMAX;
	}
	if( rmin < ((sv = (*min - *pt) * *invdir)) ) {
	    rmin = sv;
	    dmin = XMIN;
	}
    }  else  {
	/*
	 *  Direction cosines along this axis is NEAR 0,
	 *  which implies that the ray is perpendicular to the axis,
	 *  so merely check position against the boundaries.
	 */
	if( (*min > *pt) || (*max < *pt) )
	    return(0);	/* MISS */
    }

    /* Y axis */
    pt++; invdir++; max++; min++;
    if( *invdir < 0.0 )  {
	if (rmax > (sv = (*min - *pt) * *invdir) ) {
	    /* towards smaller */
	    rmax = sv;
	    dmax = YMIN;
	}
	if (rmin < (sv = (*max - *pt) * *invdir) ) {
	    rmin = sv;
	    dmin = YMAX;
	}
    }  else if( *invdir > 0.0 )  {
	/* towards larger */
	if(rmax > (sv = (*max - *pt) * *invdir) ) {
	    rmax = sv;
	    dmax = YMAX;
	}
	if( rmin < ((sv = (*min - *pt) * *invdir)) ) {
	    rmin = sv;
	    dmin = YMIN;
	}
    }  else  {
	if( (*min > *pt) || (*max < *pt) )
	    return(0);	/* MISS */
    }

    /* Z axis */
    pt++; invdir++; max++; min++;
    if( *invdir < 0.0 )  {
	/* towards smaller */
	if(rmax > (sv = (*min - *pt) * *invdir) ) {
	    rmax = sv;
	    dmax = ZMIN;
	} 
	if( rmin < (sv = (*max - *pt) * *invdir) ) {
	    rmin = sv;
	    dmin = ZMAX;
	}
    }  else if( *invdir > 0.0 )  {
	/* towards larger */
	if(rmax > (sv = (*max - *pt) * *invdir) ) {
	    rmax = sv;
	    dmax = ZMAX;
	}
	if( rmin < ((sv = (*min - *pt) * *invdir)) ) {
	    rmin = sv;
	    dmin = ZMIN;
	}
    }  else  {
	if( (*min > *pt) || (*max < *pt) )
	    return(0);	/* MISS */
    }

    /* If equal, RPP is actually a plane */
    if( rmin > rmax )
	return(0);	/* MISS */

    /* HIT.  Only now do rp->r_min and rp->r_max have to be written */
    rp->r_min = rmin;
    rp->r_max = rmax;
    
    isect->dmin = dmin;
    isect->dmax = dmax;
    return(1);		/* HIT */
}
#ifdef ORDERED_ISECT
static int
isect_ray_dsp_bb(struct isect_stuff *isect, struct dsp_bb *dsp_bb);

/*
 *	R E C U R S E _ D S P _ B B
 *
 *  Return
 *	0	continue intesection calculations
 *	1	Terminate intesection computation
 */
static int
recurse_dsp_bb(struct isect_stuff *isect,
	       struct dsp_bb *dsp_bb,
	       point_t minpt, /* entry point of dsp_bb */
	       point_t maxpt, /* exit point of dsp_bb */
	       point_t bbmin, /* min point of bb (Z=0) */
	       point_t bbmax) /* max point of bb */
{
    double	tDX;		/* dist along ray to span 1 cell in X dir */
    double	tDY;		/* dist along ray to span 1 cell in Y dir */
    double	tX, tY;		/* dist from hit pt. to next cell boundary */
    double	curr_dist;
    short	cX, cY;		/* coordinates of current cell */
    short	cs;		/* cell X,Y dimension */
    short	stepX, stepY;	/* dist to step in child array for each dir */
    short	stepPX, stepPY;
    double 	out_dist;
    struct dsp_bb **p;
    fastf_t *stom = &isect->dsp->dsp_i.dsp_stom[0];
    point_t pt, v;
    int loop = 0;
    
    DSP_BB_CK(dsp_bb);

    /* compute the size of a cell in each direction */
    cs = dsp_bb->dspb_subcell_size;

    /* compute current cell */
    cX = (minpt[X] - bbmin[X]) / cs;
    cY = (minpt[Y] - bbmin[Y]) / cs;

    /* a little bounds checking because a hit on XMAX or YMAX looks like
     * it should be in the next cell outside the box
     */
    if (cX >= dsp_bb->dspb_ch_dim[X]) cX = dsp_bb->dspb_ch_dim[X] - 1;
    if (cY >= dsp_bb->dspb_ch_dim[Y]) cY = dsp_bb->dspb_ch_dim[Y] - 1;

#ifdef FULL_DSP_DEBUGGING
    dlog("recurse_dsp_bb  cell size: %d  current cell: %d %d\n",
	 cs, cX, cY);
    dlog("dspb_ch_dim x:%d  y:%d\n",
	 dsp_bb->dspb_ch_dim[X], dsp_bb->dspb_ch_dim[Y]);
#endif

    tX = tY = curr_dist = isect->r.r_min;

    if (isect->r.r_dir[X] < 0.0) {
	stepPX = stepX = -1;
	/* tDX is the distance along the ray we have to travel
	 * to traverse a cell (travel a unit distance) along the
	 * X axis of the grid
	 */
	tDX = -cs / isect->r.r_dir[X];

	/* tX is the distance along the ray to the first cell 
	 * boundary in the X direction beyond our hit point (minpt)
	 */
	tX += ( (bbmin[X] + (cX * cs)) - minpt[X]) / isect->r.r_dir[X];
    } else {
	stepPX = stepX = 1;
	tDX = cs / isect->r.r_dir[X];
	    
	if (isect->r.r_dir[X] > 0.0)
	    tX += ((bbmin[X] + ((cX+1) * cs)) - minpt[X]) / isect->r.r_dir[X];
	else
	    tX = MAX_FASTF; /* infinite distance to next X boundary */
    }

    if (isect->r.r_dir[Y] < 0) {
	/* distance in dspb_children we have to move to step in Y dir */
	stepY = -1;
	stepPY = -dsp_bb->dspb_ch_dim[X];
	tDY = -cs / isect->r.r_dir[Y];
	tY += ( (bbmin[Y] + (cY * cs)) - minpt[Y]) / isect->r.r_dir[Y];
    } else {
	stepY = 1;
	stepPY = dsp_bb->dspb_ch_dim[X];
	tDY = cs / isect->r.r_dir[Y];
	
	if (isect->r.r_dir[Y] > 0.0)
	    tY += ((bbmin[Y] + ((cY+1) * cs)) - minpt[Y]) / isect->r.r_dir[Y];
	else
	    tY = MAX_FASTF;
    }

    /* factor in the tolerance to the out-distance */
    out_dist = isect->r.r_max - isect->tol->dist;

    p = &dsp_bb->dspb_children[dsp_bb->dspb_ch_dim[X] * cY + cX];
#ifdef FULL_DSP_DEBUGGING
    dlog("tX:%g tY:%g\n", tX, tY);

#endif

    do {
	/* intersect with the current cell */
	if (RT_G_DEBUG & DEBUG_HF) {
	    if (loop)
		bu_log("\nisect sub-cell %d %d  in dist:%g ",
		       cX, cY, curr_dist, out_dist);
	    else {
		bu_log("isect sub-cell %d %d  in dist:%g ",
		       cX, cY, curr_dist, out_dist);
		loop = 1;
	    }
	    VJOIN1(pt, isect->r.r_pt, curr_dist, isect->r.r_dir);
	    MAT4X3PNT(v, stom, pt);
	    bu_log("pt %g %g %g\n", V3ARGS(v));
	}

	/* get pointer to the current child cell.  Note the extra level
	 * of indirection.  We want to march p through dspb_children using
	 * pointer addition, but dspb_children contains pointers.  We need
	 * to be sure to increment the offset in the array, not the child
	 * pointer.
	 */

	if (RT_G_DEBUG & DEBUG_HF)
	    bu_log_indent_delta(4);

	if (isect_ray_dsp_bb(isect, *p)) return 1;

	if (RT_G_DEBUG & DEBUG_HF)
	    bu_log_indent_delta(-4);

	/* figure out which cell is next */
	if (tX < tY) {
	    cX += stepX;  /* track cell offset for debugging */
	    p += stepPX;
#ifdef FULL_DSP_DEBUGGING
	    dlog("stepping X to %d because %g < %g\n", cX, tX, tY);
#endif
	    curr_dist = tX;
	    tX += tDX;
	} else {
	    cY += stepY;  /* track cell offset for debugging */
	    p += stepPY;
#ifdef FULL_DSP_DEBUGGING
	    dlog("stepping Y to %d because %g >= %g\n", cY, tX, tY);
#endif
	    curr_dist = tY;
	    tY += tDY;
	}
#ifdef FULL_DSP_DEBUGGING
	dlog("curr_dist %g, out_dist %g\n", curr_dist, out_dist);
#endif
    } while ( curr_dist < out_dist &&
	      cX < dsp_bb->dspb_ch_dim[X] && cX >= 0 &&
	      cY < dsp_bb->dspb_ch_dim[Y] && cY >= 0 );

    return 0;
}
#endif

/*
 *	I S E C T _ R A Y _ D S P _ B B
 *
 *  Intersect a ray with a DSP bounding box.  This is the primary child of
 *  rt_dsp_shot()
 *
 *  Return
 *	0	continue intesection calculations
 *	1	Terminate intesection computation
 */
static int
isect_ray_dsp_bb(struct isect_stuff *isect, struct dsp_bb *dsp_bb)
{
    point_t bbmin, bbmax;
    point_t minpt, maxpt;
    double min_z;
    /* the rest of these support debugging output */
    FILE *fp;
    static int plotnum;
    fastf_t *stom; 
    point_t pt;
    struct xray *r = &isect->r; /* Does this buy us anything? */

    if (dsp_bb) {
	DSP_BB_CK(dsp_bb);
    } else {
	bu_log("%s:%d null ptr pixel %d %d\n", 
	       __FILE__, __LINE__, isect->ap->a_x,  isect->ap->a_y); 
	bu_bomb("");
    }

    if (RT_G_DEBUG & DEBUG_HF) {
	bu_log("\nisect_ray_dsp_bb( (%d,%d,%d) (%d,%d,%d))\n",
	       V3ARGS(dsp_bb->dspb_rpp.dsp_min),
	       V3ARGS(dsp_bb->dspb_rpp.dsp_max));
    }

    /* check to see if we miss the RPP for this area entirely */
    VMOVE(bbmax, dsp_bb->dspb_rpp.dsp_max);
    VSET(bbmin,
	 dsp_bb->dspb_rpp.dsp_min[X], 
	 dsp_bb->dspb_rpp.dsp_min[Y], 0.0);


    if ( ! dsp_in_rpp(isect, bbmin, bbmax) ) {
	/* missed it all, just return */

	if (RT_G_DEBUG & DEBUG_HF) {
	    bu_log("missed... ");
	    fclose(draw_dsp_bb(&plotnum, dsp_bb, isect->dsp, 0, 150, 0));
	}

	return 0;
    }

    /* At this point we know that we've hit the overall bounding box */

    VJOIN1(minpt, r->r_pt, r->r_min, r->r_dir);
    VJOIN1(maxpt, r->r_pt, r->r_max, r->r_dir);
    /* We could do the following:
     *
     * however, we only need the Z values now, and benchmarking show
     * that this is an expensive
     */
    if (RT_G_DEBUG & DEBUG_HF) {

	stom = &isect->dsp->dsp_i.dsp_stom[0];

	bu_log("hit b-box ");
	fp = draw_dsp_bb(&plotnum, dsp_bb, isect->dsp, 200, 200, 100);

	pl_color(fp, 150, 150, 255);
	MAT4X3PNT(pt, stom, minpt);
	pdv_3move(fp, pt);
	MAT4X3PNT(pt, stom, maxpt);
	pdv_3cont(fp, pt);

	fclose(fp);
    }


    /* if both hits are UNDER the top of the "foundation" pillar, we can
     * just add a segment for that range and return
     */
    min_z = dsp_bb->dspb_rpp.dsp_min[Z];

    if (minpt[Z] < min_z && maxpt[Z] < min_z) {
	/* add hit segment */
	struct hit seg_in, seg_out;

	seg_in.hit_magic = RT_HIT_MAGIC;
	seg_in.hit_dist = r->r_min;
	VMOVE(seg_in.hit_point, minpt);
	VMOVE(seg_in.hit_normal, dsp_pl[isect->dmin]);
	/* hit_priv   */
	/* hit_private */
	seg_in.hit_surfno = isect->dmin;
	/* hit_rayp */

	seg_out.hit_dist = r->r_max;

	VMOVE(seg_out.hit_point, maxpt);
	VMOVE(seg_out.hit_normal, dsp_pl[isect->dmax]);
	/* hit_priv   */
	/* hit_private */
	seg_out.hit_surfno = isect->dmax;
	/* hit_rayp */

	if (RT_G_DEBUG & DEBUG_HF) {
	    /* we need these for debug output
	     * VMOVE(seg_in.hit_point, minpt);
	     * VMOVE(seg_out.hit_point, maxpt);
	     */
	    /* create a special bounding box for plotting purposes */
	    VMOVE(bbmax,  dsp_bb->dspb_rpp.dsp_max);
	    VMOVE(bbmin,  dsp_bb->dspb_rpp.dsp_min);
	    bbmax[Z] = bbmin[Z];
	    bbmin[Z] = 0.0;
	}

	/* outta here */
	return (ADD_SEG(isect, &seg_in, &seg_out, bbmin, bbmax, 0, 255, 255));
    }


    /* We've hit something where we might be going through the
     * boundary.  We've got to intersect the children
     */
    if (dsp_bb->dspb_ch_dim[0]) {
#ifdef ORDERED_ISECT
	return (recurse_dsp_bb(isect, dsp_bb, minpt, maxpt, bbmin, bbmax));
#else
	int i;
	/* there are children, so we recurse */
	i = dsp_bb->dspb_ch_dim[X] * dsp_bb->dspb_ch_dim[Y] - 1;
	if (RT_G_DEBUG & DEBUG_HF)
	    bu_log_indent_delta(4);

	for ( ; i >= 0 ; i--)
	    isect_ray_dsp_bb(isect, dsp_bb->dspb_children[i]);

	if (RT_G_DEBUG & DEBUG_HF)
	    bu_log_indent_delta(-4);

	return 0;

#endif
    }

    /***********************************************************************
     *
     *	 This section is for level 0 intersections only
     *
     ***********************************************************************/

    /* intersect the DSP grid surface geometry */

    /* Check for a hit on the triangulated zone on top.
     * This gives us intersections on the triangulated top, and the sides
     * and bottom of the bounding box for the triangles.
     *
     * We do this first because we already know that the ray does NOT
     * just pass through the "foundation " pillar underneath (see test above)
     */
    bbmin[Z] = dsp_bb->dspb_rpp.dsp_min[Z];
    if (dsp_in_rpp(isect, bbmin, bbmax) ) {
	/* hit rpp */
	
	isect_ray_cell_top(isect, dsp_bb);
    }


    /* check for hits on the "foundation" pillar under the top.
     * The ray may have entered through the top of the pillar, possibly
     * after having come down through the triangles above
     */
    bbmax[Z] = dsp_bb->dspb_rpp.dsp_min[Z];
    bbmin[Z] = 0.0;
    if (dsp_in_rpp(isect, bbmin, bbmax) ) {
	/* hit rpp */
	struct hit in_hit, out_hit;

	VJOIN1(minpt, r->r_pt, r->r_min, r->r_dir);
	VJOIN1(maxpt, r->r_pt, r->r_max, r->r_dir);

	in_hit.hit_dist = r->r_min;
	in_hit.hit_surfno = isect->dmin;
	VMOVE(in_hit.hit_point, minpt);
	VMOVE(in_hit.hit_normal, dsp_pl[isect->dmin]);

	out_hit.hit_dist = r->r_max;
	out_hit.hit_surfno = isect->dmax;
	VMOVE(out_hit.hit_point, maxpt);
	VMOVE(out_hit.hit_normal, dsp_pl[isect->dmax]);

	/* add a segment to the list */
	return (ADD_SEG(isect, &in_hit, &out_hit, bbmin, bbmax, 255, 255, 0));
    }

    return 0;
}

/*
 *  			R T _ D S P _ S H O T
 *  
 *  Intersect a ray with a dsp.
 *  If an intersection occurs, a struct seg will be acquired
 *  and filled in.
 *  
 *  Returns -
 *  	0	MISS
 *	>0	HIT
 */
int
rt_dsp_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
{
    register struct dsp_specific *dsp =
	(struct dsp_specific *)stp->st_specific;
    register struct seg *segp;
    int	i;
    vect_t	dir;	/* temp storage */
    vect_t	v;
    struct isect_stuff isect;
    double	delta;

    RT_DSP_CK_MAGIC(dsp);
    BU_CK_VLS(&dsp->dsp_i.dsp_name);

    switch (dsp->dsp_i.dsp_datasrc) {
    case RT_DSP_SRC_V4_FILE: 
    case RT_DSP_SRC_FILE:
	BU_CK_MAPPED_FILE(dsp->dsp_i.dsp_mp);
	break;
    case RT_DSP_SRC_OBJ:
	RT_CK_DB_INTERNAL(dsp->dsp_i.dsp_bip);
	RT_CK_BINUNIF(dsp->dsp_i.dsp_bip->idb_ptr);
	break;
    }

    /* 
     * map ray into the coordinate system of the dsp 
     */
    MAT4X3PNT(isect.r.r_pt, dsp->dsp_i.dsp_mtos, rp->r_pt);
    MAT4X3VEC(dir, dsp->dsp_i.dsp_mtos, rp->r_dir);
    VMOVE(isect.r.r_dir, dir);
    VUNITIZE(isect.r.r_dir);

    /* wrap a bunch of things together */
    isect.ap = ap;
    isect.stp = stp;
    isect.dsp = (struct dsp_specific *)stp->st_specific;
    isect.tol = &ap->a_rt_i->rti_tol;
    isect.num_segs = 0;

    VINVDIR(isect.inv_dir, isect.r.r_dir);
    BU_LIST_INIT(&isect.seglist);


    if (RT_G_DEBUG & DEBUG_HF) {
	bu_log("rt_dsp_shot(pt:(%g %g %g)\n\tdir[%g]:(%g %g %g))\n    pixel(%d,%d)\n",
	       V3ARGS(rp->r_pt),
	       MAGNITUDE(rp->r_dir),
	       V3ARGS(rp->r_dir),
	       ap->a_x, ap->a_y);

	bn_mat_print("mtos", dsp->dsp_i.dsp_mtos);
	bu_log("Solid space ray pt:(%g %g %g)\n", V3ARGS(isect.r.r_pt));
	bu_log("\tdir[%g]: [%g %g %g]\n\tunit_dir(%g %g %g)\n",
	       MAGNITUDE(dir),
	       V3ARGS(dir),
	       V3ARGS(isect.r.r_dir));
    }

    /* We look at the topmost layer of the bounding-box tree and
     * make sure that it has dimension 1.  Otherwise, something is wrong
     */
    if (isect.dsp->layer[isect.dsp->layers-1].dim[X] != 1 ||
	isect.dsp->layer[isect.dsp->layers-1].dim[Y] != 1) {
	bu_log("%s:%d how do i find the topmost layer?\n",
	       __FILE__, __LINE__);
	bu_bomb("");
    }


    /* intersect the ray with the bounding rpps */
    (void)isect_ray_dsp_bb(&isect, isect.dsp->layer[isect.dsp->layers-1].p);

    /* if we missed it all, give up now */
    if (BU_LIST_IS_EMPTY(&isect.seglist))
	return 0;

    /* map hit distances back to model space */
    i = 0;
    for (BU_LIST_FOR(segp, seg, &isect.seglist)) {
	i += 2;
	if (RT_G_DEBUG & DEBUG_HF) {
	    bu_log("\nsolid in:%6g out:%6g\t",
		   segp->seg_in.hit_dist,
		   segp->seg_out.hit_dist);
	}

	/* form vector for hit point from start in solid space */
	VSCALE(dir, isect.r.r_dir, segp->seg_in.hit_dist);
	/* transform vector into model space */
	MAT4X3VEC(v, dsp->dsp_i.dsp_stom, dir);
	/* get magnitude */
	segp->seg_in.hit_dist = MAGNITUDE(v);
	/* XXX why is this necessary? */
	if (VDOT(v, rp->r_dir) < 0.0) segp->seg_in.hit_dist *= -1.0;

	VSCALE(dir, isect.r.r_dir, segp->seg_out.hit_dist);
	MAT4X3VEC(v, dsp->dsp_i.dsp_stom, dir);
	segp->seg_out.hit_dist = MAGNITUDE(v);
	if (VDOT(v, rp->r_dir) < 0.0) segp->seg_out.hit_dist *= -1.0;


	delta = segp->seg_out.hit_dist - segp->seg_in.hit_dist;

	if (delta < 0.0 && !NEAR_ZERO(delta, ap->a_rt_i->rti_tol.dist)) {
	    bu_log("Pixel %d %d seg inside out in:%g out:%g seg_len:%g\n",
		   ap->a_x, ap->a_y, segp->seg_in.hit_dist, segp->seg_out.hit_dist,
		   delta);
	}

#if 0
	/* transform normals into model space */
	MAT4X3VEC(v, dsp->dsp_i.dsp_mtos, segp->seg_in.hit_normal);
	VMOVE(segp->seg_in.hit_normal, v);
	VUNITIZE( segp->seg_in.hit_normal );

	MAT4X3VEC(v, dsp->dsp_i.dsp_mtos, segp->seg_out.hit_normal);
	VMOVE(segp->seg_out.hit_normal, v);
	VUNITIZE( segp->seg_out.hit_normal );
#endif
	if (RT_G_DEBUG & DEBUG_HF) {
	    bu_log("model in:%6g out:%6g\t",
		   segp->seg_in.hit_dist,
		   segp->seg_out.hit_dist);
	}
    }

    if (RT_G_DEBUG & DEBUG_HF) {
	double NdotD;
	double d;
	static const plane_t plane = {0.0, 0.0, -1.0, 0.0};

	NdotD = VDOT(plane, rp->r_dir);
	d = - ( (VDOT(plane, rp->r_pt) - plane[H]) / NdotD);	
	bu_log("rp -> Z=0 dist: %g\n", d);
    }

    /* transfer list of hitpoints */
    BU_LIST_APPEND_LIST( &(seghead->l), &isect.seglist);

    return i;
}

#define RT_DSP_SEG_MISS(SEG)	(SEG).seg_stp=RT_SOLTAB_NULL

/*
 *			R T _ D S P _ V S H O T
 *
 *  Vectorized version.
 */
void
rt_dsp_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
                  	               /* An array of solid pointers */
                		       /* An array of ray pointers */
                                    /* array of segs (results returned) */
        		  	       /* Number of ray/object pairs */
                       	    
{
    if (RT_G_DEBUG & DEBUG_HF)
	bu_log("rt_dsp_vshot()\n");

    (void)rt_vstub( stp, rp, segp, n, ap );
}



/***********************************************************************
 *
 * Compute the model-space normal at a gridpoint
 *
 */
static void
compute_normal_at_gridpoint(vect_t N,
			    struct dsp_specific *dsp,
			    int x,
			    int y,
			    FILE *fd,
			    int boolean,
			    double len)
{
    /*  Gridpoint specified is "B" we compute normal by taking the
     *  cross product of the vectors  A->C, D->E
     *
     * 		E
     *
     *		|
     *
     *	A   -	B   -	C
     *
     *		|
     *
     *		D
     */
	
    point_t A, C, D, E, tmp, pt, endpt;
    vect_t Vac, Vde;

    if (RT_G_DEBUG & DEBUG_HF) {
	bu_log("normal at %d %d\n", x, y);
	mat_print("\tstom", dsp->dsp_i.dsp_stom);
    }
    VSET(tmp, x, y, DSP(&dsp->dsp_i, x, y));

    if (x == 0) {	VMOVE(A, tmp); }
    else {		VSET(A, x-1, y, DSP(&dsp->dsp_i, x-1, y) );	}

    if (x >= XSIZ(dsp)) { VMOVE(C, tmp); }
    else {		  VSET(C, x+1, y,  DSP(&dsp->dsp_i, x+1, y) );}

    if (y == 0) {	VMOVE(D, tmp); }
    else {		VSET(D, x, y-1, DSP(&dsp->dsp_i, x, y-1) );	}

    if (y >= YSIZ(dsp)) { VMOVE(E, tmp); }
    else {		 VSET(E, x, y+1, DSP(&dsp->dsp_i, x, y+1) );	}

    MAT4X3PNT(pt, dsp->dsp_i.dsp_stom, tmp);


    /* Computing in world coordinates */
    VMOVE(tmp, A);
    MAT4X3PNT(A, dsp->dsp_i.dsp_stom, tmp);

    VMOVE(tmp, C);
    MAT4X3PNT(C, dsp->dsp_i.dsp_stom, tmp);

    VMOVE(tmp, D);
    MAT4X3PNT(D, dsp->dsp_i.dsp_stom, tmp);

    VMOVE(tmp, E);
    MAT4X3PNT(E, dsp->dsp_i.dsp_stom, tmp);

    VSUB2(Vac, C, A);
    VSUB2(Vde, E, D);

    VUNITIZE(Vac);
    VUNITIZE(Vde);
    VCROSS(N, Vac, Vde);

    if (RT_G_DEBUG & DEBUG_HF) {
	VPRINT("\tA", A);
	VPRINT("\tC", C);
	VPRINT("\tD", D);
	VPRINT("\tE", E);
	VPRINT("\tVac", Vac);
	VPRINT("\tVde", Vde);
	VPRINT("\tModel Cross N", N);
    }
    VUNITIZE(N);

    if (RT_G_DEBUG & DEBUG_HF) {
	VPRINT("\tModel Unit N", N);
    }
    if (fd) {
	VJOIN1(endpt, pt, len, N);

	pl_color(fd, 220, 220, 90);
	pdv_3line(fd, A, C);
	pdv_3line(fd, D, E);

	pdv_3line(fd, pt, endpt);
    }


}

/*
 *  			R T _ D S P _ N O R M
 *  
 *  Given ONE ray distance, return the normal and entry/exit point.
 */
void
rt_dsp_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
{
    vect_t N, t, tmp, A;
    struct dsp_specific *dsp = (struct dsp_specific *)stp->st_specific;
    vect_t Anorm, Bnorm, Dnorm, Cnorm, ABnorm, CDnorm;
    double Xfrac, Yfrac;
    int x, y;
    point_t pt;
    double dot;
    double len;
    FILE *fd = (FILE *)NULL;


    RT_DSP_CK_MAGIC(dsp);
    BU_CK_VLS(&dsp->dsp_i.dsp_name);

    switch (dsp->dsp_i.dsp_datasrc) {
    case RT_DSP_SRC_V4_FILE: 
    case RT_DSP_SRC_FILE:
	BU_CK_MAPPED_FILE(dsp->dsp_i.dsp_mp);
	break;
    case RT_DSP_SRC_OBJ:
	RT_CK_DB_INTERNAL(dsp->dsp_i.dsp_bip);
	RT_CK_BINUNIF(dsp->dsp_i.dsp_bip->idb_ptr);
	break;
    }

    if (RT_G_DEBUG & DEBUG_HF) {
	bu_log("rt_dsp_norm(%g %g %g)\n", V3ARGS(hitp->hit_normal));
	VJOIN1( hitp->hit_point, rp->r_pt, hitp->hit_dist, rp->r_dir );
	VPRINT("\thit point", hitp->hit_point);
	bu_log("hit dist: %g\n", hitp->hit_dist);
	bu_log("%s:%d vpriv: %g,%g %g\n",
	       __FILE__, __LINE__, V3ARGS(hitp->hit_vpriv));
    }

    if ( hitp->hit_surfno < XMIN || hitp->hit_surfno > ZTOP ) {
	bu_log("%s:%d bogus surface of DSP %d\n",
	       __FILE__, __LINE__, hitp->hit_surfno);
	bu_bomb("");
    }

    /* compute hit point */
    VJOIN1( hitp->hit_point, rp->r_pt, hitp->hit_dist, rp->r_dir );


    if ( hitp->hit_surfno != ZTOP || !dsp->dsp_i.dsp_smooth ) {
	/* We've hit one of the sides or bottom, or the user didn't
	 * ask for smoothing of the elevation data,
	 * so there's no interpolation to do.  Just transform the normal to
	 * model space, and comput the actual hit point
	 */

	/* transform normal into model space */
	MAT4X3VEC(tmp, dsp->dsp_i.dsp_mtos, hitp->hit_normal);
	VUNITIZE( tmp );
	VMOVE(hitp->hit_normal, tmp);

	if (RT_G_DEBUG & DEBUG_HF)
	    bu_log("\tno Interpolation needed.  Normal: %g,%g,%g\n", 
		   V3ARGS(hitp->hit_normal));
	return;
    }

    if (RT_G_DEBUG & DEBUG_HF)
	bu_log("\tNormal Interpolation flag: %d\n", dsp->dsp_i.dsp_smooth);


    /* compute the distance between grid points in model space */
    VSET(tmp, 1.0, 0.0, 0.0);
    MAT4X3VEC(t, dsp->dsp_i.dsp_stom, tmp);
    len = MAGNITUDE(t);

    if (RT_G_DEBUG & DEBUG_HF) {
	fd = bu_fopen_uniq("plotting normals in %s", 
		      "dsp_gourand%02d.pl", plot_file_num++);

	/* plot the ray */
	pl_color(fd, 255, 0, 0);
	pdv_3line(fd, rp->r_pt, hitp->hit_point);

	/* plot the normal we started with */
	pl_color(fd, 0, 255, 0);
	VJOIN1(tmp, hitp->hit_point, len, hitp->hit_normal);
	pdv_3line(fd, hitp->hit_point, tmp);

    }

    /* get the cell we hit */
    x = hitp->hit_vpriv[X];
    y = hitp->hit_vpriv[Y];

    compute_normal_at_gridpoint(Anorm, dsp, x, y, fd, 1, len);
    compute_normal_at_gridpoint(Anorm, dsp, x, y, fd, 0, len);
    compute_normal_at_gridpoint(Bnorm, dsp, x+1, y, fd, 0, len);
    compute_normal_at_gridpoint(Dnorm, dsp, x+1, y+1, fd, 0, len);
    compute_normal_at_gridpoint(Cnorm, dsp, x, y+1, fd, 0, len);

    /* transform the hit point into DSP space for determining interpolation */
    MAT4X3PNT(pt, dsp->dsp_i.dsp_mtos, hitp->hit_point);
    
    Xfrac = (pt[X] - x);
    Yfrac = (pt[Y] - y);
    if (RT_G_DEBUG & DEBUG_HF)
	bu_log("Xfract:%g Yfract:%g\n", Xfrac, Yfrac);

    if (Xfrac < 0.0) Xfrac = 0.0;
    else if (Xfrac > 1.0) Xfrac = 1.0;

    if (Yfrac < 0.0) Yfrac = 0.0;
    else if (Yfrac > 1.0) Yfrac = 1.0;


    if (dsp->dsp_i.dsp_smooth == 2) {
	/* This is an experiment to "flatten" the curvature 
	 * of the dsp near the grid points
	 */
#define SMOOTHSTEP(x)  ((x)*(x)*(3 - 2*(x)))
	Xfrac = SMOOTHSTEP( Xfrac );
	Yfrac = SMOOTHSTEP( Yfrac );
#undef SMOOTHSTEP
    }

    /* we compute the normal along the "X edges" of the cell */
    VSCALE(Anorm, Anorm, (1.0-Xfrac) );
    VSCALE(Bnorm, Bnorm,      Xfrac  );
    VADD2(ABnorm, Anorm, Bnorm);
    VUNITIZE(ABnorm);

    VSCALE(Cnorm, Cnorm, (1.0-Xfrac) );
    VSCALE(Dnorm, Dnorm,      Xfrac  );
    VADD2(CDnorm, Dnorm, Cnorm);
    VUNITIZE(CDnorm);

    /* now we interpolate the two X edge normals to get the final one */
    VSCALE(ABnorm, ABnorm, (1.0-Yfrac) );
    VSCALE(CDnorm, CDnorm, Yfrac );
    VADD2(N, ABnorm, CDnorm);

    VUNITIZE(N);
    
    dot = VDOT(N, rp->r_dir);
    if (RT_G_DEBUG & DEBUG_HF)
	bu_log("interpolated %g %g %g  dot:%g\n", V3ARGS(N), dot);
    
    if ( (hitp->hit_vpriv[Z] == 0.0 && dot > 0.0)/* in-hit needs fix */ ||
	 (hitp->hit_vpriv[Z] == 1.0 && dot < 0.0)/* out-hit needs fix */){
	/* bring the normal back to being perpindicular 
	 * to the ray to avoid "flipped normal" warnings
	 */
	VCROSS(A, rp->r_dir, N);
	VCROSS(N, A, rp->r_dir);

	VUNITIZE(N);

	dot = VDOT(N, rp->r_dir);


	if (RT_G_DEBUG & DEBUG_HF)
	    bu_log("corrected: %g %g %g dot:%g\n", V3ARGS(N), dot);
    }
    VMOVE(hitp->hit_normal, N);

    if (RT_G_DEBUG & DEBUG_HF) {
	    pl_color(fd, 255, 255, 255);
	    VJOIN1(tmp, hitp->hit_point, len, hitp->hit_normal);
	    pdv_3line(fd, hitp->hit_point, tmp);

	    bu_semaphore_acquire( BU_SEM_SYSCALL);
	    fclose(fd);
	    bu_semaphore_release( BU_SEM_SYSCALL);
    }
}

/*
 *			R T _ D S P _ C U R V E
 *
 *  Return the curvature of the dsp.
 */
void
rt_dsp_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
{

    if (RT_G_DEBUG & DEBUG_HF)
	bu_log("rt_dsp_curve()\n");

    cvp->crv_c1 = cvp->crv_c2 = 0;

    /* any tangent direction */
    bn_vec_ortho( cvp->crv_pdir, hitp->hit_normal );
}

/*
 *  			R T _ D S P _ U V
 *  
 *  For a hit on the surface of a dsp, return the (u,v) coordinates
 *  of the hit point, 0 <= u,v <= 1.
 *  u = azimuth
 *  v = elevation
 */
void
rt_dsp_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
{
    register struct dsp_specific *dsp =
	(struct dsp_specific *)stp->st_specific;
    point_t pt;
    vect_t tmp;
    double r;
    fastf_t min_r_U, min_r_V;
    vect_t norm;
    vect_t rev_dir;
    fastf_t dot_N;
    vect_t UV_dir;
    vect_t U_dir, V_dir;
    fastf_t U_len, V_len;
    double one_over_len;

    MAT4X3PNT(pt, dsp->dsp_i.dsp_mtos, hitp->hit_point);

    /* compute U, V */
    uvp->uv_u = pt[X] / (double)XSIZ(dsp);
    CLAMP(uvp->uv_u, 0.0, 1.0);

    uvp->uv_v = pt[Y] / (double)YSIZ(dsp);
    CLAMP(uvp->uv_v, 0.0, 1.0);


    /* du, dv indicate the extent of the ray radius in UV coordinates.
     * To compute this, transform unit vectors from solid space to model
     * space.  We remember the length of the resultant vectors and then
     * unitize them to get u,v directions in model coordinate space.
     */
    VSET( tmp, XSIZ(dsp), 0.0, 0.0 );	/* X direction vector */
    MAT4X3VEC( U_dir,  dsp->dsp_i.dsp_stom, tmp ); /* into model space */
    U_len = MAGNITUDE( U_dir );		/* remember model space length */
    one_over_len = 1.0/U_len;
    VSCALE( U_dir, U_dir, one_over_len ); /* scale to unit length in model space */

    VSET( tmp, 0.0, YSIZ(dsp), 0.0 );	/* Y direction vector */
    MAT4X3VEC( V_dir,  dsp->dsp_i.dsp_stom, tmp );
    V_len = MAGNITUDE( V_dir );
    one_over_len = 1.0/V_len;
    VSCALE( V_dir, V_dir, one_over_len ); /* scale to unit length in model space */

    /* divide the hit-point radius by the U/V unit length distance */
    r = ap->a_rbeam + ap->a_diverge * hitp->hit_dist;
    min_r_U = r / U_len;
    min_r_V = r / V_len;

    /* compute UV_dir, a vector in the plane of the hit point (surface)
     * which points in the anti-rayward direction
     */
    VREVERSE( rev_dir, ap->a_ray.r_dir );
    VMOVE( norm, hitp->hit_normal );
    dot_N = VDOT( rev_dir, norm );
    VJOIN1( UV_dir, rev_dir, -dot_N, norm );
    VUNITIZE( UV_dir );

    if (NEAR_ZERO( dot_N, SMALL_FASTF ) ) {
	/* ray almost perfectly 90 degrees to surface */
	uvp->uv_du = min_r_U;
	uvp->uv_dv = min_r_V;
    } else {
	/* somehow this computes the extent of U and V in the radius */
	uvp->uv_du = (r / U_len) * VDOT( UV_dir, U_dir ) / dot_N;
	uvp->uv_dv = (r / V_len) * VDOT( UV_dir, V_dir ) / dot_N;
    }



    if (uvp->uv_du < 0.0 )
	uvp->uv_du = -uvp->uv_du;
    if (uvp->uv_du < min_r_U )
	uvp->uv_du = min_r_U;

    if (uvp->uv_dv < 0.0 )
	uvp->uv_dv = -uvp->uv_dv;
    if (uvp->uv_dv < min_r_V )
	uvp->uv_dv = min_r_V;

    if (RT_G_DEBUG & DEBUG_HF)
	bu_log("rt_dsp_uv(pt:%g,%g siz:%d,%d)\n U_len=%g V_len=%g\n r=%g rbeam=%g diverge=%g dist=%g\n u=%g v=%g du=%g dv=%g\n",
	       pt[X], pt[Y], XSIZ(dsp), YSIZ(dsp), 
	       U_len, V_len,
	       r, ap->a_rbeam, ap->a_diverge, hitp->hit_dist,
	       uvp->uv_u, uvp->uv_v,
	       uvp->uv_du, uvp->uv_dv);
}

/*
 *		R T _ D S P _ F R E E
 */
void
rt_dsp_free(register struct soltab *stp)
{
    register struct dsp_specific *dsp =
	(struct dsp_specific *)stp->st_specific;

    if (RT_G_DEBUG & DEBUG_HF)
	bu_log("rt_dsp_free()\n");

    switch (dsp->dsp_i.dsp_datasrc) {
    case RT_DSP_SRC_V4_FILE: 
    case RT_DSP_SRC_FILE:
			if (dsp->dsp_i.dsp_mp) {
				BU_CK_MAPPED_FILE(dsp->dsp_i.dsp_mp);
				bu_close_mapped_file(dsp->dsp_i.dsp_mp);
			} else if (dsp->dsp_i.dsp_buf) {
				bu_free(dsp->dsp_i.dsp_buf, "dsp fake data");
			}
			break;
    case RT_DSP_SRC_OBJ:
			break;
    }
		
    bu_free( (char *)dsp, "dsp_specific" );
}

/*
 *			R T _ D S P _ C L A S S
 */
int
rt_dsp_class(void)
{
    if (RT_G_DEBUG & DEBUG_HF)
	bu_log("rt_dsp_class()\n");

    return(0);
}

/*
 *			R T _ D S P _ P L O T
 */
int
rt_dsp_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
    struct rt_dsp_internal	*dsp_ip =
	(struct rt_dsp_internal *)ip->idb_ptr;
    point_t m_pt;
    point_t s_pt;
    point_t o_pt;
    int x, y;
    int step;
    int xlim = dsp_ip->dsp_xcnt - 1;
    int ylim = dsp_ip->dsp_ycnt - 1;
    int xfudge, yfudge;
    int drawing;

    if (RT_G_DEBUG & DEBUG_HF)
	bu_log("rt_dsp_plot()\n");

    RT_CK_DB_INTERNAL(ip);
    RT_DSP_CK_MAGIC(dsp_ip);

    if (! dsp_ip->dsp_mp ) {
	bu_log("cannot find data for DSP\n");
	return 0;
    }

#define MOVE(_pt) \
	MAT4X3PNT(m_pt, dsp_ip->dsp_stom, _pt); \
	RT_ADD_VLIST( vhead, m_pt, BN_VLIST_LINE_MOVE )

#define DRAW(_pt) \
	MAT4X3PNT(m_pt, dsp_ip->dsp_stom, _pt); \
	RT_ADD_VLIST( vhead, m_pt, BN_VLIST_LINE_DRAW )


    /* Draw the Bottom */
    VSETALL(s_pt, 0.0);
    MOVE(s_pt);

    s_pt[X] = xlim;
    DRAW(s_pt);

    s_pt[Y] = ylim;
    DRAW(s_pt);

    s_pt[X] = 0.0;
    DRAW(s_pt);

    s_pt[Y] = 0.0;
    DRAW(s_pt);


    /* Draw the corners */
    s_pt[Z] = DSP(dsp_ip, 0, 0);
    DRAW(s_pt);

    VSET(s_pt, xlim, 0.0, 0.0);
    MOVE(s_pt);
    s_pt[Z] = DSP(dsp_ip, xlim, 0);
    DRAW(s_pt);


    VSET(s_pt, xlim, ylim, 0.0);
    MOVE(s_pt);
    s_pt[Z] = DSP(dsp_ip, xlim, ylim);
    DRAW(s_pt);

    VSET(s_pt, 0.0, ylim, 0.0);
    MOVE(s_pt);
    s_pt[Z] = DSP(dsp_ip, 0, ylim);
    DRAW(s_pt);


    /* Draw the outside line of the top 
     * We draw the four sides of the top at full resolution.
     * This helps edge matching.
     * The inside of the top, we draw somewhat coarser
     */
    for (y=0 ; y < dsp_ip->dsp_ycnt ; y += ylim ) {
	VSET(s_pt, 0.0, y, DSP(dsp_ip, 0, y));
	MOVE(s_pt);

	for (x=0 ; x < dsp_ip->dsp_xcnt ; x++) {
	    s_pt[X] = x;
	    s_pt[Z] = DSP(dsp_ip, x, y);
	    DRAW(s_pt);
	}
    }


    for (x=0 ; x < dsp_ip->dsp_xcnt ; x += xlim ) {
	VSET(s_pt, x, 0.0, DSP(dsp_ip, x, 0));
	MOVE(s_pt);

	for (y=0 ; y < dsp_ip->dsp_ycnt ; y++) {
	    s_pt[Y] = y;
	    s_pt[Z] = DSP(dsp_ip, x, y);
	    DRAW(s_pt);
	}
    }

    /* now draw the body of the top */
    if (ttol->rel )  {
	int	rstep;
	rstep = dsp_ip->dsp_xcnt;
	V_MAX( rstep, dsp_ip->dsp_ycnt );
	step = (int)(ttol->rel * rstep);
    } else { 
	int goal = 10000;
	goal -= 5;
	goal -= 8 + 2 * (dsp_ip->dsp_xcnt+dsp_ip->dsp_ycnt);

	if (goal <= 0) return 0;

	/* Compute data stride based upon producing no more than 'goal' vectors */
	step = ceil(
		    sqrt( 2*(xlim)*(ylim) /
			  (double)goal )
		    );
    }
    if (step < 1 )  step = 1;


    xfudge = (dsp_ip->dsp_xcnt % step + step) / 2 ;
    yfudge = (dsp_ip->dsp_ycnt % step + step) / 2 ;

    if (xfudge < 1) xfudge = 1;
    if (yfudge < 1) yfudge = 1;

    /* draw the horizontal (y==const) lines */
    for (y=yfudge ; y < ylim ; y += step ) {
	VSET(s_pt, 0.0, y, DSP(dsp_ip, 0, y));
	VMOVE(o_pt, s_pt);
	if (o_pt[Z]) {
	    drawing = 1;
	    MOVE(o_pt);
	} else {
	    drawing = 0;
	}

	for (x=xfudge ; x < xlim ; x+=step ) {
	    s_pt[X] = x;
	    
	    if ( (s_pt[Z] = DSP(dsp_ip, x, y)) ) {
		if (drawing) {
		    DRAW(s_pt);
		} else {
		    MOVE(o_pt);
		    DRAW(s_pt);
		    drawing = 1;
		}
	    } else {
		if (drawing) {
		    DRAW(s_pt);
		    drawing = 0;
		}
	    }

	    VMOVE(o_pt, s_pt);
	}
		
	s_pt[X] = xlim;
	if ( (s_pt[Z] = DSP(dsp_ip, xlim, y)) ) {
	    if (drawing) {
		DRAW(s_pt);
	    } else {
		MOVE(o_pt);
		DRAW(s_pt);
		drawing = 1;
	    }
	} else {
	    if (drawing) {
		DRAW(s_pt);
		drawing = 0;
	    }
	}

    }

    for (x=xfudge ; x < xlim ; x += step ) {
	VSET(s_pt, x, 0.0, DSP(dsp_ip, x, 0));
	VMOVE(o_pt, s_pt);
	if (o_pt[Z]) {
	    drawing = 1;
	    MOVE(o_pt);
	} else {
	    drawing = 0;
	}

		
	for (y=yfudge ; y < ylim ; y+=step) {
	    s_pt[Y] = y;

	    if ( (s_pt[Z] = DSP(dsp_ip, x, y)) ) {
		if (drawing) {
		    DRAW(s_pt);
		} else {
		    MOVE(o_pt);
		    DRAW(s_pt);
		    drawing = 1;
		}
	    } else {
		if (drawing) {
		    DRAW(s_pt);
		    drawing = 0;
		}
	    }

	    VMOVE(o_pt, s_pt);
	}
		
	s_pt[Y] = ylim;
	if ( (s_pt[Z] = DSP(dsp_ip, x, ylim)) ) {
	    if (drawing) {
		DRAW(s_pt);
	    } else {
		MOVE(o_pt);
		DRAW(s_pt);
		drawing = 1;
	    }
	} else {
	    if (drawing) {
		DRAW(s_pt);
		drawing = 0;
	    }
	}
    }

#undef MOVE
#undef DRAW
    return(0);
}

/*
 *			R T _ D S P _ T E S S
 *
 *  Returns -
 *	-1	failure
 *	 0	OK.  *r points to nmgregion that holds this tessellation.
 */
int
rt_dsp_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
    LOCAL struct rt_dsp_internal	*dsp_ip;

    if (RT_G_DEBUG & DEBUG_HF)
	bu_log("rt_dsp_tess()\n");

    RT_CK_DB_INTERNAL(ip);
    dsp_ip = (struct rt_dsp_internal *)ip->idb_ptr;
    RT_DSP_CK_MAGIC(dsp_ip);

    return(-1);
}


/* 	G E T _ F I L E _ D A T A
 *
 *	Retrieve data for DSP from external file.
 *	Returns:
 *		0 Success
 *		!0 Failure
 */
static int
get_file_data(struct rt_dsp_internal	*dsp_ip,
	      struct rt_db_internal	*ip,
	      const struct bu_external	*ep,
	      register const mat_t	mat,
	      const struct db_i		*dbip)
{
    struct bu_mapped_file		*mf;
    int				count, in_cookie, out_cookie;


    /* get file */
    mf = dsp_ip->dsp_mp = 
	bu_open_mapped_file_with_path(dbip->dbi_filepath,
				      bu_vls_addr(&dsp_ip->dsp_name), "dsp");
    if (!mf) {
	bu_log("mapped file open failed\n");
	return 0;
    }

    if (dsp_ip->dsp_mp->buflen != dsp_ip->dsp_xcnt*dsp_ip->dsp_ycnt*2) {
	bu_log("DSP buffer wrong size: %d s/b %d ",
	       dsp_ip->dsp_mp->buflen, dsp_ip->dsp_xcnt*dsp_ip->dsp_ycnt*2);
	return -1;
    }

    in_cookie = bu_cv_cookie("nus"); /* data is network unsigned short */
    out_cookie = bu_cv_cookie("hus");

    if ( bu_cv_optimize(in_cookie) != bu_cv_optimize(out_cookie) ) {
	int got;
	/* if we're on a little-endian machine we convert the
	 * input file from network to host format
	 */
	count = dsp_ip->dsp_xcnt * dsp_ip->dsp_ycnt;
	mf->apbuflen = count * sizeof(unsigned short);
	mf->apbuf = bu_malloc(mf->apbuflen, "apbuf");

	got = bu_cv_w_cookie(mf->apbuf, out_cookie, mf->apbuflen,
			     mf->buf,    in_cookie, count);
	if (got != count) {
	    bu_log("got %d != count %d", got, count);
	    bu_bomb("\n");
	}
	dsp_ip->dsp_buf = dsp_ip->dsp_mp->apbuf;
    } else {
	dsp_ip->dsp_buf = dsp_ip->dsp_mp->buf;
    }
    return 0;
}

/*	G E T _ O B J _ D A T A
 *
 *	Retrieve data for DSP from a database object.
 */
static int
get_obj_data(struct rt_dsp_internal	*dsp_ip,
	     struct rt_db_internal	*ip,
	     const struct bu_external	*ep,
	     register const mat_t	mat,
	     const struct db_i		*dbip)
{
    struct rt_binunif_internal	*bip;
    int				in_cookie, out_cookie, got;

    BU_GETSTRUCT(dsp_ip->dsp_bip, rt_db_internal);

    if (rt_retrieve_binunif(dsp_ip->dsp_bip, dbip,
			    bu_vls_addr( &dsp_ip->dsp_name) ))
	return -1;

    if (RT_G_DEBUG & DEBUG_HF)
	bu_log("db_internal magic: 0x%08x  major: %d minor:%d\n",
	       dsp_ip->dsp_bip->idb_magic,
	       dsp_ip->dsp_bip->idb_major_type,
	       dsp_ip->dsp_bip->idb_minor_type);

    bip = dsp_ip->dsp_bip->idb_ptr;

    if (RT_G_DEBUG & DEBUG_HF)
	bu_log("binunif magic: 0x%08x  type: %d count:%d data[0]:%u\n",
	       bip->magic, bip->type, bip->count, bip->u.uint16[0]);


    in_cookie = bu_cv_cookie("nus"); /* data is network unsigned short */
    out_cookie = bu_cv_cookie("hus");

    if ( bu_cv_optimize(in_cookie) != bu_cv_optimize(out_cookie) ) {
	/* if we're on a little-endian machine we convert the
	 * input file from network to host format
	 */

	got = bu_cv_w_cookie(bip->u.uint16, out_cookie,
			     bip->count * sizeof(unsigned short),
			     bip->u.uint16, in_cookie, bip->count);

	if (got != bip->count) {
	    bu_log("got %d != count %d", got, bip->count);
	    bu_bomb("\n");
	}
    }

    dsp_ip->dsp_buf = bip->u.uint16;
    return 0;
}

/*
 *	D S P _ G E T _ D A T A
 *
 *  Handle things common to both the v4 and v5 database.
 *
 *  This include applying the modelling transform, and fetching the
 *  actual data.
 *
 *  Return:
 *	0	success
 *	!0	failure
 */
static int
dsp_get_data(struct rt_dsp_internal	*dsp_ip,
	     struct rt_db_internal	*ip,
	     const struct bu_external	*ep,
	     register const mat_t	mat,
	     const struct db_i		*dbip)
{
    mat_t	tmp;
    char	*p;
		
    /* Apply Modeling transform */
    MAT_COPY(tmp, dsp_ip->dsp_stom);
    bn_mat_mul(dsp_ip->dsp_stom, mat, tmp);
		
    bn_mat_inv(dsp_ip->dsp_mtos, dsp_ip->dsp_stom);
		
    p = bu_vls_addr(&dsp_ip->dsp_name);
		
    switch (dsp_ip->dsp_datasrc) {
    case RT_DSP_SRC_FILE:
    case RT_DSP_SRC_V4_FILE:
			/* Retrieve the data from an external file */
			if (RT_G_DEBUG & DEBUG_HF)
				bu_log("getting data from file \"%s\"\n", p);
			
			if (get_file_data(dsp_ip, ip, ep, mat, dbip) != 0) {
				p = "file";
			} else {
				return 0;
			}			

			break;
    case RT_DSP_SRC_OBJ:
			/* Retrieve the data from an internal db object */
			if (RT_G_DEBUG & DEBUG_HF)
				bu_log("getting data from object \"%s\"\n", p);
			
			if (get_obj_data(dsp_ip, ip, ep, mat, dbip) != 0) {
				p = "object";
			}
			else {
				RT_CK_DB_INTERNAL(dsp_ip->dsp_bip);
				RT_CK_BINUNIF(dsp_ip->dsp_bip->idb_ptr);
				return 0;
			}
			break;
    default:
			bu_log("%s:%d Odd dsp data src '%c' s/b '%c' or '%c'\n", 
						 __FILE__, __LINE__, dsp_ip->dsp_datasrc,
						 RT_DSP_SRC_FILE, RT_DSP_SRC_OBJ);
			return -1;
    }
		
    bu_log("Cannot retrieve DSP data from %s \"%s\"\n", p,
					 bu_vls_addr(&dsp_ip->dsp_name));
		
    dsp_ip->dsp_mp = (struct bu_mapped_file *)NULL;
    dsp_ip->dsp_buf = bu_calloc(sizeof(short),
																dsp_ip->dsp_xcnt*dsp_ip->dsp_ycnt,
																"dsp fake data");
		
    return 1;
}

/*
 *			R T _ D S P _ I M P O R T
 *
 *  Import an DSP from the database format to the internal format.
 *  Apply modeling transformations as well.
 */
int
rt_dsp_import(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
{
	LOCAL struct rt_dsp_internal	*dsp_ip;
	union record			*rp;
	struct bu_vls			str;
	
	
	
	if (RT_G_DEBUG & DEBUG_HF)	
		bu_log("rt_dsp_import_v4()\n");
	
	
	
#define IMPORT_FAIL(_s) \
	bu_log("rt_dsp_import(%d) '%s' %s\n", __LINE__, \
               bu_vls_addr(&dsp_ip->dsp_name), _s);\
	bu_free( (char *)dsp_ip , "rt_dsp_import: dsp_ip" ); \
	ip->idb_type = ID_NULL; \
	ip->idb_ptr = (genptr_t)NULL; \
	return -2
	
	BU_CK_EXTERNAL( ep );
	rp = (union record *)ep->ext_buf;
	
	if (RT_G_DEBUG & DEBUG_HF)
		bu_log("rt_dsp_import(%s)\n", rp->ss.ss_args);
	/*----------------------------------------------------------------------*/
	
	
	
	/* Check record type */
	if (rp->u_id != DBID_STRSOL )  {
		bu_log("rt_dsp_import: defective record\n");
		return(-1);
	}
	
	RT_CK_DB_INTERNAL( ip );
	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_DSP;
	ip->idb_meth = &rt_functab[ID_DSP];
	ip->idb_ptr = bu_malloc( sizeof(struct rt_dsp_internal), "rt_dsp_internal");
	dsp_ip = (struct rt_dsp_internal *)ip->idb_ptr;
	dsp_ip->magic = RT_DSP_INTERNAL_MAGIC;
	
	/* set defaults */
	/* XXX bu_struct_parse does not set the null?
	 * memset(&dsp_ip->dsp_name[0], 0, DSP_NAME_LEN); 
	 */
	dsp_ip->dsp_xcnt = dsp_ip->dsp_ycnt = 0;
	
	dsp_ip->dsp_cuttype = DSP_CUT_DIR_ADAPT;
	dsp_ip->dsp_smooth = 1;
	MAT_IDN(dsp_ip->dsp_stom);
	MAT_IDN(dsp_ip->dsp_mtos);
	
	bu_vls_init( &str );
	bu_vls_strcpy( &str, rp->ss.ss_args );
	if (bu_struct_parse( &str, rt_dsp_parse, (char *)dsp_ip ) < 0) {
		if (BU_VLS_IS_INITIALIZED( &str )) bu_vls_free( &str );
		IMPORT_FAIL("parse error");
	}
	
	
	/* Validate parameters */
	if (dsp_ip->dsp_xcnt == 0 || dsp_ip->dsp_ycnt == 0) {
		IMPORT_FAIL("zero dimension on map");
	}
	
	if (dsp_get_data(dsp_ip, ip, ep, mat, dbip)!=0) {
		IMPORT_FAIL("unable to load displacement map data");
	}
	
	if (RT_G_DEBUG & DEBUG_HF) {
		bu_vls_trunc(&str, 0);
		bu_vls_struct_print( &str, rt_dsp_ptab, (char *)dsp_ip);
		bu_log("  imported as(%s)\n", bu_vls_addr(&str));
		
	}
	
	if (BU_VLS_IS_INITIALIZED( &str )) bu_vls_free( &str );

	RT_CK_DB_INTERNAL(dsp_ip->dsp_bip);
	RT_CK_BINUNIF(dsp_ip->dsp_bip->idb_ptr);
	
	return(0);			/* OK */
}


/*
 *			R T _ D S P _ E X P O R T
 *
 *  The name is added by the caller, in the usual place.
 */
int
rt_dsp_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
{
    struct rt_dsp_internal	*dsp_ip;
    struct rt_dsp_internal	dsp;
    union record		*rec;
    struct bu_vls		str;


    RT_CK_DB_INTERNAL(ip);
    if (ip->idb_type != ID_DSP )  return(-1);
    dsp_ip = (struct rt_dsp_internal *)ip->idb_ptr;
    RT_DSP_CK_MAGIC(dsp_ip);
    BU_CK_VLS(&dsp_ip->dsp_name);


    BU_CK_EXTERNAL(ep);
    ep->ext_nbytes = sizeof(union record)*DB_SS_NGRAN;
    ep->ext_buf = bu_calloc( 1, ep->ext_nbytes, "dsp external");
    rec = (union record *)ep->ext_buf;

    dsp = *dsp_ip;	/* struct copy */

    /* Since libwdb users may want to operate in units other
     * than mm, we offer the opportunity to scale the solid
     * (to get it into mm) on the way out.
     */
    dsp.dsp_stom[15] *= local2mm;

    bu_vls_init( &str );
    bu_vls_struct_print( &str, rt_dsp_ptab, (char *)&dsp);
    if (RT_G_DEBUG & DEBUG_HF)	
	bu_log("rt_dsp_export_v4(%s)\n", bu_vls_addr(&str) );

    rec->ss.ss_id = DBID_STRSOL;
    strncpy( rec->ss.ss_keyword, "dsp", NAMESIZE-1 );
    strncpy( rec->ss.ss_args, bu_vls_addr(&str), DB_SS_LEN-1 );


    if (BU_VLS_IS_INITIALIZED( &str )) bu_vls_free( &str );

    return(0);
}




/*
 *			R T _ D S P _ I M P O R T 5
 *
 *  Import an DSP from the database format to the internal format.
 *  Apply modeling transformations as well.
 */
int
rt_dsp_import5(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip, struct resource *resp, const int minor_type)
{
	struct rt_dsp_internal	*dsp_ip;
	unsigned char		*cp;
	
	if (RT_G_DEBUG & DEBUG_HF)	
		bu_log("rt_dsp_import_v5()\n");
	
	
	
	BU_CK_EXTERNAL( ep );
	
	BU_ASSERT_LONG( ep->ext_nbytes, >, 141 );
	
	RT_CK_DB_INTERNAL( ip );
	
	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_DSP;
	ip->idb_meth = &rt_functab[ID_DSP];
	dsp_ip = ip->idb_ptr = bu_malloc( sizeof(struct rt_dsp_internal), "rt_dsp_internal");
	memset(dsp_ip, 0, sizeof(*dsp_ip));
	
	dsp_ip->magic = RT_DSP_INTERNAL_MAGIC;
	
	/* get x, y counts */
	cp = (unsigned char *)ep->ext_buf;
	
	dsp_ip->dsp_xcnt = (unsigned) bu_glong( cp );
	cp += SIZEOF_NETWORK_LONG;
	if (dsp_ip->dsp_xcnt < 2) {
		bu_log("%s:%d DSP X dimension (%d) < 2 \n", 
					 __FILE__, __LINE__, 
					 dsp_ip->dsp_xcnt);
	}
	
	
	dsp_ip->dsp_ycnt = (unsigned) bu_glong( cp );
	cp += SIZEOF_NETWORK_LONG;
	if (dsp_ip->dsp_ycnt < 2) {
		bu_log("%s:%d DSP X dimension (%d) < 2 \n",
					 __FILE__, __LINE__, 
					 dsp_ip->dsp_ycnt);
	}
	
	/* convert matrix */
	ntohd((unsigned char *)dsp_ip->dsp_stom, cp, 16);
	cp += SIZEOF_NETWORK_DOUBLE * 16;
	bn_mat_inv(dsp_ip->dsp_mtos, dsp_ip->dsp_stom);
	
	/* convert smooth flag */
	dsp_ip->dsp_smooth = bu_gshort( cp );
	cp += SIZEOF_NETWORK_SHORT;
	
	dsp_ip->dsp_datasrc = *cp;
	cp++;
	switch (dsp_ip->dsp_datasrc) {
	case RT_DSP_SRC_V4_FILE:
	case RT_DSP_SRC_FILE:
	case RT_DSP_SRC_OBJ:
		break;
	default:
		bu_log("%s:%d bogus DSP datasrc '%c' (%d)\n",
					 __FILE__, __LINE__, 
					 dsp_ip->dsp_datasrc, dsp_ip->dsp_datasrc);
		break;
	}
	
	
	dsp_ip->dsp_cuttype = *cp;
	cp++;
	switch (dsp_ip->dsp_cuttype) {
	case DSP_CUT_DIR_ADAPT:
	case DSP_CUT_DIR_llUR:
	case DSP_CUT_DIR_ULlr:
		break;
	default:
		bu_log("%s:%d bogus DSP cut type '%c' (%d)\n", 
					 __FILE__, __LINE__, 
					 dsp_ip->dsp_cuttype, dsp_ip->dsp_cuttype);
		break;
	}
	
	
	/* convert name of data location */
	bu_vls_init( &dsp_ip->dsp_name );
	bu_vls_strncpy( &dsp_ip->dsp_name, (char *)cp,
									ep->ext_nbytes - (cp - (unsigned char *)ep->ext_buf) );

	if (dsp_get_data(dsp_ip, ip, ep, mat, dbip)!=0) {
		IMPORT_FAIL("unable to load displacement map data");
	}
	
	return 0; /* OK */
}

/*
 *			R T _ D S P _ E X P O R T 5
 *
 *  The name is added by the caller, in the usual place.
 */
int
rt_dsp_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip, struct resource *resp, const int minor_type)
{
	struct rt_dsp_internal	*dsp_ip;
	unsigned long		name_len;
	unsigned char		*cp;
	
	RT_CK_DB_INTERNAL(ip);
	if (ip->idb_type != ID_DSP )  return(-1);
	dsp_ip = (struct rt_dsp_internal *)ip->idb_ptr;
	RT_DSP_CK_MAGIC(dsp_ip);
	
	if (RT_G_DEBUG & DEBUG_HF)	
		bu_log("rt_dsp_export_v5()\n");
	
	name_len = bu_vls_strlen(&dsp_ip->dsp_name) + 1;
	
	BU_CK_EXTERNAL(ep);
	
	ep->ext_nbytes =
		SIZEOF_NETWORK_LONG * 2 +
		SIZEOF_NETWORK_DOUBLE * ELEMENTS_PER_MAT +
		SIZEOF_NETWORK_SHORT +
		2 + name_len;
	
	ep->ext_buf = bu_malloc( ep->ext_nbytes, "dsp external");
	cp = (unsigned char *)ep->ext_buf;
	
	memset(ep->ext_buf, 0, ep->ext_nbytes);
	
	/* Now we fill the buffer with the data, making sure everything is
	 * converted to Big-Endian IEEE
	 */
	
	bu_plong( cp, (unsigned long)dsp_ip->dsp_xcnt );
	cp += SIZEOF_NETWORK_LONG;
	
	bu_plong( cp, (unsigned long)dsp_ip->dsp_ycnt );
	cp += SIZEOF_NETWORK_LONG;
	
	/* Since libwdb users may want to operate in units other
	 * than mm, we offer the opportunity to scale the solid
	 * (to get it into mm) on the way out.
	 */
	dsp_ip->dsp_stom[15] *= local2mm;
	
	htond(cp, (unsigned char *)dsp_ip->dsp_stom, 16);
	cp += SIZEOF_NETWORK_DOUBLE * 16;
	
	bu_pshort( cp, (int)dsp_ip->dsp_smooth );
	cp += SIZEOF_NETWORK_SHORT;
	
	switch(dsp_ip->dsp_datasrc) {
	case RT_DSP_SRC_V4_FILE:
	case RT_DSP_SRC_FILE:
	case RT_DSP_SRC_OBJ:
		*cp = dsp_ip->dsp_datasrc;
		break;
	default:
		*cp = RT_DSP_SRC_FILE;
		break;
	}
	cp++;
	
	switch(dsp_ip->dsp_cuttype) {
	case DSP_CUT_DIR_ADAPT:
	case DSP_CUT_DIR_llUR:
	case DSP_CUT_DIR_ULlr:
		*cp = dsp_ip->dsp_cuttype;
		break;
	default:
		*cp = DSP_CUT_DIR_ADAPT;
		break;
	}
	cp++;
	
	strcpy((char *)cp, bu_vls_addr(&dsp_ip->dsp_name));
	
	return 0; /* OK */
}




/*
 *			R T _ D S P _ D E S C R I B E
 *
 *  Make human-readable formatted presentation of this solid.
 *  First line describes type of solid.
 *  Additional lines are indented one tab, and give parameter values.
 */
int
rt_dsp_describe(struct bu_vls		*str,
		const struct rt_db_internal *ip,
		int			verbose,
		double			mm2local,
		struct resource		*resp,
		struct db_i		*db_ip)
{
    register struct rt_dsp_internal	*dsp_ip =
	(struct rt_dsp_internal *)ip->idb_ptr;
    struct bu_vls vls;

    RT_CK_DBI(db_ip);

    bu_vls_init( &vls );

    if (RT_G_DEBUG & DEBUG_HF)
	bu_log("rt_dsp_describe()\n");

    RT_DSP_CK_MAGIC(dsp_ip);

    switch (db_ip->dbi_version) {
    case 4: 
	dsp_print_v4(&vls, dsp_ip );
	break;
    case 5:
	dsp_print_v5(&vls, dsp_ip );
	break;
    }

    bu_vls_vlscat( str, &vls );

    if (BU_VLS_IS_INITIALIZED( &vls )) bu_vls_free( &vls );

    return(0);
}

/*
 *			R T _ D S P _ I F R E E
 *
 *  Free the storage associated with the rt_db_internal version of this solid.
 */
void
rt_dsp_ifree(struct rt_db_internal *ip)
{
    register struct rt_dsp_internal	*dsp_ip;

    if (RT_G_DEBUG & DEBUG_HF)
	bu_log("rt_dsp_ifree()\n");

    RT_CK_DB_INTERNAL(ip);
    dsp_ip = (struct rt_dsp_internal *)ip->idb_ptr;
    RT_DSP_CK_MAGIC(dsp_ip);

    if (dsp_ip->dsp_mp) {
	BU_CK_MAPPED_FILE(dsp_ip->dsp_mp);
	bu_close_mapped_file(dsp_ip->dsp_mp);
    }

    if (dsp_ip->dsp_bip) {
	rt_binunif_ifree( (struct rt_db_internal *) dsp_ip->dsp_bip);
    }

    dsp_ip->magic = 0;			/* sanity */
    dsp_ip->dsp_mp = (struct bu_mapped_file *)0;

    if (BU_VLS_IS_INITIALIZED(&dsp_ip->dsp_name)) 
	bu_vls_free(  &dsp_ip->dsp_name );
    else
	bu_log("Freeing Bogus DSP, VLS string not initialized\n");


    bu_free( (char *)dsp_ip, "dsp ifree" );
    ip->idb_ptr = GENPTR_NULL;	/* sanity */
}

static void
hook_verify(const struct bu_structparse	*ip,
						const char 			*sp_name,
						genptr_t			base,		    
						char			*p)
{
	struct rt_dsp_internal *dsp_ip = (struct rt_dsp_internal *)base;
	
	if (!strcmp(sp_name, "src")) {
		switch (dsp_ip->dsp_datasrc) {
		case RT_DSP_SRC_V4_FILE:
		case RT_DSP_SRC_FILE:
		case RT_DSP_SRC_OBJ:
	    break;
		default:
	    bu_log("Error in DSP data source field s/b one of [%c%c%c]\n",
						 RT_DSP_SRC_V4_FILE,
						 RT_DSP_SRC_FILE,
						 RT_DSP_SRC_OBJ);
	    break;
		}
		
	} else if (!strcmp(sp_name, "w")) {
		if (dsp_ip->dsp_xcnt == 0)
	    bu_log("Error in DSP width dimension (0)\n");
	} else if (!strcmp(sp_name, "n")) {
		if (dsp_ip->dsp_ycnt == 0)
	    bu_log("Error in DSP width dimension (0)\n");
	} else if (!strcmp(sp_name, "cut")) {
		switch (dsp_ip->dsp_cuttype) {
		case DSP_CUT_DIR_ADAPT:
		case DSP_CUT_DIR_llUR:
		case DSP_CUT_DIR_ULlr:
	    break;
		default:
	    bu_log("Error in DSP cut type: %c s/b one of [%c%c%c]\n",
						 dsp_ip->dsp_cuttype,
						 DSP_CUT_DIR_ADAPT,
						 DSP_CUT_DIR_llUR,
						 DSP_CUT_DIR_ULlr);
	    break;
		}
	}
}



const struct bu_structparse fake_dsp_printab[] = {
    {"%c",  1, "src", DSP_O(dsp_datasrc), hook_verify },
    {"%S",  1, "name", DSP_O(dsp_name), BU_STRUCTPARSE_FUNC_NULL },
    {"%d",  1, "w",  DSP_O(dsp_xcnt),	 hook_verify },
    {"%d",  1, "n",  DSP_O(dsp_ycnt),	 hook_verify },
    {"%i",  1, "sm", DSP_O(dsp_smooth), BU_STRUCTPARSE_FUNC_NULL },
    {"%c",  1, "cut", DSP_O(dsp_cuttype), hook_verify },
    {"%f", 16, "stom", DSP_AO(dsp_stom), hook_verify },
    {"",    0, (char *)0, 0,		 BU_STRUCTPARSE_FUNC_NULL }
};


/*
 *			R T _ P A R S E T A B _ T C L G E T
 *
 *  This is the generic routine to be listed in rt_functab[].ft_tclget
 *  for those solid types which are fully described by their ft_parsetab
 *  entry.
 *
 *  'attr' is specified to retrieve only one attribute, rather than all.
 *  Example:  "db get ell.s B" to get only the B vector.
 */
int
rt_dsp_tclget(Tcl_Interp *interp, const struct rt_db_internal *intern, const char *attr)
{
	register const struct bu_structparse	*sp = NULL;
	const struct rt_dsp_internal *dsp_ip;
	int                     status;
	Tcl_DString             ds;
	struct bu_vls           str;



	/* XXX if dsp_datasrc == RT_DSP_SRC_V4_FILE we have a V4 dsp
	 * otherwise, a V5 dsp.  Take advantage of this.
	 */

	RT_CK_DB_INTERNAL( intern );
	dsp_ip = (struct rt_dsp_internal *)intern->idb_ptr;

	bu_vls_init( &str );
	Tcl_DStringInit( &ds );

	if( attr == (char *)0 ) {
	    /* Print out solid type and all attributes */

	    Tcl_DStringAppendElement( &ds, "dsp" );



	    switch (dsp_ip->dsp_datasrc) {
	    case RT_DSP_SRC_V4_FILE:
				sp = rt_dsp_ptab;
				break;
	    case RT_DSP_SRC_FILE:
	    case RT_DSP_SRC_OBJ:
				sp = fake_dsp_printab;
				break;
	    }

	    while( sp && sp->sp_name != NULL ) {
		Tcl_DStringAppendElement( &ds, sp->sp_name );
		bu_vls_trunc( &str, 0 );
		bu_vls_struct_item(&str,sp,(char *)dsp_ip,' ');
		Tcl_DStringAppendElement( &ds, bu_vls_addr(&str) );
		++sp;
	    }
	    status = TCL_OK;

	} else {
		switch (dsp_ip->dsp_datasrc) {
		case RT_DSP_SRC_V4_FILE:
			sp = rt_dsp_ptab;
		case RT_DSP_SRC_FILE:
		case RT_DSP_SRC_OBJ:
			sp = fake_dsp_printab;
			break;
		}

	    if( bu_vls_struct_item_named( &str, sp, attr,
					  (char *)dsp_ip, ' ') < 0 ) {
		bu_vls_printf(&str,
			      "Objects of type %s do not have a %s attribute.",
			      "dsp", attr);
		status = TCL_ERROR;
	    } else {
		status = TCL_OK;
	    }
	    Tcl_DStringAppendElement( &ds, bu_vls_addr(&str) );
	}

	Tcl_DStringResult( interp, &ds );
	Tcl_DStringFree( &ds );
	bu_vls_free( &str );

	return status;
}

/*
 *			R T _ P A R S E T A B _ T C L A D J U S T
 *
 *  For those solids entirely defined by their parsetab.
 *  Invoked via rt_functab[].ft_tcladjust()
 */
int
rt_dsp_tcladjust(Tcl_Interp *interp, struct rt_db_internal *intern, int argc, char **argv)
{
	register const struct bu_structparse	*sp = NULL;
	const struct rt_dsp_internal *dsp_ip;


	RT_CK_DB_INTERNAL(intern);
	dsp_ip = (struct rt_dsp_internal *)intern->idb_ptr;
	RT_DSP_CK_MAGIC(dsp_ip);
	BU_CK_VLS(&dsp_ip->dsp_name);

	switch (dsp_ip->dsp_datasrc) {
	case RT_DSP_SRC_V4_FILE:
		sp = rt_dsp_ptab;
	case RT_DSP_SRC_FILE:
	case RT_DSP_SRC_OBJ:
		sp = fake_dsp_printab;		
		break;
	}

	if (! sp) return TCL_ERROR;

	return bu_structparse_argv(interp, argc, argv, sp,
				(char *)intern->idb_ptr );
}

void
rt_dsp_make(const struct rt_functab *ftp, struct rt_db_internal *intern, double diameter)
{
    struct rt_dsp_internal *dsp;

    intern->idb_major_type = DB5_MAJORTYPE_BRLCAD;
    intern->idb_type = ID_DSP;

    BU_ASSERT(&rt_functab[intern->idb_type] == ftp);
    intern->idb_meth = ftp;

    dsp =(struct rt_dsp_internal *)bu_calloc(sizeof(struct rt_dsp_internal),1, "rt_dsp_internal");

    intern->idb_ptr = (genptr_t)dsp;
    dsp->magic = RT_DSP_INTERNAL_MAGIC;
    bu_vls_init(&dsp->dsp_name);
    bu_vls_strcpy(&dsp->dsp_name, "/dev/null");
    dsp->dsp_cuttype = DSP_CUT_DIR_ADAPT;
    MAT_IDN( dsp->dsp_mtos );
    MAT_IDN( dsp->dsp_stom );
    dsp->dsp_datasrc = RT_DSP_SRC_FILE;

}

/*	S W A P _ C E L L _ P T S
 *
 */
static int
swap_cell_pts(int A[3],
	      int B[3],
	      int C[3],
	      int D[3],
	      struct dsp_specific *dsp)

{
    switch (dsp->dsp_i.dsp_cuttype) {
    case DSP_CUT_DIR_llUR:
	return  0;
	break;

    case DSP_CUT_DIR_ADAPT: {
	int lo[2], hi[2];
	double h1, h2, h3, h4;
	double cAD, cBC;  /* curvature in direction AD, and BC */


	/*
	 *  We look at the points in the diagonal next cells to determine
	 *  the curvature along each diagonal of this cell.  This cell is
	 *  divided into two triangles by cutting across the cell in the
	 *  direction of least curvature.
	 *
	 *	*  *  *	 *
	 *	 \      /
	 *	  \C  D/
	 *	*  *--*  *
	 *	   |\/|
	 *	   |/\|
	 *	*  *--*  *
	 *	  /A  B\
	 *	 /	\
	 *	*  *  *	 *
	 */

	lo[X] = A[X] - 1;
	lo[Y] = A[Y] - 1;
	hi[X] = D[X] + 1;
	hi[Y] = D[Y] + 1;

	/* a little bounds checking */
	if (lo[X] < 0) lo[X] = 0;
	if (lo[Y] < 0) lo[Y] = 0;
	if (hi[X] > dsp->xsiz) 
	    hi[X] = dsp->xsiz;

	if (hi[Y] > dsp->ysiz)
	    hi[Y] = dsp->ysiz;

	/* compute curvature along the A->D direction */
	h1 = DSP(&dsp->dsp_i, lo[X], lo[Y]);
	h2 = A[Z];
	h3 = D[Z];
	h4 = DSP(&dsp->dsp_i, hi[X], hi[Y]);

	cAD = fabs(h3 + h1 - 2*h2 ) + fabs( h4 + h2 - 2*h3 );


	/* compute curvature along the B->C direction */
	h1 = DSP(&dsp->dsp_i, hi[X], lo[Y]);
	h2 = B[Z];
	h3 = C[Z];
	h4 = DSP(&dsp->dsp_i, lo[X], hi[Y]);

	cBC = fabs(h3 + h1 - 2*h2 ) + fabs( h4 + h2 - 2*h3 );

	if ( cAD < cBC ) {
	    /* A-D cut is fine, no need to permute */
	    if (RT_G_DEBUG & DEBUG_HF)
		bu_log("A-D cut (no swap)\n");

	    return 0;
	}

	/* fallthrough */

    }
    case DSP_CUT_DIR_ULlr:
	{
	/* prefer the B-C cut */
	int tmp[3];

	VMOVE(tmp, A);
	VMOVE(A, B);
	VMOVE(B, tmp);

	VMOVE(tmp, D);
	VMOVE(D, C);
	VMOVE(C, tmp);

	if (RT_G_DEBUG & DEBUG_HF)
	    bu_log("B-C cut (swap)\n");
	}
	return 0;
	break;
    }
    bu_log("%s:%d Unknown DSP cut direction: %d\n",
	   __FILE__, __LINE__, dsp->dsp_i.dsp_cuttype);
    bu_bomb("");
    /* not reached */
    return -1;
}



/* 
 *
 *
 *
 * triangle with origin at A, X axis along AB, Y axis along AC
 *
 *	B--A	C	A--B	   C
 *	   |	|	|	   |
 *	   C	A--B	C	B--A
 */
int
project_pt(point_t out,
	   int A[3],
	   int B[3],
	   int C[3],
	   point_t pt)
{
    int dx, dy;
    double alpha, beta, x, y;
    vect_t AB, AC;

    if (RT_G_DEBUG & DEBUG_HF) {
	bu_log("     pt %g %g %g\n", V3ARGS(pt));
	bu_log(" origin %d %d %d\n", V3ARGS(A));
	bu_log("    Bpt %d %d %d\n", V3ARGS(B));
	bu_log("    Cpt %d %d %d\n", V3ARGS(C));
    }
    if ((B[X] - A[X]) < 0) dx = -1;
    else dx = 1;
    if ((C[Y] - A[Y]) < 0) dy = -1;
    else dy = 1;

    x = pt[X] - A[X];
    y = pt[Y] - A[Y];

    alpha = x * dx;
    beta = y * dy;
    if (RT_G_DEBUG & DEBUG_HF) {
	bu_log("alpha:%g beta:%g\n", alpha, beta); 
    }
    if (alpha < -SMALL_FASTF) {
	bu_log ("Alpha negative: %g  x:%g  dx:%d\n", alpha, x, dx);
    }
    if (beta < -SMALL_FASTF) {
	bu_log ("Beta negative: %g  x:%g  dx:%d\n", beta, y, dy);
    }
    CLAMP(alpha, 0.0, 1.0);
    CLAMP(beta, 0.0, 1.0);

    if (RT_G_DEBUG & DEBUG_HF) {
	bu_log("x:%g y:%g dx:%d dy:%d alpha:%g beta:%g\n", 
	       x, y, dx, dy, alpha, beta);
    }
    if ((alpha+beta) > (1.0+SMALL_FASTF)) {
	if (RT_G_DEBUG & DEBUG_HF) bu_log("Not this triangle\n");
	return 1;
    }

    VSUB2(AB, B, A);
    VSUB2(AC, C, A);

    VJOIN2(out, A, alpha, AB, beta, AC);
    if (RT_G_DEBUG & DEBUG_HF) bu_log("out: %g %g %g\n", V3ARGS(out));

    return 0;
}
/*	D S P _ P O S
 *
 *
 *	Given an arbitrary point return the projection of that point onto
 * 	the surface of the DSP.  If the point is outside the bounds of the DSP
 *	then it will be projected to the nearest edge of the DSP.
 *	Return the cell number and the height above/below the plane
 */
int
dsp_pos(point_t out, /* return value */
	struct soltab *stp, /* pointer to soltab for dsp */
	point_t p)	/* model space point */
{
    struct dsp_specific *dsp;
    point_t pt, tri_pt;
    int x, y;
    int A[3], B[3], C[3], D[3];

    struct dsp_rpp dsp_rpp;

    RT_CK_SOLTAB(stp);

    if (stp->st_id != ID_DSP) return 1;

    dsp = (struct dsp_specific *)stp->st_specific;

    MAT4X3PNT(pt, dsp->dsp_i.dsp_mtos, p);


    if (RT_G_DEBUG & DEBUG_HF) {
	VPRINT("user_point", p);
	VPRINT("dsp_point", pt);
    }
    x = pt[X];
    y = pt[Y];

    CLAMP(x, 0, XSIZ(dsp)-1);
    CLAMP(y, 0, YSIZ(dsp)-1);

    if (RT_G_DEBUG & DEBUG_HF)
	bu_log("x:%d y:%d\n", x, y);

    VSET(dsp_rpp.dsp_min, x, y, 0);
    VSET(dsp_rpp.dsp_max, x+1, y+1, 0);

    VSET(A, x, y, DSP(&dsp->dsp_i, x, y) );
    x += 1;
    VSET(B, x, y, DSP(&dsp->dsp_i, x, y) );
    y += 1;
    VSET(D, x, y, DSP(&dsp->dsp_i, x, y) );
    x -= 1;
    VSET(C, x, y, DSP(&dsp->dsp_i, x, y) );
    y -= 1;

    if (RT_G_DEBUG & DEBUG_HF) {
	bu_log(" A: %d %d %d\n", V3ARGS(A));
	bu_log(" B: %d %d %d\n", V3ARGS(B));
	bu_log(" C: %d %d %d\n", V3ARGS(C));
	bu_log(" D: %d %d %d\n", V3ARGS(D));
    }

    swap_cell_pts(A, B, C, D, dsp);
    if (RT_G_DEBUG & DEBUG_HF) {
	bu_log(" A: %d %d %d\n", V3ARGS(A));
	bu_log(" B: %d %d %d\n", V3ARGS(B));
	bu_log(" C: %d %d %d\n", V3ARGS(C));
	bu_log(" D: %d %d %d\n", V3ARGS(D));
    }

    if (project_pt(tri_pt, B, A, D, pt)) {
	if (project_pt(tri_pt, C, D, A, pt)) {
	    bu_log("Now what???\n");
	}
    }

    MAT4X3PNT(out, dsp->dsp_i.dsp_stom, tri_pt);
    if (RT_G_DEBUG & DEBUG_HF) {
	VPRINT("user_pt", p);
	VPRINT("tri_pt", tri_pt);
	VPRINT("model_space", out);
	bu_log("X: %d Y:%d\n",x, y);
    }

    return 0;
}


/* Important when concatenating source files together */
#undef dlog
#undef XMIN
#undef XMAX
#undef YMIN
#undef YMAX
#undef ZMIN
#undef ZMAX
#undef ZMID
#undef DSP
#undef XCNT
#undef YCNT
#undef XSIZ
#undef YSIZ
@


1.119
log
@change conf.h to a wrapped config.h
@
text
@d43 1
a43 1
static const char RCSdsp[] = "@@(#)$Header: /cvs/brlcad/librt/g_dsp.c,v 1.118 2004/04/05 08:48:56 morrison Exp $ (BRL)";
@


1.118
log
@merge of ansi-6-0-branch into HEAD
@
text
@d43 1
a43 1
static const char RCSdsp[] = "@@(#)$Header$ (BRL)";
d46 5
a50 1
#include "conf.h"
@


1.117
log
@update copyright to include span through 2003
@
text
@d43 1
a43 1
static const char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.116 2003/08/02 23:14:23 butler Exp $ (BRL)";
d518 1
a518 3
dsp_print_v4(vls, dsp_ip)
     struct bu_vls *vls;
     const struct rt_dsp_internal *dsp_ip;
d628 1
a628 2
rt_dsp_print( stp )
     register const struct soltab *stp;
d920 1
a920 4
rt_dsp_prep( stp, ip, rtip )
     struct soltab		*stp;
     struct rt_db_internal	*ip;
     struct rt_i		*rtip;
d2517 1
a2517 5
rt_dsp_shot( stp, rp, ap, seghead )
     struct soltab		*stp;
     register struct xray	*rp;
     struct application	*ap;
     struct seg		*seghead;
d2668 6
a2673 6
rt_dsp_vshot( stp, rp, segp, n, ap )
     struct soltab	       *stp[]; /* An array of solid pointers */
     struct xray		*rp[]; /* An array of ray pointers */
     struct  seg            segp[]; /* array of segs (results returned) */
     int		  	    n; /* Number of ray/object pairs */
     struct application	*ap;
d2788 1
a2788 4
rt_dsp_norm( hitp, stp, rp )
     register struct hit	*hitp;
     struct soltab		*stp;
     register struct xray	*rp;
d2968 1
a2968 4
rt_dsp_curve( cvp, hitp, stp )
     register struct curvature *cvp;
     register struct hit	*hitp;
     struct soltab		*stp;
d2989 1
a2989 5
rt_dsp_uv( ap, stp, hitp, uvp )
     struct application	*ap;
     struct soltab		*stp;
     register struct hit	*hitp;
     register struct uvcoord	*uvp;
d3081 1
a3081 2
rt_dsp_free( stp )
     register struct soltab *stp;
d3110 1
a3110 1
rt_dsp_class()
d3122 1
a3122 5
rt_dsp_plot( vhead, ip, ttol, tol )
     struct bu_list		*vhead;
     struct rt_db_internal	*ip;
     const struct rt_tess_tol *ttol;
     const struct bn_tol	*tol;
d3362 1
a3362 6
rt_dsp_tess( r, m, ip, ttol, tol )
     struct nmgregion	**r;
     struct model		*m;
     struct rt_db_internal	*ip;
     const struct rt_tess_tol *ttol;
     const struct bn_tol	*tol;
d3573 1
a3573 5
rt_dsp_import( ip, ep, mat, dbip )
     struct rt_db_internal		*ip;
     const struct bu_external	*ep;
     register const mat_t		mat;
     const struct db_i		*dbip;
d3667 1
a3667 5
rt_dsp_export( ep, ip, local2mm, dbip )
     struct bu_external		*ep;
     const struct rt_db_internal	*ip;
     double				local2mm;
     const struct db_i		*dbip;
d3720 1
a3720 7
rt_dsp_import5( ip, ep, mat, dbip, resp, minor_type )
     struct rt_db_internal		*ip;
     const struct bu_external	*ep;
     register const mat_t		mat;
     const struct db_i		*dbip;
     struct resource		*resp;
     const int			minor_type;
d3821 1
a3821 7
rt_dsp_export5( ep, ip, local2mm, dbip, resp, minor_type )
     struct bu_external		*ep;
     const struct rt_db_internal	*ip;
     double				local2mm;
     const struct db_i		*dbip;
     struct resource		*resp;
     const int			minor_type;
d3954 1
a3954 2
rt_dsp_ifree( ip )
     struct rt_db_internal	*ip;
d4057 1
a4057 4
rt_dsp_tclget( interp, intern, attr )
Tcl_Interp			*interp;
const struct rt_db_internal	*intern;
const char			*attr;
d4139 1
a4139 5
rt_dsp_tcladjust( interp, intern, argc, argv )
Tcl_Interp		*interp;
struct rt_db_internal	*intern;
int			argc;
char			**argv;
@


1.116
log
@Misc enhancements to dsp_pos query
@
text
@d39 1
a39 1
 *	This software is Copyright (C) 1990 by the United States Army.
d43 1
a43 1
static const char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.115 2003/07/28 20:30:31 butler Exp $ (BRL)";
@


1.116.4.1
log
@merge from HEAD
@
text
@d39 1
a39 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d43 1
a43 1
static const char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.117 2004/02/02 17:39:20 morrison Exp $ (BRL)";
@


1.116.4.2
log
@merge from head
@
text
@d43 1
a43 1
static const char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.116.4.1 2004/02/12 18:37:40 erikg Exp $ (BRL)";
@


1.115
log
@deleted automatic plotting of dsp problems
@
text
@d43 1
a43 1
static const char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.114 2003/07/19 22:53:24 butler Exp $ (BRL)";
d1488 2
a1489 2
	     struct isect_stuff *isect, 
	     struct dsp_bb *dsp_bb)
a1492 1
    DSP_BB_CK(dsp_bb);
d1503 1
a1503 1
    switch (isect->dsp->dsp_i.dsp_cuttype) {
d1516 2
a1517 2
		   dsp_bb->dspb_rpp.dsp_min[X],
		   dsp_bb->dspb_rpp.dsp_min[Y]);
d1537 4
a1540 4
	lo[X] = dsp_bb->dspb_rpp.dsp_min[X] - 1;
	lo[Y] = dsp_bb->dspb_rpp.dsp_min[Y] - 1;
	hi[X] = dsp_bb->dspb_rpp.dsp_max[X] + 1;
	hi[Y] = dsp_bb->dspb_rpp.dsp_max[Y] + 1;
d1545 2
a1546 2
	if (hi[X] > isect->dsp->xsiz) 
	    hi[X] = isect->dsp->xsiz;
d1548 2
a1549 2
	if (hi[Y] > isect->dsp->ysiz)
	    hi[Y] = isect->dsp->ysiz;
d1552 1
a1552 1
	h1 = DSP(&isect->dsp->dsp_i, lo[X], lo[Y]);
d1555 1
a1555 1
	h4 = DSP(&isect->dsp->dsp_i, hi[X], hi[Y]);
d1561 1
a1561 1
	h1 = DSP(&isect->dsp->dsp_i, hi[X], lo[Y]);
d1564 1
a1564 1
	h4 = DSP(&isect->dsp->dsp_i, lo[X], hi[Y]);
d1599 3
a1601 3
	x = dsp_bb->dspb_rpp.dsp_min[X];
	y = dsp_bb->dspb_rpp.dsp_min[Y];
	VSET(B, x, y, DSP(&isect->dsp->dsp_i, x, y) );
d1603 2
a1604 2
	x = dsp_bb->dspb_rpp.dsp_max[X];
	VSET(A, x, y, DSP(&isect->dsp->dsp_i, x, y) );
d1606 2
a1607 2
	y = dsp_bb->dspb_rpp.dsp_max[Y];
	VSET(C, x, y, DSP(&isect->dsp->dsp_i, x, y) );
d1609 2
a1610 2
	x = dsp_bb->dspb_rpp.dsp_min[X];
	VSET(D, x, y, DSP(&isect->dsp->dsp_i, x, y) );
d1616 1
a1616 1
	   __FILE__, __LINE__, isect->dsp->dsp_i.dsp_cuttype);
d1855 1
a1855 1
    (void)permute_cell(A, B, C, D, isect, dsp_bb);
d4246 264
@


1.114
log
@Fixed bug in du/dv calculations
@
text
@d43 1
a43 1
static const char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.113 2003/07/19 22:26:33 butler Exp $ (BRL)";
d1995 2
a1996 1
	plot_cell_top(isect, dsp_bb, A, B, C, D, hits, 3, 0);
@


1.113
log
@It is now possible to "ls" a dsp object in MGED for which the associated
data file does not exist
@
text
@d43 1
a43 1
static const char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.112 2003/04/15 21:23:25 butler Exp $ (BRL)";
a3038 3
     * 
     * XXX There is a bug in this code, which shows up in odd diagonals
     * when raytracing straight down on a DSP
d3040 3
a3042 3
    VSET( tmp, XSIZ(dsp), 0.0, 0.0 )
	MAT4X3VEC( U_dir,  dsp->dsp_i.dsp_stom, tmp )
	U_len = MAGNITUDE( U_dir );
d3044 1
a3044 1
    VSCALE( U_dir, U_dir, one_over_len )
d3046 3
a3048 3
	VSET( tmp, 0.0, YSIZ(dsp), 0.0 )
	MAT4X3VEC( V_dir,  dsp->dsp_i.dsp_stom, tmp )
	V_len = MAGNITUDE( V_dir );
d3050 1
a3050 1
    VSCALE( V_dir, V_dir, one_over_len )
d3052 2
a3053 2
	/* divide the hit-point radius by the U/V unit length distance */
	r = ap->a_rbeam + ap->a_diverge * hitp->hit_dist;
d3060 17
a3076 15
    VREVERSE( rev_dir, ap->a_ray.r_dir )
	VMOVE( norm, hitp->hit_normal )
	dot_N = VDOT( rev_dir, norm );
    VJOIN1( UV_dir, rev_dir, -dot_N, norm )
	VUNITIZE( UV_dir )

	if (NEAR_ZERO( dot_N, SMALL_FASTF ) ) {
	    /* ray almost perfectly 90 degrees to surface */
	    uvp->uv_du = 0.5;
	    uvp->uv_dv = 0.5;
	} else {
	    /* somehow this computes the extent of U and V in the radius */
	    uvp->uv_du = (r / U_len) * VDOT( UV_dir, U_dir ) / dot_N;
	    uvp->uv_dv = (r / V_len) * VDOT( UV_dir, V_dir ) / dot_N;
	}
@


1.112
log
@Fixed a bug where the first segment occurs behind the start point of the ray.
No hit points in front of the ray start were being computed when a_onehit was
set.  Changed so that a_onehit segments IN FRONT of the ray origin are
computed.
@
text
@d43 1
a43 1
static const char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.111 2003/04/08 22:20:56 butler Exp $ (BRL)";
d3040 2
a3041 1

d3168 4
d3413 1
a3413 1
 *		!0 Failuer
d3432 1
a3432 1
	return -1;
@


1.111
log
@Typo which caused bogus segments fixed
@
text
@d43 1
a43 1
static const char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.110 2002/11/26 21:08:00 morrison Exp $ (BRL)";
a199 1

d1271 5
a1275 1
    return (++isect->num_segs > isect->ap->a_onehit);
d2565 2
@


1.111.2.1
log
@updated for merging
@
text
@d43 1
a43 1
static const char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.116 2003/08/02 23:14:23 butler Exp $ (BRL)";
d200 1
d1272 1
a1272 5

    if (seg->seg_in.hit_dist > 0.0 || seg->seg_out.hit_dist > 0.0) {
	return (++isect->num_segs > isect->ap->a_onehit);
    }
    return 0;
d1485 2
a1486 2
	     struct dsp_specific *dsp,
	     struct dsp_rpp *dsp_rpp)
d1490 1
d1501 1
a1501 1
    switch (dsp->dsp_i.dsp_cuttype) {
d1514 2
a1515 2
		   dsp_rpp->dsp_min[X],
		   dsp_rpp->dsp_min[Y]);
d1535 4
a1538 4
	lo[X] = dsp_rpp->dsp_min[X] - 1;
	lo[Y] = dsp_rpp->dsp_min[Y] - 1;
	hi[X] = dsp_rpp->dsp_max[X] + 1;
	hi[Y] = dsp_rpp->dsp_max[Y] + 1;
d1543 2
a1544 2
	if (hi[X] > dsp->xsiz) 
	    hi[X] = dsp->xsiz;
d1546 2
a1547 2
	if (hi[Y] > dsp->ysiz)
	    hi[Y] = dsp->ysiz;
d1550 1
a1550 1
	h1 = DSP(&dsp->dsp_i, lo[X], lo[Y]);
d1553 1
a1553 1
	h4 = DSP(&dsp->dsp_i, hi[X], hi[Y]);
d1559 1
a1559 1
	h1 = DSP(&dsp->dsp_i, hi[X], lo[Y]);
d1562 1
a1562 1
	h4 = DSP(&dsp->dsp_i, lo[X], hi[Y]);
d1597 3
a1599 3
	x = dsp_rpp->dsp_min[X];
	y = dsp_rpp->dsp_min[Y];
	VSET(B, x, y, DSP(&dsp->dsp_i, x, y) );
d1601 2
a1602 2
	x = dsp_rpp->dsp_max[X];
	VSET(A, x, y, DSP(&dsp->dsp_i, x, y) );
d1604 2
a1605 2
	y = dsp_rpp->dsp_max[Y];
	VSET(C, x, y, DSP(&dsp->dsp_i, x, y) );
d1607 2
a1608 2
	x = dsp_rpp->dsp_min[X];
	VSET(D, x, y, DSP(&dsp->dsp_i, x, y) );
d1614 1
a1614 1
	   __FILE__, __LINE__, dsp->dsp_i.dsp_cuttype);
d1853 1
a1853 1
    (void)permute_cell(A, B, C, D, isect->dsp, &dsp_bb->dspb_rpp);
d1992 1
a1992 2
	if (RT_G_DEBUG & DEBUG_HF)
	    plot_cell_top(isect, dsp_bb, A, B, C, D, hits, 3, 0);
a2561 2
    isect.num_segs = 0;

d3034 2
d3037 3
a3039 3
    VSET( tmp, XSIZ(dsp), 0.0, 0.0 );	/* X direction vector */
    MAT4X3VEC( U_dir,  dsp->dsp_i.dsp_stom, tmp ); /* into model space */
    U_len = MAGNITUDE( U_dir );		/* remember model space length */
d3041 1
a3041 1
    VSCALE( U_dir, U_dir, one_over_len ); /* scale to unit length in model space */
d3043 3
a3045 3
    VSET( tmp, 0.0, YSIZ(dsp), 0.0 );	/* Y direction vector */
    MAT4X3VEC( V_dir,  dsp->dsp_i.dsp_stom, tmp );
    V_len = MAGNITUDE( V_dir );
d3047 1
a3047 1
    VSCALE( V_dir, V_dir, one_over_len ); /* scale to unit length in model space */
d3049 2
a3050 2
    /* divide the hit-point radius by the U/V unit length distance */
    r = ap->a_rbeam + ap->a_diverge * hitp->hit_dist;
d3057 15
a3071 17
    VREVERSE( rev_dir, ap->a_ray.r_dir );
    VMOVE( norm, hitp->hit_normal );
    dot_N = VDOT( rev_dir, norm );
    VJOIN1( UV_dir, rev_dir, -dot_N, norm );
    VUNITIZE( UV_dir );

    if (NEAR_ZERO( dot_N, SMALL_FASTF ) ) {
	/* ray almost perfectly 90 degrees to surface */
	uvp->uv_du = min_r_U;
	uvp->uv_dv = min_r_V;
    } else {
	/* somehow this computes the extent of U and V in the radius */
	uvp->uv_du = (r / U_len) * VDOT( UV_dir, U_dir ) / dot_N;
	uvp->uv_dv = (r / V_len) * VDOT( UV_dir, V_dir ) / dot_N;
    }


a3161 4
    if (! dsp_ip->dsp_mp ) {
	bu_log("cannot find data for DSP\n");
	return 0;
    }
d3403 1
a3403 1
 *		!0 Failure
d3422 1
a3422 1
	return 0;
a4236 264

/*	S W A P _ C E L L _ P T S
 *
 */
static int
swap_cell_pts(int A[3],
	      int B[3],
	      int C[3],
	      int D[3],
	      struct dsp_specific *dsp)

{
    switch (dsp->dsp_i.dsp_cuttype) {
    case DSP_CUT_DIR_llUR:
	return  0;
	break;

    case DSP_CUT_DIR_ADAPT: {
	int lo[2], hi[2];
	double h1, h2, h3, h4;
	double cAD, cBC;  /* curvature in direction AD, and BC */


	/*
	 *  We look at the points in the diagonal next cells to determine
	 *  the curvature along each diagonal of this cell.  This cell is
	 *  divided into two triangles by cutting across the cell in the
	 *  direction of least curvature.
	 *
	 *	*  *  *	 *
	 *	 \      /
	 *	  \C  D/
	 *	*  *--*  *
	 *	   |\/|
	 *	   |/\|
	 *	*  *--*  *
	 *	  /A  B\
	 *	 /	\
	 *	*  *  *	 *
	 */

	lo[X] = A[X] - 1;
	lo[Y] = A[Y] - 1;
	hi[X] = D[X] + 1;
	hi[Y] = D[Y] + 1;

	/* a little bounds checking */
	if (lo[X] < 0) lo[X] = 0;
	if (lo[Y] < 0) lo[Y] = 0;
	if (hi[X] > dsp->xsiz) 
	    hi[X] = dsp->xsiz;

	if (hi[Y] > dsp->ysiz)
	    hi[Y] = dsp->ysiz;

	/* compute curvature along the A->D direction */
	h1 = DSP(&dsp->dsp_i, lo[X], lo[Y]);
	h2 = A[Z];
	h3 = D[Z];
	h4 = DSP(&dsp->dsp_i, hi[X], hi[Y]);

	cAD = fabs(h3 + h1 - 2*h2 ) + fabs( h4 + h2 - 2*h3 );


	/* compute curvature along the B->C direction */
	h1 = DSP(&dsp->dsp_i, hi[X], lo[Y]);
	h2 = B[Z];
	h3 = C[Z];
	h4 = DSP(&dsp->dsp_i, lo[X], hi[Y]);

	cBC = fabs(h3 + h1 - 2*h2 ) + fabs( h4 + h2 - 2*h3 );

	if ( cAD < cBC ) {
	    /* A-D cut is fine, no need to permute */
	    if (RT_G_DEBUG & DEBUG_HF)
		bu_log("A-D cut (no swap)\n");

	    return 0;
	}

	/* fallthrough */

    }
    case DSP_CUT_DIR_ULlr:
	{
	/* prefer the B-C cut */
	int tmp[3];

	VMOVE(tmp, A);
	VMOVE(A, B);
	VMOVE(B, tmp);

	VMOVE(tmp, D);
	VMOVE(D, C);
	VMOVE(C, tmp);

	if (RT_G_DEBUG & DEBUG_HF)
	    bu_log("B-C cut (swap)\n");
	}
	return 0;
	break;
    }
    bu_log("%s:%d Unknown DSP cut direction: %d\n",
	   __FILE__, __LINE__, dsp->dsp_i.dsp_cuttype);
    bu_bomb("");
    /* not reached */
    return -1;
}



/* 
 *
 *
 *
 * triangle with origin at A, X axis along AB, Y axis along AC
 *
 *	B--A	C	A--B	   C
 *	   |	|	|	   |
 *	   C	A--B	C	B--A
 */
int
project_pt(point_t out,
	   int A[3],
	   int B[3],
	   int C[3],
	   point_t pt)
{
    int dx, dy;
    double alpha, beta, x, y;
    vect_t AB, AC;

    if (RT_G_DEBUG & DEBUG_HF) {
	bu_log("     pt %g %g %g\n", V3ARGS(pt));
	bu_log(" origin %d %d %d\n", V3ARGS(A));
	bu_log("    Bpt %d %d %d\n", V3ARGS(B));
	bu_log("    Cpt %d %d %d\n", V3ARGS(C));
    }
    if ((B[X] - A[X]) < 0) dx = -1;
    else dx = 1;
    if ((C[Y] - A[Y]) < 0) dy = -1;
    else dy = 1;

    x = pt[X] - A[X];
    y = pt[Y] - A[Y];

    alpha = x * dx;
    beta = y * dy;
    if (RT_G_DEBUG & DEBUG_HF) {
	bu_log("alpha:%g beta:%g\n", alpha, beta); 
    }
    if (alpha < -SMALL_FASTF) {
	bu_log ("Alpha negative: %g  x:%g  dx:%d\n", alpha, x, dx);
    }
    if (beta < -SMALL_FASTF) {
	bu_log ("Beta negative: %g  x:%g  dx:%d\n", beta, y, dy);
    }
    CLAMP(alpha, 0.0, 1.0);
    CLAMP(beta, 0.0, 1.0);

    if (RT_G_DEBUG & DEBUG_HF) {
	bu_log("x:%g y:%g dx:%d dy:%d alpha:%g beta:%g\n", 
	       x, y, dx, dy, alpha, beta);
    }
    if ((alpha+beta) > (1.0+SMALL_FASTF)) {
	if (RT_G_DEBUG & DEBUG_HF) bu_log("Not this triangle\n");
	return 1;
    }

    VSUB2(AB, B, A);
    VSUB2(AC, C, A);

    VJOIN2(out, A, alpha, AB, beta, AC);
    if (RT_G_DEBUG & DEBUG_HF) bu_log("out: %g %g %g\n", V3ARGS(out));

    return 0;
}
/*	D S P _ P O S
 *
 *
 *	Given an arbitrary point return the projection of that point onto
 * 	the surface of the DSP.  If the point is outside the bounds of the DSP
 *	then it will be projected to the nearest edge of the DSP.
 *	Return the cell number and the height above/below the plane
 */
int
dsp_pos(point_t out, /* return value */
	struct soltab *stp, /* pointer to soltab for dsp */
	point_t p)	/* model space point */
{
    struct dsp_specific *dsp;
    point_t pt, tri_pt;
    int x, y;
    int A[3], B[3], C[3], D[3];

    struct dsp_rpp dsp_rpp;

    RT_CK_SOLTAB(stp);

    if (stp->st_id != ID_DSP) return 1;

    dsp = (struct dsp_specific *)stp->st_specific;

    MAT4X3PNT(pt, dsp->dsp_i.dsp_mtos, p);


    if (RT_G_DEBUG & DEBUG_HF) {
	VPRINT("user_point", p);
	VPRINT("dsp_point", pt);
    }
    x = pt[X];
    y = pt[Y];

    CLAMP(x, 0, XSIZ(dsp)-1);
    CLAMP(y, 0, YSIZ(dsp)-1);

    if (RT_G_DEBUG & DEBUG_HF)
	bu_log("x:%d y:%d\n", x, y);

    VSET(dsp_rpp.dsp_min, x, y, 0);
    VSET(dsp_rpp.dsp_max, x+1, y+1, 0);

    VSET(A, x, y, DSP(&dsp->dsp_i, x, y) );
    x += 1;
    VSET(B, x, y, DSP(&dsp->dsp_i, x, y) );
    y += 1;
    VSET(D, x, y, DSP(&dsp->dsp_i, x, y) );
    x -= 1;
    VSET(C, x, y, DSP(&dsp->dsp_i, x, y) );
    y -= 1;

    if (RT_G_DEBUG & DEBUG_HF) {
	bu_log(" A: %d %d %d\n", V3ARGS(A));
	bu_log(" B: %d %d %d\n", V3ARGS(B));
	bu_log(" C: %d %d %d\n", V3ARGS(C));
	bu_log(" D: %d %d %d\n", V3ARGS(D));
    }

    swap_cell_pts(A, B, C, D, dsp);
    if (RT_G_DEBUG & DEBUG_HF) {
	bu_log(" A: %d %d %d\n", V3ARGS(A));
	bu_log(" B: %d %d %d\n", V3ARGS(B));
	bu_log(" C: %d %d %d\n", V3ARGS(C));
	bu_log(" D: %d %d %d\n", V3ARGS(D));
    }

    if (project_pt(tri_pt, B, A, D, pt)) {
	if (project_pt(tri_pt, C, D, A, pt)) {
	    bu_log("Now what???\n");
	}
    }

    MAT4X3PNT(out, dsp->dsp_i.dsp_stom, tri_pt);
    if (RT_G_DEBUG & DEBUG_HF) {
	VPRINT("user_pt", p);
	VPRINT("tri_pt", tri_pt);
	VPRINT("model_space", out);
	bu_log("X: %d Y:%d\n",x, y);
    }

    return 0;
}


@


1.110
log
@Quelled compiler warnings
@
text
@d43 1
a43 1
static const char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.109 2002/09/05 04:10:30 butler Exp $ (BRL)";
d1145 1
a1145 2
    if (RT_G_DEBUG & DEBUG_HF) {
	bu_log("searching for insertion point for seg w in/out dist %g %g\n",
d1147 1
a1147 1
    }
d2407 1
a2407 1
	VMOVE(seg_out.hit_point, minpt);
d2415 4
a2418 4
	    /* we need these for debug output */
	    VMOVE(seg_in.hit_point, minpt);
	    VMOVE(seg_out.hit_point, maxpt);

@


1.109
log
@Changes to be able to "make" a dsp.  Basically, if the data is missing,
we pretend to access /dev/null.  This is mostly interesting so that we
can do a "db put" of a dsp object
@
text
@d43 1
a43 1
static const char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.108 2002/08/20 17:07:59 jra Exp $ (BRL)";
d3281 1
a3281 1
	    if (s_pt[Z] = DSP(dsp_ip, x, y)) {
d3300 1
a3300 1
	if (s_pt[Z] = DSP(dsp_ip, xlim, y)) {
d3331 1
a3331 1
	    if (s_pt[Z] = DSP(dsp_ip, x, y)) {
d3350 1
a3350 1
	if (s_pt[Z] = DSP(dsp_ip, x, ylim)) {
@


1.109.4.1
log
@sync to HEAD...
@
text
@d39 1
a39 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d43 1
a43 1
static const char RCSdsp[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/g_dsp.c,v 1.117 2004/02/02 17:39:20 morrison Exp $ (BRL)";
d200 1
d1145 2
a1146 1
    dlog("searching for insertion point for seg w in/out dist %g %g\n",
d1148 1
a1148 1

d1273 1
a1273 5

    if (seg->seg_in.hit_dist > 0.0 || seg->seg_out.hit_dist > 0.0) {
	return (++isect->num_segs > isect->ap->a_onehit);
    }
    return 0;
d1486 2
a1487 2
	     struct dsp_specific *dsp,
	     struct dsp_rpp *dsp_rpp)
d1491 1
d1502 1
a1502 1
    switch (dsp->dsp_i.dsp_cuttype) {
d1515 2
a1516 2
		   dsp_rpp->dsp_min[X],
		   dsp_rpp->dsp_min[Y]);
d1536 4
a1539 4
	lo[X] = dsp_rpp->dsp_min[X] - 1;
	lo[Y] = dsp_rpp->dsp_min[Y] - 1;
	hi[X] = dsp_rpp->dsp_max[X] + 1;
	hi[Y] = dsp_rpp->dsp_max[Y] + 1;
d1544 2
a1545 2
	if (hi[X] > dsp->xsiz) 
	    hi[X] = dsp->xsiz;
d1547 2
a1548 2
	if (hi[Y] > dsp->ysiz)
	    hi[Y] = dsp->ysiz;
d1551 1
a1551 1
	h1 = DSP(&dsp->dsp_i, lo[X], lo[Y]);
d1554 1
a1554 1
	h4 = DSP(&dsp->dsp_i, hi[X], hi[Y]);
d1560 1
a1560 1
	h1 = DSP(&dsp->dsp_i, hi[X], lo[Y]);
d1563 1
a1563 1
	h4 = DSP(&dsp->dsp_i, lo[X], hi[Y]);
d1598 3
a1600 3
	x = dsp_rpp->dsp_min[X];
	y = dsp_rpp->dsp_min[Y];
	VSET(B, x, y, DSP(&dsp->dsp_i, x, y) );
d1602 2
a1603 2
	x = dsp_rpp->dsp_max[X];
	VSET(A, x, y, DSP(&dsp->dsp_i, x, y) );
d1605 2
a1606 2
	y = dsp_rpp->dsp_max[Y];
	VSET(C, x, y, DSP(&dsp->dsp_i, x, y) );
d1608 2
a1609 2
	x = dsp_rpp->dsp_min[X];
	VSET(D, x, y, DSP(&dsp->dsp_i, x, y) );
d1615 1
a1615 1
	   __FILE__, __LINE__, dsp->dsp_i.dsp_cuttype);
d1854 1
a1854 1
    (void)permute_cell(A, B, C, D, isect->dsp, &dsp_bb->dspb_rpp);
d1993 1
a1993 2
	if (RT_G_DEBUG & DEBUG_HF)
	    plot_cell_top(isect, dsp_bb, A, B, C, D, hits, 3, 0);
d2408 1
a2408 1
	VMOVE(seg_out.hit_point, maxpt);
d2416 4
a2419 4
	    /* we need these for debug output
	     * VMOVE(seg_in.hit_point, minpt);
	     * VMOVE(seg_out.hit_point, maxpt);
	     */
a2562 2
    isect.num_segs = 0;

d3035 2
d3038 3
a3040 3
    VSET( tmp, XSIZ(dsp), 0.0, 0.0 );	/* X direction vector */
    MAT4X3VEC( U_dir,  dsp->dsp_i.dsp_stom, tmp ); /* into model space */
    U_len = MAGNITUDE( U_dir );		/* remember model space length */
d3042 1
a3042 1
    VSCALE( U_dir, U_dir, one_over_len ); /* scale to unit length in model space */
d3044 3
a3046 3
    VSET( tmp, 0.0, YSIZ(dsp), 0.0 );	/* Y direction vector */
    MAT4X3VEC( V_dir,  dsp->dsp_i.dsp_stom, tmp );
    V_len = MAGNITUDE( V_dir );
d3048 1
a3048 1
    VSCALE( V_dir, V_dir, one_over_len ); /* scale to unit length in model space */
d3050 2
a3051 2
    /* divide the hit-point radius by the U/V unit length distance */
    r = ap->a_rbeam + ap->a_diverge * hitp->hit_dist;
d3058 15
a3072 17
    VREVERSE( rev_dir, ap->a_ray.r_dir );
    VMOVE( norm, hitp->hit_normal );
    dot_N = VDOT( rev_dir, norm );
    VJOIN1( UV_dir, rev_dir, -dot_N, norm );
    VUNITIZE( UV_dir );

    if (NEAR_ZERO( dot_N, SMALL_FASTF ) ) {
	/* ray almost perfectly 90 degrees to surface */
	uvp->uv_du = min_r_U;
	uvp->uv_dv = min_r_V;
    } else {
	/* somehow this computes the extent of U and V in the radius */
	uvp->uv_du = (r / U_len) * VDOT( UV_dir, U_dir ) / dot_N;
	uvp->uv_dv = (r / V_len) * VDOT( UV_dir, V_dir ) / dot_N;
    }


a3162 4
    if (! dsp_ip->dsp_mp ) {
	bu_log("cannot find data for DSP\n");
	return 0;
    }
d3281 1
a3281 1
	    if ( (s_pt[Z] = DSP(dsp_ip, x, y)) ) {
d3300 1
a3300 1
	if ( (s_pt[Z] = DSP(dsp_ip, xlim, y)) ) {
d3331 1
a3331 1
	    if ( (s_pt[Z] = DSP(dsp_ip, x, y)) ) {
d3350 1
a3350 1
	if ( (s_pt[Z] = DSP(dsp_ip, x, ylim)) ) {
d3404 1
a3404 1
 *		!0 Failure
d3423 1
a3423 1
	return 0;
a4237 264

/*	S W A P _ C E L L _ P T S
 *
 */
static int
swap_cell_pts(int A[3],
	      int B[3],
	      int C[3],
	      int D[3],
	      struct dsp_specific *dsp)

{
    switch (dsp->dsp_i.dsp_cuttype) {
    case DSP_CUT_DIR_llUR:
	return  0;
	break;

    case DSP_CUT_DIR_ADAPT: {
	int lo[2], hi[2];
	double h1, h2, h3, h4;
	double cAD, cBC;  /* curvature in direction AD, and BC */


	/*
	 *  We look at the points in the diagonal next cells to determine
	 *  the curvature along each diagonal of this cell.  This cell is
	 *  divided into two triangles by cutting across the cell in the
	 *  direction of least curvature.
	 *
	 *	*  *  *	 *
	 *	 \      /
	 *	  \C  D/
	 *	*  *--*  *
	 *	   |\/|
	 *	   |/\|
	 *	*  *--*  *
	 *	  /A  B\
	 *	 /	\
	 *	*  *  *	 *
	 */

	lo[X] = A[X] - 1;
	lo[Y] = A[Y] - 1;
	hi[X] = D[X] + 1;
	hi[Y] = D[Y] + 1;

	/* a little bounds checking */
	if (lo[X] < 0) lo[X] = 0;
	if (lo[Y] < 0) lo[Y] = 0;
	if (hi[X] > dsp->xsiz) 
	    hi[X] = dsp->xsiz;

	if (hi[Y] > dsp->ysiz)
	    hi[Y] = dsp->ysiz;

	/* compute curvature along the A->D direction */
	h1 = DSP(&dsp->dsp_i, lo[X], lo[Y]);
	h2 = A[Z];
	h3 = D[Z];
	h4 = DSP(&dsp->dsp_i, hi[X], hi[Y]);

	cAD = fabs(h3 + h1 - 2*h2 ) + fabs( h4 + h2 - 2*h3 );


	/* compute curvature along the B->C direction */
	h1 = DSP(&dsp->dsp_i, hi[X], lo[Y]);
	h2 = B[Z];
	h3 = C[Z];
	h4 = DSP(&dsp->dsp_i, lo[X], hi[Y]);

	cBC = fabs(h3 + h1 - 2*h2 ) + fabs( h4 + h2 - 2*h3 );

	if ( cAD < cBC ) {
	    /* A-D cut is fine, no need to permute */
	    if (RT_G_DEBUG & DEBUG_HF)
		bu_log("A-D cut (no swap)\n");

	    return 0;
	}

	/* fallthrough */

    }
    case DSP_CUT_DIR_ULlr:
	{
	/* prefer the B-C cut */
	int tmp[3];

	VMOVE(tmp, A);
	VMOVE(A, B);
	VMOVE(B, tmp);

	VMOVE(tmp, D);
	VMOVE(D, C);
	VMOVE(C, tmp);

	if (RT_G_DEBUG & DEBUG_HF)
	    bu_log("B-C cut (swap)\n");
	}
	return 0;
	break;
    }
    bu_log("%s:%d Unknown DSP cut direction: %d\n",
	   __FILE__, __LINE__, dsp->dsp_i.dsp_cuttype);
    bu_bomb("");
    /* not reached */
    return -1;
}



/* 
 *
 *
 *
 * triangle with origin at A, X axis along AB, Y axis along AC
 *
 *	B--A	C	A--B	   C
 *	   |	|	|	   |
 *	   C	A--B	C	B--A
 */
int
project_pt(point_t out,
	   int A[3],
	   int B[3],
	   int C[3],
	   point_t pt)
{
    int dx, dy;
    double alpha, beta, x, y;
    vect_t AB, AC;

    if (RT_G_DEBUG & DEBUG_HF) {
	bu_log("     pt %g %g %g\n", V3ARGS(pt));
	bu_log(" origin %d %d %d\n", V3ARGS(A));
	bu_log("    Bpt %d %d %d\n", V3ARGS(B));
	bu_log("    Cpt %d %d %d\n", V3ARGS(C));
    }
    if ((B[X] - A[X]) < 0) dx = -1;
    else dx = 1;
    if ((C[Y] - A[Y]) < 0) dy = -1;
    else dy = 1;

    x = pt[X] - A[X];
    y = pt[Y] - A[Y];

    alpha = x * dx;
    beta = y * dy;
    if (RT_G_DEBUG & DEBUG_HF) {
	bu_log("alpha:%g beta:%g\n", alpha, beta); 
    }
    if (alpha < -SMALL_FASTF) {
	bu_log ("Alpha negative: %g  x:%g  dx:%d\n", alpha, x, dx);
    }
    if (beta < -SMALL_FASTF) {
	bu_log ("Beta negative: %g  x:%g  dx:%d\n", beta, y, dy);
    }
    CLAMP(alpha, 0.0, 1.0);
    CLAMP(beta, 0.0, 1.0);

    if (RT_G_DEBUG & DEBUG_HF) {
	bu_log("x:%g y:%g dx:%d dy:%d alpha:%g beta:%g\n", 
	       x, y, dx, dy, alpha, beta);
    }
    if ((alpha+beta) > (1.0+SMALL_FASTF)) {
	if (RT_G_DEBUG & DEBUG_HF) bu_log("Not this triangle\n");
	return 1;
    }

    VSUB2(AB, B, A);
    VSUB2(AC, C, A);

    VJOIN2(out, A, alpha, AB, beta, AC);
    if (RT_G_DEBUG & DEBUG_HF) bu_log("out: %g %g %g\n", V3ARGS(out));

    return 0;
}
/*	D S P _ P O S
 *
 *
 *	Given an arbitrary point return the projection of that point onto
 * 	the surface of the DSP.  If the point is outside the bounds of the DSP
 *	then it will be projected to the nearest edge of the DSP.
 *	Return the cell number and the height above/below the plane
 */
int
dsp_pos(point_t out, /* return value */
	struct soltab *stp, /* pointer to soltab for dsp */
	point_t p)	/* model space point */
{
    struct dsp_specific *dsp;
    point_t pt, tri_pt;
    int x, y;
    int A[3], B[3], C[3], D[3];

    struct dsp_rpp dsp_rpp;

    RT_CK_SOLTAB(stp);

    if (stp->st_id != ID_DSP) return 1;

    dsp = (struct dsp_specific *)stp->st_specific;

    MAT4X3PNT(pt, dsp->dsp_i.dsp_mtos, p);


    if (RT_G_DEBUG & DEBUG_HF) {
	VPRINT("user_point", p);
	VPRINT("dsp_point", pt);
    }
    x = pt[X];
    y = pt[Y];

    CLAMP(x, 0, XSIZ(dsp)-1);
    CLAMP(y, 0, YSIZ(dsp)-1);

    if (RT_G_DEBUG & DEBUG_HF)
	bu_log("x:%d y:%d\n", x, y);

    VSET(dsp_rpp.dsp_min, x, y, 0);
    VSET(dsp_rpp.dsp_max, x+1, y+1, 0);

    VSET(A, x, y, DSP(&dsp->dsp_i, x, y) );
    x += 1;
    VSET(B, x, y, DSP(&dsp->dsp_i, x, y) );
    y += 1;
    VSET(D, x, y, DSP(&dsp->dsp_i, x, y) );
    x -= 1;
    VSET(C, x, y, DSP(&dsp->dsp_i, x, y) );
    y -= 1;

    if (RT_G_DEBUG & DEBUG_HF) {
	bu_log(" A: %d %d %d\n", V3ARGS(A));
	bu_log(" B: %d %d %d\n", V3ARGS(B));
	bu_log(" C: %d %d %d\n", V3ARGS(C));
	bu_log(" D: %d %d %d\n", V3ARGS(D));
    }

    swap_cell_pts(A, B, C, D, dsp);
    if (RT_G_DEBUG & DEBUG_HF) {
	bu_log(" A: %d %d %d\n", V3ARGS(A));
	bu_log(" B: %d %d %d\n", V3ARGS(B));
	bu_log(" C: %d %d %d\n", V3ARGS(C));
	bu_log(" D: %d %d %d\n", V3ARGS(D));
    }

    if (project_pt(tri_pt, B, A, D, pt)) {
	if (project_pt(tri_pt, C, D, A, pt)) {
	    bu_log("Now what???\n");
	}
    }

    MAT4X3PNT(out, dsp->dsp_i.dsp_stom, tri_pt);
    if (RT_G_DEBUG & DEBUG_HF) {
	VPRINT("user_pt", p);
	VPRINT("tri_pt", tri_pt);
	VPRINT("model_space", out);
	bu_log("X: %d Y:%d\n",x, y);
    }

    return 0;
}


@


1.109.2.1
log
@Initial ANSIfication
@
text
@d43 1
a43 1
static const char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.109 2002/09/05 04:10:30 butler Exp $ (BRL)";
d519 3
a521 1
dsp_print_v4(struct bu_vls *vls, const struct rt_dsp_internal *dsp_ip)
d631 2
a632 1
rt_dsp_print(register const struct soltab *stp)
d924 4
a927 1
rt_dsp_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
d2521 5
a2525 1
rt_dsp_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
d2674 6
a2679 6
rt_dsp_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
                  	               /* An array of solid pointers */
                		       /* An array of ray pointers */
                                    /* array of segs (results returned) */
        		  	       /* Number of ray/object pairs */
                       	    
d2794 4
a2797 1
rt_dsp_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
d2977 4
a2980 1
rt_dsp_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
d3001 5
a3005 1
rt_dsp_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
d3097 2
a3098 1
rt_dsp_free(register struct soltab *stp)
d3127 1
a3127 1
rt_dsp_class(void)
d3139 5
a3143 1
rt_dsp_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d3379 6
a3384 1
rt_dsp_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d3595 5
a3599 1
rt_dsp_import(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d3693 5
a3697 1
rt_dsp_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d3750 7
a3756 1
rt_dsp_import5(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip, struct resource *resp, const int minor_type)
d3857 7
a3863 1
rt_dsp_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip, struct resource *resp, const int minor_type)
d3996 2
a3997 1
rt_dsp_ifree(struct rt_db_internal *ip)
d4100 4
a4103 1
rt_dsp_tclget(Tcl_Interp *interp, const struct rt_db_internal *intern, const char *attr)
d4185 5
a4189 1
rt_dsp_tcladjust(Tcl_Interp *interp, struct rt_db_internal *intern, int argc, char **argv)
@


1.109.2.2
log
@sync branch with HEAD
@
text
@d39 1
a39 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d43 1
a43 1
static const char RCSdsp[] = "@@(#)$Header$ (BRL)";
d200 1
d1139 2
a1140 1
    dlog("searching for insertion point for seg w in/out dist %g %g\n",
d1142 1
a1142 1

d1267 1
a1267 5

    if (seg->seg_in.hit_dist > 0.0 || seg->seg_out.hit_dist > 0.0) {
	return (++isect->num_segs > isect->ap->a_onehit);
    }
    return 0;
d1480 2
a1481 2
	     struct dsp_specific *dsp,
	     struct dsp_rpp *dsp_rpp)
d1485 1
d1496 1
a1496 1
    switch (dsp->dsp_i.dsp_cuttype) {
d1509 2
a1510 2
		   dsp_rpp->dsp_min[X],
		   dsp_rpp->dsp_min[Y]);
d1530 4
a1533 4
	lo[X] = dsp_rpp->dsp_min[X] - 1;
	lo[Y] = dsp_rpp->dsp_min[Y] - 1;
	hi[X] = dsp_rpp->dsp_max[X] + 1;
	hi[Y] = dsp_rpp->dsp_max[Y] + 1;
d1538 2
a1539 2
	if (hi[X] > dsp->xsiz) 
	    hi[X] = dsp->xsiz;
d1541 2
a1542 2
	if (hi[Y] > dsp->ysiz)
	    hi[Y] = dsp->ysiz;
d1545 1
a1545 1
	h1 = DSP(&dsp->dsp_i, lo[X], lo[Y]);
d1548 1
a1548 1
	h4 = DSP(&dsp->dsp_i, hi[X], hi[Y]);
d1554 1
a1554 1
	h1 = DSP(&dsp->dsp_i, hi[X], lo[Y]);
d1557 1
a1557 1
	h4 = DSP(&dsp->dsp_i, lo[X], hi[Y]);
d1592 3
a1594 3
	x = dsp_rpp->dsp_min[X];
	y = dsp_rpp->dsp_min[Y];
	VSET(B, x, y, DSP(&dsp->dsp_i, x, y) );
d1596 2
a1597 2
	x = dsp_rpp->dsp_max[X];
	VSET(A, x, y, DSP(&dsp->dsp_i, x, y) );
d1599 2
a1600 2
	y = dsp_rpp->dsp_max[Y];
	VSET(C, x, y, DSP(&dsp->dsp_i, x, y) );
d1602 2
a1603 2
	x = dsp_rpp->dsp_min[X];
	VSET(D, x, y, DSP(&dsp->dsp_i, x, y) );
d1609 1
a1609 1
	   __FILE__, __LINE__, dsp->dsp_i.dsp_cuttype);
d1848 1
a1848 1
    (void)permute_cell(A, B, C, D, isect->dsp, &dsp_bb->dspb_rpp);
d1987 1
a1987 2
	if (RT_G_DEBUG & DEBUG_HF)
	    plot_cell_top(isect, dsp_bb, A, B, C, D, hits, 3, 0);
d2402 1
a2402 1
	VMOVE(seg_out.hit_point, maxpt);
d2410 4
a2413 4
	    /* we need these for debug output
	     * VMOVE(seg_in.hit_point, minpt);
	     * VMOVE(seg_out.hit_point, maxpt);
	     */
a2552 2
    isect.num_segs = 0;

d3015 2
d3018 3
a3020 3
    VSET( tmp, XSIZ(dsp), 0.0, 0.0 );	/* X direction vector */
    MAT4X3VEC( U_dir,  dsp->dsp_i.dsp_stom, tmp ); /* into model space */
    U_len = MAGNITUDE( U_dir );		/* remember model space length */
d3022 1
a3022 1
    VSCALE( U_dir, U_dir, one_over_len ); /* scale to unit length in model space */
d3024 3
a3026 3
    VSET( tmp, 0.0, YSIZ(dsp), 0.0 );	/* Y direction vector */
    MAT4X3VEC( V_dir,  dsp->dsp_i.dsp_stom, tmp );
    V_len = MAGNITUDE( V_dir );
d3028 1
a3028 1
    VSCALE( V_dir, V_dir, one_over_len ); /* scale to unit length in model space */
d3030 2
a3031 2
    /* divide the hit-point radius by the U/V unit length distance */
    r = ap->a_rbeam + ap->a_diverge * hitp->hit_dist;
d3038 15
a3052 17
    VREVERSE( rev_dir, ap->a_ray.r_dir );
    VMOVE( norm, hitp->hit_normal );
    dot_N = VDOT( rev_dir, norm );
    VJOIN1( UV_dir, rev_dir, -dot_N, norm );
    VUNITIZE( UV_dir );

    if (NEAR_ZERO( dot_N, SMALL_FASTF ) ) {
	/* ray almost perfectly 90 degrees to surface */
	uvp->uv_du = min_r_U;
	uvp->uv_dv = min_r_V;
    } else {
	/* somehow this computes the extent of U and V in the radius */
	uvp->uv_du = (r / U_len) * VDOT( UV_dir, U_dir ) / dot_N;
	uvp->uv_dv = (r / V_len) * VDOT( UV_dir, V_dir ) / dot_N;
    }


a3137 4
    if (! dsp_ip->dsp_mp ) {
	bu_log("cannot find data for DSP\n");
	return 0;
    }
d3256 1
a3256 1
	    if ( (s_pt[Z] = DSP(dsp_ip, x, y)) ) {
d3275 1
a3275 1
	if ( (s_pt[Z] = DSP(dsp_ip, xlim, y)) ) {
d3306 1
a3306 1
	    if ( (s_pt[Z] = DSP(dsp_ip, x, y)) ) {
d3325 1
a3325 1
	if ( (s_pt[Z] = DSP(dsp_ip, x, ylim)) ) {
d3374 1
a3374 1
 *		!0 Failure
d3393 1
a3393 1
	return 0;
a4179 264

/*	S W A P _ C E L L _ P T S
 *
 */
static int
swap_cell_pts(int A[3],
	      int B[3],
	      int C[3],
	      int D[3],
	      struct dsp_specific *dsp)

{
    switch (dsp->dsp_i.dsp_cuttype) {
    case DSP_CUT_DIR_llUR:
	return  0;
	break;

    case DSP_CUT_DIR_ADAPT: {
	int lo[2], hi[2];
	double h1, h2, h3, h4;
	double cAD, cBC;  /* curvature in direction AD, and BC */


	/*
	 *  We look at the points in the diagonal next cells to determine
	 *  the curvature along each diagonal of this cell.  This cell is
	 *  divided into two triangles by cutting across the cell in the
	 *  direction of least curvature.
	 *
	 *	*  *  *	 *
	 *	 \      /
	 *	  \C  D/
	 *	*  *--*  *
	 *	   |\/|
	 *	   |/\|
	 *	*  *--*  *
	 *	  /A  B\
	 *	 /	\
	 *	*  *  *	 *
	 */

	lo[X] = A[X] - 1;
	lo[Y] = A[Y] - 1;
	hi[X] = D[X] + 1;
	hi[Y] = D[Y] + 1;

	/* a little bounds checking */
	if (lo[X] < 0) lo[X] = 0;
	if (lo[Y] < 0) lo[Y] = 0;
	if (hi[X] > dsp->xsiz) 
	    hi[X] = dsp->xsiz;

	if (hi[Y] > dsp->ysiz)
	    hi[Y] = dsp->ysiz;

	/* compute curvature along the A->D direction */
	h1 = DSP(&dsp->dsp_i, lo[X], lo[Y]);
	h2 = A[Z];
	h3 = D[Z];
	h4 = DSP(&dsp->dsp_i, hi[X], hi[Y]);

	cAD = fabs(h3 + h1 - 2*h2 ) + fabs( h4 + h2 - 2*h3 );


	/* compute curvature along the B->C direction */
	h1 = DSP(&dsp->dsp_i, hi[X], lo[Y]);
	h2 = B[Z];
	h3 = C[Z];
	h4 = DSP(&dsp->dsp_i, lo[X], hi[Y]);

	cBC = fabs(h3 + h1 - 2*h2 ) + fabs( h4 + h2 - 2*h3 );

	if ( cAD < cBC ) {
	    /* A-D cut is fine, no need to permute */
	    if (RT_G_DEBUG & DEBUG_HF)
		bu_log("A-D cut (no swap)\n");

	    return 0;
	}

	/* fallthrough */

    }
    case DSP_CUT_DIR_ULlr:
	{
	/* prefer the B-C cut */
	int tmp[3];

	VMOVE(tmp, A);
	VMOVE(A, B);
	VMOVE(B, tmp);

	VMOVE(tmp, D);
	VMOVE(D, C);
	VMOVE(C, tmp);

	if (RT_G_DEBUG & DEBUG_HF)
	    bu_log("B-C cut (swap)\n");
	}
	return 0;
	break;
    }
    bu_log("%s:%d Unknown DSP cut direction: %d\n",
	   __FILE__, __LINE__, dsp->dsp_i.dsp_cuttype);
    bu_bomb("");
    /* not reached */
    return -1;
}



/* 
 *
 *
 *
 * triangle with origin at A, X axis along AB, Y axis along AC
 *
 *	B--A	C	A--B	   C
 *	   |	|	|	   |
 *	   C	A--B	C	B--A
 */
int
project_pt(point_t out,
	   int A[3],
	   int B[3],
	   int C[3],
	   point_t pt)
{
    int dx, dy;
    double alpha, beta, x, y;
    vect_t AB, AC;

    if (RT_G_DEBUG & DEBUG_HF) {
	bu_log("     pt %g %g %g\n", V3ARGS(pt));
	bu_log(" origin %d %d %d\n", V3ARGS(A));
	bu_log("    Bpt %d %d %d\n", V3ARGS(B));
	bu_log("    Cpt %d %d %d\n", V3ARGS(C));
    }
    if ((B[X] - A[X]) < 0) dx = -1;
    else dx = 1;
    if ((C[Y] - A[Y]) < 0) dy = -1;
    else dy = 1;

    x = pt[X] - A[X];
    y = pt[Y] - A[Y];

    alpha = x * dx;
    beta = y * dy;
    if (RT_G_DEBUG & DEBUG_HF) {
	bu_log("alpha:%g beta:%g\n", alpha, beta); 
    }
    if (alpha < -SMALL_FASTF) {
	bu_log ("Alpha negative: %g  x:%g  dx:%d\n", alpha, x, dx);
    }
    if (beta < -SMALL_FASTF) {
	bu_log ("Beta negative: %g  x:%g  dx:%d\n", beta, y, dy);
    }
    CLAMP(alpha, 0.0, 1.0);
    CLAMP(beta, 0.0, 1.0);

    if (RT_G_DEBUG & DEBUG_HF) {
	bu_log("x:%g y:%g dx:%d dy:%d alpha:%g beta:%g\n", 
	       x, y, dx, dy, alpha, beta);
    }
    if ((alpha+beta) > (1.0+SMALL_FASTF)) {
	if (RT_G_DEBUG & DEBUG_HF) bu_log("Not this triangle\n");
	return 1;
    }

    VSUB2(AB, B, A);
    VSUB2(AC, C, A);

    VJOIN2(out, A, alpha, AB, beta, AC);
    if (RT_G_DEBUG & DEBUG_HF) bu_log("out: %g %g %g\n", V3ARGS(out));

    return 0;
}
/*	D S P _ P O S
 *
 *
 *	Given an arbitrary point return the projection of that point onto
 * 	the surface of the DSP.  If the point is outside the bounds of the DSP
 *	then it will be projected to the nearest edge of the DSP.
 *	Return the cell number and the height above/below the plane
 */
int
dsp_pos(point_t out, /* return value */
	struct soltab *stp, /* pointer to soltab for dsp */
	point_t p)	/* model space point */
{
    struct dsp_specific *dsp;
    point_t pt, tri_pt;
    int x, y;
    int A[3], B[3], C[3], D[3];

    struct dsp_rpp dsp_rpp;

    RT_CK_SOLTAB(stp);

    if (stp->st_id != ID_DSP) return 1;

    dsp = (struct dsp_specific *)stp->st_specific;

    MAT4X3PNT(pt, dsp->dsp_i.dsp_mtos, p);


    if (RT_G_DEBUG & DEBUG_HF) {
	VPRINT("user_point", p);
	VPRINT("dsp_point", pt);
    }
    x = pt[X];
    y = pt[Y];

    CLAMP(x, 0, XSIZ(dsp)-1);
    CLAMP(y, 0, YSIZ(dsp)-1);

    if (RT_G_DEBUG & DEBUG_HF)
	bu_log("x:%d y:%d\n", x, y);

    VSET(dsp_rpp.dsp_min, x, y, 0);
    VSET(dsp_rpp.dsp_max, x+1, y+1, 0);

    VSET(A, x, y, DSP(&dsp->dsp_i, x, y) );
    x += 1;
    VSET(B, x, y, DSP(&dsp->dsp_i, x, y) );
    y += 1;
    VSET(D, x, y, DSP(&dsp->dsp_i, x, y) );
    x -= 1;
    VSET(C, x, y, DSP(&dsp->dsp_i, x, y) );
    y -= 1;

    if (RT_G_DEBUG & DEBUG_HF) {
	bu_log(" A: %d %d %d\n", V3ARGS(A));
	bu_log(" B: %d %d %d\n", V3ARGS(B));
	bu_log(" C: %d %d %d\n", V3ARGS(C));
	bu_log(" D: %d %d %d\n", V3ARGS(D));
    }

    swap_cell_pts(A, B, C, D, dsp);
    if (RT_G_DEBUG & DEBUG_HF) {
	bu_log(" A: %d %d %d\n", V3ARGS(A));
	bu_log(" B: %d %d %d\n", V3ARGS(B));
	bu_log(" C: %d %d %d\n", V3ARGS(C));
	bu_log(" D: %d %d %d\n", V3ARGS(D));
    }

    if (project_pt(tri_pt, B, A, D, pt)) {
	if (project_pt(tri_pt, C, D, A, pt)) {
	    bu_log("Now what???\n");
	}
    }

    MAT4X3PNT(out, dsp->dsp_i.dsp_stom, tri_pt);
    if (RT_G_DEBUG & DEBUG_HF) {
	VPRINT("user_pt", p);
	VPRINT("tri_pt", tri_pt);
	VPRINT("model_space", out);
	bu_log("X: %d Y:%d\n",x, y);
    }

    return 0;
}


@


1.108
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d43 1
a43 1
static const char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.105 2002/07/12 21:41:44 butler Exp $ (BRL)";
d3526 4
a3529 4
						 struct rt_db_internal	*ip,
						 const struct bu_external	*ep,
						 register const mat_t	mat,
						 const struct db_i		*dbip)
d3531 1
a3531 1
	mat_t	tmp;
d3551 1
a3551 1
			}	else {
d4215 7
d4223 15
@


1.107
log
@compiler warning quelling
@
text
@d43 1
a43 1
static const char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.106 2002/08/15 20:55:11 hartley Exp $ (BRL)";
d519 3
a521 1
dsp_print_v4(struct bu_vls *vls, const struct rt_dsp_internal *dsp_ip)
d631 2
a632 1
rt_dsp_print(register const struct soltab *stp)
d924 4
a927 1
rt_dsp_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
d2521 5
a2525 1
rt_dsp_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
d2674 6
a2679 6
rt_dsp_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
                  	               /* An array of solid pointers */
                		       /* An array of ray pointers */
                                    /* array of segs (results returned) */
        		  	       /* Number of ray/object pairs */
                       	    
d2794 4
a2797 1
rt_dsp_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
d2977 4
a2980 1
rt_dsp_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
d3001 5
a3005 1
rt_dsp_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
d3097 2
a3098 1
rt_dsp_free(register struct soltab *stp)
d3127 1
a3127 1
rt_dsp_class(void)
d3139 5
a3143 1
rt_dsp_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d3281 1
a3281 1
	    if ((s_pt[Z] = DSP(dsp_ip, x, y))) {
d3300 1
a3300 1
	if ((s_pt[Z] = DSP(dsp_ip, xlim, y))) {
d3331 1
a3331 1
	    if ((s_pt[Z] = DSP(dsp_ip, x, y))) {
d3350 1
a3350 1
	if ((s_pt[Z] = DSP(dsp_ip, x, ylim))) {
d3379 6
a3384 1
rt_dsp_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d3595 5
a3599 1
rt_dsp_import(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d3693 5
a3697 1
rt_dsp_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d3750 7
a3756 1
rt_dsp_import5(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip, struct resource *resp, const int minor_type)
d3857 7
a3863 1
rt_dsp_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip, struct resource *resp, const int minor_type)
d3996 2
a3997 1
rt_dsp_ifree(struct rt_db_internal *ip)
d4100 4
a4103 1
rt_dsp_tclget(Tcl_Interp *interp, const struct rt_db_internal *intern, const char *attr)
d4185 5
a4189 1
rt_dsp_tcladjust(Tcl_Interp *interp, struct rt_db_internal *intern, int argc, char **argv)
@


1.106
log
@Converted from K&R to ANSI C - RFH
@
text
@d43 1
a43 1
static const char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.105 2002/07/12 21:41:44 butler Exp $ (BRL)";
d3256 1
a3256 1
	    if (s_pt[Z] = DSP(dsp_ip, x, y)) {
d3275 1
a3275 1
	if (s_pt[Z] = DSP(dsp_ip, xlim, y)) {
d3306 1
a3306 1
	    if (s_pt[Z] = DSP(dsp_ip, x, y)) {
d3325 1
a3325 1
	if (s_pt[Z] = DSP(dsp_ip, x, ylim)) {
@


1.105
log
@fixed typo in drawing macros
@
text
@d43 1
a43 1
static const char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.104 2002/07/12 21:29:32 butler Exp $ (BRL)";
d519 1
a519 3
dsp_print_v4(vls, dsp_ip)
     struct bu_vls *vls;
     const struct rt_dsp_internal *dsp_ip;
d629 1
a629 2
rt_dsp_print( stp )
     register const struct soltab *stp;
d921 1
a921 4
rt_dsp_prep( stp, ip, rtip )
     struct soltab		*stp;
     struct rt_db_internal	*ip;
     struct rt_i		*rtip;
d2515 1
a2515 5
rt_dsp_shot( stp, rp, ap, seghead )
     struct soltab		*stp;
     register struct xray	*rp;
     struct application	*ap;
     struct seg		*seghead;
d2664 6
a2669 6
rt_dsp_vshot( stp, rp, segp, n, ap )
     struct soltab	       *stp[]; /* An array of solid pointers */
     struct xray		*rp[]; /* An array of ray pointers */
     struct  seg            segp[]; /* array of segs (results returned) */
     int		  	    n; /* Number of ray/object pairs */
     struct application	*ap;
d2784 1
a2784 4
rt_dsp_norm( hitp, stp, rp )
     register struct hit	*hitp;
     struct soltab		*stp;
     register struct xray	*rp;
d2964 1
a2964 4
rt_dsp_curve( cvp, hitp, stp )
     register struct curvature *cvp;
     register struct hit	*hitp;
     struct soltab		*stp;
d2985 1
a2985 5
rt_dsp_uv( ap, stp, hitp, uvp )
     struct application	*ap;
     struct soltab		*stp;
     register struct hit	*hitp;
     register struct uvcoord	*uvp;
d3077 1
a3077 2
rt_dsp_free( stp )
     register struct soltab *stp;
d3106 1
a3106 1
rt_dsp_class()
d3118 1
a3118 5
rt_dsp_plot( vhead, ip, ttol, tol )
     struct bu_list		*vhead;
     struct rt_db_internal	*ip;
     const struct rt_tess_tol *ttol;
     const struct bn_tol	*tol;
d3354 1
a3354 6
rt_dsp_tess( r, m, ip, ttol, tol )
     struct nmgregion	**r;
     struct model		*m;
     struct rt_db_internal	*ip;
     const struct rt_tess_tol *ttol;
     const struct bn_tol	*tol;
d3565 1
a3565 5
rt_dsp_import( ip, ep, mat, dbip )
     struct rt_db_internal		*ip;
     const struct bu_external	*ep;
     register const mat_t		mat;
     const struct db_i		*dbip;
d3659 1
a3659 5
rt_dsp_export( ep, ip, local2mm, dbip )
     struct bu_external		*ep;
     const struct rt_db_internal	*ip;
     double				local2mm;
     const struct db_i		*dbip;
d3712 1
a3712 7
rt_dsp_import5( ip, ep, mat, dbip, resp, minor_type )
     struct rt_db_internal		*ip;
     const struct bu_external	*ep;
     register const mat_t		mat;
     const struct db_i		*dbip;
     struct resource		*resp;
     const int			minor_type;
d3813 1
a3813 7
rt_dsp_export5( ep, ip, local2mm, dbip, resp, minor_type )
     struct bu_external		*ep;
     const struct rt_db_internal	*ip;
     double				local2mm;
     const struct db_i		*dbip;
     struct resource		*resp;
     const int			minor_type;
d3946 1
a3946 2
rt_dsp_ifree( ip )
     struct rt_db_internal	*ip;
d4049 1
a4049 4
rt_dsp_tclget( interp, intern, attr )
Tcl_Interp			*interp;
const struct rt_db_internal	*intern;
const char			*attr;
d4131 1
a4131 5
rt_dsp_tcladjust( interp, intern, argc, argv )
Tcl_Interp		*interp;
struct rt_db_internal	*intern;
int			argc;
char			**argv;
@


1.104
log
@Plot routine changed so that 0-elevation values are no longer plotted
@
text
@d43 1
a43 1
static const char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.103 2002/06/19 20:13:50 butler Exp $ (BRL)";
d3165 1
a3165 1
	MAT4X3PNT(m_pt, dsp_ip->dsp_stom, s_pt); \
d3169 1
a3169 1
	MAT4X3PNT(m_pt, dsp_ip->dsp_stom, s_pt); \
@


1.103
log
@Fixed "smoothed normal" computations
@
text
@d43 1
a43 1
static const char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.102 2002/06/08 00:28:58 butler Exp $ (BRL)";
d145 1
a145 1
#define DSP(_p,_x,_y) dsp_val(_p, _x, _y)
d147 1
a147 1
dsp_val(struct rt_dsp_internal *dsp_i, unsigned x, unsigned y)
d153 1
a153 1
	       __FILE__, __LINE__, x, y, dsp_i->dsp_xcnt, dsp_i->dsp_ycnt);
d3149 1
d3155 1
d3164 1
a3164 1
#define MOVE() \
d3168 1
a3168 1
#define DRAW() \
d3175 1
a3175 1
    MOVE();
d3178 1
a3178 1
    DRAW();
d3181 1
a3181 1
    DRAW();
d3184 1
a3184 1
    DRAW();
d3187 1
a3187 1
    DRAW();
d3192 1
a3192 1
    DRAW();
d3195 1
a3195 1
    MOVE();
d3197 1
a3197 1
    DRAW();
d3201 1
a3201 1
    MOVE();
d3203 1
a3203 1
    DRAW();
d3206 1
a3206 1
    MOVE();
d3208 1
a3208 1
    DRAW();
d3218 1
a3218 1
	MOVE();
d3223 1
a3223 1
	    DRAW();
d3230 1
a3230 1
	MOVE();
d3235 1
a3235 1
	    DRAW();
d3267 1
d3270 7
a3276 1
	MOVE();
d3280 17
a3296 2
	    s_pt[Z] = DSP(dsp_ip, x, y);
	    DRAW();
d3300 14
a3313 2
	s_pt[Z] = DSP(dsp_ip, xlim, y);
	DRAW();
d3319 8
a3326 1
	MOVE();
d3330 17
a3346 2
	    s_pt[Z] = DSP(dsp_ip, x, y);
	    DRAW();
d3350 14
a3363 2
	s_pt[Z] = DSP(dsp_ip, x, ylim);
	DRAW();
@


1.102
log
@Normal interpolation had become broken because the cell number was not
being saved in hit_vpriv[XY] for rt_dsp_norm() to use.  Fixed that.
@
text
@d43 1
a43 1
static const char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.101 2002/02/26 20:40:36 morrison Exp $ (BRL)";
d2687 2
d2695 7
a2701 6
compute_normal_at_gridpoint(N, dsp, x, y, fd, boolean)
     vect_t N;
     struct dsp_specific *dsp;
     int x, y;
     FILE *fd;
     int boolean;
d2717 1
a2717 1
    point_t A, C, D, E, tmp;
d2720 5
d2726 2
a2727 1
    if (fd && boolean) {
d2729 2
a2730 4
	/* the debugging/plot version, with more matrix operations */
	if (x == 0) {	VSET(tmp, x, y, DSP(&dsp->dsp_i, x, y) );	}
	else {		VSET(tmp, x-1, y, DSP(&dsp->dsp_i, x-1, y) );	}
	MAT4X3PNT(A, dsp->dsp_i.dsp_stom, tmp);
d2732 2
a2733 3
	if (x >= XSIZ(dsp)) { VSET(tmp, x, y,  DSP(&dsp->dsp_i, x, y) );    } 
	else {		  VSET(tmp, x+1, y,  DSP(&dsp->dsp_i, x+1, y) );}
	MAT4X3PNT(C, dsp->dsp_i.dsp_stom, tmp);
d2735 2
d2738 1
a2738 3
	if (y == 0) {	VSET(tmp, x, y, DSP(&dsp->dsp_i, x, y) );       }
	else {		VSET(tmp, x, y-1, DSP(&dsp->dsp_i, x, y-1) );	}
	MAT4X3PNT(D, dsp->dsp_i.dsp_stom, tmp);
a2739 3
	if (y >= YSIZ(dsp)) { VSET(tmp, x, y, DSP(&dsp->dsp_i, x, y) );     }
	else {		 VSET(tmp, x, y+1, DSP(&dsp->dsp_i, x, y+1) );	}
	MAT4X3PNT(E, dsp->dsp_i.dsp_stom, tmp);
d2741 3
a2743 3
	pl_color(fd, 220, 220, 90);
	pdv_3line(fd, A, C);
	pdv_3line(fd, D, E);
d2745 2
a2746 2
	VSUB2(Vac, C, A);
	VSUB2(Vde, E, D);
d2748 2
a2749 1
	VCROSS(N, Vac, Vde);
d2751 2
a2752 1
	VUNITIZE(N);
d2754 2
a2755 1
    } else {
d2757 3
a2759 3
	/* the leaner, faster, production version */
	if (x == 0) {	VSET(A, x, y, DSP(&dsp->dsp_i, x, y) );	}
	else {		VSET(A, x-1, y, DSP(&dsp->dsp_i, x-1, y) );	}
d2761 10
d2772 5
a2776 2
	if (x >= XSIZ(dsp)) { VSET(C, x, y,  DSP(&dsp->dsp_i, x, y) );    } 
	else {		  VSET(C, x+1, y,  DSP(&dsp->dsp_i, x+1, y) );}
d2778 3
d2782 2
a2784 18
	if (y == 0) {	VSET(D, x, y, DSP(&dsp->dsp_i, x, y) );       }
	else {		VSET(D, x, y-1, DSP(&dsp->dsp_i, x, y-1) );	}


	if (y >= YSIZ(dsp)) { VSET(E, x, y, DSP(&dsp->dsp_i, x, y) );     }
	else {		 VSET(E, x, y+1, DSP(&dsp->dsp_i, x, y+1) );	}


	VSUB2(Vac, C, A);
	VSUB2(Vde, E, D);

	VCROSS(tmp, Vac, Vde);

	MAT4X3VEC(N, dsp->dsp_i.dsp_stom, tmp);

	VUNITIZE(N);

    }
d2799 1
a2799 1
    vect_t N, t, tmp, A, B, C, D;
a2872 12
    }

    /* get the cell we hit
     * XXX Does this still get kept????
     */
    x = hitp->hit_vpriv[X];
    y = hitp->hit_vpriv[Y];

    compute_normal_at_gridpoint(Anorm, dsp, x, y, fd, 1);
    compute_normal_at_gridpoint(Bnorm, dsp, x+1, y, fd, 0);
    compute_normal_at_gridpoint(Dnorm, dsp, x+1, y+1, fd, 0);
    compute_normal_at_gridpoint(Cnorm, dsp, x, y+1, fd, 0);
a2873 2
    if (RT_G_DEBUG & DEBUG_HF) {
	
d2883 1
d2885 3
a2887 2
	/* Plot the normals we just got */
	pl_color(fd, 220, 220, 90);
d2889 5
a2893 21
	VSET(tmp, x,   y,   DSP(&dsp->dsp_i, x,   y));
	MAT4X3PNT(A, dsp->dsp_i.dsp_stom, tmp);
	VJOIN1(tmp, A, len, Anorm);
	pdv_3line(fd, A, tmp);

	VSET(tmp, x+1, y,   DSP(&dsp->dsp_i, x+1, y));
	MAT4X3PNT(B, dsp->dsp_i.dsp_stom, tmp);
	VJOIN1(tmp, B, len, Bnorm);
	pdv_3line(fd, B, tmp);

	VSET(tmp, x+1, y+1, DSP(&dsp->dsp_i, x+1, y+1));
	MAT4X3PNT(D, dsp->dsp_i.dsp_stom, tmp);
	VJOIN1(tmp, D, len, Dnorm);
	pdv_3line(fd, D, tmp);

	VSET(tmp, x,   y+1, DSP(&dsp->dsp_i, x,   y+1));
	MAT4X3PNT(C, dsp->dsp_i.dsp_stom, tmp);
	VJOIN1(tmp, C, len, Cnorm);
	pdv_3line(fd, C, tmp);

    }
d2949 1
@


1.101
log
@Fixed a bug/feature where processing is aborted (bombing macro) when a dsp is loaded that doesn't have the cut type set or when a dsp is loaded that cannot find it's data.  Both checks are now added and rt continues gracefully instead of bombing, mimicking other rt behavior when invalid/bad data is encountered.
@
text
@d43 1
a43 1
static const char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.100 2001/11/22 02:13:19 butler Exp $ (BRL)";
d1110 1
a1110 1
    dlog("add_seg %g %g line %d\n", in_hit->hit_dist, out_hit->hit_dist, line);
d1130 4
d1229 10
d1807 2
d1834 2
d1866 3
a1868 2
	dlog("  hit triangle 1 (alpha: %g beta:%g alpha+beta: %g)\n",
	     ab_first[0], ab_first[1], ab_first[0] + ab_first[1]);
d1884 3
a1886 2
	dlog("  hit triangle 2 (alpha: %g beta:%g alpha+beta: %g)\n",
	     ab_second[0], ab_second[1], ab_second[0] + ab_second[1]);
d2822 3
d2837 1
a2837 1
    if ( hitp->hit_surfno < ZTOP || !dsp->dsp_i.dsp_smooth ) {
d2869 3
a2871 1
    /* get the cell we hit */
@


1.100
log
@fixed hit-point calculation problem.  Improved speed infinitessimally.
@
text
@d43 1
a43 1
static const char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.99 2001/11/19 22:19:22 butler Exp $ (BRL)";
d574 2
a575 2
	bu_vls_printf( vls, "  Error Error Error");
	break;
d577 2
a578 2
	bu_vls_printf( vls, "  file");
	break;
d580 2
a581 2
	bu_vls_printf( vls, "  obj");
	break;
d583 2
a584 2
	bu_vls_printf( vls, "unk src type'%c'", dsp_ip->dsp_datasrc);
	break;
d586 1
a586 1

d588 5
a592 5
		   bu_vls_addr(&dsp_ip->dsp_name),
		   dsp_ip->dsp_xcnt,
		   dsp_ip->dsp_ycnt,
		   dsp_ip->dsp_smooth);

d595 1
a595 1
	bu_vls_printf( vls, "cut=ad" ); break;
d597 1
a597 1
	bu_vls_printf( vls, "cut=lR" ); break;
d599 1
a599 1
	bu_vls_printf( vls, "cut=Lr" ); break;
d601 3
a603 3
	bu_vls_printf( vls, "cut bogus('%c'/%d)",
		       dsp_ip->dsp_cuttype,
		       dsp_ip->dsp_cuttype ); break;
d605 2
a606 2


d608 1
a608 1

d612 1
a612 1

d615 2
a616 2
		   V4ARGS(dsp_ip->dsp_stom) );

d618 2
a619 2
		   V4ARGS( &dsp_ip->dsp_stom[4]) );

d621 2
a622 2
		   V4ARGS( &dsp_ip->dsp_stom[8]) );

d624 1
a624 1
		   V4ARGS( &dsp_ip->dsp_stom[12]) );
d634 3
a636 3
    register const struct dsp_specific *dsp =
	(struct dsp_specific *)stp->st_specific;
    struct bu_vls vls;
d639 4
a642 11
    RT_DSP_CK_MAGIC(dsp);
    BU_CK_VLS(&dsp->dsp_i.dsp_name);

    bu_vls_init( &vls );
    BU_CK_VLS(&vls);

    bu_vls_printf(&vls, "\n---------db version: %d----------\n",
		  stp->st_rtip->rti_dbip->dbi_version );

    switch (stp->st_rtip->rti_dbip->dbi_version) {
    case 4: 
d644 19
a662 12
	dsp_print_v4(&vls, &(dsp->dsp_i) );
	break;
    case 5:
	BU_CK_VLS(&vls);
	dsp_print_v5(&vls, &(dsp->dsp_i) );
	break;
    }

    bu_log("%s", bu_vls_addr( &vls));

    if (BU_VLS_IS_INITIALIZED( &vls )) bu_vls_free( &vls );

d673 20
a692 20
    int idx, i, j, k, curr_layer, x, y, xs, ys, xv, yv, tot;
    unsigned short dsp_min, dsp_max, cell_min, cell_max;
    unsigned short elev;
    struct dsp_bb *dsp_bb;
    struct dsp_rpp *t;
    struct dsp_bb_layer *curr, *prev;
    unsigned short subcell_size;

    /* First we compute the total number of struct dsp_bb's we will need */
    xs = dsp->xsiz;
    ys = dsp->ysiz;
    tot = xs * ys;
    /*    bu_log("layer %d   %dx%d\n", 0, xs, ys); */
    dsp->layers = 1;
    while ( xs > 1 || ys > 1 ) {
	xv = xs / DIM_BB_CHILDREN;
	yv = ys / DIM_BB_CHILDREN;
	if (xs % DIM_BB_CHILDREN) xv++;
	if (ys % DIM_BB_CHILDREN) yv++;

d694 1
a694 1
	if (RT_G_DEBUG & DEBUG_HF)
d697 11
a707 11
	tot += xv * yv;

	if (xv > 0) xs = xv;
	else xs = 1;

	if (yv > 0) ys = yv;
	else ys = 1;
	dsp->layers++;
    }


d709 2
a710 2
    if (RT_G_DEBUG & DEBUG_HF)
	bu_log("%d layers total\n", dsp->layers);
d712 26
a737 26

    /* allocate the struct dsp_bb's we will need */
    dsp->layer = bu_malloc(dsp->layers * sizeof(struct dsp_bb_layer),
			   "dsp_bb_layers array");
    dsp->bb_array = bu_malloc(tot * sizeof(struct dsp_bb), "dsp_bb array");

    /* now we fill in the "lowest" layer of struct dsp_bb's from the
     * raw data
     */
    dsp->layer[0].dim[X] = dsp->xsiz;
    dsp->layer[0].dim[Y] = dsp->ysiz;
    dsp->layer[0].p = dsp->bb_array;

    xs = dsp->xsiz;
    ys = dsp->ysiz;

    dsp_min = 0xffff;
    dsp_max = 0;

    for (y=0 ; y < YSIZ(dsp) ; y++) {

	cell_min = 0xffff;
	cell_max = 0;

	for (x=0 ; x < XSIZ(dsp) ; x++) {

d740 1
a740 1
		bu_log("filling %d,%d\n", x, y);
d744 1
a744 1

d748 1
a748 1

d752 1
a752 1

d756 1
a756 1

d760 1
a760 1

d766 1
a766 1

d768 1
a768 1

d773 2
a774 2
		dsp_bb->dspb_children[k] = 
		    (struct dsp_bb *)NULL;
d779 2
a780 2
		 x, y, V3ARGS(dsp_bb->dspb_rpp.dsp_min),
		 V3ARGS(dsp_bb->dspb_rpp.dsp_max) );
d782 1
a782 1

d786 1
d788 16
a803 17
    }

    *d_min = dsp_min;
    *d_max = dsp_max;


    if (RT_G_DEBUG & DEBUG_HF)
	bu_log("layer 0 filled\n");

    subcell_size = 1;

    /* now we compute successive layers from the initial layer */
    for (curr_layer = 1 ; curr_layer < dsp->layers ; curr_layer++ ) {
	/* compute the number of cells in each direction for this layer */

	xs = dsp->layer[curr_layer-1].dim[X];
	if (xs % DIM_BB_CHILDREN)  
d805 2
a806 2
		xs / DIM_BB_CHILDREN + 1;
	else			  
d808 4
a811 4
		xs / DIM_BB_CHILDREN;

	ys = dsp->layer[curr_layer-1].dim[Y];
	if (ys % DIM_BB_CHILDREN) 
d813 2
a814 2
		ys / DIM_BB_CHILDREN + 1;
	else			  
d816 5
a820 1
		ys / DIM_BB_CHILDREN;
d822 4
a825 10
	/* set the start of the array for this layer */
	dsp->layer[curr_layer].p = 
	    &dsp->layer[curr_layer-1].p[
		dsp->layer[curr_layer-1].dim[X] *
		dsp->layer[curr_layer-1].dim[Y] ];

	curr = &dsp->layer[curr_layer];
	prev = &dsp->layer[curr_layer-1];

	if (RT_G_DEBUG & DEBUG_HF)
d827 3
a829 3

	/* walk the grid and fill in the values for this layer */
	for (y=0 ; y < curr->dim[Y] ; y++ ) {
d831 22
a852 22
		int n, xp, yp;
		/* x,y are in the coordinates in the current
		 * layer.  xp,yp are the coordinates of the
		 * same area in the previous (lower) layer.
		 */
		xp = x * DIM_BB_CHILDREN;
		yp = y * DIM_BB_CHILDREN;

		/* initialize the current dsp_bb cell */
		dsp_bb = &curr->p[y*curr->dim[X]+x];
		dsp_bb->magic = MAGIC_dsp_bb;
		n = (int)pow( (double)DIM_BB_CHILDREN, (double)curr_layer);
		VSET(dsp_bb->dspb_rpp.dsp_min,
		     x * n, y * n, 0x0ffff);
		VSET(dsp_bb->dspb_rpp.dsp_max,
		     x * n, y * n, 0);

		/* record the dimensions of our children */
		dsp_bb->dspb_subcell_size = subcell_size;


		tot = 0;
d854 20
a873 20
		dlog("  cell %d,%d  (%d,%d-%d,%d)\n", x, y, 
		     dsp_bb->dspb_rpp.dsp_min[X],
		     dsp_bb->dspb_rpp.dsp_min[Y],
		     (x+1) * n, (y+1)*n);
#endif
		i=0;
		for (j=0 ; j<DIM_BB_CHILDREN && (yp+j)<prev->dim[Y] ; j++) {
		    for (i=0 ; i<DIM_BB_CHILDREN && (xp+i)<prev->dim[X]; i++) {

			idx = (yp+j) * prev->dim[X] + xp+i;

			t = &prev->p[ idx ].dspb_rpp;

			VMINMAX(dsp_bb->dspb_rpp.dsp_min,
				dsp_bb->dspb_rpp.dsp_max, t->dsp_min);
			VMINMAX(dsp_bb->dspb_rpp.dsp_min,
				dsp_bb->dspb_rpp.dsp_max, t->dsp_max);

			dsp_bb->dspb_children[tot++] = &prev->p[ idx ];

d875 6
a880 6
			dlog("\t\tsubcell %d,%d min: %d,%d,%d  max: %d,%d,%d\n",
			     xp+i, yp+j, V3ARGS(t->dsp_min), V3ARGS(t->dsp_max) );

			if (RT_G_DEBUG & DEBUG_HF) 
			    if (i+1 >= DIM_BB_CHILDREN || xp+i+1 >= prev->dim[X])
				bu_log("\n");
d882 2
a883 2
		    }
		}
d885 8
a892 8
		dlog("\t\txy: %d,%d, ij:%d,%d min:%d,%d,%d max:%d,%d,%d\n",
		     x, y, i, j,
		     V3ARGS(dsp_bb->dspb_rpp.dsp_min),
		     V3ARGS(dsp_bb->dspb_rpp.dsp_max) );
#endif

		dsp_bb->dspb_ch_dim[X] = i;
		dsp_bb->dspb_ch_dim[Y] = j;
d894 2
d897 1
a897 3
	subcell_size *= DIM_BB_CHILDREN;
    }

d899 5
a903 5
    if (RT_G_DEBUG & DEBUG_HF) {
	plot_layers(dsp);
	bu_log("_  x:%d y:%d min %d max %d\n",
	       XCNT(dsp), YCNT(dsp), dsp_min, dsp_max);
    }
d929 40
a968 22
    struct rt_dsp_internal		*dsp_ip;
    register struct dsp_specific	*dsp;
    unsigned short dsp_min, dsp_max;
    point_t pt, bbpt;
    vect_t work;
    fastf_t f;

    if (RT_G_DEBUG & DEBUG_HF)
	bu_log("rt_dsp_prep()\n");

    RT_CK_DB_INTERNAL(ip);
    dsp_ip = (struct rt_dsp_internal *)ip->idb_ptr;
    RT_DSP_CK_MAGIC(dsp_ip);
    BU_CK_VLS(&dsp_ip->dsp_name);

    switch (dsp_ip->dsp_datasrc) {
    case RT_DSP_SRC_V4_FILE: 
    case RT_DSP_SRC_FILE:
	BU_CK_MAPPED_FILE(dsp_ip->dsp_mp);

	/* we do this here and now because we will need it for the
	 * dsp_specific structure in a few lines
d970 25
a994 43
	bu_semaphore_acquire( RT_SEM_MODEL);
	++dsp_ip->dsp_mp->uses;
	bu_semaphore_release( RT_SEM_MODEL);
	break;
    case RT_DSP_SRC_OBJ:
	RT_CK_DB_INTERNAL(dsp_ip->dsp_bip);
	RT_CK_BINUNIF(dsp_ip->dsp_bip->idb_ptr);
	break;
    }


    BU_GETSTRUCT( dsp, dsp_specific );
    stp->st_specific = (genptr_t) dsp;

    /* this works ok, because the mapped file keeps track of the number of
     * uses.  However, the binunif interface does not.  We'll
     * have to copy the data for that one.
     */
    dsp->dsp_i = *dsp_ip;		/* struct copy */

    /* this keeps the binary internal object from being freed */
    dsp_ip->dsp_bip = (struct rt_db_internal *)NULL;	


    dsp->xsiz = dsp_ip->dsp_xcnt-1;	/* size is # cells or values-1 */
    dsp->ysiz = dsp_ip->dsp_ycnt-1;	/* size is # cells or values-1 */


    /* compute the multi-resolution bounding boxes */
    dsp_layers(dsp, &dsp_min, &dsp_max);


    /* record the distance to each of the bounding planes */
    dsp->dsp_pl_dist[XMIN] = 0.0;
    dsp->dsp_pl_dist[XMAX] = (fastf_t)dsp->xsiz;
    dsp->dsp_pl_dist[YMIN] = 0.0;
    dsp->dsp_pl_dist[YMAX] = (fastf_t)dsp->ysiz;
    dsp->dsp_pl_dist[ZMIN] = 0.0;
    dsp->dsp_pl_dist[ZMAX] = (fastf_t)dsp_max;
    dsp->dsp_pl_dist[ZMID] = (fastf_t)dsp_min;

    /* compute enlarged bounding box and spere */

d999 10
a1008 10

    BBOX_PT(-.1,		    -.1,		        -.1);
    BBOX_PT(dsp_ip->dsp_xcnt+.1, -.1,		        -.1);
    BBOX_PT(dsp_ip->dsp_xcnt+.1, dsp_ip->dsp_ycnt+.1, -1);
    BBOX_PT(-.1,		    dsp_ip->dsp_ycnt+.1, -1);
    BBOX_PT(-.1,		    -.1,		        dsp_max+.1);
    BBOX_PT(dsp_ip->dsp_xcnt+.1, -.1,		        dsp_max+.1);
    BBOX_PT(dsp_ip->dsp_xcnt+.1, dsp_ip->dsp_ycnt+.1, dsp_max+.1);
    BBOX_PT(-.1,		    dsp_ip->dsp_ycnt+.1, dsp_max+.1);

d1010 29
a1038 29

    VADD2SCALE( stp->st_center, stp->st_min, stp->st_max, 0.5 );
    VSUB2SCALE( work, stp->st_max, stp->st_min, 0.5 );

    f = work[X];
    if (work[Y] > f )  f = work[Y];
    if (work[Z] > f )  f = work[Z];
    stp->st_aradius = f;
    stp->st_bradius = MAGNITUDE(work);

    if (RT_G_DEBUG & DEBUG_HF) {
	bu_log("  model space bbox (%g %g %g) (%g %g %g)\n",
	       V3ARGS(stp->st_min),
	       V3ARGS(stp->st_max));
    }


    switch (dsp_ip->dsp_datasrc) {
    case RT_DSP_SRC_V4_FILE: 
    case RT_DSP_SRC_FILE:
	BU_CK_MAPPED_FILE(dsp->dsp_i.dsp_mp);
	break;
    case RT_DSP_SRC_OBJ:
	RT_CK_DB_INTERNAL(dsp->dsp_i.dsp_bip);
	RT_CK_BINUNIF(dsp->dsp_i.dsp_bip->idb_ptr);
	break;
    }

    return 0;
d1043 5
a1047 5
	 struct hit *in_hit,
	 struct hit *out_hit,
	 const point_t bbmin,/* The bounding box of what you are adding ... */
	 const point_t bbmax,/* ... */
	 int r, int g, int b)/* ... this is strictly for debug plot purposes */
d1049 7
a1055 26
    fastf_t *stom = &isect->dsp->dsp_i.dsp_stom[0];
    struct bound_rpp rpp;
    char fname[32];
    FILE *fp;
    static int segnum =0;

    /* plot the bounding box and the seg */
    bu_semaphore_acquire( BU_SEM_SYSCALL);
    sprintf(fname, "dsp_seg%04d.pl", segnum++);
    fp=fopen(fname, "w");
    bu_semaphore_release( BU_SEM_SYSCALL);

    if (fp != (FILE *)NULL) {
	bu_log("plotting %s\n", fname);

	MAT4X3PNT(rpp.min, stom, bbmin);
	MAT4X3PNT(rpp.max, stom, bbmax);
	plot_rpp(fp, &rpp, r/2, g/2, b/2);

	/* re-use the rpp for the points for the segment */
	MAT4X3PNT(rpp.min, stom, in_hit->hit_point);
	MAT4X3PNT(rpp.max, stom, out_hit->hit_point);

	pl_color(fp, r, g, b);
	pdv_3line(fp, rpp.min, rpp.max);

d1057 2
a1058 1
	fclose(fp);
d1060 19
a1078 1
    }
d3105 7
a3111 7
	if (dsp->dsp_i.dsp_mp) {
	    BU_CK_MAPPED_FILE(dsp->dsp_i.dsp_mp);
	    bu_close_mapped_file(dsp->dsp_i.dsp_mp);
	} else if (dsp->dsp_i.dsp_buf) {
	    bu_free(dsp->dsp_i.dsp_buf, "dsp fake data");
	}
	break;
d3113 1
a3113 1
	break;
d3115 1
a3115 2


d3452 4
a3455 4
	     struct rt_db_internal	*ip,
	     const struct bu_external	*ep,
	     register const mat_t	mat,
	     const struct db_i		*dbip)
d3457 1
a3457 1
    mat_t	tmp;
d3459 1
a3459 1

d3463 1
a3463 1
	
d3465 1
a3465 1

d3467 1
a3467 1

d3471 9
a3479 3
	/* Retrieve the data from an external file */
	if (RT_G_DEBUG & DEBUG_HF)
	    bu_log("getting data from file \"%s\"\n", p);
d3481 1
a3481 6
	if (get_file_data(dsp_ip, ip, ep, mat, dbip))
	    p = "file";
	else
	    return 0;

	break;
d3483 13
a3495 12
	/* Retrieve the data from an internal db object */
	if (RT_G_DEBUG & DEBUG_HF)
	    bu_log("getting data from object \"%s\"\n", p);

	if (get_obj_data(dsp_ip, ip, ep, mat, dbip))
	    p = "object";
	else {
	RT_CK_DB_INTERNAL(dsp_ip->dsp_bip);
	    RT_CK_BINUNIF(dsp_ip->dsp_bip->idb_ptr);
	    return 0;
	}
	break;
d3497 4
a3500 4
	bu_log("%s:%d Odd dsp data src '%c' s/b '%c' or '%c'\n", 
	       __FILE__, __LINE__, dsp_ip->dsp_datasrc,
	       RT_DSP_SRC_FILE, RT_DSP_SRC_OBJ);
	return -1;
d3502 1
a3502 1

d3504 2
a3505 2
	   bu_vls_addr(&dsp_ip->dsp_name));

d3508 3
a3510 3
		dsp_ip->dsp_xcnt*dsp_ip->dsp_ycnt,
		"dsp fake data");

d3527 11
a3537 11
    LOCAL struct rt_dsp_internal	*dsp_ip;
    union record			*rp;
    struct bu_vls			str;



    if (RT_G_DEBUG & DEBUG_HF)	
	bu_log("rt_dsp_import_v4()\n");



d3545 59
a3603 38

    BU_CK_EXTERNAL( ep );
    rp = (union record *)ep->ext_buf;

    if (RT_G_DEBUG & DEBUG_HF)
	bu_log("rt_dsp_import(%s)\n", rp->ss.ss_args);
    /*----------------------------------------------------------------------*/



    /* Check record type */
    if (rp->u_id != DBID_STRSOL )  {
	bu_log("rt_dsp_import: defective record\n");
	return(-1);
    }

    RT_CK_DB_INTERNAL( ip );
    ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
    ip->idb_type = ID_DSP;
    ip->idb_meth = &rt_functab[ID_DSP];
    ip->idb_ptr = bu_malloc( sizeof(struct rt_dsp_internal), "rt_dsp_internal");
    dsp_ip = (struct rt_dsp_internal *)ip->idb_ptr;
    dsp_ip->magic = RT_DSP_INTERNAL_MAGIC;

    /* set defaults */
    /* XXX bu_struct_parse does not set the null?
     * memset(&dsp_ip->dsp_name[0], 0, DSP_NAME_LEN); 
     */
    dsp_ip->dsp_xcnt = dsp_ip->dsp_ycnt = 0;

    dsp_ip->dsp_cuttype = DSP_CUT_DIR_ADAPT;
    dsp_ip->dsp_smooth = 1;
    MAT_IDN(dsp_ip->dsp_stom);
    MAT_IDN(dsp_ip->dsp_mtos);

    bu_vls_init( &str );
    bu_vls_strcpy( &str, rp->ss.ss_args );
    if (bu_struct_parse( &str, rt_dsp_parse, (char *)dsp_ip ) < 0) {
a3604 2
	IMPORT_FAIL("parse error");
    }
d3606 2
a3607 5

    /* Validate parameters */
    if (dsp_ip->dsp_xcnt == 0 || dsp_ip->dsp_ycnt == 0) {
	IMPORT_FAIL("zero dimension on map");
    }
d3609 1
a3609 15
    (void)dsp_get_data(dsp_ip, ip, ep, mat, dbip);

    if (RT_G_DEBUG & DEBUG_HF) {
	bu_vls_trunc(&str, 0);
	bu_vls_struct_print( &str, rt_dsp_ptab, (char *)dsp_ip);
	bu_log("  imported as(%s)\n", bu_vls_addr(&str));

    }

    if (BU_VLS_IS_INITIALIZED( &str )) bu_vls_free( &str );

    RT_CK_DB_INTERNAL(dsp_ip->dsp_bip);
    RT_CK_BINUNIF(dsp_ip->dsp_bip->idb_ptr);

    return(0);			/* OK */
d3684 85
a3768 2
    struct rt_dsp_internal	*dsp_ip;
    unsigned char		*cp;
d3770 5
a3774 87
    if (RT_G_DEBUG & DEBUG_HF)	
	bu_log("rt_dsp_import_v5()\n");



    BU_CK_EXTERNAL( ep );

    BU_ASSERT_LONG( ep->ext_nbytes, >, 141 );

    RT_CK_DB_INTERNAL( ip );

    ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
    ip->idb_type = ID_DSP;
    ip->idb_meth = &rt_functab[ID_DSP];
    dsp_ip = ip->idb_ptr = 
	bu_malloc( sizeof(struct rt_dsp_internal), "rt_dsp_internal");
    memset(dsp_ip, 0, sizeof(*dsp_ip));

    dsp_ip->magic = RT_DSP_INTERNAL_MAGIC;

    /* get x, y counts */
    cp = (unsigned char *)ep->ext_buf;

    dsp_ip->dsp_xcnt = (unsigned) bu_glong( cp );
    cp += SIZEOF_NETWORK_LONG;
    if (dsp_ip->dsp_xcnt < 2) {
	bu_log("%s:%d DSP X dimension (%d) < 2 \n", 
	       __FILE__, __LINE__, 
	       dsp_ip->dsp_xcnt);
    }


    dsp_ip->dsp_ycnt = (unsigned) bu_glong( cp );
    cp += SIZEOF_NETWORK_LONG;
    if (dsp_ip->dsp_ycnt < 2) {
	bu_log("%s:%d DSP X dimension (%d) < 2 \n",
	       __FILE__, __LINE__, 
	       dsp_ip->dsp_ycnt);
    }

    /* convert matrix */
    ntohd((unsigned char *)dsp_ip->dsp_stom, cp, 16);
    cp += SIZEOF_NETWORK_DOUBLE * 16;
    bn_mat_inv(dsp_ip->dsp_mtos, dsp_ip->dsp_stom);

    /* convert smooth flag */
    dsp_ip->dsp_smooth = bu_gshort( cp );
    cp += SIZEOF_NETWORK_SHORT;

    dsp_ip->dsp_datasrc = *cp;
    cp++;
    switch (dsp_ip->dsp_datasrc) {
    case RT_DSP_SRC_V4_FILE:
    case RT_DSP_SRC_FILE:
    case RT_DSP_SRC_OBJ:
	break;
    default:
	bu_log("%s:%d bogus DSP cut type '%c' (%d)\n",
	       __FILE__, __LINE__, 
	       dsp_ip->dsp_datasrc, dsp_ip->dsp_datasrc);
	break;
    }


    dsp_ip->dsp_cuttype = *cp;
    cp++;
    switch (dsp_ip->dsp_cuttype) {
    case DSP_CUT_DIR_ADAPT:
    case DSP_CUT_DIR_llUR:
    case DSP_CUT_DIR_ULlr:
	break;
    default:
	bu_log("%s:%d bogus DSP data source '%c' (%d)\n", 
	       __FILE__, __LINE__, 
	       dsp_ip->dsp_cuttype, dsp_ip->dsp_cuttype);
	break;
    }


    /* convert name of data location */
    bu_vls_init( &dsp_ip->dsp_name );
    bu_vls_strncpy( &dsp_ip->dsp_name, (char *)cp,
		    ep->ext_nbytes - (cp - (unsigned char *)ep->ext_buf) );

    (void)dsp_get_data(dsp_ip, ip, ep, mat, dbip);

    return 0; /* OK */
d3791 76
a3866 61
    struct rt_dsp_internal	*dsp_ip;
    unsigned long		name_len;
    unsigned char		*cp;

    RT_CK_DB_INTERNAL(ip);
    if (ip->idb_type != ID_DSP )  return(-1);
    dsp_ip = (struct rt_dsp_internal *)ip->idb_ptr;
    RT_DSP_CK_MAGIC(dsp_ip);

    if (RT_G_DEBUG & DEBUG_HF)	
	bu_log("rt_dsp_export_v5()\n");
    


    name_len = bu_vls_strlen(&dsp_ip->dsp_name) + 1;

    BU_CK_EXTERNAL(ep);

    ep->ext_nbytes =
	    SIZEOF_NETWORK_LONG * 2 +
	    SIZEOF_NETWORK_DOUBLE * ELEMENTS_PER_MAT +
	    SIZEOF_NETWORK_SHORT +
	    2 + name_len;

    ep->ext_buf = bu_malloc( ep->ext_nbytes, "dsp external");
    cp = (unsigned char *)ep->ext_buf;

    memset(ep->ext_buf, 0, ep->ext_nbytes);


    /* Now we fill the buffer with the data, making sure everything is
     * converted to Big-Endian IEEE
     */

    bu_plong( cp, (unsigned long)dsp_ip->dsp_xcnt );
    cp += SIZEOF_NETWORK_LONG;

    bu_plong( cp, (unsigned long)dsp_ip->dsp_ycnt );
    cp += SIZEOF_NETWORK_LONG;

    /* Since libwdb users may want to operate in units other
     * than mm, we offer the opportunity to scale the solid
     * (to get it into mm) on the way out.
     */
    dsp_ip->dsp_stom[15] *= local2mm;

    htond(cp, (unsigned char *)dsp_ip->dsp_stom, 16);
    cp += SIZEOF_NETWORK_DOUBLE * 16;

    bu_pshort( cp, (int)dsp_ip->dsp_smooth );
    cp += SIZEOF_NETWORK_SHORT;

    *cp = dsp_ip->dsp_datasrc;
    cp++;

    *cp = dsp_ip->dsp_cuttype;
    cp++;

    strcpy((char *)cp, bu_vls_addr(&dsp_ip->dsp_name));

    return 0; /* OK */
d3958 3
a3960 3
	    const char 			*sp_name,
	    genptr_t			base,		    
	    char			*p)
d3962 7
a3968 7
    struct rt_dsp_internal *dsp_ip = (struct rt_dsp_internal *)base;

    if (!strcmp(sp_name, "src")) {
	switch (dsp_ip->dsp_datasrc) {
	case RT_DSP_SRC_V4_FILE:
	case RT_DSP_SRC_FILE:
	case RT_DSP_SRC_OBJ:
d3970 1
a3970 1
	default:
d3972 3
a3974 3
		   RT_DSP_SRC_V4_FILE,
		   RT_DSP_SRC_FILE,
		   RT_DSP_SRC_OBJ);
d3976 4
a3979 4
	}

    } else if (!strcmp(sp_name, "w")) {
	if (dsp_ip->dsp_xcnt == 0)
d3981 2
a3982 2
    } else if (!strcmp(sp_name, "n")) {
	if (dsp_ip->dsp_ycnt == 0)
d3984 5
a3988 5
    } else if (!strcmp(sp_name, "cut")) {
	switch (dsp_ip->dsp_cuttype) {
	case DSP_CUT_DIR_ADAPT:
	case DSP_CUT_DIR_llUR:
	case DSP_CUT_DIR_ULlr:
d3990 1
a3990 1
	default:
d3992 4
a3995 4
		   dsp_ip->dsp_cuttype,
		   DSP_CUT_DIR_ADAPT,
		   DSP_CUT_DIR_llUR,
		   DSP_CUT_DIR_ULlr);
d3997 1
a3998 1
    }
d4058 2
a4059 2
		sp = rt_dsp_ptab;
		break;
d4062 2
a4063 2
		sp = fake_dsp_printab;
		break;
d4076 8
a4083 8
	    switch (dsp_ip->dsp_datasrc) {
	    case RT_DSP_SRC_V4_FILE:
		sp = rt_dsp_ptab;
	    case RT_DSP_SRC_FILE:
	    case RT_DSP_SRC_OBJ:
		sp = fake_dsp_printab;
		break;
	    }
d4132 1
a4132 1
	    break;
@


1.99
log
@When the DSP was using a database object for data, the data was being released
when rt called dsp_ifree after calling prep().  The dsp_prep() func was
copying the pointer for use in the dsp_specific structure.  The data was going
"poof".  Now the dsp_prep() func copies the pointer, but clears it in the
version that was passed in.  Now the data doesn't go poof.
@
text
@d1 1
d43 1
a43 1
static const char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.98 2001/11/19 19:33:26 butler Exp $ (BRL)";
d685 1
a685 1
    bu_log("layer %d   %dx%d\n", 0, xs, ys);
d1094 1
d1124 1
d1127 5
d1188 4
a1191 1
    if (NEAR_ZERO(delta, isect->tol->dist)) {
d1196 1
a1196 1
    if (delta < 0.0) {
d1210 1
d1212 7
d1220 2
a1221 2
    seg->seg_in.hit_magic = RT_HIT_MAGIC;
    seg->seg_in.hit_vpriv[Z] = 0.0; /* flag as in-hit */
d1223 2
d1226 2
a1227 2
    seg->seg_out = *out_hit; /* struct copy */
    seg->seg_out.hit_magic = RT_HIT_MAGIC;
a1229 1

d2175 2
d2224 4
d2273 1
a2273 1
	    dlog("stepping Y to %d because %g >= %g\n", cX, tX, tY);
d2278 6
a2283 1
    } while ( curr_dist < out_dist );
d2315 2
a2316 1
	bu_log("null ptr pixel %d %d\n", isect->ap->a_x,  isect->ap->a_y); 
d2528 1
a2528 1
	    RT_CK_BINUNIF(dsp->dsp_i.dsp_bip->idb_ptr);
d2587 1
a2587 1
	    bu_log("solid in:%6g out:%6g\t",
d2592 1
d2594 5
a2598 2
	MAT4X3VEC(v, dsp->dsp_i.dsp_stom, dir)
	    segp->seg_in.hit_dist = MAGNITUDE(v);
d2602 2
a2603 2
	MAT4X3VEC(v, dsp->dsp_i.dsp_stom, dir)
	    segp->seg_out.hit_dist = MAGNITUDE(v);
d2615 2
d2624 1
a2624 1

d2626 1
a2626 1
	    bu_log("model in:%6g out:%6g\n",
a2698 16
    if (x == 0) {	VSET(tmp, x, y, DSP(&dsp->dsp_i, x, y) );	}
    else {		VSET(tmp, x-1, y, DSP(&dsp->dsp_i, x-1, y) );	}
    MAT4X3PNT(A, dsp->dsp_i.dsp_stom, tmp);

    if (x >= XSIZ(dsp)) {	VSET(tmp, x, y,  DSP(&dsp->dsp_i, x, y) ); } 
    else {			VSET(tmp, x+1, y,  DSP(&dsp->dsp_i, x+1, y) );	}
    MAT4X3PNT(C, dsp->dsp_i.dsp_stom, tmp);


    if (y == 0) {	VSET(tmp, x, y, DSP(&dsp->dsp_i, x, y) ); }
    else {		VSET(tmp, x, y-1, DSP(&dsp->dsp_i, x, y-1) );	}
    MAT4X3PNT(D, dsp->dsp_i.dsp_stom, tmp);

    if (y >= YSIZ(dsp)) {	VSET(tmp, x, y, DSP(&dsp->dsp_i, x, y) ); }
    else {			VSET(tmp, x, y+1, DSP(&dsp->dsp_i, x, y+1) );	}
    MAT4X3PNT(E, dsp->dsp_i.dsp_stom, tmp);
d2701 19
a2722 1
    }
d2724 35
a2758 2
    VSUB2(Vac, C, A);
    VSUB2(Vde, E, D);
d2760 1
a2760 1
    VCROSS(N, Vac, Vde);
a2761 1
    VUNITIZE(N);
a2775 1
    char buf[32];
d2795 2
d2812 4
d2819 2
a2820 1
	 * so there's no interpolation to do
d2823 5
d2844 2
a2845 11
	bu_semaphore_acquire( BU_SEM_SYSCALL);
	sprintf(buf, "dsp_gourand%02d.pl", plot_file_num++);
	fd=fopen(buf, "w");
	bu_semaphore_release( BU_SEM_SYSCALL);

	if (fd == (FILE *)NULL) {
	    bu_log("Couldn't open plot file \"%s\"\n", buf);
	    bu_bomb("");
	} else {
	    bu_log("plotting normals in %s\n", buf);
	}
@


1.98
log
@Modifications to make DSP assume data is in network format when read from an
internal binary object.  Previously this was only the case when using an
external file.
@
text
@d42 1
a42 1
static const char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.97 2001/11/14 23:47:06 butler Exp $ (BRL)";
d958 2
a959 1
	RT_CK_BINUNIF(dsp_ip->dsp_bip);
d966 5
d973 4
d1031 1
a1031 1
	BU_CK_MAPPED_FILE(dsp_ip->dsp_mp);
d1034 2
a1035 1
	RT_CK_BINUNIF(dsp_ip->dsp_bip);
d2495 2
d3417 3
a3419 1
	else
d3421 1
a3421 1

d3530 4
@


1.97
log
@Forced Null termination of file/object names
Added validity checks to rt_dsp_import5()
Added "0" value fallthrough (again)
Added support for reading in DSP when data does not exist
	(it gets replaced with 0 values).
No longer adds 0 length segments to the segment list when accumulating segs
@
text
@d42 1
a42 1
static const char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.96 2001/11/02 05:02:42 butler Exp $ (BRL)";
d949 7
d958 1
a966 4
    bu_semaphore_acquire( RT_SEM_MODEL);
    ++dsp_ip->dsp_mp->uses;
    bu_semaphore_release( RT_SEM_MODEL);

d1024 1
d1173 1
a1174 1

d3311 1
d3331 19
d3361 4
d3373 2
a3374 1
    mat_t				tmp;
d3382 2
d3387 1
d3389 7
a3395 2
	    bu_log("getting data from file\n");
	return get_file_data(dsp_ip, ip, ep, mat, dbip);
d3398 1
d3400 7
a3406 2
	    bu_log("getting data from object\n");
	return get_obj_data(dsp_ip, ip, ep, mat, dbip);
d3414 10
d3445 3
d3505 1
a3505 3
    if (dsp_get_data(dsp_ip, ip, ep, mat, dbip)) {
	IMPORT_FAIL("DSP data");
    }
d3560 1
a3560 1
	bu_log("rt_dsp_export(%s)\n", bu_vls_addr(&str) );
d3582 1
a3582 1
rt_dsp_import5( ip, ep, mat, dbip )
d3587 2
d3593 3
d3677 1
a3677 12
    if (dsp_get_data(dsp_ip, ip, ep, mat, dbip)) {
	/* We didn't get the file.  Instead of returning a full error
	 * we invent some data.  This allows the user to edit a DSP which
	 * is missing the data
	 */

	dsp_ip->dsp_mp = (struct bu_mapped_file *)NULL;
	dsp_ip->dsp_buf = bu_calloc(sizeof(short),
				    dsp_ip->dsp_xcnt*dsp_ip->dsp_ycnt,
				    "dsp fake data");

    }
d3688 1
a3688 1
rt_dsp_export5( ep, ip, local2mm, dbip )
d3693 2
d3705 5
d4030 1
@


1.96
log
@Added error checking to values that come in via "adjust" in V5 databases
@
text
@d42 1
a42 1
static const char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.95 2001/11/02 01:02:58 butler Exp $ (BRL)";
d1089 1
d1108 1
a1108 1
	    seg->seg_out.hit_vpriv[Z] = 1; /* flag as out-hit */
d1130 1
a1130 1
	    seg->seg_out.hit_vpriv[Z] = 1; /* flag as out-hit */
d1151 30
d1186 1
a1186 1
    seg->seg_in.hit_vpriv[Z] = 0; /* flag as in-hit */
d1191 1
a1191 1
    seg->seg_out.hit_vpriv[Z] = 1; /* flag as out-hit */
d1219 2
a1220 3
    if (seg->seg_in.hit_dist > seg->seg_out.hit_dist) {
	bu_log("DSP:  Adding inside-out seg\n");
    }
d1776 1
d1779 1
d2468 1
d2552 7
a2558 5
	if (segp->seg_in.hit_dist > segp->seg_out.hit_dist) {
	    bu_log("Pixel %d %d seg inside out %g %g\n",
		   ap->a_x, ap->a_y,
		   segp->seg_in.hit_dist,
		   segp->seg_out.hit_dist);
d3015 6
a3020 2
	BU_CK_MAPPED_FILE(dsp->dsp_i.dsp_mp);
	bu_close_mapped_file(dsp->dsp_i.dsp_mp);
d3264 2
a3265 1
	bu_log("DSP buffer wrong size");
d3558 6
d3567 5
d3584 12
d3599 12
d3614 2
a3615 1
    bu_vls_strcpy( &dsp_ip->dsp_name, (char *)cp );
d3618 10
a3627 1
	IMPORT_FAIL("unable to read DSP data");
d3698 1
a3698 1
    strncpy((char *)cp, bu_vls_addr(&dsp_ip->dsp_name), name_len);
@


1.95
log
@changes to make DSP get/put work
@
text
@d42 1
a42 1
static const char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.94 2001/10/31 23:01:00 butler Exp $ (BRL)";
d255 1
a255 1
    {"%i",  1, "sm", DSP_O(dsp_smooth), BU_STRUCTPARSE_FUNC_NULL },
d258 1
a258 1
    {"%f", 16, "stom", DSP_AO(dsp_stom), hook_mtos_from_stom },
d264 1
a264 1
    {"%i",  1, "sm", DSP_O(dsp_smooth), BU_STRUCTPARSE_FUNC_NULL },
d267 1
a267 1
    {"%f", 16, "stom", DSP_AO(dsp_stom), BU_STRUCTPARSE_FUNC_NULL },
d527 1
a527 1
    bu_vls_printf( vls, "Displacement Map\n  file='%s' w=%d n=%d sm=%d ",
d600 3
a602 1
	bu_vls_printf( vls, "cut'%c'/%d",dsp_ip->dsp_cuttype,dsp_ip->dsp_cuttype ); break;
d3705 47
d3753 1
a3753 1
    {"%c",  1, "src", DSP_O(dsp_datasrc), BU_STRUCTPARSE_FUNC_NULL },
d3755 5
a3759 5
    {"%d",  1, "w",  DSP_O(dsp_xcnt),	 BU_STRUCTPARSE_FUNC_NULL },
    {"%d",  1, "n",  DSP_O(dsp_ycnt),	 BU_STRUCTPARSE_FUNC_NULL },
    {"%d",  1, "sm", DSP_O(dsp_smooth), BU_STRUCTPARSE_FUNC_NULL },
    {"%c",  1, "cut", DSP_O(dsp_cuttype), BU_STRUCTPARSE_FUNC_NULL },
    {"%f", 16, "stom", DSP_AO(dsp_stom), BU_STRUCTPARSE_FUNC_NULL },
d3814 1
d3818 1
a3818 1
		bu_vls_struct_item(&str,sp,(char *)intern->idb_ptr,' ');
d3833 1
d3835 1
a3835 1
					  (char *)intern->idb_ptr, ' ') < 0 ) {
d3872 2
a3873 1

a3888 1

@


1.94
log
@Changes to make db get work on DSP
@
text
@d42 1
a42 1
static const char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.93 2001/10/26 20:48:33 bparker Exp $ (BRL)";
d255 1
a255 1
    {"%d",  1, "sm", DSP_O(dsp_smooth), BU_STRUCTPARSE_FUNC_NULL },
d264 1
a264 1
    {"%d",  1, "sm", DSP_O(dsp_smooth), BU_STRUCTPARSE_FUNC_NULL },
d525 1
a525 2

    bu_vls_init( vls );
d558 2
a559 3
dsp_print_v5(vls, dsp_ip)
     struct bu_vls *vls;
     const struct rt_dsp_internal *dsp_ip;
d562 3
a567 1
    bu_vls_init( vls );
d572 3
d599 2
d639 6
d647 1
d651 1
d3627 6
a3632 5
rt_dsp_describe( str, ip, verbose, mm2local )
     struct bu_vls		*str;
     const struct rt_db_internal *ip;
     int			verbose;
     double			mm2local;
d3638 3
d3647 9
a3655 1
    dsp_print_v5(&vls, dsp_ip);
@


1.93
log
@*- fixed off by one error
@
text
@d42 1
a42 1
static const char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.92 2001/10/25 02:23:22 butler Exp $ (BRL)";
d271 5
d3375 1
d3677 136
@


1.92
log
@replaced lost pointer increment.
@
text
@d42 1
a42 1
static const char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.91 2001/10/15 19:58:04 morrison Exp $ (BRL)";
d3551 7
a3557 1
    ep->ext_nbytes = 139 + name_len;
@


1.91
log
@Added "Darwin on Power Macintosh" support (finally)
@
text
@d42 1
a42 1
static const char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.90 2001/10/04 14:19:57 butler Exp $ (BRL)";
d3514 1
@


1.90
log
@Added import/export handling of cuttype
@
text
@d42 1
a42 1
static const char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.89 2001/10/02 19:24:28 jra Exp $ (BRL)";
d2564 1
a2564 1
compute_normal_at_gridpoint(N, dsp, x, y, fd, bool)
d2569 1
a2569 1
     int bool;
d2605 1
a2605 1
    if (fd && bool) {
@


1.89
log
@Routines were not setting idb_major_type in the internal structure
@
text
@d42 1
a42 1
static const char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.88 2001/09/09 00:42:09 butler Exp $ (BRL)";
d3513 2
d3580 3
@


1.88
log
@Fixed a border condition bug, misc performance tweaks
@
text
@d42 1
a42 1
static const char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.87 2001/09/08 03:31:26 butler Exp $ (BRL)";
d3357 1
d3483 1
@


1.87
log
@Deleted some old variables that are not used anymore
@
text
@d42 1
a42 1
static const char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.86 2001/09/07 22:35:42 butler Exp $ (BRL)";
d61 1
d67 2
a68 2
	unsigned short dsp_min[3];
	unsigned short dsp_max[3];
d85 2
a86 1
    int			dspb_ch_dim[2];	/* dimensions of children[] */
d97 2
a98 3
    /*	int	cell_size;	XXX Do we actually use this? */
	int	dim[2];		/* the dimensions of the array at element p */
	struct dsp_bb *p;	/* array of dsp_bb's for this level */
a122 11
/* access to the array */
#define DSP(_p,_x,_y) ( \
	((unsigned short *)(((struct rt_dsp_internal *)_p)->dsp_buf))[ \
		(_y) * ((struct rt_dsp_internal *)_p)->dsp_xcnt + (_x) ] )

#define XCNT(_p) (((struct rt_dsp_internal *)_p)->dsp_xcnt)
#define YCNT(_p) (((struct rt_dsp_internal *)_p)->dsp_ycnt)

#define XSIZ(_p) (_p->dsp_i.dsp_xcnt - 1)

#define YSIZ(_p) (_p->dsp_i.dsp_ycnt - 1)
d131 7
a137 7
	struct rt_dsp_internal dsp_i;	/* MUST BE FIRST */
	double		dsp_pl_dist[BBOX_PLANES];
	int		xsiz;
	int		ysiz;
	int		layers;
	struct dsp_bb_layer *layer;
	struct dsp_bb *bb_array;
d140 35
d176 4
a179 4
	double	in_dist;
	double	out_dist;
	int	in_surf;
	int	out_surf;
d208 2
a209 2
	{-1.0, 0.0, 0.0},
	{ 1.0, 0.0, 0.0},
d211 2
a212 2
	{0.0, -1.0, 0.0},
	{0.0,  1.0, 0.0},
d214 3
a216 3
	{0.0, 0.0, -1.0},
	{0.0, 0.0,  1.0},
	{0.0, 0.0,  1.0},
d230 1
a230 1
	struct rt_dsp_internal *dsp_ip = (struct rt_dsp_internal *)base;
d232 1
a232 1
	bn_mat_inv(dsp_ip->dsp_mtos, dsp_ip->dsp_stom);
d236 4
a239 4
		    const struct bu_structparse	*ip,
		    const char 			*sp_name,
		    genptr_t			base,		    
		    char			*p)
d241 1
a241 1
	struct rt_dsp_internal *dsp_ip = (struct rt_dsp_internal *)base;
d243 2
a244 2
	dsp_ip->dsp_datasrc = RT_DSP_SRC_V4_FILE;
	dsp_ip->dsp_bip = (struct rt_db_internal *)NULL;
d254 6
a259 6
	{"%S",	1, "file", DSP_O(dsp_name), hook_file },
	{"%d",  1, "sm", DSP_O(dsp_smooth), BU_STRUCTPARSE_FUNC_NULL },
	{"%d",	1, "w", DSP_O(dsp_xcnt), BU_STRUCTPARSE_FUNC_NULL },
	{"%d",	1, "n", DSP_O(dsp_ycnt), BU_STRUCTPARSE_FUNC_NULL },
	{"%f", 16, "stom", DSP_AO(dsp_stom), hook_mtos_from_stom },
	{"",	0, (char *)0, 0,	BU_STRUCTPARSE_FUNC_NULL }
d263 6
a268 6
	{"%S",	1, "file", DSP_O(dsp_name), BU_STRUCTPARSE_FUNC_NULL },
	{"%d",  1, "sm", DSP_O(dsp_smooth), BU_STRUCTPARSE_FUNC_NULL },
	{"%d",	1, "w", DSP_O(dsp_xcnt), BU_STRUCTPARSE_FUNC_NULL },
	{"%d",	1, "n", DSP_O(dsp_ycnt), BU_STRUCTPARSE_FUNC_NULL },
	{"%f", 16, "stom", DSP_AO(dsp_stom), BU_STRUCTPARSE_FUNC_NULL },
	{"",	0, (char *)0, 0,	BU_STRUCTPARSE_FUNC_NULL }
d272 1
a272 3
#if 0
static int plot_em=1;
#endif
d281 1
a281 1
	pl_color(fp, r, g, b);
d283 11
a293 11
	pd_3move(fp, rpp->min[X], rpp->min[Y], rpp->min[Z]);
	pd_3cont(fp, rpp->max[X], rpp->min[Y], rpp->min[Z]);
	pd_3cont(fp, rpp->max[X], rpp->max[Y], rpp->min[Z]);
	pd_3cont(fp, rpp->min[X], rpp->max[Y], rpp->min[Z]);
	pd_3cont(fp, rpp->min[X], rpp->min[Y], rpp->min[Z]);

	pd_3cont(fp, rpp->min[X], rpp->min[Y], rpp->max[Z]);
	pd_3cont(fp, rpp->max[X], rpp->min[Y], rpp->max[Z]);
	pd_3cont(fp, rpp->max[X], rpp->max[Y], rpp->max[Z]);
	pd_3cont(fp, rpp->min[X], rpp->max[Y], rpp->max[Z]);
	pd_3cont(fp, rpp->min[X], rpp->min[Y], rpp->max[Z]);
d304 1
a304 1
	    int r, int g, int b)
d306 3
a308 3
	fastf_t *stom = &dsp->dsp_i.dsp_stom[0];
	struct bound_rpp rpp;
	point_t pt;
d318 3
a320 2
    bu_log("  dsp_bb (%g %g %g)  (%g %g %g)\n",
	   V3ARGS(rpp.min), V3ARGS(rpp.max) );
d343 1
a343 1
    bu_log("plotting %s ", buf);
d346 1
a346 1
    plot_dsp_bb(fp, &bb, dsp, r, g, b);
d351 1
a351 1

d361 38
a398 28
	FILE *fp;
	int l, x, y, n, tot;
	char buf[32];
	static int colors[7][3] = {
		{255, 0, 0},
		{0, 255, 0},
		{0, 0, 255},
		{255, 255, 0},
		{255, 0, 255},
		{0, 255, 255},
		{255, 255, 255}
	};
	int r, g, b, c;
	struct dsp_bb *d_bb;

	for (l=0 ; l < dsp_sp->layers ; l++) {
		sprintf(buf, "Dsp_layer%d.pl", l);
		fp=fopen(buf, "w");
		if ( fp == (FILE *)NULL ) {
			bu_log("%s:%d error opening %s\n", __FILE__, __LINE__,
			       buf);
			return;
		}
		
		c = l % 6;
		r = colors[c][0];
		g = colors[c][1];
		b = colors[c][2];
d402 6
a407 20
			bu_log("plot layer %d dim:%d,%d\n", l, 
			       dsp_sp->layer[l].dim[X],
			       dsp_sp->layer[l].dim[Y]);
#endif
		tot = dsp_sp->layer[l].dim[Y] *  dsp_sp->layer[l].dim[X];
		for (y=1 ; y < dsp_sp->layer[l].dim[Y] ; y+= 2 ) {
			for (x=1 ; x < dsp_sp->layer[l].dim[X] ; x+= 2 ) {
				n = y * dsp_sp->layer[l].dim[X] + x;
				d_bb = &dsp_sp->layer[l].p[n];
				plot_dsp_bb(fp, d_bb, dsp_sp,
					    r, g, b);

#if 0
				if (RT_G_DEBUG & DEBUG_HF)
					bu_log("\t%d,%d ch_dim:%d,%d  min:(%d %d %d)  max:(%d %d %d)\n",
					       x, y,
					       d_bb->dspb_ch_dim[X],
					       d_bb->dspb_ch_dim[Y],
					       V3ARGS(d_bb->dspb_rpp.dsp_min),
					       V3ARGS(d_bb->dspb_rpp.dsp_max));
d409 1
a409 2
			}
		}
d411 2
d449 1
d455 5
a459 1
    if ( (fp=fopen(buf, "w")) == (FILE *)NULL) {
d466 1
a466 1
    plot_dsp_bb(fp, dsp_bb, isect->dsp, 128, 128, 128);
d514 2
a515 2
struct bu_vls *vls;
const struct rt_dsp_internal *dsp_ip;
d517 3
a519 3
	point_t pt, v;
	RT_DSP_CK_MAGIC(dsp_ip);
	BU_CK_VLS(&dsp_ip->dsp_name);
d521 1
a521 1
	bu_vls_init( vls );
d523 5
a527 5
	bu_vls_printf( vls, "Displacement Map\n  file='%s' w=%d n=%d sm=%d ",
		       bu_vls_addr(&dsp_ip->dsp_name),
		       dsp_ip->dsp_xcnt,
		       dsp_ip->dsp_ycnt,
		       dsp_ip->dsp_smooth);
d529 1
a529 1
	VSETALL(pt, 0.0);
d531 1
a531 1
	MAT4X3PNT(v, dsp_ip->dsp_stom, pt);
d533 1
a533 1
	bu_vls_printf( vls, " (origin at %g %g %g)mm\n", V3ARGS(v));
d535 3
a537 3
	bu_vls_printf( vls, "  stom=\n");
	bu_vls_printf( vls, "  %8.3f %8.3f %8.3f %8.3f\n",
		V4ARGS(dsp_ip->dsp_stom) );
d539 2
a540 2
	bu_vls_printf( vls, "  %8.3f %8.3f %8.3f %8.3f\n",
		V4ARGS( &dsp_ip->dsp_stom[4]) );
d542 2
a543 2
	bu_vls_printf( vls, "  %8.3f %8.3f %8.3f %8.3f\n",
		V4ARGS( &dsp_ip->dsp_stom[8]) );
d545 2
a546 2
	bu_vls_printf( vls, "  %8.3f %8.3f %8.3f %8.3f\n",
		V4ARGS( &dsp_ip->dsp_stom[12]) );
d555 2
a556 2
struct bu_vls *vls;
const struct rt_dsp_internal *dsp_ip;
d558 3
a560 3
	point_t pt, v;
	RT_DSP_CK_MAGIC(dsp_ip);
	BU_CK_VLS(&dsp_ip->dsp_name);
d562 1
a562 1
	bu_vls_init( vls );
d564 1
a564 1
	bu_vls_printf( vls, "Displacement Map\n" );
d566 11
a576 11
	switch (dsp_ip->dsp_datasrc) {
	case RT_DSP_SRC_FILE:
		bu_vls_printf( vls, "  file");
		break;
	case RT_DSP_SRC_OBJ:
		bu_vls_printf( vls, "  obj");
		break;
	default:
		bu_vls_printf( vls, "unk src type'%c'", dsp_ip->dsp_datasrc);
		break;
	}
d578 14
a591 14
	bu_vls_printf( vls, "='%s'\n  w=%d n=%d sm=%d ",
		       bu_vls_addr(&dsp_ip->dsp_name),
		       dsp_ip->dsp_xcnt,
		       dsp_ip->dsp_ycnt,
		       dsp_ip->dsp_smooth);

	switch (dsp_ip->dsp_cuttype) {
	case DSP_CUT_DIR_ADAPT:
	    bu_vls_printf( vls, "cut=ad" ); break;
	case DSP_CUT_DIR_llUR:
	    bu_vls_printf( vls, "cut=lR" ); break;
	case DSP_CUT_DIR_ULlr:
	    bu_vls_printf( vls, "cut=Lr" ); break;
	}
d594 1
a594 1
	VSETALL(pt, 0.0);
d596 1
a596 1
	MAT4X3PNT(v, dsp_ip->dsp_stom, pt);
d598 1
a598 1
	bu_vls_printf( vls, " (origin at %g %g %g)mm\n", V3ARGS(v));
d600 3
a602 3
	bu_vls_printf( vls, "  stom=\n");
	bu_vls_printf( vls, "  %8.3f %8.3f %8.3f %8.3f\n",
		V4ARGS(dsp_ip->dsp_stom) );
d604 2
a605 2
	bu_vls_printf( vls, "  %8.3f %8.3f %8.3f %8.3f\n",
		V4ARGS( &dsp_ip->dsp_stom[4]) );
d607 2
a608 2
	bu_vls_printf( vls, "  %8.3f %8.3f %8.3f %8.3f\n",
		V4ARGS( &dsp_ip->dsp_stom[8]) );
d610 2
a611 2
	bu_vls_printf( vls, "  %8.3f %8.3f %8.3f %8.3f\n",
		V4ARGS( &dsp_ip->dsp_stom[12]) );
d619 1
a619 1
register const struct soltab *stp;
d621 3
a623 3
	register const struct dsp_specific *dsp =
		(struct dsp_specific *)stp->st_specific;
	struct bu_vls vls;
d626 2
a627 2
	RT_DSP_CK_MAGIC(dsp);
	BU_CK_VLS(&dsp->dsp_i.dsp_name);
d629 8
a636 8
	switch (stp->st_rtip->rti_dbip->dbi_version) {
	case 4: 
		dsp_print_v4(&vls, &(dsp->dsp_i) );
		break;
	case 5:
		dsp_print_v5(&vls, &(dsp->dsp_i) );
		break;
	}
d638 1
a638 1
	bu_log("%s", bu_vls_addr( &vls));
d640 1
a640 1
	if (BU_VLS_IS_INITIALIZED( &vls )) bu_vls_free( &vls );
d652 19
a670 17
	int idx, i, j, k, curr_layer, x, y, xs, ys, xv, yv, tot;
	unsigned short dsp_min, dsp_max, cell_min, cell_max;
	unsigned short elev;
	struct dsp_bb *dsp_bb;
	struct dsp_rpp *t;
	struct dsp_bb_layer *curr, *prev;

	/* First we compute the total number of struct dsp_bb's we will need */
	xs = dsp->xsiz;
	ys = dsp->ysiz;
	tot = xs * ys;
	dsp->layers = 1;
	while ( xs > 1 || ys > 1 ) {
		xv = xs / DIM_BB_CHILDREN;
		yv = ys / DIM_BB_CHILDREN;
		if (xs % DIM_BB_CHILDREN) xv++;
		if (ys % DIM_BB_CHILDREN) yv++;
d672 5
a676 2
		if (RT_G_DEBUG & DEBUG_HF)
			bu_log("layer %d   %dx%d\n", dsp->layers, xv, yv);
d678 2
a679 1
		tot += xv * yv;
d681 4
a684 2
		if (xv > 0) xs = xv;
		else xs = 1;
a685 4
		if (yv > 0) ys = yv;
		else ys = 1;
		dsp->layers++;
	}
d687 4
d692 4
a695 2
	if (RT_G_DEBUG & DEBUG_HF)
		bu_log("%d layers total\n", dsp->layers);
d697 6
d704 2
a705 14
	/* allocate the struct dsp_bb's we will need */
	dsp->layer = bu_malloc(dsp->layers * sizeof(struct dsp_bb_layer),
			       "dsp_bb_layers array");
	dsp->bb_array = bu_malloc(tot * sizeof(struct dsp_bb), "dsp_bb array");

	/* now we fill in the "lowest" layer of struct dsp_bb's from the
	 * raw data
	 */
	dsp->layer[0].dim[X] = dsp->xsiz;
	dsp->layer[0].dim[Y] = dsp->ysiz;
	dsp->layer[0].p = dsp->bb_array;

	xs = dsp->xsiz;
	ys = dsp->ysiz;
d707 2
a708 2
	dsp_min = 0xffff;
	dsp_max = 0;
d710 1
a710 1
	for (y=0 ; y < YSIZ(dsp) ; y++) {
d712 2
a713 2
		cell_min = 0xffff;
		cell_max = 0;
d715 1
a715 1
		for (x=0 ; x < XSIZ(dsp) ; x++) {
d718 2
a719 2
			if (RT_G_DEBUG & DEBUG_HF)
				bu_log("filling %d,%d\n", x, y);
d721 2
a722 2
			elev = DSP(dsp, x, y);
			cell_min = cell_max = elev;
d724 32
a755 30
			elev = DSP(dsp, x+1, y);
			V_MIN(cell_min, elev);
			V_MAX(cell_max, elev);

			elev = DSP(dsp, x, y+1);
			V_MIN(cell_min, elev);
			V_MAX(cell_max, elev);

			elev = DSP(dsp, x+1, y+1);
			V_MIN(cell_min, elev);
			V_MAX(cell_max, elev);

			/* factor the cell min/max into the overall min/max */
			V_MIN(dsp_min, cell_min);
			V_MAX(dsp_max, cell_max);

			/* fill in the dsp_rpp cell min/max */
			i = y*XSIZ(dsp) + x;
			dsp_bb = &dsp->layer[0].p[i];
			VSET(dsp_bb->dspb_rpp.dsp_min, x, y, cell_min);
			VSET(dsp_bb->dspb_rpp.dsp_max, x+1, y+1, cell_max);

			/* There are no "children" of a layer 0 element */
			dsp_bb->dspb_ch_dim[X] = 0;
			dsp_bb->dspb_ch_dim[Y] = 0;
			for (k=0 ; k < NUM_BB_CHILDREN ; k++ ) {
				dsp_bb->dspb_children[k] = 
					(struct dsp_bb *)NULL;
			}
			dsp_bb->magic = MAGIC_dsp_bb;
d757 3
a759 3
			dlog("cell %d,%d min: %d,%d,%d  max: %d,%d,%d\n",
			     x, y, V3ARGS(dsp_bb->dspb_rpp.dsp_min),
			     V3ARGS(dsp_bb->dspb_rpp.dsp_max) );
d762 3
a764 4
			/* XXX should we compute the triangle orientation and
			 * save it here too?
			 */
		}
d766 1
d768 2
a769 2
	*d_min = dsp_min;
	*d_max = dsp_max;
d772 2
a773 2
	if (RT_G_DEBUG & DEBUG_HF)
			bu_log("filled first layer\n");
d775 1
d777 19
a795 18
	/* now we compute successive layers from the initial layer */
	for (curr_layer = 1 ; curr_layer < dsp->layers ; curr_layer++ ) {
		/* compute the number of cells in each direction for this layer */
		xs = dsp->layer[curr_layer-1].dim[X];
		if (xs % DIM_BB_CHILDREN)  
			dsp->layer[curr_layer].dim[X] =
				xs / DIM_BB_CHILDREN + 1;
		else			  
			dsp->layer[curr_layer].dim[X] =
				xs / DIM_BB_CHILDREN;

		ys = dsp->layer[curr_layer-1].dim[Y];
		if (ys % DIM_BB_CHILDREN) 
			dsp->layer[curr_layer].dim[Y] = 
				ys / DIM_BB_CHILDREN + 1;
		else			  
			dsp->layer[curr_layer].dim[Y] = 
				ys / DIM_BB_CHILDREN;
d797 8
a804 4
		/* set the start of the array for this layer */
		dsp->layer[curr_layer].p = &dsp->layer[curr_layer-1].p[
				    dsp->layer[curr_layer-1].dim[X] *
				    dsp->layer[curr_layer-1].dim[Y] ];
d806 2
a807 2
		curr = &dsp->layer[curr_layer];
		prev = &dsp->layer[curr_layer-1];
d809 22
a830 2
		if (RT_G_DEBUG & DEBUG_HF)
			bu_log("layer %d\n", curr_layer);
a831 19
		/* walk the grid and fill in the values for this layer */
		for (y=0 ; y < curr->dim[Y] ; y++ ) {
			for (x=0 ; x < curr->dim[X] ; x++ ) {
				int n, xp, yp;
				/* x,y are in the coordinates in the current
				 * layer.  xp,yp are the coordinates of the
				 * same area in the previous (lower) layer.
				 */
				xp = x * DIM_BB_CHILDREN;
				yp = y * DIM_BB_CHILDREN;

				/* initialize the current dsp_bb cell */
				dsp_bb = &curr->p[y*curr->dim[X]+x];
				dsp_bb->magic = MAGIC_dsp_bb;
				n = (int)pow( (double)DIM_BB_CHILDREN, (double)curr_layer);
				VSET(dsp_bb->dspb_rpp.dsp_min,
				     x * n, y * n, 0x0ffff);
				VSET(dsp_bb->dspb_rpp.dsp_max,
				     x * n, y * n, 0);
d833 1
a833 1
				tot = 0;
d835 4
a838 4
				dlog("  cell %d,%d  (%d,%d-%d,%d)\n", x, y, 
					       dsp_bb->dspb_rpp.dsp_min[X],
					       dsp_bb->dspb_rpp.dsp_min[Y],
					       (x+1) * n, (y+1)*n);
d840 3
a842 3
				i=0;
				for (j=0 ; j < DIM_BB_CHILDREN && (yp+j) < prev->dim[Y] ; j++) {
					for (i=0 ; i < DIM_BB_CHILDREN && (xp+i) < prev->dim[X]; i++) {
d844 1
a844 1
						idx = (yp+j) * prev->dim[X] + xp+i;
d846 1
a846 1
						t = &prev->p[ idx ].dspb_rpp;
d848 4
a851 2
						VMINMAX(dsp_bb->dspb_rpp.dsp_min, dsp_bb->dspb_rpp.dsp_max, t->dsp_min);
						VMINMAX(dsp_bb->dspb_rpp.dsp_min, dsp_bb->dspb_rpp.dsp_max, t->dsp_max);
d853 1
a853 1
						dsp_bb->dspb_children[tot++] = &prev->p[ idx ];
d856 2
a857 2
						dlog("\t\tsubcell %d,%d min: %d,%d,%d  max: %d,%d,%d\n",
						     xp+i, yp+j, V3ARGS(t->dsp_min), V3ARGS(t->dsp_max) );
d859 3
a861 3
						if (RT_G_DEBUG & DEBUG_HF) 
						    if (i+1 >= DIM_BB_CHILDREN || xp+i+1 >= prev->dim[X])
							bu_log("\n");
d863 2
a864 2
					}
				}
d866 4
a869 4
				dlog("\t\txy: %d,%d, ij:%d,%d min:%d,%d,%d max:%d,%d,%d\n",
				     x, y, i, j,
				     V3ARGS(dsp_bb->dspb_rpp.dsp_min),
				     V3ARGS(dsp_bb->dspb_rpp.dsp_max) );
d872 3
a874 4
				dsp_bb->dspb_ch_dim[X] = i;
				dsp_bb->dspb_ch_dim[Y] = j;
			}
		}
d876 2
d880 5
a884 5
	if (RT_G_DEBUG & DEBUG_HF) {
		plot_layers(dsp);
		bu_log("_  x:%d y:%d min %d max %d\n",
		       XCNT(dsp), YCNT(dsp), dsp_min, dsp_max);
	}
d906 10
a915 10
struct soltab		*stp;
struct rt_db_internal	*ip;
struct rt_i		*rtip;
{
	struct rt_dsp_internal		*dsp_ip;
	register struct dsp_specific	*dsp;
	unsigned short dsp_min, dsp_max;
	point_t pt, bbpt;
	vect_t work;
	fastf_t f;
d917 2
a918 2
	if (RT_G_DEBUG & DEBUG_HF)
		bu_log("rt_dsp_prep()\n");
d920 4
a923 4
	RT_CK_DB_INTERNAL(ip);
	dsp_ip = (struct rt_dsp_internal *)ip->idb_ptr;
	RT_DSP_CK_MAGIC(dsp_ip);
	BU_CK_VLS(&dsp_ip->dsp_name);
d925 8
a932 8
	switch (dsp_ip->dsp_datasrc) {
	case RT_DSP_SRC_V4_FILE: 
	case RT_DSP_SRC_FILE:
	    BU_CK_MAPPED_FILE(dsp_ip->dsp_mp);
	    break;
	case RT_DSP_SRC_OBJ:
	    break;
	}
d935 3
a937 3
	BU_GETSTRUCT( dsp, dsp_specific );
	stp->st_specific = (genptr_t) dsp;
	dsp->dsp_i = *dsp_ip;		/* struct copy */
d939 3
a941 3
	bu_semaphore_acquire( RT_SEM_MODEL);
	++dsp_ip->dsp_mp->uses;
	bu_semaphore_release( RT_SEM_MODEL);
d943 2
a944 2
	dsp->xsiz = dsp_ip->dsp_xcnt-1;	/* size is # cells or values-1 */
	dsp->ysiz = dsp_ip->dsp_ycnt-1;	/* size is # cells or values-1 */
d947 2
a948 2
	/* compute the multi-resolution bounding boxes */
	dsp_layers(dsp, &dsp_min, &dsp_max);
d951 8
a958 8
	/* record the distance to each of the bounding planes */
	dsp->dsp_pl_dist[XMIN] = 0.0;
	dsp->dsp_pl_dist[XMAX] = (fastf_t)dsp->xsiz;
	dsp->dsp_pl_dist[YMIN] = 0.0;
	dsp->dsp_pl_dist[YMAX] = (fastf_t)dsp->ysiz;
	dsp->dsp_pl_dist[ZMIN] = 0.0;
	dsp->dsp_pl_dist[ZMAX] = (fastf_t)dsp_max;
	dsp->dsp_pl_dist[ZMID] = (fastf_t)dsp_min;
d960 1
a960 1
	/* compute enlarged bounding box and spere */
d967 8
a974 8
	BBOX_PT(-.1,		    -.1,		        -.1);
	BBOX_PT(dsp_ip->dsp_xcnt+.1, -.1,		        -.1);
	BBOX_PT(dsp_ip->dsp_xcnt+.1, dsp_ip->dsp_ycnt+.1, -1);
	BBOX_PT(-.1,		    dsp_ip->dsp_ycnt+.1, -1);
	BBOX_PT(-.1,		    -.1,		        dsp_max+.1);
	BBOX_PT(dsp_ip->dsp_xcnt+.1, -.1,		        dsp_max+.1);
	BBOX_PT(dsp_ip->dsp_xcnt+.1, dsp_ip->dsp_ycnt+.1, dsp_max+.1);
	BBOX_PT(-.1,		    dsp_ip->dsp_ycnt+.1, dsp_max+.1);
d978 2
a979 2
	VADD2SCALE( stp->st_center, stp->st_min, stp->st_max, 0.5 );
	VSUB2SCALE( work, stp->st_max, stp->st_min, 0.5 );
d981 5
a985 5
	f = work[X];
	if (work[Y] > f )  f = work[Y];
	if (work[Z] > f )  f = work[Z];
	stp->st_aradius = f;
	stp->st_bradius = MAGNITUDE(work);
d987 5
a991 5
	if (RT_G_DEBUG & DEBUG_HF) {
		bu_log("  model space bbox (%g %g %g) (%g %g %g)\n",
			V3ARGS(stp->st_min),
			V3ARGS(stp->st_max));
	}
d994 8
a1001 8
	switch (dsp_ip->dsp_datasrc) {
	case RT_DSP_SRC_V4_FILE: 
	case RT_DSP_SRC_FILE:
	    BU_CK_MAPPED_FILE(dsp_ip->dsp_mp);
	    break;
	case RT_DSP_SRC_OBJ:
	    break;
	}
d1003 1
a1003 1
	return 0;
d1021 1
d1023 2
d1026 1
a1026 1
    if ((fp=fopen(fname, "w")) != (FILE *)NULL) {
d1040 1
d1042 1
d1068 1
d1070 1
a1070 1
    struct seg *seg_p;
d1075 2
a1078 1
	double tt = isect->tol->dist;
d1083 1
a1083 1
	if ( fabs(seg->seg_out.hit_dist - in_hit->hit_dist) <= (tt*tt) ) {
d1085 22
d1112 2
a1113 1
		bu_log("extending previous seg to %g\n", out_hit->hit_dist);
d1118 5
d1124 4
d1145 1
d1160 1
a1160 1

d1165 2
a1166 13
    /* insert the segment in the list by in-hit distance */
    for ( BU_LIST_FOR(seg_p, seg, &isect->seglist) ) {
	fp = (FILE *)NULL;
	if (seg->seg_in.hit_dist < seg_p->seg_in.hit_dist) {
	    /* found the spot for this one */
	    BU_LIST_INSERT(&(seg_p->l), &seg->l);
	    goto done;
	}
    }
    /* this one goes in the end of the list */
    BU_LIST_INSERT(&isect->seglist, &seg->l);
 done:

d1171 1
a1171 1
#endif
d1205 1
d1222 1
d1244 1
d1252 1
d1254 4
a1257 1
	if ( (fp=fopen(buf, "w")) == (FILE *)NULL) {
d1276 1
d1278 1
d1282 1
d1319 1
d1325 1
d1353 1
d1366 4
d1385 5
a1389 5
	point_t B, 
	point_t C, 
	point_t D, 
	struct isect_stuff *isect, 
	struct dsp_bb *dsp_bb)
d1395 8
a1402 7
	if (RT_G_DEBUG & DEBUG_HF) {
	    VPRINT("\tA", A);
	    VPRINT("\tB", B);
	    VPRINT("\tC", C);
	    VPRINT("\tD", D);
	}

d1406 1
a1406 1
	return DSP_CUT_DIR_llUR;
d1443 9
d1456 1
a1456 1
	h4 = DSP(isect->dsp, hi[X], hi[Y]);
d1462 1
a1462 1
	h1 = DSP(isect->dsp, hi[X], lo[Y]);
d1465 1
a1465 1
	h4 = DSP(isect->dsp, lo[X], hi[Y]);
d1474 2
a1475 1
	    return DSP_CUT_DIR_llUR;
d1485 1
a1485 1
		bu_log("B-C cut\n");
d1487 1
a1487 1
	return DSP_CUT_DIR_ULlr;
d1502 1
a1502 1
	VSET(B, x, y, DSP(isect->dsp, x, y) );
d1505 1
a1505 1
	VSET(A, x, y, DSP(isect->dsp, x, y) );
d1508 1
a1508 1
	VSET(C, x, y, DSP(isect->dsp, x, y) );
d1511 1
a1511 1
	VSET(D, x, y, DSP(isect->dsp, x, y) );
d1517 1
a1517 1
	       __FILE__, __LINE__, isect->dsp->dsp_i.dsp_cuttype);
d1551 5
a1555 5
		   point_t A,
		   point_t B,
		   point_t C,
		   point_t D,
		   point_t P)
d1561 1
d1563 1
a1563 1

d1570 1
d1572 1
d1582 1
d1584 1
d1594 1
d1596 1
d1606 1
d1608 1
d1614 1
d1616 1
d1620 1
d1622 1
d1626 1
a1626 1
	bu_log("%s:%d Coding error, bad face\n", __FILE__, __LINE__);
a1647 1
    int direction;
d1655 1
a1655 2
    double dot;
    double v1, v2;
d1671 1
a1671 1
    VSET(A, x, y, DSP(isect->dsp, x, y) );
d1674 1
a1674 1
    VSET(B, x, y, DSP(isect->dsp, x, y) );
d1677 1
a1677 1
    VSET(D, x, y, DSP(isect->dsp, x, y) );
d1680 1
a1680 1
    VSET(C, x, y, DSP(isect->dsp, x, y) );
d1683 1
d1697 1
a1697 1

d1750 1
a1750 1
    direction = permute_cell(A, B, C, D, isect, dsp_bb);
d1830 1
a1830 1
		v2 = VDOT(isect->r.r_dir, hits[i].hit_normal);
d1833 2
a1834 2
		if ( v2 < 0.0 ) {
		    dlog("v2(%g) < 0.0\n", v2);
a1868 1
		v1 = dot;
d1870 1
a1870 1
	} else dlog("no data at %d\n", i);
d1917 2
a1918 2
 *
 * XXX need to return surface number for in/out
d1922 2
a1923 2
	  register const fastf_t *min,
	  register const fastf_t *max)
d2036 1
a2036 1

d2060 1
a2060 1
    short	csX, csY;	/* coordinates of current cell */
d2067 1
a2067 1

d2072 1
a2072 5
    csX = (dsp_bb->dspb_rpp.dsp_max[X] - dsp_bb->dspb_rpp.dsp_min[X] + 1) / 
	dsp_bb->dspb_ch_dim[X];

    csY = (dsp_bb->dspb_rpp.dsp_max[Y] - dsp_bb->dspb_rpp.dsp_min[Y] + 1) /
	dsp_bb->dspb_ch_dim[Y];
d2075 2
a2076 2
    cX = (minpt[X] - bbmin[X]) / csX;
    cY = (minpt[Y] - bbmin[Y]) / csY;
d2084 4
a2087 2
    dlog("recurse_dsp_bb  cell size: %d %d  current cell: %d %d\n",
	 csX, csY, cX, cY);
d2097 1
a2097 1
	tDX = -csX / isect->r.r_dir[X];
d2102 1
a2102 1
	tX += ( (bbmin[X] + (cX * csX)) - minpt[X]) / isect->r.r_dir[X];
d2105 1
a2105 1
	tDX = csX / isect->r.r_dir[X];
d2108 1
a2108 1
	    tX += ((bbmin[X] + ((cX+1) * csX)) - minpt[X]) / isect->r.r_dir[X];
d2117 2
a2118 2
	tDY = -csY / isect->r.r_dir[Y];
	tY += ( (bbmin[Y] + (cY * csY)) - minpt[Y]) / isect->r.r_dir[Y];
d2122 1
a2122 1
	tDY = csY / isect->r.r_dir[Y];
d2125 1
a2125 1
	    tY += ((bbmin[Y] + ((cY+1) * csY)) - minpt[Y]) / isect->r.r_dir[Y];
d2138 8
a2145 3
	    bu_log("intersecting sub-cell %d %d  dist:%g out:%g\n",
		   cX, cY, curr_dist, out_dist);

d2148 1
a2148 4
	    bu_log("in_pt %g %g %g", V3ARGS(v));
	    VJOIN1(pt, isect->r.r_pt, out_dist, isect->r.r_dir);
	    MAT4X3PNT(v, stom, pt);
	    bu_log(" out %g %g %g\n", V3ARGS(v));
d2157 2
a2158 4
	if (p != &dsp_bb->dspb_children[dsp_bb->dspb_ch_dim[X] * cY + cX]) {
	    bu_bomb("ptr oops\n");
	}
	if (RT_G_DEBUG & DEBUG_HF) {
d2160 1
a2160 2
	    bu_log("\n");
	}
d2163 3
a2166 11
	if (RT_G_DEBUG & DEBUG_HF) {
	    bu_log_indent_delta(-4); bu_log("\n");
	    bu_log("tX: %g tY: %g\n", tX, tY);
	    VJOIN1(pt, isect->r.r_pt, tX, isect->r.r_dir);
	    MAT4X3PNT(v, stom, pt);
	    bu_log("next x crossing: %g %g %g\n", V3ARGS(v));
	    VJOIN1(pt, isect->r.r_pt, tY, isect->r.r_dir);
	    MAT4X3PNT(v, stom, pt);
	    bu_log("next y crossing: %g %g %g\n", V3ARGS(v));
	}

d2170 1
d2172 1
a2172 1

d2178 1
d2180 1
d2188 1
a2188 1

d2211 1
d2221 1
a2221 1
	bu_log("isect_ray_dsp_bb( (%d,%d,%d) (%d,%d,%d))\n",
a2225 2
    min_z = dsp_bb->dspb_rpp.dsp_min[Z];

d2235 1
a2237 1

d2240 1
d2246 7
a2252 2
    VJOIN1(minpt, isect->r.r_pt, isect->r.r_min, isect->r.r_dir);
    VJOIN1(maxpt, isect->r.r_pt, isect->r.r_max, isect->r.r_dir);
d2257 1
d2273 2
d2280 1
a2280 1
	seg_in.hit_dist = isect->r.r_min;
d2283 2
a2284 2
	    /* hit_priv   */
	    /* hit_private */
d2286 1
a2286 1
	    /* hit_rayp */
d2288 1
a2288 1
	seg_out.hit_dist = isect->r.r_max;
d2324 3
d2329 5
a2333 1
	return;
d2371 2
a2372 2
	VJOIN1(minpt, isect->r.r_pt, isect->r.r_min, isect->r.r_dir);
	VJOIN1(maxpt, isect->r.r_pt, isect->r.r_max, isect->r.r_dir);
d2374 1
a2374 1
	in_hit.hit_dist = isect->r.r_min;
d2379 1
a2379 1
	out_hit.hit_dist = isect->r.r_max;
d2404 12
a2415 24
struct soltab		*stp;
register struct xray	*rp;
struct application	*ap;
struct seg		*seghead;
{
	register struct dsp_specific *dsp =
		(struct dsp_specific *)stp->st_specific;
	register struct seg *segp;
	int	i;
	vect_t	dir;	/* temp storage */
	vect_t	v;
	struct isect_stuff isect;

	RT_DSP_CK_MAGIC(dsp);
	BU_CK_VLS(&dsp->dsp_i.dsp_name);

	switch (dsp->dsp_i.dsp_datasrc) {
	case RT_DSP_SRC_V4_FILE: 
	case RT_DSP_SRC_FILE:
	    BU_CK_MAPPED_FILE(dsp->dsp_i.dsp_mp);
	    break;
	case RT_DSP_SRC_OBJ:
	    break;
	}
d2417 2
a2418 15
	/* 
	 * map ray into the coordinate system of the dsp 
	 */
	MAT4X3PNT(isect.r.r_pt, dsp->dsp_i.dsp_mtos, rp->r_pt);
	MAT4X3VEC(dir, dsp->dsp_i.dsp_mtos, rp->r_dir);
	VMOVE(isect.r.r_dir, dir);
	VUNITIZE(isect.r.r_dir);

	/* wrap a bunch of things together */
	isect.ap = ap;
	isect.stp = stp;
	isect.dsp = (struct dsp_specific *)stp->st_specific;
	isect.tol = &ap->a_rt_i->rti_tol;
	VINVDIR(isect.inv_dir, isect.r.r_dir);
	BU_LIST_INIT(&isect.seglist);
d2420 8
d2429 15
a2443 14
	if (RT_G_DEBUG & DEBUG_HF) {
	    bu_log("rt_dsp_shot(pt:(%g %g %g)\n\tdir[%g]:(%g %g %g))\n    pixel(%d,%d)\n",
			V3ARGS(rp->r_pt),
			MAGNITUDE(rp->r_dir),
			V3ARGS(rp->r_dir),
			ap->a_x, ap->a_y);

	    bn_mat_print("mtos", dsp->dsp_i.dsp_mtos);
	    bu_log("Solid space ray pt:(%g %g %g)\n", V3ARGS(isect.r.r_pt));
	    bu_log("\tdir[%g]: [%g %g %g]\n\tunit_dir(%g %g %g)\n",
			MAGNITUDE(dir),
			V3ARGS(dir),
			V3ARGS(isect.r.r_dir));
	}
a2444 9
	/* We look at the topmost layer of the bounding-box tree and
	 * make sure that it has dimension 1.  Otherwise, something is wrong
	 */
	if (isect.dsp->layer[isect.dsp->layers-1].dim[X] != 1 ||
	    isect.dsp->layer[isect.dsp->layers-1].dim[Y] != 1) {
	    bu_log("%s:%d how do i find the topmost layer?\n",
		   __FILE__, __LINE__);
	    bu_bomb("");
	}
d2446 14
d2461 9
a2469 2
	/* intersect the ray with the bounding rpps */
	(void)isect_ray_dsp_bb(&isect, isect.dsp->layer[isect.dsp->layers-1].p);
d2472 2
a2473 13
	/* if we missed it all, give up now */
	if (BU_LIST_IS_EMPTY(&isect.seglist))
		return 0;

	/* map hit distances back to model space */
	i = 0;
	for (BU_LIST_FOR(segp, seg, &isect.seglist)) {
		i += 2;
		if (RT_G_DEBUG & DEBUG_HF) {
			bu_log("solid in:%6g out:%6g\t",
				segp->seg_in.hit_dist,
				segp->seg_out.hit_dist);
		}
d2475 3
a2477 16
		VSCALE(dir, isect.r.r_dir, segp->seg_in.hit_dist);
		MAT4X3VEC(v, dsp->dsp_i.dsp_stom, dir)
		segp->seg_in.hit_dist = MAGNITUDE(v);
		if (VDOT(v, rp->r_dir) < 0.0) segp->seg_in.hit_dist *= -1.0;

		VSCALE(dir, isect.r.r_dir, segp->seg_out.hit_dist);
		MAT4X3VEC(v, dsp->dsp_i.dsp_stom, dir)
		segp->seg_out.hit_dist = MAGNITUDE(v);
		if (VDOT(v, rp->r_dir) < 0.0) segp->seg_out.hit_dist *= -1.0;

		if (segp->seg_in.hit_dist > segp->seg_out.hit_dist) {
			bu_log("Pixel %d %d seg inside out %g %g\n",
				ap->a_x, ap->a_y,
				segp->seg_in.hit_dist,
				segp->seg_out.hit_dist);
		}
d2479 34
a2512 7
		MAT4X3VEC(v, dsp->dsp_i.dsp_mtos, segp->seg_in.hit_normal);
		VMOVE(segp->seg_in.hit_normal, v);
		VUNITIZE( segp->seg_in.hit_normal );

		MAT4X3VEC(v, dsp->dsp_i.dsp_mtos, segp->seg_out.hit_normal);
		VMOVE(segp->seg_out.hit_normal, v);
		VUNITIZE( segp->seg_out.hit_normal );
d2514 4
a2517 5
		if (RT_G_DEBUG & DEBUG_HF) {
			bu_log("model in:%6g out:%6g\n",
			segp->seg_in.hit_dist,
			segp->seg_out.hit_dist);
		}
d2519 1
d2521 4
a2524 4
	if (RT_G_DEBUG & DEBUG_HF) {
		double NdotD;
		double d;
		static const plane_t plane = {0.0, 0.0, -1.0, 0.0};
d2526 4
a2529 4
		NdotD = VDOT(plane, rp->r_dir);
		d = - ( (VDOT(plane, rp->r_pt) - plane[H]) / NdotD);	
		bu_log("rp -> Z=0 dist: %g\n", d);
	}
d2531 2
a2532 2
	/* transfer list of hitpoints */
	BU_LIST_APPEND_LIST( &(seghead->l), &isect.seglist);
d2534 1
a2534 1
	return i;
d2546 5
a2550 5
struct soltab	       *stp[]; /* An array of solid pointers */
struct xray		*rp[]; /* An array of ray pointers */
struct  seg            segp[]; /* array of segs (results returned) */
int		  	    n; /* Number of ray/object pairs */
struct application	*ap;
d2552 2
a2553 2
	if (RT_G_DEBUG & DEBUG_HF)
		bu_log("rt_dsp_vshot()\n");
d2555 1
a2555 1
	(void)rt_vstub( stp, rp, segp, n, ap );
d2565 5
a2569 5
vect_t N;
struct dsp_specific *dsp;
int x, y;
FILE *fd;
int bool;
d2571 13
a2583 13
	/*  Gridpoint specified is "B" we compute normal by taking the
	 *  cross product of the vectors  A->C, D->E
	 *
	 * 		E
	 *
	 *		|
	 *
	 *	A   -	B   -	C
	 *
	 *		|
	 *
	 *		D
	 */
d2585 2
a2586 2
	point_t A, C, D, E, tmp;
	vect_t Vac, Vde;
d2588 3
a2590 3
	if (x == 0) {	VSET(tmp, x, y, DSP(dsp, x, y) );	}
	else {		VSET(tmp, x-1, y, DSP(dsp, x-1, y) );	}
	MAT4X3PNT(A, dsp->dsp_i.dsp_stom, tmp);
d2592 3
a2594 3
	if (x >= XSIZ(dsp)) {	VSET(tmp, x, y,  DSP(dsp, x, y) ); } 
	else {			VSET(tmp, x+1, y,  DSP(dsp, x+1, y) );	}
	MAT4X3PNT(C, dsp->dsp_i.dsp_stom, tmp);
d2597 3
a2599 3
	if (y == 0) {	VSET(tmp, x, y, DSP(dsp, x, y) ); }
	else {		VSET(tmp, x, y-1, DSP(dsp, x, y-1) );	}
	MAT4X3PNT(D, dsp->dsp_i.dsp_stom, tmp);
d2601 3
a2603 3
	if (y >= YSIZ(dsp)) {	VSET(tmp, x, y, DSP(dsp, x, y) ); }
	else {			VSET(tmp, x, y+1, DSP(dsp, x, y+1) );	}
	MAT4X3PNT(E, dsp->dsp_i.dsp_stom, tmp);
d2605 5
a2609 5
	if (fd && bool) {
		pl_color(fd, 220, 220, 90);
		pdv_3line(fd, A, C);
		pdv_3line(fd, D, E);
	}
d2611 2
a2612 2
	VSUB2(Vac, C, A);
	VSUB2(Vde, E, D);
d2614 1
a2614 1
	VCROSS(N, Vac, Vde);
d2616 1
a2616 1
	VUNITIZE(N);
d2626 3
a2628 3
register struct hit	*hitp;
struct soltab		*stp;
register struct xray	*rp;
d2689 2
a2690 1
	sprintf(buf, "dsp%02d.pl", plot_file_num++);
d2693 3
a2695 5
	bu_log("plotting normals in %s\n", buf);
	bu_semaphore_acquire( BU_SEM_SYSCALL);
	if ((fd=fopen(buf, "w")) == (FILE *)NULL) {
	    bu_semaphore_release( BU_SEM_SYSCALL);
	    bu_bomb("Couldn't open plot file\n");
d2697 1
a2697 1
	    bu_log("plotting %s\n", buf);
d2725 1
a2725 1
	VSET(tmp, x,   y,   DSP(dsp, x,   y));
d2730 1
a2730 1
	VSET(tmp, x+1, y,   DSP(dsp, x+1, y));
d2735 1
a2735 1
	VSET(tmp, x+1, y+1, DSP(dsp, x+1, y+1));
d2740 1
a2740 1
	VSET(tmp, x,   y+1, DSP(dsp, x,   y+1));
a2744 1
	bu_semaphore_release( BU_SEM_SYSCALL);
a2811 2
	if (fd) {
	    bu_semaphore_acquire( BU_SEM_SYSCALL);
d2816 1
a2818 1
	}
d2829 3
a2831 3
register struct curvature *cvp;
register struct hit	*hitp;
struct soltab		*stp;
d2834 2
a2835 2
	if (RT_G_DEBUG & DEBUG_HF)
		bu_log("rt_dsp_curve()\n");
d2837 1
a2837 1
 	cvp->crv_c1 = cvp->crv_c2 = 0;
d2839 2
a2840 2
	/* any tangent direction */
 	bn_vec_ortho( cvp->crv_pdir, hitp->hit_normal );
d2853 28
a2880 34
struct application	*ap;
struct soltab		*stp;
register struct hit	*hitp;
register struct uvcoord	*uvp;
{
	register struct dsp_specific *dsp =
		(struct dsp_specific *)stp->st_specific;
	point_t pt;
	vect_t tmp;
	double r;
	fastf_t min_r_U, min_r_V;
	vect_t norm;
	vect_t rev_dir;
	fastf_t dot_N;
	vect_t UV_dir;
	vect_t U_dir, V_dir;
	fastf_t U_len, V_len;
	double one_over_len;

	MAT4X3PNT(pt, dsp->dsp_i.dsp_mtos, hitp->hit_point);

	/* compute U, V */
	uvp->uv_u = pt[X] / (double)XSIZ(dsp);
	CLAMP(uvp->uv_u, 0.0, 1.0);

	uvp->uv_v = pt[Y] / (double)YSIZ(dsp);
	CLAMP(uvp->uv_v, 0.0, 1.0);


	/* du, dv indicate the extent of the ray radius in UV coordinates.
	 * To compute this, transform unit vectors from solid space to model
	 * space.  We remember the length of the resultant vectors and then
	 * unitize them to get u,v directions in model coordinate space.
	 * 
d2882 8
a2889 2
	 */
	VSET( tmp, XSIZ(dsp), 0.0, 0.0 )
d2892 2
a2893 2
	one_over_len = 1.0/U_len;
	VSCALE( U_dir, U_dir, one_over_len )
d2898 2
a2899 2
	one_over_len = 1.0/V_len;
	VSCALE( V_dir, V_dir, one_over_len )
d2903 2
a2904 2
	min_r_U = r / U_len;
	min_r_V = r / V_len;
d2906 4
a2909 4
	/* compute UV_dir, a vector in the plane of the hit point (surface)
	 * which points in the anti-rayward direction
	 */
	VREVERSE( rev_dir, ap->a_ray.r_dir )
d2912 1
a2912 1
	VJOIN1( UV_dir, rev_dir, -dot_N, norm )
d2916 3
a2918 3
		/* ray almost perfectly 90 degrees to surface */
		uvp->uv_du = 0.5;
		uvp->uv_dv = 0.5;
d2920 3
a2922 3
		/* somehow this computes the extent of U and V in the radius */
		uvp->uv_du = (r / U_len) * VDOT( UV_dir, U_dir ) / dot_N;
		uvp->uv_dv = (r / V_len) * VDOT( UV_dir, V_dir ) / dot_N;
d2925 9
a2933 9
	if (uvp->uv_du < 0.0 )
		uvp->uv_du = -uvp->uv_du;
	if (uvp->uv_du < min_r_U )
		uvp->uv_du = min_r_U;

	if (uvp->uv_dv < 0.0 )
		uvp->uv_dv = -uvp->uv_dv;
	if (uvp->uv_dv < min_r_V )
		uvp->uv_dv = min_r_V;
d2935 7
a2941 7
	if (RT_G_DEBUG & DEBUG_HF)
		bu_log("rt_dsp_uv(pt:%g,%g siz:%d,%d)\n U_len=%g V_len=%g\n r=%g rbeam=%g diverge=%g dist=%g\n u=%g v=%g du=%g dv=%g\n",
			pt[X], pt[Y], XSIZ(dsp), YSIZ(dsp), 
			U_len, V_len,
			r, ap->a_rbeam, ap->a_diverge, hitp->hit_dist,
			uvp->uv_u, uvp->uv_v,
			uvp->uv_du, uvp->uv_dv);
d2949 1
a2949 1
register struct soltab *stp;
d2951 2
a2952 2
	register struct dsp_specific *dsp =
		(struct dsp_specific *)stp->st_specific;
d2954 2
a2955 2
	if (RT_G_DEBUG & DEBUG_HF)
		bu_log("rt_dsp_free()\n");
d2957 9
a2965 9
	switch (dsp->dsp_i.dsp_datasrc) {
	case RT_DSP_SRC_V4_FILE: 
	case RT_DSP_SRC_FILE:
	    BU_CK_MAPPED_FILE(dsp->dsp_i.dsp_mp);
	    bu_close_mapped_file(dsp->dsp_i.dsp_mp);
	    break;
	case RT_DSP_SRC_OBJ:
	    break;
	}
d2968 1
a2968 1
	bu_free( (char *)dsp, "dsp_specific" );
d2977 2
a2978 2
	if (RT_G_DEBUG & DEBUG_HF)
		bu_log("rt_dsp_class()\n");
d2980 1
a2980 1
	return(0);
d2988 14
a3001 14
struct bu_list		*vhead;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol	*tol;
{
	struct rt_dsp_internal	*dsp_ip =
		(struct rt_dsp_internal *)ip->idb_ptr;
	point_t m_pt;
	point_t s_pt;
	int x, y;
	int step;
	int xlim = dsp_ip->dsp_xcnt - 1;
	int ylim = dsp_ip->dsp_ycnt - 1;
	int xfudge, yfudge;
d3003 2
a3004 2
	if (RT_G_DEBUG & DEBUG_HF)
		bu_log("rt_dsp_plot()\n");
d3006 2
a3007 2
	RT_CK_DB_INTERNAL(ip);
	RT_DSP_CK_MAGIC(dsp_ip);
d3019 16
a3034 3
	/* Draw the Bottom */
	VSETALL(s_pt, 0.0);
	MOVE();
d3036 3
a3038 2
	s_pt[X] = xlim;
	DRAW();
d3040 4
a3043 2
	s_pt[Y] = ylim;
	DRAW();
a3044 2
	s_pt[X] = 0.0;
	DRAW();
d3046 4
a3049 2
	s_pt[Y] = 0.0;
	DRAW();
d3051 4
a3055 3
	/* Draw the corners */
	s_pt[Z] = DSP(dsp_ip, 0, 0);
	DRAW();
d3057 7
a3063 1
	VSET(s_pt, xlim, 0.0, 0.0);
d3065 7
a3071 2
	s_pt[Z] = DSP(dsp_ip, xlim, 0);
	DRAW();
d3074 2
a3075 1
	VSET(s_pt, xlim, ylim, 0.0);
a3076 2
	s_pt[Z] = DSP(dsp_ip, xlim, ylim);
	DRAW();
d3078 28
a3105 4
	VSET(s_pt, 0.0, ylim, 0.0);
	MOVE();
	s_pt[Z] = DSP(dsp_ip, 0, ylim);
	DRAW();
d3107 2
d3110 2
a3111 15
	/* Draw the outside line of the top 
	 * We draw the four sides of the top at full resolution.
	 * This helps edge matching.
	 * The inside of the top, we draw somewhat coarser
	 */
	for (y=0 ; y < dsp_ip->dsp_ycnt ; y += ylim ) {
		VSET(s_pt, 0.0, y, DSP(dsp_ip, 0, y));
		MOVE();

		for (x=0 ; x < dsp_ip->dsp_xcnt ; x++) {
			s_pt[X] = x;
			s_pt[Z] = DSP(dsp_ip, x, y);
			DRAW();
		}
	}
d3113 3
d3117 4
a3120 9
	for (x=0 ; x < dsp_ip->dsp_xcnt ; x += xlim ) {
		VSET(s_pt, x, 0.0, DSP(dsp_ip, x, 0));
		MOVE();

		for (y=0 ; y < dsp_ip->dsp_ycnt ; y++) {
			s_pt[Y] = y;
			s_pt[Z] = DSP(dsp_ip, x, y);
			DRAW();
		}
a3121 38

	/* now draw the body of the top */
	if (ttol->rel )  {
		int	rstep;
		rstep = dsp_ip->dsp_xcnt;
		V_MAX( rstep, dsp_ip->dsp_ycnt );
		step = (int)(ttol->rel * rstep);
	} else { 
		int goal = 10000;
		goal -= 5;
		goal -= 8 + 2 * (dsp_ip->dsp_xcnt+dsp_ip->dsp_ycnt);

		if (goal <= 0) return 0;

		/* Compute data stride based upon producing no more than 'goal' vectors */
		step = ceil(
			sqrt( 2*(xlim)*(ylim) /
				(double)goal )
			);
	}
	if (step < 1 )  step = 1;


	xfudge = (dsp_ip->dsp_xcnt % step + step) / 2 ;
	yfudge = (dsp_ip->dsp_ycnt % step + step) / 2 ;

	if (xfudge < 1) xfudge = 1;
	if (yfudge < 1) yfudge = 1;

	for (y=yfudge ; y < ylim ; y += step ) {
		VSET(s_pt, 0.0, y, DSP(dsp_ip, 0, y));
		MOVE();

		for (x=xfudge ; x < xlim ; x+=step ) {
			s_pt[X] = x;
			s_pt[Z] = DSP(dsp_ip, x, y);
			DRAW();
		}
d3123 3
a3125 3
		s_pt[X] = xlim;
		s_pt[Z] = DSP(dsp_ip, xlim, y);
		DRAW();
d3127 1
a3127 1
	}
d3129 3
a3131 3
	for (x=xfudge ; x < xlim ; x += step ) {
		VSET(s_pt, x, 0.0, DSP(dsp_ip, x, 0));
		MOVE();
d3133 5
a3137 5
		for (y=yfudge ; y < ylim ; y+=step) {
			s_pt[Y] = y;
			s_pt[Z] = DSP(dsp_ip, x, y);
			DRAW();
		}
d3139 4
a3142 4
		s_pt[Y] = ylim;
		s_pt[Z] = DSP(dsp_ip, x, ylim);
		DRAW();
	}
d3146 1
a3146 1
	return(0);
d3158 5
a3162 5
struct nmgregion	**r;
struct model		*m;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol	*tol;
d3164 1
a3164 1
	LOCAL struct rt_dsp_internal	*dsp_ip;
d3166 2
a3167 2
	if (RT_G_DEBUG & DEBUG_HF)
		bu_log("rt_dsp_tess()\n");
d3169 3
a3171 3
	RT_CK_DB_INTERNAL(ip);
	dsp_ip = (struct rt_dsp_internal *)ip->idb_ptr;
	RT_DSP_CK_MAGIC(dsp_ip);
d3173 1
a3173 1
	return(-1);
d3186 7
a3192 7
	     struct rt_db_internal	*ip,
	     const struct bu_external	*ep,
	     register const mat_t	mat,
	     const struct db_i		*dbip)
{
	struct bu_mapped_file		*mf;
	int				count, in_cookie, out_cookie;
d3195 8
a3202 8
	/* get file */
	mf = dsp_ip->dsp_mp = 
		bu_open_mapped_file_with_path(dbip->dbi_filepath,
			bu_vls_addr(&dsp_ip->dsp_name), "dsp");
	if (!mf) {
		bu_log("mapped file open failed\n");
		return -1;
	}
d3204 4
a3207 4
	if (dsp_ip->dsp_mp->buflen != dsp_ip->dsp_xcnt*dsp_ip->dsp_ycnt*2) {
		bu_log("DSP buffer wrong size");
		return -1;
	}
d3209 2
a3210 2
	in_cookie = bu_cv_cookie("nus"); /* data is network unsigned short */
	out_cookie = bu_cv_cookie("hus");
d3212 14
a3225 18
	if ( bu_cv_optimize(in_cookie) != bu_cv_optimize(out_cookie) ) {
		int got;
		/* if we're on a little-endian machine we convert the
		 * input file from network to host format
		 */
		count = dsp_ip->dsp_xcnt * dsp_ip->dsp_ycnt;
		mf->apbuflen = count * sizeof(unsigned short);
		mf->apbuf = bu_malloc(mf->apbuflen, "apbuf");

		got = bu_cv_w_cookie(mf->apbuf, out_cookie, mf->apbuflen,
				     mf->buf,    in_cookie, count);
		if (got != count) {
			bu_log("got %d != count %d", got, count);
			bu_bomb("\n");
		}
		dsp_ip->dsp_buf = dsp_ip->dsp_mp->apbuf;
	} else {
		dsp_ip->dsp_buf = dsp_ip->dsp_mp->buf;
d3227 5
a3231 1
	return 0;
d3245 1
a3245 1
	struct rt_binunif_internal	*bip;
d3247 1
a3247 1
	BU_GETSTRUCT(dsp_ip->dsp_bip, rt_db_internal);
d3249 3
a3251 3
	if (rt_retrieve_binunif(dsp_ip->dsp_bip, dbip,
				bu_vls_addr( &dsp_ip->dsp_name) ))
		return -1;
d3253 5
a3257 5
	if (RT_G_DEBUG & DEBUG_HF)
		bu_log("db_internal magic: 0x%08x  major: %d minor:%d\n",
		       dsp_ip->dsp_bip->idb_magic,
		       dsp_ip->dsp_bip->idb_major_type,
		       dsp_ip->dsp_bip->idb_minor_type);
d3259 1
a3259 1
	bip = dsp_ip->dsp_bip->idb_ptr;
d3261 3
a3263 3
	if (RT_G_DEBUG & DEBUG_HF)
		bu_log("binunif magic: 0x%08x  type: %d count:%d data[0]:%u\n",
		       bip->magic, bip->type, bip->count, bip->u.uint16[0]);
d3265 2
a3266 2
	dsp_ip->dsp_buf = bip->u.uint16;
	return 0;
d3284 1
a3284 1
	mat_t				tmp;
d3286 3
a3288 3
	/* Apply Modeling transform */
	MAT_COPY(tmp, dsp_ip->dsp_stom);
	bn_mat_mul(dsp_ip->dsp_stom, mat, tmp);
d3290 1
a3290 1
	bn_mat_inv(dsp_ip->dsp_mtos, dsp_ip->dsp_stom);
d3292 18
a3309 18
	switch (dsp_ip->dsp_datasrc) {
	case RT_DSP_SRC_FILE:
	case RT_DSP_SRC_V4_FILE:
		if (RT_G_DEBUG & DEBUG_HF)
			bu_log("getting data from file\n");
		return get_file_data(dsp_ip, ip, ep, mat, dbip);
		break;
	case RT_DSP_SRC_OBJ:
		if (RT_G_DEBUG & DEBUG_HF)
			bu_log("getting data from object\n");
		return get_obj_data(dsp_ip, ip, ep, mat, dbip);
		break;
	default:
		bu_log("%s:%d Odd dsp data src '%c' s/b '%c' or '%c'\n", 
		       __FILE__, __LINE__, dsp_ip->dsp_datasrc,
		       RT_DSP_SRC_FILE, RT_DSP_SRC_OBJ);
		return -1;
	}
d3320 8
a3327 8
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
{
	LOCAL struct rt_dsp_internal	*dsp_ip;
	union record			*rp;
	struct bu_vls			str;
d3341 2
a3342 2
	BU_CK_EXTERNAL( ep );
	rp = (union record *)ep->ext_buf;
d3344 3
a3346 3
	if (RT_G_DEBUG & DEBUG_HF)
		bu_log("rt_dsp_import(%s)\n", rp->ss.ss_args);
/*----------------------------------------------------------------------*/
d3350 5
a3354 5
	/* Check record type */
	if (rp->u_id != DBID_STRSOL )  {
		bu_log("rt_dsp_import: defective record\n");
		return(-1);
	}
d3356 12
a3367 6
	RT_CK_DB_INTERNAL( ip );
	ip->idb_type = ID_DSP;
	ip->idb_meth = &rt_functab[ID_DSP];
	ip->idb_ptr = bu_malloc( sizeof(struct rt_dsp_internal), "rt_dsp_internal");
	dsp_ip = (struct rt_dsp_internal *)ip->idb_ptr;
	dsp_ip->magic = RT_DSP_INTERNAL_MAGIC;
d3369 10
a3378 5
	/* set defaults */
	/* XXX bu_struct_parse does not set the null?
	 * memset(&dsp_ip->dsp_name[0], 0, DSP_NAME_LEN); 
	 */
	dsp_ip->dsp_xcnt = dsp_ip->dsp_ycnt = 0;
a3379 3
	dsp_ip->dsp_smooth = 1;
	MAT_IDN(dsp_ip->dsp_stom);
	MAT_IDN(dsp_ip->dsp_mtos);
d3381 4
a3384 12
	bu_vls_init( &str );
	bu_vls_strcpy( &str, rp->ss.ss_args );
	if (bu_struct_parse( &str, rt_dsp_parse, (char *)dsp_ip ) < 0) {
		if (BU_VLS_IS_INITIALIZED( &str )) bu_vls_free( &str );
		IMPORT_FAIL("parse error");
	}


	/* Validate parameters */
	if (dsp_ip->dsp_xcnt == 0 || dsp_ip->dsp_ycnt == 0) {
		IMPORT_FAIL("zero dimension on map");
	}
d3386 3
a3388 3
	if (dsp_get_data(dsp_ip, ip, ep, mat, dbip)) {
		IMPORT_FAIL("DSP data");
	}
d3390 4
a3393 4
	if (RT_G_DEBUG & DEBUG_HF) {
		bu_vls_trunc(&str, 0);
		bu_vls_struct_print( &str, rt_dsp_ptab, (char *)dsp_ip);
		bu_log("  imported as(%s)\n", bu_vls_addr(&str));
d3395 1
a3395 1
	}
d3397 2
a3398 2
	if (BU_VLS_IS_INITIALIZED( &str )) bu_vls_free( &str );
	return(0);			/* OK */
d3409 35
a3443 30
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
{
	struct rt_dsp_internal	*dsp_ip;
	struct rt_dsp_internal	dsp;
	union record		*rec;
	struct bu_vls		str;


	RT_CK_DB_INTERNAL(ip);
	if (ip->idb_type != ID_DSP )  return(-1);
	dsp_ip = (struct rt_dsp_internal *)ip->idb_ptr;
	RT_DSP_CK_MAGIC(dsp_ip);
	BU_CK_VLS(&dsp_ip->dsp_name);


	BU_CK_EXTERNAL(ep);
	ep->ext_nbytes = sizeof(union record)*DB_SS_NGRAN;
	ep->ext_buf = bu_calloc( 1, ep->ext_nbytes, "dsp external");
	rec = (union record *)ep->ext_buf;

	dsp = *dsp_ip;	/* struct copy */

	/* Since libwdb users may want to operate in units other
	 * than mm, we offer the opportunity to scale the solid
	 * (to get it into mm) on the way out.
	 */
	dsp.dsp_stom[15] *= local2mm;
d3445 3
a3447 8
	bu_vls_init( &str );
	bu_vls_struct_print( &str, rt_dsp_ptab, (char *)&dsp);
	if (RT_G_DEBUG & DEBUG_HF)	
		bu_log("rt_dsp_export(%s)\n", bu_vls_addr(&str) );

	rec->ss.ss_id = DBID_STRSOL;
	strncpy( rec->ss.ss_keyword, "dsp", NAMESIZE-1 );
	strncpy( rec->ss.ss_args, bu_vls_addr(&str), DB_SS_LEN-1 );
d3450 1
a3450 1
	if (BU_VLS_IS_INITIALIZED( &str )) bu_vls_free( &str );
d3452 1
a3452 1
	return(0);
d3466 4
a3469 4
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
d3471 2
a3472 2
	struct rt_dsp_internal	*dsp_ip;
	unsigned char		*cp;
d3476 1
a3476 1
	BU_CK_EXTERNAL( ep );
d3478 1
a3478 1
	BU_ASSERT_LONG( ep->ext_nbytes, >, 141 );
d3480 1
a3480 1
	RT_CK_DB_INTERNAL( ip );
d3482 5
a3486 5
	ip->idb_type = ID_DSP;
	ip->idb_meth = &rt_functab[ID_DSP];
	dsp_ip = ip->idb_ptr = 
		bu_malloc( sizeof(struct rt_dsp_internal), "rt_dsp_internal");
	memset(dsp_ip, 0, sizeof(*dsp_ip));
d3488 1
a3488 1
	dsp_ip->magic = RT_DSP_INTERNAL_MAGIC;
d3490 2
a3491 2
	/* get x, y counts */
	cp = (unsigned char *)ep->ext_buf;
d3493 2
a3494 2
	dsp_ip->dsp_xcnt = (unsigned) bu_glong( cp );
	cp += SIZEOF_NETWORK_LONG;
d3496 2
a3497 2
	dsp_ip->dsp_ycnt = (unsigned) bu_glong( cp );
	cp += SIZEOF_NETWORK_LONG;
d3499 4
a3502 4
	/* convert matrix */
	ntohd((unsigned char *)dsp_ip->dsp_stom, cp, 16);
	cp += SIZEOF_NETWORK_DOUBLE * 16;
	bn_mat_inv(dsp_ip->dsp_mtos, dsp_ip->dsp_stom);
d3504 3
a3506 3
	/* convert smooth flag */
	dsp_ip->dsp_smooth = bu_gshort( cp );
	cp += SIZEOF_NETWORK_SHORT;
d3508 2
a3509 2
	dsp_ip->dsp_datasrc = *cp;
	cp++;
d3511 3
a3513 3
	/* convert name of data location */
	bu_vls_init( &dsp_ip->dsp_name );
	bu_vls_strcpy( &dsp_ip->dsp_name, (char *)cp );
d3515 3
a3517 3
	if (dsp_get_data(dsp_ip, ip, ep, mat, dbip)) {
		IMPORT_FAIL("unable to read DSP data");
	}
d3519 1
a3519 1
	return 0; /* OK */
d3529 4
a3532 4
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d3534 3
a3536 3
	struct rt_dsp_internal	*dsp_ip;
	unsigned long		name_len;
	unsigned char		*cp;
d3538 4
a3541 4
	RT_CK_DB_INTERNAL(ip);
	if (ip->idb_type != ID_DSP )  return(-1);
	dsp_ip = (struct rt_dsp_internal *)ip->idb_ptr;
	RT_DSP_CK_MAGIC(dsp_ip);
d3543 1
a3543 1
	name_len = bu_vls_strlen(&dsp_ip->dsp_name) + 1;
d3545 4
a3548 4
	BU_CK_EXTERNAL(ep);
	ep->ext_nbytes = 139 + name_len;
	ep->ext_buf = bu_malloc( ep->ext_nbytes, "dsp external");
	cp = (unsigned char *)ep->ext_buf;
d3550 1
a3550 1
	memset(ep->ext_buf, 0, ep->ext_nbytes);
d3553 3
a3555 3
	/* Now we fill the buffer with the data, making sure everything is
	 * converted to Big-Endian IEEE
	 */
d3557 2
a3558 2
	bu_plong( cp, (unsigned long)dsp_ip->dsp_xcnt );
	cp += SIZEOF_NETWORK_LONG;
d3560 2
a3561 2
	bu_plong( cp, (unsigned long)dsp_ip->dsp_ycnt );
	cp += SIZEOF_NETWORK_LONG;
d3563 5
a3567 5
	/* Since libwdb users may want to operate in units other
	 * than mm, we offer the opportunity to scale the solid
	 * (to get it into mm) on the way out.
	 */
	dsp_ip->dsp_stom[15] *= local2mm;
d3569 2
a3570 2
	htond(cp, (unsigned char *)dsp_ip->dsp_stom, 16);
	cp += SIZEOF_NETWORK_DOUBLE * 16;
d3572 2
a3573 2
	bu_pshort( cp, (int)dsp_ip->dsp_smooth );
	cp += SIZEOF_NETWORK_SHORT;
d3575 2
a3576 2
	*cp = dsp_ip->dsp_datasrc;
	cp++;
d3578 1
a3578 1
	strncpy((char *)cp, bu_vls_addr(&dsp_ip->dsp_name), name_len);
d3580 1
a3580 1
	return 0; /* OK */
d3595 8
a3602 8
struct bu_vls		*str;
const struct rt_db_internal *ip;
int			verbose;
double			mm2local;
{
	register struct rt_dsp_internal	*dsp_ip =
		(struct rt_dsp_internal *)ip->idb_ptr;
	struct bu_vls vls;
d3605 2
a3606 2
	if (RT_G_DEBUG & DEBUG_HF)
		bu_log("rt_dsp_describe()\n");
d3608 1
a3608 1
	RT_DSP_CK_MAGIC(dsp_ip);
d3610 2
a3611 2
	dsp_print_v5(&vls, dsp_ip);
	bu_vls_vlscat( str, &vls );
d3613 1
a3613 1
	if (BU_VLS_IS_INITIALIZED( &vls )) bu_vls_free( &vls );
d3615 1
a3615 1
	return(0);
d3625 1
a3625 1
struct rt_db_internal	*ip;
d3627 1
a3627 1
	register struct rt_dsp_internal	*dsp_ip;
d3629 2
a3630 2
	if (RT_G_DEBUG & DEBUG_HF)
		bu_log("rt_dsp_ifree()\n");
d3632 3
a3634 3
	RT_CK_DB_INTERNAL(ip);
	dsp_ip = (struct rt_dsp_internal *)ip->idb_ptr;
	RT_DSP_CK_MAGIC(dsp_ip);
d3636 4
a3639 4
	if (dsp_ip->dsp_mp) {
		BU_CK_MAPPED_FILE(dsp_ip->dsp_mp);
		bu_close_mapped_file(dsp_ip->dsp_mp);
	}
d3641 3
a3643 3
	if (dsp_ip->dsp_bip) {
		rt_binunif_ifree( (struct rt_db_internal *) dsp_ip->dsp_bip);
	}
d3645 2
a3646 2
	dsp_ip->magic = 0;			/* sanity */
	dsp_ip->dsp_mp = (struct bu_mapped_file *)0;
d3648 4
a3651 4
	if (BU_VLS_IS_INITIALIZED(&dsp_ip->dsp_name)) 
		bu_vls_free(  &dsp_ip->dsp_name );
	else
		bu_log("Freeing Bogus DSP, VLS string not initialized\n");
d3654 2
a3655 2
	bu_free( (char *)dsp_ip, "dsp ifree" );
	ip->idb_ptr = GENPTR_NULL;	/* sanity */
@


1.86
log
@Added early-out for situation where a_onehit is set to non-zero
@
text
@d42 1
a42 1
static const char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.85 2001/09/07 01:00:05 butler Exp $ (BRL)";
a61 2
int old_way = 0;

a174 4
    struct seg		*sp;		/* the current segment being filled */
    short		sp_is_valid;	/* boolean: sp allocated, inhit set */
    short		sp_is_done;	/* boolean: sp has (outhit) content */

d1107 1
a2324 3
	isect.sp = (struct seg *)NULL;
	isect.sp_is_valid = 0;
	isect.sp_is_done = 0;
@


1.85
log
@bug fix:  needed to sort order of triangle hits
@
text
@d42 1
a42 1
static const char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.84 2001/09/06 23:20:07 butler Exp $ (BRL)";
d175 2
a179 1
    jmp_buf		env;		/* for setjmp()/longjmp() */
d1008 4
d1016 1
a1016 1
static void
d1050 1
a1050 1
	    return;
d1109 2
d1532 3
a1534 1
 *
d1536 1
a1536 1
static void
d1749 3
a1751 1
		ADD_SEG(isect, hitp, &hits[i], bbmin, bbmax, 255, 255, 255);
d1784 1
a1784 1

d1932 1
a1932 1
static void 
d1938 3
d1942 1
a1942 1
static void
d2059 1
a2059 1
	isect_ray_dsp_bb(isect, *p);
d2088 2
d2098 4
d2103 1
a2103 1
static void 
d2144 1
a2144 1
	return;
a2203 2
	ADD_SEG(isect, &seg_in, &seg_out, bbmin, bbmax, 0, 255, 255);

d2205 1
a2205 1
	return;
d2214 1
a2214 1
	recurse_dsp_bb(isect, dsp_bb, minpt, maxpt, bbmin, bbmax);
d2221 1
a2223 1
	return;
d2273 1
a2273 1
	ADD_SEG(isect, &in_hit, &out_hit, bbmin, bbmax, 255, 255, 0);
d2275 2
a2316 10
	/* if we run into an error, we can jump here and re-start the
	 * ray with debugging turned on.
	 */
	if (setjmp(isect.env)) {
		if (RT_G_DEBUG & DEBUG_HF)
			bu_bomb("");

		rt_g.debug |= DEBUG_HF; 
	}

d2364 1
a2364 1
	isect_ray_dsp_bb(&isect, isect.dsp->layer[isect.dsp->layers-1].p);
@


1.84
log
@Misc fixes
@
text
@d42 1
a42 1
static const char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.83 2001/09/04 17:27:24 butler Exp $ (BRL)";
d60 2
d413 2
a414 1
	      int hitflags, int style)
d455 12
a466 10
    pdv_3cont(fp, p2);
    pdv_3cont(fp, p4);
    if (!style) pl_color(fp, 96, 96, 96);

    pdv_3cont(fp, p1);

    if (!style) pl_color(fp, 255, 255, 255);
    pdv_3cont(fp, p3);
    pdv_3cont(fp, p4);

d969 39
a1020 5
    struct dsp_specific *dsp = isect->dsp;
    fastf_t *stom = &dsp->dsp_i.dsp_stom[0];
    FILE *fp;
    char fname[32];
    static int segnum = 0;
d1022 1
d1024 1
a1024 1
    struct bound_rpp rpp;
d1028 22
a1055 7
    /* XXX */

    if (seg->seg_in.hit_surfno < 0 || seg->seg_in.hit_surfno > ZTOP) {
	bu_log("%s:%d bogus surfno %d  dist:%g\n", __FILE__, __LINE__,
	       seg->seg_in.hit_surfno, seg->seg_in.hit_dist);
	bu_bomb("");
    }
d1061 1
a1061 6
    /* XXX */
    if (seg->seg_out.hit_surfno < 0 || seg->seg_out.hit_surfno > ZTOP) {
	bu_log("%s:%d bogus surfno %d  dist:%g\n", __FILE__, __LINE__,
	       seg->seg_in.hit_surfno, seg->seg_out.hit_dist);
	bu_bomb("");
    }
d1081 3
d1101 3
a1103 23

    if (RT_G_DEBUG & DEBUG_HF) {
	/* plot the bounding box and the seg */
	sprintf(fname, "dsp_seg%04d.pl", segnum++);

	if ((fp=fopen(fname, "w")) != (FILE *)NULL) {
	    bu_log("plotting %s\n", fname);

	    MAT4X3PNT(rpp.min, stom, bbmin);
	    MAT4X3PNT(rpp.max, stom, bbmax);
	    plot_rpp(fp, &rpp, r/2, g/2, b/2);

	    /* re-use the rpp for the points for the segment */
	    MAT4X3PNT(rpp.min, stom, in_hit->hit_point);
	    MAT4X3PNT(rpp.max, stom, out_hit->hit_point);

	    pl_color(fp, r, g, b);
	    pdv_3line(fp, rpp.min, rpp.max);

	    fclose(fp);
	}

    }
a1105 3



a1122 1

a1134 1

d1184 1
a1184 1
	pl_color(fp, 50, 50, 128);
a1186 3

	pl_color(fp, 75, 75, 128);

a1187 3

	pl_color(fp, 50, 50, 128);

d1190 5
a1194 2
	pl_color(fp, 255, 255, 255);
	MAT4X3PNT(p2, stom, P);	pdv_3line(fp, p1, p2);
d1666 17
a1687 1

d1707 1
d2195 3
a2197 1
#if 0
a2203 2
#else
	recurse_dsp_bb(isect, dsp_bb, minpt, maxpt, bbmin, bbmax);
@


1.83
log
@Bresenham voxel traversal added
@
text
@d42 1
a42 1
static const char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.82 2001/08/29 23:06:57 butler Exp $ (BRL)";
d1104 14
a1118 4
	bu_log("isect_ray_triangle...\n  A %g %g %g\n  B %g %g %g\n  C %g %g %g\n",
	       V3ARGS(A),
	       V3ARGS(B),
	       V3ARGS(C));
d1513 1
d1516 1
d1572 2
a1573 1
	/* XXX need to fill in rest of hit struct ?*/
d1595 2
a1596 1
	/* XXX need to fill in rest of hit struct ? */
d1620 1
d1636 2
a1645 25
    /* XXX if we hit both triangles, then the normals must oppose along
     * the ray for them to both count
     */
    if ( (hitf & 2)  && (hitf & 4) ) {
	double dot1, dot2;

	dot1 = VDOT(hits[1].hit_normal, isect->r.r_dir);
	dot2 = VDOT(hits[2].hit_normal, isect->r.r_dir);


	dlog("double-triangle hit.  Checking for proper normals\n");

	/* BTW: This non-toleranced check works only because
	 * isect_ray_triangle does the tolerancing for us
	 */
	if (dot1 > 0 && dot2 > 0) {
	    /* pick the furthest one */
	    bu_log("%s:%d Write code here\n", __FILE__, __LINE__);
	    bu_bomb("");
	} else if (dot1 < 0 && dot2 < 0) {
	    /* pick the closest one */
	    bu_log("%s:%d Write code here\n", __FILE__, __LINE__);
	    bu_bomb("");
	}
    }
d1647 2
a1649 3


    if (RT_G_DEBUG & DEBUG_HF) {
d1666 1
a1666 3
    /* XXX check to see if we have an odd number of hits 
     * BEFORE we start assembling
     */
a1667 1
    /* fill out the segment structures */
d1672 19
d1697 1
a1697 1

d1701 4
d1710 1
d1712 1
a1712 1
	}
d1715 1
a1715 1
    if (hitp) {
d1717 1
a1717 1

@


1.82
log
@Basic functioning DSP again
@
text
@d42 1
a42 1
static const char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.81 2001/08/11 13:16:50 butler Exp $ (BRL)";
d75 11
a85 10
	struct dsp_rpp	dspb_rpp;	/* our bounding box */
	/*
	 * the next two elements indicate the number and locations of
	 * sub-bounding rpps.
	 *
	 * dsp_b_ch_dim is typically DIM_BB_CHILDREN,DIM_BB_CHILDREN
	 * except for "border" areas of the array
	 */
	int			dspb_ch_dim[2];	/* dimensions of children[] */
	struct dsp_bb		*dspb_children[NUM_BB_CHILDREN];
d87 2
a88 1

d174 2
a175 2
    int			sp_is_valid;	/* boolean: sp allocated & (inhit) set */
    int			sp_is_done;	/* boolean: sp has (outhit) content */
d275 2
d290 4
a293 2
	VMOVE(pt, dsp_bb->dspb_rpp.dsp_min); /* int->float conversion */
	MAT4X3PNT(rpp.min, stom, pt);
d295 2
a296 2
	VMOVE(pt, dsp_bb->dspb_rpp.dsp_max); /* int->float conversion */
	MAT4X3PNT(rpp.max, stom, pt);
d298 2
a299 2
	bu_log("dsp_bb (%g %g %g)  (%g %g %g)\n",
	     V3ARGS(rpp.min), V3ARGS(rpp.max) );
d301 1
a301 1
	plot_rpp(fp, &rpp, r, g, b);
d303 27
d359 2
a360 1
			bu_log("%s:%d\n", __FILE__, __LINE__);
d370 1
a370 1
		if (rt_g.debug & DEBUG_HF)
d384 1
a384 1
				if (rt_g.debug & DEBUG_HF)
d428 1
a470 1
		bu_log("\t%d outseg %g %g %g\n", i, V3ARGS(p1));
a475 1
		bu_log("\t%d inseg %g %g %g\n", i, V3ARGS(p1));
d644 1
a644 1
		if (rt_g.debug & DEBUG_HF)
d658 1
a658 1
	if (rt_g.debug & DEBUG_HF)
d688 1
a688 1
			if (rt_g.debug & DEBUG_HF)
d723 1
d740 1
a740 1
	if (rt_g.debug & DEBUG_HF)
d771 1
a771 1
		if (rt_g.debug & DEBUG_HF)
d787 1
d796 1
a796 1
				dlog("\tcell %d,%d  (%d,%d-%d,%d)\n", x, y, 
d818 1
a818 1
						if (rt_g.debug & DEBUG_HF) 
d838 1
a838 1
	if (rt_g.debug & DEBUG_HF) {
d964 2
a965 1

d973 2
a974 1
	int r, int g, int b)/* ... this is strictly for debug plot purposes */
d986 2
d991 1
d995 1
d1015 16
d1049 1
a1049 1
    if (rt_g.debug & DEBUG_HF) {
d1095 7
a1101 4
    point_t P;
    vect_t AB, AC;
    plane_t N;	/* Normal for plane of triangle */
    double NdotDir, alpha, beta, u0, u1, u2, v0, v1, v2;
d1103 1
a1103 1
    dlog("isect_ray_triangle\n");
d1105 5
a1115 1
    VMOVE(hitp->hit_normal, N);
d1127 1
a1127 1
    hitp->hit_dist = (N[H]-VDOT(N, isect->r.r_pt)) / NdotDir;
d1129 1
a1129 2
    VJOIN1(P, isect->r.r_pt, hitp->hit_dist, isect->r.r_dir);
    VMOVE(hitp->hit_point, P);
d1131 4
a1134 2
    if (rt_g.debug & DEBUG_HF) {
	vect_t tmp;
d1136 1
d1138 15
a1152 1
	MAT4X3PNT(tmp, stom, hitp->hit_point);
d1154 10
a1163 1
	bu_log("\tdist:%g plane point: %g %g %g\n", hitp->hit_dist, V3ARGS(tmp));
d1197 2
a1198 2
    u0 = P[0] - A[0];	/* delta X */
    v0 = P[1] - A[1];	/* delta Y */
d1200 16
a1215 2
    u1 = AB[0];    /*   u1 = B[0] - A[0]; always 0 or 1 */
    u2 = AC[0];    /*	u2 = C[0] - A[0]; always 0 or 1 */
d1217 5
a1221 2
    v1 = AB[1];    /* v1 = B[1] - A[1]; always 0 or 1 */
    v2 = AC[1];    /* v2 = C[1] - A[1]; always 0 or 1 */
d1223 2
a1224 6
    if ( u1 == 0 ) { 
	beta = u0/u2;
	if ( 0.0 <= beta && beta <= 1.0 ) {
	    alpha = (v0 - beta * v2) / v1;
	} else 
	    alpha = 0;
d1226 1
a1226 5
	beta = (v0 * u1 - u0 * v1) / (v2 * u1 - u2 * v1);
	if ( 0.0 <= beta && beta <= 1.0 ) {
	    alpha = (u0 - beta * u2)/ u1;
	} else
	    alpha = 0;
d1233 12
a1244 2
    if (alpha >= 0.0 && beta >= 0.0 && (alpha+beta) < 1.0)
	return 1;
d1246 4
a1249 1
    return 0;
d1268 3
a1270 1
	if (rt_g.debug & DEBUG_HF) {
d1289 1
a1289 1
	if (rt_g.debug & DEBUG_HF)
d1336 1
a1336 1
	    if (rt_g.debug & DEBUG_HF)
d1348 1
a1348 1
	if (rt_g.debug & DEBUG_HF)
d1504 1
d1508 1
d1532 1
a1532 1
    if (rt_g.debug & DEBUG_HF) {
d1560 1
a1560 1
	/* XXX need to fill in rest of hit struct */
d1562 6
a1567 1
	dlog("hit ray/bb min\n");
d1582 1
a1582 1
	/* XXX need to fill in rest of hit struct */
d1584 6
a1589 1
	dlog("hit ray/bb max\n");
d1607 1
a1607 1
	dlog("\t hit triangle 1 (alpha: %g beta:%g alpha+beta: %g)\n",
d1610 1
a1610 1
	dlog("\tmiss triangle 1 (alpha: %g beta:%g a+b: %g) cond:%d\n",
d1622 1
a1622 1
	dlog("\t hit triangle 2 (alpha: %g beta:%g alpha+beta: %g)\n",
d1625 1
a1625 1
	dlog("\tmiss triangle 2 (alpha: %g beta:%g alpha+beta: %g) cond:%d\n",
d1629 9
d1639 20
a1658 1
    if (rt_g.debug & DEBUG_HF) {
d1660 13
d1675 4
d1684 2
a1685 2
		/* create seg with hits[i].hit_point); as in point */
		if (rt_g.debug & DEBUG_HF) {
a1688 1
		    bu_log("out-hit at dist %g\n", hits[i].hit_dist);
d1691 1
a1691 1
		add_seg(isect, hitp, &hits[i], bbmin, bbmax, 255, 255, 255);
d1694 2
a1695 2
		/* finish seg with hits[i].hit_point); as out point */
		if (rt_g.debug & DEBUG_HF) {
d1756 2
a1757 1
    register const fastf_t *invdir = isect->inv_dir;	/* inverses of rp->r_dir[] */
d1867 125
d1993 28
a2031 1
    int i;
d2034 6
a2039 1
    double min_z = dsp_bb->dspb_rpp.dsp_min[Z];
d2041 6
a2046 1
    if (rt_g.debug & DEBUG_HF) {
d2048 1
d2051 1
a2051 1
	       V3ARGS(dsp_bb->dspb_rpp.dsp_min));
d2054 2
d2062 2
a2063 1
    if (!dsp_in_rpp(isect, bbmin, bbmax) ) {
d2065 5
d2075 18
a2095 2
    VJOIN1(minpt, isect->r.r_pt, isect->r.r_min, isect->r.r_dir);
    VJOIN1(maxpt, isect->r.r_pt, isect->r.r_max, isect->r.r_dir);
d2098 10
a2107 1
	struct hit in_hit, out_hit;
d2109 1
a2109 7
	in_hit.hit_dist = isect->r.r_min;
	VMOVE(in_hit.hit_point, minpt);
	VMOVE(in_hit.hit_normal, dsp_pl[isect->dmin]);
	/* hit_priv   */
	/* hit_private */
	in_hit.hit_surfno = isect->dmin;
	/* hit_rayp */
d2111 2
a2112 3
	out_hit.hit_dist = isect->r.r_max;
	VMOVE(out_hit.hit_point, minpt);
	VMOVE(out_hit.hit_normal, dsp_pl[isect->dmax]);
d2115 1
a2115 1
	out_hit.hit_surfno = isect->dmax;
d2118 1
a2118 1
	if (rt_g.debug & DEBUG_HF) {
d2120 2
a2121 2
	    VMOVE(in_hit.hit_point, minpt);
	    VMOVE(out_hit.hit_point, maxpt);
d2130 1
a2130 1
	add_seg(isect, &in_hit, &out_hit, bbmin, bbmax, 0, 255, 255);
d2141 2
d2144 1
a2144 1
	i = dsp_bb->dspb_ch_dim[0] * dsp_bb->dspb_ch_dim[1] - 1;
d2148 3
d2193 1
d2198 1
d2201 1
a2201 1
	add_seg(isect, &in_hit, &out_hit, bbmin, bbmax, 255, 255, 0);
d2266 1
a2270 1
	isect.sp = (struct seg *)NULL;
d2273 1
a2273 1
	if (rt_g.debug & DEBUG_HF) {
d2311 1
a2311 1
		if (rt_g.debug & DEBUG_HF) {
d2525 2
@


1.81
log
@Misc compiler warning changes, massive changes to DSP
@
text
@d10 1
a10 2
 *  surfaces are numbered -1 .. -6 where:
 *  
d12 1
a12 1
 *	     Plane #	Name  plane dist     BBSURF #
d14 6
a19 6
 *		0	XMIN (dist = 0)		-1
 *		1	XMAX (dist = xsiz)	-2
 *		2	YMIN (dist = 0)		-3
 *		3	YMAX (dist = ysiz)	-4
 *		4	ZMIN (dist = 0)		-5
 *		5	ZMAX (dsp_max)		-6
d21 2
a22 1
 *		6	ZMID (dsp_min)		-7	(upward normal)
d24 1
a24 1
 *  if the "struct hit" surfno surface is positive, then 
d26 1
a26 5
 *	hit_vpriv[Z] is 0 if this was an in-hit.  1 if an out-hit
 *	surfno is either  TRI1 or TRI2  (XXX TRI3/TRI4?)
 *	
 *	The top surfaces of the dsp are numbered 0 .. wid*len*2
 *	(2 triangles per ``cell'')
a27 1
 *	The BBSURF() macro maps plane # into surface number (or vice versa)
d42 1
a42 1
static const char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.80 2001/05/17 20:05:24 morrison Exp $ (BRL)";
a109 1
#define BBSURF(_s) (-((_s)+1))	/* bounding box surface */
d118 1
a118 13

#define XMIN_SURF -1
#define XMAX_SURF -2
#define YMIN_SURF -3
#define YMAX_SURF -4
#define ZMIN_SURF -5
#define ZMAX_SURF -6
#define ZMID_SURF -7

#define TRI1	10
#define TRI2	20
#define TRI3	30
#define TRI4	40
d292 1
a292 1
	dlog("dsp_bb (%g %g %g)  (%g %g %g)\n",
d298 1
d335 1
d340 1
a340 1

d349 1
d357 1
d362 1
d373 2
d377 1
a377 1
	      int hitnum, int style)
d381 2
a382 1
    static int n = 0;
d384 1
a384 1
    point_t p1, p2;
d386 1
d396 1
a396 1
	sprintf(buf, "dsp_cell%04d.pl", n++);
d398 1
a398 1
	sprintf(buf, "DSP_isect_cell%04d.pl", n++);
d403 2
d407 1
a407 2

    plot_dsp_bb(fp, dsp_bb, isect->dsp, 255, 255, 255);
d410 1
d412 14
a425 2
    MAT4X3PNT(p2, stom, D);
    pdv_3line(fp, p1, p2);
d430 15
a444 10
    dlog("plotting %d hit points\n", hitnum);
    for (i = 0 ; i < hitnum && i < 3 ; i++ ) {
	pl_color(fp, colors[i][0], colors[i][1], colors[i][2]);

	MAT4X3PNT(p1, stom, hitlist[i].hit_point);
	MAT4X3PNT(p2, stom, hitlist[i+1].hit_point);
	pdv_3line(fp, p1, p2);

	if (rt_g.debug & DEBUG_HF)
	    bu_log(" hit point %g %g %g\n", V3ARGS(p1));
d802 1
d808 1
d931 7
a938 10

#if 0

/*
 *  Intersect the ray with the real bounding box of the dsp solid.
 */
static int

isect_ray_bbox(isect)
register struct isect_stuff *isect;
d940 8
a947 4
	register double NdotD = -42.0;
	register double NdotPt;
	double dist;
	register int plane;
d949 1
a949 3
	if (rt_g.debug & DEBUG_HF)
		bu_log("isect_ray_bbox(tol dist:%g perp:%g para:%g)\n",
			isect->tol->dist, isect->tol->perp, isect->tol->para);
d951 9
a959 2
	isect->bbox.in_dist = - (isect->bbox.out_dist = MAX_FASTF);
	isect->bbox.in_surf = isect->bbox.out_surf = -1;
a960 4
	/* intersect the ray with the bounding box */
	for (plane=0 ; plane < BBOX_PLANES ; plane++) {
		NdotD = VDOT(dsp_pl[plane], isect->r.r_dir);
		NdotPt = VDOT(dsp_pl[plane], isect->r.r_pt);
d962 9
a970 2
		if (rt_g.debug & DEBUG_HF)
			bu_log("\nplane %d NdotD:%g\n", plane, NdotD);
d972 1
a972 2
		/* if N/ray vectors are perp, ray misses plane */
		if (plane != ZMID && fabs(NdotD) < isect->tol->perp) {
d974 7
a980 37
			if ( (NdotPt - isect->dsp->dsp_pl_dist[plane]) >
			    SQRT_SMALL_FASTF ) {
				if (rt_g.debug & DEBUG_HF)
					bu_log("ray parallel and above bbox plane %d\n", plane);

				return 0; /* MISS */
			}
		}
		dist = - ( NdotPt - isect->dsp->dsp_pl_dist[plane] ) / NdotD;


		if (rt_g.debug & DEBUG_HF)
			bu_log("plane[%d](%g %g %g %g) dot:%g ss_dist:%g\n",
				plane, V3ARGS(dsp_pl[plane]),
				isect->dsp->dsp_pl_dist[plane],
				NdotD, dist);

		if ( plane == ZMID) /* dsp_min elevation not valid bbox limit */
			continue;

		if (NdotD < 0.0) { 
			/* ray dir and normal oppose,  entering */
			if (dist > isect->bbox.in_dist) {
				dlog("new in dist %g\n", dist);
				isect->bbox.in_dist = dist;
				isect->bbox.in_surf = plane;
			}
		} else if (NdotD > 0.0) {
			/* leaving */
			if (dist < isect->bbox.out_dist) {
				dlog("new out dist %g\n", dist);
				isect->bbox.out_dist = dist;
				isect->bbox.out_surf = plane;
			}
		} else {
			dlog("NdotD == 0.0\n");
		}
d982 4
a986 20
	if (rt_g.debug & DEBUG_HF) {
		vect_t pt, t;
		VJOIN1(t, isect->r.r_pt, isect->bbox.in_dist, isect->r.r_dir);
		MAT4X3PNT(pt, isect->dsp->dsp_i.dsp_stom, t);
		bu_log("solid rpp in  surf[%d] ss_dist:%g (%g %g %g)\n",
			isect->bbox.in_surf, isect->bbox.in_dist, V3ARGS(pt));
		VJOIN1(t, isect->r.r_pt, isect->bbox.out_dist, isect->r.r_dir);
		MAT4X3PNT(pt, isect->dsp->dsp_i.dsp_stom, t);
		bu_log("solid rpp out surf[%d] ss_dist:%g  (%g %g %g)\n",
			isect->bbox.out_surf, isect->bbox.out_dist, 
			V3ARGS(pt));
	}

	/* validate */
	if (isect->bbox.in_dist >= isect->bbox.out_dist ||
	    isect->bbox.out_dist >= MAX_FASTF ) {
		dlog("apparent miss, in dist: %g out dist:%g\n",
			isect->bbox.in_dist, isect->bbox.out_dist);
		return 0; /* MISS */
	}
d988 3
a990 3
	/* copmute "minbox" the bounding box of the rpp under the lowest
	 * displacement height
	 */
d992 3
a994 18
	isect->minbox.in_dist = isect->bbox.in_dist;
	isect->minbox.in_surf = isect->bbox.in_surf;
	isect->minbox.out_dist = isect->bbox.out_dist;
	isect->minbox.out_surf = isect->bbox.out_surf;

	if (NdotD < 0.0) {
		/* entering */
		if (dist > isect->bbox.in_dist) {
			isect->minbox.in_dist = dist;
			isect->minbox.in_surf = 6;
		}
	} else { /*  (NdotD > 0.0) */
		/* leaving */
		if (dist < isect->bbox.out_dist) {
			isect->minbox.out_dist = dist;
			isect->minbox.out_surf = 6;
		}
	}
d996 2
a997 3
	if (rt_g.debug & DEBUG_HF) {
		vect_t pt, t;
		VJOIN1(t, isect->r.r_pt, isect->minbox.in_dist, isect->r.r_dir);
d999 3
a1001 1
		MAT4X3PNT(pt, isect->dsp->dsp_i.dsp_stom, t);
d1003 3
a1005 2
		bu_log("solid minbox rpp in  surf[%d] ss_dist:%g (%g %g %g)\n",
			isect->minbox.in_surf, isect->minbox.in_dist, V3ARGS(pt));
d1007 2
a1008 2
		VJOIN1(t, isect->r.r_pt, isect->minbox.out_dist, isect->r.r_dir);
		MAT4X3PNT(pt, isect->dsp->dsp_i.dsp_stom, t);
d1010 1
a1010 2
		bu_log("solid minbox rpp out surf[%d] ss_dist:%g (%g %g %g)\n",
			isect->minbox.out_surf, isect->minbox.out_dist, V3ARGS(pt));
d1013 1
a1013 1
	return 1;
d1015 2
a1016 1
#endif
d1034 1
a1034 2
		   double *dist,
		   point_t P, 
d1038 1
d1043 2
d1051 1
a1060 1
    *dist = (N[H]+VDOT(N, isect->r.r_pt)) / NdotDir; /* dist to plane icept */
d1062 11
a1072 1
    VJOIN1(P, isect->r.r_pt, *dist, isect->r.r_dir);
d1074 2
d1108 2
a1109 2
    u0 = P[0] - A[0];
    v0 = P[1] = A[1];
d1111 2
a1112 2
    u1 = AB[0];    /* u1 = B[0] - A[0]; */
    u2 = AC[0];    /*	u2 = C[0] - A[0]; */
d1114 2
a1115 2
    v1 = AB[1];    /* v1 = B[1] - A[1]; */
    v2 = AC[1];    /* v2 = C[1] - A[1]; */
d1117 1
a1117 1
    if ( u1 == 0 ) {
d1157 8
d1235 1
a1235 1
	    if (rt_g.debug & DEBUG_HF)
d1237 1
d1301 1
a1301 1
check_bbpt_hit_elev(int i,
d1312 1
d1316 7
a1322 2
	slope = A[Z] - B[Z];
	delta = P[X] - A[X];
d1326 8
a1333 3
	slope = D[Z] - C[Z];
	delta = P[X] - C[X];
	origin = C[Z];
d1336 7
a1342 2
	slope = C[Z] - A[Z];
	delta = P[Y] - A[Y];
d1346 8
a1353 3
	slope = D[Z] - B[Z];
	delta = P[Y] - B[Y];
	origin = B[Z];
d1356 1
d1360 1
a1384 1
    double dist;
d1386 6
a1391 2
    struct hit hitlist[4];
    int hitnum = 0;
d1395 1
a1395 4
    /* first order of business is to discard any "fake" hits on the 
     * bounding box
     *
     * assign the values for the corner points
a1418 1
	bu_log("plotting cell top\n");
d1421 2
a1422 2
	hitlist[hitnum].hit_dist = isect->r.r_min;
	VMOVE(hitlist[hitnum].hit_point, p1);
d1425 2
d1428 1
a1428 4
	hitlist[hitnum].hit_dist = isect->r.r_max;
	VMOVE(hitlist[hitnum].hit_point, p2);

	plot_cell_top(isect, dsp_bb, A, D, hitlist, 2, 0);
d1433 3
d1438 7
a1444 2
	hitlist[hitnum].hit_dist = isect->r.r_min;
	VMOVE(hitlist[hitnum].hit_point, P);
d1446 2
a1447 1
	hitnum++;
d1449 1
a1449 1
	dlog("ray/bb min is a miss\n");
d1455 7
a1461 2
	hitlist[hitnum].hit_dist = isect->r.r_max;
	VMOVE(hitlist[hitnum].hit_point, P);
d1463 2
a1464 1
	hitnum++;
d1466 1
a1466 1
	dlog("ray/bb max is a miss\n");
d1473 1
a1473 1
    if (isect_ray_triangle(isect, A, B, C, &dist, P, ab_first) > 0.0) {
a1474 5
	hitlist[hitnum].hit_dist = dist;
	VMOVE(hitlist[hitnum].hit_point, P);
	/* XXX need to fill in rest of hit struct */
	hitnum++;
	dlog("hit triangle 1\n");
d1476 11
d1488 1
a1488 1
    if (isect_ray_triangle(isect, D, C, B, &dist, P, ab_second) > 0.0) {
d1490 12
a1501 5
	hitlist[hitnum].hit_dist = dist;
	VMOVE(hitlist[hitnum].hit_point, P);
	/* XXX need to fill in rest of hit struct */
	hitnum++;
	dlog("hit triangle 2\n");
d1506 43
a1548 2
	bu_log("plotting cell top\n");
	plot_cell_top(isect, dsp_bb, A, D, hitlist, hitnum, 1);
a1549 1
    dlog("%d hits on cell top\n", hitnum);
a1698 64
static void
add_seg(struct isect_stuff *isect,
	struct hit *in_hit,
	struct hit *out_hit,
	const point_t bbmin,/* The bounding box of what you are adding ... */
	const point_t bbmax,
	int r, int g, int b)/* ... this is strictly for debug plot purposes */

{
    struct dsp_specific *dsp = isect->dsp;
    fastf_t *stom = &dsp->dsp_i.dsp_stom[0];
    FILE *fp;
    char fname[32];
    static int segnum = 0;
    struct seg *seg;
    struct seg *seg_p;
    struct bound_rpp rpp;


    RT_GET_SEG(seg, isect->ap->a_resource);

    seg->seg_in = *in_hit; /* struct copy */
    seg->seg_in.hit_magic = RT_HIT_MAGIC;

    seg->seg_out = *out_hit; /* struct copy */
    seg->seg_out.hit_magic = RT_HIT_MAGIC;

    seg->seg_stp = isect->stp;

    /* insert the segment in the list by in-hit distance */
    for ( BU_LIST_FOR(seg_p, seg, &isect->seglist) ) {
	fp = (FILE *)NULL;
	if (seg->seg_in.hit_dist < seg_p->seg_in.hit_dist) {
	    /* found the spot for this one */
	    BU_LIST_INSERT(&(seg_p->l), &seg->l);
	    goto done;
	}
    }
    /* this one goes in the end of the list */
    BU_LIST_INSERT(&isect->seglist, &seg->l);
 done:


    if (rt_g.debug & DEBUG_HF) {
	/* plot the bounding box and the seg */
	sprintf(fname, "dsp_seg%04d.pl", segnum++);

	if ((fp=fopen(fname, "w")) != (FILE *)NULL) {
	    MAT4X3PNT(rpp.min, stom, bbmin);
	    MAT4X3PNT(rpp.max, stom, bbmax);
	    plot_rpp(fp, &rpp, r/2, g/2, b/2);

	    /* re-use the rpp for the points for the segment */
	    MAT4X3PNT(rpp.min, stom, in_hit->hit_point);
	    MAT4X3PNT(rpp.max, stom, out_hit->hit_point);

	    pl_color(fp, r, g, b);
	    pdv_3line(fp, rpp.min, rpp.max);

	    fclose(fp);
	}

    }
}
a1718 37

#if 0
	{
	    point_t p1;
	    double dist;
	    struct dsp_bb *bb;
	    FILE *fp;
	    point_t p2;
	    double *stom;
	    static int filenum=0;
	    char fname[32];

	    /* find a distance for the ray */
	    bb = isect->dsp->layer[isect->dsp->layers-1].p;
	    VSUB2(p1, bb->dspb_rpp.dsp_min, bb->dspb_rpp.dsp_max);
	    dist=MAGNITUDE(p1);

	    sprintf(fname, "dsp_miss%04d.pl", filenum++);
	    if ( (fp=fopen(fname, "w")) != (FILE *)NULL) {

		dlog("plotting \"%s\" ", fname);
		plot_dsp_bb(fp, dsp_bb, isect->dsp, 0, 255, 0);

		stom = &isect->dsp->dsp_i.dsp_stom[0];

		VJOIN1(p2, isect->r.r_pt, dist, isect->r.r_dir);
		MAT4X3PNT(p1, stom, p2);
		MAT4X3PNT(p2, stom, isect->r.r_pt);

		pl_color(fp, 255, 100, 255);
		pdv_3line(fp, p1, p2);
		fclose(fp);
	    }
	}
#endif


d1745 1
a1745 1
	/* hit_normal */
d1748 1
a1748 1
	in_hit.hit_surfno = BBSURF(isect->dmin);
d1752 6
a1757 1
	out_hit.hit_surfno = BBSURF(isect->dmax);
a1808 11
	if (rt_g.debug & DEBUG_HF) {
	    FILE *fp;
	    static int i;
	    char buff[32];

	    sprintf(buff, "dsp_cell_%03x", i++);
	    if ( (fp = fopen(buff, "w")) != (FILE *)NULL) {
		plot_dsp_bb(fp, dsp_bb, isect->dsp, 170, 170, 170);
		fclose(fp);
	    }
	}
d1818 1
d1827 1
a1827 1
	in_hit.hit_surfno = BBSURF(isect->dmin);
d1831 1
a1831 1
	out_hit.hit_surfno = BBSURF(isect->dmax);
a1907 4
	    FILE *fp;
	    char fname[32];
	    static int num=0;

a1919 11

	    sprintf(fname, "shot%04d.pl", num++);
	    if ( (fp=fopen(fname, "w")) != (FILE *)NULL) {
		point_t pt;
		/* plot the uppermost dsp bounding box */
		VJOIN1(pt, rp->r_pt, 10000.0, rp->r_dir);
		pl_color(fp, 255, 0, 255);
		pdv_3line(fp, rp->r_pt, pt);
		
		fclose(fp);
	    }
d2092 10
a2101 10
	vect_t N, t, tmp, A, B, C, D, N_orig;
	char buf[32];
	struct dsp_specific *dsp = (struct dsp_specific *)stp->st_specific;
	vect_t Anorm, Bnorm, Dnorm, Cnorm, ABnorm, CDnorm;
	double Xfrac, Yfrac;
	int x, y;
	point_t pt;
	double dot;
	double len;
	FILE *fd = (FILE *)NULL;
d2104 11
a2114 2
	RT_DSP_CK_MAGIC(dsp);
	BU_CK_VLS(&dsp->dsp_i.dsp_name);
d2116 5
a2120 8
	switch (dsp->dsp_i.dsp_datasrc) {
	case RT_DSP_SRC_V4_FILE: 
	case RT_DSP_SRC_FILE:
	    BU_CK_MAPPED_FILE(dsp->dsp_i.dsp_mp);
	    break;
	case RT_DSP_SRC_OBJ:
	    break;
	}
d2122 5
a2126 2
 	if (RT_G_DEBUG & DEBUG_HF)
		bu_log("rt_dsp_norm(%g %g %g)\n", V3ARGS(hitp->hit_normal));
d2128 5
a2132 1
	VMOVE(N_orig, hitp->hit_normal);
d2134 5
a2138 3
	VJOIN1( hitp->hit_point, rp->r_pt, hitp->hit_dist, rp->r_dir );
 	if (RT_G_DEBUG & DEBUG_HF)
		VPRINT("hit point", hitp->hit_point);
d2140 2
a2141 5
	if (hitp->hit_surfno < 0 || !dsp->dsp_i.dsp_smooth ) {
		/* we've hit one of the sides or bottom, or the user didn't
		 * ask for smoothing of the elevation data,
		 * so there's no interpolation to do
		 */
a2142 18
		if (rt_g.debug & DEBUG_HF)
			bu_log("no Interpolation needed %g,%g,%g\n",
			       V3ARGS(hitp->hit_normal));
		return;
	}

	if (hitp->hit_surfno < 0) {
	    /* New for the 2nd gen */
	    bu_log("Hit one of the sides, not a top surface\n");
	    VMOVE(hitp->hit_normal, dsp_pl[BBSURF(hitp->hit_surfno)]);
	}

	if ( hitp->hit_surfno != TRI2 &&  hitp->hit_surfno != TRI1 &&
	     hitp->hit_surfno != TRI3 && hitp->hit_surfno != TRI4 ) {
		bu_log("%s:%d bogus surface of DSP %d\n",
		       __FILE__, __LINE__, hitp->hit_surfno);
		bu_bomb("");
	}
d2144 4
a2147 2
	if (RT_G_DEBUG & DEBUG_HF)
		bu_log("Interpolation: %d\n", dsp->dsp_i.dsp_smooth);
d2149 4
a2152 4
	/* compute the distance between grid points in model space */
	VSET(tmp, 1.0, 0.0, 0.0);
	MAT4X3VEC(t, dsp->dsp_i.dsp_stom, tmp);
	len = MAGNITUDE(t);
d2154 5
a2158 11
	if (RT_G_DEBUG & DEBUG_HF) {
		bu_semaphore_acquire( BU_SEM_SYSCALL);
		sprintf(buf, "dsp%02d.pl", plot_file_num++);
		bu_semaphore_release( BU_SEM_SYSCALL);

		bu_log("plotting normals in %s\n", buf);
		bu_semaphore_acquire( BU_SEM_SYSCALL);
		if ((fd=fopen(buf, "w")) == (FILE *)NULL) {
			bu_semaphore_release( BU_SEM_SYSCALL);
			bu_bomb("Couldn't open plot file\n");
		}
d2160 1
d2162 3
a2164 8
	/* get the cell we hit */
	x = hitp->hit_vpriv[X];
	y = hitp->hit_vpriv[Y];

	compute_normal_at_gridpoint(Anorm, dsp, x, y, fd, 1);
	compute_normal_at_gridpoint(Bnorm, dsp, x+1, y, fd, 0);
	compute_normal_at_gridpoint(Dnorm, dsp, x+1, y+1, fd, 0);
	compute_normal_at_gridpoint(Cnorm, dsp, x, y+1, fd, 0);
d2166 4
a2169 1
	if (RT_G_DEBUG & DEBUG_HF) {
d2171 5
a2175 3
		/* plot the ray */
		pl_color(fd, 255, 0, 0);
		pdv_3line(fd, rp->r_pt, hitp->hit_point);
d2177 4
a2180 4
		/* plot the normal we started with */
		pl_color(fd, 0, 255, 0);
		VJOIN1(tmp, hitp->hit_point, len, N_orig);
		pdv_3line(fd, hitp->hit_point, tmp);
d2183 2
a2184 2
		/* Plot the normals we just got */
		pl_color(fd, 220, 220, 90);
d2186 4
a2189 4
		VSET(tmp, x,   y,   DSP(dsp, x,   y));
		MAT4X3PNT(A, dsp->dsp_i.dsp_stom, tmp);
		VJOIN1(tmp, A, len, Anorm);
		pdv_3line(fd, A, tmp);
d2191 4
a2194 4
		VSET(tmp, x+1, y,   DSP(dsp, x+1, y));
		MAT4X3PNT(B, dsp->dsp_i.dsp_stom, tmp);
		VJOIN1(tmp, B, len, Anorm);
		pdv_3line(fd, B, tmp);
d2196 4
a2199 4
		VSET(tmp, x+1, y+1, DSP(dsp, x+1, y+1));
		MAT4X3PNT(D, dsp->dsp_i.dsp_stom, tmp);
		VJOIN1(tmp, D, len, Anorm);
		pdv_3line(fd, D, tmp);
d2201 4
a2204 4
		VSET(tmp, x,   y+1, DSP(dsp, x,   y+1));
		MAT4X3PNT(C, dsp->dsp_i.dsp_stom, tmp);
		VJOIN1(tmp, C, len, Anorm);
		pdv_3line(fd, C, tmp);
d2206 2
a2207 2
		bu_semaphore_release( BU_SEM_SYSCALL);
	}
d2209 7
a2215 1
	MAT4X3PNT(pt, dsp->dsp_i.dsp_mtos, hitp->hit_point);
d2217 2
a2218 4
	Xfrac = (pt[X] - x);
	Yfrac = (pt[Y] - y);
	if (RT_G_DEBUG & DEBUG_HF)
		bu_log("Xfract:%g Yfract:%g\n", Xfrac, Yfrac);
d2220 2
a2221 2
	if (Xfrac < 0.0) Xfrac = 0.0;
	else if (Xfrac > 1.0) Xfrac = 1.0;
a2222 2
	if (Yfrac < 0.0) Yfrac = 0.0;
	else if (Yfrac > 1.0) Yfrac = 1.0;
d2224 4
a2227 5

     	if (dsp->dsp_i.dsp_smooth == 2) {
		/* This is an experiment to "flatten" the curvature 
		 * of the dsp near the grid points
		 */
d2229 2
a2230 2
		Xfrac = SMOOTHSTEP( Xfrac );
		Yfrac = SMOOTHSTEP( Yfrac );
d2232 1
a2232 1
     	}
d2234 15
a2248 15
	/* we compute the normal along the "X edges" of the cell */
	VSCALE(Anorm, Anorm, (1.0-Xfrac) );
	VSCALE(Bnorm, Bnorm,      Xfrac  );
	VADD2(ABnorm, Anorm, Bnorm);
	VUNITIZE(ABnorm);

	VSCALE(Cnorm, Cnorm, (1.0-Xfrac) );
	VSCALE(Dnorm, Dnorm,      Xfrac  );
	VADD2(CDnorm, Dnorm, Cnorm);
	VUNITIZE(CDnorm);

	/* now we interpolate the two X edge normals to get the final one */
	VSCALE(ABnorm, ABnorm, (1.0-Yfrac) );
	VSCALE(CDnorm, CDnorm, Yfrac );
	VADD2(N, ABnorm, CDnorm);
d2250 13
a2265 3
	if (RT_G_DEBUG & DEBUG_HF)
		bu_log("interpolated %g %g %g  dot:%g\n", 
		       V3ARGS(N), dot);
a2266 8
	if ( (hitp->hit_vpriv[Z] == 0.0 && dot > 0.0)/* in-hit needs fix */ ||
	     (hitp->hit_vpriv[Z] == 1.0 && dot < 0.0)/* out-hit needs fix */){
		/* bring the normal back to being perpindicular 
		 * to the ray to avoid "flipped normal" warnings
		 */
		VCROSS(A, rp->r_dir, N);
		VCROSS(N, A, rp->r_dir);
		VUNITIZE(N);
d2268 4
a2271 1
		dot = VDOT(N, rp->r_dir);
d2273 6
d2280 2
a2281 18
		if (RT_G_DEBUG & DEBUG_HF)
			bu_log("corrected: %g %g %g dot:%g\n", V3ARGS(N), dot);
	}
	VMOVE(hitp->hit_normal, N);

	if (RT_G_DEBUG & DEBUG_HF) {


		if (fd) {

			bu_semaphore_acquire( BU_SEM_SYSCALL);
			pl_color(fd, 255, 255, 255);
			VJOIN1(tmp, hitp->hit_point, len, hitp->hit_normal);
			pdv_3line(fd, hitp->hit_point, tmp);

			fclose(fd);
			bu_semaphore_release( BU_SEM_SYSCALL);
		}
d2283 1
@


1.80
log
@rt_g.debug -> RT_G_DEBUG
@
text
@a6 3
 * Adding a new solid type:
 *
 *
d47 1
a47 1
static const char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.79 2001/04/20 22:29:43 morrison Exp $ (BRL)";
d65 40
d146 3
a148 2
#define XSIZ(_p) (((struct dsp_specific *)_p)->xsiz)
#define YSIZ(_p) (((struct dsp_specific *)_p)->ysiz)
d161 3
d178 17
a194 14
	struct dsp_specific	*dsp;
	struct bu_list		seglist;	/* list of segments */
	struct xray		r;		/* solid space ray */
	struct application	*ap;
	struct soltab		*stp;
	struct bn_tol		*tol;

	struct bbox_isect bbox;
	struct bbox_isect minbox;

	struct seg *sp;		/* the current segment being filled */
	int sp_is_valid;	/* boolean: sp allocated & (inhit) set */
	int sp_is_done;		/* boolean: sp has (outhit) content */
	jmp_buf env;		/* for setjmp()/longjmp() */
a240 1

d244 3
a264 1

d266 1
d268 170
d439 4
d480 4
d515 10
a544 11
void
dsp_dump(struct rt_dsp_internal *dsp)
{
	struct bu_vls vls;

	dsp_print_v5(&vls, dsp);

	bu_log("%s", bu_vls_addr(&vls));

}

d577 224
a822 1
	int x, y;
d836 9
a844 1
	BU_CK_MAPPED_FILE(dsp_ip->dsp_mp);
a856 2
	dsp_min = 0xffff;
	dsp_max = 0;
d858 2
a859 1
	for (y=0 ; y < YCNT(dsp) ; y++) {
a860 12
		for (x=0 ; x < XCNT(dsp) ; x++) {

			if (DSP(dsp, x, y) < dsp_min)
				dsp_min = DSP(dsp, x, y);

			if (DSP(dsp, x, y) > dsp_max)
				dsp_max = DSP(dsp, x, y);
		}
	}

	if (RT_G_DEBUG & DEBUG_HF)
		bu_log("  x:%d y:%d min %d max %d\n", XCNT(dsp), YCNT(dsp), dsp_min, dsp_max);
a903 1
	BU_CK_MAPPED_FILE(dsp_ip->dsp_mp);
d905 7
a911 56
	return 0;
}


/*
 *	Register an in-bound hit on a cell
 */
#define INHIT(isp, dist, surf, cell, norm) \
	inhit(isp, dist, surf, cell, norm, __FILE__, __LINE__)
void
inhit(isp, dist, surf, cell, norm, file, line)
struct isect_stuff *isp;
double dist;
int surf;
int cell[2];
vect_t norm;
char *file;
int line;
{

	if (isp->sp_is_valid) {

		/* if we have a hit point exactly on the top of 2 cells
		 * at the exact border, we can get 2 hits on the same point.
		 * We just ignore the second hit in this case.
		 */
		if (fabs(dist - isp->sp->seg_in.hit_dist) < isp->tol->dist)
			return;


		bu_log("%s:%d pixel(%d,%d) ", file, line,
			isp->ap->a_x, isp->ap->a_y);
		bu_log("trying to enter solid when inside.\n");
		bu_log("\tnew dist %g\n\told dist %g difference: %g\n",
			dist, isp->sp->seg_in.hit_dist,
			dist - isp->sp->seg_in.hit_dist);
		longjmp(isp->env, 1);
	}

	RT_GET_SEG( isp->sp, isp->ap->a_resource );
	isp->sp->seg_stp = isp->stp;
	isp->sp->seg_in.hit_dist = dist;
	isp->sp->seg_in.hit_surfno = surf;
	isp->sp->seg_in.hit_vpriv[X] = cell[X];
	isp->sp->seg_in.hit_vpriv[Y] = cell[Y];
	isp->sp->seg_in.hit_vpriv[Z] = 0.0;
	VMOVE(isp->sp->seg_in.hit_normal, norm);
	isp->sp_is_valid = 1;

	if (RT_G_DEBUG & DEBUG_HF) {
		point_t in, t;
		VJOIN1(t, isp->r.r_pt, dist, isp->r.r_dir);
		MAT4X3PNT(in, isp->dsp->dsp_i.dsp_stom, t);
		bu_log("line %d(%d) New in pt(%g %g %g) ss_dist %g surf: %d\n",
			__LINE__, line, V3ARGS(in), dist, surf);
		bu_log("\tNormal: %g %g %g\n", V3ARGS(norm));
a912 1
}
d914 1
a914 43



/*
 *	Register an out-bound hit on a cell
 */
#define OUTHIT(isp, dist, surf, cell, norm) \
	outhit(isp, dist, surf, cell, norm, __FILE__, __LINE__)
void
outhit(isp, dist, surf, cell, norm, file, line)
struct isect_stuff *isp;
double dist;
int surf;
int cell[2];
vect_t norm;
char *file;
int line;
{
	point_t out, t;

	if (! isp->sp_is_valid) {
		bu_log("%s:%d pixel(%d,%d) ", file, line, 
			isp->ap->a_x, isp->ap->a_y);
		bu_log("Trying to set outpoint when not inside\n");
		longjmp(isp->env, 1);
	}

	isp->sp->seg_out.hit_dist = dist;
	isp->sp->seg_out.hit_surfno = surf;
	isp->sp->seg_out.hit_vpriv[X] = cell[X];
	isp->sp->seg_out.hit_vpriv[Y] = cell[Y];
	isp->sp->seg_out.hit_vpriv[Z] = 1.0;
	VMOVE(isp->sp->seg_out.hit_normal, norm);
	isp->sp_is_done = 1;

	if (RT_G_DEBUG & DEBUG_HF) {

		VJOIN1(t, isp->r.r_pt, dist, isp->r.r_dir);
		MAT4X3PNT(out, isp->dsp->dsp_i.dsp_stom, t);
		bu_log("line %d(%d) New out pt(%g %g %g) ss_dist %g surf:%d\n",
			__LINE__, line, V3ARGS(out), dist, surf);
		bu_log("\tNormal: %g %g %g\n", V3ARGS(norm));
	}
d921 1
a921 36
/*
 *  Commit a completed segment (in-hit, out-hit) to the intersection result
 */
#define HIT_COMMIT(isp) hit_commit(isp, __FILE__, __LINE__)
void
hit_commit(isp, file, line)
struct isect_stuff *isp;
char *file;
int line;
{
	if ( ! (isp)->sp_is_valid) {
		bu_log("%s:%d pixel(%d,%d) ", file, line,
			isp->ap->a_x, isp->ap->a_y);
		bu_log("attempt to commit an invalid seg\n");
		longjmp(isp->env, 1);
	}
	if ( ! (isp)->sp_is_done) {
		bu_log("%s:%d pixel(%d,%d) ", file, line,
			isp->ap->a_x, isp->ap->a_y);
		bu_log("attempt to commit an incomplete seg\n");
		longjmp(isp->env, 1);
	}

	if (RT_G_DEBUG & DEBUG_HF) {
		bu_log("line %d Committing seg %g -> %g\n", line,
			(isp)->sp->seg_in.hit_dist,
			(isp)->sp->seg_out.hit_dist);
	}

	BU_LIST_INSERT( &(isp)->seglist, &( isp->sp->l) );
	(isp)->sp = (struct seg *)NULL;
	(isp)->sp_is_valid = 0;
	(isp)->sp_is_done = 0;
}


d927 1
d936 1
a936 1
	if (RT_G_DEBUG & DEBUG_HF)
d948 1
a948 1
		if (RT_G_DEBUG & DEBUG_HF)
d956 1
a956 1
				if (RT_G_DEBUG & DEBUG_HF)
d965 1
a965 1
		if (RT_G_DEBUG & DEBUG_HF)
d993 1
a993 1
	if (RT_G_DEBUG & DEBUG_HF) {
d1014 3
a1016 765
	/* copmute "minbox" the bounding box of the rpp under the lowest
	 * displacement height
	 */

	isect->minbox.in_dist = isect->bbox.in_dist;
	isect->minbox.in_surf = isect->bbox.in_surf;
	isect->minbox.out_dist = isect->bbox.out_dist;
	isect->minbox.out_surf = isect->bbox.out_surf;

	if (NdotD < 0.0) {
		/* entering */
		if (dist > isect->bbox.in_dist) {
			isect->minbox.in_dist = dist;
			isect->minbox.in_surf = 6;
		}
	} else { /*  (NdotD > 0.0) */
		/* leaving */
		if (dist < isect->bbox.out_dist) {
			isect->minbox.out_dist = dist;
			isect->minbox.out_surf = 6;
		}
	}

	if (RT_G_DEBUG & DEBUG_HF) {
		vect_t pt, t;
		VJOIN1(t, isect->r.r_pt, isect->minbox.in_dist, isect->r.r_dir);

		MAT4X3PNT(pt, isect->dsp->dsp_i.dsp_stom, t);

		bu_log("solid minbox rpp in  surf[%d] ss_dist:%g (%g %g %g)\n",
			isect->minbox.in_surf, isect->minbox.in_dist, V3ARGS(pt));

		VJOIN1(t, isect->r.r_pt, isect->minbox.out_dist, isect->r.r_dir);
		MAT4X3PNT(pt, isect->dsp->dsp_i.dsp_stom, t);

		bu_log("solid minbox rpp out surf[%d] ss_dist:%g (%g %g %g)\n",
			isect->minbox.out_surf, isect->minbox.out_dist, V3ARGS(pt));
	}

	return 1;
}


/*
 *	Finds the minimum and maximum values in a cell
 */
void
cell_minmax(dsp, x, y, cell_min, cell_max)
register struct dsp_specific *dsp;
register int x, y;
unsigned short *cell_min;
unsigned short *cell_max;
{
	register unsigned short cmin, cmax, v;

	RT_DSP_CK_MAGIC(dsp);

	cmin = cmax = DSP(dsp, x, y);

	v = DSP(dsp, x+1, y);
	if (v < cmin) cmin = v;
	if (v > cmax) cmax = v;
	
	v = DSP(dsp, x+1, y+1);
	if (v < cmin) cmin = v;
	if (v > cmax) cmax = v;
	
	v = DSP(dsp, x, y+1);
	if (v < cmin) cmin = v;
	if (v > cmax) cmax = v;

	*cell_min = cmin;
	*cell_max = cmax;
}





/* 
 * produce a plot file of the ray and the cell being intersected 
 */
static void
plot_cell_ray(isect, cell,
	curr_pt, next_pt, hit1, dist1, hit2, dist2)
struct isect_stuff *isect;
int cell[3];		  /* 2D cell # (coordinates) */
vect_t curr_pt, next_pt;  /* in and out points on cell bbox */
int hit1;		  /* Boolean: dist1 valid */
double dist1;		  /* distance to first cell hit */
int hit2;		  /* Boolean: dist2 valid */
double dist2;		  /* distance to second cell hit */
{
	FILE	*fd;
	char	buf[132];
	point_t	A, B, C, D;
	point_t tmp, pt, in_pt, out_pt;
	unsigned short	min_val;
	unsigned short	max_val;
	int	outside;


	VSET(A, cell[X],   cell[Y],   DSP(isect->dsp, cell[X],   cell[Y])  );
	VSET(B, cell[X]+1, cell[Y],   DSP(isect->dsp, cell[X]+1, cell[Y])  );
	VSET(C, cell[X],   cell[Y]+1, DSP(isect->dsp, cell[X],   cell[Y]+1));
	VSET(D, cell[X]+1, cell[Y]+1, DSP(isect->dsp, cell[X]+1, cell[Y]+1));

	bu_semaphore_acquire( BU_SEM_SYSCALL);
	sprintf(buf, "dsp%02d.pl", plot_file_num++);
	bu_semaphore_release( BU_SEM_SYSCALL);
	bu_log("%s\n", buf);

	bu_semaphore_acquire( BU_SEM_SYSCALL);
	if ((fd=fopen(buf, "w")) == (FILE *)NULL) {
		bu_semaphore_release( BU_SEM_SYSCALL);
		return;
	}




	/* we don't plot the bounds of the box if it's a
	 * zero thickness axis aligned plane
	 */
	if (A[Z] != B[Z] || A[Z] != C[Z] || A[Z] != D[Z]) {
		RT_DSP_CK_MAGIC(isect->dsp);

		cell_minmax(isect->dsp, cell[X], cell[Y], &min_val, &max_val);


		/* plot cell top bounding box */
		pl_color(fd, 60, 60, 190);

		tmp[Z] = (double)min_val;

		VMOVEN(tmp, A, 2);
		MAT4X3PNT(pt, isect->dsp->dsp_i.dsp_stom, tmp);
		pdv_3move(fd, pt);

		VMOVEN(tmp, B, 2);
		MAT4X3PNT(pt, isect->dsp->dsp_i.dsp_stom, tmp);
		pdv_3cont(fd, pt);

		VMOVEN(tmp, D, 2);
		MAT4X3PNT(pt, isect->dsp->dsp_i.dsp_stom, tmp);
		pdv_3cont(fd, pt);

		VMOVEN(tmp, C, 2);
		MAT4X3PNT(pt, isect->dsp->dsp_i.dsp_stom, tmp);
		pdv_3cont(fd, pt);

		VMOVEN(tmp, A, 2);
		MAT4X3PNT(pt, isect->dsp->dsp_i.dsp_stom, tmp);
		pdv_3cont(fd, pt);

		tmp[Z] = (double)max_val;
		MAT4X3PNT(pt, isect->dsp->dsp_i.dsp_stom, tmp);
		pdv_3cont(fd, pt);

		VMOVEN(tmp, B, 2);
		MAT4X3PNT(pt, isect->dsp->dsp_i.dsp_stom, tmp);
		pdv_3cont(fd, pt);

		VMOVEN(tmp, D, 2);
		MAT4X3PNT(pt, isect->dsp->dsp_i.dsp_stom, tmp);
		pdv_3cont(fd, pt);

		VMOVEN(tmp, C, 2);
		MAT4X3PNT(pt, isect->dsp->dsp_i.dsp_stom, tmp);
		pdv_3cont(fd, pt);

		VMOVEN(tmp, A, 2);
		MAT4X3PNT(pt, isect->dsp->dsp_i.dsp_stom, tmp);
		pdv_3cont(fd, pt);
	} else 
		min_val = max_val = A[Z];

	/* 
	 * plot the ray on the bottom of the box if the ray
	 * is in/below it.  Otherwise, plot the ray on the top
	 * of the box.  This helps us see the overlap of the ray
	 * when it's far away.
	 */
	VMOVE(tmp, curr_pt);
	if (curr_pt[Z] < max_val) tmp[Z] = (double)min_val;
	else			  tmp[Z] = (double)max_val;
	MAT4X3PNT(in_pt, isect->dsp->dsp_i.dsp_stom, tmp);

	VMOVE(tmp, next_pt);
	if (curr_pt[Z] < max_val) tmp[Z] = (double)min_val;
	else			  tmp[Z] = (double)max_val;
	MAT4X3PNT(out_pt, isect->dsp->dsp_i.dsp_stom, tmp);
	pl_color(fd, 120, 120, 240);
	pdv_3move(fd, in_pt);
	pdv_3cont(fd, out_pt);



	/* 
	 * plot the triangles which make up the top of the cell in GREEN
	 */
	pl_color(fd, 90, 220, 90);

	VMOVE(tmp, A);
	MAT4X3PNT(pt, isect->dsp->dsp_i.dsp_stom, tmp);
	pdv_3move(fd, pt);

	VMOVE(tmp, B);
	MAT4X3PNT(pt, isect->dsp->dsp_i.dsp_stom, tmp);
	pdv_3cont(fd, pt);

	VMOVE(tmp, D);
	MAT4X3PNT(pt, isect->dsp->dsp_i.dsp_stom, tmp);
	pdv_3cont(fd, pt);

	VMOVE(tmp, A);
	MAT4X3PNT(pt, isect->dsp->dsp_i.dsp_stom, tmp);
	pdv_3cont(fd, pt);

	VMOVE(tmp, C);
	MAT4X3PNT(pt, isect->dsp->dsp_i.dsp_stom, tmp);
	pdv_3cont(fd, pt);

	VMOVE(tmp, D);
	MAT4X3PNT(pt, isect->dsp->dsp_i.dsp_stom, tmp);
	pdv_3cont(fd, pt);


	/* plot the ray */
	outside = !isect->sp_is_valid;

	if (outside)	pl_color(fd, 255, 40, 40);	/* RED */
	else		pl_color(fd, 255, 255, 100);	/* YELLOW */


	MAT4X3PNT(in_pt, isect->dsp->dsp_i.dsp_stom, curr_pt);
	pdv_3move(fd, in_pt);

	if (hit1 && hit2) {
		if (dist1 < dist2) {
			VJOIN1(tmp, isect->r.r_pt, dist1, isect->r.r_dir);
			MAT4X3PNT(pt, isect->dsp->dsp_i.dsp_stom, tmp);
			pdv_3cont(fd, pt);

			if (outside) pl_color(fd, 255, 255, 100); /* YELLOW */
			else	     pl_color(fd, 255, 40, 40);   /* RED */
			pdv_3move(fd, pt);

			outside = !outside;
			VJOIN1(tmp, isect->r.r_pt, dist2, isect->r.r_dir);
			MAT4X3PNT(pt, isect->dsp->dsp_i.dsp_stom, tmp);
			pdv_3cont(fd, pt);

			if (outside) pl_color(fd, 255, 255, 100); /* YELLOW */
			else	     pl_color(fd, 255, 40, 40);   /* RED */

			pdv_3move(fd, pt);
			outside = !outside;
		} else {
			VJOIN1(tmp, isect->r.r_pt, dist2, isect->r.r_dir);
			MAT4X3PNT(pt, isect->dsp->dsp_i.dsp_stom, tmp);
			pdv_3cont(fd, pt);

			if (outside) pl_color(fd, 255, 255, 100);
			else	     pl_color(fd, 255, 40, 40);
			pdv_3move(fd, pt);
			outside = !outside;
			VJOIN1(tmp, isect->r.r_pt, dist1, isect->r.r_dir);
			MAT4X3PNT(pt, isect->dsp->dsp_i.dsp_stom, tmp);
			pdv_3cont(fd, pt);

			if (outside) pl_color(fd, 255, 255, 100);
			else	     pl_color(fd, 255, 40, 40);
			pdv_3move(fd, pt);
			outside = !outside;
		}
	} else if (hit1) {
		VJOIN1(tmp, isect->r.r_pt, dist1, isect->r.r_dir);
		MAT4X3PNT(pt, isect->dsp->dsp_i.dsp_stom, tmp);
		pdv_3cont(fd, pt);

		if (outside)	pl_color(fd, 255, 255, 100);
		else		pl_color(fd, 255, 40, 40);
		pdv_3move(fd, pt);

	} else if (hit2) {
		VJOIN1(tmp, isect->r.r_pt, dist2, isect->r.r_dir);
		MAT4X3PNT(pt, isect->dsp->dsp_i.dsp_stom, tmp);
		pdv_3cont(fd, pt);

		if (outside)	pl_color(fd, 255, 255, 100);
		else		pl_color(fd, 255, 40, 40);
		pdv_3move(fd, pt);
	}

		
	MAT4X3PNT(pt, isect->dsp->dsp_i.dsp_stom, next_pt);
	pdv_3cont(fd, pt);


	fclose(fd);
	bu_semaphore_release( BU_SEM_SYSCALL);
}

/* 
 *  This is a support routine for isect_ray_triangles()
 *  The basic idea is to get the coordinates of the four corners of the cell.
 *  The cell top will be cut from point A to point D by isect_ray_triangles()
 *  So we re-order the points so that the cut is optimally placed.  Basically
 *  we decide if the cut will be A-D or B-C.
 */
static void
set_and_permute(isect, cell, A, B, C, D, tri1, tri2)
struct isect_stuff *isect;
int cell[3];
point_t A, B, C, D;
int *tri1;
int *tri2;
{
	int lo[2], hi[2];
	point_t tmp;
	double c1, c2;
	double h1, h2, h3, h4;

	/* Load the corner points of the cell */

	VSET(A, cell[X],   cell[Y],   DSP(isect->dsp, cell[X],   cell[Y])  );
	VSET(B, cell[X]+1, cell[Y],   DSP(isect->dsp, cell[X]+1, cell[Y])  );
	VSET(C, cell[X],   cell[Y]+1, DSP(isect->dsp, cell[X],   cell[Y]+1));
	VSET(D, cell[X]+1, cell[Y]+1, DSP(isect->dsp, cell[X]+1, cell[Y]+1));


	/*
	 *  We look at the points in the diagonal next cells to determine
	 *  the curvature along each diagonal of this cell.  This cell is
	 *  divided into two triangles by cutting across the cell in the
	 *  direction of least curvature.
	 *
	 *	*  *  *	 *
	 *	 \      /
	 *	  \C  D/
	 *	*  *--*  *
	 *	   |\/|
	 *	   |/\|
	 *	*  *--*  *
	 *	  /A  B\
	 *	 /	\
	 *	*  *  *	 *
	 */

	lo[X] = cell[X] - 1;
	lo[Y] = cell[Y] - 1;
	hi[X] = cell[X] + 1;
	hi[Y] = cell[Y] + 1;

	if (lo[X] < 0) lo[X] = 0;
	if (lo[Y] < 0) lo[Y] = 0;

	if (hi[X] > XSIZ(isect->dsp)) hi[X] = XSIZ(isect->dsp);
	if (hi[Y] > YSIZ(isect->dsp)) hi[Y] = YSIZ(isect->dsp);


	/* compute curvature along the A->D direction */
	h1 = DSP(isect->dsp, lo[X], lo[Y]);
	h2 = A[Z];
	h3 = D[Z];
	h4 = DSP(isect->dsp, hi[X], hi[Y]);

	c1 = fabs(h3 + h1 - 2*h2 ) + fabs( h4 + h2 - 2*h3 );


	/* compute curvature along the B->C direction */
	h1 = DSP(isect->dsp, hi[X], lo[Y]);
	h2 = B[Z];
	h3 = C[Z];
	h4 = DSP(isect->dsp, lo[X], hi[Y]);

	c2 = fabs(h3 + h1 - 2*h2 ) + fabs( h4 + h2 - 2*h3 );
	
	if ( c1 < c2 ) {
		*tri1 = TRI1;
		*tri2 = TRI2;

		return;
	}

	
	/* prefer the B-C cut rather than the A-D cut */
	*tri1 = TRI3;
	*tri2 = TRI4;


	VMOVE(tmp, A);
	VMOVE(A, B);
	VMOVE(B, D);
	VMOVE(D, C);
	VMOVE(C, tmp);

}

/*
 *  Once we've determined that the ray hits the bounding box for
 *  the triangles, this routine takes care of the actual triangle intersection
 *  and follow-up.
 */
static void
isect_ray_triangles(isect, cell, 
	curr_pt, next_pt)
struct isect_stuff *isect;
int cell[3];
point_t curr_pt, next_pt;
{
	point_t A, B, C, D;
	vect_t AB, AC, AD;
	vect_t N1, N2;
	vect_t PA;
	vect_t PAxD;
	double alpha;
	double beta;
	double NdotD1;
	double NdotD2;
	double abs_NdotD;
	double	dist1 = -42.0;
	double	dist2 = -42.0;
	int hit1;
	int hit2;
	char *reason1;
	char *reason2;
	int tria1, tria2;


	set_and_permute(isect, cell, A, B, C, D, &tria1, &tria2);

	if (RT_G_DEBUG & DEBUG_HF) {
		point_t t;
		bu_log("isect_ray_triangles(inside=%d)\n", isect->sp_is_valid);

		MAT4X3PNT(t, isect->dsp->dsp_i.dsp_stom, A);
		VPRINT("\tA", t);
		MAT4X3PNT(t, isect->dsp->dsp_i.dsp_stom, B);
		VPRINT("\tB", t);
		MAT4X3PNT(t, isect->dsp->dsp_i.dsp_stom, C);
		VPRINT("\tC", t);
		MAT4X3PNT(t, isect->dsp->dsp_i.dsp_stom, D);
		VPRINT("\tD", t);
	}


	VSUB2(AB, B, A);
	VSUB2(AC, C, A);
	VSUB2(AD, D, A);

	VSUB2(PA, A, isect->r.r_pt);

	/* get perpendicular to PA, D */
	VCROSS(PAxD, PA, isect->r.r_dir);

	VCROSS(N1, AB, AD);
	NdotD1 = VDOT( N1, isect->r.r_dir);

	hit1 = 0;
	reason1 = (char *)NULL;
	if ( BN_VECT_ARE_PERP(NdotD1, isect->tol)) {
		dlog("\tmiss tri1 %s\n", reason1="perpendicular");
		goto tri2;
	}

	/* project PAxD onto AB giving scaled distance along *AD* */
	alpha = VDOT( AB, PAxD );

	if (NdotD1 > 0.0) alpha = -alpha;

	abs_NdotD = NdotD1 >= 0.0 ? NdotD1 : (-NdotD1);

	if (alpha < 0.0 || alpha > abs_NdotD ) {
		dlog("\tmiss tri1 %s\n", reason1 = "(alpha)");
		goto tri2;
	}

	/* project PAxD onto AD giving scaled distance along *AB* */
	beta = VDOT( AD, PAxD );

	if ( NdotD1 < 0.0 ) beta = -beta;

	if (beta < 0.0 || beta > abs_NdotD ) {
		dlog("\tmiss tri1 %s\n", reason1 = "(beta)");
		goto tri2;
	}
	if ( alpha+beta > abs_NdotD ) {
		dlog("miss tri1 %s\n", reason1 = "(alpha+beta > NdotD)");
		goto tri2;
	}
	hit1 = 1;
	dist1 = VDOT( PA, N1 ) / NdotD1;

tri2:
	if (RT_G_DEBUG & DEBUG_HF) {
		if (hit1)  bu_log("hit tri1 dist %g\n", dist1);
		else bu_log("missed tria1 %s\n", reason1);
	}
	VCROSS(N2, AD, AC);
	NdotD2 = VDOT( N2, isect->r.r_dir);

	hit2 = 0;
	reason2 = (char *)NULL;
	if (BN_VECT_ARE_PERP(NdotD2, isect->tol)) {
		dlog("miss tri2 %s\n", reason2 = "perpendicular");
		goto done;
	}

	/* project PAxD onto AD giving scaled distance along *AC* */
	alpha = VDOT( AD, PAxD );
	if (NdotD2 > 0.0) alpha = -alpha;
	abs_NdotD = NdotD2 >= 0.0 ? NdotD2 : (-NdotD2);
	if (alpha < 0.0 || alpha > abs_NdotD ) {
		dlog("miss tri2 %s\n", reason2 = "(alpha)");
		goto done;
	}

	/* project PAxD onto AC giving scaled distance along *AD* */
	beta = VDOT( AC, PAxD );
	if ( NdotD2 < 0.0 ) beta = -beta;
	if (beta < 0.0 || beta > abs_NdotD ) {
		dlog("miss tri2 %s\n", reason2 = "(beta)");
		goto done;
	}

	if ( alpha+beta > abs_NdotD ) {
		dlog("miss tri2 %s\n", reason2 = "(alpha+beta > NdotD)");
		goto done;
	}

	hit2 = 1;
	dist2 = VDOT( PA, N2 ) / NdotD2;

done:
	if (RT_G_DEBUG & DEBUG_HF) {
		if (hit2)  bu_log("hit tri2 dist %g\n", dist2);
		else bu_log("missed tri2 %s\n", reason2);
	}

	/* plot some diagnostic overlays */
	if (RT_G_DEBUG & DEBUG_HF && plot_em)
		plot_cell_ray(isect, cell, curr_pt, next_pt, 
				hit1, dist1, hit2, dist2);

	if (hit1 && hit2 && ((NdotD1 < 0) == (NdotD2 < 0)) &&
	    BN_APPROXEQUAL(dist1, dist2, isect->tol) ) {
		/* hit a seam, eg. between two triangles of a flat plate. */
		if (RT_G_DEBUG & DEBUG_HF) {
			bu_log("ss_dist1:%g N1:%g %d\n", dist1);
			bu_log("ss_dist2:%g N2:%g %d\n", dist2);
			bu_log("hit seam, skipping hit2\n");
		}

		hit2 = 0;
	}


	/* sort the hit distances and add the hits to the segment list */
	if (hit1 && hit2) {
		int first_tri, second_tri;
		double first, second;
		double firstND, secondND;
		double *firstN, *secondN;

		/* hit both */

		if (dist1 < dist2) {
			if (RT_G_DEBUG & DEBUG_HF)
				bu_log("hit triangles: ss_dist1:%g ss_dist2:%g line:%d\n", dist1, dist2, __LINE__);
			first_tri = tria1;
			firstND = NdotD1;
			first = dist1;
			firstN = N1;
			second_tri = tria2;
			secondND = NdotD2;
			second = dist2;
			secondN = N2;
		} else {
			if (RT_G_DEBUG & DEBUG_HF)
				bu_log("hit triangles: ss_dist2:%g ss_dist1:%g line:%d\n", dist2, dist1, __LINE__);
			first_tri = tria2;
			firstND = NdotD2;
			first = dist2;
			firstN = N2;
			second_tri = tria1;
			secondND = NdotD1;
			second = dist1;
			secondN = N1;
		}

		if (firstND < 0) {
			/* entering, according to ray/normal comparison */
			INHIT(isect, first, first_tri, cell, firstN);

			if (secondND < 0) {
				/* will fail if not same point */
				INHIT(isect, second, second_tri, 
					cell, secondN);
			}
			OUTHIT(isect, second, second_tri, cell, secondN);
			HIT_COMMIT(isect);

		} else {
			/* leaving */
			OUTHIT(isect, first, first_tri, cell, firstN);
			HIT_COMMIT(isect);

			if (secondND > 0) {
				bu_log("%s:%d ray leaving while outside dsp pixel(%d,%d)",
					__FILE__, __LINE__,
					isect->ap->a_x, isect->ap->a_y);
				longjmp(isect->env, 1);
			}
			INHIT(isect, second, second_tri, cell, secondN);
		}
	} else if (hit1) {
		/* only hit tri 1 */

		if (NdotD1 < 0) {
			/* entering */
			if (RT_G_DEBUG & DEBUG_HF)
				bu_log("hit triangle 1 entering ss_dist:%g\n",
					dist1);

			INHIT(isect, dist1, tria1, cell, N1);
		} else {
			/* leaving */
			if (RT_G_DEBUG & DEBUG_HF)
				bu_log("hit triangle 1 leaving ss_dist:%g\n",
					dist1);

			OUTHIT(isect, dist1, tria1, cell, N1);
			HIT_COMMIT(isect);
		}
	} else if (hit2) {
		/* only hit 2 */

		if (NdotD2 < 0) {
			/* entering */

			if (RT_G_DEBUG & DEBUG_HF)
				bu_log("hit triangle 2 entering ss_dist:%g\n",
					dist2);

			INHIT(isect, dist2, tria2, cell, N2);
		} else {
			/* leaving */

			if (RT_G_DEBUG & DEBUG_HF)
				bu_log("hit triangle 2 leaving ss_dist:%g\n",
					dist2);

			OUTHIT(isect, dist2, tria2, cell, N2);
			HIT_COMMIT(isect);
		}
	} else {
		/* missed everything */
	}



}


/*
 *	Intersect the ray with a wall of a "cell" of the DSP.  In particular,
 *	a wall perpendicular to the X axis.
 */
static int
isect_cell_x_wall(isect, cell, surf, dist, pt)
struct isect_stuff *isect;
int cell[3];	/* cell to intersect */
int surf;	/* wall of cell to intersect */
double dist;	/* in-hit distance to cell along ray */
point_t pt;	/* point on cell wall */
{
	unsigned short a, b;	/* Elevation values on cell wall */
	double wall_top_slope;
	double wall_top;	/* wall height at Y of curr_pt */
	double pt_dy;

	if (RT_G_DEBUG & DEBUG_HF) {
		vect_t t;
		MAT4X3PNT(t, isect->dsp->dsp_i.dsp_stom, pt);
		bu_log("isect_cell_x_wall() cell(%d,%d) surf:%d ss_dist:%g pt(%g %g %g)\n",
			V2ARGS(cell), surf, dist, V3ARGS(t));
	}


	if (surf == BBSURF(XMIN)) {
		if (fabs(pt[X] - cell[X]) > isect->tol->dist) {
			bu_log("%s:%d pixel %d,%d point (%g %g %g)\n",
				__FILE__, __LINE__, 
				isect->ap->a_x, isect->ap->a_y,
				V3ARGS(pt) );
			bu_log("\tNot on plane X=%d\n", cell[X]);
			longjmp(isect->env, 1);

		}

		a = DSP(isect->dsp, cell[X],   cell[Y]);
		b = DSP(isect->dsp, cell[X],   cell[Y]+1);
	} else if (surf == BBSURF(XMAX)) {
		if (fabs(pt[X] - (cell[X]+1)) > isect->tol->dist) {
			bu_log("%s:%d pixel %d,%d point (%g %g %g)\n",
				__FILE__, __LINE__, 
				isect->ap->a_x, isect->ap->a_y,
				V3ARGS(pt) );
			bu_log("\tNot on plane Y=%d\n", cell[X] + 1);
			longjmp(isect->env, 1);

		}

		a = DSP(isect->dsp, cell[X]+1, cell[Y]);
		b = DSP(isect->dsp, cell[X]+1, cell[Y]+1);
	} else {
		bu_log("%s:%d pixel(%d,%d) ", __FILE__, __LINE__,
			isect->ap->a_x, isect->ap->a_y);
		bu_log("bad surface %d, isect_cell_x_entry_wall()\n", surf);
		longjmp(isect->env, 1);
	}

	wall_top_slope = b - a;
	pt_dy = pt[Y] - cell[Y];

	/* compute the height of the wall top at the Y location of pt */
	wall_top = a + pt_dy * wall_top_slope;

	if (RT_G_DEBUG & DEBUG_HF)
		bu_log("\ta:%d b:%d wall slope:%g top:%g dy:%g pt[Z]:%g\n",
			a, b, wall_top_slope, wall_top, pt_dy, pt[Z]);

	return (wall_top > pt[Z]);
}




/*
 *	Intersect the ray with a wall of a "cell" of the DSP.  In particular,
 *	a wall perpendicular to the Y axis.
 */
static int
isect_cell_y_wall(isect, cell, surf, dist, pt)
struct isect_stuff *isect;
int cell[3];
int surf;
double dist;
point_t pt;
{
	unsigned short a, b;	/* points on cell wall */
	double wall_top_slope;
	double wall_top;	/* wall height at Y of pt */
	double pt_dx;

	if (RT_G_DEBUG & DEBUG_HF) {
		vect_t t;

		MAT4X3PNT(t, isect->dsp->dsp_i.dsp_stom, pt);
		bu_log("isect_cell_y_wall() cell(%d,%d) surf:%d ss_dist:%g pt(%g %g %g)\n",
			V2ARGS(cell), surf, dist, V3ARGS(t));
	}

d1018 4
d1023 5
a1027 8
	if (surf == BBSURF(YMIN)) {
		if ( fabs(pt[Y] - cell[Y]) > isect->tol->dist) {
			bu_log("%s:%d pixel %d,%d point (%g %g %g)\n",
				__FILE__, __LINE__, 
				isect->ap->a_x, isect->ap->a_y,
				V3ARGS(pt) );
			bu_log("\tNot on plane Y=%d\n", cell[Y]);
			longjmp(isect->env, 1);
d1029 5
a1033 10
		a = DSP(isect->dsp, cell[X],   cell[Y]);
		b = DSP(isect->dsp, cell[X]+1, cell[Y]);
	} else if (surf == BBSURF(YMAX)) {
		if ( fabs(pt[Y] - (cell[Y] + 1)) > isect->tol->dist) {
			bu_log("%s:%d pixel %d,%d point (%g %g %g)\n",
				__FILE__, __LINE__, 
				isect->ap->a_x, isect->ap->a_y,
				V3ARGS(pt) );
			bu_log("\tNot on plane Y=%d\n", cell[Y] + 1);
			longjmp(isect->env, 1);
a1034 7
		a = DSP(isect->dsp, cell[X],   cell[Y]+1);
		b = DSP(isect->dsp, cell[X]+1, cell[Y]+1);
	} else {
		bu_log("%s:%d pixel(%d,%d) ", __FILE__, __LINE__,
			isect->ap->a_x, isect->ap->a_y);
		bu_log("bad surface %d, isect_cell_y_entry_wall()\n", surf);
		longjmp(isect->env, 1);
d1037 3
a1039 2
	wall_top_slope = b - a;
	pt_dx = pt[X] - cell[X];
d1041 1
a1041 2
	/* compute the height of the wall top at the X location of pt */
	wall_top = a + pt_dx * wall_top_slope;
d1043 2
a1044 3
	if (RT_G_DEBUG & DEBUG_HF)
		bu_log("\ta:%d b:%d wall slope:%g top:%g dx:%g pt[Z]:%g\n",
			a, b, wall_top_slope, wall_top, pt_dx, pt[Z]);
d1046 2
d1049 2
a1050 23
	return (wall_top > pt[Z]);
}

/*
 *	Intersect the ray with a wall of a "cell" of the DSP.  In particular,
 *	a wall perpendicular to the Z axis.
 */
static int
isect_cell_z_wall(isect, cell, surf, dist, pt)
struct isect_stuff *isect;
int cell[3];
int surf;
double dist;
point_t pt;
{
	/* make sure the point is really on the bottom of the solid */
	if ( fabs(pt[Z]) > isect->tol->dist) {
		bu_log("%s:%d pixel %d,%d point (%g %g %g)\n",
			__FILE__, __LINE__, 
			isect->ap->a_x, isect->ap->a_y,
			V3ARGS(pt) );
		bu_log("\tNot on plane Z=0\n");
		longjmp(isect->env, 1);
d1053 1
a1053 14

	/* make sure the point is inside the bottom of the cell */
	if (cell[X] <= pt[X] && (cell[X]+1) >= pt[X] &&
	    cell[Y] <= pt[Y] && (cell[Y]+1) >= pt[Y] )
		return 1;

	bu_log("%s:%d pixel %d,%d point (%g %g %g)\n",
		__FILE__, __LINE__, 
		isect->ap->a_x, isect->ap->a_y,
		V3ARGS(pt) );
	bu_log("\tNot inside cell\n");
	longjmp(isect->env, 1);
	/* NOTREACHED */
	return 0;
d1055 1
d1058 9
a1066 4

/*
 * A bag of pointers and info that cell_isect needs.  We package it
 * up for convenient parameter passing.
d1068 91
a1158 1
struct cell_stuff {
d1160 2
a1161 45
	int	*grid_cell;	/* grid coordinates for current cell */
	double	 curr_dist;	/* distance along ray to curr_pt */
	pointp_t curr_pt;  /* entry point on grid_cell */
	pointp_t next_pt;  /* exit point on grid_cell */
	double	 next_dist;	/* distance along ray to next_pt */

	int rising;	   /* boolean: ray Z is positive */
	int cell_insurf;   /* surface through which we   entered  grid_cell */
	int cell_outsurf;  /* surface through which we will leave grid_cell */
};



/*
 * determine if a point on a plane is on the wall of a cell in that plane
 *
 */
int
isect_pt_wall(isect, cell, surf, dist, pt, s)
struct isect_stuff *isect;
int cell[2];
int surf;
double dist;
point_t pt;
char *s;
{
	int hit;

	switch (surf) {
	case BBSURF(XMIN) :	/* Intersect X wall of cell */
	case BBSURF(XMAX) :
		hit = isect_cell_x_wall(isect, cell, surf, dist, pt);
		if (RT_G_DEBUG & DEBUG_HF) {
			if (hit)bu_log("\thit X %s-wall\n", s);
			else	bu_log("\tmiss X %s-wall\n", s);
		}
		break;
	case BBSURF(YMIN) :	/* Intersect Y wall of cell */
	case BBSURF(YMAX) :
		hit = isect_cell_y_wall(isect, cell, surf, dist, pt);
		if (RT_G_DEBUG & DEBUG_HF) {
			if (hit)bu_log("\thit Y %s-wall\n", s);
			else	bu_log("\tmiss Y %swall\n", s);
		}
		break;
d1163 1
a1163 17
	case BBSURF(ZMIN) :
		hit = isect_cell_z_wall(isect, cell, surf, dist, pt);
		if (RT_G_DEBUG & DEBUG_HF) {
			if (hit)bu_log("\thit ZMIN %s-wall\n", s);
			else	bu_log("\tmiss ZMIN %s-wall\n", s);
		}
		break;
	case BBSURF(ZMAX) :
		hit = 0; /* can't actually hit the top of the bbox */
		break;
	default :
		bu_log("\t%s:%d pixel(%d,%d) surface %d ", __FILE__, __LINE__,
			isect->ap->a_x, isect->ap->a_y, surf);
		bu_log("\tbad surface to intersect\n");
		longjmp(isect->env, 1);
	}
	return hit;
d1166 1
a1166 7


/*	Intersect a ray with a single "cell" (bounded by 4 values) of 
 *	the DSP.  This consists of 2 triangles for the top and 5 quadrilateral
 *	plates for the sides and bottom.
 *
 *       Cell		  Miss above zone
d1168 3
a1170 8
 *	*--__       ----*
 *	|\   --*	|
 *	| \  /  \	| interect zone
 *	|  *__   \	|
 *	|  |  --__* ----*
 *	|  |      |
 *	|  |      |	   Under zone
 *	|  |      |
d1172 14
a1185 8
static void
isect_ray_cell(isect, cs)
struct isect_stuff *isect;
struct cell_stuff *cs;
{
	unsigned short	cell_min;
	unsigned short	cell_max;
	int hit;
d1187 5
a1191 1
	RT_DSP_CK_MAGIC(isect->dsp);
d1193 4
a1196 2
	cell_minmax(isect->dsp, cs->grid_cell[X], cs->grid_cell[Y],
		&cell_min, &cell_max);
d1198 16
a1213 16
	if (RT_G_DEBUG & DEBUG_HF) {
		plot_cell_ray(isect, cs->grid_cell, cs->curr_pt, cs->next_pt,
				0, 0.0, 0, 0.0);
	}

	/* see if we can just skip ahead 1 cell */
	if (( cs->rising && cs->curr_pt[Z] > cell_max) ||
	    (!cs->rising && cs->next_pt[Z] > cell_max) ) {
		/* miss above zone */
		if (RT_G_DEBUG & DEBUG_HF) bu_log("\tmiss above\n");

		return;
	}

	/* if the ray passes completely under the the intersection zone
	 * we can just make note of that and move on.
a1214 9
	if ( (!cs->rising && cs->curr_pt[Z] < cell_min) ||
	     (cs->rising && cs->next_pt[Z] < cell_min) ) {
		/* in base */
		if (!isect->sp_is_valid) {
			/* entering in base */
			INHIT(isect, cs->curr_dist, cs->cell_insurf,
				cs->grid_cell, 
				dsp_pl[BBSURF(cs->cell_insurf)]);
		}
d1216 4
a1219 13
		/* extend segment out-point to the end of this cell */
		OUTHIT(isect, cs->next_dist, cs->cell_outsurf, 
			cs->grid_cell,
			dsp_pl[BBSURF(cs->cell_outsurf)]);

	     	if (BBSURF(cs->cell_outsurf) == ZMIN ||
		    BBSURF(cs->cell_outsurf) == XMIN ||
		    BBSURF(cs->cell_outsurf) == XMAX ||
		    BBSURF(cs->cell_outsurf) == YMIN ||
		    BBSURF(cs->cell_outsurf) == YMAX ) {
	     		/* we're leaving the DSP */
	     		HIT_COMMIT(isect);
	     	}
d1221 5
a1225 2
		return;
	}
d1227 1
a1227 4
	/* At this point, we know that the ray has some componenet
	 * in the intersection zone, so we must actually do the ray/cell
	 * intersection
	 */
d1230 5
d1236 1
a1236 5
	/* intersect */
	if (RT_G_DEBUG & DEBUG_HF) 
		bu_log("\tintersect %d %d X %s\n", cell_min, cell_max, 
				(cs->rising?"rising":"falling") );

d1238 4
d1243 1
a1243 17
	/* find out if we hit the inbound cell wall */
	if (!isect->sp_is_valid) {
		hit = isect_pt_wall(isect, cs->grid_cell, 
			cs->cell_insurf, cs->curr_dist, cs->curr_pt, "in");
		if (hit) {
			INHIT(isect, cs->curr_dist, cs->cell_insurf,
				cs->grid_cell, 
				dsp_pl[BBSURF(cs->cell_insurf)]);
			if (RT_G_DEBUG & DEBUG_HF) 
				bu_log("\thit inbound wall at %g (%g %g %g)\n",
						cs->curr_dist,
						V3ARGS(cs->curr_pt));
		} else
			if (RT_G_DEBUG & DEBUG_HF) 
				bu_log("\tmissed inbound wall %g (%g %g %g)\n",
						cs->curr_dist,
						V3ARGS(cs->curr_pt));
d1246 20
a1265 3
	/*
	 * This is where we actually intersect the ray with the top of
	 * the cell.
d1267 22
a1288 1
	isect_ray_triangles(isect, cs->grid_cell, cs->curr_pt, cs->next_pt);
d1290 71
d1362 1
d1364 1
a1364 9
	if (isect->sp_is_valid) {
		hit = isect_pt_wall(isect, cs->grid_cell, 
			cs->cell_outsurf, cs->next_dist, cs->next_pt, "out");
		if (hit) {
			OUTHIT(isect, cs->next_dist, cs->cell_outsurf, 
				cs->grid_cell,
				dsp_pl[BBSURF(cs->cell_outsurf)]);
		}
	}
a1366 1

d1368 2
a1369 1
 *	Intersect a ray with the whole DSP
d1373 1
a1373 2
isect_ray_dsp(isect)
struct isect_stuff *isect;
d1375 171
a1545 25
	point_t	bbin_pt;	/* DSP Bounding Box entry point */
	double	bbin_dist;
	point_t	bbout_pt;	/* DSP Bounding Box exit point */
	int	bbout_cell[3];	/* grid cell of last point in bbox */
	point_t curr_pt;	/* entry pt into a cell */
	double	curr_dist;	/* dist along ray to curr_pt */
	point_t	next_pt;	/* The out point of the current cell */


	int	curr_cell[3];	/* grid cell of current point */
	int	rising;		/* boolean:  Ray Z dir sign is positive */
	int	stepX, stepY;	/* signed step delta for grid cell marching */
	int	insurfX, outsurfX;
	int	insurfY, outsurfY;

	double	tDX;		/* dist along ray to span 1 cell in X dir */
	double	tDY;		/* dist along ray to span 1 cell in Y dir */

	double	out_dist;

	double	tX, tY;	/* dist along ray from hit pt. to next cell boundary */
	struct cell_stuff cs;

	if (RT_G_DEBUG & DEBUG_HF) {
		bu_log("isect_ray_dsp()\n");
d1547 76
a1624 16
	/* compute BBox entry point and starting grid cell */
	bbin_dist = isect->bbox.in_dist;
	VJOIN1(bbin_pt, isect->r.r_pt, bbin_dist, isect->r.r_dir);

	out_dist = isect->bbox.out_dist;
	VJOIN1(bbout_pt, isect->r.r_pt, out_dist, isect->r.r_dir);

	if (RT_G_DEBUG & DEBUG_HF) {
		bu_log("  r_pt: %g %g %g  dir: %g %g %g\n",
		       V3ARGS(isect->r.r_pt),
		       V3ARGS(isect->r.r_dir));
		bu_log(" in_pt: %g %g %g  dist: %g\n",
		       V3ARGS(bbin_pt), bbin_dist);
		bu_log("out_pt: %g %g %g  dist: %g\n",
		       V3ARGS(bbout_pt), out_dist);
	}
d1626 7
d1634 9
a1643 3
	VMOVE(curr_cell, bbin_pt);	/* int/float conversion */
	if (curr_cell[X] >= XSIZ(isect->dsp)) curr_cell[X]--;
	if (curr_cell[Y] >= YSIZ(isect->dsp)) curr_cell[Y]--;
d1645 1
d1647 2
a1648 3
	VMOVE(bbout_cell, bbout_pt);	/* int/float conversion */
	if (bbout_cell[X] >= XSIZ(isect->dsp)) bbout_cell[X]--;
	if (bbout_cell[Y] >= YSIZ(isect->dsp)) bbout_cell[Y]--;
d1650 2
a1651 2
	if (RT_G_DEBUG & DEBUG_HF) {
		vect_t t;
d1653 1
a1653 3
		MAT4X3PNT(t, isect->dsp->dsp_i.dsp_stom, bbin_pt);
		bu_log(" in cell(%4d,%4d)  pt(%g %g %g) ss_dist:%g\n",
			V2ARGS(curr_cell), V3ARGS(t), bbin_dist);
d1655 7
a1661 3
		MAT4X3PNT(t, isect->dsp->dsp_i.dsp_stom, bbout_pt);
		bu_log("out cell(%4d,%4d)  pt(%g %g %g) ss_dist:%g\n",
			V2ARGS(	bbout_cell), V3ARGS(t), out_dist);
d1663 4
a1666 2

	rising = (isect->r.r_dir[Z] > 0.); /* compute Z direction */
d1669 3
d1673 4
a1676 19
	/* Compute stepping directions and distances for both
	 * X and Y axes
	 */
	tX = tY = bbin_dist;
	if (isect->r.r_dir[X] < 0.0) {
		stepX = -1;	/* cell delta for stepping X dir on ray */
		insurfX = BBSURF(XMAX);
		outsurfX = BBSURF(XMIN);

		/* tDX is the distance along the ray we have to travel
		 * to traverse a cell (travel a unit distance) along the
		 * X axis of the grid
		 */
		tDX = -1.0 / isect->r.r_dir[X];

		/* tX is the distance along the ray to the first cell 
 		 * boundary in the X direction beyond bbin_pt
		 */
		tX += (curr_cell[X] - bbin_pt[X]) / isect->r.r_dir[X];
d1678 3
a1680 4
	} else {
		stepX = 1;
		insurfX = BBSURF(XMIN);
		outsurfX = BBSURF(XMAX);
d1682 2
a1683 1
		tDX = 1.0 / isect->r.r_dir[X];
d1685 1
a1685 6
		if (isect->r.r_dir[X] > 0.0) {
			tX += ((curr_cell[X]+1) - bbin_pt[X])
					/
				 isect->r.r_dir[X];
		} else
			tX = MAX_FASTF;
d1688 2
a1689 4
	if (isect->r.r_dir[Y] < 0) {
		stepY = -1;
		insurfY = BBSURF(YMAX);
		outsurfY = BBSURF(YMIN);
d1691 13
a1703 1
		tDY = -1.0 / isect->r.r_dir[Y];
d1705 1
a1705 1
		tY += (curr_cell[Y] - bbin_pt[Y]) / isect->r.r_dir[Y];
d1707 3
a1709 14
	} else {
		stepY = 1;
		insurfY = BBSURF(YMIN);
		outsurfY = BBSURF(YMAX);

		tDY = 1.0 / isect->r.r_dir[Y];

		if (isect->r.r_dir[Y] > 0.0) {
			tY += ((curr_cell[Y]+1) - bbin_pt[Y])
					/
				isect->r.r_dir[Y];
		} else
			tY = MAX_FASTF;
	}
d1711 32
a1742 11

	if (RT_G_DEBUG & DEBUG_HF) {
		point_t t;

		VJOIN1(t, isect->r.r_pt, tX, isect->r.r_dir);
		bu_log("stepX:%d tDX:%g tX:%g next: %g %g %g\n", 
			stepX, tDX, tX, V3ARGS(t));

		VJOIN1(t, isect->r.r_pt, tY, isect->r.r_dir);
		bu_log("stepY:%d tDY:%g tY:%g next: %g %g %g\n",
			stepY,  tDY, tY, V3ARGS(t));
d1744 1
a1744 2
/*	if (tX > out_dist) tX = out_dist; */
/*	if (tY > out_dist) tY = out_dist; */
d1747 1
a1747 72
	VMOVE(curr_pt, bbin_pt);
	curr_dist = bbin_dist;


	/* precompute some addresses for parameters we're going to
	 * pass frequently to cell_isect();
	 */
	cs.grid_cell = curr_cell;
	cs.curr_dist = curr_dist;
	cs.curr_pt = curr_pt;
	cs.rising = rising;
	cs.next_pt = next_pt;
	cs.cell_insurf = BBSURF(isect->bbox.in_surf);


	while ( (out_dist - cs.curr_dist) > isect->tol->dist) {
		if (RT_G_DEBUG & DEBUG_HF) {
			bu_log("Step to cell %d,%d curr_dist %g out_dist %g tX:%g tY:%g\n",
				cs.grid_cell[X], cs.grid_cell[Y],
				cs.curr_dist, out_dist, tX, tY);
		}


		if ( tX > out_dist && tY > out_dist ) {
			VJOIN1(cs.next_pt, isect->r.r_pt,
				out_dist, isect->r.r_dir);

			cs.cell_outsurf = BBSURF(isect->bbox.out_surf);
			cs.next_dist = out_dist;

			isect_ray_cell(isect, &cs);

			cs.curr_dist = out_dist;



		} else if (tX < tY) {
			VJOIN1(cs.next_pt, isect->r.r_pt, tX, isect->r.r_dir);
			cs.cell_outsurf = outsurfX;
			cs.next_dist = tX;

			isect_ray_cell(isect, &cs);

			cs.curr_dist = cs.next_dist;
			cs.grid_cell[X] += stepX;
			cs.cell_insurf = insurfX;
			tX += tDX;
		} else {
			VJOIN1(cs.next_pt, isect->r.r_pt, tY, isect->r.r_dir);
			cs.cell_outsurf = outsurfY;
			cs.next_dist = tY;

			isect_ray_cell(isect, &cs);

			cs.curr_dist = cs.next_dist;
			cs.grid_cell[Y] += stepY;
			cs.cell_insurf = insurfY;
			tY += tDY;
		}
		VMOVE(cs.curr_pt, cs.next_pt);
	}

	if (isect->sp_is_valid && !isect->sp_is_done) {
		OUTHIT( isect, 
		isect->bbox.out_dist,
		isect->bbox.out_surf,
		bbout_cell,
		dsp_pl[BBSURF(isect->bbox.out_surf)]);


		HIT_COMMIT( isect );
	}
d1749 121
a1871 5





a1896 1
	static const int junk[2] = { 0, 0 };
d1898 11
d1910 3
a1917 9

	}

	if (RT_G_DEBUG & DEBUG_HF) {
		bu_log("rt_dsp_shot(pt:(%g %g %g)\n\tdir[%g]:(%g %g %g))\n    pixel(%d,%d)\n",
			V3ARGS(rp->r_pt),
			MAGNITUDE(rp->r_dir),
			V3ARGS(rp->r_dir),
			ap->a_x, ap->a_y);
a1918 4
	RT_DSP_CK_MAGIC(dsp);
	BU_CK_VLS(&dsp->dsp_i.dsp_name);
	BU_CK_MAPPED_FILE(dsp->dsp_i.dsp_mp);

d1928 1
a1928 9
	if (RT_G_DEBUG & DEBUG_HF) {
		bn_mat_print("mtos", dsp->dsp_i.dsp_mtos);
		bu_log("Solid space ray pt:(%g %g %g)\n", V3ARGS(isect.r.r_pt));
		bu_log("\tdir[%g]: [%g %g %g]\n\tunit_dir(%g %g %g)\n",
			MAGNITUDE(dir),
			V3ARGS(dir),
			V3ARGS(isect.r.r_dir));
	}

d1935 3
a1938 3
	/* intersect ray with bounding cube */
	if ( isect_ray_bbox(&isect) == 0)
		return 0;
d1940 4
d1945 5
a1949 2
	BU_LIST_INIT(&isect.seglist);
	isect.sp = (struct seg *)NULL;
d1951 6
a1956 1
	if (isect.minbox.in_surf < 5 && isect.minbox.out_surf < 5 ) {
d1958 11
d1970 9
a1978 21
		/*  We actually hit and exit the dsp BELOW the min value.
		 *  For example:
		 *			     o ray origin
		 *	     /\dsp	    /
		 *	   _/  \__   /\_   /
		 *	_ |       \_/   | / ray
		 *	| |		|/
		 * Minbox |		*in point
		 *	| |	       /|
		 *	- +-----------*-+
		 *		     / out point
		 */

		inhit( &isect, isect.minbox.in_dist,
			BBSURF(isect.minbox.in_surf),
			junk, 
			dsp_pl[isect.minbox.in_surf], __FILE__, __LINE__);

		OUTHIT( (&isect), isect.minbox.out_dist,
			BBSURF(isect.minbox.out_surf), junk,
			dsp_pl[isect.minbox.out_surf]);
a1979 1
		HIT_COMMIT( (&isect) );
d1981 2
a1982 1
	} else {
a1983 3
		/* intersect ray with dsp data */
		isect_ray_dsp(&isect);
	}
d1993 2
a1994 2
		if (RT_G_DEBUG & DEBUG_HF) {
			bu_log("solid in:%6g out:%6g\n",
a2153 1
	BU_CK_MAPPED_FILE(dsp->dsp_i.dsp_mp);
d2155 8
d2179 2
a2180 2
		if (RT_G_DEBUG & DEBUG_HF)
			bu_log("no Interpolation needed\n",
d2185 6
d2481 10
a2490 2
	BU_CK_MAPPED_FILE(dsp->dsp_i.dsp_mp);
	bu_close_mapped_file(dsp->dsp_i.dsp_mp);
a3065 5

#if 0
	bu_log("export5");
	dsp_dump(dsp_ip); 
#endif
@


1.79
log
@CONST to const
@
text
@d50 1
a50 1
static const char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.78 2001/04/05 13:07:44 jra Exp $ (BRL)";
d75 1
a75 1
#define dlog if (rt_g.debug & DEBUG_HF) bu_log	
d382 1
a382 1
	if (rt_g.debug & DEBUG_HF)
d418 1
a418 1
	if (rt_g.debug & DEBUG_HF)
d457 1
a457 1
	if (rt_g.debug & DEBUG_HF) {
d514 1
a514 1
	if (rt_g.debug & DEBUG_HF) {
d559 1
a559 1
	if (rt_g.debug & DEBUG_HF) {
d596 1
a596 1
	if (rt_g.debug & DEBUG_HF) {
d622 1
a622 1
	if (rt_g.debug & DEBUG_HF)
d634 1
a634 1
		if (rt_g.debug & DEBUG_HF)
d642 1
a642 1
				if (rt_g.debug & DEBUG_HF)
d651 1
a651 1
		if (rt_g.debug & DEBUG_HF)
d679 1
a679 1
	if (rt_g.debug & DEBUG_HF) {
d723 1
a723 1
	if (rt_g.debug & DEBUG_HF) {
d1133 1
a1133 1
	if (rt_g.debug & DEBUG_HF) {
d1196 1
a1196 1
	if (rt_g.debug & DEBUG_HF) {
d1236 1
a1236 1
	if (rt_g.debug & DEBUG_HF) {
d1242 1
a1242 1
	if (rt_g.debug & DEBUG_HF && plot_em)
d1249 1
a1249 1
		if (rt_g.debug & DEBUG_HF) {
d1269 1
a1269 1
			if (rt_g.debug & DEBUG_HF)
d1280 1
a1280 1
			if (rt_g.debug & DEBUG_HF)
d1322 1
a1322 1
			if (rt_g.debug & DEBUG_HF)
d1329 1
a1329 1
			if (rt_g.debug & DEBUG_HF)
d1342 1
a1342 1
			if (rt_g.debug & DEBUG_HF)
d1350 1
a1350 1
			if (rt_g.debug & DEBUG_HF)
d1383 1
a1383 1
	if (rt_g.debug & DEBUG_HF) {
d1430 1
a1430 1
	if (rt_g.debug & DEBUG_HF)
d1457 1
a1457 1
	if (rt_g.debug & DEBUG_HF) {
d1502 1
a1502 1
	if (rt_g.debug & DEBUG_HF)
d1588 1
a1588 1
		if (rt_g.debug & DEBUG_HF) {
d1596 1
a1596 1
		if (rt_g.debug & DEBUG_HF) {
d1604 1
a1604 1
		if (rt_g.debug & DEBUG_HF) {
d1652 1
a1652 1
	if (rt_g.debug & DEBUG_HF) {
d1661 1
a1661 1
		if (rt_g.debug & DEBUG_HF) bu_log("\tmiss above\n");
d1704 1
a1704 1
	if (rt_g.debug & DEBUG_HF) 
d1718 1
a1718 1
			if (rt_g.debug & DEBUG_HF) 
d1723 1
a1723 1
			if (rt_g.debug & DEBUG_HF) 
d1780 1
a1780 1
	if (rt_g.debug & DEBUG_HF) {
d1792 1
a1792 1
	if (rt_g.debug & DEBUG_HF) {
d1813 1
a1813 1
	if (rt_g.debug & DEBUG_HF) {
d1889 1
a1889 1
	if (rt_g.debug & DEBUG_HF) {
d1920 1
a1920 1
		if (rt_g.debug & DEBUG_HF) {
d2013 1
a2013 1
		if (rt_g.debug & DEBUG_HF)
d2020 1
a2020 1
	if (rt_g.debug & DEBUG_HF) {
d2040 1
a2040 1
	if (rt_g.debug & DEBUG_HF) {
d2105 1
a2105 1
		if (rt_g.debug & DEBUG_HF) {
d2136 1
a2136 1
		if (rt_g.debug & DEBUG_HF) {
d2143 1
a2143 1
	if (rt_g.debug & DEBUG_HF) {
d2174 1
a2174 1
	if (rt_g.debug & DEBUG_HF)
d2269 1
a2269 1
 	if (rt_g.debug & DEBUG_HF)
d2275 1
a2275 1
 	if (rt_g.debug & DEBUG_HF)
d2284 1
a2284 1
		if (rt_g.debug & DEBUG_HF)
d2297 1
a2297 1
	if (rt_g.debug & DEBUG_HF)
d2305 1
a2305 1
	if (rt_g.debug & DEBUG_HF) {
d2327 1
a2327 1
	if (rt_g.debug & DEBUG_HF) {
d2369 1
a2369 1
	if (rt_g.debug & DEBUG_HF)
d2408 1
a2408 1
	if (rt_g.debug & DEBUG_HF)
d2424 1
a2424 1
		if (rt_g.debug & DEBUG_HF)
d2429 1
a2429 1
	if (rt_g.debug & DEBUG_HF) {
d2457 1
a2457 1
	if (rt_g.debug & DEBUG_HF)
d2558 1
a2558 1
	if (rt_g.debug & DEBUG_HF)
d2577 1
a2577 1
	if (rt_g.debug & DEBUG_HF)
d2592 1
a2592 1
	if (rt_g.debug & DEBUG_HF)
d2618 1
a2618 1
	if (rt_g.debug & DEBUG_HF)
d2781 1
a2781 1
	if (rt_g.debug & DEBUG_HF)
d2868 1
a2868 1
	if (rt_g.debug & DEBUG_HF)
d2876 1
a2876 1
	if (rt_g.debug & DEBUG_HF)
d2910 1
a2910 1
		if (rt_g.debug & DEBUG_HF)
d2915 1
a2915 1
		if (rt_g.debug & DEBUG_HF)
d2959 1
a2959 1
	if (rt_g.debug & DEBUG_HF)
d3005 1
a3005 1
	if (rt_g.debug & DEBUG_HF) {
d3057 1
a3057 1
	if (rt_g.debug & DEBUG_HF)	
d3225 1
a3225 1
	if (rt_g.debug & DEBUG_HF)
d3249 1
a3249 1
	if (rt_g.debug & DEBUG_HF)
@


1.78
log
@Mods to get import to work again for v4 datbases
@
text
@d50 1
a50 1
static const char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.77 2001/04/02 21:38:08 morrison Exp $ (BRL)";
d157 1
a157 1
static CONST vect_t	dsp_pl[BBOX_PLANES] = {
d201 1
a201 1
CONST struct bu_structparse rt_dsp_parse[] = {
d210 1
a210 1
CONST struct bu_structparse rt_dsp_ptab[] = {
d226 1
a226 1
CONST struct rt_dsp_internal *dsp_ip;
d263 1
a263 1
CONST struct rt_dsp_internal *dsp_ip;
d327 1
a327 1
register CONST struct soltab *stp;
d329 1
a329 1
	register CONST struct dsp_specific *dsp =
d2009 1
a2009 1
	static CONST int junk[2] = { 0, 0 };
d2146 1
a2146 1
		static CONST plane_t plane = {0.0, 0.0, -1.0, 0.0};
d2605 2
a2606 2
CONST struct rt_tess_tol *ttol;
CONST struct bn_tol	*tol;
d2776 2
a2777 2
CONST struct rt_tess_tol *ttol;
CONST struct bn_tol	*tol;
d2936 3
a2938 3
CONST struct bu_external	*ep;
register CONST mat_t		mat;
CONST struct db_i		*dbip;
d3025 1
a3025 1
CONST struct rt_db_internal	*ip;
d3027 1
a3027 1
CONST struct db_i		*dbip;
d3082 3
a3084 3
CONST struct bu_external	*ep;
register CONST mat_t		mat;
CONST struct db_i		*dbip;
d3145 1
a3145 1
CONST struct rt_db_internal	*ip;
d3147 1
a3147 1
CONST struct db_i		*dbip;
d3216 1
a3216 1
CONST struct rt_db_internal *ip;
@


1.77
log
@Deprecated bn_mat_copy() for new performance version of MAT_COPY() macro in h/vmath.h.
@
text
@d50 1
a50 1
static const char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.76 2001/03/31 01:57:06 morrison Exp $ (BRL)";
d194 1
d2909 1
a2991 1

@


1.76
log
@Deprecated bn_mat_idn() and bn_mat_zero(), updated calls to h/vmath.h's MAT_IDN() and MAT_ZERO() performance improved macros.
@
text
@d50 1
a50 1
static const char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.75 2001/03/23 22:34:31 butler Exp $ (BRL)";
d2901 1
a2901 1
	bn_mat_copy(tmp, dsp_ip->dsp_stom);
@


1.75
log
@Changes to support new DSP primitive representation
@
text
@d50 1
a50 1
static const char RCSdsp[] = "@@(#)$Header: /n/tgm/d/CVS/brlcad/librt/g_dsp.c,v 1.74 2001/03/19 20:03:33 butler Exp $ (BRL)";
d2983 2
a2984 2
	bn_mat_idn(dsp_ip->dsp_stom);
	bn_mat_idn(dsp_ip->dsp_mtos);
@


1.74
log
@test of check-in on merged file
@
text
@d50 1
a50 1
static const char RCSdsp[] = "@@(#)$Header: /d/CVS/brlcad/librt/g_dsp.c,v 1.73 2000/10/24 00:02:25 butler Exp $ (BRL)";
d68 7
d184 11
d201 1
a201 1
	{"%S",	DSP_NAME_LEN, "file", DSP_O(dsp_file), BU_STRUCTPARSE_FUNC_NULL },
d210 1
a210 1
	{"%S",	DSP_NAME_LEN, "file", DSP_O(dsp_file), BU_STRUCTPARSE_FUNC_NULL },
d215 1
a215 1
	{"",	0, (char *)0, 0,			BU_STRUCTPARSE_FUNC_NULL }
d218 1
d223 1
a223 1
dsp_print(vls, dsp_ip)
d229 1
a229 1
	BU_CK_VLS(&dsp_ip->dsp_file);
d234 1
a234 1
		       bu_vls_addr(&dsp_ip->dsp_file),
d259 62
d334 1
a334 1
	BU_CK_VLS(&dsp->dsp_i.dsp_file);
d336 8
a343 1
	dsp_print(&vls, &(dsp->dsp_i) );
d387 1
a387 1
	BU_CK_VLS(&dsp_ip->dsp_file);
d2027 1
a2027 1
	BU_CK_VLS(&dsp->dsp_i.dsp_file);
d2264 1
a2264 1
	BU_CK_VLS(&dsp->dsp_i.dsp_file);
d2790 2
a2791 4
/*
 *	D S P _ G E T _ D A T A
 *
 *  Handle things common to both the v4 and v5 database.
d2793 4
a2796 2
 *  This include applying the modelling transform, and fetching the
 *  actual data.
d2799 1
a2799 1
dsp_get_data(struct rt_dsp_internal	*dsp_ip,
a2804 1
	mat_t				tmp;
d2806 1
a2806 2
	int				count;
	int				in_cookie, out_cookie;
a2807 5
	/* Apply Modeling transform */
	bn_mat_copy(tmp, dsp_ip->dsp_stom);
	bn_mat_mul(dsp_ip->dsp_stom, mat, tmp);
	
	bn_mat_inv(dsp_ip->dsp_mtos, dsp_ip->dsp_stom);
d2812 1
a2812 1
			bu_vls_addr(&dsp_ip->dsp_file), "dsp");
d2848 77
d2948 1
a2948 1
               bu_vls_addr(&dsp_ip->dsp_file), _s);\
d2978 1
a2978 1
	 * memset(&dsp_ip->dsp_file[0], 0, DSP_NAME_LEN); 
d3038 1
a3038 1
	BU_CK_VLS(&dsp_ip->dsp_file);
d3100 2
a3101 1
	
d3122 3
d3126 2
a3127 2
	bu_vls_init( &dsp_ip->dsp_file );
	bu_vls_strcpy( &dsp_ip->dsp_file, (char *)cp );
d3157 6
a3162 1
	name_len = bu_vls_strlen(&dsp_ip->dsp_file) + 1;
d3165 1
a3165 1
	ep->ext_nbytes = 138 + name_len;
d3194 4
a3197 1
	strncpy((char *)cp, bu_vls_addr(&dsp_ip->dsp_file), name_len);
d3229 1
a3229 1
	dsp_print(&vls, dsp_ip);
d3260 4
d3267 2
a3268 2
	if (BU_VLS_IS_INITIALIZED(&dsp_ip->dsp_file)) 
		bu_vls_free(  &dsp_ip->dsp_file );
@


1.73
log
@Initializations to eliminate compiler warnings
@
text
@d50 1
a50 1
static const char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.72 2000/08/23 00:35:58 butler Exp $ (BRL)";
d429 2
a430 2
		bu_log("line %d New in pt(%g %g %g) ss_dist %g surf: %d\n",
			__LINE__, V3ARGS(in), dist, surf);
d474 2
a475 2
		bu_log("line %d New out pt(%g %g %g) ss_dist %g surf:%d\n",
			__LINE__, V3ARGS(out), dist, surf);
d1594 10
d1877 1
a1877 1
	if (isect->sp_is_valid) {
d1882 1
a1882 1
		dsp_pl[isect->bbox.out_surf]);
@


1.72
log
@compiler warnings removed
@
text
@d50 1
a50 1
static const char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.71 2000/08/21 02:02:29 butler Exp $ (BRL)";
d528 1
a528 1
	register double NdotD;
@


1.71
log
@Massive compilation warnings eliminated
@
text
@d50 1
a50 1
static const char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.70 2000/08/11 00:42:23 mike Exp $ (BRL)";
d1033 2
a1034 2
	double	dist1;
	double	dist2;
@


1.70
log
@
Fixed args to bn_mat_inv() to be in intended order.
@
text
@d50 1
a50 1
static const char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.69 2000/07/25 17:54:40 butler Exp $ (BRL)";
d1107 1
a1107 1
	if (rt_g.debug & DEBUG_HF)
d1110 1
a1110 1

d1147 1
a1147 1
	if (rt_g.debug & DEBUG_HF)
d1150 1
a1150 1

@


1.69
log
@housekeeping of unused variables
@
text
@d50 1
a50 1
static const char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.68 2000/07/14 19:43:51 butler Exp $ (BRL)";
d2947 1
a2947 2
	bn_mat_inv(dsp_ip->dsp_stom, dsp_ip->dsp_mtos);

d2958 1
a2958 1
		IMPORT_FAIL("DSP data");
@


1.68
log
@Change so that local2mm is applied to the correct matrix
@
text
@d50 1
a50 1
static const char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.67 2000/07/10 23:01:30 mike Exp $ (BRL)";
d2108 1
a2108 1
	point_t A, B, C, D, E, tmp;
d2153 1
a2153 2
	vect_t N, t, tmp, A, B, C, D, AB, AC, AD, N_orig;
	int cell[2];
d2164 1
d2773 4
a2776 4
	mat_t tmp;
	struct bu_mapped_file		*mf;
	int				count;
	int				in_cookie, out_cookie;
a2917 1
	unsigned short 		name_len;
d2919 2
a2920 1
	mat_t			tmp;
a2977 3
	struct rt_dsp_internal	dsp;
	union record		*rec;
	struct bu_vls		str;
a2978 1
	register unsigned long	tmp;
@


1.67
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d50 1
a50 1
static const char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.66 2000/07/08 01:29:29 mike Exp $ (BRL)";
d2884 1
a2884 1
	dsp.dsp_mtos[15] /= local2mm;
d2945 1
a2945 1
	ntohd((unsigned char *)dsp_ip->dsp_mtos, cp, 16);
d3014 1
a3014 1
	dsp_ip->dsp_mtos[15] /= local2mm;
d3016 1
a3016 1
	htond(cp, (unsigned char *)dsp_ip->dsp_mtos, 16);
@


1.66
log
@
Fixed lint
@
text
@d50 1
a50 1
static char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.65 2000/06/30 20:10:32 butler Exp $ (BRL)";
@


1.65
log
@Steps closer to V5 database conversion of HF's
@
text
@d50 1
a50 1
static char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.64 2000/06/30 15:38:02 mike Exp $ (BRL)";
d2956 1
a2956 1
	bu_vls_strcpy( &dsp_ip->dsp_file, cp );
d3022 1
a3022 1
	strncpy(cp, bu_vls_addr(&dsp_ip->dsp_file), name_len);
@


1.64
log
@
export methods should not init the external structure, just check them.
@
text
@d50 1
a50 1
static char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.63 2000/06/30 15:31:14 mike Exp $ (BRL)";
d162 15
d187 2
a188 2
	{"%f", 16, "stom", DSP_AO(dsp_stom), BU_STRUCTPARSE_FUNC_NULL },
	{"",	0, (char *)0, 0,			BU_STRUCTPARSE_FUNC_NULL }
d210 1
d214 5
a218 2
	bu_vls_printf( vls, "Displacement Map\n  file='%s' w=%d n=%d sm=%d\n",
		bu_vls_addr(&dsp_ip->dsp_file), dsp_ip->dsp_xcnt, dsp_ip->dsp_ycnt, dsp_ip->dsp_smooth);
d221 1
d223 2
a224 1
	bu_vls_printf( vls, "  V=(%g %g %g)mm\n", v);
a237 1

d253 1
d258 2
a259 1
	bu_vls_free( &vls );
d299 2
d1929 1
d2165 5
d2821 2
a2822 1
		bu_vls_free( &str );
d2842 2
a2843 1
	bu_vls_free( &str );
d2870 2
d2896 1
a2896 2
	bu_vls_free( &str );

d3056 2
a3057 1
	bu_vls_free( &vls );
d3088 5
a3092 1
	bu_vls_free(  &dsp_ip->dsp_file );
@


1.63
log
@
The import/export and import5/export5 methods must NOT
re-initialize their rt_db_internal* pointer, they should just check it.
@
text
@d50 1
a50 1
static char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.62 2000/06/29 20:43:52 butler Exp $ (BRL)";
d2839 1
a2839 1
	BU_INIT_EXTERNAL(ep);
d2959 1
a2959 1
	BU_INIT_EXTERNAL(ep);
@


1.62
log
@Patches for Irix compilation
@
text
@d50 1
a50 1
static char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.61 2000/06/29 19:45:57 butler Exp $ (BRL)";
d2771 1
a2771 1
	RT_INIT_DB_INTERNAL( ip );
d2893 1
a2893 1
	RT_INIT_DB_INTERNAL( ip );
@


1.61
log
@Converted g_dsp and g_xxx.c to V5 database
@
text
@d50 1
a50 1
static char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.60 2000/06/29 14:52:03 butler Exp $ (BRL)";
d2841 1
a2841 1
	ep->ext_buf = (genptr_t)bu_calloc( 1, ep->ext_nbytes, "dsp external");
d2912 1
a2912 1
	ntohd((char *)dsp_ip->dsp_mtos, cp, 16);
d2961 2
a2962 2
	cp = (unsigned char *)ep->ext_buf = 
		(genptr_t)bu_malloc( ep->ext_nbytes, "dsp external");
d2983 1
a2983 1
	htond(cp, (char *)dsp_ip->dsp_mtos, 16);
@


1.60
log
@Changed to use VLS for filename, added V5 database support
@
text
@d50 1
a50 1
static char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.59 2000/04/12 02:34:31 mike Exp $ (BRL)";
d198 1
a198 1
	bu_vls_printf( vls, "Displacement Map\n  file='%s' xs=%d ys=%d sm=%d\n",
d2662 42
d2705 21
d2795 1
a2795 1
	
d2801 2
a2802 38
	/* Apply Modeling transoform */
	bn_mat_copy(tmp, dsp_ip->dsp_stom);
	bn_mat_mul(dsp_ip->dsp_stom, mat, tmp);
	
	bn_mat_inv(dsp_ip->dsp_mtos, dsp_ip->dsp_stom);

	/* get file */
	mf = dsp_ip->dsp_mp = 
		bu_open_mapped_file_with_path(dbip->dbi_filepath,
			bu_vls_addr(&dsp_ip->dsp_file), "dsp");
	if (!mf) {
		IMPORT_FAIL("unable to open");
	}
	if (dsp_ip->dsp_mp->buflen != dsp_ip->dsp_xcnt*dsp_ip->dsp_ycnt*2) {
		IMPORT_FAIL("buffer wrong size");
	}

	in_cookie = bu_cv_cookie("nus"); /* data is network unsigned short */
	out_cookie = bu_cv_cookie("hus");

	if ( bu_cv_optimize(in_cookie) != bu_cv_optimize(out_cookie) ) {
		int got;
		/* if we're on a little-endian machine we convert the
		 * input file from network to host format
		 */
		count = dsp_ip->dsp_xcnt * dsp_ip->dsp_ycnt;
		mf->apbuflen = count * sizeof(unsigned short);
		mf->apbuf = bu_malloc(mf->apbuflen, "apbuf");

		got = bu_cv_w_cookie(mf->apbuf, out_cookie, mf->apbuflen,
				     mf->buf,    in_cookie, count);
		if (got != count) {
			bu_log("got %d != count %d", got, count);
			bu_bomb("\n");
		}
		dsp_ip->dsp_buf = dsp_ip->dsp_mp->apbuf;
	} else {
		dsp_ip->dsp_buf = dsp_ip->dsp_mp->buf;
d2887 1
d2911 1
a2911 1
	/* matrix */
d2914 2
d2917 1
a2917 1
	/* smooth flag */
d2921 1
a2921 1
	/* name of data location */
d2925 4
d2960 1
a2960 1
	ep->ext_nbytes = 140 + name_len;
d2964 2
a3023 8

#if 0
	sprintf(buf, "\tV (%g, %g, %g)\n",
		dsp_ip->v[X] * mm2local,
		dsp_ip->v[Y] * mm2local,
		dsp_ip->v[Z] * mm2local );
	bu_vls_strcat( str, buf );
#endif
@


1.59
log
@
NT port, non-compat4
@
text
@d50 1
a50 1
static char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.58 2000/03/28 21:59:04 mike Exp $ (BRL)";
d168 1
a168 1
	{"%s",	DSP_NAME_LEN, "file", DSP_AO(dsp_file), BU_STRUCTPARSE_FUNC_NULL },
d177 1
a177 1
	{"%s",	DSP_NAME_LEN, "file", DSP_AO(dsp_file), BU_STRUCTPARSE_FUNC_NULL },
d199 1
a199 1
		dsp_ip->dsp_file, dsp_ip->dsp_xcnt, dsp_ip->dsp_ycnt, dsp_ip->dsp_smooth);
d2662 2
d2686 2
a2687 1
	bu_log("rt_dsp_import(%d) '%s' %s\n", __LINE__, dsp_ip->dsp_file,_s);\
d2716 3
a2718 2
	/* XXX bu_struct_parse does not set the null? */
	memset(&dsp_ip->dsp_file[0], 0, DSP_NAME_LEN); 
d2720 1
a2720 1
	dsp_ip->dsp_xs = dsp_ip->dsp_ys = dsp_ip->dsp_zs = 0.0;
d2747 1
a2747 1
			dsp_ip->dsp_file, "dsp");
d2788 1
d2841 120
d3025 2
@


1.59.2.1
log
@Fixed bogus extra out-point
@
text
@d50 1
a50 1
static char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.59 2000/04/12 02:34:31 mike Exp $ (BRL)";
d405 2
a406 2
		bu_log("line %d(%d) New in pt(%g %g %g) ss_dist %g surf: %d\n",
			__LINE__, line, V3ARGS(in), dist, surf);
d450 2
a451 2
		bu_log("line %d(%d) New out pt(%g %g %g) ss_dist %g surf:%d\n",
			__LINE__, line, V3ARGS(out), dist, surf);
d1843 1
a1843 1
	if (isect->sp_is_valid && !isect->sp_is_done) {
d1848 1
a1848 1
		dsp_pl[BBSURF(isect->bbox.out_surf)]);
@


1.59.2.2
log
@Added a check to see if ray was departing the DSP at cell boundary.  Fixes
bug and speeds up exit
@
text
@d50 1
a50 1
static char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.59.2.1 2001/01/09 22:53:09 butler Exp $ (BRL)";
d1083 1
a1083 1
	if (rt_g.debug & DEBUG_HF) {
d1086 1
a1086 1
	}
d1123 1
a1123 1
	if (rt_g.debug & DEBUG_HF) {
d1126 1
a1126 1
	}
a1569 10

	     	if (BBSURF(cs->cell_outsurf) == ZMIN ||
		    BBSURF(cs->cell_outsurf) == XMIN ||
		    BBSURF(cs->cell_outsurf) == XMAX ||
		    BBSURF(cs->cell_outsurf) == YMIN ||
		    BBSURF(cs->cell_outsurf) == YMAX ) {
	     		/* we're leaving the DSP */
	     		HIT_COMMIT(isect);
	     	}

d2083 1
a2083 1
	point_t A, C, D, E, tmp;
d2128 2
a2129 1
	vect_t N, t, tmp, A, B, C, D, N_orig;
@


1.58
log
@
Fixed arguments
@
text
@d50 1
a50 1
static char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.57 2000/03/28 21:27:51 mike Exp $ (BRL)";
d2334 1
a2334 1
 	vec_ortho( cvp->crv_pdir, hitp->hit_normal );
@


1.57
log
@
Handled conflicting defines for XMIN
@
text
@d50 1
a50 1
static char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.56 2000/03/03 01:05:03 mike Exp $ (BRL)";
d2477 1
a2477 1
struct bn_tol		*tol;
d2648 1
a2648 1
struct bn_tol		*tol;
d2846 1
a2846 1
struct rt_db_internal	*ip;
@


1.56
log
@
Corrected order of parameters for bu_open_mapped_file_with_path()
@
text
@d50 1
a50 1
static char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.55 2000/03/02 02:31:11 butler Exp $ (BRL)";
d2904 15
@


1.55
log
@Converted to search file path for dsp data
@
text
@d50 1
a50 1
static char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.54 2000/03/02 00:43:52 mike Exp $ (BRL)";
d2742 2
a2743 2
		bu_open_mapped_file_with_path(dsp_ip->dsp_file, "dsp",
					      dbip->dbi_filepath);
@


1.54
log
@
dbip args were missing from import and export methods
@
text
@d50 1
a50 1
static char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.53 2000/02/20 06:40:50 butler Exp $ (BRL)";
d2741 3
a2743 2
	mf = dsp_ip->dsp_mp = bu_open_mapped_file(dsp_ip->dsp_file, "dsp");

a2758 2
		bu_log("doing net-host conversion\n");
#if 1
a2768 1
#endif
@


1.53
log
@Changes necessary so the DSP can take all of its input in network-order.
@
text
@d50 1
a50 1
static char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.52 2000/02/19 21:06:32 butler Exp $ (BRL)";
d2669 1
a2669 1
rt_dsp_import( ip, ep, mat )
d2673 1
d2792 1
a2792 1
rt_dsp_export( ep, ip, local2mm )
d2796 1
@


1.52
log
@changed "if( " to "if (" to improve readability.  Added comments to uv()
routine.
@
text
@d50 1
a50 1
static char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.51 2000/02/11 20:23:13 butler Exp $ (BRL)";
d96 1
a96 1
	((unsigned short *)(((struct rt_dsp_internal *)_p)->dsp_mp->buf))[ \
d2678 3
d2740 3
a2742 1
	if (!(dsp_ip->dsp_mp = bu_open_mapped_file( dsp_ip->dsp_file, "dsp"))) {
d2747 26
@


1.51
log
@Cleaned up surface normal interpolation code.
@
text
@d50 1
a50 1
static char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.50 1999/12/30 15:07:16 jra Exp $ (BRL)";
d339 2
a340 2
	if( work[Y] > f )  f = work[Y];
	if( work[Z] > f )  f = work[Z];
d1071 1
a1071 1
	if( beta < 0.0 || beta > abs_NdotD ) {
d1109 1
a1109 1
	if( beta < 0.0 || beta > abs_NdotD ) {
d2368 1
d2370 2
a2371 4
	if( uvp->uv_u > 1.0 )
		uvp->uv_u = 1.0;
	if( uvp->uv_u < 0.0 )
		uvp->uv_u = 0.0;
d2373 10
a2382 4
	if( uvp->uv_v > 1.0 )
		uvp->uv_v = 1.0;
	if(  uvp->uv_v < 0.0 )
		uvp->uv_v = 0.0;
d2395 1
d2400 3
d2408 3
a2410 2
	if( NEAR_ZERO( dot_N, SMALL_FASTF ) )
	{
d2413 2
a2414 3
	}
	else
	{
d2419 1
a2419 1
	if( uvp->uv_du < 0.0 )
d2421 1
a2421 1
	if( uvp->uv_du < min_r_U )
d2424 1
a2424 1
	if( uvp->uv_dv < 0.0 )
d2426 1
a2426 1
	if( uvp->uv_dv < min_r_V )
d2572 1
a2572 1
	if( ttol->rel )  {
d2590 1
a2590 1
	if( step < 1 )  step = 1;
d2696 1
a2696 1
	if( rp->u_id != DBID_STRSOL )  {
d2737 1
a2737 1
	if( !(dsp_ip->dsp_mp = bu_open_mapped_file( dsp_ip->dsp_file, "dsp"))) {
d2772 1
a2772 1
	if( ip->idb_type != ID_DSP )  return(-1);
@


1.50
log
@Eliminated some unused variables
@
text
@d28 3
a30 2
 *  	hit_vpriv holds the cell that was hit.
 *	surfno is either  TRI1 or TRI2
d50 1
a50 1
static char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.49 1999/12/10 15:08:58 butler Exp $ (BRL)";
d231 1
d397 1
d442 1
a693 1
	bu_semaphore_acquire( RT_SEM_MODEL);
a696 1
	bu_semaphore_release( RT_SEM_MODEL);
d2056 5
d2062 1
a2062 1
compute_normal_at_gridpoint(N, dsp, x, y)
d2066 2
d2069 2
a2070 2
	/*  Gridpoint specified is "B" we compute normal based upon
	 *  A/C, D/E
d2086 2
a2087 5
	if (x < 1) {
		VSET(tmp, x, y, DSP(dsp, x, y) );
	} else {
		VSET(tmp, x-1, y, DSP(dsp, x-1, y) );
	}
d2090 2
a2091 5
	if (x >= XSIZ(dsp)) {
		VSET(tmp, x, y,  DSP(dsp, x, y) );
	} else {
		VSET(tmp, x+1, y,  DSP(dsp, x+1, y) );
	}
d2095 2
a2096 5
	if (y < 1) {
		VSET(tmp, x, y, DSP(dsp, x, y) );
	} else {
		VSET(tmp, x, y-1, DSP(dsp, x, y-1) );
	}
d2099 8
a2106 4
	if (y >= YSIZ(dsp)) {
		VSET(tmp, x, y, DSP(dsp, x, y) );
	} else {
		VSET(tmp, x, y+1, DSP(dsp, x, y+1) );
d2109 2
a2110 4
	MAT4X3PNT(E, dsp->dsp_i.dsp_stom, tmp);

	VSUB2(Vac, A, C);
	VSUB2(Vde, D, E);
d2115 1
a2116 39
	if (rt_g.debug & DEBUG_HF) {
		char buf[32];
		FILE *fd;

		VSET(tmp, x, y, DSP(dsp, x, y));
		MAT4X3PNT(B, dsp->dsp_i.dsp_stom, tmp);

		bu_semaphore_acquire( RT_SEM_MODEL);
		sprintf(buf, "dsp%02d.pl", plot_file_num++);
		bu_semaphore_release( RT_SEM_MODEL);
		bu_log("%s\n", buf);

		bu_semaphore_acquire( BU_SEM_SYSCALL);
		if ((fd=fopen(buf, "w")) != (FILE *)NULL) {
			pl_color(fd, 255, 255, 0);
			VJOIN1(tmp, B, 1.0, N);
 			pdv_3line(fd, B, tmp);

			pl_color(fd, 255, 140, 0);
			VUNITIZE(Vac);
			VUNITIZE(Vde);

			VJOIN1(tmp, B, 1.0, Vac);
			pdv_3line(fd, B, tmp);

			VJOIN1(tmp, B, 1.0, Vde);
			pdv_3line(fd, B, tmp);

			fclose(fd);
		}
		bu_semaphore_release( BU_SEM_SYSCALL);
	}






}
d2128 1
a2128 35
#if 1
 	if (rt_g.debug & DEBUG_HF)
		bu_log("rt_dsp_norm(%g %g %g,   %g %g %g)",
		V3ARGS(hitp->hit_point),
		V3ARGS(hitp->hit_normal));

/*	MAT4X3VEC(N, dsp->dsp_i.dsp_stom, hitp->hit_normal);
	VUNITIZE(N);
	VMOVE(hitp->hit_normal, N);
*/

 	if (rt_g.debug & DEBUG_HF) {
		char buf[132];
 		point_t n;
 		FILE *fd;

		bu_log("\n\t %g %g %g\n", V3ARGS(hitp->hit_normal));

		bu_semaphore_acquire( BU_SEM_SYSCALL);
		sprintf(buf, "dsp%02d.pl", plot_file_num++);

		if ((fd=fopen(buf, "w")) != (FILE *)NULL) {
			pl_color(fd, 255, 40, 40);

			pdv_3move(fd, hitp->hit_point);
			VADD2(n, hitp->hit_point, hitp->hit_normal);
			pdv_3cont(fd, n);
			fclose(fd);
		}
		bu_semaphore_release( BU_SEM_SYSCALL);


 	}
#else
	vect_t N, tmp, A, B, C, D, AB, AC, AD;
d2131 8
d2141 1
a2141 1
		bu_log("rt_dsp_norm()\n");
d2143 1
d2146 2
a2147 25
	if (hitp->hit_surfno < 0) {
		MAT4X3VEC( N, dsp->dsp_i.dsp_stom, 
			dsp_pl[ BBSURF(hitp->hit_surfno) ] );
	} else if (dsp->dsp_i.dsp_smooth) {
		if ( hitp->hit_surfno == TRI2 ||  hitp->hit_surfno == TRI1 ||
		     hitp->hit_surfno == TRI3 ||  hitp->hit_surfno == TRI4 ) {
			vect_t Anorm, Bnorm, Dnorm, Cnorm, ABnorm, CDnorm;
			double Xfrac, Yfrac;
			int x, y;
			point_t pt;
	
			x = hitp->hit_vpriv[X];
			y = hitp->hit_vpriv[Y];
	
			compute_normal_at_gridpoint(Anorm, dsp, x, y);
			compute_normal_at_gridpoint(Bnorm, dsp, x+1, y);
			compute_normal_at_gridpoint(Dnorm, dsp, x+1, y+1);
			compute_normal_at_gridpoint(Cnorm, dsp, x, y+1);
	
			VSET(A, x,   y, DSP(dsp, x, y)  );
	
			VSET(D, x+1, y+1, DSP(dsp, x+1, y+1));
	
			MAT4X3PNT(pt, dsp->dsp_i.dsp_mtos, hitp->hit_point);
	
d2149 5
a2153 2
			Xfrac = (pt[X] - A[X]) / (D[X] - A[X]);
			Yfrac = (pt[Y] - A[Y]) / (D[Y] - A[Y]);
d2155 5
a2159 2
			if (Xfrac < 0.0) Xfrac = 0.0;
			if (Xfrac > 1.0) Xfrac = 1.0;
d2161 6
a2166 2
			if (Yfrac < 0.0) Yfrac = 0.0;
			if (Yfrac > 1.0) Yfrac = 1.0;
d2168 2
a2169 3
		     	if (dsp->dsp_i.dsp_smooth == 2) {
#define SMOOTHSTEP(x)  ((x)*(x)*(3 - 2*(x)))
				Xfrac = SMOOTHSTEP( Xfrac );
d2171 4
a2174 3
				Yfrac = SMOOTHSTEP( Yfrac );
#undef SMOOTHSTEP
		     	}
d2176 4
a2179 9
			VSCALE(Anorm, Anorm, (1.0-Xfrac) );
			VSCALE(Bnorm, Bnorm,      Xfrac  );
			VADD2(ABnorm, Anorm, Bnorm);
			VUNITIZE(ABnorm);

			VSCALE(Cnorm, Cnorm, (1.0-Xfrac) );
			VSCALE(Dnorm, Dnorm,      Xfrac  );
			VADD2(CDnorm, Dnorm, Cnorm);
			VUNITIZE(CDnorm);
d2181 5
a2185 41
			VSCALE(ABnorm, ABnorm, (1.0-Yfrac) );
			VSCALE(CDnorm, CDnorm, Yfrac );
	
			VADD2(N, ABnorm, CDnorm);
			if (rt_g.debug & DEBUG_HF) {
				FILE *fd;

				VPRINT("A", A);
				VPRINT("D", D);
				VPRINT("pt", pt);
				bu_log("Xfrac:%g Yfrac:%g\n", Xfrac, Yfrac);

				bu_semaphore_acquire( RT_SEM_MODEL);
				sprintf(buf, "dsp%02d.pl", plot_file_num++);
				bu_semaphore_release( RT_SEM_MODEL);
				bu_log("plotting normal in %s\n", buf);

				bu_semaphore_acquire( BU_SEM_SYSCALL);
				if ((fd=fopen(buf, "w")) != (FILE *)NULL) {
					pl_color(fd, 220, 220, 90);

					VJOIN1(tmp, hitp->hit_point, 1.0, Anorm);
					pdv_3line(fd, hitp->hit_point, tmp);

					VJOIN1(tmp, hitp->hit_point, 1.0, Bnorm);
					pdv_3line(fd, hitp->hit_point, tmp);

					VJOIN1(tmp, hitp->hit_point, 1.0, Dnorm);
					pdv_3line(fd, hitp->hit_point, tmp);

					VJOIN1(tmp, hitp->hit_point, 1.0, Cnorm);
					pdv_3line(fd, hitp->hit_point, tmp);

					fclose(fd);
				}
				bu_semaphore_release( BU_SEM_SYSCALL);
			}
		} else {
			bu_log("%s:%d ", __FILE__, __LINE__);
			bu_log("bogus surface of DSP %d\n", hitp->hit_surfno);
			bu_bomb("");
d2187 10
a2196 6
	} else {
		/* XXX this section should be replaced with code in
		 * isect_ray_triangles() to save the normal
		 * the only thing we should do here is transform the normal
		 * from solid to model space
		 */
d2198 1
a2198 6
		cell[X] = hitp->hit_vpriv[X];
		cell[Y] = hitp->hit_vpriv[Y];
		if ( hitp->hit_surfno == TRI1 ) {
		
			VSET(tmp, cell[X],   cell[Y],   DSP(dsp, cell[X],   cell[Y])  );
			MAT4X3PNT(A, dsp->dsp_i.dsp_stom, tmp);
d2200 3
a2202 2
			VSET(tmp, cell[X]+1, cell[Y],   DSP(dsp, cell[X]+1, cell[Y])  );
			MAT4X3PNT(B, dsp->dsp_i.dsp_stom, tmp);
d2204 4
a2207 2
			VSET(tmp, cell[X]+1, cell[Y]+1, DSP(dsp, cell[X]+1, cell[Y]+1));
			MAT4X3PNT(D, dsp->dsp_i.dsp_stom, tmp);
d2210 2
a2211 2
			VSUB2(AB, B, A);
			VSUB2(AD, D, A);
d2213 4
a2216 2
			VCROSS(N, AB, AD); 
		} else if ( hitp->hit_surfno == TRI2 ) {
d2218 4
a2221 2
			VSET(tmp, cell[X],   cell[Y],   DSP(dsp, cell[X],   cell[Y])  );
			MAT4X3PNT(A, dsp->dsp_i.dsp_stom, tmp);
d2223 9
a2231 2
			VSET(tmp, cell[X],   cell[Y]+1, DSP(dsp, cell[X],   cell[Y]+1));
			MAT4X3PNT(C, dsp->dsp_i.dsp_stom, tmp);
d2233 2
a2234 2
			VSET(tmp, cell[X]+1, cell[Y]+1, DSP(dsp, cell[X]+1, cell[Y]+1));
			MAT4X3PNT(D, dsp->dsp_i.dsp_stom, tmp);
d2236 1
a2236 2
			VSUB2(AD, D, A);
			VSUB2(AC, C, A);
d2238 4
d2243 2
a2244 7
			VCROSS(N, AD, AC); 
		} else if ( hitp->hit_surfno == TRI3 ) {
			/* alternate cut cell */
			
			VSET(tmp, cell[X]+1,   cell[Y],
			 DSP(dsp, cell[X]+1,   cell[Y])  );
			MAT4X3PNT(A, dsp->dsp_i.dsp_stom, tmp);
d2246 2
a2247 3
			VSET(tmp, cell[X]+1, cell[Y]+1,  
			 DSP(dsp, cell[X]+1, cell[Y]+1)  );
			MAT4X3PNT(B, dsp->dsp_i.dsp_stom, tmp);
a2248 3
			VSET(tmp, cell[X], cell[Y]+1,
			 DSP(dsp, cell[X], cell[Y]+1) );
			MAT4X3PNT(D, dsp->dsp_i.dsp_stom, tmp);
d2250 9
a2258 2
			VSUB2(AB, B, A);
			VSUB2(AD, D, A);
d2260 15
a2274 1
			VCROSS(N, AB, AD); 
d2276 1
a2276 2
		} else if ( hitp->hit_surfno == TRI4 ) {
			/* alternate cut cell */
d2278 4
a2281 3
			VSET(tmp, cell[X]+1,   cell[Y],  
			 DSP(dsp, cell[X]+1,   cell[Y])  );
			MAT4X3PNT(A, dsp->dsp_i.dsp_stom, tmp);
d2283 8
a2290 3
			VSET(tmp, cell[X],   cell[Y],
			 DSP(dsp, cell[X],   cell[Y]));
			MAT4X3PNT(C, dsp->dsp_i.dsp_stom, tmp);
d2292 1
a2292 3
			VSET(tmp, cell[X], cell[Y]+1,
			 DSP(dsp, cell[X], cell[Y]+1));
			MAT4X3PNT(D, dsp->dsp_i.dsp_stom, tmp);
a2293 2
			VSUB2(AD, D, A);
			VSUB2(AC, C, A);
d2295 2
a2296 6
			VCROSS(N, AD, AC); 
		} else {
			bu_log("%s:%d ", __FILE__, __LINE__);
			bu_log("bogus surface of DSP %d\n", hitp->hit_surfno);
			bu_bomb("");
		}
a2297 2

	VUNITIZE(N);
a2299 1
	
a2300 22
		vect_t tmp;
		char buf[32];
		FILE *fd;

		if ( hitp->hit_surfno == TRI1 || hitp->hit_surfno == TRI2 ) {
			bu_log("surf[%d] cell(%d,%d) pt(%g %g %g) Norm[%g %g %g](%g %g %g)\n",
				hitp->hit_surfno,
				cell[X], cell[Y],
				V3ARGS(hitp->hit_point),
				V3ARGS(dsp_pl[ hitp->hit_surfno ]),
				V3ARGS(N));
		} else {
			bu_log("surf[%d] cell(?,?) pt(%g %g %g) Norm[%g %g %g](%g %g %g)\n",
				hitp->hit_surfno,
				V3ARGS(hitp->hit_point),
				V3ARGS(dsp_pl[ hitp->hit_surfno ]),
				V3ARGS(N));
		}
		bu_semaphore_acquire( RT_SEM_MODEL);
		sprintf(buf, "dsp%02d.pl", plot_file_num++);
		bu_semaphore_release( RT_SEM_MODEL);
		bu_log("plotting normal in %s\n", buf);
a2301 3
		bu_semaphore_acquire( BU_SEM_SYSCALL);
		if ((fd=fopen(buf, "w")) != (FILE *)NULL) {
			pl_color(fd, 90, 220, 90);
d2303 7
a2309 3
			pdv_3move(fd, hitp->hit_point);
			VJOIN1(tmp, hitp->hit_point, 1.0, N);
			pdv_3cont(fd, tmp);
d2311 1
a2312 1
		bu_semaphore_release( BU_SEM_SYSCALL);
a2313 1
#endif
@


1.49
log
@removed various lint fuzz
@
text
@d49 1
a49 1
static char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.48 1999/12/10 14:10:20 butler Exp $ (BRL)";
a2163 2
	register struct dsp_specific *dsp =
		(struct dsp_specific *)stp->st_specific;
a2441 2
	register struct dsp_specific *dsp =
		(struct dsp_specific *)stp->st_specific;
@


1.48
log
@Corrceted "short" to "unsigned short" in a couple places
@
text
@d49 1
a49 1
static char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.47 1999/12/09 16:14:42 mike Exp $ (BRL)";
d202 1
a202 1
	bu_vls_printf( vls, "  V=(%g %g %g)mm\n", V3ARGS(pt));
a679 2
	vect_t	A_B;
	vect_t	A_C;
a704 2
	VSUB2(A_B, B, A);
	VSUB2(A_C, C, A);
d1429 2
d1608 2
a1609 2
	isect_ray_triangles(isect, cs->grid_cell, cs->curr_pt, cs->next_pt,
		isect->sp_is_valid);
a1632 1
	int	bbin_surf;
a1635 2
	int	cells_bbox[4];	/* bbox (in x, y) of cells along ray */

a1636 1
	int	curr_surf;	/* surface of cell bbox for curr_pt */
a1650 1
	double	span_dist;	
a1677 1
	bbin_surf = isect->bbox.in_surf;
a1687 20

	/* compute min/max cell values in X and Y for extent of 
	 * ray overlap with bounding box
	 */
	if (bbout_cell[X] < curr_cell[X]) {
		cells_bbox[XMIN] = bbout_cell[X];
		cells_bbox[XMAX] = curr_cell[X];
	} else {
		cells_bbox[XMIN] = curr_cell[X];
		cells_bbox[XMAX] = bbout_cell[X];
	}
	if (bbout_cell[Y] < curr_cell[Y]) {
		cells_bbox[YMIN] = bbout_cell[Y];
		cells_bbox[YMAX] = curr_cell[Y];
	} else {
		cells_bbox[YMIN] = curr_cell[Y];
		cells_bbox[YMAX] = bbout_cell[Y];
	}


a1780 1
	curr_surf = BBSURF(bbin_surf);
d1884 1
a1884 1
	static CONST point_t junk = { 0.0, 0.0, 0.0 };
d1954 4
a1957 3
		INHIT( (&isect), isect.minbox.in_dist,
			BBSURF(isect.minbox.in_surf), junk, 
			dsp_pl[isect.minbox.in_surf]);
a2166 1
	vect_t N;
d2474 2
a2475 3
	int x, y;
	vect_t v_m, v_s, tmp;
	double u, v, r;
@


1.47
log
@
Added missing idb_meth init
@
text
@d49 1
a49 1
static char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.46 1999/12/03 20:54:11 butler Exp $ (BRL)";
d633 2
a634 2
short *cell_min;
short *cell_max;
d636 1
a636 1
	register short cmin, cmax, v;
d682 2
a683 2
	short	min_val;
	short	max_val;
d1267 1
a1267 1
	short a, b;	/* Elevation values on cell wall */
d1341 1
a1341 1
	short a, b;	/* points on cell wall */
d1530 2
a1531 2
	short	cell_min;
	short	cell_max;
@


1.46
log
@A substantially improved version of the DSP.  More accurate, and doesn't
dump core as often ;-).
@
text
@d49 1
a49 1
static char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.45 1999/11/26 22:02:53 mike Exp $ (BRL)";
d2843 1
@


1.45
log
@
Lint fixed
@
text
@d49 1
a49 1
static char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.44 1999/11/26 21:46:45 mike Exp $ (BRL)";
d65 4
d72 15
a86 7
#define DSP_XMIN 0
#define DSP_XMAX 1
#define DSP_YMIN 2
#define DSP_YMAX 3
#define DSP_ZMIN 4
#define DSP_ZMAX 5
#define DSP_ZMID 6
d130 2
a131 2
	struct bu_list		seglist;
	struct xray		r;
d139 4
a142 3
	struct seg *sp;	/* the current segment being filled */
	int sp_is_valid;
	int sp_is_done;
d145 2
a146 69
#define INHIT(isp, dist, surf, cell, norm) {\
	if (isp->sp_is_valid) {\
		bu_log("%s:%d pixel(%d,%d) ", __FILE__, __LINE__, \
			isp->ap->a_x, isp->ap->a_y); \
		bu_bomb("trying to enter solid when inside\n"); \
	} \
 \
	RT_GET_SEG( isp->sp, isp->ap->a_resource ); \
	isp->sp->seg_stp = isp->stp; \
	isp->sp->seg_in.hit_dist = dist; \
	isp->sp->seg_in.hit_surfno = surf; \
	isp->sp->seg_in.hit_vpriv[X] = cell[X]; \
	isp->sp->seg_in.hit_vpriv[Y] = cell[Y]; \
	VMOVE(isp->sp->seg_in.hit_normal, norm); \
	isp->sp_is_valid = 1; \
	if (rt_g.debug & DEBUG_HF) { \
		point_t in, t; \
		VJOIN1(t, isp->r.r_pt, dist, isp->r.r_dir); \
		MAT4X3PNT(in, isp->dsp->dsp_i.dsp_stom, t); \
		bu_log("line %d New in pt(%g %g %g) ss_dist %g surf: %d\n", \
			__LINE__, V3ARGS(in), dist, surf); \
		bu_log("\tNormal: %g %g %g\n", V3ARGS(norm)); \
	} \
}

#define OUTHIT(isp, dist, surf, cell, norm) {\
	if (! isp->sp_is_valid) {\
		bu_log("%s:%d pixel(%d,%d) ", __FILE__, __LINE__, \
			isp->ap->a_x, isp->ap->a_y); \
		bu_bomb("Trying to set outpoint when not inside\n"); \
	} \
	isp->sp->seg_out.hit_dist = dist; \
	isp->sp->seg_out.hit_surfno = surf; \
	isp->sp->seg_out.hit_vpriv[X] = cell[X]; \
	isp->sp->seg_out.hit_vpriv[Y] = cell[Y]; \
	VMOVE(isp->sp->seg_out.hit_normal, norm); \
	isp->sp_is_done = 1; \
	if (rt_g.debug & DEBUG_HF) { \
		point_t out, t; \
		VJOIN1(t, isp->r.r_pt, dist, isp->r.r_dir); \
		MAT4X3PNT(out, isp->dsp->dsp_i.dsp_stom, t); \
		bu_log("line %d New out pt(%g %g %g) ss_dist %g surf:%d\n", \
			__LINE__, V3ARGS(out), dist, surf); \
		bu_log("\tNormal: %g %g %g\n", V3ARGS(norm)); \
	} \
}

#define HIT_COMMIT(isp) { \
	if ( ! (isp)->sp_is_valid) { \
		bu_log("%s:%d pixel(%d,%d) ", __FILE__, __LINE__, \
			isp->ap->a_x, isp->ap->a_y); \
		bu_bomb("attempt to commit an invalid seg\n"); \
	} \
	if ( ! (isp)->sp_is_done) { \
		bu_log("%s:%d pixel(%d,%d) ", __FILE__, __LINE__, \
			isp->ap->a_x, isp->ap->a_y); \
		bu_bomb("attempt to commit an incomplete seg\n"); \
	} \
 \
	if (rt_g.debug & DEBUG_HF) { \
		bu_log("line %d Committing seg %g -> %g\n", __LINE__,\
			(isp)->sp->seg_in.hit_dist, \
			(isp)->sp->seg_out.hit_dist); \
	} \
 \
	BU_LIST_INSERT( &(isp)->seglist, &( isp->sp->l) ); \
	(isp)->sp = (struct seg *)NULL; \
	(isp)->sp_is_valid = 0; \
}
d307 7
a313 7
	dsp->dsp_pl_dist[DSP_XMIN] = 0.0;
	dsp->dsp_pl_dist[DSP_XMAX] = (fastf_t)dsp->xsiz;
	dsp->dsp_pl_dist[DSP_YMIN] = 0.0;
	dsp->dsp_pl_dist[DSP_YMAX] = (fastf_t)dsp->ysiz;
	dsp->dsp_pl_dist[DSP_ZMIN] = 0.0;
	dsp->dsp_pl_dist[DSP_ZMAX] = (fastf_t)dsp_max;
	dsp->dsp_pl_dist[DSP_ZMID] = (fastf_t)dsp_min;
d315 1
a315 1
	/* compute bounding box and spere */
d355 140
a494 1
 *  Intersect the ray with the bounding box of the dsp solid.
d506 2
a507 1
		bu_log("isect_ray_bbox()\n");
d517 3
d521 2
a522 1
		if (BN_VECT_ARE_PERP(NdotD, isect->tol)) {
d529 1
a529 1
			    }
d531 1
a532 1
		dist = - ( NdotPt - isect->dsp->dsp_pl_dist[plane] ) / NdotD;
d540 1
a540 1
		if ( plane > 5) /* dsp_min elevation not valid bbox limit */
d543 2
a544 2
		if (NdotD < 0.0) {
			/* entering */
d546 1
d550 1
a550 1
		} else { /*  (NdotD > 0.0) */
d553 1
d557 2
d571 2
a572 1
			isect->bbox.out_surf, isect->bbox.out_dist, V3ARGS(pt));
d577 3
a579 1
	    isect->bbox.out_dist >= MAX_FASTF ) 
d581 1
a581 1

d638 2
d667 1
a667 1
	curr_pt, next_pt, hit1, dist1, hit2, dist2, inside)
d669 16
a684 16
int cell[3];
vect_t curr_pt, next_pt;
int hit1;
double dist1;
int hit2;
double dist2;
int inside;
{
	FILE *fd;
	char buf[132];
	point_t A, B, C, D, tmp, pt;
	vect_t A_B;
	vect_t A_C;
	short min_val;
	short max_val;
	int outside;
d700 4
a703 1
	if ((fd=fopen(buf, "w")) != (FILE *)NULL) {
a704 2
		VSUB2(A_B, B, A);
		VSUB2(A_C, C, A);
a705 3
		if (A[Z] != B[Z] || A[Z] != C[Z] || A[Z] != D[Z]) {
			cell_minmax(isect->dsp, cell[X], cell[Y],
				&min_val, &max_val);
d707 2
d710 5
a714 2
			/* plot cell top bounding box */
			pl_color(fd, 60, 60, 190);
d716 1
a716 1
			tmp[Z] = (double)min_val;
a717 3
			VMOVEN(tmp, A, 2);
			MAT4X3PNT(pt, isect->dsp->dsp_i.dsp_stom, tmp);
			pdv_3move(fd, pt);
d719 2
a720 3
			VMOVEN(tmp, B, 2);
			MAT4X3PNT(pt, isect->dsp->dsp_i.dsp_stom, tmp);
			pdv_3cont(fd, pt);
d722 1
a722 3
			VMOVEN(tmp, D, 2);
			MAT4X3PNT(pt, isect->dsp->dsp_i.dsp_stom, tmp);
			pdv_3cont(fd, pt);
d724 3
a726 3
			VMOVEN(tmp, C, 2);
			MAT4X3PNT(pt, isect->dsp->dsp_i.dsp_stom, tmp);
			pdv_3cont(fd, pt);
d728 3
a730 3
			VMOVEN(tmp, A, 2);
			MAT4X3PNT(pt, isect->dsp->dsp_i.dsp_stom, tmp);
			pdv_3cont(fd, pt);
d732 3
a734 3
			tmp[Z] = (double)max_val;
			MAT4X3PNT(pt, isect->dsp->dsp_i.dsp_stom, tmp);
			pdv_3cont(fd, pt);
d736 3
a738 3
			VMOVEN(tmp, B, 2);
			MAT4X3PNT(pt, isect->dsp->dsp_i.dsp_stom, tmp);
			pdv_3cont(fd, pt);
d740 1
a740 19
			VMOVEN(tmp, D, 2);
			MAT4X3PNT(pt, isect->dsp->dsp_i.dsp_stom, tmp);
			pdv_3cont(fd, pt);

			VMOVEN(tmp, C, 2);
			MAT4X3PNT(pt, isect->dsp->dsp_i.dsp_stom, tmp);
			pdv_3cont(fd, pt);

			VMOVEN(tmp, A, 2);
			MAT4X3PNT(pt, isect->dsp->dsp_i.dsp_stom, tmp);
			pdv_3cont(fd, pt);
		}



		/* plot the triangles */
		pl_color(fd, 90, 220, 90);

		VMOVE(tmp, A);
d742 1
a742 1
		pdv_3move(fd, pt);
d744 1
a744 1
		VMOVE(tmp, B);
d748 1
a748 1
		VMOVE(tmp, D);
d752 1
a752 1
		VMOVE(tmp, A);
d756 1
a756 1
		VMOVE(tmp, C);
d760 1
a760 1
		VMOVE(tmp, D);
d763 2
d766 45
d812 3
a814 2
		/* plot the ray */
		outside = !inside;
d816 6
a821 4
		if (outside)
			pl_color(fd, 255, 40, 40);
		else
			pl_color(fd, 255, 255, 100);
d824 2
a825 2
		MAT4X3PNT(pt, isect->dsp->dsp_i.dsp_stom, curr_pt);
		pdv_3move(fd, pt);
d827 2
a828 48
		if (hit1 && hit2) {
			if (dist1 < dist2) {
				VJOIN1(tmp, isect->r.r_pt, dist1, isect->r.r_dir);
				MAT4X3PNT(pt, isect->dsp->dsp_i.dsp_stom, tmp);
				pdv_3cont(fd, pt);

				if (outside)
					pl_color(fd, 255, 255, 100);
				else
					pl_color(fd, 255, 40, 40);

				pdv_3move(fd, pt);

				outside = !outside;
				VJOIN1(tmp, isect->r.r_pt, dist2, isect->r.r_dir);
				MAT4X3PNT(pt, isect->dsp->dsp_i.dsp_stom, tmp);
				pdv_3cont(fd, pt);

				if (outside)
					pl_color(fd, 255, 255, 100);
				else
					pl_color(fd, 255, 40, 40);

				pdv_3move(fd, pt);
				outside = !outside;
			} else {
				VJOIN1(tmp, isect->r.r_pt, dist2, isect->r.r_dir);
				MAT4X3PNT(pt, isect->dsp->dsp_i.dsp_stom, tmp);
				pdv_3cont(fd, pt);

				if (outside)
					pl_color(fd, 255, 255, 100);
				else
					pl_color(fd, 255, 40, 40);
				pdv_3move(fd, pt);
				outside = !outside;
				VJOIN1(tmp, isect->r.r_pt, dist1, isect->r.r_dir);
				MAT4X3PNT(pt, isect->dsp->dsp_i.dsp_stom, tmp);
				pdv_3cont(fd, pt);

				if (outside)
					pl_color(fd, 255, 255, 100);
				else
					pl_color(fd, 255, 40, 40);
				pdv_3move(fd, pt);
				outside = !outside;
			}
		} else if (hit1) {
d833 2
a834 4
			if (outside)
				pl_color(fd, 255, 255, 100);
			else
				pl_color(fd, 255, 40, 40);
d837 1
a837 1
		} else if (hit2) {
d842 3
a844 4
			if (outside)
				pl_color(fd, 255, 255, 100);
			else
				pl_color(fd, 255, 40, 40);
d846 18
d865 18
d885 2
a886 2
		MAT4X3PNT(pt, isect->dsp->dsp_i.dsp_stom, next_pt);
		pdv_3cont(fd, pt);
d889 2
a890 3
		fclose(fd);
		bu_semaphore_release( BU_SEM_SYSCALL);
	}
d996 1
a996 1
	curr_pt, next_pt, inside)
a999 1
int *inside;
d1019 1
d1024 1
a1024 1
		bu_log("isect_ray_triangles(inside=%d)\n", *inside);
d1027 1
a1027 1
		VPRINT("A", t);
d1029 1
a1029 1
		VPRINT("B", t);
d1031 1
a1031 1
		VPRINT("C", t);
d1033 1
a1033 1
		VPRINT("D", t);
d1052 1
a1052 1
		reason1 = "perpendicular";
d1064 1
a1064 1
		reason1 = "miss tria1 (alpha)\n";
d1074 1
a1074 1
		reason1 = "miss tria1 (beta)\n";
d1078 1
a1078 1
		reason1 = "miss tria1 (alpha+beta > NdotD)\n";
d1085 3
a1087 4
	if (rt_g.debug & DEBUG_HF && reason1 != (char *)NULL)
		bu_log("missed tria1 %s\n", reason1);
		

d1095 1
a1095 1
		reason2 = "perpendicular";
d1104 1
a1104 1
		reason2 = "miss tria2 (alpha)\n";
d1112 1
a1112 1
		reason2 = "miss tria2 (beta)\n";
d1117 1
a1117 1
		reason2 = "miss tria2 (alpha+beta > NdotD)\n";
d1125 4
a1128 2
	if (rt_g.debug & DEBUG_HF && reason2 != (char *)NULL)
		bu_log("missed tria2 %s\n", reason2);
d1132 2
a1133 1
		plot_cell_ray(isect, cell, curr_pt, next_pt, hit1, dist1, hit2, dist2, *inside);
d1182 1
a1182 7
			/* entering */
			if (*inside) {
				bu_log("%s:%d ray entering while inside dsp pixel(%d,%d)",
					__FILE__, __LINE__,
					isect->ap->a_x, isect->ap->a_y);
				bu_bomb("");
			}
d1186 3
a1188 4
				bu_log("%s:%d ray entering while inside dsp pixel(%d,%d)",
					__FILE__, __LINE__,
					isect->ap->a_x, isect->ap->a_y);
				bu_bomb("");
a1194 6
			if (! *inside) {
				bu_log("%s:%d ray leaving while outside dsp pixel(%d,%d)",
					__FILE__, __LINE__,
					isect->ap->a_x, isect->ap->a_y);
				bu_bomb("");
			}
a1196 1
			*inside = 0;
d1202 1
a1202 1
				bu_bomb("");
a1204 1
			*inside = 1;
d1212 2
a1213 8
				bu_log("hit triangle 1 entering ss_dist:%g\n", dist1);

			if (*inside) {
				bu_log("%s:%d ray entering while inside dsp pixel(%d,%d)",
					__FILE__, __LINE__,
					isect->ap->a_x, isect->ap->a_y);
				bu_bomb("");
			}
a1215 1
			*inside = 1;
d1219 2
a1220 1
				bu_log("hit triangle 1 leaving ss_dist:%g\n", dist1);
a1221 6
			if (! *inside) {
				bu_log("%s:%d ray leaving while outside dsp pixel(%d,%d)",
					__FILE__, __LINE__,
					isect->ap->a_x, isect->ap->a_y);
				bu_bomb("");
			}
a1223 1
			*inside = 0;
d1232 2
a1233 7
				bu_log("hit triangle 2 entering ss_dist:%g\n", dist2);
			if (*inside) {
				bu_log("%s:%d ray entering while inside dsp pixel(%d,%d)",
					__FILE__, __LINE__,
					isect->ap->a_x, isect->ap->a_y);
				bu_bomb("");
			}
a1235 1
			*inside = 1;
d1240 3
a1242 7
				bu_log("hit triangle 2 leaving ss_dist:%g\n", dist2);
			if (! *inside) {
				bu_log("%s:%d ray leaving while outside dsp pixel(%d,%d)",
					__FILE__, __LINE__,
					isect->ap->a_x, isect->ap->a_y);
				bu_bomb("");
			}
a1244 1
			*inside = 0;
d1254 1
d1262 4
a1265 4
int cell[3];
int surf;
double dist;
point_t pt;
d1267 1
a1267 1
	short a, b;	/* points on cell wall */
a1274 1

d1278 13
a1290 1
	if (surf == BBSURF(DSP_XMIN)) {
d1293 11
a1303 1
	} else if (surf == BBSURF(DSP_XMAX)) {
d1310 1
a1310 1
		bu_bomb("");
d1316 1
a1316 1
	/* compute the height of the wall top at the Y location of curr_pt */
d1350 1
a1350 1
		bu_log("isect_cell_y_wall() cell(%d,%d) surf:%d ss_dist:%d pt(%g %g %g)\n",
d1353 12
a1364 1
	if (surf == BBSURF(DSP_YMIN)) {
d1367 9
a1375 1
	} else if (surf == BBSURF(DSP_YMAX)) {
d1382 1
a1382 1
		bu_bomb("");
d1399 37
d1442 10
a1451 6
	pointp_t bbin_pt;
	double bbin_dist;
	int *grid_cell;
	double *curr_dist;
	int *curr_surf;
	pointp_t curr_pt;
d1454 2
d1457 54
a1510 1
 *	Intersect a ray with a single "cell" (bounded by 4 values) of 
d1513 11
a1524 1

d1526 1
a1526 1
cell_isect(isect, dt, next_surf, cs, inside, rising, isect_wall)
a1527 2
double dt;
int next_surf;
a1528 3
int *inside;
int rising;
int (*isect_wall)();
a1529 1
	point_t next_pt;
d1532 3
a1534 3
	int	hit;
	
	VJOIN1(next_pt, cs->bbin_pt, dt, isect->r.r_dir);
d1536 2
d1540 2
a1541 4
		vect_t t;
		MAT4X3PNT(t, isect->dsp->dsp_i.dsp_stom, next_pt);
		bu_log("\tnext_pt (%g %g %g) ss_dist:%g\n",
			V3ARGS(t), dt);
a1542 2
	cell_minmax(isect->dsp, cs->grid_cell[X], cs->grid_cell[Y],
		&cell_min, &cell_max);
d1544 4
a1547 25
	if (( rising && next_pt[Z] < cell_min) ||
	    (!rising && cs->curr_pt[Z] < cell_min) ) {
		/* in base */
		if (rt_g.debug & DEBUG_HF) bu_log("\tin base surf:%d next_surf:%d\n", *cs->curr_surf, next_surf);
	    	if (!*inside) {
	    		INHIT(isect,
	    		*cs->curr_dist,
	    		*cs->curr_surf,
	    		cs->grid_cell, 
	    		dsp_pl[BBSURF(*cs->curr_surf)]);
	    		*inside = 1;
	    	}

	    	OUTHIT(isect, (cs->bbin_dist+dt), next_surf, cs->grid_cell,
	    		dsp_pl[BBSURF(next_surf)]);

	    	if (rt_g.debug & DEBUG_HF)
		    	plot_cell_ray(isect, cs->grid_cell, 
		    		cs->curr_pt, next_pt, 0, 0.0, 0, 0.0, *inside);


	} else if (
	    ( rising && cs->curr_pt[Z] > cell_max) ||
	    (!rising && next_pt[Z] > cell_max) ) {
		/* miss above */
a1548 7
	    	if (*inside) {
	    		HIT_COMMIT(isect);
	    		*inside = 0;
	    	}
	    	if (rt_g.debug & DEBUG_HF)
		    	plot_cell_ray(isect, cs->grid_cell, 
		    		cs->curr_pt, next_pt, 0, 0.0, 0, 0.0, *inside);
d1550 2
d1553 11
a1563 47
	} else {
		/* intersect */
		if (rt_g.debug & DEBUG_HF)
			bu_log("\tintersect %d %d X %s\n",
				cell_min, cell_max, 
				(rising?"rising":"falling") );

		switch (*cs->curr_surf) {
		case BBSURF(DSP_XMIN) :
		case BBSURF(DSP_XMAX) :
			hit = isect_cell_x_wall(
				isect, cs->grid_cell, *cs->curr_surf,
				*cs->curr_dist, cs->curr_pt);
			if (rt_g.debug & DEBUG_HF) {
				if (hit)
					bu_log("\thit X in-wall\n");
				else
					bu_log("\tmiss X in-wall\n");
			}
			break;
		case BBSURF(DSP_YMIN) :
		case BBSURF(DSP_YMAX) :
			hit = isect_cell_y_wall(
				isect, cs->grid_cell, *cs->curr_surf,
				*cs->curr_dist, cs->curr_pt);
			if (rt_g.debug & DEBUG_HF) {
				if (hit)
					bu_log("\thit Y in-wall\n");
				else
					bu_log("\tmiss Y in-wall\n");
			}
			break;
		case BBSURF(DSP_ZMIN) :
			if (*cs->curr_dist != cs->bbin_dist){
				bu_log("\t%s:%d hitting bottom of dsp for entry while past bottom?  pixel(%d,%d)\n",
					__FILE__, __LINE__,
					isect->ap->a_x, isect->ap->a_y);
				bu_bomb("");
			}
			hit = 1;
			break;
		case BBSURF(DSP_ZMAX) :
			hit = 0;
			break;
		default:
			bu_log("\t%s:%d pixel(%d,%d) surface %d ", __FILE__, __LINE__, isect->ap->a_x, isect->ap->a_y, *cs->curr_surf);
			bu_bomb("\tbad surface to intersect\n");
d1566 13
a1578 6
		if (hit && !*inside) {
			INHIT(isect, *cs->curr_dist,
				*cs->curr_surf, cs->grid_cell,
				dsp_pl[BBSURF(*cs->curr_surf)]);
			*inside = 1;
		}
d1580 4
a1583 3
		isect_ray_triangles(isect, cs->grid_cell,
			cs->curr_pt, next_pt,
			inside);
a1585 1
		hit = isect_wall(isect, cs->grid_cell, next_surf, dt, next_pt);
d1587 4
d1592 20
a1611 20
			if (*inside) {
				if (rt_g.debug & DEBUG_HF)
					bu_log("\thit X out-wall\n");
				OUTHIT(isect, (cs->bbin_dist+dt), next_surf,
					cs->grid_cell,
					dsp_pl[BBSURF(*cs->curr_surf)]);
				*inside = 1;
			}
#if 0
			if (!*inside) {
				bu_log("\t%s:%d pixel(%d,%d) cell(%d,%d)", __FILE__, __LINE__, isect->ap->a_x, isect->ap->a_y, V2ARGS(cs->grid_cell));
				bu_log("\thit dsp and not inside g_dsp.c line:%d", __LINE__);
				bu_bomb("");
			}
#endif
		} else {
			if (rt_g.debug & DEBUG_HF)
				bu_log("\tmiss X out-wall\n");
		}
	} 
a1612 2
	/* step to next cell */
	VMOVE(cs->curr_pt, next_pt);
d1614 9
a1622 1
	*cs->curr_dist = dt;
d1625 1
d1639 1
a1639 1
	int	cell_bbox[4];	/* bbox (in x, y) of cells along ray */
d1644 1
d1646 2
a1647 2
	int	grid_cell[3];	/* grid cell of current point */
	int	inside = 0;
d1657 1
a1657 1
	double	span_dist;
d1675 7
a1681 3
		bu_log("  r_pt: %g %g %g  dir: %g %g %g\n", V3ARGS(isect->r.r_pt),  V3ARGS(isect->r.r_dir));
		bu_log(" in_pt: %g %g %g  dist: %g\n", V3ARGS(bbin_pt), bbin_dist);
		bu_log("out_pt: %g %g %g  dist: %g\n", V3ARGS(bbout_pt), out_dist);
d1687 4
a1690 4
	VMOVE(grid_cell, bbin_pt);	/* int/float conversion */
	if (grid_cell[X] >= XSIZ(isect->dsp)) grid_cell[X]--;
	if (grid_cell[Y] >= YSIZ(isect->dsp)) grid_cell[Y]--;
	
d1700 3
a1702 3
	if (bbout_cell[X] < grid_cell[X]) {
		cell_bbox[DSP_XMIN] = bbout_cell[X];
		cell_bbox[DSP_XMAX] = grid_cell[X];
d1704 2
a1705 2
		cell_bbox[DSP_XMIN] = grid_cell[X];
		cell_bbox[DSP_XMAX] = bbout_cell[X];
d1707 3
a1709 3
	if (bbout_cell[Y] < grid_cell[Y]) {
		cell_bbox[DSP_YMIN] = bbout_cell[Y];
		cell_bbox[DSP_YMAX] = grid_cell[Y];
d1711 2
a1712 2
		cell_bbox[DSP_YMIN] = grid_cell[Y];
		cell_bbox[DSP_YMAX] = bbout_cell[Y];
d1721 1
a1721 1
			V2ARGS(grid_cell), V3ARGS(t), bbin_dist);
d1730 2
d1735 1
d1738 2
a1739 2
		insurfX = BBSURF(DSP_XMAX);
		outsurfX = BBSURF(DSP_XMIN);
d1747 2
a1748 2
		/* tX is the distance along the ray from the bbox in point
		 * to the first cell boundary in the X direction
d1750 1
a1750 1
		tX = (grid_cell[X] - bbin_pt[X]) / isect->r.r_dir[X];
a1751 1
		
d1754 2
a1755 2
		insurfX = BBSURF(DSP_XMIN);
		outsurfX = BBSURF(DSP_XMAX);
d1760 3
a1762 2
			tX = ((grid_cell[X]+1) - bbin_pt[X]) / isect->r.r_dir[X];
			if (tX < tDX) tX += bbin_dist;
d1766 1
d1769 2
a1770 2
		insurfY = BBSURF(DSP_YMAX);
		outsurfY = BBSURF(DSP_YMIN);
d1774 1
a1774 1
		tY = (grid_cell[Y] - bbin_pt[Y]) / isect->r.r_dir[Y];
d1778 2
a1779 2
		insurfY = BBSURF(DSP_YMIN);
		outsurfY = BBSURF(DSP_YMAX);
d1784 3
a1786 2
			tY = ((grid_cell[Y]+1) - bbin_pt[Y]) / isect->r.r_dir[Y];
			tY += bbin_dist;
d1795 1
a1795 1
		VJOIN1(t, bbin_pt, tX, isect->r.r_dir);
d1799 1
a1799 1
		VJOIN1(t, bbin_pt, tY, isect->r.r_dir);
d1803 2
a1809 1
	span_dist = out_dist - bbin_dist;
d1815 2
a1816 5
	cs.bbin_pt = bbin_pt;
	cs.bbin_dist = bbin_dist;
	cs.grid_cell = grid_cell;
	cs.curr_dist = &curr_dist;
	cs.curr_surf = &curr_surf;
d1818 3
d1823 1
a1823 1
	do {
d1825 3
a1827 4
			vect_t t;
			MAT4X3PNT(t, isect->dsp->dsp_i.dsp_stom, curr_pt);
bu_log("cell(%d,%d) tX:%g tY:%g  inside=%d\n\tcurr_pt (%g %g %g) ss_dist:%g surf:%d\n\t",
grid_cell[X], grid_cell[Y], tX, tY, inside, V3ARGS(t), curr_dist, curr_surf);
a1829 3
/* XXX This was bogus when out_dist is measured from ray start point
 * It must be measured from bbox in point
 */
d1831 6
d1838 1
a1838 13
		if (tX > span_dist) {
			if (rt_g.debug & DEBUG_HF) {
				bu_log("tX:%g beyond span_dist%g\n", tX, out_dist);
			}
			tX = span_dist;
		}
		if (tY > span_dist) {
			if (rt_g.debug & DEBUG_HF) {
				bu_log("tY:%g beyond span_dist%g\n", tY, out_dist);
			}
			tY = span_dist;
		}
		if (tX < tY) {
d1840 1
a1840 5
			if (rt_g.debug & DEBUG_HF) {
				bu_log("tX:%g < tY:%g\n", tX, tY);
			}
			cell_isect(isect, tX, outsurfX, &cs, &inside, rising,
				isect_cell_x_wall);
a1841 2
			curr_surf = insurfX;
			grid_cell[X] += stepX;
a1842 3
			/* update dist along ray to next X cell boundary */
			tX += tDX;
		} else {
d1844 4
a1847 5
			if (rt_g.debug & DEBUG_HF) {
				bu_log("tX:%g > tY:%g\n", tX, tY);
			}
			cell_isect(isect, tY, outsurfY, &cs, &inside, rising,
				isect_cell_y_wall);
d1849 1
a1849 2
			curr_surf = insurfY;
			grid_cell[Y] += stepY;
d1851 14
d1867 2
d1870 1
a1870 7

	} while ( grid_cell[X] >= cell_bbox[DSP_XMIN] &&
		grid_cell[X] <= cell_bbox[DSP_XMAX] &&
		grid_cell[Y] >= cell_bbox[DSP_YMIN] &&
		grid_cell[Y] <= cell_bbox[DSP_YMAX] );

	if (inside) {
a1878 1
		inside = 0;
d1880 1
a1880 1
/* rt_g.debug & DEBUG_HF */
d1910 2
a1911 1
	vect_t	dir, v;
d1915 10
a1924 1
	if (rt_g.debug & DEBUG_HF)
d1930 1
a1930 1

d1934 4
a1937 1
	/* map the ray into the coordinate system of the dsp */
d1945 2
a1946 2
		bu_log("Solid space ray pt:(%g %g %g)\n\tdir[%g]:[%g %g %g]\n\tu_dir(%g %g %g)\n",
			V3ARGS(isect.r.r_pt),
a1949 1

d2617 1
a2617 1
CONST struct bn_tol	*tol;
d2788 1
a2788 1
CONST struct bn_tol	*tol;
d2809 1
a2809 1
rt_dsp_import( ip, ep, mat, dbip )
a2812 1
CONST struct db_i		*dbip;
d2820 1
a2820 1
	bu_log("rt_ebm_import(%d) '%s' %s\n", __LINE__, dsp_ip->dsp_file,_s);\
a2842 1
	ip->idb_meth = &rt_functab[ID_DSP];
d2876 1
a2876 1
	if( !(dsp_ip->dsp_mp = bu_open_mapped_file( dsp_ip->dsp_file, "dsp" )) )  {
d2899 1
a2899 1
rt_dsp_export( ep, ip, local2mm, dbip )
a2902 1
CONST struct db_i		*dbip;
d2954 1
a2954 1
CONST struct rt_db_internal	*ip;
@


1.44
log
@
Lint cleanups
@
text
@d49 1
a49 1
static char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.43 1999/11/24 23:12:06 mike Exp $ (BRL)";
d68 7
a74 7
#define XMIN 0
#define XMAX 1
#define YMIN 2
#define YMAX 3
#define ZMIN 4
#define ZMAX 5
#define ZMID 6
d361 7
a367 7
	dsp->dsp_pl_dist[XMIN] = 0.0;
	dsp->dsp_pl_dist[XMAX] = (fastf_t)dsp->xsiz;
	dsp->dsp_pl_dist[YMIN] = 0.0;
	dsp->dsp_pl_dist[YMAX] = (fastf_t)dsp->ysiz;
	dsp->dsp_pl_dist[ZMIN] = 0.0;
	dsp->dsp_pl_dist[ZMAX] = (fastf_t)dsp_max;
	dsp->dsp_pl_dist[ZMID] = (fastf_t)dsp_min;
d1201 1
a1201 1
	if (surf == BBSURF(XMIN)) {
d1204 1
a1204 1
	} else if (surf == BBSURF(XMAX)) {
d1254 1
a1254 1
	if (surf == BBSURF(YMIN)) {
d1257 1
a1257 1
	} else if (surf == BBSURF(YMAX)) {
d1371 2
a1372 2
		case BBSURF(XMIN) :
		case BBSURF(XMAX) :
d1383 2
a1384 2
		case BBSURF(YMIN) :
		case BBSURF(YMAX) :
d1395 1
a1395 1
		case BBSURF(ZMIN) :
d1404 1
a1404 1
		case BBSURF(ZMAX) :
d1524 2
a1525 2
		cell_bbox[XMIN] = bbout_cell[X];
		cell_bbox[XMAX] = grid_cell[X];
d1527 2
a1528 2
		cell_bbox[XMIN] = grid_cell[X];
		cell_bbox[XMAX] = bbout_cell[X];
d1531 2
a1532 2
		cell_bbox[YMIN] = bbout_cell[Y];
		cell_bbox[YMAX] = grid_cell[Y];
d1534 2
a1535 2
		cell_bbox[YMIN] = grid_cell[Y];
		cell_bbox[YMAX] = bbout_cell[Y];
d1558 2
a1559 2
		insurfX = BBSURF(XMAX);
		outsurfX = BBSURF(XMIN);
d1575 2
a1576 2
		insurfX = BBSURF(XMIN);
		outsurfX = BBSURF(XMAX);
d1588 2
a1589 2
		insurfY = BBSURF(YMAX);
		outsurfY = BBSURF(YMIN);
d1597 2
a1598 2
		insurfY = BBSURF(YMIN);
		outsurfY = BBSURF(YMAX);
d1693 4
a1696 4
	} while ( grid_cell[X] >= cell_bbox[XMIN] &&
		grid_cell[X] <= cell_bbox[XMAX] &&
		grid_cell[Y] >= cell_bbox[YMIN] &&
		grid_cell[Y] <= cell_bbox[YMAX] );
@


1.43
log
@
Made structparse tables CONST
@
text
@d49 1
a49 1
static char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.42 1999/11/17 02:41:57 mike Exp $ (BRL)";
d2434 1
a2434 1
struct bn_tol		*tol;
d2605 1
a2605 1
struct bn_tol		*tol;
d2626 1
a2626 1
rt_dsp_import( ip, ep, mat )
d2630 1
d2718 1
a2718 1
rt_dsp_export( ep, ip, local2mm )
d2722 1
d2774 1
a2774 1
struct rt_db_internal	*ip;
@


1.42
log
@
Added idb_meth and st_meth pointers to allow direct access to per-solid
methods, C++ style.
@
text
@d49 1
a49 1
static char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.41 1999/07/02 22:19:22 mike Exp $ (BRL)";
d220 1
a220 1
struct bu_structparse rt_dsp_parse[] = {
d229 1
a229 1
struct bu_structparse rt_dsp_ptab[] = {
@


1.41
log
@
Removed dependence on compat4.h
@
text
@d49 1
a49 1
static char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.40 1999/05/27 19:10:36 mike Exp $ (BRL)";
d2660 1
@


1.40
log
@
sed4
@
text
@d49 1
a49 1
static char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.39 1999/01/08 21:31:46 butler Exp $ (BRL)";
d226 1
a226 1
	{"",	0, (char *)0, 0,			FUNC_NULL }
d235 1
a235 1
	{"",	0, (char *)0, 0,			FUNC_NULL }
d2455 1
a2455 1
	RT_ADD_VLIST( vhead, m_pt, RT_VLIST_LINE_MOVE )
d2459 1
a2459 1
	RT_ADD_VLIST( vhead, m_pt, RT_VLIST_LINE_DRAW )
@


1.39
log
@The Xs, Ys, and Zs parameters are internal-use only.  They are not to be set.
So I deleted them from the parse table.
@
text
@d49 1
a49 1
static char RCSdsp[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_dsp.c,v 1.38 1998/06/15 13:18:42 butler Exp $ (BRL)";
d218 1
a218 1
#define DSP_AO(a) offsetofarray(struct rt_dsp_internal, a)
d221 5
a225 5
	{"%s",	DSP_NAME_LEN, "file", DSP_AO(dsp_file), FUNC_NULL },
	{"%d",  1, "sm", DSP_O(dsp_smooth), FUNC_NULL },
	{"%d",	1, "w", DSP_O(dsp_xcnt), FUNC_NULL },
	{"%d",	1, "n", DSP_O(dsp_ycnt), FUNC_NULL },
	{"%f", 16, "stom", DSP_AO(dsp_stom), FUNC_NULL },
d230 5
a234 5
	{"%s",	DSP_NAME_LEN, "file", DSP_AO(dsp_file), FUNC_NULL },
	{"%d",  1, "sm", DSP_O(dsp_smooth), FUNC_NULL },
	{"%d",	1, "w", DSP_O(dsp_xcnt), FUNC_NULL },
	{"%d",	1, "n", DSP_O(dsp_ycnt), FUNC_NULL },
	{"%f", 16, "stom", DSP_AO(dsp_stom), FUNC_NULL },
d331 1
a331 1
	GETSTRUCT( dsp, dsp_specific );
d2408 2
a2409 2
	RT_CK_MAPPED_FILE(dsp->dsp_i.dsp_mp);
	rt_close_mapped_file(dsp->dsp_i.dsp_mp);
d2411 1
a2411 1
	rt_free( (char *)dsp, "dsp_specific" );
d2431 1
a2431 1
struct rt_list		*vhead;
d2434 1
a2434 1
struct rt_tol		*tol;
d2605 1
a2605 1
struct rt_tol		*tol;
d2628 1
a2628 1
CONST struct rt_external	*ep;
d2643 1
a2643 1
	RT_CK_EXTERNAL( ep );
d2654 1
a2654 1
		rt_log("rt_dsp_import: defective record\n");
d2660 1
a2660 1
	ip->idb_ptr = rt_malloc( sizeof(struct rt_dsp_internal), "rt_dsp_internal");
d2670 2
a2671 2
	mat_idn(dsp_ip->dsp_stom);
	mat_idn(dsp_ip->dsp_mtos);
d2687 2
a2688 2
	mat_copy(tmp, dsp_ip->dsp_stom);
	mat_mul(dsp_ip->dsp_stom, mat, tmp);
d2690 1
a2690 1
	mat_inv(dsp_ip->dsp_mtos, dsp_ip->dsp_stom);
d2693 1
a2693 1
	if( !(dsp_ip->dsp_mp = rt_open_mapped_file( dsp_ip->dsp_file, "dsp" )) )  {
d2717 1
a2717 1
struct rt_external		*ep;
d2732 1
a2732 1
	RT_INIT_EXTERNAL(ep);
d2734 1
a2734 1
	ep->ext_buf = (genptr_t)rt_calloc( 1, ep->ext_nbytes, "dsp external");
d2770 1
a2770 1
struct rt_vls		*str;
d2794 1
a2794 1
	rt_vls_strcat( str, buf );
d2819 2
a2820 2
		RT_CK_MAPPED_FILE(dsp_ip->dsp_mp);
		rt_close_mapped_file(dsp_ip->dsp_mp);
d2824 1
a2824 1
	dsp_ip->dsp_mp = (struct rt_mapped_file *)0;
d2826 1
a2826 1
	rt_free( (char *)dsp_ip, "dsp ifree" );
@


1.38
log
@needed extra semaphore.
@
text
@d49 1
a49 1
static char RCSdsp[] = "@@(#)$Header: /m/cad/librt/RCS/g_dsp.c,v 1.37 1998/01/21 11:08:47 butler Exp butler $ (BRL)";
a224 3
	{"%f",	1, "xs", DSP_O(dsp_xs), FUNC_NULL },
	{"%f",	1, "ys", DSP_O(dsp_ys), FUNC_NULL },
	{"%f",	1, "zs", DSP_O(dsp_zs), FUNC_NULL },
@


1.37
log
@fixed problems mike discovered.
@
text
@d49 1
a49 1
static char RCSdsp[] = "@@(#)$Header: /m/cad/librt/RCS/g_dsp.c,v 1.36 1998/01/21 10:36:56 butler Exp butler $ (BRL)";
d253 2
a254 1
	bu_vls_printf( vls, "Displacement Map\n  file='%s' xc=%d yc=%d sm=%d\n",
d259 1
a259 1
	bu_vls_printf( vls, "  V=(%g %g %g)\n", V3ARGS(pt));
d597 1
d599 1
d1850 1
a1850 1
		MAT4X3VEC(v, dsp->dsp_i.dsp_stom, segp->seg_in.hit_normal);
d1852 1
d1854 1
a1854 1
		MAT4X3VEC(v, dsp->dsp_i.dsp_stom, segp->seg_out.hit_normal);
d1856 1
a1856 1

d2012 2
d2015 1
d2017 28
a2044 1
		bu_log("rt_dsp_norm()\n");
a2045 1
	VUNITIZE(hitp->hit_normal);
d2047 1
a2048 2
	register struct dsp_specific *dsp =
		(struct dsp_specific *)stp->st_specific;
@


1.36
log
@checkpoint
@
text
@d49 1
a49 1
static char RCSdsp[] = "@@(#)$Header: /m/cad/librt/RCS/g_dsp.c,v 1.35 1998/01/21 08:54:09 butler Exp butler $ (BRL)";
d129 1
d168 1
d185 5
d1427 9
d1437 1
a1437 1
				bu_log("\t%s:%d pixel(%d,%d) ", __FILE__, __LINE__, isect->ap->a_x, isect->ap->a_y);
d1441 1
a1441 6
			if (rt_g.debug & DEBUG_HF)
				bu_log("\thit X out-wall\n");
			OUTHIT(isect, (cs->bbin_dist+dt), next_surf,
				cs->grid_cell,
				dsp_pl[BBSURF(*cs->curr_surf)]);
			*inside = 1;
d1698 6
a1703 4
	/* What we've got is hits in the 0 .. span_dist range.
	 * We need them in the in_dist .. out_dist range.
	 
	 */
a1705 1
	if (inside) {
d1774 1
@


1.35
log
@checkpoint
@
text
@d49 1
a49 1
static char RCSdsp[] = "@@(#)$Header: /m/cad/librt/RCS/g_dsp.c,v 1.34 1997/12/16 00:13:37 mike Exp butler $ (BRL)";
d131 1
a131 1
#define INHIT(isp, dist, surf, cell) {\
d144 1
d152 1
d156 1
a156 1
#define OUTHIT(isp, dist, surf, cell) {\
d166 1
d173 1
d1066 1
a1066 1
			INHIT(isect, first, first_tri, cell);
d1074 1
a1074 1
			OUTHIT(isect, second, second_tri, cell);
d1085 1
a1085 1
			OUTHIT(isect, first, first_tri, cell);
d1095 1
a1095 1
			INHIT(isect, second, second_tri, cell);
d1113 1
a1113 1
			INHIT(isect, dist1, tria1, cell);
d1126 1
a1126 1
			OUTHIT(isect, dist1, tria1, cell);
d1145 1
a1145 1
			INHIT(isect, dist2, tria2, cell);
d1158 1
a1158 1
			OUTHIT(isect, dist2, tria2, cell);
d1324 1
a1324 1
		if (rt_g.debug & DEBUG_HF) bu_log("\tin base\n");
d1326 5
a1330 1
	    		INHIT(isect, *cs->curr_dist, *cs->curr_surf, cs->grid_cell);
a1332 1
	    	OUTHIT(isect, (cs->bbin_dist+dt), next_surf, cs->grid_cell);
d1334 3
d1407 2
a1408 1
				*cs->curr_surf, cs->grid_cell);
d1427 3
a1429 1
			OUTHIT(isect, (cs->bbin_dist+dt), next_surf, cs->grid_cell);
d1788 2
a1789 1
			BBSURF(isect.minbox.in_surf), junk);
d1792 2
a1793 1
			BBSURF(isect.minbox.out_surf), junk);
d1834 7
d1961 1
a1961 1
			pdv_3line(fd, B, tmp);
d1995 7
d2011 1
d2234 1
@


1.34
log
@Converted to bu_semaphore_acquire()
@
text
@d49 1
a49 1
static char RCSdsp[] = "@@(#)$Header: /m/cad/librt/RCS/g_dsp.c,v 1.33 1997/11/05 18:55:34 jra Exp mike $ (BRL)";
d349 1
a349 1
		bu_log("x:%d y:%d min %d max %d\n", XCNT(dsp), YCNT(dsp), dsp_min, dsp_max);
d373 2
a374 2
	BBOX_PT(dsp_ip->dsp_xcnt+.1, dsp_ip->dsp_ycnt+1, dsp_max+.1);
	BBOX_PT(-.1,		    dsp_ip->dsp_ycnt+1, dsp_max+.1);
d388 1
a388 1
		bu_log("model space bbox (%g %g %g) (%g %g %g)\n",
d409 1
a409 1
	register int i;
d418 3
a420 3
	for (i=0 ; i < BBOX_PLANES ; i++) {
		NdotD = VDOT(dsp_pl[i], isect->r.r_dir);
		NdotPt = VDOT(dsp_pl[i], isect->r.r_pt);
d424 1
a424 1
			if ( (NdotPt - isect->dsp->dsp_pl_dist[i]) >
d427 1
a427 1
					bu_log("ray parallel and above bbox surf %d\n", i);
d433 1
a433 1
		dist = - ( NdotPt - isect->dsp->dsp_pl_dist[i] ) / NdotD;
d436 3
a438 3
			bu_log("surf[%d](%g %g %g %g) dot:%g ss_dist:%g\n",
				i, V3ARGS(dsp_pl[i]),
				isect->dsp->dsp_pl_dist[i],
d441 1
a441 1
		if ( i > 5) /* dsp_min elevation not valid bbox limit */
d448 1
a448 1
				isect->bbox.in_surf = i;
d454 1
a454 1
				isect->bbox.out_surf = i;
d1311 2
a1312 2
		bu_log("next_pt(%g %g %g) surf:%d  ss_dist:%g\n",
			V3ARGS(t), next_surf, dt);
d1320 1
a1320 1
		if (rt_g.debug & DEBUG_HF) bu_log("in base\n");
d1336 1
a1336 1
		if (rt_g.debug & DEBUG_HF) bu_log("miss above\n");
d1349 1
a1349 1
			bu_log("intersect %d %d X %s\n",
d1361 1
a1361 1
					bu_log("hit X in-wall\n");
d1363 1
a1363 1
					bu_log("miss X in-wall\n");
d1373 1
a1373 1
					bu_log("hit Y in-wall\n");
d1375 1
a1375 1
					bu_log("miss Y in-wall\n");
d1380 1
a1380 1
				bu_log("%s:%d hitting bottom of dsp for entry while past bottom?  pixel(%d,%d)\n",
d1391 2
a1392 2
			bu_log("%s:%d pixel(%d,%d) surface %d ", __FILE__, __LINE__, isect->ap->a_x, isect->ap->a_y, *cs->curr_surf);
			bu_bomb("bad surface to intersect\n");
d1410 2
a1411 2
				bu_log("%s:%d pixel(%d,%d) ", __FILE__, __LINE__, isect->ap->a_x, isect->ap->a_y);
				bu_log("hit dsp and not inside g_dsp.c line:%d", __LINE__);
d1415 1
a1415 1
				bu_log("hit X out-wall\n");
d1420 1
a1420 1
				bu_log("miss X out-wall\n");
d1460 1
d1469 1
d1473 11
a1489 2
	out_dist = isect->bbox.out_dist;
	VJOIN1(bbout_pt, isect->r.r_pt, out_dist, isect->r.r_dir);
a1514 4
	VMOVE(curr_pt, bbin_pt);
	curr_dist = bbin_dist;
	curr_surf = BBSURF(bbin_surf);

d1518 3
a1520 4
		MAT4X3PNT(t, isect->dsp->dsp_i.dsp_stom, curr_pt);
		bu_log(" in cell(%d,%d)  pt(%g %g %g) ss_dist:%g\n",
			grid_cell[X], grid_cell[Y], V3ARGS(t),
			bbin_dist);
d1523 2
a1524 3
		bu_log("out cell(%d,%d)  pt(%g %g %g) ss_dist:%g\n",
			bbout_cell[X], bbout_cell[Y], V3ARGS(t),
			out_dist);
a1536 1

d1543 1
a1543 1
		/* tX is the distance along the ray from the initial hit point
d1546 1
a1546 1
		tX = (grid_cell[X] - curr_pt[X]) / isect->r.r_dir[X];
d1548 1
d1557 2
a1558 1
			tX = ((grid_cell[X]+1) - curr_pt[X]) / isect->r.r_dir[X];
d1569 2
a1570 1
		tY = (grid_cell[Y] - curr_pt[Y]) / isect->r.r_dir[Y];
d1579 2
a1580 1
			tY = ((grid_cell[Y]+1) - curr_pt[Y]) / isect->r.r_dir[Y];
d1586 19
a1615 8
	if (rt_g.debug & DEBUG_HF) {
		bu_log("stepX:%d tDX:%g tX:%g\n",
			stepX, tDX, tX);
		bu_log("stepY:%d tDY:%g tY:%g\n",
			stepY,  tDY, tY);
	}


d1620 2
a1621 2
bu_log("cell(%d,%d) tX:%g tY:%g  inside=%d\n\t  curr_pt (%g %g %g) surf:%d  ss_dist:%g\n\t",
grid_cell[X], grid_cell[Y], tX, tY, inside, V3ARGS(t), curr_surf, curr_dist);
d1624 4
a1627 2
		if (tX > out_dist) tX = out_dist;
		if (tY > out_dist) tY = out_dist;
d1629 12
d1643 3
d1656 3
d1674 5
d1805 1
d1810 8
@


1.33
log
@Mods to get it to compile on a SUN4.
@
text
@d49 1
a49 1
static char RCSdsp[] = "@@(#)$Header: /m/cad/librt/RCS/g_dsp.c,v 1.32 1997/10/28 02:35:28 butler Exp jra $ (BRL)";
d326 1
a326 1
	RES_ACQUIRE( &rt_g.res_model);
d328 1
a328 1
	RES_RELEASE( &rt_g.res_model);
d584 1
a584 1
	RES_ACQUIRE( &rt_g.res_model);
d586 1
a586 1
	RES_RELEASE( &rt_g.res_model);
d589 1
a589 1
	RES_ACQUIRE( &rt_g.res_syscall);
d764 1
a764 1
		RES_RELEASE( &rt_g.res_syscall);
d1877 1
a1877 1
		RES_ACQUIRE( &rt_g.res_model);
d1879 1
a1879 1
		RES_RELEASE( &rt_g.res_model);
d1882 1
a1882 1
		RES_ACQUIRE( &rt_g.res_syscall);
d1900 1
a1900 1
		RES_RELEASE( &rt_g.res_syscall);
d1995 1
a1995 1
				RES_ACQUIRE( &rt_g.res_model);
d1997 1
a1997 1
				RES_RELEASE( &rt_g.res_model);
d2000 1
a2000 1
				RES_ACQUIRE( &rt_g.res_syscall);
d2018 1
a2018 1
				RES_RELEASE( &rt_g.res_syscall);
d2135 1
a2135 1
		RES_ACQUIRE( &rt_g.res_model);
d2137 1
a2137 1
		RES_RELEASE( &rt_g.res_model);
d2140 1
a2140 1
		RES_ACQUIRE( &rt_g.res_syscall);
d2149 1
a2149 1
		RES_RELEASE( &rt_g.res_syscall);
@


1.32
log
@fixed bug with ray hitting seam between 2 triangle patches.
@
text
@d49 1
a49 1
static char RCSdsp[] = "@@(#)$Header: /m/cad/librt/RCS/g_dsp.c,v 1.31 1997/08/01 17:58:29 jra Exp butler $ (BRL)";
d893 1
a893 1
	int tri1, tri2;
d895 1
a895 1
	set_and_permute(isect, cell, A, B, C, D, &tri1, &tri2);
d939 1
a939 1
		reason1 = "miss tri1 (alpha)\n";
d949 1
a949 1
		reason1 = "miss tri1 (beta)\n";
d953 1
a953 1
		reason1 = "miss tri1 (alpha+beta > NdotD)\n";
d961 1
a961 1
		bu_log("missed tri1 %s\n", reason1);
d980 1
a980 1
		reason2 = "miss tri2 (alpha)\n";
d988 1
a988 1
		reason2 = "miss tri2 (beta)\n";
d993 1
a993 1
		reason2 = "miss tri2 (alpha+beta > NdotD)\n";
d1002 1
a1002 1
		bu_log("missed tri2 %s\n", reason2);
d1033 1
a1033 1
			first_tri = tri1;
d1037 1
a1037 1
			second_tri = tri2;
d1044 1
a1044 1
			first_tri = tri2;
d1048 1
a1048 1
			second_tri = tri1;
d1109 1
a1109 1
			INHIT(isect, dist1, tri1, cell);
d1122 1
a1122 1
			OUTHIT(isect, dist1, tri1, cell);
d1141 1
a1141 1
			INHIT(isect, dist2, tri2, cell);
d1154 1
a1154 1
			OUTHIT(isect, dist2, tri2, cell);
d1611 1
a1611 1
				&isect_cell_x_wall);
d1621 1
a1621 1
				&isect_cell_y_wall);
@


1.31
log
@Added du and dv calculations to rt_dsp_uv().
@
text
@d49 1
a49 1
static char RCSdsp[] = "@@(#)$Header: /m/cad/librt/RCS/g_dsp.c,v 1.30 1997/08/01 12:20:26 jra Exp jra $ (BRL)";
d585 1
a585 1
	sprintf(buf, "dsp%d.pl", plot_file_num++);
d1008 11
d1029 1
d1032 1
a1032 1
				bu_log("hit triangles: ss_dist1:%g ss_dist2:%g \n", dist1, dist2);
d1043 1
a1043 1
				bu_log("hit triangles: ss_dist2:%g ss_dist1:%g \n", dist2, dist1);
d1166 4
a1169 2


d1219 4
d1271 4
a1274 1

d1284 6
d1430 4
a1463 5
	/* since we're probably starting in the middle of a cell, we need
	 * to compute the distance along the ray to the initial
	 * X and Y boundaries.
	 */

d1524 3
a1526 1

d1605 2
d1878 1
a1878 1
		sprintf(buf, "dsp%d.pl", plot_file_num++);
d1996 1
a1996 1
				sprintf(buf, "dsp%d.pl", plot_file_num++);
d2136 1
a2136 1
		sprintf(buf, "dsp%d.pl", plot_file_num++);
@


1.30
log
@Lee's changes.
@
text
@d49 1
a49 1
static char RCSdsp[] = "@@(#)$Header: /m/cad/librt/RCS/g_dsp.c,v 1.29 1997/07/31 20:10:13 butler Exp butler $ (BRL)";
d2167 8
d2178 21
a2198 2
	x = pt[X];	/* float/int conv */
	y = pt[Y];	/* float/int conv */
a2199 11
	if (x >= XSIZ(dsp)) x = XSIZ(dsp)-1;
	if (y >= YSIZ(dsp)) y = YSIZ(dsp)-1;

	u = x / (XSIZ(dsp)-1.0);
	v = y / (YSIZ(dsp)-1.0);

	uvp->uv_u = u;
	uvp->uv_v = v;

#define DUDV
#ifdef DUDV
d2201 2
d2204 25
a2228 1
	VSETALL(v_m, r);
a2229 13
	MAT4X3VEC(v_s, dsp->dsp_i.dsp_mtos, v_m);

	/* XXX this is a gross approximation */
	VSET(tmp, v_s[X], 0.0, 0.0);
	uvp->uv_du = MAGNITUDE(tmp);

	VSET(tmp, 0.0, v_s[Y], 0.0);
	uvp->uv_dv = MAGNITUDE(tmp);
#else
	/* XXX The texture anti-aliasing stuff doesn't actually work */
	uvp->uv_du = 0.0;
	uvp->uv_dv = 0.0;
#endif
d2231 1
a2231 1
		bu_log("rt_dsp_uv(pt:%g,%g siz:%d,%d)\n r=%g rbeam=%g diverge=%g dist=%g\n u=%g v=%g du=%g dv=%g\n",
d2233 1
@


1.29
log
@checkpoint
@
text
@d49 1
a49 1
static char RCSdsp[] = "@@(#)$Header: /m/cad/librt/RCS/g_dsp.c,v 1.28 1997/07/23 21:32:19 butler Exp $ (BRL)";
d411 3
d1940 1
a1940 1
#undef SMOOTHSTEP(x)
@


1.28
log
@more appropriate smoothing.
@
text
@d49 1
a49 1
static char RCSdsp[] = "@@(#)$Header: /m/cad/librt/RCS/g_dsp.c,v 1.27 1997/07/22 23:55:41 butler Exp butler $ (BRL)";
d780 1
a780 1
	int sub[2], sup[2];
d782 2
a783 2
	vect_t Aline, Bline, Cline, Dline;
	double dot1, dot2;
d785 2
a786 7
	/*  C	 D
	 *   *--*
	 *   | /|
	 *   |/ |
	 *   *--*
	 *  A    B
	 */
a791 4
	sub[X] = cell[X] - 1;
	sub[Y] = cell[Y] - 1;
	sup[X] = cell[X] + 1;
	sup[Y] = cell[Y] + 1;
d793 17
a809 2
	if (sub[X] < 0) sub[X] = 0;
	if (sub[Y] < 0) sub[Y] = 0;
d811 4
a814 2
	if (sup[X] > XSIZ(isect->dsp)) sup[X] = XSIZ(isect->dsp);
	if (sup[Y] > YSIZ(isect->dsp)) sup[Y] = YSIZ(isect->dsp);
d816 2
a817 4
	VSET(tmp,	 sub[X], sub[Y],
	 DSP(isect->dsp, sub[X], sub[Y]));
	VSUB2(Aline, A, tmp);
	VUNITIZE(Aline);
d819 2
a820 4
	VSET(tmp,	 sup[X], sup[Y],
	 DSP(isect->dsp, sup[X], sup[Y]));
	VSUB2(Dline, tmp, D);
	VUNITIZE(Dline);
a821 2
	VSUB2(tmp, D, A);
	VUNITIZE(tmp);
d823 5
a827 1
	dot1 = VDOT(Aline, tmp) + VDOT(Dline, tmp);
d829 1
a830 4
	VSET(tmp,	 sub[X], sup[Y],
	 DSP(isect->dsp, sub[X], sup[Y]));
	VSUB2(Cline, tmp, C);
	VUNITIZE(Cline);
d832 5
a836 3
	VSET(tmp, sup[X], sub[Y], DSP(isect->dsp, sup[X], sub[Y]));
	VSUB2(Bline, B, tmp);
	VUNITIZE(Bline);
d838 1
a838 2
	VSUB2(tmp, C, B);
	VUNITIZE(tmp);
d840 1
a840 3
	dot2 = VDOT(Cline, tmp) + VDOT(Bline, tmp);

	if ( dot1 > dot2 ) {
d1409 1
a1409 1
	int	cell_bbox[4];
a1925 2
#if 1
#define SMOOTHSTEP(x)  ((x)*(x)*(3 - 2*(x)))
a1927 1
			Xfrac = SMOOTHSTEP( Xfrac );
d1931 9
a1939 2
			Yfrac = SMOOTHSTEP( Yfrac );
#endif
d2179 1
a2183 1
	VUNITIZE(v_m);
d2199 1
a2199 1
		bu_log("rt_dsp_uv(pt:%g,%g siz:%d,%d) u=%g v=%g du=%g dv=%g\n",
d2201 1
@


1.27
log
@added support for cutting cells along either diagonal
@
text
@d49 1
a49 1
static char RCSdsp[] = "@@(#)$Header: /m/cad/librt/RCS/g_dsp.c,v 1.26 1997/07/22 16:50:27 butler Exp butler $ (BRL)";
d551 3
a553 1

d765 7
d811 1
d816 6
d823 1
d827 1
d831 1
d833 4
a836 2
	dot1 = VDOT(Aline, Dline);
	dot2 = VDOT(Bline, Cline);
a862 2
 *
 *
@


1.26
log
@converted to using cell_isect()
l
@
text
@d49 1
a49 1
static char RCSdsp[] = "@@(#)$Header: /m/cad/librt/RCS/g_dsp.c,v 1.25 1997/07/22 01:02:22 butler Exp butler $ (BRL)";
d78 2
d763 35
d799 3
d803 3
d807 31
d855 1
a855 1
	vect_t N;
d869 1
d871 1
a871 11
	/*  C	 D
	 *   *--*
	 *   | /|
	 *   |/ |
	 *   *--*
	 *  A    B
	 */
	VSET(A, cell[X],   cell[Y],   DSP(isect->dsp, cell[X],   cell[Y])  );
	VSET(B, cell[X]+1, cell[Y],   DSP(isect->dsp, cell[X]+1, cell[Y])  );
	VSET(C, cell[X],   cell[Y]+1, DSP(isect->dsp, cell[X],   cell[Y]+1));
	VSET(D, cell[X]+1, cell[Y]+1, DSP(isect->dsp, cell[X]+1, cell[Y]+1));
d887 1
d897 2
a898 2
	VCROSS(N, AB, AD);
	NdotD1 = VDOT( N, isect->r.r_dir);
d933 1
a933 1
	dist1 = VDOT( PA, N ) / NdotD1;
d941 2
a942 2
	VCROSS(N, AD, AC);
	NdotD2 = VDOT( N, isect->r.r_dir);
d974 1
a974 1
	dist2 = VDOT( PA, N ) / NdotD2;
d991 1
d997 1
a997 1
			first_tri = TRI1;
d1000 2
a1001 1
			second_tri = TRI2;
d1004 1
d1008 1
a1008 1
			first_tri = TRI2;
d1011 2
a1012 1
			second_tri = TRI1;
d1015 1
d1045 1
a1045 1
			OUTHIT(isect, first, TRI1, cell);
d1073 1
a1073 1
			INHIT(isect, dist1, TRI1, cell);
d1086 1
a1086 1
			OUTHIT(isect, dist1, TRI1, cell);
d1105 1
a1105 1
			INHIT(isect, dist2, TRI2, cell);
d1118 1
a1118 1
			OUTHIT(isect, dist2, TRI2, cell);
d1245 1
a1245 1
int inside;
d1270 1
a1270 1
	    	if (!inside) {
d1272 1
a1272 1
	    		inside = 1;
d1278 1
a1278 1
		    		cs->curr_pt, next_pt, 0, 0.0, 0, 0.0, inside);
d1286 1
a1286 1
	    	if (inside) {
d1288 1
a1288 1
	    		inside = 0;
d1292 1
a1292 1
		    		cs->curr_pt, next_pt, 0, 0.0, 0, 0.0, inside);
d1344 1
a1344 1
		if (hit && !inside) {
d1347 1
a1347 1
			inside = 1;
d1352 1
a1352 1
			&inside);
d1358 1
a1358 1
			if (!inside) {
d1366 1
a1366 1
			inside = 1;
d1556 1
a1556 1
			cell_isect(isect, tX, outsurfX, &cs, inside, rising,
d1566 1
a1566 1
			cell_isect(isect, tY, outsurfY, &cs, inside, rising,
d1880 2
a1881 1
		if (  hitp->hit_surfno == TRI2 ||  hitp->hit_surfno == TRI1 ) {
d1901 1
d1904 11
a1914 1
	
d1918 1
d1923 1
a1924 1

d1968 8
a1976 2
			cell[X] = hitp->hit_vpriv[X];
			cell[Y] = hitp->hit_vpriv[Y];
a1992 2
			cell[X] = hitp->hit_vpriv[X];
			cell[Y] = hitp->hit_vpriv[Y];
d2006 39
@


1.25
log
@checkpoint, halfway to cell_isect() usage
@
text
@a0 2
#define CELL_ISECT

d49 1
a49 1
static char RCSdsp[] = "@@(#)$Header: /m/cad/librt/RCS/g_dsp.c,v 1.24 1997/07/02 02:59:28 butler Exp butler $ (BRL)";
d1158 1
a1158 1
#ifdef CELL_ISECT
a1307 3

#endif

a1335 2

#ifdef CELL_ISECT
a1336 7
#else
	short	cell_min;
	short	cell_max;
	point_t next_pt;	/* exit pt from cell */
	int	next_surf;	/* surface of cel bbox for next_pt */
	int hit=0;		/* boolean */
#endif
a1454 1
#ifdef CELL_ISECT
a1463 1
#endif
d1482 1
a1482 1
#ifdef CELL_ISECT
a1502 273

#else
		if (tX < tY) {
			/* dist along ray to next X cell boundary is closer
			 * than dist to next Y cell boundary
			 */
			VJOIN1(next_pt, bbin_pt, tX, isect->r.r_dir);
			next_surf = outsurfX;

			if (rt_g.debug & DEBUG_HF) {
				vect_t t;
				MAT4X3PNT(t, isect->dsp->dsp_i.dsp_stom, next_pt);
				bu_log("X next_pt(%g %g %g) surf:%d  ss_dist:%g\n",
					V3ARGS(t), next_surf, tX);
			}
			cell_minmax(isect->dsp, grid_cell[X], grid_cell[Y],
				&cell_min, &cell_max);

			if (( rising && next_pt[Z] < cell_min) ||
			    (!rising && curr_pt[Z] < cell_min) ) {
				/* in base */
				if (rt_g.debug & DEBUG_HF) bu_log("in base\n");
			    	if (!inside) {
			    		INHIT(isect, curr_dist, curr_surf,
			    			grid_cell);
			    		inside = 1;
			    	}
			    	OUTHIT(isect, (bbin_dist+tX), outsurfX, grid_cell);

			    	if (rt_g.debug & DEBUG_HF)
				    	plot_cell_ray(isect, grid_cell, 
				    		curr_pt, next_pt, 0, 0.0, 0, 0.0, inside);


			} else if (
			    ( rising && curr_pt[Z] > cell_max) ||
			    (!rising && next_pt[Z] > cell_max) ) {
				/* miss above */
				if (rt_g.debug & DEBUG_HF) bu_log("miss above\n");
			    	if (inside) {
			    		HIT_COMMIT(isect);
			    		inside = 0;
			    	}
			    	if (rt_g.debug & DEBUG_HF)
				    	plot_cell_ray(isect, grid_cell, 
				    		curr_pt, next_pt, 0, 0.0, 0, 0.0, inside);


			} else {
				/* intersect */
				if (rt_g.debug & DEBUG_HF)
					bu_log("intersect %d %d X %s\n",
						cell_min, cell_max, 
						(rising?"rising":"falling") );

				switch (curr_surf) {
				case BBSURF(XMIN) :
				case BBSURF(XMAX) :
					hit = isect_cell_x_wall(
						isect, grid_cell, curr_surf,
						curr_dist, curr_pt);
					if (rt_g.debug & DEBUG_HF) {
						if (hit)
							bu_log("hit X in-wall\n");
						else
							bu_log("miss X in-wall\n");
					}
					break;
				case BBSURF(YMIN) :
				case BBSURF(YMAX) :
					hit = isect_cell_y_wall(
						isect, grid_cell, curr_surf,
						curr_dist, curr_pt);
					if (rt_g.debug & DEBUG_HF) {
						if (hit)
							bu_log("hit Y in-wall\n");
						else
							bu_log("miss Y in-wall\n");
					}
					break;
				case BBSURF(ZMIN) :
					if (curr_dist != bbin_dist){
						bu_log("%s:%d hitting bottom of dsp for entry while past bottom?  pixel(%d,%d)\n",
							__FILE__, __LINE__,
							isect->ap->a_x, isect->ap->a_y);
						bu_bomb("");
					}
					hit = 1;
					break;
				case BBSURF(ZMAX) :
					hit = 0;
					break;
				default:
					bu_log("%s:%d pixel(%d,%d) surface %d ", __FILE__, __LINE__, isect->ap->a_x, isect->ap->a_y, curr_surf);
					bu_bomb("bad surface to intersect\n");
				}

				if (hit && !inside) {
					INHIT(isect, curr_dist,
						curr_surf, grid_cell);
					inside = 1;
				}

				isect_ray_triangles(isect, grid_cell,
					curr_pt, next_pt,
					&inside);


				hit = isect_cell_x_wall(
					isect, grid_cell, outsurfX,
					tX, next_pt);

				if (hit) {
					if (!inside) {
						bu_log("%s:%d pixel(%d,%d) ", __FILE__, __LINE__, isect->ap->a_x, isect->ap->a_y);
/* XXX */					bu_log("hit dsp and not inside g_dsp.c line:%d", __LINE__);
						bu_bomb("");
					}
					if (rt_g.debug & DEBUG_HF)
						bu_log("hit X out-wall\n");
					OUTHIT(isect, (bbin_dist+tX), next_surf, grid_cell);
					inside = 1;
				} else {
					if (rt_g.debug & DEBUG_HF)
						bu_log("miss X out-wall\n");
				}
			} 

			/* step to next cell in X direction */
			VMOVE(curr_pt, next_pt);
			grid_cell[X] += stepX;
			curr_surf = insurfX;

			curr_dist = tX;
			
			/* update dist along ray to next X cell boundary */
			tX += tDX;
		} else {
			/* dist along ray to next Y cell boundary is closer
			 * than dist to next X cell boundary
			 */
			VJOIN1(next_pt, bbin_pt, tY, isect->r.r_dir);
			next_surf = outsurfY;

			if (rt_g.debug & DEBUG_HF) {
				vect_t t;
				MAT4X3PNT(t, isect->dsp->dsp_i.dsp_stom, next_pt);
				bu_log("Y next_pt(%g %g %g) surf:%d ss_dist:%g\n",
					V3ARGS(t), next_surf, tY);
			}


			cell_minmax(isect->dsp, grid_cell[X], grid_cell[Y],
				&cell_min, &cell_max);

			if (( rising && next_pt[Z] < cell_min) || 
			    (!rising && curr_pt[Z] < cell_min) ) {
				/* in base */
				if (rt_g.debug & DEBUG_HF) bu_log("in base\n");
			    	if (!inside) {
			    		INHIT(isect, curr_dist, curr_surf,
			    			grid_cell);
			    		inside = 1;
			    	}
			    	OUTHIT(isect, (bbin_dist+tY), outsurfY, grid_cell);
			    	if (rt_g.debug & DEBUG_HF)
				    	plot_cell_ray(isect, grid_cell, 
				    		curr_pt, next_pt, 0, 0.0, 0, 0.0, inside);

			} else if (
			    ( rising && curr_pt[Z] > cell_max) ||
			    (!rising && next_pt[Z] > cell_max) ) {
				/* miss above */
				if (rt_g.debug & DEBUG_HF) bu_log("miss above\n");
			    	if (inside) {
			    		HIT_COMMIT(isect);
			    		inside = 0;
			    	}
			    	if (rt_g.debug & DEBUG_HF)
				    	plot_cell_ray(isect, grid_cell, 
				    		curr_pt, next_pt, 0, 0.0, 0, 0.0, inside);

			} else {
				/* intersect */
				if (rt_g.debug & DEBUG_HF)
					bu_log("intersect %d %d Y %s\n",
						cell_min, cell_max, 
						(rising?"rising":"falling") );

				switch (curr_surf) {
				case BBSURF(XMIN) :
				case BBSURF(XMAX) :
					hit = isect_cell_x_wall(
						isect, grid_cell, curr_surf,
						curr_dist, curr_pt);

					if (rt_g.debug & DEBUG_HF) {
						if (hit)
							bu_log("hit X in-wall\n");
						else
							bu_log("miss X in-wall\n");
					}
					break;
				case BBSURF(YMIN) :
				case BBSURF(YMAX) :

					hit = isect_cell_y_wall(
						isect, grid_cell, curr_surf,
						curr_dist, curr_pt);
					if (rt_g.debug & DEBUG_HF) {
						if (hit)
							bu_log("hit Y in-wall\n");
						else
							bu_log("miss Y in-wall\n");
					}
					break;
				case BBSURF(ZMIN) :
					if (curr_dist != bbin_dist) {
						bu_log("%s:%d pixel(%d,%d) hitting bottom of dsp for entry while past bottom?\n",
							__FILE__, __LINE__,
							isect->ap->a_x, isect->ap->a_y);
						bu_bomb("");
					}
					hit = 1;
					break;
				case BBSURF(ZMAX) :
					hit = 0;
					break;
				default:
					bu_log("%s:%d pixel(%d,%d) surface %d ", __FILE__, __LINE__, isect->ap->a_x, isect->ap->a_y, curr_surf);
					bu_bomb("bad surface to intersect\n");
				}

				if (hit && !inside) {
					INHIT(isect, curr_dist,
						curr_surf, grid_cell);
					inside = 1;
				}

				isect_ray_triangles(isect, grid_cell,
					curr_pt, next_pt,
					&inside);

				hit = isect_cell_y_wall(
					isect, grid_cell, outsurfY,
					tY, next_pt);

				if (hit) {
					if (!inside) {
						bu_log("%s:%d pixel(%d,%d) ", __FILE__, __LINE__, isect->ap->a_x, isect->ap->a_y);
						bu_log("hit and not inside g_dsp.c line:%d", __LINE__);
						bu_bomb("");
					}
					if (rt_g.debug & DEBUG_HF)
						bu_log("hit Y out-wall\n");
					OUTHIT(isect, (bbin_dist+tY), next_surf, grid_cell);
					inside = 1;
				} else {
					if (rt_g.debug & DEBUG_HF)
						bu_log("miss Y out-wall\n");
				}
			}

			/* step to next cell in Y direction */
			VMOVE(curr_pt, next_pt);
			grid_cell[Y] += stepY;
			curr_surf = insurfY;
			curr_dist = tY;
			
			/* update dist along ray to next Y cell boundary */
			tY += tDY;
		}
#endif
@


1.24
log
@u,v coords and misc cleanup
@
text
@d1 2
d51 1
a51 1
static char RCSdsp[] = "@@(#)$Header: /m/cad/librt/RCS/g_dsp.c,v 1.23 1997/07/01 21:39:09 butler Exp butler $ (BRL)";
d1063 1
a1063 1
int
d1112 1
a1112 1
int
d1160 152
a1326 2
	point_t next_pt;	/* exit pt from cell */
	int	next_surf;	/* surface of cel bbox for next_pt */
a1327 2
	short	cell_min;
	short	cell_max;
a1336 1
	int hit=0;		/* boolean */
d1340 11
a1351 1
	double	tX, tY;	/* dist along ray from hit pt. to next cell boundary */
d1469 12
d1498 23
a1651 5
			




d1791 1
a1791 1

@


1.23
log
@Seem to have Gourand normals working.
@
text
@d49 1
a49 1
static char RCSdsp[] = "@@(#)$Header: /m/cad/librt/RCS/g_dsp.c,v 1.22 1997/06/30 19:27:04 butler Exp butler $ (BRL)";
d230 1
a230 1
static int debug_pprint=0;
a549 125





void
print_isect_segs(isect, inside)
struct isect_stuff *isect;
int *inside;
{
	char buf[128];
	FILE *fd;
	struct seg *seg_p;
	point_t in, out, t;
	point_t in_pt, out_pt;

	RES_ACQUIRE( &rt_g.res_model);
	sprintf(buf, "dsp%d.pl", plot_file_num++);
	RES_RELEASE( &rt_g.res_model);
	bu_log("error plot %s\n", buf);

	bu_log("inside:%d\n", *inside);

	for (BU_LIST_FOR(seg_p, seg, &isect->seglist)) {
		VJOIN1(t, isect->r.r_pt, seg_p->seg_in.hit_dist,
			isect->r.r_dir);
		MAT4X3PNT(in, isect->dsp->dsp_i.dsp_stom, t);

		VJOIN1(t, isect->r.r_pt, seg_p->seg_out.hit_dist,
			isect->r.r_dir);
		MAT4X3PNT(out, isect->dsp->dsp_i.dsp_stom, t);

		bu_log("in(%g %g %g)  out(%g %g %g)\n",
			V3ARGS(in), V3ARGS(out));
	}
	if (*inside) {
		VJOIN1(t, isect->r.r_pt, isect->sp->seg_in.hit_dist,
			isect->r.r_dir);
		MAT4X3PNT(in, isect->dsp->dsp_i.dsp_stom, t);

		bu_log("in(%g %g %g)\n", in);
	}

	RES_ACQUIRE( &rt_g.res_syscall);
	if ((fd=fopen(buf, "w")) != (FILE *)NULL) {
		pl_color(fd, 255, 255, 255);

		for (BU_LIST_FOR(seg_p, seg, &isect->seglist)) {
			VJOIN1(in, isect->r.r_pt, seg_p->seg_in.hit_dist,
				isect->r.r_dir);
			MAT4X3PNT(in_pt, isect->dsp->dsp_i.dsp_stom, in);

			VJOIN1(out, isect->r.r_pt, seg_p->seg_out.hit_dist,
				isect->r.r_dir);
			MAT4X3PNT(out_pt, isect->dsp->dsp_i.dsp_stom, out);

			pdv_3line(fd, in_pt, out_pt);
		}

		if (*inside) {
			pl_color(fd, 128, 128, 128);
			VJOIN1(in, isect->r.r_pt, isect->sp->seg_in.hit_dist,
				isect->r.r_dir);
			MAT4X3PNT(in_pt, isect->dsp->dsp_i.dsp_stom, in);
			VADD2(out, in, isect->r.r_dir);
			MAT4X3PNT(out_pt, isect->dsp->dsp_i.dsp_stom, out);

			pdv_3line(fd, in_pt, out_pt);
		}

		fclose(fd);
	}

	RES_RELEASE( &rt_g.res_syscall);

}


static void
do_hit(dist, inside, NdotD, isect, TR, ts, cell, line)
double dist;
int *inside;
double NdotD;
struct isect_stuff *isect;
int TR;
char *ts;
int cell[3];
int line;
{
	/* XXX what if we're inside, leave tri2 before we enter tri1 ? */
	if (NdotD < 0.0) {
		/* Entering Solid */
		if (*inside) {
			bu_log("%s:%d from %d NdotD:%g pixel(%d,%d)\n",
				__FILE__, __LINE__, line, NdotD, 
				isect->ap->a_x, isect->ap->a_y);
			print_isect_segs(isect, inside);
			bu_bomb("Can't enter DSP top from inside\n");
		}
		if (rt_g.debug & DEBUG_HF) bu_log("hit %s entering\n", ts);

		INHIT(isect, dist, TR, cell);

		*inside = 1;

	} else {
		/* Leaving Solid */
		if (! *inside) {
			bu_log("%s:%d from %d NdotD:%g pixel(%d,%d)\n",
				__FILE__, __LINE__, line, NdotD,
				isect->ap->a_x, isect->ap->a_y);
			print_isect_segs(isect, inside);
			bu_bomb("Can't leave DSP top from outside\n");
		}

		if (rt_g.debug & DEBUG_HF) bu_log("hit %s leaving\n", ts);

		OUTHIT(isect, dist, TR, cell);

		HIT_COMMIT(isect);

		*inside = 0;
	}
}

a552 1

a1059 8
/* These macros are for the isect_ray_dsp routine.  These exist as macros
 * only because we can't do inline subroutines in C, and we don't want to
 * pay the overhead of the subroutine call.
 */




a1188 7
	/* tmp values for various macros including:
	 *	CELL_MIN, CELL_MAX
	 *	ISECT_ENTRY_WALL()
	 *	ISECT_{XY}_EXIT_WALL()
	short	h, i;
	 */

d2094 1
a2094 1
 *  For a hit on the surface of an dsp, return the (u,v) coordinates
d2108 9
d2118 20
a2137 2
	if (rt_g.debug & DEBUG_HF)
		bu_log("rt_dsp_uv()\n");
d2139 4
a2142 2
	uvp->uv_u = 0.0;
	uvp->uv_v = 0.0;
d2145 6
@


1.22
log
@fixed error in min/max computation during prep
@
text
@d49 1
a49 1
static char RCSdsp[] = "@@(#)$Header: /m/cad/librt/RCS/g_dsp.c,v 1.20 1997/06/27 18:46:16 butler Exp butler $ (BRL)";
d209 1
d221 1
d240 2
a241 2
	bu_vls_printf( vls, "Displacement Map\n  file='%s' xc=%d yc=%d\n",
		dsp_ip->dsp_file, dsp_ip->dsp_xcnt, dsp_ip->dsp_ycnt);
a718 2
		MAT4X3PNT(pt, isect->dsp->dsp_i.dsp_stom, tmp);

d881 1
a921 6
	FILE *fd;
	short h, i;

	point_t tmp;


d961 1
a961 1
	reason1 = "";
d996 4
d1005 1
a1005 1
	reason2 = "";
d1037 3
d1318 1
a1318 1
/*	vect_t	pDX, pDY;	/* vector for 1 cell change in x, y */
d1332 1
a1332 1
				
d1788 1
a1830 1
		point_t junk;
d1832 1
d1923 1
a1923 1
	rt_vstub( stp, rp, segp, n, ap );
d1926 99
d2040 1
d2049 32
d2082 29
a2110 6
	} else if ( hitp->hit_surfno == TRI1 ) {
		cell[X] = hitp->hit_vpriv[X];
		cell[Y] = hitp->hit_vpriv[Y];
		
		VSET(tmp, cell[X],   cell[Y],   DSP(dsp, cell[X],   cell[Y])  );
		MAT4X3PNT(A, dsp->dsp_i.dsp_stom, tmp);
d2112 2
a2113 2
		VSET(tmp, cell[X]+1, cell[Y],   DSP(dsp, cell[X]+1, cell[Y])  );
		MAT4X3PNT(B, dsp->dsp_i.dsp_stom, tmp);
d2115 16
a2130 2
		VSET(tmp, cell[X]+1, cell[Y]+1, DSP(dsp, cell[X]+1, cell[Y]+1));
		MAT4X3PNT(D, dsp->dsp_i.dsp_stom, tmp);
d2132 2
d2135 2
a2136 2
		VSUB2(AB, B, A);
		VSUB2(AD, D, A);
a2137 1
		VCROSS(N, AB, AD); 
d2139 2
a2140 3
	} else if ( hitp->hit_surfno == TRI2 ) {
		cell[X] = hitp->hit_vpriv[X];
		cell[Y] = hitp->hit_vpriv[Y];
d2142 4
a2145 2
		VSET(tmp, cell[X],   cell[Y],   DSP(dsp, cell[X],   cell[Y])  );
		MAT4X3PNT(A, dsp->dsp_i.dsp_stom, tmp);
d2147 2
a2148 2
		VSET(tmp, cell[X],   cell[Y]+1, DSP(dsp, cell[X],   cell[Y]+1));
		MAT4X3PNT(C, dsp->dsp_i.dsp_stom, tmp);
d2150 2
a2151 2
		VSET(tmp, cell[X]+1, cell[Y]+1, DSP(dsp, cell[X]+1, cell[Y]+1));
		MAT4X3PNT(D, dsp->dsp_i.dsp_stom, tmp);
d2153 2
a2154 2
		VSUB2(AD, D, A);
		VSUB2(AC, C, A);
d2156 2
a2158 1
		VCROSS(N, AD, AC); 
d2160 6
a2165 4
	} else {
		bu_log("%s:%d ", __FILE__, __LINE__);
		bu_log("bogus surface of DSP %d\n", hitp->hit_surfno);
		bu_bomb("");
d2194 3
d2201 1
a2201 1
			VADD2(tmp, hitp->hit_point, N);
d2205 1
d2533 1
@


1.21
log
@checkpoint
@
text
@d144 4
a147 3
		point_t in; \
		VJOIN1(in, isp->r.r_pt, dist, isp->r.r_dir); \
		bu_log("line %d New in pt(%g %g %g) dist %g surf: %d\n", \
d163 4
a166 3
		point_t out; \
		VJOIN1(out, isp->r.r_pt, dist, isp->r.r_dir); \
		bu_log("line %d New out pt(%g %g %g) dist %g surf:%d\n", \
d332 1
a332 1
	for (y=0 ; y < YSIZ(dsp) ; y++) {
d334 1
a334 1
		for (x=1 ; x < XCNT(dsp) ; x++) {
d345 1
a345 1
		bu_log("min %d max %d\n", dsp_min, dsp_max);
d429 1
a429 1
			bu_log("surf[%d](%g %g %g %g) dot:%g dist:%g\n",
d453 4
a456 3
		vect_t pt;
		VJOIN1(pt, isect->r.r_pt, isect->bbox.in_dist, isect->r.r_dir);
		bu_log("solid rpp in  surf[%d] dist:%g (%g %g %g)\n",
d458 3
a460 2
		VJOIN1(pt, isect->r.r_pt, isect->bbox.out_dist, isect->r.r_dir);
		bu_log("solid rpp out surf[%d] dist:%g  (%g %g %g)\n",
d494 2
a495 2
		vect_t pt;
		VJOIN1(pt, isect->r.r_pt, isect->minbox.in_dist, isect->r.r_dir);
d497 3
a499 1
		bu_log("solid minbox rpp in  surf[%d] dist:%g (%g %g %g)\n",
d502 4
a505 2
		VJOIN1(pt, isect->r.r_pt, isect->minbox.out_dist, isect->r.r_dir);
		bu_log("solid minbox rpp out surf[%d] dist:%g (%g %g %g)\n",
d561 1
a561 1
	point_t in, out;
d572 1
a572 1
		VJOIN1(in, isect->r.r_pt, seg_p->seg_in.hit_dist,
d574 1
d576 1
a576 1
		VJOIN1(out, isect->r.r_pt, seg_p->seg_out.hit_dist,
d578 1
d584 1
a584 1
		VJOIN1(in, isect->r.r_pt, isect->sp->seg_in.hit_dist,
d586 2
d940 1
d942 9
a950 4
		VPRINT("A", A);
		VPRINT("B", B);
		VPRINT("C", C);
		VPRINT("D", D);
d1053 1
a1053 1
				bu_log("hit triangles: dist1:%g dist2:%g \n", dist1, dist2);
d1062 1
a1062 1
				bu_log("hit triangles: dist2:%g dist1:%g \n", dist2, dist1);
d1117 1
a1117 1
				bu_log("hit triangle 1 entering dist:%g\n", dist1);
d1131 1
a1131 1
				bu_log("hit triangle 1 leaving dist:%g\n", dist1);
d1150 1
a1150 1
				bu_log("hit triangle 2 entering dist:%g\n", dist2);
d1164 1
a1164 1
				bu_log("hit triangle 2 leaving dist:%g\n", dist2);
d1206 3
a1208 3
	if (rt_g.debug & DEBUG_HF)
		bu_log("isect_cell_x_wall() cell(%d,%d) surf:%d dist:%g pt(%g %g %g)\n",
			V2ARGS(cell), surf, dist, V3ARGS(pt));
d1210 3
d1255 2
a1256 3
	if (rt_g.debug & DEBUG_HF)
		bu_log("isect_cell_y_wall() cell(%d,%d) surf:%d dist:%d pt(%g %g %g)\n",
			V2ARGS(cell), surf, dist, V3ARGS(pt));
d1258 4
d1382 5
a1386 2
		bu_log(" in cell(%d,%d)  pt(%g %g %g) dist:%g\n",
			grid_cell[X], grid_cell[Y], V3ARGS(curr_pt),
d1388 4
a1391 2
		bu_log("out cell(%d,%d)  pt(%g %g %g) dist:%g\n",
			bbout_cell[X], bbout_cell[Y], V3ARGS(bbout_pt),
d1459 6
a1464 3
		if (rt_g.debug & DEBUG_HF)
bu_log("cell(%d,%d) tX:%g tY:%g  inside=%d\n\t  curr_pt (%g %g %g) surf:%d  dist:%g\n\t",
grid_cell[X], grid_cell[Y], tX, tY, inside, V3ARGS(curr_pt), curr_surf, curr_dist);
d1473 6
a1478 4
			if (rt_g.debug & DEBUG_HF)
				bu_log("X next_pt(%g %g %g) surf:%d  dist:%g\n",
					V3ARGS(next_pt), next_surf, tX);

d1579 1
a1579 1
						bu_log("hit dsp and not inside g_dsp.c line:%d", __LINE__);
d1613 6
a1618 2
			if (rt_g.debug & DEBUG_HF)
				bu_log("Y next_pt(%g %g %g) surf:%d dist:%g\n", V3ARGS(next_pt), next_surf, tY);
d2000 1
a2000 1
		if ( hitp->hit_surfno == TRI1 || hitp->hit_surfno == TRI2 )
d2007 1
a2007 1
		else
d2013 1
a2013 1

a2510 94






















#if 0

			/* plot the normal */
			pl_color(fd, 40, 180, 40);
			VADD2(tmp, _A, N);
			pdv_3line(fd, A, tmp);

			/* plot NdotD */
			pl_color(fd, 10, 100, 10);
			VMOVE(tmp, A);
			tmp[X] -= .1;
			tmp[Y] -= .1;
			pdv_3move(fd, tmp);
			VJOIN1(tmp, tmp, NdotD, N);
			pdv_3cont(fd, tmp);

			/* plot the perpendicular */
			pl_color(fd, 180, 180, 255);
			VADD2(tmp, _A, PAxD);
			pdv_3line(fd, A, tmp);

			/* plot PA */
			pl_color(fd, 200, 200, 185);
			VSUB2(tmp, _A, PA);
			pdv_3line(fd, A, tmp);


			/* plot the extent of the A_B side */
			pl_color(fd, 90, 220, 220);
			VMOVE(tmp, _A);
			tmp[Z] += .1;
			pdv_3move(fd, tmp);
			VJOIN1(tmp, tmp, abs_NdotD, A_B);
			pdv_3cont(fd, tmp);

			/* plot alpha */
			pl_color(fd, 20, 170, 170);
			VMOVE(tmp, _A);
			tmp[Z] += .2;
			pdv_3move(fd, tmp);
			VJOIN1(tmp, tmp, alpha, A_C);
			pdv_3cont(fd, tmp);

			/* plot the extent of the A_C side */
			pl_color(fd, 90, 220, 220);
			VMOVE(tmp, _A);
			tmp[Z] += .1;
			pdv_3move(fd, tmp);
			VJOIN1(tmp, tmp, abs_NdotD, A_C);
			pdv_3cont(fd, tmp);

			/* plot beta */
			pl_color(fd, 20, 170, 170);
			VMOVE(tmp, _A);
			tmp[Z] += .2;
			pdv_3move(fd, tmp);
			VJOIN1(tmp, tmp, beta, A_B);
			pdv_3cont(fd, tmp);

		}
#define DEBUG_PLOT_CLOSE(dist)
	if (rt_g.debug & DEBUG_HF && plot_em) {
		if ( dist != 0.0) {
 			/* plot the dist */
 			pl_color(fd, 20, 20, 140);
			pdv_3move(fd, isect->r.r_pt);
 			VJOIN1(tmp, isect->r.r_pt, dist, isect->r.r_dir);
			pdv_3cont(fd, tmp);
		}
		fclose(fd);
	}
#endif
@


1.20
log
@fixed bug when hitting both triangles of a cell.
@
text
@d49 1
a49 1
static char RCSdsp[] = "@@(#)$Header: /m/cad/librt/RCS/g_dsp.c,v 1.19 1997/06/26 22:30:19 butler Exp butler $ (BRL)";
d131 2
a132 1
		bu_log("%s:%d ", __FILE__, __LINE__); \
d153 2
a154 1
		bu_log("%s:%d ", __FILE__, __LINE__); \
d171 2
a172 1
		bu_log("%s:%d ", __FILE__, __LINE__); \
d554 1
d586 2
d590 1
d592 1
a592 1
			pdv_3line(fd, in, out);
d599 1
d601 1
d603 1
a603 1
			pdv_3line(fd, in, out);
d629 3
a631 1
			bu_log("%s:%d from %d NdotD:%g\n", __FILE__, __LINE__, line, NdotD);
d644 3
a646 1
			bu_log("%s:%d from %d NdotD:%g", __FILE__, __LINE__, line, NdotD);
d676 1
a676 1
	vect_t tmp;
d682 1
a682 1
	vect_t A, B, C, D;
d704 3
d709 42
a750 11
			pd_3move(fd, A[X], A[Y], (double)min_val);
			pd_3cont(fd, B[X], B[Y], (double)min_val);
			pd_3cont(fd, D[X], D[Y], (double)min_val);
			pd_3cont(fd, C[X], C[Y], (double)min_val);
			pd_3cont(fd, A[X], A[Y], (double)min_val);

			pd_3cont(fd, A[X], A[Y], (double)max_val);
			pd_3cont(fd, B[X], B[Y], (double)max_val);
			pd_3cont(fd, D[X], D[Y], (double)max_val);
			pd_3cont(fd, C[X], C[Y], (double)max_val);
			pd_3cont(fd, A[X], A[Y], (double)max_val);
d753 2
a756 6
		pdv_3move(fd, A);
		pdv_3cont(fd, B);
		pdv_3cont(fd, D);
		pdv_3cont(fd, A);
		pdv_3cont(fd, C);
		pdv_3cont(fd, D);
d758 23
d782 1
d791 3
a793 1
		pdv_3move(fd, curr_pt);
d798 3
a800 1
				pdv_3cont(fd, tmp);
d805 3
a807 1
				pdv_3move(fd, tmp);
d810 3
a812 1
				pdv_3cont(fd, tmp);
d817 2
a818 1
				pdv_3move(fd, tmp);
d822 3
a824 1
				pdv_3cont(fd, tmp);
d829 1
a829 1
				pdv_3move(fd, tmp);
d832 3
a834 1
				pdv_3cont(fd, tmp);
d839 1
a839 1
				pdv_3move(fd, tmp);
d844 3
a846 1
			pdv_3cont(fd, tmp);
d851 1
a851 1
			pdv_3move(fd, tmp);
d855 3
a857 1
			pdv_3cont(fd, tmp);
d862 1
a862 1
			pdv_3move(fd, tmp);
d865 3
a867 2
		pdv_3cont(fd, next_pt);

d1056 3
a1058 2
				bu_log("%s:%d ray entering while inside dsp",
					__FILE__, __LINE__);
d1064 3
a1066 2
				bu_log("%s:%d ray entering while inside dsp",
					__FILE__, __LINE__);
d1075 3
a1077 2
				bu_log("%s:%d ray leaving while outside dsp",
					__FILE__, __LINE__);
d1085 3
a1087 2
				bu_log("%s:%d ray leaving while outside dsp",
					__FILE__, __LINE__);
d1102 3
a1104 2
				bu_log("%s:%d ray entering while inside dsp",
					__FILE__, __LINE__);
d1116 3
a1118 2
				bu_log("%s:%d ray leaving while outside dsp",
					__FILE__, __LINE__);
d1134 3
a1136 2
				bu_log("%s:%d ray entering while inside dsp",
					__FILE__, __LINE__);
d1148 3
a1150 2
				bu_log("%s:%d ray leaving while outside dsp",
					__FILE__, __LINE__);
d1199 2
a1200 1
		bu_log("%s:%d ", __FILE__, __LINE__);
d1245 2
a1246 1
		bu_log("%s:%d ", __FILE__, __LINE__);
d1512 3
a1514 2
						bu_log("%s:%d hitting bottom of dsp for entry while past bottom?\n",
							__FILE__, __LINE__);
d1523 1
a1523 1
					bu_log("%s:%d surface %d ", __FILE__, __LINE__, curr_surf);
d1544 1
a1544 1
						bu_log("%s:%d ", __FILE__, __LINE__);
d1649 3
a1651 2
						bu_log("%s:%d hitting bottom of dsp for entry while past bottom?\n",
							__FILE__, __LINE__);
d1660 1
a1660 1
					bu_log("%s:%d surface %d ", __FILE__, __LINE__, curr_surf);
d1680 1
a1680 1
						bu_log("%s:%d ", __FILE__, __LINE__);
d1898 1
a1898 1
	vect_t N, T, A, B, C, D, AB, AC, AD;
d1908 1
d1913 8
a1920 3
		VSET(A, cell[X],   cell[Y],   DSP(dsp, cell[X],   cell[Y])  );
		VSET(B, cell[X]+1, cell[Y],   DSP(dsp, cell[X]+1, cell[Y])  );
		VSET(D, cell[X]+1, cell[Y]+1, DSP(dsp, cell[X]+1, cell[Y]+1));
d1922 1
d1926 1
a1926 4
		VCROSS(T, AB, AD); 
		VUNITIZE(T);

		MAT4X3VEC(N, dsp->dsp_i.dsp_stom, T);
d1932 2
a1933 3
		VSET(A, cell[X],   cell[Y],   DSP(dsp, cell[X],   cell[Y])  );
		VSET(C, cell[X],   cell[Y]+1, DSP(dsp, cell[X],   cell[Y]+1));
		VSET(D, cell[X]+1, cell[Y]+1, DSP(dsp, cell[X]+1, cell[Y]+1));
d1935 6
d1945 1
a1945 4
		VCROSS(T, AD, AC); 
		VUNITIZE(T);

		MAT4X3VEC(N, dsp->dsp_i.dsp_stom, T);
d1957 24
a1980 1
	if (rt_g.debug & DEBUG_HF)
d1982 6
a1987 5
		bu_log("surf[%d] pt(%g %g %g) Norm[%g %g %g](%g %g %g)\n",
			hitp->hit_surfno,
			V3ARGS(hitp->hit_point),
			V3ARGS(dsp_pl[ hitp->hit_surfno ]),
			V3ARGS(N));
@


1.19
log
@checkpoint
@
text
@d49 1
a49 1
static char RCSdsp[] = "@@(#)$Header: /m/cad/librt/RCS/g_dsp.c,v 1.18 1997/06/26 03:27:08 butler Exp $ (BRL)";
d553 1
a553 1
	sprintf(buf, "dsp%d_1.pl", plot_file_num++);
d649 3
a651 1
plot_cell_ray(isect, cell, A, B, C, D, curr_pt, next_pt, hit1, dist1, hit2, dist2, inside)
d654 1
a654 1
vect_t A, B, C, D, curr_pt, next_pt;
d668 7
d677 1
a677 1
	sprintf(buf, "dsp%d_1.pl", plot_file_num++);
d716 64
d781 1
a781 3
		/* plot the ray */
		pl_color(fd, 255, 40, 40);
		pdv_3line(fd, curr_pt, next_pt);
d843 1
d937 1
a937 1
		plot_cell_ray(isect, cell, A, B, C, D, curr_pt, next_pt, hit1, dist1, hit2, dist2, *inside);
d949 2
d958 2
d983 1
d1009 3
d1022 3
d1036 1
d1039 3
d1052 3
d1364 5
d1378 3
d1382 1
d1500 4
d1513 4
@


1.18
log
@checkpoint
@
text
@d49 1
a49 1
static char RCSdsp[] = "@@(#)$Header: /m/cad/librt/RCS/g_dsp.c,v 1.17 1997/06/26 03:10:17 butler Exp butler $ (BRL)";
a540 109
#define DEBUG_PLOT_TRI(_A, _B, _C) \
	if (rt_g.debug & DEBUG_HF && plot_em) { \
		char buf[132]; \
 \
		RES_ACQUIRE( &rt_g.res_model); \
		sprintf(buf, "dsp%d_1.pl", plot_file_num++); \
		RES_RELEASE( &rt_g.res_model); \
		bu_log("%s\n", buf); \
 \
		RES_ACQUIRE( &rt_g.res_syscall); \
		if ((fd=fopen(buf, "w")) != (FILE *)NULL) { \
			vect_t tmp; \
			vect_t A_B; \
			vect_t A_C; \
 \
			VSUB2(A_B, _B, _A); \
			VSUB2(A_C, _C, _A); \
 \
			if (_A[Z] != _B[Z] || _A[Z] != _C[Z]) { \
				short min_val; \
				short max_val; \
				cell_minmax(isect->dsp, cell[X], cell[Y], \
					&min_val, &max_val); \
 \
				/* plot bounding box */ \
				pl_color(fd, 60, 60, 190); \
				pl_3move(fd, cell[X],   cell[Y],   min_val); \
				pl_3cont(fd, cell[X]+1, cell[Y],   min_val); \
				pl_3cont(fd, cell[X]+1, cell[Y]+1, min_val); \
				pl_3cont(fd, cell[X],   cell[Y]+1, min_val); \
				pl_3cont(fd, cell[X],   cell[Y],   min_val); \
				\
				pl_3cont(fd, cell[X], cell[Y], max_val); \
				pl_3cont(fd, cell[X]+1, cell[Y], max_val); \
				pl_3cont(fd, cell[X]+1, cell[Y]+1, max_val); \
				pl_3cont(fd, cell[X], cell[Y]+1, max_val); \
				pl_3cont(fd, cell[X], cell[Y], max_val); \
			} \
 \
			/* plot the triangle */ \
			pl_color(fd, 90, 220, 90); \
			pdv_3move(fd, _A); \
			pdv_3cont(fd, _B); \
			pdv_3cont(fd, _C); \
			pdv_3cont(fd, _A); \
 \
			/* plot the normal */ \
			pl_color(fd, 40, 180, 40); \
			VADD2(tmp, _A, N); \
			pdv_3line(fd, A, tmp); \
 \
			/* plot NdotD */ \
			pl_color(fd, 10, 100, 10); \
			VMOVE(tmp, A); \
			tmp[X] -= .1; \
			tmp[Y] -= .1; \
			pdv_3move(fd, tmp); \
			VJOIN1(tmp, tmp, NdotD, N); \
			pdv_3cont(fd, tmp); \
 \
			/* plot the perpendicular */ \
			pl_color(fd, 180, 180, 255); \
			VADD2(tmp, _A, PAxD); \
			pdv_3line(fd, A, tmp); \
 \
			/* plot PA */ \
			pl_color(fd, 200, 200, 185); \
			VSUB2(tmp, _A, PA); \
			pdv_3line(fd, A, tmp); \
 \
			/* plot the ray */ \
			pl_color(fd, 255, 40, 40); \
			pdv_3line(fd, curr_pt, next_pt); \
 \
			/* plot the extent of the A_B side */ \
			pl_color(fd, 90, 220, 220); \
			VMOVE(tmp, _A); \
			tmp[Z] += .1; \
			pdv_3move(fd, tmp); \
			VJOIN1(tmp, tmp, abs_NdotD, A_B); \
			pdv_3cont(fd, tmp); \
 \
			/* plot alpha */ \
			pl_color(fd, 20, 170, 170); \
			VMOVE(tmp, _A); \
			tmp[Z] += .2; \
			pdv_3move(fd, tmp); \
			VJOIN1(tmp, tmp, alpha, A_C); \
			pdv_3cont(fd, tmp); \
 \
			/* plot the extent of the A_C side */ \
			pl_color(fd, 90, 220, 220); \
			VMOVE(tmp, _A); \
			tmp[Z] += .1; \
			pdv_3move(fd, tmp); \
			VJOIN1(tmp, tmp, abs_NdotD, A_C); \
			pdv_3cont(fd, tmp); \
 \
			/* plot beta */ \
			pl_color(fd, 20, 170, 170); \
			VMOVE(tmp, _A); \
			tmp[Z] += .2; \
			pdv_3move(fd, tmp); \
			VJOIN1(tmp, tmp, beta, A_B); \
			pdv_3cont(fd, tmp); \
 \
		} \
		RES_RELEASE( &rt_g.res_syscall); \
	}
a541 12
#define DEBUG_PLOT_CLOSE(dist) \
	if (rt_g.debug & DEBUG_HF && plot_em) { \
		if ( dist != 0.0) { \
 			/* plot the dist */ \
 			pl_color(fd, 20, 20, 140); \
			pdv_3move(fd, isect->r.r_pt); \
 			VJOIN1(tmp, isect->r.r_pt, dist, isect->r.r_dir); \
			pdv_3cont(fd, tmp); \
		} \
		fclose(fd); \
	}

d648 64
d713 4
d743 2
a744 1
	double NdotD;
d746 6
a751 1
	double	dist;
a755 2


a777 1

d782 5
d788 1
a788 1
	NdotD = VDOT( N, isect->r.r_dir);
d790 4
a793 6

	abs_NdotD = NdotD >= 0.0 ? NdotD : (-NdotD);
	if (BN_VECT_ARE_PERP(NdotD, isect->tol)) {
		if (rt_g.debug & DEBUG_HF)
			bu_log("miss tri1 (perp %g vs tol %g)\n",
				abs_NdotD, isect->tol);
d797 1
a797 6
	VSUB2(PA, A, isect->r.r_pt);
	
	/* get perpendicular to PA, D */
	VCROSS(PAxD, PA, isect->r.r_dir);

	/* project PAxD onto AB giving the distance along *AD* */
d800 1
a800 2
	/* project PAxD onto AD giving the distance along *AB* */
	beta = VDOT( AD, PAxD );
d802 1
a802 1
	dist = 0.0;
d804 4
a807 2
	if (NdotD > 0.0) alpha = -alpha;
	if ( NdotD < 0.0 ) beta = -beta;
d809 2
a810 3
	if (rt_g.debug & DEBUG_HF)
		bu_log("alpha:%g beta:%g NdotD:%g\n", alpha, beta, NdotD);
	DEBUG_PLOT_TRI(A, B, D);
d812 1
a813 5
	if (alpha < 0.0 || alpha > abs_NdotD ) {
		if (rt_g.debug & DEBUG_HF)
			bu_log("miss tri1 (alpha)\n");
		goto tri2;
	}
d815 1
a815 2
		if (rt_g.debug & DEBUG_HF)
			bu_log("miss tri1 (beta)\n");
d819 1
a819 3
		/* miss triangle */
		if (rt_g.debug & DEBUG_HF)
			bu_log("miss tri1 (alpha+beta > NdotD)\n");
d822 2
d825 1
a825 1
	dist = VDOT( PA, N ) / NdotD;
d827 2
a828 2
	if (rt_g.debug & DEBUG_HF)
		bu_log("hit tri1 dist %g (inv:%g)\n", dist, VDOT( N, PA));
d830 6
d837 8
a844 1
	/* XXX what if we're inside, leave tri2 and enter tri1 ? */
d846 7
a852 1
	do_hit(dist, inside, NdotD, isect, TRI1, "tri1", cell, __LINE__);
d854 4
d859 2
a860 2
tri2:
	DEBUG_PLOT_CLOSE(dist);
d862 4
a865 2
	VCROSS(N, AD, AC);
	NdotD = VDOT( N, isect->r.r_dir);
a867 7
	abs_NdotD = NdotD >= 0.0 ? NdotD : (-NdotD);
	if (BN_VECT_ARE_PERP(NdotD, isect->tol)) {
		if (rt_g.debug & DEBUG_HF)
			bu_log("miss tri2 (perp %g vs tol %g)\n",
				abs_NdotD, isect->tol);
		goto bail_out;
	}
d869 22
a890 2
	/* project PAxD onto AD */
	alpha = VDOT( AD, PAxD );
d892 8
a899 2
	/* project PAxD onto AC */
	beta = VDOT( AC, PAxD );
d901 6
a906 2
	if (NdotD > 0.0) alpha = -alpha;
	if ( NdotD < 0.0 ) beta = -beta;
d908 21
d930 7
a936 2
	if (rt_g.debug & DEBUG_HF)
		bu_log("alpha:%g beta:%g NdotD:%g\n", alpha, beta, NdotD);
d938 22
a959 2
	dist = 0.0;
	DEBUG_PLOT_TRI(A, D, C);
d961 15
a975 16
	if (alpha < 0.0 || alpha > abs_NdotD ) {
		if (rt_g.debug & DEBUG_HF)
			bu_log("miss tri2 (alpha)\n");
		goto bail_out;
	}
	if( beta < 0.0 || beta > abs_NdotD ) {
		if (rt_g.debug & DEBUG_HF)
			bu_log("miss tri2 (beta)\n");
		goto bail_out;
	}
	if ( alpha+beta > abs_NdotD ) {
		/* miss triangle */
		if (rt_g.debug & DEBUG_HF)
			bu_log("miss tri2 (alpha+beta > NdotD)\n");

		goto bail_out;
a977 1
	dist = VDOT( PA, N ) / NdotD;
a978 7
	if (rt_g.debug & DEBUG_HF)
		bu_log("hit tri2 dist %g\n", dist);

	do_hit(dist, inside, NdotD, isect, TRI2, "tri2", cell, __LINE__);

bail_out:
	DEBUG_PLOT_CLOSE(dist);
a1079 12
int
isect_cell_z_wall(isect, cell, surf, dist, pt)
struct isect_stuff *isect;
int cell[3];
int surf;
double dist;
point_t pt;
{
	if (rt_g.debug & DEBUG_HF)
		bu_log("isect_cell_z_wall()\n");
	return 1;
}
d1317 9
a1325 3
					hit = isect_cell_z_wall(
						isect, grid_cell, curr_surf,
						curr_dist, curr_pt);
d1328 1
a1328 1
					bu_log("%s:%d", __FILE__, __LINE__);
d1445 9
a1453 3
					hit = isect_cell_z_wall(
						isect, grid_cell, curr_surf,
						curr_dist, curr_pt);
d1456 1
a1456 1
					bu_log("%s:%d", __FILE__, __LINE__);
d2239 94
@


1.17
log
@checkpoint
@
text
@d49 1
a49 1
static char RCSdsp[] = "@@(#)$Header: /m/cad/librt/RCS/g_dsp.c,v 1.16 1997/06/26 00:00:33 butler Exp butler $ (BRL)";
d222 1
a222 1
static int plot_em=0;
d737 1
d887 2
@


1.16
log
@worked on 35,25 view with no lights and nice normals
@
text
@d49 1
a49 1
static char RCSdsp[] = "@@(#)$Header: /m/cad/librt/RCS/g_dsp.c,v 1.15 1997/06/25 22:55:33 butler Exp butler $ (BRL)";
d55 1
d130 2
a131 1
	if (isp->sp_is_valid) \
d133 1
d145 2
a146 1
		bu_log("line %d New in pt(%g %g %g) dist %g surf: %d\n", __LINE__, V3ARGS(in), dist, surf); \
d152 1
d169 2
a170 2
		bu_log("line %d attempt to commit an invalid seg\n", __LINE__); \
		bu_bomb("Boom\n"); \
d222 2
a223 1

d502 11
d514 1
d516 7
a522 12
#if 0
#define CELL_MIN(_c) c_min(isect, _c)
#define CELL_MAX(_c) c_max(isect, _c)


static short
c_min(isect, cell)
struct isect_stuff *isect;
CONST register int *cell;
{
	register struct dsp_specific *dsp = isect->dsp;
	register short v, i;
d524 3
d528 3
a530 7
	v=DSP(dsp, cell[X], cell[Y]);

	if (  (i=DSP(dsp, cell[X]+1, cell[Y])) < v) 
		v = i;

	if ( (i=DSP(isect->dsp, cell[X], cell[Y]+1)) < v)
		v = i;
a531 2
	if ( (i=DSP(isect->dsp, cell[X]+1, cell[Y]+1)) < v)
		v = i;
a532 56
	return v;
}
static short
c_max(isect, cell)
struct isect_stuff *isect;
CONST register int *cell;
{
	register struct dsp_specific *dsp = isect->dsp;
	register short v, i;
	int j;

	j = cell[Y] * dsp->dsp_i.dsp_xcnt + cell[X];

	v = ((unsigned short *)dsp->dsp_i.dsp_mp->buf)[ j ];


	v = DSP(dsp, cell[X], cell[Y]);

	if (  (i=DSP(dsp, cell[X]+1, cell[Y])) > v )
		v = i;

	if ( (i=DSP(isect->dsp, cell[X], cell[Y]+1)) > v)
		v = i;

	if ( (i=DSP(isect->dsp, cell[X]+1, cell[Y]+1)) > v)
		v = i;

	return v;
}
#else
#define CELL_MIN(_c)                                                       \
((h=DSP(isect->dsp, _c[X], _c[Y])) < (i=DSP(isect->dsp, _c[X], _c[Y]+1)) ? \
	(h < (i=DSP(isect->dsp, _c[X], _c[Y]+1)) ?                         \
		(h < (i=DSP(isect->dsp, _c[X]+1, _c[Y]+1)) ?		   \
			h : i) :					   \
		(i < (h=DSP(isect->dsp, _c[X]+1, _c[Y]+1)) ?		   \
			i : h) )  :					   \
	(i < (h=DSP(isect->dsp, _c[X], _c[Y]+1)) ?			   \
 		(i < (h=DSP(isect->dsp, _c[X]+1, _c[Y]+1)) ?		   \
			i : h) :					   \
		(h < (i=DSP(isect->dsp, _c[X]+1, _c[Y]+1)) ?		   \
			h : i) ))

#define CELL_MAX(_c)							   \
((h=DSP(isect->dsp, _c[X], _c[Y])) > (i=DSP(isect->dsp, _c[X], _c[Y]+1)) ? \
	(h > (i=DSP(isect->dsp, _c[X], _c[Y]+1)) ?			   \
		(h > (i=DSP(isect->dsp, _c[X]+1, _c[Y]+1)) ?		   \
			h : i) :					   \
		(i > (h=DSP(isect->dsp, _c[X]+1, _c[Y]+1)) ?		   \
			i : h) )  :					   \
	(i > (h=DSP(isect->dsp, _c[X], _c[Y]+1)) ?			   \
 		(i > (h=DSP(isect->dsp, _c[X]+1, _c[Y]+1)) ?		   \
			i : h) :					   \
		(h > (i=DSP(isect->dsp, _c[X]+1, _c[Y]+1)) ?		   \
			h : i) ))
#endif
d542 2
a543 6
	if (rt_g.debug & DEBUG_HF) { \
		vect_t A_B; \
		vect_t A_C; \
 \
		VSUB2(A_B, _B, _A); \
		VSUB2(A_C, _C, _A); \
d552 3
d556 3
d560 5
a564 2
				short min_val = CELL_MIN(cell); \
				short max_val = CELL_MAX(cell); \
d566 1
a566 1
				pl_color(fd, 20, 20, 90); \
d652 1
a652 1
	if (rt_g.debug & DEBUG_HF) { \
d740 1
a740 1
			bu_log("NdotD:%g\n", NdotD);
d753 2
a754 2
			bu_log("NdotD:%g", NdotD);
			print_isect_segs(isect);
d782 1
a782 1
	curr_pt, next_pt, curr_surf, next_surf, inside)
a785 2
int curr_surf;
int next_surf;
a796 1
	double NdotPt;
d801 3
a803 3
	char buf[32];
	short cell_min = CELL_MIN(cell);
	short cell_max = CELL_MAX(cell);
a832 1
	NdotPt = VDOT(N, isect->r.r_pt);
d834 1
d895 1
a895 1
	NdotPt = VDOT(N, isect->r.r_pt);
a957 30
/*
 *	Finds the minimum and maximum values in a cell
 */
void
cell_minmax(dsp, x, y, cell_min, cell_max)
register struct dsp_specific *dsp;
register int x, y;
short *cell_min;
short *cell_max;
{
	register short cmin, cmax, v;

	cmin = cmax = DSP(dsp, x, y);

	v = DSP(dsp, x+1, y);
	if (v < cmin) cmin = v;
	if (v > cmax) cmax = v;
	
	v = DSP(dsp, x+1, y+1);
	if (v < cmin) cmin = v;
	if (v > cmax) cmax = v;
	
	v = DSP(dsp, x, y+1);
	if (v < cmin) cmin = v;
	if (v > cmax) cmax = v;

	*cell_min = cmin;
	*cell_max = cmax;
}

d985 1
d1030 1
d1049 12
d1062 1
d1091 1
a1091 1
	int hit;		/* boolean */
d1097 1
a1098 1
	short	h, i;		
d1101 1
a1101 1
	double	dsp_max = isect->dsp->dsp_pl_dist[ZMAX];
a1112 1

d1297 8
a1314 1
					curr_surf, next_surf,
d1324 1
d1398 1
d1408 1
d1419 8
a1436 1
					curr_surf, next_surf,
a1438 1

d1445 2
a1446 1
						bu_log("line:%d", __LINE__);
d1481 1
a1481 1

d1666 1
a1666 1
	if (rt_g.debug & DEBUG_HF)
d1707 1
d1717 1
d2028 1
a2028 1

@


1.15
log
@checkpoint
@
text
@d49 1
a49 1
static char RCSdsp[] = "@@(#)$Header: /m/cad/librt/RCS/g_dsp.c,v 1.14 1997/06/18 01:04:47 mike Exp butler $ (BRL)";
d1706 1
a1706 1
	vect_t N, T;
d1720 10
a1729 1
		VSET(T, .5, 0.0, 1.0);
d1736 11
a1746 1
		VSET(T, 0.0, .5, 1.0);
@


1.14
log
@Fixes for Sun4
@
text
@d49 1
a49 1
static char RCSdsp[] = "@@(#)$Header: /m/cad/librt/RCS/g_dsp.c,v 1.13 1997/06/17 05:26:58 butler Exp mike $ (BRL)";
d157 2
a158 1
		bu_log("line %d New out pt(%g %g %g) dist %g surf:%d\n", __LINE__, V3ARGS(out), dist, surf); \
d498 1
a498 1
#if 1
a594 2
		bu_log("alpha:%g beta:%g NdotD:%g\n", alpha, beta, NdotD); \
 \
a687 1
			fclose(fd); \
d692 12
d766 1
a766 1
#define DO_HIT do_hit
d768 1
a768 1
do_hit(dist, inside, NdotD, isect, TR, ts, cell)
d776 1
d898 2
d903 2
a910 1

d925 2
a926 1
	dist = VDOT( PA, N );
d928 1
a928 2
		bu_log("hit tri1 dist %g\n", dist);

a929 1
	/* */
d931 1
a931 1
	DO_HIT(dist, inside, NdotD, isect, TRI1, "tri1", cell);
d935 1
a957 1
	DEBUG_PLOT_TRI(A, D, C);
d959 2
d962 2
a967 1

d979 1
d983 2
a984 1
	dist = VDOT( PA, N );
d988 1
a988 1
	DO_HIT(dist, inside, NdotD, isect, TRI2, "tri2", cell);
d991 2
a992 1
	;
d1001 46
a1046 9
#define IN_BASEX(_i, _inside)                                               \
	if (!_inside) {							    \
        /* if (grid_cell[X] != 0 && grid_cell[X] != XCNT) bu_log("Oops, inside DSP without crossing boundary\n"); */ \
		INHIT( (_i), tX, insurfX, grid_cell ); \
 \
		_inside = 1;						    \
	}								    \
 \
	OUTHIT( (_i), tX + tDX, outsurfX, grid_cell);
d1048 3
d1052 9
a1060 15
#define IN_BASEY(_i, _inside)						    \
	if (!_inside) {							    \
									    \
/* bu_log("Oops, inside DSP without crossing boundary\n"); */		    \
		INHIT( (_i), tY, insurfY, grid_cell); \
 \
		_inside = 1;						    \
	}								    \
	OUTHIT( (_i), tY + tDY, outsurfY, grid_cell);

#define MISS_ABOVE(_i, _inside)                                     	    \
	if (_inside) {                                     		    \
		HIT_COMMIT( (_i) ); \
 \
		_inside = 0;                                     	    \
d1063 11
a1073 126
#define ISECT_ENTRY_WALL()                                     		    \
{	register double slope;                                     	    \
	/* determine if we are starting out "under/inside" the surface      \
	 * or "above/outside" the surface.                                  \
	 */                                     			    \
	switch (curr_surf) {                                     	    \
	case BBSURF(XMIN):                                     		    \
		h = grid_cell[X];                                     	    \
                                     					    \
		i = DSP(isect->dsp, h, grid_cell[Y]);                       \
		slope = (next_pt[Z] - i) / (next_pt[Y] - grid_cell[Y]);     \
                                     					    \
		i = DSP(isect->dsp, h, grid_cell[Y]+1) - i;                 \
                                     					    \
		if (slope < i) {                                     	    \
			/* Entering cell under DSP top */                   \
			if (rt_g.debug & DEBUG_HF) \
				bu_log("slope: %g, i: %d\n", slope, i); \
			if (!inside) {                                      \
				if (rt_g.debug & DEBUG_HF) \
					bu_log("entering XMIN wall\n"); \
 \
				INHIT(isect, curr_dist, \
					BBSURF(XMIN), grid_cell); \
 \
				inside = 1;                                 \
			}                           		            \
		} else { \
			if (rt_g.debug & DEBUG_HF) \
				bu_log("entering cell above DSP at XMIN wall\n"); \
		}			                                    \
		break;                  		                    \
	case BBSURF(XMAX):                                		    \
		h = grid_cell[X]+1;                                         \
					                                    \
		i = DSP(isect->dsp, h, grid_cell[Y]);                       \
		slope = (next_pt[Z] - i) / (next_pt[Y] - grid_cell[Y]);     \
		i = (DSP(isect->dsp, h, grid_cell[Y]+1) - i) /* / 1.0 */;   \
		if (slope < i ) {                                 	    \
			/* Entering cell under DSP top */                   \
			if (rt_g.debug & DEBUG_HF) \
				bu_log("slope: %g, i: %d\n", slope, i); \
			if (!inside) {                                      \
				if (rt_g.debug & DEBUG_HF) \
					bu_log("entering XMAX wall\n"); \
				INHIT(isect, curr_dist, \
					BBSURF(XMAX), grid_cell); \
				inside = 1;                    		    \
			}                                 		    \
		} else {                               			    \
			if (rt_g.debug & DEBUG_HF) \
				bu_log("entering cell above DSP at XMAX wall\n"); \
		}			                                    \
		break;                               			    \
	case BBSURF(YMIN):                                		    \
		h = grid_cell[Y];                                	    \
					                                    \
		i = DSP(isect->dsp, grid_cell[X], h);                       \
		slope = (next_pt[Z] - i) / (next_pt[X] - grid_cell[X]);     \
		i = (DSP(isect->dsp, grid_cell[X]+1, h) - i) /* / 1.0 */;   \
		if (slope < i ) {                                 	    \
			if (rt_g.debug & DEBUG_HF) \
				bu_log("slope: %g, i: %d\n", slope, i); \
			/* Entering cell under DSP top */                   \
			if (!inside) {                                      \
				if (rt_g.debug & DEBUG_HF) \
					bu_log("entering @@ YMIN wall\n"); \
				INHIT(isect, curr_dist, \
					BBSURF(YMIN), grid_cell); \
				inside = 1;				    \
			}                                  		    \
		} else { \
			if (rt_g.debug & DEBUG_HF) \
				bu_log("entering cell above DSP @@ YMIN wall\n"); \
		}                                			    \
		break;                                 			    \
	case BBSURF(YMAX):                                		    \
		h = grid_cell[Y]+1;                                 	    \
					                                    \
		i = DSP(isect->dsp, grid_cell[X], h);			    \
		slope = (next_pt[Z] - i) / (next_pt[X] - grid_cell[X]);     \
		i = DSP(isect->dsp, grid_cell[X]+1, h) - i;                 \
		if (slope < i ) {                                 	    \
			/* Entering cell under DSP top */                   \
			if (rt_g.debug & DEBUG_HF) \
				bu_log("slope: %g, i: %d\n", slope, i); \
			if (!inside) {                                      \
				if (rt_g.debug & DEBUG_HF) \
					bu_log("entering @@ YMAX wall\n"); \
 \
				INHIT(isect, curr_dist, \
					BBSURF(YMAX), grid_cell); \
				inside = 1;                                 \
			}                                 		    \
		} else { \
			if (rt_g.debug & DEBUG_HF) \
				bu_log("entering cell above DSP @@ YMIN wall\n"); \
		}                                 			    \
		break;                                			    \
	case BBSURF(ZMIN):                                 		    \
		/* Entering cell under DSP top if rising */                 \
		if (!rising)                                 		    \
			bu_bomb("How can I be sinking and entering a cell at ZMIN?\n"); \
                                					    \
		if (!inside) {                                		    \
			if (rt_g.debug & DEBUG_HF) \
				bu_log("hit bottom risinging\n"); \
			INHIT(isect, curr_dist, \
					BBSURF(YMAX), grid_cell); \
			inside = 1;				    \
		}                                 			    \
                                  					    \
		break;                                			    \
	case BBSURF(ZMAX):                                 		    \
		/* entering from above */                                   \
		if (rising)                                 		    \
			bu_bomb("How can I be rising and entering a cell at ZMAX?\n"); \
\
		if (rt_g.debug & DEBUG_HF) \
			bu_log("hit top descending\n"); \
                                					    \
		/* do nothing because we haven't entered through a          \
		 * real surface                                 	    \
		 */                                 			    \
		break;                                			    \
	}                                 				    \
d1077 29
a1105 21
#define ISECT_X_EXIT_WALL(isect, grid_cell)                                 \
{	register short h, i;                                 		    \
	register double slope;                                  	    \
                                 					    \
	if (next_surf == BBSURF(XMIN) ) h = grid_cell[X];                \
	else h = grid_cell[X]+1;                                	    \
                                					    \
	i = DSP(isect->dsp, h, grid_cell[Y]);                               \
	slope = (next_pt[Z] - i) / (next_pt[Y] - grid_cell[Y]);             \
	if (slope < DSP(isect->dsp, h, grid_cell[Y]+1) - i) {               \
	    	/* exiting cell while inside solid */                       \
		if (inside) {                                 		    \
			if (rt_g.debug & DEBUG_HF) \
				bu_log("exiting cell X dir inside DSP\n"); \
 \
			OUTHIT(isect, tX, outsurfX, grid_cell); \
		} else {                                 		    \
		    bu_log("exiting DSP cell in solid without existing seg\n"); \
		}                                 			    \
	}                                 				    \
}
d1107 2
d1110 2
d1113 3
a1115 20
#define ISECT_Y_EXIT_WALL(isect, grid_cell)                                 \
{	register short h, i;                                 		    \
	register double slope;                                 		    \
                                 					    \
	if (next_surf == BBSURF(YMIN) ) h = grid_cell[Y];                \
	else h = grid_cell[Y]+1;                                 	    \
                                 					    \
	i = DSP(isect->dsp, grid_cell[X], h);                               \
	slope = (next_pt[Z] - i) / (next_pt[X] - grid_cell[X]);             \
	if (slope < DSP(isect->dsp, grid_cell[X]+1, h) - i) {               \
	    	/* exiting cell while inside solid */                       \
		if (inside) {                                  		    \
			if (rt_g.debug & DEBUG_HF) \
				bu_log("exiting cell Y dir inside DSP\n"); \
			OUTHIT(isect, tY, outsurfY, grid_cell); \
		} else {                                  		    \
		    bu_log("exiting DSP cell in solid without existing seg\n"); \
		}                                 			    \
	}                                 				    \
}
d1118 2
d1131 1
d1139 2
a1140 1
	int	inside = 0;	/* currently have a valid seg we're building */
d1142 1
a1142 1

a1144 1
	int	outX, outY;	/* cell index which idicates we're outside */
d1150 1
d1159 1
a1159 1
	double	out_dist = isect->bbox.out_dist;
d1182 3
a1184 1
	VJOIN1(bbout_pt, isect->r.r_pt, isect->bbox.out_dist, isect->r.r_dir);
d1186 3
d1190 19
d1211 1
d1214 6
a1219 4
		bu_log(" in cell(%d,%d)  pt(%g %g %g)\n",
			grid_cell[X], grid_cell[Y], V3ARGS(curr_pt));
		bu_log("out cell(%d,%d)  pt(%g %g %g)\n",
			bbout_cell[X], bbout_cell[Y], V3ARGS(bbout_pt));
a1226 1
		outX = -1;	/* cell beyond last valid in X direction */
a1243 1
		outX = isect->dsp->dsp_i.dsp_xcnt;
a1255 1
		outY = -1;
a1263 1
		outY = isect->dsp->dsp_i.dsp_ycnt;
d1278 4
a1281 4
		bu_log("stepX:%d outX:%d  tDX:%g tX:%g\n",
			stepX, outX, tDX, tX);
		bu_log("stepY:%d outY:%d  tDY:%g tY:%g\n",
			stepY, outY, tDY, tY);
d1287 2
a1288 2
bu_log("cell(%d,%d) tX:%g tY:%g  inside=%d\n\t  curr_pt (%g %g %g)\n\t",
	grid_cell[X], grid_cell[Y], tX, tY, inside, V3ARGS(curr_pt));
d1297 27
d1325 39
a1363 3
			if (rt_g.debug & DEBUG_HF) {
				VPRINT("X next_pt", next_pt);
			}
d1365 4
a1368 14
			if (rising) {
				if (next_pt[Z] < CELL_MIN(grid_cell)) {
					/* in base */
					if (rt_g.debug & DEBUG_HF) bu_log("in base\n");

					IN_BASEX(isect, inside);

				} else if (curr_pt[Z] > CELL_MAX(grid_cell)) {
					/* miss above */
					if (rt_g.debug & DEBUG_HF) bu_log("miss above\n");
					MISS_ABOVE(isect, inside);
				} else {
					/* intersect */
					if (rt_g.debug & DEBUG_HF) bu_log("intersect %d %d X rising\n", CELL_MIN(grid_cell), CELL_MAX(grid_cell));
a1369 5
					ISECT_ENTRY_WALL();
					isect_ray_triangles(isect, grid_cell,
						curr_pt, next_pt,
						curr_surf, next_surf,
						&inside);
d1371 13
a1383 11
					ISECT_X_EXIT_WALL(isect, grid_cell);
				}
			} else {
				if (next_pt[Z] > CELL_MAX(grid_cell)) {
					/* miss above */
					if (rt_g.debug & DEBUG_HF) bu_log("miss above\n");
					MISS_ABOVE(isect, inside);
				} else if (curr_pt[Z] < CELL_MIN(grid_cell)){
					/* in base */
					if (rt_g.debug & DEBUG_HF) bu_log("in base\n");
					IN_BASEX(isect, inside);
d1385 2
a1386 11
					/* intersect */
					if (rt_g.debug & DEBUG_HF) bu_log("intersect %d %d X falling\n",
							 CELL_MIN(grid_cell), CELL_MAX(grid_cell));

					ISECT_ENTRY_WALL();
					isect_ray_triangles(isect, grid_cell,
						curr_pt, next_pt,
						curr_surf, next_surf,
						&inside);

					ISECT_X_EXIT_WALL(isect, grid_cell);
d1388 1
a1388 1
			}
d1394 6
d1411 59
a1469 16
			if (rt_g.debug & DEBUG_HF) {
				VPRINT("Y next_pt", next_pt);
			}
			if (rising) {
				if (next_pt[Z] < CELL_MIN(grid_cell)) {
					/* in base */
					if (rt_g.debug & DEBUG_HF) bu_log("in base\n");
					IN_BASEY(isect, inside);

				} else if (curr_pt[Z] > CELL_MAX(grid_cell)) {
					/* miss above */
					if (rt_g.debug & DEBUG_HF) bu_log("miss above\n");
					MISS_ABOVE(isect, inside);
				} else {
					/* intersect */
					if (rt_g.debug & DEBUG_HF) bu_log("intersect %d %d Y rising\n", CELL_MIN(grid_cell), CELL_MAX(grid_cell));
d1471 4
a1474 6
					ISECT_ENTRY_WALL();
					isect_ray_triangles(isect, grid_cell,
						curr_pt, next_pt,
						curr_surf, next_surf,
						&inside);
					ISECT_Y_EXIT_WALL(isect, grid_cell);
d1476 20
a1495 9
			} else {
				if (next_pt[Z] > CELL_MAX(grid_cell)) {
					/* miss above */
					if (rt_g.debug & DEBUG_HF) bu_log("miss above\n");
					MISS_ABOVE(isect, inside);
				} else if (curr_pt[Z] < CELL_MIN(grid_cell)){
					/* in base */
					if (rt_g.debug & DEBUG_HF) bu_log("in base\n");
					IN_BASEY(isect, inside);
a1496 1
					/* intersect */
d1498 1
a1498 10
						bu_log("intersect %d %d Y falling\n",
							CELL_MIN(grid_cell),
							CELL_MAX(grid_cell));

					ISECT_ENTRY_WALL();
					isect_ray_triangles(isect, grid_cell,
						curr_pt, next_pt,
						curr_surf, next_surf,
						&inside);
					ISECT_Y_EXIT_WALL(isect, grid_cell);
d1513 6
a1518 5
	} while ( grid_cell[X] != outX && grid_cell[Y] != outY &&
		  (tX < out_dist+tDX || tY < out_dist+tDY) ||
		  (rising && curr_pt[Z] < dsp_max) ||
		 (!rising && curr_pt[Z] > 0.0) );
		
d1558 1
a1558 1
		bu_log("rt_dsp_shot(pt:(%g %g %g)\n\tdir[%g]:(%g %g %g))\n",
d1561 2
a1562 1
			V3ARGS(rp->r_dir));
d1731 2
a1732 1
		bu_bomb("bogus surface of DSP\n");
@


1.13
log
@marching works.  triangle/cell intersector problems still.
@
text
@d49 1
a49 1
static char RCSdsp[] = "@@(#)$Header: /m/cad/librt/RCS/g_dsp.c,v 1.12 1997/06/16 20:59:37 butler Exp butler $ (BRL)";
d767 1
a767 1
	if (NdotD < 0.0) { \
d2019 2
a2020 2
	mat_idn(&dsp_ip->dsp_stom);
	mat_idn(&dsp_ip->dsp_mtos);
@


1.12
log
@cell stepping may be working again.
@
text
@d49 1
a49 1
static char RCSdsp[] = "@@(#)$Header: /m/cad/librt/RCS/g_dsp.c,v 1.11 1997/06/13 22:50:18 butler Exp butler $ (BRL)";
d124 2
a125 1
	struct seg *segp;	/* the current segment being filled */
d128 32
d161 16
d215 1
d579 224
d832 8
d852 8
a867 1

d871 2
a872 2
			bu_log("miss tri1 (perp)\n");

d877 3
d881 2
a882 1
	VCROSS(PAxD, PA, isect->r.r_dir); /* perpendicular to PA, D */
d884 2
a885 2
	/* project PAxD onto AB */
	alpha = VDOT( AB, PAxD );
d887 2
a888 8
	/* because PAxD is perpendicular to PA, we have to 
	 * reverse the projected direction along AB when the ray is 
	 * entering the triangle from the normalward direction
	 */
	if (NdotD < 0.0) alpha = -alpha;
	if (alpha < 0.0) {
		if (rt_g.debug & DEBUG_HF)
			bu_log("miss tri1 (alpha < 0.0)\n");
d890 1
a890 6
		goto tri2;
	}
	if (alpha > abs_NdotD ) {
		/* miss triangle */
		if (rt_g.debug & DEBUG_HF)
			bu_log("miss tri1 (alpha > NdotD)\n");
a891 2
		goto tri2;
	}
d893 1
a893 4
	beta = VDOT( AD, PAxD );
	if ( NdotD > 0.0 ) beta = -beta;
	if( beta < 0.0) {
		/* miss triangle */
d895 2
a896 1
			bu_log("miss tri1 (beta < 0.0)\n");
d899 1
a899 2
	if (beta > abs_NdotD ) {
		/* miss triangle */
d901 1
a901 1
			bu_log("miss tri1 (beta > NdotD)\n");
a903 1

d912 2
a913 4
	if (NdotD < 0.0) {
		/* Entering Solid */
		if (*inside) 
			bu_bomb("Can't enter top of DSP from inside\n");
a914 2
		if (rt_g.debug & DEBUG_HF)
			bu_log("hit tri1 entering\n");
d916 1
a916 8
		RT_GET_SEG( isect->segp, isect->ap->a_resource );
		isect->segp->seg_stp = isect->stp;
		isect->segp->seg_in.hit_dist = dist;

		isect->segp->seg_in.hit_surfno = TRI1;
		isect->segp->seg_in.hit_vpriv[X] = cell[X];
		isect->segp->seg_in.hit_vpriv[Y] = cell[Y];
		*inside = 1;
d918 1
a918 4
	} else {
		/* Leaving Solid */
		if (! *inside) 
			bu_bomb("Can't leave top of DSP from outside\n");
a919 2
		if (rt_g.debug & DEBUG_HF)
			bu_log("hit tri1 leaving\n");
a920 7
		isect->segp->seg_out.hit_dist = dist;
		isect->segp->seg_out.hit_surfno = TRI1;
		isect->segp->seg_out.hit_vpriv[X] = cell[X];
		isect->segp->seg_out.hit_vpriv[Y] = cell[Y];
		BU_LIST_INSERT( &isect->seglist, &( isect->segp->l) );
		*inside = 0;
	}
d930 3
a932 2
			bu_log("miss tri2 (perp)\n");
		return;
d935 1
a936 17
	/* because PAxD is perpendicular to PA, we have to 
	 * reverse the projected direction along AB when the ray is 
	 * entering the triangle from the normalward direction
	 */
	if (NdotD < 0.0) alpha = -alpha;
	if (alpha < 0.0) {
		/* miss triangle */
		if (rt_g.debug & DEBUG_HF)
			bu_log("miss tri2 (alpha < 0.0)\n");
		return;
	}
	if (alpha > abs_NdotD ) {
		/* miss triangle */
		if (rt_g.debug & DEBUG_HF)
			bu_log("miss tri2 (alpha > NdotD)\n");
		return;
	}
d938 1
d940 9
a948 3
	if ( NdotD > 0.0 ) beta = -beta;
	if (beta < 0.0) {
		/* miss triangle */
d950 1
a950 1
			bu_log("miss tri2 (beta < 0.0)\n");
d952 6
a957 1
		return;
d959 1
a959 1
	if (beta > abs_NdotD ) {
d962 2
a963 2
			bu_log("miss tri2 (beta > NdotD)\n");
		return;
d967 2
a968 4
	if (NdotD < 0.0) {
		/* Entering Solid */
		if (*inside) 
			bu_bomb("Can't enter top of DSP from inside\n");
d970 1
a970 26
		if (rt_g.debug & DEBUG_HF)
			bu_log("hit tri2 entering\n");

		RT_GET_SEG( isect->segp, isect->ap->a_resource );
		isect->segp->seg_stp = isect->stp;
		isect->segp->seg_in.hit_dist = dist;

		isect->segp->seg_in.hit_surfno = TRI2;
		isect->segp->seg_in.hit_vpriv[X] = cell[X];
		isect->segp->seg_in.hit_vpriv[Y] = cell[Y];
		*inside = 1;

	} else {
		/* Leaving Solid */
		if (! *inside) 
			bu_bomb("Can't leave top of DSP from outside\n");

		if (rt_g.debug & DEBUG_HF)
			bu_log("hit tri2 leaving\n");
		isect->segp->seg_out.hit_dist = dist;
		isect->segp->seg_out.hit_surfno = TRI2;
		isect->segp->seg_out.hit_vpriv[X] = cell[X];
		isect->segp->seg_out.hit_vpriv[Y] = cell[Y];
		BU_LIST_INSERT( &isect->seglist, &( isect->segp->l) );
		*inside = 0;
	}
d972 2
d985 2
a986 7
		RT_GET_SEG( (_i)->segp, (_i)->ap->a_resource );		    \
		(_i)->segp->seg_stp = (_i)->stp;			    \
		(_i)->segp->seg_in.hit_dist = tX;			    \
                                                                            \
		(_i)->segp->seg_in.hit_surfno = insurfX;		    \
		(_i)->segp->seg_in.hit_vpriv[X] = grid_cell[X];		    \
		(_i)->segp->seg_in.hit_vpriv[Y] = grid_cell[Y];		    \
d989 2
a990 4
	(_i)->segp->seg_out.hit_dist = tX + tDX;			    \
	(_i)->segp->seg_out.hit_surfno = outsurfX;			    \
	(_i)->segp->seg_in.hit_vpriv[X] = grid_cell[X];			    \
	(_i)->segp->seg_in.hit_vpriv[Y] = grid_cell[Y]
d992 1
d997 2
a998 7
		RT_GET_SEG( (_i)->segp, (_i)->ap->a_resource );             \
		(_i)->segp->seg_stp = (_i)->stp;                            \
		(_i)->segp->seg_in.hit_dist = tY;                           \
									    \
		(_i)->segp->seg_in.hit_surfno = insurfY;                    \
		(_i)->segp->seg_in.hit_vpriv[X] = grid_cell[X];             \
		(_i)->segp->seg_in.hit_vpriv[Y] = grid_cell[Y];             \
d1001 1
a1001 4
	(_i)->segp->seg_out.hit_dist = tY + tDY;			    \
	(_i)->segp->seg_out.hit_surfno = outsurfY;                          \
	(_i)->segp->seg_in.hit_vpriv[X] = grid_cell[X];                     \
	(_i)->segp->seg_in.hit_vpriv[Y] = grid_cell[Y]
d1005 2
a1006 1
		BU_LIST_INSERT( &(_i)->seglist, &( (_i)->segp->l) );        \
d1026 2
d1031 4
a1034 7
				RT_GET_SEG( isect->segp, isect->ap->a_resource ); \
				isect->segp->seg_stp = isect->stp; \
				isect->segp->seg_in.hit_dist = curr_dist; \
					                                     \
				isect->segp->seg_in.hit_surfno = BBSURF(XMIN); \
				isect->segp->seg_in.hit_vpriv[X] = grid_cell[X]; \
				isect->segp->seg_in.hit_vpriv[Y] = grid_cell[Y]; \
d1050 2
d1055 2
a1056 7
				RT_GET_SEG( isect->segp, isect->ap->a_resource ); \
				isect->segp->seg_stp = isect->stp; \
				isect->segp->seg_in.hit_dist = curr_dist; \
                                					    \
				isect->segp->seg_in.hit_surfno = BBSURF(XMAX); \
				isect->segp->seg_in.hit_vpriv[X] = grid_cell[X]; \
				isect->segp->seg_in.hit_vpriv[Y] = grid_cell[Y]; \
d1071 2
d1077 2
a1078 7
				RT_GET_SEG( isect->segp, isect->ap->a_resource ); \
				isect->segp->seg_stp = isect->stp;          \
				isect->segp->seg_in.hit_dist = curr_dist; \
					                                    \
				isect->segp->seg_in.hit_surfno = BBSURF(YMIN); \
				isect->segp->seg_in.hit_vpriv[X] = grid_cell[X]; \
				isect->segp->seg_in.hit_vpriv[Y] = grid_cell[Y]; \
d1094 2
d1098 4
a1101 8
					bu_log("entering @@ YMIN wall\n"); \
				RT_GET_SEG( isect->segp, isect->ap->a_resource );                                     \
				isect->segp->seg_stp = isect->stp;          \
				isect->segp->seg_in.hit_dist = curr_dist;\
                                 					    \
				isect->segp->seg_in.hit_surfno = BBSURF(YMAX);  \
				isect->segp->seg_in.hit_vpriv[X] = grid_cell[X]; \
				isect->segp->seg_in.hit_vpriv[Y] = grid_cell[Y]; \
d1117 2
a1118 7
			RT_GET_SEG( isect->segp, isect->ap->a_resource ); \
			isect->segp->seg_stp = isect->stp;          \
			isect->segp->seg_in.hit_dist = curr_dist;\
                                					    \
			isect->segp->seg_in.hit_surfno = BBSURF(ZMIN); \
			isect->segp->seg_in.hit_vpriv[X] = grid_cell[X]; \
			isect->segp->seg_in.hit_vpriv[Y] = grid_cell[Y]; \
d1153 2
a1154 4
			isect->segp->seg_out.hit_dist = tX;                 \
			isect->segp->seg_out.hit_surfno = outsurfX;         \
			isect->segp->seg_in.hit_vpriv[X] = grid_cell[X];    \
			isect->segp->seg_in.hit_vpriv[Y] = grid_cell[Y];    \
d1177 1
a1177 4
			isect->segp->seg_out.hit_dist = tY;                 \
			isect->segp->seg_out.hit_surfno = outsurfY;         \
			isect->segp->seg_in.hit_vpriv[X] = grid_cell[X];    \
			isect->segp->seg_in.hit_vpriv[Y] = grid_cell[Y];    \
d1197 5
a1202 5
	point_t curr_pt;
	int	curr_surf;
	double	curr_dist;
	point_t next_pt;
	int	next_surf;
d1211 1
a1211 1
	vect_t	pDX, pDY;	/* vector for 1 cell change in x, y */
d1231 4
d1242 3
a1244 1

d1251 7
d1260 1
a1317 5
		bu_log(" in cell(%d,%d)  pt(%g %g %g)\n",
			grid_cell[X], grid_cell[Y], V3ARGS(curr_pt));
		bu_log("out cell(%d,%d)  pt(%g %g %g)\n",
			bbout_cell[X], bbout_cell[Y], V3ARGS(bbout_pt));

d1327 2
a1328 2
			bu_log("cell(%d,%d) tX:%g tY:%g\n\t  curr_pt(%g %g %g)\n\t",
				grid_cell[X], grid_cell[Y], tX, tY, V3ARGS(curr_pt));
d1355 1
a1355 1
					if (rt_g.debug & DEBUG_HF) bu_log("intersect %d %d\n", CELL_MIN(grid_cell), CELL_MAX(grid_cell));
d1376 2
a1377 1
					if (rt_g.debug & DEBUG_HF) bu_log("intersect %d %d\n", CELL_MIN(grid_cell), CELL_MAX(grid_cell));
d1419 1
a1419 1
					if (rt_g.debug & DEBUG_HF) bu_log("intersect %d %d\n", CELL_MIN(grid_cell), CELL_MAX(grid_cell));
d1440 1
a1440 1
						bu_log("intersect %d %d\n",
d1471 1
a1471 1
		BU_LIST_INSERT( &isect->seglist, &( isect->segp->l) );
d1536 1
d1544 1
d1547 1
d1562 5
a1566 4
		RT_GET_SEG( isect.segp, isect.ap->a_resource );
		isect.segp->seg_stp = isect.stp;
		isect.segp->seg_in.hit_dist = isect.minbox.in_dist;
		isect.segp->seg_in.hit_surfno = BBSURF(isect.minbox.in_surf);
d1568 1
a1568 2
		isect.segp->seg_out.hit_dist = isect.minbox.out_dist;
		isect.segp->seg_out.hit_surfno = BBSURF(isect.minbox.out_surf);
a1569 1
		BU_LIST_INSERT( &isect.seglist, &(isect.segp->l) );
@


1.11
log
@errors in cell marching picked up somewhere along the way.
@
text
@d49 1
a49 1
static char RCSdsp[] = "@@(#)$Header: /m/cad/librt/RCS/g_dsp.c,v 1.10 1997/06/11 03:08:01 butler Exp butler $ (BRL)";
a577 56
	if (rt_g.debug & DEBUG_HF) {
		FILE *fd;
		static int n=0;
		short h, i;
		char buf[32];
		short cell_min = CELL_MIN(cell);
		short cell_max = CELL_MAX(cell);

		/* plot out the scenario */
		RES_ACQUIRE( &rt_g.res_model);

		sprintf(buf, "dsp%d_1.pl", n++);
		if ((fd=fopen(buf, "w")) != (FILE *)NULL) {
			/* plot the box */
			pl_color(fd, 180, 180, 255);
			pl_3move(fd, cell[X], cell[Y], cell_min);
			pl_3cont(fd, cell[X]+1, cell[Y], cell_min);
			pl_3cont(fd, cell[X]+1, cell[Y]+1, cell_min);
			pl_3cont(fd, cell[X], cell[Y]+1, cell_min);
			pl_3cont(fd, cell[X], cell[Y], cell_min);
			pl_3cont(fd, cell[X], cell[Y], cell_max);
			pl_3cont(fd, cell[X]+1, cell[Y], cell_max);
			pl_3cont(fd, cell[X]+1, cell[Y]+1, cell_max);
			pl_3cont(fd, cell[X], cell[Y]+1, cell_max);
			pl_3cont(fd, cell[X], cell[Y], cell_max);
			pl_3line(fd, cell[X]+1, cell[Y], cell_min,
				     cell[X]+1, cell[Y], cell_max);
			pl_3line(fd, cell[X]+1, cell[Y]+1, cell_min,
				     cell[X]+1, cell[Y]+1, cell_max);
			pl_3line(fd, cell[X], cell[Y]+1, cell_min,
				     cell[X], cell[Y]+1, cell_max);

			/* plot the ray */
			pl_color(fd, 255, 140, 140);
			pdv_3line(fd, curr_pt, next_pt);

			/* plot the triangles */
			pl_color(fd, 140, 255, 140);
			pl_3move(fd, cell[X], cell[Y], DSP(isect->dsp,
				     cell[X], cell[Y]) );
			pl_3cont(fd, cell[X]+1, cell[Y], DSP(isect->dsp,
				     cell[X]+1, cell[Y]) );
			pl_3cont(fd, cell[X]+1, cell[Y]+1, DSP(isect->dsp,
				     cell[X]+1, cell[Y]+1) );
			pl_3cont(fd, cell[X], cell[Y]+1, DSP(isect->dsp,
				     cell[X], cell[Y]+1) );
			pl_3cont(fd, cell[X], cell[Y], DSP(isect->dsp,
				     cell[X], cell[Y]) );
			pl_3cont(fd, cell[X]+1, cell[Y]+1, DSP(isect->dsp,
				     cell[X]+1, cell[Y]+1) );


			fclose(fd);
		}
		RES_RELEASE( &rt_g.res_model);
	}
d803 1
a803 1
	switch (curr_pt_surf) {                                     	    \
d819 1
a819 1
				isect->segp->seg_in.hit_dist = curr_pt_dist; \
d844 1
a844 1
				isect->segp->seg_in.hit_dist = curr_pt_dist; \
d869 1
a869 1
				isect->segp->seg_in.hit_dist = curr_pt_dist; \
d894 1
a894 1
				isect->segp->seg_in.hit_dist = curr_pt_dist;\
d916 1
a916 1
			isect->segp->seg_in.hit_dist = curr_pt_dist;\
d945 1
a945 1
	if (next_pt_surf == BBSURF(XMIN) ) h = grid_cell[X];                \
d971 1
a971 1
	if (next_pt_surf == BBSURF(YMIN) ) h = grid_cell[Y];                \
d998 7
d1006 2
a1007 2
	int	curr_pt_surf;
	double	curr_pt_dist;
d1009 1
a1009 1
	int	next_pt_surf;
a1012 2
	point_t out_pt;
	int	out_cell[3];	/* grid cell of last point in bbox */
d1040 5
a1044 3
	curr_pt_dist = isect->bbox.in_dist;
	VJOIN1(curr_pt, isect->r.r_pt, curr_pt_dist, isect->r.r_dir);
	curr_pt_surf = isect->bbox.in_surf;
d1046 2
a1047 1
	VMOVE(grid_cell, curr_pt);	/* int/float conversion */
d1049 2
a1050 2
	VJOIN1(out_pt, isect->r.r_pt, isect->bbox.out_dist, isect->r.r_dir);
	VMOVE(out_cell, out_pt);	/* int/float conversion */
d1071 1
a1071 1
/*		if (tX == 0.0) tX = tDX; */
a1081 1
/*			if (tX == 0.0) tX = tDX; */
a1093 2
/*		if (tY == 0.0) tX = tDY; */

a1103 1
/*			if (tY == 0.0) tX = tDY; */
a1107 2
	VSCALE(pDX, isect->r.r_dir, tDX);	/* vect for going tDX dist */
	VSCALE(pDY, isect->r.r_dir, tDY);
d1109 1
a1109 1
	
d1114 1
a1114 1
			out_cell[X], out_cell[Y], V3ARGS(out_pt));
a1122 3



d1132 2
a1133 2
			VJOIN1(next_pt, curr_pt, tX, isect->r.r_dir);
			next_pt_surf = outsurfX;
d1139 1
d1158 1
a1158 1
						curr_pt_surf, next_pt_surf,
d1179 1
a1179 1
						curr_pt_surf, next_pt_surf,
d1189 2
a1190 2
			curr_pt_surf = insurfX;
			curr_pt_dist = tX;
d1198 2
a1199 2
			VJOIN1(next_pt, curr_pt, tY, isect->r.r_dir);
			next_pt_surf = outsurfY;
d1221 1
a1221 1
						curr_pt_surf, next_pt_surf,
d1244 1
a1244 1
						curr_pt_surf, next_pt_surf,
d1253 2
a1254 2
			curr_pt_surf = insurfY;
			curr_pt_dist = tY;
@


1.10
log
@checkpoint
@
text
@d10 1
a10 10
 *	The surfaces of the bounding box of the dsp (in dsp coordinates)
 *	are 0 .. 6 where:
 *					Surf #
 *		0	X == 0		-1
 *		1	XMAX		-2
 *		2	Y == 0		-3
 *		3	YMAX		-4
 *		4	Z == 0		-5
 *		5	DSP_MAX		-6
 *		6	DSP_MIN		-7	(upward normal)
d12 19
d33 2
a34 2
 *	The bounding planes on the sides and bottom are numbered -6 .. -1
 *	The pseudo-surface on the top of the bounding box is -7
d49 1
a49 1
static char RCSdsp[] = "@@(#)$Header: /m/cad/librt/RCS/g_dsp.c,v 1.9 1997/06/10 13:07:06 jra Exp butler $ (BRL)";
d63 1
a63 1

d75 3
a88 2
#define CELL_MIN(_t) 1
#define CELL_MAX(_t) 1
a120 6

	char	NdotDbits;	/* bit field of perpendicular faces */
	double	NdotD[8];	/* array of VDOT(plane, dir) values */
	double	recipNdotD[8];
	double	NdotPt[8];	/* array of VDOT(plane, pt) values */

a123 1
	int inside;		/* flag:  We're inside the solid */
a128 1

a247 1

d254 1
d259 5
a278 1

d301 8
a308 8
	BBOX_PT(-1,		    -1,		        -1);
	BBOX_PT(dsp_ip->dsp_xcnt+1, -1,		        -1);
	BBOX_PT(dsp_ip->dsp_xcnt+1, dsp_ip->dsp_ycnt+1, -1);
	BBOX_PT(-1,		    dsp_ip->dsp_ycnt+1, -1);
	BBOX_PT(-1,		    -1,		        dsp_max+1);
	BBOX_PT(dsp_ip->dsp_xcnt+1, -1,		        dsp_max+1);
	BBOX_PT(dsp_ip->dsp_xcnt+1, dsp_ip->dsp_ycnt+1, dsp_max+1);
	BBOX_PT(-1,		    dsp_ip->dsp_ycnt+1, dsp_max+1);
d327 2
d332 1
a332 1
#if 1
d444 57
d502 27
d530 5
a534 2
 *  Intersect the ray with the bounding box of the dsp solid.
 *  We also pre-compute some per-ray things that will be useful later.
d536 9
a544 3
static int
isect_ray_bbox(isect)
register struct isect_stuff *isect;
d546 31
a576 3
	register double NdotD;
	double dist;
	register int i;
d578 50
a627 6
	isect->NdotDbits = 0;
	isect->bbox.in_dist = - (isect->bbox.out_dist = MAX_FASTF);
	isect->bbox.in_surf = isect->bbox.out_surf = -1;
	
	/* intersect the ray with the bounding box */
	for (i=0 ; i < BBOX_PLANES ; i++) {
a628 3
		NdotD = VDOT(dsp_pl[i], isect->r.r_dir);
		isect->NdotD[i] = NdotD;
		isect->NdotPt[i] = VDOT(dsp_pl[i], isect->r.r_pt);
d630 1
a630 4
		/* if N/ray vectors are perp, ray misses plane */
		if (BN_VECT_ARE_PERP(NdotD, isect->tol)) {
			isect->NdotDbits |= 1 << i;
			continue;
d632 10
d643 1
a643 1
		isect->recipNdotD[i] = 1.0 / NdotD;
d645 1
a645 3
		/* ray hits plane, compute distance along ray to plane */
		dist = - ( (isect->NdotPt[i] - isect->dsp->dsp_pl_dist[i]) *
			 isect->recipNdotD[i]);
d647 9
d657 1
a657 4
			bu_log("surf[%d](%g %g %g %g) dot:%g dist:%g\n",
				i, V3ARGS(dsp_pl[i]),
				isect->dsp->dsp_pl_dist[i],
				NdotD, dist);
d659 6
a664 2
		if ( i > 5) /* dsp_min elevation not valid bbox limit */
			continue;
d666 1
a666 13
		if (NdotD < 0.0) {
			/* entering */
			if (dist > isect->bbox.in_dist) {
				isect->bbox.in_dist = dist;
				isect->bbox.in_surf = i;
			}
		} else { /*  (NdotD > 0.0) */
			/* leaving */
			if (dist < isect->bbox.out_dist) {
				isect->bbox.out_dist = dist;
				isect->bbox.out_surf = i;
			}
		}
d669 14
d684 5
a688 8
	if (rt_g.debug & DEBUG_HF) {
		vect_t pt;
		VJOIN1(pt, isect->r.r_pt, isect->bbox.in_dist, isect->r.r_dir);
		bu_log("solid rpp in  surf[%d] dist:%g (%g %g %g)\n",
			isect->bbox.in_surf, isect->bbox.in_dist, V3ARGS(pt));
		VJOIN1(pt, isect->r.r_pt, isect->bbox.out_dist, isect->r.r_dir);
		bu_log("solid rpp out surf[%d] dist:%g  (%g %g %g)\n",
			isect->bbox.out_surf, isect->bbox.out_dist, V3ARGS(pt));
a689 4
	/* validate */
	if (isect->bbox.in_dist >= isect->bbox.out_dist ||
	    isect->bbox.out_dist >= MAX_FASTF ) 
		return 0; /* MISS */
d691 5
a695 12
	/* 
	 * if the ray is parallel to a face we need to check whether
	 * we were "inside" or "outside" of the face.
	 */
	if (isect->NdotDbits)
	    for (i=0 ; i < BBOX_PLANES ; i++) {
		if ( ! ((1<<i) & isect->NdotDbits) ) continue;

		if ( (isect->NdotPt[i] - isect->dsp->dsp_pl_dist[i]) >
		    SQRT_SMALL_FASTF)
			return 0; /* MISS */
	    }
d697 2
d700 8
d709 4
a712 3
	/* copmute "minbox" the bounding box of the rpp under the lowest
	 * displacement height
	 */
d714 2
a715 4
	isect->minbox.in_dist = isect->bbox.in_dist;
	isect->minbox.in_surf = isect->bbox.in_surf;
	isect->minbox.out_dist = isect->bbox.out_dist;
	isect->minbox.out_surf = isect->bbox.out_surf;
d717 6
a722 12
	if (NdotD < 0.0) {
		/* entering */
		if (dist > isect->bbox.in_dist) {
			isect->minbox.in_dist = dist;
			isect->minbox.in_surf = 6;
		}
	} else { /*  (NdotD > 0.0) */
		/* leaving */
		if (dist < isect->bbox.out_dist) {
			isect->minbox.out_dist = dist;
			isect->minbox.out_surf = 6;
		}
d724 1
d726 3
a728 3
	if (rt_g.debug & DEBUG_HF) {
		vect_t pt;
		VJOIN1(pt, isect->r.r_pt, isect->minbox.in_dist, isect->r.r_dir);
d730 6
a735 2
		bu_log("solid minbox rpp in  surf[%d] dist:%g (%g %g %g)\n",
			isect->minbox.in_surf, isect->minbox.in_dist, V3ARGS(pt));
d737 17
a753 3
		VJOIN1(pt, isect->r.r_pt, isect->minbox.out_dist, isect->r.r_dir);
		bu_log("solid minbox rpp out surf[%d] dist:%g (%g %g %g)\n",
			isect->minbox.out_surf, isect->minbox.out_dist, V3ARGS(pt));
d756 15
a770 2
	return 1;
}
d772 5
d778 2
a779 12
/*
 *  Intersect a ray with a cell bounding box.  Uses data from isect_ray_bbox.
 *
 */
static int
isect_cell_bb(isect, d, bbi)
register struct isect_stuff *isect;
double	d[6];	/* xmin, xmax, ymin, ymax, zmin, zmax plane distances */
register struct bbox_isect *bbi;
{
	register double dist;
	register int i;
d781 8
a788 1
	bbi->in_dist = - ( bbi->out_dist = MAX_FASTF );
d790 4
a793 1
	for (i=0 ; i < 6 ; i++) {
a794 1
#ifdef DEBUG_CELL_BB 
d796 11
a806 2
			bu_log("bbox d[%d] = %g", i, d[i]);
#endif
d808 4
a811 11
		if (isect->NdotDbits & (1<<i)) {
			if ( (isect->NdotPt[i]-isect->dsp->dsp_pl_dist[i]) >
			    SQRT_SMALL_FASTF) {
#ifdef DEBUG_CELL_BB
				if (rt_g.debug & DEBUG_HF)
					bu_log(" bbox miss due to face parallel\n");
#endif
				return 0; /* miss */
			    }
			continue;
		}
d813 39
a851 31
		dist = - ((isect->NdotPt[i] - d[i]) * isect->recipNdotD[i]);
#ifdef DEBUG_CELL_BB
		if (rt_g.debug & DEBUG_HF) {
			vect_t pt;
			VJOIN1(pt, isect->r.r_pt, dist, isect->r.r_dir);
			bu_log(" bbox dist %g  (%g %g %g)", dist, V3ARGS(pt));
		}
#endif
		if (isect->NdotD[i] < 0.0) {
			if (dist > bbi->in_dist) {
				bbi->in_dist = dist;
				bbi->in_surf = i;
#ifdef DEBUG_CELL_BB
				if (rt_g.debug & DEBUG_HF)
					bu_log(" new in");
#endif
			}
		} else {
			if (dist < bbi->out_dist) {
				bbi->out_dist = dist;
				bbi->out_surf = i;
#ifdef DEBUG_CELL_BB
				if (rt_g.debug & DEBUG_HF)
					bu_log(" new out");
#endif
			}
		}
#ifdef DEBUG_CELL_BB
		if (rt_g.debug & DEBUG_HF)
					bu_log("\n");
#endif
d854 142
a995 3
	if (bbi->in_dist >= bbi->out_dist ||
	    bbi->in_dist <= -MAX_FASTF || bbi->out_dist >= MAX_FASTF)
	    	return 0;
d997 22
a1018 1
	return 1;
a1020 1
#endif
d1023 22
a1044 11
/*
 *
 *  Once we've determined that the ray hits the bounding box for
 *  the triangles, this routine takes care of the actual triangle intersection
 *  and follow-up.
 */
static void
isect_ray_triangles(isect, cell)
struct isect_stuff *isect;
int cell[3];
{
d1049 1
a1053 1
#if 1
d1055 2
d1058 2
d1061 3
d1067 2
d1072 8
a1079 1
	double	tX, tY;	/* dist along ray from hit pt. to next cell boundary */
d1083 7
d1091 4
a1094 1
	VJOIN1(curr_pt, isect->r.r_pt, isect->bbox.in_dist, isect->r.r_dir);
d1097 3
d1102 1
a1102 1
	if (isect->r.r_dir[X] < 0) {
d1105 8
d1114 6
d1123 3
d1127 6
d1137 3
d1141 4
d1148 3
d1152 6
a1162 6
	/* since we're probably starting in the middle of a cell, we need
	 * to compute the distance along the ray to the initial
	 * X and Y boundaries.
	 */
	tX = (curr_pt[X] - grid_cell[X]) / isect->r.r_dir[X];
	tY = (curr_pt[Y] - grid_cell[Y]) / isect->r.r_dir[Y];
d1164 16
d1181 4
d1190 2
d1193 3
d1199 4
d1205 2
d1209 9
d1222 2
d1226 2
d1230 9
d1245 2
a1247 5
			if (grid_cell[X] == outX) {
				/* just stepped out of last cell in X */
				break;
			}

d1255 1
d1257 3
d1263 3
d1268 2
d1272 8
d1284 2
d1288 2
d1292 11
d1309 2
a1311 5
			if (grid_cell[Y] == outY) {
				/* just stepped out of last cell in Y */
				break;
			}

d1317 2
a1318 1
	} while ( (tX < out_dist || tY < out_dist) ||
d1323 3
a1325 134
#else
	int rising; /* boolean: ray Z positive */
	int xcnt, ycnt;
	int grid_cell[3];
	int out_cell[3];
	point_t curr_pt;
	point_t next_pt;
	point_t out_pt;
	double dist;

		int dsp_status;
		int status;
		struct bbox_isect bb_dsp;
		struct bbox_isect bb_cell_max;
		struct bbox_isect bb_cell_min;
		double d[6];

	isect->inside = 0;

	/* compute BBox entry point and starting grid cell */
	VJOIN1(curr_pt, isect->r.r_pt, isect->bbox.in_dist, isect->r.r_dir);
	VMOVE(grid_cell, curr_pt);	/* int/float conversion */

	/* compute BBox exit point */
	VJOIN1(out_pt, isect->r.r_pt, isect->bbox.out_dist, isect->r.r_dir);
	VMOVE(out_cell, out_pt);	/* int/float conversion */




	if (rt_g.debug & DEBUG_HF) {
		VPRINT("in_pt", curr_pt);
		VPRINT("out_pt", out_pt);
	}

#define CELL_MAX(_c) \
	(isect->dsp->cell_max[ (_c)[1] * XCNT(isect->dsp) + (_c)[0] ])
#define CELL_MIN(_c) \
	(isect->dsp->cell_min[ (_c)[1] * XCNT(isect->dsp) + (_c)[0] ])

#define DSET(xl, xh, yl, yh, zl, zh) \
	d[0] = (xl) * -1.0;	d[1] = xh; \
	d[2] = (yl) * -1.0;	d[3] = yh; \
	d[4] = (zl) * -1.0;	d[5] = zh

	do {
		if (rt_g.debug & DEBUG_HF) bu_log("cell (%d %d)-------------------------------------------\n", grid_cell[X], grid_cell[Y]);


		DSET(grid_cell[X], grid_cell[X]+1,
			grid_cell[Y], grid_cell[Y]+1,
			0.0, isect->dsp->dsp_pl_dist[5]);

		/* XXX we should really remember the previous out_surf/dist
		 * and use it for our in_surf/dist here, and save the 
		 * calculation for the in_* values
		 */
		dsp_status = isect_cell_bb(isect, d, &bb_dsp);
		/* if we now miss the the dsp, we're done */
		if (dsp_status == 0) {
			if (rt_g.debug & DEBUG_HF) bu_log("cell_miss\n");
			break;
		}
		if (rt_g.debug & DEBUG_HF) bu_log("dspcell  in surf: %d dist: %g\ndspcell out surf: %d dist: %g status %d\n",bb_dsp.in_surf, bb_dsp.in_dist,bb_dsp.out_surf, bb_dsp.out_dist, dsp_status);


		d[ZMAX] = CELL_MAX(grid_cell);
		status = isect_cell_bb(isect, d, &bb_cell_max);
		if (rt_g.debug & DEBUG_HF) bu_log("cell max  in surf: %d dist: %g\ncell max out surf: %d dist: %g status %d\n",bb_cell_max.in_surf, bb_cell_max.in_dist,bb_cell_max.out_surf, bb_cell_max.out_dist,status);
		if (status == 0) {
			if (isect->inside == 2) {
				isect->inside = 0;
				if (rt_g.debug & DEBUG_HF) bu_log("Previous segment now complete (%d %d) -> (%d %d)\n", isect->segp->seg_in.hit_vpriv[X], isect->segp->seg_in.hit_vpriv[Y], isect->segp->seg_out.hit_vpriv[X], isect->segp->seg_out.hit_vpriv[Y]);

				BU_LIST_INSERT( &isect->seglist, &(isect->segp->l) );
			}

			if (rt_g.debug & DEBUG_HF) bu_log("miss cell_max\n");
			goto next_iter;
		}



		d[ZMAX] = CELL_MIN(grid_cell);
		status = isect_cell_bb(isect, d, &bb_cell_min);
		if (rt_g.debug & DEBUG_HF) bu_log("cell min  in surf: %d dist: %g\ncell min out surf: %d dist: %g status %d\n",bb_cell_min.in_surf, bb_cell_min.in_dist,bb_cell_min.out_surf, bb_cell_min.out_dist,status);
		if (bb_cell_min.in_surf < 4 && bb_cell_min.out_surf < 4) {
			/* through the base */
			if (! isect->inside) {
				isect->inside = 2;

				if (rt_g.debug & DEBUG_HF) bu_log("New  IN at cell %d %d\n", grid_cell[X], grid_cell[Y]);
				RT_GET_SEG( isect->segp, isect->ap->a_resource );
				isect->segp->seg_stp = isect->stp;
				isect->segp->seg_in.hit_dist = isect->bbox.in_dist;
				isect->segp->seg_in.hit_surfno = isect->bbox.in_surf;
				isect->segp->seg_in.hit_vpriv[X] = grid_cell[X];
				isect->segp->seg_in.hit_vpriv[Y] = grid_cell[Y];
			}
			if (rt_g.debug & DEBUG_HF) bu_log("New OUT at cell %d %d\n", grid_cell[X], grid_cell[Y]);
			isect->segp->seg_out.hit_dist = isect->bbox.out_dist;
			isect->segp->seg_out.hit_surfno = isect->bbox.out_surf;
			isect->segp->seg_out.hit_vpriv[X] = grid_cell[X];
			isect->segp->seg_out.hit_vpriv[Y] = grid_cell[Y];
			goto next_iter;
		}

		/* we've hit the bounding box for the two triangles that
		 * make up this cell.
		 */
		isect_ray_triangles(isect, grid_cell);


next_iter:
		switch (bb_dsp.out_surf) {
		case XMIN: grid_cell[X] -= 1; break;
		case XMAX: grid_cell[X] += 1; break;
		case YMIN: grid_cell[Y] -= 1; break;
		case YMAX: grid_cell[Y] += 1; break;
		case ZMIN: dsp_status = 0; break;
		case ZMAX: dsp_status = 0; break;
		}
		if (rt_g.debug & DEBUG_HF)
			bu_log("out_surf: %d dsp_status %d\n",
				bb_dsp.out_surf, dsp_status);

	} while (dsp_status);

#undef CELL_MAX
#undef CELL_MIN

	if (isect->inside) {
		if (rt_g.debug & DEBUG_HF) bu_log("Previous segment now complete (%d %d) -> (%d %d)\n", isect->segp->seg_in.hit_vpriv[X], isect->segp->seg_in.hit_vpriv[Y], isect->segp->seg_out.hit_vpriv[X], isect->segp->seg_out.hit_vpriv[Y]);
		BU_LIST_INSERT( &isect->seglist, &(isect->segp->l) );
a1327 2
#endif

d1367 1
a1367 1

d1414 2
a1415 2
		isect.segp->seg_in.hit_dist = isect.bbox.in_dist;
		isect.segp->seg_in.hit_surfno = -(isect.bbox.in_surf+1);
d1417 2
a1418 2
		isect.segp->seg_out.hit_dist = isect.bbox.out_dist;
		isect.segp->seg_out.hit_surfno = -(isect.bbox.out_surf+1);
d1506 2
a1507 1
	vect_t N;
d1516 14
d1531 1
a1531 19
		switch (  hitp->hit_surfno ) {
		case XMIN:
		case XMAX:
		case YMIN:
		case YMAX:
		case ZMIN:
			MAT4X3VEC( N, dsp->dsp_i.dsp_stom, 
				dsp_pl[ hitp->hit_surfno ] );
			break;
		case ZMAX:
			/* XXX this should look at which triangle 
			 * of which cell was hit and 
			 * return the appropriate normal.
			 */
			MAT4X3VEC( N, dsp->dsp_i.dsp_stom, 
				dsp_pl[ hitp->hit_surfno ] );
			break;
		}

@


1.9
log
@Added a missing `;'
@
text
@d12 8
a19 7
 *		0	X == 0
 *		1	XMAX
 *		2	Y == 0
 *		3	YMAX
 *		4	Z == 0
 *		5	DSP_MAX
 *		6	DSP_MIN	up
d23 2
a24 2
 *	The bounding planes on the sides and bottom are numbered -5 .. -1
 *	The pseudo-surface on the top of the bounding box is -6
d39 1
a39 1
static char RCSdsp[] = "@@(#)$Header: /m/cad/librt/RCS/g_dsp.c,v 1.8 1997/06/09 22:22:03 butler Exp jra $ (BRL)";
d55 1
d76 2
a78 1

a85 2
	unsigned short	*cell_min;
	unsigned short	*cell_max;
d110 1
d167 1
a167 1
struct rt_dsp_internal *dsp_ip;
d208 1
a208 1
	dsp_print(&vls, &dsp->dsp_i);
a238 1
	CONST struct rt_tol		*tol = &rtip->rti_tol;
a240 3
	unsigned short left_min, left_max;
	unsigned short right_min, right_max;
	unsigned short *cell_min, *cell_max;
a243 1
	int cells;
a257 10
	cells = dsp->xsiz * dsp->ysiz;	/* Total # cells in map */

	/* build two maps:
	 *	Cell min values
	 *	Cell max values
	 * and compute min/max values for entire map
	 */
	cell_min = dsp->cell_min = (unsigned short *)
		rt_malloc( sizeof(*dsp->cell_min) * cells * 2, "min/max map" );
	cell_max = dsp->cell_max = & dsp->cell_min[cells];
d264 1
a264 7
		if (DSP(dsp, 0, y) < DSP(dsp, 0, y+1)) {
			left_min = DSP(dsp, 0, y);
			left_max = DSP(dsp, 0, y+1);
		} else {
			left_min = DSP(dsp, 0, y+1);
			left_max = DSP(dsp, 0, y);
		}
d266 2
a267 1
		for (x=1 ; x < XCNT(dsp) ; x++) {
d269 2
a270 7
			if (DSP(dsp, x, y) < DSP(dsp, x, y+1)) {
				right_min = DSP(dsp, x, y);
				right_max = DSP(dsp, x, y+1);
			} else {
				right_min = DSP(dsp, x, y+1);
				right_max = DSP(dsp, x, y);
			}
a271 17
			if (left_min < right_min)
				*cell_min = left_min;
			else
				*cell_min = right_min;

			if (left_max > right_max)
				*cell_max = left_max;
			else
				*cell_max = right_max;

			if (*cell_min < dsp_min) dsp_min = *cell_min;
			if (*cell_max > dsp_max) dsp_max = *cell_max;

			left_min = right_min;
			left_max = right_max;
			cell_max++;
			cell_min++;
d323 111
d435 1
d563 1
d638 1
a638 1

d660 129
a788 5
	vect_t pDX, pDY;	/* vector for 1 cell change in x, y */
	int outX, outY;		/* cell index which idicates we're outside */
	double tDX, tDY;	/* dist from cell start to next cell */
	double tX, tY;		/* dist to end of first cell */
	int stepX, stepY;
a814 30
	if (isect->minbox.in_surf < 5) {
		isect->inside = 1;

		RT_GET_SEG( isect->segp, isect->ap->a_resource );
		isect->segp->seg_stp = isect->stp;
		isect->segp->seg_in.hit_dist = isect->bbox.in_dist;
		isect->segp->seg_in.hit_surfno = -isect->bbox.in_surf;
		isect->segp->seg_in.hit_vpriv[X] = grid_cell[X];
		isect->segp->seg_in.hit_vpriv[Y] = grid_cell[Y];

		if ( isect->minbox.out_surf < 5 ) {
			/* we actually hit and exit the dsp 
			 * BELOW the min value.  For example:
			 *			     o ray origin
			 *	     /\dsp	    /
			 *	   _/  \__   /\_   /
			 *	_ |       \_/   | / ray
			 *	| |		|/
			 * Minbox |		*in point
			 *	| |	       /|
			 *	- +-----------*-+
			 *		     / out point
			 */

			isect->segp->seg_out.hit_dist = isect->bbox.out_dist;
			isect->segp->seg_out.hit_surfno = -isect->bbox.out_surf;
			isect->segp->seg_out.hit_vpriv[X] = out_cell[X];
			isect->segp->seg_out.hit_vpriv[Y] = out_cell[Y];

			BU_LIST_INSERT( &isect->seglist, &(isect->segp->l) );
a815 6
			return;
		} else {
			isect->segp->seg_out.hit_vpriv[X] = -1;
			isect->segp->seg_out.hit_vpriv[Y] = -1;
		}
	}
a817 1

d924 1
a992 1
	/* intersect ray with dsp data */
a993 1
	isect_ray_dsp(&isect);
d995 30
d1057 1
a1057 1
		CONST static plane_t plane = {0.0, 0.0, -1.0, 0.0};
d1112 1
a1112 1
			dsp_pl[ -hitp->hit_surfno ] );
d1114 1
a1114 1
		switch (hitp->hit_surfno) {
a1212 1
	rt_free( (char *)dsp->cell_min, "min/max map" );
a1243 1
	int half_step;
d1350 1
a1350 1
	if( (half_step = step/2) < 1 )  half_step = 1;
d1438 2
a1439 2
#define IMPORT_FAIL(s) \
	bu_log("rt_ebm_import(%d) '%s' %s\n", __LINE__, dsp_ip->dsp_file, s); \
@


1.8
log
@checkpoint
@
text
@d38 1
a38 1
static char RCSdsp[] = "@@(#)$Header: /m/cad/librt/RCS/g_dsp.c,v 1.7 1997/06/06 04:43:06 butler Exp butler $ (BRL)";
d738 1
a738 1
		isect_ray_triangles(isect, grid_cell)
@


1.7
log
@checkpoint
@
text
@d38 1
a38 1
static char RCSdsp[] = "@@(#)$Header: /m/cad/librt/RCS/g_dsp.c,v 1.6 1997/06/04 23:07:04 butler Exp $ (BRL)";
d75 6
a80 1
/* per-solid ray tracing form of solid, including precomputed terms */
d98 3
a100 1
/* per-ray ray tracing information */
d102 1
a102 1
	struct dsp_specific	*dsp;	/* MUST BE FIRST */
d116 3
d334 8
a341 8
	BBOX_PT(0,		  0,		    0);
	BBOX_PT(dsp_ip->dsp_xcnt, 0,		    0);
	BBOX_PT(dsp_ip->dsp_xcnt, dsp_ip->dsp_ycnt, 0);
	BBOX_PT(0,		  dsp_ip->dsp_ycnt, 0);
	BBOX_PT(0,		  0,		    dsp_max);
	BBOX_PT(dsp_ip->dsp_xcnt, 0,		    dsp_max);
	BBOX_PT(dsp_ip->dsp_xcnt, dsp_ip->dsp_ycnt, dsp_max);
	BBOX_PT(0,		  dsp_ip->dsp_ycnt, dsp_max);
d364 131
d507 17
a523 1
		if (isect->NdotDbits & (1<<i)) continue;
d526 7
a532 1

d537 4
d546 4
d552 4
d565 18
a586 2
	register struct seg *segp;
	int inside = 0;	/* flag:  We're inside the solid */
d595 1
d601 8
d610 8
d619 1
a619 2

		inside = 1;
d621 6
a626 4
		RT_GET_SEG( segp, isect->ap->a_resource );
		segp->seg_stp = isect->stp;
		segp->seg_in.hit_dist = isect->bbox.in_dist;
		segp->seg_in.hit_surfno = -isect->bbox.in_surf;
d633 2
a634 2
			 *	   _/  \__   /\     /
			 *	_ |       \_/  \  / ray
d642 6
a647 3
			segp->seg_out.hit_dist = isect->bbox.out_dist;
			segp->seg_out.hit_surfno = -isect->bbox.out_surf;
			BU_LIST_INSERT( &isect->seglist, &(segp->l) );
d650 3
a656 6
	/* compute BBox entry point and starting grid cell */
	VJOIN1(curr_pt, isect->r.r_pt, isect->bbox.in_dist, isect->r.r_dir);
	VMOVE(grid_cell, curr_pt);	/* int/float conversion */

	/* compute BBox exit point */
	VJOIN1(out_pt, isect->r.r_pt, isect->bbox.out_dist, isect->r.r_dir);
d658 3
a660 21

	if (isect->r.r_dir[X] < 0.0) {
		outX = out_pt[X];
		stepX = -1;

		/* dist from start of cell to get X cell change */
		tDX = -1 / isect->r.r_dir[X];

		/* dist from current point to get first X cell change */
		tX = grid_cell[X] - curr_pt[X] / isect->r.r_dir[X];
	} else if (isect->r.r_dir[X] > 0.0) {
		outX = out_pt[X] + 1;
		stepX = 1;

		/* dist from start of cell to get X cell change */
		tDX = 1 / isect->r.r_dir[X];

		/* dist from current point to get first X cell change */
		tX = (grid_cell[X]+1) - curr_pt[X] / isect->r.r_dir[X];
	} else {
		tX = MAX_FASTF;
d663 9
a671 3
	if (isect->r.r_dir[Y] < 0.0) {
		outY = out_pt[Y];
		stepY = -1;
d673 2
a674 2
		/* dist from start of cell to get Y cell change */
		tDY = -1 / isect->r.r_dir[Y];
a675 5
		/* dist from curr pt to get Y cell change */
		tY = grid_cell[Y] - curr_pt[Y] / isect->r.r_dir[Y];
	} else if (isect->r.r_dir[Y] > 0.0) {
		outY = out_pt[Y] + 1;
		stepY = 1;
d677 15
a691 8
		/* dist from start of cell to get Y cell change */
		tDY = 1 / isect->r.r_dir[Y];

		/* dist from curr pt to get Y cell change */
		tY = (grid_cell[Y]+1)  - curr_pt[Y] / isect->r.r_dir[Y];
	} else {
		tY = MAX_FASTF;
	}
a692 10
	
	VSCALE(pDX, isect->r.r_dir, tDX);
	VSCALE(pDY, isect->r.r_dir, tDY);

	rising = (isect->r.r_dir[Z] > 0.0);
#if 0
	VJOIN1(next_Xpt, curr_pt, tX, isect->r.r_dir);
	VJOIN1(next_Ypt, curr_pt, tY, isect->r.r_dir);

#define CELL_MAX
d694 7
a700 1
	dsp(x,y) > dsp(x+1,y) ?
d702 1
a702 8

	do {
		if (tX < ty) {
			if (
( rising && curr_pt[Z] <= cell_max(cell) && next_Xpt[Z] >= cell_min(cell)) ||
(!rising && curr_pt[Z] >= cell_min(cell) && next_Xpt[Z] <= cell_max(cell))
			) {
				isect_ray_triangles();
a703 58
			cell[X] += stepX;
			tX += tDX;
			VMOVE(curr_pt, next_Xpt);
			VADD2(next_Xpt, next_Xpt, pDX);
		} else {
			if (
( rising && curr_pt[Z] <= cell_max(cell) && next_Ypt[Z] >= cell_min(cell)) ||
(!rising && curr_pt[Z] >= cell_min(cell) && next_Ypt[Z] <= cell_max(cell))
			) {
				isect_ray_triangles();
			}
			cell[Y] += stepY;
			tY += tDY;
			VMOVE(curr_pt, next_pt);
			VADD2(next_Ypt, next_Ypt, pDY);
		}
	} while (cell[X] != outX && cell[Y] != outY);









































d705 2
a706 20




	dist = isect->bbox.in_dist ; 
	VJOIN1(in_pt, isect->r.r_pt, dist, isect->r.r_dir);
	VMOVE(cell, in_pt);	/* int/float conversion */

	while (dist < isect->bbox.out_dist) { 


		d[0] = cell[X];
		d[1] = cell[X]+1;
		d[2] = cell[Y];
		d[3] = cell[Y]+1;
		d[4] = 0.0;
		d[5] = max_dsp(cell);

		if (isect_cell_bb(isect, d, &bbi)) {
			/* hit cell */
a709 3
		next_step:
		/* update dist */
		dist += bbi->out_dist;
d711 38
a748 12
		switch (bbi->out_surf) {
		case XMIN: cell[X] -= 1;
			break;
		case XMAX: cell[X] += 1;
			break;
		case YMIN: cell[Y] -= 1;
			break;
		case YMAX: cell[Y] += 1;
			break;
		case ZMIN: /* Done */
		case ZMAX: dist = isect->bbox.out_dist;
			break;
d750 3
a752 2

	}
d754 1
d756 2
a757 1
----------------------------------------------------------------------
d759 3
a761 12
	{
		point_t	in_pt;
		int cell[3];
		double d[6];
		strucct bbox_isect bbi;

		VJOIN1(in_pt, rp->r_pt, dist[0], rp->r_dir);

		VMOVE(cell, in_pt);	/* int/float conversion */

		do {	
		} while ();
a762 17
----------------------------------------------------------------------

	if we don't hit the cell bounding box
		if "inside"
			close out a hit partition
		go to next cell
	
	The "base" is the box underneath the lowest height in the cell
	if we pass through the base without hitting the top
		if "inside"
			record new exit
		else
			record entrance/exit
			mark us as "inside"
		go to next cell
	
#endif
d765 1
a766 1
}
a772 104
 *  Intersect the ray with the bounding box of the dsp solid.
 *  We also pre-compute some per-ray things that will be useful later.
 */
static int
isect_ray_bbox(isect)
register struct isect_stuff *isect;
{
	register double NdotD;
	double dist;
	register int i;

	isect->NdotDbits = 0;
	isect->bbox.in_dist = - (isect->bbox.out_dist = MAX_FASTF);
	isect->bbox.in_surf = isect->bbox.out_surf = -1;
	
	/* intersect the ray with the bounding box */
	for (i=0 ; i < BBOX_PLANES ; i++) {

		NdotD = VDOT(dsp_pl[i], isect->r.r_dir);

		/* if N/ray vectors are perp, ray misses plane */
		if (BN_VECT_ARE_PERP(NdotD, isect->tol)) {
			isect->NdotDbits |= 1 << i;
			continue;
		}

		isect->NdotD[i] = NdotD;
		isect->recipNdotD[i] = 1.0 / NdotD;
		isect->NdotPt[i] = VDOT(dsp_pl[i], isect->r.r_pt);

		/* ray hits plane, compute distance along ray to plane */
		dist = - ( (isect->NdotPt[i] - isect->dsp->dsp_pl_dist[i]) *
			 isect->recipNdotD[i]);

		if (rt_g.debug & DEBUG_HF)
			bu_log("surf[%d](%g %g %g %g) dot:%g dist:%g\n",
				i, V3ARGS(dsp_pl[i]),
				isect->dsp->dsp_pl_dist[i],
				NdotD, dist);

		if ( i > 5) /* dsp_min elevation not valid bbox limit */
			continue;

		if (NdotD < 0.0) {
			/* entering */
			if (dist > isect->bbox.in_dist) {
				isect->bbox.in_dist = dist;
				isect->bbox.in_surf = i;
			}
		} else { /*  (NdotD > 0.0) */
			/* leaving */
			if (dist < isect->bbox.out_dist) {
				isect->bbox.out_dist = dist;
				isect->bbox.out_surf = i;
			}
		}
	}


	if (rt_g.debug & DEBUG_HF) {
		bu_log("solid rpp in  surf[%d] dist:%g\n",
			isect->bbox.in_surf, isect->bbox.in_dist);
		bu_log("solid rpp out surf[%d] dist:%g\n",
			isect->bbox.out_surf, isect->bbox.out_dist);
	}
	/* validate */


	if (isect->bbox.in_dist >= isect->bbox.out_dist ||
	    isect->bbox.out_dist >= MAX_FASTF ) 
		return 0; /* MISS */

	/* copmute "minbox" the bounding box of the rpp under the lowest
	 * displacement height
	 */

	isect->minbox.in_dist = isect->bbox.in_dist;
	isect->minbox.in_surf = isect->bbox.in_surf;
	isect->minbox.out_dist = isect->bbox.out_dist;
	isect->minbox.out_surf = isect->bbox.out_surf;

	if (NdotD < 0.0) {
		/* entering */
		if (dist > isect->bbox.in_dist) {
			isect->minbox.in_dist = dist;
			isect->minbox.in_surf = 6;
		}
	} else { /*  (NdotD > 0.0) */
		/* leaving */
		if (dist < isect->bbox.out_dist) {
			isect->minbox.out_dist = dist;
			isect->minbox.out_surf = 6;
		}
	}

	if (rt_g.debug & DEBUG_HF) {
		bu_log("solid minbox rpp in  surf[%d] dist:%g\n",
			isect->minbox.in_surf, isect->minbox.in_dist);
		bu_log("solid minbox rpp out surf[%d] dist:%g\n",
			isect->minbox.out_surf, isect->minbox.out_dist);
	}

	return 1;
}/*
d921 24
a944 2
	MAT4X3VEC( N, dsp->dsp_i.dsp_stom, 
		dsp_pl[ hitp->hit_surfno ] );
@


1.6
log
@checkpoint
@
text
@d12 1
a12 1
 *		0	XMIN
d14 1
a14 1
 *		2	YMIN
d16 1
a16 1
 *		4	ZMIN
d18 1
a18 1
 *		6	DSP_MIN
d38 1
a38 1
static char RCSdsp[] = "@@(#)$Header: /m/cad/librt/RCS/g_dsp.c,v 1.5 1997/05/30 05:11:46 butler Exp butler $ (BRL)";
d55 7
d63 11
d77 3
a79 1
	struct rt_dsp_internal dsp_i;
d81 2
d85 8
d95 1
a100 1
	struct dsp_specific	*dsp;
d102 1
a102 1
	char	NdotDbits;	/* bit field of non-perpendicular faces */
d107 2
a108 5
	double  minbox_dist[2];
	int  minbox_surf[2];

	double	bbox_dist[2];	/* in/out distances for bounding box */
	int	bbox_surf[2];	/* in/out surfaces for bounding box */
d115 10
a124 10
static CONST plane_t	dsp_pl[BBOX_PLANES] = {
	{-1.0, 0.0, 0.0, 0.0},
	{ 1.0, 0.0, 0.0, 0.0},

	{0.0, -1.0, 0.0, 0.0},
	{0.0,  1.0, 0.0, 0.0},

	{0.0, 0.0, -1.0, 0.0},
	{0.0, 0.0,  1.0, 0.0},
	{0.0, 0.0,  1.0, 0.0},
a127 5
/* access to the array */
#define DSP(_dsp,_x,_y) \
	(((unsigned short *)(_dsp->dsp_mp->buf))[ \
				(_y) * _dsp->dsp_xcnt + (_x) \
				])
d229 4
a232 1
	register unsigned short t, dsp_min, dsp_max;
d236 2
a246 1
	dsp->dsp_i = *dsp_ip; /* struct copy */
d248 13
a261 1
	/* find min/max values in displacement map */
d264 38
a301 5
	for (y=0 ; y < dsp_ip->dsp_ycnt ; y++) {
		for (x=0 ; x < dsp_ip->dsp_xcnt ; x++) {
			t = DSP(dsp_ip, x, y);
			if ( t > dsp_max ) dsp_max = t;
			if ( t < dsp_min ) dsp_min = t;
d308 8
a315 7
	dsp->dsp_pl_dist[0] = 0.0;
	dsp->dsp_pl_dist[1] = (fastf_t)dsp_ip->dsp_xcnt;
	dsp->dsp_pl_dist[2] = 0.0;
	dsp->dsp_pl_dist[3] = (fastf_t)dsp_ip->dsp_ycnt;
	dsp->dsp_pl_dist[4] = 0.0;
	dsp->dsp_pl_dist[5] = (fastf_t)dsp_max;
	dsp->dsp_pl_dist[6] = (fastf_t)dsp_min;
a334 1

d354 35
d390 1
a390 1
void
d395 14
d410 1
a410 16
	if (isect->minbox_surf[0] < 5 && isect->minbox_surf[1] < 5 ) {
		/* we actually hit and exit the dsp BELOW the min value
		 *
		 *		     ray origin
		 *	dsp	    o
		 *    /\    /\     /
		 *   /	\/\/  \_  / ray
		 *  |		|/
		 *  |		*in point
		 *  |	       /|
		 *  |	      /	|
		 *  |	     /	|
		 *  +-------*---+
		 *         / out point
		 *        /
		 */
d412 1
d416 24
a439 2
		segp->seg_in.hit_dist = isect->bbox_dist[0];
		segp->seg_in.hit_surfno = isect->bbox_surf[0];
a440 3
		segp->seg_out.hit_dist = isect->bbox_dist[1];
		segp->seg_out.hit_surfno = isect->bbox_surf[1];
		BU_LIST_INSERT( &isect->seglist, &(segp->l) );
d442 29
a470 1
		return;
d472 20
d494 50
d547 28
a574 1
#if 0
a575 2
	point_t	in_pt;
	int cell[3];
a576 2
	/* 
	VJOIN1(in_pt, rp->r_pt, dist[0], rp->r_dir);
d579 2
d583 35
a617 1
	while (cell[X] 
d619 1
d621 5
a625 1
#define	CELL_MINMAX(min, max, cell) {
d627 3
a629 1
}
d631 4
d650 1
a651 1
	
d654 1
a655 1
#endif
a658 1
}
d660 5
a664 2

int
d666 1
a666 1
struct isect_stuff *isect;
d670 5
a674 3
	int i;
	double *dt = isect->bbox_dist;
	int *surf = isect->bbox_surf;
d682 4
a685 1
		if (BN_VECT_ARE_PERP(NdotD, isect->tol)) continue;
a686 1
		isect->NdotDbits |= 1 << i;
a688 1

d706 3
a708 3
			if (dist > dt[0]) {
				dt[0] = dist;
				surf[0] = i;
d712 3
a714 3
			if (dist < dt[1]) {
				dt[1] = dist;
				surf[1] = i;
d722 1
a722 1
			isect->bbox_surf[0], dt[0]);
d724 1
a724 1
			isect->bbox_surf[1], dt[1]);
d729 2
a730 2
	if (dt[0] >= dt[1] || isect->bbox_surf[0] == -1 || isect->bbox_surf[1] == -1 ||
	    dt[1] >= INFINITY)
d737 4
a740 4
	isect->minbox_dist[0] = isect->bbox_dist[0];
	isect->minbox_surf[0] = isect->bbox_surf[0];
	isect->minbox_dist[1] = isect->bbox_dist[1];
	isect->minbox_surf[1] = isect->bbox_surf[1];
d744 3
a746 3
		if (dist > isect->bbox_dist[0]) {
			isect->minbox_dist[0] = dist;
			isect->minbox_surf[0] = 6;
d750 3
a752 3
		if (dist < isect->bbox_dist[1]) {
			isect->minbox_dist[1] = dist;
			isect->minbox_surf[1] = 6;
d758 1
a758 1
			isect->minbox_surf[0], isect->minbox_dist[0]);
d760 1
a760 1
			isect->minbox_surf[1], isect->minbox_dist[1]);
a817 4
	isect.NdotDbits = 0;
	isect.bbox_dist[0] = - (isect.bbox_dist[1] = MAX_FASTF);
	isect.bbox_surf[0] = 
	isect.bbox_surf[1] = -1;
d994 1
@


1.5
log
@checkpoint.  Now raytraces as an RPP.
@
text
@a7 1
 *	Design disk record
a8 2
 *	define rt_dsp_internal --- parameters for solid
 *	define dsp_specific --- raytracing form, possibly w/precomuted terms
d10 9
a18 1
 *	code import/export/describe/print/ifree/plot/prep/shot/curve/uv/tess
a19 15
 *	edit db.h add solidrec s_type define
 *	edit rtgeom.h to add rt_dsp_internal
 *	edit table.c:
 *		RT_DECLARE_INTERFACE()
 *		struct rt_functab entry
 *		rt_id_solid()
 *	edit raytrace.h to make ID_DSP, increment ID_MAXIMUM
 *	edit Cakefile to add g_dsp.c to compile
 *
 *	Then:
 *	go to /cad/libwdb and create mk_dsp() routine
 *	go to /cad/mged and create the edit support
 *
 *
 *
d38 1
a38 1
static char RCSdsp[] = "@@(#)$Header: /m/cad/librt/RCS/g_dsp.c,v 1.4 1997/05/22 09:28:06 butler Exp butler $ (BRL)";
d54 2
a55 1
#define BBOX_PLANES	6
d57 1
a57 1
/* ray tracing form of solid, including precomputed terms */
d60 16
a75 3
	unsigned short dsp_min; 
	unsigned short dsp_max; 
	plane_t		dsp_planes[BBOX_PLANES];
d77 5
a81 1
	mat_t		dsp_mtos;
d84 3
d97 1
d130 52
a232 2
	dsp->dsp_min = dsp_min;
	dsp->dsp_max = dsp_max;
d237 7
a243 5
	/* set the plane equations (in solid coord space) */
	memcpy(dsp->dsp_planes, dsp_pl, sizeof(dsp_pl));
	dsp->dsp_planes[1][H] = (fastf_t)dsp_ip->dsp_xcnt;
	dsp->dsp_planes[3][H] = (fastf_t)dsp_ip->dsp_ycnt;
	dsp->dsp_planes[5][H] = (fastf_t)dsp_max;
d245 1
a245 2
	
	/* compute bounting box and spere */
d282 5
a286 4
static void
dsp_print(vls, dsp_ip)
struct bu_vls *vls;
struct rt_dsp_internal *dsp_ip;
d288 40
a327 2
	point_t pt, v;
	RT_DSP_CK_MAGIC(dsp_ip);
d329 2
a330 3
	bu_vls_init( vls );
	bu_vls_printf( vls, "Displacement Map\n  file='%s' xc=%d yc=%d\n",
		dsp_ip->dsp_file, dsp_ip->dsp_xcnt, dsp_ip->dsp_ycnt);
a331 3
	VSETALL(pt, 0.0);
	MAT4X3PNT(v, dsp_ip->dsp_stom, pt);
	bu_vls_printf( vls, "  V=(%g %g %g)\n", V3ARGS(pt));
d333 1
a333 3
	bu_vls_printf( vls, "  stom=\n");
	bu_vls_printf( vls, "  %8.3f %8.3f %8.3f %8.3f\n",
		V4ARGS(dsp_ip->dsp_stom) );
d335 1
a335 2
	bu_vls_printf( vls, "  %8.3f %8.3f %8.3f %8.3f\n",
		V4ARGS( &dsp_ip->dsp_stom[4]) );
a336 2
	bu_vls_printf( vls, "  %8.3f %8.3f %8.3f %8.3f\n",
		V4ARGS( &dsp_ip->dsp_stom[8]) );
d338 1
a338 2
	bu_vls_printf( vls, "  %8.3f %8.3f %8.3f %8.3f\n",
		V4ARGS( &dsp_ip->dsp_stom[12]) );
d342 19
a360 10
/*
 *			R T _ D S P _ P R I N T
 */
void
rt_dsp_print( stp )
register CONST struct soltab *stp;
{
	register CONST struct dsp_specific *dsp =
		(struct dsp_specific *)stp->st_specific;
	struct bu_vls vls;
d362 1
a362 1
	RT_DSP_CK_MAGIC(dsp);
a363 1
	dsp_print(&vls, &dsp->dsp_i);
a364 2
	bu_log("%s", bu_vls_addr( &vls));
	bu_vls_free( &vls );
a366 18
void
isect_ray_dsp(dist, surf, ap, stp, seglist)
double dist[2];
int surf[2];
struct application	*ap;
struct soltab		*stp;
struct bu_list		*seglist;
{
	register struct seg *segp;
	RT_GET_SEG( segp, ap->a_resource );
	segp->seg_stp = stp;
	segp->seg_in.hit_dist = dist[0];
	segp->seg_in.hit_surfno = surf[0];

	segp->seg_out.hit_dist = dist[1];
	segp->seg_out.hit_surfno = surf[1];
	BU_LIST_INSERT( seglist, &(segp->l) );
}
d370 2
a371 6
isect_ray_bbox(dt, surf, r, planes, tol)
fastf_t 	dt[2];
int		surf[2];
struct xray 	*r;
plane_t		planes[6];
struct bn_tol	*tol;
d376 2
a377 3
	
	surf[0] = surf[1] = -1;
	dt[0] = - (dt[1] = MAX_FASTF);
d382 1
a382 1
		NdotD = VDOT(planes[i], r->r_dir);
d385 7
a391 1
		if (BN_VECT_ARE_PERP(NdotD, tol)) continue;
d394 2
a395 1
		dist = - ( (VDOT(planes[i], r->r_pt) - planes[i][H]) / NdotD);
d399 3
a401 1
				i, V4ARGS(planes[i]), NdotD, dist);
d403 3
d421 1
d423 4
a426 2
		bu_log("solid rpp in  surf[%d] dist:%g\n", surf[0], dt[0]);
		bu_log("solid rpp out surf[%d] dist:%g\n", surf[1], dt[1]);
d429 3
a431 1
	if (dt[0] >= dt[1] || surf[0] == -1 || surf[1] == -1 ||
d435 22
a456 1
	
d458 6
a486 2
	CONST struct rt_tol	*tol = &ap->a_rt_i->rti_tol;
	struct xray r;
a487 2
	double	dist[2];
	int	surf[2];
d489 1
a489 1
	struct bu_list	seglist;
d501 1
a501 1
	MAT4X3PNT(r.r_pt, dsp->dsp_i.dsp_mtos, rp->r_pt);
d503 2
a504 2
	VMOVE(r.r_dir, dir);
	VUNITIZE(r.r_dir);
d509 1
a509 1
			V3ARGS(r.r_pt),
d512 1
a512 1
			V3ARGS(r.r_dir));
d516 9
d526 1
a526 1
	if ( isect_ray_bbox(dist, surf, &r, dsp->dsp_planes, tol) == 0)
d531 2
a532 3
	BU_LIST_INIT(&seglist);

	isect_ray_dsp(dist, surf, ap, stp, &seglist);
d534 2
a535 1
	if (BU_LIST_IS_EMPTY(&seglist))
d540 1
a540 1
	for (BU_LIST_FOR(segp, seg, &seglist)) {
d548 1
a548 1
		VSCALE(dir, r.r_dir, segp->seg_in.hit_dist);
d552 1
a552 1
		VSCALE(dir, r.r_dir, segp->seg_out.hit_dist);
d574 1
a574 1
	BU_LIST_APPEND_LIST( &(seghead->l), &seglist);
d620 1
a620 1
		dsp->dsp_planes[ hitp->hit_surfno ] );
d630 1
a630 1
			V3ARGS(dsp->dsp_planes[ hitp->hit_surfno ]),
@


1.4
log
@checkpoint
@
text
@d28 7
d36 1
d48 1
a48 1
static char RCSdsp[] = "@@(#)$Header: /m/cad/librt/RCS/g_dsp.c,v 1.3 1997/05/22 02:49:51 butler Exp butler $ (BRL)";
d64 2
d69 17
d88 1
d90 4
a93 1
#define DSP(_dsp,_x,_y) (((short *)(_dsp->dsp_mp->buf))[(_y)*_dsp->dsp_xcnt+(_x)])
d100 2
a101 2
	{"%d",	1, "xc", DSP_O(dsp_xcnt), FUNC_NULL },
	{"%d",	1, "yc", DSP_O(dsp_ycnt), FUNC_NULL },
d111 2
a112 2
	{"%d",	1, "xc", DSP_O(dsp_xcnt), FUNC_NULL },
	{"%d",	1, "yc", DSP_O(dsp_ycnt), FUNC_NULL },
d142 5
d148 1
a148 1
	if (rt_g.debug & DEBUG_SOLIDS)
d154 94
d259 5
d265 2
a266 2
	if (rt_g.debug & DEBUG_SOLIDS)
		bu_log("rt_dsp_print()\n");
d269 75
d345 3
a347 1
/*
d369 74
d444 7
a450 2
	if (rt_g.debug & DEBUG_SOLIDS)
		bu_log("rt_dsp_shot()\n");
d452 1
a452 1
	return(0);			/* MISS */
d470 1
a470 1
	if (rt_g.debug & DEBUG_SOLIDS)
d489 1
d491 1
a491 1
	if (rt_g.debug & DEBUG_SOLIDS)
d495 13
d524 1
a524 1
	if (rt_g.debug & DEBUG_SOLIDS)
d551 1
a551 1
	if (rt_g.debug & DEBUG_SOLIDS)
d553 5
d570 1
a570 1
	if (rt_g.debug & DEBUG_SOLIDS)
d585 1
a585 1
	if (rt_g.debug & DEBUG_SOLIDS)
d601 2
a602 1
	LOCAL struct rt_dsp_internal	*dsp_ip;
d608 3
a610 3
	int goal;
	int xlim;
	int ylim;
d612 1
a612 1
	if (rt_g.debug & DEBUG_SOLIDS)
a615 1
	dsp_ip = (struct rt_dsp_internal *)ip->idb_ptr;
d618 1
d632 1
a632 1
	s_pt[X] = dsp_ip->dsp_xcnt-1;
d635 1
a635 1
	s_pt[Y] = dsp_ip->dsp_ycnt-1;
d646 1
a646 1
	s_pt[Z] = DSP(dsp_ip,0,0);
d649 1
a649 1
	VSET(s_pt, dsp_ip->dsp_xcnt-1, 0.0, 0.0);
d651 1
a651 1
	s_pt[Z] = DSP(dsp_ip, dsp_ip->dsp_xcnt-1, 0);
d654 2
a655 1
	VSET(s_pt, dsp_ip->dsp_xcnt-1, dsp_ip->dsp_ycnt-1, 0.0);
d657 1
a657 1
	s_pt[Z] = DSP(dsp_ip, dsp_ip->dsp_xcnt-1, dsp_ip->dsp_ycnt-1);
d660 1
a660 1
	VSET(s_pt, 0.0, dsp_ip->dsp_ycnt-1, 0.0);
d662 1
a662 1
	s_pt[Z] = DSP(dsp_ip, 0, dsp_ip->dsp_ycnt-1);
d671 1
a671 1
	for (y=0 ; y < dsp_ip->dsp_ycnt ; y += dsp_ip->dsp_ycnt-1 ) {
d683 1
a683 1
	for (x=0 ; x < dsp_ip->dsp_xcnt ; x += dsp_ip->dsp_xcnt-1 ) {
d701 1
a701 1
		goal = 10000;
d703 1
a703 1
		goal -= 4 + 2 * (dsp_ip->dsp_xcnt+dsp_ip->dsp_ycnt);
d709 1
a709 1
			sqrt( 2*(dsp_ip->dsp_xcnt-1)*(dsp_ip->dsp_ycnt-1) /
d715 6
a720 2
	xlim = dsp_ip->dsp_xcnt - half_step;
	ylim = dsp_ip->dsp_ycnt - half_step;
d722 1
a722 1
	for (y=step ; y < ylim ; y += step ) {
d726 1
a726 1
		for (x=step ; x < xlim ; x+=step ) {
d732 2
a733 3
		x = dsp_ip->dsp_xcnt-1;
		s_pt[X] = x;
		s_pt[Z] = DSP(dsp_ip, x, y);
d738 1
a738 1
	for (x=step ; x < xlim ; x += step ) {
d742 1
a742 1
		for (y=step ; y < ylim ; y+=step) {
d748 2
a749 3
		y = dsp_ip->dsp_ycnt-1;
		s_pt[Y] = y;
		s_pt[Z] = DSP(dsp_ip, x, y);
d775 1
a775 1
	if (rt_g.debug & DEBUG_SOLIDS)
d812 1
a812 1
	if (rt_g.debug & DEBUG_SOLIDS)
d865 1
a865 1
	if (rt_g.debug & DEBUG_SOLIDS) {
d912 1
a912 1
	if (rt_g.debug & DEBUG_SOLIDS)	
d945 1
a945 1
	if (rt_g.debug & DEBUG_SOLIDS)
d950 1
a950 19
	bu_vls_init( &vls );

	bu_vls_printf( &vls, "Displacement Map\n  file='%s' xc=%d yc=%d\n",
		dsp_ip->dsp_file, dsp_ip->dsp_xcnt, dsp_ip->dsp_ycnt);

	bu_vls_printf( &vls, "  stom=\n");
	bu_vls_printf( &vls, "  %8.3f %8.3f %8.3f %8.3f\n",
		V4ARGS(dsp_ip->dsp_stom) );

	bu_vls_printf( &vls, "  %8.3f %8.3f %8.3f %8.3f\n",
		V4ARGS( &dsp_ip->dsp_stom[4]) );

	bu_vls_printf( &vls, "  %8.3f %8.3f %8.3f %8.3f\n",
		V4ARGS( &dsp_ip->dsp_stom[8]) );

	bu_vls_printf( &vls, "  %8.3f %8.3f %8.3f %8.3f\n",
		V4ARGS( &dsp_ip->dsp_stom[12]) );


a951 4




d976 1
a976 1
	if (rt_g.debug & DEBUG_SOLIDS)
@


1.3
log
@export prototyped
@
text
@d40 1
a40 1
static char RCSdsp[] = "@@(#)$Header: /m/cad/librt/RCS/g_dsp.c,v 1.2 1997/05/22 02:30:43 butler Exp butler $ (BRL)";
d61 3
d67 12
a78 1
static struct bu_structparse rt_dsp_parse[] = {
d82 1
a82 3
	{"%d",	1, "xs", DSP_O(dsp_xs), FUNC_NULL },
	{"%d",	1, "ys", DSP_O(dsp_ys), FUNC_NULL },
	{"%d",	1, "ys", DSP_O(dsp_zs), FUNC_NULL },
d112 3
d129 4
d158 3
d179 3
d199 3
d219 3
d245 3
d260 6
d275 3
d292 11
d308 134
a441 1
	return(-1);
d461 3
d489 1
a489 1
	bu_log("rt_ebm_import() '%s' %s\n", dsp_ip->dsp_file, s); \
a494 1

d497 7
d516 3
a518 1
	dsp_ip->dsp_file[0] = '\0';
d521 1
d523 1
a523 1
	mat_idn(&dsp_ip->dsp_stom);
d530 1
a530 1
	bu_vls_free( &str );
d538 2
a539 2
	mat_copy(tmp, dsp_ip->dsp_mtos);
	mat_mul(dsp_ip->dsp_mtos, mat, dsp_ip->dsp_mtos);
d541 2
d551 4
d556 2
d577 1
d584 1
a584 1
	ep->ext_nbytes = sizeof(union record);
d596 5
d603 1
d605 1
a605 3
	bu_vls_init( &str );
	bu_vls_struct_print( &str, rt_dsp_parse, (char *)&dsp);
	strncpy( rec->ss.ss_args, bu_vls_addr(&str), DB_SS_LEN-1 );
d631 2
d638 12
a649 1
	rt_vls_strcat( str, "Displacement Map\n");
d651 3
a653 2
	bu_vls_printf( &vls, "  file='%s' xc=%d yc=%d\n",
		dsp_ip->dsp_file, dsp_ip->dsp_xcnt, dsp_ip->dsp_ycnt);
d656 4
d684 3
d690 6
d697 1
@


1.2
log
@checkpoint
@
text
@d40 1
a40 1
static char RCSdsp[] = "@@(#)$Header: /m/cad/librt/RCS/g_dsp.c,v 1.1 1997/05/22 02:09:07 butler Exp butler $ (BRL)";
a348 1
	
d366 1
d368 1
d380 2
a381 4
	rec->s.s_id = ID_SOLID;
#if 0
	rec->s.s_type = DSP;	/* GED primitive type from db.h */
#endif
d386 9
a396 9
	/* convert from local editing units to mm and export
	 * to database record format
	 *
	 * Warning: type conversion: double to float
	 */
#if 0
	VSCALE( &rec->s.s_values[0], dsp_ip->dsp_V, local2mm );
	rec->s.s_values[3] = dsp_ip->dsp_radius * local2mm;
#endif
@


1.1
log
@Initial revision
@
text
@d40 1
a40 1
static char RCSdsp[] = "@@(#)$Header: /m/cad/librt/RCS/g_dsp.c,v 11.1 1995/01/04 09:57:10 mike Rel4_4 butler $ (BRL)";
a54 12
#if 0
/* parameters for solid, internal representation
 * This goes in rtgeom.h
 */
/* parameters for solid, internal representation */
struct rt_dsp_internal {
	long	magic;
	vect_t	v;
};
#define RT_DSP_INTERNAL_MAGIC	0dsp
#define RT_DSP_CK_MAGIC(_p)	RT_CKMAG(_p,RT_DSP_INTERNAL_MAGIC,"rt_dsp_internal")
#endif
d58 14
a71 1
	vect_t	dsp_V;
d74 1
d296 1
d299 1
a299 1
	bu_log("rt_ebm_import() '%s' %s\n", dsp_ip->file, s); \
d309 1
a309 1
	if( rp->u_id != DSID_STRSOL )  {
d326 1
a326 1
	bu_vls_strcpy(, &str, rp->ss.ss_args );
d334 1
a334 1
	if (dsp_ip->xcnt == 0 || dsp_ip->ycnt == 0) {
d343 1
a343 1
	if( !(dsp_ip->mp = rt_open_mapped_file( dsp_ip->file, "dsp" )) )  {
d346 1
a346 1
	if (dsp_ip->mp->buflen != dsp_ip->xcnt*dsp_ip->ycnt*2) {
d380 1
d382 1
a382 1

d394 1
d397 1
a397 1

d417 1
a417 1
	char	buf[256];
d419 2
d422 2
a423 1
	rt_vls_strcat( str, "truncated general dsp (DSP)\n");
d425 9
d439 1
@
