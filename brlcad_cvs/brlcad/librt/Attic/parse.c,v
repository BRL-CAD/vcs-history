head	11.14;
access;
symbols
	ansi-20040405-merged:11.10.2.3
	postmerge-20040405-ansi:11.12
	premerge-20040404-ansi:11.11
	postmerge-autoconf:11.11
	autoconf-freeze:11.10.10.2
	premerge-autoconf:11.11
	ansi-20040316-freeze:11.10.2.2
	postmerge-20040315-windows:11.11
	premerge-20040315-windows:11.11
	windows-20040315-freeze:11.10.4.1
	autoconf-20031203:11.10
	autoconf-20031202:11.10
	autoconf-branch:11.10.0.10
	phong-branch:11.10.0.8
	photonmap-branch:11.10.0.6
	rel-6-1-DP:11.10
	windows-branch:11.10.0.4
	rel-6-0-2:11.8
	ansi-branch:11.10.0.2
	rel-6-0-1-branch:11.8.0.2
	hartley-6-0-post:11.9
	hartley-6-0-pre:11.8
	rel-6-0-1:11.8
	rel-6-0:11.8
	rel-5-4:11.6
	offsite-5-3-pre:11.7
	rel-5-3:11.6
	rel-5-2:11.6
	rel-5-1-branch:11.6.0.2
	rel-5-1:11.6
	rel-5-0:11.6
	rel-5-0-beta:11.6
	rel-4-5:11.6
	ctj-4-5-post:11.6
	ctj-4-5-pre:11.6
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1;
locks; strict;
comment	@ * @;


11.14
date	2004.05.21.18.07.34;	author morrison;	state dead;
branches;
next	11.13;

11.13
date	2004.05.10.15.30.47;	author erikg;	state Exp;
branches;
next	11.12;

11.12
date	2004.04.05.08.48.58;	author morrison;	state Exp;
branches;
next	11.11;

11.11
date	2004.02.02.17.39.28;	author morrison;	state Exp;
branches;
next	11.10;

11.10
date	2002.08.20.17.08.09;	author jra;	state Exp;
branches
	11.10.2.1
	11.10.4.1
	11.10.10.1;
next	11.9;

11.9
date	2002.08.15.20.55.20;	author hartley;	state Exp;
branches;
next	11.8;

11.8
date	2001.04.05.19.35.36;	author morrison;	state Exp;
branches;
next	11.7;

11.7
date	2000.07.10.23.01.47;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	96.08.29.22.44.43;	author butler;	state Exp;
branches;
next	11.5;

11.5
date	96.08.27.03.43.38;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	96.07.12.12.10.21;	author jra;	state Exp;
branches;
next	11.3;

11.3
date	95.06.30.15.54.02;	author gdurf;	state Exp;
branches;
next	11.2;

11.2
date	95.06.15.20.19.34;	author gdurf;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.58.21;	author mike;	state Rel4_4;
branches;
next	10.5;

10.5
date	94.11.04.05.50.04;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	94.10.17.10.16.28;	author jra;	state Exp;
branches;
next	10.3;

10.3
date	94.08.10.19.40.02;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	93.07.13.20.32.41;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.40.52;	author mike;	state Rel4_0;
branches;
next	9.15;

9.15
date	91.06.30.20.07.21;	author mike;	state Exp;
branches;
next	9.14;

9.14
date	91.06.29.23.30.35;	author mike;	state Exp;
branches;
next	9.13;

9.13
date	91.06.29.23.16.18;	author mike;	state Exp;
branches;
next	9.12;

9.12
date	91.06.14.05.49.36;	author mike;	state Exp;
branches;
next	9.11;

9.11
date	91.02.28.15.35.58;	author mike;	state Exp;
branches;
next	9.10;

9.10
date	91.02.17.19.59.47;	author mike;	state Exp;
branches;
next	9.9;

9.9
date	91.01.25.19.14.08;	author mike;	state Exp;
branches;
next	9.8;

9.8
date	91.01.12.07.25.34;	author mike;	state Exp;
branches;
next	9.7;

9.7
date	91.01.09.20.54.36;	author cjohnson;	state Exp;
branches;
next	9.6;

9.6
date	90.12.18.00.21.30;	author butler;	state Exp;
branches;
next	9.5;

9.5
date	90.12.14.21.33.37;	author butler;	state Exp;
branches;
next	9.4;

9.4
date	90.12.14.16.01.02;	author butler;	state Exp;
branches;
next	9.3;

9.3
date	90.12.10.20.38.24;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	90.12.10.03.33.19;	author butler;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.56.53;	author mike;	state Rel3_5;
branches;
next	1.7;

1.7
date	89.04.14.03.00.27;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	89.04.04.23.40.54;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	89.04.04.04.57.47;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	89.03.15.15.30.14;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	89.03.06.20.56.43;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	89.03.03.02.30.34;	author phil;	state Exp;
branches;
next	1.1;

1.1
date	88.12.27.13.39.02;	author mike;	state Exp;
branches;
next	;

11.10.2.1
date	2002.09.19.18.01.46;	author morrison;	state Exp;
branches;
next	11.10.2.2;

11.10.2.2
date	2003.02.11.03.23.44;	author morrison;	state Exp;
branches;
next	11.10.2.3;

11.10.2.3
date	2004.03.17.21.18.57;	author morrison;	state Exp;
branches;
next	;

11.10.4.1
date	2004.03.11.23.43.44;	author morrison;	state Exp;
branches;
next	;

11.10.10.1
date	2004.02.12.18.37.46;	author erikg;	state Exp;
branches;
next	11.10.10.2;

11.10.10.2
date	2004.03.15.14.07.28;	author erikg;	state Exp;
branches;
next	;


desc
@Subroutines for parsing arbitrary structures.
@


11.14
log
@moved to src/
@
text
@/*
 *			P A R S E . C
 *
 *  Routines to assign values to elements of arbitrary structures.
 *  The layout of a structure to be processed is described by
 *  a structure of type "structparse", giving element names, element
 *  formats, an offset from the beginning of the structure, and
 *  a pointer to an optional "hooked" function that is called whenever
 *  that structure element is changed.
 *
 *  Authors -
 *	Michael John Muuss
 *	Lee A. Butler
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1989-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSparse[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/parse.c,v 11.13 2004/05/10 15:30:47 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <ctype.h>
#include <math.h>
#ifdef USE_STRING_H
# include <string.h>
#else
# include <strings.h>
#endif

#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "bu.h"
#include "raytrace.h"



/*
 *			B U _ M A T P R I N T
 *
 *	XXX Should this be here, or could it be with the matrix support?
 *	pretty-print a matrix
 */
HIDDEN void
bu_matprint(const char *name, register const matp_t mat)
{
	int	delta = strlen(name)+2;

	/* indent the body of the matrix */
	bu_log_indent_delta(delta);

	bu_log(" %s=%.-12E %.-12E %.-12E %.-12E\n",
		name, mat[0], mat[1], mat[2], mat[3]);
					
	bu_log("%.-12E %.-12E %.-12E %.-12E\n",
		mat[4], mat[5], mat[6], mat[7]);

	bu_log("%.-12E %.-12E %.-12E %.-12E\n",
		mat[8], mat[9], mat[10], mat[11]);

	bu_log_indent_delta(-delta);

	bu_log("%.-12E %.-12E %.-12E %.-12E\n",
		mat[12], mat[13], mat[14], mat[15]);
}


/*
 *			B U _ S T R U C T P R I N T
 */
void
bu_structprint(const char *title, const struct bu_structparse *parsetab, const char *base)
          			       
                           	          /* structure description */
          			      	  /* base address of users structure */
{
	register const struct bu_structparse	*sdp;
	register char			*loc;
	register int			lastoff = -1;
	struct bu_vls vls;

	bu_vls_init( &vls );
	bu_log( "%s\n", title );
	if (parsetab == (struct bu_structparse *)NULL) {
		bu_log( "Null \"struct bu_structparse\" pointer\n");
		return;
	}
	for( sdp = parsetab; sdp->sp_name != (char *)0; sdp++ )  {

		/* Skip alternate keywords for same value */
		if( lastoff == sdp->sp_offset )
			continue;
		lastoff = sdp->sp_offset;

#if CRAY && !__STDC__
		loc = (char *)(base + ((int)sdp->sp_offset*sizeof(int)));
#else
		loc = (char *)(base + ((int)sdp->sp_offset));
#endif

		if (sdp->sp_fmt[0] == 'i' )  {
			bu_structprint( sdp->sp_name,
				(struct bu_structparse *)sdp->sp_count,
				base );
			continue;
		}

		if ( sdp->sp_fmt[0] != '%')  {
			bu_log("bu_structprint:  %s: unknown format '%s'\n",
				sdp->sp_name, sdp->sp_fmt );
			continue;
		}
#if 0
		bu_vls_trunc( &vls, 0 );
		bu_vls_item_print( &vls, sdp, base );
		bu_log( " %s=%s\n", sdp->sp_name, bu_vls_addr(&vls) );
#else
		switch( sdp->sp_fmt[1] )  {
		case 'c':
		case 's':
			if (sdp->sp_count < 1)
				break;
			if (sdp->sp_count == 1)
				bu_log( " %s='%c'\n", sdp->sp_name, *loc);
			else
				bu_log( " %s=\"%s\"\n", sdp->sp_name,
					(char *)loc );
			break;
		case 'S':
			{
				int delta = strlen(sdp->sp_name)+2;
				register struct bu_vls *vls =
					(struct bu_vls *)loc;

				bu_log_indent_delta(delta);
				bu_log(" %s=(vls_magic)%d (vls_offset)%d (vls_len)%d (vls_max)%d\n",
					sdp->sp_name, vls->vls_magic,
					vls->vls_offset,
					vls->vls_len, vls->vls_max);
				bu_log_indent_delta(-delta);
				bu_log("\"%s\"\n", vls->vls_str+vls->vls_offset);
			}
			break;
		case 'i':
			{	register int i = sdp->sp_count;
				register short *sp = (short *)loc;

				bu_log( " %s=%hd", sdp->sp_name, *sp++ );

				while (--i > 0) bu_log( ",%d", *sp++ );

				bu_log("\n");
			}
			break;
		case 'd':
			{	register int i = sdp->sp_count;
				register int *dp = (int *)loc;

				bu_log( " %s=%d", sdp->sp_name, *dp++ );

				while (--i > 0) bu_log( ",%d", *dp++ );

				bu_log("\n");
			}
			break;
		case 'f':
			{	register int i = sdp->sp_count;
				register double *dp = (double *)loc;

				if (sdp->sp_count == ELEMENTS_PER_MAT) {
					bu_matprint(sdp->sp_name, (matp_t)dp);
				} else if (sdp->sp_count <= ELEMENTS_PER_VECT){
					bu_log( " %s=%.25G", sdp->sp_name, *dp++ );

					while (--i > 0)
						bu_log( ",%.25G", *dp++ );

					bu_log("\n");
				}else  {
					int delta = strlen(sdp->sp_name)+2;

					bu_log_indent_delta(delta);

					bu_log( " %s=%.25G\n", sdp->sp_name, *dp++ );

					while (--i > 1)
						bu_log( "%.25G\n", *dp++ );

					bu_log_indent_delta(-delta);
					bu_log( "%.25G\n", *dp );
				}
			}
			break;
		case 'x':
			{	register int i = sdp->sp_count;
				register int *dp = (int *)loc;

				bu_log( " %s=%08x", sdp->sp_name, *dp++ );

				while (--i > 0) bu_log( ",%08x", *dp++ );

				bu_log("\n");
			}
			break;
		default:
			bu_log( " bu_structprint: Unknown format: %s=%s??\n",
				sdp->sp_name, sdp->sp_fmt );
			break;
		}
#endif
	}
	bu_vls_free(&vls);
}


/*
 *			B U _ P A R S E _ D O U B L E
 *
 *  Parse an array of one or more doubles.
 *  Return value: 0 when successful
 *               <0 upon failure
 */
HIDDEN int
bu_parse_double(const char *str, long int count, double *loc)
{
	long	i;
	int	dot_seen;
	const char	*numstart;
	double	tmp_double;
	char	buf[128];	
	int	len;

	for (i=0 ; i < count && *str ; ++i){
		numstart = str;

		/* skip sign */
		if (*str == '-' || *str == '+') str++;

		/* skip matissa */
		dot_seen = 0;
		for ( ; *str ; str++ ) {
			if (*str == '.' && !dot_seen) {
				dot_seen = 1;
				continue;
			}
			if (!isdigit(*str))
				break;
			
		}

		/* If no mantissa seen, then there is no float here */
		if (str == (numstart + dot_seen) )
			return -1;

		/* there was a mantissa, so we may have an exponent */
		if  (*str == 'E' || *str == 'e') {
			str++;

			/* skip exponent sign */
		    	if (*str == '+' || *str == '-') str++;

			while (isdigit(*str)) str++;
		}

		len = str - numstart;
		if( len > sizeof(buf)-1 )  len = sizeof(buf)-1;
		strncpy( buf, numstart, len );
		buf[len] = '\0';

		if( sscanf( buf, "%lf", &tmp_double ) != 1 )
			return -1;

		*loc++ = tmp_double;

		/* skip the separator */
		if (*str) str++;
	}
	return 0;
}

/*
 *			B U _ S T R U C T _ L O O K U P
 *
 *  Returns -
 *      -2      parse error
 *	-1	not found
 *	 0	entry found and processed
 */
HIDDEN int
bu_struct_lookup(register const struct bu_structparse *sdp, register const char *name, char *base, const char *value)
                                    	     	/* structure description */
                   			      	/* struct member name */
    					      	/* begining of structure */
          				       	/* string containing value */
{
	register char *loc;
	int i, retval = 0;

	for( ; sdp->sp_name != (char *)0; sdp++ )  {

		if( strcmp( sdp->sp_name, name ) != 0	/* no name match */
		    && sdp->sp_fmt[0] != 'i' )		/* no include desc */

		    continue;

		/* if we get this far, we've got a name match
		 * with a name in the structure description
		 */

#if CRAY && !__STDC__
		loc = (char *)(base + ((int)sdp->sp_offset*sizeof(int)));
#else
		loc = (char *)(base + ((int)sdp->sp_offset));
#endif

		if (sdp->sp_fmt[0] == 'i') {
			/* Indirect to another structure */
			if( bu_struct_lookup(
				(struct bu_structparse *)sdp->sp_count,
				name, base, value )
			    == 0 )
				return(0);	/* found */
			else
				continue;
		}
		if (sdp->sp_fmt[0] != '%') {
			bu_log("bu_struct_lookup(%s): unknown format '%s'\n",
				name, sdp->sp_fmt );
			return(-1);
		}

		switch( sdp->sp_fmt[1] )  {
		case 'c':
		case 's':
			{	register int i, j;

				/* copy the string, converting escaped
				 * double quotes to just double quotes
				 */
				for(i=j=0 ;
				    j < sdp->sp_count && value[i] != '\0' ;
				    loc[j++] = value[i++])
					if (value[i] == '\\' &&
					    value[i+1] == '"')
					    	++i;

				if (sdp->sp_count > 1)
					loc[sdp->sp_count-1] = '\0';
			}
			break;
		case 'S':
			{	struct bu_vls *vls = (struct bu_vls *)loc;
				bu_vls_init_if_uninit( vls );
				bu_vls_strcpy(vls, value);
			}
			break;
		case 'i':
			{	register short *ip = (short *)loc;
				register short tmpi;
				register const char *cp;
				for (i=0 ; i < sdp->sp_count && *value ; ++i){
					tmpi = atoi( value );

					cp = value;
					if (*cp && (*cp == '+' || *cp == '-'))
						cp++;

					while (*cp && isdigit(*cp) )
						cp++; 

					/* make sure we actually had an
					 * integer out there
					 */
					if (cp == value ||
					    (cp == value+1 &&
					    (*value == '+' || *value == '-'))){
					    retval = -2;
					    break;
					} else {
						*(ip++) = tmpi;
						value = cp;
					}
					/* skip the separator */
					if (*value) value++;
				}
			}
			break;
		case 'd':
			{	register int *ip = (int *)loc;
				register int tmpi;
				register char const *cp;
				/* Special case:  '=!' toggles a boolean */
				if( *value == '!' )  {
					*ip = *ip ? 0 : 1;
					value++;
					break;
				}
				/* Normal case: an integer */
				for (i=0 ; i < sdp->sp_count && *value ; ++i){
					tmpi = atoi( value );

					cp = value;
					if (*cp && (*cp == '+' || *cp == '-'))
						cp++;

					while (*cp && isdigit(*cp) )
						cp++; 

					/* make sure we actually had an
					 * integer out there
					 */
					if (cp == value ||
					    (cp == value+1 &&
					    (*value == '+' || *value == '-'))){
					    retval = -2;
					    break;
					} else {
						*(ip++) = tmpi;
						value = cp;
					}
					/* skip the separator */
					if (*value) value++;
				}
			}
			break;
		case 'f':
			retval = bu_parse_double(value, sdp->sp_count,
						 (double *)loc);
			break;
		default:
			bu_log("bu_struct_lookup(%s): unknown format '%s'\n",
				name, sdp->sp_fmt );
			return(-1);
		}
		if( sdp->sp_hook )  {
			sdp->sp_hook( sdp, name, base, value );
		}
		return(retval);		/* OK or parse error */
	}
	return(-1);			/* Not found */
}

/*
 *			B U _ S T R U C T P A R S E
 *
 *	Parse the structure element description in the vls string "vls"
 *	according to the structure description in "parsetab"
 *
 *  Returns -
 *	<0	failure
 *	 0	OK
 */
int
bu_structparse(const struct bu_vls *in_vls, const struct bu_structparse *desc, char *base)
                   		        	/* string to parse through */
                           	      		/* structure description */
    				      		/* base addr of users struct */
{
	struct bu_vls	vls;
	register char *cp;
	char	*name;
	char	*value;
	int retval;

	BU_CK_VLS(in_vls);
	if (desc == (struct bu_structparse *)NULL) {
		bu_log( "Null \"struct bu_structparse\" pointer\n");
		return(-1);
	}

	/* Duplicate the input string.  This algorithm is destructive. */
	bu_vls_init( &vls );
	bu_vls_vlscat( &vls, in_vls );
	cp = bu_vls_addr( &vls );

	while( *cp )  {
		/* NAME = VALUE white-space-separator */

		/* skip any leading whitespace */
		while( *cp != '\0' && isascii(*cp) && isspace(*cp) )
			cp++;

		/* Find equal sign */
		name = cp;
		while ( *cp != '\0' && *cp != '=' )
			cp++;

		if( *cp == '\0' )  {
			if( name == cp ) break;

			/* end of string in middle of arg */
			bu_log("bu_structparse: name '%s' without '='\n",
				name );
			bu_vls_free( &vls );
			return(-2);
		}

		*cp++ = '\0';

		/* Find end of value. */
		if (*cp == '"')	{
			/* strings are double-quote (") delimited
			 * skip leading " & find terminating "
			 * while skipping escaped quotes (\")
			 */
			for (value = ++cp ; *cp != '\0' ; ++cp)
				if (*cp == '"' &&
				    (cp == value || *(cp-1) != '\\') )
					break;

			if (*cp != '"') {
				bu_log("bu_structparse: name '%s'=\" without closing \"\n",
					name);
				bu_vls_free( &vls );
				return(-3);
			}
		} else {
			/* non-strings are white-space delimited */
			value = cp;
			while( *cp != '\0' && isascii(*cp) && !isspace(*cp) )
				cp++;
		}

		if( *cp != '\0' )
			*cp++ = '\0';

		/* Lookup name in desc table and modify */
		retval = bu_struct_lookup( desc, name, base, value );
		if( retval == -1 ) {
		    bu_log("bu_structparse:  '%s=%s', element name not found in:\n",
			   name, value);
		    bu_structprint( "troublesome one", desc, base );
		} else if( retval == -2 ) {
		    bu_vls_free( &vls );
		    return -2;
		}

	}
	bu_vls_free( &vls );
	return(0);
}


HIDDEN void
bu_vls_item_print_core(struct bu_vls *vp, const struct bu_structparse *sdp, const char *base, char sep_char)
                  
                                     /* item description */
                                  /* base address of users structure */
                                  /* value separator */
{
    register char *loc;

    if (sdp == (struct bu_structparse *)NULL) {
	bu_log( "Null \"struct bu_structparse\" pointer\n");
	return;
    }

#if CRAY && !__STDC__
    loc = (char *)(base + ((int)sdp->sp_offset*sizeof(int)));
#else
    loc = (char *)(base + ((int)sdp->sp_offset));
#endif

    if (sdp->sp_fmt[0] == 'i' )  {
	bu_log( "Cannot print type 'i' yet!\n" );
	return;
    }

    if ( sdp->sp_fmt[0] != '%')  {
	bu_log("bu_vls_item_print:  %s: unknown format '%s'\n",
	       sdp->sp_name, sdp->sp_fmt );
	return;
    }

    switch( sdp->sp_fmt[1] )  {
    case 'c':
    case 's':
	if (sdp->sp_count < 1)
	    break;
	if (sdp->sp_count == 1)
	    bu_vls_printf( vp, "%c", *loc );
	else
	    bu_vls_printf( vp, "%s", (char *)loc );
	break;
    case 'S': {
	register struct bu_vls *vls = (struct bu_vls *)loc;

	bu_vls_vlscat( vp, vls ); }
	break;
    case 'i': {
	register int i = sdp->sp_count;
	register short *sp = (short *)loc;

	bu_vls_printf( vp, "%hd", *sp++ );
	while( --i > 0 ) bu_vls_printf( vp, "%c%hd", sep_char, *sp++ ); }
	break;
    case 'd': {
	register int i = sdp->sp_count;
	register int *dp = (int *)loc;

	bu_vls_printf( vp, "%d", *dp++ );
	while( --i > 0 ) bu_vls_printf( vp, "%c%d", sep_char, *dp++ ); }
	break;
    case 'f': {
	register int i = sdp->sp_count;
	register double *dp = (double *)loc;

	bu_vls_printf( vp, "%.25G", *dp++ );
	while( --i > 0 ) bu_vls_printf( vp, "%c%.25G", sep_char, *dp++ ); }
	break;
    case 'x': {
	register int i = sdp->sp_count;
	register int *dp = (int *)loc;

	bu_vls_printf( vp, "%08x", *dp++ );
	while( --i > 0 ) bu_vls_printf( vp, "%c%08x", sep_char, *dp++ );  }
	break;
    default:
	break;
    }
}



/*
 *                     B U _ V L S _ I T E M _ P R I N T
 *
 * Takes the single item pointed to by "sp", and prints its value into a
 * vls.
 */

void
bu_vls_item_print(struct bu_vls *vp, const struct bu_structparse *sdp, const char *base)
                  
                                      /* item description */
                                  /* base address of users structure */
{
    bu_vls_item_print_core( vp, sdp, base, ',' );
}

/*
 *    B U _ V L S _ I T E M _ P R I N T _ N C
 *
 *    A "no-commas" version of the bu_vls_item_print() routine.
 */

void
bu_vls_item_print_nc(struct bu_vls *vp, const struct bu_structparse *sdp, const char *base)
                  
                                      /* item description */
                                  /* base address of users structure */
{
    bu_vls_item_print_core( vp, sdp, base, ' ' );
}

/*                  B U _ V L S _ N A M E _ P R I N T
 *
 * A version of bu_vls_item_print that allows you to select by name.
 */

int
bu_vls_name_print(struct bu_vls *vp, const struct bu_structparse *parsetab, const char *name, const char *base)
{
    register const struct bu_structparse *sdp;

    for( sdp = parsetab; sdp->sp_name != NULL; sdp++ )
	if( strcmp(sdp->sp_name, name) == 0 ) {
	    bu_vls_item_print( vp, sdp, base );
	    return 0;
	}

    return -1;
}

/*                  B U _ V L S _ N A M E _ P R I N T _ N C
 *
 * A "no-commas" version of bu_vls_name_print
 */

int
bu_vls_name_print_nc(struct bu_vls *vp, const struct bu_structparse *parsetab, const char *name, const char *base)
{
    register const struct bu_structparse *sdp;

    for( sdp = parsetab; sdp->sp_name != NULL; sdp++ )
	if( strcmp(sdp->sp_name, name) == 0 ) {
	    bu_vls_item_print_nc( vp, sdp, base );
	    return 0;
	}

    return -1;
}


/*
 *			B U _ V L S _ P R I N T _ D O U B L E
 */
HIDDEN void
bu_vls_print_double(struct bu_vls *vls, const char *name, register long int count, register const double *dp)
{
	register int tmpi;
	register char *cp;

	bu_vls_extend(vls, strlen(name) + 3 + 32 * count);

	cp = vls->vls_str + vls->vls_offset + vls->vls_len;
	sprintf(cp, "%s%s=%.27G", (vls->vls_len?" ":""), name, *dp++);
	tmpi = strlen(cp);
	vls->vls_len += tmpi;

	while (--count > 0) {
		cp += tmpi;
		sprintf(cp, ",%.27G", *dp++);
		tmpi = strlen(cp);
		vls->vls_len += tmpi;
	}
}

/*
 *			B U _ V L S _ S T R U C T P R I N T
 *
 *	This differs from bu_structprint in that this output is less readable
 *	by humans, but easier to parse with the computer.
 */
void
bu_vls_structprint(struct bu_vls *vls, register const struct bu_structparse *sdp, const char *base)
      	      				     	/* vls to print into */
                                    	     	/* structure description */
          				      	/* structure ponter */
{
	register char			*loc;
	register int			lastoff = -1;
	register char			*cp;

	BU_CK_VLS(vls);

	if (sdp == (struct bu_structparse *)NULL) {
		bu_log( "Null \"struct bu_structparse\" pointer\n");
		return;
	}

	for ( ; sdp->sp_name != (char*)NULL ; sdp++) {
		/* Skip alternate keywords for same value */

		if( lastoff == sdp->sp_offset )
			continue;
		lastoff = sdp->sp_offset;

#if CRAY && !__STDC__
		loc = (char *)(base + ((int)sdp->sp_offset*sizeof(int)));
#else
		loc = (char *)(base + ((int)sdp->sp_offset));
#endif

		if (sdp->sp_fmt[0] == 'i')  {
			struct bu_vls sub_str;

			bu_vls_init(&sub_str);
			bu_vls_structprint( &sub_str,
				(struct bu_structparse *)sdp->sp_count,
				base );

			bu_vls_vlscat(vls, &sub_str);
			bu_vls_free( &sub_str );
			continue;
		}

		if ( sdp->sp_fmt[0] != '%' )  {
			bu_log("bu_structprint:  %s: unknown format '%s'\n",
				sdp->sp_name, sdp->sp_fmt );
			break;
		}

		switch( sdp->sp_fmt[1] )  {
		case 'c':
		case 's':
			if (sdp->sp_count < 1)
				break;
			if (sdp->sp_count == 1) {
				bu_vls_extend(vls, strlen(sdp->sp_name)+6);
				cp = vls->vls_str + vls->vls_offset + vls->vls_len;
				if (*loc == '"')
					sprintf(cp, "%s%s=\"%s\"",
						(vls->vls_len?" ":""),
						sdp->sp_name, "\\\"");
				else
					sprintf(cp, "%s%s=\"%c\"",
						(vls->vls_len?" ":""),
						sdp->sp_name, 
						*loc);
			} else {
				register char *p; 
				register int count=0;

				/* count the quote characters */
				p = loc;
				while ((p=strchr(p, '"')) != (char *)NULL) {
					++p;
					++count;
				}
				bu_vls_extend(vls, strlen(sdp->sp_name)+
					strlen(loc)+5+count);

				cp = vls->vls_str + vls->vls_offset + vls->vls_len;
				if (vls->vls_len) (void)strcat(cp, " ");
				(void)strcat(cp, sdp->sp_name);
				(void)strcat(cp, "=\"");

				/* copy the string, escaping all the internal
				 * double quote (") characters
				 */
				p = &cp[strlen(cp)];
				while (*loc) {
					if (*loc == '"') {
						*p++ = '\\';
					}
					*p++ = *loc++;
				}
				*p++ = '"';
				*p = '\0';
			}
			vls->vls_len += strlen(cp);
			break;
		case 'S':
			{	register struct bu_vls *vls_p =
					(struct bu_vls *)loc;

				bu_vls_extend(vls, bu_vls_strlen(vls_p) + 5 +
					strlen(sdp->sp_name) );

				cp = vls->vls_str + vls->vls_offset + vls->vls_len;
				sprintf(cp, "%s%s=\"%s\"",
					(vls->vls_len?" ":""),
					sdp->sp_name,
					bu_vls_addr(vls_p) );
				vls->vls_len += strlen(cp);
			}
			break;
		case 'i':
			{	register int i = sdp->sp_count;
				register short *sp = (short *)loc;
				register int tmpi;

				bu_vls_extend(vls, 
					64 * i + strlen(sdp->sp_name) + 3 );

				cp = vls->vls_str + vls->vls_offset + vls->vls_len;
				sprintf(cp, "%s%s=%d",
						(vls->vls_len?" ":""),
						 sdp->sp_name, *sp++);
				tmpi = strlen(cp);
				vls->vls_len += tmpi;

				while (--i > 0) {
					cp += tmpi;
					sprintf(cp, ",%d", *sp++);
					tmpi = strlen(cp);
					vls->vls_len += tmpi;
				}
			}
			break;
		case 'd':
			{	register int i = sdp->sp_count;
				register int *dp = (int *)loc;
				register int tmpi;

				bu_vls_extend(vls, 
					64 * i + strlen(sdp->sp_name) + 3 );

				cp = vls->vls_str + vls->vls_offset + vls->vls_len;
				sprintf(cp, "%s%s=%d", 
					(vls->vls_len?" ":""),
					sdp->sp_name, *dp++);
				tmpi = strlen(cp);
				vls->vls_len += tmpi;

				while (--i > 0) {
					cp += tmpi;
					sprintf(cp, ",%d", *dp++);
					tmpi = strlen(cp);
					vls->vls_len += tmpi;
				}
			}
			break;
		case 'f':
			bu_vls_print_double(vls, sdp->sp_name, sdp->sp_count,
				(double *)loc);
			break;
		default:
			bu_log( " %s=%s??\n", sdp->sp_name, sdp->sp_fmt );
			abort();
			break;
		}
	}
}
@


11.13
log
@change conf.h to a wrapped config.h
@
text
@d25 1
a25 1
static const char RCSparse[] = "@@(#)$Header: /cvs/brlcad/librt/parse.c,v 11.12 2004/04/05 08:48:58 morrison Exp $ (BRL)";
@


11.12
log
@merge of ansi-6-0-branch into HEAD
@
text
@d25 1
a25 1
static const char RCSparse[] = "@@(#)$Header$ (BRL)";
d28 5
a32 1
#include "conf.h"
@


11.11
log
@update copyright to include span through 2003
@
text
@d25 1
a25 1
static const char RCSparse[] = "@@(#)$Header: /c/CVS/brlcad/librt/parse.c,v 11.10 2002/08/20 17:08:09 jra Exp $ (BRL)";
d45 180
d233 1
a233 4
bu_parse_double(str, count, loc)
const char	*str;
long		count;
double		*loc;
d299 5
a303 5
bu_struct_lookup( sdp, name, base, value )
register const struct bu_structparse	*sdp;	/* structure description */
register const char			*name;	/* struct member name */
char					*base;	/* begining of structure */
const char				*value;	/* string containing value */
d463 4
a466 4
bu_structparse( in_vls, desc, base )
const struct bu_vls		*in_vls;	/* string to parse through */
const struct bu_structparse	*desc;		/* structure description */
char				*base;		/* base addr of users struct */
a552 32
/*
 *			B U _ M A T P R I N T
 *
 *	XXX Should this be here, or could it be with the matrix support?
 *	pretty-print a matrix
 */
HIDDEN void
bu_matprint(name, mat)
const char		*name;
register const matp_t	mat;
{
	int	delta = strlen(name)+2;

	/* indent the body of the matrix */
	bu_log_indent_delta(delta);

	bu_log(" %s=%.-12E %.-12E %.-12E %.-12E\n",
		name, mat[0], mat[1], mat[2], mat[3]);
					
	bu_log("%.-12E %.-12E %.-12E %.-12E\n",
		mat[4], mat[5], mat[6], mat[7]);

	bu_log("%.-12E %.-12E %.-12E %.-12E\n",
		mat[8], mat[9], mat[10], mat[11]);

	bu_log_indent_delta(-delta);

	bu_log("%.-12E %.-12E %.-12E %.-12E\n",
		mat[12], mat[13], mat[14], mat[15]);
}


d554 5
a558 5
bu_vls_item_print_core( vp, sdp, base, sep_char )
struct bu_vls *vp;
const struct bu_structparse *sdp;    /* item description */
const char *base;                 /* base address of users structure */
char sep_char;                    /* value separator */
d642 4
a645 4
bu_vls_item_print( vp, sdp, base )
struct bu_vls *vp;
const struct bu_structparse *sdp;     /* item description */
const char *base;                 /* base address of users structure */
d657 4
a660 4
bu_vls_item_print_nc( vp, sdp, base )
struct bu_vls *vp;
const struct bu_structparse *sdp;     /* item description */
const char *base;                 /* base address of users structure */
d671 1
a671 5
bu_vls_name_print( vp, parsetab, name, base )
struct bu_vls *vp;
const struct bu_structparse *parsetab;
const char *name;
const char *base;
d690 1
a690 5
bu_vls_name_print_nc( vp, parsetab, name, base )
struct bu_vls *vp;
const struct bu_structparse *parsetab;
const char *name;
const char *base;
a703 149


/*
 *			B U _ S T R U C T P R I N T
 */
void
bu_structprint( title, parsetab, base )
const char			*title;
const struct bu_structparse	*parsetab;/* structure description */
const char			*base;	  /* base address of users structure */
{
	register const struct bu_structparse	*sdp;
	register char			*loc;
	register int			lastoff = -1;
	struct bu_vls vls;

	bu_vls_init( &vls );
	bu_log( "%s\n", title );
	if (parsetab == (struct bu_structparse *)NULL) {
		bu_log( "Null \"struct bu_structparse\" pointer\n");
		return;
	}
	for( sdp = parsetab; sdp->sp_name != (char *)0; sdp++ )  {

		/* Skip alternate keywords for same value */
		if( lastoff == sdp->sp_offset )
			continue;
		lastoff = sdp->sp_offset;

#if CRAY && !__STDC__
		loc = (char *)(base + ((int)sdp->sp_offset*sizeof(int)));
#else
		loc = (char *)(base + ((int)sdp->sp_offset));
#endif

		if (sdp->sp_fmt[0] == 'i' )  {
			bu_structprint( sdp->sp_name,
				(struct bu_structparse *)sdp->sp_count,
				base );
			continue;
		}

		if ( sdp->sp_fmt[0] != '%')  {
			bu_log("bu_structprint:  %s: unknown format '%s'\n",
				sdp->sp_name, sdp->sp_fmt );
			continue;
		}
#if 0
		bu_vls_trunc( &vls, 0 );
		bu_vls_item_print( &vls, sdp, base );
		bu_log( " %s=%s\n", sdp->sp_name, bu_vls_addr(&vls) );
#else
		switch( sdp->sp_fmt[1] )  {
		case 'c':
		case 's':
			if (sdp->sp_count < 1)
				break;
			if (sdp->sp_count == 1)
				bu_log( " %s='%c'\n", sdp->sp_name, *loc);
			else
				bu_log( " %s=\"%s\"\n", sdp->sp_name,
					(char *)loc );
			break;
		case 'S':
			{
				int delta = strlen(sdp->sp_name)+2;
				register struct bu_vls *vls =
					(struct bu_vls *)loc;

				bu_log_indent_delta(delta);
				bu_log(" %s=(vls_magic)%d (vls_offset)%d (vls_len)%d (vls_max)%d\n",
					sdp->sp_name, vls->vls_magic,
					vls->vls_offset,
					vls->vls_len, vls->vls_max);
				bu_log_indent_delta(-delta);
				bu_log("\"%s\"\n", vls->vls_str+vls->vls_offset);
			}
			break;
		case 'i':
			{	register int i = sdp->sp_count;
				register short *sp = (short *)loc;

				bu_log( " %s=%hd", sdp->sp_name, *sp++ );

				while (--i > 0) bu_log( ",%d", *sp++ );

				bu_log("\n");
			}
			break;
		case 'd':
			{	register int i = sdp->sp_count;
				register int *dp = (int *)loc;

				bu_log( " %s=%d", sdp->sp_name, *dp++ );

				while (--i > 0) bu_log( ",%d", *dp++ );

				bu_log("\n");
			}
			break;
		case 'f':
			{	register int i = sdp->sp_count;
				register double *dp = (double *)loc;

				if (sdp->sp_count == ELEMENTS_PER_MAT) {
					bu_matprint(sdp->sp_name, (matp_t)dp);
				} else if (sdp->sp_count <= ELEMENTS_PER_VECT){
					bu_log( " %s=%.25G", sdp->sp_name, *dp++ );

					while (--i > 0)
						bu_log( ",%.25G", *dp++ );

					bu_log("\n");
				}else  {
					int delta = strlen(sdp->sp_name)+2;

					bu_log_indent_delta(delta);

					bu_log( " %s=%.25G\n", sdp->sp_name, *dp++ );

					while (--i > 1)
						bu_log( "%.25G\n", *dp++ );

					bu_log_indent_delta(-delta);
					bu_log( "%.25G\n", *dp );
				}
			}
			break;
		case 'x':
			{	register int i = sdp->sp_count;
				register int *dp = (int *)loc;

				bu_log( " %s=%08x", sdp->sp_name, *dp++ );

				while (--i > 0) bu_log( ",%08x", *dp++ );

				bu_log("\n");
			}
			break;
		default:
			bu_log( " bu_structprint: Unknown format: %s=%s??\n",
				sdp->sp_name, sdp->sp_fmt );
			break;
		}
#endif
	}
	bu_vls_free(&vls);
}

d708 1
a708 5
bu_vls_print_double(vls, name, count, dp)
struct bu_vls		*vls;
const char		*name;
register long		count;
register const double	*dp;
d735 4
a738 4
bu_vls_structprint( vls, sdp, base)
struct	bu_vls				*vls;	/* vls to print into */
register const struct bu_structparse	*sdp;	/* structure description */
const char				*base;	/* structure ponter */
@


11.10
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d21 1
a21 1
 *	This software is Copyright (C) 1989 by the United States Army.
d25 1
a25 1
static const char RCSparse[] = "@@(#)$Header: /c/CVS/brlcad/librt/parse.c,v 11.8 2001/04/05 19:35:36 morrison Exp $ (BRL)";
@


11.10.4.1
log
@sync to HEAD...
@
text
@d21 1
a21 1
 *	This software is Copyright (C) 1989-2004 by the United States Army.
d25 1
a25 1
static const char RCSparse[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/parse.c,v 11.11 2004/02/02 17:39:28 morrison Exp $ (BRL)";
@


11.10.10.1
log
@merge from HEAD
@
text
@d21 1
a21 1
 *	This software is Copyright (C) 1989-2004 by the United States Army.
d25 1
a25 1
static const char RCSparse[] = "@@(#)$Header: /c/CVS/brlcad/librt/parse.c,v 11.11 2004/02/02 17:39:28 morrison Exp $ (BRL)";
@


11.10.10.2
log
@merge from head
@
text
@d25 1
a25 1
static const char RCSparse[] = "@@(#)$Header: /c/CVS/brlcad/librt/parse.c,v 11.10.10.1 2004/02/12 18:37:46 erikg Exp $ (BRL)";
@


11.10.2.1
log
@Initial ANSIfication
@
text
@d25 1
a25 1
static const char RCSparse[] = "@@(#)$Header: /c/CVS/brlcad/librt/parse.c,v 11.10 2002/08/20 17:08:09 jra Exp $ (BRL)";
d53 4
a56 1
bu_parse_double(const char *str, long int count, double *loc)
d122 5
a126 5
bu_struct_lookup(register const struct bu_structparse *sdp, register const char *name, char *base, const char *value)
                                    	     	/* structure description */
                   			      	/* struct member name */
    					      	/* begining of structure */
          				       	/* string containing value */
d286 4
a289 4
bu_structparse(const struct bu_vls *in_vls, const struct bu_structparse *desc, char *base)
                   		        	/* string to parse through */
                           	      		/* structure description */
    				      		/* base addr of users struct */
d383 3
a385 1
bu_matprint(const char *name, register const const matp_t mat)
d409 5
a413 5
bu_vls_item_print_core(struct bu_vls *vp, const struct bu_structparse *sdp, const char *base, char sep_char)
                  
                                     /* item description */
                                  /* base address of users structure */
                                  /* value separator */
d497 4
a500 4
bu_vls_item_print(struct bu_vls *vp, const struct bu_structparse *sdp, const char *base)
                  
                                      /* item description */
                                  /* base address of users structure */
d512 4
a515 4
bu_vls_item_print_nc(struct bu_vls *vp, const struct bu_structparse *sdp, const char *base)
                  
                                      /* item description */
                                  /* base address of users structure */
d526 5
a530 1
bu_vls_name_print(struct bu_vls *vp, const struct bu_structparse *parsetab, const char *name, const char *base)
d549 5
a553 1
bu_vls_name_print_nc(struct bu_vls *vp, const struct bu_structparse *parsetab, const char *name, const char *base)
d573 4
a576 4
bu_structprint(const char *title, const struct bu_structparse *parsetab, const char *base)
          			       
                           	          /* structure description */
          			      	  /* base address of users structure */
d720 5
a724 1
bu_vls_print_double(struct bu_vls *vls, const char *name, register long int count, register const double *dp)
d751 4
a754 4
bu_vls_structprint(struct bu_vls *vls, register const struct bu_structparse *sdp, const char *base)
      	      				     	/* vls to print into */
                                    	     	/* structure description */
          				      	/* structure ponter */
@


11.10.2.2
log
@changed the ordering of a couple functions so they are known types later in the file
@
text
@d25 1
a25 1
static const char RCSparse[] = "@@(#)$Header: /c/CVS/brlcad/librt/parse.c,v 11.10.2.1 2002/09/19 18:01:46 morrison Exp $ (BRL)";
a44 180


/*
 *			B U _ M A T P R I N T
 *
 *	XXX Should this be here, or could it be with the matrix support?
 *	pretty-print a matrix
 */
HIDDEN void
bu_matprint(const char *name, register const matp_t mat)
{
	int	delta = strlen(name)+2;

	/* indent the body of the matrix */
	bu_log_indent_delta(delta);

	bu_log(" %s=%.-12E %.-12E %.-12E %.-12E\n",
		name, mat[0], mat[1], mat[2], mat[3]);
					
	bu_log("%.-12E %.-12E %.-12E %.-12E\n",
		mat[4], mat[5], mat[6], mat[7]);

	bu_log("%.-12E %.-12E %.-12E %.-12E\n",
		mat[8], mat[9], mat[10], mat[11]);

	bu_log_indent_delta(-delta);

	bu_log("%.-12E %.-12E %.-12E %.-12E\n",
		mat[12], mat[13], mat[14], mat[15]);
}


/*
 *			B U _ S T R U C T P R I N T
 */
void
bu_structprint(const char *title, const struct bu_structparse *parsetab, const char *base)
          			       
                           	          /* structure description */
          			      	  /* base address of users structure */
{
	register const struct bu_structparse	*sdp;
	register char			*loc;
	register int			lastoff = -1;
	struct bu_vls vls;

	bu_vls_init( &vls );
	bu_log( "%s\n", title );
	if (parsetab == (struct bu_structparse *)NULL) {
		bu_log( "Null \"struct bu_structparse\" pointer\n");
		return;
	}
	for( sdp = parsetab; sdp->sp_name != (char *)0; sdp++ )  {

		/* Skip alternate keywords for same value */
		if( lastoff == sdp->sp_offset )
			continue;
		lastoff = sdp->sp_offset;

#if CRAY && !__STDC__
		loc = (char *)(base + ((int)sdp->sp_offset*sizeof(int)));
#else
		loc = (char *)(base + ((int)sdp->sp_offset));
#endif

		if (sdp->sp_fmt[0] == 'i' )  {
			bu_structprint( sdp->sp_name,
				(struct bu_structparse *)sdp->sp_count,
				base );
			continue;
		}

		if ( sdp->sp_fmt[0] != '%')  {
			bu_log("bu_structprint:  %s: unknown format '%s'\n",
				sdp->sp_name, sdp->sp_fmt );
			continue;
		}
#if 0
		bu_vls_trunc( &vls, 0 );
		bu_vls_item_print( &vls, sdp, base );
		bu_log( " %s=%s\n", sdp->sp_name, bu_vls_addr(&vls) );
#else
		switch( sdp->sp_fmt[1] )  {
		case 'c':
		case 's':
			if (sdp->sp_count < 1)
				break;
			if (sdp->sp_count == 1)
				bu_log( " %s='%c'\n", sdp->sp_name, *loc);
			else
				bu_log( " %s=\"%s\"\n", sdp->sp_name,
					(char *)loc );
			break;
		case 'S':
			{
				int delta = strlen(sdp->sp_name)+2;
				register struct bu_vls *vls =
					(struct bu_vls *)loc;

				bu_log_indent_delta(delta);
				bu_log(" %s=(vls_magic)%d (vls_offset)%d (vls_len)%d (vls_max)%d\n",
					sdp->sp_name, vls->vls_magic,
					vls->vls_offset,
					vls->vls_len, vls->vls_max);
				bu_log_indent_delta(-delta);
				bu_log("\"%s\"\n", vls->vls_str+vls->vls_offset);
			}
			break;
		case 'i':
			{	register int i = sdp->sp_count;
				register short *sp = (short *)loc;

				bu_log( " %s=%hd", sdp->sp_name, *sp++ );

				while (--i > 0) bu_log( ",%d", *sp++ );

				bu_log("\n");
			}
			break;
		case 'd':
			{	register int i = sdp->sp_count;
				register int *dp = (int *)loc;

				bu_log( " %s=%d", sdp->sp_name, *dp++ );

				while (--i > 0) bu_log( ",%d", *dp++ );

				bu_log("\n");
			}
			break;
		case 'f':
			{	register int i = sdp->sp_count;
				register double *dp = (double *)loc;

				if (sdp->sp_count == ELEMENTS_PER_MAT) {
					bu_matprint(sdp->sp_name, (matp_t)dp);
				} else if (sdp->sp_count <= ELEMENTS_PER_VECT){
					bu_log( " %s=%.25G", sdp->sp_name, *dp++ );

					while (--i > 0)
						bu_log( ",%.25G", *dp++ );

					bu_log("\n");
				}else  {
					int delta = strlen(sdp->sp_name)+2;

					bu_log_indent_delta(delta);

					bu_log( " %s=%.25G\n", sdp->sp_name, *dp++ );

					while (--i > 1)
						bu_log( "%.25G\n", *dp++ );

					bu_log_indent_delta(-delta);
					bu_log( "%.25G\n", *dp );
				}
			}
			break;
		case 'x':
			{	register int i = sdp->sp_count;
				register int *dp = (int *)loc;

				bu_log( " %s=%08x", sdp->sp_name, *dp++ );

				while (--i > 0) bu_log( ",%08x", *dp++ );

				bu_log("\n");
			}
			break;
		default:
			bu_log( " bu_structprint: Unknown format: %s=%s??\n",
				sdp->sp_name, sdp->sp_fmt );
			break;
		}
#endif
	}
	bu_vls_free(&vls);
}


d373 30
d553 149
@


11.10.2.3
log
@sync branch with HEAD
@
text
@d21 1
a21 1
 *	This software is Copyright (C) 1989-2004 by the United States Army.
d25 1
a25 1
static const char RCSparse[] = "@@(#)$Header$ (BRL)";
@


11.9
log
@Converted from K&R to ANSI C - RFH
@
text
@d53 4
a56 1
bu_parse_double(const char *str, long int count, double *loc)
d122 5
a126 5
bu_struct_lookup(register const struct bu_structparse *sdp, register const char *name, char *base, const char *value)
                                    	     	/* structure description */
                   			      	/* struct member name */
    					      	/* begining of structure */
          				       	/* string containing value */
d286 4
a289 4
bu_structparse(const struct bu_vls *in_vls, const struct bu_structparse *desc, char *base)
                   		        	/* string to parse through */
                           	      		/* structure description */
    				      		/* base addr of users struct */
d383 3
a385 1
bu_matprint(const char *name, register const const matp_t mat)
d409 5
a413 5
bu_vls_item_print_core(struct bu_vls *vp, const struct bu_structparse *sdp, const char *base, char sep_char)
                  
                                     /* item description */
                                  /* base address of users structure */
                                  /* value separator */
d497 4
a500 4
bu_vls_item_print(struct bu_vls *vp, const struct bu_structparse *sdp, const char *base)
                  
                                      /* item description */
                                  /* base address of users structure */
d512 4
a515 4
bu_vls_item_print_nc(struct bu_vls *vp, const struct bu_structparse *sdp, const char *base)
                  
                                      /* item description */
                                  /* base address of users structure */
d526 5
a530 1
bu_vls_name_print(struct bu_vls *vp, const struct bu_structparse *parsetab, const char *name, const char *base)
d549 5
a553 1
bu_vls_name_print_nc(struct bu_vls *vp, const struct bu_structparse *parsetab, const char *name, const char *base)
d573 4
a576 4
bu_structprint(const char *title, const struct bu_structparse *parsetab, const char *base)
          			       
                           	          /* structure description */
          			      	  /* base address of users structure */
d720 5
a724 1
bu_vls_print_double(struct bu_vls *vls, const char *name, register long int count, register const double *dp)
d751 4
a754 4
bu_vls_structprint(struct bu_vls *vls, register const struct bu_structparse *sdp, const char *base)
      	      				     	/* vls to print into */
                                    	     	/* structure description */
          				      	/* structure ponter */
@


11.8
log
@updated SIGNED to signed
updated CONST to const
@
text
@d25 1
a25 1
static const char RCSparse[] = "@@(#)$Header: /c/CVS/brlcad/librt/parse.c,v 11.7 2000/07/10 23:01:47 mike Exp $ (BRL)";
d53 1
a53 4
bu_parse_double(str, count, loc)
const char	*str;
long		count;
double		*loc;
d119 5
a123 5
bu_struct_lookup( sdp, name, base, value )
register const struct bu_structparse	*sdp;	/* structure description */
register const char			*name;	/* struct member name */
char					*base;	/* begining of structure */
const char				*value;	/* string containing value */
d283 4
a286 4
bu_structparse( in_vls, desc, base )
const struct bu_vls		*in_vls;	/* string to parse through */
const struct bu_structparse	*desc;		/* structure description */
char				*base;		/* base addr of users struct */
d380 1
a380 3
bu_matprint(name, mat)
const char		*name;
register const matp_t	mat;
d404 5
a408 5
bu_vls_item_print_core( vp, sdp, base, sep_char )
struct bu_vls *vp;
const struct bu_structparse *sdp;    /* item description */
const char *base;                 /* base address of users structure */
char sep_char;                    /* value separator */
d492 4
a495 4
bu_vls_item_print( vp, sdp, base )
struct bu_vls *vp;
const struct bu_structparse *sdp;     /* item description */
const char *base;                 /* base address of users structure */
d507 4
a510 4
bu_vls_item_print_nc( vp, sdp, base )
struct bu_vls *vp;
const struct bu_structparse *sdp;     /* item description */
const char *base;                 /* base address of users structure */
d521 1
a521 5
bu_vls_name_print( vp, parsetab, name, base )
struct bu_vls *vp;
const struct bu_structparse *parsetab;
const char *name;
const char *base;
d540 1
a540 5
bu_vls_name_print_nc( vp, parsetab, name, base )
struct bu_vls *vp;
const struct bu_structparse *parsetab;
const char *name;
const char *base;
d560 4
a563 4
bu_structprint( title, parsetab, base )
const char			*title;
const struct bu_structparse	*parsetab;/* structure description */
const char			*base;	  /* base address of users structure */
d707 1
a707 5
bu_vls_print_double(vls, name, count, dp)
struct bu_vls		*vls;
const char		*name;
register long		count;
register const double	*dp;
d734 4
a737 4
bu_vls_structprint( vls, sdp, base)
struct	bu_vls				*vls;	/* vls to print into */
register const struct bu_structparse	*sdp;	/* structure description */
const char				*base;	/* structure ponter */
@


11.7
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d25 1
a25 1
static const char RCSparse[] = "@@(#)$Header: /c/CVS/brlcad/librt/parse.c,v 11.6 1996/08/29 22:44:43 butler Exp $ (BRL)";
d54 1
a54 1
CONST char	*str;
d60 1
a60 1
	CONST char	*numstart;
d123 2
a124 2
register CONST struct bu_structparse	*sdp;	/* structure description */
register CONST char			*name;	/* struct member name */
d126 1
a126 1
CONST char				*value;	/* string containing value */
d192 1
a192 1
				register CONST char *cp;
d223 1
a223 1
				register char CONST *cp;
d287 2
a288 2
CONST struct bu_vls		*in_vls;	/* string to parse through */
CONST struct bu_structparse	*desc;		/* structure description */
d384 2
a385 2
CONST char		*name;
register CONST matp_t	mat;
d411 2
a412 2
CONST struct bu_structparse *sdp;    /* item description */
CONST char *base;                 /* base address of users structure */
d499 2
a500 2
CONST struct bu_structparse *sdp;     /* item description */
CONST char *base;                 /* base address of users structure */
d514 2
a515 2
CONST struct bu_structparse *sdp;     /* item description */
CONST char *base;                 /* base address of users structure */
d528 3
a530 3
CONST struct bu_structparse *parsetab;
CONST char *name;
CONST char *base;
d532 1
a532 1
    register CONST struct bu_structparse *sdp;
d551 3
a553 3
CONST struct bu_structparse *parsetab;
CONST char *name;
CONST char *base;
d555 1
a555 1
    register CONST struct bu_structparse *sdp;
d574 3
a576 3
CONST char			*title;
CONST struct bu_structparse	*parsetab;/* structure description */
CONST char			*base;	  /* base address of users structure */
d578 1
a578 1
	register CONST struct bu_structparse	*sdp;
d722 1
a722 1
CONST char		*name;
d724 1
a724 1
register CONST double	*dp;
d753 2
a754 2
register CONST struct bu_structparse	*sdp;	/* structure description */
CONST char				*base;	/* structure ponter */
@


11.6
log
@checkpoint
@
text
@d25 1
a25 1
static char RCSparse[] = "@@(#)$Header: /m/cad/librt/RCS/parse.c,v 11.5 1996/08/27 03:43:38 mike Exp butler $ (BRL)";
@


11.5
log
@bu.h
@
text
@d25 1
a25 1
static char RCSparse[] = "@@(#)$Header: /m/cad/librt/RCS/parse.c,v 11.4 1996/07/12 12:10:21 jra Exp mike $ (BRL)";
d46 1
a46 1
 *			R T _ P A R S E _ D O U B L E
d53 1
a53 1
rt_parse_double(str, count, loc)
d114 1
a114 1
 *			R T _ S T R U C T _ L O O K U P
d122 2
a123 2
rt_struct_lookup( sdp, name, base, value )
register CONST struct structparse	*sdp;	/* structure description */
d150 2
a151 2
			if( rt_struct_lookup(
				(struct structparse *)sdp->sp_count,
d159 1
a159 1
			bu_log("rt_struct_lookup(%s): unknown format '%s'\n",
d259 1
a259 1
			retval = rt_parse_double(value, sdp->sp_count,
d263 1
a263 1
			bu_log("rt_struct_lookup(%s): unknown format '%s'\n",
d276 1
a276 1
 *			R T _ S T R U C T P A R S E
d286 1
a286 1
rt_structparse( in_vls, desc, base )
d288 1
a288 1
CONST struct structparse	*desc;		/* structure description */
d298 2
a299 2
	if (desc == (struct structparse *)NULL) {
		bu_log( "Null \"struct structparse\" pointer\n");
d324 1
a324 1
			bu_log("rt_structparse: name '%s' without '='\n",
d344 1
a344 1
				bu_log("rt_structparse: name '%s'=\" without closing \"\n",
d360 1
a360 1
		retval = rt_struct_lookup( desc, name, base, value );
d362 1
a362 1
		    bu_log("rt_structparse:  '%s=%s', element name not found in:\n",
d364 1
a364 1
		    rt_structprint( "troublesome one", desc, base );
d375 1
d377 1
a377 1
 *			R T _ M A T P R I N T
d379 1
d383 1
a383 1
rt_matprint(name, mat)
d407 1
d409 1
a409 1
rt_vls_item_print_core( vp, sdp, base, sep_char )
d411 1
a411 1
CONST struct structparse *sdp;    /* item description */
d417 2
a418 2
    if (sdp == (struct structparse *)NULL) {
	bu_log( "Null \"struct structparse\" pointer\n");
d434 1
a434 1
	bu_log("rt_vls_item_print:  %s: unknown format '%s'\n",
d490 1
a490 1
 *                     R T _ V L S _ I T E M _ P R I N T
d497 1
a497 1
rt_vls_item_print( vp, sdp, base )
d499 1
a499 1
CONST struct structparse *sdp;     /* item description */
d502 1
a502 1
    rt_vls_item_print_core( vp, sdp, base, ',' );
d506 1
a506 1
 *    R T _ V L S _ I T E M _ P R I N T _ N C
d508 1
a508 1
 *    A "no-commas" version of the rt_vls_item_print() routine.
d512 1
a512 1
rt_vls_item_print_nc( vp, sdp, base )
d514 1
a514 1
CONST struct structparse *sdp;     /* item description */
d517 1
a517 1
    rt_vls_item_print_core( vp, sdp, base, ' ' );
d520 1
a520 1
/*                  R T _ V L S _ N A M E _ P R I N T
d522 1
a522 1
 * A version of rt_vls_item_print that allows you to select by name.
d526 1
a526 1
rt_vls_name_print( vp, parsetab, name, base )
d528 1
a528 1
CONST struct structparse *parsetab;
d532 1
a532 1
    register CONST struct structparse *sdp;
d536 1
a536 1
	    rt_vls_item_print( vp, sdp, base );
d543 1
a543 1
/*                  R T _ V L S _ N A M E _ P R I N T _ N C
d545 1
a545 1
 * A "no-commas" version of rt_vls_name_print
d549 1
a549 1
rt_vls_name_print_nc( vp, parsetab, name, base )
d551 1
a551 1
CONST struct structparse *parsetab;
d555 1
a555 1
    register CONST struct structparse *sdp;
d559 1
a559 1
	    rt_vls_item_print_nc( vp, sdp, base );
d570 1
a570 1
 *			R T _ S T R U C T P R I N T
d573 1
a573 1
rt_structprint( title, parsetab, base )
d575 1
a575 1
CONST struct structparse	*parsetab;/* structure description */
d578 1
a578 1
	register CONST struct structparse	*sdp;
d585 2
a586 2
	if (parsetab == (struct structparse *)NULL) {
		bu_log( "Null \"struct structparse\" pointer\n");
d603 2
a604 2
			rt_structprint( sdp->sp_name,
				(struct structparse *)sdp->sp_count,
d610 1
a610 1
			bu_log("rt_structprint:  %s: unknown format '%s'\n",
d616 1
a616 1
		rt_vls_item_print( &vls, sdp, base );
d672 1
a672 1
					rt_matprint(sdp->sp_name, (matp_t)dp);
d707 1
a707 1
			bu_log( " rt_structprint: Unknown format: %s=%s??\n",
d717 1
a717 1
 *			R T _ V L S _ P R I N T _ D O U B L E
d720 1
a720 1
rt_vls_print_double(vls, name, count, dp)
d745 1
a745 1
 *			R T _ V L S _ S T R U C T P R I N T
d747 1
a747 1
 *	This differs from rt_structprint in that this output is less readable
d751 1
a751 1
rt_vls_structprint( vls, sdp, base)
d753 1
a753 1
register CONST struct structparse	*sdp;	/* structure description */
d762 2
a763 2
	if (sdp == (struct structparse *)NULL) {
		bu_log( "Null \"struct structparse\" pointer\n");
d784 2
a785 2
			rt_vls_structprint( &sub_str,
				(struct structparse *)sdp->sp_count,
d794 1
a794 1
			bu_log("rt_structprint:  %s: unknown format '%s'\n",
d911 1
a911 1
			rt_vls_print_double(vls, sdp->sp_name, sdp->sp_count,
@


11.4
log
@Minor Mods for IRIX 6.2
@
text
@d25 1
a25 1
static char RCSparse[] = "@@(#)$Header: /m/cad/librt/RCS/parse.c,v 11.3 1995/06/30 15:54:02 gdurf Exp jra $ (BRL)";
d40 1
d42 1
a42 2
#include "rtstring.h"
#include "externs.h"
d159 1
a159 1
			rt_log("rt_struct_lookup(%s): unknown format '%s'\n",
d184 3
a186 5
			{	struct rt_vls *vls = (struct rt_vls *)loc;
				if (vls->vls_magic != RT_VLS_MAGIC)
					rt_vls_init(vls);

				rt_vls_strcpy(vls, value);
d263 1
a263 1
			rt_log("rt_struct_lookup(%s): unknown format '%s'\n",
d287 1
a287 1
CONST struct rt_vls		*in_vls;	/* string to parse through */
d291 1
a291 1
	struct rt_vls	vls;
d297 1
a297 1
	RT_VLS_CHECK(in_vls);
d299 1
a299 1
		rt_log( "Null \"struct structparse\" pointer\n");
d304 3
a306 3
	RT_VLS_INIT( &vls );
	rt_vls_vlscat( &vls, in_vls );
	cp = RT_VLS_ADDR( &vls );
d324 1
a324 1
			rt_log("rt_structparse: name '%s' without '='\n",
d326 1
a326 1
			rt_vls_free( &vls );
d344 1
a344 1
				rt_log("rt_structparse: name '%s'=\" without closing \"\n",
d346 1
a346 1
				rt_vls_free( &vls );
d362 1
a362 1
		    rt_log("rt_structparse:  '%s=%s', element name not found in:\n",
d366 1
a366 1
		    rt_vls_free( &vls );
d371 1
a371 1
	rt_vls_free( &vls );
d385 1
a385 1
	int i = rt_g.rtg_logindent;
d388 1
a388 1
	rt_g.rtg_logindent += strlen(name)+2;
d390 1
a390 1
	rt_log(" %s=%.-12E %.-12E %.-12E %.-12E\n",
d393 1
a393 1
	rt_log("%.-12E %.-12E %.-12E %.-12E\n",
d396 1
a396 1
	rt_log("%.-12E %.-12E %.-12E %.-12E\n",
d399 1
a399 1
	rt_g.rtg_logindent = i;
d401 1
a401 1
	rt_log("%.-12E %.-12E %.-12E %.-12E\n",
d407 1
a407 1
struct rt_vls *vp;
d415 1
a415 1
	rt_log( "Null \"struct structparse\" pointer\n");
d426 1
a426 1
	rt_log( "Cannot print type 'i' yet!\n" );
d431 1
a431 1
	rt_log("rt_vls_item_print:  %s: unknown format '%s'\n",
d442 1
a442 1
	    rt_vls_printf( vp, "%c", *loc );
d444 1
a444 1
	    rt_vls_printf( vp, "%s", (char *)loc );
d447 1
a447 1
	register struct rt_vls *vls = (struct rt_vls *)loc;
d449 1
a449 1
	rt_vls_vlscat( vp, vls ); }
d455 2
a456 2
	rt_vls_printf( vp, "%hd", *sp++ );
	while( --i > 0 ) rt_vls_printf( vp, "%c%hd", sep_char, *sp++ ); }
d462 2
a463 2
	rt_vls_printf( vp, "%d", *dp++ );
	while( --i > 0 ) rt_vls_printf( vp, "%c%d", sep_char, *dp++ ); }
d469 2
a470 2
	rt_vls_printf( vp, "%.25G", *dp++ );
	while( --i > 0 ) rt_vls_printf( vp, "%c%.25G", sep_char, *dp++ ); }
d476 2
a477 2
	rt_vls_printf( vp, "%08x", *dp++ );
	while( --i > 0 ) rt_vls_printf( vp, "%c%08x", sep_char, *dp++ );  }
d495 1
a495 1
struct rt_vls *vp;
d510 1
a510 1
struct rt_vls *vp;
d524 1
a524 1
struct rt_vls *vp;
d547 1
a547 1
struct rt_vls *vp;
d578 1
a578 1
	struct rt_vls vls;
d580 2
a581 2
	rt_vls_init( &vls );
	rt_log( "%s\n", title );
d583 1
a583 1
		rt_log( "Null \"struct structparse\" pointer\n");
d607 1
a607 1
			rt_log("rt_structprint:  %s: unknown format '%s'\n",
d612 1
a612 1
		rt_vls_trunc( &vls, 0 );
d614 1
a614 1
		rt_log( " %s=%s\n", sdp->sp_name, rt_vls_addr(&vls) );
d622 1
a622 1
				rt_log( " %s='%c'\n", sdp->sp_name, *loc);
d624 1
a624 1
				rt_log( " %s=\"%s\"\n", sdp->sp_name,
d628 4
a631 3
			{	register int indent = rt_g.rtg_logindent;
				register struct rt_vls *vls =
					(struct rt_vls *)loc;
d633 2
a634 3
				rt_g.rtg_logindent = strlen(sdp->sp_name)+2;
				
				rt_log(" %s=(vls_magic)%d (vls_offset)%d (vls_len)%d (vls_max)%d\n",
d638 2
a639 2
				rt_g.rtg_logindent = indent;
				rt_log("\"%s\"\n", vls->vls_str+vls->vls_offset);
d646 1
a646 1
				rt_log( " %s=%hd", sdp->sp_name, *sp++ );
d648 1
a648 1
				while (--i > 0) rt_log( ",%d", *sp++ );
d650 1
a650 1
				rt_log("\n");
d657 1
a657 1
				rt_log( " %s=%d", sdp->sp_name, *dp++ );
d659 1
a659 1
				while (--i > 0) rt_log( ",%d", *dp++ );
d661 1
a661 1
				rt_log("\n");
d671 1
a671 1
					rt_log( " %s=%.25G", sdp->sp_name, *dp++ );
d674 1
a674 1
						rt_log( ",%.25G", *dp++ );
d676 1
a676 1
					rt_log("\n");
d678 1
a678 1
					register int j = rt_g.rtg_logindent;
d680 1
a680 3
					rt_g.rtg_logindent += strlen(sdp->sp_name)+2;
					
					rt_log( " %s=%.25G\n", sdp->sp_name, *dp++ );
d682 2
d685 1
a685 1
						rt_log( "%.25G\n", *dp++ );
d687 2
a688 3
					rt_g.rtg_logindent = j;
					rt_log( "%.25G\n", *dp );

d696 1
a696 1
				rt_log( " %s=%08x", sdp->sp_name, *dp++ );
d698 1
a698 1
				while (--i > 0) rt_log( ",%08x", *dp++ );
d700 1
a700 1
				rt_log("\n");
d704 1
a704 1
			rt_log( " rt_structprint: Unknown format: %s=%s??\n",
d710 1
a710 1
	rt_vls_free(&vls);
d718 1
a718 1
struct rt_vls		*vls;
d726 1
a726 1
	rt_vls_extend(vls, strlen(name) + 3 + 32 * count);
d749 1
a749 1
struct	rt_vls				*vls;	/* vls to print into */
d757 1
a757 1
	RT_VLS_CHECK(vls);
d760 1
a760 1
		rt_log( "Null \"struct structparse\" pointer\n");
d778 1
a778 1
			struct rt_vls sub_str;
d780 1
a780 1
			rt_vls_init(&sub_str);
d785 2
a786 2
			rt_vls_vlscat(vls, &sub_str);
			rt_vls_free( &sub_str );
d791 1
a791 1
			rt_log("rt_structprint:  %s: unknown format '%s'\n",
d802 1
a802 1
				rt_vls_extend(vls, strlen(sdp->sp_name)+6);
d823 1
a823 1
				rt_vls_extend(vls, strlen(sdp->sp_name)+
d847 2
a848 2
			{	register struct rt_vls *vls_p =
					(struct rt_vls *)loc;
d850 1
a850 1
				rt_vls_extend(vls, rt_vls_strlen(vls_p) + 5 +
d857 1
a857 1
					rt_vls_addr(vls_p) );
d866 1
a866 1
				rt_vls_extend(vls, 
d889 1
a889 1
				rt_vls_extend(vls, 
d912 1
a912 1
			rt_log( " %s=%s??\n", sdp->sp_name, sdp->sp_fmt );
@


11.3
log
@Added some item parsing routines
@
text
@d25 1
a25 1
static char RCSparse[] = "@@(#)$Header: /m/cad/librt/RCS/parse.c,v 11.2 1995/06/15 20:19:34 gdurf Exp gdurf $ (BRL)";
d55 1
a55 1
int		count;
d58 1
a58 1
	int	i;
d723 1
a723 1
register int		count;
@


11.2
log
@Added support for single item printing
@
text
@d25 1
a25 1
static char RCSparse[] = "@@(#)$Header: /m/cad/librt/RCS/parse.c,v 11.1 1995/01/04 09:58:21 mike Rel4_4 gdurf $ (BRL)";
d49 2
d52 1
a52 1
HIDDEN void
d85 1
a85 1
			return;
d103 1
a103 1
			return;
d110 1
d117 1
d129 1
a129 1
	int i;
d135 2
a136 1
			continue;
d210 4
a213 3
					    (*value == '+' || *value == '-')))
						break;
					else {
d248 4
a251 3
					    (*value == '+' || *value == '-')))
						break;
					else {
d261 2
a262 1
			rt_parse_double(value, sdp->sp_count, (double *)loc);
d272 1
a272 1
		return(0);		/* OK */
d297 1
d361 9
a369 5
		/* Lookup name in desc table */
		if( rt_struct_lookup( desc, name, base, value ) < 0 )  {
			rt_log("rt_structparse:  '%s=%s', element name not found in:\n",
				name, value);
			rt_structprint( "troublesome one", desc, base );
d371 1
d407 2
a408 9
/*
 *                     R T _ V L S _ I T E M _ P R I N T
 *
 * Takes the single item pointed to by "sp", and prints its value into a
 * vls.
 */

void
rt_vls_item_print( vp, sdp, base )
d410 1
a410 1
CONST struct structparse *sdp;     /* item description */
d412 1
d433 1
a433 1
	rt_log("rt_structprint:  %s: unknown format '%s'\n",
d458 1
a458 1
	while( --i > 0 ) rt_vls_printf( vp, ",%hd", *sp++ ); }
d465 1
a465 1
	while( --i > 0 ) rt_vls_printf( vp, ",%d", *dp++ ); }
d472 1
a472 1
	while( --i > 0 ) rt_vls_printf( vp, ",%.25G", *dp++ ); }
d479 1
a479 1
	while( --i > 0 ) rt_vls_printf( vp, ",%08x", *dp++ );  }
d484 82
a565 1
}    
d613 1
a613 1
#if 1
@


11.1
log
@Release_4.4
@
text
@d25 1
a25 1
static char RCSparse[] = "@@(#)$Header: /m/cad/librt/RCS/parse.c,v 10.5 94/11/04 05:50:04 mike Exp $ (BRL)";
d393 84
d478 1
d491 1
d493 1
d524 5
a528 1

d622 1
d624 1
@


10.5
log
@Irix 6
@
text
@d25 1
a25 1
static char RCSparse[] = "@@(#)$Header: /m/cad/librt/RCS/parse.c,v 10.4 94/10/17 10:16:28 jra Exp Locker: mike $ (BRL)";
@


10.4
log
@replaced cp = rt_vls_addr(vls) + rt_vls_strlen(vls); with cp = vls->vls_str + vls->vls_offset + vls->vls_len;
since rt_vls_addr doesn't return address when string is null.
@
text
@d25 1
a25 1
static char RCSparse[] = "@@(#)$Header: /m/cad/librt/RCS/parse.c,v 10.3 94/08/10 19:40:02 gdurf Exp Locker: jra $ (BRL)";
a259 1
			break;
@


10.3
log
@factored ifdefs
@
text
@d25 1
a25 1
static char RCSparse[] = "@@(#)$Header: /m/cad/librt/RCS/parse.c,v 10.2 1993/07/13 20:32:41 mike Exp cjohnson $ (BRL)";
d550 1
a550 1
	cp = rt_vls_addr(vls) + rt_vls_strlen(vls);
d625 1
a625 1
				cp = rt_vls_addr(vls) + rt_vls_strlen(vls);
d648 1
a648 1
				cp = rt_vls_addr(vls) + rt_vls_strlen(vls);
d675 1
a675 1
				cp = rt_vls_addr(vls) + rt_vls_strlen(vls);
d691 1
a691 1
				cp = rt_vls_addr(vls) + rt_vls_strlen(vls);
d714 1
a714 1
				cp = rt_vls_addr(vls) + rt_vls_strlen(vls);
@


10.2
log
@Added special case:  On a %d, variable=! will toggle a boolean int.
@
text
@d25 1
a25 1
static char RCSparse[] = "@@(#)$Header: /m/cad/librt/RCS/parse.c,v 10.1 91/10/12 06:40:52 mike Rel4_0 Locker: mike $ (BRL)";
d28 2
d33 3
a35 1
#ifdef BSD
a36 2
#else
# include <string.h>
d457 1
a457 1
				rt_log(" %s=(vls_magic)%d (vls_len)%d (vls_max)%d\n",
d459 1
d462 1
a462 1
				rt_log("\"%s\"\n", vls->vls_str);
d550 1
a550 1
	cp = &vls->vls_str[vls->vls_len];
d625 1
a625 1
				cp = &vls->vls_str[vls->vls_len];
d648 1
a648 1
				cp = &vls->vls_str[vls->vls_len];
d675 1
a675 1
				cp = &vls->vls_str[vls->vls_len];
d691 1
a691 1
				cp = &vls->vls_str[vls->vls_len];
d714 1
a714 1
				cp = &vls->vls_str[vls->vls_len];
@


10.1
log
@Release_4.0
@
text
@d25 1
a25 1
static char RCSparse[] = "@@(#)$Header: /m/cad/librt/RCS/parse.c,v 9.15 91/06/30 20:07:21 mike Exp $ (BRL)";
d218 7
@


9.15
log
@Fixed rt_structparse so that it would not smash the caller's
copy of the string argument.
@
text
@d25 1
a25 1
static char RCSparse[] = "@@(#)$Header: /m/cad/librt/RCS/parse.c,v 9.14 91/06/29 23:30:35 mike Exp $ (BRL)";
@


9.14
log
@Oops, sense of test was backwards
@
text
@d25 1
a25 1
static char RCSparse[] = "@@(#)$Header: /m/cad/librt/RCS/parse.c,v 9.13 91/06/29 23:16:18 mike Exp $ (BRL)";
d272 2
a273 2
rt_structparse( vls, desc, base )
struct rt_vls			*vls;		/* string to parse through */
d277 1
d282 1
a282 1
	RT_VLS_CHECK(vls);
d288 4
a292 2
	cp = RT_VLS_ADDR(vls);

d311 1
d331 1
d351 1
@


9.13
log
@ANSI lint
@
text
@d25 1
a25 1
static char RCSparse[] = "@@(#)$Header: /m/cad/librt/RCS/parse.c,v 9.12 91/06/14 05:49:36 mike Exp $ (BRL)";
d253 1
a253 1
		if( !(sdp->sp_hook) )  {
@


9.12
log
@atof() won't grok input with capital "E" for exponents.
@
text
@d25 1
a25 1
static char RCSparse[] = "@@(#)$Header: /m/cad/librt/RCS/parse.c,v 9.11 91/02/28 15:35:58 mike Exp $ (BRL)";
d50 3
a52 3
char	*str;
int	count;
double	*loc;
d56 1
a56 1
	char	*numstart;
d117 4
a120 4
register struct structparse	*sdp;		/* structure description */
register char			*name;		/* struct member name */
char				*base;		/* begining of structure */
char				*value;		/* string containing value */
d187 1
a187 1
				register char *cp;
d217 1
a217 1
				register char *cp;
d253 1
a253 1
		if( sdp->sp_hook != FUNC_NULL )  {
d273 3
a275 3
struct rt_vls		*vls;		/* string to parse through */
struct structparse	*desc;		/* structure description */
char			*base;		/* base address of users structure */
d356 2
a357 2
char *name;
register matp_t mat;
d385 3
a387 3
char 			*title;
struct structparse	*parsetab;	/* structure description */
char			*base;		/* base address of users structure */
d389 1
a389 1
	register struct structparse	*sdp;
d524 4
a527 4
struct rt_vls *vls;
char *name;
register int count;
register double *dp;
d555 3
a557 3
struct	rt_vls			*vls;	/* vls to print into */
register struct structparse	*sdp;	/* structure description */
char				*base;	/* structure ponter */
@


9.11
log
@Fixed bug in parsing of floating point values
@
text
@d25 1
a25 1
static char RCSparse[] = "@@(#)$Header: /m/cad/librt/RCS/parse.c,v 9.10 91/02/17 19:59:47 mike Exp $ (BRL)";
d54 6
a59 6
	register int i;
	register char *cp;
	int dot_seen;
	char *numstart;
	double tmp_double;
	
a61 3
		tmp_double = atof( str );

		/* skip text of float # */
d65 1
a65 1
		if (*numstart == '-' || *numstart == '+') numstart++;
a66 2
		cp = numstart;

d68 3
a70 2
		for (dot_seen = 0; *cp ; cp++ ) {
			if (*cp == '.' && !dot_seen) {
d74 1
a74 1
			if (!isdigit(*cp))
d79 2
a80 2
		/* no mantissa, no float str */
		if (cp == numstart + dot_seen)
a82 3
		*loc++ = tmp_double;
		str = cp;

d84 2
a85 2
		if  (*cp == 'E' || *cp == 'e') {
			numstart = ++cp;
d88 1
a88 1
		    	if (*numstart == '+' || *numstart == '-') numstart++;
d90 2
a91 1
			while (isdigit(*cp)) cp++;
d93 9
a101 4
			/* if there was a mantissa, skip over it */
			if (cp != numstart)
				str = cp;
		}
@


9.10
log
@rt_structparse now returns an int.
@
text
@d11 1
a11 1
 *  Author -
d25 1
a25 1
static char RCSparse[] = "@@(#)$Header: /m/cad/librt/RCS/parse.c,v 9.9 91/01/25 19:14:08 mike Exp $ (BRL)";
d49 4
a52 4
rt_parse_double(value, count, loc)
char *value;
int count;
double *loc;
d61 2
a62 2
	for (i=0 ; i < count && *value ; ++i){
		tmp_double = atof( value );
d65 1
a65 1
		numstart = value;
d83 1
a83 1
		/* no mantissa, no float value */
d87 2
a88 3
		*((double *)loc) = tmp_double;
		loc += sizeof(double);
		value = cp;
d101 1
a101 1
				value = cp;
d105 1
a105 1
		if (*value) value++;
d264 2
a265 1
 *	parse the structure element description in the vls string "vls"
d548 2
a549 1
/*	R T _ V L S _ S T R U C T P R I N T
@


9.9
log
@Improved names of internal subroutines.
@
text
@d25 1
a25 1
static char RCSparse[] = "@@(#)$Header: /m/cad/librt/RCS/parse.c,v 9.8 91/01/12 07:25:34 mike Exp $ (BRL)";
d267 4
d272 1
a272 1
void
d285 1
a285 1
		return;
d309 1
a309 1
			break;
d328 1
a328 1
				break;
d347 1
a347 1

@


9.8
log
@lint
@
text
@d25 1
a25 1
static char RCSparse[] = "@@(#)$Header: /m/cad/librt/RCS/parse.c,v 9.7 91/01/09 20:54:36 cjohnson Exp $ (BRL)";
d44 1
a44 1
 *		P A R S E _ F L O A T
d46 1
a46 1
 *	parse an array of one or more floats.  The floats
d49 1
a49 1
parse_float(value, count, loc)
d247 1
a247 1
			parse_float(value, sdp->sp_count, (double *)loc);
d346 2
a347 1
/*	M A T P R I N T
d352 1
a352 1
matprint(name, mat)
d473 1
a473 1
					matprint(sdp->sp_name, (matp_t)dp);
d516 3
d520 1
a520 1
vls_print_float(vls, name, count, dp)
d710 1
a710 1
			vls_print_float(vls, sdp->sp_name, sdp->sp_count,
@


9.7
log
@Added 'x' to output via rt_log, no input not vls yet.
@
text
@d25 1
a25 1
static char RCSparse[] = "@@(#)$Header: /m/cad/librt/RCS/parse.c,v 9.6 90/12/18 00:21:30 butler Exp $ (BRL)";
a30 4
#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "rtstring.h"
d37 6
a612 1
				char *strchr();
@


9.6
log
@Eliminated %C special format for RGBpixel.
These are now expected to be implemented as an array of 3 ints.
@
text
@d25 1
a25 1
static char RCSparse[] = "@@(#)$Header: /m/cad/librt/RCS/parse.c,v 9.5 90/12/14 21:33:37 butler Exp $ (BRL)";
d492 11
@


9.5
log
@passes lint, gcc and cray compiler tests
@
text
@d25 1
a25 1
static char RCSparse[] = "@@(#)$Header: /m/cad/librt/RCS/parse.c,v 9.4 90/12/14 16:01:02 butler Exp $ (BRL)";
a246 10
		case 'C':	/* sdp->sp_count ignored */
			for (i=0 ; i < 3 && *value ; ++i) {
				*((unsigned char *)loc++) = atoi( value );
				while (*value && isdigit(*value) )
					value++;

				/* skip the separator */
				if (*value) value++;
			}
			break;
a493 9
		case 'C':	/* sdp->sp_count ignored */
			{	register unsigned char *ucp =
					(unsigned char *)loc;

				rt_log( " %s=%u/%u/%u\n",
					sdp->sp_name,
					ucp[0], ucp[1], ucp[2] );
			}
			break;
a695 15
			break;
		case 'C':
			{
				register unsigned char *RGBp =
					(unsigned char *)loc;

				rt_vls_extend(vls, 16+strlen(sdp->sp_name) );

				cp = &vls->vls_str[vls->vls_len];
				sprintf(cp, "%s%s=%d/%d/%d", 
						(vls->vls_len?" ":""),
						sdp->sp_name,
						RGBp[0], RGBp[1], RGBp[2]);
				vls->vls_len += strlen(cp);
			}
@


9.4
log
@improved handling of strings, unified floating point handling,
allowed for signs on integer types, and delete support for most
"pseudo-types"
@
text
@d25 1
a25 1
static char RCSparse[] = "@@(#)$Header: /m/cad/librt/RCS/parse.c,v 9.1 89/05/19 05:56:53 mike Rel3_5 $ (BRL)";
d534 1
a534 1
	sprintf(cp, " %s=%.27G", name, *dp++);
d615 2
a616 2
						sdp->sp_name,
						*(signed char *)loc);
d618 2
a619 1
				register char *p;
d659 1
a659 1
				sprintf(cp, "%s%s=\"%s\"", sdp->sp_name,
d661 1
@


9.3
log
@Too many "cp" variables.  Inner one changed to "ucp".
@
text
@d13 1
d25 1
a25 1
static char RCSparse[] = "@@(#)$Header: /m/cad/librt/RCS/parse.c,v 9.2 90/12/10 03:33:19 butler Exp $ (BRL)";
d34 1
a34 1

d41 2
a42 1
/*			R T _ P A R S E _ M A T
d44 1
a44 2
 *	Parse a string as a mat_t.  The elemets should be separated by
 *	a single, comma character.
d47 4
a50 3
rt_parse_mat( mat, str)
register matp_t mat;
char *str;
d53 5
d59 2
a60 2
	for (i=0 ; i < ELEMENTS_PER_MAT ; ++i)
		mat[i] = 0.0;
d62 2
a63 9
	for (i=0 ; i < ELEMENTS_PER_MAT ; ++i) {
		if (!isdigit(*str) && *str != '.') return;
		mat[i] = atof(str);
		while (*str && *str != ',')
			str++;
		if (!*str) return;	/* EOS */
		else str++;		/* Skip element separator */
	}
}
d65 2
a66 17
/*
 *			R T _ P A R S E _ R G B
 *
 *  Parse a slash (or other non-numeric, non-whitespace) separated string
 *  as 3 decimal (or octal) bytes.  Useful for entering rgb values in
 *  mlib_parse as 4/5/6.
 *
 *  Element [3] is made non-zero to indicate that a value has been set.
 */
HIDDEN void
rt_parse_rgb( rgb, str )
register unsigned char *rgb;
register char *str;
{
	if( !isdigit(*str) )  return;
	rgb[0] = atoi(str);
	rgb[1] = rgb[2] = 0;
d68 1
a68 9
	while( *str )
		if( !isdigit(*str++) )  break;
	if( !*str )  return;
	rgb[1] = atoi(str);
	while( *str )
		if( !isdigit(*str++) )  break;
	if( !*str )  return;
	rgb[2] = atoi(str);
}
d70 10
d81 3
a83 15
/*
 *			R T _ P A R S E _ V E C T
 *
 *  Parse a comma separated string
 *  as a vect_t (3 fastf_t's).  Useful for entering vector values in
 *  mlib_parse as 1.0/0.5/0.1.
 */
HIDDEN void
rt_parse_vect( vp, str )
register fastf_t	*vp;
register char		*str;
{
	vp[0] = vp[1] = vp[2] = 0.0;
	if( !isdigit(*str) && *str != '.' )  return;
	vp[0] = atof(str);
d85 3
a87 4
	while( *str && *str != ',')
		str++;
	if (!*str) return;
	vp[1] = atof(++str);
d89 3
a91 4
	while( *str && *str != ',')
		str++;
	if (!*str) return;
	vp[2] = atof(++str);
d93 13
d116 4
a119 4
rt_struct_lookup( spp, name, base, value )
register struct structparse	*spp;
register char			*name;
char				*base;
d123 1
d125 4
a128 3
	for( ; spp->sp_name != (char *)0; spp++ )  {
		if( strcmp( spp->sp_name, name ) != 0
		    && spp->sp_fmt[0] != 'i' )
d131 4
d136 1
a136 1
		loc = (char *)(base + ((int)spp->sp_offset*sizeof(int)));
d138 1
a138 1
		loc = (char *)(base + ((int)spp->sp_offset));
d141 1
a141 2
		switch( spp->sp_fmt[0] )  {
		case 'i':
d144 1
a144 1
				(struct structparse *)spp->sp_offset,
d148 8
a155 3
			break;
		case '%':
			switch( spp->sp_fmt[1] )  {
d157 7
a163 16
			case 'C':
				rt_parse_rgb( loc, value );
				break;
			case 'V':
				rt_parse_vect( loc, value );
				break;
			case 'M':
				rt_parse_mat( loc, value );
				break;
			case 'f':
				/*  Silicon Graphics sucks wind.
				 *  On the 3-D machines, float==double,
				 *  which breaks the scanf() strings.
				 *  So, here we cause "%f" to store into
				 *  a double.  This is the "generic"
				 *  floating point read.  Humbug.
d165 9
a173 8
				*((double *)loc) = atof( value );
				break;
			case 's':
				strcpy((char *)loc, value);
				break;
			default:
				(void)sscanf( value, spp->sp_fmt, loc );
				break;
d176 81
d259 1
a259 1
				name, spp->sp_fmt );
d261 1
d263 2
a264 3
		if( spp->sp_hook != FUNC_NULL )  {
			/* XXX What should the args be? */
			spp->sp_hook( spp, name, base, value );
d273 2
d277 1
a277 1
rt_structparse( vls, parsetab, base )
d279 1
a279 1
struct structparse	*parsetab;
d287 4
d292 1
d296 1
a296 1
		/* NAME = VALUE separator (comma, space, tab) */
d299 1
a299 2
		while( *cp != '\0' && 
		    (*cp == ',' || (isascii(*cp) && isspace(*cp)) ))
d304 3
a306 1
		while( *cp != '\0' && *cp != '=' )  cp++;
d308 6
a313 2
			if( name == cp )  break;
			rt_log("rt_structparse: name '%s' without '='\n", name );
d315 1
a318 1
		value = cp;
d320 8
a327 1
			/* strings are double-quote (") delimited */
d329 9
a337 2
			value = ++cp; /* skip leading " */
			while (*cp != '\0' && *cp != '"')
d339 1
a340 4
		} else	/* non-strings are white-space delimited */
			while( *cp != '\0' && isascii(*cp) && !isspace(*cp) )
				cp++;
		
d344 2
a345 2
		/* Lookup name in parsetab table */
		if( rt_struct_lookup( parsetab, name, base, value ) < 0 )  {
d348 1
a348 1
			rt_structprint( "troublesome one", parsetab, base );
d351 1
a353 2


d390 1
a390 1
struct structparse	*parsetab;
d393 1
a393 1
	register struct structparse	*spp;
d398 5
a402 1
	for( spp = parsetab; spp->sp_name != (char *)0; spp++ )  {
d405 1
a405 1
		if( lastoff == spp->sp_offset )
d407 1
a407 1
		lastoff = spp->sp_offset;
d410 1
a410 1
		loc = (char *)(base + ((int)spp->sp_offset*sizeof(int)));
d412 1
a412 1
		loc = (char *)(base + ((int)spp->sp_offset));
d415 3
a417 4
		switch( spp->sp_fmt[0] )  {
		case 'i':
			rt_structprint( spp->sp_name,
				(struct structparse *)spp->sp_offset,
d419 2
a420 3
			break;
		case '%':
			switch( spp->sp_fmt[1] )  {
d422 10
a431 2
			case 'c':
				rt_log( " %s=%c\n", spp->sp_name, *loc);
d433 4
a436 2
			case 's':
				rt_log( " %s=\"%s\"\n", spp->sp_name,
d438 63
a500 16
				break;
			case 'd':
				rt_log( " %s=%d\n", spp->sp_name,
					*((int *)loc) );
				break;
			case 'f':
				rt_log( " %s=%.-25G\n", spp->sp_name,
					*((double *)loc) );
				break;
			case 'C':
				{
					register unsigned char *cp =
						(unsigned char *)loc;
					rt_log(" %s=%d/%d/%d\n", spp->sp_name,
						cp[0], cp[1], cp[2] );
					break;
a501 14
			case 'M': matprint(spp->sp_name, (matp_t)loc);
				break;
			case 'V':
				{
					register fastf_t *fp = (fastf_t *)loc;
					rt_log(" %s=%.-25G  %.-25G  %.-25G\n",
						spp->sp_name,
						fp[0], fp[1], fp[2] );
					break;
				}
			default:
				rt_log( " %s=%s??\n", spp->sp_name,
					spp->sp_fmt );
				break;
d504 9
d514 2
a515 2
			rt_log("rt_structprint:  %s: unknown format '%s'\n",
				spp->sp_name, spp->sp_fmt );
d521 26
a546 1
/*	R T _ V L S _ S T R U C T P R I N T
d552 1
a552 1
rt_vls_structprint( vls, ptab, base)
d554 1
a554 1
register struct structparse	*ptab;
d563 6
a568 1
	for ( ; ptab->sp_name != (char*)NULL ; ptab++) {
d571 1
a571 1
		if( lastoff == ptab->sp_offset )
d573 1
a573 1
		lastoff = ptab->sp_offset;
d576 1
a576 1
		loc = (char *)(base + ((int)ptab->sp_offset*sizeof(int)));
d578 1
a578 1
		loc = (char *)(base + ((int)ptab->sp_offset));
d581 2
a582 4
		switch( ptab->sp_fmt[0] )  {
		case 'i':
			{
				struct rt_vls sub_str;
d584 4
a587 4
				rt_vls_init(&sub_str);
				rt_vls_structprint( &sub_str,
					(struct structparse *)ptab->sp_offset,
					base );
d589 4
a592 6
				rt_vls_vlscat(vls, &sub_str);
				rt_vls_free( &sub_str );
				break;
			}
		case '%':
			switch( ptab->sp_fmt[1] )  {
d594 10
a603 6
			case 'c':
				rt_vls_extend(vls, strlen(ptab->sp_name)+4);
				cp = &vls->vls_str[vls->vls_len];
				sprintf(cp, " %s=%c",
					ptab->sp_name, (char)(*loc));
				vls->vls_len += strlen(cp);
d605 2
a606 3
			case 's':
				rt_vls_extend(vls, strlen(ptab->sp_name)+
					strlen(loc)+6);
d608 22
a629 6
				sprintf(cp, " %s=\"%s\"",
				 	ptab->sp_name, loc);
				vls->vls_len += strlen(cp);
				break;
			case 'd':
				rt_vls_extend(vls, 64+strlen(ptab->sp_name)+3);
d631 26
a656 6
				sprintf(cp, " %s=%d",
					ptab->sp_name, *((int *)loc) );
				vls->vls_len += strlen(cp);
				break;
			case 'f':
				rt_vls_extend(vls, 32+strlen(ptab->sp_name));
d658 3
a660 2
				sprintf(cp, " %s=%.27E",
					ptab->sp_name, *((double *)loc) );
d662 6
a667 5
				break;
			case 'C':
				{
					register unsigned char *ucp =
						(unsigned char *)loc;
d669 2
a670 12
					rt_vls_extend(vls,
						16+strlen(ptab->sp_name) );
					/* WARNING: peeks inside rt_vls structure */
					cp = &vls->vls_str[vls->vls_len];
					sprintf( cp, " %s=%d/%d/%d",
						ptab->sp_name,
						ucp[0], ucp[1], ucp[2]);
					vls->vls_len += strlen(cp);
					break;
				}
			case 'M':
				{	register fastf_t *fp = (fastf_t *)loc;
d672 6
a677 2
					rt_vls_extend(vls,
						365+strlen(ptab->sp_name));
d679 5
a683 14
					cp = &vls->vls_str[vls->vls_len];
					sprintf(cp,
" %s=\
%.27E,%.27E,%.27E,%.27E,\
%.27E,%.27E,%.27E,%.27E,\
%.27E,%.27E,%.27E,%.27E,\
%.27E,%.27E,%.27E,%.27E",
						ptab->sp_name,
						fp[0], fp[1], fp[2], fp[3],
						fp[4], fp[5], fp[6], fp[7],
						fp[8], fp[9], fp[10],fp[11],
						fp[12],fp[13],fp[14],fp[15]);
					vls->vls_len += strlen(cp);
					break;
d685 6
a690 3
			case 'V':
				{
					register fastf_t *fp = (fastf_t *)loc;
d692 2
a693 1
					rt_vls_extend(vls, 96);
d695 12
a706 6
					cp = &vls->vls_str[vls->vls_len];
					sprintf(cp, " %s=%.27E,%.27E,%.27E",
						ptab->sp_name,
						fp[0], fp[1], fp[2] );
					vls->vls_len += strlen(cp);
					break;
a707 5
			default:
				rt_log( " %s=%s??\n", ptab->sp_name,
					ptab->sp_fmt );
				abort();
				break;
d710 19
d730 2
a731 2
			rt_log("rt_structprint:  %s: unknown format '%s'\n",
				ptab->sp_name, ptab->sp_fmt );
@


9.2
log
@added rt_vls_structprint for printing to a vls string
added pretty-print of matrix and character types.
@
text
@d24 1
a24 1
static char RCSparse[] = "@@(#)$Header: /m/cad/librt/RCS/parse.c,v 9.1 89/05/19 05:56:53 mike Rel3_5 $ (BRL)";
d454 1
a454 1
					register unsigned char *cp =
d459 1
a459 1

d461 1
a461 1
					sprintf(cp, " %s=%d/%d/%d",
d463 1
a463 1
						cp[0], cp[1], cp[2]);
@


9.1
log
@Release_3.5
@
text
@d24 1
a24 1
static char RCSparse[] = "@@(#)$Header: parse.c,v 1.7 89/04/14 03:00:27 mike Exp $ (BRL)";
d40 25
d82 1
a82 1
	rgb[3] = 1;
d93 1
d97 1
a97 1
 *  Parse a slash (or other non-numeric, non-whitespace) separated string
d109 2
a110 5
	while( *str ) {
		if( !isdigit(*str) && *str != '.' ) {
			str++;
			break;
		}
d112 4
a115 8
	}
	if( !*str )  return;
	vp[1] = atof(str);
	while( *str ) {
		if( !isdigit(*str) && *str != '.' ) {
			str++;
			break;
		}
d117 3
a119 3
	}
	if( !*str )  return;
	vp[2] = atof(str);
d167 3
d180 3
d195 1
a195 1
			spp->sp_hook( spp, base, value );
d206 2
a207 2
rt_structparse( cp, parsetab, base )
register char		*cp;
d211 1
d215 4
d224 1
a224 1
		    (*cp == ',' || *cp == ' ' || *cp == '\t' ) )
d236 1
a236 1
		/* Find end of value */
d238 11
a248 3
		while( *cp != '\0' && *cp != ',' &&
		    *cp != ' ' && *cp != '\t' )
			cp++;
d261 32
d298 1
a298 1
char			*title;
d329 3
d333 1
a333 1
				rt_log( " %s=%s\n", spp->sp_name,
d341 1
a341 1
				rt_log( " %s=%g\n", spp->sp_name,
d348 2
a349 2
					rt_log(" %s=%d/%d/%d(%d)\n", spp->sp_name,
						cp[0], cp[1], cp[2], cp[3] );
d352 2
d356 3
a358 3
					register fastf_t *fp =
						(fastf_t *)loc;
					rt_log(" %s=%f/%f/%f\n", spp->sp_name,
d371 140
@


1.7
log
@Indirect table entry moved back to sp_offset (from sp_hook)
because the XMP didn't like having a data space address stuffed
into a function pointer (instruction space address).
sp_offset is now always &element;  when this is NOT a byte offset
(such as on the Cray), compensation is applied here in parse.c
@
text
@d24 1
a24 1
static char RCSparse[] = "@@(#)$Header: parse.c,v 1.6 89/04/04 23:40:54 mike Locked $ (BRL)";
@


1.6
log
@oops, changed to use "hook" rather than "offset" values
@
text
@d24 1
a24 1
static char RCSparse[] = "@@(#)$Header: parse.c,v 1.5 89/04/04 04:57:47 mike Locked $ (BRL)";
d124 3
d128 1
d134 1
a134 1
				(struct structparse *)spp->sp_hook,
d244 3
d248 1
d253 1
a253 1
				(struct structparse *)spp->sp_hook,
@


1.5
log
@Converted to new way of handling structure offsets
@
text
@d24 1
a24 1
static char RCSparse[] = "@@(#)$Header: parse.c,v 1.4 89/03/15 15:30:14 mike Locked $ (BRL)";
d130 1
a130 1
				(struct structparse *)spp->sp_offset,
d245 1
a245 1
				(struct structparse *)spp->sp_offset,
@


1.4
log
@Eliminated unused variable.
@
text
@d24 1
a24 1
static char RCSparse[] = "@@(#)$Header: parse.c,v 1.3 89/03/06 20:56:43 mike Locked $ (BRL)";
a39 3
extern void	rt_structparse();
extern void	rt_structprint();

d114 1
a114 1
stroff_t			base;
d180 1
a180 1
stroff_t		base;		/* base address of users structure */
d226 1
a226 1
stroff_t		base;		/* base address of users structure */
d230 1
a230 1
	register stroff_t		lastoff = (stroff_t)(-1);
@


1.3
log
@Added some additional debugging aids
@
text
@d24 1
a24 1
static char RCSparse[] = "@@(#)$Header: /n/spark/m/cad/librt/RCS/parse.c,v 1.2 89/03/03 02:30:34 phil Exp $ (BRL)";
d34 6
a184 1
	register struct structparse *spp;
@


1.2
log
@Needed to check for parse table indirects before failing lookup.
@
text
@d24 1
a24 1
static char RCSparse[] = "@@(#)$Header: parse.c,v 1.1 88/12/27 13:39:02 phil Locked $ (BRL)";
d34 3
d195 2
a196 1
			rt_log("rt_structparse: name %s without value\n", name );
d210 1
a210 1
			rt_log("rt_structparse:  %s=%s not a valid arg\n",
d212 1
d250 2
a251 1
				rt_log( " %s=%s\n", spp->sp_name, (char *)loc );
@


1.1
log
@Initial revision
@
text
@d24 1
a24 1
static char RCSparse[] = "@@(#)$Header: material.c,v 8.2 88/12/15 03:33:48 phil Exp $ (BRL)";
d114 2
a115 1
		if( strcmp( spp->sp_name, name ) != 0 )
@
