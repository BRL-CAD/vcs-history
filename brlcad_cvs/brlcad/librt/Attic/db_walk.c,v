head	11.18;
access;
symbols
	ansi-20040405-merged:11.14.2.2
	postmerge-20040405-ansi:11.16
	premerge-20040404-ansi:11.15
	postmerge-autoconf:11.15
	autoconf-freeze:11.14.10.2
	premerge-autoconf:11.15
	ansi-20040316-freeze:11.14.2.1
	postmerge-20040315-windows:11.15
	premerge-20040315-windows:11.15
	windows-20040315-freeze:11.14.4.1
	autoconf-20031203:11.14
	autoconf-20031202:11.14
	autoconf-branch:11.14.0.10
	phong-branch:11.14.0.8
	photonmap-branch:11.14.0.6
	rel-6-1-DP:11.14
	windows-branch:11.14.0.4
	rel-6-0-2:11.12
	ansi-branch:11.14.0.2
	rel-6-0-1-branch:11.12.0.2
	hartley-6-0-post:11.13
	hartley-6-0-pre:11.12
	rel-6-0-1:11.12
	rel-6-0:11.12
	rel-5-4:11.7
	offsite-5-3-pre:11.10
	rel-5-3:11.7
	rel-5-2:11.7
	rel-5-1-branch:11.7.0.2
	rel-5-1:11.7
	rel-5-0:11.6
	rel-5-0-beta:11.6
	rel-4-5:11.6
	ctj-4-5-post:11.5
	ctj-4-5-pre:11.5
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1;
locks; strict;
comment	@ * @;


11.18
date	2004.05.21.18.07.30;	author morrison;	state dead;
branches;
next	11.17;

11.17
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.16;

11.16
date	2004.04.05.08.48.56;	author morrison;	state Exp;
branches;
next	11.15;

11.15
date	2004.02.02.17.39.15;	author morrison;	state Exp;
branches;
next	11.14;

11.14
date	2002.08.20.17.07.58;	author jra;	state Exp;
branches
	11.14.2.1
	11.14.4.1
	11.14.10.1;
next	11.13;

11.13
date	2002.08.15.20.55.10;	author hartley;	state Exp;
branches;
next	11.12;

11.12
date	2001.08.28.20.19.45;	author jra;	state Exp;
branches;
next	11.11;

11.11
date	2001.05.17.20.05.24;	author morrison;	state Exp;
branches;
next	11.10;

11.10
date	2000.10.24.14.12.25;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	2000.10.20.20.31.04;	author jra;	state Exp;
branches;
next	11.8;

11.8
date	2000.07.10.23.01.28;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	99.12.29.21.09.42;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	97.12.16.06.09.51;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	97.01.31.05.01.13;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	97.01.30.21.13.30;	author jra;	state Exp;
branches;
next	11.3;

11.3
date	97.01.30.20.32.49;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	96.09.27.08.27.30;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.56.21;	author mike;	state Rel4_4;
branches;
next	10.2;

10.2
date	94.08.10.18.21.53;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.40.06;	author mike;	state Rel4_0;
branches;
next	9.3;

9.3
date	90.12.11.22.04.01;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	90.11.02.03.39.48;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.55.50;	author mike;	state Rel3_5;
branches;
next	1.1;

1.1
date	88.12.06.00.09.26;	author mike;	state Exp;
branches;
next	;

11.14.2.1
date	2002.09.19.18.01.32;	author morrison;	state Exp;
branches;
next	11.14.2.2;

11.14.2.2
date	2004.03.17.21.18.44;	author morrison;	state Exp;
branches;
next	;

11.14.4.1
date	2004.03.11.23.43.36;	author morrison;	state Exp;
branches;
next	;

11.14.10.1
date	2004.02.12.18.37.39;	author erikg;	state Exp;
branches;
next	11.14.10.2;

11.14.10.2
date	2004.03.15.14.07.17;	author erikg;	state Exp;
branches;
next	;


desc
@db_walk
@


11.18
log
@moved to src/
@
text
@/*
 *			D B _ W A L K . C
 *
 * Functions -
 *	db_functree	No-frills tree-walk
 *	comb_functree	No-frills combination-walk
 *
 *
 *  Authors -
 *	Michael John Muuss
 *	John R. Anderson
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1988-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/db_walk.c,v 11.17 2004/05/10 15:30:46 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"
#include "vmath.h"
#include "db.h"
#include "raytrace.h"

#include "./debug.h"

void
db_functree_subtree(struct db_i *dbip, union tree *tp, void (*comb_func) (struct db_i *, struct directory *, genptr_t), void (*leaf_func) (struct db_i *, struct directory *, genptr_t), struct resource *resp, genptr_t client_data)
{
	struct directory *dp;

	if( !tp )
		return;

	RT_CHECK_DBI( dbip );
	RT_CK_TREE( tp );
	RT_CK_RESOURCE( resp );

	switch( tp->tr_op )  {

		case OP_DB_LEAF:
			if( (dp=db_lookup( dbip, tp->tr_l.tl_name, LOOKUP_NOISY )) == DIR_NULL )
				return;
			db_functree( dbip, dp, comb_func, leaf_func, resp, client_data);
			break;

		case OP_UNION:
		case OP_INTERSECT:
		case OP_SUBTRACT:
		case OP_XOR:
			db_functree_subtree( dbip, tp->tr_b.tb_left, comb_func, leaf_func, resp, client_data );
			db_functree_subtree( dbip, tp->tr_b.tb_right, comb_func, leaf_func, resp, client_data );
			break;
		default:
			bu_log( "db_functree_subtree: unrecognized operator %d\n", tp->tr_op );
			bu_bomb( "db_functree_subtree: unrecognized operator\n" );
	}
}

/*
 *			D B _ F U N C T R E E
 *
 *  This subroutine is called for a no-frills tree-walk,
 *  with the provided subroutines being called at every combination
 *  and leaf (solid) node, respectively.
 *
 *  This routine is recursive, so no variables may be declared static.
 *  
 */
void
db_functree(struct db_i *dbip, struct directory *dp, void (*comb_func) (struct db_i *, struct directory *, genptr_t), void (*leaf_func) (struct db_i *, struct directory *, genptr_t), struct resource *resp, genptr_t client_data)
{
	register int		i;

	RT_CK_DBI(dbip);
	if(RT_G_DEBUG&DEBUG_DB) bu_log("db_functree(%s) x%x, x%x, comb=x%x, leaf=x%x, client_data=x%x\n",
		dp->d_namep, dbip, dp, comb_func, leaf_func, client_data );

	if( dp->d_flags & DIR_COMB )  {
		if( dbip->dbi_version < 5 ) {
			register union record	*rp;
			register struct directory *mdp;
			/*
			 * Load the combination into local record buffer
			 * This is in external v4 format.
			 */
			if( (rp = db_getmrec( dbip, dp )) == (union record *)0 )
				return;

			/* recurse */
			for( i=1; i < dp->d_len; i++ )  {
				if( (mdp = db_lookup( dbip, rp[i].M.m_instname,
				    LOOKUP_NOISY )) == DIR_NULL )
					continue;
				db_functree( dbip, mdp, comb_func, leaf_func, resp, client_data );
			}
			bu_free( (char *)rp, "db_functree record[]" );
		} else {
			struct rt_db_internal in;
			struct rt_comb_internal *comb;

			if( rt_db_get_internal5( &in, dp, dbip, NULL, resp ) < 0 )
				return;

			comb = (struct rt_comb_internal *)in.idb_ptr;
			db_functree_subtree( dbip, comb->tree, comb_func,
				leaf_func, resp, client_data );
			rt_db_free_internal( &in, resp );
		}

		/* Finally, the combination itself */
		if( comb_func )
			comb_func( dbip, dp, client_data );

	} else if( dp->d_flags & DIR_SOLID || dp->d_major_type & DB5_MAJORTYPE_BINARY_MASK )  {
		if( leaf_func )
			leaf_func( dbip, dp, client_data );
	} else {
		bu_log("db_functree:  %s is neither COMB nor SOLID?\n",
			dp->d_namep );
	}
}
@


11.17
log
@change conf.h to a wrapped config.h
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/librt/db_walk.c,v 11.16 2004/04/05 08:48:56 morrison Exp $ (BRL)";
@


11.16
log
@merge of ansi-6-0-branch into HEAD
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d26 5
a30 1
#include "conf.h"
@


11.15
log
@update copyright to include span through 2003
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_walk.c,v 11.14 2002/08/20 17:07:58 jra Exp $ (BRL)";
d43 1
a43 7
db_functree_subtree( dbip, tp, comb_func, leaf_func, resp, client_data )
struct db_i	*dbip;
union tree	*tp;
void		(*comb_func)BU_ARGS((struct db_i *, struct directory *, genptr_t));
void		(*leaf_func)BU_ARGS((struct db_i *, struct directory *, genptr_t));
struct resource *resp;
genptr_t	client_data;
d86 1
a86 7
db_functree( dbip, dp, comb_func, leaf_func, resp, client_data)
struct db_i	*dbip;
struct directory *dp;
void		(*comb_func)BU_ARGS((struct db_i *, struct directory *, genptr_t));
void		(*leaf_func)BU_ARGS((struct db_i *, struct directory *, genptr_t));
struct resource *resp;
genptr_t	client_data;
@


11.14
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1988 by the United States Army.
d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_walk.c,v 11.12 2001/08/28 20:19:45 jra Exp $ (BRL)";
@


11.14.4.1
log
@sync to HEAD...
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1988-2004 by the United States Army.
d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/db_walk.c,v 11.15 2004/02/02 17:39:15 morrison Exp $ (BRL)";
@


11.14.10.1
log
@merge from HEAD
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1988-2004 by the United States Army.
d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_walk.c,v 11.15 2004/02/02 17:39:15 morrison Exp $ (BRL)";
@


11.14.10.2
log
@merge from head
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_walk.c,v 11.14.10.1 2004/02/12 18:37:39 erikg Exp $ (BRL)";
@


11.14.2.1
log
@Initial ANSIfication
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_walk.c,v 11.14 2002/08/20 17:07:58 jra Exp $ (BRL)";
d43 7
a49 1
db_functree_subtree(struct db_i *dbip, union tree *tp, void (*comb_func) (struct db_i *, struct directory *, genptr_t), void (*leaf_func) (struct db_i *, struct directory *, genptr_t), struct resource *resp, genptr_t client_data)
d92 7
a98 1
db_functree(struct db_i *dbip, struct directory *dp, void (*comb_func) (struct db_i *, struct directory *, genptr_t), void (*leaf_func) (struct db_i *, struct directory *, genptr_t), struct resource *resp, genptr_t client_data)
@


11.14.2.2
log
@sync branch with HEAD
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1988-2004 by the United States Army.
d23 1
a23 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.13
log
@Converted from K&R to ANSI C - RFH
@
text
@d43 7
a49 1
db_functree_subtree(struct db_i *dbip, union tree *tp, void (*comb_func) (struct db_i *, struct directory *, genptr_t), void (*leaf_func) (struct db_i *, struct directory *, genptr_t), struct resource *resp, genptr_t client_data)
d92 7
a98 1
db_functree(struct db_i *dbip, struct directory *dp, void (*comb_func) (struct db_i *, struct directory *, genptr_t), void (*leaf_func) (struct db_i *, struct directory *, genptr_t), struct resource *resp, genptr_t client_data)
@


11.12
log
@db_functree() now handles binary objects
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_walk.c,v 11.11 2001/05/17 20:05:24 morrison Exp $ (BRL)";
d43 1
a43 7
db_functree_subtree( dbip, tp, comb_func, leaf_func, resp, client_data )
struct db_i	*dbip;
union tree	*tp;
void		(*comb_func)BU_ARGS((struct db_i *, struct directory *, genptr_t));
void		(*leaf_func)BU_ARGS((struct db_i *, struct directory *, genptr_t));
struct resource *resp;
genptr_t	client_data;
d86 1
a86 7
db_functree( dbip, dp, comb_func, leaf_func, resp, client_data)
struct db_i	*dbip;
struct directory *dp;
void		(*comb_func)BU_ARGS((struct db_i *, struct directory *, genptr_t));
void		(*leaf_func)BU_ARGS((struct db_i *, struct directory *, genptr_t));
struct resource *resp;
genptr_t	client_data;
@


11.11
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_walk.c,v 11.10 2000/10/24 14:12:25 mike Exp $ (BRL)";
d142 1
a142 1
	} else if( dp->d_flags & DIR_SOLID )  {
@


11.10
log
@
Eliminated unused vars.
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_walk.c,v 11.9 2000/10/20 20:31:04 jra Exp $ (BRL)";
d103 1
a103 1
	if(rt_g.debug&DEBUG_DB) bu_log("db_functree(%s) x%x, x%x, comb=x%x, leaf=x%x, client_data=x%x\n",
@


11.9
log
@Made db_functree work for v5 databases
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_walk.c,v 11.8 2000/07/10 23:01:28 mike Exp $ (BRL)";
a127 2
			union tree *tp;
			int id;
d129 1
a129 1
			if( (id=rt_db_get_internal5( &in, dp, dbip, NULL, resp )) < 0 )
d133 2
a134 2
			tp = comb->tree;
			db_functree_subtree( dbip, tp, comb_func, leaf_func, resp, client_data );
@


11.8
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_walk.c,v 11.7 1999/12/29 21:09:42 mike Exp $ (BRL)";
d42 39
d92 1
a92 1
db_functree( dbip, dp, comb_func, leaf_func, client_data)
d97 1
a99 1
	register union record	*rp;
a100 1
	register struct directory *mdp;
d107 31
a137 13
		/*
		 * Load the combination into local record buffer
		 * This is in external v4 format.
		 */
		if( (rp = db_getmrec( dbip, dp )) == (union record *)0 )
			return;

		/* recurse */
		for( i=1; i < dp->d_len; i++ )  {
			if( (mdp = db_lookup( dbip, rp[i].M.m_instname,
			    LOOKUP_NOISY )) == DIR_NULL )
				continue;
			db_functree( dbip, mdp, comb_func, leaf_func, client_data );
a143 1
		bu_free( (char *)rp, "db_functree record[]" );
@


11.7
log
@Added client_data pointer to db_functree() to eliminate use of
global variables.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_walk.c,v 11.6 1997/12/16 06:09:51 mike Exp $ (BRL)";
@


11.6
log
@Ran h/sed4
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_walk.c,v 11.5 1997/01/31 05:01:13 mike Exp mike $ (BRL)";
d53 1
a53 1
db_functree( dbip, dp, comb_func, leaf_func)
d56 3
a58 2
void		(*comb_func)();
void		(*leaf_func)();
d64 3
a66 9
	if( dbip->dbi_magic != DBI_MAGIC )  rt_bomb("db_gettree:  bad dbip\n");
	if(rt_g.debug&DEBUG_DB) bu_log("db_functree(%s) x%x, x%x, comb=x%x, leaf=x%x\n",
		dp->d_namep, dbip, dp, comb_func, leaf_func );

	/*
	 * Load the first record of the object into local record buffer
	 */
	if( (rp = db_getmrec( dbip, dp )) == (union record *)0 )
		return;
d69 7
d81 1
a81 1
			db_functree( dbip, mdp, comb_func, leaf_func );
d86 3
a88 1
			comb_func( dbip, dp );
d91 1
a91 1
			leaf_func( dbip, dp );
a95 1
	bu_free( (char *)rp, "db_functree record[]" );
@


11.5
log
@renamed comb_functree() to db_tree_funcleaf(),
moved from db_walk.c to db_tree.c
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_walk.c,v 11.4 1997/01/30 21:13:30 jra Exp mike $ (BRL)";
d92 1
a92 1
	rt_free( (char *)rp, "db_functree record[]" );
@


11.4
log
@Added a second user pointer to comb_functree().
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_walk.c,v 11.3 1997/01/30 20:32:49 jra Exp jra $ (BRL)";
a92 42
}

/*		C O M B _ F U N C T R E E
 *
 *	This routine traverses a combination (union tree) in LNR order
 *	and calls the provided function for each leaf node.
 *	Note that this routine does not go outside this one
 *	combination!!!!
 *
 */
void
comb_functree( dbip, comb, comb_tree, leaf_func, user_ptr1, user_ptr2 )
struct db_i		*dbip;
struct rt_comb_internal	*comb;
union tree		*comb_tree;
void			(*leaf_func)();
genptr_t		user_ptr1,user_ptr2;
{
	RT_CK_DBI( dbip );

	if( !comb_tree )
		return;

	RT_CK_TREE( comb_tree );

	switch( comb_tree->tr_op )
	{
		case OP_DB_LEAF:
			(*leaf_func)( dbip, comb, comb_tree, user_ptr1, user_ptr2 );
			break;
		case OP_UNION:
		case OP_INTERSECT:
		case OP_SUBTRACT:
		case OP_XOR:
			comb_functree( dbip, comb, comb_tree->tr_b.tb_left, leaf_func, user_ptr1, user_ptr2 );
			comb_functree( dbip, comb, comb_tree->tr_b.tb_right, leaf_func, user_ptr1, user_ptr2 );
			break;
		default:
			bu_log( "comb_functree: bad op %d\n", comb_tree->tr_op );
			bu_bomb( "comb_functree: bad op\n" );
			break;
	}
@


11.3
log
@Added comb_functree().
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_walk.c,v 11.2 1996/09/27 08:27:30 mike Exp jra $ (BRL)";
d104 1
a104 1
comb_functree( dbip, comb_tree, leaf_func, user_ptr )
d106 1
d109 1
a109 1
genptr_t		user_ptr;
d121 1
a121 1
			(*leaf_func)( dbip, comb_tree, user_ptr );
d127 2
a128 2
			comb_functree( dbip, comb_tree->tr_b.tb_left, leaf_func, user_ptr );
			comb_functree( dbip, comb_tree->tr_b.tb_right, leaf_func, user_ptr );
@


11.2
log
@Converted to using proper routine names for LIBBU and LIBBN routines.
@
text
@d6 1
d11 1
d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_walk.c,v 11.1 1995/01/04 09:56:21 mike Rel4_4 mike $ (BRL)";
d93 41
@


11.1
log
@Release_4.4
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_walk.c,v 10.2 94/08/10 18:21:53 gdurf Exp $ (BRL)";
d62 1
a62 1
	if(rt_g.debug&DEBUG_DB) rt_log("db_functree(%s) x%x, x%x, comb=x%x, leaf=x%x\n",
d87 1
a87 1
		rt_log("db_functree:  %s is neither COMB nor SOLID?\n",
@


10.2
log
@Factored ifdefs
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_walk.c,v 10.1 1991/10/12 06:40:06 mike Rel4_0 gdurf $ (BRL)";
@


10.1
log
@Release_4.0
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_walk.c,v 9.3 90/12/11 22:04:01 mike Exp $ (BRL)";
d24 2
d27 3
a29 1
#ifdef BSD
a30 2
#else
#include <string.h>
@


9.3
log
@For lint purposes, #include db.h must preceed #include machine.h,
so that union record is known.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_walk.c,v 9.2 90/11/02 03:39:48 mike Exp $ (BRL)";
@


9.2
log
@Changed rt_free message
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_walk.c,v 9.1 89/05/19 05:55:50 mike Rel3_5 $ (BRL)";
d33 1
a34 1
#include "db.h"
@


9.1
log
@Release_3.5
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: db_walk.c,v 1.1 88/12/06 00:09:26 mike Exp $ (BRL)";
d88 1
a88 1
	rt_free( (char *)rp, dp->d_namep );
@


1.1
log
@Initial revision
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /cad/d/mike/cad/libdb/RCS/walk.c,v 1.3 88/10/23 13:54:47 mike Exp $ (BRL)";
@
