head	11.32;
access;
symbols
	ansi-20040405-merged:11.27.2.2
	postmerge-20040405-ansi:11.30
	premerge-20040404-ansi:11.29
	postmerge-autoconf:11.29
	autoconf-freeze:11.27.10.3
	premerge-autoconf:11.29
	ansi-20040316-freeze:11.27.2.1
	postmerge-20040315-windows:11.29
	premerge-20040315-windows:11.28
	windows-20040315-freeze:11.27.4.2
	autoconf-20031203:11.27
	autoconf-20031202:11.27
	autoconf-branch:11.27.0.10
	phong-branch:11.27.0.8
	photonmap-branch:11.27.0.6
	rel-6-1-DP:11.27
	windows-branch:11.27.0.4
	rel-6-0-2:11.25
	ansi-branch:11.27.0.2
	rel-6-0-1-branch:11.25.0.2
	hartley-6-0-post:11.26
	hartley-6-0-pre:11.25
	rel-6-0-1:11.25
	rel-6-0:11.25
	rel-5-4:11.8
	offsite-5-3-pre:11.23
	rel-5-3:11.8
	rel-5-2:11.8
	rel-5-1-branch:11.8.0.2
	rel-5-1:11.8
	rel-5-0:11.6
	rel-5-0-beta:11.6
	rel-4-5:11.6
	ctj-4-5-post:11.5
	ctj-4-5-pre:11.5
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1;
locks; strict;
comment	@ * @;


11.32
date	2004.05.21.18.07.29;	author morrison;	state dead;
branches;
next	11.31;

11.31
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.30;

11.30
date	2004.04.05.08.48.56;	author morrison;	state Exp;
branches;
next	11.29;

11.29
date	2004.03.16.20.03.08;	author morrison;	state Exp;
branches;
next	11.28;

11.28
date	2004.02.02.17.39.15;	author morrison;	state Exp;
branches;
next	11.27;

11.27
date	2002.08.20.17.07.57;	author jra;	state Exp;
branches
	11.27.2.1
	11.27.4.1
	11.27.10.1;
next	11.26;

11.26
date	2002.08.15.20.55.09;	author hartley;	state Exp;
branches;
next	11.25;

11.25
date	2001.05.17.20.05.23;	author morrison;	state Exp;
branches;
next	11.24;

11.24
date	2001.04.20.22.29.41;	author morrison;	state Exp;
branches;
next	11.23;

11.23
date	2000.08.21.02.02.29;	author butler;	state Exp;
branches;
next	11.22;

11.22
date	2000.07.29.23.23.04;	author mike;	state Exp;
branches;
next	11.21;

11.21
date	2000.07.25.16.46.06;	author butler;	state Exp;
branches;
next	11.20;

11.20
date	2000.07.12.02.09.39;	author mike;	state Exp;
branches;
next	11.19;

11.19
date	2000.07.07.22.55.52;	author mike;	state Exp;
branches;
next	11.18;

11.18
date	2000.07.07.05.48.36;	author mike;	state Exp;
branches;
next	11.17;

11.17
date	2000.07.07.05.45.13;	author mike;	state Exp;
branches;
next	11.16;

11.16
date	2000.07.07.05.27.33;	author mike;	state Exp;
branches;
next	11.15;

11.15
date	2000.06.30.21.07.31;	author mike;	state Exp;
branches;
next	11.14;

11.14
date	2000.06.30.21.05.57;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	2000.06.30.21.00.10;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	2000.06.30.20.48.56;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	2000.06.30.20.21.50;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	2000.06.29.18.20.55;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	2000.06.27.17.33.13;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	2000.01.07.03.24.09;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	99.12.22.04.57.12;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	97.12.16.00.12.31;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	97.02.06.04.18.29;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	96.10.16.02.35.23;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	96.09.27.08.27.30;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	95.11.07.14.59.35;	author adam;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.56.15;	author mike;	state Rel4_4;
branches;
next	10.8;

10.8
date	94.11.04.05.39.00;	author mike;	state Exp;
branches;
next	10.7;

10.7
date	94.09.28.02.55.17;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	94.08.10.20.30.27;	author gdurf;	state Exp;
branches;
next	10.5;

10.5
date	94.08.10.17.57.48;	author gdurf;	state Exp;
branches;
next	10.4;

10.4
date	94.08.10.17.53.54;	author gdurf;	state Exp;
branches;
next	10.3;

10.3
date	92.02.05.15.26.49;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	92.02.05.13.18.42;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.40.01;	author mike;	state Rel4_0;
branches;
next	9.12;

9.12
date	91.10.04.06.28.25;	author butler;	state Exp;
branches;
next	9.11;

9.11
date	91.10.04.00.45.55;	author butler;	state Exp;
branches;
next	9.10;

9.10
date	91.09.27.19.29.33;	author phil;	state Exp;
branches;
next	9.9;

9.9
date	91.09.27.05.51.02;	author butler;	state Exp;
branches;
next	9.8;

9.8
date	91.07.06.00.53.00;	author mike;	state Exp;
branches;
next	9.7;

9.7
date	91.06.29.22.13.46;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	91.01.25.22.05.55;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	91.01.11.07.12.23;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	90.12.10.16.04.41;	author cjohnson;	state Exp;
branches;
next	9.3;

9.3
date	90.11.02.03.33.34;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	90.05.21.21.19.40;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.55.41;	author mike;	state Rel3_5;
branches;
next	1.4;

1.4
date	89.04.17.13.41.18;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	88.12.13.02.23.51;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	88.12.08.04.46.26;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	88.12.06.00.09.12;	author mike;	state Exp;
branches;
next	;

11.27.2.1
date	2002.09.19.18.01.31;	author morrison;	state Exp;
branches;
next	11.27.2.2;

11.27.2.2
date	2004.03.17.21.18.43;	author morrison;	state Exp;
branches;
next	;

11.27.4.1
date	2002.09.26.23.04.01;	author morrison;	state Exp;
branches;
next	11.27.4.2;

11.27.4.2
date	2004.03.11.23.43.35;	author morrison;	state Exp;
branches;
next	;

11.27.10.1
date	2004.02.12.18.37.38;	author erikg;	state Exp;
branches;
next	11.27.10.2;

11.27.10.2
date	2004.03.15.14.07.17;	author erikg;	state Exp;
branches;
next	11.27.10.3;

11.27.10.3
date	2004.03.18.18.10.29;	author erikg;	state Exp;
branches;
next	;


desc
@db_io
@


11.32
log
@moved to src/
@
text
@/*
 *			D B _ I O . C
 *
 * Functions -
 *	db_getmrec	Read all records into malloc()ed memory chunk
 *	db_get		Get records from database
 *	db_put		Put records to database
 *
 *
 *  Authors -
 *	Michael John Muuss
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1988-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/db_io.c,v 11.31 2004/05/10 15:30:46 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "db.h"
#include "raytrace.h"

#include "./debug.h"

/*
 *			D B _ R E A D
 *
 *  Reads 'count' bytes at file offset 'offset' into buffer at 'addr'.
 *  A wrapper for the UNIX read() sys-call that takes into account
 *  syscall semaphores, stdio-only machines, and in-memory buffering.
 *
 *  Returns -
 *	 0	OK
 *	-1	failure
 */
/* should be HIDDEN */
int
db_read(const struct db_i *dbip, genptr_t addr, long int count, long int offset)
                 	      
        	     
    		      		/* byte count */
    		       		/* byte offset from start of file */
{
	register int	got;
	register long	s;

	RT_CK_DBI(dbip);
	if(RT_G_DEBUG&DEBUG_DB)  {
		bu_log("db_read(dbip=x%x, addr=x%x, count=%d., offset=x%x)\n",
			dbip, addr, count, offset );
	}
	if( count <= 0 || offset < 0 )  {
		return(-1);
	}
	if( dbip->dbi_inmem )  {
		if( offset+count > dbip->dbi_eof )  {
			/* Attempt to read off the end of the (mapped) file */
			bu_log("db_read(%s) ERROR offset=%d, count=%d, dbi_eof=%d\n",
				dbip->dbi_filename,
				offset, count, dbip->dbi_eof );
			return -1;
		}
		memcpy( addr, ((char *)dbip->dbi_inmem) + offset, count );
		return(0);
	}
	bu_semaphore_acquire( BU_SEM_SYSCALL );
#ifdef HAVE_UNIX_IO
	if ((s=(long)lseek( dbip->dbi_fd, (off_t)offset, 0 )) != offset) {
		bu_log("db_read: lseek returns %d not %d\n", s, offset);
		bu_bomb("db_read: Goodbye");
	}
	got = read( dbip->dbi_fd, addr, count );
#else
	if (fseek( dbip->dbi_fp, offset, 0 ))
		bu_bomb("db_read: fseek error\n");
	got = fread( addr, 1, count, dbip->dbi_fp );
#endif
	bu_semaphore_release( BU_SEM_SYSCALL );

	if( got != count )  {
		perror("db_read");
		bu_log("db_read(%s):  read error.  Wanted %d, got %d bytes\n",
			dbip->dbi_filename, count, got );
		return(-1);
	}
	return(0);			/* OK */
}

/*
 *  			D B _ G E T M R E C
 *
 *  Retrieve all records in the database pertaining to an object,
 *  and place them in malloc()'ed storage, which the caller is
 *  responsible for free()'ing.
 *
 *  Returns -
 *	union record *		OK
 *	(union record *)0	failure
 */
union record *
db_getmrec(const struct db_i *dbip, const struct directory *dp)
{
	union record	*where;

	RT_CK_DBI(dbip);
	RT_CK_DIR(dp);
	if(RT_G_DEBUG&DEBUG_DB) bu_log("db_getmrec(%s) x%x, x%x\n",
		dp->d_namep, dbip, dp );

	if( dp->d_addr < 0 )
		return( (union record *)0 );	/* was dummy DB entry */
	where = (union record *)bu_malloc(
		dp->d_len * sizeof(union record),
		"db_getmrec record[]");

	if( dp->d_flags & RT_DIR_INMEM )  {
		bcopy( dp->d_un.ptr, (char *)where, dp->d_len * sizeof(union record) );
		return where;
	}

	if( db_read( dbip, (char *)where,
	    (long)dp->d_len * sizeof(union record),
	    dp->d_addr ) < 0 )  {
		bu_free( (genptr_t)where, "db_getmrec record[]" );
		return( (union record *)0 );	/* VERY BAD */
	}
	return( where );
}

/*
 *  			D B _ G E T
 *
 *  Retrieve 'len' records from the database,
 *  "offset" granules into this entry.
 *
 *  Returns -
 *	 0	OK
 *	-1	failure
 */
int
db_get(const struct db_i *dbip, const struct directory *dp, union record *where, int offset, int len)
{

	RT_CK_DBI(dbip);
	RT_CK_DIR(dp);
	if(RT_G_DEBUG&DEBUG_DB) bu_log("db_get(%s) x%x, x%x x%x off=%d len=%d\n",
		dp->d_namep, dbip, dp, where, offset, len );

	if( dp->d_addr < 0 )  {
		where->u_id = '\0';	/* undefined id */
		return(-1);
	}
	if( offset < 0 || offset+len > dp->d_len )  {
		bu_log("db_get(%s):  xfer %d..%x exceeds 0..%d\n",
			dp->d_namep, offset, offset+len, dp->d_len );
		where->u_id = '\0';	/* undefined id */
		return(-1);
	}

	if( dp->d_flags & RT_DIR_INMEM )  {
		bcopy( ((char *)dp->d_un.ptr) + offset * sizeof(union record),
			(char *)where,
			len * sizeof(union record) );
		return 0;		/* OK */
	}

	if( db_read( dbip, (char *)where, (long)len * sizeof(union record),
	    dp->d_addr + offset * sizeof(union record) ) < 0 )  {
		where->u_id = '\0';	/* undefined id */
		return(-1);
	}
	return(0);			/* OK */
}

/*
 *			D B _ W R I T E
 *
 *  Writes 'count' bytes into at file offset 'offset' from buffer at 'addr'.
 *  A wrapper for the UNIX write() sys-call that takes into account
 *  syscall semaphores, stdio-only machines, and in-memory buffering.
 *
 *  Returns -
 *	 0	OK
 *	-1	failure
 */
/* should be HIDDEN */
int
db_write(struct db_i *dbip, const genptr_t addr, long int count, long int offset)
{
	register int	got;

	RT_CK_DBI(dbip);
	if(RT_G_DEBUG&DEBUG_DB)  {
		bu_log("db_write(dbip=x%x, addr=x%x, count=%d., offset=x%x)\n",
			dbip, addr, count, offset );
	}
	if( dbip->dbi_read_only )  {
		bu_log("db_write(%s):  READ-ONLY file\n",
			dbip->dbi_filename);
		return(-1);
	}
	if( count <= 0 || offset < 0 )  {
		return(-1);
	}
	if( dbip->dbi_inmem )  {
		bu_log("db_write() in memory?\n");
		return(-1);
	}
	bu_semaphore_acquire( BU_SEM_SYSCALL );
#ifdef HAVE_UNIX_IO
	(void)lseek( dbip->dbi_fd, offset, 0 );
	got = write( dbip->dbi_fd, addr, count );
#else
	(void)fseek( dbip->dbi_fp, offset, 0 );
	got = fwrite( addr, 1, count, dbip->dbi_fp );
#endif
	bu_semaphore_release( BU_SEM_SYSCALL );
	if( got != count )  {
		perror("db_write");
		bu_log("db_write(%s):  write error.  Wanted %d, got %d bytes.\nFile forced read-only.\n",
			dbip->dbi_filename, count, got );
		dbip->dbi_read_only = 1;
		return(-1);
	}
	return(0);			/* OK */
}

/*
 *  			D B _ P U T
 *
 *  Store 'len' records to the database,
 *  "offset" granules into this entry.
 *
 *  Returns -
 *	 0	OK
 *	-1	failure
 */
int
db_put(struct db_i *dbip, const struct directory *dp, union record *where, int offset, int len)
{

	RT_CK_DBI(dbip);
	RT_CK_DIR(dp);
	if(RT_G_DEBUG&DEBUG_DB) bu_log("db_put(%s) x%x, x%x x%x off=%d len=%d\n",
		dp->d_namep, dbip, dp, where, offset, len );

	if( offset < 0 || offset+len > dp->d_len )  {
		bu_log("db_put(%s):  xfer %d..%x exceeds 0..%d\n",
			dp->d_namep, offset, offset+len, dp->d_len );
		return(-1);
	}

	if( dp->d_flags & RT_DIR_INMEM )  {
		bcopy( (char *)where,
			((char *)dp->d_un.ptr) + offset * sizeof(union record),
			len * sizeof(union record) );
		return 0;		/* OK */
	}

	if( dbip->dbi_read_only )  {
		bu_log("db_put(%s):  READ-ONLY file\n",
			dbip->dbi_filename);
		return(-1);
	}

	if( db_write( dbip, (char *)where, (long)len * sizeof(union record),
	    dp->d_addr + offset * sizeof(union record) ) < 0 )  {
		return(-1);
	}
	return(0);
}



/*
 *			D B _ G E T _ E X T E R N A L
 *
 *  Obtains a object from the database, leaving it in external (on-disk)
 *  format.
 *  The bu_external structure represented by 'ep' is initialized here,
 *  the caller need not pre-initialize it.  On error, 'ep' is left
 *  un-initialized and need not be freed, to simplify error recovery.
 *  On success, the caller is responsible for calling bu_free_external(ep);
 *
 *  Returns -
 *	-1	error
 *	 0	success
 */
int
db_get_external(register struct bu_external *ep, const struct directory *dp, const struct db_i *dbip)
{
	RT_CK_DBI(dbip);
	RT_CK_DIR(dp);
	if(RT_G_DEBUG&DEBUG_DB) bu_log("db_get_external(%s) ep=x%x, dbip=x%x, dp=x%x\n",
		dp->d_namep, ep, dbip, dp );

	if( (dp->d_flags & RT_DIR_INMEM) == 0 && dp->d_addr < 0 )
		return( -1 );		/* was dummy DB entry */

	BU_INIT_EXTERNAL(ep);
	if( dbip->dbi_version <= 4 )
		ep->ext_nbytes = dp->d_len * sizeof(union record);
	else
		ep->ext_nbytes = dp->d_len;
	ep->ext_buf = (genptr_t)bu_malloc(
		ep->ext_nbytes, "db_get_ext ext_buf");

	if( dp->d_flags & RT_DIR_INMEM )  {
		bcopy( dp->d_un.ptr, (char *)ep->ext_buf, ep->ext_nbytes );
		return 0;
	}

	if( db_read( dbip, (char *)ep->ext_buf,
	    (long)ep->ext_nbytes, dp->d_addr ) < 0 )  {
		bu_free( ep->ext_buf, "db_get_ext ext_buf" );
	    	ep->ext_buf = (genptr_t)NULL;
	    	ep->ext_nbytes = 0;
		return( -1 );	/* VERY BAD */
	}
	return(0);
}

/*
 *
 *			D B _ P U T _ E X T E R N A L
 *
 *  Given that caller already has an external representation of
 *  the database object,  update it to have a new name
 *  (taken from dp->d_namep) in that external representation,
 *  and write the new object into the database, obtaining different storage if
 *  the size has changed.
 *
 *  Caller is responsible for freeing memory of external representation,
 *  using bu_free_external().
 *
 *  This routine is used to efficiently support MGED's "cp" and "keep"
 *  commands, which don't need to import objects just to rename and copy them.
 *
 *  Returns -
 *	-1	error
 *	 0	success
 */
int
db_put_external(struct bu_external *ep, struct directory *dp, struct db_i *dbip)
{

	RT_CK_DBI(dbip);
	RT_CK_DIR(dp);
	BU_CK_EXTERNAL(ep);
	if(RT_G_DEBUG&DEBUG_DB) bu_log("db_put_external(%s) ep=x%x, dbip=x%x, dp=x%x\n",
		dp->d_namep, ep, dbip, dp );


	if( dbip->dbi_read_only )  {
		bu_log("db_put_external(%s):  READ-ONLY file\n",
			dbip->dbi_filename);
		return(-1);
	}

	if( dbip->dbi_version == 5 )
		return db_put_external5( ep, dp, dbip );

	if( dbip->dbi_version <= 4 )  {
		int	ngran;

		ngran = (ep->ext_nbytes+sizeof(union record)-1)/sizeof(union record);
		if( ngran != dp->d_len )  {
			if( dp->d_addr != -1L )  {
				if( db_delete( dbip, dp ) < 0 )
					return -2;
			}
			if( db_alloc( dbip, dp, ngran ) < 0 )  {
			    	return -3;
			}
		}
		/* Sanity check */
		if( ngran != dp->d_len )  {
			bu_log("db_put_external(%s) ngran=%d != dp->d_len %d\n",
				dp->d_namep, ngran, dp->d_len );
			bu_bomb("db_io.c: db_put_external()");
		}

		db_wrap_v4_external( ep, dp->d_namep );
	} else
		bu_bomb("db_put_external(): unknown dbi_version\n");

	if( dp->d_flags & RT_DIR_INMEM )  {
		bcopy( (char *)ep->ext_buf, dp->d_un.ptr, ep->ext_nbytes );
		return 0;
	}

	if( db_write( dbip, (char *)ep->ext_buf, ep->ext_nbytes, dp->d_addr ) < 0 )  {
		return(-1);
	}
	return(0);
}


/*
 *
 *			D B _ F W R I T E _ E X T E R N A L
 *
 *  Add name from dp->d_namep to external representation of solid,
 *  and write it into a file.
 *
 *  Caller is responsible for freeing memory of external representation,
 *  using bu_free_external().
 *
 *  The 'name' field of the external representation is modified to
 *  contain the desired name.
 *
 *  Returns -
 *	<0	error
 *	0	OK
 *
 *  NOTE:  Callers of this should be using wdb_export_external() instead.
 */
int
db_fwrite_external(FILE *fp, const char *name, struct bu_external *ep)
    			    
          		      
                  	    			/* can't be const */
{

	if(RT_G_DEBUG&DEBUG_DB) bu_log("db_fwrite_external(%s) ep=x%x\n",
		name, ep);

	BU_CK_EXTERNAL(ep);

	db_wrap_v4_external( ep, name );

	return bu_fwrite_external( fp, ep );
}

/*
 *			D B _ F R E E _ E X T E R N A L
 *
 *  XXX This is a leftover.  You should call bu_free_external() instead.
 */
void
db_free_external(register struct bu_external *ep)
{
	BU_CK_EXTERNAL(ep);
	bu_free_external(ep);
}
@


11.31
log
@change conf.h to a wrapped config.h
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/librt/db_io.c,v 11.30 2004/04/05 08:48:56 morrison Exp $ (BRL)";
@


11.30
log
@merge of ansi-6-0-branch into HEAD
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d26 5
a30 1
#include "conf.h"
@


11.29
log
@merge of windows-6-0-branch into head
@
text
@d59 5
a63 5
db_read( dbip, addr, count, offset )
const struct db_i	*dbip;
genptr_t	addr;
long		count;		/* byte count */
long		offset;		/* byte offset from start of file */
d122 1
a122 3
db_getmrec( dbip, dp )
const struct db_i	*dbip;
const struct directory	*dp;
d162 1
a162 6
db_get( dbip, dp, where, offset, len )
const struct db_i	*dbip;
const struct directory	*dp;
union record	*where;
int		offset;
int		len;
d209 1
a209 5
db_write( dbip, addr, count, offset )
struct db_i	*dbip;
const genptr_t	addr;
long		count;
long		offset;
d260 1
a260 6
db_put( dbip, dp, where, offset, len )
struct db_i	*dbip;
const struct directory	*dp;
union record	*where;
int		offset;
int		len;
d311 1
a311 4
db_get_external( ep, dp, dbip )
register struct bu_external	*ep;
const struct directory		*dp;
const struct db_i		*dbip;
d365 1
a365 4
db_put_external( ep, dp, dbip )
struct bu_external	*ep;
struct directory	*dp;
struct db_i		*dbip;
d440 4
a443 4
db_fwrite_external( fp, name, ep )
FILE			*fp;
const char		*name;
struct bu_external	*ep;			/* can't be const */
d462 1
a462 2
db_free_external( ep )
register struct bu_external	*ep;
@


11.28
log
@update copyright to include span through 2003
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_io.c,v 11.27 2002/08/20 17:07:57 jra Exp $ (BRL)";
d29 1
d31 1
@


11.27
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1988 by the United States Army.
d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_io.c,v 11.25 2001/05/17 20:05:23 morrison Exp $ (BRL)";
@


11.27.10.1
log
@merge from HEAD
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1988-2004 by the United States Army.
d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_io.c,v 11.28 2004/02/02 17:39:15 morrison Exp $ (BRL)";
@


11.27.10.2
log
@merge from head
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_io.c,v 11.27.10.1 2004/02/12 18:37:38 erikg Exp $ (BRL)";
@


11.27.10.3
log
@merge from head
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
a28 1
#ifdef HAVE_UNISTD_H
a29 1
#endif
@


11.27.4.1
log
@Modifications (on a 6.0 source distribution) for initial port to windows (merged with sources close to 6.0.2)
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_io.c,v 11.27 2002/08/20 17:07:57 jra Exp $ (BRL)";
a28 1
#ifdef HAVE_UNISTD_H
a29 1
#endif
@


11.27.4.2
log
@sync to HEAD...
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1988-2004 by the United States Army.
d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/db_io.c,v 11.27.4.1 2002/09/26 23:04:01 morrison Exp $ (BRL)";
@


11.27.2.1
log
@Initial ANSIfication
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_io.c,v 11.27 2002/08/20 17:07:57 jra Exp $ (BRL)";
d57 5
a61 5
db_read(const struct db_i *dbip, genptr_t addr, long int count, long int offset)
                 	      
        	     
    		      		/* byte count */
    		       		/* byte offset from start of file */
d120 3
a122 1
db_getmrec(const struct db_i *dbip, const struct directory *dp)
d162 6
a167 1
db_get(const struct db_i *dbip, const struct directory *dp, union record *where, int offset, int len)
d214 5
a218 1
db_write(struct db_i *dbip, const genptr_t addr, long int count, long int offset)
d269 6
a274 1
db_put(struct db_i *dbip, const struct directory *dp, union record *where, int offset, int len)
d325 4
a328 1
db_get_external(register struct bu_external *ep, const struct directory *dp, const struct db_i *dbip)
d382 4
a385 1
db_put_external(struct bu_external *ep, struct directory *dp, struct db_i *dbip)
d460 4
a463 4
db_fwrite_external(FILE *fp, const char *name, struct bu_external *ep)
    			    
          		      
                  	    			/* can't be const */
d482 2
a483 1
db_free_external(register struct bu_external *ep)
@


11.27.2.2
log
@sync branch with HEAD
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1988-2004 by the United States Army.
d23 1
a23 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
a28 1
#ifdef HAVE_UNISTD_H
a29 1
#endif
@


11.26
log
@Converted from K&R to ANSI C - RFH
@
text
@d57 5
a61 5
db_read(const struct db_i *dbip, genptr_t addr, long int count, long int offset)
                 	      
        	     
    		      		/* byte count */
    		       		/* byte offset from start of file */
d120 3
a122 1
db_getmrec(const struct db_i *dbip, const struct directory *dp)
d162 6
a167 1
db_get(const struct db_i *dbip, const struct directory *dp, union record *where, int offset, int len)
d214 5
a218 1
db_write(struct db_i *dbip, const genptr_t addr, long int count, long int offset)
d269 6
a274 1
db_put(struct db_i *dbip, const struct directory *dp, union record *where, int offset, int len)
d325 4
a328 1
db_get_external(register struct bu_external *ep, const struct directory *dp, const struct db_i *dbip)
d382 4
a385 1
db_put_external(struct bu_external *ep, struct directory *dp, struct db_i *dbip)
d460 4
a463 4
db_fwrite_external(FILE *fp, const char *name, struct bu_external *ep)
    			    
          		      
                  	    			/* can't be const */
d482 2
a483 1
db_free_external(register struct bu_external *ep)
@


11.25
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_io.c,v 11.24 2001/04/20 22:29:41 morrison Exp $ (BRL)";
d57 5
a61 5
db_read( dbip, addr, count, offset )
const struct db_i	*dbip;
genptr_t	addr;
long		count;		/* byte count */
long		offset;		/* byte offset from start of file */
d120 1
a120 3
db_getmrec( dbip, dp )
const struct db_i	*dbip;
const struct directory	*dp;
d160 1
a160 6
db_get( dbip, dp, where, offset, len )
const struct db_i	*dbip;
const struct directory	*dp;
union record	*where;
int		offset;
int		len;
d207 1
a207 5
db_write( dbip, addr, count, offset )
struct db_i	*dbip;
const genptr_t	addr;
long		count;
long		offset;
d258 1
a258 6
db_put( dbip, dp, where, offset, len )
struct db_i	*dbip;
const struct directory	*dp;
union record	*where;
int		offset;
int		len;
d309 1
a309 4
db_get_external( ep, dp, dbip )
register struct bu_external	*ep;
const struct directory		*dp;
const struct db_i		*dbip;
d363 1
a363 4
db_put_external( ep, dp, dbip )
struct bu_external	*ep;
struct directory	*dp;
struct db_i		*dbip;
d438 4
a441 4
db_fwrite_external( fp, name, ep )
FILE			*fp;
const char		*name;
struct bu_external	*ep;			/* can't be const */
d460 1
a460 2
db_free_external( ep )
register struct bu_external	*ep;
@


11.24
log
@CONST to const
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_io.c,v 11.23 2000/08/21 02:02:29 butler Exp $ (BRL)";
d67 1
a67 1
	if(rt_g.debug&DEBUG_DB)  {
d128 1
a128 1
	if(rt_g.debug&DEBUG_DB) bu_log("db_getmrec(%s) x%x, x%x\n",
d172 1
a172 1
	if(rt_g.debug&DEBUG_DB) bu_log("db_get(%s) x%x, x%x x%x off=%d len=%d\n",
d223 1
a223 1
	if(rt_g.debug&DEBUG_DB)  {
d279 1
a279 1
	if(rt_g.debug&DEBUG_DB) bu_log("db_put(%s) x%x, x%x x%x off=%d len=%d\n",
d332 1
a332 1
	if(rt_g.debug&DEBUG_DB) bu_log("db_get_external(%s) ep=x%x, dbip=x%x, dp=x%x\n",
d391 1
a391 1
	if(rt_g.debug&DEBUG_DB) bu_log("db_put_external(%s) ep=x%x, dbip=x%x, dp=x%x\n",
d466 1
a466 1
	if(rt_g.debug&DEBUG_DB) bu_log("db_fwrite_external(%s) ep=x%x\n",
@


11.23
log
@Massive compilation warnings eliminated
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_io.c,v 11.22 2000/07/29 23:23:04 mike Exp $ (BRL)";
d58 1
a58 1
CONST struct db_i	*dbip;
d121 2
a122 2
CONST struct db_i	*dbip;
CONST struct directory	*dp;
d163 2
a164 2
CONST struct db_i	*dbip;
CONST struct directory	*dp;
d216 1
a216 1
CONST genptr_t	addr;
d327 2
a328 2
CONST struct directory		*dp;
CONST struct db_i		*dbip;
d462 1
a462 1
CONST char		*name;
@


11.22
log
@
Removed old v4 db_grow() and db_trunc() internal interfaces.
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_io.c,v 11.21 2000/07/25 16:46:06 butler Exp $ (BRL)";
d270 2
a271 2
CONST struct db_i	*dbip;
CONST struct directory	*dp;
@


11.21
log
@Fixed bad practice in db5_update_ident definition: implicit int return
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_io.c,v 11.20 2000/07/12 02:09:39 mike Exp $ (BRL)";
d408 7
a414 9
		if( ngran != dp->d_len || dp->d_addr == -1L )  {
			if( ngran < dp->d_len )  {
				if( db_trunc( dbip, dp, dp->d_len - ngran ) < 0 )
				    	return(-2);
			} else if( ngran > dp->d_len )  {
				if( db_delete( dbip, dp ) < 0 || 
				    db_alloc( dbip, dp, ngran ) < 0 )  {
				    	return(-3);
				}
@


11.20
log
@
Changed to take advantage of db_wrap_v4_external()
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_io.c,v 11.19 2000/07/07 22:55:52 mike Exp $ (BRL)";
d29 1
d45 64
a201 114
 *  			D B _ P U T
 *
 *  Store 'len' records to the database,
 *  "offset" granules into this entry.
 *
 *  Returns -
 *	 0	OK
 *	-1	failure
 */
int
db_put( dbip, dp, where, offset, len )
CONST struct db_i	*dbip;
CONST struct directory	*dp;
union record	*where;
int		offset;
int		len;
{

	RT_CK_DBI(dbip);
	RT_CK_DIR(dp);
	if(rt_g.debug&DEBUG_DB) bu_log("db_put(%s) x%x, x%x x%x off=%d len=%d\n",
		dp->d_namep, dbip, dp, where, offset, len );

	if( offset < 0 || offset+len > dp->d_len )  {
		bu_log("db_put(%s):  xfer %d..%x exceeds 0..%d\n",
			dp->d_namep, offset, offset+len, dp->d_len );
		return(-1);
	}

	if( dp->d_flags & RT_DIR_INMEM )  {
		bcopy( (char *)where,
			((char *)dp->d_un.ptr) + offset * sizeof(union record),
			len * sizeof(union record) );
		return 0;		/* OK */
	}

	if( dbip->dbi_read_only )  {
		bu_log("db_put(%s):  READ-ONLY file\n",
			dbip->dbi_filename);
		return(-1);
	}

	if( db_write( dbip, (char *)where, (long)len * sizeof(union record),
	    dp->d_addr + offset * sizeof(union record) ) < 0 )  {
		return(-1);
	}
	return(0);
}

/*
 *			D B _ R E A D
 *
 *  Reads 'count' bytes at file offset 'offset' into buffer at 'addr'.
 *  A wrapper for the UNIX read() sys-call that takes into account
 *  syscall semaphores, stdio-only machines, and in-memory buffering.
 *
 *  Returns -
 *	 0	OK
 *	-1	failure
 */
/* should be HIDDEN */
int
db_read( dbip, addr, count, offset )
CONST struct db_i	*dbip;
genptr_t	addr;
long		count;		/* byte count */
long		offset;		/* byte offset from start of file */
{
	register int	got;
	register long	s;

	RT_CK_DBI(dbip);
	if(rt_g.debug&DEBUG_DB)  {
		bu_log("db_read(dbip=x%x, addr=x%x, count=%d., offset=x%x)\n",
			dbip, addr, count, offset );
	}
	if( count <= 0 || offset < 0 )  {
		return(-1);
	}
	if( dbip->dbi_inmem )  {
		if( offset+count > dbip->dbi_eof )  {
			/* Attempt to read off the end of the (mapped) file */
			bu_log("db_read(%s) ERROR offset=%d, count=%d, dbi_eof=%d\n",
				dbip->dbi_filename,
				offset, count, dbip->dbi_eof );
			return -1;
		}
		memcpy( addr, ((char *)dbip->dbi_inmem) + offset, count );
		return(0);
	}
	bu_semaphore_acquire( BU_SEM_SYSCALL );
#ifdef HAVE_UNIX_IO
	if ((s=(long)lseek( dbip->dbi_fd, (off_t)offset, 0 )) != offset) {
		bu_log("db_read: lseek returns %d not %d\n", s, offset);
		bu_bomb("db_read: Goodbye");
	}
	got = read( dbip->dbi_fd, addr, count );
#else
	if (fseek( dbip->dbi_fp, offset, 0 ))
		bu_bomb("db_read: fseek error\n");
	got = fread( addr, 1, count, dbip->dbi_fp );
#endif
	bu_semaphore_release( BU_SEM_SYSCALL );

	if( got != count )  {
		perror("db_read");
		bu_log("db_read(%s):  read error.  Wanted %d, got %d bytes\n",
			dbip->dbi_filename, count, got );
		return(-1);
	}
	return(0);			/* OK */
}

/*
d259 52
a404 1
		union record		*rec;
@


11.19
log
@
Changed db_put_external() to call db_put_external5(), rather than
trying to do it itself.
Changing the name on the external form is expensive.
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_io.c,v 11.18 2000/07/07 05:48:36 mike Exp $ (BRL)";
d424 1
a424 3
		/* Add name.  Depends on solid names always being in the same place */
		rec = (union record *)ep->ext_buf;
		NAMEMOVE( dp->d_namep, rec->s.s_name );
d456 2
a464 1
	union record		*rec;
d471 3
a473 7
	/* Add name.  Depends on solid names always being in the same place */
	rec = (union record *)ep->ext_buf;
	NAMEMOVE( name, rec->s.s_name );

	if( fwrite( ep->ext_buf, ep->ext_nbytes, 1, fp ) != 1 )
		return -1;
	return 0;
@


11.18
log
@
Read offset in hex too
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_io.c,v 11.17 2000/07/07 05:45:13 mike Exp $ (BRL)";
d362 5
a366 3
 *  Add name from dp->d_namep to external representation of solid,
 *  and write it into the database, obtaining different storage if
 *  the size has changed since last write.
d370 7
d387 1
a390 1
	BU_CK_EXTERNAL(ep);
d398 3
a426 8
	} else if( dbip->dbi_version == 5 )  {
		if( ep->ext_nbytes != dp->d_len || dp->d_addr == -1L )  {
			if( db5_realloc( dbip, dp, ep ) < 0 )  {
				bu_log("db_put_external(%s) db_realloc5() failed\n", dp->d_namep);
				return -5;
			}
		}
		BU_ASSERT_LONG( ep->ext_nbytes, ==, dp->d_len );
@


11.17
log
@
Changed offset print to hex
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_io.c,v 11.16 2000/07/07 05:27:33 mike Exp $ (BRL)";
d210 1
a210 1
		bu_log("db_read(dbip=x%x, addr=x%x, count=%d., offset=%d.)\n",
@


11.16
log
@
Improved error handling.
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_io.c,v 11.15 2000/06/30 21:07:31 mike Exp $ (BRL)";
d273 1
a273 1
		bu_log("db_write(dbip=x%x, addr=x%x, count=%d., offset=%d.)\n",
d299 1
a299 1
		bu_log("db_write(%s):  write error.  Wanted %d, got %d bytes.  File forced read-only.\n",
@


11.15
log
@
db5_realloc() -- change of subroutine name
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_io.c,v 11.14 2000/06/30 21:05:57 mike Exp $ (BRL)";
d264 1
a264 1
CONST struct db_i	*dbip;
d299 1
a299 1
		bu_log("db_write(%s):  write error.  Wanted %d, got %d bytes\n",
d301 1
@


11.14
log
@
Added auto-allocation of storage in db_put_external().
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_io.c,v 11.13 2000/06/30 21:00:10 mike Exp $ (BRL)";
d416 1
a416 1
			if( db_realloc5( dbip, dp, ep ) < 0 )  {
@


11.13
log
@
db_realloc5
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_io.c,v 11.12 2000/06/30 20:48:56 mike Exp $ (BRL)";
d393 1
a393 1
		if( ngran != dp->d_len )  {
d415 1
a415 1
		if( ep->ext_nbytes != dp->d_len )  {
@


11.12
log
@
Extended db_put_external() to use db_realloc5().
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_io.c,v 11.11 2000/06/30 20:21:50 mike Exp $ (BRL)";
d415 6
a420 2
		if( ep->ext_nbytes != dp->d_len )
			db_realloc5( dbip, dp, ep );
@


11.11
log
@
Removed a layer of layering on db_io
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_io.c,v 11.10 2000/06/29 18:20:55 mike Exp $ (BRL)";
a373 2
	union record		*rec;
	int	ngran;
d388 14
a401 11
	BU_ASSERT_LONG( dbip->dbi_version, <=, 4 );

	ngran = (ep->ext_nbytes+sizeof(union record)-1)/sizeof(union record);
	if( ngran != dp->d_len )  {
		if( ngran < dp->d_len )  {
			if( db_trunc( dbip, dp, dp->d_len - ngran ) < 0 )
			    	return(-2);
		} else if( ngran > dp->d_len )  {
			if( db_delete( dbip, dp ) < 0 || 
			    db_alloc( dbip, dp, ngran ) < 0 )  {
			    	return(-3);
d404 6
a409 7
	}
	/* Sanity check */
	if( ngran != dp->d_len )  {
		bu_log("db_put_external(%s) ngran=%d != dp->d_len %d\n",
			dp->d_namep, ngran, dp->d_len );
		bu_bomb("db_io.c: db_put_external()");
	}
d411 9
a419 3
	/* Add name.  Depends on solid names always being in the same place */
	rec = (union record *)ep->ext_buf;
	NAMEMOVE( dp->d_namep, rec->s.s_name );
@


11.10
log
@
Changed from db_free_external() to bu_free_external()
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_io.c,v 11.9 2000/06/27 17:33:13 mike Exp $ (BRL)";
d384 8
d420 1
a420 1
	if( db_put( dbip, dp, (union record *)(ep->ext_buf), 0, ngran ) < 0 )
d422 1
@


11.9
log
@
Added rt_db_get_internal5()
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_io.c,v 11.8 2000/01/07 03:24:09 mike Exp $ (BRL)";
d314 1
a314 1
 *  On success, the caller is responsible for calling db_free_external(ep);
d366 1
a366 1
 *  using db_free_external().
d426 1
a426 1
 *  using db_free_external().
d459 2
d467 1
a467 4
	if( ep->ext_buf )  {
		bu_free( ep->ext_buf, "db_get_ext ext_buf" );
		ep->ext_buf = GENPTR_NULL;
	}
@


11.8
log
@
Added db_fwrite_external() as a parallel to db_put_external().
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_io.c,v 11.7 1999/12/22 04:57:12 mike Exp $ (BRL)";
d335 4
a338 1
	ep->ext_nbytes = dp->d_len * sizeof(union record);
@


11.7
log
@
db_open(file,"r") now uses bu_open_mapped_file().
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_io.c,v 11.6 1997/12/16 00:12:31 mike Exp $ (BRL)";
d309 7
d412 40
@


11.6
log
@Converted to bu_semaphore_acquire()
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_io.c,v 11.5 1997/02/06 04:18:29 mike Exp mike $ (BRL)";
d224 1
a224 1
		memcpy( addr, dbip->dbi_inmem + offset, count );
@


11.5
log
@Initial RT_DIR_INMEM support
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_io.c,v 11.4 1996/10/16 02:35:23 mike Exp mike $ (BRL)";
d227 1
a227 1
	RES_ACQUIRE( &rt_g.res_syscall );
d239 1
a239 1
	RES_RELEASE( &rt_g.res_syscall );
d288 1
a288 1
	RES_ACQUIRE( &rt_g.res_syscall );
d296 1
a296 1
	RES_RELEASE( &rt_g.res_syscall );
@


11.4
log
@More args declared as CONST, changed to using macros to check pointers.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_io.c,v 11.3 1996/09/27 08:27:30 mike Exp mike $ (BRL)";
d72 5
d121 7
a159 5
	if( dbip->dbi_read_only )  {
		bu_log("db_put(%s):  READ-ONLY file\n",
			dbip->dbi_filename);
		return(-1);
	}
d166 13
d197 1
d261 1
d324 1
a324 1
	if( dp->d_addr < 0 )
d332 5
d396 5
@


11.3
log
@Converted to using proper routine names for LIBBU and LIBBN routines.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_io.c,v 11.2 1995/11/07 14:59:35 adam Exp mike $ (BRL)";
d56 1
a56 1
struct db_i		*dbip;
d61 2
a62 1
	if( dbip->dbi_magic != DBI_MAGIC )  rt_bomb("db_getmrec:  bad dbip\n");
d68 1
a68 1
	where = (union record *)rt_malloc(
d75 1
a75 1
		rt_free( (char *)where, "db_getmrec record[]" );
d93 2
a94 2
struct db_i	*dbip;
CONST struct directory *dp;
d100 2
a101 1
	if( dbip->dbi_magic != DBI_MAGIC )  rt_bomb("db_get:  bad dbip\n");
d136 2
a137 2
struct db_i	*dbip;
CONST struct directory *dp;
d143 2
a144 1
	if( dbip->dbi_magic != DBI_MAGIC )  rt_bomb("db_put:  bad dbip\n");
d179 1
a179 1
struct db_i	*dbip;
d187 1
a187 1
	if( dbip->dbi_magic != DBI_MAGIC )  rt_bomb("db_read:  bad dbip\n");
d210 1
a210 1
		rt_bomb("Goodbye");
d215 1
a215 1
		rt_bomb("db_read: fseek error\n");
d242 1
a242 1
struct db_i	*dbip;
d249 1
a249 1
	if( dbip->dbi_magic != DBI_MAGIC )  rt_bomb("db_write:  bad dbip\n");
d295 1
a295 1
struct db_i			*dbip;
d297 2
a298 1
	if( dbip->dbi_magic != DBI_MAGIC )  rt_bomb("db_get_external:  bad dbip\n");
d307 1
a307 1
	ep->ext_buf = (genptr_t)rt_malloc(
d312 1
a312 1
		rt_free( (char *)ep->ext_buf, "db_get_ext ext_buf" );
d340 2
a341 1
	if( dbip->dbi_magic != DBI_MAGIC )  rt_bomb("db_put_external:  bad dbip\n");
d363 1
a363 1
		rt_bomb("db_io.c: db_put_external()");
d384 1
a384 1
		rt_free( ep->ext_buf, "db_get_ext ext_buf" );
@


11.2
log
@Matching malloc and free messages -- db_get_ext ext_buf
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_io.c,v 11.1 1995/01/04 09:56:15 mike Rel4_4 adam $ (BRL)";
d62 1
a62 1
	if(rt_g.debug&DEBUG_DB) rt_log("db_getmrec(%s) x%x, x%x\n",
d100 1
a100 1
	if(rt_g.debug&DEBUG_DB) rt_log("db_get(%s) x%x, x%x x%x off=%d len=%d\n",
d108 1
a108 1
		rt_log("db_get(%s):  xfer %d..%x exceeds 0..%d\n",
d142 1
a142 1
	if(rt_g.debug&DEBUG_DB) rt_log("db_put(%s) x%x, x%x x%x off=%d len=%d\n",
d146 1
a146 1
		rt_log("db_put(%s):  READ-ONLY file\n",
d151 1
a151 1
		rt_log("db_put(%s):  xfer %d..%x exceeds 0..%d\n",
d186 1
a186 1
		rt_log("db_read(dbip=x%x, addr=x%x, count=%d., offset=%d.)\n",
d195 1
a195 1
			rt_log("db_read(%s) ERROR offset=%d, count=%d, dbi_eof=%d\n",
d206 1
a206 1
		rt_log("db_read: lseek returns %d not %d\n", s, offset);
d219 1
a219 1
		rt_log("db_read(%s):  read error.  Wanted %d, got %d bytes\n",
d248 1
a248 1
		rt_log("db_write(dbip=x%x, addr=x%x, count=%d., offset=%d.)\n",
d252 1
a252 1
		rt_log("db_write(%s):  READ-ONLY file\n",
d260 1
a260 1
		rt_log("db_write() in memory?\n");
d274 1
a274 1
		rt_log("db_write(%s):  write error.  Wanted %d, got %d bytes\n",
d290 1
a290 1
register struct rt_external	*ep;
d295 1
a295 1
	if(rt_g.debug&DEBUG_DB) rt_log("db_get_external(%s) ep=x%x, dbip=x%x, dp=x%x\n",
d301 1
a301 1
	RT_INIT_EXTERNAL(ep);
d329 1
a329 1
struct rt_external	*ep;
d337 1
a337 1
	if(rt_g.debug&DEBUG_DB) rt_log("db_put_external(%s) ep=x%x, dbip=x%x, dp=x%x\n",
d340 1
a340 1
	RT_CK_EXTERNAL(ep);
d356 1
a356 1
		rt_log("db_put_external(%s) ngran=%d != dp->d_len %d\n",
d375 1
a375 1
register struct rt_external	*ep;
d377 1
a377 1
	RT_CK_EXTERNAL(ep);
@


11.1
log
@Release_4.4
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_io.c,v 10.8 94/11/04 05:39:00 mike Exp $ (BRL)";
d379 1
a379 1
		rt_free( ep->ext_buf, "db_external buf" );
@


10.8
log
@Irix 6
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_io.c,v 10.7 94/09/28 02:55:17 mike Exp Locker: mike $ (BRL)";
@


10.7
log
@Added code to check for going off the end of the file when
using memory mapped files or inmem files.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_io.c,v 10.6 94/08/10 20:30:27 gdurf Exp Locker: mike $ (BRL)";
d216 1
a216 1
out:
@


10.6
log
@Added externs.h
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_io.c,v 10.5 1994/08/10 17:57:48 gdurf Exp gdurf $ (BRL)";
d193 7
d216 1
@


10.5
log
@name change
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_io.c,v 10.4 1994/08/10 17:53:54 gdurf Exp gdurf $ (BRL)";
d36 1
@


10.4
log
@Factored ifdefs
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_io.c,v 10.3 1992/02/05 15:26:49 mike Exp gdurf $ (BRL)";
d196 1
a196 1
#ifdef USE_UNIX_IO
d255 1
a255 1
#ifdef USE_UNIX_IO
@


10.3
log
@db_put_external() now adds the name on it's way to disk.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_io.c,v 10.2 92/02/05 13:18:42 mike Exp Locker: mike $ (BRL)";
d26 2
d29 3
a31 1
#ifdef BSD
a32 2
#else
#include <string.h>
d181 1
a181 1
	register int	s;
a191 1
#if defined(SYSV)
a192 3
#else
		bcopy( dbip->dbi_inmem + offset, addr, count );
#endif
d196 2
a197 2
#if defined(unix) || defined(__unix) || defined(__unix__)
	if ((s=lseek( dbip->dbi_fd, offset, 0 )) != offset) {
d255 1
a255 1
#if defined(unix) || defined(__unix)  || defined(__unix__)
@


10.2
log
@Added granule expand/contract support to db_put_external().
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_io.c,v 10.1 91/10/12 06:40:01 mike Rel4_0 Locker: mike $ (BRL)";
d313 6
a318 1
 *  Caller is responsible for freeing memory, using db_free_external().
d326 1
d353 4
@


10.1
log
@Release_4.0
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_io.c,v 9.12 91/10/04 06:28:25 butler Exp $ (BRL)";
d318 1
a318 1
CONST struct directory	*dp;
d321 2
d328 21
a348 3
	if( db_put( dbip, dp, (union record *)(ep->ext_buf), 0,
	    (ep->ext_nbytes+sizeof(union record)-1)/sizeof(union record)
	    ) < 0 )
@


9.12
log
@fixed typo
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_io.c,v 9.11 91/10/04 00:45:55 butler Exp Locker: butler $ (BRL)";
@


9.11
log
@added checks of returns from lseek() and fseek() in db_read()
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_io.c,v 9.10 91/09/27 19:29:33 phil Exp Locker: butler $ (BRL)";
d200 1
a200 1
		rt_log("db_read: lseek returns %d not %d\n", i, offset);
@


9.10
log
@Fixed the "non-Unix" (fread/fwrite) version of the I/O.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_io.c,v 9.9 91/09/27 05:51:02 butler Exp Locker: phil $ (BRL)";
d179 1
d199 4
a202 1
	(void)lseek( dbip->dbi_fd, offset, 0 );
d205 2
a206 1
	(void)fseek( dbip->dbi_fp, offset, 0 );
@


9.9
log
@added __unix__ to list of symbols checked.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_io.c,v 9.8 91/07/06 00:53:00 mike Exp Locker: butler $ (BRL)";
d202 1
a202 1
	got = fread( addr, count, 1, dbip->dbi_fp );
d257 1
a257 1
	got = fwrite( addr, count, 1, dbip->dbi_fp );
@


9.8
log
@More careful about defined() checking
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_io.c,v 9.7 91/06/29 22:13:46 mike Exp $ (BRL)";
d197 1
a197 1
#if defined(unix) || defined(__unix)
d252 1
a252 1
#if defined(unix) || defined(__unix)
@


9.7
log
@ANSI lint
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_io.c,v 9.6 91/01/25 22:05:55 mike Exp $ (BRL)";
d197 1
a197 1
#if unix
d252 1
a252 1
#if unix
@


9.6
log
@Checked for external objects with no buffers
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_io.c,v 9.5 91/01/11 07:12:23 mike Exp $ (BRL)";
d53 2
a54 2
struct db_i	*dbip;
struct directory *dp;
d90 1
a90 1
struct directory *dp;
d132 1
a132 1
struct directory *dp;
d228 1
a228 1
genptr_t	addr;
d279 1
a279 1
struct directory		*dp;
d313 1
a313 1
struct directory	*dp;
@


9.5
log
@Added db_get/put/free_external().
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_io.c,v 9.4 90/12/10 16:04:41 cjohnson Exp $ (BRL)";
d336 4
a339 1
	rt_free( ep->ext_buf, "db_external buf" );
@


9.4
log
@Exchange the order of db.h and raytrace.h to allow needed defines
from db.h reach raytrace.h
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_io.c,v 9.3 90/11/02 03:33:34 mike Exp $ (BRL)";
d64 1
a64 1
	if( (where = (union record *)rt_malloc(
d66 1
a66 3
		dp->d_namep)
	    ) == ((union record *)0) )
		return( (union record *)0 );
d267 70
@


9.3
log
@Changed rt_free message.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_io.c,v 9.2 90/05/21 21:19:40 mike Exp $ (BRL)";
d35 1
a36 1
#include "db.h"
@


9.2
log
@Revised to use new bottom-level routines, db_read() and db_write().
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_io.c,v 9.1 89/05/19 05:55:41 mike Rel3_5 $ (BRL)";
d73 1
a73 1
		rt_free( (char *)where, dp->d_namep );
@


9.1
log
@Release_3.5
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: db_io.c,v 1.4 89/04/17 13:41:18 mike Exp $ (BRL)";
d63 1
a63 1
		return( (union record *)0 );	/* dummy DB entry */
d70 3
a72 1
	if( db_get( dbip, dp, where, 0, dp->d_len ) < 0 )  {
d82 1
a82 1
 *  Retrieve several records from the database,
a96 2
	register int	want;
	register int	got;
a111 2
	if( dbip->dbi_inmem )  {
		register int	start;
d113 2
a114 26
		want = len * sizeof(union record);
		start = dp->d_addr + offset * sizeof(union record);
#if defined(SYSV)
		memcpy( (char *)where, dbip->dbi_inmem + start, want );
#else
		bcopy( dbip->dbi_inmem + start, (char *)where, want );
#endif
		return(0);
	}
	RES_ACQUIRE( &rt_g.res_syscall );
#if unix
	want = len * sizeof(union record);
	(void)lseek( dbip->dbi_fd,
		(long)(dp->d_addr + offset * sizeof(union record)), 0 );
	got = read( dbip->dbi_fd, (char *)where, want );
#else
	want = len;
	(void)fseek( dbip->dbi_fp,
		(long)(dp->d_addr + offset * sizeof(union record)), 0 );
	got = fread( (char *)where, want, sizeof(union record), dbip->dbi_fp );
#endif
	RES_RELEASE( &rt_g.res_syscall );
	if( got != want )  {
		perror("db_get");
		rt_log("db_get(%s):  read error.  Wanted %d, got %d bytes\n",
			dp->d_namep, want, got );
d124 1
a124 1
 *  Store several records to the database,
a138 2
	register int	want;
	register int	got;
d154 44
d200 2
a201 4
	want = len * sizeof(union record);
	(void)lseek( dbip->dbi_fd,
		(long)(dp->d_addr + offset * sizeof(union record)), 0 );
	got = write( dbip->dbi_fd, (char *)where, want );
d203 2
a204 5
	want = len;
	(void)fseek( dbip->dbi_fp,
		(long)(dp->d_addr + offset * sizeof(union record)), 0 );
	got = fwrite( (char *)where, want, sizeof(union record),
		dbip->dbi_fp );
d207 4
a210 4
	if( got != want )  {
		perror("db_put");
		rt_log("db_put(%s):  write error.  Sent %d, achieved %d bytes\n",
			dp->d_namep, want, got );
d213 56
a268 1
	return(0);
@


1.4
log
@Can now be safely called while multi-tasking is happening.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: db_io.c,v 1.3 88/12/13 02:23:51 mike Locked $ (BRL)";
@


1.3
log
@Added return codes, as advertised.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: db_io.c,v 1.2 88/12/08 04:46:26 mike Locked $ (BRL)";
d124 1
d136 1
d182 1
d195 1
@


1.2
log
@Added dbi_inmem capability, to buffer read-only databases
in memory, if they are small enough.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: db_io.c,v 1.1 88/12/06 00:09:12 mike Locked $ (BRL)";
d104 1
a104 1
		return;
d110 1
a110 1
		return;
d122 1
a122 1
		return;
d140 1
a140 1
		return;
d142 1
d173 1
a173 1
		return;
d178 1
a178 1
		return;
d189 2
a190 1
	got = fwrite( (char *)where, want, sizeof(union record), dbip->dbi_fp );
d196 1
d198 1
@


1.1
log
@Initial revision
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /cad/d/mike/cad/libdb/RCS/io.c,v 1.5 88/10/23 13:54:38 mike Exp $ (BRL)";
d110 12
@
