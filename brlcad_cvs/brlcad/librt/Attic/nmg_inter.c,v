head	11.67;
access;
symbols
	ansi-20040405-merged:11.62.2.2
	postmerge-20040405-ansi:11.65
	premerge-20040404-ansi:11.64
	postmerge-autoconf:11.64
	autoconf-freeze:11.63.6.2
	premerge-autoconf:11.64
	ansi-20040316-freeze:11.62.2.1
	postmerge-20040315-windows:11.64
	premerge-20040315-windows:11.64
	windows-20040315-freeze:11.62.4.1
	autoconf-20031203:11.63
	autoconf-20031202:11.63
	autoconf-branch:11.63.0.6
	phong-branch:11.63.0.4
	photonmap-branch:11.63.0.2
	rel-6-1-DP:11.62
	windows-branch:11.62.0.4
	rel-6-0-2:11.60
	ansi-branch:11.62.0.2
	rel-6-0-1-branch:11.60.0.2
	hartley-6-0-post:11.61
	hartley-6-0-pre:11.60
	rel-6-0-1:11.60
	rel-6-0:11.60
	rel-5-4:11.55
	offsite-5-3-pre:11.59
	rel-5-3:11.55
	rel-5-2:11.55
	rel-5-1-branch:11.55.0.2
	rel-5-1:11.55
	rel-5-0:11.52
	rel-5-0-beta:11.50
	rel-4-5:11.49
	ctj-4-5-post:11.48
	ctj-4-5-pre:11.48
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.67
date	2004.05.21.18.07.33;	author morrison;	state dead;
branches;
next	11.66;

11.66
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.65;

11.65
date	2004.04.05.08.48.57;	author morrison;	state Exp;
branches;
next	11.64;

11.64
date	2004.02.02.17.39.23;	author morrison;	state Exp;
branches;
next	11.63;

11.63
date	2003.01.25.07.02.10;	author morrison;	state Exp;
branches
	11.63.6.1;
next	11.62;

11.62
date	2002.08.20.17.08.04;	author jra;	state Exp;
branches
	11.62.2.1
	11.62.4.1;
next	11.61;

11.61
date	2002.08.15.20.55.15;	author hartley;	state Exp;
branches;
next	11.60;

11.60
date	2001.04.20.22.29.50;	author morrison;	state Exp;
branches;
next	11.59;

11.59
date	2000.08.31.04.01.52;	author mike;	state Exp;
branches;
next	11.58;

11.58
date	2000.08.31.04.00.58;	author mike;	state Exp;
branches;
next	11.57;

11.57
date	2000.08.21.02.02.32;	author butler;	state Exp;
branches;
next	11.56;

11.56
date	2000.07.10.23.01.41;	author mike;	state Exp;
branches;
next	11.55;

11.55
date	2000.04.01.03.00.58;	author mike;	state Exp;
branches;
next	11.54;

11.54
date	2000.03.29.18.55.52;	author mike;	state Exp;
branches;
next	11.53;

11.53
date	99.12.30.15.26.55;	author jra;	state Exp;
branches;
next	11.52;

11.52
date	99.07.02.22.19.25;	author mike;	state Exp;
branches;
next	11.51;

11.51
date	99.06.03.01.39.14;	author mike;	state Exp;
branches;
next	11.50;

11.50
date	98.03.12.20.57.38;	author jra;	state Exp;
branches;
next	11.49;

11.49
date	97.09.18.20.32.45;	author jra;	state Exp;
branches;
next	11.48;

11.48
date	97.07.11.14.56.17;	author jra;	state Exp;
branches;
next	11.47;

11.47
date	97.01.21.20.43.36;	author jra;	state Exp;
branches;
next	11.46;

11.46
date	96.12.19.14.04.07;	author jra;	state Exp;
branches;
next	11.45;

11.45
date	96.09.27.08.27.30;	author mike;	state Exp;
branches;
next	11.44;

11.44
date	96.07.12.12.17.41;	author jra;	state Exp;
branches;
next	11.43;

11.43
date	96.07.02.14.27.47;	author jra;	state Exp;
branches;
next	11.42;

11.42
date	96.06.27.18.17.04;	author jra;	state Exp;
branches;
next	11.41;

11.41
date	96.06.14.19.57.35;	author jra;	state Exp;
branches;
next	11.40;

11.40
date	96.05.16.21.59.41;	author jra;	state Exp;
branches;
next	11.39;

11.39
date	96.05.07.14.11.37;	author jra;	state Exp;
branches;
next	11.38;

11.38
date	96.05.01.13.35.14;	author jra;	state Exp;
branches;
next	11.37;

11.37
date	96.04.30.20.35.32;	author jra;	state Exp;
branches;
next	11.36;

11.36
date	96.04.22.12.50.20;	author jra;	state Exp;
branches;
next	11.35;

11.35
date	96.03.18.00.05.15;	author jra;	state Exp;
branches;
next	11.34;

11.34
date	96.03.05.21.31.20;	author jra;	state Exp;
branches;
next	11.33;

11.33
date	95.12.02.03.09.46;	author mike;	state Exp;
branches;
next	11.32;

11.32
date	95.10.19.14.58.22;	author jra;	state Exp;
branches;
next	11.31;

11.31
date	95.09.06.13.56.36;	author jra;	state Exp;
branches;
next	11.30;

11.30
date	95.06.17.03.00.18;	author mike;	state Exp;
branches;
next	11.29;

11.29
date	95.05.05.21.02.16;	author jra;	state Exp;
branches;
next	11.28;

11.28
date	95.05.01.20.47.00;	author jra;	state Exp;
branches;
next	11.27;

11.27
date	95.03.13.11.00.13;	author jra;	state Exp;
branches;
next	11.26;

11.26
date	95.03.09.22.07.26;	author jra;	state Exp;
branches;
next	11.25;

11.25
date	95.03.05.21.27.21;	author mike;	state Exp;
branches;
next	11.24;

11.24
date	95.03.05.20.04.42;	author mike;	state Exp;
branches;
next	11.23;

11.23
date	95.02.28.00.41.21;	author mike;	state Exp;
branches;
next	11.22;

11.22
date	95.02.23.13.02.28;	author jra;	state Exp;
branches;
next	11.21;

11.21
date	95.02.22.00.55.04;	author mike;	state Exp;
branches;
next	11.20;

11.20
date	95.02.21.23.37.04;	author mike;	state Exp;
branches;
next	11.19;

11.19
date	95.02.21.03.10.39;	author mike;	state Exp;
branches;
next	11.18;

11.18
date	95.02.19.21.01.49;	author mike;	state Exp;
branches;
next	11.17;

11.17
date	95.02.18.19.51.05;	author mike;	state Exp;
branches;
next	11.16;

11.16
date	95.02.17.22.02.58;	author mike;	state Exp;
branches;
next	11.15;

11.15
date	95.02.15.00.14.22;	author mike;	state Exp;
branches;
next	11.14;

11.14
date	95.02.11.05.50.24;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	95.02.11.04.29.57;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	95.02.11.03.18.13;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	95.02.10.23.36.50;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	95.02.07.06.00.46;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	95.02.07.03.45.51;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	95.02.07.03.07.35;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	95.02.06.23.02.12;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	95.02.03.03.06.32;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	95.02.03.03.03.07;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	95.02.02.07.29.08;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	95.01.31.04.27.45;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	95.01.30.15.28.08;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.57.43;	author mike;	state Rel4_4;
branches;
next	10.197;

10.197
date	95.01.04.07.57.53;	author mike;	state Exp;
branches;
next	10.196;

10.196
date	95.01.03.23.09.40;	author mike;	state Exp;
branches;
next	10.195;

10.195
date	94.12.27.17.47.52;	author mike;	state Exp;
branches;
next	10.194;

10.194
date	94.12.20.14.58.39;	author jra;	state Exp;
branches;
next	10.193;

10.193
date	94.11.04.12.17.40;	author jra;	state Exp;
branches;
next	10.192;

10.192
date	94.11.04.06.48.34;	author mike;	state Exp;
branches;
next	10.191;

10.191
date	94.10.11.19.42.36;	author mike;	state Exp;
branches;
next	10.190;

10.190
date	94.09.16.20.45.48;	author mike;	state Exp;
branches;
next	10.189;

10.189
date	94.09.16.20.19.39;	author mike;	state Exp;
branches;
next	10.188;

10.188
date	94.09.12.13.45.01;	author mike;	state Exp;
branches;
next	10.187;

10.187
date	94.09.10.23.02.54;	author jra;	state Exp;
branches;
next	10.186;

10.186
date	94.09.10.04.36.52;	author mike;	state Exp;
branches;
next	10.185;

10.185
date	94.09.03.03.01.36;	author mike;	state Exp;
branches;
next	10.184;

10.184
date	94.09.02.00.32.02;	author mike;	state Exp;
branches;
next	10.183;

10.183
date	94.08.10.18.52.22;	author gdurf;	state Exp;
branches;
next	10.182;

10.182
date	94.08.09.19.37.55;	author mike;	state Exp;
branches;
next	10.181;

10.181
date	94.07.06.20.15.39;	author mike;	state Exp;
branches;
next	10.180;

10.180
date	94.07.06.16.50.08;	author mike;	state Exp;
branches;
next	10.179;

10.179
date	94.07.06.15.46.46;	author mike;	state Exp;
branches;
next	10.178;

10.178
date	94.07.04.03.17.07;	author mike;	state Exp;
branches;
next	10.177;

10.177
date	94.07.04.02.48.14;	author mike;	state Exp;
branches;
next	10.176;

10.176
date	94.07.03.20.16.17;	author mike;	state Exp;
branches;
next	10.175;

10.175
date	94.07.02.03.12.16;	author mike;	state Exp;
branches;
next	10.174;

10.174
date	94.07.02.03.00.59;	author mike;	state Exp;
branches;
next	10.173;

10.173
date	94.07.02.02.40.24;	author mike;	state Exp;
branches;
next	10.172;

10.172
date	94.07.01.23.36.45;	author mike;	state Exp;
branches;
next	10.171;

10.171
date	94.07.01.21.43.17;	author mike;	state Exp;
branches;
next	10.170;

10.170
date	94.07.01.20.36.29;	author mike;	state Exp;
branches;
next	10.169;

10.169
date	94.07.01.15.44.17;	author mike;	state Exp;
branches;
next	10.168;

10.168
date	94.07.01.15.01.52;	author mike;	state Exp;
branches;
next	10.167;

10.167
date	94.07.01.01.26.32;	author mike;	state Exp;
branches;
next	10.166;

10.166
date	94.07.01.00.25.45;	author mike;	state Exp;
branches;
next	10.165;

10.165
date	94.06.30.23.50.39;	author mike;	state Exp;
branches;
next	10.164;

10.164
date	94.06.30.22.33.48;	author mike;	state Exp;
branches;
next	10.163;

10.163
date	94.06.30.21.56.32;	author mike;	state Exp;
branches;
next	10.162;

10.162
date	94.06.30.20.00.00;	author mike;	state Exp;
branches;
next	10.161;

10.161
date	94.06.30.16.12.09;	author mike;	state Exp;
branches;
next	10.160;

10.160
date	94.06.30.15.47.25;	author mike;	state Exp;
branches;
next	10.159;

10.159
date	94.06.30.02.12.33;	author mike;	state Exp;
branches;
next	10.158;

10.158
date	94.06.29.23.44.42;	author mike;	state Exp;
branches;
next	10.157;

10.157
date	94.06.27.23.01.12;	author mike;	state Exp;
branches;
next	10.156;

10.156
date	94.04.25.03.13.01;	author mike;	state Exp;
branches;
next	10.155;

10.155
date	94.04.24.20.41.51;	author mike;	state Exp;
branches;
next	10.154;

10.154
date	94.04.24.18.41.51;	author mike;	state Exp;
branches;
next	10.153;

10.153
date	94.04.23.12.14.00;	author mike;	state Exp;
branches;
next	10.152;

10.152
date	94.04.23.10.54.39;	author mike;	state Exp;
branches;
next	10.151;

10.151
date	94.04.23.07.35.04;	author mike;	state Exp;
branches;
next	10.150;

10.150
date	94.04.23.07.25.58;	author mike;	state Exp;
branches;
next	10.149;

10.149
date	94.04.22.10.47.39;	author mike;	state Exp;
branches;
next	10.148;

10.148
date	94.04.22.08.47.54;	author mike;	state Exp;
branches;
next	10.147;

10.147
date	94.04.22.06.18.27;	author mike;	state Exp;
branches;
next	10.146;

10.146
date	94.04.22.05.59.17;	author mike;	state Exp;
branches;
next	10.145;

10.145
date	94.04.22.05.54.20;	author mike;	state Exp;
branches;
next	10.144;

10.144
date	94.04.22.05.51.39;	author mike;	state Exp;
branches;
next	10.143;

10.143
date	94.04.22.05.48.45;	author mike;	state Exp;
branches;
next	10.142;

10.142
date	94.04.22.05.10.56;	author mike;	state Exp;
branches;
next	10.141;

10.141
date	94.04.22.04.33.02;	author mike;	state Exp;
branches;
next	10.140;

10.140
date	94.04.22.04.27.52;	author mike;	state Exp;
branches;
next	10.139;

10.139
date	94.04.22.04.17.06;	author mike;	state Exp;
branches;
next	10.138;

10.138
date	94.04.21.07.12.42;	author mike;	state Exp;
branches;
next	10.137;

10.137
date	94.04.21.05.56.42;	author mike;	state Exp;
branches;
next	10.136;

10.136
date	94.04.21.05.22.16;	author mike;	state Exp;
branches;
next	10.135;

10.135
date	94.04.21.01.46.31;	author mike;	state Exp;
branches;
next	10.134;

10.134
date	94.04.20.23.43.11;	author mike;	state Exp;
branches;
next	10.133;

10.133
date	94.04.20.20.55.57;	author mike;	state Exp;
branches;
next	10.132;

10.132
date	94.04.20.00.52.38;	author mike;	state Exp;
branches;
next	10.131;

10.131
date	94.04.19.19.54.36;	author mike;	state Exp;
branches;
next	10.130;

10.130
date	94.04.19.19.53.59;	author mike;	state Exp;
branches;
next	10.129;

10.129
date	94.04.19.16.12.39;	author mike;	state Exp;
branches;
next	10.128;

10.128
date	94.04.19.07.12.56;	author mike;	state Exp;
branches;
next	10.127;

10.127
date	94.04.19.07.01.20;	author mike;	state Exp;
branches;
next	10.126;

10.126
date	94.04.19.05.26.34;	author mike;	state Exp;
branches;
next	10.125;

10.125
date	94.04.18.06.05.47;	author mike;	state Exp;
branches;
next	10.124;

10.124
date	94.04.08.00.52.57;	author mike;	state Exp;
branches;
next	10.123;

10.123
date	94.03.04.23.13.53;	author mike;	state Exp;
branches;
next	10.122;

10.122
date	94.03.04.04.28.19;	author mike;	state Exp;
branches;
next	10.121;

10.121
date	94.02.23.03.23.45;	author mike;	state Exp;
branches;
next	10.120;

10.120
date	94.02.08.11.02.28;	author jra;	state Exp;
branches;
next	10.119;

10.119
date	94.02.02.00.39.12;	author mike;	state Exp;
branches;
next	10.118;

10.118
date	94.02.02.00.11.57;	author mike;	state Exp;
branches;
next	10.117;

10.117
date	94.02.01.22.33.41;	author mike;	state Exp;
branches;
next	10.116;

10.116
date	94.01.29.00.22.08;	author mike;	state Exp;
branches;
next	10.115;

10.115
date	94.01.27.05.22.13;	author mike;	state Exp;
branches;
next	10.114;

10.114
date	94.01.26.18.44.40;	author mike;	state Exp;
branches;
next	10.113;

10.113
date	94.01.26.17.58.35;	author mike;	state Exp;
branches;
next	10.112;

10.112
date	94.01.26.17.40.19;	author mike;	state Exp;
branches;
next	10.111;

10.111
date	94.01.25.09.44.18;	author mike;	state Exp;
branches;
next	10.110;

10.110
date	94.01.23.05.58.46;	author mike;	state Exp;
branches;
next	10.109;

10.109
date	94.01.23.02.57.14;	author mike;	state Exp;
branches;
next	10.108;

10.108
date	94.01.22.23.23.16;	author mike;	state Exp;
branches;
next	10.107;

10.107
date	94.01.22.05.24.47;	author mike;	state Exp;
branches;
next	10.106;

10.106
date	94.01.20.05.15.59;	author mike;	state Exp;
branches;
next	10.105;

10.105
date	93.12.27.22.45.28;	author mike;	state Exp;
branches;
next	10.104;

10.104
date	93.12.22.06.13.47;	author mike;	state Exp;
branches;
next	10.103;

10.103
date	93.12.03.03.35.27;	author mike;	state Exp;
branches;
next	10.102;

10.102
date	93.11.18.02.09.15;	author mike;	state Exp;
branches;
next	10.101;

10.101
date	93.11.12.22.40.13;	author mike;	state Exp;
branches;
next	10.100;

10.100
date	93.10.29.04.12.37;	author mike;	state Exp;
branches;
next	10.99;

10.99
date	93.10.27.19.31.47;	author mike;	state Exp;
branches;
next	10.98;

10.98
date	93.10.26.06.15.30;	author mike;	state Exp;
branches;
next	10.97;

10.97
date	93.10.25.01.31.55;	author cjohnson;	state Exp;
branches;
next	10.96;

10.96
date	93.10.24.09.06.54;	author mike;	state Exp;
branches;
next	10.95;

10.95
date	93.10.24.03.50.55;	author mike;	state Exp;
branches;
next	10.94;

10.94
date	93.10.23.07.42.27;	author mike;	state Exp;
branches;
next	10.93;

10.93
date	93.10.23.01.38.30;	author mike;	state Exp;
branches;
next	10.92;

10.92
date	93.10.23.00.35.47;	author mike;	state Exp;
branches;
next	10.91;

10.91
date	93.10.20.23.09.56;	author mike;	state Exp;
branches;
next	10.90;

10.90
date	93.10.19.01.36.36;	author mike;	state Exp;
branches;
next	10.89;

10.89
date	93.10.18.20.37.35;	author mike;	state Exp;
branches;
next	10.88;

10.88
date	93.10.18.20.09.42;	author mike;	state Exp;
branches;
next	10.87;

10.87
date	93.10.18.19.42.59;	author mike;	state Exp;
branches;
next	10.86;

10.86
date	93.10.02.01.01.54;	author mike;	state Exp;
branches;
next	10.85;

10.85
date	93.10.01.16.36.27;	author mike;	state Exp;
branches;
next	10.84;

10.84
date	93.10.01.07.20.59;	author mike;	state Exp;
branches;
next	10.83;

10.83
date	93.10.01.06.48.38;	author mike;	state Exp;
branches;
next	10.82;

10.82
date	93.09.30.22.14.26;	author mike;	state Exp;
branches;
next	10.81;

10.81
date	93.09.30.21.08.46;	author mike;	state Exp;
branches;
next	10.80;

10.80
date	93.09.30.05.27.40;	author mike;	state Exp;
branches;
next	10.79;

10.79
date	93.09.29.22.15.08;	author mike;	state Exp;
branches;
next	10.78;

10.78
date	93.09.27.22.15.57;	author mike;	state Exp;
branches;
next	10.77;

10.77
date	93.09.24.15.07.43;	author mike;	state Exp;
branches;
next	10.76;

10.76
date	93.09.24.13.47.57;	author mike;	state Exp;
branches;
next	10.75;

10.75
date	93.09.23.13.21.46;	author mike;	state Exp;
branches;
next	10.74;

10.74
date	93.09.22.13.45.09;	author mike;	state Exp;
branches;
next	10.73;

10.73
date	93.09.21.14.07.37;	author mike;	state Exp;
branches;
next	10.72;

10.72
date	93.09.15.02.36.52;	author mike;	state Exp;
branches;
next	10.71;

10.71
date	93.09.14.22.28.09;	author mike;	state Exp;
branches;
next	10.70;

10.70
date	93.09.14.21.48.50;	author mike;	state Exp;
branches;
next	10.69;

10.69
date	93.09.10.23.17.47;	author mike;	state Exp;
branches;
next	10.68;

10.68
date	93.09.10.19.38.27;	author mike;	state Exp;
branches;
next	10.67;

10.67
date	93.09.10.16.26.43;	author mike;	state Exp;
branches;
next	10.66;

10.66
date	93.09.08.23.17.00;	author mike;	state Exp;
branches;
next	10.65;

10.65
date	93.09.08.22.47.59;	author mike;	state Exp;
branches;
next	10.64;

10.64
date	93.09.08.19.49.33;	author mike;	state Exp;
branches;
next	10.63;

10.63
date	93.09.07.09.21.54;	author jra;	state Exp;
branches;
next	10.62;

10.62
date	93.08.27.22.46.57;	author mike;	state Exp;
branches;
next	10.61;

10.61
date	93.08.27.21.41.26;	author mike;	state Exp;
branches;
next	10.60;

10.60
date	93.08.27.21.37.06;	author mike;	state Exp;
branches;
next	10.59;

10.59
date	93.08.27.04.53.03;	author mike;	state Exp;
branches;
next	10.58;

10.58
date	93.08.21.05.34.09;	author mike;	state Exp;
branches;
next	10.57;

10.57
date	93.08.20.06.16.44;	author mike;	state Exp;
branches;
next	10.56;

10.56
date	93.08.19.04.52.57;	author mike;	state Exp;
branches;
next	10.55;

10.55
date	93.08.19.02.46.47;	author mike;	state Exp;
branches;
next	10.54;

10.54
date	93.08.19.01.36.33;	author mike;	state Exp;
branches;
next	10.53;

10.53
date	93.08.19.00.10.50;	author mike;	state Exp;
branches;
next	10.52;

10.52
date	93.08.18.21.28.50;	author mike;	state Exp;
branches;
next	10.51;

10.51
date	93.08.14.07.07.48;	author mike;	state Exp;
branches;
next	10.50;

10.50
date	93.07.24.01.03.15;	author mike;	state Exp;
branches;
next	10.49;

10.49
date	93.07.23.17.03.55;	author mike;	state Exp;
branches;
next	10.48;

10.48
date	93.07.20.22.50.23;	author mike;	state Exp;
branches;
next	10.47;

10.47
date	93.05.20.17.13.31;	author mike;	state Exp;
branches;
next	10.46;

10.46
date	93.04.08.02.43.37;	author mike;	state Exp;
branches;
next	10.45;

10.45
date	93.04.07.06.34.51;	author mike;	state Exp;
branches;
next	10.44;

10.44
date	93.04.03.01.58.58;	author mike;	state Exp;
branches;
next	10.43;

10.43
date	93.03.31.00.37.10;	author mike;	state Exp;
branches;
next	10.42;

10.42
date	93.03.24.03.20.38;	author mike;	state Exp;
branches;
next	10.41;

10.41
date	93.03.24.01.43.41;	author mike;	state Exp;
branches;
next	10.40;

10.40
date	93.03.24.01.18.39;	author mike;	state Exp;
branches;
next	10.39;

10.39
date	93.03.19.05.15.08;	author mike;	state Exp;
branches;
next	10.38;

10.38
date	93.03.16.01.18.57;	author mike;	state Exp;
branches;
next	10.37;

10.37
date	93.03.10.22.30.00;	author mike;	state Exp;
branches;
next	10.36;

10.36
date	93.03.10.00.06.25;	author mike;	state Exp;
branches;
next	10.35;

10.35
date	93.03.08.21.42.01;	author mike;	state Exp;
branches;
next	10.34;

10.34
date	93.03.08.20.51.15;	author mike;	state Exp;
branches;
next	10.33;

10.33
date	93.03.03.01.51.05;	author mike;	state Exp;
branches;
next	10.32;

10.32
date	93.02.25.04.35.08;	author mike;	state Exp;
branches;
next	10.31;

10.31
date	93.02.24.23.23.07;	author mike;	state Exp;
branches;
next	10.30;

10.30
date	93.02.19.04.47.07;	author mike;	state Exp;
branches;
next	10.29;

10.29
date	93.02.18.04.51.14;	author mike;	state Exp;
branches;
next	10.28;

10.28
date	93.02.18.04.13.40;	author mike;	state Exp;
branches;
next	10.27;

10.27
date	93.02.16.14.31.34;	author mike;	state Exp;
branches;
next	10.26;

10.26
date	93.02.12.00.43.58;	author mike;	state Exp;
branches;
next	10.25;

10.25
date	93.02.11.21.59.47;	author mike;	state Exp;
branches;
next	10.24;

10.24
date	93.02.11.21.36.38;	author mike;	state Exp;
branches;
next	10.23;

10.23
date	93.02.10.03.03.09;	author mike;	state Exp;
branches;
next	10.22;

10.22
date	93.02.09.22.28.25;	author mike;	state Exp;
branches;
next	10.21;

10.21
date	93.02.09.02.57.16;	author mike;	state Exp;
branches;
next	10.20;

10.20
date	93.02.09.00.38.49;	author mike;	state Exp;
branches;
next	10.19;

10.19
date	93.02.09.00.13.37;	author mike;	state Exp;
branches;
next	10.18;

10.18
date	93.02.06.04.26.24;	author mike;	state Exp;
branches;
next	10.17;

10.17
date	93.01.25.12.32.00;	author mike;	state Exp;
branches;
next	10.16;

10.16
date	93.01.22.22.36.05;	author mike;	state Exp;
branches;
next	10.15;

10.15
date	92.10.20.17.42.10;	author mike;	state Exp;
branches;
next	10.14;

10.14
date	92.10.20.16.59.16;	author mike;	state Exp;
branches;
next	10.13;

10.13
date	92.10.06.23.12.13;	author mike;	state Exp;
branches;
next	10.12;

10.12
date	92.07.23.05.05.16;	author butler;	state Exp;
branches;
next	10.11;

10.11
date	92.07.22.03.57.33;	author butler;	state Exp;
branches;
next	10.10;

10.10
date	92.07.21.21.04.00;	author butler;	state Exp;
branches;
next	10.9;

10.9
date	92.07.20.23.09.33;	author butler;	state Exp;
branches;
next	10.8;

10.8
date	92.03.12.08.32.32;	author mike;	state Exp;
branches;
next	10.7;

10.7
date	92.03.06.12.02.41;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	92.03.06.07.54.35;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	92.03.05.05.58.28;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	92.02.29.03.17.51;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	92.02.24.23.53.56;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	92.02.21.01.35.13;	author butler;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.40.45;	author mike;	state Rel4_0;
branches;
next	1.32;

1.32
date	91.06.17.20.42.04;	author butler;	state Exp;
branches;
next	1.31;

1.31
date	91.05.18.03.03.08;	author mike;	state Exp;
branches;
next	1.30;

1.30
date	91.03.28.01.02.50;	author mike;	state Exp;
branches;
next	1.29;

1.29
date	91.03.21.20.19.09;	author mike;	state Exp;
branches;
next	1.28;

1.28
date	91.03.21.19.53.11;	author mike;	state Exp;
branches;
next	1.27;

1.27
date	91.03.21.19.48.19;	author mike;	state Exp;
branches;
next	1.26;

1.26
date	91.03.21.14.28.25;	author mike;	state Exp;
branches;
next	1.25;

1.25
date	91.03.21.14.22.37;	author mike;	state Exp;
branches;
next	1.24;

1.24
date	91.03.02.01.41.40;	author mike;	state Exp;
branches;
next	1.23;

1.23
date	91.03.01.23.52.17;	author mike;	state Exp;
branches;
next	1.22;

1.22
date	91.02.07.20.32.37;	author mike;	state Exp;
branches;
next	1.21;

1.21
date	90.12.10.20.41.43;	author mike;	state Exp;
branches;
next	1.20;

1.20
date	90.07.31.01.15.37;	author mike;	state Exp;
branches;
next	1.19;

1.19
date	90.05.24.20.06.14;	author mike;	state Exp;
branches;
next	1.18;

1.18
date	90.05.24.03.56.38;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	90.05.24.02.09.43;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	90.05.23.22.42.51;	author butler;	state Exp;
branches;
next	1.15;

1.15
date	90.05.23.22.06.56;	author butler;	state Exp;
branches;
next	1.14;

1.14
date	90.05.21.23.48.26;	author butler;	state Exp;
branches;
next	1.13;

1.13
date	90.05.18.12.23.50;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	90.05.18.07.26.00;	author butler;	state Exp;
branches;
next	1.11;

1.11
date	90.05.17.11.36.22;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	90.05.15.05.38.28;	author butler;	state Exp;
branches;
next	1.9;

1.9
date	90.05.13.21.00.05;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	90.05.13.14.24.42;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	90.05.13.12.42.13;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	90.05.13.11.06.13;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	90.05.11.08.22.14;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	90.05.11.07.21.32;	author butler;	state Exp;
branches;
next	1.3;

1.3
date	90.05.11.05.35.47;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	90.05.11.05.28.11;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	90.05.11.04.59.26;	author mike;	state Exp;
branches;
next	;

11.62.2.1
date	2002.09.19.18.01.39;	author morrison;	state Exp;
branches;
next	11.62.2.2;

11.62.2.2
date	2004.03.17.21.18.52;	author morrison;	state Exp;
branches;
next	;

11.62.4.1
date	2004.03.11.23.43.41;	author morrison;	state Exp;
branches;
next	;

11.63.6.1
date	2004.02.12.18.37.44;	author erikg;	state Exp;
branches;
next	11.63.6.2;

11.63.6.2
date	2004.03.15.14.07.26;	author erikg;	state Exp;
branches;
next	;


desc
@Intersection routines
@


11.67
log
@moved to src/
@
text
@/*
 *			N M G _ I N T E R . C
 *
 *  Routines to intersect two NMG regions.  When complete, all loops
 *  in each region have a single classification w.r.t. the other region,
 *  i.e. all geometric intersections of the two regions have explicit
 *  topological representations.
 *
 *  The intersector makes sure that all geometric intersections gets
 *  recorded with explicit geometry and topology that is shared between both
 *  regions. Primary examples of this are (a) the line of intersection
 *  between two planes (faces), and (b) the point of intersection where two
 *  edges cross.
 *
 *  Entities of one region that are INSIDE, but not ON the other region
 *  do not become shared during the intersection process.
 *
 *  All point -vs- point comparisons should be done in 3D, for consistency.
 *
 *  Method -
 *
 *	Find all the points of intersection between the two regions, and
 *	insert vertices at those points, breaking edges on those new
 *	vertices as appropriate.
 *
 *	Call the face cutter to construct and delete edges and loops
 *	along the line of intersection, as appropriate.
 *
 *	There are no "user interface" routines in here.
 *
 *  Authors -
 *	Michael John Muuss
 *	Lee A. Butler
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Pacakge" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1994-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/nmg_inter.c,v 11.66 2004/05/10 15:30:46 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif


#include <stdio.h>
#include <math.h>
#include <string.h>
#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "nmg.h"
#include "raytrace.h"
#include "./debug.h"
#include "plot3.h"

#define ISECT_NONE	0
#define ISECT_SHARED_V	1
#define ISECT_SPLIT1	2
#define ISECT_SPLIT2	4

struct ee_2d_state {
	struct nmg_inter_struct	*is;
	struct edgeuse	*eu;
	point_t	start;
	point_t	end;
	vect_t	dir;
};


static int	nmg_isect_edge2p_face2p BU_ARGS((struct nmg_inter_struct *is,
			struct edgeuse *eu, struct faceuse *fu,
			struct faceuse *eu_fu));


static struct nmg_inter_struct	*nmg_hack_last_is;	/* see nmg_isect2d_final_cleanup() */

/*
 */
struct vertexuse *
nmg_make_dualvu(struct vertex *v, struct faceuse *fu, const struct bn_tol *tol)
{
	struct loopuse *lu;
	struct vertexuse *dualvu;
	struct edgeuse *new_eu;

	NMG_CK_VERTEX( v );
	NMG_CK_FACEUSE( fu );
	BN_CK_TOL( tol );

	if (rt_g.NMG_debug & DEBUG_POLYSECT)
		bu_log( "nmg_make_dualvu( v=x%x, fu=x%x )\n", v, fu );

	/* check for existing vu */
	if(  (dualvu=nmg_find_v_in_face( v, fu ))  )
	{
		if (rt_g.NMG_debug & DEBUG_POLYSECT)
			bu_log( "\tdualvu already exists (x%x)\n", dualvu );
		return( dualvu );
	}

	new_eu = (struct edgeuse *)NULL;

	/* check if v lies within tolerance of an edge in face */
	if (rt_g.NMG_debug & DEBUG_POLYSECT)
		bu_log( "\tLooking for an edge to split\n" );
	for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
	{
		struct edgeuse *eu;

		if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
			continue;

		for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
		{
			int code;
			fastf_t   dist;
			point_t pca;

			if (rt_g.NMG_debug & DEBUG_POLYSECT)
				bu_log( "\tChecking eu x%x (%f %f %f) <-> (%f %f %f)\n",
					eu,
					V3ARGS( eu->vu_p->v_p->vg_p->coord ),
					V3ARGS( eu->eumate_p->vu_p->v_p->vg_p->coord ) );

			code = bn_dist_pt3_lseg3( &dist, pca,
				eu->vu_p->v_p->vg_p->coord,
				eu->eumate_p->vu_p->v_p->vg_p->coord,
				v->vg_p->coord, tol );

			if (rt_g.NMG_debug & DEBUG_POLYSECT)
				bu_log( "bn_dist_pt3_lseg3 returns %d, dist=%f\n", code, dist );

			if( code > 2 )
				continue;

			/* v is within tolerance of eu */
			if( code > 0 )
				continue;

			/* split edge */
			if (rt_g.NMG_debug & DEBUG_POLYSECT)
				bu_log( "nmg_make_dualvu is splitting eu x%x at v x%x\n", eu, v );
			new_eu = nmg_esplit( v, eu, 1 );
		}
	}

	if( new_eu )
		return( new_eu->vu_p );

	/* need a self loop  */
	lu = nmg_mlv( &fu->l.magic, v, OT_BOOLPLACE );
	if (rt_g.NMG_debug & DEBUG_POLYSECT)
		bu_log( "nmg_make_dualvu is makeing a self_loop (lu=x%x, vu=x%x) for v=x%x\n", lu, BU_LIST_FIRST( vertexuse, &lu->down_hd ), v );
	nmg_loop_g( lu->l_p, tol );
	return( BU_LIST_FIRST( vertexuse, &lu->down_hd ) );
}

/*
 *			N M G _ E N L I S T _ V U
 *
 *  Given a vu which represents a point of intersection between shells
 *  s1 and s2, insert it and it's dual into lists l1 and l2.
 *  First, determine whether the vu came from s1 or s2, and insert in
 *  the corresponding list.
 *
 *  Second, try and find a dual of that vertex
 *  in the other shell's faceuse (fu1 or fu2)
 *  (if the entity in the other shell is not a wire), and enlist the dual.
 *  If there is no dual, make a self-loop over there, and enlist that.
 *
 *  If 'dualvu' is provided, don't search, just use that.
 *
 *  While it is true that in most cases the calling routine will know
 *  which shell the vu came from, it's cheap to re-determine it here.
 *  This "all in one" packaging, which handles both lists automaticly
 *  is *vastly* superior to the previous version, which pushed 10-20
 *  lines of bookkeeping up into *every* place an intersection vu was
 *  created.
 *
 *  Returns a pointer to vu's dual.
 *
 *  "Join the Army, young vertexuse".
 */
struct vertexuse *
nmg_enlist_vu(struct nmg_inter_struct *is, const struct vertexuse *vu, struct vertexuse *dualvu, fastf_t dist)
                       	    
                      	    
                	        		/* vu's dual in other shell.  May be NULL */
       			     			/* distance along intersect ray for this vu */
{
	struct shell		*sv;		/* shell of vu */
	struct loopuse		*lu;		/* lu of new self-loop */
	struct faceuse		*dualfu = (struct faceuse *)NULL; /* faceuse of vu's dual */
	struct shell		*duals = (struct shell *)NULL;	/* shell of vu's dual */
	struct faceuse		*fuv;		/* faceuse of vu */

	NMG_CK_INTER_STRUCT(is);
	NMG_CK_VERTEXUSE(vu);
	if(dualvu)  {
		NMG_CK_VERTEXUSE(dualvu);
		if( vu == dualvu )  rt_bomb("nmg_enlist_vu() vu == dualvu\n");
	}

	if( is->mag_len <= BU_PTBL_END( is->l1 ) || is->mag_len <= BU_PTBL_END( is->l2 ) )
		bu_log( "Array for distances to vertexuses is too small (%d)\n" , is->mag_len );

#if 0
	/* Check the geometry */
	if( bn_distsq_line3_pt3(is->pt, is->dir, vu->v_p->vg_p->coord) > is->tol.dist_sq )  {
		bu_log("nmg_enlist_vu() WARNING: vu=x%x, v=x%x not within tolerance of intersect line\n",
			vu, vu->v_p);
	}
#endif

	sv = nmg_find_s_of_vu( vu );
	fuv = nmg_find_fu_of_vu( vu );

	/* First step:  add vu to corresponding list */
	if( sv == is->s1 )  {
		bu_ptbl_ins_unique( is->l1, (long *)&vu->l.magic );
		if( is->mag_len <= BU_PTBL_END( is->l1 ) )
		{
			if( is->mag_len )
			{
				is->mag_len *= 2;
				is->mag1 = (fastf_t *)rt_realloc( (char *)is->mag1, is->mag_len*sizeof( fastf_t),
					"is->mag1" );
				is->mag2 = (fastf_t *)rt_realloc( (char *)is->mag2, is->mag_len*sizeof( fastf_t),
					"is->mag2" );
			}
			else
			{
				is->mag_len = 2*(BU_PTBL_END( is->l1 ) + BU_PTBL_END( is->l2 ));
				is->mag1 = (fastf_t *)bu_calloc( is->mag_len, sizeof( fastf_t ), "is->mag1" );
				is->mag2 = (fastf_t *)bu_calloc( is->mag_len, sizeof( fastf_t ), "is->mag2" );
			}
			
		}
		if( dist < MAX_FASTF )
			is->mag1[bu_ptbl_locate( is->l1, (long *)&vu->l.magic )] = dist;
		duals = is->s2;		/* other shell */
		dualfu = is->fu2;
		if( is->fu1 && is->fu1->s_p != is->s1 ) rt_bomb("nmg_enlist_vu() fu1/s1 mismatch\n");
		if( fuv != is->fu1 )  {
			bu_log("fuv=x%x, fu1=x%x, fu2=x%x\n", fuv, is->fu1, is->fu2);
			bu_log( "\tvu=x%x (x%x)\n", vu, vu->v_p );
			rt_bomb("nmg_enlist_vu() vu/fu1 mis-match\n");
		}
	} else if( sv == is->s2 )  {
		bu_ptbl_ins_unique( is->l2, (long *)&vu->l.magic );
		if( is->mag_len <= BU_PTBL_END( is->l2 ) )
		{
			if( is->mag_len )
			{
				is->mag_len *= 2;
				is->mag1 = (fastf_t *)rt_realloc( (char *)is->mag1, is->mag_len*sizeof( fastf_t),
					"is->mag1" );
				is->mag2 = (fastf_t *)rt_realloc( (char *)is->mag2, is->mag_len*sizeof( fastf_t),
					"is->mag2" );
			}
			else
			{
				is->mag_len = 2*(BU_PTBL_END( is->l1 ) + BU_PTBL_END( is->l2 ));
				is->mag1 = (fastf_t *)bu_calloc( is->mag_len, sizeof( fastf_t ), "is->mag1" );
				is->mag2 = (fastf_t *)bu_calloc( is->mag_len, sizeof( fastf_t ), "is->mag2" );
			}
			
		}
		if( dist < MAX_FASTF )
			is->mag2[bu_ptbl_locate( is->l2, (long *)&vu->l.magic )] = dist;
		duals = is->s1;		/* other shell */
		dualfu = is->fu1;
		if( is->fu2 && is->fu2->s_p != is->s2 ) rt_bomb("nmg_enlist_vu() fu2/s2 mismatch\n");
		if( fuv != is->fu2 )  {
			bu_log("fuv=x%x, fu1=x%x, fu2=x%x\n", fuv, is->fu1, is->fu2);
			bu_log( "\tvu=x%x (x%x)\n", vu, vu->v_p );
			rt_bomb("nmg_enlist_vu() vu/fu2 mis-match\n");
		}
	} else {
		bu_log("nmg_enlist_vu(vu=x%x,dv=x%x) sv=x%x, s1=x%x, s2=x%x\n",
			vu, dualvu, sv, is->s1, is->s2 );
		rt_bomb("nmg_enlist_vu: vu is not in s1 or s2\n");
	}

	if( dualvu )  {
		if( vu->v_p != dualvu->v_p )  rt_bomb("nmg_enlist_vu() dual vu has different vertex\n");
		if( nmg_find_s_of_vu(dualvu) != duals )  {
			bu_log("nmg_enlist_vu(vu=x%x,dv=x%x) sv=x%x, s1=x%x, s2=x%x, sdual=x%x\n",
				vu, dualvu,
				sv, is->s1, is->s2, nmg_find_s_of_vu(dualvu) );
			rt_bomb("nmg_enlist_vu() dual vu shell mis-match\n");
		}
		if( dualfu && nmg_find_fu_of_vu(dualvu) != dualfu) rt_bomb("nmg_enlist_vu() dual vu has wrong fu\n");
	}

	/* Second, search for vu's dual */
	if( dualfu )  {
		NMG_CK_FACEUSE(dualfu);
		if( dualfu->s_p != duals )  rt_bomb("nmg_enlist_vu() dual fu's shell is not dual's shell?\n");
		if( !dualvu )
			dualvu = nmg_make_dualvu( vu->v_p, dualfu, &(is->tol) );
		else {
			if( rt_g.NMG_debug & DEBUG_POLYSECT )  {
				bu_log("nmg_enlist_vu(vu=x%x,dv=x%x) re-using dualvu=x%x from dualfu=x%x\n",
					vu, dualvu,
					dualvu, dualfu);
			}
		}
	} else {
		/* Must have come from a wire in other shell, make wire loop */
		bu_log("\tvu=x%x, %s, fu1=x%x, fu2=x%x\n", vu, (sv==is->s1)?"shell 1":"shell 2", is->fu1, is->fu2);
		bu_log("nmg_enlist_vu(): QUESTION: What do I search for wire intersections?  Making self-loop\n");
		if( !dualvu && !(dualvu = nmg_find_v_in_shell( vu->v_p, duals, 0 )) )  {
			/* Not found, make self-loop in dual shell */
			lu = nmg_mlv( &duals->l.magic, vu->v_p, OT_BOOLPLACE );
			nmg_loop_g( lu->l_p, &(is->tol) );
			dualvu = BU_LIST_FIRST( vertexuse, &lu->down_hd );
		} else {
			if( rt_g.NMG_debug & DEBUG_POLYSECT )  {
				bu_log("nmg_enlist_vu(vu=x%x) re-using dualvu=x%x from dualshell=x%x\n",
					vu,
					dualvu, duals);
			}
		}
	}
	NMG_CK_VERTEXUSE(dualvu);

	/* Enlist the dual onto the other list */
	if( sv == is->s1 )  {
		bu_ptbl_ins_unique( is->l2, (long *)&dualvu->l.magic );
		if( is->mag_len <= BU_PTBL_END( is->l2 ) )
		{
			if( is->mag_len )
			{
				is->mag_len *= 2;
				is->mag1 = (fastf_t *)rt_realloc( (char *)is->mag1, is->mag_len*sizeof( fastf_t),
					"is->mag1" );
				is->mag2 = (fastf_t *)rt_realloc( (char *)is->mag2, is->mag_len*sizeof( fastf_t),
					"is->mag2" );
			}
			else
			{
				is->mag_len = 2*(BU_PTBL_END( is->l1 ) + BU_PTBL_END( is->l2 ));
				is->mag1 = (fastf_t *)bu_calloc( is->mag_len, sizeof( fastf_t ), "is->mag1" );
				is->mag2 = (fastf_t *)bu_calloc( is->mag_len, sizeof( fastf_t ), "is->mag2" );
			}
			
		}
		if( dist < MAX_FASTF )
			is->mag2[bu_ptbl_locate( is->l2, (long *)&dualvu->l.magic )] = dist;
	} else {
		bu_ptbl_ins_unique( is->l1, (long *)&dualvu->l.magic );
		if( is->mag_len <= BU_PTBL_END( is->l1 ) )
		{
			if( is->mag_len )
			{
				is->mag_len *= 2;
				is->mag1 = (fastf_t *)rt_realloc( (char *)is->mag1, is->mag_len*sizeof( fastf_t),
					"is->mag1" );
				is->mag2 = (fastf_t *)rt_realloc( (char *)is->mag2, is->mag_len*sizeof( fastf_t),
					"is->mag2" );
			}
			else
			{
				is->mag_len = 2*(BU_PTBL_END( is->l1 ) + BU_PTBL_END( is->l2 ));
				is->mag1 = (fastf_t *)bu_calloc( is->mag_len, sizeof( fastf_t ), "is->mag1" );
				is->mag2 = (fastf_t *)bu_calloc( is->mag_len, sizeof( fastf_t ), "is->mag2" );
			}
			
		}
		if( dist < MAX_FASTF )
			is->mag1[bu_ptbl_locate( is->l1, (long *)&dualvu->l.magic )] = dist;
	}

	if( rt_g.NMG_debug & DEBUG_POLYSECT )  {
		bu_log("nmg_enlist_vu(vu=x%x,dv=x%x) v=x%x, dist=%g (%s) ret=x%x\n",
			vu, dualvu, vu->v_p, dist,
			(sv == is->s1) ? "shell 1" : "shell 2",
			dualvu );
	}

	/* Some (expensive) centralized sanity checking */
	if( (rt_g.NMG_debug & DEBUG_VERIFY) && is->fu1 && is->fu2 )  {
		nmg_ck_v_in_2fus(vu->v_p, is->fu1, is->fu2, &(is->tol));
	}
	return dualvu;
}

/*
 *			N M G _ G E T _ 2 D _ V E R T E X
 *
 *  A "lazy evaluator" to obtain the 2D projection of a vertex.
 *  The lazy approach is not a luxury, since new (3D) vertices are created
 *  as the edge/edge intersection proceeds, and their 2D coordinates may
 *  be needed later on in the calculation.
 *  The alternative would be to store the 2D projection each time a
 *  new vertex is created, but that is likely to be a lot of bothersome
 *  code, where one omission would be deadly.
 *
 *  The return is a 3-tuple, with the Z coordinate set to 0.0 for safety.
 *  This is especially useful when the projected value is printed using
 *  one of the 3D print routines.
 *
 *  'assoc_use' is either a pointer to a faceuse, or an edgeuse.
 */
static void
nmg_get_2d_vertex(fastf_t *v2d, struct vertex *v, struct nmg_inter_struct *is, const long int *assoc_use)
       			    		/* a 3-tuple */
             		   
                       	    
          		           	/* ptr to faceuse/edgeuse associated w/2d projection */
{
	register fastf_t	*pt2d;
	point_t			pt;
	struct vertex_g		*vg;
	long			*this;

	NMG_CK_INTER_STRUCT(is);
	NMG_CK_VERTEX(v);

	/* If 2D preparations have not been made yet, do it now */
	if( !is->vert2d )  {
		nmg_isect2d_prep( is, assoc_use );
	}

	if( *assoc_use == NMG_FACEUSE_MAGIC )  {
		this = &((struct faceuse *)assoc_use)->f_p->l.magic;
		if( this != is->twod )
			goto bad;
	} else if ( *assoc_use == NMG_EDGEUSE_MAGIC )  {
		this = &((struct edgeuse *)assoc_use)->e_p->magic;
		if( this != is->twod )
			goto bad;
	} else {
		this = (long *)NULL;
bad:
		bu_log("nmg_get_2d_vertex(,assoc_use=%x %s) this=x%x %s, is->twod=%x %s\n",
			assoc_use, bu_identify_magic(*assoc_use),
			this, bu_identify_magic(*this),
			is->twod, bu_identify_magic(*(is->twod)) );
		rt_bomb("nmg_get_2d_vertex:  2d association mis-match\n");
	}

	if( !v->vg_p )  {
		bu_log("nmg_get_2d_vertex: v=x%x, assoc_use=x%x, null vg_p\n",
			v, assoc_use);
		rt_bomb("nmg_get_2d_vertex:  vertex with no geometry!\n");
	}
	vg = v->vg_p;
	NMG_CK_VERTEX_G(vg);
	if( v->index >= is->maxindex )  {
		struct model	*m;
		int		oldmax;
		register int	i;

		oldmax = is->maxindex;
		m = nmg_find_model(&v->magic);
		NMG_CK_MODEL(m);
		bu_log("nmg_get_2d_vertex:  v=x%x, v->index=%d, is->maxindex=%d, m->maxindex=%d\n",
			v, v->index, is->maxindex, m->maxindex );
		if( v->index >= m->maxindex )  {
			/* Really off the end */
			VPRINT("3d vertex", vg->coord);
			rt_bomb("nmg_get_2d_vertex:  array overrun\n");
		}
		/* Need to extend array, it's grown. */
		is->maxindex = m->maxindex * 4;
		if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
			bu_log("nmg_get_2d_vertex() extending vert2d array from %d to %d points (m max=%d)\n",
				oldmax, is->maxindex, m->maxindex);
		}
		is->vert2d = (fastf_t *)rt_realloc( (char *)is->vert2d,
			is->maxindex * 3 * sizeof(fastf_t), "vert2d[]");

		/* Clear out the new part of the 2D vertex array, setting flag in [2] to -1 */
		for( i = (3*is->maxindex)-1-2; i >= oldmax*3; i -= 3 )  {
			VSET( &is->vert2d[i], 0, 0, -1 );
		}
	}
	pt2d = &is->vert2d[v->index*3];
	if( pt2d[2] == 0 )  {
		/* Flag set.  Conversion is done.  Been here before */
		v2d[0] = pt2d[0];
		v2d[1] = pt2d[1];
		v2d[2] = 0;
		return;
	}

	MAT4X3PNT( pt, is->proj, vg->coord );
	v2d[0] = pt2d[0] = pt[0];
	v2d[1] = pt2d[1] = pt[1];
	v2d[2] = pt2d[2] = 0;		/* flag */

	if( !NEAR_ZERO( pt[2], is->tol.dist ) )  {
		struct faceuse	*fu = (struct faceuse *)assoc_use;
		plane_t	n;
		fastf_t	dist;
		NMG_GET_FU_PLANE( n, fu );
		dist = DIST_PT_PLANE(vg->coord, n);
		bu_log("nmg_get_2d_vertex ERROR #%d (%g %g %g) becomes (%g,%g)\n\t%g != zero, dist3d=%g, %g*tol\n",
			v->index, V3ARGS(vg->coord), V3ARGS(pt),
			dist, dist/is->tol.dist );
		if( !NEAR_ZERO( dist, is->tol.dist ) &&
		    !NEAR_ZERO( pt[2], 10*is->tol.dist ) )  {
			bu_log("nmg_get_2d_vertex(,assoc_use=%x) f=x%x, is->twod=%x\n",
				assoc_use, fu->f_p, is->twod);
			PLPRINT("fu->f_p N", n);
			rt_bomb("3D->2D point projection error\n");
		}
	}

	if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
		bu_log("2d #%d (%g %g %g) becomes (%g,%g) %g\n",
			v->index, V3ARGS(vg->coord), V3ARGS(pt) );
	}
}

/*
 *			N M G _ I S E C T 2 D _ P R E P
 *
 *  To intersect two co-planar faces, project all vertices from those
 *  faces into 2D.
 *  At the moment, use a memory intensive strategy which allocates a
 *  (3d) point_t for each "index" item, and subscripts the resulting
 *  array by the vertices index number.
 *  Since additional vertices can be created as the intersection process
 *  operates, 2*maxindex items are originall allocated, as a (generous)
 *  upper bound on the amount of intersecting that might happen.
 *
 *  In the array, the third double of each projected vertex is set to -1 when
 *  that slot has not been filled yet, and 0 when it has been.
 */
/* XXX Set this up so that it can take either an edge pointer
 * or a face pointer.  In case of edge, make edge_g_lseg->dir unit, and
 * rotate that to +X axis.  Make edge_g_lseg->pt be the origin.
 * This will allow the 2D routines to operate on wires.
 */
void
nmg_isect2d_prep(struct nmg_inter_struct *is, const long int *assoc_use)
{
	struct model	*m;
	struct face_g_plane	*fg;
	vect_t		to;
	point_t		centroid;
	point_t		centroid_proj;
	plane_t		n;
	register int	i;

	NMG_CK_INTER_STRUCT(is);

	if( *assoc_use == NMG_FACEUSE_MAGIC )  {
		if( &((struct faceuse *)assoc_use)->f_p->l.magic == is->twod )
			return;		/* Already prepped */
	} else if( *assoc_use == NMG_EDGEUSE_MAGIC )  {
		if( &((struct edgeuse *)assoc_use)->e_p->magic == is->twod )
			return;		/* Already prepped */
	} else {
		rt_bomb("nmg_isect2d_prep() bad assoc_use magic\n");
	}

	nmg_isect2d_cleanup(is);
	nmg_hack_last_is = is;

	m = nmg_find_model( assoc_use );

	is->maxindex = ( 2 * m->maxindex );
	is->vert2d = (fastf_t *)bu_malloc( is->maxindex * 3 * sizeof(fastf_t), "vert2d[]");

	if( *assoc_use == NMG_FACEUSE_MAGIC )  {
		struct faceuse	*fu1 = (struct faceuse *)assoc_use;
		struct face	*f1;

		f1 = fu1->f_p;
		fg = f1->g.plane_p;
		NMG_CK_FACE_G_PLANE(fg);
		is->twod = &f1->l.magic;
		if( f1->flip )  {
			VREVERSE( n, fg->N );
			n[3] = -fg->N[3];
		} else {
			HMOVE( n, fg->N );
		}
		if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
			bu_log("nmg_isect2d_prep(f=x%x) flip=%d\n", f1, f1->flip);
			PLPRINT("N", n);
		}

		/*
		 *  Rotate so that f1's N vector points up +Z.
		 *  This places all 2D calcuations in the XY plane.
		 *  Translate so that f1's centroid becomes the 2D origin.
		 *  Reasoning:  no vertex should be favored by putting it at
		 *  the origin.  The "desirable" floating point space in the
		 *  vicinity of the origin should be used to best advantage,
		 *  by centering calculations around it.
		 */
		VSET( to, 0, 0, 1 );
		bn_mat_fromto( is->proj, n, to );
		VADD2SCALE( centroid, f1->max_pt, f1->min_pt, 0.5 );
		MAT4X3PNT( centroid_proj, is->proj, centroid );
		centroid_proj[Z] = n[3];	/* pull dist from origin off newZ */
		MAT_DELTAS_VEC_NEG( is->proj, centroid_proj );
	} else if( *assoc_use == NMG_EDGEUSE_MAGIC )  {
		struct edgeuse	*eu1 = (struct edgeuse *)assoc_use;
		struct edge	*e1;
		struct edge_g_lseg	*eg;

		bu_log("2d prep for edgeuse\n");
		e1 = eu1->e_p;
		NMG_CK_EDGE(e1);
		eg = eu1->g.lseg_p;
		NMG_CK_EDGE_G_LSEG(eg);
		is->twod = &e1->magic;

		/*
		 *  Rotate so that eg's eg_dir vector points up +X.
		 *  The choice of the other axes is arbitrary.
		 *  This ensures that all calculations happen on the XY plane.
		 *  Translate the edge start point to the origin.
		 */
		VSET( to, 1, 0, 0 );
		bn_mat_fromto( is->proj, eg->e_dir, to );
		MAT_DELTAS_VEC_NEG( is->proj, eg->e_pt );
	} else {
		rt_bomb("nmg_isect2d_prep() bad assoc_use magic\n");
	}

	/* Clear out the 2D vertex array, setting flag in [2] to -1 */
	for( i = (3*is->maxindex)-1-2; i >= 0; i -= 3 )  {
		VSET( &is->vert2d[i], 0, 0, -1 );
	}
}

/*
 *			N M G _ I S E C T 2 D _ C L E A N U P.
 *
 *  Common routine to zap 2d vertex cache, and release dynamic storage.
 */
void
nmg_isect2d_cleanup(struct nmg_inter_struct *is)
{
	NMG_CK_INTER_STRUCT(is);

	nmg_hack_last_is = (struct nmg_inter_struct *)NULL;

	if( !is->vert2d )  return;
	bu_free( (char *)is->vert2d, "vert2d");
	is->vert2d = (fastf_t *)NULL;
	is->twod = (long *)NULL;
}

/*
 *			N M G _ I S E C T 2 D _ F I N A L _ C L E A N U P
 *
 *  XXX Hack routine used for storage reclamation by G-JACK for
 *  XXX calculation of the reportcard without gobbling lots of memory
 *  XXX on rt_bomb() longjmp()s.
 *  Can be called by the longjmp handler with impunity.
 *  If a pointer to busy dynamic memory is still handy, it will be freed.
 *  If not, no harm done.
 */
void
nmg_isect2d_final_cleanup(void)
{
	if( nmg_hack_last_is && nmg_hack_last_is->magic == NMG_INTER_STRUCT_MAGIC )
		nmg_isect2d_cleanup( nmg_hack_last_is );
}

/*
 *			N M G _ I S E C T _ V E R T 2 P _ F A C E 2 P
 *
 *  Handle the complete intersection of a vertex which lies on the
 *  plane of a face.  *every* intersection is performed.
 *
 *  If already part of the topology of the face, do nothing more.
 *  If it intersects one of the edges of the face, break the edge there.
 *  Otherwise, add a self-loop into the face as a marker.
 *
 *  All vertexuse pairs are enlisted on the intersection line.
 *  Assuming that there is one (is->l1 non null).
 *
 *  Called by -
 *	nmg_isect_3vertex_3face()
 *	nmg_isect_two_face2p()
 */
void
nmg_isect_vert2p_face2p(struct nmg_inter_struct *is, struct vertexuse *vu1, struct faceuse *fu2)
{
	struct vertexuse	*vu2;
	struct loopuse	 *lu2;
	pointp_t	pt;
	int		ret = 0;

	if (rt_g.NMG_debug & DEBUG_POLYSECT)
		bu_log("nmg_isect_vert2p_face2p(, vu1=x%x, fu2=x%x)\n", vu1, fu2);
	NMG_CK_INTER_STRUCT(is);
	NMG_CK_VERTEXUSE(vu1);
	NMG_CK_FACEUSE(fu2);

	pt = vu1->v_p->vg_p->coord;

	/* Prep the 2D cache, if the face changed */
	nmg_isect2d_prep( is, &fu2->l.magic );

	/* For every edge and vert, check topo AND geometric intersection */
	for( BU_LIST_FOR( lu2, loopuse, &fu2->lu_hd ) )  {
		struct edgeuse	*eu2;

		NMG_CK_LOOPUSE(lu2);
		if( BU_LIST_FIRST_MAGIC( &lu2->down_hd ) == NMG_VERTEXUSE_MAGIC )  {
			vu2 = BU_LIST_FIRST( vertexuse, &lu2->down_hd );
			if( vu1->v_p == vu2->v_p )  {

				if( is->l1 ) nmg_enlist_vu( is, vu1, vu2, MAX_FASTF );
				ret++;
				continue;
			}
			/* Use 3D comparisons for uniformity */
			if( bn_pt3_pt3_equal( pt, vu2->v_p->vg_p->coord, &is->tol ) )  {
				/* Fuse the two verts together */
				nmg_jv( vu1->v_p, vu2->v_p );
				if( is->l1 ) nmg_enlist_vu( is, vu1, vu2, MAX_FASTF );
				ret++;
				continue;
			}
			continue;
		}
		for( BU_LIST_FOR( eu2, edgeuse, &lu2->down_hd ) )  {
			struct edgeuse	*new_eu;

			if( eu2->vu_p->v_p == vu1->v_p )  {
				if( is->l1 ) nmg_enlist_vu( is, vu1, eu2->vu_p, MAX_FASTF );
				ret++;
				continue;
			}

			new_eu = nmg_break_eu_on_v(eu2, vu1->v_p, fu2, is);
			if ( new_eu ) 
			{
				if( is->l1 ) nmg_enlist_vu( is, vu1, new_eu->vu_p, MAX_FASTF );
				ret++;
				continue;
			}
		}
	}

	if( ret == 0 )  {
		/* The vertex lies in the face, but touches nothing.  Place marker */
		if (rt_g.NMG_debug & DEBUG_POLYSECT)
		    	VPRINT("Making vertexloop", pt);

		lu2 = nmg_mlv(&fu2->l.magic, vu1->v_p, OT_BOOLPLACE);
		nmg_loop_g( lu2->l_p, &is->tol );
		vu2 = BU_LIST_FIRST( vertexuse, &lu2->down_hd );
		if(is->l1) nmg_enlist_vu( is, vu1, vu2, MAX_FASTF );
	}
}

/*
 *			N M G _ I S E C T _ 3 V E R T E X _ 3 F A C E
 *
 *	intersect a vertex with a face (primarily for intersecting
 *	loops of a single vertex with a face).
 *
 *  XXX It would be useful to have one of the new vu's in fu returned
 *  XXX as a flag, so that nmg_find_v_in_face() wouldn't have to be called
 *  XXX to re-determine what was just done.
 */
static void
nmg_isect_3vertex_3face(struct nmg_inter_struct *is, struct vertexuse *vu, struct faceuse *fu)
{
	struct vertexuse *vup;
	pointp_t pt;
	fastf_t dist;
	plane_t	n;

	NMG_CK_INTER_STRUCT(is);
	NMG_CK_VERTEXUSE(vu);
	NMG_CK_VERTEX(vu->v_p);
	NMG_CK_FACEUSE(fu);

	if (rt_g.NMG_debug & DEBUG_POLYSECT)
		bu_log("nmg_isect_3vertex_3face(, vu=x%x, fu=x%x) v=x%x\n", vu, fu, vu->v_p);

	/* check the topology first */	
	vup=nmg_find_v_in_face(vu->v_p, fu);
	if (vup) {
		if (rt_g.NMG_debug & DEBUG_POLYSECT) bu_log("\tvu lies in face (topology 1)\n");
		(void)bu_ptbl_ins_unique(is->l1, &vu->l.magic);
		(void)bu_ptbl_ins_unique(is->l2, &vup->l.magic);
		return;
	}


	/* since the topology didn't tell us anything, we need to check with
	 * the geometry
	 */
	pt = vu->v_p->vg_p->coord;
	NMG_GET_FU_PLANE( n, fu );
	dist = DIST_PT_PLANE(pt, n);

	if ( !NEAR_ZERO(dist, is->tol.dist) )  {
		if (rt_g.NMG_debug & DEBUG_POLYSECT) bu_log("\tvu not on face (geometry)\n");
		return;
	}

	/*
	 *  The point lies on the plane of the face, by geometry.
	 *  This is now a 2-D problem.
	 */
	(void)nmg_isect_vert2p_face2p( is, vu, fu );
}

/*
 *			N M G _ B R E A K _ 3 E D G E _ A T _ P L A N E
 *
 *	Having decided that an edge(use) crosses a plane of intersection,
 *	stick a vertex at the point of intersection along the edge.
 *
 *  vu1_final in fu1 is BU_LIST_PNEXT_CIRC(edgeuse,eu1)->vu_p after return.
 *  vu2_final is the returned value, and is in fu2.
 *
 */
static struct vertexuse *
nmg_break_3edge_at_plane(const fastf_t *hit_pt, struct faceuse *fu2, struct nmg_inter_struct *is, struct edgeuse *eu1)
             		       
              		     		/* The face that eu intersects */
                            
              		     		/* Edge to be broken (in fu1) */
{
	struct vertexuse *vu1_final;
	struct vertexuse *vu2_final;	/* hit_pt's vu in fu2 */
	struct vertex	*v2;
	struct loopuse	*plu2;		/* "point" loopuse */
	struct edgeuse	*eu1forw;	/* New eu, after break, forw of eu1 */
	struct vertex	*v1;
	struct vertex	*v1mate;
	fastf_t		dist;

	NMG_CK_INTER_STRUCT(is);
	NMG_CK_EDGEUSE(eu1);

	v1 = eu1->vu_p->v_p;
	NMG_CK_VERTEX(v1);
	v1mate = eu1->eumate_p->vu_p->v_p;
	NMG_CK_VERTEX(v1mate);

	/* Intersection is between first and second vertex points.
	 * Insert new vertex at intersection point.
	 */
	if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
		bu_log("nmg_break_3edge_at_plane() Splitting %g, %g, %g <-> %g, %g, %g\n",
			V3ARGS(v1->vg_p->coord),
			V3ARGS(v1mate->vg_p->coord) );
		VPRINT("\tAt point of intersection", hit_pt);
	}

	/* Double check for bad behavior */
	if( bn_pt3_pt3_equal( hit_pt, v1->vg_p->coord, &is->tol ) )
		rt_bomb("nmg_break_3edge_at_plane() hit_pt equal to v1\n");
	if( bn_pt3_pt3_equal( hit_pt, v1mate->vg_p->coord, &is->tol ) )
		rt_bomb("nmg_break_3edge_at_plane() hit_pt equal to v1mate\n");

	{
		vect_t	va, vb;
		VSUB2( va, hit_pt, eu1->vu_p->v_p->vg_p->coord  );
		VSUB2( vb, eu1->eumate_p->vu_p->v_p->vg_p->coord, hit_pt );
		VUNITIZE(va);
		VUNITIZE(vb);
		if( VDOT( va, vb ) <= 0.7071 )  {
			rt_bomb("nmg_break_3edge_at_plane() eu1 changes direction?\n");
		}
	}
	{
		struct bn_tol	t2;
		t2 = is->tol;	/* Struct copy */

		t2.dist = is->tol.dist * 4;
		t2.dist_sq = t2.dist * t2.dist;
		dist = DIST_PT_PT(hit_pt, v1->vg_p->coord);
		if( bn_pt3_pt3_equal( hit_pt, v1->vg_p->coord, &t2 ) )
			bu_log("NOTICE: nmg_break_3edge_at_plane() hit_pt nearly equal to v1 %g*tol\n", dist/is->tol.dist);
		dist = DIST_PT_PT(hit_pt, v1mate->vg_p->coord);
		if( bn_pt3_pt3_equal( hit_pt, v1mate->vg_p->coord, &t2 ) )
			bu_log("NOTICE: nmg_break_3edge_at_plane() hit_pt nearly equal to v1mate %g*tol\n", dist/is->tol.dist);
	}

	/* if we can't find the appropriate vertex in the
	 * other face by a geometry search, build a new vertex.
	 * Otherwise, re-use the existing one.
	 * Can't just search other face, might miss relevant vert.
	 */
	v2 = nmg_find_pt_in_model(fu2->s_p->r_p->m_p, hit_pt, &(is->tol));
	if (v2) {
		/* the other face has a convenient vertex for us */
		if (rt_g.NMG_debug & DEBUG_POLYSECT)
			bu_log("re-using vertex v=x%x from other shell\n", v2);

		eu1forw = nmg_ebreaker(v2, eu1, &(is->tol));
		vu1_final = eu1forw->vu_p;
		vu2_final = nmg_enlist_vu( is, vu1_final, 0, MAX_FASTF );
	} else {
		/* The other face has no vertex in this vicinity */
		/* If hit_pt falls outside all the loops in fu2,
		 * then there is no need to break this edge.
		 * XXX It is probably cheaper to call nmg_isect_3vertex_3face()
		 * XXX here first, causing any ON cases to be resolved into
		 * XXX shared topology first (and also cutting fu2 edges NOW),
		 * XXX and then run the classifier to answer IN/OUT.
		 * This is expensive.  For getting started, tolerate it.
		 */
		int	class;
		class = nmg_class_pt_fu_except( hit_pt, fu2,
			(struct loopuse *)NULL,
			(void (*)())NULL, (void (*)())NULL, (char *)NULL, 0,
			0, &is->tol );
		if( class == NMG_CLASS_AoutB )  {
			/* point outside face loop, no need to break eu1 */
#if 0
bu_log("%%%%%% point is outside face loop, no need to break eu1?\n");
			return (struct vertexuse *)NULL;
#endif
			/* Can't optimize this break out -- need to have
			 * the new vertexuse on the line of intersection,
			 * to drive the state machine of the face cutter!
			 */
		}

		eu1forw = nmg_ebreaker((struct vertex *)NULL, eu1, &is->tol);
		vu1_final = eu1forw->vu_p;
		nmg_vertex_gv(vu1_final->v_p, hit_pt);
		if (rt_g.NMG_debug & DEBUG_POLYSECT)
			bu_log("Made new vertex vu=x%x, v=x%x\n", vu1_final, vu1_final->v_p);

		NMG_CK_VERTEX_G(eu1->vu_p->v_p->vg_p);
		NMG_CK_VERTEX_G(eu1->eumate_p->vu_p->v_p->vg_p);
		NMG_CK_VERTEX_G(eu1forw->vu_p->v_p->vg_p);
		NMG_CK_VERTEX_G(eu1forw->eumate_p->vu_p->v_p->vg_p);

		if (rt_g.NMG_debug & DEBUG_POLYSECT) {
			register pointp_t p1 = eu1->vu_p->v_p->vg_p->coord;
			register pointp_t p2 = eu1->eumate_p->vu_p->v_p->vg_p->coord;

			bu_log("After split eu1 x%x= %g, %g, %g -> %g, %g, %g\n",
				eu1,
				V3ARGS(p1), V3ARGS(p2) );
			p1 = eu1forw->vu_p->v_p->vg_p->coord;
			p2 = eu1forw->eumate_p->vu_p->v_p->vg_p->coord;
			bu_log("\teu1forw x%x = %g, %g, %g -> %g, %g, %g\n",
				eu1forw,
				V3ARGS(p1), V3ARGS(p2) );
		}

		switch(class)  {
		case NMG_CLASS_AinB:
			/* point inside a face loop, break edge */
			break;
		case NMG_CLASS_AonBshared:
			/* point is on a loop boundary.  Break fu2 loop too? */
			if (rt_g.NMG_debug & DEBUG_POLYSECT)
				bu_log("%%%%%% point is on loop boundary.  Break fu2 loop too?\n");
			nmg_isect_3vertex_3face( is, vu1_final, fu2 );
			/* XXX should get new vu2 from isect_3vertex_3face! */
			vu2_final = nmg_find_v_in_face( vu1_final->v_p, fu2 );
			if( !vu2_final ) rt_bomb("%%%%%% missed!\n");
			NMG_CK_VERTEXUSE(vu2_final);
			nmg_enlist_vu( is, vu1_final, vu2_final, MAX_FASTF );
			return vu2_final;
		case NMG_CLASS_AoutB:
			/* Can't optimize this, break edge anyway. */
			break;
		default:
			rt_bomb("nmg_break_3edge_at_plane() bad classification return from nmg_class_pt_f()\n");
		}

		/* stick this vertex in the other shell
		 * and make sure it is in the other shell's
		 * list of vertices on the intersect line
		 */
		plu2 = nmg_mlv(&fu2->l.magic, vu1_final->v_p, OT_BOOLPLACE);
		vu2_final = BU_LIST_FIRST( vertexuse, &plu2->down_hd );
		NMG_CK_VERTEXUSE(vu2_final);
		nmg_loop_g(plu2->l_p, &is->tol);

		if (rt_g.NMG_debug & DEBUG_POLYSECT) {
			bu_log("Made vertexloop in other face. lu=x%x vu=x%x on v=x%x\n",
				plu2, 
				vu2_final, vu2_final->v_p);
		}
		vu2_final = nmg_enlist_vu( is, vu1_final, vu2_final, MAX_FASTF );
	}

	if (rt_g.NMG_debug & DEBUG_POLYSECT) {
		register pointp_t	p1, p2;
		p1 = eu1->vu_p->v_p->vg_p->coord;
		p2 = eu1->eumate_p->vu_p->v_p->vg_p->coord;
		bu_log("\tNow %g, %g, %g <-> %g, %g, %g\n",
			V3ARGS(p1), V3ARGS(p2) );
		p1 = eu1forw->vu_p->v_p->vg_p->coord;
		p2 = eu1forw->eumate_p->vu_p->v_p->vg_p->coord;
		bu_log("\tand %g, %g, %g <-> %g, %g, %g\n\n",
			V3ARGS(p1), V3ARGS(p2) );
	}
	return vu2_final;
}

/*
 *			N M G _ B R E A K _ E U _ O N _ V
 *
 *  The vertex 'v2' is known to lie in the plane of eu1's face.
 *  If v2 lies between the two endpoints of eu1, break eu1 and
 *  return the new edgeuse pointer.
 *
 *  If an edgeuse vertex is joined with v2, v2 remains as the survivor,
 *  as the caller is working on it explicitly, and the edgeuse vertices
 *  are dealt with implicitly (by dereferencing the eu pointers).
 *  Otherwise, we will invalidate our caller's v2 pointer.
 *
 *  Note that no "intersection line" stuff is done, the goal here is
 *  just to get the edge appropriately broken.
 *
 *  Either faceuse can be passed in, but it needs to be consistent with the
 *  faceuse used to establish the 2d vertex cache.
 *
 *  Returns -
 *	new_eu	if edge is broken
 *	0	otherwise
 */
struct edgeuse *
nmg_break_eu_on_v(struct edgeuse *eu1, struct vertex *v2, struct faceuse *fu, struct nmg_inter_struct *is)
              		     
             		    
              		    	/* for plane equation of (either) face */
                       	    
{
	point_t		a;
	point_t		b;
	point_t		p;
	int		code;
	fastf_t		dist;
	struct vertex	*v1a;
	struct vertex	*v1b;
	struct edgeuse		*new_eu = (struct edgeuse *)0;

	NMG_CK_EDGEUSE(eu1);
	NMG_CK_VERTEX(v2);
	NMG_CK_FACEUSE(fu);
	NMG_CK_INTER_STRUCT(is);

	v1a = eu1->vu_p->v_p;
	v1b = BU_LIST_PNEXT_CIRC( edgeuse, eu1 )->vu_p->v_p;

	/* Check for already shared topology */
	if( v1a == v2 || v1b == v2 )  {
		goto out;
	}

	/* Map to 2d */
	nmg_get_2d_vertex( a, v1a, is, &fu->l.magic );
	nmg_get_2d_vertex( b, v1b, is, &fu->l.magic );
	nmg_get_2d_vertex( p, v2, is, &fu->l.magic );

	dist = -INFINITY;
	code = bn_isect_pt2_lseg2( &dist, a, b, p, &(is->tol) );

	switch(code)  {
	case -2:
		/* P outside AB */
		break;
	default:
	case -1:
		/* P not on line */
#if 0
		/* This can happen when v2 is a long way from the lseg */
		V2PRINT("a", a);
		V2PRINT("p", p);
		V2PRINT("b", b);
		VPRINT("A", v1a->vg_p->coord);
		VPRINT("P", v2->vg_p->coord);
		VPRINT("B", v1b->vg_p->coord);
		rt_bomb("nmg_break_eu_on_v() P not on line?\n");
#endif
		break;
	case 1:
		/* P is at A */
		nmg_jv( v2, v1a );	/* v2 must be surviving vertex */
		break;
	case 2:
		/* P is at B */
		nmg_jv( v2, v1b );	/* v2 must be surviving vertex */
		break;
	case 3:
		/* P is in the middle, break edge */
		new_eu = nmg_ebreaker( v2, eu1, &is->tol );
		if (rt_g.NMG_debug & DEBUG_POLYSECT) {
			bu_log("nmg_break_eu_on_v() breaking eu=x%x on v=x%x, new_eu=x%x\n",
				eu1, v2, new_eu );
		}
		break;
	}

out:
	return new_eu;
}

/*
 *			N M G _ B R E A K _ E G _ O N _ V
 *
 *  Given a vertex 'v' which is already known to have geometry that lies
 *  on the line defined by 'eg', break all the edgeuses along 'eg'
 *  which cross 'v'.
 *
 *  Calculation is done in 1 dimension:  parametric distance along 'eg'.
 *  Edge direction vector needs to be made unit length so that tol->dist
 *  makes sense.
 */
void
nmg_break_eg_on_v(const struct edge_g_lseg *eg, struct vertex *v, const struct bn_tol *tol)
{
	register struct edgeuse	**eup;
	struct bu_ptbl	eutab;
	vect_t		dir;
	double		vdist;

	NMG_CK_EDGE_G_LSEG(eg);
	NMG_CK_VERTEX(v);
	BN_CK_TOL(tol);

	VMOVE( dir, eg->e_dir );
	VUNITIZE( dir );
	vdist = bn_dist_pt3_along_line3( eg->e_pt, dir, v->vg_p->coord );

	/* This has to be a table, because nmg_ebreaker() will
	 * change the list on the fly, otherwise.
	 */
	nmg_edgeuse_with_eg_tabulate( &eutab, eg );

	for( eup = (struct edgeuse **)BU_PTBL_LASTADDR(&eutab);
	     eup >= (struct edgeuse **)BU_PTBL_BASEADDR(&eutab);
	     eup--
	)  {
		struct vertex	*va;
		struct vertex	*vb;
		double		a;
		double		b;
		struct edgeuse	*new_eu;

		NMG_CK_EDGEUSE(*eup);
		if( (*eup)->g.lseg_p != eg )  rt_bomb("nmg_break_eg_on_v() eu disowns eg\n");

		va = (*eup)->vu_p->v_p;
		vb = (*eup)->eumate_p->vu_p->v_p;
		if( v == va || v == vb )  continue;
		if( bn_pt3_pt3_equal( v->vg_p->coord, va->vg_p->coord, tol ) )  {
			nmg_jv( v, va );
			continue;
		}
		if( bn_pt3_pt3_equal( v->vg_p->coord, vb->vg_p->coord, tol ) )  {
			nmg_jv( v, vb );
			continue;
		}
		a = bn_dist_pt3_along_line3( eg->e_pt, dir, va->vg_p->coord );
		b = bn_dist_pt3_along_line3( eg->e_pt, dir, vb->vg_p->coord );
		if( NEAR_ZERO( a-vdist, tol->dist ) )  continue;
		if( NEAR_ZERO( b-vdist, tol->dist ) )  continue;
		if( !bn_between( a, vdist, b, tol ) )  continue;
		new_eu = nmg_ebreaker( v, *eup, tol );
		if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
			bu_log("nmg_break_eg_on_v( eg=x%x, v=x%x ) new_eu=x%x\n",
				eg, v, new_eu );
		}
	}
	bu_ptbl_free( &eutab);
}

/*
 *			N M G _ I S E C T _ 2 C O L I N E A R _ E D G E 2 P
 *
 *  Perform edge mutual breaking only on two colinear edgeuses.
 *  This can result in 2 new edgeuses showing up in either loop (case A & D).
 *  The vertexuse lists are updated to have all participating vu's and
 *  their duals.
 *
 *  Two colinear line segments (eu1 and eu2, or just "1" and "2" in the
 *  diagram) can overlap each other in one of 9 configurations,
 *  labeled A through I:
 *
 *	A	B	C	D	E	F	G	H	I
 *
 *  vu1b,vu2b
 *	*	*	  *	  *	*	  *	*	  *	*=*
 *	1	1	  2	  2	1	  2	1	  2	1 2
 *	1=*	1	  2	*=2	1=*	*=2	*	  *	1 2
 *	1 2	*=*	*=*	1 2	1 2	1 2			1 2
 *	1 2	  2	1	1 2	1 2	1 2	  *	*	1 2
 *	1=*	  2	1	*=2	*=2	1=*	  2	1	1 2
 *	1	  *	*	  2	  2	1	  *	*	1 2
 *	*			  *	  *	*			*=*
 *   vu1a,vu2a
 *
 *  To ensure nothing is missed, break every edgeuse on all 4 vertices.
 *  If a new edgeuse is created, add it to the list of edgeuses still to be
 *  broken.
 *  Brute force, but *certain* not to miss anything.
 *
 *  There is nothing to prevent eu1 and eu2 from being edgeuses in the same
 *  loop.  This creates interesting patterns if one is NEXT of the other,
 *  such as vu[1] == vu[2].  Just handle it gracefully.
 *
 *  Returns the number of edgeuses that resulted,
 *  which is always at least the original 2.
 *
 */
int
nmg_isect_2colinear_edge2p(struct edgeuse *eu1, struct edgeuse *eu2, struct faceuse *fu, struct nmg_inter_struct *is, struct bu_ptbl *l1, struct bu_ptbl *l2)
              	     
              	     
              		    	/* for plane equation of (either) face */
                       	    
              		    	/* optional: list of new eu1 pieces */
              		    	/* optional: list of new eu2 pieces */
{
	struct edgeuse	*eu[10];
	struct vertexuse *vu[4];
	register int	i;
	register int	j;
	int		neu;	/* Number of edgeuses */

	if (rt_g.NMG_debug & DEBUG_POLYSECT) {
		bu_log("nmg_isect_2colinear_edge2p(eu1=x%x, eu2=x%x) START\n",
			eu1, eu2);
	}

	NMG_CK_EDGEUSE(eu1);
	NMG_CK_EDGEUSE(eu2);
	NMG_CK_FACEUSE(fu);	/* Don't check it, just pass it on down. */
	NMG_CK_INTER_STRUCT(is);
	if( l1 )  BU_CK_PTBL(l1);
	if( l2 )  BU_CK_PTBL(l2);

	vu[0] = eu1->vu_p;
	vu[1] = BU_LIST_PNEXT_CIRC( edgeuse, eu1 )->vu_p;
	vu[2] = eu2->vu_p;
	vu[3] = BU_LIST_PNEXT_CIRC( edgeuse, eu2 )->vu_p;

	eu[0] = eu1;
	eu[1] = eu2;
	neu = 2;

	for( i=0; i < neu; i++ )  {
		for( j=0; j<4; j++ )  {
			eu[neu] = nmg_break_eu_on_v(eu[i],vu[j]->v_p,fu,is);
			if( eu[neu] )  {
				nmg_enlist_vu( is, eu[neu]->vu_p, vu[j], MAX_FASTF );
				if( l1 && eu[neu]->e_p == eu1->e_p )
					bu_ptbl_ins_unique(l1, &eu[neu]->l.magic );
				else if( l2 && eu[neu]->e_p == eu2->e_p )
					bu_ptbl_ins_unique(l2, &eu[neu]->l.magic );
				neu++;
			}
		}
	}

	/* Now join 'em up */
	/*  This step should no longer be necessary, as nmg_ebreaker()
	 *  from nmg_break_eu_on_v() should have already handled this. */
	for( i=0; i < neu-1; i++ )  {
		for( j=i+1; j < neu; j++ )  {
			if( !NMG_ARE_EUS_ADJACENT(eu[i],eu[j]) )  continue;
			nmg_radial_join_eu( eu[i], eu[j], &(is->tol) );
		}
	}

	/* Enlist all four of the original endpoints */
	for( i=0; i < 4; i++ )  {
		for( j=0; j < 4; j++ )  {
			if( i==j )  continue;
			if( vu[i] == vu[j] ) continue;	/* Happens if eu2 follows eu1 in loop */
			if( vu[i]->v_p == vu[j]->v_p )  {
				nmg_enlist_vu( is, vu[i], vu[j], MAX_FASTF );
				goto next_i;
			}
		}
		/* No match, let subroutine hunt for dual */
		nmg_enlist_vu( is, vu[i], 0, MAX_FASTF );
next_i:		;
	}

	if (rt_g.NMG_debug & DEBUG_POLYSECT) {
		bu_log("nmg_isect_2colinear_edge2p(eu1=x%x, eu2=x%x) ret #eu=%d\n",
			eu1, eu2, neu);
	}
	return neu;
}

/*
 *			N M G _ I S E C T _ E D G E 2 P _ E D G E 2 P
 *
 *  Actual 2d edge/edge intersector
 *
 *  One or both of the edges may be wire edges, i.e.
 *  either or both of the fu1 and fu2 args may be null.
 *  If so, the vert_list's are unimportant.
 *
 *  Returns a bit vector -
 *	ISECT_NONE	no intersection
 *	ISECT_SHARED_V	intersection was at (at least one) shared vertex
 *	ISECT_SPLIT1	eu1 was split at (geometric) intersection.
 *	ISECT_SPLIT2	eu2 was split at (geometric) intersection.
 */
int
nmg_isect_edge2p_edge2p(struct nmg_inter_struct *is, struct edgeuse *eu1, struct edgeuse *eu2, struct faceuse *fu1, struct faceuse *fu2)
                       	    
              		     
              		     
              		     		/* fu of eu1, for plane equation */
              		     		/* fu of eu2, for error checks */
{
	point_t		eu1_start;
	point_t		eu1_end;
	vect_t		eu1_dir;
	point_t		eu2_start;
	point_t		eu2_end;
	vect_t		eu2_dir;
	vect_t		dir3d;
	fastf_t		dist[2];
	int		status;
	point_t		hit_pt;
	struct vertexuse	*vu;
	struct vertexuse	*vu1a, *vu1b;
	struct vertexuse	*vu2a, *vu2b;
	struct model		*m;
	int		ret = 0;

	NMG_CK_INTER_STRUCT(is);
	NMG_CK_EDGEUSE(eu1);
	NMG_CK_EDGEUSE(eu2);
	m = nmg_find_model(&eu1->l.magic);
	NMG_CK_MODEL(m);
	/*
	 * Important note:  don't use eu1->eumate_p->vu_p here,
	 * because that vu is in the opposite orientation faceuse.
	 * Putting those vu's on the intersection line makes for big trouble.
	 */
	vu1a = eu1->vu_p;
	vu1b = BU_LIST_PNEXT_CIRC( edgeuse, eu1 )->vu_p;
	vu2a = eu2->vu_p;
	vu2b = BU_LIST_PNEXT_CIRC( edgeuse, eu2 )->vu_p;
	NMG_CK_VERTEXUSE(vu1a);
	NMG_CK_VERTEXUSE(vu1b);
	NMG_CK_VERTEXUSE(vu2a);
	NMG_CK_VERTEXUSE(vu2b);

	if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
		bu_log("nmg_isect_edge2p_edge2p(eu1=x%x, eu2=x%x) START\n\tfu1=x%x, fu2=x%x\n\tvu1a=%x vu1b=%x, vu2a=%x vu2b=%x\n\tv1a=%x v1b=%x,   v2a=%x v2b=%x\n",
			eu1, eu2,
			fu1, fu2,
			vu1a, vu1b, vu2a, vu2b,
			vu1a->v_p, vu1b->v_p, vu2a->v_p, vu2b->v_p );
	}

	/*
	 *  Topology check.
	 *  If both endpoints of both edges match, this is a trivial accept.
	 */
	if( vu1a->v_p == vu2a->v_p && vu1b->v_p == vu2b->v_p )  {
		if (rt_g.NMG_debug & DEBUG_POLYSECT)
			bu_log("nmg_isect_edge2p_edge2p: shared edge topology, both ends\n");
    		nmg_radial_join_eu(eu1, eu2, &is->tol );
	    	nmg_enlist_vu( is, vu1a, vu2a, MAX_FASTF );
	    	nmg_enlist_vu( is, vu1b, vu2b, MAX_FASTF );
	    	ret = ISECT_SHARED_V;
		goto out;		/* vu1a, vu1b already listed */
	}
	if( vu1a->v_p == vu2b->v_p && vu1b->v_p == vu2a->v_p )  {
		if (rt_g.NMG_debug & DEBUG_POLYSECT)
			bu_log("nmg_isect_edge2p_edge2p: shared edge topology, both ends, reversed.\n");
    		nmg_radial_join_eu(eu1, eu2, &is->tol );
	    	nmg_enlist_vu( is, vu1a, vu2b, MAX_FASTF );
	    	nmg_enlist_vu( is, vu1b, vu2a, MAX_FASTF );
	    	ret = ISECT_SHARED_V;
		goto out;		/* vu1a, vu1b already listed */
	}

	/*
	 *  The 3D line in is->pt and is->dir is prepared by the caller.
	 *  is->pt is *not* one of the endpoints of this edge.
	 *
	 *  IMPORTANT NOTE:  The edge-ray used for the edge intersection
	 *  calculations is colinear with the "intersection line",
	 *  but the edge-ray starts at vu1a and points to vu1b,
	 *  while the intersection line has to satisfy different constraints.
	 *  Don't confuse the two!
	 */
	nmg_get_2d_vertex( eu1_start, vu1a->v_p, is, &fu2->l.magic );	/* 2D line */
	nmg_get_2d_vertex( eu1_end, vu1b->v_p, is, &fu2->l.magic );
	VSUB2_2D( eu1_dir, eu1_end, eu1_start );

	nmg_get_2d_vertex( eu2_start, vu2a->v_p, is, &fu2->l.magic );
	nmg_get_2d_vertex( eu2_end, vu2b->v_p, is, &fu2->l.magic );
	VSUB2_2D( eu2_dir, eu2_end, eu2_start );

	dist[0] = dist[1] = 0;	/* for clean prints, below */

	/* The "proper" thing to do is intersect two line segments.
	 * However, this means that none of the intersections of edge "line"
	 * with the exterior of the loop are computed, and that
	 * violates the strategy assumptions of the face-cutter.
	 */
	/* To pick up ALL intersection points, the source edge is a line */
	status = bn_isect_line2_lseg2( dist, eu1_start, eu1_dir,
			eu2_start, eu2_dir, &is->tol );

	if (rt_g.NMG_debug & DEBUG_POLYSECT) {
		bu_log("\tbn_isect_line2_lseg2()=%d, dist: %g, %g\n",
			status, dist[0], dist[1] );
	}

	/*
	 *  Whether geometry hits or misses, as long as not colinear, check topo.
	 *  If one endpoint matches, and edges are not colinear,
	 *  then accept the one shared vertex as the intersection point.
	 *  Can't do this before geometry check, or we might miss the
	 *  colinear condition, and not do the mutual intersection.
	 */
	if( status != 0 &&
	    (vu1a->v_p == vu2a->v_p || vu1a->v_p == vu2b->v_p ||
	    vu1b->v_p == vu2a->v_p || vu1b->v_p == vu2b->v_p )
	)  {
		if (rt_g.NMG_debug & DEBUG_POLYSECT)
			bu_log("edge2p_edge2p: non-colinear edges share one vertex (topology)\n");
		if( vu1a->v_p == vu2a->v_p )
			nmg_enlist_vu( is, vu1a, vu2a, MAX_FASTF );
		else if( vu1a->v_p == vu2b->v_p )
			nmg_enlist_vu( is, vu1a, vu2b, MAX_FASTF );

		if( vu1b->v_p == vu2a->v_p )
			nmg_enlist_vu( is, vu1b, vu2a, MAX_FASTF );
		else if( vu1b->v_p == vu2b->v_p )
			nmg_enlist_vu( is, vu1b, vu2b, MAX_FASTF );

		ret = ISECT_SHARED_V;
		goto out;		/* vu1a, vu1b already listed */
	}

	if (status < 0)  {
		ret = ISECT_NONE;	/* No geometric intersection */
		goto topo;		/* Still need to list vu1a, vu2b */
	}

	if( status == 0 )  {
		/* Lines are co-linear and on line of intersection. */
		/* Perform full mutual intersection, and vu enlisting. */
		if( nmg_isect_2colinear_edge2p( eu1, eu2, fu2, is, (struct bu_ptbl *)0, (struct bu_ptbl *)0 ) > 2 )  {
			/* Can't tell which edgeuse(s) got split */
			ret = ISECT_SPLIT1 | ISECT_SPLIT2;
		} else {
			/* XXX Can't tell if some sharing ensued.  Does it matter? */
			/* No, not for the one place we are called. */
			ret = ISECT_NONE;
		}
		goto out;		/* vu1a, vu1b listed by nmg_isect_2colinear_edge2p */
	}

	/* There is only one intersect point.  Break one or both edges. */


	/* The ray defined by the edgeuse line eu1 intersects the lseg eu2.
	 * Tolerances have already been factored in.
	 * The edge exists over values of 0 <= dist <= 1.
	 */
	VSUB2( dir3d, vu1b->v_p->vg_p->coord, vu1a->v_p->vg_p->coord );
	VJOIN1( hit_pt, vu1a->v_p->vg_p->coord, dist[0], dir3d );

	if ( dist[0] == 0 )  {
		/* First point of eu1 is on eu2, by geometry */
		if (rt_g.NMG_debug & DEBUG_POLYSECT)
			bu_log("\tvu=x%x vu1a is intersect point\n", vu1a);
		if( dist[1] < 0 || dist[1] > 1 )  {
			if (rt_g.NMG_debug & DEBUG_POLYSECT)
				bu_log("\teu1 line intersects eu2 outside vu2a...vu2b range, ignore.\n");
			ret = ISECT_NONE;
			goto topo;
		}

		/* Edges not colinear. Either join up with a matching vertex,
		 * or break eu2 on our vert.
		 */
		if( dist[1] == 0 )  {
			if (rt_g.NMG_debug & DEBUG_POLYSECT)
				bu_log("\tvu2a matches vu1a\n");
			nmg_jv(vu1a->v_p, vu2a->v_p);
			nmg_enlist_vu( is, vu1a, vu2a, MAX_FASTF );
			ret = ISECT_SHARED_V;
			goto topo;
		}
		if( dist[1] == 1 )  {
			if (rt_g.NMG_debug & DEBUG_POLYSECT)
				bu_log("\tsecond point of eu2 matches vu1a\n");
			nmg_jv(vu1a->v_p, vu2b->v_p);
			nmg_enlist_vu( is, vu1a, vu2b, MAX_FASTF );
			ret = ISECT_SHARED_V;
			goto topo;
		}
		/* Break eu2 on our first vertex */
		if (rt_g.NMG_debug & DEBUG_POLYSECT)
			bu_log("\tbreaking eu2 on vu1a\n");
		vu = nmg_ebreaker( vu1a->v_p, eu2, &is->tol )->vu_p;
		nmg_enlist_vu( is, vu1a, vu, MAX_FASTF );
		ret = ISECT_SPLIT2;	/* eu1 not broken, just touched */
		goto topo;
	}

	if ( dist[0] == 1 )  {
		/* Second point of eu1 is on eu2, by geometry */
		if (rt_g.NMG_debug & DEBUG_POLYSECT)
			bu_log("\tvu=x%x vu1b is intersect point\n", vu1b);
		if( dist[1] < 0 || dist[1] > 1 )  {
			if (rt_g.NMG_debug & DEBUG_POLYSECT)
				bu_log("\teu1 line intersects eu2 outside vu2a...vu2b range, ignore.\n");
			ret = ISECT_NONE;
			goto topo;
		}

		/* Edges not colinear. Either join up with a matching vertex,
		 * or break eu2 on our vert.
		 */
		if( dist[1] == 0 )  {
			if (rt_g.NMG_debug & DEBUG_POLYSECT)
				bu_log("\tvu2a matches vu1b\n");
			nmg_jv(vu1b->v_p, vu2a->v_p);
			nmg_enlist_vu( is, vu1b, vu2a, MAX_FASTF );
			ret = ISECT_SHARED_V;
			goto topo;
		}
		if( dist[1] == 1 )  {
			if (rt_g.NMG_debug & DEBUG_POLYSECT)
				bu_log("\tsecond point of eu2 matches vu1b\n");
			nmg_jv(vu1b->v_p, vu2b->v_p);
			nmg_enlist_vu( is, vu1b, vu2b, MAX_FASTF );
			ret = ISECT_SHARED_V;
			goto topo;
		}
		/* Break eu2 on our second vertex */
		if (rt_g.NMG_debug & DEBUG_POLYSECT)
			bu_log("\tbreaking eu2 on vu1b\n");
		vu = nmg_ebreaker( vu1b->v_p, eu2, &is->tol )->vu_p;
		nmg_enlist_vu( is, vu1b, vu, MAX_FASTF );
		ret = ISECT_SPLIT2;	/* eu1 not broken, just touched */
		goto topo;
	}

	/*  eu2 intersect point is on eu1 line, but not between vertices.
	 *  Since it crosses the line of intersection, it must be broken.
	 */
	if( dist[0] < 0 || dist[0] > 1 )  {
		if (rt_g.NMG_debug & DEBUG_POLYSECT)
			bu_log("\tIntersect point on eu2 is outside vu1a...vu1b.  Break eu2 anyway.\n");

		if( dist[1] == 0 )  {
			nmg_enlist_vu( is, vu2a, 0, MAX_FASTF );
			ret = ISECT_SHARED_V;		/* eu1 was not broken */
			goto topo;
		} else if( dist[1] == 1 )  {
			nmg_enlist_vu( is, vu2b, 0, MAX_FASTF );
			ret = ISECT_SHARED_V;		/* eu1 was not broken */
			goto topo;
		} else if( dist[1] > 0 && dist[1] < 1 )  {
			/* Break eu2 somewhere in the middle */
			struct vertexuse	*new_vu2;
			struct vertex		*new_v2;
			if (rt_g.NMG_debug & DEBUG_POLYSECT)
			    	VPRINT("\t\tBreaking eu2 at intersect point", hit_pt);
			new_v2 = nmg_find_pt_in_model(m, hit_pt, &(is->tol) );
			new_vu2 = nmg_ebreaker( new_v2, eu2, &is->tol )->vu_p;
			if( !new_v2 )  {
				/* A new vertex was created, assign geom */
				nmg_vertex_gv( new_vu2->v_p, hit_pt );	/* 3d geom */
			}
			nmg_enlist_vu( is, new_vu2, 0, MAX_FASTF );
			ret = ISECT_SPLIT2;	/* eu1 was not broken */
			goto topo;
		}

		/* Hit point not on either eu1 or eu2, nothing to do */
		ret = ISECT_NONE;
		goto topo;
	}

	/* Intersection is in the middle of the reference edge (eu1) */
	/* dist[0] >= 0 && dist[0] <= 1 ) */
	if (rt_g.NMG_debug & DEBUG_POLYSECT)
		bu_log("\tintersect is in middle of eu1, breaking it\n");

	/* Edges not colinear. Either join up with a matching vertex,
	 * or break eu2 on our vert.
	 */
	if( dist[1] == 0 )  {
		if (rt_g.NMG_debug & DEBUG_POLYSECT)
			bu_log("\t\tintersect point is vu2a\n");
		vu = nmg_ebreaker( vu2a->v_p, eu1, &is->tol )->vu_p;
		nmg_enlist_vu( is, vu2a, vu, MAX_FASTF );
		ret |= ISECT_SPLIT1;
		goto topo;
	} else if( dist[1] == 1 )  {
		if (rt_g.NMG_debug & DEBUG_POLYSECT)
			bu_log("\t\tintersect point is vu2b\n");
		vu = nmg_ebreaker( vu2b->v_p, eu1, &is->tol )->vu_p;
		nmg_enlist_vu( is, vu2b, vu, MAX_FASTF );
		ret |= ISECT_SPLIT1;
		goto topo;
	} else if( dist[1] > 0 && dist[1] < 1 )  {
		/* Intersection is in the middle of both, split edge */
		struct vertex	*new_v;
		if (rt_g.NMG_debug & DEBUG_POLYSECT)
		    	VPRINT("\t\tBreaking both edges at intersect point", hit_pt);
		ret = ISECT_SPLIT1 | ISECT_SPLIT2;
		new_v = nmg_e2break( eu1, eu2 );
		nmg_vertex_gv( new_v, hit_pt );	/* 3d geometry */

		/* new_v is at far end of eu1 and eu2 */
		if( eu1->eumate_p->vu_p->v_p != new_v ) rt_bomb("new_v 1\n");
		if( eu2->eumate_p->vu_p->v_p != new_v ) rt_bomb("new_v 2\n");
		/* Can't use eumate_p here, it's in wrong orientation face */
		nmg_enlist_vu( is, BU_LIST_PNEXT_CIRC(edgeuse,eu1)->vu_p,
			BU_LIST_PNEXT_CIRC(edgeuse,eu2)->vu_p, MAX_FASTF );
		goto topo;
	} else {
		/* Intersection is in middle of eu1, which lies on the
		 * line of intersection being computed, but is outside
		 * the endpoints of eu2.  There is no point in breaking
		 * eu1 here -- it does not connnect up with anything.
		 */
		ret = ISECT_NONE;
		goto topo;
	}

topo:
	/*
	 *  Listing of any vu's from eu2 will have been done above.
	 *
	 *  The *original* vu1a and vu1b (and their duals) MUST be
	 *  forcibly listed on
	 *  the intersection line, since eu1 lies ON the line!
	 *
	 *  This is done last, so that the intersection code (above) has
	 *  the opportunity to create the duals.
	 *  vu1a and vu1b don't have to have anything to do with eu2,
	 *  hence the 2nd vu argument is unspecified (0).
	 *  For our purposes here, we will be satisfied with *any* use
	 *  of the same vertex in the other face.
	 */
	nmg_enlist_vu( is, vu1a, 0, MAX_FASTF );
	nmg_enlist_vu( is, vu1b, 0, MAX_FASTF );
out:
	/* By here, vu1a and vu1b MUST have been enlisted */
	if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
		bu_log("nmg_isect_edge2p_edge2p(eu1=x%x, eu2=x%x) END, ret=%d %s%s%s\n",
			eu1, eu2, ret,
			(ret&ISECT_SHARED_V)? "SHARED_V|" :
				((ret==0) ? "NONE" : ""),
			(ret&ISECT_SPLIT1)? "SPLIT1|" : "",
			(ret&ISECT_SPLIT2)? "SPLIT2" : ""
		);
	}

	return ret;
}

/*
 *			N M G _ I S E C T _ W I R E E D G E 3 P _ F A C E 3 P
 *
 *  Intersect an edge eu1 with a faceuse fu2.
 *  eu1 may belong to fu1, or it may be a wire edge.
 *
 *  XXX It is not clear whether we need the caller to provide the
 *  line equation, or if we should just create it here.
 *  If done here, the start pt needs to be outside fu2 (fu1 also?)
 *
 *  Returns -
 *	0	If everything went well
 *	1	If vu[] list along the intersection line needs to be re-done.
 */
static int
nmg_isect_wireedge3p_face3p(struct nmg_inter_struct *is, struct edgeuse *eu1, struct faceuse *fu2)
{
	struct vertexuse *vu1_final = (struct vertexuse *)NULL;
	struct vertexuse *vu2_final = (struct vertexuse *)NULL;
	struct vertex	*v1a;		/* vertex at start of eu1 */
	struct vertex	*v1b;		/* vertex at end of eu1 */
	point_t		hit_pt;
	vect_t		edge_vect;
	fastf_t		edge_len;	/* MAGNITUDE(edge_vect) */
	fastf_t		dist;		/* parametric dist to hit point */
	fastf_t		dist_to_plane;	/* distance to hit point, in mm */
	int		status;
	vect_t		start_pt;
	struct edgeuse	*eunext;
	struct faceuse	*fu1;		/* fu that contains eu1 */
	plane_t		n2;
	int		ret = 0;

	if (rt_g.NMG_debug & DEBUG_POLYSECT)
		bu_log("nmg_isect_wireedge3p_face3p(, eu1=x%x, fu2=x%x) START\n", eu1, fu2);

	NMG_CK_INTER_STRUCT(is);
	NMG_CK_EDGEUSE(eu1);
	NMG_CK_VERTEXUSE(eu1->vu_p);
	v1a = eu1->vu_p->v_p;
	NMG_CK_VERTEX(v1a);
	NMG_CK_VERTEX_G(v1a->vg_p);

	NMG_CK_EDGEUSE(eu1->eumate_p);
	NMG_CK_VERTEXUSE(eu1->eumate_p->vu_p);
	v1b = eu1->eumate_p->vu_p->v_p;
	NMG_CK_VERTEX(v1b);
	NMG_CK_VERTEX_G(v1b->vg_p);

	NMG_CK_FACEUSE(fu2);
	if( fu2->orientation != OT_SAME )  rt_bomb("nmg_isect_wireedge3p_face3p() fu2 not OT_SAME\n");
	fu1 = nmg_find_fu_of_eu(eu1);	/* May be NULL */

	/*
	 *  Form a ray that starts at one vertex of the edgeuse
	 *  and points to the other vertex.
	 */
	VSUB2(edge_vect, v1b->vg_p->coord, v1a->vg_p->coord);
	edge_len = MAGNITUDE(edge_vect);

	VMOVE( start_pt, v1a->vg_p->coord );

	{
		/* XXX HACK */
		double	dot;
		dot = fabs( VDOT( is->dir, edge_vect ) / edge_len ) - 1;
		if( !NEAR_ZERO( dot, .01 ) )  {
			bu_log("HACK HACK cough cough.  Resetting is->pt, is->dir\n");
			VPRINT("old is->pt ", is->pt);
			VPRINT("old is->dir", is->dir);
			VMOVE( is->pt, start_pt );
			VMOVE( is->dir, edge_vect );
			VUNITIZE(is->dir);
			VPRINT("new is->pt ", is->pt);
			VPRINT("new is->dir", is->dir);
		}
	}

	NMG_GET_FU_PLANE( n2, fu2 );
	if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
		bu_log("Testing (%g, %g, %g) -> (%g, %g, %g) dir=(%g, %g, %g)\n",
			V3ARGS(start_pt),
			V3ARGS(v1b->vg_p->coord),
			V3ARGS(edge_vect) );
		PLPRINT("\t", n2);
	}

	status = bn_isect_line3_plane(&dist, start_pt, edge_vect,
		n2, &is->tol);

	if (rt_g.NMG_debug & DEBUG_POLYSECT) {
	    if (status >= 0)
		bu_log("\tHit. bn_isect_line3_plane=%d, dist=%g (%e)\n",
			status, dist, dist);
	    else
		bu_log("\tMiss. Boring status of bn_isect_line3_plane: %d\n",
			status);
	}
	if( status == 0 )  {
		struct nmg_inter_struct	is2;

		/*
		 *  Edge (ray) lies in the plane of the other face,
		 *  by geometry.  Drop into 2D code to handle all
		 *  possible intersections (there may be many),
		 *  and any cut/joins, then resume with the previous work.
		 */
		if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
			bu_log("nmg_isect_wireedge3p_face3p: edge lies ON face, using 2D code\n@@ @@ @@ @@ @@ @@ @@ @@ @@ @@ 2D CODE, START\n");
			bu_log("  The status of the face/face intersect line, before 2d:\n");
			nmg_pr_ptbl_vert_list( "l1", is->l1, is->mag1 );
			nmg_pr_ptbl_vert_list( "l2", is->l2, is->mag2 );
		}

		is2 = *is;	/* make private copy */
		is2.vert2d = 0;	/* Don't use previously initialized stuff */

		ret = nmg_isect_edge2p_face2p( &is2, eu1, fu2, fu1 );

		nmg_isect2d_cleanup( &is2 );

		/*
		 *  Because nmg_isect_edge2p_face2p() calls the face cutter,
		 *  vu's in lone lu's that are listed in the current l1 or
		 *  l2 lists may have been destroyed.  It's ret is ours.
		 */

		/* Only do this if list is still OK */
		if (rt_g.NMG_debug & DEBUG_POLYSECT && ret == 0)  {
			bu_log("nmg_isect_wireedge3p_face3p: @@ @@ @@ @@ @@ @@ @@ @@ @@ @@ 2D CODE, END, resume 3d problem.\n");
			bu_log("  The status of the face/face intersect line, so far:\n");
			nmg_pr_ptbl_vert_list( "l1", is->l1, is->mag1 );
			nmg_pr_ptbl_vert_list( "l2", is->l2, is->mag2 );
		}

		/* See if start vertex is now shared */
		if ( (vu2_final=nmg_find_v_in_face(eu1->vu_p->v_p, fu2)) ) {
			if (rt_g.NMG_debug & DEBUG_POLYSECT)
				bu_log("\tEdge start vertex lies on other face (2d topology).\n");
			vu1_final = eu1->vu_p;
			(void)bu_ptbl_ins_unique(is->l1, &vu1_final->l.magic);
			(void)bu_ptbl_ins_unique(is->l2, &vu2_final->l.magic);
		}
                /* XXX HACK HACK -- shut off error checking */
                vu1_final = vu2_final = (struct vertexuse *)NULL;
		goto out;
	}

	/*
	 *  We now know that the the edge does not lie +in+ the other face,
	 *  so it will intersect the face in at most one point.
	 *  Before looking at the results of the geometric calculation,
	 *  check the topology.  If the topology says that starting vertex
	 *  of this edgeuse is on the other face, that is the hit point.
	 *  Enter the two vertexuses of that starting vertex in the list,
	 *  and return.
	 *
	 *  XXX Lee wonders if there might be a benefit to violating the
	 *  XXX "only ask geom question once" rule, and doing a geom
	 *  XXX calculation here before the topology check.
	 */
	if ( (vu2_final=nmg_find_v_in_face(v1a, fu2)) ) {
		vu1_final = eu1->vu_p;
		if (rt_g.NMG_debug & DEBUG_POLYSECT) {
			bu_log("\tEdge start vertex lies on other face (topology).\n\tAdding vu1_final=x%x (v=x%x), vu2_final=x%x (v=x%x)\n",
				vu1_final, vu1_final->v_p,
				vu2_final, vu2_final->v_p);
		}
		(void)bu_ptbl_ins_unique(is->l1, &vu1_final->l.magic);
		(void)bu_ptbl_ins_unique(is->l2, &vu2_final->l.magic);
		goto out;
	}

	if (status < 0)  {
		/*  Ray does not strike plane.
		 *  See if start point lies on plane.
		 */
		dist = VDOT( start_pt, n2 ) - n2[3];
		if( !NEAR_ZERO( dist, is->tol.dist ) )
			goto out;		/* No geometric intersection */

		/* XXX Does this ever happen, now that geom calc is done
		 * XXX above, and there is 2D handling as well?  Lets find out.
		 */
		rt_bomb("nmg_isect_wireedge3p_face3p: Edge start vertex lies on other face (geometry)\n");

		/* Start point lies on plane of other face */
		if (rt_g.NMG_debug & DEBUG_POLYSECT)
			bu_log("\tEdge start vertex lies on other face (geometry)\n");
		dist = VSUB2DOT( v1a->vg_p->coord, start_pt, edge_vect )
				/ edge_len;
	}

	/* The ray defined by the edgeuse intersects the plane 
	 * of the other face.  Check to see if the distance to
         * intersection is between limits of the endpoints of
	 * this edge(use).
	 * The edge exists over values of 0 <= dist <= 1, ie,
	 * over values of 0 <= dist_to_plane <= edge_len.
	 * The tolerance, an absolute distance, can only be compared
	 * to other absolute distances like dist_to_plane & edge_len.
	 * The vertices are "fattened" by +/- is->tol units.
	 */
	dist_to_plane = edge_len * dist;

	if (rt_g.NMG_debug & DEBUG_POLYSECT)
		bu_log("\tedge_len=%g, dist=%g, dist_to_plane=%g\n",
			edge_len, dist, dist_to_plane);

	if ( dist_to_plane < -is->tol.dist )  {
		/* Hit is behind first point */
		if (rt_g.NMG_debug & DEBUG_POLYSECT)
			bu_log("\tplane behind first point\n");
		goto out;
	}

	if ( dist_to_plane > edge_len + is->tol.dist) {
		if (rt_g.NMG_debug & DEBUG_POLYSECT)
			bu_log("\tplane beyond second point\n");
		goto out;
	}

	VJOIN1( hit_pt, start_pt, dist, edge_vect );

	/* Check hit_pt against face/face intersection line */
	{
		fastf_t	ff_dist;
		ff_dist = bn_dist_line3_pt3( is->pt, is->dir, hit_pt );
		if( ff_dist > is->tol.dist )  {
			bu_log("WARNING nmg_isect_wireedge3p_face3p() hit_pt off f/f line %g*tol (%e, tol=%e)\n",
				ff_dist/is->tol.dist,
				ff_dist, is->tol.dist);
			/* XXX now what? */
		}
	}

	/*
	 * If the vertex on the other end of this edgeuse is on the face,
	 * then make a linkage to an existing face vertex (if found),
	 * and give up on this edge, knowing that we'll pick up the
	 * intersection of the next edgeuse with the face later.
	 */
	if ( dist_to_plane < is->tol.dist )  {
		/* First point is on plane of face, by geometry */
		if (rt_g.NMG_debug & DEBUG_POLYSECT)
			bu_log("\tedge starts at plane intersect\n");
		vu1_final = eu1->vu_p;
		vu2_final = nmg_enlist_vu( is, vu1_final, 0, MAX_FASTF );
		goto out;
	}

	if ( dist_to_plane < edge_len - is->tol.dist) {
		/* Intersection is between first and second vertex points.
		 * Insert new vertex at intersection point.
		 */
		vu2_final = nmg_break_3edge_at_plane(hit_pt, fu2, is, eu1);
		if( vu2_final )
			vu1_final = BU_LIST_PNEXT_CIRC(edgeuse,eu1)->vu_p;
		goto out;
	}

#if 0
	if ( dist_to_plane <= edge_len + is->tol.dist)
#endif
	{
		/* Second point is on plane of face, by geometry */
		if (rt_g.NMG_debug & DEBUG_POLYSECT)
			bu_log("\tedge ends at plane intersect\n");

		eunext = BU_LIST_PNEXT_CIRC(edgeuse,eu1);
		NMG_CK_EDGEUSE(eunext);
		if( eunext->vu_p->v_p != v1b )
			rt_bomb("nmg_isect_wireedge3p_face3p: discontinuous eu loop\n");

		vu1_final = eunext->vu_p;
		vu2_final = nmg_enlist_vu( is, vu1_final, 0, MAX_FASTF );
		goto out;
	}

out:
	/* If vu's were added to list, run some quick checks here */
	if( vu1_final && vu2_final )  {
		fastf_t	dist;

		if( vu1_final->v_p != vu2_final->v_p )  rt_bomb("nmg_isect_wireedge3p_face3p() vertex mis-match\n");

		dist = bn_dist_line3_pt3( is->pt, is->dir,
			vu1_final->v_p->vg_p->coord );
		if( dist > 100*is->tol.dist )  {
			bu_log("ERROR nmg_isect_wireedge3p_face3p() vu1=x%x point off line by %g > 100*dist_tol (%g)\n",
				vu1_final, dist, 100*is->tol.dist);
			VPRINT("is->pt|", is->pt);
			VPRINT("is->dir", is->dir);
			VPRINT(" coord ", vu1_final->v_p->vg_p->coord );
			rt_bomb("nmg_isect_wireedge3p_face3p()\n");
		}
		if( dist > is->tol.dist )  {
			bu_log("WARNING nmg_isect_wireedge3p_face3p() vu1=x%x pt off line %g*tol (%e, tol=%e)\n",
				vu1_final, dist/is->tol.dist,
				dist, is->tol.dist);
		}
	}

	if (rt_g.NMG_debug & DEBUG_POLYSECT)
		bu_log("nmg_isect_wireedge3p_face3p(, eu1=x%x, fu2=x%x) ret=%d END\n", eu1, fu2, ret);
	return ret;
}

/*
 *			N M G _ I S E C T _ W I R E L O O P 3 P _ F A C E 3 P
 *
 *	Intersect a single loop with another face.
 *	Note that it may be a wire loop.
 *
 *  Returns -
 *	 0	everything is ok
 *	>0	vu[] list along intersection line needs to be re-done.
 */
static int
nmg_isect_wireloop3p_face3p(struct nmg_inter_struct *bs, struct loopuse *lu, struct faceuse *fu)
{
	struct edgeuse	*eu;
	long		magic1;
	int		discards = 0;

	if (rt_g.NMG_debug & DEBUG_POLYSECT) {
		plane_t		n;
		bu_log("nmg_isect_wireloop3p_face3p(, lu=x%x, fu=x%x) START\n", lu, fu);
		NMG_GET_FU_PLANE( n, fu );
		HPRINT("  fg N", n);
	}

	NMG_CK_INTER_STRUCT(bs);
	NMG_CK_LOOPUSE(lu);
	NMG_CK_LOOP(lu->l_p);
	NMG_CK_LOOP_G(lu->l_p->lg_p);

	NMG_CK_FACEUSE(fu);

	magic1 = BU_LIST_FIRST_MAGIC( &lu->down_hd );
	if (magic1 == NMG_VERTEXUSE_MAGIC) {
		struct vertexuse	*vu = BU_LIST_FIRST(vertexuse,&lu->down_hd);
		/* this is most likely a loop inserted when we split
		 * up fu2 wrt fu1 (we're now splitting fu1 wrt fu2)
		 */
		nmg_isect_3vertex_3face(bs, vu, fu);
		return 0;
	} else if (magic1 != NMG_EDGEUSE_MAGIC) {
		rt_bomb("nmg_isect_wireloop3p_face3p() Unknown type of NMG loopuse\n");
	}

	/*  Process loop consisting of a list of edgeuses.
	 *
	 * By going backwards around the list we avoid
	 * re-processing an edgeuse that was just created
	 * by nmg_isect_wireedge3p_face3p.  This is because the edgeuses
	 * point in the "next" direction, and when one of
	 * them is split, it inserts a new edge AHEAD or
	 * "nextward" of the current edgeuse.
	 */ 
	for( eu = BU_LIST_LAST(edgeuse, &lu->down_hd );
	     BU_LIST_NOT_HEAD(eu,&lu->down_hd);
	     eu = BU_LIST_PLAST(edgeuse,eu) )  {
		NMG_CK_EDGEUSE(eu);

		if (eu->up.magic_p != &lu->l.magic) {
			rt_bomb("nmg_isect_wireloop3p_face3p: edge does not share loop\n");
		}

		discards += nmg_isect_wireedge3p_face3p(bs, eu, fu);

		nmg_ck_lueu(lu, "nmg_isect_wireloop3p_face3p");
	}

	if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
		bu_log("nmg_isect_wireloop3p_face3p(, lu=x%x, fu=x%x) END, discards=%d\n", lu, fu, discards);
	}
	return discards;
}

/*
 *			N M G _ I S E C T _ C O N S T R U C T _ N I C E _ R A Y
 *
 *  Construct a nice ray for is->pt, is->dir
 *  which contains the line of intersection, is->on_eg.
 *
 *  See the comment in nmg_isect_two_generics_faces() for details
 *  on the constraints on this ray, and the algorithm.
 *
 *  XXX Danger?
 *  The ray -vs- RPP check is being done in 3D.
 *  It really ought to be done in 2D, to ensure that
 *  long edge lines on nearly axis-aligned faces don't
 *  get discarded prematurely!
 *  XXX Can't just comment out the code, I think the selection
 *  XXX of is->pt is significant:
 *	1)  All intersections are at positive distances on the ray,
 *	2)  dir cross N will point "left".
 *
 *  Returns -
 *	0	OK
 *	1	ray misses fu2 bounding box
 */
int
nmg_isect_construct_nice_ray(struct nmg_inter_struct *is, struct faceuse *fu2)
{
	struct xray		line;
	vect_t			invdir;

	NMG_CK_INTER_STRUCT(is);
	NMG_CK_FACEUSE(fu2);

	VMOVE( line.r_pt, is->on_eg->e_pt );			/* 3D line */
	VMOVE( line.r_dir, is->on_eg->e_dir );
	VUNITIZE( line.r_dir );
	VINVDIR( invdir, line.r_dir );

	/* nmg_loop_g() makes sure there are no 0-thickness faces */
	if( !rt_in_rpp( &line, invdir, fu2->f_p->min_pt, fu2->f_p->max_pt ) )  {
		/* The edge ray missed the face RPP, nothing to do. */
		if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
			VPRINT("r_pt ", line.r_pt);
			VPRINT("r_dir", line.r_dir);
			VPRINT("fu2 min", fu2->f_p->min_pt);
			VPRINT("fu2 max", fu2->f_p->max_pt);
			bu_log("r_min=%g, r_max=%g\n", line.r_min, line.r_max);
			bu_log("nmg_isect_construct_nice_ray() edge ray missed face bounding RPP, ret=1\n");
		}
		return 1;	/* Missed */
	}
	if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
		VPRINT("fu2 min", fu2->f_p->min_pt);
		VPRINT("fu2 max", fu2->f_p->max_pt);
		bu_log("r_min=%g, r_max=%g\n", line.r_min, line.r_max);
	}
	/* Start point will lie at min or max dist, outside of face RPP */
	VJOIN1( is->pt, line.r_pt, line.r_min, line.r_dir );
	if( line.r_min > line.r_max )  {
		/* Direction is heading the wrong way, flip it */
		VREVERSE( is->dir, line.r_dir );
		if (rt_g.NMG_debug & DEBUG_POLYSECT)
			bu_log("flipping dir\n");
	} else {
		VMOVE( is->dir, line.r_dir );
	}
	if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
		VPRINT("r_pt ", line.r_pt);
		VPRINT("r_dir", line.r_dir);
		VPRINT("->pt ", is->pt);
		VPRINT("->dir", is->dir);
		bu_log("nmg_isect_construct_nice_ray() ret=0\n");
	}
	return 0;
}

/*
 *			N M G _ I S E C T _ E D G E 2 P _ F A C E 2 P
 *
 *  Given one (2D) edge (eu1) lying in the plane of another face (fu2),
 *  intersect with all the other edges of that face.
 *  The line of intersection is defined by the geometry of this edgeuse.
 *  Therefore, all edgeuses in fu1 which share edge geometry are,
 *  by definition, ON the intersection line.  We process all edgeuses
 *  which share geometry at once, followed by cutjoin operation.
 *  It is up to the caller not to recall for the other edgeuses of this edge_g.
 *
 *  XXX eu1 may be a wire edge, in which case there is no fu1 face!
 *
 *  Note that this routine completely conducts the
 *  intersection operation, so that edges may come and go, loops
 *  may join or split, each time it is called.
 *  This imposes special requirements on handling the march through
 *  the linked lists in this routine.
 *
 *  This also means that much of argument "is" is changed each call.
 *
 *  It further means that vu's in lone lu's found along the edge
 *  "intersection line" here may get merged in, causing the lu to
 *  be killed, and the vu, which is listed in the 3D (calling)
 *  routine's l1/l2 list, is now invalid.
 *
 *  NOTE-
 *  Since this routine calls the face cutter, *all* points of intersection
 *  along the line, for *both* faces, need to be found.
 *  Otherwise, the parity requirements of the face cutter will be violated.
 *  This means that eu1 needs to be intersected with all of fu1 also,
 *  including itself (so that the vu's at the ends of eu1 are listed).
 *
 *  Returns -
 *	0	Topology is completely shared (or no sharing).  l1/l2 valid.
 *	>0	Caller needs to invalidate his l1/l2 list.
 */
static int
nmg_isect_edge2p_face2p(struct nmg_inter_struct *is, struct edgeuse *eu1, struct faceuse *fu2, struct faceuse *fu1)
                       	    
              		     		/* edge to be intersected w/fu2 */
              		     		/* face to be intersected w/eu1 */
              		     		/* fu that eu1 is from */
{
	struct bu_ptbl vert_list1, vert_list2;
	fastf_t		*mag1,	    *mag2;
	struct vertexuse	*vu1;
	struct vertexuse	*vu2;
	struct edgeuse		*fu2_eu;	/* use of edge in fu2 */
	int			total_splits = 0;
	int			ret = 0;
	struct bu_ptbl		eu1_list;
	struct bu_ptbl		eu2_list;

	NMG_CK_INTER_STRUCT(is);
	NMG_CK_EDGEUSE(eu1);
	NMG_CK_FACEUSE(fu2);
	if(fu1) NMG_CK_FACEUSE(fu1);	 /* fu1 may be null */

	if (rt_g.NMG_debug & DEBUG_POLYSECT)
		bu_log("nmg_isect_edge2p_face2p(eu1=x%x, fu2=x%x, fu1=x%x) START\n", eu1, fu2, fu1);

	if( fu2->orientation != OT_SAME )  rt_bomb("nmg_isect_edge2p_face2p() fu2 not OT_SAME\n");
	if( fu1 && fu1->orientation != OT_SAME )  rt_bomb("nmg_isect_edge2p_face2p() fu1 not OT_SAME\n");

	mag1 = (fastf_t *)NULL;
	mag2 = (fastf_t *)NULL;

	/*  See if an edge exists in other face that connects these 2 verts */
	fu2_eu = nmg_find_eu_in_face( eu1->vu_p->v_p, eu1->eumate_p->vu_p->v_p,
	    fu2, (const struct edgeuse *)NULL, 0 );
	if( fu2_eu != (struct edgeuse *)NULL )  {
		/* There is an edge in other face that joins these 2 verts. */
		NMG_CK_EDGEUSE(fu2_eu);
		if( fu2_eu->e_p != eu1->e_p )  {
			/* Not the same edge, fuse! */
			bu_log("nmg_isect_edge2p_face2p() fusing unshared shared edge\n");
			nmg_radial_join_eu( eu1, fu2_eu, &is->tol );
		}
		/* Topology is completely shared */
		if (rt_g.NMG_debug & DEBUG_POLYSECT)
			bu_log("nmg_isect_edge2p_face2p() topology is shared\n");
		ret = 0;
		goto do_ret;
	}

	(void)bu_ptbl(&vert_list1, BU_PTBL_INIT,(long *)NULL);
	(void)bu_ptbl(&vert_list2, BU_PTBL_INIT,(long *)NULL);
	(void)bu_ptbl(&eu1_list, BU_PTBL_INIT,(long *)NULL);
	(void)bu_ptbl(&eu2_list, BU_PTBL_INIT,(long *)NULL);

	NMG_CK_EDGE_G_LSEG(eu1->g.lseg_p);
	is->on_eg = eu1->g.lseg_p;
    	is->l1 = &vert_list1;
    	is->l2 = &vert_list2;
	is->s1 = nmg_find_s_of_eu(eu1);		/* may be wire edge */
	is->s2 = fu2->s_p;
	is->fu1 = fu1;
	is->fu2 = fu2;

    	if ( fu1 && rt_g.NMG_debug & (DEBUG_POLYSECT|DEBUG_FCUT|DEBUG_MESH)
    	    && rt_g.NMG_debug & DEBUG_PLOTEM) {
    	    	nmg_pl_2fu( "Iface%d.pl", 0, fu2, fu1, 0 );
    	}

	vu1 = eu1->vu_p;
	vu2 = BU_LIST_PNEXT_CIRC( edgeuse, eu1 )->vu_p;
	if( vu1->v_p == vu2->v_p )  {
		bu_log("nmg_isect_edge2p_face2p(eu1=x%x) skipping 0-len edge (topology)\n", eu1);
		/* Call nmg_k0eu() ? */
		goto out;
	}

	/*
	 *  Construct the ray which contains the line of intersection,
	 *  i.e. the line that contains the edge "eu1" (is->on_eg).
	 */
	if( nmg_isect_construct_nice_ray( is, fu2 ) )  goto out;

	if( rt_g.NMG_debug & DEBUG_VERIFY )  {
		nmg_fu_touchingloops(fu2);
		if(fu1)nmg_fu_touchingloops(fu1);
		nmg_region_v_unique( is->s1->r_p, &is->tol );
		nmg_region_v_unique( is->s2->r_p, &is->tol );
	}

	/* Build list of all edgeuses in eu1/fu1 and fu2 */
	if( fu1 )  {
		nmg_edgeuse_tabulate( &eu1_list, &fu1->l.magic );
	} else {
		nmg_edgeuse_tabulate( &eu1_list, &eu1->l.magic );
	}
	nmg_edgeuse_tabulate( &eu2_list, &fu2->l.magic );

	is->mag_len = 2 * (BU_PTBL_END( &eu1_list ) + BU_PTBL_END( &eu2_list ) );
	mag1 = (fastf_t *)bu_calloc( is->mag_len, sizeof( fastf_t ), "mag1" );
	mag2 = (fastf_t *)bu_calloc( is->mag_len, sizeof( fastf_t ), "mag2" );

	is->mag1 = mag1;
	is->mag2 = mag2;

	/* Run infinite line containing eu1 through fu2 */
	total_splits = 1;
	nmg_isect_line2_face2pNEW( is, fu2, fu1, &eu2_list, &eu1_list );

	/* If eu1 is a wire, there is no fu1 to run line through. */
	if( fu1 )  {
		/* We are intersecting with ourself */
		nmg_isect_line2_face2pNEW( is, fu1, fu2, &eu1_list, &eu2_list );
	}
	if (rt_g.NMG_debug & DEBUG_POLYSECT )
		bu_log("nmg_isect_edge2p_face2p(): total_splits=%d\n", total_splits);

	if( total_splits <= 0 )  goto out;

    	if (rt_g.NMG_debug & DEBUG_FCUT) {
	    	bu_log("nmg_isect_edge2p_face2p(eu1=x%x, fu2=x%x) vert_lists C:\n", eu1, fu2 );
    		nmg_pr_ptbl_vert_list( "vert_list1", &vert_list1, mag1 );
    		nmg_pr_ptbl_vert_list( "vert_list2", &vert_list2, mag2 );
    	}
#if 0
	nmg_purge_unwanted_intersection_points(&vert_list1, mag1, fu2, &is->tol);
	if(fu1)nmg_purge_unwanted_intersection_points(&vert_list2, mag2, fu1, &is->tol);
#endif
    	if (rt_g.NMG_debug & DEBUG_FCUT) {
	    	bu_log("nmg_isect_edge2p_face2p(eu1=x%x, fu2=x%x) vert_lists D:\n", eu1, fu2 );
    		nmg_pr_ptbl_vert_list( "vert_list1", &vert_list1, mag1 );
    		nmg_pr_ptbl_vert_list( "vert_list2", &vert_list2, mag2 );
    	}

	if (vert_list1.end == 0 && vert_list2.end == 0) goto out;

	/* Invoke the face cutter to snip and join loops along isect line */
	is->on_eg = nmg_face_cutjoin(&vert_list1, &vert_list2, mag1, mag2, fu1, fu2, is->pt, is->dir, is->on_eg, &is->tol);
	ret = 1;		/* face cutter was called. */

out:
	(void)bu_ptbl_free(&vert_list1);
	(void)bu_ptbl_free(&vert_list2);
	(void)bu_ptbl_free(&eu1_list);
	(void)bu_ptbl_free(&eu2_list);
	if( mag1 )
		bu_free( (char *)mag1, "nmg_isect_edge2p_face2p: mag1" );
	if( mag2 )
		bu_free( (char *)mag2, "nmg_isect_edge2p_face2p: mag2" );

do_ret:
	if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
		bu_log("nmg_isect_edge2p_face2p(eu1=x%x, fu2=x%x) ret=%d\n",
			eu1, fu2, ret);
	}
	return ret;
}

/*
 */
void
nmg_enlist_one_vu(struct nmg_inter_struct *is, const struct vertexuse *vu, fastf_t dist)
                       	    
                      	    
       			     			/* distance along intersect ray for this vu */
{
	struct shell		*sv;		/* shell of vu */

	NMG_CK_INTER_STRUCT(is);
	NMG_CK_VERTEXUSE(vu);

	if( is->mag_len <= BU_PTBL_END( is->l1 ) || is->mag_len <= BU_PTBL_END( is->l2 ) )
		bu_log( "Array for distances to vertexuses is too small (%d)\n" , is->mag_len );

	sv = nmg_find_s_of_vu( vu );

	/* First step:  add vu to corresponding list */
	if( sv == is->s1 )  {
		bu_ptbl_ins_unique( is->l1, (long *)&vu->l.magic );
		if( is->mag_len <= BU_PTBL_END( is->l1 ) )
		{
			if( is->mag_len )
			{
				is->mag_len *= 2;
				is->mag1 = (fastf_t *)rt_realloc( (char *)is->mag1, is->mag_len*sizeof( fastf_t),
					"is->mag1" );
				is->mag2 = (fastf_t *)rt_realloc( (char *)is->mag2, is->mag_len*sizeof( fastf_t),
					"is->mag2" );
			}
			else
			{
				is->mag_len = 2*(BU_PTBL_END( is->l1 ) + BU_PTBL_END( is->l2 ));
				is->mag1 = (fastf_t *)bu_calloc( is->mag_len, sizeof( fastf_t ), "is->mag1" );
				is->mag2 = (fastf_t *)bu_calloc( is->mag_len, sizeof( fastf_t ), "is->mag2" );
			}
			
		}
		if( dist < MAX_FASTF )
			is->mag1[bu_ptbl_locate( is->l1, (long *)&vu->l.magic )] = dist;
	} else if( sv == is->s2 )  {
		bu_ptbl_ins_unique( is->l2, (long *)&vu->l.magic );
		if( is->mag_len <= BU_PTBL_END( is->l2 ) )
		{
			if( is->mag_len )
			{
				is->mag_len *= 2;
				is->mag1 = (fastf_t *)rt_realloc( (char *)is->mag1, is->mag_len*sizeof( fastf_t),
					"is->mag1" );
				is->mag2 = (fastf_t *)rt_realloc( (char *)is->mag2, is->mag_len*sizeof( fastf_t),
					"is->mag2" );
			}
			else
			{
				is->mag_len = 2*(BU_PTBL_END( is->l1 ) + BU_PTBL_END( is->l2 ));
				is->mag1 = (fastf_t *)bu_calloc( is->mag_len, sizeof( fastf_t ), "is->mag1" );
				is->mag2 = (fastf_t *)bu_calloc( is->mag_len, sizeof( fastf_t ), "is->mag2" );
			}
			
		}
		if( dist < MAX_FASTF )
			is->mag2[bu_ptbl_locate( is->l2, (long *)&vu->l.magic )] = dist;
	} else {
		bu_log("nmg_enlist_one_vu(vu=x%x) sv=x%x, s1=x%x, s2=x%x\n",
			vu, sv, is->s1, is->s2 );
		rt_bomb("nmg_enlist_one_vu: vu is not in s1 or s2\n");
	}

	if( rt_g.NMG_debug & DEBUG_POLYSECT )  {
		bu_log("nmg_enlist_one_vu(vu=x%x) v=x%x, dist=%g (%s)\n",
			vu, vu->v_p, dist,
			(sv == is->s1) ? "shell 1" : "shell 2" );
	}

	/* Some (expensive) centralized sanity checking */
	if( (rt_g.NMG_debug & DEBUG_VERIFY) && is->fu1 && is->fu2 )  {
		nmg_ck_v_in_2fus(vu->v_p, is->fu1, is->fu2, &(is->tol));
	}
}

static void
nmg_coplanar_face_vertex_fuse(struct faceuse *fu1, struct faceuse *fu2, struct bn_tol *tol)
{
	struct bu_ptbl fu1_verts;
	struct bu_ptbl fu2_verts;
	int i, j;
	vect_t norm;

	NMG_CK_FACEUSE( fu1 );
	NMG_CK_FACEUSE( fu2 );
	BN_CK_TOL( tol );

	NMG_GET_FU_NORMAL( norm, fu1 );

	nmg_vertex_tabulate( &fu1_verts, &fu1->l.magic );
	nmg_vertex_tabulate( &fu2_verts, &fu2->l.magic );

	for( i=0 ; i<BU_PTBL_END( &fu1_verts ) ; i++ )
	{
		struct vertex *v1;

		v1 = (struct vertex *)BU_PTBL_GET( &fu1_verts, i );

		for( j=0 ; j<BU_PTBL_END( &fu2_verts ) ; j++ )
		{
			struct vertex *v2;
			vect_t diff;
			vect_t diff_unit;
			fastf_t len_sq, inv_len;
			fastf_t dot;

			v2 = (struct vertex *)BU_PTBL_GET( &fu2_verts, j );

			if( v1 == v2 )
				continue;

			VSUB2( diff, v1->vg_p->coord, v2->vg_p->coord );
			len_sq = MAGSQ( diff );
			if( len_sq > 4.0*tol->dist_sq )
				continue;

			inv_len = 1.0 / sqrt( len_sq );

			VSCALE( diff_unit, diff, inv_len );

			dot = VDOT( norm, diff_unit );
			if( BN_VECT_ARE_PARALLEL( dot, tol ) )
			{
				/* fuse these two vertices */
				nmg_jv( v2, v1 );
				break;
			}
		}
	}
}

static void
nmg_isect_two_face2p_jra(struct nmg_inter_struct *is, struct faceuse *fu1, struct faceuse *fu2)
{
	struct model *m;
	struct loopuse *lu;
	struct bu_ptbl eu1_list;
	struct bu_ptbl eu2_list;
	struct bu_ptbl v_list;
	struct bu_ptbl vert_list1,vert_list2;
	fastf_t *mag1,*mag2;
	int i,j;

	NMG_CK_FACEUSE( fu1 );
	NMG_CK_FACEUSE( fu2 );
	NMG_CK_INTER_STRUCT(is);

	if (rt_g.NMG_debug & DEBUG_POLYSECT)
		bu_log( "nmg_isect_two)face2p_jra: fu1=x%x, fu2=x%x\n" );

	nmg_coplanar_face_vertex_fuse( fu1, fu2, &is->tol );

	m = nmg_find_model( &fu1->l.magic );
	NMG_CK_MODEL( m );

	nmg_edgeuse_tabulate( &eu1_list, &fu1->l.magic );
	nmg_edgeuse_tabulate( &eu2_list, &fu2->l.magic );

	is->mag_len = 2 * (BU_PTBL_END( &eu1_list ) + BU_PTBL_END( &eu2_list ) );
	mag1 = (fastf_t *)bu_calloc( is->mag_len, sizeof( fastf_t ), "mag1" );
	mag2 = (fastf_t *)bu_calloc( is->mag_len, sizeof( fastf_t ), "mag2" );

	for( i=0 ; i<is->mag_len ; i++ )
	{
		mag1[i] = MAX_FASTF;
		mag2[i] = MAX_FASTF;
	}


	is->s1 = fu1->s_p;
	is->s2 = fu2->s_p;
	is->fu1 = fu1;
	is->fu2 = fu2;
	is->mag1 = mag1;
	is->mag2 = mag2;

	/* First split all edgeuses that intersect */
	for( i=0 ; i<BU_PTBL_END( &eu1_list ) ; i++ )
	{
		struct edgeuse *eu1;
		struct vertex_g *vg1a,*vg1b;
		vect_t vt1_3d;

		eu1 = (struct edgeuse *)BU_PTBL_GET( &eu1_list, i );
		NMG_CK_EDGEUSE( eu1 );

		vg1a = eu1->vu_p->v_p->vg_p;
		NMG_CK_VERTEX_G( vg1a );
		vg1b = eu1->eumate_p->vu_p->v_p->vg_p;
		NMG_CK_VERTEX_G( vg1b );

		VSUB2( vt1_3d, vg1b->coord, vg1a->coord );
#if 0
		nmg_get_2d_vertex( pt1a, eu1->vu_p->v_p, is, (long *)fu1 );
		nmg_get_2d_vertex( pt1b, eu1->eumate_p->vu_p->v_p, is, (long *)fu1 );
		VSUB2( vt1, pt1b, pt1a );
#endif
		for( j=0 ; j<BU_PTBL_END( &eu2_list ) ; j++ )
		{
			struct edgeuse *eu2;
			struct vertex_g *vg2a, *vg2b;
			int code;
			vect_t vt2_3d;
			fastf_t dist[2];
			point_t hit_pt;
			int hit_no;
			int hit_count;

			eu2 = (struct edgeuse *)BU_PTBL_GET( &eu2_list, j );
			NMG_CK_EDGEUSE( eu2 );
#if 0
			nmg_get_2d_vertex( pt2a, eu2->vu_p->v_p, is, (long *)fu1 );
			nmg_get_2d_vertex( pt2b, eu2->eumate_p->vu_p->v_p, is, (long *)fu1 );
			VSUB2( vt2, pt2b, pt2a );
#endif
			vg2a = eu2->vu_p->v_p->vg_p;
			vg2b = eu2->eumate_p->vu_p->v_p->vg_p;
			VSUB2( vt2_3d, vg2b->coord, vg2a->coord );
#if 0
			code = bn_isect_lseg2_lseg2( dist, pt1a, vt1,
				pt2a, vt2, &is->tol );
#else
			code = bn_isect_lseg3_lseg3( dist, vg1a->coord, vt1_3d,
				vg2a->coord, vt2_3d, &is->tol );
#endif

			if( code < 0 )
				continue;

			if( code == 0 )
			{
				hit_count = 2;
				if( dist[0] < dist[1] )
				{
					fastf_t tmp;

					tmp = dist[0];
					dist[0] = dist[1];
					dist[1] = tmp;
				}
			}
			else
				hit_count = 1;

			for( hit_no=0 ; hit_no < hit_count ; hit_no++ )
			{
				struct edgeuse *new_eu;
				struct vertex *hitv;
				struct vertexuse *hit_vu = NULL;

				if( dist[hit_no] < 0.0 || dist[hit_no] > 1.0 )
					continue;

				hitv = (struct vertex *)NULL;

				if( dist[hit_no] == 0.0 )
				{
					hit_vu = eu1->vu_p;
					hitv = hit_vu->v_p;
					VMOVE( hit_pt, hitv->vg_p->coord );
				}
				else if( dist[hit_no] == 1.0 )
				{
					hit_vu = eu1->eumate_p->vu_p;
					hitv = hit_vu->v_p;
					VMOVE( hit_pt, hitv->vg_p->coord );
				}
				else
					VJOIN1( hit_pt, vg1a->coord , dist[hit_no], vt1_3d )

				if (rt_g.NMG_debug & DEBUG_POLYSECT)
					bu_log( "eus x%x and x%x intersect #%d at (%f %f %f)\n",
						eu1, eu2, hit_no, V3ARGS( hit_pt ) );

				if( !hit_vu )
					hit_vu = nmg_find_pt_in_face( fu2, hit_pt, &is->tol );

				if( !hit_vu )
					hitv = nmg_find_pt_in_model( nmg_find_model( &fu1->l.magic ), hit_pt, &is->tol );

				if (rt_g.NMG_debug & DEBUG_POLYSECT && hitv)
					bu_log( "Found vertex (x%x) at hit_pt\n", hitv );

				if( hitv != eu1->vu_p->v_p && hitv != eu1->eumate_p->vu_p->v_p )
				{
					struct edgeuse *next_eu, *prev_eu;

					next_eu = BU_LIST_PNEXT_CIRC( edgeuse, &eu1->l );
					prev_eu = BU_LIST_PPREV_CIRC( edgeuse, &eu1->l );

					if( hitv != prev_eu->vu_p->v_p && hitv != next_eu->eumate_p->vu_p->v_p )
					{
						if (rt_g.NMG_debug & DEBUG_POLYSECT)
							bu_log( "Splitting eu1 x%x\n", eu1 );
						new_eu = nmg_esplit( hitv, eu1, 1 );
						hitv = new_eu->vu_p->v_p;
						if( !hitv->vg_p )
							nmg_vertex_gv( hitv, hit_pt );
						vg1b = eu1->eumate_p->vu_p->v_p->vg_p;
						VSUB2( vt1_3d, vg1b->coord, vg1a->coord );
#if 0
						bu_ptbl_ins( &eu1_list, (long *)new_eu );
						nmg_get_2d_vertex( pt1b, eu1->eumate_p->vu_p->v_p, is, (long *)fu1 );
						VSUB2( vt1, pt1b, pt1a );
#endif
					}
				}
				if( code == 1 && hitv != eu2->vu_p->v_p && hitv != eu2->eumate_p->vu_p->v_p )
				{
					struct edgeuse *next_eu, *prev_eu;

					next_eu = BU_LIST_PNEXT_CIRC( edgeuse, &eu2->l );
					prev_eu = BU_LIST_PPREV_CIRC( edgeuse, &eu2->l );

					if( hitv != prev_eu->vu_p->v_p && hitv != next_eu->eumate_p->vu_p->v_p )
					{
						if (rt_g.NMG_debug & DEBUG_POLYSECT)
						{
							vect_t tmp1, tmp2;
							VSUB2( tmp1, hit_pt, eu2->vu_p->v_p->vg_p->coord )
							VSUB2( tmp2, hit_pt, eu2->eumate_p->vu_p->v_p->vg_p->coord )
							bu_log( "Splitting eu2 x%x\n",  eu2 );
							bu_log( "Distance to hit_pt = %g from vu1, %g from vu2\n",
								MAGNITUDE( tmp1 ), MAGNITUDE( tmp2 ) );
						}
						new_eu = nmg_esplit( hitv, eu2, 1 );
						hitv = new_eu->vu_p->v_p;
						if( !hitv->vg_p )
							nmg_vertex_gv( hitv, hit_pt );
						bu_ptbl_ins( &eu2_list, (long *)new_eu );
					}
				}

				if( hitv )
					(void)nmg_break_all_es_on_v( &m->magic, hitv, &is->tol );
			}
		}
	}

	bu_ptbl_free( &eu1_list);
	bu_ptbl_free( &eu2_list);

	/* Make sure every vertex in fu1 has dual in fu2
	 * (if they overlap)
	 */
	nmg_vertex_tabulate( &v_list, &fu1->l.magic );

	for( i=0 ; i<BU_PTBL_END( &v_list ) ; i++ )
	{
		struct vertex *v;
		int class;

		v = (struct vertex *)BU_PTBL_GET( &v_list, i );
		NMG_CK_VERTEX( v );

		if( nmg_find_v_in_face( v, fu2 ) )
			continue;

		/* Check if this vertex is within other FU */
		class = nmg_class_pt_fu_except( v->vg_p->coord, fu2, NULL, NULL, NULL,
			(char *)NULL, 0, 0, &is->tol );

		if( class == NMG_CLASS_AinB )
		{
			if (rt_g.NMG_debug & DEBUG_POLYSECT)
				bu_log( "Making dualvu of vertex x%x in fu2 x%x\n", v, fu2 );
			(void)nmg_make_dualvu( v, fu2, &is->tol );
		}
	}
	bu_ptbl_reset( &v_list);

	/* same for fu2  */
	nmg_vertex_tabulate( &v_list, &fu2->l.magic );

	for( i=0 ; i<BU_PTBL_END( &v_list ) ; i++ )
	{
		struct vertex *v;
		int class;

		v = (struct vertex *)BU_PTBL_GET( &v_list, i );
		NMG_CK_VERTEX( v );

		if( nmg_find_v_in_face( v, fu1 ) )
			continue;

		/* Check if this vertex is within other FU */
		class = nmg_class_pt_fu_except( v->vg_p->coord, fu1, NULL, NULL, NULL,
			(char *)NULL, 0, 0, &is->tol );

		if( class == NMG_CLASS_AinB )
		{
			if (rt_g.NMG_debug & DEBUG_POLYSECT)
				bu_log( "Making dualvu of vertex x%x in fu1 x%x\n", v, fu1 );
			(void)nmg_make_dualvu( v, fu1, &is->tol );
		}
	}

	bu_ptbl_free( &v_list);

	bu_ptbl_init( &vert_list1, 64, " &vert_list1");
	bu_ptbl_init( &vert_list2, 64, " &vert_list2");
    	is->l1 = &vert_list1;
    	is->l2 = &vert_list2;

	for( BU_LIST_FOR( lu, loopuse, &fu1->lu_hd ) )
	{
		struct edgeuse *eu;

		NMG_CK_LOOPUSE( lu );

		if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
			continue;

		for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
		{
			struct vertexuse *vu;
			struct vertex *v1,*v2;

			NMG_CK_EDGEUSE( eu );

			v1 = eu->vu_p->v_p;
			NMG_CK_VERTEX( v1 );
			v2 = eu->eumate_p->vu_p->v_p;
			NMG_CK_VERTEX( v2 );

			if( !nmg_find_v_in_face( v1, fu2 ) ||
				!nmg_find_v_in_face( v2, fu2 ) )
				continue;

			if (rt_g.NMG_debug & DEBUG_POLYSECT)
				bu_log( "Making EU x%x an intersect line for face cutting\n", eu );

			for( BU_LIST_FOR( vu, vertexuse, &v1->vu_hd ) )
			{
				struct faceuse *fu;

				fu = nmg_find_fu_of_vu( vu );

				if( fu == fu2 )
					nmg_enlist_one_vu( is, vu, 0.0 );
			}

			for( BU_LIST_FOR( vu, vertexuse, &v2->vu_hd ) )
			{
				struct faceuse *fu;

				fu = nmg_find_fu_of_vu( vu );

				if( fu == fu2 )
					nmg_enlist_one_vu( is, vu, 1.0 );
			}

			/* Now do face cutting */
			if (rt_g.NMG_debug & DEBUG_POLYSECT)
				bu_log( "Calling face cutter for fu2 x%x\n", fu2 );
			nmg_fcut_face_2d( is->l2, is->mag2, fu2, fu1, &is->tol );

			bu_ptbl_reset( is->l1);
			bu_ptbl_reset( is->l2);
		}
	}

	for( BU_LIST_FOR( lu, loopuse, &fu2->lu_hd ) )
	{
		struct edgeuse *eu;

		NMG_CK_LOOPUSE( lu );

		if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
			continue;

		for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
		{
			struct vertexuse *vu;
			struct vertex *v1,*v2;

			NMG_CK_EDGEUSE( eu );

			v1 = eu->vu_p->v_p;
			NMG_CK_VERTEX( v1 );
			v2 = eu->eumate_p->vu_p->v_p;
			NMG_CK_VERTEX( v2 );

			if( !nmg_find_v_in_face( v1, fu1 ) ||
				!nmg_find_v_in_face( v2, fu1 ) )
				continue;

			if (rt_g.NMG_debug & DEBUG_POLYSECT)
				bu_log( "Making EU x%x an intersect line for face cutting\n", eu );

			for( BU_LIST_FOR( vu, vertexuse, &v1->vu_hd ) )
			{
				struct faceuse *fu;

				fu = nmg_find_fu_of_vu( vu );

				if( fu == fu1 )
					nmg_enlist_one_vu( is, vu, 0.0 );
			}

			for( BU_LIST_FOR( vu, vertexuse, &v2->vu_hd ) )
			{
				struct faceuse *fu;

				fu = nmg_find_fu_of_vu( vu );

				if( fu == fu1 )
					nmg_enlist_one_vu( is, vu, 1.0 );
			}

			/* Now do face cutting */
			if (rt_g.NMG_debug & DEBUG_POLYSECT)
				bu_log( "Calling face cutter for fu1 x%x\n", fu1 );
			nmg_fcut_face_2d( is->l1, is->mag1, fu1, fu2, &is->tol );

			bu_ptbl_reset( is->l1);
			bu_ptbl_reset( is->l2);
		}
	}
	if( mag1 )
		bu_free( (char *)mag1, "mag1" );
	if( mag2 )
		bu_free( (char *)mag2, "mag2" );

	bu_ptbl_free( is->l1);
	bu_ptbl_free( is->l2);
}

/*
 *			N M G _ I S E C T _ T W O _ F A C E 2 P
 *
 *  Manage the mutual intersection of two 3-D coplanar planar faces.
 *
 *  The big challenge in this routine comes from the fact that
 *  loopuses can come and go as the facecutter operates.
 *  Thus, after a call to nmg_isect_edge2p_face2p(), the current
 *  loopuse structure may be invalid.
 *  The intersection operations being performed here never delete
 *  edgeuses, only split existing ones and add new ones.
 *  It might reduce complexity to unbreak edges in here, but that
 *  would violate the assumption of edgeuses not vanishing.
 *
 *  Called by -
 *	nmg_isect_two_generic_faces()
 *
 *  Call tree -
 *	nmg_isect_vert2p_face2p()
 *	nmg_isect_edge2p_face2p()
 *		nmg_isect_vert2p_face2p()
 *		nmg_isect_line2_face2p()
 *		nmg_purge_unwanted_intersection_points()
 *		nmg_face_cutjoin()
 */
#if 0
static void
nmg_isect_two_face2p( is, fu1, fu2 )
struct nmg_inter_struct	*is;
struct faceuse		*fu1, *fu2;
{
	struct model		*m;
	struct loopuse		*lu;
	struct edgeuse		*eu;
	struct vertexuse	*vu;
	unsigned char		*tags;
	int			tagsize;

	NMG_CK_INTER_STRUCT(is);
	NMG_CK_FACEUSE(fu1);
	NMG_CK_FACEUSE(fu2);
	m = fu1->s_p->r_p->m_p;
	NMG_CK_MODEL(m);

	is->l1 = 0;
	is->l2 = 0;
	is->fu1 = fu1;
	is->fu2 = fu2;

	if (rt_g.NMG_debug & DEBUG_POLYSECT)
		bu_log("nmg_isect_two_face2p(fu1=x%x, fu2=x%x) START\n", fu1, fu2);

	/* Allocate map of edgegeom's visited */
	tagsize = 4 * m->maxindex+1;
	tags = (unsigned char *)bu_calloc( tagsize, 1, "nmg_isect_two_face2p() tags[]" );

/* XXX A vastly better strategy would be to build a list of vu's and eu's,
 * XXX and then intersect them with the other face.
 * XXX loopuses can come and go as loops get cutjoin'ed, but at this
 * XXX stage edgeuses are created, but never deleted.
 * XXX This way, the process should converge in 2 interations, rather than N.
 */

	/* For every edge in f1, intersect with f2, incl. cutjoin */
	bzero( (char *)tags, tagsize );
f1_again:
	if( rt_g.NMG_debug & DEBUG_VERIFY )  {
		nmg_fu_touchingloops(fu1);
		nmg_fu_touchingloops(fu2);
		nmg_region_v_unique( fu1->s_p->r_p, &is->tol );
		nmg_region_v_unique( fu2->s_p->r_p, &is->tol );
	}
	for( BU_LIST_FOR( lu, loopuse, &fu1->lu_hd ) )  {
		NMG_CK_LOOPUSE(lu);
		if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) == NMG_VERTEXUSE_MAGIC )  {
			is->l1 = 0;
			is->l2 = 0;
			vu = BU_LIST_FIRST( vertexuse, &lu->down_hd );
			if( !NMG_INDEX_FIRST_TIME(tags, vu->v_p) )  continue;
			nmg_isect_vert2p_face2p( is, vu, fu2 );
			continue;
		}
		for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
			struct edge_g_lseg	*eg;

			NMG_CK_EDGEUSE(eu);
			eg = eu->g.lseg_p;
			/* If this eu's eg has been seen before, skip on. */
			if( eg && !NMG_INDEX_FIRST_TIME(tags, eg) )  continue;

			if( nmg_isect_edge2p_face2p( is, eu, fu2, fu1 ) )  {
				/* Face topologies have changed */
				/* This loop might have been joined into another loopuse! */
				/* XXX Might want to unbreak edges? */
				goto f1_again;
			}
		}
	}

	/* Zap 2d cache, we are switching faces now */
	nmg_isect2d_cleanup(is);

	/* For every edge in f2, intersect with f1, incl. cutjoin */
	bzero( (char *)tags, tagsize );
f2_again:
	if( rt_g.NMG_debug & DEBUG_VERIFY )  {
		nmg_fu_touchingloops(fu1);
		nmg_fu_touchingloops(fu2);
		nmg_region_v_unique( fu1->s_p->r_p, &is->tol );
		nmg_region_v_unique( fu2->s_p->r_p, &is->tol );
	}
	for( BU_LIST_FOR( lu, loopuse, &fu2->lu_hd ) )  {
		NMG_CK_LOOPUSE(lu);
		if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) == NMG_VERTEXUSE_MAGIC )  {
			is->l1 = 0;
			is->l2 = 0;
			vu = BU_LIST_FIRST( vertexuse, &lu->down_hd );
			if( !NMG_INDEX_FIRST_TIME(tags, vu->v_p) )  continue;
			nmg_isect_vert2p_face2p( is, vu, fu1 );
			continue;
		}
		for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
			struct edge_g_lseg	*eg;

			NMG_CK_EDGEUSE(eu);
			eg = eu->g.lseg_p;
			/* If this eu's eg has been seen before, skip on. */
			if( eg && !NMG_INDEX_FIRST_TIME(tags, eg) )  continue;

			if( nmg_isect_edge2p_face2p( is, eu, fu1, fu2 ) )  {
				/* Face topologies have changed */
				goto f2_again;
			}
		}
	}
	if( rt_g.NMG_debug & DEBUG_VERIFY )  {
		nmg_fu_touchingloops(fu1);
		nmg_fu_touchingloops(fu2);
		nmg_region_v_unique( fu1->s_p->r_p, &is->tol );
		nmg_region_v_unique( fu2->s_p->r_p, &is->tol );
	}
	bu_free( (char *)tags, "tags[]" );
	if (rt_g.NMG_debug & DEBUG_POLYSECT)
		bu_log("nmg_isect_two_face2p(fu1=x%x, fu2=x%x) END\n", fu1, fu2);
}
#endif
/*
 *			N M G _ I S E C T _ L I N E 2 _ E D G E 2 P
 *
 *  A parallel to nmg_isect_edge2p_edge2p().
 *
 *  Intersect the line with eu1, from fu1.
 *  The resulting vu's are added to "list", not is->l1 or is->l2.
 *  fu2 is the "other" face on this intersect line, and is used only
 *  when searching for existing vertex structs suitable for re-use.
 *
 *  Returns -
 *	Number of times edge is broken (0 or 1).
 */
int
nmg_isect_line2_edge2p(struct nmg_inter_struct *is, struct bu_ptbl *list, struct edgeuse *eu1, struct faceuse *fu1, struct faceuse *fu2)
{
	point_t		eu1_start;	/* 2D */
	point_t		eu1_end;	/* 2D */
	vect_t		eu1_dir;	/* 2D */
	fastf_t		dist[2];
	int		status;
	point_t		hit_pt;		/* 3D */
	struct vertexuse	*vu1a, *vu1b;
	int			ret = 0;

	NMG_CK_INTER_STRUCT(is);
	BU_CK_PTBL(list);
	NMG_CK_EDGEUSE(eu1);
	NMG_CK_FACEUSE(fu1);
	NMG_CK_FACEUSE(fu2);

	/*
	 * Important note:  don't use eu1->eumate_p->vu_p here,
	 * because that vu is in the opposite orientation faceuse.
	 * Putting those vu's on the intersection line makes for big trouble.
	 */
	vu1a = eu1->vu_p;
	vu1b = BU_LIST_PNEXT_CIRC( edgeuse, eu1 )->vu_p;
	NMG_CK_VERTEXUSE(vu1a);
	NMG_CK_VERTEXUSE(vu1b);

	if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
		bu_log("nmg_isect_line2_edge2p(eu1=x%x, fu1=x%x)\n\tvu1a=%x vu1b=%x\n\tv2a=%x v2b=%x\n",
			eu1, fu1,
			vu1a, vu1b,
			vu1a->v_p, vu1b->v_p );
	}

	/*
	 *  The 3D line in is->pt and is->dir is prepared by the caller.
	 */
	nmg_get_2d_vertex( eu1_start, vu1a->v_p, is, &fu1->l.magic );
	nmg_get_2d_vertex( eu1_end, vu1b->v_p, is, &fu1->l.magic );
	VSUB2_2D( eu1_dir, eu1_end, eu1_start );

	dist[0] = dist[1] = 0;	/* for clean prints, below */

	/* Intersect the line with the edge, in 2D */
	status = bn_isect_line2_lseg2( dist, is->pt2d, is->dir2d,
			eu1_start, eu1_dir, &is->tol );

	if (rt_g.NMG_debug & DEBUG_POLYSECT) {
		bu_log("\tbn_isect_line2_lseg2()=%d, dist: %g, %g\n",
			status, dist[0], dist[1] );
	}

	if (status < 0)  goto out;	/* No geometric intersection */

	if( status == 0 )  {
		/*
		 *  The edge is colinear with the line.
		 *  List both vertexuse structures, and return.
		 */
		if (rt_g.NMG_debug & DEBUG_POLYSECT)
			bu_log("\t\tedge colinear with isect line.  Listing vu1a, vu1b\n");
		nmg_enlist_vu(is, vu1a, 0, MAX_FASTF);
		nmg_enlist_vu(is, vu1b, 0, MAX_FASTF);
		ret = 0;
		goto out;
	}

	/* There is only one intersect point.  Break the edge there. */

	VJOIN1( hit_pt, is->pt, dist[0], is->dir );	/* 3D hit */

	/* Edges not colinear. Either list a vertex,
	 * or break eu1.
	 */
	if( status == 1 || dist[1] == 0 )  {
		if (rt_g.NMG_debug & DEBUG_POLYSECT)
			bu_log("\t\tintersect point is vu1a\n");
		if( !bn_pt3_pt3_equal(hit_pt, vu1a->v_p->vg_p->coord, &(is->tol) ) )
			rt_bomb("vu1a does not match calculated point\n");
		nmg_enlist_vu(is, vu1a, 0, MAX_FASTF);
		ret = 0;
	} else if( status == 2 || dist[1] == 1 )  {
		if (rt_g.NMG_debug & DEBUG_POLYSECT)
			bu_log("\t\tintersect point is vu1b\n");
		if( !bn_pt3_pt3_equal(hit_pt, vu1b->v_p->vg_p->coord, &(is->tol) ) )
			rt_bomb("vu1b does not match calculated point\n");
		nmg_enlist_vu(is, vu1b, 0, MAX_FASTF);
		ret = 0;
	} else {
		/* Intersection is in the middle of eu1, split edge */
		struct vertexuse	*vu1_final;
		struct vertex		*new_v;
		if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
			fastf_t	dist;
			int	code;
			bu_log("\t2D: pt2d=(%g, %g), dir2d=(%g, %g)\n",
				is->pt2d[X], is->pt2d[Y],
				is->dir2d[X], is->dir2d[Y] );
			bu_log("\t2D: eu1_start=(%g, %g), eu1_dir=(%g, %g)\n",
				eu1_start[X], eu1_start[Y],
				eu1_dir[X], eu1_dir[Y] );
			VPRINT("\t3D: is->pt ", is->pt);
			VPRINT("\t3D: is->dir", is->dir);
			bu_log("\t2d: Breaking eu1 at isect.\n");
			VPRINT("  vu1a", vu1a->v_p->vg_p->coord);
			VPRINT("hit_pt", hit_pt);
			VPRINT("  vu1b", vu1b->v_p->vg_p->coord);
			/* XXX Perform a (not-so) quick check */
			code = bn_isect_pt_lseg( &dist, vu1a->v_p->vg_p->coord,
				vu1b->v_p->vg_p->coord,
				hit_pt, &(is->tol) );
			bu_log("\tbn_isect_pt_lseg() dist=%g, ret=%d\n", dist, code);
			if( code < 0 )  rt_bomb("3D point not on 3D lseg\n");

			/* Ensure that the 3D hit_pt is between the end pts */
if( !bn_between(vu1a->v_p->vg_p->coord[X], hit_pt[X], vu1b->v_p->vg_p->coord[X], &(is->tol)) ||
    !bn_between(vu1a->v_p->vg_p->coord[Y], hit_pt[Y], vu1b->v_p->vg_p->coord[Y], &(is->tol)) ||
    !bn_between(vu1a->v_p->vg_p->coord[Z], hit_pt[Z], vu1b->v_p->vg_p->coord[Z], &(is->tol)) )  {
    	VPRINT("vu1a", vu1a->v_p->vg_p->coord);
    	VPRINT("hitp", hit_pt);
    	VPRINT("vu1b", vu1b->v_p->vg_p->coord);
    	rt_bomb("nmg_isect_line2_edge2p() hit point not between edge verts!\n");
}

		}

		/* if we can't find the appropriate vertex
		 * by a geometry search, build a new vertex.
		 * Otherwise, re-use the existing one.
		 * Can't just search other face, might miss relevant vert.
		 */
		new_v = nmg_find_pt_in_model(fu2->s_p->r_p->m_p, hit_pt, &(is->tol));
		vu1_final = nmg_ebreaker(new_v, eu1, &is->tol)->vu_p;
		ret = 1;
		if( !new_v )  {
			nmg_vertex_gv( vu1_final->v_p, hit_pt );	/* 3d geom */
			if (rt_g.NMG_debug & DEBUG_POLYSECT)
				bu_log("\t\tmaking new vertex vu=x%x v=x%x\n",
					vu1_final, vu1_final->v_p);
		} else {
			if (rt_g.NMG_debug & DEBUG_POLYSECT)
				bu_log("\t\tre-using vertex v=x%x vu=x%x\n", new_v, vu1_final);
		}
		nmg_enlist_vu(is, vu1_final, 0, MAX_FASTF);

		nmg_ck_face_worthless_edges( fu1 );
	}

out:
	if (rt_g.NMG_debug & DEBUG_POLYSECT)
		bu_log("nmg_isect_line2_edge2p(eu1=x%x, fu1=x%x) END ret=%d\n", eu1, fu1, ret);
	return ret;
}

/*
 *			N M G _ I S E C T _ L I N E 2 _ V E R T E X 2
 *
 *  If this lone vertex lies along the intersect line, then add it to
 *  the lists.
 *
 *  Called from nmg_isect_line2_face2p().
 */
void
nmg_isect_line2_vertex2(struct nmg_inter_struct *is, struct vertexuse *vu1, struct faceuse *fu1)
{

	NMG_CK_INTER_STRUCT(is);
	NMG_CK_VERTEXUSE(vu1);
	NMG_CK_FACEUSE(fu1);

	if (rt_g.NMG_debug & DEBUG_POLYSECT)
		bu_log("nmg_isect_line2_vertex2(vu=x%x)\n", vu1);

	/* Needs to be a 3D comparison */
	if( bn_distsq_line3_pt3( is->pt, is->dir, vu1->v_p->vg_p->coord ) > is->tol.dist_sq )
		return;

	if (rt_g.NMG_debug & DEBUG_POLYSECT)
		bu_log("nmg_isect_line2_vertex2(vu=x%x) line hits vertex v=x%x\n", vu1, vu1->v_p);

	nmg_enlist_vu( is, vu1, 0, MAX_FASTF );
}

/*
 *
 *  Given two pointer tables filled with edgeuses representing two differentt
 *  edge geometry lines, see if there is a common vertex of intersection.
 *  If so, enlist the intersection.
 *
 *  Returns -
 *	1	intersection found
 *	0	no intersection
 */
int
nmg_isect_two_ptbls(struct nmg_inter_struct *is, const struct bu_ptbl *t1, const struct bu_ptbl *t2)
{
	const struct edgeuse	**eu1;
	const struct edgeuse	**eu2;
	struct vertexuse	*vu1a;
	struct vertexuse	*vu1b;

	NMG_CK_INTER_STRUCT(is);
	BU_CK_PTBL(t1);

	for( eu1 = (const struct edgeuse **)BU_PTBL_LASTADDR(t1);
	     eu1 >= (const struct edgeuse **)BU_PTBL_BASEADDR(t1); eu1--
	)  {
		struct vertex	*v1a;
		struct vertex	*v1b;

		vu1a = (*eu1)->vu_p;
		vu1b = BU_LIST_PNEXT_CIRC( edgeuse, (*eu1) )->vu_p;
		NMG_CK_VERTEXUSE(vu1a);
		NMG_CK_VERTEXUSE(vu1b);
		v1a = vu1a->v_p;
		v1b = vu1b->v_p;

		for( eu2 = (const struct edgeuse **)BU_PTBL_LASTADDR(t2);
		     eu2 >= (const struct edgeuse **)BU_PTBL_BASEADDR(t2); eu2--
		)  {
			register struct vertexuse	*vu2a;
			register struct vertexuse	*vu2b;

			vu2a = (*eu2)->vu_p;
			vu2b = BU_LIST_PNEXT_CIRC( edgeuse, (*eu2) )->vu_p;
			NMG_CK_VERTEXUSE(vu2a);
			NMG_CK_VERTEXUSE(vu2b);

			if( v1a == vu2a->v_p )  {
				vu1b = vu2a;
				goto enlist;
			}
			if( v1a == vu2b->v_p )  {
				vu1b = vu2b;
				goto enlist;
			}
			if( v1b == vu2a->v_p )  {
				vu1a = vu1b;
				vu1b = vu2a;
				goto enlist;
			}
			if( v1b == vu2b->v_p )  {
				vu1a = vu1b;
				vu1b = vu2b;
				goto enlist;
			}
		}
	}
	return 0;
enlist:
	/* Two vu's are now vu1a, vu1b */
	if( nmg_find_s_of_vu(vu1a) == nmg_find_s_of_vu(vu1b) )  {
		vu1b = 0;
	}

	if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
		bu_log("nmg_isect_two_ptbls() intersection! vu=x%x, vu_dual=x%x\n",
			vu1a, vu1b );
	}
	nmg_enlist_vu( is, vu1a, vu1b, MAX_FASTF );
	return 1;
}

/*
 *			N M G _ F I N D _ E G _ O N _ L I N E
 *
 *  Do a geometric search to find an edge_g_lseg on the given line.
 *  If the fuser did it's job, there should be only one.
 */
struct edge_g_lseg *
nmg_find_eg_on_line(const long int *magic_p, const fastf_t *pt, const fastf_t *dir, const struct bn_tol *tol)
{
	struct bu_ptbl	eutab;
	struct edgeuse	**eup;
	struct edge_g_lseg	*ret = (struct edge_g_lseg *)NULL;
	vect_t		dir1, dir2;

	BN_CK_TOL(tol);

	nmg_edgeuse_on_line_tabulate( &eutab, magic_p, pt, dir, tol );

	for( eup = (struct edgeuse **)BU_PTBL_LASTADDR(&eutab);
	     eup >= (struct edgeuse **)BU_PTBL_BASEADDR(&eutab); eup--
	)  {
		if( !ret )  {
			/* No edge_g_lseg found yet, use this one. */
			ret = (*eup)->g.lseg_p;
			continue;
		}
		if( (*eup)->g.lseg_p == ret ) continue;	/* OK */

		/* Found 2 different edge_g_lseg, pick best one */
		VMOVE( dir1, ret->e_dir );
		VUNITIZE(dir1);
		VMOVE( dir2, (*eup)->g.lseg_p->e_dir );
		VUNITIZE(dir2);
		if( fabs(VDOT(dir1,dir)) > fabs(VDOT(dir2,dir)) )  {
			/* ret is better, do nothing */
		} else {
			/* *eup is better, take it instead */
			ret = (*eup)->g.lseg_p;
		}
		bu_log("nmg_find_eg_on_line() 2 different eg's, taking better one.\n");
	}
	(void)bu_ptbl_free( &eutab);
	if( rt_g.NMG_debug & DEBUG_POLYSECT) {
		bu_log("rt_find_eg_on_line( x%x ) ret=x%x\n", magic_p, ret);
	}
	return ret;
}

/*
 *			N M G _ K 0 E U
 *
 *  Kill all 0-length edgeuses that start and end on this vertex.
 *
 *  Returns -
 *	0	If none were found
 *	count	Number of 0-length edgeuses killed (not counting mates)
 */
int
nmg_k0eu(struct vertex *v)
{
	struct edgeuse		*eu;
	struct vertexuse	*vu;
	int			count = 0;

	NMG_CK_VERTEX(v);
top:
	for( BU_LIST_FOR( vu, vertexuse, &v->vu_hd ) )  {
		NMG_CK_VERTEXUSE(vu);
		if( *vu->up.magic_p != NMG_EDGEUSE_MAGIC )  continue;
		eu = vu->up.eu_p;
		NMG_CK_EDGEUSE(eu);
		if( eu->eumate_p->vu_p->v_p != v )  continue;
		bu_log("nmg_k0eu(v=x%x) killing 0-len eu=x%x, mate=x%x\n",
			v, eu, eu->eumate_p);
nmg_pr_eu_briefly(eu, 0);
nmg_pr_eu_briefly(eu->eumate_p, 0);
		if( nmg_keu(eu) )  {
			bu_log("nmg_k0eu() WARNING: parent now has no edgeuses\n");
			/* XXX Now what? */
		}
		count++;
		goto top;	/* vu_hd list is altered by nmg_keu() */
	}
	return count;
}

/*
 *			N M G _ R E P A I R _ V _ N E A R _ V
 *
 *  Attempt to join two vertices which both claim to be the intersection
 *  of two lines.  If they are close enough, repair the damage.
 *
 *  Returns -
 *	hit_v	If repair succeeds.  vertex 'v' is now invalid.
 *	NULL	If repair fails.
 *		If 'bomb' is non-zero, rt_bomb() is called.
 */
struct vertex *
nmg_repair_v_near_v(struct vertex *hit_v, struct vertex *v, const struct edge_g_lseg *eg1, const struct edge_g_lseg *eg2, int bomb, const struct bn_tol *tol)
             		       
             		   
                        		     		/* edge_g_lseg of hit_v */
                        		     		/* edge_g_lseg of v */
   			     
                   	     
{
	NMG_CK_VERTEX(hit_v);
	NMG_CK_VERTEX(v);
	if(eg1) NMG_CK_EDGE_G_LSEG(eg1);	/* eg1 may be NULL */
	NMG_CK_EDGE_G_LSEG(eg2);
	BN_CK_TOL(tol);

	bu_log("nmg_repair_v_near_v(hit_v=x%x, v=x%x)\n", hit_v, v );

	VPRINT("v  ", v->vg_p->coord);
	VPRINT("hit", hit_v->vg_p->coord);
	bu_log("dist v-hit=%g, equal=%d\n",
		bn_dist_pt3_pt3(v->vg_p->coord, hit_v->vg_p->coord),
		bn_pt3_pt3_equal(v->vg_p->coord, hit_v->vg_p->coord, tol)
	    );
	if( eg1 )  {
		if( bn_2line3_colinear( eg1->e_pt, eg1->e_dir, eg2->e_pt, eg2->e_dir, 1e5, tol ) )
			rt_bomb("ERROR: nmg_repair_v_near_v() eg1 and eg2 are colinear!\n");
		bu_log("eg1: line/ vu dist=%g, hit dist=%g\n",
			bn_dist_line3_pt3( eg1->e_pt, eg1->e_dir, v->vg_p->coord ),
			bn_dist_line3_pt3( eg1->e_pt, eg1->e_dir, hit_v->vg_p->coord ) );
		bu_log("eg2: line/ vu dist=%g, hit dist=%g\n",
			bn_dist_line3_pt3( eg2->e_pt, eg2->e_dir, v->vg_p->coord ),
			bn_dist_line3_pt3( eg2->e_pt, eg2->e_dir, hit_v->vg_p->coord ) );
		nmg_pr_eg(&eg1->l.magic, 0);
		nmg_pr_eg(&eg2->l.magic, 0);
	}

	if( bn_dist_pt3_pt3(v->vg_p->coord,
	      hit_v->vg_p->coord) < 10 * tol->dist )  {
		struct edgeuse	*eu0;
		bu_log("NOTICE: The intersection of two lines has resulted in 2 different intersect points\n");
		bu_log("  Since the two points are 'close', they are being fused.\n");

		/* See if there is an edge between them */
		eu0 = nmg_findeu(hit_v, v, (struct shell *)NULL,
			(struct edgeuse *)NULL, 0);
		if( eu0 )  {
			bu_log("DANGER: a 0-length edge is being created eu0=x%x\n", eu0);
		}

		nmg_jv(hit_v, v);
		(void)nmg_k0eu(hit_v);
		goto out;
	}
	/* Separation is too great */
/**	if( bomb ) **/
		rt_bomb("nmg_repair_v_near_v() separation is too great to repair.\n");
	hit_v = (struct vertex *)NULL;
out:
	bu_log("nmg_repair_v_near_v(v=x%x) ret=x%x\n", v, hit_v);
	return hit_v;
}

/*
 *  Search all edgeuses referring to this vu's vertex.
 *  If the vertex is used by edges on both eg1 and eg2, then it's a "hit"
 *  between the two edge geometries.
 *  If a new hit happens at a different vertex from a previous hit,
 *  that is a fatal error.
 *
 *  This routine exists only as a support routine for nmg_common_v_2eg().
 *  
 * XXX This is a lame name.
 */
struct vertex *
nmg_search_v_eg(const struct edgeuse *eu, int second, const struct edge_g_lseg *eg1, const struct edge_g_lseg *eg2, register struct vertex *hit_v, const struct bn_tol *tol)
                    		    
   				       		/* 2nd vu on eu, not 1st */
                        	     
                        	     
                      		       		/* often will be NULL */
                   		     
{
	struct vertex			*v;
	register struct vertexuse	*vu1;
	register struct edgeuse		*seen1 = (struct edgeuse *)NULL;
	register struct edgeuse		*seen2 = (struct edgeuse *)NULL;

	NMG_CK_EDGEUSE(eu);
	NMG_CK_EDGE_G_LSEG(eg1);
	NMG_CK_EDGE_G_LSEG(eg2);
	BN_CK_TOL(tol);

	if( second )  {
		v = BU_LIST_PNEXT_CIRC(edgeuse, eu)->vu_p->v_p;
		if( v != eu->eumate_p->vu_p->v_p )
			rt_bomb("nmg_search_v_eg() next vu not mate's vu?\n");
	} else {
		v = eu->vu_p->v_p;
	}
	NMG_CK_VERTEX(v);

	if( eu->g.lseg_p != eg1 )  rt_bomb("nmg_search_v_eg() eu not on eg1\n");

	/* vu lies on eg1 by topology.  Check this assertion. */
	if( bn_distsq_line3_pt3( eg1->e_pt, eg1->e_dir, v->vg_p->coord ) > tol->dist_sq )  {
		VPRINT("v", v->vg_p->coord);
		nmg_pr_eu( eu, (char *)NULL );
		nmg_pr_eg( &eg1->l.magic, 0 );
		rt_bomb("nmg_search_v_eg() eu vertex not on eg line\n");
	}

	/* This loop accounts for 30% of the runtime of a boolean! */
	for( BU_LIST_FOR( vu1, vertexuse, &v->vu_hd ) )  {
		register struct edgeuse	*eu1;

		if( *vu1->up.magic_p != NMG_EDGEUSE_MAGIC )  continue;
		eu1 = vu1->up.eu_p;
		if( eu1->g.lseg_p == eg1 )  seen1 = eu1;
		if( eu1->g.lseg_p == eg2 )  seen2 = eu1;
		if( !seen1 || !seen2 )  continue;

		/* Both edge_g's have been seen at 'v', this is a hit. */
		if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
			bu_log("  seen1=x%x, seen2=x%x, hit_v=x%x, v=x%x\n",
				seen1, seen2, hit_v, v);
		}
		if( !hit_v )   {
			hit_v = v;
			break;
		}

		/* Is it a different vertex than hit_v? */
		if( hit_v == v )  break;

		/* Different vertices, this "can't happen" */
		bu_log("ERROR seen1=x%x, seen2=x%x, hit_v=x%x != v=x%x\n",
			seen1, seen2, hit_v, v);
		if( nmg_repair_v_near_v( hit_v, v, eg1, eg2, 0, tol ) )
			break;

		rt_bomb("nmg_search_v_eg() two different vertices for intersect point?\n");
	}
	if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
		bu_log("nmg_search_v_eg(eu=x%x, %d, eg1=x%x, eg2=x%x) ret=x%x\n",
			eu, second, eg1, eg2, hit_v);
	}
	return hit_v;
}

/*
 *			N M G _ C O M M O N _ V _ 2 E G
 *
 *  Perform a topology search for a common vertex between two edge geometry
 *  lines.
 */
struct vertex *
nmg_common_v_2eg(struct edge_g_lseg *eg1, struct edge_g_lseg *eg2, const struct bn_tol *tol)
{
	struct edgeuse		*eu1;
	struct vertex		*hit_v = (struct vertex *)NULL;
	struct bu_list		*midway;	/* &eu->l2, midway into edgeuse */

	NMG_CK_EDGE_G_LSEG(eg1);
	NMG_CK_EDGE_G_LSEG(eg2);
	BN_CK_TOL(tol);

	if( eg1 == eg2 )
		rt_bomb("nmg_common_v_2eg() eg1 and eg2 are colinear\n");

	/* Scan all edgeuses in the model that use eg1 */
	for( BU_LIST_FOR( midway, bu_list, &eg1->eu_hd2 ) )  {
		NMG_CKMAG(midway, NMG_EDGEUSE2_MAGIC, "edgeuse2 [l2]");
		eu1 = BU_LIST_MAIN_PTR( edgeuse, midway, l2 );
		NMG_CK_EDGEUSE(eu1);
		if( eu1->g.lseg_p != eg1 )  rt_bomb("nmg_common_v_2eg() eu disavows eg\n");
		/* Both verts of eu1 lie on line eg1 */
		hit_v = nmg_search_v_eg( eu1, 0, eg1, eg2, hit_v, tol );
		hit_v = nmg_search_v_eg( eu1, 1, eg1, eg2, hit_v, tol );
	}
	if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
		bu_log("nmg_common_v_2eg(eg1=x%x, eg2=x%x) hit_v=x%x\n",
			eg1, eg2, hit_v);
	}
	return hit_v;
}

#define VDIST( a, b )	sqrt( (a[X]-b[X])*(a[X]-b[X]) + (a[Y]-b[Y])*(a[Y]-b[Y]) + (a[Z]-b[Z])*(a[Z]-b[Z]) )
#define VDIST_SQ( a, b )	( (a[X]-b[X])*(a[X]-b[X]) + (a[Y]-b[Y])*(a[Y]-b[Y]) + (a[Z]-b[Z])*(a[Z]-b[Z]) )

int
nmg_is_vertex_on_inter(struct vertex *v, struct faceuse *fu1, struct faceuse *fu2, struct nmg_inter_struct *is)
{
	struct vertex_g *vg;
	plane_t pl1,pl2;
	int code;
	fastf_t dist;

	NMG_CK_VERTEX( v );
	NMG_CK_FACEUSE( fu1 );
	NMG_CK_FACEUSE( fu2 );
	NMG_CK_INTER_STRUCT(is);

	if( nmg_find_v_in_face( v, fu1 ) && nmg_find_v_in_face( v, fu2 ) )
		return( 1 );

	NMG_GET_FU_PLANE( pl1, fu1 );
	NMG_GET_FU_PLANE( pl2, fu2 );

	vg = v->vg_p;
	NMG_CK_VERTEX_G( vg );

	/* check if vertex is in plane of fu's  */
	dist = fabs( DIST_PT_PLANE( vg->coord, pl1 ) );
	if( dist > is->tol.dist )
		return( 0 );
	dist = fabs( DIST_PT_PLANE( vg->coord, pl2 ) );
	if( dist > is->tol.dist )
		return( 0 );

	/* check if it is on intersection line */
	if( bn_distsq_line3_pt3( is->pt, is->dir, vg->coord ) > is->tol.dist_sq )
		return( 0 );

	/* check if it is within fu's */
	code = nmg_class_pt_fu_except( vg->coord, fu1, (struct loopuse *)NULL,
		(void (*)())NULL, (void (*)())NULL, (char *)NULL, 0, 0, &is->tol );
	if( code != NMG_CLASS_AinB )
		return( 0 );

	code = nmg_class_pt_fu_except( vg->coord, fu2, (struct loopuse *)NULL,
		(void (*)())NULL, (void (*)())NULL, (char *)NULL, 0, 0, &is->tol );
	if( code != NMG_CLASS_AinB )
		return( 0 );

	return( 1 );
}

void
nmg_isect_eu_verts(struct edgeuse *eu, struct vertex_g *vg1, struct vertex_g *vg2, struct bu_ptbl *verts, struct bu_ptbl *inters, const struct bn_tol *tol)
{
	int i;
	struct vertex *v1,*v2;

	NMG_CK_EDGEUSE( eu );
	NMG_CK_VERTEX_G( vg1 );
	NMG_CK_VERTEX_G( vg2 );
	BU_CK_PTBL( verts );
	BU_CK_PTBL( inters );
	BN_CK_TOL( tol );

	v1 = eu->vu_p->v_p;	
	v2 = eu->eumate_p->vu_p->v_p;

	for( i=0 ; i<BU_PTBL_END( verts ) ; i++ )
	{
		struct vertex *v;
		fastf_t dist;
		point_t pca;
		int code;

		v = (struct vertex *)BU_PTBL_GET( verts, i );
		if( v == v1 || v == v2 )
		{
			bu_ptbl_ins_unique( inters, (long *)v );
			continue;
		}

		code = bn_dist_pt3_lseg3( &dist, pca, vg1->coord,
				vg2->coord, v->vg_p->coord, tol );

		if( code )
			continue;

		bu_ptbl_ins_unique( inters, (long *)v );
	}

	return;
}

void
nmg_isect_eu_eu(struct edgeuse *eu1, struct vertex_g *vg1a, struct vertex_g *vg1b, fastf_t *dir1, struct edgeuse *eu2, struct bu_ptbl *verts, struct bu_ptbl *inters, const struct bn_tol *tol)
{
	struct model *m;
	struct vertex_g *vg2a,*vg2b;
	vect_t dir2;
	fastf_t dist[2];
	int code;
	point_t hit_pt;
	vect_t diff;

	if (rt_g.NMG_debug & DEBUG_POLYSECT)
		bu_log( "nmg_isect_eu_eu( eu1=x%x, eu2=x%x )\n", eu1, eu2 );

	NMG_CK_EDGEUSE( eu1 );
	NMG_CK_VERTEX_G( vg1a );
	NMG_CK_VERTEX_G( vg1b );
	NMG_CK_EDGEUSE( eu2 );
	BN_CK_TOL( tol );
	BU_CK_PTBL( inters );
	BU_CK_PTBL( verts );

	m = nmg_find_model( &eu1->l.magic );
	NMG_CK_MODEL( m );

	vg2a = eu2->vu_p->v_p->vg_p;
	NMG_CK_VERTEX_G( vg2a );

	vg2b = eu2->eumate_p->vu_p->v_p->vg_p;
	NMG_CK_VERTEX_G( vg2b );

	VSUB2( dir2, vg2b->coord, vg2a->coord );

	code = bn_isect_lseg3_lseg3( dist, vg1a->coord, dir1, vg2a->coord, dir2, tol );

	if( code < 0 )
	{
		if (rt_g.NMG_debug & DEBUG_POLYSECT)
			bu_log( "\tnmg_isect_eu_eu: No intersection\n" );
		return;
	}

	if( code == 1 )
	{
		point_t hit_pt1,hit_pt2;
		struct vertex *v=(struct vertex *)NULL;
		struct edgeuse *new_eu;

		/* normal intersection (one point ) */

		if( eu1->vu_p->v_p == eu2->vu_p->v_p ||
		    eu1->vu_p->v_p == eu2->eumate_p->vu_p->v_p ||
		    eu1->eumate_p->vu_p->v_p == eu2->vu_p->v_p ||
		    eu1->eumate_p->vu_p->v_p == eu2->eumate_p->vu_p->v_p )
			return;

		if( dist[0] == 0.0 || dist[0] == 1.0 )
			return;

		if( dist[1] == 0.0 )
		{
			bu_ptbl_ins_unique( inters, (long *)eu2->vu_p->v_p );
			return;
		}
		if( dist[1] == 1.0 )
		{
			bu_ptbl_ins_unique( inters, (long *)eu2->eumate_p->vu_p->v_p );
			return;
		}

		VJOIN1( hit_pt1, vg1a->coord, dist[0], dir1 );
		VJOIN1( hit_pt2, vg2a->coord, dist[1], dir2 );

		VBLEND2( hit_pt, 0.5, hit_pt1, 0.5, hit_pt2 );

		v = nmg_find_pt_in_model( m, hit_pt, tol );

		if (rt_g.NMG_debug & DEBUG_POLYSECT)
		{
			bu_log( "nmg_isect_eu_eu: intersection at (%g %g %g)\n", V3ARGS( hit_pt ) );
			bu_log( "splitting eu x%x at v=x%x\n", eu2, v );
		}
		new_eu = nmg_esplit( v, eu2, 1 );
		if( !v )
		{
			v = new_eu->vu_p->v_p;
			nmg_vertex_gv( v, hit_pt );
			if (rt_g.NMG_debug & DEBUG_POLYSECT)
				bu_log( "\tcreated new vertex x%x\n", v );
		}
		bu_ptbl_ins_unique( inters, (long *)v );
		bu_ptbl_ins_unique( verts, (long *)v );
		return;
	}

	/* code == 0, could be two intersection points
	 * But there should be no vertex creation here
	 */

	VSUB2( diff, vg2a->coord, vg1a->coord );
	if( VDOT( diff, dir1 ) > 0.0 )
	{
		VSUB2( diff, vg1b->coord, vg2a->coord );
		if( VDOT( diff, dir1 ) > 0.0 )
			bu_ptbl_ins_unique( inters, (long *)eu2->vu_p->v_p );
	}

	VSUB2( diff, vg2b->coord, vg1a->coord );
	if( VDOT( diff, dir1 ) > 0.0 )
	{
		VSUB2( diff, vg1b->coord, vg2b->coord );
		if( VDOT( diff, dir1 ) > 0.0 )
			bu_ptbl_ins_unique( inters, (long *)eu2->eumate_p->vu_p->v_p );
	}
}

void
nmg_isect_eu_fu(struct nmg_inter_struct *is, struct bu_ptbl *verts, struct edgeuse *eu, struct faceuse *fu)
{
	struct model *m;
	struct vertex_g *vg1,*vg2;
	struct loopuse *lu;
	plane_t pl;
	fastf_t dist;
	fastf_t eu_len;
	fastf_t one_over_len;
	point_t hit_pt;
	vect_t edir;
	vect_t dir;
	struct bu_ptbl inters;
	fastf_t *inter_dist;
	int i;

	if (rt_g.NMG_debug & DEBUG_POLYSECT)
		bu_log( "nmg_isect_eu_fu: eu=x%x, fu=x%x START\n", eu, fu );

	NMG_CK_INTER_STRUCT( is );
	NMG_CK_FACEUSE( fu );
	NMG_CK_EDGEUSE( eu );
	BU_CK_PTBL( verts );

	if( nmg_find_fu_of_eu( eu ) == fu )
	{
		bu_log( "nmg_isect_eu_fu() called with eu (x%x) from its own fu (x%x)\n",eu , fu );
		rt_bomb( "nmg_isect_eu_fu() called with eu from its own fu" );
	}

	m = nmg_find_model( &fu->l.magic );
	NMG_CK_MODEL( m );
	if( nmg_find_model( &eu->l.magic ) != m )
	{
		bu_log( "nmg_isect_eu_fu() called with EU (x%x) from model (x%x)\n", eu, nmg_find_model( &eu->l.magic ) );
		bu_log( "\tand FU (x%x) from model (x%x)\n", fu, m );
		rt_bomb( "nmg_isect_eu_fu() called with EU and FU from different models" );
	}

	vg1 = eu->vu_p->v_p->vg_p;
	NMG_CK_VERTEX_G( vg1 );
	vg2 = eu->eumate_p->vu_p->v_p->vg_p;
	NMG_CK_VERTEX_G( vg2 );

	VSUB2( dir, vg2->coord, vg1->coord );
	VMOVE( edir, dir );
	eu_len = MAGNITUDE( dir );
	if( eu_len < is->tol.dist || eu_len < SMALL_FASTF )
	{
		if (rt_g.NMG_debug & DEBUG_POLYSECT)
			bu_log( "\tnmg_isec_eu_fu: 0 length edge\n" );
		return;
	}

	one_over_len = 1.0/eu_len;
	VSCALE( dir, dir, one_over_len );

	NMG_GET_FU_PLANE( pl, fu );
	/* check if edge line intersects plane of fu */
	if( bn_isect_line3_plane( &dist, vg1->coord, dir, pl, &is->tol ) < 1 )
	{
		if (rt_g.NMG_debug & DEBUG_POLYSECT)
			bu_log( "\tnmg_isec_eu_fu: no intersection\n" );
		return;
	}
#if 0
	/* make sure intersection is within limits of eu */
	if( dist < (-is->tol.dist) || dist > eu_len+is->tol.dist )
	{
		if (rt_g.NMG_debug & DEBUG_POLYSECT)
			bu_log( "\tnmg_isec_eu_fu: intersection beyond ends of EU\n" );
		return;
	}

	if( dist <= is->tol.dist )
	{
		if (rt_g.NMG_debug & DEBUG_POLYSECT)
			bu_log( "\tintersection at eu_vu_p\n" );
		(void)nmg_make_dualvu( eu->vu_p->v_p, fu, &is->tol );
		return;
	}

	if( dist >= eu_len - is->tol.dist )
	{
		if (rt_g.NMG_debug & DEBUG_POLYSECT)
			bu_log( "\tintersection at eu->eumate_p->vu_p\n" );
		(void)nmg_make_dualvu( eu->eumate_p->vu_p->v_p, fu, &is->tol );
		return;
	}
#endif
	VJOIN1( hit_pt, vg1->coord, dist, dir );

	if (rt_g.NMG_debug & DEBUG_POLYSECT)
		bu_log( "\tintersection point at (%g %g %g)\n", V3ARGS( hit_pt ) );

	/* create a list of intersection vertices */
	bu_ptbl_init( &inters, 64, " &inters");

	/* add vertices from fu to list */
	nmg_isect_eu_verts( eu, vg1, vg2, verts, &inters, &is->tol );

	/* break FU EU's that intersect our eu, and put vertices on list */
	for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
	{
		struct edgeuse *eu_fu;

		NMG_CK_LOOPUSE( lu );

		/* vertices of FU are handled above */
		if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
			continue;

		for( BU_LIST_FOR( eu_fu, edgeuse, &lu->down_hd ) )
		{
			NMG_CK_EDGEUSE( eu_fu );

			nmg_isect_eu_eu( eu, vg1, vg2, edir, eu_fu, verts, &inters, &is->tol );

		}
	}

	/* Now break eu at every vertex in the "inters" list */

	if( BU_PTBL_END( &inters ) == 0 )
	{
		struct vertex *v=(struct vertex *)NULL;
		int class;
		fastf_t dist_to_plane;

		if (rt_g.NMG_debug & DEBUG_POLYSECT)
			bu_log( "\tNo intersection points found\n" );

		/* check if EU endpoints are within tolerance of FU
		 * If so, the endpoint is the intersection and nothing to do
		 */
		dist_to_plane = DIST_PT_PLANE( vg1->coord, pl );
		if( dist_to_plane < 0.0 )
			dist_to_plane = (-dist_to_plane);
		if( dist_to_plane <= is->tol.dist )
		{
			/* check if hit point is within fu */
			class = nmg_class_pt_fu_except( vg1->coord, fu, (struct loopuse *)NULL,
				0, 0, (char *)NULL, 0, 0, &is->tol );
			if( class != NMG_CLASS_AinB )
				goto out;

			v = eu->vu_p->v_p;
			if( v && !nmg_find_v_in_face( v, fu ) )
			{
				struct vertexuse *new_vu;

				new_vu = nmg_make_dualvu( v, fu, &is->tol );
				bu_ptbl_ins_unique( verts, (long *)new_vu->v_p );
			}
			goto out;
		}

		dist_to_plane = DIST_PT_PLANE( vg2->coord, pl );
		if( dist_to_plane < 0.0 )
			dist_to_plane = (-dist_to_plane);
		if( dist_to_plane <= is->tol.dist )
		{
			/* check if hit point is within fu */
			class = nmg_class_pt_fu_except( vg2->coord, fu, (struct loopuse *)NULL,
				0, 0, (char *)NULL, 0, 0, &is->tol );
			if( class != NMG_CLASS_AinB )
				goto out;

			v = eu->eumate_p->vu_p->v_p;
			if( v && !nmg_find_v_in_face( v, fu ) )
			{
				struct vertexuse *new_vu;

				new_vu = nmg_make_dualvu( v, fu, &is->tol );
				bu_ptbl_ins_unique( verts, (long *)new_vu->v_p );
			}
			goto out;
		}

		/* no vertices found, we might need to create a self loop */

		/* make sure intersection is within limits of eu */
		if( dist < (-is->tol.dist) || dist > eu_len+is->tol.dist )
		{
			if (rt_g.NMG_debug & DEBUG_POLYSECT)
				bu_log( "\tnmg_isec_eu_fu: intersection beyond ends of EU\n" );
			goto out;
		}

		/* check if hit_point is within tolerance of an end of eu */
		if( VDIST_SQ( hit_pt, vg1->coord ) <= is->tol.dist_sq )
		{
			v = eu->vu_p->v_p;
			VMOVE( hit_pt, vg1->coord );
		}
		else if( VDIST_SQ( hit_pt, vg2->coord ) <= is->tol.dist_sq )
		{
			v = eu->eumate_p->vu_p->v_p;
			VMOVE( hit_pt, vg2->coord );
		}

		if (rt_g.NMG_debug & DEBUG_POLYSECT)
		{
			bu_log( "\tHit point is not within tolerance of eu endpoints\n" );
			bu_log( "\t\thit_pt=( %g %g %g ), eu=(%g %g %g)<->(%g %g %g)\n",
				V3ARGS( hit_pt), V3ARGS( vg1->coord ), V3ARGS( vg2->coord ) );
		}

		/* check if hit point is within fu */
		class = nmg_class_pt_fu_except( hit_pt, fu, (struct loopuse *)NULL,
			0, 0, (char *)NULL, 0, 0, &is->tol );

		if( class == NMG_CLASS_AinB )
		{
			struct edgeuse *new_eu;

			/* may need to split eu */
			if( !v )
				v = nmg_find_pt_in_model( m, hit_pt, &is->tol );
			if( v != eu->vu_p->v_p && v != eu->eumate_p->vu_p->v_p )
			{
				if (rt_g.NMG_debug & DEBUG_POLYSECT)
					bu_log( "\tsplitting eu (x%x) at hit_pt (v=x%x)\n", eu, v );

				new_eu = nmg_esplit( v, eu, 1 );
				if( !v )
				{
					v = new_eu->vu_p->v_p;
					if (rt_g.NMG_debug & DEBUG_POLYSECT)
						bu_log( "\tnew vertex at hit point is x%x\n", v );
					nmg_vertex_gv( v, hit_pt );
				}
			}

			if( v && !nmg_find_v_in_face( v, fu ) )
			{
				struct vertexuse *new_vu;

				new_vu = nmg_make_dualvu( v, fu, &is->tol );
				bu_ptbl_ins_unique( verts, (long *)new_vu->v_p );
			}
			
		}
		goto out;
	}

	if( BU_PTBL_END( &inters ) == 1 )
	{
		struct vertex *v;

		/* only one vertex, just split */
		v = (struct vertex *)BU_PTBL_GET( &inters, 0 );
		NMG_CK_VERTEX( v );

		if (rt_g.NMG_debug & DEBUG_POLYSECT)
			bu_log( "Only one intersect vertex (x%x), just split all EU's at (x%x)\n", v, eu );

		if( v == eu->vu_p->v_p || v == eu->eumate_p->vu_p->v_p )
			goto out;

		(void)nmg_break_all_es_on_v( &m->magic, v, &is->tol );

		goto out;
	}

	/* must do them in order from furthest to nearest */
	inter_dist = (fastf_t *)bu_calloc( BU_PTBL_END( &inters ), sizeof( fastf_t ),
		"nmg_isect_eu_fu: inter_dist" );

	if (rt_g.NMG_debug & DEBUG_POLYSECT)
		bu_log( "%d intersect vertices along eu (x%x)\n", BU_PTBL_END( &inters ), eu );

	for( i=0 ; i<BU_PTBL_END( &inters ) ; i++ )
	{
		struct vertex *v;
		struct vertex_g *vg;
		vect_t diff;

		v = (struct vertex *)BU_PTBL_GET( &inters, i );
		NMG_CK_VERTEX( v );
		vg = v->vg_p;
		NMG_CK_VERTEX_G( vg );

		VSUB2( diff, vg->coord, vg1->coord );
		if( VDOT( diff, dir ) < 0.0 )
			rt_bomb( "nmg_isect_eu_fu: intersection point not on eu\n" );

		inter_dist[i] = MAGSQ( diff );
	}

	if (rt_g.NMG_debug & DEBUG_POLYSECT)
	{
		bu_log( "Intersect vertices along eu x%x:\n", eu );
		for( i=0 ; i<BU_PTBL_END( &inters ) ; i++ )
			bu_log( "%d x%x %g\n", i+1, BU_PTBL_GET( &inters, i ), inter_dist[i] );
	}

	while( 1 )
	{
		struct vertex *v;
		fastf_t max_dist;
		int index_at_max;

		max_dist = (-1.0);
		index_at_max = (-1);

		for( i=0 ; i<BU_PTBL_END( &inters ) ; i++ )
		{
			if( inter_dist[i] > max_dist )
			{
				max_dist = inter_dist[i];
				index_at_max = i;
			}
		}

		if( index_at_max < 0 )
			break;

		v = (struct vertex *)BU_PTBL_GET( &inters, index_at_max );
		NMG_CK_VERTEX( v );

		if( v != eu->vu_p->v_p && v != eu->eumate_p->vu_p->v_p )
		{
			if (rt_g.NMG_debug & DEBUG_POLYSECT)
				bu_log( "Breaking edges at vertex #%d, dist=%g, v=x%x\n", i+1, inter_dist[i], v );
			(void)nmg_break_all_es_on_v( &m->magic, v, &is->tol );
		}

		inter_dist[index_at_max] = (-10.0);
	}

	bu_free( (char *)inter_dist, "nmg_isect_eu_fu: inter_dist" );

out:
	bu_ptbl_free( &inters);

	if (rt_g.NMG_debug & DEBUG_POLYSECT)
		bu_log( "nmg_isect_eu_fu: eu=x%x, fu=x%x END\n", eu, fu );

}

void
nmg_isect_fu_jra(struct nmg_inter_struct *is, struct faceuse *fu1, struct faceuse *fu2, struct bu_ptbl *eu1_list, struct bu_ptbl *eu2_list)
{
	struct model *m;
	struct bu_ptbl verts1,verts2;
	struct loopuse *lu;
	int i;

	if (rt_g.NMG_debug & DEBUG_POLYSECT)
		bu_log( "nmg_isect_fu_jra( fu1=x%x, fu2=x%x ) START\n", fu1, fu2 );

	NMG_CK_INTER_STRUCT(is);
	NMG_CK_FACEUSE(fu1);
	NMG_CK_FACEUSE(fu2);
	BU_CK_PTBL(eu1_list);
	BU_CK_PTBL(eu2_list);

	m = nmg_find_model( &fu1->l.magic );
	NMG_CK_MODEL( m );

	nmg_vertex_tabulate( &verts2, &fu2->l.magic );

	/* Intersect fu1 edgeuses */
	for( BU_LIST_FOR( lu, loopuse, &fu1->lu_hd ) )
	{
		struct edgeuse *eu;

		NMG_CK_LOOPUSE( lu );

		if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
			continue;

		for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
		{
			NMG_CK_EDGEUSE( eu );

			nmg_isect_eu_fu( is, &verts2, eu, fu2 );
		}
	}

	bu_ptbl_free( &verts2);
	nmg_vertex_tabulate( &verts1, &fu1->l.magic );

	/* now intersect fu2 edgeuses */
	for( BU_LIST_FOR( lu, loopuse, &fu2->lu_hd ) )
	{
		struct edgeuse *eu;

		NMG_CK_LOOPUSE( lu );

		if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
			continue;

		for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
		{
			NMG_CK_EDGEUSE( eu );

			nmg_isect_eu_fu( is, &verts1, eu, fu1 );
		}
	}

	/* check for existing vertices along intersection */
	bu_ptbl_free( &verts1);

	/* XXXX this is the second time this tabulate is being done,
	 * but for now it's safer this way
	 */
	nmg_vertex_tabulate( &verts1, &fu1->l.magic );
	nmg_vertex_tabulate( &verts2, &fu2->l.magic );

	/* merge the two lists */
	for( i=0 ; i<BU_PTBL_END( &verts2 ) ; i++ )
	{
		struct vertex *v;

		v = (struct vertex *)BU_PTBL_GET( &verts2, i );
		NMG_CK_VERTEX( v );

		bu_ptbl_ins_unique( &verts1, (long *)v );
	}
	bu_ptbl_free( &verts2);

	for( i=0 ; i< BU_PTBL_END( &verts1 ) ; i++ )
	{
		struct vertex *v;
		struct vertexuse *vu;
		fastf_t dist;

		v = (struct vertex *)BU_PTBL_GET( &verts1, i );
		NMG_CK_VERTEX( v );

		if( !nmg_is_vertex_on_inter( v, fu1, fu2, is ) )
			continue;

		/* calculate distance along intersect ray */
		dist = VDIST( is->pt, v->vg_p->coord );

		/* this vertex is on the intersection line
		 * add all uses from fu1 and fu2 to intersection list
		 */
		for( BU_LIST_FOR( vu, vertexuse, &v->vu_hd ) )
		{
			struct faceuse *fu_tmp;

			fu_tmp = nmg_find_fu_of_vu( vu );
			if( fu_tmp == fu1 || fu_tmp == fu2 )
			{
				if (rt_g.NMG_debug & DEBUG_POLYSECT)
					bu_log( "\tenlisting vu x%x (x%x) from fu (x%x)\n", vu, v, fu_tmp );
				nmg_enlist_one_vu( is, vu, dist );
			}
		}
	}

	bu_ptbl_free( &verts1);

	if (rt_g.NMG_debug & DEBUG_POLYSECT)
		bu_log( "nmg_isect_fu_jra( fu1=x%x, fu2=x%x ) END\n", fu1, fu2 );
}

/*
 *			N M G _ I S E C T _ L I N E 2 _ F A C E 2 P
 *
 * HEART
 *
 *  For each distinct edge_g_lseg LINE on the face (composed of potentially many
 *  edgeuses and many different edges), intersect with the edge_g_lseg LINE
 *  which represents the face/face intersection line.
 *
 *  Note that the geometric intersection of the two faces is
 *  stored in is->pt and is->dir.
 *  If is->on_eg is set, it is the callers' responsibility to make sure
 *  it is not much different than the original geometric one.
 *
 *  Go to great pains to ensure that two non-colinear lines intersect
 *  at either 0 or 1 points, and no more.
 *
 *  Called from -
 *	nmg_isect_edge2p_face2p()
 *	nmg_isect_two_face3p()
 */
void
nmg_isect_line2_face2pNEW(struct nmg_inter_struct *is, struct faceuse *fu1, struct faceuse *fu2, struct bu_ptbl *eu1_list, struct bu_ptbl *eu2_list)
{
	struct bu_ptbl		eg_list;
	struct edge_g_lseg	**eg1;
	struct edgeuse		*eu1;
	struct edgeuse		*eu2;
	fastf_t			dist[2];
	int			code;
	point_t			eg_pt2d;	/* 2D */
	vect_t			eg_dir2d;	/* 2D */
	struct loopuse		*lu1;
	point_t			hit3d;
	point_t			hit2d;		/* 2D */
	struct edgeuse		*new_eu;
	int			eu1_index;
	int			eu2_index;
	int			class;

	NMG_CK_INTER_STRUCT(is);
	NMG_CK_FACEUSE(fu1);
	NMG_CK_FACEUSE(fu2);
	BU_CK_PTBL(eu1_list);
	BU_CK_PTBL(eu2_list);

	if (rt_g.NMG_debug & DEBUG_POLYSECT)
		bu_log("nmg_isect_line2_face2pNEW(, fu1=x%x, fu2=x%x) on_eg=x%x\n", fu1, fu2, is->on_eg);

	/* Project the intersect line into 2D.  Build matrix first. */
	nmg_isect2d_prep( is, &fu1->l.magic );
	/* XXX Need subroutine for this!! */
	MAT4X3PNT( is->pt2d, is->proj, is->pt );
	MAT4X3VEC( is->dir2d, is->proj, is->dir );

re_tabulate:
	/* Build list of all edge_g_lseg's in fu1 */
	/* XXX This could be more cheaply done by cooking down eu1_list */
	nmg_edge_g_tabulate( &eg_list, &fu1->l.magic );

	/* Process each distinct line in the face fu1 */
	for( eg1 = (struct edge_g_lseg **)BU_PTBL_LASTADDR(&eg_list);
	     eg1 >= (struct edge_g_lseg **)BU_PTBL_BASEADDR(&eg_list); eg1--
	)  {
		struct vertex		*hit_v = (struct vertex *)NULL;

		NMG_CK_EDGE_G_LSEG(*eg1);

		if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
			bu_log( "\tChecking eg=x%x\n", *eg1 );
		}

		if( *eg1 == is->on_eg )  {
#if 0
colinear:
			/*
			 *  This edge_g is known to be ON the face/face line.
			 *  Intersect all pairs of edgeuses, and enlist
			 *  every vertexuse along the edge.
			 *  Because the list can grow, scan in upwards direction.
			 */
			if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
				bu_log("\tThis edge_geom generated the line.  Enlisting.\n");
			}
			for( eu1_index=0; eu1_index < BU_PTBL_END(eu1_list); eu1_index++ )  {
				eu1 = (struct edgeuse *)BU_PTBL_GET(eu1_list, eu1_index);
				NMG_CK_EDGEUSE(eu1);
				if( eu1->g.lseg_p != is->on_eg )  continue;
				/* eu1 is from fu1 */

				for( eu2_index=0; eu2_index < BU_PTBL_END(eu2_list); eu2_index++ )  {
					eu2 = (struct edgeuse *)BU_PTBL_GET(eu2_list, eu2_index);
					NMG_CK_EDGEUSE(eu2);

					if( eu2->g.lseg_p != is->on_eg )  continue;
					/*
					 *  eu2 is from fu2.
					 *  Perform intersection.
					 *  New edgeuses are added to lists.
					 */
					(void)nmg_isect_2colinear_edge2p( eu1, eu2,
						fu1, is, eu1_list, eu2_list);
				}

				/* For the case where only 1 face is involved */
				nmg_enlist_vu(is, eu1->vu_p, 0, MAX_FASTF );
				nmg_enlist_vu(is, BU_LIST_PNEXT_CIRC(edgeuse, eu1)->vu_p, 0, MAX_FASTF );
			}
			continue;
#else
			fastf_t  dist;
			point_t pca;
			struct edgeuse *eu_end;
			struct vertex_g *vg;
			plane_t pl1,pl2;

colinear:
			if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
				bu_log("\tThis edge_geom generated the line.  Enlisting.\n");
			}

			NMG_GET_FU_PLANE( pl1, is->fu1 );
			NMG_GET_FU_PLANE( pl2, is->fu2 );
			for( eu1_index=0; eu1_index < BU_PTBL_END(eu1_list); eu1_index++ )
			{
				eu1 = (struct edgeuse *)BU_PTBL_GET(eu1_list, eu1_index);
				NMG_CK_EDGEUSE(eu1);
				if( eu1->g.lseg_p != is->on_eg )  continue;
				/* eu1 is from fu1 */

				vg = eu1->vu_p->v_p->vg_p;
				NMG_CK_VERTEX_G( vg );
				(void)rt_dist_pt3_line3( &dist, pca, is->pt, is->dir, vg->coord, &(is->tol) );
				if( dist <= is->tol.dist )
				{
					/* vertex is on intersection line */

					if( DIST_PT_PLANE( vg->coord, pl2 ) <= is->tol.dist )
					{
						/* and in plane of fu2 */
						if( nmg_class_pt_fu_except( vg->coord, fu2, (struct loopuse *)NULL, NULL, NULL, (char *)NULL, 0, 0, &(is->tol) ) != NMG_CLASS_AoutB )
						{
							/* and within fu2 */
							dist = VDIST( is->pt, vg->coord );
							nmg_enlist_vu( is, eu1->vu_p, 0, dist );
						}
					}
				}
				eu_end = BU_LIST_PNEXT_CIRC( edgeuse, &eu1->l );
				vg = eu_end->vu_p->v_p->vg_p;
				NMG_CK_VERTEX_G( vg );
				code = rt_dist_pt3_line3( &dist, pca, is->pt, is->dir, eu_end->vu_p->v_p->vg_p->coord, &(is->tol) );
				if( dist <= is->tol.dist )
				{
					/* vertex is on intersection line */

					if( DIST_PT_PLANE( vg->coord, pl2 ) <= is->tol.dist )
					{
						/* and in plane of fu2 */
						if( nmg_class_pt_fu_except( vg->coord, fu2, (struct loopuse *)NULL, NULL, NULL, (char *)NULL, 0, 0, &(is->tol) ) != NMG_CLASS_AoutB )
						{
							/* and within fu2 */
							dist = VDIST( is->pt, vg->coord );
							nmg_enlist_vu( is, eu_end->vu_p, 0, dist );
						}
					}
				}
			}

			for( eu2_index=0; eu2_index < BU_PTBL_END(eu2_list); eu2_index++ )
			{
				eu2 = (struct edgeuse *)BU_PTBL_GET(eu2_list, eu2_index);
				NMG_CK_EDGEUSE(eu2);

				if( eu2->g.lseg_p != is->on_eg )  continue;
				/*  eu2 is from fu2 */

				vg = eu2->vu_p->v_p->vg_p;
				NMG_CK_VERTEX_G( vg );
				code = rt_dist_pt3_line3( &dist, pca, is->pt, is->dir, vg->coord, &(is->tol) );
				if( dist <= is->tol.dist )
				{
					/* vertex is on intersection line */

					if( DIST_PT_PLANE( vg->coord, pl1 ) <= is->tol.dist )
					{
						/* and in plane of fu1 */
						if( nmg_class_pt_fu_except( vg->coord, fu1, (struct loopuse *)NULL, NULL, NULL, (char *)NULL, 0, 0, &(is->tol) ) != NMG_CLASS_AoutB )
						{
							/* and within fu1 */
							dist = VDIST( is->pt, vg->coord );
							nmg_enlist_vu( is, eu2->vu_p, 0, dist );
						}
					}
				}
				eu_end = BU_LIST_PNEXT_CIRC( edgeuse, &eu2->l );
				vg = eu_end->vu_p->v_p->vg_p;
				NMG_CK_VERTEX_G( vg );
				code = rt_dist_pt3_line3( &dist, pca, is->pt, is->dir, eu_end->vu_p->v_p->vg_p->coord, &(is->tol) );
				if( dist <= is->tol.dist )
				{
					/* vertex is on intersection line */

					if( DIST_PT_PLANE( vg->coord, pl1 ) <= is->tol.dist )
					{
						/* and in plane of fu1 */
						if( nmg_class_pt_fu_except( vg->coord, fu1, (struct loopuse *)NULL, NULL, NULL, (char *)NULL, 0, 0, &(is->tol) ) != NMG_CLASS_AoutB )
						{
							/* and within fu1 */
							dist = VDIST( is->pt, vg->coord );
							nmg_enlist_vu( is, eu_end->vu_p, 0, dist );
						}
					}
				}
			}
			continue;
#endif
		}

		/*
		 *  eg1 is now known to be NOT colinear with on_eg.
		 *  From here on, only 0 or 1 points of intersection are possible.
		 */

		/*  The 3D line in is->pt and is->dir is prepared by our caller. */
		MAT4X3PNT( eg_pt2d, is->proj, (*eg1)->e_pt );
		MAT4X3VEC( eg_dir2d, is->proj, (*eg1)->e_dir );

		/* Calculate 2D geometric intersection, but don't look at answer yet */
		dist[0] = dist[1] = -INFINITY;
		code = bn_isect_line2_line2( dist, is->pt2d, is->dir2d,
			eg_pt2d, eg_dir2d, &(is->tol) );

		/* Do this check before topology search */
		if( code == 0 )  {
			/* Geometry says lines are colinear.  Egads!  This can't be! */
			if( is->on_eg )  {
				bu_log("nmg_isect_line2_face2pNEW() edge_g not shared, geometry says lines are colinear.\n");
				goto fixup;
			}
			/* on_eg wasn't set, use it and continue on */
			if( rt_g.NMG_debug & DEBUG_POLYSECT )
				bu_log("NOTICE: setting on_eg to eg1 and continuing with colinear case.\n");
			is->on_eg = (*eg1);
			goto colinear;
		}

		/* Double check */
		if( is->on_eg && bn_2line3_colinear(
		    (*eg1)->e_pt, (*eg1)->e_dir,
		    is->on_eg->e_pt, is->on_eg->e_dir, 1e5, &(is->tol) ) )  {
fixup:
			nmg_pr_eg(&(*eg1)->l.magic, 0);
			nmg_pr_eg(&is->on_eg->l.magic, 0);
			bu_log("nmg_isect_line2_face2pNEW() eg1 colinear to on_eg?\n");
#if 0
		    	/* XXX See if this helps. */
		    	nmg_model_fuse( nmg_find_model(&fu1->l.magic), &(is->tol) );
			rt_bomb("nmg_isect_line2_face2pNEW() eg1 colinear to on_eg?\n");
#else
		    	/* fuse eg1 with on_eg, handle as colinear */
		    	bu_log("fusing eg1 with on_eg, handling as colinear\n");
		    	nmg_jeg( is->on_eg, *eg1 );
		    	goto colinear;
#endif
		}

		/* If on_eg was specified, do a search for topology intersection */
		if( is->on_eg && !hit_v )  {
			if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
				bu_log("non-colinear.  Searching for topological intersection between on_eg and eg1\n");
			}
			/* See if any vu along eg1 is used by edge from on_eg */
			hit_v = nmg_common_v_2eg( *eg1, is->on_eg, &(is->tol) );
			/*
			 *  Note that while eg1 contains an eu from fu1,
			 *  the intersection vertex just found may occur
			 *  well outside *either* faceuse, but lie on some
			 *  other face that shares this face geometry.
			 */
			if(hit_v) {
				fastf_t dist1,dist2;
				plane_t	n1, n2;

				if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
					static int num=0;
					char buf[128];
					FILE *fp;
					sprintf(buf, "Itopo%d.pl", num++);
					if( (fp=fopen(buf,"w")) != NULL )  {
						pl_color(fp, 255, 0, 0);
						pdv_3ray( fp, is->on_eg->e_pt, is->on_eg->e_dir, 1.0 );
						pdv_3cont( fp, hit_v->vg_p->coord );
						pl_color(fp, 255,255, 0);
						pdv_3ray( fp, (*eg1)->e_pt, (*eg1)->e_dir, 1.0 );
						pdv_3cont( fp, hit_v->vg_p->coord );
						fclose(fp);
						bu_log("overlay %s red is on_eg, yellow is eg1\n", buf);
					} else perror(buf);
					bu_log("\tTopology intersection.  hit_v=x%x (%g, %g, %g)\n",
						hit_v,
						V3ARGS(hit_v->vg_p->coord) );
				}

				/*
				 *  If the hit point is outside BOTH faces
				 *  bounding RPP, then it can be ignored.
				 *  Otherwise, it is needed for generating
				 *  accurate state transitions in the
				 *  face cutter.
				 */
				if( !V3PT_IN_RPP( hit_v->vg_p->coord, fu1->f_p->min_pt, fu1->f_p->max_pt ) &&
				    !V3PT_IN_RPP( hit_v->vg_p->coord, fu2->f_p->min_pt, fu2->f_p->max_pt )
				)  {
					/* Lines intersect outside bounds of both faces. */
					if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
						VPRINT("\t\tisect pt outside fu1 & fu2 RPP:", hit_v->vg_p->coord );
						bu_log("\t\tfu1 RPP: ( %g %g %g ) <-> ( %g %g %g )\n",
							V3ARGS( fu1->f_p->min_pt ), V3ARGS( fu1->f_p->max_pt ) );
						bu_log("\t\tfu2 RPP: ( %g %g %g ) <-> ( %g %g %g )\n",
							V3ARGS( fu2->f_p->min_pt ), V3ARGS( fu2->f_p->max_pt ) );
					}
					continue;
				}

				/*
				 *  Geometry check.
				 *  Since on_eg is the line of intersection
				 *  between fu1 and fu2, and since eg1
				 *  lies in the plane of fu1,
				 *  and since hit_v lies on eg1
				 *  at the point where eg1 intersects on_eg,
				 *  it's pretty hard to see how hit_v
				 *  could fail to lie in the plane of fu2.
				 *
				 *  However, in BigWedge r1 (m14.r) this
				 *  case occurs:  hit_v is off f2 by -60mm!
				 *  These two fu's don't overlap at all.
				 *
				 *  Rather than letting nmg_ck_v_in_2fus()
				 *  blow it's mind over this, catch it here
				 *  and discard the point.
				 *  (Hopefully the RPP checks above will have
				 *  already discarded it).
				 */
				NMG_GET_FU_PLANE(n1, fu1);
				NMG_GET_FU_PLANE(n2, fu2);
				dist1 = DIST_PT_PLANE( hit_v->vg_p->coord , n1 );
				dist2 = DIST_PT_PLANE( hit_v->vg_p->coord , n2 );

				if( !NEAR_ZERO( dist1 , is->tol.dist ) || !NEAR_ZERO( dist2 , is->tol.dist ) )  {
					continue;
				}
				if( (class=nmg_class_pt_fu_except( hit_v->vg_p->coord, fu1, (struct loopuse *)NULL, NULL, NULL, (char *)NULL, 0, 0, &(is->tol) )) == NMG_CLASS_AoutB )
				{
					if (rt_g.NMG_debug & DEBUG_POLYSECT)
					{
						VPRINT("\t\tisect pt outside face fu1 (nmg_class_pt_fu_except):", hit_v->vg_p->coord );
					}
					continue;
				}
				else if( (class=nmg_class_pt_fu_except( hit_v->vg_p->coord, fu2, (struct loopuse *)NULL, NULL, NULL, (char *)NULL, 0, 0, &(is->tol) )) == NMG_CLASS_AoutB )
				{
					if (rt_g.NMG_debug & DEBUG_POLYSECT)
					{
						VPRINT("\t\tisect pt outside face fu2 (nmg_class_pt_fu_except):", hit_v->vg_p->coord );
					}
					continue;
				}
				/* Ignore further geometry checking, isect is good.
				 * Head right to searching for vertexuses
				 */
				goto force_isect;
			}
		}

		/* Now compare results of topology and geometry calculations */

		if( code < 0 )  {
			/* Geometry says lines are parallel, no intersection */
			if( hit_v )  {
				bu_log("NOTICE: geom/topo mis-match, enlisting topo vu, hit_v=x%x\n", hit_v);
				VPRINT("hit_v", hit_v->vg_p->coord);
				nmg_pr_eg(&(*eg1)->l.magic, 0);
				nmg_pr_eg(&is->on_eg->l.magic, 0);
				bu_log(" dist to eg1=%e, dist to on_eg=%e\n",
					bn_dist_line3_pt3((*eg1)->e_pt, (*eg1)->e_dir, hit_v->vg_p->coord),
					bn_dist_line3_pt3(is->on_eg->e_pt, is->on_eg->e_dir, hit_v->vg_p->coord) );
				VPRINT("is->pt2d ", is->pt2d);
				VPRINT("is->dir2d", is->dir2d);
				VPRINT("eg_pt2d  ", eg_pt2d);
				VPRINT("eg_dir2d ", eg_dir2d);
				bu_log(" 3d line isect, code=%d\n",
					bn_isect_line3_line3( &dist[0], &dist[1],
						is->pt, is->dir,
						(*eg1)->e_pt,
						(*eg1)->e_dir,
						&(is->tol)
					) );
				goto force_isect;
			}
			continue;
		}
		/* Geometry says 2 lines intersect at a point */
		VJOIN1( hit3d, is->pt, dist[0], is->dir );
		if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
			VPRINT("\t2 lines intersect at", hit3d);
		}
#if 1
		if( !V3PT_IN_RPP( hit3d, fu1->f_p->min_pt, fu1->f_p->max_pt ) )  {
			/* Lines intersect outside bounds of this face. */
			if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
				VPRINT("\t\tisect pt outside fu1 face RPP:", hit3d );
				bu_log("\t\tface RPP: ( %g %g %g ) <-> ( %g %g %g )\n",
					V3ARGS( fu1->f_p->min_pt ), V3ARGS( fu1->f_p->max_pt ) );
			}
			continue;
		}

		if( (class=nmg_class_pt_fu_except( hit3d, fu1, (struct loopuse *)NULL, NULL, NULL, (char *)NULL, 0, 0, &(is->tol) )) == NMG_CLASS_AoutB )
		{
			if (rt_g.NMG_debug & DEBUG_POLYSECT)
			{
				VPRINT("\t\tisect pt outside face fu1 (nmg_class_pt_fu_except):", hit3d );
			}
			continue;
		}
		else if( (class=nmg_class_pt_fu_except( hit3d, fu2, (struct loopuse *)NULL, NULL, NULL, (char *)NULL, 0, 0, &(is->tol) )) == NMG_CLASS_AoutB )
		{
			if (rt_g.NMG_debug & DEBUG_POLYSECT)
			{
				VPRINT("\t\tisect pt outside face fu2 (nmg_class_pt_fu_except):", hit3d );
			}
			continue;
		}
		else if(rt_g.NMG_debug & DEBUG_POLYSECT)
		{
			bu_log( "\t\tnmg_class_pt_fu_except(fu1) returns %s\n", nmg_class_name(class) );
		}
#endif
		VJOIN1_2D( hit2d, is->pt2d, dist[0], is->dir2d );

		/* Consistency check between geometry, and hit_v. */
		if( hit_v )  {
force_isect:
			/* Force things to be consistent, use geom from hit_v */
			VMOVE(hit3d, hit_v->vg_p->coord);
			nmg_get_2d_vertex( hit2d, hit_v, is, &fu1->l.magic );
			if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
				bu_log("hit_v=x%x\n", hit_v);
				VPRINT("hit3d", hit3d);
				V2PRINT("hit2d", hit2d);
			}
		}

eu_search:
		/*  Search all eu's on eg1 for vu's to enlist.
		 *  There may be many, and the list may grow.
		 */
		for( eu1_index=0; eu1_index < BU_PTBL_END(eu1_list); eu1_index++ )  {
			struct vertexuse	*vu1a, *vu1b;
			struct vertexuse	*vu1_midpt;
			fastf_t			ldist;
			point_t			eu1_pt2d;	/* 2D */
			point_t			eu1_end2d;	/* 2D */
			double			tmp_dist_sq;

			eu1 = (struct edgeuse *)BU_PTBL_GET(eu1_list, eu1_index);

			/* This EU may have been killed by nmg_repair_v_near_v() */
			if( eu1->l.magic != NMG_EDGEUSE_MAGIC )
				continue;

			NMG_CK_EDGEUSE(eu1);

			if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
				bu_log( "\tChecking eu x%x\n", eu1 );
			}

			if( eu1->g.lseg_p != *eg1 )
			{
				if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
					bu_log( "\t\teg x%x is not eg1=x%x\n", eu1->g.lseg_p, *eg1 );
				}
				continue;
			}
			vu1a = eu1->vu_p;
			vu1b = BU_LIST_PNEXT_CIRC( edgeuse, eu1 )->vu_p;

			/* First, a topology check of both endpoints */
			if( vu1a->v_p == hit_v )  {
hit_a:
				if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
					bu_log("\tlisting intersect point at vu1a=x%x\n", vu1a);
				}
				/* Note that the distance dist[0] may not actually
				 * be the exact distance to vu1a, but it is the distance
				 * to the actual intersection point. This is an
				 * attempt to get the correct ordering of vertices
				 * on the intersection list, since using the
				 * actual distance can get them reversed when
				 * a VU is chosen over the actual interection
				 * point.
				 */
				nmg_enlist_vu(is, vu1a, 0, dist[0]);
			}
			if( vu1b->v_p == hit_v )  {
hit_b:
				if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
					bu_log("\tlisting intersect point at vu1b=x%x\n", vu1b);
				}
				/* see above note about dist[0] */
				nmg_enlist_vu(is, vu1b, 0, dist[0]);
			}
			if( vu1a->v_p == hit_v || vu1b->v_p == hit_v )  continue;

			/*  Second, a geometry check on the edgeuse ENDPOINTS
			 *  -vs- the line segment.  This is 3D, for consistency
			 *  with comparisons elsewhere.
			 */
			tmp_dist_sq = bn_distsq_line3_pt3( is->pt, is->dir, vu1a->v_p->vg_p->coord );
			if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
				bu_log( "\tvu1a is sqrt(%g) from the intersect line\n" , tmp_dist_sq );
			}
			if( tmp_dist_sq <= is->tol.dist_sq  )  {
				if( !hit_v )  {
					if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
						bu_log( "\tnmg_isect_line2_face2pNEW: using nearby vu1a vertex x%x from eu x%x\n", vu1a->v_p, eu1 );
					}
					hit_v = vu1a->v_p;
					goto hit_a;
				}
				if( hit_v == vu1a->v_p )  goto hit_a;
#if 0
				nmg_repair_v_near_v( hit_v, vu1a->v_p,
					is->on_eg, *eg1, 1, &(is->tol) );
				bu_ptbl_free( &eg_list);
				goto re_tabulate;
#else
				/* Fall through to bn_isect_pt2_lseg2() */
#endif
			}
			tmp_dist_sq = bn_distsq_line3_pt3( is->pt, is->dir, vu1b->v_p->vg_p->coord );
			if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
				bu_log( "\tvu1b is sqrt(%g) from the intersect line\n" , tmp_dist_sq );
			}
			if(tmp_dist_sq <= is->tol.dist_sq )  {
				if( !hit_v )  {
					if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
						bu_log( "\tnmg_isect_line2_face2pNEW: using nearby vu1b vertex x%x from eu x%x\n", vu1b->v_p, eu1 );
					}
					hit_v = vu1b->v_p;
					goto hit_b;
				}
				if( hit_v == vu1b->v_p )  goto hit_b;
#if 0
				nmg_repair_v_near_v( hit_v, vu1b->v_p,
					is->on_eg, *eg1, 1, &(is->tol) );
				bu_ptbl_free( &eg_list);
				goto re_tabulate;
#else
				/* Fall through to bn_isect_pt2_lseg2() */
#endif
			}

			/* Third, a geometry check of the HITPT -vs- the line segment */
			nmg_get_2d_vertex( eu1_pt2d, vu1a->v_p, is, &fu1->l.magic );
			nmg_get_2d_vertex( eu1_end2d, vu1b->v_p, is, &fu1->l.magic );
			ldist = 0;
			code = bn_isect_pt2_lseg2( &ldist, eu1_pt2d, eu1_end2d, hit2d, &(is->tol) );
			if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
				bu_log("\tbn_isect_pt2_lseg2() returned %d, ldist=%g\n", code, ldist);
			}
			switch(code)  {
			case -2:
				continue;	/* outside lseg AB pts */
			default:
			case -1:
				continue;	/* Point not on lseg */
			case 1:
				/* Point is at A (vu1a) by geometry */
				if( hit_v && hit_v != vu1a->v_p )  {
					nmg_repair_v_near_v( hit_v, vu1a->v_p,
						is->on_eg, *eg1, 1, &(is->tol) );
					bu_ptbl_free( &eg_list);
					goto re_tabulate;
				}
				hit_v = vu1a->v_p;
				if (rt_g.NMG_debug & DEBUG_POLYSECT) bu_log("\thit_v = x%x (vu1a)\n", hit_v);
				goto hit_a;
			case 2:
				/* Point is at B (vu1b) by geometry */
				if( hit_v && hit_v != vu1b->v_p )  {
					nmg_repair_v_near_v( hit_v, vu1b->v_p,
						is->on_eg, *eg1, 1, &(is->tol) );
					bu_ptbl_free( &eg_list);
					goto re_tabulate;
				}
				hit_v = vu1b->v_p;
				if (rt_g.NMG_debug & DEBUG_POLYSECT) bu_log("\thit_v = x%x (vu1b)\n", hit_v);
				goto hit_b;
			case 3:
				/* Point hits the line segment amidships!  Split edge!
				 * If we don't have a hit vertex yet,
				 * search for one in whole model.
				 */
				if( !hit_v )  {
					hit_v = nmg_find_pt_in_model(fu1->s_p->r_p->m_p,
						hit3d, &(is->tol));
					if( hit_v == vu1a->v_p || hit_v == vu1b->v_p )
						rt_bomb("About to make 0-length edge!\n");
				}
				new_eu = nmg_ebreaker(hit_v, eu1, &is->tol);
				bu_ptbl_ins_unique( eu1_list, &new_eu->l.magic );
				/* "eu1" must now be considered invalid */
				vu1_midpt = new_eu->vu_p;
				if( !hit_v )  {
					hit_v = vu1_midpt->v_p;
					nmg_vertex_gv( hit_v, hit3d );
					if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
						bu_log("\tmaking new vertex vu=x%x hit_v=x%x\n",
							vu1_midpt, hit_v);
					}
					/*  Before we loose track of the fact
					 *  that this vertex lies on *both*
					 *  lines, break any edges in the
					 *  intersection line that cross it.
					 */
					if( is->on_eg )  {
						nmg_break_eg_on_v( is->on_eg,
							hit_v, &(is->tol) );
					}
				} else {
					if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
						bu_log("\tre-using hit_v=x%x, vu=x%x\n", hit_v, vu1_midpt);
					}
					if( hit_v != vu1_midpt->v_p )  rt_bomb("hit_v changed?\n");
				}
				if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
					bu_log( "Faceuses after nmg_ebreaker() call\n") ;
					bu_log( "fu1:\n" );
					nmg_pr_fu_briefly( fu1 , "\t" );
					bu_log( "fu2:\n" );
					nmg_pr_fu_briefly( fu2 , "\t" );
				}
				nmg_enlist_vu(is, vu1_midpt, 0, dist[0]);
				/* Neither old nor new edgeuse need further handling */
				/* Because "eu1" is now invalid, restart loop. */
				goto eu_search;
			}
		}
	}

	/* Don't forget to do self loops with no edges */
	for( BU_LIST_FOR( lu1, loopuse, &fu1->lu_hd ) )  {
		struct vertexuse	*vu1;

		if( BU_LIST_FIRST_MAGIC( &lu1->down_hd ) != NMG_VERTEXUSE_MAGIC )  continue;

		/* Intersect line with lone vertex vu1 */
		vu1 = BU_LIST_FIRST( vertexuse, &lu1->down_hd );
		NMG_CK_VERTEXUSE(vu1);

		/* Needs to be a 3D comparison */
		if( bn_distsq_line3_pt3( is->pt, is->dir,
		      vu1->v_p->vg_p->coord ) > is->tol.dist_sq )
			continue;

		if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
			bu_log("\tself-loop vu=x%x lies on line of intersection\n", vu1 );
		}

		/* Break all edgeuses in the model on line on_eg, at vu1 */
		if( is->on_eg )  {
			nmg_break_eg_on_v( is->on_eg, vu1->v_p, &(is->tol) );
			nmg_enlist_vu(is, vu1, 0, MAX_FASTF );
		}

#if 1
		/* This can probably be removed */
		/* recent OLD WAY: */
		/*  To prevent an OT_BOOLPLACE from being overlooked,
		 *  break *both* sets of eu's
		 */

		/* Break all edges from fu1 list */
		for( eu1_index=0; eu1_index < BU_PTBL_END(eu1_list); eu1_index++ )  {
			eu1 = (struct edgeuse *)BU_PTBL_GET(eu1_list, eu1_index);

			/* This EU may have been killed by nmg_repair_v_near_v() */
			if( eu1->l.magic != NMG_EDGEUSE_MAGIC )
				continue;

			NMG_CK_EDGEUSE(eu1);
			if( eu1->g.lseg_p != is->on_eg )  continue;
			/* eu1 is from fu1 and on the intersection line */
			new_eu = nmg_break_eu_on_v( eu1, vu1->v_p, fu1, is );
			if( !new_eu )  continue;
			bu_ptbl_ins_unique( eu1_list, &new_eu->l.magic );
			nmg_enlist_vu(is, new_eu->vu_p, 0, MAX_FASTF );
		}

		/* Break all edges from fu2 list */
		for( eu2_index=0; eu2_index < BU_PTBL_END(eu2_list); eu2_index++ )  {
			eu2 = (struct edgeuse *)BU_PTBL_GET(eu2_list, eu2_index);

			/* This EU may have been killed by nmg_repair_v_near_v() */
			if( eu2->l.magic != NMG_EDGEUSE_MAGIC )
				continue;

			NMG_CK_EDGEUSE(eu2);
			if( eu2->g.lseg_p != is->on_eg )  continue;
			/* eu2 is from fu2 and on the intersection line */
			new_eu = nmg_break_eu_on_v( eu2, vu1->v_p, fu1, is );
			if( !new_eu )  continue;
			bu_ptbl_ins_unique( eu2_list, &new_eu->l.magic );
			nmg_enlist_vu(is, new_eu->vu_p, 0, MAX_FASTF );
		}
#endif
	}

	bu_ptbl_free( &eg_list);
}

/* XXX move to nmg_info.c */
/*
 *			N M G _ I S _ E U _ O N _ L I N E 3
 */
int
nmg_is_eu_on_line3(const struct edgeuse *eu, const fastf_t *pt, const fastf_t *dir, const struct bn_tol *tol)
{
	struct edge_g_lseg	*eg;

	NMG_CK_EDGEUSE(eu);
	BN_CK_TOL(tol);

	eg = eu->g.lseg_p;
	NMG_CK_EDGE_G_LSEG(eg);

	/* Ensure direction vectors are generally parallel */
	/* These are not unit vectors */
	/* tol->para and RT_DOT_TOL are too tight a tolerance.  0.1 is 5 degrees */
	if( fabs(VDOT(eg->e_dir, dir)) <
	    0.9 * MAGNITUDE(eg->e_dir) * MAGNITUDE(dir)  )  return 0;

	/* Ensure that vertices on edge are within tol of line */
	if( bn_distsq_line3_pt3( eg->e_pt, eg->e_dir,
	    eu->vu_p->v_p->vg_p->coord ) > tol->dist_sq )  return 0;
	if( bn_distsq_line3_pt3( eg->e_pt, eg->e_dir,
	    eu->eumate_p->vu_p->v_p->vg_p->coord ) > tol->dist_sq )  return 0;

	return 1;
}

/* XXX Move to nmg_info.c */
/*
 *			N M G _ F I N D _ E G _ B E T W E E N _ 2 F G
 *
 *  Perform a topology search to determine if two face geometries (specified
 *  by their faceuses) share an edge geometry in common.
 *  The edge_g is returned, even if there are no existing uses of it
 *  in *either* fu1 or fu2.  It still represents the intersection line
 *  between the two face geometries, found topologically.
 *
 *  If there are multiple edgeuses in common, ensure that they all refer
 *  to the same edge_g geometry structure.  The intersection of two planes
 *  (non-coplanar) must be a single line.
 *
 *  Calling this routine when the two faces share face geometry
 *  is illegal.
 *
 *  NULL is returned if no common edge geometry could be found.
 */
struct edge_g_lseg *
nmg_find_eg_between_2fg(const struct faceuse *ofu1, const struct faceuse *fu2, const struct bn_tol *tol)
{
	const struct faceuse	*fu1;
	const struct loopuse	*lu1;
	const struct face_g_plane	*fg1;
	const struct face_g_plane	*fg2;
	const struct face	*f1;
	struct edgeuse		*ret = (struct edgeuse *)NULL;
	int			coincident;

	NMG_CK_FACEUSE(ofu1);
	NMG_CK_FACEUSE(fu2);
	BN_CK_TOL(tol);

	fg1 = ofu1->f_p->g.plane_p;
	fg2 = fu2->f_p->g.plane_p;
	NMG_CK_FACE_G_PLANE(fg1);
	NMG_CK_FACE_G_PLANE(fg2);

	if( fg1 == fg2 )  rt_bomb("nmg_find_eg_between_2fg() face_g_plane shared, infinitely many results\n");

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		nmg_pr_fus_in_fg( &fg1->magic );
		nmg_pr_fus_in_fg( &fg2->magic );
	}

	/* For all faces using fg1 */
	for( BU_LIST_FOR( f1, face, &fg1->f_hd ) )  {
		NMG_CK_FACE(f1);

		/* Arbitrarily pick one of the two fu's using f1 */
		fu1 = f1->fu_p;
		NMG_CK_FACEUSE(fu1);

		for( BU_LIST_FOR( lu1, loopuse, &fu1->lu_hd ) )  {
			const struct edgeuse	*eu1;
			NMG_CK_LOOPUSE(lu1);
			if( BU_LIST_FIRST_MAGIC(&lu1->down_hd) == NMG_VERTEXUSE_MAGIC )
				continue;
			if (rt_g.NMG_debug & DEBUG_BASIC)  {
				bu_log(" visiting lu1=x%x, fu1=x%x, fg1=x%x\n",
					lu1, fu1, fg1 );
			}
restart:
			for( BU_LIST_FOR( eu1, edgeuse, &lu1->down_hd ) )  {
				struct edgeuse *eur;

				NMG_CK_EDGEUSE(eu1);
				/* Walk radially around the edge */
				for(
				    eur = eu1->radial_p;
				    eur != eu1->eumate_p;
				    eur = eur->eumate_p->radial_p
				)  {
					const struct faceuse	*tfu;

					if (*eur->up.magic_p != NMG_LOOPUSE_MAGIC ) continue;
					if( *eur->up.lu_p->up.magic_p != NMG_FACEUSE_MAGIC )  continue;
					tfu = eur->up.lu_p->up.fu_p;
					if( tfu->f_p->g.plane_p != fg2 )  continue;
					NMG_CK_EDGE_G_EITHER( eur->g.lseg_p );

				    	/* Found the other face on this edge! */
					if (rt_g.NMG_debug & DEBUG_BASIC)  {
						bu_log(" Found shared edge, eur=x%x, eg=x%x\n", eur, eur->g.lseg_p );
						nmg_pr_eu_briefly( eur, (char *)NULL );
						nmg_pr_eu_briefly( eur->eumate_p, (char *)NULL );
			    			nmg_pr_eg( eur->g.magic_p, 0 );
						nmg_pr_fu_around_eu( eur, tol );
					}

				    	if( !ret )  {
				    		/* First common edge found */
						if (rt_g.NMG_debug & DEBUG_BASIC)  {
							nmg_pl_lu_around_eu(eur);
						}
				    		ret = eur;
				    		continue;
				    	}

			    		/* Previous edge found, check edge_g */
			    		if( eur->g.lseg_p == ret->g.lseg_p )  continue;

					/* Edge geometry differs. vu's same? */
					if( NMG_ARE_EUS_ADJACENT(eur, ret) )  {
						if (rt_g.NMG_debug & DEBUG_BASIC)  {
							bu_log("nmg_find_eg_between_2fg() joining edges eur=x%x, ret=x%x\n",
								eur, ret );
						}
						nmg_radial_join_eu(ret, eur, tol);
						goto restart;
					}

					/* This condition "shouldn't happen" */
		    			bu_log("eur=x%x, eg_p=x%x;  ret=x%x, eg_p=x%x\n",
		    				eur, eur->g.lseg_p,
		    				ret, ret->g.lseg_p);
		    			nmg_pr_eg( eur->g.magic_p, 0 );
		    			nmg_pr_eg( ret->g.magic_p, 0 );
		    			nmg_pr_eu_endpoints( eur, 0 );
		    			nmg_pr_eu_endpoints( ret, 0 );

					coincident = nmg_2edgeuse_g_coincident( eur, ret, tol );
					if( coincident )  {
						/* Change eur to use ret's eg */
						bu_log("nmg_find_eg_between_2fg() belatedly fusing e1=x%x, eg1=x%x, e2=x%x, eg2=x%x\n",
							eur->e_p, eur->g.lseg_p,
							ret->e_p, ret->g.lseg_p );
						nmg_jeg( ret->g.lseg_p, eur->g.lseg_p );
						/* See if there are any others. */
						nmg_model_fuse( nmg_find_model(&eur->l.magic), tol );
					} else {
			    			rt_bomb("nmg_find_eg_between_2fg() 2 faces intersect with differing edge geometries?\n");
					}
					goto restart;
				}
			}
		}
	}
	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_find_eg_between_2fg(fu1=x%x, fu2=x%x) edge_g=x%x\n",
			ofu1, fu2, ret ? ret->g.lseg_p : 0);
	}
	if( ret )
		return ret->g.lseg_p;
	return (struct edge_g_lseg *)NULL;
}

/* XXX Move to nmg_info.c */
/*
 *			N M G _ D O E S _ F U _ U S E _ E G
 *
 *  See if any edgeuse in the given faceuse
 *  lies on the indicated edge geometry (edge_g).
 *  This is a topology check only.
 *
 *  Returns -
 *	NULL	No
 *	eu	Yes, here is one edgeuse that does.  There may be more.
 */
struct edgeuse *
nmg_does_fu_use_eg(const struct faceuse *fu1, const long int *eg)
{
	const struct loopuse	*lu1;
	register struct edgeuse	*eu1;

	NMG_CK_FACEUSE(fu1);
	NMG_CK_EDGE_G_EITHER(eg);

	for( BU_LIST_FOR( lu1, loopuse, &fu1->lu_hd ) )  {
		NMG_CK_LOOPUSE(lu1);
		if( BU_LIST_FIRST_MAGIC(&lu1->down_hd) == NMG_VERTEXUSE_MAGIC )
			continue;
		if (rt_g.NMG_debug & DEBUG_BASIC)  {
			bu_log(" visiting lu1=x%x, fu1=x%x\n",
				lu1, fu1 );
		}
		for( BU_LIST_FOR( eu1, edgeuse, &lu1->down_hd ) )  {
			if( eu1->g.magic_p == eg )  goto out;
		}
	}
	eu1 = (struct edgeuse *)NULL;
out:
	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_does_fu_use_eg(fu1=x%x, eg=x%x) eu1=x%x\n",
			fu1, eg, eu1 );
	}
	return eu1;
}

/* XXX move to plane.c */
/*
 *			R T _ L I N E _ O N _ P L A N E
 *
 *  Returns -
 *	1	line is on plane, within tol
 *	0	line does not lie on the plane
 */
int
rt_line_on_plane(const fastf_t *pt, const fastf_t *dir, const fastf_t *plane, const struct bn_tol *tol)
{
	vect_t	unitdir;
	fastf_t	dist;

	BN_CK_TOL(tol);

	dist = DIST_PT_PLANE( pt, plane );
	if( !NEAR_ZERO( dist, tol->dist ) )  return 0;

	VMOVE( unitdir, dir );
	VUNITIZE( unitdir );
/* XXX This is *way* too tight TOO_STRICT */
	if( fabs(VDOT(unitdir, plane)) >= tol->para )  {
		/* Vectors are parallel */
		/* ray parallel to plane, and point is on it */
		return 1;
	}
	return 0;
}

/*
 *			N M G _ I S E C T _ T W O _ F A C E 3 P
 *
 *  Handle the complete mutual intersection of
 *  two 3-D non-coplanar planar faces,
 *  including cutjoin and meshing.
 *
 *  The line of intersection has already been computed.
 *  Handle as two 2-D line/face intersection problems
 *
 *  This is the HEART of the intersection code.
 */
static void
nmg_isect_two_face3p(struct nmg_inter_struct *is, struct faceuse *fu1, struct faceuse *fu2)
{
	struct bu_ptbl vert_list1, vert_list2;
	struct bu_ptbl		eu1_list;	/* all eu's in fu1 */
	struct bu_ptbl		eu2_list;	/* all eu's in fu2 */
	fastf_t			*mag1=(fastf_t *)NULL;
	fastf_t			*mag2=(fastf_t *)NULL;
	int			i;

	NMG_CK_INTER_STRUCT(is);
	NMG_CK_FACEUSE(fu1);
	NMG_CK_FACEUSE(fu2);

	if (rt_g.NMG_debug & DEBUG_POLYSECT) {
		bu_log("nmg_isect_two_face3p( fu1=x%x, fu2=x%x )  START12\n", fu1, fu2);
		VPRINT("isect ray is->pt ", is->pt);
		VPRINT("isect ray is->dir", is->dir);
	}

	if( rt_g.NMG_debug & DEBUG_VERIFY )  {
		nmg_vfu( &fu1->s_p->fu_hd, fu1->s_p );
		nmg_vfu( &fu2->s_p->fu_hd, fu2->s_p );
		nmg_fu_touchingloops(fu1);
		nmg_fu_touchingloops(fu2);
	}

	/* Verify that line is within tolerance of both planes */
#if TOO_STRICT
	NMG_GET_FU_PLANE(n1, fu1);
	if( !rt_line_on_plane( is->pt, is->dir, n1, &(is->tol) ) )
		bu_log("WARNING: intersect line not on plane of fu1\n");
	NMG_GET_FU_PLANE(n2, fu2);
	if( !rt_line_on_plane( is->pt, is->dir, n2, &(is->tol) ) )
		bu_log("WARNING: intersect line not on plane of fu2\n");
#endif

    	if (rt_g.NMG_debug & (DEBUG_POLYSECT|DEBUG_FCUT|DEBUG_MESH)
    	    && rt_g.NMG_debug & DEBUG_PLOTEM) {
    	    	nmg_pl_2fu( "Iface%d.pl", 0, fu1, fu2, 0 );
    	}
#if 0
	/* Topology search */
	/* See if 2 faces share an edge already.  If so, get edge_geom line */
	if( (is->on_eg = nmg_find_eg_between_2fg(fu1, fu2, &(is->tol))) )  {
		NMG_CK_EDGE_G_LSEG(is->on_eg);
#if TOO_STRICT
		/* Verify that this edge_g is with tol of both planes */
		if( !rt_line_on_plane( is->on_eg->e_pt, is->on_eg->e_dir, n1, &(is->tol) ) )  {
			bu_log("WARNING: shared on_eg not on plane of fu1, omitting.\n");
			is->on_eg = NULL;
		} else if( !rt_line_on_plane( is->on_eg->e_pt, is->on_eg->e_dir, n2, &(is->tol) ) )  {
			bu_log("WARNING: shared on_eg not on plane of fu2, omitting.\n");
			is->on_eg = NULL;
		}
#endif
		/*
		 *  There is a topological edge_g in common between
		 *  the two face geometries.
		 *  The intersection still needs to be done, because
		 *  there might be partial sharing due to the fuser,
		 *  but a full intersection may not have been performed
		 *  on both faceuses yet.
		 */
		/* Check angle first */
	    	VMOVE( unit_e_dir, is->on_eg->e_dir );
	    	VUNITIZE( unit_e_dir );
	    	dot = VDOT(is->dir, unit_e_dir);
		if( fabs(dot) < is->tol.para &&	/* not parallel */
		    !bn_2line3_colinear(
		    is->pt, is->dir,
		    is->on_eg->e_pt, unit_e_dir, 1000.0, &(is->tol) ) )  {
		    	ang = acos(fabs(dot));
			bu_log("WARNING nmg_isect_two_face3p() is->pt and on_eg lines differ by %g deg. (shared topo)\n",
				ang * bn_radtodeg );
		}
		/* Take geometry from the known shared edge is->on_eg */
		nmg_isect_construct_nice_ray( is, fu2 );
	}
	if( !is->on_eg )  {
		/* Geometry search */
		if( !(is->on_eg = nmg_find_eg_on_line( &fu1->l.magic, is->pt, is->dir, &(is->tol) ) ) )  {
			is->on_eg = nmg_find_eg_on_line( &fu2->l.magic, is->pt, is->dir, &(is->tol) );
		}
		if( is->on_eg )  {
			/* Check angle */
		    	VMOVE( unit_e_dir, is->on_eg->e_dir );
		    	VUNITIZE( unit_e_dir );
		    	dot = VDOT(is->dir, unit_e_dir);
			if( fabs(dot) < is->tol.para &&	/* not parallel */
			    !bn_2line3_colinear(
			    is->pt, is->dir,
			    is->on_eg->e_pt, unit_e_dir, 1000.0, &(is->tol) ) )  {
			    	ang = acos(fabs(dot));
				bu_log("WARNING nmg_isect_two_face3p() is->pt and on_eg lines differ by %g deg. (geom search)\n",
					ang * bn_radtodeg );
			    	if( ang * bn_radtodeg > 1.0 )  {
					/* Forget about this shared topology */
					bu_log("nmg_isect_two_face3p() line direction mismatch (geom), clearing on_eg.\n");
			    		is->on_eg = (struct edge_g_lseg *)NULL;
			    	}
			}
		}
	}
	if( is->on_eg )  {
		if( rt_g.NMG_debug & DEBUG_POLYSECT) {
			VPRINT("is->on_eg->e_pt ", is->on_eg->e_pt);
			VPRINT("is->on_eg->e_dir", is->on_eg->e_dir);
		}
	}
#endif
	(void)bu_ptbl(&vert_list1, BU_PTBL_INIT,(long *)NULL);
	(void)bu_ptbl(&vert_list2, BU_PTBL_INIT,(long *)NULL);

	/* Build list of all edgeuses in fu1 and fu2 */
	nmg_edgeuse_tabulate( &eu1_list, &fu1->l.magic );
	nmg_edgeuse_tabulate( &eu2_list, &fu2->l.magic );

	is->mag_len = 2 * (BU_PTBL_END( &eu1_list ) + BU_PTBL_END( &eu2_list ) );
	mag1 = (fastf_t *)bu_calloc( is->mag_len, sizeof( fastf_t ), "mag1" );
	mag2 = (fastf_t *)bu_calloc( is->mag_len, sizeof( fastf_t ), "mag2" );

	for( i=0 ; i<is->mag_len ; i++ )
	{
		mag1[i] = MAX_FASTF;
		mag2[i] = MAX_FASTF;
	}


    	is->l1 = &vert_list1;
    	is->l2 = &vert_list2;
	is->s1 = fu1->s_p;
	is->s2 = fu2->s_p;
	is->fu1 = fu1;
	is->fu2 = fu2;
	is->mag1 = mag1;
	is->mag2 = mag2;
#if 0
	/*  Intersect the line with everything in fu1.
	 *  Note any colinear edgeuses in fu2 for potential sharing.
	 */
	nmg_isect_line2_face2pNEW(is, fu1, fu2, &eu1_list, &eu2_list);

	if( rt_g.NMG_debug & DEBUG_VERIFY )  {
		nmg_fu_touchingloops(fu1);
		nmg_fu_touchingloops(fu2);
		nmg_vfu( &fu1->s_p->fu_hd, fu1->s_p );
		nmg_vfu( &fu2->s_p->fu_hd, fu2->s_p );
	}

	/*
	 *  Now intersect the line with the other face.
	 */
    	if (rt_g.NMG_debug & DEBUG_FCUT) {
	    	bu_log("nmg_isect_two_face3p(fu1=x%x, fu2=x%x) vert_lists A:\n", fu1, fu2);
    		nmg_pr_ptbl_vert_list( "vert_list1", &vert_list1, mag1 );
    		nmg_pr_ptbl_vert_list( "vert_list2", &vert_list2, mag2 );
    	}

	if (rt_g.NMG_debug & DEBUG_POLYSECT) {
		bu_log("nmg_isect_two_face3p( fu1=x%x, fu2=x%x )  START21\n", fu1, fu2);
	}
#endif

	/*
	 *  Now do the intersection with the other face.
	 */
    	is->l2 = &vert_list1;
    	is->l1 = &vert_list2;
	is->s2 = fu1->s_p;
	is->s1 = fu2->s_p;
	is->fu2 = fu1;
	is->fu1 = fu2;
	is->mag1 = mag2;
	is->mag2 = mag1;
/*	nmg_isect_line2_face2pNEW(is, fu2, fu1, &eu2_list, &eu1_list); */
	is->on_eg = (struct edge_g_lseg *)NULL;
	nmg_isect_fu_jra(is, fu1, fu2, &eu1_list, &eu2_list);

	if( rt_g.NMG_debug & DEBUG_VERIFY )  {
		nmg_fu_touchingloops(fu1);
		nmg_fu_touchingloops(fu2);
		nmg_vfu( &fu1->s_p->fu_hd, fu1->s_p );
		nmg_vfu( &fu2->s_p->fu_hd, fu2->s_p );
	}
#if 0
	nmg_purge_unwanted_intersection_points(&vert_list1, mag1, fu2, &is->tol);
	nmg_purge_unwanted_intersection_points(&vert_list2, mag2, fu1, &is->tol);
#endif
    	if (rt_g.NMG_debug & DEBUG_FCUT) {
	    	bu_log("nmg_isect_two_face3p(fu1=x%x, fu2=x%x) vert_lists B:\n", fu1, fu2);
    		nmg_pr_ptbl_vert_list( "vert_list1", &vert_list1, mag1 );
    		nmg_pr_ptbl_vert_list( "vert_list2", &vert_list2, mag2 );
    	}

    	if (vert_list1.end == 0 && vert_list2.end == 0) {
    		/* there were no intersections */
    		goto out;
    	}

	if (rt_g.NMG_debug & DEBUG_POLYSECT) {
		bu_log("nmg_isect_two_face3p( fu1=x%x, fu2=x%x )  MIDDLE\n", fu1, fu2);
	}

	is->on_eg = nmg_face_cutjoin(&vert_list1, &vert_list2, mag1, mag2, fu1, fu2, is->pt, is->dir, is->on_eg, &is->tol);

	if( rt_g.NMG_debug & DEBUG_VERIFY )  {
		nmg_fu_touchingloops(fu1);
		nmg_fu_touchingloops(fu2);
		nmg_region_v_unique( fu1->s_p->r_p, &is->tol );
		nmg_region_v_unique( fu2->s_p->r_p, &is->tol );
		nmg_vfu( &fu1->s_p->fu_hd, fu1->s_p );
		nmg_vfu( &fu2->s_p->fu_hd, fu2->s_p );
	}

	nmg_mesh_faces(fu1, fu2, &is->tol);
	if( rt_g.NMG_debug & DEBUG_VERIFY )  {
		nmg_fu_touchingloops(fu1);
		nmg_fu_touchingloops(fu2);
	}

#if 0
	nmg_show_broken_classifier_stuff((long *)fu1, (long **)NULL, 1, 0);
	nmg_show_broken_classifier_stuff((long *)fu2, (long **)NULL, 1, 0);
#endif

out:
	(void)bu_ptbl_free(&vert_list1);
	(void)bu_ptbl_free(&vert_list2);
	(void)bu_ptbl_free(&eu1_list);
	(void)bu_ptbl_free(&eu2_list);
	if( mag1 )
		bu_free( (char *)mag1, "nmg_isect_two_face3p: mag1" );
	if( mag2 )
		bu_free( (char *)mag2, "nmg_isect_two_face3p: mag2" );


	if( rt_g.NMG_debug & DEBUG_VERIFY )  {
		nmg_vfu( &fu1->s_p->fu_hd, fu1->s_p );
		nmg_vfu( &fu2->s_p->fu_hd, fu2->s_p );
	}
	if (rt_g.NMG_debug & DEBUG_POLYSECT) {
		bu_log("nmg_isect_two_face3p( fu1=x%x, fu2=x%x )  END\n", fu1, fu2);
		VPRINT("isect ray is->pt ", is->pt);
		VPRINT("isect ray is->dir", is->dir);
	}
}

void
nmg_cut_lu_into_coplanar_and_non(struct loopuse *lu, fastf_t *pl, struct nmg_inter_struct *is)
{
	struct model *m;
	struct edgeuse *eu;
	struct vertex_g *vg2;
	struct vertex *vcut1,*vcut2;
	struct  bu_ptbl cut_list;
	fastf_t dist,dist2;
	int class1,class2;
	int in=0;
	int on=0;
	int out=0;
	int i;

	if (rt_g.NMG_debug & DEBUG_POLYSECT)
		bu_log( "nmg_cut_lu_into_coplanar_and_non( lu=x%x, pl=%g %g %g %g )\n", lu, V4ARGS( pl ) );

	NMG_CK_LOOPUSE( lu );
	NMG_CK_INTER_STRUCT( is );

	m = nmg_find_model( &is->fu1->l.magic );

	/* check if this loop even needs to be considered */
	if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
		return;

	bu_ptbl_init( &cut_list, 64, " &cut_list");

	eu = BU_LIST_FIRST( edgeuse, &lu->down_hd );
	vg2 = eu->vu_p->v_p->vg_p;
	NMG_CK_VERTEX_G( vg2 );
	dist2 = DIST_PT_PLANE( vg2->coord, pl );
	if( dist2 > is->tol.dist )
	{
		class2 = NMG_CLASS_AoutB;
		out++;
	}
	else if( dist2 < (-is->tol.dist) )
	{
		class2 = NMG_CLASS_AinB;
		in++;
	}
	else
	{
		class2 = NMG_CLASS_AonBshared;
		on++;
	}

	vcut1 = (struct vertex *)NULL;
	for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
	{
		class1 = class2;

		vg2 = eu->eumate_p->vu_p->v_p->vg_p;
		dist2 = DIST_PT_PLANE( vg2->coord, pl );

		if( dist2 > is->tol.dist )
		{
			class2 = NMG_CLASS_AoutB;
			out++;
		}
		else if( dist2 < (-is->tol.dist) )
		{
			class2 = NMG_CLASS_AinB;
			in++;
		}
		else
		{
			class2 = NMG_CLASS_AonBshared;
			on++;
		}

		if( class1 == NMG_CLASS_AonBshared && class2 != class1 )
		{
			if( !vcut1 )
			{
				vcut1 = eu->vu_p->v_p;
			}
			else if( vcut1 != eu->vu_p->v_p )
			{
				bu_ptbl_ins( &cut_list, (long *)vcut1 );
				bu_ptbl_ins( &cut_list, (long *)eu->vu_p->v_p );
				vcut1 = (struct vertex *)NULL;
			}
		}
		else if( class2 == NMG_CLASS_AonBshared && class1 != class2 )
		{
			if( !vcut1 )
			{
				vcut1 = eu->eumate_p->vu_p->v_p;
			}
			else if( vcut1 != eu->eumate_p->vu_p->v_p )
			{
				bu_ptbl_ins( &cut_list, (long *)vcut1 );
				bu_ptbl_ins( &cut_list, (long *)eu->eumate_p->vu_p->v_p );
				vcut1 = (struct vertex *)NULL;
			}
		}
	}

	if (rt_g.NMG_debug & DEBUG_POLYSECT)
	{
		bu_log( "\t pl=( %g %g %g %g )\n", V4ARGS( pl ) );
		bu_log( "\tcut_lists=%d, on=%d, in=%d, out=%d\n", BU_PTBL_END( &cut_list ),on,in,out );
		if( BU_PTBL_END( &cut_list ) )
		{
			bu_log( "\tcut_lists:\n" );
			for( i=0 ; i<BU_PTBL_END( &cut_list ) ; i++ )
			{
				struct vertex *v;

				v = (struct vertex *)BU_PTBL_GET( &cut_list, i );
				bu_log( "\t\t%d, x%x\n", i+1, v );
			}
		}
	}

	if( !on )
		return;

	if( BU_PTBL_END( &cut_list ) < 2 )
	{
		bu_ptbl_free( &cut_list);

		if (rt_g.NMG_debug & DEBUG_POLYSECT)
			bu_log( "No loops need cutting\n" );
		return;
	}

	if( nmg_loop_is_a_crack( lu ) )
	{
		struct bu_ptbl lus;

		if (rt_g.NMG_debug & DEBUG_POLYSECT)
			bu_log( "Loop is a crack\n" );

		i = 0;
		while( i < BU_PTBL_END( &cut_list ) )
		{
			struct vertexuse *vu;

			vcut1 = (struct vertex *)BU_PTBL_GET( &cut_list, i );
			for( BU_LIST_FOR( vu, vertexuse, &vcut1->vu_hd ) )
			{
				if( nmg_find_lu_of_vu( vu ) != lu )
					continue;

				eu = vu->up.eu_p;
				if( NMG_ARE_EUS_ADJACENT( eu, BU_LIST_PNEXT_CIRC( edgeuse, &eu->l ) ) )
				{
					i--;
					bu_ptbl_rm( &cut_list, (long *)vcut1 );
				}
				else if( NMG_ARE_EUS_ADJACENT( eu, BU_LIST_PPREV_CIRC( edgeuse, &eu->l ) ) )
				{
					i--;
					bu_ptbl_rm( &cut_list, (long *)vcut1 );
				}
			}
			i++;
		}

		if( BU_PTBL_END( &cut_list ) == 0 )
		{
			bu_ptbl_free( &cut_list);

			if (rt_g.NMG_debug & DEBUG_POLYSECT)
				bu_log( "no loops need cutting\n" );
			return;
		}

		bu_ptbl_init( &lus, 64, " &lus");
		bu_ptbl_ins( &lus, (long *)lu );
		for( i=0 ; i<BU_PTBL_END( &cut_list ) ; i++ )
		{
			int j;

			vcut1 = (struct vertex *)BU_PTBL_GET( &cut_list, i );

			for( j=0 ; j<BU_PTBL_END( &lus ) ; j++ )
			{
				int did_split=0;
				struct loopuse *lu1;
				struct vertexuse *vu1;
				struct loopuse *new_lu;

				lu1 = (struct loopuse *)BU_PTBL_GET( &lus, j );

				for( BU_LIST_FOR( vu1, vertexuse, &vcut1->vu_hd ) )
				{
					if( nmg_find_lu_of_vu( vu1 ) == lu1 )
					{
						if (rt_g.NMG_debug & DEBUG_POLYSECT)
							bu_log( "Splitting lu x%x at vu x%x\n", lu1, vu1 );
						new_lu = nmg_split_lu_at_vu( lu1, vu1 );
						nmg_lu_reorient( lu1 );
						nmg_lu_reorient( new_lu );
						nmg_loop_g( new_lu->l_p, &is->tol );
						nmg_loop_g( lu1->l_p, &is->tol );
						bu_ptbl_ins( &lus, (long *)new_lu );
						did_split = 1;
						break;
					}
				}
				if( did_split )
					break;
			}
		}
		bu_ptbl_free( &lus);
		bu_ptbl_free( &cut_list);
		return;
	}

	if( BU_PTBL_END( &cut_list )%2 )
	{
		bu_log( "Uneven number (%d) of vertices on cut list\n" , BU_PTBL_END( &cut_list ) );
		rt_bomb( "Uneven number of vertices on cut list" );
	}

	/* Sort vertices on cut list into some order */
	if( BU_PTBL_END( &cut_list ) > 2 )
	{
		struct vertex *v1=(struct vertex *)NULL;
		struct vertex *v2=(struct vertex *)NULL;
		struct vertex *end1 = NULL, *end2 = NULL;
		fastf_t max_dist = 0.0;
		vect_t diff;
		fastf_t *dist_array;
		int done;

		/* find longest distance between two vertices */
		for( i=0 ; i<BU_PTBL_END( &cut_list ) ; i++ )
		{
			int j;

			v1 = (struct vertex *)BU_PTBL_GET( &cut_list, i );

			for( j=i ; j<BU_PTBL_END( &cut_list ) ; j++ )
			{
				fastf_t tmp_dist;

				v2 = (struct vertex *)BU_PTBL_GET( &cut_list, j );
				VSUB2( diff, v1->vg_p->coord, v2->vg_p->coord )
				tmp_dist = MAGSQ( diff );
				if( tmp_dist > max_dist )
				{
					max_dist = tmp_dist;
					end1 = v1;
					end2 = v2;
				}
			}
		}
		if( !end1 || !end2 )
		{
			bu_log( "nmg_cut_lu_into_coplanar_and_non: Cannot find endpoints\n" );
			rt_bomb( "nmg_cut_lu_into_coplanar_and_non: Cannot find endpoints\n" );
		}

		/* create array of distances (SQ) along the line from end1 to end2 */
		dist_array = (fastf_t *)bu_calloc( sizeof( fastf_t ), BU_PTBL_END( &cut_list ), "distance array" );
		for( i=0 ; i<BU_PTBL_END( &cut_list ) ; i++ )
		{
			v1 = (struct vertex *)BU_PTBL_GET( &cut_list, i );
			if( v1 == end1 )
			{
				dist_array[i] = 0.0;
				continue;
			}
			if( v1 == end2 )
			{
				dist_array[i] = max_dist;
				continue;
			}

			VSUB2( diff, v1->vg_p->coord, end1->vg_p->coord )
			dist_array[i] = MAGSQ( diff );
		}

		/* sort vertices according to distance array */
		done = 0;
		while( !done )
		{
			fastf_t tmp_dist;
			long *tmp_v;

			done = 1;
			for( i=1 ; i<BU_PTBL_END( &cut_list ) ; i++ )
			{
				if( dist_array[i-1] <= dist_array[i] )
					continue;

				/* swap distances in array */
				tmp_dist = dist_array[i];
				dist_array[i] = dist_array[i-1];
				dist_array[i-1] = tmp_dist;

				/* swap vertices */
				tmp_v = cut_list.buffer[i];
				cut_list.buffer[i] = cut_list.buffer[i-1];
				cut_list.buffer[i-1] = tmp_v;

				done = 0;
			}
		}

		if (rt_g.NMG_debug & DEBUG_POLYSECT)
		{
			bu_log( "After sorting:\n" );
			for( i=0 ; i<BU_PTBL_END( &cut_list ) ; i++ )
				bu_log( "v=x%x, dist=%g\n", BU_PTBL_GET( &cut_list, i ), dist_array[i] );
		}

		bu_free( (char *)dist_array, "distance array" );
	}

	for( i=0 ; i<BU_PTBL_END( &cut_list ) ; i += 2 )
	{
		struct loopuse *lu1;
		struct vertexuse *vu;
		vect_t dir;
		point_t hit_pt;
		struct vertex *hit_v;
		struct vertexuse *hit_vu;
		struct edgeuse *new_eu;
		fastf_t len;
		fastf_t inv_len;
		int skip=0;

		vcut1 = (struct vertex *)BU_PTBL_GET( &cut_list, i );
		vcut2 = (struct vertex *)BU_PTBL_GET( &cut_list, i+1 );

		if( vcut1 == vcut2 )
			continue;

		/* make sure these are not the ends of an edge of lu */
		for( BU_LIST_FOR( vu, vertexuse, &vcut1->vu_hd ) )
		{
			if( nmg_find_lu_of_vu( vu ) != lu )
				continue;

			eu = vu->up.eu_p;
			if( eu->eumate_p->vu_p->v_p == vcut2 )
			{
				/* already an edge here */
				skip = 1;
				break;
			}
		}
		if( skip )
			continue;

		/* need to cut face along line from vcut1 to vcut2 */
		VMOVE( is->pt, vcut1->vg_p->coord );
		VSUB2( dir, vcut2->vg_p->coord, vcut1->vg_p->coord );
		len = MAGNITUDE( dir );
		if( len <= is->tol.dist )
			continue;

		inv_len = 1.0/len;
		VSCALE( is->dir, dir, inv_len );

		/* add vertexuses to intersect list */
		bu_ptbl_reset( is->l1);

		/* add uses of vcut1 */
		for( BU_LIST_FOR( vu, vertexuse, &vcut1->vu_hd ) )
		{
			if( nmg_find_fu_of_vu( vu ) == is->fu1 )
				nmg_enlist_one_vu( is, vu, 0.0 );
		}

		/* add uses of vcut2 */
		for( BU_LIST_FOR( vu, vertexuse, &vcut2->vu_hd ) )
		{
			if( nmg_find_fu_of_vu( vu ) == is->fu1 )
				nmg_enlist_one_vu( is, vu, len );
		}

		/* look for other edges that may intersect this line */
		for( BU_LIST_FOR( lu1, loopuse, &is->fu1->lu_hd ) )
		{
			struct edgeuse *eu1;

			NMG_CK_LOOPUSE( lu1 );

			if( BU_LIST_FIRST_MAGIC( &lu1->down_hd ) != NMG_EDGEUSE_MAGIC )
				continue;

			for( BU_LIST_FOR( eu1, edgeuse, &lu1->down_hd ) )
			{
				int code;
				fastf_t dists[2];
				vect_t dir2;

				NMG_CK_EDGEUSE( eu1 );

				VSUB2( dir2, eu1->eumate_p->vu_p->v_p->vg_p->coord, eu1->vu_p->v_p->vg_p->coord );
				code = bn_isect_lseg3_lseg3( dists, is->pt, dir,
					eu1->vu_p->v_p->vg_p->coord, dir2, &is->tol );
				if( code < 0 )
					continue;

				if( code == 0 )
				{
					if( dists[0] > 0.0 && dists[0] < 1.0 )
					{
						dist = dists[0]*len;
						for( BU_LIST_FOR( vu, vertexuse, &eu1->vu_p->v_p->vu_hd ) )
						{
							if( nmg_find_fu_of_vu( vu ) == is->fu1 )
								nmg_enlist_one_vu( is, vu, dist );
						}
					}
					if( dists[1] > 0.0 && dists[1] < 1.0 )
					{
						dist = dists[1]*len;
						for( BU_LIST_FOR( vu, vertexuse, &eu1->eumate_p->vu_p->v_p->vu_hd ) )
						{
							if( nmg_find_fu_of_vu( vu ) == is->fu1 )
								nmg_enlist_one_vu( is, vu, len );
						}
					}
					continue;
				}

				/* normal intersection, may need to split eu1 */
				if( dists[0] <= 0.0 || dists[0] >= 1.0 )
					continue;

				if( dists[1] <= 0.0 || dists[1] >= 1.0 )
					continue;

				VJOIN1( hit_pt, is->pt, dists[0], dir );
				hit_vu = (struct vertexuse *)NULL;
				hit_v = (struct vertex *)NULL;

				hit_vu = nmg_find_pt_in_face( is->fu1, hit_pt, &is->tol );
				if( hit_vu )
					hit_v = hit_vu->v_p;

				if( !hit_v )
					hit_v = nmg_find_pt_in_model( m, hit_pt, &is->tol );
				new_eu = nmg_esplit( hit_v, eu1, 1 );
				hit_v = new_eu->vu_p->v_p;
				if( !hit_v->vg_p )
					nmg_vertex_gv( hit_v, hit_pt );

				/* add uses of hit_v to intersection list */
				dist = dists[0]*len;
				for( BU_LIST_FOR( vu, vertexuse, &hit_v->vu_hd ) )
				{
					if( nmg_find_fu_of_vu( vu ) == is->fu1 )
						nmg_enlist_one_vu( is, vu, dist );
				}
			}
		}

		if (rt_g.NMG_debug & DEBUG_POLYSECT)
			bu_log( "nmg_cut_lu_into_coplanar_and_non: calling face cutter\n" );
		bu_ptbl_reset( is->l2);
		(void)nmg_face_cutjoin( is->l1, is->l2, is->mag1, is->mag2, is->fu1,
			is->fu2, is->pt, is->dir, is->on_eg, &is->tol);

		vcut1 = (struct vertex *)NULL;
		vcut2 = (struct vertex *)NULL;
	}

	bu_ptbl_free( &cut_list);
}

static void
nmg_isect_coplanar_edges(struct nmg_inter_struct *is, struct bu_ptbl *eu1_list, struct bu_ptbl *eu2_list)
{
	struct model *m;
	struct loopuse *lu;
	struct bu_ptbl v_list;
	int i,j;
	plane_t pl1,pl2;

	if (rt_g.NMG_debug & DEBUG_POLYSECT)
		bu_log( "nmg_isect_coplanar_edges START\n" );

	NMG_CK_INTER_STRUCT( is );
	BU_CK_PTBL( eu1_list );
	BU_CK_PTBL( eu2_list );

	m = nmg_find_model( &is->fu1->l.magic );

	NMG_GET_FU_PLANE( pl1, is->fu1 );
	NMG_GET_FU_PLANE( pl2, is->fu2 );

	if (rt_g.NMG_debug & DEBUG_POLYSECT)
	{
		bu_log( "pl1 = %g %g %g %g\n", V4ARGS( pl1 ) );
		bu_log( "pl2 = %g %g %g %g\n", V4ARGS( pl2 ) );
	}

	/* First split all edgeuses that intersect */
	for( i=0 ; i<BU_PTBL_END( eu1_list ) ; i++ )
	{
		struct edgeuse *eu1;
		double len_vt1;
		vect_t vt1;
		struct vertex_g *vg1a,*vg1b;

		eu1 = (struct edgeuse *)BU_PTBL_GET( eu1_list, i );
		NMG_CK_EDGEUSE( eu1 );

		vg1a = eu1->vu_p->v_p->vg_p;
		NMG_CK_VERTEX_G( vg1a );
		vg1b = eu1->eumate_p->vu_p->v_p->vg_p;
		NMG_CK_VERTEX_G( vg1b );

		if (rt_g.NMG_debug & DEBUG_POLYSECT)
			bu_log( "Considering EU x%x (%g %g %g) <-> (%g %g %g)\n",
				eu1, V3ARGS( vg1a->coord ), V3ARGS( vg1b->coord ) );

#if 0
		/* only consider edges in the plane of the other face */
		if( !NEAR_ZERO( DIST_PT_PLANE( vg1a->coord, pl2 ), is->tol.dist ) )
		{
			if (rt_g.NMG_debug & DEBUG_POLYSECT)
				bu_log( "\tvg1a is not in other plane (%g)\n", DIST_PT_PLANE( vg1a->coord, pl2 ) );
			continue;
		}
		if( !NEAR_ZERO( DIST_PT_PLANE( vg1b->coord, pl2 ), is->tol.dist ) )
		{
			if (rt_g.NMG_debug & DEBUG_POLYSECT)
				bu_log( "\tvg1b is not in other plane (%g)\n", DIST_PT_PLANE( vg1b->coord, pl2 ) );
			continue;
		}
#endif

		VSUB2( vt1, vg1b->coord, vg1a->coord );
		len_vt1 = MAGNITUDE( vt1 );
		VSCALE( vt1, vt1, 1.0/len_vt1 );

		for( j=0 ; j<BU_PTBL_END( eu2_list ) ; j++ )
		{
			struct edgeuse *eu2;
			struct vertex_g *vg2a,*vg2b;
			int code;
			vect_t vt2;
			double len_vt2;
			fastf_t dist[2];
			point_t hit_pt;
			int hit_no;
			int hit_count;
			struct vertex *hitv;
			struct vertexuse *hit_vu;

			eu2 = (struct edgeuse *)BU_PTBL_GET( eu2_list, j );
			NMG_CK_EDGEUSE( eu2 );

			if (rt_g.NMG_debug & DEBUG_POLYSECT)
				bu_log( "\tConsidering EU2 x%x (%g %g %g) <-> (%g %g %g)\n",
					eu2, V3ARGS( eu2->vu_p->v_p->vg_p->coord ), V3ARGS( eu2->eumate_p->vu_p->v_p->vg_p->coord ) );
#if 0
			/* only consider edges in the plane of the other face */
			if( !NEAR_ZERO( DIST_PT_PLANE( eu2->vu_p->v_p->vg_p->coord, pl1 ), is->tol.dist ) )
			{
				if (rt_g.NMG_debug & DEBUG_POLYSECT)
					bu_log( "\t\tEU2 start pt not in other plane (%g)\n",
						DIST_PT_PLANE( eu2->vu_p->v_p->vg_p->coord, pl1 ) );
				continue;
			}
			if( !NEAR_ZERO( DIST_PT_PLANE( eu2->eumate_p->vu_p->v_p->vg_p->coord, pl1 ), is->tol.dist ) )
			{
				if (rt_g.NMG_debug & DEBUG_POLYSECT)
					bu_log( "\t\tEU2 end pt not in other plane (%g)\n",
						DIST_PT_PLANE( eu2->eumate_p->vu_p->v_p->vg_p->coord, pl1 ) );
				continue;
			}
#endif

			/* if these edges are radial, nothing to do */
			if( eu1->vu_p->v_p == eu2->vu_p->v_p &&
				eu1->eumate_p->vu_p->v_p == eu2->eumate_p->vu_p->v_p )
					continue;

			if( eu1->vu_p->v_p == eu2->eumate_p->vu_p->v_p &&
				eu1->eumate_p->vu_p->v_p == eu2->vu_p->v_p )
					continue;

			vg2a = eu2->vu_p->v_p->vg_p;
			NMG_CK_VERTEX_G( vg2a );
			vg2b = eu2->eumate_p->vu_p->v_p->vg_p;
			NMG_CK_VERTEX_G( vg2b );
			VSUB2( vt2, vg2b->coord, vg2a->coord  );
			len_vt2 = MAGNITUDE( vt2 );
			VSCALE( vt2, vt2, 1.0/len_vt2 );

			code = rt_dist_line3_line3( dist, vg1a->coord, vt1,
				vg2a->coord, vt2, &is->tol );

			if (rt_g.NMG_debug & DEBUG_POLYSECT)
				bu_log( "\tcode = %d\n", code );

			if( code == (-2) || code == 1 )
				continue;

			if( code == (-1) )
			{
				fastf_t tmp;
				vect_t tmp_vect;
				fastf_t dist1[2];

				hit_count = 0;

				/* lines are colinear */
				VSUB2( tmp_vect, vg2a->coord, vg1a->coord );
				dist1[0] = VDOT( tmp_vect, vt1 );
				if( NEAR_ZERO( dist1[0], is->tol.dist ) )
					dist1[0] = 0.0;
				else if( NEAR_ZERO( dist1[0] - len_vt1, is->tol.dist ) )
					dist1[0] = len_vt1;
				VSUB2( tmp_vect, vg2b->coord, vg1a->coord );
				dist1[1] = VDOT( tmp_vect, vt1 );
				if( NEAR_ZERO( dist1[1], is->tol.dist ) )
					dist1[1] = 0.0;
				else if( NEAR_ZERO( dist1[1] - len_vt1, is->tol.dist ) )
					dist1[1] = len_vt1;

				if( (dist1[0] >= 0.0 && dist1[0] <= len_vt1 ) )
				{
					dist[hit_count] = dist1[0];
					hit_count++;
				}
				if ( (dist1[1] >= 0.0 && dist1[1] <= len_vt1 ) )
				{
					dist[hit_count] = dist1[1];
					hit_count++;
				}

				if( hit_count == 0 )
					continue;

				if( hit_count == 2 && dist[0] < dist[1] )
				{
					tmp = dist[0];
					dist[0] = dist[1];
					dist[1] = tmp;
				}
			}
			else
			{
				if( NEAR_ZERO( dist[0], is->tol.dist ) )
					dist[0] = 0.0;
				else if( NEAR_ZERO( dist[0] - len_vt1, is->tol.dist ) )
					dist[0] = len_vt1;
				if( NEAR_ZERO( dist[1], is->tol.dist ) )
					dist[1] = 0.0;
				else if( NEAR_ZERO( dist[1] - len_vt2, is->tol.dist ) )
					dist[1] = len_vt2;
				if( dist[0] < 0.0 || dist[0] > len_vt1 )
					continue;
				if( dist[1] < 0.0 || dist[1] > len_vt2 )
					continue;
				hit_count = 1;
			}

			for( hit_no=0 ; hit_no < hit_count ; hit_no++ )
			{
				struct edgeuse *new_eu;

				if (rt_g.NMG_debug & DEBUG_POLYSECT)
					bu_log( "\tdist[%d] = %g\n", hit_no, dist[hit_no] );

				hitv = (struct vertex *)NULL;
				hit_vu = (struct vertexuse *)NULL;

				if( dist[hit_no] == 0.0 )
				{
					hit_vu = eu1->vu_p;
					hitv = hit_vu->v_p;
					VMOVE( hit_pt, hitv->vg_p->coord );
				}
				else if( dist[hit_no] == len_vt1 )
				{
					hit_vu = eu1->eumate_p->vu_p;
					hitv = hit_vu->v_p;
					VMOVE( hit_pt, hitv->vg_p->coord );
				}
				else
					VJOIN1( hit_pt, vg1a->coord , dist[hit_no], vt1 )

				if (rt_g.NMG_debug & DEBUG_POLYSECT)
					bu_log( "eus x%x and x%x intersect #%d at (%g %g %g)\n",
						eu1, eu2, hit_no, V3ARGS( hit_pt ) );

				if( !hit_vu )
					hit_vu = nmg_find_pt_in_face( is->fu2, hit_pt, &is->tol );

				if( !hit_vu )
					hitv = nmg_find_pt_in_model( nmg_find_model( &is->fu1->l.magic ), hit_pt, &is->tol );
				else
					hitv = hit_vu->v_p;

				if (rt_g.NMG_debug & DEBUG_POLYSECT && hitv)
					bu_log( "Found vertex (x%x) at hit_pt\n", hitv );

				if( hitv != eu1->vu_p->v_p && hitv != eu1->eumate_p->vu_p->v_p )
				{
					if (rt_g.NMG_debug & DEBUG_POLYSECT)
						bu_log( "Splitting eu1 x%x\n", eu1 );
					new_eu = nmg_esplit( hitv, eu1, 1 );
					hitv = new_eu->vu_p->v_p;
					if( !hitv->vg_p )
						nmg_vertex_gv( hitv, hit_pt );
					vg1b = eu1->eumate_p->vu_p->v_p->vg_p;
					VSUB2( vt1, vg1b->coord, vg1a->coord );
					len_vt1 = MAGNITUDE( vt1 );
					VSCALE( vt1, vt1, 1.0/len_vt1 );
					bu_ptbl_ins( eu1_list, (long *)new_eu );
				}
				if( code == 0 && hitv != eu2->vu_p->v_p && hitv != eu2->eumate_p->vu_p->v_p )
				{
					if (rt_g.NMG_debug & DEBUG_POLYSECT)
						bu_log( "Splitting eu2 x%x at hitv = x%x\n",  eu2, hitv );
					new_eu = nmg_esplit( hitv, eu2, 1 );
					hitv = new_eu->vu_p->v_p;
					if( !hitv->vg_p )
						nmg_vertex_gv( hitv, hit_pt );
					bu_ptbl_ins( eu2_list, (long *)new_eu );
				}

				if( hitv )
					(void)nmg_break_all_es_on_v( &m->magic, hitv, &is->tol );
			}
		}
	}

	bu_ptbl_free( eu1_list);
	bu_ptbl_free( eu2_list);

	/* Make sure every vertex in fu1 has dual in fu2
	 * (if they overlap)
	 */
	nmg_vertex_tabulate( &v_list, &is->fu1->l.magic );

	for( i=0 ; i<BU_PTBL_END( &v_list ) ; i++ )
	{
		struct vertex *v;
		int class;

		v = (struct vertex *)BU_PTBL_GET( &v_list, i );
		NMG_CK_VERTEX( v );

		if( nmg_find_v_in_face( v, is->fu2 ) )
			continue;

		/* Check if this vertex is within other FU */
		if( !NEAR_ZERO( DIST_PT_PLANE( v->vg_p->coord, pl2 ), is->tol.dist ) )
			continue;

		class = nmg_class_pt_fu_except( v->vg_p->coord, is->fu2, NULL, NULL, NULL,
			(char *)NULL, 0, 0, &is->tol );

		if( class == NMG_CLASS_AinB )
		{
			if (rt_g.NMG_debug & DEBUG_POLYSECT)
				bu_log( "Making dualvu of vertex x%x in is->fu2 x%x\n", v, is->fu2 );
			(void)nmg_make_dualvu( v, is->fu2, &is->tol );
		}
	}
	bu_ptbl_reset( &v_list);

	/* same for fu2  */
	nmg_vertex_tabulate( &v_list, &is->fu2->l.magic );

	for( i=0 ; i<BU_PTBL_END( &v_list ) ; i++ )
	{
		struct vertex *v;
		int class;

		v = (struct vertex *)BU_PTBL_GET( &v_list, i );
		NMG_CK_VERTEX( v );

		if( nmg_find_v_in_face( v, is->fu1 ) )
			continue;

		/* Check if this vertex is within other FU */
		if( !NEAR_ZERO( DIST_PT_PLANE( v->vg_p->coord, pl1 ), is->tol.dist ) )
			continue;

		class = nmg_class_pt_fu_except( v->vg_p->coord, is->fu1, NULL, NULL, NULL,
			(char *)NULL, 0, 0, &is->tol );

		if( class == NMG_CLASS_AinB )
		{
			if (rt_g.NMG_debug & DEBUG_POLYSECT)
				bu_log( "Making dualvu of vertex x%x in fu1 x%x\n", v, is->fu1 );
			(void)nmg_make_dualvu( v, is->fu1, &is->tol );
		}
	}

	bu_ptbl_free( &v_list);

	bu_ptbl_reset( is->l1);
	bu_ptbl_reset( is->l2);

	for( BU_LIST_FOR( lu, loopuse, &is->fu1->lu_hd ) )
	{
		struct edgeuse *eu;

		NMG_CK_LOOPUSE( lu );

		if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
			continue;

		for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
		{
			struct vertexuse *vu;
			struct vertex *v1,*v2;

			NMG_CK_EDGEUSE( eu );

			v1 = eu->vu_p->v_p;
			NMG_CK_VERTEX( v1 );
			v2 = eu->eumate_p->vu_p->v_p;
			NMG_CK_VERTEX( v2 );

			if( !NEAR_ZERO( DIST_PT_PLANE( v1->vg_p->coord, pl2), is->tol.dist ) )
				continue;
			if( !NEAR_ZERO( DIST_PT_PLANE( v2->vg_p->coord, pl2), is->tol.dist ) )
				continue;

			if( !nmg_find_v_in_face( v1, is->fu2 ) ||
				!nmg_find_v_in_face( v2, is->fu2 ) )
				continue;

			if (rt_g.NMG_debug & DEBUG_POLYSECT)
				bu_log( "Making EU x%x an intersect line for face cutting\n", eu );

			for( BU_LIST_FOR( vu, vertexuse, &v1->vu_hd ) )
			{
				struct faceuse *fu;

				fu = nmg_find_fu_of_vu( vu );

				if( fu == is->fu2 )
					nmg_enlist_one_vu( is, vu, 0.0 );
			}

			for( BU_LIST_FOR( vu, vertexuse, &v2->vu_hd ) )
			{
				struct faceuse *fu;

				fu = nmg_find_fu_of_vu( vu );

				if( fu == is->fu2 )
					nmg_enlist_one_vu( is, vu, 1.0 );
			}

			/* Now do face cutting */
			if (rt_g.NMG_debug & DEBUG_POLYSECT)
				bu_log( "Calling face cutter for fu2 x%x\n", is->fu2 );
			nmg_fcut_face_2d( is->l2, is->mag2, is->fu2, is->fu1, &is->tol );

			bu_ptbl_reset( is->l1);
			bu_ptbl_reset( is->l2);
		}
	}

	for( BU_LIST_FOR( lu, loopuse, &is->fu2->lu_hd ) )
	{
		struct edgeuse *eu;

		NMG_CK_LOOPUSE( lu );

		if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
			continue;

		for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
		{
			struct vertexuse *vu;
			struct vertex *v1,*v2;

			NMG_CK_EDGEUSE( eu );

			v1 = eu->vu_p->v_p;
			NMG_CK_VERTEX( v1 );
			v2 = eu->eumate_p->vu_p->v_p;
			NMG_CK_VERTEX( v2 );

			if( !NEAR_ZERO( DIST_PT_PLANE( v1->vg_p->coord, pl1), is->tol.dist ) )
				continue;
			if( !NEAR_ZERO( DIST_PT_PLANE( v2->vg_p->coord, pl1), is->tol.dist ) )
				continue;

			if( !nmg_find_v_in_face( v1, is->fu1 ) ||
				!nmg_find_v_in_face( v2, is->fu1 ) )
				continue;

			if (rt_g.NMG_debug & DEBUG_POLYSECT)
				bu_log( "Making EU x%x an intersect line for face cutting\n", eu );

			for( BU_LIST_FOR( vu, vertexuse, &v1->vu_hd ) )
			{
				struct faceuse *fu;

				fu = nmg_find_fu_of_vu( vu );

				if( fu == is->fu1 )
					nmg_enlist_one_vu( is, vu, 0.0 );
			}

			for( BU_LIST_FOR( vu, vertexuse, &v2->vu_hd ) )
			{
				struct faceuse *fu;

				fu = nmg_find_fu_of_vu( vu );

				if( fu == is->fu1 )
					nmg_enlist_one_vu( is, vu, 1.0 );
			}

			/* Now do face cutting */
			if (rt_g.NMG_debug & DEBUG_POLYSECT)
				bu_log( "Calling face cutter for fu1 x%x\n", is->fu1 );
			nmg_fcut_face_2d( is->l1, is->mag1, is->fu1, is->fu2, &is->tol );

			bu_ptbl_reset( is->l1);
			bu_ptbl_reset( is->l2);
		}
	}
}

#if 0
static void
jra_save_fu_data( fu1, fu2, pl1, pl2 )
struct faceuse *fu1,*fu2;
plane_t pl1,pl2;
{
	NMG_CK_FACEUSE( fu1 );
	NMG_CK_FACEUSE( fu2 );

	bu_log( "STARTDATA\n" );
	bu_log( "%f %f %f %f\n", V4ARGS( pl1 ) );
	bu_log( "%f %f %f %f\n", V4ARGS( pl2 ) );
	nmg_pr_fu_briefly( fu1, "" );
	nmg_pr_fu_briefly( fu2, "" );
	bu_log( "ENDDATA\n" );
}
#endif
#define MAX_FACES	200
void
nmg_check_radial_angles(char *str, struct shell *s, const struct bn_tol *tol)
{
	struct bu_ptbl edges;
	vect_t xvec,yvec,zvec;
	int i,j;
	double angle[MAX_FACES];
	struct faceuse *fus[MAX_FACES];
	int face_count;
	int increasing;

	NMG_CK_SHELL( s );
	BN_CK_TOL( tol );

	bu_ptbl_init( &edges, 64, " &edges");
	nmg_edge_tabulate( &edges, &s->l.magic );

	for( i=0 ; i<BU_PTBL_END( &edges ) ; i++ )
	{
		struct edge *e;
		struct edgeuse *eu_start;
		struct edgeuse *eu;
		struct faceuse *fu;
		int start;

		e = (struct edge *)BU_PTBL_GET( &edges,  i );
		NMG_CK_EDGE( e );

		eu_start = e->eu_p;
		NMG_CK_EDGEUSE( eu_start );

		eu = eu_start;
		do
		{
			fu = nmg_find_fu_of_eu( eu );
		} while( !fu && eu != eu_start );

		if( !fu )
			continue;

		eu_start = eu;
		if( nmg_find_eu_leftvec( xvec, eu ) )
			rt_bomb( "nmg_check_radial_angles() eu not part of a face!!" );

		VSUB2( zvec, eu->eumate_p->vu_p->v_p->vg_p->coord, eu->vu_p->v_p->vg_p->coord );
		VUNITIZE( zvec );
		VCROSS( yvec, zvec, xvec );

		face_count = 0;

		eu = eu_start;
		do
		{
			fu = nmg_find_fu_of_eu( eu );
			if( fu )
			{
				if( face_count >= MAX_FACES )
				{
					bu_log( "Too many faces in nmg_check_radial_angles (%d)\n", face_count );
					rt_bomb( "Too many faces in nmg_check_radial_angles\n" );
				}
				angle[face_count] = nmg_measure_fu_angle( eu, xvec, yvec, zvec );
				fus[face_count] = fu;
				face_count++;
			}
			eu = eu->eumate_p->radial_p;
		} while( eu != eu_start );

		/* list of angles should be monotonically increasing or decreasing */
		increasing =  (-1);
		start = 1;
		for( j=2 ; j<=face_count ; j++ )
		{
			if( angle[j] == 0.0 || angle[j] == bn_twopi )
				continue;
			if( angle[j] == angle[j-1] )
				continue;
			else if( angle[j] > angle[j-1] )
			{
				start = j;
				increasing = 1;
				break;
			}
			else
			{
				start = j;
				increasing = 0;
				break;
			}
		}

		if( increasing == (-1 ) )
			continue;

		for( j=start+1 ; j<face_count ; j++ )
		{
			if( (increasing && angle[j] < angle[j-1]) ||
			    (!increasing && angle[j] > angle[j-1]) )
			{
				bu_log( str );
				bu_log( "nmg_check_radial_angles(): angles not monotonically increasing or decreasing\n" );
				bu_log( "start=%d, increasing = %d\n", start, increasing );
				bu_log( "\tfaces around eu x%x\n", eu_start );
				for( j=0 ; j<face_count ; j++ )
					bu_log( "\t\tfu=x%x, angle=%g\n", fus[j], angle[j]*180.0/bn_pi );
				rt_bomb( "nmg_check_radial_angles(): angles not monotonically increasing or decreasing\n" );
			}
		}
	}
	bu_ptbl_free( &edges);
}

/*			N M G _ I S E C T _ N E A R L Y _ C O P L A N A R _ F A C E S
 *
 *	The two faceuses passed are expected to be parallel and distinct or coplanar
 *	according to bn_isect_2planes(). Also, some (but not all) of the vertices in
 *	one faceuse are within tolerance of the other faceuse. This case is singled
 *	out in nmg_isect_two_generic_faces().
 *
 *	The algorithm is:
 *		1. split any edges that pass from beyond tolerance on one side
 *		   of the other faceuse to beyond tolerance on the other side.
 *		2. cut all loops in each faceuse such that the resulting loops are
 *		   either entirely within tolerance of the other faceuse, or share
 *		   only one "line of intersection" with the other faceuse.
 *		3. intersect coplanar loops same as done in nmg_isect_two_face2p_jra().	
 */
static void
nmg_isect_nearly_coplanar_faces(struct nmg_inter_struct *is, struct faceuse *fu1, struct faceuse *fu2)
{
	int i;
	struct model *m;
	struct edgeuse *eu;
	struct loopuse *lu;
	struct bu_ptbl loops;
	plane_t pl1;
	plane_t pl2;
	fastf_t *mag1,*mag2;
	struct bu_ptbl eu1_list;
	struct bu_ptbl vert_list1;
	struct bu_ptbl eu2_list;
	struct bu_ptbl vert_list2;
	struct bu_ptbl verts;

	NMG_CK_FACEUSE( fu1 );
	NMG_CK_FACEUSE( fu2 );
	NMG_CK_INTER_STRUCT(is);

	if (rt_g.NMG_debug & DEBUG_POLYSECT)
		bu_log( "nmg_isect_nearly_coplanar_faces( fu1=x%x, fu2=x%x )\n", fu1, fu2 );

	m = nmg_find_model( &fu1->l.magic );
	NMG_CK_MODEL( m );

	NMG_GET_FU_PLANE( pl1, fu1 );
	NMG_GET_FU_PLANE( pl2, fu2 );

#if 0
	jra_save_fu_data( fu1, fu2, pl1, pl2 );
#endif

	nmg_edgeuse_tabulate( &eu1_list, &fu1->l.magic );
	nmg_edgeuse_tabulate( &eu2_list, &fu2->l.magic );

	is->mag_len = 2 * (BU_PTBL_END( &eu1_list ) + BU_PTBL_END( &eu2_list ) );
	mag1 = (fastf_t *)bu_calloc( is->mag_len, sizeof( fastf_t ), "mag1" );
	mag2 = (fastf_t *)bu_calloc( is->mag_len, sizeof( fastf_t ), "mag2" );

	for( i=0 ; i<is->mag_len ; i++ )
	{
		mag1[i] = MAX_FASTF;
		mag2[i] = MAX_FASTF;
	}

	bu_ptbl_init( &vert_list1, 64, " &vert_list1");
	bu_ptbl_init( &vert_list2, 64, " &vert_list2");

	is->s1 = fu1->s_p;
	is->s2 = fu2->s_p;
	is->fu1 = fu1;
	is->fu2 = fu2;
	is->l1 = &vert_list1;
	is->l2 = &vert_list2;
	is->mag1 = mag1;
	is->mag2 = mag2;
	is->on_eg = (struct edge_g_lseg *)NULL;

	/* split any edges that pass through the plane of the other faceuse */
	for( BU_LIST_FOR( lu, loopuse, &fu1->lu_hd ) )
	{
		NMG_CK_LOOPUSE( lu );
		if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
			continue;

		for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
		{
			int code;
			int class1,class2;
			fastf_t dist;
			struct vertex_g *vg1,*vg2;
			vect_t dir;
			point_t hit_pt;
			struct vertexuse *hit_vu;
			struct vertex *hit_v=(struct vertex *)NULL;
			struct edgeuse *new_eu;

			NMG_CK_EDGEUSE( eu );

			vg1 = eu->vu_p->v_p->vg_p;
			vg2 = eu->eumate_p->vu_p->v_p->vg_p;

			dist = DIST_PT_PLANE( vg1->coord, pl2 );
			if( dist > is->tol.dist )
				class1 = NMG_CLASS_AoutB;
			else if( dist < (-is->tol.dist ) )
				class1 = NMG_CLASS_AinB;
			else
				class1 = NMG_CLASS_AonBshared;

			dist = DIST_PT_PLANE( vg2->coord, pl2 );
			if( dist > is->tol.dist )
				class2 = NMG_CLASS_AoutB;
			else if( dist < (-is->tol.dist ) )
				class2 = NMG_CLASS_AinB;
			else
				class2 = NMG_CLASS_AonBshared;

			if( class1 == class2 )
				continue;

			if( class1 == NMG_CLASS_AonBshared || class2 == NMG_CLASS_AonBshared )
				continue;

			/* need to split this edge at plane pl2 */
			VSUB2( dir, vg2->coord, vg1->coord )

			code = bn_isect_line3_plane( &dist, vg1->coord, dir, pl2, &is->tol );
			if( code < 1 )
			{
				bu_log( "nmg_isect_nearly_coplanar_faces: EU (x%x) goes from %s to %s\n",
					eu, nmg_class_name( class1 ), nmg_class_name( class2 ) );
				bu_log( "But bn_isect_line3_plane() returns %d\n", code );
				bu_log( "pl2 = ( %g %g %g %g )\n", V4ARGS( pl2 ) );
				nmg_pr_lu_briefly( lu, "" );
				rt_bomb( "nmg_isect_nearly_coplanar_faces: BAD EU" );
			}

			if( dist <= 0.0 || dist >= 1.0 )
			{
				bu_log( "nmg_isect_nearly_coplanar_faces: EU (x%x) goes from %s to %s\n",
					eu, nmg_class_name( class1 ), nmg_class_name( class2 ) );
				bu_log( "But bn_isect_line3_plane() returns %d and dist=%g\n", code, dist );
				bu_log( "pl2 = ( %g %g %g %g )\n", V4ARGS( pl2 ) );
				nmg_pr_lu_briefly( lu, "" );
				rt_bomb( "nmg_isect_nearly_coplanar_faces: BAD EU" );
			}
				
			VJOIN1( hit_pt, vg1->coord, dist, dir );

			hit_vu = nmg_find_pt_in_face( fu2, hit_pt, &is->tol );
			if( !hit_vu )
				hit_v = nmg_find_pt_in_model( m, hit_pt, &is->tol );
			else
				hit_v = hit_vu->v_p;

			new_eu = nmg_esplit( hit_v, eu, 1 );
			hit_v = new_eu->vu_p->v_p;
			if( !hit_v->vg_p )
				nmg_vertex_gv( hit_v, hit_pt );

			if (rt_g.NMG_debug & DEBUG_POLYSECT)
			{
				bu_log( "nmg_cut_lu_into_coplanar_and_non:\n" );
				bu_log( "\tsplitting eu x%x at v=x%x (%g %g %g)\n",
					eu, hit_v, V3ARGS( hit_v->vg_p->coord ) );
			}

		}
	}

	/* get a list of all the loops in this faceuse */
	bu_ptbl_init( &loops, 64, " &loops");
	for( BU_LIST_FOR( lu, loopuse, &fu1->lu_hd ) )
		bu_ptbl( &loops,  BU_PTBL_INS, (long *)lu );

	/* cut each loop so that every loop ends up either entirely on the other
	 * face, or with only a "line of intersection" in common
	 */
	for( i=0 ; i<BU_PTBL_END( &loops ) ; i++ )
	{
		lu = (struct loopuse *)BU_PTBL_GET( &loops, i );
		NMG_CK_LOOPUSE( lu );

		nmg_cut_lu_into_coplanar_and_non( lu, pl2, is );
	}

	/* same for fu2 */
	for( BU_LIST_FOR( lu, loopuse, &fu2->lu_hd ) )
	{
		NMG_CK_LOOPUSE( lu );
		if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
			continue;

		for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
		{
			int code;
			int class1,class2;
			fastf_t dist;
			struct vertex_g *vg1,*vg2;
			vect_t dir;
			point_t hit_pt;
			struct vertexuse *hit_vu;
			struct vertex *hit_v=(struct vertex *)NULL;
			struct edgeuse *new_eu;

			NMG_CK_EDGEUSE( eu );

			vg1 = eu->vu_p->v_p->vg_p;
			vg2 = eu->eumate_p->vu_p->v_p->vg_p;

			dist = DIST_PT_PLANE( vg1->coord, pl1 );
			if( dist > is->tol.dist )
				class1 = NMG_CLASS_AoutB;
			else if( dist < (-is->tol.dist ) )
				class1 = NMG_CLASS_AinB;
			else
				class1 = NMG_CLASS_AonBshared;

			dist = DIST_PT_PLANE( vg2->coord, pl1 );
			if( dist > is->tol.dist )
				class2 = NMG_CLASS_AoutB;
			else if( dist < (-is->tol.dist ) )
				class2 = NMG_CLASS_AinB;
			else
				class2 = NMG_CLASS_AonBshared;

			if( class1 == class2 )
				continue;

			if( class1 == NMG_CLASS_AonBshared || class2 == NMG_CLASS_AonBshared )
				continue;

			/* need to split this edge at plane pl1 */
			VSUB2( dir, vg2->coord, vg1->coord )

			code = bn_isect_line3_plane( &dist, vg1->coord, dir, pl1, &is->tol );
			if( code < 1 )
			{
				bu_log( "nmg_isect_nearly_coplanar_faces: EU (x%x) goes from %s to %s\n",
					eu, nmg_class_name( class1 ), nmg_class_name( class2 ) );
				bu_log( "But bn_isect_line3_plane() returns %d\n", code );
				bu_log( "pl1 = ( %g %g %g %g )\n", V4ARGS( pl1 ) );
				nmg_pr_lu_briefly( lu, "" );
				rt_bomb( "nmg_isect_nearly_coplanar_faces: BAD EU" );
			}

			if( dist <= 0.0 || dist >= 1.0 )
			{
				bu_log( "nmg_isect_nearly_coplanar_faces: EU (x%x) goes from %s to %s\n",
					eu, nmg_class_name( class1 ), nmg_class_name( class2 ) );
				bu_log( "But bn_isect_line3_plane() returns %d and dist=%g\n", code, dist );
				bu_log( "pl1 = ( %g %g %g %g )\n", V4ARGS( pl1 ) );
				nmg_pr_lu_briefly( lu, "" );
				rt_bomb( "nmg_isect_nearly_coplanar_faces: BAD EU" );
			}
			VJOIN1( hit_pt, vg1->coord, dist, dir );

			hit_vu = nmg_find_pt_in_face( fu2, hit_pt, &is->tol );
			if( !hit_vu )
				hit_v = nmg_find_pt_in_model( m, hit_pt, &is->tol );
			else
				hit_v = hit_vu->v_p;

			new_eu = nmg_esplit( hit_v, eu, 1 );
			hit_v = new_eu->vu_p->v_p;
			if( !hit_v->vg_p )
				nmg_vertex_gv( hit_v, hit_pt );
		}
	}

	/* get a list of all the loops in this faceuse */
	bu_ptbl_reset( &loops);
	for( BU_LIST_FOR( lu, loopuse, &fu2->lu_hd ) )
		bu_ptbl( &loops,  BU_PTBL_INS, (long *)lu );

	/* cut each loop so that every loop ends up either entirely on the other
	 * face, or with only a "line of intersection" in common
	 */
	for( i=0 ; i<BU_PTBL_END( &loops ) ; i++ )
	{
		lu = (struct loopuse *)BU_PTBL_GET( &loops, i );
		NMG_CK_LOOPUSE( lu );

		nmg_cut_lu_into_coplanar_and_non( lu, pl1, is );
	}

	/* Need to break edges in faces on vertices that may lie on new edges formed by cuts */
	nmg_vertex_tabulate( &verts, &m->magic );
	/* split new edges in fu1 */
	for( BU_LIST_FOR( lu, loopuse, &fu1->lu_hd ) )
	{
		if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
			continue;

		for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
		{
			if( bu_ptbl_locate( &eu1_list, (long *)eu ) != (-1) )
				continue;

			/* this is a new edgeuse, check if it should be split */
			for( i=0 ; i<BU_PTBL_END( &verts ) ; i++ )
			{
				struct vertex *v;
				int code;
				fastf_t dist[2];
				point_t pca;

				v = (struct vertex *)BU_PTBL_GET( &verts , i );

				if( v == eu->vu_p->v_p )
					continue;

				if( v == eu->eumate_p->vu_p->v_p )
					continue;

				code = bn_dist_pt3_lseg3( dist, pca, eu->vu_p->v_p->vg_p->coord,
					eu->eumate_p->vu_p->v_p->vg_p->coord, v->vg_p->coord, &is->tol );

				if( code > 2 )
					continue;

				if( code == 1 )
					bu_log( "nmg_isect_nearly_coplanar_faces: vertices should have been fused x%x and x%x\n", v, eu->vu_p->v_p );
				else if( code == 2 )
					bu_log( "nmg_isect_nearly_coplanar_faces: vertices should have been fused x%x and x%x\n", v, eu->eumate_p->vu_p->v_p );
				else
				{
					/* need to split EU at V */
					(void)nmg_esplit( v, eu, 1 );
				}
			}
		}
	}

	/* split new edges in fu2 */
	for( BU_LIST_FOR( lu, loopuse, &fu2->lu_hd ) )
	{
		if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
			continue;

		for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
		{
			if( bu_ptbl_locate( &eu1_list, (long *)eu ) != (-1) )
				continue;

			/* this is a new edgeuse, check if it should be split */
			for( i=0 ; i<BU_PTBL_END( &verts ) ; i++ )
			{
				struct vertex *v;
				int code;
				fastf_t dist[2];
				point_t pca;

				v = (struct vertex *)BU_PTBL_GET( &verts , i );

				if( v == eu->vu_p->v_p )
					continue;

				if( v == eu->eumate_p->vu_p->v_p )
					continue;

				code = bn_dist_pt3_lseg3( dist, pca, eu->vu_p->v_p->vg_p->coord,
					eu->eumate_p->vu_p->v_p->vg_p->coord, v->vg_p->coord, &is->tol );

				if( code > 2 )
					continue;

				if( code == 1 )
					bu_log( "nmg_isect_nearly_coplanar_faces: vertices should have been fused x%x and x%x\n", v, eu->vu_p->v_p );
				else if( code == 2 )
					bu_log( "nmg_isect_nearly_coplanar_faces: vertices should have been fused x%x and x%x\n", v, eu->eumate_p->vu_p->v_p );
				else
				{
					/* need to split EU at V */
					(void)nmg_esplit( v, eu, 1 );
				}
			}
		}
	}

	bu_ptbl_free( &loops);
	bu_ptbl_free( &verts);

	if (rt_g.NMG_debug & DEBUG_POLYSECT)
	{
		plane_t pl1,pl2;
		fastf_t dist;

		bu_log( "After splitting loops into coplanar and non:\n" );
		nmg_pr_fu_briefly( fu1, "" );
		nmg_pr_fu_briefly( fu2, "" );

		NMG_GET_FU_PLANE( pl1, fu1 );
		NMG_GET_FU_PLANE( pl2, fu2 );

		for( BU_LIST_FOR( lu, loopuse, &fu1->lu_hd ) )
		{
			int in=0,on=0,out=0;

			for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
			{
				struct vertex_g *vg;

				vg = eu->vu_p->v_p->vg_p;

				dist = DIST_PT_PLANE( vg->coord, pl2 );

				if( dist > is->tol.dist )
					out++;
				else if( dist < (-is->tol.dist ))
					in++;
				else
					on++;
			}

			if( in && out )
				bu_log( "lu x%x is in and out of fu x%x\n", lu, fu2 );
			else if( in )
				bu_log( "lu x%x is inside of fu x%x\n", lu, fu2 );
			else if( out )
				bu_log( "lu x%x is outside of fu x%x\n", lu, fu2 );
			else if( on )
				bu_log( "lu x%x is on of fu x%x\n", lu, fu2 );
			else
				bu_log( "Can't figure lu x%x w.r.t fu x%x, on=%d, in=%d, out=%d\n",
					lu, fu2, on,in,out);
		}

		for( BU_LIST_FOR( lu, loopuse, &fu2->lu_hd ) )
		{
			int in=0,on=0,out=0;

			for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
			{
				struct vertex_g *vg;

				vg = eu->vu_p->v_p->vg_p;

				dist = DIST_PT_PLANE( vg->coord, pl1 );

				if( dist > is->tol.dist )
					out++;
				else if( dist < (-is->tol.dist ))
					in++;
				else
					on++;
			}

			if( in && out )
				bu_log( "lu x%x is in and out of fu x%x\n", lu, fu1 );
			else if( in )
				bu_log( "lu x%x is inside of fu x%x\n", lu, fu1 );
			else if( out )
				bu_log( "lu x%x is outside of fu x%x\n", lu, fu1 );
			else if( on )
				bu_log( "lu x%x is on of fu x%x\n", lu, fu1 );
			else
				bu_log( "Can't figure lu x%x w.r.t fu x%x, on=%d, in=%d, out=%d\n",
					lu, fu1, on,in,out);
		}
	}

	/* now intersect only EU's that lie in the plane of the other faceuse */
	bu_ptbl_reset( &eu1_list);
	bu_ptbl_reset( &eu2_list);
	nmg_edgeuse_tabulate( &eu1_list, &fu1->l.magic );
	nmg_edgeuse_tabulate( &eu2_list, &fu2->l.magic );
	nmg_isect_coplanar_edges( is, &eu1_list, &eu2_list );

	if( mag1 )
		bu_free( (char *)mag1, "mag1" );
	if( mag2 )
		bu_free( (char *)mag2, "mag2" );

	bu_ptbl_free( is->l1);
	bu_ptbl_free( is->l2);

	if (rt_g.NMG_debug & DEBUG_POLYSECT)
	{
		plane_t pl1,pl2;
		fastf_t dist;

		bu_log( "After intersection nearly coplanar faces:\n" );
		nmg_pr_fu_briefly( fu1, "" );
		nmg_pr_fu_briefly( fu2, "" );

		NMG_GET_FU_PLANE( pl1, fu1 );
		NMG_GET_FU_PLANE( pl2, fu2 );

		for( BU_LIST_FOR( lu, loopuse, &fu1->lu_hd ) )
		{
			int in=0,on=0,out=0;

			for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
			{
				struct vertex_g *vg;

				vg = eu->vu_p->v_p->vg_p;

				dist = DIST_PT_PLANE( vg->coord, pl2 );

				if( dist > is->tol.dist )
					out++;
				else if( dist < (-is->tol.dist ))
					in++;
				else
					on++;
			}

			if( in && out )
				bu_log( "lu x%x is in and out of fu x%x\n", lu, fu2 );
			else if( in )
				bu_log( "lu x%x is inside of fu x%x\n", lu, fu2 );
			else if( out )
				bu_log( "lu x%x is outside of fu x%x\n", lu, fu2 );
			else if( on )
				bu_log( "lu x%x is on of fu x%x\n", lu, fu2 );
			else
				bu_log( "Can't figure lu x%x w.r.t fu x%x, on=%d, in=%d, out=%d\n",
					lu, fu2, on,in,out);
		}

		for( BU_LIST_FOR( lu, loopuse, &fu2->lu_hd ) )
		{
			int in=0,on=0,out=0;

			for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
			{
				struct vertex_g *vg;

				vg = eu->vu_p->v_p->vg_p;

				dist = DIST_PT_PLANE( vg->coord, pl1 );

				if( dist > is->tol.dist )
					out++;
				else if( dist < (-is->tol.dist ))
					in++;
				else
					on++;
			}

			if( in && out )
				bu_log( "lu x%x is in and out of fu x%x\n", lu, fu1 );
			else if( in )
				bu_log( "lu x%x is inside of fu x%x\n", lu, fu1 );
			else if( out )
				bu_log( "lu x%x is outside of fu x%x\n", lu, fu1 );
			else if( on )
				bu_log( "lu x%x is on of fu x%x\n", lu, fu1 );
			else
				bu_log( "Can't figure lu x%x w.r.t fu x%x, on=%d, in=%d, out=%d\n",
					lu, fu1, on,in,out);
		}
	}

}

/*			N M G _ F A C E S _ C A N _ B E _ I N T E R S E C T E D
 *
 *	Check if two faceuses can be intersected normally, by looking at the line
 *	of intersection and determining if the vertices from each face are all
 *	above the other face on one side of the intersection line and below it
 *	on the other side of the interection line.
 *
 *	return:
 *		1 - faceuses meet criteria and can be intersected normally
 *		0 - must use nmg_isect_nearly_coplanar_faces
 */
int
nmg_faces_can_be_intersected(struct nmg_inter_struct *bs, const struct faceuse *fu1, const struct faceuse *fu2, const struct bn_tol *tol)
{
	plane_t pl1,pl2;
	point_t min_pt;
	struct face *f1,*f2;
	double dir_len_sq;
	double one_over_dir_len;
	plane_t tmp_pl;
	vect_t left;
	struct bu_ptbl verts;
	int on_line, above_left, below_left, on_left, above_right, below_right, on_right;
	int i;

	NMG_CK_FACEUSE( fu1 );
	NMG_CK_FACEUSE( fu2 );
	BN_CK_TOL( tol );

	NMG_GET_FU_PLANE( pl1, fu1 );
	NMG_GET_FU_PLANE( pl2, fu2 );

	f1 = fu1->f_p;
	f2 = fu2->f_p;

	NMG_CK_FACE( f1 );
	NMG_CK_FACE( f2 );

	VMOVE(min_pt, f1->min_pt);
	VMIN(min_pt, f2->min_pt);

	VCROSS( bs->dir, pl1, pl2 );
	dir_len_sq = MAGSQ( bs->dir );
	if( dir_len_sq <= SMALL_FASTF )
		return( 0 );

	one_over_dir_len = 1.0/sqrt( dir_len_sq );
	VSCALE( bs->dir, bs->dir, one_over_dir_len );
	VMOVE( tmp_pl, bs->dir );
	tmp_pl[3] = VDOT( tmp_pl, min_pt );

	if( bn_mkpoint_3planes( bs->pt, tmp_pl, pl1, pl2 ) )
		return( 0 );

	VCROSS( left, pl1, bs->dir );

	/* check vertices from fu1 versus plane of fu2 */
	nmg_vertex_tabulate( &verts, &fu1->l.magic );
	on_line = 0;
	above_left = 0;
	below_left = 0;
	on_left = 0;
	above_right = 0;
	below_right = 0;
	on_right = 0;
	for( i=0 ; i<BU_PTBL_END( &verts ) ; i++ )
	{
		struct vertex *v;
		point_t pca;
		fastf_t dist;
		int code;
		vect_t to_v;

		v = (struct vertex *)BU_PTBL_GET( &verts, i );

		code = rt_dist_pt3_line3( &dist, pca, bs->pt, bs->dir, v->vg_p->coord, tol );

		if( code == 0 || code == 1 )
		{
			on_line++;
			continue;
		}

		VSUB2( to_v, v->vg_p->coord, pca );
		dist = DIST_PT_PLANE( v->vg_p->coord, pl2 );
		if( VDOT( to_v, left ) > 0.0 )
		{
			/* left of intersection line */
			if( dist > tol->dist )
				above_left++;
			else if( dist < (-tol->dist) )
				below_left++;
			else
				on_left++;
		}
		else
		{
			/* right of intersction line */
			if( dist > tol->dist )
				above_right++;
			else if( dist < (-tol->dist) )
				below_right++;
			else
				on_right++;
		}
	}
	bu_ptbl_free( &verts);

	if( above_left && below_left )
		return( 0 );
	if( on_left )
		return( 0 );
	if( above_right && below_right )
		return( 0 );
	if( on_right )
		return( 0 );

	/* check vertices from fu2 versus plane of fu1 */
	nmg_vertex_tabulate( &verts, &fu2->l.magic );
	on_line = 0;
	above_left = 0;
	below_left = 0;
	on_left = 0;
	above_right = 0;
	below_right = 0;
	on_right = 0;
	for( i=0 ; i<BU_PTBL_END( &verts ) ; i++ )
	{
		struct vertex *v;
		point_t pca;
		fastf_t dist;
		int code;
		vect_t to_v;

		v = (struct vertex *)BU_PTBL_GET( &verts, i );

		code = rt_dist_pt3_line3( &dist, pca, bs->pt, bs->dir, v->vg_p->coord, tol );

		if( code == 0 || code == 1 )
		{
			on_line++;
			continue;
		}

		VSUB2( to_v, v->vg_p->coord, pca );
		dist = DIST_PT_PLANE( v->vg_p->coord, pl1 );
		if( VDOT( to_v, left ) > 0.0 )
		{
			/* left of intersection line */
			if( dist > tol->dist )
				above_left++;
			else if( dist < (-tol->dist) )
				below_left++;
			else
				on_left++;
		}
		else
		{
			/* right of intersction line */
			if( dist > tol->dist )
				above_right++;
			else if( dist < (-tol->dist) )
				below_right++;
			else
				on_right++;
		}
	}
	bu_ptbl_free( &verts);

	if( above_left && below_left )
		return( 0 );
	if( on_left )
		return( 0 );
	if( above_right && below_right )
		return( 0 );
	if( on_right )
		return( 0 );

	return( 1 );
}

/*
 *			N M G _ I S E C T _ T W O _ G E N E R I C _ F A C E S
 *
 *	Intersect a pair of faces
 */
void
nmg_isect_two_generic_faces(struct faceuse *fu1, struct faceuse *fu2, const struct bn_tol *tol)
{
	struct nmg_inter_struct	bs;
	plane_t		pl1, pl2;
	struct face	*f1;
	struct face	*f2;
	point_t		min_pt;
	int		status;
	int		i;

	BN_CK_TOL(tol);
	bs.magic = NMG_INTER_STRUCT_MAGIC;
	bs.vert2d = (fastf_t *)NULL;
	bs.tol = *tol;		/* struct copy */

	NMG_CK_FACEUSE(fu1);
	f1 = fu1->f_p;
	NMG_CK_FACE(f1);
	NMG_CK_FACE_G_PLANE(f1->g.plane_p);

	NMG_CK_FACEUSE(fu2);
	f2 = fu2->f_p;
	NMG_CK_FACE(f2);
	NMG_CK_FACE_G_PLANE(f2->g.plane_p);

	NMG_GET_FU_PLANE( pl1, fu1 );
	NMG_GET_FU_PLANE( pl2, fu2 );

	if (rt_g.NMG_debug & DEBUG_POLYSECT) {
		bu_log("\nnmg_isect_two_generic_faces(fu1=x%x, fu2=x%x)\n", fu1, fu2);

		bu_log("Planes\t%gx + %gy + %gz = %g\n\t%gx + %gy + %gz = %g\n",
			pl1[0], pl1[1], pl1[2], pl1[3],
			pl2[0], pl2[1], pl2[2], pl2[3]);
		bu_log( "Cosine of angle between planes = %g\n" , VDOT( pl1 , pl2 ) );
		bu_log( "fu1:\n" );
		nmg_pr_fu_briefly( fu1 , "\t" );
		bu_log( "fu2:\n" );
		nmg_pr_fu_briefly( fu2 , "\t" );
nmg_fu_touchingloops(fu1);
nmg_fu_touchingloops(fu2);
	}

	status = 10;
	if( f1->g.plane_p == f2->g.plane_p )  {
		if (rt_g.NMG_debug & DEBUG_POLYSECT) {
			bu_log("co-planar faces (shared fg)\n");
		}
		status = (-1);
	}

	if ( !V3RPP_OVERLAP_TOL(f2->min_pt, f2->max_pt,
	    f1->min_pt, f1->max_pt, &bs.tol) )  return;

	/*
	 *  The extents of face1 overlap the extents of face2.
	 *  Construct a ray which contains the line of intersection.
	 *  There are two choices for direction, and an infinite number
	 *  of candidate points.
	 *
	 *  The correct choice of this ray is very important, so that:
	 *	1)  All intersections are at positive distances on the ray,
	 *	2)  dir cross N will point "left".
	 *
	 *  These two conditions can be satisfied by intersecting the
	 *  line with the face's bounding RPP.  This will give two
	 *  points A and B, where A is closer to the min point of the RPP
	 *  and B is closer to the max point of the RPP.
	 *  Let bs.pt be A, and let bs.dir point from A towards B.
	 *  This choice will satisfy both constraints, above.
	 *
	 *  NOTE:  These conditions must be enforced in the 2D code, also.
	 */
	VMOVE(min_pt, f1->min_pt);
	VMIN(min_pt, f2->min_pt);
	if( status == 10 )
	{
		status = bn_isect_2planes( bs.pt, bs.dir, pl1, pl2,
			min_pt, tol );

		if (rt_g.NMG_debug & DEBUG_POLYSECT) {
			bu_log( "\tnmg_isect_two_generic_faces: intersect ray start (%f , %f , %f )\n\t\tin direction (%f , %f , %f )\n",
				bs.pt[X],
				bs.pt[Y],
				bs.pt[Z],
				bs.dir[X],
				bs.dir[Y],
				bs.dir[Z] );
		}
	}

	switch( status )  {
	case 0:
		if( fu1->f_p->g.plane_p == fu2->f_p->g.plane_p )  {
			rt_bomb("nmg_isect_two_generic_faces: co-planar faces not detected\n");
		}
		/* All is well */
		bs.coplanar = 0;
		nmg_isect_two_face3p( &bs, fu1, fu2 );
		break;
	case -1:
	case -2:
		/* co-planar faces */
		{
			int coplanar1=0;
			int coplanar2=0;
			int coplanar=0;
			int parallel=0;
			fastf_t max_dist1;
			fastf_t min_dist1;
			fastf_t max_dist2;
			fastf_t min_dist2;
			fastf_t dist;
			struct bu_ptbl verts;

			if( f1->g.plane_p == f2->g.plane_p )
				goto cplanar;

			/* are these face really coplanar??? */

			min_dist1 = MAX_FASTF;
			max_dist1 = (-MAX_FASTF);
			min_dist2 = MAX_FASTF;
			max_dist2 = (-MAX_FASTF);
			nmg_vertex_tabulate( &verts, &fu1->l.magic );
			for( i=0 ; i<BU_PTBL_END( &verts ) ; i++ )
			{
				struct vertex *v;

				v = (struct vertex *)BU_PTBL_GET( &verts, i );
				dist = DIST_PT_PLANE( v->vg_p->coord, pl2 );
				if( dist > max_dist1 )
					max_dist1 = dist;
				if( dist < min_dist1 )
					min_dist1 = dist;
			}
			bu_ptbl_free( &verts);

			if( min_dist1 > tol->dist )
			{
				if (rt_g.NMG_debug & DEBUG_POLYSECT)
				{
					bu_log( "nmg_isect_two_generic_faces: bn_isect_2planes() says faces are coplanar.\n" );
					bu_log( "\tbut all vertices of fu1 (x%x) are at least %gmm above plane of fu2 (x%x)\n",
						fu1, min_dist1, fu2 );
				}
				parallel = 1;
			}
			else if( max_dist1 < (-tol->dist ) )
			{
				if (rt_g.NMG_debug & DEBUG_POLYSECT)
				{
					bu_log( "nmg_isect_two_generic_faces: bn_isect_2planes() says faces are coplanar.\n" );
					bu_log( "\tbut all vertices of fu1 (x%x) are at least %gmm below plane of fu2 (x%x)\n",
						fu1, -max_dist1, fu2 );
				}
				parallel =  1;
			}
			else if( max_dist1 <= tol->dist && min_dist1 >= (-tol->dist) )
			{
				if (rt_g.NMG_debug & DEBUG_POLYSECT)
					bu_log( "nmg_isect_two_generic_faces: coplanar faces don't share face geometry, intersecting anyway\n" );
				coplanar1 = 1;
			}

			if( !parallel )
			{
				/* Nothing determined so far, try looking at vertices in the other face */
				nmg_vertex_tabulate( &verts, &fu2->l.magic );
				for( i=0 ; i<BU_PTBL_END( &verts ) ; i++ )
				{
					struct vertex *v;

					v = (struct vertex *)BU_PTBL_GET( &verts, i );
					dist = DIST_PT_PLANE( v->vg_p->coord, pl1 );
					if( dist > max_dist2 )
						max_dist2 = dist;
					if( dist < min_dist2 )
						min_dist2 = dist;
				}
				bu_ptbl_free( &verts);

				if( min_dist2 > tol->dist )
				{
					if (rt_g.NMG_debug & DEBUG_POLYSECT)
					{
						bu_log( "nmg_isect_two_generic_faces: bn_isect_2planes() says faces are coplanar.\n" );
						bu_log( "\tbut all vertices of fu2 (x%x) are at least %gmm above plane of fu1 (x%x)\n",
							fu2, min_dist2, fu1 );
					}
					parallel = 1;
				}
				else if( max_dist2 < (-tol->dist ) )
				{
					if (rt_g.NMG_debug & DEBUG_POLYSECT)
					{
						bu_log( "nmg_isect_two_generic_faces: bn_isect_2planes() says faces are coplanar.\n" );
						bu_log( "\tbut all vertices of fu2 (x%x) are at least %gmm below plane of fu1 (x%x)\n",
							fu2, -max_dist2, fu1 );
					}
					parallel = 1;
				}
				else if( max_dist2 <= tol->dist && min_dist2 >= (-tol->dist) )
				{
					if (rt_g.NMG_debug & DEBUG_POLYSECT)
						bu_log( "nmg_isect_two_generic_faces: coplanar faces don't share face geometry, intersecting anyway\n" );
					coplanar2 = 1;
				}
			}

			if (rt_g.NMG_debug & DEBUG_POLYSECT)
			{
				bu_log( "nmg_isect_two_generic_faces: FUs x%x and x%x do not share face geometry\n", fu1, fu2 );
				bu_log( "\tbut bn_isect_2planes() says they are coplanar or parallel\n" );
				bu_log( "max_dist1 = %g, min_dist1 = %g\n", max_dist1, min_dist1 );
				bu_log( "max_dist2 = %g, min_dist2 = %g\n", max_dist2, min_dist2 );
			}

			if( coplanar1 && coplanar2 )
				coplanar = 1;

			if( coplanar )
			{
cplanar:
				bs.coplanar = 1;
				nmg_isect_two_face2p_jra( &bs, fu1, fu2 );
				break;
			}
			else if( parallel )
				break;
			else
			{
				if( nmg_faces_can_be_intersected( &bs, fu1, fu2, tol ) )
				{
					bs.coplanar = 0;
					nmg_isect_two_face3p( &bs, fu1, fu2 );
				}
				else
					nmg_isect_nearly_coplanar_faces( &bs, fu1, fu2 );
			}
		}
		break;
	default:
		/* internal error */
		bu_log("ERROR nmg_isect_two_generic_faces() unable to find plane intersection\n");
		break;
	}

	nmg_isect2d_cleanup( &bs );
#if 0
	/* 	TOO EARLY, These are needed for identifying shared vertices */
	/* Eliminate any OT_BOOLPLACE self-loops now. */
	nmg_sanitize_fu( fu1 );
	nmg_sanitize_fu( fu2 );
#endif
	/* Eliminate stray vertices that were added along edges in this step */
	(void)nmg_unbreak_region_edges( &fu1->l.magic );
	(void)nmg_unbreak_region_edges( &fu2->l.magic );

    	if ( fu1 && rt_g.NMG_debug & (DEBUG_POLYSECT|DEBUG_FCUT|DEBUG_MESH)
    	    && rt_g.NMG_debug & DEBUG_PLOTEM) {
    	    	static int nshell = 1;
    	    	char	name[32];
    	    	FILE	*fp;


    	    	/* Both at once */
    	    	nmg_pl_2fu( "Iface%d.pl", 0, fu2, fu1, 0 );

		/* Each in it's own file */
    	    	nmg_face_plot( fu1 );
    	    	nmg_face_plot( fu2 );

    	    	sprintf(name, "shellA%d.pl", nshell);
    	    	if( (fp = fopen(name, "w")) != NULL )  {
    	    		bu_log("overlay %s\n", name);
    	    		nmg_pl_s( fp, fu1->s_p );
    	    		fclose(fp);
    	    	}

    	    	sprintf(name, "shellB%d.pl", nshell++);
    	    	if( (fp = fopen(name, "w")) != NULL )  {
    	    		bu_log("overlay %s\n", name);
    	    		nmg_pl_s( fp, fu2->s_p );
    	    		fclose(fp);
    	    	}

#if 0
    	    	/* This should really be controlled by it's own bit. */
    	    	sprintf(name, "model%d.g", nshell);
		nmg_stash_model_to_file( name, m, "After 2d isect" );
    	    	nshell++;
#endif
    	}

	if( rt_g.NMG_debug & DEBUG_VERIFY )  {
nmg_region_v_unique( fu1->s_p->r_p, &bs.tol );
nmg_region_v_unique( fu2->s_p->r_p, &bs.tol );
nmg_fu_touchingloops(fu1);
nmg_fu_touchingloops(fu2);
nmg_ck_face_worthless_edges( fu1 );
nmg_ck_face_worthless_edges( fu2 );
	}
}

/*
 *			N M G _ I S E C T _ E D G E 3 P _ E D G E 3 P
 *
 *  Intersect one edge with another.  At least one is a wire edge;
 *  thus there is no face context or intersection line.
 *  If the edges are non-colinear, there will be at most one point of isect.
 *  If the edges are colinear, there may be two.
 *
 *  Called from nmg_isect_edge3p_shell()
 */
static void
nmg_isect_edge3p_edge3p(struct nmg_inter_struct *is, struct edgeuse *eu1, struct edgeuse *eu2)
{
	struct vertexuse	*vu1a;
	struct vertexuse	*vu1b;
	struct vertexuse	*vu2a;
	struct vertexuse	*vu2b;
	vect_t			eu1_dir;
	vect_t			eu2_dir;
	fastf_t			dist[2];
	int			status;
	struct vertex		*new_v;
	point_t			hit_pt;

	NMG_CK_INTER_STRUCT(is);
	NMG_CK_EDGEUSE(eu1);
	NMG_CK_EDGEUSE(eu2);

	vu1a = eu1->vu_p;
	vu1b = BU_LIST_PNEXT_CIRC( edgeuse, eu1 )->vu_p;
	vu2a = eu2->vu_p;
	vu2b = BU_LIST_PNEXT_CIRC( edgeuse, eu2 )->vu_p;
	NMG_CK_VERTEXUSE(vu1a);
	NMG_CK_VERTEXUSE(vu1b);
	NMG_CK_VERTEXUSE(vu2a);
	NMG_CK_VERTEXUSE(vu2b);

	if (rt_g.NMG_debug & DEBUG_POLYSECT)
		bu_log("nmg_isect_edge3p_edge3p(eu1=x%x, eu2=x%x)\n\tvu1a=%x vu1b=%x, vu2a=%x vu2b=%x\n\tv1a=%x v1b=%x,   v2a=%x v2b=%x\n",
			eu1, eu2,
			vu1a, vu1b, vu2a, vu2b,
			vu1a->v_p, vu1b->v_p, vu2a->v_p, vu2b->v_p );

	/*
	 *  Topology check.
	 *  If both endpoints of both edges match, this is a trivial accept.
	 */
	if( (vu1a->v_p == vu2a->v_p && vu1b->v_p == vu2b->v_p) ||
	    (vu1a->v_p == vu2b->v_p && vu1b->v_p == vu2a->v_p) )  {
		if (rt_g.NMG_debug & DEBUG_POLYSECT)
			bu_log("nmg_isect_edge3p_edge3p: shared edge topology, both ends\n");
	    	if( eu1->e_p != eu2->e_p )
	    		nmg_radial_join_eu(eu1, eu2, &is->tol );
	    	return;
	}
	VSUB2( eu1_dir, vu1b->v_p->vg_p->coord, vu1a->v_p->vg_p->coord );
	VSUB2( eu2_dir, vu2b->v_p->vg_p->coord, vu2a->v_p->vg_p->coord );

	dist[0] = dist[1] = 0;	/* for clean prints, below */

	status = bn_isect_lseg3_lseg3( dist,
			vu1a->v_p->vg_p->coord, eu1_dir,
			vu2a->v_p->vg_p->coord, eu2_dir, &is->tol );

	if (rt_g.NMG_debug & DEBUG_POLYSECT) {
		bu_log("\trt_isect_line3_lseg3()=%d, dist: %g, %g\n",
			status, dist[0], dist[1] );
	}

	if( status < 0 )  {
		/* missed */
		return;
	}

	if( status == 0 )  {
		/* lines are colinear */
		bu_log("nmg_isect_edge3p_edge3p() colinear case.  Untested waters.\n");
		/* Initialize 2D vertex cache with EDGE info. */
		nmg_isect2d_prep( is, &eu1->l.magic );
		/* 3rd arg has to be a faceuse.  Tried to send it eu1->e_p */
		/* XXX This will rt_bomb() when faceuse is checked. */
		(void)nmg_isect_2colinear_edge2p( eu1, eu2, (struct faceuse *)NULL, is, (struct bu_ptbl *)0, (struct bu_ptbl *)0 );
		return;
	}

	/* XXX There is an intersection point.  This could just be
	 * reformulated as a 2D problem here, and passed off to
	 * the 2D routine that this was based on.
	 */

	/* dist[0] is distance along eu1 */
	if( dist[0] == 0 )  {
		/* Hit is at vu1a */
		if( dist[1] == 0 )  {
			/* Hit is at vu2a */
			nmg_jv( vu1a->v_p, vu2a->v_p );
			return;
		} else if( dist[1] == 1 )  {
			/* Hit is at vu2b */
			nmg_jv( vu1a->v_p, vu2b->v_p );
			return;
		}
		/* Break eu2 on vu1a */
		nmg_ebreaker( vu1a->v_p, eu2, &is->tol );
		return;
	} else if( dist[0] == 1 )  {
		/* Hit is at vu1b */
		if( dist[1] == 0 )  {
			/* Hit is at vu2a */
			nmg_jv( vu1b->v_p, vu2a->v_p );
			return;
		} else if( dist[1] == 1 )  {
			/* Hit is at vu2b */
			nmg_jv( vu1b->v_p, vu2b->v_p );
			return;
		}
		/* Break eu2 on vu1b */
		nmg_ebreaker( vu1b->v_p, eu2, &is->tol );
		return;
	} else {
		/* Hit on eu1 is between vu1a and vu1b */
		if( dist[1] < 0 || dist[1] > 1 )  return;	/* Don't bother breaking eu1, it doesn't touch eu2. */

		if( dist[1] == 0 )  {
			/* Hit is at vu2a */
			nmg_ebreaker( vu2a->v_p, eu1, &is->tol );
			return;
		} else if( dist[1] == 1 )  {
			/* Hit is at vu2b */
			nmg_ebreaker( vu2b->v_p, eu1, &is->tol );
			return;
		}
		/* Hit is amidships on both eu1 and eu2. */
		new_v = nmg_e2break( eu1, eu2 );

		VJOIN1( hit_pt, vu2a->v_p->vg_p->coord, dist[1], eu2_dir );
		nmg_vertex_gv(new_v, hit_pt);
	}
}

/*
 *			N M G _ I S E C T _ V E R T E X 3 _ E D G E 3 P
 *
 *  Intersect a lone vertex from s1 with a single edge from s2.
 */
static void
nmg_isect_vertex3_edge3p(struct nmg_inter_struct *is, struct vertexuse *vu1, struct edgeuse *eu2)
{
	fastf_t		dist;
	int		code;
	struct vertexuse	*vu2 = (struct vertexuse *)NULL;

	NMG_CK_INTER_STRUCT(is);
	NMG_CK_VERTEXUSE(vu1);
	NMG_CK_EDGEUSE(eu2);

	code = bn_isect_pt_lseg( &dist, eu2->vu_p->v_p->vg_p->coord,
		eu2->vu_p->v_p->vg_p->coord,
		vu1->v_p->vg_p->coord, &is->tol );

	if( code < 0 )  return;		/* Not on line */
	switch( code )  {
	case 1:
		/* Hit is at A */
		vu2 = eu2->vu_p;
		break;
	case 2:
		/* Hit is at B */
		vu2 = BU_LIST_NEXT( edgeuse, &eu2->l)->vu_p;
		break;
	case 3:
		/* Hit is in the span AB somewhere, break edge */
		vu2 = nmg_ebreaker( vu1->v_p, eu2, &is->tol )->vu_p;
		break;
	default:
		rt_bomb("nmg_isect_vertex3_edge3p()\n");
	}
	/* Make sure verts are shared at hit point. They _should_ already be. */
	nmg_jv( vu1->v_p, vu2->v_p );
	(void)bu_ptbl_ins_unique(is->l1, &vu1->l.magic);
	(void)bu_ptbl_ins_unique(is->l2, &vu2->l.magic);
}

/*
 *			N M G _ I S E C T _ E D G E 3 P _ S H E L L
 *
 *  Intersect one edge with all of another shell.
 *  There is no face context for this edge, because
 *
 *  At present, this routine is used for only one purpose:
 *	1)  Handling wire edge -vs- shell intersection
 *
 *  The edge will be fully intersected with the shell, potentially
 *  getting trimmed down in the process as crossings of s2 are found.
 *  The caller is responsible for re-calling with the extra edgeuses.
 *
 *  If both vertices of eu1 are on s2 (the other shell), and
 *  there is no edge in s2 between them, we need to determine
 *  whether this is an interior or exterior edge, and
 *  perhaps add a loop into s2 connecting those two verts.
 *
 *  We can't use the face cutter, because s2 has no
 *  appropriate face containing this edge.
 *
 *  If this edge is split, we have to
 *  trust nmg_ebreak() to insert new eu's ahead in the eu list,
 *  so caller will see them.
 *
 *  Lots of junk will be put on the vert_list's in 'is';  the caller
 *  should just free the lists without using them.
 *
 *  Called by nmg_crackshells().
 */
static void
nmg_isect_edge3p_shell(struct nmg_inter_struct *is, struct edgeuse *eu1, struct shell *s2)
{
	struct faceuse	*fu2;
	struct loopuse	*lu2;
	struct edgeuse	*eu2;
	struct vertexuse *vu2;
	point_t		midpt;

	NMG_CK_INTER_STRUCT(is);
	NMG_CK_EDGEUSE(eu1);
	NMG_CK_SHELL(s2);

	if (rt_g.NMG_debug & DEBUG_POLYSECT) {
		bu_log("nmg_isect_edge3p_shell(, eu1=x%x, s2=x%x) START\n",
			eu1, s2 );
	}

	if ( (eu2 = nmg_find_matching_eu_in_s( eu1, s2 )) )  {
		/* XXX Is the fact that s2 has a corresponding edge good enough? */
		nmg_radial_join_eu( eu1, eu2, &is->tol );
		return;
	}

	/* Note the ray that contains this edge.  For debug in nmg_isect_wireedge3p_face3p() */
	VMOVE( is->pt, eu1->vu_p->v_p->vg_p->coord );
	VSUB2( is->dir, eu1->eumate_p->vu_p->v_p->vg_p->coord, is->pt );
	VUNITIZE( is->dir );

	/* Check eu1 of s1 against all faces in s2 */
	for( BU_LIST_FOR( fu2, faceuse, &s2->fu_hd ) )  {
		NMG_CK_FACEUSE(fu2);
		if( fu2->orientation != OT_SAME )  continue;
		is->fu2 = fu2;

		/* We aren't interested in the vert_list's, ignore return */
		(void)nmg_isect_wireedge3p_face3p( is, eu1, fu2 );
	}

	/* Check eu1 of s1 against all wire loops in s2 */
	is->fu2 = (struct faceuse *)NULL;
	for( BU_LIST_FOR( lu2, loopuse, &s2->lu_hd ) )  {
		NMG_CK_LOOPUSE(lu2);
		/* Really, it's just a bunch of wire edges, in a loop. */
		if( BU_LIST_FIRST_MAGIC( &lu2->down_hd ) == NMG_VERTEXUSE_MAGIC)  {
			/* XXX Can there be lone-vertex wire loops here? */
			vu2 = BU_LIST_FIRST( vertexuse, &lu2->down_hd );
			NMG_CK_VERTEXUSE(vu2);
			nmg_isect_vertex3_edge3p( is, vu2, eu1 );
			continue;
		}
		for( BU_LIST_FOR( eu2, edgeuse, &lu2->down_hd ) )  {
			NMG_CK_EDGEUSE(eu2);
			nmg_isect_edge3p_edge3p( is, eu1, eu2 );
		}
	}

	/* Check eu1 of s1 against all wire edges in s2 */
	for( BU_LIST_FOR( eu2, edgeuse, &s2->eu_hd ) )  {
		NMG_CK_EDGEUSE(eu2);
		nmg_isect_edge3p_edge3p( is, eu1, eu2 );
	}

	/* Check eu1 of s1 against vert of s2 */
	if( s2->vu_p )  {
		nmg_isect_vertex3_edge3p( is, s2->vu_p, eu1 );
	}

	/*
	 *  The edge has been fully intersected with the other shell.
	 *  It may have been trimmed in the process;  the caller is
	 *  responsible for re-calling us with the extra edgeuses.
	 *  If both vertices of eu1 are on s2 (the other shell), and
	 *  there is no edge in s2 between them, we need to determine
	 *  whether this is an interior or exterior edge, and
	 *  perhaps add a loop into s2 connecting those two verts.
	 */
	if ((eu2 = nmg_find_matching_eu_in_s( eu1, s2 )) )  {
		/* We can't fuse wire edges */
		goto out;
	}
	/*  Can't use the face cutter, because s2 has no associated face!
	 *  Call the geometric classifier on the midpoint.
	 *  If it's INSIDE or ON the other shell, add a wire loop
	 *  that connects the two vertices.
	 */
	VADD2SCALE( midpt, eu1->vu_p->v_p->vg_p->coord,
		eu1->eumate_p->vu_p->v_p->vg_p->coord,  0.5 );
	if( nmg_class_pt_s( midpt, s2, 0, &is->tol ) == NMG_CLASS_AoutB )
		goto out;		/* Nothing more to do */

	/* Add a wire loop in s2 connecting the two vertices */
	lu2 = nmg_mlv( &s2->l.magic, eu1->vu_p->v_p, OT_UNSPEC );
	NMG_CK_LOOPUSE(lu2);
	{
		struct edgeuse	*neu1, *neu2;

		neu1 = nmg_meonvu( BU_LIST_FIRST( vertexuse, &lu2->down_hd ) );
		neu2 = nmg_eusplit( eu1->eumate_p->vu_p->v_p, neu1, 0 );
		NMG_CK_EDGEUSE(eu1);
		/* Attach both new edges in s2 to original edge in s1 */
		nmg_use_edge_g( neu1, eu1->g.magic_p );
		nmg_use_edge_g( neu2, eu1->g.magic_p );
		nmg_radial_join_eu( eu1, neu2, &is->tol );
		nmg_radial_join_eu( eu1, neu1, &is->tol );
}
	nmg_loop_g(lu2->l_p, &is->tol);
	if (rt_g.NMG_debug & DEBUG_POLYSECT) {
		bu_log("nmg_isect_edge3p_shell(, eu1=x%x, s2=x%x) Added wire lu=x%x\n",
			eu1, s2, lu2 );
	}

out:
	if (rt_g.NMG_debug & DEBUG_POLYSECT) {
		bu_log("nmg_isect_edge3p_shell(, eu1=x%x, s2=x%x) END\n",
			eu1, s2 );
	}
	return;
}

/*
 *			N M G _ C R A C K S H E L L S
 *
 *	Split the components of two shells wherever they may intersect,
 *	in preparation for performing boolean operations on the shells.
 */
void
nmg_crackshells(struct shell *s1, struct shell *s2, const struct bn_tol *tol)
{
	struct bu_ptbl		vert_list1, vert_list2;
	struct nmg_inter_struct is;
	struct shell_a	*sa1, *sa2;
	struct face	*f1;
	struct faceuse	*fu1, *fu2;
	struct loopuse	*lu1;
	struct loopuse	*lu2;
	struct edgeuse	*eu1;
	struct edgeuse	*eu2;
	char		*flags;
	int		flag_len;

	if (rt_g.NMG_debug & DEBUG_POLYSECT)
		bu_log("nmg_crackshells(s1=x%x, s2=x%x)\n", s1, s2);

	BN_CK_TOL(tol);
	NMG_CK_SHELL(s1);
	sa1 = s1->sa_p;
	NMG_CK_SHELL_A(sa1);

	NMG_CK_SHELL(s2);
	sa2 = s2->sa_p;
	NMG_CK_SHELL_A(sa2);

	if( rt_g.NMG_debug & DEBUG_VERIFY )  {
		nmg_ck_vs_in_region( s1->r_p, tol );
		nmg_ck_vs_in_region( s2->r_p, tol );
	}

	/* All the non-face/face isect subroutines need are tol, l1, and l2 */
	is.magic = NMG_INTER_STRUCT_MAGIC;
	is.vert2d = (fastf_t *)NULL;
	is.tol = *tol;		/* struct copy */
	is.l1 = &vert_list1;
	is.l2 = &vert_list2;
	is.s1 = s1;
	is.s2 = s2;
	is.fu1 = (struct faceuse *)NULL;
	is.fu2 = (struct faceuse *)NULL;
	(void)bu_ptbl_init(&vert_list1, 64, "&vert_list1");
	(void)bu_ptbl_init(&vert_list2, 64, "&vert_list2");

	if( rt_g.NMG_debug & DEBUG_VERIFY )  {
		nmg_vshell( &s1->r_p->s_hd, s1->r_p );
		nmg_vshell( &s2->r_p->s_hd, s2->r_p );
	}

	/* See if shells overlap */
	if ( ! V3RPP_OVERLAP_TOL(sa1->min_pt, sa1->max_pt,
	    sa2->min_pt, sa2->max_pt, tol) )
		return;

	/* XXX This is dangerous:  maxindex will grow rapidly! */
	flag_len = s1->r_p->m_p->maxindex * 10;
	flags = (char *)bu_calloc( flag_len, sizeof(char),
		"nmg_crackshells flags[]" );

	/*
	 *  Check each of the faces in shell 1 to see
	 *  if they overlap the extent of shell 2
	 */
	for( BU_LIST_FOR( fu1, faceuse, &s1->fu_hd ) )  {
		if( s1->r_p->m_p->maxindex >= flag_len )  rt_bomb("nmg_crackshells() flag_len overrun\n");
		NMG_CK_FACEUSE(fu1);
		f1 = fu1->f_p;
		NMG_CK_FACE(f1);

		if( fu1->orientation != OT_SAME )  continue;
		if( NMG_INDEX_IS_SET(flags, f1) )  continue;
		NMG_CK_FACE_G_PLANE(f1->g.plane_p);

		/* See if face f1 overlaps shell2 */
		if( ! V3RPP_OVERLAP_TOL(sa2->min_pt, sa2->max_pt,
		    f1->min_pt, f1->max_pt, tol) )
			continue;

		is.fu1 = fu1;

		/*
		 *  Now, check the face f1 from shell 1
		 *  against each of the faces of shell 2
		 */
	    	for( BU_LIST_FOR( fu2, faceuse, &s2->fu_hd ) )  {
	    		NMG_CK_FACEUSE(fu2);
	    		NMG_CK_FACE(fu2->f_p);
			if( fu2->orientation != OT_SAME )  continue;

	    		is.fu2 = fu2;
			nmg_isect_two_generic_faces(fu1, fu2, tol);
	    	}

		/*
		 *  Because the rest of the shell elements are wires,
		 *  there is no need to invoke the face cutter;
		 *  calculating the intersection points (vertices)
		 *  is sufficient.
		 *  XXX Is this true?  What about a wire edge cutting
		 *  XXX clean across fu1?  fu1 ought to be cut!
		 *
		 *  If coplanar, need to cut face.
		 *  If non-coplanar, can only hit at one point.
		 */
		is.fu2 = (struct faceuse *)NULL;

		/* Check f1 from s1 against wire loops of s2 */
		for( BU_LIST_FOR( lu2, loopuse, &s2->lu_hd ) )  {
			NMG_CK_LOOPUSE(lu2);
			/* Not interested in vert_list here */
			(void)nmg_isect_wireloop3p_face3p( &is, lu2, fu1 );
		}

		/* Check f1 from s1 against wire edges of s2 */
		for( BU_LIST_FOR( eu2, edgeuse, &s2->eu_hd ) )  {
			NMG_CK_EDGEUSE(eu2);

			nmg_isect_wireedge3p_face3p( &is, eu2, fu1 );
		}

		/* Check f1 from s1 against lone vert of s2 */
		if( s2->vu_p )  {
			nmg_isect_3vertex_3face( &is, s2->vu_p, fu1 );
		}

	    	NMG_INDEX_SET(flags, f1);

		if( rt_g.NMG_debug & DEBUG_VERIFY )  {
			nmg_vshell( &s1->r_p->s_hd, s1->r_p );
			nmg_vshell( &s2->r_p->s_hd, s2->r_p );
		}
	}

	/*  Check each wire loop of shell 1 against non-faces of shell 2. */
	is.fu1 = (struct faceuse *)NULL;
	is.fu2 = (struct faceuse *)NULL;
	for( BU_LIST_FOR( lu1, loopuse, &s1->lu_hd ) )  {
		NMG_CK_LOOPUSE( lu1 );
		/* XXX Can there be lone-vertex loops here? (yes, need an intersector) */
		if( BU_LIST_FIRST_MAGIC( &lu1->down_hd ) != NMG_EDGEUSE_MAGIC )
			continue;
		/* Really, it's just a bunch of wire edges, in a loop. */
		for( BU_LIST_FOR( eu1, edgeuse, &lu1->down_hd ) )  {
			NMG_CK_EDGEUSE(eu1);
			/* Check eu1 against all of shell 2 */
			nmg_isect_edge3p_shell( &is, eu1, s2 );
		}
	}

	/*  Check each wire edge of shell 1 against all of shell 2. */
	for( BU_LIST_FOR( eu1, edgeuse, &s1->eu_hd ) )  {
		NMG_CK_EDGEUSE( eu1 );
		nmg_isect_edge3p_shell( &is, eu1, s2 );
	}

	/* Check each lone vert of s1 against shell 2 */
	if( s1->vu_p )  {
		/* Check vert of s1 against all faceuses in s2 */
	    	for( BU_LIST_FOR( fu2, faceuse, &s2->fu_hd ) )  {
	    		NMG_CK_FACEUSE(fu2);
			if( fu2->orientation != OT_SAME )  continue;
	    		nmg_isect_3vertex_3face( &is, s1->vu_p, fu2 );
	    	}
		/* Check vert of s1 against all wire loops of s2 */
		for( BU_LIST_FOR( lu2, loopuse, &s2->lu_hd ) )  {
			NMG_CK_LOOPUSE(lu2);
			/* Really, it's just a bunch of wire edges, in a loop. */
			/* XXX Can there be lone-vertex loops here? */
			for( BU_LIST_FOR( eu2, edgeuse, &lu2->down_hd ) )  {
				NMG_CK_EDGEUSE(eu2);
				nmg_isect_vertex3_edge3p( &is, s1->vu_p, eu2 );
			}
		}
		/* Check vert of s1 against all wire edges of s2 */
		for( BU_LIST_FOR( eu2, edgeuse, &s2->eu_hd ) )  {
			NMG_CK_EDGEUSE(eu2);
			nmg_isect_vertex3_edge3p( &is, s1->vu_p, eu2 );
		}

		/* Check vert of s1 against vert of s2 */
		/* Unnecessary: already done by vertex fuser */
	}
	if( s1->r_p->m_p->maxindex >= flag_len )  rt_bomb("nmg_crackshells() flag_len overrun by end\n");

	/* Release storage from bogus isect line */
	(void)bu_ptbl_free(&vert_list1);
	(void)bu_ptbl_free(&vert_list2);

	bu_free( (char *)flags, "nmg_crackshells flags[]" );

	/* Eliminate stray vertices that were added along edges in this step */
	(void)nmg_unbreak_region_edges( &s1->l.magic );
	(void)nmg_unbreak_region_edges( &s2->l.magic );
#if 0
		/* TOO EARLY!!! These are needed to identify shared vertices */
	/* clean things up now that the intersections have been built */
	nmg_sanitize_s_lv(s1, OT_BOOLPLACE);
	nmg_sanitize_s_lv(s2, OT_BOOLPLACE);
#endif
	nmg_isect2d_cleanup(&is);

	if( rt_g.NMG_debug & DEBUG_VERIFY )  {
		nmg_vshell( &s1->r_p->s_hd, s1->r_p );
		nmg_vshell( &s2->r_p->s_hd, s2->r_p );
nmg_ck_vs_in_region( s1->r_p, tol );
nmg_ck_vs_in_region( s2->r_p, tol );
	}
}

/*
 *			N M G _ F U _ T O U C H I N G L O O P S
 */
int
nmg_fu_touchingloops(const struct faceuse *fu)
{
	const struct loopuse	*lu;
	const struct vertexuse	*vu;

	NMG_CK_FACEUSE(fu);
	for (BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )  {
		NMG_CK_LOOPUSE(lu);
		if ((vu = nmg_loop_touches_self( lu )) )  {
			NMG_CK_VERTEXUSE(vu);
#if 0
			/* Right now, this routine is used for debugging ONLY,
			 * so if this condition exists, die.
			 * However, note that this condition happens a lot
			 * for valid reasons, too.
			 */
			bu_log("nmg_fu_touchingloops(lu=x%x, vu=x%x, v=x%x)\n",
				lu, vu, vu->v_p );
			nmg_pr_lu_briefly(lu,0);
			rt_bomb("nmg_fu_touchingloops()\n");
#else
			/* Perhaps log something here? */
#endif
			return 1;
		}
	}
	return 0;
}
@


11.66
log
@change conf.h to a wrapped config.h
@
text
@d49 1
a49 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/librt/nmg_inter.c,v 11.65 2004/04/05 08:48:57 morrison Exp $ (ARL)";
@


11.65
log
@merge of ansi-6-0-branch into HEAD
@
text
@d49 1
a49 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d52 5
a56 1
#include "conf.h"
@


11.64
log
@update copyright to include span through 2003
@
text
@d49 1
a49 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_inter.c,v 11.63 2003/01/25 07:02:10 morrison Exp $ (ARL)";
d88 1
a88 4
nmg_make_dualvu( v, fu, tol )
struct vertex *v;
struct faceuse *fu;
const struct bn_tol *tol;
d193 5
a197 5
nmg_enlist_vu( is, vu, dualvu, dist )
struct nmg_inter_struct	*is;
const struct vertexuse	*vu;
struct vertexuse	*dualvu;		/* vu's dual in other shell.  May be NULL */
fastf_t			dist;			/* distance along intersect ray for this vu */
d415 5
a419 5
nmg_get_2d_vertex( v2d, v, is, assoc_use )
point_t			v2d;		/* a 3-tuple */
struct vertex		*v;
struct nmg_inter_struct	*is;
const long		*assoc_use;	/* ptr to faceuse/edgeuse associated w/2d projection */
d547 1
a547 3
nmg_isect2d_prep( is, assoc_use )
struct nmg_inter_struct	*is;
const long		*assoc_use;
d648 1
a648 2
nmg_isect2d_cleanup(is)
struct nmg_inter_struct	*is;
d671 1
a671 1
nmg_isect2d_final_cleanup()
d695 1
a695 4
nmg_isect_vert2p_face2p(is, vu1, fu2)
struct nmg_inter_struct *is;
struct vertexuse	*vu1;
struct faceuse		*fu2;
d778 1
a778 4
nmg_isect_3vertex_3face(is, vu, fu)
struct nmg_inter_struct *is;
struct vertexuse *vu;
struct faceuse *fu;
d833 5
a837 5
nmg_break_3edge_at_plane(hit_pt, fu2, is, eu1)
const point_t		hit_pt;
struct faceuse		*fu2;		/* The face that eu intersects */
struct nmg_inter_struct *is;
struct edgeuse		*eu1;		/* Edge to be broken (in fu1) */
d1038 5
a1042 5
nmg_break_eu_on_v( eu1, v2, fu, is )
struct edgeuse		*eu1;
struct vertex		*v2;
struct faceuse		*fu;	/* for plane equation of (either) face */
struct nmg_inter_struct	*is;
d1126 1
a1126 4
nmg_break_eg_on_v( eg, v, tol )
const struct edge_g_lseg	*eg;
struct vertex		*v;
const struct bn_tol	*tol;
d1223 7
a1229 7
nmg_isect_2colinear_edge2p( eu1, eu2, fu, is, l1, l2 )
struct edgeuse	*eu1;
struct edgeuse	*eu2;
struct faceuse		*fu;	/* for plane equation of (either) face */
struct nmg_inter_struct	*is;
struct bu_ptbl		*l1;	/* optional: list of new eu1 pieces */
struct bu_ptbl		*l2;	/* optional: list of new eu2 pieces */
d1320 6
a1325 6
nmg_isect_edge2p_edge2p( is, eu1, eu2, fu1, fu2 )
struct nmg_inter_struct	*is;
struct edgeuse		*eu1;
struct edgeuse		*eu2;
struct faceuse		*fu1;		/* fu of eu1, for plane equation */
struct faceuse		*fu2;		/* fu of eu2, for error checks */
d1693 1
a1693 4
nmg_isect_wireedge3p_face3p(is, eu1, fu2)
struct nmg_inter_struct *is;
struct edgeuse		*eu1;
struct faceuse		*fu2;
d1997 1
a1997 4
nmg_isect_wireloop3p_face3p(bs, lu, fu)
struct nmg_inter_struct *bs;
struct loopuse *lu;
struct faceuse *fu;
d2082 1
a2082 3
nmg_isect_construct_nice_ray( is, fu2 )
struct nmg_inter_struct	*is;
struct faceuse		*fu2;
d2171 5
a2175 5
nmg_isect_edge2p_face2p( is, eu1, fu2, fu1 )
struct nmg_inter_struct	*is;
struct edgeuse		*eu1;		/* edge to be intersected w/fu2 */
struct faceuse		*fu2;		/* face to be intersected w/eu1 */
struct faceuse		*fu1;		/* fu that eu1 is from */
d2330 4
a2333 4
nmg_enlist_one_vu( is,   vu,  dist )
struct nmg_inter_struct	*is;
const struct vertexuse	*vu;
fastf_t			dist;			/* distance along intersect ray for this vu */
d2409 1
a2409 3
nmg_coplanar_face_vertex_fuse( fu1, fu2, tol )
struct faceuse *fu1, *fu2;
struct bn_tol *tol;
d2465 1
a2465 3
nmg_isect_two_face2p_jra( is, fu1, fu2 )
struct nmg_inter_struct	*is;
struct faceuse		*fu1, *fu2;
d3021 1
a3021 6
nmg_isect_line2_edge2p( is, list, eu1, fu1, fu2 )
struct nmg_inter_struct	*is;
struct bu_ptbl		*list;
struct edgeuse		*eu1;
struct faceuse		*fu1;
struct faceuse		*fu2;
d3184 1
a3184 4
nmg_isect_line2_vertex2( is, vu1, fu1 )
struct nmg_inter_struct	*is;
struct vertexuse	*vu1;
struct faceuse		*fu1;
d3215 1
a3215 4
nmg_isect_two_ptbls( is, t1, t2 )
struct nmg_inter_struct		*is;
const struct bu_ptbl		*t1;
const struct bu_ptbl		*t2;
d3291 1
a3291 5
nmg_find_eg_on_line( magic_p, pt, dir, tol )
const long		*magic_p;
const point_t		pt;
const vect_t		dir;
const struct bn_tol	*tol;
d3342 1
a3342 2
nmg_k0eu(v)
struct vertex	*v;
d3382 7
a3388 7
nmg_repair_v_near_v( hit_v, v, eg1, eg2, bomb, tol )
struct vertex		*hit_v;
struct vertex		*v;
const struct edge_g_lseg		*eg1;		/* edge_g_lseg of hit_v */
const struct edge_g_lseg		*eg2;		/* edge_g_lseg of v */
int			bomb;
const struct bn_tol	*tol;
d3455 7
a3461 7
nmg_search_v_eg( eu, second, eg1, eg2, hit_v, tol )
const struct edgeuse		*eu;
int				second;		/* 2nd vu on eu, not 1st */
const struct edge_g_lseg	*eg1;
const struct edge_g_lseg	*eg2;
register struct vertex		*hit_v;		/* often will be NULL */
const struct bn_tol		*tol;
d3537 1
a3537 4
nmg_common_v_2eg( eg1, eg2, tol )
struct edge_g_lseg	*eg1;
struct edge_g_lseg	*eg2;
const struct bn_tol	*tol;
d3571 1
a3571 5
nmg_is_vertex_on_inter( v, fu1, fu2, is )
struct vertex *v;
struct faceuse *fu1;
struct faceuse *fu2;
struct nmg_inter_struct *is;
d3619 1
a3619 7
nmg_isect_eu_verts( eu, vg1, vg2, verts, inters, tol )
struct edgeuse *eu;
struct vertex_g *vg1;
struct vertex_g *vg2;
struct bu_ptbl *verts;
struct bu_ptbl *inters;
const struct bn_tol *tol;
d3661 1
a3661 9
nmg_isect_eu_eu( eu1, vg1a, vg1b, dir1, eu2, verts, inters, tol )
struct edgeuse *eu1;
struct vertex_g *vg1a;
struct vertex_g *vg1b;
vect_t dir1;
struct edgeuse *eu2;
struct bu_ptbl *verts;
struct bu_ptbl *inters;
const struct bn_tol *tol;
d3777 1
a3777 5
nmg_isect_eu_fu( is, verts, eu, fu )
struct nmg_inter_struct *is;
struct bu_ptbl		*verts;
struct edgeuse		*eu;
struct faceuse          *fu;
d4119 1
a4119 6
nmg_isect_fu_jra( is, fu1, fu2, eu1_list, eu2_list)
struct nmg_inter_struct	*is;
struct faceuse		*fu1;
struct faceuse		*fu2;
struct bu_ptbl		*eu1_list;
struct bu_ptbl		*eu2_list;
d4260 1
a4260 6
nmg_isect_line2_face2pNEW( is, fu1, fu2, eu1_list, eu2_list )
struct nmg_inter_struct	*is;
struct faceuse		*fu1;
struct faceuse		*fu2;
struct bu_ptbl		*eu1_list;
struct bu_ptbl		*eu2_list;
d4967 1
a4967 5
nmg_is_eu_on_line3(eu, pt, dir, tol)
const struct edgeuse	*eu;
const point_t		pt;
const vect_t		dir;
const struct bn_tol	*tol;
d5012 1
a5012 4
nmg_find_eg_between_2fg(ofu1, fu2, tol)
const struct faceuse	*ofu1;
const struct faceuse	*fu2;
const struct bn_tol	*tol;
d5153 1
a5153 3
nmg_does_fu_use_eg( fu1, eg )
const struct faceuse	*fu1;
const long		*eg;
d5191 1
a5191 5
rt_line_on_plane( pt, dir, plane, tol )
const point_t	pt;
const vect_t	dir;
const plane_t	plane;
const struct bn_tol	*tol;
d5225 1
a5225 3
nmg_isect_two_face3p( is, fu1, fu2 )
struct nmg_inter_struct	*is;
struct faceuse		*fu1, *fu2;
d5473 1
a5473 4
nmg_cut_lu_into_coplanar_and_non( lu, pl, is )
struct loopuse *lu;
plane_t pl;
struct nmg_inter_struct *is;
d5944 1
a5944 4
nmg_isect_coplanar_edges( is, eu1_list, eu2_list )
struct nmg_inter_struct *is;
struct bu_ptbl *eu1_list;
struct bu_ptbl *eu2_list;
d6420 1
a6420 4
nmg_check_radial_angles( str, s, tol )
char *str;
struct shell *s;
const struct bn_tol *tol;
d6547 1
a6547 3
nmg_isect_nearly_coplanar_faces( is, fu1, fu2 )
struct nmg_inter_struct	*is;
struct faceuse *fu1,*fu2;
d7099 1
a7099 5
nmg_faces_can_be_intersected( bs, fu1, fu2, tol )
struct nmg_inter_struct *bs;
const struct faceuse *fu1;
const struct faceuse *fu2;
const struct bn_tol *tol;
d7274 1
a7274 4
nmg_isect_two_generic_faces(fu1, fu2, tol)
struct faceuse		*fu1;
struct faceuse		*fu2;
const struct bn_tol	*tol;
d7590 1
a7590 4
nmg_isect_edge3p_edge3p( is, eu1, eu2 )
struct nmg_inter_struct	*is;
struct edgeuse		*eu1;
struct edgeuse		*eu2;
d7725 1
a7725 4
nmg_isect_vertex3_edge3p( is, vu1, eu2 )
struct nmg_inter_struct		*is;
struct vertexuse	*vu1;
struct edgeuse		*eu2;
d7793 1
a7793 4
nmg_isect_edge3p_shell( is, eu1, s2 )
struct nmg_inter_struct		*is;
struct edgeuse		*eu1;
struct shell		*s2;
d7919 1
a7919 4
nmg_crackshells(s1, s2, tol)
struct shell		*s1;
struct shell		*s2;
const struct bn_tol	*tol;
d8132 1
a8132 2
nmg_fu_touchingloops(fu)
const struct faceuse	*fu;
@


11.63
log
@quelled a warning on a potentially unset variable (redundant set statement) read
@
text
@d45 1
a45 1
 *	This software is Copyright (C) 1994 by the United States Army
d49 1
a49 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_inter.c,v 11.62 2002/08/20 17:08:04 jra Exp $ (ARL)";
@


11.63.6.1
log
@merge from HEAD
@
text
@d45 1
a45 1
 *	This software is Copyright (C) 1994-2004 by the United States Army
d49 1
a49 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_inter.c,v 11.64 2004/02/02 17:39:23 morrison Exp $ (ARL)";
@


11.63.6.2
log
@merge from head
@
text
@d49 1
a49 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_inter.c,v 11.63.6.1 2004/02/12 18:37:44 erikg Exp $ (ARL)";
@


11.62
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d49 1
a49 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_inter.c,v 11.60 2001/04/20 22:29:50 morrison Exp $ (ARL)";
d1839 2
a1840 1
vu1_final = vu1_final = (struct vertexuse *)NULL;	/* XXX HACK HACK -- shut off error checking */
@


11.62.4.1
log
@sync to HEAD...
@
text
@d45 1
a45 1
 *	This software is Copyright (C) 1994-2004 by the United States Army
d49 1
a49 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/nmg_inter.c,v 11.64 2004/02/02 17:39:23 morrison Exp $ (ARL)";
d1839 1
a1839 2
                /* XXX HACK HACK -- shut off error checking */
                vu1_final = vu2_final = (struct vertexuse *)NULL;
@


11.62.2.1
log
@Initial ANSIfication
@
text
@d49 1
a49 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_inter.c,v 11.62 2002/08/20 17:08:04 jra Exp $ (ARL)";
d88 4
a91 1
nmg_make_dualvu(struct vertex *v, struct faceuse *fu, const struct bn_tol *tol)
d196 5
a200 5
nmg_enlist_vu(struct nmg_inter_struct *is, const struct vertexuse *vu, struct vertexuse *dualvu, fastf_t dist)
                       	    
                      	    
                	        		/* vu's dual in other shell.  May be NULL */
       			     			/* distance along intersect ray for this vu */
d418 5
a422 5
nmg_get_2d_vertex(fastf_t *v2d, struct vertex *v, struct nmg_inter_struct *is, const long int *assoc_use)
       			    		/* a 3-tuple */
             		   
                       	    
          		           	/* ptr to faceuse/edgeuse associated w/2d projection */
d550 3
a552 1
nmg_isect2d_prep(struct nmg_inter_struct *is, const long int *assoc_use)
d653 2
a654 1
nmg_isect2d_cleanup(struct nmg_inter_struct *is)
d677 1
a677 1
nmg_isect2d_final_cleanup(void)
d701 4
a704 1
nmg_isect_vert2p_face2p(struct nmg_inter_struct *is, struct vertexuse *vu1, struct faceuse *fu2)
d787 4
a790 1
nmg_isect_3vertex_3face(struct nmg_inter_struct *is, struct vertexuse *vu, struct faceuse *fu)
d845 5
a849 5
nmg_break_3edge_at_plane(const fastf_t *hit_pt, struct faceuse *fu2, struct nmg_inter_struct *is, struct edgeuse *eu1)
             		       
              		     		/* The face that eu intersects */
                            
              		     		/* Edge to be broken (in fu1) */
d1050 5
a1054 5
nmg_break_eu_on_v(struct edgeuse *eu1, struct vertex *v2, struct faceuse *fu, struct nmg_inter_struct *is)
              		     
             		    
              		    	/* for plane equation of (either) face */
                       	    
d1138 4
a1141 1
nmg_break_eg_on_v(const struct edge_g_lseg *eg, struct vertex *v, const struct bn_tol *tol)
d1238 7
a1244 7
nmg_isect_2colinear_edge2p(struct edgeuse *eu1, struct edgeuse *eu2, struct faceuse *fu, struct nmg_inter_struct *is, struct bu_ptbl *l1, struct bu_ptbl *l2)
              	     
              	     
              		    	/* for plane equation of (either) face */
                       	    
              		    	/* optional: list of new eu1 pieces */
              		    	/* optional: list of new eu2 pieces */
d1335 6
a1340 6
nmg_isect_edge2p_edge2p(struct nmg_inter_struct *is, struct edgeuse *eu1, struct edgeuse *eu2, struct faceuse *fu1, struct faceuse *fu2)
                       	    
              		     
              		     
              		     		/* fu of eu1, for plane equation */
              		     		/* fu of eu2, for error checks */
d1708 4
a1711 1
nmg_isect_wireedge3p_face3p(struct nmg_inter_struct *is, struct edgeuse *eu1, struct faceuse *fu2)
d2014 4
a2017 1
nmg_isect_wireloop3p_face3p(struct nmg_inter_struct *bs, struct loopuse *lu, struct faceuse *fu)
d2102 3
a2104 1
nmg_isect_construct_nice_ray(struct nmg_inter_struct *is, struct faceuse *fu2)
d2193 5
a2197 5
nmg_isect_edge2p_face2p(struct nmg_inter_struct *is, struct edgeuse *eu1, struct faceuse *fu2, struct faceuse *fu1)
                       	    
              		     		/* edge to be intersected w/fu2 */
              		     		/* face to be intersected w/eu1 */
              		     		/* fu that eu1 is from */
d2352 4
a2355 4
nmg_enlist_one_vu(struct nmg_inter_struct *is, const struct vertexuse *vu, fastf_t dist)
                       	    
                      	    
       			     			/* distance along intersect ray for this vu */
d2431 3
a2433 1
nmg_coplanar_face_vertex_fuse(struct faceuse *fu1, struct faceuse *fu2, struct bn_tol *tol)
d2489 3
a2491 1
nmg_isect_two_face2p_jra(struct nmg_inter_struct *is, struct faceuse *fu1, struct faceuse *fu2)
d3047 6
a3052 1
nmg_isect_line2_edge2p(struct nmg_inter_struct *is, struct bu_ptbl *list, struct edgeuse *eu1, struct faceuse *fu1, struct faceuse *fu2)
d3215 4
a3218 1
nmg_isect_line2_vertex2(struct nmg_inter_struct *is, struct vertexuse *vu1, struct faceuse *fu1)
d3249 4
a3252 1
nmg_isect_two_ptbls(struct nmg_inter_struct *is, const struct bu_ptbl *t1, const struct bu_ptbl *t2)
d3328 5
a3332 1
nmg_find_eg_on_line(const long int *magic_p, const fastf_t *pt, const fastf_t *dir, const struct bn_tol *tol)
d3383 2
a3384 1
nmg_k0eu(struct vertex *v)
d3424 7
a3430 7
nmg_repair_v_near_v(struct vertex *hit_v, struct vertex *v, const struct edge_g_lseg *eg1, const struct edge_g_lseg *eg2, int bomb, const struct bn_tol *tol)
             		       
             		   
                        		     		/* edge_g_lseg of hit_v */
                        		     		/* edge_g_lseg of v */
   			     
                   	     
d3497 7
a3503 7
nmg_search_v_eg(const struct edgeuse *eu, int second, const struct edge_g_lseg *eg1, const struct edge_g_lseg *eg2, register struct vertex *hit_v, const struct bn_tol *tol)
                    		    
   				       		/* 2nd vu on eu, not 1st */
                        	     
                        	     
                      		       		/* often will be NULL */
                   		     
d3579 4
a3582 1
nmg_common_v_2eg(struct edge_g_lseg *eg1, struct edge_g_lseg *eg2, const struct bn_tol *tol)
d3616 5
a3620 1
nmg_is_vertex_on_inter(struct vertex *v, struct faceuse *fu1, struct faceuse *fu2, struct nmg_inter_struct *is)
d3668 7
a3674 1
nmg_isect_eu_verts(struct edgeuse *eu, struct vertex_g *vg1, struct vertex_g *vg2, struct bu_ptbl *verts, struct bu_ptbl *inters, const struct bn_tol *tol)
d3716 9
a3724 1
nmg_isect_eu_eu(struct edgeuse *eu1, struct vertex_g *vg1a, struct vertex_g *vg1b, fastf_t *dir1, struct edgeuse *eu2, struct bu_ptbl *verts, struct bu_ptbl *inters, const struct bn_tol *tol)
d3840 5
a3844 1
nmg_isect_eu_fu(struct nmg_inter_struct *is, struct bu_ptbl *verts, struct edgeuse *eu, struct faceuse *fu)
d4186 6
a4191 1
nmg_isect_fu_jra(struct nmg_inter_struct *is, struct faceuse *fu1, struct faceuse *fu2, struct bu_ptbl *eu1_list, struct bu_ptbl *eu2_list)
d4332 6
a4337 1
nmg_isect_line2_face2pNEW(struct nmg_inter_struct *is, struct faceuse *fu1, struct faceuse *fu2, struct bu_ptbl *eu1_list, struct bu_ptbl *eu2_list)
d5044 5
a5048 1
nmg_is_eu_on_line3(const struct edgeuse *eu, const fastf_t *pt, const fastf_t *dir, const struct bn_tol *tol)
d5093 4
a5096 1
nmg_find_eg_between_2fg(const struct faceuse *ofu1, const struct faceuse *fu2, const struct bn_tol *tol)
d5237 3
a5239 1
nmg_does_fu_use_eg(const struct faceuse *fu1, const long int *eg)
d5277 5
a5281 1
rt_line_on_plane(const fastf_t *pt, const fastf_t *dir, const fastf_t *plane, const struct bn_tol *tol)
d5315 3
a5317 1
nmg_isect_two_face3p(struct nmg_inter_struct *is, struct faceuse *fu1, struct faceuse *fu2)
d5565 4
a5568 1
nmg_cut_lu_into_coplanar_and_non(struct loopuse *lu, fastf_t *pl, struct nmg_inter_struct *is)
d6039 4
a6042 1
nmg_isect_coplanar_edges(struct nmg_inter_struct *is, struct bu_ptbl *eu1_list, struct bu_ptbl *eu2_list)
d6518 4
a6521 1
nmg_check_radial_angles(char *str, struct shell *s, const struct bn_tol *tol)
d6648 3
a6650 1
nmg_isect_nearly_coplanar_faces(struct nmg_inter_struct *is, struct faceuse *fu1, struct faceuse *fu2)
d7202 5
a7206 1
nmg_faces_can_be_intersected(struct nmg_inter_struct *bs, const struct faceuse *fu1, const struct faceuse *fu2, const struct bn_tol *tol)
d7381 4
a7384 1
nmg_isect_two_generic_faces(struct faceuse *fu1, struct faceuse *fu2, const struct bn_tol *tol)
d7700 4
a7703 1
nmg_isect_edge3p_edge3p(struct nmg_inter_struct *is, struct edgeuse *eu1, struct edgeuse *eu2)
d7838 4
a7841 1
nmg_isect_vertex3_edge3p(struct nmg_inter_struct *is, struct vertexuse *vu1, struct edgeuse *eu2)
d7909 4
a7912 1
nmg_isect_edge3p_shell(struct nmg_inter_struct *is, struct edgeuse *eu1, struct shell *s2)
d8038 4
a8041 1
nmg_crackshells(struct shell *s1, struct shell *s2, const struct bn_tol *tol)
d8254 2
a8255 1
nmg_fu_touchingloops(const struct faceuse *fu)
@


11.62.2.2
log
@sync branch with HEAD
@
text
@d45 1
a45 1
 *	This software is Copyright (C) 1994-2004 by the United States Army
d49 1
a49 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d1821 1
a1821 2
                /* XXX HACK HACK -- shut off error checking */
                vu1_final = vu2_final = (struct vertexuse *)NULL;
@


11.61
log
@Converted from K&R to ANSI C - RFH
@
text
@d88 4
a91 1
nmg_make_dualvu(struct vertex *v, struct faceuse *fu, const struct bn_tol *tol)
d196 5
a200 5
nmg_enlist_vu(struct nmg_inter_struct *is, const struct vertexuse *vu, struct vertexuse *dualvu, fastf_t dist)
                       	    
                      	    
                	        		/* vu's dual in other shell.  May be NULL */
       			     			/* distance along intersect ray for this vu */
d418 5
a422 5
nmg_get_2d_vertex(fastf_t *v2d, struct vertex *v, struct nmg_inter_struct *is, const long int *assoc_use)
       			    		/* a 3-tuple */
             		   
                       	    
          		           	/* ptr to faceuse/edgeuse associated w/2d projection */
d550 3
a552 1
nmg_isect2d_prep(struct nmg_inter_struct *is, const long int *assoc_use)
d653 2
a654 1
nmg_isect2d_cleanup(struct nmg_inter_struct *is)
d677 1
a677 1
nmg_isect2d_final_cleanup(void)
d701 4
a704 1
nmg_isect_vert2p_face2p(struct nmg_inter_struct *is, struct vertexuse *vu1, struct faceuse *fu2)
d787 4
a790 1
nmg_isect_3vertex_3face(struct nmg_inter_struct *is, struct vertexuse *vu, struct faceuse *fu)
d845 5
a849 5
nmg_break_3edge_at_plane(const fastf_t *hit_pt, struct faceuse *fu2, struct nmg_inter_struct *is, struct edgeuse *eu1)
             		       
              		     		/* The face that eu intersects */
                            
              		     		/* Edge to be broken (in fu1) */
d1050 5
a1054 5
nmg_break_eu_on_v(struct edgeuse *eu1, struct vertex *v2, struct faceuse *fu, struct nmg_inter_struct *is)
              		     
             		    
              		    	/* for plane equation of (either) face */
                       	    
d1138 4
a1141 1
nmg_break_eg_on_v(const struct edge_g_lseg *eg, struct vertex *v, const struct bn_tol *tol)
d1238 7
a1244 7
nmg_isect_2colinear_edge2p(struct edgeuse *eu1, struct edgeuse *eu2, struct faceuse *fu, struct nmg_inter_struct *is, struct bu_ptbl *l1, struct bu_ptbl *l2)
              	     
              	     
              		    	/* for plane equation of (either) face */
                       	    
              		    	/* optional: list of new eu1 pieces */
              		    	/* optional: list of new eu2 pieces */
d1335 6
a1340 6
nmg_isect_edge2p_edge2p(struct nmg_inter_struct *is, struct edgeuse *eu1, struct edgeuse *eu2, struct faceuse *fu1, struct faceuse *fu2)
                       	    
              		     
              		     
              		     		/* fu of eu1, for plane equation */
              		     		/* fu of eu2, for error checks */
d1708 4
a1711 1
nmg_isect_wireedge3p_face3p(struct nmg_inter_struct *is, struct edgeuse *eu1, struct faceuse *fu2)
d2014 4
a2017 1
nmg_isect_wireloop3p_face3p(struct nmg_inter_struct *bs, struct loopuse *lu, struct faceuse *fu)
d2102 3
a2104 1
nmg_isect_construct_nice_ray(struct nmg_inter_struct *is, struct faceuse *fu2)
d2193 5
a2197 5
nmg_isect_edge2p_face2p(struct nmg_inter_struct *is, struct edgeuse *eu1, struct faceuse *fu2, struct faceuse *fu1)
                       	    
              		     		/* edge to be intersected w/fu2 */
              		     		/* face to be intersected w/eu1 */
              		     		/* fu that eu1 is from */
d2352 4
a2355 4
nmg_enlist_one_vu(struct nmg_inter_struct *is, const struct vertexuse *vu, fastf_t dist)
                       	    
                      	    
       			     			/* distance along intersect ray for this vu */
d2431 3
a2433 1
nmg_coplanar_face_vertex_fuse(struct faceuse *fu1, struct faceuse *fu2, struct bn_tol *tol)
d2489 3
a2491 1
nmg_isect_two_face2p_jra(struct nmg_inter_struct *is, struct faceuse *fu1, struct faceuse *fu2)
d3047 6
a3052 1
nmg_isect_line2_edge2p(struct nmg_inter_struct *is, struct bu_ptbl *list, struct edgeuse *eu1, struct faceuse *fu1, struct faceuse *fu2)
d3215 4
a3218 1
nmg_isect_line2_vertex2(struct nmg_inter_struct *is, struct vertexuse *vu1, struct faceuse *fu1)
d3249 4
a3252 1
nmg_isect_two_ptbls(struct nmg_inter_struct *is, const struct bu_ptbl *t1, const struct bu_ptbl *t2)
d3328 5
a3332 1
nmg_find_eg_on_line(const long int *magic_p, const fastf_t *pt, const fastf_t *dir, const struct bn_tol *tol)
d3383 2
a3384 1
nmg_k0eu(struct vertex *v)
d3424 7
a3430 7
nmg_repair_v_near_v(struct vertex *hit_v, struct vertex *v, const struct edge_g_lseg *eg1, const struct edge_g_lseg *eg2, int bomb, const struct bn_tol *tol)
             		       
             		   
                        		     		/* edge_g_lseg of hit_v */
                        		     		/* edge_g_lseg of v */
   			     
                   	     
d3497 7
a3503 7
nmg_search_v_eg(const struct edgeuse *eu, int second, const struct edge_g_lseg *eg1, const struct edge_g_lseg *eg2, register struct vertex *hit_v, const struct bn_tol *tol)
                    		    
   				       		/* 2nd vu on eu, not 1st */
                        	     
                        	     
                      		       		/* often will be NULL */
                   		     
d3579 4
a3582 1
nmg_common_v_2eg(struct edge_g_lseg *eg1, struct edge_g_lseg *eg2, const struct bn_tol *tol)
d3616 5
a3620 1
nmg_is_vertex_on_inter(struct vertex *v, struct faceuse *fu1, struct faceuse *fu2, struct nmg_inter_struct *is)
d3668 7
a3674 1
nmg_isect_eu_verts(struct edgeuse *eu, struct vertex_g *vg1, struct vertex_g *vg2, struct bu_ptbl *verts, struct bu_ptbl *inters, const struct bn_tol *tol)
d3716 9
a3724 1
nmg_isect_eu_eu(struct edgeuse *eu1, struct vertex_g *vg1a, struct vertex_g *vg1b, fastf_t *dir1, struct edgeuse *eu2, struct bu_ptbl *verts, struct bu_ptbl *inters, const struct bn_tol *tol)
d3840 5
a3844 1
nmg_isect_eu_fu(struct nmg_inter_struct *is, struct bu_ptbl *verts, struct edgeuse *eu, struct faceuse *fu)
d4186 6
a4191 1
nmg_isect_fu_jra(struct nmg_inter_struct *is, struct faceuse *fu1, struct faceuse *fu2, struct bu_ptbl *eu1_list, struct bu_ptbl *eu2_list)
d4332 6
a4337 1
nmg_isect_line2_face2pNEW(struct nmg_inter_struct *is, struct faceuse *fu1, struct faceuse *fu2, struct bu_ptbl *eu1_list, struct bu_ptbl *eu2_list)
d5044 5
a5048 1
nmg_is_eu_on_line3(const struct edgeuse *eu, const fastf_t *pt, const fastf_t *dir, const struct bn_tol *tol)
d5093 4
a5096 1
nmg_find_eg_between_2fg(const struct faceuse *ofu1, const struct faceuse *fu2, const struct bn_tol *tol)
d5237 3
a5239 1
nmg_does_fu_use_eg(const struct faceuse *fu1, const long int *eg)
d5277 5
a5281 1
rt_line_on_plane(const fastf_t *pt, const fastf_t *dir, const fastf_t *plane, const struct bn_tol *tol)
d5315 3
a5317 1
nmg_isect_two_face3p(struct nmg_inter_struct *is, struct faceuse *fu1, struct faceuse *fu2)
d5565 4
a5568 1
nmg_cut_lu_into_coplanar_and_non(struct loopuse *lu, fastf_t *pl, struct nmg_inter_struct *is)
d6039 4
a6042 1
nmg_isect_coplanar_edges(struct nmg_inter_struct *is, struct bu_ptbl *eu1_list, struct bu_ptbl *eu2_list)
d6518 4
a6521 1
nmg_check_radial_angles(char *str, struct shell *s, const struct bn_tol *tol)
d6648 3
a6650 1
nmg_isect_nearly_coplanar_faces(struct nmg_inter_struct *is, struct faceuse *fu1, struct faceuse *fu2)
d7202 5
a7206 1
nmg_faces_can_be_intersected(struct nmg_inter_struct *bs, const struct faceuse *fu1, const struct faceuse *fu2, const struct bn_tol *tol)
d7381 4
a7384 1
nmg_isect_two_generic_faces(struct faceuse *fu1, struct faceuse *fu2, const struct bn_tol *tol)
d7700 4
a7703 1
nmg_isect_edge3p_edge3p(struct nmg_inter_struct *is, struct edgeuse *eu1, struct edgeuse *eu2)
d7838 4
a7841 1
nmg_isect_vertex3_edge3p(struct nmg_inter_struct *is, struct vertexuse *vu1, struct edgeuse *eu2)
d7909 4
a7912 1
nmg_isect_edge3p_shell(struct nmg_inter_struct *is, struct edgeuse *eu1, struct shell *s2)
d8038 4
a8041 1
nmg_crackshells(struct shell *s1, struct shell *s2, const struct bn_tol *tol)
d8254 2
a8255 1
nmg_fu_touchingloops(const struct faceuse *fu)
@


11.60
log
@CONST to const
@
text
@d49 1
a49 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_inter.c,v 11.59 2000/08/31 04:01:52 mike Exp $ (ARL)";
d88 1
a88 4
nmg_make_dualvu( v, fu, tol )
struct vertex *v;
struct faceuse *fu;
const struct bn_tol *tol;
d193 5
a197 5
nmg_enlist_vu( is, vu, dualvu, dist )
struct nmg_inter_struct	*is;
const struct vertexuse	*vu;
struct vertexuse	*dualvu;		/* vu's dual in other shell.  May be NULL */
fastf_t			dist;			/* distance along intersect ray for this vu */
d415 5
a419 5
nmg_get_2d_vertex( v2d, v, is, assoc_use )
point_t			v2d;		/* a 3-tuple */
struct vertex		*v;
struct nmg_inter_struct	*is;
const long		*assoc_use;	/* ptr to faceuse/edgeuse associated w/2d projection */
d547 1
a547 3
nmg_isect2d_prep( is, assoc_use )
struct nmg_inter_struct	*is;
const long		*assoc_use;
d648 1
a648 2
nmg_isect2d_cleanup(is)
struct nmg_inter_struct	*is;
d671 1
a671 1
nmg_isect2d_final_cleanup()
d695 1
a695 4
nmg_isect_vert2p_face2p(is, vu1, fu2)
struct nmg_inter_struct *is;
struct vertexuse	*vu1;
struct faceuse		*fu2;
d778 1
a778 4
nmg_isect_3vertex_3face(is, vu, fu)
struct nmg_inter_struct *is;
struct vertexuse *vu;
struct faceuse *fu;
d833 5
a837 5
nmg_break_3edge_at_plane(hit_pt, fu2, is, eu1)
const point_t		hit_pt;
struct faceuse		*fu2;		/* The face that eu intersects */
struct nmg_inter_struct *is;
struct edgeuse		*eu1;		/* Edge to be broken (in fu1) */
d1038 5
a1042 5
nmg_break_eu_on_v( eu1, v2, fu, is )
struct edgeuse		*eu1;
struct vertex		*v2;
struct faceuse		*fu;	/* for plane equation of (either) face */
struct nmg_inter_struct	*is;
d1126 1
a1126 4
nmg_break_eg_on_v( eg, v, tol )
const struct edge_g_lseg	*eg;
struct vertex		*v;
const struct bn_tol	*tol;
d1223 7
a1229 7
nmg_isect_2colinear_edge2p( eu1, eu2, fu, is, l1, l2 )
struct edgeuse	*eu1;
struct edgeuse	*eu2;
struct faceuse		*fu;	/* for plane equation of (either) face */
struct nmg_inter_struct	*is;
struct bu_ptbl		*l1;	/* optional: list of new eu1 pieces */
struct bu_ptbl		*l2;	/* optional: list of new eu2 pieces */
d1320 6
a1325 6
nmg_isect_edge2p_edge2p( is, eu1, eu2, fu1, fu2 )
struct nmg_inter_struct	*is;
struct edgeuse		*eu1;
struct edgeuse		*eu2;
struct faceuse		*fu1;		/* fu of eu1, for plane equation */
struct faceuse		*fu2;		/* fu of eu2, for error checks */
d1693 1
a1693 4
nmg_isect_wireedge3p_face3p(is, eu1, fu2)
struct nmg_inter_struct *is;
struct edgeuse		*eu1;
struct faceuse		*fu2;
d1996 1
a1996 4
nmg_isect_wireloop3p_face3p(bs, lu, fu)
struct nmg_inter_struct *bs;
struct loopuse *lu;
struct faceuse *fu;
d2081 1
a2081 3
nmg_isect_construct_nice_ray( is, fu2 )
struct nmg_inter_struct	*is;
struct faceuse		*fu2;
d2170 5
a2174 5
nmg_isect_edge2p_face2p( is, eu1, fu2, fu1 )
struct nmg_inter_struct	*is;
struct edgeuse		*eu1;		/* edge to be intersected w/fu2 */
struct faceuse		*fu2;		/* face to be intersected w/eu1 */
struct faceuse		*fu1;		/* fu that eu1 is from */
d2329 4
a2332 4
nmg_enlist_one_vu( is,   vu,  dist )
struct nmg_inter_struct	*is;
const struct vertexuse	*vu;
fastf_t			dist;			/* distance along intersect ray for this vu */
d2408 1
a2408 3
nmg_coplanar_face_vertex_fuse( fu1, fu2, tol )
struct faceuse *fu1, *fu2;
struct bn_tol *tol;
d2464 1
a2464 3
nmg_isect_two_face2p_jra( is, fu1, fu2 )
struct nmg_inter_struct	*is;
struct faceuse		*fu1, *fu2;
d3020 1
a3020 6
nmg_isect_line2_edge2p( is, list, eu1, fu1, fu2 )
struct nmg_inter_struct	*is;
struct bu_ptbl		*list;
struct edgeuse		*eu1;
struct faceuse		*fu1;
struct faceuse		*fu2;
d3183 1
a3183 4
nmg_isect_line2_vertex2( is, vu1, fu1 )
struct nmg_inter_struct	*is;
struct vertexuse	*vu1;
struct faceuse		*fu1;
d3214 1
a3214 4
nmg_isect_two_ptbls( is, t1, t2 )
struct nmg_inter_struct		*is;
const struct bu_ptbl		*t1;
const struct bu_ptbl		*t2;
d3290 1
a3290 5
nmg_find_eg_on_line( magic_p, pt, dir, tol )
const long		*magic_p;
const point_t		pt;
const vect_t		dir;
const struct bn_tol	*tol;
d3341 1
a3341 2
nmg_k0eu(v)
struct vertex	*v;
d3381 7
a3387 7
nmg_repair_v_near_v( hit_v, v, eg1, eg2, bomb, tol )
struct vertex		*hit_v;
struct vertex		*v;
const struct edge_g_lseg		*eg1;		/* edge_g_lseg of hit_v */
const struct edge_g_lseg		*eg2;		/* edge_g_lseg of v */
int			bomb;
const struct bn_tol	*tol;
d3454 7
a3460 7
nmg_search_v_eg( eu, second, eg1, eg2, hit_v, tol )
const struct edgeuse		*eu;
int				second;		/* 2nd vu on eu, not 1st */
const struct edge_g_lseg	*eg1;
const struct edge_g_lseg	*eg2;
register struct vertex		*hit_v;		/* often will be NULL */
const struct bn_tol		*tol;
d3536 1
a3536 4
nmg_common_v_2eg( eg1, eg2, tol )
struct edge_g_lseg	*eg1;
struct edge_g_lseg	*eg2;
const struct bn_tol	*tol;
d3570 1
a3570 5
nmg_is_vertex_on_inter( v, fu1, fu2, is )
struct vertex *v;
struct faceuse *fu1;
struct faceuse *fu2;
struct nmg_inter_struct *is;
d3618 1
a3618 7
nmg_isect_eu_verts( eu, vg1, vg2, verts, inters, tol )
struct edgeuse *eu;
struct vertex_g *vg1;
struct vertex_g *vg2;
struct bu_ptbl *verts;
struct bu_ptbl *inters;
const struct bn_tol *tol;
d3660 1
a3660 9
nmg_isect_eu_eu( eu1, vg1a, vg1b, dir1, eu2, verts, inters, tol )
struct edgeuse *eu1;
struct vertex_g *vg1a;
struct vertex_g *vg1b;
vect_t dir1;
struct edgeuse *eu2;
struct bu_ptbl *verts;
struct bu_ptbl *inters;
const struct bn_tol *tol;
d3776 1
a3776 5
nmg_isect_eu_fu( is, verts, eu, fu )
struct nmg_inter_struct *is;
struct bu_ptbl		*verts;
struct edgeuse		*eu;
struct faceuse          *fu;
d4118 1
a4118 6
nmg_isect_fu_jra( is, fu1, fu2, eu1_list, eu2_list)
struct nmg_inter_struct	*is;
struct faceuse		*fu1;
struct faceuse		*fu2;
struct bu_ptbl		*eu1_list;
struct bu_ptbl		*eu2_list;
d4259 1
a4259 6
nmg_isect_line2_face2pNEW( is, fu1, fu2, eu1_list, eu2_list )
struct nmg_inter_struct	*is;
struct faceuse		*fu1;
struct faceuse		*fu2;
struct bu_ptbl		*eu1_list;
struct bu_ptbl		*eu2_list;
d4966 1
a4966 5
nmg_is_eu_on_line3(eu, pt, dir, tol)
const struct edgeuse	*eu;
const point_t		pt;
const vect_t		dir;
const struct bn_tol	*tol;
d5011 1
a5011 4
nmg_find_eg_between_2fg(ofu1, fu2, tol)
const struct faceuse	*ofu1;
const struct faceuse	*fu2;
const struct bn_tol	*tol;
d5152 1
a5152 3
nmg_does_fu_use_eg( fu1, eg )
const struct faceuse	*fu1;
const long		*eg;
d5190 1
a5190 5
rt_line_on_plane( pt, dir, plane, tol )
const point_t	pt;
const vect_t	dir;
const plane_t	plane;
const struct bn_tol	*tol;
d5224 1
a5224 3
nmg_isect_two_face3p( is, fu1, fu2 )
struct nmg_inter_struct	*is;
struct faceuse		*fu1, *fu2;
d5472 1
a5472 4
nmg_cut_lu_into_coplanar_and_non( lu, pl, is )
struct loopuse *lu;
plane_t pl;
struct nmg_inter_struct *is;
d5943 1
a5943 4
nmg_isect_coplanar_edges( is, eu1_list, eu2_list )
struct nmg_inter_struct *is;
struct bu_ptbl *eu1_list;
struct bu_ptbl *eu2_list;
d6419 1
a6419 4
nmg_check_radial_angles( str, s, tol )
char *str;
struct shell *s;
const struct bn_tol *tol;
d6546 1
a6546 3
nmg_isect_nearly_coplanar_faces( is, fu1, fu2 )
struct nmg_inter_struct	*is;
struct faceuse *fu1,*fu2;
d7098 1
a7098 5
nmg_faces_can_be_intersected( bs, fu1, fu2, tol )
struct nmg_inter_struct *bs;
const struct faceuse *fu1;
const struct faceuse *fu2;
const struct bn_tol *tol;
d7273 1
a7273 4
nmg_isect_two_generic_faces(fu1, fu2, tol)
struct faceuse		*fu1;
struct faceuse		*fu2;
const struct bn_tol	*tol;
d7589 1
a7589 4
nmg_isect_edge3p_edge3p( is, eu1, eu2 )
struct nmg_inter_struct	*is;
struct edgeuse		*eu1;
struct edgeuse		*eu2;
d7724 1
a7724 4
nmg_isect_vertex3_edge3p( is, vu1, eu2 )
struct nmg_inter_struct		*is;
struct vertexuse	*vu1;
struct edgeuse		*eu2;
d7792 1
a7792 4
nmg_isect_edge3p_shell( is, eu1, s2 )
struct nmg_inter_struct		*is;
struct edgeuse		*eu1;
struct shell		*s2;
d7918 1
a7918 4
nmg_crackshells(s1, s2, tol)
struct shell		*s1;
struct shell		*s2;
const struct bn_tol	*tol;
d8131 1
a8131 2
nmg_fu_touchingloops(fu)
const struct faceuse	*fu;
@


11.59
log
@
lint
@
text
@d49 1
a49 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_inter.c,v 11.58 2000/08/31 04:00:58 mike Exp $ (ARL)";
d91 1
a91 1
CONST struct bn_tol *tol;
d198 1
a198 1
CONST struct vertexuse	*vu;
d422 1
a422 1
CONST long		*assoc_use;	/* ptr to faceuse/edgeuse associated w/2d projection */
d552 1
a552 1
CONST long		*assoc_use;
d846 1
a846 1
CONST point_t		hit_pt;
d1139 1
a1139 1
CONST struct edge_g_lseg	*eg;
d1141 1
a1141 1
CONST struct bn_tol	*tol;
d2225 1
a2225 1
	    fu2, (CONST struct edgeuse *)NULL, 0 );
d2354 1
a2354 1
CONST struct vertexuse	*vu;
d3251 2
a3252 2
CONST struct bu_ptbl		*t1;
CONST struct bu_ptbl		*t2;
d3254 2
a3255 2
	CONST struct edgeuse	**eu1;
	CONST struct edgeuse	**eu2;
d3262 2
a3263 2
	for( eu1 = (CONST struct edgeuse **)BU_PTBL_LASTADDR(t1);
	     eu1 >= (CONST struct edgeuse **)BU_PTBL_BASEADDR(t1); eu1--
d3275 2
a3276 2
		for( eu2 = (CONST struct edgeuse **)BU_PTBL_LASTADDR(t2);
		     eu2 >= (CONST struct edgeuse **)BU_PTBL_BASEADDR(t2); eu2--
d3329 4
a3332 4
CONST long		*magic_p;
CONST point_t		pt;
CONST vect_t		dir;
CONST struct bn_tol	*tol;
d3427 2
a3428 2
CONST struct edge_g_lseg		*eg1;		/* edge_g_lseg of hit_v */
CONST struct edge_g_lseg		*eg2;		/* edge_g_lseg of v */
d3430 1
a3430 1
CONST struct bn_tol	*tol;
d3498 1
a3498 1
CONST struct edgeuse		*eu;
d3500 2
a3501 2
CONST struct edge_g_lseg	*eg1;
CONST struct edge_g_lseg	*eg2;
d3503 1
a3503 1
CONST struct bn_tol		*tol;
d3582 1
a3582 1
CONST struct bn_tol	*tol;
d3674 1
a3674 1
CONST struct bn_tol *tol;
d3724 1
a3724 1
CONST struct bn_tol *tol;
d5045 4
a5048 4
CONST struct edgeuse	*eu;
CONST point_t		pt;
CONST vect_t		dir;
CONST struct bn_tol	*tol;
d5094 9
a5102 9
CONST struct faceuse	*ofu1;
CONST struct faceuse	*fu2;
CONST struct bn_tol	*tol;
{
	CONST struct faceuse	*fu1;
	CONST struct loopuse	*lu1;
	CONST struct face_g_plane	*fg1;
	CONST struct face_g_plane	*fg2;
	CONST struct face	*f1;
d5131 1
a5131 1
			CONST struct edgeuse	*eu1;
d5150 1
a5150 1
					CONST struct faceuse	*tfu;
d5238 2
a5239 2
CONST struct faceuse	*fu1;
CONST long		*eg;
d5241 1
a5241 1
	CONST struct loopuse	*lu1;
d5278 4
a5281 4
CONST point_t	pt;
CONST vect_t	dir;
CONST plane_t	plane;
CONST struct bn_tol	*tol;
d6521 1
a6521 1
CONST struct bn_tol *tol;
d7204 3
a7206 3
CONST struct faceuse *fu1;
CONST struct faceuse *fu2;
CONST struct bn_tol *tol;
d7384 1
a7384 1
CONST struct bn_tol	*tol;
d8041 1
a8041 1
CONST struct bn_tol	*tol;
d8255 1
a8255 1
CONST struct faceuse	*fu;
d8257 2
a8258 2
	CONST struct loopuse	*lu;
	CONST struct vertexuse	*vu;
@


11.58
log
@
lint
@
text
@d49 1
a49 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_inter.c,v 11.57 2000/08/21 02:02:32 butler Exp $ (ARL)";
d5792 1
a5792 1
		struct vertex *end1, *end2;
@


11.57
log
@Massive compilation warnings eliminated
@
text
@d49 1
a49 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_inter.c,v 11.56 2000/07/10 23:01:41 mike Exp $ (ARL)";
a2565 2
			struct vertex *hitv;
			struct vertexuse *hit_vu;
d2606 2
@


11.56
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d49 1
a49 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_inter.c,v 11.55 2000/04/01 03:00:58 mike Exp $ (ARL)";
d55 1
d62 1
d105 1
a105 1
	if( dualvu=nmg_find_v_in_face( v, fu ) )
d753 4
a756 1
			if( new_eu = nmg_break_eu_on_v( eu2, vu1->v_p, fu2, is ) ) {
d806 2
a807 1
	if (vup=nmg_find_v_in_face(vu->v_p, fu)) {
d1275 2
a1276 1
			if( eu[neu] = nmg_break_eu_on_v(eu[i],vu[j]->v_p,fu,is) )  {
d1832 1
a1832 1
		if (vu2_final=nmg_find_v_in_face(eu1->vu_p->v_p, fu2)) {
d1856 1
a1856 1
	if (vu2_final=nmg_find_v_in_face(v1a, fu2)) {
d2912 1
d3032 1
a3032 1

d5552 1
a5552 1
outfast:
d6499 1
d6515 1
a6515 1

d7648 1
a7648 1
    	    	struct model	*m = nmg_find_model( &fu1->l.magic );
d7929 1
a7929 1
	if( eu2 = nmg_find_matching_eu_in_s( eu1, s2 ) )  {
d7988 1
a7988 1
	if( eu2 = nmg_find_matching_eu_in_s( eu1, s2 ) )  {
d8261 1
a8261 1
	for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )  {
d8263 1
a8263 1
		if( vu = nmg_loop_touches_self( lu ) )  {
@


11.55
log
@
added externs from nmg_inter.c to raytrace.h
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_inter.c,v 11.54 2000/03/29 18:55:52 mike Exp $ (ARL)";
@


11.54
log
@
Moved pdv_ to libbn/plot3.c
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_inter.c,v 11.53 1999/12/30 15:26:55 jra Exp $ (ARL)";
a66 26
struct nmg_inter_struct {
	long		magic;
	struct bu_ptbl	*l1;		/* vertexuses on the line of */
	struct bu_ptbl *l2;		/* intersection between planes */
	fastf_t		*mag1;		/* Distances along intersection line */
	fastf_t		*mag2;		/* for each vertexuse in l1 and l2. */
	int		mag_len;	/* Array size of mag1 and mag2 */
	struct shell	*s1;
	struct shell	*s2;
	struct faceuse	*fu1;		/* null if l1 comes from a wire */
	struct faceuse	*fu2;		/* null if l2 comes from a wire */
	struct bn_tol	tol;
	int		coplanar;	/* a flag */
	struct edge_g_lseg	*on_eg;		/* edge_g for line of intersection */
	point_t		pt;		/* 3D line of intersection */
	vect_t		dir;
	point_t		pt2d;		/* 2D projection of isect line */
	vect_t		dir2d;
	fastf_t		*vert2d;	/* Array of 2d vertex projections [index] */
	int		maxindex;	/* size of vert2d[] */
	mat_t		proj;		/* Matrix to project onto XY plane */
	CONST long	*twod;		/* ptr to face/edge of 2d projection */
};
#define NMG_INTER_STRUCT_MAGIC	0x99912120
#define NMG_CK_INTER_STRUCT(_p)	NMG_CKMAG(_p, NMG_INTER_STRUCT_MAGIC, "nmg_inter_struct")

a74 7
RT_EXTERN(void			nmg_isect2d_prep, (struct nmg_inter_struct *is,
				CONST long *assoc_use));
RT_EXTERN(CONST struct vertexuse *nmg_loop_touches_self, (CONST struct loopuse *lu));
RT_EXTERN(void			nmg_isect_line2_face2pNEW, (struct nmg_inter_struct *is,
				struct faceuse *fu1, struct faceuse *fu2,
				struct bu_ptbl *eu1_list,
				struct bu_ptbl *eu2_list));
d76 1
a76 1
static int	nmg_isect_edge2p_face2p RT_ARGS((struct nmg_inter_struct *is,
a78 10
struct edgeuse *	nmg_break_eu_on_v RT_ARGS((struct edgeuse *eu1,
			struct vertex *v2, struct faceuse *fu,
			struct nmg_inter_struct *is));
RT_EXTERN(struct vertexuse *	nmg_enlist_vu, (struct nmg_inter_struct	*is,
				CONST struct vertexuse *vu,
				struct vertexuse *dualvu,
				fastf_t dist));
RT_EXTERN(void			nmg_isect2d_cleanup, (struct nmg_inter_struct *is));
RT_EXTERN(void			nmg_isect_vert2p_face2p, (struct nmg_inter_struct *is,
				struct vertexuse *vu1, struct faceuse *fu2));
d83 2
d2342 2
d3835 1
a3836 1
struct edgeuse		*eu;
d7195 2
a7196 1
CONST struct faceuse *fu1,*fu2;
d7373 2
a7374 1
struct faceuse		*fu1, *fu2;
@


11.53
log
@Eliminated some unused variables
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_inter.c,v 11.52 1999/07/02 22:19:25 mike Exp $ (ARL)";
a124 15

/* XXX move to libplot3/plot3.c */
void
pdv_3ray( fp, pt, dir, t )
FILE		*fp;
CONST point_t	pt;
CONST vect_t	dir;
double		t;
{
	point_t	tip;

	VJOIN1( tip, pt, t, dir );
	pdv_3move( fp, pt );
	pdv_3cont( fp, tip );
}
@


11.52
log
@
Removed dependence on compat4.h
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_inter.c,v 11.51 1999/06/03 01:39:14 mike Exp $ (ARL)";
a260 1
	int			old_mag_len;
a287 1
			old_mag_len = is->mag_len;
a317 1
			old_mag_len = is->mag_len;
a397 1
			old_mag_len = is->mag_len;
a419 1
			old_mag_len = is->mag_len;
a2404 5
	struct loopuse		*lu;		/* lu of new self-loop */
	struct faceuse		*dualfu = (struct faceuse *)NULL; /* faceuse of vu's dual */
	struct shell		*duals = (struct shell *)NULL;	/* shell of vu's dual */
	struct faceuse		*fuv;		/* faceuse of vu */
	int			old_mag_len;
a2412 1
	fuv = nmg_find_fu_of_vu( vu );
a2418 1
			old_mag_len = is->mag_len;
a2440 1
			old_mag_len = is->mag_len;
a2585 2
		point_t pt1a,pt1b;	/* 2D */
		vect_t vt1;		/* 2D */
a2607 2
			point_t pt2a,pt2b;	/* 2D */
			vect_t vt2;		/* 2D */
a3901 1
	int intersections=0;
a4103 1
			struct loopuse *lu;
a4241 1
	plane_t pl1,pl2;
a4255 3
	NMG_GET_FU_PLANE( pl2, fu2 );
	NMG_GET_FU_PLANE( pl1, fu1 );

a4470 1
			int code;
d4493 1
a4493 1
				code = rt_dist_pt3_line3( &dist, pca, is->pt, is->dir, vg->coord, &(is->tol) );
a5369 4
	plane_t			n1, n2;
    	fastf_t			dot;
	fastf_t			ang;
    	vect_t			unit_e_dir;
d5618 1
a5618 2
	struct edgeuse *eu_next;
	struct vertex_g *vg1,*vg2;
d5621 1
a5621 1
	fastf_t dist,dist1,dist2;
a5664 1
		vg1 = vg2;
a5789 1
			struct loopuse *new_lu;
a6117 1
		point_t pt1a,pt1b;
a6158 1
			point_t pt2a,pt2b;
a7429 2
	struct loopuse	*lu;
	struct edgeuse	*eu;
@


11.51
log
@
sed4
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_inter.c,v 11.50 1998/03/12 20:57:38 jra Exp $ (ARL)";
d3659 1
a3659 1
	for( BU_LIST_FOR( midway, rt_list, &eg1->eu_hd2 ) )  {
@


11.50
log
@Added nmg_coplanar_face_vertex_fuse() and modified nmg_isect_two_face2p_jra() to do
calculations in 3d for consistency.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 11.49 1997/09/18 20:32:45 jra Exp jra $ (ARL)";
d301 2
a302 2
				is->mag1 = (fastf_t *)rt_calloc( is->mag_len, sizeof( fastf_t ), "is->mag1" );
				is->mag2 = (fastf_t *)rt_calloc( is->mag_len, sizeof( fastf_t ), "is->mag2" );
d332 2
a333 2
				is->mag1 = (fastf_t *)rt_calloc( is->mag_len, sizeof( fastf_t ), "is->mag1" );
				is->mag2 = (fastf_t *)rt_calloc( is->mag_len, sizeof( fastf_t ), "is->mag2" );
d413 2
a414 2
				is->mag1 = (fastf_t *)rt_calloc( is->mag_len, sizeof( fastf_t ), "is->mag1" );
				is->mag2 = (fastf_t *)rt_calloc( is->mag_len, sizeof( fastf_t ), "is->mag2" );
d436 2
a437 2
				is->mag1 = (fastf_t *)rt_calloc( is->mag_len, sizeof( fastf_t ), "is->mag1" );
				is->mag2 = (fastf_t *)rt_calloc( is->mag_len, sizeof( fastf_t ), "is->mag2" );
d639 1
a639 1
	is->vert2d = (fastf_t *)rt_malloc( is->maxindex * 3 * sizeof(fastf_t), "vert2d[]");
d670 1
a670 1
		mat_fromto( is->proj, n, to );
d694 1
a694 1
		mat_fromto( is->proj, eg->e_dir, to );
d720 1
a720 1
	rt_free( (char *)is->vert2d, "vert2d");
d2344 2
a2345 2
	mag1 = (fastf_t *)rt_calloc( is->mag_len, sizeof( fastf_t ), "mag1" );
	mag2 = (fastf_t *)rt_calloc( is->mag_len, sizeof( fastf_t ), "mag2" );
d2391 1
a2391 1
		rt_free( (char *)mag1, "nmg_isect_edge2p_face2p: mag1" );
d2393 1
a2393 1
		rt_free( (char *)mag2, "nmg_isect_edge2p_face2p: mag2" );
d2442 2
a2443 2
				is->mag1 = (fastf_t *)rt_calloc( is->mag_len, sizeof( fastf_t ), "is->mag1" );
				is->mag2 = (fastf_t *)rt_calloc( is->mag_len, sizeof( fastf_t ), "is->mag2" );
d2465 2
a2466 2
				is->mag1 = (fastf_t *)rt_calloc( is->mag_len, sizeof( fastf_t ), "is->mag1" );
				is->mag2 = (fastf_t *)rt_calloc( is->mag_len, sizeof( fastf_t ), "is->mag2" );
d2578 2
a2579 2
	mag1 = (fastf_t *)rt_calloc( is->mag_len, sizeof( fastf_t ), "mag1" );
	mag2 = (fastf_t *)rt_calloc( is->mag_len, sizeof( fastf_t ), "mag2" );
d2943 1
a2943 1
		rt_free( (char *)mag1, "mag1" );
d2945 1
a2945 1
		rt_free( (char *)mag2, "mag2" );
d3004 1
a3004 1
	tags = (unsigned char *)rt_calloc( tagsize, 1, "nmg_isect_two_face2p() tags[]" );
d3091 1
a3091 1
	rt_free( (char *)tags, "tags[]" );
d4175 1
a4175 1
	inter_dist = (fastf_t *)rt_calloc( BU_PTBL_END( &inters ), sizeof( fastf_t ),
d4240 1
a4240 1
	rt_free( (char *)inter_dist, "nmg_isect_eu_fu: inter_dist" );
d5509 2
a5510 2
	mag1 = (fastf_t *)rt_calloc( is->mag_len, sizeof( fastf_t ), "mag1" );
	mag2 = (fastf_t *)rt_calloc( is->mag_len, sizeof( fastf_t ), "mag2" );
d5622 1
a5622 1
		rt_free( (char *)mag1, "nmg_isect_two_face3p: mag1" );
d5624 1
a5624 1
		rt_free( (char *)mag2, "nmg_isect_two_face3p: mag2" );
d6765 2
a6766 2
	mag1 = (fastf_t *)rt_calloc( is->mag_len, sizeof( fastf_t ), "mag1" );
	mag2 = (fastf_t *)rt_calloc( is->mag_len, sizeof( fastf_t ), "mag2" );
d7180 1
a7180 1
		rt_free( (char *)mag1, "mag1" );
d7182 1
a7182 1
		rt_free( (char *)mag2, "mag2" );
d8175 1
a8175 1
	flags = (char *)rt_calloc( flag_len, sizeof(char),
d8307 1
a8307 1
	rt_free( (char *)flags, "nmg_crackshells flags[]" );
@


11.49
log
@Mods for use of pmalloc in TNURB raytracing.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 11.48 1997/07/11 14:56:17 jra Exp $ (ARL)";
d2491 58
d2569 2
d2613 1
a2613 1

d2617 1
a2617 1

d2621 1
d2625 1
d2635 1
d2639 5
a2643 1

d2646 4
d2708 21
a2728 11
					if (rt_g.NMG_debug & DEBUG_POLYSECT)
						bu_log( "Splitting eu1 x%x\n", eu1 );
					new_eu = nmg_esplit( hitv, eu1, 1 );
					hitv = new_eu->vu_p->v_p;
					if( !hitv->vg_p )
						nmg_vertex_gv( hitv, hit_pt );
					vg1b = eu1->eumate_p->vu_p->v_p->vg_p;
					VSUB2( vt1_3d, vg1b->coord, vg1a->coord );
					bu_ptbl_ins( &eu1_list, (long *)new_eu );
					nmg_get_2d_vertex( pt1b, eu1->eumate_p->vu_p->v_p, is, (long *)fu1 );
					VSUB2( vt1, pt1b, pt1a );
d2732 6
a2737 1
					if (rt_g.NMG_debug & DEBUG_POLYSECT)
d2739 14
a2752 6
						vect_t tmp1, tmp2;
						VSUB2( tmp1, hit_pt, eu2->vu_p->v_p->vg_p->coord )
						VSUB2( tmp2, hit_pt, eu2->eumate_p->vu_p->v_p->vg_p->coord )
						bu_log( "Splitting eu2 x%x\n",  eu2 );
						bu_log( "Distance to hit_pt = %g from vu1, %g from vu2\n",
							MAGNITUDE( tmp1 ), MAGNITUDE( tmp2 ) );
a2753 5
					new_eu = nmg_esplit( hitv, eu2, 1 );
					hitv = new_eu->vu_p->v_p;
					if( !hitv->vg_p )
						nmg_vertex_gv( hitv, hit_pt );
					bu_ptbl_ins( &eu2_list, (long *)new_eu );
@


11.48
log
@Mod to nmg_cut_lu_into_coplanar_and_non() to order the vertices on the cut list.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 11.47 1997/01/21 20:43:36 jra Exp jra $ (ARL)";
d2623 1
a2623 1
					bu_log( "eus x%x and x%x intersect #%d at (%g %g %g)\n",
d2652 4
d2657 3
d6279 1
a6279 1
						bu_log( "Splitting eu2 x%x\n",  eu2 );
@


11.47
log
@Temporary kludge for ignoring intersecting wire loops of a single vertex.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 11.46 1996/12/19 14:04:07 jra Exp jra $ (ARL)";
d5768 96
d5880 3
d5905 1
a5905 1
			break;
@


11.46
log
@Solaris complains about passing (void *)NULL where it should be (void (*)())NULL.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 11.45 1996/09/27 08:27:30 mike Exp jra $ (ARL)";
d8062 3
a8065 1
		/* XXX Can there be lone-vertex loops here? */
@


11.45
log
@Converted to using proper routine names for LIBBU and LIBBN routines.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 11.44 1996/07/12 12:17:41 jra Exp mike $ (ARL)";
d3622 1
a3622 1
		(void *)NULL, (void *)NULL, (char *)NULL, 0, 0, &is->tol );
d3627 1
a3627 1
		(void *)NULL, (void *)NULL, (char *)NULL, 0, 0, &is->tol );
@


11.44
log
@Minor Mods for IRIX 6.2
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 11.43 1996/07/02 14:27:47 jra Exp jra $ (ARL)";
d69 2
a70 2
	struct nmg_ptbl	*l1;		/* vertexuses on the line of */
	struct nmg_ptbl *l2;		/* intersection between planes */
d78 1
a78 1
	struct rt_tol	tol;
d106 2
a107 2
				struct nmg_ptbl *eu1_list,
				struct nmg_ptbl *eu2_list));
d145 1
a145 1
CONST struct rt_tol *tol;
d153 1
a153 1
	RT_CK_TOL( tol );
d156 1
a156 1
		rt_log( "nmg_make_dualvu( v=x%x, fu=x%x )\n", v, fu );
d162 1
a162 1
			rt_log( "\tdualvu already exists (x%x)\n", dualvu );
d170 2
a171 2
		rt_log( "\tLooking for an edge to split\n" );
	for( RT_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
d175 1
a175 1
		if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d178 1
a178 1
		for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d185 1
a185 1
				rt_log( "\tChecking eu x%x (%f %f %f) <-> (%f %f %f)\n",
d190 1
a190 1
			code = rt_dist_pt3_lseg3( &dist, pca,
d196 1
a196 1
				rt_log( "rt_dist_pt3_lseg3 returns %d, dist=%f\n", code, dist );
d207 1
a207 1
				rt_log( "nmg_make_dualvu is splitting eu x%x at v x%x\n", eu, v );
d218 1
a218 1
		rt_log( "nmg_make_dualvu is makeing a self_loop (lu=x%x, vu=x%x) for v=x%x\n", lu, RT_LIST_FIRST( vertexuse, &lu->down_hd ), v );
d220 1
a220 1
	return( RT_LIST_FIRST( vertexuse, &lu->down_hd ) );
d270 2
a271 2
	if( is->mag_len <= NMG_TBL_END( is->l1 ) || is->mag_len <= NMG_TBL_END( is->l2 ) )
		rt_log( "Array for distances to vertexuses is too small (%d)\n" , is->mag_len );
d275 2
a276 2
	if( rt_distsq_line3_pt3(is->pt, is->dir, vu->v_p->vg_p->coord) > is->tol.dist_sq )  {
		rt_log("nmg_enlist_vu() WARNING: vu=x%x, v=x%x not within tolerance of intersect line\n",
d286 2
a287 2
		nmg_tbl( is->l1, TBL_INS_UNIQUE, (long *)&vu->l.magic );
		if( is->mag_len <= NMG_TBL_END( is->l1 ) )
d300 1
a300 1
				is->mag_len = 2*(NMG_TBL_END( is->l1 ) + NMG_TBL_END( is->l2 ));
d307 1
a307 1
			is->mag1[nmg_tbl( is->l1, TBL_LOC, (long *)&vu->l.magic )] = dist;
d312 2
a313 2
			rt_log("fuv=x%x, fu1=x%x, fu2=x%x\n", fuv, is->fu1, is->fu2);
			rt_log( "\tvu=x%x (x%x)\n", vu, vu->v_p );
d317 2
a318 2
		nmg_tbl( is->l2, TBL_INS_UNIQUE, (long *)&vu->l.magic );
		if( is->mag_len <= NMG_TBL_END( is->l2 ) )
d331 1
a331 1
				is->mag_len = 2*(NMG_TBL_END( is->l1 ) + NMG_TBL_END( is->l2 ));
d338 1
a338 1
			is->mag2[nmg_tbl( is->l2, TBL_LOC, (long *)&vu->l.magic )] = dist;
d343 2
a344 2
			rt_log("fuv=x%x, fu1=x%x, fu2=x%x\n", fuv, is->fu1, is->fu2);
			rt_log( "\tvu=x%x (x%x)\n", vu, vu->v_p );
d348 1
a348 1
		rt_log("nmg_enlist_vu(vu=x%x,dv=x%x) sv=x%x, s1=x%x, s2=x%x\n",
d356 1
a356 1
			rt_log("nmg_enlist_vu(vu=x%x,dv=x%x) sv=x%x, s1=x%x, s2=x%x, sdual=x%x\n",
d372 1
a372 1
				rt_log("nmg_enlist_vu(vu=x%x,dv=x%x) re-using dualvu=x%x from dualfu=x%x\n",
d379 2
a380 2
		rt_log("\tvu=x%x, %s, fu1=x%x, fu2=x%x\n", vu, (sv==is->s1)?"shell 1":"shell 2", is->fu1, is->fu2);
		rt_log("nmg_enlist_vu(): QUESTION: What do I search for wire intersections?  Making self-loop\n");
d385 1
a385 1
			dualvu = RT_LIST_FIRST( vertexuse, &lu->down_hd );
d388 1
a388 1
				rt_log("nmg_enlist_vu(vu=x%x) re-using dualvu=x%x from dualshell=x%x\n",
d398 2
a399 2
		nmg_tbl( is->l2, TBL_INS_UNIQUE, (long *)&dualvu->l.magic );
		if( is->mag_len <= NMG_TBL_END( is->l2 ) )
d412 1
a412 1
				is->mag_len = 2*(NMG_TBL_END( is->l1 ) + NMG_TBL_END( is->l2 ));
d419 1
a419 1
			is->mag2[nmg_tbl( is->l2, TBL_LOC, (long *)&dualvu->l.magic )] = dist;
d421 2
a422 2
		nmg_tbl( is->l1, TBL_INS_UNIQUE, (long *)&dualvu->l.magic );
		if( is->mag_len <= NMG_TBL_END( is->l1 ) )
d435 1
a435 1
				is->mag_len = 2*(NMG_TBL_END( is->l1 ) + NMG_TBL_END( is->l2 ));
d442 1
a442 1
			is->mag1[nmg_tbl( is->l1, TBL_LOC, (long *)&dualvu->l.magic )] = dist;
d446 1
a446 1
		rt_log("nmg_enlist_vu(vu=x%x,dv=x%x) v=x%x, dist=%g (%s) ret=x%x\n",
d507 4
a510 4
		rt_log("nmg_get_2d_vertex(,assoc_use=%x %s) this=x%x %s, is->twod=%x %s\n",
			assoc_use, rt_identify_magic(*assoc_use),
			this, rt_identify_magic(*this),
			is->twod, rt_identify_magic(*(is->twod)) );
d515 1
a515 1
		rt_log("nmg_get_2d_vertex: v=x%x, assoc_use=x%x, null vg_p\n",
d529 1
a529 1
		rt_log("nmg_get_2d_vertex:  v=x%x, v->index=%d, is->maxindex=%d, m->maxindex=%d\n",
d539 1
a539 1
			rt_log("nmg_get_2d_vertex() extending vert2d array from %d to %d points (m max=%d)\n",
d570 1
a570 1
		rt_log("nmg_get_2d_vertex ERROR #%d (%g %g %g) becomes (%g,%g)\n\t%g != zero, dist3d=%g, %g*tol\n",
d575 1
a575 1
			rt_log("nmg_get_2d_vertex(,assoc_use=%x) f=x%x, is->twod=%x\n",
d583 1
a583 1
		rt_log("2d #%d (%g %g %g) becomes (%g,%g) %g\n",
d656 1
a656 1
			rt_log("nmg_isect2d_prep(f=x%x) flip=%d\n", f1, f1->flip);
d680 1
a680 1
		rt_log("2d prep for edgeuse\n");
d771 1
a771 1
		rt_log("nmg_isect_vert2p_face2p(, vu1=x%x, fu2=x%x)\n", vu1, fu2);
d782 1
a782 1
	for( RT_LIST_FOR( lu2, loopuse, &fu2->lu_hd ) )  {
d786 2
a787 2
		if( RT_LIST_FIRST_MAGIC( &lu2->down_hd ) == NMG_VERTEXUSE_MAGIC )  {
			vu2 = RT_LIST_FIRST( vertexuse, &lu2->down_hd );
d795 1
a795 1
			if( rt_pt3_pt3_equal( pt, vu2->v_p->vg_p->coord, &is->tol ) )  {
d804 1
a804 1
		for( RT_LIST_FOR( eu2, edgeuse, &lu2->down_hd ) )  {
d827 1
a827 1
		vu2 = RT_LIST_FIRST( vertexuse, &lu2->down_hd );
d859 1
a859 1
		rt_log("nmg_isect_3vertex_3face(, vu=x%x, fu=x%x) v=x%x\n", vu, fu, vu->v_p);
d863 3
a865 3
		if (rt_g.NMG_debug & DEBUG_POLYSECT) rt_log("\tvu lies in face (topology 1)\n");
		(void)nmg_tbl(is->l1, TBL_INS_UNIQUE, &vu->l.magic);
		(void)nmg_tbl(is->l2, TBL_INS_UNIQUE, &vup->l.magic);
d878 1
a878 1
		if (rt_g.NMG_debug & DEBUG_POLYSECT) rt_log("\tvu not on face (geometry)\n");
d895 1
a895 1
 *  vu1_final in fu1 is RT_LIST_PNEXT_CIRC(edgeuse,eu1)->vu_p after return.
d927 1
a927 1
		rt_log("nmg_break_3edge_at_plane() Splitting %g, %g, %g <-> %g, %g, %g\n",
d934 1
a934 1
	if( rt_pt3_pt3_equal( hit_pt, v1->vg_p->coord, &is->tol ) )
d936 1
a936 1
	if( rt_pt3_pt3_equal( hit_pt, v1mate->vg_p->coord, &is->tol ) )
d950 1
a950 1
		struct rt_tol	t2;
d956 2
a957 2
		if( rt_pt3_pt3_equal( hit_pt, v1->vg_p->coord, &t2 ) )
			rt_log("NOTICE: nmg_break_3edge_at_plane() hit_pt nearly equal to v1 %g*tol\n", dist/is->tol.dist);
d959 2
a960 2
		if( rt_pt3_pt3_equal( hit_pt, v1mate->vg_p->coord, &t2 ) )
			rt_log("NOTICE: nmg_break_3edge_at_plane() hit_pt nearly equal to v1mate %g*tol\n", dist/is->tol.dist);
d972 1
a972 1
			rt_log("re-using vertex v=x%x from other shell\n", v2);
d995 1
a995 1
rt_log("%%%%%% point is outside face loop, no need to break eu1?\n");
d1008 1
a1008 1
			rt_log("Made new vertex vu=x%x, v=x%x\n", vu1_final, vu1_final->v_p);
d1019 1
a1019 1
			rt_log("After split eu1 x%x= %g, %g, %g -> %g, %g, %g\n",
d1024 1
a1024 1
			rt_log("\teu1forw x%x = %g, %g, %g -> %g, %g, %g\n",
d1036 1
a1036 1
				rt_log("%%%%%% point is on loop boundary.  Break fu2 loop too?\n");
d1056 1
a1056 1
		vu2_final = RT_LIST_FIRST( vertexuse, &plu2->down_hd );
d1061 1
a1061 1
			rt_log("Made vertexloop in other face. lu=x%x vu=x%x on v=x%x\n",
d1072 1
a1072 1
		rt_log("\tNow %g, %g, %g <-> %g, %g, %g\n",
d1076 1
a1076 1
		rt_log("\tand %g, %g, %g <-> %g, %g, %g\n\n",
d1126 1
a1126 1
	v1b = RT_LIST_PNEXT_CIRC( edgeuse, eu1 )->vu_p->v_p;
d1139 1
a1139 1
	code = rt_isect_pt2_lseg2( &dist, a, b, p, &(is->tol) );
d1171 1
a1171 1
			rt_log("nmg_break_eu_on_v() breaking eu=x%x on v=x%x, new_eu=x%x\n",
d1196 1
a1196 1
CONST struct rt_tol	*tol;
d1199 1
a1199 1
	struct nmg_ptbl	eutab;
d1205 1
a1205 1
	RT_CK_TOL(tol);
d1209 1
a1209 1
	vdist = rt_dist_pt3_along_line3( eg->e_pt, dir, v->vg_p->coord );
d1216 2
a1217 2
	for( eup = (struct edgeuse **)NMG_TBL_LASTADDR(&eutab);
	     eup >= (struct edgeuse **)NMG_TBL_BASEADDR(&eutab);
d1232 1
a1232 1
		if( rt_pt3_pt3_equal( v->vg_p->coord, va->vg_p->coord, tol ) )  {
d1236 1
a1236 1
		if( rt_pt3_pt3_equal( v->vg_p->coord, vb->vg_p->coord, tol ) )  {
d1240 2
a1241 2
		a = rt_dist_pt3_along_line3( eg->e_pt, dir, va->vg_p->coord );
		b = rt_dist_pt3_along_line3( eg->e_pt, dir, vb->vg_p->coord );
d1244 1
a1244 1
		if( !rt_between( a, vdist, b, tol ) )  continue;
d1247 1
a1247 1
			rt_log("nmg_break_eg_on_v( eg=x%x, v=x%x ) new_eu=x%x\n",
d1251 1
a1251 1
	nmg_tbl( &eutab, TBL_FREE, (long *)0 );
d1298 2
a1299 2
struct nmg_ptbl		*l1;	/* optional: list of new eu1 pieces */
struct nmg_ptbl		*l2;	/* optional: list of new eu2 pieces */
d1308 1
a1308 1
		rt_log("nmg_isect_2colinear_edge2p(eu1=x%x, eu2=x%x) START\n",
d1316 2
a1317 2
	if( l1 )  NMG_CK_PTBL(l1);
	if( l2 )  NMG_CK_PTBL(l2);
d1320 1
a1320 1
	vu[1] = RT_LIST_PNEXT_CIRC( edgeuse, eu1 )->vu_p;
d1322 1
a1322 1
	vu[3] = RT_LIST_PNEXT_CIRC( edgeuse, eu2 )->vu_p;
d1333 1
a1333 1
					nmg_tbl(l1, TBL_INS_UNIQUE, &eu[neu]->l.magic );
d1335 1
a1335 1
					nmg_tbl(l2, TBL_INS_UNIQUE, &eu[neu]->l.magic );
d1367 1
a1367 1
		rt_log("nmg_isect_2colinear_edge2p(eu1=x%x, eu2=x%x) ret #eu=%d\n",
d1423 1
a1423 1
	vu1b = RT_LIST_PNEXT_CIRC( edgeuse, eu1 )->vu_p;
d1425 1
a1425 1
	vu2b = RT_LIST_PNEXT_CIRC( edgeuse, eu2 )->vu_p;
d1432 1
a1432 1
		rt_log("nmg_isect_edge2p_edge2p(eu1=x%x, eu2=x%x) START\n\tfu1=x%x, fu2=x%x\n\tvu1a=%x vu1b=%x, vu2a=%x vu2b=%x\n\tv1a=%x v1b=%x,   v2a=%x v2b=%x\n",
d1445 1
a1445 1
			rt_log("nmg_isect_edge2p_edge2p: shared edge topology, both ends\n");
d1454 1
a1454 1
			rt_log("nmg_isect_edge2p_edge2p: shared edge topology, both ends, reversed.\n");
d1488 1
a1488 1
	status = rt_isect_line2_lseg2( dist, eu1_start, eu1_dir,
d1492 1
a1492 1
		rt_log("\trt_isect_line2_lseg2()=%d, dist: %g, %g\n",
d1508 1
a1508 1
			rt_log("edge2p_edge2p: non-colinear edges share one vertex (topology)\n");
d1531 1
a1531 1
		if( nmg_isect_2colinear_edge2p( eu1, eu2, fu2, is, (struct nmg_ptbl *)0, (struct nmg_ptbl *)0 ) > 2 )  {
d1555 1
a1555 1
			rt_log("\tvu=x%x vu1a is intersect point\n", vu1a);
d1558 1
a1558 1
				rt_log("\teu1 line intersects eu2 outside vu2a...vu2b range, ignore.\n");
d1568 1
a1568 1
				rt_log("\tvu2a matches vu1a\n");
d1576 1
a1576 1
				rt_log("\tsecond point of eu2 matches vu1a\n");
d1584 1
a1584 1
			rt_log("\tbreaking eu2 on vu1a\n");
d1594 1
a1594 1
			rt_log("\tvu=x%x vu1b is intersect point\n", vu1b);
d1597 1
a1597 1
				rt_log("\teu1 line intersects eu2 outside vu2a...vu2b range, ignore.\n");
d1607 1
a1607 1
				rt_log("\tvu2a matches vu1b\n");
d1615 1
a1615 1
				rt_log("\tsecond point of eu2 matches vu1b\n");
d1623 1
a1623 1
			rt_log("\tbreaking eu2 on vu1b\n");
d1635 1
a1635 1
			rt_log("\tIntersect point on eu2 is outside vu1a...vu1b.  Break eu2 anyway.\n");
d1670 1
a1670 1
		rt_log("\tintersect is in middle of eu1, breaking it\n");
d1677 1
a1677 1
			rt_log("\t\tintersect point is vu2a\n");
d1684 1
a1684 1
			rt_log("\t\tintersect point is vu2b\n");
d1702 2
a1703 2
		nmg_enlist_vu( is, RT_LIST_PNEXT_CIRC(edgeuse,eu1)->vu_p,
			RT_LIST_PNEXT_CIRC(edgeuse,eu2)->vu_p, MAX_FASTF );
d1735 1
a1735 1
		rt_log("nmg_isect_edge2p_edge2p(eu1=x%x, eu2=x%x) END, ret=%d %s%s%s\n",
d1784 1
a1784 1
		rt_log("nmg_isect_wireedge3p_face3p(, eu1=x%x, fu2=x%x) START\n", eu1, fu2);
d1817 1
a1817 1
			rt_log("HACK HACK cough cough.  Resetting is->pt, is->dir\n");
d1830 1
a1830 1
		rt_log("Testing (%g, %g, %g) -> (%g, %g, %g) dir=(%g, %g, %g)\n",
d1837 1
a1837 1
	status = rt_isect_line3_plane(&dist, start_pt, edge_vect,
d1842 1
a1842 1
		rt_log("\tHit. rt_isect_line3_plane=%d, dist=%g (%e)\n",
d1845 1
a1845 1
		rt_log("\tMiss. Boring status of rt_isect_line3_plane: %d\n",
d1858 2
a1859 2
			rt_log("nmg_isect_wireedge3p_face3p: edge lies ON face, using 2D code\n@@ @@ @@ @@ @@ @@ @@ @@ @@ @@ 2D CODE, START\n");
			rt_log("  The status of the face/face intersect line, before 2d:\n");
d1879 2
a1880 2
			rt_log("nmg_isect_wireedge3p_face3p: @@ @@ @@ @@ @@ @@ @@ @@ @@ @@ 2D CODE, END, resume 3d problem.\n");
			rt_log("  The status of the face/face intersect line, so far:\n");
d1888 1
a1888 1
				rt_log("\tEdge start vertex lies on other face (2d topology).\n");
d1890 2
a1891 2
			(void)nmg_tbl(is->l1, TBL_INS_UNIQUE, &vu1_final->l.magic);
			(void)nmg_tbl(is->l2, TBL_INS_UNIQUE, &vu2_final->l.magic);
d1913 1
a1913 1
			rt_log("\tEdge start vertex lies on other face (topology).\n\tAdding vu1_final=x%x (v=x%x), vu2_final=x%x (v=x%x)\n",
d1917 2
a1918 2
		(void)nmg_tbl(is->l1, TBL_INS_UNIQUE, &vu1_final->l.magic);
		(void)nmg_tbl(is->l2, TBL_INS_UNIQUE, &vu2_final->l.magic);
d1937 1
a1937 1
			rt_log("\tEdge start vertex lies on other face (geometry)\n");
d1955 1
a1955 1
		rt_log("\tedge_len=%g, dist=%g, dist_to_plane=%g\n",
d1961 1
a1961 1
			rt_log("\tplane behind first point\n");
d1967 1
a1967 1
			rt_log("\tplane beyond second point\n");
d1976 1
a1976 1
		ff_dist = rt_dist_line_point( is->pt, is->dir, hit_pt );
d1978 1
a1978 1
			rt_log("WARNING nmg_isect_wireedge3p_face3p() hit_pt off f/f line %g*tol (%e, tol=%e)\n",
d1994 1
a1994 1
			rt_log("\tedge starts at plane intersect\n");
d2006 1
a2006 1
			vu1_final = RT_LIST_PNEXT_CIRC(edgeuse,eu1)->vu_p;
d2016 1
a2016 1
			rt_log("\tedge ends at plane intersect\n");
d2018 1
a2018 1
		eunext = RT_LIST_PNEXT_CIRC(edgeuse,eu1);
d2035 1
a2035 1
		dist = rt_dist_line_point( is->pt, is->dir,
d2038 1
a2038 1
			rt_log("ERROR nmg_isect_wireedge3p_face3p() vu1=x%x point off line by %g > 100*dist_tol (%g)\n",
d2046 1
a2046 1
			rt_log("WARNING nmg_isect_wireedge3p_face3p() vu1=x%x pt off line %g*tol (%e, tol=%e)\n",
d2053 1
a2053 1
		rt_log("nmg_isect_wireedge3p_face3p(, eu1=x%x, fu2=x%x) ret=%d END\n", eu1, fu2, ret);
d2079 1
a2079 1
		rt_log("nmg_isect_wireloop3p_face3p(, lu=x%x, fu=x%x) START\n", lu, fu);
d2091 1
a2091 1
	magic1 = RT_LIST_FIRST_MAGIC( &lu->down_hd );
d2093 1
a2093 1
		struct vertexuse	*vu = RT_LIST_FIRST(vertexuse,&lu->down_hd);
d2112 3
a2114 3
	for( eu = RT_LIST_LAST(edgeuse, &lu->down_hd );
	     RT_LIST_NOT_HEAD(eu,&lu->down_hd);
	     eu = RT_LIST_PLAST(edgeuse,eu) )  {
d2127 1
a2127 1
		rt_log("nmg_isect_wireloop3p_face3p(, lu=x%x, fu=x%x) END, discards=%d\n", lu, fu, discards);
d2179 2
a2180 2
			rt_log("r_min=%g, r_max=%g\n", line.r_min, line.r_max);
			rt_log("nmg_isect_construct_nice_ray() edge ray missed face bounding RPP, ret=1\n");
d2187 1
a2187 1
		rt_log("r_min=%g, r_max=%g\n", line.r_min, line.r_max);
d2195 1
a2195 1
			rt_log("flipping dir\n");
d2204 1
a2204 1
		rt_log("nmg_isect_construct_nice_ray() ret=0\n");
d2253 1
a2253 1
	struct nmg_ptbl vert_list1, vert_list2;
d2260 2
a2261 2
	struct nmg_ptbl		eu1_list;
	struct nmg_ptbl		eu2_list;
d2269 1
a2269 1
		rt_log("nmg_isect_edge2p_face2p(eu1=x%x, fu2=x%x, fu1=x%x) START\n", eu1, fu2, fu1);
d2285 1
a2285 1
			rt_log("nmg_isect_edge2p_face2p() fusing unshared shared edge\n");
d2290 1
a2290 1
			rt_log("nmg_isect_edge2p_face2p() topology is shared\n");
d2295 4
a2298 4
	(void)nmg_tbl(&vert_list1, TBL_INIT,(long *)NULL);
	(void)nmg_tbl(&vert_list2, TBL_INIT,(long *)NULL);
	(void)nmg_tbl(&eu1_list, TBL_INIT,(long *)NULL);
	(void)nmg_tbl(&eu2_list, TBL_INIT,(long *)NULL);
d2315 1
a2315 1
	vu2 = RT_LIST_PNEXT_CIRC( edgeuse, eu1 )->vu_p;
d2317 1
a2317 1
		rt_log("nmg_isect_edge2p_face2p(eu1=x%x) skipping 0-len edge (topology)\n", eu1);
d2343 1
a2343 1
	is->mag_len = 2 * (NMG_TBL_END( &eu1_list ) + NMG_TBL_END( &eu2_list ) );
d2360 1
a2360 1
		rt_log("nmg_isect_edge2p_face2p(): total_splits=%d\n", total_splits);
d2365 1
a2365 1
	    	rt_log("nmg_isect_edge2p_face2p(eu1=x%x, fu2=x%x) vert_lists C:\n", eu1, fu2 );
d2374 1
a2374 1
	    	rt_log("nmg_isect_edge2p_face2p(eu1=x%x, fu2=x%x) vert_lists D:\n", eu1, fu2 );
d2386 4
a2389 4
	(void)nmg_tbl(&vert_list1, TBL_FREE, (long *)NULL);
	(void)nmg_tbl(&vert_list2, TBL_FREE, (long *)NULL);
	(void)nmg_tbl(&eu1_list, TBL_FREE, (long *)NULL);
	(void)nmg_tbl(&eu2_list, TBL_FREE, (long *)NULL);
d2397 1
a2397 1
		rt_log("nmg_isect_edge2p_face2p(eu1=x%x, fu2=x%x) ret=%d\n",
d2419 2
a2420 2
	if( is->mag_len <= NMG_TBL_END( is->l1 ) || is->mag_len <= NMG_TBL_END( is->l2 ) )
		rt_log( "Array for distances to vertexuses is too small (%d)\n" , is->mag_len );
d2427 2
a2428 2
		nmg_tbl( is->l1, TBL_INS_UNIQUE, (long *)&vu->l.magic );
		if( is->mag_len <= NMG_TBL_END( is->l1 ) )
d2441 1
a2441 1
				is->mag_len = 2*(NMG_TBL_END( is->l1 ) + NMG_TBL_END( is->l2 ));
d2448 1
a2448 1
			is->mag1[nmg_tbl( is->l1, TBL_LOC, (long *)&vu->l.magic )] = dist;
d2450 2
a2451 2
		nmg_tbl( is->l2, TBL_INS_UNIQUE, (long *)&vu->l.magic );
		if( is->mag_len <= NMG_TBL_END( is->l2 ) )
d2464 1
a2464 1
				is->mag_len = 2*(NMG_TBL_END( is->l1 ) + NMG_TBL_END( is->l2 ));
d2471 1
a2471 1
			is->mag2[nmg_tbl( is->l2, TBL_LOC, (long *)&vu->l.magic )] = dist;
d2473 1
a2473 1
		rt_log("nmg_enlist_one_vu(vu=x%x) sv=x%x, s1=x%x, s2=x%x\n",
d2479 1
a2479 1
		rt_log("nmg_enlist_one_vu(vu=x%x) v=x%x, dist=%g (%s)\n",
d2497 4
a2500 4
	struct nmg_ptbl eu1_list;
	struct nmg_ptbl eu2_list;
	struct nmg_ptbl v_list;
	struct nmg_ptbl vert_list1,vert_list2;
d2509 1
a2509 1
		rt_log( "nmg_isect_two)face2p_jra: fu1=x%x, fu2=x%x\n" );
d2517 1
a2517 1
	is->mag_len = 2 * (NMG_TBL_END( &eu1_list ) + NMG_TBL_END( &eu2_list ) );
d2536 1
a2536 1
	for( i=0 ; i<NMG_TBL_END( &eu1_list ) ; i++ )
d2544 1
a2544 1
		eu1 = (struct edgeuse *)NMG_TBL_GET( &eu1_list, i );
d2558 1
a2558 1
		for( j=0 ; j<NMG_TBL_END( &eu2_list ) ; j++ )
d2571 1
a2571 1
			eu2 = (struct edgeuse *)NMG_TBL_GET( &eu2_list, j );
d2577 1
a2577 1
			code = rt_isect_lseg2_lseg2( dist, pt1a, vt1,
d2623 1
a2623 1
					rt_log( "eus x%x and x%x intersect #%d at (%g %g %g)\n",
d2633 1
a2633 1
					rt_log( "Found vertex (x%x) at hit_pt\n", hitv );
d2638 1
a2638 1
						rt_log( "Splitting eu1 x%x\n", eu1 );
d2645 1
a2645 1
					nmg_tbl( &eu1_list, TBL_INS, (long *)new_eu );
d2652 1
a2652 1
						rt_log( "Splitting eu2 x%x\n",  eu2 );
d2657 1
a2657 1
					nmg_tbl( &eu2_list, TBL_INS, (long *)new_eu );
d2666 2
a2667 2
	nmg_tbl( &eu1_list, TBL_FREE, (long *)NULL );
	nmg_tbl( &eu2_list, TBL_FREE, (long *)NULL );
d2674 1
a2674 1
	for( i=0 ; i<NMG_TBL_END( &v_list ) ; i++ )
d2679 1
a2679 1
		v = (struct vertex *)NMG_TBL_GET( &v_list, i );
d2692 1
a2692 1
				rt_log( "Making dualvu of vertex x%x in fu2 x%x\n", v, fu2 );
d2696 1
a2696 1
	nmg_tbl( &v_list, TBL_RST, (long *)NULL );
d2701 1
a2701 1
	for( i=0 ; i<NMG_TBL_END( &v_list ) ; i++ )
d2706 1
a2706 1
		v = (struct vertex *)NMG_TBL_GET( &v_list, i );
d2719 1
a2719 1
				rt_log( "Making dualvu of vertex x%x in fu1 x%x\n", v, fu1 );
d2724 1
a2724 1
	nmg_tbl( &v_list, TBL_FREE, (long *)NULL );
d2726 2
a2727 2
	nmg_tbl( &vert_list1, TBL_INIT, (long *)NULL );
	nmg_tbl( &vert_list2, TBL_INIT, (long *)NULL );
d2731 1
a2731 1
	for( RT_LIST_FOR( lu, loopuse, &fu1->lu_hd ) )
d2737 1
a2737 1
		if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d2740 1
a2740 1
		for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d2757 1
a2757 1
				rt_log( "Making EU x%x an intersect line for face cutting\n", eu );
d2759 1
a2759 1
			for( RT_LIST_FOR( vu, vertexuse, &v1->vu_hd ) )
d2769 1
a2769 1
			for( RT_LIST_FOR( vu, vertexuse, &v2->vu_hd ) )
d2781 1
a2781 1
				rt_log( "Calling face cutter for fu2 x%x\n", fu2 );
d2784 2
a2785 2
			nmg_tbl( is->l1, TBL_RST, (long *)NULL );
			nmg_tbl( is->l2, TBL_RST, (long *)NULL );
d2789 1
a2789 1
	for( RT_LIST_FOR( lu, loopuse, &fu2->lu_hd ) )
d2795 1
a2795 1
		if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d2798 1
a2798 1
		for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d2815 1
a2815 1
				rt_log( "Making EU x%x an intersect line for face cutting\n", eu );
d2817 1
a2817 1
			for( RT_LIST_FOR( vu, vertexuse, &v1->vu_hd ) )
d2827 1
a2827 1
			for( RT_LIST_FOR( vu, vertexuse, &v2->vu_hd ) )
d2839 1
a2839 1
				rt_log( "Calling face cutter for fu1 x%x\n", fu1 );
d2842 2
a2843 2
			nmg_tbl( is->l1, TBL_RST, (long *)NULL );
			nmg_tbl( is->l2, TBL_RST, (long *)NULL );
d2851 2
a2852 2
	nmg_tbl( is->l1, TBL_FREE, (long *)NULL );
	nmg_tbl( is->l2, TBL_FREE, (long *)NULL );
d2904 1
a2904 1
		rt_log("nmg_isect_two_face2p(fu1=x%x, fu2=x%x) START\n", fu1, fu2);
d2926 1
a2926 1
	for( RT_LIST_FOR( lu, loopuse, &fu1->lu_hd ) )  {
d2928 1
a2928 1
		if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) == NMG_VERTEXUSE_MAGIC )  {
d2931 1
a2931 1
			vu = RT_LIST_FIRST( vertexuse, &lu->down_hd );
d2936 1
a2936 1
		for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
d2965 1
a2965 1
	for( RT_LIST_FOR( lu, loopuse, &fu2->lu_hd ) )  {
d2967 1
a2967 1
		if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) == NMG_VERTEXUSE_MAGIC )  {
d2970 1
a2970 1
			vu = RT_LIST_FIRST( vertexuse, &lu->down_hd );
d2975 1
a2975 1
		for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
d2997 1
a2997 1
		rt_log("nmg_isect_two_face2p(fu1=x%x, fu2=x%x) END\n", fu1, fu2);
d3016 1
a3016 1
struct nmg_ptbl		*list;
d3031 1
a3031 1
	NMG_CK_PTBL(list);
d3042 1
a3042 1
	vu1b = RT_LIST_PNEXT_CIRC( edgeuse, eu1 )->vu_p;
d3047 1
a3047 1
		rt_log("nmg_isect_line2_edge2p(eu1=x%x, fu1=x%x)\n\tvu1a=%x vu1b=%x\n\tv2a=%x v2b=%x\n",
d3063 1
a3063 1
	status = rt_isect_line2_lseg2( dist, is->pt2d, is->dir2d,
d3067 1
a3067 1
		rt_log("\trt_isect_line2_lseg2()=%d, dist: %g, %g\n",
d3079 1
a3079 1
			rt_log("\t\tedge colinear with isect line.  Listing vu1a, vu1b\n");
d3095 2
a3096 2
			rt_log("\t\tintersect point is vu1a\n");
		if( !rt_pt3_pt3_equal(hit_pt, vu1a->v_p->vg_p->coord, &(is->tol) ) )
d3102 2
a3103 2
			rt_log("\t\tintersect point is vu1b\n");
		if( !rt_pt3_pt3_equal(hit_pt, vu1b->v_p->vg_p->coord, &(is->tol) ) )
d3114 1
a3114 1
			rt_log("\t2D: pt2d=(%g, %g), dir2d=(%g, %g)\n",
d3117 1
a3117 1
			rt_log("\t2D: eu1_start=(%g, %g), eu1_dir=(%g, %g)\n",
d3122 1
a3122 1
			rt_log("\t2d: Breaking eu1 at isect.\n");
d3127 1
a3127 1
			code = rt_isect_pt_lseg( &dist, vu1a->v_p->vg_p->coord,
d3130 1
a3130 1
			rt_log("\trt_isect_pt_lseg() dist=%g, ret=%d\n", dist, code);
d3134 3
a3136 3
if( !rt_between(vu1a->v_p->vg_p->coord[X], hit_pt[X], vu1b->v_p->vg_p->coord[X], &(is->tol)) ||
    !rt_between(vu1a->v_p->vg_p->coord[Y], hit_pt[Y], vu1b->v_p->vg_p->coord[Y], &(is->tol)) ||
    !rt_between(vu1a->v_p->vg_p->coord[Z], hit_pt[Z], vu1b->v_p->vg_p->coord[Z], &(is->tol)) )  {
d3156 1
a3156 1
				rt_log("\t\tmaking new vertex vu=x%x v=x%x\n",
d3160 1
a3160 1
				rt_log("\t\tre-using vertex v=x%x vu=x%x\n", new_v, vu1_final);
d3169 1
a3169 1
		rt_log("nmg_isect_line2_edge2p(eu1=x%x, fu1=x%x) END ret=%d\n", eu1, fu1, ret);
d3193 1
a3193 1
		rt_log("nmg_isect_line2_vertex2(vu=x%x)\n", vu1);
d3196 1
a3196 1
	if( rt_distsq_line3_pt3( is->pt, is->dir, vu1->v_p->vg_p->coord ) > is->tol.dist_sq )
d3200 1
a3200 1
		rt_log("nmg_isect_line2_vertex2(vu=x%x) line hits vertex v=x%x\n", vu1, vu1->v_p);
d3218 2
a3219 2
CONST struct nmg_ptbl		*t1;
CONST struct nmg_ptbl		*t2;
d3227 1
a3227 1
	NMG_CK_PTBL(t1);
d3229 2
a3230 2
	for( eu1 = (CONST struct edgeuse **)NMG_TBL_LASTADDR(t1);
	     eu1 >= (CONST struct edgeuse **)NMG_TBL_BASEADDR(t1); eu1--
d3236 1
a3236 1
		vu1b = RT_LIST_PNEXT_CIRC( edgeuse, (*eu1) )->vu_p;
d3242 2
a3243 2
		for( eu2 = (CONST struct edgeuse **)NMG_TBL_LASTADDR(t2);
		     eu2 >= (CONST struct edgeuse **)NMG_TBL_BASEADDR(t2); eu2--
d3249 1
a3249 1
			vu2b = RT_LIST_PNEXT_CIRC( edgeuse, (*eu2) )->vu_p;
d3281 1
a3281 1
		rt_log("nmg_isect_two_ptbls() intersection! vu=x%x, vu_dual=x%x\n",
d3299 1
a3299 1
CONST struct rt_tol	*tol;
d3301 1
a3301 1
	struct nmg_ptbl	eutab;
d3306 1
a3306 1
	RT_CK_TOL(tol);
d3310 2
a3311 2
	for( eup = (struct edgeuse **)NMG_TBL_LASTADDR(&eutab);
	     eup >= (struct edgeuse **)NMG_TBL_BASEADDR(&eutab); eup--
d3331 1
a3331 1
		rt_log("nmg_find_eg_on_line() 2 different eg's, taking better one.\n");
d3333 1
a3333 1
	(void)nmg_tbl( &eutab, TBL_FREE, 0 );
d3335 1
a3335 1
		rt_log("rt_find_eg_on_line( x%x ) ret=x%x\n", magic_p, ret);
d3359 1
a3359 1
	for( RT_LIST_FOR( vu, vertexuse, &v->vu_hd ) )  {
d3365 1
a3365 1
		rt_log("nmg_k0eu(v=x%x) killing 0-len eu=x%x, mate=x%x\n",
d3370 1
a3370 1
			rt_log("nmg_k0eu() WARNING: parent now has no edgeuses\n");
d3397 1
a3397 1
CONST struct rt_tol	*tol;
d3403 1
a3403 1
	RT_CK_TOL(tol);
d3405 1
a3405 1
	rt_log("nmg_repair_v_near_v(hit_v=x%x, v=x%x)\n", hit_v, v );
d3409 3
a3411 3
	rt_log("dist v-hit=%g, equal=%d\n",
		rt_dist_pt3_pt3(v->vg_p->coord, hit_v->vg_p->coord),
		rt_pt3_pt3_equal(v->vg_p->coord, hit_v->vg_p->coord, tol)
d3414 1
a3414 1
		if( rt_2line3_colinear( eg1->e_pt, eg1->e_dir, eg2->e_pt, eg2->e_dir, 1e5, tol ) )
d3416 6
a3421 6
		rt_log("eg1: line/ vu dist=%g, hit dist=%g\n",
			rt_dist_line3_pt3( eg1->e_pt, eg1->e_dir, v->vg_p->coord ),
			rt_dist_line3_pt3( eg1->e_pt, eg1->e_dir, hit_v->vg_p->coord ) );
		rt_log("eg2: line/ vu dist=%g, hit dist=%g\n",
			rt_dist_line3_pt3( eg2->e_pt, eg2->e_dir, v->vg_p->coord ),
			rt_dist_line3_pt3( eg2->e_pt, eg2->e_dir, hit_v->vg_p->coord ) );
d3426 1
a3426 1
	if( rt_dist_pt3_pt3(v->vg_p->coord,
d3429 2
a3430 2
		rt_log("NOTICE: The intersection of two lines has resulted in 2 different intersect points\n");
		rt_log("  Since the two points are 'close', they are being fused.\n");
d3436 1
a3436 1
			rt_log("DANGER: a 0-length edge is being created eu0=x%x\n", eu0);
d3448 1
a3448 1
	rt_log("nmg_repair_v_near_v(v=x%x) ret=x%x\n", v, hit_v);
d3470 1
a3470 1
CONST struct rt_tol		*tol;
d3480 1
a3480 1
	RT_CK_TOL(tol);
d3483 1
a3483 1
		v = RT_LIST_PNEXT_CIRC(edgeuse, eu)->vu_p->v_p;
d3494 1
a3494 1
	if( rt_distsq_line3_pt3( eg1->e_pt, eg1->e_dir, v->vg_p->coord ) > tol->dist_sq )  {
d3502 1
a3502 1
	for( RT_LIST_FOR( vu1, vertexuse, &v->vu_hd ) )  {
d3513 1
a3513 1
			rt_log("  seen1=x%x, seen2=x%x, hit_v=x%x, v=x%x\n",
d3525 1
a3525 1
		rt_log("ERROR seen1=x%x, seen2=x%x, hit_v=x%x != v=x%x\n",
d3533 1
a3533 1
		rt_log("nmg_search_v_eg(eu=x%x, %d, eg1=x%x, eg2=x%x) ret=x%x\n",
d3549 1
a3549 1
CONST struct rt_tol	*tol;
d3553 1
a3553 1
	struct rt_list		*midway;	/* &eu->l2, midway into edgeuse */
d3557 1
a3557 1
	RT_CK_TOL(tol);
d3563 1
a3563 1
	for( RT_LIST_FOR( midway, rt_list, &eg1->eu_hd2 ) )  {
d3565 1
a3565 1
		eu1 = RT_LIST_MAIN_PTR( edgeuse, midway, l2 );
d3573 1
a3573 1
		rt_log("nmg_common_v_2eg(eg1=x%x, eg2=x%x) hit_v=x%x\n",
d3617 1
a3617 1
	if( rt_distsq_line3_pt3( is->pt, is->dir, vg->coord ) > is->tol.dist_sq )
d3639 3
a3641 3
struct nmg_ptbl *verts;
struct nmg_ptbl *inters;
CONST struct rt_tol *tol;
d3649 3
a3651 3
	NMG_CK_PTBL( verts );
	NMG_CK_PTBL( inters );
	RT_CK_TOL( tol );
d3656 1
a3656 1
	for( i=0 ; i<NMG_TBL_END( verts ) ; i++ )
d3663 1
a3663 1
		v = (struct vertex *)NMG_TBL_GET( verts, i );
d3666 1
a3666 1
			nmg_tbl( inters, TBL_INS_UNIQUE, (long *)v );
d3670 1
a3670 1
		code = rt_dist_pt3_lseg3( &dist, pca, vg1->coord,
d3676 1
a3676 1
		nmg_tbl( inters, TBL_INS_UNIQUE, (long *)v );
d3689 3
a3691 3
struct nmg_ptbl *verts;
struct nmg_ptbl *inters;
CONST struct rt_tol *tol;
d3702 1
a3702 1
		rt_log( "nmg_isect_eu_eu( eu1=x%x, eu2=x%x )\n", eu1, eu2 );
d3708 3
a3710 3
	RT_CK_TOL( tol );
	NMG_CK_PTBL( inters );
	NMG_CK_PTBL( verts );
d3723 1
a3723 1
	code = rt_isect_lseg3_lseg3( dist, vg1a->coord, dir1, vg2a->coord, dir2, tol );
d3728 1
a3728 1
			rt_log( "\tnmg_isect_eu_eu: No intersection\n" );
d3751 1
a3751 1
			nmg_tbl( inters, TBL_INS_UNIQUE, (long *)eu2->vu_p->v_p );
d3756 1
a3756 1
			nmg_tbl( inters, TBL_INS_UNIQUE, (long *)eu2->eumate_p->vu_p->v_p );
d3769 2
a3770 2
			rt_log( "nmg_isect_eu_eu: intersection at (%g %g %g)\n", V3ARGS( hit_pt ) );
			rt_log( "splitting eu x%x at v=x%x\n", eu2, v );
d3778 1
a3778 1
				rt_log( "\tcreated new vertex x%x\n", v );
d3780 2
a3781 2
		nmg_tbl( inters, TBL_INS_UNIQUE, (long *)v );
		nmg_tbl( verts, TBL_INS_UNIQUE, (long *)v );
d3794 1
a3794 1
			nmg_tbl( inters, TBL_INS_UNIQUE, (long *)eu2->vu_p->v_p );
d3802 1
a3802 1
			nmg_tbl( inters, TBL_INS_UNIQUE, (long *)eu2->eumate_p->vu_p->v_p );
d3809 1
a3809 1
struct nmg_ptbl		*verts;
d3824 1
a3824 1
	struct nmg_ptbl inters;
d3829 1
a3829 1
		rt_log( "nmg_isect_eu_fu: eu=x%x, fu=x%x START\n", eu, fu );
d3834 1
a3834 1
	NMG_CK_PTBL( verts );
d3838 1
a3838 1
		rt_log( "nmg_isect_eu_fu() called with eu (x%x) from its own fu (x%x)\n",eu , fu );
d3846 2
a3847 2
		rt_log( "nmg_isect_eu_fu() called with EU (x%x) from model (x%x)\n", eu, nmg_find_model( &eu->l.magic ) );
		rt_log( "\tand FU (x%x) from model (x%x)\n", fu, m );
d3862 1
a3862 1
			rt_log( "\tnmg_isec_eu_fu: 0 length edge\n" );
d3871 1
a3871 1
	if( rt_isect_line3_plane( &dist, vg1->coord, dir, pl, &is->tol ) < 1 )
d3874 1
a3874 1
			rt_log( "\tnmg_isec_eu_fu: no intersection\n" );
d3882 1
a3882 1
			rt_log( "\tnmg_isec_eu_fu: intersection beyond ends of EU\n" );
d3889 1
a3889 1
			rt_log( "\tintersection at eu_vu_p\n" );
d3897 1
a3897 1
			rt_log( "\tintersection at eu->eumate_p->vu_p\n" );
d3905 1
a3905 1
		rt_log( "\tintersection point at (%g %g %g)\n", V3ARGS( hit_pt ) );
d3908 1
a3908 1
	nmg_tbl( &inters, TBL_INIT, (long *)NULL );
d3914 1
a3914 1
	for( RT_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
d3921 1
a3921 1
		if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d3924 1
a3924 1
		for( RT_LIST_FOR( eu_fu, edgeuse, &lu->down_hd ) )
d3935 1
a3935 1
	if( NMG_TBL_END( &inters ) == 0 )
d3942 1
a3942 1
			rt_log( "\tNo intersection points found\n" );
d3964 1
a3964 1
				nmg_tbl( verts, TBL_INS_UNIQUE, (long *)new_vu->v_p );
d3986 1
a3986 1
				nmg_tbl( verts, TBL_INS_UNIQUE, (long *)new_vu->v_p );
d3997 1
a3997 1
				rt_log( "\tnmg_isec_eu_fu: intersection beyond ends of EU\n" );
d4015 2
a4016 2
			rt_log( "\tHit point is not within tolerance of eu endpoints\n" );
			rt_log( "\t\thit_pt=( %g %g %g ), eu=(%g %g %g)<->(%g %g %g)\n",
d4035 1
a4035 1
					rt_log( "\tsplitting eu (x%x) at hit_pt (v=x%x)\n", eu, v );
d4042 1
a4042 1
						rt_log( "\tnew vertex at hit point is x%x\n", v );
d4052 1
a4052 1
				nmg_tbl( verts, TBL_INS_UNIQUE, (long *)new_vu->v_p );
d4059 1
a4059 1
	if( NMG_TBL_END( &inters ) == 1 )
d4064 1
a4064 1
		v = (struct vertex *)NMG_TBL_GET( &inters, 0 );
d4068 1
a4068 1
			rt_log( "Only one intersect vertex (x%x), just split all EU's at (x%x)\n", v, eu );
d4079 1
a4079 1
	inter_dist = (fastf_t *)rt_calloc( NMG_TBL_END( &inters ), sizeof( fastf_t ),
d4083 1
a4083 1
		rt_log( "%d intersect vertices along eu (x%x)\n", NMG_TBL_END( &inters ), eu );
d4085 1
a4085 1
	for( i=0 ; i<NMG_TBL_END( &inters ) ; i++ )
d4091 1
a4091 1
		v = (struct vertex *)NMG_TBL_GET( &inters, i );
d4105 3
a4107 3
		rt_log( "Intersect vertices along eu x%x:\n", eu );
		for( i=0 ; i<NMG_TBL_END( &inters ) ; i++ )
			rt_log( "%d x%x %g\n", i+1, NMG_TBL_GET( &inters, i ), inter_dist[i] );
d4119 1
a4119 1
		for( i=0 ; i<NMG_TBL_END( &inters ) ; i++ )
d4131 1
a4131 1
		v = (struct vertex *)NMG_TBL_GET( &inters, index_at_max );
d4137 1
a4137 1
				rt_log( "Breaking edges at vertex #%d, dist=%g, v=x%x\n", i+1, inter_dist[i], v );
d4147 1
a4147 1
	nmg_tbl( &inters, TBL_FREE, (long *)NULL );
d4150 1
a4150 1
		rt_log( "nmg_isect_eu_fu: eu=x%x, fu=x%x END\n", eu, fu );
d4159 2
a4160 2
struct nmg_ptbl		*eu1_list;
struct nmg_ptbl		*eu2_list;
d4163 1
a4163 1
	struct nmg_ptbl verts1,verts2;
d4169 1
a4169 1
		rt_log( "nmg_isect_fu_jra( fu1=x%x, fu2=x%x ) START\n", fu1, fu2 );
d4174 2
a4175 2
	NMG_CK_PTBL(eu1_list);
	NMG_CK_PTBL(eu2_list);
d4186 1
a4186 1
	for( RT_LIST_FOR( lu, loopuse, &fu1->lu_hd ) )
d4192 1
a4192 1
		if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d4195 1
a4195 1
		for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d4203 1
a4203 1
	nmg_tbl( &verts2, TBL_FREE, (long *)NULL );
d4207 1
a4207 1
	for( RT_LIST_FOR( lu, loopuse, &fu2->lu_hd ) )
d4213 1
a4213 1
		if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d4216 1
a4216 1
		for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d4225 1
a4225 1
	nmg_tbl( &verts1, TBL_FREE, (long *)NULL );
d4234 1
a4234 1
	for( i=0 ; i<NMG_TBL_END( &verts2 ) ; i++ )
d4238 1
a4238 1
		v = (struct vertex *)NMG_TBL_GET( &verts2, i );
d4241 1
a4241 1
		nmg_tbl( &verts1, TBL_INS_UNIQUE, (long *)v );
d4243 1
a4243 1
	nmg_tbl( &verts2, TBL_FREE, (long *)NULL );
d4245 1
a4245 1
	for( i=0 ; i< NMG_TBL_END( &verts1 ) ; i++ )
d4251 1
a4251 1
		v = (struct vertex *)NMG_TBL_GET( &verts1, i );
d4263 1
a4263 1
		for( RT_LIST_FOR( vu, vertexuse, &v->vu_hd ) )
d4271 1
a4271 1
					rt_log( "\tenlisting vu x%x (x%x) from fu (x%x)\n", vu, v, fu_tmp );
d4277 1
a4277 1
	nmg_tbl( &verts1, TBL_FREE, (long *)NULL );
d4280 1
a4280 1
		rt_log( "nmg_isect_fu_jra( fu1=x%x, fu2=x%x ) END\n", fu1, fu2 );
d4309 2
a4310 2
struct nmg_ptbl		*eu1_list;
struct nmg_ptbl		*eu2_list;
d4312 1
a4312 1
	struct nmg_ptbl		eg_list;
d4331 2
a4332 2
	NMG_CK_PTBL(eu1_list);
	NMG_CK_PTBL(eu2_list);
d4335 1
a4335 1
		rt_log("nmg_isect_line2_face2pNEW(, fu1=x%x, fu2=x%x) on_eg=x%x\n", fu1, fu2, is->on_eg);
d4349 2
a4350 2
	for( eg1 = (struct edge_g_lseg **)NMG_TBL_LASTADDR(&eg_list);
	     eg1 >= (struct edge_g_lseg **)NMG_TBL_BASEADDR(&eg_list); eg1--
d4357 1
a4357 1
			rt_log( "\tChecking eg=x%x\n", *eg1 );
d4370 1
a4370 1
				rt_log("\tThis edge_geom generated the line.  Enlisting.\n");
d4372 2
a4373 2
			for( eu1_index=0; eu1_index < NMG_TBL_END(eu1_list); eu1_index++ )  {
				eu1 = (struct edgeuse *)NMG_TBL_GET(eu1_list, eu1_index);
d4378 2
a4379 2
				for( eu2_index=0; eu2_index < NMG_TBL_END(eu2_list); eu2_index++ )  {
					eu2 = (struct edgeuse *)NMG_TBL_GET(eu2_list, eu2_index);
d4394 1
a4394 1
				nmg_enlist_vu(is, RT_LIST_PNEXT_CIRC(edgeuse, eu1)->vu_p, 0, MAX_FASTF );
d4407 1
a4407 1
				rt_log("\tThis edge_geom generated the line.  Enlisting.\n");
d4412 1
a4412 1
			for( eu1_index=0; eu1_index < NMG_TBL_END(eu1_list); eu1_index++ )
d4414 1
a4414 1
				eu1 = (struct edgeuse *)NMG_TBL_GET(eu1_list, eu1_index);
d4437 1
a4437 1
				eu_end = RT_LIST_PNEXT_CIRC( edgeuse, &eu1->l );
d4458 1
a4458 1
			for( eu2_index=0; eu2_index < NMG_TBL_END(eu2_list); eu2_index++ )
d4460 1
a4460 1
				eu2 = (struct edgeuse *)NMG_TBL_GET(eu2_list, eu2_index);
d4484 1
a4484 1
				eu_end = RT_LIST_PNEXT_CIRC( edgeuse, &eu2->l );
d4519 1
a4519 1
		code = rt_isect_line2_line2( dist, is->pt2d, is->dir2d,
d4526 1
a4526 1
				rt_log("nmg_isect_line2_face2pNEW() edge_g not shared, geometry says lines are colinear.\n");
d4531 1
a4531 1
				rt_log("NOTICE: setting on_eg to eg1 and continuing with colinear case.\n");
d4537 1
a4537 1
		if( is->on_eg && rt_2line3_colinear(
d4543 1
a4543 1
			rt_log("nmg_isect_line2_face2pNEW() eg1 colinear to on_eg?\n");
d4550 1
a4550 1
		    	rt_log("fusing eg1 with on_eg, handling as colinear\n");
d4559 1
a4559 1
				rt_log("non-colinear.  Searching for topological intersection between on_eg and eg1\n");
d4586 1
a4586 1
						rt_log("overlay %s red is on_eg, yellow is eg1\n", buf);
d4588 1
a4588 1
					rt_log("\tTopology intersection.  hit_v=x%x (%g, %g, %g)\n",
d4606 1
a4606 1
						rt_log("\t\tfu1 RPP: ( %g %g %g ) <-> ( %g %g %g )\n",
d4608 1
a4608 1
						rt_log("\t\tfu2 RPP: ( %g %g %g ) <-> ( %g %g %g )\n",
d4670 1
a4670 1
				rt_log("NOTICE: geom/topo mis-match, enlisting topo vu, hit_v=x%x\n", hit_v);
d4674 3
a4676 3
				rt_log(" dist to eg1=%e, dist to on_eg=%e\n",
					rt_dist_line3_pt3((*eg1)->e_pt, (*eg1)->e_dir, hit_v->vg_p->coord),
					rt_dist_line3_pt3(is->on_eg->e_pt, is->on_eg->e_dir, hit_v->vg_p->coord) );
d4681 2
a4682 2
				rt_log(" 3d line isect, code=%d\n",
					rt_isect_line3_line3( &dist[0], &dist[1],
d4702 1
a4702 1
				rt_log("\t\tface RPP: ( %g %g %g ) <-> ( %g %g %g )\n",
d4726 1
a4726 1
			rt_log( "\t\tnmg_class_pt_fu_except(fu1) returns %s\n", nmg_class_name(class) );
d4738 1
a4738 1
				rt_log("hit_v=x%x\n", hit_v);
d4748 1
a4748 1
		for( eu1_index=0; eu1_index < NMG_TBL_END(eu1_list); eu1_index++ )  {
d4756 1
a4756 1
			eu1 = (struct edgeuse *)NMG_TBL_GET(eu1_list, eu1_index);
d4765 1
a4765 1
				rt_log( "\tChecking eu x%x\n", eu1 );
d4771 1
a4771 1
					rt_log( "\t\teg x%x is not eg1=x%x\n", eu1->g.lseg_p, *eg1 );
d4776 1
a4776 1
			vu1b = RT_LIST_PNEXT_CIRC( edgeuse, eu1 )->vu_p;
d4782 1
a4782 1
					rt_log("\tlisting intersect point at vu1a=x%x\n", vu1a);
d4798 1
a4798 1
					rt_log("\tlisting intersect point at vu1b=x%x\n", vu1b);
d4809 1
a4809 1
			tmp_dist_sq = rt_distsq_line3_pt3( is->pt, is->dir, vu1a->v_p->vg_p->coord );
d4811 1
a4811 1
				rt_log( "\tvu1a is sqrt(%g) from the intersect line\n" , tmp_dist_sq );
d4816 1
a4816 1
						rt_log( "\tnmg_isect_line2_face2pNEW: using nearby vu1a vertex x%x from eu x%x\n", vu1a->v_p, eu1 );
d4825 1
a4825 1
				nmg_tbl( &eg_list, TBL_FREE, (long *)0 );
d4828 1
a4828 1
				/* Fall through to rt_isect_pt2_lseg2() */
d4831 1
a4831 1
			tmp_dist_sq = rt_distsq_line3_pt3( is->pt, is->dir, vu1b->v_p->vg_p->coord );
d4833 1
a4833 1
				rt_log( "\tvu1b is sqrt(%g) from the intersect line\n" , tmp_dist_sq );
d4838 1
a4838 1
						rt_log( "\tnmg_isect_line2_face2pNEW: using nearby vu1b vertex x%x from eu x%x\n", vu1b->v_p, eu1 );
d4847 1
a4847 1
				nmg_tbl( &eg_list, TBL_FREE, (long *)0 );
d4850 1
a4850 1
				/* Fall through to rt_isect_pt2_lseg2() */
d4858 1
a4858 1
			code = rt_isect_pt2_lseg2( &ldist, eu1_pt2d, eu1_end2d, hit2d, &(is->tol) );
d4860 1
a4860 1
				rt_log("\trt_isect_pt2_lseg2() returned %d, ldist=%g\n", code, ldist);
d4873 1
a4873 1
					nmg_tbl( &eg_list, TBL_FREE, (long *)0 );
d4877 1
a4877 1
				if (rt_g.NMG_debug & DEBUG_POLYSECT) rt_log("\thit_v = x%x (vu1a)\n", hit_v);
d4884 1
a4884 1
					nmg_tbl( &eg_list, TBL_FREE, (long *)0 );
d4888 1
a4888 1
				if (rt_g.NMG_debug & DEBUG_POLYSECT) rt_log("\thit_v = x%x (vu1b)\n", hit_v);
d4902 1
a4902 1
				nmg_tbl( eu1_list, TBL_INS_UNIQUE, &new_eu->l.magic );
d4909 1
a4909 1
						rt_log("\tmaking new vertex vu=x%x hit_v=x%x\n",
d4923 1
a4923 1
						rt_log("\tre-using hit_v=x%x, vu=x%x\n", hit_v, vu1_midpt);
d4928 2
a4929 2
					rt_log( "Faceuses after nmg_ebreaker() call\n") ;
					rt_log( "fu1:\n" );
d4931 1
a4931 1
					rt_log( "fu2:\n" );
d4943 1
a4943 1
	for( RT_LIST_FOR( lu1, loopuse, &fu1->lu_hd ) )  {
d4946 1
a4946 1
		if( RT_LIST_FIRST_MAGIC( &lu1->down_hd ) != NMG_VERTEXUSE_MAGIC )  continue;
d4949 1
a4949 1
		vu1 = RT_LIST_FIRST( vertexuse, &lu1->down_hd );
d4953 1
a4953 1
		if( rt_distsq_line3_pt3( is->pt, is->dir,
d4958 1
a4958 1
			rt_log("\tself-loop vu=x%x lies on line of intersection\n", vu1 );
d4975 2
a4976 2
		for( eu1_index=0; eu1_index < NMG_TBL_END(eu1_list); eu1_index++ )  {
			eu1 = (struct edgeuse *)NMG_TBL_GET(eu1_list, eu1_index);
d4987 1
a4987 1
			nmg_tbl( eu1_list, TBL_INS_UNIQUE, &new_eu->l.magic );
d4992 2
a4993 2
		for( eu2_index=0; eu2_index < NMG_TBL_END(eu2_list); eu2_index++ )  {
			eu2 = (struct edgeuse *)NMG_TBL_GET(eu2_list, eu2_index);
d5004 1
a5004 1
			nmg_tbl( eu2_list, TBL_INS_UNIQUE, &new_eu->l.magic );
d5010 1
a5010 1
	nmg_tbl( &eg_list, TBL_FREE, (long *)0 );
d5022 1
a5022 1
CONST struct rt_tol	*tol;
d5027 1
a5027 1
	RT_CK_TOL(tol);
d5039 1
a5039 1
	if( rt_distsq_line3_pt3( eg->e_pt, eg->e_dir,
d5041 1
a5041 1
	if( rt_distsq_line3_pt3( eg->e_pt, eg->e_dir,
d5070 1
a5070 1
CONST struct rt_tol	*tol;
d5082 1
a5082 1
	RT_CK_TOL(tol);
d5097 1
a5097 1
	for( RT_LIST_FOR( f1, face, &fg1->f_hd ) )  {
d5104 1
a5104 1
		for( RT_LIST_FOR( lu1, loopuse, &fu1->lu_hd ) )  {
d5107 1
a5107 1
			if( RT_LIST_FIRST_MAGIC(&lu1->down_hd) == NMG_VERTEXUSE_MAGIC )
d5110 1
a5110 1
				rt_log(" visiting lu1=x%x, fu1=x%x, fg1=x%x\n",
d5114 1
a5114 1
			for( RT_LIST_FOR( eu1, edgeuse, &lu1->down_hd ) )  {
d5134 1
a5134 1
						rt_log(" Found shared edge, eur=x%x, eg=x%x\n", eur, eur->g.lseg_p );
d5156 1
a5156 1
							rt_log("nmg_find_eg_between_2fg() joining edges eur=x%x, ret=x%x\n",
d5164 1
a5164 1
		    			rt_log("eur=x%x, eg_p=x%x;  ret=x%x, eg_p=x%x\n",
d5175 1
a5175 1
						rt_log("nmg_find_eg_between_2fg() belatedly fusing e1=x%x, eg1=x%x, e2=x%x, eg2=x%x\n",
d5190 1
a5190 1
		rt_log("nmg_find_eg_between_2fg(fu1=x%x, fu2=x%x) edge_g=x%x\n",
d5221 1
a5221 1
	for( RT_LIST_FOR( lu1, loopuse, &fu1->lu_hd ) )  {
d5223 1
a5223 1
		if( RT_LIST_FIRST_MAGIC(&lu1->down_hd) == NMG_VERTEXUSE_MAGIC )
d5226 1
a5226 1
			rt_log(" visiting lu1=x%x, fu1=x%x\n",
d5229 1
a5229 1
		for( RT_LIST_FOR( eu1, edgeuse, &lu1->down_hd ) )  {
d5236 1
a5236 1
		rt_log("nmg_does_fu_use_eg(fu1=x%x, eg=x%x) eu1=x%x\n",
d5255 1
a5255 1
CONST struct rt_tol	*tol;
d5260 1
a5260 1
	RT_CK_TOL(tol);
d5293 3
a5295 3
	struct nmg_ptbl vert_list1, vert_list2;
	struct nmg_ptbl		eu1_list;	/* all eu's in fu1 */
	struct nmg_ptbl		eu2_list;	/* all eu's in fu2 */
d5309 1
a5309 1
		rt_log("nmg_isect_two_face3p( fu1=x%x, fu2=x%x )  START12\n", fu1, fu2);
d5325 1
a5325 1
		rt_log("WARNING: intersect line not on plane of fu1\n");
d5328 1
a5328 1
		rt_log("WARNING: intersect line not on plane of fu2\n");
d5343 1
a5343 1
			rt_log("WARNING: shared on_eg not on plane of fu1, omitting.\n");
d5346 1
a5346 1
			rt_log("WARNING: shared on_eg not on plane of fu2, omitting.\n");
d5363 1
a5363 1
		    !rt_2line3_colinear(
d5367 2
a5368 2
			rt_log("WARNING nmg_isect_two_face3p() is->pt and on_eg lines differ by %g deg. (shared topo)\n",
				ang * rt_radtodeg );
d5384 1
a5384 1
			    !rt_2line3_colinear(
d5388 3
a5390 3
				rt_log("WARNING nmg_isect_two_face3p() is->pt and on_eg lines differ by %g deg. (geom search)\n",
					ang * rt_radtodeg );
			    	if( ang * rt_radtodeg > 1.0 )  {
d5392 1
a5392 1
					rt_log("nmg_isect_two_face3p() line direction mismatch (geom), clearing on_eg.\n");
d5405 2
a5406 2
	(void)nmg_tbl(&vert_list1, TBL_INIT,(long *)NULL);
	(void)nmg_tbl(&vert_list2, TBL_INIT,(long *)NULL);
d5412 1
a5412 1
	is->mag_len = 2 * (NMG_TBL_END( &eu1_list ) + NMG_TBL_END( &eu2_list ) );
d5448 1
a5448 1
	    	rt_log("nmg_isect_two_face3p(fu1=x%x, fu2=x%x) vert_lists A:\n", fu1, fu2);
d5454 1
a5454 1
		rt_log("nmg_isect_two_face3p( fu1=x%x, fu2=x%x )  START21\n", fu1, fu2);
d5484 1
a5484 1
	    	rt_log("nmg_isect_two_face3p(fu1=x%x, fu2=x%x) vert_lists B:\n", fu1, fu2);
d5495 1
a5495 1
		rt_log("nmg_isect_two_face3p( fu1=x%x, fu2=x%x )  MIDDLE\n", fu1, fu2);
d5521 4
a5524 4
	(void)nmg_tbl(&vert_list1, TBL_FREE, (long *)NULL);
	(void)nmg_tbl(&vert_list2, TBL_FREE, (long *)NULL);
	(void)nmg_tbl(&eu1_list, TBL_FREE, (long *)NULL);
	(void)nmg_tbl(&eu2_list, TBL_FREE, (long *)NULL);
d5536 1
a5536 1
		rt_log("nmg_isect_two_face3p( fu1=x%x, fu2=x%x )  END\n", fu1, fu2);
d5553 1
a5553 1
	struct  nmg_ptbl cut_list;
d5562 1
a5562 1
		rt_log( "nmg_cut_lu_into_coplanar_and_non( lu=x%x, pl=%g %g %g %g )\n", lu, V4ARGS( pl ) );
d5570 1
a5570 1
	if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d5573 1
a5573 1
	nmg_tbl( &cut_list, TBL_INIT, (long *)NULL );
d5575 1
a5575 1
	eu = RT_LIST_FIRST( edgeuse, &lu->down_hd );
d5596 1
a5596 1
	for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d5628 2
a5629 2
				nmg_tbl( &cut_list, TBL_INS, (long *)vcut1 );
				nmg_tbl( &cut_list, TBL_INS, (long *)eu->vu_p->v_p );
d5641 2
a5642 2
				nmg_tbl( &cut_list, TBL_INS, (long *)vcut1 );
				nmg_tbl( &cut_list, TBL_INS, (long *)eu->eumate_p->vu_p->v_p );
d5650 3
a5652 3
		rt_log( "\t pl=( %g %g %g %g )\n", V4ARGS( pl ) );
		rt_log( "\tcut_lists=%d, on=%d, in=%d, out=%d\n", NMG_TBL_END( &cut_list ),on,in,out );
		if( NMG_TBL_END( &cut_list ) )
d5654 2
a5655 2
			rt_log( "\tcut_lists:\n" );
			for( i=0 ; i<NMG_TBL_END( &cut_list ) ; i++ )
d5659 2
a5660 2
				v = (struct vertex *)NMG_TBL_GET( &cut_list, i );
				rt_log( "\t\t%d, x%x\n", i+1, v );
d5668 1
a5668 1
	if( NMG_TBL_END( &cut_list ) < 2 )
d5670 1
a5670 1
		nmg_tbl( &cut_list, TBL_FREE, (long *)NULL );
d5673 1
a5673 1
			rt_log( "No loops need cutting\n" );
d5679 1
a5679 1
		struct nmg_ptbl lus;
d5682 1
a5682 1
			rt_log( "Loop is a crack\n" );
d5685 1
a5685 1
		while( i < NMG_TBL_END( &cut_list ) )
d5689 2
a5690 2
			vcut1 = (struct vertex *)NMG_TBL_GET( &cut_list, i );
			for( RT_LIST_FOR( vu, vertexuse, &vcut1->vu_hd ) )
d5696 1
a5696 1
				if( NMG_ARE_EUS_ADJACENT( eu, RT_LIST_PNEXT_CIRC( edgeuse, &eu->l ) ) )
d5699 1
a5699 1
					nmg_tbl( &cut_list, TBL_RM, (long *)vcut1 );
d5701 1
a5701 1
				else if( NMG_ARE_EUS_ADJACENT( eu, RT_LIST_PPREV_CIRC( edgeuse, &eu->l ) ) )
d5704 1
a5704 1
					nmg_tbl( &cut_list, TBL_RM, (long *)vcut1 );
d5710 1
a5710 1
		if( NMG_TBL_END( &cut_list ) == 0 )
d5712 1
a5712 1
			nmg_tbl( &cut_list, TBL_FREE, (long *)NULL );
d5715 1
a5715 1
				rt_log( "no loops need cutting\n" );
d5719 3
a5721 3
		nmg_tbl( &lus, TBL_INIT, (long *)NULL );
		nmg_tbl( &lus, TBL_INS, (long *)lu );
		for( i=0 ; i<NMG_TBL_END( &cut_list ) ; i++ )
d5726 1
a5726 1
			vcut1 = (struct vertex *)NMG_TBL_GET( &cut_list, i );
d5728 1
a5728 1
			for( j=0 ; j<NMG_TBL_END( &lus ) ; j++ )
d5735 1
a5735 1
				lu1 = (struct loopuse *)NMG_TBL_GET( &lus, j );
d5737 1
a5737 1
				for( RT_LIST_FOR( vu1, vertexuse, &vcut1->vu_hd ) )
d5742 1
a5742 1
							rt_log( "Splitting lu x%x at vu x%x\n", lu1, vu1 );
d5748 1
a5748 1
						nmg_tbl( &lus, TBL_INS, (long *)new_lu );
d5757 2
a5758 2
		nmg_tbl( &lus, TBL_FREE, (long *)NULL );
		nmg_tbl( &cut_list, TBL_FREE, (long *)NULL );
d5762 1
a5762 1
	if( NMG_TBL_END( &cut_list )%2 )
d5764 1
a5764 1
		rt_log( "Uneven number (%d) of vertices on cut list\n" , NMG_TBL_END( &cut_list ) );
d5768 1
a5768 1
	for( i=0 ; i<NMG_TBL_END( &cut_list ) ; i += 2 )
d5781 2
a5782 2
		vcut1 = (struct vertex *)NMG_TBL_GET( &cut_list, i );
		vcut2 = (struct vertex *)NMG_TBL_GET( &cut_list, i+1 );
d5785 1
a5785 1
		for( RT_LIST_FOR( vu, vertexuse, &vcut1->vu_hd ) )
d5812 1
a5812 1
		nmg_tbl( is->l1, TBL_RST, (long *)NULL );
d5815 1
a5815 1
		for( RT_LIST_FOR( vu, vertexuse, &vcut1->vu_hd ) )
d5822 1
a5822 1
		for( RT_LIST_FOR( vu, vertexuse, &vcut2->vu_hd ) )
d5829 1
a5829 1
		for( RT_LIST_FOR( lu1, loopuse, &is->fu1->lu_hd ) )
d5835 1
a5835 1
			if( RT_LIST_FIRST_MAGIC( &lu1->down_hd ) != NMG_EDGEUSE_MAGIC )
d5838 1
a5838 1
			for( RT_LIST_FOR( eu1, edgeuse, &lu1->down_hd ) )
d5847 1
a5847 1
				code = rt_isect_lseg3_lseg3( dists, is->pt, dir,
d5857 1
a5857 1
						for( RT_LIST_FOR( vu, vertexuse, &eu1->vu_p->v_p->vu_hd ) )
d5866 1
a5866 1
						for( RT_LIST_FOR( vu, vertexuse, &eu1->eumate_p->vu_p->v_p->vu_hd ) )
d5899 1
a5899 1
				for( RT_LIST_FOR( vu, vertexuse, &hit_v->vu_hd ) )
d5908 2
a5909 2
			rt_log( "nmg_cut_lu_into_coplanar_and_non: calling face cutter\n" );
		nmg_tbl( is->l2, TBL_RST, (long *)NULL );
d5917 1
a5917 1
	nmg_tbl( &cut_list, TBL_FREE, (long *)NULL );
d5923 2
a5924 2
struct nmg_ptbl *eu1_list;
struct nmg_ptbl *eu2_list;
d5928 1
a5928 1
	struct nmg_ptbl v_list;
d5933 1
a5933 1
		rt_log( "nmg_isect_coplanar_edges START\n" );
d5936 2
a5937 2
	NMG_CK_PTBL( eu1_list );
	NMG_CK_PTBL( eu2_list );
d5946 2
a5947 2
		rt_log( "pl1 = %g %g %g %g\n", V4ARGS( pl1 ) );
		rt_log( "pl2 = %g %g %g %g\n", V4ARGS( pl2 ) );
d5951 1
a5951 1
	for( i=0 ; i<NMG_TBL_END( eu1_list ) ; i++ )
d5959 1
a5959 1
		eu1 = (struct edgeuse *)NMG_TBL_GET( eu1_list, i );
d5968 1
a5968 1
			rt_log( "Considering EU x%x (%g %g %g) <-> (%g %g %g)\n",
d5976 1
a5976 1
				rt_log( "\tvg1a is not in other plane (%g)\n", DIST_PT_PLANE( vg1a->coord, pl2 ) );
d5982 1
a5982 1
				rt_log( "\tvg1b is not in other plane (%g)\n", DIST_PT_PLANE( vg1b->coord, pl2 ) );
d5991 1
a5991 1
		for( j=0 ; j<NMG_TBL_END( eu2_list ) ; j++ )
d6006 1
a6006 1
			eu2 = (struct edgeuse *)NMG_TBL_GET( eu2_list, j );
d6010 1
a6010 1
				rt_log( "\tConsidering EU2 x%x (%g %g %g) <-> (%g %g %g)\n",
d6017 1
a6017 1
					rt_log( "\t\tEU2 start pt not in other plane (%g)\n",
d6024 1
a6024 1
					rt_log( "\t\tEU2 end pt not in other plane (%g)\n",
d6051 1
a6051 1
				rt_log( "\tcode = %d\n", code );
d6121 1
a6121 1
					rt_log( "\tdist[%d] = %g\n", hit_no, dist[hit_no] );
d6142 1
a6142 1
					rt_log( "eus x%x and x%x intersect #%d at (%g %g %g)\n",
d6154 1
a6154 1
					rt_log( "Found vertex (x%x) at hit_pt\n", hitv );
d6159 1
a6159 1
						rt_log( "Splitting eu1 x%x\n", eu1 );
d6168 1
a6168 1
					nmg_tbl( eu1_list, TBL_INS, (long *)new_eu );
d6173 1
a6173 1
						rt_log( "Splitting eu2 x%x\n",  eu2 );
d6178 1
a6178 1
					nmg_tbl( eu2_list, TBL_INS, (long *)new_eu );
d6187 2
a6188 2
	nmg_tbl( eu1_list, TBL_FREE, (long *)NULL );
	nmg_tbl( eu2_list, TBL_FREE, (long *)NULL );
d6195 1
a6195 1
	for( i=0 ; i<NMG_TBL_END( &v_list ) ; i++ )
d6200 1
a6200 1
		v = (struct vertex *)NMG_TBL_GET( &v_list, i );
d6216 1
a6216 1
				rt_log( "Making dualvu of vertex x%x in is->fu2 x%x\n", v, is->fu2 );
d6220 1
a6220 1
	nmg_tbl( &v_list, TBL_RST, (long *)NULL );
d6225 1
a6225 1
	for( i=0 ; i<NMG_TBL_END( &v_list ) ; i++ )
d6230 1
a6230 1
		v = (struct vertex *)NMG_TBL_GET( &v_list, i );
d6246 1
a6246 1
				rt_log( "Making dualvu of vertex x%x in fu1 x%x\n", v, is->fu1 );
d6251 1
a6251 1
	nmg_tbl( &v_list, TBL_FREE, (long *)NULL );
d6253 2
a6254 2
	nmg_tbl( is->l1, TBL_RST, (long *)NULL );
	nmg_tbl( is->l2, TBL_RST, (long *)NULL );
d6256 1
a6256 1
	for( RT_LIST_FOR( lu, loopuse, &is->fu1->lu_hd ) )
d6262 1
a6262 1
		if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d6265 1
a6265 1
		for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d6287 1
a6287 1
				rt_log( "Making EU x%x an intersect line for face cutting\n", eu );
d6289 1
a6289 1
			for( RT_LIST_FOR( vu, vertexuse, &v1->vu_hd ) )
d6299 1
a6299 1
			for( RT_LIST_FOR( vu, vertexuse, &v2->vu_hd ) )
d6311 1
a6311 1
				rt_log( "Calling face cutter for fu2 x%x\n", is->fu2 );
d6314 2
a6315 2
			nmg_tbl( is->l1, TBL_RST, (long *)NULL );
			nmg_tbl( is->l2, TBL_RST, (long *)NULL );
d6319 1
a6319 1
	for( RT_LIST_FOR( lu, loopuse, &is->fu2->lu_hd ) )
d6325 1
a6325 1
		if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d6328 1
a6328 1
		for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d6350 1
a6350 1
				rt_log( "Making EU x%x an intersect line for face cutting\n", eu );
d6352 1
a6352 1
			for( RT_LIST_FOR( vu, vertexuse, &v1->vu_hd ) )
d6362 1
a6362 1
			for( RT_LIST_FOR( vu, vertexuse, &v2->vu_hd ) )
d6374 1
a6374 1
				rt_log( "Calling face cutter for fu1 x%x\n", is->fu1 );
d6377 2
a6378 2
			nmg_tbl( is->l1, TBL_RST, (long *)NULL );
			nmg_tbl( is->l2, TBL_RST, (long *)NULL );
d6391 3
a6393 3
	rt_log( "STARTDATA\n" );
	rt_log( "%f %f %f %f\n", V4ARGS( pl1 ) );
	rt_log( "%f %f %f %f\n", V4ARGS( pl2 ) );
d6396 1
a6396 1
	rt_log( "ENDDATA\n" );
d6404 1
a6404 1
CONST struct rt_tol *tol;
d6406 1
a6406 1
	struct nmg_ptbl edges;
d6415 1
a6415 1
	RT_CK_TOL( tol );
d6417 1
a6417 1
	nmg_tbl( &edges, TBL_INIT, (long *)NULL );
d6420 1
a6420 1
	for( i=0 ; i<NMG_TBL_END( &edges ) ; i++ )
d6428 1
a6428 1
		e = (struct edge *)NMG_TBL_GET( &edges,  i );
d6461 1
a6461 1
					rt_log( "Too many faces in nmg_check_radial_angles (%d)\n", face_count );
d6476 1
a6476 1
			if( angle[j] == 0.0 || angle[j] == rt_twopi )
d6502 4
a6505 4
				rt_log( str );
				rt_log( "nmg_check_radial_angles(): angles not monotonically increasing or decreasing\n" );
				rt_log( "start=%d, increasing = %d\n", start, increasing );
				rt_log( "\tfaces around eu x%x\n", eu_start );
d6507 1
a6507 1
					rt_log( "\t\tfu=x%x, angle=%g\n", fus[j], angle[j]*180.0/rt_pi );
d6512 1
a6512 1
	nmg_tbl( &edges, TBL_FREE, (long *)NULL );
d6518 1
a6518 1
 *	according to rt_isect_2planes(). Also, some (but not all) of the vertices in
d6539 1
a6539 1
	struct nmg_ptbl loops;
d6543 5
a6547 5
	struct nmg_ptbl eu1_list;
	struct nmg_ptbl vert_list1;
	struct nmg_ptbl eu2_list;
	struct nmg_ptbl vert_list2;
	struct nmg_ptbl verts;
d6554 1
a6554 1
		rt_log( "nmg_isect_nearly_coplanar_faces( fu1=x%x, fu2=x%x )\n", fu1, fu2 );
d6569 1
a6569 1
	is->mag_len = 2 * (NMG_TBL_END( &eu1_list ) + NMG_TBL_END( &eu2_list ) );
d6579 2
a6580 2
	nmg_tbl( &vert_list1, TBL_INIT, (long *)NULL );
	nmg_tbl( &vert_list2, TBL_INIT, (long *)NULL );
d6593 1
a6593 1
	for( RT_LIST_FOR( lu, loopuse, &fu1->lu_hd ) )
d6596 1
a6596 1
		if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d6599 1
a6599 1
		for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d6641 1
a6641 1
			code = rt_isect_line3_plane( &dist, vg1->coord, dir, pl2, &is->tol );
d6644 1
a6644 1
				rt_log( "nmg_isect_nearly_coplanar_faces: EU (x%x) goes from %s to %s\n",
d6646 2
a6647 2
				rt_log( "But rt_isect_line3_plane() returns %d\n", code );
				rt_log( "pl2 = ( %g %g %g %g )\n", V4ARGS( pl2 ) );
d6654 1
a6654 1
				rt_log( "nmg_isect_nearly_coplanar_faces: EU (x%x) goes from %s to %s\n",
d6656 2
a6657 2
				rt_log( "But rt_isect_line3_plane() returns %d and dist=%g\n", code, dist );
				rt_log( "pl2 = ( %g %g %g %g )\n", V4ARGS( pl2 ) );
d6677 2
a6678 2
				rt_log( "nmg_cut_lu_into_coplanar_and_non:\n" );
				rt_log( "\tsplitting eu x%x at v=x%x (%g %g %g)\n",
d6686 3
a6688 3
	nmg_tbl( &loops, TBL_INIT, (long *)NULL );
	for( RT_LIST_FOR( lu, loopuse, &fu1->lu_hd ) )
		nmg_tbl( &loops,  TBL_INS, (long *)lu );
d6693 1
a6693 1
	for( i=0 ; i<NMG_TBL_END( &loops ) ; i++ )
d6695 1
a6695 1
		lu = (struct loopuse *)NMG_TBL_GET( &loops, i );
d6702 1
a6702 1
	for( RT_LIST_FOR( lu, loopuse, &fu2->lu_hd ) )
d6705 1
a6705 1
		if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d6708 1
a6708 1
		for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d6750 1
a6750 1
			code = rt_isect_line3_plane( &dist, vg1->coord, dir, pl1, &is->tol );
d6753 1
a6753 1
				rt_log( "nmg_isect_nearly_coplanar_faces: EU (x%x) goes from %s to %s\n",
d6755 2
a6756 2
				rt_log( "But rt_isect_line3_plane() returns %d\n", code );
				rt_log( "pl1 = ( %g %g %g %g )\n", V4ARGS( pl1 ) );
d6763 1
a6763 1
				rt_log( "nmg_isect_nearly_coplanar_faces: EU (x%x) goes from %s to %s\n",
d6765 2
a6766 2
				rt_log( "But rt_isect_line3_plane() returns %d and dist=%g\n", code, dist );
				rt_log( "pl1 = ( %g %g %g %g )\n", V4ARGS( pl1 ) );
d6786 3
a6788 3
	nmg_tbl( &loops, TBL_RST, (long *)NULL );
	for( RT_LIST_FOR( lu, loopuse, &fu2->lu_hd ) )
		nmg_tbl( &loops,  TBL_INS, (long *)lu );
d6793 1
a6793 1
	for( i=0 ; i<NMG_TBL_END( &loops ) ; i++ )
d6795 1
a6795 1
		lu = (struct loopuse *)NMG_TBL_GET( &loops, i );
d6804 1
a6804 1
	for( RT_LIST_FOR( lu, loopuse, &fu1->lu_hd ) )
d6806 1
a6806 1
		if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d6809 1
a6809 1
		for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d6811 1
a6811 1
			if( nmg_tbl( &eu1_list, TBL_LOC, (long *)eu ) != (-1) )
d6815 1
a6815 1
			for( i=0 ; i<NMG_TBL_END( &verts ) ; i++ )
d6822 1
a6822 1
				v = (struct vertex *)NMG_TBL_GET( &verts , i );
d6830 1
a6830 1
				code = rt_dist_pt3_lseg3( dist, pca, eu->vu_p->v_p->vg_p->coord,
d6837 1
a6837 1
					rt_log( "nmg_isect_nearly_coplanar_faces: vertices should have been fused x%x and x%x\n", v, eu->vu_p->v_p );
d6839 1
a6839 1
					rt_log( "nmg_isect_nearly_coplanar_faces: vertices should have been fused x%x and x%x\n", v, eu->eumate_p->vu_p->v_p );
d6850 1
a6850 1
	for( RT_LIST_FOR( lu, loopuse, &fu2->lu_hd ) )
d6852 1
a6852 1
		if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d6855 1
a6855 1
		for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d6857 1
a6857 1
			if( nmg_tbl( &eu1_list, TBL_LOC, (long *)eu ) != (-1) )
d6861 1
a6861 1
			for( i=0 ; i<NMG_TBL_END( &verts ) ; i++ )
d6868 1
a6868 1
				v = (struct vertex *)NMG_TBL_GET( &verts , i );
d6876 1
a6876 1
				code = rt_dist_pt3_lseg3( dist, pca, eu->vu_p->v_p->vg_p->coord,
d6883 1
a6883 1
					rt_log( "nmg_isect_nearly_coplanar_faces: vertices should have been fused x%x and x%x\n", v, eu->vu_p->v_p );
d6885 1
a6885 1
					rt_log( "nmg_isect_nearly_coplanar_faces: vertices should have been fused x%x and x%x\n", v, eu->eumate_p->vu_p->v_p );
d6895 2
a6896 2
	nmg_tbl( &loops, TBL_FREE, (long *)NULL );
	nmg_tbl( &verts, TBL_FREE, (long *)NULL );
d6903 1
a6903 1
		rt_log( "After splitting loops into coplanar and non:\n" );
d6910 1
a6910 1
		for( RT_LIST_FOR( lu, loopuse, &fu1->lu_hd ) )
d6914 1
a6914 1
			for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d6931 1
a6931 1
				rt_log( "lu x%x is in and out of fu x%x\n", lu, fu2 );
d6933 1
a6933 1
				rt_log( "lu x%x is inside of fu x%x\n", lu, fu2 );
d6935 1
a6935 1
				rt_log( "lu x%x is outside of fu x%x\n", lu, fu2 );
d6937 1
a6937 1
				rt_log( "lu x%x is on of fu x%x\n", lu, fu2 );
d6939 1
a6939 1
				rt_log( "Can't figure lu x%x w.r.t fu x%x, on=%d, in=%d, out=%d\n",
d6943 1
a6943 1
		for( RT_LIST_FOR( lu, loopuse, &fu2->lu_hd ) )
d6947 1
a6947 1
			for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d6964 1
a6964 1
				rt_log( "lu x%x is in and out of fu x%x\n", lu, fu1 );
d6966 1
a6966 1
				rt_log( "lu x%x is inside of fu x%x\n", lu, fu1 );
d6968 1
a6968 1
				rt_log( "lu x%x is outside of fu x%x\n", lu, fu1 );
d6970 1
a6970 1
				rt_log( "lu x%x is on of fu x%x\n", lu, fu1 );
d6972 1
a6972 1
				rt_log( "Can't figure lu x%x w.r.t fu x%x, on=%d, in=%d, out=%d\n",
d6978 2
a6979 2
	nmg_tbl( &eu1_list, TBL_RST, (long *)NULL );
	nmg_tbl( &eu2_list, TBL_RST, (long *)NULL );
d6989 2
a6990 2
	nmg_tbl( is->l1, TBL_FREE, (long *)NULL );
	nmg_tbl( is->l2, TBL_FREE, (long *)NULL );
d6997 1
a6997 1
		rt_log( "After intersection nearly coplanar faces:\n" );
d7004 1
a7004 1
		for( RT_LIST_FOR( lu, loopuse, &fu1->lu_hd ) )
d7008 1
a7008 1
			for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d7025 1
a7025 1
				rt_log( "lu x%x is in and out of fu x%x\n", lu, fu2 );
d7027 1
a7027 1
				rt_log( "lu x%x is inside of fu x%x\n", lu, fu2 );
d7029 1
a7029 1
				rt_log( "lu x%x is outside of fu x%x\n", lu, fu2 );
d7031 1
a7031 1
				rt_log( "lu x%x is on of fu x%x\n", lu, fu2 );
d7033 1
a7033 1
				rt_log( "Can't figure lu x%x w.r.t fu x%x, on=%d, in=%d, out=%d\n",
d7037 1
a7037 1
		for( RT_LIST_FOR( lu, loopuse, &fu2->lu_hd ) )
d7041 1
a7041 1
			for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d7058 1
a7058 1
				rt_log( "lu x%x is in and out of fu x%x\n", lu, fu1 );
d7060 1
a7060 1
				rt_log( "lu x%x is inside of fu x%x\n", lu, fu1 );
d7062 1
a7062 1
				rt_log( "lu x%x is outside of fu x%x\n", lu, fu1 );
d7064 1
a7064 1
				rt_log( "lu x%x is on of fu x%x\n", lu, fu1 );
d7066 1
a7066 1
				rt_log( "Can't figure lu x%x w.r.t fu x%x, on=%d, in=%d, out=%d\n",
d7088 1
a7088 1
CONST struct rt_tol *tol;
d7097 1
a7097 1
	struct nmg_ptbl verts;
d7103 1
a7103 1
	RT_CK_TOL( tol );
d7127 1
a7127 1
	if( rt_mkpoint_3planes( bs->pt, tmp_pl, pl1, pl2 ) )
d7141 1
a7141 1
	for( i=0 ; i<NMG_TBL_END( &verts ) ; i++ )
d7149 1
a7149 1
		v = (struct vertex *)NMG_TBL_GET( &verts, i );
d7182 1
a7182 1
	nmg_tbl( &verts, TBL_FREE, (long *)NULL );
d7202 1
a7202 1
	for( i=0 ; i<NMG_TBL_END( &verts ) ; i++ )
d7210 1
a7210 1
		v = (struct vertex *)NMG_TBL_GET( &verts, i );
d7243 1
a7243 1
	nmg_tbl( &verts, TBL_FREE, (long *)NULL );
d7265 1
a7265 1
CONST struct rt_tol	*tol;
d7277 1
a7277 1
	RT_CK_TOL(tol);
d7296 1
a7296 1
		rt_log("\nnmg_isect_two_generic_faces(fu1=x%x, fu2=x%x)\n", fu1, fu2);
d7298 1
a7298 1
		rt_log("Planes\t%gx + %gy + %gz = %g\n\t%gx + %gy + %gz = %g\n",
d7301 2
a7302 2
		rt_log( "Cosine of angle between planes = %g\n" , VDOT( pl1 , pl2 ) );
		rt_log( "fu1:\n" );
d7304 1
a7304 1
		rt_log( "fu2:\n" );
d7313 1
a7313 1
			rt_log("co-planar faces (shared fg)\n");
d7344 1
a7344 1
		status = rt_isect_2planes( bs.pt, bs.dir, pl1, pl2,
d7348 1
a7348 1
			rt_log( "\tnmg_isect_two_generic_faces: intersect ray start (%f , %f , %f )\n\t\tin direction (%f , %f , %f )\n",
d7380 1
a7380 1
			struct nmg_ptbl verts;
d7392 1
a7392 1
			for( i=0 ; i<NMG_TBL_END( &verts ) ; i++ )
d7396 1
a7396 1
				v = (struct vertex *)NMG_TBL_GET( &verts, i );
d7403 1
a7403 1
			nmg_tbl( &verts, TBL_FREE, (long *)NULL );
d7409 2
a7410 2
					rt_log( "nmg_isect_two_generic_faces: rt_isect_2planes() says faces are coplanar.\n" );
					rt_log( "\tbut all vertices of fu1 (x%x) are at least %gmm above plane of fu2 (x%x)\n",
d7419 2
a7420 2
					rt_log( "nmg_isect_two_generic_faces: rt_isect_2planes() says faces are coplanar.\n" );
					rt_log( "\tbut all vertices of fu1 (x%x) are at least %gmm below plane of fu2 (x%x)\n",
d7428 1
a7428 1
					rt_log( "nmg_isect_two_generic_faces: coplanar faces don't share face geometry, intersecting anyway\n" );
d7436 1
a7436 1
				for( i=0 ; i<NMG_TBL_END( &verts ) ; i++ )
d7440 1
a7440 1
					v = (struct vertex *)NMG_TBL_GET( &verts, i );
d7447 1
a7447 1
				nmg_tbl( &verts, TBL_FREE, (long *)NULL );
d7453 2
a7454 2
						rt_log( "nmg_isect_two_generic_faces: rt_isect_2planes() says faces are coplanar.\n" );
						rt_log( "\tbut all vertices of fu2 (x%x) are at least %gmm above plane of fu1 (x%x)\n",
d7463 2
a7464 2
						rt_log( "nmg_isect_two_generic_faces: rt_isect_2planes() says faces are coplanar.\n" );
						rt_log( "\tbut all vertices of fu2 (x%x) are at least %gmm below plane of fu1 (x%x)\n",
d7472 1
a7472 1
						rt_log( "nmg_isect_two_generic_faces: coplanar faces don't share face geometry, intersecting anyway\n" );
d7479 4
a7482 4
				rt_log( "nmg_isect_two_generic_faces: FUs x%x and x%x do not share face geometry\n", fu1, fu2 );
				rt_log( "\tbut rt_isect_2planes() says they are coplanar or parallel\n" );
				rt_log( "max_dist1 = %g, min_dist1 = %g\n", max_dist1, min_dist1 );
				rt_log( "max_dist2 = %g, min_dist2 = %g\n", max_dist2, min_dist2 );
d7511 1
a7511 1
		rt_log("ERROR nmg_isect_two_generic_faces() unable to find plane intersection\n");
d7542 1
a7542 1
    	    		rt_log("overlay %s\n", name);
d7549 1
a7549 1
    	    		rt_log("overlay %s\n", name);
d7604 1
a7604 1
	vu1b = RT_LIST_PNEXT_CIRC( edgeuse, eu1 )->vu_p;
d7606 1
a7606 1
	vu2b = RT_LIST_PNEXT_CIRC( edgeuse, eu2 )->vu_p;
d7613 1
a7613 1
		rt_log("nmg_isect_edge3p_edge3p(eu1=x%x, eu2=x%x)\n\tvu1a=%x vu1b=%x, vu2a=%x vu2b=%x\n\tv1a=%x v1b=%x,   v2a=%x v2b=%x\n",
d7625 1
a7625 1
			rt_log("nmg_isect_edge3p_edge3p: shared edge topology, both ends\n");
d7635 1
a7635 1
	status = rt_isect_lseg3_lseg3( dist,
d7640 1
a7640 1
		rt_log("\trt_isect_line3_lseg3()=%d, dist: %g, %g\n",
d7651 1
a7651 1
		rt_log("nmg_isect_edge3p_edge3p() colinear case.  Untested waters.\n");
d7656 1
a7656 1
		(void)nmg_isect_2colinear_edge2p( eu1, eu2, (struct faceuse *)NULL, is, (struct nmg_ptbl *)0, (struct nmg_ptbl *)0 );
d7734 1
a7734 1
	code = rt_isect_pt_lseg( &dist, eu2->vu_p->v_p->vg_p->coord,
d7746 1
a7746 1
		vu2 = RT_LIST_NEXT( edgeuse, &eu2->l)->vu_p;
d7757 2
a7758 2
	(void)nmg_tbl(is->l1, TBL_INS_UNIQUE, &vu1->l.magic);
	(void)nmg_tbl(is->l2, TBL_INS_UNIQUE, &vu2->l.magic);
d7808 1
a7808 1
		rt_log("nmg_isect_edge3p_shell(, eu1=x%x, s2=x%x) START\n",
d7824 1
a7824 1
	for( RT_LIST_FOR( fu2, faceuse, &s2->fu_hd ) )  {
d7835 1
a7835 1
	for( RT_LIST_FOR( lu2, loopuse, &s2->lu_hd ) )  {
d7838 1
a7838 1
		if( RT_LIST_FIRST_MAGIC( &lu2->down_hd ) == NMG_VERTEXUSE_MAGIC)  {
d7840 1
a7840 1
			vu2 = RT_LIST_FIRST( vertexuse, &lu2->down_hd );
d7845 1
a7845 1
		for( RT_LIST_FOR( eu2, edgeuse, &lu2->down_hd ) )  {
d7852 1
a7852 1
	for( RT_LIST_FOR( eu2, edgeuse, &s2->eu_hd ) )  {
d7891 1
a7891 1
		neu1 = nmg_meonvu( RT_LIST_FIRST( vertexuse, &lu2->down_hd ) );
d7902 1
a7902 1
		rt_log("nmg_isect_edge3p_shell(, eu1=x%x, s2=x%x) Added wire lu=x%x\n",
d7908 1
a7908 1
		rt_log("nmg_isect_edge3p_shell(, eu1=x%x, s2=x%x) END\n",
d7924 1
a7924 1
CONST struct rt_tol	*tol;
d7926 1
a7926 1
	struct nmg_ptbl		vert_list1, vert_list2;
d7939 1
a7939 1
		rt_log("nmg_crackshells(s1=x%x, s2=x%x)\n", s1, s2);
d7941 1
a7941 1
	RT_CK_TOL(tol);
d7965 2
a7966 2
	(void)nmg_tbl(&vert_list1, TBL_INIT, (long *)NULL);
	(void)nmg_tbl(&vert_list2, TBL_INIT, (long *)NULL);
d7987 1
a7987 1
	for( RT_LIST_FOR( fu1, faceuse, &s1->fu_hd ) )  {
d8008 1
a8008 1
	    	for( RT_LIST_FOR( fu2, faceuse, &s2->fu_hd ) )  {
d8031 1
a8031 1
		for( RT_LIST_FOR( lu2, loopuse, &s2->lu_hd ) )  {
d8038 1
a8038 1
		for( RT_LIST_FOR( eu2, edgeuse, &s2->eu_hd ) )  {
d8060 1
a8060 1
	for( RT_LIST_FOR( lu1, loopuse, &s1->lu_hd ) )  {
d8064 1
a8064 1
		for( RT_LIST_FOR( eu1, edgeuse, &lu1->down_hd ) )  {
d8072 1
a8072 1
	for( RT_LIST_FOR( eu1, edgeuse, &s1->eu_hd ) )  {
d8080 1
a8080 1
	    	for( RT_LIST_FOR( fu2, faceuse, &s2->fu_hd ) )  {
d8086 1
a8086 1
		for( RT_LIST_FOR( lu2, loopuse, &s2->lu_hd ) )  {
d8090 1
a8090 1
			for( RT_LIST_FOR( eu2, edgeuse, &lu2->down_hd ) )  {
d8096 1
a8096 1
		for( RT_LIST_FOR( eu2, edgeuse, &s2->eu_hd ) )  {
d8107 2
a8108 2
	(void)nmg_tbl(&vert_list1, TBL_FREE, (long *)NULL);
	(void)nmg_tbl(&vert_list2, TBL_FREE, (long *)NULL);
d8142 1
a8142 1
	for( RT_LIST_FOR( lu, loopuse, &fu->lu_hd ) )  {
d8152 1
a8152 1
			rt_log("nmg_fu_touchingloops(lu=x%x, vu=x%x, v=x%x)\n",
@


11.43
log
@Added some debug code to nmg_isect_nearly_coplanar_faces().
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 11.42 1996/06/27 18:17:04 jra Exp jra $ (ARL)";
d1531 1
a1531 1
		if( nmg_isect_2colinear_edge2p( eu1, eu2, fu2, is, 0, 0 ) > 2 )  {
d2554 2
a2555 2
		nmg_get_2d_vertex( pt1a, eu1->vu_p->v_p, is, fu1 );
		nmg_get_2d_vertex( pt1b, eu1->eumate_p->vu_p->v_p, is, fu1 );
d2573 2
a2574 2
			nmg_get_2d_vertex( pt2a, eu2->vu_p->v_p, is, fu1 );
			nmg_get_2d_vertex( pt2b, eu2->eumate_p->vu_p->v_p, is, fu1 );
d2646 1
a2646 1
					nmg_get_2d_vertex( pt1b, eu1->eumate_p->vu_p->v_p, is, fu1 );
a5597 2
		fastf_t dist1,dist2;

a5598 1
		dist1 = dist2;
d7656 1
a7656 1
		(void)nmg_isect_2colinear_edge2p( eu1, eu2, (struct faceuse *)NULL, is, 0, 0 );
@


11.42
log
@Added code to nmg_isect_two_generic_faces() to further limit the use of nmg_isect_nearly_coplanar_faces().
Also added edge splitting to nmg_isect_nearly_coplanar_faces() after call to nmg_cut_lu_into_coplanar_and_non().
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 11.41 1996/06/14 19:57:35 jra Exp jra $ (ARL)";
d5674 3
d5716 3
d5744 2
d5910 2
d6901 79
d6994 79
@


11.41
log
@Added code to nmg_cut_lu_into_coplanar_and_non() to try to handle some pathological cases.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 11.40 1996/05/16 21:59:41 jra Exp jra $ (ARL)";
d3592 1
d3609 2
a3610 1
	if( DIST_PT_PLANE( vg->coord, pl1 ) > is->tol.dist )
d3612 2
a3613 1
	if( DIST_PT_PLANE( vg->coord, pl2 ) > is->tol.dist )
d5739 4
a5742 2
						new_lu->orientation = OT_SAME;
						new_lu->lumate_p->orientation = OT_SAME;
d6540 1
d6794 93
a6886 1
	/* XXXX Need to break edges in faces on vertices that may lie on new edges formed by cuts */
d6889 1
d6908 184
d7333 9
a7341 1
				nmg_isect_nearly_coplanar_faces( &bs, fu1, fu2 );
@


11.40
log
@Delayed removal of OT_BOOLPLACE loops till after shared vertices are identified.
Made requirements for coplanar faces more stringent.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 11.39 1996/05/07 14:11:37 jra Exp jra $ (ARL)";
d5577 1
d5579 2
d5582 1
d5584 2
d5587 1
d5589 3
a5600 3
		if( class1 == NMG_CLASS_AonBshared )
			on++;

d5605 1
d5607 2
d5610 1
d5612 2
d5615 1
d5617 2
d5623 1
d5625 1
a5631 2
			else
				vcut1 = (struct vertex *)NULL;
d5636 1
d5638 1
a5644 2
			else
				vcut1 = (struct vertex *)NULL;
d5651 1
a5651 1
		rt_log( "\tcut_lists=%d, on=%d\n", NMG_TBL_END( &cut_list ),on );
d5674 78
d5760 1
a5760 1
		struct loopuse *lu;
d5769 1
d5774 17
d5819 1
a5819 1
		for( RT_LIST_FOR( lu, loopuse, &is->fu1->lu_hd ) )
d5823 1
a5823 1
			NMG_CK_LOOPUSE( lu );
d5825 1
a5825 1
			if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d5828 1
a5828 1
			for( RT_LIST_FOR( eu1, edgeuse, &lu->down_hd ) )
d6787 2
@


11.39
log
@Changes due to change in calling sequence for nmg_break_all_es_on_v().
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 11.38 1996/05/01 13:35:14 jra Exp jra $ (ARL)";
d6809 2
d6867 1
a6867 1
				coplanar = 1;
d6870 1
a6870 1
			if( !coplanar && !parallel )
d6911 1
a6911 1
					coplanar = 1;
d6923 3
d6946 2
a6947 1

d6951 1
a6951 1

d7545 2
a7546 1

d7550 1
a7550 1

@


11.38
log
@Fixed memory leak in nmg_isect_fu_jra().
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 11.37 1996/04/30 20:35:32 jra Exp jra $ (ARL)";
d2661 1
a2661 1
					(void)nmg_model_break_all_es_on_v( m, hitv, &is->tol );
d4070 1
a4070 1
		(void)nmg_model_break_all_es_on_v( m, v, &is->tol );
d4135 1
a4135 1
			(void)nmg_model_break_all_es_on_v( m, v, &is->tol );
d6058 1
a6058 1
					(void)nmg_model_break_all_es_on_v( m, hitv, &is->tol );
@


11.37
log
@Added some debug logging.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 11.36 1996/04/22 12:50:20 jra Exp jra $ (ARL)";
d4200 1
a4200 1
	nmg_tbl( &verts2, TBL_RST, (long *)NULL );
d4222 1
a4222 1
	nmg_tbl( &verts1, TBL_RST, (long *)NULL );
@


11.36
log
@Added nmg_isect_nearly_coplanar_faces() and support routines
and incorporated them into Boolean evaluation code.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 11.35 1996/03/18 00:05:15 jra Exp jra $ (ARL)";
d155 3
d160 3
d164 1
d169 2
d184 6
d194 3
@


11.35
log
@Many more mods. Rewrite of Face intersection routines.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 11.34 1996/03/05 21:31:20 jra Exp jra $ (ARL)";
d973 1
a973 1
			&is->tol );
d2120 1
a2120 1
 *  See the comment in nmg_isect_two_generic_faces() for details
d2669 1
a2669 1
			(char *)NULL, 0, &is->tol );
d2696 1
a2696 1
			(char *)NULL, 0, &is->tol );
d2828 4
d2833 2
d3601 1
a3601 1
		(void *)NULL, (void *)NULL, (char *)NULL, 0, &is->tol );
d3606 1
a3606 1
		(void *)NULL, (void *)NULL, (char *)NULL, 0, &is->tol );
d3918 1
d3923 47
d4001 1
a4001 1
			0, 0, (char *)NULL, 0, &is->tol );
d4408 1
a4408 1
						if( nmg_class_pt_fu_except( vg->coord, fu2, (struct loopuse *)NULL, NULL, NULL, (char *)NULL, 0, &(is->tol) ) != NMG_CLASS_AoutB )
d4427 1
a4427 1
						if( nmg_class_pt_fu_except( vg->coord, fu2, (struct loopuse *)NULL, NULL, NULL, (char *)NULL, 0, &(is->tol) ) != NMG_CLASS_AoutB )
d4455 1
a4455 1
						if( nmg_class_pt_fu_except( vg->coord, fu1, (struct loopuse *)NULL, NULL, NULL, (char *)NULL, 0, &(is->tol) ) != NMG_CLASS_AoutB )
d4474 1
a4474 1
						if( nmg_class_pt_fu_except( vg->coord, fu1, (struct loopuse *)NULL, NULL, NULL, (char *)NULL, 0, &(is->tol) ) != NMG_CLASS_AoutB )
d4621 1
a4621 1
				if( (class=nmg_class_pt_fu_except( hit_v->vg_p->coord, fu1, (struct loopuse *)NULL, NULL, NULL, (char *)NULL, 0, &(is->tol) )) == NMG_CLASS_AoutB )
d4629 1
a4629 1
				else if( (class=nmg_class_pt_fu_except( hit_v->vg_p->coord, fu2, (struct loopuse *)NULL, NULL, NULL, (char *)NULL, 0, &(is->tol) )) == NMG_CLASS_AoutB )
d4687 1
a4687 1
		if( (class=nmg_class_pt_fu_except( hit3d, fu1, (struct loopuse *)NULL, NULL, NULL, (char *)NULL, 0, &(is->tol) )) == NMG_CLASS_AoutB )
d4695 1
a4695 1
		else if( (class=nmg_class_pt_fu_except( hit3d, fu2, (struct loopuse *)NULL, NULL, NULL, (char *)NULL, 0, &(is->tol) )) == NMG_CLASS_AoutB )
d5521 1156
d6730 1
d6735 1
a6735 1
		goto coplanar;
d6762 4
a6765 2
	status = rt_isect_2planes( bs.pt, bs.dir, pl1, pl2,
		min_pt, tol );
d6767 9
a6775 8
	if (rt_g.NMG_debug & DEBUG_POLYSECT) {
		rt_log( "\tnmg_isect_two_generic_faces: intersect ray start (%f , %f , %f )\n\t\tin direction (%f , %f , %f )\n",
			bs.pt[X],
			bs.pt[Y],
			bs.pt[Z],
			bs.dir[X],
			bs.dir[Y],
			bs.dir[Z] );
d6788 1
d6790 125
a6914 7
		rt_log("co-planar faces (rt_isect_2planes)  WARNING: faces not shared.\n");
coplanar:
		bs.coplanar = 1;
		nmg_isect_two_face2p_jra( &bs, fu1, fu2 );
		break;
	case -2:
		/* parallel and distinct, no intersection */
@


11.34
log
@Many mods to convert NMG Booleans to running without state machine.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 11.33 1995/12/02 03:09:46 mike Exp $ (ARL)";
d2351 1
a2351 1

d2354 1
a2354 1

d2461 1
a2461 1
		rt_log("nmg_enlist_one_vu(vu=x%x) v=x%x, dist=%g (%s)",
d2549 1
d2565 16
a2580 1
			for( hit_no=0 ; hit_no < code ; hit_no++ )
d2584 1
a2584 1
				if( dist[hit_no] < 0.0 )
d2605 2
a2606 2
					rt_log( "eus x%x and x%x intersect at (%g %g %g)\n",
						eu1, eu2, V3ARGS( hit_pt ) );
d2625 2
d2631 1
a2631 1
				if( hitv != eu2->vu_p->v_p && hitv != eu2->eumate_p->vu_p->v_p )
d3556 1
d3559 1
a3559 1
nmg_is_vertex_on_inter( v, fu, is )
d3561 2
a3562 1
struct faceuse *fu;
d3566 1
a3566 1
	plane_t pl;
d3570 2
a3571 1
	NMG_CK_FACEUSE( fu );
d3574 1
a3574 1
	if( nmg_find_v_in_face( v, fu ) )
d3577 2
a3578 1
	NMG_GET_FU_PLANE( pl, fu );
d3583 4
a3586 2
	/* check if vertex is in plane of fu  */
	if( DIST_PT_PLANE( vg->coord, pl ) > is->tol.dist )
d3593 7
a3599 2
	/* check if it is within fu */
	code = nmg_class_pt_fu_except( vg->coord, fu, (struct loopuse *)NULL,
d3607 47
d3656 9
a3664 6
nmg_isect_fu_jra( is, fu1, fu2, eu1_list, eu2_list)
struct nmg_inter_struct	*is;
struct faceuse		*fu1;
struct faceuse		*fu2;
struct nmg_ptbl		*eu1_list;
struct nmg_ptbl		*eu2_list;
d3667 6
a3672 4
	struct nmg_ptbl verts;
	struct loopuse *lu;
	plane_t pl1,pl2;
	int i;
d3675 1
a3675 1
		rt_log( "nmg_isect_fu_jra( fu1=x%x, fu2=x%x )\n", fu1, fu2 );
d3677 7
a3683 5
	NMG_CK_INTER_STRUCT(is);
	NMG_CK_FACEUSE(fu1);
	NMG_CK_FACEUSE(fu2);
	NMG_CK_PTBL(eu1_list);
	NMG_CK_PTBL(eu2_list);
d3685 1
a3685 1
	m = nmg_find_model( &fu1->l.magic );
d3688 9
a3696 2
	NMG_GET_FU_PLANE( pl2, fu2 );
	NMG_GET_FU_PLANE( pl1, fu1 );
d3698 1
a3698 2
	/* Intersect fu1 edgeuses */
	for( RT_LIST_FOR( lu, loopuse, &fu1->lu_hd ) )
d3700 4
a3703 1
		struct edgeuse *eu;
d3705 13
a3717 1
		NMG_CK_LOOPUSE( lu );
d3719 2
a3720 2
		if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
			continue;
d3722 6
a3727 1
		for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d3729 8
a3736 10
			struct vertexuse *vu;
			struct edgeuse *new_eu;
			struct vertex *hitv;
			struct vertex_g *vg1,*vg2;
			fastf_t dist;
			fastf_t eu_len;
			fastf_t one_over_len;
			vect_t dir;
			point_t hit_pt;
			int code;
d3738 1
a3738 1
			NMG_CK_EDGEUSE( eu );
d3740 17
a3756 2
			hitv = (struct vertex *)NULL;
			vu = (struct vertexuse *)NULL;
d3758 3
a3760 11
			vg1 = eu->vu_p->v_p->vg_p;
			NMG_CK_VERTEX_G( vg1 );
			vg2 = eu->eumate_p->vu_p->v_p->vg_p;
			NMG_CK_VERTEX_G( vg2 );

			VSUB2( dir, vg2->coord, vg1->coord );
			eu_len = MAGNITUDE( dir );
			if( eu_len < is->tol.dist || eu_len < SMALL_FASTF )
				continue;
			one_over_len = 1.0/eu_len;
			VSCALE( dir, dir, one_over_len );
d3762 7
a3768 3
			/* check if edge line intersects plane of fu2 */
			if( rt_isect_line3_plane( &dist, vg1->coord, dir, pl2, &is->tol ) < 1 )
				continue;
d3770 8
a3777 3
			/* make sure intersection is within limits of eu */
			if( dist < (-is->tol.dist) || dist > eu_len+is->tol.dist )
				continue;
d3779 21
a3799 16
			/* maybe its within tolerance of an end of EU */
			if( NEAR_ZERO( dist, is->tol.dist ) )
			{
				vu = eu->vu_p;
				VMOVE( hit_pt, vg1->coord );
			}
			else if( NEAR_ZERO( eu_len - dist, is->tol.dist ) )
			{
				vu = eu->eumate_p->vu_p;
				VMOVE( hit_pt, vg2->coord );
			}
			else
			{
				fastf_t dot;
				fastf_t del_dist;
				fastf_t dist1,dist2;
d3801 2
a3802 5
				/* if the edge is nearly collinear with the plane,
				 * then look along the edge direction for a vertex
				 * that is on the edge line and within tolerance
				 * of the plane
				 */
d3804 4
a3807 2
				dot = fabs( VDOT( pl2, dir ) );
				del_dist = is->tol.dist/dot;
d3809 5
a3813 21
				dist1 = dist - del_dist;
				dist2 = dist + del_dist;
				if( dist1 <= 0.0 )
				{
					vu = eu->vu_p;
					VMOVE( hit_pt, vg1->coord );
				}
				else if( dist2 >= eu_len )
				{
					vu = eu->eumate_p->vu_p;
					VMOVE( hit_pt, vg2->coord );
				}
				else
				{
					struct vertex *v;
					struct edgeuse *eu_test;
					int code;
					point_t pca;
					point_t a,b;
					fastf_t dist3;
					struct nmg_ptbl verts;
d3815 8
a3822 1
					nmg_vertex_tabulate( &verts, &fu2->l.magic );
d3824 14
a3837 2
					VJOIN1( a, vg1->coord, dist1, dir );
					VJOIN1( b, vg1->coord, dist2, dir );
d3839 2
a3840 14
					for( i=0 ; i<NMG_TBL_END( &verts ) ; i++ )
					{
						v = (struct vertex *)NMG_TBL_GET( &verts, i );
						NMG_CK_VERTEX( v );
						code = rt_dist_pt3_lseg3( &dist3, pca, a, b,
							v->vg_p->coord, &is->tol );
						if( code > 2 )
						{
							v = (struct vertex *)NULL;
							continue;
						}
						VMOVE( hit_pt, v->vg_p->coord );
						break;
					}
d3842 16
a3857 1
					nmg_tbl( &verts, TBL_FREE, (long *)NULL );
d3859 7
a3865 10
					if( !v )
					{
						/* must be in the middle of EU */
						vu = (struct vertexuse *)NULL;
						VJOIN1( hit_pt, vg1->coord, dist, dir )
					}
					else
						vu = nmg_find_v_in_face( v, fu2 );
				}
			}
d3867 9
a3875 2
			if (rt_g.NMG_debug & DEBUG_POLYSECT)
				rt_log( "\tChecking intersection pt (%g %g %g)\n", V3ARGS( hit_pt ) );
d3877 2
a3878 6
			/* check if hit point is within fu2 */
			if( vu && nmg_find_fu_of_vu( vu ) == fu2 )
				code = NMG_CLASS_AinB;
			else
				code = nmg_class_pt_fu_except( hit_pt, fu2, (struct loopuse *)NULL,
					(void *)NULL, (void *)NULL, (char *)NULL, 0, &is->tol );
d3880 2
a3881 2
			if (rt_g.NMG_debug & DEBUG_POLYSECT)
				rt_log( "\t\thit_pt is %s with respect to fu2\n", nmg_class_name( code ) );
d3883 2
a3884 2
			if( code != NMG_CLASS_AinB )
				continue;
d3886 4
a3889 2
			if( !vu )
				vu = nmg_find_pt_in_face( fu1, hit_pt, &is->tol );
d3891 1
a3891 2
			if( !vu )
				vu = nmg_find_pt_in_face( fu2, hit_pt, &is->tol );
d3893 3
a3895 2
			if( !vu )
				hitv = nmg_find_pt_in_model( nmg_find_model( &fu1->l.magic ), hit_pt, &is->tol );
d3897 3
a3899 2
			if( vu )
				hitv = vu->v_p;
d3901 1
a3901 10
			if( hitv != eu->vu_p->v_p && hitv != eu->eumate_p->vu_p->v_p )
			{
				new_eu = nmg_esplit( hitv, eu, 1 );
				if (rt_g.NMG_debug & DEBUG_POLYSECT)
					rt_log( "\t splitting eu x%x, new_eu=x%x new_vu=x%x\n", eu, new_eu, new_eu->vu_p );
				hitv = new_eu->vu_p->v_p;
				if( !hitv->vg_p )
					nmg_vertex_gv( hitv, hit_pt );
			}
			(void)nmg_make_dualvu( hitv, fu2, &is->tol );
a3902 2
			if( hitv )
				(void)nmg_model_break_all_es_on_v( m, hitv, &is->tol );
d3906 3
a3908 2
	/* now intersect fu2 edgeuses */
	for( RT_LIST_FOR( lu, loopuse, &fu2->lu_hd ) )
d3910 2
a3911 1
		struct edgeuse *eu;
d3913 2
a3914 1
		NMG_CK_LOOPUSE( lu );
d3916 1
a3916 2
		if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
			continue;
d3918 2
a3919 1
		for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d3921 4
a3924 10
			struct vertexuse *vu;
			struct edgeuse *new_eu;
			struct vertex *hitv;
			struct vertex_g *vg1,*vg2;
			fastf_t dist;
			fastf_t eu_len;
			fastf_t one_over_len;
			vect_t dir;
			point_t hit_pt;
			int code;
d3926 11
a3936 1
			NMG_CK_EDGEUSE( eu );
d3938 6
a3943 2
			vu = (struct vertexuse *)NULL;
			hitv = (struct vertex *)NULL;
d3945 3
a3947 11
			vg1 = eu->vu_p->v_p->vg_p;
			NMG_CK_VERTEX_G( vg1 );
			vg2 = eu->eumate_p->vu_p->v_p->vg_p;
			NMG_CK_VERTEX_G( vg2 );

			VSUB2( dir, vg2->coord, vg1->coord );
			eu_len = MAGNITUDE( dir );
			if( eu_len < is->tol.dist || eu_len < SMALL_FASTF )
				continue;
			one_over_len = 1.0/eu_len;
			VSCALE( dir, dir, one_over_len );
d3949 4
a3952 3
			/* check if edge line intersects plane of fu1 */
			if( rt_isect_line3_plane( &dist, vg1->coord, dir, pl1, &is->tol ) < 1 )
				continue;
d3954 7
a3960 3
			/* make sure intersection is within limits of eu */
			if( dist < (-is->tol.dist) || dist > eu_len+is->tol.dist )
				continue;
d3962 8
a3969 5
			/* maybe its within tolerance of an end of EU */
			if( NEAR_ZERO( dist, is->tol.dist ) )
			{
				hitv = eu->vu_p->v_p;
				VMOVE( hit_pt, vg1->coord );
d3971 2
a3972 1
			else if( NEAR_ZERO( eu_len - dist, is->tol.dist ) )
d3974 4
a3977 2
				hitv = eu->eumate_p->vu_p->v_p;
				VMOVE( hit_pt, vg2->coord );
d3979 27
a4005 5
			else
			{
				fastf_t dot;
				fastf_t del_dist;
				fastf_t dist1,dist2;
d4007 2
a4008 5
				/* if the edge is nearly collinear with the plane,
				 * then look along the edge direction for a vertex
				 * that is on the edge line and within tolerance
				 * of the plane
				 */
d4010 5
a4014 2
				dot = fabs( VDOT( pl1, dir ) );
				del_dist = is->tol.dist/dot;
d4016 4
a4019 21
				dist1 = dist - del_dist;
				dist2 = dist + del_dist;
				if( dist1 <= 0.0 )
				{
					vu = eu->vu_p;
					VMOVE( hit_pt, vg1->coord );
				}
				else if( dist2 >= eu_len )
				{
					vu = eu->eumate_p->vu_p;
					VMOVE( hit_pt, vg2->coord );
				}
				else
				{
					struct vertex *v;
					struct edgeuse *eu_test;
					int code;
					point_t pca;
					point_t a,b;
					fastf_t dist3;
					struct nmg_ptbl verts;
d4021 3
a4023 1
					nmg_vertex_tabulate( &verts, &fu1->l.magic );
d4025 2
a4026 2
					VJOIN1( a, vg1->coord, dist1, dir );
					VJOIN1( b, vg1->coord, dist2, dir );
d4028 6
a4033 11
					for( i=0 ; i<NMG_TBL_END( &verts ) ; i++ )
					{
						v = (struct vertex *)NMG_TBL_GET( &verts, i );
						NMG_CK_VERTEX( v );
						code = rt_dist_pt3_lseg3( &dist3, pca, a, b,
							v->vg_p->coord, &is->tol );
						if( code > 2 )
						{
							v = (struct vertex *)NULL;
							continue;
						}
d4035 5
a4039 3
						VMOVE( hit_pt, v->vg_p->coord );
						break;
					}
d4041 2
a4042 1
					nmg_tbl( &verts, TBL_FREE, (long *)NULL );
d4044 6
a4049 9
					if( !v )
					{
						/* must be in the middle of EU */
						vu = (struct vertexuse *)NULL;
						VJOIN1( hit_pt, vg1->coord, dist, dir )
					}
					else
						vu = nmg_find_v_in_face( v, fu1 );
				}
d4051 4
d4056 5
d4062 30
a4091 1
				rt_log( "\tChecking intersection pt (%g %g %g)\n", V3ARGS( hit_pt ) );
d4093 2
a4094 6
			/* check if hit point is within fu1 */
			if( vu && nmg_find_fu_of_vu( vu ) == fu1 )
				code = NMG_CLASS_AinB;
			else
				code = nmg_class_pt_fu_except( hit_pt, fu1, (struct loopuse *)NULL,
					(void *)NULL, (void *)NULL, (char *)NULL, 0, &is->tol );
d4096 5
a4100 2
			if (rt_g.NMG_debug & DEBUG_POLYSECT)
				rt_log( "\t\thit_pt is %s with respect to fu2\n", nmg_class_name( code ) );
d4102 2
a4103 2
			if( code != NMG_CLASS_AinB )
				continue;
d4105 2
a4106 3
			/* this is a real intersection point */
			hitv = (struct vertex *)NULL;
			vu = (struct vertexuse *)NULL;
d4108 1
a4108 2
			if( !vu )
				vu = nmg_find_pt_in_face( fu2, hit_pt, &is->tol );
d4110 4
a4113 2
			if( !vu )
				vu = nmg_find_pt_in_face( fu1, hit_pt, &is->tol );
d4115 1
a4115 2
			if( !vu )
				hitv = nmg_find_pt_in_model( nmg_find_model( &fu1->l.magic ), hit_pt, &is->tol );
d4117 2
a4118 2
			if( vu )
				hitv = vu->v_p;
d4120 3
a4122 10
			if( hitv != eu->vu_p->v_p && hitv != eu->eumate_p->vu_p->v_p )
			{
				new_eu = nmg_esplit( hitv, eu, 1 );
				if (rt_g.NMG_debug & DEBUG_POLYSECT)
					rt_log( "\t splitting eu x%x, new_eu=x%x new_vu=x%x\n", eu, new_eu, new_eu->vu_p );
				hitv = new_eu->vu_p->v_p;
				if( !hitv->vg_p )
					nmg_vertex_gv( hitv, hit_pt );
			}
			(void)nmg_make_dualvu( hitv, fu1, &is->tol );
d4124 1
a4124 2
			if( hitv )
				(void)nmg_model_break_all_es_on_v( m, hitv, &is->tol );
d4128 2
a4129 2
	/* check for existing vertices along intersection */
	nmg_vertex_tabulate( &verts, &fu1->l.magic );
d4131 2
a4132 1
	for( i=0 ; i< NMG_TBL_END( &verts ) ; i++ )
d4134 1
a4134 3
		struct vertex *v;
		struct vertexuse *vu;
		fastf_t dist;
d4136 1
a4136 2
		v = (struct vertex *)NMG_TBL_GET( &verts, i );
		NMG_CK_VERTEX( v );
d4138 1
a4138 1
		if( !nmg_is_vertex_on_inter( v, fu2, is ) )
d4141 3
a4143 2
		/* calculate distance along intersect ray */
		dist = VDIST( is->pt, v->vg_p->coord );
d4145 1
a4145 11
		/* this vertex is on the intersection line
		 * add all uses from fu1 to intersection list
		 */
		for( RT_LIST_FOR( vu, vertexuse, &v->vu_hd ) )
		{
			if( nmg_find_fu_of_vu( vu ) == fu1 )
			{
				if (rt_g.NMG_debug & DEBUG_POLYSECT)
					rt_log( "\tenlisting vu x%x (x%x) from fu1 (x%x)\n", vu, v,   fu1 );
				nmg_enlist_one_vu( is, vu, dist );
			}
d4149 20
a4168 3
	/* and same for fu2 */
	nmg_tbl( &verts, TBL_RST, (long *)NULL );
	nmg_vertex_tabulate( &verts, &fu2->l.magic );
d4170 1
a4170 1
	for( i=0 ; i< NMG_TBL_END( &verts ) ; i++ )
d4176 1
a4176 1
		v = (struct vertex *)NMG_TBL_GET( &verts, i );
d4179 1
a4179 1
		if( !nmg_is_vertex_on_inter( v, fu1, is ) )
d4186 1
a4186 1
		 * add all uses from fu2 to intersection list
d4190 4
a4193 1
			if( nmg_find_fu_of_vu( vu ) == fu2 )
d4196 1
a4196 1
					rt_log( "\tenlisting vu x%x (x%x) from fu2 (x%x)\n", vu, v, fu2 );
d4202 1
a4202 1
	nmg_tbl( &verts, TBL_FREE, (long *)NULL );
d4204 2
d5404 1
a5404 1

d5407 1
a5407 1

d5955 1
a5955 1
	if( nmg_class_pt_s( midpt, s2, &is->tol ) == NMG_CLASS_AoutB )
@


11.33
log
@edge_g_lseg got an rt_list structure, for symmetry with edge_g_cnurb.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 11.32 1995/10/19 14:58:22 jra Exp $ (ARL)";
d141 64
d295 1
d326 1
d350 3
a352 6
		if( !dualvu && !(dualvu = nmg_find_v_in_face( vu->v_p, dualfu )) )  {
			/* Not found, make self-loop in dualfu */
			lu = nmg_mlv( &dualfu->l.magic, vu->v_p, OT_BOOLPLACE );
			nmg_loop_g( lu->l_p, &(is->tol) );
			dualvu = RT_LIST_FIRST( vertexuse, &lu->down_hd );
		} else {
d2256 3
d2372 4
a2375 2
	rt_free( (char *)mag1, "nmg_isect_edge2p_face2p: mag1" );
	rt_free( (char *)mag2, "nmg_isect_edge2p_face2p: mag2" );
d2385 428
d3537 491
d4106 1
d4142 109
a4384 8
					rt_log("WARNING fu1 dist1=%g, fu2 dist2=%g.  Intersect not in plane of face, skipping.\n", dist1, dist2);
nmg_pr_fu_briefly( fu1 , "FU1: " );
rt_log( "fu1 plane = ( %g %g %g %g )\n" , V4ARGS( n1 ) );
nmg_pr_fu_briefly( fu2 , "FU2: " );
rt_log( "fu2 plane = ( %g %g %g %g )\n" , V4ARGS( n2 ) );
rt_log( "Intersect vertex is x%x ( %g %g %g )\n", hit_v, V3ARGS( hit_v->vg_p->coord ) );
nmg_stash_model_to_file( "isect.g", nmg_find_model( &fu1->l.magic ), "Intersect not in plane of face" );
rt_bomb("nmg_isect_line2_face2pNEW()\n");
d4387 16
d4442 1
a4442 1
#if 0
d4461 8
d5080 1
a5080 1

d5149 1
a5149 1

d5176 1
a5176 1

d5201 1
d5214 3
a5216 1
	nmg_isect_line2_face2pNEW(is, fu2, fu1, &eu2_list, &eu1_list);
d5398 1
a5398 1
		nmg_isect_two_face2p( &bs, fu1, fu2 );
@


11.32
log
@Added some debugging prints to nmg_isect_line2_face2pNEW().
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 11.31 1995/09/06 13:56:36 jra Exp $ (ARL)";
d2884 2
a2885 2
		nmg_pr_eg(&eg1->magic, 0);
		nmg_pr_eg(&eg2->magic, 0);
d2959 1
a2959 1
		nmg_pr_eg( &eg1->magic, 0 );
d3189 2
a3190 2
			nmg_pr_eg(&(*eg1)->magic, 0);
			nmg_pr_eg(&is->on_eg->magic, 0);
d3312 2
a3313 2
				nmg_pr_eg(&(*eg1)->magic, 0);
				nmg_pr_eg(&is->on_eg->magic, 0);
@


11.31
log
@Added a distance array corresponding to the vertexuse list in nmg_enlist_vu().
Also modified calling routines to support use of the new array.
Ifdef'd out the RPP check and calls to nmg_class_pt_fu_except() in nmg_isect_line2_face2pNEW().
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 11.30 1995/06/17 03:00:18 mike Exp jra $ (ARL)";
d3386 1
d3441 5
a3445 1
			if( rt_distsq_line3_pt3( is->pt, is->dir, vu1a->v_p->vg_p->coord ) <= is->tol.dist_sq  )  {
d3463 5
a3467 1
			if( rt_distsq_line3_pt3( is->pt, is->dir, vu1b->v_p->vg_p->coord ) <= is->tol.dist_sq )  {
d3558 7
@


11.30
log
@Infinite loop protection.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 11.29 1995/05/05 21:02:16 jra Exp mike $ (ARL)";
d71 3
d117 2
a118 1
				struct vertexuse *dualvu));
d168 1
a168 1
nmg_enlist_vu( is, vu, dualvu )
d172 1
d179 1
d188 3
d205 21
d235 21
d318 21
d341 21
d365 2
a366 2
		rt_log("nmg_enlist_vu(vu=x%x,dv=x%x) v=x%x (%s) ret=x%x\n",
			vu, dualvu, vu->v_p,
d708 2
a709 1
				if(is->l1) nmg_enlist_vu( is, vu1, vu2 );
d717 1
a717 1
				if(is->l1) nmg_enlist_vu( is, vu1, vu2 );
d727 1
a727 1
				if(is->l1) nmg_enlist_vu( is, vu1, eu2->vu_p );
d732 1
a732 1
				if(is->l1) nmg_enlist_vu( is, vu1, new_eu->vu_p );
d747 1
a747 1
		if(is->l1) nmg_enlist_vu( is, vu1, vu2 );
d895 1
a895 1
		vu2_final = nmg_enlist_vu( is, vu1_final, 0 );
d961 1
a961 1
			nmg_enlist_vu( is, vu1_final, vu2_final );
d984 1
a984 1
		vu2_final = nmg_enlist_vu( is, vu1_final, vu2_final );
d1250 1
a1250 1
				nmg_enlist_vu( is, eu[neu]->vu_p, vu[j] );
d1276 1
a1276 1
				nmg_enlist_vu( is, vu[i], vu[j] );
d1281 1
a1281 1
		nmg_enlist_vu( is, vu[i], 0 );
d1366 2
a1367 2
	    	nmg_enlist_vu( is, vu1a, vu2a );
	    	nmg_enlist_vu( is, vu1b, vu2b );
d1375 2
a1376 2
	    	nmg_enlist_vu( is, vu1a, vu2b );
	    	nmg_enlist_vu( is, vu1b, vu2a );
d1429 1
a1429 1
			nmg_enlist_vu( is, vu1a, vu2a );
d1431 1
a1431 1
			nmg_enlist_vu( is, vu1a, vu2b );
d1434 1
a1434 1
			nmg_enlist_vu( is, vu1b, vu2a );
d1436 1
a1436 1
			nmg_enlist_vu( is, vu1b, vu2b );
d1489 1
a1489 1
			nmg_enlist_vu( is, vu1a, vu2a );
d1497 1
a1497 1
			nmg_enlist_vu( is, vu1a, vu2b );
d1505 1
a1505 1
		nmg_enlist_vu( is, vu1a, vu );
d1528 1
a1528 1
			nmg_enlist_vu( is, vu1b, vu2a );
d1536 1
a1536 1
			nmg_enlist_vu( is, vu1b, vu2b );
d1544 1
a1544 1
		nmg_enlist_vu( is, vu1b, vu );
d1557 1
a1557 1
			nmg_enlist_vu( is, vu2a, 0 );
d1561 1
a1561 1
			nmg_enlist_vu( is, vu2b, 0 );
d1576 1
a1576 1
			nmg_enlist_vu( is, new_vu2, 0 );
d1598 1
a1598 1
		nmg_enlist_vu( is, vu2a, vu );
d1605 1
a1605 1
		nmg_enlist_vu( is, vu2b, vu );
d1622 1
a1622 1
			RT_LIST_PNEXT_CIRC(edgeuse,eu2)->vu_p );
d1649 2
a1650 2
	nmg_enlist_vu( is, vu1a, 0 );
	nmg_enlist_vu( is, vu1b, 0 );
d1779 2
a1780 2
			nmg_pr_ptbl_vert_list( "l1", is->l1 );
			nmg_pr_ptbl_vert_list( "l2", is->l2 );
d1800 2
a1801 2
			nmg_pr_ptbl_vert_list( "l1", is->l1 );
			nmg_pr_ptbl_vert_list( "l2", is->l2 );
d1915 1
a1915 1
		vu2_final = nmg_enlist_vu( is, vu1_final, 0 );
d1943 1
a1943 1
		vu2_final = nmg_enlist_vu( is, vu1_final, 0 );
d2173 1
d2259 7
d2282 2
a2283 2
    		nmg_pr_ptbl_vert_list( "vert_list1", &vert_list1 );
    		nmg_pr_ptbl_vert_list( "vert_list2", &vert_list2 );
d2286 2
a2287 2
	nmg_purge_unwanted_intersection_points(&vert_list1, fu2, &is->tol);
	if(fu1)nmg_purge_unwanted_intersection_points(&vert_list2, fu1, &is->tol);
d2291 2
a2292 2
    		nmg_pr_ptbl_vert_list( "vert_list1", &vert_list1 );
    		nmg_pr_ptbl_vert_list( "vert_list2", &vert_list2 );
d2298 1
a2298 1
	is->on_eg = nmg_face_cutjoin(&vert_list1, &vert_list2, fu1, fu2, is->pt, is->dir, is->on_eg, &is->tol);
d2306 2
d2542 2
a2543 2
		nmg_enlist_vu(is, vu1a, 0);
		nmg_enlist_vu(is, vu1b, 0);
d2560 1
a2560 1
		nmg_enlist_vu(is, vu1a, 0);
d2567 1
a2567 1
		nmg_enlist_vu(is, vu1b, 0);
d2624 1
a2624 1
		nmg_enlist_vu(is, vu1_final, 0);
d2664 1
a2664 1
	nmg_enlist_vu( is, vu1, 0 );
d2746 1
a2746 1
	nmg_enlist_vu( is, vu1a, vu1b );
d3114 4
d3150 2
a3151 2
				nmg_enlist_vu(is, eu1->vu_p, 0 );
				nmg_enlist_vu(is, RT_LIST_PNEXT_CIRC(edgeuse, eu1)->vu_p, 0 );
d3337 1
d3360 1
a3360 1

d3394 12
a3405 1
			if( eu1->g.lseg_p != *eg1 )  continue;
a3408 1

d3415 10
a3424 1
				nmg_enlist_vu(is, vu1a, 0);
d3431 2
a3432 1
				nmg_enlist_vu(is, vu1b, 0);
d3442 3
d3460 3
d3550 1
a3550 1
				nmg_enlist_vu(is, vu1_midpt, 0);
d3580 1
a3580 1
			nmg_enlist_vu(is, vu1, 0 );
d3604 1
a3604 1
			nmg_enlist_vu(is, new_eu->vu_p, 0 );
d3621 1
a3621 1
			nmg_enlist_vu(is, new_eu->vu_p, 0 );
d3912 2
d3918 1
d4028 11
d4045 2
d4065 2
a4066 2
    		nmg_pr_ptbl_vert_list( "vert_list1", &vert_list1 );
    		nmg_pr_ptbl_vert_list( "vert_list2", &vert_list2 );
d4082 2
d4093 2
a4094 2
	nmg_purge_unwanted_intersection_points(&vert_list1, fu2, &is->tol);
	nmg_purge_unwanted_intersection_points(&vert_list2, fu1, &is->tol);
d4098 2
a4099 2
    		nmg_pr_ptbl_vert_list( "vert_list1", &vert_list1 );
    		nmg_pr_ptbl_vert_list( "vert_list2", &vert_list2 );
d4111 1
a4111 1
	is->on_eg = nmg_face_cutjoin(&vert_list1, &vert_list2, fu1, fu2, is->pt, is->dir, is->on_eg, &is->tol);
d4138 4
d4166 2
d4173 1
@


11.29
log
@Modified nmg_isect_line2_face2pNEW() to skip over EU's with bad magic
from being killed by nmg_repair_v_near_v().
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 11.28 1995/05/01 20:47:00 jra Exp jra $ (ARL)";
d3594 1
d3641 1
a3641 1
						continue;
d3665 1
a3665 1
					/* Advance to next radial edgeuse */
@


11.28
log
@Added check for intersection point using nmg_class_pt_fu_except() in nmg_isect_line2_face2pNEW().
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 11.27 1995/03/13 11:00:13 jra Exp jra $ (ARL)";
d3458 5
d3475 5
@


11.27
log
@removed previous changes concerning nmg_repair_v_near_v.
Added a check in nmg_isect_line2_face2pNEW() to skip EU's with bad magic.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 11.26 95/03/09 22:07:26 jra Exp Locker: jra $ (ARL)";
d2980 1
d3232 1
a3232 1
				VPRINT("\t\tisect pt outside face RPP:", hit3d );
d3237 13
@


11.26
log
@Added nmg_remove_0eus_from_list() and calls to it from nmg_repair_v_near_v()
Also added eu_list arg to nmg_repair_v_near_v().
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 11.25 95/03/05 21:27:21 mike Exp Locker: jra $ (ARL)";
a2736 25
/*	N M G _ R E M O V E _ 0 E U S _ F R O M _ L I S T
 *
 * Remove zero length edgeuses around vertex "v" from the list "eu_list"
 *
 */
void
nmg_remove_0eus_from_list( v, eu_list )
struct vertex *v;
struct nmg_ptbl *eu_list;
{
	struct vertexuse *vu;
	struct edgeuse *eu;

	for( RT_LIST_FOR( vu, vertexuse, &v->vu_hd ) )
	{
		NMG_CK_VERTEXUSE(vu);
		if( *vu->up.magic_p != NMG_EDGEUSE_MAGIC )  continue;
		eu = vu->up.eu_p;
		NMG_CK_EDGEUSE(eu);
		if( eu->eumate_p->vu_p->v_p != v )  continue;
		nmg_tbl( eu_list, TBL_RM, (long *)eu );
		nmg_tbl( eu_list, TBL_RM, (long *)eu->eumate_p );
	}
}

d2749 1
a2749 1
nmg_repair_v_near_v( hit_v, v, eg1, eg2, eu_list, bomb, tol )
a2753 1
struct nmg_ptbl				*eu_list;	/* eu list that may contain an EU that we kill */
a2797 2
	      	if( eu_list )
		      	nmg_remove_0eus_from_list( hit_v, eu_list );
d2885 1
a2885 1
		if( nmg_repair_v_near_v( hit_v, v, eg1, eg2, (struct nmg_ptbl *)0, 0, tol ) )
d3265 5
d3305 1
a3305 1
					is->on_eg, *eg1, eu1_list, 1, &(is->tol) );
d3320 1
a3320 1
					is->on_eg, *eg1, eu1_list, 1, &(is->tol) );
d3346 1
a3346 1
						is->on_eg, *eg1, eu1_list, 1, &(is->tol) );
d3357 1
a3357 1
						is->on_eg, *eg1, eu1_list, 1, &(is->tol) );
@


11.25
log
@Added a small efficiency measure.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 11.24 95/03/05 20:04:42 mike Exp Locker: mike $ (ARL)";
d2737 25
d2774 1
a2774 1
nmg_repair_v_near_v( hit_v, v, eg1, eg2, bomb, tol )
d2779 1
d2824 2
d2913 1
a2913 1
		if( nmg_repair_v_near_v( hit_v, v, eg1, eg2, 0, tol ) )
d3328 1
a3328 1
					is->on_eg, *eg1, 1, &(is->tol) );
d3343 1
a3343 1
					is->on_eg, *eg1, 1, &(is->tol) );
d3369 1
a3369 1
						is->on_eg, *eg1, 1, &(is->tol) );
d3380 1
a3380 1
						is->on_eg, *eg1, 1, &(is->tol) );
@


11.24
log
@Improved handling of mis-matched lines
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 11.23 95/02/28 00:41:21 mike Exp Locker: mike $ (ARL)";
d3131 12
a3142 4
#if 0
/* Efficiency measure.  Add later. */
				if( !V3PT_IN_RPP( hit_v->vg_p->coord, fu1->f_p->min_pt, fu1->f_p->max_pt ) )  {
					/* Lines intersect outside bounds of this face. */
d3144 2
a3145 2
						VPRINT("\t\tisect pt outside fu1 RPP:", hit_v->vg_p->coord );
						rt_log("\t\tface RPP: ( %g %g %g ) <-> ( %g %g %g )\n",
d3147 1
a3147 8
					}
					continue;
				}
				if( !V3PT_IN_RPP( hit_v->vg_p->coord, fu2->f_p->min_pt, fu2->f_p->max_pt ) )  {
					/* Lines intersect outside bounds of this face. */
					if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
						VPRINT("\t\tisect pt outside fu2 RPP:", hit_v->vg_p->coord );
						rt_log("\t\tface RPP: ( %g %g %g ) <-> ( %g %g %g )\n",
d3152 1
a3152 1
#endif
a3816 2
		    	if( ang * rt_radtodeg > 1.0 )
				rt_bomb("nmg_isect_two_face3p() line direction mismatch\n");
@


11.23
log
@Converted to Lee's new nmg_class_pt_fu_except().
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 11.22 95/02/23 13:02:28 jra Exp Locker: mike $ (ARL)";
d1958 77
a2081 4
	struct xray		line;
	point_t			min_pt;
	point_t			max_pt;
	vect_t			invdir;
d2121 1
a2134 17
	/*
	 *  Construct the ray which contains the line of intersection,
	 *  i.e. the line that contains the edge "eu1".
	 *
	 *  See the comment in nmg_isect_two_generic_faces() for details
	 *  on the constraints on this ray, and the algorithm.
	 *
	 *  XXX Danger?
	 *  The ray -vs- RPP check is being done in 3D.
	 *  It really ought to be done in 2D, to ensure that
	 *  long edge lines on nearly axis-aligned faces don't
	 *  get discarded prematurely!
	 *  XXX Can't just comment out the code, I think the selection
	 *  XXX of is->pt is significant:
	 *	1)  All intersections are at positive distances on the ray,
	 *	2)  dir cross N will point "left".
	 */
d2138 2
a2139 2
		if (rt_g.NMG_debug & DEBUG_POLYSECT)
			rt_log("nmg_isect_edge2p_face2p(eu1=x%x) skipping 0-len edge (topology)\n", eu1);
a2141 4
	VMOVE( line.r_pt, is->on_eg->e_pt );			/* 3D line */
	VMOVE( line.r_dir, is->on_eg->e_dir );
	VUNITIZE( line.r_dir );
	VINVDIR( invdir, line.r_dir );
d2143 5
a2147 3
	/* nmg_loop_g() makes sure there are no 0-thickness faces */
	VMOVE( min_pt, fu2->f_p->min_pt );
	VMOVE( max_pt, fu2->f_p->max_pt );
a2148 36
	if( !rt_in_rpp( &line, invdir, min_pt, max_pt ) )  {
		/* The edge ray missed the face RPP, nothing to do. */
		if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
			VPRINT("r_pt ", line.r_pt);
			VPRINT("r_dir", line.r_dir);
			VPRINT("fu2 min", fu2->f_p->min_pt);
			VPRINT("fu2 max", fu2->f_p->max_pt);
			VPRINT("min_pt", min_pt);
			VPRINT("max_pt", max_pt);
			rt_log("r_min=%g, r_max=%g\n", line.r_min, line.r_max);
			rt_log("nmg_isect_edge2p_face2p() edge ray missed face bounding RPP\n");
		}
		goto out;
	}
	if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
		VPRINT("fu2 min", fu2->f_p->min_pt);
		VPRINT("fu2 max", fu2->f_p->max_pt);
		rt_log("r_min=%g, r_max=%g\n", line.r_min, line.r_max);
	}
	/* Start point will lie at min or max dist, outside of face RPP */
	VJOIN1( is->pt, line.r_pt, line.r_min, line.r_dir );
	if( line.r_min > line.r_max )  {
		/* Direction is heading the wrong way, flip it */
		VREVERSE( is->dir, line.r_dir );
		if (rt_g.NMG_debug & DEBUG_POLYSECT)
			rt_log("flipping dir\n");
	} else {
		VMOVE( is->dir, line.r_dir );
	}
	if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
		VPRINT("r_pt ", line.r_pt);
		VPRINT("r_dir", line.r_dir);
		VPRINT("->pt ", is->pt);
		VPRINT("->dir", is->dir);
	}

d2662 1
d2677 13
a2689 3
		/* Found different edge_g_lseg, claimed to be colinear */
		rt_log("*eup=x%x, g=x%x, ret=x%x\n", *eup, (*eup)->g.lseg_p, ret );
		rt_bomb("nmg_find_eg_on_line() 2 different eg's, fuser failure.\n");
d2692 3
d2948 2
a2949 2
 *  If is->on_eg is set, use the line equation from there, as it
 *  may be slightly different than the original geometric one.
d2953 4
a2989 39
	if( is->on_eg )  {
	    	fastf_t	dot;
	    	vect_t	unit_e_dir;

	    	VMOVE( unit_e_dir, is->on_eg->e_dir );
	    	VUNITIZE( unit_e_dir );
	    	dot = VDOT(is->dir, unit_e_dir);

		if( fabs(dot) < is->tol.para &&	/* not parallel */
		    !rt_2line3_colinear(
		    is->pt, is->dir,
		    is->on_eg->e_pt, unit_e_dir, 1000.0, &(is->tol) ) )  {

#if 0
			VPRINT("   is->pt   ", is->pt);
			VPRINT("   is->dir  ", is->dir);
			VPRINT("unit  e_dir ", unit_e_dir);
			VPRINT("on_eg->e_pt ", is->on_eg->e_pt);
			VPRINT("on_eg->e_dir", is->on_eg->e_dir);
		    	rt_log(" dot=%g, ang=%g deg\n", dot,
				acos(fabs(dot)) * rt_radtodeg );
#endif
			rt_log("WARNING nmg_isect_line2_face2pNEW() is->pt and on_eg lines differ by %g deg.  Using on_eg line.  |on_eg|=%gmm\n",
				acos(fabs(dot)) * rt_radtodeg,
				MAGNITUDE(is->on_eg->e_dir) );

			/* Ensure absolute consistency between the two versions of the line! */
			VMOVE( is->pt, is->on_eg->e_pt );
			VMOVE( is->dir, is->on_eg->e_dir );
			VUNITIZE(is->dir);
			/*
			 * XXX What about the constraints on the ray?
			 *	1)  All intersections are at positive distances on the ray,
			 *	2)  dir cross N will point "left".
			 * XXX Don't they have to be recomputed here?
			 */
		}
	}

d3747 3
a3785 1

d3805 16
d3827 19
a3851 7
#if TOO_STRICT
		if( !rt_2line3_colinear(
		    is->pt, is->dir,
		    is->on_eg->e_pt, is->on_eg->e_dir, 1000.0, &(is->tol) ) )  {
		    	rt_bomb("nmg_isect_two_face3p() on_eg does not represent is->pt/dir line\n");
		}
#endif
@


11.22
log
@Added some debug messages just before rt_bomb call in nmg_isect_line2_face2pNEW().
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 11.21 95/02/22 00:55:04 mike Exp Locker: jra $ (ARL)";
d813 4
a816 1
		class = nmg_class_pt_f( hit_pt, fu2, &is->tol );
@


11.21
log
@Made a quite attempt to speed up nmg_search_v_eg(), because
surprisingly it accounts for 30% of the runtime of an NMG boolean!
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 11.20 95/02/21 23:37:04 mike Exp Locker: mike $ (ARL)";
d3178 6
@


11.20
log
@Fixed problem where some edges were not being properly fused as
the intersection process proceeded.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 11.19 95/02/21 03:10:39 mike Exp Locker: mike $ (ARL)";
d2791 1
a2791 1
struct vertex			*hit_v;		/* often will be NULL */
d2794 4
a2797 4
	struct vertex		*v;
	struct vertexuse	*vu1;
	struct edgeuse		*seen1 = (struct edgeuse *)NULL;
	struct edgeuse		*seen2 = (struct edgeuse *)NULL;
d2823 1
d2825 1
a2825 1
		struct edgeuse	*eu1;
a2826 1
		NMG_CK_VERTEXUSE(vu1);
@


11.19
log
@Eliminated some XXX code.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 11.18 95/02/19 21:01:49 mike Exp Locker: mike $ (ARL)";
d177 4
a180 1
	if(dualvu) NMG_CK_VERTEXUSE(dualvu);
d213 2
a214 2
		rt_log("nmg_enlist_vu(vu=x%x) sv=x%x, s1=x%x, s2=x%x\n",
			vu, sv, is->s1, is->s2 );
d221 3
a223 2
			rt_log("nmg_enlist_vu(vu=x%x) sv=x%x, s1=x%x, s2=x%x, sdual=x%x\n",
				vu, sv, is->s1, is->s2, nmg_find_s_of_vu(dualvu) );
d240 2
a241 2
				rt_log("nmg_enlist_vu(vu=x%x) re-using dualvu=x%x from dualfu=x%x\n",
					vu,
d272 4
a275 3
		rt_log("nmg_enlist_vu(vu=x%x) v=x%x, dualvu=x%x (%s)\n",
			vu, vu->v_p, dualvu,
			(sv == is->s1) ? "shell 1" : "shell 2" );
d1106 4
d1129 5
d1164 2
d1177 1
d1189 1
a1189 1
		rt_log("nmg_isect_2colinear_edge2p(eu1=x%x, eu2=x%x) #eu=%d\n",
@


11.18
log
@Wrote nmg_k0eu()
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 11.17 95/02/18 19:51:05 mike Exp Locker: mike $ (ARL)";
d2910 3
a2912 3
	struct edge_g_lseg		**eg1;
	struct edgeuse		**eu1;
	struct edgeuse		**eu2;
d2921 2
d2955 3
a2957 2
			rt_log("WARNING nmg_isect_line2_face2pNEW() is->pt and on_eg lines differ by %g deg.  Using on_eg line.\n",
				acos(fabs(dot)) * rt_radtodeg );
d3002 5
a3006 7
			for( eu1 = (struct edgeuse **)NMG_TBL_BASEADDR(eu1_list);
			     eu1 <= (struct edgeuse **)NMG_TBL_LASTADDR(eu1_list);
			     eu1++
			)  {
				NMG_CK_EDGEUSE(*eu1);
				if( (*eu1)->g.lseg_p != is->on_eg )  continue;
				/* *eu1 is from fu1 */
d3008 5
a3012 6
				for( eu2 = (struct edgeuse **)NMG_TBL_BASEADDR(eu2_list);
				     eu2 <= (struct edgeuse **)NMG_TBL_LASTADDR(eu2_list);
				     eu2++
				)  {
					NMG_CK_EDGEUSE(*eu2);
					if( (*eu2)->g.lseg_p != is->on_eg )  continue;
d3014 1
a3014 1
					 *  *eu2 is from fu2.
d3018 1
a3018 1
					(void)nmg_isect_2colinear_edge2p( *eu1, *eu2,
d3023 2
a3024 2
				nmg_enlist_vu(is, (*eu1)->vu_p, 0 );
				nmg_enlist_vu(is, RT_LIST_PNEXT_CIRC(edgeuse, (*eu1))->vu_p, 0 );
d3139 1
a3139 1
				 *  and since hit_v lines on eg1
d3161 1
d3229 4
a3232 4
		/* Search all eu's on eg1 for vu's to enlist.  May be many. */
		for( eu1 = (struct edgeuse **)NMG_TBL_LASTADDR(eu1_list);
		     eu1 >= (struct edgeuse **)NMG_TBL_BASEADDR(eu1_list); eu1--
		)  {
d3239 5
a3243 4
			NMG_CK_EDGEUSE(*eu1);
			if( (*eu1)->g.lseg_p != *eg1 )  continue;
			vu1a = (*eu1)->vu_p;
			vu1b = RT_LIST_PNEXT_CIRC( edgeuse, (*eu1) )->vu_p;
d3345 1
a3345 2
				new_eu = nmg_ebreaker(hit_v, *eu1, &is->tol);
				/* WARNING: realloc() may move the array */
d3412 6
a3417 8
		for( eu1 = (struct edgeuse **)NMG_TBL_BASEADDR(eu1_list);
		     eu1 <= (struct edgeuse **)NMG_TBL_LASTADDR(eu1_list);
		     eu1++
		)  {
			NMG_CK_EDGEUSE(*eu1);
			if( (*eu1)->g.lseg_p != is->on_eg )  continue;
			/* *eu1 is from fu1 and on the intersection line */
			new_eu = nmg_break_eu_on_v( *eu1, vu1->v_p, fu1, is );
a3418 1
			/* XXX What about realloc() moving the array? */
d3424 6
a3429 8
		for( eu2 = (struct edgeuse **)NMG_TBL_BASEADDR(eu2_list);
		     eu2 <= (struct edgeuse **)NMG_TBL_LASTADDR(eu2_list);
		     eu2++
		)  {
			NMG_CK_EDGEUSE(*eu2);
			if( (*eu2)->g.lseg_p != is->on_eg )  continue;
			/* *eu2 is from fu2 and on the intersection line */
			new_eu = nmg_break_eu_on_v( *eu2, vu1->v_p, fu1, is );
a3430 1
			/* XXX What about realloc() moving the array? */
a3433 6
#endif

#if 0
		/* OLD WAY: */
		nmg_isect_line2_vertex2( is, vu1, fu1 );
		/* Only result is a use of vu1 added to the other face */
@


11.17
log
@Made one more noisy message conditional on debug bit.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 11.16 95/02/17 22:02:58 mike Exp Locker: mike $ (ARL)";
d2646 39
d2706 1
a2706 1
	NMG_CK_EDGE_G_LSEG(eg1);
d2718 12
a2729 10
	if( rt_2line3_colinear( eg1->e_pt, eg1->e_dir, eg2->e_pt, eg2->e_dir, 1e5, tol ) )
		rt_log("ERROR: eg1 and eg2 are colinear!\n");
	rt_log("eg1: line/ vu dist=%g, hit dist=%g\n",
		rt_dist_line3_pt3( eg1->e_pt, eg1->e_dir, v->vg_p->coord ),
		rt_dist_line3_pt3( eg1->e_pt, eg1->e_dir, hit_v->vg_p->coord ) );
	rt_log("eg2: line/ vu dist=%g, hit dist=%g\n",
		rt_dist_line3_pt3( eg2->e_pt, eg2->e_dir, v->vg_p->coord ),
		rt_dist_line3_pt3( eg2->e_pt, eg2->e_dir, hit_v->vg_p->coord ) );
	nmg_pr_eg(&eg1->magic, 0);
	nmg_pr_eg(&eg2->magic, 0);
a2741 1
			goto out;	/* XXX blow up, for now */
d2745 2
a2746 2
		/* XXX Kill all uses of the 0-length edge? */
		return hit_v;
d2748 4
d2753 2
a2754 4
	/* Separate is too great */
	if( bomb )
		rt_bomb("nmg_repair_v_near_v() separation is too great to repair.\n");
	return (struct vertex *)NULL;
d2975 1
d3274 2
d3289 2
d3315 2
d3326 2
@


11.16
log
@Rewrote nmg_common_v_2eg() to use eu_hd2 list, rather than
calling nmg_edgeuse_with_eg_tabulate().
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 11.15 95/02/15 00:14:22 mike Exp Locker: mike $ (ARL)";
d3008 2
a3009 1
			rt_log("NOTICE: setting on_eg to eg1 and continuing with colinear case.\n");
@


11.15
log
@Changed "Plotting to " messages into "overlay" messages,
to allow cut-n-paste into MGED sessions.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 11.14 95/02/11 05:50:24 mike Exp Locker: mike $ (ARL)";
d1028 4
a1031 2
	/* XXX Replace with walk of eg eu list */
	nmg_edgeuse_with_eg_tabulate( &eutab, nmg_find_model(&v->magic), eg );
d1044 1
a1044 1
		if( (*eup)->g.lseg_p != eg )  continue;
d1048 3
a1050 1
		if( rt_pt3_pt3_equal( v->vg_p->coord, va->vg_p->coord, tol ) )
d1052 3
a1054 1
		if( rt_pt3_pt3_equal( v->vg_p->coord, vb->vg_p->coord, tol ) )
d1056 1
d2721 2
d2803 1
a2803 1
 *			N M G _ I S E C T _ 2 E G
d2809 3
a2811 3
nmg_isect_2eg( eg1, eg2, tol, m )
struct edge_g_lseg		*eg1;
struct edge_g_lseg		*eg2;
a2812 1
struct model		*m;		/* XXX */
d2814 1
a2814 2
	struct nmg_ptbl		eu1_list;
	struct edgeuse		**eu1;
d2816 1
a2820 1
	NMG_CK_MODEL(m);
d2822 2
a2823 3
	if( eg1 == eg2 || rt_2line3_colinear(
	    eg1->e_pt, eg1->e_dir, eg2->e_pt, eg2->e_dir, 1e5, tol ) )
		rt_bomb("nmg_isect_2eg() eg1 and eg2 are colinear\n");
d2825 9
a2833 14
	/* XXX "without regard to complexity".  This is a slow algorithm. */
	/* XXX Re-write once edge_g heads a lists of edges, rather than ->usage */

	/* Build a list of all edgeuses in this model on eg1 */
	nmg_edgeuse_with_eg_tabulate( &eu1_list, &m->magic, eg1 );

	for( eu1 = (struct edgeuse **)NMG_TBL_LASTADDR(&eu1_list);
	     eu1 >= (struct edgeuse **)NMG_TBL_BASEADDR(&eu1_list); eu1--
	)  {
		NMG_CK_EDGEUSE(*eu1);
		if( (*eu1)->g.lseg_p != eg1 )  rt_bomb("nmg_isect_2eg() sanity\n");
		/* Both verts of *eu1 lie on line *eg1 */
		hit_v = nmg_search_v_eg( *eu1, 0, eg1, eg2, hit_v, tol );
		hit_v = nmg_search_v_eg( *eu1, 1, eg1, eg2, hit_v, tol );
a2834 1
	nmg_tbl( &eu1_list, TBL_FREE, (long *)0 );
d2836 1
a2836 1
		rt_log("nmg_isect_2eg(eg1=x%x, eg2=x%x) hit_v=x%x\n",
d3039 1
a3039 1
			hit_v = nmg_isect_2eg( *eg1, is->on_eg, &(is->tol), nmg_find_model( &fu1->l.magic ) );
@


11.14
log
@Removed over-agressive optimization.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 11.13 95/02/11 04:29:57 mike Exp Locker: mike $ (ARL)";
d3063 1
a3063 1
						rt_log("wrote %s, red is on_eg, yellow is eg1\n", buf);
d4019 1
a4019 1
    	    		rt_log("Plotting to %s\n", name);
d4024 1
a4024 1
    	    	sprintf(name, "shellB%d.pl", nshell);
d4026 1
a4026 1
    	    		rt_log("Plotting to %s\n", name);
@


11.13
log
@Marked some dubious bits of code.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 11.12 95/02/11 03:18:13 mike Exp Locker: mike $ (ARL)";
d2058 2
a2059 2
	VMOVE( line.r_pt, vu1->v_p->vg_p->coord );		/* 3D line */
	VSUB2( line.r_dir, vu2->v_p->vg_p->coord, line.r_pt );
d3733 4
a3736 2
		 *  If it isn't used by at least one edge of *both* faceuses,
		 *  then we know there can't be an intersection.
a3737 7
		if( is->on_eg )  {
			struct edgeuse	*eu1, *eu2;

			eu1 = nmg_does_fu_use_eg( fu1, is->on_eg );
			eu2 = nmg_does_fu_use_eg( fu2, is->on_eg );
			if( !eu1 || !eu2 )  goto outfast;
		}
@


11.12
log
@Reduced blathering
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 11.11 95/02/10 23:36:50 mike Exp Locker: mike $ (ARL)";
d2040 10
d2181 3
d2843 2
d2848 2
a2849 2
 *  edgeuses and many different edges), intersect the edge_g_lseg LINE with
 *  the face/face intersection line.
d2913 11
a2924 4
		/* Ensure absolute consistency between the two versions of the line! */
		VMOVE( is->pt, is->on_eg->e_pt );
		VMOVE( is->dir, is->on_eg->e_dir );
		VUNITIZE(is->dir);
@


11.11
log
@Corrected misleading print of hangle.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 11.10 95/02/07 06:00:46 mike Exp Locker: mike $ (ARL)";
d2875 9
a2883 1
		if( !rt_2line3_colinear(
d2885 1
a2885 3
		    is->on_eg->e_pt, is->on_eg->e_dir, 1000.0, &(is->tol) ) )  {
		    	vect_t	unit_e_dir;
		    	fastf_t	dot;
d2887 1
a2887 3
		    	VMOVE( unit_e_dir, is->on_eg->e_dir );
		    	VUNITIZE( unit_e_dir );

a2892 1
		    	dot = VDOT(is->dir, unit_e_dir);
d2895 3
a2897 1
			rt_log("WARNING nmg_isect_line2_face2pNEW() is->pt and on_eg lines differ.  Using on_eg line.\n");
@


11.10
log
@nmg_je() isn't going to take care of the edge geometry sharing.
Changed to nmg_use_edge_g and nmg_radial_join_eu
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 11.9 95/02/07 03:45:51 mike Exp Locker: mike $ (ARL)";
d2890 2
a2891 1
		    	rt_log(" dot=%g, ang=%g deg\n", dot, acos(dot) * rt_radtodeg );
@


11.9
log
@Make an rt_log() conditional on a debugging bit.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 11.8 95/02/07 03:07:35 mike Exp Locker: mike $ (ARL)";
d4348 5
a4352 3
		/* Attach new edge in s2 to original edge in s1 */
		nmg_je( eu1, neu2 );	/* join new wire edge to existing edge */
		nmg_je( eu1, neu1 );	/* join new wire edge to existing edge */
@


11.8
log
@Commented odd use of nmg_je() .
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 11.7 95/02/06 23:02:12 mike Exp Locker: mike $ (ARL)";
a1055 1
#if 0
a1056 3
#else
		{
#endif
@


11.7
log
@Changed calls to nmg_moveeu() to nmg_je(), which is the real name
of that routine.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 11.6 95/02/03 03:06:32 mike Exp Locker: mike $ (ARL)";
d4353 3
a4355 3
		nmg_je( eu1, neu2 );
		nmg_je( eu1, neu1 );
	}
@


11.6
log
@Moved 2 routines from nmg_inter.c to nmg_pr.c
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 11.5 95/02/03 03:03:07 mike Exp Locker: mike $ (ARL)";
d4353 2
a4354 2
		nmg_moveeu( eu1, neu2 );
		nmg_moveeu( eu1, neu1 );
@


11.5
log
@Added nmg_does_fu_use_eg
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 11.4 95/02/02 07:29:08 mike Exp Locker: mike $ (ARL)";
a3406 76
}

/* XXX Move to nmg_pr.c */
/*
 *			N M G _ P R _ F U S _ I N _ F G
 *
 *  For either kind of face geometry, print the list of all faces & faceuses
 *  that share this geometry.
 */
void
nmg_pr_fus_in_fg(fg_magic)
CONST long	*fg_magic;
{
	struct face	*f;

	NMG_CK_FACE_G_EITHER(fg_magic);
	rt_log("nmg_pr_fus_in_fg(x%x):\n", fg_magic);
	for( RT_LIST_FOR( f, face, &(((struct face_g_plane *)fg_magic)->f_hd) ) )  {
		NMG_CK_FACE(f);
		NMG_CK_FACEUSE(f->fu_p);
		rt_log(" f=x%x, fu=x%x, fumate=x%x\n",
			f, f->fu_p, f->fu_p->fumate_p );
	}
}

/*
 *			N M G _ P L _ L U _ A R O U N D _ E U
 *
 *  Plot all the loopuses around an edgeuse.
 *  Don't bother drawing the loopuse mates.
 */
void
nmg_pl_lu_around_eu(eu)
CONST struct edgeuse	*eu;
{
	FILE			*fp;
	CONST struct edgeuse	*eu1;
	CONST struct loopuse	*lu1;
	long			*b;
	static int		num;
	char			buf[128];

	NMG_CK_EDGEUSE(eu);

	sprintf(buf, "eu_vicinity%d.pl", num++);
	if( (fp = fopen(buf, "w")) == NULL )  {
		perror(buf);
		return;
	}

	b = (long *)rt_calloc( nmg_find_model((long *)eu)->maxindex, sizeof(long),
		"nmg_pl_lu_around_eu flag[]" );

	/* To go correct way around, start with arg's mate,
	 * so that arg, then radial, will follow.
	 */
	eu = eu->eumate_p;

	eu1 = eu;
	do {
		/* First, the edgeuse mate */
		/* Second, the edgeuse itself (mate's mate) */
		eu1 = eu1->eumate_p;

		if (*eu1->up.magic_p == NMG_LOOPUSE_MAGIC )  {
			lu1 = eu1->up.lu_p;
			nmg_pl_lu(fp, lu1, b, 80, 100, 170);
		}

		/* Now back around to the radial edgeuse */
		eu1 = eu1->radial_p;
	} while( eu1 != eu );

	rt_free( (char *)b, "nmg_pl_lu_around_eu flag[]" );
	fclose(fp);
	rt_log("Wrote %s\n", buf);
@


11.4
log
@Added lots of debugging code, and some printing, and some comments.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 11.3 95/01/31 04:27:45 mike Exp Locker: mike $ (ARL)";
d2881 7
a2887 1
		    is->on_eg->e_pt, is->on_eg->e_dir, 1e5, &(is->tol) ) )  {
d2890 1
d2893 2
d3485 1
d3635 44
d3770 1
d3782 13
d3919 1
@


11.3
log
@Made flags[] index checking a bit more robust.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 11.2 95/01/30 15:28:08 jra Exp Locker: mike $ (ARL)";
d102 2
a103 1
				struct faceuse *fu1, struct nmg_ptbl *eu1_list,
d122 9
d132 5
d2114 1
a2114 1
	nmg_isect_line2_face2pNEW( is, fu2, &eu2_list, &eu1_list );
d2119 1
a2119 1
		nmg_isect_line2_face2pNEW( is, fu1, &eu1_list, &eu2_list );
a2717 1
	CONST struct vertexuse	*vu;
d2719 2
a2720 2
	int			seen1 = 0;
	int			seen2 = 0;
d2728 3
a2730 1
		vu = RT_LIST_PNEXT_CIRC(edgeuse, eu)->vu_p;
d2732 1
a2732 1
		vu = eu->vu_p;
a2733 3

	NMG_CK_VERTEXUSE(vu);
	v = vu->v_p;
d2736 10
d2752 2
a2753 2
		if( eu1->g.lseg_p == eg1 )  seen1 = 1;
		if( eu1->g.lseg_p == eg2 )  seen2 = 1;
d2757 8
a2764 1
		if( !hit_v )  return v;
d2767 1
a2767 1
		if( hit_v == v )  return hit_v;
d2770 2
a2771 2
		rt_log("vu=x%x, v=x%x; hit_v=x%x\n",
			vu, v, hit_v);
d2773 1
a2773 1
			return hit_v;
d2777 4
d2826 4
d2838 7
a2844 1
 *  the face/face intersection line passed in is->pt and is->dir.
d2849 1
a2849 1
nmg_isect_line2_face2pNEW( is, fu1, eu1_list, eu2_list )
d2852 1
d2871 1
d2876 1
a2876 1
		rt_log("nmg_isect_line2_face2pNEW(, fu1=x%x) on_eg=x%x\n", fu1, is->on_eg);
d2878 16
d2904 1
a2904 1
	/* Process each distinct line in the face */
d2975 1
a2975 1
			rt_log("WARNING: setting on_eg and continuing.\n");
d2994 1
a2994 1
		    	rt_log("fusing with on_eg, handling as colinear\n");
d3000 5
a3004 2
		/* If on_eg was specified, do a topology search */
		if( is->on_eg )  {
d3007 84
d3098 1
a3098 1
				rt_log("NOTICE: geom/topo mis-match, enlisting topo vu\n");
d3102 1
a3102 1
				rt_log(" dist to eg1=%g, dist to on_eg=%g\n",
d3109 7
d3128 1
a3128 1
				VPRINT("\t\tintersection outise face RPP:", hit3d );
d3143 5
d3400 1
d3402 75
d3482 2
a3483 1
 *  in *either* fu1 or fu2.
d3519 5
d3537 4
d3557 1
d3560 8
d3570 3
a3578 1
					if( eur->e_p == ret->e_p )  continue;
d3583 2
a3584 1
							rt_log("nmg_find_eg_between_2fg() joining edges eur=x%x, ret=x%x\n");
d3590 1
a3590 1
					/* This condition "shouldn't happen */
d3625 1
d3627 33
d3679 1
d3699 8
a3706 1
	/* XXX */
d3717 8
a3724 10
#if 0
		/* Check this edge w.r.t. the line geometry */
		if( !nmg_is_eu_on_line3( on_eu, is->pt, is->dir, &(is->tol) ) )  {
			rt_log("Wow!  Found shared edge on_eu=x%x\n", on_eu);
			VPRINT("isect ray is->pt ", is->pt);
			VPRINT("on_eu   eg->e_pt ", on_eu->g.lseg_p->e_pt);
			VPRINT("isect ray is->dir", is->dir);
			VPRINT("on_eu   eg->e_dir", on_eu->g.lseg_p->e_dir);
			rt_bomb("bad line\n");
			/* XXX How about resetting is->pt to eg->pt, etc.? */
d3727 2
a3728 1
	} else {
d3734 13
d3765 1
a3765 1
	nmg_isect_line2_face2pNEW(is, fu1, &eu1_list, &eu2_list);
d3796 1
a3796 1
	nmg_isect_line2_face2pNEW(is, fu2, &eu2_list, &eu1_list);
@


11.2
log
@Added some debug code to nmg_isect_line2_face2pNEW().
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 11.1 95/01/04 09:57:43 mike Rel4_4 Locker: jra $ (ARL)";
d4086 1
d4129 2
a4130 1
	flags = (char *)rt_calloc( s1->r_p->m_p->maxindex * 4, sizeof(char),
d4138 1
d4254 1
@


11.1
log
@Release_4.4
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.197 95/01/04 07:57:53 mike Exp $ (ARL)";
d2971 5
@


10.197
log
@Cray C90
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.196 95/01/03 23:09:40 mike Exp Locker: mike $ (ARL)";
@


10.196
log
@Fixed argument type so it will compile everywhere.
A more genuine fix is left for later.  Bug #270
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.195 94/12/27 17:47:52 mike Exp Locker: mike $ (ARL)";
d156 2
a157 2
	struct faceuse		*dualfu;	/* faceuse of vu's dual */
	struct shell		*duals;		/* shell of vu's dual */
d3875 1
a3875 1
	struct vertexuse	*vu2;
@


10.195
log
@Bug 247, changed show_broken_stuff to nmg_show_broken_classifier_stuff().
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.194 94/12/20 14:58:39 jra Exp Locker: mike $ (ARL)";
d3801 3
a3803 1
		(void)nmg_isect_2colinear_edge2p( eu1, eu2, eu1->e_p, is, 0, 0 );
@


10.194
log
@MOds for CRAY
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.193 94/11/04 12:17:40 jra Exp Locker: jra $ (ARL)";
d3523 2
a3524 2
	show_broken_stuff((long *)fu1, (long **)NULL, 1, 0);
	show_broken_stuff((long *)fu2, (long **)NULL, 1, 0);
@


10.193
log
@Modified calls to nmg_pr_eg to agree with new declaration.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.192 94/11/04 06:48:34 mike Exp $ (ARL)";
d936 3
a938 3
	nmg_get_2d_vertex( a, v1a, is, fu );
	nmg_get_2d_vertex( b, v1b, is, fu );
	nmg_get_2d_vertex( p, v2, is, fu );
d1259 2
a1260 2
	nmg_get_2d_vertex( eu1_start, vu1a->v_p, is, fu2 );	/* 2D line */
	nmg_get_2d_vertex( eu1_end, vu1b->v_p, is, fu2 );
d1263 2
a1264 2
	nmg_get_2d_vertex( eu2_start, vu2a->v_p, is, fu2 );
	nmg_get_2d_vertex( eu2_end, vu2b->v_p, is, fu2 );
d2344 2
a2345 2
	nmg_get_2d_vertex( eu1_start, vu1a->v_p, is, fu1 );
	nmg_get_2d_vertex( eu1_end, vu1b->v_p, is, fu1 );
d2629 2
a2630 2
struct edge_g_lseg		*eg1;		/* edge_g_lseg of hit_v */
struct edge_g_lseg		*eg2;		/* edge_g_lseg of v */
d2981 1
a2981 1
			nmg_get_2d_vertex( hit2d, hit_v, is, fu1 );
d3050 2
a3051 2
			nmg_get_2d_vertex( eu1_pt2d, vu1a->v_p, is, fu1 );
			nmg_get_2d_vertex( eu1_end2d, vu1b->v_p, is, fu1 );
@


10.192
log
@Irix 6 lint
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.191 94/10/11 19:42:36 mike Exp Locker: mike $ (ARL)";
d2656 2
a2657 2
	nmg_pr_eg(eg1, 0);
	nmg_pr_eg(eg2, 0);
d2923 2
a2924 2
			nmg_pr_eg(*eg1, 0);
			nmg_pr_eg(is->on_eg, 0);
d2951 2
a2952 2
				nmg_pr_eg(*eg1, 0);
				nmg_pr_eg(is->on_eg, 0);
d3330 2
a3331 2
		    			nmg_pr_eg( eur->g.lseg_p, 0 );
		    			nmg_pr_eg( ret->g.lseg_p, 0 );
@


10.191
log
@SUnOS pointed out variable 'lu' was printed before being set.
IN fact, it was never used.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.190 94/09/16 20:45:48 mike Exp Locker: mike $ (ARL)";
a89 2
static CONST struct nmg_visit_handlers nmg_null_handlers;	/* null filled */

a573 1
	fastf_t		dist;
a652 1
	struct loopuse *plu;
a1197 3
	int		wire = 1;	/* at least one arg is a wire */
	long		*magic1;
	long		*magic2;
a1217 12
	if( fu1 && fu2 )  wire = 0;	/* No wire edges */

	/* Note what parent to make self-loops in:  faceuse, or shell */
	if( fu1 )
		magic1 = &fu1->l.magic;
	else
		magic1 = &nmg_find_s_of_eu(eu1)->l.magic;
	if( fu2 )
		magic2 = &fu2->l.magic;
	else
		magic2 = &nmg_find_s_of_eu(eu2)->l.magic;

a1420 1
		struct loopuse *plu;
a1557 1
	struct vertex	*v2;
a1563 2
	struct loopuse	*plu;
	fastf_t		dist2;
a1564 1
	struct edgeuse	*euforw;
a1565 1
	struct edgeuse	*eulast;
a1970 1
	int			another_pass;
a1972 1
	struct edgeuse		**eup;
a2314 1
	struct vertexuse	*vu;
a2474 1
	point_t		v2d;
a3378 4
	struct nmg_ptbl	on_line;	/* List of eu's on the line */
	int	again;		/* Need to do it again? */
	int	trips;		/* Number of trips through loop */
	CONST struct edgeuse_g	*on_eg;
a3554 1
	int		i;
a3749 1
top:
a3796 1
		int	nbreak;
a3941 1
	struct shell	*s1;
a3951 2
	s1 = nmg_find_s_of_eu(eu1);

d4283 1
@


10.190
log
@nmg_move_eg() became nmg_jeg().
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.189 94/09/16 20:19:39 mike Exp Locker: mike $ (ARL)";
a1988 1
	struct loopuse		*lu;
d2134 1
a2134 1
		rt_log("nmg_isect_edge2p_face2p(): total_splits=%d\n", lu, total_splits);
@


10.189
log
@Moved rt_2line3_colinear() to plane.c
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.188 94/09/12 13:45:01 mike Exp Locker: mike $ (ARL)";
d2963 1
a2963 1
		    	nmg_move_eg( *eg1, is->on_eg );
d3371 1
a3371 1
						nmg_move_eg( eur->g.lseg_p, ret->g.lseg_p );
@


10.188
log
@Fixed XXX.  pointer went invalid after realloc().
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.187 94/09/10 23:02:54 jra Exp Locker: mike $ (ARL)";
a61 4
/* XXX move to raytrace.h */
RT_EXTERN(struct edgeuse	*nmg_ebreaker, (struct vertex *v,
				struct edgeuse *eu, CONST struct rt_tol *tol));

a2822 55
}

/* XXX move to plane.c */
/*
 *			R T _ 2 L I N E 3 _ C O L I N E A R
 *
 *  Returns non-zero if the 3 lines are colinear to within tol->dist
 *  over the given distance range.
 *
 *  Range should be at least one model diameter for most applications.
 *  1e5 might be OK for a default for "vehicle sized" models.
 *
 *  The direction vectors do not need to be unit length.
 */
int
rt_2line3_colinear( p1, d1, p2, d2, range, tol )
CONST point_t		p1;
CONST vect_t		d1;
CONST point_t		p2;
CONST vect_t		d2;
double			range;
CONST struct rt_tol	*tol;
{
	fastf_t		mag1;
	fastf_t		mag2;
	point_t		tail;

	RT_CK_TOL(tol);

	if( (mag1 = MAGNITUDE(d1)) < SMALL_FASTF )  rt_bomb("rt_2line3_colinear() mag1 zero\n");
	if( (mag2 = MAGNITUDE(d2)) < SMALL_FASTF )  rt_bomb("rt_2line3_colinear() mag2 zero\n");

	/* Impose a general angular tolerance to reject 
	/* tol->para and RT_DOT_TOL are too tight a tolerance.  0.1 is 5 degrees */
	if( fabs(VDOT(d1, d2)) < 0.9 * mag1 * mag2  )  goto fail;

	/* See if start points are within tolerance of other line */
	if( rt_distsq_line3_pt3( p1, d1, p2 ) > tol->dist_sq )  goto fail;
	if( rt_distsq_line3_pt3( p2, d2, p1 ) > tol->dist_sq )  goto fail;

	VJOIN1( tail, p1, range/mag1, d1 );
	if( rt_distsq_line3_pt3( p2, d2, tail ) > tol->dist_sq )  goto fail;

	VJOIN1( tail, p2, range/mag2, d2 );
	if( rt_distsq_line3_pt3( p1, d1, tail ) > tol->dist_sq )  goto fail;

	if( rt_g.debug & DEBUG_MATH )  {
		rt_log("rt_2line3colinear(range=%g) ret=1\n",range);
	}
	return 1;
fail:
	if( rt_g.debug & DEBUG_MATH )  {
		rt_log("rt_2line3colinear(range=%g) ret=0\n",range);
	}
	return 0;
@


10.187
log
@Changed call to nmg_2edge_g_coincident to nmg_2edgeuse_coincident.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.186 94/09/10 04:36:52 mike Exp Locker: jra $ (ARL)";
d3073 1
d3182 1
a3182 1
				/* XXX What about realloc() moving the array? */
d3184 1
d3210 2
@


10.186
log
@Converted NMG data structures to have edge_g pointer in edgeuse, not edge.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.185 94/09/03 03:01:36 mike Exp $ (ARL)";
d3420 1
a3420 1
					coincident = nmg_2edge_g_coincident( eur->e_p, ret->e_p, tol );
@


10.185
log
@Snapshot of non-working intermediate stage in edge_g evolution.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.184 94/09/02 00:32:02 mike Exp Locker: mike $ (ARL)";
d495 1
a495 1
		eg = e1->eg_p;
d1035 1
a1035 1
		if( (*eup)->e_p->eg_p != eg )  continue;
d2042 1
a2042 1
	is->on_eg = eu1->e_p->eg_p;
d2260 1
a2260 1
			eg = eu->e_p->eg_p;
d2299 1
a2299 1
			eg = eu->e_p->eg_p;
d2636 1
a2636 1
			ret = (*eup)->e_p->eg_p;
d2639 1
a2639 1
		if( (*eup)->e_p->eg_p == ret ) continue;	/* OK */
d2641 1
a2641 1
		rt_log("*eup=x%x, eg_p=x%x, ret=x%x\n", *eup, (*eup)->e_p->eg_p, ret );
d2731 2
a2732 2
CONST struct edge_g_lseg		*eg1;
CONST struct edge_g_lseg		*eg2;
d2763 2
a2764 2
		if( eu1->e_p->eg_p == eg1 )  seen1 = 1;
		if( eu1->e_p->eg_p == eg2 )  seen2 = 1;
d2820 1
a2820 1
		if( (*eu1)->e_p->eg_p != eg1 )  rt_bomb("nmg_isect_2eg() sanity\n");
d2955 1
a2955 1
				if( (*eu1)->e_p->eg_p != is->on_eg )  continue;
d2963 1
a2963 1
					if( (*eu2)->e_p->eg_p != is->on_eg )  continue;
d3022 1
a3022 1
		    	nmg_move_eg( *eg1, is->on_eg, fu1->s_p );
d3084 1
a3084 1
			if( (*eu1)->e_p->eg_p != *eg1 )  continue;
d3250 1
a3250 1
			if( (*eu1)->e_p->eg_p != is->on_eg )  continue;
d3265 1
a3265 1
			if( (*eu2)->e_p->eg_p != is->on_eg )  continue;
d3301 1
a3301 1
	eg = eu->e_p->eg_p;
d3399 1
a3399 1
			    		if( eur->e_p->eg_p == ret->e_p->eg_p )  continue;
d3413 4
a3416 4
		    				eur, eur->e_p->eg_p,
		    				ret, ret->e_p->eg_p);
		    			nmg_pr_eg( eur->e_p->eg_p, 0 );
		    			nmg_pr_eg( ret->e_p->eg_p, 0 );
d3424 3
a3426 3
							eur->e_p, eur->e_p->eg_p,
							ret->e_p, ret->e_p->eg_p );
						nmg_move_eg( eur->e_p->eg_p, ret->e_p->eg_p, nmg_find_s_of_eu(eur) );
d3439 1
a3439 1
			ofu1, fu2, ret ? ret->e_p->eg_p : 0);
d3442 1
a3442 1
		return ret->e_p->eg_p;
d3505 1
a3505 1
			VPRINT("on_eu   eg->e_pt ", on_eu->e_p->eg_p->e_pt);
d3507 1
a3507 1
			VPRINT("on_eu   eg->e_dir", on_eu->e_p->eg_p->e_dir);
d4132 1
a4132 1
		neu2 = nmg_eusplit( eu1->eumate_p->vu_p->v_p, neu1 );
@


10.184
log
@Changed to new face geometry pointers (g.plane_p)
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.183 94/08/10 18:52:22 gdurf Exp Locker: mike $ (ARL)";
d81 1
a81 1
	struct edge_g	*on_eg;		/* edge_g for line of intersection */
d416 2
a417 2
 * or a face pointer.  In case of edge, make edge_g->dir unit, and
 * rotate that to +X axis.  Make edge_g->pt be the origin.
d490 1
a490 1
		struct edge_g	*eg;
d496 1
a496 1
		NMG_CK_EDGE_G(eg);
d1004 1
a1004 1
CONST struct edge_g	*eg;
d1013 1
a1013 1
	NMG_CK_EDGE_G(eg);
d2257 1
a2257 1
			struct edge_g	*eg;
d2296 1
a2296 1
			struct edge_g	*eg;
d2613 1
a2613 1
 *  Do a geometric search to find an edge_g on the given line.
d2616 1
a2616 1
struct edge_g *
d2625 1
a2625 1
	struct edge_g	*ret = (struct edge_g *)NULL;
d2635 1
a2635 1
			/* No edge_g found yet, use this one. */
d2640 1
a2640 1
		/* Found different edge_g, claimed to be colinear */
d2663 2
a2664 2
struct edge_g		*eg1;		/* edge_g of hit_v */
struct edge_g		*eg2;		/* edge_g of v */
d2670 2
a2671 2
	NMG_CK_EDGE_G(eg1);
	NMG_CK_EDGE_G(eg2);
d2731 2
a2732 2
CONST struct edge_g		*eg1;
CONST struct edge_g		*eg2;
d2743 2
a2744 2
	NMG_CK_EDGE_G(eg1);
	NMG_CK_EDGE_G(eg2);
d2792 2
a2793 2
struct edge_g		*eg1;
struct edge_g		*eg2;
d2801 2
a2802 2
	NMG_CK_EDGE_G(eg1);
	NMG_CK_EDGE_G(eg2);
d2887 2
a2888 2
 *  For each distinct edge_g LINE on the face (composed of potentially many
 *  edgeuses and many different edges), intersect the edge_g LINE with
d2901 1
a2901 1
	struct edge_g		**eg1;
d2927 1
a2927 1
	/* Build list of all edge_g's in fu1 */
d2932 2
a2933 2
	for( eg1 = (struct edge_g **)NMG_TBL_LASTADDR(&eg_list);
	     eg1 >= (struct edge_g **)NMG_TBL_BASEADDR(&eg_list); eg1--
d2937 1
a2937 1
		NMG_CK_EDGE_G(*eg1);
d3296 1
a3296 1
	struct edge_g	*eg;
d3302 1
a3302 1
	NMG_CK_EDGE_G(eg);
d3336 1
a3336 1
struct edge_g *
d3443 1
a3443 1
	return (struct edge_g *)NULL;
d3499 1
a3499 1
		NMG_CK_EDGE_G(is->on_eg);
@


10.183
log
@fix include ordering
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.182 1994/08/09 19:37:55 mike Exp gdurf $ (ARL)";
d426 1
a426 1
	struct face_g	*fg;
d458 2
a459 2
		fg = f1->fg_p;
		NMG_CK_FACE_G(fg);
d3344 2
a3345 2
	CONST struct face_g	*fg1;
	CONST struct face_g	*fg2;
d3354 4
a3357 4
	fg1 = ofu1->f_p->fg_p;
	fg2 = fu2->f_p->fg_p;
	NMG_CK_FACE_G(fg1);
	NMG_CK_FACE_G(fg2);
d3359 1
a3359 1
	if( fg1 == fg2 )  rt_bomb("nmg_find_eg_between_2fg() face_g shared, infinitely many results\n");
d3389 1
a3389 1
					if( tfu->f_p->fg_p != fg2 )  continue;
d3659 1
a3659 1
	NMG_CK_FACE_G(f1->fg_p);
d3664 1
a3664 1
	NMG_CK_FACE_G(f2->fg_p);
d3684 1
a3684 1
	if( f1->fg_p == f2->fg_p )  {
d3730 1
a3730 1
		if( fu1->f_p->fg_p == fu2->f_p->fg_p )  {
d4230 1
a4230 1
		NMG_CK_FACE_G(f1->fg_p);
@


10.182
log
@Added GDurf's new "conf.h"
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.181 94/07/06 20:15:39 mike Exp Locker: mike $ (ARL)";
d55 1
a56 1
#include "machine.h"
@


10.181
log
@Changed to using nmg_find_eg_between_2fg()
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.180 94/07/06 16:50:08 mike Exp Locker: mike $ (ARL)";
d52 1
@


10.180
log
@Changed from nmg_ebreak() to nmg_ebreaker()
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.179 94/07/06 15:46:46 mike Exp Locker: mike $ (ARL)";
d2997 1
a2997 1
				rt_log("nmg_isect_line2_face2pNEW() edge_g not shared, geometry says lines are colinear.  Unresolvable inconsistency.\n");
d3319 127
d3466 1
a3466 1
	CONST struct edgeuse	*on_eu;
d3497 1
a3497 2
	if( (on_eu = nmg_find_edge_between_2fu(fu1, fu2, &(is->tol))) )  {
		is->on_eg = on_eu->e_p->eg_p;
d3499 1
d3510 1
@


10.179
log
@Removed some deadwood code.
Added "wire" to some wire-only routine names.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.178 94/07/04 03:17:07 mike Exp Locker: mike $ (ARL)";
d61 4
d786 1
a786 1
		eu1forw = nmg_ebreak(v2, eu1);
d813 1
a813 1
		eu1forw = nmg_ebreak((struct vertex *)NULL, eu1);
d978 1
a978 1
		new_eu = nmg_ebreak( v2, eu1 );
d1047 1
a1047 1
		new_eu = nmg_ebreak( v, *eup );
d1394 1
a1394 1
		vu = nmg_ebreak( vu1a->v_p, eu2 )->vu_p;
d1433 1
a1433 1
		vu = nmg_ebreak( vu1b->v_p, eu2 )->vu_p;
d1462 1
a1462 1
			new_vu2 = nmg_ebreak( new_v2, eu2 )->vu_p;
d1488 1
a1488 1
		vu = nmg_ebreak( vu2a->v_p, eu1 )->vu_p;
d1495 1
a1495 1
		vu = nmg_ebreak( vu2b->v_p, eu1 )->vu_p;
d2471 1
a2471 1
		vu1_final = nmg_ebreak(new_v, eu1)->vu_p;
d3179 1
a3179 1
				new_eu = nmg_ebreak(hit_v, *eu1);
d3786 1
a3786 1
		nmg_ebreak( vu1a->v_p, eu2 );
d3800 1
a3800 1
		nmg_ebreak( vu1b->v_p, eu2 );
d3808 1
a3808 1
			nmg_ebreak( vu2a->v_p, eu1 );
d3812 1
a3812 1
			nmg_ebreak( vu2b->v_p, eu1 );
d3858 1
a3858 1
		vu2 = nmg_ebreak( vu1->v_p, eu2 )->vu_p;
@


10.178
log
@Increased size of flags[] for nmg_crackshells().
@
text
@a0 1
#define HEART 1
d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.177 94/07/04 02:48:14 mike Exp Locker: mike $ (ARL)";
a549 76
 *			N M G _ I S E C T _ E D G E 2 P _ V E R T 2 P
 *
 *  Intersect an edge and a vertex known to lie in the same plane.
 *
 *  This is a separate routine because it's used more than once.
 *
 *  Returns -
 *	0	if there was no intersection
 *	1	if the vertex was an endpoint of the edge.
 *	2	if edge was split (in the middle) at vertex.
 *
 * XXX YYY ZZZ replace this with nmg_isect_vu_on_eu().
 */
static int
nmg_isect_edge2p_vert2p( is, eu, vu )
struct nmg_inter_struct *is;
struct edgeuse		*eu;
struct vertexuse	*vu;
{
	fastf_t		dist;
	int		status;
	point_t		endpt;
	int		ret;

	NMG_CK_INTER_STRUCT(is);
	NMG_CK_EDGEUSE(eu);
	NMG_CK_VERTEXUSE(vu);

	/* Topology check */
	if( vu->v_p == eu->vu_p->v_p || vu->v_p == eu->eumate_p->vu_p->v_p )  {
		ret = 1;
		goto out;
	}

	/* XXX a 2d formulation would be better! */
#if 0
	/* Has to wait for non-faceuse based versions of the 2d proj */
	nmg_get_2d_vertex( is->pt, eu->vu_p->v_p, is, fu );
	nmg_get_2d_vertex( endpt, eu->eumate_p->vu_p->v_p, is, fu );
	VSUB2_2D( is->dir, endpt, is->pt );
	/* rt_isect_pt2_lseg2() */
#endif

	status = rt_isect_pt_lseg( &dist,
		eu->vu_p->v_p->vg_p->coord,
		eu->eumate_p->vu_p->v_p->vg_p->coord,
		vu->v_p->vg_p->coord, &is->tol );
	switch( status )  {
	default:
		ret = 0;
		break;
	case 1:
		/* pt is at start of edge */
		/* The vertex assumes the coords of the edge vertex */
		nmg_jv( eu->vu_p->v_p, vu->v_p );
		ret = 1;
		break;
	case 2:
		/* pt is at end of edge */
		/* The vertex assumes the coords of the edge vertex */
		nmg_jv( vu->v_p, eu->eumate_p->vu_p->v_p );
		ret = 1;
		break;
	case 3:
		/* pt is in interior of edge, break edge */
		(void)nmg_ebreak( vu->v_p, eu );
		ret = 2;
		break;
	}
out:
	if (rt_g.NMG_debug & DEBUG_POLYSECT)
		rt_log("nmg_isect_edge2p_vert2p(, eu=x%x, vu=x%x) ret=%d\n", eu, vu, ret);
	return ret;
}

/*
d561 4
d1554 1
a1554 1
 *			N M G _ I S E C T _ E D G E 3 P _ F A C E 3 P
d1568 1
a1568 1
nmg_isect_edge3p_face3p(is, eu1, fu2)
d1595 1
a1595 1
		rt_log("nmg_isect_edge3p_face3p(, eu1=x%x, fu2=x%x) START\n", eu1, fu2);
d1611 1
a1611 1
	if( fu2->orientation != OT_SAME )  rt_bomb("nmg_isect_edge3p_face3p() fu2 not OT_SAME\n");
d1669 1
a1669 1
			rt_log("nmg_isect_edge3p_face3p: edge lies ON face, using 2D code\n@@ @@ @@ @@ @@ @@ @@ @@ @@ @@ 2D CODE, START\n");
d1690 1
a1690 1
			rt_log("nmg_isect_edge3p_face3p: @@ @@ @@ @@ @@ @@ @@ @@ @@ @@ 2D CODE, END, resume 3d problem.\n");
d1744 1
a1744 1
		rt_bomb("nmg_isect_edge3p_face3p: Edge start vertex lies on other face (geometry)\n");
d1789 1
a1789 1
			rt_log("WARNING nmg_isect_edge3p_face3p() hit_pt off f/f line %g*tol (%e, tol=%e)\n",
d1832 1
a1832 1
			rt_bomb("nmg_isect_edge3p_face3p: discontinuous eu loop\n");
d1844 1
a1844 1
		if( vu1_final->v_p != vu2_final->v_p )  rt_bomb("nmg_isect_edge3p_face3p() vertex mis-match\n");
d1849 1
a1849 1
			rt_log("ERROR nmg_isect_edge3p_face3p() vu1=x%x point off line by %g > 100*dist_tol (%g)\n",
d1854 1
a1854 1
			rt_bomb("nmg_isect_edge3p_face3p()\n");
d1857 1
a1857 1
			rt_log("WARNING nmg_isect_edge3p_face3p() vu1=x%x pt off line %g*tol (%e, tol=%e)\n",
d1864 1
a1864 1
		rt_log("nmg_isect_edge3p_face3p(, eu1=x%x, fu2=x%x) ret=%d END\n", eu1, fu2, ret);
d1869 1
a1869 1
 *			N M G _ I S E C T _ L O O P 3 P _ F A C E 3 P
d1879 1
a1879 1
nmg_isect_loop3p_face3p(bs, lu, fu)
d1890 1
a1890 1
		rt_log("nmg_isect_loop3p_face3p(, lu=x%x, fu=x%x) START\n", lu, fu);
d1911 1
a1911 1
		rt_bomb("nmg_isect_loop3p_face3p() Unknown type of NMG loopuse\n");
d1918 1
a1918 1
	 * by nmg_isect_edge3p_face3p.  This is because the edgeuses
d1929 1
a1929 1
			rt_bomb("nmg_isect_loop3p_face3p: edge does not share loop\n");
d1932 1
a1932 1
		discards += nmg_isect_edge3p_face3p(bs, eu, fu);
d1934 1
a1934 1
		nmg_ck_lueu(lu, "nmg_isect_loop3p_face3p");
d1938 1
a1938 1
		rt_log("nmg_isect_loop3p_face3p(, lu=x%x, fu=x%x) END, discards=%d\n", lu, fu, discards);
a1998 3
#if !HEART
	struct nmg_ptbl		eutab;
#endif
a2115 26
#if !HEART
	/*
	 *  The line of intersection is defined by the geometry of this
	 *  edgeuse.  Therefore, all edgeuses which share edge geometry
	 *  are, by definition, ON the line.
	 *  (1) For every vertex ON the line, intersect it with fu2,
	 *  so that all edges in fu2 are properly broken, then
	 *  (2) enlist all the vertexuses on the intersect list.
	 *  The face cutter will take care of joining unshared edges.
	 *  (I hope!)
	 */
	nmg_edgeuse_with_eg_tabulate( &eutab,
		fu1 ? &fu1->l.magic : eu1->up.magic_p,
		eu1->e_p->eg_p );
	for( eup = (struct edgeuse **)NMG_TBL_LASTADDR(&eutab);
	     eup >= (struct edgeuse **)NMG_TBL_BASEADDR(&eutab); eup--
	)  {
		struct vertexuse	*vu1a, *vu1b;
		NMG_CK_EDGEUSE(*eup);
		vu1a = (*eup)->vu_p;
		vu1b = RT_LIST_PNEXT_CIRC(edgeuse,(*eup))->vu_p;
		nmg_isect_vert2p_face2p( is, vu1a, fu2 );
		nmg_isect_vert2p_face2p( is, vu1b, fu2 );
	}
#endif

a2124 1
#if HEART
a2126 3
#else
	total_splits = nmg_isect_line2_face2p( is, fu2, eu1, &eutab );
#endif
a2130 1
#if HEART
a2131 3
#else
		total_splits += nmg_isect_line2_face2p( is, fu1, 0, 0 );
#endif
a2135 3
#if !HEART
	nmg_tbl( &eutab, TBL_FREE, (long *)0 );
#endif
a2191 2
 *			nmg_isect_line2_vertex2()
 *			nmg_isect_line2_edgegeom2p()
a2605 536
 *			N M G _ I S E C T _ L I N E _ E D G E G E O M 2 P
 *
 *  Given an edgeuse eu1 in fu1 with edge geometry eg1,
 *  and a (2 face intersection) line which lies in the plane of fu1,
 *  calculate the intersection of eg1 with the line,
 *  and apply that result to all edgeuses which share eg1.
 *
 *  This routine replaces the incremental approach, which tended to
 *  degenerate when a long edge was broken very near an edgeuse.
 *  When the angle from the edge to the line was small, that close
 *  extra vertexuse would also get listed on the line of intersection,
 *  playing havoc with the state transition mechanism of the face cutter.
 *
 *  In this routine, two non-colinear lines will intersect in exactly one pt.
 *
 *  In some cases, the line actually represents an edge_geometry.
 *  In that case, a topological search for an existing vertex of intersection
 *  between the two edge_geometries must be performed before attempting
 *  any geometry comparisons.
 *
 *  Called by nmg_isect_line2_face2p().
 *
 *  Returns -
 *	Number of times an edge is broken (0 or >=1).
 */
int
nmg_isect_line2_edgegeom2p( is, eu1, fu1, eu2, line_eutab )
struct nmg_inter_struct	*is;
struct edgeuse		*eu1;
struct faceuse		*fu1;
struct edgeuse		*eu2;		/* optional: edge generating the line */
struct nmg_ptbl		*line_eutab;	/* optional */
{
	point_t		eu1_pt2d;	/* 2D */
	point_t		eu1_end2d;	/* 2D */
	fastf_t		dist[2];
	int		status;
	point_t		hit3d;
	point_t		hit2d;
	struct vertexuse	*vu;
	struct vertexuse	*vu1a, *vu1b;
	int			ret = 0;
	struct edge_g		*eg1;
	struct nmg_ptbl		eutab;
	point_t		eg_pt2d;	/* 2D */
	vect_t		eg_dir2d;	/* 2D */
	struct edgeuse	**eup;
	struct vertex	*hit_v;
	int		code;
	int		n_colinear;
	fastf_t		min_dist_sq;

	eutab.magic = 0;

	NMG_CK_INTER_STRUCT(is);
	NMG_CK_EDGEUSE(eu1);
	NMG_CK_FACEUSE(fu1);
	if( eu2 )  NMG_CK_EDGEUSE(eu2);
	if( line_eutab )  NMG_CK_PTBL(line_eutab);

	eg1 = eu1->e_p->eg_p;
	NMG_CK_EDGE_G(eg1);

	if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
		rt_log("nmg_isect_line2_edgegeom2p(eu1=x%x, fu1=x%x)  START\n\teg1=x%x, eu2=x%x, line_eutab=x%x\n",
			fu1, eu1,
			eg1, eu2, line_eutab);
	}

	/* If the edge generated this line, colinearity is assured. */
	if( eu2 && eu2->e_p->eg_p == eg1 )  {
		if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
			rt_log("\tThis edge_geom generated the line.  Enlisting.\n");
		}
		for( eup = (struct edgeuse **)NMG_TBL_LASTADDR(line_eutab);
		     eup >= (struct edgeuse **)NMG_TBL_BASEADDR(line_eutab);
		     eup--
		)  {
			vu1a = (*eup)->vu_p;
			vu1b = RT_LIST_PNEXT_CIRC( edgeuse, (*eup) )->vu_p;
			nmg_enlist_vu(is, vu1a, 0);
			nmg_enlist_vu(is, vu1b, 0);
		}
		ret = 0;
		goto out;
	}

	/*  The 3D line in is->pt and is->dir is prepared by our caller. */
	/*  So is the 2D line in is->pt2d and is->dir2d. */
	MAT4X3PNT( eg_pt2d, is->proj, eg1->e_pt );
	MAT4X3VEC( eg_dir2d, is->proj, eg1->e_dir );

	/*
	 *  Determine if eg1 is colinear with the line of intersection. 2D
	 */
	dist[0] = dist[1] = -INFINITY;
	code = rt_isect_line2_line2( dist, is->pt2d, is->dir2d,
		eg_pt2d, eg_dir2d, &(is->tol) );
	if( code < 0 )  {
		/* Lines are parallel, no intersection, nothing to do. */
		ret = 0;
		goto out;
	}

	/* Assemble the list of eu's in fu1 that use eg1 */
	nmg_edgeuse_with_eg_tabulate( &eutab, &fu1->l.magic, eg1 );
	if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
		rt_log("   code=%d, dist[0]=%g\n", code, dist[0]);
		nmg_pr_ptbl("fu1 edgeuse table", &eutab, 1);
		if( line_eutab )  nmg_pr_ptbl("line_eutab from fu2", line_eutab, 1);
	}

	/* XXX These are not unit length */
	if( fabs(VDOT_2D(is->dir2d, eg_dir2d)) < is->tol.para *
	    sqrt(MAGSQ_2D(is->dir2d)) * sqrt(MAGSQ_2D(eg_dir2d)) )
		goto not_colinear;

	/*
	 *  Even though rt_isect_line2_line2() might have said "non-colinear",
	 *  the angles are close enough that it's worth searching properly.
	 *
	 *  eg1 is potentially colinear with line of intersection.
	 *  Test each edgeuse on eg1 individually, and count all those where
	 *  both vertices are within tolerance of the line.
	 *  The 3D version of the comparison is used here, for
	 *  consistency with similar checks in other routines.
	 */
	n_colinear = 0;
	for( eup = (struct edgeuse **)NMG_TBL_LASTADDR(&eutab);
	     eup >= (struct edgeuse **)NMG_TBL_BASEADDR(&eutab); eup--
	)  {
		FAST fastf_t		a, b;

		NMG_CK_EDGEUSE(*eup);

		vu1a = (*eup)->vu_p;
		vu1b = RT_LIST_PNEXT_CIRC( edgeuse, (*eup) )->vu_p;
		NMG_CK_VERTEXUSE(vu1a);
		NMG_CK_VERTEXUSE(vu1b);

		a = rt_distsq_line3_pt3( is->pt, is->dir, vu1a->v_p->vg_p->coord );
		b = rt_distsq_line3_pt3( is->pt, is->dir, vu1b->v_p->vg_p->coord );
		if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
			rt_log("\tColinearity check *eup=x%x, a^2=%g, b^2=%g, tol^2=%g\n",
				*eup, a, b, is->tol.dist_sq);
		}
		if( a > is->tol.dist_sq || b > is->tol.dist_sq )
			continue;
		n_colinear++;
	}
	if( n_colinear >= NMG_TBL_END(&eutab) )  {
		register int	i, j;

		ret = 0;
		/* All edgeuses are colinear!  Enlist them and return. */
		if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
			rt_log("\tAll colinear.  Enlisting all edgeuse vu's\n");
		}
		/* Use subscripts and search upwards; table may grow */
		for( i=0; i < NMG_TBL_END(&eutab); i++ )  {
			register struct edgeuse	*eu1;

			eu1 = (struct edgeuse *)NMG_TBL_GET(&eutab, i);
			vu1a = eu1->vu_p;
			vu1b = RT_LIST_PNEXT_CIRC( edgeuse, eu1 )->vu_p;
			if( line_eutab )  {
				register struct edgeuse	*eu2;

				/* Search upwards, as it may grow */
				for( j=0; j<NMG_TBL_END(line_eutab); j++ )  {
					eu2 = (struct edgeuse *)NMG_TBL_GET(line_eutab, j);
					ret += nmg_isect_2colinear_edge2p(
						eu1, eu2,
						fu1, is, &eutab, line_eutab
						) - 2;
					/* New edgeuses are added to lists now */
					/* All vertexuses are enlisted now */
				}
			}
			/* Do this regardless, just to be safe.  But after isect */
			nmg_enlist_vu(is, vu1a, 0);
			nmg_enlist_vu(is, vu1b, 0);
		}
		/* ret is calculated above */
		goto out;
	}
	if( n_colinear > 0 )  {
		/*
		 *  Only *some* of the edgeuses are colinear, yet they all
		 *  came from the same original edge, and share edge geometry.
		 *  Now what?
		 */
		if( code >= 1 )  {
			if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
				rt_log("\t%d of %d eus claim colinearity.  Using isect point.\n",
					n_colinear, NMG_TBL_END(&eutab));
			}
			/* Don't enlist ANY of the eu's due to colinearity */
			goto not_colinear;
		}
		rt_log("\tOnly %d of %d edgeuses claim colinearity.\n",
			n_colinear, NMG_TBL_END(&eutab));
		rt_bomb("partially colinear edge geometry?\n");
	}
	/*  If rt_isect_line2_line2() says colinear, we are done. */
	if( code == 0 )  {
		/*
		 *  The edges themselves *all* disagree that they are colinear.
		 *  Since we don't have a hit distance to use,
		 *  call the 2 lines colinear and parallel.  No intersects.
		 */
		if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
			rt_log("\tNo colinear edgeuses, assuming parallel lines.  Miss.\n");
		}
		ret = 0;
		goto out;
	}

not_colinear:
	/*
	 *  Found the ONE point in 2D where the two lines intersect.
	 *  First step:  a topological search of the two intersect lines
	 *  for a common vertex.
	 */
	if( line_eutab && nmg_isect_two_ptbls( is, &eutab, line_eutab ) )  {
		/* Topological intersection has been enlisted.  Done. */
		if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
			rt_log("\tTopological intersection enlisted.\n");
		}
		ret = 0;	/* No broken edges */
		goto out;
	}

	/*
	 *  Before we believe that the rt_isect_line2_line2()'s hit point
	 *  is the place to break our edge, search for the vertex
	 *  closest to the line.  If it's within tolerance, use *that*
	 *  rather than breaking the edge.
	 */
	min_dist_sq = INFINITY;
	for( eup = (struct edgeuse **)NMG_TBL_LASTADDR(&eutab);
	     eup >= (struct edgeuse **)NMG_TBL_BASEADDR(&eutab); eup--
	)  {
		FAST fastf_t		d;

		NMG_CK_EDGEUSE(*eup);

		vu1a = (*eup)->vu_p;
		vu1b = RT_LIST_PNEXT_CIRC( edgeuse, (*eup) )->vu_p;
		NMG_CK_VERTEXUSE(vu1a);
		NMG_CK_VERTEXUSE(vu1b);

		d = rt_distsq_line3_pt3( is->pt, is->dir, vu1a->v_p->vg_p->coord );
		if( d < min_dist_sq )  {
			min_dist_sq = d;
			hit_v = vu1a->v_p;
		}
		d = rt_distsq_line3_pt3( is->pt, is->dir, vu1b->v_p->vg_p->coord );
		if( d < min_dist_sq )  {
			min_dist_sq = d;
			hit_v = vu1b->v_p;
		}
	}
	if( min_dist_sq < is->tol.dist_sq )  {
		/* Found the vertex.  Enlist all uses of it on this edge_g. */
		if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
			rt_log("\tExisting v=x%x is intersect point, dist=%g\n",
				hit_v, sqrt(min_dist_sq) );
		}
		for( eup = (struct edgeuse **)NMG_TBL_LASTADDR(&eutab);
		     eup >= (struct edgeuse **)NMG_TBL_BASEADDR(&eutab); eup--
		)  {
			NMG_CK_EDGEUSE(*eup);
			vu1a = (*eup)->vu_p;
			vu1b = RT_LIST_PNEXT_CIRC( edgeuse, (*eup) )->vu_p;
			NMG_CK_VERTEXUSE(vu1a);
			NMG_CK_VERTEXUSE(vu1b);
			if( vu1a->v_p == hit_v )
				nmg_enlist_vu(is, vu1a, 0);
			if( vu1b->v_p == hit_v )
				nmg_enlist_vu(is, vu1b, 0);
		}
		ret = 0;
		goto out;
	}

	VJOIN1( hit3d, is->pt, dist[0], is->dir );
	if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
		VPRINT("\t2 lines intersect at", hit3d);
	}
	if( !V3PT_IN_RPP( hit3d, fu1->f_p->min_pt, fu1->f_p->max_pt ) )  {
		/* Lines intersect outside bounds of this face.  Done. */
		ret = 0;
		goto out;
	}

	VJOIN1_2D( hit2d, is->pt2d, dist[0], is->dir2d );
	hit_v = (struct vertex *)NULL;
	ret = 0;

	/*
	 *  Because of the possibility of "acordian pleat" loops that
	 *  run back and forth, it is possible that there might be
	 *  multiple vertexuses to list.
	 */
	for( eup = (struct edgeuse **)NMG_TBL_LASTADDR(&eutab);
	     eup >= (struct edgeuse **)NMG_TBL_BASEADDR(&eutab); eup--
	)  {
		fastf_t			ldist;
		struct vertexuse	*vu1_final;

		NMG_CK_EDGEUSE(*eup);
		if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
			rt_log("\tConsidering *eup=x%x\n", *eup);
		}

		vu1a = (*eup)->vu_p;
		vu1b = RT_LIST_PNEXT_CIRC( edgeuse, (*eup) )->vu_p;
		NMG_CK_VERTEXUSE(vu1a);
		NMG_CK_VERTEXUSE(vu1b);

		/* First, a topology check of both endpoints */
		if( vu1a->v_p == hit_v )  {
hit_a:
			if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
				rt_log("\tlisting intersect point at vu1a=x%x\n", vu1a);
			}
			nmg_enlist_vu(is, vu1a, 0);
		}
		if( vu1b->v_p == hit_v )  {
hit_b:
			if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
				rt_log("\tlisting intersect point at vu1b=x%x\n", vu1b);
			}
			nmg_enlist_vu(is, vu1b, 0);
		}
		if( vu1a->v_p == hit_v || vu1b->v_p == hit_v )  continue;

		/*  Second, a geometry check on the edgeuse ENDPOINTS
		 *  -vs- the line segment.  This is 3D, for consistency
		 *  with comparisons elsewhere.
		 */
		if( rt_distsq_line3_pt3( is->pt, is->dir, vu1a->v_p->vg_p->coord ) <= is->tol.dist_sq  )  {
			hit_v = vu1a->v_p;
			goto hit_a;
		}
		if( rt_distsq_line3_pt3( is->pt, is->dir, vu1b->v_p->vg_p->coord ) <= is->tol.dist_sq )  {
			hit_v = vu1b->v_p;
			goto hit_b;
		}

		/* Third, a geometry check of the HITPT -vs- the line segment */
		nmg_get_2d_vertex( eu1_pt2d, vu1a->v_p, is, fu1 );
		nmg_get_2d_vertex( eu1_end2d, vu1b->v_p, is, fu1 );
		ldist = 0;
		code = rt_isect_pt2_lseg2( &ldist, eu1_pt2d, eu1_end2d, hit2d, &(is->tol) );
		if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
			rt_log("\trt_isect_pt2_lseg2() returned %d, ldist=%g\n", code, ldist);
		}
		switch(code)  {
		case -2:
			continue;	/* outside lseg AB pts */
		default:
		case -1:
#if 0
			rt_log("rt_isect_pt2_lseg2() returned %d, dist[0]=%e\n", code, dist[0]);
			VPRINT("  pt", is->pt);
			VPRINT(" dir", is->dir);
			VPRINT("  A3", vu1a->v_p->vg_p->coord);
			VPRINT("Hit3", hit3d);
			VPRINT("  B3", vu1b->v_p->vg_p->coord);
			V2PRINT("\n pt2", is->pt2d);
			V2PRINT("dir2", is->dir2d);
			V2PRINT("  A2", eu1_pt2d );
			V2PRINT("Hit2", hit2d);
			V2PRINT("  B2", eu1_end2d );
			rt_log("not on line of AB within tolerance, continuing\n");
#endif
			continue;	/* Point not on lseg */
		case 1:
			/* Point is at A (vu1a) by geometry */
			hit_v = vu1a->v_p;
			if (rt_g.NMG_debug & DEBUG_POLYSECT) rt_log("\thit_v = x%x (vu1a)\n", hit_v);
			goto hit_a;
		case 2:
			/* Point is at B (vu1b) by geometry */
			hit_v = vu1b->v_p;
			if (rt_g.NMG_debug & DEBUG_POLYSECT) rt_log("\thit_v = x%x (vu1b)\n", hit_v);
			goto hit_b;
		case 3:
			/* Point hits the line segment amidships!  Split edge!
			 * If we don't have a hit vertex yet,
			 * search for one in whole model.
			 */
			if( !hit_v )  {
				hit_v = nmg_find_pt_in_model(fu1->s_p->r_p->m_p,
					hit3d, &(is->tol));
				if( hit_v == vu1a->v_p || hit_v == vu1b->v_p )
					rt_bomb("About to make 0-length edge!\n");
			}
			vu1_final = nmg_ebreak(hit_v, *eup)->vu_p;
			ret++;		/* tally # of edges broken */
			if( !hit_v )  {
				hit_v = vu1_final->v_p;
				nmg_vertex_gv( hit_v, hit3d );
				if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
					rt_log("\tmaking new vertex vu=x%x hit_v=x%x\n",
						vu1_final, hit_v);
				}
			} else {
				if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
					rt_log("\tre-using hit_v=x%x, vu=x%x\n", hit_v, vu1_final);
				}
				if( hit_v != vu1_final->v_p )  rt_bomb("hit_v changed?\n");
			}
			nmg_enlist_vu(is, vu1_final, 0);
			/* Neither old nor new edgeuse need further handling */
			break;
		}
	}

out:
	if(eutab.magic)  nmg_tbl( &eutab, TBL_FREE, (long *)0 );
	if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
		rt_log("nmg_isect_line2_edgegeom2p(eg1=x%x, fu1=x%x) ret=%d END\n",
			eg1, fu1, ret);
	}
	return ret;
}

/*
 *			N M G _ I S E C T _ L I N E 2 _ F A C E 2 P
 *
 *  The line is provided by the caller, and lies in the plane of both
 *  face fu1 and face fu2.
 *  We are concerned only with intersection with fu1 here.
 *  See the comment in nmg_isect_two_generic_faces() for details
 *  on the constraints on this ray, and the algorithm.
 *
 *  In some cases, the line actually represents an edge_geometry.
 *
 *  Called by nmg_isect_edge2p_face2p().
 *
 *  Return -
 *	number of edges broken
 */
int
nmg_isect_line2_face2p(is, fu1, eu2, line_eutab)
struct nmg_inter_struct	*is;
struct faceuse		*fu1;
struct edgeuse		*eu2;		/* optional: edge of line */
struct nmg_ptbl		*line_eutab;	/* optional */
{
	struct loopuse		*lu1;
	int			nbreak = 0;
	struct model		*m;
	unsigned char		*tags;

	NMG_CK_INTER_STRUCT(is);
	NMG_CK_FACEUSE(fu1);
	if( eu2 )  NMG_CK_EDGEUSE(eu2);
	if( line_eutab )  NMG_CK_PTBL(line_eutab);
	m = fu1->s_p->r_p->m_p;
	NMG_CK_MODEL(m);

	if (rt_g.NMG_debug & DEBUG_POLYSECT)
		rt_log("nmg_isect_line2_face2p(, fu1=x%x)\n", fu1);

	/* Allocate map of edgegeom's visited */
	tags = (unsigned char *)rt_calloc( 2*m->maxindex+1, 1, "nmg_isect_line2_face2p() tags[]" );

	if( fu1->orientation != OT_SAME )  rt_bomb("nmg_isect_line2_face2p() fu1 not OT_SAME\n");

	/* XXX Check that line lies in plane of face */
	/* XXX Distance from start point to plane within tol? */

    	if (rt_g.NMG_debug & (DEBUG_POLYSECT|DEBUG_FCUT)
    	    && rt_g.NMG_debug & DEBUG_PLOTEM) {
    	    	/* XXX This routine is a real weakie */
    	    	nmg_plot_ray_face("face", is->pt, is->dir, fu1);
    	}

	/* Project the intersect line into 2D.  Build matrix first. */
	nmg_isect2d_prep( is, &fu1->l.magic );
	/* XXX Need subroutine for this!! */
	MAT4X3PNT( is->pt2d, is->proj, is->pt );
	MAT4X3VEC( is->dir2d, is->proj, is->dir );

	if( rt_g.NMG_debug & DEBUG_VERIFY )  {
		nmg_ck_face_worthless_edges( fu1 );
		nmg_fu_touchingloops(fu1);
		nmg_region_v_unique( fu1->s_p->r_p, &is->tol );
	}
	/* Split all edges that cross the line of intersection */
	for( RT_LIST_FOR( lu1, loopuse, &fu1->lu_hd ) )  {
		struct edgeuse	*eu1;

		if( RT_LIST_FIRST_MAGIC( &lu1->down_hd ) == NMG_VERTEXUSE_MAGIC )  {
			struct vertexuse	*vu1;
			/* Intersect line with lone vertex vu1 */
			vu1 = RT_LIST_FIRST( vertexuse, &lu1->down_hd );
			NMG_CK_VERTEXUSE(vu1);
			nmg_isect_line2_vertex2( is, vu1, fu1 );
			/* nbreak is not incremented for a vert on the line */
			continue;
		}
		for( RT_LIST_FOR( eu1, edgeuse, &lu1->down_hd ) )  {
			struct edge_g	*eg1;
			/* intersect line with eu1 */
			eg1 = eu1->e_p->eg_p;
			/* If this eu's eg has been seen before, nothing more to do */
			if( eg1 && !NMG_INDEX_FIRST_TIME(tags, eg1) )  continue;

			nbreak += nmg_isect_line2_edgegeom2p( is, eu1, fu1, eu2, line_eutab );

			if( rt_g.NMG_debug & DEBUG_VERIFY )  {
				nmg_fu_touchingloops(fu1);
				nmg_region_v_unique( fu1->s_p->r_p, &is->tol );
			}
		}
	}

	if( rt_g.NMG_debug & DEBUG_VERIFY )  {
		nmg_fu_touchingloops(fu1);
		nmg_region_v_unique( fu1->s_p->r_p, &is->tol );
	}

do_ret:
	rt_free( (char *)tags, "nmg_isect_line2_face2p() tags[]");
	if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
		rt_log("nmg_isect_line2_face2p(fu1=x%x) END nbreak=%d\n", fu1, nbreak);
	}
	return nbreak;
}

/*
d3280 1
d3327 1
a3327 1
nmg_isect_two_face3pNEW( is, fu1, fu2 )
d3344 1
a3344 1
		rt_log("nmg_isect_two_face3pNEW( fu1=x%x, fu2=x%x )  START12\n", fu1, fu2);
a3402 1
#if HEART
a3403 7
#else
	/* XXX Should these guys be made to share edge geometry? */
	nmg_edgeuse_on_line_tabulate( &on_line, &fu2->l.magic,
		is->pt, is->dir, &(is->tol) );
	(void)nmg_isect_line2_face2p(is, fu1, 0, &on_line);
	(void)nmg_tbl( &on_line, TBL_FREE, 0 );
#endif
d3416 1
a3416 1
	    	rt_log("nmg_isect_two_face3pNEW(fu1=x%x, fu2=x%x) vert_lists A:\n", fu1, fu2);
d3422 1
a3422 1
		rt_log("nmg_isect_two_face3pNEW( fu1=x%x, fu2=x%x )  START21\n", fu1, fu2);
a3433 1
#if HEART
a3434 6
#else
	nmg_edgeuse_on_line_tabulate( &on_line, &fu1->l.magic,
		is->pt, is->dir, &(is->tol) );
	(void)nmg_isect_line2_face2p(is, fu2, 0, &on_line);
	(void)nmg_tbl( &on_line, TBL_FREE, 0 );
#endif
d3447 1
a3447 1
	    	rt_log("nmg_isect_two_face3pNEW(fu1=x%x, fu2=x%x) vert_lists B:\n", fu1, fu2);
d3458 1
a3458 1
		rt_log("nmg_isect_two_face3pNEW( fu1=x%x, fu2=x%x )  MIDDLE\n", fu1, fu2);
d3494 1
a3494 1
		rt_log("nmg_isect_two_face3pNEW( fu1=x%x, fu2=x%x )  END\n", fu1, fu2);
d3602 1
a3602 1
		nmg_isect_two_face3pNEW( &bs, fu1, fu2 );
d3925 1
a3925 1
	/* Note the ray that contains this edge.  For debug in nmg_isect_edge3p_face3p() */
d3937 1
a3937 1
		(void)nmg_isect_edge3p_face3p( is, eu1, fu2 );
d4136 1
a4136 1
			(void)nmg_isect_loop3p_face3p( &is, lu2, fu1 );
d4143 1
a4143 1
			nmg_isect_edge3p_face3p( &is, eu2, fu1 );
@


10.177
log
@Added more debugging prints
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.176 94/07/03 20:16:17 mike Exp Locker: mike $ (ARL)";
d4705 1
a4705 1
	long		*flags;
a4741 7
	/* XXX this isn't true for non-3-manifold geometry! */
	if( RT_LIST_IS_EMPTY( &s1->fu_hd ) ||
	    RT_LIST_IS_EMPTY( &s2->fu_hd ) )  {
		rt_log("ERROR:shells must contain faces for boolean operations.");
		return;
	}

d4747 2
a4748 1
	flags = (long *)rt_calloc( s1->r_p->m_p->maxindex, sizeof(long),
d4791 3
@


10.176
log
@Added nmg_is_eu_on_line3().
Changed unexpected colinearity discovery from fatal error to recoverable
error.
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.175 94/07/02 03:12:16 mike Exp Locker: mike $ (ARL)";
d3685 10
@


10.175
log
@Try to cary on.
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.174 94/07/02 03:00:59 mike Exp Locker: mike $ (ARL)";
d3644 2
a3645 1
				rt_bomb("nmg_isect_line2_face2pNEW() edge_g not shared, geometry says lines are colinear.  Unresolvable inconsistency.\n");
d3657 1
d3922 33
d4009 10
a4018 8
		/* XXX Should call nmg_is_eu_on_line3() as double-check */
#if 0
rt_log("Wow!  Found shared edge on_eu=x%x\n", on_eu);
		VPRINT("isect ray is->pt ", is->pt);
		VPRINT("on_eu   eg->e_pt ", on_eu->e_p->eg_p->e_pt);
		VPRINT("isect ray is->dir", is->dir);
		VPRINT("on_eu   eg->e_dir", on_eu->e_p->eg_p->e_dir);
#endif
@


10.174
log
@Replaced intersecting of lone vertices (self-loops)
with a call to nmg_break_eg_on_v().
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.173 94/07/02 02:40:24 mike Exp Locker: mike $ (ARL)";
d3659 1
d3663 6
@


10.173
log
@rt_2line3colinear() added.
Added double check for eg1 colinear to on_eg.
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.172 94/07/01 23:36:45 mike Exp Locker: mike $ (ARL)";
d3858 9
d3900 1
@


10.172
log
@Moved stuff to plane.c
Added 'tol' arg to nmg_find_edge_between_2fu()
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.171 94/07/01 21:43:17 mike Exp Locker: mike $ (ARL)";
d60 1
d3328 2
d3452 4
d3475 1
d3477 54
d3644 1
a3644 1
				rt_bomb("nmg_isect_lien2_face2pNEW() edge_g not shared, geometry says lines are colinear.  Unresolvable inconsistency.\n");
d3650 12
@


10.171
log
@If first geometry check gives an inconsistent answer, let the second
geometry check resolve the ambiguity.
Fixes m11 test.
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.170 94/07/01 20:36:29 mike Exp Locker: mike $ (ARL)";
a60 15
/* XXX move to raytrace.h */
RT_EXTERN(double		rt_dist_pt3_pt3, (CONST point_t a, CONST point_t b));

/* XXX move to plane.c */
double
rt_dist_pt3_pt3( a, b )
CONST point_t	a;
CONST point_t	b;
{
	vect_t	diff;

	VSUB2( diff, a, b );
	return MAGNITUDE( diff );
}

d3880 1
a3880 1
	if( (on_eu = nmg_find_edge_between_2fu(fu1, fu2)) )  {
@


10.170
log
@When breaking
an edge in fu1 at the intersection point ("hit_pt") with the fu1/fu2
intersection line, and there is no existing vertex for that point, and
there are edges in fu2 that line on the intersection line (and in this
case happen to cross the hit_pt), just dropping an OT_BOOLPLACE
self-loop into fu2 isn't the best thing to do, because there is the risk
that intersections might not be done later.  I've written
nmg_break_eg_on_v() to take care of the business right away.
That fixed m13 and m15.
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.169 94/07/01 15:44:17 mike Exp Locker: mike $ (ARL)";
d61 3
d1127 2
d1131 1
d1133 3
d3309 68
d3434 1
a3434 32
		VPRINT("vu ", vu->v_p->vg_p->coord);
		VPRINT("hit", hit_v->vg_p->coord);
		rt_log("dist vu-hit=%g, equal=%d\n",
			rt_dist_pt3_pt3(vu->v_p->vg_p->coord,
				hit_v->vg_p->coord),
			rt_pt3_pt3_equal(vu->v_p->vg_p->coord,
				hit_v->vg_p->coord, tol)
		    );
		rt_log("eg1: line/ vu dist=%g, hit dist=%g\n",
			rt_dist_line3_pt3( eg1->e_pt, eg1->e_dir, vu->v_p->vg_p->coord ),
			rt_dist_line3_pt3( eg1->e_pt, eg1->e_dir, hit_v->vg_p->coord ) );
		rt_log("eg2: line/ vu dist=%g, hit dist=%g\n",
			rt_dist_line3_pt3( eg2->e_pt, eg2->e_dir, vu->v_p->vg_p->coord ),
			rt_dist_line3_pt3( eg2->e_pt, eg2->e_dir, hit_v->vg_p->coord ) );
		nmg_pr_eg(eg1, 0);
		nmg_pr_eg(eg2, 0);

		if( rt_dist_pt3_pt3(vu->v_p->vg_p->coord,
		      hit_v->vg_p->coord) < 10 * tol->dist )  {
			struct edgeuse	*eu0;
			rt_log("NOTICE: The intersection of two lines has resulted in 2 different intersect points\n");
			rt_log("  Since the two points are 'close', they are being fused.\n");

			/* See if there is an edge between them */
			eu0 = nmg_findeu(hit_v, v, (struct shell *)NULL,
				(struct edgeuse *)NULL, 0);
			if( eu0 )  {
				rt_log("DANGER: a 0-length edge is being created eu0=x%x\n", eu0);
			}

			nmg_jv(hit_v, v);
			/* XXX Kill all uses of the 0-length edge? */
a3435 1
		}
d3679 11
a3689 4
				/* XXX What if hit_v already set, differently? */
				if( hit_v && hit_v != vu1a->v_p ) rt_bomb("nmg_isect_line2_face2pNEW() hitv != vu1a\n");
				hit_v = vu1a->v_p;
				goto hit_a;
d3692 11
a3702 3
				if( hit_v && hit_v != vu1b->v_p ) rt_bomb("nmg_isect_line2_face2pNEW() hitv != vu1b\n");
				hit_v = vu1b->v_p;
				goto hit_b;
d3721 4
d3730 4
@


10.169
log
@Pulled out nmg_inter_2eg() to do topology search.
This version runs BigWedge tests m12 and m16!
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.168 94/07/01 15:01:52 mike Exp Locker: mike $ (ARL)";
d114 3
d430 1
a430 1
long			*assoc_use;
d1071 64
d3434 1
d3589 1
a3589 5
		if( hit_v && !rt_pt3_pt3_equal( hit3d, hit_v->vg_p->coord, &(is->tol) ) )  {
			rt_log("NOTICE: hit_v and hit3d don't agree, using hit_v.\n");
			VPRINT("\thit3d", hit3d);
			VPRINT("\thit_v", hit_v->vg_p->coord);

d3591 1
a3591 1
			/* Just in case, make things consistent */
d3690 9
@


10.168
log
@Added heuristic for dealing with 2 lines that intersect in more than 1
vertex.
It works, but isn't helpful.

@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.167 94/07/01 01:26:32 mike Exp Locker: mike $ (ARL)";
d3241 2
a3242 2
struct vertexuse *
nmg_search_v_eg( eu, second, eg1, eg2, hit_vu, tol )
d3247 1
a3247 1
struct vertexuse		*hit_vu;	/* often will be NULL */
d3281 2
a3282 2
		/* Both edge_g's have been seen at 'vu', this is a hit. */
		if( !hit_vu )  return vu;
d3284 2
a3285 2
		/* Is it a different vertex than hit_vu? */
		if( hit_vu->v_p == v )  return hit_vu;
d3288 2
a3289 2
		rt_log("vu=x%x, v=x%x; hit_vu=x%x, v=x%x\n",
			vu, v, hit_vu, hit_vu->v_p );
d3291 1
a3291 1
		VPRINT("hit", hit_vu->v_p->vg_p->coord);
d3294 1
a3294 1
				hit_vu->v_p->vg_p->coord),
d3296 1
a3296 1
				hit_vu->v_p->vg_p->coord, tol)
d3300 1
a3300 1
			rt_dist_line3_pt3( eg1->e_pt, eg1->e_dir, hit_vu->v_p->vg_p->coord ) );
d3303 1
a3303 1
			rt_dist_line3_pt3( eg2->e_pt, eg2->e_dir, hit_vu->v_p->vg_p->coord ) );
d3308 1
a3308 1
		      hit_vu->v_p->vg_p->coord) < 10 * tol->dist )  {
d3314 1
a3314 1
			eu0 = nmg_findeu(hit_vu->v_p, v, (struct shell *)NULL,
d3320 1
a3320 1
			nmg_jv(hit_vu->v_p, v);
d3322 1
a3322 1
			return hit_vu;
d3327 1
a3327 1
	return hit_vu;
d3331 40
a3420 1
		struct vertexuse	*hit_vu = (struct vertexuse *)NULL;
d3495 1
a3495 10
			for( eu1 = (struct edgeuse **)NMG_TBL_LASTADDR(eu1_list);
			     eu1 >= (struct edgeuse **)NMG_TBL_BASEADDR(eu1_list); eu1--
			)  {
				NMG_CK_EDGEUSE(*eu1);
				if( (*eu1)->e_p->eg_p != *eg1 )  continue;
				/* Both verts of *eu1 lie on line *eg1 */
				hit_vu = nmg_search_v_eg( *eu1, 0, *eg1, is->on_eg, hit_vu, &(is->tol) );
				hit_vu = nmg_search_v_eg( *eu1, 1, *eg1, is->on_eg, hit_vu, &(is->tol) );
			}
			/* hit_vu will be non-NULL if there is 1 topological intersection */
d3502 1
a3502 1
			if( hit_vu )  {
d3504 1
a3504 2
				/* XXX There could be many vu's with same v, due to acordian pleats */
				nmg_enlist_vu(is, hit_vu, 0);
d3520 5
a3524 5
		/* Consistency check between geometry, and hit_vu. */
		if( hit_vu && !rt_pt3_pt3_equal( hit3d, hit_vu->v_p->vg_p->coord, &(is->tol) ) )  {
			rt_log("NOTICE: hit_vu and hit3d don't agree, using hit_vu.\n");
			VPRINT("\thit3d ", hit3d);
			VPRINT("\thit_vu", hit_vu->v_p->vg_p->coord);
d3526 1
d3528 2
a3529 2
			VMOVE(hit3d, hit_vu->v_p->vg_p->coord);
			nmg_get_2d_vertex( hit2d, hit_vu->v_p, is, fu1 );
a3531 2
		if( hit_vu )  hit_v = hit_vu->v_p;

d3617 1
d3672 1
d3687 1
@


10.167
log
@ when a lone vertexuse (typically
OT_BOOLPLACE) lies on the line of face/face intersection, the edges of
the faces also on the line need to be broken on that vertex.
added two extra blocks of code to the "Don't forget to do self loops"
section at the bottom of nmg_isect_line2_face2pNEW().
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.166 94/07/01 00:25:45 mike Exp Locker: mike $ (ARL)";
d61 12
d3242 1
a3242 1
nmg_search_v_eg( eu, second, eg1, eg2, hit_vu )
d3248 1
d3250 1
a3250 1
	CONST struct vertex	*v;
d3259 1
d3292 7
a3298 1
		rt_log("eg1: vu dist=%g, hit dist=%g\n",
d3301 1
a3301 1
		rt_log("eg2: vu dist=%g, hit dist=%g\n",
d3306 19
d3462 2
a3463 2
				hit_vu = nmg_search_v_eg( *eu1, 0, *eg1, is->on_eg, hit_vu );
				hit_vu = nmg_search_v_eg( *eu1, 1, *eg1, is->on_eg, hit_vu );
@


10.166
log
@Well, this version works better.
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.165 94/06/30 23:50:39 mike Exp Locker: mike $ (ARL)";
d3310 1
d3318 1
d3326 1
a3326 1
		rt_log("nmg_isect_line2_face2pNEW(, fu1=x%x)\n", fu1);
a3361 1
				register struct edgeuse	**eu2;
a3470 1
			struct edgeuse		*new_eu;
d3580 44
d3625 2
a3626 1
		/* Only potential result is a use of vu1 added to the other face */
d3628 1
@


10.165
log
@Newly created edgeuses are added to list.
Lists are released when done.
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.164 94/06/30 22:33:48 mike Exp Locker: mike $ (ARL)";
d1998 1
d2000 1
d2002 2
d2036 2
d2118 1
a2131 1
#if !HEART
d2144 8
d2155 1
a2155 1
	nmg_isect_line2_face2pNEW( is, fu2 );
d2160 1
a2160 1
	/* Now, run line through fu1, if eu1 is not wire */
d2164 1
a2164 1
		nmg_isect_line2_face2pNEW( is, fu1 );
d2172 1
d2174 1
d2201 2
d3301 1
a3301 1
nmg_isect_line2_face2pNEW( is, fu1 )
d3304 2
a3306 1
	struct nmg_ptbl		eu_list;
d3320 2
a3331 3
	/* Build list of all edgeuses in fu1 */
	nmg_edgeuse_tabulate( &eu_list, &fu1->l.magic );

d3333 1
a3333 1
	/* XXX This could be more cheaply done by cooking down eu_list */
d3356 2
a3357 2
			for( eu1 = (struct edgeuse **)NMG_TBL_BASEADDR(&eu_list);
			     eu1 <= (struct edgeuse **)NMG_TBL_LASTADDR(&eu_list);
d3363 1
d3365 2
a3366 2
				for( eu2 = eu1+1;
				     eu2 <= (struct edgeuse **)NMG_TBL_LASTADDR(&eu_list);
d3371 4
a3374 2
					/*  Perform intersection.
					 *  New edgeuses are added to eu_list.
a3375 2
					if( nmg_find_fu_of_eu(*eu1) ==
					    nmg_find_fu_of_eu(*eu2) )  continue;
d3377 1
a3377 1
						fu1, is, &eu_list, &eu_list);
d3416 2
a3417 2
			for( eu1 = (struct edgeuse **)NMG_TBL_LASTADDR(&eu_list);
			     eu1 >= (struct edgeuse **)NMG_TBL_BASEADDR(&eu_list); eu1--
d3465 2
a3466 2
		for( eu1 = (struct edgeuse **)NMG_TBL_LASTADDR(&eu_list);
		     eu1 >= (struct edgeuse **)NMG_TBL_BASEADDR(&eu_list); eu1--
d3550 1
a3550 1
				nmg_tbl( &eu_list, TBL_INS_UNIQUE, &new_eu->l.magic );
a3582 1
	nmg_tbl( &eu_list, TBL_FREE, (long *)0 );
d3608 2
d3659 4
d3674 1
a3674 1
	nmg_isect_line2_face2pNEW(is, fu1);
d3713 1
a3713 1
	nmg_isect_line2_face2pNEW(is, fu2);
d3771 2
@


10.164
log
@set the geometric value (hit3d) to the value from the
topology in this case, and propagate that through the rest of the
routine, for consistency.
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.163 94/06/30 21:56:32 mike Exp Locker: mike $ (ARL)";
d3451 1
d3530 3
a3532 1
				vu1_midpt = nmg_ebreak(hit_v, *eu1)->vu_p;
d3564 2
@


10.163
log
@Finally, sensible error messages out of nmg_search_v_eg().
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.162 94/06/30 20:00:00 mike Exp Locker: mike $ (ARL)";
d3434 7
a3440 4
			rt_log("ERROR? hit_vu and hit3d don't agree!\n");
			VPRINT("hit3d ", hit3d);
			VPRINT("hit_vu", hit_vu->v_p->vg_p->coord);
			/* XXX Now what? */
d3484 1
d3489 1
@


10.162
log
@I changed the calling sequence to nmg_face_cutjoin() to accept and
return the edge_g pointer of the intersection line.
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.161 94/06/30 16:12:09 mike Exp Locker: mike $ (ARL)";
d2547 1
a2547 1
 *  Given two pointer tables filled with edgeuses representing two different
d3204 5
a3208 2
 *  Report if any edgeuse referrs to edge_g "eg".
 *  If found, and hit_vu non-NULL, bomb.
d3212 5
a3216 3
nmg_search_v_eg( vu, eg, hit_vu )
struct vertexuse		*vu;
CONST struct edge_g		*eg;
d3220 4
a3223 1
	CONST struct vertexuse	*vu1;
d3225 10
a3235 2
	NMG_CK_EDGE_G(eg);

d3240 2
a3241 1
		CONST struct edgeuse	*eu;
a3242 1
		if( vu1 == vu )  continue;
d3244 4
a3247 2
		eu = vu1->up.eu_p;
		if( eu->e_p->eg_p != eg )  continue;
d3249 2
a3250 4
		/* 'vu' is shared by an edge along 'eg' */
		if( hit_vu )  {
			/* Is it a different vertex than hit_vu? */
			if( hit_vu->v_p == v )  continue;
d3252 17
a3268 8
			/* Yes, this "can't happen" */
			rt_log("vu=x%x, v=x%x; hit_vu=x%x, v=x%x\n",
				vu, v, hit_vu, hit_vu->v_p );
			VPRINT("vu ", vu->v_p->vg_p->coord);
			VPRINT("hit", hit_vu->v_p->vg_p->coord);
			rt_bomb("nmg_search_v_eg() two different vertices for intersect point?\n");
		}
		hit_vu = vu;
d3403 2
a3404 2
				hit_vu = nmg_search_v_eg( (*eu1)->vu_p, is->on_eg, hit_vu );
				hit_vu = nmg_search_v_eg( RT_LIST_PNEXT_CIRC(edgeuse, (*eu1))->vu_p, is->on_eg, hit_vu );
@


10.161
log
@I upgraded nmg_isect_edge2p_face2p() to call the new routine
nmg_isect_line2_face2pNEW() and the numbered tests still work.

@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.160 94/06/30 15:47:25 mike Exp Locker: mike $ (ARL)";
a60 3
/* XXX move to raytrace.h (from nmg_info.c) */
RT_EXTERN(CONST struct edgeuse *nmg_find_edge_between_2fu, (CONST struct faceuse *fu1, CONST struct faceuse *fu2));

d2179 1
a2179 1
	nmg_face_cutjoin(&vert_list1, &vert_list2, fu1, fu2, is->pt, is->dir, &is->tol);
d3239 2
d3377 1
d3687 1
a3687 1
	nmg_face_cutjoin(&vert_list1, &vert_list2, fu1, fu2, is->pt, is->dir, &is->tol);
@


10.160
log
@Added support needed for coplanar face stuff, next.
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.159 94/06/30 02:12:33 mike Exp Locker: mike $ (ARL)";
d2036 1
d2128 1
d2139 1
d2142 4
d2147 1
d2152 2
a2153 2
#if 0
		total_splits += nmg_isect_line2_face2p( is, fu1, eu1, &eutab );
@


10.159
log
@New line intersects line version of nmg_isect_line2_face2pNEW().
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.158 94/06/29 23:44:42 mike Exp Locker: mike $ (ARL)";
d3297 5
a3301 2
			/* This edge_g is known to be ON the face/face line.
			 * Enlist all the vertexuses from edgeuses using on_eg.
d3306 3
a3308 2
			for( eu1 = (struct edgeuse **)NMG_TBL_LASTADDR(&eu_list);
			     eu1 >= (struct edgeuse **)NMG_TBL_BASEADDR(&eu_list); eu1--
d3310 1
d3313 17
@


10.158
log
@Added use of nmg_find_edge_between_2fu().
@
text
@d1 1
d50 1
a50 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.157 94/06/27 23:01:12 mike Exp Locker: mike $ (ARL)";
d79 1
d3160 344
d3551 1
d3554 2
d3564 5
d3584 3
d3592 1
d3623 3
d3630 1
@


10.157
log
@New versions of nmg_get_2d_vertex(), and nmg_isect2d_prep(). These new
routines can handle 2-d projection of points on wire edgeuses as well as
on face loops.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.156 94/04/25 03:13:01 mike Exp Locker: mike $ (ARL)";
d60 3
d2734 3
a2736 1
	if( fabs(VDOT_2D(is->dir2d, eg_dir2d)) < is->tol.para )
d3166 2
d3178 1
d3200 17
a3225 5

    	if (rt_g.NMG_debug & (DEBUG_POLYSECT|DEBUG_FCUT|DEBUG_MESH)
    	    && rt_g.NMG_debug & DEBUG_PLOTEM) {
    	    	nmg_pl_2fu( "Iface%d.pl", 0, fu1, fu2, 0 );
    	}
@


10.156
log
@(1) Intersection of vertex with line changed to enlist vertexuses,
and to make a comprehensive search.
(2) All edgeuses on a line of intersection (from the other face)
are tabulated, in an attempt to do a better job linking them
up with intersections made in the other face.
All this code is highly suspect.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.155 94/04/24 20:41:51 mike Exp Locker: mike $ (ARL)";
d82 1
a82 1
	struct face	*face;		/* face of 2d projection plane */
d97 2
a98 1
RT_EXTERN(void		nmg_isect2d_prep, (struct nmg_inter_struct *is, struct face *f1));
d275 2
d279 3
a281 3
nmg_get_2d_vertex( v2d, v, is, fu )
point_t		v2d;		/* a 3-tuple */
struct vertex	*v;
d283 1
a283 1
CONST struct faceuse	*fu;	/* for plane equation */
d288 1
d295 1
a295 1
		nmg_isect2d_prep( is, fu->f_p );
d298 16
a313 4
	if( fu->f_p != is->face )  {
		rt_log("nmg_get_2d_vertex(,fu=%x) f=x%x, is->face=%x\n",
			fu, fu->f_p, is->face);
		rt_bomb("nmg_get_2d_vertex:  face mis-match\n");
a314 1
	NMG_CK_FACEUSE(fu);
d317 2
a318 1
		rt_log("nmg_get_2d_vertex: v=x%x, fu=x%x, null vg_p\n", v, fu);
d367 1
d377 2
a378 3
			rt_log("nmg_get_2d_vertex(,fu=%x) f=x%x, is->face=%x\n",
				fu, fu->f_p, is->face);
			PLPRINT("is->face N", is->face->fg_p->N);
a408 1
 * f1 & is->face should become a (long *) to track geom associativity.
d411 1
a411 1
nmg_isect2d_prep( is, f1 )
d413 1
a413 1
struct face		*f1;
a423 1
	NMG_CK_FACE(f1);
d425 9
a433 1
	if( is->vert2d && f1 == is->face )  return;	/* Already prepped */
d438 1
a438 13
	fg = f1->fg_p;
	NMG_CK_FACE_G(fg);
	is->face = f1;
	if( f1->flip )  {
		VREVERSE( n, fg->N );
		n[3] = -fg->N[3];
	} else {
		HMOVE( n, fg->N );
	}
	if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
		rt_log("nmg_isect2d_prep(f=x%x) flip=%d\n", f1, f1->flip);
		PLPRINT("N", n);
	}
a439 2
	m = nmg_find_model( &f1->l.magic );

d443 3
a445 15
	/*
	 *  Rotate so that f1's N vector points up +Z.
	 *  This places all 2D calcuations in the XY plane.
	 *  Translate so that f1's centroid becomes the 2D origin.
	 *  Reasoning:  no vertex should be favored by putting it at
	 *  the origin.  The "desirable" floating point space in the
	 *  vicinity of the origin should be used to best advantage,
	 *  by centering calculations around it.
	 */
	VSET( to, 0, 0, 1 );
	mat_fromto( is->proj, n, to );
	VADD2SCALE( centroid, f1->max_pt, f1->min_pt, 0.5 );
	MAT4X3PNT( centroid_proj, is->proj, centroid );
	centroid_proj[Z] = n[3];	/* pull dist from origin off newZ */
	MAT_DELTAS_VEC_NEG( is->proj, centroid_proj );
d447 55
d524 1
a524 1
	is->face = (struct face *)NULL;
d654 1
a654 1
	nmg_isect2d_prep( is, fu2->f_p );
d3100 1
a3100 1
	nmg_isect2d_prep( is, fu1->f_p );
d3569 1
a3569 1
		rt_bomb("nmg_isect_edge3p_edge3p() colinear case.  Write some code here.\n");
d3571 1
a3571 1
		nmg_isect2d_prep( is, (struct face *)eu1->e_p );
a3572 1
		/* XXX The support for this won't quite work yet */
@


10.155
log
@Neatness.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.154 94/04/24 18:41:51 mike Exp Locker: mike $ (ARL)";
d110 1
a110 1
RT_EXTERN(struct vertexuse *	nmg_isect_vert2p_face2p, (struct nmg_inter_struct *is,
d159 8
d573 2
a574 1
 *  plane of a face.
d576 1
a576 1
 *  It it intersects one of the edges of the face, break the edge there.
d579 2
a580 7
 *  Since this is an intersection of a vertex, no loop cut/join action
 *  is needed, since the only possible actions are fusing vertices
 *  and breaking edges into two edges about this vertex.
 *  No vertexuses need to be added to the intersect list.
 *
 *  Returns -
 *	vu2	dual of vu1.  vu2 is in fu2.
d582 1
a582 1
struct vertexuse *
d592 1
a599 4
	/* check the topology first */	
	if( vu2 = nmg_find_v_in_face(vu1->v_p, fu2) )  return vu2;

	/* topology didn't say anything, check with the geometry. */
d605 1
a605 1
	/* For every edge and vert in face, check geometric intersection */
d612 5
a616 1
			if( vu1->v_p == vu2->v_p )  return vu2;
d621 3
a623 2
				nmg_ck_v_in_2fus(vu1->v_p, nmg_find_fu_of_vu(vu1), fu2, &is->tol);
				return vu2;
d629 6
a634 1
			/* If there is an intersection, we are done */
d636 3
a638 1
				return new_eu->vu_p;
d643 4
a646 3
	/* The vertex lies in the face, but touches nothing.  Place marker */
	if (rt_g.NMG_debug & DEBUG_POLYSECT)
	    	VPRINT("Making vertexloop", pt);
d648 5
a652 3
	lu2 = nmg_mlv(&fu2->l.magic, vu1->v_p, OT_BOOLPLACE);
	nmg_loop_g( lu2->l_p, &is->tol );
	return RT_LIST_FIRST( vertexuse, &lu2->down_hd );
a708 4
	 *
	 *  Intersect this point with all the edges of the face.
	 *  Note that no nmg_tbl() calls will be done during vert2p_face2p,
	 *  which is exactly what is needed here.
d710 1
a710 4
	vup = nmg_isect_vert2p_face2p( is, vu, fu );
	NMG_CK_VERTEXUSE(vup);

	nmg_enlist_vu( is, vu, vup );
d1037 1
a1037 1
nmg_isect_2colinear_edge2p( eu1, eu2, fu, is )
d1042 2
d1055 2
d1071 4
d1282 1
a1282 1
		if( nmg_isect_2colinear_edge2p( eu1, eu2, fu2, is ) > 2 )  {
d2078 2
a2079 2
		nmg_enlist_vu( is, vu1a, nmg_isect_vert2p_face2p( is, vu1a, fu2 ) );
		nmg_enlist_vu( is, vu1b, nmg_isect_vert2p_face2p( is, vu1b, fu2 ) );
d2083 1
a2083 1
	total_splits = nmg_isect_line2_face2p( is, fu2, eu1->e_p, &eutab );
d2088 5
a2092 1
		total_splits += nmg_isect_line2_face2p( is, fu1, eu1->e_p, &eutab );
d2175 2
a2194 1
	/* XXX I think this could be moved before the label, for efficiency */
d2206 2
d2245 2
d2474 2
a2475 3
	nmg_get_2d_vertex( v2d, vu1->v_p, is, fu1 );

	if( rt_distsq_line2_point2( is->pt2d, is->dir2d, v2d ) > is->tol.dist_sq )
d2555 3
a2557 2
	/* Bypass error check in nmg_enlist_vu() */
	if( nmg_find_s_of_vu(vu1a) == nmg_find_s_of_vu(vu1b) )  vu1b = 0;
d2594 1
a2594 1
nmg_isect_line2_edgegeom2p( is, eu1, fu1, e, line_eutab )
d2598 1
a2598 1
struct edge		*e;		/* optional: edge generating the line */
d2625 1
a2625 1
	if( e )  NMG_CK_EDGE(e);
d2632 1
a2632 1
		rt_log("nmg_isect_line2_edgegeom2p(eu1=x%x, fu1=x%x)  START\n\teg1=x%x, e=x%x, line_eutab=x%x\n",
d2634 1
a2634 1
			eg1, e, line_eutab);
d2638 1
a2638 1
	if( e && e->eg_p == eg1 )  {
d2640 1
a2640 1
			rt_log("\tThis edge generated the line.  Enlisting.\n");
d2675 3
a2677 2
		rt_log(" code=%d, dist[0]=%g\n", code, dist[0]);
		nmg_pr_ptbl("Edgeuse table", &eutab, 1);
d2717 3
d2724 22
a2745 5
		for( eup = (struct edgeuse **)NMG_TBL_LASTADDR(&eutab);
		     eup >= (struct edgeuse **)NMG_TBL_BASEADDR(&eutab); eup--
		)  {
			vu1a = (*eup)->vu_p;
			vu1b = RT_LIST_PNEXT_CIRC( edgeuse, (*eup) )->vu_p;
d2749 1
a2749 1
		ret = 0;
d3013 1
a3013 1
nmg_isect_line2_face2p(is, fu1, e, line_eutab)
d3016 1
a3016 1
struct edge		*e;		/* optional: edge of line */
d3026 1
a3026 1
	if( e )  NMG_CK_EDGE(e);
d3079 1
a3079 1
			nbreak += nmg_isect_line2_edgegeom2p( is, eu1, fu1, e, line_eutab );
d3117 1
d3156 8
a3163 2
	/* XXX Is an optimization based upon the return code here possible? */
	(void)nmg_isect_line2_face2p(is, fu1, 0, 0);
d3185 3
d3194 4
a3197 1
	(void)nmg_isect_line2_face2p(is, fu2, 0, 0);
d3419 2
d3424 1
d3521 1
a3521 1
		(void)nmg_isect_2colinear_edge2p( eu1, eu2, eu1->e_p, is );
@


10.154
log
@Added a debug print.
Eliminated NEWLINE define
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.153 94/04/23 12:14:00 mike Exp Locker: mike $ (ARL)";
d110 2
d3086 2
a3087 2
nmg_fu_touchingloops(fu1);
nmg_fu_touchingloops(fu2);
d3112 2
a3113 2
nmg_fu_touchingloops(fu1);
nmg_fu_touchingloops(fu2);
d3140 2
a3141 2
nmg_fu_touchingloops(fu1);
nmg_fu_touchingloops(fu2);
d3167 4
a3170 4
nmg_fu_touchingloops(fu1);
nmg_fu_touchingloops(fu2);
nmg_region_v_unique( fu1->s_p->r_p, &is->tol );
nmg_region_v_unique( fu2->s_p->r_p, &is->tol );
d3177 2
a3178 2
nmg_fu_touchingloops(fu1);
nmg_fu_touchingloops(fu2);
@


10.153
log
@Moved some junk from nmg_inter.c to nmg_junk.c
@
text
@a0 2
#define NEWLINE 1	/* "New" algorithm:  isect line with 2 faces in 2d */

d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.152 94/04/23 10:54:39 mike Exp Locker: mike $ (ARL)";
a2249 1
 * NEWLINE!
a2539 2
 *  NEWLINE2
 *
d2604 3
a2606 2
		rt_log("nmg_isect_line2_edgegeom2p(eg1=x%x, fu1=x%x) eu1=x%x START\n",
			eg1, fu1, eu1);
a2947 1
 * NEWLINE!
a3052 1
 * NEWLINE!
@


10.152
log
@Added nmg_isect_two_ptbls(), and calling sequence support so that
we can detect (a) when the line generated by an edge is being
intersected with itself, and (b) when there is a topological
intersection point already registered as the intersection of two lines.
@
text
@d51 1
a51 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.151 94/04/23 07:35:04 mike Exp Locker: mike $ (ARL)";
d3385 2
d3574 2
a3575 3
 *  At present, this routine is used for only two purposes:
 *	1)  Handling wire edge -vs- shell intersection,
 *	2)  From nmg_isect_face3p_shell_int(), for "straddling" edges.
d3595 2
a3719 62
}

/*
 *			N M G _ I S E C T _ F A C E 3 P _ S H E L L _ I N T
 *
 *  Intersect all the edges in fu1 that don't lie on any of the faces
 *  of shell s2 with s2, i.e. "interior" edges, where the
 *  endpoints lie on s2, but the edge is not shared with a face of s2.
 *  Such edges wouldn't have been processed by
 *  the NEWLINE version of nmg_isect_two_generic_faces(), so
 *  intersections need to be looked for here.
 *  Fortunately, it's easy to reject everything except edges that need
 *  processing using only the topology structures.
 *
 *  The "_int" at the end of the name is to signify that this routine
 *  does only "interior" edges, and is not a general face/shell intersector.
 */
void
nmg_isect_face3p_shell_int( is, fu1, s2 )
struct nmg_inter_struct	*is;
struct faceuse	*fu1;
struct shell	*s2;
{
	struct shell	*s1;
	struct loopuse	*lu1;
	struct edgeuse	*eu1;

	NMG_CK_INTER_STRUCT(is);
	NMG_CK_FACEUSE(fu1);
	NMG_CK_SHELL(s2);
	s1 = fu1->s_p;
	NMG_CK_SHELL(s1);

	if (rt_g.NMG_debug & DEBUG_POLYSECT)
		rt_log("nmg_isect_face3p_shell_int(, fu1=x%x, s2=x%x) START\n", fu1, s2 );

	for( RT_LIST_FOR( lu1, loopuse, &fu1->lu_hd ) )  {
		NMG_CK_LOOPUSE(lu1);
		if( RT_LIST_FIRST_MAGIC( &lu1->down_hd ) == NMG_VERTEXUSE_MAGIC)
			continue;
		for( RT_LIST_FOR( eu1, edgeuse, &lu1->down_hd ) )  {
			struct edgeuse		*eu2;

			eu2 = nmg_find_matching_eu_in_s( eu1, s2 );
			if( eu2	)  {
rt_log("nmg_isect_face3p_shell_int() eu1=x%x, e1=x%x, eu2=x%x, e2=x%x (nothing to do)\n", eu1, eu1->e_p, eu2, eu2->e_p);
				/*  Whether the edgeuse is in a face, or a
				 *  wire edgeuse, the other guys will isect it.
				 */
				continue;
			}
			/*  vu2a and vu2b are in shell s2, but there is no
			 *  edge running between them in shell s2.
			 *  Create a line of intersection, and go to it!.
			 */
rt_log("nmg_isect_face3p_shell_int(, s2=x%x) eu1=x%x, no eu2\n", s2, eu1);
			nmg_isect_edge3p_shell( is, eu1, s2 );
		}
	}

	if (rt_g.NMG_debug & DEBUG_POLYSECT)
		rt_log("nmg_isect_face3p_shell_int(, fu1=x%x, s2=x%x) END\n", fu1, s2 );
@


10.151
log
@Optimized nmg_isect_two_face2p(), reduced overall runtime by 1/3!
@
text
@d51 1
a51 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.150 94/04/23 07:25:58 mike Exp Locker: mike $ (ARL)";
d167 1
a167 1
		if( is->fu1 && is->fu1->s_p != is->s1 ) rt_bomb("fu1/s1 mismatch\n");
d176 1
a176 1
		if( is->fu2 && is->fu2->s_p != is->s2 ) rt_bomb("fu2/s2 mismatch\n");
d188 7
a194 3
		if( vu->v_p != dualvu->v_p )  rt_bomb("dual vu has different vertex\n");
		if( nmg_find_s_of_vu(dualvu) != duals )  rt_bomb("dual vu shell mis-match\n");
		if( dualfu && nmg_find_fu_of_vu(dualvu) != dualfu) rt_bomb("dual vu has wrong fu\n");
d200 1
a200 1
		if( dualfu->s_p != duals )  rt_bomb("dual fu's shell is not dual's shell?\n");
a2063 1
	nmg_tbl( &eutab, TBL_FREE, (long *)0 );
d2066 1
a2066 1
	total_splits = nmg_isect_line2_face2p( is, &vert_list2, fu2, fu1 );
d2070 2
a2071 2
		total_splits += nmg_isect_line2_face2p( is,
			&vert_list1, fu1, fu2 );
d2076 1
d2125 10
d2431 2
d2435 1
a2435 1
nmg_isect_line2_vertex2( is, list1, vu1, fu1, fu2 )
a2436 1
struct nmg_ptbl		*list1;
a2438 1
struct faceuse		*fu2;
a2442 1
	NMG_CK_PTBL(list1);
a2444 1
	NMG_CK_FACEUSE(fu2);
d2461 82
d2560 7
d2571 1
a2571 1
nmg_isect_line2_edgegeom2p( is, list, eu1, fu1, fu2 )
a2572 1
struct nmg_ptbl		*list;
d2575 2
a2576 1
struct faceuse		*fu2;
a2599 1
	NMG_CK_PTBL(list);
d2602 2
a2603 1
	NMG_CK_FACEUSE(fu2);
a2605 1
	/* Might this be null? */
d2613 18
d2684 2
a2685 2
			rt_log("\tColinearity check *eup=x%x, a=%g, b=%g\n",
				*eup, a, b);
d2739 1
d2742 13
a2759 1
not_colinear:
d2961 2
d2969 1
a2969 1
nmg_isect_line2_face2p(is, list, fu1, fu2)
a2970 1
struct nmg_ptbl		*list;
d2972 2
a2973 1
struct faceuse		*fu2;
a2980 1
	NMG_CK_PTBL(list);
d2982 2
a2983 1
	NMG_CK_FACEUSE(fu2);
d3024 1
a3024 1
			nmg_isect_line2_vertex2( is, list, vu1, fu1, fu2 );
d3035 1
a3035 1
			nbreak += nmg_isect_line2_edgegeom2p( is, list, eu1, fu1, fu2 );
d3113 1
a3113 1
	(void)nmg_isect_line2_face2p(is, &vert_list1, fu1, fu2);
d3141 1
a3141 1
	(void)nmg_isect_line2_face2p(is, &vert_list2, fu2, fu1);
@


10.150
log
@Modified nmg_isect_edge2p_face2p() to intersect
all the edgeuses which share a common edge_geometry.
Modified nmg_isect_two_face2p() to keep a tags array of edge_geometry.
@
text
@d51 1
a51 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.149 94/04/22 10:47:39 mike Exp Locker: mike $ (ARL)";
a2157 1
f1_again:
d2160 1
d2171 1
d2196 1
a2197 1
	bzero( (char *)tags, tagsize );
d2208 1
@


10.149
log
@Breakthrough!  The co-planar face case is the same as the non-coplanar
case:  it should be treated as an infinite line crossing *both* faces.
(One line per edgeuse).
@
text
@d20 2
d51 1
a51 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.148 94/04/22 08:47:54 mike Exp Locker: mike $ (ARL)";
d399 2
d597 3
d608 1
a608 1
			/* Perhaps a 2d routine here? */
d1873 5
a1877 2
 *  This edge represents a line of intersection, and so a
 *  cutjoin/mesh pass will be needed for each one.
d1879 1
a1879 1
 *  XXX eu1 may be a wire edge, in which case there is no face!
d1924 2
d1930 1
a1930 1
	/* fu1 may be null */
a1955 3
	/* Zap 2d cache, we could be switching faces now */
	nmg_isect2d_cleanup(is);

d2037 24
a2060 9
	/* The use of an infinite line through fu2 is essential! */
	/* Put eu1's vu's on the list.  They are the hardest to get
	 * right by geometry. (Needed to fix Test18) */
	/* XXX What about join operations on colinear edgeuses? */
/* XXX YYY ZZZ What about proper breaking of colinear edgeuses, too! */
/* XXX Can I just enlist them, and let the face cutter deal with it? */
/* XXX Should get list of all eu's on edge_g, and enlist all their vu's! */
	nmg_enlist_vu( is, eu1->vu_p, 0 );
	nmg_enlist_vu( is, RT_LIST_PNEXT_CIRC(edgeuse,eu1)->vu_p, 0 );
d2062 1
a2062 1
	/* Run eu1's line through fu2 */
d2064 1
a2071 1
	/* XXX Should modify caller to tally all eu's sharing this edge_g */
a2072 1

d2112 9
d2127 3
a2129 2
	struct loopuse	*lu;
	struct edgeuse	*eu;
d2131 2
d2137 3
a2142 11
#if 0
	/* r71, r23 are useful demonstrations */
	/* Turn these flags on only for early code debugging */
	rt_g.NMG_debug |= DEBUG_POLYSECT;
	rt_g.NMG_debug |= DEBUG_FCUT;
	rt_g.NMG_debug |= DEBUG_VU_SORT;
	rt_g.NMG_debug |= DEBUG_PLOTEM;
	rt_g.NMG_debug |= DEBUG_INS;
	rt_g.NMG_debug |= DEBUG_FCUT;
#endif

d2146 11
d2159 2
d2162 4
a2165 4
nmg_fu_touchingloops(fu1);
nmg_fu_touchingloops(fu2);
nmg_region_v_unique( fu1->s_p->r_p, &is->tol );
nmg_region_v_unique( fu2->s_p->r_p, &is->tol );
d2175 2
d2178 3
d2184 2
d2196 1
d2198 4
a2201 4
nmg_fu_touchingloops(fu1);
nmg_fu_touchingloops(fu2);
nmg_region_v_unique( fu1->s_p->r_p, &is->tol );
nmg_region_v_unique( fu2->s_p->r_p, &is->tol );
d2211 2
d2214 3
d2225 4
a2228 4
nmg_fu_touchingloops(fu1);
nmg_fu_touchingloops(fu2);
nmg_region_v_unique( fu1->s_p->r_p, &is->tol );
nmg_region_v_unique( fu2->s_p->r_p, &is->tol );
d2230 1
a2821 2
 *  A parallel to nmg_isect_edge2p_face2p().
 *
d2828 2
a2868 3
	/* Zap 2d cache, we should be switching faces now */
	nmg_isect2d_cleanup(is);

d2871 1
a2874 1
nmg_ck_face_worthless_edges( fu1 );
d2876 3
a2878 2
nmg_fu_touchingloops(fu1);
nmg_region_v_unique( fu1->s_p->r_p, &is->tol );
d2910 2
a2911 2
nmg_fu_touchingloops(fu1);
nmg_region_v_unique( fu1->s_p->r_p, &is->tol );
d3681 4
a3684 2
nmg_ck_vs_in_region( s1->r_p, tol );
nmg_ck_vs_in_region( s2->r_p, tol );
@


10.148
log
@Added additional search for existing vertices on edge_g line before
accepting calculated geometric hit3d to break an edge on.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.147 94/04/22 06:18:27 mike Exp Locker: mike $ (ARL)";
d2022 4
a2025 4
nmg_fu_touchingloops(fu2);
if(fu1)nmg_fu_touchingloops(fu1);
nmg_region_v_unique( is->s2->r_p, &is->tol );
nmg_region_v_unique( is->s1->r_p, &is->tol );
a2026 4
	/* Run through the list until no more edges are split in either face */
	total_splits = 0;
	do  {
		another_pass = 0;
d2028 9
a2036 3
		/* First, eu1 -vs- fu2 */
		for( RT_LIST_FOR( lu, loopuse, &fu2->lu_hd ) )  {
			struct edgeuse	*eu2;
d2038 3
a2040 39
			if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) == NMG_VERTEXUSE_MAGIC )  {
				struct vertexuse	*vu;
				vu = RT_LIST_FIRST( vertexuse, &lu->down_hd );
				if( nmg_isect_edge2p_vert2p( is, eu1, vu ) > 1 )  {
					another_pass++;	/* edge was split */
					total_splits++;
				}
				continue;
			}
			for( RT_LIST_FOR( eu2, edgeuse, &lu->down_hd ) )  {
				/* isect eu1 with eu2 */
				if( nmg_isect_edge2p_edge2p( is, eu1, eu2, fu1, fu2 )
				 & (ISECT_SPLIT1|ISECT_SPLIT2)
				)  {
					another_pass++;	/* edge was split */
					total_splits++;
				}
				if( rt_g.NMG_debug & DEBUG_VERIFY )  {
nmg_fu_touchingloops(fu2);
if(fu1)nmg_fu_touchingloops(fu1);
nmg_region_v_unique( is->s2->r_p, &is->tol );
nmg_region_v_unique( is->s1->r_p, &is->tol );
				}
			}
		}
		if (rt_g.NMG_debug & DEBUG_POLYSECT && another_pass > 0 )
			rt_log("nmg_isect_edge2p_face2p(): lu=x%x, another_pass=%d\n", lu, another_pass);
	} while( another_pass );

	/*
	 *  If there were _no_ new intersections, IN EITHER FACE,
	 *  then there is no need to call the face cutter here.
	 *  Otherwise, process _all_ the vu's along the line of intersection.
	 */
	if (rt_g.NMG_debug & DEBUG_POLYSECT )
		rt_log("nmg_isect_edge2p_face2p(): lu=x%x, total_splits=%d\n", lu, total_splits);

	/* Now, run line of intersection through fu1, if eu1 is not wire */
/* XXX This is new */
d2042 2
a2043 3
		total_splits += nmg_isect_line2_face2p( is, &vert_list1, fu1, fu2 );
		if (rt_g.NMG_debug & DEBUG_POLYSECT )
			rt_log("nmg_isect_edge2p_face2p(): lu=x%x, total_splits=%d B\n", lu, total_splits);
d2045 3
d2049 1
a2069 2
nmg_fu_touchingloops(fu2);
if(fu1)nmg_fu_touchingloops(fu1);
a2070 2
nmg_fu_touchingloops(fu2);		/* XXX r410 dies here */
nmg_fu_touchingloops(fu1);
a2075 2
nmg_fu_touchingloops(fu2);
if(fu1)nmg_fu_touchingloops(fu1);
@


10.147
log
@When "partial colinearity" occurs, and there is a hit point
from the geometric intersector, the lines are not colinear, they
intersect at that one point.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.146 94/04/22 05:59:17 mike Exp Locker: mike $ (ARL)";
d2475 1
d2535 1
a2535 1
		fastf_t		a, b;
d2604 4
d2610 47
@


10.146
log
@Eliminated another unnecessary routine.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.145 94/04/22 05:54:20 mike Exp Locker: mike $ (ARL)";
d2534 2
a2536 3
		if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
			rt_log("\tConsidering *eup=x%x for colinearity\n", *eup);
		}
d2543 7
a2549 1
		if( rt_distsq_line3_pt3( is->pt, is->dir, vu1a->v_p->vg_p->coord ) > is->tol.dist_sq  )
a2550 2
		if( rt_distsq_line3_pt3( is->pt, is->dir, vu1b->v_p->vg_p->coord ) > is->tol.dist_sq )
			continue;
d2575 10
a2584 1
		rt_log("\tOnly %d of %d edgeuses claim colinearity.\n", n_colinear, NMG_TBL_END(&eutab)-1);
@


10.145
log
@Eliminiated nmg_isect_two_face3p(), the "old way".
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.144 94/04/22 05:51:39 mike Exp Locker: mike $ (ARL)";
a1857 72
	return discards;
}

/*
 *			N M G _ I S E C T _ F A C E 3 P _ F A C E 3 P
 *
 *	Intersect entirely of planar face 1 with the entirety of planar face 2
 *	given that the two faces are not coplanar.
 *
 *  The line of intersection has already been computed,
 *  and face cutting is handled at a higher level.
 *
 *  Returns -
 *	 0	everything is ok
 *	>0	vu[] list along intersection line needs to be re-done.
 */
static int
nmg_isect_face3p_face3p(bs, fu1, fu2)
struct nmg_inter_struct *bs;
struct faceuse	*fu1;
struct faceuse	*fu2;
{
	struct loopuse	*lu1;		/* loopuses in fu1 */
	struct loopuse	*lu2;		/* loopuses in fu2 */
	struct loop_g	*lg1;
	int		discards = 0;

	if (rt_g.NMG_debug & DEBUG_POLYSECT)
		rt_log("nmg_isect_face3p_face3p(, fu1=x%x, fu2=x%x) START ++++++++++\n", fu1, fu2);

	NMG_CK_INTER_STRUCT(bs);
	NMG_CK_FACE_G(fu2->f_p->fg_p);
	NMG_CK_FACE_G(fu1->f_p->fg_p);

	if( fu1->orientation != OT_SAME )  rt_bomb("nmg_isect_face3p_face3p() fu1 not OT_SAME\n");
	if( fu2->orientation != OT_SAME )  rt_bomb("nmg_isect_face3p_face3p() fu2 not OT_SAME\n");

	/* process each face loop in face 1 */
	for( RT_LIST_FOR( lu1, loopuse, &fu1->lu_hd ) )  {
		NMG_CK_LOOPUSE(lu1);
		if (lu1->up.fu_p != fu1) {
			rt_bomb("nmg_isect_face3p_face3p() Child loop doesn't share parent!\n");
		}
		NMG_CK_LOOP(lu1->l_p);
		lg1 = lu1->l_p->lg_p;
		NMG_CK_LOOP_G(lg1);

		/* If the bounding box of a loop doesn't intersect the
		 * bounding box of a loop in the other face, it doesn't need
		 * to get cut.
		 */
		for (RT_LIST_FOR(lu2, loopuse, &fu2->lu_hd )){
			struct loop_g *lg2;	/* loop geom in lu2/fu2 */

			NMG_CK_LOOPUSE(lu2);
			NMG_CK_LOOP(lu2->l_p);
			lg2 = lu2->l_p->lg_p;
			NMG_CK_LOOP_G(lg2);

			if (! V3RPP_OVERLAP_TOL( lg2->min_pt, lg2->max_pt,
			    lg1->min_pt, lg1->max_pt, &bs->tol)) continue;

			/*
			 *  If any of the loops in fu2 overlap lu1, intersect
			 *  all the edges in lu1 with the plane of fu2.
			 */
			discards += nmg_isect_loop3p_face3p(bs, lu1, fu2);
			break;
		}
	}
	if (rt_g.NMG_debug & DEBUG_POLYSECT)
		rt_log("nmg_isect_face3p_face3p(, fu1=x%x, fu2=x%x) RETURN ++++++++++ discards=%d\n\n", fu1, fu2, discards);
@


10.144
log
@Moved nmg_pr_ptbl() from nmg_inter.c to nmg_pr.c
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.143 94/04/22 05:48:45 mike Exp Locker: mike $ (ARL)";
a2289 1

a2290 152
 *			N M G _ I S E C T _ T W O _ F A C E 3 P
 *
 *  Handle the complete mutual intersection of
 *  two 3-D non-coplanar planar faces,
 *  including cutjoin and meshing.
 *
 *  The line of intersection has already been computed.
 */
static void
nmg_isect_two_face3p( is, fu1, fu2 )
struct nmg_inter_struct	*is;
struct faceuse		*fu1, *fu2;
{
	struct nmg_ptbl vert_list1, vert_list2;
	int	again;		/* Need to do it again? */
	int	trips;		/* Number of trips through loop */

	NMG_CK_INTER_STRUCT(is);
	NMG_CK_FACEUSE(fu1);
	NMG_CK_FACEUSE(fu2);

	if (rt_g.NMG_debug & DEBUG_POLYSECT) {
		rt_log("nmg_isect_two_face3p( fu1=x%x, fu2=x%x )  START12\n", fu1, fu2);
		VPRINT("isect ray is->pt ", is->pt);
		VPRINT("isect ray is->dir", is->dir);
	}

	if( rt_g.NMG_debug & DEBUG_VERIFY )  {
		nmg_vfu( &fu1->s_p->fu_hd, fu1->s_p );
		nmg_vfu( &fu2->s_p->fu_hd, fu2->s_p );
nmg_fu_touchingloops(fu1);
nmg_fu_touchingloops(fu2);
	}

	(void)nmg_tbl(&vert_list1, TBL_INIT,(long *)NULL);
	(void)nmg_tbl(&vert_list2, TBL_INIT,(long *)NULL);

	again = 1;
	for( trips = 0; again > 0 && trips < 3; trips++ )  {
		again = 0;

		(void)nmg_tbl(&vert_list1, TBL_RST,(long *)NULL);
		(void)nmg_tbl(&vert_list2, TBL_RST,(long *)NULL);

	    	is->l1 = &vert_list1;
	    	is->l2 = &vert_list2;
		is->s1 = fu1->s_p;
		is->s2 = fu2->s_p;
		is->fu1 = fu1;
		is->fu2 = fu2;

	    	if (rt_g.NMG_debug & (DEBUG_POLYSECT|DEBUG_FCUT|DEBUG_MESH)
	    	    && rt_g.NMG_debug & DEBUG_PLOTEM) {
	    	    	nmg_pl_2fu( "Iface%d.pl", 0, fu1, fu2, 0 );
	    	}

		if( nmg_isect_face3p_face3p(is, fu1, fu2) )  {
			if (rt_g.NMG_debug & DEBUG_POLYSECT)
				rt_log("nmg_isect_two_face3p(): re-building intersection line A\n");
			again = 1;
		}
		if( rt_g.NMG_debug & DEBUG_VERIFY )  {
nmg_fu_touchingloops(fu1);
nmg_fu_touchingloops(fu2);
			nmg_vfu( &fu1->s_p->fu_hd, fu1->s_p );
			nmg_vfu( &fu2->s_p->fu_hd, fu2->s_p );
		}

		/*
		 *  Now intersect the other way around, to catch any stragglers.
		 */
	    	if (rt_g.NMG_debug & DEBUG_FCUT) {
		    	rt_log("nmg_isect_two_face3p(fu1=x%x, fu2=x%x) vert_lists A:\n", fu1, fu2);
	    		nmg_pr_ptbl_vert_list( "vert_list1", &vert_list1 );
	    		nmg_pr_ptbl_vert_list( "vert_list2", &vert_list2 );
	    	}

		if (rt_g.NMG_debug & DEBUG_POLYSECT) {
			rt_log("nmg_isect_two_face3p( fu1=x%x, fu2=x%x )  START21\n", fu1, fu2);
		}

	    	is->l2 = &vert_list1;
	    	is->l1 = &vert_list2;
		is->s2 = fu1->s_p;
		is->s1 = fu2->s_p;
		is->fu2 = fu1;
		is->fu1 = fu2;

		if( nmg_isect_face3p_face3p(is, fu2, fu1) )  {
			if (rt_g.NMG_debug & DEBUG_POLYSECT)
				rt_log("nmg_isect_two_face3p(): re-building intersection line B\n");
			again = 1;
		}

		if( rt_g.NMG_debug & DEBUG_VERIFY )  {
nmg_fu_touchingloops(fu1);
nmg_fu_touchingloops(fu2);
			nmg_vfu( &fu1->s_p->fu_hd, fu1->s_p );
			nmg_vfu( &fu2->s_p->fu_hd, fu2->s_p );
		}
	}

	nmg_purge_unwanted_intersection_points(&vert_list1, fu2, &is->tol);
	nmg_purge_unwanted_intersection_points(&vert_list2, fu1, &is->tol);

    	if (rt_g.NMG_debug & DEBUG_FCUT) {
	    	rt_log("nmg_isect_two_face3p(fu1=x%x, fu2=x%x) vert_lists B:\n", fu1, fu2);
    		nmg_pr_ptbl_vert_list( "vert_list1", &vert_list1 );
    		nmg_pr_ptbl_vert_list( "vert_list2", &vert_list2 );
    	}

    	if (vert_list1.end == 0 && vert_list2.end == 0) {
    		/* there were no intersections */
    		goto out;
    	}

	if (rt_g.NMG_debug & DEBUG_POLYSECT) {
		rt_log("nmg_isect_two_face3p( fu1=x%x, fu2=x%x )  MIDDLE\n", fu1, fu2);
	}

	nmg_face_cutjoin(&vert_list1, &vert_list2, fu1, fu2, is->pt, is->dir, &is->tol);

	if( rt_g.NMG_debug & DEBUG_VERIFY )  {
nmg_fu_touchingloops(fu1);
nmg_fu_touchingloops(fu2);
nmg_region_v_unique( fu1->s_p->r_p, &is->tol );
nmg_region_v_unique( fu2->s_p->r_p, &is->tol );
		nmg_vfu( &fu1->s_p->fu_hd, fu1->s_p );
		nmg_vfu( &fu2->s_p->fu_hd, fu2->s_p );
	}

#if 0
	show_broken_stuff((long *)fu1, (long **)NULL, 1, 0);
	show_broken_stuff((long *)fu2, (long **)NULL, 1, 0);
#endif

out:
	(void)nmg_tbl(&vert_list1, TBL_FREE, (long *)NULL);
	(void)nmg_tbl(&vert_list2, TBL_FREE, (long *)NULL);

	if( rt_g.NMG_debug & DEBUG_VERIFY )  {
		nmg_vfu( &fu1->s_p->fu_hd, fu1->s_p );
		nmg_vfu( &fu2->s_p->fu_hd, fu2->s_p );
	}
	if (rt_g.NMG_debug & DEBUG_POLYSECT) {
		rt_log("nmg_isect_two_face3p( fu1=x%x, fu2=x%x )  END\n", fu1, fu2);
		VPRINT("isect ray is->pt ", is->pt);
		VPRINT("isect ray is->dir", is->dir);
	}
}

/*
a3164 1
#if NEWLINE
a3165 3
#else
		nmg_isect_two_face3p( &bs, fu1, fu2 );
#endif
d3169 1
a3169 1
rt_log("co-planar faces (rt_isect_2planes)  WARNING: faces not shared.\n");
@


10.143
log
@Changed from 2D to 3D point calculations, for consistency with
the same checks done in other places.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.142 94/04/22 05:10:56 mike Exp Locker: mike $ (ARL)";
a2651 27
}

/* XXX move to nmg_pr.c */
/*
 *			N M G _ P R _ P T B L
 *
 *  Print an nmg_ptbl array for inspection.
 */
void
nmg_pr_ptbl( title, tbl, verbose )
CONST char		*title;
CONST struct nmg_ptbl	*tbl;
int			verbose;
{
	register long	**lp;

	NMG_CK_PTBL(tbl);
	rt_log("nmg_pr_ptbl(%s) %d entries (%d allocated)\n",
		title, tbl->end, tbl->blen );

	if( !verbose )  return;

	for( lp = (long **)NMG_TBL_BASEADDR(tbl);
	     lp <= (long **)NMG_TBL_LASTADDR(tbl); lp++
	)  {
		rt_log("  %.8x %s\n", *lp, rt_identify_magic(**lp) );
	}
@


10.142
log
@Check to make sure that *all* edgeuses really are colinear.
@
text
@a2 5
/* XXX move to vmath.h */
#define V2PRINT(a,b)	\
	rt_log("%s (%g, %g)\n", a, V2ARGS(b) );


d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.141 94/04/22 04:33:02 mike Exp Locker: mike $ (ARL)";
d2779 2
a2794 2
		nmg_get_2d_vertex( eu1_pt2d, vu1a->v_p, is, fu1 );
		nmg_get_2d_vertex( eu1_end2d, vu1b->v_p, is, fu1 );
d2796 1
a2796 1
		if( rt_distsq_line2_point2( is->pt2d, is->dir2d, eu1_pt2d ) > is->tol.dist_sq  )
d2798 1
a2798 1
		if( rt_distsq_line2_point2( is->pt2d, is->dir2d, eu1_end2d ) > is->tol.dist_sq )
d2897 5
a2901 5
		nmg_get_2d_vertex( eu1_pt2d, vu1a->v_p, is, fu1 );
		nmg_get_2d_vertex( eu1_end2d, vu1b->v_p, is, fu1 );

		/* Second, a geometry check on the edgeuse ENDPOINTS -vs- the line segment */
		if( rt_distsq_line2_point2( is->pt2d, is->dir2d, eu1_pt2d ) <= is->tol.dist_sq  )  {
d2905 1
a2905 1
		if( rt_distsq_line2_point2( is->pt2d, is->dir2d, eu1_end2d ) <= is->tol.dist_sq )  {
d2911 2
@


10.141
log
@Improved debugging, commenting.
@
text
@d54 1
a54 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.138 94/04/21 07:12:42 mike Exp Locker: mike $ (ARL)";
d2782 2
a2783 2
	 *  Test each edgeuse on eg1 individually, and list those where
	 *  both (2D) vertices are within tolerance of the line.
d2790 1
a2790 1
		if (rt_g.NMG_debug & DEBUG_POLYSECT)
d2792 1
d2805 19
a2823 1

d2825 3
a2827 2
		 *  The edge is colinear with the line.
		 *  List both vertexuse structures.
d2829 2
a2830 5
		if (rt_g.NMG_debug & DEBUG_POLYSECT)
			rt_log("\tedgeuse x%x colinear with isect line.  Listing vu1a, vu1b\n", *eup);
		nmg_enlist_vu(is, vu1a, 0);
		nmg_enlist_vu(is, vu1b, 0);
		n_colinear++;
d2832 10
a2841 4
	/*  If rt_isect_line2_line2() says colinear, or if colinear edges
	 *  were found, we are done.
	 */
	if( n_colinear || code == 0 )  {
d2851 3
d2864 5
d2876 1
a2876 1
		if (rt_g.NMG_debug & DEBUG_POLYSECT)
d2878 1
d2888 1
a2888 1
			if (rt_g.NMG_debug & DEBUG_POLYSECT)
d2890 1
d2895 1
a2895 1
			if (rt_g.NMG_debug & DEBUG_POLYSECT)
d2897 1
d2918 1
a2918 1
		if (rt_g.NMG_debug & DEBUG_POLYSECT)
d2920 1
d2967 1
a2967 1
				if (rt_g.NMG_debug & DEBUG_POLYSECT)
d2970 1
d2972 1
a2972 1
				if (rt_g.NMG_debug & DEBUG_POLYSECT)
d2974 1
d2978 1
@


10.140
log
@A version of nmg_isect_2colinear_edge2p() which won't fail to
enlist all the vertexuses, and with reasonable sharing.
@
text
@d54 1
a54 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.139 94/04/22 04:17:06 mike Exp Locker: mike $ (ARL)";
d290 1
d342 9
a350 4
		rt_log("nmg_get_2d_vertex ERROR #%d (%g %g %g) becomes (%g,%g) %g != zero!\n",
			v->index, V3ARGS(vg->coord), V3ARGS(pt) );
		if( !NEAR_ZERO( pt[2], 10*is->tol.dist ) )  {
			plane_t	n;
a353 1
			NMG_GET_FU_PLANE( n, fu );
d519 1
d570 1
a570 1
 *  This also means that no nmg_tbl( , TBL_INS_UNIQUE ) ops need be done.
a571 3
 *  XXX It would be useful to have one of the new vu's in fu returned
 *  XXX as a flag, so that nmg_find_v_in_face() wouldn't have to be called
 *  XXX to re-determine what was just done.
d573 1
a573 1
 *	vu2	dual of vu2
a1809 1
	plane_t		n;
d1812 1
@


10.139
log
@Added extra checking to nmg_enlist_vu().
@
text
@d54 1
a54 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.138 94/04/21 07:12:42 mike Exp Locker: mike $ (ARL)";
d1062 12
a1073 7
	/* Enlist the original endpoints */
	if( vu[0]->v_p == vu[2]->v_p )  {
		nmg_enlist_vu( is, vu[0], vu[2] );
	} else if( vu[0]->v_p == vu[3]->v_p )  {
		nmg_enlist_vu( is, vu[0], vu[3] );
	} else {
		nmg_enlist_vu( is, vu[0], 0 );
a1074 11

	if( vu[1]->v_p == vu[2]->v_p )  {
		nmg_enlist_vu( is, vu[1], vu[2] );
	} else if( vu[1]->v_p == vu[3]->v_p ) {
		nmg_enlist_vu( is, vu[1], vu[3] );
	} else {
		nmg_enlist_vu( is, vu[1], 0 );
	}
	/* XXX Might miss adding vu[2] and vu[3] otherwise! */
	nmg_enlist_vu( is, vu[2], 0 );
	nmg_enlist_vu( is, vu[3], 0 );
@


10.138
log
@Can't use eumate, need to use PNEXT_CIRC.
Removed "P not on line" bomb.
@
text
@d54 1
a54 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.137 94/04/21 05:56:42 mike Exp $ (ARL)";
d190 5
a194 2
	if( dualvu && nmg_find_s_of_vu(dualvu) != duals )  rt_bomb("dual vu shell mis-match\n");
	if( dualvu && vu->v_p != dualvu->v_p )  rt_bomb("dual vu has different vertex\n");
@


10.137
log
@Deleted nmg_isect_two_colinear_edge2p_both_ways() and
nmg_isect_two_colinear_edge2p().
@
text
@d54 1
a54 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.136 94/04/21 05:22:16 mike Exp Locker: mike $ (ARL)";
d114 1
d156 1
d163 1
d170 5
d179 5
d599 1
a599 1
			if( vu1->v_p == vu2->v_p )  return;
d948 2
d953 5
a957 1
		rt_log("nmg_break_eu_on_v() P not on line?\n");
d982 1
a982 1
 *			N M G _ B R E A K _ 2 C O L I N E A R _ E D G E 2 P
d986 2
a1013 1
 *  NOTE:  The vertexuse lists are updated.
d1016 1
a1016 1
nmg_break_2colinear_edge2p( eu1, eu2, fu, is )
d1034 1
a1034 1
	vu[1] = eu1->eumate_p->vu_p;
d1036 1
a1036 1
	vu[3] = eu2->eumate_p->vu_p;
d1075 3
d1080 1
a1080 1
		rt_log("nmg_break_2colinear_edge2p(eu1=x%x, eu2=x%x) #eu=%d\n",
d1259 1
a1259 1
		if( nmg_break_2colinear_edge2p( eu1, eu2, fu2, is ) > 2 )  {
d1267 1
a1267 1
		goto out;		/* vu1a, vu1b listed by nmg_break_2colinear_edge2p */
d2216 2
d3467 1
a3467 1
		(void)nmg_break_2colinear_edge2p( eu1, eu2, eu1->e_p, is );
@


10.136
log
@Conversion to nmg_enlist_vu().
@
text
@d54 1
a54 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.135 94/04/21 01:46:31 mike Exp Locker: mike $ (ARL)";
d227 5
d359 6
d380 2
d441 1
a965 1
 *  No intersect list stuff is performed.
d993 1
a993 1
 *  NOTE:  The vertexuse lists are now updated.
d1010 1
a1010 1
	NMG_CK_FACEUSE(fu);
a1063 245
 * N M G _ I S E C T _ T W O _ C O L I N E A R _ E D G E 2 P _ B O T H _ W A Y S
 *
 *  A wrapper for nmg_isect_two_colinear_edge2p().
 *
 *  XXX This is an abomination, and needs to be totally scrapped.
 *  XXX Unfortunately, it is still called in one place:  nmg_isect_edge3p_edge3p()
 */
static int
nmg_isect_two_colinear_edge2p_both_ways( dist, l1, l2, vu1a, vu1b, vu2a, vu2b, eu1, eu2, fu1, fu2, tol )
CONST fastf_t		dist[2];
struct nmg_ptbl		*l1;
struct nmg_ptbl		*l2;
struct vertexuse	*vu1a;
struct vertexuse	*vu1b;
struct vertexuse	*vu2a;
struct vertexuse	*vu2b;
struct edgeuse		*eu1;
struct edgeuse		*eu2;
struct faceuse		*fu1;		/* fu of eu1, for plane equation */
struct faceuse		*fu2;		/* fu of eu2, for error checks */
CONST struct rt_tol	*tol;
{
	fastf_t		eu2dist[2];
	fastf_t		ptol;
	int		status;
	int		ret = 0;
	vect_t		eu1_dir;
	vect_t		eu2_dir;

	RT_CK_TOL(tol);

	/*
	 *  Special case of colinear overlapping edges.
	 *  There may be 2 intersect points.
	 *  dist[1] has special meaning for this return status:
	 *  it's distance w.r.t. eu1's 1st point (vu1a), not eu2's 1st.
	 *  Find break points on eu1 caused by vu2[ab].
	 */
	if( nmg_isect_two_colinear_edge2p( dist, l1, l2,
		vu1a, vu1b, vu2a, vu2b,
		eu1, eu2, fu1, fu2, tol, "eu1/eu2" )
	   > 0
	)  {
		ret |= ISECT_SPLIT1;	/* eu1 was broken */
	}

#if 0
	/*
	 *  If the segments only partially overlap, need to intersect
	 *  the other way as well.
	 *  Find break points on eu2 caused by vu1[ab].
	 */
/*XXX Couldn't this also be more intuitively done by re-calling rt_isect_*? */
	if( fabs(eu2_dir[X]) >= fabs(eu2_dir[Y]) )  {
		eu2dist[0] = (eu1_start[X] - eu2_start[X])/eu2_dir[X];
		eu2dist[1] = (eu1_start[X] + eu1_dir[X] - eu2_start[X])/eu2_dir[X];
	} else {
		eu2dist[0] = (eu1_start[Y] - eu2_start[Y])/eu2_dir[Y];
		eu2dist[1] = (eu1_start[Y] + eu1_dir[Y] - eu2_start[Y])/eu2_dir[Y];
	}
	/* Tolerance processing */
	ptol = tol->dist / sqrt( eu2_dir[X]*eu2_dir[X] + eu2_dir[Y]*eu2_dir[Y] );
	if( eu2dist[0] > -ptol && eu2dist[0] < ptol )  eu2dist[0] = 0;
	else if( eu2dist[0] > 1-ptol && eu2dist[0] < 1+ptol ) eu2dist[0] = 1;
		if( eu2dist[1] > -ptol && eu2dist[1] < ptol )  eu2dist[1] = 0;
	else if( eu2dist[1] > 1-ptol && eu2dist[1] < 1+ptol ) eu2dist[1] = 1;
	if (rt_g.NMG_debug & DEBUG_POLYSECT) {
		rt_log("\tnmg_isect_two_colinear_edge2p_both_ways() eu2dist: %g, %g\n",
			eu2dist[0], eu2dist[1] );
		rt_log("ptol = %g, eu2dist=%g, %g\n", ptol, eu2dist[0], eu2dist[1]);
	}
#else
	/* For new eu1, find break points on eu2 caused by vu1a and vu1b. */
	vu1a = eu1->vu_p;
	vu1b = RT_LIST_PNEXT_CIRC( edgeuse, eu1 )->vu_p;
	VSUB2( eu1_dir, vu1b->v_p->vg_p->coord, vu1a->v_p->vg_p->coord );
	VSUB2( eu2_dir, vu2b->v_p->vg_p->coord, vu2a->v_p->vg_p->coord );

	eu2dist[0] = eu2dist[1] = 0;	/* for clean prints, below */

	status = rt_isect_lseg3_lseg3( eu2dist,
			vu2a->v_p->vg_p->coord, eu2_dir,
			vu1a->v_p->vg_p->coord, eu1_dir,
			tol );

	if (rt_g.NMG_debug & DEBUG_POLYSECT) {
		rt_log("\tnmg_isect_two_colinear_edge2p_both_ways()=%d, dist: %g, %g\n",
			status, eu2dist[0], eu2dist[1] );
	}

	if( status != 0 )  goto out;
#endif

	/*  Find break points on eu2 caused by vu1[ab]. */
	if( nmg_isect_two_colinear_edge2p( eu2dist, l2, l1,
		vu2a, vu2b, vu1a, vu1b,
		eu2, eu1, fu2, fu1, tol, "eu2/eu1" )
	> 0 )  {
		ret |= ISECT_SPLIT2;	/* eu2 was broken */
	}
out:
	if(fu1)nmg_ck_face_worthless_edges( fu1 );
	if(fu2)nmg_ck_face_worthless_edges( fu2 );
	return ret;
}

/*
 *			N M G _ I S E C T _ T W O _ C O L I N E A R _ E D G E 2 P
 *
 *  Two colinear line segments (eu1 and eu2, or just "1" and "2" in the
 *  diagram) can overlap each other in one of 9 configurations,
 *  labeled A through I:
 *
 *	A	B	C	D	E	F	G	H	I
 *
 *  vu1b,vu2b
 *	*	*	  *	  *	*	  *	*	  *	*=*
 *	1	1	  2	  2	1	  2	1	  2	1 2
 *	1=*	1	  2	*=2	1=*	*=2	*	  *	1 2
 *	1 2	*=*	*=*	1 2	1 2	1 2			1 2
 *	1 2	  2	1	1 2	1 2	1 2	  *	*	1 2
 *	1=*	  2	1	*=2	*=2	1=*	  2	1	1 2
 *	1	  *	*	  2	  2	1	  *	*	1 2
 *	*			  *	  *	*			*=*
 *   vu1a,vu2a
 *
 *  dist[0] has the distance (0..1) along eu1 from vu1a to vu2a.
 *  dist[1] has the distance (0..1) along eu1 from vu1a to vu2b.
 *
 *  As a consequence of this, conditions D, E, F can not be
 *  completely processed by just one call.
 *  If the caller computes a second array where the sense of eu1 and eu2
 *  are exchanged, and calls again, then the full intersection 
 *  will be achieved.
 *
 *  Returns -
 *	n	number of times eu1 was broken.
 */
int
nmg_isect_two_colinear_edge2p( dist, l1, l2, vu1a, vu1b, vu2a, vu2b, eu1, eu2, fu1, fu2, tol, str )
CONST fastf_t		dist[2];
struct nmg_ptbl		*l1;
struct nmg_ptbl		*l2;
struct vertexuse	*vu1a;
struct vertexuse	*vu1b;
struct vertexuse	*vu2a;
struct vertexuse	*vu2b;
struct edgeuse		*eu1;
struct edgeuse		*eu2;
struct faceuse		*fu1;		/* fu of eu1, for plane equation */
struct faceuse		*fu2;		/* fu of eu2, for error checks */
CONST struct rt_tol	*tol;
CONST char		*str;
{
	int	nbreak = 0;
	fastf_t	d0, d1;

	NMG_CK_VERTEXUSE(vu1a);
	NMG_CK_VERTEXUSE(vu1b);
	NMG_CK_VERTEXUSE(vu2a);
	NMG_CK_VERTEXUSE(vu2b);
	NMG_CK_EDGEUSE(eu1);
	NMG_CK_EDGEUSE(eu2);
	if(fu1)NMG_CK_FACEUSE(fu1);
	if(fu2)NMG_CK_FACEUSE(fu2);
	RT_CK_TOL(tol);

	if (rt_g.NMG_debug & DEBUG_POLYSECT)
		rt_log("nmg_isect_two_colinear_edge2p(eu1=x%x, eu2=x%x) %s\n", eu1, eu2, str);
	if(fu1)nmg_ck_face_worthless_edges( fu1 );
	if(fu2)nmg_ck_face_worthless_edges( fu2 );

	if( dist[0] > dist[1] )  {
		/* Need to swap vu2a and vu2b */
		struct vertexuse	*vu;
		fastf_t			t;
		if (rt_g.NMG_debug & DEBUG_POLYSECT)
			rt_log("nmg_isect_two_colinear_edge2p() dist [0] > [1], flip\n");
		vu = vu2a;
		vu2a = vu2b;
		vu2b = vu;
		d0 = dist[1];
		d1 = dist[0];
	} else {
		d0 = dist[0];
		d1 = dist[1];
	}

	/* First intersection point:  break eu1 */
	if( d0 == 0 )  {
		if (rt_g.NMG_debug & DEBUG_POLYSECT)
			rt_log("\tvu1a intersects vu2a\n");
		(void)nmg_tbl(l1, TBL_INS_UNIQUE, &vu1a->l.magic);
		(void)nmg_tbl(l2, TBL_INS_UNIQUE, &vu2a->l.magic);
		nmg_jv(vu1a->v_p, vu2a->v_p);
		if(fu1&&fu2)nmg_ck_v_in_2fus(vu1a->v_p, fu1, fu2, tol);
	} else if( d0 == 1 )  {
		if (rt_g.NMG_debug & DEBUG_POLYSECT)
			rt_log("\tvu1a intersects vu2b\n");
		(void)nmg_tbl(l1, TBL_INS_UNIQUE, &vu1a->l.magic);
		(void)nmg_tbl(l2, TBL_INS_UNIQUE, &vu2b->l.magic);
		nmg_jv(vu1a->v_p, vu2b->v_p);
		if(fu1&&fu2)nmg_ck_v_in_2fus(vu1a->v_p, fu1, fu2, tol);
	} else if( d0 > 0 && d0 < 1 )  {
		/* Break eu1 into two pieces */
		if (rt_g.NMG_debug & DEBUG_POLYSECT)
			rt_log("\tvu2a=x%x breaks eu1=x%x\n", vu2a, eu1 );
		/*
		 *  Update eu1 to be new edgeuse;  if vu2b needs to break
		 *  the edge as well, it will be this new one.
		 */
		eu1 = nmg_ebreak( vu2a->v_p, eu1 );
		nbreak++;
		vu1a = eu1->vu_p;
		if(fu1)nmg_ck_face_worthless_edges( fu1 );
		if(fu2)nmg_ck_face_worthless_edges( fu2 );
	}

	/* Second intersection point: break eu1 again */
	if( d1 == 0 )  {
		if (rt_g.NMG_debug & DEBUG_POLYSECT)
			rt_log("\tvu1a intersects vu2b\n");
		(void)nmg_tbl(l1, TBL_INS_UNIQUE, &vu1a->l.magic);
		(void)nmg_tbl(l2, TBL_INS_UNIQUE, &vu2b->l.magic);
		nmg_jv(vu1a->v_p, vu2b->v_p);
		if(fu1&&fu2)nmg_ck_v_in_2fus(vu1a->v_p, fu1, fu2, tol);
	} else if( d1 == 1 )  {
		if (rt_g.NMG_debug & DEBUG_POLYSECT)
			rt_log("\tvu1b intersects vu2b\n");
		(void)nmg_tbl(l1, TBL_INS_UNIQUE, &vu1b->l.magic);
		(void)nmg_tbl(l2, TBL_INS_UNIQUE, &vu2b->l.magic);
		nmg_jv(vu1b->v_p, vu2b->v_p);
		if(fu1&&fu2)nmg_ck_v_in_2fus(vu1b->v_p, fu1, fu2, tol);
	} else if( d1 > 0 && d1 < 1 )  {
		if (rt_g.NMG_debug & DEBUG_POLYSECT)
			rt_log("\tvu2b=x%x breaks eu1=x%x\n", vu2b, eu1 );
		(void)nmg_ebreak( vu2b->v_p, eu1 );
		nbreak++;
		if(fu1)nmg_ck_face_worthless_edges( fu1 );
		if(fu2)nmg_ck_face_worthless_edges( fu2 );
	}
	return nbreak;
}

/*
a1275 1
			if(!wire)nmg_ck_v_in_2fus(vu1a->v_p, fu1, fu2, &is->tol);
a1283 1
			if(!wire)nmg_ck_v_in_2fus(vu1a->v_p, fu1, fu2, &is->tol);
a1314 1
			if(!wire)nmg_ck_v_in_2fus(vu1a->v_p, fu1, fu2, &is->tol);
a1322 1
			if(!wire)nmg_ck_v_in_2fus(vu1b->v_p, fu1, fu2, &is->tol);
a1760 1
		if(fu1) nmg_ck_v_in_2fus(vu1_final->v_p, fu1, fu2, &is->tol);
d3439 6
a3444 14
#if 1
rt_g.NMG_debug |= DEBUG_POLYSECT;
/* XXX must use a 3-D version!! */
		nbreak = nmg_isect_two_colinear_edge2p_both_ways( dist,
			is->l1, is->l2,
			vu1a, vu1b, vu2a, vu2b,
			eu1, eu2,
			nmg_find_fu_of_eu(eu1),
			nmg_find_fu_of_eu(eu2),
			&is->tol );
#else
		/* XXXXXXXX */
		rt_bomb("nmg_isect_edge3p_edge3p colinear case!\n");
#endif
d3447 5
d3483 2
@


10.135
log
@Added nmg_enrole_vu(), have not yet torn out the previous code.
@
text
@d54 1
a54 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.134 94/04/20 23:43:11 mike Exp Locker: mike $ (ARL)";
d108 6
d115 1
d126 1
d132 2
d140 4
d145 2
a146 2
void
nmg_enlist_vu( is, vu )
d149 1
a153 1
	struct vertexuse	*dualvu;	/* vu's dual in other shell */
d158 1
d177 3
a180 1
	dualvu = (struct vertexuse *)NULL;
d184 1
a184 1
		if( !(dualvu = nmg_find_v_in_face( vu->v_p, dualfu )) )  {
d200 1
a200 1
		if( !(dualvu = nmg_find_v_in_shell( vu->v_p, duals, 0 )) )  {
d227 1
a230 55
 *		N M G _ I N S E R T _ F U _ V U _ I N _ O T H E R _ L I S T
 *
 *  Insert vu2 from fu2 that corresponds to v onto
 *  the OTHER face's (fu2's) intersect list (list2).
 *  If such a vu2 does not exist, create one as a self-loop in fu2.
 *
 *  NOTE that "list1" is fu1's list.  list2 is found via the "is" arg.
 *
 *  Returns -
 *	vu2		vertexuse in fu2 that was added to list2.
 */
struct vertexuse *
nmg_insert_fu_vu_in_other_list( is, list1, v, fu2 )
struct nmg_inter_struct	*is;
struct nmg_ptbl		*list1;
struct vertex		*v;
struct faceuse		*fu2;
{
	struct vertexuse	*vu2;
	struct nmg_ptbl		*lp;
	struct loopuse		*plu;		/* point loopuse */
	struct shell		*s;

	NMG_CK_INTER_STRUCT(is);
	NMG_CK_PTBL(list1);
	NMG_CK_VERTEX(v);
	NMG_CK_FACEUSE(fu2);

	if( is->l1 == list1 )  {
		lp = is->l2;
		s = is->s2;
	}  else  {
		lp = is->l1;
		s = is->s1;
	}
	if( fu2->s_p != s )  rt_bomb("nmg_insert_fu_vu_in_other_list() fu in wrong shell\n");
	if( vu2 = nmg_find_v_in_face( v, fu2 ) )  {
		(void)nmg_tbl(lp, TBL_INS_UNIQUE, &vu2->l.magic);
		return vu2;
	}
	/* Insert copy of this vertex into other face, as self-loop. */
	plu = nmg_mlv(&fu2->l.magic, v, OT_BOOLPLACE);
	nmg_loop_g(plu->l_p, &is->tol);
	vu2 = RT_LIST_FIRST( vertexuse, &plu->down_hd );
	NMG_CK_VERTEXUSE(vu2);
	(void)nmg_tbl(lp, TBL_INS_UNIQUE, &vu2->l.magic);

	if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
		rt_log("nmg_insert_fu_vu_in_other_list: v=x%x, made self-loop for fu2: vu2=x%x\n",
			v, vu2);
	}
	return vu2;
}

/*
d539 2
d542 1
a542 1
static void
d548 1
d560 1
a560 1
	if( nmg_find_v_in_face(vu1->v_p, fu2) )  return;
a567 1
		struct vertexuse *vu2;
d578 1
a578 1
				return;
d583 1
d585 3
a587 1
			if( nmg_isect_edge2p_vert2p( is, eu2, vu1 ) )  return;
d597 1
d659 2
a660 1
	nmg_isect_vert2p_face2p( is, vu, fu );
d662 1
a662 18
	/* Re-check the topology */
	if (vup=nmg_find_v_in_face(vu->v_p, fu)) {
		if (rt_g.NMG_debug & DEBUG_POLYSECT) rt_log("\tvu lies in face (topology 2)\n");
		(void)nmg_tbl(is->l1, TBL_INS_UNIQUE, &vu->l.magic);
		(void)nmg_tbl(is->l2, TBL_INS_UNIQUE, &vup->l.magic);
		return;
	}

	/* Make lone vertex-loop in fu to indicate sharing */
	if (rt_g.NMG_debug & DEBUG_POLYSECT)
	    	VPRINT("nmg_isect_3vertex_3face() making vertexloop", vu->v_p->vg_p->coord);

	plu = nmg_mlv(&fu->l.magic, vu->v_p, OT_BOOLPLACE);
	nmg_loop_g(plu->l_p, &is->tol);
	vup = RT_LIST_FIRST(vertexuse, &plu->down_hd);
	NMG_CK_VERTEXUSE(vup);
	(void)nmg_tbl(is->l1, TBL_INS_UNIQUE, &vu->l.magic);
    	(void)nmg_tbl(is->l2, TBL_INS_UNIQUE, &vup->l.magic);
d752 1
a752 1
		vu2_final = nmg_insert_fu_vu_in_other_list( is, is->l2, v2, fu2 );
d815 1
a815 1
			(void)nmg_tbl(is->l2, TBL_INS_UNIQUE, &vu2_final->l.magic);
d838 1
a838 1
		(void)nmg_tbl(is->l2, TBL_INS_UNIQUE, &vu2_final->l.magic);
a851 1
	(void)nmg_tbl(is->l1, TBL_INS_UNIQUE, &eu1forw->vu_p->l.magic);
d979 2
d990 1
a990 1
	struct vertex	*v[4];
d1000 4
a1003 4
	v[0] = eu1->vu_p->v_p;
	v[1] = eu1->eumate_p->vu_p->v_p;
	v[2] = eu2->vu_p->v_p;
	v[3] = eu2->eumate_p->vu_p->v_p;
d1011 2
a1012 1
			if( eu[neu] = nmg_break_eu_on_v(eu[i],v[j],fu,is) )
d1014 1
d1026 17
d1054 3
d1380 1
a1380 2
	if( (vu1a->v_p == vu2a->v_p && vu1b->v_p == vu2b->v_p) ||
	    (vu1a->v_p == vu2b->v_p && vu1b->v_p == vu2a->v_p) )  {
d1384 2
d1387 1
a1387 1
		goto topo;
d1389 9
d1434 1
d1437 2
d1440 2
a1441 2
	if( status != 0 && (
	    vu1a->v_p == vu2a->v_p || vu1a->v_p == vu2b->v_p ||
d1446 10
d1457 1
a1457 1
		goto topo;
d1462 1
a1462 1
		goto out;
d1466 2
a1467 4
		/* Lines are co-linear */
#if 1
		/* XXX This part might not help, test it. */
		/* First, perform full mutual intersection */
d1469 6
a1474 5
			/* Things might have changed */
			vu1a = eu1->vu_p;
			vu1b = RT_LIST_PNEXT_CIRC( edgeuse, eu1 )->vu_p;
			vu2a = eu2->vu_p;
			vu2b = RT_LIST_PNEXT_CIRC( edgeuse, eu2 )->vu_p;
d1476 1
a1476 8
#endif
		/* XXX Drop back to old routine to list the verts */
		ret |= nmg_isect_two_colinear_edge2p_both_ways( dist,
			is->l1, is->l2,
			vu1a, vu1b, vu2a, vu2b,
			eu1, eu2, fu1, fu2,
			&is->tol );
		goto out;
d1497 1
a1497 1
			goto out;
a1498 1
		(void)nmg_tbl(is->l1, TBL_INS_UNIQUE, &vu1a->l.magic);
a1505 1
			(void)nmg_tbl(is->l2, TBL_INS_UNIQUE, &vu2a->l.magic);
d1507 1
d1510 1
a1510 1
			goto out;
a1514 1
			(void)nmg_tbl(is->l2, TBL_INS_UNIQUE, &vu2b->l.magic);
d1516 1
d1519 1
a1519 1
			goto out;
d1524 2
a1525 4
		(void)nmg_ebreak( vu1a->v_p, eu2 );
		if(fu1)nmg_ck_face_worthless_edges( fu1 );
		if(fu2)nmg_ck_face_worthless_edges( fu2 );
		(void)nmg_tbl(is->l2, TBL_INS_UNIQUE, &vu2b->l.magic);
d1527 1
a1527 1
		goto out;
d1538 1
a1538 1
			goto out;
a1539 1
		(void)nmg_tbl(is->l1, TBL_INS_UNIQUE, &vu1b->l.magic);
a1546 1
			(void)nmg_tbl(is->l2, TBL_INS_UNIQUE, &vu2a->l.magic);
d1548 1
d1551 1
a1551 1
			goto out;
a1555 1
			(void)nmg_tbl(is->l2, TBL_INS_UNIQUE, &vu2b->l.magic);
d1557 1
d1560 1
a1560 1
			goto out;
d1565 2
a1566 4
		(void)nmg_ebreak( vu1b->v_p, eu2 );
		(void)nmg_tbl(is->l2, TBL_INS_UNIQUE, &vu2b->l.magic);
		if(fu1)nmg_ck_face_worthless_edges( fu1 );
		if(fu2)nmg_ck_face_worthless_edges( fu2 );
d1568 1
a1568 1
		goto out;
d1571 3
a1573 1
	/* eu2 intersect point is on eu1 line, but not between vertices */
d1580 3
a1582 15
			if( vu = nmg_find_v_in_face( vu2a->v_p, fu1 ) )  {
				if (rt_g.NMG_debug & DEBUG_POLYSECT)
					rt_log("\t\tIntersect point is vu2a\n");
			} else {
				if (rt_g.NMG_debug & DEBUG_POLYSECT)
					rt_log("\t\tIntersect point is vu2a, make self-loop in fu1\n");
				plu = nmg_mlv(magic1, vu2a->v_p, OT_BOOLPLACE);
				nmg_loop_g(plu->l_p, &is->tol);
				vu = RT_LIST_FIRST( vertexuse, &plu->down_hd );
			}
			NMG_CK_VERTEXUSE(vu);
			(void)nmg_tbl(is->l1, TBL_INS_UNIQUE, &vu->l.magic);
			(void)nmg_tbl(is->l2, TBL_INS_UNIQUE, &vu2a->l.magic);
			ret = ISECT_SHARED_V;	/* eu1 was not broken */
			goto out;
d1584 1
a1584 13
			if( vu = nmg_find_v_in_face( vu2b->v_p, fu1 ) )  {
				if (rt_g.NMG_debug & DEBUG_POLYSECT)
					rt_log("\t\tIntersect point is vu2b\n");
			} else {
				if (rt_g.NMG_debug & DEBUG_POLYSECT)
					rt_log("\t\tIntersect point is vu2b, make self-loop in fu1\n");
				plu = nmg_mlv(magic1, vu2b->v_p, OT_BOOLPLACE);
				nmg_loop_g(plu->l_p, &is->tol);
				vu = RT_LIST_FIRST( vertexuse, &plu->down_hd );
			}
			NMG_CK_VERTEXUSE(vu);
			(void)nmg_tbl(is->l1, TBL_INS_UNIQUE, &vu->l.magic);
			(void)nmg_tbl(is->l2, TBL_INS_UNIQUE, &vu2b->l.magic);
d1586 1
a1586 1
			goto out;
d1599 1
a1599 7

			/* The "other" list of this call will be l1 */
			(void)nmg_insert_fu_vu_in_other_list( is, is->l2, new_vu2->v_p, fu1 );
			(void)nmg_tbl(is->l2, TBL_INS_UNIQUE, &new_vu2->l.magic);

			nmg_ck_face_worthless_edges( fu1 );
			nmg_ck_face_worthless_edges( fu2 );
d1601 1
a1601 1
			goto out;
d1604 1
a1604 1
		/* Ray misses eu2, nothing to do */
d1606 1
d1610 1
d1620 2
a1621 1
		nmg_ebreak( vu2a->v_p, eu1 );
d1623 1
a1623 4
		(void)nmg_tbl(is->l1, TBL_INS_UNIQUE, &vu1b->l.magic);
		(void)nmg_tbl(is->l2, TBL_INS_UNIQUE, &vu2a->l.magic);
		nmg_ck_face_worthless_edges( fu1 );
		nmg_ck_face_worthless_edges( fu2 );
d1627 2
a1628 1
		nmg_ebreak( vu2b->v_p, eu1 );
d1630 2
a1631 5
		(void)nmg_tbl(is->l1, TBL_INS_UNIQUE, &vu1b->l.magic);
		(void)nmg_tbl(is->l2, TBL_INS_UNIQUE, &vu2b->l.magic);
		nmg_ck_face_worthless_edges( fu1 );
		nmg_ck_face_worthless_edges( fu2 );
	} else {
d1640 1
a1640 1
		/* new_v is at far end of eu1 */
d1642 1
d1644 11
a1654 4
		(void)nmg_tbl(is->l1, TBL_INS_UNIQUE, &RT_LIST_PNEXT_CIRC(edgeuse,eu1)->vu_p->l.magic);
		(void)nmg_tbl(is->l2, TBL_INS_UNIQUE, &RT_LIST_PNEXT_CIRC(edgeuse,eu2)->vu_p->l.magic);
		nmg_ck_face_worthless_edges( fu1 );
		nmg_ck_face_worthless_edges( fu2 );
a1656 8
	/*
	 *  Now that processing is done and edges may have been shortened,
	 *  enrole any shared topology (representing edge intersections)
	 *  in the list of vu's encountered along this edge.
	 *  Note that either (or both) vu's may be shared in the case
	 *  of co-linear edges.
	 *  Can't use eumate_p here, it's in wrong orientation faceuse.
	 */
a1657 14
	vu1a = eu1->vu_p;
	vu1b = RT_LIST_PNEXT_CIRC(edgeuse,eu1)->vu_p;
	vu2a = eu2->vu_p;
	vu2b = RT_LIST_PNEXT_CIRC(edgeuse,eu2)->vu_p;

	/* If endpoints match, make sure that edge is shared */
	if( ( (vu1a->v_p == vu2a->v_p && vu1b->v_p == vu2b->v_p) ||
	      (vu1a->v_p == vu2b->v_p && vu1b->v_p == vu2a->v_p)
	    ) && (eu1->e_p != eu1->e_p)  )  {
		if (rt_g.NMG_debug & DEBUG_POLYSECT)
			rt_log("\tendpoints are shared, make edge shared.\n");
		nmg_radial_join_eu(eu1, eu2, &is->tol);
	}

d1659 12
a1670 5
	 *  vu1a and vu1b and their duals MUST be listed on
	 *  the intersection line.
	 *  Given that the edges are coplanar, if each vu does not
	 *  have a (dual) reference in the other face, then we need to
	 *  create a self-loop vu over there.
d1672 2
a1673 34
	(void)nmg_tbl(is->l1, TBL_INS_UNIQUE, &vu1a->l.magic);
	(void)nmg_tbl(is->l1, TBL_INS_UNIQUE, &vu1b->l.magic);

	/* Find dual of vu1a in fu2 */
	if( vu1a->v_p == vu2a->v_p )  {
		(void)nmg_tbl(is->l2, TBL_INS_UNIQUE, &vu2a->l.magic);
	} else if( vu1a->v_p == vu2b->v_p )  {
		(void)nmg_tbl(is->l2, TBL_INS_UNIQUE, &vu2b->l.magic);
	} else if( vu=nmg_find_v_in_face(vu1a->v_p, fu2) )  {
		(void)nmg_tbl(is->l2, TBL_INS_UNIQUE, &vu->l.magic);
	} else {
		struct loopuse *plu;
		plu = nmg_mlv(magic2, vu1a->v_p, OT_BOOLPLACE);
		nmg_loop_g(plu->l_p, &is->tol);
		vu = RT_LIST_FIRST( vertexuse, &plu->down_hd );
		NMG_CK_VERTEXUSE(vu);
		(void)nmg_tbl(is->l2, TBL_INS_UNIQUE, &vu->l.magic);
	}

	/* Find dual of vu1b in fu2 */
	if( vu1b->v_p == vu2a->v_p )  {
		(void)nmg_tbl(is->l2, TBL_INS_UNIQUE, &vu2a->l.magic);
	} else if( vu1b->v_p == vu2b->v_p )  {
		(void)nmg_tbl(is->l2, TBL_INS_UNIQUE, &vu2b->l.magic);
	} else if( vu=nmg_find_v_in_face(vu1b->v_p, fu2) )  {
		(void)nmg_tbl(is->l2, TBL_INS_UNIQUE, &vu->l.magic);
	} else {
		struct loopuse *plu;
		plu = nmg_mlv(magic2, vu1b->v_p, OT_BOOLPLACE);
		nmg_loop_g(plu->l_p, &is->tol);
		vu = RT_LIST_FIRST( vertexuse, &plu->down_hd );
		NMG_CK_VERTEXUSE(vu);
		(void)nmg_tbl(is->l2, TBL_INS_UNIQUE, &vu->l.magic);
	}
d1675 1
d1943 1
a1943 30
		(void)nmg_tbl(is->l1, TBL_INS_UNIQUE, &vu1_final->l.magic);

		/* XXX SHouldn't this be a topology search, since vertex fuser has already run? */
		v2 = nmg_find_pt_in_model(fu2->s_p->r_p->m_p, v1a->vg_p->coord, &(is->tol));
		if (v2) {
			register pointp_t	p3;
			/* Other shell has a very similar vertex.  Add to list */
			if (rt_g.NMG_debug & DEBUG_POLYSECT)
				rt_log("A: v1a=x%x Other shell has v2=x%x\n", v1a, v2);
#if 0
			/* Make new coordinates be the midpoint */
			p3 = v2->vg_p->coord;
			VADD2SCALE(v1a->vg_p->coord, v1a->vg_p->coord, p3, 0.5);
#endif
			/* Combine the two vertices */
			nmg_jv(v1a, v2);
			vu2_final = nmg_insert_fu_vu_in_other_list( is, is->l1, v1a, fu2 );
			if(fu1) nmg_ck_v_in_2fus(v1a, fu1, fu2, &is->tol);
		} else {
			/* Insert copy of this vertex into face */
			if (rt_g.NMG_debug & DEBUG_POLYSECT)
			    	VPRINT("Making vertexloop",
			    		v1a->vg_p->coord);

			plu = nmg_mlv(&fu2->l.magic, v1a, OT_BOOLPLACE);
			nmg_loop_g(plu->l_p, &is->tol);
			vu2_final = RT_LIST_FIRST( vertexuse, &plu->down_hd );
			NMG_CK_VERTEXUSE(vu2_final);
			(void)nmg_tbl(is->l2, TBL_INS_UNIQUE, &vu2_final->l.magic);
		}
d1971 1
a1971 30
		(void)nmg_tbl(is->l1, TBL_INS_UNIQUE, &vu1_final->l.magic);

		/* XXX Shouldn't this be a topology search, rather than geom?  Vert fuser has already run */
		v2 = nmg_find_pt_in_model(fu2->s_p->r_p->m_p, v1b->vg_p->coord, &(is->tol));
		if (v2) {
			register pointp_t	p3;
			/* Face has a very similar vertex.  Add to list */
			if (rt_g.NMG_debug & DEBUG_POLYSECT)
				rt_log("B: v1b=x%x Other shell has v2=x%x\n", v1b, v2);
#if 0
			/* Make new coordinates be the midpoint */
			p3 = v2->vg_p->coord;
			VADD2SCALE(v1b->vg_p->coord, v1b->vg_p->coord, p3, 0.5);
#endif
			/* Combine the two vertices */
			nmg_jv(v1b, v2);
			vu2_final = nmg_insert_fu_vu_in_other_list( is, is->l1, v1b, fu2 );
			if(fu1) nmg_ck_v_in_2fus(v1b, fu1, fu2, &is->tol);
		} else {
			/* Insert copy of this vertex into face */
			if (rt_g.NMG_debug & DEBUG_POLYSECT)
			    	VPRINT("Making vertexloop",
			    		v1b->vg_p->coord);

			plu = nmg_mlv(&fu2->l.magic, v1b, OT_BOOLPLACE);
			nmg_loop_g(plu->l_p, &is->tol);
			vu2_final = RT_LIST_FIRST( vertexuse, &plu->down_hd );
			NMG_CK_VERTEXUSE(vu2_final);
			(void)nmg_tbl(is->l2, TBL_INS_UNIQUE, &vu2_final->l.magic);
		}
d2742 2
a2743 7
		(void)nmg_tbl(list, TBL_INS_UNIQUE, &vu1a->l.magic);
		(void)nmg_tbl(list, TBL_INS_UNIQUE, &vu1b->l.magic);
/* XXX XYZZY What happens here?  Do vu's get added to other list??? */
		nmg_insert_fu_vu_in_other_list( is, list, vu1a->v_p, fu2 );
		nmg_insert_fu_vu_in_other_list( is, list, vu1b->v_p, fu2 );
nmg_enlist_vu(is, vu1a);
nmg_enlist_vu(is, vu1b);
d2760 1
a2760 4
		(void)nmg_tbl(list, TBL_INS_UNIQUE, &vu1a->l.magic);
		nmg_insert_fu_vu_in_other_list( is, list, vu1a->v_p, fu2 );
nmg_enlist_vu(is, vu1a);
		nmg_ck_face_worthless_edges( fu1 );
d2767 1
a2767 4
		(void)nmg_tbl(list, TBL_INS_UNIQUE, &vu1b->l.magic);
		nmg_insert_fu_vu_in_other_list( is, list, vu1b->v_p, fu2 );
nmg_enlist_vu(is, vu1b);
		nmg_ck_face_worthless_edges( fu1 );
d2807 2
a2808 2
		/* if we can't find the appropriate vertex in the other
		 * shell by a geometry search, build a new vertex.
a2814 1
		(void)nmg_tbl(list, TBL_INS_UNIQUE, &vu1_final->l.magic);
d2822 1
a2822 1
				rt_log("\t\tre-using vertex v=x%x from face, vu=x%x\n", new_v, vu1_final);
d2824 1
a2824 2
		nmg_insert_fu_vu_in_other_list( is, list, vu1_final->v_p, fu2 );
nmg_enlist_vu(is, vu1_final);
d2868 1
a2868 2
	(void)nmg_tbl(list1, TBL_INS_UNIQUE, &vu1->l.magic);
	(void)nmg_insert_fu_vu_in_other_list( is, list1, vu1->v_p, fu2 );
a3003 3
		/* XXX Should do same thing as nmg_edge_geom_isect_line() does in
		 * XXX nmg_fcut.c, and force edge geom to isect line if it has none.
		 */
d3023 2
a3024 6
		(void)nmg_tbl(list, TBL_INS_UNIQUE, &vu1a->l.magic);
		(void)nmg_tbl(list, TBL_INS_UNIQUE, &vu1b->l.magic);
		nmg_insert_fu_vu_in_other_list( is, list, vu1a->v_p, fu2 );
		nmg_insert_fu_vu_in_other_list( is, list, vu1b->v_p, fu2 );
nmg_enlist_vu(is, vu1a);
nmg_enlist_vu(is, vu1b);
d3070 1
a3070 3
			(void)nmg_tbl(list, TBL_INS_UNIQUE, &vu1a->l.magic);
			nmg_insert_fu_vu_in_other_list( is, list, vu1a->v_p, fu2 );
nmg_enlist_vu(is, vu1a);
d3076 1
a3076 3
			(void)nmg_tbl(list, TBL_INS_UNIQUE, &vu1b->l.magic);
			nmg_insert_fu_vu_in_other_list( is, list, vu1b->v_p, fu2 );
nmg_enlist_vu(is, vu1b);
a3140 1
			(void)nmg_tbl(list, TBL_INS_UNIQUE, &vu1_final->l.magic);
d3152 1
a3152 2
			nmg_insert_fu_vu_in_other_list( is, list, hit_v, fu2 );
nmg_enlist_vu(is, vu1_final);
@


10.134
log
@Fixed bug in nmg_break_eu_on_v() 
@
text
@d54 1
a54 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.133 94/04/20 20:55:57 mike Exp Locker: mike $ (ARL)";
d76 2
d113 100
d906 2
a907 2
 *  The vertexuse 'vu' is known to lie in the plane of eu's face.
 *  If vu lies between the two endpoints of eu, break eu and
d2386 2
d2698 2
d2735 2
d2888 2
d2908 1
d2918 1
d2978 1
d3185 2
d3234 1
d3242 1
d3320 1
d3487 2
d3522 2
d4022 1
d4029 1
d4215 2
d4258 2
d4269 1
a4272 7
#if 0
		/* XXX Test16.r.  This is not the correct fix.  Leave out. */
		/* Intersect all "interior" edges that got missed by generic. */
		/* This may make additional wire loops in s2 */
		nmg_isect_face3p_shell_int( &is, fu1, s2 );
#endif

d4276 1
a4276 1
		 *  finding the intersection points (vertices)
d4278 2
d4281 1
d4310 3
a4312 1
	/*  Check each wire loop of shell 1 against all of shell 2. */
@


10.133
log
@When breaking colinear edges, have to join them too.
@
text
@d54 1
a54 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.132 94/04/20 00:52:38 mike Exp Locker: mike $ (ARL)";
d808 5
d874 1
a874 1
		nmg_jv( v1a, v2 );
d878 1
a878 1
		nmg_jv( v1b, v2 );
d899 1
a899 1
 *  This can result in 2 new edgeuses showing up in either loop.
@


10.132
log
@Added another way of handling the mutual intersection of
two colinear edgeuses.
@
text
@a2 3
/* XXX Move to nmg.h */
#define NMG_TBL_LASTADDR(p)	((p)->buffer + (p)->end - 1)

d54 1
a54 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.131 94/04/19 19:54:36 mike Exp Locker: mike $ (ARL)";
d954 9
@


10.131
log
@Got rid of NO_SEARCH #ifdef stuff.
@
text
@d57 1
a57 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.130 94/04/19 19:53:59 mike Exp Locker: mike $ (ARL)";
d396 2
d805 160
a1050 2
	if(fu1)nmg_ck_face_worthless_edges( fu1 );
	if(fu2)nmg_ck_face_worthless_edges( fu2 );
d1052 1
a1052 1
	if( status != 0 )  return ret;
d1062 1
d1354 13
@


10.130
log
@Narrowing in on worthless edge source
@
text
@a0 1
#define NO_SEARCH	0	/* Don't search for a vert for nmg_ebreak() */
d57 1
a57 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.129 94/04/19 16:12:39 mike Exp Locker: mike $ (ARL)";
a689 3
#if NO_SEARCH
	v2 = (struct vertex *)NULL;
#else
a690 1
#endif
a1342 3
#if NO_SEARCH
			new_v2 = (struct vertex *)NULL;
#else
a1343 1
#endif
a2666 3
#if NO_SEARCH
		new_v = (struct vertex *)NULL;
#else
a2667 1
#endif
@


10.129
log
@Marker self-loops are indicated as OT_BOOLPLACE now, rather than OT_UNSPEC.
If they get attached to something else, they will be reassessed.
@
text
@d58 1
a58 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.128 94/04/19 07:12:56 mike Exp Locker: mike $ (ARL)";
d894 3
a896 1
	
d907 2
d974 1
a974 1
		rt_log("nmg_isect_two_colinear_edge2p(x%x, x%x) %s\n", eu1, eu2, str);
d1123 4
a1126 3
	if (rt_g.NMG_debug & DEBUG_POLYSECT)
		rt_log("nmg_isect_edge2p_edge2p(eu1=x%x, eu2=x%x, fu1=x%x, fu2=x%x)\n\tvu1a=%x vu1b=%x, vu2a=%x vu2b=%x\n\tv1a=%x v1b=%x,   v2a=%x v2b=%x\n",
			eu1, eu2, fu1, fu2,
d1129 1
a3030 1
			nmg_ck_face_worthless_edges( fu1 );
@


10.128
log
@Took out the rt_bomb(), it isn't called for.
@
text
@d58 1
a58 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.127 94/04/19 07:01:20 mike Exp Locker: mike $ (ARL)";
d156 1
a156 1
	plu = nmg_mlv(&fu2->l.magic, v, OT_UNSPEC);
d527 1
a527 1
	lu2 = nmg_mlv(&fu2->l.magic, vu1->v_p, OT_UNSPEC);
d604 1
a604 1
	plu = nmg_mlv(&fu->l.magic, vu->v_p, OT_UNSPEC);
d779 1
a779 1
		plu2 = nmg_mlv(&fu2->l.magic, vu1_final->v_p, OT_UNSPEC);
d1311 1
a1311 1
				plu = nmg_mlv(magic1, vu2a->v_p, OT_UNSPEC);
d1327 1
a1327 1
				plu = nmg_mlv(magic1, vu2b->v_p, OT_UNSPEC);
d1452 1
a1452 1
		plu = nmg_mlv(magic2, vu1a->v_p, OT_UNSPEC);
d1468 1
a1468 1
		plu = nmg_mlv(magic2, vu1b->v_p, OT_UNSPEC);
d1766 1
a1766 1
			plu = nmg_mlv(&fu2->l.magic, v1a, OT_UNSPEC);
d1823 1
a1823 1
			plu = nmg_mlv(&fu2->l.magic, v1b, OT_UNSPEC);
@


10.127
log
@This version works as well as the old one did, and can do
some of the Big Wedge cases (m1 and m2, m11, m3).
@
text
@d58 1
a58 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.126 94/04/19 05:26:34 mike Exp Locker: mike $ (ARL)";
d2974 2
d2986 3
a2988 3
			rt_log("rt_isect_pt2_lseg2() returned %d, ldist=%g, dist[0]=%e\n", code, ldist, dist[0]);
			rt_bomb("not on line of AB within tolerance??\n");
			continue;
d3025 1
@


10.126
log
@Added nmg_isect_line2_edgegeom2p().
For all edge geometry, only calculates the line of intersection once.
@
text
@d58 1
a58 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.125 94/04/18 06:05:47 mike Exp Locker: mike $ (ARL)";
d2866 2
d2889 1
a2889 1
			rt_log("\t\tedge colinear with isect line.  Listing vu1a, vu1b\n");
d2908 7
a2915 1
	VJOIN1( hit3d, is->pt, dist[0], is->dir );
d2927 1
a2927 1
			rt_log("\t\tConsidering *eup=x%x\n", *eup);
d2938 1
a2938 3
				rt_log("\t\tlisting intersect point at vu1a=x%x\n", vu1a);
			if( !rt_pt3_pt3_equal(hit3d, vu1a->v_p->vg_p->coord, &(is->tol) ) )
				rt_bomb("vu1a does not match calculated point\n");
d2945 1
a2945 3
				rt_log("\t\tlisting intersect point at vu1b=x%x\n", vu1b);
			if( !rt_pt3_pt3_equal(hit3d, vu1b->v_p->vg_p->coord, &(is->tol) ) )
				rt_bomb("vu1b does not match calculated point\n");
a2950 1
		/* Second, a geometry check on the edgeuse line segment */
d2954 11
d2968 1
a2968 1
			rt_log("\t\trt_isect_pt2_lseg2() returned %d, ldist=%e\n", code, ldist);
d2974 2
d2979 2
d2984 1
a2984 1
			rt_log("rt_isect_pt2_lseg2() returned %d, ldist=%e, dist[0]=%e\n", code, ldist, dist[0]);
d2990 1
a2990 1
			if (rt_g.NMG_debug & DEBUG_POLYSECT) rt_log("\t\thit_v = x%x (vu1a)\n", hit_v);
d2995 1
a2995 1
			if (rt_g.NMG_debug & DEBUG_POLYSECT) rt_log("\t\thit_v = x%x (vu1b)\n", hit_v);
d3005 2
d3015 1
a3015 1
					rt_log("\t\tmaking new vertex vu=x%x hit_v=x%x\n",
d3019 1
a3019 1
					rt_log("\t\tre-using hit_v=x%x, vu=x%x\n", hit_v, vu1_final);
@


10.125
log
@Added 'tol' argument to rt_between().
Added some extra error checking.
@
text
@d4 8
d54 1
a54 1
 *	This software is Copyright (C) 1993 by the United States Army
d58 1
a58 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.124 94/04/08 00:52:57 mike Exp Locker: mike $ (ARL)";
d423 1
a423 1
	VSUB2( is->dir, endpt, is->pt );
d1150 1
a1150 1
	VSUB2( eu1_dir, eu1_end, eu1_start );
d1154 1
a1154 1
	VSUB2( eu2_dir, eu2_end, eu2_start );
d2571 1
a2571 1
	VSUB2( eu1_dir, eu1_end, eu1_start );
d2735 1
d2737 280
d3040 2
d3047 2
d3053 3
d3094 1
d3096 6
a3101 1
			nbreak += nmg_isect_line2_edge2p( is, list, eu1, fu1, fu2 );
d3103 2
a3104 2
nmg_fu_touchingloops(fu1);
nmg_region_v_unique( fu1->s_p->r_p, &is->tol );
d3115 1
@


10.124
log
@#ifdef's for an experiment
@
text
@d50 1
a50 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.123 94/03/04 23:13:53 mike Exp Locker: mike $ (ARL)";
d2634 4
a2637 1
		    	VPRINT("\t\t2d: Breaking eu1 at isect. 3D pt=", hit_pt);
d2642 1
a2642 1
			rt_log("rt_isect_pt_lseg() dist=%g, ret=%d\n", dist, code);
d2644 11
@


10.123
log
@Made the pesky shared face message conditional.

@
text
@d1 2
a2 1
#define NEWLINE 1
d50 1
a50 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.122 94/03/04 04:28:19 mike Exp Locker: mike $ (ARL)";
d683 3
d687 1
d1334 3
d1338 1
d2159 1
d2164 1
d2191 1
d2196 1
d2294 1
d2299 1
d2322 1
d2327 1
d2344 1
d2349 1
d2648 3
d2652 1
d2766 1
d2769 1
d2786 1
d2789 1
d2793 1
d2796 1
@


10.122
log
@Check status code.
Added more debugging.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.121 94/02/23 03:23:45 mike Exp Locker: mike $ (ARL)";
d2972 3
a2974 1
		rt_log("co-planar faces (shared fg)\n");
d3030 1
a3030 1
rt_log("co-planar faces (rt_isect_2planes).\n");
@


10.121
log
@Isect_faces%d.pl is now Iface%d.pl, for brevity.
After doing 2-D face intersections, added *lots* of debug plotting.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.120 94/02/08 11:02:28 jra Exp Locker: mike $ (ARL)";
d2568 1
d2582 1
a2582 1
	if( dist[1] == 0 )  {
d2585 2
d2591 1
a2591 1
	} else if( dist[1] == 1 )  {
d2594 2
d2604 19
a2622 2
		if (rt_g.NMG_debug & DEBUG_POLYSECT)
		    	VPRINT("\t\tBreaking eu1 at intersect point (2d)", hit_pt);
@


10.120
log
@Made nmg_isect_two_generic_faces available outside this module.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.119 94/02/02 00:39:12 mike Exp Locker: jra $ (ARL)";
d2088 1
a2088 2
    		static int fno=1;
    	    	nmg_pl_2fu( "Isect_2d_faces%d.pl", fno++, fu2, fu1, 0 );
d2388 1
a2388 2
	    		static int fno=1;
	    	    	nmg_pl_2fu( "Isect_faces%d.pl", fno++, fu1, fu2, 0 );
d2804 1
a2804 2
    		static int fno=1;
    	    	nmg_pl_2fu( "Isect_faces%d.pl", fno++, fu1, fu2, 0 );
d3029 33
@


10.119
log
@Oops, I forgot to put back the shared topology check.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.118 94/02/02 00:11:57 mike Exp Locker: mike $ (ARL)";
d2906 1
a2906 1
static void
@


10.118
log
@Fusing new common edges is now done inside nmg_face_cutjoin(),
rather than by each of the (two) callers in nmg_inter.c
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.117 94/02/01 22:33:41 mike Exp Locker: mike $ (ARL)";
a2056 2
#if 0
/* XXX There may be multiple edges, loops to cut/merge, etc. Can't just cop out here. */
a2073 1
#endif
@


10.117
log
@Clarification of the role of the intersector.
Removed bogus Test16 "fix" 
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.116 94/01/29 00:22:08 mike Exp Locker: mike $ (ARL)";
d2057 2
d2076 1
a2231 2
nmg_region_v_unique( is->s2->r_p, &is->tol );
nmg_region_v_unique( is->s1->r_p, &is->tol );
a2234 3
nmg_region_v_unique( is->s2->r_p, &is->tol );
nmg_region_v_unique( is->s1->r_p, &is->tol );
	if(fu1) nmg_mesh_faces(fu2, fu1, &is->tol);
a2466 6
	}

	nmg_mesh_faces(fu1, fu2, &is->tol);
	if( rt_g.NMG_debug & DEBUG_VERIFY )  {
nmg_fu_touchingloops(fu1);
nmg_fu_touchingloops(fu2);
@


10.116
log
@nmg_isect_two_colinear_edge2p_both_ways() worked on.
Not much testing yet.
@
text
@d11 9
d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.115 94/01/27 05:22:13 mike Exp Locker: jra $ (ARL)";
d3555 2
d3560 1
@


10.115
log
@nmg_isect_two_colinear_edge2p_both_ways() added,
worked on nmg_isect_edge3p_edge3p().
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.114 94/01/26 18:44:40 mike Exp Locker: mike $ (ARL)";
d51 5
d790 1
a790 1
int
d805 6
a810 3
	fastf_t	eu2dist[2];
	fastf_t	ptol;
	int	ret = 0;
d829 1
d835 1
d849 3
a851 3
		if (rt_g.NMG_debug & DEBUG_POLYSECT) {
	rt_log("\trt_isect_line2_lseg2()=%d, eu2dist: %g, %g\n",
			status, eu2dist[0], eu2dist[1] );
d854 6
d861 15
d1034 4
a1037 4
 *	0	no intersection
 *	1	intersection was at (at least one) shared vertex
 *	2	eu1 was split at (geometric) intersection.
 *	4	eu2 was split at (geometric) intersection.
a1038 5
#define ISECT_NONE	0
#define ISECT_SHARED_V	1
#define ISECT_SPLIT1	2
#define ISECT_SPLIT2	4

d1173 2
a1174 1
			eu1, eu2, fu1, fu2, &is->tol );
a3106 1
	/* A is vu2a, B is vu2b */
d3124 1
d3134 1
d3137 1
@


10.114
log
@Fleshed out nmg_isect_vertex3_edge3p()
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.113 94/01/26 17:58:35 mike Exp Locker: mike $ (ARL)";
d781 75
d912 2
a913 2
	NMG_CK_FACEUSE(fu1);
	NMG_CK_FACEUSE(fu2);
d918 2
a919 2
	nmg_ck_face_worthless_edges( fu1 );
	nmg_ck_face_worthless_edges( fu2 );
d944 1
a944 1
		nmg_ck_v_in_2fus(vu1a->v_p, fu1, fu2, tol);
d951 1
a951 1
		nmg_ck_v_in_2fus(vu1a->v_p, fu1, fu2, tol);
d963 2
a964 2
		nmg_ck_face_worthless_edges( fu1 );
		nmg_ck_face_worthless_edges( fu2 );
d974 1
a974 1
		nmg_ck_v_in_2fus(vu1a->v_p, fu1, fu2, tol);
d981 1
a981 1
		nmg_ck_v_in_2fus(vu1b->v_p, fu1, fu2, tol);
d987 2
a988 2
		nmg_ck_face_worthless_edges( fu1 );
		nmg_ck_face_worthless_edges( fu2 );
d1144 2
a1145 11
		fastf_t	eu2dist[2];
		fastf_t	ptol;

		/*
		 *  Special case of colinear overlapping edges.
		 *  There may be 2 intersect points.
		 *  dist[1] has special meaning for this return status:
		 *  it's distance w.r.t. eu1's 1st point (vu1a), not eu2's 1st.
		 *  Find break points on eu1 caused by vu2[ab].
		 */
		if( nmg_isect_two_colinear_edge2p( dist, is->l1, is->l2,
d1147 1
a1147 39
			eu1, eu2, fu1, fu2, &is->tol, "eu1/eu2" )
		   > 0
		)  {
			ret |= ISECT_SPLIT1;	/* eu1 was broken */
		}

		/*
		 *  If the segments only partially overlap, need to intersect
		 *  the other way as well.
		 *  Find break points on eu2 caused by vu1[ab].
		 */
		if( fabs(eu2_dir[X]) >= fabs(eu2_dir[Y]) )  {
			eu2dist[0] = (eu1_start[X] - eu2_start[X])/eu2_dir[X];
			eu2dist[1] = (eu1_start[X] + eu1_dir[X] - eu2_start[X])/eu2_dir[X];
		} else {
			eu2dist[0] = (eu1_start[Y] - eu2_start[Y])/eu2_dir[Y];
			eu2dist[1] = (eu1_start[Y] + eu1_dir[Y] - eu2_start[Y])/eu2_dir[Y];
		}
		/* Tolerance processing */
		ptol = is->tol.dist / sqrt( eu2_dir[X]*eu2_dir[X] + eu2_dir[Y]*eu2_dir[Y] );
		if( eu2dist[0] > -ptol && eu2dist[0] < ptol )  eu2dist[0] = 0;
		else if( eu2dist[0] > 1-ptol && eu2dist[0] < 1+ptol ) eu2dist[0] = 1;

		if( eu2dist[1] > -ptol && eu2dist[1] < ptol )  eu2dist[1] = 0;
		else if( eu2dist[1] > 1-ptol && eu2dist[1] < 1+ptol ) eu2dist[1] = 1;

		if (rt_g.NMG_debug & DEBUG_POLYSECT) {
			rt_log("\trt_isect_line2_lseg2()=%d, eu2dist: %g, %g\n",
				status, eu2dist[0], eu2dist[1] );
			rt_log("ptol = %g, eu2dist=%g, %g\n", ptol, eu2dist[0], eu2dist[1]);
		}

		/*  Find break points on eu2 caused by vu1[ab]. */
		if( nmg_isect_two_colinear_edge2p( eu2dist, is->l2, is->l1,
			vu2a, vu2b, vu1a, vu1b,
			eu2, eu1, fu2, fu1, &is->tol, "eu2/eu1" )
		> 0 )  {
			ret |= ISECT_SPLIT2;	/* eu2 was broken */
		}
d1154 1
a1154 1
	/* The ray defined by the edgeuse intersects the eu2.
d3040 2
d3047 1
d3080 2
a3081 1
	status = rt_isect_line_lseg( dist,
d3094 1
d3096 1
d3098 11
a3109 2
	/* XXX More goes here */
/* XXXXXXXXXXXXXXXXXXXXXXX */
d3111 46
a3156 1
	rt_bomb("nmg_isect_edge3p_edge3p\n");
@


10.113
log
@More careful about wires.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.112 94/01/26 17:40:19 mike Exp Locker: mike $ (ARL)";
d3073 2
d3077 1
a3077 1
nmg_isect_vertex3_edge3p( is, vu, eu )
d3079 2
a3080 2
struct vertexuse	*vu;
struct edgeuse		*eu;
d3082 3
d3087 2
a3088 2
	NMG_CK_VERTEXUSE(vu);
	NMG_CK_EDGEUSE(eu);
d3090 3
a3092 1
/* XXXXXXXXXXXXXXXXXXXX */
d3094 21
a3114 1
	rt_bomb("nmg_isect_vertex3_edge3p()\n");
d3172 1
a3172 1
		/* We can't fuse wire edges */
@


10.112
log
@When making the wire edge, fuse it with the original edge.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.111 94/01/25 09:44:18 mike Exp Locker: mike $ (ARL)";
d923 2
a924 1
 *  One or both of the edges may be wire edges.
d959 1
d962 2
d968 2
d986 10
d1153 1
a1153 1
			nmg_ck_v_in_2fus(vu1a->v_p, fu1, fu2, &is->tol);
d1162 1
a1162 1
			nmg_ck_v_in_2fus(vu1a->v_p, fu1, fu2, &is->tol);
d1170 2
a1171 2
		nmg_ck_face_worthless_edges( fu1 );
		nmg_ck_face_worthless_edges( fu2 );
d1197 1
a1197 1
			nmg_ck_v_in_2fus(vu1a->v_p, fu1, fu2, &is->tol);
d1206 1
a1206 1
			nmg_ck_v_in_2fus(vu1b->v_p, fu1, fu2, &is->tol);
d1215 2
a1216 2
		nmg_ck_face_worthless_edges( fu1 );
		nmg_ck_face_worthless_edges( fu2 );
d1234 1
a1234 1
				plu = nmg_mlv(&fu1->l.magic, vu2a->v_p, OT_UNSPEC);
d1250 1
a1250 1
				plu = nmg_mlv(&fu1->l.magic, vu2b->v_p, OT_UNSPEC);
d1265 1
a1265 1
			new_v2 = nmg_find_pt_in_model(fu2->s_p->r_p->m_p, hit_pt, &(is->tol) );
d1371 1
a1371 1
		plu = nmg_mlv(&fu2->l.magic, vu1a->v_p, OT_UNSPEC);
d1387 1
a1387 1
		plu = nmg_mlv(&fu2->l.magic, vu1b->v_p, OT_UNSPEC);
@


10.111
log
@Moved some stuff to nmg_info.c
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.110 94/01/23 05:58:46 mike Exp Locker: mike $ (ARL)";
d3201 10
a3210 3
	eu2 = nmg_meonvu( RT_LIST_FIRST( vertexuse, &lu2->down_hd ) );
	NMG_CK_EDGEUSE(eu2);
	(void)nmg_eusplit( eu1->eumate_p->vu_p->v_p, eu2 );
@


10.110
log
@Lots of minor fixes regarding handling of wire edges,
which don't have an associated faceuse.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.109 94/01/23 02:57:14 mike Exp Locker: mike $ (ARL)";
a50 21
/* XXX move to raytrach.h for nmg_info.c */
RT_EXTERN(struct vertex	*	nmg_find_pt_in_model, (CONST struct model *m,
				CONST point_t pt, CONST struct rt_tol *tol));
RT_EXTERN(struct edgeuse *	nmg_find_eu_in_face, (CONST struct vertex *v1,
				CONST struct vertex *v2, CONST struct faceuse *fu,
				CONST struct edgeuse *eup, int dangling_only));

RT_EXTERN(double		rt_dist_line2_point2, (CONST point_t pt,
				CONST vect_t dir, CONST point_t a));
RT_EXTERN(double		rt_distsq_line2_point2, (CONST point_t pt,
				CONST vect_t dir, CONST point_t a));

RT_EXTERN(struct edgeuse	*nmg_find_matching_eu_in_s, (
				CONST struct edgeuse *eu1, CONST struct shell *s2));

#define DIST_PT_PT(a,b)		sqrt( \
	((a)[X]-(b)[X])*((a)[X]-(b)[X]) + \
	((a)[Y]-(b)[Y])*((a)[Y]-(b)[Y]) + \
	((a)[Z]-(b)[Z])*((a)[Z]-(b)[Z]) )


d994 1
a994 2
	    	if( !wire && eu1->e_p != eu2->e_p )
	    		nmg_radial_join_eu(eu1, eu2, &is->tol );
d1983 1
a1983 1
		if( fu1 && fu2_eu->e_p != eu1->e_p )  {
d3024 1
a3024 4
	    	/* Don't mesh wire edges, nmg_radial_join_eu() can't do it. */
	    	if( eu1->e_p != eu2->e_p &&
		    *eu1->up.magic_p == NMG_LOOPUSE_MAGIC &&
		    *eu2->up.magic_p == NMG_LOOPUSE_MAGIC )
a3215 79
}

/*
 * XXX move to nmg_info.c
 *			N M G _ F I N D _ V _ I N _ S H E L L
 *
 *  Search shell "s" for a vertexuse that refers to vertex "v".
 *  For efficiency, the search is done on the uses of "v".
 *
 *  If "edges_only" is set, only a vertexuse from an edgeuse will
 *  be returned, otherwise, vu's from self-loops and lone-shell-vu's
 *  are also candidates.
 */
struct vertexuse *
nmg_find_v_in_shell( v, s, edges_only )
CONST struct vertex	*v;
CONST struct shell	*s;
int			edges_only;
{
	struct vertexuse	*vu;

	for( RT_LIST_FOR( vu, vertexuse, &v->vu_hd ) )  {
		NMG_CK_VERTEXUSE(vu);

		if( *vu->up.magic_p == NMG_LOOPUSE_MAGIC )  {
			if( edges_only )  continue;
			if( nmg_find_s_of_lu( vu->up.lu_p ) == s )
				return vu;
			continue;
		}
		if( *vu->up.magic_p == NMG_SHELL_MAGIC )  {
			if( edges_only )  continue;
			if( vu->up.s_p == s )
				return vu;
			continue;
		}
		if( *vu->up.magic_p != NMG_EDGEUSE_MAGIC )
			rt_bomb("nmg_find_v_in_shell(): bad vu up ptr\n");

		/* vu is being used by an edgeuse */
		if( nmg_find_s_of_eu( vu->up.eu_p ) == s )
			return vu;
	}
	return (struct vertexuse *)NULL;
}

/* XXX move to nmg_info.c */
/*
 *			N M G _ F I N D _ M A T C H I N G _ E U _ I N _ S
 *
 *  If shell s2 has an edge that connects the same vertices as eu1 connects,
 *  return the matching edgeuse in s2.
 */
struct edgeuse *
nmg_find_matching_eu_in_s( eu1, s2 )
CONST struct edgeuse	*eu1;
CONST struct shell	*s2;
{
	CONST struct vertexuse	*vu1a, *vu1b;
	struct vertexuse	*vu2a, *vu2b;
	struct edgeuse		*eu2;

	NMG_CK_EDGEUSE(eu1);
	NMG_CK_SHELL(s2);

	vu1a = eu1->vu_p;
	vu1b = RT_LIST_PNEXT_CIRC( edgeuse, eu1 )->vu_p;
	NMG_CK_VERTEXUSE(vu1a);
	NMG_CK_VERTEXUSE(vu1b);
	if( (vu2a = nmg_find_v_in_shell( vu1a->v_p, s2, 0 )) == (struct vertexuse *)NULL )
		return (struct edgeuse *)NULL;
	if( (vu2b = nmg_find_v_in_shell( vu1b->v_p, s2, 0 )) == (struct vertexuse *)NULL )
		return (struct edgeuse *)NULL;

	/* Both vertices have vu's of eu's in s2 */

	eu2 = nmg_findeu( vu1a->v_p, vu1b->v_p, s2,
	    (CONST struct edgeuse *)NULL, 0 );
	return eu2;		/* May be NULL if no edgeuse found */
@


10.109
log
@getting closer to a working Test16.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.108 94/01/22 23:23:16 mike Exp Locker: mike $ (ARL)";
d944 3
d980 1
d999 2
d1015 1
a1015 1
	    	if( eu1->e_p != eu2->e_p )
d1416 2
a1417 2
 *  Intersect an edge in fu1 with a (hopefully non-colinear/coplanar)
 *  face fu2.
d1419 3
a1421 2
 *  The line of intersection between the two faces has already been found
 *  at this point, up in nmg_isect_two_face2p().
d1472 1
a1472 2
	fu1 = nmg_find_fu_of_eu(eu1);
	NMG_CK_FACEUSE(fu1);
d1483 17
d1505 1
a1507 1
	NMG_GET_FU_PLANE( n2, fu2 );
d1541 1
d1564 1
d1684 1
a1684 1
			nmg_ck_v_in_2fus(v1a, fu1, fu2, &is->tol);
d1741 1
a1741 1
			nmg_ck_v_in_2fus(v1b, fu1, fu2, &is->tol);
d1764 2
a1765 1
		dist = rt_dist_line_point( is->pt, is->dir, vu1_final->v_p->vg_p->coord );
d1767 2
a1768 2
			rt_log("ERROR nmg_isect_edge3p_face3p() vu1=x%x point off line by %g > 100*dist_tol\n",
				dist);
d1779 1
a1779 1
		nmg_ck_v_in_2fus(vu1_final->v_p, fu1, fu2, &is->tol);
d1790 2
a1791 1
 *	Intersect a single loop with another face
d1942 2
d1991 1
a1991 1
	NMG_CK_FACEUSE(fu1);
d1997 1
a1997 1
	if( fu1->orientation != OT_SAME )  rt_bomb("nmg_isect_edge2p_face2p() fu1 not OT_SAME\n");
d2005 1
a2005 1
		if( fu2_eu->e_p != eu1->e_p )  {
d2025 1
a2025 1
	is->s1 = fu1->s_p;
d2028 1
a2028 1
    	if (rt_g.NMG_debug & (DEBUG_POLYSECT|DEBUG_FCUT|DEBUG_MESH)
d2094 3
a2096 3
nmg_fu_touchingloops(fu1);
nmg_region_v_unique( fu2->s_p->r_p, &is->tol );
nmg_region_v_unique( fu1->s_p->r_p, &is->tol );
d2124 3
a2126 3
nmg_fu_touchingloops(fu1);
nmg_region_v_unique( fu2->s_p->r_p, &is->tol );
nmg_region_v_unique( fu1->s_p->r_p, &is->tol );
d2141 1
a2141 1
	/* Now, run line of intersection through fu1 */
d2143 5
a2147 3
	total_splits += nmg_isect_line2_face2p( is, &vert_list1, fu1, fu2 );
	if (rt_g.NMG_debug & DEBUG_POLYSECT )
		rt_log("nmg_isect_edge2p_face2p(): lu=x%x, total_splits=%d B\n", lu, total_splits);
d2158 1
a2158 1
	nmg_purge_unwanted_intersection_points(&vert_list2, fu1, &is->tol);
d2170 3
a2172 3
nmg_fu_touchingloops(fu1);
nmg_region_v_unique( fu2->s_p->r_p, &is->tol );
nmg_region_v_unique( fu1->s_p->r_p, &is->tol );
d2176 3
a2178 3
nmg_region_v_unique( fu2->s_p->r_p, &is->tol );
nmg_region_v_unique( fu1->s_p->r_p, &is->tol );
	nmg_mesh_faces(fu2, fu1, &is->tol);
d2185 1
a2185 1
nmg_fu_touchingloops(fu1);
d3006 1
a3006 1
struct nmg_inter_struct		*is;
d3180 1
a3180 1
			nmg_isect_vertex3_edge3p( &is, vu2, eu1 );
d3185 1
a3185 1
			nmg_isect_edge3p_edge3p( &is, eu1, eu2 );
d3192 1
a3192 1
		nmg_isect_edge3p_edge3p( &is, eu1, eu2 );
d3197 1
a3197 1
		nmg_isect_vertex3_edge3p( &is, s2->vu_p, eu1 );
d3353 3
d3365 1
a3365 1
rt_log("nmg_isect_face3p_shell_int() eu1=x%x, eu2=x%x (nothing to do)\n", eu1, eu2);
d3380 2
d3484 1
d3497 2
a3498 2
			/* XXX what about return code here? */
			nmg_isect_loop3p_face3p( &is, lu2, fu1 );
d3501 1
a3501 1
		/* Check f1 from s1 against edges of s2 */
@


10.108
log
@nmg_isect_edge2p_edge2p() now returns a bit vector -- status for both edges.
Much better loop termination conditions in nmg_isect_edge2p_face2p() --
should not do any more infinite looping.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.107 94/01/22 05:24:47 mike Exp Locker: mike $ (ARL)";
d63 3
d1714 1
a1714 1
			nmg_jv(v1b, vu2_final->v_p);
d1743 3
d2072 1
d3071 2
a3072 3
 *  Intersect one wire edge with another shell.
 *  There is no face context, or intersection line, unless this edge
 *  happens to lie in the plane of one of the shell's faces.
d3074 22
a3095 2
 *  XXX If this edge is split, how to ensure that all eu's are visited?
 *  (Probably via a return code, and re-iteration)
d3103 1
d3107 2
d3114 18
d3136 3
a3138 2
		/* XXX _must_ look at return code here! */
		nmg_isect_edge3p_face3p( is, eu1, fu2 );
d3145 7
a3151 1
		/* XXX Can there be lone-vertex loops here? */
d3168 42
d3256 1
d3258 34
d3307 2
a3308 1
nmg_isect_face3p_shell_int( fu1, s2 )
d3316 1
a3326 2
			struct vertexuse	*vu1a, *vu1b;
			struct vertexuse	*vu2a, *vu2b;
d3329 1
a3329 14
			NMG_CK_EDGEUSE(eu1);
			vu1a = eu1->vu_p;
			vu1b = RT_LIST_PNEXT_CIRC( edgeuse, eu1 )->vu_p;
			NMG_CK_VERTEXUSE(vu1a);
			NMG_CK_VERTEXUSE(vu1b);
			if( (vu2a = nmg_find_v_in_shell( vu1a->v_p, s2, 0 )) == (struct vertexuse *)NULL )
				continue;
			if( (vu2b = nmg_find_v_in_shell( vu1b->v_p, s2, 0 )) == (struct vertexuse *)NULL )
				continue;

			/* Both vertices have vu's of eu's in s2 */

			eu2 = nmg_findeu( vu1a->v_p, vu1b->v_p, s2,
			    (CONST struct edgeuse *)NULL, 0 );
d3331 1
a3331 1
rt_log("nmg_isect_face3p_shell_int() eu2=x%x: v1=x%x, v2=x%x (nothing to do)\n", eu2, vu1a->v_p, vu1b->v_p);
d3341 1
a3341 3
rt_log("nmg_isect_face3p_shell_int() no eu: v1=x%x, v2=x%x (skipping)\n", vu1a->v_p, vu1b->v_p);
rt_bomb("nmg_isect_face3p_shell_int()\n");	/* needs finishing */
#if 0
a3342 1
#endif
d3448 1
a3448 1
		nmg_isect_face3p_shell_int( fu1, s2 );
@


10.107
log
@Working on nmg_isect_edge2p_face2p(), to prevent violating facecutter
parity requirements.  Not working yet.
Also, minor cleanups, moved some code to plane.c
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.106 94/01/20 05:15:59 mike Exp Locker: mike $ (ARL)";
d941 1
a941 1
 *  Returns -
d943 1
a943 1
 *	1	intersection was at a shared vertex
d945 1
d947 5
d1008 1
a1008 1
	    	ret = 1;
d1056 1
a1056 1
		ret = 1;
d1060 4
a1063 1
	if (status < 0)  return 0;	/* No geometric intersection */
d1079 4
a1082 2
		   > 0 )
			ret = 2;	/* eu1 was broken */
d1111 1
a1111 1
		(void)nmg_isect_two_colinear_edge2p( eu2dist, is->l2, is->l1,
d1113 5
a1117 3
			eu2, eu1, fu2, fu1, &is->tol, "eu2/eu1" );

		return ret;	/* indicate whether eu1 was broken or not */
d1137 2
a1138 1
			return 0;
d1151 2
a1152 1
			return 1;
d1160 2
a1161 1
			return 1;
d1170 2
a1171 1
		return 1;		/* eu1 not broken, just touched */
d1181 2
a1182 1
			return 0;
d1195 2
a1196 1
			return 1;
d1204 2
a1205 1
			return 1;
d1214 2
a1215 1
		return 1;		/* eu1 not broken, just touched */
d1238 2
a1239 1
			return 0;		/* eu1 was not broken */
d1254 2
a1255 1
			return 0;		/* eu1 was not broken */
d1275 2
a1276 1
			return 0;		/* eu1 was not broken */
d1280 1
a1280 1
		return 0;
d1294 1
d1303 1
d1313 1
a1324 1
	ret = 2;	/* eu1 was broken */
d1390 10
a1399 2
	if (rt_g.NMG_debug & DEBUG_POLYSECT)
		rt_log("nmg_isect_edge2p_edge2p(eu1=x%x, eu2=x%x) END, ret=%d\n", eu1, eu2, ret);
d1950 1
d2063 1
d2073 1
a2073 1
				if( nmg_isect_edge2p_vert2p( is, eu1, vu ) > 1 )
d2075 2
d2081 3
a2083 1
				if( nmg_isect_edge2p_edge2p( is, eu1, eu2, fu1, fu2 ) > 1 )
d2085 2
d2094 1
a2094 1
			rt_log("nmg_isect_edge2p_face2p(): another_pass=%d\n", lu, another_pass);
d2097 7
a2103 5
    	if (rt_g.NMG_debug & DEBUG_FCUT) {
	    	rt_log("nmg_isect_edge2p_face2p(eu1=x%x, fu2=x%x) vert_lists A:\n", eu1, fu2 );
    		nmg_pr_ptbl_vert_list( "vert_list1", &vert_list1 );
    		nmg_pr_ptbl_vert_list( "vert_list2", &vert_list2 );
    	}
a2104 20
	nmg_purge_unwanted_intersection_points(&vert_list1, fu2, &is->tol);
	nmg_purge_unwanted_intersection_points(&vert_list2, fu1, &is->tol);

    	if (rt_g.NMG_debug & DEBUG_FCUT) {
	    	rt_log("nmg_isect_edge2p_face2p(eu1=x%x, fu2=x%x) vert_lists B:\n", eu1, fu2 );
    		nmg_pr_ptbl_vert_list( "vert_list1", &vert_list1 );
    		nmg_pr_ptbl_vert_list( "vert_list2", &vert_list2 );
    	}

/* XXX If there were _no_ new intersections, IN EITHER FACE,
 * XXX then there is no need to
 * XXX call the face cutter here.  Otherwise, yes.
 * The return codes from nmg_isect_edge2p_edge2p() are presently inadequate.
 */

	if (vert_list1.end == 0 && vert_list2.end == 0) {
    		/* there were no intersections */
    		goto out;
    	}

d2107 3
a2109 1
	nmg_isect_line2_face2p( is, &vert_list1, fu1, fu2 );
d2111 2
d2128 1
a2128 4
    	if (vert_list1.end == 0 && vert_list2.end == 0) {
    		/* there were no intersections */
    		goto out;
    	}
d2411 3
d2415 1
a2415 1
void
d2431 1
d2487 1
d2504 1
d2511 1
d2526 1
d2544 2
a2545 1
		rt_log("nmg_isect_line2_edge2p(eu1=x%x, fu1=x%x) END\n", eu1, fu1);
d2596 3
d2600 1
a2600 1
void
d2608 1
d2650 1
d2655 1
a2655 1
			nmg_isect_line2_edge2p( is, list, eu1, fu1, fu2 );
d2666 1
a2666 1
		rt_log("nmg_isect_line2_face2p(fu1=x%x) END\n", fu1);
d2668 1
a2668 1
	return;
d2725 2
a2726 1
	nmg_isect_line2_face2p(is, &vert_list1, fu1, fu2);
d2752 1
a2752 1
	nmg_isect_line2_face2p(is, &vert_list2, fu2, fu1);
@


10.106
log
@Added nmg_find_v_in_shell(),
nmg_isect_face3p_shell_int().
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.105 93/12/27 22:45:28 mike Exp Locker: mike $ (ARL)";
d54 3
d58 4
d63 4
a66 5
/* XXX move to vmath.h */
#define VDOT_2D(a,b)	( (a)[X]*(b)[X] + (a)[Y]*(b)[Y] )
#define VSUB2_2D(a,b,c)	{ \
			(a)[X] = (b)[X] - (c)[X];\
			(a)[Y] = (b)[Y] - (c)[Y]; }
a68 42
/* XXX move to plane.c */
/*
 *			R T _ D I S T _ L I N E 2 _ P O I N T 2
 *
 *  Given a parametric line defined by PT + t * DIR and a point A,
 *  return the closest distance between the line and the point.
 *  It is necessary that DIR have unit length.
 *
 *  Return -
 *	Distance
 */
double
rt_dist_line2_point2( pt, dir, a )
CONST point_t	pt;
CONST vect_t	dir;
CONST point_t	a;
{
	LOCAL vect_t		f;
	register fastf_t	FdotD;

	VSUB2_2D( f, pt, a );
	FdotD = VDOT_2D( f, dir );
	if( (FdotD = VDOT_2D( f, f ) - FdotD * FdotD ) <= SMALL_FASTF )
		return(0.0);
	return( sqrt(FdotD) );
}
double
rt_distsq_line2_point2( pt, dir, a )
CONST point_t	pt;
CONST vect_t	dir;
CONST point_t	a;
{
	LOCAL vect_t		f;
	register fastf_t	FdotD;

	VSUB2_2D( f, pt, a );
	FdotD = VDOT_2D( f, dir );
	if( (FdotD = VDOT_2D( f, f ) - FdotD * FdotD ) <= SMALL_FASTF )
		return(0.0);
	return( FdotD );
}

a666 4
#define DIST_PT_PT(a,b)		sqrt( \
	((a)[X]-(b)[X])*((a)[X]-(b)[X]) + \
	((a)[Y]-(b)[Y])*((a)[Y]-(b)[Y]) + \
	((a)[Z]-(b)[Z])*((a)[Z]-(b)[Z]) )
d1888 7
d1924 1
a1924 1
		rt_log("nmg_isect_edge2p_face2p(eu1=x%x, fu2=x%x, fu1=x%x)\n", eu1, fu2, fu1);
d1930 2
a1931 3
	/* XXX This searches whole other shell.  Should be shared w/fu2, but... */
	fu2_eu = nmg_findeu( eu1->vu_p->v_p, eu1->eumate_p->vu_p->v_p,
	    fu2->s_p, (CONST struct edgeuse *)NULL, 0 );
a1938 2
			/* Topology is completely shared */
			goto do_ret;
d1940 5
d1947 3
d2006 1
a2006 1
	/* Start point will line on min side of face RPP */
d2027 1
a2027 1
	/* Run through the list until no more edges are split */
d2030 1
d2070 30
a2178 2
			/* XXX What about return code here? */
			nmg_isect_edge2p_face2p( is, eu, fu2, fu1 );
d2180 4
a2183 9
			/* XXX "eu" may have been simplified away! */
			if( eu->l.magic != NMG_EDGEUSE_MAGIC ) goto f1_again;

			/* "eu" may have moved to another loop,
			 * need to abort for() to avoid getting
			 * RT_LIST_NEXT on wrong linked list!
			 */
			NMG_CK_EDGEUSE(eu);
			if(eu->up.lu_p != lu)  goto f1_again;
a2204 2
			/* XXX What about return code here? */
			nmg_isect_edge2p_face2p( is, eu, fu1, fu2 );
d2206 4
a2209 6
			/* XXX "eu" may have been simplified away! */
			if( eu->l.magic != NMG_EDGEUSE_MAGIC ) goto f1_again;

			/* "eu" may have moved to another loop */
			NMG_CK_EDGEUSE(eu);
			if(eu->up.lu_p != lu )  goto f2_again;
d3173 1
@


10.105
log
@Moved bounding box for faces from struct face_g to struct face.
Necessary because face geometry is now shared by multiple faces
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.104 93/12/22 06:13:47 mike Exp Locker: mike $ (ARL)";
d3057 1
d3085 116
d3298 3
@


10.104
log
@Indicate whether co-planar detection is by shared face geometry, or
by rt_isect_2planes().
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.103 93/12/03 03:35:27 mike Exp Locker: mike $ (ARL)";
d371 1
a371 1
	VADD2SCALE( centroid, fg->max_pt, fg->min_pt, 0.5 );
d2011 3
a2013 8
	/* XXX Prevent ray from missing 0-thickness face */
	/* XXX should be done in nmg_loop_g() for real */
	min_pt[X] = fu2->f_p->fg_p->min_pt[X] - 10*is->tol.dist;
	min_pt[Y] = fu2->f_p->fg_p->min_pt[Y] - 10*is->tol.dist;
	min_pt[Z] = fu2->f_p->fg_p->min_pt[Z] - 10*is->tol.dist;
	max_pt[X] = fu2->f_p->fg_p->max_pt[X] + 10*is->tol.dist;
	max_pt[Y] = fu2->f_p->fg_p->max_pt[Y] + 10*is->tol.dist;
	max_pt[Z] = fu2->f_p->fg_p->max_pt[Z] + 10*is->tol.dist;
d2020 2
a2021 2
			VPRINT("fu2 min", fu2->f_p->fg_p->min_pt);
			VPRINT("fu2 max", fu2->f_p->fg_p->max_pt);
d2030 2
a2031 2
		VPRINT("fu2 min", fu2->f_p->fg_p->min_pt);
		VPRINT("fu2 max", fu2->f_p->fg_p->max_pt);
d2840 2
a2841 2
	if ( !V3RPP_OVERLAP_TOL(f2->fg_p->min_pt, f2->fg_p->max_pt,
	    f1->fg_p->min_pt, f1->fg_p->max_pt, &bs.tol) )  return;
d2862 2
a2863 2
	VMOVE(min_pt, f1->fg_p->min_pt);
	VMIN(min_pt, f2->fg_p->min_pt);
d3167 1
a3167 1
		    f1->fg_p->min_pt, f1->fg_p->max_pt, tol) )
@


10.103
log
@Access to plane equation / surface normal in face_geometry structure
is now done through macros NMG_GET_FU_PLANE() NMG_GET_FU_NORMAL(),
which honor the f->flip flag.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.102 93/11/18 02:09:15 mike Exp Locker: mike $ (ARL)";
d2840 5
d2897 2
a2898 1
rt_log("co-planar faces.\n");
@


10.102
log
@Bounding box routines now all take a tol arg.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.101 93/11/12 22:40:13 mike Exp $ (ARL)";
d293 1
d297 2
a298 1
			PLPRINT("fu->f_p N", fu->f_p->fg_p->N);
d334 1
d344 6
d351 2
a352 2
		rt_log("nmg_isect2d_prep(f=x%x)\n", f1);
		PLPRINT("N", fg->N);
d370 1
a370 1
	mat_fromto( is->proj, fg->N, to );
d373 1
a373 1
	centroid_proj[Z] = fg->N[3];	/* pull dist from origin off newZ */
d582 1
d605 2
a606 1
	dist = DIST_PT_PLANE(pt, fu->f_p->fg_p->N);
d1447 1
d1487 1
d1489 1
a1489 1
		fu2->f_p->fg_p->N, &is->tol);
d1575 1
a1575 1
		dist = VDOT( start_pt, fu2->f_p->fg_p->N ) - fu2->f_p->fg_p->N[3];
d1779 1
d1783 2
a1784 1
		HPRINT("  fg N", fu->f_p->fg_p->N);
d2801 1
a2801 1
	fastf_t		*pl1, *pl2;
d2822 3
a2826 2
		pl1 = f1->fg_p->N;
		pl2 = f2->fg_p->N;
d2864 1
a2864 1
	status = rt_isect_2planes( bs.pt, bs.dir, f1->fg_p->N, f2->fg_p->N,
d2879 3
@


10.101
log
@Added nmg_isect2d_cleanup() and nmg_isect2d_final_cleanup().
The latter function is a hack intended strictly for the longjmp()
handler used in G-JACK to run the reportcard
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.100 93/10/29 04:12:37 mike Exp Locker: mike $ (ARL)";
d188 1
a188 1
	nmg_loop_g(plu->l_p);
d346 1
a346 1
	m = nmg_find_model( &f1->magic );
d550 1
a550 1
	nmg_loop_g( lu2->l_p );
d625 1
a625 1
	nmg_loop_g(plu->l_p);
d802 1
a802 1
		nmg_loop_g(plu2->l_p);
d1240 1
a1240 1
				nmg_loop_g(plu->l_p);
d1255 1
a1255 1
				nmg_loop_g(plu->l_p);
d1372 1
a1372 1
		nmg_loop_g(plu->l_p);
d1388 1
a1388 1
		nmg_loop_g(plu->l_p);
d1657 1
a1657 1
			nmg_loop_g(plu->l_p);
d1714 1
a1714 1
			nmg_loop_g(plu->l_p);
@


10.100
log
@Added more checking
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.99 93/10/27 19:31:47 mike Exp Locker: mike $ (ARL)";
d142 1
d144 1
d336 2
d374 35
d1507 1
a1507 1
		if( is2.vert2d )  rt_free( (char *)is2.vert2d, "vert2d");
d2182 1
a2182 4
	if(is->vert2d)  {
		rt_free( (char *)is->vert2d, "vert2d" );
		is->vert2d = NULL;
	}
d2590 1
a2590 4
	if(is->vert2d)  {
		rt_free( (char *)is->vert2d, "vert2d" );
		is->vert2d = NULL;
	}
d2886 1
a2886 1
	if(bs.vert2d)  rt_free( (char *)bs.vert2d, "vert2d" );
d3255 2
@


10.99
log
@Moved face simplification from the bottom of the face cutter
up to the bottom of nmg_isect_two_generic_faces().
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.98 93/10/26 06:15:30 mike Exp Locker: mike $ (ARL)";
d2564 1
d2868 2
@


10.98
log
@Extend vert2d array if it isn't large enough to start with.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.97 1993/10/25 01:31:55 cjohnson Exp $ (ARL)";
d2853 8
@


10.97
log
@Syntax fix for old K&R style compiler.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.96 1993/10/24 09:06:54 mike Exp cjohnson $ (ARL)";
d244 29
a272 1
	if( v->index >= is->maxindex )  rt_bomb("nmg_get_2d_vertex:  array overrun\n");
d345 1
a345 1
	is->vert2d = (fastf_t *)rt_malloc( 3 * is->maxindex * sizeof(fastf_t), "vert2d[]");
@


10.96
log
@Changed from find_pt_in_shell to find_pt_in_model.
Fixed bug in 2d intersection by swapping endpoints as necessary.
Added hack so that if "eu" is simplified out of existence, does not blow up.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.95 93/10/24 03:50:55 mike Exp Locker: mike $ (ARL)";
d630 2
a631 1
		struct rt_tol	t2 = is->tol;	/* Struct copy */
@


10.95
log
@Relaxed dependence on implicit ordering of faceuses in fu_hd list
as being OT_SAME, OT_OPPOSITE.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.94 93/10/23 07:42:27 mike Exp Locker: mike $ (ARL)";
d51 5
d647 1
a647 1
	v2 = nmg_find_pt_in_shell(fu2->s_p, hit_pt, &(is->tol));
d808 1
d825 15
a839 1
	if( dist[0] > dist[1] )  rt_bomb("nmg_isect_two_colinear_edge2p() dist [0] > [1]\n");
d842 1
a842 1
	if( dist[0] == 0 )  {
d849 1
a849 1
	} else if( dist[0] == 1 )  {
d856 1
a856 1
	} else if( dist[0] > 0 && dist[0] < 1 )  {
d872 1
a872 1
	if( dist[1] == 0 )  {
d879 1
a879 1
	} else if( dist[1] == 1 )  {
d886 1
a886 1
	} else if( dist[1] > 0 && dist[1] < 1 )  {
d1200 1
a1200 1
			new_v2 = nmg_find_pt_in_shell(fu2->s_p, hit_pt, &(is->tol) );
d1567 1
a1567 1
		v2 = nmg_find_pt_in_shell(fu2->s_p, v1a->vg_p->coord, &(is->tol));
d1624 1
a1624 1
		v2 = nmg_find_pt_in_shell(fu2->s_p, v1b->vg_p->coord, &(is->tol));
d2100 4
d2136 4
d2425 1
a2425 1
		new_v = nmg_find_pt_in_shell(fu2->s_p, hit_pt, &(is->tol));
@


10.94
log
@Added nmg_isect_line2_vertex2(), added support routines.
Eliminate stray vertices and unbreak edges at end of nmg_crackshells().
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.93 93/10/23 01:38:30 mike Exp Locker: mike $ (ARL)";
d2935 1
d3040 1
d3056 1
a3058 8

			/* try not to process redundant faceuses (mates) */
			if( RT_LIST_NOT_HEAD( fu2, &s2->fu_hd ) )  {
				register struct faceuse	*nextfu;
				nextfu = RT_LIST_PNEXT(faceuse, fu2 );
				if( nextfu->f_p == fu2->f_p )
					fu2 = nextfu;
			}
d3118 1
@


10.93
log
@Added double checking on nmg_insert_fu_vu_in_other_list
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.92 93/10/23 00:35:47 mike Exp Locker: mike $ (ARL)";
d51 49
d107 1
d110 2
a111 1
	int		coplanar;
d655 1
a655 1
		 * XXX It is probably cheaper to call rt_isect_3vertex_3face()
d2184 1
a2184 1
				rt_log("nmg_isect_two_generic_faces(): re-building intersection line A\n");
d2198 1
a2198 1
		    	rt_log("nmg_isect_two_generic_faces(fu1=x%x, fu2=x%x) vert_lists A:\n", fu1, fu2);
d2214 1
a2214 1
				rt_log("nmg_isect_two_generic_faces(): re-building intersection line B\n");
d2230 1
a2230 1
	    	rt_log("nmg_isect_two_generic_faces(fu1=x%x, fu2=x%x) vert_lists B:\n", fu1, fu2);
a2299 2
	point_t		line_start;	/* 2D */
	vect_t		line_dir;	/* 2D */
a2338 5
	/* XXX HACK: project line into 2D.  Matrix is valid from calls, above */
	/* XXX This should be done by caller */
	MAT4X3PNT( line_start, is->proj, is->pt );
	MAT4X3VEC( line_dir, is->proj, is->dir );

d2342 1
a2342 1
	status = rt_isect_line2_lseg2( dist, line_start, line_dir,
d2420 37
d2496 1
a2496 1
	/* Zap 2d cache, we may be switching faces now */
d2502 5
d2514 5
a2518 5
			struct vertexuse	*vu;
			/* Line hits a lone vertex self-loop */
			vu = RT_LIST_FIRST( vertexuse, &lu1->down_hd );
			NMG_CK_VERTEXUSE(vu);
			(void)nmg_tbl(list, TBL_INS_UNIQUE, &vu->l.magic);
d2606 1
a2606 1
	    	rt_log("nmg_isect_two_generic_faces(fu1=x%x, fu2=x%x) vert_lists A:\n", fu1, fu2);
d2632 1
a2632 1
	    	rt_log("nmg_isect_two_generic_faces(fu1=x%x, fu2=x%x) vert_lists B:\n", fu1, fu2);
a2796 4
	/* Eliminate stray vertices that were added in this step */
	(void)nmg_unbreak_region_edges( &fu1->l.magic );
	(void)nmg_unbreak_region_edges( &fu2->l.magic );

d3150 8
@


10.92
log
@When intersecting two faces, can't search other face for a likely
vertex, need to search the other shell.  Otherwise, this can lead to
nmg_region_v_unique():  2 verts are the same, within tolerance
because the necessary vertex already exists, but in another face.
(Typically a radial face).
Changed from nmg_find_pt_in_face() to nmg_find_pt_in_shell().
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.91 93/10/20 23:09:56 mike Exp Locker: mike $ (ARL)";
d55 2
d88 1
a88 1
 *		N M G _ I N S E R T _ O T H E R _ F U _ V _ I N _ L I S T
d90 8
a97 3
 *  Insert the vu from fu2 that corresponds to v1 onto
 *  the OTHER face's (fu2's) intersect list.
 *  If such a vu does not exist, make a self-loop in fu2.
d100 1
a100 1
nmg_insert_other_fu_v_in_list( is, list, v1, fu2 )
d102 2
a103 2
struct nmg_ptbl		*list;
struct vertex		*v1;
d109 1
d112 2
a113 2
	NMG_CK_PTBL(list);
	NMG_CK_VERTEX(v1);
d116 1
a116 1
	if( is->l1 == list )
d118 2
a119 1
	else
d121 4
a124 1
	if( vu2 = nmg_find_v_in_face( v1, fu2 ) )  {
d129 1
a129 1
	plu = nmg_mlv(&fu2->l.magic, v1, OT_UNSPEC);
d136 2
a137 2
		rt_log("nmg_insert_other_fu_v_in_list: v1=x%x, made self-loop for fu2: vu2=x%x\n",
			v1, vu2);
d599 1
a599 1
		vu2_final = nmg_insert_other_fu_v_in_list( is, is->l2, v2, fu2 );
d1126 1
d1129 6
a1134 2
			new_vu2 = nmg_ebreak( NULL, eu2 )->vu_p;
			nmg_vertex_gv( new_vu2->v_p, hit_pt );	/* 3d geom */
d1136 3
a1138 4
			plu = nmg_mlv(&fu1->l.magic, new_vu2->v_p, OT_UNSPEC);
			nmg_loop_g(plu->l_p);
			vu = RT_LIST_FIRST( vertexuse, &plu->down_hd );
			NMG_CK_VERTEXUSE(vu);
a1139 2
			(void)nmg_tbl(is->l1, TBL_INS_UNIQUE, &vu->l.magic);
			(void)nmg_tbl(is->l2, TBL_INS_UNIQUE, &new_vu2->l.magic);
d1509 1
a1509 1
			vu2_final = nmg_insert_other_fu_v_in_list( is, is->l2, v1a, fu2 );
d1566 1
a1566 1
			vu2_final = nmg_insert_other_fu_v_in_list( is, is->l2, v1b, fu2 );
d1829 2
d2122 2
d2158 3
d2317 2
a2318 2
		nmg_insert_other_fu_v_in_list( is, list, vu1a->v_p, fu2 );
		nmg_insert_other_fu_v_in_list( is, list, vu1b->v_p, fu2 );
d2333 1
a2333 1
		nmg_insert_other_fu_v_in_list( is, list, vu1a->v_p, fu2 );
d2339 1
a2339 1
		nmg_insert_other_fu_v_in_list( is, list, vu1b->v_p, fu2 );
d2365 1
a2365 1
		nmg_insert_other_fu_v_in_list( is, list, vu1_final->v_p, fu2 );
d2372 1
a2372 1
		rt_log("nmg_isect_line2_edge2p(eu1=x%x, fu1=x%x) END%d\n", eu1, fu1);
d2498 2
d2531 2
d2923 2
@


10.91
log
@Added calls to nmg_unbreak_region_edges().
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.90 93/10/19 01:36:36 mike Exp Locker: mike $ (ARL)";
a50 6
/* XXX move to raytrace.h (for nmg_ck.c) */
RT_EXTERN(void		nmg_ck_v_in_2fus, (CONST struct vertex *vp,
			CONST struct faceuse *fu1, CONST struct faceuse *fu2,
			CONST struct rt_tol *tol));


d85 17
d103 27
d516 1
d577 1
d579 2
a580 2
	vu2_final = nmg_find_pt_in_face(hit_pt, fu2, &(is->tol));
	if (vu2_final) {
d583 1
a583 1
			rt_log("re-using vertex v=x%x from other face\n", vu2_final->v_p);
d585 1
a585 1
		eu1forw = nmg_ebreak(vu2_final->v_p, eu1);
d587 1
a587 1
		(void)nmg_tbl(is->l2, TBL_INS_UNIQUE, &vu2_final->l.magic);
d1269 1
d1482 2
a1483 2
		vu2_final = nmg_find_pt_in_face(v1a->vg_p->coord, fu2, &(is->tol));
		if (vu2_final) {
d1485 1
a1485 1
			/* Face has a very similar vertex.  Add to list */
d1487 1
a1487 2
				rt_log("A: Reusing vu2=x%x, v=x%x from fu2\n", vu2_final, vu2_final->v_p);
			(void)nmg_tbl(is->l2, TBL_INS_UNIQUE, &vu2_final->l.magic);
d1490 1
a1490 1
			p3 = vu2_final->v_p->vg_p->coord;
d1494 2
a1495 1
			nmg_jv(v1a, vu2_final->v_p);
d1539 2
a1540 2
		vu2_final = nmg_find_pt_in_face(v1b->vg_p->coord, fu2, &(is->tol));
		if (vu2_final) {
d1544 1
a1544 2
				rt_log("B: Reusing vu2=x%x, v=x%x from fu2\n", vu2_final, vu2_final->v_p);
			(void)nmg_tbl(is->l2, TBL_INS_UNIQUE, &vu2_final->l.magic);
d1547 1
a1547 1
			p3 = vu2_final->v_p->vg_p->coord;
d1552 1
a2209 44
 *		N M G _ I N S E R T _ O T H E R _ F U _ V U _ I N _ L I S T
 *
 *  Insert the vu from fu2 that corresponds to vu1 onto
 *  the OTHER face's (fu2's) intersect list.
 *  If such a vu does not exist, make a self-loop in fu2.
 */
void
nmg_insert_other_fu_vu_in_list( is, list, vu1, fu2 )
struct nmg_inter_struct	*is;
struct nmg_ptbl		*list;
struct vertexuse	*vu1;
struct faceuse		*fu2;
{
	struct vertexuse	*vu2;
	struct nmg_ptbl		*lp;
	struct loopuse		*plu;		/* point loopuse */

	NMG_CK_INTER_STRUCT(is);
	NMG_CK_PTBL(list);
	NMG_CK_VERTEXUSE(vu1);
	NMG_CK_FACEUSE(fu2);

	if( is->l1 == list )
		lp = is->l2;
	else
		lp = is->l1;
	if( vu2 = nmg_find_v_in_face( vu1->v_p, fu2 ) )  {
		(void)nmg_tbl(lp, TBL_INS_UNIQUE, &vu2->l.magic);
		return;
	}
	/* Insert copy of this vertex into other face, as self-loop. */
	plu = nmg_mlv(&fu2->l.magic, vu1->v_p, OT_UNSPEC);
	nmg_loop_g(plu->l_p);
	vu2 = RT_LIST_FIRST( vertexuse, &plu->down_hd );
	NMG_CK_VERTEXUSE(vu2);
	(void)nmg_tbl(lp, TBL_INS_UNIQUE, &vu2->l.magic);

	if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
		rt_log("nmg_insert_other_fu_vu_in_list: vu1=x%x, made self-loop for fu2: vu2=x%x\n",
			vu1, vu2);
	}
}

/*
d2296 2
a2297 2
		nmg_insert_other_fu_vu_in_list( is, list, vu1a, fu2 );
		nmg_insert_other_fu_vu_in_list( is, list, vu1b, fu2 );
d2312 1
a2312 1
		nmg_insert_other_fu_vu_in_list( is, list, vu1a, fu2 );
d2318 1
a2318 1
		nmg_insert_other_fu_vu_in_list( is, list, vu1b, fu2 );
a2321 1
		struct vertexuse	*vu2;
d2327 2
a2328 2
		/* if we can't find the appropriate vertex in the OTHER
		 * face by a geometry search, build a new vertex.
d2330 1
d2332 1
a2332 7
		vu2 = nmg_find_pt_in_face(hit_pt, fu2, &(is->tol));
		if (vu2) {
			/* the other face has a convenient vertex for us */
			new_v = vu2->v_p;
		} else {
			new_v = (struct vertex *)NULL;
		}
d2344 1
a2344 1
		nmg_insert_other_fu_vu_in_list( is, list, vu1_final, fu2 );
@


10.90
log
@Added more printing
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.89 93/10/18 20:37:35 mike Exp Locker: mike $ (ARL)";
d2694 5
@


10.89
log
@Added nmg_insert_other_fu_vu_in_list()
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.88 93/10/18 20:09:42 mike Exp Locker: mike $ (ARL)";
a2338 2
			if (rt_g.NMG_debug & DEBUG_POLYSECT)
				rt_log("\t\tre-using vertex v=x%x from face\n", new_v);
d2344 9
a2352 1
		if( !new_v )  nmg_vertex_gv( vu1_final->v_p, hit_pt );	/* 3d geom */
@


10.88
log
@Added more printing to nmg_isect_two_face2p
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.87 93/10/18 19:42:59 mike Exp Locker: mike $ (ARL)";
d2169 44
d2299 2
d2315 1
d2321 1
d2347 1
@


10.87
log
@Added extra fu arg to nmg_isect_lien2_face2p(), so that it could search
in OTHER face for tasty vu's.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.86 93/10/02 01:01:54 mike Exp Locker: mike $ (ARL)";
d1953 1
a1953 1
		rt_log("nmg_isect_two_face2p\n");
d1981 6
d2013 2
d2016 1
@


10.86
log
@Added new code to do face/face intersection as a pair of line/face2p
operations, inspired by remarks made by John Anderson.
It compiles, but has not been tested.  The call has not been #ifdef'ed
in yet.
@
text
@d1 2
d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.85 93/10/01 16:36:27 mike Exp Locker: mike $ (ARL)";
d132 4
a135 1
	if( !v->vg_p )  rt_bomb("nmg_get_2d_vertex:  vertex with no geometry!\n");
d2165 1
a2165 1
 *  The line is item 1, intersect it with eu2, from fu2.
d2167 2
d2171 1
a2171 1
nmg_isect_line2_edge2p( is, list, eu2, fu2 )
d2174 2
a2175 1
struct edgeuse		*eu2;
d2180 3
a2182 4
	point_t		eu2_start;	/* 2D */
	point_t		eu2_end;	/* 2D */
	vect_t		eu2_dir;	/* 2D */
	vect_t		dir3d;
d2185 1
a2185 1
	point_t		hit_pt;
d2187 1
a2187 1
	struct vertexuse	*vu2a, *vu2b;
d2190 3
a2193 1
	NMG_CK_EDGEUSE(eu2);
d2200 4
a2203 4
	vu2a = eu2->vu_p;
	vu2b = RT_LIST_PNEXT_CIRC( edgeuse, eu2 )->vu_p;
	NMG_CK_VERTEXUSE(vu2a);
	NMG_CK_VERTEXUSE(vu2b);
d2206 4
a2209 4
		rt_log("nmg_isect_line2_edge2p(eu2=x%x, fu2=x%x)\n\tvu2a=%x vu2b=%x\n\tv2a=%x v2b=%x\n",
			eu2, fu2,
			vu2a, vu2b,
			vu2a->v_p, vu2b->v_p );
d2215 3
a2217 3
	nmg_get_2d_vertex( eu2_start, vu2a->v_p, is, fu2 );
	nmg_get_2d_vertex( eu2_end, vu2b->v_p, is, fu2 );
	VSUB2( eu2_dir, eu2_end, eu2_start );
d2220 1
d2228 1
a2228 1
			eu2_start, eu2_dir, &is->tol );
d2243 3
a2245 3
			rt_log("\t\tedge colinear with isect line.  Listing vu2a, vu2b\n");
		(void)nmg_tbl(list, TBL_INS_UNIQUE, &vu2a->l.magic);
		(void)nmg_tbl(list, TBL_INS_UNIQUE, &vu2b->l.magic);
d2254 1
a2254 1
	 * or break eu2.
d2258 3
a2260 3
			rt_log("\t\tintersect point is vu2a\n");
		(void)nmg_tbl(list, TBL_INS_UNIQUE, &vu2a->l.magic);
		nmg_ck_face_worthless_edges( fu2 );
d2263 3
a2265 3
			rt_log("\t\tintersect point is vu2b\n");
		(void)nmg_tbl(list, TBL_INS_UNIQUE, &vu2b->l.magic);
		nmg_ck_face_worthless_edges( fu2 );
d2267 3
a2269 2
		/* Intersection is in the middle of eu2, split edge */
		struct vertexuse	*vu2_final;
d2272 1
a2272 1
		    	VPRINT("\t\tBreaking eu2 at intersect point", hit_pt);
d2274 1
a2274 1
		/* if we can't find the appropriate vertex in the
d2278 2
a2279 2
		vu2_final = nmg_find_pt_in_face(hit_pt, fu2, &(is->tol));
		if (vu2_final) {
d2281 1
a2281 1
			new_v = vu2_final->v_p;
d2283 1
a2283 1
				rt_log("re-using vertex v=x%x from face\n", new_v);
d2287 3
a2289 2
		vu2_final = nmg_ebreak(new_v, eu2)->vu_p;
		(void)nmg_tbl(list, TBL_INS_UNIQUE, &vu2_final->l.magic);
d2291 1
a2291 1
		nmg_ck_face_worthless_edges( fu2 );
d2296 1
a2296 1
		rt_log("nmg_isect_line2_edge2p(eu2=x%x, fu2=x%x) END%d\n", eu2, fu2);
d2305 3
a2307 1
 *  The line is provided by the caller, and lies in the plane of the face.
d2312 1
a2312 1
nmg_isect_line2_face2p(is, list, fu)
d2315 2
a2316 1
struct faceuse		*fu;
d2318 1
a2318 1
	struct loopuse		*lu;
d2321 3
a2323 1
	NMG_CK_FACEUSE(fu);
d2326 1
a2326 1
		rt_log("nmg_isect_line2_face2p(, fu=x%x)\n", fu);
d2328 1
a2328 1
	if( fu->orientation != OT_SAME )  rt_bomb("nmg_isect_line2_face2p() fu1 not OT_SAME\n");
d2336 1
a2336 1
    	    	nmg_plot_ray_face("face", is->pt, is->dir, fu);
d2345 2
a2346 2
nmg_fu_touchingloops(fu);
nmg_region_v_unique( fu->s_p->r_p, &is->tol );
d2348 2
a2349 2
	for( RT_LIST_FOR( lu, loopuse, &fu->lu_hd ) )  {
		struct edgeuse	*eu;
d2351 1
a2351 1
		if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) == NMG_VERTEXUSE_MAGIC )  {
d2354 1
a2354 1
			vu = RT_LIST_FIRST( vertexuse, &lu->down_hd );
d2359 5
a2363 5
		for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
			/* intersect line with eu */
			nmg_isect_line2_edge2p( is, list, eu, fu );
nmg_fu_touchingloops(fu);
nmg_region_v_unique( fu->s_p->r_p, &is->tol );
d2367 2
a2368 2
nmg_fu_touchingloops(fu);
nmg_region_v_unique( fu->s_p->r_p, &is->tol );
d2372 1
a2372 1
		rt_log("nmg_isect_line2_face2p(fu=x%x) END\n", fu);
d2429 1
a2429 1
	nmg_isect_line2_face2p(is, fu1);
d2439 1
a2439 1
	 *  Now intersect the other way around, to catch any stragglers.
d2453 1
a2453 1
	nmg_isect_line2_face2p(is, fu2);
@


10.85
log
@Err, loop in nmg_isect_two_face3p() would never run, due to a
small logic error.  Fixed that.
Also got rid of one more stray print.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.84 93/10/01 07:20:59 mike Exp Locker: mike $ (ARL)";
d1587 1
a1587 1
		return;
d2155 346
d2591 3
d2595 1
@


10.84
log
@Fixed two cases where eu1 was not broken, just touched.
(Stirred, not broken?)
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.83 93/10/01 06:48:38 mike Exp Locker: mike $ (ARL)";
a1543 1
#if 0
a1544 1
#endif
d2042 1
a2042 1
	again = 0;
@


10.83
log
@Lots of debugging of 2D code.
Added return codes, indicating whether the 3D intersection line
that's being held pending while the 2D code is running,
has been invalidated and needs to be re-run or not.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.82 93/09/30 22:14:26 mike Exp Locker: mike $ (ARL)";
d987 1
a987 1
		return 2;
d1027 1
a1027 1
		return 2;
@


10.82
log
@Moved the nmg_ck_vs_in_region() and nmg_fu_touchingloops()
calls into DEBUG_VERIFY blocks, so as to not slow things down
as much.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.81 93/09/30 21:08:46 mike Exp Locker: mike $ (ARL)";
d84 1
a84 1
static void	nmg_isect_edge2p_face2p RT_ARGS((struct nmg_inter_struct *is,
d667 1
a667 1
 *  dist[1] has the distance (0..1) along eu1 from vua1 to vu2b.
d674 3
d678 1
a678 1
void
d694 2
d737 1
d762 1
d766 1
d777 1
a777 1
 *	2	one or both edges was split at (geometric) intersection.
d900 1
a900 1
		nmg_isect_two_colinear_edge2p( dist, is->l1, is->l2,
d902 3
a904 1
			eu1, eu2, fu1, fu2, &is->tol, "eu1/eu2" );
d932 2
a933 1
		nmg_isect_two_colinear_edge2p( eu2dist, is->l2, is->l1,
d937 1
a937 1
		return 2;	/* XXX unsure of what happened, be conservative */
d1050 1
a1050 1
			return 1;
d1065 1
a1065 1
			return 1;
d1083 1
a1083 1
			return 2;
d1090 1
a1090 1
	/* Intersection is in the middle of the reference edge */
d1129 1
a1129 1
	ret = 2;	/* an edge was broken */
d1195 2
d1209 4
d1214 1
a1214 1
static void
d1237 1
d1296 1
a1296 1
		if (rt_g.NMG_debug & DEBUG_POLYSECT)
d1298 4
d1306 1
a1306 1
		nmg_isect_edge2p_face2p( &is2, eu1, fu2, fu1 );
d1309 5
d1315 2
a1316 1
		if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
d1544 1
d1546 3
a1548 1
		rt_log("nmg_isect_edge3p_face3p(, eu1=x%x, fu2=x%x) END\n", eu1, fu2);
d1555 4
d1560 1
a1560 1
static void
d1568 1
d1612 1
a1612 1
		nmg_isect_edge3p_face3p(bs, eu, fu);
d1617 2
a1618 2
	if (rt_g.NMG_debug & DEBUG_POLYSECT) {
		rt_log("nmg_isect_loop3p_face3p(, lu=x%x, fu=x%x) END\n", lu, fu);
d1620 1
d1631 4
d1636 1
a1636 1
static void
d1645 1
d1682 3
a1684 2
			/* These two loops overlap, intersect
			 * all the edges in lu1 with the plane of fu2.
d1686 1
a1686 4
/* XXX Why are we doing this over and over again?  Or is function wrongly named? */
			nmg_isect_loop3p_face3p(bs, lu1, fu2);
#if 0
			/* XXX Is this the answer? */
a1687 1
#endif
d1691 2
a1692 1
		rt_log("nmg_isect_face3p_face3p(, fu1=x%x, fu2=x%x) RETURN ++++++++++\n\n", fu1, fu2);
d1710 9
d1720 1
a1720 1
static void
d1733 2
d1737 1
d1761 2
a1762 1
			return;		/* Topology is completely shared */
d1796 23
a1818 2
	if( !rt_in_rpp( &line, invdir, fu2->f_p->fg_p->min_pt, fu2->f_p->fg_p->max_pt ) )  {
		rt_bomb("nmg_isect_edge2p_face2p() edge ray missed face bounding RPP\n");
a1846 1
	another_pass = 0;
d1848 1
d1869 2
d1904 1
d1911 7
d1967 1
d1993 1
d2021 2
d2044 3
a2046 2
    	is->l1 = &vert_list1;
    	is->l2 = &vert_list2;
d2048 2
a2049 5
    	if (rt_g.NMG_debug & (DEBUG_POLYSECT|DEBUG_FCUT|DEBUG_MESH)
    	    && rt_g.NMG_debug & DEBUG_PLOTEM) {
    		static int fno=1;
    	    	nmg_pl_2fu( "Isect_faces%d.pl", fno++, fu1, fu2, 0 );
    	}
d2051 15
a2065 2
	nmg_isect_face3p_face3p(is, fu1, fu2);
	if( rt_g.NMG_debug & DEBUG_VERIFY )  {
d2068 3
a2070 3
		nmg_vfu( &fu1->s_p->fu_hd, fu1->s_p );
		nmg_vfu( &fu2->s_p->fu_hd, fu2->s_p );
	}
d2072 8
a2079 5
    	if (rt_g.NMG_debug & DEBUG_FCUT) {
	    	rt_log("nmg_isect_two_generic_faces(fu1=x%x, fu2=x%x) vert_lists A:\n", fu1, fu2);
    		nmg_pr_ptbl_vert_list( "vert_list1", &vert_list1 );
    		nmg_pr_ptbl_vert_list( "vert_list2", &vert_list2 );
    	}
d2081 3
a2083 3
	if (rt_g.NMG_debug & DEBUG_POLYSECT) {
		rt_log("nmg_isect_two_face3p( fu1=x%x, fu2=x%x )  START21\n", fu1, fu2);
	}
d2085 7
a2091 3
    	is->l2 = &vert_list1;
    	is->l1 = &vert_list2;
	nmg_isect_face3p_face3p(is, fu2, fu1);
d2093 1
a2093 1
	if( rt_g.NMG_debug & DEBUG_VERIFY )  {
d2096 3
a2098 2
		nmg_vfu( &fu1->s_p->fu_hd, fu1->s_p );
		nmg_vfu( &fu2->s_p->fu_hd, fu2->s_p );
d2542 1
a2542 1

@


10.81
log
@Moved general stuff off into other modules
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
a502 8
	/* Check hit_pt against face/face intersection line */
	dist = rt_dist_line_point( is->pt, is->dir, hit_pt );
	if( dist > is->tol.dist )  {
		rt_log("WARNING nmg_break_3edge_at_plane() hit_pt off line %g*tol (%e, tol=%e)\n",
			dist/is->tol.dist,
			dist, is->tol.dist);
	}

d524 1
a524 1
			rt_log("WARNING: nmg_break_3edge_at_plane() hit_pt nearly equal to v1 %g*tol\n", dist/is->tol.dist);
d527 1
a527 1
			rt_log("WARNING: nmg_break_3edge_at_plane() hit_pt nearly equal to v1mate %g*tol\n", dist/is->tol.dist);
d598 2
a599 2
rt_log("%%%%%% point is on loop boundary.  Break fu2 loop too?\n");
#if 1
a606 2
#endif
			break;
d919 1
a919 1
rt_log("ptol = %g, eu2dist=%g, %g\n", ptol, eu2dist[0], eu2dist[1]);
a1742 2
VPRINT("fu2 min", fu2->f_p->fg_p->min_pt);
VPRINT("fu2 max", fu2->f_p->fg_p->max_pt);
d1746 5
a1750 1
rt_log("r_min=%g, r_max=%g\n", line.r_min, line.r_max);
d1756 2
a1757 1
rt_log("flipping dir\n");
d1761 6
a1766 4
VPRINT("r_pt ", line.r_pt);
VPRINT("r_dir", line.r_dir);
VPRINT("->pt ", is->pt);
VPRINT("->dir", is->dir);
d1817 1
a1948 1
	}
d1951 1
a1951 2
nmg_region_v_unique( fu1->s_p->r_p, &is->tol );
nmg_region_v_unique( fu2->s_p->r_p, &is->tol );
d1966 1
a1968 4
nmg_region_v_unique( fu1->s_p->r_p, &is->tol );
nmg_region_v_unique( fu2->s_p->r_p, &is->tol );

	if( rt_g.NMG_debug & DEBUG_VERIFY )  {
d1986 2
a1989 4
nmg_region_v_unique( fu1->s_p->r_p, &is->tol );
nmg_region_v_unique( fu2->s_p->r_p, &is->tol );

	if( rt_g.NMG_debug & DEBUG_VERIFY )  {
d2013 2
a2018 2

	if( rt_g.NMG_debug & DEBUG_VERIFY )  {
d2024 1
d2027 1
a2094 1
	}
d2097 1
d2158 1
d2163 1
a2512 2
	}

d2515 1
d2542 2
@


10.80
log
@Added codd to nmg_break_3edge_at_plane to call the classifier on the
point about to be inserted in the other face.
Also added some %g*tol prints.
And changed a few variable names to be more clear.
@
text
@d26 1
a26 1
 *	Aberdeen Proving Ground, Maryland  21005-5066
d28 5
d34 2
a35 2
 *	This software is Copyright (C) 1993 by the United States Army.
 *	All rights reserved.
d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.79 93/09/29 22:15:08 mike Exp Locker: mike $ (BRL)";
a229 1
/* XXX Move to nmg_pr.c or nmg_misc.c */
a230 45
 *			N M G _ P R _ P T B L _ V E R T _ L I S T
 *
 *  Print a ptbl array as a vertex list.
 */
void
nmg_pr_ptbl_vert_list( str, tbl )
CONST char	*str;
struct nmg_ptbl	*tbl;
{
	int			i;
	struct vertexuse	**vup;
	struct vertexuse	*vu;
	struct vertex		*v;
	struct vertex_g		*vg;

    	rt_log("nmg_pr_ptbl_vert_list(%s):\n", str);

	vup = (struct vertexuse **)tbl->buffer;
	for (i=0 ; i < tbl->end ; ++i) {
		vu = vup[i];
		NMG_CK_VERTEXUSE(vu);
		v = vu->v_p;
		NMG_CK_VERTEX(v);
		vg = v->vg_p;
		NMG_CK_VERTEX_G(vg);
		rt_log("%d\t%g, %g, %g\t", i, V3ARGS(vg->coord) );
		if (*vu->up.magic_p == NMG_EDGEUSE_MAGIC) {
			rt_log("EDGEUSE");
		} else if (*vu->up.magic_p == NMG_LOOPUSE_MAGIC) {
			rt_log("LOOPUSE");
			if ((struct vertexuse *)vu->up.lu_p->down_hd.forw != vu) {
				rt_log("ERROR vertexuse's parent disowns us!\n");
				if (((struct vertexuse *)(vu->up.lu_p->lumate_p->down_hd.forw))->l.magic == NMG_VERTEXUSE_MAGIC)
					rt_bomb("lumate has vertexuse\n");
				else
					rt_bomb("lumate has garbage\n");
			}
		} else {
			rt_log("UNKNOWN");
		}
		rt_log("\tv=x%x, vu=x%x\n", v , vu);
	}
}

/*
a655 1
/* XXX move to nmg_ck.c */
a656 37
 *			N M G _ C K _ F A C E _ W O R T H L E S S _ E D G E S
 *
 *  For the moment, a quick hack to see if breaking an edge at a given
 *  vertex results in a null edge being created.
 */
void
nmg_ck_face_worthless_edges( fu )
CONST struct faceuse	*fu;
{
	CONST struct loopuse	*lu;

	for( RT_LIST_FOR( lu, loopuse, &fu->lu_hd ) )  {
		struct edgeuse	*eu;
		struct vertexuse *vu2;

		NMG_CK_LOOPUSE(lu);
		if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) == NMG_VERTEXUSE_MAGIC )
			continue;
		for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
			struct edgeuse		*neu;
			neu = RT_LIST_PNEXT_CIRC( edgeuse, eu );
			if( eu->vu_p == neu->vu_p )
				rt_bomb("edge runs between two copies of vu??\n");
			if( eu->vu_p->v_p == neu->vu_p->v_p )  {
#if 0
				nmg_pr_eu( eu, NULL );
				nmg_pr_eu( neu, NULL );
#endif
				rt_log("eu=x%x, neu=x%x, v=x%x\n", eu, neu, eu->vu_p->v_p);
				rt_log("eu=x%x, neu=x%x, v=x%x\n", eu->eumate_p, neu->eumate_p, eu->eumate_p->vu_p->v_p);
				rt_bomb("nmg_ck_face_worthless_edges() edge runs from&to same vertex\n");
			}
		}
	}
}

/*
a2554 67
}

/* XXX move to nmg_info.c */
/*
 *			N M G _ L O O P _ T O U C H E S _ S E L F
 *
 *  Search through all the vertices in a loop.
 *  If there are two distinct uses of one vertex in the loop,
 *  return true.
 *  This is useful for detecting "accordian pleats"
 *  unexpectedly showing up in a loop.
 *  Intended for specific debugging tasks, rather than as a
 *  routine used generally.
 *  Derrived from nmg_split_touchingloops().
 *
 *  Returns -
 *	vu	Yes, the loop touches itself at least once, at this vu.
 *	0	No, the loop does not touch itself.
 */
CONST struct vertexuse *
nmg_loop_touches_self( lu )
CONST struct loopuse	*lu;
{
	CONST struct edgeuse	*eu;
	CONST struct vertexuse	*vu;
	CONST struct vertex	*v;

	if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
		return (CONST struct vertexuse *)0;

	/* For each edgeuse, get vertexuse and vertex */
	for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
		CONST struct vertexuse	*tvu;

		vu = eu->vu_p;
		NMG_CK_VERTEXUSE(vu);
		v = vu->v_p;
		NMG_CK_VERTEX(v);

		/*
		 *  For each vertexuse on vertex list,
		 *  check to see if it points up to the this loop.
		 *  If so, then there is a duplicated vertex.
		 *  Ordinarily, the vertex list will be *very* short,
		 *  so this strategy is likely to be faster than
		 *  a table-based approach, for most cases.
		 */
		for( RT_LIST_FOR( tvu, vertexuse, &v->vu_hd ) )  {
			CONST struct edgeuse		*teu;
			CONST struct loopuse		*tlu;
			CONST struct loopuse		*newlu;

			if( tvu == vu )  continue;
			if( *tvu->up.magic_p != NMG_EDGEUSE_MAGIC )  continue;
			teu = tvu->up.eu_p;
			NMG_CK_EDGEUSE(teu);
			if( *teu->up.magic_p != NMG_LOOPUSE_MAGIC )  continue;
			tlu = teu->up.lu_p;
			NMG_CK_LOOPUSE(tlu);
			if( tlu != lu )  continue;
			/*
			 *  Repeated vertex exists.
			 */
			return vu;
		}
	}
	return (CONST struct vertexuse *)0;
@


10.79
log
@John made an interesting observation this afternoon, and remarked that
nmg_break_3edge_at_plane(hit_pt, eu1, fu2) breaks it's edge (eu1) at
the plane intersect point (hit_pt), even if hit_pt falls OUTSIDE all the
loops of the face (fu2).
This is not an unexpected behavior, but I put a call to the
classifier in, just to double check.
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.78 93/09/27 22:15:57 mike Exp Locker: mike $ (BRL)";
d281 1
a281 1
 *	2	if edge was split at vertex.
a305 1
	/* This needs to be done every pass:  it changes as edges are cut */
d357 4
d363 1
a363 1
nmg_isect_vert2p_face2p(is, vu, fu)
d365 2
a366 2
struct vertexuse	*vu;
struct faceuse		*fu;
d368 1
a368 1
	struct loopuse	 *lu;
d373 1
a373 1
		rt_log("nmg_isect_vert2p_face2p(, vu=x%x, fu=x%x)\n", vu, fu);
d375 2
a376 2
	NMG_CK_VERTEXUSE(vu);
	NMG_CK_FACEUSE(fu);
d379 1
a379 1
	if( nmg_find_v_in_face(vu->v_p, fu) )  return;
d382 1
a382 1
	pt = vu->v_p->vg_p->coord;
d385 2
a386 2
	for( RT_LIST_FOR( lu, loopuse, &fu->lu_hd ) )  {
		struct edgeuse	*eu;
d389 4
a392 4
		NMG_CK_LOOPUSE(lu);
		if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) == NMG_VERTEXUSE_MAGIC )  {
			vu2 = RT_LIST_FIRST( vertexuse, &lu->down_hd );
			if( vu->v_p == vu2->v_p )  return;
d396 2
a397 2
				nmg_jv( vu->v_p, vu2->v_p );
				nmg_ck_v_in_2fus(vu->v_p, nmg_find_fu_of_vu(vu), fu, &is->tol);
d402 1
a402 1
		for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
d404 1
a404 1
			if( nmg_isect_edge2p_vert2p( is, eu, vu ) )  return;
d412 2
a413 2
	lu = nmg_mlv(&fu->l.magic, vu->v_p, OT_UNSPEC);
	nmg_loop_g( lu->l_p );
d421 4
d512 3
a514 2
	struct vertexuse *vu2_final;
	struct loopuse	*plu;
d518 1
d544 8
d562 4
d568 1
d571 1
d573 2
a574 1
			rt_log("WARNING: nmg_break_3edge_at_plane() hit_pt nearly equal to v1\n");
d576 1
a576 1
			rt_log("WARNING: nmg_break_3edge_at_plane() hit_pt nearly equal to v1mate\n");
d580 2
a581 2
	 * other face, we'll build a new vertex.  Otherwise
	 * we re-use an old one.
d590 1
d604 1
a604 9
		switch(class)  {
		case NMG_CLASS_AinB:
			/* point inside a face loop, break edge */
			break;
		case NMG_CLASS_AonBshared:
			/* point is on a loop boundary.  Break fu2 loop too? */
rt_log("%%%%%% point is on loop boundary.  Break fu2 loop too?\n");
			break;
		case NMG_CLASS_AoutB:
d606 1
d608 6
a613 1
			break;
d617 2
a618 1
		nmg_vertex_gv(eu1forw->vu_p->v_p, hit_pt);
d620 1
a620 1
			rt_log("Made new vertex vu=x%x, v=x%x\n", eu1forw->vu_p, eu1forw->vu_p->v_p);
d641 24
d669 2
a670 2
		plu = nmg_mlv(&fu2->l.magic, eu1forw->vu_p->v_p, OT_UNSPEC);
		vu2_final = RT_LIST_FIRST( vertexuse, &plu->down_hd );
d672 1
a672 1
		nmg_loop_g(plu->l_p);
d676 1
a676 1
				plu, 
d1280 2
a1281 1
 *	Intersect an edge with a (hopefully non-colinear/coplanar) face
d1283 2
a1284 5
 * This code currently assumes that an edge can only intersect a face at one
 * point.  This is probably a bad assumption for the future
 *
 *  The line of intersection between the two faces is found in
 *  nmg_isect_two_face2p().
a1449 1
	VJOIN1( hit_pt, start_pt, dist, edge_vect );
d1463 5
d1469 14
d1532 2
a1533 1
		vu1_final = RT_LIST_PNEXT_CIRC(edgeuse,eu1)->vu_p;
d1537 4
a1540 1
	if ( dist_to_plane < edge_len + is->tol.dist) {
a1583 3
	if (rt_g.NMG_debug & DEBUG_POLYSECT)
		rt_log("\tdist to plane X: X > MAGNITUDE(edge)\n");

d1598 3
a1600 2
			rt_log("WARNING nmg_isect_edge3p_face3p() vu1=x%x point off line by %e, tol=%e\n",
				vu1_final, dist, is->tol.dist);
@


10.78
log
@Changed nmg_isect_3edge_3face() name to nmg_isect_edge3p_face3p(),
and reorganized the internals of that routine to have better variable
names, and an opportunity for error checking down at the bottom.
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.77 93/09/24 15:07:43 mike Exp Locker: mike $ (BRL)";
d493 4
d498 2
a499 2
static void
nmg_break_3edge_at_plane(hit_pt, fu, is, eu)
d501 1
a501 1
struct faceuse		*fu;		/* The face that eu intersects */
d503 1
a503 1
struct edgeuse		*eu;		/* Edge to be broken */
d505 1
a505 1
	struct vertexuse *vu_other;
d507 1
a507 1
	struct edgeuse	*euforw;	/* New eu, after break, forw of eu */
d512 1
a512 1
	NMG_CK_EDGEUSE(eu);
d514 1
a514 1
	v1 = eu->vu_p->v_p;
d516 1
a516 1
	v1mate = eu->eumate_p->vu_p->v_p;
d537 2
a538 2
		VSUB2( va, hit_pt, eu->vu_p->v_p->vg_p->coord  );
		VSUB2( vb, eu->eumate_p->vu_p->v_p->vg_p->coord, hit_pt );
d542 1
a542 1
			rt_bomb("nmg_break_3edge_at_plane() eu changes direction?\n");
d559 2
a560 2
	vu_other = nmg_find_pt_in_face(hit_pt, fu, &(is->tol));
	if (vu_other) {
d563 1
a563 1
			rt_log("re-using vertex v=x%x from other face\n", vu_other->v_p);
d565 2
a566 2
		euforw = nmg_ebreak(vu_other->v_p, eu);
		(void)nmg_tbl(is->l2, TBL_INS_UNIQUE, &vu_other->l.magic);
d569 26
a594 2
		euforw = nmg_ebreak((struct vertex *)NULL, eu);
		nmg_vertex_gv(euforw->vu_p->v_p, hit_pt);
d596 1
a596 1
			rt_log("Made new vertex vu=x%x, v=x%x\n", euforw->vu_p, euforw->vu_p->v_p);
d598 4
a601 4
		NMG_CK_VERTEX_G(eu->vu_p->v_p->vg_p);
		NMG_CK_VERTEX_G(eu->eumate_p->vu_p->v_p->vg_p);
		NMG_CK_VERTEX_G(euforw->vu_p->v_p->vg_p);
		NMG_CK_VERTEX_G(euforw->eumate_p->vu_p->v_p->vg_p);
d604 2
a605 2
			register pointp_t p1 = eu->vu_p->v_p->vg_p->coord;
			register pointp_t p2 = eu->eumate_p->vu_p->v_p->vg_p->coord;
d607 2
a608 2
			rt_log("After split eu x%x= %g, %g, %g -> %g, %g, %g\n",
				eu,
d610 4
a613 4
			p1 = euforw->vu_p->v_p->vg_p->coord;
			p2 = euforw->eumate_p->vu_p->v_p->vg_p->coord;
			rt_log("\teuforw x%x = %g, %g, %g -> %g, %g, %g\n",
				euforw,
d621 3
a623 3
		plu = nmg_mlv(&fu->l.magic, euforw->vu_p->v_p, OT_UNSPEC);
		vu_other = RT_LIST_FIRST( vertexuse, &plu->down_hd );
		NMG_CK_VERTEXUSE(vu_other);
d629 1
a629 1
				vu_other, vu_other->v_p);
d631 1
a631 1
		(void)nmg_tbl(is->l2, TBL_INS_UNIQUE, &vu_other->l.magic);
d636 2
a637 2
		p1 = eu->vu_p->v_p->vg_p->coord;
		p2 = eu->eumate_p->vu_p->v_p->vg_p->coord;
d640 2
a641 2
		p1 = euforw->vu_p->v_p->vg_p->coord;
		p2 = euforw->eumate_p->vu_p->v_p->vg_p->coord;
d645 2
a646 1
	(void)nmg_tbl(is->l1, TBL_INS_UNIQUE, &euforw->vu_p->l.magic);
a1370 1
nmg_ck_v_in_2fus(v1a, fu1, fu2, &is->tol);
d1437 2
d1467 2
a1468 2
		nmg_break_3edge_at_plane(hit_pt, fu2, is, eu1);
		/* XXX set vu1_final, vu2_final? */
d1490 2
d1536 1
@


10.77
log
@Added calls to nmg_ck_v_in_2fus() after most calls to nmg_jv().
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.76 93/09/24 13:47:57 mike Exp Locker: mike $ (BRL)";
d1201 1
a1201 1
 *			N M G _ I S E C T _ 3 E D G E _ 3 F A C E
d1212 4
a1215 4
nmg_isect_3edge_3face(bs, eu, fu)
struct nmg_inter_struct *bs;
struct edgeuse *eu;
struct faceuse *fu;
d1217 4
a1220 3
	struct vertexuse *vu_other;
	struct vertex	*v1;
	struct vertex	*v1mate;
d1233 1
d1236 1
a1236 1
		rt_log("nmg_isect_3edge_3face(, eu=x%x, fu=x%x) START\n", eu, fu);
d1238 6
a1243 6
	NMG_CK_INTER_STRUCT(bs);
	NMG_CK_EDGEUSE(eu);
	NMG_CK_VERTEXUSE(eu->vu_p);
	v1 = eu->vu_p->v_p;
	NMG_CK_VERTEX(v1);
	NMG_CK_VERTEX_G(v1->vg_p);
d1245 5
a1249 5
	NMG_CK_EDGEUSE(eu->eumate_p);
	NMG_CK_VERTEXUSE(eu->eumate_p->vu_p);
	v1mate = eu->eumate_p->vu_p->v_p;
	NMG_CK_VERTEX(v1mate);
	NMG_CK_VERTEX_G(v1mate->vg_p);
d1251 4
a1254 1
	if( fu->orientation != OT_SAME )  rt_bomb("nmg_isect_3edge_3face() fu not OT_SAME\n");
d1260 1
a1260 1
	VSUB2(edge_vect, v1mate->vg_p->coord, v1->vg_p->coord);
d1263 1
a1263 1
	VMOVE( start_pt, v1->vg_p->coord );
d1268 1
a1268 1
			V3ARGS(v1mate->vg_p->coord),
d1273 1
a1273 1
		fu->f_p->fg_p->N, &bs->tol);
d1277 2
a1278 2
		rt_log("\tHit. Status of rt_isect_line3_plane: %d dist: %g\n",
				status, dist);
d1281 1
a1281 1
				status);
d1284 1
a1284 1
		struct nmg_inter_struct	is;
d1293 1
a1293 1
			rt_log("nmg_isect_3edge_3face: edge lies ON face, using 2D code\n@@ @@ @@ @@ @@ @@ @@ @@ @@ @@ 2D CODE, START\n");
d1295 2
a1296 2
		is = *bs;	/* make private copy */
		is.vert2d = 0;	/* Don't use previously initialized stuff */
d1298 1
a1298 1
		nmg_isect_edge2p_face2p( &is, eu, fu, nmg_find_fu_of_eu(eu) );
d1300 1
a1300 1
		if( is.vert2d )  rt_free( (char *)is.vert2d, "vert2d");
d1303 1
a1303 1
			rt_log("nmg_isect_3edge_3face: @@ @@ @@ @@ @@ @@ @@ @@ @@ @@ 2D CODE, END, resume 3d problem.\n");
d1305 2
a1306 2
			nmg_pr_ptbl_vert_list( "l1", bs->l1 );
			nmg_pr_ptbl_vert_list( "l2", bs->l2 );
d1310 1
a1310 1
		if (vu_other=nmg_find_v_in_face(eu->vu_p->v_p, fu)) {
d1313 3
a1315 2
			(void)nmg_tbl(bs->l1, TBL_INS_UNIQUE, &eu->vu_p->l.magic);
			(void)nmg_tbl(bs->l2, TBL_INS_UNIQUE, &vu_other->l.magic);
d1333 2
a1334 1
	if (vu_other=nmg_find_v_in_face(v1, fu)) {
d1336 3
a1338 3
			rt_log("\tEdge start vertex lies on other face (topology).\n\tAdding vu1=x%x (v=x%x), vu_other=x%x (v=x%x)\n",
				eu->vu_p, eu->vu_p->v_p,
				vu_other, vu_other->v_p);
d1340 3
a1342 2
		(void)nmg_tbl(bs->l1, TBL_INS_UNIQUE, &eu->vu_p->l.magic);
		(void)nmg_tbl(bs->l2, TBL_INS_UNIQUE, &vu_other->l.magic);
d1350 2
a1351 2
		dist = VDOT( start_pt, fu->f_p->fg_p->N ) - fu->f_p->fg_p->N[3];
		if( !NEAR_ZERO( dist, bs->tol.dist ) )
d1357 1
a1357 1
		rt_bomb("nmg_isect_3edge_3face: Edge start vertex lies on other face (geometry)\n");
d1362 1
a1362 1
		dist = VSUB2DOT( v1->vg_p->coord, start_pt, edge_vect )
d1374 1
a1374 1
	 * The vertices are "fattened" by +/- bs->tol units.
d1383 1
a1383 1
	if ( dist_to_plane < -bs->tol.dist )  {
d1397 1
a1397 1
	if ( dist_to_plane < bs->tol.dist )  {
d1401 2
a1402 1
		(void)nmg_tbl(bs->l1, TBL_INS_UNIQUE, &eu->vu_p->l.magic);
d1404 3
a1406 2
		vu_other = nmg_find_pt_in_face(v1->vg_p->coord, fu, &(bs->tol));
		if (vu_other) {
d1409 1
a1409 1
			(void)nmg_tbl(bs->l2, TBL_INS_UNIQUE, &vu_other->l.magic);
d1412 2
a1413 2
			p3 = vu_other->v_p->vg_p->coord;
			VADD2SCALE(v1->vg_p->coord, v1->vg_p->coord, p3, 0.5);
d1416 2
a1417 2
			nmg_jv(v1, vu_other->v_p);
			nmg_ck_v_in_2fus(v1, nmg_find_fu_of_vu(eu->vu_p), fu, &bs->tol);
d1422 1
a1422 1
			    		v1->vg_p->coord);
d1424 1
a1424 1
			plu = nmg_mlv(&fu->l.magic, v1, OT_UNSPEC);
d1426 3
a1428 3
			vu_other = RT_LIST_FIRST( vertexuse, &plu->down_hd );
			NMG_CK_VERTEXUSE(vu_other);
			(void)nmg_tbl(bs->l2, TBL_INS_UNIQUE, &vu_other->l.magic);
d1433 1
a1433 1
	if ( dist_to_plane < edge_len - bs->tol.dist) {
d1437 2
a1438 1
		nmg_break_3edge_at_plane(hit_pt, fu, bs, eu);
d1442 1
a1442 1
	if ( dist_to_plane < edge_len + bs->tol.dist) {
d1447 1
a1447 1
		eunext = RT_LIST_PNEXT_CIRC(edgeuse,eu);
d1449 2
a1450 2
		if( eunext->vu_p->v_p != v1mate )
			rt_bomb("nmg_isect_3edge_3face: discontinuous eu loop\n");
d1452 2
a1453 1
		(void)nmg_tbl(bs->l1, TBL_INS_UNIQUE, &eunext->vu_p->l.magic);
d1455 3
a1457 2
		vu_other = nmg_find_pt_in_face(v1mate->vg_p->coord, fu, &(bs->tol));
		if (vu_other) {
d1460 1
a1460 1
			(void)nmg_tbl(bs->l2, TBL_INS_UNIQUE, &vu_other->l.magic);
d1463 2
a1464 2
			p3 = vu_other->v_p->vg_p->coord;
			VADD2SCALE(v1mate->vg_p->coord, v1mate->vg_p->coord, p3, 0.5);
d1467 2
a1468 2
			nmg_jv(v1mate, vu_other->v_p);
			nmg_ck_v_in_2fus(v1mate, nmg_find_fu_of_vu(eu->eumate_p->vu_p), fu, &bs->tol);
d1473 1
a1473 1
			    		v1mate->vg_p->coord);
d1475 1
a1475 1
			plu = nmg_mlv(&fu->l.magic, v1mate, OT_UNSPEC);
d1477 3
a1479 3
			vu_other = RT_LIST_FIRST( vertexuse, &plu->down_hd );
			NMG_CK_VERTEXUSE(vu_other);
			(void)nmg_tbl(bs->l2, TBL_INS_UNIQUE, &vu_other->l.magic);
d1488 18
d1507 1
a1507 1
		rt_log("nmg_isect_3edge_3face(, eu=x%x, fu=x%x) END\n", eu, fu);
d1552 1
a1552 1
	 * by nmg_isect_3edge_3face.  This is because the edgeuses
d1566 1
a1566 1
		nmg_isect_3edge_3face(bs, eu, fu);
d2283 1
a2283 1
		nmg_isect_3edge_3face( is, eu1, fu2 );
d2344 3
d2430 1
a2430 1
			nmg_isect_3edge_3face( &is, eu2, fu1 );
d2501 3
a2535 2

/* XXX Need a routine to ensure that all verts are within tol_dist of their face, after fusing is done */
@


10.76
log
@Fixed bug in nmg_isect_two_colinear_edge2p().
Under some circumstances it was calling nmg_ebreak() with the
wrong edgeuse to break.
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.75 93/09/23 13:21:46 mike Exp Locker: mike $ (BRL)";
d44 6
d394 1
d688 1
a688 1
nmg_isect_two_colinear_edge2p( dist, l1, l2, vu1a, vu1b, vu2a, vu2b, eu1, eu2, fu1, fu2, str )
d700 1
d711 1
d727 1
d734 1
d744 1
d756 1
d763 1
d906 1
a906 1
			eu1, eu2, fu1, fu2, "eu1/eu2" );
d936 1
a936 1
			eu2, eu1, fu2, fu1, "eu2/eu1" );
d970 1
d978 1
d1010 1
d1018 1
d1407 1
d1455 1
@


10.75
log
@Moved VINVDIR to vmath.h
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.74 93/09/22 13:45:09 mike Exp Locker: mike $ (BRL)";
d55 1
a55 1
	struct face	*face;		/* fu of 2d projection plane */
d655 2
a656 2
 *  diagram) can overlap each other in one of 8 configurations,
 *  labeled A through H:
d658 1
a658 1
 *	A	B	C	D	E	F	G	H
d661 8
a668 8
 *	*	*	  *	  *	*	  *	*	  *
 *	1	1	  2	  2	1	  2	1	  2
 *	1=*	1	  2	*=2	1=*	*=2	*	  *
 *	1 2	*=*	*=*	1 2	1 2	1 2
 *	1 2	  2	1	1 2	1 2	1 2	  *	*
 *	1=*	  2	1	*=2	*=2	1=*	  2	1
 *	1	  *	*	  2	  2	1	  *	*
 *	*			  *	  *	*
d678 1
a678 1
 *  be achieved.
d709 2
d728 5
a732 1
		(void)nmg_ebreak( vu2a->v_p, eu1 );
a734 12
	    {
		vect_t	va, vb;
	    	point_t	hit_pt;
	    	VMOVE( hit_pt, vu2a->v_p->vg_p->coord );
		VSUB2( va, hit_pt, eu1->vu_p->v_p->vg_p->coord  );
		VSUB2( vb, eu1->eumate_p->vu_p->v_p->vg_p->coord, hit_pt );
		VUNITIZE(va);
		VUNITIZE(vb);
		if( VDOT( va, vb ) <= 0.7071 )  {
			rt_bomb("nmg_isect_two_colinear_edge2p() eu changes direction? A\n");
		}
	    }
a755 12
	    {
		vect_t	va, vb;
	    	point_t	hit_pt;
	    	VMOVE( hit_pt, vu2b->v_p->vg_p->coord );
		VSUB2( va, hit_pt, eu1->vu_p->v_p->vg_p->coord  );
		VSUB2( vb, eu1->eumate_p->vu_p->v_p->vg_p->coord, hit_pt );
		VUNITIZE(va);
		VUNITIZE(vb);
		if( VDOT( va, vb ) <= 0.7071 )  {
			rt_bomb("nmg_isect_two_colinear_edge2p() eu changes direction? B\n");
		}
	    }
d869 1
a869 1
	    vu2a->v_p == vu1b->v_p || vu2b->v_p == vu1b->v_p )
d1408 1
a1408 1
		nmg_break_3edge_at_plane(hit_pt, fu, bs, eu, v1, v1mate);
d2166 1
a2166 1
			vu1a->v_p->vg_p->coord, eu2_dir, &is->tol );
@


10.74
log
@Added checking to nmg_isect_two_colinear_edge2p()
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.73 93/09/21 14:07:37 mike Exp Locker: mike $ (BRL)";
a42 24

/* XXX move to vmath.h, incorporate in librt/shoot.c */
/* Given a direction vector, compute the inverses of each element. */
/* When division by zero would have occured, mark inverse as INFINITY. */
#define VINVDIR( _inv, _dir )	{ \
	if( (_dir)[X] < -SQRT_SMALL_FASTF || (_dir)[X] > SQRT_SMALL_FASTF )  { \
		(_inv)[X]=1.0/(_dir)[X]; \
	} else { \
		(_dir)[X] = 0.0; \
		(_inv)[X] = INFINITY; \
	} \
	if( (_dir)[Y] < -SQRT_SMALL_FASTF || (_dir)[Y] > SQRT_SMALL_FASTF )  { \
		(_inv)[Y]=1.0/(_dir)[Y]; \
	} else { \
		(_dir)[Y] = 0.0; \
		(_inv)[Y] = INFINITY; \
	} \
	if( (_dir)[Z] < -SQRT_SMALL_FASTF || (_dir)[Z] > SQRT_SMALL_FASTF )  { \
		(_inv)[Z]=1.0/(_dir)[Z]; \
	} else { \
		(_dir)[Z] = 0.0; \
		(_inv)[Z] = INFINITY; \
	} \
    }
@


10.73
log
@When joining a lone vertex to an edge vertex, use the coordinates
from the edge vertex, not the lone vertex.
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.72 93/09/15 02:36:52 mike Exp Locker: mike $ (BRL)";
d753 12
d786 12
@


10.72
log
@More debugging, some comments.
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.71 93/09/14 22:28:09 mike Exp Locker: mike $ (BRL)";
d341 2
a342 1
		nmg_jv( vu->v_p, eu->vu_p->v_p );
d347 1
@


10.71
log
@Added markers for 2-D special case handling
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.70 93/09/14 21:48:50 mike Exp Locker: mike $ (BRL)";
d546 20
d1490 1
a1490 1
		rt_log("nmg_isect_loop3p_face3p(, lu=x%x, fu=x%x)\n", lu, fu);
d1535 4
d1546 3
d1556 3
a1558 2
	struct loopuse	*lu, *fu2lu;
	struct loop_g	*lg;
d1571 3
a1573 3
	for( RT_LIST_FOR( lu, loopuse, &fu1->lu_hd ) )  {
		NMG_CK_LOOPUSE(lu);
		if (lu->up.fu_p != fu1) {
d1576 3
a1578 3
		NMG_CK_LOOP(lu->l_p);
		lg = lu->l_p->lg_p;
		NMG_CK_LOOP_G(lg);
d1584 2
a1585 2
		for (RT_LIST_FOR(fu2lu, loopuse, &fu2->lu_hd )){
			struct loop_g *fu2lg;
d1587 4
a1590 4
			NMG_CK_LOOPUSE(fu2lu);
			NMG_CK_LOOP(fu2lu->l_p);
			fu2lg = fu2lu->l_p->lg_p;
			NMG_CK_LOOP_G(fu2lg);
d1592 2
a1593 2
			if (! V3RPP_OVERLAP_TOL( fu2lg->min_pt, fu2lg->max_pt,
			    lg->min_pt, lg->max_pt, &bs->tol)) continue;
d1595 9
a1603 1
			nmg_isect_loop3p_face3p(bs, lu, fu2);
d1875 2
d1890 1
a1890 1
		rt_log("nmg_isect_two_face3p( fu1=x%x, fu2=x%x )\n", fu1, fu2);
d1933 4
d1964 4
d1996 5
d2168 4
a2171 3
#if 0
	    	/* Does this make sense to do with wire edges? */
	    	if( eu1->e_p != eu2->e_p )
a2172 1
#endif
@


10.70
log
@Improved debugging prints in nmg_break_3edge_at_plane()
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.69 93/09/10 23:17:47 mike Exp Locker: mike $ (BRL)";
d1266 1
a1266 1
			rt_log("nmg_isect_3edge_3face: edge lies ON face, using 2D code\n");
d1274 7
@


10.69
log
@handle the many omissions in the prototype "all of shell1 against all of shell2".
Added nmg_isect_edge3p_shell(), nmg_isect_edge3p_edge3p() [which isn't
finished yet], and nmg_isect_vertex3_edge3p() [which isn't started yet].
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.68 93/09/10 19:38:27 mike Exp Locker: mike $ (BRL)";
d211 4
a214 2
rt_log("nmg_isect2d_prep(f=x%x)\n", f1);
PLPRINT("N", fg->N);
d510 5
a514 7
nmg_break_3edge_at_plane(hit_pt, fu, bs, eu, v1, v1mate)
point_t	hit_pt;
struct faceuse *fu;
struct nmg_inter_struct *bs;
struct edgeuse *eu;
struct vertex	*v1;
struct vertex	*v1mate;
d518 3
a520 1
	struct edgeuse *euforw;
d522 2
a523 1
	NMG_CK_INTER_STRUCT(bs);
d525 5
d534 4
a537 3
		rt_log("Splitting %g, %g, %g <-> %g, %g, %g\n",
			V3ARGS(v1->vg_p->coord), V3ARGS(v1mate->vg_p->coord) );
		VPRINT("\tPoint of intersection", hit_pt);
d540 6
d550 1
a550 1
	vu_other = nmg_find_pt_in_face(hit_pt, fu, &(bs->tol));
d557 1
a557 1
		(void)nmg_tbl(bs->l2, TBL_INS_UNIQUE, &vu_other->l.magic);
a559 3
		if (rt_g.NMG_debug & DEBUG_POLYSECT)
			rt_log("Making new vertex\n");

d562 2
d574 2
a575 1
			rt_log("Just split %g, %g, %g -> %g, %g, %g\n",
d579 2
a580 1
			rt_log("\t\t\t%g, %g, %g -> %g, %g, %g\n",
d594 3
a596 2
		    	VPRINT("Making vertexloop",
				vu_other->v_p->vg_p->coord);
d598 1
a598 1
		(void)nmg_tbl(bs->l2, TBL_INS_UNIQUE, &vu_other->l.magic);
d612 1
a612 1
	(void)nmg_tbl(bs->l1, TBL_INS_UNIQUE, &euforw->vu_p->l.magic);
@


10.68
log
@Added comments to front.
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.67 93/09/10 16:26:43 mike Exp Locker: mike $ (BRL)";
d433 2
a434 2
nmg_isect_3vertex_3face(bs, vu, fu)
struct nmg_inter_struct *bs;
d443 1
a443 1
	NMG_CK_INTER_STRUCT(bs);
d454 2
a455 2
		(void)nmg_tbl(bs->l1, TBL_INS_UNIQUE, &vu->l.magic);
		(void)nmg_tbl(bs->l2, TBL_INS_UNIQUE, &vup->l.magic);
d466 1
a466 1
	if ( !NEAR_ZERO(dist, bs->tol.dist) )  {
d479 1
a479 1
	nmg_isect_vert2p_face2p( bs, vu, fu );
d484 2
a485 2
		(void)nmg_tbl(bs->l1, TBL_INS_UNIQUE, &vu->l.magic);
		(void)nmg_tbl(bs->l2, TBL_INS_UNIQUE, &vup->l.magic);
d497 2
a498 2
	(void)nmg_tbl(bs->l1, TBL_INS_UNIQUE, &vu->l.magic);
    	(void)nmg_tbl(bs->l2, TBL_INS_UNIQUE, &vup->l.magic);
d763 2
a764 2
	fastf_t	dist[2];
	int	status;
d801 3
a803 1
			rt_log("edge2p_edge2p: shared edge topology, both ends\n");
d1276 4
d1300 5
d2044 156
d2211 3
d2216 4
a2219 1
	struct shell_a	*sa1, *sa2;
d2234 9
d2299 6
a2304 1
		/* Check f1 from s1 against wire loops and edges of s2 */
d2306 14
d2321 3
d2333 1
a2333 4
	/*
	 *  Check each wire loop and wire edge of shell 1 against shell 2.
	 */
#if 0
d2335 8
d2344 2
d2347 2
a2349 1
#endif
d2352 21
d2374 8
d2420 2
@


10.67
log
@Changed name of nmg_touchingloops() to nmg_loop_touches_self().
@
text
@d4 14
a17 1
 *	Routines to intersect two NMG regions.
d21 1
a22 1
 *	Michael John Muuss
d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.66 93/09/08 23:17:00 mike Exp Locker: mike $ (BRL)";
@


10.66
log
@#if 0'ed out the take midpoint of two coord before joining the verts code.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.65 93/09/08 22:47:59 mike Exp Locker: mike $ (BRL)";
a54 1
/* Was nmg_boolstruct, but that name has appeared in nmg.h */
d82 1
a82 1
RT_EXTERN(CONST struct vertexuse *nmg_touchingloops, (CONST struct loopuse *lu));
d236 1
a236 1
char		*str;
d1091 10
a1225 2
		struct nmg_ptbl		t1, t2;
		point_t	foo;
a2135 1

d2149 1
a2149 1
		if( vu = nmg_touchingloops( lu ) )  {
d2159 1
a2159 1
			rt_bomb("nmg_touchingloops()\n");
d2167 1
d2169 1
a2169 1
 *			N M G _ T O U C H I N G L O O P S
d2185 1
a2185 1
nmg_touchingloops( lu )
@


10.65
log
@Added return codes to nmg_isect_edge2p_vert2p().
Added more debugging
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.64 93/09/08 19:49:33 mike Exp Locker: mike $ (BRL)";
d1323 1
d1327 1
d1370 1
d1374 1
@


10.64
log
@Changed variable names in nmg_isect_edge2p_face2p() to make things
clearer.
Added return codes to nmg_isect_edge2p_vert2p(), and
nmg_isect_edge2p_edge2p(), to allow eliminating some XXX code.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.63 93/09/07 09:21:54 jra Exp Locker: mike $ (BRL)";
d296 1
d303 4
a306 2
	if( vu->v_p == eu->vu_p->v_p )  return 1;
	if( vu->v_p == eu->eumate_p->vu_p->v_p )  return 1;
d323 1
d328 2
a329 1
		return 1;
d333 2
a334 1
		return 1;
d338 2
a339 1
		return 2;
d341 4
a344 1
	return 0;
d433 1
d437 1
a437 1
		rt_log("nmg_isect_3vertex_3face(, vu=x%x, fu=x%x)\n", vu, fu);
d441 1
d454 4
a457 1
	if ( !NEAR_ZERO(dist, bs->tol.dist) )  return;
a458 2
	/* The point lies on the plane of the face, by geometry. */

d460 3
d471 1
@


10.63
log
@reversed order of fu args in call to nmg_face_cutjoin from nmg_isect_edge2p_face2p
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.62 93/08/27 22:46:57 mike Exp Locker: jra $ (BRL)";
a282 1
 *	1	if the vertex and edge intersected and have been joined
d284 2
d301 5
a305 1
	/* Perhaps a 2d formulation would be better? */
d324 1
a324 1
		return;
d328 1
a328 1
		return;
d332 1
a332 1
		return;
d334 1
d713 5
d719 1
a719 1
void
d740 1
d773 1
d821 1
d825 1
a825 1
	if (status < 0)  return;	/* No geometric intersection */
d872 1
a872 1
		return;
d892 1
a892 1
			return;
d904 1
a904 1
			return;
d911 1
a911 1
			return;
d920 1
a920 1
		return;
d930 1
a930 1
			return;
d942 1
a942 1
			return;
d949 1
a949 1
			return;
d958 1
a958 1
		return;
d981 1
a981 1
			return;
d996 1
a996 1
			return;
d1014 1
a1014 1
			return;
d1018 1
a1018 1
		return;
d1060 1
d1116 2
d1501 1
a1501 1
 *  Given one (2D) edge lying in the plane of another face,
d1515 1
a1515 1
nmg_isect_edge2p_face2p( is, eu, fu, eu_fu )
d1517 3
a1519 3
struct edgeuse		*eu;
struct faceuse		*fu;
struct faceuse		*eu_fu;		/* fu that eu is from */
d1522 1
a1522 1
	struct loopuse	*lu;
d1525 1
a1525 1
	struct edgeuse		*otherf_eu;
d1528 1
d1531 3
a1533 3
	NMG_CK_EDGEUSE(eu);
	NMG_CK_FACEUSE(fu);
	NMG_CK_FACEUSE(eu_fu);
d1536 1
a1536 1
		rt_log("nmg_isect_edge2p_face2p(eu=x%x, fu=x%x, eu_fu=x%x)\n", eu, fu, eu_fu);
d1538 2
a1539 2
	if( fu->orientation != OT_SAME )  rt_bomb("nmg_isect_edge2p_face2p() fu not OT_SAME\n");
	if( eu_fu->orientation != OT_SAME )  rt_bomb("nmg_isect_edge2p_face2p() eu_fu not OT_SAME\n");
d1542 4
a1545 4
	/* XXX This searches whole other shell.  Should be shared w/fu, but... */
	otherf_eu = nmg_findeu( eu->vu_p->v_p, eu->eumate_p->vu_p->v_p,
	    fu->s_p, (CONST struct edgeuse *)NULL, 0 );
	if( otherf_eu != (struct edgeuse *)NULL )  {
d1547 2
a1548 2
		NMG_CK_EDGEUSE(otherf_eu);
		if( otherf_eu->e_p != eu->e_p )  {
d1551 1
a1551 1
			nmg_radial_join_eu( eu, otherf_eu, &is->tol );
d1565 1
a1565 1
    	    	nmg_pl_2fu( "Isect_2d_faces%d.pl", fno++, fu, eu_fu, 0 );
d1570 1
a1570 1
	 *  i.e. the line that contains the edge "eu".
d1575 2
a1576 2
	vu1 = eu->vu_p;
	vu2 = RT_LIST_PNEXT_CIRC( edgeuse, eu )->vu_p;
d1579 1
a1579 1
			rt_log("nmg_isect_edge2p_face2p(eu=x%x) skipping 0-len edge (topology)\n", eu);
d1586 3
a1588 3
VPRINT("fu min", fu->f_p->fg_p->min_pt);
VPRINT("fu max", fu->f_p->fg_p->max_pt);
	if( !rt_in_rpp( &line, invdir, fu->f_p->fg_p->min_pt, fu->f_p->fg_p->max_pt ) )  {
d1606 9
a1614 6
nmg_fu_touchingloops(fu);
nmg_fu_touchingloops(eu_fu);
nmg_region_v_unique( fu->s_p->r_p, &is->tol );
nmg_region_v_unique( eu_fu->s_p->r_p, &is->tol );
	for( RT_LIST_FOR( lu, loopuse, &fu->lu_hd ) )  {
		struct edgeuse	*eu2;
d1616 16
a1631 8
		if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) == NMG_VERTEXUSE_MAGIC )  {
			struct vertexuse	*vu;
			vu = RT_LIST_FIRST( vertexuse, &lu->down_hd );
			/* XXX How to ensure that if original edge is split,
			 * then both parts get processed?
			 */
			(void)nmg_isect_edge2p_vert2p( is, eu, vu );
			continue;
d1633 1
a1633 10
		for( RT_LIST_FOR( eu2, edgeuse, &lu->down_hd ) )  {
			/* isect eu with eu */
			/* XXX same question here */
			nmg_isect_edge2p_edge2p( is, eu, eu2, eu_fu, fu );
nmg_fu_touchingloops(fu);
nmg_fu_touchingloops(eu_fu);
nmg_region_v_unique( fu->s_p->r_p, &is->tol );
nmg_region_v_unique( eu_fu->s_p->r_p, &is->tol );
		}
	}
d1636 1
a1636 1
	    	rt_log("nmg_isect_edge2p_face2p(eu=x%x, fu=x%x) vert_lists A:\n", eu, fu );
d1641 2
a1642 2
	nmg_purge_unwanted_intersection_points(&vert_list1, fu, &is->tol);
	nmg_purge_unwanted_intersection_points(&vert_list2, eu_fu, &is->tol);
d1645 1
a1645 1
	    	rt_log("nmg_isect_edge2p_face2p(eu=x%x, fu=x%x) vert_lists B:\n", eu, fu );
d1655 10
a1664 10
nmg_fu_touchingloops(fu);
nmg_fu_touchingloops(eu_fu);
nmg_region_v_unique( fu->s_p->r_p, &is->tol );
nmg_region_v_unique( eu_fu->s_p->r_p, &is->tol );
	nmg_face_cutjoin(&vert_list1, &vert_list2, eu_fu, fu, is->pt, is->dir, &is->tol);
nmg_fu_touchingloops(fu);		/* XXX r410 dies here */
nmg_fu_touchingloops(eu_fu);
nmg_region_v_unique( fu->s_p->r_p, &is->tol );
nmg_region_v_unique( eu_fu->s_p->r_p, &is->tol );
	nmg_mesh_faces(fu, eu_fu, &is->tol);
d1669 2
a1670 2
nmg_fu_touchingloops(fu);
nmg_fu_touchingloops(eu_fu);
@


10.62
log
@Enforces desired constraints on intersection ray in 2D case, but
it still does not help the Bradley r1 problem.  More study is needed.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.61 93/08/27 21:41:26 mike Exp Locker: mike $ (BRL)";
d271 1
a271 1
		rt_log("\tv=x%x\n", v);
d748 2
a749 2
		rt_log("nmg_isect_edge2p_edge2p(eu1=x%x, eu2=x%x)\n\tvu1a=%x vu1b=%x, vu2a=%x vu2b=%x\n\tv1a=%x v1b=%x,   v2a=%x v2b=%x\n",
			eu1, eu2,
d1518 1
a1518 1
		rt_log("nmg_isect_edge2p_face2p(eu=x%x, fu=x%x)\n", eu, fu);
d1639 1
a1639 1
	nmg_face_cutjoin(&vert_list1, &vert_list2, fu, eu_fu, is->pt, is->dir, &is->tol);
d1897 5
d1932 10
@


10.61
log
@Took out "PROPER_2D" #ifdefs.  That way just isn't right.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.60 93/08/27 21:37:06 mike Exp Locker: mike $ (BRL)";
d31 24
d722 1
a722 1
	vect_t	dir;
d765 8
a772 5
	 *  Construct the ray which contains the line of intersection.
	 *  This needs to be done every pass:  it changes as edges are cut
XXX which edge to use?  Or at least, which direction?
	 *  This needs to be done BEFORE any topology checking,
	 *  to establish is->pt for later use.
a773 3
	VMOVE( is->pt, vu1a->v_p->vg_p->coord );		/* 3D line */
	VSUB2( is->dir, vu1b->v_p->vg_p->coord, is->pt );

d794 1
a794 1
		rt_log("\trt_isect_lseg2_lseg2()=%d, dist: %g, %g\n",
d849 1
a849 1
			rt_log("\trt_isect_lseg2_lseg2()=%d, eu2dist: %g, %g\n",
d868 2
a869 1
	VJOIN1( hit_pt, is->pt, dist[0], is->dir );	/* 3d */
a1154 1
	 *  Starting vertex does not lie on the face according to topology.
d1509 2
d1549 38
@


10.60
log
@Documented how proper intersection ray is to be chosen, so that
"left" vectors work out properly.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.59 93/08/27 04:53:03 mike Exp Locker: mike $ (BRL)";
d759 1
a759 2
#define PROPER_2D	0
#if PROPER_2D
a764 3
	status = rt_isect_lseg2_lseg2(&dist[0], eu1_start, eu1_dir,
			eu2_start, eu2_dir, &is->tol );
#else
d768 1
a768 1
#endif
d927 1
a927 1
#if !PROPER_2D
d977 1
a977 1
#endif
@


10.59
log
@Added some comments, and face orientation checking.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.58 93/08/21 05:34:09 mike Exp Locker: mike $ (BRL)";
d1847 15
a1861 2
	 *  The start point will be at the edge, and direction isn't
	 *  important, as the positive part of the ray will cross the faces.
@


10.58
log
@Bad arg to nmg_get_2d_vertex().
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.57 93/08/20 06:16:44 mike Exp Locker: mike $ (BRL)";
d740 7
a746 1
	/* This needs to be done every pass:  it changes as edges are cut */
d1131 2
d1426 3
d1469 1
a1469 1
 *  Note that nmg_isect_edge2p_edge2p() completely conducts the
d1474 2
d1498 3
d1844 6
a1849 1
	/* Extents of face1 overlap face2 */
@


10.57
log
@More careful checking of cached 2D projections.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.56 93/08/19 04:52:57 mike Exp Locker: mike $ (BRL)";
d126 1
a126 1
		rt_log("nmg_get_2d_vertex ERROR #%d (%g,%g,%g) becomes (%g,%g) %g != zero!\n",
d138 1
a138 1
		rt_log("2d #%d (%g,%g,%g) becomes (%g,%g) %g\n",
d744 2
a745 2
	nmg_get_2d_vertex( eu1_start, vu1a->v_p, is, fu1 );	/* 2D line */
	nmg_get_2d_vertex( eu1_end, vu1b->v_p, is, fu1 );
d748 2
a749 2
	nmg_get_2d_vertex( eu2_start, vu2a->v_p, is, fu1 );
	nmg_get_2d_vertex( eu2_end, vu2b->v_p, is, fu1 );
d1509 1
a1509 1
    	    	nmg_pl_2fu( "Isect_faces%d.pl", fno++, fu, eu_fu, 0 );
@


10.56
log
@Fixed bugs in 3edge_3face dropping into 2D code.
Changed over-agressive topology checks to wait until co-linearity has
been shown not to exist.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.55 93/08/19 02:46:47 mike Exp Locker: mike $ (BRL)";
d43 1
d101 6
d128 7
d174 1
d748 2
a749 2
	nmg_get_2d_vertex( eu2_start, vu2a->v_p, is, fu2 );
	nmg_get_2d_vertex( eu2_end, vu2b->v_p, is, fu2 );
d1164 3
d1168 1
a1168 1
		is.vert2d = 0;
a1169 14
		rt_log("nmg_isect_3edge_3face: edge lies on face, 'shouldn't happen', using 2D code\n");
		EUPRINT("eu", eu);
		VPRINT("start_pt", start_pt);
		VPRINT("edge_vect", edge_vect);
		PLPRINT("N", fu->f_p->fg_p->N);
		rt_g.NMG_debug |= DEBUG_POLYSECT;
		nmg_get_2d_vertex( foo, eu->vu_p->v_p, &is, fu );
		VPRINT("eu_v1", eu->vu_p->v_p->vg_p->coord );
		VPRINT("eu_v1 2d", foo);
		nmg_get_2d_vertex( foo, eu->eumate_p->vu_p->v_p, &is, fu );
		VPRINT("eu_v2", eu->eumate_p->vu_p->v_p->vg_p->coord );
		VPRINT("eu_v2 2d", foo);
		mat_print("is->proj", is.proj);

a1170 1
		rt_log("nmg_isect_3edge_3face: END END END\n");
@


10.55
log
@The  "start vertex is topologically on the other
face" fast-test code was only reasonable if the edge is non-coplanar
with the face.  If the edge lies in the face, then special 2D handling
is required, as there can be arbitrary many points of intersection
between the edge and the face.
Code reorganized to defer the start point's topology check until after the test for co-planarity was
performed.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.54 93/08/19 01:36:33 mike Exp Locker: mike $ (BRL)";
d119 1
a119 1
		rt_log("nmg_get_2d_vertex ERROR %d (%g,%g,%g) becomes (%g,%g) %g != zero!\n",
a120 1
		mat_print("is->proj", is->proj);
d124 1
a124 1
		rt_log("%d (%g,%g,%g) becomes (%g,%g) %g\n",
d160 2
a161 1
rt_log("nmg_isect2d_prep()\n");
d714 6
a719 8
	/* First, a topology check. */
	if( vu1a->v_p == vu2a->v_p || vu1a->v_p == vu2b->v_p || vu2a->v_p == vu1b->v_p || vu2b->v_p == vu1b->v_p )  {
		/* These edges intersect, topologically.  No work. */
		/* XXX True if both endpoints match.
		 * XXX True if not co-linear.
		 * XXX what about co-linear case, with only one matching
		 * XXX endpoint to start with?
		 */
d721 1
a721 1
			rt_log("edge2p_edge2p: shared topology x%x--x%x, x%x--x%x\n", vu1a->v_p, vu1b->v_p, vu2a->v_p, vu2b->v_p);
d756 14
a1138 1
#if 0
d1158 1
a1158 1
		nmg_get_2d_vertex( foo, eu->vu_p->v_p, &is, nmg_find_fu_of_eu(eu) );
d1161 1
a1161 1
		nmg_get_2d_vertex( foo, eu->eumate_p->vu_p->v_p, &is, nmg_find_fu_of_eu(eu) );
d1171 1
a1171 1
		/* See if starting vertex is now shared */
d1173 2
a1178 3
#else
		rt_bomb("nmg_isect_3edge_3face: edge lies on face, 'shouldn't happen'\n");
#endif
@


10.54
log
@Fixed up 2D code to fuse non-shared edges that should be shared.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.53 93/08/19 00:10:50 mike Exp Locker: mike $ (BRL)";
d1052 1
a1052 1
 *	Intersect an edge with a (non-colinear/coplanar) face
a1098 21
	 * First check the topology.  If the topology says that starting
	 * vertex of this edgeuse is on the other face, enter the
	 * two vertexuses of that starting vertex in the list and return.
	 */
	if (vu_other=nmg_find_v_in_face(v1, fu)) {
		if (rt_g.NMG_debug & DEBUG_POLYSECT) {
			register pointp_t p1 = v1->vg_p->coord;
			register pointp_t p2 = v1mate->vg_p->coord;
			rt_log("Edgeuse %g, %g, %g -> %g, %g, %g\n",
				V3ARGS(p1), V3ARGS(p2) );
			rt_log("\tvertex topologically on isect plane.\n\tAdding vu1=x%x (v=x%x), vu_other=x%x (v=x%x)\n",
				eu->vu_p, eu->vu_p->v_p,
				vu_other, vu_other->v_p);
		}

		(void)nmg_tbl(bs->l1, TBL_INS_UNIQUE, &eu->vu_p->l.magic);
		(void)nmg_tbl(bs->l2, TBL_INS_UNIQUE, &vu_other->l.magic);
		goto out;
	}

	/*
d1170 21
d1201 1
a1201 1
			rt_log("\tStart point lies on plane of other face\n");
@


10.53
log
@Added some more debugging code, calling on nmg_region_v_unique().
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.52 93/08/18 21:28:50 mike Exp Locker: mike $ (BRL)";
d1462 1
d1472 13
a1484 18
	/* See if this edge is topologically on other face already */
	if( (vu1 = nmg_find_v_in_face( eu->vu_p->v_p, fu )) &&
	    (vu2 = nmg_find_v_in_face( eu->eumate_p->vu_p->v_p, fu )) )  {
#if 0
		rt_log("edge: (%g,%g,%g) (%g,%g,%g)\n", V3ARGS(eu->vu_p->v_p->vg_p->coord), V3ARGS(eu->eumate_p->vu_p->v_p->vg_p->coord) );
#endif
	    	/* Even though the endpoints are shared, ensure that
	    	 * the edge is also shared.
	    	 * XXX As the intersection progresses, the edges are not
	    	 * XXX initially shared.
	    	 * XXX Is there any merit to calling nmg_radial_join_eu()
	    	 * XXX here, or can it wait?
	    	 */
#if 0
	    	if( !nmg_is_edge_in_looplist( eu->e_p, &fu->lu_hd ) )
			rt_log("nmg_isect_edge2p_face2p() edge is not shared with other face\n");
#endif
		return;
@


10.52
log
@Added 'tol' parameter to face meshing (sorting) routines.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.51 93/08/14 07:07:48 mike Exp Locker: mike $ (BRL)";
d1505 2
d1525 2
d1552 2
d1557 2
d1604 2
d1629 2
d1648 2
d1682 2
d1700 2
d1719 2
d1744 2
d1847 2
@


10.51
log
@Beginnings of an attempt to handle edge-lies-in-face case.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.50 93/07/24 01:03:15 mike Exp $ (BRL)";
a30 3
/* XXX move to raytrace.h */
RT_EXTERN(struct faceuse	*nmg_find_fu_of_eu, (struct edgeuse *eu));

d1551 1
a1551 1
	nmg_mesh_faces(fu, eu_fu);
d1730 1
a1730 1
	nmg_mesh_faces(fu1, fu2);
@


10.50
log
@Shuffled around nmg_fu_touchingloops() code a bit.
It happens a lot for valid reasons, too, so it shouldn't
die (or blather) by default.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.49 93/07/23 17:03:55 mike Exp Locker: mike $ (BRL)";
d31 3
d63 3
d67 2
d124 1
d164 1
d1059 3
d1104 1
a1104 1
	 * two vertexuses of it in the list and return.
d1150 44
a1193 1
	if( status == 0 )  rt_bomb("nmg_isect_3edge_3face: edge lies on face, 'shouldn't happen'\n");
@


10.49
log
@#ifdef'ed the error message
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.48 93/07/20 22:50:23 mike Exp Locker: mike $ (BRL)";
d58 1
d1902 1
d1907 14
a1920 1
		if( nmg_touchingloops( lu ) )  return 1;
d1938 1
a1938 1
 *	1	Yes, the loop touches itself at least once.
d1941 1
a1941 1
int
d1950 1
a1950 1
		return 0;
d1985 1
a1985 7
#if 0
nmg_pr_lu_briefly(lu,0);
rt_bomb("nmg_touchingloops()\n");
#else
rt_log("nmg_touchingloops(lu=x%x, vu1=x%x, vu2=x%x, v=x%x\n", lu, vu, tvu, v );
#endif
			return 1;
d1988 1
a1988 1
	return 0;
@


10.48
log
@Added nmg_touchingloops(), as a debugging aid.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.47 93/05/20 17:13:31 mike Exp Locker: mike $ (BRL)";
d1970 1
d1973 3
@


10.47
log
@Changed rt_isect_ray_plane() to rt_isect_line3_plane().
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.46 93/04/08 02:43:37 mike Exp Locker: mike $ (BRL)";
d57 3
d1449 2
d1467 2
d1492 2
d1495 2
d1502 2
d1540 2
d1563 2
d1580 2
d1612 2
d1628 2
d1645 2
d1668 2
d1677 2
d1737 2
d1771 2
d1890 86
@


10.46
log
@Modified nmg_isect_edge2p_face2p() to recognize when an edgeuse
has been relocated into another loop, and to break off
before we start wandering down the wrong linked list!
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.45 93/04/07 06:34:51 mike Exp Locker: mike $ (BRL)";
d1122 2
a1123 1
	status = rt_isect_ray_plane(&dist, start_pt, edge_vect, fu->f_p->fg_p->N);
d1127 1
a1127 1
		rt_log("\tHit. Status of rt_isect_ray_plane: %d dist: %g\n",
d1130 1
a1130 1
		rt_log("\tMiss. Boring status of rt_isect_ray_plane: %d\n",
d1133 1
@


10.45
log
@Made DEBUG_VERIFY a runtime option
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.44 93/04/03 01:58:58 mike Exp Locker: mike $ (BRL)";
d1385 6
a1390 2
 * XXX How to really treat this edge as a ray, so that the state machine
 * XXX knows how to get in and out of loops?
d1401 2
d1413 2
a1414 6
	/* XXX Is it safe to assume that since both endpoints are
	 * XXX already registered in the other face that the edge
	 * XXX has been fully intersected already?
	 */
	if( nmg_find_v_in_face( eu->vu_p->v_p, fu ) &&
	    nmg_find_v_in_face( eu->eumate_p->vu_p->v_p, fu ) )  {
d1418 11
d1524 1
d1526 1
d1533 1
d1535 6
d1545 1
d1547 1
d1554 1
d1556 3
@


10.44
log
@nmg_find_vu_in_face() has changed name to nmg_find_pt_in_face()
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.43 93/03/31 00:37:10 mike Exp Locker: mike $ (BRL)";
d1559 4
a1562 4
#ifdef PARANOID_VERIFY
	nmg_vfu( &fu1->s_p->fu_hd, fu1->s_p );
	nmg_vfu( &fu2->s_p->fu_hd, fu2->s_p );
#endif
d1578 4
a1581 4
#ifdef PARANOID_VERIFY
	nmg_vfu( &fu1->s_p->fu_hd, fu1->s_p );
	nmg_vfu( &fu2->s_p->fu_hd, fu2->s_p );
#endif
d1593 4
a1596 4
#ifdef PARANOID_VERIFY
	nmg_vfu( &fu1->s_p->fu_hd, fu1->s_p );
	nmg_vfu( &fu2->s_p->fu_hd, fu2->s_p );
#endif
d1614 4
a1617 4
#ifdef PARANOID_VERIFY
	nmg_vfu( &fu1->s_p->fu_hd, fu1->s_p );
	nmg_vfu( &fu2->s_p->fu_hd, fu2->s_p );
#endif
d1630 4
a1633 4
#ifdef PARANOID_VERIFY
	nmg_vfu( &fu1->s_p->fu_hd, fu1->s_p );
	nmg_vfu( &fu2->s_p->fu_hd, fu2->s_p );
#endif
d1741 4
a1744 5
#ifdef PARANOID_VERIFY
	/* This is a good conservative place to check on things */
	nmg_vshell( &s1->r_p->s_hd, s1->r_p );
	nmg_vshell( &s2->r_p->s_hd, s2->r_p );
#endif
d1803 4
a1806 5
#ifdef PARANOID_VERIFY
		/* XXX expensive, but very conservative, for now */
		nmg_vshell( &s1->r_p->s_hd, s1->r_p );
		nmg_vshell( &s2->r_p->s_hd, s2->r_p );
#endif
d1823 4
a1826 5
#ifdef PARANOID_VERIFY
	/* After all is done, check things again */
	nmg_vshell( &s1->r_p->s_hd, s1->r_p );
	nmg_vshell( &s2->r_p->s_hd, s2->r_p );
#endif
@


10.43
log
@nmg_purge_unwanted_intersection_points() got a tol arg.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.42 93/03/24 03:20:38 mike Exp Locker: mike $ (BRL)";
d450 1
a450 1
	vu_other = nmg_find_vu_in_face(hit_pt, fu, &(bs->tol));
d1184 1
a1184 1
		vu_other = nmg_find_vu_in_face(v1->vg_p->coord, fu, &(bs->tol));
d1229 1
a1229 1
		vu_other = nmg_find_vu_in_face(v1mate->vg_p->coord, fu, &(bs->tol));
@


10.42
log
@Moved nmg_find_v_in_face() to ngm_mod.c
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.41 93/03/24 01:43:41 mike Exp Locker: mike $ (BRL)";
d1456 2
a1457 2
	nmg_purge_unwanted_intersection_points(&vert_list1, fu);
	nmg_purge_unwanted_intersection_points(&vert_list2, eu_fu);
d1598 2
a1599 2
	nmg_purge_unwanted_intersection_points(&vert_list1, fu2);
	nmg_purge_unwanted_intersection_points(&vert_list2, fu1);
@


10.41
log
@Housekeeping in nmg_break_3edge_at_plane()
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.40 93/03/24 01:18:39 mike Exp Locker: mike $ (BRL)";
a225 40
 *			N M G _ F I N D _ V E R T E X U S E_ O N _ F A C E
 *
 *	Perform a topological check to
 *	determine if the given vertex can be found in the given faceuse.
 *	If it can, return a pointer to the vertexuse which was found in the
 *	faceuse.
 */
static struct vertexuse *
nmg_find_vertexuse_on_face(v, fu)
CONST struct vertex	*v;
CONST struct faceuse	*fu;
{
	struct vertexuse *vu;
	struct edgeuse *eu;
	struct loopuse *lu;

#define CKLU_FOR_FU(_lu, _fu, _vu) \
	if (*_lu->up.magic_p == NMG_FACEUSE_MAGIC && _lu->up.fu_p == _fu) \
		return(_vu)

	NMG_CK_VERTEX(v);

	for( RT_LIST_FOR( vu, vertexuse, &v->vu_hd ) )  {
		NMG_CK_VERTEXUSE(vu);
		if (*vu->up.magic_p == NMG_EDGEUSE_MAGIC) {
			eu = vu->up.eu_p;
			if (*eu->up.magic_p == NMG_LOOPUSE_MAGIC) {
				lu = eu->up.lu_p;
				CKLU_FOR_FU(lu, fu, vu);
			}
		} else if (*vu->up.magic_p == NMG_LOOPUSE_MAGIC) {
			lu = vu->up.lu_p;
			CKLU_FOR_FU(lu, fu, vu);
		}
	}

	return((struct vertexuse *)NULL);
}

/*
d312 1
a312 1
	if( nmg_find_vertexuse_on_face(vu->v_p, fu) )  return;
d373 1
a373 1
	if (vup=nmg_find_vertexuse_on_face(vu->v_p, fu)) {
d398 1
a398 1
	if (vup=nmg_find_vertexuse_on_face(vu->v_p, fu)) {
d513 1
d520 1
a520 1
static void
d889 1
a889 1
			if( vu = nmg_find_vertexuse_on_face( vu2a->v_p, fu1 ) )  {
d904 1
a904 1
			if( vu = nmg_find_vertexuse_on_face( vu2b->v_p, fu1 ) )  {
d1010 1
a1010 1
	} else if( vu=nmg_find_vertexuse_on_face(vu1a->v_p, fu2) )  {
d1026 1
a1026 1
	} else if( vu=nmg_find_vertexuse_on_face(vu1b->v_p, fu2) )  {
d1089 1
a1089 1
	if (vu_other=nmg_find_vertexuse_on_face(v1, fu)) {
d1411 2
a1412 2
	if( nmg_find_vertexuse_on_face( eu->vu_p->v_p, fu ) &&
	    nmg_find_vertexuse_on_face( eu->eumate_p->vu_p->v_p, fu ) )  {
@


10.40
log
@Moved V3RPP_OVERLAP_TOL to vmath.h,
Made sure to check both vertex lists were empty before assuming
that there were no intersections.  (sanity check -- it didn't help).
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.39 93/03/19 05:15:08 mike Exp Locker: mike $ (BRL)";
a455 51
/*	M E G A _ C H E C K _ E B R E A K _ R E S U L T
 *
 *	Given all the trouble that nmg_ebreak() and nmg_esplit() were
 *	to develop, this routine exists to assist isect_edge_face() in
 *	checking the results of a call to these routines.
 */
static struct edgeuse *
mega_check_ebreak_result(eu)
struct edgeuse *eu;
{
	struct edgeuse *euforw;

	NMG_CK_EDGEUSE(eu);
	NMG_CK_EDGEUSE(eu->eumate_p);

	/* since we just split eu, the "next" edgeuse
	 * from eu CAN'T (in a working [as opposed to broken]
	 * system) be the list head.
	 */
	euforw = RT_LIST_PNEXT(edgeuse, eu);

	NMG_CK_EDGEUSE(euforw);
	NMG_CK_EDGEUSE(euforw->eumate_p);

	NMG_CK_VERTEXUSE(eu->vu_p);
	NMG_CK_VERTEXUSE(eu->eumate_p->vu_p);
	NMG_CK_VERTEXUSE(euforw->vu_p);
	NMG_CK_VERTEXUSE(euforw->eumate_p->vu_p);

	NMG_CK_VERTEX(eu->vu_p->v_p);
	NMG_CK_VERTEX(eu->eumate_p->vu_p->v_p);
	NMG_CK_VERTEX(euforw->vu_p->v_p);
	NMG_CK_VERTEX(euforw->eumate_p->vu_p->v_p);

	nmg_ck_lueu(eu->up.lu_p, "isect_edge_face" );

	if (euforw->vu_p->v_p != eu->eumate_p->vu_p->v_p)
		rt_bomb("I was supposed to share verticies!\n");

	/* Make sure there is no geometry at the place we're about
	 * to stick the new geometry
	 */
	if (eu->eumate_p->vu_p->v_p->vg_p != (struct vertex_g *)NULL) {
		VPRINT("where'd this geometry come from?",
			eu->eumate_p->vu_p->v_p->vg_p->coord);
		rt_bomb("I didn't order this\n");
	}

	return(euforw);
}

a492 1

d494 1
a494 1
			rt_log("re-using vertex from other face\n");
d496 1
a496 1
		(void)nmg_ebreak(vu_other->v_p, eu);
d503 2
a504 1
		(void)nmg_ebreak((struct vertex *)NULL, eu);
a505 8
		(void)mega_check_ebreak_result(eu);
		euforw = RT_LIST_PNEXT(edgeuse, eu);

		if (euforw->vu_p->v_p != eu->eumate_p->vu_p->v_p)
			rt_bomb("I thought you said I was sharing verticies!\n");

		nmg_vertex_gv(eu->eumate_p->vu_p->v_p, hit_pt);

a510 3
		if (euforw->vu_p->v_p != eu->eumate_p->vu_p->v_p)
			rt_bomb("I thought I was sharing verticies!\n");

d527 1
a527 1
		plu = nmg_mlv(&fu->l.magic, eu->eumate_p->vu_p->v_p, OT_UNSPEC);
a534 6
			if (RT_LIST_FIRST_MAGIC(&plu->down_hd) !=
				NMG_VERTEXUSE_MAGIC)
				rt_bomb("bad plu\n");
			if (RT_LIST_FIRST_MAGIC(&plu->lumate_p->down_hd) !=
				NMG_VERTEXUSE_MAGIC)
				rt_bomb("bad plumate\n");
a538 1
	euforw = RT_LIST_PNEXT_CIRC(edgeuse, eu);
d554 2
d584 1
a584 1
				rt_bomb("edge runs from&to same vertex\n");
@


10.39
log
@Added tolerance-based RPP overlap checking.
@
text
@a0 1
/* XXX Move to VMATH.h.  Use in nmg_misc.c */
a1 12
 * Compare two extents represented as RPPs.
 * If they overlap, within tolerance distance, return true
 */
#define V3RPP_OVERLAP_TOL(_l1, _h1, _l2, _h2, _t) \
    (! ((_l1)[0] > (_h2)[0] + (_t)->dist || \
	(_l1)[1] > (_h2)[1] + (_t)->dist || \
	(_l1)[2] > (_h2)[2] + (_t)->dist || \
	(_l2)[0] > (_h1)[0] + (_t)->dist || \
	(_l2)[1] > (_h1)[1] + (_t)->dist || \
	(_l2)[2] > (_h1)[2] + (_t)->dist ) )

/*
d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.38 93/03/16 01:18:57 mike Exp Locker: mike $ (BRL)";
d1571 1
a1571 1
    	if (vert_list1.end == 0) {
d1713 1
a1713 1
    	if (vert_list1.end == 0) {
@


10.38
log
@Moved 2d line routines from nmg_inter.c to plane.c
@
text
@d1 1
d3 12
d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.37 93/03/10 22:30:00 mike Exp Locker: mike $ (BRL)";
d1487 2
a1488 2
			if (! V3RPP_OVERLAP( fu2lg->min_pt, fu2lg->max_pt,
			    lg->min_pt, lg->max_pt)) continue;
d1798 2
a1799 2
	if ( !V3RPP_OVERLAP(f2->fg_p->min_pt, f2->fg_p->max_pt,
	    f1->fg_p->min_pt, f1->fg_p->max_pt) )  return;
d1874 2
a1875 2
	if ( ! V3RPP_OVERLAP(sa1->min_pt, sa1->max_pt,
	    sa2->min_pt, sa2->max_pt) )
d1894 2
a1895 2
		if( ! V3RPP_OVERLAP(sa2->min_pt, sa2->max_pt,
		    f1->fg_p->min_pt, f1->fg_p->max_pt) )
@


10.37
log
@Calling nmg_vshell() or nmg_vfu() all the time is *very* expensive.
Made nearly all calls conditionally compiled on PARANOID_VERIFY
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.36 93/03/10 00:06:25 mike Exp Locker: mike $ (BRL)";
a29 359

/*
 *			R T _ P T 3 _ P T 3 _ E Q U A L
 *
 *  Returns -
 *	1	if the two points are equal, within the tolerance
 *	0	if the two points are not "the same"
 */
int
rt_pt3_pt3_equal( a, b, tol )
CONST point_t		a;
CONST point_t		b;
CONST struct rt_tol	*tol;
{
	vect_t	diff;

	RT_CK_TOL(tol);
	VSUB2( diff, b, a );
	if( MAGSQ( diff ) < tol->dist_sq )  return 1;
	return 0;
}

/* XXX move to plane.c */

/*
 *			R T _ I S E C T _ L I N E 2 _ L I N E 2
 *
 *  Intersect two lines, each in given in parametric form:
 *
 *	X = P + t * D
 *  and
 *	X = A + u * C
 *
 *  While the parametric form is usually used to denote a ray
 *  (ie, positive values of the parameter only), in this case
 *  the full line is considered.
 *
 *  The direction vectors C and D need not have unit length.
 *
 *  Explicit Return -
 *	-1	no intersection, lines are parallel.
 *	 0	lines are co-linear
 *			dist[0] gives distance from P to A,
 *			dist[1] gives distance from P to (A+C) [not same as below]
 *	 1	intersection found (t and u returned)
 *			dist[0] gives distance from P to isect,
 *			dist[1] gives distance from A to isect.
 *
 *  Implicit Returns -
 *	When explicit return > 0, dist[0] and dist[1] are the
 *	line parameters of the intersection point on the 2 rays.
 *	The actual intersection coordinates can be found by
 *	substituting either of these into the original ray equations.
 */
int
rt_isect_line2_line2( dist, p, d, a, c, tol )
fastf_t			*dist;			/* dist[2] */
CONST point_t		p;
CONST vect_t		d;
CONST point_t		a;
CONST vect_t		c;
CONST struct rt_tol	*tol;
{
	fastf_t			hx, hy;		/* A - P */
	register fastf_t	det;
	register fastf_t	det1;

	RT_CK_TOL(tol);
#	if DEBUG_2D_LINES
		rt_log("rt_isect_line_line2() p=(%g,%g), d=(%g,%g)\n\t\ta=(%g,%g), c=(%g,%g)\n",
			V2ARGS(p), V2ARGS(d), V2ARGS(a), V2ARGS(c) );
#	endif

	/*
	 *  From the two components q and r, form a system
	 *  of 2 equations in 2 unknowns.
	 *  Solve for t and u in the system:
	 *
	 *	Px + t * Dx = Ax + u * Cx
	 *	Py + t * Dy = Ay + u * Cy
	 *  or
	 *	t * Dx - u * Cx = Ax - Px
	 *	t * Dy - u * Cy = Ay - Py
	 *
	 *  Let H = A - P, resulting in:
	 *
	 *	t * Dx - u * Cx = Hx
	 *	t * Dy - u * Cy = Hy
	 *
	 *  or
	 *
	 *	[ Dx  -Cx ]   [ t ]   [ Hx ]
	 *	[         ] * [   ] = [    ]
	 *	[ Dy  -Cy ]   [ u ]   [ Hy ]
	 *
	 *  This system can be solved by direct substitution, or by
	 *  finding the determinants by Cramers rule:
	 *
	 *	             [ Dx  -Cx ]
	 *	det(M) = det [         ] = -Dx * Cy + Cx * Dy
	 *	             [ Dy  -Cy ]
	 *
	 *  If det(M) is zero, then the lines are parallel (perhaps colinear).
	 *  Otherwise, exactly one solution exists.
	 */
	det = c[X] * d[Y] - d[X] * c[Y];

	/*
	 *  det(M) is non-zero, so there is exactly one solution.
	 *  Using Cramer's rule, det1(M) replaces the first column
	 *  of M with the constant column vector, in this case H.
	 *  Similarly, det2(M) replaces the second column.
	 *  Computation of the determinant is done as before.
	 *
	 *  Now,
	 *
	 *	                  [ Hx  -Cx ]
	 *	              det [         ]
	 *	    det1(M)       [ Hy  -Cy ]   -Hx * Cy + Cx * Hy
	 *	t = ------- = --------------- = ------------------
	 *	     det(M)       det(M)        -Dx * Cy + Cx * Dy
	 *
	 *  and
	 *
	 *	                  [ Dx   Hx ]
	 *	              det [         ]
	 *	    det2(M)       [ Dy   Hy ]    Dx * Hy - Hx * Dy
	 *	u = ------- = --------------- = ------------------
	 *	     det(M)       det(M)        -Dx * Cy + Cx * Dy
	 */
	hx = a[X] - p[X];
	hy = a[Y] - p[Y];
	det1 = (c[X] * hy - hx * c[Y]);
	if( NEAR_ZERO( det, SQRT_SMALL_FASTF ) )  {
		/* Lines are parallel */
		if( !NEAR_ZERO( det1, SQRT_SMALL_FASTF ) )  {
			/* Lines are NOT co-linear, just parallel */
#			if DEBUG_2D_LINES
				rt_log("parallel, not co-linear\n");
#			endif
			return -1;	/* parallel, no intersection */
		}

		/*
		 *  Lines are co-linear.
		 *  Determine t as distance from P to A.
		 *  Determine u as distance from P to (A+C).  [special!]
		 *  Use largest direction component, for numeric stability
		 *  (and avoiding division by zero).
		 */
		if( fabs(d[X]) >= fabs(d[Y]) )  {
			dist[0] = hx/d[X];
			dist[1] = (hx + c[X]) / d[X];
		} else {
			dist[0] = hy/d[Y];
			dist[1] = (hy + c[Y]) / d[Y];
		}
#		if DEBUG_2D_LINES
			rt_log("colinear, t = %g, u = %g\n", dist[0], dist[1] );
#		endif
		return 0;	/* Lines co-linear */
	}
	det = 1/det;
	dist[0] = det * det1;
	dist[1] = det * (d[X] * hy - hx * d[Y]);
#	if DEBUG_2D_LINES
		rt_log("intersection, t = %g, u = %g\n", dist[0], dist[1] );
#	endif

	return 1;		/* Intersection found */
}

/*
 *			R T _ I S E C T _ L I N E 2 _ L S E G 2
 *
 *  Intersect a line in parametric form:
 *
 *	X = P + t * D
 *
 *  with a line segment defined by two distinct points A and B=(A+C).
 *
 *  Explicit Return -
 *	-4	A and B are not distinct points
 *	-3	Lines do not intersect
 *	-2	Intersection exists, but outside segemnt, < A
 *	-1	Intersection exists, but outside segment, > B
 *	 0	Lines are co-linear (special meaning of dist[1])
 *	 1	Intersection at vertex A
 *	 2	Intersection at vertex B (A+C)
 *	 3	Intersection between A and B
 *
 *  Implicit Returns -
 *	t	When explicit return >= 0, t is the parameter that describes
 *		the intersection of the line and the line segment.
 *		The actual intersection coordinates can be found by
 *		solving P + t * D.  However, note that for return codes
 *		1 and 2 (intersection exactly at a vertex), it is
 *		strongly recommended that the original values passed in
 *		A or B are used instead of solving P + t * D, to prevent
 *		numeric error from creeping into the position of
 *		the endpoints.
 */
int
rt_isect_line2_lseg2( dist, p, d, a, c, tol )
fastf_t			*dist;		/* dist[2] */
CONST point_t		p;
CONST vect_t		d;
CONST point_t		a;
CONST vect_t		c;
CONST struct rt_tol	*tol;
{
	register fastf_t f;
	fastf_t		fuzz;
	int		ret;

	RT_CK_TOL(tol);
	/*
	 *  To keep the values of u between 0 and 1,
	 *  C should NOT be scaled to have unit length.
	 *  However, it is a good idea to make sure that
	 *  C is a non-zero vector, (ie, that A and B are distinct).
	 */
	if( (fuzz = MAGSQ(c)) < tol->dist_sq )  {
		return -4;		/* points A and B are not distinct */
	}

	if( (ret = rt_isect_line2_line2( dist, p, d, a, c, tol )) < 0 )  {
		/* Lines are parallel, non-colinear */
		return -3;		/* No intersection found */
	}
	if( ret == 0 )  {
		fastf_t	ptol;
		/*  Lines are colinear */
		/*  If P within tol of either endpoint (0, 1), make exact. */
		ptol = tol->dist / sqrt( d[X]*d[X] + d[Y]*d[Y] );
		if( dist[0] > -ptol && dist[0] < ptol )  dist[0] = 0;
		else if( dist[0] > 1-ptol && dist[0] < 1+ptol ) dist[0] = 1;

		if( dist[1] > -ptol && dist[1] < ptol )  dist[1] = 0;
		else if( dist[1] > 1-ptol && dist[1] < 1+ptol ) dist[1] = 1;
		return 0;		/* Colinear */
	}

	/*
	 *  The two lines intersect at a point.
	 *  If the dist[1] parameter is outside the range (0..1),
	 *  reject the intersection, because it falls outside
	 *  the line segment A--B.
	 *
	 *  Convert the tol->dist into allowable deviation in terms of
	 *  (0..1) range of the parameters.
	 */
	fuzz = tol->dist / sqrt(fuzz);
	if( dist[1] < -fuzz )
		return -2;		/* Intersection < A */
	if( (f=(dist[1]-1)) > fuzz )
		return -1;		/* Intersection > B */

	/* Check for fuzzy intersection with one of the verticies */
	if( dist[1] < fuzz )  {
		dist[1] = 0;
		return 1;		/* Intersection at A */
	}
	if( f >= -fuzz )  {
		dist[1] = 1;
		return 2;		/* Intersection at B */
	}
	return 3;			/* Intersection between A and B */
}

/*
 *			R T _ I S E C T _ L S E G 2  _ L S E G 2
 *
 *  Intersect two 2D line segments, defined by two points and two vectors.
 *  The vectors are unlikely to be unit length.
 *
 *  Explicit Return -
 *	-2	missed (line segments are parallel)
 *	-1	missed (colinear and non-overlapping)
 *	 0	hit (line segments colinear and overlapping)
 *	 1	hit (normal intersection)
 *
 *  Implicit Return -
 *	The value at dist[] is set to the parametric distance of the intercept
 *	dist[0] is parameter along p, range 0 to 1, to intercept.
 *	dist[1] is parameter along q, range 0 to 1, to intercept.
 *	If within distance tolerance of the endpoints, these will be
 *	exactly 0.0 or 1.0, to ease the job of caller.
 *
 *  Special note:  when return code is "0" for co-linearity, dist[1] has
 *  an alternate interpretation:  it's the parameter along p (not q)
 *  which takes you from point p to the point (q + qdir), i.e., it's
 *  the endpoint of the q linesegment, since in this case there may be
 *  *two* intersections, if q is contained within span p to (p + pdir).
 *  And either may be -10 if the point is outside the span.
 */
int
rt_isect_lseg2_lseg2( dist, p, pdir, q, qdir, tol )
fastf_t		*dist;
CONST point_t	p;
CONST vect_t	pdir;
CONST point_t	q;
CONST vect_t	qdir;
struct rt_tol	*tol;
{
	fastf_t	dx, dy;
	fastf_t	det;		/* determinant */
	fastf_t	det1, det2;
	fastf_t	b,c;
	fastf_t	hx, hy;		/* H = Q - P */
	fastf_t	ptol, qtol;	/* length in parameter space == tol->dist */
	int	status;

	RT_CK_TOL(tol);
rt_log("rt_isect_lseg2_lseg2() p=(%g,%g), pdir=(%g,%g)\n\t\tq=(%g,%g), qdir=(%g,%g)\n",
V2ARGS(p), V2ARGS(pdir), V2ARGS(q), V2ARGS(qdir) );

	status = rt_isect_line2_line2( dist, p, pdir, q, qdir, tol );
	if( status < 0 )  {
		/* Lines are parallel, non-colinear */
		return -1;	/* No intersection */
	}
	if( status == 0 )  {
		int	nogood = 0;
		/* Lines are colinear */
		/*  If P within tol of either endpoint (0, 1), make exact. */
		ptol = tol->dist / sqrt( pdir[X]*pdir[X] + pdir[Y]*pdir[Y] );
rt_log("ptol=%g\n", ptol);
		if( dist[0] > -ptol && dist[0] < ptol )  dist[0] = 0;
		else if( dist[0] > 1-ptol && dist[0] < 1+ptol ) dist[0] = 1;

		if( dist[1] > -ptol && dist[1] < ptol )  dist[1] = 0;
		else if( dist[1] > 1-ptol && dist[1] < 1+ptol ) dist[1] = 1;

		if( dist[1] < 0 || dist[1] > 1 )  nogood = 1;
		if( dist[0] < 0 || dist[0] > 1 )  nogood++;
		if( nogood >= 2 )
			return -1;	/* colinear, but not overlapping */
rt_log("  HIT colinear!\n");
		return 0;		/* colinear and overlapping */
	}
	/* Lines intersect */
	/*  If within tolerance of an endpoint (0, 1), make exact. */
	ptol = tol->dist / sqrt( pdir[X]*pdir[X] + pdir[Y]*pdir[Y] );
	if( dist[0] > -ptol && dist[0] < ptol )  dist[0] = 0;
	else if( dist[0] > 1-ptol && dist[0] < 1+ptol ) dist[0] = 1;

	qtol = tol->dist / sqrt( qdir[X]*qdir[X] + qdir[Y]*qdir[Y] );
	if( dist[1] > -qtol && dist[1] < qtol )  dist[1] = 0;
	else if( dist[1] > 1-qtol && dist[1] < 1+qtol ) dist[1] = 1;

rt_log("ptol=%g, qtol=%g\n", ptol, qtol);
	if( dist[0] < 0 || dist[0] > 1 || dist[1] < 0 || dist[1] > 1 ) {
rt_log("  MISS\n");
		return -1;		/* missed */
	}
rt_log("  HIT!\n");
	return 1;			/* hit, normal intersection */
}
@


10.36
log
@Removed some of the extra error checking, in the interest of speed.
It's only checked about 10X per operation, rather than 50X.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.35 93/03/08 21:42:01 mike Exp Locker: mike $ (BRL)";
d2024 1
d2027 1
d2043 1
d2046 1
d2058 1
d2061 1
d2079 1
d2082 1
d2095 1
d2098 1
d2206 2
d2210 1
d2269 1
d2273 1
d2289 6
@


10.35
log
@Added lots of error checking
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.34 93/03/08 20:51:15 mike Exp Locker: mike $ (BRL)";
a1548 5
	if (*eu->up.magic_p == NMG_LOOPUSE_MAGIC) {
		/* XXX edge sanity checking */
		nmg_veu( &eu->up.lu_p->down_hd, eu->up.magic_p );
	}

a1722 7
	if (*eu->up.magic_p == NMG_LOOPUSE_MAGIC) {
		/* XXX edge sanity checking */
		nmg_veu( &eu->up.lu_p->down_hd, eu->up.magic_p );
	}
	/* XXX Ensure that other face is still OK */
	nmg_vfu( &fu->s_p->fu_hd, fu->s_p );

a1773 2
	nmg_vfu( &fu->s_p->fu_hd, fu->s_p );
	nmg_veu( &lu->down_hd, &lu->l.magic );
a1786 2
	nmg_veu( &lu->down_hd, &lu->l.magic );
	nmg_vfu( &fu->s_p->fu_hd, fu->s_p );
a2132 2
	nmg_vfu( &fu1->s_p->fu_hd, fu1->s_p );
	nmg_vfu( &fu2->s_p->fu_hd, fu2->s_p );
a2164 3

	nmg_vfu( &fu1->s_p->fu_hd, fu1->s_p );
	nmg_vfu( &fu2->s_p->fu_hd, fu2->s_p );
@


10.34
log
@Added more sanity checking
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.33 93/03/03 01:51:05 mike Exp Locker: mike $ (BRL)";
d2035 1
d2040 3
d2057 3
d2070 3
d2088 4
d2102 3
d2149 2
d2183 3
d2276 4
@


10.33
log
@Changed to V3RPP_OVERLAP, DIST_PT_PLANE
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.32 93/02/25 04:35:08 mike Exp Locker: mike $ (BRL)";
d1534 1
a1534 1
		rt_log("nmg_isect_3edge_3face(, eu=x%x, fu=x%x)\n", eu, fu);
d1550 2
a1551 19
		/* some edge sanity checking */
		eunext = RT_LIST_PNEXT_CIRC(edgeuse, &eu->l);
		eulast = RT_LIST_PLAST_CIRC(edgeuse, &eu->l);
		NMG_CK_EDGEUSE(eunext);
		NMG_CK_EDGEUSE(eulast);
		if (v1 != eulast->eumate_p->vu_p->v_p) {
			VPRINT("unshared vertex (mine): ",
				v1->vg_p->coord);
			VPRINT("\t\t (last->eumate_p): ",
				eulast->eumate_p->vu_p->v_p->vg_p->coord);
			rt_bomb("nmg_isect_3edge_3face() discontiuous edgeloop\n");
		}
		if( eunext->vu_p->v_p != v1mate) {
			VPRINT("unshared vertex (my mate): ",
				v1mate->vg_p->coord);
			VPRINT("\t\t (next): ",
				eunext->vu_p->v_p->vg_p->coord);
			rt_bomb("nmg_isect_3edge_3face() discontinuous edgeloop\n");
		}
d1572 1
a1572 1
		return;
d1608 1
a1608 1
			return;		/* No geometric intersection */
d1638 1
a1638 1
		return;
d1676 1
a1676 1
		return;
d1684 1
a1684 1
		return;
d1721 1
a1721 1
		return;
d1726 11
d1740 1
a1740 1
 *			N M G _ I S E C T _ P L A N E _ L O O P _ F A C E
d1745 1
a1745 1
nmg_isect_plane_loop_face(bs, lu, fu)
d1754 1
a1754 1
		rt_log("nmg_isect_plane_loop_face(, lu=x%x, fu=x%x)\n", lu, fu);
d1774 1
a1774 1
		rt_bomb("nmg_isect_plane_loop_face() Unknown type of NMG loopuse\n");
d1786 2
d1794 1
a1794 1
			rt_bomb("nmg_isect_plane_loop_face: edge does not share loop\n");
d1799 1
a1799 1
		nmg_ck_lueu(lu, "nmg_isect_plane_loop_face");
d1801 2
d1852 1
a1852 1
			nmg_isect_plane_loop_face(bs, lu, fu2);
d2194 3
@


10.32
log
@Time to stop.  r23 now makes it to Isect_faces9.pl
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.31 93/02/24 23:23:07 mike Exp Locker: mike $ (BRL)";
d783 1
a783 1
	dist = NMG_DIST_PT_PLANE(pt, fu->f_p->fg_p->N);
d1851 1
a1851 1
			if (! NMG_EXTENT_OVERLAP( fu2lg->min_pt, fu2lg->max_pt,
d2135 1
a2135 1
	if ( !NMG_EXTENT_OVERLAP(f2->fg_p->min_pt, f2->fg_p->max_pt,
d2205 1
a2205 1
	if ( ! NMG_EXTENT_OVERLAP(sa1->min_pt, sa1->max_pt,
d2225 1
a2225 1
		if( ! NMG_EXTENT_OVERLAP(sa2->min_pt, sa2->max_pt,
@


10.31
log
@Fixed typo regarding which end of edge to add to intersect list.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.30 93/02/19 04:47:07 mike Exp Locker: mike $ (BRL)";
d1979 1
a1979 1
#if 1
d1981 1
@


10.30
log
@Changed calling sequence of nmg_ebreak() and nmg_esplit() to
use edgeuse pointers, rather than edge pointers.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.29 93/02/18 04:51:14 mike Exp Locker: mike $ (BRL)";
a30 3
/* XXX move to vmath.h */
#define V2ARGS(a)	(a)[X], (a)[Y]

d1163 4
a1166 1
		rt_log("nmg_isect_edge2p_edge2p(eu1=x%x, eu2=x%x)\n", eu1, eu2);
d1381 1
a1381 1
			(void)nmg_tbl(is->l2, TBL_INS_UNIQUE, &vu2a->l.magic);
d1385 1
a1385 1
			struct vertexuse	*new_vu;
d1388 2
a1389 4
			(void)nmg_ebreak( NULL, eu2 );
			/* Can't use eumate_p here, it's in wrong orientation face */
			new_vu = RT_LIST_PNEXT_CIRC(edgeuse,eu2)->vu_p;
			nmg_vertex_gv( new_vu->v_p, hit_pt );	/* 3d geom */
d1391 1
a1391 1
			plu = nmg_mlv(&fu1->l.magic, new_vu->v_p, OT_UNSPEC);
d1397 1
a1397 1
			(void)nmg_tbl(is->l2, TBL_INS_UNIQUE, &new_vu->l.magic);
d1417 1
a1417 3
		vu = vu2a;
		(void)nmg_tbl(is->l2, TBL_INS_UNIQUE, &vu->l.magic);
		nmg_ebreak( vu->v_p, eu1 );
d1419 1
d1425 1
a1425 3
		vu = vu2b;
		(void)nmg_tbl(is->l2, TBL_INS_UNIQUE, &vu->l.magic);
		nmg_ebreak( vu->v_p, eu1 );
d1427 1
d1979 1
a1979 1
#if 0
d1985 2
@


10.29
log
@Simple 2D intersection cases work.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.28 93/02/18 04:13:40 mike Exp Locker: mike $ (BRL)";
a33 2
RT_EXTERN( struct vertex *nmg_e2break, (struct edge *e1, struct edge *e2) );

d678 1
a678 1
		nmg_ebreak( vu->v_p, eu->e_p );
d910 1
a910 1
		(void)nmg_ebreak(vu_other->v_p, eu->e_p);
d917 1
a917 1
		(void)nmg_ebreak((struct vertex *)NULL, eu->e_p);
d1094 1
a1094 1
		(void)nmg_ebreak( vu2a->v_p, eu1->e_p );
d1115 1
a1115 1
		(void)nmg_ebreak( vu2b->v_p, eu1->e_p );
d1302 1
a1302 1
		(void)nmg_ebreak( vu1a->v_p, eu2->e_p );
d1340 1
a1340 1
		(void)nmg_ebreak( vu1b->v_p, eu2->e_p );
d1388 1
a1388 1
			(void)nmg_ebreak( NULL, eu2->e_p );
d1421 1
a1421 1
		nmg_ebreak( vu->v_p, eu1->e_p );
d1430 1
a1430 1
		nmg_ebreak( vu->v_p, eu1->e_p );
d1439 1
a1439 1
		new_v = nmg_e2break( eu1->e_p, eu2->e_p );
@


10.28
log
@Fixed several small but nasty typos, split out a subroutine
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.27 93/02/16 14:31:34 mike Exp Locker: mike $ (BRL)";
d103 4
a106 2
rt_log("rt_isect_line_line2() p=(%g,%g), d=(%g,%g)\n\t\ta=(%g,%g), c=(%g,%g)\n",
V2ARGS(p), V2ARGS(d), V2ARGS(a), V2ARGS(c) );
d172 3
a174 1
rt_log("parallel, not co-linear\n");
d192 3
a194 1
rt_log("colinear, t = %g, u = %g\n", dist[0], dist[1] );
d200 3
a202 1
rt_log("intersection, t = %g, u = %g\n", dist[0], dist[1] );
a351 1
#if 1
a392 121
#else
	/*
	 *  Form a system 2 equations in 2 unknowns.  Let:
	 *	P = p
	 *	D = pdir
	 *	Q = q
	 *	C = qdir
	 *
	 * then
	 *	Px + t * Dx = Qx + u * Cx
	 *	Py + t * Dy = Qy + u * Cy
	 *  or
	 *	t * Dx - u * Cx = Qx - Px
	 *	t * Dy - u * Cy = Qy - Py
	 *
	 *  Let H = Q - P, resulting in:
	 *
	 *	t * Dx - u * Cx = Hx
	 *	t * Dy - u * Cy = Hy
	 *
	 *  or
	 *
	 *	[ Dx  -Cx ]   [ t ]   [ Hx ]
	 *	[         ] * [   ] = [    ]
	 *	[ Dy  -Cy ]   [ u ]   [ Hy ]
	 *
	 *  This system can be solved by direct substitution, or by
	 *  finding the determinants by Cramers rule:
	 *
	 *	             [ Dx  -Cx ]
	 *	det(M) = det [         ] = -Dx * Cy + Cx * Dy
	 *	             [ Dy  -Cy ]
	 *
	 *  If det(M) is zero, then the lines are parallel (perhaps colinear).
	 *  Otherwise, exactly one solution exists.
	 */
	det = (qdir[X] * pdir[Y]) - (pdir[X] * qdir[Y]);

	/*
	 *  Using Cramer's rule, det1(M) replaces the first column
	 *  of M with the constant column vector, in this case H.
	 *  Similarly, det2(M) replaces the second column.
	 *  Computation of the determinant is done as before.
	 *
	 *  Now,
	 *
	 *	                  [ Hx  -Cx ]
	 *	              det [         ]
	 *	    det1(M)       [ Hy  -Cy ]   -Hx * Cy + Cx * Hy
	 *	t = ------- = --------------- = ------------------
	 *	     det(M)       det(M)        -Dx * Cy + Cx * Dy
	 *
	 *  and
	 *
	 *	                  [ Dx   Hx ]
	 *	              det [         ]
	 *	    det2(M)       [ Dy   Hy ]    Dx * Hy - Hx * Dy
	 *	u = ------- = --------------- = ------------------
	 *	     det(M)       det(M)        -Dx * Cy + Cx * Dy
	 */
	hx = q[X] - p[X];
	hy = q[Y] - p[Y];
	det1 = qdir[X] * hy - qdir[Y] * hx;
	if( NEAR_ZERO( det, SQRT_SMALL_FASTF ) )  {
		int	nogood = 0;
		/* lines are parallel */
		if( !NEAR_ZERO( det1, SQRT_SMALL_FASTF ) )  {
			/* Lines are NOT co-linear, just parallel */
			return -2;
		}
		/*
		 * Determine dist[0] for point Q w.r.t. P.
		 * There is a special interpretation of dist[1] here:
		 *	 point (Q + Qdir) w.r.t. P.
		 */
		if( fabs(pdir[X]) >= fabs(pdir[Y]) )  {
			dist[0] = hx / pdir[X];
			dist[1] = (hx + qdir[X]) / pdir[X];
		} else {
			dist[0] = hy / pdir[Y];
			dist[1] = (hy + qdir[Y]) / pdir[Y];
		}
rt_log("dist[0] = %g, dist[1] = %g\n", dist[0], dist[1] );

		/*  If within tolerance of an endpoint (0, 1), make exact. */
		ptol = tol->dist / sqrt( pdir[X]*pdir[X] + pdir[Y]*pdir[Y] );
		if( dist[0] > -ptol && dist[0] < ptol )  dist[0] = 0;
		else if( dist[0] > 1-ptol && dist[0] < 1+ptol ) dist[0] = 1;

		if( dist[1] > -ptol && dist[1] < ptol )  dist[1] = 0;
		else if( dist[1] > 1-ptol && dist[1] < 1+ptol ) dist[1] = 1;

		if( dist[1] < 0 || dist[1] > 1 )  nogood = 1;
		if( dist[0] < 0 || dist[0] > 1 )  nogood++;
		if( nogood >= 2 )
			return -1;	/* colinear, but not overlapping */
rt_log("  HIT colinear!\n");
		return 0;		/* colinear and overlapping */
	}

	det = 1 / det;
	dist[0] = det1 * det;
	det2 = pdir[X] * hy - pdir[Y] * hx;
	dist[1] = det2 * det;
rt_log("dist[0] = %g, dist[1] = %g\n", dist[0], dist[1] );

	/*  If within tolerance of an endpoint (0, 1), make exact. */
	ptol = tol->dist / sqrt( pdir[X]*pdir[X] + pdir[Y]*pdir[Y] );
	if( dist[0] > -ptol && dist[0] < ptol )  dist[0] = 0;
	else if( dist[0] > 1-ptol && dist[0] < 1+ptol ) dist[0] = 1;

	qtol = tol->dist / sqrt( qdir[X]*qdir[X] + qdir[Y]*qdir[Y] );
	if( dist[1] > -qtol && dist[1] < qtol )  dist[1] = 0;
	else if( dist[1] > 1-qtol && dist[1] < 1+qtol ) dist[1] = 1;

rt_log("ptol=%g, qtol=%g\n", ptol, qtol);
	if( dist[0] < 0 || dist[0] > 1 || dist[1] < 0 || dist[1] > 1 )
		return -1;		/* missed */
rt_log("  HIT!\n");
	return 1;			/* hit, normal intersection */
#endif
d478 1
a478 3
#if 0
	if (rt_g.NMG_debug & DEBUG_POLYSECT)
#endif
d481 1
a530 1
HPRINT("fg->N", fg->N);
d1074 2
a1075 1
	rt_log("nmg_isect_two_colinear_edge2p(x%x, x%x) %s\n", eu1, eu2, str);
d1153 5
d1159 1
a1159 1
	vu1b = eu1->eumate_p->vu_p;
d1161 1
a1161 1
	vu2b = eu2->eumate_p->vu_p;
d1167 2
a1168 1
	rt_log("nmg_isect_edge2p_edge2p(eu1=x%x, eu2=x%x)\n", eu1, eu2);
d1250 4
d1255 1
d1391 2
a1392 1
			new_vu = eu2->eumate_p->vu_p;
d1446 3
a1448 2
		(void)nmg_tbl(is->l1, TBL_INS_UNIQUE, &eu1->eumate_p->vu_p->l.magic);
		(void)nmg_tbl(is->l2, TBL_INS_UNIQUE, &eu2->eumate_p->vu_p->l.magic);
d1459 1
d1463 1
a1463 1
	vu1b = eu1->eumate_p->vu_p;
d1465 1
a1465 1
	vu2b = eu2->eumate_p->vu_p;
d1892 2
a1893 1
	rt_log("nmg_isect_edge2p_face2p(eu=x%x, fu=x%x)\n", eu, fu);
d1902 1
d1904 1
d1985 1
a1985 2
	rt_log("nmg_isect_two_face2p\n");
#if 1
a1990 1
	rt_g.NMG_debug |= DEBUG_INS;
d1993 3
d2154 2
a2155 2
		/* co-planar */
		rt_log("co-planar faces.\n");
a2156 1
#if 1
a2157 1
#endif
@


10.27
log
@Minor typos
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.26 93/02/12 00:43:58 mike Exp Locker: mike $ (BRL)";
d31 3
d103 2
a104 2
rt_log("rt_isect_line_line2() p=(%g,%g,%g), d=(%g,%g,%g)\n\t\ta=(%g,%g,%g), c=(%g,%g,%g)\n",
V3ARGS(p), V3ARGS(d), V3ARGS(a), V3ARGS(c) );
d186 1
a186 1
			dist[1] = (hx + c[Y]) / d[Y];
d263 1
d341 2
a342 2
rt_log("rt_isect_lseg2_lseg2() p=(%g,%g,%g), pdir=(%g,%g,%g)\n\t\tq=(%g,%g,%g), qdir=(%g,%g,%g)\n",
V3ARGS(p), V3ARGS(pdir), V3ARGS(q), V3ARGS(qdir) );
d380 2
a381 1
	if( dist[0] < 0 || dist[0] > 1 || dist[1] < 0 || dist[1] > 1 )
d383 1
d587 5
d688 1
a688 1
			rt_log("EDGEUSE\n");
d690 1
a690 1
			rt_log("LOOPUSE\n");
d699 1
a699 1
			rt_log("UNKNOWN\n");
d701 1
d1138 101
d1251 6
a1256 6
	point_t		this_start;
	point_t		this_end;
	vect_t		this_dir;
	point_t		other_start;
	point_t		other_end;
	vect_t		other_dir;
d1260 1
a1260 1
	point_t	hit_pt;
d1277 2
d1282 5
d1296 3
a1298 3
	nmg_get_2d_vertex( this_start, vu1a->v_p, is, fu1 );	/* 2D line */
	nmg_get_2d_vertex( this_end, vu1b->v_p, is, fu1 );
	VSUB2( this_dir, this_end, this_start );
d1300 3
a1302 3
	nmg_get_2d_vertex( other_start, vu2a->v_p, is, fu2 );
	nmg_get_2d_vertex( other_end, vu2b->v_p, is, fu2 );
	VSUB2( other_dir, other_end, other_start );
d1305 1
a1305 1
#define PROPER_2D	1
d1312 2
a1313 2
	status = rt_isect_lseg2_lseg2(&dist[0], this_start, this_dir,
			other_start, other_dir, &is->tol );
d1316 2
a1317 2
	status = rt_isect_line2_lseg2( dist, this_start, this_dir,
			other_start, other_dir, &is->tol );
d1326 9
a1334 4
		/* Need to handle special case of colinear overlapping
		 * edges.  There may be 2 intersect points.
		 * dist[1] has special meaning for this return status:
		 * it's distance w.r.t. eu1's 1st point, not eu2's 1st.
d1336 15
a1350 22
rt_log("2d overlapping edges\n");
nmg_ck_face_worthless_edges( fu1 );
nmg_ck_face_worthless_edges( fu2 );
		if( dist[0] == 0 )  {
			if (rt_g.NMG_debug & DEBUG_POLYSECT)
				rt_log("\tvu1a intersects vu2a\n");
			(void)nmg_tbl(is->l1, TBL_INS_UNIQUE, &vu1a->l.magic);
			(void)nmg_tbl(is->l2, TBL_INS_UNIQUE, &vu2a->l.magic);
			nmg_jv(vu1a->v_p, vu2a->v_p);
		} else if( dist[0] == 1 )  {
			if (rt_g.NMG_debug & DEBUG_POLYSECT)
				rt_log("\tvu1a intersects vu2b\n");
			(void)nmg_tbl(is->l1, TBL_INS_UNIQUE, &vu1a->l.magic);
			(void)nmg_tbl(is->l2, TBL_INS_UNIQUE, &vu2b->l.magic);
			nmg_jv(vu1a->v_p, vu2b->v_p);
		} else if( dist[0] > 0 && dist[0] < 1 )  {
			/* Break eu1 into two pieces */
			if (rt_g.NMG_debug & DEBUG_POLYSECT)
				rt_log("\tvu2a=x%x breaks eu1=x%x\n", vu2a, eu1 );
			(void)nmg_ebreak( vu2a->v_p, eu1->e_p );
			nmg_ck_face_worthless_edges( fu1 );
			nmg_ck_face_worthless_edges( fu2 );
d1352 13
a1364 24
/* XXX what about improper 2D handling here? */
		if( dist[1] == 0 )  {
			if (rt_g.NMG_debug & DEBUG_POLYSECT)
				rt_log("\tvu1a intersects vu2b\n");
			(void)nmg_tbl(is->l1, TBL_INS_UNIQUE, &vu1a->l.magic);
			(void)nmg_tbl(is->l2, TBL_INS_UNIQUE, &vu2b->l.magic);
			nmg_jv(vu1a->v_p, vu2b->v_p);
		} else if( dist[1] == 1 )  {
			if (rt_g.NMG_debug & DEBUG_POLYSECT)
				rt_log("\tsecond pt of eu1 intersects vu2b\n");
			(void)nmg_tbl(is->l1, TBL_INS_UNIQUE, &vu1b->l.magic);
			(void)nmg_tbl(is->l2, TBL_INS_UNIQUE, &vu2b->l.magic);
			nmg_jv(vu1b->v_p, vu2b->v_p);
		} else if( dist[1] > 0 && dist[1] < 1 )  {
			if (rt_g.NMG_debug & DEBUG_POLYSECT)
				rt_log("\tvu2b=x%x breaks eu1=x%x\n", vu2b, eu1 );
			(void)nmg_ebreak( vu2b->v_p, eu1->e_p );
			nmg_ck_face_worthless_edges( fu1 );
			nmg_ck_face_worthless_edges( fu2 );
		}
/* XXX what about improper 2D handling here? */
		/* XXX What about intersecting the other way, to make sure
		 * XXX that eu2 is broken in the right place too.
		 */
d1375 1
a1375 1
	VJOIN1( hit_pt, this_start, dist[0], this_dir );	/* 3d */
d1380 1
a1380 1
			rt_log("\tvu=x%x first point of eu1 is intersect point\n", vu1a);
d1393 1
a1393 1
				rt_log("\tfirst point of eu2 matches first point of eu1\n");
d1400 1
a1400 1
				rt_log("\tsecond point of eu2 matches first point of eu1\n");
d1407 1
a1407 1
			rt_log("\tbreaking eu2 on first point of eu1\n");
d1431 1
a1431 1
				rt_log("\tfirst point of eu2 matches vu1b\n");
d1460 10
a1469 5
			if (rt_g.NMG_debug & DEBUG_POLYSECT)
				rt_log("\t\tIntersect point is vu2a, make self-loop in fu1\n");
			plu = nmg_mlv(&fu1->l.magic, vu2a->v_p, OT_UNSPEC);
			nmg_loop_g(plu->l_p);
			vu = RT_LIST_FIRST( vertexuse, &plu->down_hd );
d1475 10
a1484 5
			if (rt_g.NMG_debug & DEBUG_POLYSECT)
				rt_log("\t\tIntersect point is vu2b, make self-loop in fu1\n");
			plu = nmg_mlv(&fu1->l.magic, vu2b->v_p, OT_UNSPEC);
			nmg_loop_g(plu->l_p);
			vu = RT_LIST_FIRST( vertexuse, &plu->down_hd );
d1602 1
a1602 1
		plu = nmg_mlv(&fu2->l.magic, vu1a->v_p, OT_UNSPEC);
d1993 1
a1993 1
	rt_log("nmg_isect_edge2p_face2p\n");
d1996 4
d2001 4
a2004 1
	    nmg_find_vertexuse_on_face( eu->eumate_p->vu_p->v_p, fu ) )  return;
d2083 1
d2087 4
d2254 1
a2254 1
#if 0
@


10.26
log
@More work on 2D case, changing from isect_lseg2_lseg2 to line2_lseg2.
Plus appropriate support routine upgrades
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.25 93/02/11 21:59:47 mike Exp Locker: mike $ (BRL)";
d239 1
d341 1
a341 2
	status = rt_isect_line2_line2( &dist[0], &dist[1],
		p, pdir, q, qdir, tol );
d1140 1
a1140 1
	point_t		this_dir;
d2081 1
@


10.25
log
@Changed names of pt3_pt3_equal, rt_isect_lseg2_lseg2
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.24 93/02/11 21:36:38 mike Exp Locker: mike $ (BRL)";
d55 1
d57 236
d300 1
a300 1
 *	-1	missed (no intersection)
d333 1
d335 1
d339 42
a380 1
	RT_CK_TOL(tol);
d444 1
a444 1
rt_log("parallel\n");
d472 3
a474 3
		if( dist[1] < 0 || dist[1] > 1 )  dist[1] = -10;
		if( dist[0] < 0 || dist[0] > 1 )  dist[0] = -10;
		if( dist[0] + dist[1] <= -20 )
d500 1
d509 1
a509 1
	point_t		pt;		/* line of intersection */
d764 1
d1138 6
a1143 3
	point_t	other_start;
	point_t	other_end;
	vect_t	other_dir;
a1148 1
	point_t		endpt;
d1173 2
a1174 3
	nmg_get_2d_vertex( is->pt, vu1a->v_p, is, fu1 );
	nmg_get_2d_vertex( endpt, vu1b->v_p, is, fu1 );
	VSUB2( is->dir, endpt, is->pt );
d1176 4
d1184 3
a1186 1
#if 1
d1192 1
a1192 1
	status = rt_isect_lseg2_lseg2(&dist[0], is->pt, is->dir,
d1196 2
a1198 1

d1200 2
a1201 6
	    if (status >= 0)
		rt_log("\tHit. Status of rt_isect_2dlsec_2dlseg: %d dist: %g, %g\n",
				status, dist[0], dist[1] );
	    else
		rt_log("\tMiss. Boring status of rt_isect_2dlsec_2dlseg: %d\n",
				status);
d1203 2
a1204 3
	if (status < 0)  {
		return;		/* No geometric intersection */
	}
d1216 1
a1216 1
				rt_log("\tfirst pt of eu1 intersects first pt of eu2\n");
d1222 1
a1222 1
				rt_log("\tfirst pt of eu1 intersects second pt of eu2\n");
d1228 2
a1229 9
			if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
/*YYY*/
				rt_log("\tvu=x%x first pt of eu2=x%x breaks eu1=x%x\n",
					vu2a, eu2, eu1 );
				rt_log("before nmg_ebreak(v=x%x, e=x%x)\n", vu2a->v_p, eu1->e_p );
				nmg_pr_v( vu2a->v_p, NULL );
				nmg_pr_eu( eu1, NULL );
				nmg_pr_eu( eu1->eumate_p, NULL );
			}
d1234 1
d1237 1
a1237 1
				rt_log("\tfirst pt of eu1 intersects second pt of eu2\n");
d1243 1
a1243 1
				rt_log("\tsecond pt of eu1 intersects second pt of eu2\n");
d1248 2
a1249 5
			if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
				rt_log("\tvu=x%x second pt of eu2=x%x breaks eu1=x%x\n", vu2b, eu2, eu1 );
				nmg_pr_eu( eu1, NULL );
				nmg_pr_eu( eu2, NULL );
			}
d1254 1
d1268 1
a1268 1
	VJOIN1( hit_pt, is->pt, dist[0], is->dir );	/* 3d */
d1274 5
d1291 1
a1291 1
		if( dist[1] >= 1 )  {
d1308 1
a1308 1
	if ( dist[0] >= 1 )  {
d1311 6
a1316 1
			rt_log("\tvu=x%x second point of eu1 is intersect point\n", vu1b);
d1324 1
a1324 1
				rt_log("\tfirst point of eu2 matches second point of eu1\n");
d1329 1
a1329 1
		if( dist[1] >= 1 )  {
d1331 1
a1331 1
				rt_log("\tsecond point of eu2 matches second point of eu1\n");
d1338 1
a1338 1
			rt_log("\tbreaking eu2 on second point of eu1\n");
d1346 51
d1406 1
a1406 1
			rt_log("\t\tintersect point is first pt of eu2\n");
d1413 1
a1413 1
	} else if( dist[1] >= 1 )  {
d1415 1
a1415 1
			rt_log("\t\tintersect point is second pt of eu2\n");
a1431 1
/*???*/		if( eu2->eumate_p->vu_p->v_p != new_v ) rt_bomb("new_v 2\n");
@


10.24
log
@Added bounds checking on is->vert2d[], for safety.
Added vert2p_face2p call to vert3_face3 case.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.23 93/02/10 03:03:09 mike Exp Locker: mike $ (BRL)";
d34 1
a34 1
 *			R T _ T W O _ P T S _ E Q U A L
d41 1
a41 1
rt_two_pts_equal( a, b, tol )
d56 1
a56 1
 *			R T _ I S E C T _ 2 D L S E G  _ 2 D L S E G 
d82 1
a82 1
rt_isect_2dlseg_2dlseg( dist, p, pdir, q, qdir, tol )
d97 1
a97 1
rt_log("rt_isect_2dlseg_2dlseg() p=(%g,%g,%g), pdir=(%g,%g,%g)\n\t\tq=(%g,%g,%g), qdir=(%g,%g,%g)\n",
d553 1
a553 1
			if( rt_two_pts_equal( pt, vu2->v_p->vg_p->coord, &is->tol ) )  {
d897 7
a903 1
	status = rt_isect_2dlseg_2dlseg(&dist[0], is->pt, is->dir,
d905 3
@


10.23
log
@More work on 2D stuff, still not all resolved.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.22 93/02/09 22:28:25 mike Exp Locker: mike $ (BRL)";
d232 1
d285 1
a328 1
	int		words;
d341 2
a342 2
	words = 3 * ( 2 * m->maxindex );
	is->vert2d = (fastf_t *)rt_malloc( words * sizeof(fastf_t), "vert2d[]");
d362 1
a362 1
	for( i = words-1-2; i >= 0; i -= 3 )  {
d519 1
d616 6
a621 7
	/* XXX shouldn't the edges be intersected?  point-on-line? */
	/* XXX nmg_isect_vert2p_face2p( is, vu, fu ); */
	if (nmg_tbl(bs->l1, TBL_INS_UNIQUE, &vu->l.magic) < 0) {
		/* XXX should re-check nmg_find_vertexuse_on_face(),
		 * XXX use new vu if it turned up, else make lone-vert-loop */
		if (rt_g.NMG_debug & DEBUG_POLYSECT)
		    	VPRINT("Making vertexloop", vu->v_p->vg_p->coord);
d623 5
a627 4
		plu = nmg_mlv(&fu->l.magic, vu->v_p, OT_UNSPEC);
		nmg_loop_g(plu->l_p);
	    	(void)nmg_tbl(bs->l2, TBL_INS_UNIQUE,
			&RT_LIST_FIRST_MAGIC(&plu->down_hd) );
d629 11
@


10.22
log
@Now prepping for 2D projections is lazy too.
This version ran Bradley r71 OK, which is a good start.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.21 93/02/09 02:57:16 mike Exp Locker: mike $ (BRL)";
d182 1
d297 6
a302 1
rt_log("%d (%g,%g,%g) becomes (%g,%g) %g\n", v->index, V3ARGS(vg->coord), V3ARGS(pt) );
a356 2
VPRINT("centroid", centroid);
VPRINT("centroid_proj", centroid_proj);
a358 1
mat_print("3d->2d xform matrix", is->proj);
d470 1
d475 1
d477 7
d796 2
a797 1
 *  Actual 2d intersector, called from nmg_isect_2edge_2face via nmg_visit()
d799 36
d836 1
a836 1
nmg_isect_edge2p_edge2p( is, eu1, eu2, fu )
d840 2
a841 1
CONST struct faceuse	*fu;		/* for plane equation */
a846 1
	register fastf_t	*pt2d;
d851 3
d858 8
d867 15
a881 2
	nmg_get_2d_vertex( other_start, eu2->vu_p->v_p, is, fu );
	nmg_get_2d_vertex( other_end, eu2->eumate_p->vu_p->v_p, is, fu );
d901 2
d904 56
a959 1
		rt_bomb("2d overlapping edges\n");
d965 1
a965 1
	/* The ray defined by the edgeuse intersects the other edge.
d972 1
a972 1
		/* First point of ref edge is on other edge, by geometry */
d974 2
a975 2
			rt_log("\tfirst point of ref edge is intersect point\n");
		(void)nmg_tbl(is->l1, TBL_INS_UNIQUE, &eu1->vu_p->l.magic);
d978 1
a978 1
		 * or break other edge on our vert.
d982 3
a984 3
				rt_log("\tfirst point of other edge matches first point of ref edge\n");
			(void)nmg_tbl(is->l2, TBL_INS_UNIQUE, &eu2->vu_p->l.magic);
			nmg_jv(eu1->vu_p->v_p, eu2->vu_p->v_p);
d989 3
a991 3
				rt_log("\tsecond point of other edge matches first point of ref edge\n");
			(void)nmg_tbl(is->l2, TBL_INS_UNIQUE, &eu2->eumate_p->vu_p->l.magic);
			nmg_jv(eu1->vu_p->v_p, eu2->eumate_p->vu_p->v_p);
d994 1
a994 1
		/* Break other edge on our first vertex */
d996 5
a1000 3
			rt_log("\tbreaking other edge on first point of ref edge\n");
		(void)nmg_ebreak( eu1->vu_p->v_p, eu2->e_p );
		(void)nmg_tbl(is->l2, TBL_INS_UNIQUE, &eu2->eumate_p->vu_p->l.magic);
d1005 1
a1005 1
		/* Second point of ref edge is on other edge, by geometry */
d1007 2
a1008 2
			rt_log("\tsecond point of ref edge is intersect point\n");
		(void)nmg_tbl(is->l1, TBL_INS_UNIQUE, &eu1->eumate_p->vu_p->l.magic);
d1011 1
a1011 1
		 * or break other edge on our vert.
d1015 3
a1017 3
				rt_log("\tfirst point of other edge matches second point of ref edge\n");
			(void)nmg_tbl(is->l2, TBL_INS_UNIQUE, &eu2->vu_p->l.magic);
			nmg_jv(eu1->eumate_p->vu_p->v_p, eu2->vu_p->v_p);
d1022 3
a1024 3
				rt_log("\tsecond point of other edge matches second point of ref edge\n");
			(void)nmg_tbl(is->l2, TBL_INS_UNIQUE, &eu2->eumate_p->vu_p->l.magic);
			nmg_jv(eu1->eumate_p->vu_p->v_p, eu2->eumate_p->vu_p->v_p);
d1027 1
a1027 1
		/* Break other edge on our second vertex */
d1029 5
a1033 3
			rt_log("\tbreaking other edge on second point of ref edge\n");
		(void)nmg_ebreak( eu1->eumate_p->vu_p->v_p, eu2->e_p );
		(void)nmg_tbl(is->l2, TBL_INS_UNIQUE, &eu2->eumate_p->vu_p->l.magic);
d1039 1
a1039 1
		rt_log("\tintersect is in middle of ref edge, breaking it\n");
d1042 1
a1042 1
	 * or break other edge on our vert.
d1046 2
a1047 2
			rt_log("\tintersect point is start of other edge\n");
		vu = eu2->vu_p;
d1050 3
a1052 1
		(void)nmg_tbl(is->l1, TBL_INS_UNIQUE, &eu1->eumate_p->vu_p->l.magic);
d1055 2
a1056 2
			rt_log("\tintersect point is end of other edge\n");
		vu = eu2->eumate_p->vu_p;
d1059 3
a1061 1
		(void)nmg_tbl(is->l1, TBL_INS_UNIQUE, &eu1->eumate_p->vu_p->l.magic);
d1066 1
a1066 1
		    	VPRINT("Breaking both edges at intersect point", hit_pt);
d1070 1
d1072 1
a1072 1
		if( eu2->eumate_p->vu_p->v_p != new_v ) rt_bomb("new_v 2\n");
d1075 2
d1078 54
a1131 1
	return;
d1499 2
a1510 1
	point_t		endpt;
a1522 8
	nmg_get_2d_vertex( is->pt, eu->vu_p->v_p, is, fu );
	nmg_get_2d_vertex( endpt, eu->eumate_p->vu_p->v_p, is, fu );
	VSUB2( is->dir, endpt, is->pt );
	if (rt_g.NMG_debug & DEBUG_POLYSECT) {
		VPRINT("isect ray 2d is->pt ", is->pt);
		VPRINT("isect ray 2d is->dir", is->dir);
	}

d1537 1
d1550 1
a1550 1
			nmg_isect_edge2p_edge2p( is, eu, eu2, fu );
d1600 4
a1603 2
	/* r71 is a useful demonstration */
/*	rt_g.NMG_debug |= DEBUG_POLYSECT; */
d1765 1
d1767 1
@


10.21
log
@SUbstantial rearrangement of 2D support.
Not finished yet.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.20 93/02/09 00:38:49 mike Exp Locker: mike $ (BRL)";
d218 1
a218 1
	return 0;			/* hit, normal intersection */
d262 1
a262 1
nmg_get_2d_vertex( v2d, v, is )
d266 1
d274 6
d418 2
a419 2
struct vertex *v;
struct faceuse *fu;
d535 1
a535 1
		if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) == NMG_LOOPUSE_MAGIC )  {
d600 4
a603 1
	/* The point lies on the plane of the face. */
d605 2
a606 1
		/* XXX shouldn't the edges be intersected?  point-on-line? */
d787 1
a787 1
nmg_isect_edge2p_edge2p( is, eu1, eu2 )
d791 1
d807 2
a808 2
	nmg_get_2d_vertex( other_start, eu2->vu_p->v_p, is );
	nmg_get_2d_vertex( other_end, eu2->eumate_p->vu_p->v_p, is );
d1307 1
a1307 1
nmg_isect_edge2p_face2p( is, eu, fu )
d1311 1
d1318 3
d1322 1
a1322 1
	rt_bomb("nmg_isect_edge2p_face2p\n");
d1325 2
a1326 2
	if( nmg_find_vertexuse_on_face( eu->vu_p, fu ) &&
	    nmg_find_vertexuse_on_face( eu->eumate_p->vu_p, fu ) )  return;
d1328 2
a1329 2
	nmg_get_2d_vertex( is->pt, eu->vu_p->v_p, is );
	nmg_get_2d_vertex( endpt, eu->eumate_p->vu_p->v_p, is );
d1345 1
a1345 2
 	   	/* XXX Will this work with both fu's being the same? */
    	    	nmg_pl_2fu( "Isect_faces%d.pl", fno++, fu, fu, 0 );
d1350 1
a1350 1
		if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) == NMG_LOOPUSE_MAGIC )  {
d1362 1
a1362 1
			nmg_isect_edge2p_edge2p( is, eu, eu2 );
d1372 2
a1373 5
#if 0
	/* XXX fu1 fu2 ? */
	nmg_purge_unwanted_intersection_points(&vert_list1, fu2);
	nmg_purge_unwanted_intersection_points(&vert_list2, fu1);
#endif
d1386 2
a1387 4
	/* XXX Make sure we can deal with both fu's being the same! */
	nmg_face_cutjoin(&vert_list1, &vert_list2, fu, fu, is->pt, is->dir, &is->tol);
	/* XXX What to do here? */
	nmg_mesh_faces(fu, fu);
a1411 1
	nmg_isect2d_prep( is, fu1->f_p );
d1417 1
a1417 1
		if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) == NMG_LOOPUSE_MAGIC )  {
d1423 1
a1423 1
			nmg_isect_edge2p_face2p( is, eu, fu2 );
d1429 1
a1429 1
		if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) == NMG_LOOPUSE_MAGIC )  {
d1435 1
a1435 1
			nmg_isect_edge2p_face2p( is, eu, fu1 );
a1517 1
 *  XXX What about wire loops and wire edges ?
a1574 1
#if 0
a1575 1
#endif
d1671 1
a1671 1
		/* Check f1 from s1 against lone verts of s2 */
@


10.20
log
@Moved nmg_mesh_faces() debug messages into nmg_mesh.c
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.19 93/02/09 00:13:37 mike Exp Locker: mike $ (BRL)";
d33 14
d48 6
d100 1
d356 1
d358 44
d442 9
a450 1
 *			N M G _ I S E C T _ 2 V E R T E X _ 2 F A C E
d452 48
d501 4
a504 4
nmg_isect_2vertex_2face(bs, vu, fu)
struct nmg_inter_struct *bs;
struct vertexuse *vu;
struct faceuse *fu;
d506 3
a508 4
	struct loopuse *plu;
	struct vertexuse *vup;
	pointp_t pt;
	fastf_t dist;
d511 4
a514 1
		rt_log("nmg_isect_2vertex_2face(, vu=x%x, fu=x%x)\n", vu, fu);
d517 1
a517 5
	if (vup=nmg_find_vertexuse_on_face(vu->v_p, fu)) {
		(void)nmg_tbl(bs->l1, TBL_INS_UNIQUE, &vu->l.magic);
		(void)nmg_tbl(bs->l2, TBL_INS_UNIQUE, &vup->l.magic);
		return;
	}
a520 6
#if 0
	/* Use nmg_visit to visit all the edges of the other face */
	/* Perhaps the 2d formulation would be better? */
	status = rt_isect_pt_lseg( &dist, eu->vu_p->v_p->vg_p->coord,
		eu->eumate_p->vu_p->v_p->vg_p->coord,
		pt, &bs->tol );
d522 4
d527 17
a543 1
	dist = NMG_DIST_PT_PLANE(pt, fu->f_p->fg_p->N);
d545 3
a547 1
	if ( !NEAR_ZERO(dist, bs->tol.dist) )  return;
d549 2
a550 13
	/* The point lies on the plane of the face. */
	if (nmg_tbl(bs->l1, TBL_INS_UNIQUE, &vu->l.magic) < 0) {
		if (rt_g.NMG_debug & DEBUG_POLYSECT)
		    	VPRINT("Making vertexloop", vu->v_p->vg_p->coord);

		plu = nmg_mlv(&fu->l.magic, vu->v_p, OT_UNSPEC);
		nmg_loop_g(plu->l_p);
	    	(void)nmg_tbl(bs->l2, TBL_INS_UNIQUE,
			&RT_LIST_FIRST_MAGIC(&plu->down_hd) );
	}
#else
	rt_log("2vertex_2face, skipping\n");
#endif
d570 4
d676 2
d776 4
a779 4
nmg_isect_2edge_2edge( magicp, statep, flag )
long		*magicp;
genptr_t	statep;
int		flag;
a780 2
	struct edgeuse	*eu = (struct edgeuse *)magicp;
	struct ee_2d_state	*state = (struct ee_2d_state *)statep;
d791 3
a793 1
	NMG_CK_EDGEUSE(eu);
d795 2
a796 2
	nmg_get_2d_vertex( other_start, eu->vu_p->v_p, state->is );
	nmg_get_2d_vertex( other_end, eu->eumate_p->vu_p->v_p, state->is );
d799 2
a800 1
	status = rt_isect_2dlseg_2dlseg(&dist[0], state->start, state->dir, other_start, other_dir, &state->is->tol );
d827 1
a827 1
	VJOIN1( hit_pt, state->start, dist[0], state->dir );	/* 3d */
d833 1
a833 1
		(void)nmg_tbl(state->is->l1, TBL_INS_UNIQUE, &state->eu->vu_p->l.magic);
d841 2
a842 2
			(void)nmg_tbl(state->is->l2, TBL_INS_UNIQUE, &eu->vu_p->l.magic);
			nmg_jv(state->eu->vu_p->v_p, eu->vu_p->v_p);
d848 2
a849 2
			(void)nmg_tbl(state->is->l2, TBL_INS_UNIQUE, &eu->eumate_p->vu_p->l.magic);
			nmg_jv(state->eu->vu_p->v_p, eu->eumate_p->vu_p->v_p);
d855 2
a856 2
		(void)nmg_ebreak( state->eu->vu_p->v_p, eu->e_p );
		(void)nmg_tbl(state->is->l2, TBL_INS_UNIQUE, &eu->eumate_p->vu_p->l.magic);
d864 1
a864 1
		(void)nmg_tbl(state->is->l1, TBL_INS_UNIQUE, &state->eu->eumate_p->vu_p->l.magic);
d872 2
a873 2
			(void)nmg_tbl(state->is->l2, TBL_INS_UNIQUE, &eu->vu_p->l.magic);
			nmg_jv(state->eu->eumate_p->vu_p->v_p, eu->vu_p->v_p);
d879 2
a880 2
			(void)nmg_tbl(state->is->l2, TBL_INS_UNIQUE, &eu->eumate_p->vu_p->l.magic);
			nmg_jv(state->eu->eumate_p->vu_p->v_p, eu->eumate_p->vu_p->v_p);
d886 2
a887 2
		(void)nmg_ebreak( state->eu->eumate_p->vu_p->v_p, eu->e_p );
		(void)nmg_tbl(state->is->l2, TBL_INS_UNIQUE, &eu->eumate_p->vu_p->l.magic);
d901 4
a904 4
		vu = eu->vu_p;
		(void)nmg_tbl(state->is->l2, TBL_INS_UNIQUE, &vu->l.magic);
		nmg_ebreak( vu->v_p, state->eu->e_p );
		(void)nmg_tbl(state->is->l1, TBL_INS_UNIQUE, &state->eu->eumate_p->vu_p->l.magic);
d908 4
a911 4
		vu = eu->eumate_p->vu_p;
		(void)nmg_tbl(state->is->l2, TBL_INS_UNIQUE, &vu->l.magic);
		nmg_ebreak( vu->v_p, state->eu->e_p );
		(void)nmg_tbl(state->is->l1, TBL_INS_UNIQUE, &state->eu->eumate_p->vu_p->l.magic);
d917 1
a917 1
		new_v = nmg_e2break( state->eu->e_p, eu->e_p );
d920 4
a923 4
		if( state->eu->eumate_p->vu_p->v_p != new_v ) rt_bomb("new_v 1\n");
		if( eu->eumate_p->vu_p->v_p != new_v ) rt_bomb("new_v 2\n");
		(void)nmg_tbl(state->is->l1, TBL_INS_UNIQUE, &state->eu->eumate_p->vu_p->l.magic);
		(void)nmg_tbl(state->is->l2, TBL_INS_UNIQUE, &eu->eumate_p->vu_p->l.magic);
a928 122
 *			N M G _ I S E C T _ 2 E D G E _ 2 F A C E
 *
 *  Intersect a given edgeuse "eu" with all the edges of a different
 *  but (coplanar) face.  "eu" defines a line of intersection along which
 *  all the vertices will lie.
 *  The caller of this routine should immediately process them
 *  through the state machine to take the appropriate loop-level actions
 *  (cut, join, jaunt, etc).
 */
static void
nmg_isect_2edge_2face(is, eu, fu)
struct nmg_inter_struct *is;
struct edgeuse *eu;
struct faceuse *fu;
{
	struct ee_2d_state state;
	struct vertexuse *vu_other;
	struct vertex	*v1;
	struct vertex	*v1mate;
	point_t		hit_pt;
	fastf_t		edge_len;	/* MAGNITUDE(state.dir) */
	fastf_t		dist;		/* parametric dist to hit point */
	fastf_t		dist_to_plane;	/* distance to hit point, in mm */
	int		status;
	struct loopuse	*plu;
	fastf_t		dist2;
	struct edgeuse	*euforw;
	struct edgeuse	*eunext;
	struct edgeuse	*eulast;
	struct nmg_visit_handlers	handlers;

	if (rt_g.NMG_debug & DEBUG_POLYSECT)
		rt_log("nmg_isect_2edge_2face(, eu=x%x, fu=x%x)\n", eu, fu);

	NMG_CK_EDGEUSE(eu);
	NMG_CK_VERTEXUSE(eu->vu_p);
	v1 = eu->vu_p->v_p;
	NMG_CK_VERTEX(v1);
	NMG_CK_VERTEX_G(v1->vg_p);

	NMG_CK_EDGEUSE(eu->eumate_p);
	NMG_CK_VERTEXUSE(eu->eumate_p->vu_p);
	v1mate = eu->eumate_p->vu_p->v_p;
	NMG_CK_VERTEX(v1mate);
	NMG_CK_VERTEX_G(v1mate->vg_p);

	if (*eu->up.magic_p == NMG_LOOPUSE_MAGIC) {
		/* some edge sanity checking */
		eunext = RT_LIST_PNEXT_CIRC(edgeuse, &eu->l);
		eulast = RT_LIST_PLAST_CIRC(edgeuse, &eu->l);
		NMG_CK_EDGEUSE(eunext);
		NMG_CK_EDGEUSE(eulast);
		if (v1 != eulast->eumate_p->vu_p->v_p) {
			VPRINT("unshared vertex (mine): ",
				v1->vg_p->coord);
			VPRINT("\t\t (last->eumate_p): ",
				eulast->eumate_p->vu_p->v_p->vg_p->coord);
			rt_bomb("nmg_isect_2edge_2face() discontiuous edgeloop\n");
		}
		if( eunext->vu_p->v_p != v1mate) {
			VPRINT("unshared vertex (my mate): ",
				v1mate->vg_p->coord);
			VPRINT("\t\t (next): ",
				eunext->vu_p->v_p->vg_p->coord);
			rt_bomb("nmg_isect_2edge_2face() discontinuous edgeloop\n");
		}
	}

	/*
	 * First check the topology.  If the topology says that starting
	 * vertex of this edgeuse is on the other (coplanar) face, enter the
	 * two vertexuses of it in the list and return.
	 */
	if (vu_other=nmg_find_vertexuse_on_face(v1, fu)) {
		if (rt_g.NMG_debug & DEBUG_POLYSECT) {
			register pointp_t p1 = v1->vg_p->coord;
			register pointp_t p2 = v1mate->vg_p->coord;
			rt_log("Edgeuse %g, %g, %g -> %g, %g, %g\n",
				V3ARGS(p1), V3ARGS(p2) );
			rt_log("\tvertex topologically on isect plane.\n\tAdding vu1=x%x (v=x%x), vu_other=x%x (v=x%x)\n",
				eu->vu_p, eu->vu_p->v_p,
				vu_other, vu_other->v_p);
		}

		(void)nmg_tbl(is->l1, TBL_INS_UNIQUE, &eu->vu_p->l.magic);
		(void)nmg_tbl(is->l2, TBL_INS_UNIQUE, &vu_other->l.magic);
		return;
	}

	/*
	 *  Starting vertex does not lie on the face according to topology.
	 *  For each edge in the other face, intersect it with this edge,
	 *  which will now be considered as a ray.
	 *  Form a ray that starts at one vertex of the edgeuse
	 *  and points to the other vertex.
	 */
	nmg_get_2d_vertex( state.start, v1, is );
	nmg_get_2d_vertex( state.end, v1mate, is );
	VSUB2(state.dir, state.end, state.start);
	edge_len = MAGNITUDE(state.dir);

#if 0
	if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
#else
	{
#endif
		rt_log("Testing2d (%g, %g, %g) -> (%g, %g, %g) dir=(%g, %g, %g)\n",
			V3ARGS(state.start),
			V3ARGS(v1mate->vg_p->coord),
			V3ARGS(state.dir) );
	}

	/* Consider each edgeuse of the other faceuse, in turn */
	handlers = nmg_null_handlers;	/* struct copy */
	handlers.bef_edgeuse = nmg_isect_2edge_2edge;
	state.is = is;
	state.eu = eu;
	/* state already has start,end,dir */
	nmg_visit( fu, &handlers, (genptr_t)&state );
}

/*
d961 1
a1173 1
 *	Handles both 3D and 2D cases.
d1189 1
d1202 1
a1202 4
	     	if( bs->coplanar )
			nmg_isect_2vertex_2face(bs, vu, fu);
		else
			nmg_isect_3vertex_3face(bs, vu, fu);
d1226 1
a1226 4
	     	if( bs->coplanar )
			nmg_isect_2edge_2face(bs, eu, fu);
	     	else
			nmg_isect_3edge_3face(bs, eu, fu);
d1233 1
a1233 1
 *			N M G _ I S E C T _ T W O _ P L A N A R _ F A C E S
d1235 2
a1236 1
 *	Intersect loops of face 1 with the entirety of face 2
d1239 1
a1239 1
nmg_isect_two_planar_faces(bs, fu1, fu2)
d1248 1
a1248 1
		rt_log("nmg_isect_two_planar_faces(, fu1=x%x, fu2=x%x) START ++++++++++\n", fu1, fu2);
d1250 1
d1258 1
a1258 1
			rt_bomb("nmg_isect_two_planar_faces() Child loop doesn't share parent!\n");
d1283 1
a1283 1
		rt_log("nmg_isect_two_planar_faces(, fu1=x%x, fu2=x%x) RETURN ++++++++++\n\n", fu1, fu2);
d1287 6
a1292 1
 *			N M G _ P R _ V E R T _ L I S T
d1295 4
a1298 3
nmg_pr_vert_list( str, tbl )
char		*str;
struct nmg_ptbl	*tbl;
d1300 96
a1395 2
	int			i;
	struct vertexuse	**vup;
a1396 2
	struct vertex		*v;
	struct vertex_g		*vg;
d1398 3
a1400 1
    	rt_log("nmg_pr_vert_list(%s):\n", str);
d1402 10
a1411 22
	vup = (struct vertexuse **)tbl->buffer;
	for (i=0 ; i < tbl->end ; ++i) {
		vu = vup[i];
		NMG_CK_VERTEXUSE(vu);
		v = vu->v_p;
		NMG_CK_VERTEX(v);
		vg = v->vg_p;
		NMG_CK_VERTEX_G(vg);
		rt_log("%d\t%g, %g, %g\t", i, V3ARGS(vg->coord) );
		if (*vu->up.magic_p == NMG_EDGEUSE_MAGIC) {
			rt_log("EDGEUSE\n");
		} else if (*vu->up.magic_p == NMG_LOOPUSE_MAGIC) {
			rt_log("LOOPUSE\n");
			if ((struct vertexuse *)vu->up.lu_p->down_hd.forw != vu) {
				rt_log("ERROR vertexuse's parent disowns us!\n");
				if (((struct vertexuse *)(vu->up.lu_p->lumate_p->down_hd.forw))->l.magic == NMG_VERTEXUSE_MAGIC)
					rt_bomb("lumate has vertexuse\n");
				else
					rt_bomb("lumate has garbage\n");
			}
		} else {
			rt_log("UNKNOWN\n");
d1413 3
d1417 12
d1432 74
a1515 1
	struct nmg_ptbl vert_list1, vert_list2;
d1526 1
d1556 1
d1561 1
a1566 1
		nmg_isect2d_prep( &bs, f1, f2 );
d1568 2
a1569 7
		rt_log("Skipping, for now.\n");
		/* Use this for real, for now. */
		return;	/* XXX break */
#else
		/* Use this for debugging, until things work. */
		/* r71 is a useful demonstration */
/*		rt_g.NMG_debug |= DEBUG_POLYSECT; */
a1570 1
#endif
d1573 1
a1573 1
		return;
d1577 1
a1577 1
		return;
a1579 55
	if (rt_g.NMG_debug & DEBUG_POLYSECT) {
		VPRINT("isect ray bs.pt ", bs.pt);
		VPRINT("isect ray bs.dir", bs.dir);
	}

	(void)nmg_tbl(&vert_list1, TBL_INIT,(long *)NULL);
	(void)nmg_tbl(&vert_list2, TBL_INIT,(long *)NULL);

    	bs.l1 = &vert_list1;
    	bs.l2 = &vert_list2;
    	bs.tol = *tol;		/* struct copy */

    	if (rt_g.NMG_debug & (DEBUG_POLYSECT|DEBUG_FCUT|DEBUG_MESH)
    	    && rt_g.NMG_debug & DEBUG_PLOTEM) {
    		static int fno=1;
    	    	nmg_pl_2fu( "Isect_faces%d.pl", fno++, fu1, fu2, 0 );
    	}

	nmg_isect_two_planar_faces(&bs, fu1, fu2);

    	if (rt_g.NMG_debug & DEBUG_FCUT) {
	    	rt_log("nmg_isect_two_generic_faces(fu1=x%x, fu2=x%x) vert_lists A:\n", fu1, fu2);
    		nmg_pr_vert_list( "vert_list1", &vert_list1 );
    		nmg_pr_vert_list( "vert_list2", &vert_list2 );
    	}

    	bs.l2 = &vert_list1;
    	bs.l1 = &vert_list2;
	nmg_isect_two_planar_faces(&bs, fu2, fu1);

	nmg_purge_unwanted_intersection_points(&vert_list1, fu2);
	nmg_purge_unwanted_intersection_points(&vert_list2, fu1);

    	if (rt_g.NMG_debug & DEBUG_FCUT) {
	    	rt_log("nmg_isect_two_generic_faces(fu1=x%x, fu2=x%x) vert_lists B:\n", fu1, fu2);
    		nmg_pr_vert_list( "vert_list1", &vert_list1 );
    		nmg_pr_vert_list( "vert_list2", &vert_list2 );
    	}

    	if (vert_list1.end == 0) {
    		/* there were no intersections */
    		goto out;
    	}

	nmg_face_cutjoin(&vert_list1, &vert_list2, fu1, fu2, bs.pt, bs.dir, tol);
	nmg_mesh_faces(fu1, fu2);

#if 0
	show_broken_stuff((long *)fu1, (long **)NULL, 1, 0);
	show_broken_stuff((long *)fu2, (long **)NULL, 1, 0);
#endif

out:
	(void)nmg_tbl(&vert_list1, TBL_FREE, (long *)NULL);
	(void)nmg_tbl(&vert_list2, TBL_FREE, (long *)NULL);
d1603 1
@


10.19
log
@Changed to "lazy evaluation" of 3D->2D projection.
This is important for being able to handle new 3D points which
are created as the intersection process proceeds.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.18 93/02/06 04:26:24 mike Exp Locker: mike $ (BRL)";
d1382 1
a1383 1
#if 0
a1433 1

a1445 12

	/* When two faces are intersected
	 * with each other, they should
	 * share the same edge(s) of
	 * intersection. 
	 */
    	if (rt_g.NMG_debug & DEBUG_MESH &&
    	    rt_g.NMG_debug & DEBUG_PLOTEM) {
    		static int fnum=1;
    	    	nmg_pl_2fu( "Before_mesh%d.pl", fnum++, fu1, fu2, 1 );
    	}

a1447 6
    	if (rt_g.NMG_debug & DEBUG_MESH &&
    	    rt_g.NMG_debug & DEBUG_PLOTEM) {
    		static int fno=1;
    	    	nmg_pl_2fu( "After_mesh%d.pl", fno++, fu1, fu2, 1 );
    	}

a1526 6
	    		/* See if face f1 overlaps face 2 */
			if( ! NMG_EXTENT_OVERLAP(
			    fu2->f_p->fg_p->min_pt, fu2->f_p->fg_p->max_pt,
			    f1->fg_p->min_pt, f1->fg_p->max_pt) )
				continue;

d1537 5
d1544 13
@


10.18
log
@Additional work on 2D intersection.  Still unfinished.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.17 93/01/25 12:32:00 mike Exp Locker: mike $ (BRL)";
d174 1
d196 1
d226 1
d228 7
a234 1
 *  Visit all the vertices, and compute their 2d projection.
d236 3
a238 3
 * XXX Replace with common subroutine used to obtain 2d from 3d.
 * XXX That will give lazy evaluation, and protection for new
 * XXX vertices that geometric intersection adds to the fray.
d240 5
a244 5
void
nmg_isect2d_vis_vertex( magicp, state, flag )
long		*magicp;
genptr_t	state;
int		flag;
a245 4
	struct vertex	*v = (struct vertex *)magicp;
	struct nmg_inter_struct	*is = (struct nmg_inter_struct *)state;
	fastf_t		*opt;
	point_t		pt;
d247 2
d252 3
a254 2

	if( !v->vg_p )  rt_bomb("nmg_isect2d_vis_vertex:  vertex with no geometry!\n");
d257 4
a260 1
		/* Flag set.  Been here before */
d264 5
a268 6
	opt = v->vg_p->coord;
	MAT4X3PNT( pt, is->proj, opt );
	pt2d[0] = pt[0];
	pt2d[1] = pt[1];
	pt2d[2] = 0;		/* flag */
rt_log("%d (%g,%g,%g) becomes (%g,%g) %g\n", v->index, V3ARGS(opt), V3ARGS(pt) );
d287 1
a287 1
nmg_isect2d_prep( is, f1, f2 )
a289 1
struct face		*f2;
a297 1
	struct nmg_visit_handlers	handlers;
a300 1
	NMG_CK_FACE(f2);
a332 8

	/* Project all the vertices in both faces */
	handlers = nmg_null_handlers;	/* struct copy */
	handlers.vis_vertex = nmg_isect2d_vis_vertex;
rt_log("projecting face1:\n");
	nmg_visit( f1->fu_p, &handlers, (genptr_t)is );
rt_log("projecting face2:\n");
	nmg_visit( f2->fu_p, &handlers, (genptr_t)is );
d664 2
a665 4
	pt2d = &state->is->vert2d[eu->vu_p->v_p->index*3];
	VMOVE( other_start, pt2d );
	pt2d = &state->is->vert2d[eu->eumate_p->vu_p->v_p->index*3];
	VMOVE( other_end, pt2d );
d799 6
a804 1
 *  Intersect 2D line segments with each other.
d893 5
d899 1
a899 2
	VMOVE( state.start, v1->vg_p->coord );
	VMOVE( state.end, v1mate->vg_p->coord );
a901 6
		register fastf_t	*pt2d;
		pt2d = &is->vert2d[v1->index*3];
		VMOVE( state.start, pt2d );
		pt2d = &is->vert2d[v1mate->index*3];
		VMOVE( state.end, pt2d );
	}
a902 4
	VSUB2(state.dir, state.end, state.start);
	edge_len = MAGNITUDE(state.dir);

	if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
d1383 1
a1383 1
#if 1
@


10.17
log
@Beginnings of code to handle co-planar faces.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.16 93/01/22 22:36:05 mike Exp Locker: mike $ (BRL)";
d31 167
d213 1
a213 1
static struct nmg_visit_handlers nmg_isect2d_handlers;	/* null fill, to start */
d215 8
d224 6
d289 1
d328 2
a329 1
	nmg_isect2d_handlers.vis_vertex = nmg_isect2d_vis_vertex;
d331 1
a331 1
	nmg_visit( f1->fu_p, &nmg_isect2d_handlers, (genptr_t)is );
d333 1
a333 1
	nmg_visit( f2->fu_p, &nmg_isect2d_handlers, (genptr_t)is );
d337 1
a337 1
 *			N M G _ F I N D _ 3 V E R T E X _ O N _ 3 F A C E
d345 1
a345 1
nmg_find_3vertex_on_3face(v, fu)
d376 3
d385 42
a426 1
	rt_bomb("2vertex_2face\n");
d450 1
a450 1
	if (vup=nmg_find_3vertex_on_3face(vu->v_p, fu)) {
d465 1
d467 1
d571 1
d607 1
a607 3
		 * list of vertices on the instersect line
		 *
		 * XXX Is this really a good idea?
d642 162
d805 2
a806 2
nmg_isect_2edge_2face(bs, eu, fu)
struct nmg_inter_struct *bs;
d810 110
a919 1
	rt_bomb("XXX YYY ZZZ\n");
d925 1
a925 1
 *	Intersect an edge with a face
d994 1
a994 1
	if (vu_other=nmg_find_3vertex_on_3face(v1, fu)) {
d1034 2
a1035 2
		rt_log("\tMiss. Boring status of rt_isect_ray_plane: %d dist: %g\n",
				status, dist);
a1160 2


a1176 1
	struct loopuse	*fulu;
d1219 1
a1219 1
			rt_bomb("edge does not share loop\n");
a1228 1

d1251 1
a1251 1
	/* process each loop in face 1 */
d1273 4
a1276 4
			if (NMG_EXTENT_OVERLAP( fu2lg->min_pt, fu2lg->max_pt,
			    lg->min_pt, lg->max_pt)) {
				nmg_isect_plane_loop_face(bs, lu, fu2);
			}
d1329 1
d1387 2
d1390 6
@


10.16
log
@Changed names to reflect 3D nature, in preparation for
addition of 2D family of routines.
@
text
@d12 1
a12 2
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
d16 1
a16 1
 *	This software is Copyright (C) 1990 by the United States Army.
d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.15 92/10/20 17:42:10 mike Exp Locker: mike $ (BRL)";
d33 1
d40 2
a41 1
	fastf_t		*vu2d;		/* Array of 2d vu projections */
d43 2
d46 2
d49 105
d193 9
d414 9
d667 1
a667 1
 *			N M G _ I S E C T _ 3 L O O P _ 3 F A C E
d670 1
d673 1
a673 1
nmg_isect_3loop_3face(bs, lu, fu)
d683 1
a683 1
		rt_log("nmg_isect_3loop_3face(, lu=x%x, fu=x%x)\n", lu, fu);
d695 1
d699 4
a702 2
		nmg_isect_3vertex_3face(bs,
			RT_LIST_FIRST(vertexuse,&lu->down_hd), fu);
d705 1
a705 1
		rt_bomb("nmg_isect_3loop_3face() Unknown type of NMG loopuse\n");
d726 6
a731 2
		nmg_isect_3edge_3face(bs, eu, fu);
		nmg_ck_lueu(lu, "nmg_isect_3loop_3face");
d737 1
a737 1
 *			N M G _ I S E C T _ T W O _ 3 F A C E S
d742 1
a742 1
nmg_isect_two_3faces(bs, fu1, fu2)
d751 1
a751 1
		rt_log("nmg_isect_two_3faces(, fu1=x%x, fu2=x%x) START ++++++++++\n", fu1, fu2);
d760 1
a760 1
			rt_bomb("nmg_isect_two_3faces() Child loop doesn't share parent!\n");
d780 1
a780 2
				nmg_isect_3loop_3face(bs, lu, fu2);
				break;
d785 1
a785 1
		rt_log("nmg_isect_two_3faces(, fu1=x%x, fu2=x%x) RETURN ++++++++++\n\n", fu1, fu2);
d849 3
d887 1
a887 1
		rt_log("co-planar faces.  Skipping, for now.\n");
d889 3
a891 1
		return;
d919 1
a919 1
	nmg_isect_two_3faces(&bs, fu1, fu2);
d929 1
a929 1
	nmg_isect_two_3faces(&bs, fu2, fu1);
d943 1
a943 3
		(void)nmg_tbl(&vert_list1, TBL_FREE, (long *)NULL);
		(void)nmg_tbl(&vert_list2, TBL_FREE, (long *)NULL);
    		return;
a966 4

	(void)nmg_tbl(&vert_list1, TBL_FREE, (long *)NULL);
	(void)nmg_tbl(&vert_list2, TBL_FREE, (long *)NULL);

d971 5
@


10.15
log
@When creating an OT_UNSPEC loop, need to also give it geometry.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.14 92/10/20 16:59:16 mike Exp Locker: mike $ (BRL)";
d40 1
d43 2
a44 1
/*	F I N D _ V E R T E X _ O N _ F A C E
d52 1
a52 1
find_vertex_on_face(v, fu)
d83 2
a84 1
/*	I S E C T _ V E R T E X _ F A C E
d89 2
a90 1
static void isect_vertex_face(bs, vu, fu)
d101 1
a101 1
		rt_log("isect_vertex_face(, vu=x%x, fu=x%x)\n", vu, fu);
d104 1
a104 1
	if (vup=find_vertex_on_face(vu->v_p, fu)) {
d181 2
a182 1
/*	B R E A K _ E D G E _ A T _ P L A N E
d188 1
a188 1
break_edge_at_plane(hit_pt, fu, bs, eu, v1, v1mate)
d228 2
a229 1
		euforw = mega_check_ebreak_result(eu);
d295 2
a296 1
/*	I S E C T _ E D G E _ F A C E
d303 2
a304 1
static void isect_edge_face(bs, eu, fu)
d326 1
a326 1
		rt_log("isect_edge_face(, eu=x%x, fu=x%x)\n", eu, fu);
d351 1
a351 1
			rt_bomb("isect_edge_face() discontiuous edgeloop\n");
d358 1
a358 1
			rt_bomb("isect_edge_face() discontinuous edgeloop\n");
d367 1
a367 1
	if (vu_other=find_vertex_on_face(v1, fu)) {
d491 1
a491 1
		break_edge_at_plane(hit_pt, fu, bs, eu, v1, v1mate);
d503 1
a503 1
			rt_bomb("isect_edge_face: discontinuous eu loop\n");
d537 3
a539 1
/*	I S E C T _ L O O P _ F A C E
d543 2
a544 1
static void isect_loop_face(bs, lu, fu)
d554 1
a554 1
		rt_log("isect_loop_face(, lu=x%x, fu=x%x)\n", lu, fu);
d569 1
a569 1
		isect_vertex_face(bs,
d573 1
a573 1
		rt_bomb("isect_loop_face() Unknown type of NMG loopuse\n");
d580 1
a580 1
	 * by isect_edge_face.  This is because the edgeuses
d594 2
a595 2
		isect_edge_face(bs, eu, fu);
		nmg_ck_lueu(lu, "isect_loop_face");
d601 1
a601 1
 *			N M G _ I S E C T _ 2 F A C E _ L O O P S
d605 2
a606 1
static void nmg_isect_2face_loops(bs, fu1, fu2)
d615 1
a615 1
		rt_log("nmg_isect_2face_loops(, fu1=x%x, fu2=x%x) START ++++++++++\n", fu1, fu2);
d624 1
a624 1
			rt_bomb("nmg_isect_2face_loops() Child loop doesn't share parent!\n");
d644 1
a644 1
				isect_loop_face(bs, lu, fu2);
d650 1
a650 1
		rt_log("nmg_isect_2face_loops(, fu1=x%x, fu2=x%x) RETURN ++++++++++\n\n", fu1, fu2);
d696 1
a696 1
 *			N M G _ I S E C T _ 2 F A C E S
d700 2
a701 1
static void nmg_isect_2faces(fu1, fu2, tol)
d725 1
a725 1
		rt_log("\nnmg_isect_2faces(fu1=x%x, fu2=x%x)\n", fu1, fu2);
d757 1
a757 1
		rt_log("ERROR nmg_isect_2faces() unable to find plane intersection\n");
d779 1
a779 1
	nmg_isect_2face_loops(&bs, fu1, fu2);
d782 1
a782 1
	    	rt_log("nmg_isect_2faces(fu1=x%x, fu2=x%x) vert_lists A:\n", fu1, fu2);
d789 1
a789 1
	nmg_isect_2face_loops(&bs, fu2, fu1);
d796 1
a796 1
	    	rt_log("nmg_isect_2faces(fu1=x%x, fu2=x%x) vert_lists B:\n", fu1, fu2);
d913 1
a913 1
			nmg_isect_2faces(fu1, fu2, tol);
@


10.14
log
@Slightly neater pointer checking.
Not that it helped find this bug.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.13 92/10/06 23:12:13 mike Exp Locker: mike $ (BRL)";
d516 1
a626 8

			/* If this loop is just some drek deposited as part of
			 * the intersection operation, or it defines a hole
			 * in the face, it doesn't really count.
			 */
			if (fu2lu->orientation != OT_SAME)
			    	continue;

@


10.13
log
@DEBUG_COMBINE -> DEBUG_FCUT
VSUB2DOT moved to vmath.h
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.12 92/07/23 05:05:16 butler Exp Locker: mike $ (BRL)";
d599 1
d613 3
d622 2
a625 1
			NMG_CK_LOOP_G(fu2lu->l_p->lg_p);
d629 1
a629 1
			 * int the face, it doesn't really count.
d634 5
a638 3
			if (NMG_EXTENT_OVERLAP(
			   fu2lu->l_p->lg_p->min_pt, fu2lu->l_p->lg_p->max_pt,
			    lu->l_p->lg_p->min_pt,   lu->l_p->lg_p->max_pt)) {
@


10.12
log
@changed loop bounding box check to apply to only OT_SAME loops
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.11 92/07/22 03:57:33 butler Exp Locker: butler $ (BRL)";
d413 1
a413 7

#define VSUBDOT(_pt2, _pt, _dir)	( \
	((_pt2)[X] - (_pt)[X]) * (_dir)[X] + \
	((_pt2)[Y] - (_pt)[Y]) * (_dir)[Y] + \
	((_pt2)[Z] - (_pt)[Z]) * (_dir)[Z] )

		dist = VSUBDOT( v1->vg_p->coord, start_pt, edge_vect )
d760 1
a760 1
    	if (rt_g.NMG_debug & (DEBUG_POLYSECT|DEBUG_COMBINE|DEBUG_MESH)
d768 1
a768 1
    	if (rt_g.NMG_debug & DEBUG_COMBINE) {
d782 1
a782 1
    	if (rt_g.NMG_debug & DEBUG_COMBINE) {
@


10.11
log
@broke up isect_edge_face() a bit to make it more readable.
Changed so that vertexuses of loops which don't overlap intersection face
are purged from the list of vertexuses on the line of intersection.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.10 92/07/21 21:04:00 butler Exp Locker: butler $ (BRL)";
d629 2
a630 2
			 * the intersection operation, it doesn't really
			 * count
d632 1
a632 2
			if (fu2lu->orientation != OT_SAME &&
			    fu2lu->orientation != OT_OPPOSITE)
@


10.10
log
@moved check of loop bounding boxes from isect_loop_face() to
nmg_isect_2face_loops()
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.9 92/07/20 23:09:33 butler Exp Locker: butler $ (BRL)";
d126 163
d311 1
a311 1
	fastf_t		dist1, dist2;
d313 1
d361 2
a362 3
			register pointp_t	p1, p2;
			p1 = v1->vg_p->coord;
			p2 = v1mate->vg_p->coord;
d383 1
a384 53

#define USE_EDGE_GEOMETRY	0
#if USE_EDGE_GEOMETRY
	if( eu->e_p->eg_p )
#else
	if(0)
#endif
	{
		/* Use ray in edge geometry, for repeatability */
		register struct edge_g	*eg = eu->e_p->eg_p;
		fastf_t		dot;
		NMG_CK_EDGE_G(eg);
		if( MAGSQ( eg->e_dir ) < SQRT_SMALL_FASTF )  {
			rt_log("zero length edge_g\n");
			nmg_pr_eg(eg, "");
			goto calc;
		}
		if( (dot=VDOT( edge_vect, eg->e_dir )) < 0 )  {
			VREVERSE( edge_vect, eg->e_dir );
			if( dot > -0.95 )  {
				rt_log("edge/ray dot=%g!\n", dot);
				goto calc;
			}
		} else {
			VMOVE( edge_vect, eg->e_dir );
			if( dot < 0.95 )  {
				rt_log("edge/ray dot=%g!\n", dot);
				goto calc;
			}
		}
		VMOVE( start_pt, eg->e_pt );

#define VSUBDOT(_pt2, _pt, _dir)	( \
	((_pt2)[X] - (_pt)[X]) * (_dir)[X] + \
	((_pt2)[Y] - (_pt)[Y]) * (_dir)[Y] + \
	((_pt2)[Z] - (_pt)[Z]) * (_dir)[Z] )

		dist1 = VSUBDOT( v1->vg_p->coord, start_pt, edge_vect ) / edge_len;
		dist2 = VSUBDOT( v1mate->vg_p->coord, start_pt, edge_vect ) / edge_len;

rt_log("A dist1=%g, dist2=%g\n", dist1, dist2);

	} else {
calc:
		VMOVE( start_pt, v1->vg_p->coord );
		dist1 = 0;
		dist2 = edge_len;

#if USE_EDGE_GEOMETRY
rt_log("B dist1=%g, dist2=%g\n", dist1, dist2);
#endif
	}

d395 2
a396 2
		if (status >= 0)
			rt_log("\tHit. Status of rt_isect_ray_plane: %d dist: %g\n",
d398 2
a399 2
		else
			rt_log("\tMiss. Boring status of rt_isect_ray_plane: %d dist: %g\n",
d409 1
d413 8
a420 1
		dist = VSUBDOT( v1->vg_p->coord, start_pt, edge_vect ) / edge_len;
d440 1
a440 1
	if ( dist_to_plane < dist1-(bs->tol.dist) )  {
a447 13
	/* If the hit point is outside the bounding box of the other face,
	 * this edge can't really be intersecting the face.
	 */
	if ( !(NMG_EXTENT_OVERLAP(hit_pt, hit_pt,
	   fu->f_p->fg_p->min_pt, fu->f_p->fg_p->max_pt)) ) {
		if (rt_g.NMG_debug & DEBUG_POLYSECT) {
			VPRINT("\thit_pt is outside of face bounding box\n",
				hit_pt);
		}
		return;
	}


d454 1
a454 1
	if ( dist_to_plane < dist1+(bs->tol.dist) )  {
a483 2
	if ( dist_to_plane < dist2 - bs->tol.dist) {
		struct edgeuse	*euforw;
d485 1
d489 1
a489 121
		if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
			rt_log("Splitting %g, %g, %g <-> %g, %g, %g\n",
				V3ARGS(v1->vg_p->coord), V3ARGS(v1mate->vg_p->coord) );
			VPRINT("\tPoint of intersection", hit_pt);
		}

		/* if we can't find the appropriate vertex in the
		 * other face, we'll build a new vertex.  Otherwise
		 * we re-use an old one.
		 */
		vu_other = nmg_find_vu_in_face(hit_pt, fu, &(bs->tol));
		if (vu_other) {
			/* the other face has a convenient vertex for us */

			if (rt_g.NMG_debug & DEBUG_POLYSECT)
				rt_log("re-using vertex from other face\n");

			(void)nmg_ebreak(vu_other->v_p, eu->e_p);
			(void)nmg_tbl(bs->l2, TBL_INS_UNIQUE, &vu_other->l.magic);
		} else {
			if (rt_g.NMG_debug & DEBUG_POLYSECT)
				rt_log("Making new vertex\n");

			(void)nmg_ebreak((struct vertex *)NULL, eu->e_p);

			/* given the trouble that nmg_ebreak (nmg_esplit)
			 * went to create, we're going to check this to the
			 * limit.
			 */
			NMG_CK_EDGEUSE(eu);
			NMG_CK_EDGEUSE(eu->eumate_p);

			/* since we just split eu, the "next" edgeuse
			 * from eu CAN'T (in a working [as opposed to broken]
			 * system) be the list head.
			 */
			euforw = RT_LIST_PNEXT(edgeuse, eu);

			NMG_CK_EDGEUSE(euforw);
			NMG_CK_EDGEUSE(euforw->eumate_p);

			NMG_CK_VERTEXUSE(eu->vu_p);
			NMG_CK_VERTEXUSE(eu->eumate_p->vu_p);
			NMG_CK_VERTEXUSE(euforw->vu_p);
			NMG_CK_VERTEXUSE(euforw->eumate_p->vu_p);

			NMG_CK_VERTEX(eu->vu_p->v_p);
			NMG_CK_VERTEX(eu->eumate_p->vu_p->v_p);
			NMG_CK_VERTEX(euforw->vu_p->v_p);
			NMG_CK_VERTEX(euforw->eumate_p->vu_p->v_p);

			nmg_ck_lueu(eu->up.lu_p, "isect_edge_face" );

			/* check to make sure we know the right place to
			 * stick the geometry
			 */
			if (eu->eumate_p->vu_p->v_p->vg_p != 
			    (struct vertex_g *)NULL) {
				VPRINT("where'd this geometry come from?",
					eu->eumate_p->vu_p->v_p->vg_p->coord);
			}
			nmg_vertex_gv(eu->eumate_p->vu_p->v_p, hit_pt);

			NMG_CK_VERTEX_G(eu->vu_p->v_p->vg_p);
			NMG_CK_VERTEX_G(eu->eumate_p->vu_p->v_p->vg_p);
			NMG_CK_VERTEX_G(euforw->vu_p->v_p->vg_p);
			NMG_CK_VERTEX_G(euforw->eumate_p->vu_p->v_p->vg_p);
						
			if (euforw->vu_p->v_p != eu->eumate_p->vu_p->v_p)
				rt_bomb("I was supposed to share verticies!\n");

			if (rt_g.NMG_debug & DEBUG_POLYSECT) {
				register pointp_t	p1, p2;
				p1 = eu->vu_p->v_p->vg_p->coord;
				p2 = eu->eumate_p->vu_p->v_p->vg_p->coord;
				rt_log("Just split %g, %g, %g -> %g, %g, %g\n",
					V3ARGS(p1), V3ARGS(p2) );
				p1 = euforw->vu_p->v_p->vg_p->coord;
				p2 = euforw->eumate_p->vu_p->v_p->vg_p->coord;
				rt_log("\t\t\t%g, %g, %g -> %g, %g, %g\n",
					V3ARGS(p1), V3ARGS(p2) );
			}
			/* stick this vertex in the other shell
			 * and make sure it is in the other shell's
			 * list of vertices on the instersect line
			 *
			 * XXX Is this really a good idea?
			 */
			plu = nmg_mlv(&fu->l.magic,
				eu->eumate_p->vu_p->v_p, OT_SAME);
			vu_other = RT_LIST_FIRST( vertexuse, &plu->down_hd );
			NMG_CK_VERTEXUSE(vu_other);
			nmg_loop_g(plu->l_p);

			if (rt_g.NMG_debug & DEBUG_POLYSECT) {
			    	VPRINT("Making vertexloop",
					vu_other->v_p->vg_p->coord);
				if (RT_LIST_FIRST_MAGIC(&plu->down_hd) !=
					NMG_VERTEXUSE_MAGIC)
					rt_bomb("bad plu\n");
				if (RT_LIST_FIRST_MAGIC(&plu->lumate_p->down_hd) !=
					NMG_VERTEXUSE_MAGIC)
					rt_bomb("bad plumate\n");

			}
			(void)nmg_tbl(bs->l2, TBL_INS_UNIQUE, &vu_other->l.magic);
		}

		euforw = RT_LIST_PNEXT_CIRC(edgeuse, eu);
		if (rt_g.NMG_debug & DEBUG_POLYSECT) {
			register pointp_t	p1, p2;
			p1 = eu->vu_p->v_p->vg_p->coord;
			p2 = eu->eumate_p->vu_p->v_p->vg_p->coord;
			rt_log("\tNow %g, %g, %g <-> %g, %g, %g\n",
				V3ARGS(p1), V3ARGS(p2) );
			p1 = euforw->vu_p->v_p->vg_p->coord;
			p2 = euforw->eumate_p->vu_p->v_p->vg_p->coord;
			rt_log("\tand %g, %g, %g <-> %g, %g, %g\n\n",
				V3ARGS(p1), V3ARGS(p2) );
		}
		(void)nmg_tbl(bs->l1, TBL_INS_UNIQUE, &euforw->vu_p->l.magic);
d492 2
a493 2
	if ( dist_to_plane < dist2 + bs->tol.dist) {
		struct edgeuse	*eunext;
a557 1
	/* loop overlaps intersection face? */
d628 8
d785 4
d802 1
a802 2
	nmg_face_combine(&vert_list1, fu1, fu2, bs.pt, bs.dir);
	nmg_face_combine(&vert_list2, fu2, fu1, bs.pt, bs.dir);
@


10.9
log
@added check to see if loop bounding box overlaps a loop bounding box
in the face/plane of intersection before intersecting loop with face/plane.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.8 92/03/12 08:32:32 mike Exp Locker: butler $ (BRL)";
d42 1
a42 1
/*	V E R T E X _ O N _ F A C E
d49 2
a50 1
static struct vertexuse *vertex_on_face(v, fu)
d100 1
a100 1
	if (vup=vertex_on_face(vu->v_p, fu)) {
d150 2
a168 2
		struct edgeuse	*eunext;
		struct edgeuse	*eulast;
d195 1
a195 1
	if (vu_other=vertex_on_face(v1, fu)) {
d219 3
d252 1
d257 1
d260 1
d262 1
d268 1
d328 14
a400 1
/*			(void)nmg_esplit(vu_other->v_p, eu->e_p); */
a406 1
/*			(void)nmg_esplit((struct vertex *)NULL, eu->e_p); */
d469 2
a560 1
	int		no_overlaps;
d581 4
a584 11
	} else if (magic1 == NMG_EDGEUSE_MAGIC) {
		/*
		 * If the bounding box of a loop doesn't intersect the
		 * bounding box of a loop in the other face, it doesn't need
		 * to get cut.
		 */
		no_overlaps = 1;
		for (RT_LIST_FOR(fulu, loopuse, &fu->lu_hd )){
			NMG_CK_LOOPUSE(fulu);
			NMG_CK_LOOP(fulu->l_p);
			NMG_CK_LOOP_G(fulu->l_p->lg_p);
d586 16
a601 6
			if (NMG_EXTENT_OVERLAP(
			    fulu->l_p->lg_p->min_pt,fulu->l_p->lg_p->max_pt,
			    lu->l_p->lg_p->min_pt,lu->l_p->lg_p->max_pt)) {
				no_overlaps = 0;
				break;
			}
a602 2
		if (no_overlaps)
			return;
d604 3
a606 14
		/*
		 *  Process a loop consisting of a list of edgeuses.
		 *
		 * By going backwards around the list we avoid
		 * re-processing an edgeuse that was just created
		 * by isect_edge_face.  This is because the edgeuses
		 * point in the "next" direction, and when one of
		 * them is split, it inserts a new edge AHEAD or
		 * "nextward" of the current edgeuse.
		 */ 
		for( eu = RT_LIST_LAST(edgeuse, &lu->down_hd );
		     RT_LIST_NOT_HEAD(eu,&lu->down_hd);
		     eu = RT_LIST_PLAST(edgeuse,eu) )  {
			NMG_CK_EDGEUSE(eu);
a607 10
			if (eu->up.magic_p != &lu->l.magic) {
				rt_bomb("edge does not share loop\n");
			}

			isect_edge_face(bs, eu, fu);
			nmg_ck_lueu(lu, "isect_loop_face");
		 }
	} else {
		rt_bomb("isect_loop_face() Unknown type of NMG loopuse\n");
	}
d620 1
a620 1
	struct loopuse	*lu;
d634 17
a650 1
		isect_loop_face(bs, lu, fu2);
@


10.8
log
@Fixed problem with "edge ends at plane intersect" case in nmg_inter.c
Wrong vertexuse was being placed on intersect list.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.7 92/03/06 12:02:41 mike Exp Locker: mike $ (BRL)";
d119 1
d348 1
d453 1
d537 2
d546 3
d561 21
d813 5
@


10.7
log
@Removed incorrect code about "MATE vertex topologically on isect plane".
Added code to check for start point of edge being exactly ON the
isect plane, when edge dir vector lies in the face of the other plane;
a case where rt_isect_ray_plane() returns "miss" because of the
infinite number of hits (a line's worth).
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.6 92/03/06 07:54:35 mike Exp Locker: mike $ (BRL)";
d72 2
a73 2
				lu = vu->up.lu_p;
				CKLU_FOR_FU(lu, fu, vu);
d482 1
d487 3
a489 1
		if( RT_LIST_PNEXT_CIRC(edgeuse,eu)->vu_p->v_p != v1mate )
d492 1
a492 4
#if 0
		/* Adding these guys causes bool.g Test7.r to die */
		(void)nmg_tbl(bs->l1, TBL_INS_UNIQUE, &eu->vu_p->l.magic);
#endif
a497 1
#if 0
a498 1
#endif
a512 1
#if 0
a513 1
#endif
d814 1
a814 1
	/* XXX this isn't true for non-manifold geometry! */
@


10.6
log
@Improved debugging prints
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.5 92/03/05 05:58:28 mike Exp Locker: mike $ (BRL)";
d189 1
a189 1
	 * First check the topology.  If the topology says that either
d191 1
a191 1
	 * vertexuses in the list and return.
d200 3
a202 1
			rt_log("\tvertex topologically on intersection plane\n");
a208 16
	if (vu_other=vertex_on_face(v1mate, fu)) {
		if (rt_g.NMG_debug & DEBUG_POLYSECT) {
			register pointp_t	p1, p2;
			p1 = v1->vg_p->coord;
			p2 = v1mate->vg_p->coord;
			rt_log("Edgeuse %g, %g, %g -> %g, %g, %g\n",
				V3ARGS(p1), V3ARGS(p2) );
			rt_log("\tMATE vertex topologically on intersection plane. skipping edgeuse\n");
		}
#if 0
		/* For some reason, this currently causes trouble */
		(void)nmg_tbl(bs->l1, TBL_INS_UNIQUE, &eu->eumate_p->vu_p->l.magic);
		(void)nmg_tbl(bs->l2, TBL_INS_UNIQUE, &vu_other->l.magic);
#endif
		return;
	}
d211 1
a211 1
	 *  Neither vertex lies on the face according to topology.
d265 4
a268 2
		rt_log("Testing %g, %g, %g -> %g, %g, %g\n",
			V3ARGS(v1->vg_p->coord), V3ARGS(v1mate->vg_p->coord) );
d275 1
a275 1
			rt_log("\tStatus of rt_isect_ray_plane: %d dist: %g\n",
d278 1
a278 1
			rt_log("\tBoring status of rt_isect_ray_plane: %d dist: %g\n",
d281 12
a292 2
	if (status < 0)
		return;		/* No geometric intersection */
d539 1
a539 1
	if (rt_g.NMG_debug & DEBUG_POLYSECT)
d541 2
d718 5
@


10.5
log
@Turned off stray printing.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.4 92/02/29 03:17:51 mike Exp Locker: mike $ (BRL)";
d95 3
d149 3
d542 1
a542 1
		rt_log("isect_loop_faces\n");
d595 3
d603 1
a603 4

		if (rt_g.NMG_debug & DEBUG_POLYSECT)
			rt_log("\nLoop %8x\n", lu);

a606 1

d609 2
d614 42
a670 4
	union {
		struct vertexuse **vu;
		long **magic_p;
	} p;
d684 1
d688 1
a688 1
		rt_log("\nPlanes\t%gx + %gy + %gz = %g\n\t%gx + %gy + %gz = %g\n",
d708 1
a708 1
		rt_log("co-planar faces?\n");
d736 3
a738 21
	    	p.magic_p = vert_list1.buffer;
	    	rt_log("vert_list1\n");
		for (i=0 ; i < vert_list1.end ; ++i) {
			rt_log("%d\t%g, %g, %g\t", i,
				p.vu[i]->v_p->vg_p->coord[X],
				p.vu[i]->v_p->vg_p->coord[Y],
				p.vu[i]->v_p->vg_p->coord[Z]);
			if (*p.vu[i]->up.magic_p == NMG_EDGEUSE_MAGIC) {
				rt_log("EDGEUSE\n");
			} else if (*p.vu[i]->up.magic_p == NMG_LOOPUSE_MAGIC){
				rt_log("LOOPUSE\n");
	if ((struct vertexuse *)p.vu[i]->up.lu_p->down_hd.forw != p.vu[i]) {
		rt_log("vertexuse's parent disowns us!\n");
		if (((struct vertexuse *)(p.vu[i]->up.lu_p->lumate_p->down_hd.forw))->l.magic == NMG_VERTEXUSE_MAGIC)
			rt_bomb("lumate has vertexuse\n");
		else
			rt_bomb("lumate has garbage\n");
	}
			} else
				rt_log("UNKNOWN\n");
		}
d745 6
d801 3
@


10.4
log
@First attempts at using edge geometry
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.3 92/02/24 23:53:56 mike Exp Locker: mike $ (BRL)";
d225 2
a226 1
#if 0
d267 1
d269 1
@


10.3
log
@Added edge_g note
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.2 92/02/21 01:35:13 butler Exp Locker: mike $ (BRL)";
d143 2
d178 1
a178 1
			rt_bomb("isect_edge_face() discontiuous edgeloop\n");
a222 1
/* XXX This should use edge geometry, when available. */
d224 44
d274 1
a274 1
	status = rt_isect_ray_plane(&dist, v1->vg_p->coord, edge_vect, fu->f_p->fg_p->N);
d297 1
a297 2
	VJOIN1( hit_pt, v1->vg_p->coord, dist, edge_vect );
	edge_len = MAGNITUDE(edge_vect);
d304 1
a304 1
	if ( dist_to_plane < -(bs->tol.dist) )  {
d317 1
a317 1
	if ( dist_to_plane < bs->tol.dist )  {
d346 1
a346 1
	if ( dist_to_plane < edge_len - bs->tol.dist) {
d474 1
a474 1
	if ( dist_to_plane < edge_len + bs->tol.dist) {
@


10.2
log
@updated to use nmg_ebreak instead of nmg_esplit
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 10.1 91/10/12 06:40:45 mike Rel4_0 Locker: butler $ (BRL)";
d221 1
@


10.1
log
@Release_4.0
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 1.32 91/06/17 20:42:04 butler Exp $ (BRL)";
d324 2
a325 1
			(void)nmg_esplit(vu_other->v_p, eu->e_p);
d331 2
a332 1
			(void)nmg_esplit((struct vertex *)NULL, eu->e_p);
d334 3
a336 2
			/* given the trouble that nmg_esplit was to create,
			 * we're going to check this to the limit
d343 1
a343 1
			 * system) be the list head.  
@


1.32
log
@changed function declarations so that all global functions have their
"nmg_" at the begining of the line.  Static functions have their function
names on the same line as the "static" modifier.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 1.31 91/05/18 03:03:08 mike Exp $ (BRL)";
@


1.31
log
@Converted to new tolerance interface
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 1.30 91/03/28 01:02:50 mike Exp $ (BRL)";
d706 2
a707 1
void nmg_crackshells(s1, s2, tol)
@


1.30
log
@Moved tbl_vsort to nmg_comb.c,
changed calling sequence to nmg_face_combine.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 1.29 91/03/21 20:19:09 mike Exp $ (BRL)";
d36 1
a36 1
	fastf_t		tol;
d109 1
a109 1
	if ( !NEAR_ZERO(dist, bs->tol) )  return;
d259 1
a259 1
	if ( dist_to_plane < -(bs->tol) )  {
d272 1
a272 1
	if ( dist_to_plane < bs->tol )  {
d278 1
a278 1
		vu_other = nmg_find_vu_in_face(v1->vg_p->coord, fu, bs->tol);
d301 1
a301 1
	if ( dist_to_plane < edge_len - bs->tol) {
d317 1
a317 1
		vu_other = nmg_find_vu_in_face(hit_pt, fu, bs->tol);
d426 1
a426 1
	if ( dist_to_plane < edge_len + bs->tol) {
d439 1
a439 1
		vu_other = nmg_find_vu_in_face(v1mate->vg_p->coord, fu, bs->tol);
d561 2
a562 2
struct faceuse *fu1, *fu2;
fastf_t tol;
d602 2
a603 1
	status = rt_isect_2planes( bs.pt, bs.dir, f1->fg_p->N, f2->fg_p->N, min_pt );
d628 1
a628 1
    	bs.tol = tol/50.0;
d707 3
a709 2
struct shell *s1, *s2;
fastf_t tol;
@


1.29
log
@When intersections are found on the far end of an edge, that intersection
is stored, but not added to the lists, because doing so seems to
cause grief further downstream, for now.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 1.28 91/03/21 19:53:11 mike Exp $ (BRL)";
a41 72


/*
 *	T B L _ V S O R T
 *	sort list of vertices in fu1 on plane of fu2 
 *
 *	W A R N I N G:
 *		This function makes gross assumptions about the contents
 *	and structure of an nmg_ptbl list!  If I could figure a way of folding
 *	this into the nmg_tbl routine, I would do it.
 */
static void tbl_vsort(b, fu1, fu2, pt)
struct nmg_ptbl *b;		/* table of vertexuses on intercept line */
struct faceuse	*fu1, *fu2;
point_t		pt;
{
	point_t		min_pt;
	vect_t		vect;
	union {
		struct vertexuse **vu;
		long **magic_p;
	} p;
	struct vertexuse *tvu;
	fastf_t *mag, tmag;
	int i, j;

	mag = (fastf_t *)rt_calloc(b->end, sizeof(fastf_t),
					"vector magnitudes for sort");

	p.magic_p = b->buffer;
	/* check vertexuses and compute distance from start of line */
	for(i = 0 ; i < b->end ; ++i) {
		NMG_CK_VERTEXUSE(p.vu[i]);

		VSUB2(vect, pt, p.vu[i]->v_p->vg_p->coord);
		mag[i] = MAGNITUDE(vect);
	}

	/* a trashy bubble-head sort, because I hope this list is never
	 * very long.
	 */
	for(i=0 ; i < b->end - 1 ; ++i) {
		for (j=i+1; j < b->end ; ++j) {
			if (mag[i] > mag[j]) {
				tvu = p.vu[i];
				p.vu[i] = p.vu[j];
				p.vu[j] = tvu;

				tmag = mag[i];
				mag[i] = mag[j];
				mag[j] = tmag;
			}
		}
	}
	/*
	 * We should do something here to "properly"
	 * order vertexuses which share a vertex
	 * or whose coordinates are equal.
	 *
	 * Just what should be done & how is not
	 * clear to me at this hour of the night.
	 * for (i=0 ; i < b->end - 1 ; ++i) {
	 *	if (p.vu[i]->v_p == p.vu[i+1]->v_p ||
	 *	    VAPPROXEQUAL(p.vu[i]->v_p->vg_p->coord,
	 *	    p.vu[i+1]->v_p->vg_p->coord, VDIVIDE_TOL) ) {
	 *	}
	 * }
	 */
	rt_free((char *)mag, "vector magnitudes");
}


d672 2
a673 5
	tbl_vsort(&vert_list1, fu1, fu2, bs.pt);
	nmg_face_combine(&vert_list1, fu1, fu2);

	tbl_vsort(&vert_list2, fu2, fu1, bs.pt);
	nmg_face_combine(&vert_list2, fu2, fu1);
@


1.28
log
@Improved comments.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 1.26 91/03/21 14:28:25 mike Exp $ (BRL)";
d281 1
d367 3
a369 2
			(void)nmg_tbl(bs->l2, TBL_INS_UNIQUE,
				&RT_LIST_FIRST_MAGIC(&plu->down_hd) );
d466 2
d471 1
a471 2
				RT_LIST_PNEXT(vertexuse,&plu->down_hd)->
					v_p->vg_p->coord);
d480 1
a480 2
			(void)nmg_tbl(bs->l2, TBL_INS_UNIQUE,
				&RT_LIST_FIRST_MAGIC(&plu->down_hd) );
d507 1
a523 1
#if 0
d530 4
a533 2
			(void)nmg_tbl(bs->l2, TBL_INS_UNIQUE,
				&RT_LIST_FIRST_MAGIC(&plu->down_hd) );
@


1.27
log
@Minor neatening of code.
@
text
@d236 1
a236 1
		if (eu->vu_p->v_p != eulast->eumate_p->vu_p->v_p) {
d238 1
a238 1
				eu->vu_p->v_p->vg_p->coord);
d243 1
a243 1
		if( eunext->vu_p->v_p != eu->eumate_p->vu_p->v_p) {
d245 1
a245 1
				eu->eumate_p->vu_p->v_p->vg_p->coord);
d260 2
a261 6
			p1 = eu->vu_p->v_p->vg_p->coord;
			NMG_CK_EDGEUSE(eu->eumate_p);
			NMG_CK_VERTEXUSE(eu->eumate_p->vu_p);
			NMG_CK_VERTEX(eu->eumate_p->vu_p->v_p);
			NMG_CK_VERTEX_G(eu->eumate_p->vu_p->v_p->vg_p);
			p2 = eu->eumate_p->vu_p->v_p->vg_p->coord;
d270 2
a271 3
	} else if (vu_other=vertex_on_face(eu->eumate_p->vu_p->v_p, fu)) {
		register pointp_t	p1, p2;

d273 3
a275 6
			p1 = eu->vu_p->v_p->vg_p->coord;
			NMG_CK_EDGEUSE(eu->eumate_p);
			NMG_CK_VERTEXUSE(eu->eumate_p->vu_p);
			NMG_CK_VERTEX(eu->eumate_p->vu_p->v_p);
			NMG_CK_VERTEX_G(eu->eumate_p->vu_p->v_p->vg_p);
			p2 = eu->eumate_p->vu_p->v_p->vg_p->coord;
d280 4
d337 6
a346 2

		/* Add to list of verts on intersection line */
a348 1
		/* If face doesn't have a "very similar" point, give it one */
d352 1
a352 4
			/* Face has a vertex very similar to this one.
			 * Add vertex to face's list of vertices on
			 * intersection line.
			 */
d354 1
a354 4

			/* new coordinates are the midpoint between
			 * the two existing coordinates
			 */
d360 1
a360 3
			/* Since the other face doesn't have a vertex quite
			 * like this one, we make a copy of this one.
			 */
a365 2

			/* Add vertex to other face's list */
a497 3
		/* Make no entries in intersection lists,
		 * because it will be handled on the next call.
		 */
d501 1
a501 2
		if( RT_LIST_PNEXT_CIRC(edgeuse,eu)->vu_p->v_p !=
		    v1mate )
d504 4
a507 1
		/* If face has a "very similar" point, connect up with it */
d511 5
a515 3
			/* new coordinates are the midpoint between
			 * the two existing coordinates
			 */
d520 11
@


1.26
log
@Changed from TBL_INS to TBL_INS_UNIQUE throughout.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 1.25 91/03/21 14:22:37 mike Exp $ (BRL)";
d196 3
d218 3
a220 2
	NMG_CK_VERTEX(eu->vu_p->v_p);
	NMG_CK_VERTEX_G(eu->vu_p->v_p->vg_p);
d222 6
d252 4
a255 12
	/* We check to see if the edge crosses the plane of face fu.
	 * First we check the topology.  If the topology says that the start
	 * vertex of this edgeuse is on the other face, we enter the
	 * vertexuses in the list and it's all over.
	 *
	 * If the vertex on the other end of this edgeuse is on the face,
	 * then make a linkage to an existing face vertex (if found),
	 * and give up on this edge, knowing that we'll pick up the
	 * intersection of the next edgeuse with the face later.
	 *
	 * This all assumes that an edge can only intersect a face at one
	 * point.  This is probably a bad assumption for the future
d257 1
a257 2
	if (vu_other=vertex_on_face(eu->vu_p->v_p, fu)) {
		register pointp_t	p1, p2;
d259 1
a295 2
	v1 = eu->vu_p->v_p;
	v1mate = eu->eumate_p->vu_p->v_p;
a312 4

	/* if this edge doesn't intersect the other face by geometry,
	 * we're done.
	 */
d314 1
a314 1
		return;
@


1.25
log
@Simple change of variables, for clarity
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 1.24 91/03/02 01:41:40 mike Exp $ (BRL)";
d181 3
a183 2
	if (NEAR_ZERO(dist, bs->tol) &&
	    nmg_tbl(bs->l1, TBL_INS_UNIQUE, &vu->l.magic) < 0) {
d188 1
a188 2
	    	/* XXX should this be TBL_INS_UNIQUE? */
	    	(void)nmg_tbl(bs->l2, TBL_INS,
d372 1
a372 3
			 * like this one, we make a copy of this one and make.
			 * sure it's in the other face's list of intersect
			 * verticies.
a373 1

d380 2
a381 5
			/* make sure this vertex is in other face's list of
			 * points to deal with
			 */
			/* Should this be TBL_INS_UNIQUE? */
			(void)nmg_tbl(bs->l2, TBL_INS,
d492 1
a492 2
			/* XXX Should this be TBL_INS_UNIQUE ? */
			(void)nmg_tbl(bs->l2, TBL_INS,
d508 1
a508 3

		/* XXX Should this be TBL_INS_UNIQUE ? */
		(void)nmg_tbl(bs->l1, TBL_INS, &euforw->vu_p->l.magic);
@


1.24
log
@Changed nmg_crackshells to use flag array, rather than ptbl list.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 1.23 91/03/01 23:52:17 mike Exp $ (BRL)";
d202 3
a204 1
	struct vertexuse *vu;
a207 1
	pointp_t	p1, p2;
d255 2
a256 2
	if (vu=vertex_on_face(eu->vu_p->v_p, fu)) {

d265 1
a265 1
				p1[0], p1[1], p1[2], p2[0], p2[1], p2[2]);
d270 1
a270 1
		(void)nmg_tbl(bs->l2, TBL_INS_UNIQUE, &vu->l.magic);
d272 2
a273 1
	} else if (vu=vertex_on_face(eu->eumate_p->vu_p->v_p, fu)) {
d283 1
a283 1
				p1[0], p1[1], p1[2], p2[0], p2[1], p2[2]);
d294 3
a296 3
	p1 = eu->vu_p->v_p->vg_p->coord;
	p2 = eu->eumate_p->vu_p->v_p->vg_p->coord;
	VSUB2(edge_vect, p2, p1);
d298 1
a298 1
	if (rt_g.NMG_debug & DEBUG_POLYSECT)
d300 2
a301 1
			p1[X], p1[Y], p1[Z], p2[X], p2[Y], p2[Z]);
d303 1
a304 2
	status = rt_isect_ray_plane(&dist, p1, edge_vect, fu->f_p->fg_p->N);

d330 1
a330 1
	VJOIN1( hit_pt, p1, dist, edge_vect );
d354 2
a355 2
		vu = nmg_find_vu_in_face(p1, fu, bs->tol);
		if (vu) {
d361 1
a361 1
			(void)nmg_tbl(bs->l2, TBL_INS_UNIQUE, &vu->l.magic);
d366 2
a367 2
			p3 = vu->v_p->vg_p->coord;
			VADD2SCALE(p1, p1, p3, 0.5);
d369 1
a369 1
			nmg_jv(eu->vu_p->v_p, vu->v_p);
d379 1
a379 1
			    		eu->vu_p->v_p->vg_p->coord);
d381 1
a381 1
			plu = nmg_mlv(&fu->l.magic, eu->vu_p->v_p, OT_UNSPEC);
d400 1
a400 1
			p1[X], p1[Y], p1[Z], p2[X], p2[Y], p2[Z]);
d408 2
a409 2
		vu = nmg_find_vu_in_face(hit_pt, fu, bs->tol);
		if (vu) {
d415 2
a416 2
			(void)nmg_esplit(vu->v_p, eu->e_p);
			(void)nmg_tbl(bs->l2, TBL_INS_UNIQUE, &vu->l.magic);
d469 1
d498 1
d505 1
d509 1
a509 1
				p1[X], p1[Y], p1[Z], p2[X], p2[Y], p2[Z]);
d513 1
a513 1
				p1[X], p1[Y], p1[Z], p2[X], p2[Y], p2[Z]);
d516 1
d529 1
a529 1
		    eu->eumate_p->vu_p->v_p )
d533 2
a534 2
		vu = nmg_find_vu_in_face(p2, fu, bs->tol);
		if (vu) {
d539 2
a540 2
			p3 = vu->v_p->vg_p->coord;
			VADD2SCALE(p2, p2, p3, 0.5);
d542 1
a542 1
			nmg_jv(eu->eumate_p->vu_p->v_p, vu->v_p);
@


1.23
log
@Removed stray declaration
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 1.22 91/02/07 20:32:37 mike Exp $ (BRL)";
d786 4
a789 2
	struct faceuse *fu1, *fu2;
	struct nmg_ptbl faces;
a790 2
	NMG_CK_SHELL(s2);
	NMG_CK_SHELL_A(s2->sa_p);
d792 2
a793 1
	NMG_CK_SHELL_A(s1->sa_p);
d795 4
d806 3
a808 2
	if ( ! NMG_EXTENT_OVERLAP(s1->sa_p->min_pt, s1->sa_p->max_pt,
	    s2->sa_p->min_pt, s2->sa_p->max_pt) )
d811 2
a812 1
	(void)nmg_tbl(&faces, TBL_INIT, (long *)NULL);
d814 4
a817 1
	/* shells overlap */
a818 3
		/* check each of the faces in shell 1 to see
		 * if they overlap the extent of shell 2
		 */
d820 2
a821 2
		NMG_CK_FACE(fu1->f_p);
		NMG_CK_FACE_G(fu1->f_p->fg_p);
d823 2
a824 4
		if (nmg_tbl(&faces, TBL_LOC, &fu1->f_p->magic) < 0 &&
		    NMG_EXTENT_OVERLAP(s2->sa_p->min_pt,
		    s2->sa_p->max_pt, fu1->f_p->fg_p->min_pt,
		    fu1->f_p->fg_p->max_pt) ) {
d826 4
a829 8
			/* poly1 overlaps shell2 */
		    	for( RT_LIST_FOR( fu2, faceuse, &s2->fu_hd ) )  {
		    		NMG_CK_FACEUSE(fu2);
		    		NMG_CK_FACE(fu2->f_p);
				/* now check the face of shell 1
				 * against each of the faces of shell 2
	 			 */
				nmg_isect_2faces(fu1, fu2, tol);
d831 7
a837 10
				/* try not to process redundant faceuses (mates) */
				if( RT_LIST_NOT_HEAD( fu2, &s2->fu_hd ) )  {
					register struct faceuse	*nextfu;
					nextfu = RT_LIST_PNEXT(faceuse, fu2 );
					if( nextfu->f_p == fu2->f_p )
						fu2 = nextfu;
				}
		    	}
			(void)nmg_tbl(&faces, TBL_INS, &fu1->f_p->magic);
		}
d839 17
a855 7
		/* try not to process redundant faceuses (mates) */
		if( RT_LIST_NOT_HEAD( fu1, &s1->fu_hd ) )  {
			register struct faceuse	*nextfu;
			nextfu = RT_LIST_PNEXT(faceuse, fu1 );
			if( nextfu->f_p == fu1->f_p )
				fu1 = nextfu;
		}
d857 1
a857 2

	(void)nmg_tbl(&faces, TBL_FREE, (long *)NULL );
@


1.22
log
@Changed from NMG_LIST macros to RT_LIST macros, from rtlist.h
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 1.21 90/12/10 20:41:43 mike Exp $ (BRL)";
a649 1
	extern void nmg_face_combine();
@


1.21
log
@"Warning:  unknown escape sequence '\e'", fixed
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 1.20 90/07/31 01:15:37 mike Exp $ (BRL)";
d135 1
a135 1
	for( NMG_LIST( vu, vertexuse, &v->vu_hd ) )  {
d189 1
a189 1
			&NMG_LIST_FIRST_MAGIC(&plu->down_hd) );
d221 2
a222 2
		eunext = NMG_LIST_PNEXT_CIRC(edgeuse, &eu->l);
		eulast = NMG_LIST_PLAST_CIRC(edgeuse, &eu->l);
d386 1
a386 1
				&NMG_LIST_FIRST_MAGIC(&plu->down_hd) );
d431 1
a431 1
			euforw = NMG_LIST_PNEXT(edgeuse, eu);
d485 1
a485 1
				NMG_LIST_PNEXT(vertexuse,&plu->down_hd)->
d487 1
a487 1
				if (NMG_LIST_FIRST_MAGIC(&plu->down_hd) !=
d490 1
a490 1
				if (NMG_LIST_FIRST_MAGIC(&plu->lumate_p->down_hd) !=
d496 1
a496 1
				&NMG_LIST_FIRST_MAGIC(&plu->down_hd) );
d499 1
a499 1
		euforw = NMG_LIST_PNEXT_CIRC(edgeuse, eu);
d522 1
a522 1
		if( NMG_LIST_PNEXT_CIRC(edgeuse,eu)->vu_p->v_p !=
d565 1
a565 1
	magic1 = NMG_LIST_FIRST_MAGIC( &lu->down_hd );
d571 1
a571 1
			NMG_LIST_FIRST(vertexuse,&lu->down_hd), fu);
d583 3
a585 3
		for( eu = NMG_LIST_LAST(edgeuse, &lu->down_hd );
		     NMG_LIST_MORE(eu,edgeuse,&lu->down_hd);
		     eu = NMG_LIST_PLAST(edgeuse,eu) )  {
d616 1
a616 1
	for( NMG_LIST( lu, loopuse, &fu1->lu_hd ) )  {
d796 2
a797 2
	if( NMG_LIST_IS_EMPTY( &s1->fu_hd ) ||
	    NMG_LIST_IS_EMPTY( &s2->fu_hd ) )  {
d809 1
a809 1
	for( NMG_LIST( fu1, faceuse, &s1->fu_hd ) )  {
d823 1
a823 1
		    	for( NMG_LIST( fu2, faceuse, &s2->fu_hd ) )  {
d832 1
a832 1
				if( NMG_LIST_MORE( fu2, faceuse, &s2->fu_hd ) )  {
d834 1
a834 1
					nextfu = NMG_LIST_PNEXT(faceuse, fu2 );
d843 1
a843 1
		if( NMG_LIST_MORE( fu1, faceuse, &s1->fu_hd ) )  {
d845 1
a845 1
			nextfu = NMG_LIST_PNEXT(faceuse, fu1 );
@


1.20
log
@Changed nmg_boolstruct to nmg_inter_struct,
to avoid conflicts with new nmg.h
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 1.19 90/05/24 20:06:14 mike Exp $ (BRL)";
d333 1
a333 1
		rt_log("\edge_len=%g, dist=%g, dist_to_plane=%g\n",
@


1.19
log
@converted to TBL_INS_UNIQUE
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 1.18 90/05/24 03:56:38 mike Exp $ (BRL)";
d32 2
a33 1
struct nmg_boolstruct {
d158 1
a158 1
struct nmg_boolstruct *bs;
d198 1
a198 1
struct nmg_boolstruct *bs;
d551 1
a551 1
struct nmg_boolstruct *bs;
d606 1
a606 1
struct nmg_boolstruct *bs;
d639 1
a639 1
	struct nmg_boolstruct	bs;
@


1.18
log
@Moved nmg_pl_2fu to nmg_plot.c
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 1.17 90/05/24 02:09:43 mike Exp $ (BRL)";
d168 2
a169 5
		if (nmg_tbl(bs->l1, TBL_LOC, &vu->l.magic) < 0)
			(void)nmg_tbl(bs->l1, TBL_INS, &vu->l.magic);
		if (nmg_tbl(bs->l2, TBL_LOC, &vup->l.magic) < 0)
			(void)nmg_tbl(bs->l2, TBL_INS, &vup->l.magic);

d181 1
a181 4
	    nmg_tbl(bs->l1, TBL_LOC, &vu->l.magic) < 0) {

		(void)nmg_tbl(bs->l1, TBL_INS, &vu->l.magic);

d186 1
d267 2
a268 4
		if (nmg_tbl(bs->l1, TBL_LOC, &eu->vu_p->l.magic) < 0)
			(void)nmg_tbl(bs->l1, TBL_INS, &eu->vu_p->l.magic);
		if (nmg_tbl(bs->l2, TBL_LOC, &vu->l.magic) < 0)
			(void)nmg_tbl(bs->l2, TBL_INS, &vu->l.magic);
d348 1
a348 2
		if (nmg_tbl(bs->l1, TBL_LOC, &eu->vu_p->l.magic) < 0)
			(void)nmg_tbl(bs->l1, TBL_INS, &eu->vu_p->l.magic);
d358 1
a358 2
			if (nmg_tbl(bs->l2, TBL_LOC, &vu->l.magic) < 0)
				(void)nmg_tbl(bs->l2, TBL_INS, &vu->l.magic);
d383 1
d413 1
a413 2
			if (nmg_tbl(bs->l2, TBL_LOC, &vu->l.magic) < 0)
				(void)nmg_tbl(bs->l2, TBL_INS, &vu->l.magic);
@


1.17
log
@Added missing function arg.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 1.16 90/05/23 22:42:51 butler Exp $ (BRL)";
a634 36
}

/*
 *			N M G _ P L _ 2 F U
 *
 *  Note that 'str' is expected to contain a %d to place the frame number.
 */
void
nmg_pl_2fu( str, num, fu1, fu2, show_mates )
char		*str;
int		num;
struct faceuse	*fu1;
struct faceuse	*fu2;
int		show_mates;
{
	FILE		*fp;
	char		name[32];
	struct nmg_ptbl	b;

	(void)nmg_tbl(&b, TBL_INIT, (long *)NULL);

	(void)sprintf(name, str, num);
	rt_log("plotting to %s\n", name);
	if ((fp=fopen(name, "w")) == (FILE *)NULL)
		rt_bomb(name);

	(void)nmg_pl_fu(fp, fu1, &b, 100, 100, 180);
	if( show_mates )
		(void)nmg_pl_fu(fp, fu1->fumate_p, &b, 100, 100, 180);

	(void)nmg_pl_fu(fp, fu2, &b, 100, 100, 180);
	if( show_mates )
		(void)nmg_pl_fu(fp, fu2->fumate_p, &b, 100, 100, 180);

	(void)fclose(fp);
	(void)nmg_tbl(&b, TBL_FREE, (long *)NULL);
@


1.16
log
@added some comments
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 1.15 90/05/23 22:06:56 butler Exp $ (BRL)";
d454 1
a454 1
			nmg_ck_lueu(eu->up.lu_p);
@


1.15
log
@Added nmg_simplify routines & call them after boolean evaluation is complete
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 1.14 90/05/21 23:48:26 butler Exp $ (BRL)";
d33 2
a34 2
	struct nmg_ptbl	*l1;
	struct nmg_ptbl *l2;
@


1.14
log
@Minor additional error checking
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 1.13 90/05/18 12:23:50 mike Exp $ (BRL)";
d815 1
@


1.13
log
@about 33/64th of the way converted to new linked lists ;-) LAB
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 1.12 90/05/18 07:26:00 butler Exp $ (BRL)";
d434 7
a440 1
			euforw = NMG_LIST_PNEXT_CIRC(edgeuse, eu);
d454 2
d569 3
d601 1
d790 1
@


1.12
log
@Halfway converted to new double-linked-list structures ;-)
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 1.11 90/05/17 11:36:22 mike Exp $ (BRL)";
d483 1
a483 1
			if (rt_g.NMG_debug & DEBUG_POLYSECT)
d485 1
a485 1
					NMG_LIST_PNEXT(vertexuse,&plu->down_hd)->
d487 6
d494 1
d756 7
@


1.11
log
@Further improved.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 1.10 90/05/15 05:38:28 butler Exp $ (BRL)";
d134 1
a134 2
	vu = v->vu_p;
	do {
d146 1
a147 3
		vu = vu->next;
	} while (vu != v->vu_p);

d168 4
a171 4
		if (nmg_tbl(bs->l1, TBL_LOC, &vu->magic) < 0)
			(void)nmg_tbl(bs->l1, TBL_INS, &vu->magic);
		if (nmg_tbl(bs->l2, TBL_LOC, &vup->magic) < 0)
			(void)nmg_tbl(bs->l2, TBL_INS, &vup->magic);
d184 1
a184 1
	    nmg_tbl(bs->l1, TBL_LOC, &vu->magic) < 0) {
d186 1
a186 1
		(void)nmg_tbl(bs->l1, TBL_INS, &vu->magic);
d191 3
a193 2
		plu = nmg_mlv(&fu->magic, vu->v_p, OT_UNSPEC);
	    	(void)nmg_tbl(bs->l2, TBL_INS, &plu->down.vu_p->magic);
d222 2
d225 10
a234 4
		if (eu->vu_p->v_p != eu->last->eumate_p->vu_p->v_p) {
			VPRINT("unshared vertex (mine): ", eu->vu_p->v_p->vg_p->coord);
			VPRINT("\t\t (last->eumate_p): ", eu->last->eumate_p->vu_p->v_p->vg_p->coord);
			rt_bomb("discontiuous edgeloop\n");
d236 6
a241 4
		if (eu->next->vu_p->v_p != eu->eumate_p->vu_p->v_p) {
VPRINT("unshared vertex (my mate): ", eu->eumate_p->vu_p->v_p->vg_p->coord);
VPRINT("\t\t (next): ", eu->next->vu_p->v_p->vg_p->coord);
			rt_bomb("discontiuous edgeloop\n");
a242 2


a244 2


d272 4
a275 4
		if (nmg_tbl(bs->l1, TBL_LOC, &eu->vu_p->magic) < 0)
			(void)nmg_tbl(bs->l1, TBL_INS, &eu->vu_p->magic);
		if (nmg_tbl(bs->l2, TBL_LOC, &vu->magic) < 0)
			(void)nmg_tbl(bs->l2, TBL_INS, &vu->magic);
d355 2
a356 2
		if (nmg_tbl(bs->l1, TBL_LOC, &eu->vu_p->magic) < 0)
			(void)nmg_tbl(bs->l1, TBL_INS, &eu->vu_p->magic);
d366 2
a367 2
			if (nmg_tbl(bs->l2, TBL_LOC, &vu->magic) < 0)
				(void)nmg_tbl(bs->l2, TBL_INS, &vu->magic);
d387 1
a387 1
			plu = nmg_mlv(&fu->magic, eu->vu_p->v_p, OT_UNSPEC);
d392 2
a393 1
			(void)nmg_tbl(bs->l2, TBL_INS, &plu->down.vu_p->magic);
d398 2
d421 2
a422 2
			if (nmg_tbl(bs->l2, TBL_LOC, &vu->magic) < 0)
				(void)nmg_tbl(bs->l2, TBL_INS, &vu->magic);
a423 1

d434 3
a436 2
			NMG_CK_EDGEUSE(eu->next);
			NMG_CK_EDGEUSE(eu->next->eumate_p);
d440 2
a441 2
			NMG_CK_VERTEXUSE(eu->next->vu_p);
			NMG_CK_VERTEXUSE(eu->next->eumate_p->vu_p);
d445 2
a446 2
			NMG_CK_VERTEX(eu->next->vu_p->v_p);
			NMG_CK_VERTEX(eu->next->eumate_p->vu_p->v_p);
d460 4
a463 4
			NMG_CK_VERTEX_G(eu->next->vu_p->v_p->vg_p);
			NMG_CK_VERTEX_G(eu->next->eumate_p->vu_p->v_p->vg_p);

			if (eu->next->vu_p->v_p != eu->eumate_p->vu_p->v_p)
d467 8
a474 14
				rt_log("Just split %g, %g, %g -> %g, %g, %g\n\t\t\t%g, %g, %g -> %g, %g, %g\n",
					eu->vu_p->v_p->vg_p->coord[0],
					eu->vu_p->v_p->vg_p->coord[1],
					eu->vu_p->v_p->vg_p->coord[2],
					eu->eumate_p->vu_p->v_p->vg_p->coord[0],
					eu->eumate_p->vu_p->v_p->vg_p->coord[1],
					eu->eumate_p->vu_p->v_p->vg_p->coord[2],
					eu->next->vu_p->v_p->vg_p->coord[0],
					eu->next->vu_p->v_p->vg_p->coord[1],
					eu->next->vu_p->v_p->vg_p->coord[2],
					eu->next->eumate_p->vu_p->v_p->vg_p->coord[0],
					eu->next->eumate_p->vu_p->v_p->vg_p->coord[1],
					eu->next->eumate_p->vu_p->v_p->vg_p->coord[2]);

d480 1
a480 1
			plu = nmg_mlv(&fu->magic,
d485 2
a486 1
			    		plu->down.vu_p->v_p->vg_p->coord);
d488 2
a489 1
			(void)nmg_tbl(bs->l2, TBL_INS, &plu->down.vu_p->magic);
d492 1
d498 2
a499 2
			p1 = eu->next->vu_p->v_p->vg_p->coord;
			p2 = eu->next->eumate_p->vu_p->v_p->vg_p->coord;
d504 1
a504 1
		(void)nmg_tbl(bs->l1, TBL_INS, &eu->next->vu_p->magic);
d515 2
a516 1
		if( eu->next->vu_p->v_p != eu->eumate_p->vu_p->v_p )
d548 2
a549 1
	struct edgeuse *eu, *eu_start;
a550 1

d555 2
a556 1
	if (*lu->down.magic_p == NMG_VERTEXUSE_MAGIC) {
d560 12
a571 3
		isect_vertex_face(bs, lu->down.vu_p, fu);
	} else if (*lu->down.magic_p == NMG_EDGEUSE_MAGIC) {
		/* Process a loop consisting of a list of edgeuses.
d573 3
a575 2
		eu_start = eu = lu->down.eu_p;
		do {
d578 1
a578 1
			if (eu->up.magic_p != &lu->magic) {
d583 1
a583 10

			/* by going backwards around the list we avoid
			 * re-processing an edgeuse that was just created
			 * by isect_edge_face.  This is because the edgeuses
			 * point in the "next" direction, and when one of
			 * them is split, it inserts a new edge AHEAD or
			 * "nextward" of the current edgeuse.
			 */
			eu = eu->last;
		} while (eu != eu_start);
d599 1
a599 1
	struct loopuse *lu_start, *lu;
d605 1
a605 2
	lu_start = lu = fu1->lu_p;
	do {
d615 1
a615 3

		lu = lu->next;
	} while (lu != lu_start);
d675 1
d812 5
a816 2
	if (!s1->fu_p || !s2->fu_p)
		rt_bomb("ERROR:shells must contain faces for boolean operations.");
d825 1
a825 2
	fu1 = s1->fu_p;
	do {
d839 5
a843 5
			fu2 = s2->fu_p;
			do {
				/* now we check the face of shell 1
				 * against each of the faces of shell
				 * 2.
d847 8
a854 9
				/* try to avoid processing redundant
				 * faceuses.
				 */
				if (fu2->next != s2->fu_p &&
				    fu2->next->f_p == fu2->f_p)
					fu2 = fu2->next->next;
				else
					fu2 = fu2->next;
			} while (fu2 != s2->fu_p);
d856 1
a856 1
		    }
d858 8
a865 6
		/* try not to process redundant faceuses */
		if (fu1->next != s1->fu_p && fu1->next->f_p == fu1->f_p)
			fu1 = fu1->next->next;
		else
			fu1 = fu1->next;
	} while (fu1 != s1->fu_p);
@


1.10
log
@corrected (again) problem with edges intersecting planes of faces "behind"
the edgeuse vector
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 1.9 90/05/13 21:00:05 mike Exp $ (BRL)";
d210 7
a216 6
	fastf_t		vect_len;	/* MAGNITUDE(vect) */
	pointp_t p1, p2, p3;
	vect_t vect, delta;
	fastf_t dist, mag;
	int status;
	struct loopuse *plu;
d296 1
a296 1
	VSUB2(vect, p2, p1);
d303 1
a303 1
	status = rt_isect_ray_plane(&dist, p1, vect, fu->f_p->fg_p->N);
d320 1
a320 1
	/* the ray defined by the edgeuse intersects the plane 
d324 5
d330 3
a332 4
	VJOIN1( hit_pt, p1, dist, vect );
	vect_len = MAGNITUDE(vect);
	VSCALE(delta, vect, dist);
	mag = MAGNITUDE(delta);
d335 2
a336 2
		rt_log("\tmag of vect:%g  Dist to plane:%g\n",
			MAGNITUDE(vect), mag);
d338 1
a338 1
	if ( dist < -(bs->tol) )  {
d345 1
a345 1
	if ( mag < bs->tol )  {
d357 1
d392 1
a392 1
	if ( mag < vect_len - bs->tol) {
d503 1
a503 1
	if ( mag < vect_len + bs->tol) {
d517 1
@


1.9
log
@function names and some debug messages improved.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 1.8 90/05/13 14:24:42 mike Exp $ (BRL)";
d333 1
a333 1
	if( mag < -(bs->tol) )  {
d340 1
a340 1
	if( mag < bs->tol )  {
@


1.8
log
@Packaged some plotting stuff into nmg_pl_2fu().
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 1.7 90/05/13 12:42:13 mike Exp $ (BRL)";
d571 1
a571 1
		rt_bomb("Unknown type of NMG loopuse\n");
d574 3
a576 1
/*	I S E C T _ L O O P S
d578 1
a578 1
 *	intersect loops of face 1 with face 2
d580 1
a580 1
static void isect_loops(bs, fu1, fu)
d582 2
a583 1
struct faceuse *fu1, *fu;
d587 1
a587 1
	NMG_CK_FACE_G(fu->f_p->fg_p);
d598 1
a598 1
			rt_bomb("Child loop doesn't share parent!\n");
d601 1
a601 1
		isect_loop_face(bs, lu, fu);
d608 2
d723 1
a723 1
	isect_loops(&bs, fu1, fu2);
d744 1
a744 1
	isect_loops(&bs, fu2, fu1);
@


1.7
log
@Initial support for co-planar faces.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 1.6 90/05/13 11:06:13 mike Exp $ (BRL)";
d33 6
a38 2
	struct nmg_ptbl *l1, *l2;
	fastf_t tol;
d604 14
d619 19
d648 1
a648 1
	struct nmg_boolstruct bs;
a652 2
	point_t		pt;
	vect_t		dir;
d685 1
a685 1
	status = rt_isect_2planes( pt, dir, f1->fg_p->N, f2->fg_p->N, min_pt );
d689 1
d694 1
d697 1
a697 1
		/* parallel and distinct */
a713 3
    		FILE *fd, *fopen();
    		static char name[32];
    		static struct nmg_ptbl b;
d715 1
a715 15

    		(void)nmg_tbl(&b, TBL_INIT, (long *)NULL);
    		(void)sprintf(name, "Isect_faces%d.pl", fno++);
    		rt_log("plotting to %s\n", name);
    		if ((fd=fopen(name, "w")) == (FILE *)NULL)
    			rt_bomb(name);

    		(void)nmg_pl_fu(fd, fu1, &b, 100, 100, 180);
/*    		(void)nmg_pl_fu(fd, fu1->fumate_p, &b, 100, 100, 180);
*/
    		(void)nmg_pl_fu(fd, fu2, &b, 100, 100, 180);
/*    		(void)nmg_pl_fu(fd, fu2->fumate_p, &b, 100, 100, 180);
*/
    		(void)fclose(fd);
    		(void)nmg_tbl(&b, TBL_FREE, (long *)NULL);
d747 1
a747 1
	tbl_vsort(&vert_list1, fu1, fu2, pt);
d750 1
a750 1
	tbl_vsort(&vert_list2, fu2, fu1, pt);
a759 3
    		FILE *fd, *fopen();
    		static char name[32];
    		static struct nmg_ptbl b;
d761 1
a761 15

    		(void)nmg_tbl(&b, TBL_INIT, (long *)NULL);
    		(void)sprintf(name, "Before_mesh%d.pl", fnum++);
    		if ((fd=fopen(name, "w")) == (FILE *)NULL)
    			rt_bomb(name);

    		rt_log("plotting %s\n", name);
    		(void)nmg_pl_fu(fd, fu1, &b, 100, 100, 180);
    		(void)nmg_pl_fu(fd, fu1->fumate_p, &b, 100, 100, 180);

    		(void)nmg_pl_fu(fd, fu2, &b, 100, 100, 180);
    		(void)nmg_pl_fu(fd, fu2->fumate_p, &b, 100, 100, 180);

    		(void)fclose(fd);
    		(void)nmg_tbl(&b, TBL_FREE, (long *)NULL);
a767 3
    		FILE *fd, *fopen();
    		static char name[32];
    		static struct nmg_ptbl b;
d769 1
a769 15

    		(void)nmg_tbl(&b, TBL_INIT, (long *)NULL);
    		(void)sprintf(name, "After_mesh%d.pl", fno++);
    		rt_log("plotting to %s\n", name);
    		if ((fd=fopen(name, "w")) == (FILE *)NULL)
    			rt_bomb(name);

    		(void)nmg_pl_fu(fd, fu1, &b, 100, 100, 180);
    		(void)nmg_pl_fu(fd, fu1->fumate_p, &b, 100, 100, 180);

    		(void)nmg_pl_fu(fd, fu2, &b, 100, 100, 180);
    		(void)nmg_pl_fu(fd, fu2->fumate_p, &b, 100, 100, 180);

    		(void)fclose(fd);
    		(void)nmg_tbl(&b, TBL_FREE, (long *)NULL);
@


1.6
log
@Minor neatening.
@
text
@d7 1
a7 1
 *  Author -
d9 1
d17 1
a17 1
 *	This software is Copyright (C) 1989 by the United States Army.
d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_inter.c,v 1.5 90/05/11 08:22:14 mike Exp $ (BRL)";
d48 1
a48 1
static void tbl_vsort(b, fu1, fu2)
d50 2
a51 1
struct faceuse *fu1, *fu2;
d53 2
a54 2
	point_t pt, min_pt;
	vect_t	dir, vect;
a62 3
	VMOVE(min_pt, fu1->f_p->fg_p->min_pt);
	VMIN(min_pt, fu2->f_p->fg_p->min_pt);
	rt_isect_2planes(pt, dir, fu1->f_p->fg_p->N, fu2->f_p->fg_p->N, min_pt);
d616 3
d623 1
d648 20
d727 1
a727 1
	tbl_vsort(&vert_list1, fu1, fu2);
d730 1
a730 1
	tbl_vsort(&vert_list2, fu2, fu1);
@


1.5
log
@Improved some comments.
When intersecting edge/face, added code to take topological note of
hitting an existing vertex on the far end of the edge.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: nmg_inter.c,v 1.4 90/05/11 07:21:32 mike Locked $ (BRL)";
d602 2
a603 1
/*	I S E C T _ F A C E S
d607 1
a607 1
static void nmg_isect_faces(fu1, fu2, tol)
d613 4
a616 3
	int i;
	fastf_t *pl1, *pl2;

d622 4
d627 5
d633 2
a634 2
		pl1 = fu1->f_p->fg_p->N;
		pl2 = fu2->f_p->fg_p->N;
d641 2
a642 6
	NMG_CK_FACEUSE(fu1);
	NMG_CK_FACE(fu1->f_p);
	NMG_CK_FACE_G(fu1->f_p->fg_p);
	NMG_CK_FACEUSE(fu2);
	NMG_CK_FACE(fu2->f_p);
	NMG_CK_FACE_G(fu2->f_p->fg_p);
a643 3
	if ( !NMG_EXTENT_OVERLAP(fu2->f_p->fg_p->min_pt,fu2->f_p->fg_p->max_pt,
	    fu1->f_p->fg_p->min_pt,fu1->f_p->fg_p->max_pt) )  return;

d767 2
a768 1
/*	C R A C K S H E L L S
d770 2
a771 2
 *	split the faces of two shells in preparation for performing boolean
 *	operations with them.
d785 1
d789 4
d795 9
a803 2
	if (NMG_EXTENT_OVERLAP(s1->sa_p->min_pt, s1->sa_p->max_pt,
	    s2->sa_p->min_pt, s2->sa_p->max_pt) ) {
d805 4
a808 8
		/* shells overlap */
		fu1 = s1->fu_p;
		do {/* check each of the faces in shell 1 to see
		     * if they overlap the extent of shell 2
		     */
			NMG_CK_FACEUSE(fu1);
			NMG_CK_FACE(fu1->f_p);
			NMG_CK_FACE_G(fu1->f_p->fg_p);
d810 8
a817 4
			if (nmg_tbl(&faces, TBL_LOC, &fu1->f_p->magic) < 0 &&
			    NMG_EXTENT_OVERLAP(s2->sa_p->min_pt,
			    s2->sa_p->max_pt, fu1->f_p->fg_p->min_pt,
			    fu1->f_p->fg_p->max_pt) ) {
d819 11
a829 8
				/* poly1 overlaps shell2 */
				fu2 = s2->fu_p;
				do {
					/* now we check the face of shell 1
					 * against each of the faces of shell
					 * 2.
		 			 */
					nmg_isect_faces(fu1, fu2, tol);
d831 6
a836 8
					/* try to avoid processing redundant
					 * faceuses.
					 */
					if (fu2->next != s2->fu_p &&
					    fu2->next->f_p == fu2->f_p)
						fu2 = fu2->next->next;
					else
						fu2 = fu2->next;
d838 1
a838 13
				} while (fu2 != s2->fu_p);
				(void)nmg_tbl(&faces, TBL_INS, &fu1->f_p->magic);
			    }

			/* try not to process redundant faceuses */
			if (fu1->next != s1->fu_p && fu1->next->f_p == fu1->f_p)
				fu1 = fu1->next->next;
			else
				fu1 = fu1->next;

		} while (fu1 != s1->fu_p);
	}

@


1.4
log
@fixed nasty "teleporting vertex" problem
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: nmg_inter.c,v 1.3 90/05/11 05:35:47 mike Exp $ (BRL)";
d112 3
a114 2
 *	determine if the given vertex can be found in the given faceuse
 *	if it can, return a pointer to the vertexuse which was found in the
d206 2
a207 1
	point_t pt;
d241 4
a244 2
	 * If the vertex on the other end of this edgeuse is on the face, then
	 * we give up on this edge, knowing that we'll pick up the
d248 1
a248 1
	 * point.  This is probbably a bad assumption for the future
a281 1

d285 4
a288 4

	/* Since the topology didn't tell us about any intersections, 
	 * we need to check the geometry.  First we form the vector for the
	 * edgeuse.
a300 1

d321 2
d330 6
d337 2
a338 5
	if (NEAR_ZERO(mag, bs->tol) ) {
		/* the starting vertex of this edgeuse is
		 * geometrically on the other face.
		 */

d342 1
a342 3
		/* if this vertex is not already in our list of vertices
		 * on the intersection line, we add it to the list
		 */
d346 1
a346 6
		/* if the other face doesn't already have a very similar
		 * point, we give it one
		 */
		/* check to see if the other face has a point which is very
		 * similar
		 */
d349 3
a351 4
			/* the other face has a vertex very similar to this
			 * one.  We should make sure the use in the other
			 * face is in that face's list of verticies on the
			 * intersection, and combine the two verticies.
d356 1
a356 1
			/* compute the new coordinate as the midpoint between
d361 1
d381 1
d383 3
a385 4
	else if (dist > 0.0 && mag < MAGNITUDE(vect)-bs->tol) {
		/* the line segment defined by this edge(use)
		 * crosses the other face/plane.  We insert a new
		 * vertex at the point of intersection.
d387 1
a387 2

		if (rt_g.NMG_debug & DEBUG_POLYSECT)
d390 2
a392 7
		/* compute the point of intersection of this edge
		 * with the face
		 */
		VADD2(pt, p1, delta);
		if (rt_g.NMG_debug & DEBUG_POLYSECT)
			VPRINT("\tPoint of intersection", pt);

d397 1
a397 1
		vu = nmg_find_vu_in_face(pt, fu, bs->tol);
d440 1
a440 1
			nmg_vertex_gv(eu->eumate_p->vu_p->v_p, pt);
d492 1
d494 5
a498 1
	else
d500 21
a520 1
		rt_log("\tdist to plane X: X < 0.0 or X > MAGNITUDE(edge)\n");
@


1.3
log
@Indents
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: nmg_inter.c,v 1.2 90/05/11 05:28:11 mike Locked $ (BRL)";
d217 18
d361 1
a361 1
			VSUB2SCALE(p1, p1, p3, 0.5);
d457 1
a457 1
				rt_log("Just split %g, %g, %g -> %g, %g, %g   %g, %g, %g -> %g, %g, %g\n",
@


1.2
log
@Oops, moved a subroutine around, fixed a static.
@
text
@d1 2
a2 1
/*			N M G _ B O O L . C
d4 2
a5 5
 *	Support for boolean operations on NMG objects.  Most of the routines
 *	in here are static/local to this file.  The interfaces here are the
 *	functions "nmg_do_bool" and "nmg_mesh_faces".  The former does boolean
 *	operations on a pair of shells.  The latter is a function to make
 *	edges shared between two faces whenever possible.
d20 1
a20 1
static char RCSid[] = "@@(#)$Header: nmg_inter.c,v 1.1 90/05/11 04:59:26 mike Locked $ (BRL)";
a36 1
/********************** isects ***************************************/
a37 1

d47 1
a47 1
void tbl_vsort(b, fu1, fu2)
d600 2
a601 2
	if (NMG_EXTENT_OVERLAP(fu2->f_p->fg_p->min_pt,fu2->f_p->fg_p->max_pt,
	    fu1->f_p->fg_p->min_pt,fu1->f_p->fg_p->max_pt) ) {
d603 3
a605 3
		/* poly1 overlaps poly2 */
		(void)nmg_tbl(&vert_list1, TBL_INIT,(long *)NULL);
		(void)nmg_tbl(&vert_list2, TBL_INIT,(long *)NULL);
d607 3
a609 3
	    	bs.l1 = &vert_list1;
	    	bs.l2 = &vert_list2;
	    	bs.tol = tol/50.0;
d611 6
d618 5
a622 6
	    	if (rt_g.NMG_debug & (DEBUG_POLYSECT|DEBUG_COMBINE|DEBUG_MESH)
	    	    && rt_g.NMG_debug & DEBUG_PLOTEM) {
	    		FILE *fd, *fopen();
	    		static char name[32];
	    		static struct nmg_ptbl b;
	    		static int fno=1;
d624 2
a625 8
	    		(void)nmg_tbl(&b, TBL_INIT, (long *)NULL);
	    		(void)sprintf(name, "Isect_faces%d.pl", fno++);
	    		rt_log("plotting to %s\n", name);
	    		if ((fd=fopen(name, "w")) == (FILE *)NULL)
	    			rt_bomb(name);

	    		(void)nmg_pl_fu(fd, fu1, &b, 100, 100, 180);
/*	    		(void)nmg_pl_fu(fd, fu1->fumate_p, &b, 100, 100, 180);
d627 2
a628 2
	    		(void)nmg_pl_fu(fd, fu2, &b, 100, 100, 180);
/*	    		(void)nmg_pl_fu(fd, fu2->fumate_p, &b, 100, 100, 180);
d630 3
a632 3
	    		(void)fclose(fd);
	    		(void)nmg_tbl(&b, TBL_FREE, (long *)NULL);
	    	}
d634 1
a634 1
		isect_loops(&bs, fu1, fu2);
d636 16
a651 4
	    	if (rt_g.NMG_debug & DEBUG_COMBINE) {
		    	p.magic_p = vert_list1.buffer;
		    	rt_log("vert_list1\n");
			for (i=0 ; i < vert_list1.end ; ++i) {
d653 3
a655 12
				rt_log("%d\t%g, %g, %g\t", i,
					p.vu[i]->v_p->vg_p->coord[X],
					p.vu[i]->v_p->vg_p->coord[Y],
					p.vu[i]->v_p->vg_p->coord[Z]);
				if (*p.vu[i]->up.magic_p == NMG_EDGEUSE_MAGIC) {
					rt_log("EDGEUSE\n");
				} else if (*p.vu[i]->up.magic_p == NMG_LOOPUSE_MAGIC){
					rt_log("LOOPUSE\n");
				} else
					rt_log("UNKNOWN\n");
			}
	    	}
d657 8
d666 2
a667 3
	    	bs.l2 = &vert_list1;
	    	bs.l1 = &vert_list2;
		isect_loops(&bs, fu2, fu1);
d669 11
a679 8
	    	if (vert_list1.end == 0) {
	    		/* there were no intersections */
			(void)nmg_tbl(&vert_list1, TBL_FREE, (long *)NULL);
			(void)nmg_tbl(&vert_list2, TBL_FREE, (long *)NULL);
	    		return;
	    	}
		tbl_vsort(&vert_list1, fu1, fu2);
		nmg_face_combine(&vert_list1, fu1, fu2);
d681 4
a684 2
		tbl_vsort(&vert_list2, fu2, fu1);
		nmg_face_combine(&vert_list2, fu2, fu1);
d686 3
a688 5
		/* When two faces are intersected
		 * with each other, they should
		 * share the same edge(s) of
		 * intersection. 
		 */
d690 2
d693 3
a695 6
	    	if (rt_g.NMG_debug & DEBUG_MESH &&
	    	    rt_g.NMG_debug & DEBUG_PLOTEM) {
	    		FILE *fd, *fopen();
	    		static char name[32];
	    		static struct nmg_ptbl b;
	    		static int fnum=1;
d697 1
a697 4
	    		(void)nmg_tbl(&b, TBL_INIT, (long *)NULL);
	    		(void)sprintf(name, "Before_mesh%d.pl", fnum++);
	    		if ((fd=fopen(name, "w")) == (FILE *)NULL)
	    			rt_bomb(name);
d699 6
a704 3
	    		rt_log("plotting %s\n", name);
	    		(void)nmg_pl_fu(fd, fu1, &b, 100, 100, 180);
	    		(void)nmg_pl_fu(fd, fu1->fumate_p, &b, 100, 100, 180);
d706 5
a710 2
	    		(void)nmg_pl_fu(fd, fu2, &b, 100, 100, 180);
	    		(void)nmg_pl_fu(fd, fu2->fumate_p, &b, 100, 100, 180);
d712 2
a713 3
	    		(void)fclose(fd);
	    		(void)nmg_tbl(&b, TBL_FREE, (long *)NULL);
	    	}
d715 2
a716 1
 		nmg_mesh_faces(fu1, fu2);
d718 3
d722 3
a724 6
	    	if (rt_g.NMG_debug & DEBUG_MESH &&
	    	    rt_g.NMG_debug & DEBUG_PLOTEM) {
	    		FILE *fd, *fopen();
	    		static char name[32];
	    		static struct nmg_ptbl b;
	    		static int fno=1;
a725 20
	    		(void)nmg_tbl(&b, TBL_INIT, (long *)NULL);
	    		(void)sprintf(name, "After_mesh%d.pl", fno++);
	    		rt_log("plotting to %s\n", name);
	    		if ((fd=fopen(name, "w")) == (FILE *)NULL)
	    			rt_bomb(name);

	    		(void)nmg_pl_fu(fd, fu1, &b, 100, 100, 180);
	    		(void)nmg_pl_fu(fd, fu1->fumate_p, &b, 100, 100, 180);

	    		(void)nmg_pl_fu(fd, fu2, &b, 100, 100, 180);
	    		(void)nmg_pl_fu(fd, fu2->fumate_p, &b, 100, 100, 180);

	    		(void)fclose(fd);
	    		(void)nmg_tbl(&b, TBL_FREE, (long *)NULL);
	    	}

		(void)nmg_tbl(&vert_list1, TBL_FREE, (long *)NULL);
		(void)nmg_tbl(&vert_list2, TBL_FREE, (long *)NULL);
	}
}
@


1.1
log
@Initial revision
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: nmg_bool.c,v 1.10 90/05/11 04:43:15 mike Locked $ (BRL)";
d42 22
d65 49
d671 1
a671 1
		combine(&vert_list1, fu1, fu2);
d674 1
a674 1
		combine(&vert_list2, fu2, fu1);
@
