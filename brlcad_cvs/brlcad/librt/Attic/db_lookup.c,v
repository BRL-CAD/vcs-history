head	11.38;
access;
symbols
	ansi-20040405-merged:11.34.2.2
	postmerge-20040405-ansi:11.36
	premerge-20040404-ansi:11.35
	postmerge-autoconf:11.35
	autoconf-freeze:11.34.10.2
	premerge-autoconf:11.35
	ansi-20040316-freeze:11.34.2.1
	postmerge-20040315-windows:11.35
	premerge-20040315-windows:11.35
	windows-20040315-freeze:11.34.4.1
	autoconf-20031203:11.34
	autoconf-20031202:11.34
	autoconf-branch:11.34.0.10
	phong-branch:11.34.0.8
	photonmap-branch:11.34.0.6
	rel-6-1-DP:11.34
	windows-branch:11.34.0.4
	rel-6-0-2:11.30
	ansi-branch:11.34.0.2
	rel-6-0-1-branch:11.30.0.2
	hartley-6-0-post:11.33
	hartley-6-0-pre:11.32
	rel-6-0-1:11.30
	rel-6-0:11.30
	rel-5-4:11.11
	offsite-5-3-pre:11.19
	rel-5-3:11.11
	rel-5-2:11.11
	rel-5-1-branch:11.11.0.2
	rel-5-1:11.11
	rel-5-0:11.5
	rel-5-0-beta:11.5
	rel-4-5:11.4
	ctj-4-5-post:11.3
	ctj-4-5-pre:11.3
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1;
locks; strict;
comment	@ * @;


11.38
date	2004.05.21.18.07.29;	author morrison;	state dead;
branches;
next	11.37;

11.37
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.36;

11.36
date	2004.04.05.08.48.56;	author morrison;	state Exp;
branches;
next	11.35;

11.35
date	2004.02.02.17.39.15;	author morrison;	state Exp;
branches;
next	11.34;

11.34
date	2002.08.20.17.07.57;	author jra;	state Exp;
branches
	11.34.2.1
	11.34.4.1
	11.34.10.1;
next	11.33;

11.33
date	2002.08.15.20.55.09;	author hartley;	state Exp;
branches;
next	11.32;

11.32
date	2002.08.15.13.48.53;	author jra;	state Exp;
branches;
next	11.31;

11.31
date	2002.08.11.02.04.14;	author morrison;	state Exp;
branches;
next	11.30;

11.30
date	2002.02.26.20.29.01;	author jra;	state Exp;
branches;
next	11.29;

11.29
date	2002.02.26.20.25.34;	author jra;	state Exp;
branches;
next	11.28;

11.28
date	2002.02.22.16.09.12;	author jra;	state Exp;
branches;
next	11.27;

11.27
date	2002.02.14.15.41.36;	author jra;	state Exp;
branches;
next	11.26;

11.26
date	2002.01.09.19.57.23;	author jra;	state Exp;
branches;
next	11.25;

11.25
date	2001.11.08.18.15.11;	author bparker;	state Exp;
branches;
next	11.24;

11.24
date	2001.05.17.20.05.23;	author morrison;	state Exp;
branches;
next	11.23;

11.23
date	2001.04.20.22.29.41;	author morrison;	state Exp;
branches;
next	11.22;

11.22
date	2001.04.20.20.00.13;	author bparker;	state Exp;
branches;
next	11.21;

11.21
date	2001.03.27.20.06.41;	author jra;	state Exp;
branches;
next	11.20;

11.20
date	2001.03.23.22.05.30;	author jra;	state Exp;
branches;
next	11.19;

11.19
date	2001.01.29.16.17.10;	author jra;	state Exp;
branches;
next	11.18;

11.18
date	2000.09.08.05.54.41;	author mike;	state Exp;
branches;
next	11.17;

11.17
date	2000.09.07.05.49.52;	author mike;	state Exp;
branches;
next	11.16;

11.16
date	2000.09.07.05.34.34;	author mike;	state Exp;
branches;
next	11.15;

11.15
date	2000.08.29.04.23.40;	author mike;	state Exp;
branches;
next	11.14;

11.14
date	2000.08.21.02.02.29;	author butler;	state Exp;
branches;
next	11.13;

11.13
date	2000.07.10.23.01.27;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	2000.07.07.03.36.18;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	2000.05.02.01.46.03;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	2000.01.08.02.30.26;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	99.12.30.02.58.39;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	99.12.29.23.23.09;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	99.11.26.21.46.44;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	99.09.21.14.57.48;	author jra;	state Exp;
branches;
next	11.5;

11.5
date	98.03.27.17.20.43;	author jra;	state Exp;
branches;
next	11.4;

11.4
date	97.12.16.06.09.51;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	97.02.05.03.54.44;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	96.09.27.08.27.30;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.56.16;	author mike;	state Rel4_4;
branches;
next	10.4;

10.4
date	94.09.30.16.08.45;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	94.08.10.17.52.28;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	93.04.01.03.48.00;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.40.02;	author mike;	state Rel4_0;
branches;
next	9.7;

9.7
date	91.08.30.17.13.01;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	91.06.30.23.17.58;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	90.12.07.20.49.33;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	90.12.07.05.49.44;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	90.05.21.14.32.18;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	89.06.19.17.22.34;	author phil;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.55.43;	author mike;	state Rel3_5;
branches;
next	1.4;

1.4
date	89.05.18.23.38.15;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	89.03.06.16.05.38;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	88.12.13.02.13.44;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	88.12.06.00.09.15;	author mike;	state Exp;
branches;
next	;

11.34.2.1
date	2002.09.19.18.01.31;	author morrison;	state Exp;
branches;
next	11.34.2.2;

11.34.2.2
date	2004.03.17.21.18.43;	author morrison;	state Exp;
branches;
next	;

11.34.4.1
date	2004.03.11.23.43.35;	author morrison;	state Exp;
branches;
next	;

11.34.10.1
date	2004.02.12.18.37.38;	author erikg;	state Exp;
branches;
next	11.34.10.2;

11.34.10.2
date	2004.03.15.14.07.17;	author erikg;	state Exp;
branches;
next	;


desc
@db_lookup
@


11.38
log
@moved to src/
@
text
@/*
 *			D B _ L O O K U P . C
 *
 * Functions -
 *	db_dirhash	Compute hashing function
 *	db_lookup	Convert an object name into directory pointer
 *	db_diradd	Add entry to the directory
 *	db_dirdelete	Delete entry from directory
 *	db_rename	Change name string of a directory entry
 *	db_pr_dir	Print contents of database directory
 *
 *
 *  Authors -
 *	Michael John Muuss
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1988-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/db_lookup.c,v 11.37 2004/05/10 15:30:46 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"
#include "vmath.h"
#include "db.h"
#include "raytrace.h"

#include "./debug.h"


/*
 *			D B _ I S _ D I R E C T O R Y _ N O N _ E M P T Y
 *
 *  Returns -
 *	0	if the in-memory directory is empty
 *	1	if the in-memory directory has entries,
 *		which implies that a db_scan() has already been performed.
 */
int
db_is_directory_non_empty(const struct db_i	*dbip)
{
	register int	i;

	RT_CK_DBI(dbip);

	for (i = 0; i < RT_DBNHASH; i++)  {
		if( dbip->dbi_Head[i] != DIR_NULL )
			return 1;
	}
	return 0;
}

/*
 *			D B _ G E T _ D I R E C T O R Y _ S I Z E
 *
 *  Return the number of "struct directory" nodes in the given database.
 */
int
db_get_directory_size(const struct db_i *dbip)
{
	register struct directory *dp;
	register int	count = 0;
	int		i;

	RT_CK_DBI(dbip);

	for (i = 0; i < RT_DBNHASH; i++)  {
		for (dp = dbip->dbi_Head[i]; dp != DIR_NULL; dp = dp->d_forw)
			count++;
	}
	return count;
}

/*
 *			D B _ C K _ D I R E C T O R Y
 *
 *  For debugging, ensure that all the linked-lists for the directory
 *  structure are intact.
 */
void
db_ck_directory(const struct db_i *dbip)
{
	register struct directory *dp;
	int		i;

	RT_CK_DBI(dbip);

	for (i = 0; i < RT_DBNHASH; i++)  {
		for (dp = dbip->dbi_Head[i]; dp != DIR_NULL; dp = dp->d_forw)
			RT_CK_DIR(dp);
	}
}

/*
 *			D B _ D I R H A S H
 *  
 *  Internal function to return pointer to head of hash chain
 *  corresponding to the given string.
 */
int
db_dirhash(const char *str)
{
	register const unsigned char *s = (unsigned char *)str;
	register long sum;
	register int i;

	sum = 0;
	/* BSD namei hashing starts i=0, discarding first char.  why? */
	for( i=1; *s; )
		sum += *s++ * i++;

	return( RT_DBHASH(sum) );
}

/*
 *  Name -
 *	D B _ D I R C H E C K
 *
 *  Description -
 *	This routine ensures that ret_name is not already in the
 *	directory. If it is, it tries a fixed number of times to
 *	modify ret_name before giving up. Note - most of the time,
 *	the hash for ret_name is computed once.
 *
 *  Inputs -
 *	dbip		database instance pointer
 *	ret_name	the original name
 *	noisy		to blather or not
 *
 *  Outputs -
 *	ret_name	the name to use
 *	headp		pointer to the first (struct directory *) in the bucket
 *
 *  Returns -
 *	 0	success
 *	<0	fail
 */
int
db_dircheck(struct db_i		*dbip,
	    struct bu_vls	*ret_name,
	    int			noisy,
	    struct directory	***headp)
{
	register struct directory	*dp;
	register char			*cp = bu_vls_addr(ret_name);
	register char			n0 = cp[0];
	register char			n1 = cp[1];

	/* Compute hash only once (almost always the case) */
	*headp = &(dbip->dbi_Head[db_dirhash(cp)]);

	for (dp = **headp; dp != DIR_NULL; dp=dp->d_forw) {
		register char	*this;
		if (n0 == *(this=dp->d_namep)  &&	/* speed */
		    n1 == this[1]  &&			/* speed */
		    strcmp(cp, this) == 0) {
			/* Name exists in directory already */
			register int	c;

			bu_vls_strcpy(ret_name, "A_");
			bu_vls_strcat(ret_name, this);

			for (c = 'A'; c <= 'Z'; c++) {
				*cp = c;
				if (db_lookup(dbip, cp, noisy) == DIR_NULL)
					break;
			}
			if (c > 'Z') {
				bu_log("db_dircheck: Duplicate of name '%s', ignored\n",
				       cp);
				return -1;	/* fail */
			}
			bu_log("db_dircheck: Duplicate of '%s', given temporary name '%s'\n",
			       cp+2, cp);

			/* no need to recurse, simply recompute the hash and break */
			*headp = &(dbip->dbi_Head[db_dirhash(cp)]);
			break;
		}
	}

	return 0;	/* success */
}


/*
 *			D B _ L O O K U P
 *
 * This routine takes a name and looks it up in the
 * directory table.  If the name is present, a pointer to
 * the directory struct element is returned, otherwise
 * NULL is returned.
 *
 * If noisy is non-zero, a print occurs, else only
 * the return code indicates failure.
 *
 *  Returns -
 *	struct directory	if name is found
 *	DIR_NULL		on failure
 */
struct directory *
db_lookup(const struct db_i *dbip, register const char *name, int noisy)
{
	register struct directory *dp;
	register char	n0;
	register char	n1;

	if (!name) {
	  bu_log("db_lookup received NULL name\n");
	  return (DIR_NULL);
	}

	n0 = name[0];
	n1 = name[1];

	RT_CK_DBI(dbip);

	dp = dbip->dbi_Head[db_dirhash(name)];
	for(; dp != DIR_NULL; dp=dp->d_forw )  {
		register char	*this;
		if(
			n0 == *(this=dp->d_namep)  &&	/* speed */
			n1 == this[1]  &&	/* speed */
			strcmp( name, this ) == 0
		)  {
			if(RT_G_DEBUG&DEBUG_DB) bu_log("db_lookup(%s) x%x\n", name, dp);
			return(dp);
		}
	}

	if(noisy || RT_G_DEBUG&DEBUG_DB) bu_log("db_lookup(%s) failed: %s does not exist\n", name, name);
	return( DIR_NULL );
}

/*
 *			D B _ D I R A D D
 *
 * Add an entry to the directory.
 * Try to make the regular path through the code as fast as possible,
 * to speed up building the table of contents.
 */
struct directory *
db_diradd(register struct db_i *dbip, register const char *name, long int laddr, int len, int flags, genptr_t ptr)
                    	      
                   	      
    			      
   			    
   			      
        		    		/* for db version 5, this is a pointer to an unsigned char (minor_type) */
{
	struct directory **headp;
	register struct directory *dp;
	char *tmp_ptr;
	struct bu_vls	local;

	RT_CK_DBI(dbip);

	if(RT_G_DEBUG&DEBUG_DB)  {
		bu_log("db_diradd(dbip=x%x, name='%s', addr=x%x, len=%d, flags=x%x)\n",
			dbip, name, laddr, len, flags );
	}

	if( (tmp_ptr=strchr( name, '/' )) != NULL )  {
		/* if this is a version 4 database and the offending char is beyond NAMESIZE
		 * then it is not really a problem
		 */
		if( dbip->dbi_version < 5 && (tmp_ptr - name) < 16 ) {
			bu_log("db_diradd() object named '%s' is illegal, ignored\n", name );
			return DIR_NULL;
		}
	}

	bu_vls_init(&local);
	if( dbip->dbi_version < 5 ) {
		bu_vls_strncpy(&local, name, NAMESIZE);
	} else {
		bu_vls_strcpy(&local, name);
	}
	if (db_dircheck(dbip, &local, 0, &headp) < 0) {
		bu_vls_free(&local);
		return DIR_NULL;
	}

	/* 'name' not found in directory, add it */
	RT_GET_DIRECTORY(dp, &rt_uniresource);
	RT_CK_DIR(dp);
	RT_DIR_SET_NAMEP(dp, bu_vls_addr(&local));	/* sets d_namep */
	bu_vls_free(&local);
	dp->d_un.file_offset = laddr;
	dp->d_flags = flags & ~(RT_DIR_INMEM);
	dp->d_len = len;
	dp->d_forw = *headp;
	BU_LIST_INIT( &dp->d_use_hd );
	*headp = dp;
	dp->d_animate = NULL;
	dp->d_nref = 0;
	dp->d_uses = 0;
	if( dbip->dbi_version > 4 ) {
		dp->d_major_type = DB5_MAJORTYPE_BRLCAD;
		dp->d_minor_type = *(unsigned char *)ptr;
	}
	return( dp );
}

/*
 *			D B _ I N M E M
 *
 *  Transmogrify an existing directory entry to be an in-memory-only
 *  one, stealing the external representation from 'ext'.
 */
void
db_inmem(struct directory *dp, struct bu_external *ext, int flags, struct db_i *dbip)
{
	BU_CK_EXTERNAL(ext);
	RT_CK_DIR(dp);

	if( dp->d_flags & RT_DIR_INMEM )
		bu_free( dp->d_un.ptr, "db_inmem() ext ptr" );
	dp->d_un.ptr = ext->ext_buf;
	if( dbip->dbi_version < 5 ) {
		dp->d_len = ext->ext_nbytes / 128;	/* DB_MINREC granule size */
	} else {
		dp->d_len = ext->ext_nbytes;
	}
	dp->d_flags = flags | RT_DIR_INMEM;

	/* Empty out the external structure, but leave it w/valid magic */
	ext->ext_buf = (genptr_t)NULL;
	ext->ext_nbytes = 0;
}

/*
 *  			D B _ D I R D E L E T E
 *
 *  Given a pointer to a directory entry, remove it from the
 *  linked list, and free the associated memory.
 *
 *  It is the responsibility of the caller to have released whatever
 *  structures have been hung on the d_use_hd bu_list, first.
 *
 *  Returns -
 *	 0	on success
 *	-1	on failure
 */
int
db_dirdelete(register struct db_i *dbip, register struct directory *dp)
{
	register struct directory *findp;
	register struct directory **headp;

	RT_CK_DBI(dbip);
	RT_CK_DIR(dp);

	headp = &(dbip->dbi_Head[db_dirhash(dp->d_namep)]);

	if( dp->d_flags & RT_DIR_INMEM )
	{
		if( dp->d_un.ptr != NULL )
			bu_free( dp->d_un.ptr, "db_dirdelete() inmem ptr" );
	}

	if( *headp == dp )  {
		RT_DIR_FREE_NAMEP(dp);	/* frees d_namep */
		*headp = dp->d_forw;

		/* Put 'dp' back on the freelist */
		dp->d_forw = rt_uniresource.re_directory_hd;
		rt_uniresource.re_directory_hd = dp;
		return(0);
	}
	for( findp = *headp; findp != DIR_NULL; findp = findp->d_forw )  {
		if( findp->d_forw != dp )
			continue;
		RT_DIR_FREE_NAMEP(dp);	/* frees d_namep */
		findp->d_forw = dp->d_forw;

		/* Put 'dp' back on the freelist */
		dp->d_forw = rt_uniresource.re_directory_hd;
		rt_uniresource.re_directory_hd = dp;
		return(0);
	}
	return(-1);
}

/*
 *			D B _ R E N A M E
 *
 *  Change the name string of a directory entry.
 *  Because of the hashing function, this takes some extra work.
 *
 *  Returns -
 *	 0	on success
 *	-1	on failure
 */
int
db_rename(register struct db_i *dbip, register struct directory *dp, const char *newname)
{
	register struct directory *findp;
	register struct directory **headp;

	RT_CK_DBI(dbip);
	RT_CK_DIR(dp);

	/* Remove from linked list */
	headp = &(dbip->dbi_Head[db_dirhash(dp->d_namep)]);
	if( *headp == dp )  {
		/* Was first on list, dequeue */
		*headp = dp->d_forw;
	} else {
		for( findp = *headp; findp != DIR_NULL; findp = findp->d_forw )  {
			if( findp->d_forw != dp )
				continue;
			/* Dequeue */
			findp->d_forw = dp->d_forw;
			goto out;
		}
		return(-1);		/* ERROR: can't find */
	}

out:
	/* Effect new name */
	RT_DIR_FREE_NAMEP(dp);			/* frees d_namep */
	RT_DIR_SET_NAMEP( dp, newname );	/* sets d_namep */

	/* Add to new linked list */
	headp = &(dbip->dbi_Head[db_dirhash(newname)]);
	dp->d_forw = *headp;
	*headp = dp;
	return(0);
}

/*
 *			D B _ P R _ D I R
 *
 *  For debugging, print the entire contents of the database directory.
 */
void
db_pr_dir(register const struct db_i *dbip)
{
	register const struct directory *dp;
	register char		*flags;
	register int		i;

	RT_CK_DBI(dbip);

	bu_log("db_pr_dir(x%x):  Dump of directory for file %s [%s]\n",
		dbip, dbip->dbi_filename,
		dbip->dbi_read_only ? "READ-ONLY" : "Read/Write" );

	bu_log("Title = %s\n", dbip->dbi_title);
	/* units ? */

	for( i = 0; i < RT_DBNHASH; i++ )  {
		for( dp = dbip->dbi_Head[i]; dp != DIR_NULL; dp=dp->d_forw )  {
			if( dp->d_flags & DIR_SOLID )
				flags = "SOL";
			else if( (dp->d_flags & (DIR_COMB|DIR_REGION)) ==
			    (DIR_COMB|DIR_REGION) )
				flags = "REG";
			else if( (dp->d_flags & (DIR_COMB|DIR_REGION)) ==
			    DIR_COMB )
				flags = "COM";
			else
				flags = "Bad";
			bu_log("x%.8x %s %s=x%.8x len=%.5d use=%.2d nref=%.2d %s",
				dp,
				flags,
				dp->d_flags & RT_DIR_INMEM ? "  ptr " : "d_addr",
				dp->d_addr,
				dp->d_len,
				dp->d_uses,
				dp->d_nref,
				dp->d_namep );
			if( dp->d_animate )
				bu_log(" anim=x%x\n", dp->d_animate );
			else
				bu_log("\n");
		}
	}
}


/*
 *  			D B _ G E T _ D I R E C T O R Y
 *  
 *  This routine is called by the RT_GET_DIRECTORY macro when the freelist
 *  is exhausted.  Rather than simply getting one additional structure,
 *  we get a whole batch, saving overhead.
 */
void
db_get_directory(register struct resource *resp)
{
	register struct directory	*dp;
	register int		bytes;

	RT_RESOURCE_CHECK(resp);
	BU_CK_PTBL( &resp->re_directory_blocks );

	BU_ASSERT_PTR( resp->re_directory_hd, ==, NULL );

	/* Get a BIG block */
	bytes = bu_malloc_len_roundup(1024*sizeof(struct directory));
	dp = (struct directory *)bu_malloc(bytes, "db_get_directory()");

	/* Record storage for later */
	bu_ptbl_ins( &resp->re_directory_blocks, (long *)dp );

	while( bytes >= sizeof(struct directory) )  {
		dp->d_magic = RT_DIR_MAGIC;
		dp->d_forw = resp->re_directory_hd;
		resp->re_directory_hd = dp;
		dp++;
		bytes -= sizeof(struct directory);
	}
}

/*
 *			D B _ L O O K U P _ B Y _ A T T R
 *
 *	lookup directory entries based on directory flags (dp->d_flags) and attributes
 *	the "dir_flags" arg is a mask for the directory flags
 *	the "avs" is an attribute value set used to select from the objects that pass
 *	the flags mask. if "op" is 1, then the object must have all the attributes and
 *	values that appear in "avs" in order to be selected. If "op" is 2, then the object
 *	must have at least one of the attribute/value pairs from "avs".
 *
 *	returns a ptbl list of selected directory pointers
 *		an empty list means nothing met the requirements
 *		a NULL return means something went wrong
 */
struct bu_ptbl *
db_lookup_by_attr(struct db_i *dbip, int dir_flags, struct bu_attribute_value_set *avs, int op)
                  
              			/* flags of the form used in struct directory (d_flags) */
                                   
       	/* 1 -> all attribute name/value pairs must be present and match */
        /* 2 -> at least one of the name/value pairs must be present and match */
{
	struct bu_attribute_value_set obj_avs;
	struct directory *dp;
	struct bu_ptbl *tbl;
	int match_count=0;
	int attr_count;
	int i,j;
	int draw;

	RT_CK_DBI(dbip);

	if( avs ) {
		BU_CK_AVS( avs );
		attr_count = avs->count;
	} else {
		attr_count = 0;
	}
	tbl = (struct bu_ptbl *)bu_malloc( sizeof( struct bu_ptbl ), "wdb_get_by_attr ptbl" );
	bu_ptbl_init( tbl, 128, "wdb_get_by_attr ptbl_init" );
	FOR_ALL_DIRECTORY_START(dp,dbip)
		if( (dp->d_flags & dir_flags) == 0 ) continue;
		if(attr_count ) {
			if( db5_get_attributes( dbip, &obj_avs, dp ) < 0 ) {
				bu_log( "ERROR: failed to get attributes for %s\n", dp->d_namep );
				return( (struct bu_ptbl *)NULL );
			}

			draw = 0;
			match_count = 0;
			for( i=0 ; i<avs->count ; i++ ) {
				for( j=0 ; j<obj_avs.count ; j++ ) {
					if( !strcmp( avs->avp[i].name, obj_avs.avp[j].name ) ) {
						if( !strcmp( avs->avp[i].value, obj_avs.avp[j].value ) ) {
							if( op == 2 ) {
								draw = 1;
								break;
							} else {
								match_count++;
							}
						}
					}
				}
				if( draw ) break;
			}
			bu_avs_free( &obj_avs );
		} else {
			draw = 1;
		}
		if( draw || match_count == attr_count ) {
			bu_ptbl_ins( tbl , (long *)dp );
		}
	FOR_ALL_DIRECTORY_END

	return( tbl );
}
@


11.37
log
@change conf.h to a wrapped config.h
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/librt/db_lookup.c,v 11.36 2004/04/05 08:48:56 morrison Exp $ (BRL)";
@


11.36
log
@merge of ansi-6-0-branch into HEAD
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d29 5
a33 1
#include "conf.h"
@


11.35
log
@update copyright to include span through 2003
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_lookup.c,v 11.34 2002/08/20 17:07:57 jra Exp $ (BRL)";
d74 1
a74 2
db_get_directory_size( dbip )
const struct db_i	*dbip;
d116 1
a116 2
db_dirhash(str)
const char *str;
d217 1
a217 4
db_lookup( dbip, name, noisy )
const struct db_i	*dbip;
register const char	*name;
int			noisy;
d258 7
a264 7
db_diradd( dbip, name, laddr, len, flags, ptr )
register struct db_i	*dbip;
register const char	*name;
long			laddr;
int			len;
int			flags;
genptr_t		ptr;		/* for db version 5, this is a pointer to an unsigned char (minor_type) */
d327 1
a327 5
db_inmem( dp, ext, flags, dbip )
struct directory	*dp;
struct bu_external	*ext;
int			flags;
struct db_i		*dbip;
d361 1
a361 3
db_dirdelete( dbip, dp )
register struct db_i		*dbip;
register struct directory	*dp;
d411 1
a411 4
db_rename( dbip, dp, newname )
register struct db_i		*dbip;
register struct directory	*dp;
const char			*newname;
d453 1
a453 2
db_pr_dir( dbip )
register const struct db_i	*dbip;
d547 5
a551 5
db_lookup_by_attr( dbip, dir_flags, avs, op )
struct db_i *dbip;
int dir_flags;			/* flags of the form used in struct directory (d_flags) */
struct bu_attribute_value_set *avs;
int op;	/* 1 -> all attribute name/value pairs must be present and match */
@


11.34
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d22 1
a22 1
 *	This software is Copyright (C) 1988 by the United States Army.
d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_lookup.c,v 11.32 2002/08/15 13:48:53 jra Exp $ (BRL)";
@


11.34.4.1
log
@sync to HEAD...
@
text
@d22 1
a22 1
 *	This software is Copyright (C) 1988-2004 by the United States Army.
d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/db_lookup.c,v 11.35 2004/02/02 17:39:15 morrison Exp $ (BRL)";
@


11.34.10.1
log
@merge from HEAD
@
text
@d22 1
a22 1
 *	This software is Copyright (C) 1988-2004 by the United States Army.
d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_lookup.c,v 11.35 2004/02/02 17:39:15 morrison Exp $ (BRL)";
@


11.34.10.2
log
@merge from head
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_lookup.c,v 11.34.10.1 2004/02/12 18:37:38 erikg Exp $ (BRL)";
@


11.34.2.1
log
@Initial ANSIfication
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_lookup.c,v 11.34 2002/08/20 17:07:57 jra Exp $ (BRL)";
d74 2
a75 1
db_get_directory_size(const struct db_i *dbip)
d117 2
a118 1
db_dirhash(const char *str)
d219 4
a222 1
db_lookup(const struct db_i *dbip, register const char *name, int noisy)
d263 7
a269 7
db_diradd(register struct db_i *dbip, register const char *name, long int laddr, int len, int flags, genptr_t ptr)
                    	      
                   	      
    			      
   			    
   			      
        		    		/* for db version 5, this is a pointer to an unsigned char (minor_type) */
d332 5
a336 1
db_inmem(struct directory *dp, struct bu_external *ext, int flags, struct db_i *dbip)
d370 3
a372 1
db_dirdelete(register struct db_i *dbip, register struct directory *dp)
d422 4
a425 1
db_rename(register struct db_i *dbip, register struct directory *dp, const char *newname)
d467 2
a468 1
db_pr_dir(register const struct db_i *dbip)
d562 5
a566 5
db_lookup_by_attr(struct db_i *dbip, int dir_flags, struct bu_attribute_value_set *avs, int op)
                  
              			/* flags of the form used in struct directory (d_flags) */
                                   
       	/* 1 -> all attribute name/value pairs must be present and match */
@


11.34.2.2
log
@sync branch with HEAD
@
text
@d22 1
a22 1
 *	This software is Copyright (C) 1988-2004 by the United States Army.
d26 1
a26 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.33
log
@Converted from K&R to ANSI C - RFH
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_lookup.c,v 11.30 2002/02/26 20:29:01 jra Exp $ (BRL)";
d74 2
a75 1
db_get_directory_size(const struct db_i *dbip)
d117 2
a118 1
db_dirhash(const char *str)
d219 4
a222 1
db_lookup(const struct db_i *dbip, register const char *name, int noisy)
d225 10
a234 2
	register char	n0 = name[0];
	register char	n1 = name[1];
d263 7
a269 7
db_diradd(register struct db_i *dbip, register const char *name, long int laddr, int len, int flags, genptr_t ptr)
                    	      
                   	      
    			      
   			    
   			      
        		    		/* for db version 5, this is a pointer to an unsigned char (minor_type) */
d332 5
a336 1
db_inmem(struct directory *dp, struct bu_external *ext, int flags)
d344 5
a348 1
	dp->d_len = ext->ext_nbytes / 128;	/* DB_MINREC granule size */
d370 3
a372 1
db_dirdelete(register struct db_i *dbip, register struct directory *dp)
d422 4
a425 1
db_rename(register struct db_i *dbip, register struct directory *dp, const char *newname)
d467 2
a468 1
db_pr_dir(register const struct db_i *dbip)
d562 5
a566 5
db_lookup_by_attr(struct db_i *dbip, int dir_flags, struct bu_attribute_value_set *avs, int op)
                  
              			/* flags of the form used in struct directory (d_flags) */
                                   
       	/* 1 -> all attribute name/value pairs must be present and match */
@


11.32
log
@db_inmem() needed different behavior depending on db version
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_lookup.c,v 11.31 2002/08/11 02:04:14 morrison Exp $ (BRL)";
d74 1
a74 2
db_get_directory_size( dbip )
const struct db_i	*dbip;
d116 1
a116 2
db_dirhash(str)
const char *str;
d217 1
a217 4
db_lookup( dbip, name, noisy )
const struct db_i	*dbip;
register const char	*name;
int			noisy;
d220 2
a221 10
	register char	n0;
	register char	n1;

	if (!name) {
	  bu_log("db_lookup received NULL name\n");
	  return (DIR_NULL);
	}

	n0 = name[0];
	n1 = name[1];
d250 7
a256 7
db_diradd( dbip, name, laddr, len, flags, ptr )
register struct db_i	*dbip;
register const char	*name;
long			laddr;
int			len;
int			flags;
genptr_t		ptr;		/* for db version 5, this is a pointer to an unsigned char (minor_type) */
d319 1
a319 5
db_inmem( dp, ext, flags, dbip )
struct directory	*dp;
struct bu_external	*ext;
int			flags;
struct db_i		*dbip;
d327 1
a327 5
	if( dbip->dbi_version < 5 ) {
		dp->d_len = ext->ext_nbytes / 128;	/* DB_MINREC granule size */
	} else {
		dp->d_len = ext->ext_nbytes;
	}
d349 1
a349 3
db_dirdelete( dbip, dp )
register struct db_i		*dbip;
register struct directory	*dp;
d399 1
a399 4
db_rename( dbip, dp, newname )
register struct db_i		*dbip;
register struct directory	*dp;
const char			*newname;
d441 1
a441 2
db_pr_dir( dbip )
register const struct db_i	*dbip;
d535 5
a539 5
db_lookup_by_attr( dbip, dir_flags, avs, op )
struct db_i *dbip;
int dir_flags;			/* flags of the form used in struct directory (d_flags) */
struct bu_attribute_value_set *avs;
int op;	/* 1 -> all attribute name/value pairs must be present and match */
@


11.31
log
@added check for null name argument before dereferencing a potential null pointer
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_lookup.c,v 11.30 2002/02/26 20:29:01 jra Exp $ (BRL)";
d332 1
a332 1
db_inmem( dp, ext, flags )
d336 1
d344 5
a348 1
	dp->d_len = ext->ext_nbytes / 128;	/* DB_MINREC granule size */
@


11.30
log
@Initialized variable "match_count" in db_lookup_by_attr() to eliminate compiler warning
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_lookup.c,v 11.29 2002/02/26 20:25:34 jra Exp $ (BRL)";
d225 10
a234 2
	register char	n0 = name[0];
	register char	n1 = name[1];
@


11.29
log
@db_lookup_by_attr() now matches everything if passed a NULL or empty attribute value set
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_lookup.c,v 11.28 2002/02/22 16:09:12 jra Exp $ (BRL)";
d559 1
a559 1
	int match_count;
@


11.28
log
@Added db_lookup_by_attr()
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_lookup.c,v 11.27 2002/02/14 15:41:36 jra Exp $ (BRL)";
d564 8
a573 1
	attr_count = avs->count;
d576 5
a580 4
		if( db5_get_attributes( dbip, &obj_avs, dp ) < 0 ) {
			bu_log( "ERROR: failed to get attributes for %s\n", dp->d_namep );
			return( (struct bu_ptbl *)NULL );
		}
d582 12
a593 11
		draw = 0;
		match_count = 0;
		for( i=0 ; i<avs->count ; i++ ) {
			for( j=0 ; j<obj_avs.count ; j++ ) {
				if( !strcmp( avs->avp[i].name, obj_avs.avp[j].name ) ) {
					if( !strcmp( avs->avp[i].value, obj_avs.avp[j].value ) ) {
						if( op == 2 ) {
							draw = 1;
							break;
						} else {
							match_count++;
d597 1
d599 3
a601 1
			if( draw ) break;
a602 1
		bu_avs_free( &obj_avs );
@


11.27
log
@db_diradd() was finding offending '/' characters in v4 names beyond the end of the name (<NAMESIZE)
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_lookup.c,v 11.26 2002/01/09 19:57:23 jra Exp $ (BRL)";
d532 66
@


11.26
log
@db_diradd() now handles long names
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_lookup.c,v 11.25 2001/11/08 18:15:11 bparker Exp $ (BRL)";
d265 1
d275 8
a282 3
	if( strchr( name, '/' ) != NULL )  {
		bu_log("db_diradd() object named '%s' is illegal, ignored\n", name );
		return DIR_NULL;
@


11.25
log
@*- mods to ensure null string termination
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_lookup.c,v 11.24 2001/05/17 20:05:23 morrison Exp $ (BRL)";
a252 2
 * Note: This is used only for v4 databases.
 * v5 databases use db5_diradd_handler()
d280 5
a284 1
	bu_vls_strncpy(&local, name, NAMESIZE);
@


11.24
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_lookup.c,v 11.23 2001/04/20 22:29:41 morrison Exp $ (BRL)";
d282 1
a282 1
	bu_vls_strcpy(&local, name);
@


11.23
log
@CONST to const
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_lookup.c,v 11.22 2001/04/20 20:00:13 bparker Exp $ (BRL)";
d238 1
a238 1
			if(rt_g.debug&DEBUG_DB) bu_log("db_lookup(%s) x%x\n", name, dp);
d243 1
a243 1
	if(noisy || rt_g.debug&DEBUG_DB) bu_log("db_lookup(%s) failed: %s does not exist\n", name, name);
d271 1
a271 1
	if(rt_g.debug&DEBUG_DB)  {
@


11.22
log
@*- new function db_dircheck -
   incorporates the behavior from both db_diradd()
   and db5_diradd() to check for the existence
   of "name" while computing the hash once (most
   of the time) and possibly modifying name so that
   it is unique.
*- using db_dircheck in db_diradd and db5_diradd
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_lookup.c,v 11.21 2001/03/27 20:06:41 jra Exp $ (BRL)";
d55 1
a55 1
db_is_directory_non_empty(CONST struct db_i	*dbip)
d75 1
a75 1
CONST struct db_i	*dbip;
d118 1
a118 1
CONST char *str;
d120 1
a120 1
	register CONST unsigned char *s = (unsigned char *)str;
d220 2
a221 2
CONST struct db_i	*dbip;
register CONST char	*name;
d259 1
a259 1
register CONST char	*name;
d404 1
a404 1
CONST char			*newname;
d447 1
a447 1
register CONST struct db_i	*dbip;
d449 1
a449 1
	register CONST struct directory *dp;
@


11.21
log
@db_diradd() now doesn't try to use pointer to minor type for v4 databases
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_lookup.c,v 11.20 2001/03/23 22:05:30 jra Exp $ (BRL)";
d132 70
d267 1
d281 5
a285 36
	/* Compute hash only once */
	headp = &(dbip->dbi_Head[db_dirhash(name)]);

	/* Use inline version of db_lookup here, to save re-hash */
	{
		register char	n0 = name[0];
		register char	n1 = name[1];
		for(dp = *headp; dp != DIR_NULL; dp=dp->d_forw )  {
			register char	*this;
			if(
				n0 == *(this=dp->d_namep)  &&	/* speed */
				n1 == this[1]  &&	/* speed */
				strcmp( name, this ) == 0
			)  {
				/* Name exists in directory already */
				struct bu_vls	local;
				register int	c;

				bu_vls_init( &local );
				for( c = 'A'; c <= 'Z'; c++ )  {
					bu_vls_printf( &local, "%c_%s", c, this );
					if( db_lookup( dbip, bu_vls_addr( &local ), 0 ) == DIR_NULL )
						break;
				}
				if( c > 'Z' )  {
					bu_log("db_diradd: Duplicate of name '%s', ignored\n",
						bu_vls_addr( &local ) );
					return( DIR_NULL );
				}
				bu_log("db_diradd: Duplicate of '%s', given temporary name '%s'\n",
					name, bu_vls_addr( &local ) );
				/* Use recursion to simplify the code */
				return db_diradd( dbip, bu_vls_addr( &local ), laddr, len, flags, ptr );
				bu_vls_free( &local );
			}
		}
d289 1
a289 1
	RT_GET_DIRECTORY( dp, &rt_uniresource );
d291 2
a292 1
	RT_DIR_SET_NAMEP( dp, name );		/* sets d_namep */
@


11.20
log
@Support for major and minor types in directory structure
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/librt/db_lookup.c,v 11.19 2001/01/29 16:17:10 jra Exp $ (BRL)";
d193 1
a193 1
genptr_t		ptr;		/* unused client_data from db_scan() */
d261 4
a264 2
	dp->d_major_type = DB5_MAJORTYPE_BRLCAD;
	dp->d_minor_type = *(unsigned char *)ptr;
@


11.19
log
@dbconcat now works with v5 and v4 databases
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_lookup.c,v 11.18 2000/09/08 05:54:41 mike Exp $ (BRL)";
d261 2
@


11.18
log
@
Modified tree routines to take resource pointer.
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_lookup.c,v 11.17 2000/09/07 05:49:52 mike Exp $ (BRL)";
d225 1
a225 1
				char		local[NAMESIZE+2+2];
d228 1
a228 6
				/* Shift right two characters */
				/* Don't truncate to NAMESIZE, name is just internal */
				strncpy( local+2, name, NAMESIZE );
				local[1] = '_';			/* distinctive separater */
				local[NAMESIZE+2] = '\0';	/* ensure null termination */

d230 2
a231 2
					local[0] = c;
					if( db_lookup( dbip, local, 0 ) == DIR_NULL )
d236 1
a236 1
						local );
d240 1
a240 1
					name, local );
d242 2
a243 1
				return db_diradd( dbip, local, laddr, len, flags, ptr );
@


11.17
log
@
Added helpful comment.
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_lookup.c,v 11.16 2000/09/07 05:34:34 mike Exp $ (BRL)";
d91 20
d253 3
a255 3
	BU_GETSTRUCT( dp, directory );		/* calls bu_malloc */
	dp->d_magic = RT_DIR_MAGIC;
	dp->d_namep = bu_strdup( name );	/* calls bu_malloc */
d262 3
d327 1
a327 1
		bu_free( dp->d_namep, "dir name" );
d329 4
a332 1
		bu_free( (char *)dp, "struct directory" );
d338 1
a338 1
		bu_free( dp->d_namep, "dir name" );
d340 4
a343 2
		bzero( (char *)dp, sizeof(struct directory) );	/* sanity */
		bu_free( (char *)dp, "struct directory" );
d389 2
a390 2
	bu_free( dp->d_namep, "d_namep" );
	dp->d_namep = bu_strdup( newname );
d447 35
@


11.16
log
@
Slightly enhanced db_diradd()
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_lookup.c,v 11.15 2000/08/29 04:23:40 mike Exp $ (BRL)";
d163 2
@


11.15
log
@
Improved speed of db_lookup().
Truncating to NAMESIZE isn't done here any more, to support v5.
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_lookup.c,v 11.14 2000/08/21 02:02:29 butler Exp $ (BRL)";
d160 3
a162 1
 * Add an entry to the directory
d173 1
a173 1
	register struct directory **headp;
a174 1
	char			local[NAMESIZE+2+2];
d183 4
a186 2
	(void)strncpy( local, name, NAMESIZE );	/* Trim the name */
	local[NAMESIZE] = '\0';			/* ensure null termination */
d188 2
a189 2
	if( db_lookup( dbip, local, 0 ) != DIR_NULL )  {
		register int	c;
d191 36
a226 15
		/* Shift right two characters */
		/* Don't truncate to NAMESIZE, name is just internal */
		strncpy( local+2, name, NAMESIZE );
		local[1] = '_';			/* distinctive separater */
		local[NAMESIZE+2] = '\0';	/* ensure null termination */

		for( c = 'A'; c <= 'Z'; c++ )  {
			local[0] = c;
			if( db_lookup( dbip, local, 0 ) == DIR_NULL )
				break;
		}
		if( c > 'Z' )  {
			bu_log("db_diradd: Duplicate of name '%s', ignored\n",
				local );
			return( DIR_NULL );
a227 2
		bu_log("db_diradd: Duplicate of '%s', given temporary name '%s'\n",
			name, local );
d230 2
a231 3
	BU_GETSTRUCT( dp, directory );
	if( dp == DIR_NULL )
		return( DIR_NULL );
d233 1
a233 1
	dp->d_namep = bu_strdup( local );
a236 1
	headp = &(dbip->dbi_Head[db_dirhash(local)]);
@


11.14
log
@Massive compilation warnings eliminated
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_lookup.c,v 11.13 2000/07/10 23:01:27 mike Exp $ (BRL)";
d116 1
a116 1
 * This routine takes a name, trims to NAMESIZE, and looks it up in the
d135 2
a136 1
	char		local[NAMESIZE+2];
a139 5
	if( (int)strlen(name) > NAMESIZE )  {
		(void)strncpy( local, name, NAMESIZE );	/* Trim the name */
		local[NAMESIZE] = '\0';			/* ensure null termination */
		name = local;
	}
d144 2
a145 2
			name[0] == (this=dp->d_namep)[0]  &&	/* speed */
			name[1] == this[1]  &&	/* speed */
@


11.13
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_lookup.c,v 11.12 2000/07/07 03:36:18 mike Exp $ (BRL)";
d55 1
a55 2
db_is_directory_non_empty( dbip )
CONST struct db_i	*dbip;
@


11.12
log
@
Improved table formatting
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_lookup.c,v 11.11 2000/05/02 01:46:03 mike Exp $ (BRL)";
@


11.11
log
@
Changed from rt_list to bu_list
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_lookup.c,v 11.10 2000/01/08 02:30:26 mike Exp $ (BRL)";
d388 2
a389 3
			bu_log("%.8x %.16s %s %s=%.8x use=%.2d len=%.3d nref=%.2d",
				dp, dp->d_namep,
				dp->d_flags & RT_DIR_INMEM ? "ptr" : "d_addr",
d391 1
d393 1
d395 2
a396 2
				dp->d_len,
				dp->d_nref );
@


11.10
log
@
Added db_is_directory_non_empty()
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_lookup.c,v 11.9 1999/12/30 02:58:39 mike Exp $ (BRL)";
d261 1
a261 1
 *  structures have been hung on the d_use_hd rt_list, first.
@


11.9
log
@
Abstracted out db_get_directory_size()
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_lookup.c,v 11.8 1999/12/29 23:23:09 mike Exp $ (BRL)";
d47 23
d76 1
a76 1
struct db_i	*dbip;
@


11.8
log
@
db_scan() got a client_data argument, which
db_diradd() needed to learn to ignore.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_lookup.c,v 11.7 1999/11/26 21:46:44 mike Exp $ (BRL)";
d46 21
@


11.7
log
@
Lint cleanups
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_lookup.c,v 11.6 1999/09/21 14:57:48 jra Exp $ (BRL)";
d124 1
a124 1
db_diradd( dbip, name, laddr, len, flags )
d130 1
@


11.6
log
@db_dirdelete() was trying to free an inmem pointer already freed by db_delete().
Added a check to not free NULL pointers.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_lookup.c,v 11.5 1998/03/27 17:20:43 jra Exp $ (BRL)";
d87 1
a87 1
struct db_i		*dbip;
@


11.5
log
@Modified error message from db_lookup.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_lookup.c,v 11.4 1997/12/16 06:09:51 mike Exp jra $ (BRL)";
d236 4
a239 1
		bu_free( dp->d_un.ptr, "db_dirdelete() inmem ptr" );
@


11.4
log
@Ran h/sed4
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_lookup.c,v 11.3 1997/02/05 03:54:44 mike Exp mike $ (BRL)";
d114 1
a114 1
	if(noisy || rt_g.debug&DEBUG_DB) bu_log("db_lookup(%s) failed\n", name);
@


11.3
log
@Added support for in-memory database objects.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /n/vapor/m/cad/librt/RCS/db_lookup.c,v 11.2 1996/09/27 08:27:30 mike Exp mike $ (BRL)";
d239 1
a239 1
		rt_free( dp->d_namep, "dir name" );
d241 1
a241 1
		rt_free( (char *)dp, "struct directory" );
d247 1
a247 1
		rt_free( dp->d_namep, "dir name" );
d250 1
a250 1
		rt_free( (char *)dp, "struct directory" );
d296 1
a296 1
	rt_free( dp->d_namep, "d_namep" );
@


11.2
log
@Converted to using proper routine names for LIBBU and LIBBN routines.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_lookup.c,v 11.1 1995/01/04 09:56:16 mike Rel4_4 mike $ (BRL)";
d173 2
a174 2
	dp->d_addr = laddr;
	dp->d_flags = flags;
d184 26
d234 4
d340 1
a340 1
			bu_log("%.8x %.16s %s addr=%.6x use=%.2d len=%.3d nref=%.2d",
d342 1
@


11.1
log
@Release_4.4
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_lookup.c,v 10.4 94/09/30 16:08:45 mike Exp $ (BRL)";
d109 1
a109 1
			if(rt_g.debug&DEBUG_DB) rt_log("db_lookup(%s) x%x\n", name, dp);
d114 1
a114 1
	if(noisy || rt_g.debug&DEBUG_DB) rt_log("db_lookup(%s) failed\n", name);
d138 1
a138 1
		rt_log("db_diradd(dbip=x%x, name='%s', addr=x%x, len=%d, flags=x%x)\n",
d160 1
a160 1
			rt_log("db_diradd: Duplicate of name '%s', ignored\n",
d164 1
a164 1
		rt_log("db_diradd: Duplicate of '%s', given temporary name '%s'\n",
d168 1
a168 1
	GETSTRUCT( dp, directory );
d172 1
a172 1
	dp->d_namep = rt_strdup( local );
d178 1
a178 1
	RT_LIST_INIT( &dp->d_use_hd );
d267 1
a267 1
	dp->d_namep = rt_strdup( newname );
d291 1
a291 1
	rt_log("db_pr_dir(x%x):  Dump of directory for file %s [%s]\n",
d295 1
a295 1
	rt_log("Title = %s\n", dbip->dbi_title);
d310 1
a310 1
			rt_log("%.8x %.16s %s addr=%.6x use=%.2d len=%.3d nref=%.2d",
d318 1
a318 1
				rt_log(" anim=x%x\n", dp->d_animate );
d320 1
a320 1
				rt_log("\n");
@


10.4
log
@Element d_use_hd needs to be initialized.
Necessary to implement linear-time searching algorithm in
rt_find_identical_solid(), to replace current O((nsolid/128)**2)
algorithm.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_lookup.c,v 10.3 94/08/10 17:52:28 gdurf Exp Locker: mike $ (BRL)";
@


10.3
log
@factored ifdefs
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_lookup.c,v 10.2 1993/04/01 03:48:00 mike Exp gdurf $ (BRL)";
d178 1
d188 3
@


10.2
log
@Modifed to set and check RT_DIR_MAGIC.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_lookup.c,v 10.1 91/10/12 06:40:02 mike Rel4_0 Locker: mike $ (BRL)";
d29 2
d32 3
a34 1
#ifdef BSD
a35 2
#else
#include <string.h>
@


10.1
log
@Release_4.0
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_lookup.c,v 9.7 91/08/30 17:13:01 mike Exp $ (BRL)";
d38 1
a39 1
#include "db.h"
d86 1
a86 1
register char		*name;
d92 1
a92 1
	if( dbip->dbi_magic != DBI_MAGIC )  rt_bomb("db_lookup:  bad dbip\n");
d112 1
a112 3
	if( noisy )
		rt_log("db_lookup:  could not find '%s'\n", name );
	if(rt_g.debug&DEBUG_DB) rt_log("db_lookup(%s) failed\n", name);
d124 1
a124 1
register char		*name;
d133 1
a133 1
	if( dbip->dbi_magic != DBI_MAGIC )  rt_bomb("db_diradd:  bad dbip\n");
d169 1
d198 2
a199 1
	if( dbip->dbi_magic != DBI_MAGIC )  rt_bomb("db_dirdelete:  bad dbip\n");
d234 1
a234 1
char				*newname;
d239 2
a240 1
	if( dbip->dbi_magic != DBI_MAGIC )  rt_bomb("db_rename:  bad dbip\n");
d277 1
a277 1
register struct db_i	*dbip;
d279 1
a279 1
	register struct directory *dp;
d283 1
a283 1
	if( dbip->dbi_magic != DBI_MAGIC )  rt_bomb("db_pr_dir:  bad dbip\n");
@


9.7
log
@strlen returns unsigned
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_lookup.c,v 9.6 91/06/30 23:17:58 mike Exp $ (BRL)";
@


9.6
log
@Changed from rti_headsolid list for all soltab structures,
to RT_DBNHASH different lists, rti_solidheads[].
This permits much faster searching in the parallel treewalking stage.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_lookup.c,v 9.5 90/12/07 20:49:33 mike Exp $ (BRL)";
d94 1
a94 1
	if( strlen(name) > NAMESIZE )  {
@


9.5
log
@When deleting a directory entry, zero it before calling rt_free(),
to mess up applications that might continue using the pointer.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_lookup.c,v 9.4 90/12/07 05:49:44 mike Exp $ (BRL)";
d51 1
a51 1
static int
d53 1
a53 1
char *str;
d55 1
a55 1
	register unsigned char *s = (unsigned char *)str;
@


9.4
log
@In db_diradd(), if a duplicate name is encountered,
it is now given a temporary name, by prefixing.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_lookup.c,v 9.3 90/05/21 14:32:18 mike Exp $ (BRL)";
d213 1
@


9.3
log
@Improved error message, lint.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_lookup.c,v 9.2 89/06/19 17:22:34 phil Exp $ (BRL)";
d85 1
a85 1
register struct db_i	*dbip;
d90 1
a90 1
	static char local[NAMESIZE+2];
d101 1
d103 3
a105 3
			name[0] == dp->d_namep[0]  &&	/* speed */
			name[1] == dp->d_namep[1]  &&	/* speed */
			strcmp( name, dp->d_namep ) == 0
d133 1
a133 2
	struct directory	*dupdp;
	char			local[NAMESIZE+2];
d137 1
a137 3
	if(rt_g.debug&DEBUG_DB) rt_log("db_diradd( x%x, %s, addr=x%x, len=%d, flags=x%x)\n", dbip, name, laddr, len, flags);

	if( (dupdp = db_lookup( dbip, name, 0 )) != DIR_NULL )  {
a139 3
		rt_log("Attempt to duplicate existing entry x%x d_addr=x%x with same name, ignored\n",
			dupdp, dupdp->d_addr );
		return( DIR_NULL );
d142 26
a170 2
	(void)strncpy( local, name, NAMESIZE );	/* Trim the name */
	local[NAMESIZE] = '\0';			/* ensure null termination */
@


9.2
log
@Fixed problem with db_rename()
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: db_lookup.c,v 9.1 89/05/19 05:55:43 phil Locked $ (BRL)";
a90 1
	register int i;
d94 1
a94 1
	if( (i=strlen(name)) > NAMESIZE )  {
d140 3
a142 2
		rt_log("db_diradd( x%x, %s, addr=x%x, len=%d, flags=x%x) duplicates entry x%x d_addr=x%x\n",
			dbip, name, laddr, len, flags,
@


9.1
log
@Release_3.5
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: db_lookup.c,v 1.4 89/05/18 23:38:15 mike Exp $ (BRL)";
d219 1
a219 1
	if( dbip->dbi_magic != DBI_MAGIC )  rt_bomb("db_dirdelete:  bad dbip\n");
d224 1
d230 1
d234 1
a234 1
		return(-1);
d237 1
a242 1
out:
@


1.4
log
@Added extra error checking to db_diradd() to prevent duplicate names.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: db_lookup.c,v 1.3 89/03/06 16:05:38 mike Locked $ (BRL)";
@


1.3
log
@ansii
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: db_lookup.c,v 1.2 88/12/13 02:13:44 mike Locked $ (BRL)";
d133 2
a134 1
	char local[NAMESIZE+2];
d138 8
a145 3
/**
	rt_log("db_diradd( x%x, %s, addr=x%x, len=%d, flags=x%x\n", dbip, name, laddr, len, flags);
**/
@


1.2
log
@Added optional debugging to db_lookup()
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: db_lookup.c,v 1.1 88/12/06 00:09:15 mike Locked $ (BRL)";
d180 1
a180 1
		rt_free( dp, "struct directory" );
d188 1
a188 1
		rt_free( dp, "struct directory" );
@


1.1
log
@Initial revision
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /cad/d/mike/cad/libdb/RCS/lookup.c,v 1.6 88/10/29 23:54:18 mike Exp $ (BRL)";
d41 1
d44 1
d106 2
a107 1
		)
d109 1
d114 1
@
