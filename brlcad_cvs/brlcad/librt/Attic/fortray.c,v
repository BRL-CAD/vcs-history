head	11.14;
access;
symbols
	ansi-20040405-merged:11.10.2.3
	postmerge-20040405-ansi:11.12
	premerge-20040404-ansi:11.11
	postmerge-autoconf:11.11
	autoconf-freeze:11.10.10.2
	premerge-autoconf:11.11
	ansi-20040316-freeze:11.10.2.2
	postmerge-20040315-windows:11.11
	premerge-20040315-windows:11.11
	windows-20040315-freeze:11.10.4.1
	autoconf-20031203:11.10
	autoconf-20031202:11.10
	autoconf-branch:11.10.0.10
	phong-branch:11.10.0.8
	photonmap-branch:11.10.0.6
	rel-6-1-DP:11.10
	windows-branch:11.10.0.4
	rel-6-0-2:11.8
	ansi-branch:11.10.0.2
	rel-6-0-1-branch:11.8.0.2
	hartley-6-0-post:11.9
	hartley-6-0-pre:11.8
	rel-6-0-1:11.8
	rel-6-0:11.8
	rel-5-4:11.6
	offsite-5-3-pre:11.8
	rel-5-3:11.6
	rel-5-2:11.6
	rel-5-1-branch:11.6.0.2
	rel-5-1:11.6
	rel-5-0:11.4
	rel-5-0-beta:11.2
	rel-4-5:11.2
	ctj-4-5-post:11.2
	ctj-4-5-pre:11.2
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.14
date	2004.05.21.18.07.30;	author morrison;	state dead;
branches;
next	11.13;

11.13
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.12;

11.12
date	2004.04.05.08.48.56;	author morrison;	state Exp;
branches;
next	11.11;

11.11
date	2004.02.02.17.39.15;	author morrison;	state Exp;
branches;
next	11.10;

11.10
date	2002.08.20.17.07.58;	author jra;	state Exp;
branches
	11.10.2.1
	11.10.4.1
	11.10.10.1;
next	11.9;

11.9
date	2002.08.15.20.55.10;	author hartley;	state Exp;
branches;
next	11.8;

11.8
date	2000.08.21.02.02.29;	author butler;	state Exp;
branches;
next	11.7;

11.7
date	2000.07.10.23.01.29;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	99.12.30.03.20.55;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	99.12.23.06.00.18;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	99.06.03.00.59.03;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	99.06.03.00.55.47;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	96.03.29.21.50.14;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.56.26;	author mike;	state Rel4_4;
branches;
next	10.2;

10.2
date	94.08.10.20.42.27;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.40.09;	author mike;	state Rel4_0;
branches;
next	1.1;

1.1
date	91.09.23.11.10.55;	author mike;	state Exp;
branches;
next	;

11.10.2.1
date	2002.09.19.18.01.32;	author morrison;	state Exp;
branches;
next	11.10.2.2;

11.10.2.2
date	2003.02.11.03.22.27;	author morrison;	state Exp;
branches;
next	11.10.2.3;

11.10.2.3
date	2004.03.17.21.18.44;	author morrison;	state Exp;
branches;
next	;

11.10.4.1
date	2004.03.11.23.43.36;	author morrison;	state Exp;
branches;
next	;

11.10.10.1
date	2004.02.12.18.37.39;	author erikg;	state Exp;
branches;
next	11.10.10.2;

11.10.10.2
date	2004.03.15.14.07.17;	author erikg;	state Exp;
branches;
next	;


desc
@FORTRAN interface to LIBRT
@


11.14
log
@moved to src/
@
text
@/*
 *			F O R T R A Y . C
 *
 *  A general-purpose set of FORTRAN-callable interface routines to
 *  permit any FORTRAN program to use LIBRT, the ray-tracing library
 *  of the BRL CAD Package.
 *
 *  
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1986-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/fortray.c,v 11.13 2004/05/10 15:30:46 erikg Exp $";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <string.h>
#include "machine.h"
#include "vmath.h"
#include "raytrace.h"

/*
 *  Macro 'F' is used to take the 'C' function name,
 *  and convert it to the convention used for a particular system.
 *  Both lower-case and upper-case alternatives have to be provided
 *  because there is no way to get the C preprocessor to change the
 *  case of a token.
 *
 *  See also the code in ../libplot3/fortran.c
 */
#if CRAY
#	define	F(lc,uc)	uc
#endif
#if defined(apollo) || defined(mips) || defined(aux)
	/* Lower case, with a trailing underscore */
#ifdef __STDC__
#	define	F(lc,uc)	lc ## _
#else
#	define	F(lc,uc)	lc/**/_
#endif
#endif
#if !defined(F)
#	define	F(lc,uc)	lc
#endif

extern struct resource rt_uniresource;	/* From librt/shoot.c */

int			fr_hit(struct application *ap, struct partition *headp, struct seg *segp), fr_miss(struct application *ap);
struct partition	fr_global_head;

/*
 *			F R _ S T R I N G _ C 2 F
 *
 *  Take a null-terminated C string, and place it with space padding
 *  on the right into a FORTRAN string of given length.
 */
void
fr_string_c2f(register char *fstr, register char *cstr, register int flen)
{
	register int	i;
	
	for( i=0; i < flen; i++ )  {
		if( (fstr[i] = cstr[i]) == '\0' )  break;
	}
	for( ; i < flen; i++ )
		fstr[i] = ' ';
}

/*
 *			F R _ S T R I N G _ F 2 C
 *
 *  Take a FORTRAN string with a length, and return a pointer to
 *  null terminated copy of that string in a STATIC buffer.
 */
static char *
fr_string_f2c(char *str, int maxlen)
{
	static char	buf[512];
	int	len;
	int	i;

	len = sizeof(buf)-1;
	buf[len] = '\0';
	if( maxlen < len )  len = maxlen;
	strncpy( buf, str, len );

	/* Remove any trailing blanks */
	for( i=strlen(buf)-1; i >= 0; i-- )  {
		if( buf[i] != ' ' && buf[i] != '\n' )  break;
		buf[i] = '\0';
	}
	return(buf);
}

/*
 *			F R D I R
 *
 *  FORTRAN to RT interface for rt_dirbuild()
 *
 *  XXX NOTE Apollo FORTRAN passes string length as extra (invisible)
 *  argument, by value.  Other systems probably are different.
 *
 *  XXX On some systems, the C standard I/O library may need to be
 *  initialized here (eg, Cray).
 */
void
F(frdir,FRDIR)( rtip, filename, filelen )
struct rt_i	**rtip;
char		*filename;
int		filelen;
{
	char	*file;

	file = fr_string_f2c( filename, filelen );
	*rtip = rt_dirbuild( file, (char *)0, 0 );
}

/*
 *			F R T R E E
 *
 *  Add another top-level tree to the in-core geometry.
 */
void
F(frtree,FRTREE)( fail, rtip, objname, objlen )
int		*fail;
struct rt_i	**rtip;
char		*objname;
int		objlen;
{
	char	*obj;

	obj = fr_string_f2c( objname, objlen );
	*fail = rt_gettree( *rtip, obj );
}

#define CONTEXT_LEN	6	/* Reserve this many FORTRAN Doubles for each */
struct context {
	double		co_vpriv[3];
	struct soltab	*co_stp;
	char		*co_priv;
	int		co_inflip;
};

/*
 *			F R S H O T
 *
 * NOTE that the [0] element here corresponds with the caller's (1) element. 
 */
void
F(frshot,FRSHOT)( nloc, indist, outdist, region_ids, context, rtip, pt, dir )
int		*nloc;		/* input & output */
double		*indist;	/* output only */
double		*outdist;
int		*region_ids;
struct context	*context;
struct rt_i	**rtip;		/* input only */
double		*pt;
double		*dir;
{
	struct application	ap;
	register struct partition *pp;
	int		ret;
	register int	i;

	if( *nloc <= 0 )  {
		bu_log("ERROR frshot: nloc=%d\n", *nloc);
		*nloc = 0;
		return;
	}

	bzero( (char *)&ap, sizeof(ap));
	ap.a_ray.r_pt[X] = pt[0];
	ap.a_ray.r_pt[Y] = pt[1];
	ap.a_ray.r_pt[Z] = pt[2];
	ap.a_ray.r_dir[X] = dir[0];
	ap.a_ray.r_dir[Y] = dir[1];
	ap.a_ray.r_dir[Z] = dir[2];
	VUNITIZE( ap.a_ray.r_dir );
	ap.a_hit = fr_hit;
	ap.a_miss = fr_miss;
	ap.a_level = 0;
	ap.a_onehit = 1;		/* Should be parameter XXX */
	ap.a_resource = &rt_uniresource;
	rt_uniresource.re_magic = RESOURCE_MAGIC;
	ap.a_purpose = "frshot";
	ap.a_rt_i = *rtip;

	/*
	 *  Actually fire the ray
	 *  The list of results will be linked to fr_global_head
	 *  by fr_hit(), for further use below.
	 *
	 *  It is a bit risky to rely on the segment structures
	 *  pointed to by the partition list to still be valid,
	 *  because rt_shootray has already put them back on the
	 *  free segment queue.  However, they will remain unchanged
	 *  until the next call to rt_shootray(), so copying out the
	 *  data here will work fine.
	 */
	ret = rt_shootray( &ap );

	if( ret <= 0 )  {
		/* Signal no hits */
		*nloc = 0;
		return;
	}

	/* Copy hit information from linked list to argument arrays */
	pp = fr_global_head.pt_forw;
	if( pp == &fr_global_head )  {
		*nloc = 0;
		return;
	}
	for( i=0; i < *nloc; i++, pp=pp->pt_forw )  {
		register struct context	*ctp;

		if( pp == &fr_global_head )  break;
		indist[i] = pp->pt_inhit->hit_dist;
		outdist[i] = pp->pt_outhit->hit_dist;
		/* This might instead be reg_regionid ?? */
		region_ids[i] = pp->pt_regionp->reg_bit+1;
		ctp = &context[i];
		ctp->co_stp = pp->pt_inseg->seg_stp;
		VMOVE( ctp->co_vpriv, pp->pt_inhit->hit_vpriv);
		ctp->co_priv = pp->pt_inhit->hit_private;
		ctp->co_inflip = pp->pt_inflip;
	}
	*nloc = i;	/* Will have been incremented above, if successful */

	/* Free linked list storage */
	for( pp = fr_global_head.pt_forw; pp != &fr_global_head;  )  {
		register struct partition *newpp;

		newpp = pp;
		pp = pp->pt_forw;
		FREE_PT(newpp, (&rt_uniresource));
	}
}

int
fr_hit(struct application *ap, struct partition *headp, struct seg *segp)
{
	if( headp->pt_forw == headp )  return(0);

	/* Steal the linked list, hang it off a global header */
	fr_global_head.pt_forw = headp->pt_forw;
	fr_global_head.pt_back = headp->pt_back;
	fr_global_head.pt_back->pt_forw = &fr_global_head;
	fr_global_head.pt_forw->pt_back = &fr_global_head;

	headp->pt_forw = headp->pt_back = headp;
	return(1);
}

int
fr_miss(struct application *ap)
{
	fr_global_head.pt_forw = fr_global_head.pt_back = &fr_global_head;
	return(0);
}
/*
 *			F R N O R M
 *
 *  Given the data returned by a previous call to frshot(),
 *  compute the surface normal at the entry point to the indicated solid.
 *
 *  In order to save storage, and copying time, frshot() saved only
 *  the minimum amount of data required.  Here, the hit and xray
 *  structures are reconstructed, suitable for passing to RT_HIT_NORM.
 */
void
F(frnorm,FRNORM)( normal, index, indist, context, pt, dir )
double		*normal;	/* output only */
int		*index;		/* input only */
double		*indist;
struct context	*context;
double		*pt;
double		*dir;
{
	register struct context	*ctp;
	struct hit	hit;
#if 0
	struct xray	ray;
#endif
	struct soltab	*stp;
	register int	i;
	
	i = *index-1;		/* Selects which inhit is used */

#if 0
	/* Reconstruct the ray structure */
	ray.r_pt[X] = pt[0];
	ray.r_pt[Y] = pt[1];
	ray.r_pt[Z] = pt[2];
	ray.r_dir[X] = dir[0];
	ray.r_dir[Y] = dir[1];
	ray.r_dir[Z] = dir[2];
	/* Unitize r_dir? */
#endif

	/* Reconstruct the hit structure */
	hit.hit_dist = indist[i];
	ctp = &context[i];
	stp = ctp->co_stp;
	VMOVE( hit.hit_vpriv, ctp->co_vpriv );
	hit.hit_private = ctp->co_priv;
	
#if 0
	RT_HIT_NORMAL( normal, &hit, stp, &ray, ctp->co_inflip );
#else
	/* The new macro doesn't use ray argument */
	RT_HIT_NORMAL( normal, &hit, stp, NULL, ctp->co_inflip );
#endif
}

/*
 *			F R N R E G
 *
 *  Return the number of regions that exist in the model
 */
void
F(frnreg,FRNREG)( nreg, rtip )
int		*nreg;
struct rt_i	**rtip;
{
	*nreg = (*rtip)->nregions;
}

/*
 *			F R N A M E
 *
 *  Given a region number (range 1..nregions), return the
 *  right-hand portion of the name in the provided buffer.
 *
 *  XXX buflen is provided "automaticly" on the Apollo.
 */
void
F(frname,FRNAME)( fbuf, region_num, rtip, fbuflen )
char		*fbuf;
int		*region_num;
struct rt_i	**rtip;
int		fbuflen;
{
	register struct region *rp;
	int	i;
	int	len;
	int	offset;
	int	rnum;
	char	buf[512];

	rnum = *region_num-1;
	if( rnum < 0 || rnum > (*rtip)->nregions )  {
		sprintf( buf, "Region id %d out of range, max=%ld",
			*region_num, (long)((*rtip)->nregions) );
		fr_string_c2f( fbuf, buf, fbuflen );
		return;
	}
	for( BU_LIST_FOR( rp, region, &((*rtip)->HeadRegion) ) )  {
		if( rp->reg_bit != rnum )  continue;
		len = strlen( rp->reg_name );
		offset = 0;
		if( len >= fbuflen )  {
			offset = len-(fbuflen+1);
			len -= (fbuflen+1);
		}
		strncpy( fbuf, rp->reg_name+offset, len );
		for( i=offset+len; i < fbuflen; i++ )
			fbuf[i] = ' ';
		return;
	}
	sprintf(fbuf, "Unable to find region %d", *region_num );
	fr_string_c2f( fbuf, buf, fbuflen );
}
@


11.13
log
@change conf.h to a wrapped config.h
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/librt/fortray.c,v 11.12 2004/04/05 08:48:56 morrison Exp $";
@


11.12
log
@merge of ansi-6-0-branch into HEAD
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header$";
d25 5
a29 1
#include "conf.h"
@


11.11
log
@update copyright to include span through 2003
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/fortray.c,v 11.10 2002/08/20 17:07:58 jra Exp $";
d59 1
a59 1
int			fr_hit(), fr_miss();
d69 1
a69 4
fr_string_c2f( fstr, cstr, flen )
register char	*fstr;
register char	*cstr;
register int	flen;
d87 1
a87 3
fr_string_f2c( str, maxlen )
char	*str;
int	maxlen;
d252 1
a252 3
fr_hit( ap, headp )
struct application	*ap;
struct partition	*headp;
d267 1
a267 2
fr_miss( ap )
struct application	*ap;
@


11.10
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1986 by the United States Army.
d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/fortray.c,v 11.8 2000/08/21 02:02:29 butler Exp $";
@


11.10.4.1
log
@sync to HEAD...
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/fortray.c,v 11.11 2004/02/02 17:39:15 morrison Exp $";
@


11.10.10.1
log
@merge from HEAD
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/fortray.c,v 11.11 2004/02/02 17:39:15 morrison Exp $";
@


11.10.10.2
log
@merge from head
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/fortray.c,v 11.10.10.1 2004/02/12 18:37:39 erikg Exp $";
@


11.10.2.1
log
@Initial ANSIfication
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/fortray.c,v 11.10 2002/08/20 17:07:58 jra Exp $";
d59 1
a59 1
int			fr_hit(struct application *ap, struct partition *headp), fr_miss(struct application *ap);
d69 4
a72 1
fr_string_c2f(register char *fstr, register char *cstr, register int flen)
d90 3
a92 1
fr_string_f2c(char *str, int maxlen)
d257 3
a259 1
fr_hit(struct application *ap, struct partition *headp)
d274 2
a275 1
fr_miss(struct application *ap)
@


11.10.2.2
log
@added a missing parameter to the hit routine (segment list)
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/fortray.c,v 11.10.2.1 2002/09/19 18:01:32 morrison Exp $";
d59 1
a59 1
int			fr_hit(struct application *ap, struct partition *headp, struct seg *segp), fr_miss(struct application *ap);
d252 1
a252 1
fr_hit(struct application *ap, struct partition *headp, struct seg *segp)
@


11.10.2.3
log
@sync branch with HEAD
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d22 1
a22 1
static const char RCSid[] = "@@(#)$Header$";
@


11.9
log
@Converted from K&R to ANSI C - RFH
@
text
@d59 1
a59 1
int			fr_hit(struct application *ap, struct partition *headp), fr_miss(struct application *ap);
d69 4
a72 1
fr_string_c2f(register char *fstr, register char *cstr, register int flen)
d90 3
a92 1
fr_string_f2c(char *str, int maxlen)
d257 3
a259 1
fr_hit(struct application *ap, struct partition *headp)
d274 2
a275 1
fr_miss(struct application *ap)
@


11.8
log
@Massive compilation warnings eliminated
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/fortray.c,v 11.7 2000/07/10 23:01:29 mike Exp $";
d59 1
a59 1
int			fr_hit(), fr_miss();
d69 1
a69 4
fr_string_c2f( fstr, cstr, flen )
register char	*fstr;
register char	*cstr;
register int	flen;
d87 1
a87 3
fr_string_f2c( str, maxlen )
char	*str;
int	maxlen;
d252 1
a252 3
fr_hit( ap, headp )
struct application	*ap;
struct partition	*headp;
d267 1
a267 2
fr_miss( ap )
struct application	*ap;
@


11.7
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/fortray.c,v 11.6 1999/12/30 03:20:55 mike Exp $";
d28 1
a28 1

@


11.6
log
@
Eliminated compiler warning
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/fortray.c,v 11.5 1999/12/23 06:00:18 mike Exp $";
@


11.5
log
@
struct region is now a bu_list
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/fortray.c,v 11.4 1999/06/03 00:59:03 mike Exp $";
d301 1
d303 1
d309 1
d318 1
d327 1
d329 4
@


11.4
log
@
Slightly better packaging.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/fortray.c,v 11.3 1999/06/03 00:55:47 mike Exp $";
d368 1
a368 1
	for( rp = (*rtip)->HeadRegion; rp != REGION_NULL; rp=rp->reg_forw )  {
@


11.3
log
@
sed4
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/fortray.c,v 11.2 1996/03/29 21:50:14 mike Exp $";
d63 1
a63 1
 *			S T R I N G _ C 2 F
d69 1
a69 1
string_c2f( fstr, cstr, flen )
d84 1
a84 1
 *			S T R I N G _ F 2 C
d90 1
a90 1
string_f2c( str, maxlen )
d94 1
a94 1
	static char	buf[128];
d130 1
a130 1
	file = string_f2c( filename, filelen );
d148 1
a148 1
	obj = string_f2c( objname, objlen );
d359 1
a359 1
	char	buf[128];
d365 1
a365 1
		string_c2f( fbuf, buf, fbuflen );
d382 1
a382 1
	string_c2f( fbuf, buf, fbuflen );
@


11.2
log
@Converted to new RT_HIT_NORMAL macro
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/fortray.c,v 11.1 1995/01/04 09:56:26 mike Rel4_4 mike $";
d182 1
a182 1
		rt_log("ERROR frshot: nloc=%d\n", *nloc);
d363 2
a364 2
		sprintf( buf, "Region id %d out of range, max=%d",
			*region_num, (*rtip)->nregions );
@


11.1
log
@Release_4.4
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/fortray.c,v 10.2 94/08/10 20:42:27 gdurf Exp $";
d152 1
a152 1
#define CONTEXT_LEN	5	/* Reserve 5 FORTRAN Doubles for each */
d157 1
d242 1
d323 1
a323 5
	RT_HIT_NORM( &hit, stp, &ray );
	
	normal[0] = hit.hit_normal[X];
	normal[1] = hit.hit_normal[Y];
	normal[2] = hit.hit_normal[Z];
d347 1
@


10.2
log
@Added include of conf.h
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/fortray.c,v 10.1 1991/10/12 06:40:09 mike Rel4_0 gdurf $";
@


10.1
log
@Release_4.0
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/fortray.c,v 1.1 91/09/23 11:10:55 mike Exp $";
d24 2
@


1.1
log
@Initial revision
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header$";
@
