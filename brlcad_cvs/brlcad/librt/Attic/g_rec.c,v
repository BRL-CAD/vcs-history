head	11.19;
access;
symbols
	ansi-20040405-merged:11.15.2.2
	postmerge-20040405-ansi:11.17
	premerge-20040404-ansi:11.16
	postmerge-autoconf:11.16
	autoconf-freeze:11.15.10.2
	premerge-autoconf:11.16
	ansi-20040316-freeze:11.15.2.1
	postmerge-20040315-windows:11.16
	premerge-20040315-windows:11.16
	windows-20040315-freeze:11.15.4.1
	autoconf-20031203:11.15
	autoconf-20031202:11.15
	autoconf-branch:11.15.0.10
	phong-branch:11.15.0.8
	photonmap-branch:11.15.0.6
	rel-6-1-DP:11.15
	windows-branch:11.15.0.4
	rel-6-0-2:11.13
	ansi-branch:11.15.0.2
	rel-6-0-1-branch:11.13.0.2
	hartley-6-0-post:11.14
	hartley-6-0-pre:11.13
	rel-6-0-1:11.13
	rel-6-0:11.13
	rel-5-4:11.8
	offsite-5-3-pre:11.10
	rel-5-3:11.8
	rel-5-2:11.8
	rel-5-1-branch:11.8.0.2
	rel-5-1:11.8
	rel-5-0:11.5
	rel-5-0-beta:11.5
	rel-4-5:11.2
	ctj-4-5-post:11.2
	ctj-4-5-pre:11.2
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.3
	rel-1-10:4.1
	rt-2:2.1;
locks; strict;
comment	@ * @;


11.19
date	2004.05.21.18.07.31;	author morrison;	state dead;
branches;
next	11.18;

11.18
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.17;

11.17
date	2004.04.05.08.48.57;	author morrison;	state Exp;
branches;
next	11.16;

11.16
date	2004.02.02.17.39.21;	author morrison;	state Exp;
branches;
next	11.15;

11.15
date	2002.08.20.17.08.01;	author jra;	state Exp;
branches
	11.15.2.1
	11.15.4.1
	11.15.10.1;
next	11.14;

11.14
date	2002.08.15.20.55.13;	author hartley;	state Exp;
branches;
next	11.13;

11.13
date	2001.05.17.20.05.25;	author morrison;	state Exp;
branches;
next	11.12;

11.12
date	2001.04.20.22.29.46;	author morrison;	state Exp;
branches;
next	11.11;

11.11
date	2001.03.31.01.57.09;	author morrison;	state Exp;
branches;
next	11.10;

11.10
date	2000.10.18.18.10.34;	author butler;	state Exp;
branches;
next	11.9;

11.9
date	2000.07.10.23.01.34;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	2000.04.12.02.34.35;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	99.11.17.02.42.01;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	99.10.30.03.53.27;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	99.05.27.19.10.41;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	98.10.28.17.16.20;	author jra;	state Exp;
branches;
next	11.3;

11.3
date	98.10.06.19.07.41;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	97.03.27.17.59.21;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.56.55;	author mike;	state Rel4_4;
branches;
next	10.3;

10.3
date	94.08.10.18.38.43;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	94.05.10.23.30.35;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.40.23;	author mike;	state Rel4_0;
branches;
next	9.15;

9.15
date	91.09.20.23.24.08;	author butler;	state Exp;
branches;
next	9.14;

9.14
date	91.09.13.13.18.48;	author mmark;	state Exp;
branches;
next	9.13;

9.13
date	91.06.30.00.52.44;	author mike;	state Exp;
branches;
next	9.12;

9.12
date	91.06.30.00.10.57;	author mike;	state Exp;
branches;
next	9.11;

9.11
date	91.06.22.22.30.32;	author mike;	state Exp;
branches;
next	9.10;

9.10
date	91.05.18.03.01.25;	author mike;	state Exp;
branches;
next	9.9;

9.9
date	91.01.25.21.19.14;	author mike;	state Exp;
branches;
next	9.8;

9.8
date	91.01.25.20.36.05;	author mike;	state Exp;
branches;
next	9.7;

9.7
date	91.01.15.21.03.14;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	90.11.01.06.43.45;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	90.10.15.12.01.01;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	90.10.06.02.05.19;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	90.05.04.08.13.13;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	90.03.14.15.05.55;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.56.23;	author mike;	state Rel3_5;
branches;
next	8.7;

8.7
date	89.04.27.23.08.54;	author phil;	state Exp;
branches;
next	8.6;

8.6
date	89.04.17.17.19.47;	author mike;	state Exp;
branches;
next	8.5;

8.5
date	89.04.11.12.05.53;	author phil;	state Exp;
branches;
next	8.4;

8.4
date	89.04.08.02.48.21;	author mike;	state Exp;
branches;
next	8.3;

8.3
date	89.04.07.19.56.21;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	88.12.15.01.24.21;	author phil;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.31.35;	author mike;	state Rel3_0;
branches;
next	7.3;

7.3
date	88.05.14.00.01.13;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	88.02.06.05.36.44;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.33.56;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.07.56.15;	author mike;	state Rel;
branches;
next	5.2;

5.2
date	87.07.01.17.26.15;	author phil;	state Exp;
branches;
next	5.1;

5.1
date	87.06.24.22.12.02;	author mike;	state Rel;
branches;
next	4.9;

4.9
date	87.05.30.06.04.02;	author phil;	state Exp;
branches;
next	4.8;

4.8
date	87.04.28.00.27.48;	author phil;	state Exp;
branches;
next	4.7;

4.7
date	87.04.07.21.23.11;	author phil;	state Exp;
branches;
next	4.6;

4.6
date	87.04.03.00.11.09;	author phil;	state Exp;
branches;
next	4.5;

4.5
date	87.03.23.23.41.42;	author mike;	state Exp;
branches;
next	4.4;

4.4
date	87.03.10.23.43.00;	author mike;	state Exp;
branches;
next	4.3;

4.3
date	87.02.12.22.11.40;	author mike;	state Exp;
branches;
next	4.2;

4.2
date	87.01.28.21.00.19;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.45.42;	author mike;	state Rel1;
branches;
next	3.8;

3.8
date	86.12.24.08.05.57;	author mike;	state Exp;
branches;
next	3.7;

3.7
date	86.11.26.04.40.04;	author mike;	state Exp;
branches;
next	3.6;

3.6
date	86.11.25.01.35.08;	author mike;	state Exp;
branches;
next	3.5;

3.5
date	86.11.24.23.14.22;	author mike;	state Exp;
branches;
next	3.4;

3.4
date	86.10.10.17.46.07;	author mike;	state Exp;
branches;
next	3.3;

3.3
date	86.08.12.04.16.10;	author mike;	state Exp;
branches;
next	3.2;

3.2
date	86.07.24.06.10.25;	author mike;	state Exp;
branches;
next	3.1;

3.1
date	86.07.11.01.32.24;	author mike;	state Exp;
branches;
next	3.0;

3.0
date	86.06.10.01.33.28;	author mike;	state Exp;
branches;
next	2.3;

2.3
date	86.06.09.21.50.45;	author mike;	state Exp;
branches;
next	2.2;

2.2
date	85.09.05.02.18.17;	author mike;	state Exp;
branches;
next	2.1;

2.1
date	85.08.31.06.05.48;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	85.07.30.05.54.35;	author mike;	state Exp;
branches;
next	;

11.15.2.1
date	2002.09.19.18.01.35;	author morrison;	state Exp;
branches;
next	11.15.2.2;

11.15.2.2
date	2004.03.17.21.18.47;	author morrison;	state Exp;
branches;
next	;

11.15.4.1
date	2004.03.11.23.43.38;	author morrison;	state Exp;
branches;
next	;

11.15.10.1
date	2004.02.12.18.37.41;	author erikg;	state Exp;
branches;
next	11.15.10.2;

11.15.10.2
date	2004.03.15.14.07.20;	author erikg;	state Exp;
branches;
next	;


desc
@Right Eliptical Cylinder routines.
Special case of TGC, separated for speed.
@


11.19
log
@moved to src/
@
text
@/*
 *			G _ R E C . C
 *
 *  Purpose -
 *	Intersect a ray with a Right Eliptical Cylinder.
 *	This is a special (but common) case of the TGC,
 *	which is handled separately.
 *
 *  Algorithm -
 *  
 *  Given V, H, A, and B, there is a set of points on this cylinder
 *  
 *  { (x,y,z) | (x,y,z) is on cylinder }
 *  
 *  Through a series of Affine Transformations, this set of points will be
 *  transformed into a set of points on a unit cylinder located at the origin
 *  with a radius of 1, and a height of +1 along the +Z axis.
 *  
 *  { (x',y',z') | (x',y',z') is on cylinder at origin }
 *  
 *  The transformation from X to X' is accomplished by:
 *  
 *  X' = S(R( X - V ))
 *  
 *  where R(X) =  ( A/(|A|) )
 *  		 (  B/(|B|)  ) . X
 *  		  ( H/(|H|) )
 *  
 *  and S(X) =	 (  1/|A|   0     0   )
 *  		(    0    1/|B|   0    ) . X
 *  		 (   0      0   1/|H| )
 *  
 *  To find the intersection of a line with the surface of the cylinder,
 *  consider the parametric line L:
 *  
 *  	L : { P(n) | P + t(n) . D }
 *  
 *  Call W the actual point of intersection between L and the cylinder.
 *  Let W' be the point of intersection between L' and the unit cylinder.
 *  
 *  	L' : { P'(n) | P' + t(n) . D' }
 *  
 *  W = invR( invS( W' ) ) + V
 *  
 *  Where W' = k D' + P'.
 *  
 *  If Dx' and Dy' are both 0, then there is no hit on the cylinder;
 *  but the end plates need checking.
 *
 *  Line L' hits the infinitely tall unit cylinder at W' when
 *
 *	k**2 + b * k + c = 0
 *
 *  where
 *
 *  b = 2 * ( Dx' * Px' + Dy' * Py' ) / ( Dx'**2 + Dy'**2 )
 *  c = ( ( Px'**2 + Py'**2 ) - r**2 ) / ( Dx'**2 + Dy'**2 )
 *  r = 1.0
 *  
 *  The qudratic formula yields k (which is constant):
 *
 *  k = [ -b +/- sqrt( b**2 - 4 * c ] / 2.0
 *  
 *  Now, D' = S( R( D ) )
 *  and  P' = S( R( P - V ) )
 *  
 *  Substituting,
 *  
 *  W = V + invR( invS[ k *( S( R( D ) ) ) + S( R( P - V ) ) ] )
 *    = V + invR( ( k * R( D ) ) + R( P - V ) )
 *    = V + k * D + P - V
 *    = k * D + P
 *  
 *  Note that ``k'' is constant, and is the same in the formulations
 *  for both W and W'.
 *
 *  The hit at ``k'' is a hit on the height=1 unit cylinder IFF
 *  0 <= Wz' <= 1.
 *  
 *  NORMALS.  Given the point W on the surface of the cylinder,
 *  what is the vector normal to the tangent plane at that point?
 *  
 *  Map W onto the unit cylinder, ie:  W' = S( R( W - V ) ).
 *  
 *  Plane on unit cylinder at W' has a normal vector N' of the same value
 *  as W' in x and y, with z set to zero, ie, (Wx', Wy', 0)
 *  
 *  The plane transforms back to the tangent plane at W, and this
 *  new plane (on the original cylinder) has a normal vector of N, viz:
 *  
 *  N = inverse[ transpose(invR o invS) ] ( N' )
 *    = inverse[ transpose(invS) o transpose(invR) ] ( N' )
 *    = inverse[ inverse(S) o R ] ( N' )
 *    = invR o S ( N' )
 *
 *  Note that the normal vector produced above will not have unit length.
 *
 *  THE END PLATES.
 *
 *  If Dz' == 0, line L' is parallel to the end plates, so there is no hit.
 *
 *  Otherwise, the line L' hits the bottom plate with k = (0 - Pz') / Dz',
 *  and hits the top plate with k = (1 - Pz') / Dz'.
 *
 *  The solution W' is within the end plate IFF
 *
 *	Wx'**2 + Wy'**2 <= 1.0
 *
 *  The normal for a hit on the bottom plate is -Hunit, and
 *  the normal for a hit on the top plate is +Hunit.
 *
 *  Authors -
 *	Edwin O. Davisson	(Analysis)
 *	Michael John Muuss	(Programming)
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1985-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSrec[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/g_rec.c,v 11.18 2004/05/10 15:30:46 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef HAVE_STRING_H
#include <string.h>
#endif
#include <math.h>
#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "rtgeom.h"
#include "./debug.h"

struct rec_specific {
	vect_t	rec_V;		/* Vector to center of base of cylinder  */
	vect_t	rec_Hunit;	/* Unit H vector */
	mat_t	rec_SoR;	/* Scale(Rot(vect)) */
	mat_t	rec_invRoS;	/* invRot(Scale(vect)) */
	vect_t	rec_A;		/* One axis of ellipse */
	vect_t	rec_B;		/* Other axis of ellipse */
	fastf_t	rec_iAsq;	/* 1/MAGSQ(A) */
	fastf_t	rec_iBsq;	/* 1/MAGSQ(B) */
};

/*
 *  			R E C _ P R E P
 *  
 *  Given a pointer to a GED database record, and a transformation matrix,
 *  determine if this is a valid REC,
 *  and if so, precompute various terms of the formulas.
 *  
 *  Returns -
 *  	0	REC is OK
 *  	!0	Error in description
 *  
 *  Implicit return -
 *  	A struct rec_specific is created,
 *	and it's address is stored in
 *  	stp->st_specific for use by rt_rec_shot().
 *	If the TGC is really an REC, stp->st_id is modified to ID_REC.
 */
int
rt_rec_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
{
	struct rt_tgc_internal	*tip;
	register struct rec_specific *rec;
	LOCAL double	magsq_h, magsq_a, magsq_b, magsq_c, magsq_d;
	LOCAL double	mag_h, mag_a, mag_b;
	LOCAL mat_t	R;
	LOCAL mat_t	Rinv;
	LOCAL mat_t	S;
	LOCAL vect_t	invsq;	/* [ 1/(|A|**2), 1/(|B|**2), 1/(|Hv|**2) ] */
	LOCAL vect_t	work;
	LOCAL fastf_t	f;

	tip = (struct rt_tgc_internal *)ip->idb_ptr;
	RT_TGC_CK_MAGIC(tip);

	/* Validate that |H| > 0, compute |A| |B| |C| |D| */
	mag_h = sqrt( magsq_h = MAGSQ( tip->h ) );
	mag_a = sqrt( magsq_a = MAGSQ( tip->a ) );
	mag_b = sqrt( magsq_b = MAGSQ( tip->b ) );
	magsq_c = MAGSQ( tip->c );
	magsq_d = MAGSQ( tip->d );

	/* Check for |H| > 0, |A| > 0, |B| > 0 */
	if( NEAR_ZERO(mag_h, RT_LEN_TOL) || NEAR_ZERO(mag_a, RT_LEN_TOL)
	 || NEAR_ZERO(mag_b, RT_LEN_TOL) )  {
		return(1);		/* BAD, too small */
	}

	/* Make sure that A == C, B == D */
	VSUB2( work, tip->a, tip->c );
	f = MAGSQ( work );
	if( ! NEAR_ZERO(f, 0.0001) )  {
		return(1);		/* BAD, !cylinder */
	}
	VSUB2( work, tip->b, tip->d );
	f = MAGSQ( work );
	if( ! NEAR_ZERO(f, 0.0001) )  {
		return(1);		/* BAD, !cylinder */
	}

	/* Check for A.B == 0, H.A == 0 and H.B == 0 */
	f = VDOT( tip->a, tip->b ) / (mag_a * mag_b);
	if( ! NEAR_ZERO(f, RT_DOT_TOL) )  {
		return(1);		/* BAD */
	}
	f = VDOT( tip->h, tip->a ) / (mag_h * mag_a);
	if( ! NEAR_ZERO(f, RT_DOT_TOL) )  {
		return(1);		/* BAD */
	}
	f = VDOT( tip->h, tip->b ) / (mag_h * mag_b);
	if( ! NEAR_ZERO(f, RT_DOT_TOL) )  {
		return(1);		/* BAD */
	}

	/*
	 *  This TGC is really an REC
	 */
	stp->st_id = ID_REC;		/* "fix" soltab ID */
	stp->st_meth = &rt_functab[ID_REC];

	BU_GETSTRUCT( rec, rec_specific );
	stp->st_specific = (genptr_t)rec;

	VMOVE( rec->rec_Hunit, tip->h );
	VUNITIZE( rec->rec_Hunit );

	VMOVE( rec->rec_V, tip->v );
	VMOVE( rec->rec_A, tip->a );
	VMOVE( rec->rec_B, tip->b );
	rec->rec_iAsq = 1.0/magsq_a;
	rec->rec_iBsq = 1.0/magsq_b;

	VSET( invsq, 1.0/magsq_a, 1.0/magsq_b, 1.0/magsq_h );

	/* Compute R and Rinv matrices */
	MAT_IDN( R );
	f = 1.0/mag_a;
	VSCALE( &R[0], tip->a, f );
	f = 1.0/mag_b;
	VSCALE( &R[4], tip->b, f );
	f = 1.0/mag_h;
	VSCALE( &R[8], tip->h, f );
	bn_mat_trn( Rinv, R );			/* inv of rot mat is trn */

	/* Compute S */
	MAT_IDN( S );
	S[ 0] = sqrt( invsq[0] );
	S[ 5] = sqrt( invsq[1] );
	S[10] = sqrt( invsq[2] );

	/* Compute SoR and invRoS */
	bn_mat_mul( rec->rec_SoR, S, R );
	bn_mat_mul( rec->rec_invRoS, Rinv, S );

	/* Compute bounding sphere and RPP */
	{
		LOCAL fastf_t	dx, dy, dz;	/* For bounding sphere */
		LOCAL vect_t	P, w1;
		LOCAL fastf_t	f, tmp, z;

		/* X */
		VSET( P, 1.0, 0, 0 );		/* bounding plane normal */
		MAT3X3VEC( w1, R, P );		/* map plane into local coord syst */
		/* 1st end ellipse (no Z part) */
		tmp = magsq_a * w1[X] * w1[X] + magsq_b * w1[Y] * w1[Y];
		if( tmp > SMALL )
			f = sqrt(tmp);		/* XY part */
		else
			f = 0;
		stp->st_min[X] = rec->rec_V[X] - f;	/* V.P +/- f */
		stp->st_max[X] = rec->rec_V[X] + f;
		/* 2nd end ellipse */
		z = w1[Z] * mag_h;		/* Z part */
		tmp = magsq_c * w1[X] * w1[X] + magsq_d * w1[Y] * w1[Y];
		if( tmp > SMALL )
			f = sqrt(tmp);		/* XY part */
		else
			f = 0;
		if( rec->rec_V[X] - f + z < stp->st_min[X] )
			stp->st_min[X] = rec->rec_V[X] - f + z;
		if( rec->rec_V[X] + f + z > stp->st_max[X] )
			stp->st_max[X] = rec->rec_V[X] + f + z;

		/* Y */
		VSET( P, 0, 1.0, 0 );		/* bounding plane normal */
		MAT3X3VEC( w1, R, P );		/* map plane into local coord syst */
		/* 1st end ellipse (no Z part) */
		tmp = magsq_a * w1[X] * w1[X] + magsq_b * w1[Y] * w1[Y];
		if( tmp > SMALL )
			f = sqrt(tmp);		/* XY part */
		else
			f = 0;
		stp->st_min[Y] = rec->rec_V[Y] - f;	/* V.P +/- f */
		stp->st_max[Y] = rec->rec_V[Y] + f;
		/* 2nd end ellipse */
		z = w1[Z] * mag_h;		/* Z part */
		tmp = magsq_c * w1[X] * w1[X] + magsq_d * w1[Y] * w1[Y];
		if( tmp > SMALL )
			f = sqrt(tmp);		/* XY part */
		else
			f = 0;
		if( rec->rec_V[Y] - f + z < stp->st_min[Y] )
			stp->st_min[Y] = rec->rec_V[Y] - f + z;
		if( rec->rec_V[Y] + f + z > stp->st_max[Y] )
			stp->st_max[Y] = rec->rec_V[Y] + f + z;

		/* Z */
		VSET( P, 0, 0, 1.0 );		/* bounding plane normal */
		MAT3X3VEC( w1, R, P );		/* map plane into local coord syst */
		/* 1st end ellipse (no Z part) */
		tmp = magsq_a * w1[X] * w1[X] + magsq_b * w1[Y] * w1[Y];
		if( tmp > SMALL )
			f = sqrt(tmp);		/* XY part */
		else
			f = 0;
		stp->st_min[Z] = rec->rec_V[Z] - f;	/* V.P +/- f */
		stp->st_max[Z] = rec->rec_V[Z] + f;
		/* 2nd end ellipse */
		z = w1[Z] * mag_h;		/* Z part */
		tmp = magsq_c * w1[X] * w1[X] + magsq_d * w1[Y] * w1[Y];
		if( tmp > SMALL )
			f = sqrt(tmp);		/* XY part */
		else
			f = 0;
		if( rec->rec_V[Z] - f + z < stp->st_min[Z] )
			stp->st_min[Z] = rec->rec_V[Z] - f + z;
		if( rec->rec_V[Z] + f + z > stp->st_max[Z] )
			stp->st_max[Z] = rec->rec_V[Z] + f + z;

		VSET( stp->st_center,
			(stp->st_max[X] + stp->st_min[X])/2,
			(stp->st_max[Y] + stp->st_min[Y])/2,
			(stp->st_max[Z] + stp->st_min[Z])/2 );

		dx = (stp->st_max[X] - stp->st_min[X])/2;
		f = dx;
		dy = (stp->st_max[Y] - stp->st_min[Y])/2;
		if( dy > f )  f = dy;
		dz = (stp->st_max[Z] - stp->st_min[Z])/2;
		if( dz > f )  f = dz;
		stp->st_aradius = f;
		stp->st_bradius = sqrt(dx*dx + dy*dy + dz*dz);
	}
	return(0);			/* OK */
}

/*
 *  			R E C _ P R I N T
 */
void
rt_rec_print(register const struct soltab *stp)
{
	register const struct rec_specific *rec =
		(struct rec_specific *)stp->st_specific;

	VPRINT("V", rec->rec_V);
	VPRINT("Hunit", rec->rec_Hunit);
	bn_mat_print("S o R", rec->rec_SoR );
	bn_mat_print("invR o S", rec->rec_invRoS );
}

/* hit_surfno is set to one of these */
#define	REC_NORM_BODY	(1)		/* compute normal */
#define	REC_NORM_TOP	(2)		/* copy tgc_N */
#define	REC_NORM_BOT	(3)		/* copy reverse tgc_N */

/*
 *  			R E C _ S H O T
 *  
 *  Intersect a ray with a right elliptical cylinder,
 *  where all constant terms have
 *  been precomputed by rt_rec_prep().  If an intersection occurs,
 *  a struct seg will be acquired and filled in.
 *  
 *  Returns -
 *  	0	MISS
 *	>0	HIT
 */
int
rt_rec_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
{
	register struct rec_specific *rec =
		(struct rec_specific *)stp->st_specific;
	LOCAL vect_t	dprime;		/* D' */
	LOCAL vect_t	pprime;		/* P' */
	LOCAL fastf_t	k1, k2;		/* distance constants of solution */
	LOCAL vect_t	xlated;		/* translated vector */
	LOCAL struct hit hits[4];	/* 4 potential hit points */
	register struct hit *hitp;	/* pointer to hit point */
	int		nhits = 0;	/* Number of hit points */

	hitp = &hits[0];

	/* out, Mat, vect */
	MAT4X3VEC( dprime, rec->rec_SoR, rp->r_dir );
	VSUB2( xlated, rp->r_pt, rec->rec_V );
	MAT4X3VEC( pprime, rec->rec_SoR, xlated );

	if( NEAR_ZERO(dprime[X], SMALL) && NEAR_ZERO(dprime[Y], SMALL) )
		goto check_plates;

	/* Find roots of the equation, using forumla for quadratic w/ a=1 */
	{
		FAST fastf_t	b;		/* coeff of polynomial */
		FAST fastf_t	root;		/* root of radical */
		FAST fastf_t	dx2dy2;

		b = 2 * ( dprime[X]*pprime[X] + dprime[Y]*pprime[Y] ) * 
		   (dx2dy2 = 1 / (dprime[X]*dprime[X] + dprime[Y]*dprime[Y]));
		if( (root = b*b - 4 * dx2dy2 *
		    (pprime[X]*pprime[X] + pprime[Y]*pprime[Y] - 1)) <= 0 )
			goto check_plates;
		root = sqrt(root);

		k1 = (root-b) * 0.5;
		k2 = (root+b) * (-0.5);
	}

	/*
	 *  k1 and k2 are potential solutions to intersection with side.
	 *  See if they fall in range.
	 */
	VJOIN1( hitp->hit_vpriv, pprime, k1, dprime );		/* hit' */
	if( hitp->hit_vpriv[Z] >= 0.0 && hitp->hit_vpriv[Z] <= 1.0 ) {
		hitp->hit_magic = RT_HIT_MAGIC;
		hitp->hit_dist = k1;
		hitp->hit_surfno = REC_NORM_BODY;	/* compute N */
		hitp++; nhits++;
	}

	VJOIN1( hitp->hit_vpriv, pprime, k2, dprime );		/* hit' */
	if( hitp->hit_vpriv[Z] >= 0.0 && hitp->hit_vpriv[Z] <= 1.0 )  {
		hitp->hit_magic = RT_HIT_MAGIC;
		hitp->hit_dist = k2;
		hitp->hit_surfno = REC_NORM_BODY;	/* compute N */
		hitp++; nhits++;
	}

	/*
	 * Check for hitting the end plates.
	 */
check_plates:
	if( nhits < 2  &&  !NEAR_ZERO(dprime[Z], SMALL) )  {
		/* 0 or 1 hits so far, this is worthwhile */
		k1 = -pprime[Z] / dprime[Z];		/* bottom plate */
		k2 = (1.0 - pprime[Z]) / dprime[Z];	/* top plate */

		VJOIN1( hitp->hit_vpriv, pprime, k1, dprime );	/* hit' */
		if( hitp->hit_vpriv[X] * hitp->hit_vpriv[X] +
		    hitp->hit_vpriv[Y] * hitp->hit_vpriv[Y] <= 1.0 )  {
			hitp->hit_magic = RT_HIT_MAGIC;
			hitp->hit_dist = k1;
			hitp->hit_surfno = REC_NORM_BOT;	/* -H */
			hitp++; nhits++;
		}

		VJOIN1( hitp->hit_vpriv, pprime, k2, dprime );	/* hit' */
		if( hitp->hit_vpriv[X] * hitp->hit_vpriv[X] +
		    hitp->hit_vpriv[Y] * hitp->hit_vpriv[Y] <= 1.0 )  {
			hitp->hit_magic = RT_HIT_MAGIC;
			hitp->hit_dist = k2;
			hitp->hit_surfno = REC_NORM_TOP;	/* +H */
			hitp++; nhits++;
		}
	}
	if( nhits == 0 )  return 0;	/* MISS */
	if( nhits == 2 )  {
hit:
		if( hits[0].hit_dist < hits[1].hit_dist )  {
			/* entry is [0], exit is [1] */
			register struct seg *segp;

			RT_GET_SEG(segp, ap->a_resource);
			segp->seg_stp = stp;
			segp->seg_in = hits[0];		/* struct copy */
			segp->seg_out = hits[1];	/* struct copy */
			BU_LIST_INSERT( &(seghead->l), &(segp->l) );
		} else {
			/* entry is [1], exit is [0] */
			register struct seg *segp;

			RT_GET_SEG(segp, ap->a_resource);
			segp->seg_stp = stp;
			segp->seg_in = hits[1];		/* struct copy */
			segp->seg_out = hits[0];	/* struct copy */
			BU_LIST_INSERT( &(seghead->l), &(segp->l) );
		}
		return 2;			/* HIT */
	}
	if( nhits == 1 )  {
		if( hits[0].hit_surfno != REC_NORM_BODY )
			bu_log("rt_rec_shot(%s): 1 intersection with end plate?\n", stp->st_name );
		/*
		 *  Ray is tangent to body of cylinder,
		 *  or a single hit on on an end plate (??)
		 *  This could be considered a MISS,
		 *  but to signal the condition, return 0-thickness hit.
		 */
		hits[1] = hits[0];	/* struct copy */
		nhits++;
		goto hit;
	}
	if( nhits == 3 )  {
		fastf_t tol_dist = ap->a_rt_i->rti_tol.dist;
		/*
		 *  Check for case where two of the three hits
		 *  have the same distance, e.g. hitting at the rim.
		 */
		k1 = hits[0].hit_dist - hits[1].hit_dist;
		if( NEAR_ZERO( k1, tol_dist ) )  {
			if(RT_G_DEBUG&DEBUG_ARB8)bu_log("rt_rec_shot(%s): 3 hits, collapsing 0&1\n", stp->st_name);
			hits[1] = hits[2];	/* struct copy */
			nhits--;
			goto hit;
		}
		k1 = hits[1].hit_dist - hits[2].hit_dist;
		if( NEAR_ZERO( k1, tol_dist ) )  {
			if(RT_G_DEBUG&DEBUG_ARB8)bu_log("rt_rec_shot(%s): 3 hits, collapsing 1&2\n", stp->st_name);
			nhits--;
			goto hit;
		}
	}
	/*  nhits >= 3 */
	bu_log("rt_rec_shot(%s): %d unique hits?!?  %g, %g, %g, %g\n",
		stp->st_name, nhits,
		hits[0].hit_dist,
		hits[1].hit_dist,
		hits[2].hit_dist,
		hits[3].hit_dist);

	/* count just the first two, to have something */
	goto hit;
}

#define SEG_MISS(SEG)		(SEG).seg_stp=(struct soltab *) 0;	
/*
 *			R E C _ V S H O T
 *
 *  This is the Becker vector version
 */
void
rt_rec_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		  	       /* Number of ray/object pairs */
                  	    
{
	register int    i;
	register struct rec_specific *rec;
	LOCAL vect_t	dprime;		/* D' */
	LOCAL vect_t	pprime;		/* P' */
	LOCAL fastf_t	k1, k2;		/* distance constants of solution */
	LOCAL vect_t	xlated;		/* translated vector */
	LOCAL struct hit hits[3];	/* 4 potential hit points */
	register struct hit *hitp;	/* pointer to hit point */
	FAST fastf_t	b;		/* coeff of polynomial */
	FAST fastf_t	root;		/* root of radical */
	FAST fastf_t	dx2dy2;

	/* for each ray/right_eliptical_cylinder pair */
#	include "noalias.h"
	for(i = 0; i < n; i++){
#if !CRAY /* XXX currently prevents vectorization on cray */
	 	if (stp[i] == 0) continue; /* stp[i] == 0 signals skip ray */
#endif

		rec = (struct rec_specific *)stp[i]->st_specific;
		hitp = &hits[0];

		/* out, Mat, vect */
		MAT4X3VEC( dprime, rec->rec_SoR, rp[i]->r_dir );
		VSUB2( xlated, rp[i]->r_pt, rec->rec_V );
		MAT4X3VEC( pprime, rec->rec_SoR, xlated );

		if( NEAR_ZERO(dprime[X], SMALL) && NEAR_ZERO(dprime[Y], SMALL) )
			goto check_plates;

		/* Find roots of eqn, using forumla for quadratic w/ a=1 */
		b = 2 * ( dprime[X]*pprime[X] + dprime[Y]*pprime[Y] ) * 
		   (dx2dy2 = 1 / (dprime[X]*dprime[X] + dprime[Y]*dprime[Y]));
		if( (root = b*b - 4 * dx2dy2 *
		    (pprime[X]*pprime[X] + pprime[Y]*pprime[Y] - 1)) <= 0 )
			goto check_plates;

		root = sqrt(root);
		k1 = (root-b) * 0.5;
		k2 = (root+b) * (-0.5);

		/*
		 *  k1 and k2 are potential solutions to intersection with side.
		 *  See if they fall in range.
		 */
		VJOIN1( hitp->hit_vpriv, pprime, k1, dprime );	/* hit' */
		if( hitp->hit_vpriv[Z] >= 0.0 && hitp->hit_vpriv[Z] <= 1.0 ) {
			hitp->hit_dist = k1;
			hitp->hit_surfno = REC_NORM_BODY;	/* compute N */
			hitp++;
		}

		VJOIN1( hitp->hit_vpriv, pprime, k2, dprime );		/* hit' */
		if( hitp->hit_vpriv[Z] >= 0.0 && hitp->hit_vpriv[Z] <= 1.0 )  {
			hitp->hit_dist = k2;
			hitp->hit_surfno = REC_NORM_BODY;	/* compute N */
			hitp++;
		}

		/*
		 * Check for hitting the end plates.
		 */
check_plates:
		if( hitp < &hits[2]  &&  !NEAR_ZERO(dprime[Z], SMALL) )  {
			/* 0 or 1 hits so far, this is worthwhile */
			k1 = -pprime[Z] / dprime[Z];	/* bottom plate */
			k2 = (1.0 - pprime[Z]) / dprime[Z];	/* top plate */

			VJOIN1( hitp->hit_vpriv, pprime, k1, dprime );/* hit' */
			if( hitp->hit_vpriv[X] * hitp->hit_vpriv[X] +
			    hitp->hit_vpriv[Y] * hitp->hit_vpriv[Y] <= 1.0 )  {
				hitp->hit_dist = k1;
				hitp->hit_surfno = REC_NORM_BOT;	/* -H */
				hitp++;
			}

			VJOIN1( hitp->hit_vpriv, pprime, k2, dprime );/* hit' */
			if( hitp->hit_vpriv[X] * hitp->hit_vpriv[X] +
			    hitp->hit_vpriv[Y] * hitp->hit_vpriv[Y] <= 1.0 )  {
				hitp->hit_dist = k2;
				hitp->hit_surfno = REC_NORM_TOP;	/* +H */
				hitp++;
			}
		}

		if( hitp != &hits[2] ) {
			SEG_MISS(segp[i]);		/* MISS */
		} else {
			segp[i].seg_stp = stp[i];

			if( hits[0].hit_dist < hits[1].hit_dist )  {
				/* entry is [0], exit is [1] */
				VMOVE(segp[i].seg_in.hit_vpriv, hits[0].hit_vpriv);
				segp[i].seg_in.hit_dist = hits[0].hit_dist;
				segp[i].seg_in.hit_surfno = hits[0].hit_surfno;
				VMOVE(segp[i].seg_out.hit_vpriv, hits[1].hit_vpriv);
				segp[i].seg_out.hit_dist = hits[1].hit_dist;
				segp[i].seg_out.hit_surfno = hits[1].hit_surfno;
			} else {
				/* entry is [1], exit is [0] */
				VMOVE(segp[i].seg_in.hit_vpriv, hits[1].hit_vpriv);
				segp[i].seg_in.hit_dist = hits[1].hit_dist;
				segp[i].seg_in.hit_surfno = hits[1].hit_surfno;
				VMOVE(segp[i].seg_out.hit_vpriv, hits[0].hit_vpriv);
				segp[i].seg_out.hit_dist = hits[0].hit_dist;
				segp[i].seg_out.hit_surfno = hits[0].hit_surfno;
			}
		}
	}
}

/*
 *  			R E C _ N O R M
 *
 *  Given ONE ray distance, return the normal and entry/exit point.
 *  hit_surfno is a flag indicating if normal needs to be computed or not.
 */
void
rt_rec_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
{
	register struct rec_specific *rec =
		(struct rec_specific *)stp->st_specific;

	VJOIN1( hitp->hit_point, rp->r_pt, hitp->hit_dist, rp->r_dir );
	switch( hitp->hit_surfno )  {
	case REC_NORM_BODY:
		/* compute it */
		hitp->hit_vpriv[Z] = 0.0;
		MAT4X3VEC( hitp->hit_normal, rec->rec_invRoS,
			hitp->hit_vpriv );
		VUNITIZE( hitp->hit_normal );
		break;
	case REC_NORM_TOP:
		VMOVE( hitp->hit_normal, rec->rec_Hunit );
		break;
	case REC_NORM_BOT:
		VREVERSE( hitp->hit_normal, rec->rec_Hunit );
		break;
	default:
		bu_log("rt_rec_norm: surfno=%d bad\n", hitp->hit_surfno);
		break;
	}
}

/*
 *			R E C _ C U R V E
 *
 *  Return the "curvature" of the cylinder.  If an endplate,
 *  pick a principle direction orthogonal to the normal, and 
 *  indicate no curvature.  Otherwise, compute curvature.
 *  Normal must have been computed before calling this routine.
 */
void
rt_rec_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
{
	register struct rec_specific *rec =
		(struct rec_specific *)stp->st_specific;
	vect_t	uu;
	fastf_t	ax, bx, q;

	switch( hitp->hit_surfno )  {
	case REC_NORM_BODY:
		/* This could almost certainly be simpler if we used
		 * inverse A rather than inverse A squared, right Ed?
		 */
		VMOVE( cvp->crv_pdir, rec->rec_Hunit );
		VSUB2( uu, hitp->hit_point, rec->rec_V );
		cvp->crv_c1 = 0;
		ax = VDOT( uu, rec->rec_A ) * rec->rec_iAsq;
		bx = VDOT( uu, rec->rec_B ) * rec->rec_iBsq;
		q = sqrt( ax * ax * rec->rec_iAsq + bx * bx * rec->rec_iBsq );
		cvp->crv_c2 = - rec->rec_iAsq * rec->rec_iBsq / (q*q*q);
		break;
	case REC_NORM_TOP:
	case REC_NORM_BOT:
		bn_vec_ortho( cvp->crv_pdir, hitp->hit_normal );
		cvp->crv_c1 = cvp->crv_c2 = 0;
		break;
	default:
		bu_log("rt_rec_curve: bad surfno %d\n", hitp->hit_surfno);
		break;
	}
}

/*
 *  			R E C _ U V
 *  
 *  For a hit on the surface of an REC, return the (u,v) coordinates
 *  of the hit point, 0 <= u,v <= 1.
 *
 *  u is the rotation around the cylinder, and
 *  v is the displacement along H.
 */
void
rt_rec_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
{
	register struct rec_specific *rec =
		(struct rec_specific *)stp->st_specific;
	LOCAL vect_t work;
	LOCAL vect_t pprime;
	FAST fastf_t len;
	FAST fastf_t ratio;

	/* hit_point is on surface;  project back to unit cylinder,
	 * creating a vector from vertex to hit point.
	 */
	VSUB2( work, hitp->hit_point, rec->rec_V );
	MAT4X3VEC( pprime, rec->rec_SoR, work );

	switch( hitp->hit_surfno )  {
	case REC_NORM_BODY:
		/* Skin.  x,y coordinates define rotation.  radius = 1 */
		ratio = pprime[Y];
		if( ratio > 1.0 )
			ratio = 1.0;
		if( ratio < -1.0 )
			ratio = -1.0;
		uvp->uv_u = acos(ratio) * bn_inv2pi;
		uvp->uv_v = pprime[Z];		/* height */
		break;
	case REC_NORM_TOP:
		/* top plate */
		len = sqrt(pprime[X]*pprime[X]+pprime[Y]*pprime[Y]);
		ratio = pprime[Y]/len;
		if( ratio > 1.0 )
			ratio = 1.0;
		if( ratio < -1.0 )
			ratio = -1.0;
		uvp->uv_u = acos(ratio) * bn_inv2pi;
		uvp->uv_v = len;		/* rim v = 1 */
		break;
	case REC_NORM_BOT:
		/* bottom plate */
		len = sqrt(pprime[X]*pprime[X]+pprime[Y]*pprime[Y]);
		ratio = pprime[Y]/len;
		if( ratio > 1.0 )
			ratio = 1.0;
		if( ratio < -1.0 )
			ratio = -1.0;
		uvp->uv_u = acos(ratio) * bn_inv2pi;
		uvp->uv_v = 1 - len;	/* rim v = 0 */
		break;
	}
	/* Handle other half of acos() domain */
	if( pprime[X] < 0 )
		uvp->uv_u = 1.0 - uvp->uv_u;

	if( uvp->uv_u < 0 )  uvp->uv_u = 0;
	else if( uvp->uv_u > 1 )  uvp->uv_u = 1;
	if( uvp->uv_v < 0 )  uvp->uv_v = 0;
	else if( uvp->uv_v > 1 )  uvp->uv_v = 1;

	/* XXX uv_du should be relative to rotation, uv_dv relative to height */
	uvp->uv_du = uvp->uv_dv = 0;
}

/*
 *			R E C _ F R E E
 */
void
rt_rec_free(struct soltab *stp)
{
	register struct rec_specific *rec =
		(struct rec_specific *)stp->st_specific;

	bu_free( (char *)rec, "rec_specific");
}

int
rt_rec_class(void)
{
	return(0);
}

/* plot and tess are handled by g_tgc.c */
/* import, export, ifree, and describe are also handled by g_tgc.c */
@


11.18
log
@change conf.h to a wrapped config.h
@
text
@d126 1
a126 1
static const char RCSrec[] = "@@(#)$Header: /cvs/brlcad/librt/g_rec.c,v 11.17 2004/04/05 08:48:57 morrison Exp $ (BRL)";
@


11.17
log
@merge of ansi-6-0-branch into HEAD
@
text
@d126 1
a126 1
static const char RCSrec[] = "@@(#)$Header$ (BRL)";
d129 5
a133 1
#include "conf.h"
@


11.16
log
@update copyright to include span through 2003
@
text
@d126 1
a126 1
static const char RCSrec[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_rec.c,v 11.15 2002/08/20 17:08:01 jra Exp $ (BRL)";
d171 1
a171 4
rt_rec_prep( stp, ip, rtip )
struct soltab		*stp;
struct rt_db_internal	*ip;
struct rt_i		*rtip;
d362 1
a362 2
rt_rec_print( stp )
register const struct soltab *stp;
d391 1
a391 5
rt_rec_shot( stp, rp, ap, seghead )
struct soltab		*stp;
register struct xray	*rp;
struct application	*ap;
struct seg		*seghead;
d553 6
a558 6
rt_rec_vshot( stp, rp, segp, n, ap )
struct soltab	       *stp[]; /* An array of solid pointers */
struct xray		*rp[]; /* An array of ray pointers */
struct  seg            segp[]; /* array of segs (results returned) */
int		  	    n; /* Number of ray/object pairs */
struct application	*ap;
d678 1
a678 4
rt_rec_norm( hitp, stp, rp )
register struct hit *hitp;
struct soltab *stp;
register struct xray *rp;
d713 1
a713 4
rt_rec_curve( cvp, hitp, stp )
register struct curvature *cvp;
register struct hit *hitp;
struct soltab *stp;
d754 1
a754 5
rt_rec_uv( ap, stp, hitp, uvp )
struct application *ap;
struct soltab *stp;
register struct hit *hitp;
register struct uvcoord *uvp;
d820 1
a820 2
rt_rec_free( stp )
struct soltab *stp;
d829 1
a829 1
rt_rec_class()
@


11.15
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d122 1
a122 1
 *	This software is Copyright (C) 1985 by the United States Army.
d126 1
a126 1
static const char RCSrec[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_rec.c,v 11.13 2001/05/17 20:05:25 morrison Exp $ (BRL)";
@


11.15.4.1
log
@sync to HEAD...
@
text
@d122 1
a122 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d126 1
a126 1
static const char RCSrec[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/g_rec.c,v 11.16 2004/02/02 17:39:21 morrison Exp $ (BRL)";
@


11.15.10.1
log
@merge from HEAD
@
text
@d122 1
a122 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d126 1
a126 1
static const char RCSrec[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_rec.c,v 11.16 2004/02/02 17:39:21 morrison Exp $ (BRL)";
@


11.15.10.2
log
@merge from head
@
text
@d126 1
a126 1
static const char RCSrec[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_rec.c,v 11.15.10.1 2004/02/12 18:37:41 erikg Exp $ (BRL)";
@


11.15.2.1
log
@Initial ANSIfication
@
text
@d126 1
a126 1
static const char RCSrec[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_rec.c,v 11.15 2002/08/20 17:08:01 jra Exp $ (BRL)";
d171 4
a174 1
rt_rec_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
d365 2
a366 1
rt_rec_print(register const struct soltab *stp)
d395 5
a399 1
rt_rec_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
d561 6
a566 6
rt_rec_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		  	       /* Number of ray/object pairs */
                  	    
d686 4
a689 1
rt_rec_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
d724 4
a727 1
rt_rec_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
d768 5
a772 1
rt_rec_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
d838 2
a839 1
rt_rec_free(struct soltab *stp)
d848 1
a848 1
rt_rec_class(void)
@


11.15.2.2
log
@sync branch with HEAD
@
text
@d122 1
a122 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d126 1
a126 1
static const char RCSrec[] = "@@(#)$Header$ (BRL)";
@


11.14
log
@Converted from K&R to ANSI C - RFH
@
text
@d171 4
a174 1
rt_rec_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
d365 2
a366 1
rt_rec_print(register const struct soltab *stp)
d395 5
a399 1
rt_rec_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
d561 6
a566 6
rt_rec_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		  	       /* Number of ray/object pairs */
                  	    
d686 4
a689 1
rt_rec_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
d724 4
a727 1
rt_rec_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
d768 5
a772 1
rt_rec_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
d838 2
a839 1
rt_rec_free(struct soltab *stp)
d848 1
a848 1
rt_rec_class(void)
@


11.13
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d126 1
a126 1
static const char RCSrec[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_rec.c,v 11.12 2001/04/20 22:29:46 morrison Exp $ (BRL)";
d171 1
a171 4
rt_rec_prep( stp, ip, rtip )
struct soltab		*stp;
struct rt_db_internal	*ip;
struct rt_i		*rtip;
d362 1
a362 2
rt_rec_print( stp )
register const struct soltab *stp;
d391 1
a391 5
rt_rec_shot( stp, rp, ap, seghead )
struct soltab		*stp;
register struct xray	*rp;
struct application	*ap;
struct seg		*seghead;
d553 6
a558 6
rt_rec_vshot( stp, rp, segp, n, ap )
struct soltab	       *stp[]; /* An array of solid pointers */
struct xray		*rp[]; /* An array of ray pointers */
struct  seg            segp[]; /* array of segs (results returned) */
int		  	    n; /* Number of ray/object pairs */
struct application	*ap;
d678 1
a678 4
rt_rec_norm( hitp, stp, rp )
register struct hit *hitp;
struct soltab *stp;
register struct xray *rp;
d713 1
a713 4
rt_rec_curve( cvp, hitp, stp )
register struct curvature *cvp;
register struct hit *hitp;
struct soltab *stp;
d754 1
a754 5
rt_rec_uv( ap, stp, hitp, uvp )
struct application *ap;
struct soltab *stp;
register struct hit *hitp;
register struct uvcoord *uvp;
d820 1
a820 2
rt_rec_free( stp )
struct soltab *stp;
d829 1
a829 1
rt_rec_class()
@


11.12
log
@CONST to const
@
text
@d126 1
a126 1
static const char RCSrec[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_rec.c,v 11.11 2001/03/31 01:57:09 morrison Exp $ (BRL)";
d530 1
a530 1
			if(rt_g.debug&DEBUG_ARB8)bu_log("rt_rec_shot(%s): 3 hits, collapsing 0&1\n", stp->st_name);
d537 1
a537 1
			if(rt_g.debug&DEBUG_ARB8)bu_log("rt_rec_shot(%s): 3 hits, collapsing 1&2\n", stp->st_name);
@


11.11
log
@Deprecated bn_mat_idn() and bn_mat_zero(), updated calls to h/vmath.h's MAT_IDN() and MAT_ZERO() performance improved macros.
@
text
@d126 1
a126 1
static const char RCSrec[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_rec.c,v 11.10 2000/10/18 18:10:34 butler Exp $ (BRL)";
d366 1
a366 1
register CONST struct soltab *stp;
d368 1
a368 1
	register CONST struct rec_specific *rec =
@


11.10
log
@Patches for compiling under RedHat 7.0
@
text
@d126 1
a126 1
static const char RCSrec[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_rec.c,v 11.9 2000/07/10 23:01:34 mike Exp $ (BRL)";
d250 1
a250 1
	bn_mat_idn( R );
d260 1
a260 1
	bn_mat_idn( S );
@


11.9
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d126 1
a126 1
static const char RCSrec[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_rec.c,v 11.8 2000/04/12 02:34:35 mike Exp $ (BRL)";
d132 3
@


11.8
log
@
NT port, non-compat4
@
text
@d126 1
a126 1
static char RCSrec[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_rec.c,v 11.7 1999/11/17 02:42:01 mike Exp $ (BRL)";
@


11.7
log
@
Added idb_meth and st_meth pointers to allow direct access to per-solid
methods, C++ style.
@
text
@d126 1
a126 1
static char RCSrec[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_rec.c,v 11.6 1999/10/30 03:53:27 mike Exp $ (BRL)";
d746 1
a746 1
		vec_ortho( cvp->crv_pdir, hitp->hit_normal );
@


11.6
log
@
Added magic numbers for ray, hit, and application structures.
@
text
@d126 1
a126 1
static char RCSrec[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_rec.c,v 11.5 1999/05/27 19:10:41 mike Exp $ (BRL)";
d230 1
@


11.5
log
@
sed4
@
text
@d126 1
a126 1
static char RCSrec[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_rec.c,v 11.4 1998/10/28 17:16:20 jra Exp $ (BRL)";
d440 1
d448 1
d466 1
d475 1
@


11.4
log
@Eliminated a FAST that was causing a problem under Linux.
@
text
@d126 1
a126 1
static char RCSrec[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_rec.c,v 11.3 1998/10/06 19:07:41 mike Exp $ (BRL)";
d231 1
a231 1
	GETSTRUCT( rec, rec_specific );
d246 1
a246 1
	mat_idn( R );
d253 1
a253 1
	mat_trn( Rinv, R );			/* inv of rot mat is trn */
d256 1
a256 1
	mat_idn( S );
d262 2
a263 2
	mat_mul( rec->rec_SoR, S, R );
	mat_mul( rec->rec_invRoS, Rinv, S );
d369 2
a370 2
	mat_print("S o R", rec->rec_SoR );
	mat_print("invR o S", rec->rec_invRoS );
d488 1
a488 1
			RT_LIST_INSERT( &(seghead->l), &(segp->l) );
d497 1
a497 1
			RT_LIST_INSERT( &(seghead->l), &(segp->l) );
d503 1
a503 1
			rt_log("rt_rec_shot(%s): 1 intersection with end plate?\n", stp->st_name );
d522 1
a522 1
			if(rt_g.debug&DEBUG_ARB8)rt_log("rt_rec_shot(%s): 3 hits, collapsing 0&1\n", stp->st_name);
d529 1
a529 1
			if(rt_g.debug&DEBUG_ARB8)rt_log("rt_rec_shot(%s): 3 hits, collapsing 1&2\n", stp->st_name);
d535 1
a535 1
	rt_log("rt_rec_shot(%s): %d unique hits?!?  %g, %g, %g, %g\n",
d702 1
a702 1
		rt_log("rt_rec_norm: surfno=%d bad\n", hitp->hit_surfno);
d745 1
a745 1
		rt_log("rt_rec_curve: bad surfno %d\n", hitp->hit_surfno);
d787 1
a787 1
		uvp->uv_u = acos(ratio) * rt_inv2pi;
d798 1
a798 1
		uvp->uv_u = acos(ratio) * rt_inv2pi;
d809 1
a809 1
		uvp->uv_u = acos(ratio) * rt_inv2pi;
d836 1
a836 1
	rt_free( (char *)rec, "rec_specific");
@


11.3
log
@Fixed bug reported by Alain Gliere <alain.gliere@@cea.fr> due to
there being 3 intersection points.  Reproduce by:

in cil1 rcc 0 0 -15 0 0 30 15
r alu u cil1
g all  alu
mater alu aluminium "" 0 0 255 0

rtshot -p 0. 0. 10. -a 135. 0. -215. TEST.g all
rtshot -p 0. 0. 10.001 -a 135. 0. -215. TEST.g all
@
text
@d126 1
a126 1
static char RCSrec[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_rec.c,v 11.2 1997/03/27 17:59:21 jra Exp $ (BRL)";
d515 1
a515 1
		FAST fastf_t tol_dist = ap->a_rt_i->rti_tol.dist;
@


11.2
log
@UV calculation was not checking for domain errors in call to acos().
@
text
@d126 1
a126 1
static char RCSrec[] = "@@(#)$Header: /m/cad/librt/RCS/g_rec.c,v 11.1 1995/01/04 09:56:55 mike Rel4_4 jra $ (BRL)";
d403 1
a403 1
	LOCAL struct hit hits[3];	/* 4 potential hit points */
d405 1
d442 1
a442 1
		hitp++;
d449 1
a449 1
		hitp++;
d456 1
a456 1
	if( hitp < &hits[2]  &&  !NEAR_ZERO(dprime[Z], SMALL) )  {
d466 1
a466 1
			hitp++;
d474 1
a474 1
			hitp++;
d477 64
a540 2
	if( hitp != &hits[2] )
		return(0);	/* MISS */
d542 2
a543 20
	if( hits[0].hit_dist < hits[1].hit_dist )  {
		/* entry is [0], exit is [1] */
		register struct seg *segp;

		RT_GET_SEG(segp, ap->a_resource);
		segp->seg_stp = stp;
		segp->seg_in = hits[0];		/* struct copy */
		segp->seg_out = hits[1];	/* struct copy */
		RT_LIST_INSERT( &(seghead->l), &(segp->l) );
	} else {
		/* entry is [1], exit is [0] */
		register struct seg *segp;

		RT_GET_SEG(segp, ap->a_resource);
		segp->seg_stp = stp;
		segp->seg_in = hits[1];		/* struct copy */
		segp->seg_out = hits[0];	/* struct copy */
		RT_LIST_INSERT( &(seghead->l), &(segp->l) );
	}
	return(2);			/* HIT */
@


11.1
log
@Release_4.4
@
text
@d126 1
a126 1
static char RCSrec[] = "@@(#)$Header: /m/cad/librt/RCS/g_rec.c,v 10.3 94/08/10 18:38:43 gdurf Exp $ (BRL)";
d726 1
d737 6
a742 1
		uvp->uv_u = acos(pprime[Y]) * rt_inv2pi;
d748 6
a753 1
		uvp->uv_u = acos(pprime[Y]/len) * rt_inv2pi;
d759 6
a764 1
		uvp->uv_u = acos(pprime[Y]/len) * rt_inv2pi;
@


10.3
log
@Added include of conf.h
@
text
@d126 1
a126 1
static char RCSrec[] = "@@(#)$Header: /m/cad/librt/RCS/g_rec.c,v 10.2 1994/05/10 23:30:35 mike Exp gdurf $ (BRL)";
@


10.2
log
@Fixed problem with u,v going out of range.
@
text
@d126 1
a126 1
static char RCSrec[] = "@@(#)$Header: /m/cad/librt/RCS/g_rec.c,v 10.1 91/10/12 06:40:23 mike Rel4_0 Locker: mike $ (BRL)";
d128 2
@


10.1
log
@Release_4.0
@
text
@d126 1
a126 1
static char RCSrec[] = "@@(#)$Header: /m/cad/librt/RCS/g_rec.c,v 9.15 91/09/20 23:24:08 butler Exp $ (BRL)";
d754 6
a759 1
	/* uv_du should be relative to rotation, uv_dv relative to height */
@


9.15
log
@removing fuzz with lint
@
text
@d126 1
a126 1
static char RCSrec[] = "@@(#)$Header: /m/cad/librt/RCS/g_rec.c,v 9.14 91/09/13 13:18:48 mmark Exp $ (BRL)";
@


9.14
log
@changed "x/sqrt(x)" to "sqrt(x)" here and there
@
text
@d126 1
a126 1
static char RCSrec[] = "@@(#)$Header: /m/cad/librt/RCS/g_rec.c,v 9.13 91/06/30 00:52:44 mike Exp $ (BRL)";
d174 1
a174 1
	LOCAL double	mag_h, mag_a, mag_b, mag_c, mag_d;
a177 1
	LOCAL vect_t	Hv, A, B, C, D;
d189 2
a190 2
	mag_c = sqrt( magsq_c = MAGSQ( tip->c ) );
	mag_d = sqrt( magsq_d = MAGSQ( tip->d ) );
@


9.13
log
@Bloody static variables in _prep routine were botching parallel prepping!
@
text
@d126 1
a126 1
static char RCSrec[] = "@@(#)$Header: /m/cad/librt/RCS/g_rec.c,v 9.12 91/06/30 00:10:57 mike Exp $ (BRL)";
d276 1
a276 1
			f = tmp/sqrt(tmp);	/* XY part */
d285 1
a285 1
			f = tmp/sqrt(tmp);	/* XY part */
d299 1
a299 1
			f = tmp/sqrt(tmp);	/* XY part */
d308 1
a308 1
			f = tmp/sqrt(tmp);	/* XY part */
d322 1
a322 1
			f = tmp/sqrt(tmp);	/* XY part */
d331 1
a331 1
			f = tmp/sqrt(tmp);	/* XY part */
@


9.12
log
@Some args to ft_print, ft_import, and ft_export became CONST
@
text
@d126 1
a126 1
static char RCSrec[] = "@@(#)$Header: /m/cad/librt/RCS/g_rec.c,v 9.11 91/06/22 22:30:32 mike Exp $ (BRL)";
d173 9
a181 9
	static double	magsq_h, magsq_a, magsq_b, magsq_c, magsq_d;
	static double	mag_h, mag_a, mag_b, mag_c, mag_d;
	static mat_t	R;
	static mat_t	Rinv;
	static mat_t	S;
	static vect_t	Hv, A, B, C, D;
	static vect_t	invsq;	/* [ 1/(|A|**2), 1/(|B|**2), 1/(|Hv|**2) ] */
	static vect_t	work;
	static fastf_t	f;
@


9.11
log
@Tolerance can be had from ap->a_rt_i->rti_tol, so it is no longer
passed as a parameter on ft_prep, ft_shot, or ft_vshot.
ft_vshot calling sequence also changed to use application structure.
@
text
@d126 1
a126 1
static char RCSrec[] = "@@(#)$Header: /m/cad/librt/RCS/g_rec.c,v 9.10 91/05/18 03:01:25 mike Exp $ (BRL)";
d361 1
a361 1
register struct soltab *stp;
d363 1
a363 1
	register struct rec_specific *rec =
@


9.10
log
@Converted to new tolerance interface
@
text
@d126 1
a126 1
static char RCSrec[] = "@@(#)$Header: /m/cad/librt/RCS/g_rec.c,v 9.9 91/01/25 21:19:14 mike Exp $ (BRL)";
d166 1
a166 1
rt_rec_prep( stp, ip, rtip, tol )
a169 1
CONST struct rt_tol	*tol;
d390 1
a390 1
rt_rec_shot( stp, rp, ap, seghead, tol )
a394 1
CONST struct rt_tol	*tol;
d507 1
a507 1
rt_rec_vshot( stp, rp, segp, n, resp, tol )
d512 1
a512 2
struct resource         *resp; /* pointer to a list of free segs */
CONST struct rt_tol	*tol;
@


9.9
log
@Converted to new function switch table interface,
using separation between internal and external forms of geometry.
@
text
@d126 1
a126 1
static char RCSrec[] = "@@(#)$Header: /m/cad/librt/RCS/g_rec.c,v 9.8 91/01/25 20:36:05 mike Exp $ (BRL)";
d166 1
a166 1
rt_rec_prep( stp, ip, rtip )
d170 1
d391 1
a391 1
rt_rec_shot( stp, rp, ap, seghead )
d396 1
d509 1
a509 1
rt_rec_vshot( stp, rp, segp, n, resp)
d515 1
@


9.8
log
@Added rt_ prefix to _internal structure
@
text
@d126 1
a126 1
static char RCSrec[] = "@@(#)$Header: /m/cad/librt/RCS/g_rec.c,v 9.7 91/01/15 21:03:14 mike Exp $ (BRL)";
a164 1
/* NEW_IF already */
@


9.7
log
@Use tgc_internal structure now, via new import/export interface.
Fixed suspicious code:
<       VMOVE( rec->rec_A, REC_A );
>       VMOVE( rec->rec_A, tip->a );
Formerly was using un-rotated/scaled version of A vector,
yet a few lines later, rec_A is clearly expected to have
the length of the scaled version.
If problems surface, look here first.
@
text
@d126 1
a126 1
static char RCSrec[] = "@@(#)$Header: /m/cad/librt/RCS/g_rec.c,v 9.6 90/11/01 06:43:45 mike Exp $ (BRL)";
d172 1
a172 1
	struct tgc_internal	*tip;
d184 1
a184 1
	tip = (struct tgc_internal *)ip->idb_ptr;
@


9.6
log
@Corrected minor oversight in case statements.
@
text
@d126 1
a126 1
static char RCSrec[] = "@@(#)$Header: /m/cad/librt/RCS/g_rec.c,v 9.5 90/10/15 12:01:01 mike Exp $ (BRL)";
a132 1
#include "db.h"
d134 1
a147 7
#define REC_V	&vec[0*ELEMENTS_PER_VECT]
#define REC_H	&vec[1*ELEMENTS_PER_VECT]
#define REC_A	&vec[2*ELEMENTS_PER_VECT]
#define REC_B	&vec[3*ELEMENTS_PER_VECT]
#define REC_C	&vec[4*ELEMENTS_PER_VECT]
#define REC_D	&vec[5*ELEMENTS_PER_VECT]

d165 1
d167 1
a167 1
rt_rec_prep( stp, rp, rtip )
d169 1
a169 1
union record		*rp;
d172 1
a182 1
	fastf_t		vec[3*6];
d184 2
a185 1
	rt_fastf_float( vec, rp->s.s_values, 6 );
a186 7
	/* Apply rotation to Hv, A,B,C,D */
	MAT4X3VEC( Hv, stp->st_pathmat, REC_H );
	MAT4X3VEC( A, stp->st_pathmat, REC_A );
	MAT4X3VEC( B, stp->st_pathmat, REC_B );
	MAT4X3VEC( C, stp->st_pathmat, REC_C );
	MAT4X3VEC( D, stp->st_pathmat, REC_D );

d188 5
a192 5
	mag_h = sqrt( magsq_h = MAGSQ( Hv ) );
	mag_a = sqrt( magsq_a = MAGSQ( A ) );
	mag_b = sqrt( magsq_b = MAGSQ( B ) );
	mag_c = sqrt( magsq_c = MAGSQ( C ) );
	mag_d = sqrt( magsq_d = MAGSQ( D ) );
d201 1
a201 1
	VSUB2( work, A, C );
d206 1
a206 1
	VSUB2( work, B, D );
d213 1
a213 1
	f = VDOT( A, B ) / (mag_a * mag_b);
d217 1
a217 1
	f = VDOT( Hv, A ) / (mag_h * mag_a);
d221 1
a221 1
	f = VDOT( Hv, B ) / (mag_h * mag_b);
d234 1
a234 1
	VMOVE( rec->rec_Hunit, Hv );
d237 3
a239 6
	{
		register fastf_t *p = REC_V;
		MAT4X3PNT( rec->rec_V, stp->st_pathmat, p );
	}
	VMOVE( rec->rec_A, REC_A );
	VMOVE( rec->rec_B, REC_B );
d248 1
a248 1
	VSCALE( &R[0], A, f );
d250 1
a250 1
	VSCALE( &R[4], B, f );
d252 1
a252 1
	VSCALE( &R[8], Hv, f );
d780 1
@


9.5
log
@Changed from using hit_private to hit_surfno for surface indicator
@
text
@d126 1
a126 1
static char RCSrec[] = "@@(#)$Header: /m/cad/librt/RCS/g_rec.c,v 9.4 90/10/06 02:05:19 mike Exp $ (BRL)";
d658 1
a658 1
	case 0:	/* REC_NORM_BODY */
d665 1
a665 1
	case 1:	/* REC_NORM_TOP */
d668 1
a668 1
	case 2:	/* REC_NORM_BOT */
d697 1
a697 1
	case 0:	/* REC_NORM_BODY */
d709 2
a710 2
	case 1:	/* REC_NORM_TOP */
	case 2:	/* REC_NORM_BOT */
d749 1
a749 1
	case 0:	/* REC_NORM_BODY */
d754 1
a754 1
	case 1:	/* REC_NORM_TOP */
d760 1
a760 1
	case 2:	/* REC_NORM_BOT */
@


9.4
log
@Converted seg structures to use doubly linked lists.
@
text
@d126 1
a126 1
static char RCSrec[] = "@@(#)$Header: /m/cad/librt/RCS/g_rec.c,v 9.3 90/05/04 08:13:13 mike Exp $ (BRL)";
d388 4
a391 4
/* To be clean, hit_private (a genptr_t), is set to one of these */
#define	REC_NORM_BODY	((genptr_t)0)
#define	REC_NORM_TOP	((genptr_t)1)	/* copy tgc_N */
#define	REC_NORM_BOT	((genptr_t)2)	/* copy reverse tgc_N */
d455 1
a455 1
		hitp->hit_private = REC_NORM_BODY;	/* compute N */
d462 1
a462 1
		hitp->hit_private = REC_NORM_BODY;	/* compute N */
d479 1
a479 1
			hitp->hit_private = REC_NORM_BOT;	/* -H */
d487 1
a487 1
			hitp->hit_private = REC_NORM_TOP;	/* +H */
d578 1
a578 1
			hitp->hit_private = REC_NORM_BODY;	/* compute N */
d585 1
a585 1
			hitp->hit_private = REC_NORM_BODY;	/* compute N */
d602 1
a602 1
				hitp->hit_private = REC_NORM_BOT;	/* -H */
d610 1
a610 1
				hitp->hit_private = REC_NORM_TOP;	/* +H */
d624 1
a624 1
				segp[i].seg_in.hit_private = hits[0].hit_private;
d627 1
a627 1
				segp[i].seg_out.hit_private = hits[1].hit_private;
d632 1
a632 1
				segp[i].seg_in.hit_private = hits[1].hit_private;
d635 1
a635 1
				segp[i].seg_out.hit_private = hits[0].hit_private;
d645 1
a645 1
 *  hit_private is a flag indicating if normal needs to be computed or not.
d657 1
a657 1
	switch( (int)(hitp->hit_private) )  {
d672 1
a672 1
		rt_log("rt_rec_norm: bad flag x%x\n", (int)hitp->hit_private);
d696 1
a696 1
	switch( (int)(hitp->hit_private) )  {
d715 1
a715 1
		rt_log("rt_rec_curve: bad flag x%x\n", (int)hitp->hit_private);
d748 1
a748 1
	switch( (int)(hitp->hit_private) )  {
@


9.3
log
@Routines all got rt_ prefixes
@
text
@d126 1
a126 1
static char RCSrec[] = "@@(#)$Header: g_rec.c,v 9.2 90/03/14 15:05:55 mike Locked $ (BRL)";
d403 1
a403 1
 *  	segp	HIT
d405 2
a406 2
struct seg *
rt_rec_shot( stp, rp, ap )
d410 1
d492 1
a492 1
		return(SEG_NULL);	/* MISS */
d498 1
a498 1
		GET_SEG(segp, ap->a_resource);
d502 1
a502 1
		return(segp);			/* HIT */
d507 1
a507 1
		GET_SEG(segp, ap->a_resource);
d511 1
a511 1
		return(segp);			/* HIT */
d513 1
a513 1
	/* NOTREACHED */
a618 1
			segp[i].seg_next = SEG_NULL;
@


9.2
log
@Changed type of st_specific to genptr_t
@
text
@d2 1
a2 1
 *			R E C . C
d126 1
a126 1
static char RCSrec[] = "@@(#)$Header: g_rec.c,v 9.1 89/05/19 05:56:23 mike Locked $ (BRL)";
d169 1
a169 1
 *  	stp->st_specific for use by rec_shot().
d173 1
a173 1
rec_prep( stp, rp, rtip )
d376 1
a376 1
rec_print( stp )
d388 4
a391 2
/* To be clean, hit_private (a char *), is set to one of these */
static char rec_compute[4];
d398 1
a398 1
 *  been precomputed by rec_prep().  If an intersection occurs,
d406 1
a406 1
rec_shot( stp, rp, ap )
d454 1
a454 1
		hitp->hit_private = &rec_compute[0];	/* compute N */
d461 1
a461 1
		hitp->hit_private = &rec_compute[0];	/* compute N */
d478 1
a478 1
			hitp->hit_private = &rec_compute[2];	/* -H */
d486 1
a486 1
			hitp->hit_private = &rec_compute[1];	/* +H */
d522 1
a522 1
rec_vshot( stp, rp, segp, n, resp)
d577 1
a577 1
			hitp->hit_private = &rec_compute[0];	/* compute N */
d584 1
a584 1
			hitp->hit_private = &rec_compute[0];	/* compute N */
d601 1
a601 1
				hitp->hit_private = &rec_compute[2];	/* -H */
d609 1
a609 1
				hitp->hit_private = &rec_compute[1];	/* +H */
d648 1
a648 1
rec_norm( hitp, stp, rp )
d657 2
a658 2
	switch( hitp->hit_private-rec_compute )  {
	case 0:
d665 1
a665 1
	case 1:
d668 1
a668 1
	case 2:
d672 1
a672 1
		rt_log("rec_norm: bad flag x%x\n", (int)hitp->hit_private);
d686 1
a686 1
rec_curve( cvp, hitp, stp )
d696 2
a697 2
	switch( hitp->hit_private-rec_compute )  {
	case 0:
d709 2
a710 2
	case 1:
	case 2:
d715 1
a715 1
		rt_log("rec_curve: bad flag x%x\n", (int)hitp->hit_private);
d730 1
a730 1
rec_uv( ap, stp, hitp, uvp )
d748 2
a749 2
	switch( hitp->hit_private-rec_compute )  {
	case 0:
d754 1
a754 1
	case 1:
d760 1
a760 1
	case 2:
d779 1
a779 1
rec_free( stp )
d789 1
a789 1
rec_class()
d794 1
a794 4
void
rec_plot()
{
}
@


9.1
log
@Release_3.5
@
text
@d126 1
a126 1
static char RCSrec[] = "@@(#)$Header: g_rec.c,v 8.7 89/04/27 23:08:54 phil Exp $ (BRL)";
d244 1
a244 1
	stp->st_specific = (int *)rec;
@


8.7
log
@removed redundant declaration
@
text
@d126 1
a126 1
static char RCSrec[] = "@@(#)$Header: g_rec.c,v 8.6 89/04/17 17:19:47 phil Locked $ (BRL)";
@


8.6
log
@Calling sequence to xxx_prep() shortened from 6 to 3 args.
Database conversion moved into prep routines.
@
text
@d126 1
a126 1
static char RCSrec[] = "@@(#)$Header: g_rec.c,v 8.5 89/04/11 12:05:53 mike Locked $ (BRL)";
a726 2
extern double rt_inv2pi;

@


8.5
log
@removed an unused vector
@
text
@d126 1
a126 1
static char RCSrec[] = "@@(#)$Header: rec.c,v 8.4 89/04/08 02:48:21 phil Locked $ (BRL)";
d173 1
a173 2
rec_prep( vec, stp, mat, rtip )
register fastf_t	*vec;
d175 1
a175 1
matp_t			mat;
d188 1
d190 2
d193 5
a197 5
	MAT4X3VEC( Hv, mat, REC_H );
	MAT4X3VEC( A, mat, REC_A );
	MAT4X3VEC( B, mat, REC_B );
	MAT4X3VEC( C, mat, REC_C );
	MAT4X3VEC( D, mat, REC_D );
d251 1
a251 1
		MAT4X3PNT( rec->rec_V, mat, p );
@


8.4
log
@Includes Dave Becker's vectorized version
@
text
@d126 1
a126 1
static char RCSrec[] = "@@(#)$Header: rec.c,v 8.3 89/04/07 19:56:21 mike Locked $ (BRL)";
a187 1
	static vect_t	temp;
@


8.3
log
@Dave Becker pointed out that sorting k1 and k2 is not necessary,
as a comparison wil be done at the bottom.
@
text
@d126 1
a126 1
static char RCSrec[] = "@@(#)$Header: rec.c,v 8.2 88/12/15 01:24:21 mike Locked $ (BRL)";
d510 126
@


8.2
log
@several toleraces were overly large.  In particular, intersections with the
end plates were getting skipped if you were close to oblique on a large
cylinder.  Moved most of the toleraces out into raytrace.h.
@
text
@d126 1
a126 1
static char RCSrec[] = "@@(#)$Header: rec.c,v 8.1 88/10/05 00:31:35 phil Locked $ (BRL)";
d440 2
a441 5
		if( (k1 = (root-b) * 0.5) > (k2 = (root+b) * (-0.5)) )  {
			root = k2;
			k2 = k1;
			k1 = root;
		}
@


8.1
log
@Release_3.0
@
text
@d126 1
a126 1
static char RCSrec[] = "@@(#)$Header: rec.c,v 7.3 88/05/14 00:01:13 mike Exp $ (BRL)";
d205 4
a208 2
	if( NEAR_ZERO(magsq_h, 0.0001) )  {
		return(1);		/* BAD */
a210 6
	/* Validate that A.B == 0 */
	f = VDOT( A, B ) / (mag_a * mag_b);
	if( ! NEAR_ZERO(f, 0.0001) )  {
		return(1);		/* BAD */
	}

d215 1
a215 1
		return(1);		/* BAD */
d220 6
a227 2

	/* Check for H.A == 0 and H.B == 0 */
d229 1
a229 1
	if( ! NEAR_ZERO(f, 0.0001) )  {
d233 1
a233 1
	if( ! NEAR_ZERO(f, 0.0001) )  {
a236 5
	/* Check for |A| > 0, |B| > 0 */
	if( NEAR_ZERO(mag_a, 0.0001) || NEAR_ZERO(mag_b, 0.0001) )  {
		return(1);		/* BAD */
	}

d290 1
a290 1
		if( tmp > 1.0e-8 )
d299 1
a299 1
		if( tmp > 1.0e-8 )
d313 1
a313 1
		if( tmp > 1.0e-8 )
d322 1
a322 1
		if( tmp > 1.0e-8 )
d336 1
a336 1
		if( tmp > 1.0e-8 )
d345 1
a345 1
		if( tmp > 1.0e-8 )
d424 1
a424 1
	if( NEAR_ZERO(dprime[X], 0.0001) && NEAR_ZERO(dprime[Y], 0.0001) )
d469 1
a469 1
	if( hitp < &hits[2]  &&  !NEAR_ZERO(dprime[Z], 0.0001) )  {
@


7.3
log
@lint fixes
added zero _uv() routines to some modules
@
text
@d126 1
a126 1
static char RCSrec[] = "@@(#)$Header: rec.c,v 7.2 88/02/06 05:36:44 mike Locked $ (BRL)";
@


7.2
log
@rt_orthovec to vec_ortho
@
text
@d126 1
a126 1
static char RCSrec[] = "@@(#)$Header: rec.c,v 7.1 87/11/02 23:33:56 mike Locked $ (BRL)";
d172 1
d379 1
d526 1
d564 1
d610 1
d659 1
d669 1
d672 1
d675 1
@


7.1
log
@Release 2.3
@
text
@d126 1
a126 1
static char RCSrec[] = "@@(#)$Header: rec.c,v 6.1 87/07/11 07:56:15 mike Rel $ (BRL)";
d586 1
a586 1
		rt_orthovec( cvp->crv_pdir, hitp->hit_normal );
@


6.1
log
@Release 2.0
@
text
@d126 1
a126 1
static char RCSrec[] = "@@(#)$Header: rec.c,v 5.2 87/07/01 17:26:15 phil Exp $ (BRL)";
@


5.2
log
@fixed normal computation!
@
text
@d126 1
a126 1
static char RCSrec[] = "@@(#)$Header: rec.c,v 5.1 87/06/24 22:12:02 phil Locked $ (BRL)";
@


5.1
log
@Release 1.24
@
text
@d126 1
a126 1
static char RCSrec[] = "@@(#)$Header: rec.c,v 4.9 87/05/30 06:04:02 phil Exp $ (BRL)";
d536 1
@


4.9
log
@vmath.h name change
@
text
@d126 1
a126 1
static char RCSrec[] = "@@(#)$Header: rec.c,v 4.8 87/04/28 00:27:48 phil Locked $ (BRL)";
@


4.8
log
@changed curve convention
@
text
@d126 1
a126 1
static char RCSrec[] = "@@(#)$Header: rec.c,v 4.7 87/04/07 21:23:11 phil Locked $ (BRL)";
d291 1
a291 1
		MAT3XVEC( w1, R, P );		/* map plane into local coord syst */
d314 1
a314 1
		MAT3XVEC( w1, R, P );		/* map plane into local coord syst */
d337 1
a337 1
		MAT3XVEC( w1, R, P );		/* map plane into local coord syst */
@


4.7
log
@changed curvature to follow current convention
@
text
@d126 1
a126 1
static char RCSrec[] = "@@(#)$Header: rec.c,v 4.6 87/04/03 00:11:09 phil Locked $ (BRL)";
d560 1
a560 1
rec_curve( cvp, hitp, stp, rp )
a563 1
struct xray *rp;
d581 1
a581 6
		cvp->crv_c2 = rec->rec_iAsq * rec->rec_iBsq / (q*q*q);

		if( VDOT( hitp->hit_normal, rp->r_dir ) > 0 )  {
			/* ray strikes surface from inside; make curv negative */
			cvp->crv_c2 = - cvp->crv_c2;
		}
a591 1

@


4.6
log
@new tightest possible bounding RPP code
@
text
@d126 1
a126 1
static char RCSrec[] = "@@(#)$Header: rec.c,v 4.5 87/03/23 23:41:42 phil Locked $ (BRL)";
d583 5
a587 6
		if( VDOT( uu, hitp->hit_normal ) >= 0 )
			break;
		rt_log("rec_curve:  flipping curvature?\n");
		cvp->crv_c1 = -(cvp->crv_c2);
		cvp->crv_c2 = 0;
		VCROSS( cvp->crv_pdir, hitp->hit_normal, rec->rec_Hunit );
@


4.5
log
@New version that supports multiframe animation,
and post-raytrace cleanups.
@
text
@d126 1
a126 1
static char RCSrec[] = "@@(#)$Header: rec.c,v 4.4 87/03/10 23:43:00 mike Exp $ (BRL)";
d285 3
a287 2
		LOCAL fastf_t dx, dy, dz;	/* For bounding sphere */
		LOCAL vect_t temp;
d289 22
a310 7
		/* There are 8 corners to the bounding RPP */
		/* This may not be minimal, but does fully contain the rec */
		VADD2( temp, rec->rec_V, A );
		VADD2( work, temp, B );
		VMINMAX( stp->st_min, stp->st_max, work );	/* V + A + B */
		VSUB2( work, temp, B );
		VMINMAX( stp->st_min, stp->st_max, work );	/* V + A - B */
d312 22
a333 5
		VSUB2( temp, rec->rec_V, A );
		VADD2( work, temp, B );
		VMINMAX( stp->st_min, stp->st_max, work );	/* V - A + B */
		VSUB2( work, temp, B );
		VMINMAX( stp->st_min, stp->st_max, work );	/* V - A - B */
d335 22
a356 12
		VADD3( temp, rec->rec_V, Hv, C );
		VADD2( work, temp, D );
		VMINMAX( stp->st_min, stp->st_max, work );	/* V + H + C + D */
		VSUB2( work, temp, D );
		VMINMAX( stp->st_min, stp->st_max, work );	/* V + H + C - D */

		VADD2( temp, rec->rec_V, Hv );
		VSUB2( temp, temp, C );
		VADD2( work, temp, D );
		VMINMAX( stp->st_min, stp->st_max, work );	/* V + H - C + D */
		VSUB2( work, temp, D );
		VMINMAX( stp->st_min, stp->st_max, work );	/* V + H - C - D */
@


4.4
log
@For Stay, switched 3rd arg to ft_shoot() from resource pointer
(member of application struct) to application struct pointer.
@
text
@d126 1
a126 1
static char RCSrec[] = "@@(#)$Header: rec.c,v 4.3 87/02/12 22:11:40 mike Locked $ (BRL)";
d172 5
a176 4
rec_prep( vec, stp, mat )
register fastf_t *vec;
struct soltab *stp;
matp_t mat;
d613 20
@


4.3
log
@Release 1.20 -- First Formal Release
@
text
@d126 1
a126 1
static char RCSrec[] = "@@(#)$Header: rec.c,v 4.2 87/01/28 21:00:19 mike Exp $ (BRL)";
d362 1
a362 1
rec_shot( stp, rp, res )
d365 1
a365 1
struct resource		*res;
d456 1
a456 1
		GET_SEG(segp, res);
d465 1
a465 1
		GET_SEG(segp, res);
@


4.2
log
@Release 1.16:  added curvature
@
text
@d126 1
a126 1
static char RCSrec[] = "@@(#)$Header: rec.c,v 4.1 86/12/29 03:45:42 mike Locked $ (BRL)";
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d126 1
a126 1
static char RCSrec[] = "@@(#)$Header: rec.c,v 3.8 86/12/24 08:05:57 mike Locked $ (BRL)";
d142 4
d255 4
d506 50
@


3.8
log
@Revised for resource structure.
@
text
@d126 1
a126 1
static char RCSrec[] = "@@(#)$Header: rec.c,v 3.7 86/11/26 04:40:04 mike Exp $ (BRL)";
@


3.7
log
@Fixed grievous typo which flipped normals of end plate in n-2 rev.
@
text
@d126 1
a126 1
static char RCSrec[] = "@@(#)$Header: rec.c,v 3.6 86/11/25 01:35:08 mike Locked $ (BRL)";
d354 4
a357 3
rec_shot( stp, rp )
struct soltab *stp;
register struct xray *rp;
a368 1
	/* ASSERT that MAGNITUDE(rp->r_dir) == 1 */
d448 1
a448 1
		GET_SEG(segp);
d457 1
a457 1
		GET_SEG(segp);
@


3.6
log
@Fixed one additional oversight.
@
text
@d126 1
a126 1
static char RCSrec[] = "@@(#)$Header: rec.c,v 3.5 86/11/24 23:14:22 mike Locked $ (BRL)";
d429 1
a429 1
			hitp->hit_private = &rec_compute[1];	/* H */
d437 1
a437 1
			hitp->hit_private = &rec_compute[2];	/* -H */
@


3.5
log
@Being squeeky clean with hit_private, for the Cray.
@
text
@d126 1
a126 1
static char RCSrec[] = "@@(#)$Header: rec.c,v 3.4 86/10/10 17:46:07 mike Locked $ (BRL)";
d529 1
a529 1
	switch( (int)hitp->hit_private )  {
@


3.4
log
@Neatened, changed to VMINMAX
@
text
@d126 1
a126 1
static char RCSrec[] = "@@(#)$Header: rec.c,v 3.3 86/08/12 04:16:10 mike Exp $ (BRL)";
d338 3
d405 1
a405 1
		hitp->hit_private = (char *)3;	/* compute */
d412 1
a412 1
		hitp->hit_private = (char *)3;		/* compute */
d429 1
a429 1
			hitp->hit_private = (char *)2;	/* -H */
d437 1
a437 1
			hitp->hit_private = (char *)1;	/* H */
d481 2
a482 2
	switch( (int)hitp->hit_private )  {
	case 3:
d495 1
a495 1
		rt_log("rec_norm: bad flag %d\n", (int)hitp->hit_private);
@


3.3
log
@Changed #include directives for use with CC -I convention
@
text
@d126 1
a126 1
static char RCSrec[] = "@@(#)$Header: rec.c,v 3.2 86/07/24 06:10:25 mike Exp $ (BRL)";
a150 2
static void	rec_minmax();

d283 1
a283 1
		rec_minmax( stp, work );	/* V + A + B */
d285 1
a285 1
		rec_minmax( stp, work );	/* V + A - B */
d289 1
a289 1
		rec_minmax( stp, work );	/* V - A + B */
d291 1
a291 1
		rec_minmax( stp, work );	/* V - A - B */
d295 1
a295 1
		rec_minmax( stp, work );	/* V + H + C + D */
d297 1
a297 1
		rec_minmax( stp, work );	/* V + H + C - D */
d302 1
a302 1
		rec_minmax( stp, work );	/* V + H - C + D */
d304 1
a304 1
		rec_minmax( stp, work );	/* V + H - C - D */
d402 1
a402 1
		hitp->hit_private = (char *)0;	/* compute */
d409 1
a409 1
		hitp->hit_private = (char *)0;		/* compute */
a462 16
#define REC_MINMAX(a,b,c)	{if( (ftemp = (c)) < (a) )  a = ftemp;\
			if( ftemp > (b) )  b = ftemp; }

static void
rec_minmax(stp, v)
register struct soltab *stp;
register vectp_t v;
{
	FAST fastf_t ftemp;

	REC_MINMAX( stp->st_min[X], stp->st_max[X], v[X] );
	REC_MINMAX( stp->st_min[Y], stp->st_max[Y], v[Y] );
	REC_MINMAX( stp->st_min[Z], stp->st_max[Z], v[Z] );
}


d479 1
a479 1
	case 0:
d490 3
@


3.2
log
@Added uvcoord support
@
text
@d126 1
a126 1
static char RCSrec[] = "@@(#)$Header: rec.c,v 3.1 86/07/11 01:32:24 mike Exp $ (BRL)";
d131 5
a135 5
#include "../h/machine.h"
#include "../h/vmath.h"
#include "../h/db.h"
#include "../h/raytrace.h"
#include "debug.h"
@


3.1
log
@Cleanups inspired by the crummy compiler on the Cray XMP
@
text
@d126 1
a126 1
static char RCSrec[] = "@@(#)$Header: rec.c,v 3.0 86/06/10 01:33:28 mike Exp $ (BRL)";
d523 2
a524 1
rec_uv( stp, hitp, uvp )
d527 1
a527 1
register fastf_t *uvp;
d544 2
a545 2
		uvp[0] = acos(pprime[Y]) * rt_inv2pi;
		uvp[1] = pprime[Z];		/* height */
d550 2
a551 2
		uvp[0] = acos(pprime[Y]/len) * rt_inv2pi;
		uvp[1] = len;		/* rim v = 1 */
d556 2
a557 2
		uvp[0] = acos(pprime[Y]/len) * rt_inv2pi;
		uvp[1] = 1 - len;	/* rim v = 0 */
d562 4
a565 1
		uvp[0] = 1.0 - uvp[0];
@


3.0
log
@rt/ and librt/ separated,
global datastructures simplified.
@
text
@d126 1
a126 1
static char RCSid[] = "@@(#)$Header: rec.c,v 2.3 86/06/09 21:50:45 mike Exp $ (BRL)";
d144 6
a149 6
#define SP_V	&vec[0*ELEMENTS_PER_VECT]
#define SP_H	&vec[1*ELEMENTS_PER_VECT]
#define SP_A	&vec[2*ELEMENTS_PER_VECT]
#define SP_B	&vec[3*ELEMENTS_PER_VECT]
#define SP_C	&vec[4*ELEMENTS_PER_VECT]
#define SP_D	&vec[5*ELEMENTS_PER_VECT]
d188 5
a192 5
	MAT4X3VEC( Hv, mat, SP_H );
	MAT4X3VEC( A, mat, SP_A );
	MAT4X3VEC( B, mat, SP_B );
	MAT4X3VEC( C, mat, SP_C );
	MAT4X3VEC( D, mat, SP_D );
d201 1
a201 1
	if( NEAR_ZERO(magsq_h) )  {
d207 1
a207 1
	if( ! NEAR_ZERO(f) )  {
d214 1
a214 1
	if( ! NEAR_ZERO(f) )  {
d219 1
a219 1
	if( ! NEAR_ZERO(f) )  {
d225 1
a225 1
	if( ! NEAR_ZERO(f) )  {
d229 1
a229 1
	if( ! NEAR_ZERO(f) )  {
d234 1
a234 1
	if( NEAR_ZERO(mag_a) || NEAR_ZERO(mag_b) )  {
d250 1
a250 1
		register fastf_t *p = SP_V;
d374 1
a374 1
	if( NEAR_ZERO(dprime[X]) && NEAR_ZERO(dprime[Y]) )
d419 1
a419 1
	if( hitp < &hits[2]  &&  !NEAR_ZERO(dprime[Z]) )  {
a446 2
		if( hits[1].hit_dist <= 0 )
			return(SEG_NULL);	/* MISS: behind start pt */
a455 2
		if( hits[0].hit_dist <= 0 )
			return(SEG_NULL);	/* MISS: behind start pt */
d465 1
a465 1
#define MINMAX(a,b,c)	{if( (ftemp = (c)) < (a) )  a = ftemp;\
d475 3
a477 3
	MINMAX( stp->st_min[X], stp->st_max[X], v[X] );
	MINMAX( stp->st_min[Y], stp->st_max[Y], v[Y] );
	MINMAX( stp->st_min[Z], stp->st_max[Z], v[Z] );
d521 1
a521 1
static double inv2pi =  0.15915494309189533619;		/* 1/(pi*2) */
d543 1
a543 1
		uvp[0] = acos(pprime[Y]) * inv2pi;
d549 1
a549 1
		uvp[0] = acos(pprime[Y]/len) * inv2pi;
d555 1
a555 1
		uvp[0] = acos(pprime[Y]/len) * inv2pi;
@


2.3
log
@rt and librt separated
@
text
@d126 1
a126 1
static char RCSid[] = "@@(#)$Header: rec.c,v 2.2 85/09/05 02:18:17 mike Exp $ (BRL)";
@


2.2
log
@Improved handling of normals and texture map generation.
@
text
@d126 1
a126 1
static char RCSid[] = "@@(#)$Header: rec.c,v 2.1 85/08/31 06:05:48 mike Exp $ (BRL)";
d134 1
a134 1
#include "raytrace.h"
@


2.1
log
@Version 2 of RT
@
text
@d126 1
a126 1
static char RCSid[] = "@@(#)$Header: rec.c,v 1.1 85/07/30 05:54:35 mike Exp $ (BRL)";
d404 1
a404 1
		hitp->hit_private = (char *)1;		/* flag */
d411 1
a411 1
		hitp->hit_private = (char *)1;		/* flag */
d428 1
a428 2
			hitp->hit_private = (char *)0;	/* flag */
			VREVERSE( hitp->hit_normal, rec->rec_Hunit ); /* -H */
d436 1
a436 2
			hitp->hit_private = (char *)0;	/* flag */
			VMOVE( hitp->hit_normal, rec->rec_Hunit ); /* H */
d500 3
a502 1
	if( hitp->hit_private == (char *)1 )  {
d506 7
a513 1
	/* Otherwise, normal is already filled in */
d521 1
a521 2
 *  For now, u,v = 0 on the end plates of the REC.
 *  On the skin of the cylinder itself,
d544 7
a550 2
	/* See if this is top or bottom plate */
	if( VEQUAL( hitp->hit_normal, rec->rec_Hunit ) )  {
d555 2
a556 4
		goto out;
	}
	VREVERSE( work, rec->rec_Hunit );
	if( VEQUAL( hitp->hit_normal, work ) )  {
d561 1
a561 1
		goto out;
a562 5

	/* Skin.  x,y coordinates define rotation.  radius = 1 */
	uvp[0] = acos(pprime[Y]) * inv2pi;
	uvp[1] = pprime[Z];		/* height */
out:
@


1.1
log
@Initial revision
@
text
@d126 1
a126 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d130 1
a201 1
		printf("rec(%s):  zero length H vector\n", stp->st_name );
d205 1
a205 1
	/* Validate that A.B == 0, C.D == 0 */
a207 2
		(void)fprintf(stderr,"rec(%s):  A not perpendicular to B\n",
			stp->st_name);
d210 4
a213 1
	f = VDOT( C, D ) / (mag_c * mag_d);
a214 2
		(void)fprintf(stderr,"rec(%s):  C not perpendicular to D\n",
			stp->st_name);
d217 5
a225 2
		(void)fprintf(stderr,"rec(%s):  A not perpendicular to H\n",
			stp->st_name);
a229 2
		(void)fprintf(stderr,"rec(%s):  B not perpendicular to H\n",
			stp->st_name);
a234 2
		(void)fprintf(stderr,"rec(%s):  A or B zero length\n",
			stp->st_name);
a237 14
	/* Make sure that A == C, B == D */
	VSUB2( work, A, C );
	f = MAGSQ( work );
	if( ! NEAR_ZERO(f) )  {
		(void)fprintf(stderr,"rec(%s):  A != C\n", stp->st_name);
		return(1);		/* BAD */
	}
	VSUB2( work, B, D );
	f = MAGSQ( work );
	if( ! NEAR_ZERO(f) )  {
		(void)fprintf(stderr,"rec(%s):  B != D\n", stp->st_name);
		return(1);		/* BAD */
	}

d314 1
d316 1
d318 3
a320 1
		stp->st_radsq = dx*dx + dy*dy + dz*dz;
d359 5
a363 10
	register struct seg *segp;
	static vect_t	dprime;		/* D' */
	static vect_t	pprime;		/* P' */
	static fastf_t	dx2dy2;		/* 1/(D'[x]**2 + D'[y]**2) */
	static fastf_t	b, c;		/* coeff of polynomial */
	static fastf_t	root;		/* root of radical */
	static fastf_t	k1, k2;		/* distance constants of solution */
	static vect_t	xlated;		/* translated vector */
	static point_t	point;		/* hit point */
	static struct hit hits[4];	/* 4 potential hit points */
d377 5
a381 3
	dx2dy2 = 1.0 / (dprime[X] * dprime[X] + dprime[Y] * dprime[Y]);
	b = 2 * ( dprime[X] * pprime[X] + dprime[Y] * pprime[Y] ) * dx2dy2;
	c = ( (pprime[X] * pprime[X] + pprime[Y] * pprime[Y]) - 1.0) * dx2dy2;
d383 6
a388 4
	root = b*b - ( 4 * c );			/* a == 1 */
	if( root < 0 )
		goto check_plates;
	root = sqrt(root);
d390 6
a395 2
	k1 = (-b + root) * 0.5;			/* a == 1 */
	k2 = (-b - root) * 0.5;
d398 2
a399 3
	 * k1 and k2 are potential solutions to intersection with
	 * side, in no particular order.
	 *  Compute exact intersection points, and surface normal.
d401 2
a402 2
	VJOIN1( point, pprime, k1, dprime );		/* hit' */
	if( point[Z] >= 0.0 && point[Z] <= 1.0 ) {
d404 1
a404 3
		VJOIN1( hitp->hit_point, rp->r_pt, k1, rp->r_dir );
		MAT4X3VEC( hitp->hit_normal, rec->rec_invRoS, point );
		VUNITIZE( hitp->hit_normal );
d408 2
a409 2
	VJOIN1( point, pprime, k2, dprime );		/* hit' */
	if( point[Z] >= 0.0 && point[Z] <= 1.0 )  {
d411 1
a411 3
		VJOIN1( hitp->hit_point, rp->r_pt, k2, rp->r_dir );
		MAT4X3VEC( hitp->hit_normal, rec->rec_invRoS, point );
		VUNITIZE( hitp->hit_normal );
d424 3
a426 2
		VJOIN1( point, pprime, k1, dprime );		/* hit' */
		if( point[X] * point[X] + point[Y] * point[Y] <= 1.0 )  {
d428 1
a428 1
			VJOIN1( hitp->hit_point, rp->r_pt, k1, rp->r_dir );
d433 3
a435 2
		VJOIN1( point, pprime, k2, dprime );		/* hit' */
		if( point[X] * point[X] + point[Y] * point[Y] <= 1.0 )  {
d437 1
a437 1
			VJOIN1( hitp->hit_point, rp->r_pt, k2, rp->r_dir );
d442 1
a442 1
	if( hitp == &hits[0] )
a444 11
	if( hitp != &hits[2] )  {
		static struct hit *hp;	/* XXX */
		printf("ERROR: rec(%s):  %d hits??\n", stp->st_name,
			(&hits[0] - hitp) / sizeof(struct hit)   );
		for( hp = &hits[0]; hp < hitp; hp++ )
			hit_print( "?hit?", hp );
		return(SEG_NULL);	/* MISS */
	}
	GET_SEG(segp);
	segp->seg_stp = stp;
	segp->seg_flag = SEG_IN|SEG_OUT;
d447 6
d455 1
d458 6
d466 1
d468 1
a468 1
	return(segp);			/* HIT */
d484 79
@
