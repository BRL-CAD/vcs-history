head	11.17;
access;
symbols
	ansi-20040405-merged:11.13.2.2
	postmerge-20040405-ansi:11.15
	premerge-20040404-ansi:11.14
	postmerge-autoconf:11.14
	autoconf-freeze:11.13.10.2
	premerge-autoconf:11.14
	ansi-20040316-freeze:11.13.2.1
	postmerge-20040315-windows:11.14
	premerge-20040315-windows:11.14
	windows-20040315-freeze:11.13.4.1
	autoconf-20031203:11.13
	autoconf-20031202:11.13
	autoconf-branch:11.13.0.10
	phong-branch:11.13.0.8
	photonmap-branch:11.13.0.6
	rel-6-1-DP:11.13
	windows-branch:11.13.0.4
	rel-6-0-2:11.11
	ansi-branch:11.13.0.2
	rel-6-0-1-branch:11.11.0.2
	hartley-6-0-post:11.12
	hartley-6-0-pre:11.11
	rel-6-0-1:11.11
	rel-6-0:11.11
	rel-5-4:11.8
	offsite-5-3-pre:11.10
	rel-5-3:11.8
	rel-5-2:11.8
	rel-5-1-branch:11.8.0.2
	rel-5-1:11.8
	rel-5-0:11.6
	rel-5-0-beta:11.5
	rel-4-5:11.5
	ctj-4-5-post:11.5
	ctj-4-5-pre:11.5
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.17
date	2004.05.21.18.07.32;	author morrison;	state dead;
branches;
next	11.16;

11.16
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.15;

11.15
date	2004.04.05.08.48.57;	author morrison;	state Exp;
branches;
next	11.14;

11.14
date	2004.02.02.17.39.23;	author morrison;	state Exp;
branches;
next	11.13;

11.13
date	2002.08.20.17.08.04;	author jra;	state Exp;
branches
	11.13.2.1
	11.13.4.1
	11.13.10.1;
next	11.12;

11.12
date	2002.08.15.20.55.15;	author hartley;	state Exp;
branches;
next	11.11;

11.11
date	2001.04.20.22.29.50;	author morrison;	state Exp;
branches;
next	11.10;

11.10
date	2000.08.21.02.02.32;	author butler;	state Exp;
branches;
next	11.9;

11.9
date	2000.07.10.23.01.41;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	2000.04.01.01.43.54;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	99.11.24.21.44.30;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	99.06.03.01.43.36;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	96.10.25.16.22.45;	author jra;	state Exp;
branches;
next	11.4;

11.4
date	96.10.21.02.51.52;	author jra;	state Exp;
branches;
next	11.3;

11.3
date	96.09.27.08.27.30;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	96.09.06.18.33.53;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.57.36;	author mike;	state Rel4_4;
branches;
next	10.23;

10.23
date	95.01.04.08.03.16;	author mike;	state Exp;
branches;
next	10.22;

10.22
date	94.12.30.00.43.59;	author mike;	state Exp;
branches;
next	10.21;

10.21
date	94.09.21.03.50.07;	author mike;	state Exp;
branches;
next	10.20;

10.20
date	94.09.21.03.10.42;	author mike;	state Exp;
branches;
next	10.19;

10.19
date	94.09.16.20.52.35;	author mike;	state Exp;
branches;
next	10.18;

10.18
date	94.09.15.23.53.22;	author mike;	state Exp;
branches;
next	10.17;

10.17
date	94.09.10.05.18.57;	author mike;	state Exp;
branches;
next	10.16;

10.16
date	94.09.10.04.36.47;	author mike;	state Exp;
branches;
next	10.15;

10.15
date	94.09.03.03.01.10;	author mike;	state Exp;
branches;
next	10.14;

10.14
date	94.09.02.19.08.08;	author mike;	state Exp;
branches;
next	10.13;

10.13
date	94.09.02.17.58.23;	author mike;	state Exp;
branches;
next	10.12;

10.12
date	94.09.02.01.14.54;	author mike;	state Exp;
branches;
next	10.11;

10.11
date	94.09.02.00.31.57;	author mike;	state Exp;
branches;
next	10.10;

10.10
date	94.09.01.22.59.58;	author mike;	state Exp;
branches;
next	10.9;

10.9
date	94.08.25.21.35.48;	author mike;	state Exp;
branches;
next	10.8;

10.8
date	94.08.09.19.37.40;	author mike;	state Exp;
branches;
next	10.7;

10.7
date	94.05.05.23.13.21;	author butler;	state Exp;
branches;
next	10.6;

10.6
date	94.05.05.22.24.19;	author butler;	state Exp;
branches;
next	10.5;

10.5
date	94.04.25.02.24.39;	author butler;	state Exp;
branches;
next	10.4;

10.4
date	94.04.25.00.43.22;	author butler;	state Exp;
branches;
next	10.3;

10.3
date	94.01.11.04.24.25;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	93.01.20.20.15.54;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.40.44;	author mike;	state Rel4_0;
branches;
next	1.8;

1.8
date	91.06.23.02.42.09;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	91.06.17.20.42.03;	author butler;	state Exp;
branches;
next	1.6;

1.6
date	91.02.27.22.23.01;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	91.02.07.20.32.36;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	91.02.07.20.00.50;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	91.02.07.00.13.25;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	91.02.06.22.22.11;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	91.02.06.17.22.49;	author mike;	state Exp;
branches;
next	;

11.13.2.1
date	2002.09.19.18.01.39;	author morrison;	state Exp;
branches;
next	11.13.2.2;

11.13.2.2
date	2004.03.17.21.18.52;	author morrison;	state Exp;
branches;
next	;

11.13.4.1
date	2004.03.11.23.43.41;	author morrison;	state Exp;
branches;
next	;

11.13.10.1
date	2004.02.12.18.37.43;	author erikg;	state Exp;
branches;
next	11.13.10.2;

11.13.10.2
date	2004.03.15.14.07.25;	author erikg;	state Exp;
branches;
next	;


desc
@Subroutines to count and re-index NMG data structures
@


11.17
log
@moved to src/
@
text
@/*
 *			N M G _ I N D E X . C
 *
 *  Handle counting and re-indexing of NMG data structures.
 *
 *  Authors -
 *	Michael John Muuss
 *	Lee A. Butler
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1990-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSnmg_index[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/nmg_index.c,v 11.16 2004/05/10 15:30:46 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif


#include <stdio.h>
#include <string.h>
#include <math.h>
#include "externs.h"
#include "machine.h"
#include "vmath.h"
#include "nmg.h"
#include "raytrace.h"

/*
 *			N M G _ I N D E X _ O F _ S T R U C T
 *
 *  Return the structure index number of an arbitrary NMG structure.
 *
 *  Returns -
 *	>=0	index number
 *	 -1	pointed at struct bu_list embedded within NMG structure.
 *	 -2	error:  unknown magic number
 */
int
nmg_index_of_struct(register const long int *p)
{
	switch(*p)  {
	case NMG_MODEL_MAGIC:
		return ((struct model *)p)->index;
	case NMG_REGION_MAGIC:
		return ((struct nmgregion *)p)->index;
	case NMG_REGION_A_MAGIC:
		return ((struct nmgregion_a *)p)->index;
	case NMG_SHELL_MAGIC:
		return ((struct shell *)p)->index;
	case NMG_SHELL_A_MAGIC:
		return ((struct shell_a *)p)->index;
	case NMG_FACEUSE_MAGIC:
		return ((struct faceuse *)p)->index;
	case NMG_FACE_MAGIC:
		return ((struct face *)p)->index;
	case NMG_FACE_G_PLANE_MAGIC:
		return ((struct face_g_plane *)p)->index;
	case NMG_FACE_G_SNURB_MAGIC:
		return ((struct face_g_snurb *)p)->index;
	case NMG_LOOPUSE_MAGIC:
		return ((struct loopuse *)p)->index;
	case NMG_LOOP_MAGIC:
		return ((struct loop *)p)->index;
	case NMG_LOOP_G_MAGIC:
		return ((struct loop_g *)p)->index;
	case NMG_EDGEUSE_MAGIC:
		return ((struct edgeuse *)p)->index;
	case NMG_EDGEUSE2_MAGIC:
		/* Points to l2 inside edgeuse */
		return BU_LIST_MAIN_PTR(edgeuse, p, l2)->index;
	case NMG_EDGE_MAGIC:
		return ((struct edge *)p)->index;
	case NMG_EDGE_G_LSEG_MAGIC:
		return ((struct edge_g_lseg *)p)->index;
	case NMG_EDGE_G_CNURB_MAGIC:
		return ((struct edge_g_cnurb *)p)->index;
	case NMG_VERTEXUSE_MAGIC:
		return ((struct vertexuse *)p)->index;
	case NMG_VERTEXUSE_A_PLANE_MAGIC:
		return ((struct vertexuse_a_plane *)p)->index;
	case NMG_VERTEXUSE_A_CNURB_MAGIC:
		return ((struct vertexuse_a_cnurb *)p)->index;
	case NMG_VERTEX_MAGIC:
		return ((struct vertex *)p)->index;
	case NMG_VERTEX_G_MAGIC:
		return ((struct vertex_g *)p)->index;
	case BU_LIST_HEAD_MAGIC:
		/* indicate special list head encountered */
		return -1;
	}
	/* default */
	bu_log("nmg_index_of_struct: magicp = x%x, magic = x%x\n", p, *p);
	return -2;	/* indicate error */
}

#define NMG_HIGH_BIT	0x80000000

#define NMG_MARK_INDEX(_p)	((_p)->index |= NMG_HIGH_BIT)

#define	NMG_ASSIGN_NEW_INDEX(_p)	\
	{ if( ((_p)->index & NMG_HIGH_BIT) != 0 ) \
		(_p)->index = newindex++; }

/*
 *			N M G _ M A R K _ E D G E _ G
 *
 *  Helper routine
 */
static void
nmg_mark_edge_g(long int *magic_p)
{
	if( !magic_p )  rt_bomb("nmg_mark_edge_g bad magic\n");
	switch( *magic_p )  {
	case NMG_EDGE_G_LSEG_MAGIC:
		{
			struct edge_g_lseg *lseg = (struct edge_g_lseg *)magic_p;
			NMG_MARK_INDEX(lseg);
			return;
		}
	case NMG_EDGE_G_CNURB_MAGIC:
		{
			struct edge_g_cnurb *cnurb = (struct edge_g_cnurb *)magic_p;
			NMG_MARK_INDEX(cnurb);
			return;
		}
	}	
	rt_bomb("nmg_mark_edge_g() unknown magic\n");
}

/*
 *			N M G _ M _ S E T _ H I G H _ B I T
 *
 *  First pass:  just set the high bit on all index words
 *
 *  This is a separate function largely for the benefit of global optimizers,
 *  which tended to blow their brains out on such a large subroutine.
 */
void
nmg_m_set_high_bit(struct model *m)
{
	struct nmgregion	*r;
	struct shell		*s;
	struct  faceuse		*fu;
	struct face		*f;
	struct loopuse		*lu;
	struct loop		*l;
	register struct edgeuse		*eu;
	struct edge			*e;
	register struct vertexuse	*vu;

#define MARK_VU(_vu)	{ \
	struct vertex	*v; \
	NMG_CK_VERTEXUSE(_vu); \
	NMG_MARK_INDEX(_vu); \
	if(_vu->a.magic_p) switch(*_vu->a.magic_p)  { \
	case NMG_VERTEXUSE_A_PLANE_MAGIC: \
		NMG_MARK_INDEX(_vu->a.plane_p); \
		break; \
	case NMG_VERTEXUSE_A_CNURB_MAGIC: \
		NMG_MARK_INDEX(_vu->a.cnurb_p); \
		break; \
	} \
	v = _vu->v_p; \
	NMG_CK_VERTEX(v); \
	NMG_MARK_INDEX(v); \
	if(v->vg_p)  { \
		NMG_CK_VERTEX_G(v->vg_p); \
		NMG_MARK_INDEX(v->vg_p); \
	} \
    }

	NMG_CK_MODEL(m);
	NMG_MARK_INDEX(m);

	for( BU_LIST_FOR( r, nmgregion, &m->r_hd ) )  {
		NMG_CK_REGION(r);
		NMG_MARK_INDEX(r);
		if( r->ra_p )  {
			NMG_CK_REGION_A(r->ra_p);
			NMG_MARK_INDEX(r->ra_p);
		}
		for( BU_LIST_FOR( s, shell, &r->s_hd ) )  {
			NMG_CK_SHELL(s);
			NMG_MARK_INDEX(s);
			if( s->sa_p )  {
				NMG_CK_SHELL_A(s->sa_p);
				NMG_MARK_INDEX(s->sa_p);
			}
			/* Faces in shell */
			for( BU_LIST_FOR( fu, faceuse, &s->fu_hd ) )  {
				NMG_CK_FACEUSE(fu);
				NMG_MARK_INDEX(fu);
				f = fu->f_p;
				NMG_CK_FACE(f);
				NMG_MARK_INDEX(f);
				if(f->g.magic_p) switch( *f->g.magic_p )  {
				case NMG_FACE_G_PLANE_MAGIC:
					NMG_MARK_INDEX(f->g.plane_p);
					break;
				case NMG_FACE_G_SNURB_MAGIC:
					NMG_MARK_INDEX(f->g.snurb_p);
					break;
				}
				/* Loops in face */
				for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )  {
					NMG_CK_LOOPUSE(lu);
					NMG_MARK_INDEX(lu);
					l = lu->l_p;
					NMG_CK_LOOP(l);
					NMG_MARK_INDEX(l);
					if( l->lg_p )  {
						NMG_CK_LOOP_G(l->lg_p);
						NMG_MARK_INDEX(l->lg_p);
					}
					if( BU_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC )  {
						/* Loop of Lone vertex */
						vu = BU_LIST_FIRST( vertexuse, &lu->down_hd );
						MARK_VU(vu);
						continue;
					}
					for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
						NMG_CK_EDGEUSE(eu);
						NMG_MARK_INDEX(eu);
						e = eu->e_p;
						NMG_CK_EDGE(e);
						NMG_MARK_INDEX(e);
						if(eu->g.magic_p) nmg_mark_edge_g( eu->g.magic_p );
						vu = eu->vu_p;
						MARK_VU(vu);
					}
				}
			}
			/* Wire loops in shell */
			for( BU_LIST_FOR( lu, loopuse, &s->lu_hd ) )  {
				NMG_CK_LOOPUSE(lu);
				NMG_MARK_INDEX(lu);
				l = lu->l_p;
				NMG_CK_LOOP(l);
				NMG_MARK_INDEX(l);
				if( l->lg_p )  {
					NMG_CK_LOOP_G(l->lg_p);
					NMG_MARK_INDEX(l->lg_p);
				}
				if( BU_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC )  {
					/* Wire loop of Lone vertex */
					vu = BU_LIST_FIRST( vertexuse, &lu->down_hd );
					MARK_VU(vu);
					continue;
				}
				for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
					NMG_CK_EDGEUSE(eu);
					NMG_MARK_INDEX(eu);
					e = eu->e_p;
					NMG_CK_EDGE(e);
					NMG_MARK_INDEX(e);
					if(eu->g.magic_p) nmg_mark_edge_g( eu->g.magic_p );
					vu = eu->vu_p;
					MARK_VU(vu);
				}
			}
			/* Wire edges in shell */
			for( BU_LIST_FOR( eu, edgeuse, &s->eu_hd ) )  {
				NMG_CK_EDGEUSE(eu);
				NMG_MARK_INDEX(eu);
				e = eu->e_p;
				NMG_CK_EDGE(e);
				NMG_MARK_INDEX(e);
				if(eu->g.magic_p) nmg_mark_edge_g( eu->g.magic_p );
				vu = eu->vu_p;
				MARK_VU(vu);
			}
			/* Lone vertex in shell */
			if( (vu = s->vu_p) )  {
				MARK_VU(vu);
			}
		}
	}
#undef MARK_VU
}

/*
 *			N M G _ M _ R E I N D E X
 *
 *  Reassign index numbers to all the data structures in a model.
 *  The model structure will get index 0, all others will be sequentially
 *  assigned after that.
 *
 *  Because the first pass has done extensive error checking,
 *  the second pass can do less.
 */
void
nmg_m_reindex(struct model *m, register long int newindex)
{
	struct nmgregion	*r;
	struct shell		*s;
	struct faceuse		*fu;
	struct face		*f;
	struct loopuse		*lu;
	struct loop		*l;
	register struct edgeuse		*eu;
	struct edge			*e;
	register struct vertexuse	*vu;
	struct vertex			*v;

#define ASSIGN_VU(_vu)	{ \
		NMG_CK_VERTEXUSE(_vu); \
		NMG_ASSIGN_NEW_INDEX(_vu); \
		if(_vu->a.magic_p)  switch(*_vu->a.magic_p)  { \
		case NMG_VERTEXUSE_A_PLANE_MAGIC: \
			NMG_ASSIGN_NEW_INDEX(_vu->a.plane_p); \
			break; \
		case NMG_VERTEXUSE_A_CNURB_MAGIC: \
			NMG_ASSIGN_NEW_INDEX(_vu->a.cnurb_p); \
			break; \
		} \
		v = _vu->v_p; \
		NMG_CK_VERTEX(v); \
		NMG_ASSIGN_NEW_INDEX(v); \
		if(v->vg_p) NMG_ASSIGN_NEW_INDEX(v->vg_p); \
	}

	NMG_CK_MODEL(m);
	if( m->index != 0 )  bu_log("nmg_m_reindex() m->index=%d\n", m->index);
	if ( newindex < 0 )  bu_log("nmg_m_reindex() newindex(%ld) < 0\n", newindex);

	/* First pass:  set high bits */
	nmg_m_set_high_bit( m );

	/*
	 *  Second pass:  assign new index number
	 */

	NMG_ASSIGN_NEW_INDEX(m);
	for( BU_LIST_FOR( r, nmgregion, &m->r_hd ) )  {
		NMG_CK_REGION(r);
		NMG_ASSIGN_NEW_INDEX(r);
		if( r->ra_p )  NMG_ASSIGN_NEW_INDEX(r->ra_p);
		for( BU_LIST_FOR( s, shell, &r->s_hd ) )  {
			NMG_CK_SHELL(s);
			NMG_ASSIGN_NEW_INDEX(s);
			if( s->sa_p )  NMG_ASSIGN_NEW_INDEX(s->sa_p);
			/* Faces in shell */
			for( BU_LIST_FOR( fu, faceuse, &s->fu_hd ) )  {
				NMG_CK_FACEUSE(fu);
				NMG_ASSIGN_NEW_INDEX(fu);
				f = fu->f_p;
				NMG_CK_FACE(f);
				NMG_ASSIGN_NEW_INDEX(f);
				if( f->g.plane_p ) switch( *f->g.magic_p )  {
				case NMG_FACE_G_PLANE_MAGIC:
					NMG_ASSIGN_NEW_INDEX(f->g.plane_p);
					break;
				case NMG_FACE_G_SNURB_MAGIC:
					NMG_ASSIGN_NEW_INDEX(f->g.snurb_p);
					break;
				}
				/* Loops in face */
				for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )  {
					NMG_CK_LOOPUSE(lu);
					NMG_ASSIGN_NEW_INDEX(lu);
					l = lu->l_p;
					NMG_CK_LOOP(l);
					NMG_ASSIGN_NEW_INDEX(l);
					if( l->lg_p )  NMG_ASSIGN_NEW_INDEX(l->lg_p);
					if( BU_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC )  {
						/* Loop of Lone vertex */
						vu = BU_LIST_FIRST( vertexuse, &lu->down_hd );
						ASSIGN_VU(vu);
						continue;
					}
					for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
						NMG_CK_EDGEUSE(eu);
						NMG_ASSIGN_NEW_INDEX(eu);
						e = eu->e_p;
						NMG_CK_EDGE(e);
						NMG_ASSIGN_NEW_INDEX(e);
						if( eu->g.magic_p ) switch(*eu->g.magic_p)  {
						case NMG_EDGE_G_LSEG_MAGIC:
							NMG_ASSIGN_NEW_INDEX(eu->g.lseg_p);
							break;
						case NMG_EDGE_G_CNURB_MAGIC:
							NMG_ASSIGN_NEW_INDEX(eu->g.cnurb_p);
							break;
						}
						vu = eu->vu_p;
						ASSIGN_VU(vu);
					}
				}
			}
			/* Wire loops in shell */
			for( BU_LIST_FOR( lu, loopuse, &s->lu_hd ) )  {
				NMG_CK_LOOPUSE(lu);
				NMG_ASSIGN_NEW_INDEX(lu);
				l = lu->l_p;
				NMG_CK_LOOP(l);
				NMG_ASSIGN_NEW_INDEX(l);
				if( l->lg_p )  NMG_ASSIGN_NEW_INDEX(l->lg_p);
				if( BU_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC )  {
					/* Wire loop of Lone vertex */
					vu = BU_LIST_FIRST( vertexuse, &lu->down_hd );
					ASSIGN_VU(vu);
					continue;
				}
				for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
					NMG_CK_EDGEUSE(eu);
					NMG_ASSIGN_NEW_INDEX(eu);
					e = eu->e_p;
					NMG_CK_EDGE(e);
					NMG_ASSIGN_NEW_INDEX(e);
					if( eu->g.magic_p ) switch(*eu->g.magic_p)  {
					case NMG_EDGE_G_LSEG_MAGIC:
						NMG_ASSIGN_NEW_INDEX(eu->g.lseg_p);
						break;
					case NMG_EDGE_G_CNURB_MAGIC:
						NMG_ASSIGN_NEW_INDEX(eu->g.cnurb_p);
						break;
					}
					vu = eu->vu_p;
					ASSIGN_VU(vu);
				}
			}
			/* Wire edges in shell */
			for( BU_LIST_FOR( eu, edgeuse, &s->eu_hd ) )  {
				NMG_CK_EDGEUSE(eu);
				NMG_ASSIGN_NEW_INDEX(eu);
				e = eu->e_p;
				NMG_CK_EDGE(e);
				NMG_ASSIGN_NEW_INDEX(e);
				if( eu->g.magic_p ) switch(*eu->g.magic_p)  {
				case NMG_EDGE_G_LSEG_MAGIC:
					NMG_ASSIGN_NEW_INDEX(eu->g.lseg_p);
					break;
				case NMG_EDGE_G_CNURB_MAGIC:
					NMG_ASSIGN_NEW_INDEX(eu->g.cnurb_p);
					break;
				}
				vu = eu->vu_p;
				ASSIGN_VU(vu);
			}
			/* Lone vertex in shell */
			if( (vu = s->vu_p) )  {
				ASSIGN_VU(vu);
			}
		}
	}
#undef ASSIGN_VU

	if( rt_g.NMG_debug & DEBUG_BASIC )  {
		 bu_log("nmg_m_reindex() oldmax=%d, new%d=>%d\n",
		 	m->maxindex, m->index, newindex );
	}
	m->maxindex = newindex;
}

/*
 *			N M G _ V L S _ S T R U C T _ C O U N T S
 *
 */
void
nmg_vls_struct_counts(struct bu_vls *str, const struct nmg_struct_counts *ctr)
{
	BU_CK_VLS( str );

	bu_vls_printf(str, " Actual structure counts:\n");
	bu_vls_printf(str, "\t%6d model\n", ctr->model);
	bu_vls_printf(str, "\t%6d region\n", ctr->region);
	bu_vls_printf(str, "\t%6d region_a\n", ctr->region_a);
	bu_vls_printf(str, "\t%6d shell\n", ctr->shell);
	bu_vls_printf(str, "\t%6d shell_a\n", ctr->shell_a);
	bu_vls_printf(str, "\t%6d face\n", ctr->face);
	bu_vls_printf(str, "\t%6d face_g_plane\n", ctr->face_g_plane);
	bu_vls_printf(str, "\t%6d face_g_snurb\n", ctr->face_g_snurb);
	bu_vls_printf(str, "\t%6d faceuse\n", ctr->faceuse);
	bu_vls_printf(str, "\t%6d loopuse\n", ctr->loopuse);
	bu_vls_printf(str, "\t%6d loop\n", ctr->loop);
	bu_vls_printf(str, "\t%6d loop_g\n", ctr->loop_g);
	bu_vls_printf(str, "\t%6d edgeuse\n", ctr->edgeuse);
	bu_vls_printf(str, "\t%6d edge\n", ctr->edge);
	bu_vls_printf(str, "\t%6d edge_g_lseg\n", ctr->edge_g_lseg);
	bu_vls_printf(str, "\t%6d edge_g_cnurb\n", ctr->edge_g_cnurb);
	bu_vls_printf(str, "\t%6d vertexuse\n", ctr->vertexuse);
	bu_vls_printf(str, "\t%6d vertexuse_a_plane\n", ctr->vertexuse_a_plane);
	bu_vls_printf(str, "\t%6d vertexuse_a_cnurb\n", ctr->vertexuse_a_cnurb);
	bu_vls_printf(str, "\t%6d vertex\n", ctr->vertex);
	bu_vls_printf(str, "\t%6d vertex_g\n", ctr->vertex_g);
	bu_vls_printf(str, " Abstractions:\n");
	bu_vls_printf(str, "\t%6d max_structs\n", ctr->max_structs);
	bu_vls_printf(str, "\t%6d face_loops\n", ctr->face_loops);
	bu_vls_printf(str, "\t%6d face_edges\n", ctr->face_edges);
	bu_vls_printf(str, "\t%6d face_lone_verts\n", ctr->face_lone_verts);
	bu_vls_printf(str, "\t%6d wire_loops\n", ctr->wire_loops);
	bu_vls_printf(str, "\t%6d wire_loop_edges\n", ctr->wire_loop_edges);
	bu_vls_printf(str, "\t%6d wire_edges\n", ctr->wire_edges);
	bu_vls_printf(str, "\t%6d wire_lone_verts\n", ctr->wire_lone_verts);
	bu_vls_printf(str, "\t%6d shells_of_lone_vert\n", ctr->shells_of_lone_vert);
}

/*
 *			N M G _ P R _ S T R U C T _ C O U N T S
 */
void
nmg_pr_struct_counts(const struct nmg_struct_counts *ctr, const char *str)
{
	struct bu_vls		vls;

	bu_log("nmg_pr_count(%s)\n", str);

	bu_vls_init( &vls );
	nmg_vls_struct_counts( &vls, ctr );
	bu_log("%s", bu_vls_addr( &vls ) );
	bu_vls_free( &vls );
}

/*
 *			N M G _ M _ S T R U C T _ C O U N T
 *
 *  Returns -
 *	Pointer to magic-number/structure-base pointer array,
 *	indexed by nmg structure index.
 *	Caller is responsible for freeing it.
 */
long **
nmg_m_struct_count(register struct nmg_struct_counts *ctr, const struct model *m)
{
	struct nmgregion	*r;
	struct shell		*s;
	struct faceuse		*fu;
	struct face		*f;
	struct loopuse		*lu;
	struct loop		*l;
	struct edgeuse		*eu;
	struct edge		*e;
	struct vertexuse	*vu;
	struct vertex		*v;
	register long		**ptrs;

#define NMG_UNIQ_INDEX(_p,_type)	\
	if( (_p)->index > m->maxindex )  { \
		bu_log("x%x (%s) has index %d, m->maxindex=%d\n", (_p), \
			bu_identify_magic(*((long *)(_p))), (_p)->index, m->maxindex ); \
		rt_bomb("nmg_m_struct_count index overflow\n"); \
	} \
	if( ptrs[(_p)->index] == (long *)0 )  { \
		ptrs[(_p)->index] = (long *)(_p); \
		ctr->_type++; \
	}

#define UNIQ_VU(_vu)	{ \
		NMG_CK_VERTEXUSE(_vu); \
		NMG_UNIQ_INDEX(_vu, vertexuse); \
		if(_vu->a.magic_p) switch(*_vu->a.magic_p) { \
		case NMG_VERTEXUSE_A_PLANE_MAGIC: \
			NMG_UNIQ_INDEX(_vu->a.plane_p, vertexuse_a_plane); \
			break; \
		case NMG_VERTEXUSE_A_CNURB_MAGIC: \
			NMG_UNIQ_INDEX(_vu->a.cnurb_p, vertexuse_a_cnurb); \
			break; \
		} \
		v = _vu->v_p; \
		NMG_CK_VERTEX(v); \
		NMG_UNIQ_INDEX(v, vertex); \
		if(v->vg_p)  { \
			NMG_CK_VERTEX_G(v->vg_p); \
			NMG_UNIQ_INDEX(v->vg_p, vertex_g); \
		} \
	}

	NMG_CK_MODEL(m);
	bzero( (char *)ctr, sizeof(*ctr) );

	ptrs = (long **)bu_calloc( m->maxindex+1, sizeof(long *), "nmg_m_count ptrs[]" );

	NMG_UNIQ_INDEX(m, model);
	ctr->max_structs = m->maxindex;
	for( BU_LIST_FOR( r, nmgregion, &m->r_hd ) )  {
		NMG_CK_REGION(r);
		NMG_UNIQ_INDEX(r, region);
		if(r->ra_p)  {
			NMG_CK_REGION_A(r->ra_p);
			NMG_UNIQ_INDEX(r->ra_p, region_a);
		}
		for( BU_LIST_FOR( s, shell, &r->s_hd ) )  {
			NMG_CK_SHELL(s);
			NMG_UNIQ_INDEX(s, shell);
			if(s->sa_p)  {
				NMG_CK_SHELL_A(s->sa_p);
				NMG_UNIQ_INDEX(s->sa_p, shell_a);
			}
			/* Faces in shell */
			for( BU_LIST_FOR( fu, faceuse, &s->fu_hd ) )  {
				NMG_CK_FACEUSE(fu);
				NMG_UNIQ_INDEX(fu, faceuse);
				f = fu->f_p;
				NMG_CK_FACE(f);
				NMG_UNIQ_INDEX(f, face);
				if( f->g.magic_p )  switch( *f->g.magic_p )  {
				case NMG_FACE_G_PLANE_MAGIC:
					NMG_UNIQ_INDEX(f->g.plane_p, face_g_plane);
					break;
				case NMG_FACE_G_SNURB_MAGIC:
					NMG_UNIQ_INDEX(f->g.snurb_p, face_g_snurb);
					break;
				}
				/* Loops in face */
				for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )  {
					NMG_CK_LOOPUSE(lu);
					NMG_UNIQ_INDEX(lu, loopuse);
					l = lu->l_p;
					NMG_CK_LOOP(l);
					NMG_UNIQ_INDEX(l, loop);
					if( l->lg_p )  {
						NMG_CK_LOOP_G(l->lg_p);
						NMG_UNIQ_INDEX(l->lg_p, loop_g);
					}
					if( BU_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC )  {
						/* Loop of Lone vertex */
						ctr->face_lone_verts++;
						vu = BU_LIST_FIRST(vertexuse, &lu->down_hd);
						UNIQ_VU(vu);
						continue;
					}
					ctr->face_loops++;
					for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
						ctr->face_edges++;
						NMG_CK_EDGEUSE(eu);
						NMG_UNIQ_INDEX(eu, edgeuse);
						e = eu->e_p;
						NMG_CK_EDGE(e);
						NMG_UNIQ_INDEX(e, edge);
						if( eu->g.magic_p )  switch( *eu->g.magic_p )  {
						case NMG_EDGE_G_LSEG_MAGIC:
							NMG_UNIQ_INDEX(eu->g.lseg_p, edge_g_lseg);
							break;
						case NMG_EDGE_G_CNURB_MAGIC:
							NMG_UNIQ_INDEX(eu->g.cnurb_p, edge_g_cnurb);
							break;
						}
						vu = eu->vu_p;
						UNIQ_VU(vu);
					}
				}
			}
			/* Wire loops in shell */
			for( BU_LIST_FOR( lu, loopuse, &s->lu_hd ) )  {
				NMG_CK_LOOPUSE(lu);
				NMG_UNIQ_INDEX(lu, loopuse);
				l = lu->l_p;
				NMG_CK_LOOP(l);
				NMG_UNIQ_INDEX(l, loop);
				if( l->lg_p )  {
					NMG_CK_LOOP_G(l->lg_p);
					NMG_UNIQ_INDEX(l->lg_p, loop_g);
				}
				if( BU_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC )  {
					ctr->wire_lone_verts++;
					/* Wire loop of Lone vertex */
					vu = BU_LIST_FIRST( vertexuse, &lu->down_hd );
					UNIQ_VU(vu);
					continue;
				}
				ctr->wire_loops++;
				for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
					NMG_CK_EDGEUSE(eu);
					NMG_UNIQ_INDEX(eu, edgeuse);
					e = eu->e_p;
					NMG_CK_EDGE(e);
					NMG_UNIQ_INDEX(e, edge);
					if( eu->g.magic_p )  switch( *eu->g.magic_p )  {
					case NMG_EDGE_G_LSEG_MAGIC:
						NMG_UNIQ_INDEX(eu->g.lseg_p, edge_g_lseg);
						break;
					case NMG_EDGE_G_CNURB_MAGIC:
						NMG_UNIQ_INDEX(eu->g.cnurb_p, edge_g_cnurb);
						break;
					}
					vu = eu->vu_p;
					UNIQ_VU(vu);
					ctr->wire_loop_edges++;
				}
			}
			/* Wire edges in shell */
			for( BU_LIST_FOR( eu, edgeuse, &s->eu_hd ) )  {
				NMG_CK_EDGEUSE(eu);
				ctr->wire_edges++;
				NMG_UNIQ_INDEX(eu, edgeuse);
				e = eu->e_p;
				NMG_CK_EDGE(e);
				NMG_UNIQ_INDEX(e, edge);
				if( eu->g.magic_p )  switch( *eu->g.magic_p )  {
				case NMG_EDGE_G_LSEG_MAGIC:
					NMG_UNIQ_INDEX(eu->g.lseg_p, edge_g_lseg);
					break;
				case NMG_EDGE_G_CNURB_MAGIC:
					NMG_UNIQ_INDEX(eu->g.cnurb_p, edge_g_cnurb);
					break;
				}
				vu = eu->vu_p;
				UNIQ_VU(vu);
			}
			/* Lone vertex in shell */
			if( (vu = s->vu_p) )  {
				ctr->shells_of_lone_vert++;
				UNIQ_VU(vu);
			}
		}
	}
	/* Caller must free them */
	return ptrs;
#undef UNIQ_VU
}

/*
 *
 *  Count 'em up, and print 'em out.
 */
void
nmg_struct_counts(const struct model *m, const char *str)
{
	struct nmg_struct_counts	cnts;
	long	**tab;

	NMG_CK_MODEL(m);

	tab = nmg_m_struct_count( &cnts, m );
	bu_free( (char *)tab, "nmg_m_struct_count" );
	nmg_pr_struct_counts( &cnts, str );
}

/*			N M G _ M E R G _ M O D E L S
 *
 *	Combine two NMG model trees into one single NMG model.  The 
 *	first model inherits the nmgregions of the second.  The second
 *	model pointer is freed before return.
 */
void
nmg_merge_models(struct model *m1, struct model *m2)
{
	struct nmgregion *r;

	NMG_CK_MODEL(m1);
	NMG_CK_MODEL(m2);

	/* first reorder the first model to "compress" the
	 * number space if possible.
	 */
	nmg_m_reindex(m1, 0);

	if( m1 == m2 ) /* nothing to do */
		return;

	/* now re-order the second model starting with an index number
	 * of m1->maxindex.
	 *
	 * We might get away with using m1->maxindex-1, since the first
	 * value is assigned to the second model structure, and we will
	 * shortly be freeing the second model struct.
	 */

	nmg_m_reindex(m2, m1->maxindex);
	m1->maxindex = m2->maxindex;		/* big enough for both */

	/* Rehome all the regions in m2, and move them from m2 to m1 */
	for ( BU_LIST_FOR(r, nmgregion, &(m2->r_hd)) ) {
		NMG_CK_REGION(r);
		r->m_p = m1;
	}
	BU_LIST_APPEND_LIST(&(m1->r_hd), &(m2->r_hd));

	FREE_MODEL(m2);
}

#define CHECK_INDEX( _p ) if((_p)->index > maxindex ) maxindex = (_p)->index
#define CHECK_VU_INDEX( _vu) {\
		NMG_CK_VERTEXUSE(_vu); \
		CHECK_INDEX(_vu); \
		if(_vu->a.magic_p)  switch(*_vu->a.magic_p)  { \
		case NMG_VERTEXUSE_A_PLANE_MAGIC: \
			CHECK_INDEX(_vu->a.plane_p); \
			break; \
		case NMG_VERTEXUSE_A_CNURB_MAGIC: \
			CHECK_INDEX(_vu->a.cnurb_p); \
			break; \
		} \
		v = _vu->v_p; \
		NMG_CK_VERTEX(v); \
		CHECK_INDEX(v); \
		if(v->vg_p) CHECK_INDEX(v->vg_p); \
	}

/*
 *			N M G _ F I N D _ M A X _ I N D E X
 */
long
nmg_find_max_index(const struct model *m)
{
	long			maxindex=0;
	struct nmgregion	*r;
	struct shell		*s;
	struct faceuse		*fu;
	struct face		*f;
	struct loopuse		*lu;
	struct loop		*l;
	register struct edgeuse		*eu;
	struct edge			*e;
	register struct vertexuse	*vu;
	struct vertex			*v;

	for( BU_LIST_FOR( r, nmgregion, &m->r_hd ) )  {
		NMG_CK_REGION(r);
		CHECK_INDEX(r);
		if( r->ra_p )  CHECK_INDEX(r->ra_p);
		for( BU_LIST_FOR( s, shell, &r->s_hd ) )  {
			NMG_CK_SHELL(s);
			CHECK_INDEX(s);
			if( s->sa_p )  CHECK_INDEX(s->sa_p);
			/* Faces in shell */
			for( BU_LIST_FOR( fu, faceuse, &s->fu_hd ) )  {
				NMG_CK_FACEUSE(fu);
				CHECK_INDEX(fu);
				f = fu->f_p;
				NMG_CK_FACE(f);
				CHECK_INDEX(f);
				if( f->g.plane_p ) switch( *f->g.magic_p )  {
				case NMG_FACE_G_PLANE_MAGIC:
					CHECK_INDEX(f->g.plane_p);
					break;
				case NMG_FACE_G_SNURB_MAGIC:
					CHECK_INDEX(f->g.snurb_p);
					break;
				}
				/* Loops in face */
				for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )  {
					NMG_CK_LOOPUSE(lu);
					CHECK_INDEX(lu);
					l = lu->l_p;
					NMG_CK_LOOP(l);
					CHECK_INDEX(l);
					if( l->lg_p )  CHECK_INDEX(l->lg_p);
					if( BU_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC )  {
						/* Loop of Lone vertex */
						vu = BU_LIST_FIRST( vertexuse, &lu->down_hd );
						CHECK_VU_INDEX(vu);
						continue;
					}
					for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
						NMG_CK_EDGEUSE(eu);
						CHECK_INDEX(eu);
						e = eu->e_p;
						NMG_CK_EDGE(e);
						CHECK_INDEX(e);
						if( eu->g.magic_p ) switch(*eu->g.magic_p)  {
						case NMG_EDGE_G_LSEG_MAGIC:
							CHECK_INDEX(eu->g.lseg_p);
							break;
						case NMG_EDGE_G_CNURB_MAGIC:
							CHECK_INDEX(eu->g.cnurb_p);
							break;
						}
						vu = eu->vu_p;
						CHECK_VU_INDEX(vu);
					}
				}
			}
			/* Wire loops in shell */
			for( BU_LIST_FOR( lu, loopuse, &s->lu_hd ) )  {
				NMG_CK_LOOPUSE(lu);
				CHECK_INDEX(lu);
				l = lu->l_p;
				NMG_CK_LOOP(l);
				CHECK_INDEX(l);
				if( l->lg_p )  CHECK_INDEX(l->lg_p);
				if( BU_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC )  {
					/* Wire loop of Lone vertex */
					vu = BU_LIST_FIRST( vertexuse, &lu->down_hd );
					CHECK_VU_INDEX(vu);
					continue;
				}
				for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
					NMG_CK_EDGEUSE(eu);
					CHECK_INDEX(eu);
					e = eu->e_p;
					NMG_CK_EDGE(e);
					CHECK_INDEX(e);
					if( eu->g.magic_p ) switch(*eu->g.magic_p)  {
					case NMG_EDGE_G_LSEG_MAGIC:
						CHECK_INDEX(eu->g.lseg_p);
						break;
					case NMG_EDGE_G_CNURB_MAGIC:
						CHECK_INDEX(eu->g.cnurb_p);
						break;
					}
					vu = eu->vu_p;
					CHECK_VU_INDEX(vu);
				}
			}
			/* Wire edges in shell */
			for( BU_LIST_FOR( eu, edgeuse, &s->eu_hd ) )  {
				NMG_CK_EDGEUSE(eu);
				CHECK_INDEX(eu);
				e = eu->e_p;
				NMG_CK_EDGE(e);
				CHECK_INDEX(e);
				if( eu->g.magic_p ) switch(*eu->g.magic_p)  {
				case NMG_EDGE_G_LSEG_MAGIC:
					CHECK_INDEX(eu->g.lseg_p);
					break;
				case NMG_EDGE_G_CNURB_MAGIC:
					CHECK_INDEX(eu->g.cnurb_p);
					break;
				}
				vu = eu->vu_p;
				CHECK_VU_INDEX(vu);
			}
			/* Lone vertex in shell */
			if( (vu = s->vu_p) )  {
				CHECK_VU_INDEX(vu);
			}
		}
	}
	return( maxindex );
}
@


11.16
log
@change conf.h to a wrapped config.h
@
text
@d20 1
a20 1
static const char RCSnmg_index[] = "@@(#)$Header: /cvs/brlcad/librt/nmg_index.c,v 11.15 2004/04/05 08:48:57 morrison Exp $ (BRL)";
@


11.15
log
@merge of ansi-6-0-branch into HEAD
@
text
@d20 1
a20 1
static const char RCSnmg_index[] = "@@(#)$Header$ (BRL)";
d23 5
a27 1
#include "conf.h"
@


11.14
log
@update copyright to include span through 2003
@
text
@d20 1
a20 1
static const char RCSnmg_index[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_index.c,v 11.13 2002/08/20 17:08:04 jra Exp $ (BRL)";
d44 1
a44 2
nmg_index_of_struct( p )
register const long	*p;
d115 1
a115 2
nmg_mark_edge_g( magic_p )
long	*magic_p;
d144 1
a144 2
nmg_m_set_high_bit( m )
struct model	*m;
d297 1
a297 3
nmg_m_reindex( m, newindex )
struct model	*m;
register long	newindex;
d465 1
a465 3
nmg_vls_struct_counts( str, ctr )
struct bu_vls			*str;
const struct nmg_struct_counts	*ctr;
d507 1
a507 3
nmg_pr_struct_counts( ctr, str )
const struct nmg_struct_counts	*ctr;
const char			*str;
d528 1
a528 3
nmg_m_struct_count( ctr, m )
register struct nmg_struct_counts	*ctr;
const struct model			*m;
d722 1
a722 3
nmg_struct_counts( m, str )
const struct model	*m;
const char		*str;
d741 1
a741 3
nmg_merge_models(m1, m2)
struct model *m1;
struct model *m2;
d799 1
a799 2
nmg_find_max_index( m )
const struct model *m;
@


11.13
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1990 by the United States Army.
d20 1
a20 1
static const char RCSnmg_index[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_index.c,v 11.11 2001/04/20 22:29:50 morrison Exp $ (BRL)";
@


11.13.4.1
log
@sync to HEAD...
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d20 1
a20 1
static const char RCSnmg_index[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/nmg_index.c,v 11.14 2004/02/02 17:39:23 morrison Exp $ (BRL)";
@


11.13.10.1
log
@merge from HEAD
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d20 1
a20 1
static const char RCSnmg_index[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_index.c,v 11.14 2004/02/02 17:39:23 morrison Exp $ (BRL)";
@


11.13.10.2
log
@merge from head
@
text
@d20 1
a20 1
static const char RCSnmg_index[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_index.c,v 11.13.10.1 2004/02/12 18:37:43 erikg Exp $ (BRL)";
@


11.13.2.1
log
@Initial ANSIfication
@
text
@d20 1
a20 1
static const char RCSnmg_index[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_index.c,v 11.13 2002/08/20 17:08:04 jra Exp $ (BRL)";
d44 2
a45 1
nmg_index_of_struct(register const long int *p)
d116 2
a117 1
nmg_mark_edge_g(long int *magic_p)
d146 2
a147 1
nmg_m_set_high_bit(struct model *m)
d300 3
a302 1
nmg_m_reindex(struct model *m, register long int newindex)
d470 3
a472 1
nmg_vls_struct_counts(struct bu_vls *str, const struct nmg_struct_counts *ctr)
d514 3
a516 1
nmg_pr_struct_counts(const struct nmg_struct_counts *ctr, const char *str)
d537 3
a539 1
nmg_m_struct_count(register struct nmg_struct_counts *ctr, const struct model *m)
d733 3
a735 1
nmg_struct_counts(const struct model *m, const char *str)
d754 3
a756 1
nmg_merge_models(struct model *m1, struct model *m2)
d814 2
a815 1
nmg_find_max_index(const struct model *m)
@


11.13.2.2
log
@sync branch with HEAD
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d20 1
a20 1
static const char RCSnmg_index[] = "@@(#)$Header$ (BRL)";
@


11.12
log
@Converted from K&R to ANSI C - RFH
@
text
@d44 2
a45 1
nmg_index_of_struct(register const long int *p)
d116 2
a117 1
nmg_mark_edge_g(long int *magic_p)
d146 2
a147 1
nmg_m_set_high_bit(struct model *m)
d300 3
a302 1
nmg_m_reindex(struct model *m, register long int newindex)
d470 3
a472 1
nmg_vls_struct_counts(struct bu_vls *str, const struct nmg_struct_counts *ctr)
d514 3
a516 1
nmg_pr_struct_counts(const struct nmg_struct_counts *ctr, const char *str)
d537 3
a539 1
nmg_m_struct_count(register struct nmg_struct_counts *ctr, const struct model *m)
d733 3
a735 1
nmg_struct_counts(const struct model *m, const char *str)
d754 3
a756 1
nmg_merge_models(struct model *m1, struct model *m2)
d814 2
a815 1
nmg_find_max_index(const struct model *m)
@


11.11
log
@CONST to const
@
text
@d20 1
a20 1
static const char RCSnmg_index[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_index.c,v 11.10 2000/08/21 02:02:32 butler Exp $ (BRL)";
d44 1
a44 2
nmg_index_of_struct( p )
register const long	*p;
d115 1
a115 2
nmg_mark_edge_g( magic_p )
long	*magic_p;
d144 1
a144 2
nmg_m_set_high_bit( m )
struct model	*m;
d297 1
a297 3
nmg_m_reindex( m, newindex )
struct model	*m;
register long	newindex;
d465 1
a465 3
nmg_vls_struct_counts( str, ctr )
struct bu_vls			*str;
const struct nmg_struct_counts	*ctr;
d507 1
a507 3
nmg_pr_struct_counts( ctr, str )
const struct nmg_struct_counts	*ctr;
const char			*str;
d528 1
a528 3
nmg_m_struct_count( ctr, m )
register struct nmg_struct_counts	*ctr;
const struct model			*m;
d722 1
a722 3
nmg_struct_counts( m, str )
const struct model	*m;
const char		*str;
d741 1
a741 3
nmg_merge_models(m1, m2)
struct model *m1;
struct model *m2;
d799 1
a799 2
nmg_find_max_index( m )
const struct model *m;
@


11.10
log
@Massive compilation warnings eliminated
@
text
@d20 1
a20 1
static const char RCSnmg_index[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_index.c,v 11.9 2000/07/10 23:01:41 mike Exp $ (BRL)";
d45 1
a45 1
register CONST long	*p;
d472 1
a472 1
CONST struct nmg_struct_counts	*ctr;
d515 2
a516 2
CONST struct nmg_struct_counts	*ctr;
CONST char			*str;
d539 1
a539 1
CONST struct model			*m;
d734 2
a735 2
CONST struct model	*m;
CONST char		*str;
d815 1
a815 1
CONST struct model *m;
@


11.9
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d20 1
a20 1
static const char RCSnmg_index[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_index.c,v 11.8 2000/04/01 01:43:54 mike Exp $ (BRL)";
d25 1
d281 1
a281 1
			if( vu = s->vu_p )  {
d451 1
a451 1
			if( vu = s->vu_p )  {
d717 1
a717 1
			if( vu = s->vu_p )  {
d936 1
a936 1
			if( vu = s->vu_p )  {
@


11.8
log
@
added externs for nmg_index.c
@
text
@d20 1
a20 1
static char RCSnmg_index[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_index.c,v 11.7 1999/11/24 21:44:30 mike Exp $ (BRL)";
@


11.7
log
@
Removed includes of compat header files rtstring.h and rtlist.h
@
text
@d20 1
a20 1
static char RCSnmg_index[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_index.c,v 11.6 1999/06/03 01:43:36 mike Exp $ (BRL)";
d44 1
a44 1
register long	*p;
d733 2
a734 2
/*CONST*/ struct model	*m;
/*CONST*/ char		*str;
d808 4
@


11.6
log
@
sed4
@
text
@d20 1
a20 1
static char RCSnmg_index[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_index.c,v 11.5 1996/10/25 16:22:45 jra Exp $ (BRL)";
a28 1
#include "rtlist.h"
@


11.5
log
@Fixed bug in nmg_find_max_index().
@
text
@d20 1
a20 1
static char RCSnmg_index[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_index.c,v 11.4 1996/10/21 02:51:52 jra Exp $ (BRL)";
d587 1
a587 1
	ptrs = (long **)rt_calloc( m->maxindex+1, sizeof(long *), "nmg_m_count ptrs[]" );
d743 1
a743 1
	rt_free( (char *)tab, "nmg_m_struct_count" );
@


11.4
log
@Added nmg_find_max_index().
@
text
@d20 1
a20 1
static char RCSnmg_index[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_index.c,v 11.3 1996/09/27 08:27:30 mike Exp jra $ (BRL)";
d793 16
d859 1
a859 1
						CHECK_INDEX(vu);
d877 1
a877 1
						CHECK_INDEX(vu);
d892 1
a892 1
					CHECK_INDEX(vu);
d910 1
a910 1
					CHECK_INDEX(vu);
d929 1
a929 1
				CHECK_INDEX(vu);
d933 1
a933 1
				CHECK_INDEX(vu);
@


11.3
log
@Converted to using proper routine names for LIBBU and LIBBN routines.
@
text
@d20 1
a20 1
static char RCSnmg_index[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_index.c,v 11.2 1996/09/06 18:33:53 jra Exp mike $ (BRL)";
d790 132
@


11.2
log
@Added check for same models in nmg_merge_models().
@
text
@d20 1
a20 1
static char RCSnmg_index[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_index.c,v 11.1 1995/01/04 09:57:36 mike Rel4_4 jra $ (BRL)";
d40 1
a40 1
 *	 -1	pointed at struct rt_list embedded within NMG structure.
d76 1
a76 1
		return RT_LIST_MAIN_PTR(edgeuse, p, l2)->index;
d93 1
a93 1
	case RT_LIST_HEAD_MAGIC:
d98 1
a98 1
	rt_log("nmg_index_of_struct: magicp = x%x, magic = x%x\n", p, *p);
d183 1
a183 1
	for( RT_LIST_FOR( r, nmgregion, &m->r_hd ) )  {
d190 1
a190 1
		for( RT_LIST_FOR( s, shell, &r->s_hd ) )  {
d198 1
a198 1
			for( RT_LIST_FOR( fu, faceuse, &s->fu_hd ) )  {
d213 1
a213 1
				for( RT_LIST_FOR( lu, loopuse, &fu->lu_hd ) )  {
d223 1
a223 1
					if( RT_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC )  {
d225 1
a225 1
						vu = RT_LIST_FIRST( vertexuse, &lu->down_hd );
d229 1
a229 1
					for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
d242 1
a242 1
			for( RT_LIST_FOR( lu, loopuse, &s->lu_hd ) )  {
d252 1
a252 1
				if( RT_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC )  {
d254 1
a254 1
					vu = RT_LIST_FIRST( vertexuse, &lu->down_hd );
d258 1
a258 1
				for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
d270 1
a270 1
			for( RT_LIST_FOR( eu, edgeuse, &s->eu_hd ) )  {
d333 2
a334 2
	if( m->index != 0 )  rt_log("nmg_m_reindex() m->index=%d\n", m->index);
	if ( newindex < 0 )  rt_log("nmg_m_reindex() newindex(%ld) < 0\n", newindex);
d344 1
a344 1
	for( RT_LIST_FOR( r, nmgregion, &m->r_hd ) )  {
d348 1
a348 1
		for( RT_LIST_FOR( s, shell, &r->s_hd ) )  {
d353 1
a353 1
			for( RT_LIST_FOR( fu, faceuse, &s->fu_hd ) )  {
d368 1
a368 1
				for( RT_LIST_FOR( lu, loopuse, &fu->lu_hd ) )  {
d375 1
a375 1
					if( RT_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC )  {
d377 1
a377 1
						vu = RT_LIST_FIRST( vertexuse, &lu->down_hd );
d381 1
a381 1
					for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
d401 1
a401 1
			for( RT_LIST_FOR( lu, loopuse, &s->lu_hd ) )  {
d408 1
a408 1
				if( RT_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC )  {
d410 1
a410 1
					vu = RT_LIST_FIRST( vertexuse, &lu->down_hd );
d414 1
a414 1
				for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
d433 1
a433 1
			for( RT_LIST_FOR( eu, edgeuse, &s->eu_hd ) )  {
d459 1
a459 1
		 rt_log("nmg_m_reindex() oldmax=%d, new%d=>%d\n",
d471 1
a471 1
struct rt_vls			*str;
d474 1
a474 1
	RT_VLS_CHECK( str );
d476 32
a507 32
	rt_vls_printf(str, " Actual structure counts:\n");
	rt_vls_printf(str, "\t%6d model\n", ctr->model);
	rt_vls_printf(str, "\t%6d region\n", ctr->region);
	rt_vls_printf(str, "\t%6d region_a\n", ctr->region_a);
	rt_vls_printf(str, "\t%6d shell\n", ctr->shell);
	rt_vls_printf(str, "\t%6d shell_a\n", ctr->shell_a);
	rt_vls_printf(str, "\t%6d face\n", ctr->face);
	rt_vls_printf(str, "\t%6d face_g_plane\n", ctr->face_g_plane);
	rt_vls_printf(str, "\t%6d face_g_snurb\n", ctr->face_g_snurb);
	rt_vls_printf(str, "\t%6d faceuse\n", ctr->faceuse);
	rt_vls_printf(str, "\t%6d loopuse\n", ctr->loopuse);
	rt_vls_printf(str, "\t%6d loop\n", ctr->loop);
	rt_vls_printf(str, "\t%6d loop_g\n", ctr->loop_g);
	rt_vls_printf(str, "\t%6d edgeuse\n", ctr->edgeuse);
	rt_vls_printf(str, "\t%6d edge\n", ctr->edge);
	rt_vls_printf(str, "\t%6d edge_g_lseg\n", ctr->edge_g_lseg);
	rt_vls_printf(str, "\t%6d edge_g_cnurb\n", ctr->edge_g_cnurb);
	rt_vls_printf(str, "\t%6d vertexuse\n", ctr->vertexuse);
	rt_vls_printf(str, "\t%6d vertexuse_a_plane\n", ctr->vertexuse_a_plane);
	rt_vls_printf(str, "\t%6d vertexuse_a_cnurb\n", ctr->vertexuse_a_cnurb);
	rt_vls_printf(str, "\t%6d vertex\n", ctr->vertex);
	rt_vls_printf(str, "\t%6d vertex_g\n", ctr->vertex_g);
	rt_vls_printf(str, " Abstractions:\n");
	rt_vls_printf(str, "\t%6d max_structs\n", ctr->max_structs);
	rt_vls_printf(str, "\t%6d face_loops\n", ctr->face_loops);
	rt_vls_printf(str, "\t%6d face_edges\n", ctr->face_edges);
	rt_vls_printf(str, "\t%6d face_lone_verts\n", ctr->face_lone_verts);
	rt_vls_printf(str, "\t%6d wire_loops\n", ctr->wire_loops);
	rt_vls_printf(str, "\t%6d wire_loop_edges\n", ctr->wire_loop_edges);
	rt_vls_printf(str, "\t%6d wire_edges\n", ctr->wire_edges);
	rt_vls_printf(str, "\t%6d wire_lone_verts\n", ctr->wire_lone_verts);
	rt_vls_printf(str, "\t%6d shells_of_lone_vert\n", ctr->shells_of_lone_vert);
d518 1
a518 1
	struct rt_vls		vls;
d520 1
a520 1
	rt_log("nmg_pr_count(%s)\n", str);
d522 1
a522 1
	rt_vls_init( &vls );
d524 2
a525 2
	rt_log("%s", rt_vls_addr( &vls ) );
	rt_vls_free( &vls );
d555 2
a556 2
		rt_log("x%x (%s) has index %d, m->maxindex=%d\n", (_p), \
			rt_identify_magic(*((long *)(_p))), (_p)->index, m->maxindex ); \
d591 1
a591 1
	for( RT_LIST_FOR( r, nmgregion, &m->r_hd ) )  {
d598 1
a598 1
		for( RT_LIST_FOR( s, shell, &r->s_hd ) )  {
d606 1
a606 1
			for( RT_LIST_FOR( fu, faceuse, &s->fu_hd ) )  {
d621 1
a621 1
				for( RT_LIST_FOR( lu, loopuse, &fu->lu_hd ) )  {
d631 1
a631 1
					if( RT_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC )  {
d634 1
a634 1
						vu = RT_LIST_FIRST(vertexuse, &lu->down_hd);
d639 1
a639 1
					for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
d660 1
a660 1
			for( RT_LIST_FOR( lu, loopuse, &s->lu_hd ) )  {
d670 1
a670 1
				if( RT_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC )  {
d673 1
a673 1
					vu = RT_LIST_FIRST( vertexuse, &lu->down_hd );
d678 1
a678 1
				for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
d698 1
a698 1
			for( RT_LIST_FOR( eu, edgeuse, &s->eu_hd ) )  {
d783 1
a783 1
	for ( RT_LIST_FOR(r, nmgregion, &(m2->r_hd)) ) {
d787 1
a787 1
	RT_LIST_APPEND_LIST(&(m1->r_hd), &(m2->r_hd));
@


11.1
log
@Release_4.4
@
text
@d20 1
a20 1
static char RCSnmg_index[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_index.c,v 10.23 95/01/04 08:03:16 mike Exp $ (BRL)";
d767 3
@


10.23
log
@Made chatter conditional on DEBUG_BASIC.
@
text
@d20 1
a20 1
static char RCSnmg_index[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_index.c,v 10.22 94/12/30 00:43:59 mike Exp Locker: mike $ (BRL)";
@


10.22
log
@DEC Alpha.
@
text
@d20 1
a20 1
static char RCSnmg_index[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_index.c,v 10.21 94/09/21 03:50:07 mike Exp Locker: mike $ (BRL)";
d458 4
a461 4
#if 1
 rt_log("nmg_m_reindex() oldmax=%d, new%d=>%d\n",
 	m->maxindex, m->index, newindex );
#endif
@


10.21
log
@Eliminated model_a structure
@
text
@d20 1
a20 1
static char RCSnmg_index[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_index.c,v 10.20 94/09/21 03:10:42 mike Exp Locker: mike $ (BRL)";
d585 1
a585 1
	bzero( ctr, sizeof(*ctr) );
@


10.20
log
@Fixed problem with vertexuse attributes not being properly noticed
in nmg_reindex() and nmg_m_struct_count().
Also added support for snurb faces.
@
text
@d20 1
a20 1
static char RCSnmg_index[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_index.c,v 10.19 94/09/16 20:52:35 mike Exp Locker: mike $ (BRL)";
a49 2
	case NMG_MODEL_A_MAGIC:
		return ((struct model_a *)p)->index;
a181 1
	if( m->ma_p )  NMG_MARK_INDEX(m->ma_p);
a343 1
	if( m->ma_p )  NMG_ASSIGN_NEW_INDEX(m->ma_p);
a477 1
	rt_vls_printf(str, "\t%6d model_a\n", ctr->model_a);
a589 4
	if(m->ma_p)  {
		NMG_CK_MODEL_A(m->ma_p);
		NMG_UNIQ_INDEX(m->ma_p, model_a);
	}
@


10.19
log
@Eliminated edge_g crutch.
They are now explicitly edge_g_lseg.
@
text
@d20 1
a20 1
static char RCSnmg_index[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_index.c,v 10.18 94/09/15 23:53:22 mike Exp Locker: mike $ (BRL)";
a159 1
	struct vertex			*v;
d161 21
d207 2
a208 2
				if( f->g.plane_p )  {
					NMG_CK_FACE_G_PLANE(f->g.plane_p);
d210 4
d229 1
a229 13
						NMG_CK_VERTEXUSE(vu);
						NMG_MARK_INDEX(vu);
						if(vu->a.plane_p)  {
							NMG_CK_VERTEXUSE_A_PLANE(vu->a.plane_p);
							NMG_MARK_INDEX(vu->a.plane_p);
						}
						v = vu->v_p;
						NMG_CK_VERTEX(v);
						NMG_MARK_INDEX(v);
						if(v->vg_p)  {
							NMG_CK_VERTEX_G(v->vg_p);
							NMG_MARK_INDEX(v->vg_p);
						}
d240 1
a240 9
						NMG_CK_VERTEXUSE(vu);
						NMG_MARK_INDEX(vu);
						v = vu->v_p;
						NMG_CK_VERTEX(v);
						NMG_MARK_INDEX(v);
						if(v->vg_p)  {
							NMG_CK_VERTEX_G(v->vg_p);
							NMG_MARK_INDEX(v->vg_p);
						}
d258 1
a258 13
					NMG_CK_VERTEXUSE(vu);
					NMG_MARK_INDEX(vu);
					if(vu->a.plane_p)  {
						NMG_CK_VERTEXUSE_A_PLANE(vu->a.plane_p);
						NMG_MARK_INDEX(vu->a.plane_p);
					}
					v = vu->v_p;
					NMG_CK_VERTEX(v);
					NMG_MARK_INDEX(v);
					if(v->vg_p)  {
						NMG_CK_VERTEX_G(v->vg_p);
						NMG_MARK_INDEX(v->vg_p);
					}
d269 1
a269 9
					NMG_CK_VERTEXUSE(vu);
					NMG_MARK_INDEX(vu);
					v = vu->v_p;
					NMG_CK_VERTEX(v);
					NMG_MARK_INDEX(v);
					if(v->vg_p)  {
						NMG_CK_VERTEX_G(v->vg_p);
						NMG_MARK_INDEX(v->vg_p);
					}
d281 1
a281 9
				NMG_CK_VERTEXUSE(vu);
				NMG_MARK_INDEX(vu);
				v = vu->v_p;
				NMG_CK_VERTEX(v);
				NMG_MARK_INDEX(v);
				if(v->vg_p)  {
					NMG_CK_VERTEX_G(v->vg_p);
					NMG_MARK_INDEX(v->vg_p);
				}
d285 1
a285 9
				NMG_CK_VERTEXUSE(vu);
				NMG_MARK_INDEX(vu);
				v = vu->v_p;
				NMG_CK_VERTEX(v);
				NMG_MARK_INDEX(v);
				if(v->vg_p)  {
					NMG_CK_VERTEX_G(v->vg_p);
					NMG_MARK_INDEX(v->vg_p);
				}
d289 1
d318 16
d363 8
a370 1
				if( f->g.plane_p )  NMG_ASSIGN_NEW_INDEX(f->g.plane_p);
d382 1
a382 7
						NMG_CK_VERTEXUSE(vu);
						NMG_ASSIGN_NEW_INDEX(vu);
						if(vu->a.plane_p)  NMG_ASSIGN_NEW_INDEX(vu->a.plane_p);
						v = vu->v_p;
						NMG_CK_VERTEX(v);
						NMG_ASSIGN_NEW_INDEX(v);
						if(v->vg_p) NMG_ASSIGN_NEW_INDEX(v->vg_p);
d400 1
a400 6
						NMG_CK_VERTEXUSE(vu);
						NMG_ASSIGN_NEW_INDEX(vu);
						v = vu->v_p;
						NMG_CK_VERTEX(v);
						NMG_ASSIGN_NEW_INDEX(v);
						if(v->vg_p) NMG_ASSIGN_NEW_INDEX(v->vg_p);
d415 1
a415 7
					NMG_CK_VERTEXUSE(vu);
					NMG_ASSIGN_NEW_INDEX(vu);
					if(vu->a.plane_p)  NMG_ASSIGN_NEW_INDEX(vu->a.plane_p);
					v = vu->v_p;
					NMG_CK_VERTEX(v);
					NMG_ASSIGN_NEW_INDEX(v);
					if(v->vg_p) NMG_ASSIGN_NEW_INDEX(v->vg_p);
d433 1
a433 6
					NMG_CK_VERTEXUSE(vu);
					NMG_ASSIGN_NEW_INDEX(vu);
					v = vu->v_p;
					NMG_CK_VERTEX(v);
					NMG_ASSIGN_NEW_INDEX(v);
					if(v->vg_p) NMG_ASSIGN_NEW_INDEX(v->vg_p);
d452 1
a452 6
				NMG_CK_VERTEXUSE(vu);
				NMG_ASSIGN_NEW_INDEX(vu);
				v = vu->v_p;
				NMG_CK_VERTEX(v);
				NMG_ASSIGN_NEW_INDEX(v);
				if(v->vg_p) NMG_ASSIGN_NEW_INDEX(v->vg_p);
d456 1
a456 6
				NMG_CK_VERTEXUSE(vu);
				NMG_ASSIGN_NEW_INDEX(vu);
				v = vu->v_p;
				NMG_CK_VERTEX(v);
				NMG_ASSIGN_NEW_INDEX(v);
				if(v->vg_p) NMG_ASSIGN_NEW_INDEX(v->vg_p);
d460 1
d569 20
d644 1
a644 13
						NMG_CK_VERTEXUSE(vu);
						NMG_UNIQ_INDEX(vu, vertexuse);
						if(vu->a.plane_p)  {
							NMG_CK_VERTEXUSE_A_PLANE(vu->a.plane_p);
							NMG_UNIQ_INDEX(vu->a.plane_p, vertexuse_a_plane);
						}
						v = vu->v_p;
						NMG_CK_VERTEX(v);
						NMG_UNIQ_INDEX(v, vertex);
						if(v->vg_p)  {
							NMG_CK_VERTEX_G(v->vg_p);
							NMG_UNIQ_INDEX(v->vg_p, vertex_g);
						}
d664 1
a664 9
						NMG_CK_VERTEXUSE(vu);
						NMG_UNIQ_INDEX(vu, vertexuse);
						v = vu->v_p;
						NMG_CK_VERTEX(v);
						NMG_UNIQ_INDEX(v, vertex);
						if(v->vg_p)  {
							NMG_CK_VERTEX_G(v->vg_p);
							NMG_UNIQ_INDEX(v->vg_p, vertex_g);
						}
d683 1
a683 13
					NMG_CK_VERTEXUSE(vu);
					NMG_UNIQ_INDEX(vu, vertexuse);
					if(vu->a.plane_p)  {
						NMG_CK_VERTEXUSE_A_PLANE(vu->a.plane_p);
						NMG_UNIQ_INDEX(vu->a.plane_p, vertexuse_a_plane);
					}
					v = vu->v_p;
					NMG_CK_VERTEX(v);
					NMG_UNIQ_INDEX(v, vertex);
					if(v->vg_p)  {
						NMG_CK_VERTEX_G(v->vg_p);
						NMG_UNIQ_INDEX(v->vg_p, vertex_g);
					}
d702 1
a702 9
					NMG_CK_VERTEXUSE(vu);
					NMG_UNIQ_INDEX(vu, vertexuse);
					v = vu->v_p;
					NMG_CK_VERTEX(v);
					NMG_UNIQ_INDEX(v, vertex);
					if(v->vg_p)  {
						NMG_CK_VERTEX_G(v->vg_p);
						NMG_UNIQ_INDEX(v->vg_p, vertex_g);
					}
d723 1
a723 9
				NMG_CK_VERTEXUSE(vu);
				NMG_UNIQ_INDEX(vu, vertexuse);
				v = vu->v_p;
				NMG_CK_VERTEX(v);
				NMG_UNIQ_INDEX(v, vertex);
				if(v->vg_p)  {
					NMG_CK_VERTEX_G(v->vg_p);
					NMG_UNIQ_INDEX(v->vg_p, vertex_g);
				}
d728 1
a728 9
				NMG_CK_VERTEXUSE(vu);
				NMG_UNIQ_INDEX(vu, vertexuse);
				v = vu->v_p;
				NMG_CK_VERTEX(v);
				NMG_UNIQ_INDEX(v, vertex);
				if(v->vg_p)  {
					NMG_CK_VERTEX_G(v->vg_p);
					NMG_UNIQ_INDEX(v->vg_p, vertex_g);
				}
d734 1
@


10.18
log
@added case NMG_FACE_G_SNURB_MAGIC
@
text
@d20 1
a20 1
static char RCSnmg_index[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_index.c,v 10.17 94/09/10 05:18:57 mike Exp Locker: mike $ (BRL)";
d535 2
a536 1
	rt_vls_printf(str, "\t%6d edge_g\n", ctr->edge_g);
d538 2
a539 2
	rt_vls_printf(str, "\t%6d vertexuse_a_plane_plane\n", ctr->vertexuse_a_plane);
	rt_vls_printf(str, "\t%6d vertexuse_a_plane_cnurb\n", ctr->vertexuse_a_cnurb);
@


10.17
log
@Added NMG_EDGEUSE2_MAGIC.
@
text
@d20 1
a20 1
static char RCSnmg_index[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_index.c,v 10.16 94/09/10 04:36:47 mike Exp Locker: mike $ (BRL)";
d66 2
@


10.16
log
@Converted NMG data structures to have edge_g pointer in edgeuse, not edge.
@
text
@d20 1
a20 1
static char RCSnmg_index[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_index.c,v 10.15 94/09/03 03:01:10 mike Exp $ (BRL)";
d74 3
@


10.15
log
@Snapshot of non-working intermediate stage in edge_g evolution.
@
text
@d20 1
a20 1
static char RCSnmg_index[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_index.c,v 10.14 94/09/02 19:08:08 mike Exp Locker: mike $ (BRL)";
d108 27
d221 1
a221 4
						if(e->eg_p)  {
							NMG_CK_EDGE_G_LSEG(e->eg_p);
							NMG_MARK_INDEX(e->eg_p);
						}
d270 1
a270 4
					if(e->eg_p)  {
						NMG_CK_EDGE_G_LSEG(e->eg_p);
						NMG_MARK_INDEX(e->eg_p);
					}
d290 1
a290 4
				if(e->eg_p)  {
					NMG_CK_EDGE_G_LSEG(e->eg_p);
					NMG_MARK_INDEX(e->eg_p);
				}
d400 8
a407 1
						if(e->eg_p) NMG_ASSIGN_NEW_INDEX(e->eg_p);
d444 8
a451 1
					if(e->eg_p) NMG_ASSIGN_NEW_INDEX(e->eg_p);
d468 8
a475 1
				if(e->eg_p) NMG_ASSIGN_NEW_INDEX(e->eg_p);
d680 7
a686 3
						if(e->eg_p)  {
							NMG_CK_EDGE_G_LSEG(e->eg_p);
							NMG_UNIQ_INDEX(e->eg_p, edge_g);
d738 7
a744 3
					if(e->eg_p)  {
						NMG_CK_EDGE_G_LSEG(e->eg_p);
						NMG_UNIQ_INDEX(e->eg_p, edge_g);
d767 7
a773 3
				if(e->eg_p)  {
					NMG_CK_EDGE_G_LSEG(e->eg_p);
					NMG_UNIQ_INDEX(e->eg_p, edge_g);
@


10.14
log
@vertexuse_a is now vertexuse_a_plane and vertexuse_a_cnurb
@
text
@d20 1
a20 1
static char RCSnmg_index[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_index.c,v 10.13 94/09/02 17:58:23 mike Exp Locker: mike $ (BRL)";
d76 4
a79 2
	case NMG_EDGE_G_MAGIC:
		return ((struct edge_g *)p)->index;
d195 1
a195 1
							NMG_CK_EDGE_G(e->eg_p);
d247 1
a247 1
						NMG_CK_EDGE_G(e->eg_p);
d270 1
a270 1
					NMG_CK_EDGE_G(e->eg_p);
d642 1
a642 1
							NMG_CK_EDGE_G(e->eg_p);
d696 1
a696 1
						NMG_CK_EDGE_G(e->eg_p);
d721 1
a721 1
					NMG_CK_EDGE_G(e->eg_p);
@


10.13
log
@faceuse_a, loopuse_a, and edgeuse_a have been eliminated.
@
text
@d20 1
a20 1
static char RCSnmg_index[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_index.c,v 10.12 94/09/02 01:14:54 mike Exp Locker: mike $ (BRL)";
d81 1
a81 1
		return ((struct vertexuse_a *)p)->index;
d173 3
a175 3
						if(vu->vua_p)  {
							NMG_CK_VERTEXUSE_A(vu->vua_p);
							NMG_MARK_INDEX(vu->vua_p);
d225 3
a227 3
					if(vu->vua_p)  {
						NMG_CK_VERTEXUSE_A(vu->vua_p);
						NMG_MARK_INDEX(vu->vua_p);
d367 1
a367 1
						if(vu->vua_p)  NMG_ASSIGN_NEW_INDEX(vu->vua_p);
d404 1
a404 1
					if(vu->vua_p)  NMG_ASSIGN_NEW_INDEX(vu->vua_p);
d491 2
a492 2
	rt_vls_printf(str, "\t%6d vertexuse_a_plane\n", ctr->vertexuse_a_plane);
	rt_vls_printf(str, "\t%6d vertexuse_a_cnurb\n", ctr->vertexuse_a_cnurb);
d618 3
a620 3
						if(vu->vua_p)  {
							NMG_CK_VERTEXUSE_A(vu->vua_p);
							NMG_UNIQ_INDEX(vu->vua_p, vertexuse_a);
d673 3
a675 3
					if(vu->vua_p)  {
						NMG_CK_VERTEXUSE_A(vu->vua_p);
						NMG_UNIQ_INDEX(vu->vua_p, vertexuse_a);
@


10.12
log
@More fallout from face_g changes.
@
text
@d20 1
a20 1
static char RCSnmg_index[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_index.c,v 10.11 94/09/02 00:31:57 mike Exp $ (BRL)";
a61 2
	case NMG_FACEUSE_A_MAGIC:
		return ((struct faceuse_a *)p)->index;
a67 2
	case NMG_LOOPUSE_A_MAGIC:
		return ((struct loopuse_a *)p)->index;
a73 2
	case NMG_EDGEUSE_A_MAGIC:
		return ((struct edgeuse_a *)p)->index;
d80 1
a80 1
	case NMG_VERTEXUSE_A_MAGIC:
d82 2
a149 4
				if( fu->fua_p )  {
					NMG_CK_FACEUSE_A(fu->fua_p);
					NMG_MARK_INDEX(fu->fua_p);
				}
a160 4
					if( lu->lua_p )  {
						NMG_CK_LOOPUSE_A(lu->lua_p);
						NMG_MARK_INDEX(lu->lua_p);
					}
a188 4
						if(eu->eua_p)  {
							NMG_CK_EDGEUSE_A(eu->eua_p);
							NMG_MARK_INDEX(eu->eua_p);
						}
a212 4
				if( lu->lua_p )  {
					NMG_CK_LOOPUSE_A(lu->lua_p);
					NMG_MARK_INDEX(lu->lua_p);
				}
a240 4
					if(eu->eua_p)  {
						NMG_CK_EDGEUSE_A(eu->eua_p);
						NMG_MARK_INDEX(eu->eua_p);
					}
a263 4
				if(eu->eua_p)  {
					NMG_CK_EDGEUSE_A(eu->eua_p);
					NMG_MARK_INDEX(eu->eua_p);
				}
a349 1
				if( fu->fua_p )  NMG_ASSIGN_NEW_INDEX(fu->fua_p);
a357 1
					if( lu->lua_p )  NMG_ASSIGN_NEW_INDEX(lu->lua_p);
a376 1
						if(eu->eua_p) NMG_ASSIGN_NEW_INDEX(eu->eua_p);
a394 1
				if( lu->lua_p )  NMG_ASSIGN_NEW_INDEX(lu->lua_p);
a413 1
					if(eu->eua_p) NMG_ASSIGN_NEW_INDEX(eu->eua_p);
a430 1
				if(eu->eua_p) NMG_ASSIGN_NEW_INDEX(eu->eua_p);
a483 1
	rt_vls_printf(str, "\t%6d faceuse_a\n", ctr->faceuse_a);
a484 1
	rt_vls_printf(str, "\t%6d loopuse_a\n", ctr->loopuse_a);
a487 1
	rt_vls_printf(str, "\t%6d edgeuse_a\n", ctr->edgeuse_a);
d491 2
a492 1
	rt_vls_printf(str, "\t%6d vertexuse_a\n", ctr->vertexuse_a);
a589 4
				if( fu->fua_p )  {
					NMG_CK_FACEUSE_A(fu->fua_p);
					NMG_UNIQ_INDEX(fu->fua_p, faceuse_a);
				}
a604 4
					if( lu->lua_p )  {
						NMG_CK_LOOPUSE_A(lu->lua_p);
						NMG_UNIQ_INDEX(lu->lua_p, loopuse_a);
					}
a635 4
						if(eu->eua_p)  {
							NMG_CK_EDGEUSE_A(eu->eua_p);
							NMG_UNIQ_INDEX(eu->eua_p, edgeuse_a);
						}
a659 4
				if( lu->lua_p )  {
					NMG_CK_LOOPUSE_A(lu->lua_p);
					NMG_UNIQ_INDEX(lu->lua_p, loopuse_a);
				}
a689 4
					if(eu->eua_p)  {
						NMG_CK_EDGEUSE_A(eu->eua_p);
						NMG_UNIQ_INDEX(eu->eua_p, edgeuse_a);
					}
a714 4
				if(eu->eua_p)  {
					NMG_CK_EDGEUSE_A(eu->eua_p);
					NMG_UNIQ_INDEX(eu->eua_p, edgeuse_a);
				}
@


10.11
log
@Changed to new face geometry pointers (g.plane_p)
@
text
@d20 1
a20 1
static char RCSnmg_index[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_index.c,v 10.10 94/09/01 22:59:58 mike Exp Locker: mike $ (BRL)";
d515 2
a516 1
	rt_vls_printf(str, "\t%6d face_g_plane\n", ctr->face_g);
d549 1
a549 1
/*CONST*/ char			*str;
d572 1
a572 1
/*CONST*/ struct model			*m;
d633 2
a634 2
				if( f->g.plane_p )  {
					NMG_CK_FACE_G_PLANE(f->g.plane_p);
d636 4
@


10.10
log
@Moved function.
Because it's not in raytrace.h yet.
@
text
@d20 1
a20 1
static char RCSnmg_index[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_index.c,v 10.9 94/08/25 21:35:48 mike Exp Locker: mike $ (BRL)";
d66 2
a67 2
	case NMG_FACE_G_MAGIC:
		return ((struct face_g *)p)->index;
d161 3
a163 3
				if( f->fg_p )  {
					NMG_CK_FACE_G(f->fg_p);
					NMG_MARK_INDEX(f->fg_p);
d382 1
a382 1
				if( f->fg_p )  NMG_ASSIGN_NEW_INDEX(f->fg_p);
d515 1
a515 1
	rt_vls_printf(str, "\t%6d face_g\n", ctr->face_g);
d632 3
a634 3
				if( f->fg_p )  {
					NMG_CK_FACE_G(f->fg_p);
					NMG_UNIQ_INDEX(f->fg_p, face_g);
@


10.9
log
@Fixed maxindex bug in nmg_merge_models().
Added nmg_struct_counts().
Improved debugging in nmg_m_struct_count().
@
text
@d20 1
a20 1
static char RCSnmg_index[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_index.c,v 10.8 94/08/09 19:37:40 mike Exp Locker: mike $ (BRL)";
a496 18
 *			N M G _ P R _ S T R U C T _ C O U N T S
 */
void
nmg_pr_struct_counts( ctr, str )
CONST struct nmg_struct_counts	*ctr;
/*CONST*/ char			*str;
{
	struct rt_vls		vls;

	rt_log("nmg_pr_count(%s)\n", str);

	rt_vls_init( &vls );
	nmg_vls_struct_counts( &vls, ctr );
	rt_log("%s", rt_vls_addr( &vls ) );
	rt_vls_free( &vls );
}

/*
d540 18
@


10.8
log
@Added GDurf's new "conf.h"
@
text
@d20 1
a20 1
static char RCSnmg_index[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_index.c,v 10.7 94/05/05 23:13:21 butler Exp Locker: mike $ (BRL)";
a497 2
 *
 *  XXX This version is depricated, in favor of nmg_vls_struct_counts()
d501 2
a502 2
struct nmg_struct_counts	*ctr;
char				*str;
d504 2
d507 5
a511 33
	rt_log(" Actual structure counts:\n");
	rt_log("\t%6d model\n", ctr->model);
	rt_log("\t%6d model_a\n", ctr->model_a);
	rt_log("\t%6d region\n", ctr->region);
	rt_log("\t%6d region_a\n", ctr->region_a);
	rt_log("\t%6d shell\n", ctr->shell);
	rt_log("\t%6d shell_a\n", ctr->shell_a);
	rt_log("\t%6d face\n", ctr->face);
	rt_log("\t%6d face_g\n", ctr->face_g);
	rt_log("\t%6d faceuse\n", ctr->faceuse);
	rt_log("\t%6d faceuse_a\n", ctr->faceuse_a);
	rt_log("\t%6d loopuse\n", ctr->loopuse);
	rt_log("\t%6d loopuse_a\n", ctr->loopuse_a);
	rt_log("\t%6d loop\n", ctr->loop);
	rt_log("\t%6d loop_g\n", ctr->loop_g);
	rt_log("\t%6d edgeuse\n", ctr->edgeuse);
	rt_log("\t%6d edgeuse_a\n", ctr->edgeuse_a);
	rt_log("\t%6d edge\n", ctr->edge);
	rt_log("\t%6d edge_g\n", ctr->edge_g);
	rt_log("\t%6d vertexuse\n", ctr->vertexuse);
	rt_log("\t%6d vertexuse_a\n", ctr->vertexuse_a);
	rt_log("\t%6d vertex\n", ctr->vertex);
	rt_log("\t%6d vertex_g\n", ctr->vertex_g);
	rt_log(" Abstractions:\n");
	rt_log("\t%6d max_structs\n", ctr->max_structs);
	rt_log("\t%6d face_loops\n", ctr->face_loops);
	rt_log("\t%6d face_edges\n", ctr->face_edges);
	rt_log("\t%6d face_lone_verts\n", ctr->face_lone_verts);
	rt_log("\t%6d wire_loops\n", ctr->wire_loops);
	rt_log("\t%6d wire_loop_edges\n", ctr->wire_loop_edges);
	rt_log("\t%6d wire_edges\n", ctr->wire_edges);
	rt_log("\t%6d wire_lone_verts\n", ctr->wire_lone_verts);
	rt_log("\t%6d shells_of_lone_vert\n", ctr->shells_of_lone_vert);
d571 1
a571 1
struct model				*m;
d586 3
a588 1
	if( (_p)->index > m->maxindex )  \
d590 1
d807 11
d819 7
d856 1
d858 1
@


10.7
log
@Changed info msg at end of nmg_m_reindex()
@
text
@d20 1
a20 1
static char RCSnmg_index[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_index.c,v 10.6 94/05/05 22:24:19 butler Exp Locker: butler $ (BRL)";
d23 1
@


10.6
log
@deleted gratuitous nmg_m_reindex() call in nmg_merge_models()
@
text
@d20 1
a20 1
static char RCSnmg_index[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_index.c,v 10.5 94/04/25 02:24:39 butler Exp Locker: butler $ (BRL)";
d489 2
a490 1
 rt_log("nmg_m_reindex() oldmax=%d, newmax=%d\n", m->maxindex, newindex );
@


10.5
log
@Fixed type where nmg_merge_models() was re-homing regions to the wrong model
@
text
@d20 1
a20 1
static char RCSnmg_index[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_index.c,v 10.4 94/04/25 00:43:22 butler Exp Locker: butler $ (BRL)";
a850 1
	nmg_m_reindex(m2, 0);
d852 1
a852 1
	/* no re-order the second model starting with an index number
@


10.4
log
@nmg_merge_models()
@
text
@d20 1
a20 1
static char RCSnmg_index[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_index.c,v 10.3 94/01/11 04:24:25 mike Exp Locker: butler $ (BRL)";
d863 2
a864 1
	for ( RT_LIST_FOR(r, nmgregion, &(m1->r_hd)) )
d866 1
a866 1

@


10.3
log
@nmg_vls_struct_counts() added
@
text
@d20 1
a20 1
static char RCSnmg_index[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_index.c,v 10.2 93/01/20 20:15:54 mike Exp Locker: mike $ (BRL)";
d336 1
a336 1
nmg_m_reindex( m )
d338 1
a349 1
	register int		newindex;
d351 1
d354 1
a361 1
	newindex = 0;	/* model remains index 0 */
d828 41
@


10.2
log
@Whoops, vu needs to be initialized.
@
text
@d20 1
a20 1
static char RCSnmg_index[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_index.c,v 10.1 91/10/12 06:40:44 mike Rel4_0 Locker: mike $ (BRL)";
d495 2
d540 46
d618 3
a622 1
	NMG_CK_MODEL(m);
@


10.1
log
@Release_4.0
@
text
@d20 1
a20 1
static char RCSnmg_index[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_index.c,v 1.8 91/06/23 02:42:09 mike Exp $ (BRL)";
d626 1
@


1.8
log
@Reorganized to prevent SGI optimizer from blowing up.
@
text
@d20 1
a20 1
static char RCSnmg_index[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_index.c,v 1.7 91/06/17 20:42:03 butler Exp $ (BRL)";
@


1.7
log
@changed function declarations so that all global functions have their
"nmg_" at the begining of the line.  Static functions have their function
names on the same line as the "static" modifier.
@
text
@d20 1
a20 1
static char RCSnmg_index[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_index.c,v 1.6 91/02/27 22:23:01 mike Exp $ (BRL)";
d109 1
a109 1
 *			N M G _ M _ R E I N D E X
d111 4
a114 3
 *  Reassign index numbers to all the data structures in a model.
 *  The model structure will get index 0, all others will be sequentially
 *  assigned after that.
d117 1
a117 1
nmg_m_reindex( m )
d122 1
a122 1
	struct faceuse		*fu;
a129 1
	register int		newindex;
a130 3
	/*
	 *  First pass:  just set the high bit on all index words
	 */
a131 2
	if( m->index != 0 )  rt_log("nmg_m_reindex() m->index=%d\n", m->index);

d134 1
d323 33
@


1.6
log
@Added nmg_index_of_struct
@
text
@d20 1
a20 1
static char RCSnmg_index[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_index.c,v 1.5 91/02/07 20:32:36 mike Exp $ (BRL)";
d459 1
a459 1
rt_log("nmg_m_reindex() oldmax=%d, newmax=%d\n", m->maxindex, newindex );
@


1.5
log
@Changed from NMG_LIST macros to RT_LIST macros, from rtlist.h
@
text
@d20 1
a20 1
static char RCSnmg_index[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_index.c,v 1.4 91/02/07 20:00:50 mike Exp $ (BRL)";
d32 68
d534 2
@


1.4
log
@Changed nmg_m_count() to return array of magic-number pointers
@
text
@d20 1
a20 1
static char RCSnmg_index[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_index.c,v 1.3 91/02/07 00:13:25 mike Exp $ (BRL)";
d71 1
a71 1
	for( NMG_LIST( r, nmgregion, &m->r_hd ) )  {
d78 1
a78 1
		for( NMG_LIST( s, shell, &r->s_hd ) )  {
d86 1
a86 1
			for( NMG_LIST( fu, faceuse, &s->fu_hd ) )  {
d101 1
a101 1
				for( NMG_LIST( lu, loopuse, &fu->lu_hd ) )  {
d115 1
a115 1
					if( NMG_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC )  {
d117 1
a117 1
						vu = NMG_LIST_FIRST( vertexuse, &lu->down_hd );
d133 1
a133 1
					for( NMG_LIST( eu, edgeuse, &lu->down_hd ) )  {
d161 1
a161 1
			for( NMG_LIST( lu, loopuse, &s->lu_hd ) )  {
d175 1
a175 1
				if( NMG_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC )  {
d177 1
a177 1
					vu = NMG_LIST_FIRST( vertexuse, &lu->down_hd );
d193 1
a193 1
				for( NMG_LIST( eu, edgeuse, &lu->down_hd ) )  {
d220 1
a220 1
			for( NMG_LIST( eu, edgeuse, &s->eu_hd ) )  {
d267 1
a267 1
	for( NMG_LIST( r, nmgregion, &m->r_hd ) )  {
d271 1
a271 1
		for( NMG_LIST( s, shell, &r->s_hd ) )  {
d276 1
a276 1
			for( NMG_LIST( fu, faceuse, &s->fu_hd ) )  {
d285 1
a285 1
				for( NMG_LIST( lu, loopuse, &fu->lu_hd ) )  {
d293 1
a293 1
					if( NMG_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC )  {
d295 1
a295 1
						vu = NMG_LIST_FIRST( vertexuse, &lu->down_hd );
d305 1
a305 1
					for( NMG_LIST( eu, edgeuse, &lu->down_hd ) )  {
d324 1
a324 1
			for( NMG_LIST( lu, loopuse, &s->lu_hd ) )  {
d332 1
a332 1
				if( NMG_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC )  {
d334 1
a334 1
					vu = NMG_LIST_FIRST( vertexuse, &lu->down_hd );
d344 1
a344 1
				for( NMG_LIST( eu, edgeuse, &lu->down_hd ) )  {
d362 1
a362 1
			for( NMG_LIST( eu, edgeuse, &s->eu_hd ) )  {
d480 1
a480 1
	for( NMG_LIST( r, nmgregion, &m->r_hd ) )  {
d487 1
a487 1
		for( NMG_LIST( s, shell, &r->s_hd ) )  {
d495 1
a495 1
			for( NMG_LIST( fu, faceuse, &s->fu_hd ) )  {
d510 1
a510 1
				for( NMG_LIST( lu, loopuse, &fu->lu_hd ) )  {
d524 1
a524 1
					if( NMG_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC )  {
d543 1
a543 1
					for( NMG_LIST( eu, edgeuse, &lu->down_hd ) )  {
d572 1
a572 1
			for( NMG_LIST( lu, loopuse, &s->lu_hd ) )  {
d586 1
a586 1
				if( NMG_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC )  {
d589 1
a589 1
					vu = NMG_LIST_FIRST( vertexuse, &lu->down_hd );
d606 1
a606 1
				for( NMG_LIST( eu, edgeuse, &lu->down_hd ) )  {
d634 1
a634 1
			for( NMG_LIST( eu, edgeuse, &s->eu_hd ) )  {
@


1.3
log
@Moved nmg_struct_counts to nmg.h
@
text
@d20 1
a20 1
static char RCSnmg_index[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_index.c,v 1.2 91/02/06 22:22:11 mike Exp $ (BRL)";
d442 5
d448 1
a448 1
void
d450 2
a451 2
struct nmg_struct_counts	*ctr;
struct model			*m;
d463 1
a463 1
	long			*flags;
d466 2
a467 2
	if( flags[(_p)->index] == 0 )  { \
		flags[(_p)->index] = 1; \
d471 1
a471 1
	flags = (long *)rt_calloc( m->maxindex, sizeof(long), "nmg_m_count flags[]");
d675 2
a676 1
	rt_free( (char *)flags, "flags[]" );
@


1.2
log
@Fleshed out code
@
text
@d20 1
a20 1
static char RCSnmg_index[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_index.c,v 1.1 91/02/06 17:22:49 mike Exp $ (BRL)";
a31 3

extern void	nmg_m_reindex();

d396 7
a402 41
/*****/

struct nmg_counter {
	/* Actual structure counts */
	long	model;
	long	model_a;
	long	region;
	long	region_a;
	long	shell;
	long	shell_a;
	long	face;
	long	face_g;
	long	faceuse;
	long	faceuse_a;
	long	loopuse;
	long	loopuse_a;
	long	loop;
	long	loop_g;
	long	edgeuse;
	long	edgeuse_a;
	long	edge;
	long	edge_g;
	long	vertexuse;
	long	vertexuse_a;
	long	vertex;
	long	vertex_g;
	/* Abstractions */
	long	max_structs;
	long	face_loops;
	long	face_edges;
	long	face_lone_verts;
	long	wire_loops;
	long	wire_loop_edges;
	long	wire_edges;
	long	wire_lone_verts;
	long	shells_of_lone_vert;
};

nmg_pr_count( ctr, str )
struct nmg_counter	*ctr;
char			*str;
d440 7
a446 3
nmg_m_count( ctr, m )
struct model		*m;
struct nmg_counter	*ctr;
@


1.1
log
@Initial revision
@
text
@d20 1
a20 1
static char RCSnmg_index[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 1.37 91/01/28 23:52:59 mike Exp $ (BRL)";
a34 14
struct nmg_counter {
	long	max_structs;
	long	regions;
	long	shells;
	long	faces;
	long	face_loops;
	long	face_edges;
	long	face_lone_verts;
	long	wire_loops;
	long	wire_loop_edges;
	long	wire_edges;
	long	lone_verts;
};

d37 6
d57 1
d59 1
d61 1
d63 1
d66 3
d72 2
a73 1
	/* First pass:  just set the high bit on all index words */
d76 5
a80 1
		r->index |= NMG_HIGH_BIT;
d83 5
a87 1
			s->index |= NMG_HIGH_BIT;
d91 12
a102 2
				fu->index |= NMG_HIGH_BIT;
				fu->f_p->index |= NMG_HIGH_BIT;
d106 12
a117 2
					lu->index |= NMG_HIGH_BIT;
					lu->l_p->index |= NMG_HIGH_BIT;
d122 12
a133 2
						vu->index |= NMG_HIGH_BIT;
						vu->v_p->index |= NMG_HIGH_BIT;
d138 12
a149 2
						eu->index |= NMG_HIGH_BIT;
						eu->e_p->index |= NMG_HIGH_BIT;
d152 8
a159 2
						vu->index |= NMG_HIGH_BIT;
						vu->v_p->index |= NMG_HIGH_BIT;
d166 12
a177 2
				lu->index |= NMG_HIGH_BIT;
				lu->l_p->index |= NMG_HIGH_BIT;
d182 12
a193 2
					vu->index |= NMG_HIGH_BIT;
					vu->v_p->index |= NMG_HIGH_BIT;
d198 12
a209 2
					eu->index |= NMG_HIGH_BIT;
					eu->e_p->index |= NMG_HIGH_BIT;
d212 8
a219 2
					vu->index |= NMG_HIGH_BIT;
					vu->v_p->index |= NMG_HIGH_BIT;
d225 12
a236 2
				eu->index |= NMG_HIGH_BIT;
				eu->e_p->index |= NMG_HIGH_BIT;
d239 8
a246 2
				vu->index |= NMG_HIGH_BIT;
				vu->v_p->index |= NMG_HIGH_BIT;
d251 8
a258 2
				vu->index |= NMG_HIGH_BIT;
				vu->v_p->index |= NMG_HIGH_BIT;
d263 4
a266 3
#define	NMG_ASSIGN_NEW_INDEX(_p)	\
	{ if( ((_p)->index & NMG_HIGH_BIT) != 0 ) \
		(_p)->index = newindex++; }
d268 2
a269 2
	/* Second pass:  assign new index number */
	newindex = 1;	/* model remains index 0 */
d273 1
d277 1
d282 5
a286 1
				NMG_ASSIGN_NEW_INDEX(fu->f_p);
d291 5
a295 1
					NMG_ASSIGN_NEW_INDEX(lu->l_p);
d301 5
a305 1
						NMG_ASSIGN_NEW_INDEX(vu->v_p);
d311 5
a315 1
						NMG_ASSIGN_NEW_INDEX(eu->e_p);
d319 4
a322 1
						NMG_ASSIGN_NEW_INDEX(vu->v_p);
d330 5
a334 1
				NMG_ASSIGN_NEW_INDEX(lu->l_p);
d340 5
a344 1
					NMG_ASSIGN_NEW_INDEX(vu->v_p);
d350 5
a354 1
					NMG_ASSIGN_NEW_INDEX(eu->e_p);
d358 4
a361 1
					NMG_ASSIGN_NEW_INDEX(vu->v_p);
d368 5
a372 1
				NMG_ASSIGN_NEW_INDEX(eu->e_p);
d376 4
a379 1
				NMG_ASSIGN_NEW_INDEX(vu->v_p);
d385 4
a388 1
				NMG_ASSIGN_NEW_INDEX(vu->v_p);
d392 2
a393 1
#if 0
d401 36
d442 24
a466 3
	rt_log("\t%6d regions\n", ctr->regions);
	rt_log("\t%6d shells\n", ctr->shells);
	rt_log("\t%6d faces\n", ctr->faces);
d473 2
a474 1
	rt_log("\t%6d lone_verts\n", ctr->lone_verts);
d484 1
d486 1
d488 4
d493 8
d502 5
d510 5
a514 1
		ctr->regions++;
d517 5
a521 1
			ctr->shells++;
d525 13
a537 1
				ctr->faces++;
d540 12
d553 1
d555 13
d572 1
d574 22
a595 1
						ctr->face_edges++;
d602 12
d615 16
a630 1
					ctr->lone_verts++;
d636 22
d665 22
d688 13
d703 1
@
