head	11.16;
access;
symbols
	ansi-20040405-merged:11.12.2.2
	postmerge-20040405-ansi:11.14
	premerge-20040404-ansi:11.13
	postmerge-autoconf:11.13
	autoconf-freeze:11.12.10.2
	premerge-autoconf:11.13
	ansi-20040316-freeze:11.12.2.1
	postmerge-20040315-windows:11.13
	premerge-20040315-windows:11.13
	windows-20040315-freeze:11.12.4.1
	autoconf-20031203:11.12
	autoconf-20031202:11.12
	autoconf-branch:11.12.0.10
	phong-branch:11.12.0.8
	photonmap-branch:11.12.0.6
	rel-6-1-DP:11.12
	windows-branch:11.12.0.4
	rel-6-0-2:11.10
	ansi-branch:11.12.0.2
	rel-6-0-1-branch:11.10.0.2
	hartley-6-0-post:11.11
	hartley-6-0-pre:11.10
	rel-6-0-1:11.10
	rel-6-0:11.10
	rel-5-4:11.7.2.1
	offsite-5-3-pre:11.9
	rel-5-3:11.7.2.1
	rel-5-2:11.7
	rel-5-1-branch:11.7.0.2
	rel-5-1:11.7
	rel-5-0:11.7
	rel-5-0-beta:11.6
	rel-4-5:11.6
	ctj-4-5-post:11.4
	ctj-4-5-pre:11.4
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.16
date	2004.05.21.18.07.34;	author morrison;	state dead;
branches;
next	11.15;

11.15
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.14;

11.14
date	2004.04.05.08.48.58;	author morrison;	state Exp;
branches;
next	11.13;

11.13
date	2004.02.02.17.39.28;	author morrison;	state Exp;
branches;
next	11.12;

11.12
date	2002.08.20.17.08.08;	author jra;	state Exp;
branches
	11.12.2.1
	11.12.4.1
	11.12.10.1;
next	11.11;

11.11
date	2002.08.15.20.55.20;	author hartley;	state Exp;
branches;
next	11.10;

11.10
date	2001.04.20.22.29.55;	author morrison;	state Exp;
branches;
next	11.9;

11.9
date	2000.11.14.21.13.22;	author jra;	state Exp;
branches;
next	11.8;

11.8
date	2000.07.10.23.01.47;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	99.06.03.01.39.15;	author mike;	state Exp;
branches
	11.7.2.1;
next	11.6;

11.6
date	97.10.06.21.35.36;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	97.09.18.20.32.45;	author jra;	state Exp;
branches;
next	11.4;

11.4
date	96.12.31.01.09.27;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	95.12.01.02.49.33;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	95.11.30.17.51.52;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.53.54;	author mike;	state Rel4_4;
branches
	11.1.1.1;
next	10.8;

10.8
date	94.11.08.01.04.37;	author mike;	state Exp;
branches;
next	10.7;

10.7
date	94.11.05.00.21.42;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	94.08.11.01.19.26;	author gdurf;	state Exp;
branches;
next	10.5;

10.5
date	92.06.02.22.52.08;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	92.05.29.01.20.11;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	92.05.29.00.52.30;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	92.05.28.22.12.16;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.39.14;	author mike;	state Rel4_0;
branches;
next	1.3;

1.3
date	91.06.23.03.42.22;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	91.06.14.09.42.24;	author stay;	state Exp;
branches;
next	1.1;

1.1
date	91.05.18.02.36.04;	author stay;	state Exp;
branches;
next	;

11.1.1.1
date	98.01.29.06.43.38;	author mike;	state Rel4_5;
branches;
next	;

11.7.2.1
date	2000.11.14.21.35.30;	author jra;	state Exp;
branches;
next	;

11.12.2.1
date	2002.09.19.18.01.46;	author morrison;	state Exp;
branches;
next	11.12.2.2;

11.12.2.2
date	2004.03.17.21.18.56;	author morrison;	state Exp;
branches;
next	;

11.12.4.1
date	2004.03.11.23.43.44;	author morrison;	state Exp;
branches;
next	;

11.12.10.1
date	2004.02.12.18.37.46;	author erikg;	state Exp;
branches;
next	11.12.10.2;

11.12.10.2
date	2004.03.15.14.07.28;	author erikg;	state Exp;
branches;
next	;


desc
@Utility routines
@


11.16
log
@moved to src/
@
text
@/*
 *			N U R B _ U T I L . C
 *
 *  Function -
 *	Utilities for NURB curves and surfaces.
 *
 *  Author -
 *	Paul Randal Stay
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1994-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/nurb_util.c,v 11.15 2004/05/10 15:30:46 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include "machine.h"
#include "vmath.h"
#include "nmg.h"
#include "raytrace.h"
#include "nurb.h"

/* Create a place holder for a nurb surface. */

struct face_g_snurb *
rt_nurb_new_snurb(int u_order, int v_order, int n_u, int n_v, int n_rows, int n_cols, int pt_type, struct resource *res)
{
	register struct face_g_snurb * srf;
	int pnum;
	
	GET_SNURB(srf);
	srf->order[0] = u_order;
	srf->order[1] = v_order;
	srf->dir = RT_NURB_SPLIT_ROW;

	srf->u.k_size = n_u;
	srf->v.k_size = n_v;
	srf->s_size[0] = n_rows;
	srf->s_size[1] = n_cols;
	srf->pt_type = pt_type;

	pnum = sizeof (fastf_t) * n_rows * n_cols * RT_NURB_EXTRACT_COORDS(pt_type);

	srf->u.knots = (fastf_t *) bu_malloc ( 
			n_u * sizeof (fastf_t ), "rt_nurb_new_snurb: u kv knot values");
	srf->v.knots = (fastf_t *) bu_malloc ( 
			n_v * sizeof (fastf_t ), "rt_nurb_new_snurb: v kv knot values");
	srf->ctl_points = ( fastf_t *) bu_malloc( 
			pnum, "rt_nurb_new_snurb: control mesh points");

	return srf;
}

/* Create a place holder for a new nurb curve. */
struct edge_g_cnurb *
rt_nurb_new_cnurb(int order, int n_knots, int n_pts, int pt_type)
{
	register struct edge_g_cnurb * crv;

	GET_CNURB(crv);
	crv->order = order;

	crv->k.k_size = n_knots;
	crv->k.knots = (fastf_t *)
		bu_malloc(n_knots * sizeof(fastf_t),
			"rt_nurb_new_cnurb: knot values");

	crv->c_size = n_pts;
	crv->pt_type = pt_type;

	crv->ctl_points = (fastf_t *)
		bu_malloc( sizeof(fastf_t) * RT_NURB_EXTRACT_COORDS(pt_type) *
			n_pts, 
			"rt_nurb_new_cnurb: mesh point values");

	return crv;
}

/*
 *			R T _ N U R B _ C L E A N _ S N U R B
 *
 *  Clean up the storage use of an snurb, but don't release the pointer.
 *  Often used by routines that allocate an array of nurb pointers,
 *  or use automatic variables to hold one.
 */
void
rt_nurb_clean_snurb(struct face_g_snurb *srf, struct resource *res)
{
	NMG_CK_SNURB(srf);

	bu_free( (char *)srf->u.knots, "rt_nurb_clean_snurb() u.knots" );
	bu_free( (char *)srf->v.knots, "rt_nurb_free_snurb() v.knots" );
	bu_free( (char *)srf->ctl_points, "rt_nurb_free_snurb() ctl_points");

	/* Invalidate the structure */
	srf->u.knots = (fastf_t *)NULL;
	srf->v.knots = (fastf_t *)NULL;
	srf->ctl_points = (fastf_t *)NULL;
	srf->order[0] = srf->order[1] = -1;
	srf->l.magic = 0;
}

/*
 *			R T _ N U R B _ F R E E _ S N U R B
 */
void
rt_nurb_free_snurb(struct face_g_snurb *srf, struct resource *res)
{
	NMG_CK_SNURB(srf);

	/* assume that links to other surface and curves are already deleted */

	bu_free( (char *)srf->u.knots, "rt_nurb_free_snurb: u kv knots" );
	bu_free( (char *)srf->v.knots, "rt_nurb_free_snurb: v kv knots" );
	bu_free( (char *)srf->ctl_points, "rt_nurb_free_snurb: mesh points");

	srf->l.magic = 0;
	bu_free( (char *)srf, "rt_nurb_free_snurb: snurb struct" );
}


/*
 *			R T _ N U R B _ C L E A N _ C N U R B
 *
 *  Clean up the storage use of a cnurb, but don't release the pointer.
 *  Often used by routines that allocate an array of nurb pointers,
 *  or use automatic variables to hold one.
 */
void
rt_nurb_clean_cnurb(struct edge_g_cnurb *crv)
{
	NMG_CK_CNURB(crv);
	bu_free( (char*)crv->k.knots, "rt_nurb_free_cnurb: knots");
	bu_free( (char*)crv->ctl_points, "rt_nurb_free_cnurb: control points");
	/* Invalidate the structure */
	crv->k.knots = (fastf_t *)NULL;
	crv->ctl_points = (fastf_t *)NULL;
	crv->c_size = 0;
	crv->order = -1;
	crv->l.magic = 0;
}

/*
 *			R T _ N U R B _ F R E E _ C N U R B
 *
 *  Release a cnurb and all the storage that it references.
 */
void
rt_nurb_free_cnurb(struct edge_g_cnurb *crv)
{
	NMG_CK_CNURB(crv);
	bu_free( (char*)crv->k.knots, "rt_nurb_free_cnurb: knots");
	bu_free( (char*)crv->ctl_points, "rt_nurb_free_cnurb: control points");
	crv->l.magic = 0;		/* sanity */
	bu_free( (char*)crv, "rt_nurb_free_cnurb: cnurb struct");
}

void
rt_nurb_c_print(const struct edge_g_cnurb *crv)
{
	register fastf_t * ptr;
	int i,j;

	NMG_CK_CNURB(crv);
	bu_log("curve = {\n");
	bu_log("\tOrder = %d\n", crv->order);
	bu_log("\tKnot Vector = {\n\t\t");

	for( i = 0; i < crv->k.k_size; i++)
		bu_log("%10.8f ", crv->k.knots[i]);

	bu_log("\n\t}\n");
	bu_log("\t");
	rt_nurb_print_pt_type(crv->pt_type);
	bu_log("\tmesh = {\n");
	for( ptr = &crv->ctl_points[0], i= 0;
		i < crv->c_size; i++, ptr += RT_NURB_EXTRACT_COORDS(crv->pt_type))
	{
		bu_log("\t\t");
		for(j = 0; j < RT_NURB_EXTRACT_COORDS(crv->pt_type); j++)
			bu_log("%4.5f\t", ptr[j]);
		bu_log("\n");

	}
	bu_log("\t}\n}\n");
	

}

void
rt_nurb_s_print(char *c, const struct face_g_snurb *srf)
{

    bu_log("%s\n", c );

    bu_log("order %d %d\n", srf->order[0], srf->order[1] );

    bu_log( "u knot vector \n");

    rt_nurb_pr_kv( &srf->u );

    bu_log( "v knot vector \n");

    rt_nurb_pr_kv( &srf->v );

    rt_nurb_pr_mesh( srf );

}

void
rt_nurb_pr_kv(const struct knot_vector *kv)
{
    register fastf_t * ptr = kv->knots;
    int i;

    bu_log("[%d]\t", kv->k_size );


    for( i = 0; i < kv->k_size; i++)
    {
	bu_log("%2.5f  ", *ptr++);
    }
    bu_log("\n");
}

void
rt_nurb_pr_mesh(const struct face_g_snurb *m)
{
	int i,j,k;
	fastf_t * m_ptr = m->ctl_points;
	int evp = RT_NURB_EXTRACT_COORDS(m->pt_type);

	NMG_CK_SNURB(m);

	bu_log("\t[%d] [%d]\n", m->s_size[0], m->s_size[1] );

	for( i = 0; i < m->s_size[0]; i++)
	{
		for( j =0; j < m->s_size[1]; j++)
		{
			bu_log("\t");

			for(k = 0; k < evp; k++)
				bu_log("%f    ", m_ptr[k]);

			bu_log("\n");
			m_ptr += RT_NURB_EXTRACT_COORDS(m->pt_type);
		}
		bu_log("\n");
	}
}

void
rt_nurb_print_pt_type(int c)
{
	int rat;

	rat = RT_NURB_IS_PT_RATIONAL(c);
	
	if( RT_NURB_EXTRACT_PT_TYPE(c) == RT_NURB_PT_XY)
		bu_log("Point Type = RT_NURB_PT_XY");
	else 
	if( RT_NURB_EXTRACT_PT_TYPE(c) == RT_NURB_PT_XYZ)
		bu_log("Point Type = RT_NURB_PT_XYX");
	else 
	if( RT_NURB_EXTRACT_PT_TYPE(c) == RT_NURB_PT_UV)
		bu_log("Point Type = RT_NURB_PT_UV");

	if( rat )
		bu_log("W\n");
	else
		bu_log("\n");
}
@


11.15
log
@change conf.h to a wrapped config.h
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/librt/nurb_util.c,v 11.14 2004/04/05 08:48:58 morrison Exp $ (ARL)";
@


11.14
log
@merge of ansi-6-0-branch into HEAD
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d27 5
a31 1
#include "conf.h"
@


11.13
log
@update copyright to include span through 2003
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nurb_util.c,v 11.12 2002/08/20 17:08:08 jra Exp $ (ARL)";
d39 1
a39 3
rt_nurb_new_snurb(u_order, v_order, n_u, n_v, n_rows, n_cols, pt_type, res)
int u_order, v_order, n_u, n_v, n_rows, n_cols, pt_type;
struct resource *res;
d69 1
a69 2
rt_nurb_new_cnurb( order, n_knots, n_pts, pt_type)
int order, n_knots, n_pts, pt_type;
d100 1
a100 3
rt_nurb_clean_snurb( srf, res )
struct face_g_snurb * srf;
struct resource *res;
d120 1
a120 3
rt_nurb_free_snurb( srf, res )
struct face_g_snurb * srf;
struct resource *res;
d143 1
a143 2
rt_nurb_clean_cnurb( crv )
struct edge_g_cnurb * crv;
d162 1
a162 2
rt_nurb_free_cnurb( crv)
struct edge_g_cnurb * crv;
d172 1
a172 2
rt_nurb_c_print( crv)
const struct edge_g_cnurb * crv;
d204 1
a204 3
rt_nurb_s_print( c, srf )
char * c;
const struct face_g_snurb * srf;
d224 1
a224 2
rt_nurb_pr_kv( kv )
const struct knot_vector * kv;
d240 1
a240 2
rt_nurb_pr_mesh( m )
const struct face_g_snurb * m;
d267 1
a267 2
rt_nurb_print_pt_type(c)
int c;
@


11.12
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1994 by the United States Army
d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nurb_util.c,v 11.10 2001/04/20 22:29:55 morrison Exp $ (ARL)";
@


11.12.4.1
log
@sync to HEAD...
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1994-2004 by the United States Army
d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/nurb_util.c,v 11.13 2004/02/02 17:39:28 morrison Exp $ (ARL)";
@


11.12.10.1
log
@merge from HEAD
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1994-2004 by the United States Army
d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nurb_util.c,v 11.13 2004/02/02 17:39:28 morrison Exp $ (ARL)";
@


11.12.10.2
log
@merge from head
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nurb_util.c,v 11.12.10.1 2004/02/12 18:37:46 erikg Exp $ (ARL)";
@


11.12.2.1
log
@Initial ANSIfication
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nurb_util.c,v 11.12 2002/08/20 17:08:08 jra Exp $ (ARL)";
d39 3
a41 1
rt_nurb_new_snurb(int u_order, int v_order, int n_u, int n_v, int n_rows, int n_cols, int pt_type, struct resource *res)
d71 2
a72 1
rt_nurb_new_cnurb(int order, int n_knots, int n_pts, int pt_type)
d103 3
a105 1
rt_nurb_clean_snurb(struct face_g_snurb *srf, struct resource *res)
d125 3
a127 1
rt_nurb_free_snurb(struct face_g_snurb *srf, struct resource *res)
d150 2
a151 1
rt_nurb_clean_cnurb(struct edge_g_cnurb *crv)
d170 2
a171 1
rt_nurb_free_cnurb(struct edge_g_cnurb *crv)
d181 2
a182 1
rt_nurb_c_print(const struct edge_g_cnurb *crv)
d214 3
a216 1
rt_nurb_s_print(char *c, const struct face_g_snurb *srf)
d236 2
a237 1
rt_nurb_pr_kv(const struct knot_vector *kv)
d253 2
a254 1
rt_nurb_pr_mesh(const struct face_g_snurb *m)
d281 2
a282 1
rt_nurb_print_pt_type(int c)
@


11.12.2.2
log
@sync branch with HEAD
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1994-2004 by the United States Army
d24 1
a24 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
@


11.11
log
@Converted from K&R to ANSI C - RFH
@
text
@d39 3
a41 1
rt_nurb_new_snurb(int u_order, int v_order, int n_u, int n_v, int n_rows, int n_cols, int pt_type, struct resource *res)
d71 2
a72 1
rt_nurb_new_cnurb(int order, int n_knots, int n_pts, int pt_type)
d103 3
a105 1
rt_nurb_clean_snurb(struct face_g_snurb *srf, struct resource *res)
d125 3
a127 1
rt_nurb_free_snurb(struct face_g_snurb *srf, struct resource *res)
d150 2
a151 1
rt_nurb_clean_cnurb(struct edge_g_cnurb *crv)
d170 2
a171 1
rt_nurb_free_cnurb(struct edge_g_cnurb *crv)
d181 2
a182 1
rt_nurb_c_print(const struct edge_g_cnurb *crv)
d214 3
a216 1
rt_nurb_s_print(char *c, const struct face_g_snurb *srf)
d236 2
a237 1
rt_nurb_pr_kv(const struct knot_vector *kv)
d253 2
a254 1
rt_nurb_pr_mesh(const struct face_g_snurb *m)
d281 2
a282 1
rt_nurb_print_pt_type(int c)
@


11.10
log
@CONST to const
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nurb_util.c,v 11.9 2000/11/14 21:13:22 jra Exp $ (ARL)";
d39 1
a39 3
rt_nurb_new_snurb(u_order, v_order, n_u, n_v, n_rows, n_cols, pt_type, res)
int u_order, v_order, n_u, n_v, n_rows, n_cols, pt_type;
struct resource *res;
d69 1
a69 2
rt_nurb_new_cnurb( order, n_knots, n_pts, pt_type)
int order, n_knots, n_pts, pt_type;
d100 1
a100 3
rt_nurb_clean_snurb( srf, res )
struct face_g_snurb * srf;
struct resource *res;
d120 1
a120 3
rt_nurb_free_snurb( srf, res )
struct face_g_snurb * srf;
struct resource *res;
d143 1
a143 2
rt_nurb_clean_cnurb( crv )
struct edge_g_cnurb * crv;
d162 1
a162 2
rt_nurb_free_cnurb( crv)
struct edge_g_cnurb * crv;
d172 1
a172 2
rt_nurb_c_print( crv)
const struct edge_g_cnurb * crv;
d204 1
a204 3
rt_nurb_s_print( c, srf )
char * c;
const struct face_g_snurb * srf;
d224 1
a224 2
rt_nurb_pr_kv( kv )
const struct knot_vector * kv;
d240 1
a240 2
rt_nurb_pr_mesh( m )
const struct face_g_snurb * m;
d267 1
a267 2
rt_nurb_print_pt_type(c)
int c;
@


11.9
log
@Eliminated pmalloc (a failed experiment)
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nurb_util.c,v 11.8 2000/07/10 23:01:47 mike Exp $ (ARL)";
d182 1
a182 1
CONST struct edge_g_cnurb * crv;
d216 1
a216 1
CONST struct face_g_snurb * srf;
d237 1
a237 1
CONST struct knot_vector * kv;
d254 1
a254 1
CONST struct face_g_snurb * m;
@


11.8
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nurb_util.c,v 11.7 1999/06/03 01:39:15 mike Exp $ (ARL)";
d59 1
a59 12
	if( res )
	{
		srf->u.knots = (fastf_t *) rt_pmalloc ( 
			n_u * sizeof (fastf_t ), &res->re_pmem);
		srf->v.knots = (fastf_t *) rt_pmalloc ( 
			n_v * sizeof (fastf_t ), &res->re_pmem);
		srf->ctl_points = ( fastf_t *) rt_pmalloc( 
			pnum, &res->re_pmem);
	}
	else
	{
		srf->u.knots = (fastf_t *) bu_malloc ( 
d61 1
a61 1
		srf->v.knots = (fastf_t *) bu_malloc ( 
d63 1
a63 1
		srf->ctl_points = ( fastf_t *) bu_malloc( 
a64 1
	}
d109 4
a112 12
	if( res )
	{
		rt_pfree( (char *)srf->u.knots, &res->re_pmem );
		rt_pfree( (char *)srf->v.knots, &res->re_pmem );
		rt_pfree( (char *)srf->ctl_points, &res->re_pmem );
	}
	else
	{
		bu_free( (char *)srf->u.knots, "rt_nurb_clean_snurb() u.knots" );
		bu_free( (char *)srf->v.knots, "rt_nurb_free_snurb() v.knots" );
		bu_free( (char *)srf->ctl_points, "rt_nurb_free_snurb() ctl_points");
	}
d133 3
a135 13
	if( res )
	{
		rt_pfree( (char *)srf->u.knots, &res->re_pmem );
		rt_pfree( (char *)srf->v.knots, &res->re_pmem );
		rt_pfree( (char *)srf->ctl_points, &res->re_pmem);
	}
	else
	{

		bu_free( (char *)srf->u.knots, "rt_nurb_free_snurb: u kv knots" );
		bu_free( (char *)srf->v.knots, "rt_nurb_free_snurb: v kv knots" );
		bu_free( (char *)srf->ctl_points, "rt_nurb_free_snurb: mesh points");
	}
@


11.7
log
@
sed4
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nurb_util.c,v 11.6 1997/10/06 21:35:36 mike Exp $ (ARL)";
@


11.7.2.1
log
@Eliminated pmalloc (a failed experiment)
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nurb_util.c,v 11.7 1999/06/03 01:39:15 mike Exp $ (ARL)";
d59 12
a70 1
	srf->u.knots = (fastf_t *) bu_malloc ( 
d72 1
a72 1
	srf->v.knots = (fastf_t *) bu_malloc ( 
d74 1
a74 1
	srf->ctl_points = ( fastf_t *) bu_malloc( 
d76 1
d121 12
a132 4
	bu_free( (char *)srf->u.knots, "rt_nurb_clean_snurb() u.knots" );
	bu_free( (char *)srf->v.knots, "rt_nurb_free_snurb() v.knots" );
	bu_free( (char *)srf->ctl_points, "rt_nurb_free_snurb() ctl_points");

d153 13
a165 3
	bu_free( (char *)srf->u.knots, "rt_nurb_free_snurb: u kv knots" );
	bu_free( (char *)srf->v.knots, "rt_nurb_free_snurb: v kv knots" );
	bu_free( (char *)srf->ctl_points, "rt_nurb_free_snurb: mesh points");
@


11.6
log
@rt_pmalloc
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nurb_util.c,v 11.5 1997/09/18 20:32:45 jra Exp mike $ (ARL)";
d70 1
a70 1
		srf->u.knots = (fastf_t *) rt_malloc ( 
d72 1
a72 1
		srf->v.knots = (fastf_t *) rt_malloc ( 
d74 1
a74 1
		srf->ctl_points = ( fastf_t *) rt_malloc( 
d93 1
a93 1
		rt_malloc(n_knots * sizeof(fastf_t),
d100 1
a100 1
		rt_malloc( sizeof(fastf_t) * RT_NURB_EXTRACT_COORDS(pt_type) *
d129 3
a131 3
		rt_free( (char *)srf->u.knots, "rt_nurb_clean_snurb() u.knots" );
		rt_free( (char *)srf->v.knots, "rt_nurb_free_snurb() v.knots" );
		rt_free( (char *)srf->ctl_points, "rt_nurb_free_snurb() ctl_points");
d162 3
a164 3
		rt_free( (char *)srf->u.knots, "rt_nurb_free_snurb: u kv knots" );
		rt_free( (char *)srf->v.knots, "rt_nurb_free_snurb: v kv knots" );
		rt_free( (char *)srf->ctl_points, "rt_nurb_free_snurb: mesh points");
d168 1
a168 1
	rt_free( (char *)srf, "rt_nurb_free_snurb: snurb struct" );
d184 2
a185 2
	rt_free( (char*)crv->k.knots, "rt_nurb_free_cnurb: knots");
	rt_free( (char*)crv->ctl_points, "rt_nurb_free_cnurb: control points");
d204 2
a205 2
	rt_free( (char*)crv->k.knots, "rt_nurb_free_cnurb: knots");
	rt_free( (char*)crv->ctl_points, "rt_nurb_free_cnurb: control points");
d207 1
a207 1
	rt_free( (char*)crv, "rt_nurb_free_cnurb: cnurb struct");
@


11.5
log
@Mods for use of pmalloc in TNURB raytracing.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nurb_util.c,v 11.4 1996/12/31 01:09:27 mike Exp jra $ (ARL)";
d61 1
a61 1
		srf->u.knots = (fastf_t *) pmalloc ( 
d63 1
a63 1
		srf->v.knots = (fastf_t *) pmalloc ( 
d65 1
a65 1
		srf->ctl_points = ( fastf_t *) pmalloc( 
d123 3
a125 3
		pfree( (char *)srf->u.knots, &res->re_pmem );
		pfree( (char *)srf->v.knots, &res->re_pmem );
		pfree( (char *)srf->ctl_points, &res->re_pmem );
d155 3
a157 3
		pfree( (char *)srf->u.knots, &res->re_pmem );
		pfree( (char *)srf->v.knots, &res->re_pmem );
		pfree( (char *)srf->ctl_points, &res->re_pmem);
@


11.4
log
@libbu
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nurb_util.c,v 11.3 1995/12/01 02:49:33 mike Exp mike $ (ARL)";
d39 1
a39 1
rt_nurb_new_snurb(u_order, v_order, n_u, n_v, n_rows, n_cols, pt_type)
d41 1
a52 6

	srf->u.knots = (fastf_t *) rt_malloc ( 
		n_u * sizeof (fastf_t ), "rt_nurb_new_snurb: u kv knot values");
	srf->v.knots = (fastf_t *) rt_malloc ( 
		n_v * sizeof (fastf_t ), "rt_nurb_new_snurb: v kv knot values");

d56 1
a56 1
	
d58 19
a76 2
	srf->ctl_points = ( fastf_t *) rt_malloc( 
		pnum, "rt_nurb_new_snurb: control mesh points");
d115 1
a115 1
rt_nurb_clean_snurb( srf )
d117 1
d121 12
a132 3
	rt_free( (char *)srf->u.knots, "rt_nurb_clean_snurb() u.knots" );
	rt_free( (char *)srf->v.knots, "rt_nurb_free_snurb() v.knots" );
	rt_free( (char *)srf->ctl_points, "rt_nurb_free_snurb() ctl_points");
d145 1
a145 1
rt_nurb_free_snurb( srf )
d147 1
d153 13
a165 3
	rt_free( (char *)srf->u.knots, "rt_nurb_free_snurb: u kv knots" );
	rt_free( (char *)srf->v.knots, "rt_nurb_free_snurb: v kv knots" );
	rt_free( (char *)srf->ctl_points, "rt_nurb_free_snurb: mesh points");
@


11.3
log
@LIBNURB data structures have been fully merged withNMG data structures.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/libnurb/RCS/nurb_util.c,v 11.1 1995/01/04 09:53:54 mike Rel4_4 jra $ (ARL)";
d185 3
a187 3
	rt_log("curve = {\n");
	rt_log("\tOrder = %d\n", crv->order);
	rt_log("\tKnot Vector = {\n\t\t");
d190 1
a190 1
		rt_log("%10.8f ", crv->k.knots[i]);
d192 2
a193 2
	rt_log("\n\t}\n");
	rt_log("\t");
d195 1
a195 1
	rt_log("\tmesh = {\n");
d199 1
a199 1
		rt_log("\t\t");
d201 2
a202 2
			rt_log("%4.5f\t", ptr[j]);
		rt_log("\n");
d205 1
a205 1
	rt_log("\t}\n}\n");
d216 1
a216 1
    rt_log("%s\n", c );
d218 1
a218 1
    rt_log("order %d %d\n", srf->order[0], srf->order[1] );
d220 1
a220 1
    rt_log( "u knot vector \n");
d224 1
a224 1
    rt_log( "v knot vector \n");
d239 1
a239 1
    rt_log("[%d]\t", kv->k_size );
d244 1
a244 1
	rt_log("%2.5f  ", *ptr++);
d246 1
a246 1
    rt_log("\n");
d259 1
a259 1
	rt_log("\t[%d] [%d]\n", m->s_size[0], m->s_size[1] );
d265 1
a265 1
			rt_log("\t");
d268 1
a268 1
				rt_log("%f    ", m_ptr[k]);
d270 1
a270 1
			rt_log("\n");
d273 1
a273 1
		rt_log("\n");
d286 1
a286 1
		rt_log("Point Type = RT_NURB_PT_XY");
d289 1
a289 1
		rt_log("Point Type = RT_NURB_PT_XYX");
d292 1
a292 1
		rt_log("Point Type = RT_NURB_PT_UV");
d295 1
a295 1
		rt_log("W\n");
d297 1
a297 1
		rt_log("\n");
@


11.2
log
@Increased digits in rt_nurb_c_print() knot print.
@
text
@d38 3
a40 3
struct snurb *
rt_nurb_new_snurb(u_order, v_order, n_u_knots, n_v_knots, n_rows, n_cols, pt_type)
int u_order, v_order, n_u_knots, n_v_knots, n_rows, n_cols, pt_type;
d42 1
a42 1
	register struct snurb * srf;
d50 2
a51 2
	srf->u_knots.k_size = n_u_knots;
	srf->v_knots.k_size = n_v_knots;
d53 4
a56 4
	srf->u_knots.knots = (fastf_t *) rt_malloc ( 
		n_u_knots * sizeof (fastf_t ), "rt_nurb_new_snurb: u kv knot values");
	srf->v_knots.knots = (fastf_t *) rt_malloc ( 
		n_v_knots * sizeof (fastf_t ), "rt_nurb_new_snurb: v kv knot values");
d70 1
a70 1
struct cnurb *
d74 1
a74 1
	register struct cnurb * crv;
d79 2
a80 2
	crv->knot.k_size = n_knots;
	crv->knot.knots = (fastf_t *)
d104 1
a104 1
struct snurb * srf;
d108 2
a109 2
	rt_free( (char *)srf->u_knots.knots, "rt_nurb_clean_snurb() u_knots.knots" );
	rt_free( (char *)srf->v_knots.knots, "rt_nurb_free_snurb() v_knots.knots" );
d112 2
a113 2
	srf->u_knots.knots = (fastf_t *)NULL;
	srf->v_knots.knots = (fastf_t *)NULL;
d124 1
a124 1
struct snurb * srf;
d130 2
a131 2
	rt_free( (char *)srf->u_knots.knots, "rt_nurb_free_snurb: u kv knots" );
	rt_free( (char *)srf->v_knots.knots, "rt_nurb_free_snurb: v kv knots" );
d148 1
a148 1
struct cnurb * crv;
d151 1
a151 1
	rt_free( (char*)crv->knot.knots, "rt_nurb_free_cnurb: knots");
d154 1
a154 1
	crv->knot.knots = (fastf_t *)NULL;
d168 1
a168 1
struct cnurb * crv;
d171 1
a171 1
	rt_free( (char*)crv->knot.knots, "rt_nurb_free_cnurb: knots");
d179 1
a179 1
CONST struct cnurb * crv;
d189 2
a190 2
	for( i = 0; i < crv->knot.k_size; i++)
		rt_log("%10.8f ", crv->knot.knots[i]);
d213 1
a213 1
CONST struct snurb * srf;
d222 1
a222 1
    rt_nurb_pr_kv( &srf->u_knots );
d226 1
a226 1
    rt_nurb_pr_kv( &srf->v_knots );
d251 1
a251 1
CONST struct snurb * m;
@


11.1
log
@Release_4.4
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/libnurb/RCS/nurb_util.c,v 10.8 94/11/08 01:04:37 mike Exp $ (ARL)";
d190 1
a190 1
		rt_log("%3.2f  ", crv->knot.knots[i]);
@


11.1.1.1
log
@Release_4.5
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad4.5/RCS/nurb_util.c,v 11.6 1997/10/06 21:35:36 mike Exp $ (ARL)";
d38 3
a40 4
struct face_g_snurb *
rt_nurb_new_snurb(u_order, v_order, n_u, n_v, n_rows, n_cols, pt_type, res)
int u_order, v_order, n_u, n_v, n_rows, n_cols, pt_type;
struct resource *res;
d42 1
a42 1
	register struct face_g_snurb * srf;
d50 8
a57 2
	srf->u.k_size = n_u;
	srf->v.k_size = n_v;
d61 1
a61 1

d63 2
a64 19

	if( res )
	{
		srf->u.knots = (fastf_t *) rt_pmalloc ( 
			n_u * sizeof (fastf_t ), &res->re_pmem);
		srf->v.knots = (fastf_t *) rt_pmalloc ( 
			n_v * sizeof (fastf_t ), &res->re_pmem);
		srf->ctl_points = ( fastf_t *) rt_pmalloc( 
			pnum, &res->re_pmem);
	}
	else
	{
		srf->u.knots = (fastf_t *) rt_malloc ( 
			n_u * sizeof (fastf_t ), "rt_nurb_new_snurb: u kv knot values");
		srf->v.knots = (fastf_t *) rt_malloc ( 
			n_v * sizeof (fastf_t ), "rt_nurb_new_snurb: v kv knot values");
		srf->ctl_points = ( fastf_t *) rt_malloc( 
			pnum, "rt_nurb_new_snurb: control mesh points");
	}
d70 1
a70 1
struct edge_g_cnurb *
d74 1
a74 1
	register struct edge_g_cnurb * crv;
d79 2
a80 2
	crv->k.k_size = n_knots;
	crv->k.knots = (fastf_t *)
d103 2
a104 3
rt_nurb_clean_snurb( srf, res )
struct face_g_snurb * srf;
struct resource *res;
d108 3
a110 12
	if( res )
	{
		rt_pfree( (char *)srf->u.knots, &res->re_pmem );
		rt_pfree( (char *)srf->v.knots, &res->re_pmem );
		rt_pfree( (char *)srf->ctl_points, &res->re_pmem );
	}
	else
	{
		rt_free( (char *)srf->u.knots, "rt_nurb_clean_snurb() u.knots" );
		rt_free( (char *)srf->v.knots, "rt_nurb_free_snurb() v.knots" );
		rt_free( (char *)srf->ctl_points, "rt_nurb_free_snurb() ctl_points");
	}
d112 2
a113 2
	srf->u.knots = (fastf_t *)NULL;
	srf->v.knots = (fastf_t *)NULL;
d123 2
a124 3
rt_nurb_free_snurb( srf, res )
struct face_g_snurb * srf;
struct resource *res;
d130 3
a132 13
	if( res )
	{
		rt_pfree( (char *)srf->u.knots, &res->re_pmem );
		rt_pfree( (char *)srf->v.knots, &res->re_pmem );
		rt_pfree( (char *)srf->ctl_points, &res->re_pmem);
	}
	else
	{

		rt_free( (char *)srf->u.knots, "rt_nurb_free_snurb: u kv knots" );
		rt_free( (char *)srf->v.knots, "rt_nurb_free_snurb: v kv knots" );
		rt_free( (char *)srf->ctl_points, "rt_nurb_free_snurb: mesh points");
	}
d148 1
a148 1
struct edge_g_cnurb * crv;
d151 1
a151 1
	rt_free( (char*)crv->k.knots, "rt_nurb_free_cnurb: knots");
d154 1
a154 1
	crv->k.knots = (fastf_t *)NULL;
d168 1
a168 1
struct edge_g_cnurb * crv;
d171 1
a171 1
	rt_free( (char*)crv->k.knots, "rt_nurb_free_cnurb: knots");
d179 1
a179 1
CONST struct edge_g_cnurb * crv;
d185 3
a187 3
	bu_log("curve = {\n");
	bu_log("\tOrder = %d\n", crv->order);
	bu_log("\tKnot Vector = {\n\t\t");
d189 2
a190 2
	for( i = 0; i < crv->k.k_size; i++)
		bu_log("%10.8f ", crv->k.knots[i]);
d192 2
a193 2
	bu_log("\n\t}\n");
	bu_log("\t");
d195 1
a195 1
	bu_log("\tmesh = {\n");
d199 1
a199 1
		bu_log("\t\t");
d201 2
a202 2
			bu_log("%4.5f\t", ptr[j]);
		bu_log("\n");
d205 1
a205 1
	bu_log("\t}\n}\n");
d213 1
a213 1
CONST struct face_g_snurb * srf;
d216 1
a216 1
    bu_log("%s\n", c );
d218 1
a218 1
    bu_log("order %d %d\n", srf->order[0], srf->order[1] );
d220 1
a220 1
    bu_log( "u knot vector \n");
d222 1
a222 1
    rt_nurb_pr_kv( &srf->u );
d224 1
a224 1
    bu_log( "v knot vector \n");
d226 1
a226 1
    rt_nurb_pr_kv( &srf->v );
d239 1
a239 1
    bu_log("[%d]\t", kv->k_size );
d244 1
a244 1
	bu_log("%2.5f  ", *ptr++);
d246 1
a246 1
    bu_log("\n");
d251 1
a251 1
CONST struct face_g_snurb * m;
d259 1
a259 1
	bu_log("\t[%d] [%d]\n", m->s_size[0], m->s_size[1] );
d265 1
a265 1
			bu_log("\t");
d268 1
a268 1
				bu_log("%f    ", m_ptr[k]);
d270 1
a270 1
			bu_log("\n");
d273 1
a273 1
		bu_log("\n");
d286 1
a286 1
		bu_log("Point Type = RT_NURB_PT_XY");
d289 1
a289 1
		bu_log("Point Type = RT_NURB_PT_XYX");
d292 1
a292 1
		bu_log("Point Type = RT_NURB_PT_UV");
d295 1
a295 1
		bu_log("W\n");
d297 1
a297 1
		bu_log("\n");
@


10.8
log
@Added clean routines for cnurb and snurbs.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
@


10.7
log
@Irix 6
@
text
@d6 1
d9 1
a9 1
 * 
d11 7
a17 3
 * 	SECAD/VLD Computing Consortium, Bldg 394
 *	The U.S. Army Ballistic Research Laboratory
 * 	Aberdeen Proving Ground, Maryland 21005
d20 2
a21 2
 *	This software is Copyright (C) 1986 by the United States Army.
 *	All rights reserved.
d23 3
d95 12
a106 1
/* free routine for a nurb surface */
d108 14
a126 1
    /* assume that links to other surface and curves are already deleted */
d128 1
a128 3
    rt_free( (char *)srf->u_knots.knots, "rt_nurb_free_snurb: u kv knots" );
    rt_free( (char *)srf->v_knots.knots, "rt_nurb_free_snurb: v kv knots" );
    rt_free( (char *)srf->ctl_points, "rt_nurb_free_snurb: mesh points");
d130 6
a135 1
    rt_free( (char *)srf, "rt_nurb_free_snurb: snurb struct" );
d139 21
a159 1
/* free routine for a nurb curve */
d161 5
d173 1
a174 1

@


10.6
log
@Added include of conf.h
@
text
@d221 1
a221 2
	fastf_t flt;
	int coords, rat;
a222 1
	coords = RT_NURB_EXTRACT_COORDS(c);
@


10.5
log
@Changed lists to use rt_list structures
Made some args CONST where appropriate
Switched to GET_CNURB() macros
Added calls to NMG_CK_SNURB()
@
text
@d19 2
@


10.4
log
@Control polygon/mesh is now just part of the cnurb/snurb structures,
rather than being a separate structure of their own.
@
text
@d1 2
a2 1
/*	N U R B _ U T I L . C
d22 2
d26 1
a26 1
/* Create a paceholder for a nurb surface. */
d35 1
a35 4
	srf = (struct snurb *) rt_malloc( sizeof ( struct snurb),
		"rt_nurb_new: snurb struct");

	srf->next = (struct snurb *) 0;
d66 1
a66 4
	crv = (struct cnurb *) rt_malloc( sizeof(struct cnurb),
		"rt_nurb_new_cnurb: cnurb struct");

	crv->next = (struct cnurb *) 0;
d91 1
d108 1
d117 1
a117 1
struct cnurb * crv;
d122 4
a125 3
	fprintf(stderr,"curve = {\n");
	fprintf(stderr,"\tOrder = %d\n", crv->order);
	fprintf(stderr,"\tKnot Vector = {\n\t\t");
d128 1
a128 1
		fprintf(stderr,"%3.2f  ", crv->knot.knots[i]);
d130 2
a131 2
	fprintf(stderr,"\n\t}\n");
	fprintf(stderr,"\t");
d133 1
a133 1
	fprintf(stderr,"\tmesh = {\n");
d137 1
a137 1
		fprintf(stderr,"\t\t");
d139 2
a140 2
			fprintf(stderr,"%4.5f\t", ptr[j]);
		fprintf(stderr,"\n");
d143 1
a143 1
	fprintf(stderr,"\t}\n}\n");
d151 1
a151 1
struct snurb * srf;
d154 1
a154 1
    fprintf ( stderr, "%s\n", c );
d156 1
a156 1
    fprintf ( stderr, "order %d %d\n", srf->order[0], srf->order[1] );
d158 1
a158 1
    fprintf(stderr, "u knot vector \n");
d162 1
a162 1
    fprintf(stderr, "v knot vector \n");
d172 1
a172 1
struct knot_vector * kv;
d177 1
a177 1
    fprintf( stderr, "[%d]\t", kv->k_size );
d182 1
a182 1
	fprintf( stderr, "%2.5f  ", *ptr++);
d184 1
a184 1
    fprintf(stderr,"\n");
d189 1
a189 1
struct snurb * m;
a190 1

d195 1
a195 1
	fprintf(stderr,"\t[%d] [%d]\n", m->s_size[0], m->s_size[1] );
d197 2
d203 1
a203 1
			fprintf(stderr,"\t");
d206 1
a206 1
				fprintf(stderr,"%f    ", m_ptr[k]);
d208 1
a208 1
			fprintf(stderr,"\n");
d211 1
a211 1
		fprintf(stderr,"\n");
d226 1
a226 1
		fprintf(stderr,"Point Type = RT_NURB_PT_XY");
d229 1
a229 1
		fprintf(stderr,"Point Type = RT_NURB_PT_XYX");
d232 1
a232 1
		fprintf(stderr,"Point Type = RT_NURB_PT_UV");
d235 1
a235 1
		fprintf(stderr,"W\n");
d237 1
a237 1
		fprintf(stderr,"\n");
a238 1

@


10.3
log
@Modifications due to data structure revisions:  mesh and knots are no
longer pointers, but in-place structures.
@
text
@d48 3
a50 3
	srf->mesh.s_size[0] = n_rows;
	srf->mesh.s_size[1] = n_cols;
	srf->mesh.pt_type = pt_type;
d53 1
a53 1
	srf->mesh.ctl_points = ( fastf_t *) rt_malloc( 
d77 2
a78 2
	crv->mesh.c_size = n_pts;
	crv->mesh.pt_type = pt_type;
d80 1
a80 1
	crv->mesh.ctl_points = (fastf_t *)
d98 1
a98 1
    rt_free( (char *)srf->mesh.ctl_points, "rt_nurb_free_snurb: mesh points");
d111 1
a111 1
	rt_free( (char*)crv->mesh.ctl_points, "rt_nurb_free_cnurb: control points");
d132 1
a132 1
	rt_nurb_print_pt_type(crv->mesh.pt_type);
d134 2
a135 2
	for( ptr = &crv->mesh.ctl_points[0], i= 0;
		i < crv->mesh.c_size; i++, ptr += RT_NURB_EXTRACT_COORDS(crv->mesh.pt_type))
d138 1
a138 1
		for(j = 0; j < RT_NURB_EXTRACT_COORDS(crv->mesh.pt_type); j++)
d166 1
a166 1
    rt_nurb_pr_mesh( &srf->mesh );
d189 1
a189 1
struct s_mesh * m;
@


10.2
log
@Expanded names of manifest constants
@
text
@d40 2
a41 4
	srf->u_knots = ( struct knot_vector *) rt_malloc ( 
		sizeof ( struct knot_vector ), "rt_nurb_new_snurb: u kv struct");    
	srf->v_knots = ( struct knot_vector *) rt_malloc ( 
		sizeof ( struct knot_vector ), "rt_nurb_new_snurb: v kv struct");
d43 1
a43 4
	srf->u_knots->k_size = n_u_knots;
	srf->v_knots->k_size = n_v_knots;

	srf->u_knots->knots = (fastf_t *) rt_malloc ( 
d45 1
a45 1
	srf->v_knots->knots = (fastf_t *) rt_malloc ( 
d48 3
a50 6
	srf->mesh = (struct s_mesh *) rt_malloc ( 
	sizeof ( struct s_mesh ), "rt_nurb_new_snurb: control mesh");

	srf->mesh->s_size[0] = n_rows;
	srf->mesh->s_size[1] = n_cols;
	srf->mesh->pt_type = pt_type;
d53 1
a53 1
	srf->mesh->ctl_points = ( fastf_t *) rt_malloc( 
d72 2
a73 6
	crv->knot = ( struct knot_vector *) rt_malloc ( 
		sizeof ( struct knot_vector ), 
		"rt_nurb_new_cnurb: struct knotvector");    

	crv->knot->k_size = n_knots;
	crv->knot->knots = (fastf_t *)
d77 2
a78 3
	crv->mesh = (struct c_mesh *) rt_malloc(
		sizeof( struct c_mesh), 
		"rt_nurb_new_cnurb: struct c_mesh");
d80 1
a80 4
	crv->mesh->c_size = n_pts;
	crv->mesh->pt_type = pt_type;

	crv->mesh->ctl_points = (fastf_t *)
d96 3
a98 4
    rt_free( (char *)srf->u_knots->knots, "rt_nurb_free_snurb: u kv knots" );
    rt_free( (char *)srf->v_knots->knots, "rt_nurb_free_snurb: v kv knots" );
    rt_free( (char *)srf->u_knots, "rt_nurb_free_snurb: u kv struct");
    rt_free( (char *)srf->v_knots, "rt_nurb_free_snurb: v kv struct");
d100 1
a100 4
    rt_free( (char *)srf->mesh->ctl_points, "rt_nurb_free_snurb: mesh points");
    rt_free( (char *)srf->mesh, "rt_nurb_free_snurb: mesh struct" );

    rt_free( (char *)srf, "rt_nurb_free_snurb: bspline struct" );
d110 3
a112 5
	rt_free( (char*)crv->knot->knots, "rt_nurb_free_cnurb: knots");
	rt_free( (char*)crv->knot, "rt_nurb_free_cnurb: knot struct");
	rt_free( (char*)crv->mesh->ctl_points, "rt_nurb_free_cnurb: control points");
	rt_free( (char*)crv->mesh, "rt_nurb_free_cnurb: mesh struct");
	rt_free( (char*)crv, "rt_nurb_free_cnurb: cmesh struct");
d127 2
a128 2
	for( i = 0; i < crv->knot->k_size; i++)
		fprintf(stderr,"%3.2f  ", crv->knot->knots[i]);
d132 1
a132 1
	rt_nurb_print_pt_type(crv->mesh->pt_type);
d134 2
a135 2
	for( ptr = &crv->mesh->ctl_points[0], i= 0;
		i < crv->mesh->c_size; i++, ptr += RT_NURB_EXTRACT_COORDS(crv->mesh->pt_type))
d138 1
a138 1
		for(j = 0; j < RT_NURB_EXTRACT_COORDS(crv->mesh->pt_type); j++)
d160 1
a160 1
    rt_nurb_pr_kv( srf->u_knots );
d164 1
a164 1
    rt_nurb_pr_kv( srf->v_knots );
d166 1
a166 1
    rt_nurb_pr_mesh( srf->mesh );
d227 1
a227 1
	if( RT_NURB_EXTRACT_PT_TYPE(c) == RT_NURB_RT_NURB_PT_XYZ)
@


10.1
log
@Release_4.0
@
text
@d38 1
a38 1
	srf->dir = ROW;
d60 1
a60 1
	pnum = sizeof (fastf_t) * n_rows * n_cols * EXTRACT_COORDS(pt_type);
d97 1
a97 1
		rt_malloc( sizeof(fastf_t) * EXTRACT_COORDS(pt_type) *
d157 1
a157 1
		i < crv->mesh->c_size; i++, ptr += EXTRACT_COORDS(crv->mesh->pt_type))
d160 1
a160 1
		for(j = 0; j < EXTRACT_COORDS(crv->mesh->pt_type); j++)
d216 1
a216 1
	int evp = EXTRACT_COORDS(m->pt_type);
d230 1
a230 1
			m_ptr += EXTRACT_COORDS(m->pt_type);
d243 2
a244 2
	coords = EXTRACT_COORDS(c);
	rat = EXTRACT_RAT(c);
d246 2
a247 2
	if( EXTRACT_PT_TYPE(c) == PT_XY)
		fprintf(stderr,"Point Type = PT_XY");
d249 2
a250 2
	if( EXTRACT_PT_TYPE(c) == PT_XYZ)
		fprintf(stderr,"Point Type = PT_XYX");
d252 2
a253 2
	if( EXTRACT_PT_TYPE(c) == PT_UV)
		fprintf(stderr,"Point Type = PT_UV");
@


1.3
log
@minor lint
@
text
@@


1.2
log
@fixed nurb.h
@
text
@a22 3
void	rt_nurb_pr_kv();
void	rt_nurb_pr_mesh();

d126 1
d138 1
d236 1
d238 1
a238 1
char c;
@


1.1
log
@Initial revision
@
text
@d21 1
a21 1
#include "./nurb.h"
@
