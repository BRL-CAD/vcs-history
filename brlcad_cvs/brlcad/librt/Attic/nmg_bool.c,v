head	11.25;
access;
symbols
	ansi-20040405-merged:11.21.2.2
	postmerge-20040405-ansi:11.23
	premerge-20040404-ansi:11.22
	postmerge-autoconf:11.22
	autoconf-freeze:11.21.10.2
	premerge-autoconf:11.22
	ansi-20040316-freeze:11.21.2.1
	postmerge-20040315-windows:11.22
	premerge-20040315-windows:11.22
	windows-20040315-freeze:11.21.4.1
	autoconf-20031203:11.21
	autoconf-20031202:11.21
	autoconf-branch:11.21.0.10
	phong-branch:11.21.0.8
	photonmap-branch:11.21.0.6
	rel-6-1-DP:11.21
	windows-branch:11.21.0.4
	rel-6-0-2:11.19
	ansi-branch:11.21.0.2
	rel-6-0-1-branch:11.19.0.2
	hartley-6-0-post:11.20
	hartley-6-0-pre:11.19
	rel-6-0-1:11.19
	rel-6-0:11.19
	rel-5-4:11.11.2.1
	offsite-5-3-pre:11.16
	rel-5-3:11.11
	rel-5-2:11.11
	rel-5-1-branch:11.11.0.2
	rel-5-1:11.11
	rel-5-0:11.7
	rel-5-0-beta:11.6
	rel-4-5:11.2;
locks; strict;
comment	@ * @;


11.25
date	2004.05.21.18.07.32;	author morrison;	state dead;
branches;
next	11.24;

11.24
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.23;

11.23
date	2004.04.05.08.48.57;	author morrison;	state Exp;
branches;
next	11.22;

11.22
date	2004.02.02.17.39.22;	author morrison;	state Exp;
branches;
next	11.21;

11.21
date	2002.08.20.17.08.03;	author jra;	state Exp;
branches
	11.21.2.1
	11.21.4.1
	11.21.10.1;
next	11.20;

11.20
date	2002.08.15.20.55.14;	author hartley;	state Exp;
branches;
next	11.19;

11.19
date	2001.05.17.20.05.25;	author morrison;	state Exp;
branches;
next	11.18;

11.18
date	2001.04.20.22.29.49;	author morrison;	state Exp;
branches;
next	11.17;

11.17
date	2001.03.29.21.35.57;	author jra;	state Exp;
branches;
next	11.16;

11.16
date	2000.09.08.05.54.42;	author mike;	state Exp;
branches;
next	11.15;

11.15
date	2000.08.29.04.03.11;	author mike;	state Exp;
branches;
next	11.14;

11.14
date	2000.08.21.02.02.31;	author butler;	state Exp;
branches;
next	11.13;

11.13
date	2000.07.10.23.01.38;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	2000.06.27.17.36.09;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	2000.04.01.03.34.12;	author mike;	state Exp;
branches
	11.11.2.1;
next	11.10;

11.10
date	2000.03.29.02.59.46;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	2000.01.04.17.58.20;	author bparker;	state Exp;
branches;
next	11.8;

11.8
date	99.12.30.15.18.56;	author jra;	state Exp;
branches;
next	11.7;

11.7
date	99.06.03.01.39.14;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	99.05.11.19.26.13;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	98.09.14.15.59.17;	author bparker;	state Exp;
branches;
next	11.4;

11.4
date	98.07.31.20.36.44;	author jra;	state Exp;
branches;
next	11.3;

11.3
date	98.03.19.15.57.01;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	98.01.29.06.41.05;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	98.01.29.06.40.35;	author mike;	state Rel4_4;
branches;
next	;

11.11.2.1
date	2001.03.29.21.35.10;	author jra;	state Exp;
branches;
next	;

11.21.2.1
date	2002.09.19.18.01.37;	author morrison;	state Exp;
branches;
next	11.21.2.2;

11.21.2.2
date	2004.03.17.21.18.51;	author morrison;	state Exp;
branches;
next	;

11.21.4.1
date	2004.03.11.23.43.40;	author morrison;	state Exp;
branches;
next	;

11.21.10.1
date	2004.02.12.18.37.43;	author erikg;	state Exp;
branches;
next	11.21.10.2;

11.21.10.2
date	2004.03.15.14.07.23;	author erikg;	state Exp;
branches;
next	;


desc
@NMG Booleans
@


11.25
log
@moved to src/
@
text
@/*	N M G _ B O O L . C
 *
 *	Support for boolean operations on NMG objects.  Most of the routines
 *	in here are static/local to this file.  The interfaces here are the
 *	functions "nmg_do_bool" and "nmg_mesh_faces".  The former does boolean
 *	operations on a pair of shells.  The latter is a function to make
 *	edges shared between two faces whenever possible.
 *
 *  Authors -
 *	Lee A. Butler
 *	Michael John Muuss
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Pacakge" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1993-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/nmg_bool.c,v 11.24 2004/05/10 15:30:46 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif


#include <stdio.h>
#include <math.h>
#include <string.h>
#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "nmg.h"
#include "raytrace.h"
#include "./debug.h"

extern int nmg_class_nothing_broken;

/* XXX Move to nmg_manif.c or nmg_ck.c */
struct dangling_faceuse_state {
	char		*visited;
	const char	*manifolds;
	int		count;
};

int debug_file_count=0;

static void
nmg_dangling_handler(long int *longp, genptr_t state, int first)
{
	register struct faceuse	*fu = (struct faceuse *)longp;
	register struct dangling_faceuse_state *sp =
		(struct dangling_faceuse_state *)state;

	NMG_CK_FACEUSE(fu);
	if( fu->orientation != OT_SAME )  return;
	/* If this faceuse has been processed before, do nothing more */
	if( !NMG_INDEX_FIRST_TIME(sp->visited, fu) )  return;

	if( nmg_dangling_face(fu, sp->manifolds ) )  {
		sp->count++;
	}
}

/*
 *			N M G _ H A S _ D A N G L I N G _ F A C E S
 *
 *  Argument is expected to be model, region, shell, or faceuse pointer.
 *
 *  Returns -
 *	0	No dangling faces
 *	!0	Has dangling faces
 */
int
nmg_has_dangling_faces(long int *magic_p, const char *manifolds)
{
	struct model			*m;
	struct nmg_visit_handlers	handlers;
	struct dangling_faceuse_state	st;

	m = nmg_find_model( magic_p );
	NMG_CK_MODEL(m);
	st.visited = (char *)bu_calloc(m->maxindex+1, sizeof(char), "visited[]");
	st.manifolds = manifolds;
	st.count = 0;

	handlers = nmg_visit_handlers_null;		/* struct copy */
	handlers.bef_faceuse = nmg_dangling_handler;
	nmg_visit( magic_p, &handlers, (genptr_t)&st );

	bu_free( (char *)st.visited, "visited[]");
	return st.count;
}

/*
 *			N M G _ S H O W _ E A C H _ L O O P
 *
 *  Within a shell, show each loop as a separate display.
 *  Pause after displaying each one.
 *
 *  Note that in "non-fancy" mode, show_broken_eu() draws just the edge.
 */
void
nmg_show_each_loop(struct shell *s, long int **classlist, int new, int fancy, const char *str)
            	   
    		              
   		    		/* non-zero means flush previous vlist */
          	     		/* non-zero means pause after the display */
{
	struct faceuse	*fu;
	struct loopuse	*lu;
	char		buf[128];
	long		save;

	NMG_CK_SHELL(s);
	save = rt_g.NMG_debug;
	for( BU_LIST_FOR( fu, faceuse, &s->fu_hd ) )  {
		NMG_CK_FACEUSE(fu);
		if( fu->orientation == OT_OPPOSITE )  continue;
		for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )  {
			NMG_CK_LOOPUSE(lu);
			if( BU_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC )
				continue;
			/* Display only OT_SAME, and OT_UNSPEC et.al.  */
			if( lu->orientation == OT_OPPOSITE )  continue;

			sprintf(buf, "%s=x%lx", str, (unsigned long)lu);
			nmg_show_broken_classifier_stuff(&lu->l.magic, classlist, new, fancy, buf);
		}
	}
	for( BU_LIST_FOR( lu, loopuse, &s->lu_hd ) )  {
		sprintf(buf, "%s=x%lx (wire)", str, (unsigned long)lu);
		nmg_show_broken_classifier_stuff(&lu->l.magic, classlist, new, fancy, buf);
	}
	rt_g.NMG_debug = save;		/* restore it */
}

void
stash_shell(struct shell *s, char *file_name, char *title, const struct bn_tol *tol)
{
	struct model *m;
	struct nmgregion *r;
	struct shell *new_s;
	struct faceuse *fu;
	char counted_name[256];

	m = nmg_mm();
	r = nmg_mrsv( m );
	new_s = BU_LIST_FIRST( shell, &r->s_hd );

	for( BU_LIST_FOR( fu, faceuse, &s->fu_hd ) )
	{
		if( fu->orientation != OT_SAME )
			continue;

		(void)nmg_dup_face( fu, new_s );
	}

	nmg_rebound( m, tol );
	sprintf( counted_name, "%s%d.g", file_name, debug_file_count );
	nmg_stash_model_to_file( counted_name, m, title );
	nmg_km( m );
}

void
nmg_kill_non_common_cracks(struct shell *sA, struct shell *sB)
{
	struct faceuse *fu;
	struct faceuse *fu_next;

	if( rt_g.NMG_debug & DEBUG_BASIC )
		bu_log( "nmg_kill_non_common_cracks( s=%x and %x )\n" , sA, sB );

	NMG_CK_SHELL( sA );
	NMG_CK_SHELL( sB );

	fu = BU_LIST_FIRST( faceuse, &sA->fu_hd );
	while( BU_LIST_NOT_HEAD( fu, &sA->fu_hd ) )
	{
		struct loopuse *lu;
		struct loopuse *lu_next;
		int empty_face=0;

		NMG_CK_FACEUSE( fu );

		fu_next = BU_LIST_PNEXT( faceuse, &fu->l );
		while( BU_LIST_NOT_HEAD( fu_next, &sA->fu_hd )
			&& fu_next == fu->fumate_p )
				fu_next = BU_LIST_PNEXT( faceuse, &fu_next->l );

		lu = BU_LIST_FIRST( loopuse, &fu->lu_hd );
		while( BU_LIST_NOT_HEAD( lu, &fu->lu_hd ) )
		{
			struct edgeuse *eu;
			struct edgeuse *eu_next;
			int empty_loop=0;

			NMG_CK_LOOPUSE( lu );

			lu_next = BU_LIST_PNEXT( loopuse, &lu->l );

			if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
			{
				lu = lu_next;
				continue;
			}

crack_topA:
			for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
			{
				NMG_CK_EDGEUSE( eu );

				eu_next = BU_LIST_PNEXT_CIRC( edgeuse, &eu->l );
				NMG_CK_EDGEUSE( eu_next );

				/* check if eu and eu_next form a jaunt */
				if( eu->vu_p->v_p != eu_next->eumate_p->vu_p->v_p )
					continue;

				/* check if vertex at apex is in other shell 
				 * if so, we need this vertex, can't kill crack
				 */
				if( nmg_find_v_in_shell( eu_next->vu_p->v_p, sB, 0 ) )
					continue;

				if( nmg_keu( eu ) )
					empty_loop = 1;
				else if( nmg_keu( eu_next ) )
					empty_loop = 1;

				if( empty_loop )
					break;

				goto crack_topA;
			}
			if( empty_loop )
			{
				if( nmg_klu( lu ) )
				{
					empty_face = 1;
					break;
				}
			}
			lu = lu_next;
		}
		if( empty_face )
		{
			if( nmg_kfu( fu ) )
			{
				break;
			}
		}
		fu = fu_next;
	}

	fu = BU_LIST_FIRST( faceuse, &sB->fu_hd );
	while( BU_LIST_NOT_HEAD( fu, &sB->fu_hd ) )
	{
		struct loopuse *lu;
		struct loopuse *lu_next;
		int empty_face=0;

		NMG_CK_FACEUSE( fu );

		fu_next = BU_LIST_PNEXT( faceuse, &fu->l );
		while( BU_LIST_NOT_HEAD( fu_next, &sB->fu_hd )
			&& fu_next == fu->fumate_p )
				fu_next = BU_LIST_PNEXT( faceuse, &fu_next->l );

		lu = BU_LIST_FIRST( loopuse, &fu->lu_hd );
		while( BU_LIST_NOT_HEAD( lu, &fu->lu_hd ) )
		{
			struct edgeuse *eu;
			struct edgeuse *eu_next;
			int empty_loop=0;

			NMG_CK_LOOPUSE( lu );

			lu_next = BU_LIST_PNEXT( loopuse, &lu->l );

			if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
			{
				lu = lu_next;
				continue;
			}

crack_top:
			for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
			{
				NMG_CK_EDGEUSE( eu );

				eu_next = BU_LIST_PNEXT_CIRC( edgeuse, &eu->l );
				NMG_CK_EDGEUSE( eu_next );

				/* check if eu and eu_next form a jaunt */
				if( eu->vu_p->v_p != eu_next->eumate_p->vu_p->v_p )
					continue;

				/* check if crack apex is in other shell */
				if( nmg_find_v_in_shell( eu_next->vu_p->v_p, sA, 0 ) )
					continue;

				if( nmg_keu( eu ) )
					empty_loop = 1;
				else if( nmg_keu( eu_next ) )
					empty_loop = 1;

				if( empty_loop )
					break;

				goto crack_top;
			}
			if( empty_loop )
			{
				if( nmg_klu( lu ) )
				{
					empty_face = 1;
					break;
				}
			}
			lu = lu_next;
		}
		if( empty_face )
		{
			if( nmg_kfu( fu ) )
			{
				break;
			}
		}
		fu = fu_next;
	}
}

/*			N M G _ C L A S S I F Y _ S H A R E D _ E D G E S _ V E R T S
 *
 *	Preprocessor routine for classifier to get all the easy shared edges and
 *	vertices marked as shared.
 */

static void
nmg_classify_shared_edges_verts(struct shell *sA, struct shell *sB, long int **classlist)
{
	struct bu_ptbl verts;
	struct bu_ptbl edges;
	int i;

	if (rt_g.NMG_debug & DEBUG_CLASSIFY)
		bu_log( "nmg_classify_shared_edges_verts( sA=x%x, sB=x%x )\n", sA, sB );

	NMG_CK_SHELL( sA );
	NMG_CK_SHELL( sB );

	nmg_vertex_tabulate( &verts, &sA->l.magic );
	for( i=0 ; i<BU_PTBL_END( &verts ) ; i++ )
	{
		struct vertex *v;
		struct vertexuse *vu;

		v = (struct vertex *)BU_PTBL_GET( &verts, i );
		NMG_CK_VERTEX( v );

		for( BU_LIST_FOR( vu, vertexuse, &v->vu_hd ) )
		{
			NMG_CK_VERTEXUSE( vu );

			if( nmg_find_s_of_vu( vu ) == sB )
			{
				/* set classification in both lists */
				NMG_INDEX_SET(classlist[NMG_CLASS_AonBshared], v );
				NMG_INDEX_SET(classlist[4 + NMG_CLASS_AonBshared], v );

				if (rt_g.NMG_debug & DEBUG_CLASSIFY)
					bu_log( "nmg_classify_shared_edges_verts: v=x%x is shared\n", v );

				break;
			}
		}
	}
	bu_ptbl_free( &verts);

	nmg_edge_tabulate( &edges, &sA->l.magic );
	for( i=0 ; i<BU_PTBL_END( &edges ) ; i++ )
	{
		struct edge *e;
		struct edgeuse *eu;
		struct edgeuse *eu_start;

		e = (struct edge *)BU_PTBL_GET( &edges, i );
		NMG_CK_EDGE( e );

		eu_start = e->eu_p;
		NMG_CK_EDGEUSE( eu_start );

		eu = eu_start;
		do
		{
			if( nmg_find_s_of_eu( eu ) == sB )
			{
				NMG_INDEX_SET(classlist[NMG_CLASS_AonBshared], e );
				NMG_INDEX_SET(classlist[4 + NMG_CLASS_AonBshared], e );

				if (rt_g.NMG_debug & DEBUG_CLASSIFY)
					bu_log( "nmg_classify_shared_edges_verts: e=x%x is shared\n", e );

				break;
			}

			eu = eu->eumate_p->radial_p;
			NMG_CK_EDGEUSE( eu );

		} while( eu != eu_start && eu->eumate_p != eu_start );
	}
	bu_ptbl_free( &edges);
}

/*		N M G _ K I L L _ A N T I _ L O O P S
 *
 *	Look for same loop in opposite direction in shell "s",
 *	Kill them.
 */

void
nmg_kill_anti_loops(struct shell *s, const struct bn_tol *tol)
{
	struct bu_ptbl loops;
	struct faceuse *fu;
	struct loopuse *lu;
	int i,j;

	NMG_CK_SHELL( s );
	BN_CK_TOL( tol );

	bu_ptbl_init( &loops, 64, " &loops");

	for( BU_LIST_FOR( fu, faceuse, &s->fu_hd ) )
	{
		NMG_CK_FACEUSE( fu );

		if( fu->orientation != OT_SAME )
			continue;

		for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
		{
			NMG_CK_LOOPUSE( lu );

			if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
				continue;

			bu_ptbl_ins( &loops, (long *)lu );
		}
	}

	for( i=0 ; i < BU_PTBL_END( &loops ) ; i++ )
	{
		struct loopuse *lu1;
		struct edgeuse *eu1_start;
		struct vertex *v1;

		lu1 = (struct loopuse *)BU_PTBL_GET( &loops, i );
		NMG_CK_LOOPUSE( lu1 );

		eu1_start = BU_LIST_FIRST( edgeuse, &lu1->down_hd );
		NMG_CK_EDGEUSE( eu1_start );
		v1 = eu1_start->vu_p->v_p;
		NMG_CK_VERTEX( v1 );

		for( j=i+1 ; j<BU_PTBL_END( &loops ) ; j++ )
		{
			struct loopuse *lu2;
			struct edgeuse *eu1;
			struct edgeuse *eu2;
			struct vertexuse *vu2;
			struct faceuse *fu1,*fu2;
			int anti=1;

			lu2 = (struct loopuse *)BU_PTBL_GET( &loops, j );
			NMG_CK_LOOPUSE( lu2 );

			/* look for v1 in lu2 */
			vu2 = nmg_find_vertex_in_lu( v1, lu2 );

			if( !vu2 )
				continue;

			/* found common vertex, now look for the rest */
			eu2 = vu2->up.eu_p;
			NMG_CK_EDGEUSE( eu2 );
			eu1 = eu1_start;
			do
			{
				eu2 = BU_LIST_PNEXT_CIRC( edgeuse, &eu2->l );
				eu1 = BU_LIST_PPREV_CIRC( edgeuse, &eu1->l );

				if( eu2->vu_p->v_p != eu1->vu_p->v_p )
				{
					anti = 0;
					break;
				}
			} while( eu1 != eu1_start );

			if( !anti )
				continue;

			fu1 = lu1->up.fu_p;
			fu2 = lu2->up.fu_p;

			if( fu1 == fu2 )
				continue;

			if( nmg_klu( lu1 ) )
			{
				if( nmg_kfu( fu1 ) )
					goto out;
			}
			if( nmg_klu( lu2 ) )
			{
				if( nmg_kfu( fu2 ) )
					goto out;
			}

			bu_ptbl_rm( &loops, (long *)lu1 );
			bu_ptbl_rm( &loops, (long *)lu2 );
			i--;
			break;
		}
	}
out:
	bu_ptbl_free( &loops);
}

void
nmg_kill_wire_edges(struct shell *s)
{
	struct loopuse *lu;
	struct edgeuse *eu;

	while( BU_LIST_NON_EMPTY( &s->lu_hd ) )
	{
		lu = BU_LIST_FIRST( loopuse, &s->lu_hd );
		nmg_klu( lu );
	}

	while( BU_LIST_NON_EMPTY( &s->eu_hd ) )
	{
		eu = BU_LIST_FIRST( edgeuse, &s->eu_hd );
		nmg_keu( eu );
	}
}

/*
 *			N M G _ B O O L
 *
 *	Perform boolean operations on a pair of shells.
 *
 *  The return is an updated version of shell A.
 *  Shell B is destroyed.
 *
 *  XXX this probably should operate on regions, not shells.
 */
static struct shell * nmg_bool(struct shell *sA, struct shell *sB, const int oper, const struct bn_tol *tol)
{
	int	i;
	int	nelem;
	long	*classlist[8];
	FILE	*fd, *fp;
	struct model		*m;
	struct nmgregion	*rA;
	struct nmgregion	*rB;

	NMG_CK_SHELL(sA);
	NMG_CK_SHELL(sB);
	rA = sA->r_p;
	rB = sB->r_p;
	NMG_CK_REGION(rA);
	NMG_CK_REGION(rB);
	m = rA->m_p;
	NMG_CK_MODEL(m);

	debug_file_count++;
	if( rt_g.NMG_debug & DEBUG_VERIFY )  {
#if 0
		nmg_vshell( &rA->s_hd, rA );
		nmg_vshell( &rB->s_hd, rB );
#else
		/* Sometimes the tessllations of non-participating regions
		 * are damaged during a boolean operation.  Check everything.
		 */
		nmg_vmodel(m);
#endif
#if VERBOSE_VERIFY
		bu_log("\n==================== Shell A:\n");
		nmg_pr_s_briefly(sA, 0);
		bu_log("\n==================== Shell B:\n");
		nmg_pr_s_briefly(sB, 0);
		bu_log("\n====================\n");
#endif
	}
#if 0
nmg_s_radial_check( sA, tol );
nmg_s_radial_check( sB, tol );
#endif

	nmg_shell_coplanar_face_merge(sA, tol, 1);
	nmg_shell_coplanar_face_merge(sB, tol, 1);

	nmg_model_fuse( m, tol );

	if (nmg_check_closed_shell(sA, tol)) {
		if (rt_g.NMG_debug & DEBUG_BOOL &&
		    rt_g.NMG_debug & DEBUG_PLOTEM) {
			if ((fp=fopen("Unclosed.pl", "w")) != (FILE *)NULL) {
				bu_log("Plotting unclosed NMG shell\n");
				nmg_pl_s(fp, sA);
				fclose(fp);
			}
		}
		if (rt_g.NMG_debug & DEBUG_BOOL)
			nmg_pr_s(sA, "");

		bu_log("nmg_bool: sA is unclosed, barging ahead\n");
	}

	if (nmg_check_closed_shell(sB, tol)) {
		if (rt_g.NMG_debug & DEBUG_BOOL &&
		    rt_g.NMG_debug & DEBUG_PLOTEM) {
			if ((fp=fopen("Unclosed.pl", "w")) != (FILE *)NULL) {
				bu_log("Plotting unclosed NMG shell\n");
				nmg_pl_s(fp, sB);
				fclose(fp);
			}
		}
		if (rt_g.NMG_debug & DEBUG_BOOL)
			nmg_pr_s(sB, "");
		bu_log("nmg_bool: sB is unclosed, barging ahead\n");
	}


	if (rt_g.NMG_debug & DEBUG_BOOL && rt_g.NMG_debug & DEBUG_PLOTEM) {
		if ((fp=fopen("shellA.pl", "w")) == (FILE*)NULL) {
			(void)perror("shellA.pl");
			exit(-1);
		}
		bu_log("plotting shellA.pl\n");
		nmg_pl_s(fp, sA);
		fclose(fp);

		if ((fp=fopen("shellB.pl", "w")) == (FILE*)NULL) {
			(void)perror("shellB.pl");
			exit(-1);
		}
		bu_log("plotting shellB.pl\n");
		nmg_pl_s(fp, sB);
		fclose(fp);
	}

	if( rt_g.NMG_debug & DEBUG_VERIFY )  {
#if 0
		nmg_vshell( &rA->s_hd, rA );
		nmg_vshell( &rB->s_hd, rB );
#else
		/* Sometimes the tessllations of non-participating regions
		 * are damaged during a boolean operation.  Check everything.
		 */
		nmg_vmodel(m);
#endif
#if VERBOSE_VERIFY
		bu_log("\n==================== Shell A: ====== before crackshells\n");
		nmg_pr_s_briefly(sA, 0);
		bu_log("\n==================== Shell B:\n");
		nmg_pr_s_briefly(sB, 0);
		bu_log("\n====================\n");
#endif
	}

#if 1
	if (rt_g.NMG_debug & DEBUG_BOOL)
	{
		char file_name[256];

		sprintf( file_name, "before%d.g", debug_file_count );
		nmg_stash_model_to_file( file_name, m, "Before crackshells" );
	}
#endif

	/* Perform shell/shell intersections */
	nmg_crackshells(sA, sB, tol);

	if (rt_g.NMG_debug & DEBUG_BOOL)
	{
		stash_shell( sA, "a1_", "sA", tol );
		stash_shell( sB, "b1_", "sB", tol );
		bu_log( "Just After Crackshells:\nShell A:\n" );
		nmg_pr_s_briefly( sA, 0 );
		bu_log( "Just After Crackshells:\nShell B:\n" );
		nmg_pr_s_briefly( sB, 0 );
	}

	(void)nmg_model_vertex_fuse( m, tol );

	(void)nmg_kill_anti_loops( sA, tol );
	(void)nmg_kill_anti_loops( sB, tol );

	nmg_m_reindex( m, 0 );

	/*
	 *  Allocate storage for classlist[].
	 *  Get all 8 lists at once, and just build pointers for the rest.
	 *  XXX In some cases, number of items may grow 
	 *  XXX (e.g. added vu's, loops) as things are demoted, etc.
	 *  XXX Try to accomodate here by reserving some extra table space.
	 *
	 *  XXX The classlist really only needs to be an unsigned char,
	 *  XXX not a long*.
	 */
	nelem = (m->maxindex)*4+1;		/* includes extra space */
	classlist[0] = (long *)bu_calloc( 8 * nelem + 1,
		sizeof(long), "nmg_bool classlist[8]" );
	for( i = 1; i < 8; i++ )  {
		classlist[i] = classlist[0] + i * nelem;
	}

	nmg_classify_shared_edges_verts( sA, sB, classlist );

	/* clean things up now that the intersections have been built */
	nmg_sanitize_s_lv(sA, OT_BOOLPLACE);
	nmg_sanitize_s_lv(sB, OT_BOOLPLACE);

	/* Separate any touching loops, so classifier does not have any
	 * really complex loops to do.
	 * In particular, it is necessary for (r410) to make
	 * interior (touching) loop segments into true interior loops
	 * that are separate from the exterior loop,
	 * so the classifier can assess each separately.
	 */
	nmg_s_split_touchingloops(sA, tol);
	nmg_s_split_touchingloops(sB, tol);

	(void)nmg_kill_cracks( sA );
	(void)nmg_kill_cracks( sB );

	/* eliminate unecessary breaks in edges */
	(void)nmg_simplify_shell_edges( sA, tol );
	(void)nmg_simplify_shell_edges( sB, tol );

	(void)nmg_model_break_e_on_v( m, tol );

	(void)nmg_model_edge_fuse( m , tol );

	if( rt_g.NMG_debug & DEBUG_VERIFY )  {
#if 0
		nmg_vshell( &rA->s_hd, rA );
		nmg_vshell( &rB->s_hd, rB );
#else
		/* Sometimes the tessllations of non-participating regions
		 * are damaged during a boolean operation.  Check everything.
		 */
		nmg_vmodel(m);
#endif
#if VERBOSE_VERIFY
		bu_log("\n==================== Shell A: ====== before mesh_shell_shell\n");
		nmg_pr_s_briefly(sA, 0);
		bu_log("\n==================== Shell B:\n");
		nmg_pr_s_briefly(sB, 0);
		bu_log("\n====================\n");
#endif
		if( (i = nmg_model_fuse( m, tol )) > 0 )  {
			bu_log("NOTICE: nmg_bool: fused %d entities while cracking shells\n", i);
			rt_bomb("nmg_bool() entities unfused after nmg_crackshells()\n");
		}
	}
#if 1
	/* Temporary search */
	if( nmg_has_dangling_faces( (long *)rA, (char *)NULL ) )
		bu_log("Dangling faces detected in rA before classification\n");
	if( nmg_has_dangling_faces( (long *)rB, (char *)NULL ) )
		bu_log("Dangling faces detected in rB before classification\n");
	if( nmg_has_dangling_faces( (long *)m, (char *)NULL ) )
		bu_log("Dangling faces detected in model before classification\n");
#endif

	if( rt_g.NMG_debug & DEBUG_VERIFY )  {
#if 0
		nmg_vshell( &rA->s_hd, rA );
		nmg_vshell( &rB->s_hd, rB );
#else
		/* Sometimes the tessllations of non-participating regions
		 * are damaged during a boolean operation.  Check everything.
		 */
		nmg_vmodel(m);
#endif
#if VERBOSE_VERIFY
		bu_log("\n==================== Shell A: ====== after mesh_shell_shell\n");
		nmg_pr_s_briefly(sA, 0);
		bu_log("\n==================== Shell B:\n");
		nmg_pr_s_briefly(sB, 0);
		bu_log("\n====================\n");
#endif
	}
#if 0
nmg_s_radial_check( sA, tol );
nmg_s_radial_check( sB, tol );
#endif

	/*
	 *  Before splitting, join up small loop fragments into large
	 *  ones, so that maximal splits will be possible.
	 *  This is essential for cutting holes in faces, e.g. Test3.r
	 */
	if (rt_g.NMG_debug & DEBUG_BOOL)
	{
		char file_name[256];

		sprintf( file_name, "notjoined%d.g", debug_file_count );
		nmg_stash_model_to_file( file_name, m, "Before s_join_touchingloops" );
	}
#if 0
	nmg_s_join_touchingloops(sA, tol);
	nmg_s_join_touchingloops(sB, tol);
	if (rt_g.NMG_debug & DEBUG_BOOL)
	{
		char file_name[256];

		sprintf( file_name, "joined%d.g", debug_file_count );
		nmg_stash_model_to_file( file_name, m, "After s_join_touchingloops" );
	}
#endif

	/* Re-build bounding boxes, edge geometry, as needed. */
	nmg_shell_a(sA, tol);
	nmg_shell_a(sB, tol);

	if (rt_g.NMG_debug & DEBUG_BOOL)
	{
		stash_shell( sA, "a", "sA", tol );
		stash_shell( sB, "b", "sB", tol );

		bu_log( "sA:\n" );
		nmg_pr_s_briefly( sA, 0 );
		bu_log( "sB:\n" );
		nmg_pr_s_briefly( sB, 0 );
	}

	if (rt_g.NMG_debug & DEBUG_BOOL)
	{
		char file_name[256];

		sprintf( file_name, "after%d.g", debug_file_count );
		nmg_stash_model_to_file( file_name, m, "After crackshells" );
	}

	if (rt_g.NMG_debug & DEBUG_BOOL) {
		if (rt_g.NMG_debug & DEBUG_PLOTEM) {
			if ((fd = fopen("Cracked_Shells.pl", "w")) == (FILE *)NULL) {
				(void)perror("Cracked_Shells");
				exit(-1);
			}
			bu_log("plotting Cracked_Shells.pl\n");

			nmg_pl_s(fd, sA);
			nmg_pl_s(fd, sB);
			(void)fclose(fd);

			nmg_pl_isect("isectA.pl", sA, tol);
			nmg_pl_isect("isectB.pl", sB, tol);
		}

		bu_log("check 2\n");
	}

	if (nmg_ck_closed_surf(sA, tol))
		bu_log("nmg_bool() WARNING: sA unclosed before classification.  Boldly pressing on.\n");
	if (nmg_ck_closed_surf(sB, tol))
		bu_log("nmg_bool() WARNING: sB unclosed before classification.  Boldly pressing on.\n");

	if( rt_g.NMG_debug & DEBUG_VERIFY )  {
#if 0
		nmg_vshell( &rA->s_hd, rA );
		nmg_vshell( &rB->s_hd, rB );
#else
		/* Sometimes the tessllations of non-participating regions
		 * are damaged during a boolean operation.  Check everything.
		 */
		nmg_vmodel(m);
#endif
	}

#if 0
	/* Reindex structures before classification or evaluation. */
	nmg_m_reindex( m, 0 );

	/*
	 *  Allocate storage for classlist[].
	 *  Get all 8 lists at once, and just build pointers for the rest.
	 *  XXX In some cases, number of items may grow 
	 *  XXX (e.g. added vu's, loops) as things are demoted, etc.
	 *  XXX Try to accomodate here by reserving some extra table space.
	 *
	 *  XXX The classlist really only needs to be an unsigned char,
	 *  XXX not a long*.
	 */
	nelem = (m->maxindex)*4+1;		/* includes extra space */
	classlist[0] = (long *)bu_calloc( 8 * nelem + 1,
		sizeof(long), "nmg_bool classlist[8]" );
	for( i = 1; i < 8; i++ )  {
		classlist[i] = classlist[0] + i * nelem;
	}
#endif
	nmg_class_nothing_broken = 1;
	if (rt_g.NMG_debug & (DEBUG_GRAPHCL|DEBUG_PL_LOOP)) {
		nmg_show_broken_classifier_stuff((long *)sA, &classlist[0],
			nmg_class_nothing_broken, 1, "unclassed sA");
		nmg_show_broken_classifier_stuff((long *)sB, &classlist[4], 1, 1, "unclassed sB");
	}

	/*
	 *  Classify A -vs- B, then B -vs- A.
	 *  Carry onAonBshared and onAonBanti classifications forward
	 *  from first step to second step.
	 *  A -vs- B live in classlist[0..3], B -vs- A live in classlist[4..7].
	 */
	nmg_class_shells(sA, sB, &classlist[0], tol);
	memcpy( (char *)classlist[4+NMG_CLASS_AonBshared],
		(char *)classlist[0+NMG_CLASS_AonBshared],
		nelem*sizeof(long) );
	memcpy( (char *)classlist[4+NMG_CLASS_AonBanti],
		(char *)classlist[0+NMG_CLASS_AonBanti],
		nelem*sizeof(long) );
	nmg_class_shells(sB, sA, &classlist[4], tol);

	if (rt_g.NMG_debug & (DEBUG_GRAPHCL|DEBUG_PL_LOOP)) {
		nmg_class_nothing_broken = 1;

		/* Show each loop, one at a time, non-fancy */
		/* XXX Should have it's own bit, or combination -- not always wanted */
		nmg_show_each_loop(sA, &classlist[0], 1, 0, "sA lu");
		nmg_show_each_loop(sB, &classlist[4], 1, 0, "sB lu");

		/* Show each shell as a whole */
		nmg_show_broken_classifier_stuff((long *)sA, &classlist[0], 1, 0, "sA classed");
		nmg_show_broken_classifier_stuff((long *)sB, &classlist[4], 1, 0, "sB classed");
	}
#if 1
	if( rt_g.NMG_debug & DEBUG_BOOL )
	{
		bu_log( "Just before nmg_evaluate_boolean:\nShell A:\n" );
		nmg_pr_s_briefly( sA , 0 );
		bu_log( "Shell B:\n" );
		nmg_pr_s_briefly( sB , 0 );
	}
#endif
nmg_s_radial_check( sA, tol );
nmg_s_radial_check( sB, tol );
	nmg_evaluate_boolean( sA, sB, oper, classlist, tol);

#if 1
	if( rt_g.NMG_debug & DEBUG_BOOL )
	{
		bu_log( "Just after nmg_evaluate_boolean:\nShell A:\n" );
		nmg_pr_s_briefly( sA , 0 );
		bu_log( "Shell B:\n" );
		nmg_pr_s_briefly( sB , 0 );
	}
#endif

	if( rt_g.NMG_debug & DEBUG_VERIFY )  {
		nmg_vmodel(m);
		if( (i = nmg_model_fuse( m, tol )) > 0 )  {
			bu_log("ERROR: nmg_bool: fused %d entities after BOOLEAN.  Isect bug.\n", i);
			rt_bomb("nmg_bool() entities unfused after nmg_evaluate_boolean()\n");
		}
	}

	/*
	 *  nmg_evaluate_boolean() may return an invalid shell,
	 *  i.e., one that has absolutely nothing in it.
	 *  This is an indication that the shell should be deleted
	 *  from the region, an operation which can not be accomplished
	 *  this far down in the subroutine tree.
	 */
	if( !nmg_shell_is_empty(sA) )  {
nmg_s_radial_check( sA, tol );
		/* Temporary search */
		if( nmg_has_dangling_faces( (long *)rA, (char *)NULL ) )
		bu_log("Dangling faces detected in rA after boolean\n");
		if( nmg_has_dangling_faces( (long *)rB, (char *)NULL ) )
			bu_log("Dangling faces detected in rB after boolean\n");
		if( nmg_has_dangling_faces( (long *)m, (char *)NULL ) )  {
			if(rt_g.NMG_debug)
				nmg_stash_model_to_file( "dangle.g", m, "After Boolean" );
			rt_bomb("nmg_bool() Dangling faces detected after boolean\n");
		}

		/* Do this before table size changes */
		if (rt_g.NMG_debug & (DEBUG_GRAPHCL|DEBUG_PL_LOOP)) {
			nmg_class_nothing_broken = 1;

			/* Show final result of the boolean */
			nmg_show_broken_classifier_stuff((long *)sA, &classlist[0], 1, 0, "sA result");
		}

		/*  Go back and combine loops
		 *  of faces together wherever possible
		 *  to reduce the loop/edge count.
		 */
		nmg_simplify_shell(sA);
		if( rt_g.NMG_debug & DEBUG_VERIFY )
			nmg_vshell( &rA->s_hd, rA );

		(void) nmg_unbreak_region_edges( &sA->l.magic );

#if 1
	if( rt_g.NMG_debug & DEBUG_BOOL )
	{
		bu_log( "Just after nmg_simplify_shell:\nShell A:\n" );
		nmg_pr_s_briefly( sA , 0 );
		bu_log( "Shell B:\n" );
		nmg_pr_s_briefly( sB , 0 );
	}
#endif
		/* Bounding boxes may have changed */
		nmg_shell_a(sA, tol);

		if( nmg_ck_closed_surf(sA, tol) )  {
			if( rt_g.NMG_debug )
				bu_log("nmg_bool() WARNING: sA unclosed at return, barging on.\n");
			else
				rt_bomb("nmg_bool() sA unclosed at return, aborting.\n");
		}
nmg_s_radial_check( sA, tol );

		if( rt_g.NMG_debug & DEBUG_BOOL )
		{
			char tmp_name[256];
			sprintf( tmp_name, "after_bool_%d.g", debug_file_count );
			nmg_stash_model_to_file( tmp_name, m, "After Boolean" );
		}
	}

	bu_free( (char *)classlist[0], "nmg_bool classlist[8]" );

	if (rt_g.NMG_debug & DEBUG_BOOL) {
		bu_log("Returning from NMG_BOOL\n");
	}
	if( rt_g.NMG_debug & DEBUG_VERIFY )  {
#if 0
		nmg_vshell( &rA->s_hd, rA );
#else
		/* Sometimes the tessllations of non-participating regions
		 * are damaged during a boolean operation.  Check everything.
		 */
		nmg_vmodel(m);
#endif
	}

	nmg_kill_wire_edges( sA );

	return(sA);
}

/*
 *			N M G _ D O _ B O O L
 *
 *	BUG: we assume only one shell per region
 */
struct nmgregion *
nmg_do_bool(struct nmgregion *rA, struct nmgregion *rB, const int oper, const struct bn_tol *tol)
{
	struct shell		*s;
	struct nmgregion	*r;

	NMG_CK_REGION(rA);
	NMG_CK_REGION(rB);

#if 1
nmg_region_v_unique( rA, tol );
nmg_region_v_unique( rB, tol );
#endif

	s = nmg_bool(BU_LIST_FIRST(shell, &rA->s_hd),
		BU_LIST_FIRST(shell, &rB->s_hd),
		oper, tol);
	r = s->r_p;

	/* shell B was destroyed, need to eliminate region B */
	nmg_kr( rB );

	NMG_CK_SHELL(s);
	NMG_CK_REGION(r);

	/* If shell A became empty, eliminate it from the returned region */
	if( nmg_shell_is_empty(s) )
	{
		nmg_ks(s);
		if( BU_LIST_NON_EMPTY( &r->s_hd ) )
		{
			rt_bomb( "nmg_do_bool: Result of Boolean is an empty shell, but region is not empty!!!\n" );
		}
		nmg_kr( r );
		return( (struct nmgregion *)NULL );
	}

	return(r);
}

/* XXX move to ??? Everything from here on down needs to go into another module */


/*
 *			N M G _ B O O L T R E E _ L E A F _ T E S S
 *
 *  Called from db_walk_tree() each time a tree leaf is encountered.
 *  The primitive solid, in external format, is provided in 'ep',
 *  and the type of that solid (e.g. ID_ELL) is in 'id'.
 *  The full tree state including the accumulated transformation matrix
 *  and the current tolerancing is in 'tsp',
 *  and the full path from root to leaf is in 'pathp'.
 *
 *  Import the solid, tessellate it into an NMG, stash a pointer to
 *  the tessellation in a new tree structure (union), and return a
 *  pointer to that.
 *
 *  Usually given as an argument to, and called from db_walk_tree().
 *
 *  This routine must be prepared to run in parallel.
 */
union tree *
nmg_booltree_leaf_tess(struct db_tree_state *tsp, struct db_full_path *pathp, struct rt_db_internal *ip, genptr_t client_data)
{
	struct model		*m;
	struct nmgregion	*r1;
	union tree		*curtree;
	struct directory	*dp;

	NMG_CK_MODEL(*tsp->ts_m);
	BN_CK_TOL(tsp->ts_tol);
	RT_CK_TESS_TOL(tsp->ts_ttol);
	RT_CK_DB_INTERNAL(ip);
	RT_CK_RESOURCE(tsp->ts_resp);

	RT_CK_FULL_PATH(pathp);
	dp = DB_FULL_PATH_CUR_DIR(pathp);
	RT_CK_DIR(dp);

	m = nmg_mm();

	if (ip->idb_meth->ft_tessellate(
	    &r1, m, ip, tsp->ts_ttol, tsp->ts_tol) < 0) {
		bu_log("nmg_booltree_leaf_tess(%s): tessellation failure\n", dp->d_namep);
	    	return(TREE_NULL);
	}

	NMG_CK_REGION(r1);
	if( rt_g.NMG_debug & DEBUG_VERIFY )  {
		nmg_vshell( &r1->s_hd, r1 );
	}

	RT_GET_TREE( curtree, tsp->ts_resp );
	curtree->magic = RT_TREE_MAGIC;
	curtree->tr_op = OP_NMG_TESS;
	curtree->tr_d.td_name = bu_strdup(dp->d_namep);
	curtree->tr_d.td_r = r1;

	if (RT_G_DEBUG&DEBUG_TREEWALK)
		bu_log("nmg_booltree_leaf_tess(%s) OK\n", dp->d_namep);

	return(curtree);
}

/*
 *			N M G _ B O O L T R E E _ L E A F _ T N U R B
 *
 *  Called from db_walk_tree() each time a tree leaf is encountered.
 *  The primitive solid, in external format, is provided in 'ep',
 *  and the type of that solid (e.g. ID_ELL) is in 'id'.
 *  The full tree state including the accumulated transformation matrix
 *  and the current tolerancing is in 'tsp',
 *  and the full path from root to leaf is in 'pathp'.
 *
 *  Import the solid, convert it into an NMG using t-NURBS,
 *  stash a pointer in a new tree structure (union), and return a
 *  pointer to that.
 *
 *  Usually given as an argument to, and called from db_walk_tree().
 *
 *  This routine must be prepared to run in parallel.
 */
union tree *
nmg_booltree_leaf_tnurb(struct db_tree_state *tsp, struct db_full_path *pathp, struct rt_db_internal *ip, genptr_t client_data)
{
	struct nmgregion	*r1;
	union tree		*curtree;
	struct directory	*dp;

	NMG_CK_MODEL(*tsp->ts_m);
	BN_CK_TOL(tsp->ts_tol);
	RT_CK_TESS_TOL(tsp->ts_ttol);
	RT_CK_DB_INTERNAL(ip);
	RT_CK_RESOURCE(tsp->ts_resp);

	RT_CK_FULL_PATH(pathp);
	dp = DB_FULL_PATH_CUR_DIR(pathp);
	RT_CK_DIR(dp);

	if (ip->idb_meth->ft_tnurb(
	    &r1, *tsp->ts_m, ip, tsp->ts_tol) < 0) {
		bu_log("nmg_booltree_leaf_tnurb(%s): CSG to t-NURB conversation failure\n", dp->d_namep);
	    	return(TREE_NULL);
	}

	NMG_CK_REGION(r1);
	if( rt_g.NMG_debug & DEBUG_VERIFY )  {
		nmg_vshell( &r1->s_hd, r1 );
	}

	RT_GET_TREE( curtree, tsp->ts_resp );
	curtree->magic = RT_TREE_MAGIC;
	curtree->tr_op = OP_NMG_TESS;
	curtree->tr_d.td_name = bu_strdup(dp->d_namep);
	curtree->tr_d.td_r = r1;

	if (RT_G_DEBUG&DEBUG_TREEWALK)
		bu_log("nmg_booltree_leaf_tnurb(%s) OK\n", dp->d_namep);

	return(curtree);
}

/*
 *			N M G _ B O O L T R E E _ E V A L U A T E
 *
 *  Given a tree of leaf nodes tesselated earlier by nmg_booltree_leaf_tess(),
 *  use recursion to do a depth-first traversal of the tree,
 *  evaluating each pair of boolean operations
 *  and reducing that result to a single nmgregion.
 *
 *  Usually called from a do_region_end() handler from db_walk_tree().
 *  For an example of several, see mged/dodraw.c.
 *
 *  Returns an OP_NMG_TESS union tree node, which will contain the
 *  resulting region and it's name, as a dynamic string.
 *  The caller is responsible for releasing the string, and the node,
 *  by calling db_free_tree() on the node.
 *
 *  It is *essential* that the caller call nmg_model_fuse() before
 *  calling this subroutine.
 *
 *  Returns NULL if there is no geometry to return.
 *
 *  Typical calls will be of this form:
 *	(void)nmg_model_fuse( m, tol );
 *	curtree = nmg_booltree_evaluate( curtree, tol );
 */
union tree *
nmg_booltree_evaluate(register union tree *tp, const struct bn_tol *tol, struct resource *resp)
{
	union tree		*tl;
	union tree		*tr;
	struct nmgregion	*reg;
	int			op;
	const char		*op_str;
	char			*name;

	RT_CK_TREE(tp);
	BN_CK_TOL(tol);
	RT_CK_RESOURCE(resp);

	switch(tp->tr_op) {
	case OP_NOP:
		return(0);
	case OP_NMG_TESS:
		/* Hit a tree leaf */
		if( rt_g.NMG_debug & DEBUG_VERIFY )  {
			nmg_vshell( &tp->tr_d.td_r->s_hd, tp->tr_d.td_r );
		}
		return tp;
	case OP_UNION:
		op = NMG_BOOL_ADD;
		op_str = " u ";
		break;
	case OP_INTERSECT:
		op = NMG_BOOL_ISECT;
		op_str = " + ";
		break;
	case OP_SUBTRACT:
		op = NMG_BOOL_SUB;
		op_str = " - ";
		break;
	default:
		bu_log("nmg_booltree_evaluate: bad op %d\n", tp->tr_op);
		return(0);
	}
	/* Handle a boolean operation node.  First get it's leaves. */
	tl = nmg_booltree_evaluate(tp->tr_b.tb_left, tol, resp);
	tr = nmg_booltree_evaluate(tp->tr_b.tb_right, tol, resp);
	if (tl == 0 || !tl->tr_d.td_r) {
		if (tr == 0 || !tr->tr_d.td_r)
			return 0;
		if( op == NMG_BOOL_ADD )
			return tr;
		/* For sub and intersect, if lhs is 0, result is null */
		db_free_tree(tr, resp);
		tp->tr_b.tb_right = TREE_NULL;
		tp->tr_op = OP_NOP;
		return 0;
	}
	if (tr == 0 || !tr->tr_d.td_r) {
		if (tl == 0 || !tl->tr_d.td_r)
			return 0;
		if( op == NMG_BOOL_ISECT )  {
			db_free_tree(tl, resp);
			tp->tr_b.tb_left = TREE_NULL;
			tp->tr_op = OP_NOP;
			return 0;
		}
		/* For sub and add, if rhs is 0, result is lhs */
		return tl;
	}
	if( tl->tr_op != OP_NMG_TESS )  rt_bomb("nmg_booltree_evaluate() bad left tree\n");
	if( tr->tr_op != OP_NMG_TESS )  rt_bomb("nmg_booltree_evaluate() bad right tree\n");

bu_log(" {%s}%s{%s}\n", tl->tr_d.td_name, op_str, tr->tr_d.td_name );

	NMG_CK_REGION(tr->tr_d.td_r);
	NMG_CK_REGION(tl->tr_d.td_r);
	if (nmg_ck_closed_region(tr->tr_d.td_r, tol) != 0)
	    	bu_log("nmg_booltree_evaluate:  WARNING, non-closed shell (r), barging ahead\n");
	if (nmg_ck_closed_region(tl->tr_d.td_r, tol) != 0)
	    	bu_log("nmg_booltree_evaluate:  WARNING, non-closed shell (l), barging ahead\n");
nmg_r_radial_check( tr->tr_d.td_r, tol );
nmg_r_radial_check( tl->tr_d.td_r, tol );

	if( rt_g.NMG_debug & DEBUG_BOOL )
	{
		bu_log( "Before model fuse\nShell A:\n" );
		nmg_pr_s_briefly( BU_LIST_FIRST( shell, &tl->tr_d.td_r->s_hd ), "" );
		bu_log( "Shell B:\n" );
		nmg_pr_s_briefly( BU_LIST_FIRST( shell, &tr->tr_d.td_r->s_hd ), "" );
	}

	/* move operands into the same model */
	if( tr->tr_d.td_r->m_p != tl->tr_d.td_r->m_p )
		nmg_merge_models( tl->tr_d.td_r->m_p, tr->tr_d.td_r->m_p );

	/* input r1 and r2 are destroyed, output is new region */
	reg = nmg_do_bool(tl->tr_d.td_r, tr->tr_d.td_r, op, tol);
	tl->tr_d.td_r = NULL;
	tr->tr_d.td_r = NULL;
	if( reg )
	{
		NMG_CK_REGION(reg);
		nmg_r_radial_check( reg, tol );

		if( rt_g.NMG_debug & DEBUG_VERIFY )  {
			nmg_vshell( &reg->s_hd, reg );
		}
	}

	/* Build string of result name */
	name = (char *)bu_malloc( strlen(tl->tr_d.td_name)+3+strlen(tr->tr_d.td_name)+2+1,
		"nmg_booltree_evaluate name");
	name[0] = '(';
	strcpy( name+1, tl->tr_d.td_name );
	strcat( name+1, op_str );
	strcat( name+1, tr->tr_d.td_name );
	strcat( name+1, ")" );

	/* Clean up child tree nodes (and their names) */
	db_free_tree(tl, resp);
	db_free_tree(tr, resp);

	/* Convert argument binary node into a result node */
	tp->tr_op = OP_NMG_TESS;
	tp->tr_d.td_r = reg;
	tp->tr_d.td_name = name;
	return tp;
}

/*
 *			N M G _ B O O L E A N
 *
 *  This is the main application interface to the NMG Boolean Evaluator.
 *
 *  This routine has the opportunity to do "once only" operations
 *  before and after the boolean tree is walked.
 *
 *  Returns -
 *	0	Boolean went OK.  Result region is in tp->tr_d.td_r
 *	!0	Boolean produced null result.
 *
 *  The caller is responsible for freeing 'tp' in either case,
 *  typically with db_free_tree(tp);
 */
int
nmg_boolean( union tree *tp, struct model *m, const struct bn_tol *tol, struct resource *resp )
{
	union tree	*result;
	int		ret;

	RT_CK_TREE(tp);
	NMG_CK_MODEL(m);
	BN_CK_TOL(tol);
	RT_CK_RESOURCE(resp);

	if (rt_g.NMG_debug & (DEBUG_BOOL|DEBUG_BASIC) )  {
		bu_log("\n\nnmg_boolean( tp=x%x, m=x%x ) START\n",
			tp, m );
	}

	/*
	 *  Find all entities within geometric tolerance of each other
	 *  and "fuse" them, establishing topological sharing.
	 *  Also breaks all edges on all vertices that are within tolerance.
	 *  Operate on the entire model at once.
	 */
	(void)nmg_model_fuse( m, tol );

	/*
	 *  Evaluate the nodes of the boolean tree one at a time,
	 *  until only a single region remains.
	 */
	result = nmg_booltree_evaluate( tp, tol, resp );
	RT_CK_TREE( result );
	if( result != tp )  rt_bomb("nmg_boolean() result of nmg_booltree_evaluate() isn't tp\n");
	if( tp->tr_op != OP_NMG_TESS )  {
		bu_log("nmg_boolean() result of nmg_booltree_evaluate() op != OP_NMG_TESS\n");
		rt_pr_tree( tp, 0 );
		ret = 1;
		goto out;
	}
	if( tp->tr_d.td_r == (struct nmgregion *)NULL )  {
		/* Pointers are all OK, but boolean produced null set */
		ret = 1;
		goto out;
	}
	/* move result into correct model */
	nmg_merge_models( m, tp->tr_d.td_r->m_p );
	ret = 0;

out:
	if (rt_g.NMG_debug & (DEBUG_BOOL|DEBUG_BASIC) )  {
		bu_log("nmg_boolean( tp=x%x, m=x%x ) END, ret=%d\n\n",
			tp, m, ret );
	}
	return ret;
}
@


11.24
log
@change conf.h to a wrapped config.h
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/librt/nmg_bool.c,v 11.23 2004/04/05 08:48:57 morrison Exp $ (ARL)";
@


11.23
log
@merge of ansi-6-0-branch into HEAD
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d30 5
a34 1
#include "conf.h"
@


11.22
log
@update copyright to include span through 2003
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_bool.c,v 11.21 2002/08/20 17:08:03 jra Exp $ (ARL)";
d53 1
a53 4
nmg_dangling_handler( longp, state, first )
long		*longp;
genptr_t	state;
int		first;
d79 1
a79 3
nmg_has_dangling_faces( magic_p, manifolds )
long		*magic_p;
const char	*manifolds;
d108 5
a112 5
nmg_show_each_loop(s, classlist, new, fancy, str)
struct shell	*s;
long		*classlist[4];
int		new;		/* non-zero means flush previous vlist */
const char	*str;		/* non-zero means pause after the display */
d143 1
a143 5
stash_shell( s, file_name, title, tol )
struct shell *s;
char *file_name;
char *title;
struct bn_tol *tol;
d170 1
a170 3
nmg_kill_non_common_cracks( sA, sB )
struct shell *sA;
struct shell *sB;
d345 1
a345 4
nmg_classify_shared_edges_verts( sA, sB, classlist )
struct shell *sA;
struct shell *sB;
long *classlist[8];
d427 1
a427 3
nmg_kill_anti_loops( s, tol )
struct shell *s;
const struct bn_tol *tol;
d536 1
a536 2
nmg_kill_wire_edges( s )
struct shell *s;
d564 1
a564 4
static struct shell * nmg_bool(sA, sB, oper, tol)
struct shell *sA, *sB;
const int		oper;
const struct bn_tol	*tol;
d1070 1
a1070 4
nmg_do_bool(rA, rB, oper, tol)
struct nmgregion *rA, *rB;
const int		oper;
const struct bn_tol	*tol;
d1131 1
a1131 5
nmg_booltree_leaf_tess(tsp, pathp, ip, client_data)
struct db_tree_state	*tsp;
struct db_full_path	*pathp;
struct rt_db_internal	*ip;
genptr_t		client_data;
d1192 1
a1192 5
nmg_booltree_leaf_tnurb(tsp, pathp, ip, client_data)
struct db_tree_state	*tsp;
struct db_full_path	*pathp;
struct rt_db_internal	*ip;
genptr_t		client_data;
d1257 1
a1257 4
nmg_booltree_evaluate(tp, tol, resp)
register union tree		*tp;
const struct bn_tol		*tol;
struct resource			*resp;
@


11.21
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d23 1
a23 1
 *	This software is Copyright (C) 1993 by the United States Army
d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_bool.c,v 11.19 2001/05/17 20:05:25 morrison Exp $ (ARL)";
@


11.21.4.1
log
@sync to HEAD...
@
text
@d23 1
a23 1
 *	This software is Copyright (C) 1993-2004 by the United States Army
d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/nmg_bool.c,v 11.22 2004/02/02 17:39:22 morrison Exp $ (ARL)";
@


11.21.10.1
log
@merge from HEAD
@
text
@d23 1
a23 1
 *	This software is Copyright (C) 1993-2004 by the United States Army
d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_bool.c,v 11.22 2004/02/02 17:39:22 morrison Exp $ (ARL)";
@


11.21.10.2
log
@merge from head
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_bool.c,v 11.21.10.1 2004/02/12 18:37:43 erikg Exp $ (ARL)";
@


11.21.2.1
log
@Initial ANSIfication
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_bool.c,v 11.21 2002/08/20 17:08:03 jra Exp $ (ARL)";
d53 4
a56 1
nmg_dangling_handler(long int *longp, genptr_t state, int first)
d82 3
a84 1
nmg_has_dangling_faces(long int *magic_p, const char *manifolds)
d113 5
a117 5
nmg_show_each_loop(struct shell *s, long int **classlist, int new, int fancy, const char *str)
            	   
    		              
   		    		/* non-zero means flush previous vlist */
          	     		/* non-zero means pause after the display */
d148 5
a152 1
stash_shell(struct shell *s, char *file_name, char *title, const struct bn_tol *tol)
d179 3
a181 1
nmg_kill_non_common_cracks(struct shell *sA, struct shell *sB)
d356 4
a359 1
nmg_classify_shared_edges_verts(struct shell *sA, struct shell *sB, long int **classlist)
d441 3
a443 1
nmg_kill_anti_loops(struct shell *s, const struct bn_tol *tol)
d552 2
a553 1
nmg_kill_wire_edges(struct shell *s)
d581 4
a584 1
static struct shell * nmg_bool(struct shell *sA, struct shell *sB, const int oper, const struct bn_tol *tol)
d1090 4
a1093 1
nmg_do_bool(struct nmgregion *rA, struct nmgregion *rB, const int oper, const struct bn_tol *tol)
d1154 5
a1158 1
nmg_booltree_leaf_tess(struct db_tree_state *tsp, struct db_full_path *pathp, struct rt_db_internal *ip, genptr_t client_data)
d1219 5
a1223 1
nmg_booltree_leaf_tnurb(struct db_tree_state *tsp, struct db_full_path *pathp, struct rt_db_internal *ip, genptr_t client_data)
d1288 4
a1291 1
nmg_booltree_evaluate(register union tree *tp, const struct bn_tol *tol, struct resource *resp)
@


11.21.2.2
log
@sync branch with HEAD
@
text
@d23 1
a23 1
 *	This software is Copyright (C) 1993-2004 by the United States Army
d27 1
a27 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
@


11.20
log
@Converted from K&R to ANSI C - RFH
@
text
@d53 4
a56 1
nmg_dangling_handler(long int *longp, genptr_t state, int first)
d82 3
a84 1
nmg_has_dangling_faces(long int *magic_p, const char *manifolds)
d113 5
a117 5
nmg_show_each_loop(struct shell *s, long int **classlist, int new, int fancy, const char *str)
            	   
    		              
   		    		/* non-zero means flush previous vlist */
          	     		/* non-zero means pause after the display */
d148 5
a152 1
stash_shell(struct shell *s, char *file_name, char *title, const struct bn_tol *tol)
d179 3
a181 1
nmg_kill_non_common_cracks(struct shell *sA, struct shell *sB)
d356 4
a359 1
nmg_classify_shared_edges_verts(struct shell *sA, struct shell *sB, long int **classlist)
d441 3
a443 1
nmg_kill_anti_loops(struct shell *s, const struct bn_tol *tol)
d552 2
a553 1
nmg_kill_wire_edges(struct shell *s)
d581 4
a584 1
static struct shell * nmg_bool(struct shell *sA, struct shell *sB, const int oper, const struct bn_tol *tol)
d1090 4
a1093 1
nmg_do_bool(struct nmgregion *rA, struct nmgregion *rB, const int oper, const struct bn_tol *tol)
d1154 5
a1158 1
nmg_booltree_leaf_tess(struct db_tree_state *tsp, struct db_full_path *pathp, struct rt_db_internal *ip, genptr_t client_data)
d1219 5
a1223 1
nmg_booltree_leaf_tnurb(struct db_tree_state *tsp, struct db_full_path *pathp, struct rt_db_internal *ip, genptr_t client_data)
d1288 4
a1291 1
nmg_booltree_evaluate(register union tree *tp, const struct bn_tol *tol, struct resource *resp)
@


11.19
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_bool.c,v 11.18 2001/04/20 22:29:49 morrison Exp $ (ARL)";
d53 1
a53 4
nmg_dangling_handler( longp, state, first )
long		*longp;
genptr_t	state;
int		first;
d79 1
a79 3
nmg_has_dangling_faces( magic_p, manifolds )
long		*magic_p;
const char	*manifolds;
d108 5
a112 5
nmg_show_each_loop(s, classlist, new, fancy, str)
struct shell	*s;
long		*classlist[4];
int		new;		/* non-zero means flush previous vlist */
const char	*str;		/* non-zero means pause after the display */
d143 1
a143 5
stash_shell( s, file_name, title, tol )
struct shell *s;
char *file_name;
char *title;
struct bn_tol *tol;
d170 1
a170 3
nmg_kill_non_common_cracks( sA, sB )
struct shell *sA;
struct shell *sB;
d345 1
a345 4
nmg_classify_shared_edges_verts( sA, sB, classlist )
struct shell *sA;
struct shell *sB;
long *classlist[8];
d427 1
a427 3
nmg_kill_anti_loops( s, tol )
struct shell *s;
const struct bn_tol *tol;
d536 1
a536 2
nmg_kill_wire_edges( s )
struct shell *s;
d564 1
a564 4
static struct shell * nmg_bool(sA, sB, oper, tol)
struct shell *sA, *sB;
const int		oper;
const struct bn_tol	*tol;
d1070 1
a1070 4
nmg_do_bool(rA, rB, oper, tol)
struct nmgregion *rA, *rB;
const int		oper;
const struct bn_tol	*tol;
d1131 1
a1131 5
nmg_booltree_leaf_tess(tsp, pathp, ip, client_data)
struct db_tree_state	*tsp;
struct db_full_path	*pathp;
struct rt_db_internal	*ip;
genptr_t		client_data;
d1192 1
a1192 5
nmg_booltree_leaf_tnurb(tsp, pathp, ip, client_data)
struct db_tree_state	*tsp;
struct db_full_path	*pathp;
struct rt_db_internal	*ip;
genptr_t		client_data;
d1257 1
a1257 4
nmg_booltree_evaluate(tp, tol, resp)
register union tree		*tp;
const struct bn_tol		*tol;
struct resource			*resp;
@


11.18
log
@CONST to const
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_bool.c,v 11.17 2001/03/29 21:35:57 jra Exp $ (ARL)";
d1194 1
a1194 1
	if (rt_g.debug&DEBUG_TREEWALK)
d1256 1
a1256 1
	if (rt_g.debug&DEBUG_TREEWALK)
@


11.17
log
@nmg_booltree_evaluate() needed to do some cleanup when results are empty.
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_bool.c,v 11.16 2000/09/08 05:54:42 mike Exp $ (ARL)";
d46 1
a46 1
	CONST char	*manifolds;
d84 1
a84 1
CONST char	*manifolds;
d117 1
a117 1
CONST char	*str;		/* non-zero means pause after the display */
d443 1
a443 1
CONST struct bn_tol *tol;
d583 2
a584 2
CONST int		oper;
CONST struct bn_tol	*tol;
d1092 2
a1093 2
CONST int		oper;
CONST struct bn_tol	*tol;
d1290 1
a1290 1
CONST struct bn_tol		*tol;
d1297 1
a1297 1
	CONST char		*op_str;
@


11.16
log
@
Modified tree routines to take resource pointer.
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_bool.c,v 11.15 2000/08/29 04:03:11 mike Exp $ (ARL)";
d1339 2
d1348 2
@


11.15
log
@
externs
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_bool.c,v 11.14 2000/08/21 02:02:31 butler Exp $ (ARL)";
d1169 1
d1188 1
a1188 1
	BU_GETUNION(curtree, tree);
d1233 1
d1250 1
a1250 1
	BU_GETUNION(curtree, tree);
d1288 1
a1288 1
nmg_booltree_evaluate(tp, tol)
d1291 1
d1302 1
d1330 2
a1331 2
	tl = nmg_booltree_evaluate(tp->tr_b.tb_left, tol);
	tr = nmg_booltree_evaluate(tp->tr_b.tb_right, tol);
d1338 1
a1338 1
		db_free_tree(tr);
d1345 1
a1345 1
			db_free_tree(tl);
d1401 2
a1402 2
	db_free_tree(tl);
	db_free_tree(tr);
d1427 1
a1427 1
nmg_boolean( union tree *tp, struct model *m, const struct bn_tol *tol )
d1435 1
d1454 1
a1454 1
	result = nmg_booltree_evaluate( tp, tol );
@


11.14
log
@Massive compilation warnings eliminated
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_bool.c,v 11.13 2000/07/10 23:01:38 mike Exp $ (ARL)";
d1423 1
a1423 4
nmg_boolean( tp, m, tol )
register union tree		*tp;
struct model			*m;
CONST struct bn_tol		*tol;
@


11.13
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_bool.c,v 11.12 2000/06/27 17:36:09 mike Exp $ (ARL)";
d33 1
@


11.12
log
@
Modified calling sequence to leaf node callback for db_recurse()
and db_walk_tree().
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_bool.c,v 11.11 2000/04/01 03:34:12 mike Exp $ (ARL)";
@


11.11
log
@
parameter lint
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_bool.c,v 11.10 2000/03/29 02:59:46 mike Exp $ (ARL)";
d1153 1
a1153 1
nmg_booltree_leaf_tess(tsp, pathp, ep, id, client_data)
d1156 1
a1156 2
struct bu_external	*ep;
int			id;
a1158 1
	struct rt_db_internal	intern;
d1167 1
a1172 8
	RT_INIT_DB_INTERNAL(&intern);
	if (rt_functab[id].ft_import(&intern, ep, tsp->ts_mat, tsp->ts_dbip) < 0) {
		bu_log("nmg_booltree_leaf_tess(%s):  solid import failure\n", dp->d_namep);
	    	if (intern.idb_ptr)  rt_functab[id].ft_ifree(&intern);
	    	return(TREE_NULL);		/* ERROR */
	}
	RT_CK_DB_INTERNAL(&intern);

d1175 2
a1176 2
	if (rt_functab[id].ft_tessellate(
	    &r1, m, &intern, tsp->ts_ttol, tsp->ts_tol) < 0) {
a1177 1
		rt_functab[id].ft_ifree(&intern);
a1179 1
	rt_functab[id].ft_ifree(&intern);
d1217 1
a1217 1
nmg_booltree_leaf_tnurb(tsp, pathp, ep, id, client_data)
d1220 1
a1220 2
struct bu_external	*ep;
int			id;
a1222 1
	struct rt_db_internal	intern;
d1230 1
d1236 2
a1237 10
	RT_INIT_DB_INTERNAL(&intern);
	if (rt_functab[id].ft_import(&intern, ep, tsp->ts_mat, tsp->ts_dbip) < 0) {
		bu_log("nmg_booltree_leaf_tess(%s):  solid import failure\n", dp->d_namep);
	    	if (intern.idb_ptr)  rt_functab[id].ft_ifree(&intern);
	    	return(TREE_NULL);		/* ERROR */
	}
	RT_CK_DB_INTERNAL(&intern);

	if (rt_functab[id].ft_tnurb(
	    &r1, *tsp->ts_m, &intern, tsp->ts_tol) < 0) {
a1238 1
		rt_functab[id].ft_ifree(&intern);
a1240 1
	rt_functab[id].ft_ifree(&intern);
@


11.11.2.1
log
@nmg_booltree_evaluate() needed to do some cleanup when results are empty.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_bool.c,v 11.11 2000/04/01 03:34:12 mike Exp $ (ARL)";
a1355 2
		tp->tr_b.tb_right = TREE_NULL;
		tp->tr_op = OP_NOP;
a1362 2
			tp->tr_b.tb_left = TREE_NULL;
			tp->tr_op = OP_NOP;
@


11.10
log
@
Removed stray extern.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_bool.c,v 11.9 2000/01/04 17:58:20 bparker Exp $ (ARL)";
d933 1
a933 1
		nmg_show_broken_classifier_stuff(sA, &classlist[0],
d935 1
a935 1
		nmg_show_broken_classifier_stuff(sB, &classlist[4], 1, 1, "unclassed sB");
d962 2
a963 2
		nmg_show_broken_classifier_stuff(sA, &classlist[0], 1, 0, "sA classed");
		nmg_show_broken_classifier_stuff(sB, &classlist[4], 1, 0, "sB classed");
d1021 1
a1021 1
			nmg_show_broken_classifier_stuff(sA, &classlist[0], 1, 0, "sA result");
@


11.9
log
@*- add client_data to db_walk_tree
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_bool.c,v 11.8 1999/12/30 15:18:56 jra Exp $ (ARL)";
a40 2

RT_EXTERN( struct vertexuse *nmg_find_vertex_in_lu, ( struct vertex *v1, struct loopuse *lu2 ) );
@


11.8
log
@Eliminated some unused variables
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_bool.c,v 11.7 1999/06/03 01:39:14 mike Exp $ (ARL)";
d1155 1
a1155 1
nmg_booltree_leaf_tess(tsp, pathp, ep, id)
d1160 1
d1230 1
a1230 1
nmg_booltree_leaf_tnurb(tsp, pathp, ep, id)
d1235 1
@


11.7
log
@
sed4
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_bool.c,v 11.6 1999/05/11 19:26:13 mike Exp $ (ARL)";
a185 1
	int empty_shell=0;
a265 1
				empty_shell = 1;
a342 1
				empty_shell = 1;
a448 1
	int empty_fu;
@


11.6
log
@Neatened up output blather
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_bool.c,v 11.5 1998/09/14 15:59:17 bparker Exp $ (ARL)";
d93 1
a93 1
	st.visited = (char *)rt_calloc(m->maxindex+1, sizeof(char), "visited[]");
d101 1
a101 1
	rt_free( (char *)st.visited, "visited[]");
d745 1
a745 1
	classlist[0] = (long *)rt_calloc( 8 * nelem + 1,
d931 1
a931 1
	classlist[0] = (long *)rt_calloc( 8 * nelem + 1,
d1068 1
a1068 1
	rt_free( (char *)classlist[0], "nmg_bool classlist[8]" );
d1413 1
a1413 1
	name = (char *)rt_malloc( strlen(tl->tr_d.td_name)+3+strlen(tr->tr_d.td_name)+2+1,
@


11.5
log
@*- fix typos
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_bool.c,v 11.4 1998/07/31 20:36:44 jra Exp $ (ARL)";
d1017 3
a1019 5
			bu_log("Dangling faces detected in model after boolean\n");
#if 1
			nmg_stash_model_to_file( "dangle.g", m, "After Boolean" );
			rt_bomb("Dangling faces detected after boolean\n");
#endif
@


11.4
log
@Added a nmg_unbreak_region_edges() call to nmg_bool() to help triangulator.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_bool.c,v 11.3 1998/03/19 15:57:01 jra Exp $ (ARL)";
d137 1
a137 1
			sprintf(buf, "%s=x%x", str, lu);
d142 1
a142 1
		sprintf(buf, "%s=x%x (wire)", str, lu);
@


11.3
log
@Cahnged to new calling sequence for ft_import and ft_export.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_bool.c,v 11.2 1998/01/29 06:41:05 mike Exp jra $ (ARL)";
d1039 2
@


11.2
log
@Because of file corruption in the RCS archive,
all development history up to this point has been lost.
But the code is still ok!
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_bool.c,v 11.26 1998/01/29 06:35:02 mike Exp $ (ARL)";
d1180 1
a1180 1
	if (rt_functab[id].ft_import(&intern, ep, tsp->ts_mat) < 0) {
d1253 1
a1253 1
	if (rt_functab[id].ft_import(&intern, ep, tsp->ts_mat) < 0) {
@


11.1
log
@Release_4.4
@
text
@d1 1
a1 2
/*
 *			N M G _ B O O L . C
d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_bool.c,v 11.16 95/03/02 14:30:33 mike Exp $ (ARL)";
d42 2
d51 2
d127 1
a127 1
	for( RT_LIST_FOR( fu, faceuse, &s->fu_hd ) )  {
d130 1
a130 1
		for( RT_LIST_FOR( lu, loopuse, &fu->lu_hd ) )  {
d132 1
a132 1
			if( RT_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC )
d141 1
a141 1
	for( RT_LIST_FOR( lu, loopuse, &s->lu_hd ) )  {
d148 428
d589 1
a589 1
CONST struct rt_tol	*tol;
d608 1
d620 1
a620 1
		rt_log("\n==================== Shell A:\n");
d622 1
a622 1
		rt_log("\n==================== Shell B:\n");
d624 1
a624 1
		rt_log("\n====================\n");
d627 1
d630 1
d635 3
a637 1
	if (nmg_ck_closed_surf(sA, tol)) {
d641 1
a641 1
				rt_log("Plotting unclosed NMG shell\n");
d649 1
a649 1
		rt_log("nmg_bool: sA is unclosed, barging ahead\n");
d652 1
a652 1
	if (nmg_ck_closed_surf(sB, tol)) {
d656 1
a656 1
				rt_log("Plotting unclosed NMG shell\n");
d663 1
a663 1
		rt_log("nmg_bool: sB is unclosed, barging ahead\n");
d672 1
a672 1
		rt_log("plotting shellA.pl\n");
d680 1
a680 1
		rt_log("plotting shellB.pl\n");
d696 1
a696 1
		rt_log("\n==================== Shell A: ====== before crackshells\n");
d698 1
a698 1
		rt_log("\n==================== Shell B:\n");
d700 1
a700 1
		rt_log("\n====================\n");
d706 6
a711 1
		nmg_stash_model_to_file( "before.g", m, "Before crackshells" );
d717 61
d789 1
a789 1
		rt_log("\n==================== Shell A: ====== before mesh_shell_shell\n");
d791 1
a791 1
		rt_log("\n==================== Shell B:\n");
d793 1
a793 1
		rt_log("\n====================\n");
d796 1
a796 1
			rt_log("NOTICE: nmg_bool: fused %d entities while cracking shells\n", i);
d803 1
a803 1
		rt_log("Dangling faces detected in rA before classification\n");
d805 1
a805 1
		rt_log("Dangling faces detected in rB before classification\n");
d807 1
a807 1
		rt_log("Dangling faces detected in model before classification\n");
d821 1
a821 1
		rt_log("\n==================== Shell A: ====== after mesh_shell_shell\n");
d823 1
a823 1
		rt_log("\n==================== Shell B:\n");
d825 1
a825 1
		rt_log("\n====================\n");
d828 1
d831 1
d838 8
d849 2
a850 1
		nmg_stash_model_to_file( "joined.g", m, "After s_join_touchingloops" );
d852 4
a855 9
	/* Separate any touching loops, so classifier does not have any
	 * really complex loops to do.
	 * In particular, it is necessary for (r410) to make
	 * interior (touching) loop segments into true interior loops
	 * that are separate from the exterior loop,
	 * so the classifier can assess each separately.
	 */
	nmg_s_split_touchingloops(sA, tol);
	nmg_s_split_touchingloops(sB, tol);
a860 1
#if 1
d862 17
a878 2
		nmg_stash_model_to_file( "after.g", m, "After crackshells" );
#endif
d886 1
a886 1
			rt_log("plotting Cracked_Shells.pl\n");
d896 1
a896 1
		rt_log("check 2\n");
d900 1
a900 1
		rt_log("nmg_bool() WARNING: sA unclosed before classification.  Boldly pressing on.\n");
d902 1
a902 1
		rt_log("nmg_bool() WARNING: sB unclosed before classification.  Boldly pressing on.\n");
d916 1
d936 1
a936 1

d974 1
a974 1
		rt_log( "Just before nmg_evaluate_boolean:\nShell A:\n" );
d976 1
a976 1
		rt_log( "Shell B:\n" );
d987 1
a987 1
		rt_log( "Just after nmg_evaluate_boolean:\nShell A:\n" );
d989 1
a989 1
		rt_log( "Shell B:\n" );
d997 1
a997 1
			rt_log("ERROR: nmg_bool: fused %d entities after BOOLEAN.  Isect bug.\n", i);
d1013 1
a1013 1
		rt_log("Dangling faces detected in rA after boolean\n");
d1015 1
a1015 1
			rt_log("Dangling faces detected in rB after boolean\n");
d1017 2
a1018 2
			rt_log("Dangling faces detected in model after boolean\n");
#if 0
d1040 9
d1054 1
a1054 1
				rt_log("nmg_bool() WARNING: sA unclosed at return, barging on.\n");
d1059 7
d1071 1
a1071 1
		rt_log("Returning from NMG_BOOL\n");
d1084 2
d1098 1
a1098 1
CONST struct rt_tol	*tol;
d1111 2
a1112 2
	s = nmg_bool(RT_LIST_FIRST(shell, &rA->s_hd),
		RT_LIST_FIRST(shell, &rB->s_hd),
d1124 1
d1126 7
d1162 1
a1162 1
struct rt_external	*ep;
d1166 1
d1172 1
a1172 1
	RT_CK_TOL(tsp->ts_tol);
d1181 1
a1181 1
		rt_log("nmg_booltree_leaf_tess(%s):  solid import failure\n", dp->d_namep);
d1187 2
d1190 73
a1262 2
	    &r1, *tsp->ts_m, &intern, tsp->ts_ttol, tsp->ts_tol) < 0) {
		rt_log("nmg_booltree_leaf_tess(%s): tessellation failure\n", dp->d_namep);
d1273 1
a1273 1
	GETUNION(curtree, tree);
d1276 1
a1276 1
	curtree->tr_d.td_name = rt_strdup(dp->d_namep);
d1280 1
a1280 1
		rt_log("nmg_booltree_leaf_tess(%s) OK\n", dp->d_namep);
d1313 1
a1313 1
CONST struct rt_tol		*tol;
d1323 1
a1323 1
	RT_CK_TOL(tol);
d1347 1
a1347 1
		rt_log("nmg_booltree_evaluate: bad op %d\n", tp->tr_op);
d1353 2
a1354 2
	if (tl == 0) {
		if (tr == 0)
d1362 2
a1363 2
	if (tr == 0) {
		if (tl == 0)
d1375 1
a1375 1
rt_log(" {%s}%s{%s}\n", tl->tr_d.td_name, op_str, tr->tr_d.td_name );
d1380 1
a1380 1
	    	rt_log("nmg_booltree_evaluate:  WARNING, non-closed shell (r), barging ahead\n");
d1382 1
a1382 1
	    	rt_log("nmg_booltree_evaluate:  WARNING, non-closed shell (l), barging ahead\n");
d1386 12
d1402 4
a1405 2
	NMG_CK_REGION(reg);
nmg_r_radial_check( reg, tol );
d1407 3
a1409 2
	if( rt_g.NMG_debug & DEBUG_VERIFY )  {
		nmg_vshell( &reg->s_hd, reg );
d1421 1
a1421 1
	/* Clean up child tree nodes (and their names) /
d1451 1
a1451 1
CONST struct rt_tol		*tol;
d1458 1
a1458 1
	RT_CK_TOL(tol);
d1461 1
a1461 1
		rt_log("\n\nnmg_boolean( tp=x%x, m=x%x ) START\n",
d1481 1
a1481 1
		rt_log("nmg_boolean() result of nmg_booltree_evaluate() op != OP_NMG_TESS\n");
d1491 2
d1497 1
a1497 1
		rt_log("nmg_boolean( tp=x%x, m=x%x ) END, ret=%d\n\n",
@
