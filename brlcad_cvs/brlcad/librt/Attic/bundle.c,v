head	11.17;
access;
symbols
	ansi-20040405-merged:11.13.2.2
	postmerge-20040405-ansi:11.15
	premerge-20040404-ansi:11.14
	postmerge-autoconf:11.14
	autoconf-freeze:11.13.10.3
	premerge-autoconf:11.14
	ansi-20040316-freeze:11.13.2.1
	postmerge-20040315-windows:11.14
	premerge-20040315-windows:11.14
	windows-20040315-freeze:11.13.4.1
	autoconf-20031203:11.13.10.1
	autoconf-20031202:11.13
	autoconf-branch:11.13.0.10
	phong-branch:11.13.0.8
	photonmap-branch:11.13.0.6
	rel-6-1-DP:11.13
	windows-branch:11.13.0.4
	rel-6-0-2:11.11
	ansi-branch:11.13.0.2
	rel-6-0-1-branch:11.11.0.2
	hartley-6-0-post:11.12
	hartley-6-0-pre:11.11
	rel-6-0-1:11.11
	rel-6-0:11.11
	rel-5-4:11.6
	offsite-5-3-pre:11.8
	rel-5-3:11.6
	rel-5-2:11.6
	rel-5-1-branch:11.6.0.2
	rel-5-1:11.6;
locks; strict;
comment	@ * @;


11.17
date	2004.05.21.18.07.29;	author morrison;	state dead;
branches;
next	11.16;

11.16
date	2004.05.10.15.30.45;	author erikg;	state Exp;
branches;
next	11.15;

11.15
date	2004.04.05.08.48.56;	author morrison;	state Exp;
branches;
next	11.14;

11.14
date	2003.10.29.16.19.05;	author jra;	state Exp;
branches;
next	11.13;

11.13
date	2002.08.20.17.07.56;	author jra;	state Exp;
branches
	11.13.2.1
	11.13.4.1
	11.13.10.1;
next	11.12;

11.12
date	2002.08.15.20.55.07;	author hartley;	state Exp;
branches;
next	11.11;

11.11
date	2002.01.10.18.12.40;	author butler;	state Exp;
branches;
next	11.10;

11.10
date	2001.05.17.20.05.23;	author morrison;	state Exp;
branches;
next	11.9;

11.9
date	2001.04.20.22.29.40;	author morrison;	state Exp;
branches;
next	11.8;

11.8
date	2000.09.08.05.54.40;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	2000.07.10.23.01.26;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	2000.05.10.01.46.11;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	2000.03.29.18.28.03;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	2000.03.28.20.50.44;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	99.11.02.03.07.07;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	99.10.30.04.06.42;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	99.10.23.00.04.37;	author mike;	state Exp;
branches;
next	;

11.13.2.1
date	2002.09.19.18.01.29;	author morrison;	state Exp;
branches;
next	11.13.2.2;

11.13.2.2
date	2004.03.17.21.18.41;	author morrison;	state Exp;
branches;
next	;

11.13.4.1
date	2004.03.11.23.43.34;	author morrison;	state Exp;
branches;
next	;

11.13.10.1
date	2003.12.03.16.24.06;	author erikg;	state Exp;
branches;
next	11.13.10.2;

11.13.10.2
date	2004.02.12.18.37.38;	author erikg;	state Exp;
branches;
next	11.13.10.3;

11.13.10.3
date	2004.03.15.14.07.16;	author erikg;	state Exp;
branches;
next	;


desc
@@


11.17
log
@moved to src/
@
text
@/*
 *			B U N D L E . C
 * NOTE:  This is experimental code right now.
 *
 *  Author -
 *	Michael John Muuss
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1985,1991 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSbundle[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/bundle.c,v 11.16 2004/05/10 15:30:45 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#include "machine.h"
#include "vmath.h"
#include "bu.h"
#include "bn.h"
#include "raytrace.h"
#include "./debug.h"

extern void	rt_plot_cell(union cutter *cutp, struct rt_shootray_status *ssp, struct bu_list *waiting_segs_hd, struct rt_i *rtip);		/* at end of file */

/*
 *			R T _ F I N D _ N U G R I D
 *
 *  Along the given axis, find which NUgrid cell this value lies in.
 *  Use method of binary subdivision.
 */
extern int	rt_find_nugrid(struct nugridnode *nugnp, int axis, fastf_t val);


/*
 *			R T _ A D V A N C E _ T O _ N E X T _ C E L L
 */
extern const union cutter *rt_advance_to_next_cell(register struct rt_shootray_status *ssp);

/*
 *			R T _ S H O O T R A Y _ B U N D L E
 *
 *  Note that the direction vector r_dir
 *  must have unit length;  this is mandatory, and is not ordinarily checked,
 *  in the name of efficiency.
 *
 *  Input:  Pointer to an application structure, with these mandatory fields:
 *	a_ray.r_pt	Starting point of ray to be fired
 *	a_ray.r_dir	UNIT VECTOR with direction to fire in (dir cosines)
 *	a_hit		Routine to call when something is hit
 *	a_miss		Routine to call when ray misses everything
 *
 *  Calls user's a_miss() or a_hit() routine as appropriate.
 *  Passes a_hit() routine list of partitions, with only hit_dist
 *  fields valid.  Normal computation deferred to user code,
 *  to avoid needless computation here.
 *
 *  Formal Return: whatever the application function returns (an int).
 *
 *  NOTE:  The appliction functions may call rt_shootray() recursively.
 *	Thus, none of the local variables may be static.
 *
 *  To prevent having to lock the statistics variables in a PARALLEL
 *  environment, all the statistics variables have been moved into
 *  the 'resource' structure, which is allocated per-CPU.
 */

/* XXX maybe parameter with NORM, UV, CURVE bits? */

int
rt_shootray_bundle(register struct application *ap, struct xray *rays, int nrays)
{
	struct rt_shootray_status	ss;
	struct seg		new_segs;	/* from solid intersections */
	struct seg		waiting_segs;	/* awaiting rt_boolweave() */
	struct seg		finished_segs;	/* processed by rt_boolweave() */
	fastf_t			last_bool_start;
	struct bu_bitv		*solidbits;	/* bits for all solids shot so far */
	struct bu_ptbl		*regionbits;	/* table of all involved regions */
	char			*status;
	auto struct partition	InitialPart;	/* Head of Initial Partitions */
	auto struct partition	FinalPart;	/* Head of Final Partitions */
	struct soltab		**stpp;
	register const union cutter *cutp;
	struct resource		*resp;
	struct rt_i		*rtip;
	const int		debug_shoot = RT_G_DEBUG & DEBUG_SHOOT;

	RT_AP_CHECK(ap);
	if( ap->a_magic )  {
		RT_CK_AP(ap);
	} else {
		ap->a_magic = RT_AP_MAGIC;
	}
	if( ap->a_ray.magic )  {
		RT_CK_RAY(&(ap->a_ray));
	} else {
		ap->a_ray.magic = RT_RAY_MAGIC;
	}
	if( ap->a_resource == RESOURCE_NULL )  {
		ap->a_resource = &rt_uniresource;
		rt_uniresource.re_magic = RESOURCE_MAGIC;
		if(RT_G_DEBUG)bu_log("rt_shootray_bundle:  defaulting a_resource to &rt_uniresource\n");
	}
	ss.ap = ap;
	rtip = ap->a_rt_i;
	RT_CK_RTI( rtip );
	resp = ap->a_resource;
	RT_RESOURCE_CHECK(resp);
	ss.resp = resp;

	if(RT_G_DEBUG&(DEBUG_ALLRAYS|DEBUG_SHOOT|DEBUG_PARTITION|DEBUG_ALLHITS)) {
		bu_log_indent_delta(2);
		bu_log("\n**********shootray_bundle cpu=%d  %d,%d lvl=%d (%s)\n",
			resp->re_cpu,
			ap->a_x, ap->a_y,
			ap->a_level,
			ap->a_purpose != (char *)0 ? ap->a_purpose : "?" );
		bu_log("Pnt (%g, %g, %g) a_onehit=%d\n",
			V3ARGS(ap->a_ray.r_pt),
			ap->a_onehit );
		VPRINT("Dir", ap->a_ray.r_dir);
	}
	if(RT_BADVEC(ap->a_ray.r_pt)||RT_BADVEC(ap->a_ray.r_dir))  {
		bu_log("\n**********shootray cpu=%d  %d,%d lvl=%d (%s)\n",
			resp->re_cpu,
			ap->a_x, ap->a_y,
			ap->a_level,
			ap->a_purpose != (char *)0 ? ap->a_purpose : "?" );
		VPRINT(" r_pt", ap->a_ray.r_pt);
		VPRINT("r_dir", ap->a_ray.r_dir);
		rt_bomb("rt_shootray_bundle() bad ray\n");
	}

	if( rtip->needprep )
		rt_prep(rtip);

	InitialPart.pt_forw = InitialPart.pt_back = &InitialPart;
	InitialPart.pt_magic = PT_HD_MAGIC;
	FinalPart.pt_forw = FinalPart.pt_back = &FinalPart;
	FinalPart.pt_magic = PT_HD_MAGIC;
	ap->a_Final_Part_hdp = &FinalPart;

	BU_LIST_INIT( &new_segs.l );
	BU_LIST_INIT( &waiting_segs.l );
	BU_LIST_INIT( &finished_segs.l );
	ap->a_finished_segs_hdp = &finished_segs;

	if( BU_LIST_UNINITIALIZED( &resp->re_parthead ) )  {
		/* XXX This shouldn't happen any more */
		bu_log("rt_shootray_bundle() resp=x%x uninitialized, fixing it\n", resp);
		/*
		 *  We've been handed a mostly un-initialized resource struct,
		 *  with only a magic number and a cpu number filled in.
		 *  Init it and add it to the table.
		 *  This is how application-provided resource structures
		 *  are remembered for later cleanup by the library.
		 */
		rt_init_resource( resp, resp->re_cpu, rtip );

		/* Ensure that this CPU's resource structure is registered */
		BU_ASSERT_PTR( BU_PTBL_GET(&rtip->rti_resources, resp->re_cpu), !=, NULL );
	}

	solidbits = get_solidbitv( rtip->nsolids, resp );
	bu_bitv_clear(solidbits);

	if( BU_LIST_IS_EMPTY( &resp->re_region_ptbl ) )  {
		BU_GETSTRUCT( regionbits, bu_ptbl );
		bu_ptbl_init( regionbits, 7, "rt_shootray_bundle() regionbits ptbl" );
	} else {
		regionbits = BU_LIST_FIRST( bu_ptbl, &resp->re_region_ptbl );
		BU_LIST_DEQUEUE( &regionbits->l );
		BU_CK_PTBL(regionbits);
	}

	/* Verify that direction vector has unit length */
	if(RT_G_DEBUG) {
		FAST fastf_t f, diff;
		f = MAGSQ(ap->a_ray.r_dir);
		if( NEAR_ZERO(f, 0.0001) )  {
			rt_bomb("rt_shootray_bundle:  zero length dir vector\n");
			return(0);
		}
		diff = f - 1;
		if( !NEAR_ZERO( diff, 0.0001 ) )  {
			bu_log("rt_shootray_bundle: non-unit dir vect (x%d y%d lvl%d)\n",
				ap->a_x, ap->a_y, ap->a_level );
			f = 1/f;
			VSCALE( ap->a_ray.r_dir, ap->a_ray.r_dir, f );
		}
	}

	/* Compute the inverse of the direction cosines */
	if( ap->a_ray.r_dir[X] < -SQRT_SMALL_FASTF )  {
		ss.abs_inv_dir[X] = -(ss.inv_dir[X]=1.0/ap->a_ray.r_dir[X]);
		ss.rstep[X] = -1;
	} else if( ap->a_ray.r_dir[X] > SQRT_SMALL_FASTF )  {
		ss.abs_inv_dir[X] =  (ss.inv_dir[X]=1.0/ap->a_ray.r_dir[X]);
		ss.rstep[X] = 1;
	} else {
		ap->a_ray.r_dir[X] = 0.0;
		ss.abs_inv_dir[X] = ss.inv_dir[X] = INFINITY;
		ss.rstep[X] = 0;
	}
	if( ap->a_ray.r_dir[Y] < -SQRT_SMALL_FASTF )  {
		ss.abs_inv_dir[Y] = -(ss.inv_dir[Y]=1.0/ap->a_ray.r_dir[Y]);
		ss.rstep[Y] = -1;
	} else if( ap->a_ray.r_dir[Y] > SQRT_SMALL_FASTF )  {
		ss.abs_inv_dir[Y] =  (ss.inv_dir[Y]=1.0/ap->a_ray.r_dir[Y]);
		ss.rstep[Y] = 1;
	} else {
		ap->a_ray.r_dir[Y] = 0.0;
		ss.abs_inv_dir[Y] = ss.inv_dir[Y] = INFINITY;
		ss.rstep[Y] = 0;
	}
	if( ap->a_ray.r_dir[Z] < -SQRT_SMALL_FASTF )  {
		ss.abs_inv_dir[Z] = -(ss.inv_dir[Z]=1.0/ap->a_ray.r_dir[Z]);
		ss.rstep[Z] = -1;
	} else if( ap->a_ray.r_dir[Z] > SQRT_SMALL_FASTF )  {
		ss.abs_inv_dir[Z] =  (ss.inv_dir[Z]=1.0/ap->a_ray.r_dir[Z]);
		ss.rstep[Z] = 1;
	} else {
		ap->a_ray.r_dir[Z] = 0.0;
		ss.abs_inv_dir[Z] = ss.inv_dir[Z] = INFINITY;
		ss.rstep[Z] = 0;
	}

	/*
	 *  If ray does not enter the model RPP, skip on.
	 *  If ray ends exactly at the model RPP, trace it.
	 */
	if( !rt_in_rpp( &ap->a_ray, ss.inv_dir, rtip->mdl_min, rtip->mdl_max )  ||
	    ap->a_ray.r_max < 0.0 )  {
		resp->re_nmiss_model++;
		ap->a_return = ap->a_miss( ap );
		status = "MISS model";
		goto out;
	}

	/*
	 *  The interesting part of the ray starts at distance 0.
	 *  If the ray enters the model at a negative distance,
	 *  (ie, the ray starts within the model RPP),
	 *  we only look at little bit behind (BACKING_DIST) to see if we are
	 *  just coming out of something, but never further back than
	 *  the intersection with the model RPP.
	 *  If the ray enters the model at a positive distance,
	 *  we always start there.
	 *  It is vital that we never pick a start point outside the
	 *  model RPP, or the space partitioning tree will pick the
	 *  wrong box and the ray will miss it.
	 *
	 *  BACKING_DIST should probably be determined by floating point
	 *  noise factor due to model RPP size -vs- number of bits of
	 *  floating point mantissa significance, rather than a constant,
	 *  but that is too hideous to think about here.
	 *  Also note that applications that really depend on knowing
	 *  what region they are leaving from should probably back their
	 *  own start-point up, rather than depending on it here, but
	 *  it isn't much trouble here.
	 */
	ss.box_start = ss.model_start = ap->a_ray.r_min;
	ss.box_end = ss.model_end = ap->a_ray.r_max;

	if( ss.box_start < BACKING_DIST )
		ss.box_start = BACKING_DIST; /* Only look a little bit behind */

	ss.lastcut = CUTTER_NULL;
	ss.old_status = (struct rt_shootray_status *)NULL;
	ss.curcut = &ap->a_rt_i->rti_CutHead;
	if( ss.curcut->cut_type == CUT_NUGRIDNODE ) {
		ss.lastcell = CUTTER_NULL;
		VSET( ss.curmin, ss.curcut->nugn.nu_axis[X][0].nu_spos,
				 ss.curcut->nugn.nu_axis[Y][0].nu_spos,
				 ss.curcut->nugn.nu_axis[Z][0].nu_spos );
		VSET( ss.curmax, ss.curcut->nugn.nu_axis[X][ss.curcut->nugn.nu_cells_per_axis[X]-1].nu_epos,
				 ss.curcut->nugn.nu_axis[Y][ss.curcut->nugn.nu_cells_per_axis[Y]-1].nu_epos,
				 ss.curcut->nugn.nu_axis[Z][ss.curcut->nugn.nu_cells_per_axis[Z]-1].nu_epos );
	} else if( ss.curcut->cut_type == CUT_CUTNODE ||
		   ss.curcut->cut_type == CUT_BOXNODE ) {
		ss.lastcell = ss.curcut;
		VMOVE( ss.curmin, rtip->mdl_min );
		VMOVE( ss.curmax, rtip->mdl_max );
	}

	last_bool_start = BACKING_DIST;
	ss.newray = ap->a_ray;		/* struct copy */
	ss.odist_corr = ss.obox_start = ss.obox_end = -99;
	ss.dist_corr = 0.0;

	/*
	 *  While the ray remains inside model space,
	 *  push from box to box until ray emerges from
	 *  model space again (or first hit is found, if user is impatient).
	 *  It is vitally important to always stay within the model RPP, or
	 *  the space partitoning tree will pick wrong boxes & miss them.
	 */
	while( (cutp = rt_advance_to_next_cell( &ss )) != CUTTER_NULL )  {
		if(debug_shoot) {
			rt_pr_cut( cutp, 0 );
		}

		if( cutp->bn.bn_len <= 0 )  {
			/* Push ray onwards to next box */
			ss.box_start = ss.box_end;
			resp->re_nempty_cells++;
			continue;
		}

		/* Consider all objects within the box */
		stpp = &(cutp->bn.bn_list[cutp->bn.bn_len-1]);
		for( ; stpp >= cutp->bn.bn_list; stpp-- )  {
			register struct soltab *stp = *stpp;
			int ray;

			if( BU_BITTEST( solidbits, stp->st_bit ) )  {
				resp->re_ndup++;
				continue;	/* already shot */
			}

			/* Shoot all the rays in the bundle through this solid */
			/* XXX open issue: entering neighboring cells too? */
			BU_BITSET( solidbits, stp->st_bit );

			for( ray=0; ray < nrays; ray++ )  {
				struct xray	ss2_newray;

				/* Be compatible with the ss backing distance stuff */
				VMOVE( ss2_newray.r_dir, rays[ray].r_dir );
				VJOIN1( ss2_newray.r_pt, rays[ray].r_pt, ss.dist_corr, ss2_newray.r_dir );

				/* Check against bounding RPP, if desired by solid */
				if( rt_functab[stp->st_id].ft_use_rpp )  {
					if( !rt_in_rpp( &ss2_newray, ss.inv_dir,
					    stp->st_min, stp->st_max ) )  {
						if(debug_shoot)bu_log("rpp miss %s by ray %d\n", stp->st_name, ray);
						resp->re_prune_solrpp++;
						continue;	/* MISS */
					}
					if( ss.dist_corr + ss2_newray.r_max < BACKING_DIST )  {
						if(debug_shoot)bu_log("rpp skip %s, dist_corr=%g, r_max=%g, by ray %d\n", stp->st_name, ss.dist_corr, ss2_newray.r_max, ray);
						resp->re_prune_solrpp++;
						continue;	/* MISS */
					}
				}

				if(debug_shoot)bu_log("shooting %s with ray %d\n", stp->st_name, ray);
				resp->re_shots++;
				BU_LIST_INIT( &(new_segs.l) );
				if( rt_functab[stp->st_id].ft_shot( 
				    stp, &ss2_newray, ap, &new_segs ) <= 0 )  {
					resp->re_shot_miss++;
					continue;	/* MISS */
				}

				/* Add seg chain to list awaiting rt_boolweave() */
				{
					register struct seg *s2;
					while(BU_LIST_WHILE(s2,seg,&(new_segs.l)))  {
						BU_LIST_DEQUEUE( &(s2->l) );
						/* Restore to original distance */
						s2->seg_in.hit_dist += ss.dist_corr;
						s2->seg_out.hit_dist += ss.dist_corr;
						s2->seg_in.hit_rayp = s2->seg_out.hit_rayp = &rays[ray];
						BU_LIST_INSERT( &(waiting_segs.l), &(s2->l) );
					}
				}
				resp->re_shot_hit++;
				break;			/* HIT */
			}
		}
		if( RT_G_DEBUG & DEBUG_ADVANCE )
			rt_plot_cell( cutp, &ss, &(waiting_segs.l), rtip);

		/*
		 *  If a_onehit == 0 and a_ray_length <= 0, then the ray
		 *  is traced to +infinity.
		 *
		 *  If a_onehit != 0, then it indicates how many hit points
		 *  (which are greater than the ray start point of 0.0)
		 *  the application requires, ie, partitions with inhit >= 0.
		 *  (If negative, indicates number of non-air hits needed).
		 *  If this box yielded additional segments,
		 *  immediately weave them into the partition list,
		 *  and perform final boolean evaluation.
		 *  If this results in the required number of final
		 *  partitions, then cease ray-tracing and hand the
		 *  partitions over to the application.
		 *  All partitions will have valid in and out distances.
		 *  a_ray_length is treated similarly to a_onehit.
		 */
		if( ap->a_onehit != 0 && BU_LIST_NON_EMPTY( &(waiting_segs.l) ) )  {
			int	done;

			/* Weave these segments into partition list */
			rt_boolweave( &finished_segs, &waiting_segs, &InitialPart, ap );

			/* Evaluate regions upto box_end */
			done = rt_boolfinal( &InitialPart, &FinalPart,
				last_bool_start, ss.box_end, regionbits, ap, solidbits );
			last_bool_start = ss.box_end;

			/* See if enough partitions have been acquired */
			if( done > 0 )  goto hitit;
		}

		if( ap->a_ray_length > 0.0 && ss.box_end >= ap->a_ray_length )
			goto weave;

		/* Push ray onwards to next box */
		ss.box_start = ss.box_end;
	}

	/*
	 *  Ray has finally left known space --
	 *  Weave any remaining segments into the partition list.
	 */
weave:
	if( RT_G_DEBUG&DEBUG_ADVANCE )
		bu_log( "rt_shootray_bundle: ray has left known space\n" );
	
	if( BU_LIST_NON_EMPTY( &(waiting_segs.l) ) )  {
		rt_boolweave( &finished_segs, &waiting_segs, &InitialPart, ap );
	}

	/* finished_segs chain now has all segments hit by this ray */
	if( BU_LIST_IS_EMPTY( &(finished_segs.l) ) )  {
		ap->a_return = ap->a_miss( ap );
		status = "MISS prims";
		goto out;
	}

	/*
	 *  All intersections of the ray with the model have
	 *  been computed.  Evaluate the boolean trees over each partition.
	 */
	(void)rt_boolfinal( &InitialPart, &FinalPart, BACKING_DIST,
		INFINITY,
		regionbits, ap, solidbits);

	if( FinalPart.pt_forw == &FinalPart )  {
		ap->a_return = ap->a_miss( ap );
		status = "MISS bool";
		RT_FREE_PT_LIST( &InitialPart, resp );
		RT_FREE_SEG_LIST( &finished_segs, resp );
		goto out;
	}

	/*
	 *  Ray/model intersections exist.  Pass the list to the
	 *  user's a_hit() routine.  Note that only the hit_dist
	 *  elements of pt_inhit and pt_outhit have been computed yet.
	 *  To compute both hit_point and hit_normal, use the
	 *
	 *  	RT_HIT_NORM( hitp, stp, rayp )
	 *
	 *  macro.  To compute just hit_point, use
	 *
	 *  VJOIN1( hitp->hit_point, rp->r_pt, hitp->hit_dist, rp->r_dir );
	 */
hitit:
	if(debug_shoot)  rt_pr_partitions(rtip,&FinalPart,"a_hit()");

	/*
	 *  Before recursing, release storage for unused Initial partitions.
	 *  finished_segs can not be released yet, because FinalPart
	 *  partitions will point to hits in those segments.
	 */
	RT_FREE_PT_LIST( &InitialPart, resp );

	/*
	 *  finished_segs is only used by special hit routines
	 *  which don't follow the traditional solid modeling paradigm.
	 */
	if(RT_G_DEBUG&DEBUG_ALLHITS) rt_pr_partitions(rtip,&FinalPart,"Parition list passed to a_hit() routine");
	ap->a_return = ap->a_hit( ap, &FinalPart, &finished_segs );
	status = "HIT";

	RT_FREE_SEG_LIST( &finished_segs, resp );
	RT_FREE_PT_LIST( &FinalPart, resp );

	/*
	 * Processing of this ray is complete.
	 */
out:
	/*  Return dynamic resources to their freelists.  */
	BU_CK_BITV(solidbits);
	BU_LIST_APPEND( &resp->re_solid_bitv, &solidbits->l );
	BU_CK_PTBL(regionbits);
	BU_LIST_APPEND( &resp->re_region_ptbl, &regionbits->l );

	/*
	 *  Record essential statistics in per-processor data structure.
	 */
	resp->re_nshootray++;

	/* Terminate any logging */
	if(RT_G_DEBUG&(DEBUG_ALLRAYS|DEBUG_SHOOT|DEBUG_PARTITION|DEBUG_ALLHITS))  {
		bu_log_indent_delta(-2);
		bu_log("----------shootray_bundle cpu=%d  %d,%d lvl=%d (%s) %s ret=%d\n",
			resp->re_cpu,
			ap->a_x, ap->a_y,
			ap->a_level,
			ap->a_purpose != (char *)0 ? ap->a_purpose : "?",
			status, ap->a_return);
	}
	return( ap->a_return );
}
@


11.16
log
@change conf.h to a wrapped config.h
@
text
@d18 1
a18 1
static const char RCSbundle[] = "@@(#)$Header: /cvs/brlcad/librt/bundle.c,v 11.15 2004/04/05 08:48:56 morrison Exp $ (BRL)";
@


11.15
log
@merge of ansi-6-0-branch into HEAD
@
text
@d18 1
a18 1
static const char RCSbundle[] = "@@(#)$Header$ (BRL)";
d21 5
a25 1
#include "conf.h"
@


11.14
log
@Now calls get_solidbitv() instead of doing it itself
@
text
@d18 1
a18 1
static const char RCSbundle[] = "@@(#)$Header: /c/CVS/brlcad/librt/bundle.c,v 11.13 2002/08/20 17:07:56 jra Exp $ (BRL)";
d32 1
a32 1
extern void	rt_plot_cell();		/* at end of file */
d40 1
a40 1
extern int	rt_find_nugrid();
d46 1
a46 1
extern const union cutter *rt_advance_to_next_cell();
d79 1
a79 4
rt_shootray_bundle( ap, rays, nrays )
register struct application *ap;
struct xray		*rays;
int			nrays;
@


11.13
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d18 1
a18 1
static const char RCSbundle[] = "@@(#)$Header: /c/CVS/brlcad/librt/bundle.c,v 11.11 2002/01/10 18:12:40 butler Exp $ (BRL)";
d175 2
a176 8
	if( BU_LIST_IS_EMPTY( &resp->re_solid_bitv ) )  {
		solidbits = bu_bitv_new( rtip->nsolids );
	} else {
		solidbits = BU_LIST_FIRST( bu_bitv, &resp->re_solid_bitv );
		BU_LIST_DEQUEUE( &solidbits->l );
		BU_CK_BITV(solidbits);
		BU_BITV_NBITS_CHECK( solidbits, rtip->nsolids );
	}
@


11.13.4.1
log
@sync to HEAD...
@
text
@d18 1
a18 1
static const char RCSbundle[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/bundle.c,v 11.14 2003/10/29 16:19:05 jra Exp $ (BRL)";
d175 8
a182 2

	solidbits = get_solidbitv( rtip->nsolids, resp );
@


11.13.10.1
log
@updates from HEAD, part 1
@
text
@d18 1
a18 1
static const char RCSbundle[] = "@@(#)$Header: /c/CVS/brlcad/librt/bundle.c,v 11.14 2003/10/29 16:19:05 jra Exp $ (BRL)";
d175 8
a182 2

	solidbits = get_solidbitv( rtip->nsolids, resp );
@


11.13.10.2
log
@merge from HEAD
@
text
@@


11.13.10.3
log
@merge from head
@
text
@d18 1
a18 1
static const char RCSbundle[] = "@@(#)$Header: /c/CVS/brlcad/librt/bundle.c,v 11.13.10.2 2004/02/12 18:37:38 erikg Exp $ (BRL)";
@


11.13.2.1
log
@Initial ANSIfication
@
text
@d18 1
a18 1
static const char RCSbundle[] = "@@(#)$Header: /c/CVS/brlcad/librt/bundle.c,v 11.13 2002/08/20 17:07:56 jra Exp $ (BRL)";
d32 1
a32 1
extern void	rt_plot_cell(union cutter *cutp, struct rt_shootray_status *ssp, struct bu_list *waiting_segs_hd, struct rt_i *rtip);		/* at end of file */
d40 1
a40 1
extern int	rt_find_nugrid(struct nugridnode *nugnp, int axis, fastf_t val);
d46 1
a46 1
extern const union cutter *rt_advance_to_next_cell(register struct rt_shootray_status *ssp);
d79 4
a82 1
rt_shootray_bundle(register struct application *ap, struct xray *rays, int nrays)
@


11.13.2.2
log
@sync branch with HEAD
@
text
@d18 1
a18 1
static const char RCSbundle[] = "@@(#)$Header$ (BRL)";
d172 8
a179 2

	solidbits = get_solidbitv( rtip->nsolids, resp );
@


11.12
log
@Converted from K&R to ANSI C - RFH
@
text
@d32 1
a32 1
extern void	rt_plot_cell(union cutter *cutp, struct rt_shootray_status *ssp, struct bu_list *waiting_segs_hd, struct rt_i *rtip);		/* at end of file */
d40 1
a40 1
extern int	rt_find_nugrid(struct nugridnode *nugnp, int axis, fastf_t val);
d46 1
a46 1
extern const union cutter *rt_advance_to_next_cell(register struct rt_shootray_status *ssp);
d79 4
a82 1
rt_shootray_bundle(register struct application *ap, struct xray *rays, int nrays)
@


11.11
log
@Changed word "solids" to indicate "prims" or primitives"
@
text
@d18 1
a18 1
static const char RCSbundle[] = "@@(#)$Header: /c/CVS/brlcad/librt/bundle.c,v 11.10 2001/05/17 20:05:23 morrison Exp $ (BRL)";
d32 1
a32 1
extern void	rt_plot_cell();		/* at end of file */
d40 1
a40 1
extern int	rt_find_nugrid();
d46 1
a46 1
extern const union cutter *rt_advance_to_next_cell();
d79 1
a79 4
rt_shootray_bundle( ap, rays, nrays )
register struct application *ap;
struct xray		*rays;
int			nrays;
@


11.10
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d18 1
a18 1
static const char RCSbundle[] = "@@(#)$Header: /c/CVS/brlcad/librt/bundle.c,v 11.9 2001/04/20 22:29:40 morrison Exp $ (BRL)";
d447 1
a447 1
		status = "MISS solids";
@


11.9
log
@CONST to const
@
text
@d18 1
a18 1
static const char RCSbundle[] = "@@(#)$Header: /c/CVS/brlcad/librt/bundle.c,v 11.8 2000/09/08 05:54:40 mike Exp $ (BRL)";
d98 1
a98 1
	const int		debug_shoot = rt_g.debug & DEBUG_SHOOT;
d114 1
a114 1
		if(rt_g.debug)bu_log("rt_shootray_bundle:  defaulting a_resource to &rt_uniresource\n");
d123 1
a123 1
	if(rt_g.debug&(DEBUG_ALLRAYS|DEBUG_SHOOT|DEBUG_PARTITION|DEBUG_ALLHITS)) {
d195 1
a195 1
	if(rt_g.debug) {
d390 1
a390 1
		if( rt_g.debug & DEBUG_ADVANCE )
d437 1
a437 1
	if( rt_g.debug&DEBUG_ADVANCE )
d493 1
a493 1
	if(rt_g.debug&DEBUG_ALLHITS) rt_pr_partitions(rtip,&FinalPart,"Parition list passed to a_hit() routine");
d516 1
a516 1
	if(rt_g.debug&(DEBUG_ALLRAYS|DEBUG_SHOOT|DEBUG_PARTITION|DEBUG_ALLHITS))  {
@


11.8
log
@
Modified tree routines to take resource pointer.
@
text
@d18 1
a18 1
static const char RCSbundle[] = "@@(#)$Header: /c/CVS/brlcad/librt/bundle.c,v 11.7 2000/07/10 23:01:26 mike Exp $ (BRL)";
d46 1
a46 1
extern CONST union cutter *rt_advance_to_next_cell();
d95 1
a95 1
	register CONST union cutter *cutp;
d98 1
a98 1
	CONST int		debug_shoot = rt_g.debug & DEBUG_SHOOT;
@


11.7
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d18 1
a18 1
static const char RCSbundle[] = "@@(#)$Header: /c/CVS/brlcad/librt/bundle.c,v 11.6 2000/05/10 01:46:11 mike Exp $ (BRL)";
d161 2
d170 1
a170 1
		rt_init_resource( resp, resp->re_cpu );
d172 2
a173 3
		bu_semaphore_acquire(RT_SEM_MODEL);
		bu_ptbl_ins_unique( &rtip->rti_resources, (long *)resp );
		bu_semaphore_release(RT_SEM_MODEL);
@


11.6
log
@
Eliminated the special space-partitioning box for infinite solids.
Eliminated rti_inf_box
Thanks to Glenn's having implemented the per-solid classification method.
@
text
@d18 1
a18 1
static char RCSbundle[] = "@@(#)$Header: /c/CVS/brlcad/librt/bundle.c,v 11.5 2000/03/29 18:28:03 mike Exp $ (BRL)";
@


11.5
log
@
Got rid of AUTO define
@
text
@d18 1
a18 1
static char RCSbundle[] = "@@(#)$Header: /c/CVS/brlcad/librt/bundle.c,v 11.4 2000/03/28 20:50:44 mike Exp $ (BRL)";
a245 32
	 *  If there are infinite solids in the model,
	 *  shoot at all of them, all of the time
	 *  (until per-solid classification is implemented)
	 *  before considering the model RPP.
	 *  This code is a streamlined version of the real version.
	 */
	if( rtip->rti_inf_box.bn.bn_len > 0 )  {
		/* Consider all objects within the box */
		cutp = &(rtip->rti_inf_box);
		stpp = &(cutp->bn.bn_list[cutp->bn.bn_len-1]);
		for( ; stpp >= cutp->bn.bn_list; stpp-- )  {
			register struct soltab *stp = *stpp;

			/* Shoot a ray */
			if(debug_shoot)bu_log("shooting %s\n", stp->st_name);
			BU_BITSET( solidbits, stp->st_bit );
			resp->re_shots++;
			if( rt_functab[stp->st_id].ft_shot( 
			    stp, &ap->a_ray, ap, &waiting_segs ) <= 0 )  {
				resp->re_shot_miss++;
				continue;	/* MISS */
			}
			resp->re_shot_hit++;
			{
				register struct seg *segp =
					BU_LIST_FIRST(seg, &waiting_segs.l);
				segp->seg_in.hit_rayp = segp->seg_out.hit_rayp = &ap->a_ray;
			}
		}
	}

	/*
a250 9
	    	/* XXX it would be better to do the infinite objects here,
	    	 * XXX and let rt_advance_to_next_cell mention them otherwise,
	    	 * XXX such as when rays escape from the model RPP.
	    	 */
	    	if( BU_LIST_NON_EMPTY( &waiting_segs.l ) )  {
	    		/* Go handle the infinite objects we hit */
	    		ss.model_end = INFINITY;
	    		goto weave;
	    	}
@


11.4
log
@
Moved shootray_status to raytrace.h, added rt_ prefix
@
text
@d18 1
a18 1
static char RCSbundle[] = "@@(#)$Header: /c/CVS/brlcad/librt/bundle.c,v 11.3 1999/11/02 03:07:07 mike Exp $ (BRL)";
a33 6
#ifdef CRAY
#define AUTO register
#else
#define AUTO /*let the compiler decide*/
#endif

d88 1
a88 1
	AUTO fastf_t		last_bool_start;
d91 1
a91 1
	AUTO char		*status;
d94 1
a94 1
	AUTO struct soltab	**stpp;
d97 1
a97 1
	AUTO struct rt_i	*rtip;
@


11.3
log
@
bundle improvements
@
text
@d18 1
a18 1
static char RCSbundle[] = "@@(#)$Header: /c/CVS/brlcad/librt/bundle.c,v 11.2 1999/10/30 04:06:42 mike Exp $ (BRL)";
a39 44
#define NUGRID_T_SETUP(_ax,_cval,_cno) \
	if( ssp->rstep[_ax] > 0 ) { \
		ssp->tv[_ax] = t0 + (nu_axis[_ax][_cno].nu_epos - _cval) * \
					    ssp->inv_dir[_ax]; \
	} else if( ssp->rstep[_ax] < 0 ) { \
		ssp->tv[_ax] = t0 + (nu_axis[_ax][_cno].nu_spos - _cval) * \
					    ssp->inv_dir[_ax]; \
	} else { \
		ssp->tv[_ax] = INFINITY; \
	}
#define NUGRID_T_ADV(_ax,_cno) \
	if( ssp->rstep[_ax] != 0 )  { \
		ssp->tv[_ax] += nu_axis[_ax][_cno].nu_width * \
			ssp->abs_inv_dir[_ax]; \
	}

#define BACKING_DIST	(-2.0)		/* mm to look behind start point */
#define OFFSET_DIST	0.01		/* mm to advance point into box */

struct shootray_status {
	fastf_t			dist_corr;	/* correction distance */
	fastf_t			odist_corr;
	fastf_t			box_start;
	fastf_t			obox_start; 
	fastf_t			box_end;
	fastf_t			obox_end;
	fastf_t			model_start;
	fastf_t			model_end;
	struct xray		newray;		/* closer ray start */
	struct application	*ap;
	struct resource		*resp;
	vect_t			inv_dir;      /* inverses of ap->a_ray.r_dir */
	vect_t			abs_inv_dir;  /* absolute values of inv_dir */
	int			rstep[3];     /* -/0/+ dir of ray in axis */
	CONST union cutter	*lastcut, *lastcell;
	CONST union cutter	*curcut;
	vect_t			curmin, curmax;
	int			igrid[3];     /* integer cell coordinates */
	vect_t			tv;	      /* next t intercept values */
	int			out_axis;     /* axis ray will leave through */
	struct shootray_status	*old_status;
};


d90 1
a90 1
	struct shootray_status	ss;
d333 1
a333 1
	ss.old_status = (struct shootray_status *)NULL;
@


11.2
log
@
Added processing for new magic numbers
@
text
@d18 1
a18 1
static char RCSbundle[] = "@@(#)$Header: /c/CVS/brlcad/librt/bundle.c,v 11.1 1999/10/23 00:04:37 mike Exp $ (BRL)";
d99 1
a99 1
 *			R T _ S H O O T R A Y
d438 1
a438 1
				VJOIN( ss2_newray.r_pt, rays[ray].r_pt, ss.dist_corr, ss2_newray.r_dir );
d477 1
@


11.1
log
@
First attempt
@
text
@d18 1
a18 1
static char RCSbundle[] = "@@(#)$Header: /c/CVS/brlcad/librt/shoot.c,v 11.45 1998/09/22 02:36:04 mike Exp $ (BRL)";
d151 10
d319 5
d472 1
a472 2
						/* TODO:  based upon flags, evaluate hit_normal now */
						/* XXX add pointer to xray from struct hit for lazy evaluators? */
@

