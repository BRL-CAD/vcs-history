head	11.7;
access;
symbols
	postmerge-20051223-bobWinPort:11.6
	rel-7-6-branch:11.6.0.12
	ansi-20040405-merged:11.6.10.1
	postmerge-20040405-ansi:11.6
	autoconf-freeze:11.6.6.3
	postmerge-20040315-windows:11.6
	windows-20040315-freeze:11.6.8.1
	autoconf-20031203:11.6.6.1
	autoconf-branch:11.6.0.6
	phong-branch:11.6.0.4
	photonmap-branch:11.6.0.2
	windows-branch:11.6.0.8
	ansi-branch:11.6.0.10
	hartley-6-0-pre:11.6
	rel-5-0-beta:11.6
	rel-4-5:11.6
	ctj-4-5-post:11.6
	ctj-4-5-pre:11.6
	rel-4-4:11.1
	rel-4-0:10.1
	release-7-0:11.6;
locks; strict;
comment	@ * @;


11.7
date	2007.11.29.18.30.02;	author brlcad;	state dead;
branches;
next	11.6;

11.6
date	96.04.19.15.28.06;	author jra;	state Exp;
branches
	11.6.2.1
	11.6.4.1
	11.6.6.1
	11.6.8.1
	11.6.10.1
	11.6.12.1;
next	11.5;

11.5
date	96.04.12.14.56.26;	author jra;	state Exp;
branches;
next	11.4;

11.4
date	95.03.02.04.47.39;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	95.02.28.23.45.36;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	95.02.02.01.48.04;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.58.23;	author mike;	state Rel4_4;
branches;
next	10.36;

10.36
date	95.01.04.07.56.00;	author mike;	state Exp;
branches;
next	10.35;

10.35
date	94.11.28.13.26.47;	author jra;	state Exp;
branches;
next	10.34;

10.34
date	94.11.04.05.54.06;	author mike;	state Exp;
branches;
next	10.33;

10.33
date	94.10.11.19.36.09;	author mike;	state Exp;
branches;
next	10.32;

10.32
date	94.09.16.20.19.52;	author mike;	state Exp;
branches;
next	10.31;

10.31
date	94.08.10.19.20.21;	author gdurf;	state Exp;
branches;
next	10.30;

10.30
date	94.07.01.23.36.01;	author mike;	state Exp;
branches;
next	10.29;

10.29
date	94.04.22.05.28.14;	author mike;	state Exp;
branches;
next	10.28;

10.28
date	94.04.21.07.00.33;	author mike;	state Exp;
branches;
next	10.27;

10.27
date	94.04.20.00.43.22;	author mike;	state Exp;
branches;
next	10.26;

10.26
date	94.04.19.07.17.16;	author mike;	state Exp;
branches;
next	10.25;

10.25
date	94.04.18.06.06.01;	author mike;	state Exp;
branches;
next	10.24;

10.24
date	94.04.18.01.46.03;	author mike;	state Exp;
branches;
next	10.23;

10.23
date	94.04.17.19.45.34;	author mike;	state Exp;
branches;
next	10.22;

10.22
date	94.04.12.22.39.26;	author mike;	state Exp;
branches;
next	10.21;

10.21
date	94.03.09.22.03.45;	author mike;	state Exp;
branches;
next	10.20;

10.20
date	94.03.04.18.38.18;	author mike;	state Exp;
branches;
next	10.19;

10.19
date	94.03.04.18.26.03;	author mike;	state Exp;
branches;
next	10.18;

10.18
date	94.03.04.11.09.53;	author jra;	state Exp;
branches;
next	10.17;

10.17
date	94.03.04.04.30.01;	author mike;	state Exp;
branches;
next	10.16;

10.16
date	94.03.02.17.07.08;	author mike;	state Exp;
branches;
next	10.15;

10.15
date	94.01.27.05.23.59;	author mike;	state Exp;
branches;
next	10.14;

10.14
date	94.01.22.05.17.40;	author mike;	state Exp;
branches;
next	10.13;

10.13
date	94.01.12.02.50.10;	author mike;	state Exp;
branches;
next	10.12;

10.12
date	93.08.12.22.26.31;	author mike;	state Exp;
branches;
next	10.11;

10.11
date	93.05.20.17.10.48;	author mike;	state Exp;
branches;
next	10.10;

10.10
date	93.05.19.20.44.59;	author butler;	state Exp;
branches;
next	10.9;

10.9
date	93.03.25.18.05.02;	author mm;	state Exp;
branches;
next	10.8;

10.8
date	93.03.24.22.23.22;	author mm;	state Exp;
branches;
next	10.7;

10.7
date	93.03.17.01.18.29;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	93.03.17.00.28.34;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	93.03.16.01.18.43;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	93.02.11.21.58.11;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	93.02.06.04.25.53;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	92.02.25.00.01.46;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.40.53;	author mike;	state Rel4_0;
branches;
next	1.23;

1.23
date	91.06.19.21.22.45;	author mike;	state Exp;
branches;
next	1.22;

1.22
date	91.06.14.06.26.08;	author mike;	state Exp;
branches;
next	1.21;

1.21
date	91.05.25.01.35.40;	author mike;	state Exp;
branches;
next	1.20;

1.20
date	91.05.18.03.03.32;	author mike;	state Exp;
branches;
next	1.19;

1.19
date	91.04.01.18.36.07;	author mike;	state Exp;
branches;
next	1.18;

1.18
date	91.02.27.22.58.08;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	90.12.07.00.45.46;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	90.12.06.19.58.25;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	90.12.06.19.44.43;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	90.11.01.04.49.14;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	90.05.16.07.41.24;	author butler;	state Exp;
branches;
next	1.12;

1.12
date	90.05.13.11.29.09;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	90.05.13.11.22.40;	author butler;	state Exp;
branches;
next	1.10;

1.10
date	90.05.10.08.43.14;	author butler;	state Exp;
branches;
next	1.9;

1.9
date	90.05.10.05.15.56;	author butler;	state Exp;
branches;
next	1.8;

1.8
date	90.03.14.23.10.38;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	90.03.05.22.23.57;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	90.03.03.05.59.21;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	89.10.18.14.31.13;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	89.10.16.10.16.44;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	89.10.13.22.02.16;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	89.10.13.20.38.35;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	89.10.10.16.05.53;	author mike;	state Exp;
branches;
next	;

11.6.2.1
date	2003.08.26.14.03.35;	author justin;	state Exp;
branches;
next	;

11.6.4.1
date	2003.09.13.18.02.22;	author butler;	state Exp;
branches;
next	;

11.6.6.1
date	2003.12.03.16.24.07;	author erikg;	state Exp;
branches;
next	11.6.6.2;

11.6.6.2
date	2004.02.12.18.37.46;	author erikg;	state Exp;
branches;
next	11.6.6.3;

11.6.6.3
date	2004.03.15.14.07.29;	author erikg;	state Exp;
branches;
next	;

11.6.8.1
date	2004.03.11.23.43.44;	author morrison;	state Exp;
branches;
next	;

11.6.10.1
date	2004.03.17.21.18.57;	author morrison;	state Exp;
branches;
next	;

11.6.12.1
date	96.04.19.15.28.06;	author brlcad;	state dead;
branches;
next	11.6.12.2;

11.6.12.2
date	2005.11.13.17.44.59;	author brlcad;	state Exp;
branches;
next	;


desc
@Useful routines for dealing with planes.
@


11.7
log
@once again, try to delete these zombie files that have again mysteriously shown up after an update
@
text
@/*
 *			P L A N E . C
 *
 *  Some useful routines for dealing with planes and lines.
 *
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Distribution Status -
 *	Public Domain, Distribution Unlimited
 */
#ifndef lint
static char RCSplane[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/librt/Attic/plane.c,v 11.6 1996/04/19 15:28:06 jra Exp $ (BRL)";
#endif

#include "conf.h"

#include <stdio.h>
#include <math.h>

#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "./debug.h"

/*
 *			R T _ D I S T _ P T 3 _ P T 3
 *
 *  Returns distance between two points.
 */
double
rt_dist_pt3_pt3( a, b )
CONST point_t	a;
CONST point_t	b;
{
	vect_t	diff;

	VSUB2( diff, a, b );
	return MAGNITUDE( diff );
}

/*
 *			R T _ P T 3 _ P T 3 _ E Q U A L
 *
 *  Returns -
 *	1	if the two points are equal, within the tolerance
 *	0	if the two points are not "the same"
 */
int
rt_pt3_pt3_equal( a, b, tol )
CONST point_t		a;
CONST point_t		b;
CONST struct rt_tol	*tol;
{
	vect_t	diff;

	RT_CK_TOL(tol);
	VSUB2( diff, b, a );
	if( MAGSQ( diff ) < tol->dist_sq )  return 1;
	return 0;
}

/*
 *			R T _ P T 2 _ P T 2 _ E Q U A L
 *
 *  Returns -
 *	1	if the two points are equal, within the tolerance
 *	0	if the two points are not "the same"
 */
int
rt_pt2_pt2_equal( a, b, tol )
CONST point_t		a;
CONST point_t		b;
CONST struct rt_tol	*tol;
{
	vect_t	diff;

	RT_CK_TOL(tol);
	VSUB2_2D( diff, b, a );
	if( MAGSQ_2D( diff ) < tol->dist_sq )  return 1;
	return 0;
}

/*
 *			R T _ 3 P T S _ C O L L I N E A R
 *
 *  Check to see if three points are collinear.
 *
 *  The algorithm is designed to work properly regardless of the
 *  order in which the points are provided.
 *
 *  Returns (boolean) -
 *	1	If 3 points are collinear
 *	0	If they are not
 */
int
rt_3pts_collinear(a, b, c, tol)
point_t	a, b, c;
struct rt_tol	*tol;
{
	fastf_t	mag_ab, mag_bc, mag_ca, max_len, dist_sq;
	fastf_t cos_a, cos_b, cos_c;
	vect_t	ab, bc, ca;
	int max_edge_no;

	VSUB2(ab, b, a);
	VSUB2(bc, c, b);
	VSUB2(ca, a, c);
	mag_ab = MAGNITUDE(ab);
	mag_bc = MAGNITUDE(bc);
	mag_ca = MAGNITUDE(ca);

	/* find longest edge */
	max_len = mag_ab;
	max_edge_no = 1;

	if( mag_bc > max_len )
	{
		max_len = mag_bc;
		max_edge_no = 2;
	}

	if( mag_ca > max_len )
	{
		max_len = mag_ca;
		max_edge_no = 3;
	}

	switch( max_edge_no )
	{
		default:
		case 1:
			cos_b = (-VDOT( ab , bc ))/(mag_ab * mag_bc );
			dist_sq = mag_bc*mag_bc*( 1.0 - cos_b*cos_b);
			break;
		case 2:
			cos_c = (-VDOT( bc , ca ))/(mag_bc * mag_ca );
			dist_sq = mag_ca*mag_ca*(1.0 - cos_c*cos_c);
			break;
		case 3:
			cos_a = (-VDOT( ca , ab ))/(mag_ca * mag_ab );
			dist_sq = mag_ab*mag_ab*(1.0 - cos_a*cos_a);
			break;
	}

	if( dist_sq <= tol->dist_sq )
		return( 1 );
	else
		return( 0 );
}


/*
 *			R T _ 3 P T S _ D I S T I N C T
 *
 *  Check to see if three points are all distinct, i.e.,
 *  ensure that there is at least sqrt(dist_tol_sq) distance
 *  between every pair of points.
 *
 *  Returns (boolean) -
 *	1	If all three points are distinct
 *	0	If two or more points are closer together than dist_tol_sq
 */
int
rt_3pts_distinct( a, b, c, tol )
CONST point_t		a, b, c;
CONST struct rt_tol	*tol;
{
	vect_t	B_A;
	vect_t	C_A;
	vect_t	C_B;

	RT_CK_TOL(tol);
	VSUB2( B_A, b, a );
	if( MAGSQ( B_A ) <= tol->dist_sq )  return(0);
	VSUB2( C_A, c, a );
	if( MAGSQ( C_A ) <= tol->dist_sq )  return(0);
	VSUB2( C_B, c, b );
	if( MAGSQ( C_B ) <= tol->dist_sq )  return(0);
	return(1);
}

/*
 *			R T _ M K _ P L A N E _ 3 P T S
 *
 *  Find the equation of a plane that contains three points.
 *  Note that normal vector created is expected to point out (see vmath.h),
 *  so the vector from A to C had better be counter-clockwise
 *  (about the point A) from the vector from A to B.
 *  This follows the BRL-CAD outward-pointing normal convention, and the
 *  right-hand rule for cross products.
 *
 *
 *			C
 *	                *
 *	                |\
 *	                | \
 *	   ^     N      |  \
 *	   |      \     |   \
 *	   |       \    |    \
 *	   |C-A     \   |     \
 *	   |         \  |      \
 *	   |          \ |       \
 *	               \|        \
 *	                *---------*
 *	                A         B
 *			   ----->
 *		            B-A
 *
 *  If the points are given in the order A B C (eg, *counter*-clockwise),
 *  then the outward pointing surface normal N = (B-A) x (C-A).
 *
 *  Explicit Return -
 *	 0	OK
 *	-1	Failure.  At least two of the points were not distinct,
 *		or all three were colinear.
 *
 *  Implicit Return -
 *	plane	The plane equation is stored here.
 */
int
rt_mk_plane_3pts( plane, a, b, c, tol )
plane_t			plane;
CONST point_t		a, b, c;
CONST struct rt_tol	*tol;
{
	vect_t	B_A;
	vect_t	C_A;
	vect_t	C_B;
	register fastf_t mag;

	RT_CK_TOL(tol);

	VSUB2( B_A, b, a );
	if( MAGSQ( B_A ) <= tol->dist_sq )  return(-1);
	VSUB2( C_A, c, a );
	if( MAGSQ( C_A ) <= tol->dist_sq )  return(-1);
	VSUB2( C_B, c, b );
	if( MAGSQ( C_B ) <= tol->dist_sq )  return(-1);

	VCROSS( plane, B_A, C_A );

	/* Ensure unit length normal */
	if( (mag = MAGNITUDE(plane)) <= SMALL_FASTF )
		return(-1);	/* FAIL */
	mag = 1/mag;
	VSCALE( plane, plane, mag );

	/* Find distance from the origin to the plane */
	/* XXX Should do with pt that has smallest magnitude (closest to origin) */
	plane[3] = VDOT( plane, a );

#if 0
	/* Check to be sure that angle between A-Origin and N vect < 89 degrees */
	/* XXX Could complain for pts on axis-aligned plane, far from origin */
	mag = MAGSQ(a);
	if( mag > tol->dist_sq )  {
		/* cos(89 degrees) = 0.017452406, reciprocal is 57.29 */
		if( plane[3]/sqrt(mag) < 0.017452406 )  {
			rt_log("rt_mk_plane_3pts() WARNING: plane[3] value is suspect\n");
		}
	}
#endif
	return(0);		/* OK */
}

/*
 *			R T _ M K P O I N T _ 3 P L A N E S
 *
 *  Given the description of three planes, compute the point of intersection,
 *  if any.
 *
 *  Find the solution to a system of three equations in three unknowns:
 *
 *	Px * Ax + Py * Ay + Pz * Az = -A3;
 *	Px * Bx + Py * By + Pz * Bz = -B3;
 *	Px * Cx + Py * Cy + Pz * Cz = -C3;
 *
 *  or
 *
 *	[ Ax  Ay  Az ]   [ Px ]   [ -A3 ]
 *	[ Bx  By  Bz ] * [ Py ] = [ -B3 ]
 *	[ Cx  Cy  Cz ]   [ Pz ]   [ -C3 ]
 *
 *
 *  Explitic Return -
 *	 0	OK
 *	-1	Failure.  Intersection is a line or plane.
 *
 *  Implicit Return -
 *	pt	The point of intersection is stored here.
 */
int
rt_mkpoint_3planes( pt, a, b, c )
point_t		pt;
CONST plane_t	a, b, c;
{
	vect_t	v1, v2, v3;
	register fastf_t det;

	/* Find a vector perpendicular to both planes B and C */
	VCROSS( v1, b, c );

	/*  If that vector is perpendicular to A,
	 *  then A is parallel to either B or C, and no intersection exists.
	 *  This dot&cross product is the determinant of the matrix M.
	 *  (I suspect there is some deep significance to this!)
	 */
	det = VDOT( a, v1 );
	if( NEAR_ZERO( det, SMALL_FASTF ) )  return(-1);

	VCROSS( v2, a, c );
	VCROSS( v3, a, b );

	det = 1/det;
	pt[X] = det*(a[3]*v1[X] - b[3]*v2[X] + c[3]*v3[X]);
	pt[Y] = det*(a[3]*v1[Y] - b[3]*v2[Y] + c[3]*v3[Y]);
	pt[Z] = det*(a[3]*v1[Z] - b[3]*v2[Z] + c[3]*v3[Z]);
	return(0);
}

/*
 *			R T _ 2 L I N E 3 _ C O L I N E A R
 *
 *  Returns non-zero if the 3 lines are colinear to within tol->dist
 *  over the given distance range.
 *
 *  Range should be at least one model diameter for most applications.
 *  1e5 might be OK for a default for "vehicle sized" models.
 *
 *  The direction vectors do not need to be unit length.
 */
int
rt_2line3_colinear( p1, d1, p2, d2, range, tol )
CONST point_t		p1;
CONST vect_t		d1;
CONST point_t		p2;
CONST vect_t		d2;
double			range;
CONST struct rt_tol	*tol;
{
	fastf_t		mag1;
	fastf_t		mag2;
	point_t		tail;

	RT_CK_TOL(tol);

	if( (mag1 = MAGNITUDE(d1)) < SMALL_FASTF )  rt_bomb("rt_2line3_colinear() mag1 zero\n");
	if( (mag2 = MAGNITUDE(d2)) < SMALL_FASTF )  rt_bomb("rt_2line3_colinear() mag2 zero\n");

	/* Impose a general angular tolerance to reject "obviously" non-parallel lines */
	/* tol->para and RT_DOT_TOL are too tight a tolerance.  0.1 is 5 degrees */
	if( fabs(VDOT(d1, d2)) < 0.9 * mag1 * mag2  )  goto fail;

	/* See if start points are within tolerance of other line */
	if( rt_distsq_line3_pt3( p1, d1, p2 ) > tol->dist_sq )  goto fail;
	if( rt_distsq_line3_pt3( p2, d2, p1 ) > tol->dist_sq )  goto fail;

	VJOIN1( tail, p1, range/mag1, d1 );
	if( rt_distsq_line3_pt3( p2, d2, tail ) > tol->dist_sq )  goto fail;

	VJOIN1( tail, p2, range/mag2, d2 );
	if( rt_distsq_line3_pt3( p1, d1, tail ) > tol->dist_sq )  goto fail;

	if( rt_g.debug & DEBUG_MATH )  {
		rt_log("rt_2line3colinear(range=%g) ret=1\n",range);
	}
	return 1;
fail:
	if( rt_g.debug & DEBUG_MATH )  {
		rt_log("rt_2line3colinear(range=%g) ret=0\n",range);
	}
	return 0;
}

/*
 *			R T _ I S E C T _ L I N E 3 _ P L A N E
 *
 *  Intersect an infinite line (specified in point and direction vector form)
 *  with a plane that has an outward pointing normal.
 *  The direction vector need not have unit length.
 *
 *  Explicit Return -
 *	-2	missed (ray is outside halfspace)
 *	-1	missed (ray is inside)
 *	 0	line lies on plane
 *	 1	hit (ray is entering halfspace)
 *	 2	hit (ray is leaving)
 *
 *  Implicit Return -
 *	The value at *dist is set to the parametric distance of the intercept
 */
int
rt_isect_line3_plane( dist, pt, dir, plane, tol )
fastf_t		*dist;
CONST point_t	pt;
CONST vect_t	dir;
CONST plane_t	plane;
CONST struct rt_tol	*tol;
{
	register fastf_t	slant_factor;
	register fastf_t	norm_dist;

	RT_CK_TOL(tol);

	norm_dist = plane[3] - VDOT( plane, pt );
	slant_factor = VDOT( plane, dir );

	if( slant_factor < -SMALL_FASTF )  {
		*dist = norm_dist/slant_factor;
		return 1;			/* HIT, entering */
	} else if( slant_factor > SMALL_FASTF )  {
		*dist = norm_dist/slant_factor;
		return 2;			/* HIT, leaving */
	}

	/*
	 *  Ray is parallel to plane when dir.N == 0.
	 */
	*dist = 0;		/* sanity */
	if( norm_dist < -tol->dist )
		return -2;	/* missed, outside */
	if( norm_dist > tol->dist )
		return -1;	/* missed, inside */
	return 0;		/* Ray lies in the plane */
}

/*
 *			R T _ I S E C T _ 2 P L A N E S
 *
 *  Given two planes, find the line of intersection between them,
 *  if one exists.
 *  The line of intersection is returned in parametric line
 *  (point & direction vector) form.
 *
 *  In order that all the geometry under consideration be in "front"
 *  of the ray, it is necessary to pass the minimum point of the model
 *  RPP.  If this convention is unnecessary, just pass (0,0,0) as rpp_min.
 *
 *  Explicit Return -
 *	 0	OK, line of intersection stored in `pt' and `dir'.
 *	-1	FAIL, planes are identical (co-planar)
 *	-2	FAIL, planes are parallel and distinct
 *	-3	FAIL, unable to find line of intersection
 *
 *  Implicit Returns -
 *	pt	Starting point of line of intersection
 *	dir	Direction vector of line of intersection (unit length)
 */
int
rt_isect_2planes( pt, dir, a, b, rpp_min, tol )
point_t		pt;
vect_t		dir;
CONST plane_t	a;
CONST plane_t	b;
CONST vect_t	rpp_min;
CONST struct rt_tol	*tol;
{
	LOCAL vect_t		abs_dir;
	LOCAL plane_t		pl;
	int			i;

	if( (i = rt_coplanar( a, b, tol )) != 0 )  {
		if( i > 0 )
			return(-1);	/* FAIL -- coplanar */
		return(-2);		/* FAIL -- parallel & distinct */
	}

	/* Direction vector for ray is perpendicular to both plane normals */
	VCROSS( dir, a, b );
	VUNITIZE( dir );		/* safety */

	/*
	 *  Select an axis-aligned plane which has it's normal pointing
	 *  along the same axis as the largest magnitude component of
	 *  the direction vector.
	 *  If the largest magnitude component is negative, reverse the
	 *  direction vector, so that model is "in front" of start point.
	 */
	abs_dir[X] = (dir[X] >= 0) ? dir[X] : (-dir[X]);
	abs_dir[Y] = (dir[Y] >= 0) ? dir[Y] : (-dir[Y]);
	abs_dir[Z] = (dir[Z] >= 0) ? dir[Z] : (-dir[Z]);

	if( abs_dir[X] >= abs_dir[Y] )  {
		if( abs_dir[X] >= abs_dir[Z] )  {
			VSET( pl, 1, 0, 0 );	/* X */
			pl[3] = rpp_min[X];
			if( dir[X] < 0 )  {
				VREVERSE( dir, dir );
			}
		} else {
			VSET( pl, 0, 0, 1 );	/* Z */
			pl[3] = rpp_min[Z];
			if( dir[Z] < 0 )  {
				VREVERSE( dir, dir );
			}
		}
	} else {
		if( abs_dir[Y] >= abs_dir[Z] )  {
			VSET( pl, 0, 1, 0 );	/* Y */
			pl[3] = rpp_min[Y];
			if( dir[Y] < 0 )  {
				VREVERSE( dir, dir );
			}
		} else {
			VSET( pl, 0, 0, 1 );	/* Z */
			pl[3] = rpp_min[Z];
			if( dir[Z] < 0 )  {
				VREVERSE( dir, dir );
			}
		}
	}

	/* Intersection of the 3 planes defines ray start point */
	if( rt_mkpoint_3planes( pt, pl, a, b ) < 0 )
		return(-3);	/* FAIL -- no intersection */

	return(0);		/* OK */
}

/*
 *			R T _ I S E C T _ L I N E 2 _ L I N E 2
 *
 *  Intersect two lines, each in given in parametric form:
 *
 *	X = P + t * D
 *  and
 *	X = A + u * C
 *
 *  While the parametric form is usually used to denote a ray
 *  (ie, positive values of the parameter only), in this case
 *  the full line is considered.
 *
 *  The direction vectors C and D need not have unit length.
 *
 *  Explicit Return -
 *	-1	no intersection, lines are parallel.
 *	 0	lines are co-linear
 *			dist[0] gives distance from P to A,
 *			dist[1] gives distance from P to (A+C) [not same as below]
 *	 1	intersection found (t and u returned)
 *			dist[0] gives distance from P to isect,
 *			dist[1] gives distance from A to isect.
 *
 *  Implicit Returns -
 *	When explicit return > 0, dist[0] and dist[1] are the
 *	line parameters of the intersection point on the 2 rays.
 *	The actual intersection coordinates can be found by
 *	substituting either of these into the original ray equations.
 *
 *  Note that for lines which are very nearly parallel, but not
 *  quite parallel enough to have the determinant go to "zero",
 *  the intersection can turn up in surprising places.
 *  (e.g. when det=1e-15 and det1=5.5e-17, t=0.5)
 */
int
rt_isect_line2_line2( dist, p, d, a, c, tol )
fastf_t			*dist;			/* dist[2] */
CONST point_t		p;
CONST vect_t		d;
CONST point_t		a;
CONST vect_t		c;
CONST struct rt_tol	*tol;
{
	fastf_t			hx, hy;		/* A - P */
	register fastf_t	det;
	register fastf_t	det1;
	vect_t			unit_d;
	vect_t			unit_c;
	vect_t			unit_h;
	fastf_t			dot;
	int			parallel;
	int			parallel1;

	RT_CK_TOL(tol);
	if( rt_g.debug & DEBUG_MATH )  {
		rt_log("rt_isect_line2_line2() p=(%g,%g), d=(%g,%g)\n\t\t\ta=(%g,%g), c=(%g,%g)\n",
			V2ARGS(p), V2ARGS(d), V2ARGS(a), V2ARGS(c) );
	}

	/*
	 *  From the two components q and r, form a system
	 *  of 2 equations in 2 unknowns.
	 *  Solve for t and u in the system:
	 *
	 *	Px + t * Dx = Ax + u * Cx
	 *	Py + t * Dy = Ay + u * Cy
	 *  or
	 *	t * Dx - u * Cx = Ax - Px
	 *	t * Dy - u * Cy = Ay - Py
	 *
	 *  Let H = A - P, resulting in:
	 *
	 *	t * Dx - u * Cx = Hx
	 *	t * Dy - u * Cy = Hy
	 *
	 *  or
	 *
	 *	[ Dx  -Cx ]   [ t ]   [ Hx ]
	 *	[         ] * [   ] = [    ]
	 *	[ Dy  -Cy ]   [ u ]   [ Hy ]
	 *
	 *  This system can be solved by direct substitution, or by
	 *  finding the determinants by Cramers rule:
	 *
	 *	             [ Dx  -Cx ]
	 *	det(M) = det [         ] = -Dx * Cy + Cx * Dy
	 *	             [ Dy  -Cy ]
	 *
	 *  If det(M) is zero, then the lines are parallel (perhaps colinear).
	 *  Otherwise, exactly one solution exists.
	 */
	det = c[X] * d[Y] - d[X] * c[Y];

	/*
	 *  det(M) is non-zero, so there is exactly one solution.
	 *  Using Cramer's rule, det1(M) replaces the first column
	 *  of M with the constant column vector, in this case H.
	 *  Similarly, det2(M) replaces the second column.
	 *  Computation of the determinant is done as before.
	 *
	 *  Now,
	 *
	 *	                  [ Hx  -Cx ]
	 *	              det [         ]
	 *	    det1(M)       [ Hy  -Cy ]   -Hx * Cy + Cx * Hy
	 *	t = ------- = --------------- = ------------------
	 *	     det(M)       det(M)        -Dx * Cy + Cx * Dy
	 *
	 *  and
	 *
	 *	                  [ Dx   Hx ]
	 *	              det [         ]
	 *	    det2(M)       [ Dy   Hy ]    Dx * Hy - Hx * Dy
	 *	u = ------- = --------------- = ------------------
	 *	     det(M)       det(M)        -Dx * Cy + Cx * Dy
	 */
	hx = a[X] - p[X];
	hy = a[Y] - p[Y];
	det1 = (c[X] * hy - hx * c[Y]);

	unit_d[0] = d[0];
	unit_d[1] = d[1];
	unit_d[2] = 0.0;
	VUNITIZE( unit_d );
	unit_c[0] = c[0];
	unit_c[1] = c[1];
	unit_c[2] = 0.0;
	VUNITIZE( unit_c );
	unit_h[0] = hx;
	unit_h[1] = hy;
	unit_h[2] = 0.0;
	VUNITIZE( unit_h );

	if( fabs( VDOT( unit_d, unit_c ) ) >= tol->para )
		parallel = 1;
	else
		parallel = 0;

	if( fabs( VDOT( unit_h, unit_c ) ) >= tol->para )
		parallel1 = 1;
	else
		parallel1 = 0;

	/* XXX This zero tolerance here should actually be
	 * XXX determined by something like
	 * XXX max(c[X], c[Y], d[X], d[Y]) / MAX_FASTF_DYNAMIC_RANGE
	 * XXX In any case, nothing smaller than 1e-16
	 */
#define DETERMINANT_TOL		1.0e-14		/* XXX caution on non-IEEE machines */
	if( parallel || NEAR_ZERO( det, DETERMINANT_TOL ) )  {
		/* Lines are parallel */
		if( !parallel1 && !NEAR_ZERO( det1, DETERMINANT_TOL ) )  {
			/* Lines are NOT co-linear, just parallel */
			if( rt_g.debug & DEBUG_MATH )  {
				rt_log("\tparallel, not co-linear.  det=%e, det1=%g\n", det, det1);
			}
			return -1;	/* parallel, no intersection */
		}

		/*
		 *  Lines are co-linear.
		 *  Determine t as distance from P to A.
		 *  Determine u as distance from P to (A+C).  [special!]
		 *  Use largest direction component, for numeric stability
		 *  (and avoiding division by zero).
		 */
		if( fabs(d[X]) >= fabs(d[Y]) )  {
			dist[0] = hx/d[X];
			dist[1] = (hx + c[X]) / d[X];
		} else {
			dist[0] = hy/d[Y];
			dist[1] = (hy + c[Y]) / d[Y];
		}
		if( rt_g.debug & DEBUG_MATH )  {
			rt_log("\tcolinear, t = %g, u = %g\n", dist[0], dist[1] );
		}
		return 0;	/* Lines co-linear */
	}
	if( rt_g.debug & DEBUG_MATH )  {
		/* XXX This print is temporary */
rt_log("\thx=%g, hy=%g, det=%g, det1=%g, det2=%g\n", hx, hy, det, det1, (d[X] * hy - hx * d[Y]) );
	}
	det = 1/det;
	dist[0] = det * det1;
	dist[1] = det * (d[X] * hy - hx * d[Y]);
	if( rt_g.debug & DEBUG_MATH )  {
		rt_log("\tintersection, t = %g, u = %g\n", dist[0], dist[1] );
	}

#if 0
	/* XXX This isn't any good.
	 * 1)  Sometimes, dist[0] is very large.  Only caller can tell whether
	 *     that is useful to him or not.
	 * 2)  Sometimes, the difference between the two hit points is
	 *     not much more than tol->dist.  Either hit point is perfectly
	 *     good;  the caller just needs to be careful and not use *both*.
	 */
	{
		point_t		hit1, hit2;
		vect_t		diff;
		fastf_t		dist_sq;

		VJOIN1_2D( hit1, p, dist[0], d );
		VJOIN1_2D( hit2, a, dist[1], c );
		VSUB2_2D( diff, hit1, hit2 );
		dist_sq = MAGSQ_2D( diff );
		if( dist_sq >= tol->dist_sq )  {
			if( rt_g.debug & DEBUG_MATH || dist_sq < 100*tol->dist_sq )  {
				rt_log("rt_isect_line2_line2(): dist=%g >%g, inconsistent solution, hit1=(%g,%g), hit2=(%g,%g)\n",
					sqrt(dist_sq), tol->dist,
					hit1[X], hit1[Y], hit2[X], hit2[Y]);
			}
			return -2;	/* s/b -1? */
		}
	}
#endif

	return 1;		/* Intersection found */
}

/*
 *			R T _ I S E C T _ L I N E 2 _ L S E G 2
 *
 *  Intersect a line in parametric form:
 *
 *	X = P + t * D
 *
 *  with a line segment defined by two distinct points A and B=(A+C).
 *
 *  XXX probably should take point B, not vector C.  Sigh.
 *
 *  Explicit Return -
 *	-4	A and B are not distinct points
 *	-3	Lines do not intersect
 *	-2	Intersection exists, but outside segemnt, < A
 *	-1	Intersection exists, but outside segment, > B
 *	 0	Lines are co-linear (special meaning of dist[1])
 *	 1	Intersection at vertex A
 *	 2	Intersection at vertex B (A+C)
 *	 3	Intersection between A and B
 *
 *  Implicit Returns -
 *	t	When explicit return >= 0, t is the parameter that describes
 *		the intersection of the line and the line segment.
 *		The actual intersection coordinates can be found by
 *		solving P + t * D.  However, note that for return codes
 *		1 and 2 (intersection exactly at a vertex), it is
 *		strongly recommended that the original values passed in
 *		A or B are used instead of solving P + t * D, to prevent
 *		numeric error from creeping into the position of
 *		the endpoints.
 */
int
rt_isect_line2_lseg2( dist, p, d, a, c, tol )
fastf_t			*dist;		/* dist[2] */
CONST point_t		p;
CONST vect_t		d;
CONST point_t		a;
CONST vect_t		c;
CONST struct rt_tol	*tol;
{
	register fastf_t f;
	fastf_t		ctol;
	int		ret;
	point_t		b;

	RT_CK_TOL(tol);
	if( rt_g.debug & DEBUG_MATH )  {
		rt_log("rt_isect_line2_lseg2() p=(%g,%g), pdir=(%g,%g)\n\t\t\ta=(%g,%g), adir=(%g,%g)\n",
			V2ARGS(p), V2ARGS(d), V2ARGS(a), V2ARGS(c) );
	}

	/*
	 *  To keep the values of u between 0 and 1,
	 *  C should NOT be scaled to have unit length.
	 *  However, it is a good idea to make sure that
	 *  C is a non-zero vector, (ie, that A and B are distinct).
	 */
	if( (ctol = MAGSQ_2D(c)) <= tol->dist_sq )  {
		ret = -4;		/* points A and B are not distinct */
		goto out;
	}

	/*
	 *  Detecting colinearity is difficult, and very very important.
	 *  As a first step, check to see if both points A and B lie
	 *  within tolerance of the line.  If so, then the line segment AC
	 *  is ON the line.
	 */
	VADD2_2D( b, a, c );
	if( rt_distsq_line2_point2( p, d, a ) <= tol->dist_sq  &&
	    (ctol=rt_distsq_line2_point2( p, d, b )) <= tol->dist_sq )  {
		if( rt_g.debug & DEBUG_MATH )  {
rt_log("b=(%g, %g), b_dist_sq=%g\n", V2ARGS(b), ctol);
			rt_log("rt_isect_line2_lseg2() pts A and B within tol of line\n");
		}
	    	/* Find the parametric distance along the ray */
	    	dist[0] = rt_dist_pt2_along_line2( p, d, a );
	    	dist[1] = rt_dist_pt2_along_line2( p, d, b );
	    	ret = 0;		/* Colinear */
	    	goto out;
	}

	if( (ret = rt_isect_line2_line2( dist, p, d, a, c, tol )) < 0 )  {
		/* Lines are parallel, non-colinear */
		ret = -3;		/* No intersection found */
		goto out;
	}
	if( ret == 0 )  {
		fastf_t	dtol;
		/*  Lines are colinear */
		/*  If P within tol of either endpoint (0, 1), make exact. */
		dtol = tol->dist / sqrt(MAGSQ_2D(d));
		if( rt_g.debug & DEBUG_MATH )  {
			rt_log("rt_isect_line2_lseg2() dtol=%g, dist[0]=%g, dist[1]=%g\n",
				dtol, dist[0], dist[1]);
		}
		if( dist[0] > -dtol && dist[0] < dtol )  dist[0] = 0;
		else if( dist[0] > 1-dtol && dist[0] < 1+dtol ) dist[0] = 1;

		if( dist[1] > -dtol && dist[1] < dtol )  dist[1] = 0;
		else if( dist[1] > 1-dtol && dist[1] < 1+dtol ) dist[1] = 1;
		ret = 0;		/* Colinear */
		goto out;
	}

	/*
	 *  The two lines are claimed to intersect at a point.
	 *  First, validate that hit point represented by dist[0]
	 *  is in fact on and between A--B.
	 *  (Nearly parallel lines can result in odd situations here).
	 *  The performance hit of doing this is vastly preferable
	 *  to returning wrong answers.  Know a faster algorithm?
	 */
	{
		fastf_t		ab_dist = 0;
		point_t		hit_pt;
		point_t		hit2;

		VJOIN1_2D( hit_pt, p, dist[0], d );
		VJOIN1_2D( hit2, a, dist[1], c );
		/* Check both hit point value calculations */
		if( rt_pt2_pt2_equal( a, hit_pt, tol ) ||
		    rt_pt2_pt2_equal( a, hit2, tol ) )  {
			dist[1] = 0;
			ret = 1;	/* Intersect is at A */
		}
		if( rt_pt2_pt2_equal( b, hit_pt, tol ) ||
		    rt_pt2_pt2_equal( b, hit_pt, tol ) )  {
			dist[1] = 1;
			ret = 2;	/* Intersect is at B */
		}

		ret = rt_isect_pt2_lseg2( &ab_dist, a, b, hit_pt, tol );
		if( rt_g.debug & DEBUG_MATH )  {
			/* XXX This is temporary */
			V2PRINT("a", a);
			V2PRINT("hit", hit_pt);
			V2PRINT("b", b);
rt_log("rt_isect_pt2_lseg2() hit2d=(%g,%g) ab_dist=%g, ret=%d\n", hit_pt[X], hit_pt[Y], ab_dist, ret);
rt_log("\tother hit2d=(%g,%g)\n", hit2[X], hit2[Y] );
		}
		if( ret <= 0 )  {
			if( ab_dist < 0 )  {
				ret = -2;	/* Intersection < A */
			} else {
				ret = -1;	/* Intersection >B */
			}
			goto out;
		}
		if( ret == 1 )  {
			dist[1] = 0;
			ret = 1;	/* Intersect is at A */
			goto out;
		}
		if( ret == 2 )  {
			dist[1] = 1;
			ret = 2;	/* Intersect is at B */
			goto out;
		}
		/* ret == 3, hit_pt is between A and B */

		if( !rt_between( a[X], hit_pt[X], b[X], tol ) ||
		    !rt_between( a[Y], hit_pt[Y], b[Y], tol ) ) {
		    	rt_bomb("rt_isect_line2_lseg2() hit_pt not between A and B!\n");
		}
	}

	/*
	 *  If the dist[1] parameter is outside the range (0..1),
	 *  reject the intersection, because it falls outside
	 *  the line segment A--B.
	 *
	 *  Convert the tol->dist into allowable deviation in terms of
	 *  (0..1) range of the parameters.
	 */
	ctol = tol->dist / sqrt(ctol);
	if( rt_g.debug & DEBUG_MATH )  {
		rt_log("rt_isect_line2_lseg2() ctol=%g, dist[1]=%g\n", ctol, dist[1]);
	}
	if( dist[1] < -ctol )  {
		ret = -2;		/* Intersection < A */
		goto out;
	}
	if( (f=(dist[1]-1)) > ctol )  {
		ret = -1;		/* Intersection > B */
		goto out;
	}

	/* Check for ctoly intersection with one of the verticies */
	if( dist[1] < ctol )  {
		dist[1] = 0;
		ret = 1;		/* Intersection at A */
		goto out;
	}
	if( f >= -ctol )  {
		dist[1] = 1;
		ret = 2;		/* Intersection at B */
		goto out;
	}
	ret = 3;			/* Intersection between A and B */
out:
	if( rt_g.debug & DEBUG_MATH )  {
		rt_log("rt_isect_line2_lseg2() dist[0]=%g, dist[1]=%g, ret=%d\n",
			dist[0], dist[1], ret);
	}
	return ret;
}

/*
 *			R T _ I S E C T _ L S E G 2  _ L S E G 2
 *
 *  Intersect two 2D line segments, defined by two points and two vectors.
 *  The vectors are unlikely to be unit length.
 *
 *  Explicit Return -
 *	-2	missed (line segments are parallel)
 *	-1	missed (colinear and non-overlapping)
 *	 0	hit (line segments colinear and overlapping)
 *	 1	hit (normal intersection)
 *
 *  Implicit Return -
 *	The value at dist[] is set to the parametric distance of the intercept
 *	dist[0] is parameter along p, range 0 to 1, to intercept.
 *	dist[1] is parameter along q, range 0 to 1, to intercept.
 *	If within distance tolerance of the endpoints, these will be
 *	exactly 0.0 or 1.0, to ease the job of caller.
 *
 *  Special note:  when return code is "0" for co-linearity, dist[1] has
 *  an alternate interpretation:  it's the parameter along p (not q)
 *  which takes you from point p to the point (q + qdir), i.e., it's
 *  the endpoint of the q linesegment, since in this case there may be
 *  *two* intersections, if q is contained within span p to (p + pdir).
 *  And either may be -10 if the point is outside the span.
 */
int
rt_isect_lseg2_lseg2( dist, p, pdir, q, qdir, tol )
fastf_t		*dist;
CONST point_t	p;
CONST vect_t	pdir;
CONST point_t	q;
CONST vect_t	qdir;
struct rt_tol	*tol;
{
	fastf_t	ptol, qtol;	/* length in parameter space == tol->dist */
	int	status;

	RT_CK_TOL(tol);
	if( rt_g.debug & DEBUG_MATH )  {
		rt_log("rt_isect_lseg2_lseg2() p=(%g,%g), pdir=(%g,%g)\n\t\tq=(%g,%g), qdir=(%g,%g)\n",
			V2ARGS(p), V2ARGS(pdir), V2ARGS(q), V2ARGS(qdir) );
	}

	status = rt_isect_line2_line2( dist, p, pdir, q, qdir, tol );
	if( status < 0 )  {
		/* Lines are parallel, non-colinear */
		return -1;	/* No intersection */
	}
	if( status == 0 )  {
		int	nogood = 0;
		/* Lines are colinear */
		/*  If P within tol of either endpoint (0, 1), make exact. */
		ptol = tol->dist / sqrt( MAGSQ_2D(pdir) );
		if( rt_g.debug & DEBUG_MATH )  {
			rt_log("ptol=%g\n", ptol);
		}
		if( dist[0] > -ptol && dist[0] < ptol )  dist[0] = 0;
		else if( dist[0] > 1-ptol && dist[0] < 1+ptol ) dist[0] = 1;

		if( dist[1] > -ptol && dist[1] < ptol )  dist[1] = 0;
		else if( dist[1] > 1-ptol && dist[1] < 1+ptol ) dist[1] = 1;

		if( dist[1] < 0 || dist[1] > 1 )  nogood = 1;
		if( dist[0] < 0 || dist[0] > 1 )  nogood++;
		if( nogood >= 2 )
			return -1;	/* colinear, but not overlapping */
		if( rt_g.debug & DEBUG_MATH )  {
			rt_log("  HIT colinear!\n");
		}
		return 0;		/* colinear and overlapping */
	}
	/* Lines intersect */
	/*  If within tolerance of an endpoint (0, 1), make exact. */
	ptol = tol->dist / sqrt( MAGSQ_2D(pdir) );
	if( dist[0] > -ptol && dist[0] < ptol )  dist[0] = 0;
	else if( dist[0] > 1-ptol && dist[0] < 1+ptol ) dist[0] = 1;

	qtol = tol->dist / sqrt( MAGSQ_2D(qdir) );
	if( dist[1] > -qtol && dist[1] < qtol )  dist[1] = 0;
	else if( dist[1] > 1-qtol && dist[1] < 1+qtol ) dist[1] = 1;

	if( rt_g.debug & DEBUG_MATH )  {
		rt_log("ptol=%g, qtol=%g\n", ptol, qtol);
	}
	if( dist[0] < 0 || dist[0] > 1 || dist[1] < 0 || dist[1] > 1 ) {
		if( rt_g.debug & DEBUG_MATH )  {
			rt_log("  MISS\n");
		}
		return -1;		/* missed */
	}
	if( rt_g.debug & DEBUG_MATH )  {
		rt_log("  HIT!\n");
	}
	return 1;			/* hit, normal intersection */
}

/*
 *			R T _ I S E C T _ L S E G 3  _ L S E G 3
 *
 *  Intersect two 3D line segments, defined by two points and two vectors.
 *  The vectors are unlikely to be unit length.
 *
 *  Explicit Return -
 *	-2	missed (line segments are parallel)
 *	-1	missed (colinear and non-overlapping)
 *	 0	hit (line segments colinear and overlapping)
 *	 1	hit (normal intersection)
 *
 *  Implicit Return -
 *	The value at dist[] is set to the parametric distance of the intercept
 *	dist[0] is parameter along p, range 0 to 1, to intercept.
 *	dist[1] is parameter along q, range 0 to 1, to intercept.
 *	If within distance tolerance of the endpoints, these will be
 *	exactly 0.0 or 1.0, to ease the job of caller.
 *
 *  Special note:  when return code is "0" for co-linearity, dist[1] has
 *  an alternate interpretation:  it's the parameter along p (not q)
 *  which takes you from point p to the point (q + qdir), i.e., it's
 *  the endpoint of the q linesegment, since in this case there may be
 *  *two* intersections, if q is contained within span p to (p + pdir).
 *  And either may be -10 if the point is outside the span.
 */
int
rt_isect_lseg3_lseg3( dist, p, pdir, q, qdir, tol )
fastf_t		*dist;
CONST point_t	p;
CONST vect_t	pdir;
CONST point_t	q;
CONST vect_t	qdir;
struct rt_tol	*tol;
{
	fastf_t	ptol, qtol;	/* length in parameter space == tol->dist */
	fastf_t	pmag, qmag;
	int	status;

	RT_CK_TOL(tol);
	if( rt_g.debug & DEBUG_MATH )  {
		rt_log("rt_isect_lseg3_lseg3() p=(%g,%g), pdir=(%g,%g)\n\t\tq=(%g,%g), qdir=(%g,%g)\n",
			V2ARGS(p), V2ARGS(pdir), V2ARGS(q), V2ARGS(qdir) );
	}

	status = rt_isect_line3_line3( &dist[0], &dist[1], p, pdir, q, qdir, tol );
	if( status < 0 )  {
		/* Lines are parallel, non-colinear */
		return -1;	/* No intersection */
	}
	pmag = MAGNITUDE(pdir);
	if( pmag < SMALL_FASTF )
		rt_bomb("rt_isect_lseg3_lseg3: |p|=0\n");
	if( status == 0 )  {
		int	nogood = 0;
		/* Lines are colinear */
		/*  If P within tol of either endpoint (0, 1), make exact. */
		ptol = tol->dist / pmag;
		if( rt_g.debug & DEBUG_MATH )  {
			rt_log("ptol=%g\n", ptol);
		}
		if( dist[0] > -ptol && dist[0] < ptol )  dist[0] = 0;
		else if( dist[0] > 1-ptol && dist[0] < 1+ptol ) dist[0] = 1;

		if( dist[1] > -ptol && dist[1] < ptol )  dist[1] = 0;
		else if( dist[1] > 1-ptol && dist[1] < 1+ptol ) dist[1] = 1;

		if( dist[1] < 0 || dist[1] > 1 )  nogood = 1;
		if( dist[0] < 0 || dist[0] > 1 )  nogood++;
		if( nogood >= 2 )
			return -1;	/* colinear, but not overlapping */
		if( rt_g.debug & DEBUG_MATH )  {
			rt_log("  HIT colinear!\n");
		}
		return 0;		/* colinear and overlapping */
	}
	/* Lines intersect */
	/*  If within tolerance of an endpoint (0, 1), make exact. */
	ptol = tol->dist / pmag;
	if( dist[0] > -ptol && dist[0] < ptol )  dist[0] = 0;
	else if( dist[0] > 1-ptol && dist[0] < 1+ptol ) dist[0] = 1;

	qmag = MAGNITUDE(qdir);
	if( qmag < SMALL_FASTF )
		rt_bomb("rt_isect_lseg3_lseg3: |q|=0\n");
	qtol = tol->dist / qmag;
	if( dist[1] > -qtol && dist[1] < qtol )  dist[1] = 0;
	else if( dist[1] > 1-qtol && dist[1] < 1+qtol ) dist[1] = 1;

	if( rt_g.debug & DEBUG_MATH )  {
		rt_log("ptol=%g, qtol=%g\n", ptol, qtol);
	}
	if( dist[0] < 0 || dist[0] > 1 || dist[1] < 0 || dist[1] > 1 ) {
		if( rt_g.debug & DEBUG_MATH )  {
			rt_log("  MISS\n");
		}
		return -1;		/* missed */
	}
	if( rt_g.debug & DEBUG_MATH )  {
		rt_log("  HIT!\n");
	}
	return 1;			/* hit, normal intersection */
}

/*
 *			R T _ I S E C T _ L I N E 3 _ L I N E 3
 *
 *  Intersect two lines, each in given in parametric form:
 *
 *	X = P + t * D
 *  and
 *	X = A + u * C
 *
 *  While the parametric form is usually used to denote a ray
 *  (ie, positive values of the parameter only), in this case
 *  the full line is considered.
 *
 *  The direction vectors C and D need not have unit length.
 *
 *  Explicit Return -
 *	-2	no intersection, lines are parallel.
 *	-1	no intersection
 *	 0	lines are co-linear (t returned for u=0 to give distance to A)
 *	 1	intersection found (t and u returned)
 *
 *  Implicit Returns -
 *
 *	t,u	When explicit return >= 0, t and u are the
 *		line parameters of the intersection point on the 2 rays.
 *		The actual intersection coordinates can be found by
 *		substituting either of these into the original ray equations.
 *
 * XXX It would be sensible to change the t,u pair to dist[2].
 */
int
rt_isect_line3_line3( t, u, p, d, a, c, tol )
fastf_t			*t;
fastf_t			*u;
CONST point_t		p;
CONST vect_t		d;
CONST point_t		a;
CONST vect_t		c;
CONST struct rt_tol	*tol;
{
	LOCAL vect_t		n;
	LOCAL vect_t		abs_n;
	LOCAL vect_t		h;
	register fastf_t	det;
	register fastf_t	det1;
	register short int	q,r,s;

	RT_CK_TOL(tol);

	/*
	 *  Any intersection will occur in the plane with surface
	 *  normal D cross C, which may not have unit length.
	 *  The plane containing the two lines will be a constant
	 *  distance from a plane with the same normal that contains
	 *  the origin.  Therfore, the projection of any point on the
	 *  plane along N has the same length.
	 *  Verify that this holds for P and A.
	 *  If N dot P != N dot A, there is no intersection, because
	 *  P and A must lie on parallel planes that are different
	 *  distances from the origin.
	 */
	VCROSS( n, d, c );
	det = VDOT( n, p ) - VDOT( n, a );
	if( !NEAR_ZERO( det, tol->dist ) )  {
		return(-1);		/* No intersection */
	}

	if( NEAR_ZERO( MAGSQ( n ) , SMALL_FASTF ) )
	{
		vect_t a_to_p;

		/* lines are parallel, must find another way to get normal vector */
		VSUB2( a_to_p , p , a );
		VCROSS( n , a_to_p , d );

		/* if normal still has zero length, then lines are parallel and collinear
		 * and the following code will work OK */
	}

	/*
	 *  Solve for t and u in the system:
	 *
	 *	Px + t * Dx = Ax + u * Cx
	 *	Py + t * Dy = Ay + u * Cy
	 *	Pz + t * Dz = Az + u * Cz
	 *
	 *  This system is over-determined, having 3 equations in 2 unknowns.
	 *  However, the intersection problem is really only a 2-dimensional
	 *  problem, being located in the surface of a plane.
	 *  Therefore, the "least important" of these equations can
	 *  be initially ignored, leaving a system of 2 equations in
	 *  2 unknowns.
	 *
	 *  Find the component of N with the largest magnitude.
	 *  This component will have the least effect on the parameters
	 *  in the system, being most nearly perpendicular to the plane.
	 *  Denote the two remaining components by the
	 *  subscripts q and r, rather than x,y,z.
	 *  Subscript s is the smallest component, used for checking later.
	 */
	abs_n[X] = (n[X] >= 0) ? n[X] : (-n[X]);
	abs_n[Y] = (n[Y] >= 0) ? n[Y] : (-n[Y]);
	abs_n[Z] = (n[Z] >= 0) ? n[Z] : (-n[Z]);
	if( abs_n[X] >= abs_n[Y] )  {
		if( abs_n[X] >= abs_n[Z] )  {
			/* X is largest in magnitude */
			q = Y;
			r = Z;
			s = X;
		} else {
			/* Z is largest in magnitude */
			q = X;
			r = Y;
			s = Z;
		}
	} else {
		if( abs_n[Y] >= abs_n[Z] )  {
			/* Y is largest in magnitude */
			q = X;
			r = Z;
			s = Y;
		} else {
			/* Z is largest in magnitude */
			q = X;
			r = Y;
			s = Z;
		}
	}

#if 0
	/* XXX Use rt_isect_line2_line2() here */
	/* move the 2d vectors around */
	rt_isect_line2_line2( &dist, p, d, a, c, tol );
#endif

	/*
	 *  From the two components q and r, form a system
	 *  of 2 equations in 2 unknowns:
	 *
	 *	Pq + t * Dq = Aq + u * Cq
	 *	Pr + t * Dr = Ar + u * Cr
	 *  or
	 *	t * Dq - u * Cq = Aq - Pq
	 *	t * Dr - u * Cr = Ar - Pr
	 *
	 *  Let H = A - P, resulting in:
	 *
	 *	t * Dq - u * Cq = Hq
	 *	t * Dr - u * Cr = Hr
	 *
	 *  or
	 *
	 *	[ Dq  -Cq ]   [ t ]   [ Hq ]
	 *	[         ] * [   ] = [    ]
	 *	[ Dr  -Cr ]   [ u ]   [ Hr ]
	 *
	 *  This system can be solved by direct substitution, or by
	 *  finding the determinants by Cramers rule:
	 *
	 *	             [ Dq  -Cq ]
	 *	det(M) = det [         ] = -Dq * Cr + Cq * Dr
	 *	             [ Dr  -Cr ]
	 *
	 *  If det(M) is zero, then the lines are parallel (perhaps colinear).
	 *  Otherwise, exactly one solution exists.
	 */
	VSUB2( h, a, p );
	det = c[q] * d[r] - d[q] * c[r];
	det1 = (c[q] * h[r] - h[q] * c[r]);		/* see below */
	/* XXX This should be no smaller than 1e-16.  See rt_isect_line2_line2 for details */
	if( NEAR_ZERO( det, DETERMINANT_TOL ) )  {
		/* Lines are parallel */
		if( !NEAR_ZERO( det1, DETERMINANT_TOL ) )  {
			/* Lines are NOT co-linear, just parallel */
			return -2;	/* parallel, no intersection */
		}

		/* Lines are co-linear */
		/* Compute t for u=0 as a convenience to caller */
		*u = 0;
		/* Use largest direction component */
		if( fabs(d[q]) >= fabs(d[r]) )  {
			*t = h[q]/d[q];
		} else {
			*t = h[r]/d[r];
		}
		return(0);	/* Lines co-linear */
	}

	/*
	 *  det(M) is non-zero, so there is exactly one solution.
	 *  Using Cramer's rule, det1(M) replaces the first column
	 *  of M with the constant column vector, in this case H.
	 *  Similarly, det2(M) replaces the second column.
	 *  Computation of the determinant is done as before.
	 *
	 *  Now,
	 *
	 *	                  [ Hq  -Cq ]
	 *	              det [         ]
	 *	    det1(M)       [ Hr  -Cr ]   -Hq * Cr + Cq * Hr
	 *	t = ------- = --------------- = ------------------
	 *	     det(M)       det(M)        -Dq * Cr + Cq * Dr
	 *
	 *  and
	 *
	 *	                  [ Dq   Hq ]
	 *	              det [         ]
	 *	    det2(M)       [ Dr   Hr ]    Dq * Hr - Hq * Dr
	 *	u = ------- = --------------- = ------------------
	 *	     det(M)       det(M)        -Dq * Cr + Cq * Dr
	 */
	det = 1/det;
	*t = det * det1;
	*u = det * (d[q] * h[r] - h[q] * d[r]);

	/*
	 *  Check that these values of t and u satisfy the 3rd equation
	 *  as well!
	 *  XXX It isn't clear that "det" is exactly a model-space distance.
	 */
	det = *t * d[s] - *u * c[s] - h[s];
	if( !NEAR_ZERO( det, tol->dist ) )  {
		/* XXX This tolerance needs to be much less loose than
		 * XXX SQRT_SMALL_FASTF.  What about DETERMINANT_TOL?
		 */
		/* Inconsistent solution, lines miss each other */
		return(-1);
	}

	/*  To prevent errors, check the answer.
	 *  Not returning bogus results to our caller is worth the extra time.
	 */
	{
		point_t		hit1, hit2;

		VJOIN1( hit1, p, *t, d );
		VJOIN1( hit2, a, *u, c );
		if( !rt_pt3_pt3_equal( hit1, hit2, tol ) )  {
/*			rt_log("rt_isect_line3_line3(): BOGUS RESULT, hit1=(%g,%g,%g), hit2=(%g,%g,%g)\n",
				hit1[X], hit1[Y], hit1[Z], hit2[X], hit2[Y], hit2[Z]); */
			return -1;
		}
	}

	return(1);		/* Intersection found */
}

/*
 *			R T _ I S E C T _ L I N E _ L S E G
 *
 *  Intersect a line in parametric form:
 *
 *	X = P + t * D
 *
 *  with a line segment defined by two distinct points A and B.
 *
 *  Explicit Return -
 *	-4	A and B are not distinct points
 *	-3	Intersection exists, < A (t is returned)
 *	-2	Intersection exists, > B (t is returned)
 *	-1	Lines do not intersect
 *	 0	Lines are co-linear (t for A is returned)
 *	 1	Intersection at vertex A
 *	 2	Intersection at vertex B
 *	 3	Intersection between A and B
 *
 *  Implicit Returns -
 *	t	When explicit return >= 0, t is the parameter that describes
 *		the intersection of the line and the line segment.
 *		The actual intersection coordinates can be found by
 *		solving P + t * D.  However, note that for return codes
 *		1 and 2 (intersection exactly at a vertex), it is
 *		strongly recommended that the original values passed in
 *		A or B are used instead of solving P + t * D, to prevent
 *		numeric error from creeping into the position of
 *		the endpoints.
 */
/* XXX should probably be called rt_isect_line3_lseg3() */
/* XXX should probably be changed to return dist[2] */
int
rt_isect_line_lseg( t, p, d, a, b, tol )
fastf_t			*t;
CONST point_t		p;
CONST vect_t		d;
CONST point_t		a;
CONST point_t		b;
CONST struct rt_tol	*tol;
{
	LOCAL vect_t	c;		/* Direction vector from A to B */
	auto fastf_t	u;		/* As in, A + u * C = X */
	register fastf_t f;
	register int	ret;
	fastf_t		fuzz;

	RT_CK_TOL(tol);

	VSUB2( c, b, a );
	/*
	 *  To keep the values of u between 0 and 1,
	 *  C should NOT be scaled to have unit length.
	 *  However, it is a good idea to make sure that
	 *  C is a non-zero vector, (ie, that A and B are distinct).
	 */
	if( (fuzz = MAGSQ(c)) < tol->dist_sq )  {
		return(-4);		/* points A and B are not distinct */
	}

	/*
	 *  Detecting colinearity is difficult, and very very important.
	 *  As a first step, check to see if both points A and B lie
	 *  within tolerance of the line.  If so, then the line segment AC
	 *  is ON the line.
	 */
	if( rt_distsq_line3_pt3( p, d, a ) <= tol->dist_sq  &&
	    rt_distsq_line3_pt3( p, d, b ) <= tol->dist_sq )  {
		if( rt_g.debug & DEBUG_MATH )  {
			rt_log("rt_isect_line3_lseg3() pts A and B within tol of line\n");
		}
	    	/* Find the parametric distance along the ray */
		*t = rt_dist_pt3_along_line3( p, d, a );
		/*** dist[1] = rt_dist_pt3_along_line3( p, d, b ); ***/
		return 0;		/* Colinear */
	}

	if( (ret = rt_isect_line3_line3( t, &u, p, d, a, c, tol )) < 0 )  {
		/* No intersection found */
		return( -1 );
	}
	if( ret == 0 )  {
		/* co-linear (t was computed for point A, u=0) */
		return( 0 );
	}

	/*
	 *  The two lines intersect at a point.
	 *  If the u parameter is outside the range (0..1),
	 *  reject the intersection, because it falls outside
	 *  the line segment A--B.
	 *
	 *  Convert the tol->dist into allowable deviation in terms of
	 *  (0..1) range of the parameters.
	 */
	fuzz = tol->dist / sqrt(fuzz);
	if( u < -fuzz )
		return(-3);		/* Intersection < A */
	if( (f=(u-1)) > fuzz )
		return(-2);		/* Intersection > B */

	/* Check for fuzzy intersection with one of the verticies */
	if( u < fuzz )
		return( 1 );		/* Intersection at A */
	if( f >= -fuzz )
		return( 2 );		/* Intersection at B */

	return(3);			/* Intersection between A and B */
}

/*
 *			R T _ D I S T _ L I N E 3_ P T 3
 *
 *  Given a parametric line defined by PT + t * DIR and a point A,
 *  return the closest distance between the line and the point.
 *
 *  'dir' need not have unit length.
 *
 *  Find parameter for PCA along line with unitized DIR:
 *	d = VDOT(f, dir) / MAGNITUDE(dir);
 *  Find distance g from PCA to A using Pythagoras:
 *	g = sqrt( MAGSQ(f) - d**2 )
 *
 *  Return -
 *	Distance
 */
double
rt_dist_line3_pt3( pt, dir, a )
CONST point_t	pt;
CONST vect_t	dir;
CONST point_t	a;
{
	LOCAL vect_t		f;
	register fastf_t	FdotD;

	if( (FdotD = MAGNITUDE(dir)) <= SMALL_FASTF )  {
		FdotD = 0.0;
		goto out;
	}
	VSUB2( f, a, pt );
	FdotD = VDOT( f, dir ) / FdotD;
	FdotD = MAGSQ( f ) - FdotD * FdotD;
	if( FdotD <= SMALL_FASTF )  {
		FdotD = 0.0;
		goto out;
	}
	FdotD = sqrt(FdotD);
out:
	if( rt_g.debug & DEBUG_MATH )  {
		rt_log("rt_dist_line3_pt3() ret=%g\n", FdotD);
	}
	return FdotD;
}

/*
 *			R T _ D I S T S Q _ L I N E 3 _ P T 3
 *
 *  Given a parametric line defined by PT + t * DIR and a point A,
 *  return the square of the closest distance between the line and the point.
 *
 *  'dir' need not have unit length.
 *
 *  Return -
 *	Distance squared
 */
double
rt_distsq_line3_pt3( pt, dir, a )
CONST point_t	pt;
CONST vect_t	dir;
CONST point_t	a;
{
	LOCAL vect_t		f;
	register fastf_t	FdotD;

	VSUB2( f, pt, a );
	if( (FdotD = MAGNITUDE(dir)) <= SMALL_FASTF )  {
		FdotD = 0.0;
		goto out;
	}
	FdotD = VDOT( f, dir ) / FdotD;
	if( (FdotD = VDOT( f, f ) - FdotD * FdotD ) <= SMALL_FASTF )  {
		FdotD = 0.0;
	}
out:
	if( rt_g.debug & DEBUG_MATH )  {
		rt_log("rt_distsq_line3_pt3() ret=%g\n", FdotD);
	}
	return FdotD;
}

/*
 *			R T _ D I S T _ L I N E _ O R I G I N
 *
 *  Given a parametric line defined by PT + t * DIR,
 *  return the closest distance between the line and the origin.
 *
 *  'dir' need not have unit length.
 *
 *  Return -
 *	Distance
 */
double
rt_dist_line_origin( pt, dir )
CONST point_t	pt;
CONST vect_t	dir;
{
	register fastf_t	PTdotD;

	if( (PTdotD = MAGNITUDE(dir)) <= SMALL_FASTF )
		return 0.0;
	PTdotD = VDOT( pt, dir ) / PTdotD;
	if( (PTdotD = VDOT( pt, pt ) - PTdotD * PTdotD ) <= SMALL_FASTF )
		return(0.0);
	return( sqrt(PTdotD) );
}
/*
 *			R T _ D I S T _ L I N E 2 _ P O I N T 2
 *
 *  Given a parametric line defined by PT + t * DIR and a point A,
 *  return the closest distance between the line and the point.
 *
 *  'dir' need not have unit length.
 *
 *  Return -
 *	Distance
 */
double
rt_dist_line2_point2( pt, dir, a )
CONST point_t	pt;
CONST vect_t	dir;
CONST point_t	a;
{
	LOCAL vect_t		f;
	register fastf_t	FdotD;

	VSUB2_2D( f, pt, a );
	if( (FdotD = sqrt(MAGSQ_2D(dir))) <= SMALL_FASTF )
		return 0.0;
	FdotD = VDOT_2D( f, dir ) / FdotD;
	if( (FdotD = VDOT_2D( f, f ) - FdotD * FdotD ) <= SMALL_FASTF )
		return(0.0);
	return( sqrt(FdotD) );
}

/*
 *			R T _ D I S T S Q _ L I N E 2 _ P O I N T 2
 *
 *  Given a parametric line defined by PT + t * DIR and a point A,
 *  return the closest distance between the line and the point, squared.
 *
 *  'dir' need not have unit length.
 *
 *  Return -
 *	Distance squared
 */
double
rt_distsq_line2_point2( pt, dir, a )
CONST point_t	pt;
CONST vect_t	dir;
CONST point_t	a;
{
	LOCAL vect_t		f;
	register fastf_t	FdotD;

	VSUB2_2D( f, pt, a );
	if( (FdotD = sqrt(MAGSQ_2D(dir))) <= SMALL_FASTF )
		return 0.0;
	FdotD = VDOT_2D( f, dir ) / FdotD;
	if( (FdotD = VDOT_2D( f, f ) - FdotD * FdotD ) <= SMALL_FASTF )
		return(0.0);
	return( FdotD );
}

/*
 *			R T _ A R E A _ O F _ T R I A N G L E
 *
 *  Returns the area of a triangle.
 *  Algorithm by Jon Leech 3/24/89.
 */
double
rt_area_of_triangle( a, b, c )
register CONST point_t a, b, c;
{
	register double	t;
	register double	area;

	t =	a[Y] * (b[Z] - c[Z]) -
		b[Y] * (a[Z] - c[Z]) +
		c[Y] * (a[Z] - b[Z]);
	area  = t*t;
	t =	a[Z] * (b[X] - c[X]) -
		b[Z] * (a[X] - c[X]) +
		c[Z] * (a[X] - b[X]);
	area += t*t;
	t = 	a[X] * (b[Y] - c[Y]) -
		b[X] * (a[Y] - c[Y]) +
		c[X] * (a[Y] - b[Y]);
	area += t*t;

	return( 0.5 * sqrt(area) );
}


/*
 *			R T _ I S E C T _ P T _ L S E G
 *
 * Intersect a point P with the line segment defined by two distinct
 * points A and B.
 *	
 * Explicit Return
 *	-2	P on line AB but outside range of AB,
 *			dist = distance from A to P on line.
 *	-1	P not on line of AB within tolerance
 *	1	P is at A
 *	2	P is at B
 *	3	P is on AB, dist = distance from A to P on line.
 *	
 *    B *
 *	|  
 *    P'*-tol-*P 
 *	|    /  _
 *    dist  /   /|
 *	|  /   /
 *	| /   / AtoP
 *	|/   /
 *    A *   /
 *	
 *	tol = distance limit from line to pt P;
 *	dist = distance from A to P'
 */
int rt_isect_pt_lseg(dist, a, b, p, tol)
fastf_t			*dist;		/* distance along line from A to P */
CONST point_t		a, b, p;	/* points for line and intersect */
CONST struct rt_tol	*tol;
{
	vect_t	AtoP,
		BtoP,
		AtoB,
		ABunit;	/* unit vector from A to B */
	fastf_t	APprABunit;	/* Mag of projection of AtoP onto ABunit */
	fastf_t	distsq;

	RT_CK_TOL(tol);

	VSUB2(AtoP, p, a);
	if (MAGSQ(AtoP) < tol->dist_sq)
		return(1);	/* P at A */

	VSUB2(BtoP, p, b);
	if (MAGSQ(BtoP) < tol->dist_sq)
		return(2);	/* P at B */

	VSUB2(AtoB, b, a);
	VMOVE(ABunit, AtoB);
	distsq = MAGSQ(ABunit);
	if( distsq < tol->dist_sq )
		return -1;	/* A equals B, and P isn't there */
	distsq = 1/sqrt(distsq);
	VSCALE( ABunit, ABunit, distsq );

	/* Similar to rt_dist_line_pt, except we
	 * never actually have to do the sqrt that the other routine does.
	 */

	/* find dist as a function of ABunit, actually the projection
	 * of AtoP onto ABunit
	 */
	APprABunit = VDOT(AtoP, ABunit);

	/* because of pythgorean theorem ... */
	distsq = MAGSQ(AtoP) - APprABunit * APprABunit;
	if (distsq > tol->dist_sq)
		return(-1);	/* dist pt to line too large */

	/* Distance from the point to the line is within tolerance. */
	*dist = VDOT(AtoP, AtoB) / MAGSQ(AtoB);

	if (*dist > 1.0 || *dist < 0.0)	/* P outside AtoB */
		return(-2);

	return(3);	/* P on AtoB */
}

/*
 *			R T _ I S E C T _ P T 2 _ L S E G 2
 *
 * Intersect a point P with the line segment defined by two distinct
 * points A and B.
 *	
 * Explicit Return
 *	-2	P on line AB but outside range of AB,
 *			dist = distance from A to P on line.
 *	-1	P not on line of AB within tolerance
 *	1	P is at A
 *	2	P is at B
 *	3	P is on AB, dist = distance from A to P on line.
 *	
 *    B *
 *	|  
 *    P'*-tol-*P 
 *	|    /  _
 *    dist  /   /|
 *	|  /   /
 *	| /   / AtoP
 *	|/   /
 *    A *   /
 *	
 *	tol = distance limit from line to pt P;
 *	dist = distance from A to P'
 */
int
rt_isect_pt2_lseg2(dist, a, b, p, tol)
fastf_t			*dist;		/* distance along line from A to P */
CONST point_t		a, b, p;	/* points for line and intersect */
CONST struct rt_tol	*tol;
{
	vect_t	AtoP,
		BtoP,
		AtoB,
		ABunit;	/* unit vector from A to B */
	fastf_t	APprABunit;	/* Mag of projection of AtoP onto ABunit */
	fastf_t	distsq;

	RT_CK_TOL(tol);

	VSUB2_2D(AtoP, p, a);
	if (MAGSQ_2D(AtoP) < tol->dist_sq)
		return(1);	/* P at A */

	VSUB2_2D(BtoP, p, b);
	if (MAGSQ_2D(BtoP) < tol->dist_sq)
		return(2);	/* P at B */

	VSUB2_2D(AtoB, b, a);
	VMOVE_2D(ABunit, AtoB);
	distsq = MAGSQ_2D(ABunit);
	if( distsq < tol->dist_sq )  {
		if( rt_g.debug & DEBUG_MATH )  {
			rt_log("distsq A=%g\n", distsq);
		}
		return -1;	/* A equals B, and P isn't there */
	}
	distsq = 1/sqrt(distsq);
	VSCALE_2D( ABunit, ABunit, distsq );

	/* Similar to rt_dist_line_pt, except we
	 * never actually have to do the sqrt that the other routine does.
	 */

	/* find dist as a function of ABunit, actually the projection
	 * of AtoP onto ABunit
	 */
	APprABunit = VDOT_2D(AtoP, ABunit);

	/* because of pythgorean theorem ... */
	distsq = MAGSQ_2D(AtoP) - APprABunit * APprABunit;
	if (distsq > tol->dist_sq) {
		if( rt_g.debug & DEBUG_MATH )  {
			V2PRINT("ABunit", ABunit);
			rt_log("distsq B=%g\n", distsq);
		}
		return(-1);	/* dist pt to line too large */
	}

	/* Distance from the point to the line is within tolerance. */
	*dist = VDOT_2D(AtoP, AtoB) / MAGSQ_2D(AtoB);

	if (*dist > 1.0 || *dist < 0.0)	/* P outside AtoB */
		return(-2);

	return(3);	/* P on AtoB */
}

/*
 *			R T _ D I S T _ P T 3 _ L S E G 3
 *
 *  Find the distance from a point P to a line segment described
 *  by the two endpoints A and B, and the point of closest approach (PCA).
 *
 *			P
 *		       *
 *		      /.
 *		     / .
 *		    /  .
 *		   /   . (dist)
 *		  /    .
 *		 /     .
 *		*------*--------*
 *		A      PCA	B
 *
 *  There are six distinct cases, with these return codes -
 *	0	P is within tolerance of lseg AB.  *dist isn't 0: (SPECIAL!!!)
 *		  *dist = parametric dist = |PCA-A| / |B-A|.  pca=computed.
 *	1	P is within tolerance of point A.  *dist = 0, pca=A.
 *	2	P is within tolerance of point B.  *dist = 0, pca=B.
 *	3	P is to the "left" of point A.  *dist=|P-A|, pca=A.
 *	4	P is to the "right" of point B.  *dist=|P-B|, pca=B.
 *	5	P is "above/below" lseg AB.  *dist=|PCA-P|, pca=computed.
 *
 * This routine was formerly called rt_dist_pt_lseg().
 *
 * XXX For efficiency, a version of this routine that provides the
 * XXX distance squared would be faster.
 */
int
rt_dist_pt3_lseg3( dist, pca, a, b, p, tol )
fastf_t		*dist;
point_t		pca;
CONST point_t	a, b, p;
CONST struct rt_tol *tol;
{
	vect_t	PtoA;		/* P-A */
	vect_t	PtoB;		/* P-B */
	vect_t	AtoB;		/* B-A */
	fastf_t	P_A_sq;		/* |P-A|**2 */
	fastf_t	P_B_sq;		/* |P-B|**2 */
	fastf_t	B_A;		/* |B-A| */
	fastf_t	t;		/* distance along ray of projection of P */

	RT_CK_TOL(tol);

	if( rt_g.debug & DEBUG_MATH )  {
		rt_log("rt_dist_pt3_lseg3() a=(%g,%g,%g) b=(%g,%g,%g)\n\tp=(%g,%g,%g), tol->dist=%g sq=%g\n",
			V3ARGS(a),
			V3ARGS(b),
			V3ARGS(p),
			tol->dist, tol->dist_sq );
	}

	/* Check proximity to endpoint A */
	VSUB2(PtoA, p, a);
	if( (P_A_sq = MAGSQ(PtoA)) < tol->dist_sq )  {
		/* P is within the tol->dist radius circle around A */
		VMOVE( pca, a );
		if( rt_g.debug & DEBUG_MATH )  rt_log("  at A\n");
		*dist = 0.0;
		return 1;
	}

	/* Check proximity to endpoint B */
	VSUB2(PtoB, p, b);
	if( (P_B_sq = MAGSQ(PtoB)) < tol->dist_sq )  {
		/* P is within the tol->dist radius circle around B */
		VMOVE( pca, b );
		if( rt_g.debug & DEBUG_MATH )  rt_log("  at B\n");
		*dist = 0.0;
		return 2;
	}

	VSUB2(AtoB, b, a);
	B_A = sqrt( MAGSQ(AtoB) );

	/* compute distance (in actual units) along line to PROJECTION of
	 * point p onto the line: point pca
	 */
	t = VDOT(PtoA, AtoB) / B_A;
	if( rt_g.debug & DEBUG_MATH )  {
		rt_log("rt_dist_pt3_lseg3() B_A=%g, t=%g\n",
			B_A, t );
	}

	if( t <= 0 )  {
		/* P is "left" of A */
		if( rt_g.debug & DEBUG_MATH )  rt_log("  left of A\n");
		VMOVE( pca, a );
		*dist = sqrt(P_A_sq);
		return 3;
	}
	if( t < B_A )  {
		/* PCA falls between A and B */
		register fastf_t	dsq;
		fastf_t			param_dist;	/* parametric dist */

		/* Find PCA */
		param_dist = t / B_A;		/* Range 0..1 */
		VJOIN1(pca, a, param_dist, AtoB);

		/* Find distance from PCA to line segment (Pythagorus) */
		if( (dsq = P_A_sq - t * t ) <= tol->dist_sq )  {
			if( rt_g.debug & DEBUG_MATH )  rt_log("  ON lseg\n");
			/* Distance from PCA to lseg is zero, give param instead */
			*dist = param_dist;	/* special! */
			return 0;
		}
		if( rt_g.debug & DEBUG_MATH )  rt_log("  closest to lseg\n");
		*dist = sqrt(dsq);
		return 5;
	}
	/* P is "right" of B */
	if( rt_g.debug & DEBUG_MATH )  rt_log("  right of B\n");
	VMOVE(pca, b);
	*dist = sqrt(P_B_sq);
	return 4;
}

/*
 *			R T _ D I S T _ P T 2 _ L S E G 2
 *
 *  Find the distance from a point P to a line segment described
 *  by the two endpoints A and B, and the point of closest approach (PCA).
 *
 *			P
 *		       *
 *		      /.
 *		     / .
 *		    /  .
 *		   /   . (dist)
 *		  /    .
 *		 /     .
 *		*------*--------*
 *		A      PCA	B
 *
 *  There are six distinct cases, with these return codes -
 *	0	P is within tolerance of lseg AB.  *dist isn't 0: (SPECIAL!!!)
 *		  *dist = parametric dist = |PCA-A| / |B-A|.  pca=computed.
 *	1	P is within tolerance of point A.  *dist = 0, pca=A.
 *	2	P is within tolerance of point B.  *dist = 0, pca=B.
 *	3	P is to the "left" of point A.  *dist=|P-A|**2, pca=A.
 *	4	P is to the "right" of point B.  *dist=|P-B|**2, pca=B.
 *	5	P is "above/below" lseg AB.  *dist=|PCA-P|**2, pca=computed.
 *
 *
 *  Patterned after rt_dist_pt3_lseg3().
 */
int
rt_dist_pt2_lseg2( dist_sq, pca, a, b, p, tol )
fastf_t		*dist_sq;
fastf_t		pca[2];
CONST point_t	a, b, p;
CONST struct rt_tol *tol;
{
	vect_t	PtoA;		/* P-A */
	vect_t	PtoB;		/* P-B */
	vect_t	AtoB;		/* B-A */
	fastf_t	P_A_sq;		/* |P-A|**2 */
	fastf_t	P_B_sq;		/* |P-B|**2 */
	fastf_t	B_A;		/* |B-A| */
	fastf_t	t;		/* distance along ray of projection of P */

	RT_CK_TOL(tol);

	if( rt_g.debug & DEBUG_MATH )  {
		rt_log("rt_dist_pt3_lseg3() a=(%g,%g,%g) b=(%g,%g,%g)\n\tp=(%g,%g,%g), tol->dist=%g sq=%g\n",
			V3ARGS(a),
			V3ARGS(b),
			V3ARGS(p),
			tol->dist, tol->dist_sq );
	}


	/* Check proximity to endpoint A */
	VSUB2_2D(PtoA, p, a);
	if( (P_A_sq = MAGSQ_2D(PtoA)) < tol->dist_sq )  {
		/* P is within the tol->dist radius circle around A */
		V2MOVE( pca, a );
		if( rt_g.debug & DEBUG_MATH )  rt_log("  at A\n");
		*dist_sq = 0.0;
		return 1;
	}

	/* Check proximity to endpoint B */
	VSUB2_2D(PtoB, p, b);
	if( (P_B_sq = MAGSQ_2D(PtoB)) < tol->dist_sq )  {
		/* P is within the tol->dist radius circle around B */
		V2MOVE( pca, b );
		if( rt_g.debug & DEBUG_MATH )  rt_log("  at B\n");
		*dist_sq = 0.0;
		return 2;
	}

	VSUB2_2D(AtoB, b, a);
	B_A = sqrt( MAGSQ_2D(AtoB) );

	/* compute distance (in actual units) along line to PROJECTION of
	 * point p onto the line: point pca
	 */
	t = VDOT_2D(PtoA, AtoB) / B_A;
	if( rt_g.debug & DEBUG_MATH )  {
		rt_log("rt_dist_pt3_lseg3() B_A=%g, t=%g\n",
			B_A, t );
	}

	if( t <= 0 )  {
		/* P is "left" of A */
		if( rt_g.debug & DEBUG_MATH )  rt_log("  left of A\n");
		V2MOVE( pca, a );
		*dist_sq = P_A_sq;
		return 3;
	}
	if( t < B_A )  {
		/* PCA falls between A and B */
		register fastf_t	dsq;
		fastf_t			param_dist;	/* parametric dist */

		/* Find PCA */
		param_dist = t / B_A;		/* Range 0..1 */
		V2JOIN1(pca, a, param_dist, AtoB);

		/* Find distance from PCA to line segment (Pythagorus) */
		if( (dsq = P_A_sq - t * t ) <= tol->dist_sq )  {
			if( rt_g.debug & DEBUG_MATH )  rt_log("  ON lseg\n");
			/* Distance from PCA to lseg is zero, give param instead */
			*dist_sq = param_dist;	/* special! Not squared. */
			return 0;
		}
		if( rt_g.debug & DEBUG_MATH )  rt_log("  closest to lseg\n");
		*dist_sq = dsq;
		return 5;
	}
	/* P is "right" of B */
	if( rt_g.debug & DEBUG_MATH )  rt_log("  right of B\n");
	V2MOVE(pca, b);
	*dist_sq = P_B_sq;
	return 4;
}

/*
 *			R T _ R O T A T E _ B B O X
 *
 *  Transform a bounding box (RPP) by the given 4x4 matrix.
 *  There are 8 corners to the bounding RPP.
 *  Each one needs to be transformed and min/max'ed.
 *  This is not minimal, but does fully contain any internal object,
 *  using an axis-aligned RPP.
 */
void
rt_rotate_bbox( omin, omax, mat, imin, imax )
point_t		omin;
point_t		omax;
CONST mat_t	mat;
CONST point_t	imin;
CONST point_t	imax;
{
	point_t	local;		/* vertex point in local coordinates */
	point_t	model;		/* vertex point in model coordinates */

#define ROT_VERT( a, b, c )  \
	VSET( local, a[X], b[Y], c[Z] ); \
	MAT4X3PNT( model, mat, local ); \
	VMINMAX( omin, omax, model ) \

	ROT_VERT( imin, imin, imin );
	ROT_VERT( imin, imin, imax );
	ROT_VERT( imin, imax, imin );
	ROT_VERT( imin, imax, imax );
	ROT_VERT( imax, imin, imin );
	ROT_VERT( imax, imin, imax );
	ROT_VERT( imax, imax, imin );
	ROT_VERT( imax, imax, imax );
#undef ROT_VERT
}

/*
 *			R T _ R O T A T E _ P L A N E
 *
 *  Transform a plane equation by the given 4x4 matrix.
 */
void
rt_rotate_plane( oplane, mat, iplane )
plane_t		oplane;
CONST mat_t	mat;
CONST plane_t	iplane;
{
	point_t		orig_pt;
	point_t		new_pt;

	/* First, pick a point that lies on the original halfspace */
	VSCALE( orig_pt, iplane, iplane[3] );

	/* Transform the surface normal */
	MAT4X3VEC( oplane, mat, iplane );

	/* Transform the point from original to new halfspace */
	MAT4X3PNT( new_pt, mat, orig_pt );

	/*
	 *  The transformed normal is all that is required.
	 *  The new distance is found from the transformed point on the plane.
	 */
	oplane[3] = VDOT( new_pt, oplane );
}

/*
 *			R T _ C O P L A N A R
 *
 *  Test if two planes are identical.  If so, their dot products will be
 *  either +1 or -1, with the distance from the origin equal in magnitude.
 *
 *  Returns -
 *	-1	not coplanar, parallel but distinct
 *	 0	not coplanar, not parallel.  Planes intersect.
 *	+1	coplanar, same normal direction
 *	+2	coplanar, opposite normal direction
 */
int
rt_coplanar( a, b, tol )
CONST plane_t		a;
CONST plane_t		b;
CONST struct rt_tol	*tol;
{
	register fastf_t	f;
	register fastf_t	dot;

	RT_CK_TOL(tol);

	/* Check to see if the planes are parallel */
	dot = VDOT( a, b );
	if( dot >= 0 )  {
		/* Normals head in generally the same directions */
		if( dot < tol->para )
			return(0);	/* Planes intersect */

		/* Planes have "exactly" the same normal vector */
		f = a[3] - b[3];
		if( NEAR_ZERO( f, tol->dist ) )  {
			return(1);	/* Coplanar, same direction */
		}
		return(-1);		/* Parallel but distinct */
	}
	/* Normals head in generally opposite directions */
	if( -dot < tol->para )
		return(0);		/* Planes intersect */

	/* Planes have "exactly" opposite normal vectors */
	f = a[3] + b[3];
	if( NEAR_ZERO( f, tol->dist ) )  {
		return(2);		/* Coplanar, opposite directions */
	}
	return(-1);			/* Parallel but distinct */
}

/*
 *			R T _ A N G L E _ M E A S U R E
 *
 *  Using two perpendicular vectors (x_dir and y_dir) which lie
 *  in the same plane as 'vec', return the angle (in radians) of 'vec'
 *  from x_dir, going CCW around the perpendicular x_dir CROSS y_dir.
 *
 *  Trig note -
 *
 *  theta = atan2(x,y) returns an angle in the range -pi to +pi.
 *  Here, we need an angle in the range of 0 to 2pi.
 *  This could be implemented by adding 2pi to theta when theta is negative,
 *  but this could have nasty numeric ambiguity right in the vicinity
 *  of theta = +pi, which is a very critical angle for the applications using
 *  this routine.
 *  So, an alternative formulation is to compute gamma = atan2(-x,-y),
 *  and then theta = gamma + pi.  Now, any error will occur in the
 *  vicinity of theta = 0, which can be handled much more readily.
 *
 *  If theta is negative, or greater than two pi,
 *  wrap it around.
 *  These conditions only occur if there are problems in atan2().
 *
 *  Returns -
 *	vec == x_dir returns 0,
 *	vec == y_dir returns pi/2,
 *	vec == -x_dir returns pi,
 *	vec == -y_dir returns 3*pi/2.
 *
 *  In all cases, the returned value is between 0 and rt_twopi.
 */
double
rt_angle_measure( vec, x_dir, y_dir )
vect_t	vec;
CONST vect_t	x_dir;
CONST vect_t	y_dir;
{
	fastf_t		xproj, yproj;
	fastf_t		gamma;
	fastf_t		ang;

	xproj = -VDOT( vec, x_dir );
	yproj = -VDOT( vec, y_dir );
	gamma = atan2( yproj, xproj );	/* -pi..+pi */
	ang = rt_pi + gamma;		/* 0..+2pi */
	if( ang < 0 )  {
		do {
			ang += rt_twopi;
		} while( ang < 0 );
	} else if( ang > rt_twopi )  {
		do {
			ang -= rt_twopi;
		} while( ang > rt_twopi );
	}
	if( ang < 0 || ang > rt_twopi )  rt_bomb("rt_angle_measure() angle out of range\n");
	return ang;
}

/*
 *			R T _ D I S T _ P T 3 _ A L O N G _ L I N E 3
 *
 *  Return the parametric distance t of a point X along a line defined
 *  as a ray, i.e. solve X = P + t * D.
 *  If the point X does not lie on the line, then t is the distance of
 *  the perpendicular projection of point X onto the line.
 */
double
rt_dist_pt3_along_line3( p, d, x )
CONST point_t	p;
CONST vect_t	d;
CONST point_t	x;
{
	vect_t	x_p;

	VSUB2( x_p, x, p );
	return VDOT( x_p, d );
}


/*
 *			R T _ D I S T _ P T 2 _ A L O N G _ L I N E 2
 *
 *  Return the parametric distance t of a point X along a line defined
 *  as a ray, i.e. solve X = P + t * D.
 *  If the point X does not lie on the line, then t is the distance of
 *  the perpendicular projection of point X onto the line.
 */
double
rt_dist_pt2_along_line2( p, d, x )
CONST point_t	p;
CONST vect_t	d;
CONST point_t	x;
{
	vect_t	x_p;
	double	ret;

	VSUB2_2D( x_p, x, p );
	ret = VDOT_2D( x_p, d );
	if( rt_g.debug & DEBUG_MATH )  {
		rt_log("rt_dist_pt2_along_line2() p=(%g, %g), d=(%g, %g), x=(%g, %g) ret=%g\n",
			V2ARGS(p),
			V2ARGS(d),
			V2ARGS(x),
			ret );
	}
	return ret;
}

/*
 *  Returns -
 *	1	if left <= mid <= right
 *	0	if mid is not in the range.
 */
int
rt_between( left, mid, right, tol )
double	left;
double	mid;
double	right;
CONST struct rt_tol	*tol;
{
	RT_CK_TOL(tol);

	if( left < right )  {
		if( NEAR_ZERO(left-right, tol->dist*0.1) )  {
			left -= tol->dist*0.1;
			right += tol->dist*0.1;
		}
		if( mid < left || mid > right )  goto fail;
		return 1;
	}
	/* The 'right' value is lowest */
	if( NEAR_ZERO(left-right, tol->dist*0.1) )  {
		right -= tol->dist*0.1;
		left += tol->dist*0.1;
	}
	if( mid < right || mid > left )  goto fail;
	return 1;
fail:
	if( rt_g.debug & DEBUG_MATH )  {
		rt_log("rt_between( %.17e, %.17e, %.17e ) ret=0 FAIL\n",
			left, mid, right);
	}
	return 0;
}
@


11.6
log
@Commented out irritating "BOGUS HIT" message from rt_isect_line3_line3().
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 11.5 1996/04/12 14:56:26 jra Exp jra $ (BRL)";
@


11.6.12.1
log
@file plane.c was added on branch rel-7-6-branch on 2005-11-13 17:44:59 +0000
@
text
@d1 2379
@


11.6.12.2
log
@more merging changes from HEAD aka rel-7-6-4 to the rel-7-6-branch, adding the items that were moved and resolving rcs keyword conflicts
@
text
@a0 2379
/*
 *			P L A N E . C
 *
 *  Some useful routines for dealing with planes and lines.
 *
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Distribution Status -
 *	Public Domain, Distribution Unlimited
 */
#ifndef lint
static char RCSplane[] = "@@(#)$Header$ (BRL)";
#endif

#include "conf.h"

#include <stdio.h>
#include <math.h>

#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "./debug.h"

/*
 *			R T _ D I S T _ P T 3 _ P T 3
 *
 *  Returns distance between two points.
 */
double
rt_dist_pt3_pt3( a, b )
CONST point_t	a;
CONST point_t	b;
{
	vect_t	diff;

	VSUB2( diff, a, b );
	return MAGNITUDE( diff );
}

/*
 *			R T _ P T 3 _ P T 3 _ E Q U A L
 *
 *  Returns -
 *	1	if the two points are equal, within the tolerance
 *	0	if the two points are not "the same"
 */
int
rt_pt3_pt3_equal( a, b, tol )
CONST point_t		a;
CONST point_t		b;
CONST struct rt_tol	*tol;
{
	vect_t	diff;

	RT_CK_TOL(tol);
	VSUB2( diff, b, a );
	if( MAGSQ( diff ) < tol->dist_sq )  return 1;
	return 0;
}

/*
 *			R T _ P T 2 _ P T 2 _ E Q U A L
 *
 *  Returns -
 *	1	if the two points are equal, within the tolerance
 *	0	if the two points are not "the same"
 */
int
rt_pt2_pt2_equal( a, b, tol )
CONST point_t		a;
CONST point_t		b;
CONST struct rt_tol	*tol;
{
	vect_t	diff;

	RT_CK_TOL(tol);
	VSUB2_2D( diff, b, a );
	if( MAGSQ_2D( diff ) < tol->dist_sq )  return 1;
	return 0;
}

/*
 *			R T _ 3 P T S _ C O L L I N E A R
 *
 *  Check to see if three points are collinear.
 *
 *  The algorithm is designed to work properly regardless of the
 *  order in which the points are provided.
 *
 *  Returns (boolean) -
 *	1	If 3 points are collinear
 *	0	If they are not
 */
int
rt_3pts_collinear(a, b, c, tol)
point_t	a, b, c;
struct rt_tol	*tol;
{
	fastf_t	mag_ab, mag_bc, mag_ca, max_len, dist_sq;
	fastf_t cos_a, cos_b, cos_c;
	vect_t	ab, bc, ca;
	int max_edge_no;

	VSUB2(ab, b, a);
	VSUB2(bc, c, b);
	VSUB2(ca, a, c);
	mag_ab = MAGNITUDE(ab);
	mag_bc = MAGNITUDE(bc);
	mag_ca = MAGNITUDE(ca);

	/* find longest edge */
	max_len = mag_ab;
	max_edge_no = 1;

	if( mag_bc > max_len )
	{
		max_len = mag_bc;
		max_edge_no = 2;
	}

	if( mag_ca > max_len )
	{
		max_len = mag_ca;
		max_edge_no = 3;
	}

	switch( max_edge_no )
	{
		default:
		case 1:
			cos_b = (-VDOT( ab , bc ))/(mag_ab * mag_bc );
			dist_sq = mag_bc*mag_bc*( 1.0 - cos_b*cos_b);
			break;
		case 2:
			cos_c = (-VDOT( bc , ca ))/(mag_bc * mag_ca );
			dist_sq = mag_ca*mag_ca*(1.0 - cos_c*cos_c);
			break;
		case 3:
			cos_a = (-VDOT( ca , ab ))/(mag_ca * mag_ab );
			dist_sq = mag_ab*mag_ab*(1.0 - cos_a*cos_a);
			break;
	}

	if( dist_sq <= tol->dist_sq )
		return( 1 );
	else
		return( 0 );
}


/*
 *			R T _ 3 P T S _ D I S T I N C T
 *
 *  Check to see if three points are all distinct, i.e.,
 *  ensure that there is at least sqrt(dist_tol_sq) distance
 *  between every pair of points.
 *
 *  Returns (boolean) -
 *	1	If all three points are distinct
 *	0	If two or more points are closer together than dist_tol_sq
 */
int
rt_3pts_distinct( a, b, c, tol )
CONST point_t		a, b, c;
CONST struct rt_tol	*tol;
{
	vect_t	B_A;
	vect_t	C_A;
	vect_t	C_B;

	RT_CK_TOL(tol);
	VSUB2( B_A, b, a );
	if( MAGSQ( B_A ) <= tol->dist_sq )  return(0);
	VSUB2( C_A, c, a );
	if( MAGSQ( C_A ) <= tol->dist_sq )  return(0);
	VSUB2( C_B, c, b );
	if( MAGSQ( C_B ) <= tol->dist_sq )  return(0);
	return(1);
}

/*
 *			R T _ M K _ P L A N E _ 3 P T S
 *
 *  Find the equation of a plane that contains three points.
 *  Note that normal vector created is expected to point out (see vmath.h),
 *  so the vector from A to C had better be counter-clockwise
 *  (about the point A) from the vector from A to B.
 *  This follows the BRL-CAD outward-pointing normal convention, and the
 *  right-hand rule for cross products.
 *
 *
 *			C
 *	                *
 *	                |\
 *	                | \
 *	   ^     N      |  \
 *	   |      \     |   \
 *	   |       \    |    \
 *	   |C-A     \   |     \
 *	   |         \  |      \
 *	   |          \ |       \
 *	               \|        \
 *	                *---------*
 *	                A         B
 *			   ----->
 *		            B-A
 *
 *  If the points are given in the order A B C (eg, *counter*-clockwise),
 *  then the outward pointing surface normal N = (B-A) x (C-A).
 *
 *  Explicit Return -
 *	 0	OK
 *	-1	Failure.  At least two of the points were not distinct,
 *		or all three were colinear.
 *
 *  Implicit Return -
 *	plane	The plane equation is stored here.
 */
int
rt_mk_plane_3pts( plane, a, b, c, tol )
plane_t			plane;
CONST point_t		a, b, c;
CONST struct rt_tol	*tol;
{
	vect_t	B_A;
	vect_t	C_A;
	vect_t	C_B;
	register fastf_t mag;

	RT_CK_TOL(tol);

	VSUB2( B_A, b, a );
	if( MAGSQ( B_A ) <= tol->dist_sq )  return(-1);
	VSUB2( C_A, c, a );
	if( MAGSQ( C_A ) <= tol->dist_sq )  return(-1);
	VSUB2( C_B, c, b );
	if( MAGSQ( C_B ) <= tol->dist_sq )  return(-1);

	VCROSS( plane, B_A, C_A );

	/* Ensure unit length normal */
	if( (mag = MAGNITUDE(plane)) <= SMALL_FASTF )
		return(-1);	/* FAIL */
	mag = 1/mag;
	VSCALE( plane, plane, mag );

	/* Find distance from the origin to the plane */
	/* XXX Should do with pt that has smallest magnitude (closest to origin) */
	plane[3] = VDOT( plane, a );

#if 0
	/* Check to be sure that angle between A-Origin and N vect < 89 degrees */
	/* XXX Could complain for pts on axis-aligned plane, far from origin */
	mag = MAGSQ(a);
	if( mag > tol->dist_sq )  {
		/* cos(89 degrees) = 0.017452406, reciprocal is 57.29 */
		if( plane[3]/sqrt(mag) < 0.017452406 )  {
			rt_log("rt_mk_plane_3pts() WARNING: plane[3] value is suspect\n");
		}
	}
#endif
	return(0);		/* OK */
}

/*
 *			R T _ M K P O I N T _ 3 P L A N E S
 *
 *  Given the description of three planes, compute the point of intersection,
 *  if any.
 *
 *  Find the solution to a system of three equations in three unknowns:
 *
 *	Px * Ax + Py * Ay + Pz * Az = -A3;
 *	Px * Bx + Py * By + Pz * Bz = -B3;
 *	Px * Cx + Py * Cy + Pz * Cz = -C3;
 *
 *  or
 *
 *	[ Ax  Ay  Az ]   [ Px ]   [ -A3 ]
 *	[ Bx  By  Bz ] * [ Py ] = [ -B3 ]
 *	[ Cx  Cy  Cz ]   [ Pz ]   [ -C3 ]
 *
 *
 *  Explitic Return -
 *	 0	OK
 *	-1	Failure.  Intersection is a line or plane.
 *
 *  Implicit Return -
 *	pt	The point of intersection is stored here.
 */
int
rt_mkpoint_3planes( pt, a, b, c )
point_t		pt;
CONST plane_t	a, b, c;
{
	vect_t	v1, v2, v3;
	register fastf_t det;

	/* Find a vector perpendicular to both planes B and C */
	VCROSS( v1, b, c );

	/*  If that vector is perpendicular to A,
	 *  then A is parallel to either B or C, and no intersection exists.
	 *  This dot&cross product is the determinant of the matrix M.
	 *  (I suspect there is some deep significance to this!)
	 */
	det = VDOT( a, v1 );
	if( NEAR_ZERO( det, SMALL_FASTF ) )  return(-1);

	VCROSS( v2, a, c );
	VCROSS( v3, a, b );

	det = 1/det;
	pt[X] = det*(a[3]*v1[X] - b[3]*v2[X] + c[3]*v3[X]);
	pt[Y] = det*(a[3]*v1[Y] - b[3]*v2[Y] + c[3]*v3[Y]);
	pt[Z] = det*(a[3]*v1[Z] - b[3]*v2[Z] + c[3]*v3[Z]);
	return(0);
}

/*
 *			R T _ 2 L I N E 3 _ C O L I N E A R
 *
 *  Returns non-zero if the 3 lines are colinear to within tol->dist
 *  over the given distance range.
 *
 *  Range should be at least one model diameter for most applications.
 *  1e5 might be OK for a default for "vehicle sized" models.
 *
 *  The direction vectors do not need to be unit length.
 */
int
rt_2line3_colinear( p1, d1, p2, d2, range, tol )
CONST point_t		p1;
CONST vect_t		d1;
CONST point_t		p2;
CONST vect_t		d2;
double			range;
CONST struct rt_tol	*tol;
{
	fastf_t		mag1;
	fastf_t		mag2;
	point_t		tail;

	RT_CK_TOL(tol);

	if( (mag1 = MAGNITUDE(d1)) < SMALL_FASTF )  rt_bomb("rt_2line3_colinear() mag1 zero\n");
	if( (mag2 = MAGNITUDE(d2)) < SMALL_FASTF )  rt_bomb("rt_2line3_colinear() mag2 zero\n");

	/* Impose a general angular tolerance to reject "obviously" non-parallel lines */
	/* tol->para and RT_DOT_TOL are too tight a tolerance.  0.1 is 5 degrees */
	if( fabs(VDOT(d1, d2)) < 0.9 * mag1 * mag2  )  goto fail;

	/* See if start points are within tolerance of other line */
	if( rt_distsq_line3_pt3( p1, d1, p2 ) > tol->dist_sq )  goto fail;
	if( rt_distsq_line3_pt3( p2, d2, p1 ) > tol->dist_sq )  goto fail;

	VJOIN1( tail, p1, range/mag1, d1 );
	if( rt_distsq_line3_pt3( p2, d2, tail ) > tol->dist_sq )  goto fail;

	VJOIN1( tail, p2, range/mag2, d2 );
	if( rt_distsq_line3_pt3( p1, d1, tail ) > tol->dist_sq )  goto fail;

	if( rt_g.debug & DEBUG_MATH )  {
		rt_log("rt_2line3colinear(range=%g) ret=1\n",range);
	}
	return 1;
fail:
	if( rt_g.debug & DEBUG_MATH )  {
		rt_log("rt_2line3colinear(range=%g) ret=0\n",range);
	}
	return 0;
}

/*
 *			R T _ I S E C T _ L I N E 3 _ P L A N E
 *
 *  Intersect an infinite line (specified in point and direction vector form)
 *  with a plane that has an outward pointing normal.
 *  The direction vector need not have unit length.
 *
 *  Explicit Return -
 *	-2	missed (ray is outside halfspace)
 *	-1	missed (ray is inside)
 *	 0	line lies on plane
 *	 1	hit (ray is entering halfspace)
 *	 2	hit (ray is leaving)
 *
 *  Implicit Return -
 *	The value at *dist is set to the parametric distance of the intercept
 */
int
rt_isect_line3_plane( dist, pt, dir, plane, tol )
fastf_t		*dist;
CONST point_t	pt;
CONST vect_t	dir;
CONST plane_t	plane;
CONST struct rt_tol	*tol;
{
	register fastf_t	slant_factor;
	register fastf_t	norm_dist;

	RT_CK_TOL(tol);

	norm_dist = plane[3] - VDOT( plane, pt );
	slant_factor = VDOT( plane, dir );

	if( slant_factor < -SMALL_FASTF )  {
		*dist = norm_dist/slant_factor;
		return 1;			/* HIT, entering */
	} else if( slant_factor > SMALL_FASTF )  {
		*dist = norm_dist/slant_factor;
		return 2;			/* HIT, leaving */
	}

	/*
	 *  Ray is parallel to plane when dir.N == 0.
	 */
	*dist = 0;		/* sanity */
	if( norm_dist < -tol->dist )
		return -2;	/* missed, outside */
	if( norm_dist > tol->dist )
		return -1;	/* missed, inside */
	return 0;		/* Ray lies in the plane */
}

/*
 *			R T _ I S E C T _ 2 P L A N E S
 *
 *  Given two planes, find the line of intersection between them,
 *  if one exists.
 *  The line of intersection is returned in parametric line
 *  (point & direction vector) form.
 *
 *  In order that all the geometry under consideration be in "front"
 *  of the ray, it is necessary to pass the minimum point of the model
 *  RPP.  If this convention is unnecessary, just pass (0,0,0) as rpp_min.
 *
 *  Explicit Return -
 *	 0	OK, line of intersection stored in `pt' and `dir'.
 *	-1	FAIL, planes are identical (co-planar)
 *	-2	FAIL, planes are parallel and distinct
 *	-3	FAIL, unable to find line of intersection
 *
 *  Implicit Returns -
 *	pt	Starting point of line of intersection
 *	dir	Direction vector of line of intersection (unit length)
 */
int
rt_isect_2planes( pt, dir, a, b, rpp_min, tol )
point_t		pt;
vect_t		dir;
CONST plane_t	a;
CONST plane_t	b;
CONST vect_t	rpp_min;
CONST struct rt_tol	*tol;
{
	LOCAL vect_t		abs_dir;
	LOCAL plane_t		pl;
	int			i;

	if( (i = rt_coplanar( a, b, tol )) != 0 )  {
		if( i > 0 )
			return(-1);	/* FAIL -- coplanar */
		return(-2);		/* FAIL -- parallel & distinct */
	}

	/* Direction vector for ray is perpendicular to both plane normals */
	VCROSS( dir, a, b );
	VUNITIZE( dir );		/* safety */

	/*
	 *  Select an axis-aligned plane which has it's normal pointing
	 *  along the same axis as the largest magnitude component of
	 *  the direction vector.
	 *  If the largest magnitude component is negative, reverse the
	 *  direction vector, so that model is "in front" of start point.
	 */
	abs_dir[X] = (dir[X] >= 0) ? dir[X] : (-dir[X]);
	abs_dir[Y] = (dir[Y] >= 0) ? dir[Y] : (-dir[Y]);
	abs_dir[Z] = (dir[Z] >= 0) ? dir[Z] : (-dir[Z]);

	if( abs_dir[X] >= abs_dir[Y] )  {
		if( abs_dir[X] >= abs_dir[Z] )  {
			VSET( pl, 1, 0, 0 );	/* X */
			pl[3] = rpp_min[X];
			if( dir[X] < 0 )  {
				VREVERSE( dir, dir );
			}
		} else {
			VSET( pl, 0, 0, 1 );	/* Z */
			pl[3] = rpp_min[Z];
			if( dir[Z] < 0 )  {
				VREVERSE( dir, dir );
			}
		}
	} else {
		if( abs_dir[Y] >= abs_dir[Z] )  {
			VSET( pl, 0, 1, 0 );	/* Y */
			pl[3] = rpp_min[Y];
			if( dir[Y] < 0 )  {
				VREVERSE( dir, dir );
			}
		} else {
			VSET( pl, 0, 0, 1 );	/* Z */
			pl[3] = rpp_min[Z];
			if( dir[Z] < 0 )  {
				VREVERSE( dir, dir );
			}
		}
	}

	/* Intersection of the 3 planes defines ray start point */
	if( rt_mkpoint_3planes( pt, pl, a, b ) < 0 )
		return(-3);	/* FAIL -- no intersection */

	return(0);		/* OK */
}

/*
 *			R T _ I S E C T _ L I N E 2 _ L I N E 2
 *
 *  Intersect two lines, each in given in parametric form:
 *
 *	X = P + t * D
 *  and
 *	X = A + u * C
 *
 *  While the parametric form is usually used to denote a ray
 *  (ie, positive values of the parameter only), in this case
 *  the full line is considered.
 *
 *  The direction vectors C and D need not have unit length.
 *
 *  Explicit Return -
 *	-1	no intersection, lines are parallel.
 *	 0	lines are co-linear
 *			dist[0] gives distance from P to A,
 *			dist[1] gives distance from P to (A+C) [not same as below]
 *	 1	intersection found (t and u returned)
 *			dist[0] gives distance from P to isect,
 *			dist[1] gives distance from A to isect.
 *
 *  Implicit Returns -
 *	When explicit return > 0, dist[0] and dist[1] are the
 *	line parameters of the intersection point on the 2 rays.
 *	The actual intersection coordinates can be found by
 *	substituting either of these into the original ray equations.
 *
 *  Note that for lines which are very nearly parallel, but not
 *  quite parallel enough to have the determinant go to "zero",
 *  the intersection can turn up in surprising places.
 *  (e.g. when det=1e-15 and det1=5.5e-17, t=0.5)
 */
int
rt_isect_line2_line2( dist, p, d, a, c, tol )
fastf_t			*dist;			/* dist[2] */
CONST point_t		p;
CONST vect_t		d;
CONST point_t		a;
CONST vect_t		c;
CONST struct rt_tol	*tol;
{
	fastf_t			hx, hy;		/* A - P */
	register fastf_t	det;
	register fastf_t	det1;
	vect_t			unit_d;
	vect_t			unit_c;
	vect_t			unit_h;
	fastf_t			dot;
	int			parallel;
	int			parallel1;

	RT_CK_TOL(tol);
	if( rt_g.debug & DEBUG_MATH )  {
		rt_log("rt_isect_line2_line2() p=(%g,%g), d=(%g,%g)\n\t\t\ta=(%g,%g), c=(%g,%g)\n",
			V2ARGS(p), V2ARGS(d), V2ARGS(a), V2ARGS(c) );
	}

	/*
	 *  From the two components q and r, form a system
	 *  of 2 equations in 2 unknowns.
	 *  Solve for t and u in the system:
	 *
	 *	Px + t * Dx = Ax + u * Cx
	 *	Py + t * Dy = Ay + u * Cy
	 *  or
	 *	t * Dx - u * Cx = Ax - Px
	 *	t * Dy - u * Cy = Ay - Py
	 *
	 *  Let H = A - P, resulting in:
	 *
	 *	t * Dx - u * Cx = Hx
	 *	t * Dy - u * Cy = Hy
	 *
	 *  or
	 *
	 *	[ Dx  -Cx ]   [ t ]   [ Hx ]
	 *	[         ] * [   ] = [    ]
	 *	[ Dy  -Cy ]   [ u ]   [ Hy ]
	 *
	 *  This system can be solved by direct substitution, or by
	 *  finding the determinants by Cramers rule:
	 *
	 *	             [ Dx  -Cx ]
	 *	det(M) = det [         ] = -Dx * Cy + Cx * Dy
	 *	             [ Dy  -Cy ]
	 *
	 *  If det(M) is zero, then the lines are parallel (perhaps colinear).
	 *  Otherwise, exactly one solution exists.
	 */
	det = c[X] * d[Y] - d[X] * c[Y];

	/*
	 *  det(M) is non-zero, so there is exactly one solution.
	 *  Using Cramer's rule, det1(M) replaces the first column
	 *  of M with the constant column vector, in this case H.
	 *  Similarly, det2(M) replaces the second column.
	 *  Computation of the determinant is done as before.
	 *
	 *  Now,
	 *
	 *	                  [ Hx  -Cx ]
	 *	              det [         ]
	 *	    det1(M)       [ Hy  -Cy ]   -Hx * Cy + Cx * Hy
	 *	t = ------- = --------------- = ------------------
	 *	     det(M)       det(M)        -Dx * Cy + Cx * Dy
	 *
	 *  and
	 *
	 *	                  [ Dx   Hx ]
	 *	              det [         ]
	 *	    det2(M)       [ Dy   Hy ]    Dx * Hy - Hx * Dy
	 *	u = ------- = --------------- = ------------------
	 *	     det(M)       det(M)        -Dx * Cy + Cx * Dy
	 */
	hx = a[X] - p[X];
	hy = a[Y] - p[Y];
	det1 = (c[X] * hy - hx * c[Y]);

	unit_d[0] = d[0];
	unit_d[1] = d[1];
	unit_d[2] = 0.0;
	VUNITIZE( unit_d );
	unit_c[0] = c[0];
	unit_c[1] = c[1];
	unit_c[2] = 0.0;
	VUNITIZE( unit_c );
	unit_h[0] = hx;
	unit_h[1] = hy;
	unit_h[2] = 0.0;
	VUNITIZE( unit_h );

	if( fabs( VDOT( unit_d, unit_c ) ) >= tol->para )
		parallel = 1;
	else
		parallel = 0;

	if( fabs( VDOT( unit_h, unit_c ) ) >= tol->para )
		parallel1 = 1;
	else
		parallel1 = 0;

	/* XXX This zero tolerance here should actually be
	 * XXX determined by something like
	 * XXX max(c[X], c[Y], d[X], d[Y]) / MAX_FASTF_DYNAMIC_RANGE
	 * XXX In any case, nothing smaller than 1e-16
	 */
#define DETERMINANT_TOL		1.0e-14		/* XXX caution on non-IEEE machines */
	if( parallel || NEAR_ZERO( det, DETERMINANT_TOL ) )  {
		/* Lines are parallel */
		if( !parallel1 && !NEAR_ZERO( det1, DETERMINANT_TOL ) )  {
			/* Lines are NOT co-linear, just parallel */
			if( rt_g.debug & DEBUG_MATH )  {
				rt_log("\tparallel, not co-linear.  det=%e, det1=%g\n", det, det1);
			}
			return -1;	/* parallel, no intersection */
		}

		/*
		 *  Lines are co-linear.
		 *  Determine t as distance from P to A.
		 *  Determine u as distance from P to (A+C).  [special!]
		 *  Use largest direction component, for numeric stability
		 *  (and avoiding division by zero).
		 */
		if( fabs(d[X]) >= fabs(d[Y]) )  {
			dist[0] = hx/d[X];
			dist[1] = (hx + c[X]) / d[X];
		} else {
			dist[0] = hy/d[Y];
			dist[1] = (hy + c[Y]) / d[Y];
		}
		if( rt_g.debug & DEBUG_MATH )  {
			rt_log("\tcolinear, t = %g, u = %g\n", dist[0], dist[1] );
		}
		return 0;	/* Lines co-linear */
	}
	if( rt_g.debug & DEBUG_MATH )  {
		/* XXX This print is temporary */
rt_log("\thx=%g, hy=%g, det=%g, det1=%g, det2=%g\n", hx, hy, det, det1, (d[X] * hy - hx * d[Y]) );
	}
	det = 1/det;
	dist[0] = det * det1;
	dist[1] = det * (d[X] * hy - hx * d[Y]);
	if( rt_g.debug & DEBUG_MATH )  {
		rt_log("\tintersection, t = %g, u = %g\n", dist[0], dist[1] );
	}

#if 0
	/* XXX This isn't any good.
	 * 1)  Sometimes, dist[0] is very large.  Only caller can tell whether
	 *     that is useful to him or not.
	 * 2)  Sometimes, the difference between the two hit points is
	 *     not much more than tol->dist.  Either hit point is perfectly
	 *     good;  the caller just needs to be careful and not use *both*.
	 */
	{
		point_t		hit1, hit2;
		vect_t		diff;
		fastf_t		dist_sq;

		VJOIN1_2D( hit1, p, dist[0], d );
		VJOIN1_2D( hit2, a, dist[1], c );
		VSUB2_2D( diff, hit1, hit2 );
		dist_sq = MAGSQ_2D( diff );
		if( dist_sq >= tol->dist_sq )  {
			if( rt_g.debug & DEBUG_MATH || dist_sq < 100*tol->dist_sq )  {
				rt_log("rt_isect_line2_line2(): dist=%g >%g, inconsistent solution, hit1=(%g,%g), hit2=(%g,%g)\n",
					sqrt(dist_sq), tol->dist,
					hit1[X], hit1[Y], hit2[X], hit2[Y]);
			}
			return -2;	/* s/b -1? */
		}
	}
#endif

	return 1;		/* Intersection found */
}

/*
 *			R T _ I S E C T _ L I N E 2 _ L S E G 2
 *
 *  Intersect a line in parametric form:
 *
 *	X = P + t * D
 *
 *  with a line segment defined by two distinct points A and B=(A+C).
 *
 *  XXX probably should take point B, not vector C.  Sigh.
 *
 *  Explicit Return -
 *	-4	A and B are not distinct points
 *	-3	Lines do not intersect
 *	-2	Intersection exists, but outside segemnt, < A
 *	-1	Intersection exists, but outside segment, > B
 *	 0	Lines are co-linear (special meaning of dist[1])
 *	 1	Intersection at vertex A
 *	 2	Intersection at vertex B (A+C)
 *	 3	Intersection between A and B
 *
 *  Implicit Returns -
 *	t	When explicit return >= 0, t is the parameter that describes
 *		the intersection of the line and the line segment.
 *		The actual intersection coordinates can be found by
 *		solving P + t * D.  However, note that for return codes
 *		1 and 2 (intersection exactly at a vertex), it is
 *		strongly recommended that the original values passed in
 *		A or B are used instead of solving P + t * D, to prevent
 *		numeric error from creeping into the position of
 *		the endpoints.
 */
int
rt_isect_line2_lseg2( dist, p, d, a, c, tol )
fastf_t			*dist;		/* dist[2] */
CONST point_t		p;
CONST vect_t		d;
CONST point_t		a;
CONST vect_t		c;
CONST struct rt_tol	*tol;
{
	register fastf_t f;
	fastf_t		ctol;
	int		ret;
	point_t		b;

	RT_CK_TOL(tol);
	if( rt_g.debug & DEBUG_MATH )  {
		rt_log("rt_isect_line2_lseg2() p=(%g,%g), pdir=(%g,%g)\n\t\t\ta=(%g,%g), adir=(%g,%g)\n",
			V2ARGS(p), V2ARGS(d), V2ARGS(a), V2ARGS(c) );
	}

	/*
	 *  To keep the values of u between 0 and 1,
	 *  C should NOT be scaled to have unit length.
	 *  However, it is a good idea to make sure that
	 *  C is a non-zero vector, (ie, that A and B are distinct).
	 */
	if( (ctol = MAGSQ_2D(c)) <= tol->dist_sq )  {
		ret = -4;		/* points A and B are not distinct */
		goto out;
	}

	/*
	 *  Detecting colinearity is difficult, and very very important.
	 *  As a first step, check to see if both points A and B lie
	 *  within tolerance of the line.  If so, then the line segment AC
	 *  is ON the line.
	 */
	VADD2_2D( b, a, c );
	if( rt_distsq_line2_point2( p, d, a ) <= tol->dist_sq  &&
	    (ctol=rt_distsq_line2_point2( p, d, b )) <= tol->dist_sq )  {
		if( rt_g.debug & DEBUG_MATH )  {
rt_log("b=(%g, %g), b_dist_sq=%g\n", V2ARGS(b), ctol);
			rt_log("rt_isect_line2_lseg2() pts A and B within tol of line\n");
		}
	    	/* Find the parametric distance along the ray */
	    	dist[0] = rt_dist_pt2_along_line2( p, d, a );
	    	dist[1] = rt_dist_pt2_along_line2( p, d, b );
	    	ret = 0;		/* Colinear */
	    	goto out;
	}

	if( (ret = rt_isect_line2_line2( dist, p, d, a, c, tol )) < 0 )  {
		/* Lines are parallel, non-colinear */
		ret = -3;		/* No intersection found */
		goto out;
	}
	if( ret == 0 )  {
		fastf_t	dtol;
		/*  Lines are colinear */
		/*  If P within tol of either endpoint (0, 1), make exact. */
		dtol = tol->dist / sqrt(MAGSQ_2D(d));
		if( rt_g.debug & DEBUG_MATH )  {
			rt_log("rt_isect_line2_lseg2() dtol=%g, dist[0]=%g, dist[1]=%g\n",
				dtol, dist[0], dist[1]);
		}
		if( dist[0] > -dtol && dist[0] < dtol )  dist[0] = 0;
		else if( dist[0] > 1-dtol && dist[0] < 1+dtol ) dist[0] = 1;

		if( dist[1] > -dtol && dist[1] < dtol )  dist[1] = 0;
		else if( dist[1] > 1-dtol && dist[1] < 1+dtol ) dist[1] = 1;
		ret = 0;		/* Colinear */
		goto out;
	}

	/*
	 *  The two lines are claimed to intersect at a point.
	 *  First, validate that hit point represented by dist[0]
	 *  is in fact on and between A--B.
	 *  (Nearly parallel lines can result in odd situations here).
	 *  The performance hit of doing this is vastly preferable
	 *  to returning wrong answers.  Know a faster algorithm?
	 */
	{
		fastf_t		ab_dist = 0;
		point_t		hit_pt;
		point_t		hit2;

		VJOIN1_2D( hit_pt, p, dist[0], d );
		VJOIN1_2D( hit2, a, dist[1], c );
		/* Check both hit point value calculations */
		if( rt_pt2_pt2_equal( a, hit_pt, tol ) ||
		    rt_pt2_pt2_equal( a, hit2, tol ) )  {
			dist[1] = 0;
			ret = 1;	/* Intersect is at A */
		}
		if( rt_pt2_pt2_equal( b, hit_pt, tol ) ||
		    rt_pt2_pt2_equal( b, hit_pt, tol ) )  {
			dist[1] = 1;
			ret = 2;	/* Intersect is at B */
		}

		ret = rt_isect_pt2_lseg2( &ab_dist, a, b, hit_pt, tol );
		if( rt_g.debug & DEBUG_MATH )  {
			/* XXX This is temporary */
			V2PRINT("a", a);
			V2PRINT("hit", hit_pt);
			V2PRINT("b", b);
rt_log("rt_isect_pt2_lseg2() hit2d=(%g,%g) ab_dist=%g, ret=%d\n", hit_pt[X], hit_pt[Y], ab_dist, ret);
rt_log("\tother hit2d=(%g,%g)\n", hit2[X], hit2[Y] );
		}
		if( ret <= 0 )  {
			if( ab_dist < 0 )  {
				ret = -2;	/* Intersection < A */
			} else {
				ret = -1;	/* Intersection >B */
			}
			goto out;
		}
		if( ret == 1 )  {
			dist[1] = 0;
			ret = 1;	/* Intersect is at A */
			goto out;
		}
		if( ret == 2 )  {
			dist[1] = 1;
			ret = 2;	/* Intersect is at B */
			goto out;
		}
		/* ret == 3, hit_pt is between A and B */

		if( !rt_between( a[X], hit_pt[X], b[X], tol ) ||
		    !rt_between( a[Y], hit_pt[Y], b[Y], tol ) ) {
		    	rt_bomb("rt_isect_line2_lseg2() hit_pt not between A and B!\n");
		}
	}

	/*
	 *  If the dist[1] parameter is outside the range (0..1),
	 *  reject the intersection, because it falls outside
	 *  the line segment A--B.
	 *
	 *  Convert the tol->dist into allowable deviation in terms of
	 *  (0..1) range of the parameters.
	 */
	ctol = tol->dist / sqrt(ctol);
	if( rt_g.debug & DEBUG_MATH )  {
		rt_log("rt_isect_line2_lseg2() ctol=%g, dist[1]=%g\n", ctol, dist[1]);
	}
	if( dist[1] < -ctol )  {
		ret = -2;		/* Intersection < A */
		goto out;
	}
	if( (f=(dist[1]-1)) > ctol )  {
		ret = -1;		/* Intersection > B */
		goto out;
	}

	/* Check for ctoly intersection with one of the verticies */
	if( dist[1] < ctol )  {
		dist[1] = 0;
		ret = 1;		/* Intersection at A */
		goto out;
	}
	if( f >= -ctol )  {
		dist[1] = 1;
		ret = 2;		/* Intersection at B */
		goto out;
	}
	ret = 3;			/* Intersection between A and B */
out:
	if( rt_g.debug & DEBUG_MATH )  {
		rt_log("rt_isect_line2_lseg2() dist[0]=%g, dist[1]=%g, ret=%d\n",
			dist[0], dist[1], ret);
	}
	return ret;
}

/*
 *			R T _ I S E C T _ L S E G 2  _ L S E G 2
 *
 *  Intersect two 2D line segments, defined by two points and two vectors.
 *  The vectors are unlikely to be unit length.
 *
 *  Explicit Return -
 *	-2	missed (line segments are parallel)
 *	-1	missed (colinear and non-overlapping)
 *	 0	hit (line segments colinear and overlapping)
 *	 1	hit (normal intersection)
 *
 *  Implicit Return -
 *	The value at dist[] is set to the parametric distance of the intercept
 *	dist[0] is parameter along p, range 0 to 1, to intercept.
 *	dist[1] is parameter along q, range 0 to 1, to intercept.
 *	If within distance tolerance of the endpoints, these will be
 *	exactly 0.0 or 1.0, to ease the job of caller.
 *
 *  Special note:  when return code is "0" for co-linearity, dist[1] has
 *  an alternate interpretation:  it's the parameter along p (not q)
 *  which takes you from point p to the point (q + qdir), i.e., it's
 *  the endpoint of the q linesegment, since in this case there may be
 *  *two* intersections, if q is contained within span p to (p + pdir).
 *  And either may be -10 if the point is outside the span.
 */
int
rt_isect_lseg2_lseg2( dist, p, pdir, q, qdir, tol )
fastf_t		*dist;
CONST point_t	p;
CONST vect_t	pdir;
CONST point_t	q;
CONST vect_t	qdir;
struct rt_tol	*tol;
{
	fastf_t	ptol, qtol;	/* length in parameter space == tol->dist */
	int	status;

	RT_CK_TOL(tol);
	if( rt_g.debug & DEBUG_MATH )  {
		rt_log("rt_isect_lseg2_lseg2() p=(%g,%g), pdir=(%g,%g)\n\t\tq=(%g,%g), qdir=(%g,%g)\n",
			V2ARGS(p), V2ARGS(pdir), V2ARGS(q), V2ARGS(qdir) );
	}

	status = rt_isect_line2_line2( dist, p, pdir, q, qdir, tol );
	if( status < 0 )  {
		/* Lines are parallel, non-colinear */
		return -1;	/* No intersection */
	}
	if( status == 0 )  {
		int	nogood = 0;
		/* Lines are colinear */
		/*  If P within tol of either endpoint (0, 1), make exact. */
		ptol = tol->dist / sqrt( MAGSQ_2D(pdir) );
		if( rt_g.debug & DEBUG_MATH )  {
			rt_log("ptol=%g\n", ptol);
		}
		if( dist[0] > -ptol && dist[0] < ptol )  dist[0] = 0;
		else if( dist[0] > 1-ptol && dist[0] < 1+ptol ) dist[0] = 1;

		if( dist[1] > -ptol && dist[1] < ptol )  dist[1] = 0;
		else if( dist[1] > 1-ptol && dist[1] < 1+ptol ) dist[1] = 1;

		if( dist[1] < 0 || dist[1] > 1 )  nogood = 1;
		if( dist[0] < 0 || dist[0] > 1 )  nogood++;
		if( nogood >= 2 )
			return -1;	/* colinear, but not overlapping */
		if( rt_g.debug & DEBUG_MATH )  {
			rt_log("  HIT colinear!\n");
		}
		return 0;		/* colinear and overlapping */
	}
	/* Lines intersect */
	/*  If within tolerance of an endpoint (0, 1), make exact. */
	ptol = tol->dist / sqrt( MAGSQ_2D(pdir) );
	if( dist[0] > -ptol && dist[0] < ptol )  dist[0] = 0;
	else if( dist[0] > 1-ptol && dist[0] < 1+ptol ) dist[0] = 1;

	qtol = tol->dist / sqrt( MAGSQ_2D(qdir) );
	if( dist[1] > -qtol && dist[1] < qtol )  dist[1] = 0;
	else if( dist[1] > 1-qtol && dist[1] < 1+qtol ) dist[1] = 1;

	if( rt_g.debug & DEBUG_MATH )  {
		rt_log("ptol=%g, qtol=%g\n", ptol, qtol);
	}
	if( dist[0] < 0 || dist[0] > 1 || dist[1] < 0 || dist[1] > 1 ) {
		if( rt_g.debug & DEBUG_MATH )  {
			rt_log("  MISS\n");
		}
		return -1;		/* missed */
	}
	if( rt_g.debug & DEBUG_MATH )  {
		rt_log("  HIT!\n");
	}
	return 1;			/* hit, normal intersection */
}

/*
 *			R T _ I S E C T _ L S E G 3  _ L S E G 3
 *
 *  Intersect two 3D line segments, defined by two points and two vectors.
 *  The vectors are unlikely to be unit length.
 *
 *  Explicit Return -
 *	-2	missed (line segments are parallel)
 *	-1	missed (colinear and non-overlapping)
 *	 0	hit (line segments colinear and overlapping)
 *	 1	hit (normal intersection)
 *
 *  Implicit Return -
 *	The value at dist[] is set to the parametric distance of the intercept
 *	dist[0] is parameter along p, range 0 to 1, to intercept.
 *	dist[1] is parameter along q, range 0 to 1, to intercept.
 *	If within distance tolerance of the endpoints, these will be
 *	exactly 0.0 or 1.0, to ease the job of caller.
 *
 *  Special note:  when return code is "0" for co-linearity, dist[1] has
 *  an alternate interpretation:  it's the parameter along p (not q)
 *  which takes you from point p to the point (q + qdir), i.e., it's
 *  the endpoint of the q linesegment, since in this case there may be
 *  *two* intersections, if q is contained within span p to (p + pdir).
 *  And either may be -10 if the point is outside the span.
 */
int
rt_isect_lseg3_lseg3( dist, p, pdir, q, qdir, tol )
fastf_t		*dist;
CONST point_t	p;
CONST vect_t	pdir;
CONST point_t	q;
CONST vect_t	qdir;
struct rt_tol	*tol;
{
	fastf_t	ptol, qtol;	/* length in parameter space == tol->dist */
	fastf_t	pmag, qmag;
	int	status;

	RT_CK_TOL(tol);
	if( rt_g.debug & DEBUG_MATH )  {
		rt_log("rt_isect_lseg3_lseg3() p=(%g,%g), pdir=(%g,%g)\n\t\tq=(%g,%g), qdir=(%g,%g)\n",
			V2ARGS(p), V2ARGS(pdir), V2ARGS(q), V2ARGS(qdir) );
	}

	status = rt_isect_line3_line3( &dist[0], &dist[1], p, pdir, q, qdir, tol );
	if( status < 0 )  {
		/* Lines are parallel, non-colinear */
		return -1;	/* No intersection */
	}
	pmag = MAGNITUDE(pdir);
	if( pmag < SMALL_FASTF )
		rt_bomb("rt_isect_lseg3_lseg3: |p|=0\n");
	if( status == 0 )  {
		int	nogood = 0;
		/* Lines are colinear */
		/*  If P within tol of either endpoint (0, 1), make exact. */
		ptol = tol->dist / pmag;
		if( rt_g.debug & DEBUG_MATH )  {
			rt_log("ptol=%g\n", ptol);
		}
		if( dist[0] > -ptol && dist[0] < ptol )  dist[0] = 0;
		else if( dist[0] > 1-ptol && dist[0] < 1+ptol ) dist[0] = 1;

		if( dist[1] > -ptol && dist[1] < ptol )  dist[1] = 0;
		else if( dist[1] > 1-ptol && dist[1] < 1+ptol ) dist[1] = 1;

		if( dist[1] < 0 || dist[1] > 1 )  nogood = 1;
		if( dist[0] < 0 || dist[0] > 1 )  nogood++;
		if( nogood >= 2 )
			return -1;	/* colinear, but not overlapping */
		if( rt_g.debug & DEBUG_MATH )  {
			rt_log("  HIT colinear!\n");
		}
		return 0;		/* colinear and overlapping */
	}
	/* Lines intersect */
	/*  If within tolerance of an endpoint (0, 1), make exact. */
	ptol = tol->dist / pmag;
	if( dist[0] > -ptol && dist[0] < ptol )  dist[0] = 0;
	else if( dist[0] > 1-ptol && dist[0] < 1+ptol ) dist[0] = 1;

	qmag = MAGNITUDE(qdir);
	if( qmag < SMALL_FASTF )
		rt_bomb("rt_isect_lseg3_lseg3: |q|=0\n");
	qtol = tol->dist / qmag;
	if( dist[1] > -qtol && dist[1] < qtol )  dist[1] = 0;
	else if( dist[1] > 1-qtol && dist[1] < 1+qtol ) dist[1] = 1;

	if( rt_g.debug & DEBUG_MATH )  {
		rt_log("ptol=%g, qtol=%g\n", ptol, qtol);
	}
	if( dist[0] < 0 || dist[0] > 1 || dist[1] < 0 || dist[1] > 1 ) {
		if( rt_g.debug & DEBUG_MATH )  {
			rt_log("  MISS\n");
		}
		return -1;		/* missed */
	}
	if( rt_g.debug & DEBUG_MATH )  {
		rt_log("  HIT!\n");
	}
	return 1;			/* hit, normal intersection */
}

/*
 *			R T _ I S E C T _ L I N E 3 _ L I N E 3
 *
 *  Intersect two lines, each in given in parametric form:
 *
 *	X = P + t * D
 *  and
 *	X = A + u * C
 *
 *  While the parametric form is usually used to denote a ray
 *  (ie, positive values of the parameter only), in this case
 *  the full line is considered.
 *
 *  The direction vectors C and D need not have unit length.
 *
 *  Explicit Return -
 *	-2	no intersection, lines are parallel.
 *	-1	no intersection
 *	 0	lines are co-linear (t returned for u=0 to give distance to A)
 *	 1	intersection found (t and u returned)
 *
 *  Implicit Returns -
 *
 *	t,u	When explicit return >= 0, t and u are the
 *		line parameters of the intersection point on the 2 rays.
 *		The actual intersection coordinates can be found by
 *		substituting either of these into the original ray equations.
 *
 * XXX It would be sensible to change the t,u pair to dist[2].
 */
int
rt_isect_line3_line3( t, u, p, d, a, c, tol )
fastf_t			*t;
fastf_t			*u;
CONST point_t		p;
CONST vect_t		d;
CONST point_t		a;
CONST vect_t		c;
CONST struct rt_tol	*tol;
{
	LOCAL vect_t		n;
	LOCAL vect_t		abs_n;
	LOCAL vect_t		h;
	register fastf_t	det;
	register fastf_t	det1;
	register short int	q,r,s;

	RT_CK_TOL(tol);

	/*
	 *  Any intersection will occur in the plane with surface
	 *  normal D cross C, which may not have unit length.
	 *  The plane containing the two lines will be a constant
	 *  distance from a plane with the same normal that contains
	 *  the origin.  Therfore, the projection of any point on the
	 *  plane along N has the same length.
	 *  Verify that this holds for P and A.
	 *  If N dot P != N dot A, there is no intersection, because
	 *  P and A must lie on parallel planes that are different
	 *  distances from the origin.
	 */
	VCROSS( n, d, c );
	det = VDOT( n, p ) - VDOT( n, a );
	if( !NEAR_ZERO( det, tol->dist ) )  {
		return(-1);		/* No intersection */
	}

	if( NEAR_ZERO( MAGSQ( n ) , SMALL_FASTF ) )
	{
		vect_t a_to_p;

		/* lines are parallel, must find another way to get normal vector */
		VSUB2( a_to_p , p , a );
		VCROSS( n , a_to_p , d );

		/* if normal still has zero length, then lines are parallel and collinear
		 * and the following code will work OK */
	}

	/*
	 *  Solve for t and u in the system:
	 *
	 *	Px + t * Dx = Ax + u * Cx
	 *	Py + t * Dy = Ay + u * Cy
	 *	Pz + t * Dz = Az + u * Cz
	 *
	 *  This system is over-determined, having 3 equations in 2 unknowns.
	 *  However, the intersection problem is really only a 2-dimensional
	 *  problem, being located in the surface of a plane.
	 *  Therefore, the "least important" of these equations can
	 *  be initially ignored, leaving a system of 2 equations in
	 *  2 unknowns.
	 *
	 *  Find the component of N with the largest magnitude.
	 *  This component will have the least effect on the parameters
	 *  in the system, being most nearly perpendicular to the plane.
	 *  Denote the two remaining components by the
	 *  subscripts q and r, rather than x,y,z.
	 *  Subscript s is the smallest component, used for checking later.
	 */
	abs_n[X] = (n[X] >= 0) ? n[X] : (-n[X]);
	abs_n[Y] = (n[Y] >= 0) ? n[Y] : (-n[Y]);
	abs_n[Z] = (n[Z] >= 0) ? n[Z] : (-n[Z]);
	if( abs_n[X] >= abs_n[Y] )  {
		if( abs_n[X] >= abs_n[Z] )  {
			/* X is largest in magnitude */
			q = Y;
			r = Z;
			s = X;
		} else {
			/* Z is largest in magnitude */
			q = X;
			r = Y;
			s = Z;
		}
	} else {
		if( abs_n[Y] >= abs_n[Z] )  {
			/* Y is largest in magnitude */
			q = X;
			r = Z;
			s = Y;
		} else {
			/* Z is largest in magnitude */
			q = X;
			r = Y;
			s = Z;
		}
	}

#if 0
	/* XXX Use rt_isect_line2_line2() here */
	/* move the 2d vectors around */
	rt_isect_line2_line2( &dist, p, d, a, c, tol );
#endif

	/*
	 *  From the two components q and r, form a system
	 *  of 2 equations in 2 unknowns:
	 *
	 *	Pq + t * Dq = Aq + u * Cq
	 *	Pr + t * Dr = Ar + u * Cr
	 *  or
	 *	t * Dq - u * Cq = Aq - Pq
	 *	t * Dr - u * Cr = Ar - Pr
	 *
	 *  Let H = A - P, resulting in:
	 *
	 *	t * Dq - u * Cq = Hq
	 *	t * Dr - u * Cr = Hr
	 *
	 *  or
	 *
	 *	[ Dq  -Cq ]   [ t ]   [ Hq ]
	 *	[         ] * [   ] = [    ]
	 *	[ Dr  -Cr ]   [ u ]   [ Hr ]
	 *
	 *  This system can be solved by direct substitution, or by
	 *  finding the determinants by Cramers rule:
	 *
	 *	             [ Dq  -Cq ]
	 *	det(M) = det [         ] = -Dq * Cr + Cq * Dr
	 *	             [ Dr  -Cr ]
	 *
	 *  If det(M) is zero, then the lines are parallel (perhaps colinear).
	 *  Otherwise, exactly one solution exists.
	 */
	VSUB2( h, a, p );
	det = c[q] * d[r] - d[q] * c[r];
	det1 = (c[q] * h[r] - h[q] * c[r]);		/* see below */
	/* XXX This should be no smaller than 1e-16.  See rt_isect_line2_line2 for details */
	if( NEAR_ZERO( det, DETERMINANT_TOL ) )  {
		/* Lines are parallel */
		if( !NEAR_ZERO( det1, DETERMINANT_TOL ) )  {
			/* Lines are NOT co-linear, just parallel */
			return -2;	/* parallel, no intersection */
		}

		/* Lines are co-linear */
		/* Compute t for u=0 as a convenience to caller */
		*u = 0;
		/* Use largest direction component */
		if( fabs(d[q]) >= fabs(d[r]) )  {
			*t = h[q]/d[q];
		} else {
			*t = h[r]/d[r];
		}
		return(0);	/* Lines co-linear */
	}

	/*
	 *  det(M) is non-zero, so there is exactly one solution.
	 *  Using Cramer's rule, det1(M) replaces the first column
	 *  of M with the constant column vector, in this case H.
	 *  Similarly, det2(M) replaces the second column.
	 *  Computation of the determinant is done as before.
	 *
	 *  Now,
	 *
	 *	                  [ Hq  -Cq ]
	 *	              det [         ]
	 *	    det1(M)       [ Hr  -Cr ]   -Hq * Cr + Cq * Hr
	 *	t = ------- = --------------- = ------------------
	 *	     det(M)       det(M)        -Dq * Cr + Cq * Dr
	 *
	 *  and
	 *
	 *	                  [ Dq   Hq ]
	 *	              det [         ]
	 *	    det2(M)       [ Dr   Hr ]    Dq * Hr - Hq * Dr
	 *	u = ------- = --------------- = ------------------
	 *	     det(M)       det(M)        -Dq * Cr + Cq * Dr
	 */
	det = 1/det;
	*t = det * det1;
	*u = det * (d[q] * h[r] - h[q] * d[r]);

	/*
	 *  Check that these values of t and u satisfy the 3rd equation
	 *  as well!
	 *  XXX It isn't clear that "det" is exactly a model-space distance.
	 */
	det = *t * d[s] - *u * c[s] - h[s];
	if( !NEAR_ZERO( det, tol->dist ) )  {
		/* XXX This tolerance needs to be much less loose than
		 * XXX SQRT_SMALL_FASTF.  What about DETERMINANT_TOL?
		 */
		/* Inconsistent solution, lines miss each other */
		return(-1);
	}

	/*  To prevent errors, check the answer.
	 *  Not returning bogus results to our caller is worth the extra time.
	 */
	{
		point_t		hit1, hit2;

		VJOIN1( hit1, p, *t, d );
		VJOIN1( hit2, a, *u, c );
		if( !rt_pt3_pt3_equal( hit1, hit2, tol ) )  {
/*			rt_log("rt_isect_line3_line3(): BOGUS RESULT, hit1=(%g,%g,%g), hit2=(%g,%g,%g)\n",
				hit1[X], hit1[Y], hit1[Z], hit2[X], hit2[Y], hit2[Z]); */
			return -1;
		}
	}

	return(1);		/* Intersection found */
}

/*
 *			R T _ I S E C T _ L I N E _ L S E G
 *
 *  Intersect a line in parametric form:
 *
 *	X = P + t * D
 *
 *  with a line segment defined by two distinct points A and B.
 *
 *  Explicit Return -
 *	-4	A and B are not distinct points
 *	-3	Intersection exists, < A (t is returned)
 *	-2	Intersection exists, > B (t is returned)
 *	-1	Lines do not intersect
 *	 0	Lines are co-linear (t for A is returned)
 *	 1	Intersection at vertex A
 *	 2	Intersection at vertex B
 *	 3	Intersection between A and B
 *
 *  Implicit Returns -
 *	t	When explicit return >= 0, t is the parameter that describes
 *		the intersection of the line and the line segment.
 *		The actual intersection coordinates can be found by
 *		solving P + t * D.  However, note that for return codes
 *		1 and 2 (intersection exactly at a vertex), it is
 *		strongly recommended that the original values passed in
 *		A or B are used instead of solving P + t * D, to prevent
 *		numeric error from creeping into the position of
 *		the endpoints.
 */
/* XXX should probably be called rt_isect_line3_lseg3() */
/* XXX should probably be changed to return dist[2] */
int
rt_isect_line_lseg( t, p, d, a, b, tol )
fastf_t			*t;
CONST point_t		p;
CONST vect_t		d;
CONST point_t		a;
CONST point_t		b;
CONST struct rt_tol	*tol;
{
	LOCAL vect_t	c;		/* Direction vector from A to B */
	auto fastf_t	u;		/* As in, A + u * C = X */
	register fastf_t f;
	register int	ret;
	fastf_t		fuzz;

	RT_CK_TOL(tol);

	VSUB2( c, b, a );
	/*
	 *  To keep the values of u between 0 and 1,
	 *  C should NOT be scaled to have unit length.
	 *  However, it is a good idea to make sure that
	 *  C is a non-zero vector, (ie, that A and B are distinct).
	 */
	if( (fuzz = MAGSQ(c)) < tol->dist_sq )  {
		return(-4);		/* points A and B are not distinct */
	}

	/*
	 *  Detecting colinearity is difficult, and very very important.
	 *  As a first step, check to see if both points A and B lie
	 *  within tolerance of the line.  If so, then the line segment AC
	 *  is ON the line.
	 */
	if( rt_distsq_line3_pt3( p, d, a ) <= tol->dist_sq  &&
	    rt_distsq_line3_pt3( p, d, b ) <= tol->dist_sq )  {
		if( rt_g.debug & DEBUG_MATH )  {
			rt_log("rt_isect_line3_lseg3() pts A and B within tol of line\n");
		}
	    	/* Find the parametric distance along the ray */
		*t = rt_dist_pt3_along_line3( p, d, a );
		/*** dist[1] = rt_dist_pt3_along_line3( p, d, b ); ***/
		return 0;		/* Colinear */
	}

	if( (ret = rt_isect_line3_line3( t, &u, p, d, a, c, tol )) < 0 )  {
		/* No intersection found */
		return( -1 );
	}
	if( ret == 0 )  {
		/* co-linear (t was computed for point A, u=0) */
		return( 0 );
	}

	/*
	 *  The two lines intersect at a point.
	 *  If the u parameter is outside the range (0..1),
	 *  reject the intersection, because it falls outside
	 *  the line segment A--B.
	 *
	 *  Convert the tol->dist into allowable deviation in terms of
	 *  (0..1) range of the parameters.
	 */
	fuzz = tol->dist / sqrt(fuzz);
	if( u < -fuzz )
		return(-3);		/* Intersection < A */
	if( (f=(u-1)) > fuzz )
		return(-2);		/* Intersection > B */

	/* Check for fuzzy intersection with one of the verticies */
	if( u < fuzz )
		return( 1 );		/* Intersection at A */
	if( f >= -fuzz )
		return( 2 );		/* Intersection at B */

	return(3);			/* Intersection between A and B */
}

/*
 *			R T _ D I S T _ L I N E 3_ P T 3
 *
 *  Given a parametric line defined by PT + t * DIR and a point A,
 *  return the closest distance between the line and the point.
 *
 *  'dir' need not have unit length.
 *
 *  Find parameter for PCA along line with unitized DIR:
 *	d = VDOT(f, dir) / MAGNITUDE(dir);
 *  Find distance g from PCA to A using Pythagoras:
 *	g = sqrt( MAGSQ(f) - d**2 )
 *
 *  Return -
 *	Distance
 */
double
rt_dist_line3_pt3( pt, dir, a )
CONST point_t	pt;
CONST vect_t	dir;
CONST point_t	a;
{
	LOCAL vect_t		f;
	register fastf_t	FdotD;

	if( (FdotD = MAGNITUDE(dir)) <= SMALL_FASTF )  {
		FdotD = 0.0;
		goto out;
	}
	VSUB2( f, a, pt );
	FdotD = VDOT( f, dir ) / FdotD;
	FdotD = MAGSQ( f ) - FdotD * FdotD;
	if( FdotD <= SMALL_FASTF )  {
		FdotD = 0.0;
		goto out;
	}
	FdotD = sqrt(FdotD);
out:
	if( rt_g.debug & DEBUG_MATH )  {
		rt_log("rt_dist_line3_pt3() ret=%g\n", FdotD);
	}
	return FdotD;
}

/*
 *			R T _ D I S T S Q _ L I N E 3 _ P T 3
 *
 *  Given a parametric line defined by PT + t * DIR and a point A,
 *  return the square of the closest distance between the line and the point.
 *
 *  'dir' need not have unit length.
 *
 *  Return -
 *	Distance squared
 */
double
rt_distsq_line3_pt3( pt, dir, a )
CONST point_t	pt;
CONST vect_t	dir;
CONST point_t	a;
{
	LOCAL vect_t		f;
	register fastf_t	FdotD;

	VSUB2( f, pt, a );
	if( (FdotD = MAGNITUDE(dir)) <= SMALL_FASTF )  {
		FdotD = 0.0;
		goto out;
	}
	FdotD = VDOT( f, dir ) / FdotD;
	if( (FdotD = VDOT( f, f ) - FdotD * FdotD ) <= SMALL_FASTF )  {
		FdotD = 0.0;
	}
out:
	if( rt_g.debug & DEBUG_MATH )  {
		rt_log("rt_distsq_line3_pt3() ret=%g\n", FdotD);
	}
	return FdotD;
}

/*
 *			R T _ D I S T _ L I N E _ O R I G I N
 *
 *  Given a parametric line defined by PT + t * DIR,
 *  return the closest distance between the line and the origin.
 *
 *  'dir' need not have unit length.
 *
 *  Return -
 *	Distance
 */
double
rt_dist_line_origin( pt, dir )
CONST point_t	pt;
CONST vect_t	dir;
{
	register fastf_t	PTdotD;

	if( (PTdotD = MAGNITUDE(dir)) <= SMALL_FASTF )
		return 0.0;
	PTdotD = VDOT( pt, dir ) / PTdotD;
	if( (PTdotD = VDOT( pt, pt ) - PTdotD * PTdotD ) <= SMALL_FASTF )
		return(0.0);
	return( sqrt(PTdotD) );
}
/*
 *			R T _ D I S T _ L I N E 2 _ P O I N T 2
 *
 *  Given a parametric line defined by PT + t * DIR and a point A,
 *  return the closest distance between the line and the point.
 *
 *  'dir' need not have unit length.
 *
 *  Return -
 *	Distance
 */
double
rt_dist_line2_point2( pt, dir, a )
CONST point_t	pt;
CONST vect_t	dir;
CONST point_t	a;
{
	LOCAL vect_t		f;
	register fastf_t	FdotD;

	VSUB2_2D( f, pt, a );
	if( (FdotD = sqrt(MAGSQ_2D(dir))) <= SMALL_FASTF )
		return 0.0;
	FdotD = VDOT_2D( f, dir ) / FdotD;
	if( (FdotD = VDOT_2D( f, f ) - FdotD * FdotD ) <= SMALL_FASTF )
		return(0.0);
	return( sqrt(FdotD) );
}

/*
 *			R T _ D I S T S Q _ L I N E 2 _ P O I N T 2
 *
 *  Given a parametric line defined by PT + t * DIR and a point A,
 *  return the closest distance between the line and the point, squared.
 *
 *  'dir' need not have unit length.
 *
 *  Return -
 *	Distance squared
 */
double
rt_distsq_line2_point2( pt, dir, a )
CONST point_t	pt;
CONST vect_t	dir;
CONST point_t	a;
{
	LOCAL vect_t		f;
	register fastf_t	FdotD;

	VSUB2_2D( f, pt, a );
	if( (FdotD = sqrt(MAGSQ_2D(dir))) <= SMALL_FASTF )
		return 0.0;
	FdotD = VDOT_2D( f, dir ) / FdotD;
	if( (FdotD = VDOT_2D( f, f ) - FdotD * FdotD ) <= SMALL_FASTF )
		return(0.0);
	return( FdotD );
}

/*
 *			R T _ A R E A _ O F _ T R I A N G L E
 *
 *  Returns the area of a triangle.
 *  Algorithm by Jon Leech 3/24/89.
 */
double
rt_area_of_triangle( a, b, c )
register CONST point_t a, b, c;
{
	register double	t;
	register double	area;

	t =	a[Y] * (b[Z] - c[Z]) -
		b[Y] * (a[Z] - c[Z]) +
		c[Y] * (a[Z] - b[Z]);
	area  = t*t;
	t =	a[Z] * (b[X] - c[X]) -
		b[Z] * (a[X] - c[X]) +
		c[Z] * (a[X] - b[X]);
	area += t*t;
	t = 	a[X] * (b[Y] - c[Y]) -
		b[X] * (a[Y] - c[Y]) +
		c[X] * (a[Y] - b[Y]);
	area += t*t;

	return( 0.5 * sqrt(area) );
}


/*
 *			R T _ I S E C T _ P T _ L S E G
 *
 * Intersect a point P with the line segment defined by two distinct
 * points A and B.
 *	
 * Explicit Return
 *	-2	P on line AB but outside range of AB,
 *			dist = distance from A to P on line.
 *	-1	P not on line of AB within tolerance
 *	1	P is at A
 *	2	P is at B
 *	3	P is on AB, dist = distance from A to P on line.
 *	
 *    B *
 *	|  
 *    P'*-tol-*P 
 *	|    /  _
 *    dist  /   /|
 *	|  /   /
 *	| /   / AtoP
 *	|/   /
 *    A *   /
 *	
 *	tol = distance limit from line to pt P;
 *	dist = distance from A to P'
 */
int rt_isect_pt_lseg(dist, a, b, p, tol)
fastf_t			*dist;		/* distance along line from A to P */
CONST point_t		a, b, p;	/* points for line and intersect */
CONST struct rt_tol	*tol;
{
	vect_t	AtoP,
		BtoP,
		AtoB,
		ABunit;	/* unit vector from A to B */
	fastf_t	APprABunit;	/* Mag of projection of AtoP onto ABunit */
	fastf_t	distsq;

	RT_CK_TOL(tol);

	VSUB2(AtoP, p, a);
	if (MAGSQ(AtoP) < tol->dist_sq)
		return(1);	/* P at A */

	VSUB2(BtoP, p, b);
	if (MAGSQ(BtoP) < tol->dist_sq)
		return(2);	/* P at B */

	VSUB2(AtoB, b, a);
	VMOVE(ABunit, AtoB);
	distsq = MAGSQ(ABunit);
	if( distsq < tol->dist_sq )
		return -1;	/* A equals B, and P isn't there */
	distsq = 1/sqrt(distsq);
	VSCALE( ABunit, ABunit, distsq );

	/* Similar to rt_dist_line_pt, except we
	 * never actually have to do the sqrt that the other routine does.
	 */

	/* find dist as a function of ABunit, actually the projection
	 * of AtoP onto ABunit
	 */
	APprABunit = VDOT(AtoP, ABunit);

	/* because of pythgorean theorem ... */
	distsq = MAGSQ(AtoP) - APprABunit * APprABunit;
	if (distsq > tol->dist_sq)
		return(-1);	/* dist pt to line too large */

	/* Distance from the point to the line is within tolerance. */
	*dist = VDOT(AtoP, AtoB) / MAGSQ(AtoB);

	if (*dist > 1.0 || *dist < 0.0)	/* P outside AtoB */
		return(-2);

	return(3);	/* P on AtoB */
}

/*
 *			R T _ I S E C T _ P T 2 _ L S E G 2
 *
 * Intersect a point P with the line segment defined by two distinct
 * points A and B.
 *	
 * Explicit Return
 *	-2	P on line AB but outside range of AB,
 *			dist = distance from A to P on line.
 *	-1	P not on line of AB within tolerance
 *	1	P is at A
 *	2	P is at B
 *	3	P is on AB, dist = distance from A to P on line.
 *	
 *    B *
 *	|  
 *    P'*-tol-*P 
 *	|    /  _
 *    dist  /   /|
 *	|  /   /
 *	| /   / AtoP
 *	|/   /
 *    A *   /
 *	
 *	tol = distance limit from line to pt P;
 *	dist = distance from A to P'
 */
int
rt_isect_pt2_lseg2(dist, a, b, p, tol)
fastf_t			*dist;		/* distance along line from A to P */
CONST point_t		a, b, p;	/* points for line and intersect */
CONST struct rt_tol	*tol;
{
	vect_t	AtoP,
		BtoP,
		AtoB,
		ABunit;	/* unit vector from A to B */
	fastf_t	APprABunit;	/* Mag of projection of AtoP onto ABunit */
	fastf_t	distsq;

	RT_CK_TOL(tol);

	VSUB2_2D(AtoP, p, a);
	if (MAGSQ_2D(AtoP) < tol->dist_sq)
		return(1);	/* P at A */

	VSUB2_2D(BtoP, p, b);
	if (MAGSQ_2D(BtoP) < tol->dist_sq)
		return(2);	/* P at B */

	VSUB2_2D(AtoB, b, a);
	VMOVE_2D(ABunit, AtoB);
	distsq = MAGSQ_2D(ABunit);
	if( distsq < tol->dist_sq )  {
		if( rt_g.debug & DEBUG_MATH )  {
			rt_log("distsq A=%g\n", distsq);
		}
		return -1;	/* A equals B, and P isn't there */
	}
	distsq = 1/sqrt(distsq);
	VSCALE_2D( ABunit, ABunit, distsq );

	/* Similar to rt_dist_line_pt, except we
	 * never actually have to do the sqrt that the other routine does.
	 */

	/* find dist as a function of ABunit, actually the projection
	 * of AtoP onto ABunit
	 */
	APprABunit = VDOT_2D(AtoP, ABunit);

	/* because of pythgorean theorem ... */
	distsq = MAGSQ_2D(AtoP) - APprABunit * APprABunit;
	if (distsq > tol->dist_sq) {
		if( rt_g.debug & DEBUG_MATH )  {
			V2PRINT("ABunit", ABunit);
			rt_log("distsq B=%g\n", distsq);
		}
		return(-1);	/* dist pt to line too large */
	}

	/* Distance from the point to the line is within tolerance. */
	*dist = VDOT_2D(AtoP, AtoB) / MAGSQ_2D(AtoB);

	if (*dist > 1.0 || *dist < 0.0)	/* P outside AtoB */
		return(-2);

	return(3);	/* P on AtoB */
}

/*
 *			R T _ D I S T _ P T 3 _ L S E G 3
 *
 *  Find the distance from a point P to a line segment described
 *  by the two endpoints A and B, and the point of closest approach (PCA).
 *
 *			P
 *		       *
 *		      /.
 *		     / .
 *		    /  .
 *		   /   . (dist)
 *		  /    .
 *		 /     .
 *		*------*--------*
 *		A      PCA	B
 *
 *  There are six distinct cases, with these return codes -
 *	0	P is within tolerance of lseg AB.  *dist isn't 0: (SPECIAL!!!)
 *		  *dist = parametric dist = |PCA-A| / |B-A|.  pca=computed.
 *	1	P is within tolerance of point A.  *dist = 0, pca=A.
 *	2	P is within tolerance of point B.  *dist = 0, pca=B.
 *	3	P is to the "left" of point A.  *dist=|P-A|, pca=A.
 *	4	P is to the "right" of point B.  *dist=|P-B|, pca=B.
 *	5	P is "above/below" lseg AB.  *dist=|PCA-P|, pca=computed.
 *
 * This routine was formerly called rt_dist_pt_lseg().
 *
 * XXX For efficiency, a version of this routine that provides the
 * XXX distance squared would be faster.
 */
int
rt_dist_pt3_lseg3( dist, pca, a, b, p, tol )
fastf_t		*dist;
point_t		pca;
CONST point_t	a, b, p;
CONST struct rt_tol *tol;
{
	vect_t	PtoA;		/* P-A */
	vect_t	PtoB;		/* P-B */
	vect_t	AtoB;		/* B-A */
	fastf_t	P_A_sq;		/* |P-A|**2 */
	fastf_t	P_B_sq;		/* |P-B|**2 */
	fastf_t	B_A;		/* |B-A| */
	fastf_t	t;		/* distance along ray of projection of P */

	RT_CK_TOL(tol);

	if( rt_g.debug & DEBUG_MATH )  {
		rt_log("rt_dist_pt3_lseg3() a=(%g,%g,%g) b=(%g,%g,%g)\n\tp=(%g,%g,%g), tol->dist=%g sq=%g\n",
			V3ARGS(a),
			V3ARGS(b),
			V3ARGS(p),
			tol->dist, tol->dist_sq );
	}

	/* Check proximity to endpoint A */
	VSUB2(PtoA, p, a);
	if( (P_A_sq = MAGSQ(PtoA)) < tol->dist_sq )  {
		/* P is within the tol->dist radius circle around A */
		VMOVE( pca, a );
		if( rt_g.debug & DEBUG_MATH )  rt_log("  at A\n");
		*dist = 0.0;
		return 1;
	}

	/* Check proximity to endpoint B */
	VSUB2(PtoB, p, b);
	if( (P_B_sq = MAGSQ(PtoB)) < tol->dist_sq )  {
		/* P is within the tol->dist radius circle around B */
		VMOVE( pca, b );
		if( rt_g.debug & DEBUG_MATH )  rt_log("  at B\n");
		*dist = 0.0;
		return 2;
	}

	VSUB2(AtoB, b, a);
	B_A = sqrt( MAGSQ(AtoB) );

	/* compute distance (in actual units) along line to PROJECTION of
	 * point p onto the line: point pca
	 */
	t = VDOT(PtoA, AtoB) / B_A;
	if( rt_g.debug & DEBUG_MATH )  {
		rt_log("rt_dist_pt3_lseg3() B_A=%g, t=%g\n",
			B_A, t );
	}

	if( t <= 0 )  {
		/* P is "left" of A */
		if( rt_g.debug & DEBUG_MATH )  rt_log("  left of A\n");
		VMOVE( pca, a );
		*dist = sqrt(P_A_sq);
		return 3;
	}
	if( t < B_A )  {
		/* PCA falls between A and B */
		register fastf_t	dsq;
		fastf_t			param_dist;	/* parametric dist */

		/* Find PCA */
		param_dist = t / B_A;		/* Range 0..1 */
		VJOIN1(pca, a, param_dist, AtoB);

		/* Find distance from PCA to line segment (Pythagorus) */
		if( (dsq = P_A_sq - t * t ) <= tol->dist_sq )  {
			if( rt_g.debug & DEBUG_MATH )  rt_log("  ON lseg\n");
			/* Distance from PCA to lseg is zero, give param instead */
			*dist = param_dist;	/* special! */
			return 0;
		}
		if( rt_g.debug & DEBUG_MATH )  rt_log("  closest to lseg\n");
		*dist = sqrt(dsq);
		return 5;
	}
	/* P is "right" of B */
	if( rt_g.debug & DEBUG_MATH )  rt_log("  right of B\n");
	VMOVE(pca, b);
	*dist = sqrt(P_B_sq);
	return 4;
}

/*
 *			R T _ D I S T _ P T 2 _ L S E G 2
 *
 *  Find the distance from a point P to a line segment described
 *  by the two endpoints A and B, and the point of closest approach (PCA).
 *
 *			P
 *		       *
 *		      /.
 *		     / .
 *		    /  .
 *		   /   . (dist)
 *		  /    .
 *		 /     .
 *		*------*--------*
 *		A      PCA	B
 *
 *  There are six distinct cases, with these return codes -
 *	0	P is within tolerance of lseg AB.  *dist isn't 0: (SPECIAL!!!)
 *		  *dist = parametric dist = |PCA-A| / |B-A|.  pca=computed.
 *	1	P is within tolerance of point A.  *dist = 0, pca=A.
 *	2	P is within tolerance of point B.  *dist = 0, pca=B.
 *	3	P is to the "left" of point A.  *dist=|P-A|**2, pca=A.
 *	4	P is to the "right" of point B.  *dist=|P-B|**2, pca=B.
 *	5	P is "above/below" lseg AB.  *dist=|PCA-P|**2, pca=computed.
 *
 *
 *  Patterned after rt_dist_pt3_lseg3().
 */
int
rt_dist_pt2_lseg2( dist_sq, pca, a, b, p, tol )
fastf_t		*dist_sq;
fastf_t		pca[2];
CONST point_t	a, b, p;
CONST struct rt_tol *tol;
{
	vect_t	PtoA;		/* P-A */
	vect_t	PtoB;		/* P-B */
	vect_t	AtoB;		/* B-A */
	fastf_t	P_A_sq;		/* |P-A|**2 */
	fastf_t	P_B_sq;		/* |P-B|**2 */
	fastf_t	B_A;		/* |B-A| */
	fastf_t	t;		/* distance along ray of projection of P */

	RT_CK_TOL(tol);

	if( rt_g.debug & DEBUG_MATH )  {
		rt_log("rt_dist_pt3_lseg3() a=(%g,%g,%g) b=(%g,%g,%g)\n\tp=(%g,%g,%g), tol->dist=%g sq=%g\n",
			V3ARGS(a),
			V3ARGS(b),
			V3ARGS(p),
			tol->dist, tol->dist_sq );
	}


	/* Check proximity to endpoint A */
	VSUB2_2D(PtoA, p, a);
	if( (P_A_sq = MAGSQ_2D(PtoA)) < tol->dist_sq )  {
		/* P is within the tol->dist radius circle around A */
		V2MOVE( pca, a );
		if( rt_g.debug & DEBUG_MATH )  rt_log("  at A\n");
		*dist_sq = 0.0;
		return 1;
	}

	/* Check proximity to endpoint B */
	VSUB2_2D(PtoB, p, b);
	if( (P_B_sq = MAGSQ_2D(PtoB)) < tol->dist_sq )  {
		/* P is within the tol->dist radius circle around B */
		V2MOVE( pca, b );
		if( rt_g.debug & DEBUG_MATH )  rt_log("  at B\n");
		*dist_sq = 0.0;
		return 2;
	}

	VSUB2_2D(AtoB, b, a);
	B_A = sqrt( MAGSQ_2D(AtoB) );

	/* compute distance (in actual units) along line to PROJECTION of
	 * point p onto the line: point pca
	 */
	t = VDOT_2D(PtoA, AtoB) / B_A;
	if( rt_g.debug & DEBUG_MATH )  {
		rt_log("rt_dist_pt3_lseg3() B_A=%g, t=%g\n",
			B_A, t );
	}

	if( t <= 0 )  {
		/* P is "left" of A */
		if( rt_g.debug & DEBUG_MATH )  rt_log("  left of A\n");
		V2MOVE( pca, a );
		*dist_sq = P_A_sq;
		return 3;
	}
	if( t < B_A )  {
		/* PCA falls between A and B */
		register fastf_t	dsq;
		fastf_t			param_dist;	/* parametric dist */

		/* Find PCA */
		param_dist = t / B_A;		/* Range 0..1 */
		V2JOIN1(pca, a, param_dist, AtoB);

		/* Find distance from PCA to line segment (Pythagorus) */
		if( (dsq = P_A_sq - t * t ) <= tol->dist_sq )  {
			if( rt_g.debug & DEBUG_MATH )  rt_log("  ON lseg\n");
			/* Distance from PCA to lseg is zero, give param instead */
			*dist_sq = param_dist;	/* special! Not squared. */
			return 0;
		}
		if( rt_g.debug & DEBUG_MATH )  rt_log("  closest to lseg\n");
		*dist_sq = dsq;
		return 5;
	}
	/* P is "right" of B */
	if( rt_g.debug & DEBUG_MATH )  rt_log("  right of B\n");
	V2MOVE(pca, b);
	*dist_sq = P_B_sq;
	return 4;
}

/*
 *			R T _ R O T A T E _ B B O X
 *
 *  Transform a bounding box (RPP) by the given 4x4 matrix.
 *  There are 8 corners to the bounding RPP.
 *  Each one needs to be transformed and min/max'ed.
 *  This is not minimal, but does fully contain any internal object,
 *  using an axis-aligned RPP.
 */
void
rt_rotate_bbox( omin, omax, mat, imin, imax )
point_t		omin;
point_t		omax;
CONST mat_t	mat;
CONST point_t	imin;
CONST point_t	imax;
{
	point_t	local;		/* vertex point in local coordinates */
	point_t	model;		/* vertex point in model coordinates */

#define ROT_VERT( a, b, c )  \
	VSET( local, a[X], b[Y], c[Z] ); \
	MAT4X3PNT( model, mat, local ); \
	VMINMAX( omin, omax, model ) \

	ROT_VERT( imin, imin, imin );
	ROT_VERT( imin, imin, imax );
	ROT_VERT( imin, imax, imin );
	ROT_VERT( imin, imax, imax );
	ROT_VERT( imax, imin, imin );
	ROT_VERT( imax, imin, imax );
	ROT_VERT( imax, imax, imin );
	ROT_VERT( imax, imax, imax );
#undef ROT_VERT
}

/*
 *			R T _ R O T A T E _ P L A N E
 *
 *  Transform a plane equation by the given 4x4 matrix.
 */
void
rt_rotate_plane( oplane, mat, iplane )
plane_t		oplane;
CONST mat_t	mat;
CONST plane_t	iplane;
{
	point_t		orig_pt;
	point_t		new_pt;

	/* First, pick a point that lies on the original halfspace */
	VSCALE( orig_pt, iplane, iplane[3] );

	/* Transform the surface normal */
	MAT4X3VEC( oplane, mat, iplane );

	/* Transform the point from original to new halfspace */
	MAT4X3PNT( new_pt, mat, orig_pt );

	/*
	 *  The transformed normal is all that is required.
	 *  The new distance is found from the transformed point on the plane.
	 */
	oplane[3] = VDOT( new_pt, oplane );
}

/*
 *			R T _ C O P L A N A R
 *
 *  Test if two planes are identical.  If so, their dot products will be
 *  either +1 or -1, with the distance from the origin equal in magnitude.
 *
 *  Returns -
 *	-1	not coplanar, parallel but distinct
 *	 0	not coplanar, not parallel.  Planes intersect.
 *	+1	coplanar, same normal direction
 *	+2	coplanar, opposite normal direction
 */
int
rt_coplanar( a, b, tol )
CONST plane_t		a;
CONST plane_t		b;
CONST struct rt_tol	*tol;
{
	register fastf_t	f;
	register fastf_t	dot;

	RT_CK_TOL(tol);

	/* Check to see if the planes are parallel */
	dot = VDOT( a, b );
	if( dot >= 0 )  {
		/* Normals head in generally the same directions */
		if( dot < tol->para )
			return(0);	/* Planes intersect */

		/* Planes have "exactly" the same normal vector */
		f = a[3] - b[3];
		if( NEAR_ZERO( f, tol->dist ) )  {
			return(1);	/* Coplanar, same direction */
		}
		return(-1);		/* Parallel but distinct */
	}
	/* Normals head in generally opposite directions */
	if( -dot < tol->para )
		return(0);		/* Planes intersect */

	/* Planes have "exactly" opposite normal vectors */
	f = a[3] + b[3];
	if( NEAR_ZERO( f, tol->dist ) )  {
		return(2);		/* Coplanar, opposite directions */
	}
	return(-1);			/* Parallel but distinct */
}

/*
 *			R T _ A N G L E _ M E A S U R E
 *
 *  Using two perpendicular vectors (x_dir and y_dir) which lie
 *  in the same plane as 'vec', return the angle (in radians) of 'vec'
 *  from x_dir, going CCW around the perpendicular x_dir CROSS y_dir.
 *
 *  Trig note -
 *
 *  theta = atan2(x,y) returns an angle in the range -pi to +pi.
 *  Here, we need an angle in the range of 0 to 2pi.
 *  This could be implemented by adding 2pi to theta when theta is negative,
 *  but this could have nasty numeric ambiguity right in the vicinity
 *  of theta = +pi, which is a very critical angle for the applications using
 *  this routine.
 *  So, an alternative formulation is to compute gamma = atan2(-x,-y),
 *  and then theta = gamma + pi.  Now, any error will occur in the
 *  vicinity of theta = 0, which can be handled much more readily.
 *
 *  If theta is negative, or greater than two pi,
 *  wrap it around.
 *  These conditions only occur if there are problems in atan2().
 *
 *  Returns -
 *	vec == x_dir returns 0,
 *	vec == y_dir returns pi/2,
 *	vec == -x_dir returns pi,
 *	vec == -y_dir returns 3*pi/2.
 *
 *  In all cases, the returned value is between 0 and rt_twopi.
 */
double
rt_angle_measure( vec, x_dir, y_dir )
vect_t	vec;
CONST vect_t	x_dir;
CONST vect_t	y_dir;
{
	fastf_t		xproj, yproj;
	fastf_t		gamma;
	fastf_t		ang;

	xproj = -VDOT( vec, x_dir );
	yproj = -VDOT( vec, y_dir );
	gamma = atan2( yproj, xproj );	/* -pi..+pi */
	ang = rt_pi + gamma;		/* 0..+2pi */
	if( ang < 0 )  {
		do {
			ang += rt_twopi;
		} while( ang < 0 );
	} else if( ang > rt_twopi )  {
		do {
			ang -= rt_twopi;
		} while( ang > rt_twopi );
	}
	if( ang < 0 || ang > rt_twopi )  rt_bomb("rt_angle_measure() angle out of range\n");
	return ang;
}

/*
 *			R T _ D I S T _ P T 3 _ A L O N G _ L I N E 3
 *
 *  Return the parametric distance t of a point X along a line defined
 *  as a ray, i.e. solve X = P + t * D.
 *  If the point X does not lie on the line, then t is the distance of
 *  the perpendicular projection of point X onto the line.
 */
double
rt_dist_pt3_along_line3( p, d, x )
CONST point_t	p;
CONST vect_t	d;
CONST point_t	x;
{
	vect_t	x_p;

	VSUB2( x_p, x, p );
	return VDOT( x_p, d );
}


/*
 *			R T _ D I S T _ P T 2 _ A L O N G _ L I N E 2
 *
 *  Return the parametric distance t of a point X along a line defined
 *  as a ray, i.e. solve X = P + t * D.
 *  If the point X does not lie on the line, then t is the distance of
 *  the perpendicular projection of point X onto the line.
 */
double
rt_dist_pt2_along_line2( p, d, x )
CONST point_t	p;
CONST vect_t	d;
CONST point_t	x;
{
	vect_t	x_p;
	double	ret;

	VSUB2_2D( x_p, x, p );
	ret = VDOT_2D( x_p, d );
	if( rt_g.debug & DEBUG_MATH )  {
		rt_log("rt_dist_pt2_along_line2() p=(%g, %g), d=(%g, %g), x=(%g, %g) ret=%g\n",
			V2ARGS(p),
			V2ARGS(d),
			V2ARGS(x),
			ret );
	}
	return ret;
}

/*
 *  Returns -
 *	1	if left <= mid <= right
 *	0	if mid is not in the range.
 */
int
rt_between( left, mid, right, tol )
double	left;
double	mid;
double	right;
CONST struct rt_tol	*tol;
{
	RT_CK_TOL(tol);

	if( left < right )  {
		if( NEAR_ZERO(left-right, tol->dist*0.1) )  {
			left -= tol->dist*0.1;
			right += tol->dist*0.1;
		}
		if( mid < left || mid > right )  goto fail;
		return 1;
	}
	/* The 'right' value is lowest */
	if( NEAR_ZERO(left-right, tol->dist*0.1) )  {
		right -= tol->dist*0.1;
		left += tol->dist*0.1;
	}
	if( mid < right || mid > left )  goto fail;
	return 1;
fail:
	if( rt_g.debug & DEBUG_MATH )  {
		rt_log("rt_between( %.17e, %.17e, %.17e ) ret=0 FAIL\n",
			left, mid, right);
	}
	return 0;
}
@


11.6.10.1
log
@sync branch with HEAD
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header$ (BRL)";
@


11.6.8.1
log
@sync to HEAD...
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/Attic/plane.c,v 11.6 1996/04/19 15:28:06 jra Exp $ (BRL)";
@


11.6.6.1
log
@updates from HEAD, part 1
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /c/CVS/brlcad/librt/Attic/plane.c,v 11.6 1996/04/19 15:28:06 jra Exp $ (BRL)";
@


11.6.6.2
log
@merge from HEAD
@
text
@@


11.6.6.3
log
@merge from head
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /c/CVS/brlcad/librt/Attic/plane.c,v 11.6.6.2 2004/02/12 18:37:46 erikg Exp $ (BRL)";
@


11.6.4.1
log
@Merged head into branch
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /c/CVS/brlcad/librt/Attic/plane.c,v 11.6 1996/04/19 15:28:06 jra Exp $ (BRL)";
@


11.6.2.1
log
@updated for merging
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /c/CVS/brlcad/librt/Attic/plane.c,v 11.6 1996/04/19 15:28:06 jra Exp $ (BRL)";
@


11.5
log
@Added code to rt_isect_line2_line2() to help detect parallel lines.
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 11.4 1995/03/02 04:47:39 mike Exp $ (BRL)";
d1396 2
a1397 2
			rt_log("rt_isect_line3_line3(): BOGUS RESULT, hit1=(%g,%g,%g), hit2=(%g,%g,%g)\n",
				hit1[X], hit1[Y], hit1[Z], hit2[X], hit2[Y], hit2[Z]);
@


11.4
log
@Added bullet-proofing
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 11.3 95/02/28 23:45:36 mike Exp Locker: mike $ (BRL)";
d573 6
d647 23
d676 1
a676 1
	if( NEAR_ZERO( det, DETERMINANT_TOL ) )  {
d678 1
a678 1
		if( !NEAR_ZERO( det1, DETERMINANT_TOL ) )  {
@


11.3
log
@Tests for division by zero should be against SMALL_FASTF, not
SQRT_SMALL_FASTF.  See h/machine.h for details.
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 11.2 95/02/02 01:48:04 mike Exp Locker: mike $ (BRL)";
d2235 2
d2253 3
a2255 1
		return rt_twopi + ang;
d2257 3
a2259 1
		return ang - rt_twopi;
d2261 1
@


11.2
log
@Clarified code in rt_dist_line3_pt3().  Fixed unimportant sign problem.
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 11.1 95/01/04 09:58:23 mike Rel4_4 Locker: mike $ (BRL)";
d249 1
a249 1
	if( (mag = MAGNITUDE(plane)) <= SQRT_SMALL_FASTF )
d315 1
a315 1
	if( NEAR_ZERO( det, SQRT_SMALL_FASTF ) )  return(-1);
d414 1
a414 1
	if( slant_factor < -SQRT_SMALL_FASTF )  {
d417 1
a417 1
	} else if( slant_factor > SQRT_SMALL_FASTF )  {
d1075 1
a1075 1
	if( pmag < SQRT_SMALL_FASTF )
d1107 1
a1107 1
	if( qmag < SQRT_SMALL_FASTF )
@


11.1
log
@Release_4.4
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.36 95/01/04 07:56:00 mike Exp $ (BRL)";
d1494 5
a1510 1
	VSUB2( f, pt, a );
d1515 1
d1517 2
a1518 1
	if( (FdotD = VDOT( f, f ) - FdotD * FdotD ) <= SMALL_FASTF )  {
@


10.36
log
@Cray C90
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.35 94/11/28 13:26:47 jra Exp Locker: mike $ (BRL)";
@


10.35
log
@Fixed rt_isect_line3_line3 to correctly handle parallel lines.
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.34 94/11/04 05:54:06 mike Exp Locker: jra $ (BRL)";
d136 1
@


10.34
log
@Irix 6
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.33 94/10/11 19:36:09 mike Exp Locker: mike $ (BRL)";
d1192 12
@


10.33
log
@Fixed some unsafe 2D code that was using [Z].
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.32 94/09/16 20:19:52 mike Exp Locker: mike $ (BRL)";
d355 1
a355 1
	/* Impose a general angular tolerance to reject 
a462 1
	register fastf_t	d;
a960 5
	fastf_t	dx, dy;
	fastf_t	det;		/* determinant */
	fastf_t	det1, det2;
	fastf_t	b,c;
	fastf_t	hx, hy;		/* H = Q - P */
a1057 5
	fastf_t	dx, dy;
	fastf_t	det;		/* determinant */
	fastf_t	det1, det2;
	fastf_t	b,c;
	fastf_t	hx, hy;		/* H = Q - P */
a1873 1
	fastf_t	B_A_sq;
d1907 1
a1907 1
	B_A = sqrt( B_A_sq = MAGSQ(AtoB) );
a1993 1
	fastf_t	B_A_sq;
d2028 1
a2028 1
	B_A = sqrt( B_A_sq = MAGSQ_2D(AtoB) );
@


10.32
log
@Moved rt_2line3_colinear() to plane.c
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.31 94/08/10 19:20:21 gdurf Exp Locker: mike $ (BRL)";
d1826 1
a1826 1
			VPRINT("ABunit", ABunit);
d1996 1
a1996 1
point_t		pca;
d2024 1
a2024 1
		VMOVE( pca, a );
d2034 1
a2034 1
		VMOVE( pca, b );
d2055 1
a2055 1
		VMOVE( pca, a );
d2066 1
a2066 1
		VJOIN1(pca, a, param_dist, AtoB);
d2081 1
a2081 1
	VMOVE(pca, b);
@


10.31
log
@Added include of conf.h
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.30 1994/07/01 23:36:01 mike Exp gdurf $ (BRL)";
d324 54
@


10.30
log
@Added rt_dist_pt3_pt3().  Added DEBUG_MATH prints to rt_dist_line3_pt3().
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.29 94/04/22 05:28:14 mike Exp Locker: mike $ (BRL)";
d20 2
@


10.29
log
@Moved stuff into proper header files.
Changed rt_dist_line_point() to rt_dist_line3_pt3().
Left a compatability macro in raytrace.h
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.28 94/04/21 07:00:33 mike Exp Locker: mike $ (BRL)";
d30 16
d1449 4
a1452 2
	if( (FdotD = MAGNITUDE(dir)) <= SMALL_FASTF )
		return 0.0;
d1454 10
a1463 3
	if( (FdotD = VDOT( f, f ) - FdotD * FdotD ) <= SMALL_FASTF )
		return(0.0);
	return( sqrt(FdotD) );
d1487 4
a1490 2
	if( (FdotD = MAGNITUDE(dir)) <= SMALL_FASTF )
		return 0.0;
d1492 7
a1498 2
	if( (FdotD = VDOT( f, f ) - FdotD * FdotD ) <= SMALL_FASTF )
		return(0.0);
@


10.28
log
@Needed function declaration, to get return type right!
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.27 94/04/20 00:43:22 mike Exp Locker: mike $ (BRL)";
a28 13
/* XXX move to raytrace.h */
RT_EXTERN(double	rt_dist_pt3_along_line3, (CONST point_t	p,
			CONST vect_t d, CONST point_t x));
RT_EXTERN(double	rt_dist_pt2_along_line2, (CONST point_t p,
			CONST vect_t d, CONST point_t x));
RT_EXTERN(double	rt_distsq_line3_pt3, (CONST point_t pt,
			CONST vect_t dir, CONST point_t a));

/* XXX move to vmath.h */
#define V2PRINT(a,b)	\
	rt_log("%s (%g, %g)\n", a, V2ARGS(b) );


d1413 1
a1413 1
 *			R T _ D I S T _ L I N E _ P O I N T
a1421 2
 *
 *  XXX Another name for this might be rt_dist_line3_pt3()
d1424 1
a1424 1
rt_dist_line_point( pt, dir, a )
@


10.27
log
@Relaxed requirement for unit vectors.
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.26 94/04/19 07:17:16 mike Exp Locker: mike $ (BRL)";
d34 3
@


10.26
log
@Took out "inconsistent results" blather.
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.25 94/04/18 06:06:01 mike Exp Locker: mike $ (BRL)";
a1426 1
 *  It is necessary that DIR have unit length.
d1428 2
d1445 3
a1447 1
	FdotD = VDOT( f, dir );
a1457 1
 *  It is necessary that DIR have unit length.
d1459 2
d1474 3
a1476 1
	FdotD = VDOT( f, dir );
a1486 1
 *  It is necessary that DIR have unit length.
d1488 2
d1500 3
a1502 1
	PTdotD = VDOT( pt, dir );
a1511 1
 *  It is necessary that DIR have unit length.
d1513 2
d1528 3
a1530 1
	FdotD = VDOT_2D( f, dir );
a1540 1
 *  It is necessary that DIR have unit length.
d1542 2
d1557 3
a1559 1
	FdotD = VDOT_2D( f, dir );
@


10.25
log
@Added 'tol' argument to rt_between().
Added some extra error checking.
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.24 94/04/18 01:46:03 mike Exp Locker: mike $ (BRL)";
d625 7
a631 2
	/*  To prevent errors, check the answer.
	 *  Not returning bogus results to our caller is worth the extra time.
d651 1
@


10.24
log
@Added externs, and some debug prints.
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.23 94/04/17 19:45:34 mike Exp Locker: mike $ (BRL)";
d34 3
d659 2
d771 12
d786 3
d811 5
d2203 37
@


10.23
log
@Fixed problem with Test12, namely, that rt_isect_line2_lseg2() was
missing co-linear intersections.
Applied similar improvements to the 3D code.
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.22 94/04/12 22:39:26 mike Exp Locker: mike $ (BRL)";
d29 7
d716 1
a716 1
	    rt_distsq_line2_point2( p, d, b ) <= tol->dist_sq )  {
d718 1
d2166 1
d2169 9
a2177 1
	return VDOT_2D( x_p, d );
@


10.22
log
@Moved 2D macros to vmath.h
Changed BOGUS RESULT logging.
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.21 94/03/09 22:03:45 mike Exp Locker: mike $ (BRL)";
d682 1
d696 1
a696 1
	if( (ctol = MAGSQ_2D(c)) < tol->dist_sq )  {
d701 19
a752 1
		point_t		b;
a755 1
		VADD2_2D( b, a, c );
d1333 17
d1392 2
d1412 26
d2120 41
@


10.21
log
@Pulled out DETERMINANT_TOL, which is still a hack, but better than
SQRT_SMALL_FASTF.
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.20 94/03/04 18:38:18 mike Exp Locker: mike $ (BRL)";
a28 27
/* XXX move to vmath.h */
#define VADD2_2D(a,b,c)	{ \
			(a)[X] = (b)[X] + (c)[X];\
			(a)[Y] = (b)[Y] + (c)[Y];}
#define VSUB2_2D(a,b,c)	{ \
			(a)[X] = (b)[X] - (c)[X];\
			(a)[Y] = (b)[Y] - (c)[Y];}
#define MAGSQ_2D(a)	( (a)[X]*(a)[X] + (a)[Y]*(a)[Y] )
#define VDOT_2D(a,b)	( (a)[X]*(b)[X] + (a)[Y]*(b)[Y] )
#define VMOVE_2D(a,b)	{ \
			(a)[X] = (b)[X];\
			(a)[Y] = (b)[Y];}
#define VSCALE_2D(a,b,c)	{ \
			(a)[X] = (b)[X] * (c);\
			(a)[Y] = (b)[Y] * (c); }
#define VJOIN1_2D(a,b,c,d) 	{ \
			(a)[X] = (b)[X] + (c) * (d)[X];\
			(a)[Y] = (b)[Y] + (c) * (d)[Y]; }
#define VUNITIZE_RET(a,ret)	{ \
			register double _f; _f = MAGNITUDE(a); \
			if( _f < VDIVIDE_TOL ) return(ret); \
			_f = 1.0/_f; \
			(a)[X] *= _f; (a)[Y] *= _f; (a)[Z] *= _f; }


#define PI      3.14159265358979323

d620 2
d625 8
a632 3
		if( !rt_pt2_pt2_equal( hit1, hit2, tol ) )  {
			rt_log("rt_isect_line2_line2(): BOGUS RESULT, hit1=(%g,%g), hit2=(%g,%g)\n",
				hit1[X], hit1[Y], hit2[X], hit2[Y]);
@


10.20
log
@Changed to 2D macros, for readability.
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.19 94/03/04 18:26:03 mike Exp Locker: mike $ (BRL)";
d601 2
a602 1
	if( NEAR_ZERO( det, SQRT_SMALL_FASTF ) )  {
d604 1
a604 1
		if( !NEAR_ZERO( det1, SQRT_SMALL_FASTF ) )  {
d1197 1
a1197 1
	if( NEAR_ZERO( det, SQRT_SMALL_FASTF ) )  {
d1199 1
a1199 1
		if( !NEAR_ZERO( det1, SQRT_SMALL_FASTF ) )  {
d1250 2
a1251 2
		/* This tolerance needs to be much less loose than
		 * SQRT_SMALL_FASTF.
d1632 3
a1634 1
rt_log("distsq A=%g\n", distsq);
d1652 4
a1655 2
VPRINT("ABunit", ABunit);
rt_log("distsq B=%g\n", distsq);
@


10.19
log
@Fixed missing sqrt() calls.
Added rt_pt2_pt2_equal(), added double checking to line/line isectors.
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.18 94/03/04 11:09:53 jra Exp Locker: mike $ (BRL)";
d47 5
d728 1
a728 1
		dtol = tol->dist / sqrt( d[X]*d[X] + d[Y]*d[Y] );
d885 1
a885 1
		ptol = tol->dist / sqrt( pdir[X]*pdir[X] + pdir[Y]*pdir[Y] );
d906 1
a906 1
	ptol = tol->dist / sqrt( pdir[X]*pdir[X] + pdir[Y]*pdir[Y] );
d910 1
a910 1
	qtol = tol->dist / sqrt( qdir[X]*qdir[X] + qdir[Y]*qdir[Y] );
@


10.18
log
@Re-wrote rt_3pts_collinear.
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.17 94/03/04 04:30:01 mike Exp Locker: jra $ (BRL)";
d73 21
d98 3
d594 1
d636 15
d746 1
a746 1
		fastf_t		ab_dist;
d749 1
d753 1
d755 5
d1190 1
d1251 15
d1546 1
a1546 1
	distsq = 1/distsq;
d1625 2
a1626 1
	if( distsq < tol->dist_sq )
d1628 2
a1629 1
	distsq = 1/distsq;
d1643 3
a1645 1
	if (distsq > tol->dist_sq)
d1647 1
@


10.17
log
@Added rt_isect_pt2_lseg2().
Added double check for bad results to rt_isect_line2_lseg2(),
since bad results had been seen getting returned to callers on
very nearly parallel lines.
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.16 94/03/02 17:07:08 mike Exp Locker: mike $ (BRL)";
d86 4
a89 2
	fastf_t	dist, mag_ba, mag_ca, theta;
	vect_t	ba, ca;
d91 5
a95 3
	VSUB2(ba, b, a);
	VSUB2(ca, c, a);
	mag_ba = MAGNITUDE(ba);
d97 37
a133 3
	theta = acos(VDOT(ba, ca)/(mag_ba * mag_ca));
	dist = mag_ba * sin(theta);
	return(fabs(dist) < tol->dist);
@


10.16
log
@Added some commented-out code to try and make rt_mk_plane_3pts() more
robust.
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.15 94/01/27 05:23:59 mike Exp Locker: mike $ (BRL)";
d30 3
d38 9
d48 1
d443 5
d464 1
a464 1
		rt_log("rt_isect_line2_line2() p=(%g,%g), d=(%g,%g)\n\t\ta=(%g,%g), c=(%g,%g)\n",
d528 5
d538 1
a538 1
				rt_log("parallel, not co-linear\n");
d558 1
a558 1
			rt_log("colinear, t = %g, u = %g\n", dist[0], dist[1] );
d562 4
d570 1
a570 1
		rt_log("intersection, t = %g, u = %g\n", dist[0], dist[1] );
d616 1
a616 1
	fastf_t		fuzz;
d620 5
d631 3
a633 2
	if( (fuzz = MAGSQ(c)) < tol->dist_sq )  {
		return -4;		/* points A and B are not distinct */
d638 2
a639 1
		return -3;		/* No intersection found */
d642 1
a642 1
		fastf_t	ptol;
d645 7
a651 3
		ptol = tol->dist / sqrt( d[X]*d[X] + d[Y]*d[Y] );
		if( dist[0] > -ptol && dist[0] < ptol )  dist[0] = 0;
		else if( dist[0] > 1-ptol && dist[0] < 1+ptol ) dist[0] = 1;
d653 4
a656 3
		if( dist[1] > -ptol && dist[1] < ptol )  dist[1] = 0;
		else if( dist[1] > 1-ptol && dist[1] < 1+ptol ) dist[1] = 1;
		return 0;		/* Colinear */
d660 37
a696 1
	 *  The two lines intersect at a point.
d704 12
a715 5
	fuzz = tol->dist / sqrt(fuzz);
	if( dist[1] < -fuzz )
		return -2;		/* Intersection < A */
	if( (f=(dist[1]-1)) > fuzz )
		return -1;		/* Intersection > B */
d717 2
a718 2
	/* Check for fuzzy intersection with one of the verticies */
	if( dist[1] < fuzz )  {
d720 2
a721 1
		return 1;		/* Intersection at A */
d723 1
a723 1
	if( f >= -fuzz )  {
d725 2
a726 1
		return 2;		/* Intersection at B */
d728 7
a734 1
	return 3;			/* Intersection between A and B */
d1442 5
a1446 1
	VUNITIZE(ABunit);
d1464 81
@


10.15
log
@Added rt_isect_lseg3_lseg3().
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.14 94/01/22 05:17:40 mike Exp Locker: mike $ (BRL)";
d183 1
d185 12
@


10.14
log
@Added rt_dist_line2_point2(), rt_distsq_line2_point2().
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.13 94/01/12 02:50:10 mike Exp Locker: mike $ (BRL)";
d737 109
d872 2
@


10.13
log
@Added new routine.
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.12 93/08/12 22:26:31 mike Exp Locker: mike $ (BRL)";
d1094 51
@


10.12
log
@CONST args to rt_angle_measure.
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.11 93/05/20 17:10:48 mike Exp Locker: mike $ (BRL)";
d29 7
d1322 122
@


10.11
log
@Changed rt_isect_ray_plane to rt_isect_line3_plane(), adding "tol"
parameter.  It now reports when ray lies ON the plane.
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.10 93/05/19 20:44:59 butler Exp Locker: mike $ (BRL)";
d1465 2
a1466 2
vect_t	x_dir;
vect_t	y_dir;
@


10.10
log
@fixed comment for rt_isect_line_lseg()
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.9 1993/03/25 18:05:02 mm Exp butler $ (BRL)";
d236 1
a236 1
 *			R T _ I S E C T _ R A Y _ P L A N E
d238 3
a240 2
 *  Intersect a ray with a plane that has an outward pointing normal.
 *  The ray direction vector need not have unit length.
d245 3
a247 2
 *	 0	hit (ray is entering halfspace)
 *	 1	hit (ray is leaving)
d253 1
a253 1
rt_isect_ray_plane( dist, pt, dir, plane )
d258 1
d263 2
d270 1
a270 1
		return(0);			/* HIT, entering */
d273 1
a273 1
		return(1);			/* HIT, leaving */
d280 5
a284 3
	if( norm_dist < 0.0 )
		return(-2);	/* missed, outside */
	return(-1);		/* missed, inside */
@


10.9
log
@improved rt_3pts_collinear
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.8 1993/03/24 22:23:22 mm Exp $ (BRL)";
d951 1
a951 1
 *	-2	Intersection exists, < A (t is returned)
@


10.8
log
@added rt_3pts_collinear
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.7 1993/03/17 01:18:29 mike Exp mm $ (BRL)";
d29 2
d58 1
a58 1
 *	1	If all 3 points are collinear
d64 1
a64 1
fastf_t	tol;
d66 2
a67 1
	vect_t	v1, v2, v3;
d69 7
a75 6
	VSUB2(v1, b, a);
	VUNITIZE(v1);
	VSUB2(v2, c, a);
	VUNITIZE(v2);
	VREVERSE(v3, v2);
	return(VAPPROXEQUAL(v1, v2, tol) || VAPPROXEQUAL(v1, v3, tol));
@


10.7
log
@Changed rt_dist_pt_lseg() to rt_dist_pt3_lseg3().
Return code is now a flag to indicate which of 6 cases have happened.
Distance is returned via a pointer instead.
Changed calling sequence, so name was changed.
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.6 93/03/17 00:28:34 mike Exp Locker: mike $ (BRL)";
d49 25
@


10.6
log
@Fixed nasty subtle bug in rt_dist_pt_lseg():
It was comparing the distance between the *projection* of P onto
the line to the end points, rather than from P itself.
This produced cases where P was a long ways away from an end point,
yet it was being declared as "on" the end point.
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.5 93/03/16 01:18:43 mike Exp Locker: mike $ (BRL)";
d1160 1
a1160 1
 *			R T _ D I S T _ P T _ L S E G
d1162 2
a1163 2
 *	Find the distance from a point P to a line segment described
 *	by the two endpoints A and B.
d1176 8
a1183 1
 *  There are six distinct cases:
d1185 1
a1185 3
 *	Explicit return
 *	    distance from the point of closest approach on lseg to point
 *	    0.0 if within tol->dist of A or B or the line segment.
a1186 3
 *	Implicit return
 *	    pca 	the point of closest approach
 *
d1190 3
a1192 1
double rt_dist_pt_lseg(pca, a, b, p, tol)
d1209 1
a1209 1
		rt_log("rt_dist_pt_lseg() a=(%g,%g,%g) b=(%g,%g,%g)\n\tp=(%g,%g,%g), tol->dist=%g sq=%g\n",
d1222 2
a1223 1
		return 0.0;
d1232 2
a1233 1
		return 0.0;
d1244 1
a1244 1
		rt_log("rt_dist_pt_lseg() B_A=%g, t=%g\n",
d1249 2
a1250 1
		/* P is "below" A */
d1252 2
a1253 2
		if( rt_g.debug & DEBUG_MATH )  rt_log("  below A\n");
		return sqrt(P_A_sq);
d1256 1
a1256 1
		/* P falls between A and B */
d1266 4
a1269 2
			if( rt_g.debug & DEBUG_MATH )  rt_log("  on lseg\n");
			return 0.0;
d1272 2
a1273 1
		return sqrt(dsq);
d1275 2
a1276 1
	/* P is "above" B */
d1278 2
a1279 2
	if( rt_g.debug & DEBUG_MATH )  rt_log("  above B\n");
	return sqrt(P_B_sq);
@


10.5
log
@Moved 2d line routines from nmg_inter.c to plane.c
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.4 93/02/11 21:58:11 mike Exp Locker: mike $ (BRL)";
d27 1
d70 1
d129 2
d389 2
a390 2
#	if DEBUG_2D_LINES
		rt_log("rt_isect_line_line2() p=(%g,%g), d=(%g,%g)\n\t\ta=(%g,%g), c=(%g,%g)\n",
d392 1
a392 1
#	endif
d458 1
a458 1
#			if DEBUG_2D_LINES
d460 1
a460 1
#			endif
d478 1
a478 1
#		if DEBUG_2D_LINES
d480 1
a480 1
#		endif
d486 1
a486 1
#	if DEBUG_2D_LINES
d488 1
a488 1
#	endif
d635 1
a635 1
#	if DEBUG_2D_LINES
d638 1
a638 1
#	endif
d650 1
a650 1
#		if DEBUG_2D_LINES
d652 1
a652 1
#		endif
d663 1
a663 1
#		if DEBUG_2D_LINES
d665 1
a665 1
#		endif
d678 1
a678 1
#	if DEBUG_2D_LINES
d680 1
a680 1
#	endif
d682 1
a682 1
#		if DEBUG_2D_LINES
d684 1
a684 1
#		endif
d687 1
a687 1
#	if DEBUG_2D_LINES
d689 1
a689 1
#	endif
d738 2
d958 2
d1122 2
d1165 13
d1194 1
d1196 4
a1199 2
	fastf_t	seglen;		/* |B-A| */
	fastf_t	seglen_sq;
d1201 12
a1212 1
	
d1214 16
d1231 1
a1231 2
	seglen_sq = MAGSQ(AtoB);
	seglen = sqrt(seglen_sq);
d1233 8
a1240 2
	/* compute distance (in actual units) along line to pca */
	t = VDOT(PtoA, AtoB) / seglen;
d1242 1
a1242 1
	if( t < -tol->dist )  {
d1245 2
a1246 1
		return MAGNITUDE(PtoA);
d1248 1
a1248 6
	if( t < tol->dist )  {
		/* P is within the tol->dist radius circle around A */
		VMOVE( pca, a );
		return 0.0;
	}
	if( t < seglen - tol->dist )  {
d1254 1
a1254 1
		param_dist = VDOT(PtoA, AtoB) / seglen_sq;
d1257 3
a1259 2
		/* Find distance from PCA to line segment */
		if( (dsq = VDOT( PtoA, PtoA ) - t * t ) <= tol->dist_sq )  {
d1262 1
a1264 5
	if( t < seglen + tol->dist )  {
		/* P is within the tol->dist radius circle around B */
		VMOVE( pca, b );
		return 0.0;
	}
d1267 2
a1268 2
	VSUB2(PtoA, p, b);
	return MAGNITUDE(PtoA);
d1357 2
@


10.4
log
@Added extra return code from rt_isect_line3_line3
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.3 93/02/06 04:25:53 mike Exp Locker: mike $ (BRL)";
d29 21
d342 348
d802 6
d936 1
@


10.3
log
@Fixed line intersector, so it can tell the difference between
parallel and colinear lines.
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.2 92/02/25 00:01:46 mike Exp Locker: mike $ (BRL)";
d321 1
a321 1
 *			R T _ I S E C T _ 2 L I N E S
d349 1
a349 1
rt_isect_2lines( t, u, p, d, a, c, tol )
d540 3
a542 2
 *	-3	A and B are not distinct points
 *	-2	Intersection exists, but is outside of A--B
d560 1
d584 1
a584 1
		return(-3);		/* points A and B are not distinct */
d587 1
a587 1
	if( (ret = rt_isect_2lines( t, &u, p, d, a, c, tol )) < 0 )  {
d607 1
a607 1
		return(-2);		/* Intersection outside of A--B */
d609 1
a609 1
		return(-2);		/* Intersection outside of A--B */
@


10.2
log
@Moved in rt_angle_measure() from nmg_comb.c
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 10.1 91/10/12 06:40:53 mike Rel4_0 Locker: mike $ (BRL)";
d336 1
d362 1
d461 2
a462 2
	 *  If det(M) is zero, then there is no solution; otherwise,
	 *  exactly one solution exists.
d466 1
d468 6
d478 1
a478 1
		if( d[q] >= d[r] )  {
d510 1
a510 1
	*t = det * (c[q] * h[r] - h[q] * c[r]);
@


10.1
log
@Release_4.0
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 1.23 91/06/19 21:22:45 mike Exp $ (BRL)";
d944 51
@


1.23
log
@Added rt_coplanar
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 1.22 91/06/14 06:26:08 mike Exp $ (BRL)";
@


1.22
log
@More rigorous algorithm for rt_rotate_bbox
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 1.21 91/05/25 01:35:40 mike Exp $ (BRL)";
d260 1
d262 3
a264 8
	/* Check to see if the planes are parallel */
	d = VDOT( a, b );
	if( RT_VECT_ARE_PARALLEL(d, tol) )  {
		/* See if the planes are identical */
		d = a[3] - b[3];
		if( NEAR_ZERO( d, tol->dist ) )  {
			return(-1);	/* FAIL -- planes are identical */
		}
d897 47
@


1.21
log
@Fixed rt_dist_pt_lseg() to take into account tolerances,
so that if pt is within tolerance of A, B, or the line segment,
the distance is zero.
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 1.20 91/05/18 03:03:32 mike Exp $ (BRL)";
d854 2
a855 2
	point_t		rmin, rmax;
	point_t		pt;
d857 4
a860 2
	MAT4X3PNT( rmin, mat, imin );
	MAT4X3PNT( rmax, mat, imax );
d862 9
a870 23
	VSET( omin, rmin[X], rmin[Y], rmin[Z] );
	VMOVE( omax, omin );

	VSET( pt, rmax[X], rmin[Y], rmin[Z] );
	VMINMAX( omin, omax, pt );

	VSET( pt, rmin[X], rmax[Y], rmin[Z] );
	VMINMAX( omin, omax, pt );

	VSET( pt, rmax[X], rmax[Y], rmin[Z] );
	VMINMAX( omin, omax, pt );

	VSET( pt, rmin[X], rmin[Y], rmax[Z] );
	VMINMAX( omin, omax, pt );

	VSET( pt, rmax[X], rmin[Y], rmax[Z] );
	VMINMAX( omin, omax, pt );

	VSET( pt, rmin[X], rmax[Y], rmax[Z] );
	VMINMAX( omin, omax, pt );

	VSET( pt, rmax[X], rmax[Y], rmax[Z] );
	VMINMAX( omin, omax, pt );
@


1.20
log
@Converted to new tolerance interface
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 1.19 91/04/01 18:36:07 mike Exp $ (BRL)";
d754 1
a754 4

	if (distsq < 0)
		distsq = 0.0;
	else if (distsq > tol->dist_sq)
a759 1
	/* XXX This formula does not give a tol->dist radius around endpts */
d774 1
d778 3
d787 5
a791 3
	vect_t ENDPTtoP, AtoB;
	double Pr_prop;		/* proj of a-p onto a-b as proportion of a-b */
	double distance;	/* distance of point from lseg */
d793 1
a793 1
	VSUB2(ENDPTtoP, p, a);
d795 2
d798 2
a799 2
	/* compute distance along line to pca */
	Pr_prop = VDOT(ENDPTtoP, AtoB) / MAGSQ(AtoB);
d801 4
a804 10
	/* XXX This does not provide a tol->dist circle around endpoints */
	if (Pr_prop < 1.0 && Pr_prop > 0.0) {
		/* pt is along edge of lseg, scale AtoB by Pr_prop to
		 * get a vector from A to the P.C.A.
		 */
		VJOIN1(pca, a, Pr_prop, AtoB);
		VUNITIZE(AtoB);

		distance = rt_dist_line_point(a, AtoB, p);
		return(distance);
d806 9
d816 9
a824 6
	/* pt is closer to an endpoint than to the line segment */
	if (Pr_prop >= 1.0) {
		VSUB2(ENDPTtoP, p, b);
		VMOVE(pca, b);
	} else {
		VMOVE(pca, a);
d826 9
a834 3

	distance = MAGNITUDE(ENDPTtoP);
	return(distance);
@


1.19
log
@Updated comment
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 1.18 91/02/27 22:58:08 mike Exp $ (BRL)";
d26 1
d40 3
a42 3
rt_3pts_distinct( a, b, c, dist_tol_sq )
point_t	a, b, c;
double	dist_tol_sq;
d49 1
a49 1
	if( MAGSQ( B_A ) <= dist_tol_sq )  return(0);
d51 1
a51 1
	if( MAGSQ( C_A ) <= dist_tol_sq )  return(0);
d53 1
a53 1
	if( MAGSQ( C_B ) <= dist_tol_sq )  return(0);
d96 4
a99 4
rt_mk_plane_3pts( plane, a, b, c, dist_tol_sq )
plane_t	plane;
point_t	a, b, c;
double	dist_tol_sq;
d107 1
a107 1
	if( MAGSQ( B_A ) <= dist_tol_sq )  return(-1);
d109 1
a109 1
	if( MAGSQ( C_A ) <= dist_tol_sq )  return(-1);
d111 1
a111 1
	if( MAGSQ( C_B ) <= dist_tol_sq )  return(-1);
d154 2
a155 2
point_t	pt;
plane_t	a, b, c;
d198 4
a201 4
fastf_t	*dist;
point_t	pt;
vect_t	dir;
plane_t	plane;
d249 7
a255 6
rt_isect_2planes( pt, dir, a, b, rpp_min )
point_t	pt;
vect_t	dir;
plane_t	a;
plane_t	b;
vect_t	rpp_min;
a259 3
	/* XXX These should be parameters */
	fastf_t			cos_ang_tol = 0.999999;
	fastf_t			dist_tol = 0.005;
d263 1
a263 1
	if( !NEAR_ZERO( d, cos_ang_tol ) )  {
d266 1
a266 1
		if( NEAR_ZERO( d, dist_tol ) )  {
a338 2
 *  XXX Tolerancing around zero, as always, remains a problem.
 *
d352 8
a359 6
rt_isect_2lines( t, u, p, d, a, c )
fastf_t		*t, *u;
point_t		p;
vect_t		d;
point_t		a;
vect_t		c;
a378 1
#define DIFFERENCE_TOL	(1.0e-10)
d381 1
a381 1
	if( !NEAR_ZERO( det, DIFFERENCE_TOL ) )  {
d511 1
a511 1
	 *  XXX It isn't clear what tolerance to use here.
d514 1
a514 1
	if( !NEAR_ZERO( det, DIFFERENCE_TOL ) )  {
d555 7
a561 6
rt_isect_line_lseg( t, p, d, a, b )
fastf_t		*t;
point_t		p;
vect_t		d;
point_t		a;
point_t		b;
d567 1
a567 2
	/* XXX should be a parameter */
	fastf_t		dist_tol_sq = SMALL_FASTF;
d576 2
a577 2
	if( MAGSQ(c) < dist_tol_sq )  {
		return(-3);		/* A and B are not distinct */
d580 1
a580 1
	if( (ret = rt_isect_2lines( t, &u, p, d, a, c )) < 0 )  {
d594 3
d598 2
a599 1
	if( u < -SQRT_SMALL_FASTF )
d601 1
a601 1
	if( (f=(u-1)) > SQRT_SMALL_FASTF )
d605 1
a605 1
	if( u < SQRT_SMALL_FASTF )
d607 1
a607 1
	if( f >= -SQRT_SMALL_FASTF )
d625 3
a627 3
point_t	pt;
vect_t	dir;
point_t	a;
d634 1
a634 2
	if( (FdotD = VDOT( f, f ) - FdotD * FdotD ) <= 0 ||
	    (FdotD = sqrt( FdotD )) < SQRT_SMALL_FASTF )
d636 1
a636 1
	return( FdotD );
d651 2
a652 2
point_t	pt;
vect_t	dir;
d657 1
a657 2
	if( (PTdotD = VDOT( pt, pt ) - PTdotD * PTdotD ) <= 0 ||
	    (PTdotD = sqrt( PTdotD )) < SQRT_SMALL_FASTF )
d659 1
a659 1
	return( PTdotD );
d670 1
a670 1
register point_t a, b, c;
d692 2
a693 1
/*	R T _ I S E C T _ P T _ L S E G
d719 4
a722 4
int rt_isect_pt_lseg(dist, a, b, p, dist_tol_sq)
fastf_t *dist;		/* distance along line from A to P */
point_t a, b, p;	/* points for line and intersect */
fastf_t dist_tol_sq;	/* dist tol (squared) for pt on line or other-point */
d728 2
a730 5
	fastf_t	APprABunit;	/* Magnitude of the projection of
				 * AtoP onto ABunit
				 */
	fastf_t distsq;		/* distance^2 from parametric line to pt */

d732 1
a732 1
	if (MAGSQ(AtoP) < dist_tol_sq)
d736 1
a736 1
	if (MAGSQ(BtoP) < dist_tol_sq)
d757 1
a757 2

	if (distsq > dist_tol_sq)
d763 1
d770 2
a771 1
/*	R T _ D I S T _ P T _ L S E G
d782 4
a785 2
double rt_dist_pt_lseg(pca, a, b, p)
point_t pca, a, b, p;
d788 1
a788 1
	double Pr_prop;		/* projection of a-p onto a-b as a proportion of a-b */
d797 1
a805 1

a809 1

a817 1

d834 3
a836 3
mat_t		mat;
point_t		imin;
point_t		imax;
d877 2
a878 2
mat_t		mat;
plane_t		iplane;
@


1.18
log
@Added rotate_bbox and rotate_plane
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 1.17 90/12/07 00:45:46 mike Exp $ (BRL)";
a84 6
 *  This is the "right hand rule".
 *
 *  While listing the points in counterclockwise order is "closer"
 *  to the orientation expected for the cross product,
 *  it might have been nice to have listed the points in clockwise
 *  order to match the convention of the NMG face creation routines.
@


1.17
log
@lint
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 1.16 90/12/06 19:58:25 mike Exp $ (BRL)";
d826 78
@


1.16
log
@Fixed subtle, but horible, bug in rt_isect_2planes.
It caused serious trouble for mged/proc_reg.c,
not a pretty place to have to debug from.
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 1.15 90/12/06 19:44:43 mike Exp $ (BRL)";
d603 3
a605 1
	if( u < -SQRT_SMALL_FASTF || (f=(u-1)) > SQRT_SMALL_FASTF )
@


1.15
log
@Minor neatening up.
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 1.14 90/11/01 04:49:14 mike Exp $ (BRL)";
d296 1
a296 1
			VSET( pl, 1, 0, 0 );
d302 1
a302 1
			VSET( pl, 0, 0, 1 );
d310 1
a310 1
			VSET( pl, 0, 1, 0 );
d316 2
a317 2
			VSET( pl, 0, 0, 1 );
			pl[3] = rpp_min[Y];
@


1.14
log
@Added rt_3pts_distinct().
Added dist_tol_sq arg to rt_mk_plane_3pts
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 1.13 90/05/16 07:41:24 butler Exp $ (BRL)";
d264 3
d270 1
a270 2
	/* XXX angular tolerance needed */
	if( !NEAR_ZERO( d, 0.999999 ) )  {
d273 1
a273 2
		/* XXX need distance tolerance */
		if( NEAR_ZERO( d, 0.005 ) )  {
d574 2
d584 1
a584 6
#if 0
	/* Perhaps something like this would be more efficient? */
	if( VNEAR_ZERO( c, 0.005 ) )  return(-3);
#endif
	f = MAGNITUDE(c);		/* always positive */
	if( f < SQRT_SMALL_FASTF )  {
d722 5
a726 6
int rt_isect_pt_lseg(dist, a, b, p, tolsq)
fastf_t *dist;	/* distance along line from A to P */
point_t a, b, p; /* points for line and intersect */
fastf_t tolsq;	/* distance tolerance (squared) for point being */
{		/* on line or other-point */

d738 1
a738 1
	if (MAGSQ(AtoP) < tolsq)
d742 1
a742 1
	if (MAGSQ(BtoP) < tolsq)
d749 3
a751 3
/* This part is similar to rt_dist_line_pt.  The difference being that we
 * never actually have to do the sqrt that the other routine does.
 */
d764 1
a764 1
	if (distsq > tolsq)
d767 1
a767 3
/* at this point we know the distance from the point to the line is
 * within tolerance.
 */
d802 1
a802 1
		 * egt a vector from A to the P.C.A.
@


1.13
log
@rt_dist_pt_lseg debugged (it wasn't really broken)
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 1.12 90/05/13 11:29:09 mike Exp $ (BRL)";
d28 29
a91 2
 *  XXX The tolerance here should be relative to the model diameter, not abs.
 *
d101 1
a101 1
rt_mk_plane_3pts( plane, a, b, c )
d104 1
d112 1
a112 1
	if( VNEAR_ZERO( B_A, 0.005 ) )  return(-1);
d114 1
a114 1
	if( VNEAR_ZERO( C_A, 0.005 ) )  return(-1);
d116 1
a116 1
	if( VNEAR_ZERO( C_B, 0.005 ) )  return(-1);
@


1.12
log
@Added different return codes to rt_isect_2planes
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: /m/cad/librt/RCS/plane.c,v 1.11 90/05/13 11:22:40 butler Exp $ (BRL)";
d768 2
a769 1
	double dist, APdist;
d774 8
a781 4
	dist = VDOT(ENDPTtoP, AtoB) / MAGSQ(AtoB);
	if (dist <= 1.0 && dist >= 0.0) {
		/* pt is along edge of lseg */
		VSCALE(pca, AtoB, dist);
d783 4
a786 1
		return(rt_dist_line_point(a, AtoB, p));
d791 4
a794 5
	APdist = MAGNITUDE(ENDPTtoP);
	VSUB2(ENDPTtoP, p, b);
	dist = MAGNITUDE(ENDPTtoP);

	if (APdist < dist) {
a795 1
		return(APdist);
d798 3
a800 2
	VMOVE(pca, b);
	return(dist);
@


1.11
log
@Fixed minor typos
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: plane.c,v 1.10 90/05/10 08:43:14 butler Locked $ (BRL)";
d217 3
a219 1
 *	-1	FAIL
d239 10
a248 2
	if( !NEAR_ZERO( d, 0.999999 ) )
		return(-1);		/* FAIL -- parallel */
d297 1
a297 1
		return(-1);	/* FAIL -- no intersection */
@


1.10
log
@turned  rt_dist_pt_lseg into what I really wanted (I think ;-)
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: plane.c,v 1.9 90/05/10 05:15:56 butler Locked $ (BRL)";
d690 1
a690 1
{		/ * on line or other-point */
d702 1
a702 1
	VSUB2(AtoP p, a);
d726 3
d768 1
a768 1
		return(rt_dist_pt_line(a, AtoB, p));
@


1.9
log
@added rt_isect_pt_lseg and rt_dist_pt_lseg
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: plane.c,v 1.8 90/03/14 23:10:38 butler Locked $ (BRL)";
d744 6
d751 2
a752 2
double rt_dist_pt_lseg(a, b, p)
point_t a, b, p;
d763 1
d774 6
a779 1
	if (APdist < dist) return(APdist);
@


1.8
log
@Further documented parameters to rt_mk_plane_3pts
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: plane.c,v 1.7 90/03/05 22:23:57 mike Locked $ (BRL)";
d657 112
@


1.7
log
@Improved a comment.
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: plane.c,v 1.6 90/03/03 05:59:21 mike Locked $ (BRL)";
d36 26
@


1.6
log
@Added rt_area_of_triangle().
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: plane.c,v 1.5 89/10/18 14:31:13 mike Locked $ (BRL)";
d32 4
a35 2
 *  so C had better be counter-clockwise from B to follow the
 *  BRL-CAD outward-pointing normal convention.
d41 2
a42 1
 *	-1	Failure.  At least two of the points were not distinct.
@


1.5
log
@Added rt_dist_line_point() and rt_dist_line_origin()
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: plane.c,v 1.1 89/10/10 16:05:53 mike Exp $ (BRL)";
d599 29
@


1.4
log
@Added rt_isect_2lines()
@
text
@d551 8
a558 3
 * Still to come:
 *	Closest Distance between a line and the origin,
 *	Closest Distance between a line and a point.
d560 40
@


1.3
log
@For ray-meets-plane, distinguish between "in" and "on".
@
text
@d4 1
a4 1
 *  Some useful routines for dealing with planes.
d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: plane.c,v 1.2 89/10/13 20:38:35 mike Locked $ (BRL)";
d80 13
d106 1
a106 1
	register fastf_t d;
d108 1
d110 9
a118 3
	d = VDOT( a, v1 );
	if( NEAR_ZERO( d, SQRT_SMALL_FASTF ) )  return(-1);
	d = 1/d;
d122 4
a125 3
	pt[X] = d*(a[3]*v1[X] - b[3]*v2[X] + c[3]*v3[X]);
	pt[Y] = d*(a[3]*v1[Y] - b[3]*v2[Y] + c[3]*v3[Y]);
	pt[Z] = d*(a[3]*v1[Z] - b[3]*v2[Z] + c[3]*v3[Z]);
d136 1
a136 2
 *	-3	missed (ray is outside halfspace)
 *	-2	"missed" (ray lies on plane)
d169 3
a171 5
	if( norm_dist < SQRT_SMALL_FASTF )
		return(-3);	/* missed, outside */
	if( norm_dist > SQRT_SMALL_FASTF )
		return(-1);	/* missed, inside */
	return(-2);		/* "missed", ray lies on plane */
a173 4
static plane_t	xpl = { 1, 0, 0, 0 };
static plane_t	ypl = { 0, 1, 0, 0 };
static plane_t	zpl = { 0, 0, 1, 0 };

d184 1
a184 1
 *  RPP.  If this is unnecessary, just pass (0,0,0).
d213 1
a213 1
	VUNITIZE( dir );		/* safety? */
d228 1
a228 1
			VMOVE( pl, xpl);
d234 1
a234 1
			VMOVE( pl, zpl);
d242 1
a242 1
			VMOVE( pl, ypl);
d248 1
a248 1
			VMOVE( pl, zpl);
d262 293
@


1.2
log
@Added  rt_isect_2planes()
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header: plane.c,v 1.1 89/10/10 16:05:53 mike Exp $ (BRL)";
d115 2
a116 1
 *	-2	missed (ray is outside halfspace)
d149 5
a153 3
	if( norm_dist < 0.0 )
		return(-2);	/* missed, outside */
	return(-1);		/* missed, inside */
@


1.1
log
@Initial revision
@
text
@d18 1
a18 1
static char RCSplane[] = "@@(#)$Header$ (BRL)";
d37 1
a37 1
 *  Returns -
d40 3
d80 1
a80 1
 *  Returns -
d83 3
d102 3
a104 4
	pt[X] = a[3]*v1[X] - b[3]*v2[X] + c[3]*v3[X];
	pt[Y] = a[3]*v1[Y] - b[3]*v2[Y] + c[3]*v3[Y];
	pt[Z] = a[3]*v1[Z] - b[3]*v2[Z] + c[3]*v3[Z];
	VSCALE( pt, pt, d );
d151 93
@
