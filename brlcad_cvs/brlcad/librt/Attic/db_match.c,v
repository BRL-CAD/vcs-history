head	1.17;
access;
symbols
	ansi-20040405-merged:1.13.2.2
	postmerge-20040405-ansi:1.15
	premerge-20040404-ansi:1.14
	postmerge-autoconf:1.14
	autoconf-freeze:1.13.10.2
	premerge-autoconf:1.14
	ansi-20040316-freeze:1.13.2.1
	postmerge-20040315-windows:1.14
	premerge-20040315-windows:1.14
	windows-20040315-freeze:1.13.4.1
	autoconf-20031203:1.13
	autoconf-20031202:1.13
	autoconf-branch:1.13.0.10
	phong-branch:1.13.0.8
	photonmap-branch:1.13.0.6
	rel-6-1-DP:1.13
	windows-branch:1.13.0.4
	rel-6-0-2:1.11
	ansi-branch:1.13.0.2
	rel-6-0-1-branch:1.11.0.2
	hartley-6-0-post:1.12
	hartley-6-0-pre:1.11
	rel-6-0-1:1.11
	rel-6-0:1.10
	rel-5-4:1.5
	offsite-5-3-pre:1.9
	rel-5-3:1.5
	rel-5-2:1.5
	rel-5-1-branch:1.5.0.2
	rel-5-1:1.5
	rel-5-0:1.2
	rel-5-0-beta:1.2
	rel-4-5:1.2
	ctj-4-5-post:1.2
	ctj-4-5-pre:1.2;
locks; strict;
comment	@ * @;


1.17
date	2004.05.21.18.07.29;	author morrison;	state dead;
branches;
next	1.16;

1.16
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	1.15;

1.15
date	2004.04.05.08.48.56;	author morrison;	state Exp;
branches;
next	1.14;

1.14
date	2004.02.02.17.39.15;	author morrison;	state Exp;
branches;
next	1.13;

1.13
date	2002.08.20.17.07.57;	author jra;	state Exp;
branches
	1.13.2.1
	1.13.4.1
	1.13.10.1;
next	1.12;

1.12
date	2002.08.15.20.55.09;	author hartley;	state Exp;
branches;
next	1.11;

1.11
date	2002.07.13.17.45.27;	author jra;	state Exp;
branches;
next	1.10;

1.10
date	2001.04.20.22.29.41;	author morrison;	state Exp;
branches;
next	1.9;

1.9
date	2000.09.08.05.54.41;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	2000.09.01.04.31.53;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	2000.07.10.23.01.27;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	2000.06.29.14.44.11;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	99.12.22.02.17.58;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	99.11.26.22.14.14;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	99.11.24.23.07.17;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	97.06.30.13.35.47;	author gdurf;	state Exp;
branches;
next	1.1;

1.1
date	97.06.17.18.48.15;	author gdurf;	state Exp;
branches;
next	;

1.13.2.1
date	2002.09.19.18.01.31;	author morrison;	state Exp;
branches;
next	1.13.2.2;

1.13.2.2
date	2004.03.17.21.18.44;	author morrison;	state Exp;
branches;
next	;

1.13.4.1
date	2004.03.11.23.43.35;	author morrison;	state Exp;
branches;
next	;

1.13.10.1
date	2004.02.12.18.37.38;	author erikg;	state Exp;
branches;
next	1.13.10.2;

1.13.10.2
date	2004.03.15.14.07.17;	author erikg;	state Exp;
branches;
next	;


desc
@@


1.17
log
@moved to src/
@
text
@/*
 *			D B _ M A T C H . C
 *
 * Functions -
 *	db_regexp_match		Determine if a string matches a regexp pattern
 *	db_regexp_match_all	Return a vls filled with all names matching
 *				the given pattern
 *	db_update_nref		Updates the d_nref fields of each member of
 *				the directory in the given database.
 *
 *  Author -
 *	Michael John Muuss
 *	Glenn Durfee
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1994-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */

#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/db_match.c,v 1.16 2004/05/10 15:30:46 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>

#include "machine.h"
#include "vmath.h"
#include "db.h"
#include "raytrace.h"
#include "rtgeom.h"

#include "./debug.h"

/*
 *			D B _ R E G E X P _ M A T C H
 *
 *	If string matches pattern, return 1, else return 0
 *
 *	special characters:
 *		*	Matches any string including the null string.
 *		?	Matches any single character.
 *		[...]	Matches any one of the characters enclosed.
 *		-	May be used inside brackets to specify range
 *			(i.e. str[1-58] matches str1, str2, ... str5, str8)
 *		\	Escapes special characters.
 */
int
db_regexp_match(register const char *pattern, register const char *string)
{
	do {
		switch( *pattern ) {
		case '*':
			/* match any string including null string */
			++pattern;
			do {
				if( db_regexp_match( pattern, string ) )
					return( 1 );
			} while( *string++ != '\0' );
			return( 0 );
		case '?':
			/* match any character  */
			if( *string == '\0' )
				return( 0 );
			break;
		case '[':
			/* try to match one of the characters in brackets */
			++pattern;
			if( *pattern == '\0' )
				return( 0 );
			while( *pattern != *string ) {
				if( pattern[0] == '-' && pattern[-1] != '\\')
					if(	pattern[-1] <= *string &&
						pattern[-1] != '[' &&
						pattern[ 1] >= *string &&
						pattern[ 1] != ']' )
						break;
				++pattern;
				if( *pattern == '\0' || *pattern == ']' )
					return( 0 );
			}
			/* skip to next character after closing bracket */
			while( *pattern != '\0' && *pattern != ']' )
				++pattern;
			break;
		case '\\':
			/* escape special character */
			++pattern;
			/* compare characters */
			if( *pattern != *string )
				return( 0 );
			break;
		default:
			/* compare characters */
			if( *pattern != *string )
				return( 0 );
		}
		++string;
	} while( *pattern++ != '\0' );
	return( 1 );
}



/*
 *			D B _ R E G E X P _ M A T C H _ A L L
 *
 * Appends a list of all database matches to the given vls, or the pattern
 * itself if no matches are found.
 * Returns the number of matches.
 */
 
int
db_regexp_match_all(struct bu_vls *dest, struct db_i *dbip, const char *pattern)
{
	register int i, num;
	register struct directory *dp;

	for( i = num = 0; i < RT_DBNHASH; i++ )  {
		for( dp = dbip->dbi_Head[i]; dp != DIR_NULL; dp = dp->d_forw ){
			if( !db_regexp_match( pattern, dp->d_namep ) )
				continue;
			if( num == 0 )
				bu_vls_strcat( dest, dp->d_namep );
			else {
				bu_vls_strcat( dest, " " );
				bu_vls_strcat( dest, dp->d_namep );
			}
			++num;
		}
	}

	return num;
}


HIDDEN void
db_count_refs(struct db_i *dbip, struct rt_comb_internal *comb, union tree *comb_leaf, genptr_t dummy1, genptr_t dummy2, genptr_t dummy3)
{
	struct directory	*dp;

	RT_CK_TREE( comb_leaf );

	if( (dp=db_lookup(dbip, comb_leaf->tr_l.tl_name, LOOKUP_QUIET)) != DIR_NULL )
		++dp->d_nref;
}


/*
 *			D B _ U P D A T E _ N R E F
 *
 * Updates the d_nref fields (which count the number of times a given entry
 * is referenced by a COMBination in the database).
 *
 */

void
db_update_nref( struct db_i *dbip, struct resource *resp )
{
	register int			i;
	register struct directory      *dp;
	struct rt_db_internal		intern;
	struct rt_comb_internal	       *comb;

	RT_CK_DBI( dbip );
	RT_CK_RESOURCE(resp);

	/* First, clear any existing counts */
	for( i = 0; i < RT_DBNHASH; i++ )
		for( dp = dbip->dbi_Head[i]; dp != DIR_NULL; dp = dp->d_forw )
			dp->d_nref = 0;

	/* Examine all COMB nodes */
	for( i = 0; i < RT_DBNHASH; i++ )  {
		for( dp = dbip->dbi_Head[i]; dp != DIR_NULL; dp = dp->d_forw ){

			/* handle non-combination objects that reference other objects */
			if( dp->d_major_type == DB5_MAJORTYPE_BRLCAD ) {
				struct directory *dp2;

				if( dp->d_minor_type == DB5_MINORTYPE_BRLCAD_EXTRUDE ) {
					struct rt_extrude_internal *extr;

					if( rt_db_get_internal(&intern, dp, dbip, (fastf_t *)NULL, resp) < 0 )
						continue;
					extr = (struct rt_extrude_internal *)intern.idb_ptr;
					RT_EXTRUDE_CK_MAGIC( extr );
					if( extr->sketch_name ) {
						dp2 = db_lookup( dbip, extr->sketch_name, LOOKUP_QUIET );
						if( dp2 != DIR_NULL ) {
							dp2->d_nref++;
						}
					}
					rt_db_free_internal( &intern, resp );
				} else if( dp->d_minor_type ==  DB5_MINORTYPE_BRLCAD_DSP ) {
					struct rt_dsp_internal *dsp;

					if( rt_db_get_internal(&intern, dp, dbip, (fastf_t *)NULL, resp) < 0 )
						continue;
					dsp = (struct rt_dsp_internal *)intern.idb_ptr;
					RT_DSP_CK_MAGIC( dsp );
					if( dsp->dsp_datasrc == RT_DSP_SRC_OBJ && bu_vls_strlen( &dsp->dsp_name) > 0 ) {
						dp2 = db_lookup( dbip, bu_vls_addr( &dsp->dsp_name ), LOOKUP_QUIET );
						if( dp2 != DIR_NULL ) {
							dp2->d_nref++;
						}
					}
					rt_db_free_internal( &intern, resp );
				}
			}
			if( !(dp->d_flags & DIR_COMB) )
				continue;
			if( rt_db_get_internal(&intern, dp, dbip, (fastf_t *)NULL, resp) < 0 )
				continue;
			if( intern.idb_type != ID_COMBINATION )  {
				bu_log("NOTICE: %s was marked a combination, but isn't one?  Clearing flag\n",
					dp->d_namep);
				dp->d_flags &= ~DIR_COMB;
				rt_db_free_internal( &intern, resp );
				continue;
			}
			comb = (struct rt_comb_internal *)intern.idb_ptr;
			db_tree_funcleaf( dbip, comb, comb->tree,
					  db_count_refs, (genptr_t)NULL,
					  (genptr_t)NULL, (genptr_t)NULL );
			rt_db_free_internal( &intern, resp );
		}
	}
}
@


1.16
log
@change conf.h to a wrapped config.h
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/librt/db_match.c,v 1.15 2004/04/05 08:48:56 morrison Exp $ (ARL)";
@


1.15
log
@merge of ansi-6-0-branch into HEAD
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d33 5
a37 1
#include "conf.h"
@


1.14
log
@update copyright to include span through 2003
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_match.c,v 1.13 2002/08/20 17:07:57 jra Exp $ (ARL)";
d59 1
a59 2
db_regexp_match( pattern, string )
register const char *pattern, *string;
d124 1
a124 4
db_regexp_match_all( dest, dbip, pattern )
struct bu_vls	*dest;
struct db_i	*dbip;
const char	*pattern;
d148 1
a148 5
db_count_refs( dbip, comb, comb_leaf, dummy1, dummy2, dummy3 )
struct db_i		*dbip;
struct rt_comb_internal *comb;
union tree		*comb_leaf;
genptr_t		 dummy1, dummy2, dummy3;
@


1.13
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d25 1
a25 1
 *	This software is Copyright (C) 1994 by the United States Army
d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_match.c,v 1.11 2002/07/13 17:45:27 jra Exp $ (ARL)";
@


1.13.4.1
log
@sync to HEAD...
@
text
@d25 1
a25 1
 *	This software is Copyright (C) 1994-2004 by the United States Army
d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/db_match.c,v 1.14 2004/02/02 17:39:15 morrison Exp $ (ARL)";
@


1.13.10.1
log
@merge from HEAD
@
text
@d25 1
a25 1
 *	This software is Copyright (C) 1994-2004 by the United States Army
d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_match.c,v 1.14 2004/02/02 17:39:15 morrison Exp $ (ARL)";
@


1.13.10.2
log
@merge from head
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_match.c,v 1.13.10.1 2004/02/12 18:37:38 erikg Exp $ (ARL)";
@


1.13.2.1
log
@Initial ANSIfication
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_match.c,v 1.13 2002/08/20 17:07:57 jra Exp $ (ARL)";
d59 2
a60 1
db_regexp_match(register const char *pattern, register const char *string)
d125 4
a128 1
db_regexp_match_all(struct bu_vls *dest, struct db_i *dbip, const char *pattern)
d152 5
a156 1
db_count_refs(struct db_i *dbip, struct rt_comb_internal *comb, union tree *comb_leaf, genptr_t dummy1, genptr_t dummy2, genptr_t dummy3)
@


1.13.2.2
log
@sync branch with HEAD
@
text
@d25 1
a25 1
 *	This software is Copyright (C) 1994-2004 by the United States Army
d30 1
a30 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
@


1.12
log
@Converted from K&R to ANSI C - RFH
@
text
@d59 2
a60 1
db_regexp_match(register const char *pattern, register const char *string)
d125 4
a128 1
db_regexp_match_all(struct bu_vls *dest, struct db_i *dbip, const char *pattern)
d152 5
a156 1
db_count_refs(struct db_i *dbip, struct rt_comb_internal *comb, union tree *comb_leaf, genptr_t dummy1, genptr_t dummy2, genptr_t dummy3)
@


1.11
log
@Mods to db_update_nref() to handle DSP and Extrusions (tops command will now handle them correctly)
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_match.c,v 1.10 2001/04/20 22:29:41 morrison Exp $ (ARL)";
d59 1
a59 2
db_regexp_match( pattern, string )
register const char *pattern, *string;
d124 1
a124 4
db_regexp_match_all( dest, dbip, pattern )
struct bu_vls	*dest;
struct db_i	*dbip;
const char	*pattern;
d148 1
a148 5
db_count_refs( dbip, comb, comb_leaf, dummy1, dummy2, dummy3 )
struct db_i		*dbip;
struct rt_comb_internal *comb;
union tree		*comb_leaf;
genptr_t		 dummy1, dummy2, dummy3;
@


1.10
log
@CONST to const
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_match.c,v 1.9 2000/09/08 05:54:41 mike Exp $ (ARL)";
d41 1
d194 35
@


1.9
log
@
Modified tree routines to take resource pointer.
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_match.c,v 1.8 2000/09/01 04:31:53 mike Exp $ (ARL)";
d59 1
a59 1
register CONST char *pattern, *string;
d127 1
a127 1
CONST char	*pattern;
@


1.8
log
@
Added error checking.
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_match.c,v 1.7 2000/07/10 23:01:27 mike Exp $ (ARL)";
d175 1
a175 2
db_update_nref( dbip )
struct db_i    *dbip;
d183 1
d195 1
a195 1
			if( rt_db_get_internal(&intern, dp, dbip, (fastf_t *)NULL) < 0 )
d201 1
a201 1
				rt_db_free_internal( &intern );
d208 1
a208 1
			rt_db_free_internal( &intern );
@


1.7
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_match.c,v 1.6 2000/06/29 14:44:11 mike Exp $ (ARL)";
d198 3
@


1.6
log
@
rt_db_free_internal
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_match.c,v 1.5 1999/12/22 02:17:58 mike Exp $ (ARL)";
@


1.5
log
@
Eliminated dead vars
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_match.c,v 1.4 1999/11/26 22:14:14 mike Exp $ (ARL)";
d191 1
a191 1
	for( i = 0; i < RT_DBNHASH; i++ )
d197 2
a198 1
			if( intern.idb_type != ID_COMBINATION )
d200 1
d205 1
a205 1
			intern.idb_meth->ft_ifree( &intern );
d207 1
@


1.4
log
@
lint
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_match.c,v 1.3 1999/11/24 23:07:17 mike Exp $ (ARL)";
d178 1
a178 1
	register int			i, j;
@


1.3
log
@
ft_ifree
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_match.c,v 1.2 1997/06/30 13:35:47 gdurf Exp $ (ARL)";
d195 1
a195 1
			if( rt_db_get_internal(&intern, dp, dbip, (matp_t *)NULL) < 0 )
@


1.2
log
@Added db_update_nref() (from MGED) for use by librt
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_match.c,v 1.1 1997/06/17 18:48:15 gdurf Exp gdurf $ (ARL)";
d203 1
a203 1
			rt_db_free_internal( &intern );
@


1.1
log
@Initial revision
@
text
@d8 2
d30 1
a30 1
static char RCSid[] = "@@(#)$Header: $ (ARL)";
d35 2
d59 1
a59 1
register char *pattern, *string;
a120 2
 *
 * XXX need to extern this guy for mged
d127 1
a127 1
char		*pattern;
d147 58
@
