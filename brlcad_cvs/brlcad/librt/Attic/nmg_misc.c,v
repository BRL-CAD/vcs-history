head	11.99;
access;
symbols
	ansi-20040405-merged:11.93.2.2
	postmerge-20040405-ansi:11.97
	premerge-20040404-ansi:11.96
	postmerge-autoconf:11.96
	autoconf-freeze:11.95.6.2
	premerge-autoconf:11.96
	ansi-20040316-freeze:11.93.2.1
	postmerge-20040315-windows:11.96
	premerge-20040315-windows:11.96
	windows-20040315-freeze:11.93.4.1
	autoconf-20031203:11.95
	autoconf-20031202:11.95
	autoconf-branch:11.95.0.6
	phong-branch:11.95.0.4
	photonmap-branch:11.95.0.2
	rel-6-1-DP:11.93
	windows-branch:11.93.0.4
	rel-6-0-2:11.91
	ansi-branch:11.93.0.2
	rel-6-0-1-branch:11.91.0.2
	hartley-6-0-post:11.92
	hartley-6-0-pre:11.91
	rel-6-0-1:11.91
	rel-6-0:11.90
	rel-5-4:11.79.2.1
	offsite-5-3-pre:11.86
	rel-5-3:11.79.2.1
	rel-5-2:11.79
	rel-5-1-branch:11.79.0.2
	rel-5-1:11.79
	rel-5-0:11.72
	rel-5-0-beta:11.70
	rel-4-5:11.65
	ctj-4-5-post:11.63
	ctj-4-5-pre:11.59
	rel-4-4:11.1
	rel-4-0:1.29;
locks; strict;
comment	@ * @;


11.99
date	2004.05.21.18.07.33;	author morrison;	state dead;
branches;
next	11.98;

11.98
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.97;

11.97
date	2004.04.05.08.48.57;	author morrison;	state Exp;
branches;
next	11.96;

11.96
date	2004.02.02.17.39.24;	author morrison;	state Exp;
branches;
next	11.95;

11.95
date	2002.12.13.20.09.22;	author jra;	state Exp;
branches
	11.95.6.1;
next	11.94;

11.94
date	2002.11.27.13.42.56;	author jra;	state Exp;
branches;
next	11.93;

11.93
date	2002.08.20.17.08.05;	author jra;	state Exp;
branches
	11.93.2.1
	11.93.4.1;
next	11.92;

11.92
date	2002.08.15.20.55.16;	author hartley;	state Exp;
branches;
next	11.91;

11.91
date	2002.08.06.16.06.13;	author jra;	state Exp;
branches;
next	11.90;

11.90
date	2001.10.02.19.24.31;	author jra;	state Exp;
branches;
next	11.89;

11.89
date	2001.08.21.17.02.19;	author jra;	state Exp;
branches;
next	11.88;

11.88
date	2001.04.05.19.35.35;	author morrison;	state Exp;
branches;
next	11.87;

11.87
date	2001.03.31.01.57.11;	author morrison;	state Exp;
branches;
next	11.86;

11.86
date	2000.10.24.19.31.45;	author mike;	state Exp;
branches;
next	11.85;

11.85
date	2000.09.08.05.54.42;	author mike;	state Exp;
branches;
next	11.84;

11.84
date	2000.08.25.05.18.56;	author mike;	state Exp;
branches;
next	11.83;

11.83
date	2000.08.21.02.02.32;	author butler;	state Exp;
branches;
next	11.82;

11.82
date	2000.07.14.17.14.05;	author jra;	state Exp;
branches;
next	11.81;

11.81
date	2000.07.10.23.01.43;	author mike;	state Exp;
branches;
next	11.80;

11.80
date	2000.06.29.18.20.56;	author mike;	state Exp;
branches;
next	11.79;

11.79
date	2000.05.02.01.56.00;	author mike;	state Exp;
branches
	11.79.2.1;
next	11.78;

11.78
date	2000.05.02.01.46.04;	author mike;	state Exp;
branches;
next	11.77;

11.77
date	2000.03.29.02.36.04;	author mike;	state Exp;
branches;
next	11.76;

11.76
date	2000.03.29.01.17.23;	author mike;	state Exp;
branches;
next	11.75;

11.75
date	2000.03.28.22.00.10;	author mike;	state Exp;
branches;
next	11.74;

11.74
date	99.12.30.15.17.00;	author jra;	state Exp;
branches;
next	11.73;

11.73
date	99.11.24.14.39.52;	author jra;	state Exp;
branches;
next	11.72;

11.72
date	99.08.23.12.54.26;	author jra;	state Exp;
branches;
next	11.71;

11.71
date	99.06.03.01.01.26;	author mike;	state Exp;
branches;
next	11.70;

11.70
date	99.05.19.16.48.31;	author jra;	state Exp;
branches;
next	11.69;

11.69
date	99.05.10.03.01.55;	author jra;	state Exp;
branches;
next	11.68;

11.68
date	98.07.30.19.51.15;	author jra;	state Exp;
branches;
next	11.67;

11.67
date	98.03.19.15.57.01;	author jra;	state Exp;
branches;
next	11.66;

11.66
date	98.02.22.23.32.58;	author jra;	state Exp;
branches;
next	11.65;

11.65
date	97.12.03.06.56.00;	author mike;	state Exp;
branches;
next	11.64;

11.64
date	97.11.21.21.05.09;	author jra;	state Exp;
branches;
next	11.63;

11.63
date	97.08.29.17.03.43;	author jra;	state Exp;
branches;
next	11.62;

11.62
date	97.08.26.14.19.41;	author jra;	state Exp;
branches;
next	11.61;

11.61
date	97.08.20.19.22.56;	author jra;	state Exp;
branches;
next	11.60;

11.60
date	97.08.15.19.22.14;	author jra;	state Exp;
branches;
next	11.59;

11.59
date	97.06.25.04.46.49;	author mike;	state Exp;
branches;
next	11.58;

11.58
date	97.06.13.21.42.51;	author mike;	state Exp;
branches;
next	11.57;

11.57
date	97.05.22.02.12.49;	author mike;	state Exp;
branches;
next	11.56;

11.56
date	97.05.19.11.59.00;	author jra;	state Exp;
branches;
next	11.55;

11.55
date	97.04.16.20.21.46;	author jra;	state Exp;
branches;
next	11.54;

11.54
date	97.04.10.19.54.34;	author jra;	state Exp;
branches;
next	11.53;

11.53
date	96.11.19.20.29.03;	author jra;	state Exp;
branches;
next	11.52;

11.52
date	96.10.25.16.49.47;	author jra;	state Exp;
branches;
next	11.51;

11.51
date	96.10.11.18.34.22;	author jra;	state Exp;
branches;
next	11.50;

11.50
date	96.10.10.20.19.02;	author jra;	state Exp;
branches;
next	11.49;

11.49
date	96.10.10.12.42.58;	author bparker;	state Exp;
branches;
next	11.48;

11.48
date	96.09.27.08.27.30;	author mike;	state Exp;
branches;
next	11.47;

11.47
date	96.09.27.07.20.30;	author mike;	state Exp;
branches;
next	11.46;

11.46
date	96.08.28.05.42.36;	author mike;	state Exp;
branches;
next	11.45;

11.45
date	96.08.27.02.57.48;	author mike;	state Exp;
branches;
next	11.44;

11.44
date	96.05.16.22.09.52;	author jra;	state Exp;
branches;
next	11.43;

11.43
date	96.04.22.12.16.53;	author jra;	state Exp;
branches;
next	11.42;

11.42
date	96.03.28.18.07.05;	author jra;	state Exp;
branches;
next	11.41;

11.41
date	96.03.28.02.33.50;	author butler;	state Exp;
branches;
next	11.40;

11.40
date	96.03.25.21.12.47;	author jra;	state Exp;
branches;
next	11.39;

11.39
date	96.03.17.23.58.09;	author jra;	state Exp;
branches;
next	11.38;

11.38
date	96.03.05.21.32.18;	author jra;	state Exp;
branches;
next	11.37;

11.37
date	96.02.20.16.58.18;	author jra;	state Exp;
branches;
next	11.36;

11.36
date	96.02.16.15.41.17;	author jra;	state Exp;
branches;
next	11.35;

11.35
date	95.12.04.20.33.45;	author jra;	state Exp;
branches;
next	11.34;

11.34
date	95.12.01.02.47.38;	author mike;	state Exp;
branches;
next	11.33;

11.33
date	95.11.28.20.44.11;	author jra;	state Exp;
branches;
next	11.32;

11.32
date	95.11.22.22.30.51;	author jra;	state Exp;
branches;
next	11.31;

11.31
date	95.11.06.17.15.41;	author jra;	state Exp;
branches;
next	11.30;

11.30
date	95.10.31.20.26.28;	author jra;	state Exp;
branches;
next	11.29;

11.29
date	95.10.19.15.00.23;	author jra;	state Exp;
branches;
next	11.28;

11.28
date	95.09.06.13.11.11;	author jra;	state Exp;
branches;
next	11.27;

11.27
date	95.07.14.19.11.24;	author jra;	state Exp;
branches;
next	11.26;

11.26
date	95.06.27.19.45.57;	author jra;	state Exp;
branches;
next	11.25;

11.25
date	95.06.23.21.07.39;	author jra;	state Exp;
branches;
next	11.24;

11.24
date	95.05.05.21.04.11;	author jra;	state Exp;
branches;
next	11.23;

11.23
date	95.05.02.20.46.56;	author jra;	state Exp;
branches;
next	11.22;

11.22
date	95.04.27.12.10.07;	author jra;	state Exp;
branches;
next	11.21;

11.21
date	95.04.07.16.55.04;	author jra;	state Exp;
branches;
next	11.20;

11.20
date	95.04.04.13.23.46;	author jra;	state Exp;
branches;
next	11.19;

11.19
date	95.04.03.20.52.26;	author jra;	state Exp;
branches;
next	11.18;

11.18
date	95.03.24.16.05.02;	author jra;	state Exp;
branches;
next	11.17;

11.17
date	95.03.17.15.02.48;	author jra;	state Exp;
branches;
next	11.16;

11.16
date	95.03.09.13.31.15;	author jra;	state Exp;
branches;
next	11.15;

11.15
date	95.03.06.10.57.25;	author jra;	state Exp;
branches;
next	11.14;

11.14
date	95.03.02.15.45.39;	author jra;	state Exp;
branches;
next	11.13;

11.13
date	95.03.01.16.51.25;	author jra;	state Exp;
branches;
next	11.12;

11.12
date	95.03.01.06.20.37;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	95.02.27.16.28.48;	author jra;	state Exp;
branches;
next	11.10;

11.10
date	95.02.23.14.44.50;	author jra;	state Exp;
branches;
next	11.9;

11.9
date	95.02.03.16.22.42;	author jra;	state Exp;
branches;
next	11.8;

11.8
date	95.02.01.18.35.49;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	95.01.27.13.32.28;	author jra;	state Exp;
branches;
next	11.6;

11.6
date	95.01.24.16.57.19;	author jra;	state Exp;
branches;
next	11.5;

11.5
date	95.01.22.17.34.08;	author jra;	state Exp;
branches;
next	11.4;

11.4
date	95.01.19.09.28.54;	author jra;	state Exp;
branches;
next	11.3;

11.3
date	95.01.13.16.20.45;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	95.01.12.15.07.45;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.57.53;	author mike;	state Rel4_4;
branches;
next	1.165;

1.165
date	94.12.30.00.42.35;	author mike;	state Exp;
branches;
next	1.164;

1.164
date	94.12.19.16.41.21;	author jra;	state Exp;
branches;
next	1.163;

1.163
date	94.11.29.12.29.44;	author jra;	state Exp;
branches;
next	1.162;

1.162
date	94.11.22.14.23.19;	author jra;	state Exp;
branches;
next	1.161;

1.161
date	94.11.21.16.30.25;	author jra;	state Exp;
branches;
next	1.160;

1.160
date	94.11.18.12.36.17;	author jra;	state Exp;
branches;
next	1.159;

1.159
date	94.11.04.10.00.36;	author jra;	state Exp;
branches;
next	1.158;

1.158
date	94.11.04.06.31.46;	author mike;	state Exp;
branches;
next	1.157;

1.157
date	94.11.04.06.28.08;	author mike;	state Exp;
branches;
next	1.156;

1.156
date	94.11.03.10.52.02;	author jra;	state Exp;
branches;
next	1.155;

1.155
date	94.10.14.10.55.44;	author jra;	state Exp;
branches;
next	1.154;

1.154
date	94.10.11.19.39.08;	author mike;	state Exp;
branches;
next	1.153;

1.153
date	94.09.23.16.18.49;	author mike;	state Exp;
branches;
next	1.152;

1.152
date	94.09.23.15.48.04;	author jra;	state Exp;
branches;
next	1.151;

1.151
date	94.09.10.04.37.01;	author mike;	state Exp;
branches;
next	1.150;

1.150
date	94.09.10.04.09.29;	author mike;	state Exp;
branches;
next	1.149;

1.149
date	94.09.03.03.01.24;	author mike;	state Exp;
branches;
next	1.148;

1.148
date	94.09.02.00.32.12;	author mike;	state Exp;
branches;
next	1.147;

1.147
date	94.08.29.14.07.39;	author jra;	state Exp;
branches;
next	1.146;

1.146
date	94.08.10.18.54.11;	author gdurf;	state Exp;
branches;
next	1.145;

1.145
date	94.08.09.19.38.09;	author mike;	state Exp;
branches;
next	1.144;

1.144
date	94.08.03.15.40.36;	author jra;	state Exp;
branches;
next	1.143;

1.143
date	94.07.15.14.02.04;	author jra;	state Exp;
branches;
next	1.142;

1.142
date	94.07.14.10.32.15;	author jra;	state Exp;
branches;
next	1.141;

1.141
date	94.07.11.16.46.01;	author jra;	state Exp;
branches;
next	1.140;

1.140
date	94.07.05.16.20.34;	author jra;	state Exp;
branches;
next	1.139;

1.139
date	94.07.01.23.57.42;	author mike;	state Exp;
branches;
next	1.138;

1.138
date	94.07.01.11.37.48;	author jra;	state Exp;
branches;
next	1.137;

1.137
date	94.06.27.10.37.38;	author jra;	state Exp;
branches;
next	1.136;

1.136
date	94.05.19.13.44.07;	author jra;	state Exp;
branches;
next	1.135;

1.135
date	94.05.17.16.18.24;	author jra;	state Exp;
branches;
next	1.134;

1.134
date	94.04.12.11.35.02;	author jra;	state Exp;
branches;
next	1.133;

1.133
date	94.04.11.08.16.19;	author jra;	state Exp;
branches;
next	1.132;

1.132
date	94.04.08.16.31.45;	author jra;	state Exp;
branches;
next	1.131;

1.131
date	94.04.07.12.50.17;	author jra;	state Exp;
branches;
next	1.130;

1.130
date	94.03.31.16.23.12;	author jra;	state Exp;
branches;
next	1.129;

1.129
date	94.03.30.18.02.32;	author jra;	state Exp;
branches;
next	1.128;

1.128
date	94.03.30.15.48.04;	author jra;	state Exp;
branches;
next	1.127;

1.127
date	94.03.30.14.54.02;	author jra;	state Exp;
branches;
next	1.126;

1.126
date	94.03.30.13.40.20;	author jra;	state Exp;
branches;
next	1.125;

1.125
date	94.03.30.13.26.01;	author jra;	state Exp;
branches;
next	1.124;

1.124
date	94.03.29.18.28.27;	author jra;	state Exp;
branches;
next	1.123;

1.123
date	94.03.28.14.48.48;	author jra;	state Exp;
branches;
next	1.122;

1.122
date	94.03.24.18.19.43;	author jra;	state Exp;
branches;
next	1.121;

1.121
date	94.03.18.12.54.25;	author jra;	state Exp;
branches;
next	1.120;

1.120
date	94.03.16.13.47.17;	author jra;	state Exp;
branches;
next	1.119;

1.119
date	94.03.13.14.45.06;	author jra;	state Exp;
branches;
next	1.118;

1.118
date	94.03.12.17.03.25;	author jra;	state Exp;
branches;
next	1.117;

1.117
date	94.03.11.19.49.20;	author mike;	state Exp;
branches;
next	1.116;

1.116
date	94.03.11.19.48.00;	author jra;	state Exp;
branches;
next	1.115;

1.115
date	94.03.09.17.42.33;	author jra;	state Exp;
branches;
next	1.114;

1.114
date	94.03.03.17.56.51;	author jra;	state Exp;
branches;
next	1.113;

1.113
date	94.02.17.16.04.17;	author jra;	state Exp;
branches;
next	1.112;

1.112
date	94.02.16.17.56.56;	author jra;	state Exp;
branches;
next	1.111;

1.111
date	94.02.16.09.43.44;	author jra;	state Exp;
branches;
next	1.110;

1.110
date	94.02.10.18.47.46;	author mike;	state Exp;
branches;
next	1.109;

1.109
date	94.02.10.16.32.16;	author jra;	state Exp;
branches;
next	1.108;

1.108
date	94.02.09.18.21.53;	author jra;	state Exp;
branches;
next	1.107;

1.107
date	94.02.09.11.02.14;	author jra;	state Exp;
branches;
next	1.106;

1.106
date	94.02.04.16.26.31;	author jra;	state Exp;
branches;
next	1.105;

1.105
date	94.02.02.17.55.53;	author jra;	state Exp;
branches;
next	1.104;

1.104
date	94.02.01.17.55.26;	author jra;	state Exp;
branches;
next	1.103;

1.103
date	94.01.31.16.42.47;	author jra;	state Exp;
branches;
next	1.102;

1.102
date	94.01.29.12.19.06;	author jra;	state Exp;
branches;
next	1.101;

1.101
date	94.01.28.16.15.37;	author jra;	state Exp;
branches;
next	1.100;

1.100
date	94.01.25.16.37.39;	author jra;	state Exp;
branches;
next	1.99;

1.99
date	94.01.25.09.42.04;	author mike;	state Exp;
branches;
next	1.98;

1.98
date	94.01.20.13.05.02;	author jra;	state Exp;
branches;
next	1.97;

1.97
date	94.01.14.02.45.33;	author mike;	state Exp;
branches;
next	1.96;

1.96
date	94.01.13.23.12.26;	author mike;	state Exp;
branches;
next	1.95;

1.95
date	94.01.13.10.48.39;	author jra;	state Exp;
branches;
next	1.94;

1.94
date	94.01.12.17.59.01;	author jra;	state Exp;
branches;
next	1.93;

1.93
date	94.01.06.15.22.53;	author jra;	state Exp;
branches;
next	1.92;

1.92
date	93.12.27.15.08.02;	author jra;	state Exp;
branches;
next	1.91;

1.91
date	93.12.22.15.31.24;	author jra;	state Exp;
branches;
next	1.90;

1.90
date	93.12.21.17.25.12;	author jra;	state Exp;
branches;
next	1.89;

1.89
date	93.12.14.14.12.25;	author jra;	state Exp;
branches;
next	1.88;

1.88
date	93.12.03.03.35.34;	author mike;	state Exp;
branches;
next	1.87;

1.87
date	93.12.02.20.46.10;	author mike;	state Exp;
branches;
next	1.86;

1.86
date	93.11.18.02.09.21;	author mike;	state Exp;
branches;
next	1.85;

1.85
date	93.11.13.00.12.36;	author mike;	state Exp;
branches;
next	1.84;

1.84
date	93.11.12.23.41.51;	author mike;	state Exp;
branches;
next	1.83;

1.83
date	93.11.12.22.16.51;	author mike;	state Exp;
branches;
next	1.82;

1.82
date	93.11.08.15.10.59;	author jra;	state Exp;
branches;
next	1.81;

1.81
date	93.11.02.13.24.06;	author jra;	state Exp;
branches;
next	1.80;

1.80
date	93.10.29.04.05.22;	author mike;	state Exp;
branches;
next	1.79;

1.79
date	93.10.28.23.48.34;	author mike;	state Exp;
branches;
next	1.78;

1.78
date	93.10.27.16.16.59;	author jra;	state Exp;
branches;
next	1.77;

1.77
date	93.10.27.13.44.26;	author jra;	state Exp;
branches;
next	1.76;

1.76
date	93.10.23.07.44.06;	author mike;	state Exp;
branches;
next	1.75;

1.75
date	93.10.23.07.17.41;	author mike;	state Exp;
branches;
next	1.74;

1.74
date	93.10.23.03.01.59;	author mike;	state Exp;
branches;
next	1.73;

1.73
date	93.10.22.22.28.17;	author mike;	state Exp;
branches;
next	1.72;

1.72
date	93.10.22.19.42.20;	author mike;	state Exp;
branches;
next	1.71;

1.71
date	93.10.20.23.49.05;	author mike;	state Exp;
branches;
next	1.70;

1.70
date	93.10.20.15.23.25;	author mike;	state Exp;
branches;
next	1.69;

1.69
date	93.10.07.11.18.44;	author jra;	state Exp;
branches;
next	1.68;

1.68
date	93.10.01.20.32.31;	author mike;	state Exp;
branches;
next	1.67;

1.67
date	93.09.30.20.57.02;	author mike;	state Exp;
branches;
next	1.66;

1.66
date	93.09.24.15.35.19;	author jra;	state Exp;
branches;
next	1.65;

1.65
date	93.09.22.14.11.52;	author jra;	state Exp;
branches;
next	1.64;

1.64
date	93.09.14.22.24.19;	author mike;	state Exp;
branches;
next	1.63;

1.63
date	93.08.31.14.12.28;	author jra;	state Exp;
branches;
next	1.62;

1.62
date	93.08.27.09.31.10;	author jra;	state Exp;
branches;
next	1.61;

1.61
date	93.08.26.16.56.44;	author jra;	state Exp;
branches;
next	1.60;

1.60
date	93.08.23.17.08.28;	author jra;	state Exp;
branches;
next	1.59;

1.59
date	93.08.17.11.09.52;	author jra;	state Exp;
branches;
next	1.58;

1.58
date	93.07.29.11.22.54;	author jra;	state Exp;
branches;
next	1.57;

1.57
date	93.07.28.11.08.19;	author jra;	state Exp;
branches;
next	1.56;

1.56
date	93.07.23.16.28.09;	author mike;	state Exp;
branches;
next	1.55;

1.55
date	93.07.23.16.01.10;	author jra;	state Exp;
branches;
next	1.54;

1.54
date	93.07.20.20.58.10;	author mike;	state Exp;
branches;
next	1.53;

1.53
date	93.07.19.12.41.44;	author jra;	state Exp;
branches;
next	1.52;

1.52
date	93.06.09.00.33.18;	author butler;	state Exp;
branches;
next	1.51;

1.51
date	93.05.22.01.46.23;	author mike;	state Exp;
branches;
next	1.50;

1.50
date	93.05.21.23.47.06;	author mike;	state Exp;
branches;
next	1.49;

1.49
date	93.05.21.15.36.52;	author butler;	state Exp;
branches;
next	1.48;

1.48
date	93.05.21.03.24.43;	author butler;	state Exp;
branches;
next	1.47;

1.47
date	93.04.01.05.20.29;	author mike;	state Exp;
branches;
next	1.46;

1.46
date	93.03.27.00.04.01;	author mike;	state Exp;
branches;
next	1.45;

1.45
date	93.03.26.23.01.18;	author mike;	state Exp;
branches;
next	1.44;

1.44
date	93.03.24.02.24.46;	author mike;	state Exp;
branches;
next	1.43;

1.43
date	93.03.20.04.11.03;	author mike;	state Exp;
branches;
next	1.42;

1.42
date	93.03.17.01.10.43;	author mike;	state Exp;
branches;
next	1.41;

1.41
date	93.03.15.23.52.46;	author mike;	state Exp;
branches;
next	1.40;

1.40
date	93.03.06.00.01.56;	author butler;	state Exp;
branches;
next	1.39;

1.39
date	93.03.03.01.53.39;	author mike;	state Exp;
branches;
next	1.38;

1.38
date	93.03.03.01.35.33;	author butler;	state Exp;
branches;
next	1.37;

1.37
date	92.11.16.23.09.00;	author mike;	state Exp;
branches;
next	1.36;

1.36
date	92.10.20.17.51.02;	author mike;	state Exp;
branches;
next	1.35;

1.35
date	92.08.05.22.30.45;	author mike;	state Exp;
branches;
next	1.34;

1.34
date	92.07.23.05.06.47;	author butler;	state Exp;
branches;
next	1.33;

1.33
date	92.07.22.03.57.05;	author butler;	state Exp;
branches;
next	1.32;

1.32
date	92.07.01.01.32.58;	author butler;	state Exp;
branches;
next	1.31;

1.31
date	92.02.24.23.29.31;	author mike;	state Exp;
branches;
next	1.30;

1.30
date	92.02.21.06.41.59;	author butler;	state Exp;
branches;
next	1.29;

1.29
date	91.06.13.05.44.08;	author butler;	state Exp;
branches;
next	1.28;

1.28
date	91.05.18.03.03.23;	author mike;	state Exp;
branches;
next	1.27;

1.27
date	91.04.03.02.30.44;	author mike;	state Exp;
branches;
next	1.26;

1.26
date	91.03.01.19.46.44;	author mike;	state Exp;
branches;
next	1.25;

1.25
date	91.02.28.02.06.01;	author mike;	state Exp;
branches;
next	1.24;

1.24
date	91.02.07.20.32.39;	author mike;	state Exp;
branches;
next	1.23;

1.23
date	91.01.14.23.24.37;	author mike;	state Exp;
branches;
next	1.22;

1.22
date	90.12.08.02.22.17;	author mike;	state Exp;
branches;
next	1.21;

1.21
date	90.05.24.23.23.35;	author mike;	state Exp;
branches;
next	1.20;

1.20
date	90.05.24.20.47.41;	author mike;	state Exp;
branches;
next	1.19;

1.19
date	90.05.24.19.02.19;	author mike;	state Exp;
branches;
next	1.18;

1.18
date	90.05.23.19.43.43;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	90.05.23.00.32.49;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	90.05.23.00.29.11;	author butler;	state Exp;
branches;
next	1.15;

1.15
date	90.05.22.00.40.59;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	90.05.21.22.05.08;	author butler;	state Exp;
branches;
next	1.13;

1.13
date	90.05.21.14.41.30;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	90.05.21.11.44.58;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	90.05.18.12.24.30;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	90.05.18.07.26.04;	author butler;	state Exp;
branches;
next	1.9;

1.9
date	90.05.16.07.39.46;	author butler;	state Exp;
branches;
next	1.8;

1.8
date	90.05.15.09.21.53;	author butler;	state Exp;
branches;
next	1.7;

1.7
date	90.05.09.11.37.43;	author butler;	state Exp;
branches;
next	1.6;

1.6
date	90.03.14.22.37.32;	author butler;	state Exp;
branches;
next	1.5;

1.5
date	90.03.08.04.40.59;	author butler;	state Exp;
branches;
next	1.4;

1.4
date	90.02.27.21.02.01;	author butler;	state Exp;
branches;
next	1.3;

1.3
date	90.01.03.14.27.48;	author butler;	state Exp;
branches;
next	1.2;

1.2
date	89.12.22.03.15.13;	author butler;	state Exp;
branches;
next	1.1;

1.1
date	89.12.09.02.32.34;	author mike;	state Exp;
branches;
next	;

11.79.2.1
date	2000.11.09.14.40.28;	author jra;	state Exp;
branches;
next	;

11.93.2.1
date	2002.09.19.18.01.40;	author morrison;	state Exp;
branches;
next	11.93.2.2;

11.93.2.2
date	2004.03.17.21.18.53;	author morrison;	state Exp;
branches;
next	;

11.93.4.1
date	2004.03.11.23.43.42;	author morrison;	state Exp;
branches;
next	;

11.95.6.1
date	2004.02.12.18.37.44;	author erikg;	state Exp;
branches;
next	11.95.6.2;

11.95.6.2
date	2004.03.15.14.07.26;	author erikg;	state Exp;
branches;
next	;


desc
@Random NMG support routines
@


11.99
log
@moved to src/
@
text
@/*
 *			N M G _ M I S C . C
 *
 *	As the name implies, these are miscellaneous routines that work with
 *	the NMG structures.
 *
 *
 *  Authors -
 *	John R. Anderson
 *	Lee A. Butler
 *	Michael John Muuss
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Pacakge" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1993-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/nmg_misc.c,v 11.98 2004/05/10 15:30:46 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif


#include <math.h>
#include <stdio.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include "machine.h"
#include "vmath.h"
#include "externs.h"
#include "nmg.h"
#include "raytrace.h"
#include "nurb.h"
#include "rtgeom.h"

#include "db.h"		/* for debugging stuff at bottom */

/*
 *	N M G _ S N U R B _ C A L C _ L U _ U V _ O R I E N T
 */
int
nmg_snurb_calc_lu_uv_orient(const struct loopuse *lu)
{
	struct edgeuse *eu;
	int edge_count=0;
	int edge_no;
	vect_t area;
	point_t *pts;

	NMG_CK_LOOPUSE( lu );

	if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
		rt_bomb( "nmg_snurb_calc_lu_uv_orient: LU has no edges\n" );

	if( *lu->up.magic_p != NMG_FACEUSE_MAGIC )
		rt_bomb( "nmg_snurb_calc_lu_uv_orient: LU is not part of a faceuse\n" );

	NMG_CK_FACEUSE( lu->up.fu_p );
	NMG_CK_FACE( lu->up.fu_p->f_p );

	if( *lu->up.fu_p->f_p->g.magic_p != NMG_FACE_G_SNURB_MAGIC )
		rt_bomb( "nmg_snurb_calc_lu_uv_orient: LU is not part of a SNURB face\n" );

	/* count "psuedo-vertices" in loop */
	for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
	{
		struct edge_g_cnurb *eg;

		NMG_CK_EDGEUSE( eu );

		if( *eu->g.magic_p != NMG_EDGE_G_CNURB_MAGIC )
			rt_bomb( "nmg_snurb_calc_lu_uv_orient: EU on NURB face does not have edge_g_cnurb geometry\n" );

		eg = eu->g.cnurb_p;
		NMG_CK_EDGE_G_CNURB( eg );

		if( eg->order <= 0 )
			edge_count++;
		else
			edge_count += 5;
	}

	/* allocate memory for "psuedo-vertices" */
	pts = (point_t *)bu_calloc( edge_count, sizeof( point_t ), "Orient_nurb_face_loops: pts" );

	/* Assign uv geometry to each "psuedo-vertex" */
	edge_no = 0;
	for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
	{
		struct edge_g_cnurb *eg;
		struct vertexuse *vu;
		struct vertexuse_a_cnurb *vg1;

		eg = eu->g.cnurb_p;

		if( eg->order <= 0 )
		{
			vu = eu->vu_p;
			NMG_CK_VERTEXUSE( vu );
			if( *vu->a.magic_p != NMG_VERTEXUSE_A_CNURB_MAGIC )
				rt_bomb( "Orient_nurb_face_loops: vertexuse in face_g_snurb faceuse doesn't have edge_g_cnurb attribute\n" );
			vg1 = vu->a.cnurb_p;
			VMOVE( pts[edge_no], vg1->param )
			edge_no++;
		}
		else
		{
			fastf_t t1,t2;
			hpoint_t crv_pt;
			int coords;
			int i;

			t1 = eg->k.knots[0];
			t2 = eg->k.knots[eg->k.k_size-1];
			coords = RT_NURB_EXTRACT_COORDS( eg->pt_type );

			for( i=0 ; i<5 ; i++ )
			{
				fastf_t t;

				t = t1 + (t2 - t1)*0.2*(fastf_t)i;

				VSETALLN( crv_pt, 0.0, coords )
				rt_nurb_c_eval( eg, t, crv_pt );
				if( RT_NURB_IS_PT_RATIONAL( eg->pt_type ) )
					VSCALE( pts[edge_no], crv_pt, crv_pt[coords-1] )
				else
					VMOVE( pts[edge_no], crv_pt )
				edge_no++;
			}
		}
	}

	/* translate loop such that pts[0] is at (0,0,0) */
	for( edge_no=1 ; edge_no<edge_count ; edge_no++ )
	{
		VSUB2( pts[edge_no], pts[edge_no], pts[0] )
		pts[edge_no][Z] = 0.0;
	}
	VSETALL( pts[0], 0.0 )

	/* calculate area of loop in uv-space */
	VSETALL( area, 0.0 );
	for( edge_no=1 ; edge_no<edge_count-1 ; edge_no++ )
	{
		vect_t cross;

		VCROSS( cross, pts[edge_no], pts[edge_no+1] );
		VADD2( area, area, cross );
	}

	bu_free( (char *)pts, "nmg_snurb_calc_lu_uv_orient: pts" );

	if( area[Z] > 0.0 )
		return( OT_SAME );
	if( area[Z] < 0.0 )
		return( OT_OPPOSITE );

	return( OT_NONE );
}

void
nmg_snurb_fu_eval(const struct faceuse *fu, const fastf_t u, const fastf_t v, fastf_t *pt_on_srf)
{
	struct face *f;
	hpoint_t tmp_pt;

	NMG_CK_FACEUSE( fu );

	f = fu->f_p;
	NMG_CK_FACE( f );
	if( !f->g.magic_p )
	{
		bu_log( "nmg_snurb_fu_get_norm: face has no geometry (x%x)\n", f );
		rt_bomb( "nmg_snurb_fu_get_norm: bad face\n" );
	}
	if( *f->g.magic_p != NMG_FACE_G_SNURB_MAGIC )
	{
		bu_log( "nmg_snurb_fu_get_norm: face is not a NURB face (x%x)\n", f );
		rt_bomb( "nmg_snurb_fu_get_norm: bad face\n" );
	}

	VSETALLN( tmp_pt, 0.0, 4 );
	rt_nurb_s_eval( f->g.snurb_p, u, v, tmp_pt );

	if( RT_NURB_IS_PT_RATIONAL(f->g.snurb_p->pt_type) )
	{
		double f;

		f = 1.0 / tmp_pt[3];
		VSCALE( pt_on_srf, tmp_pt, f );
	}
	else
		VMOVE( pt_on_srf, tmp_pt )
}

void
nmg_snurb_fu_get_norm(const struct faceuse *fu, const fastf_t u, const fastf_t v, fastf_t *norm)
{
	struct face *f;

	NMG_CK_FACEUSE( fu );

	f = fu->f_p;
	NMG_CK_FACE( f );
	if( !f->g.magic_p )
	{
		bu_log( "nmg_snurb_fu_get_norm: face has no geometry (x%x)\n", f );
		rt_bomb( "nmg_snurb_fu_get_norm: bad face\n" );
	}
	if( *f->g.magic_p != NMG_FACE_G_SNURB_MAGIC )
	{
		bu_log( "nmg_snurb_fu_get_norm: face is not a NURB face (x%x)\n", f );
		rt_bomb( "nmg_snurb_fu_get_norm: bad face\n" );
	}

	rt_nurb_s_norm( f->g.snurb_p, u, v, norm );

	if( (fu->orientation != OT_SAME) != (f->flip != 0 ) )
		VREVERSE( norm, norm )
}

void
nmg_snurb_fu_get_norm_at_vu(const struct faceuse *fu, const struct vertexuse *vu, fastf_t *norm)
{
	struct vertexuse_a_cnurb *va;

	NMG_CK_FACEUSE( fu );
	NMG_CK_VERTEXUSE( vu );

	if( !vu->a.magic_p )
	{
		bu_log( "nmg_snurb_fu_get_norm_at_vu: vertexuse does not have an attribute (x%x)\n", vu );
		rt_bomb( "nmg_snurb_fu_get_norm_at_vu: bad VU\n" );
	}

	if( *vu->a.magic_p != NMG_VERTEXUSE_A_CNURB_MAGIC )
	{
		bu_log( "nmg_snurb_fu_get_norm_at_vu: vertexuse does not have a cnurb attribute (x%x)\n", vu );
		rt_bomb( "nmg_snurb_fu_get_norm_at_vu: bad VU\n" );
	}

	va = vu->a.cnurb_p;
	NMG_CK_VERTEXUSE_A_CNURB( va );

	nmg_snurb_fu_get_norm( fu, va->param[0], va->param[1], norm );

}

void
nmg_find_zero_length_edges(const struct model *m)
{
	struct bu_ptbl eu_tab;
	struct edgeuse *eu;
	int i;

	bu_ptbl_init( &eu_tab, 64, " &eu_tab");

	nmg_edgeuse_tabulate( &eu_tab, &m->magic );

	for( i=0 ; i<BU_PTBL_END( &eu_tab ) ; i++ )
	{
		struct loopuse *lu;

		eu = (struct edgeuse *)BU_PTBL_GET( &eu_tab, i );
		NMG_CK_EDGEUSE( eu );

		if( eu->vu_p->v_p != eu->eumate_p->vu_p->v_p )
			continue;

		/* found a zero length edge */

		bu_log( "Edgeuse x%x (vp %x to vp %x)\n" , eu, eu->vu_p->v_p, eu->eumate_p->vu_p->v_p );
		if( *eu->up.magic_p != NMG_LOOPUSE_MAGIC )
		{
			bu_log( "\tThis is a wire edge\n" );
			continue;
		}

		lu = eu->up.lu_p;

		nmg_pr_lu_briefly( lu, "" );
	}

	bu_ptbl_free( &eu_tab);
}

/*
 *	N M G _ F I N D _ T O P _ F A C E _ I N _ D I R
 *
 *	Finds the topmost face in a shell (in given direction).
 *	Expects to have a translation table (variable "flags") for
 *	the model, and will ignore face structures that have their
 *	flag set in the table.
 *
 *	dir must be X,Y, or Z
 */
struct face *
nmg_find_top_face_in_dir(const struct shell *s, int dir, long int *flags)
{
	fastf_t extreme_value=(-MAX_FASTF);
	fastf_t extreme_slope=(-MAX_FASTF);
	vect_t edge;
	vect_t normal;
	struct face *f_top=(struct face *)NULL;
	struct edge *e_top=(struct edge *)NULL;
	struct vertex *vp_top=(struct vertex *)NULL;
	struct loopuse *lu;
	struct faceuse *fu;
	struct edgeuse *eu,*eu1;
	struct vertexuse *vu;
	struct vertex *v1,*v2;
	int bottommost=0;

	if( rt_g.NMG_debug & DEBUG_BASIC )
		bu_log( "nmg_find_top_face_in_dir( s = x%x , dir=%d , flags = x%x )\n" , s, dir , flags );

	NMG_CK_SHELL( s );

	if( dir < X || dir > Z )
	{
		bu_log( "nmg_find_top_face_in_dir: illegal direction: %d\n", dir );
		return( (struct face *)NULL );
	}

#if 0
	if( dir < 0 )
	{
		bottommost = 1;
		dir = (-dir);
		extreme_value = MAX_FASTF;
		extreme_slope = MAX_FASTF;
	}
#endif
	/* find extreme vertex */
	for( BU_LIST_FOR( fu , faceuse , &s->fu_hd ) )
	{
		NMG_CK_FACEUSE( fu );

		/* skip flagged faceuses */
		if( NMG_INDEX_TEST( flags , fu->f_p ) )
			continue;
		for( BU_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
		{
			NMG_CK_LOOPUSE( lu );
			if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) == NMG_EDGEUSE_MAGIC )
			{
				for( BU_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
				{
					NMG_CK_EDGEUSE( eu );
					if( bottommost )
					{
						if( eu->vu_p->v_p->vg_p->coord[dir] < extreme_value )
						{
							extreme_value = eu->vu_p->v_p->vg_p->coord[dir];
							vp_top = eu->vu_p->v_p;
						}
					}
					else
					{
						if( eu->vu_p->v_p->vg_p->coord[dir] > extreme_value )
						{
							extreme_value = eu->vu_p->v_p->vg_p->coord[dir];
							vp_top = eu->vu_p->v_p;
						}
					}
				}
			}
		}
	}
	if( vp_top == (struct vertex *)NULL )
	{
		bu_log( "Find_top_face_in_dir: Could not find extreme vertex" );
		return( (struct face *)NULL );
	}

	if( rt_g.NMG_debug & DEBUG_BASIC )
		bu_log( "top vertex is x%x at ( %g %g %g )\n",
			vp_top, V3ARGS( vp_top->vg_p->coord ) );

	/* find edge from vp_top with extreme slope in "dir" direction */
	for( BU_LIST_FOR( vu , vertexuse , &vp_top->vu_hd ) )
	{
		struct vertexuse *vu1;

		NMG_CK_VERTEXUSE( vu );

		/* only consider edgeuses */
		if( *vu->up.magic_p != NMG_EDGEUSE_MAGIC )
			continue;

		eu = vu->up.eu_p;
		NMG_CK_EDGEUSE( eu );

		if( rt_g.NMG_debug & DEBUG_BASIC )
		{
			bu_log( "Checking edge (%g %g %g)<->(%g %g %g)\n",
				V3ARGS( eu->vu_p->v_p->vg_p->coord ),
				V3ARGS( eu->eumate_p->vu_p->v_p->vg_p->coord ) );
		}

		/* skip wire edges */
		if( *eu->up.magic_p != NMG_LOOPUSE_MAGIC )
			continue;

		/* skip wire loops */
		if( *eu->up.lu_p->up.magic_p != NMG_FACEUSE_MAGIC )
			continue;

		/* skip finished faces */
		if( NMG_INDEX_TEST( flags , eu->up.lu_p->up.fu_p->f_p ) )
			continue;

		/* skip edges from other shells */
		if( nmg_find_s_of_eu( eu ) != s )
			continue;

		/* skip zero length edges */
		if( eu->eumate_p->vu_p->v_p == vp_top )
			continue;

		/* get vertex at other end of this edge */
		vu1 = eu->eumate_p->vu_p;
		NMG_CK_VERTEXUSE( vu1 );

		/* make a unit vector in direction of edgeuse */
		VSUB2( edge , vu1->v_p->vg_p->coord , vu->v_p->vg_p->coord );
		VUNITIZE( edge );

		if( rt_g.NMG_debug & DEBUG_BASIC )
		{
			bu_log( "Checking edge (%g %g %g)<->(%g %g %g)\n",
				V3ARGS( eu->vu_p->v_p->vg_p->coord ),
				V3ARGS( eu->eumate_p->vu_p->v_p->vg_p->coord ) );
			bu_log( "\tedge direction = (%g %g %g)\n", V3ARGS( edge ) );
			bu_log( "\t\textreme slope = %g\n", extreme_slope );
		}

		/* check against current maximum slope */
		if( bottommost )
		{
			if( edge[dir] < extreme_slope )
			{
				extreme_slope = edge[dir];
				e_top = eu->e_p;
			}
		}
		else
		{
			if( edge[dir] > extreme_slope )
			{
				if( rt_g.NMG_debug & DEBUG_BASIC )
					bu_log( "New top edge!\n" );
				extreme_slope = edge[dir];
				e_top = eu->e_p;
			}
		}
	}
	if( e_top == (struct edge *)NULL )
	{
		bu_log( "Fix_normals: Could not find uppermost edge" );
		return( (struct face *)NULL );
	}

	eu = e_top->eu_p;

#if 0
	/* if the top edge is a free edge, don't use it */
	if( eu->eumate_p == eu->radial_p )
		return( (struct face *)NULL );
#endif
	v1 = eu->vu_p->v_p;
	NMG_CK_VERTEX( v1 );
	v2 = eu->eumate_p->vu_p->v_p;
	NMG_CK_VERTEX( v2 );

	if( rt_g.NMG_debug & DEBUG_BASIC )
		bu_log( "top EU is x%x (%g %g %g) <-> (%g %g %g)\n",
			eu, V3ARGS( v1->vg_p->coord ),
			V3ARGS( v2->vg_p->coord ) );

	/* now find the face containing edge between v1 nad v2
	 with "left-pointing vector" having the most extreme slope */
	if( bottommost )
		extreme_slope = MAX_FASTF;
	else
		extreme_slope = (-MAX_FASTF);

	for( BU_LIST_FOR( vu, vertexuse, &v1->vu_hd ) )
	{
		vect_t left;
		vect_t edge_dir;

		NMG_CK_VERTEXUSE( vu );
		if( *vu->up.magic_p != NMG_EDGEUSE_MAGIC )
			continue;

		eu1 = vu->up.eu_p;
		NMG_CK_EDGEUSE( eu1 );

		/* don't bother with anything but faces */
		if( *eu1->up.magic_p != NMG_LOOPUSE_MAGIC )
			continue;

		/* skip edges not between correct vertices */
		if( eu1->eumate_p->vu_p->v_p != v2 )
			continue;

		lu = eu1->up.lu_p;
		NMG_CK_LOOPUSE( lu );
		if( *lu->up.magic_p != NMG_FACEUSE_MAGIC )
			continue;

		/* fu is a faceuse containing "eu1" */
		fu = lu->up.fu_p;
		NMG_CK_FACEUSE( fu );

		/* skip faces from other shells and flagged faceuses */
		if( fu->s_p != s || NMG_INDEX_TEST( flags, fu->f_p ) )
			continue;

		/* make a vector in the direction of "eu1" */
		if( rt_g.NMG_debug & DEBUG_BASIC )
			bu_log( "test EU is x%x (%g %g %g) <-> (%g %g %g)\n",
				eu, V3ARGS( eu->vu_p->v_p->vg_p->coord ),
				V3ARGS( eu->eumate_p->vu_p->v_p->vg_p->coord ) );

		VSUB2( edge_dir , eu1->eumate_p->vu_p->v_p->vg_p->coord , eu1->vu_p->v_p->vg_p->coord );

		if( rt_g.NMG_debug & DEBUG_BASIC )
			bu_log( "edge_dir is ( %g %g %g )\n", V3ARGS( edge_dir ) );

		/* find the normal for this faceuse */
		if( *fu->f_p->g.magic_p == NMG_FACE_G_PLANE_MAGIC )
			NMG_GET_FU_NORMAL( normal, fu )
		else if( *fu->f_p->g.magic_p == NMG_FACE_G_SNURB_MAGIC )
			nmg_snurb_fu_get_norm_at_vu( fu, eu1->vu_p, normal );

		if( rt_g.NMG_debug & DEBUG_BASIC )
			bu_log( "fu normal is ( %g %g %g )\n" , V3ARGS( normal ) );

		/* normal cross edge direction gives vector in face */
		VCROSS( left , normal , edge_dir );

		/* unitize to get slope */
		VUNITIZE( left );
		if( rt_g.NMG_debug & DEBUG_BASIC )
		{
			bu_log( "left vector is ( %g %g %g )\n", V3ARGS( left ) );
			bu_log( "\textreme slope in %d direction is %g\n", dir, extreme_slope );
		}

		/* check against current most extreme slope */
		if( bottommost )
		{
			if( left[dir] < extreme_slope )
			{
				extreme_slope = left[dir];
				f_top = fu->f_p;
			}
		}
		else
		{
			if( left[dir] > extreme_slope )
			{
				if( rt_g.NMG_debug & DEBUG_BASIC )
					bu_log( "new f_top\n" );
				extreme_slope = left[dir];
				f_top = fu->f_p;
			}
		}
	}

	if( f_top == (struct face *)NULL )
	{
		bu_log( "Nmg_find_top_face_in_dir: Could not find uppermost face" );
		return( (struct face *)NULL );
	}

	if( rt_g.NMG_debug & DEBUG_BASIC )
		bu_log( "nmg_find_top_face_in_dir: top face = x%x, dir = %d, top vertex = x%x ( %g %g %g )\n",
			f_top, dir, vp_top, V3ARGS( vp_top->vg_p->coord ) );

	return( f_top );
}

/*
 *	N M G _ F I N D _ T O P _ F A C E
 *
 *	Finds the topmost face in a shell (in some direction).
 *	Expects to have a translation table (variable "flags") for
 *	the model, and will ignore face structures that have their
 *	flag set in the table.
 *
 * returns the top face in some direction.
 *
 * dir will be set to X, Y, or Z to indicate which top face was found.
 */

struct face *
nmg_find_top_face(const struct shell *s, int *dir, long int *flags)
{
	struct face *top_face;

	for( *dir=X ; *dir<=Z ; (*dir)++ )
		if( (top_face=nmg_find_top_face_in_dir( s, *dir, flags )) != (struct face *)NULL )
			return( top_face );

	/* give up!! */
	bu_log( "Nmg_find_top_face: Cannot find a top face\n" );
	*dir = (-32000); /* will hopefully cause an error if used */
	return( (struct face *)NULL );

}

/*	N M G _ A S S O C _ V O I D _ S H E L L S
 *
 * Passed an bu_ptbl structure containing one shell, this routine
 * examines the other shells in the region to determine if any are void shells
 * within the shell on the bu_ptbl list. Any such void shells found are added
 * to the bu_ptbl list. The final result is a ptbl list of shells where the
 * first shell on the list is the outer shell, and any additional shells one
 * the list are void shells within that outer shell. This is a support routine
 * for "nmg_find_outer_and_void_shells" and gets called for every outer shell
 * in the region
 */
struct top_face
{
	struct shell *s;
	struct face *f;
	int dir;
	vect_t normal;
};

static void
nmg_assoc_void_shells(const struct nmgregion *r, struct bu_ptbl *shells, const struct bn_tol *ttol)
{
	struct shell *outer_shell,*void_s,*s;
	struct faceuse *fu;
	struct loopuse *lu;
	struct edgeuse *eu;
	long *flags;
	struct top_face *top_faces;
	int total_shells=0;
	int i;
	int dir;

	NMG_CK_REGION( r );
	BU_CK_PTBL( shells );
	BN_CK_TOL( ttol );

	outer_shell = (struct shell *)BU_PTBL_GET( shells , 0 );
	NMG_CK_SHELL( outer_shell );

	/* count shells in region */
	for( BU_LIST_FOR( s , shell , &r->s_hd ) )
		total_shells++;

	/* make an array of shells and top faces */
	top_faces = (struct top_face *)bu_calloc( total_shells , sizeof( struct top_face ) , "nmg_assoc_void_shells: top_faces" );

	/* make flags array for use by "nmg_find_top_face" */
	flags = (long *)bu_calloc( r->m_p->maxindex , sizeof( long ) , "nmg_find_outer_and_void_shells: flags" );

	top_faces[0].s = outer_shell;
	top_faces[0].f = nmg_find_top_face( outer_shell, &dir , flags );
	top_faces[0].dir = dir;
	fu = top_faces[0].f->fu_p;
	if( fu->orientation != OT_SAME )
		fu = fu->fumate_p;
	NMG_GET_FU_NORMAL( top_faces[0].normal , fu );

	/* fill in top_faces array */
	i = 0;
	for( BU_LIST_FOR( s , shell , &r->s_hd ) )
	{
		if( s == outer_shell )
			continue;

		top_faces[++i].s = s;
		top_faces[i].f = nmg_find_top_face( s, &dir , flags );
		top_faces[i].dir = dir;
		if( top_faces[i].f == (struct face *)NULL )
			bu_log( "WARNING: nmg_assoc_void_shells() could not find top face for shell x%x\n", s );
		else
		{
			fu = top_faces[i].f->fu_p;
			if( fu->orientation != OT_SAME )
				fu = fu->fumate_p;
			NMG_GET_FU_NORMAL( top_faces[i].normal , fu );
		}
	}

	/* look for voids */
	for( BU_LIST_FOR( void_s , shell , &r->s_hd ) )
	{
		struct face *void_f;
		int wrong_void=0;
		vect_t normal;

		if( void_s == outer_shell )
			continue;

		NMG_CK_SHELL( void_s );

		void_f = (struct face *)NULL;
		for( i=0 ; i<total_shells ; i++ )
		{
			if( top_faces[i].s == void_s )
			{
				void_f = top_faces[i].f;
				dir = top_faces[i].dir;
				VMOVE( normal , top_faces[i].normal );
				break;
			}
		}
		if( void_f == (struct face *)NULL )
			rt_bomb( "nmg_assoc_void_shells: no top face for a shell\n" );

		if( normal[dir] < 0.0)
		{
			/* this is a void shell */
			struct face *int_f;
			struct shell *test_s;
			int breakout=0;
			int not_in_this_shell=0;

			/* this is a void shell
			 * but does it belong with outer_shell */
			if( !V3RPP1_IN_RPP2( void_s->sa_p->min_pt , void_s->sa_p->max_pt , outer_shell->sa_p->min_pt , outer_shell->sa_p->max_pt ) )
			{
				continue;
			}

			for( BU_LIST_FOR( fu , faceuse , &void_s->fu_hd ) )
			{
				for( BU_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
				{
					if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
						continue;
					for( BU_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
					{
						int class;

						class = nmg_class_pt_s( eu->vu_p->v_p->vg_p->coord , outer_shell, 0 , ttol );

						if( class == NMG_CLASS_AoutB )
						{
							breakout = 1;
							not_in_this_shell = 1;
							break;
						}
					}
					if( breakout )
						break;
				}
				if( breakout )
					break;
			}

			if( not_in_this_shell )
				continue;

			int_f = (struct face *)NULL;
			for( i=0 ; i<total_shells ; i++ )
			{
				if( top_faces[i].s == void_s )
				{
					int_f = top_faces[i].f;
					break;
				}
			}
			if( int_f == (struct face *)NULL )
				rt_bomb( "nmg_assoc_void_shells: no top face for a shell\n" );

			/* Make sure there are no other external shells between these two */
			for( BU_LIST_FOR( test_s , shell , &r->s_hd ) )
			{
				vect_t test_norm;
				struct face *test_f;
				int test_dir = 0;

				/* don't check against the outer shell or the candidate void shell */
				if( test_s == void_s || test_s == outer_shell )
					continue;

				/* find top face for the test shell */
				test_f = (struct face *)NULL;
				for( i=0 ; i<total_shells ; i++ )
				{
					if( top_faces[i].s == test_s )
					{
						test_f = top_faces[i].f;
						test_dir = top_faces[i].dir;
						VMOVE( test_norm , top_faces[i].normal );
						break;
					}
				}
				if( test_f == (struct face *)NULL )
					rt_bomb( "nmg_assoc_void_shells: no top face for a shell\n" );

				/* skip test shells that are void shells */
				if( test_norm[test_dir] < 0.0)
					continue;

				/* if the void shell is not within the test shell, continue */
				if( !V3RPP1_IN_RPP2( void_s->sa_p->min_pt , void_s->sa_p->max_pt , test_s->sa_p->min_pt , test_s->sa_p->max_pt ) )
					continue;

				/* the void shell may be within this shell */
				/* XXXX Need code here to check if candidate void shell (void_s)
				 * XXXX is within test shell (test_s) and test shell is
				 * XXXX is within outer shell (outer_shell)
				if( void_s in test_s and test_s in outer_shell )
				{
					wrong_void = 1;
					break;
				}
				*/
			}
			if( wrong_void )
			{
				continue;
			}

			/* This void shell belongs with shell outer_s 
			 * add it to the list of shells */
			bu_ptbl_ins( shells , (long *)void_s );
		}
	}
	bu_free( (char *)flags , "nmg_assoc_void_shells: flags" );
}

/*	N M G _ F I N D _ O U T E R _ A N D _ V O I D _ S H E L L S
 *
 * This routine takes a region and constructs an array of bu_ptbl lists.
 * A list is created for each outer shell, and that shell is the first item
 * on the list. Additional shells on any list are void shells within that
 * lists outer shell. This routine calls "nmg_decompose_shell" for every
 * shell in the region, so the original region topology may be changed
 * to accomplish this. No geometry is altered.
 */
int
nmg_find_outer_and_void_shells(struct nmgregion *r, struct bu_ptbl ***shells, const struct bn_tol *tol)
{
	struct bu_ptbl *outer_shells;
	struct shell *s;
	int i;
	int total_shells=0;
	int outer_shell_count;
	int re_bound=0;
	int dir;
	long *flags;

	NMG_CK_REGION( r );
	BN_CK_TOL( tol );

	/* Decompose shells */
	outer_shells = (struct bu_ptbl *)bu_malloc( sizeof( struct bu_ptbl ) , "nmg_find_outer_and_void_shells: outer_shells" );
	bu_ptbl_init( outer_shells , 64, " outer_shells ");
	for (BU_LIST_FOR(s, shell, &r->s_hd))
	{
		NMG_CK_SHELL( s );
		bu_ptbl_ins( outer_shells , (long *)s );
	}
	for( i=0 ; i<BU_PTBL_END( outer_shells ) ; i++ )
	{
		s = (struct shell *)BU_PTBL_GET( outer_shells , i );
		if( nmg_decompose_shell( s , tol ) > 1 )
			re_bound = 1;
	}
	bu_ptbl_reset( outer_shells );

	if( re_bound )
		nmg_region_a( r , tol );

	for (BU_LIST_FOR(s, shell, &r->s_hd))
		total_shells++;

	flags = (long *)bu_calloc( r->m_p->maxindex , sizeof( long ) , "nmg_find_outer_and_void_shells: flags" );

	for( BU_LIST_FOR( s , shell , &r->s_hd ) )
	{
		struct face *f;
		struct faceuse *fu;
		vect_t normal;

		f = (struct face *)NULL;
		for( dir = X ; dir <= Z ; dir++ ) {
			if( (f = nmg_find_top_face_in_dir( s, dir , flags )) == (struct face *)NULL )
				continue;

			fu = f->fu_p;
			if( fu->orientation != OT_SAME )
				fu = fu->fumate_p;
			if( fu->orientation != OT_SAME )
				rt_bomb( "nmg_find_outer_and_void_shells: Neither faceuse nor mate have OT_SAME orient\n" );

			NMG_GET_FU_NORMAL( normal , fu );
			if( normal[dir] >= 0.0)	{
				bu_ptbl_ins( outer_shells , (long *)s );	/* outer shell */
				break;
			}
		}

		if( f == (struct face *)NULL ) {
			bu_bomb( "nmg_find_outer_and_void_shells: cannot find top face in a shell\n" );
		}
	}

	/* outer_shells is now a list of all the outer shells in the region */
	outer_shell_count = BU_PTBL_END( outer_shells );

	*shells = (struct bu_ptbl **)bu_calloc( BU_PTBL_END( outer_shells ) , sizeof( struct bu_ptbl *) ,
			"nmg_find_outer_and_void_shells: shells" );
	for( i=0 ; i<BU_PTBL_END( outer_shells ) ; i++ )
	{
		(*shells)[i] = (struct bu_ptbl *)bu_malloc( sizeof( struct bu_ptbl ) , 
			"nmg_find_outer_and_void_shells: shells[]" );

		bu_ptbl_init( (*shells)[i] , 64, "(*shells)[i]");
		BU_CK_PTBL( (*shells)[i] );
		bu_ptbl_ins( (*shells)[i] , BU_PTBL_GET( outer_shells , i ) );
		if( outer_shell_count != total_shells ) /* must be some void shells */
			nmg_assoc_void_shells( r , (*shells)[i] , tol );
	}

	bu_free( (char *)flags , "nmg_find_outer_and_void_shells: flags" );
	bu_ptbl_free( outer_shells );
	return( outer_shell_count );
}

/*	N M G _ M A R K _ E D G E S _ R E A L
 *
 * Sets the "is_real" flag on all edges at or below the
 * pointer passed. Returns the number of flags set.
 */
int
nmg_mark_edges_real(const long int *magic_p)
{
	struct bu_ptbl edges;
	int i,count;

	nmg_edge_tabulate( &edges , magic_p );

	count = BU_PTBL_END( &edges );
	for( i=0 ; i<count ; i++ )
	{
		struct edge *e;

		e = (struct edge *)BU_PTBL_GET( &edges , i );
		NMG_CK_EDGE( e );

		e->is_real = 1;
	}

	bu_ptbl_free( &edges );

	return( count );
}

/*	N M G _ T A B U L A T E _ F A C E _ G _ V E R T S
 *
 * Tabulates all vertices in faces that use fg
 */

void
nmg_tabulate_face_g_verts(struct bu_ptbl *tab, const struct face_g_plane *fg)
{
	struct face *f;

	NMG_CK_FACE_G_PLANE( fg );

	bu_ptbl_init( tab, 64, " tab");

	/* loop through all faces using fg */
	for( BU_LIST_FOR( f , face , &fg->f_hd ) )
	{
		struct faceuse *fu;
		struct loopuse *lu;

		NMG_CK_FACE( f );

		/* get one of the two uses of this face */
		fu = f->fu_p;
		NMG_CK_FACEUSE( fu );

		/* Visit each loop in this faceuse */
		for( BU_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
		{
			NMG_CK_LOOPUSE( lu );

			/* include loops of a single vertex */
			if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) == NMG_VERTEXUSE_MAGIC )
			{
				struct vertexuse *vu;
				struct vertex *v;

				vu = BU_LIST_FIRST(vertexuse, &lu->down_hd);
				NMG_CK_VERTEXUSE( vu );
				v = vu->v_p;
				NMG_CK_VERTEX( v );

				/* insert vertex into table */
				bu_ptbl_ins_unique( tab , (long *)v );
			}
			else
			{
				struct edgeuse *eu;

				/* visit each edgeuse in the loop */
				for( BU_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
				{
					struct vertexuse *vu;
					struct vertex *v;

					NMG_CK_EDGEUSE( eu );
					vu = eu->vu_p;
					NMG_CK_VERTEXUSE( vu );
					v = vu->v_p;
					NMG_CK_VERTEX( v );

					/* insert vertex into table */
					bu_ptbl_ins_unique( tab , (long *)v );
				}
			}
		}
	}
}

/* 	N M G _ I S E C T _ S H E L L _ S E L F
 *
 * Intersects all faces in a shell with all other faces in the same shell
 * Intended for use after extrusion
 *
 */
void
nmg_isect_shell_self(struct shell *s, const struct bn_tol *tol)
{
	struct model *m;
	struct nmgregion *r;
	struct shell *s_fu;
	struct faceuse *fu;
	struct bu_ptbl fus;
	int fu_no;
	int fu2_no;

	NMG_CK_SHELL( s );
	BN_CK_TOL( tol );

	m = nmg_find_model( &s->l.magic );
	NMG_CK_MODEL( m );

	nmg_vmodel( m );

	r = s->r_p;
	NMG_CK_REGION( r );

	s_fu = nmg_msv( r );
	NMG_CK_SHELL( s_fu );

	bu_ptbl_init( &fus , 64, " &fus ");

	for( BU_LIST_FOR( fu , faceuse , &s->fu_hd ) )
	{
		NMG_CK_FACEUSE( fu );

		if( fu->orientation == OT_SAME )
			bu_ptbl_ins( &fus , (long *)fu );
	}

	/* intersect each face with every other face in the shell */
	for( fu_no=0 ; fu_no < BU_PTBL_END( &fus ) ; fu_no ++ )
	{
		struct faceuse *fu2;

		fu = (struct faceuse *)BU_PTBL_GET( &fus , fu_no );

		NMG_CK_FACEUSE( fu );

		/* move fu to another shell to avoid radial edge problems */
		nmg_mv_fu_between_shells( s_fu, s, fu );

		/* consider intersection this faceuse with all the faceuses
		 * after it in the list
		 */
		for( fu2_no=fu_no+1 ; fu2_no < BU_PTBL_END( &fus ) ; fu2_no++ )
		{
			struct face *f,*f2;

			fu2 = (struct faceuse *)BU_PTBL_GET( &fus , fu2_no );

			if( rt_g.NMG_debug & DEBUG_BASIC )
				bu_log( "nmg_extrude_cleanup: fu=x%x, fu2=x%x\n" , fu , fu2 );

			/* skip faceuses radial to fu or not OT_SAME */
			if( fu2->orientation != OT_SAME || nmg_faces_are_radial( fu , fu2 ) )
				continue;

			f = fu->f_p;
			f2 = fu2->f_p;

			/* skip faceuse pairs that don't have overlapping BB's */
			if( !V3RPP_OVERLAP( f->min_pt , f->max_pt , f2->min_pt , f2->max_pt ) )
				continue;

			if( rt_g.NMG_debug & DEBUG_BASIC )
				bu_log( "nmg_extrude_cleanup: calling nmg_isect_two_generic_faces( fu=x%x , fu2=x%x )\n" , fu , fu2 );

			nmg_isect_two_generic_faces( fu , fu2 , tol );
		}
		/* move fu back where it belongs */
		while( BU_LIST_NON_EMPTY( &s_fu->fu_hd ) )
		{
			struct faceuse *fu_tmp;

			fu_tmp = BU_LIST_FIRST( faceuse , &s_fu->fu_hd );
			NMG_CK_FACEUSE( fu_tmp );

			if( rt_g.NMG_debug & DEBUG_BASIC )
				bu_log( "nmg_extrude_cleanup: moving fu x%x back\n" , fu_tmp );

			nmg_mv_fu_between_shells( s, s_fu, fu_tmp );
		}
	}

	/* get rid of the temporary shell */
	nmg_ks( s_fu );

	bu_ptbl_free( &fus);
}

/*	N M G _ N E X T _ R A D I A L _ E D G E U S E
 *
 * Traverse radial edgeuse around specified edgeuse looking for
 * one that meets optional restrictions. If a shell is specified
 * only edgeuse from that shell will be considered. If wires is
 * non-zero, wire edges will be considered, otherwise, wire edges
 * are ignored.
 *
 * returns:
 *	radial edgeuse
 */

struct edgeuse *
nmg_next_radial_eu(const struct edgeuse *eu, const struct shell *s, const int wires)
{
	struct edgeuse *ret_eu;

	NMG_CK_EDGEUSE( eu );
	if( s )
		NMG_CK_SHELL( s );

	if( s && nmg_find_s_of_eu( eu ) != s )
		rt_bomb( "nmg_find_radial_eu: eu is not in specified shell\n" );

	if( !wires && !nmg_find_fu_of_eu( eu ) )
		rt_bomb( "nmg_find_radial_eu: wire edges not specified, but eu is a wire!!\n" );

	ret_eu = eu->eumate_p->radial_p;
	while(
	      (!wires & (nmg_find_fu_of_eu(ret_eu) == (struct faceuse *)NULL))
	      ||
	      ( (s != (struct shell *)NULL) &&
		nmg_find_s_of_eu(ret_eu) != s  )
	      )
			ret_eu = ret_eu->eumate_p->radial_p;

	return( ret_eu );
}

/*	N M G _ P R E V _ R A D I A L _ E D G E U S E
 *
 * Traverse radial edgeuse around specified edgeuse in opposite
 * direction from nmg_next_radial_eu, looking for
 * one that meets optional restrictions. If a shell is specified
 * only edgeuse from that shell will be considered. If wires is
 * non-zero, wire edges will be considered, otherwise, wire edges
 * are ignored.
 *
 * returns:
 *	radial edgeuse
 */

struct edgeuse *
nmg_prev_radial_eu(const struct edgeuse *eu, const struct shell *s, const int wires)
{
	struct edgeuse *ret_eu;

	NMG_CK_EDGEUSE( eu );
	if( s )
		NMG_CK_SHELL( s );

	if( s && nmg_find_s_of_eu( eu ) != s )
		rt_bomb( "nmg_find_radial_eu: eu is not in specified shell\n" );

	if( !wires && !nmg_find_fu_of_eu( eu ) )
		rt_bomb( "nmg_find_radial_eu: wire edges not specified, but eu is a wire!!\n" );

	ret_eu = eu->radial_p->eumate_p;
	while( ( !wires & (nmg_find_fu_of_eu( ret_eu ) == (struct faceuse *)NULL)) ||
		( (s != (struct shell *)NULL) && nmg_find_s_of_eu( ret_eu ) != s  ) )
			ret_eu = ret_eu->radial_p->eumate_p;

	return( ret_eu );
}

/*	N M G _ R A D I A L _ F A C E _ C O U N T
 *
 * Counts the number of faces (actually, the number of radial edgeuse/mate pairs)
 * around eu. If s is specified, only edgeuses in shell s are counted. Wire
 * edgeuses are not counted.
 *
 * returns:
 *	number of edgeuse/mate pairs radiall around eu that meet restrictions
 */
int
nmg_radial_face_count(const struct edgeuse *eu, const struct shell *s)
{
	int face_count=1;
	struct edgeuse *eu1;

	NMG_CK_EDGEUSE( eu );
	if( s )
		NMG_CK_SHELL( s );

	/* count radial faces on this edge */
	eu1 = eu->eumate_p->radial_p;
	while( eu1 != eu && eu1 != eu->eumate_p )
	{
		/* ignore other shells and don't count wires */
		if( (!s || nmg_find_s_of_eu( eu1 ) == s) &&
			nmg_find_fu_of_eu( eu1 ) != (struct faceuse *)NULL )
				face_count++;
		eu1 = eu1->eumate_p->radial_p;
	}

	return( face_count );
}

/*	N M G _ C H E C K _ C L O S E D _ S H E L L
 *
 *	Looks at every eu in OT_SAME fu's. If any eu
 *	has no radials, then it must be the edge of a
 *	dangling face and therfore the edge of an opening.
 *
 *  returns:
 *	0 - O.K.
 *	1 - found a hole
 */
int
nmg_check_closed_shell(const struct shell *s, const struct bn_tol *tol)
{
	struct faceuse *fu;

	NMG_CK_SHELL( s );
	BN_CK_TOL( tol );

	for( BU_LIST_FOR( fu , faceuse , &s->fu_hd ) )
	{
		struct loopuse *lu;

		NMG_CK_FACEUSE( fu );

		if( fu->orientation != OT_SAME )
			continue;

		for( BU_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
		{
			struct edgeuse *eu;

			NMG_CK_LOOPUSE( lu );

			if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
				continue;

			for( BU_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
			{
				struct edgeuse *next_eu;

				next_eu = nmg_next_radial_eu( eu, s , 0 );
				if( next_eu == eu || next_eu == eu->eumate_p )
					return( 1 );
			}
		}
	}

	return( 0 );
}

/*	N M G _ M O V E _ L U _ B E T W E E N _ F U S
 *
 * Moves lu from src faceuse to dest faceuse
 *
 * returns:
 *	0 - All is well
 *	1 - src faceuse is now empty
 */
int
nmg_move_lu_between_fus(struct faceuse *dest, struct faceuse *src, struct loopuse *lu)
{
	struct loopuse *lumate;
	int src_is_empty;

	NMG_CK_FACEUSE( dest );
	NMG_CK_FACEUSE( dest->fumate_p );
	NMG_CK_FACEUSE( src );
	NMG_CK_FACEUSE( src->fumate_p );
	NMG_CK_LOOPUSE( lu );

	if( rt_g.NMG_debug & DEBUG_BASIC )
		bu_log( "nmg_move_lu_between_fus( dest=x%x, src=x%x, lu=x%x)\n", dest, src, lu );

	if( lu->up.fu_p != src )
	{
		bu_log( "nmg_move_lu_between_fus( dest=x%x, src=x%x, lu=x%x)\n", dest, src, lu );
		rt_bomb( "\tlu is not in src faceuse\n" );
	}

	if( dest == src )
		return( 0 );

	lumate = lu->lumate_p;
	NMG_CK_LOOPUSE( lumate );

	/* remove lu from src faceuse */
	BU_LIST_DEQUEUE( &lu->l );
	src_is_empty = BU_LIST_IS_EMPTY( &src->lu_hd );

	/* remove lumate from src faceuse mate */
	BU_LIST_DEQUEUE( &lumate->l );
	if( src_is_empty != BU_LIST_IS_EMPTY( &src->fumate_p->lu_hd ) )
	{
		bu_log( "nmg_move_lu_between_fus( dest=x%x, src=x%x, lu=x%x)\n", dest, src, lu );
		if( src_is_empty )
			rt_bomb( "\tsrc faceuse contains only lu, but src->fumate_p has more!!\n" );
		rt_bomb( "\tsrc->fumate_p faceuse contains only lu->lumate_p, but src has more!!\n" );
	}

	/* add lu to dest faceuse */
	BU_LIST_INSERT( &dest->lu_hd, &lu->l );

	/* add lumate to dest mate */
	BU_LIST_INSERT( &dest->fumate_p->lu_hd, &lumate->l );

	/* adjust up pointers */
	lu->up.fu_p = dest;
	lumate->up.fu_p = dest->fumate_p;

	return( src_is_empty );
}

/*	N M G _ L O O P _ P L A N E _ N E W E L L
 *
 *	Calculate the plane equation of a loop using Newell's Method
 *	(See "Graphics Gems III", David Kirk editor, Academic Press, Inc. 1992)
 *
 *	If the loop orientation is OT_OPPOSITE, the normal of the plane
 *	is reversed.
 */
void
nmg_loop_plane_newell(const struct loopuse *lu, fastf_t *pl)
{
	struct edgeuse *eu;
	double hmin,hmax;
	double pl_tmp[3];

	NMG_CK_LOOPUSE( lu );

	VSETALL( pl, 0.0 );
	pl[H] = 0.0;

	VSETALL( pl_tmp, 0.0 );

	/* make sure we have a loop of edges */
	if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
		return;

	/* check if this loop is a crack */
	if( nmg_loop_is_a_crack( lu ) )
		return;

	if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
		return;

	for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
	{
		struct edgeuse *eu_next;
		struct vertex_g *vg;
		struct vertex_g *vg_next;

		vg = eu->vu_p->v_p->vg_p;
		eu_next = BU_LIST_PNEXT_CIRC( edgeuse, &eu->l );
		vg_next = eu_next->vu_p->v_p->vg_p;

		pl_tmp[X] += ( vg->coord[Y] - vg_next->coord[Y]) * ( vg->coord[Z] + vg_next->coord[Z] );
		pl_tmp[Y] += ( vg->coord[Z] - vg_next->coord[Z]) * ( vg->coord[X] + vg_next->coord[X] );
		pl_tmp[Z] += ( vg->coord[X] - vg_next->coord[X]) * ( vg->coord[Y] + vg_next->coord[Y] );
	}

	VUNITIZE( pl_tmp );
	VMOVE( pl, pl_tmp );

	hmin = MAX_FASTF;
	hmax = (-hmin);

	for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
	{
		struct vertex_g *vg;
		fastf_t htest;

		vg = eu->vu_p->v_p->vg_p;
		htest = VDOT( vg->coord, pl );
		if( htest > hmax )
			hmax = htest;
		if( htest < hmin )
			hmin = htest;
	}

	pl[H] = (hmax + hmin)/2.0;

	if( lu->orientation == OT_OPPOSITE )
		HREVERSE( pl, pl );
}

/*	N M G _ L O O P _ P L A N E _ A R E A
 *
 *  Calculates a plane equation and the area of a loop
 *
 *  returns:
 *	the area of the loop
 *	less than zero indicates an error
 *
 *  pl is assigned the plane equation for the loop
 *
 */

fastf_t
nmg_loop_plane_area(const struct loopuse *lu, fastf_t *pl)
{
	fastf_t area;
	fastf_t vect_mag;
	fastf_t vect_mag_inv;
	fastf_t pt_dot_plane=0.0;
	fastf_t pt_count=0.0;
	plane_t plane;
	struct edgeuse *eu;
	vect_t trans;

	NMG_CK_LOOPUSE( lu );

	/* make sure we have a loop of edges */
	if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
		return( (fastf_t)(-1.0) );

	/* check if this loop is a crack */
	if( nmg_loop_is_a_crack( lu ) )
		return( (fastf_t)(-1.0) );

	/* calculate a translation to put one vertex at the origin
	 * not necessary, but good for accuracy.
	 * Also, origin must be in plane of loop for this
	 * method to work
	 */
	eu = BU_LIST_FIRST( edgeuse , &lu->down_hd );
	NMG_CK_VERTEXUSE( eu->vu_p );
	NMG_CK_VERTEX( eu->vu_p->v_p );
	NMG_CK_VERTEX_G( eu->vu_p->v_p->vg_p );
	VMOVE( trans , eu->vu_p->v_p->vg_p->coord );

	VSET( plane , 0.0 , 0.0 , 0.0 );

	/* Calculate area and plane normal.
	 * Cross product of each pair of vertices gives twice
	 * the area of the triangle formed by the origin and
	 * the two vertices. (positive if counter-clockwise,
	 * negative if clockwise). In counter_clockwise case,
	 * sum of all cross products around loop adds area for
	 * edges away from origin and subtracts area for edges
	 * near origin, leaving twice the area of the polygon.
	 */
	for( BU_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
	{
		struct edgeuse *next_eu;
		struct vertex *vp,*next_vp;
		vect_t cross;
		point_t p1,p2;

		vp = eu->vu_p->v_p;

		next_eu = BU_LIST_PNEXT_CIRC( edgeuse , &eu->l );
		NMG_CK_EDGEUSE( next_eu );
		NMG_CK_VERTEXUSE( next_eu->vu_p );

		next_vp = next_eu->vu_p->v_p;
		NMG_CK_VERTEX( next_vp );
		NMG_CK_VERTEX_G( next_vp->vg_p );

		VSUB2( p1 , vp->vg_p->coord , trans );
		VSUB2( p2 , next_vp->vg_p->coord , trans );
		VCROSS( cross , p1 , p2 );
		VADD2( plane , plane , cross );
	}

	vect_mag = MAGNITUDE( plane );

	/* Error if the area is too small to unitize the normal vector */
	if( vect_mag < SMALL_FASTF )
		return( (fastf_t)(-1.0) );

	area = 0.5 * vect_mag;
	vect_mag_inv = 1.0/vect_mag;

	VSCALE( plane , plane , vect_mag_inv );

	/* calculate plane[3] as average distance to plane */
	for( BU_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
	{
		pt_dot_plane += VDOT( plane , eu->vu_p->v_p->vg_p->coord );
		pt_count++;
	}

	/* Error if we don't have at least 3 vertices in this loop */
	if( pt_count < 3 )
		return( (fastf_t)(-1.0) );

	plane[3] = pt_dot_plane/pt_count;
	HMOVE( pl , plane );

	return( area );
}

/*	N M G _ C A L C _ F A C E _ P L A N E
 *
 * Calculate face geometry using a least squares fit or Newell's method.
 *
 * If fu does not already have a face_g_plane associated, only
 * vertices in fu will participate, and if it has only one loop
 * Newell's method will be used rather than a least square fit.
 *
 * if fu has a face_g_plane, then all vertices in any face that
 * references the same face_g_plane will participate in the
 * fit for the face plane.
 *
 * Returns:
 *	0 - All is well
 *	1 - Failed to calculate face geometry
 *
 */

int
nmg_calc_face_plane(struct faceuse *fu_in, fastf_t *pl)
{
	struct faceuse *fu;
	struct bu_ptbl verts;
	plane_t old_pl;
	struct face *f;
	struct face_g_plane *fg;
	struct loopuse *lu;
	mat_t matrix;
	mat_t inverse;
	fastf_t det;
	double one_over_vertex_count;
	vect_t vsum;
	fastf_t min_dist=MAX_FASTF;
	fastf_t max_dist=(-MAX_FASTF);
	int i;
	int got_dir=0;
	int failed=0;
	int loop_count=0;

	fu = fu_in;
	NMG_CK_FACEUSE( fu );

	/* find an OT_SAME loop to use for calculating general direction of normal */
	for( BU_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
	{
		if( !got_dir && BU_LIST_FIRST_MAGIC( &lu->down_hd ) == NMG_EDGEUSE_MAGIC )
		{
			/* get general direction for face normal */
			nmg_loop_plane_newell( lu , old_pl );
			if( old_pl[X] != 0.0 || old_pl[Y] != 0.0 || old_pl[Z] != 0.0 )
				got_dir = 1;
		}

		loop_count++;
	}

	if( !got_dir )
		return( 1 );

	f = fu->f_p;
	NMG_CK_FACE( f );
	fg = f->g.plane_p;
	if( fg )
	{
		struct face *f1;

		NMG_CK_FACE_G_PLANE( fg );

		/* count loops using this face geometry */
		loop_count = 0;
		for( BU_LIST_FOR( f1 , face, &fg->f_hd ) )
		{
			for( BU_LIST_FOR( lu, loopuse, &f1->fu_p->lu_hd ) )
				loop_count++;
		}

		/* if this face geometry only has one loop using it, just use Newell's method */
		if( loop_count < 2 )
		{
			HMOVE( pl, old_pl );
			return( 0 );
		}

		nmg_tabulate_face_g_verts( &verts , fg );
	}
	else		/* just use vertices from this faceuse */
	{
		/* If this faceuse only has one loop, just use Newell's method */
		if( loop_count < 2 )
		{
			HMOVE( pl, old_pl );
			return( 0 );
		}

		nmg_vertex_tabulate( &verts , &fu->l.magic );
	}

	/* Get the direction for the plane normal in "old_pl".
	 * Make sure we are dealing with OT_SAME or OT_UNSPEC faceuse.
	 */
	if( fu->orientation != OT_UNSPEC )
	{
		if( fu->orientation != OT_SAME )
			fu = fu->fumate_p;
		if( fu->orientation != OT_SAME )
		{
			bu_log( "nmg_calc_face_plane: fu x%x has no OT_SAME use\n" , fu );
			bu_ptbl_free( &verts );
			return( 1 );
		}
	}

	/* build matrix */
	MAT_ZERO( matrix );
	VSET( vsum , 0.0 , 0.0 , 0.0 );

	one_over_vertex_count = 1.0/(double)(BU_PTBL_END( &verts ));

	for( i=0 ; i<BU_PTBL_END( &verts ) ; i++ )
	{
		struct vertex *v;
		struct vertex_g *vg;

		v = (struct vertex *)BU_PTBL_GET( &verts , i );
		vg = v->vg_p;

		matrix[0] += vg->coord[X] * vg->coord[X];
		matrix[1] += vg->coord[X] * vg->coord[Y];
		matrix[2] += vg->coord[X] * vg->coord[Z];
		matrix[5] += vg->coord[Y] * vg->coord[Y];
		matrix[6] += vg->coord[Y] * vg->coord[Z];
		matrix[10] += vg->coord[Z] * vg->coord[Z];

		vsum[X] += vg->coord[X];
		vsum[Y] += vg->coord[Y];
		vsum[Z] += vg->coord[Z];
	}
	matrix[4] = matrix[1];
	matrix[8] = matrix[2];
	matrix[9] = matrix[6];
	matrix[15] = 1.0;


	/* Check that we don't have a singular matrix */
	det = bn_mat_determinant( matrix );

	if( !NEAR_ZERO( det , SMALL_FASTF ) )
	{
		fastf_t inv_len_pl;

		/* invert matrix */
		bn_mat_inv( inverse , matrix );

		/* get normal vector */
		MAT4X3PNT( pl , inverse , vsum );

		/* unitize direction vector */
		inv_len_pl = 1.0/(MAGNITUDE( pl ));
		HSCALE( pl , pl , inv_len_pl );

		/* get average vertex coordinates */
		VSCALE( vsum, vsum, one_over_vertex_count );

		/* get distance from plane to orgin */
		pl[H] = VDOT( pl , vsum );

		/* make sure it points in the correct direction */
		if( VDOT( pl , old_pl ) < 0.0 )
			HREVERSE( pl , pl );
	}
	else
	{
		struct vertex *v,*v0;
		int x_same=1;
		int y_same=1;
		int z_same=1;

		/* singular matrix, may occur if all vertices have the same zero
		 * component.
		 */
		v0 = (struct vertex *)BU_PTBL_GET( &verts , 0 );
		for( i=1 ; i<BU_PTBL_END( &verts ) ; i++ )
		{
			v = (struct vertex *)BU_PTBL_GET( &verts , i );

			if( v->vg_p->coord[X] != v0->vg_p->coord[X] )
				x_same = 0;
			if( v->vg_p->coord[Y] != v0->vg_p->coord[Y] )
				y_same = 0;
			if( v->vg_p->coord[Z] != v0->vg_p->coord[Z] )
				z_same = 0;

			if( !x_same && !y_same && !z_same )
				break;
		}

		if( x_same )
		{
			VSET( pl , 1.0 , 0.0 , 0.0 );
		}
		else if( y_same )
		{
			VSET( pl , 0.0 , 1.0 , 0.0 );
		}
		else if( z_same )
		{
			VSET( pl , 0.0 , 0.0 , 1.0 );
		}

		if( x_same || y_same || z_same )
		{
			/* get average vertex coordinates */
			VSCALE( vsum, vsum, one_over_vertex_count );

			/* get distance from plane to orgin */
			pl[H] = VDOT( pl , vsum );

			/* make sure it points in the correct direction */
			if( VDOT( pl , old_pl ) < 0.0 )
				HREVERSE( pl , pl );
		}
		else
		{
			bu_log( "nmg_calc_face_plane: Cannot calculate plane for fu x%x\n" , fu );
			nmg_pr_fu_briefly( fu , (char *)NULL );
			bu_log( "%d verts\n" , BU_PTBL_END( &verts ) );
			failed = 1;
		}
	}

	/* make sure plane is at center of range of vertices */
	for( i=0 ; i<BU_PTBL_END( &verts ) ; i++ )
	{
		struct vertex *v;
		struct vertex_g *vg;
		fastf_t dist;

		v = (struct vertex *)BU_PTBL_GET( &verts, i );
		vg = v->vg_p;

		dist = DIST_PT_PLANE( vg->coord, pl );
		if( dist > max_dist )
			max_dist = dist;
		if( dist < min_dist )
			min_dist = dist;
	}

	pl[H] += (max_dist + min_dist)/2.0;

	bu_ptbl_free( &verts );
	return( failed );
}

/*	N M G _ C A L C _ F A C E _ G
 *
 * interface to nmg_calc_face_plane(), calls nmg_face_g with the
 * resulting plane
 *
 */
int
nmg_calc_face_g(struct faceuse *fu)
{
	plane_t pl;
	int ret_val;

	ret_val = nmg_calc_face_plane( fu, pl );

	if( !ret_val )
		nmg_face_g( fu, pl );

	return( ret_val );
}

/*
 *			N M G _ F A C E U S E _ A R E A
 *
 *	The following routines calculate surface area of
 *	NMG objects. Note that this includes all surfaces,
 *	not just external surfaces, i.e., an NMG object consisting
 *	of two adjacent cubes with a coincident face will have a
 *	surface area of 12*s*s (s is length of one side)
 */

fastf_t
nmg_faceuse_area(const struct faceuse *fu)
{
	struct loopuse *lu;
	plane_t plane;
	fastf_t area=0.0;
	fastf_t tmp_area;

	NMG_CK_FACEUSE( fu );

	for( BU_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
	{
		if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
			continue;

		tmp_area = nmg_loop_plane_area( lu , plane );
		if( tmp_area < 0.0 )
			continue;

		if( lu->orientation == OT_SAME )
			area += tmp_area;
		else if( lu->orientation == OT_OPPOSITE )
			area -= tmp_area;
		else
		{
			bu_log( "nmg_faceuse_area: Cannot calculate area (lu with %s orientation)\n",
				nmg_orientation( lu->orientation ) );
			return( (fastf_t)-1.0 );
		}
	}

	return( area );
}

fastf_t
nmg_shell_area(const struct shell *s)
{
	fastf_t area=0.0;
	fastf_t tmp_area;
	struct faceuse *fu;

	NMG_CK_SHELL( s );

	for( BU_LIST_FOR( fu , faceuse , &s->fu_hd ) )
	{
		if( fu->orientation != OT_SAME )
			continue;

		tmp_area = nmg_faceuse_area( fu );
		if( tmp_area < 0.0 )
			continue;

		area += tmp_area;
	}

	return( area );
}

fastf_t
nmg_region_area(const struct nmgregion *r)
{
	struct shell *s;
	fastf_t area=0.0;

	NMG_CK_REGION( r );

	for( BU_LIST_FOR( s , shell , &r->s_hd ) )
		area += nmg_shell_area( s );

	return( area );
}

fastf_t
nmg_model_area(const struct model *m)
{
	struct nmgregion *r;
	fastf_t area=0.0;

	NMG_CK_MODEL( m );

	for( BU_LIST_FOR( r , nmgregion , &m->r_hd ) )
		area += nmg_region_area( r );

	return( area );
}

/*	R T _ D I S T _ L I N E 3 _ L I N E 3
 *
 *  Calculate closest approach of two lines
 *
 *  returns:
 *	-2 -> lines are parallel and do not intersect
 *	-1 -> lines are parallel and collinear
 *	 0 -> lines intersect
 *	 1 -> lines do not intersect
 *  For return values less than zero, dist is not set.
 *  For return valuse of 0 or 1, dist[0] is the distance
 *  from p1 in the d1 direction to the point of closest
 *  approach for that line.  Similar for the second line.
 *  d1 and d2 must be unit direction vectors.
XXX How is this different from bn_isect_line3_line3() ?
XXX Why are the calling sequences just slightly different?
XXX Can we pick the better one, and get rid of the other one?
XXX If not, can we document how they differ?
 */

int
rt_dist_line3_line3(fastf_t *dist, const fastf_t *p1, const fastf_t *d1, const fastf_t *p2, const fastf_t *d2, const struct bn_tol *tol)
{
	fastf_t d1_d2;
	point_t a1,a2;
	vect_t a1_to_a2;
	vect_t p2_to_p1;
	fastf_t min_dist;
	fastf_t tol_dist_sq;
	fastf_t tol_dist;

	BN_CK_TOL( tol );

	if( tol->dist > 0.0 )
		tol_dist = tol->dist;
	else
		tol_dist = 0.005;

	if( tol->dist_sq > 0.0 )
		tol_dist_sq = tol->dist_sq;
	else
		tol_dist_sq = tol_dist * tol_dist;

	if( !NEAR_ZERO( MAGSQ( d1 ) - 1.0 , tol_dist_sq ) )
	{
		bu_log( "rt_dist_line3_line3: non-unit length direction vector ( %f %f %f )\n" , V3ARGS( d1 ) );
		rt_bomb( "rt_dist_line3_line3\n" );
	}

	if( !NEAR_ZERO( MAGSQ( d2 ) - 1.0 , tol_dist_sq ) )
	{
		bu_log( "rt_dist_line3_line3: non-unit length direction vector ( %f %f %f )\n" , V3ARGS( d2 ) );
		rt_bomb( "rt_dist_line3_line3\n" );
	}

	d1_d2 = VDOT( d1 , d2 );

	if( BN_VECT_ARE_PARALLEL( d1_d2 , tol ) )
	{
		if( bn_dist_line3_pt3( p1 , d1 , p2 ) > tol_dist )
			return( -2 ); /* parallel, but not collinear */
		else
			return( -1 ); /* parallel and collinear */
	}

	VSUB2( p2_to_p1 , p1 , p2 );
	dist[0] = (d1_d2 * VDOT( p2_to_p1 , d2 ) - VDOT( p2_to_p1 , d1 ))/(1.0 - d1_d2 * d1_d2 );
	dist[1] = dist[0] * d1_d2 + VDOT( p2_to_p1 , d2 );

	VJOIN1( a1 , p1 , dist[0] , d1 );
	VJOIN1( a2 , p2 , dist[1] , d2 );

	VSUB2( a1_to_a2 , a2 , a1 );
	min_dist = MAGNITUDE( a1_to_a2 );
	if( min_dist < tol_dist )
		return( 0 );
	else
		return( 1 );
}

/*	R T _ D I S T _ L I N E 3 _ L S E G 3
 *
 *  calculate intersection or closest approach of
 *  a line and a line segement.
 *
 *  returns:
 *	-2 -> line and line segment are parallel and collinear.
 *	-1 -> line and line segment are parallel, not collinear.
 *	 0 -> intersection between points a and b.
 *	 1 -> intersection outside a and b.
 *	 2 -> closest approach is between a and b.
 *	 3 -> closest approach is outside a and b.
 *
 *  dist[0] is actual distance from p in d direction to
 *  closest portion of segment.
 *  dist[1] is ratio of distance from a to b (0.0 at a, and 1.0 at b),
 *  dist[1] may be less than 0 or greater than 1.
 *  For return values less than 0, closest approach is defined as
 *  closest to point p.
 *  Direction vector, d, must be unit length.
XXX This should be moved to libbn/plane.c
XXX probably renamed as bn_dist_line3_line3().
 */

int
rt_dist_line3_lseg3(fastf_t *dist, const fastf_t *p, const fastf_t *d, const fastf_t *a, const fastf_t *b, const struct bn_tol *tol)
{
	vect_t a_to_b;
	vect_t a_dir;
	fastf_t len_ab;
	int outside_segment;
	int ret;

	BN_CK_TOL( tol );

	VSUB2( a_to_b , b , a );
	len_ab = MAGNITUDE( a_to_b );
	VSCALE( a_dir , a_to_b , (1.0/len_ab) );

	ret = rt_dist_line3_line3( dist , p , d , a , a_dir , tol );

	if( ret < 0 )
	{
		vect_t to_a,to_b;
		fastf_t dist_to_a,dist_to_b;

		VSUB2( to_a , a , p );
		VSUB2( to_b , b , p );
		dist_to_a = VDOT( to_a , d );
		dist_to_b = VDOT( to_b , d );

		if( dist_to_a <= dist_to_b )
		{
			dist[0] = dist_to_a;
			dist[1] = 0.0;
		}
		else
		{
			dist[0] = dist_to_b;
			dist[1] = 1.0;
		}
		return( ret );
	}

	if( dist[1] >= (-tol->dist) && dist[1] <= len_ab + tol->dist )
	{
		/* intersect or closest approach between a and b */
		outside_segment = 0;
		dist[1] = dist[1]/len_ab;
		if( dist[1] < 0.0 )
			dist[1] = 0.0;
		if( dist[1] > 1.0 )
			dist[1] = 1.0;
	}
	else
	{
		outside_segment = 1;
		dist[1] = dist[1]/len_ab;
	}

	return( 2*ret + outside_segment );
}


/* N M G _ P U R G E _ U N W A N T E D _ I N T E R S E C T I O N _ P O I N T S
 *
 *	Make sure that the list of intersection points doesn't contain
 *	any vertexuses from loops whose bounding boxes don;t overlap the
 *	bounding box of a loop in the given faceuse.
 *
 *	This is really a special purpose routine to help the intersection
 *	operations of the boolean process.  The only reason it's here instead
 *	of nmg_inter.c is that it knows too much about the format and contents
 *	of an bu_ptbl structure.
 */
void
nmg_purge_unwanted_intersection_points(struct bu_ptbl *vert_list, fastf_t *mag_list, const struct faceuse *fu, const struct bn_tol *tol)
{
	int			i;
	int			j;
	struct vertexuse	*vu;
	struct loopuse		*lu;
	const struct loop_g	*lg;
	const struct loopuse	*fu2lu;
	const struct loop_g	*fu2lg = (const struct loop_g *)NULL;
	int			overlap = 0;

	NMG_CK_FACEUSE(fu);
	BN_CK_TOL(tol);

	if (rt_g.NMG_debug & DEBUG_POLYSECT)
	{
		bu_log("nmg_purge_unwanted_intersection_points(0x%08x, 0x%08x)\n", vert_list, fu);
		bu_log("\t%d vertexuses in list\n", vert_list->end );
	}

	for (i=0 ; i < vert_list->end ; i++) {
		vu = (struct vertexuse *)vert_list->buffer[i];
		if( vu->l.magic != NMG_VERTEXUSE_MAGIC )
		{
			/* vertexuse probably killed by nmg_repair_v_near_v() */
			/* delete the entry from the vertex list */
			for (j=i ; j < vert_list->end ; j++)
			{
				vert_list->buffer[j] = vert_list->buffer[j+1];
				mag_list[j] = mag_list[j+1];
			}

			--(vert_list->end);
			vert_list->buffer[vert_list->end] = (long *)NULL;
			mag_list[vert_list->end] = MAX_FASTF;
			--i;
			continue;
		}
		NMG_CK_VERTEXUSE(vu);
		lu = nmg_find_lu_of_vu( vu );
		NMG_CK_LOOPUSE(lu);
		lg = lu->l_p->lg_p;
		NMG_CK_LOOP_G(lg);

		if (rt_g.NMG_debug & DEBUG_POLYSECT) {
			bu_log("vu[%d]: 0x%08x (%g %g %g) lu: 0x%08x %s\n",
				i, vu, V3ARGS(vu->v_p->vg_p->coord),
				lu, nmg_orientation(lu->orientation) );
			bu_log("\tlu BBox: (%g %g %g) (%g %g %g)\n",
				V3ARGS(lg->min_pt), V3ARGS(lg->max_pt) );
		}
		if (lu->up.fu_p->f_p == fu->f_p)
			bu_log("I'm checking against my own face?\n");

		/* If the bounding box of a loop doesn't intersect the
		 * bounding box of a loop in the other face, it shouldn't
		 * be on the list of intersecting loops.
		 */
		overlap = 0;
		for (BU_LIST_FOR(fu2lu, loopuse, &fu->lu_hd )){
			NMG_CK_LOOPUSE(fu2lu);
			NMG_CK_LOOP(fu2lu->l_p);

			switch(fu2lu->orientation)  {
			case OT_BOOLPLACE:
				/*  If this loop is destined for removal
				 *  by sanitize(), skip it.
				 */
				continue;
			case OT_UNSPEC:
				/* If this is a loop of a lone vertex,
				 * it was deposited into the
				 * other loop as part of an intersection
				 * operation, and is quite important.
				 */
				if( BU_LIST_FIRST_MAGIC(&fu2lu->down_hd) != NMG_VERTEXUSE_MAGIC )
					bu_log("nmg_purge_unwanted_intersection_points() non self-loop OT_UNSPEC vertexuse in fu2?\n");
				break;
			case OT_SAME:
			case OT_OPPOSITE:
				break;
			default:
				bu_log("nmg_purge_unwanted_intersection_points encountered %s loop in fu2\n",
					nmg_orientation(fu2lu->orientation));
				/* Process it anyway */
				break;
			}

			fu2lg = fu2lu->l_p->lg_p;
			NMG_CK_LOOP_G(fu2lg);

			if (rt_g.NMG_debug & DEBUG_POLYSECT) {
				bu_log("\tfu2lu BBox: (%g %g %g)  (%g %g %g) %s\n",
					V3ARGS(fu2lg->min_pt), V3ARGS(fu2lg->max_pt),
					nmg_orientation(fu2lu->orientation) );
			}

			if (V3RPP_OVERLAP_TOL(fu2lg->min_pt, fu2lg->max_pt,
			    lg->min_pt, lg->max_pt, tol)) {
				overlap = 1;
				break;
			}
		}
		if (!overlap) {
			/* why is this vertexuse in the list? */
			if (rt_g.NMG_debug & DEBUG_POLYSECT) {
				bu_log("nmg_purge_unwanted_intersection_points This little bugger slipped in somehow.  Deleting it from the list.\n");
				nmg_pr_vu_briefly(vu, (char *)NULL);
			}
			if( BU_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC &&
			    lu->orientation == OT_UNSPEC )  {
				/* Drop this loop of a single vertex in sanitize() */
				if (rt_g.NMG_debug & DEBUG_POLYSECT)
					bu_log("nmg_purge_unwanted_intersection_points() remarking as OT_BOOLPLACE\n");
				lu->orientation =
				  lu->lumate_p->orientation = OT_BOOLPLACE;
			}

			/* delete the entry from the vertex list */
			for (j=i ; j < vert_list->end ; j++)
			{
				vert_list->buffer[j] = vert_list->buffer[j+1];
				mag_list[j] = mag_list[j+1];
			}

			--(vert_list->end);
			vert_list->buffer[vert_list->end] = (long *)NULL;
			mag_list[vert_list->end] = MAX_FASTF;
			--i;
		}
	}
	if (rt_g.NMG_debug & DEBUG_POLYSECT)
		bu_log("\tAt end of nmg_purge_unwanted_intersection_points, %d vertexuses in list\n",
				vert_list->end );
}


/*				N M G _ I N _ O R _ R E F
 *
 *	if the given vertexuse "vu" is in the table given by "b" or if "vu"
 *	references a vertex which is refernced by a vertexuse in the table,
 *	then we return 1.  Otherwise, we return 0.
 */
int 
nmg_in_or_ref(struct vertexuse *vu, struct bu_ptbl *b)
{
	union {
		struct vertexuse **vu;
		long **magic_p;
	} p;
	int i;

	p.magic_p = b->buffer;
	for (i=0 ; i < b->end ; ++i) {
		if (p.vu[i] && *p.magic_p[i] == NMG_VERTEXUSE_MAGIC &&
		    (p.vu[i] == vu || p.vu[i]->v_p == vu->v_p))
			return(1);
	}
	return(0);
}

/*
 *			N M G _ R E B O U N D
 *
 *  Re-compute all the bounding boxes in the NMG model.
 *  Bounding boxes are presently found in these structures:
 *	loop_g
 *	face_g
 *	shell_a
 *	nmgregion_a
 *  The re-bounding must be performed in a bottom-up manner,
 *  computing the loops first, and working up to the nmgregions.
 */
void
nmg_rebound(struct model *m, const struct bn_tol *tol)
{
	struct nmgregion	*r;
	struct shell		*s;
	struct faceuse		*fu;
	struct face		*f;
	struct loopuse		*lu;
	struct loop		*l;
	register int		*flags;

	NMG_CK_MODEL(m);
	BN_CK_TOL(tol);

	flags = (int *)bu_calloc( m->maxindex*2, sizeof(int), "rebound flags[]" );

	for( BU_LIST_FOR( r, nmgregion, &m->r_hd ) )  {
		NMG_CK_REGION(r);
		for( BU_LIST_FOR( s, shell, &r->s_hd ) )  {
			NMG_CK_SHELL(s);

			/* Loops in faces in shell */
			for( BU_LIST_FOR( fu, faceuse, &s->fu_hd ) )  {
				NMG_CK_FACEUSE(fu);
				/* Loops in face */
				for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )  {
					NMG_CK_LOOPUSE(lu);
					l = lu->l_p;
					NMG_CK_LOOP(l);
					if( NMG_INDEX_FIRST_TIME(flags,l) )
						nmg_loop_g(l, tol);
				}
			}
			/* Faces in shell */
			for( BU_LIST_FOR( fu, faceuse, &s->fu_hd ) )  {
				NMG_CK_FACEUSE(fu);
				f = fu->f_p;
				NMG_CK_FACE(f);

				/* Rebound the face */
				if( NMG_INDEX_FIRST_TIME(flags,f) )
					nmg_face_bb( f, tol );
			}

			/* Wire loops in shell */
			for( BU_LIST_FOR( lu, loopuse, &s->lu_hd ) )  {
				NMG_CK_LOOPUSE(lu);
				l = lu->l_p;
				NMG_CK_LOOP(l);
				if( NMG_INDEX_FIRST_TIME(flags,l) )
					nmg_loop_g(l, tol);
			}

			/*
			 *  Rebound the shell.
			 *  This routine handles wire edges and lone vertices.
			 */
			if( NMG_INDEX_FIRST_TIME(flags,s) )
				nmg_shell_a( s, tol );
		}

		/* Rebound the nmgregion */
		nmg_region_a( r, tol );
	}

	bu_free( (char *)flags, "rebound flags[]" );
}

/*
 *			N M G _ C O U N T _ S H E L L _ K I D S
 */
void
nmg_count_shell_kids(const struct model *m, long unsigned int *total_faces, long unsigned int *total_wires, long unsigned int *total_points)
{
	short *tbl;

	const struct nmgregion *r;
	const struct shell *s;
	const struct faceuse *fu;
	const struct loopuse *lu;
	const struct edgeuse *eu;

	NMG_CK_MODEL(m);

	tbl = (short *)bu_calloc(m->maxindex+1, sizeof(char),
		"face/wire/point counted table");

	*total_faces = *total_wires = *total_points = 0;
	for (BU_LIST_FOR(r, nmgregion, &m->r_hd)) {
		for (BU_LIST_FOR(s, shell, &r->s_hd)) {
			if (s->vu_p) {
				total_points++;
				continue;
			}
			for (BU_LIST_FOR(fu, faceuse, &s->fu_hd)) {
				if (NMG_INDEX_TEST_AND_SET(tbl, fu->f_p))
					(*total_faces)++;
			}
			for (BU_LIST_FOR(lu, loopuse, &s->lu_hd)) {
				if (NMG_INDEX_TEST_AND_SET(tbl, lu->l_p))
					(*total_wires)++;
			}
			for (BU_LIST_FOR(eu, edgeuse, &s->eu_hd)) {
				if (NMG_INDEX_TEST_AND_SET(tbl, eu->e_p))
					(*total_wires)++;
			}
		}
	}

	bu_free((char *)tbl, "face/wire/point counted table");
}

/*
 *	O R D E R _ T B L
 *
 *	private support routine for nmg_close_shell
 *	creates an array of indices into a table of edgeuses, ordered
 *	end-to-end. This may or may not create an actual loop.
 *
 *	Arguments:
 *	tbl is the table (provided by caller)
 *	index is the array of indices created by order_tbl
 *	tbl_size is the size of the table (provided by caller)
 *	loop_size is the number of edgeuses in the loop (calculated by order_tbl)
 */
static void
order_tbl(struct bu_ptbl *tbl, int start_index, int **index, int tbl_size, int *loop_size)
{
	int i,j,k;
	int found;
	struct edgeuse *eu,*eu1;
	struct vertex *start_v;

	/* create an index into the table, ordered to create a loop */
	if( *index == NULL )
		(*index) = (int *)bu_calloc( tbl_size , sizeof( int ) , "Table index" );

	for( i=0 ; i<tbl_size ; i++ )
		(*index)[i] = (-1);

	/* start the loop at index = start_index */
	(*index)[0] = start_index;
	*loop_size = 1;
	eu = (struct edgeuse *)BU_PTBL_GET( tbl , start_index );
	start_v = eu->vu_p->v_p;
	i = 0;
	found = 1;
	while( eu->eumate_p->vu_p->v_p != start_v && found )
	{
		found = 0;

		/* Look for edgeuse that starts where "eu" ends */
		for( j=0 ; j<tbl_size ; j++ )
		{
			int already_used = 0;

			eu1 = (struct edgeuse *)BU_PTBL_GET( tbl , j );

			/* don't use same edgeuse twice!!! */
			for( k=0 ; k<(*loop_size) ; k++ )
			{
				if( eu1 == (struct edgeuse *)BU_PTBL_GET( tbl, (*index)[k] ) )
				{
					already_used = 1;
					break;
				}
			}
			if( already_used )
				continue;
			if( eu1->vu_p->v_p == eu->eumate_p->vu_p->v_p )
			{
				/* Found it */
				found = 1;
				(*index)[++i] = j;
				(*loop_size)++;
				eu = eu1;
				break;
			}
		}
	}
}

/*
 *	N M G _ C L O S E _ S H E L L
 *
 *	Examines the passed shell and, if there are holes, closes them
 *	note that not much care is taken as to how the holes are closed
 *	so the results are not entirely predictable.
 *	A list of free edges is created (edges bounding only one face).
 *	New faces are constructed by taking two consecutive edges
 *	and making a face. The newly created edge is added to the list
 *	of free edges and the two used ones are removed.
 *
 */
void
nmg_close_shell(struct shell *s, const struct bn_tol *tol)
{
	struct bu_ptbl eu_tbl;		/* table of free edgeuses from shell */
	struct bu_ptbl vert_tbl;	/* table of vertices for use in nmg_cface */
	int *index;			/* array of indices into eu_tbl, ordered to form a loop */
	int loop_size;			/* number of edgeueses in loop */
	struct faceuse *fu;
	struct loopuse *lu;
	struct edgeuse *eu;
	int start_loop;
	int i;
	int found;

	if( rt_g.NMG_debug & DEBUG_BASIC )
		bu_log( "nmg_close_shell: s = x%x\n" , s );

	NMG_CK_SHELL( s );
	BN_CK_TOL( tol );

	index = NULL;

	/* construct a table of free edges */
	(void)bu_ptbl_init( &eu_tbl , 64, " &eu_tbl ");

	/* loop through all the faces in the shell */
	for( BU_LIST_FOR( fu , faceuse , &s->fu_hd ) )
	{
		NMG_CK_FACEUSE( fu );
		/* only look at OT_SAME faces */
		if( fu->orientation == OT_SAME )
		{
			/* loop through each loopuse in the face */
			for( BU_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
			{
				NMG_CK_LOOPUSE( lu );
				/* ignore loops that are just a vertex */
				if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) ==
					NMG_VERTEXUSE_MAGIC )
						continue;

				/* loop through all the edgeuses in the loop */
				for( BU_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
				{
					NMG_CK_EDGEUSE( eu );
					/* if this edgeuse is a free edge, add its mate to the list */
					if( eu->radial_p == eu->eumate_p )
						(void)bu_ptbl_ins( &eu_tbl , (long *) eu->eumate_p );
				}
			}
		}
	}

	/* if there is nothing in our list of free edges, the shell is already closed */
	if( BU_PTBL_END( &eu_tbl ) == 0 )
	{
		bu_ptbl_free( &eu_tbl );
		return;
	}

	/* create a table of vertices */
	(void)bu_ptbl_init( &vert_tbl , 64, " &vert_tbl ");

	while( BU_PTBL_END( &eu_tbl ) )
	{
		int give_up_on_face=0;

		/* Create an index into the table that orders the edgeuses into a loop */
		start_loop = -1;
		loop_size = 0;
		while( loop_size < 2 )
		{
			if( ++start_loop > BU_PTBL_END( &eu_tbl ) - 3 )
				break;
			order_tbl( &eu_tbl, start_loop , &index , BU_PTBL_END( &eu_tbl ) , &loop_size );
		}

		/* Create new faces to close the shell */
		while( loop_size > 3 )
		{
			struct edgeuse *eu1, *eu2=NULL, *eu_new = NULL;
			struct edgeuse **eu_used;	/* array of edgueses used, for deletion */
			int edges_used=0;			/* number of edges used in making a face */
			int found_face=0;		/* flag - indicates that a face with the correct normal will be created */
			int start_index,end_index;	/* start and stop index for loop */
			int coplanar;			/* flag - indicates entire loop is coplanar */
			plane_t pl1,pl2;		/* planes for checking coplanarity of loop */
			point_t pt[3];			/* points for calculating planes */

			/* Look for an easy way out, maybe this loop is planar */
			/* first, calculate a plane from the first three non-collinear vertices */
			start_index = 0;
			end_index = start_index + 3;
			
			for( i=start_index ; i<end_index ; i++ )
			{
				eu = (struct edgeuse *)BU_PTBL_GET( &eu_tbl , index[i] );
				VMOVE( pt[i-start_index] , eu->vu_p->v_p->vg_p->coord );
			}
			while( bn_mk_plane_3pts( pl1 , pt[0] , pt[1] , pt[2] , tol ) && end_index<loop_size )
			{
				start_index++;
				end_index++;
				for( i=start_index ; i<end_index ; i++ )
				{
					eu = (struct edgeuse *)BU_PTBL_GET( &eu_tbl , index[i] );
					VMOVE( pt[i-start_index] , eu->vu_p->v_p->vg_p->coord );
				}
			}
			if( end_index == loop_size )
			{
				if( BU_PTBL_END( &eu_tbl ) > loop_size )
				{
					int old_loop_size=loop_size;

					loop_size = 0;
					while( loop_size < 3 )
					{
						found = 1;
						for( start_loop=index[0]+1 ; start_loop < BU_PTBL_END( &eu_tbl )-3 ; start_loop++ )
						{
							found = 0;
							for( i=0 ; i<old_loop_size ; i++ )
							{
								if( index[i] == start_loop )
								{
									found = 1;
									break;
								}
							}
							if( !found )
								break;
						}
						if( found )
						{
							/* Could not even make a plane, this is some serious screw-up */
							bu_log( "nmg_close_shell: cannot make any planes from loop, old_loop_size = %d\n", old_loop_size );
							for( i=0 ; i<old_loop_size ; i++ )
							{
								eu= (struct edgeuse *)BU_PTBL_GET( &eu_tbl , index[i] );
								bu_log( "(%g %g %g) <-> (%g %g %g)\n",
									V3ARGS( eu->vu_p->v_p->vg_p->coord ),
									V3ARGS( eu->eumate_p->vu_p->v_p->vg_p->coord ) );
							}
							bu_bomb( "nmg_close_shell: cannot make any planes from loop\n" );
						}
						order_tbl( &eu_tbl, start_loop , &index , BU_PTBL_END( &eu_tbl ) , &loop_size );
					}
				}
			}

			/* now we have one plane, let's check the others */
			coplanar = 1;
			while( end_index < loop_size && coplanar )
			{
				end_index +=3;
				if( end_index > loop_size )
					end_index = loop_size;
				start_index = end_index - 3;

				for( i=start_index ; i<end_index ; i++ )
				{
					eu = (struct edgeuse *)BU_PTBL_GET( &eu_tbl , index[i] );
					VMOVE( pt[i-start_index] , eu->vu_p->v_p->vg_p->coord );
				}

				/* if these three points make a plane, is it coplanar with
				 * our first one??? */
				if( !bn_mk_plane_3pts( pl2 , pt[0] , pt[1] , pt[2] , tol ) )
				{
					if( (i=bn_coplanar( pl1 , pl2 , tol )) < 1 )
						coplanar = 0;
				}
			}

			if( coplanar )	/* excellent! - just make one big face */
			{
				struct edgeuse *eu_tmp;

				/* put vertices in table */
				bu_ptbl_reset( &vert_tbl );
				for( i=0 ; i<loop_size ; i++ )
				{
					eu = (struct edgeuse *)BU_PTBL_GET( &eu_tbl , index[i] );
					bu_ptbl_ins( &vert_tbl , (long *)&eu->vu_p->v_p );
				}

				/* make face */
				fu = nmg_cmface( s , (struct vertex ***)BU_PTBL_BASEADDR(&vert_tbl) , loop_size );

				/* face geometry */
				if( nmg_loop_plane_area( BU_LIST_FIRST( loopuse , &fu->lu_hd ) , pl2 ) < 0.0 )
				{
					bu_log( "Failed planeeq\n" );
					nmg_kfu( fu );
				}
				else
				{
					nmg_face_g( fu , pl2 );

					/* Calculate face bounding box */
					nmg_face_bb( fu->f_p , tol );
				}

				/* now eliminate loop from table */
				eu_used = (struct edgeuse **)bu_calloc( loop_size , sizeof( struct edguse *) , "edges used list" );
				for( i=0 ; i<loop_size ; i++ )
					eu_used[i] = (struct edgeuse *)BU_PTBL_GET( &eu_tbl , index[i] );

				for( i=0 ; i<loop_size ; i++ )
					bu_ptbl_rm( &eu_tbl , (long *)eu_used[i] );

				bu_free( (char *)eu_used , "edge used list" );

				/* may need to remove one more edgeuse from table */
				eu_tmp = nmg_find_e( (*(struct vertex **)BU_PTBL_GET( &vert_tbl, 0 )), (*(struct vertex **)BU_PTBL_GET( &vert_tbl, loop_size-1 )), (struct shell *)NULL, (struct edge *)NULL );
				if( eu_tmp )
				{
					if( eu_tmp->radial_p != eu_tmp->eumate_p )
					{
						for( i=0 ; i<BU_PTBL_END( &eu_tbl ) ; i++ )
						{
							struct edgeuse *eu2;

							eu2 = (struct edgeuse *)BU_PTBL_GET( &eu_tbl, i );
							if( EDGESADJ( eu2, eu_tmp ) )
							{
								bu_ptbl_rm( &eu_tbl , (long *)eu2 );
								break;
							}
						}
					}
				}

				/* set some flags to get us back to start of loop */
				found_face = 1;
				give_up_on_face = 1;
			}

			/* OK, so we have to do this one little-by-little */
			start_index = -1;
			end_index = -1;
			while( !found_face )
			{
				/* refresh the vertex list */
				(void)bu_ptbl_reset( &vert_tbl );

				if( end_index == 0 )
				{
					give_up_on_face = 1;
					break;
				}
				start_index++;
				end_index = start_index + 1;
				if( end_index == loop_size )
					end_index = 0;

				/* Get two edgeuses from the loop */
				eu1 = (struct edgeuse *)BU_PTBL_GET( &eu_tbl , index[start_index] );
				bu_ptbl_ins( &vert_tbl , (long *)&eu1->vu_p->v_p );

				eu2 = (struct edgeuse *)BU_PTBL_GET( &eu_tbl , index[end_index] );
				bu_ptbl_ins( &vert_tbl , (long *)&eu2->vu_p->v_p );

				edges_used = 2;	
				/* if the edges are collinear, we can't make a face */
				while( bn_3pts_collinear(
					eu1->vu_p->v_p->vg_p->coord,
					eu2->vu_p->v_p->vg_p->coord,
					eu2->eumate_p->vu_p->v_p->vg_p->coord,
					tol ) && edges_used < loop_size )
				{
					/* So, add another edge */
					end_index++;
					if( end_index == loop_size )
						end_index = 0;
					eu1 = eu2;
					eu2 = (struct edgeuse *)BU_PTBL_GET( &eu_tbl , index[end_index]);
					bu_ptbl_ins( &vert_tbl , (long *)&eu2->vu_p->v_p );
					edges_used++;
				}

				found_face = 1;
#if 0
				/* check that newly created edge isn't already a winged edge */
				vfirst = (*(struct vertex **)BU_PTBL_GET( &vert_tbl, 0 ));
				vlast = (*(struct vertex **)BU_PTBL_GET( &vert_tbl, edges_used-1 ));
				eu_tmp = nmg_find_e( vfirst, vlast, (struct shell *)NULL, (struct edge *)NULL );
				if( eu_tmp )
				{
					if( eu_tmp->radial_p != eu_tmp->eumate_p )
						found_face = 0;
				}
#endif
				
			}

			if( give_up_on_face )
			{
				loop_size = 0;
				start_loop = -1;
				break;
			}

			/* add last vertex to table */
			bu_ptbl_ins( &vert_tbl , (long *)&eu2->eumate_p->vu_p->v_p );

			/* save list of used edges to be removed later */
			eu_used = (struct edgeuse **)bu_calloc( edges_used , sizeof( struct edguse *) , "edges used list" );
			for( i=0 ; i<edges_used ; i++ )
				eu_used[i] = (struct edgeuse *)BU_PTBL_GET( &eu_tbl , index[i] );

			/* make a face */
			fu = nmg_cmface( s , (struct vertex ***)BU_PTBL_BASEADDR(&vert_tbl) , edges_used+1 );
			/* out with the old, in with the new */
			for( i=0 ; i<edges_used ; i++ )
				bu_ptbl_rm( &eu_tbl , (long *)eu_used[i] );

			if( nmg_loop_plane_area( BU_LIST_FIRST( loopuse , &fu->lu_hd ) , pl2 ) < 0.0 )
			{
				bu_log( "Failed planeeq\n" );
				nmg_kfu( fu );
			}
			else
			{
				nmg_face_g( fu , pl2 );

				/* find the newly created edgeuse */
				found = 0;
				for( BU_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
				{
					NMG_CK_LOOPUSE( lu );
					if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) ==
						NMG_VERTEXUSE_MAGIC )
							continue;
					for( BU_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
					{
						NMG_CK_EDGEUSE( eu );
						if( eu->vu_p->v_p == (*(struct vertex **)BU_PTBL_GET( &vert_tbl , 0 ))
						&& eu->eumate_p->vu_p->v_p == (*(struct vertex **)BU_PTBL_GET( &vert_tbl , edges_used) ) )
						{
							eu_new = eu;
							found = 1;
							break;
						}
						else if( eu->vu_p->v_p == (*(struct vertex **)BU_PTBL_GET( &vert_tbl , edges_used))
						&& eu->eumate_p->vu_p->v_p == (*(struct vertex **)BU_PTBL_GET( &vert_tbl , 0 ) ) )
						{
							eu_new = eu->eumate_p;
							found = 1;
							break;
						}

					}
					if( found )
						break;
				}

				if( eu_new->radial_p == eu_new->eumate_p )
					bu_ptbl_ins( &eu_tbl , (long *)eu_new );
				else
				{
					struct edgeuse *eu_tmp;

					/* find third eu to be removed from eu_tbl */
					for( i=0 ; i<BU_PTBL_END( &eu_tbl ) ; i++ )
					{
						eu_tmp = (struct edgeuse *)BU_PTBL_GET( &eu_tbl, i );
						if( eu_tmp->vu_p->v_p == eu_new->vu_p->v_p &&
						    eu_tmp->eumate_p->vu_p->v_p == eu_new->eumate_p->vu_p->v_p )
						{
							bu_ptbl_rm( &eu_tbl , (long *)eu_tmp );
							break;
						}
					}
				}
			}

			bu_free( (char *)eu_used , "edge used list" );

			/* re-order loop */
			loop_size = 0;
			start_loop = -1;
			while( loop_size < 3 && start_loop < BU_PTBL_END( &eu_tbl )-3 )
				order_tbl( &eu_tbl, ++start_loop , &index , BU_PTBL_END( &eu_tbl ) , &loop_size );
		}

		if( give_up_on_face )
			continue;

		if( loop_size == 2 )
		{
			bu_ptbl_reset( &vert_tbl );
			eu = (struct edgeuse *)BU_PTBL_GET( &eu_tbl , index[0] );
			(void)bu_ptbl_ins( &vert_tbl , (long *)&eu->vu_p->v_p);
			eu = (struct edgeuse *)BU_PTBL_GET( &eu_tbl , index[1] );
			(void)bu_ptbl_ins( &vert_tbl , (long *)&eu->vu_p->v_p);
			(void)bu_ptbl_ins( &vert_tbl , (long *)&eu->eumate_p->vu_p->v_p);
			if( !bn_3pts_collinear(
				((*(struct vertex **)BU_PTBL_GET( &vert_tbl , 0 )))->vg_p->coord,
				((*(struct vertex **)BU_PTBL_GET( &vert_tbl , 1 )))->vg_p->coord,
				((*(struct vertex **)BU_PTBL_GET( &vert_tbl , 2 )))->vg_p->coord,
				tol ) )
			{
				fu = nmg_cmface( s , (struct vertex ***)BU_PTBL_BASEADDR(&vert_tbl) , 3 );
				if( nmg_calc_face_g( fu ) )
				{
					bu_log( "Failed planeeq\n" );
					nmg_kfu( fu );
				}
			}
			else
				bu_log( "Not makeing face, edges are collinear!\n" );

			loop_size = 0;
			continue;
		}
		else if( loop_size < 2 )
		{
			loop_size = 0;
			continue;
		}

		/* if the last 3 vertices are collinear, then don't make the last face */
		bu_ptbl_reset( &vert_tbl );
		for( i=0 ; i<3 ; i++ )
		{
			eu = (struct edgeuse *)BU_PTBL_GET( &eu_tbl , index[i] );
			(void)bu_ptbl_ins( &vert_tbl , (long *)&eu->vu_p->v_p);
		}

		if( !bn_3pts_collinear(
			((*(struct vertex **)BU_PTBL_GET( &vert_tbl , 0 )))->vg_p->coord,
			((*(struct vertex **)BU_PTBL_GET( &vert_tbl , 1 )))->vg_p->coord,
			((*(struct vertex **)BU_PTBL_GET( &vert_tbl , 2 )))->vg_p->coord,
			tol ) )
		{
		
			/* Create last face from remaining 3 edges */
			fu = nmg_cmface( s , (struct vertex ***)BU_PTBL_BASEADDR(&vert_tbl) , 3 );
			if( nmg_calc_face_g( fu ) )
				bu_log( "Failed planeeq\n" );

		}
		else
			bu_log( "Not makeing face, edges are collinear!\n" );

		/* remove the last three edges from the table */
		{
			struct edgeuse *eu1,*eu2,*eu3;

			eu1 = (struct edgeuse *)BU_PTBL_GET( &eu_tbl , index[0] );
			eu2 = (struct edgeuse *)BU_PTBL_GET( &eu_tbl , index[1] );
			eu3 = (struct edgeuse *)BU_PTBL_GET( &eu_tbl , index[2] );
			bu_ptbl_rm( &eu_tbl , (long *)eu1 );
			bu_ptbl_rm( &eu_tbl , (long *)eu2 );
			bu_ptbl_rm( &eu_tbl , (long *)eu3 );
		}
	}

	/* Free up all the memory */
	bu_free( (char *)index , "index" );
	bu_ptbl_free( &eu_tbl );
	bu_ptbl_free( &vert_tbl );

}

/*
 *	N M G _ D U P _ S H E L L
 *
 *	Duplicate a shell and return the new copy. New shell is
 *	in the same region.
 *
 *  The vertex geometry is copied from the source faces into topologically
 *  distinct (new) vertex and vertex_g structs.
 *  They will start out being geometricly coincident, but it is anticipated
 *  that the caller will modify the geometry, e.g. as in an extrude operation.
 *
 *  NOTE: This routine creates a translation table that gives the
 *  correspondence between old and new structures, the caller is responsible
 *  for freeing this memory. Warning - NOT EVERY structure is assigned a
 *  correspondence.
 */
struct shell *
nmg_dup_shell(struct shell *s, long int ***trans_tbl, const struct bn_tol *tol)
{

	struct model *m;
	struct shell *new_s;
	struct faceuse *fu;
	struct loopuse *lu,*new_lu;
	struct edgeuse *eu;
	struct faceuse *new_fu;
	struct bu_ptbl faces;
	int tbl_size;

	if( rt_g.NMG_debug & DEBUG_BASIC) 
		bu_log( "nmg_dup_shell( s = x%x , trans_tbl = x%x )\n" , s , trans_tbl );

	NMG_CK_SHELL( s );
	BN_CK_TOL( tol );

	m = nmg_find_model( (long *)s );

	/* create translation table double size to accomodate both copies */
	tbl_size = m->maxindex * 3;
	(*trans_tbl) = (long **)bu_calloc(tbl_size, sizeof(long *),
		"nmg_dup_shell trans_tbl" );

	bu_ptbl_init( &faces , 64, " &faces ");

	new_s = nmg_msv( s->r_p );
	if( s->index >= tbl_size ) rt_bomb( "nmg_dup_shell: trans table exceeded\n" );
	NMG_INDEX_ASSIGN( (*trans_tbl) , s , (long *)new_s );
	if( new_s->index >= tbl_size ) rt_bomb( "nmg_dup_shell: trans table exceeded\n" );
	NMG_INDEX_ASSIGN( (*trans_tbl) , new_s , (long *)s );

	/* copy face uses */
	for( BU_LIST_FOR( fu , faceuse , &s->fu_hd ) )
	{
		NMG_CK_FACEUSE( fu );
		if( fu->orientation == OT_SAME )
		{
			new_fu = (struct faceuse *)NULL;
			for( BU_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
			{
				NMG_CK_LOOPUSE( lu );
				if( new_fu )
				{
					new_lu = nmg_dup_loop( lu , &new_fu->l.magic , (*trans_tbl) );
					if( lu->index >= tbl_size ) rt_bomb( "nmg_dup_shell: trans table exceeded\n" );
					NMG_INDEX_ASSIGN( (*trans_tbl) , lu , (long *)new_lu );
					if( new_lu->index >= tbl_size ) rt_bomb( "nmg_dup_shell: trans table exceeded\n" );
					NMG_INDEX_ASSIGN( (*trans_tbl) , new_lu , (long *)lu );
				}
				else
				{
					new_lu = nmg_dup_loop( lu , &new_s->l.magic , (*trans_tbl) );
					if( new_lu->index >= tbl_size ) rt_bomb( "nmg_dup_shell: trans table exceeded\n" );
					NMG_INDEX_ASSIGN( (*trans_tbl) , lu , (long *)new_lu );
					if( lu->index >= tbl_size ) rt_bomb( "nmg_dup_shell: trans table exceeded\n" );
					NMG_INDEX_ASSIGN( (*trans_tbl) , new_lu , (long *)lu );
					new_fu = nmg_mf( new_lu );
					if( lu->orientation == OT_OPPOSITE )
					{
						/* nmg_mf forces loops to OT_SAME */
						new_lu->orientation = OT_OPPOSITE;
						new_lu->lumate_p->orientation = OT_OPPOSITE;
					}
					if( fu->index >= tbl_size ) rt_bomb( "nmg_dup_shell: trans table exceeded\n" );
					NMG_INDEX_ASSIGN( (*trans_tbl) , fu , (long *)new_fu );
					if( new_fu->index >= tbl_size ) rt_bomb( "nmg_dup_shell: trans table exceeded\n" );
					NMG_INDEX_ASSIGN( (*trans_tbl) , new_fu , (long *)fu );
					if( fu->fumate_p->index >= tbl_size ) rt_bomb( "nmg_dup_shell: trans table exceeded\n" );
					NMG_INDEX_ASSIGN( (*trans_tbl) , fu->fumate_p , (long *)new_fu->fumate_p );
					if( new_fu->fumate_p->index >= tbl_size ) rt_bomb( "nmg_dup_shell: trans table exceeded\n" );
					NMG_INDEX_ASSIGN( (*trans_tbl) , new_fu->fumate_p , (long *)fu->fumate_p );
					if( fu->f_p->index >= tbl_size ) rt_bomb( "nmg_dup_shell: trans table exceeded\n" );
					NMG_INDEX_ASSIGN( (*trans_tbl) , fu->f_p , (long *)new_fu->f_p );
					if( new_fu->f_p->index >= tbl_size ) rt_bomb( "nmg_dup_shell: trans table exceeded\n" );
					NMG_INDEX_ASSIGN( (*trans_tbl) , new_fu->f_p , (long *)fu->f_p );
				}
			}
			if (fu->f_p->g.plane_p)
			{
#if 1
				/* Do it this way if you expect to change the normals */
				plane_t	n;
				NMG_GET_FU_PLANE( n, fu );
				nmg_face_g(new_fu, n);
#else
				/* Do it this way to share fu's geometry struct */
				nmg_jfg( fu, new_fu );
#endif

				/* XXX Perhaps this should be new_fu->f_p->g.plane_p ? */
				if( fu->f_p->g.plane_p->index >= tbl_size ) rt_bomb( "nmg_dup_shell: trans table exceeded\n" );
				NMG_INDEX_ASSIGN( (*trans_tbl) , fu->f_p->g.plane_p , (long *)new_fu->f_p->g.plane_p );
				if( new_fu->f_p->g.plane_p->index >= tbl_size ) rt_bomb( "nmg_dup_shell: trans table exceeded\n" );
				NMG_INDEX_ASSIGN( (*trans_tbl) , new_fu->f_p->g.plane_p , (long *)fu->f_p->g.plane_p );
			}
			new_fu->orientation = fu->orientation;
			new_fu->fumate_p->orientation = fu->fumate_p->orientation;
			bu_ptbl_ins( &faces , (long *)new_fu );
		}
	}

	/* glue new faces */
	nmg_gluefaces( (struct faceuse **)BU_PTBL_BASEADDR( &faces) , BU_PTBL_END( &faces ), tol );
	bu_ptbl_free( &faces );

	/* copy wire loops */
	for( BU_LIST_FOR( lu , loopuse , &s->lu_hd ) )
	{
		NMG_CK_LOOPUSE( lu );
		new_lu = nmg_dup_loop( lu , &new_s->l.magic , (*trans_tbl) );
		if( lu->index >= tbl_size ) rt_bomb( "nmg_dup_shell: trans table exceeded\n" );
		NMG_INDEX_ASSIGN( (*trans_tbl) , lu , (long *)new_lu );
		if( new_lu->index >= tbl_size ) rt_bomb( "nmg_dup_shell: trans table exceeded\n" );
		NMG_INDEX_ASSIGN( (*trans_tbl) , new_lu , (long *)lu );
	}

	/* copy wire edges */
	for( BU_LIST_FOR( eu , edgeuse , &s->eu_hd ) )
	{
		struct vertex *old_v1,*old_v2,*new_v1,*new_v2;
		struct edgeuse *new_eu;

		NMG_CK_EDGEUSE( eu );
		NMG_CK_VERTEXUSE( eu->vu_p );
		NMG_CK_VERTEX( eu->vu_p->v_p );
		NMG_CK_EDGEUSE( eu->eumate_p );
		NMG_CK_VERTEXUSE( eu->eumate_p->vu_p );
		NMG_CK_VERTEX( eu->eumate_p->vu_p->v_p );

		old_v1 = eu->vu_p->v_p;
		new_v1 = NMG_INDEX_GETP(vertex, (*trans_tbl), old_v1);
		old_v2 = eu->eumate_p->vu_p->v_p;
		new_v2 = NMG_INDEX_GETP(vertex, (*trans_tbl), old_v2);

		/* make the wire edge */
		new_eu = nmg_me( new_v1 , new_v2 , new_s );
		if( eu->index >= tbl_size ) rt_bomb( "nmg_dup_shell: trans table exceeded\n" );
		NMG_INDEX_ASSIGN( (*trans_tbl) , eu , (long *)new_eu );
		if( new_eu->index >= tbl_size ) rt_bomb( "nmg_dup_shell: trans table exceeded\n" );
		NMG_INDEX_ASSIGN( (*trans_tbl) , new_eu , (long *)eu );

		new_v1 = new_eu->vu_p->v_p;
		if( old_v1->index >= tbl_size ) rt_bomb( "nmg_dup_shell: trans table exceeded\n" );
		NMG_INDEX_ASSIGN( (*trans_tbl) , old_v1 , (long *)new_v1 );
		if( new_v1->index >= tbl_size ) rt_bomb( "nmg_dup_shell: trans table exceeded\n" );
		NMG_INDEX_ASSIGN( (*trans_tbl) , new_v1 , (long *)old_v1 );
		if( !new_v1->vg_p )
		{
			nmg_vertex_gv( new_v1 , old_v1->vg_p->coord );
			if( old_v1->vg_p->index >= tbl_size ) rt_bomb( "nmg_dup_shell: trans table exceeded\n" );
			NMG_INDEX_ASSIGN( (*trans_tbl) , old_v1->vg_p , (long *)new_v1->vg_p );
			if( new_v1->vg_p->index >= tbl_size ) rt_bomb( "nmg_dup_shell: trans table exceeded\n" );
			NMG_INDEX_ASSIGN( (*trans_tbl) , new_v1->vg_p , (long *)old_v1->vg_p );
		}

		new_v2 = new_eu->eumate_p->vu_p->v_p;
		if( old_v2->index >= tbl_size ) rt_bomb( "nmg_dup_shell: trans table exceeded\n" );
		NMG_INDEX_ASSIGN( (*trans_tbl) , old_v2 , (long *)new_v2 );
		if( new_v2->index >= tbl_size ) rt_bomb( "nmg_dup_shell: trans table exceeded\n" );
		NMG_INDEX_ASSIGN( (*trans_tbl) , new_v2 , (long *)old_v2 );
		if( !new_v2->vg_p )
		{
			nmg_vertex_gv( new_v2 , old_v2->vg_p->coord );
			if( old_v2->vg_p->index >= tbl_size ) rt_bomb( "nmg_dup_shell: trans table exceeded\n" );
			NMG_INDEX_ASSIGN( (*trans_tbl) , old_v2->vg_p , (long *)new_v2->vg_p );
			if( new_v2->vg_p->index >= tbl_size ) rt_bomb( "nmg_dup_shell: trans table exceeded\n" );
			NMG_INDEX_ASSIGN( (*trans_tbl) , new_v2->vg_p , (long *)old_v2->vg_p );
		}

	}

#if 0
	/* XXX for this to work nmg_mvu and nmg_mvvu must not be private
	 *     perhaps there is another way???? */
	/* copy vertex use
	 * This must be done last, since other routines may steal it */
	if( s->vu_p )
	{
		old_vu = s->vu_p;
		NMG_CK_VERTEXUSE( old_vu );
		old_v = old_vu->v_p;
		NMG_CK_VERTEX( old_v );
		new_v = NMG_INDEX_GETP(vertex, (*trans_tbl), old_v);
		if( new_v )
		{
			/* already copied vertex, just need a use */
			if( new_s->vu_p )
				(void )nmg_kvu( new_s->vu_p );
			new_s->vu_p = nmg_mvu( new_v , (long *)new_s , m );
		}
		else
		{
			/* make a new vertex and use */
			new_s->vu_p = nmg_mvvu( (long *)new_s , m );
			new_v = new_s->vu_p->v_p;

			/* put entry in table */
			if( old_v->index >= tbl_size ) rt_bomb( "nmg_dup_shell: trans table exceeded\n" );
			NMG_INDEX_ASSIGN( (*trans_tbl) , old_v , (long *)new_v );
			if( new_v->index >= tbl_size ) rt_bomb( "nmg_dup_shell: trans table exceeded\n" );
			NMG_INDEX_ASSIGN( (*trans_tbl) , new_v , (long *)old_v );

			/* assign the same geometry as the old copy */
			nmg_vertex_gv( new_v , old_v->vg_p->coord );
			if( old_v->vg_p->index >= tbl_size ) rt_bomb( "nmg_dup_shell: trans table exceeded\n" );
			NMG_INDEX_ASSIGN( (*trans_tbl) , old_v->vg_p , (long *)new_v->vg_p );
			if( new_v->vg_p->index >= tbl_size ) rt_bomb( "nmg_dup_shell: trans table exceeded\n" );
			NMG_INDEX_ASSIGN( (*trans_tbl) , new_v->vg_p , (long *)old_v->vg_p );
		}
	}
#endif

	return( new_s );
}

/*	Routines to use the bu_ptbl structures as a stack of edgeuse structures */

#define	NMG_PUSH( _ptr , _stack )	bu_ptbl_ins( _stack , (long *) _ptr );

struct edgeuse
*nmg_pop_eu(struct bu_ptbl *stack)
{
	struct edgeuse *eu;

	/* return a NULL if stack is empty */
	if( BU_PTBL_END( stack ) == 0 )
		return( (struct edgeuse *)NULL );

	/* get last edgeuse on the stack */
	eu = (struct edgeuse *)BU_PTBL_GET( stack , BU_PTBL_END( stack )-1 );

	/* remove that edgeuse from the stack */
	bu_ptbl_rm( stack , (long *)eu );

	return( eu );
}

void
nmg_reverse_radials(struct faceuse *fu, const struct bn_tol *tol)
{
	struct loopuse *lu;

	if( rt_g.NMG_debug & DEBUG_BASIC )
		bu_log( "nmg_reverse_radials( fu = x%x )\n" , fu );

	NMG_CK_FACEUSE( fu );
	BN_CK_TOL( tol );

	for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
	{
		struct edgeuse *eu;
		struct edgeuse *eu_radial;
		struct edgeuse *eumate;
		struct edgeuse *eumate_radial;

		NMG_CK_LOOPUSE( lu );

		if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
			continue;

		for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
		{
			eu_radial = eu->radial_p;
			eumate = eu->eumate_p;
			eumate_radial = eumate->radial_p;

			/* if no radials continue to next edgeuse in loop */
			if( eu_radial == eumate )
				continue;

			/* Note: there is no problem if this loop is radial to another
			 * loop in the same face, the radials will get switched as we process
			 * the first loop, then switched back as we process the second
			 */

			eu_radial->radial_p = eumate;
			eu->radial_p = eumate_radial;
			eumate_radial->radial_p = eu;
			eumate->radial_p = eu_radial;
		}
	}
}

/* XXX Don't use this, use nmg_s_radial_harmonize() at the right time. */
/*	N M G _ R E V E R S E _ F A C E _ A N D _ R A D I A L S
 *
 *	This routine calls "nmg_reverse_face" and also makes the radial
 *	pointers connect faces of like orientation (i.e., OT_SAME to OT_SAME and
 *	OT_OPPOSITE to OT_OPPOSITE).
 */

void
nmg_reverse_face_and_radials(struct faceuse *fu, const struct bn_tol *tol)
{
	struct loopuse *lu;

	if( rt_g.NMG_debug & DEBUG_BASIC )
		bu_log( "nmg_reverse_face_and_radials( fu = x%x )\n" , fu );

	NMG_CK_FACEUSE( fu );
	BN_CK_TOL( tol );

	/* reverse face */
	nmg_reverse_face( fu );

	for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
	{
		struct edgeuse *eu;
		struct edgeuse *eu_radial;
		struct edgeuse *eumate;
		struct edgeuse *eumate_radial;

		NMG_CK_LOOPUSE( lu );

		if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
			continue;

		for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
		{
			eu_radial = eu->radial_p;
			eumate = eu->eumate_p;
			eumate_radial = eumate->radial_p;

			/* if no radials continue to next edgeuse in loop */
			if( eu_radial == eumate )
				continue;

			/* Note: there is no problem if this loop is radial to another
			 * loop in the same face, the radials will get switched as we process
			 * the first loop, then switched back as we process the second
			 */

			eu_radial->radial_p = eumate;
			eu->radial_p = eumate_radial;
			eumate_radial->radial_p = eu;
			eumate->radial_p = eu_radial;
		}
	}
}

/*	N M G _ S H E L L _ I S _ V O I D
 *
 * determines if the shell is a void shell or an exterior shell
 * by finding the topmost face (in some direction) and looking at
 * the component of the OT_SAME faceuse normal in that direction.
 *
 * returns:
 *	0 - shell is exterior shell
 *	1 - shell is a void shell
 *	-1 - cannot determine
 *
 * It is expected that this shell is the result of nmg_decompose_shells.
 */
int
nmg_shell_is_void(const struct shell *s)
{
	struct model *m;
	struct face *f;
	struct faceuse *fu;
	vect_t normal;
	int dir;
	long *flags;

	NMG_CK_SHELL( s );

	m = nmg_find_model( &s->l.magic );
	NMG_CK_MODEL( m );

	flags = (long *)bu_calloc( m->maxindex , sizeof( long ) , "nmg_shell_is_void: flags " );

	f = nmg_find_top_face( s, &dir , flags );

	bu_free( (char *)flags , "nmg_shell_is_void: flags" );

	if( f == (struct face *)NULL )
		return( -1 );

	NMG_CK_FACE( f );
	NMG_CK_FACE_G_PLANE( f->g.plane_p );
	fu = f->fu_p;
	NMG_CK_FACEUSE( fu );

	if( fu->orientation != OT_SAME )
		fu = fu->fumate_p;
	if( fu->orientation != OT_SAME )
		return( -1 );

	NMG_GET_FU_NORMAL( normal , fu );

	if( normal[dir] == 0.0 )
		return( -1 );
	if( normal[dir] < 0.0)
		return( 1 );
	else
		return( 0 );
}

/*	N M G _ P R O P A G A T E _ N O R M A L S
 *
 *	This routine expects "fu_in" to have a correctly oriented normal.
 *	It then checks all faceuses in the same shell it can reach via radial structures, and
 *	reverses faces and modifies radial structures as needed to result in
 *	a consistent NMG shell structure. The "flags" variable is a translation table
 *	for the model, and as each face is checked, its flag is set. Faces with flags
 *	that have already been set will not be checked by this routine.
 */

void
nmg_propagate_normals(struct faceuse *fu_in, long int *flags, const struct bn_tol *tol)
{
	struct bu_ptbl stack;
	struct loopuse *lu;
	struct edgeuse *eu,*eu1;
	struct faceuse *fu;

	if( rt_g.NMG_debug & DEBUG_BASIC )
		bu_log( "nmg_propagate_normals( fu_in = x%x , flags = x%x )\n" , fu_in , flags );

	NMG_CK_FACEUSE( fu_in );
	BN_CK_TOL( tol );

	fu = fu_in;
	if( fu->orientation != OT_SAME )
		fu = fu->fumate_p;
	if( fu->orientation != OT_SAME )
	{
		bu_log( "nmg_propagate_normals: Could not find OT_SAME orientation of faceuse x%x\n" , fu_in );
		return;
	}

	/* set flag for this face since we know this one is OK */
	NMG_INDEX_SET( flags , fu->f_p );

	/* Use the ptbl structure as a stack */
	bu_ptbl_init( &stack , 64, " &stack ");

	/* push all edgeuses of "fu" onto the stack */
	for( BU_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
	{
		NMG_CK_LOOPUSE( lu );
		if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
			continue;
		for( BU_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
		{
			/* don't push free edges on the stack */
			if( eu->radial_p->eumate_p != eu )
				NMG_PUSH( eu , &stack );
		}
	}

	/* now pop edgeuses from stack, go to radial face, fix its normal,
	 * and push its edgeuses onto the stack */

	while( (eu1 = nmg_pop_eu( &stack )) != (struct edgeuse *)NULL )
	{
		/* eu1 is an edgeuse on an OT_SAME face, so its radial
		 * should be in an OT_SAME also */

		NMG_CK_EDGEUSE( eu1 );

		eu = eu1->radial_p;
		NMG_CK_EDGEUSE( eu );

		/* find the face that contains this edgeuse */
		fu = nmg_find_fu_of_eu( eu );
		if( !fu )
			continue;

		NMG_CK_FACEUSE( fu );

		/* if this face has already been processed, skip it */
		if( NMG_INDEX_TEST_AND_SET( flags , fu->f_p ) )
		{
			if( rt_g.NMG_debug & DEBUG_BASIC )
				bu_log( "nmg_propagate_normals: checking fu x%x, eu = x%x, eu1 = x%x\n" , fu, eu, eu1 );

			if( fu->orientation == OT_SAME )
			{
				if( eu1->vu_p->v_p == eu->vu_p->v_p &&
					eu1->eumate_p->vu_p->v_p == eu->eumate_p->vu_p->v_p )
				{
					/* edge direction is wrong, need to reverse
					 * both the face and the radials
					 */
					nmg_reverse_face_and_radials( fu , tol );
				}
				/* else - this is the way it should be */
			}
			else if( fu->orientation == OT_OPPOSITE )
			{
				if( eu1->vu_p->v_p == eu->vu_p->v_p &&
					eu1->eumate_p->vu_p->v_p == eu->eumate_p->vu_p->v_p )
				{
					/* just swap radial pointer around */
					nmg_reverse_radials( fu , tol );
				}
				else
				{
					/* just reverse the face */
					nmg_reverse_face( fu );
				}
			}
			else
			{
				bu_log( "nmg_propagate_normals: found an unoriented face!!!!\n" );
				nmg_pr_fu_briefly( fu, "" );
				rt_bomb( "nmg_propagate_normals: found an unoriented face!!!!\n" );
			}

			/* make sure we are dealing with an OT_SAME faceuse */
			if( fu->orientation != OT_SAME )
				fu = fu->fumate_p;

			/* push all edgeuses of "fu" onto the stack */
			for( BU_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
			{
				NMG_CK_LOOPUSE( lu );
				if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
					continue;
				for( BU_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
				{
					/* don't push free edges on the stack */
					if( eu->radial_p->eumate_p != eu )
						NMG_PUSH( eu , &stack );
				}
			}
		}
	}

	/* free the stack */
	bu_ptbl_free( &stack );
}


/*		N M G _ D I S C O N N E C T _ S H E L L S
 *
 *	looks for edges that have uses in more than one shell in region.
 *	creates new edges so that there is no sharing of edges among shells
 */
static void
nmg_disconnect_shells(struct nmgregion *r)
{
	struct shell *s1;
	struct bu_ptbl edges;
	int count=0;
	int i;

	NMG_CK_REGION( r );

	/* count number of shells in this region */
	for( BU_LIST_FOR( s1, shell, &r->s_hd ) )
		count++;

	/* if there is less than two shells, nothing to do */
	if( count < 2 )
		return;

	/* get a list of all edges in this region */
	nmg_edge_tabulate( &edges, &r->l.magic );

	/* look at every edge in region */
	for( i=0 ; i<BU_PTBL_END( &edges ) ; i++ )
	{
		struct edge *e;
		struct edgeuse *eu;
		struct edgeuse *eu1;
		struct shell *needs_disconnect=(struct shell *)NULL;

		e = (struct edge *)BU_PTBL_GET( &edges, i );
		NMG_CK_EDGE( e );

		/* find shell of a use of this edge */
		eu = e->eu_p;
		s1 = nmg_find_s_of_eu( eu );

		/* check if any other use of this edge is from a different shell */
		eu1 = eu->eumate_p->radial_p;
		while( eu1 != eu &&  eu1 != eu->eumate_p )
		{
			struct shell *s2;

			if( (s2 = nmg_find_s_of_eu( eu1 )) != s1 )
			{
				needs_disconnect = s2;
				break;
			}
			eu1 = eu1->eumate_p->radial_p;
		}

		while( needs_disconnect )
		{
			struct edgeuse *eu2;
			struct edgeuse *start_eu;
			struct edgeuse *last;
			int last_orientation;

			/* disconnect first use of this edge in shell 'needs_disconnect' */
			start_eu = eu1->radial_p;
			nmg_unglueedge( eu1 );
			last = eu1;
			last_orientation = (nmg_find_fu_of_eu( eu1 ))->orientation;

			/* now disconnect all other uses, reconnecting them to eu1 as we go  */
			while( nmg_find_s_of_eu( start_eu ) == needs_disconnect )
				start_eu = start_eu->eumate_p->radial_p;
			eu2 = start_eu;
			do
			{
				struct edgeuse *next_eu;
				struct faceuse *fu2;

				/* find uses in 'needs_disconnect' shell */
				next_eu = eu2->eumate_p->radial_p;
				if( nmg_find_s_of_eu( eu2 ) == needs_disconnect )
				{

					/* disconnect this use */
					nmg_unglueedge( eu2 );
					fu2 = nmg_find_fu_of_eu( eu2 );

					/* reconnect it to 'needs_disconnect' shell */
					if( fu2->orientation == last_orientation)
					{
						nmg_je( last, eu2 );
						last = eu2->eumate_p;
						last_orientation = fu2->fumate_p->orientation;
					}
					else
					{
						nmg_je( last, eu2->eumate_p );
						last_orientation = fu2->orientation;
						last = eu2;
					}
				}
				eu2 = next_eu;
			} while( eu2 != start_eu && eu2->eumate_p != start_eu );

			/* now check remaining uses */
			eu1 = eu->eumate_p->radial_p;
			needs_disconnect = (struct shell *)NULL;
			while( eu1 != eu &&  eu1 != eu->eumate_p )
			{
				struct shell *s2;

				if( (s2 = nmg_find_s_of_eu( eu1 )) != s1 )
				{
					needs_disconnect = s2;
					break;
				}
				eu1 = eu1->eumate_p->radial_p;
			}
		}

	}
}

/*		N M G _ C O N N E C T _ S A M E _ F U _ O R I E N T S
 *
 *	looks for radially connected faceuses that have disagreeing orientations.
 *	if such a condiftion is found, the radial pointers are rearranged to make
 *	the radial faces agree in orientation.
 */
void
nmg_connect_same_fu_orients(struct shell *s)
{
	struct faceuse *fu;

	for( BU_LIST_FOR( fu, faceuse, &s->fu_hd ) )
	{
		struct loopuse *lu;

		if( fu->orientation != OT_SAME )
			continue;

		for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
		{
			struct edgeuse *eu;

			if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
				continue;

			for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
			{
				struct faceuse *fu2;
				struct faceuse *fu3;
				struct edgeuse *eu2;

				eu2 = eu->radial_p;

				if( eu2 == eu->eumate_p )
					continue;

				fu2 = nmg_find_fu_of_eu( eu2 );
				if( fu2->orientation == OT_SAME )
					continue;

				fu3 = nmg_find_fu_of_eu( eu->eumate_p->radial_p );
				if( fu3->orientation == OT_OPPOSITE )
					continue;
			}
		}
	}
}

/*		N M G _ F I X _ D E C O M P O S E D_ S H E L L _ N O R M A L S
 *
 *	Routine to set all OT_SAME faceuse normals to outward direction.
 *	Assumes that there are no other shells sharing edges with this one.
 */

void
nmg_fix_decomposed_shell_normals(struct shell *s, const struct bn_tol *tol)
{
	struct model *m;
	struct face *f_top;
	struct faceuse *fu;
	vect_t normal;
	int dir;
	int missed_faces;
	long *flags;

	NMG_CK_SHELL( s );
	BN_CK_TOL( tol );

	m = s->r_p->m_p;
	flags = (long *)bu_calloc( m->maxindex , sizeof( long ) , "nmg_fix_decomposed_shell_normals: flags" );

missed:
	/* find the top face */
	f_top = nmg_find_top_face( s, &dir , flags );
	if( f_top == (struct face *)NULL )
	{
		bu_log( "nmg_fix_decomposed_shell_normals: Could not get a top face from nmg_find_top_face()\n" );
		bu_log( "\tWARNING: continuing without fixing normals!!!!\n" );
		bu_free( (char *)flags, "nmg_fix_decomposed_shell_normals: flags" );
		return;
	}
	if( *f_top->g.magic_p != NMG_FACE_G_PLANE_MAGIC )
	{
		NMG_INDEX_SET( flags, f_top );
		goto missed;
	}

	if( NMG_INDEX_TEST( flags, f_top ) )
		bu_log(" nmg_find_top_face returned a flagged face %x\n" , f_top );

	NMG_CK_FACE( f_top );
	fu = f_top->fu_p;
	NMG_CK_FACEUSE( fu );
	if( fu->orientation != OT_SAME )
		fu = fu->fumate_p;
	if( fu->orientation != OT_SAME )
	{
		bu_log( "nmg_fix_decomposed_shell_normals: no OT_SAME use of top face\n" );
		bu_free( (char *)flags , "nmg_fix_decomposed_shell_normals: flags" );
		return;
	}
	NMG_GET_FU_NORMAL( normal , fu );

	if( rt_g.NMG_debug & DEBUG_BASIC )
	{
		bu_log( "\tnmg_fix_decomposed_shell_normals: top face is x%x in %d direction, OT_SAME use is x%x\n", f_top, dir, fu );
		bu_log( "\toutward normal = ( %g %g %g )\n" , V3ARGS( normal ) );
	}

	/* f_top is the topmost face (in the "dir" direction), so its OT_SAME use should have a
	 * normal with component in the "dir" direction */
	if( normal[dir] < 0.0 )
	{
		if( rt_g.NMG_debug & DEBUG_BASIC )
			bu_log( "nmg_fix_decomposed_shell_normals: reversing fu x%x\n" , fu );

		nmg_reverse_face_and_radials( fu, tol );
	}

	/* get OT_SAME use of top face */
	fu = f_top->fu_p;
	if( fu->orientation != OT_SAME )
		fu = fu->fumate_p;

	NMG_CK_FACEUSE( fu );

	/* fu is now known to be a correctly oriented faceuse,
	 * propagate this throughout the shell, face by face, by
	 * traversing the shell using the radial edge structure */

	nmg_propagate_normals( fu , flags , tol );

	if( rt_g.NMG_debug & DEBUG_BASIC )
	{
		vect_t new_norm;

		NMG_GET_FU_NORMAL( new_norm , fu );
		bu_log( "nmg_fix_decomposed_shell_normals: After propagation top faceuse normal is ( %g %g %g )\n",
			V3ARGS( new_norm ) );
	}

	/* check if all the faces have been processed */
	missed_faces = 0;
	for( BU_LIST_FOR( fu , faceuse , &s->fu_hd ) )
	{
		NMG_CK_FACEUSE( fu );
		if( fu->orientation == OT_SAME )
		{
			if( !NMG_INDEX_TEST( flags , fu->f_p ) )
				missed_faces++;
		}
	}

	if( missed_faces )
	{
		bu_log( "nmg_fix_decomposed_shell_normals: missed %d faces in shell x%x (was it decomposed?)\n", 
			missed_faces, s );
		rt_bomb( "nmg_fix_decomposed_shell_normals: missed faces in shell (was it decomposed?)\n" );
	}

	bu_free( (char *)flags, "flags" );
}

/*		N M G _ M K _ M O D E L _ F R O M _ R E G I O N
 *
 *	Creates a new model from an existing nmgregion.
 *	Will refuse to create new model if the passed nmgregion has
 *	children with uses in another nmgregion.
 *
 *	The reindex flag indicates if the new model should be reindexed.
 *		If non-zero, nmg_m_reindex() is called.
 *		If zero, the maxindex field of the new model is filled by finding
 *			the largest index value in the new model and adding one.
 *		This is useful if the indices in the region are being used for table look-up.
 */
struct model *
nmg_mk_model_from_region(struct nmgregion *r, int reindex)
{
	struct model *m;
	struct bu_ptbl tbl;
	int i;
	int other_uses=0;

	NMG_CK_REGION( r );


	/* check if anything in this region has uses in another region */
	nmg_vertex_tabulate( &tbl, &r->l.magic );

	for( i=0 ; i<BU_PTBL_END( &tbl ) ; i++ )
	{
		struct vertex *v;
		struct vertexuse *vu;

		v = (struct vertex *)BU_PTBL_GET( &tbl, i );
		NMG_CK_VERTEX( v );

		for( BU_LIST_FOR( vu, vertexuse, &v->vu_hd ) )
		{
			if( (nmg_find_s_of_vu( vu ))->r_p != r )
			{
				bu_log( "vertexuse x%x (v=x%x) at (%g %g %g) has use in another region\n",
					vu, v, V3ARGS( v->vg_p->coord ) );
				other_uses++;
			}
		}
	}
	bu_ptbl_free( &tbl );

	nmg_edge_tabulate( &tbl, &r->l.magic );
	for( i=0 ; i<BU_PTBL_END( &tbl ) ; i++ )
	{
		struct edge *e;
		struct edgeuse *eu;
		struct edgeuse *eu1;

		e = (struct edge *)BU_PTBL_GET( &tbl, i );
		NMG_CK_EDGE( e );

		eu = e->eu_p;
		NMG_CK_EDGEUSE( eu );

		eu1 = eu->radial_p->eumate_p;
		while( eu1 != eu )
		{
			if( (nmg_find_s_of_eu( eu1 ))->r_p != r )
			{
				bu_log( "edgeuse x%x (e=x%x) at (%g %g %g)<->(%g %g %g0 has use in another region\n",
					eu, e, V3ARGS( eu->vu_p->v_p->vg_p->coord ), V3ARGS( eu->eumate_p->vu_p->v_p->vg_p->coord ) );
				other_uses++;
			}
			eu1 = eu1->radial_p->eumate_p;
		}
	}
	bu_ptbl_free( &tbl );

	if( other_uses )
	{
		return( (struct model *)NULL );
	}

	m = nmg_mm();

	BU_LIST_DEQUEUE( &r->l );

	BU_LIST_INSERT( &m->r_hd, &r->l );

	r->m_p = m;

	if( reindex )
		nmg_m_reindex( m , 0 );
	else
		m->maxindex = nmg_find_max_index( m ) + 1;

	return( m );
}

/*		N M G _ F I X _ N O R M A L S
 *
 *	Routine to set faceuse normlas to correct direction.
 *
 *	Method:
 *		1. Make a  copy of the shell in another model.
 *		2. Decompose the copy into constituent shells.
 *		3. Set all normals of constituent shells outward (no void shells)
 *		4. Use nmg_classify_s_vs_s() for every pair of shells.
 *		5. Mark any shell that is inside an odd number of other shells as a void shell.
 *		6. Compare original faceuses with the results in the copy and adjust normals as needed.
 *		7. Destroy the copy model.
 */
void
nmg_fix_normals(struct shell *s_orig, const struct bn_tol *tol)
{
	struct model *tmp_m;
	struct model *m;
	struct shell *dup_s;
	struct shell *s1;
	struct nmgregion *tmp_r;
	struct faceuse *fu;
	struct bu_ptbl reverse;
	int shell_count;
	long **trans_tbl;

	if( rt_g.NMG_debug & DEBUG_BASIC )
		bu_log( "nmg_fix_normals( s = x%x )\n" , s_orig );

	NMG_CK_SHELL( s_orig );
	BN_CK_TOL( tol );

	/* Currently we can only fix normals for planar faces
	 * check that there are no TNURB faces
	 */
	for( BU_LIST_FOR( fu, faceuse, &s_orig->fu_hd ) )
	{
		struct face *f;

		NMG_CK_FACEUSE( fu );

		if( fu->orientation != OT_SAME )
			continue;

		f = fu->f_p;

		if( !f->g.magic_p )
		{
			bu_log( "nmg_fix_normals failed, found a face with no geometry (x%x)\n", f );
			return;
		}

		if( *f->g.magic_p != NMG_FACE_G_PLANE_MAGIC )
		{
			bu_log( "nmg_fix_normals: non-planar face found (x%x)\n", f );
			bu_log( "	cannot fix normals\n" );
			return;
		}
	}

        m = s_orig->r_p->m_p;

        /* make a temporary nmgregion for us to work in */
        tmp_r = nmg_mrsv( m );

        /* get rid of the automatically created shell */
        (void)nmg_ks( BU_LIST_FIRST( shell, &tmp_r->s_hd ) );

        /* make a copy of the shell of interest */
        dup_s = nmg_dup_shell( s_orig, &trans_tbl, tol );

        /* move the copy to our work area */
        nmg_mv_shell_to_region( dup_s, tmp_r );

	/* move duplicate shell to another model */
	tmp_m = nmg_mk_model_from_region( tmp_r, 0 ); /* don't reindex, We need the old indices */
	nmg_rebound( tmp_m, tol );

	/* decompose the shell */
	shell_count = nmg_decompose_shell( dup_s, tol );

	if( shell_count == 1 )
	{
		/* just one shell, so fix it and return */
		(void)nmg_km( tmp_m );
		bu_free( (char *)trans_tbl, "translate table" );
		nmg_connect_same_fu_orients( s_orig );
		nmg_fix_decomposed_shell_normals( s_orig, tol );
		return;
	}

	/* make sure the shells don't share any edges */
	nmg_disconnect_shells( tmp_r );

	/* Make sure all OT_SAME faceuses are radial to OT_SAME faceuses */
	for( BU_LIST_FOR( s1, shell, &tmp_r->s_hd ) )
		nmg_connect_same_fu_orients( s1 );

	/* Decomposed into more than one shell.
	 * Need to check for inner void shells.
	 * Start by making all the shells look like solids (no voids).
	 */
	for( BU_LIST_FOR( s1, shell, &tmp_r->s_hd ) )
		nmg_fix_decomposed_shell_normals( s1, tol );

	/* initialize a list of shells to be reversed */
	bu_ptbl_init( &reverse, 8, "Ptbl for nmg_fix_normals" );

	/* now check which shells are inside others */
	for( BU_LIST_FOR( s1, shell, &tmp_r->s_hd ) )
	{
		struct shell *s2;
		int inner_count=0;

		for( BU_LIST_FOR( s2, shell, &tmp_r->s_hd ) )
		{
			int class;

			if( s1 == s2 )
				continue;

			class = nmg_classify_s_vs_s( s1, s2, tol );
			if( class == NMG_CLASS_AinB )
				inner_count++;
			else if( class == NMG_CLASS_Unknown )
			{
				bu_log( "nmg_fix_normals: nmg_classify_s_vs_s() failed for shells x%x and x%x\n", s1, s2 );
				bu_log( "   Continueing anyway (shell is likely to have incorrectly oriented normals)\n" );
			}
		}

		if( inner_count % 2 )
		{
			/* shell s1 is inside an odd number of shells, so it must be a void */
			bu_ptbl_ins( &reverse, (long *)s1 );
		}
	}

	/* now set faces in orignal shell to match our calculations */
	nmg_connect_same_fu_orients( s_orig );

	for( BU_LIST_FOR( s1, shell, &tmp_r->s_hd ) )
	{
		int reversed;

		if( bu_ptbl_locate( &reverse, (long *)s1 ) == (-1 ))
			reversed = 0;
		else
			reversed = 1;

		for( BU_LIST_FOR( fu, faceuse, &s1->fu_hd ) )
		{
			struct faceuse *fu_in_s;
			vect_t normal;
			vect_t normal_in_s;

			if( fu->orientation != OT_SAME )
				continue;

			fu_in_s = NMG_INDEX_GETP( faceuse, trans_tbl, fu );
			if( !fu_in_s )
			{
				bu_log( "fu x%x does not have corrrespondence in original shell\n", fu );
				nmg_pr_fu_briefly( fu, "" );
				continue;
			}
			if( fu_in_s->orientation != OT_SAME  )
				fu_in_s = fu_in_s->fumate_p;

			NMG_GET_FU_NORMAL( normal, fu );
			if( reversed )
				VREVERSE( normal, normal )

			NMG_GET_FU_NORMAL( normal_in_s, fu_in_s );

			if( VDOT( normal, normal_in_s ) < 0.0 )
			{
				nmg_reverse_face_and_radials( fu_in_s, tol );
			}
		}
	}

	bu_ptbl_free( &reverse );
	bu_free( (char *)trans_tbl, "translation table" );

	nmg_km( tmp_m );
}

/*	N M G _ B R E A K _ L O N G _ E D G E S
 *
 *	This codes looks for situations as illustrated:
 *
 *    *------->*-------->*--------->*
 *    *<----------------------------*
 *
 *	where one long edgeuse (the bottom one above) and two or more
 *	shorter edgeusess (the tops ones) are collinear and have the same
 *	start and end vertices.  The code breaks the longer edgeuse into
 *	ones that can be radials of the shorter ones.
 *	Returns the number of splits performed.
 */

int
nmg_break_long_edges(struct shell *s, const struct bn_tol *tol)
{
	struct faceuse *fu;
	struct loopuse *lu;
	struct edgeuse *eu;
	int split_count=0;

	if( rt_g.NMG_debug & DEBUG_BASIC )
		bu_log( "nmg_break_long_edges( s = x%x )\n" , s );

	NMG_CK_SHELL( s );
	BN_CK_TOL( tol );

	/* look at every edgeuse in the shell */
	for( BU_LIST_FOR( fu , faceuse , &s->fu_hd ) )
	{
		NMG_CK_FACEUSE( fu );

		for( BU_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
		{
			NMG_CK_LOOPUSE( lu );

			/* skip loops of a single vertex */
			if( BU_LIST_FIRST_MAGIC(&lu->down_hd) != NMG_EDGEUSE_MAGIC )
				continue;

			for( BU_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
			{
				struct vertexuse *vu;

				NMG_CK_EDGEUSE( eu );

				/* look for an edgeuse that terminates on this vertex */
				for( BU_LIST_FOR( vu , vertexuse , &eu->vu_p->v_p->vu_hd ) )
				{
					struct edgeuse *eu1;

					NMG_CK_VERTEXUSE( vu );

					/* skip vertexuses that are not part of an edge */
					if( *vu->up.magic_p != NMG_EDGEUSE_MAGIC )
						continue;

					eu1 = vu->up.eu_p;

					/* don't consider the edge we already found!!! */
					if( eu1 == eu )
						continue;

					/* if it terminates at the same vertex as eu, skip it */
					if( eu1->eumate_p->vu_p->v_p == eu->eumate_p->vu_p->v_p )
						continue;

					/* get the mate (so it terminates at "vu") */
					eu1 = eu1->eumate_p;

					/* make sure it is collinear with "eu" */
					if( bn_3pts_collinear( eu->vu_p->v_p->vg_p->coord ,
						eu->eumate_p->vu_p->v_p->vg_p->coord ,
						eu1->vu_p->v_p->vg_p->coord , tol ) )
					{
						/* make sure we break the longer edge
						 * and that the edges are in opposite directions */
						vect_t v0,v1;

						VSUB2( v0 , eu->eumate_p->vu_p->v_p->vg_p->coord , eu->vu_p->v_p->vg_p->coord );
						VSUB2( v1 , eu1->eumate_p->vu_p->v_p->vg_p->coord , eu1->vu_p->v_p->vg_p->coord );

						if (MAGSQ( v0 ) > MAGSQ( v1 ) && VDOT( v0 , v1 ) < 0.0 )
						{
							if( rt_g.NMG_debug & DEBUG_BASIC )
							{
								bu_log( "Breaking edge from ( %f %f %f ) to ( %f %f %f ) at ( %f %f %f )\n",
									V3ARGS( eu->vu_p->v_p->vg_p->coord ),
									V3ARGS( eu->eumate_p->vu_p->v_p->vg_p->coord ),
									V3ARGS( eu1->vu_p->v_p->vg_p->coord ) );
							}
							(void) nmg_ebreak(eu1->vu_p->v_p, eu);
							split_count++;
						}
						else if( rt_g.NMG_debug & DEBUG_BASIC )
						{
							bu_log( "Not splitting collinear edges x%x and x%x:\n", eu , eu1 );
							bu_log( "\t( %f %f %f ) -> ( %f %f %f )\n",
								V3ARGS( eu->vu_p->v_p->vg_p->coord ),
								V3ARGS( eu->eumate_p->vu_p->v_p->vg_p->coord ) );
							bu_log( "\t( %f %f %f ) -> ( %f %f %f )\n",
								V3ARGS( eu1->vu_p->v_p->vg_p->coord ),
								V3ARGS( eu1->eumate_p->vu_p->v_p->vg_p->coord ) );
						}
					}
				}
			}
		}
	}
	return( split_count );
}

/*	N M G _ M K _ N E W _ F A C E _ F R O M _ L O O P
 *
 *  Remove a loopuse from an existing face and construct a new face
 *  from that loop
 *
 *  Returns new faceuse as built by nmg_mf()
 *
 */
struct faceuse *
nmg_mk_new_face_from_loop(struct loopuse *lu)
{
	struct shell *s;
	struct faceuse *fu;
	struct loopuse *lu1;
	struct loopuse *lu_mate;
	int ot_same_loops=0;

	if( rt_g.NMG_debug & DEBUG_BASIC )
		bu_log( "nmg_mk_new_face_from_loop( lu = x%x )\n" , lu );

	NMG_CK_LOOPUSE( lu );

	if( *lu->up.magic_p != NMG_FACEUSE_MAGIC )
	{
		bu_log( "nmg_mk_new_face_from_loop: loopuse is not in a faceuse\n" );
		return( (struct faceuse *)NULL );
	}

	fu = lu->up.fu_p;
	NMG_CK_FACEUSE( fu );

	s = fu->s_p;
	NMG_CK_SHELL( s );

	/* Count the number of exterior loops in this faceuse */
	for( BU_LIST_FOR( lu1 , loopuse , &fu->lu_hd ) )
	{
		NMG_CK_LOOPUSE( lu1 );
		if( lu1->orientation == OT_SAME )
			ot_same_loops++;
	}

	if( ot_same_loops == 1 && lu->orientation == OT_SAME )
	{
		bu_log( "nmg_mk_new_face_from_loop: cannot remove only exterior loop from faceuse\n" );
		return( (struct faceuse *)NULL );
	}

	lu_mate = lu->lumate_p;

	/* remove loopuse from faceuse */
	BU_LIST_DEQUEUE( &lu->l );

	/* remove its mate from faceuse mate */
	BU_LIST_DEQUEUE( &lu_mate->l );

	/* insert these loops in the shells list of wire loops
	 * put the original loopuse at the head of the list
	 * so that it will end up as the returned faceuse from "nmg_mf"
	 */
	BU_LIST_INSERT( &s->lu_hd , &lu_mate->l );
	BU_LIST_INSERT( &s->lu_hd , &lu->l );

	/* set the "up" pointers to the shell */
	lu->up.s_p = s;
	lu_mate->up.s_p = s;

	/* Now make the new face */
	return( nmg_mf( lu ) );
}

/* state for nmg_split_loops_into_faces */
struct nmg_split_loops_state
{
	long		*flags;		/* index based array of flags for model */
	const struct bn_tol	*tol;
	int		split;		/* count of faces split */
};

void
nmg_split_loops_handler(long int *fu_p, genptr_t sl_state, int after)
{
	struct faceuse *fu;
	struct nmg_split_loops_state *state;
	struct loopuse *lu;
	const struct bn_tol *tol;
	int otsame_loops=0;
	int otopp_loops=0;

	fu = (struct faceuse *)fu_p;
	NMG_CK_FACEUSE( fu );

	state = (struct nmg_split_loops_state *)sl_state;
	tol = state->tol;

	if( fu->orientation != OT_SAME )
		return;

	if( !NMG_INDEX_TEST_AND_SET( state->flags , fu ) )  return;

	NMG_INDEX_SET( state->flags , fu->fumate_p );

	for( BU_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
	{
		NMG_CK_LOOPUSE( lu );

		if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
			continue;

		if( lu->orientation == OT_SAME )
			otsame_loops++;
		else if( lu->orientation == OT_OPPOSITE )
			otopp_loops++;
		else
		{
			bu_log( "nmg_split_loops_into_faces: facuse (x%x) with %s loopuse (x%x)\n",
				fu , nmg_orientation( lu->orientation ) , lu );
			return;
		}
	}

	/* if there is only one OT_SAME loop in this faceuse, nothing to do */
	if( otsame_loops == 1 )
		return;

	if( otopp_loops && otsame_loops )
	{
		struct bu_ptbl inside_loops;

		bu_ptbl_init( &inside_loops , 64, " &inside_loops ");

		lu = BU_LIST_FIRST( loopuse , &fu->lu_hd );
		while( BU_LIST_NOT_HEAD( lu , &fu->lu_hd ) )
		{
			struct faceuse *new_fu;
			struct loopuse *lu_next;
			struct loopuse *lu1;
			plane_t plane;
			int index;

			lu_next = BU_LIST_PNEXT( loopuse , &lu->l );

			if( otsame_loops == 1 )
			{
				/* done */
				bu_ptbl_free( &inside_loops );
				return;
			}

			if( lu->orientation != OT_SAME )
			{
				lu = lu_next;
				continue;
			}

			/* find OT_OPPOSITE loops for this exterior loop */
			for( BU_LIST_FOR( lu1 , loopuse , &fu->lu_hd ) )
			{
				struct loopuse *lu2;
				int hole_in_lu=1;

				if( lu1 == lu )
					continue;

				/* skip loops that are not OT_OPPOSITE */
				if( lu1->orientation != OT_OPPOSITE )
					continue;

				/* skip loops that are not within lu */
				if( nmg_classify_lu_lu( lu1 , lu , tol ) != NMG_CLASS_AinB )
					continue;

				/* lu1 is an OT_OPPOSITE loopuse within the OT_SAME lu
				 * but lu1 may be within yet another loopuse that is
				 * also within lu (nested loops)
				 */

				/* look for another OT_SAME loopuse within lu */
				for( BU_LIST_FOR( lu2 , loopuse , &fu->lu_hd ) )
				{

					if( lu2 == lu || lu2 == lu1 )
						continue;

					if( lu2->orientation != OT_SAME )
						continue;

					if( nmg_classify_lu_lu( lu2 , lu , tol ) == NMG_CLASS_AinB )
					{
						/* lu2 is within lu, does it contain lu1?? */
						if( nmg_classify_lu_lu( lu1 , lu2 , tol ) == NMG_CLASS_AinB )
						{
							/* Yes, lu1 is within lu2, so lu1 is not
							 * a hole in lu
							 */
							hole_in_lu = 0;;
							break;
						}
					}
				}

				if( hole_in_lu )
					bu_ptbl_ins( &inside_loops , (long *)lu1 );
			}

			NMG_GET_FU_PLANE( plane , fu );

			new_fu = nmg_mk_new_face_from_loop( lu );
			nmg_face_g( new_fu , plane );

			for( index=0 ; index<BU_PTBL_END( &inside_loops ) ; index++ )
			{
				lu1 = (struct loopuse *)BU_PTBL_GET( &inside_loops , index );
				nmg_move_lu_between_fus( new_fu , fu , lu1 );
				otopp_loops--;
			}
			nmg_face_bb( new_fu->f_p, tol );
			bu_ptbl_reset( &inside_loops );
			otsame_loops--;
			lu = lu_next;
		}
		bu_ptbl_free( &inside_loops );
	}
	else if( otsame_loops )
	{
		/* all loops are of the same orientation, just make a face for every loop */
		int first=1;
		struct faceuse *new_fu;

		lu = BU_LIST_FIRST( loopuse , &fu->lu_hd );
		while( BU_LIST_NOT_HEAD( lu , &fu->lu_hd ) )
		{
			struct loopuse *next_lu;

			next_lu = BU_LIST_PNEXT( loopuse , &lu->l );

			if( first )
				first = 0;
			else
			{
				plane_t plane;

				if( lu->orientation == OT_SAME )
				{
					NMG_GET_FU_PLANE( plane , fu );
				}
				else
				{
					NMG_GET_FU_PLANE( plane , fu->fumate_p );
				}
				new_fu = nmg_mk_new_face_from_loop( lu );
				nmg_face_g( new_fu , plane );
				nmg_face_bb( new_fu->f_p, tol );
			}

			lu = next_lu;
		}
	}
	else
	{
		/* faceuse has only OT_OPPOSITE loopuses */
		bu_log( "nmg_split_loops_into_faces: fu (x%x) has only OT_OPPOSITE loopuses, ignored\n" , fu );
	}
}

/*	N M G _ S P L I T _ L O O P S _ I N T O _ F A C E S
 *
 *	Visits each faceuse and splits disjoint loops into
 *	seperate faces.
 *
 *	Returns the number of faces modified.
 */
int
nmg_split_loops_into_faces(long int *magic_p, const struct bn_tol *tol)
{
	struct model *m;
	struct nmg_visit_handlers htab;
	struct nmg_split_loops_state sl_state;
	int count;

	if( rt_g.NMG_debug & DEBUG_BASIC )
		bu_log( "nmg_split_loops_into_faces( magic_p = x%x )\n" , magic_p );

	BN_CK_TOL( tol );

	m = nmg_find_model( magic_p );
	NMG_CK_MODEL( m );

	BN_CK_TOL( tol );

	htab = nmg_visit_handlers_null;		/* struct copy */
	htab.aft_faceuse = nmg_split_loops_handler;

	sl_state.split = 0;
	sl_state.flags = (long *)bu_calloc( m->maxindex*2 , sizeof( long ) , "nmg_split_loops_into_faces: flags" );
	sl_state.tol = tol;

	nmg_visit( magic_p , &htab , (genptr_t *)&sl_state );

	count = sl_state.split;

	bu_free( (char *)sl_state.flags , "nmg_split_loops_into_faces: flags" );

	return( count );
}

/*	N M G _ D E C O M P O S E _ S H E L L
 *
 *	Accepts one shell and breaks it to the minimum number
 *	of disjoint shells.
 *
 *	explicit returns:
 *		# of resulting shells ( 1 indicates that nothing was done )
 *
 *	implicit returns:
 *		additional shells in the passed in shell's region.
 */
int
nmg_decompose_shell(struct shell *s, const struct bn_tol *tol)
{
	int missed_faces;
	int no_of_shells=1;
	int shell_no=1;
	int i,j;
	struct model *m;
	struct nmgregion *r;
	struct shell *new_s;
	struct faceuse *fu;
	struct loopuse *lu;
	struct edgeuse *eu;
	struct edgeuse *eu1;
	struct faceuse *missed_fu = NULL;
	struct bu_ptbl stack;
	struct bu_ptbl shared_edges;
	long *flags;

	if( rt_g.NMG_debug & DEBUG_BASIC )
		bu_log( "nmg_decompose_shell( s = x%x ) START\n" , s );

	NMG_CK_SHELL( s );

	BN_CK_TOL( tol );

	/* Make an index table to insure we visit each face once and only once */
	r = s->r_p;
	NMG_CK_REGION( r );
	m = r->m_p;
	NMG_CK_MODEL( m );
	flags = (long *)bu_calloc( m->maxindex*2 , sizeof( long ) , "nmg_decompose_shell: flags" );

	bu_ptbl_init( &stack , 64, " &stack ");
	bu_ptbl_init( &shared_edges , 64, " &shared_edges ");

	/* Need to be sure that every face has just one OT_SAME loop */
	(void)nmg_split_loops_into_faces( &s->l.magic , tol );

	/* get first faceuse from shell */
	fu = BU_LIST_FIRST( faceuse , &s->fu_hd );
	NMG_CK_FACEUSE( fu );
	if( fu->orientation != OT_SAME )
		fu = fu->fumate_p;
	if( fu->orientation != OT_SAME )
		rt_bomb( "First face in shell has no OT_SAME uses!!!!\n" );

	/* put all edguses of first faceuse on the stack */
	for( BU_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
	{
		NMG_CK_LOOPUSE( lu );
		if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )	
			continue;

		for( BU_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
		{
			/* build two lists, one of winged edges, the other not */
			if( nmg_radial_face_count( eu , s ) > 2 )
				bu_ptbl_ins_unique( &shared_edges , (long *)eu );
			else
				bu_ptbl_ins_unique( &stack , (long *)eu );
		}
	}

	/* Mark first faceuse and mate with shell number */
	NMG_INDEX_ASSIGN( flags , fu , shell_no );
	NMG_INDEX_ASSIGN( flags , fu->fumate_p , shell_no );

	/* now pop edgeuse of the stack and visit faces radial to edgeuse */
	while( (eu1 = nmg_pop_eu( &stack )) != (struct edgeuse *)NULL )
	{
		NMG_CK_EDGEUSE( eu1 );

		/* move to the radial */
		eu = eu1->radial_p;
		NMG_CK_EDGEUSE( eu );

		/* make sure we stay within the intended shell */
		while( nmg_find_s_of_eu( eu ) != s && eu != eu1 && eu != eu1->eumate_p )
			eu = eu->eumate_p->radial_p;

		if( eu == eu1 || eu == eu1->eumate_p )
			continue;

		fu = nmg_find_fu_of_eu( eu );
		NMG_CK_FACEUSE( fu );

		if( fu->orientation != OT_SAME )
			fu = fu->fumate_p;

		/* if this faceuse has already been visited, skip it */
		if( !NMG_INDEX_TEST( flags , fu ) )
		{
                        /* push all edgeuses of "fu" onto the stacks */
                        for( BU_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
                        {
                                NMG_CK_LOOPUSE( lu );

                                if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
                                        continue;

                                for( BU_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
                                {
					/* build two lists, one of winged edges, the other not */
					if( nmg_radial_face_count( eu , s ) > 2 )
						bu_ptbl_ins_unique( &shared_edges , (long *)eu );
					else
						bu_ptbl_ins_unique( &stack , (long *)eu );
                                }
                        }
			/* Mark this faceuse and its mate with a shell number */
			NMG_INDEX_ASSIGN( flags , fu , shell_no );
			NMG_INDEX_ASSIGN( flags , fu->fumate_p , shell_no );
		}
	}

	/* count number of faces that were not visited */
	missed_faces = 0;
	for( BU_LIST_FOR( fu , faceuse , &s->fu_hd ) )
	{
		NMG_CK_FACEUSE( fu );
		if( fu->orientation == OT_SAME )
		{
			if( !NMG_INDEX_TEST( flags , fu ) )
			{
				missed_faces++;
				missed_fu = fu;
			}
		}
	}

	if( !missed_faces )	/* nothing to do, just one shell */
	{
		bu_free( (char *)flags , "nmg_decompose_shell: flags " );
		bu_ptbl_free( &stack );
		bu_ptbl_free( &shared_edges );
		return( no_of_shells );
	}

	while( missed_faces )
	{
		struct edgeuse *unassigned_eu = NULL;
		int *shells_at_edge;
		int new_shell_no=0;

		bu_ptbl_reset( &stack );

		/* Look at the list of shared edges to see if anything can be deduced */
		shells_at_edge = (int *)bu_calloc( no_of_shells+1 , sizeof( int ) , "nmg_decompose_shell: shells_at_edge" );

		for( i=0 ; i<BU_PTBL_END( &shared_edges ) ; i++ )
		{
			int faces_at_edge=0;
			int k;

			/* Construct a list of shells for this edge.
			 * shells_at_edge[i] is the number of edgeuses of this
			 * edge that have been assigned to shell number i.
			 * shells_at_edge[0] is the number of uses of this edge
			 * that have not been asigned to any shell yet
			 */
			for( k=0 ; k<=no_of_shells ; k++ )
				shells_at_edge[k] = 0;

			unassigned_eu = NULL;

			eu = (struct edgeuse *)BU_PTBL_GET( &shared_edges , i );
			NMG_CK_EDGEUSE( eu );

			eu1 = eu;
			do
			{
				struct faceuse *fu_of_eu;

				fu_of_eu = nmg_find_fu_of_eu( eu1 );

				faces_at_edge++;
				if( !NMG_INDEX_TEST( flags , fu_of_eu ) )
					unassigned_eu = eu1;
				shells_at_edge[ NMG_INDEX_GET( flags , fu_of_eu ) ]++;

				eu1 = nmg_next_radial_eu( eu1 , s , 0 );
			}
			while( eu1 != eu );

			if( shells_at_edge[0] == 1 && unassigned_eu )
			{
				/* Only one edgeuse at this edge is unassigned, should be
				 * able to determine which shell it belongs in */

				for( j=1 ; j<=no_of_shells ; j++ )
				{
					if( shells_at_edge[j] == 1 )
					{
						/* unassigned edgeuse should belong to shell j */
						new_shell_no = j;
						break;
					}
				}
			}
			else if( shells_at_edge[0] == 0 )
			{
				/* all uses of this edge have been assigned
				 * it can be deleted from the table
				 */
				bu_ptbl_rm( &shared_edges , (long *)eu );
			}
			if( new_shell_no )
				break;
		}

		if( !new_shell_no )
		{
			/* Couldn't find a definite edgeuse to start a new shell
			 * so use radial parity to pick an edgeuse that should not be
			 * part of the same shell as ones already assigned
			 */
			for( i=0 ; i<BU_PTBL_END( &shared_edges ) ; i++ )
			{
				struct faceuse *fu_of_eu1;
				int found_missed_face=0;

				eu = (struct edgeuse *)BU_PTBL_GET( &shared_edges , i );
				NMG_CK_EDGEUSE( eu );

				eu1 = eu;
				do
				{
					/* look for unassigned edgeuses */
					fu_of_eu1 = nmg_find_fu_of_eu( eu1 );
					NMG_CK_FACEUSE( fu_of_eu1 );
					if( !NMG_INDEX_TEST( flags , fu_of_eu1 ) )
					{
						struct edgeuse *eu2;
						struct faceuse *fu_of_eu2;

						/* look for a neighboring edgeuse that
						 * has been assigned
						 */
						eu2 = nmg_prev_radial_eu( eu1 , s , 0 );
						fu_of_eu2 = nmg_find_fu_of_eu( eu2 );
						NMG_CK_FACEUSE( fu_of_eu2 );
						if( NMG_INDEX_TEST( flags , fu_of_eu2 ) )
						{
							/* eu2 has been assigned
							 * compare orientation parity
							 */
							if( fu_of_eu2->orientation ==
								fu_of_eu1->orientation )
							{
								/* These should not be in the same
								 * shell, so start a new shell
								 * at this faceuse
								 */
								missed_fu = fu_of_eu1;
								found_missed_face = 1;
							}
						}
						if( found_missed_face )
							break;

						eu2 = nmg_next_radial_eu( eu1 , s , 0 );
						fu_of_eu2 = nmg_find_fu_of_eu( eu2 );
						NMG_CK_FACEUSE( fu_of_eu2 );
						if( NMG_INDEX_TEST( flags , fu_of_eu2 ) )
						{
							/* eu2 has been assigned
							 * compare orientation parity
							 */
							if( fu_of_eu2->orientation ==
								fu_of_eu1->orientation )
							{
								/* These should not be in the same
								 * shell, so start a new shell
								 * at this faceuse
								 */
								missed_fu = fu_of_eu1;
								found_missed_face = 1;
							}
						}

					}
					if( found_missed_face )
						break;
					eu1 = nmg_next_radial_eu( eu1 , s , 0 );
				}
				while( eu1 != eu );

				if( found_missed_face )
					break;
			}
		}

		bu_free( (char *)shells_at_edge , "nmg_decompose_shell: shells_at_edge" );

		/* make a new shell number */
		if( new_shell_no )
		{
			shell_no = new_shell_no;
			fu = nmg_find_fu_of_eu( unassigned_eu );
		}
		else
		{
			shell_no = (++no_of_shells);
			NMG_CK_FACEUSE( missed_fu );
			fu = missed_fu;
		}

		if( fu->orientation != OT_SAME )
			fu = fu->fumate_p;

		if( !NMG_INDEX_TEST( flags , fu ) )
		{
			/* move this missed face to the new shell */

                        /* push all edgeuses of "fu" onto the stack */
                        for( BU_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
                        {
                                NMG_CK_LOOPUSE( lu );

                                if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
                                        continue;

                                for( BU_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
                                {
					/* build two lists, one of winged edges, the other not */
					if( nmg_radial_face_count( eu , s ) > 2 )
						bu_ptbl_ins_unique( &shared_edges , (long *)eu );
					else
						bu_ptbl_ins_unique( &stack , (long *)eu );
                                }
                        }

			/* Mark this faceuse with a shell number */
			NMG_INDEX_ASSIGN( flags , fu , shell_no );
			NMG_INDEX_ASSIGN( flags , fu->fumate_p , shell_no );

		}
		else
			rt_bomb( "nmg_decompose_shell: Missed face wasn't missed???\n" );

		/* now pop edgeuse of the stack and visit faces radial to edgeuse */
		while( (eu1 = nmg_pop_eu( &stack )) != (struct edgeuse *)NULL )
		{
			NMG_CK_EDGEUSE( eu1 );

			/* move to the radial */
			eu = eu1->radial_p;
			NMG_CK_EDGEUSE( eu );

			/* stay within the original shell */
			while( nmg_find_s_of_eu( eu ) != s && eu != eu1 && eu != eu1->eumate_p )
				eu = eu->eumate_p->radial_p;

			if( eu == eu1 || eu == eu1->eumate_p )
				continue;

			fu = nmg_find_fu_of_eu( eu );
			NMG_CK_FACEUSE( fu );

			/* if this face has already been visited, skip it */
			if( !NMG_INDEX_TEST( flags , fu ) )
			{
	                        /* push all edgeuses of "fu" onto the stack */
	                        for( BU_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
	                        {
	                                NMG_CK_LOOPUSE( lu );
	                                if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
	                                        continue;
	                                for( BU_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
	                                {
						/* build two lists, one of winged edges, the other not */
						if( nmg_radial_face_count( eu , s ) > 2 )
							bu_ptbl_ins_unique( &shared_edges , (long *)eu );
						else
							bu_ptbl_ins_unique( &stack , (long *)eu );
	                                }
	                        }

				/* Mark this faceuse with a shell number */
				NMG_INDEX_ASSIGN( flags , fu , shell_no );
				NMG_INDEX_ASSIGN( flags , fu->fumate_p , shell_no );

			}
		}

		/* count number of faces that were not visited */
		missed_faces = 0;
		for( BU_LIST_FOR( fu , faceuse , &s->fu_hd ) )
		{
			NMG_CK_FACEUSE( fu );
			if( fu->orientation == OT_SAME )
			{
				if( !NMG_INDEX_TEST( flags , fu ) )
				{
					missed_faces++;
					missed_fu = fu;
				}
			}
		}
	}

	/* Now build the new shells */
	for( shell_no=2 ; shell_no<=no_of_shells ; shell_no++ )
	{
		struct bu_ptbl faces;

		bu_ptbl_init( &faces, 64, "Faces ptbl for nmg_decompose_shell" );

		/* Make a shell */
		new_s = nmg_msv( r );
		(void)nmg_kvu( new_s->vu_p );

		/* Move faces marked with this shell_no to this shell */
		fu = BU_LIST_FIRST( faceuse , &s->fu_hd );
		while( BU_LIST_NOT_HEAD( fu , &s->fu_hd ) )
		{
			struct faceuse *next_fu;

			next_fu = BU_LIST_NEXT( faceuse , &fu->l );
			while( BU_LIST_NOT_HEAD( next_fu , &s->fu_hd ) && next_fu->orientation != OT_SAME )
				next_fu = BU_LIST_NEXT( faceuse , &next_fu->l );

			if( fu->orientation != OT_SAME )
			{
				fu = next_fu;
				continue;
			}

			if( NMG_INDEX_GET( flags , fu ) == shell_no )
			{
				nmg_mv_fu_between_shells( new_s , s , fu );
				bu_ptbl_ins( &faces, (long *)fu );
			}

			fu = next_fu;
		}

		nmg_gluefaces( (struct faceuse **)BU_PTBL_BASEADDR( &faces ), BU_PTBL_END( &faces ), tol );
		bu_ptbl_free( &faces );
		nmg_shell_a( new_s, tol );
	}
	bu_free( (char *)flags , "nmg_decompose_shell: flags " );
	bu_ptbl_free( &stack );
	bu_ptbl_free( &shared_edges );

	nmg_rebound( m ,tol );

	if( rt_g.NMG_debug & DEBUG_BASIC )
		bu_log( "nmg_decompose_shell END (%d shells)\n" , no_of_shells );

	return( no_of_shells );
}

/*
 *			N M G _ S T A S H _ M O D E L _ T O _ F I L E
 *
 *  Store an NMG model as a separate .g file, for later examination.
 *  Don't free the model, as the caller may still have uses for it.
 *
 *  NON-PARALLEL because of rt_uniresource.
 */
void
nmg_stash_model_to_file(const char *filename, const struct model *m, const char *title)
{
	struct rt_wdb		*fp;
	struct rt_db_internal	intern;
	struct bu_external	ext;
	int			ret;
	int			flags;
	char			*name="error.s";

	bu_log("nmg_stash_model_to_file('%s', x%x, %s)\n", filename, m, title);

	NMG_CK_MODEL(m);
	nmg_vmodel(m);

	if( (fp = wdb_fopen(filename)) == NULL )  {
		perror(filename);
		return;
	}

	RT_INIT_DB_INTERNAL(&intern);
	intern.idb_major_type = DB5_MAJORTYPE_BRLCAD;
	intern.idb_type = ID_NMG;
	intern.idb_meth = &rt_functab[ID_NMG];
	intern.idb_ptr = (genptr_t)m;

	if( fp->dbip->dbi_version <= 4 )  {
		BU_INIT_EXTERNAL( &ext );
		ret = intern.idb_meth->ft_export( &ext, &intern, 1.0, fp->dbip, &rt_uniresource );
		if( ret < 0 )  {
			bu_log("rt_db_put_internal(%s):  solid export failure\n",
				name);
			ret = -1;
			goto out;
		}
		db_wrap_v4_external( &ext, name );
	} else {
		if( rt_db_cvt_to_external5( &ext, name, &intern, 1.0, fp->dbip, &rt_uniresource, intern.idb_major_type ) < 0 )  {
			bu_log("wdb_export(%s): solid export failure\n",
				name );
			ret = -2;
			goto out;
		}
	}
	BU_CK_EXTERNAL( &ext );

	flags = db_flags_internal( &intern );
	ret = wdb_export_external( fp, &ext, name, flags, intern.idb_type );
out:
	bu_free_external( &ext );
	wdb_close( fp );

	bu_log("nmg_stash_model_to_file(): wrote error.s to '%s'\n",
		filename);
}

/* state for nmg_unbreak_edge */
struct nmg_unbreak_state
{
	long		*flags;		/* index based array of flags for model */
	int		unbroken;	/* count of edges mended */
};

/*
 *			N M G _ U N B R E A K _ H A N D L E R
 *
 *	edgeuse visit routine for nmg_unbreak_region_edges.
 *
 *	checks if edgeuse "eu" and its successor are candidates	to be unbroken.
 *	looks for two consectutive edgeuses sharing the same
 *	edge geometry. Checks that the middle vertex has no
 *	other uses, and,  if so, kills the second edgeuse.
 *	Also moves the vu of the first edgeuse mate to the vu
 *	of the killed edgeuse mate.
 */
void
nmg_unbreak_handler(long int *eup, genptr_t state, int after)
{
	struct edgeuse *eu1,*eu2;
	struct edge *e;
	struct edge_g_lseg *eg;
	struct nmg_unbreak_state *ub_state;
	struct vertex	*vb;
	int		ret;

	eu1 = (struct edgeuse *)eup;
	NMG_CK_EDGEUSE( eu1 );

	ub_state = (struct nmg_unbreak_state *)state;

	/* there is a temptation to do a NMG_INDEX_SET( ub_state->flags , eu1->eumate_p )
	 * here to avoid looking at this edgeuse's mate, but since we are only looking
	 * forward, we must look at ALL edgeuses
	 */

	/* make sure we only visit this edgeuse once */
	if( !NMG_INDEX_TEST_AND_SET( ub_state->flags , eu1 ) )  return;

	e = eu1->e_p;
	NMG_CK_EDGE( e );

	eg = eu1->g.lseg_p;
	if( !eg )  {
		bu_log( "nmg_unbreak_handler: no geomtry for edge x%x\n" , e );
		return;
	}
	NMG_CK_EDGE_G_EITHER(eg);

	/* if the edge geometry doesn't have at least two uses, this
	 * is not a candidate for unbreaking */		
	if( bu_list_len( &eg->eu_hd2 ) < 2*2 )  {
		/* bu_log("nmg_unbreak_handler: usage < 4\n"); */
		return;
	}

	/* Check for two consecutive uses, by looking forward. */
	eu2 = BU_LIST_PNEXT_CIRC( edgeuse , eu1 );
	NMG_CK_EDGEUSE( eu2 );
	if( eu2->g.lseg_p != eg )
	{
		/* Can't look backward here, or nmg_unbreak_edge()
		 * will be asked to kill *this* edgeuse, which
		 * will blow our caller's mind.
		 */
		/* bu_log("nmg_unbreak_handler: eu1 edge geom not shared with eu2\n"); */
		return;
	}
	vb = eu2->vu_p->v_p;
	NMG_CK_VERTEX(vb);

	/* at this point, the situation is:

		     eu1          eu2
		*----------->*----------->*
		A------------B------------C
		*<-----------*<-----------*
		    eu1mate      eu2mate
	*/
	ret = nmg_unbreak_edge( eu1 );
	if( ret != 0 )  return;

	/* keep a count of unbroken edges */
	ub_state->unbroken++;
}

/*
 *			N M G _ U N B R E A K _ R E G I O N _ E D G E S
 *
 *	Uses the visit handler to call nmg_unbreak_handler for
 *	each edgeuse below the region (or any other NMG element).
 *
 *	returns the number of edges mended
 */
int
nmg_unbreak_region_edges(long int *magic_p)
{
	struct model *m;
	struct nmg_visit_handlers htab;
	struct nmg_unbreak_state ub_state;
	int count;

	if( rt_g.NMG_debug & DEBUG_BASIC )
		bu_log( "nmg_unbreak_region_edges( magic_p = x%x )\n" , magic_p );

	m = nmg_find_model( magic_p );
	NMG_CK_MODEL( m );	

	htab = nmg_visit_handlers_null;		/* struct copy */
	htab.aft_edgeuse = nmg_unbreak_handler;

	ub_state.unbroken = 0;
	ub_state.flags = (long *)bu_calloc( m->maxindex*2 , sizeof( long ) , "nmg_unbreak_region_edges: flags" );

	nmg_visit( magic_p , &htab , (genptr_t *)&ub_state );

	count = ub_state.unbroken;

	bu_free( (char *)ub_state.flags , "nmg_unbreak_region_edges: flags" );

	return( count );
}

/*
 *			R T _ D I S T _ P T 3 _ L I N E 3
 *
 *  Find the distance from a point P to a line described
 *  by the endpoint A and direction dir, and the point of closest approach (PCA).
 *
 *			P
 *		       *
 *		      /.
 *		     / .
 *		    /  .
 *		   /   . (dist)
 *		  /    .
 *		 /     .
 *		*------*-------->
 *		A      PCA	dir
 *
 *  There are three distinct cases, with these return codes -
 *	0	P is within tolerance of point A.  *dist = 0, pca=A.
 *	1	P is within tolerance of line.  *dist = 0, pca=computed.
 *	2	P is "above/below" line.  *dist=|PCA-P|, pca=computed.
 *
 *
 * XXX For efficiency, a version of this routine that provides the
 * XXX distance squared would be faster.
XXX This should be moved into libbn/plane.c,
XXX probably named bn_dist_pt3_line3().
 */
int
rt_dist_pt3_line3(fastf_t *dist, fastf_t *pca, const fastf_t *a, const fastf_t *dir, const fastf_t *p, const struct bn_tol *tol)
{
	vect_t	AtoP;		/* P-A */
	vect_t	unit_dir;	/* unitized dir vector */
	fastf_t	A_P_sq;		/* |P-A|**2 */
	fastf_t	t;		/* distance along ray of projection of P */
	fastf_t	dsq;		/* sqaure of distance from p to line */

	if( rt_g.NMG_debug & DEBUG_BASIC )
		bu_log( "rt_dist_pt3_line3( a=( %f %f %f ), dir=( %f %f %f ), p=( %f %f %f )\n" ,
			V3ARGS( a ) , V3ARGS( dir ) , V3ARGS( p ) );

	BN_CK_TOL(tol);

	/* Check proximity to endpoint A */
	VSUB2(AtoP, p, a);
	if( (A_P_sq = MAGSQ(AtoP)) < tol->dist_sq )  {
		/* P is within the tol->dist radius circle around A */
		VMOVE( pca, a );
		*dist = 0.0;
		return( 0 );
	}

	VMOVE( unit_dir , dir );
	VUNITIZE( unit_dir );

	/* compute distance (in actual units) along line to PROJECTION of
	 * point p onto the line: point pca
	 */
	t = VDOT(AtoP, unit_dir);

	VJOIN1( pca , a , t , unit_dir );
	if( (dsq = A_P_sq - t*t) < tol->dist_sq )
	{
		/* P is within tolerance of the line */
		*dist = 0.0;
		return( 1 );
	}
	else
	{
		/* P is off line */
		*dist = sqrt( dsq );
		return( 2 );
	}
}

/*
 *	N M G _ M V _ S H E L L _ T O _ R E G I O N
 *
 *  Move a shell from one nmgregion to another.
 *  Will bomb if shell and region aren't in the same model.
 *
 *  returns:
 *	0 - all is well
 *	1 - nmgregion that gave up the shell is now empty!!!!
 *
 */
int
nmg_mv_shell_to_region(struct shell *s, struct nmgregion *r)
{
	int ret_val;

	if( rt_g.NMG_debug & DEBUG_BASIC )
		bu_log( "nmg_mv_shell_to_region( s=x%x , r=x%x )\n" , s , r );

	NMG_CK_SHELL( s );
	NMG_CK_REGION( r );

	if( s->r_p == r )
	{
		bu_log( "nmg_mv_shell_to_region: Attempt to move shell to region it is already in\n" );
		return( 0 );
	}

	if( nmg_find_model( &s->l.magic ) != nmg_find_model( &r->l.magic ) )
		rt_bomb( "nmg_mv_shell_to_region: Cannot move shell to a different model\n" );

	BU_LIST_DEQUEUE( &s->l );
	if( BU_LIST_IS_EMPTY( &s->r_p->s_hd ) )
		ret_val = 1;
	else
		ret_val = 0;

	BU_LIST_APPEND( &r->s_hd , &s->l );

	s->r_p = r;

	return( ret_val );
}

/*	N M G _ F I N D _ I S E C T _ F A C E S
 *
 *	Find all faces that contain vertex "new_v"
 *	Put them in a bu_ptbl "faces"
 *
 *	returns:
 *		the number of faces that contain the vertex
 *
 *	and fills in the table with the faces.
 *	Counts edges at this vertex where radial is mate (free_edges)
 */
int
nmg_find_isect_faces(const struct vertex *new_v, struct bu_ptbl *faces, int *free_edges, const struct bn_tol *tol)
{
	struct faceuse *fu;
	struct face_g_plane *fg;
	struct vertexuse *vu;
	int i;
	int unique;

	if( rt_g.NMG_debug & DEBUG_BASIC )
		bu_log( "nmg_find_isect_faces( new_v=x%x , faces=x%x )\n" , new_v , faces );

	NMG_CK_VERTEX( new_v );
	BN_CK_TOL( tol );
	BU_CK_PTBL( faces );

	/* loop through vertex's vu list */
	for( BU_LIST_FOR( vu , vertexuse , &new_v->vu_hd ) )
	{
		NMG_CK_VERTEXUSE( vu );
		fu = nmg_find_fu_of_vu( vu );
		if( fu->orientation != OT_SAME )
			continue;;

		NMG_CK_FACEUSE( fu );
		fg = fu->f_p->g.plane_p;

		/* check if this face is different from the ones on list */
		unique = 1;
		for( i=0 ; i<BU_PTBL_END( faces ) ; i++ )
		{
			struct face *fp;

			fp = (struct face *)BU_PTBL_GET( faces , i );
			if( fp->g.plane_p == fg || bn_coplanar( fg->N , fp->g.plane_p->N , tol ) > 0 )
			{
				unique = 0;
				break;
			}
		}

		/* if it is not already on the list, add it */
		if( unique )
		{
			struct edgeuse *eu1;

			bu_ptbl_ins( faces , (long *)fu->f_p );
			/* Count the number of free edges containing new_v */

			if( *vu->up.magic_p != NMG_EDGEUSE_MAGIC )
				continue;

			eu1 = vu->up.eu_p;
			if( eu1->eumate_p == eu1->radial_p )
				(*free_edges)++;
			else
			{
				eu1 = BU_LIST_PPREV_CIRC( edgeuse , eu1 );
				if( eu1->eumate_p == eu1->radial_p )
					(*free_edges)++;
			}
		}
	}
	return( BU_PTBL_END( faces ) );
}

/*	N M G _ S I M P L E _ V E R T E X _ S O L V E
 *
 *	given a vertex and a list of faces (not more than three)
 *	that should intersect at the vertex, calculate a new
 *	location for the vertex.
 *
 *	returns:
 *		0 - if everything is OK
 *		1 - failure
 *
 *	and modifies the geometry of the vertex to the new location
 */
int
nmg_simple_vertex_solve(struct vertex *new_v, const struct bu_ptbl *faces, const struct bn_tol *tol)
{
	struct vertex_g *vg;
	int failed=0;

	if( rt_g.NMG_debug & DEBUG_BASIC )
	{
		struct face *f;
		struct faceuse *fu;
		plane_t pl;
		int i;

		bu_log( "nmg_simple_vertex_solve( new_v=x%x , %d faces )\n" , new_v , BU_PTBL_END( faces ));

		for( i=0 ; i<BU_PTBL_END( faces ) ; i++ )
		{
			f = (struct face *)BU_PTBL_GET( faces, i );
			fu = f->fu_p;
			if( fu->orientation != OT_SAME )
				fu = fu->fumate_p;
			if( fu->orientation != OT_SAME )
				bu_log( "\tface (x%x) has no OT_SAME use\n", f );
			NMG_GET_FU_PLANE( pl, fu );
			bu_log( "\t#%d: %g %g %g %g\n", i, V4ARGS( pl ) );
		}
	}

	NMG_CK_VERTEX( new_v );
	BU_CK_PTBL( faces );
	BN_CK_TOL( tol );

	vg = new_v->vg_p;
	NMG_CK_VERTEX_G( vg );

	switch( BU_PTBL_END( faces ) )
	{
		struct face *fp1,*fp2,*fp3;
		plane_t pl1;
		fastf_t	vert_move_len;
		fastf_t pl_dot;

		case 0:
			bu_log( "nmg_simple_vertex_solve: vertex not in any face planes!!!\n" );
			failed = 1;
			break;

		case 1:		/* just move the vertex to the plane */
			fp1 = (struct face *)BU_PTBL_GET( faces , 0 );
			vert_move_len = DIST_PT_PLANE( vg->coord , fp1->g.plane_p->N );
			VJOIN1( vg->coord , vg->coord , -vert_move_len , fp1->g.plane_p->N );
			break;

		case 2:
			fp1 = (struct face *)BU_PTBL_GET( faces , 0 );
			fp2 = (struct face *)BU_PTBL_GET( faces , 1 );

			pl_dot = VDOT( fp1->g.plane_p->N, fp2->g.plane_p->N );
			if( NEAR_ZERO( pl_dot - 1.0 , tol->perp ) || NEAR_ZERO( pl_dot + 1.0, tol->perp) )
			{
				vect_t move_vect;

				/* treat as a single plane */
				vert_move_len = (DIST_PT_PLANE( vg->coord , fp1->g.plane_p->N )
						+ DIST_PT_PLANE( vg->coord , fp2->g.plane_p->N ))/2.0;
				VADD2( move_vect, fp1->g.plane_p->N, fp2->g.plane_p->N );
				VUNITIZE( move_vect );
				VJOIN1( vg->coord, vg->coord, -vert_move_len, move_vect );
			}
			else
			{
				/* create a third plane perpendicular to first two */

				VCROSS( pl1 , fp1->g.plane_p->N , fp2->g.plane_p->N );

				VUNITIZE( pl1 );
				pl1[3] = VDOT( vg->coord , pl1 );
				if( bn_mkpoint_3planes( vg->coord , fp1->g.plane_p->N , fp2->g.plane_p->N , pl1 ) )
				{
					bu_log( "nmg_simple_vertex_solve: Cannot find new coords for two planes\n" );
					bu_log( "\tplanes are ( %f %f %f %f ) and ( %f %f %f %f )\n",
						V4ARGS( fp1->g.plane_p->N ) ,
						V4ARGS( fp2->g.plane_p->N ) );
					bu_log( "\tcalculated third plane is ( %f %f %f %f )\n" , V4ARGS( pl1 ) );
					failed = 1;
					break;
				}
			}
			break;

		case 3:		/* just intersect the three planes */
			fp1 = (struct face *)BU_PTBL_GET( faces , 0 );
			fp2 = (struct face *)BU_PTBL_GET( faces , 1 );
			fp3 = (struct face *)BU_PTBL_GET( faces , 2 );
			if( bn_mkpoint_3planes( vg->coord , fp1->g.plane_p->N , fp2->g.plane_p->N , fp3->g.plane_p->N ) )
			{
				bu_log( "nmg_simple_vertex_solve: failed for 3 planes:\n" );
				bu_log( "\t( %f %f %f %f )\n" , V4ARGS( fp1->g.plane_p->N ) );
				bu_log( "\t( %f %f %f %f )\n" , V4ARGS( fp2->g.plane_p->N ) );
				bu_log( "\t( %f %f %f %f )\n" , V4ARGS( fp3->g.plane_p->N ) );
				failed = 1;
				break;
			}
			break;
		default:
			failed = 1;
			bu_log( "nmg_simple_vertex_solve: Called for a complex vertex\n" );
			break;
	}

	if( failed )
		bu_log( "nmg_simple_vertex_solve: Failed to determine new coordinates for vertex at ( %f %f %f )\n",
			V3ARGS( new_v->vg_p->coord ) );
	else if( rt_g.NMG_debug & DEBUG_BASIC )
		bu_log( "nmg_simple_vertex_solve: new coords = ( %f %f %f )\n",
			V3ARGS( new_v->vg_p->coord ) );

	return( failed );
}

/*	N M G _ C K _ V E R T _ O N _ F U S
 *
 *  Check all uses of a vertex to see if it lies within tolerance
 *  of all faces where it is used
 *
 * returns:
 *	0 - All is well
 *	1 - vertex is off face plane by at least tol->dist for at least one face
 */
int
nmg_ck_vert_on_fus(const struct vertex *v, const struct bn_tol *tol)
{
	struct vertexuse *vu;
	fastf_t max_dist=0.0;
	int ret_val=0;

	NMG_CK_VERTEX( v );
	BN_CK_TOL( tol );

	NMG_CK_VERTEX_G( v->vg_p );

	for( BU_LIST_FOR( vu , vertexuse , &v->vu_hd ) )
	{
		struct faceuse *fu;
		fastf_t dist;

		fu = nmg_find_fu_of_vu( vu );
		if( !fu )
			continue;

		NMG_CK_FACEUSE( fu );
		NMG_CK_FACE( fu->f_p );
		NMG_CK_FACE_G_PLANE( fu->f_p->g.plane_p );
		dist = DIST_PT_PLANE( v->vg_p->coord , fu->f_p->g.plane_p->N );
		dist = (dist < 0.0 ? (-dist) : dist);
		if( dist > tol->dist )
		{
			ret_val = 1;

			if( dist > max_dist )
				max_dist = dist;

			bu_log( "nmg_ck_vert_on_fus: v=x%x vu=x%x ( %f %f %f ) is %g from\n\tfaceuse x%x f x%x\n" , v , vu , V3ARGS( v->vg_p->coord ) , dist , fu , fu->f_p );
		}
	}

	if( ret_val )
		bu_log( "nmg_ck_vert_on_fus: v=x%x ( %f %f %f ) max distance of %g from faceuses\n" , v , V3ARGS( v->vg_p->coord ) , max_dist );

	return( ret_val );
}

/* struct used by nmg_complex_vertex_solve
 * to store info about one edge
 * that contains the vertex in question
 */
struct intersect_fus
{
	struct faceuse *fu[2];	/* fu's that intersect at this edge */
	struct edgeuse *eu;	/* edgeuse in fu[0] that emanates from vertex */
	point_t start;		/* calculated start point of edge line */
	vect_t dir;		/* calculated direction of edge line */
	point_t pt;		/* a point on the edge a small distance from the vertex */
	int got_pt;		/* flag indicating that the above point has been obtained */
	int free_edge;		/* flag indicating that this is a free edge */
	struct vertex *vp;	/* a vertex pointer for above point */
};

/*	N M G _ P R _ I N T E R
 *
 * debug printing of the table of intersect_fus structs used by extruder
 */

static void
nmg_pr_inter(const struct vertex *new_v, const struct bu_ptbl *int_faces)
{
	int i;
	struct bn_tol tol;

	NMG_CK_VERTEX( new_v );
	BU_CK_PTBL( int_faces );

	tol.magic = BN_TOL_MAGIC;
	tol.dist = 0.005;
	tol.dist_sq = tol.dist * tol.dist;
	tol.perp = 1e-6;
	tol.para = 1 - tol.perp;

	bu_log( "\nint_faces at vertex x%x ( %f %f %f )\n" , new_v , V3ARGS( new_v->vg_p->coord ) );
	for( i=0 ; i<BU_PTBL_END( int_faces ) ; i++ )
	{
		struct intersect_fus *i_fus;
		struct face *fp1,*fp2;
		plane_t pl;

		i_fus = (struct intersect_fus *)BU_PTBL_GET( int_faces , i );

		bu_log( "edge number %d, x%x\n" , i , i_fus );
		if( i_fus->fu[0] )
			fp1 = i_fus->fu[0]->f_p;
		else
			fp1 = NULL;
		if( i_fus->fu[1] )
		{
			fp2 = i_fus->fu[1]->f_p;
			NMG_GET_FU_PLANE( pl , i_fus->fu[1] );
		}
		else
			fp2 = NULL;

		if( i_fus->fu[1] )
			bu_log( "\tfu1 = x%x (face=x%x), fu2 = x%x (face=x%x) ( %f %f %f %f )\n" , i_fus->fu[0] , fp1 , i_fus->fu[1] , fp2 , V4ARGS( pl ) );
		else
			bu_log( "\tfu1 = x%x (face=x%x), fu2 = x%x (face=x%x)\n" , i_fus->fu[0] , fp1 , i_fus->fu[1] , fp2 );

		if( i_fus->eu == NULL )
			bu_log( "\teu = NULL\n" );
		else if( i_fus->eu->vu_p == NULL )
			bu_log( "\teu = x%x , vu_p = NULL\n" , i_fus->eu );
		else
		{
			struct faceuse *fu;

			bu_log( "\teu = x%x, from x%x ( %f %f %f ) to x%x ( %f %f %f )\n" , i_fus->eu,
				i_fus->eu->vu_p->v_p , V3ARGS( i_fus->eu->vu_p->v_p->vg_p->coord ),
				i_fus->eu->eumate_p->vu_p->v_p , V3ARGS( i_fus->eu->eumate_p->vu_p->v_p->vg_p->coord ) );
			if( i_fus->fu[0] )
			{
				fu = nmg_find_fu_of_eu( i_fus->eu );
				if( fu != i_fus->fu[0] )
					bu_log( "****ERROR**** eu is not in fu1 it's in x%x\n" , fu );
			}
			else
			{
				fu = nmg_find_fu_of_eu( i_fus->eu );
				if( fu != i_fus->fu[1] )
					bu_log( "****ERROR**** eu is not in fu2, it's in x%x\n" , fu );
			}
#if 0
			/* XXXX sometimes this gives a zero length edge error in spite of the check!! */
			if( !bn_pt3_pt3_equal( i_fus->eu->vu_p->v_p->vg_p->coord, i_fus->eu->eumate_p->vu_p->v_p, &tol ) )
				nmg_pr_fu_around_eu( i_fus->eu , &tol );
#endif
		}

		bu_log( "\tstart = ( %f %f %f ) , dir = ( %f %f %f )\n" , V3ARGS( i_fus->start ) , V3ARGS( i_fus->dir ) );
		bu_log( "\tpt = ( %f %f %f )\n" , V3ARGS( i_fus->pt ) );
		bu_log( "\tfree_edge = %d\n" , i_fus->free_edge );
		if( i_fus->eu && i_fus->eu->vu_p )
		{
			if( i_fus->eu->eumate_p != i_fus->eu->radial_p &&
			    i_fus->free_edge )
				bu_log( "****ERROR**** this is NOT a free edge\n" );
			if( i_fus->eu->eumate_p == i_fus->eu->radial_p &&
			    !i_fus->free_edge )
				bu_log( "****ERROR**** This is a free edge\n" );
		}
		if( i_fus->vp )
			bu_log( "\tvp = x%x ( %f %f %f )\n" , i_fus->vp , V3ARGS( i_fus->vp->vg_p->coord ) );
		else
			bu_log( "\tvp = NULL\n" );
	}
}

/*	N M G _ G E T _ E D G E _ L I N E S
 *
 * Fill in the intersect_fus structures for edges around
 * new_v. Does not fill in "pt" or "vp".
 *
 *	returns:
 *		0 - All is well
 *		1 - Failure
 */

static int
nmg_get_edge_lines(struct vertex *new_v, struct bu_ptbl *int_faces, const struct bn_tol *tol)
{
	struct vertex_g *vg;
	struct vertexuse *vu;
	struct edgeuse *eu,*eu1;
	struct faceuse *fu;
	struct model *m;
	struct nmgregion *r;
	struct bn_tol tol_tmp;
	int done=0;
	int edge_no;

	NMG_CK_VERTEX( new_v );
	vg = new_v->vg_p;
	NMG_CK_VERTEX_G( vg );
	BN_CK_TOL( tol );
	BU_CK_PTBL( int_faces );

	if( rt_g.NMG_debug & DEBUG_BASIC )
		bu_log( "nmg_get_edge_lines( new_v=x%x , int_faces=x%x )\n" , new_v , int_faces );

	/* A temporary tolerance struct for times when I don't want tolerancing */
	tol_tmp.magic = BN_TOL_MAGIC;
	tol_tmp.dist = 0.0;
	tol_tmp.dist_sq = 0.0;
	tol_tmp.perp = 0.0;
	tol_tmp.para = 1.0;

	m = nmg_find_model( &new_v->magic );
	NMG_CK_MODEL( m );
	r = BU_LIST_FIRST( nmgregion , &m->r_hd );
	NMG_CK_REGION( r );
	NMG_CK_REGION_A( r->ra_p );

	/* look for a dangling edge emanating from this vertex */
	eu1 = (struct edgeuse *)NULL;
	for( BU_LIST_FOR( vu , vertexuse , &new_v->vu_hd ) )
	{
		if( *vu->up.magic_p != NMG_EDGEUSE_MAGIC )
			continue;

		eu = vu->up.eu_p->eumate_p;
		fu = nmg_find_fu_of_eu( eu );
		if( !fu )
			continue;

		if( fu->orientation != OT_SAME )
			continue;

		if( eu->eumate_p == eu->radial_p )
		{
			/* found a dangling edge, start processing here */
			plane_t pl;
			struct intersect_fus *i_fus;

			/* create and initialize an intersect_fus struct for this edge */
			i_fus = (struct intersect_fus *)bu_malloc( sizeof( struct intersect_fus ) , "nmg_get_edge_lines: i_fus" );
			i_fus->fu[0] = NULL;
			i_fus->fu[1] = fu;
			i_fus->eu = eu;
			i_fus->vp = (struct vertex *)NULL;
			VSET( i_fus->pt , 0.0 , 0.0 , 0.0 );
			i_fus->got_pt = 0;
			i_fus->free_edge = 1;
			eu1 = BU_LIST_PNEXT_CIRC( edgeuse , &eu->l );

			VSUB2( i_fus->dir , eu->vu_p->v_p->vg_p->coord , eu->eumate_p->vu_p->v_p->vg_p->coord );
			VUNITIZE( i_fus->dir );
			NMG_GET_FU_PLANE( pl , fu );
			VJOIN1( i_fus->start , vg->coord , (-DIST_PT_PLANE( vg->coord , pl )) , pl );

			/* Save this info in the int_faces table */
			bu_ptbl_ins( int_faces , (long *)i_fus );

			break;
		}
	}

	if( !eu1 )
	{
		int found_start=0;

		/* get the an edgeuse emanating from new_v */
		for( BU_LIST_FOR( vu , vertexuse , &new_v->vu_hd ) )
		{
			NMG_CK_VERTEXUSE( vu );
			if( *vu->up.magic_p != NMG_EDGEUSE_MAGIC )
				continue;

			eu1 = vu->up.eu_p;

			fu = nmg_find_fu_of_eu( eu1 );
			NMG_CK_FACEUSE( fu );

			if( fu->orientation == OT_SAME )
			{
				found_start = 1;
				break;
			}
		}
		if( !found_start )
		{
			bu_log( "Cannot find edgeuse in OT_SAME faceuse starting at ( %f %f %f )\n",
				V3ARGS( new_v->vg_p->coord ) );
			return( 1 );
		}
	}

	eu = eu1;

	/* loop through all the edges emanating from new_v */
	while( !done )
	{
		fastf_t dist;
		point_t start;
		vect_t dir;
		vect_t eu_dir;
		int ret_val;
		struct intersect_fus *i_fus;
		struct faceuse *fu1,*fu2;

		NMG_CK_EDGEUSE( eu );

		if( eu->vu_p->v_p != new_v )
		{
			/* This can happen if the faces of the shell are not properly
			 * oriented such as might happen when an object is incorrectly
			 * modelled in FASTGEN and run through the patch-g converter
			 */
			bu_log( "nmg_get_edge_lines: Bad solid!!!\n" );
			for( edge_no=0 ; edge_no<BU_PTBL_END( int_faces ) ; edge_no++ )
			{
				struct intersect_fus *i_fus;

				i_fus = (struct intersect_fus *)BU_PTBL_GET( int_faces , edge_no );

				bu_free( (char *)i_fus , "nmg_get_edge_lines: i_fus" );
			}
			return( 1 );
		}

		/* get the direction of the original edge (away from the vertex) */
		VSUB2( eu_dir , eu->eumate_p->vu_p->v_p->vg_p->coord , eu->vu_p->v_p->vg_p->coord );

		/* get the two faces that intersect along this edge */
		fu1 = nmg_find_fu_of_eu( eu );
		fu2 = nmg_find_fu_of_eu( eu->radial_p );

		/* initialize the intersect structure for this edge */
		i_fus = (struct intersect_fus *)bu_malloc( sizeof( struct intersect_fus ) , "nmg_inside_vert: intersection list" );
		i_fus->fu[0] = fu1;
		if( eu->radial_p == eu->eumate_p )
		{
			i_fus->fu[1] = (struct faceuse *)NULL;
			i_fus->free_edge = 1;
			done = 1;
		}
		else
		{
			i_fus->fu[1] = fu2;
			i_fus->free_edge = 0;
		}
		i_fus->eu = eu;
		i_fus->vp = (struct vertex *)NULL;
		VSET( i_fus->pt , 0.0 , 0.0 , 0.0 );
		i_fus->got_pt = 0;
		VSET( i_fus->start , 0.0 , 0.0 , 0.0 );
		VSET( i_fus->dir , 0.0 , 0.0 , 0.0 );

		/* if edge is between loops of same face , don't calculate an edge line */
		if( fu1->f_p != fu2->f_p )
		{
			/* find the new edge line at the intersection of these two faces
			 * the line is defined by start and dir */

			ret_val = bn_isect_2planes( start, dir, 
						    fu1->f_p->g.plane_p->N,
						    fu2->f_p->g.plane_p->N,
						    new_v->vg_p->coord,
						    &tol_tmp );
			if( ret_val )
			{
				/* Cannot find line for this edge */
				bu_log( "nmg_inside_vert: Cannot find new edge between two planes\n" );
				bu_log( "return from bn_isect_2planes is %d\n" , ret_val );
				bu_log( "\tplanes are ( %f %f %f %f ) and ( %f %f %f %f )\n" ,
					V4ARGS( fu1->f_p->g.plane_p->N ),
					V4ARGS( fu2->f_p->g.plane_p->N ) );
				bu_log( "\tfus x%x and x%x, faces x%x and x%x\n" ,
					fu1, fu2, fu1->f_p, fu2->f_p );
				nmg_pr_fu_briefly( fu1 , "fu1: " );
				nmg_pr_fu_briefly( fu2 , "fu2: " );
				rt_bomb( "Can't find plane intersection\n" );
			}
			/* Make the start point at closest approach to old vertex */
			(void)rt_dist_pt3_line3( &dist , start , start , dir , new_v->vg_p->coord , tol );

			/* Make sure the calculated direction is away from the vertex */
			if( VDOT( eu_dir , dir ) < 0.0 )
				VREVERSE( dir , dir );
			VMOVE( i_fus->start , start );
			VMOVE( i_fus->dir , dir );
		}
		else if( i_fus->free_edge )
		{
			plane_t pl;

			/* for a dangling edge, use the same direction as the original edge
			 * just move the start point to the new plane
			 */

			NMG_GET_FU_PLANE( pl , fu1 );

			VMOVE( i_fus->dir , eu_dir );
			VUNITIZE( i_fus->dir );

			VJOIN1( i_fus->start , vg->coord , (-DIST_PT_PLANE( vg->coord , pl )) , pl );

		}

		/* Save this info in the int_faces table */
		bu_ptbl_ins( int_faces , (long *)i_fus );

		if( !done )
		{
			/* move on to the next edge emanating from new_v */
			eu = eu->radial_p;
			eu = BU_LIST_PNEXT_CIRC( edgeuse , eu );
			if( eu == eu1 )
				done = 1;
		}
	}
	if( rt_g.NMG_debug & DEBUG_BASIC )
	{
		bu_log( "After getting edge lines:\n" );
		nmg_pr_inter( new_v , int_faces );
	}

	return( 0 );
}

/*	N M G _ G E T _ M A X _ E D G E _ I N T E R S
 *
 * Fill in the "pt" portion of the "intersect_fus" structure
 * for edges around new_v by calculating the intersection with neighboring
 * edges and selecting the furthest one from new_v.
 */
static int
nmg_get_max_edge_inters(const struct vertex *new_v, struct bu_ptbl *int_faces, const struct bu_ptbl *faces, const struct bn_tol *tol)
{
	struct model *m;
	struct nmgregion *r;
	int edge_no;

	if( rt_g.NMG_debug & DEBUG_BASIC ) 
		bu_log( "nmg_get_max_edge_inters( new_v = x%x , %d intersect_fus structs , %d faces )\n" , new_v , BU_PTBL_END( int_faces ) , BU_PTBL_END( faces ) );

	NMG_CK_VERTEX( new_v );
	BN_CK_TOL( tol );
	BU_CK_PTBL( int_faces );

	m = nmg_find_model( &new_v->magic );
	NMG_CK_MODEL( m );
	r = BU_LIST_FIRST( nmgregion , &m->r_hd );
	NMG_CK_REGION( r );
	NMG_CK_REGION_A( r->ra_p );

	/* loop through edges departing from new_v */
	for( edge_no=0 ; edge_no<BU_PTBL_END( int_faces ) ; edge_no++ )
	{
		struct intersect_fus *edge_fus,*other_fus;
		fastf_t max_dist,dist[2];
		int next_edge_no,prev_edge_no;
		int other_index;

		edge_fus = (struct intersect_fus *)BU_PTBL_GET( int_faces , edge_no );

		/* don't calculate intersect point for edge between two loops of same face */
		if( edge_fus->fu[0] && edge_fus->fu[1] &&
			 edge_fus->fu[0]->f_p == edge_fus->fu[1]->f_p )
				continue;

		/* Find intersections with neighboring edges and keep the one
		 * furthest up the edge
		 */
		max_dist = (-MAX_FASTF);

		/* start with next edge */
		next_edge_no = edge_no + 1;
		if( next_edge_no == BU_PTBL_END( int_faces ) )
			next_edge_no = 0;

		other_fus = (struct intersect_fus *)BU_PTBL_GET( int_faces , next_edge_no );

		/* skip over edges betwen loops of same face */
		while( other_fus->fu[0] == other_fus->fu[1] && other_fus != edge_fus )
		{
			next_edge_no++;
			if( next_edge_no == BU_PTBL_END( int_faces ) )
				next_edge_no = 0;

			other_fus = (struct intersect_fus *)BU_PTBL_GET( int_faces , next_edge_no );

		}

		/* if we found another edge, calculate its intersection with the edge */
		if( other_fus != edge_fus )
		{
			if( !rt_dist_line3_line3( dist , edge_fus->start , edge_fus->dir , other_fus->start , other_fus->dir , tol ) )
			{
				if( rt_g.NMG_debug & DEBUG_BASIC )
					bu_log( "Edge #%d intersects edge #%d at dist = %f\n" , edge_no , next_edge_no , dist[0] );
				if( NEAR_ZERO( dist[0] , tol->dist ) )
					dist[0] = 0.0;
				if( dist[0] > max_dist )
					max_dist = dist[0];
			}
		}

		/* now check the previous neighboring edge */
		prev_edge_no = edge_no - 1;
		if( prev_edge_no < 0 )
			prev_edge_no = BU_PTBL_END( int_faces ) - 1;

		other_fus = (struct intersect_fus *)BU_PTBL_GET( int_faces , prev_edge_no );

		while( other_fus->fu[0] == other_fus->fu[1] && other_fus != edge_fus )
		{
			prev_edge_no--;
			if( prev_edge_no < 0 )
				prev_edge_no = BU_PTBL_END( int_faces ) - 1;

			other_fus = (struct intersect_fus *)BU_PTBL_GET( int_faces , prev_edge_no );
		}

		if( other_fus != edge_fus )
		{
			if( rt_dist_line3_line3( dist , edge_fus->start , edge_fus->dir , other_fus->start , other_fus->dir , tol ) >= 0 )
			{
				if( rt_g.NMG_debug & DEBUG_BASIC )
					bu_log( "Edge #%d intersects edge #%d at dist = %f\n" , edge_no , prev_edge_no , dist[0] );
				if( NEAR_ZERO( dist[0] , tol->dist ) )
					dist[0] = 0.0;
				if( dist[0] > max_dist )
					max_dist = dist[0];
			}
		}

		if( max_dist < 0.0 )
		{
			/* Now check for intersections with other planes */
			for( other_index=0 ; other_index<BU_PTBL_END( int_faces ) ; other_index ++ )
			{
				struct face *f;

				if( other_index == edge_no )
					continue;

				other_fus = (struct intersect_fus *)BU_PTBL_GET( int_faces , other_index );

				if( !other_fus->fu[0] )
					continue;

				NMG_CK_FACEUSE( other_fus->fu[0] );
				f = other_fus->fu[0]->f_p;

				if( edge_fus->fu[0] && f == edge_fus->fu[0]->f_p )
					continue;

				if( edge_fus->fu[1] && f == edge_fus->fu[1]->f_p )
					continue;

				/* Do not intersect with a plane that this edge is parallel to */
				if( NEAR_ZERO( VDOT( f->g.plane_p->N , edge_fus->dir ) , tol->perp ) )
					continue;

				if( bn_isect_line3_plane( &dist[0] , edge_fus->start , edge_fus->dir , f->g.plane_p->N , tol ) > 1 )
					continue;

				if( rt_g.NMG_debug & DEBUG_BASIC )
					bu_log( "Edge #%d intersects fu[0] from edge #%d at dist = %f\n" , edge_no , other_index , dist[0] );

				if( NEAR_ZERO( dist[0] , tol->dist ) )
					dist[0] = 0.0;

				if( dist[0] > max_dist )
					max_dist = dist[0];
			}
		}

		/* if any intersections have been found, save the point in edge_fus->pt */
		if( max_dist > (-MAX_FASTF) )
		{
			VJOIN1( edge_fus->pt , edge_fus->start , max_dist , edge_fus->dir );
			edge_fus->got_pt = 1;
		}
	}

	/* if no intersection was found, just use the edge-line start point */
	for( edge_no=0 ; edge_no < BU_PTBL_END( int_faces ) ; edge_no++ )
	{
		struct intersect_fus *edge_fus;

		edge_fus = (struct intersect_fus *)BU_PTBL_GET( int_faces , edge_no );
		if( !edge_fus->got_pt )
			VMOVE( edge_fus->pt , edge_fus->start )
	}

	if( rt_g.NMG_debug & DEBUG_BASIC )
	{
		bu_log( "After nmg_get_max_edge_inters:\n" );
		nmg_pr_inter( new_v , int_faces );
	}

	return( 0 );
}

/*	N M G _ F U S E _ I N T E R S
 *
 * eliminate "j_fus" from the table "int_faces" and
 * adjust the info in "i_fus".
 * This is done when the "vp" vertices of the two structures
 * have been joined.
 */
static void
nmg_fuse_inters(struct intersect_fus *i_fus, struct intersect_fus *j_fus, struct bu_ptbl *int_faces, const struct bn_tol *tol)
{
	struct edgeuse *radial_eu;
	struct edgeuse *prev_eu;

	BU_CK_PTBL( int_faces );
	BN_CK_TOL( tol );

	if( rt_g.NMG_debug & DEBUG_BASIC )
		bu_log( "nmg_fuse_inters: i_fus=x%x, j_fus=x%x, %d edges\n" , i_fus, j_fus, BU_PTBL_END( int_faces ) );

	/* remember the radial edge of the structure to be deleted */
	radial_eu = j_fus->eu->radial_p;

	/* if the vertices have been joined prev_eu and j_fus->eu should be adjacent */
	prev_eu = BU_LIST_PPREV_CIRC( edgeuse , &j_fus->eu->l );

	if( EDGESADJ( prev_eu , j_fus->eu ) )
	{
		nmg_keu( prev_eu );
		nmg_keu( j_fus->eu );
	}
	else
		bu_log( "nmg_fuse_inter_verts: ERROR: can't find adjacent edges to kill\n" );

	/* the other face for this edge is now j_fus->fu[1] */
	i_fus->fu[1] = j_fus->fu[1];

	/* if there are other faces along the edges that have been brought together
	 * do a radial join
	 */
	if( i_fus->fu[0] && j_fus->fu[1] )
	{
		if( rt_g.NMG_debug & DEBUG_BASIC )
		{
			bu_log( "radial join of eu's x%x and x%x\n" , i_fus->eu , radial_eu );
			bu_log( "\tx%x to x%x and x%x to x%x\n" ,
				i_fus->eu->vu_p->v_p, i_fus->eu->eumate_p->vu_p->v_p,
				radial_eu->vu_p->v_p, radial_eu->eumate_p->vu_p->v_p );
		}
		nmg_radial_join_eu( i_fus->eu , radial_eu , tol );
	}

	/* If this is a dangling edge, need to adjust the eu pointer */
	if( !i_fus->fu[0] )
		i_fus->eu = radial_eu;
	NMG_CK_EDGEUSE( i_fus->eu );

	/* if the deleted structure was for a dangling edge,
	 * then this edge is now dangling
	 */
	if( j_fus->free_edge )
		i_fus->free_edge = 1;

	bu_ptbl_rm( int_faces , (long *)j_fus );
	bu_free( (char *)j_fus , "nmg_split_edges_at_pts: j_fus " );

}

/*	N M G _ S P L I T _ E D G E S _ A T _ P T S
 *
 * Using the info in the table of intersect_fus structs,
 * split the edgeuse (eu) in each struct at the point (pt)
 * store the new vertices in the structure (vp) and assign
 * the geometry.
 *
 */
static void
nmg_split_edges_at_pts(const struct vertex *new_v, struct bu_ptbl *int_faces, const struct bn_tol *tol)
{
	int edge_no;

	if( rt_g.NMG_debug & DEBUG_BASIC )
		bu_log( "nmg_split_edges_at_pts( new_v = x%x , %d intersect_fus structs)\n" , new_v , BU_PTBL_END( int_faces ) );

	BN_CK_TOL( tol );
	BU_CK_PTBL( int_faces );
	NMG_CK_VERTEX( new_v );

	/* loop through all edges departing from new_v */
	for( edge_no=0 ; edge_no < BU_PTBL_END( int_faces ) ; edge_no++ )
	{
		struct intersect_fus *i_fus;
		struct edgeuse *new_eu;

		i_fus = (struct intersect_fus *)BU_PTBL_GET( int_faces , edge_no );

		/* skip edges between two loops of same face, for now */
		if( i_fus->fu[0] && i_fus->fu[1] && i_fus->fu[0]->f_p == i_fus->fu[1]->f_p )
			continue;

		if( bn_pt3_pt3_equal( new_v->vg_p->coord , i_fus->pt , tol ) )
		{
			/* if pt is within tolerance of new_v, don't split the edge */
			i_fus->vp = (struct vertex *)NULL;
			VMOVE( i_fus->pt , new_v->vg_p->coord );
			VMOVE( i_fus->start , new_v->vg_p->coord );
			VSUB2( i_fus->dir , i_fus->eu->eumate_p->vu_p->v_p->vg_p->coord , i_fus->eu->vu_p->v_p->vg_p->coord );
			VUNITIZE( i_fus->dir );
			continue;
		}
		new_eu = nmg_esplit( i_fus->vp , i_fus->eu, 0 );
		i_fus->vp = new_eu->vu_p->v_p;

		/* Need to keep track of correct eu in this case */
		if( i_fus->free_edge && !i_fus->fu[0] )
			i_fus->eu = new_eu;

		/* Assign geometry to the new vertex */
		if( i_fus && !i_fus->vp->vg_p )
			nmg_vertex_gv( i_fus->vp , i_fus->pt );
	}
	if( rt_g.NMG_debug & DEBUG_BASIC )
	{
		bu_log( "After splitting edges:\n" );
		nmg_pr_inter( new_v , int_faces );
	}

	/* Now take care of edges between two loops of same face */
	edge_no = 0;
	while( edge_no < BU_PTBL_END( int_faces ) )
	{
		int next_edge_no;
		struct intersect_fus *i_fus,*j_fus;

		next_edge_no = edge_no + 1;
		if( next_edge_no == BU_PTBL_END( int_faces ) )
			next_edge_no = 0;

		i_fus = (struct intersect_fus *)BU_PTBL_GET( int_faces , edge_no );
		j_fus = (struct intersect_fus *)BU_PTBL_GET( int_faces , next_edge_no );

		/* look at all edges in the same face as i_fus->fu[1] */
		while( j_fus->fu[0] && j_fus->fu[1] &&
		       j_fus->fu[0]->f_p == j_fus->fu[1]->f_p &&
		       j_fus != i_fus )
		{
			/* if both edges are dangling, there is nothing to do */
			if( i_fus->free_edge && j_fus->free_edge )
				break;

			/* if we haven't assigned a vertex, skip this edge */
			if( !i_fus->vp )
				break;

			/* split the neighbor at the first structure's "vp"
			 * this moves the neighboring edge's endpoint to
			 * fall on the first edge.
			 */
			(void) nmg_esplit( i_fus->vp , j_fus->eu, 0 );

			/* now we can ignore this edge */
			nmg_fuse_inters( i_fus , j_fus , int_faces , tol );

			/* go to the next edge */
			if( next_edge_no == BU_PTBL_END( int_faces ) )
				next_edge_no = 0;

			j_fus = (struct intersect_fus *)BU_PTBL_GET( int_faces , next_edge_no );

		}
		edge_no++;
	}
	if( rt_g.NMG_debug & DEBUG_BASIC )
	{
		bu_log( "After loops of same face\n" );
		nmg_pr_inter( new_v , int_faces );
	}
}

/*	N M G _ R E M O V E _ S H O R T _ E U S _ I N T E R
 *
 * kill all zero length edgeuses in faces around new_v
 *
 */
static void
nmg_remove_short_eus_inter(struct vertex *new_v, struct bu_ptbl *int_faces, const struct bn_tol *tol)
{
	int edge_no;
	struct vertexuse *vu;

	NMG_CK_VERTEX( new_v );
	BU_CK_PTBL( int_faces );
	BN_CK_TOL( tol );

	if( rt_g.NMG_debug & DEBUG_BASIC )
		bu_log( "nmg_remove_short_eus: new_v=x%x ( %f %f %f ), %d edges\n" , new_v, V3ARGS( new_v->vg_p->coord ), BU_PTBL_END( int_faces ) );

	/* first join any of the "vp" in the intersect_fus structs that are
	 * within tolerance of new-v
	 */
	for( edge_no=0 ; edge_no<BU_PTBL_END( int_faces ) ; edge_no++ )
	{
		struct intersect_fus *edge_fus;

		edge_fus = (struct intersect_fus *)BU_PTBL_GET( int_faces , edge_no );

		if( !edge_fus->vp )
			continue;

		if( !bn_pt3_pt3_equal( new_v->vg_p->coord , edge_fus->vp->vg_p->coord , tol ) )
			continue;

		nmg_jv( new_v , edge_fus->vp );
		edge_fus->vp = new_v;
	}

	/* look at all faces around new_v */
	vu = BU_LIST_FIRST( vertexuse , &new_v->vu_hd );
	while( BU_LIST_NOT_HEAD( vu , &new_v->vu_hd ) )
	{
		struct vertexuse *vu_next;
		struct faceuse *fu;
		struct loopuse *lu;
		struct faceuse *bad_fu=(struct faceuse *)NULL;
		int bad_loop=0;

		NMG_CK_VERTEXUSE( vu );

		vu_next = BU_LIST_PNEXT( vertexuse , &vu->l );

		if( *vu->up.magic_p != NMG_EDGEUSE_MAGIC )
		{
			vu = vu_next;
			continue;
		}

		fu = nmg_find_fu_of_vu( vu );
		NMG_CK_FACEUSE( fu );

		/* look at all loops in these faces */
		lu = BU_LIST_FIRST( loopuse , &fu->lu_hd );
		while( BU_LIST_NOT_HEAD( lu , &fu->lu_hd ) )
		{
			struct loopuse *lu_next;
			struct edgeuse *eu;

			NMG_CK_LOOPUSE( lu );

			lu_next = BU_LIST_PNEXT( loopuse , &lu->l );

			eu = BU_LIST_FIRST( edgeuse , &lu->down_hd );
			while( BU_LIST_NOT_HEAD( eu , &lu->down_hd ) )
			{
				struct edgeuse *eu_next;

				NMG_CK_EDGEUSE( eu );

				eu_next = BU_LIST_PNEXT( edgeuse , &eu->l );

				/* kill edges that are to/from same vertex */
				if( eu->vu_p->v_p == eu->eumate_p->vu_p->v_p )
				{
					while( (vu_next == eu->vu_p || vu_next == eu->eumate_p->vu_p ) &&
						BU_LIST_NOT_HEAD( vu_next , &new_v->vu_hd ) )
							vu_next = BU_LIST_PNEXT( vertexuse , &vu_next->l );
					while( (eu_next == eu || eu_next == eu->eumate_p) &&
						BU_LIST_NOT_HEAD( eu_next , &lu->down_hd ) )
							eu_next = BU_LIST_PNEXT( edgeuse , &eu_next->l );

					if( rt_g.NMG_debug & DEBUG_BASIC )
						bu_log( "\tkilling eu x%x (x%x)\n" , eu , eu->eumate_p );

					bad_loop = nmg_keu( eu );
				}
				/* kill edges with length less than tol->dist */
				else if( bn_pt3_pt3_equal( eu->vu_p->v_p->vg_p->coord , eu->eumate_p->vu_p->v_p->vg_p->coord , tol ) )
				{
					struct edgeuse *prev_eu;

					prev_eu = BU_LIST_PPREV_CIRC( edgeuse , &eu->l );
					NMG_CK_EDGEUSE( prev_eu );

					prev_eu->eumate_p->vu_p->v_p = eu->eumate_p->vu_p->v_p;

					while( (vu_next == eu->vu_p || vu_next == eu->eumate_p->vu_p ) &&
						BU_LIST_NOT_HEAD( vu_next , &new_v->vu_hd ) )
							vu_next = BU_LIST_PNEXT( vertexuse , &vu_next->l );
					while( (eu_next == eu || eu_next == eu->eumate_p) &&
						BU_LIST_NOT_HEAD( eu_next , &lu->down_hd ) )
							eu_next = BU_LIST_PNEXT( edgeuse , &eu_next->l );

					if( rt_g.NMG_debug & DEBUG_BASIC )
						bu_log( "\tkilling eu x%x (x%x)\n" , eu , eu->eumate_p );

					bad_loop = nmg_keu( eu );
				}

				if( bad_loop )
				{
					/* emptied a loop, so kill it */
					while( (lu_next == lu || lu_next == lu->lumate_p) &&
						BU_LIST_NOT_HEAD( lu_next , &fu->lu_hd ) )
							lu_next = BU_LIST_PNEXT( loopuse , &lu_next->l );

					bad_fu = nmg_find_fu_of_lu( lu );
					if( !nmg_klu( lu ) )
						bad_fu = (struct faceuse *)NULL;

					break;
				}

				eu = eu_next;
			}
			if( bad_fu )
			{
				/* emptied a faceuse, so kill it */
				if( nmg_kfu( bad_fu ) )
				{
					/* I can't believe I emptied the whole thing!! */
					bu_log( "nmg_remove_short_eus_inter: nmg_kfu emptied shell!!!\n" );
					break;
				}
			}
			lu = lu_next;
		}

		vu = vu_next;
	}
}

/*	N M G _ S I M P L I F Y _ I N T E R
 *
 * Eliminates adjacent intersect_fus structs with collinear edges
 *
 */
static void
nmg_simplify_inter(const struct vertex *new_v, struct bu_ptbl *int_faces, const struct bn_tol *tol)
{
	int edge_no=0;
	int next_edge_no;

	if( rt_g.NMG_debug & DEBUG_BASIC )
		bu_log( "nmg_simplify_inter( new_v=x%x ( %f %f %f ), int_faces=x%x)\n",
			new_v, V3ARGS( new_v->vg_p->coord ) , int_faces );

	NMG_CK_VERTEX( new_v );
	BU_CK_PTBL( int_faces );
	BN_CK_TOL( tol );

	while( BU_PTBL_END( int_faces ) > 1 && edge_no < BU_PTBL_END( int_faces ) )
	{
		struct intersect_fus *i_fus;
		struct intersect_fus *j_fus;

		/* get two consectutive structures */
		i_fus = (struct intersect_fus *)BU_PTBL_GET( int_faces , edge_no );
		next_edge_no = edge_no+1;
		if( next_edge_no == BU_PTBL_END( int_faces ) )
			 next_edge_no = 0;
		j_fus = (struct intersect_fus *)BU_PTBL_GET( int_faces , next_edge_no );

		/* skip open space */
		if( (i_fus->free_edge || j_fus->free_edge) && next_edge_no == 0 )
		{
			edge_no++;
			continue;
		}

		/* Don't fuse free edges together */
		if( i_fus->free_edge && j_fus->free_edge )
		{
			edge_no++;
			continue;
		}

		/* if either vertex or edgeuse is null, skip */
		if( i_fus->vp == NULL || j_fus->vp == NULL ||
		    i_fus->eu == NULL || j_fus->eu == NULL )
		{
			edge_no++;
			continue;
		}

		/* If either vertex is new_v, skip */
		if( i_fus->vp == new_v || j_fus->vp == new_v )
		{
			edge_no++;
			continue;
		}

		NMG_CK_VERTEX( i_fus->vp );
		NMG_CK_VERTEX( j_fus->vp );
		NMG_CK_EDGEUSE( i_fus->eu );
		NMG_CK_EDGEUSE( j_fus->eu );

		/* if the two vertices are within tolerance,
		 * fuse them
		 */
		if( i_fus->vp == j_fus->vp )
		{
			nmg_fuse_inters( i_fus , j_fus , int_faces , tol );
			continue;
		}
		else if( bn_pt3_pt3_equal( i_fus->vp->vg_p->coord , j_fus->vp->vg_p->coord , tol ) )
		{
			nmg_jv( i_fus->vp , j_fus->vp );
			nmg_fuse_inters( i_fus , j_fus , int_faces , tol );
			continue;
		}
		else if( bn_3pts_collinear( i_fus->vp->vg_p->coord , j_fus->vp->vg_p->coord , new_v->vg_p->coord , tol ) )
		{
			fastf_t i_dist,j_dist;
			vect_t i_dist_to_new_v,j_dist_to_new_v;

			/* all three points are collinear,
			 * may need to split edges
			 */

			VSUB2( i_dist_to_new_v , new_v->vg_p->coord , i_fus->vp->vg_p->coord );
			VSUB2( j_dist_to_new_v , new_v->vg_p->coord , j_fus->vp->vg_p->coord );

			if( VDOT( i_dist_to_new_v , j_dist_to_new_v ) < 0.0 )
			{
				/* points are collinear with new_v, but in opoosit directions */
				edge_no++;
				continue;
			}

			i_dist = MAGSQ( i_dist_to_new_v );
			j_dist = MAGSQ( j_dist_to_new_v );

			if( i_dist < tol->dist_sq || j_dist < tol->dist_sq )
				rt_bomb( "nmg_simplify_inter: vertex within tolerance of new_v\n" );

			if( rt_g.NMG_debug & DEBUG_BASIC )
				bu_log( "\tCollinear vertices x%x, x%x, and x%x\n",
						new_v , i_fus->vp , j_fus->vp );

			if( i_dist > j_dist && j_dist > tol->dist_sq )
			{
				/* j point is closer to new_v than i point
				 * split edge at j point
				 */

				if( rt_g.NMG_debug & DEBUG_BASIC )
					bu_log( "\tSplitting i_fus->eu x%x at vertex x%x\n" , i_fus->eu , j_fus->vp );

				(void)nmg_esplit( j_fus->vp , i_fus->eu, 0 );
				i_fus->vp = j_fus->vp;
				nmg_fuse_inters( i_fus , j_fus , int_faces , tol );

				continue;
			}
			else if( j_dist > i_dist && i_dist > tol->dist_sq )
			{
				/* i point is closer to new_v than j point
				 * split edge at i point
				 */

				if( rt_g.NMG_debug & DEBUG_BASIC )
					bu_log( "\tSplitting j_fus->eu x%x at vertex x%x\n" , j_fus->eu , i_fus->vp );

				(void)nmg_esplit( i_fus->vp , j_fus->eu, 0 );
				nmg_fuse_inters( i_fus , j_fus , int_faces , tol );
				continue;
			}
		}
		edge_no++;
	}
	if( rt_g.NMG_debug & DEBUG_BASIC )
	{
		bu_log( "\nAfter nmg_simplify_inter:\n" );
		nmg_pr_inter( new_v , int_faces );
	}
}

/*	N M G _ M A K E _ F A C E S _ A T _ V E R T
 *
 * Make new faces around vertex new_v using info in
 * the table of intersect_fu structures. Each structure
 * contains a vertex on an edge departing new_v.
 * Vertices from two consecutive edges are combined with
 * new_v to form triangular faces around new_v
 *
 */
void
nmg_make_faces_at_vert(struct vertex *new_v, struct bu_ptbl *int_faces, const struct bn_tol *tol)
{
	struct loopuse *old_lu;
	int edge_no=0,next_edge_no;

	if( rt_g.NMG_debug & DEBUG_BASIC )
		bu_log( "nmg_make_faces_at_vert( x%x , %d intersect_fus structs)\n" , new_v , BU_PTBL_END( int_faces ) );

	NMG_CK_VERTEX( new_v );
	BU_CK_PTBL( int_faces );
	BN_CK_TOL( tol );

	if( BU_PTBL_END( int_faces ) == 1 )
	{
		struct intersect_fus *i_fus;

		/* only one intersect point is left, move new_v to it
		 * and don't make any faces
		 */
		i_fus = (struct intersect_fus *)BU_PTBL_GET( int_faces , 0 );
		if( i_fus->vp )
		{
			i_fus = (struct intersect_fus *)BU_PTBL_GET( int_faces , 0 );

			VMOVE( new_v->vg_p->coord , i_fus->vp->vg_p->coord );
			nmg_jv( new_v , i_fus->vp );
		}
		return;
	}

	if( BU_PTBL_END( int_faces ) == 2 )
	{
		struct intersect_fus *i_fus,*j_fus;
		point_t center_pt;

		/* only two intersect points left, if they are not on free edges,
		 *  move new_v to the center of the connecting line. No new faces needed
		 */
		i_fus = (struct intersect_fus *)BU_PTBL_GET( int_faces , 0 );
		j_fus = (struct intersect_fus *)BU_PTBL_GET( int_faces , 1 );

		if( i_fus->vp && j_fus->vp && !i_fus->free_edge && !j_fus->free_edge )
		{
			VCOMB2( center_pt , 0.5 , i_fus->vp->vg_p->coord , 0.5 , j_fus->vp->vg_p->coord );
			VMOVE( new_v->vg_p->coord , center_pt );
		}
		return;
	}

	/* Need to make new faces.
	 * loop around the vertex, looking at
	 * pairs of adjacent edges and deciding
	 * if a new face needs to be constructed
	 * from the two intersect vertices and new_v
	 */
	while( edge_no < BU_PTBL_END( int_faces ) )
	{
		struct intersect_fus *i_fus;
		struct intersect_fus *j_fus;
		struct vertexuse *vu1,*vu2;
		struct edgeuse *eu;
		struct loopuse *lu;
		struct loopuse *new_lu;
		struct faceuse *new_fu;
		struct faceuse *fu;

		/* get two consectutive structures */
		i_fus = (struct intersect_fus *)BU_PTBL_GET( int_faces , edge_no );
		next_edge_no = edge_no+1;
		if( next_edge_no == BU_PTBL_END( int_faces ) )
			 next_edge_no = 0;
		j_fus = (struct intersect_fus *)BU_PTBL_GET( int_faces , next_edge_no );

		/* Don't construct a new face across open space */
		if( (i_fus->free_edge || j_fus->free_edge) && next_edge_no == 0 )
		{
			edge_no++;
			continue;
		}

		/* if the two vertices are the same, no face needed */
		if( i_fus->vp == j_fus->vp )
		{
			edge_no++;
			continue;
		}

		/* if either vertex is null, no face needed */
		if( i_fus->vp == NULL || j_fus->vp == NULL || i_fus->eu == NULL || j_fus->eu == NULL )
		{
			edge_no++;
			continue;
		}

		/* Don't make faces with two vertices the same */
		if( i_fus->vp == new_v || j_fus->vp == new_v )
		{
			edge_no++;
			continue;
		}

		NMG_CK_VERTEX( i_fus->vp );
		NMG_CK_VERTEX( j_fus->vp );
		NMG_CK_EDGEUSE( i_fus->eu );
		NMG_CK_EDGEUSE( j_fus->eu );

		/* don't make degenerate faces */
		if( bn_3pts_collinear( i_fus->vp->vg_p->coord , j_fus->vp->vg_p->coord , new_v->vg_p->coord , tol ) )
		{
			edge_no++;
			continue;
		}

		/* O.K., here is where we actually start making faces.
		 * Find uses of the two vertices in the same loopuse
		 */
		old_lu = j_fus->eu->up.lu_p;
		vu1 = (struct vertexuse *)NULL;
		vu2 = (struct vertexuse *)NULL;
		for( BU_LIST_FOR( eu , edgeuse , &old_lu->down_hd ) )
		{
			if( eu->vu_p->v_p == i_fus->vp )
				vu1 = eu->vu_p;
			else if( eu->vu_p->v_p == j_fus->vp )
				vu2 = eu->vu_p;
		}

		if( vu1 == NULL || vu2 == NULL )
		{
			bu_log( "nmg_make_faces_at_vert: ERROR: Can't find loop containing vertices x%x and x%x\n" , i_fus->vp, j_fus->vp );
			bu_log( "\t( %f %f %f ) and ( %f %f %f )\n" , V3ARGS( i_fus->vp->vg_p->coord ) , V3ARGS( j_fus->vp->vg_p->coord ) );
			edge_no++;
			continue;
		}

		/* make sure the two vertices have a third between,
		 * otherwise, don't cut the loop
		 */
		eu = vu1->up.eu_p;
		if( eu->eumate_p->vu_p == vu2 )
		{
			edge_no++;
			continue;
		}
		eu = vu2->up.eu_p;
		if( eu->eumate_p->vu_p == vu1 )
		{
			edge_no++;
			continue;
		}

		/* cut the face loop across the two vertices */
		new_lu = nmg_cut_loop( vu1 , vu2 );

		/* Fix orientations.
		 * We will never be cutting an OT_OPPOSITE loop
		 * so the will always be OT_SAME
		 */
		new_lu->orientation = OT_SAME;
		new_lu->lumate_p->orientation = OT_SAME;
		old_lu->orientation = OT_SAME;
		old_lu->lumate_p->orientation = OT_SAME;

		/* find which loopuse contains new_v
		 * this will be the one to become a new face
		 */
		lu = NULL;

		/* first check old_lu */
		for( BU_LIST_FOR( eu , edgeuse , &old_lu->down_hd ) )
		{
			if( eu->vu_p->v_p == new_v )
			{
				lu = old_lu;
				break;
			}
		}

		/* if not found check new_lu */
		if( lu == NULL )
		{
			for( BU_LIST_FOR( eu , edgeuse , &new_lu->down_hd ) )
			{
				if( eu->vu_p->v_p == new_v )
				{
					lu = old_lu;
					break;
				}
			}
		}

		if( lu == NULL )
		{
			fu = old_lu->up.fu_p;
			bu_log( "nmg_make_faces_at_vert: can't find loop for new face\n" );
			bu_log( "vu1 = x%x (x%x) vu2 = x%x (x%x)\n" , vu1 , vu1->v_p , vu2 , vu2->v_p );
			bu_log( "new_v = x%x\n" , new_v );
			bu_log( "old_lu = x%x , new_lu = x%x\n" , old_lu , new_lu );
			nmg_pr_fu_briefly( fu , (char *)NULL );
			rt_bomb( "nmg_make_faces_at_vert: can't find loop for new face\n" );
		}

		/* make the new face from the new loop */
		new_fu = nmg_mk_new_face_from_loop( lu );

		/* update the intersect_fus structs (probably not necessary at this point) */
		j_fus->fu[0] = new_fu;
		i_fus->fu[1] = new_fu;

		NMG_CK_FACEUSE( new_fu );

		/* calculate a plane equation for the new face */
		if( nmg_calc_face_g( new_fu ) )
		{
			bu_log( "nmg_make_faces_at_vert: Failed to calculate plane eqn for face:\n " );
			bu_log( "\tnew_v is x%x at ( %f %f %f )\n" , new_v , V3ARGS( new_v->vg_p->coord ) );
			if( bn_3pts_collinear( new_v->vg_p->coord,
			    vu1->v_p->vg_p->coord, vu2->v_p->vg_p->coord,
			    tol ) )
				bu_log( "\tPoints are collinear\n" );
			nmg_pr_fu_briefly( new_fu , " " );
		}
		nmg_face_bb( new_fu->f_p , tol );

		edge_no++;
	}
}

/*	N M G _ K I L L _ C R A C K S _ A T _ V E R T E X
 *
 * Look at all faces around vertex new_v and kill any two
 * consecutive eu's that go from a vertex to a second then back
 * to the original vertex
 */
void
nmg_kill_cracks_at_vertex(const struct vertex *vp)
{
	struct bu_ptbl fus_at_vert;
	struct vertexuse *vu;
	struct faceuse *fu;
	int fu_no;

	if( rt_g.NMG_debug & DEBUG_BASIC )
		bu_log( "nmg_kill_cracks_at_vertex( vp=x%x )\n" , vp );

	NMG_CK_VERTEX( vp );

	/* first make a list of all the faceuses at this vertex */
	bu_ptbl_init( &fus_at_vert , 64, " &fus_at_vert ");

	for( BU_LIST_FOR( vu , vertexuse , &vp->vu_hd ) )
	{
		NMG_CK_VERTEXUSE( vu );

		fu = nmg_find_fu_of_vu( vu );
		if( !fu )
			continue;

		NMG_CK_FACEUSE( fu );
		bu_ptbl_ins_unique( &fus_at_vert , (long *)fu );
	}

	/* Now look at these faceuses for cracks ( jaunts from a vertex and back to the same ) */
	for( fu_no=0 ; fu_no<BU_PTBL_END( &fus_at_vert ) ; fu_no++ )
	{
		struct loopuse *lu;
		int bad_face=0;

		fu = (struct faceuse *)BU_PTBL_GET( &fus_at_vert , fu_no );
		NMG_CK_FACEUSE( fu );

		lu = BU_LIST_FIRST( loopuse , &fu->lu_hd );
		while( BU_LIST_NOT_HEAD( lu , &fu->lu_hd ) )
		{
			struct loopuse *lu_next;
			struct edgeuse *eu;
			int bad_loop=0;

			NMG_CK_LOOPUSE( lu );

			lu_next = BU_LIST_NEXT( loopuse , &lu->l );

			if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
			{
				lu = lu_next;
				continue;
			}

			eu = BU_LIST_FIRST( edgeuse , &lu->down_hd );
			while( BU_LIST_NOT_HEAD( eu , &lu->down_hd ) )
			{
				struct edgeuse *eu_prev;
				struct edgeuse *eu_next;

				NMG_CK_EDGEUSE( eu );

				eu_next = BU_LIST_NEXT( edgeuse , &eu->l );
				eu_prev = BU_LIST_PPREV_CIRC( edgeuse , &eu->l );
				NMG_CK_EDGEUSE( eu_prev );

				/* Check for a crack */
				if( EDGESADJ( eu , eu_prev ) )
				{
					/* found a crack, kill it */
					if( nmg_keu( eu ) )
					{
						/* This should never happen */
						bu_log( "ERROR: nmg_kill_cracks_at_vert: bad loopuse x%x\n" , lu );
						bad_loop = 1;
						break;
					}
					if( nmg_keu( eu_prev ) )
					{
						bad_loop = 1;
						break;
					}
				}
				eu = eu_next;
			}
			if( bad_loop )
			{
				if( nmg_klu( lu ) )
				{
					bad_face = 1;
					break;
				}
			}
			lu = lu_next;
		}
		if( bad_face )
		{
			if( nmg_kfu( fu ) )
				bu_log( "ERROR:nmg_kill_cracks_at_vert: bad shell!!!\n" );
		}
	}
	bu_ptbl_free( &fus_at_vert );
}

/*	N M G _ D I S T _ T O _ C R O S S
 *
 * Used by nmg_fix_crossed edges to calculate the point
 * where two edges cross
 *
 *	returns:
 *		distance to intersection if edge intersect
 *		-1.0 if they don't
 */
static fastf_t
nmg_dist_to_cross(const struct intersect_fus *i_fus, const struct intersect_fus *j_fus, fastf_t *new_pt, const struct bn_tol *tol)
{
	plane_t pl;
	struct edgeuse *i_next_eu,*j_next_eu;
	struct vertex *i_end,*j_end;
	struct vertex *i_start,*j_start;
	point_t i_end_pt,j_end_pt;
	vect_t i_dir,j_dir;
	fastf_t dist[2];

	BN_CK_TOL( tol );

	if( i_fus->fu[1] )
		NMG_GET_FU_PLANE( pl , i_fus->fu[1] )

	/* get edgeuses leaving from new vertices */
	if( !i_fus->fu[0] )
		i_next_eu = BU_LIST_PPREV_CIRC( edgeuse , &i_fus->eu->l );
	else
		i_next_eu = BU_LIST_PNEXT_CIRC( edgeuse , &i_fus->eu->l );

	if( !j_fus->fu[0] )
		j_next_eu = BU_LIST_PPREV_CIRC( edgeuse , &j_fus->eu->l );
	else
		j_next_eu = BU_LIST_PNEXT_CIRC( edgeuse , &j_fus->eu->l );

	NMG_CK_EDGEUSE( i_next_eu );
	NMG_CK_EDGEUSE( j_next_eu );

	/* get endpoints for these edges */
	i_end = i_next_eu->eumate_p->vu_p->v_p;
	j_end = j_next_eu->eumate_p->vu_p->v_p;

	NMG_CK_VERTEX( i_end );
	NMG_CK_VERTEX( j_end );

	/* since the other end of these edges may not have been adjusted yet
	 * project the endpoints onto the face plane
	 */
	if( i_fus->fu[1] )
	{
		VJOIN1( i_end_pt , i_end->vg_p->coord , -(DIST_PT_PLANE( i_end->vg_p->coord , pl )) , pl )
		VJOIN1( j_end_pt , j_end->vg_p->coord , -(DIST_PT_PLANE( j_end->vg_p->coord , pl )) , pl )
	}
	else
	{
		VMOVE( i_end_pt , i_end->vg_p->coord )
		VMOVE( j_end_pt , j_end->vg_p->coord )
	}

	/* get start points, guaranteed to be on plane */
	i_start =  i_next_eu->vu_p->v_p;
	j_start =  j_next_eu->vu_p->v_p;

	NMG_CK_VERTEX( i_start );
	NMG_CK_VERTEX( j_start );

	/* calculate direction vectors for use by bn_isect_lseg3_lseg3 */
	VSUB2( i_dir , i_end_pt , i_start->vg_p->coord );
	VSUB2( j_dir , j_end_pt , j_start->vg_p->coord );

	if( rt_g.NMG_debug & DEBUG_BASIC )
	{
		bu_log( "nmg_dist_to_cross: checking edges x%x and x%x:\n" , i_fus , j_fus );
		bu_log( "\t( %f %f %f ) <-> ( %f %f %f )\n", V3ARGS( i_start->vg_p->coord ), V3ARGS( i_end_pt ) );
		bu_log( "\t( %f %f %f ) <-> ( %f %f %f )\n", V3ARGS( j_start->vg_p->coord ), V3ARGS( j_end_pt ) );
	}

	if( i_fus->free_edge && j_fus->free_edge )
	{
		fastf_t max_dist0;
		fastf_t max_dist1;
		int ret_val;

		if( rt_g.NMG_debug & DEBUG_BASIC )
			bu_log( "\tBoth are free edges\n" );

		max_dist0 = MAGNITUDE( i_dir );
		VSCALE( i_dir , i_dir , (1.0/max_dist0) )
		max_dist1 = MAGNITUDE( j_dir );
		VSCALE( j_dir , j_dir , (1.0/max_dist1) )

		/* check if these two edges intersect or pass near each other */
		if( (ret_val=rt_dist_line3_line3( dist , i_start->vg_p->coord , i_dir ,
			j_start->vg_p->coord , j_dir , tol )) >= 0 )
		{
			if( rt_g.NMG_debug & DEBUG_BASIC )
			{
				bu_log( "max_dists = %f , %f\n" , max_dist0,max_dist1 );
				bu_log( "dist = %f , %f\n" , dist[0] , dist[1] );
			}

			/* if the closest approach or intersect point is
			 * within the edge endpoints, this is a real intersection
			 */
			if( dist[0] >= 0.0 && dist[0] <= max_dist0 &&
			    dist[1] >= 0.0 && dist[1] <= max_dist1 )
			{
				plane_t pl1,pl2,pl3;

				if( rt_g.NMG_debug & DEBUG_BASIC )
				{
					point_t tmp_pt;

					bu_log( "\t\tintersection!!\n" );
					VJOIN1( tmp_pt , i_start->vg_p->coord , dist[0] , i_dir );
					bu_log( "\t\t\t( %f %f %f )\n" , V3ARGS( tmp_pt ) );
					VJOIN1( tmp_pt , j_start->vg_p->coord , dist[1] , j_dir );
					bu_log( "\t\t\t( %f %f %f )\n" , V3ARGS( tmp_pt ) );
				}

				/* calculate the intersect point */
				NMG_GET_FU_PLANE( pl1 , j_fus->fu[1] );
				NMG_GET_FU_PLANE( pl2 , i_fus->fu[0] );
				VCROSS( pl3 , pl1 , pl2 );
				pl3[3] = VDOT( pl3 , i_fus->vp->vg_p->coord );
				bn_mkpoint_3planes( new_pt , pl1 , pl2 , pl3 );

				return( dist[0] );
			}
			else
				return( (fastf_t)(-1.0) );
		}
		else
		{
			if( rt_g.NMG_debug & DEBUG_BASIC )
				bu_log( "ret_val = %d\n" , ret_val );

			return( (fastf_t)(-1.0) );
		}
	}
	else
	{
		/* check if these two edges intersect */
		if( bn_isect_lseg3_lseg3( dist , i_start->vg_p->coord , i_dir ,
			j_start->vg_p->coord , j_dir , tol ) == 1 )
		{
			fastf_t len0;

			len0 = MAGNITUDE( i_dir );

			/* calculate intersection point */
			if( dist[0] == 0.0 )
				VMOVE( new_pt , i_start->vg_p->coord )
			else if( dist[0] == 1.0 )
				VMOVE( new_pt , i_end_pt )
			else if( dist[1] == 0.0 )
				VMOVE( new_pt , j_start->vg_p->coord )
			else if( dist[1] == 1.0 )
				VMOVE( new_pt , j_end_pt )
			else
				VJOIN1( new_pt , i_start->vg_p->coord , dist[0] , i_dir )

			if( rt_g.NMG_debug & DEBUG_BASIC )
				bu_log( "\tdist=%f, new_pt=( %f %f %f )\n" , dist[0] , V3ARGS( new_pt ) );

			return( dist[0]*len0 );
		}
		else
			return( (fastf_t)(-1.0) );
	}
}

/*	N M G _ F I X _ C R O S S E D _ L O O P S
 *
 * Detect situations where edges have been split, but new vertices are
 * in wrong order. This typically happens as shown:
 *
 *                  new face planes
 *                  |
 *                  |
 *   \       \   /  |    /
 *    \       \ /<--|   /
 *     \       X       /
 *      \     / \     /
 *       \   /___\   /
 *        \         /
 *         \       /<- original face planes
 *          \     /
 *           \___/
 *
 * This can be detected by checking if the edges leaving from the new
 * vertices cross. If so, the middle face is deleted and the
 * two vertices are fused.
 *
 */
static void
nmg_fix_crossed_loops(struct vertex *new_v, struct bu_ptbl *int_faces, const struct bn_tol *tol)
{
	int edge_no;

	if( rt_g.NMG_debug & DEBUG_BASIC )
		bu_log( "nmg_fix_crossed_loops( new_v=x%x ( %f %f %f ), %d edges)\n", new_v , V3ARGS( new_v->vg_p->coord ) , BU_PTBL_END( int_faces ) );

	NMG_CK_VERTEX( new_v );
	BU_CK_PTBL( int_faces );
	BN_CK_TOL( tol );

	/* first check for edges that cross both adjacent edges */
	if( BU_PTBL_END( int_faces ) > 2 )
	{
		for( edge_no=0 ; edge_no<BU_PTBL_END( int_faces ) ; edge_no++ )
		{
			int next_edge_no,prev_edge_no;
			struct intersect_fus *edge_fus;
			struct intersect_fus *next_fus,*prev_fus;
			fastf_t dist1,dist2;
			point_t pt1,pt2;

			edge_fus = (struct intersect_fus *)BU_PTBL_GET( int_faces , edge_no );

			if( !edge_fus->vp )
				continue;

			/* look at next edge */
			next_edge_no = edge_no + 1;
			if( next_edge_no == BU_PTBL_END( int_faces ) )
				next_edge_no = 0;

			next_fus = (struct intersect_fus *)BU_PTBL_GET( int_faces , next_edge_no );

			/* Don't want to fuse two dangling edges */
			if( next_fus->vp && (!edge_fus->free_edge || !next_fus->free_edge) )
				dist1 = nmg_dist_to_cross( edge_fus , next_fus , pt1 , tol );
			else
				dist1 = (-1.0);

			/* look at previous edge */
			prev_edge_no = edge_no - 1;
			if( prev_edge_no < 0 )
				prev_edge_no = BU_PTBL_END( int_faces ) - 1;

			prev_fus = (struct intersect_fus *)BU_PTBL_GET( int_faces , prev_edge_no );

			/* Don't want to fuse two dangling edges */
			if( prev_fus->vp && (!edge_fus->free_edge || !prev_fus->free_edge) )
				dist2 = nmg_dist_to_cross( edge_fus , prev_fus , pt2 , tol );
			else
				dist2 = (-1.0);

			/* if no intersections, continue */
			if( dist1 < tol->dist || dist2 < tol->dist )
				continue;

			if( rt_g.NMG_debug & DEBUG_BASIC )
			{
				bu_log( "fus=x%x, prev=x%x, next=x%x, dist1=%f, dist2=%f\n",
					edge_fus,next_fus,prev_fus,dist1,dist2 );
				bu_log( "\t( %f %f %f ), ( %f %f %f )\n" , V3ARGS( pt1 ) , V3ARGS( pt2 ) );
			}

			/* if both intersections are at the same point, merge all three */
			if( bn_pt3_pt3_equal( pt1 , pt2 , tol ) )
			{
				if( rt_g.NMG_debug & DEBUG_BASIC )
					bu_log( "\tMerging all three points to pt1\n" );

				VMOVE( edge_fus->vp->vg_p->coord , pt1 );
				VMOVE( edge_fus->pt , pt1 );
				VMOVE( next_fus->vp->vg_p->coord , pt1 );
				VMOVE( next_fus->pt , pt1 );
				VMOVE( prev_fus->vp->vg_p->coord , pt1 );
				VMOVE( prev_fus->pt , pt1 );
			}
			else if( dist1 > dist2 )
			{
				/* merge edge point with next edge point */
				if( rt_g.NMG_debug & DEBUG_BASIC )
					bu_log( "\tMerging edge and next to pt1, moving prev to pt2\n");
				VMOVE( edge_fus->vp->vg_p->coord , pt1 );
				VMOVE( edge_fus->pt , pt1 );
				VMOVE( next_fus->vp->vg_p->coord , pt1 );
				VMOVE( next_fus->pt , pt1 );

				VMOVE( prev_fus->vp->vg_p->coord , pt2 );
				VMOVE( prev_fus->pt , pt2 );
			}
			else
			{
				/* merge edge point with previous point */
				if( rt_g.NMG_debug & DEBUG_BASIC )
					bu_log( "\tMerging edge and prev to pt2, moving next to pt1\n" );
				VMOVE( edge_fus->vp->vg_p->coord , pt2 );
				VMOVE( edge_fus->pt , pt2 );
				VMOVE( prev_fus->vp->vg_p->coord , pt2 );
				VMOVE( prev_fus->pt , pt2 );

				VMOVE( next_fus->vp->vg_p->coord , pt1 );
				VMOVE( next_fus->pt , pt1 );
			}
		}
	}

	if( rt_g.NMG_debug & DEBUG_BASIC )
	{
		bu_log( "After fixing edges that intersect two edges:\n" );
		nmg_pr_inter( new_v , int_faces );
	}

	/* now look for edges that cross just a single adjacent edge */
	for( edge_no=0 ; edge_no<BU_PTBL_END( int_faces ) ; edge_no++ )
	{
		int next_edge_no;
		struct intersect_fus *edge_fus;
		struct intersect_fus *next_fus;
		point_t pt;
		fastf_t dist;

		edge_fus = (struct intersect_fus *)BU_PTBL_GET( int_faces , edge_no );

		if( !edge_fus->vp )
			continue;

		/* just look at next edge */
		next_edge_no = edge_no + 1;
		if( next_edge_no == BU_PTBL_END( int_faces ) )
			next_edge_no = 0;

		next_fus = (struct intersect_fus *)BU_PTBL_GET( int_faces , next_edge_no );

		if( !next_fus->vp )
			continue;

		/* check for intersection */
		dist = nmg_dist_to_cross( edge_fus , next_fus , pt , tol );

		if( dist > tol->dist )
		{
			/* there is an intersection */
			if( rt_g.NMG_debug & DEBUG_BASIC )
			{
				bu_log( "edge x%x intersect next edge x%x\n" , edge_fus , next_fus );
				bu_log( "\tdist=%f, ( %f %f %f )\n" , dist , V3ARGS( pt ) );
			}
			if( edge_fus->free_edge && next_fus->free_edge )
			{
				/* if both edges are free edges, move new_v to the intersection */
				VMOVE( edge_fus->vp->vg_p->coord , pt );
				VMOVE( edge_fus->pt , pt );
				VMOVE( next_fus->vp->vg_p->coord , pt );
				VMOVE( next_fus->pt , pt );
				VMOVE( new_v->vg_p->coord , pt );
			}
			else
			{
				/* just merge the two points */
				VMOVE( edge_fus->vp->vg_p->coord , pt );
				VMOVE( edge_fus->pt , pt );
				VMOVE( next_fus->vp->vg_p->coord , pt );
				VMOVE( next_fus->pt , pt );
			}
		}
	}
	if( rt_g.NMG_debug & DEBUG_BASIC )
	{
		bu_log( "After nmg_fix_crossed_loops:\n" );
		nmg_pr_inter( new_v , int_faces );
	}
}

/*	N M G _ C A L C _ N E W _ V
 *
 * Calculates a new geometry for new_v
 */
static int
nmg_calc_new_v(struct vertex *new_v, const struct bu_ptbl *int_faces, const struct bn_tol *tol)
{
	plane_t *planes;
	int pl_count;
	int i;

	NMG_CK_VERTEX( new_v );
	BU_CK_PTBL( int_faces );
	BN_CK_TOL( tol );

	if( rt_g.NMG_debug & DEBUG_BASIC )
		bu_log( "nmg_calc_new_v: (%f %f %f) , %d faces\n" , V3ARGS( new_v->vg_p->coord ) , BU_PTBL_END( int_faces ) );

	/* make space for at least three planes */
	i = BU_PTBL_END( int_faces );
	if( i < 3 )
		i = 3;
	planes = (plane_t *)bu_calloc( i , sizeof( plane_t ) , "nmg_calc_new_v: planes" );

	pl_count = 0;

	for( i=0 ; i<BU_PTBL_END( int_faces ) ; i++ )
	{
		struct intersect_fus *fus;
		plane_t pl;
		int j;
		int unique=1;

		fus = (struct intersect_fus *)BU_PTBL_GET( int_faces , i );

		if( !fus->fu[0] )
			continue;

		NMG_CK_FACEUSE( fus->fu[0] );
		NMG_GET_FU_PLANE( pl , fus->fu[0] );

		for( j=0 ; j<pl_count ; j++ )
		{
			if( bn_coplanar( planes[j] , pl , tol ) > 0 )
			{
				unique = 0;
				break;
			}
		}

		if( !unique )
			continue;

		VMOVE( planes[pl_count] , pl );
		planes[pl_count][H] = pl[H];
		pl_count++;
	}

	if( pl_count > 2 )
	{
		if( bn_isect_planes( new_v->vg_p->coord , (const plane_t *)planes , pl_count ) )
		{
			bu_log( "nmg_cacl_new_v: Cannot solve for new geometry at ( %f %f %f )\n",
				V3ARGS( new_v->vg_p->coord ) );
			bu_free( (char *)planes , "nmg_calc_new_v: planes" );
			return( 1 );
		}
	}
	else if( pl_count == 1 )
	{
		fastf_t vert_move_len;

		/* move the vertex to the plane */
		vert_move_len = DIST_PT_PLANE( new_v->vg_p->coord , planes[0] );
		VJOIN1( new_v->vg_p->coord , new_v->vg_p->coord , -vert_move_len , planes[0] );
	}
	else if( pl_count == 2 )
	{
		VCROSS( planes[2] , planes[0] , planes[1] );
		planes[2][H] = VDOT( new_v->vg_p->coord , planes[2] );
		pl_count = 3;
		if( bn_mkpoint_3planes( new_v->vg_p->coord , planes[0] , planes[1] , planes[2] ) )
		{
			bu_log( "nmg_cacl_new_v: 3 planes do not intersect at a point\n" );
			bu_free( (char *)planes , "nmg_calc_new_v: planes" );
			return( 1 );
		}
	}
	else
	{
		bu_log( "nmg_calc_new_v: No face planes at vertex x%x (%f %f %f)\n",
			new_v , V3ARGS( new_v->vg_p->coord ) );
		bu_free( (char *)planes , "nmg_calc_new_v: planes" );
		return( 1 );
	}

	if( rt_g.NMG_debug & DEBUG_BASIC )
		bu_log( "\tnew_v = ( %f %f %f )\n" , V3ARGS( new_v->vg_p->coord ) );

	bu_free( (char *)planes , "nmg_calc_new_v: planes" );

	for( i=0 ; i<BU_PTBL_END( int_faces ) ; i++ )
	{
		struct intersect_fus *fus;
		fastf_t dist;

		fus = (struct intersect_fus *)BU_PTBL_GET( int_faces , i );

		(void) rt_dist_pt3_line3( &dist , fus->start , fus->start , fus->dir , new_v->vg_p->coord , tol );
	}

	if( rt_g.NMG_debug & DEBUG_BASIC )
	{
		bu_log( "After nmg_calc_new_v:\n" );
		nmg_pr_inter( new_v , int_faces );
	}

	return( 0 );
}

/*	N M G _ C O M P L E X _ V E R T E X _ S O L V E
 *
 *	This is intended to handle the cases the "nmg_simple_vertex_solve"
 *	can't do (more than three faces intersecting at a vertex)
 *
 *	This routine may create new edges and/or faces and
 *	Modifies the location of "new_v"
 *
 *	if approximate is non-zero, the new geomatry is
 *	approximated by calculating the point with minimum
 *	distance to all the intersecting faces
 *
 *	returns:
 *		0 - if everything is OK
 *		1 - failure
 */

int
nmg_complex_vertex_solve(struct vertex *new_v, const struct bu_ptbl *faces, const int free_edges, const int approximate, const struct bn_tol *tol)
{
	struct faceuse *fu;
	struct face *fp1;
	struct bu_ptbl int_faces;
	int i;

	/* More than 3 faces intersect at vertex (new_v)
	 * Calculate intersection point along each edge
	 * emanating from new_v */

	if( rt_g.NMG_debug & DEBUG_BASIC )
		bu_log( "nmg_complex_vertex_solve( new_v = x%x , %d faces )\n" , new_v , BU_PTBL_END( faces ) );

	NMG_CK_VERTEX( new_v );
	BU_CK_PTBL( faces );
	BN_CK_TOL( tol );

	if( approximate )
	{
		plane_t *planes;
		int plane_count;

		plane_count = BU_PTBL_END( faces );

		planes = (plane_t *)bu_calloc( plane_count+free_edges , sizeof( plane_t ) , "nmg_complex_vertex_solve: planes" );


		for( i=0 ; i<BU_PTBL_END( faces ) ; i++ )
		{
			fp1 = (struct face *)BU_PTBL_GET( faces , i );
			fu = fp1->fu_p;
			NMG_GET_FU_PLANE( planes[i] , fu );

			if( rt_g.NMG_debug & DEBUG_BASIC )
				bu_log( "\t plane #%d: %g %g %g %g\n", i, V4ARGS( planes[i] ) );
		}

		if( rt_g.NMG_debug & DEBUG_BASIC )
		{
			int j;

			for( i=0 ; i<BU_PTBL_END( faces ); i++ )
			{
				fastf_t dot;

				dot = VDOT( planes[i], new_v->vg_p->coord );
				bu_log( "\tVDOT( #%d, new_v ) - dist = %g\n", i, dot-planes[i][3] );

				for( j=0 ; j<BU_PTBL_END( faces ) ; j++ )
				{
					dot = VDOT( planes[i], planes[j] );
					bu_log( "\tVDOT( #%d, #%d ) = %g\n",i,j, dot );
				}
			}
		}

		if( free_edges )
		{
			int free_edge_count=0;
			struct vertexuse *vu;
			struct faceuse *fu_free=(struct faceuse *)NULL;
			struct edgeuse *eu_free=(struct edgeuse *)NULL;

			plane_count = BU_PTBL_END( faces );

			for( BU_LIST_FOR( vu, vertexuse, &new_v->vu_hd ) )
			{
				struct edgeuse *eu;

				if( *vu->up.magic_p != NMG_EDGEUSE_MAGIC )
					continue;

				eu = vu->up.eu_p;

				if( eu->radial_p == eu->eumate_p )
				{
					vect_t fu_norm;

					/* this is a free edges */
					eu_free = eu;
					fu_free = nmg_find_fu_of_eu( eu_free );
					free_edge_count++;

					NMG_GET_FU_NORMAL( fu_norm, fu_free );

					VCROSS( planes[plane_count], fu_norm, eu_free->g.lseg_p->e_dir );
					VUNITIZE( planes[plane_count] );

					planes[plane_count][3] = VDOT( planes[plane_count], new_v->vg_p->coord );

					if( rt_g.NMG_debug & DEBUG_BASIC )
						bu_log( "\t added plane #%d: %g %g %g %g\n", plane_count, V4ARGS( planes[plane_count] ) );

					plane_count++;

					if( free_edge_count == free_edges )
						break;
				}
			}
		}

		if( bn_isect_planes( new_v->vg_p->coord , (const plane_t *)planes , plane_count ) )
		{
			bu_log( "nmg_complex_vertex_solve: Could not calculate new geometry at ( %f %f %f )\n",
				V3ARGS( new_v->vg_p->coord ) );
			bu_free( (char *) planes , "nmg_complex_vertex_solve: planes" );
			return( 1 );
		}
		bu_free( (char *) planes , "nmg_complex_vertex_solve: planes" );

		if( rt_g.NMG_debug & DEBUG_BASIC )
			bu_log( "nmg_complex_vertex_solve: new coords = ( %f %f %f )\n",
				V3ARGS( new_v->vg_p->coord ) );
		return( 0 );
	}

	bu_ptbl_init( &int_faces , 64, " &int_faces ");

	/* get int_faces table (of intersect_fus structures) partially filled in
	 * with fu's, eu, and edge line definition
	 */
	if( nmg_get_edge_lines( new_v , &int_faces , tol ) )
	{
		bu_ptbl_free( &int_faces );
		return( 1 );
	}

	/* calculate geometry for new_v */
	if( nmg_calc_new_v( new_v , &int_faces , tol ) )
	{
		bu_ptbl_free( &int_faces );
		return( 1 );
	}

	/* fill in "pt" portion of intersect_fus structures with points
	 * that are the intersections of the edge line with the other
	 * edges that meet at new_v. The intersection that is furthest
	 * up the edge away from new_v is selected
	 */
	if (nmg_get_max_edge_inters( new_v , &int_faces , faces , tol ) )
	{
		bu_ptbl_free( &int_faces );
		return( 1 );
	}

	/* split edges at intersection points */
	nmg_split_edges_at_pts( new_v , &int_faces , tol );

	/* fix intersection points that cause loops that cross themselves */
	nmg_fix_crossed_loops( new_v , &int_faces , tol );

	nmg_remove_short_eus_inter( new_v , &int_faces , tol );

	nmg_simplify_inter( new_v , &int_faces , tol );

	/* Build needed faces */
	nmg_make_faces_at_vert( new_v , &int_faces , tol );

	/* Where faces were not built, cracks have formed */
	nmg_kill_cracks_at_vertex( new_v );

	/* free some memory */
	for( i=0 ; i<BU_PTBL_END( &int_faces ) ; i++ )
	{
		struct intersect_fus *i_fus;

		i_fus = (struct intersect_fus *)BU_PTBL_GET( &int_faces , i );
		bu_free( (char *)i_fus , "nmg_complex_vertex_solve: intersect_fus struct\n" );
	}
	bu_ptbl_free( &int_faces );

	if( rt_g.NMG_debug & DEBUG_BASIC )
		bu_log( "nmg_co,mplex_vertex_solve: new coords = ( %f %f %f )\n",
			V3ARGS( new_v->vg_p->coord ) );

	return( 0 );
}

/*	N M G _ B A D _ F A C E _ N O R M A L S
 *
 *	Look for faceuses in the shell with normals that do
 *	not agree with the geometry (i.e., in the wrong direction)
 *
 *	return:
 *		1 - at least one faceuse with a bad normal was found
 *		0 - no faceuses with bad normals were found
 */
int
nmg_bad_face_normals(const struct shell *s, const struct bn_tol *tol)
{
	struct faceuse *fu;
	struct loopuse *lu;
	vect_t old_normal;
	plane_t new_plane;

	NMG_CK_SHELL( s );
	BN_CK_TOL( tol );

	for( BU_LIST_FOR( fu , faceuse , &s->fu_hd ) )
	{
		fastf_t area = -1;

		NMG_CK_FACEUSE( fu );

		/* only check OT_SAME faseuses */
		if( fu->orientation != OT_SAME )
			continue;

		/* get current normal */
		NMG_GET_FU_NORMAL( old_normal , fu );

		for( BU_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
		{
			NMG_CK_LOOPUSE( lu );

			if( lu->orientation != OT_SAME && lu->orientation != OT_OPPOSITE )
				continue;

			if( (area = nmg_loop_plane_area( lu , new_plane )) > 0.0 )
			{
				if( lu->orientation != OT_SAME )
					VREVERSE( new_plane , new_plane )
				break;
			}
		}

		if( area > 0.0 )
		{
			if( VDOT( old_normal , new_plane ) < 0.0 )
				return( 1 );
		}
	}
	return( 0 );
}

/*
 *	N M G _ F A C E S _ A R E _ R A D I A L
 *
 *	checks if two faceuses are radial to each other
 *
 *	returns
 *		1 - the two faceuses are radial to each other
 *		0 - otherwise
 *
 */
int
nmg_faces_are_radial(const struct faceuse *fu1, const struct faceuse *fu2)
{
	struct edgeuse *eu,*eu_tmp;
	struct loopuse *lu;

	NMG_CK_FACEUSE( fu1 );
	NMG_CK_FACEUSE( fu2 );

	/* look at every loop in the faceuse #1 */
	for( BU_LIST_FOR( lu , loopuse , &fu1->lu_hd ) )
	{
		if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
			continue;

		/* look at every edgeuse in the loop */
		for( BU_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
		{
			/* now search radially around edge */
			eu_tmp = eu->eumate_p->radial_p;
			while( eu_tmp != eu && eu_tmp != eu->eumate_p )
			{
				struct faceuse *fu_tmp;

				/* find radial faceuse */
				fu_tmp = nmg_find_fu_of_eu( eu_tmp );

				/* if its the same as fu2 or its mate, the faceuses are radial */
				if( fu_tmp == fu2 || fu_tmp == fu2->fumate_p )
					return( 1 );

				/* go to next radial edgeuse */
				eu_tmp = eu_tmp->eumate_p->radial_p;
			}
		}
	}

	return( 0 );
}

/*	N M G _ M O V E _ E D G E _ T H R U _ P T
 *
 *	moves indicated edgeuse (mv_eu) so that it passes thru
 *	the given point (pt). The direction of the edgeuse
 *	is not changed, so new edgeuse is parallel to the original.
 *
 *	plane equations of all radial faces on this edge are changed
 *	and all vertices (except one anchor point) in radial loops are adjusted
 *	Note that the anchor point is chosen arbitrarily.
 *
 *	returns:
 *		1 - failure
 *		0 - success
 */

int
nmg_move_edge_thru_pt(struct edgeuse *mv_eu, const fastf_t *pt, const struct bn_tol *tol)
{
	struct faceuse *fu,*fu1;
	struct edgeuse *eu,*eu1;
	struct edge_g_lseg *eg;
	struct vertex *v1,*v2;
	struct model *m;
	vect_t e_dir;
	struct bu_ptbl tmp_faces[2];
	struct bu_ptbl faces;
	int count;
	long *flags;

	if( rt_g.NMG_debug & DEBUG_BASIC )
		bu_log( "nmg_move_edge_thru_pt( mv_eu=x%x , pt=( %f %f %f) )\n" , mv_eu , V3ARGS( pt ) );

	NMG_CK_EDGEUSE( mv_eu );
	BN_CK_TOL( tol );

	m = nmg_find_model( &mv_eu->l.magic );
	NMG_CK_MODEL( m );

	/* get endpoint vertices */
	v1 = mv_eu->vu_p->v_p;
	NMG_CK_VERTEX( v1 );
	v2 = mv_eu->eumate_p->vu_p->v_p;
	NMG_CK_VERTEX( v2 );

	eg = mv_eu->g.lseg_p;

	/* get edge direction */
	if( v1 != v2 )
	{
		if( eg )
		{
			NMG_CK_EDGE_G_LSEG(eg);
			VMOVE( e_dir , eg->e_dir );
			if( mv_eu->orientation == OT_OPPOSITE )
			{
				VREVERSE( e_dir , e_dir );
			}
		}
		else
		{
			nmg_edge_g( mv_eu );
			eg = mv_eu->g.lseg_p;
			VMOVE( e_dir , eg->e_dir );
		}
		VUNITIZE( e_dir );
	}

	eu = mv_eu;
	fu1 = nmg_find_fu_of_eu( eu );

	if( fu1 == NULL )
	{
		vect_t to_pt;
		vect_t move_v;
		fastf_t edir_comp;
		point_t new_loc;

		/* This must be a wire edge, just adjust the endpoints */
		/* keep edge the same length, and move vertices perpendicular to e_dir */

		VSUB2( to_pt , pt , v1->vg_p->coord );
		edir_comp = VDOT( to_pt , e_dir );
		VJOIN1( move_v , to_pt , -edir_comp , e_dir );

		/* move the vertices */
		VADD2( new_loc , v1->vg_p->coord , move_v );
		nmg_vertex_gv( v1 , new_loc );

		if( v2 != v1 )
		{
			VADD2( new_loc , v2->vg_p->coord , move_v );
			nmg_vertex_gv( v2 , new_loc );
		}

		/* adjust edge geometry */
		if( !eg )
			nmg_edge_g( eu );
		else
			VMOVE( eg->e_pt , new_loc )

		if( *eu->up.magic_p == NMG_LOOPUSE_MAGIC )
		{
			struct edgeuse *tmp_eu;

			/* edge is part of a wire loop
			 * need to adjust geometry neighbor edges
			 */

			tmp_eu = BU_LIST_PNEXT_CIRC( edgeuse , &eu->l );
			NMG_CK_EDGEUSE( tmp_eu );
			if( *tmp_eu->g.magic_p == NMG_EDGE_G_LSEG_MAGIC )
			{
				VMOVE( tmp_eu->g.lseg_p->e_pt , tmp_eu->vu_p->v_p->vg_p->coord )
				VSUB2( tmp_eu->g.lseg_p->e_dir, tmp_eu->eumate_p->vu_p->v_p->vg_p->coord, tmp_eu->g.lseg_p->e_pt)
			}
			tmp_eu = BU_LIST_PPREV_CIRC( edgeuse , &eu->l );
			NMG_CK_EDGEUSE( tmp_eu );
			if( *tmp_eu->g.magic_p == NMG_EDGE_G_LSEG_MAGIC )
			{
				VMOVE( tmp_eu->g.lseg_p->e_pt , tmp_eu->vu_p->v_p->vg_p->coord )
				VSUB2( tmp_eu->g.lseg_p->e_dir, tmp_eu->eumate_p->vu_p->v_p->vg_p->coord, tmp_eu->g.lseg_p->e_pt)
			}
		}

		return( 0 );
	}

	/* can only handle edges with up to two radial faces */
	if( mv_eu->radial_p->eumate_p != mv_eu->eumate_p->radial_p && mv_eu->radial_p != mv_eu->eumate_p )
	{
		bu_log( "Cannot handle edges with more than two radial faces\n" );
		return( 1 );
	}

	bu_ptbl_init( &tmp_faces[0] , 64, " &tmp_faces[0] ");
	bu_ptbl_init( &tmp_faces[1] , 64, " &tmp_faces[1] ");

	/* cannot handle complex vertices yet */
	if( nmg_find_isect_faces( v1 , &tmp_faces[0] , &count , tol ) > 3 ||
	    nmg_find_isect_faces( v2 , &tmp_faces[1] , &count , tol ) > 3 )
	{
		bu_log( "nmg_move_edge_thru_pt: cannot handle complex vertices yet\n" );
		bu_ptbl_free( &tmp_faces[0] );
		bu_ptbl_free( &tmp_faces[1] );
		return( 1 );
	}

	/* Move edge geometry to new point */
	if( eg )
	{
		VMOVE( eg->e_pt , pt );
	}

	/* modify plane equation for each face radial to mv_eu */
	fu = fu1;
	do
	{
		struct edgeuse *eu_next;
		plane_t plane;
		int cross_direction;
		vect_t norm;
		int done;

		NMG_CK_EDGEUSE( eu );
		NMG_CK_FACEUSE( fu );

		if( fu->orientation == OT_SAME )
			NMG_GET_FU_NORMAL( norm , fu )
		else
			NMG_GET_FU_NORMAL( norm , fu->fumate_p )

		/* find an anchor point for face to rotate about
		 * go forward in loop until we find a vertex that is
		 * far enough from the line of mv_eu to produce a
		 * non-zero cross product
		 */
		eu_next = eu;
		done = 0;
		while( !done )
		{
			vect_t to_anchor;
			vect_t next_dir;
			vect_t cross;
			struct vertex *anchor_v;
			fastf_t mag;

			/* get next edgeuse in loop */
			eu_next = BU_LIST_PNEXT_CIRC( edgeuse , &eu_next->l );

			/* check if we have circled the entire loop */
			if( eu_next == eu )
			{
				bu_log( "nmg_move_edge_thru_pt: cannot calculate new plane eqn\n" );
				return( 1 );
			}

			/* anchor point is endpoint of this edgeuse */
			anchor_v = eu_next->eumate_p->vu_p->v_p;

			VSUB2( next_dir , anchor_v->vg_p->coord , eu_next->vu_p->v_p->vg_p->coord );
			VCROSS( cross , e_dir , next_dir );
			if( VDOT( cross , norm ) < 0.0 )
				cross_direction = 1;
			else
				cross_direction = 0;

			/* calculate new plane */
			VSUB2( to_anchor , anchor_v->vg_p->coord , pt );
			if( cross_direction )
			{
				VCROSS( plane , to_anchor , e_dir );
			}
			else
			{
				VCROSS( plane , e_dir , to_anchor );
			}

			mag = MAGNITUDE( plane );
			if( mag > SQRT_SMALL_FASTF )
			{
				/* this is an acceptable plane */
				mag = 1.0/mag;
				VSCALE( plane , plane , mag );
				plane[3] = VDOT( plane , pt );

				/* assign this plane to the face */
				if( fu->orientation == OT_SAME )
					nmg_face_g( fu , plane );
				else
					nmg_face_g( fu->fumate_p , plane );
				done = 1;
			}
		}

		/* move on to next radial face */
		eu = eu->eumate_p->radial_p;
		fu = nmg_find_fu_of_eu( eu );
	}
	while( fu != fu1 && fu != fu1->fumate_p );

	/* now recalculate vertex coordinates for all affected vertices,
	 * could be lots of them
	 */

	flags = (long *)bu_calloc( m->maxindex , sizeof( long ) , "nmg_move_edge_thru_pt: flags" );
	bu_ptbl_init( &faces , 64, " &faces ");

	eu1 = mv_eu;
	fu1 = nmg_find_fu_of_eu( eu1 );
	fu = fu1;
	do
	{
		struct loopuse *lu;

		for( BU_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
		{
			struct edgeuse *eu;

			NMG_CK_LOOPUSE( lu );

			if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) == NMG_VERTEXUSE_MAGIC )
			{
				struct vertexuse *vu;
				vu = BU_LIST_FIRST( vertexuse , &lu->down_hd );
				if( NMG_INDEX_TEST_AND_SET( flags , vu->v_p ) )
				{
					bu_ptbl_reset( &faces );

					/* find all unique faces that intersect at this vertex (vu->v_p) */
					if( nmg_find_isect_faces( vu->v_p , &faces , &count , tol ) > 3 )
					{
						bu_log( "mg_move_edge_thru_pt: Cannot handle complex vertices\n" );
						bu_ptbl_free( &faces );
						bu_free( (char *)flags , "mg_move_edge_thru_pt: flags" );
						return( 1 );
					}

					if( nmg_simple_vertex_solve( vu->v_p , &faces, tol ) )
					{
						/* failed */
						bu_log( "nmg_move_edge_thru_pt: Could not solve simple vertex\n" );
						bu_ptbl_free( &faces );
						bu_free( (char *)flags , "mg_move_edge_thru_pt: flags" );
						return( 1 );
					}
				}
				continue;
			}

			for( BU_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
			{
				struct vertexuse *vu;

				vu = eu->vu_p;
				if( NMG_INDEX_TEST_AND_SET( flags , vu->v_p ) )
				{

					bu_ptbl_reset( &faces );

					/* find all unique faces that intersect at this vertex (vu->v_p) */
					if( nmg_find_isect_faces( vu->v_p , &faces , &count , tol ) > 3 )
					{
						bu_log( "mg_move_edge_thru_pt: Cannot handle complex vertices\n" );
						bu_ptbl_free( &faces );
						bu_free( (char *)flags , "mg_move_edge_thru_pt: flags" );
						return( 1 );
					}

					if( BU_PTBL_END( &faces ) == 1 &&
						(mv_eu->vu_p->v_p == vu->v_p ||
						 mv_eu->eumate_p->vu_p->v_p == vu->v_p) )
					{
						vect_t to_pt;
						vect_t mv_vect;
						vect_t eu_dir;

						/* special case for edge of a dangling face */

						/* just move vertex to new edge geometry */
						VSUB2( eu_dir, eu->eumate_p->vu_p->v_p->vg_p->coord, vu->v_p->vg_p->coord );
						VUNITIZE( eu_dir );
						VSUB2( to_pt, pt , vu->v_p->vg_p->coord );
						VJOIN1( mv_vect, to_pt, -VDOT( e_dir, to_pt ), e_dir );
						VADD2( vu->v_p->vg_p->coord, vu->v_p->vg_p->coord, mv_vect);
					}
					else
					{
						if( nmg_simple_vertex_solve( vu->v_p , &faces, tol ) )
						{
							/* failed */
							bu_log( "nmg_move_edge_thru_pt: Could not solve simple vertex\n" );
							bu_ptbl_free( &faces );
							bu_free( (char *)flags , "mg_move_edge_thru_pt: flags" );
							return( 1 );
						}
					}

					/* adjust edge geometry */
					if( eu->e_p != mv_eu->e_p )
					{
						if( !eu->g.magic_p )
							nmg_edge_g( eu );
						else
						{
							VMOVE( eu->g.lseg_p->e_pt, vu->v_p->vg_p->coord );
							VSUB2( eu->g.lseg_p->e_dir,
								eu->eumate_p->vu_p->v_p->vg_p->coord,
								vu->v_p->vg_p->coord );
						}
					}
				}
			}
		}

		/* move on to next radial face */
		eu1 = eu1->eumate_p->radial_p;
		fu = nmg_find_fu_of_eu( eu1 );
	}
	while( fu != fu1 && fu != fu1->fumate_p );

	bu_free( (char *)flags , "mg_move_edge_thru_pt: flags" );
	bu_ptbl_free( &faces );

	return( 0 );
}

/*	N M G _ V L I S T _ T O _ W I R E _ E D G E S
 *
 *	Convert a vlist to NMG wire edges
 *
 */
void
nmg_vlist_to_wire_edges(struct shell *s, const struct bu_list *vhead)
{
	const struct bn_vlist *vp;
	struct edgeuse *eu;
	struct vertex *v1,*v2;
	point_t pt1,pt2;

	NMG_CK_SHELL( s );
	NMG_CK_LIST( vhead );

	v1 = (struct vertex *)NULL;
	v2 = (struct vertex *)NULL;

	vp = BU_LIST_FIRST( bn_vlist , vhead );
	if( vp->nused < 2 )
		return;

	for( BU_LIST_FOR( vp , bn_vlist , vhead ) )
	{
		register int i;
		register int nused = vp->nused;
		vect_t edge_vec;

		for( i=0 ; i<nused ; i++ )
		{
			switch( vp->cmd[i] )
			{
				case BN_VLIST_LINE_MOVE:
				case BN_VLIST_POLY_MOVE:
					v1 = (struct vertex *)NULL;
					v2 = (struct vertex *)NULL;
					VMOVE( pt2 , vp->pt[i] );
					break;
				case BN_VLIST_LINE_DRAW:
				case BN_VLIST_POLY_DRAW:
					VSUB2( edge_vec , pt2 , vp->pt[i] );
					if( VNEAR_ZERO( edge_vec , SMALL_FASTF ) )
						break;
					VMOVE( pt1 , pt2 );
					v1 = v2;
					VMOVE( pt2 , vp->pt[i] );
					v2 = (struct vertex *)NULL;
					eu = nmg_me( v1 , v2 , s );
					v1 = eu->vu_p->v_p;
					v2 = eu->eumate_p->vu_p->v_p;
					nmg_vertex_gv( v2 , pt2 );
					if( !v1->vg_p )
						nmg_vertex_gv( v1 , pt1 );
					nmg_edge_g( eu );
					break;
				case BN_VLIST_POLY_START:
				case BN_VLIST_POLY_END:
					break;
			}
		}
	}
}

void
nmg_follow_free_edges_to_vertex(const struct vertex *vpa, const struct vertex *vpb, struct bu_ptbl *bad_verts, const struct shell *s, const struct edgeuse *eu, struct bu_ptbl *verts, int *found)
{
	struct vertexuse *vu;

	BU_CK_PTBL( bad_verts );
	NMG_CK_EDGEUSE( eu );
	NMG_CK_VERTEX( vpa );
	NMG_CK_VERTEX( vpb );
	if( s )
		NMG_CK_SHELL( s );

	NMG_CK_VERTEX( eu->eumate_p->vu_p->v_p );

	if( rt_g.NMG_debug & DEBUG_BASIC )
	{
		bu_log( "nmg_follow_free_edges_to_vertex( vpa=x%x, vpb=x%x s=x%x, eu=x%x, found=%d )\n",
			vpa,vpb,s,eu,*found );
	}

	for( BU_LIST_FOR( vu , vertexuse , &eu->eumate_p->vu_p->v_p->vu_hd ) )
	{
		struct edgeuse *eu1;

		NMG_CK_VERTEXUSE( vu );

		if( *vu->up.magic_p != NMG_EDGEUSE_MAGIC )
			continue;

		if( s && (nmg_find_s_of_vu( vu ) != s ) )
			continue;

		eu1 = vu->up.eu_p;

		NMG_CK_EDGEUSE( eu1 );

		if( rt_g.NMG_debug & DEBUG_BASIC )
			bu_log( "\tchecking eu x%x: x%x ( %f %f %f )\n\t\tto x%x ( %f %f %f )\n", eu1,
				eu1->vu_p->v_p, V3ARGS( eu1->vu_p->v_p->vg_p->coord ),
				eu1->eumate_p->vu_p->v_p, V3ARGS( eu1->eumate_p->vu_p->v_p->vg_p->coord ) );

		/* stick to free edges */
		if( eu1->eumate_p != eu1->radial_p )
		{
			if( rt_g.NMG_debug & DEBUG_BASIC )
				bu_log( "\t\tnot a dangling edge\n" );
			continue;
		}

		/* don`t go back the way we came */
		if( eu1 == eu->eumate_p )
		{
			if( rt_g.NMG_debug & DEBUG_BASIC )
				bu_log( "\t\tback the way we came\n" );
			continue;
		}

		if( eu1->eumate_p->vu_p->v_p == vpb )
		{
			/* found it!!! */
			if( rt_g.NMG_debug & DEBUG_BASIC )
				bu_log( "\t\tfound goal\n" );
			bu_ptbl_ins( verts , (long *)vu->v_p );
			bu_ptbl_ins( verts , (long *)vpb );
			*found = 1;
		}
		else if( eu1->eumate_p->vu_p->v_p == vpa )
		{
			/* back where we started */
			if( rt_g.NMG_debug & DEBUG_BASIC )
				bu_log( "\t\tback at start\n" );
			continue;
		}
		else if( bu_ptbl_locate( bad_verts , (long *)eu1->eumate_p->vu_p->v_p ) != (-1))
		{
			/* this is the wrong way */
			if( rt_g.NMG_debug & DEBUG_BASIC )
				bu_log( "\t\tA bad vertex\n" );
			continue;
		}
		else if( bu_ptbl_locate( verts , (long *)eu1->eumate_p->vu_p->v_p ) != (-1))
		{
			/* This is a loop !!!! */
			if( rt_g.NMG_debug & DEBUG_BASIC )
				bu_log( "a loop\n" );
			continue;
		}
		else
		{
			if( rt_g.NMG_debug & DEBUG_BASIC )
				bu_log( "\t\tinserting vertex x%x\n" , vu->v_p );
			bu_ptbl_ins( verts , (long *)vu->v_p );
			if( rt_g.NMG_debug & DEBUG_BASIC )
				bu_log( "\t\tCalling follow edges\n" );
			nmg_follow_free_edges_to_vertex( vpa , vpb , bad_verts , s , eu1 , verts , found );
			if( *found < 0 )
			{
				if( rt_g.NMG_debug & DEBUG_BASIC )
				{
					bu_log( "\t\treturn is %d\n" , *found );
					bu_log( "\t\t\tremove vertex x%x\n" , vu->v_p );
				}
				bu_ptbl_rm( verts , (long *)vu->v_p );
				*found = 0;
			}
		}
		if( *found )
			return;
	}

	*found = (-1);
}

static struct bu_ptbl *
nmg_find_path(const struct vertex *vpa, const struct vertex *vpb, struct bu_ptbl *bad_verts, const struct shell *s)
{
	int done;
	static struct bu_ptbl verts;
	struct vertexuse *vua;


	BU_CK_PTBL( bad_verts );
	NMG_CK_VERTEX( vpa );
	NMG_CK_VERTEX( vpb );

	if( rt_g.NMG_debug & DEBUG_BASIC )
	{
		int i;

		bu_log( "nmg_find_path( vpa=x%x ( %f %f %f ), vpb=x%x ( %f %f %f )\n",
			vpa, V3ARGS( vpa->vg_p->coord ), vpb, V3ARGS( vpb->vg_p->coord ) );
		bu_log( "\t%d vertices to avoid\n" , BU_PTBL_END( bad_verts ) );
		for( i=0 ; i<BU_PTBL_END( bad_verts ) ; i++ )
		{
			struct vertex *vpbad;

			vpbad = (struct vertex *)BU_PTBL_GET( bad_verts , i );
			bu_log( "\tx%x ( %f %f %f )\n" , vpbad , V3ARGS( vpbad->vg_p->coord ) );
		}
	}

	bu_ptbl_init( &verts , 64, " &verts ");
	bu_ptbl_ins( &verts , (long *)vpa );

	for( BU_LIST_FOR( vua , vertexuse , &vpa->vu_hd ) )
	{
		struct edgeuse *eua;

		NMG_CK_VERTEXUSE( vua );

		if( *vua->up.magic_p != NMG_EDGEUSE_MAGIC )
			continue;

		if( s && (nmg_find_s_of_vu( vua ) != s) )
			continue;

		eua = vua->up.eu_p;

		NMG_CK_EDGEUSE( eua );

		if( rt_g.NMG_debug & DEBUG_BASIC )
			bu_log( "\tchecking eu x%x: x%x ( %f %f %f )\n\t\tto x%x ( %f %f %f )\n", eua,
				eua->vu_p->v_p, V3ARGS( eua->vu_p->v_p->vg_p->coord ),
				eua->eumate_p->vu_p->v_p, V3ARGS( eua->eumate_p->vu_p->v_p->vg_p->coord ) );

		if( eua->eumate_p != eua->radial_p )
		{
			if( rt_g.NMG_debug & DEBUG_BASIC )
				bu_log( "\t\tback the way we came!\n" );
			continue;
		}

		if( bu_ptbl_locate( bad_verts , (long *)eua->eumate_p->vu_p->v_p ) != (-1) )
		{
			if( rt_g.NMG_debug & DEBUG_BASIC )
				bu_log( "\t\tOne of the bad vertices!!\n" );
			continue;
		}

		if( eua->eumate_p->vu_p->v_p == vpb )
		{
			if( rt_g.NMG_debug & DEBUG_BASIC )
				bu_log( "\t\tfound goal!!\n" );
			bu_ptbl_ins( &verts , (long *)vpb );
			return( &verts );
		}

		done = 0;
		if( rt_g.NMG_debug & DEBUG_BASIC )
			bu_log( "\tCall follow edges\n" );
		nmg_follow_free_edges_to_vertex( vpa, vpb, bad_verts, s, eua, &verts, &done );

		if( done == 1 )
			break;

		bu_ptbl_reset( &verts );
		bu_ptbl_ins( &verts , (long *)vpa );
	}

	if( done != 1 )
		bu_ptbl_init( &verts , 64, " &verts ");

	return( &verts );
}

void
nmg_glue_face_in_shell(const struct faceuse *fu, struct shell *s, const struct bn_tol *tol)
{
	struct loopuse *lu;

	NMG_CK_FACEUSE( fu );
	NMG_CK_SHELL( s );
	BN_CK_TOL( tol );

	for( BU_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
	{
		struct edgeuse *eu;

		NMG_CK_LOOPUSE( lu );
		if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
			continue;

		for( BU_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
		{
			struct edgeuse *eu1;

			NMG_CK_EDGEUSE( eu );

			eu1 = nmg_findeu( eu->vu_p->v_p, eu->eumate_p->vu_p->v_p, s, eu, 1 );
			if( eu1 )
			{
				NMG_CK_EDGEUSE( eu1 );
				nmg_radial_join_eu( eu1, eu, tol );
			}
		}
	}
}

#if 0
static int
nmg_vert_is_normalward( v, vbase, norm )
struct vertex *v;
struct vertex *vbase;
vect_t norm;
{
	vect_t to_v;

	NMG_CK_VERTEX( v );
	NMG_CK_VERTEX( vbase );

	VSUB2( to_v, v->vg_p->coord, vbase->vg_p->coord );
	if( VDOT( to_v, norm ) > 0.0 )
		return( 1 );
	else
		return( 0 );
}


/* Join EU's running from v1 to v2 and from v2 to v3 */
static void
Join_eus( v1, v2, v3, tol )
struct vertex *v1,*v2,*v3;
const struct bn_tol *tol;
{
	struct edgeuse *eu1;
	struct edgeuse *eu2;

	if( rt_g.NMG_debug & DEBUG_BASIC )
	{
		bu_log( "Join_eus:\n" );
		bu_log( "\tv1 = x%x ( %g %g %g )\n", v1, V3ARGS( v1->vg_p->coord ) );
		bu_log( "\tv2 = x%x ( %g %g %g )\n", v2, V3ARGS( v2->vg_p->coord ) );
		bu_log( "\tv3 = x%x ( %g %g %g )\n", v3, V3ARGS( v3->vg_p->coord ) );
	}

	eu1 = nmg_find_e( v1, v2, (struct shell *)NULL, (struct edge *)NULL );
	if( !eu1 )
	{
		if( rt_g.NMG_debug & DEBUG_BASIC )
			bu_log( "\tNo edge found from v1 to v2\n" );
	}
	else
	{
		NMG_CK_EDGEUSE( eu1 );

		eu2 = nmg_find_e( v1, v2, (struct shell *)NULL, eu1->e_p );
		while( eu2 )
		{
			NMG_CK_EDGEUSE( eu2 );

			if( rt_g.NMG_debug & DEBUG_BASIC )
				bu_log( "Joining eus x%x and x%x\n" , eu1, eu2 );
			nmg_radial_join_eu( eu1, eu2, tol );

			eu2 = nmg_find_e( v1, v2, (struct shell *)NULL, eu1->e_p );
		}
	}

	eu1 = nmg_find_e( v2, v3, (struct shell *)NULL, (struct edge *)NULL );
	if( !eu1 )
	{
		if( rt_g.NMG_debug & DEBUG_BASIC )
			bu_log( "\tNo edge found from v2 to v3\n" );
	}
	else
	{
		NMG_CK_EDGEUSE( eu1 );

		eu2 = nmg_find_e( v2, v3, (struct shell *)NULL, eu1->e_p );
		while( eu2 )
		{
			NMG_CK_EDGEUSE( eu2 );
			if( rt_g.NMG_debug & DEBUG_BASIC )
				bu_log( "Joining eus x%x and x%x\n" , eu1, eu2 );
			nmg_radial_join_eu( eu1, eu2, tol );

			eu2 = nmg_find_e( v2, v3, (struct shell *)NULL, eu1->e_p );
		}
	}
}
#endif

static int
nmg_make_connect_faces(struct shell *dst, struct vertex *vpa, struct vertex *vpb, struct bu_ptbl *verts, const struct bn_tol *tol)
{
	int done=0;
	int i,j;
	int verts_in_face=0;
	struct vertex *face_verts[20];
	struct vertex *v;
	int max_vert_no=19;
	int made_face;
	int faces_made=0;
	fastf_t dist_to_a_sq,dist_to_b_sq;
	vect_t to_vpa,to_vpb;

	if( rt_g.NMG_debug & DEBUG_BASIC )
	{
		bu_log( "nmg_make_connect_faces( dst=x%x, vpa=x%x ( %f %f %f ), vpb=x%x ( %f %f %f )\n",
				dst, vpa, V3ARGS( vpa->vg_p->coord ), vpb, V3ARGS( vpb->vg_p->coord ) );
		for( i=0 ; i<BU_PTBL_END( verts ) ; i++ )
		{
			struct vertex *v;

			v = (struct vertex *)BU_PTBL_GET( verts , i );
			bu_log( "\tx%x ( %f %f %f )\n" , v , V3ARGS( v->vg_p->coord ) );
		}
	}

	NMG_CK_SHELL( dst );
	NMG_CK_VERTEX( vpa );
	NMG_CK_VERTEX( vpb );
	BU_CK_PTBL( verts );
	BN_CK_TOL( tol );

	if( BU_PTBL_END( verts ) < 1 )
	{
		bu_log( "nmg_make_connect_faces: no list of vertices from other shell\n" );
		return( 0 );
	}
	if( BU_PTBL_END( verts ) == 1 )
	{
		face_verts[0] = vpb;
		face_verts[1] = vpa;
		face_verts[2] = (struct vertex *)BU_PTBL_GET( verts , 0 );
		i = 0;
	}
	else
	{
		/* set up for first face */
		face_verts[0] = vpa;
		face_verts[1] = (struct vertex *)BU_PTBL_GET( verts , 0 );
		face_verts[2] = (struct vertex *)BU_PTBL_GET( verts , 1 );
		i = 1;
	}
	v = face_verts[2];
	verts_in_face = 3;

	VSUB2( to_vpa , vpa->vg_p->coord , v->vg_p->coord );
	VSUB2( to_vpb , vpb->vg_p->coord , v->vg_p->coord );

	dist_to_a_sq = MAGSQ( to_vpa );
	dist_to_b_sq = MAGSQ( to_vpb );

	while( 1 )
	{
		struct faceuse *new_fu;
		struct loopuse *lu;
		plane_t pl;
		fastf_t area;
		int still_collinear=0;

		made_face = 0;

		/* if the current points are all collinear, add another vertex */
		while( bn_3pts_collinear( face_verts[0]->vg_p->coord,
				face_verts[1]->vg_p->coord,
				face_verts[verts_in_face - 1]->vg_p->coord, tol) )
		{
			if( verts_in_face >= max_vert_no )
			{
				still_collinear = 1;
				break;
			}

			if( i+1 >= BU_PTBL_END( verts ) )
			{
				still_collinear = 1;
				break;
			}
			i++;
			face_verts[verts_in_face] = (struct vertex *)BU_PTBL_GET( verts , i );
			verts_in_face++;
		}
			
		if( !still_collinear )
		{
			/* make the new face */

			if( rt_g.NMG_debug & DEBUG_BASIC )
			{
				int debug_int;

				bu_log( "make face:\n" );
				for( debug_int=0 ; debug_int<verts_in_face ; debug_int++ )
					bu_log( "\tx%x ( %f %f %f )\n" , face_verts[debug_int],
						V3ARGS( face_verts[debug_int]->vg_p->coord ) );
			}

			new_fu = nmg_cface( dst , face_verts , verts_in_face );
			lu = BU_LIST_FIRST( loopuse , &new_fu->lu_hd );
			area = nmg_loop_plane_area( lu , pl );

			if( area <= 0.0 )
			{
				bu_log( "Bad lu:\n" );
				nmg_pr_lu_briefly( lu, " " );
				nmg_kfu( new_fu );
				rt_bomb( "nmg_make_connect_faces: Failed to calculate plane eqn\n" );
			}
			else
			{
				made_face = 1;
				faces_made++;

				nmg_face_g( new_fu , pl );
				nmg_loop_g( lu->l_p, tol );

				/* glue this face in */
				nmg_glue_face_in_shell( new_fu , dst , tol );
			}
		}
		else
			made_face = 0;

		/* If we are half way to the other end of the edge,
		 * switch from vpa to vpb for the basis of the faces.
		 * Need to make the "middle" face.
		 */
		if( dist_to_b_sq <= dist_to_a_sq && face_verts[0] == vpa )
		{
			face_verts[0] = vpb;
			face_verts[1] = vpa;
			face_verts[2] = v;
			verts_in_face = 3;
		}
		else
		{
			/* Get ready for next face and check if done */
			i++;

			if( i < BU_PTBL_END( verts ) )
			{
				v = (struct vertex *)BU_PTBL_GET( verts , i );
				NMG_CK_VERTEX( v );

				VSUB2( to_vpa , vpa->vg_p->coord , v->vg_p->coord );
				VSUB2( to_vpb , vpb->vg_p->coord , v->vg_p->coord );

				dist_to_a_sq = MAGSQ( to_vpa );
				dist_to_b_sq = MAGSQ( to_vpb );
				face_verts[1] = face_verts[verts_in_face-1];
				face_verts[2] = v;
				verts_in_face = 3;
			}
			else if( face_verts[0] == vpa )
			{
				if( done )
					break;

				/* make last face */
				face_verts[0] = vpb;
				face_verts[1] = vpa;
				face_verts[2] = face_verts[verts_in_face-1];
				verts_in_face = 3;
				done = 1;
			}
			else	/* we are done */
				break;
		}

	}

	if( !made_face )
	{
		int found;

		if( !faces_made )
		{
			/* put all the vertices on the list */

			/* check for vpa */
			found = 0;
			for( i=0 ; i<verts_in_face ; i++ )
			{
				if( face_verts[i] == vpa )
				{
					found = 1;
					break;
				}
			}
			if( !found )
			{
				if( verts_in_face < 19 )
				{
					face_verts[verts_in_face] = vpa;
					verts_in_face++;
				}
			}

			/* check for vpb */
			found = 0;
			for( i=0 ; i<verts_in_face ; i++ )
			{
				if( face_verts[i] == vpb )
				{
					found = 1;
					break;
				}
			}
			if( !found )
			{
				if( verts_in_face < 19 )
				{
					face_verts[verts_in_face] = vpb;
					verts_in_face++;
				}
			}

			/* check verts table */
			for( j=0 ; j<BU_PTBL_END( verts ) ; j++ )
			{
				struct vertex *v_tmp;

				v_tmp = (struct vertex *)BU_PTBL_GET( verts, j );
				found = 0;
				for( i=0 ; i<verts_in_face ; i++ )
				{
					if( face_verts[i] == v_tmp )
					{
						found = 1;
						break;
					}
				}
				if( !found )
				{
					if( verts_in_face < 19 )
					{
						face_verts[verts_in_face] = v_tmp;
						verts_in_face++;
					}
				}
			}
		}
#if 1
		return( 1 );
#else
		if( rt_g.NMG_debug & DEBUG_BASIC )
		{
			bu_log( "nmg_make_connect_faces: Looking for edges to split verts in face = %d\n", verts_in_face );
			for( i=0 ; i<verts_in_face ; i++ )
				bu_log( "\t x%x ( %g %g %g )\n", face_verts[i], V3ARGS( face_verts[i]->vg_p->coord ) );
		}

		for( i=0 ; i<verts_in_face-2 ; i++ )
		{
			for( j=i+1 ; j<verts_in_face-1 ; j++ )
			{
				for( k=j+1 ; k<verts_in_face ; k++ )
				{
					struct edgeuse *eu;

					if( rt_g.NMG_debug & DEBUG_BASIC )
					{
						bu_log( "Checking collinearity of:\n" );
						bu_log( "\t x%x ( %g %g %g )\n", face_verts[i], V3ARGS( face_verts[i]->vg_p->coord ) );
						bu_log( "\t x%x ( %g %g %g )\n", face_verts[j], V3ARGS( face_verts[j]->vg_p->coord ) );
						bu_log( "\t x%x ( %g %g %g )\n", face_verts[k], V3ARGS( face_verts[k]->vg_p->coord ) );
					}

					if( !bn_3pts_collinear( face_verts[i]->vg_p->coord,
								face_verts[j]->vg_p->coord,
								face_verts[k]->vg_p->coord, tol ) )
						continue;
					if( rt_g.NMG_debug & DEBUG_BASIC )
						bu_log( "\t They are collinear\n" );

					if( (eu = nmg_findeu( face_verts[i], face_verts[j], (struct shell *)NULL,
						(struct edgeuse *)NULL, 0 ) ) )
					{
						if( rt_g.NMG_debug & DEBUG_BASIC )
							bu_log( "\tFound eu between x%x and x%x\n", face_verts[i], face_verts[j] );

						if( !bn_dist_pt3_lseg3( &dist, pca,
							face_verts[i]->vg_p->coord,
							face_verts[j]->vg_p->coord,
							face_verts[k]->vg_p->coord, tol ) )
						{
							new_eu = nmg_esplit( face_verts[k], eu, 1 );
							Join_eus( face_verts[i], face_verts[k], face_verts[j], tol );
						}
						else if( rt_g.NMG_debug & DEBUG_BASIC )
							bu_log( "\t\tvertex x%x is outside eu\n" , face_verts[k] );
					}
					if( (eu = nmg_findeu( face_verts[i], face_verts[k], (struct shell *)NULL,
						(struct edgeuse *)NULL, 0 ) ) )
					{
						if( rt_g.NMG_debug & DEBUG_BASIC )
							bu_log( "\tFound eu between x%x and x%x\n", face_verts[i], face_verts[k] );

						if( !bn_dist_pt3_lseg3( &dist, pca,
							face_verts[i]->vg_p->coord,
							face_verts[k]->vg_p->coord,
							face_verts[j]->vg_p->coord, tol ) )
						{
							new_eu = nmg_esplit( face_verts[j], eu, 1 );
							Join_eus( face_verts[i], face_verts[j], face_verts[k], tol );
						}
						else if( rt_g.NMG_debug & DEBUG_BASIC )
							bu_log( "\t\tvertex x%x is outside eu\n" , face_verts[j] );
					}
					if( (eu = nmg_findeu( face_verts[j], face_verts[k], (struct shell *)NULL,
						(struct edgeuse *)NULL, 0 ) ) )
					{
						if( rt_g.NMG_debug & DEBUG_BASIC )
							bu_log( "\tFound eu between x%x and x%x\n", face_verts[j], face_verts[k] );

						if( !bn_dist_pt3_lseg3( &dist, pca,
							face_verts[j]->vg_p->coord,
							face_verts[k]->vg_p->coord,
							face_verts[i]->vg_p->coord, tol ) )
						{
							new_eu = nmg_esplit( face_verts[i], eu, 1 );
							Join_eus( face_verts[j], face_verts[i], face_verts[k], tol );
						}
						else if( rt_g.NMG_debug & DEBUG_BASIC )
							bu_log( "\t\tvertex x%x is outside eu\n" , face_verts[i] );
					}
				}
			}
		}
#endif
	}
	return( 0 );
}

/*	N M G _ O P E N _ S H E L L S _ C O N N E C T
 *
 *	Two open shells are connected along their free edges by building
 *	new faces.  The resluting closed shell is in "dst", and "src" shell
 *	is destroyed.  The "copy_tbl" is a translation table that provides
 *	a one-to-one translation between the vertices in the two shells, i.e.,
 *	NMG_INDEX_GETP(vertex, copy_tbl, v), where v is a pointer to a vertex
 *	in "dst" shell, provides a pointer to the corresponding vertex in "src" shell
 *
 *	returns:
 *		0 - All is well
 *		1 - failure
 */

/* 	structure for use by nmg_open_shells_connect */
struct dangle
{
	struct vertex *va,*vb;		/* vertices of a dangling edge in dst shell */
	struct vertex *v1,*v2;		/* corresponding vertices in src shell */
	struct bu_ptbl bad_verts;	/* list of vertices to avoid when finding path
					 * from v1 to v2 */
	int needs_edge_breaking;
};

int
nmg_open_shells_connect(struct shell *dst, struct shell *src, const long int **copy_tbl, const struct bn_tol *tol)
{
	struct faceuse *fu;
	struct loopuse *lu;
	struct edgeuse *eu;
	struct bu_ptbl faces;
	struct bu_ptbl dangles;
	int open_src,open_dst;
	int i,j,k;

	if( rt_g.NMG_debug & DEBUG_BASIC )
		bu_log( "nmg_open_shells_connect( dst=x%x , src=x%x , copy_tbl=x%x)\n" , dst , src , copy_tbl );

	NMG_CK_SHELL( dst );
	NMG_CK_SHELL( src );
	BN_CK_TOL( tol );

	open_src = nmg_check_closed_shell( src , tol );
	open_dst = nmg_check_closed_shell( dst , tol );

	if( !open_dst && !open_src )
	{
		/* both shells are closed, just join them */
		nmg_js( dst, src, tol );
		return( 0 );
	}

	if( !open_dst )
	{
		bu_log( "nmg_open_shells_connect: destination shell is closed!\n" );
		return( 1 );
	}

	if( !open_src )
	{
		bu_log( "nmg_open_shells_connect: source shell is closed!\n" );
		return( 1 );
	}

	bu_ptbl_init( &dangles , 64, " &dangles ");

	/* find free edges in "dst" shell */
	for( BU_LIST_FOR( fu , faceuse , &dst->fu_hd ) )
	{
		NMG_CK_FACEUSE( fu );
		if( fu->orientation != OT_SAME )
			continue;
		for( BU_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
		{
			NMG_CK_LOOPUSE( lu );
			if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) == NMG_VERTEXUSE_MAGIC )
				continue;

			for( BU_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
			{
				NMG_CK_EDGEUSE( eu );
				if( eu->eumate_p == eu->radial_p )
				{
					struct dangle *dang;
					struct vertexuse *test_vu;
					struct vertex *vpbad1,*vpbada;

					/* found a dangling edge, put it in the list */
					dang = (struct dangle *)bu_malloc( sizeof( struct dangle ) ,
						"nmg_open_shells_connect: dang" );

					dang->needs_edge_breaking = 0;
					dang->va = eu->vu_p->v_p;
					NMG_CK_VERTEX( dang->va );
					dang->v1 = NMG_INDEX_GETP(vertex, copy_tbl, dang->va );
					NMG_CK_VERTEX( dang->v1 );
					dang->vb = eu->eumate_p->vu_p->v_p;
					NMG_CK_VERTEX( dang->vb );
					dang->v2 = NMG_INDEX_GETP(vertex, copy_tbl, dang->vb );
					NMG_CK_VERTEX( dang->v2 );

					bu_ptbl_init( &dang->bad_verts , 64, " &dang->bad_verts ");

					/* look for other dangling edges around this one
					 * to establish direction for nmg_find_path
					 * to look in
					 */

					for( BU_LIST_FOR( test_vu , vertexuse , &dang->va->vu_hd ) )
					{
						struct edgeuse *test_eu;

						if( *test_vu->up.magic_p != NMG_EDGEUSE_MAGIC )
							continue;

						test_eu = test_vu->up.eu_p;
						if( test_eu == eu )
							continue;

						if( test_eu->eumate_p->vu_p->v_p == dang->vb )
							continue;

						if( test_eu->eumate_p == test_eu->radial_p )
						{
							/* another dangling edge, don't want
							 * nmg_find_path to wander off
							 * in this direction
							 */
							vpbada = test_eu->eumate_p->vu_p->v_p;
							vpbad1 = NMG_INDEX_GETP( vertex , copy_tbl , vpbada );
							if( vpbad1 )
								bu_ptbl_ins( &dang->bad_verts , (long *)vpbad1 );
						}
					}

					for( BU_LIST_FOR( test_vu , vertexuse , &dang->vb->vu_hd ) )
					{
						struct edgeuse *test_eu;

						if( *test_vu->up.magic_p != NMG_EDGEUSE_MAGIC )
							continue;

						test_eu = test_vu->up.eu_p;
						if( test_eu == eu->eumate_p )
							continue;


						if( test_eu->eumate_p->vu_p->v_p == dang->va )
							continue;

						if( test_eu->eumate_p == test_eu->radial_p )
						{
							/* another dangling edge, don't want
							 * nmg_find_path to wander off
							 * in this direction
							 */
							vpbada = test_eu->eumate_p->vu_p->v_p;
							vpbad1 = NMG_INDEX_GETP( vertex , copy_tbl , vpbada );
							if( vpbad1 )
								bu_ptbl_ins( &dang->bad_verts , (long *)vpbad1 );
						}
					}
				bu_ptbl_ins( &dangles , (long *)dang );
				}
			}
		}
	}

	/* now build the faces to connect the dangling edges */
	for( i=0 ; i<BU_PTBL_END( &dangles ) ; i++ )
	{
		struct dangle *dang;
		struct bu_ptbl *verts;

		dang = (struct dangle *)BU_PTBL_GET( &dangles , i );

		/* find vertices between vp1 and vp2 */
		verts = nmg_find_path( dang->v1 , dang->v2 , &dang->bad_verts , src );

		/* make faces connecting the two shells */
		if( BU_PTBL_END( verts ) > 1 )
			dang->needs_edge_breaking = nmg_make_connect_faces( dst , dang->va , dang->vb , verts , tol );
		else
		{
			bu_log( "nmg_open_shells_connect: unable to make connecting face\n" );
			bu_log( "\tfor edge from x%x ( %f %f %f )\n\t\tto x%x ( %f %f %f )\n",
				dang->va, V3ARGS( dang->va->vg_p->coord ),
				dang->vb, V3ARGS( dang->vb->vg_p->coord ) );
		}

		bu_ptbl_free( verts );
		bu_ptbl_free( &dang->bad_verts );
	}

	while( BU_PTBL_END( &dangles ) )
	{
		struct vertex *verts[4];
		struct dangle *dang;
		struct edgeuse *eu;
		fastf_t dist;
		point_t pca;
		int done;

		dang = (struct dangle *)BU_PTBL_GET( &dangles , BU_PTBL_END( &dangles )-1 );
		if( dang->needs_edge_breaking )
		{

			dang = (struct dangle *)BU_PTBL_GET( &dangles, BU_PTBL_END( &dangles ) - 1 );
			verts[0] = dang->va;
			verts[1] = dang->vb;
			verts[2] = dang->v1;
			verts[3] = dang->v2;

			for( i=0 ; i<3 ; i++ )
			{
				for( j=i+1 ; j<4 ; j++ )
				{
					eu = nmg_findeu( verts[i], verts[j],
						0, 0, 1 );
					if( !eu )
						continue;

					for( k=0 ; k<4 ; k++ )
					{
						if( k == i || k == j )
							continue;
						if( bn_dist_pt3_lseg3( &dist, pca,
							verts[i]->vg_p->coord,
							verts[j]->vg_p->coord,
							verts[k]->vg_p->coord,  tol ) )
							continue;

						(void)nmg_esplit( verts[k], eu, 1 );
					}
				}
			}
			done = 0;
			while( !done )
			{
				done = 1;
				for( i=0 ; i<3 ; i++ )
				{
					for( j=i+1 ; j<4 ; j++ )
					{
						struct edgeuse *eu2;

						eu = nmg_findeu( verts[i], verts[j], 0, 0, 1 );
						if( !eu )
							continue;

						eu2 = nmg_findeu( verts[i], verts[j], 0, eu, 1 );
						if( !eu2 )
							continue;

						if( eu2->vu_p->v_p == eu->vu_p->v_p )
							eu2 = eu2->eumate_p;
						nmg_je( eu, eu2 );
						done = 0;
					}
				}
			}
		}
		bu_ptbl_rm( &dangles , (long *)dang );
		bu_free( (char *)dang , "nmg_open_shells_connect: dang" );
	}

	bu_ptbl_free( &dangles);
	nmg_js( dst , src , tol );

	/* now glue it all together */
	bu_ptbl_init( &faces , 64, " &faces ");
	for( BU_LIST_FOR( fu , faceuse , &dst->fu_hd ) )
	{
		NMG_CK_FACEUSE( fu );
		if( fu->orientation == OT_SAME )
			bu_ptbl_ins( &faces , (long *)fu );
	}
	nmg_gluefaces( (struct faceuse **)BU_PTBL_BASEADDR( &faces) , BU_PTBL_END( &faces ), tol );
	bu_ptbl_free( &faces );

	return( 0 );
}

/*	N M G _ I N _ V E R T
 *
 *	Move vertex so it is at the intersection of the newly created faces
 *
 *	This routine is used by "nmg_extrude_shell" to move vertices. Each
 *	plane has already been moved a distance inward and
 *	the surface normals have been reversed.
 *
 *	if approximate is non-zero, then the coordinates of the new
 *	vertex may be calculated as the point with minimum distance
 *	to all the faces that intersect at the vertex for vertices
 *	where more than three faces intersect.
 *
 */
int
nmg_in_vert(struct vertex *new_v, const int approximate, const struct bn_tol *tol)
{
	struct bu_ptbl faces;
	int failed=0;
	int free_edges=0;
	int face_count;

	if( rt_g.NMG_debug & DEBUG_BASIC )
		bu_log( "nmg_in_vert( new_v=x%x at ( %f %f %f) )\n" , new_v , V3ARGS( new_v->vg_p->coord ) );

	NMG_CK_VERTEX( new_v );
	BN_CK_TOL( tol );

	bu_ptbl_init( &faces , 64, " &faces ");

	/* find all unique faces that intersect at this vertex (new_v) */
	face_count = nmg_find_isect_faces( new_v , &faces , &free_edges , tol );

	if( rt_g.NMG_debug & DEBUG_BASIC )
		bu_log( "\tnmg_in_vert: found %d faces at new_v, %d free_edges\n",
			face_count, free_edges );

	if( (face_count < 4 && !free_edges) || face_count < 3 )
	{
		if( nmg_simple_vertex_solve( new_v , &faces, tol ) )
		{
			failed = 1;
			bu_log( "Could not solve simple vertex\n" );
		}
	}
	else
	{
		if( nmg_complex_vertex_solve( new_v , &faces , free_edges , approximate , tol ) )
		{
			failed = 1;
			bu_log( "Could not solve complex vertex\n" );
		}
	}

	/* Free memory */
	bu_ptbl_free( &faces );

	return( failed );
}

/*		N M G _ M I R R O R _ M O D E L
 *
 *	mirror model across the y-axis
 *	this does not copy the model, it changes the
 *	model passed to it
 */

void
nmg_mirror_model(struct model *m)
{
	struct bu_ptbl vertices;
	struct nmgregion *r;
	int i;
	long *flags;

	NMG_CK_MODEL( m );

	/* mirror all vertices across the y axis */
	nmg_vertex_tabulate( &vertices , &m->magic );

	for( i=0 ; i<BU_PTBL_END( &vertices ) ; i++ )
	{
		struct vertex *v;

		v = (struct vertex *)BU_PTBL_GET( &vertices , i );
		NMG_CK_VERTEX( v );

		v->vg_p->coord[Y] = (-v->vg_p->coord[Y]);
	}
	(void)bu_ptbl_free( &vertices );

	/* adjust the direction of all the faces */
	flags = (long *)bu_calloc( m->maxindex , sizeof( long ) , "nmg_mirror_model: flags" );
	for( BU_LIST_FOR( r , nmgregion , &m->r_hd ) )
	{
		struct shell *s;

		for( BU_LIST_FOR( s , shell , &r->s_hd ) )
		{
			struct faceuse *fu;

			for( BU_LIST_FOR( fu , faceuse , &s->fu_hd ) )
			{
				int orientation;

				if( NMG_INDEX_TEST_AND_SET( flags , fu ) )
				{
					/* switch orientations of all faceuses */
					orientation = fu->orientation;
					fu->orientation = fu->fumate_p->orientation;
					fu->fumate_p->orientation = orientation;
					NMG_INDEX_SET( flags , fu->fumate_p );

					if( NMG_INDEX_TEST_AND_SET( flags , fu->f_p->g.plane_p ) )
					{
						/* correct normal vector */
						fu->f_p->g.plane_p->N[Y] = (-fu->f_p->g.plane_p->N[Y]);
					}
				}
			}
		}
	}

	bu_free( (char *)flags , "nmg_mirror_model: flags " );
}

int
nmg_kill_cracks(struct shell *s)
{
	struct faceuse *fu;
	struct faceuse *fu_next;
	int empty_shell=0;

	if( rt_g.NMG_debug & DEBUG_BASIC )
		bu_log( "nmg_kill_cracks( s=%x )\n" , s );

	NMG_CK_SHELL( s );
#if 1
	/* Loops may be inadvertently connected with a crack,
	 * this code is to dissconnect them and kill the connecting crack.
	 * Look for cracks that are two EU's from one loop that 
	 * share the same edge, but are not consectutive in the loop.
	 * This will require a split_lu to handle.
	 */
	for( BU_LIST_FOR( fu, faceuse, &s->fu_hd ) )
	{
		struct loopuse *lu;
		NMG_CK_FACEUSE( fu );

		if( fu->orientation != OT_SAME )
			continue;

		for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
		{
			struct edgeuse *eu;

			NMG_CK_LOOPUSE( lu );

			if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
				continue;
again:
			for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
			{
				struct edgeuse *eu2;

				NMG_CK_EDGEUSE( eu );

				for( BU_LIST_FOR( eu2, edgeuse, &lu->down_hd ) )
				{
					struct loopuse *new_lu1;
					struct loopuse *new_lu2;

					if( eu == eu2 )
						continue;

					/* check if eu and eu2 share an edge */
					if( eu->e_p != eu2->e_p )
						continue;

					if( eu2 == BU_LIST_PNEXT_CIRC( edgeuse, &eu->l ) )
					{
						/* this is just a regular crack, catch it later */
						continue;
					}
					if( eu2 == BU_LIST_PPREV_CIRC( edgeuse, &eu->l ) )
					{
						/* this is just a regular crack, catch it later */
						continue;
					}

					if( eu->vu_p->v_p == eu2->vu_p->v_p )
					{
						/* This must be part of an accordion, catch it later */
						continue;
					}

					if( eu->eumate_p->vu_p->v_p != eu2->vu_p->v_p )
					{
						/* this is a problem!!! */
						bu_log( "nmg_kill_cracks: found a strange crack at eu1=x%x, eu2=x%x\n", eu, eu2 );
						nmg_pr_lu_briefly( lu, "" );
						rt_bomb( "nmg_kill_cracks: found a strange crack\n" );
					}

					new_lu1 = nmg_split_lu_at_vu( lu, eu->vu_p );
					new_lu2 = nmg_split_lu_at_vu( new_lu1, eu2->vu_p );

					nmg_klu( new_lu2 );

					nmg_lu_reorient( lu );
					nmg_lu_reorient( new_lu1 );

					goto again;
				}
			}
		}
	}
#endif
	fu = BU_LIST_FIRST( faceuse, &s->fu_hd );
	while( BU_LIST_NOT_HEAD( fu, &s->fu_hd ) )
	{
		struct loopuse *lu;
		struct loopuse *lu_next;
		int empty_face=0;

		NMG_CK_FACEUSE( fu );

		fu_next = BU_LIST_PNEXT( faceuse, &fu->l );
		while( BU_LIST_NOT_HEAD( fu_next, &s->fu_hd )
			&& fu_next == fu->fumate_p )
				fu_next = BU_LIST_PNEXT( faceuse, &fu_next->l );

		lu = BU_LIST_FIRST( loopuse, &fu->lu_hd );
		while( BU_LIST_NOT_HEAD( lu, &fu->lu_hd ) )
		{
			struct edgeuse *eu;
			struct edgeuse *eu_next;
			int empty_loop=0;

			NMG_CK_LOOPUSE( lu );

			lu_next = BU_LIST_PNEXT( loopuse, &lu->l );

			if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
			{
				lu = lu_next;
				continue;
			}

crack_top:
			for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
			{
				NMG_CK_EDGEUSE( eu );

				eu_next = BU_LIST_PNEXT_CIRC( edgeuse, &eu->l );
				NMG_CK_EDGEUSE( eu_next );
				/* check if eu and eu_next form a jaunt */
				if( eu->vu_p->v_p != eu_next->eumate_p->vu_p->v_p )
					continue;

				if( nmg_keu( eu ) )
					empty_loop = 1;
				else if( nmg_keu( eu_next ) )
					empty_loop = 1;

				if( empty_loop )
					break;

				goto crack_top;
			}
			if( empty_loop )
			{
				if( nmg_klu( lu ) )
				{
					empty_face = 1;
					break;
				}
			}
			lu = lu_next;
		}
		if( empty_face )
		{
			if( nmg_kfu( fu ) )
			{
				empty_shell = 1;
				break;
			}
		}
		fu = fu_next;
	}

	if( empty_shell )
	{
		if( rt_g.NMG_debug & DEBUG_BASIC )
			bu_log( "nmg_kill_cracks: ret = %d\n" , empty_shell );
		return( empty_shell );
	}


	if( rt_g.NMG_debug & DEBUG_BASIC )
		bu_log( "nmg_kill_cracks: ret = %d\n" , empty_shell );

	return( empty_shell );
}

int
nmg_kill_zero_length_edgeuses(struct model *m)
{
	struct nmgregion *r;
	int empty_model=0;

	if( rt_g.NMG_debug & DEBUG_BASIC )
		bu_log( "nmg_kill_zero_length_edgeuses( m=%x )\n", m );

	NMG_CK_MODEL( m );

	r = BU_LIST_FIRST( nmgregion, &m->r_hd );
	while( BU_LIST_NOT_HEAD( r, &m->r_hd ) )
	{
		struct nmgregion *next_r;
		struct shell *s;
		int empty_region=0;

		NMG_CK_REGION( r );

		next_r = BU_LIST_PNEXT( nmgregion, &r->l );

		s = BU_LIST_FIRST( shell, &r->s_hd );
		while( BU_LIST_NOT_HEAD( s, &r->s_hd ) )
		{
			struct shell *next_s;
			struct faceuse *fu;
			int empty_shell=0;

			NMG_CK_SHELL( s );

			next_s = BU_LIST_PNEXT( shell, &s->l );

			fu = BU_LIST_FIRST( faceuse, &s->fu_hd );
			while( BU_LIST_NOT_HEAD( fu, &s->fu_hd ) )
			{
				struct loopuse *lu;
				struct faceuse *next_fu;
				int empty_fu=0;

				NMG_CK_FACEUSE( fu );

				next_fu = BU_LIST_PNEXT( faceuse, &fu->l );
				if( next_fu == fu->fumate_p )
					next_fu = BU_LIST_PNEXT( faceuse, &next_fu->l );

				lu = BU_LIST_FIRST( loopuse, &fu->lu_hd );
				while( BU_LIST_NOT_HEAD( lu, &fu->lu_hd ) )
				{
					struct edgeuse *eu;
					struct loopuse *next_lu;
					int empty_loop=0;

					NMG_CK_LOOPUSE( lu );

					next_lu = BU_LIST_PNEXT( loopuse, &lu->l );

					if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
					{
						lu = next_lu;
						continue;
					}

					eu = BU_LIST_FIRST( edgeuse, &lu->down_hd );
					while( BU_LIST_NOT_HEAD( eu, &lu->down_hd ) )
					{
						struct edgeuse *next_eu;
						struct edgeuse *next_eu_circ;

						NMG_CK_EDGEUSE( eu );

						next_eu = BU_LIST_PNEXT( edgeuse, &eu->l );
						next_eu_circ = BU_LIST_PNEXT_CIRC( edgeuse, &eu->l );

						if( eu->vu_p->v_p == next_eu_circ->vu_p->v_p )
						{
							/* found a zero length edgeuse */
							if( nmg_keu( eu ) )
								empty_loop = 1;
						}
						eu = next_eu;
					}
					if( empty_loop )
					{
						if( nmg_klu( lu ) )
							empty_fu = 1;
					}
					lu = next_lu;
				}
				if( empty_fu )
				{
					if( nmg_kfu( fu ) )
						empty_shell = 1;
				}
				fu = next_fu;
			}
			if( empty_shell )
			{
				if( nmg_ks( s ) )
					empty_region = 1;
			}
			s = next_s;
		}
		if( empty_region )
		{
			if( nmg_kr( r ) )
				empty_model = 1;
		}
		r = next_r;
	}

	if( empty_model )
		return( 1 );
	else
		return( 0 );
}

/*	N M G _ M A K E _ F A C E S _ W I T H I N _ T O L
 *
 * Check all vertices on faces of specified shell. Any face containing
 * vertices more than tol->dist off the plane of the face will be
 * triangulated and broken into seperate faces
 */
void
nmg_make_faces_within_tol(struct shell *s, const struct bn_tol *tol)
{
	struct bu_ptbl faceuses;
	struct faceuse *fu;
	int i;

	NMG_CK_SHELL( s );
	BN_CK_TOL( tol );

	bu_ptbl_init( &faceuses, 64, " &faceuses");

	for( BU_LIST_FOR( fu, faceuse, &s->fu_hd ) )
	{
		NMG_CK_FACEUSE( fu );

		if( fu->orientation != OT_SAME )
			continue;

		bu_ptbl_ins( &faceuses, (long *)fu );
	}

	for (i = 0; i < BU_PTBL_END( &faceuses ); i++)
	{
		fu = (struct faceuse *)BU_PTBL_GET( &faceuses, i );

		/* check if all the vertices for this face lie on the plane */
		if( nmg_ck_fu_verts( fu, fu->f_p, tol ) )
		{
			plane_t pl;

			/* Need to triangulate this face */
			nmg_triangulate_fu( fu, tol );

			/* split each triangular loop into its own face */
			(void)nmg_split_loops_into_faces( &fu->l.magic, tol );

			if( nmg_calc_face_plane( fu, pl ) )
			{
				bu_log( "nmg_make_faces_within_tol(): nmg_calc_face_plane() failed\n" );
				rt_bomb( "nmg_make_faces_within_tol(): nmg_calc_face_plane() failed" );
			}
			nmg_face_new_g( fu, pl );
		}
	}

	for( BU_LIST_FOR( fu, faceuse, &s->fu_hd ) )
	{
		plane_t pl;

		if( fu->orientation != OT_SAME )
			continue;

		if( bu_ptbl_locate( &faceuses, (long *)fu ) != (-1) )
			continue;

		if( nmg_calc_face_plane( fu, pl ) )
		{
			bu_log( "nmg_make_faces_within_tol(): nmg_calc_face_plane() failed\n" );
			rt_bomb( "nmg_make_faces_within_tol(): nmg_calc_face_plane() failed" );
		}

		nmg_face_new_g( fu, pl );
	}

	bu_ptbl_free( &faceuses);
}

void
nmg_intersect_loops_self(struct shell *s, const struct bn_tol *tol)
{
	struct faceuse *fu;
	struct bu_ptbl edgeuses;

	NMG_CK_SHELL( s );
	BN_CK_TOL( tol );

	bu_ptbl_init( &edgeuses, 64, " &edgeuses");

	for( BU_LIST_FOR( fu, faceuse, &s->fu_hd ) )
	{
		struct loopuse *lu;

		NMG_CK_FACEUSE( fu );

		if( fu->orientation != OT_SAME )
			continue;

		for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
		{
			struct edgeuse *eu;
			int i,j;

			NMG_CK_LOOPUSE( lu );

			if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
				continue;
top:
			for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
				bu_ptbl_ins( &edgeuses, (long *)eu );

			for( i=0 ; i<BU_PTBL_END( &edgeuses ); i++ )
			{
				vect_t eu_dir;

				eu = (struct edgeuse *)BU_PTBL_GET( &edgeuses, i );
				VSUB2( eu_dir, eu->eumate_p->vu_p->v_p->vg_p->coord, eu->vu_p->v_p->vg_p->coord );

				for( j=i+1 ; j<BU_PTBL_END( &edgeuses ) ; j++ )
				{
					struct edgeuse *eu2;
					struct edgeuse *new_eu=(struct edgeuse *)NULL;
					struct vertex *v;
					vect_t eu2_dir;
					point_t int_pt;
					fastf_t dist[2];
					int code;

					eu2 = (struct edgeuse *)BU_PTBL_GET( &edgeuses, j );
					VSUB2( eu2_dir, eu2->eumate_p->vu_p->v_p->vg_p->coord, eu2->vu_p->v_p->vg_p->coord );

					code = bn_isect_lseg3_lseg3( dist, eu->vu_p->v_p->vg_p->coord, eu_dir,
						eu2->vu_p->v_p->vg_p->coord, eu2_dir, tol );

					if( code < 0 )	/* no intersection */
						continue;

					if( code == 0 )
					{
						if( dist[0] > 0.0 && dist[0] != 1.0 )
						{
							VJOIN1( int_pt, eu->vu_p->v_p->vg_p->coord, dist[0], eu_dir );
							v = (struct vertex *)NULL;
							new_eu = nmg_ebreaker( v, eu, tol );
							nmg_vertex_gv( new_eu->vu_p->v_p, int_pt );
						}
						if( dist[1] > 0.0 && dist[1] != 1.0 )
						{
							VJOIN1( int_pt, eu->vu_p->v_p->vg_p->coord, dist[1], eu_dir );
							v = (struct vertex *)NULL;
							new_eu = nmg_ebreaker( v, eu, tol );
							nmg_vertex_gv( new_eu->vu_p->v_p, int_pt );
						}
					}
					else
					{
						if( dist[0] != 0.0 && dist[0] != 1.0 )
						{
							VJOIN1( int_pt, eu->vu_p->v_p->vg_p->coord, dist[0], eu_dir );
							v = (struct vertex *)NULL;
							new_eu = nmg_ebreaker( v, eu, tol );
							nmg_vertex_gv( new_eu->vu_p->v_p, int_pt );
						}
						if( dist[1] != 0.0 && dist[1] != 1.0 )
						{
							VJOIN1( int_pt, eu2->vu_p->v_p->vg_p->coord, dist[1], eu2_dir );
							v = (struct vertex *)NULL;
							new_eu = nmg_ebreaker( v, eu2, tol );
							nmg_vertex_gv( new_eu->vu_p->v_p, int_pt );
						}

					}
					if( new_eu )
					{
						bu_ptbl_reset( &edgeuses);
						goto top;
					}
				}
			}

			bu_ptbl_reset( &edgeuses);
		}
	}

	bu_ptbl_free( &edgeuses);
}

/*	R T _ J O I N _ C N U R B S
 *
 * Join a list of cnurb structs into a single cnurb.
 * The curves must have matching endpoints, otherwise
 * nothing is done and (struct cnurb *)NULL is returned.
 *
 * Returns:
 *	A single cnurb structure that joins all the
 *	cnurbs on the list.
 */
struct edge_g_cnurb *
rt_join_cnurbs(struct bu_list *crv_head)
{
	struct edge_g_cnurb *crv,*next_crv;
	struct edge_g_cnurb *new_crv=(struct edge_g_cnurb *)NULL;
	fastf_t knot_delta=0.0;
	fastf_t last_knot=0.0;
	int ncoords;
	int knot_index=(-1);
	int max_order=0;
	int ctl_points=1;
	int ctl_index=(-1);
	int knot_length=0;
	int pt_type=0;
	int curve_count=0;
	int i,j;

	BU_CK_LIST_HEAD( crv_head );

	/* Check that all curves are the same pt_type and
	 * have mutliplicity equal to order at endpoints.
	 */
	for( BU_LIST_FOR( crv, edge_g_cnurb, crv_head ) )
	{
		curve_count++;
		rt_nurb_c_print( crv);
		if( crv->order > max_order )
			max_order = crv->order;

		i = 0;
		while( crv->k.knots[++i] == crv->k.knots[0] );
		if( i != crv->order )
		{
			bu_log( "Curve does not have multiplicity equal to order at start:\n" );
			rt_nurb_c_print( crv);
			return( new_crv );
		}

		i = crv->k.k_size - 1;
		while( crv->k.knots[--i] == crv->k.knots[crv->k.k_size - 1] );
		if( crv->k.k_size - i - 1 != crv->order )
		{
			bu_log( "Curve does not have multiplicity equal to order at end:\n" );
			rt_nurb_c_print( crv);
			return( new_crv );
		}

		if( pt_type == 0 )
			pt_type = crv->pt_type;
		else
		{
			if( crv->pt_type != pt_type )
			{
				bu_log( "rt_join_cnurbs: curves are not the same pt_type (%d vs %d)\n",
					pt_type, crv->pt_type );
				return( new_crv );
			}
		}
	}

	/* If there is only one entry on list, just return it */
	if( curve_count < 2 )
	{
		crv = BU_LIST_FIRST( edge_g_cnurb, crv_head );
		BU_LIST_DEQUEUE( &crv->l );
		return( crv );
	}

	/* Raise each curve to order max_order */
	for( BU_LIST_FOR( crv, edge_g_cnurb, crv_head ) )
	{
		if( crv->order == max_order )
			continue;

		/* This curve must have its order raised to max_order */
		/* XXXX Need a routine to raise order of a curve */
		rt_bomb( "rt_join_cnurbs: Need to raise order of curve\n" );
	}

	/* Check that endponts match */
	crv = BU_LIST_FIRST( edge_g_cnurb, crv_head );
	ncoords = RT_NURB_EXTRACT_COORDS( crv->pt_type );
	next_crv = BU_LIST_NEXT( edge_g_cnurb, &crv->l );
	while( BU_LIST_NOT_HEAD( &next_crv->l, crv_head ) )
	{
		int endpoints_equal;

		endpoints_equal = 1;

		for( i=0 ; i<ncoords ; i++ )
		{
			/* It is tempting to use a tolerance here, but these coordinates may be
			 * x/y/z or x/y or u/v, ...
			 */
			if( crv->ctl_points[(crv->c_size-1)*ncoords+i] == next_crv->ctl_points[i] )
				continue;
			else
			{
				endpoints_equal = 0;
				break;
			}
		}
		if( endpoints_equal )
		{
			/* Nothing needed here, go to next curve */
			crv = next_crv;
			next_crv = BU_LIST_NEXT( edge_g_cnurb, &crv->l );
			continue;
		}

		bu_log( "rt_join_cnurbs: Curve endpoints do not match:\n" );
		rt_nurb_c_print( crv );
		rt_nurb_c_print( next_crv );
		return( new_crv );
	}

	/* Get new knot size and polygon size */
	crv = BU_LIST_FIRST( edge_g_cnurb, crv_head );
	knot_length = crv->order;
	for( BU_LIST_FOR( crv, edge_g_cnurb, crv_head ) )
	{
		ctl_points += (crv->c_size - 1);
		knot_length += (crv->k.k_size - crv->order - 1);

	}
	knot_length++;

	new_crv = rt_nurb_new_cnurb( max_order, knot_length, ctl_points, pt_type );

	crv = BU_LIST_FIRST( edge_g_cnurb, crv_head );

	/* copy first knot values from first curve */
	for( i=0 ; i<crv->order ; i++ )
		new_crv->k.knots[++knot_index] = crv->k.knots[i];

	/* copy first control point from first curve */
	for( j=0 ; j<ncoords ; j++ )
		new_crv->ctl_points[j] = crv->ctl_points[j];

	ctl_index = 0;
	knot_delta = new_crv->k.knots[knot_index];

	/* copy each curve to the new combined curve */
	for( BU_LIST_FOR( crv, edge_g_cnurb, crv_head ) )
	{
		/* copy interior knots */
		for( i=crv->order ; i<crv->k.k_size-crv->order ; i++ )
		{
			new_crv->k.knots[++knot_index] = crv->k.knots[i] + knot_delta;
		}

		/* copy endpoint knots (reduce multiplicity by one) */
		for( i=0 ; i<crv->order-1 ; i++ )
			new_crv->k.knots[++knot_index] = crv->k.knots[crv->k.k_size-1] + knot_delta;

		knot_delta += crv->k.knots[crv->k.k_size-1];
		last_knot = new_crv->k.knots[knot_index];

		/* copy control points (skip duplicate initial point) */
		for( i=1 ; i<crv->c_size ; i++ )
		{
			ctl_index++;
			VMOVEN( &new_crv->ctl_points[ctl_index*ncoords], &crv->ctl_points[i*ncoords], ncoords );
		}
	}
	new_crv->k.knots[++knot_index] = last_knot;

	return( new_crv );
}

/*	R T _ A R C 2 D _ T O _ C N U R B
 *
 * Convert a 2D arc to a NURB curve.
 *	point_type indicates what type of CNURB is requested.
 *	The arc start, end, and center must be at the same Z
 *	coordinate value if point_type is RT_NURB_PT_XYZ. For values of
 *	point_type of RT_NURB_PT_XY or RT_NURB_PT_UV, the Z coordinate
 *	is ignored. (Note that point_type must be one of the point types
 *	defined in nurb.h). The arc is constructed counter-clockwise
 *	(as viewed from the +Z direction).
 */
struct edge_g_cnurb *
rt_arc2d_to_cnurb(fastf_t *i_center, fastf_t *i_start, fastf_t *i_end, int point_type, const struct bn_tol *tol)
{
	struct edge_g_cnurb *crv;
	struct bu_list crv_head;
	point_t center;
	point_t start;
	point_t end;
	double angle;
	double angles[3];
	double radius;
	double tmp_radius;
	vect_t v1, v2;
	vect_t ref1, ref2;
	vect_t norm;
	point_t start1;
	point_t end1;
	int nsegs;
	int pt_type;
	int ncoords = 0;
	int i;

	BN_CK_TOL( tol );

	VMOVE( start, i_start )
	VMOVE( center, i_center )
	VMOVE( end, i_end )
	switch( point_type )
	{
		case RT_NURB_PT_XY:
		case RT_NURB_PT_UV:
			ncoords = 3;
			start[Z] = 0.0;
			center[Z] = 0.0;
			end[Z] = 0.0;
			break;
		case RT_NURB_PT_XYZ:
		case RT_NURB_PT_DATA:
		case RT_NURB_PT_PROJ:
			ncoords = 4;
			break;
	}

	if( point_type == RT_NURB_PT_XYZ )
	{
		/* check for points at same Z-coordinate value */
		if( center[Z] - start[Z] > tol->dist )
		{
			bu_log( "rt_arc2d_to_cnurb: center and start points not at same Z value (%g vs %g)\n",
					center[Z], start[Z] );
			return( (struct edge_g_cnurb *)NULL );
		}

		if( end[Z] - start[Z] > tol->dist )
		{
			bu_log( "rt_arc2d_to_cnurb: end and start points not at same Z value (%g vs %g)\n",
					end[Z], start[Z] );
			return( (struct edge_g_cnurb *)NULL );
		}

		if( end[Z] - center[Z] > tol->dist )
		{
			bu_log( "rt_arc2d_to_cnurb: end and center points not at same Z value (%g vs %g)\n",
					end[Z], center[Z] );
			return( (struct edge_g_cnurb *)NULL );
		}
	}

	/* point type is point_type with weighting factor (rational) */
	pt_type = RT_NURB_MAKE_PT_TYPE( ncoords, point_type, RT_NURB_PT_RATIONAL );

	/* calculate radius twice */
	if( ncoords == 4 )
	{
		VSUB2( v1, start, center );
		radius = MAGNITUDE( v1 );
		VSUB2( v2, end, center );
		tmp_radius = MAGNITUDE( v2 );
	}
	else
	{
		radius = sqrt( (start[X] - center[X])*(start[X] - center[X]) +
			(start[Y] - center[Y])*(start[Y] - center[Y]) );
		tmp_radius = sqrt( (end[X] - center[X])*(end[X] - center[X]) +
			(end[Y] - center[Y])*(end[Y] - center[Y]) );
	}

	/* make sure radii are consistent */
	if( !NEAR_ZERO( radius - tmp_radius, tol->dist ) )
	{
		bu_log( "rt_arc2d_to_cnurb: distances from center to start and center to end are different\n" );
		bu_log( "                        (%g and %g)\n", radius, tmp_radius );
		return( (struct edge_g_cnurb *)NULL );
	}

	/* construct coord system ref1,ref2,norm */
	VSET( norm, 0.0, 0.0, 1.0 );
	VMOVE( ref1, v1 );
	VSCALE( ref1, ref1, 1.0/radius );
	VCROSS( ref2, norm, ref1 );

	/* calculate angle of arc */
	angle = atan2( VDOT( v2, ref2 ), VDOT( v2, ref1 ) );
	if( angle <= 0.0 )
		angle += 2.0*bn_pi;

	if( angle < 150.0*bn_pi/180.0 ) /* angle is reasonable to do in one segment */
	{
		fastf_t dist1, dist2;
		vect_t t1, t2;
		int ret_val;

		/* second control point is intersection of tangent lines */
		VMOVE( t1, ref2 );
		if( VDOT( t1, v2 ) > 0.0 )
			VREVERSE( t1, t1 );
		VCROSS( t2, v2, norm );
		VUNITIZE( t2 );
		if( VDOT( t2, v1 ) > 0.0 )
			VREVERSE( t2, t2 );
		if( (ret_val=bn_isect_line3_line3( &dist1, &dist2, start, t1, end, t2, tol )) < 1 )
		{
			bu_log( "rt_arc2d_to_cnurb: Cannot calculate second control point\n" );
			bu_log( "                   bn_isect_line3_line3 returns %d\n" , ret_val );
			return( (struct edge_g_cnurb *)NULL );
		}

		/* Get memory for this curve (order=3, 6 knot values, 3 control points) */
		crv = rt_nurb_new_cnurb( 3, 6, 3, pt_type );

		/* Set knot values */
		for( i=0 ; i<3 ; i++ )
			crv->k.knots[i] = 0.0;
		for( i=3 ; i<6 ; i++ )
			crv->k.knots[i] = 1.0;

		/* First and third control points are start and end */
		VMOVEN( crv->ctl_points, start, ncoords-1 )
		VMOVEN( &crv->ctl_points[8], end, ncoords-1 )

		/* weights are 1.0 for the endpoints */
		crv->ctl_points[ncoords-1] = 1.0;
		crv->ctl_points[3*ncoords-1] = 1.0;

		/* second control point is as calculated above */
		VJOIN1N( &crv->ctl_points[ncoords], start, dist1, t1, ncoords-1 )

		/* weight for second control point is cosine of half the arc angle */
		crv->ctl_points[2*ncoords-1] = cos( angle/2.0 );

		/* scale middle point by its weight */
		VSCALEN( &crv->ctl_points[ncoords], &crv->ctl_points[ncoords], crv->ctl_points[2*ncoords-1], ncoords-1 )

		return( crv );
	}

	/* Angle is too great for one segment.
	 * Make up to three segments and join them.
	 */

	if( angle < 1.5*bn_pi )
	{
		/* do it in two segments */
		nsegs = 2;
		angles[0] = angle/2.0;
		angles[1] = angle;
	}
	else
	{
		/* use three segments */
		nsegs = 3;
		angles[0] = angle/3.0;
		angles[1] = 2.0*angles[0];
		angles[2] = angle;
	}

	/* initialize bu_list structure to hold list of curves */
	BU_LIST_INIT( &crv_head );

	/* Make each arc segment */
	VMOVE( end1, start );
	for( i=0 ; i<nsegs ; i++ )
	{
		VMOVE( start1, end1 );
		if( i == nsegs-1 )
			VMOVE( end1, end )
		else
			VJOIN2( end1, center, radius*cos( angles[i] ), ref1, radius*sin( angles[i] ), ref2 )

		crv = rt_arc2d_to_cnurb( center, start1, end1, point_type, tol );
		BU_LIST_INSERT( &crv_head, &crv->l );
	}

	/* join the arc segments into one edge_g_cnurb */
	crv = rt_join_cnurbs( &crv_head );

	return( crv );
}

int
nmg_break_edge_at_verts(struct edge *e, struct bu_ptbl *verts, const struct bn_tol *tol)
{
	int break_count=0;
	int j;
	struct vertex *va,*vb;
	struct bu_ptbl edges;

	BN_CK_TOL( tol );
	NMG_CK_EDGE( e );
	BU_CK_PTBL( verts );

	bu_ptbl_init( &edges, 64, " &edges");
	bu_ptbl_ins( &edges, (long *)e );

start:

	while( BU_PTBL_END( &edges ) )
	{
		struct edge *e1;
		struct edgeuse *eu;

		e1 = (struct edge *)BU_PTBL_GET( &edges, BU_PTBL_END( &edges )-1 );
		NMG_CK_EDGE( e1 );
		eu = e1->eu_p;
		NMG_CK_EDGEUSE( eu );

		va = eu->vu_p->v_p;
		NMG_CK_VERTEX( va );
		vb = eu->eumate_p->vu_p->v_p;
		NMG_CK_VERTEX( vb );

		for( j=0 ; j<BU_PTBL_END( verts ) ; j++ )
		{
			struct edgeuse *eu_new;
			struct vertex *v;
			fastf_t dist;
			point_t pca;

			v = (struct vertex *)BU_PTBL_GET( verts, j );
			NMG_CK_VERTEX( v );

			if( v == va || v == vb )
				continue;

			if( bn_dist_pt3_lseg3( &dist, pca, va->vg_p->coord, vb->vg_p->coord, v->vg_p->coord, tol ) )
				continue;

			eu_new = nmg_esplit( v, eu, 1 );
			break_count++;

			bu_ptbl_rm( &edges, (long *)e1 );
			bu_ptbl_ins( &edges, (long *)eu->e_p );
			bu_ptbl_ins( &edges, (long *)eu_new->e_p );

			goto start;
		}
		bu_ptbl_rm( &edges, (long *)e1 );
	}
	bu_ptbl_free( &edges);
	return( break_count );
}

int
nmg_break_edges(long int *magic_p, const struct bn_tol *tol)
{
	struct bu_ptbl edges;
	struct bu_ptbl verts;
	int i;
	int break_count=0;

	BN_CK_TOL( tol );

	nmg_edge_tabulate( &edges, magic_p );
	nmg_vertex_tabulate( &verts, magic_p );

	for( i=0 ; i<BU_PTBL_END( &edges ); i++ )
	{
		struct edge *e;
		int edge_break_count=0;

		e = (struct edge *)BU_PTBL_GET( &edges, i );
		NMG_CK_EDGE( e );
		edge_break_count = nmg_break_edge_at_verts( e, &verts, tol );
		break_count += edge_break_count;
	}
	bu_ptbl_free( &edges);
	bu_ptbl_free( &verts);

	return( break_count );
}


static int
Shell_is_arb(struct shell *s, struct bu_ptbl *tab)
{
	struct faceuse *fu;
	struct face *f;
	int four_verts=0;
	int three_verts=0;
	int face_count=0;
	int loop_count;

	NMG_CK_SHELL( s );

	nmg_vertex_tabulate( tab, &s->l.magic );

	if( BU_PTBL_END( tab ) > 8 || BU_PTBL_END( tab ) < 4 )
		goto not_arb;

	for( BU_LIST_FOR( fu, faceuse, &s->fu_hd ) )
	{
		struct loopuse *lu;
		vect_t fu_norm;

		NMG_CK_FACEUSE( fu );

		if( fu->orientation != OT_SAME )
			continue;

		f = fu->f_p;
		NMG_CK_FACE( f );

		if( *f->g.magic_p != NMG_FACE_G_PLANE_MAGIC )
			goto not_arb;

		NMG_GET_FU_NORMAL( fu_norm, fu );

		loop_count = 0;
		for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
		{
			struct edgeuse *eu;

			NMG_CK_LOOPUSE( lu );

			if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
				goto not_arb;

			loop_count++;

			/* face must be a single loop */
			if( loop_count > 1 )
				goto not_arb;

			for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
			{
				struct edgeuse *eu_radial;
				struct faceuse *fu_radial;
				struct face *f_radial;
				vect_t norm_radial;
				vect_t eu_dir;
				vect_t cross;
				fastf_t dot;

				NMG_CK_EDGEUSE( eu );

				eu_radial = nmg_next_radial_eu( eu, s, 0 );

				/* Can't have any dangling faces */
				if( eu_radial == eu || eu_radial == eu->eumate_p )
					goto not_arb;

				fu_radial = nmg_find_fu_of_eu( eu_radial );
				NMG_CK_FACEUSE( fu_radial );

				if( fu_radial->orientation != OT_SAME )
					fu_radial = fu_radial->fumate_p;

				f_radial = fu_radial->f_p;
				NMG_CK_FACE( f_radial );

				/* faces must be planar */
				if( *f_radial->g.magic_p != NMG_FACE_G_PLANE_MAGIC )
					goto not_arb;


				/* Make sure shell is convex by checking that edguses
				 * run in direction fu_norm X norm_radial
				 */
				NMG_GET_FU_NORMAL( norm_radial, fu_radial );

				dot = VDOT( norm_radial, fu_norm );

				if( !NEAR_ZERO( dot - 1.0, 0.00001 ) )
				{

					VCROSS( cross, fu_norm, norm_radial );

					if( eu->orientation == OT_NONE )
					{
						VSUB2( eu_dir, eu->vu_p->v_p->vg_p->coord, eu->eumate_p->vu_p->v_p->vg_p->coord )
						if( eu->orientation != OT_SAME )
							VREVERSE( eu_dir, eu_dir )
					}
					else
						VMOVE( eu_dir, eu->g.lseg_p->e_dir )

					if( eu->orientation == OT_SAME || eu->orientation == OT_NONE )
					{
						if( VDOT( cross, eu_dir ) < 0.0 )
							goto not_arb;
					}
					else
					{
						if( VDOT( cross, eu_dir ) > 0.0 )
							goto not_arb;
					}
				}
			}
		}
	}

	/* count face types */
	for( BU_LIST_FOR( fu, faceuse, &s->fu_hd ) )
	{
		struct loopuse *lu;
		int vert_count=0;

		if( fu->orientation != OT_SAME )
			continue;

		face_count++;
		for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
		{
			struct edgeuse *eu;

			for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
				vert_count++;
		}

		if( vert_count == 3 )
			three_verts++;
		else if( vert_count == 4 )
			four_verts++;
	}

	/* must have only three and four vertices in each face */
	if( face_count != three_verts + four_verts )
		goto not_arb;

	/* which type of arb is this?? */
	switch( BU_PTBL_END( tab ) )
	{
		case 4:		/* each face must have 3 vertices */
			if( three_verts != 4 || four_verts != 0 )
				goto not_arb;
			break;
		case 5:		/* one face with 4 verts, four with 3 verts */
			if( four_verts != 1 || three_verts != 4 )
				goto not_arb;
			break;
		case 6:		/* three faces with 4 verts, two with 3 verts */
			if( three_verts != 2 || four_verts != 3 )
				goto not_arb;
			break;
		case 7:		/* four faces with 4 verts, two with 3 verts */
			if( four_verts != 4 || three_verts != 2 )
				goto not_arb;
			break;
		case 8:		/* each face must have 4 vertices */
			if( four_verts != 6 || three_verts != 0 )
				goto not_arb;
			break;
	}

	return( BU_PTBL_END( tab ) );


not_arb:
	bu_ptbl_free( tab);
	return( 0 );
}

/*		N M G _ T O _ A R B
 *
 *	Converts an NMG to an ARB, if possible.
 *
 *	NMG must have been coplanar face merged and simplified
 *
 *	Returns:
 *		1 - Equivalent ARB was constructed
 *		0 - Cannot construct an equivalent ARB
 *
 *	The newly constructed arb is in "arb_int"
 */
int
nmg_to_arb( const struct model *m, struct rt_arb_internal *arb_int )
{
	struct nmgregion *r;
	struct shell *s;
	struct faceuse *fu;
	struct loopuse *lu;
	struct edgeuse *eu;
	struct vertex *v;
	struct edgeuse *eu_start;
	struct faceuse *fu1;
	struct bu_ptbl tab;
	int face_verts;
	int i,j;
	int found;
	int ret_val = 0;

	NMG_CK_MODEL( m );

	r = BU_LIST_FIRST( nmgregion, &m->r_hd );

	/* must be a single region */
	if( BU_LIST_NEXT_NOT_HEAD( &r->l, &m->r_hd ) )
		return( 0 );

	s = BU_LIST_FIRST( shell, &r->s_hd );
	NMG_CK_SHELL( s );

	/* must be a single shell */
	if( BU_LIST_NEXT_NOT_HEAD( &s->l, &r->s_hd ) )
		return( 0 );

	switch( Shell_is_arb( s, &tab ) )
	{
		case 0:
			ret_val = 0;
			break;
		case 4:
			v = (struct vertex *)BU_PTBL_GET( &tab, 0 );
			NMG_CK_VERTEX( v );
			VMOVE( arb_int->pt[0], v->vg_p->coord );
			v = (struct vertex *)BU_PTBL_GET( &tab, 1 );
			NMG_CK_VERTEX( v );
			VMOVE( arb_int->pt[1], v->vg_p->coord );
			v = (struct vertex *)BU_PTBL_GET( &tab, 2 );
			NMG_CK_VERTEX( v );
			VMOVE( arb_int->pt[2], v->vg_p->coord );
			VMOVE( arb_int->pt[3], v->vg_p->coord );
			v = (struct vertex *)BU_PTBL_GET( &tab, 3 );
			NMG_CK_VERTEX( v );
			VMOVE( arb_int->pt[4], v->vg_p->coord );
			VMOVE( arb_int->pt[5], v->vg_p->coord );
			VMOVE( arb_int->pt[6], v->vg_p->coord );
			VMOVE( arb_int->pt[7], v->vg_p->coord );

			bu_ptbl_free( &tab);
			ret_val = 1;
			break;
		case 5:
			fu = BU_LIST_FIRST( faceuse, &s->fu_hd );
			face_verts = 0;
			while( face_verts != 4 )
			{
				face_verts = 0;
				fu = BU_LIST_PNEXT_CIRC( faceuse, &fu->l );
				lu = BU_LIST_FIRST( loopuse, &fu->lu_hd );
				for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
					face_verts++;
			}
			NMG_CK_FACEUSE( fu );
			if( fu->orientation != OT_SAME )
				fu = fu->fumate_p;
			NMG_CK_FACEUSE( fu );

			lu = BU_LIST_FIRST( loopuse, &fu->lu_hd );
			j = 0;
			eu_start = BU_LIST_FIRST( edgeuse, &lu->down_hd );
			for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
			{
				VMOVE( arb_int->pt[j], eu->vu_p->v_p->vg_p->coord )
				j++;
			}

			eu = eu_start->radial_p;
			eu = BU_LIST_PNEXT_CIRC( edgeuse, &eu->l );
			eu = eu->eumate_p;
			for( i=0 ; i<4 ; i++ )
			{
				VMOVE( arb_int->pt[j], eu->vu_p->v_p->vg_p->coord )
				j++;
			}

			bu_ptbl_free( &tab);
			ret_val = 1;
			break;
		case 6:
			fu = BU_LIST_FIRST( faceuse, &s->fu_hd );
			face_verts = 0;
			while( face_verts != 3 )
			{
				face_verts = 0;
				fu = BU_LIST_PNEXT_CIRC( faceuse, &fu->l );
				lu = BU_LIST_FIRST( loopuse, &fu->lu_hd );
				for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
					face_verts++;
			}
			NMG_CK_FACEUSE( fu );
			if( fu->orientation != OT_SAME )
				fu = fu->fumate_p;
			NMG_CK_FACEUSE( fu );

			lu = BU_LIST_FIRST( loopuse, &fu->lu_hd );

			eu_start = BU_LIST_FIRST( edgeuse, &lu->down_hd );
			eu = eu_start;
			VMOVE( arb_int->pt[1], eu->vu_p->v_p->vg_p->coord );
			eu = BU_LIST_PNEXT_CIRC( edgeuse, &eu->l );
			VMOVE( arb_int->pt[0], eu->vu_p->v_p->vg_p->coord );
			eu = BU_LIST_PNEXT_CIRC( edgeuse, &eu->l );
			VMOVE( arb_int->pt[4], eu->vu_p->v_p->vg_p->coord );
			VMOVE( arb_int->pt[5], eu->vu_p->v_p->vg_p->coord );

			eu = eu_start->radial_p;
			eu = BU_LIST_PNEXT_CIRC( edgeuse, &eu->l );
			eu = BU_LIST_PNEXT_CIRC( edgeuse, &eu->l );
			eu = eu->radial_p->eumate_p;
			VMOVE( arb_int->pt[2], eu->vu_p->v_p->vg_p->coord );
			eu = BU_LIST_PNEXT_CIRC( edgeuse, &eu->l );
			VMOVE( arb_int->pt[3], eu->vu_p->v_p->vg_p->coord );
			eu = BU_LIST_PNEXT_CIRC( edgeuse, &eu->l );
			VMOVE( arb_int->pt[6], eu->vu_p->v_p->vg_p->coord );
			VMOVE( arb_int->pt[7], eu->vu_p->v_p->vg_p->coord );

			bu_ptbl_free( &tab);
			ret_val = 1;
			break;
		case 7:
			found = 0;
			fu = BU_LIST_FIRST( faceuse, &s->fu_hd );
			while( !found )
			{
				int verts4=0,verts3=0;

				lu = BU_LIST_FIRST( loopuse, &fu->lu_hd );
				for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
				{
					struct loopuse *lu1;
					struct edgeuse *eu1;
					int vert_count=0;

					fu1 = nmg_find_fu_of_eu( eu->radial_p );
					lu1 = BU_LIST_FIRST( loopuse, &fu1->lu_hd );
					for( BU_LIST_FOR( eu1, edgeuse, &lu1->down_hd ) )
						vert_count++;

					if( vert_count == 4 )
						verts4++;
					else if( vert_count == 3 )
						verts3++;
				}

				if( verts4 == 2 && verts3 == 2 )
					found = 1;
			}
			if( fu->orientation != OT_SAME )
				fu = fu->fumate_p;
			NMG_CK_FACEUSE( fu );

			lu = BU_LIST_FIRST( loopuse, &fu->lu_hd );
			j = 0;
			eu_start = BU_LIST_FIRST( edgeuse, &lu->down_hd );
			for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
			{
				VMOVE( arb_int->pt[j], eu->vu_p->v_p->vg_p->coord )
				j++;
			}

			eu = eu_start->radial_p;
			eu = BU_LIST_PNEXT_CIRC( edgeuse, &eu->l );
			eu = BU_LIST_PNEXT_CIRC( edgeuse, &eu->l );
			eu = eu->radial_p->eumate_p;
			fu1 = nmg_find_fu_of_eu( eu );
			if( nmg_faces_are_radial( fu, fu1 ) )
			{
				eu = eu_start->radial_p;
				eu = BU_LIST_PNEXT_CIRC( edgeuse, &eu->l );
				eu = eu->radial_p->eumate_p;
			}
			for( i=0 ; i<4 ; i++ )
			{
				VMOVE( arb_int->pt[j], eu->vu_p->v_p->vg_p->coord )
				j++;
				eu = BU_LIST_PNEXT_CIRC( edgeuse, &eu->l );
			}

			bu_ptbl_free( &tab);
			ret_val = 1;
			break;
		case 8:
			fu = BU_LIST_FIRST( faceuse, &s->fu_hd );
			NMG_CK_FACEUSE( fu );
			if( fu->orientation != OT_SAME )
				fu = fu->fumate_p;
			NMG_CK_FACEUSE( fu );

			lu = BU_LIST_FIRST( loopuse, &fu->lu_hd );
			j = 0;
			eu_start = BU_LIST_FIRST( edgeuse, &lu->down_hd );
			for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
			{
				VMOVE( arb_int->pt[j], eu->vu_p->v_p->vg_p->coord )
				j++;
			}

			eu = eu_start->radial_p;
			eu = BU_LIST_PNEXT_CIRC( edgeuse, &eu->l );
			eu = BU_LIST_PNEXT_CIRC( edgeuse, &eu->l );
			eu = eu->radial_p->eumate_p;
			for( i=0 ; i<4 ; i++ )
			{
				VMOVE( arb_int->pt[j], eu->vu_p->v_p->vg_p->coord )
				j++;
				eu = BU_LIST_PNEXT_CIRC( edgeuse, &eu->l );
			}

			bu_ptbl_free( &tab);
			ret_val = 1;
			break;
		default:
			rt_bomb( "Shell_is_arb screwed up" );
			break;
	}
	if( ret_val )
		arb_int->magic = RT_ARB_INTERNAL_MAGIC;
	return( ret_val );
}

/*		N M G _ T O _ T G C
 *
 *	Converts an NMG to a TGC, if possible.
 *
 *	NMG must have been coplanar face merged and simplified
 *
 *	Returns:
 *		1 - Equivalent TGC was constructed
 *		0 - Cannot construct an equivalent TGC
 *
 *	The newly constructed tgc is in "tgc_int"
 *
 *	Currently only supports RCC, and creates circumscribed RCC
 */
int
nmg_to_tgc(
	const struct model *m,
	struct rt_tgc_internal *tgc_int,
	const struct bn_tol *tol )
{
	struct nmgregion *r;
	struct shell *s;
	struct faceuse *fu;
	struct loopuse *lu;
	struct edgeuse *eu;
	struct faceuse *fu_base=(struct faceuse *)NULL;
	struct faceuse *fu_top=(struct faceuse *)NULL;
	int three_vert_faces=0;
	int four_vert_faces=0;
	int many_vert_faces=0;
	int base_vert_count=0;
	int top_vert_count=0;
	point_t sum;
	fastf_t vert_count=0.0;
	fastf_t one_over_vert_count;
	point_t base_center;
	fastf_t min_base_r_sq;
	fastf_t max_base_r_sq;
	fastf_t sum_base_r_sq;
	fastf_t ave_base_r_sq;
	fastf_t base_r;
	point_t top_center;
	fastf_t min_top_r_sq;
	fastf_t max_top_r_sq;
	fastf_t sum_top_r_sq;
	fastf_t ave_top_r_sq;
	fastf_t top_r;
	plane_t top_pl;
	plane_t base_pl;
	vect_t plv_1,plv_2;

	NMG_CK_MODEL( m );

	BN_CK_TOL( tol );

	r = BU_LIST_FIRST( nmgregion, &m->r_hd );

	/* must be a single region */
	if( BU_LIST_NEXT_NOT_HEAD( &r->l, &m->r_hd ) )
		return( 0 );

	s = BU_LIST_FIRST( shell, &r->s_hd );
	NMG_CK_SHELL( s );

	/* must be a single shell */
	if( BU_LIST_NEXT_NOT_HEAD( &s->l, &r->s_hd ) )
		return( 0 );

	for( BU_LIST_FOR( fu, faceuse, &s->fu_hd ) )
	{
		int lu_count=0;

		NMG_CK_FACEUSE( fu );
		if( fu->orientation != OT_SAME )
			continue;

		vert_count = 0.0;

		for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
		{

			NMG_CK_LOOPUSE( lu );

			if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
				return( 0 );

			lu_count++;
			if( lu_count > 1 )
				return( 0 );

			for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
				vert_count++;
		}

		if( vert_count < 3 )
			return( 0 );

		if( vert_count == 4 )
			four_vert_faces++;
		else if( vert_count ==3 )
			three_vert_faces++;
		else
		{
			many_vert_faces++;
			if( many_vert_faces > 2 )
				return( 0 );

			if( many_vert_faces == 1 )
			{
				fu_base = fu;
				base_vert_count = vert_count;
				NMG_GET_FU_PLANE( base_pl, fu_base );
			}
			else if( many_vert_faces == 2 )
			{
				fu_top = fu;
				top_vert_count = vert_count;
				NMG_GET_FU_PLANE( top_pl, fu_top );
			}
		}
	}
	/* if there are any three vertex faces,
	 * there must be an even number of them
	 */
	if( three_vert_faces%2 )
		return( 0 );

	/* base and top must have same number of vertices */
	if( base_vert_count != top_vert_count )
		return( 0 );

	/* Must have correct number of side faces */
	if( (base_vert_count != four_vert_faces) &&
	    (base_vert_count*2 != three_vert_faces ) )
		return( 0 );

	if( !NEAR_ZERO( 1.0 + VDOT( top_pl, base_pl ), tol->perp ) )
		return( 0 );

	/* This looks like a good candidate,
	 * Calculate center of base and top faces
	 */

	vert_count = 0.0;
	VSETALL( sum, 0.0 );
	lu = BU_LIST_FIRST( loopuse, &fu_base->lu_hd );
	for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
	{
		struct vertex_g *vg;

		NMG_CK_EDGEUSE( eu );

		NMG_CK_VERTEXUSE( eu->vu_p );
		NMG_CK_VERTEX( eu->vu_p->v_p );
		vg = eu->vu_p->v_p->vg_p;
		NMG_CK_VERTEX_G( vg );

		VADD2( sum, sum, vg->coord );
		vert_count++;
	}

	one_over_vert_count = 1.0/vert_count;
	VSCALE( base_center, sum, one_over_vert_count );

	/* Calculate Average Radius */
	min_base_r_sq = MAX_FASTF;
	max_base_r_sq = (-min_base_r_sq);
	sum_base_r_sq = 0.0;
	lu = BU_LIST_FIRST( loopuse, &fu_base->lu_hd );
	for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
	{
		struct vertex_g *vg;
		vect_t rad_vect;
		fastf_t r_sq;

		vg = eu->vu_p->v_p->vg_p;

		VSUB2( rad_vect, vg->coord, base_center );
		r_sq = MAGSQ( rad_vect );
		if( r_sq > max_base_r_sq )
			max_base_r_sq = r_sq;
		if( r_sq < min_base_r_sq )
			min_base_r_sq = r_sq;

		sum_base_r_sq += r_sq;
	}

	ave_base_r_sq = sum_base_r_sq/vert_count;

	base_r = sqrt( max_base_r_sq );

	if( !NEAR_ZERO( (max_base_r_sq - ave_base_r_sq)/ave_base_r_sq, 0.001 ) ||
	    !NEAR_ZERO( (min_base_r_sq - ave_base_r_sq)/ave_base_r_sq, 0.001 ) )
			return( 0 );

	VSETALL( sum, 0.0 );
	lu = BU_LIST_FIRST( loopuse, &fu_top->lu_hd );
	for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
	{
		struct vertex_g *vg;

		NMG_CK_EDGEUSE( eu );

		NMG_CK_VERTEXUSE( eu->vu_p );
		NMG_CK_VERTEX( eu->vu_p->v_p );
		vg = eu->vu_p->v_p->vg_p;
		NMG_CK_VERTEX_G( vg );

		VADD2( sum, sum, vg->coord );
	}

	VSCALE( top_center, sum, one_over_vert_count );

	/* Calculate Average Radius */
	min_top_r_sq = MAX_FASTF;
	max_top_r_sq = (-min_top_r_sq);
	sum_top_r_sq = 0.0;
	lu = BU_LIST_FIRST( loopuse, &fu_top->lu_hd );
	for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
	{
		struct vertex_g *vg;
		vect_t rad_vect;
		fastf_t r_sq;

		vg = eu->vu_p->v_p->vg_p;

		VSUB2( rad_vect, vg->coord, top_center );
		r_sq = MAGSQ( rad_vect );
		if( r_sq > max_top_r_sq )
			max_top_r_sq = r_sq;
		if( r_sq < min_top_r_sq )
			min_top_r_sq = r_sq;

		sum_top_r_sq += r_sq;
	}

	ave_top_r_sq = sum_top_r_sq/vert_count;
	top_r = sqrt( max_top_r_sq );

	if( !NEAR_ZERO( (max_top_r_sq - ave_top_r_sq)/ave_top_r_sq, 0.001 ) ||
	    !NEAR_ZERO( (min_top_r_sq - ave_top_r_sq)/ave_top_r_sq, 0.001 ) )
			return( 0 );


	VMOVE( tgc_int->v, base_center );
	VSUB2( tgc_int->h, top_center, base_center );

	bn_vec_perp( plv_1, top_pl );
	VCROSS( plv_2, top_pl, plv_1 );
	VUNITIZE( plv_1 );
	VUNITIZE( plv_2 );
	VSCALE( tgc_int->a, plv_1, base_r );
	VSCALE( tgc_int->b, plv_2, base_r );
	VSCALE( tgc_int->c, plv_1, top_r );
	VSCALE( tgc_int->d, plv_2, top_r );

	tgc_int->magic = RT_TGC_INTERNAL_MAGIC;

	return( 1 );
}


/*		N M G _ L U _ I S _ C O N V E X
 *
 *	Checks if lu is convex
 *
 * Returns:
 *	1 - is loop is convex, or lu is a loop of a single vertex
 *	0 - otherwise
 */
int
nmg_lu_is_convex(struct loopuse *lu, const struct bn_tol *tol)
{
	struct edgeuse *eu1,*eu2,*eu3,*eu_start;

	NMG_CK_LOOPUSE( lu );
	BN_CK_TOL( tol );

	if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
		return( 1 );

	if( !lu->l_p->lg_p )
		nmg_loop_g( lu->l_p, tol );

	eu1 = BU_LIST_FIRST( edgeuse, &lu->down_hd );
	eu_start = eu1;
	eu2 = BU_LIST_PNEXT_CIRC( edgeuse, &eu1->l );
	eu3 = BU_LIST_PNEXT_CIRC( edgeuse, &eu2->l );

	if( eu1->vu_p->v_p == eu3->eumate_p->vu_p->v_p )
		return( 1 );		/* triangle */

	while( eu3 != eu_start )
	{
		int class;
		struct vertex_g *vg1,*vg3;
		point_t mid_pt;

		vg1 = eu1->vu_p->v_p->vg_p;
		NMG_CK_VERTEX_G( vg1 );

		vg3 = eu3->vu_p->v_p->vg_p;
		NMG_CK_VERTEX_G( vg3 );

		VBLEND2( mid_pt, 0.5, vg1->coord, 0.5, vg3->coord );

		class = nmg_class_pt_lu_except( mid_pt, lu, NULL, tol );

		if( (class == NMG_CLASS_AoutB && lu->orientation == OT_SAME) ||
		    (class == NMG_CLASS_AinB  && lu->orientation == OT_OPPOSITE) )
				return( 0 );
		else
		{
			eu1 = BU_LIST_PNEXT_CIRC( edgeuse, &eu1->l );
			eu2 = BU_LIST_PNEXT_CIRC( edgeuse, &eu1->l );
			eu3 = BU_LIST_PNEXT_CIRC( edgeuse, &eu2->l );
		}
	}

	return( 1 );
}

/*
 *			N M G _ T O _ P O L Y
 *
 * XXX This routine is deprecated in favor of BoTs
 */
int
nmg_to_poly(const struct model *m, struct rt_pg_internal *poly_int, const struct bn_tol *tol)
{
	struct nmgregion *r;
	struct shell  *s;
	struct faceuse *fu;
	struct loopuse *lu;
	struct edgeuse *eu;
	struct model *dup_m;
	struct nmgregion *dup_r;
	struct shell *dup_s;
	int max_count;
	int count_npts;
	int face_count=0;
#if 0
	struct rt_pg_face_internal *_poly;
#endif

	NMG_CK_MODEL( m );

	BN_CK_TOL( tol );

	for( BU_LIST_FOR( r, nmgregion, &m->r_hd ) )
	{
		for( BU_LIST_FOR( s, shell, &r->s_hd ) )
		{
			if( nmg_check_closed_shell( s, tol ) )
				return( 0 );
		}
	}

	dup_m = nmg_mm();
	dup_r = nmg_mrsv( dup_m );
	dup_s = BU_LIST_FIRST( shell, &dup_r->s_hd );

	for( BU_LIST_FOR( r, nmgregion, &m->r_hd ) )
	{
		for( BU_LIST_FOR( s, shell, &r->s_hd ) )
		{
			for( BU_LIST_FOR( fu, faceuse, &s->fu_hd ) )
			{
				if( fu->orientation != OT_SAME )
					continue;
				(void)nmg_dup_face( fu, dup_s );
			}
		}
	}

	for( BU_LIST_FOR( dup_r, nmgregion, &dup_m->r_hd ) )
	{
		for( BU_LIST_FOR( dup_s, shell, &dup_r->s_hd ) )
		{
			for( BU_LIST_FOR( fu , faceuse , &dup_s->fu_hd ) )
			{
				NMG_CK_FACEUSE( fu );

				/* only do OT_SAME faces */
				if( fu->orientation != OT_SAME )
					continue;

				/* count vertices in loops */
				max_count = 0;
				for( BU_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
				{
					NMG_CK_LOOPUSE( lu );
					if( BU_LIST_FIRST_MAGIC(&lu->down_hd) != NMG_EDGEUSE_MAGIC )
						continue;

					if( lu->orientation != OT_SAME )
					{
						/* triangulate holes */
						max_count = 6;
						break;
					}

					count_npts = 0;
					for( BU_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
						count_npts++;

					if( count_npts > 5 )
					{
						max_count = count_npts;
						break;
					}
					if( !nmg_lu_is_convex( lu, tol ) )
					{
						/* triangulate non-convex faces */
						max_count = 6;
						break;
					}
				}

				/* if any loop has more than 5 vertices, triangulate the face */
				if( max_count > 5 )
				{
					if( rt_g.NMG_debug & DEBUG_BASIC )
						bu_log( "write_shell_as_polysolid: triangulating fu x%x\n", fu );
					nmg_triangulate_fu( fu, tol );
				}

				for( BU_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
				{
					NMG_CK_LOOPUSE( lu );
					if( BU_LIST_FIRST_MAGIC(&lu->down_hd) != NMG_EDGEUSE_MAGIC )
						continue;

					face_count++;
				}
			}
		}
	}
	poly_int->npoly = face_count;
	poly_int->poly = (struct rt_pg_face_internal *)bu_calloc( face_count,
		sizeof( struct rt_pg_face_internal ), "nmg_to_poly: poly" );

	face_count = 0;
	for( BU_LIST_FOR( dup_r, nmgregion, &dup_m->r_hd ) )
	{
		for( BU_LIST_FOR( dup_s, shell, &dup_r->s_hd ) )
		{
			for( BU_LIST_FOR( fu , faceuse , &dup_s->fu_hd ) )
			{
				vect_t norm;

				NMG_CK_FACEUSE( fu );

				/* only do OT_SAME faces */
				if( fu->orientation != OT_SAME )
					continue;

				NMG_GET_FU_NORMAL( norm, fu );

				for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
				{
					int pt_no=0;

					if( BU_LIST_FIRST_MAGIC(&lu->down_hd) != NMG_EDGEUSE_MAGIC )
						continue;

					/* count vertices in loop */
					count_npts = 0;
					for( BU_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
						count_npts++;

					poly_int->poly[face_count].npts = count_npts;
					poly_int->poly[face_count].verts = (fastf_t *) bu_calloc( 3*count_npts, sizeof( fastf_t ), "nmg_to_poly: verts" );
					poly_int->poly[face_count].norms = (fastf_t *) bu_calloc( 3*count_npts, sizeof( fastf_t ), "nmg_to_poly: norms" );

					for( BU_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
					{
						struct vertex_g *vg;

						vg = eu->vu_p->v_p->vg_p;
						NMG_CK_VERTEX_G( vg );

						VMOVE( &(poly_int->poly[face_count].verts[pt_no*3]), vg->coord );
						VMOVE( &(poly_int->poly[face_count].norms[pt_no*3]), norm );

						pt_no++;
					}
					face_count++;
				}
			}
		}
	}

	poly_int->magic = RT_PG_INTERNAL_MAGIC;
	nmg_km( dup_m );

	return( 1 );
}

int
nmg_simplify_shell_edges(struct shell *s, const struct bn_tol *tol)
{
	struct faceuse *fu;
	int count=0;

	NMG_CK_SHELL( s );
	BN_CK_TOL( tol );

	fu = BU_LIST_FIRST( faceuse, &s->fu_hd );
	while( BU_LIST_NOT_HEAD( &fu->l, &s->fu_hd ) )
	{
		struct faceuse *fu_next;
		struct loopuse *lu;
		int empty_fu=0;

		NMG_CK_FACEUSE( fu );

		fu_next = BU_LIST_PNEXT( faceuse, &fu->l );

		if( fu->orientation != OT_SAME )
		{
			fu = fu_next;
			continue;
		}

		lu = BU_LIST_FIRST( loopuse, &fu->lu_hd );

		while( BU_LIST_NOT_HEAD( &lu->l, &fu->lu_hd ) )
		{
			struct loopuse *lu_next;
			struct edge *ep1,*ep2;
			struct edgeuse *eu;
			struct edgeuse *eu_next;
			vect_t dir_eu;
			vect_t dir_next;

			NMG_CK_LOOPUSE( lu );

			lu_next = BU_LIST_PNEXT( loopuse, &lu->l );

			if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
			{
				lu = lu_next;
				continue;
			}

			eu = BU_LIST_FIRST( edgeuse, &lu->down_hd );
			while( BU_LIST_NOT_HEAD( &eu->l, &lu->down_hd ) )
			{
				struct vertex *v1,*v2,*v3;
				struct vertex_g *vg1,*vg2,*vg3;
				struct vertexuse *vu;
				struct vertexuse *next_vu;
				struct edgeuse *eu_tmp;
				point_t pca;
				fastf_t dist;
				int skip;
				int empty_lu=0;

				v1 = eu->vu_p->v_p;
				ep1 = eu->e_p;
				eu_next = BU_LIST_PNEXT_CIRC( edgeuse, &eu->l );
				ep2 = eu_next->e_p;
				v2 = eu_next->vu_p->v_p;

				if( v1 == v2 )
				{
					/* this is a crack */
					eu = BU_LIST_PNEXT( edgeuse, &eu->l );
					continue;
				}

				/* make sure there are no uses of v2 outside this shell,
				 * and that all uses are for either ep1 or ep2 */
				skip = 0;
				for( BU_LIST_FOR( vu, vertexuse, &v2->vu_hd ) )
				{
					if( nmg_find_s_of_vu( vu ) != s )
					{
						skip = 1;
						break;
					}
					if( *vu->up.magic_p != NMG_EDGEUSE_MAGIC )
						continue;

					if( vu->up.eu_p->e_p != ep1 &&
					    vu->up.eu_p->e_p != ep2 )
					{
						skip = 1;
						break;
					}
				}

				if( skip )
				{
					/* can't kill eu_next */
					eu = BU_LIST_PNEXT( edgeuse, &eu->l );
					continue;
				}

				vg2 = v2->vg_p;

				v1 = eu->vu_p->v_p;
				vg1 = v1->vg_p;
				v3 = eu_next->eumate_p->vu_p->v_p;
				vg3 = v3->vg_p;

				VSUB2( dir_eu, vg2->coord, vg1->coord );
				VSUB2( dir_next, vg3->coord, vg2->coord );

				skip = 1;
				if( rt_dist_pt3_line3( &dist, pca, vg1->coord, dir_eu, vg3->coord, tol ) < 2 )
					skip = 0;
				else if( rt_dist_pt3_line3( &dist, pca, vg2->coord, dir_next, vg1->coord, tol ) < 2 )
					skip = 0;

				if( skip )
				{
					/* can't kill eu_next */
					eu = BU_LIST_PNEXT( edgeuse, &eu->l );
					continue;
				}

				count++;
				/* kill all uses of eu_next edge */
				eu_tmp = eu_next->radial_p;
				while( eu_tmp != eu_next->eumate_p )
				{
					nmg_keu( eu_tmp );
					eu_tmp = eu_next->radial_p;
				}
				nmg_keu( eu_next );

				/* move all ep1 EU's using v2 to vertex v3 */
				vu = BU_LIST_FIRST( vertexuse, &v2->vu_hd );
				while( BU_LIST_NOT_HEAD( &vu->l, &v2->vu_hd ) )
				{
					NMG_CK_VERTEXUSE( vu );
					next_vu = BU_LIST_PNEXT( vertexuse, &vu->l );
					if( *vu->up.magic_p != NMG_EDGEUSE_MAGIC )
					{
						vu = next_vu;
						continue;
					}

					eu_tmp = vu->up.eu_p;
					NMG_CK_EDGEUSE( eu );

					if( eu->e_p != ep1 )
					{
						vu = next_vu;
						continue;
					}

					nmg_movevu( eu_tmp->vu_p, v3 );

					vu = next_vu;
					continue;
				}

				if( BU_LIST_IS_EMPTY( &lu->down_hd ) )
				{
					empty_lu = 1;
					empty_fu = nmg_klu( lu );
				}
				if( empty_lu )
					break;

			}

			if( empty_fu )
				break;
			lu = lu_next;
		}
		if( empty_fu )
		{
			if( fu_next == fu->fumate_p )
				fu_next = BU_LIST_NEXT( faceuse, &fu_next->l );
			(void)nmg_kfu( fu );
		}
		fu = fu_next;
	}
	return( count );
}

#define EDGE_COLLAPSE_DEBUG 0

int
nmg_select_collapse(const fastf_t max_dist1, const fastf_t max_dot1, const int flip1, const fastf_t max_dist2, const fastf_t max_dot2, const int flip2, const fastf_t max_dot, const fastf_t tol_dist)
{
	unsigned int ret;

	ret = 1 | 2;

	if( flip1 )
		ret = ret & ~1;

	if( flip2 )
		ret = ret & ~2;

	if( max_dist1 > tol_dist )
		ret = ret & ~1;

	if( max_dist2 > tol_dist )
		ret = ret & ~2;

	if( max_dot1 > max_dot )
		ret = ret & ~1;

	if( max_dot2 > max_dot )
		ret = ret & ~2;

	if( ret == (1 | 2) )
	{
		if( max_dot1 < max_dot2 )
			ret = 1;
		else
			ret =  2;
	}

#if EDGE_COLLAPSE_DEBUG
bu_log( "\nmax_dot=%g, tol_coll=%g\n", max_dot, tol_dist );
bu_log( "max_dist1, max_dot1, flip1: %g %g %d\n", max_dist1, max_dot1, flip1 );
bu_log( "max_dist2, max_dot2, flip2: %g %g %d\n", max_dist2, max_dot2, flip2 );
bu_log( "choice = %d\n", ret );
#endif

	return( ret );
}

/*	 	N M G _ E D G E _ C O L L A P S E
 *
 * Routine to decimate an NMG model through edge collapse
 * to obtain a model with less faces at a greater tolerance
 *
 *  tol_coll is the tolerance distance to be used for choosing
 *  edges to collapse
 *
 * Model must already be triangulated (this is not checked for)
 *
 * returns number of edges collapsed
 */
int
nmg_edge_collapse(struct model *m, const struct bn_tol *tol, const fastf_t tol_coll, const fastf_t min_angle)
{
	fastf_t max_dot;
	struct bu_ptbl edge_table;
	long edge_no=0;
	long count=0;
	long sub_count=1;
	int choice;
	int i;

	NMG_CK_MODEL( m );
	BN_CK_TOL( tol );

	max_dot = cos( min_angle * bn_pi / 180.0 );

	/* Each triangle must be its own face */
	(void)nmg_split_loops_into_faces( &m->magic, tol );

	nmg_edge_tabulate( &edge_table, &m->magic );

	while( sub_count )
	{
		sub_count = 0;
		for( edge_no=0 ; edge_no < BU_PTBL_END( &edge_table ) ; edge_no++ )
		{
			int done=0;
			struct edge *e;
			struct edgeuse *eu, *eu2, *eu3;
			struct faceuse *fu, *fu2;
			struct vertex *v1, *v2;
			struct vertexuse *vu;
			int real_count1, real_count2;
			vect_t edge_dir;
			fastf_t max_dist1, max_dist2;
			fastf_t max_dot1, max_dot2;
			int flip1, flip2;
			int no_collapse;
			int free_edge;

			max_dist1 = -1.0;
			max_dist2 = -1.0;
			max_dot1 = -1.0;
			max_dot2 = -1.0;

			e = (struct edge *)BU_PTBL_GET( &edge_table, edge_no );
			if( !e )
				continue;
			if( e->magic != NMG_EDGE_MAGIC )
				continue;

			NMG_CK_EDGE( e );
			eu = e->eu_p;
			NMG_CK_EDGEUSE( eu );

			v1 = eu->vu_p->v_p;
			NMG_CK_VERTEX( v1 );
			v2 = eu->eumate_p->vu_p->v_p;
			NMG_CK_VERTEX( v2 );

			/* don't collapse free edges */
			free_edge = 0;
			eu2 = eu;
			do
			{
				eu3 = eu2;
				do {
					if( eu3->radial_p->eumate_p == eu3 )
					{
						free_edge = 1;
						break;
					}
					eu3 = BU_LIST_PNEXT_CIRC( edgeuse, &eu3->l );
					
				} while ( eu3 != eu2 );
				if( free_edge )
					break;

				eu2 = eu2->radial_p->eumate_p;
			} while( eu2 != eu );

			if( free_edge )
			{
#if EDGE_COLLAPSE_DEBUG
				bu_log( "Not collapsing free edge at (%g %g %g)<->(%g %g %g)\n",
					V3ARGS( v1->vg_p->coord ), V3ARGS( v2->vg_p->coord ) );
#endif
				continue;
			}

			/* consider collapsing this edge */
#if EDGE_COLLAPSE_DEBUG
			bu_log( "Consider collapsing e x%x (%g %g %g)<->(%g %g %g)\n", e, V3ARGS( v1->vg_p->coord ), V3ARGS( v2->vg_p->coord ) );
#endif

			/* don't collapse where more than 2 real edges meet */
			real_count1 = 0;

			for( BU_LIST_FOR( vu, vertexuse, &v1->vu_hd ) )
			{
				struct edgeuse *eu1;

				if( *vu->up.magic_p != NMG_EDGEUSE_MAGIC )
					continue;

				eu1 = vu->up.eu_p;

				fu = nmg_find_fu_of_eu( eu1 );
				if( fu->orientation != OT_SAME )
					continue;

				if( eu1->e_p->is_real )
					real_count1++;
			}

			if( real_count1 > 2 )
			{
#if EDGE_COLLAPSE_DEBUG
				bu_log( "\t%d real edges at v1\n", real_count1 );
#endif
				continue;
			}

			real_count2 = 0;

			for( BU_LIST_FOR( vu, vertexuse, &v2->vu_hd ) )
			{
				struct edgeuse *eu1;

				if( *vu->up.magic_p != NMG_EDGEUSE_MAGIC )
					continue;

				eu1 = vu->up.eu_p;

				fu = nmg_find_fu_of_eu( eu1 );
				if( fu->orientation != OT_SAME )
					continue;

				if( eu1->e_p->is_real )
					real_count2++;
			}

			if( real_count2 > 2 )
			{
#if EDGE_COLLAPSE_DEBUG
				bu_log( "\t%d real edges at v1\n", real_count1 );
#endif
				continue;
			}

			/* if real edges are involved, only collapse along the real edges */
			if( (real_count1 || real_count2) && !e->is_real )
			{
#if EDGE_COLLAPSE_DEBUG
				bu_log( "\tthis edge is not real\n" );
#endif
				continue;
			}
#if EDGE_COLLAPSE_DEBUG
			bu_log( "\tpassed real edges test\n" );
#endif

			VSUB2( edge_dir, v2->vg_p->coord, v1->vg_p->coord )
			VUNITIZE( edge_dir )

			fu = nmg_find_fu_of_eu( eu );
			NMG_CK_FACEUSE( fu );
			if( fu->orientation != OT_SAME )
				fu = fu->fumate_p;
			if( fu->orientation != OT_SAME )
			{
				bu_log( "nmg_edge_collapse: fu (x%x) has no OT_SAME use!!!\n", fu );
				continue;
			}
			eu2 = eu->radial_p;
			NMG_CK_EDGEUSE( eu2 );
			fu2 = nmg_find_fu_of_eu( eu2 );
			NMG_CK_FACEUSE( fu2 );
			if( fu2->orientation != OT_SAME )
				fu2 = fu2->fumate_p;
			if( fu2->orientation != OT_SAME )
			{
				bu_log( "nmg_edge_collapse: fu2 (x%x) has no OT_SAME use!!!\n", fu2 );
				continue;
			}

#if EDGE_COLLAPSE_DEBUG
			bu_log( "\tCheck moving v1 to v2\n" );
#endif
			/* check if moving v1 to v2 would flip any loops */
			flip1 = 0;
			for( BU_LIST_FOR( vu, vertexuse, &v1->vu_hd ) )
			{
				struct edgeuse *eu1, *eu2;
				vect_t vec1, vec2, vec3;
				vect_t norma;
				struct vertex_g *vg1, *vg2;
				plane_t normb;
				fastf_t dist;
				fastf_t dot1;

				if( *vu->up.magic_p != NMG_EDGEUSE_MAGIC )
					continue;

				eu1 = vu->up.eu_p;
				eu2 = BU_LIST_PNEXT_CIRC( edgeuse, &eu1->l );

				if( eu2->eumate_p->vu_p->v_p == v2 )
					continue;

				if( eu2->vu_p->v_p == v2 )
					continue;

				vg1 = eu2->vu_p->v_p->vg_p;
				vg2 = eu2->eumate_p->vu_p->v_p->vg_p;

				VSUB2( vec1, v1->vg_p->coord, vg1->coord )
				VSUB2( vec2, vg2->coord, vg1->coord )
				VCROSS( norma, vec1, vec2 )
#if EDGE_COLLAPSE_DEBUG
				bu_log( "\t\toriginal tri (%g %g %g) (%g %g %g) (%g %g %g)\n",
					V3ARGS( v1->vg_p->coord ),
					V3ARGS( vg1->coord ),
					V3ARGS( vg2->coord ) );
#endif
				VSUB2( vec1, v2->vg_p->coord, vg1->coord )
				VCROSS( normb, vec1, vec2 )
				VSUB2( vec3, v2->vg_p->coord, vg2->coord )
				VUNITIZE( vec1 );
				VUNITIZE( vec2 );
				VUNITIZE( vec3 );

				dot1 = VDOT( vec1, vec2 );
				if( dot1 > max_dot1 )
					max_dot1 = dot1;
				dot1 = VDOT( vec1, vec3 );
				if( dot1 > max_dot1 )
					max_dot1 = dot1;
				dot1 = -VDOT( vec2, vec3 );
				if( dot1 > max_dot1 )
					max_dot1 = dot1;
#if EDGE_COLLAPSE_DEBUG
				bu_log( "\t\tnew tri (%g %g %g) (%g %g %g) (%g %g %g)\n",
					V3ARGS( v2->vg_p->coord ),
					V3ARGS( vg1->coord ),
					V3ARGS( vg2->coord ) );
#endif
				fu = nmg_find_fu_of_eu( eu1 );
				if( fu->orientation == OT_SAME )
				{
					VUNITIZE( normb )
					normb[3] = VDOT( normb, v2->vg_p->coord );

					dist = fabs( DIST_PT_PLANE( v1->vg_p->coord, normb ) );
#if EDGE_COLLAPSE_DEBUG
					bu_log( "\t\t\tdist = %g\n", dist );
#endif
					if( dist > max_dist1 )
						max_dist1 = dist;
				}
#if EDGE_COLLAPSE_DEBUG
				else
					bu_log( "\t\t\tfu->orientation = %s\n", nmg_orientation( fu->orientation ) );
#endif

				if( VDOT( norma, normb ) <= 0.0 )
				{
					/* this would flip a loop */
					flip1 = 1;
#if EDGE_COLLAPSE_DEBUG
					bu_log( "\t\t\tflip1 = 1\n" );
#endif
					break;
				}
				
			}

			/* check if moving v2 to v1 would flip any loops */
#if EDGE_COLLAPSE_DEBUG
			bu_log( "\tCheck moving v2 to v1\n" );
#endif
			flip2 = 0;
			for( BU_LIST_FOR( vu, vertexuse, &v2->vu_hd ) )
			{
				struct edgeuse *eu1, *eu2;
				vect_t vec1, vec2, vec3;
				vect_t norma;
				plane_t normb;
				struct vertex_g *vg1, *vg2;
				fastf_t dist, dot1;

				if( *vu->up.magic_p != NMG_EDGEUSE_MAGIC )
					continue;

				eu1 = vu->up.eu_p;
				eu2 = BU_LIST_PNEXT_CIRC( edgeuse, &eu1->l );

				if( eu2->eumate_p->vu_p->v_p == v1 )
					continue;

				if( eu2->vu_p->v_p == v1 )
					continue;

				vg1 = eu2->vu_p->v_p->vg_p;
				vg2 = eu2->eumate_p->vu_p->v_p->vg_p;

				VSUB2( vec1, v2->vg_p->coord, vg1->coord )
				VSUB2( vec2, vg2->coord, vg1->coord )
				VCROSS( norma, vec1, vec2 )
#if EDGE_COLLAPSE_DEBUG
				bu_log( "\t\toriginal tri (%g %g %g) (%g %g %g) (%g %g %g)\n",
					V3ARGS( v2->vg_p->coord ),
					V3ARGS( vg1->coord ),
					V3ARGS( vg2->coord ) );
#endif

				VSUB2( vec1, v1->vg_p->coord, vg1->coord )
				VCROSS( normb, vec1, vec2 )
				VSUB2( vec3, v1->vg_p->coord, vg2->coord );
				VSUB2( vec3, v2->vg_p->coord, vg2->coord )
				VUNITIZE( vec1 );
				VUNITIZE( vec2 );
				VUNITIZE( vec3 );

				dot1 = VDOT( vec1, vec2 );
				if( dot1 > max_dot2 )
					max_dot2 = dot1;
				dot1 = VDOT( vec1, vec3 );
				if( dot1 > max_dot2 )
					max_dot2 = dot1;
				dot1 = -VDOT( vec2, vec3 );
				if( dot1 > max_dot2 )
					max_dot2 = dot1;
#if EDGE_COLLAPSE_DEBUG
				bu_log( "\t\tnew tri (%g %g %g) (%g %g %g) (%g %g %g)\n",
					V3ARGS( v1->vg_p->coord ),
					V3ARGS( vg1->coord ),
					V3ARGS( vg2->coord ) );
#endif

				fu = nmg_find_fu_of_eu( eu1 );
				if( fu->orientation == OT_SAME )
				{
					VUNITIZE( normb )
					normb[3] = VDOT( normb, v1->vg_p->coord );

					dist = fabs( DIST_PT_PLANE( v2->vg_p->coord, normb ));
#if EDGE_COLLAPSE_DEBUG
					bu_log( "\t\t\tdist = %g\n", dist );
#endif
					if( dist > max_dist2 )
						max_dist2 = dist;
				}
#if EDGE_COLLAPSE_DEBUG
				else
					bu_log( "\t\t\tfu->orientation = %s\n", nmg_orientation( fu->orientation ) );
#endif

				if( VDOT( norma, normb ) <= 0.0 )
				{
					/* this would flip a loop */
#if EDGE_COLLAPSE_DEBUG
					bu_log( "\t\t\tflip2 = 1\n" );
#endif
					flip2 = 1;
					break;
				}
			}
#if EDGE_COLLAPSE_DEBUG
			bu_log( "\tmax_dist1=%g, flip1=%d, max_dist2=%g, flip2=%d\n", max_dist1, flip1, max_dist2, flip2 );
#endif

			if( max_dist1 < 0.0 )
				max_dist1 = MAX_FASTF;
			if( max_dist2 < 0.0 )
				max_dist2 = MAX_FASTF;
			if( ((max_dist1 > tol_coll) || (flip1 > 0) ) &&
			    ((max_dist2 > tol_coll) || (flip2 > 0) ) )
				continue;


			/* one last check to insure we don't collapse two faces into
			 * a flat plane, i.e., don't collapse an ARB4 into a single
			 * triangle.
			 */
			no_collapse = 0;
			for( BU_LIST_FOR( vu, vertexuse, &v1->vu_hd ) )
			{
				struct edgeuse *eu1, *eu1a;
				struct edgeuse *eu2, *eu2a;
				struct vertexuse *vu2;

				if( *vu->up.magic_p != NMG_EDGEUSE_MAGIC )
					continue;

				eu1 = vu->up.eu_p;
				if( eu1->e_p == e )
					continue;

				eu1a = BU_LIST_PNEXT_CIRC( edgeuse, &eu1->l );

				for( BU_LIST_FOR( vu2, vertexuse, &v2->vu_hd ) )
				{
					if( *vu2->up.magic_p != NMG_EDGEUSE_MAGIC )
						continue;

					eu2 = vu2->up.eu_p;
					if( eu2->e_p == e )
						continue;
					if( eu2->e_p == eu1->e_p )
						continue;

					eu2a = BU_LIST_PNEXT_CIRC( edgeuse, &eu2->l );

					if( NMG_ARE_EUS_ADJACENT( eu1a, eu2a ) )
					{
						no_collapse = 1;
						break;
					}
				}

				if( no_collapse )
					break;
			}

			if( no_collapse )
			{
#if EDGE_COLLAPSE_DEBUG
				bu_log( "\tNot collapsing edge (would create 2D object)\n" );
#endif
				continue;
			}

			choice = nmg_select_collapse( max_dist1, max_dot1, flip1,
						  max_dist2, max_dot2, flip2,
						  max_dot, tol_coll );

			if( !choice )
				continue;
#if EDGE_COLLAPSE_DEBUG
			bu_log( "\tCollapsing edge\n" );
#endif
			/* edge will be collapsed */
			bu_ptbl_zero( &edge_table, (long *)e );

			sub_count++;

			/* kill the loops radial to the edge being collapsed */
			eu2 = eu->radial_p;
			done = 0;
			while( !done )
			{
				struct edgeuse *next;
				struct loopuse *lu;
				struct faceuse *fu;

				next = eu2->eumate_p->radial_p;
				if( next == eu2 )
					done = 1;

				if( *eu2->up.magic_p != NMG_LOOPUSE_MAGIC )
					(void)nmg_keu( eu2 );
				else
				{
					lu = eu2->up.lu_p;
					if( *lu->up.magic_p != NMG_FACEUSE_MAGIC )
						(void)nmg_klu( lu );
					else
					{
						fu = lu->up.fu_p;
						if( nmg_klu( lu ) )
							nmg_kfu( fu );
					}
				}
				eu2 = next;
			}

			if( choice == 1 )
			{
				struct edgeuse *eu1,*eu2;
				struct vertexuse *vu2;
#if EDGE_COLLAPSE_DEBUG
				bu_log( "\tMoving v1 to v2 (%g %g %g) -> (%g %g %g)\n", V3ARGS( v1->vg_p->coord ), V3ARGS( v2->vg_p->coord ) );
#endif
				/* vertex1 will be moved to vertex2 */

				/* recalculate edge geometry */
				for( BU_LIST_FOR( vu, vertexuse, &v1->vu_hd ) )
				{
					struct faceuse *fu;
					struct edge_g_lseg *eg;
					struct vertex_g *v1a;

					if( *vu->up.magic_p != NMG_EDGEUSE_MAGIC )
						continue;

					eu1 = vu->up.eu_p;
					fu = nmg_find_fu_of_eu( eu1 );
					if( !fu )
						continue;

					if( fu->orientation != OT_SAME )
						continue;

					if( !eu1->g.magic_p )
						nmg_edge_g( eu1 );
					else if( *eu1->g.magic_p != NMG_EDGE_G_LSEG_MAGIC )
						continue;

					eg = eu1->g.lseg_p;
					v1a = eu1->eumate_p->vu_p->v_p->vg_p;
					VSUB2( eg->e_dir, v2->vg_p->coord, v1a->coord );
					VMOVE( eg->e_pt, v2->vg_p->coord );
				}

				done = 0;
				while( !done )
				{
					vu = BU_LIST_FIRST( vertexuse, &v1->vu_hd );
					if( BU_LIST_LAST( vertexuse, &v1->vu_hd ) == vu )
						done = 1;
					nmg_movevu( vu, v2 );
				}
				for( BU_LIST_FOR( vu, vertexuse, &v2->vu_hd ) )
				{
					if( *vu->up.magic_p != NMG_EDGEUSE_MAGIC )
						continue;

					eu1 = vu->up.eu_p;

					vu2 = BU_LIST_NEXT( vertexuse, &vu->l );
					while( BU_LIST_NOT_HEAD( &vu2->l, &v2->vu_hd ) )
					{
						if( *vu2->up.magic_p != NMG_EDGEUSE_MAGIC )
						{
							vu2 = BU_LIST_NEXT( vertexuse, &vu2->l );
							continue;
						}
						eu2 = vu2->up.eu_p;
						if( eu2->eumate_p->vu_p->v_p == eu1->eumate_p->vu_p->v_p &&
							eu2->e_p != eu1->e_p )
						{
							struct edge *e1, *e2;

							e1 = eu1->e_p;
							e2 = eu2->e_p;

							nmg_radial_join_eu_NEW( eu2, eu1, tol );
							if( eu1->e_p != e1 )
								bu_ptbl_zero( &edge_table, (long *)e1 );
							if( eu2->e_p != e2 )
								bu_ptbl_zero( &edge_table, (long *)e2 );
						}
						vu2 = BU_LIST_NEXT( vertexuse, &vu2->l );
					}
				}
			}
			else if( choice == 2 )
			{
				struct edgeuse *eu1,*eu2;
				struct vertexuse *vu2;
#if EDGE_COLLAPSE_DEBUG
				bu_log( "\tMoving v2 to v1 (%g %g %g) -> (%g %g %g)\n", V3ARGS( v2->vg_p->coord ), V3ARGS( v1->vg_p->coord ) );
#endif
				/* vertex2 will be moved to vertex1 */
				/* recalculate edge geometry */
				for( BU_LIST_FOR( vu, vertexuse, &v2->vu_hd ) )
				{
					struct faceuse *fu;
					struct edge_g_lseg *eg;
					struct vertex_g *v1a;

					if( *vu->up.magic_p != NMG_EDGEUSE_MAGIC )
						continue;

					eu1 = vu->up.eu_p;
					fu = nmg_find_fu_of_eu( eu1 );
					if( !fu )
						continue;

					if( fu->orientation != OT_SAME )
						continue;

					if( !eu1->g.magic_p )
						nmg_edge_g( eu1 );
					else if( *eu1->g.magic_p != NMG_EDGE_G_LSEG_MAGIC )
						continue;

					eg = eu1->g.lseg_p;
					v1a = eu1->eumate_p->vu_p->v_p->vg_p;
					VSUB2( eg->e_dir, v1->vg_p->coord, v1a->coord );
					VMOVE( eg->e_pt, v1->vg_p->coord );
				}

				done = 0;
				while( !done )
				{
					vu = BU_LIST_FIRST( vertexuse, &v2->vu_hd );
					if( BU_LIST_LAST( vertexuse, &v2->vu_hd ) == vu )
						done = 1;
					nmg_movevu( vu, v1 );
				}
				for( BU_LIST_FOR( vu, vertexuse, &v1->vu_hd ) )
				{
					if( *vu->up.magic_p != NMG_EDGEUSE_MAGIC )
						continue;

					eu1 = vu->up.eu_p;

					vu2 = BU_LIST_NEXT( vertexuse, &vu->l );
					while( BU_LIST_NOT_HEAD( &vu2->l, &v1->vu_hd ) )
					{
						if( *vu2->up.magic_p != NMG_EDGEUSE_MAGIC )
						{
							vu2 = BU_LIST_NEXT( vertexuse, &vu2->l );
							continue;
						}
						eu2 = vu2->up.eu_p;
						if( eu2->eumate_p->vu_p->v_p == eu1->eumate_p->vu_p->v_p &&
							eu2->e_p != eu1->e_p )
						{
							struct edge *e1, *e2;

							e1 = eu1->e_p;
							e2 = eu2->e_p;
							nmg_radial_join_eu_NEW( eu2, eu1, tol );
							if( eu1->e_p != e1 )
								bu_ptbl_zero( &edge_table, (long *)e1 );
							if( eu2->e_p != e2 )
								bu_ptbl_zero( &edge_table, (long *)e2 );
						}
						vu2 = BU_LIST_NEXT( vertexuse, &vu2->l );
					}
				}
			}
			else
				continue;
		}
		count += sub_count;
	}

	if( count )
	{
		/* recalculate face planes */
		/* re-use edge table space */
		bu_ptbl_reset( &edge_table );
		nmg_face_tabulate( &edge_table, &m->magic );

		for( i=0 ; i<BU_PTBL_END( &edge_table ) ; i++ )
		{
			struct face *f;
			struct faceuse *fu;

			f = (struct face *)BU_PTBL_GET( &edge_table, i );
			NMG_CK_FACE( f );
			fu = f->fu_p;
			if( fu->orientation != OT_SAME )
				fu = fu->fumate_p;
			if( fu->orientation != OT_SAME )
				bu_bomb( "nmg_edge_collapse: Face has no OT_SAME use!!!\n" );

			nmg_calc_face_g( fu );
		}
	}
	bu_ptbl_free( &edge_table );
	return( count );
}

/*			N M G _ B O T
 *
 *	Convert an NMG to a BOT solid
 */

struct rt_bot_internal *
nmg_bot(struct shell *s, const struct bn_tol *tol)
{
	struct rt_bot_internal	*bot;
	struct bu_ptbl		nmg_vertices;
	struct bu_ptbl		nmg_faces;
	int			i, face_no;
	struct vertex		*v;

	NMG_CK_SHELL( s );
	BN_CK_TOL(tol);

	/* first convert the NMG to triangles */
	(void)nmg_triangulate_shell(s, tol);

	/* make a list of all the vertices */
	nmg_vertex_tabulate( &nmg_vertices, &s->l.magic );

	/* and a list of all the faces */
	nmg_face_tabulate( &nmg_faces, &s->l.magic );

	/* now build the BOT */
	bot = (struct rt_bot_internal *)bu_malloc( sizeof( struct rt_bot_internal ), "BOT from NMG" );

	bot->magic = RT_BOT_INTERNAL_MAGIC;
	bot->mode = RT_BOT_SOLID;
	bot->orientation = RT_BOT_CCW;
	bot->bot_flags = 0;

	bot->num_vertices = BU_PTBL_LEN( &nmg_vertices );
	bot->num_faces = 0;

	/* count the number of triangles */
	for( i=0 ; i<BU_PTBL_LEN( &nmg_faces ); i++ )
	{
		struct face *f;
		struct faceuse *fu;
		struct loopuse *lu;

		f = (struct face *)BU_PTBL_GET( &nmg_faces, i );
		NMG_CK_FACE( f );

		fu = f->fu_p;

		if( fu->orientation != OT_SAME )
		{
			fu = fu->fumate_p;
			if( fu->orientation != OT_SAME )
			{
				bu_log( "nmg_bot(): Face has no OT_SAME use!!!!\n" );
				bu_free( (char *)bot->vertices, "BOT vertices" );
				bu_free( (char *)bot->faces, "BOT faces" );
				bu_free( (char *)bot, "BOT" );
				return( (struct rt_bot_internal *)NULL );
			}
		}

		for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
		{
			if( BU_LIST_FIRST_MAGIC(&lu->down_hd) != NMG_EDGEUSE_MAGIC )
				continue;
			bot->num_faces++;
		}
	}

	bot->faces = (int *)bu_calloc( bot->num_faces * 3, sizeof( int ), "BOT faces" );
	bot->vertices = (fastf_t *)bu_calloc( bot->num_vertices * 3, sizeof( fastf_t ), "BOT vertices" );

	bot->thickness = (fastf_t *)NULL;
	bot->face_mode = (struct bu_bitv *)NULL;

	/* fill in the vertices */
	for( i=0 ; i<BU_PTBL_LEN( &nmg_vertices ) ; i++ )
	{
		struct vertex_g *vg;

		v = (struct vertex *)BU_PTBL_GET( &nmg_vertices, i );
		NMG_CK_VERTEX( v );

		vg = v->vg_p;
		NMG_CK_VERTEX_G( vg );

		VMOVE( &bot->vertices[i*3], vg->coord );
	}

	/* fill in the faces */
	face_no = 0;
	for( i=0 ; i<BU_PTBL_LEN( &nmg_faces ); i++ )
	{
		struct face *f;
		struct faceuse *fu;
		struct loopuse *lu;

		f = (struct face *)BU_PTBL_GET( &nmg_faces, i );
		NMG_CK_FACE( f );

		fu = f->fu_p;

		if( fu->orientation != OT_SAME )
		{
			fu = fu->fumate_p;
			if( fu->orientation != OT_SAME )
			{
				bu_log( "nmg_bot(): Face has no OT_SAME use!!!!\n" );
				bu_free( (char *)bot->vertices, "BOT vertices" );
				bu_free( (char *)bot->faces, "BOT faces" );
				bu_free( (char *)bot, "BOT" );
				return( (struct rt_bot_internal *)NULL );
			}
		}

		for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
		{
			struct edgeuse *eu;
			int vertex_no=0;

			if( BU_LIST_FIRST_MAGIC(&lu->down_hd) != NMG_EDGEUSE_MAGIC )
				continue;

			for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
			{
				struct vertex *v;

				if( vertex_no > 2 )
				{
					bu_log( "nmg_bot(): Face has not been triangulated!!!\n" );
					bu_free( (char *)bot->vertices, "BOT vertices" );
					bu_free( (char *)bot->faces, "BOT faces" );
					bu_free( (char *)bot, "BOT" );
					return( (struct rt_bot_internal *)NULL );
				}

				v = eu->vu_p->v_p;
				NMG_CK_VERTEX( v );


				bot->faces[ face_no*3 + vertex_no ] = bu_ptbl_locate( &nmg_vertices, (long *)v );

				vertex_no++;
			}

			face_no++;
		}
	}

	bu_ptbl_free( &nmg_vertices );
	bu_ptbl_free( &nmg_faces );

	return( bot );
}
@


11.98
log
@change conf.h to a wrapped config.h
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/librt/nmg_misc.c,v 11.97 2004/04/05 08:48:57 morrison Exp $ (ARL)";
@


11.97
log
@merge of ansi-6-0-branch into HEAD
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d30 5
a34 1
#include "conf.h"
@


11.96
log
@update copyright to include span through 2003
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_misc.c,v 11.95 2002/12/13 20:09:22 jra Exp $ (ARL)";
d52 1
a52 2
nmg_snurb_calc_lu_uv_orient( lu )
const struct loopuse *lu;
d173 1
a173 5
nmg_snurb_fu_eval( fu, u, v, pt_on_srf )
const struct faceuse *fu;
const fastf_t u;
const fastf_t v;
point_t pt_on_srf;
d208 1
a208 5
nmg_snurb_fu_get_norm( fu, u, v, norm )
const struct faceuse *fu;
const fastf_t u;
const fastf_t v;
vect_t norm;
d234 1
a234 4
nmg_snurb_fu_get_norm_at_vu( fu, vu, norm )
const struct faceuse *fu;
const struct vertexuse *vu;
vect_t norm;
d261 1
a261 2
nmg_find_zero_length_edges( m )
const struct model *m;
d309 1
a309 4
nmg_find_top_face_in_dir( s, dir , flags )
const struct shell *s;
int dir;
long *flags;
d611 1
a611 4
nmg_find_top_face( s, dir , flags )
const struct shell *s;
int *dir;
long *flags;
d646 1
a646 4
nmg_assoc_void_shells( r , shells , ttol )
const struct nmgregion *r;
struct bu_ptbl *shells;
const struct bn_tol *ttol;
d854 1
a854 4
nmg_find_outer_and_void_shells( r , shells , tol )
struct nmgregion *r;
struct bu_ptbl ***shells;
const struct bn_tol *tol;
d949 1
a949 2
nmg_mark_edges_real( magic_p )
const long *magic_p;
d978 1
a978 3
nmg_tabulate_face_g_verts( tab , fg )
struct bu_ptbl *tab;
const struct face_g_plane *fg;
d1048 1
a1048 3
nmg_isect_shell_self( s , tol )
struct shell *s;
const struct bn_tol *tol;
d1156 1
a1156 4
nmg_next_radial_eu( eu , s , wires )
const struct edgeuse *eu;
const struct shell *s;
const int wires;
d1196 1
a1196 4
nmg_prev_radial_eu( eu , s , wires )
const struct edgeuse *eu;
const struct shell *s;
const int wires;
d1228 1
a1228 3
nmg_radial_face_count( eu , s )
const struct edgeuse *eu;
const struct shell *s;
d1262 1
a1262 3
nmg_check_closed_shell( s , tol )
const struct shell *s;
const struct bn_tol *tol;
d1310 1
a1310 4
nmg_move_lu_between_fus( dest , src , lu )
struct faceuse *dest;
struct faceuse *src;
struct loopuse *lu;
d1372 1
a1372 3
nmg_loop_plane_newell( lu, pl )
const struct loopuse *lu;
plane_t pl;
d1449 1
a1449 3
nmg_loop_plane_area( lu , pl )
const struct loopuse *lu;
plane_t pl;
d1562 1
a1562 3
nmg_calc_face_plane( fu_in, pl )
struct faceuse *fu_in;
plane_t pl;
d1803 1
a1803 2
nmg_calc_face_g( fu )
struct faceuse *fu;
d1827 1
a1827 2
nmg_faceuse_area( fu )
const struct faceuse *fu;
d1861 1
a1861 2
nmg_shell_area( s )
const struct shell *s;
d1885 1
a1885 2
nmg_region_area( r )
const struct nmgregion *r;
d1899 1
a1899 2
nmg_model_area( m )
const struct model *m;
d1933 1
a1933 5
rt_dist_line3_line3( dist , p1 , d1 , p2 , d2 , tol )
fastf_t dist[2];
const point_t p1,p2;
const vect_t d1,d2;
const struct bn_tol *tol;
d2017 1
a2017 6
rt_dist_line3_lseg3( dist , p , d , a , b , tol )
fastf_t dist[2];
const point_t p;
const vect_t d;
const point_t a,b;
const struct bn_tol *tol;
d2088 1
a2088 5
nmg_purge_unwanted_intersection_points(vert_list, mag_list, fu, tol)
struct bu_ptbl		*vert_list;
fastf_t			*mag_list;
const struct faceuse	*fu;
const struct bn_tol	*tol;
d2232 1
a2232 3
nmg_in_or_ref(vu, b)
struct vertexuse *vu;
struct bu_ptbl *b;
d2262 1
a2262 3
nmg_rebound( m, tol )
struct model		*m;
const struct bn_tol	*tol;
d2333 1
a2333 5
nmg_count_shell_kids(m, total_faces, total_wires, total_points)
const struct model *m;
unsigned long *total_wires;
unsigned long *total_faces;
unsigned long *total_points;
d2387 1
a2387 6
order_tbl( tbl, start_index , index , tbl_size , loop_size )
struct bu_ptbl *tbl;
int start_index;
int **index;
int tbl_size;
int *loop_size;
d2456 1
a2456 3
nmg_close_shell( s , tol )
struct shell *s;
const struct bn_tol *tol;
d2939 1
a2939 4
nmg_dup_shell( s , trans_tbl, tol )
struct shell *s;
long ***trans_tbl;
const struct bn_tol *tol;
d3161 1
a3161 2
*nmg_pop_eu( stack )
struct bu_ptbl *stack;
d3179 1
a3179 3
nmg_reverse_radials( fu, tol )
struct faceuse *fu;
const struct bn_tol *tol;
d3233 1
a3233 3
nmg_reverse_face_and_radials( fu , tol )
struct faceuse *fu;
const struct bn_tol *tol;
d3295 1
a3295 2
nmg_shell_is_void( s )
const struct shell *s;
d3349 1
a3349 4
nmg_propagate_normals( fu_in , flags , tol )
struct faceuse *fu_in;
long *flags;
const struct bn_tol *tol;
d3481 1
a3481 2
nmg_disconnect_shells( r )
struct nmgregion *r;
d3604 1
a3604 2
nmg_connect_same_fu_orients( s )
struct shell *s;
d3652 1
a3652 3
nmg_fix_decomposed_shell_normals( s, tol )
struct shell *s;
const struct bn_tol *tol;
d3773 1
a3773 3
nmg_mk_model_from_region( r, reindex )
struct nmgregion *r;
int reindex;
d3868 1
a3868 3
nmg_fix_normals(s_orig, tol)
struct shell *s_orig;
const struct bn_tol *tol;
d4057 1
a4057 3
nmg_break_long_edges( s , tol )
struct shell *s;
const struct bn_tol *tol;
d4164 1
a4164 2
nmg_mk_new_face_from_loop( lu )
struct loopuse *lu;
d4235 1
a4235 4
nmg_split_loops_handler( fu_p , sl_state , after )
long *fu_p;
genptr_t sl_state;
int after;
d4428 1
a4428 3
nmg_split_loops_into_faces( magic_p , tol )
long		*magic_p;
const struct bn_tol	*tol;
d4473 1
a4473 3
nmg_decompose_shell( s , tol )
struct shell *s;
const struct bn_tol *tol;
d4935 1
a4935 4
nmg_stash_model_to_file( filename, m, title )
const char		*filename;
const struct model	*m;
const char		*title;
d5010 1
a5010 4
nmg_unbreak_handler( eup , state , after )
long	*eup;
genptr_t state;
int	after;
d5088 1
a5088 2
nmg_unbreak_region_edges( magic_p )
long		*magic_p;
d5145 1
a5145 6
rt_dist_pt3_line3( dist, pca, a, dir, p, tol )
fastf_t		*dist;
point_t		pca;
const point_t	a, p;
const vect_t	dir;
const struct bn_tol *tol;
d5203 1
a5203 3
nmg_mv_shell_to_region( s , r )
struct shell *s;
struct nmgregion *r;
d5247 1
a5247 5
nmg_find_isect_faces( new_v , faces , free_edges , tol )
const struct vertex *new_v;
struct bu_ptbl *faces;
int *free_edges;
const struct bn_tol *tol;
d5325 1
a5325 4
nmg_simple_vertex_solve( new_v , faces, tol )
struct vertex *new_v;
const struct bu_ptbl *faces;
const struct bn_tol *tol;
d5454 1
a5454 3
nmg_ck_vert_on_fus( v , tol )
const struct vertex *v;
const struct bn_tol *tol;
d5518 1
a5518 3
nmg_pr_inter( new_v , int_faces )
const struct vertex *new_v;
const struct bu_ptbl *int_faces;
d5619 1
a5619 4
nmg_get_edge_lines( new_v , int_faces , tol )
struct vertex *new_v;
struct bu_ptbl *int_faces;
const struct bn_tol *tol;
d5867 1
a5867 5
nmg_get_max_edge_inters( new_v , int_faces , faces , tol )
const struct vertex *new_v;
struct bu_ptbl *int_faces;
const struct bu_ptbl *faces;
const struct bn_tol *tol;
d6044 1
a6044 5
nmg_fuse_inters( i_fus , j_fus , int_faces , tol )
struct intersect_fus *i_fus;
struct intersect_fus *j_fus;
struct bu_ptbl *int_faces;
const struct bn_tol *tol;
d6112 1
a6112 4
nmg_split_edges_at_pts( new_v , int_faces , tol )
const struct vertex *new_v;
struct bu_ptbl *int_faces;
const struct bn_tol *tol;
d6220 1
a6220 4
nmg_remove_short_eus_inter( new_v , int_faces , tol )
struct vertex *new_v;
struct bu_ptbl *int_faces;
const struct bn_tol *tol;
d6371 1
a6371 4
nmg_simplify_inter( new_v , int_faces , tol )
const struct vertex *new_v;
struct bu_ptbl *int_faces;
const struct bn_tol *tol;
d6521 1
a6521 4
nmg_make_faces_at_vert( new_v , int_faces , tol )
struct vertex *new_v;
struct bu_ptbl *int_faces;
const struct bn_tol *tol;
d6756 1
a6756 2
nmg_kill_cracks_at_vertex( vp )
const struct vertex *vp;
d6869 1
a6869 5
nmg_dist_to_cross( i_fus , j_fus , new_pt , tol )
const struct intersect_fus *i_fus;
const struct intersect_fus *j_fus;
point_t new_pt;
const struct bn_tol *tol;
d7056 1
a7056 4
nmg_fix_crossed_loops( new_v , int_faces , tol )
struct vertex *new_v;
struct bu_ptbl *int_faces;
const struct bn_tol *tol;
d7234 1
a7234 4
nmg_calc_new_v( new_v , int_faces , tol )
struct vertex *new_v;
const struct bu_ptbl *int_faces;
const struct bn_tol *tol;
d7367 1
a7367 6
nmg_complex_vertex_solve( new_v , faces , free_edges , approximate , tol )
struct vertex *new_v;
const struct bu_ptbl *faces;
const int free_edges;
const int approximate;
const struct bn_tol *tol;
d7556 1
a7556 3
nmg_bad_face_normals( s , tol )
const struct shell *s;
const struct bn_tol *tol;
d7614 1
a7614 3
nmg_faces_are_radial( fu1 , fu2 )
const struct faceuse *fu1;
const struct faceuse *fu2;
d7669 1
a7669 4
nmg_move_edge_thru_pt( mv_eu , pt , tol )
struct edgeuse *mv_eu;
const point_t pt;
const struct bn_tol *tol;
d8025 1
a8025 3
nmg_vlist_to_wire_edges( s , vhead )
struct shell *s;
const struct bu_list *vhead;
d8084 1
a8084 7
nmg_follow_free_edges_to_vertex( vpa, vpb, bad_verts, s, eu, verts, found )
const struct vertex *vpa,*vpb;
struct bu_ptbl *bad_verts;
const struct shell *s;
const struct edgeuse *eu;
struct bu_ptbl *verts;
int *found;
d8197 1
a8197 4
nmg_find_path( vpa, vpb, bad_verts, s )
const struct vertex *vpa,*vpb;
struct bu_ptbl *bad_verts;
const struct shell *s;
d8289 1
a8289 4
nmg_glue_face_in_shell( fu , s , tol )
const struct faceuse *fu;
struct shell *s;
const struct bn_tol *tol;
d8406 1
a8406 5
nmg_make_connect_faces( dst , vpa , vpb , verts , tol )
struct shell *dst;
struct vertex *vpa,*vpb;
struct bu_ptbl *verts;
const struct bn_tol *tol;
d8774 1
a8774 5
nmg_open_shells_connect( dst , src , copy_tbl , tol )
struct shell *dst;
struct shell *src;
const long **copy_tbl;
const struct bn_tol *tol;
d9047 1
a9047 4
nmg_in_vert( new_v , approximate , tol )
struct vertex *new_v;
const int approximate;
const struct bn_tol *tol;
d9100 1
a9100 2
nmg_mirror_model( m )
struct model *m;
d9159 1
a9159 2
nmg_kill_cracks( s )
struct shell *s;
d9338 1
a9338 2
nmg_kill_zero_length_edgeuses( m )
struct model *m;
d9461 1
a9461 3
nmg_make_faces_within_tol( s, tol )
struct shell *s;
const struct bn_tol *tol;
d9529 1
a9529 3
nmg_intersect_loops_self( s, tol )
struct shell *s;
const struct bn_tol *tol;
d9648 1
a9648 2
rt_join_cnurbs( crv_head )
struct bu_list	*crv_head;
d9829 1
a9829 6
rt_arc2d_to_cnurb( i_center, i_start, i_end, point_type, tol )
point_t i_center;
point_t i_start;
point_t i_end;
int point_type;
const struct bn_tol *tol;
d10028 1
a10028 4
nmg_break_edge_at_verts( e, verts, tol )
struct edge *e;
struct bu_ptbl *verts;
const struct bn_tol *tol;
d10091 1
a10091 3
nmg_break_edges( magic_p, tol )
long *magic_p;
const struct bn_tol *tol;
d10121 1
a10121 3
Shell_is_arb( s, tab )
struct shell *s;
struct bu_ptbl *tab;
d10820 1
a10820 3
nmg_lu_is_convex( lu, tol )
struct loopuse *lu;
const struct bn_tol *tol;
d10877 1
a10877 4
nmg_to_poly( m, poly_int, tol )
const struct model *m;
struct rt_pg_internal *poly_int;
const struct bn_tol *tol;
d11049 1
a11049 3
nmg_simplify_shell_edges( s, tol )
struct shell *s;
const struct bn_tol *tol;
d11237 1
a11237 3
nmg_select_collapse( max_dist1, max_dot1, flip1, max_dist2, max_dot2, flip2, max_dot, tol_dist )
const fastf_t max_dist1, max_dot1, max_dist2, max_dot2, max_dot, tol_dist;
const int flip1, flip2;
d11292 1
a11292 5
nmg_edge_collapse( m, tol, tol_coll, min_angle )
struct model *m;
const struct bn_tol *tol;
const fastf_t tol_coll;
const fastf_t min_angle;
d11965 1
a11965 3
nmg_bot( s, tol )
struct shell *s;
const struct bn_tol *tol;
@


11.95
log
@Fixed a bug in nmg_find_outer_and_void_shells() where an outer shell was not recognozed
@
text
@d23 1
a23 1
 *	This software is Copyright (C) 1993 by the United States Army
d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_misc.c,v 11.94 2002/11/27 13:42:56 jra Exp $ (ARL)";
@


11.95.6.1
log
@merge from HEAD
@
text
@d23 1
a23 1
 *	This software is Copyright (C) 1993-2004 by the United States Army
d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_misc.c,v 11.96 2004/02/02 17:39:24 morrison Exp $ (ARL)";
@


11.95.6.2
log
@merge from head
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_misc.c,v 11.95.6.1 2004/02/12 18:37:44 erikg Exp $ (ARL)";
@


11.94
log
@BOT primitives can now have vertex normals
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_misc.c,v 11.93 2002/08/20 17:08:05 jra Exp $ (ARL)";
d923 10
a932 6
		f = nmg_find_top_face( s, &dir , flags );
		fu = f->fu_p;
		if( fu->orientation != OT_SAME )
			fu = fu->fumate_p;
		if( fu->orientation != OT_SAME )
			rt_bomb( "nmg_find_outer_and_void_shells: Neither faceuse nor mate have OT_SAME orient\n" );
d934 9
a942 4
		NMG_GET_FU_NORMAL( normal , fu );
		if( normal[dir] > 0.0)
		{
			bu_ptbl_ins( outer_shells , (long *)s );	/* outer shell */
@


11.93
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_misc.c,v 11.91 2002/08/06 16:06:13 jra Exp $ (ARL)";
d12225 1
a12225 1
	bot->error_mode = 0;
@


11.93.4.1
log
@sync to HEAD...
@
text
@d23 1
a23 1
 *	This software is Copyright (C) 1993-2004 by the United States Army
d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/nmg_misc.c,v 11.96 2004/02/02 17:39:24 morrison Exp $ (ARL)";
d923 6
a928 4
		f = (struct face *)NULL;
		for( dir = X ; dir <= Z ; dir++ ) {
			if( (f = nmg_find_top_face_in_dir( s, dir , flags )) == (struct face *)NULL )
				continue;
d930 4
a933 15
			fu = f->fu_p;
			if( fu->orientation != OT_SAME )
				fu = fu->fumate_p;
			if( fu->orientation != OT_SAME )
				rt_bomb( "nmg_find_outer_and_void_shells: Neither faceuse nor mate have OT_SAME orient\n" );

			NMG_GET_FU_NORMAL( normal , fu );
			if( normal[dir] >= 0.0)	{
				bu_ptbl_ins( outer_shells , (long *)s );	/* outer shell */
				break;
			}
		}

		if( f == (struct face *)NULL ) {
			bu_bomb( "nmg_find_outer_and_void_shells: cannot find top face in a shell\n" );
d12225 1
a12225 1
	bot->bot_flags = 0;
@


11.93.2.1
log
@Initial ANSIfication
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_misc.c,v 11.93 2002/08/20 17:08:05 jra Exp $ (ARL)";
d52 2
a53 1
nmg_snurb_calc_lu_uv_orient(const struct loopuse *lu)
d174 5
a178 1
nmg_snurb_fu_eval(const struct faceuse *fu, const fastf_t u, const fastf_t v, fastf_t *pt_on_srf)
d213 5
a217 1
nmg_snurb_fu_get_norm(const struct faceuse *fu, const fastf_t u, const fastf_t v, fastf_t *norm)
d243 4
a246 1
nmg_snurb_fu_get_norm_at_vu(const struct faceuse *fu, const struct vertexuse *vu, fastf_t *norm)
d273 2
a274 1
nmg_find_zero_length_edges(const struct model *m)
d322 4
a325 1
nmg_find_top_face_in_dir(const struct shell *s, int dir, long int *flags)
d627 4
a630 1
nmg_find_top_face(const struct shell *s, int *dir, long int *flags)
d665 4
a668 1
nmg_assoc_void_shells(const struct nmgregion *r, struct bu_ptbl *shells, const struct bn_tol *ttol)
d876 4
a879 1
nmg_find_outer_and_void_shells(struct nmgregion *r, struct bu_ptbl ***shells, const struct bn_tol *tol)
d965 2
a966 1
nmg_mark_edges_real(const long int *magic_p)
d995 3
a997 1
nmg_tabulate_face_g_verts(struct bu_ptbl *tab, const struct face_g_plane *fg)
d1067 3
a1069 1
nmg_isect_shell_self(struct shell *s, const struct bn_tol *tol)
d1177 4
a1180 1
nmg_next_radial_eu(const struct edgeuse *eu, const struct shell *s, const int wires)
d1220 4
a1223 1
nmg_prev_radial_eu(const struct edgeuse *eu, const struct shell *s, const int wires)
d1255 3
a1257 1
nmg_radial_face_count(const struct edgeuse *eu, const struct shell *s)
d1291 3
a1293 1
nmg_check_closed_shell(const struct shell *s, const struct bn_tol *tol)
d1341 4
a1344 1
nmg_move_lu_between_fus(struct faceuse *dest, struct faceuse *src, struct loopuse *lu)
d1406 3
a1408 1
nmg_loop_plane_newell(const struct loopuse *lu, fastf_t *pl)
d1485 3
a1487 1
nmg_loop_plane_area(const struct loopuse *lu, fastf_t *pl)
d1600 3
a1602 1
nmg_calc_face_plane(struct faceuse *fu_in, fastf_t *pl)
d1843 2
a1844 1
nmg_calc_face_g(struct faceuse *fu)
d1868 2
a1869 1
nmg_faceuse_area(const struct faceuse *fu)
d1903 2
a1904 1
nmg_shell_area(const struct shell *s)
d1928 2
a1929 1
nmg_region_area(const struct nmgregion *r)
d1943 2
a1944 1
nmg_model_area(const struct model *m)
d1978 5
a1982 1
rt_dist_line3_line3(fastf_t *dist, const fastf_t *p1, const fastf_t *d1, const fastf_t *p2, const fastf_t *d2, const struct bn_tol *tol)
d2066 6
a2071 1
rt_dist_line3_lseg3(fastf_t *dist, const fastf_t *p, const fastf_t *d, const fastf_t *a, const fastf_t *b, const struct bn_tol *tol)
d2142 5
a2146 1
nmg_purge_unwanted_intersection_points(struct bu_ptbl *vert_list, fastf_t *mag_list, const struct faceuse *fu, const struct bn_tol *tol)
d2290 3
a2292 1
nmg_in_or_ref(struct vertexuse *vu, struct bu_ptbl *b)
d2322 3
a2324 1
nmg_rebound(struct model *m, const struct bn_tol *tol)
d2395 5
a2399 1
nmg_count_shell_kids(const struct model *m, long unsigned int *total_faces, long unsigned int *total_wires, long unsigned int *total_points)
d2453 6
a2458 1
order_tbl(struct bu_ptbl *tbl, int start_index, int **index, int tbl_size, int *loop_size)
d2527 3
a2529 1
nmg_close_shell(struct shell *s, const struct bn_tol *tol)
d3012 4
a3015 1
nmg_dup_shell(struct shell *s, long int ***trans_tbl, const struct bn_tol *tol)
d3237 2
a3238 1
*nmg_pop_eu(struct bu_ptbl *stack)
d3256 3
a3258 1
nmg_reverse_radials(struct faceuse *fu, const struct bn_tol *tol)
d3312 3
a3314 1
nmg_reverse_face_and_radials(struct faceuse *fu, const struct bn_tol *tol)
d3376 2
a3377 1
nmg_shell_is_void(const struct shell *s)
d3431 4
a3434 1
nmg_propagate_normals(struct faceuse *fu_in, long int *flags, const struct bn_tol *tol)
d3566 2
a3567 1
nmg_disconnect_shells(struct nmgregion *r)
d3690 2
a3691 1
nmg_connect_same_fu_orients(struct shell *s)
d3739 3
a3741 1
nmg_fix_decomposed_shell_normals(struct shell *s, const struct bn_tol *tol)
d3862 3
a3864 1
nmg_mk_model_from_region(struct nmgregion *r, int reindex)
d3959 3
a3961 1
nmg_fix_normals(struct shell *s_orig, const struct bn_tol *tol)
d4150 3
a4152 1
nmg_break_long_edges(struct shell *s, const struct bn_tol *tol)
d4259 2
a4260 1
nmg_mk_new_face_from_loop(struct loopuse *lu)
d4331 4
a4334 1
nmg_split_loops_handler(long int *fu_p, genptr_t sl_state, int after)
d4527 3
a4529 1
nmg_split_loops_into_faces(long int *magic_p, const struct bn_tol *tol)
d4574 3
a4576 1
nmg_decompose_shell(struct shell *s, const struct bn_tol *tol)
d5038 4
a5041 1
nmg_stash_model_to_file(const char *filename, const struct model *m, const char *title)
d5116 4
a5119 1
nmg_unbreak_handler(long int *eup, genptr_t state, int after)
d5197 2
a5198 1
nmg_unbreak_region_edges(long int *magic_p)
d5255 6
a5260 1
rt_dist_pt3_line3(fastf_t *dist, fastf_t *pca, const fastf_t *a, const fastf_t *dir, const fastf_t *p, const struct bn_tol *tol)
d5318 3
a5320 1
nmg_mv_shell_to_region(struct shell *s, struct nmgregion *r)
d5364 5
a5368 1
nmg_find_isect_faces(const struct vertex *new_v, struct bu_ptbl *faces, int *free_edges, const struct bn_tol *tol)
d5446 4
a5449 1
nmg_simple_vertex_solve(struct vertex *new_v, const struct bu_ptbl *faces, const struct bn_tol *tol)
d5578 3
a5580 1
nmg_ck_vert_on_fus(const struct vertex *v, const struct bn_tol *tol)
d5644 3
a5646 1
nmg_pr_inter(const struct vertex *new_v, const struct bu_ptbl *int_faces)
d5747 4
a5750 1
nmg_get_edge_lines(struct vertex *new_v, struct bu_ptbl *int_faces, const struct bn_tol *tol)
d5998 5
a6002 1
nmg_get_max_edge_inters(const struct vertex *new_v, struct bu_ptbl *int_faces, const struct bu_ptbl *faces, const struct bn_tol *tol)
d6179 5
a6183 1
nmg_fuse_inters(struct intersect_fus *i_fus, struct intersect_fus *j_fus, struct bu_ptbl *int_faces, const struct bn_tol *tol)
d6251 4
a6254 1
nmg_split_edges_at_pts(const struct vertex *new_v, struct bu_ptbl *int_faces, const struct bn_tol *tol)
d6362 4
a6365 1
nmg_remove_short_eus_inter(struct vertex *new_v, struct bu_ptbl *int_faces, const struct bn_tol *tol)
d6516 4
a6519 1
nmg_simplify_inter(const struct vertex *new_v, struct bu_ptbl *int_faces, const struct bn_tol *tol)
d6669 4
a6672 1
nmg_make_faces_at_vert(struct vertex *new_v, struct bu_ptbl *int_faces, const struct bn_tol *tol)
d6907 2
a6908 1
nmg_kill_cracks_at_vertex(const struct vertex *vp)
d7021 5
a7025 1
nmg_dist_to_cross(const struct intersect_fus *i_fus, const struct intersect_fus *j_fus, fastf_t *new_pt, const struct bn_tol *tol)
d7212 4
a7215 1
nmg_fix_crossed_loops(struct vertex *new_v, struct bu_ptbl *int_faces, const struct bn_tol *tol)
d7393 4
a7396 1
nmg_calc_new_v(struct vertex *new_v, const struct bu_ptbl *int_faces, const struct bn_tol *tol)
d7529 6
a7534 1
nmg_complex_vertex_solve(struct vertex *new_v, const struct bu_ptbl *faces, const int free_edges, const int approximate, const struct bn_tol *tol)
d7723 3
a7725 1
nmg_bad_face_normals(const struct shell *s, const struct bn_tol *tol)
d7783 3
a7785 1
nmg_faces_are_radial(const struct faceuse *fu1, const struct faceuse *fu2)
d7840 4
a7843 1
nmg_move_edge_thru_pt(struct edgeuse *mv_eu, const fastf_t *pt, const struct bn_tol *tol)
d8199 3
a8201 1
nmg_vlist_to_wire_edges(struct shell *s, const struct bu_list *vhead)
d8260 7
a8266 1
nmg_follow_free_edges_to_vertex(const struct vertex *vpa, const struct vertex *vpb, struct bu_ptbl *bad_verts, const struct shell *s, const struct edgeuse *eu, struct bu_ptbl *verts, int *found)
d8379 4
a8382 1
nmg_find_path(const struct vertex *vpa, const struct vertex *vpb, struct bu_ptbl *bad_verts, const struct shell *s)
d8474 4
a8477 1
nmg_glue_face_in_shell(const struct faceuse *fu, struct shell *s, const struct bn_tol *tol)
d8594 5
a8598 1
nmg_make_connect_faces(struct shell *dst, struct vertex *vpa, struct vertex *vpb, struct bu_ptbl *verts, const struct bn_tol *tol)
d8966 5
a8970 1
nmg_open_shells_connect(struct shell *dst, struct shell *src, const long int **copy_tbl, const struct bn_tol *tol)
d9243 4
a9246 1
nmg_in_vert(struct vertex *new_v, const int approximate, const struct bn_tol *tol)
d9299 2
a9300 1
nmg_mirror_model(struct model *m)
d9359 2
a9360 1
nmg_kill_cracks(struct shell *s)
d9539 2
a9540 1
nmg_kill_zero_length_edgeuses(struct model *m)
d9663 3
a9665 1
nmg_make_faces_within_tol(struct shell *s, const struct bn_tol *tol)
d9733 3
a9735 1
nmg_intersect_loops_self(struct shell *s, const struct bn_tol *tol)
d9854 2
a9855 1
rt_join_cnurbs(struct bu_list *crv_head)
d10036 6
a10041 1
rt_arc2d_to_cnurb(fastf_t *i_center, fastf_t *i_start, fastf_t *i_end, int point_type, const struct bn_tol *tol)
d10240 4
a10243 1
nmg_break_edge_at_verts(struct edge *e, struct bu_ptbl *verts, const struct bn_tol *tol)
d10306 3
a10308 1
nmg_break_edges(long int *magic_p, const struct bn_tol *tol)
d10338 3
a10340 1
Shell_is_arb(struct shell *s, struct bu_ptbl *tab)
d11039 3
a11041 1
nmg_lu_is_convex(struct loopuse *lu, const struct bn_tol *tol)
d11098 4
a11101 1
nmg_to_poly(const struct model *m, struct rt_pg_internal *poly_int, const struct bn_tol *tol)
d11273 3
a11275 1
nmg_simplify_shell_edges(struct shell *s, const struct bn_tol *tol)
d11463 3
a11465 1
nmg_select_collapse(const fastf_t max_dist1, const fastf_t max_dot1, const int flip1, const fastf_t max_dist2, const fastf_t max_dot2, const int flip2, const fastf_t max_dot, const fastf_t tol_dist)
d11520 5
a11524 1
nmg_edge_collapse(struct model *m, const struct bn_tol *tol, const fastf_t tol_coll, const fastf_t min_angle)
d12197 3
a12199 1
nmg_bot(struct shell *s, const struct bn_tol *tol)
@


11.93.2.2
log
@sync branch with HEAD
@
text
@d23 1
a23 1
 *	This software is Copyright (C) 1993-2004 by the United States Army
d27 1
a27 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d898 6
a903 4
		f = (struct face *)NULL;
		for( dir = X ; dir <= Z ; dir++ ) {
			if( (f = nmg_find_top_face_in_dir( s, dir , flags )) == (struct face *)NULL )
				continue;
d905 4
a908 15
			fu = f->fu_p;
			if( fu->orientation != OT_SAME )
				fu = fu->fumate_p;
			if( fu->orientation != OT_SAME )
				rt_bomb( "nmg_find_outer_and_void_shells: Neither faceuse nor mate have OT_SAME orient\n" );

			NMG_GET_FU_NORMAL( normal , fu );
			if( normal[dir] >= 0.0)	{
				bu_ptbl_ins( outer_shells , (long *)s );	/* outer shell */
				break;
			}
		}

		if( f == (struct face *)NULL ) {
			bu_bomb( "nmg_find_outer_and_void_shells: cannot find top face in a shell\n" );
d11982 1
a11982 1
	bot->bot_flags = 0;
@


11.92
log
@Converted from K&R to ANSI C - RFH
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_misc.c,v 11.90 2001/10/02 19:24:31 jra Exp $ (ARL)";
d52 2
a53 1
nmg_snurb_calc_lu_uv_orient(const struct loopuse *lu)
d174 5
a178 1
nmg_snurb_fu_eval(const struct faceuse *fu, const fastf_t u, const fastf_t v, fastf_t *pt_on_srf)
d213 5
a217 1
nmg_snurb_fu_get_norm(const struct faceuse *fu, const fastf_t u, const fastf_t v, fastf_t *norm)
d243 4
a246 1
nmg_snurb_fu_get_norm_at_vu(const struct faceuse *fu, const struct vertexuse *vu, fastf_t *norm)
d273 2
a274 1
nmg_find_zero_length_edges(const struct model *m)
d322 4
a325 1
nmg_find_top_face_in_dir(const struct shell *s, int dir, long int *flags)
d627 4
a630 1
nmg_find_top_face(const struct shell *s, int *dir, long int *flags)
d665 4
a668 1
nmg_assoc_void_shells(const struct nmgregion *r, struct bu_ptbl *shells, const struct bn_tol *ttol)
d876 4
a879 1
nmg_find_outer_and_void_shells(struct nmgregion *r, struct bu_ptbl ***shells, const struct bn_tol *tol)
d965 2
a966 1
nmg_mark_edges_real(const long int *magic_p)
d995 3
a997 1
nmg_tabulate_face_g_verts(struct bu_ptbl *tab, const struct face_g_plane *fg)
d1067 3
a1069 1
nmg_isect_shell_self(struct shell *s, const struct bn_tol *tol)
d1177 4
a1180 1
nmg_next_radial_eu(const struct edgeuse *eu, const struct shell *s, const int wires)
d1220 4
a1223 1
nmg_prev_radial_eu(const struct edgeuse *eu, const struct shell *s, const int wires)
d1255 3
a1257 1
nmg_radial_face_count(const struct edgeuse *eu, const struct shell *s)
d1291 3
a1293 1
nmg_check_closed_shell(const struct shell *s, const struct bn_tol *tol)
d1341 4
a1344 1
nmg_move_lu_between_fus(struct faceuse *dest, struct faceuse *src, struct loopuse *lu)
d1406 3
a1408 1
nmg_loop_plane_newell(const struct loopuse *lu, fastf_t *pl)
d1485 3
a1487 1
nmg_loop_plane_area(const struct loopuse *lu, fastf_t *pl)
d1600 3
a1602 1
nmg_calc_face_plane(struct faceuse *fu_in, fastf_t *pl)
d1843 2
a1844 1
nmg_calc_face_g(struct faceuse *fu)
d1868 2
a1869 1
nmg_faceuse_area(const struct faceuse *fu)
d1903 2
a1904 1
nmg_shell_area(const struct shell *s)
d1928 2
a1929 1
nmg_region_area(const struct nmgregion *r)
d1943 2
a1944 1
nmg_model_area(const struct model *m)
d1978 5
a1982 1
rt_dist_line3_line3(fastf_t *dist, const fastf_t *p1, const fastf_t *d1, const fastf_t *p2, const fastf_t *d2, const struct bn_tol *tol)
d2066 6
a2071 1
rt_dist_line3_lseg3(fastf_t *dist, const fastf_t *p, const fastf_t *d, const fastf_t *a, const fastf_t *b, const struct bn_tol *tol)
d2142 5
a2146 1
nmg_purge_unwanted_intersection_points(struct bu_ptbl *vert_list, fastf_t *mag_list, const struct faceuse *fu, const struct bn_tol *tol)
d2290 3
a2292 1
nmg_in_or_ref(struct vertexuse *vu, struct bu_ptbl *b)
d2322 3
a2324 1
nmg_rebound(struct model *m, const struct bn_tol *tol)
d2395 5
a2399 1
nmg_count_shell_kids(const struct model *m, long unsigned int *total_faces, long unsigned int *total_wires, long unsigned int *total_points)
d2453 6
a2458 1
order_tbl(struct bu_ptbl *tbl, int start_index, int **index, int tbl_size, int *loop_size)
d2527 3
a2529 1
nmg_close_shell(struct shell *s, const struct bn_tol *tol)
d3012 4
a3015 1
nmg_dup_shell(struct shell *s, long int ***trans_tbl, const struct bn_tol *tol)
d3237 2
a3238 1
*nmg_pop_eu(struct bu_ptbl *stack)
d3256 3
a3258 1
nmg_reverse_radials(struct faceuse *fu, const struct bn_tol *tol)
d3312 3
a3314 1
nmg_reverse_face_and_radials(struct faceuse *fu, const struct bn_tol *tol)
d3376 2
a3377 1
nmg_shell_is_void(const struct shell *s)
d3431 4
a3434 1
nmg_propagate_normals(struct faceuse *fu_in, long int *flags, const struct bn_tol *tol)
d3566 2
a3567 1
nmg_disconnect_shells(struct nmgregion *r)
d3690 2
a3691 1
nmg_connect_same_fu_orients(struct shell *s)
d3739 3
a3741 1
nmg_fix_decomposed_shell_normals(struct shell *s, const struct bn_tol *tol)
d3862 3
a3864 1
nmg_mk_model_from_region(struct nmgregion *r, int reindex)
d3959 3
a3961 1
nmg_fix_normals(struct shell *s_orig, const struct bn_tol *tol)
d4150 3
a4152 1
nmg_break_long_edges(struct shell *s, const struct bn_tol *tol)
d4259 2
a4260 1
nmg_mk_new_face_from_loop(struct loopuse *lu)
d4331 4
a4334 1
nmg_split_loops_handler(long int *fu_p, genptr_t sl_state, int after)
d4527 3
a4529 1
nmg_split_loops_into_faces(long int *magic_p, const struct bn_tol *tol)
d4574 3
a4576 1
nmg_decompose_shell(struct shell *s, const struct bn_tol *tol)
d5038 4
a5041 1
nmg_stash_model_to_file(const char *filename, const struct model *m, const char *title)
d5045 4
d5066 25
a5090 5
	/* Scale change on export is 1.0 -- no change */
	if( wdb_put_internal( fp, "error.s", &intern, 1.0 ) < 0 )  {
		bu_bomb("nmg_stash_model_to_file() wdb_put_internal failure\n");
	}
	/* intern has been freed */
d5116 4
a5119 1
nmg_unbreak_handler(long int *eup, genptr_t state, int after)
d5197 2
a5198 1
nmg_unbreak_region_edges(long int *magic_p)
d5255 6
a5260 1
rt_dist_pt3_line3(fastf_t *dist, fastf_t *pca, const fastf_t *a, const fastf_t *dir, const fastf_t *p, const struct bn_tol *tol)
d5318 3
a5320 1
nmg_mv_shell_to_region(struct shell *s, struct nmgregion *r)
d5364 5
a5368 1
nmg_find_isect_faces(const struct vertex *new_v, struct bu_ptbl *faces, int *free_edges, const struct bn_tol *tol)
d5446 4
a5449 1
nmg_simple_vertex_solve(struct vertex *new_v, const struct bu_ptbl *faces, const struct bn_tol *tol)
d5578 3
a5580 1
nmg_ck_vert_on_fus(const struct vertex *v, const struct bn_tol *tol)
d5644 3
a5646 1
nmg_pr_inter(const struct vertex *new_v, const struct bu_ptbl *int_faces)
d5747 4
a5750 1
nmg_get_edge_lines(struct vertex *new_v, struct bu_ptbl *int_faces, const struct bn_tol *tol)
d5998 5
a6002 1
nmg_get_max_edge_inters(const struct vertex *new_v, struct bu_ptbl *int_faces, const struct bu_ptbl *faces, const struct bn_tol *tol)
d6179 5
a6183 1
nmg_fuse_inters(struct intersect_fus *i_fus, struct intersect_fus *j_fus, struct bu_ptbl *int_faces, const struct bn_tol *tol)
d6251 4
a6254 1
nmg_split_edges_at_pts(const struct vertex *new_v, struct bu_ptbl *int_faces, const struct bn_tol *tol)
d6362 4
a6365 1
nmg_remove_short_eus_inter(struct vertex *new_v, struct bu_ptbl *int_faces, const struct bn_tol *tol)
d6516 4
a6519 1
nmg_simplify_inter(const struct vertex *new_v, struct bu_ptbl *int_faces, const struct bn_tol *tol)
d6669 4
a6672 1
nmg_make_faces_at_vert(struct vertex *new_v, struct bu_ptbl *int_faces, const struct bn_tol *tol)
d6907 2
a6908 1
nmg_kill_cracks_at_vertex(const struct vertex *vp)
d7021 5
a7025 1
nmg_dist_to_cross(const struct intersect_fus *i_fus, const struct intersect_fus *j_fus, fastf_t *new_pt, const struct bn_tol *tol)
d7212 4
a7215 1
nmg_fix_crossed_loops(struct vertex *new_v, struct bu_ptbl *int_faces, const struct bn_tol *tol)
d7393 4
a7396 1
nmg_calc_new_v(struct vertex *new_v, const struct bu_ptbl *int_faces, const struct bn_tol *tol)
d7529 6
a7534 1
nmg_complex_vertex_solve(struct vertex *new_v, const struct bu_ptbl *faces, const int free_edges, const int approximate, const struct bn_tol *tol)
d7723 3
a7725 1
nmg_bad_face_normals(const struct shell *s, const struct bn_tol *tol)
d7783 3
a7785 1
nmg_faces_are_radial(const struct faceuse *fu1, const struct faceuse *fu2)
d7840 4
a7843 1
nmg_move_edge_thru_pt(struct edgeuse *mv_eu, const fastf_t *pt, const struct bn_tol *tol)
d8199 3
a8201 1
nmg_vlist_to_wire_edges(struct shell *s, const struct bu_list *vhead)
d8260 7
a8266 1
nmg_follow_free_edges_to_vertex(const struct vertex *vpa, const struct vertex *vpb, struct bu_ptbl *bad_verts, const struct shell *s, const struct edgeuse *eu, struct bu_ptbl *verts, int *found)
d8379 4
a8382 1
nmg_find_path(const struct vertex *vpa, const struct vertex *vpb, struct bu_ptbl *bad_verts, const struct shell *s)
d8474 4
a8477 1
nmg_glue_face_in_shell(const struct faceuse *fu, struct shell *s, const struct bn_tol *tol)
d8594 5
a8598 1
nmg_make_connect_faces(struct shell *dst, struct vertex *vpa, struct vertex *vpb, struct bu_ptbl *verts, const struct bn_tol *tol)
d8966 5
a8970 1
nmg_open_shells_connect(struct shell *dst, struct shell *src, const long int **copy_tbl, const struct bn_tol *tol)
d9243 4
a9246 1
nmg_in_vert(struct vertex *new_v, const int approximate, const struct bn_tol *tol)
d9299 2
a9300 1
nmg_mirror_model(struct model *m)
d9359 2
a9360 1
nmg_kill_cracks(struct shell *s)
d9539 2
a9540 1
nmg_kill_zero_length_edgeuses(struct model *m)
d9663 3
a9665 1
nmg_make_faces_within_tol(struct shell *s, const struct bn_tol *tol)
d9733 3
a9735 1
nmg_intersect_loops_self(struct shell *s, const struct bn_tol *tol)
d9854 2
a9855 1
rt_join_cnurbs(struct bu_list *crv_head)
d10036 6
a10041 1
rt_arc2d_to_cnurb(fastf_t *i_center, fastf_t *i_start, fastf_t *i_end, int point_type, const struct bn_tol *tol)
d10240 4
a10243 1
nmg_break_edge_at_verts(struct edge *e, struct bu_ptbl *verts, const struct bn_tol *tol)
d10306 3
a10308 1
nmg_break_edges(long int *magic_p, const struct bn_tol *tol)
d10338 3
a10340 1
Shell_is_arb(struct shell *s, struct bu_ptbl *tab)
d11039 3
a11041 1
nmg_lu_is_convex(struct loopuse *lu, const struct bn_tol *tol)
d11098 4
a11101 1
nmg_to_poly(const struct model *m, struct rt_pg_internal *poly_int, const struct bn_tol *tol)
d11273 3
a11275 1
nmg_simplify_shell_edges(struct shell *s, const struct bn_tol *tol)
d11463 3
a11465 1
nmg_select_collapse(const fastf_t max_dist1, const fastf_t max_dot1, const int flip1, const fastf_t max_dist2, const fastf_t max_dot2, const int flip2, const fastf_t max_dot, const fastf_t tol_dist)
d11520 5
a11524 1
nmg_edge_collapse(struct model *m, const struct bn_tol *tol, const fastf_t tol_coll, const fastf_t min_angle)
d12197 3
a12199 1
nmg_bot(struct shell *s, const struct bn_tol *tol)
@


11.91
log
@corrected nmg_stash_model_to_file() so it no longer frees the NMG
@
text
@d52 1
a52 2
nmg_snurb_calc_lu_uv_orient( lu )
const struct loopuse *lu;
d173 1
a173 5
nmg_snurb_fu_eval( fu, u, v, pt_on_srf )
const struct faceuse *fu;
const fastf_t u;
const fastf_t v;
point_t pt_on_srf;
d208 1
a208 5
nmg_snurb_fu_get_norm( fu, u, v, norm )
const struct faceuse *fu;
const fastf_t u;
const fastf_t v;
vect_t norm;
d234 1
a234 4
nmg_snurb_fu_get_norm_at_vu( fu, vu, norm )
const struct faceuse *fu;
const struct vertexuse *vu;
vect_t norm;
d261 1
a261 2
nmg_find_zero_length_edges( m )
const struct model *m;
d309 1
a309 4
nmg_find_top_face_in_dir( s, dir , flags )
const struct shell *s;
int dir;
long *flags;
d611 1
a611 4
nmg_find_top_face( s, dir , flags )
const struct shell *s;
int *dir;
long *flags;
d646 1
a646 4
nmg_assoc_void_shells( r , shells , ttol )
const struct nmgregion *r;
struct bu_ptbl *shells;
const struct bn_tol *ttol;
d854 1
a854 4
nmg_find_outer_and_void_shells( r , shells , tol )
struct nmgregion *r;
struct bu_ptbl ***shells;
const struct bn_tol *tol;
d940 1
a940 2
nmg_mark_edges_real( magic_p )
const long *magic_p;
d969 1
a969 3
nmg_tabulate_face_g_verts( tab , fg )
struct bu_ptbl *tab;
const struct face_g_plane *fg;
d1039 1
a1039 3
nmg_isect_shell_self( s , tol )
struct shell *s;
const struct bn_tol *tol;
d1147 1
a1147 4
nmg_next_radial_eu( eu , s , wires )
const struct edgeuse *eu;
const struct shell *s;
const int wires;
d1187 1
a1187 4
nmg_prev_radial_eu( eu , s , wires )
const struct edgeuse *eu;
const struct shell *s;
const int wires;
d1219 1
a1219 3
nmg_radial_face_count( eu , s )
const struct edgeuse *eu;
const struct shell *s;
d1253 1
a1253 3
nmg_check_closed_shell( s , tol )
const struct shell *s;
const struct bn_tol *tol;
d1301 1
a1301 4
nmg_move_lu_between_fus( dest , src , lu )
struct faceuse *dest;
struct faceuse *src;
struct loopuse *lu;
d1363 1
a1363 3
nmg_loop_plane_newell( lu, pl )
const struct loopuse *lu;
plane_t pl;
d1440 1
a1440 3
nmg_loop_plane_area( lu , pl )
const struct loopuse *lu;
plane_t pl;
d1553 1
a1553 3
nmg_calc_face_plane( fu_in, pl )
struct faceuse *fu_in;
plane_t pl;
d1794 1
a1794 2
nmg_calc_face_g( fu )
struct faceuse *fu;
d1818 1
a1818 2
nmg_faceuse_area( fu )
const struct faceuse *fu;
d1852 1
a1852 2
nmg_shell_area( s )
const struct shell *s;
d1876 1
a1876 2
nmg_region_area( r )
const struct nmgregion *r;
d1890 1
a1890 2
nmg_model_area( m )
const struct model *m;
d1924 1
a1924 5
rt_dist_line3_line3( dist , p1 , d1 , p2 , d2 , tol )
fastf_t dist[2];
const point_t p1,p2;
const vect_t d1,d2;
const struct bn_tol *tol;
d2008 1
a2008 6
rt_dist_line3_lseg3( dist , p , d , a , b , tol )
fastf_t dist[2];
const point_t p;
const vect_t d;
const point_t a,b;
const struct bn_tol *tol;
d2079 1
a2079 5
nmg_purge_unwanted_intersection_points(vert_list, mag_list, fu, tol)
struct bu_ptbl		*vert_list;
fastf_t			*mag_list;
const struct faceuse	*fu;
const struct bn_tol	*tol;
d2223 1
a2223 3
nmg_in_or_ref(vu, b)
struct vertexuse *vu;
struct bu_ptbl *b;
d2253 1
a2253 3
nmg_rebound( m, tol )
struct model		*m;
const struct bn_tol	*tol;
d2324 1
a2324 5
nmg_count_shell_kids(m, total_faces, total_wires, total_points)
const struct model *m;
unsigned long *total_wires;
unsigned long *total_faces;
unsigned long *total_points;
d2378 1
a2378 6
order_tbl( tbl, start_index , index , tbl_size , loop_size )
struct bu_ptbl *tbl;
int start_index;
int **index;
int tbl_size;
int *loop_size;
d2447 1
a2447 3
nmg_close_shell( s , tol )
struct shell *s;
const struct bn_tol *tol;
d2930 1
a2930 4
nmg_dup_shell( s , trans_tbl, tol )
struct shell *s;
long ***trans_tbl;
const struct bn_tol *tol;
d3152 1
a3152 2
*nmg_pop_eu( stack )
struct bu_ptbl *stack;
d3170 1
a3170 3
nmg_reverse_radials( fu, tol )
struct faceuse *fu;
const struct bn_tol *tol;
d3224 1
a3224 3
nmg_reverse_face_and_radials( fu , tol )
struct faceuse *fu;
const struct bn_tol *tol;
d3286 1
a3286 2
nmg_shell_is_void( s )
const struct shell *s;
d3340 1
a3340 4
nmg_propagate_normals( fu_in , flags , tol )
struct faceuse *fu_in;
long *flags;
const struct bn_tol *tol;
d3472 1
a3472 2
nmg_disconnect_shells( r )
struct nmgregion *r;
d3595 1
a3595 2
nmg_connect_same_fu_orients( s )
struct shell *s;
d3643 1
a3643 3
nmg_fix_decomposed_shell_normals( s, tol )
struct shell *s;
const struct bn_tol *tol;
d3764 1
a3764 3
nmg_mk_model_from_region( r, reindex )
struct nmgregion *r;
int reindex;
d3859 1
a3859 3
nmg_fix_normals(s_orig, tol)
struct shell *s_orig;
const struct bn_tol *tol;
d4048 1
a4048 3
nmg_break_long_edges( s , tol )
struct shell *s;
const struct bn_tol *tol;
d4155 1
a4155 2
nmg_mk_new_face_from_loop( lu )
struct loopuse *lu;
d4226 1
a4226 4
nmg_split_loops_handler( fu_p , sl_state , after )
long *fu_p;
genptr_t sl_state;
int after;
d4419 1
a4419 3
nmg_split_loops_into_faces( magic_p , tol )
long		*magic_p;
const struct bn_tol	*tol;
d4464 1
a4464 3
nmg_decompose_shell( s , tol )
struct shell *s;
const struct bn_tol *tol;
d4926 1
a4926 4
nmg_stash_model_to_file( filename, m, title )
const char		*filename;
const struct model	*m;
const char		*title;
a4929 4
	struct bu_external	ext;
	int			ret;
	int			flags;
	char			*name="error.s";
d4947 5
a4951 25
	if( fp->dbip->dbi_version <= 4 )  {
		BU_INIT_EXTERNAL( &ext );
		ret = intern.idb_meth->ft_export( &ext, &intern, 1.0, fp->dbip, &rt_uniresource );
		if( ret < 0 )  {
			bu_log("rt_db_put_internal(%s):  solid export failure\n",
				name);
			ret = -1;
			goto out;
		}
		db_wrap_v4_external( &ext, name );
	} else {
		if( rt_db_cvt_to_external5( &ext, name, &intern, 1.0, fp->dbip, &rt_uniresource, intern.idb_major_type ) < 0 )  {
			bu_log("wdb_export(%s): solid export failure\n",
				name );
			ret = -2;
			goto out;
		}
	}
	BU_CK_EXTERNAL( &ext );

	flags = db_flags_internal( &intern );
	ret = wdb_export_external( fp, &ext, name, flags, intern.idb_type );
out:
	bu_free_external( &ext );
	wdb_close( fp );
d4977 1
a4977 4
nmg_unbreak_handler( eup , state , after )
long	*eup;
genptr_t state;
int	after;
d5055 1
a5055 2
nmg_unbreak_region_edges( magic_p )
long		*magic_p;
d5112 1
a5112 6
rt_dist_pt3_line3( dist, pca, a, dir, p, tol )
fastf_t		*dist;
point_t		pca;
const point_t	a, p;
const vect_t	dir;
const struct bn_tol *tol;
d5170 1
a5170 3
nmg_mv_shell_to_region( s , r )
struct shell *s;
struct nmgregion *r;
d5214 1
a5214 5
nmg_find_isect_faces( new_v , faces , free_edges , tol )
const struct vertex *new_v;
struct bu_ptbl *faces;
int *free_edges;
const struct bn_tol *tol;
d5292 1
a5292 4
nmg_simple_vertex_solve( new_v , faces, tol )
struct vertex *new_v;
const struct bu_ptbl *faces;
const struct bn_tol *tol;
d5421 1
a5421 3
nmg_ck_vert_on_fus( v , tol )
const struct vertex *v;
const struct bn_tol *tol;
d5485 1
a5485 3
nmg_pr_inter( new_v , int_faces )
const struct vertex *new_v;
const struct bu_ptbl *int_faces;
d5586 1
a5586 4
nmg_get_edge_lines( new_v , int_faces , tol )
struct vertex *new_v;
struct bu_ptbl *int_faces;
const struct bn_tol *tol;
d5834 1
a5834 5
nmg_get_max_edge_inters( new_v , int_faces , faces , tol )
const struct vertex *new_v;
struct bu_ptbl *int_faces;
const struct bu_ptbl *faces;
const struct bn_tol *tol;
d6011 1
a6011 5
nmg_fuse_inters( i_fus , j_fus , int_faces , tol )
struct intersect_fus *i_fus;
struct intersect_fus *j_fus;
struct bu_ptbl *int_faces;
const struct bn_tol *tol;
d6079 1
a6079 4
nmg_split_edges_at_pts( new_v , int_faces , tol )
const struct vertex *new_v;
struct bu_ptbl *int_faces;
const struct bn_tol *tol;
d6187 1
a6187 4
nmg_remove_short_eus_inter( new_v , int_faces , tol )
struct vertex *new_v;
struct bu_ptbl *int_faces;
const struct bn_tol *tol;
d6338 1
a6338 4
nmg_simplify_inter( new_v , int_faces , tol )
const struct vertex *new_v;
struct bu_ptbl *int_faces;
const struct bn_tol *tol;
d6488 1
a6488 4
nmg_make_faces_at_vert( new_v , int_faces , tol )
struct vertex *new_v;
struct bu_ptbl *int_faces;
const struct bn_tol *tol;
d6723 1
a6723 2
nmg_kill_cracks_at_vertex( vp )
const struct vertex *vp;
d6836 1
a6836 5
nmg_dist_to_cross( i_fus , j_fus , new_pt , tol )
const struct intersect_fus *i_fus;
const struct intersect_fus *j_fus;
point_t new_pt;
const struct bn_tol *tol;
d7023 1
a7023 4
nmg_fix_crossed_loops( new_v , int_faces , tol )
struct vertex *new_v;
struct bu_ptbl *int_faces;
const struct bn_tol *tol;
d7201 1
a7201 4
nmg_calc_new_v( new_v , int_faces , tol )
struct vertex *new_v;
const struct bu_ptbl *int_faces;
const struct bn_tol *tol;
d7334 1
a7334 6
nmg_complex_vertex_solve( new_v , faces , free_edges , approximate , tol )
struct vertex *new_v;
const struct bu_ptbl *faces;
const int free_edges;
const int approximate;
const struct bn_tol *tol;
d7523 1
a7523 3
nmg_bad_face_normals( s , tol )
const struct shell *s;
const struct bn_tol *tol;
d7581 1
a7581 3
nmg_faces_are_radial( fu1 , fu2 )
const struct faceuse *fu1;
const struct faceuse *fu2;
d7636 1
a7636 4
nmg_move_edge_thru_pt( mv_eu , pt , tol )
struct edgeuse *mv_eu;
const point_t pt;
const struct bn_tol *tol;
d7992 1
a7992 3
nmg_vlist_to_wire_edges( s , vhead )
struct shell *s;
const struct bu_list *vhead;
d8051 1
a8051 7
nmg_follow_free_edges_to_vertex( vpa, vpb, bad_verts, s, eu, verts, found )
const struct vertex *vpa,*vpb;
struct bu_ptbl *bad_verts;
const struct shell *s;
const struct edgeuse *eu;
struct bu_ptbl *verts;
int *found;
d8164 1
a8164 4
nmg_find_path( vpa, vpb, bad_verts, s )
const struct vertex *vpa,*vpb;
struct bu_ptbl *bad_verts;
const struct shell *s;
d8256 1
a8256 4
nmg_glue_face_in_shell( fu , s , tol )
const struct faceuse *fu;
struct shell *s;
const struct bn_tol *tol;
d8373 1
a8373 5
nmg_make_connect_faces( dst , vpa , vpb , verts , tol )
struct shell *dst;
struct vertex *vpa,*vpb;
struct bu_ptbl *verts;
const struct bn_tol *tol;
d8741 1
a8741 5
nmg_open_shells_connect( dst , src , copy_tbl , tol )
struct shell *dst;
struct shell *src;
const long **copy_tbl;
const struct bn_tol *tol;
d9014 1
a9014 4
nmg_in_vert( new_v , approximate , tol )
struct vertex *new_v;
const int approximate;
const struct bn_tol *tol;
d9067 1
a9067 2
nmg_mirror_model( m )
struct model *m;
d9126 1
a9126 2
nmg_kill_cracks( s )
struct shell *s;
d9305 1
a9305 2
nmg_kill_zero_length_edgeuses( m )
struct model *m;
d9428 1
a9428 3
nmg_make_faces_within_tol( s, tol )
struct shell *s;
const struct bn_tol *tol;
d9496 1
a9496 3
nmg_intersect_loops_self( s, tol )
struct shell *s;
const struct bn_tol *tol;
d9615 1
a9615 2
rt_join_cnurbs( crv_head )
struct bu_list	*crv_head;
d9796 1
a9796 6
rt_arc2d_to_cnurb( i_center, i_start, i_end, point_type, tol )
point_t i_center;
point_t i_start;
point_t i_end;
int point_type;
const struct bn_tol *tol;
d9995 1
a9995 4
nmg_break_edge_at_verts( e, verts, tol )
struct edge *e;
struct bu_ptbl *verts;
const struct bn_tol *tol;
d10058 1
a10058 3
nmg_break_edges( magic_p, tol )
long *magic_p;
const struct bn_tol *tol;
d10088 1
a10088 3
Shell_is_arb( s, tab )
struct shell *s;
struct bu_ptbl *tab;
d10787 1
a10787 3
nmg_lu_is_convex( lu, tol )
struct loopuse *lu;
const struct bn_tol *tol;
d10844 1
a10844 4
nmg_to_poly( m, poly_int, tol )
const struct model *m;
struct rt_pg_internal *poly_int;
const struct bn_tol *tol;
d11016 1
a11016 3
nmg_simplify_shell_edges( s, tol )
struct shell *s;
const struct bn_tol *tol;
d11204 1
a11204 3
nmg_select_collapse( max_dist1, max_dot1, flip1, max_dist2, max_dot2, flip2, max_dot, tol_dist )
const fastf_t max_dist1, max_dot1, max_dist2, max_dot2, max_dot, tol_dist;
const int flip1, flip2;
d11259 1
a11259 5
nmg_edge_collapse( m, tol, tol_coll, min_angle )
struct model *m;
const struct bn_tol *tol;
const fastf_t tol_coll;
const fastf_t min_angle;
d11932 1
a11932 3
nmg_bot( s, tol )
struct shell *s;
const struct bn_tol *tol;
@


11.90
log
@Routines were not setting idb_major_type in the internal structure
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_misc.c,v 11.89 2001/08/21 17:02:19 jra Exp $ (ARL)";
d5045 4
d5066 25
a5090 5
	/* Scale change on export is 1.0 -- no change */
	if( wdb_put_internal( fp, "error.s", &intern, 1.0 ) < 0 )  {
		bu_bomb("nmg_stash_model_to_file() wdb_put_internal failure\n");
	}
	/* intern has been freed */
@


11.89
log
@Eliminated a warning by changing the comment in a bu_log() call
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_misc.c,v 11.88 2001/04/05 19:35:35 morrison Exp $ (ARL)";
d5057 1
@


11.88
log
@updated SIGNED to signed
updated CONST to const
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_misc.c,v 11.87 2001/03/31 01:57:11 morrison Exp $ (ARL)";
d3841 1
a3841 1
		bu_log( "nmg_fix_decomposed_shell_normals: missed %d faces in shell x%x (was it decomposed????)\n", 
d3843 1
a3843 1
		rt_bomb( "nmg_fix_decomposed_shell_normals: missed faces in shell (was it decomposed????)\n" );
@


11.87
log
@Deprecated bn_mat_idn() and bn_mat_zero(), updated calls to h/vmath.h's MAT_IDN() and MAT_ZERO() performance improved macros.
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_misc.c,v 11.86 2000/10/24 19:31:45 mike Exp $ (ARL)";
d53 1
a53 1
CONST struct loopuse *lu;
d175 3
a177 3
CONST struct faceuse *fu;
CONST fastf_t u;
CONST fastf_t v;
d214 3
a216 3
CONST struct faceuse *fu;
CONST fastf_t u;
CONST fastf_t v;
d244 2
a245 2
CONST struct faceuse *fu;
CONST struct vertexuse *vu;
d274 1
a274 1
CONST struct model *m;
d323 1
a323 1
CONST struct shell *s;
d628 1
a628 1
CONST struct shell *s;
d666 1
a666 1
CONST struct nmgregion *r;
d668 1
a668 1
CONST struct bn_tol *ttol;
d879 1
a879 1
CONST struct bn_tol *tol;
d966 1
a966 1
CONST long *magic_p;
d997 1
a997 1
CONST struct face_g_plane *fg;
d1069 1
a1069 1
CONST struct bn_tol *tol;
d1178 3
a1180 3
CONST struct edgeuse *eu;
CONST struct shell *s;
CONST int wires;
d1221 3
a1223 3
CONST struct edgeuse *eu;
CONST struct shell *s;
CONST int wires;
d1256 2
a1257 2
CONST struct edgeuse *eu;
CONST struct shell *s;
d1292 2
a1293 2
CONST struct shell *s;
CONST struct bn_tol *tol;
d1407 1
a1407 1
CONST struct loopuse *lu;
d1486 1
a1486 1
CONST struct loopuse *lu;
d1869 1
a1869 1
CONST struct faceuse *fu;
d1904 1
a1904 1
CONST struct shell *s;
d1929 1
a1929 1
CONST struct nmgregion *r;
d1944 1
a1944 1
CONST struct model *m;
d1980 3
a1982 3
CONST point_t p1,p2;
CONST vect_t d1,d2;
CONST struct bn_tol *tol;
d2068 4
a2071 4
CONST point_t p;
CONST vect_t d;
CONST point_t a,b;
CONST struct bn_tol *tol;
d2145 2
a2146 2
CONST struct faceuse	*fu;
CONST struct bn_tol	*tol;
d2152 3
a2154 3
	CONST struct loop_g	*lg;
	CONST struct loopuse	*fu2lu;
	CONST struct loop_g	*fu2lg = (CONST struct loop_g *)NULL;
d2324 1
a2324 1
CONST struct bn_tol	*tol;
d2396 1
a2396 1
CONST struct model *m;
d2403 5
a2407 5
	CONST struct nmgregion *r;
	CONST struct shell *s;
	CONST struct faceuse *fu;
	CONST struct loopuse *lu;
	CONST struct edgeuse *eu;
d2529 1
a2529 1
CONST struct bn_tol *tol;
d3015 1
a3015 1
CONST struct bn_tol *tol;
d3258 1
a3258 1
CONST struct bn_tol *tol;
d3314 1
a3314 1
CONST struct bn_tol *tol;
d3377 1
a3377 1
CONST struct shell *s;
d3434 1
a3434 1
CONST struct bn_tol *tol;
d3741 1
a3741 1
CONST struct bn_tol *tol;
d3961 1
a3961 1
CONST struct bn_tol *tol;
d4152 1
a4152 1
CONST struct bn_tol *tol;
d4326 1
a4326 1
	CONST struct bn_tol	*tol;
d4339 1
a4339 1
	CONST struct bn_tol *tol;
d4529 1
a4529 1
CONST struct bn_tol	*tol;
d4576 1
a4576 1
CONST struct bn_tol *tol;
d5039 3
a5041 3
CONST char		*filename;
CONST struct model	*m;
CONST char		*title;
d5233 3
a5235 3
CONST point_t	a, p;
CONST vect_t	dir;
CONST struct bn_tol *tol;
d5340 1
a5340 1
CONST struct vertex *new_v;
d5343 1
a5343 1
CONST struct bn_tol *tol;
d5423 2
a5424 2
CONST struct bu_ptbl *faces;
CONST struct bn_tol *tol;
d5554 2
a5555 2
CONST struct vertex *v;
CONST struct bn_tol *tol;
d5620 2
a5621 2
CONST struct vertex *new_v;
CONST struct bu_ptbl *int_faces;
d5725 1
a5725 1
CONST struct bn_tol *tol;
d5974 1
a5974 1
CONST struct vertex *new_v;
d5976 2
a5977 2
CONST struct bu_ptbl *faces;
CONST struct bn_tol *tol;
d6158 1
a6158 1
CONST struct bn_tol *tol;
d6227 1
a6227 1
CONST struct vertex *new_v;
d6229 1
a6229 1
CONST struct bn_tol *tol;
d6340 1
a6340 1
CONST struct bn_tol *tol;
d6492 1
a6492 1
CONST struct vertex *new_v;
d6494 1
a6494 1
CONST struct bn_tol *tol;
d6647 1
a6647 1
CONST struct bn_tol *tol;
d6883 1
a6883 1
CONST struct vertex *vp;
d6997 2
a6998 2
CONST struct intersect_fus *i_fus;
CONST struct intersect_fus *j_fus;
d7000 1
a7000 1
CONST struct bn_tol *tol;
d7190 1
a7190 1
CONST struct bn_tol *tol;
d7370 2
a7371 2
CONST struct bu_ptbl *int_faces;
CONST struct bn_tol *tol;
d7426 1
a7426 1
		if( bn_isect_planes( new_v->vg_p->coord , (CONST plane_t *)planes , pl_count ) )
d7506 4
a7509 4
CONST struct bu_ptbl *faces;
CONST int free_edges;
CONST int approximate;
CONST struct bn_tol *tol;
d7611 1
a7611 1
		if( bn_isect_planes( new_v->vg_p->coord , (CONST plane_t *)planes , plane_count ) )
d7699 2
a7700 2
CONST struct shell *s;
CONST struct bn_tol *tol;
d7759 2
a7760 2
CONST struct faceuse *fu1;
CONST struct faceuse *fu2;
d7817 2
a7818 2
CONST point_t pt;
CONST struct bn_tol *tol;
d8176 1
a8176 1
CONST struct bu_list *vhead;
d8178 1
a8178 1
	CONST struct bn_vlist *vp;
d8236 1
a8236 1
CONST struct vertex *vpa,*vpb;
d8238 2
a8239 2
CONST struct shell *s;
CONST struct edgeuse *eu;
d8355 1
a8355 1
CONST struct vertex *vpa,*vpb;
d8357 1
a8357 1
CONST struct shell *s;
d8450 1
a8450 1
CONST struct faceuse *fu;
d8452 1
a8452 1
CONST struct bn_tol *tol;
d8508 1
a8508 1
CONST struct bn_tol *tol;
d8573 1
a8573 1
CONST struct bn_tol *tol;
d8944 2
a8945 2
CONST long **copy_tbl;
CONST struct bn_tol *tol;
d9220 2
a9221 2
CONST int approximate;
CONST struct bn_tol *tol;
d9640 1
a9640 1
CONST struct bn_tol *tol;
d9710 1
a9710 1
CONST struct bn_tol *tol;
d10016 1
a10016 1
CONST struct bn_tol *tol;
d10218 1
a10218 1
CONST struct bn_tol *tol;
d10283 1
a10283 1
CONST struct bn_tol *tol;
d11016 1
a11016 1
CONST struct bn_tol *tol;
d11074 1
a11074 1
CONST struct model *m;
d11076 1
a11076 1
CONST struct bn_tol *tol;
d11250 1
a11250 1
CONST struct bn_tol *tol;
d11439 2
a11440 2
CONST fastf_t max_dist1, max_dot1, max_dist2, max_dot2, max_dot, tol_dist;
CONST int flip1, flip2;
d11497 3
a11499 3
CONST struct bn_tol *tol;
CONST fastf_t tol_coll;
CONST fastf_t min_angle;
d12174 1
a12174 1
CONST struct bn_tol *tol;
@


11.86
log
@
ANSI function declarations
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_misc.c,v 11.85 2000/09/08 05:54:42 mike Exp $ (ARL)";
d1696 1
a1696 1
	bn_mat_zero( matrix );
@


11.85
log
@
Modified tree routines to take resource pointer.
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_misc.c,v 11.84 2000/08/25 05:18:56 mike Exp $ (ARL)";
d10507 1
a10507 3
nmg_to_arb( m, arb_int )
CONST struct model *m;
struct rt_arb_internal *arb_int;
d10758 4
a10761 4
nmg_to_tgc( m, tgc_int,  tol )
CONST struct model *m;
struct rt_tgc_internal *tgc_int;
CONST struct bn_tol *tol;
d11067 5
@


11.84
log
@
lint
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_misc.c,v 11.83 2000/08/21 02:02:32 butler Exp $ (ARL)";
d5034 2
d5043 1
a5043 2
	FILE	*fp;
	struct bu_external	ext;
a5044 1
	union record		rec;
d5051 1
a5051 1
	if( (fp = fopen(filename, "w")) == NULL )  {
a5059 1
	BU_INIT_EXTERNAL( &ext );
d5062 7
a5068 16
	if( rt_functab[ID_NMG].ft_export( &ext, &intern, 1.0, DBI_NULL ) < 0 )  {
		bu_log("nmg_stash_model_to_file: solid export failure\n");
		bu_free_external( &ext );
		bu_bomb("nmg_stash_model_to_file() ft_export() error\n");
	}
	NAMEMOVE( "error", ((union record *)ext.ext_buf)->s.s_name );

	bzero( (char *)&rec, sizeof(rec) );
	rec.u_id = ID_IDENT;
	strcpy( rec.i.i_version, ID_VERSION );
	strncpy( rec.i.i_title, title, sizeof(rec.i.i_title)-1 );
	fwrite( (char *)&rec, sizeof(rec), 1, fp );
	fwrite( ext.ext_buf, ext.ext_nbytes, 1, fp );
	fclose(fp);
	bu_free_external( &ext );
	bu_log("nmg_stash_model_to_file(): wrote '%s' in %d bytes\n", filename, ext.ext_nbytes);
@


11.83
log
@Massive compilation warnings eliminated
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_misc.c,v 11.82 2000/07/14 17:14:05 jra Exp $ (ARL)";
d813 1
a813 1
				int test_dir;
d2537 1
a2537 1
	struct edgeuse *eu,*eu1,*eu2,*eu3,*eu_new;
d2608 1
d2610 1
a2610 1
			int edges_used;			/* number of edges used in making a face */
d2976 10
a2985 6
		eu1 = (struct edgeuse *)BU_PTBL_GET( &eu_tbl , index[0] );
		eu2 = (struct edgeuse *)BU_PTBL_GET( &eu_tbl , index[1] );
		eu3 = (struct edgeuse *)BU_PTBL_GET( &eu_tbl , index[2] );
		bu_ptbl_rm( &eu_tbl , (long *)eu1 );
		bu_ptbl_rm( &eu_tbl , (long *)eu2 );
		bu_ptbl_rm( &eu_tbl , (long *)eu3 );
d4589 1
a4589 1
	struct faceuse *missed_fu;
d4716 1
a4716 1
		struct edgeuse *unassigned_eu;
d7722 1
a7722 1
		fastf_t area;
d9845 1
a9845 1
	fastf_t last_knot;
d10044 1
a10044 1
	int ncoords;
d10533 1
a10533 1
	int ret_val;
@


11.82
log
@Added nmg_bot() routine to convert NMG to BOT solids
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_misc.c,v 11.81 2000/07/10 23:01:43 mike Exp $ (ARL)";
d1195 6
a1200 2
	while( ( !wires & (nmg_find_fu_of_eu( ret_eu ) == (struct faceuse *)NULL)) ||
		( (s != (struct shell *)NULL) & nmg_find_s_of_eu( ret_eu ) != s  ) )
d5905 6
a5910 1
			if( ret_val=bn_isect_2planes( start , dir , fu1->f_p->g.plane_p->N , fu2->f_p->g.plane_p->N , new_v->vg_p->coord , &tol_tmp ) )
d8489 1
d8508 1
d8571 1
@


11.81
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_misc.c,v 11.80 2000/06/29 18:20:56 mike Exp $ (ARL)";
d12154 158
@


11.80
log
@
Changed from db_free_external() to bu_free_external()
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_misc.c,v 11.79 2000/05/02 01:56:00 mike Exp $ (ARL)";
@


11.79
log
@
Someone wrote & instead of &&
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_misc.c,v 11.78 2000/05/02 01:46:04 mike Exp $ (ARL)";
d5056 2
a5057 2
		db_free_external( &ext );
		rt_bomb("nmg_stash_model_to_file() ft_export() error\n");
d5068 1
a5068 1
	db_free_external( &ext );
@


11.79.2.1
log
@Added nmg_bot() routine to convert NMG solids to BOTs
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_misc.c,v 11.79 2000/05/02 01:56:00 mike Exp $ (ARL)";
a12153 158
}

/*			N M G _ B O T
 *
 *	Convert an NMG to a BOT solid
 */

struct rt_bot_internal *
nmg_bot( s, tol )
struct shell *s;
CONST struct bn_tol *tol;
{
	struct rt_bot_internal	*bot;
	struct bu_ptbl		nmg_vertices;
	struct bu_ptbl		nmg_faces;
	int			i, face_no;
	struct vertex		*v;

	NMG_CK_SHELL( s );
	BN_CK_TOL(tol);

	/* first convert the NMG to triangles */
	(void)nmg_triangulate_shell(s, tol);

	/* make a list of all the vertices */
	nmg_vertex_tabulate( &nmg_vertices, &s->l.magic );

	/* and a list of all the faces */
	nmg_face_tabulate( &nmg_faces, &s->l.magic );

	/* now build the BOT */
	bot = (struct rt_bot_internal *)bu_malloc( sizeof( struct rt_bot_internal ), "BOT from NMG" );

	bot->magic = RT_BOT_INTERNAL_MAGIC;
	bot->mode = RT_BOT_SOLID;
	bot->orientation = RT_BOT_CCW;
	bot->error_mode = 0;

	bot->num_vertices = BU_PTBL_LEN( &nmg_vertices );
	bot->num_faces = 0;

	/* count the number of triangles */
	for( i=0 ; i<BU_PTBL_LEN( &nmg_faces ); i++ )
	{
		struct face *f;
		struct faceuse *fu;
		struct loopuse *lu;

		f = (struct face *)BU_PTBL_GET( &nmg_faces, i );
		NMG_CK_FACE( f );

		fu = f->fu_p;

		if( fu->orientation != OT_SAME )
		{
			fu = fu->fumate_p;
			if( fu->orientation != OT_SAME )
			{
				bu_log( "nmg_bot(): Face has no OT_SAME use!!!!\n" );
				bu_free( (char *)bot->vertices, "BOT vertices" );
				bu_free( (char *)bot->faces, "BOT faces" );
				bu_free( (char *)bot, "BOT" );
				return( (struct rt_bot_internal *)NULL );
			}
		}

		for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
		{
			if( BU_LIST_FIRST_MAGIC(&lu->down_hd) != NMG_EDGEUSE_MAGIC )
				continue;
			bot->num_faces++;
		}
	}

	bot->faces = (int *)bu_calloc( bot->num_faces * 3, sizeof( int ), "BOT faces" );
	bot->vertices = (fastf_t *)bu_calloc( bot->num_vertices * 3, sizeof( fastf_t ), "BOT vertices" );

	bot->thickness = (fastf_t *)NULL;
	bot->face_mode = (struct bu_bitv *)NULL;

	/* fill in the vertices */
	for( i=0 ; i<BU_PTBL_LEN( &nmg_vertices ) ; i++ )
	{
		struct vertex_g *vg;

		v = (struct vertex *)BU_PTBL_GET( &nmg_vertices, i );
		NMG_CK_VERTEX( v );

		vg = v->vg_p;
		NMG_CK_VERTEX_G( vg );

		VMOVE( &bot->vertices[i*3], vg->coord );
	}

	/* fill in the faces */
	face_no = 0;
	for( i=0 ; i<BU_PTBL_LEN( &nmg_faces ); i++ )
	{
		struct face *f;
		struct faceuse *fu;
		struct loopuse *lu;

		f = (struct face *)BU_PTBL_GET( &nmg_faces, i );
		NMG_CK_FACE( f );

		fu = f->fu_p;

		if( fu->orientation != OT_SAME )
		{
			fu = fu->fumate_p;
			if( fu->orientation != OT_SAME )
			{
				bu_log( "nmg_bot(): Face has no OT_SAME use!!!!\n" );
				bu_free( (char *)bot->vertices, "BOT vertices" );
				bu_free( (char *)bot->faces, "BOT faces" );
				bu_free( (char *)bot, "BOT" );
				return( (struct rt_bot_internal *)NULL );
			}
		}

		for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
		{
			struct edgeuse *eu;
			int vertex_no=0;

			if( BU_LIST_FIRST_MAGIC(&lu->down_hd) != NMG_EDGEUSE_MAGIC )
				continue;

			for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
			{
				struct vertex *v;

				if( vertex_no > 2 )
				{
					bu_log( "nmg_bot(): Face has not been triangulated!!!\n" );
					bu_free( (char *)bot->vertices, "BOT vertices" );
					bu_free( (char *)bot->faces, "BOT faces" );
					bu_free( (char *)bot, "BOT" );
					return( (struct rt_bot_internal *)NULL );
				}

				v = eu->vu_p->v_p;
				NMG_CK_VERTEX( v );


				bot->faces[ face_no*3 + vertex_no ] = bu_ptbl_locate( &nmg_vertices, (long *)v );

				vertex_no++;
			}

			face_no++;
		}
	}

	bu_ptbl_free( &nmg_vertices );
	bu_ptbl_free( &nmg_faces );

	return( bot );
@


11.78
log
@
Changed from rt_list to bu_list
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_misc.c,v 11.77 2000/03/29 02:36:04 mike Exp $ (ARL)";
d1235 1
a1235 1
		( (s != (struct shell *)NULL) & nmg_find_s_of_eu( ret_eu ) != s  ) )
@


11.77
log
@
externs and consts for nmg_misc.c
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_misc.c,v 11.76 2000/03/29 01:17:23 mike Exp $ (ARL)";
d10184 1
a10184 1
	/* initialize rt_list structure to hold list of curves */
@


11.76
log
@
Added externs, fixed messages.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_misc.c,v 11.75 2000/03/28 22:00:10 mike Exp $ (ARL)";
d53 1
a53 1
struct loopuse *lu;
d274 1
a274 1
struct model *m;
a1059 79
/*	R T _ I S E C T _ P L A N E S
 *
 * Calculates the point that is the minimum distance from all the
 * planes in the "planes" array.  If the planes intersect at a single point,
 * that point is the solution.
 *
 * The method used here is based on:
 *	An expression for the distance from a point to a plane is VDOT(pt,plane)-plane[H].
 *	Square that distance and sum for all planes to get the "total" distance.
 *	For minimum total distance, the partial derivatives of this expression (with
 *	respect to x, y, and z) must all be zero. 
 *	This produces a set of three equations in three unknowns (x, y, and z).
 *	This routine sets up the three equations as [matrix][pt] = [hpq]
 *	and solves by inverting "matrix" into "inverse" and
 *	[pt] = [inverse][hpq].
 *
 * There is likely a more economical solution rather than matrix inversion, but
 * bn_mat_inv was handy at the time.
 *
 * Checks if these planes form a singular matrix and returns:
 *	0 - all is well
 *	1 - planes form a singular matrix (no solution)
XXX Should be renamed bn_isect_nplanes() and moved to libbn/plane.c
 */
int
rt_isect_planes( pt , planes , pl_count )
point_t pt;
CONST plane_t planes[];
CONST int pl_count;
{
	mat_t matrix;
	mat_t inverse;
	vect_t hpq;
	fastf_t det;
	int i;

	if( rt_g.NMG_debug & DEBUG_BASIC )
	{
		bu_log( "rt_isect_planes:\n" );
		for( i=0 ; i<pl_count ; i++ )
		{
			bu_log( "Plane #%d (%f %f %f %f)\n" , i , V4ARGS( planes[i] ) );
		}
	}

	bn_mat_zero( matrix );
	VSET( hpq , 0.0 , 0.0 , 0.0 );

	for( i=0 ; i<pl_count ; i++ )
	{
		matrix[0] += planes[i][X] * planes[i][X];
		matrix[5] += planes[i][Y] * planes[i][Y];
		matrix[10] += planes[i][Z] * planes[i][Z];
		matrix[1] += planes[i][X] * planes[i][Y];
		matrix[2] += planes[i][X] * planes[i][Z];
		matrix[6] += planes[i][Y] * planes[i][Z];
		hpq[X] += planes[i][X] * planes[i][H];
		hpq[Y] += planes[i][Y] * planes[i][H];
		hpq[Z] += planes[i][Z] * planes[i][H];
	}

	matrix[4] = matrix[1];
	matrix[8] = matrix[2];
	matrix[9] = matrix[6];
	matrix[15] = 1.0;

	/* Check that we don't have a singular matrix */
	det = bn_mat_determinant( matrix );
	if( NEAR_ZERO( det , SMALL_FASTF ) )
		return( 1 );

	bn_mat_inv( inverse , matrix );

	MAT4X3PNT( pt , inverse , hpq );

	return( 0 );

}

d1288 2
a1289 2
struct shell *s;
struct bn_tol *tol;
d2525 1
a2525 1
struct bn_tol *tol;
d3006 1
a3006 1
struct bn_tol *tol;
d4143 1
a4143 1
struct bn_tol *tol;
d4317 1
a4317 1
	struct bn_tol	*tol;
d4330 1
a4330 1
	struct bn_tol *tol;
d4520 1
a4520 1
struct bn_tol	*tol;
d4567 1
a4567 1
struct bn_tol *tol;
d5425 1
a5425 1
struct bn_tol *tol;
d7422 1
a7422 1
		if( rt_isect_planes( new_v->vg_p->coord , (CONST plane_t *)planes , pl_count ) )
d7607 1
a7607 1
		if( rt_isect_planes( new_v->vg_p->coord , (CONST plane_t *)planes , plane_count ) )
d8172 1
a8172 1
struct bu_list *vhead;
d8174 1
a8174 1
	struct bn_vlist *vp;
d9703 1
a9703 1
struct bn_tol *tol;
d9810 1
d10009 1
a10009 1
struct bn_tol *tol;
d10276 1
a10276 1
struct bn_tol *tol;
d11428 1
a11428 1
select_collapse( max_dist1, max_dot1, flip1, max_dist2, max_dot2, flip2, max_dot, tol_dist )
d11921 1
a11921 1
			choice = select_collapse( max_dist1, max_dot1, flip1,
@


11.75
log
@
moved mat_determinant to libbn
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_misc.c,v 11.74 1999/12/30 15:17:00 jra Exp $ (ARL)";
d3825 1
a3825 1
	flags = (long *)bu_calloc( m->maxindex , sizeof( long ) , "nmg_fix_normals: flags" );
d3832 1
a3832 1
		bu_log( "nmg_fix_normals: Could not get a top face from nmg_find_top_face()\n" );
d3834 1
a3834 1
		bu_free( (char *)flags, "nmg_fix_normals: flags" );
d3853 2
a3854 2
		bu_log( "nmg_fix_normals: no OT_SAME use of top face\n" );
		bu_free( (char *)flags , "nmg_fix_normals: flags" );
d3861 1
a3861 1
		bu_log( "\tnmg_fix_normals: top face is x%x in %d direction, OT_SAME use is x%x\n", f_top, dir, fu );
d3870 1
a3870 1
			bu_log( "nmg_fix_normals: reversing fu x%x\n" , fu );
d3893 1
a3893 1
		bu_log( "nmg_fix_normals: After propagation top faceuse normal is ( %g %g %g )\n",
d7834 2
a7835 1
CONST struct faceuse *fu1,*fu2;
d11318 1
a11318 1
struct bn_tol *tol;
@


11.74
log
@Eliminated some unused variables
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_misc.c,v 11.73 1999/11/24 14:39:52 jra Exp $ (ARL)";
a958 54
/*		M A T _ D E T 3
 *
 *	Calculates the determinant of the 3X3 "rotation"
 *	part of the passed amtrix
XXX should be re-named bn_mat_det3(), and moved to libbn/mat.c
 */
fastf_t
mat_det3( m )
CONST mat_t m;
{
	fastf_t sum;

	sum = m[0] * ( m[5]*m[10] - m[6]*m[9] )
	     -m[1] * ( m[4]*m[10] - m[6]*m[8] )
	     +m[2] * ( m[4]*m[9] - m[5]*m[8] );

	return( sum );
}


/*		M A T _ D E T E R M I N A N T
 *
 *	Calculates the determinant of the 4X4 matrix
XXX should be re-named bn_mat_determinant(), and moved to libbn/mat.c
 */
fastf_t
mat_determinant( m )
CONST mat_t m;
{
	fastf_t det[4];
	fastf_t sum;

	det[0] = m[5] * (m[10]*m[15] - m[11]*m[14])
		-m[6] * (m[ 9]*m[15] - m[11]*m[13])
		+m[7] * (m[ 9]*m[14] - m[10]*m[13]);

	det[1] = m[4] * (m[10]*m[15] - m[11]*m[14])
		-m[6] * (m[ 8]*m[15] - m[11]*m[12])
		+m[7] * (m[ 8]*m[14] - m[10]*m[12]);

	det[2] = m[4] * (m[ 9]*m[15] - m[11]*m[13])
		-m[5] * (m[ 8]*m[15] - m[11]*m[12])
		+m[7] * (m[ 8]*m[13] - m[ 9]*m[12]);

	det[3] = m[4] * (m[ 9]*m[14] - m[10]*m[13])
		-m[5] * (m[ 8]*m[14] - m[10]*m[12])
		+m[6] * (m[ 8]*m[13] - m[ 9]*m[12]);

	sum = m[0]*det[0] - m[1]*det[1] + m[2]*det[2] - m[3]*det[3];

	return( sum );

}

d1127 1
a1127 1
	det = mat_determinant( matrix );
d1802 1
a1802 1
	det = mat_determinant( matrix );
@


11.73
log
@Was missing some idb_meth settings for the rt_db_internal structs
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_misc.c,v 11.72 1999/08/23 12:54:26 jra Exp $ (ARL)";
d103 1
a103 1
		struct vertexuse_a_cnurb *vg1,*vg2;
a247 1
	struct face *f;
a248 1
	point_t uvw;
a338 1
	int done;
a2721 1
		vect_t	normal;
a2736 1
			vect_t inside;			/* vector pointing to left of edge (inside face) */
a2737 1
			vect_t v1,v2;			/* edge vectors */
a2899 3
				struct vertex *vfirst, *vlast;
				struct edgeuse *eu_tmp;

a3604 3
		struct edgeuse *eu2;
		int radial_count=0;

a3990 1
	struct model *old_m;
d4091 1
a4091 1
	struct nmgregion *tmp_r, *tmp_r2;
a7697 1
			struct loopuse *lu;
a7715 1
					vect_t eu_dir;
d8701 1
a8701 1
	int i,j,k;
a8880 3
		fastf_t dist;
		point_t pca;
		struct edgeuse *new_eu;
a9479 1
		int empty_face=0;
a9787 7
		plane_t pl;
		struct loopuse *lu;
		struct edgeuse *eu;
		struct vertexuse *vu;
		fastf_t dist_to_plane;
		int triangulate=0;

a9789 2
		NMG_GET_FU_PLANE( pl, fu );

a9957 1
	struct edge_g_cnurb *linear_crv;
d10248 1
a10248 1
		vect_t t1, t2, t3;
a10442 1
	int arb;
a10900 1
	int ret=0;
a11209 1
	int i;
a11651 1
			plane_t perp_pl, pl, pl2;
a11652 1
			fastf_t min_dist1, min_dist2;
a11654 1
			fastf_t dot;
a11658 2
			min_dist1 = MAX_FASTF;
			min_dist2 = MAX_FASTF;
a11792 1
			NMG_GET_FU_PLANE( pl, fu )
a12110 1
					vect_t edge_dir;
a12189 1
					vect_t edge_dir;
@


11.72
log
@Slight improvment to Shell_is_arb()
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_misc.c,v 11.71 1999/06/03 01:01:26 mike Exp $ (ARL)";
d5195 1
@


11.71
log
@
sed4
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_misc.c,v 11.70 1999/05/19 16:48:31 jra Exp $ (ARL)";
d10526 1
d10555 1
a10555 1
				VCROSS( cross, fu_norm, norm_radial );
d10557 1
a10557 1
				if( eu->orientation == OT_NONE )
a10558 6
					VSUB2( eu_dir, eu->vu_p->v_p->vg_p->coord, eu->eumate_p->vu_p->v_p->vg_p->coord )
					if( eu->orientation != OT_SAME )
						VREVERSE( eu_dir, eu_dir )
				}
				else
					VMOVE( eu_dir, eu->g.lseg_p->e_dir )
d10560 21
a10580 9
				if( eu->orientation == OT_SAME || eu->orientation == OT_NONE )
				{
					if( VDOT( cross, eu_dir ) < 0.0 )
						goto not_arb;
				}
				else
				{
					if( VDOT( cross, eu_dir ) > 0.0 )
						goto not_arb;
@


11.70
log
@Added a check in nmg_simple_vertex_solve() for antiparallel planes
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_misc.c,v 11.69 1999/05/10 03:01:55 jra Exp $ (ARL)";
d95 1
a95 1
	pts = (point_t *)rt_calloc( edge_count, sizeof( point_t ), "Orient_nurb_face_loops: pts" );
d163 1
a163 1
	rt_free( (char *)pts, "nmg_snurb_calc_lu_uv_orient: pts" );
d426 1
a426 1
			rt_log( "Checking edge (%g %g %g)<->(%g %g %g)\n",
d461 1
a461 1
			rt_log( "Checking edge (%g %g %g)<->(%g %g %g)\n",
d464 2
a465 2
			rt_log( "\tedge direction = (%g %g %g)\n", V3ARGS( edge ) );
			rt_log( "\t\textreme slope = %g\n", extreme_slope );
d482 1
a482 1
					rt_log( "New top edge!\n" );
d695 1
a695 1
	top_faces = (struct top_face *)rt_calloc( total_shells , sizeof( struct top_face ) , "nmg_assoc_void_shells: top_faces" );
d698 1
a698 1
	flags = (long *)rt_calloc( r->m_p->maxindex , sizeof( long ) , "nmg_find_outer_and_void_shells: flags" );
d866 1
a866 1
	rt_free( (char *)flags , "nmg_assoc_void_shells: flags" );
d897 1
a897 1
	outer_shells = (struct bu_ptbl *)rt_malloc( sizeof( struct bu_ptbl ) , "nmg_find_outer_and_void_shells: outer_shells" );
d918 1
a918 1
	flags = (long *)rt_calloc( r->m_p->maxindex , sizeof( long ) , "nmg_find_outer_and_void_shells: flags" );
d943 1
a943 1
	*shells = (struct bu_ptbl **)rt_calloc( BU_PTBL_END( outer_shells ) , sizeof( struct bu_ptbl *) ,
d947 1
a947 1
		(*shells)[i] = (struct bu_ptbl *)rt_malloc( sizeof( struct bu_ptbl ) , 
d957 1
a957 1
	rt_free( (char *)flags , "nmg_find_outer_and_void_shells: flags" );
d1134 1
a1134 1
 * mat_inv was handy at the time.
d1162 1
a1162 1
	mat_zero( matrix );
d1188 1
a1188 1
	mat_inv( inverse , matrix );
d1828 1
a1828 1
	mat_zero( matrix );
d1866 1
a1866 1
		mat_inv( inverse , matrix );
d2469 1
a2469 1
	flags = (int *)rt_calloc( m->maxindex*2, sizeof(int), "rebound flags[]" );
d2520 1
a2520 1
	rt_free( (char *)flags, "rebound flags[]" );
d2543 1
a2543 1
	tbl = (short *)rt_calloc(m->maxindex+1, sizeof(char),
d2568 1
a2568 1
	rt_free((char *)tbl, "face/wire/point counted table");
d2599 1
a2599 1
		(*index) = (int *)rt_calloc( tbl_size , sizeof( int ) , "Table index" );
d2867 1
a2867 1
				eu_used = (struct edgeuse **)rt_calloc( loop_size , sizeof( struct edguse *) , "edges used list" );
d2874 1
a2874 1
				rt_free( (char *)eu_used , "edge used list" );
d2973 1
a2973 1
			eu_used = (struct edgeuse **)rt_calloc( edges_used , sizeof( struct edguse *) , "edges used list" );
d3043 1
a3043 1
			rt_free( (char *)eu_used , "edge used list" );
d3122 1
a3122 1
	rt_free( (char *)index , "index" );
d3170 1
a3170 1
	(*trans_tbl) = (long **)rt_calloc(tbl_size, sizeof(long *),
d3524 1
a3524 1
	flags = (long *)rt_calloc( m->maxindex , sizeof( long ) , "nmg_shell_is_void: flags " );
d3528 1
a3528 1
	rt_free( (char *)flags , "nmg_shell_is_void: flags" );
d3666 1
a3666 1
				rt_log( "nmg_propagate_normals: found an unoriented face!!!!\n" );
d3891 1
a3891 1
	flags = (long *)rt_calloc( m->maxindex , sizeof( long ) , "nmg_fix_normals: flags" );
d3900 1
a3900 1
		rt_free( (char *)flags, "nmg_fix_normals: flags" );
d3920 1
a3920 1
		rt_free( (char *)flags , "nmg_fix_normals: flags" );
d3977 1
a3977 1
		rt_log( "nmg_fix_decomposed_shell_normals: missed %d faces in shell x%x (was it decomposed????)\n", 
d4022 1
a4022 1
		for( RT_LIST_FOR( vu, vertexuse, &v->vu_hd ) )
d4026 1
a4026 1
				rt_log( "vertexuse x%x (v=x%x) at (%g %g %g) has use in another region\n",
d4052 1
a4052 1
				rt_log( "edgeuse x%x (e=x%x) at (%g %g %g)<->(%g %g %g0 has use in another region\n",
d4068 1
a4068 1
	RT_LIST_DEQUEUE( &r->l );
d4070 1
a4070 1
	RT_LIST_INSERT( &m->r_hd, &r->l );
d4132 1
a4132 1
			rt_log( "nmg_fix_normals failed, found a face with no geometry (x%x)\n", f );
d4138 2
a4139 2
			rt_log( "nmg_fix_normals: non-planar face found (x%x)\n", f );
			rt_log( "	cannot fix normals\n" );
d4210 2
a4211 2
				rt_log( "nmg_fix_normals: nmg_classify_s_vs_s() failed for shells x%x and x%x\n", s1, s2 );
				rt_log( "   Continueing anyway (shell is likely to have incorrectly oriented normals)\n" );
d4246 1
a4246 1
				rt_log( "fu x%x does not have corrrespondence in original shell\n", fu );
d4687 1
a4687 1
	sl_state.flags = (long *)rt_calloc( m->maxindex*2 , sizeof( long ) , "nmg_split_loops_into_faces: flags" );
d4694 1
a4694 1
	rt_free( (char *)sl_state.flags , "nmg_split_loops_into_faces: flags" );
d4743 1
a4743 1
	flags = (long *)rt_calloc( m->maxindex*2 , sizeof( long ) , "nmg_decompose_shell: flags" );
d4845 1
a4845 1
		rt_free( (char *)flags , "nmg_decompose_shell: flags " );
d4860 1
a4860 1
		shells_at_edge = (int *)rt_calloc( no_of_shells+1 , sizeof( int ) , "nmg_decompose_shell: shells_at_edge" );
d5005 1
a5005 1
		rt_free( (char *)shells_at_edge , "nmg_decompose_shell: shells_at_edge" );
d5154 1
a5154 1
	rt_free( (char *)flags , "nmg_decompose_shell: flags " );
d5336 1
a5336 1
	ub_state.flags = (long *)rt_calloc( m->maxindex*2 , sizeof( long ) , "nmg_unbreak_region_edges: flags" );
d5342 1
a5342 1
	rt_free( (char *)ub_state.flags , "nmg_unbreak_region_edges: flags" );
d5927 1
a5927 1
			i_fus = (struct intersect_fus *)rt_malloc( sizeof( struct intersect_fus ) , "nmg_get_edge_lines: i_fus" );
d6007 1
a6007 1
				rt_free( (char *)i_fus , "nmg_get_edge_lines: i_fus" );
d6020 1
a6020 1
		i_fus = (struct intersect_fus *)rt_malloc( sizeof( struct intersect_fus ) , "nmg_inside_vert: intersection list" );
d6354 1
a6354 1
	rt_free( (char *)j_fus , "nmg_split_edges_at_pts: j_fus " );
d7529 1
a7529 1
	planes = (plane_t *)rt_calloc( i , sizeof( plane_t ) , "nmg_calc_new_v: planes" );
d7571 1
a7571 1
			rt_free( (char *)planes , "nmg_calc_new_v: planes" );
d7591 1
a7591 1
			rt_free( (char *)planes , "nmg_calc_new_v: planes" );
d7599 1
a7599 1
		rt_free( (char *)planes , "nmg_calc_new_v: planes" );
d7606 1
a7606 1
	rt_free( (char *)planes , "nmg_calc_new_v: planes" );
d7675 1
a7675 1
		planes = (plane_t *)rt_calloc( plane_count+free_edges , sizeof( plane_t ) , "nmg_complex_vertex_solve: planes" );
d7758 1
a7758 1
			rt_free( (char *) planes , "nmg_complex_vertex_solve: planes" );
d7761 1
a7761 1
		rt_free( (char *) planes , "nmg_complex_vertex_solve: planes" );
d7820 1
a7820 1
		rt_free( (char *)i_fus , "nmg_complex_vertex_solve: intersect_fus struct\n" );
d8188 1
a8188 1
	flags = (long *)rt_calloc( m->maxindex , sizeof( long ) , "nmg_move_edge_thru_pt: flags" );
d8217 1
a8217 1
						rt_free( (char *)flags , "mg_move_edge_thru_pt: flags" );
d8226 1
a8226 1
						rt_free( (char *)flags , "mg_move_edge_thru_pt: flags" );
d8248 1
a8248 1
						rt_free( (char *)flags , "mg_move_edge_thru_pt: flags" );
d8276 1
a8276 1
							rt_free( (char *)flags , "mg_move_edge_thru_pt: flags" );
d8304 1
a8304 1
	rt_free( (char *)flags , "mg_move_edge_thru_pt: flags" );
d8320 1
a8320 1
	struct rt_vlist *vp;
d8331 1
a8331 1
	vp = BU_LIST_FIRST( rt_vlist , vhead );
d8335 1
a8335 1
	for( BU_LIST_FOR( vp , rt_vlist , vhead ) )
d8345 2
a8346 2
				case RT_VLIST_LINE_MOVE:
				case RT_VLIST_POLY_MOVE:
d8351 2
a8352 2
				case RT_VLIST_LINE_DRAW:
				case RT_VLIST_POLY_DRAW:
d8368 2
a8369 2
				case RT_VLIST_POLY_START:
				case RT_VLIST_POLY_END:
d9150 1
a9150 1
					dang = (struct dangle *)rt_malloc( sizeof( struct dangle ) ,
d9325 1
a9325 1
		rt_free( (char *)dang , "nmg_open_shells_connect: dang" );
d9441 1
a9441 1
	flags = (long *)rt_calloc( m->maxindex , sizeof( long ) , "nmg_mirror_model: flags" );
d9472 1
a9472 1
	rt_free( (char *)flags , "nmg_mirror_model: flags " );
d11139 1
a11139 1
	mat_vec_perp( plv_1, top_pl );
d11332 1
a11332 1
	poly_int->poly = (struct rt_pg_face_internal *)rt_calloc( face_count,
d11365 2
a11366 2
					poly_int->poly[face_count].verts = (fastf_t *) rt_calloc( 3*count_npts, sizeof( fastf_t ), "nmg_to_poly: verts" );
					poly_int->poly[face_count].norms = (fastf_t *) rt_calloc( 3*count_npts, sizeof( fastf_t ), "nmg_to_poly: norms" );
@


11.69
log
@Mods to nmg_edge_collapse() to avoid collapsing free edges
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_misc.c,v 11.68 1998/07/30 19:51:15 jra Exp $ (ARL)";
d5627 1
a5627 1
			if( NEAR_ZERO( pl_dot - 1.0 , tol->perp ) )
@


11.68
log
@Added some checks to nmg_to_poly().
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_misc.c,v 11.67 1998/03/19 15:57:01 jra Exp $ (ARL)";
d11671 1
a11671 1
			struct edgeuse *eu, *eu2;
d11684 1
d11707 30
@


11.67
log
@Cahnged to new calling sequence for ft_import and ft_export.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 11.66 1998/02/22 23:32:58 jra Exp jra $ (ARL)";
d11288 7
d11306 1
@


11.66
log
@Added minimum resultant angel parameter to nmg_edge_collapse().
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 11.65 1997/12/03 06:56:00 mike Exp jra $ (ARL)";
d5199 1
a5199 1
	if( rt_functab[ID_NMG].ft_export( &ext, &intern, 1.0 ) < 0 )  {
@


11.65
log
@Noted some routines which should be moved to LIBBN.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 11.64 1997/11/21 21:05:09 jra Exp mike $ (ARL)";
d11574 45
d11632 1
a11632 1
nmg_edge_collapse( m, tol, tol_coll )
d11636 1
d11638 1
d11643 1
d11649 2
d11672 1
d11681 2
d11804 1
a11804 1
				vect_t vec1, vec2;
d11809 1
d11837 14
d11895 1
a11895 1
				vect_t vec1, vec2;
d11899 1
a11899 1
				fastf_t dist;
d11928 15
d12042 7
d12087 1
a12087 1
			if( ((max_dist1 <= max_dist2) && !flip1) || flip2 )
d12168 1
a12168 1
			else
d12247 2
@


11.64
log
@Trying to improve nmg_close_shell().
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 11.63 1997/08/29 17:03:43 jra Exp jra $ (ARL)";
d966 1
d985 1
d1139 1
d1989 4
a1992 1
/*	The following routines calculate surface area of
d2103 4
d2193 2
d5372 2
@


11.63
log
@Added code to recalculate edge geometry in nmg_edge_collapse().
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 11.62 1997/08/26 14:19:41 jra Exp jra $ (ARL)";
d2564 1
a2564 1
 *	to create a loop.
d2573 1
a2573 1
order_tbl( tbl , index , tbl_size , loop_size )
d2575 1
d2580 1
a2580 1
	int i,j;
d2583 1
d2592 2
a2593 2
	/* start the loop at index = 0 */
	(*index)[0] = 0;
d2595 3
a2597 1
	eu = (struct edgeuse *)BU_PTBL_GET( tbl , 0 );
d2599 1
a2599 2
	i = 0;
	while( found )
d2604 1
a2604 1
		for( j=1 ; j<tbl_size ; j++ )
d2606 2
d2609 12
a2654 2
	struct faceuse **fu_list;	/* array of pointers to faceuses, for use in nmg_gluefaces */
	int fu_counter=0;		/* number of faceuses in above array */
d2658 1
a2679 2
			/* count 'em */
			fu_counter++;
a2707 10
	/* put all the existing faces in a list (needed later for "nmg_gluefaces") */
	fu_list = (struct faceuse **)rt_calloc( fu_counter + BU_PTBL_END( &eu_tbl ) - 2 , sizeof( struct faceuse *) , "face use list " );
	fu_counter = 0;
	for( BU_LIST_FOR( fu , faceuse , &s->fu_hd ) )
	{
		NMG_CK_FACEUSE( fu );
		if( fu->orientation == OT_SAME )
			fu_list[fu_counter++] = fu;
	}

d2717 8
a2724 1
		order_tbl( &eu_tbl , &index , BU_PTBL_END( &eu_tbl ) , &loop_size );
d2761 38
a2798 2
				/* Could not even make a plane, this is some serious screw-up */
				rt_bomb( "nmg_close_shell: cannot make any planes from loop\n" );
d2820 1
a2820 1
					if( bn_coplanar( pl1 , pl2 , tol ) < 1 )
d2827 2
d2834 1
a2834 1
					bu_ptbl_ins( &vert_tbl , (long *)eu->vu_p->v_p );
d2838 1
a2838 1
				fu = nmg_cface( s , (struct vertex **)BU_PTBL_BASEADDR(&vert_tbl) , loop_size );
d2842 1
d2844 2
d2847 1
d2850 3
a2852 5
				/* Calculate face bounding box */
				nmg_face_bb( fu->f_p , tol );

				/* add this face to list for glueing */
				fu_list[fu_counter++] = fu;
d2864 20
d2890 2
a2891 1
			start_index = 0;
d2894 2
a2895 1
				vect_t	norm;
d2900 6
d2912 1
a2912 1
				bu_ptbl_ins( &vert_tbl , (long *)eu1->vu_p->v_p );
a2913 3
				VSUB2( v1 , eu1->eumate_p->vu_p->v_p->vg_p->coord , eu1->vu_p->v_p->vg_p->coord );
				VCROSS( inside , normal , v1 );

d2915 1
a2915 1
				bu_ptbl_ins( &vert_tbl , (long *)eu2->vu_p->v_p );
d2931 1
a2931 1
					bu_ptbl_ins( &vert_tbl , (long *)eu2->vu_p->v_p );
d2936 9
a2944 25
				VSUB2( v2 , eu2->eumate_p->vu_p->v_p->vg_p->coord , eu2->vu_p->v_p->vg_p->coord );
				fu = nmg_find_fu_of_eu( eu1 );
				NMG_GET_FU_NORMAL( norm, fu );
				VCROSS( inside , norm , v1 );
				if( VDOT( inside , v2 ) > 0.0 )
				{
					/* this face normal would be in the wrong direction */
					found_face = 0;

					/* move along the loop by one edge and try again */
					start_index++;
					if( start_index > loop_size-2 )
					{
						/* can't make a face from this loop, so delete it */
						eu_used = (struct edgeuse **)rt_calloc( loop_size , sizeof( struct edguse *) , "edges used list" );
						for( i=0 ; i<loop_size ; i++ )
							eu_used[i] = (struct edgeuse *)BU_PTBL_GET( &eu_tbl , index[i] );
						for( i=0 ; i<loop_size ; i++ )
							bu_ptbl_rm( &eu_tbl , (long *)eu_used[i] );

						rt_free( (char *)eu_used , "edge used list" );

						give_up_on_face = 1;
						break;
					}
d2946 2
d2951 5
a2955 1
				break;			
d2958 1
a2958 1
			bu_ptbl_ins( &vert_tbl , (long *)eu2->eumate_p->vu_p->v_p );
d2966 5
a2970 1
			fu = nmg_cface( s , (struct vertex **)BU_PTBL_BASEADDR(&vert_tbl) , edges_used+1 );
d2972 1
d2974 2
d2977 1
d2980 3
a2982 12
			/* add new face to the list of faces */
			fu_list[fu_counter++] = fu;

			/* find the newly created edgeuse */
			found = 0;
			for( BU_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
			{
				NMG_CK_LOOPUSE( lu );
				if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) ==
					NMG_VERTEXUSE_MAGIC )
						continue;
				for( BU_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
d2984 5
a2988 3
					NMG_CK_EDGEUSE( eu );
					if( eu->vu_p->v_p == (struct vertex *)BU_PTBL_GET( &vert_tbl , 0 )
					&& eu->eumate_p->vu_p->v_p == (struct vertex *)BU_PTBL_GET( &vert_tbl , edges_used) )
d2990 18
a3007 2
						eu_new = eu;
						found = 1;
d3009 10
a3018 3
					}
					else if( eu->vu_p->v_p == (struct vertex *)BU_PTBL_GET( &vert_tbl , edges_used)
					&& eu->eumate_p->vu_p->v_p == (struct vertex *)BU_PTBL_GET( &vert_tbl , 0 ) )
d3020 7
a3026 3
						eu_new = eu->eumate_p;
						found = 1;
						break;
a3027 1

a3028 2
				if( found )
					break;
a3030 5
			/* out with the old, in with the new */
			for( i=0 ; i<edges_used ; i++ )
				bu_ptbl_rm( &eu_tbl , (long *)eu_used[i] );
			bu_ptbl_ins( &eu_tbl , (long *)eu_new );

d3034 4
a3037 1
			order_tbl( &eu_tbl , &index , BU_PTBL_END( &eu_tbl ) , &loop_size );
d3043 28
a3070 1
		if( loop_size != 3 )
d3072 2
a3073 6
			bu_log( "Error, loop size should be 3\n" );
			bu_ptbl_free( &eu_tbl );
			bu_ptbl_free( &vert_tbl );
			rt_free( (char *)index , "index" );
			rt_free( (char *)fu_list , "faceuse list " );
			return;
d3081 1
a3081 1
			(void)bu_ptbl_ins( &vert_tbl , (long *)eu->vu_p->v_p);
d3085 3
a3087 3
			((struct vertex *)BU_PTBL_GET( &vert_tbl , 0 ))->vg_p->coord,
			((struct vertex *)BU_PTBL_GET( &vert_tbl , 1 ))->vg_p->coord,
			((struct vertex *)BU_PTBL_GET( &vert_tbl , 2 ))->vg_p->coord,
d3092 1
a3092 1
			fu = nmg_cface( s , (struct vertex **)BU_PTBL_BASEADDR(&vert_tbl) , 3 );
a3095 3
			/* and add it to the list */
			fu_list[fu_counter++] = fu;

d3097 2
a3108 3
	/* finally, glue it all together */
	nmg_gluefaces( fu_list , fu_counter, tol );

a3110 1
	rt_free( (char *)fu_list , "faceuse list " );
a3113 7
	/* we may have constructed some coplanar faces */
	nmg_shell_coplanar_face_merge( s , tol , 1 );
	if( nmg_simplify_shell( s ) )
	{
		bu_log( "nmg_close_shell(): Simplified shell is empty" );
		return;
	}
@


11.62
log
@Improvements tp nmg_edge_collapse().
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 11.61 1997/08/20 19:22:56 jra Exp jra $ (ARL)";
d11891 31
d11972 30
@


11.61
log
@Minor mods for IRIX 6.4.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 11.60 1997/08/15 19:22:14 jra Exp jra $ (ARL)";
d11458 2
d11465 3
d11473 1
a11473 1
nmg_edge_collapse( m, tol )
d11476 1
d11510 1
d11533 3
d11544 10
a11553 1
				if( eu->e_p->is_real )
d11558 4
d11563 1
d11571 10
a11580 1
				if( eu->e_p->is_real )
d11585 4
d11590 1
d11594 4
d11599 4
a11606 1
			/* create plane containing edge and normal to surface */
d11629 3
a11631 1

d11661 6
a11666 1

d11669 6
a11674 1

d11682 3
d11688 4
d11697 3
d11706 3
d11737 6
d11746 6
d11760 3
d11766 4
d11774 3
d11781 3
d11789 2
a11790 2
			if( ((max_dist1 > tol->dist) || (flip1 > 0) ) &&
			    ((max_dist2 > tol->dist) || (flip2 > 0) ) )
d11793 55
d11883 1
a11883 1
			if( (max_dist1 <= max_dist2) && !flip1 )
d11887 3
a11889 1

d11937 3
a11939 1

@


11.60
log
@Added nmg_edge_collapse()
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 11.59 1997/06/25 04:46:49 mike Exp jra $ (ARL)";
d11644 2
a11645 1
				vect_t norma, normb;
@


11.59
log
@extern has been superceeded by raytrace.h
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 11.58 1997/06/13 21:42:51 mike Exp mike $ (ARL)";
d11455 400
@


11.58
log
@rt_list_len became bu_list_len
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 11.57 1997/05/22 02:12:49 mike Exp mike $ (ARL)";
d48 3
a50 2
RT_EXTERN( struct edgeuse *nmg_find_e, (struct vertex *v1, struct vertex *v2, struct shell *s, struct edge *e ) );

@


11.57
log
@Removed unnecessary function
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 11.56 1997/05/19 11:59:00 jra Exp mike $ (ARL)";
d5161 1
a5161 1
	if( rt_list_len( &eg->eu_hd2 ) < 2*2 )  {
@


11.56
log
@Fixed a small bug in nmg_break_edge_at_verts().
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 11.55 1997/04/16 20:21:46 jra Exp jra $ (ARL)";
a3966 51
}

char *
nmg_magic_to_str( magic_p )
long *magic_p;
{
	switch( *magic_p )
	{
		case NMG_MODEL_MAGIC:
			return( "MODEL" );
		case NMG_REGION_MAGIC:
			return( "NMGREGION" );
		case NMG_REGION_A_MAGIC:
			return( "NMGREGION_A" );
		case NMG_SHELL_MAGIC:
			return( "SHELL" );
		case NMG_SHELL_A_MAGIC:
			return( "SHELL_A" );
		case NMG_FACEUSE_MAGIC:
			return( "FACEUSE" );
		case NMG_FACE_MAGIC:
			return( "FACE" );
		case NMG_FACE_G_PLANE_MAGIC:
			return( "FACE_G_PLANE" );
		case NMG_FACE_G_SNURB_MAGIC:
			return( "FACE_G_SNURB" );
		case NMG_LOOPUSE_MAGIC:
			return( "LOOPUSE" );
		case NMG_LOOP_G_MAGIC:
			return( "LOOP_G" );
		case NMG_LOOP_MAGIC:
			return( "LOOP" );
		case NMG_EDGEUSE_MAGIC:
			return( "EDGEUSE" );
		case NMG_EDGE_MAGIC:
			return( "EDGE" );
		case NMG_EDGE_G_LSEG_MAGIC:
			return( "EDGE_G_LSEG" );
		case NMG_EDGE_G_CNURB_MAGIC:
			return( "EDGE_G_CNURB" );
		case NMG_VERTEXUSE_MAGIC:
			return( "VERTEXUSE" );
		case NMG_VERTEXUSE_A_PLANE_MAGIC:
			return( "VERTEXUSE_A_PLANE" );
		case NMG_VERTEXUSE_A_CNURB_MAGIC:
			return( "VERTEXUSE_A_CNURB" );
		case NMG_VERTEX_MAGIC:
			return( "VERTEX" );
		case NMG_VERTEX_G_MAGIC:
			return( "VERTEX_G" );
	}
@


11.55
log
@Added nmg_magic_to_str().
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 11.54 1997/04/10 19:54:34 jra Exp jra $ (ARL)";
d10356 1
a10356 1
			bu_ptbl_rm( &edges, (long *)e );
@


11.54
log
@nmg_shell_is_void() now returns -1 if it can't tell rather than bombing.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 11.53 1996/11/19 20:29:03 jra Exp jra $ (ARL)";
d3969 51
d4082 1
a4082 1
	m = s_orig->r_p->m_p;
d4084 2
a4085 2
	/* make a temporary nmgregion for us to work in */
	tmp_r = nmg_mrsv( m );
d4087 2
a4088 2
	/* get rid of the automatically created shell */
	(void)nmg_ks( BU_LIST_FIRST( shell, &tmp_r->s_hd ) );
d4090 2
a4091 2
	/* make a copy of the shell of interest */
	dup_s = nmg_dup_shell( s_orig, &trans_tbl, tol );
d4093 2
a4094 2
	/* move the copy to our work area */
	nmg_mv_shell_to_region( dup_s, tmp_r );
d4162 1
d4206 1
@


11.53
log
@Fixed nmg_dup_shell() to correctly dup OT_OPPOSITE loopuses.
Mod to nmg_fix_normals() to not attempt NURB faces.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 11.52 1996/10/25 16:49:47 jra Exp jra $ (ARL)";
d423 7
d458 9
d480 2
d493 3
a496 1
	eu = e_top->eu_p;
d499 1
a499 1

d3391 1
d3418 1
a3418 1
		rt_bomb( "nmg_shell_is_void: Cannot determine if shell is void\n" );
d3428 1
a3428 1
		rt_bomb( "nmg_shell_is_void: Neither faceuse nor mate have OT_SAME orient\n" );
d3433 1
a3433 1
		rt_bomb( "nmg_shell_is_void: Cannot determine if shell is void\n" );
@


11.52
log
@Rewrite of nmg_fix_normals().
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 11.51 1996/10/11 18:34:22 jra Exp $ (ARL)";
d3074 6
d3971 1
d3982 28
a4091 1
		struct faceuse *fu;
d4109 6
@


11.51
log
@Improved nmg_fix_normals() to handle interior voids.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 11.50 1996/10/10 20:19:02 jra Exp jra $ (ARL)";
d348 6
d1519 2
a1520 1
	fastf_t hmin,hmax;
d1527 2
d1550 3
a1552 3
		pl[X] += ( vg->coord[Y] - vg_next->coord[Y]) * ( vg->coord[Z] + vg_next->coord[Z] );
		pl[Y] += ( vg->coord[Z] - vg_next->coord[Z]) * ( vg->coord[X] + vg_next->coord[X] );
		pl[Z] += ( vg->coord[X] - vg_next->coord[X]) * ( vg->coord[Y] + vg_next->coord[Y] );
d1555 2
a1556 1
	VUNITIZE( pl );
d2978 1
a2978 1
	nmg_gluefaces( fu_list , fu_counter );
d3012 1
a3012 1
nmg_dup_shell( s , trans_tbl )
d3015 1
d3017 1
d3031 1
d3113 1
a3113 1
	nmg_gluefaces( (struct faceuse **)BU_PTBL_BASEADDR( &faces) , BU_PTBL_END( &faces ) );
d3222 1
a3222 1
	
d3249 48
a3296 1
#if 1
d3320 1
a3320 3
#if 0
	(void)nmg_face_fix_radial_parity( fu , tol );
#else
a3353 1
#endif
a3354 1
#endif
a3481 17
		/* if there is more than one other radial for this edge
		 * in this shell, then can't know which to propogate to
		 */

		eu2 = eu1->radial_p->eumate_p;
		while( eu2 != eu1 )
		{
			if( nmg_find_s_of_eu( eu2 ) == fu_in->s_p )
				radial_count++;

			eu2 = eu2->radial_p->eumate_p;
		}

		if( radial_count > 1 )
			continue;

		/* go to the radial */
a3484 7
		/* make sure we are still on the same shell */
		while( nmg_find_s_of_eu( eu ) != fu_in->s_p && eu != eu1 && eu != eu1->eumate_p )
			eu = eu->eumate_p->radial_p;

		if( eu == eu1 || eu == eu1->eumate_p )
			continue;

d3486 2
a3487 7
		if( *eu->up.magic_p != NMG_LOOPUSE_MAGIC )
			continue;

		lu = eu->up.lu_p;
		NMG_CK_LOOPUSE( lu );

		if( *lu->up.magic_p != NMG_FACEUSE_MAGIC )
a3489 1
		fu = lu->up.fu_p;
d3496 15
a3510 7
				bu_log( "nmg_propagate_normals: reversing fu x%x\n" , fu );
#if 1
			/* if orientation is wrong, or if the radial edges are in the same direction
			 * then reverse the face and fix the radials */
			if( fu->orientation != OT_SAME ||
				( eu1->vu_p->v_p == eu->vu_p->v_p &&
				 eu1->eumate_p->vu_p->v_p == eu->eumate_p->vu_p->v_p ))
d3512 11
a3522 1
				nmg_reverse_face_and_radials( fu , tol );
d3524 5
a3528 4
#else
			/* Reverse face now, caller will fix radials */
			if( fu->orientation != OT_SAME )  {
				nmg_reverse_face( fu );
a3529 1
#endif
d3555 125
a3679 1
/*	N M G _ F I X _ N O R M A L S
d3681 48
a3728 8
 *	Finds the topmost face in the shell, assumes its normal must have
 *	a positive z-component, and makes it so if not.  Then propagates this
 *	orientation though the radial structures.  Disjoint shells are handled
 *	by flagging checked faces, and calling "nmg_find_top_face" again.
 *
 *	XXX - known bug: shells that are intended to describe void spaces (i.e., should
 *			 have inward pointing normals), will end up with outward pointing
 *			 normals.
d3730 2
d3735 1
a3735 1
nmg_fix_normals( s , tol )
a3739 4
	struct nmgregion *tmp_r;
	struct shell *dup_s;
	struct shell *s1;
	struct shell *kill_s;
d3742 3
a3745 6
	long **trans_tbl;
	int missed_faces=1;
	int shell_count=0;

	if( rt_g.NMG_debug & DEBUG_BASIC )
		bu_log( "nmg_fix_normals( s = x%x )\n" , s );
a3749 2

	/* Make an index table to insure we visit each face once and only once */
d3753 41
a3793 2
	/* loop to catch disjoint shells */
	while( missed_faces )
d3795 18
a3812 2
		vect_t normal;
		int dir;
d3814 3
a3816 14
		/* find the top face */
		f_top = nmg_find_top_face( s, &dir , flags );
		if( f_top == (struct face *)NULL )
		{
			bu_log( "nmg_fix_normals: Could not get a top face from nmg_find_top_face()\n" );
			bu_log( "\tWARNING: continuing without fixing normals!!!!\n" );
			rt_free( (char *)flags, "nmg_fix_normals: flags" );
			return;
		}
		if( *f_top->g.magic_p != NMG_FACE_G_PLANE_MAGIC )
		{
			NMG_INDEX_SET( flags, f_top );
			goto missed;
		}
d3818 4
a3821 2
		if( NMG_INDEX_TEST( flags, f_top ) )
			bu_log(" nmg_find_top_face returned a flagged face %x\n" , f_top );
d3823 4
a3826 2
		NMG_CK_FACE( f_top );
		fu = f_top->fu_p;
d3828 1
a3828 3
		if( fu->orientation != OT_SAME )
			fu = fu->fumate_p;
		if( fu->orientation != OT_SAME )
d3830 2
a3831 3
			bu_log( "nmg_fix_normals: no OT_SAME use of top face\n" );
			rt_free( (char *)flags , "nmg_fix_normals: flags" );
			return;
d3833 8
a3840 1
		NMG_GET_FU_NORMAL( normal , fu );
d3842 2
a3843 5
		if( rt_g.NMG_debug & DEBUG_BASIC )
		{
			bu_log( "\tnmg_fix_normals: top face is x%x in %d direction, OT_SAME use is x%x\n", f_top, dir, fu );
			bu_log( "\toutward normal = ( %g %g %g )\n" , V3ARGS( normal ) );
		}
d3845 22
a3866 6
		/* f_top is the topmost face (in the "dir" direction), so its OT_SAME use should have a
		 * normal with component in the "dir" direction */
		if( normal[dir] < 0.0 )
		{
			if( rt_g.NMG_debug & DEBUG_BASIC )
				bu_log( "nmg_fix_normals: reversing fu x%x\n" , fu );
d3868 1
a3868 2
			nmg_reverse_face_and_radials( fu, tol );
		}
a3869 4
		/* get OT_SAME use of top face */
		fu = f_top->fu_p;
		if( fu->orientation != OT_SAME )
			fu = fu->fumate_p;
d3871 2
a3872 1
		NMG_CK_FACEUSE( fu );
d3874 4
a3877 3
		/* fu is now known to be a correctly oriented faceuse,
		 * propagate this throughout the shell, face by face, by
		 * traversing the shell using the radial edge structure */
d3879 2
a3880 1
		nmg_propagate_normals( fu , flags , tol );
d3882 1
a3882 1
		if( rt_g.NMG_debug & DEBUG_BASIC )
d3884 16
a3899 1
			vect_t new_norm;
d3901 2
a3902 4
			NMG_GET_FU_NORMAL( new_norm , fu );
			bu_log( "nmg_fix_normals: After propagation top faceuse normal is ( %g %g %g )\n",
				V3ARGS( new_norm ) );
		}
d3904 2
a3905 1
missed:
d3907 2
a3908 3
		/* check if all the faces have been processed */
		missed_faces = 0;
		for( BU_LIST_FOR( fu , faceuse , &s->fu_hd ) )
d3910 1
a3910 2
			NMG_CK_FACEUSE( fu );
			if( fu->orientation == OT_SAME )
d3912 3
a3914 2
				if( !NMG_INDEX_TEST( flags , fu->f_p ) )
					missed_faces++;
d3916 1
d3918 2
d3921 3
a3923 1
		shell_count++;
d3926 45
a3970 2
	/* free some memory */
	rt_free( (char *)flags , "nmg_fix_normals: flags" );
d3972 2
a3973 2
	if( shell_count == 1 )
		return;
d3975 1
a3975 4
	/* this shell is actually more than one piece
	 * it may be than some pieces are inner voids and should have
	 * their normals reversed.
	 */
d3977 1
a3977 1
	/* make a temporary nmgregion to work in */
d3979 9
a3987 2
	kill_s = RT_LIST_FIRST( shell, &tmp_r->s_hd );
	(void)nmg_ks( kill_s );
d3989 3
a3991 2
	/* duplicate the shell in question */
	dup_s = nmg_dup_shell( s, &trans_tbl );
d3993 2
a3994 3
	/* move the duplicate shell to the temporary nmgregion */
	(void)nmg_mv_shell_to_region( dup_s, tmp_r );
	nmg_region_a( tmp_r, tol );
d3996 1
a3996 1
	if( (shell_count=nmg_decompose_shell( dup_s , tol )) > 1 )
d3998 21
a4018 4
		/* This shell has more than one part */
		int inner_count; /* count of how many shells contain this shell */
		struct bu_ptbl reverse_list;
		int i;
d4020 2
a4021 1
		bu_ptbl_init( &reverse_list, shell_count, "list of shells to be reversed" );
d4023 5
a4027 2
		for( RT_LIST_FOR( s1 , shell , &tmp_r->s_hd ) )
			nmg_shell_a( s1 , tol );
d4029 1
a4029 1
		for( RT_LIST_FOR( s1 , shell , &tmp_r->s_hd ) )
d4031 4
a4034 1
			struct shell *s2;
d4036 4
a4039 2
			inner_count = 0;
			for( RT_LIST_FOR( s2 , shell , &tmp_r->s_hd ) )
d4041 11
a4051 2
				if( s1 == s2 )
					continue;
d4053 6
a4058 3
				if( nmg_classify_s_vs_s( s1, s2, tol ) == NMG_CLASS_AinB )
					inner_count++;
			}
d4060 4
a4063 2
			if( inner_count % 2 )
			{
d4065 5
a4069 4
				/* this shell is contained by an odd number of shells
				 * it must be a void region, so reverse the surface normals
				 */
				bu_ptbl_ins( &reverse_list, (long *)s1 );
d4071 2
a4072 2
			}
		}
d4074 3
d4078 3
a4080 7
		/* reverse shells on list */
		for( i=0 ; i<BU_PTBL_END( &reverse_list ); i++ )
		{
			s1 = (struct shell *)BU_PTBL_GET( &reverse_list, i );
			for( BU_LIST_FOR( fu, faceuse, &s1->fu_hd ) )
			{
				struct faceuse *fu_in_s;
d4082 1
a4082 2
				if( fu->orientation != OT_SAME )
					continue;
d4084 3
a4086 3
				fu_in_s = NMG_INDEX_GETP( faceuse, trans_tbl, fu );
				NMG_CK_FACEUSE( fu_in_s );
				nmg_reverse_face_and_radials( fu_in_s , tol );
d4090 4
a4093 2
	rt_free( (char *)trans_tbl, "trans_tbl" );
	(void)nmg_kr( tmp_r );
a4561 2
	(void)nmg_split_loops_into_faces( &s->l.magic , tol );

d4572 3
d4629 1
a4629 1
                        /* push all "winged" edgeuses of "fu" onto the stack */
d4694 1
a4694 1
			 * shells_at_edge[0] si the number of uses of this edge
d4941 3
d4947 1
d4966 1
d4968 2
d4973 4
a4976 2
		if( nmg_kvu( new_s->vu_p ) )
			rt_bomb( "nmg_decompose_shell: killed shell vertex, emptied shell!!\n" );
d4982 2
d9161 1
a9161 1
	nmg_gluefaces( (struct faceuse **)BU_PTBL_BASEADDR( &faces) , BU_PTBL_END( &faces ) );
a11391 32
}

int
nmg_mv_region_to_model( r, m )
struct nmgregion *r;
struct model *m;
{
	struct model *m_old;
	int ret_val;

	NMG_CK_REGION( r );
	NMG_CK_MODEL( m );

	if( r->m_p == m )
		return( 0 );

	m_old = r->m_p;

	BU_LIST_DEQUEUE( &r->l );

	if( BU_LIST_IS_EMPTY( &m_old->r_hd ) )
		ret_val = 1;
	else
		ret_val = 0;

	BU_LIST_APPEND( &m->r_hd, &r->l );

	r->m_p = m;

	nmg_m_reindex( m, 0 );

	return( ret_val );
@


11.50
log
@Added nmg_mv_region_to_model()
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 11.49 1996/10/10 12:42:58 bparker Exp jra $ (ARL)";
d3013 1
d3023 2
a3024 1
	(*trans_tbl) = (long **)rt_calloc(m->maxindex*3, sizeof(long *),
d3030 1
d3032 2
d3048 1
d3050 2
d3056 1
d3058 2
d3061 1
d3063 3
d3067 3
d3071 2
d3088 1
d3090 2
d3108 1
d3110 2
d3134 1
d3136 2
d3140 1
d3142 2
d3147 1
d3149 2
d3154 1
d3156 2
d3161 1
d3163 2
d3195 1
d3197 2
d3202 1
d3204 2
d3530 4
d3537 1
d3539 1
d3547 1
a3610 4
#if 0
		/* Establish radial parity */
		nmg_s_radial_harmonize( s, tol );
#endif
a3616 4
#if 0
		/* Re-establish radial parity */
		nmg_s_radial_harmonize( s, tol );
#endif
d3640 2
d3646 78
@


11.49
log
@if'd out variable _poly ----- not being used ---- because it wouldn't compile on sun4
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 11.48 1996/09/27 08:27:30 mike Exp bparker $ (ARL)";
d10884 32
@


11.48
log
@Converted to using proper routine names for LIBBU and LIBBN routines.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 11.47 1996/09/27 07:20:30 mike Exp mike $ (ARL)";
d10548 3
a10550 1
	struct rt_pg_face_internal *poly;
@


11.47
log
@Lee fixed incorrect arguments.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 11.46 1996/08/28 05:42:36 mike Exp butler $ (ARL)";
d62 1
a62 1
	if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d75 1
a75 1
	for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d98 1
a98 1
	for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d188 1
a188 1
		rt_log( "nmg_snurb_fu_get_norm: face has no geometry (x%x)\n", f );
d193 1
a193 1
		rt_log( "nmg_snurb_fu_get_norm: face is not a NURB face (x%x)\n", f );
d226 1
a226 1
		rt_log( "nmg_snurb_fu_get_norm: face has no geometry (x%x)\n", f );
d231 1
a231 1
		rt_log( "nmg_snurb_fu_get_norm: face is not a NURB face (x%x)\n", f );
d256 1
a256 1
		rt_log( "nmg_snurb_fu_get_norm_at_vu: vertexuse does not have an attribute (x%x)\n", vu );
d262 1
a262 1
		rt_log( "nmg_snurb_fu_get_norm_at_vu: vertexuse does not have a cnurb attribute (x%x)\n", vu );
d277 1
a277 1
	struct nmg_ptbl eu_tab;
d281 1
a281 1
	nmg_tbl( &eu_tab, TBL_INIT, (long *)0 );
d285 1
a285 1
	for( i=0 ; i<NMG_TBL_END( &eu_tab ) ; i++ )
d289 1
a289 1
		eu = (struct edgeuse *)NMG_TBL_GET( &eu_tab, i );
d297 1
a297 1
		rt_log( "Edgeuse x%x (vp %x to vp %x)\n" , eu, eu->vu_p->v_p, eu->eumate_p->vu_p->v_p );
d300 1
a300 1
			rt_log( "\tThis is a wire edge\n" );
d309 1
a309 1
	nmg_tbl( &eu_tab, TBL_FREE, (long *)0 );
d344 1
a344 1
		rt_log( "nmg_find_top_face_in_dir( s = x%x , dir=%d , flags = x%x )\n" , s, dir , flags );
d358 1
a358 1
	for( RT_LIST_FOR( fu , faceuse , &s->fu_hd ) )
d365 1
a365 1
		for( RT_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
d368 1
a368 1
			if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) == NMG_EDGEUSE_MAGIC )
d370 1
a370 1
				for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
d395 1
a395 1
		rt_log( "Find_top_face_in_dir: Could not find extreme vertex" );
d400 1
a400 1
		rt_log( "top vertex is x%x at ( %g %g %g )\n",
d404 1
a404 1
	for( RT_LIST_FOR( vu , vertexuse , &vp_top->vu_hd ) )
d465 1
a465 1
		rt_log( "Fix_normals: Could not find uppermost edge" );
d480 1
a480 1
		rt_log( "top EU is x%x (%g %g %g) <-> (%g %g %g)\n",
d491 1
a491 1
	for( RT_LIST_FOR( vu, vertexuse, &v1->vu_hd ) )
d526 1
a526 1
			rt_log( "test EU is x%x (%g %g %g) <-> (%g %g %g)\n",
d533 1
a533 1
			rt_log( "edge_dir is ( %g %g %g )\n", V3ARGS( edge_dir ) );
d542 1
a542 1
			rt_log( "fu normal is ( %g %g %g )\n" , V3ARGS( normal ) );
d551 2
a552 2
			rt_log( "left vector is ( %g %g %g )\n", V3ARGS( left ) );
			rt_log( "\textreme slope in %d direction is %g\n", dir, extreme_slope );
d569 1
a569 1
					rt_log( "new f_top\n" );
d578 1
a578 1
		rt_log( "Nmg_find_top_face_in_dir: Could not find uppermost face" );
d583 1
a583 1
		rt_log( "nmg_find_top_face_in_dir: top face = x%x, dir = %d, top vertex = x%x ( %g %g %g )\n",
d615 1
a615 1
	rt_log( "Nmg_find_top_face: Cannot find a top face\n" );
d623 1
a623 1
 * Passed an nmg_ptbl structure containing one shell, this routine
d625 2
a626 2
 * within the shell on the nmg_ptbl list. Any such void shells found are added
 * to the nmg_ptbl list. The final result is a ptbl list of shells where the
d643 2
a644 2
struct nmg_ptbl *shells;
CONST struct rt_tol *ttol;
d657 2
a658 2
	NMG_CK_PTBL( shells );
	RT_CK_TOL( ttol );
d660 1
a660 1
	outer_shell = (struct shell *)NMG_TBL_GET( shells , 0 );
d664 1
a664 1
	for( RT_LIST_FOR( s , shell , &r->s_hd ) )
d683 1
a683 1
	for( RT_LIST_FOR( s , shell , &r->s_hd ) )
d692 1
a692 1
			rt_log( "WARNING: nmg_assoc_void_shells() could not find top face for shell x%x\n", s );
d703 1
a703 1
	for( RT_LIST_FOR( void_s , shell , &r->s_hd ) )
d743 1
a743 1
			for( RT_LIST_FOR( fu , faceuse , &void_s->fu_hd ) )
d745 1
a745 1
				for( RT_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
d747 1
a747 1
					if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d749 1
a749 1
					for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
d785 1
a785 1
			for( RT_LIST_FOR( test_s , shell , &r->s_hd ) )
d836 1
a836 1
			nmg_tbl( shells , TBL_INS , (long *)void_s );
d844 1
a844 1
 * This routine takes a region and constructs an array of nmg_ptbl lists.
d854 2
a855 2
struct nmg_ptbl ***shells;
CONST struct rt_tol *tol;
d857 1
a857 1
	struct nmg_ptbl *outer_shells;
d867 1
a867 1
	RT_CK_TOL( tol );
d870 3
a872 3
	outer_shells = (struct nmg_ptbl *)rt_malloc( sizeof( struct nmg_ptbl ) , "nmg_find_outer_and_void_shells: outer_shells" );
	nmg_tbl( outer_shells , TBL_INIT , NULL );
	for (RT_LIST_FOR(s, shell, &r->s_hd))
d875 1
a875 1
		nmg_tbl( outer_shells , TBL_INS , (long *)s );
d877 1
a877 1
	for( i=0 ; i<NMG_TBL_END( outer_shells ) ; i++ )
d879 1
a879 1
		s = (struct shell *)NMG_TBL_GET( outer_shells , i );
d883 1
a883 1
	nmg_tbl( outer_shells , TBL_RST , NULL );
d888 1
a888 1
	for (RT_LIST_FOR(s, shell, &r->s_hd))
d893 1
a893 1
	for( RT_LIST_FOR( s , shell , &r->s_hd ) )
d909 1
a909 1
			nmg_tbl( outer_shells , TBL_INS , (long *)s );	/* outer shell */
d914 1
a914 1
	outer_shell_count = NMG_TBL_END( outer_shells );
d916 1
a916 1
	*shells = (struct nmg_ptbl **)rt_calloc( NMG_TBL_END( outer_shells ) , sizeof( struct nmg_ptbl *) ,
d918 1
a918 1
	for( i=0 ; i<NMG_TBL_END( outer_shells ) ; i++ )
d920 1
a920 1
		(*shells)[i] = (struct nmg_ptbl *)rt_malloc( sizeof( struct nmg_ptbl ) , 
d923 3
a925 3
		nmg_tbl( (*shells)[i] , TBL_INIT , NULL );
		NMG_CK_PTBL( (*shells)[i] );
		nmg_tbl( (*shells)[i] , TBL_INS , (long *)NMG_TBL_GET( outer_shells , i ) );
d931 1
a931 1
	nmg_tbl( outer_shells , TBL_FREE , NULL );
d996 1
a996 1
	struct nmg_ptbl edges;
d1001 1
a1001 1
	count = NMG_TBL_END( &edges );
d1006 1
a1006 1
		e = (struct edge *)NMG_TBL_GET( &edges , i );
d1012 1
a1012 1
	nmg_tbl( &edges , TBL_FREE , (long *)NULL );
d1024 1
a1024 1
struct nmg_ptbl *tab;
d1031 1
a1031 1
	nmg_tbl( tab, TBL_INIT, (long *)0 );
d1034 1
a1034 1
	for( RT_LIST_FOR( f , face , &fg->f_hd ) )
d1046 1
a1046 1
		for( RT_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
d1051 1
a1051 1
			if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) == NMG_VERTEXUSE_MAGIC )
d1056 1
a1056 1
				vu = RT_LIST_FIRST(vertexuse, &lu->down_hd);
d1062 1
a1062 1
				nmg_tbl( tab , TBL_INS_UNIQUE , (long *)v );
d1069 1
a1069 1
				for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
d1081 1
a1081 1
					nmg_tbl( tab , TBL_INS_UNIQUE , (long *)v );
d1125 1
a1125 1
		rt_log( "rt_isect_planes:\n" );
d1128 1
a1128 1
			rt_log( "Plane #%d (%f %f %f %f)\n" , i , V4ARGS( planes[i] ) );
d1175 1
a1175 1
CONST struct rt_tol *tol;
d1181 1
a1181 1
	struct nmg_ptbl fus;
d1186 1
a1186 1
	RT_CK_TOL( tol );
d1199 1
a1199 1
	nmg_tbl( &fus , TBL_INIT , (long *)NULL );
d1201 1
a1201 1
	for( RT_LIST_FOR( fu , faceuse , &s->fu_hd ) )
d1206 1
a1206 1
			nmg_tbl( &fus , TBL_INS , (long *)fu );
d1210 1
a1210 1
	for( fu_no=0 ; fu_no < NMG_TBL_END( &fus ) ; fu_no ++ )
d1214 1
a1214 1
		fu = (struct faceuse *)NMG_TBL_GET( &fus , fu_no );
d1224 1
a1224 1
		for( fu2_no=fu_no+1 ; fu2_no < NMG_TBL_END( &fus ) ; fu2_no++ )
d1228 1
a1228 1
			fu2 = (struct faceuse *)NMG_TBL_GET( &fus , fu2_no );
d1231 1
a1231 1
				rt_log( "nmg_extrude_cleanup: fu=x%x, fu2=x%x\n" , fu , fu2 );
d1245 1
a1245 1
				rt_log( "nmg_extrude_cleanup: calling nmg_isect_two_generic_faces( fu=x%x , fu2=x%x )\n" , fu , fu2 );
d1250 1
a1250 1
		while( RT_LIST_NON_EMPTY( &s_fu->fu_hd ) )
d1254 1
a1254 1
			fu_tmp = RT_LIST_FIRST( faceuse , &s_fu->fu_hd );
d1258 1
a1258 1
				rt_log( "nmg_extrude_cleanup: moving fu x%x back\n" , fu_tmp );
d1267 1
a1267 1
	nmg_tbl( &fus, TBL_FREE, (long *)NULL );
d1395 1
a1395 1
struct rt_tol *tol;
d1400 1
a1400 1
	RT_CK_TOL( tol );
d1402 1
a1402 1
	for( RT_LIST_FOR( fu , faceuse , &s->fu_hd ) )
d1411 1
a1411 1
		for( RT_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
d1417 1
a1417 1
			if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d1420 1
a1420 1
			for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
d1458 1
a1458 1
		rt_log( "nmg_move_lu_between_fus( dest=x%x, src=x%x, lu=x%x)\n", dest, src, lu );
d1462 1
a1462 1
		rt_log( "nmg_move_lu_between_fus( dest=x%x, src=x%x, lu=x%x)\n", dest, src, lu );
d1473 2
a1474 2
	RT_LIST_DEQUEUE( &lu->l );
	src_is_empty = RT_LIST_IS_EMPTY( &src->lu_hd );
d1477 2
a1478 2
	RT_LIST_DEQUEUE( &lumate->l );
	if( src_is_empty != RT_LIST_IS_EMPTY( &src->fumate_p->lu_hd ) )
d1480 1
a1480 1
		rt_log( "nmg_move_lu_between_fus( dest=x%x, src=x%x, lu=x%x)\n", dest, src, lu );
d1487 1
a1487 1
	RT_LIST_INSERT( &dest->lu_hd, &lu->l );
d1490 1
a1490 1
	RT_LIST_INSERT( &dest->fumate_p->lu_hd, &lumate->l );
d1521 1
a1521 1
	if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d1528 1
a1528 1
	if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d1531 1
a1531 1
	for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d1538 1
a1538 1
		eu_next = RT_LIST_PNEXT_CIRC( edgeuse, &eu->l );
d1551 1
a1551 1
	for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d1599 1
a1599 1
	if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d1611 1
a1611 1
	eu = RT_LIST_FIRST( edgeuse , &lu->down_hd );
d1628 1
a1628 1
	for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
d1637 1
a1637 1
		next_eu = RT_LIST_PNEXT_CIRC( edgeuse , &eu->l );
d1663 1
a1663 1
	for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
d1703 1
a1703 1
	struct nmg_ptbl verts;
d1724 1
a1724 1
	for( RT_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
d1726 1
a1726 1
		if( !got_dir && RT_LIST_FIRST_MAGIC( &lu->down_hd ) == NMG_EDGEUSE_MAGIC )
d1751 1
a1751 1
		for( RT_LIST_FOR( f1 , face, &fg->f_hd ) )
d1753 1
a1753 1
			for( RT_LIST_FOR( lu, loopuse, &f1->fu_p->lu_hd ) )
d1787 2
a1788 2
			rt_log( "nmg_calc_face_plane: fu x%x has no OT_SAME use\n" , fu );
			nmg_tbl( &verts , TBL_FREE , (long *)NULL );
d1797 1
a1797 1
	one_over_vertex_count = 1.0/(double)(NMG_TBL_END( &verts ));
d1799 1
a1799 1
	for( i=0 ; i<NMG_TBL_END( &verts ) ; i++ )
d1804 1
a1804 1
		v = (struct vertex *)NMG_TBL_GET( &verts , i );
d1861 2
a1862 2
		v0 = (struct vertex *)NMG_TBL_GET( &verts , 0 );
		for( i=1 ; i<NMG_TBL_END( &verts ) ; i++ )
d1864 1
a1864 1
			v = (struct vertex *)NMG_TBL_GET( &verts , i );
d1904 1
a1904 1
			rt_log( "nmg_calc_face_plane: Cannot calculate plane for fu x%x\n" , fu );
d1906 1
a1906 1
			rt_log( "%d verts\n" , NMG_TBL_END( &verts ) );
d1912 1
a1912 1
	for( i=0 ; i<NMG_TBL_END( &verts ) ; i++ )
d1918 1
a1918 1
		v = (struct vertex *)NMG_TBL_GET( &verts, i );
d1930 1
a1930 1
	nmg_tbl( &verts , TBL_FREE , (long *)NULL );
d1973 1
a1973 1
	for( RT_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
d1975 1
a1975 1
		if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d1988 1
a1988 1
			rt_log( "nmg_faceuse_area: Cannot calculate area (lu with %s orientation)\n",
d2007 1
a2007 1
	for( RT_LIST_FOR( fu , faceuse , &s->fu_hd ) )
d2031 1
a2031 1
	for( RT_LIST_FOR( s , shell , &r->s_hd ) )
d2046 1
a2046 1
	for( RT_LIST_FOR( r , nmgregion , &m->r_hd ) )
d2073 1
a2073 1
CONST struct rt_tol *tol;
d2083 1
a2083 1
	RT_CK_TOL( tol );
d2097 1
a2097 1
		rt_log( "rt_dist_line3_line3: non-unit length direction vector ( %f %f %f )\n" , V3ARGS( d1 ) );
d2103 1
a2103 1
		rt_log( "rt_dist_line3_line3: non-unit length direction vector ( %f %f %f )\n" , V3ARGS( d2 ) );
d2109 1
a2109 1
	if( RT_VECT_ARE_PARALLEL( d1_d2 , tol ) )
d2111 1
a2111 1
		if( rt_dist_line_point( p1 , d1 , p2 ) > tol_dist )
d2160 1
a2160 1
CONST struct rt_tol *tol;
d2168 1
a2168 1
	RT_CK_TOL( tol );
d2228 1
a2228 1
 *	of an nmg_ptbl structure.
d2232 1
a2232 1
struct nmg_ptbl		*vert_list;
d2235 1
a2235 1
CONST struct rt_tol	*tol;
d2247 1
a2247 1
	RT_CK_TOL(tol);
d2251 2
a2252 2
		rt_log("nmg_purge_unwanted_intersection_points(0x%08x, 0x%08x)\n", vert_list, fu);
		rt_log("\t%d vertexuses in list\n", vert_list->end );
d2280 1
a2280 1
			rt_log("vu[%d]: 0x%08x (%g %g %g) lu: 0x%08x %s\n",
d2283 1
a2283 1
			rt_log("\tlu BBox: (%g %g %g) (%g %g %g)\n",
d2287 1
a2287 1
			rt_log("I'm checking against my own face?\n");
d2294 1
a2294 1
		for (RT_LIST_FOR(fu2lu, loopuse, &fu->lu_hd )){
d2310 2
a2311 2
				if( RT_LIST_FIRST_MAGIC(&fu2lu->down_hd) != NMG_VERTEXUSE_MAGIC )
					rt_log("nmg_purge_unwanted_intersection_points() non self-loop OT_UNSPEC vertexuse in fu2?\n");
d2317 1
a2317 1
				rt_log("nmg_purge_unwanted_intersection_points encountered %s loop in fu2\n",
d2327 1
a2327 1
				rt_log("\tfu2lu BBox: (%g %g %g)  (%g %g %g) %s\n",
d2341 1
a2341 1
				rt_log("nmg_purge_unwanted_intersection_points This little bugger slipped in somehow.  Deleting it from the list.\n");
d2344 1
a2344 1
			if( RT_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC &&
d2348 1
a2348 1
					rt_log("nmg_purge_unwanted_intersection_points() remarking as OT_BOOLPLACE\n");
d2367 1
a2367 1
		rt_log("\tAt end of nmg_purge_unwanted_intersection_points, %d vertexuses in list\n",
d2381 1
a2381 1
struct nmg_ptbl *b;
d2413 1
a2413 1
CONST struct rt_tol	*tol;
d2424 1
a2424 1
	RT_CK_TOL(tol);
d2428 1
a2428 1
	for( RT_LIST_FOR( r, nmgregion, &m->r_hd ) )  {
d2430 1
a2430 1
		for( RT_LIST_FOR( s, shell, &r->s_hd ) )  {
d2434 1
a2434 1
			for( RT_LIST_FOR( fu, faceuse, &s->fu_hd ) )  {
d2437 1
a2437 1
				for( RT_LIST_FOR( lu, loopuse, &fu->lu_hd ) )  {
d2446 1
a2446 1
			for( RT_LIST_FOR( fu, faceuse, &s->fu_hd ) )  {
d2457 1
a2457 1
			for( RT_LIST_FOR( lu, loopuse, &s->lu_hd ) )  {
d2504 2
a2505 2
	for (RT_LIST_FOR(r, nmgregion, &m->r_hd)) {
		for (RT_LIST_FOR(s, shell, &r->s_hd)) {
d2510 1
a2510 1
			for (RT_LIST_FOR(fu, faceuse, &s->fu_hd)) {
d2514 1
a2514 1
			for (RT_LIST_FOR(lu, loopuse, &s->lu_hd)) {
d2518 1
a2518 1
			for (RT_LIST_FOR(eu, edgeuse, &s->eu_hd)) {
d2543 1
a2543 1
struct nmg_ptbl *tbl;
d2562 1
a2562 1
	eu = (struct edgeuse *)NMG_TBL_GET( tbl , 0 );
d2572 1
a2572 1
			eu1 = (struct edgeuse *)NMG_TBL_GET( tbl , j );
d2601 1
a2601 1
struct rt_tol *tol;
d2603 2
a2604 2
	struct nmg_ptbl eu_tbl;		/* table of free edgeuses from shell */
	struct nmg_ptbl vert_tbl;	/* table of vertices for use in nmg_cface */
d2616 1
a2616 1
		rt_log( "nmg_close_shell: s = x%x\n" , s );
d2619 1
a2619 1
	RT_CK_TOL( tol );
d2624 1
a2624 1
	(void)nmg_tbl( &eu_tbl , TBL_INIT , (long *)NULL );
d2627 1
a2627 1
	for( RT_LIST_FOR( fu , faceuse , &s->fu_hd ) )
d2636 1
a2636 1
			for( RT_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
d2640 1
a2640 1
				if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) ==
d2645 1
a2645 1
				for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
d2650 1
a2650 1
						(void)nmg_tbl( &eu_tbl , TBL_INS , (long *) eu->eumate_p );
d2657 1
a2657 1
	if( NMG_TBL_END( &eu_tbl ) == 0 )
d2659 1
a2659 1
		nmg_tbl( &eu_tbl , TBL_FREE , (long *)NULL );
d2664 1
a2664 1
	fu_list = (struct faceuse **)rt_calloc( fu_counter + NMG_TBL_END( &eu_tbl ) - 2 , sizeof( struct faceuse *) , "face use list " );
d2666 1
a2666 1
	for( RT_LIST_FOR( fu , faceuse , &s->fu_hd ) )
d2674 1
a2674 1
	(void)nmg_tbl( &vert_tbl , TBL_INIT , (long *)NULL );
d2676 1
a2676 1
	while( NMG_TBL_END( &eu_tbl ) )
d2682 1
a2682 1
		order_tbl( &eu_tbl , &index , NMG_TBL_END( &eu_tbl ) , &loop_size );
d2704 1
a2704 1
				eu = (struct edgeuse *)NMG_TBL_GET( &eu_tbl , index[i] );
d2707 1
a2707 1
			while( rt_mk_plane_3pts( pl1 , pt[0] , pt[1] , pt[2] , tol ) && end_index<loop_size )
d2713 1
a2713 1
					eu = (struct edgeuse *)NMG_TBL_GET( &eu_tbl , index[i] );
d2734 1
a2734 1
					eu = (struct edgeuse *)NMG_TBL_GET( &eu_tbl , index[i] );
d2740 1
a2740 1
				if( !rt_mk_plane_3pts( pl2 , pt[0] , pt[1] , pt[2] , tol ) )
d2742 1
a2742 1
					if( rt_coplanar( pl1 , pl2 , tol ) < 1 )
d2750 1
a2750 1
				nmg_tbl( &vert_tbl , TBL_RST , (long *)NULL );
d2753 2
a2754 2
					eu = (struct edgeuse *)NMG_TBL_GET( &eu_tbl , index[i] );
					nmg_tbl( &vert_tbl , TBL_INS , (long *)eu->vu_p->v_p );
d2758 1
a2758 1
				fu = nmg_cface( s , (struct vertex **)NMG_TBL_BASEADDR(&vert_tbl) , loop_size );
d2761 2
a2762 2
				if( nmg_loop_plane_area( RT_LIST_FIRST( loopuse , &fu->lu_hd ) , pl2 ) < 0.0 )
					rt_log( "Failed planeeq\n" );
d2775 1
a2775 1
					eu_used[i] = (struct edgeuse *)NMG_TBL_GET( &eu_tbl , index[i] );
d2778 1
a2778 1
					nmg_tbl( &eu_tbl , TBL_RM , (long *)eu_used[i] );
d2794 1
a2794 1
				(void)nmg_tbl( &vert_tbl , TBL_RST , (long *)NULL );
d2801 2
a2802 2
				eu1 = (struct edgeuse *)NMG_TBL_GET( &eu_tbl , index[start_index] );
				nmg_tbl( &vert_tbl , TBL_INS , (long *)eu1->vu_p->v_p );
d2807 2
a2808 2
				eu2 = (struct edgeuse *)NMG_TBL_GET( &eu_tbl , index[end_index] );
				nmg_tbl( &vert_tbl , TBL_INS , (long *)eu2->vu_p->v_p );
d2812 1
a2812 1
				while( rt_3pts_collinear(
d2823 2
a2824 2
					eu2 = (struct edgeuse *)NMG_TBL_GET( &eu_tbl , index[end_index]);
					nmg_tbl( &vert_tbl , TBL_INS , (long *)eu2->vu_p->v_p );
d2845 1
a2845 1
							eu_used[i] = (struct edgeuse *)NMG_TBL_GET( &eu_tbl , index[i] );
d2847 1
a2847 1
							nmg_tbl( &eu_tbl , TBL_RM , (long *)eu_used[i] );
d2861 1
a2861 1
			nmg_tbl( &vert_tbl , TBL_INS , (long *)eu2->eumate_p->vu_p->v_p );
d2866 1
a2866 1
				eu_used[i] = (struct edgeuse *)NMG_TBL_GET( &eu_tbl , index[i] );
d2869 3
a2871 3
			fu = nmg_cface( s , (struct vertex **)NMG_TBL_BASEADDR(&vert_tbl) , edges_used+1 );
			if( nmg_loop_plane_area( RT_LIST_FIRST( loopuse , &fu->lu_hd ) , pl2 ) < 0.0 )
				rt_log( "Failed planeeq\n" );
d2880 1
a2880 1
			for( RT_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
d2883 1
a2883 1
				if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) ==
d2886 1
a2886 1
				for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
d2889 2
a2890 2
					if( eu->vu_p->v_p == (struct vertex *)NMG_TBL_GET( &vert_tbl , 0 )
					&& eu->eumate_p->vu_p->v_p == (struct vertex *)NMG_TBL_GET( &vert_tbl , edges_used) )
d2896 2
a2897 2
					else if( eu->vu_p->v_p == (struct vertex *)NMG_TBL_GET( &vert_tbl , edges_used)
					&& eu->eumate_p->vu_p->v_p == (struct vertex *)NMG_TBL_GET( &vert_tbl , 0 ) )
d2911 2
a2912 2
				nmg_tbl( &eu_tbl , TBL_RM , (long *)eu_used[i] );
			nmg_tbl( &eu_tbl , TBL_INS , (long *)eu_new );
d2917 1
a2917 1
			order_tbl( &eu_tbl , &index , NMG_TBL_END( &eu_tbl ) , &loop_size );
d2925 3
a2927 3
			rt_log( "Error, loop size should be 3\n" );
			nmg_tbl( &eu_tbl , TBL_FREE , (long *)NULL );
			nmg_tbl( &vert_tbl , TBL_FREE , (long *)NULL );
d2934 1
a2934 1
		nmg_tbl( &vert_tbl , TBL_RST , (long *)NULL );
d2937 2
a2938 2
			eu = (struct edgeuse *)NMG_TBL_GET( &eu_tbl , index[i] );
			(void)nmg_tbl( &vert_tbl , TBL_INS , (long *)eu->vu_p->v_p);
d2941 4
a2944 4
		if( !rt_3pts_collinear(
			((struct vertex *)NMG_TBL_GET( &vert_tbl , 0 ))->vg_p->coord,
			((struct vertex *)NMG_TBL_GET( &vert_tbl , 1 ))->vg_p->coord,
			((struct vertex *)NMG_TBL_GET( &vert_tbl , 2 ))->vg_p->coord,
d2949 1
a2949 1
			fu = nmg_cface( s , (struct vertex **)NMG_TBL_BASEADDR(&vert_tbl) , 3 );
d2951 1
a2951 1
				rt_log( "Failed planeeq\n" );
d2959 6
a2964 6
		eu1 = (struct edgeuse *)NMG_TBL_GET( &eu_tbl , index[0] );
		eu2 = (struct edgeuse *)NMG_TBL_GET( &eu_tbl , index[1] );
		eu3 = (struct edgeuse *)NMG_TBL_GET( &eu_tbl , index[2] );
		nmg_tbl( &eu_tbl , TBL_RM , (long *)eu1 );
		nmg_tbl( &eu_tbl , TBL_RM , (long *)eu2 );
		nmg_tbl( &eu_tbl , TBL_RM , (long *)eu3 );
d2973 2
a2974 2
	nmg_tbl( &eu_tbl , TBL_FREE , (long *)NULL );
	nmg_tbl( &vert_tbl , TBL_FREE , (long *)NULL );
d2980 1
a2980 1
		rt_log( "nmg_close_shell(): Simplified shell is empty" );
d3012 1
a3012 1
	struct nmg_ptbl faces;
d3015 1
a3015 1
		rt_log( "nmg_dup_shell( s = x%x , trans_tbl = x%x )\n" , s , trans_tbl );
d3025 1
a3025 1
	nmg_tbl( &faces , TBL_INIT , (long *)NULL );
d3031 1
a3031 1
	for( RT_LIST_FOR( fu , faceuse , &s->fu_hd ) )
d3037 1
a3037 1
			for( RT_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
d3072 1
a3072 1
			nmg_tbl( &faces , TBL_INS , (long *)new_fu );
d3077 2
a3078 2
	nmg_gluefaces( (struct faceuse **)NMG_TBL_BASEADDR( &faces) , NMG_TBL_END( &faces ) );
	nmg_tbl( &faces , TBL_FREE , (long *)NULL );
d3081 1
a3081 1
	for( RT_LIST_FOR( lu , loopuse , &s->lu_hd ) )
d3089 1
a3089 1
	for( RT_LIST_FOR( eu , edgeuse , &s->eu_hd ) )
d3166 1
a3166 1
/*	Routines to use the nmg_ptbl structures as a stack of edgeuse structures */
d3168 1
a3168 1
#define	NMG_PUSH( _ptr , _stack )	nmg_tbl( _stack , TBL_INS , (long *) _ptr );
d3172 1
a3172 1
struct nmg_ptbl *stack;
d3177 1
a3177 1
	if( NMG_TBL_END( stack ) == 0 )
d3181 1
a3181 1
	eu = (struct edgeuse *)NMG_TBL_GET( stack , NMG_TBL_END( stack )-1 );
d3184 1
a3184 1
	nmg_tbl( stack , TBL_RM , (long *)eu );
d3201 1
a3201 1
CONST struct rt_tol *tol;
d3206 1
a3206 1
		rt_log( "nmg_reverse_face_and_radials( fu = x%x )\n" , fu );
d3209 1
a3209 1
	RT_CK_TOL( tol );
d3216 1
a3216 1
	for( RT_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
d3225 1
a3225 1
		if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d3228 1
a3228 1
		for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d3324 1
a3324 1
CONST struct rt_tol *tol;
d3326 1
a3326 1
	struct nmg_ptbl stack;
d3332 1
a3332 1
		rt_log( "nmg_propagate_normals( fu_in = x%x , flags = x%x )\n" , fu_in , flags );
d3335 1
a3335 1
	RT_CK_TOL( tol );
d3342 1
a3342 1
		rt_log( "nmg_propagate_normals: Could not find OT_SAME orientation of faceuse x%x\n" , fu_in );
d3350 1
a3350 1
	nmg_tbl( &stack , TBL_INIT , (long *)NULL );
d3353 1
a3353 1
	for( RT_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
d3356 1
a3356 1
		if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d3358 1
a3358 1
		for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
d3423 1
a3423 1
				rt_log( "nmg_propagate_normals: reversing fu x%x\n" , fu );
d3445 1
a3445 1
			for( RT_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
d3448 1
a3448 1
				if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d3450 1
a3450 1
				for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
d3461 1
a3461 1
	nmg_tbl( &stack , TBL_FREE , (long *)NULL );
d3480 1
a3480 1
CONST struct rt_tol *tol;
d3489 1
a3489 1
		rt_log( "nmg_fix_normals( s = x%x )\n" , s );
d3492 1
a3492 1
	RT_CK_TOL( tol );
d3508 2
a3509 2
			rt_log( "nmg_fix_normals: Could not get a top face from nmg_find_top_face()\n" );
			rt_log( "\tWARNING: continuing without fixing normals!!!!\n" );
d3520 1
a3520 1
			rt_log(" nmg_find_top_face returned a flagged face %x\n" , f_top );
d3529 1
a3529 1
			rt_log( "nmg_fix_normals: no OT_SAME use of top face\n" );
d3537 2
a3538 2
			rt_log( "\tnmg_fix_normals: top face is x%x in %d direction, OT_SAME use is x%x\n", f_top, dir, fu );
			rt_log( "\toutward normal = ( %g %g %g )\n" , V3ARGS( normal ) );
d3546 1
a3546 1
				rt_log( "nmg_fix_normals: reversing fu x%x\n" , fu );
d3577 1
a3577 1
			rt_log( "nmg_fix_normals: After propagation top faceuse normal is ( %g %g %g )\n",
d3585 1
a3585 1
		for( RT_LIST_FOR( fu , faceuse , &s->fu_hd ) )
d3617 1
a3617 1
struct rt_tol *tol;
d3625 1
a3625 1
		rt_log( "nmg_break_long_edges( s = x%x )\n" , s );
d3628 1
a3628 1
	RT_CK_TOL( tol );
d3631 1
a3631 1
	for( RT_LIST_FOR( fu , faceuse , &s->fu_hd ) )
d3635 1
a3635 1
		for( RT_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
d3640 1
a3640 1
			if( RT_LIST_FIRST_MAGIC(&lu->down_hd) != NMG_EDGEUSE_MAGIC )
d3643 1
a3643 1
			for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
d3650 1
a3650 1
				for( RT_LIST_FOR( vu , vertexuse , &eu->vu_p->v_p->vu_hd ) )
d3674 1
a3674 1
					if( rt_3pts_collinear( eu->vu_p->v_p->vg_p->coord ,
d3689 1
a3689 1
								rt_log( "Breaking edge from ( %f %f %f ) to ( %f %f %f ) at ( %f %f %f )\n",
d3699 2
a3700 2
							rt_log( "Not splitting collinear edges x%x and x%x:\n", eu , eu1 );
							rt_log( "\t( %f %f %f ) -> ( %f %f %f )\n",
d3703 1
a3703 1
							rt_log( "\t( %f %f %f ) -> ( %f %f %f )\n",
d3734 1
a3734 1
		rt_log( "nmg_mk_new_face_from_loop( lu = x%x )\n" , lu );
d3740 1
a3740 1
		rt_log( "nmg_mk_new_face_from_loop: loopuse is not in a faceuse\n" );
d3751 1
a3751 1
	for( RT_LIST_FOR( lu1 , loopuse , &fu->lu_hd ) )
d3760 1
a3760 1
		rt_log( "nmg_mk_new_face_from_loop: cannot remove only exterior loop from faceuse\n" );
d3767 1
a3767 1
	RT_LIST_DEQUEUE( &lu->l );
d3770 1
a3770 1
	RT_LIST_DEQUEUE( &lu_mate->l );
d3776 2
a3777 2
	RT_LIST_INSERT( &s->lu_hd , &lu_mate->l );
	RT_LIST_INSERT( &s->lu_hd , &lu->l );
d3791 1
a3791 1
	struct rt_tol	*tol;
d3804 1
a3804 1
	struct rt_tol *tol;
d3821 1
a3821 1
	for( RT_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
d3825 1
a3825 1
		if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d3834 1
a3834 1
			rt_log( "nmg_split_loops_into_faces: facuse (x%x) with %s loopuse (x%x)\n",
d3846 1
a3846 1
		struct nmg_ptbl inside_loops;
d3848 1
a3848 1
		nmg_tbl( &inside_loops , TBL_INIT , (long *)NULL );
d3850 2
a3851 2
		lu = RT_LIST_FIRST( loopuse , &fu->lu_hd );
		while( RT_LIST_NOT_HEAD( lu , &fu->lu_hd ) )
d3859 1
a3859 1
			lu_next = RT_LIST_PNEXT( loopuse , &lu->l );
d3864 1
a3864 1
				nmg_tbl( &inside_loops , TBL_FREE , (long *)NULL );
d3875 1
a3875 1
			for( RT_LIST_FOR( lu1 , loopuse , &fu->lu_hd ) )
d3897 1
a3897 1
				for( RT_LIST_FOR( lu2 , loopuse , &fu->lu_hd ) )
d3921 1
a3921 1
					nmg_tbl( &inside_loops , TBL_INS , (long *)lu1 );
d3929 1
a3929 1
			for( index=0 ; index<NMG_TBL_END( &inside_loops ) ; index++ )
d3931 1
a3931 1
				lu1 = (struct loopuse *)NMG_TBL_GET( &inside_loops , index );
d3936 1
a3936 1
			nmg_tbl( &inside_loops , TBL_RST , (long *)NULL );
d3940 1
a3940 1
		nmg_tbl( &inside_loops , TBL_FREE , (long *)NULL );
d3948 2
a3949 2
		lu = RT_LIST_FIRST( loopuse , &fu->lu_hd );
		while( RT_LIST_NOT_HEAD( lu , &fu->lu_hd ) )
d3953 1
a3953 1
			next_lu = RT_LIST_PNEXT( loopuse , &lu->l );
d3980 1
a3980 1
		rt_log( "nmg_split_loops_into_faces: fu (x%x) has only OT_OPPOSITE loopuses, ignored\n" , fu );
d3994 1
a3994 1
struct rt_tol	*tol;
d4002 1
a4002 1
		rt_log( "nmg_split_loops_into_faces( magic_p = x%x )\n" , magic_p );
d4004 1
a4004 1
	RT_CK_TOL( tol );
d4009 1
a4009 1
	RT_CK_TOL( tol );
d4041 1
a4041 1
struct rt_tol *tol;
d4055 2
a4056 2
	struct nmg_ptbl stack;
	struct nmg_ptbl shared_edges;
d4060 1
a4060 1
		rt_log( "nmg_decompose_shell( s = x%x ) START\n" , s );
d4064 1
a4064 1
	RT_CK_TOL( tol );
d4075 2
a4076 2
	nmg_tbl( &stack , TBL_INIT , (long *)NULL );
	nmg_tbl( &shared_edges , TBL_INIT , (long *)NULL );
d4079 1
a4079 1
	fu = RT_LIST_FIRST( faceuse , &s->fu_hd );
d4087 1
a4087 1
	for( RT_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
d4090 1
a4090 1
		if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )	
d4093 1
a4093 1
		for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
d4097 1
a4097 1
				nmg_tbl( &shared_edges , TBL_INS_UNIQUE , (long *)eu );
d4099 1
a4099 1
				nmg_tbl( &stack , TBL_INS_UNIQUE , (long *)eu );
d4133 1
a4133 1
                        for( RT_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
d4137 1
a4137 1
                                if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d4140 1
a4140 1
                                for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
d4144 1
a4144 1
						nmg_tbl( &shared_edges , TBL_INS_UNIQUE , (long *)eu );
d4146 1
a4146 1
						nmg_tbl( &stack , TBL_INS_UNIQUE , (long *)eu );
d4157 1
a4157 1
	for( RT_LIST_FOR( fu , faceuse , &s->fu_hd ) )
d4173 2
a4174 2
		nmg_tbl( &stack , TBL_FREE , (long *)NULL );
		nmg_tbl( &shared_edges , TBL_FREE , (long *)NULL );
d4184 1
a4184 1
		nmg_tbl( &stack , TBL_RST , (long *)NULL );
d4189 1
a4189 1
		for( i=0 ; i<NMG_TBL_END( &shared_edges ) ; i++ )
d4205 1
a4205 1
			eu = (struct edgeuse *)NMG_TBL_GET( &shared_edges , i );
d4244 1
a4244 1
				nmg_tbl( &shared_edges , TBL_RM , (long *)eu );
d4256 1
a4256 1
			for( i=0 ; i<NMG_TBL_END( &shared_edges ) ; i++ )
d4261 1
a4261 1
				eu = (struct edgeuse *)NMG_TBL_GET( &shared_edges , i );
d4355 1
a4355 1
                        for( RT_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
d4359 1
a4359 1
                                if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d4362 1
a4362 1
                                for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
d4366 1
a4366 1
						nmg_tbl( &shared_edges , TBL_INS_UNIQUE , (long *)eu );
d4368 1
a4368 1
						nmg_tbl( &stack , TBL_INS_UNIQUE , (long *)eu );
d4403 1
a4403 1
	                        for( RT_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
d4406 1
a4406 1
	                                if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d4408 1
a4408 1
	                                for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
d4412 1
a4412 1
							nmg_tbl( &shared_edges , TBL_INS_UNIQUE , (long *)eu );
d4414 1
a4414 1
							nmg_tbl( &stack , TBL_INS_UNIQUE , (long *)eu );
d4427 1
a4427 1
		for( RT_LIST_FOR( fu , faceuse , &s->fu_hd ) )
d4449 2
a4450 2
		fu = RT_LIST_FIRST( faceuse , &s->fu_hd );
		while( RT_LIST_NOT_HEAD( fu , &s->fu_hd ) )
d4454 3
a4456 3
			next_fu = RT_LIST_NEXT( faceuse , &fu->l );
			while( RT_LIST_NOT_HEAD( next_fu , &s->fu_hd ) && next_fu->orientation != OT_SAME )
				next_fu = RT_LIST_NEXT( faceuse , &next_fu->l );
d4473 2
a4474 2
	nmg_tbl( &stack , TBL_FREE , (long *)NULL );
	nmg_tbl( &shared_edges , TBL_FREE , (long *)NULL );
d4477 1
a4477 1
		rt_log( "nmg_decompose_shell END (%d shells)\n" , no_of_shells );
d4495 1
a4495 1
	struct rt_external	ext;
d4499 1
a4499 1
	rt_log("nmg_stash_model_to_file('%s', x%x, %s)\n", filename, m, title);
d4512 1
a4512 1
	RT_INIT_EXTERNAL( &ext );
d4516 1
a4516 1
		rt_log("nmg_stash_model_to_file: solid export failure\n");
d4530 1
a4530 1
	rt_log("nmg_stash_model_to_file(): wrote '%s' in %d bytes\n", filename, ext.ext_nbytes);
d4583 1
a4583 1
		rt_log( "nmg_unbreak_handler: no geomtry for edge x%x\n" , e );
d4591 1
a4591 1
		/* rt_log("nmg_unbreak_handler: usage < 4\n"); */
d4596 1
a4596 1
	eu2 = RT_LIST_PNEXT_CIRC( edgeuse , eu1 );
d4604 1
a4604 1
		/* rt_log("nmg_unbreak_handler: eu1 edge geom not shared with eu2\n"); */
d4643 1
a4643 1
		rt_log( "nmg_unbreak_region_edges( magic_p = x%x )\n" , magic_p );
d4695 1
a4695 1
CONST struct rt_tol *tol;
d4704 1
a4704 1
		rt_log( "rt_dist_pt3_line3( a=( %f %f %f ), dir=( %f %f %f ), p=( %f %f %f )\n" ,
d4707 1
a4707 1
	RT_CK_TOL(tol);
d4760 1
a4760 1
		rt_log( "nmg_mv_shell_to_region( s=x%x , r=x%x )\n" , s , r );
d4767 1
a4767 1
		rt_log( "nmg_mv_shell_to_region: Attempt to move shell to region it is already in\n" );
d4774 2
a4775 2
	RT_LIST_DEQUEUE( &s->l );
	if( RT_LIST_IS_EMPTY( &s->r_p->s_hd ) )
d4780 1
a4780 1
	RT_LIST_APPEND( &r->s_hd , &s->l );
d4790 1
a4790 1
 *	Put them in a nmg_ptbl "faces"
d4801 1
a4801 1
struct nmg_ptbl *faces;
d4803 1
a4803 1
CONST struct rt_tol *tol;
d4812 1
a4812 1
		rt_log( "nmg_find_isect_faces( new_v=x%x , faces=x%x )\n" , new_v , faces );
d4815 2
a4816 2
	RT_CK_TOL( tol );
	NMG_CK_PTBL( faces );
d4819 1
a4819 1
	for( RT_LIST_FOR( vu , vertexuse , &new_v->vu_hd ) )
d4831 1
a4831 1
		for( i=0 ; i<NMG_TBL_END( faces ) ; i++ )
d4835 2
a4836 2
			fp = (struct face *)NMG_TBL_GET( faces , i );
			if( fp->g.plane_p == fg || rt_coplanar( fg->N , fp->g.plane_p->N , tol ) > 0 )
d4848 1
a4848 1
			nmg_tbl( faces , TBL_INS , (long *)fu->f_p );
d4859 1
a4859 1
				eu1 = RT_LIST_PLAST_CIRC( edgeuse , eu1 );
d4865 1
a4865 1
	return( NMG_TBL_END( faces ) );
d4883 2
a4884 2
CONST struct nmg_ptbl *faces;
struct rt_tol *tol;
d4896 1
a4896 1
		rt_log( "nmg_simple_vertex_solve( new_v=x%x , %d faces )\n" , new_v , NMG_TBL_END( faces ));
d4898 1
a4898 1
		for( i=0 ; i<NMG_TBL_END( faces ) ; i++ )
d4900 1
a4900 1
			f = (struct face *)NMG_TBL_GET( faces, i );
d4905 1
a4905 1
				rt_log( "\tface (x%x) has no OT_SAME use\n", f );
d4907 1
a4907 1
			rt_log( "\t#%d: %g %g %g %g\n", i, V4ARGS( pl ) );
d4912 2
a4913 2
	NMG_CK_PTBL( faces );
	RT_CK_TOL( tol );
d4918 1
a4918 1
	switch( NMG_TBL_END( faces ) )
d4926 1
a4926 1
			rt_log( "nmg_simple_vertex_solve: vertex not in any face planes!!!\n" );
d4931 1
a4931 1
			fp1 = (struct face *)NMG_TBL_GET( faces , 0 );
d4937 2
a4938 2
			fp1 = (struct face *)NMG_TBL_GET( faces , 0 );
			fp2 = (struct face *)NMG_TBL_GET( faces , 1 );
d4960 1
a4960 1
				if( rt_mkpoint_3planes( vg->coord , fp1->g.plane_p->N , fp2->g.plane_p->N , pl1 ) )
d4962 2
a4963 2
					rt_log( "nmg_simple_vertex_solve: Cannot find new coords for two planes\n" );
					rt_log( "\tplanes are ( %f %f %f %f ) and ( %f %f %f %f )\n",
d4966 1
a4966 1
					rt_log( "\tcalculated third plane is ( %f %f %f %f )\n" , V4ARGS( pl1 ) );
d4974 9
a4982 9
			fp1 = (struct face *)NMG_TBL_GET( faces , 0 );
			fp2 = (struct face *)NMG_TBL_GET( faces , 1 );
			fp3 = (struct face *)NMG_TBL_GET( faces , 2 );
			if( rt_mkpoint_3planes( vg->coord , fp1->g.plane_p->N , fp2->g.plane_p->N , fp3->g.plane_p->N ) )
			{
				rt_log( "nmg_simple_vertex_solve: failed for 3 planes:\n" );
				rt_log( "\t( %f %f %f %f )\n" , V4ARGS( fp1->g.plane_p->N ) );
				rt_log( "\t( %f %f %f %f )\n" , V4ARGS( fp2->g.plane_p->N ) );
				rt_log( "\t( %f %f %f %f )\n" , V4ARGS( fp3->g.plane_p->N ) );
d4989 1
a4989 1
			rt_log( "nmg_simple_vertex_solve: Called for a complex vertex\n" );
d4994 1
a4994 1
		rt_log( "nmg_simple_vertex_solve: Failed to determine new coordinates for vertex at ( %f %f %f )\n",
d4997 1
a4997 1
		rt_log( "nmg_simple_vertex_solve: new coords = ( %f %f %f )\n",
d5015 1
a5015 1
CONST struct rt_tol *tol;
d5022 1
a5022 1
	RT_CK_TOL( tol );
d5026 1
a5026 1
	for( RT_LIST_FOR( vu , vertexuse , &v->vu_hd ) )
d5047 1
a5047 1
			rt_log( "nmg_ck_vert_on_fus: v=x%x vu=x%x ( %f %f %f ) is %g from\n\tfaceuse x%x f x%x\n" , v , vu , V3ARGS( v->vg_p->coord ) , dist , fu , fu->f_p );
d5052 1
a5052 1
		rt_log( "nmg_ck_vert_on_fus: v=x%x ( %f %f %f ) max distance of %g from faceuses\n" , v , V3ARGS( v->vg_p->coord ) , max_dist );
d5081 1
a5081 1
CONST struct nmg_ptbl *int_faces;
d5084 1
a5084 1
	struct rt_tol tol;
d5087 1
a5087 1
	NMG_CK_PTBL( int_faces );
d5089 1
a5089 1
	tol.magic = RT_TOL_MAGIC;
d5095 2
a5096 2
	rt_log( "\nint_faces at vertex x%x ( %f %f %f )\n" , new_v , V3ARGS( new_v->vg_p->coord ) );
	for( i=0 ; i<NMG_TBL_END( int_faces ) ; i++ )
d5102 1
a5102 1
		i_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , i );
d5104 1
a5104 1
		rt_log( "edge number %d, x%x\n" , i , i_fus );
d5118 1
a5118 1
			rt_log( "\tfu1 = x%x (face=x%x), fu2 = x%x (face=x%x) ( %f %f %f %f )\n" , i_fus->fu[0] , fp1 , i_fus->fu[1] , fp2 , V4ARGS( pl ) );
d5120 1
a5120 1
			rt_log( "\tfu1 = x%x (face=x%x), fu2 = x%x (face=x%x)\n" , i_fus->fu[0] , fp1 , i_fus->fu[1] , fp2 );
d5123 1
a5123 1
			rt_log( "\teu = NULL\n" );
d5125 1
a5125 1
			rt_log( "\teu = x%x , vu_p = NULL\n" , i_fus->eu );
d5130 1
a5130 1
			rt_log( "\teu = x%x, from x%x ( %f %f %f ) to x%x ( %f %f %f )\n" , i_fus->eu,
d5137 1
a5137 1
					rt_log( "****ERROR**** eu is not in fu1 it's in x%x\n" , fu );
d5143 1
a5143 1
					rt_log( "****ERROR**** eu is not in fu2, it's in x%x\n" , fu );
d5147 1
a5147 1
			if( !rt_pt3_pt3_equal( i_fus->eu->vu_p->v_p->vg_p->coord, i_fus->eu->eumate_p->vu_p->v_p, &tol ) )
d5152 3
a5154 3
		rt_log( "\tstart = ( %f %f %f ) , dir = ( %f %f %f )\n" , V3ARGS( i_fus->start ) , V3ARGS( i_fus->dir ) );
		rt_log( "\tpt = ( %f %f %f )\n" , V3ARGS( i_fus->pt ) );
		rt_log( "\tfree_edge = %d\n" , i_fus->free_edge );
d5159 1
a5159 1
				rt_log( "****ERROR**** this is NOT a free edge\n" );
d5162 1
a5162 1
				rt_log( "****ERROR**** This is a free edge\n" );
d5165 1
a5165 1
			rt_log( "\tvp = x%x ( %f %f %f )\n" , i_fus->vp , V3ARGS( i_fus->vp->vg_p->coord ) );
d5167 1
a5167 1
			rt_log( "\tvp = NULL\n" );
d5184 2
a5185 2
struct nmg_ptbl *int_faces;
CONST struct rt_tol *tol;
d5193 1
a5193 1
	struct rt_tol tol_tmp;
d5200 2
a5201 2
	RT_CK_TOL( tol );
	NMG_CK_PTBL( int_faces );
d5204 1
a5204 1
		rt_log( "nmg_get_edge_lines( new_v=x%x , int_faces=x%x )\n" , new_v , int_faces );
d5207 1
a5207 1
	tol_tmp.magic = RT_TOL_MAGIC;
d5215 1
a5215 1
	r = RT_LIST_FIRST( nmgregion , &m->r_hd );
d5221 1
a5221 1
	for( RT_LIST_FOR( vu , vertexuse , &new_v->vu_hd ) )
d5249 1
a5249 1
			eu1 = RT_LIST_PNEXT_CIRC( edgeuse , &eu->l );
d5257 1
a5257 1
			nmg_tbl( int_faces , TBL_INS , (long *)i_fus );
d5268 1
a5268 1
		for( RT_LIST_FOR( vu , vertexuse , &new_v->vu_hd ) )
d5287 1
a5287 1
			rt_log( "Cannot find edgeuse in OT_SAME faceuse starting at ( %f %f %f )\n",
d5314 2
a5315 2
			rt_log( "nmg_get_edge_lines: Bad solid!!!\n" );
			for( edge_no=0 ; edge_no<NMG_TBL_END( int_faces ) ; edge_no++ )
d5319 1
a5319 1
				i_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , edge_no );
d5360 1
a5360 1
			if( ret_val=rt_isect_2planes( start , dir , fu1->f_p->g.plane_p->N , fu2->f_p->g.plane_p->N , new_v->vg_p->coord , &tol_tmp ) )
d5363 3
a5365 3
				rt_log( "nmg_inside_vert: Cannot find new edge between two planes\n" );
				rt_log( "return from rt_isect_2planes is %d\n" , ret_val );
				rt_log( "\tplanes are ( %f %f %f %f ) and ( %f %f %f %f )\n" ,
d5368 1
a5368 1
				rt_log( "\tfus x%x and x%x, faces x%x and x%x\n" ,
d5401 1
a5401 1
		nmg_tbl( int_faces , TBL_INS , (long *)i_fus );
d5407 1
a5407 1
			eu = RT_LIST_PNEXT_CIRC( edgeuse , eu );
d5414 1
a5414 1
		rt_log( "After getting edge lines:\n" );
d5430 3
a5432 3
struct nmg_ptbl *int_faces;
CONST struct nmg_ptbl *faces;
CONST struct rt_tol *tol;
d5439 1
a5439 1
		rt_log( "nmg_get_max_edge_inters( new_v = x%x , %d intersect_fus structs , %d faces )\n" , new_v , NMG_TBL_END( int_faces ) , NMG_TBL_END( faces ) );
d5442 2
a5443 2
	RT_CK_TOL( tol );
	NMG_CK_PTBL( int_faces );
d5447 1
a5447 1
	r = RT_LIST_FIRST( nmgregion , &m->r_hd );
d5452 1
a5452 1
	for( edge_no=0 ; edge_no<NMG_TBL_END( int_faces ) ; edge_no++ )
d5459 1
a5459 1
		edge_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , edge_no );
d5473 1
a5473 1
		if( next_edge_no == NMG_TBL_END( int_faces ) )
d5476 1
a5476 1
		other_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , next_edge_no );
d5482 1
a5482 1
			if( next_edge_no == NMG_TBL_END( int_faces ) )
d5485 1
a5485 1
			other_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , next_edge_no );
d5495 1
a5495 1
					rt_log( "Edge #%d intersects edge #%d at dist = %f\n" , edge_no , next_edge_no , dist[0] );
d5506 1
a5506 1
			prev_edge_no = NMG_TBL_END( int_faces ) - 1;
d5508 1
a5508 1
		other_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , prev_edge_no );
d5514 1
a5514 1
				prev_edge_no = NMG_TBL_END( int_faces ) - 1;
d5516 1
a5516 1
			other_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , prev_edge_no );
d5524 1
a5524 1
					rt_log( "Edge #%d intersects edge #%d at dist = %f\n" , edge_no , prev_edge_no , dist[0] );
d5535 1
a5535 1
			for( other_index=0 ; other_index<NMG_TBL_END( int_faces ) ; other_index ++ )
d5542 1
a5542 1
				other_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , other_index );
d5560 1
a5560 1
				if( rt_isect_line3_plane( &dist[0] , edge_fus->start , edge_fus->dir , f->g.plane_p->N , tol ) > 1 )
d5564 1
a5564 1
					rt_log( "Edge #%d intersects fu[0] from edge #%d at dist = %f\n" , edge_no , other_index , dist[0] );
d5583 1
a5583 1
	for( edge_no=0 ; edge_no < NMG_TBL_END( int_faces ) ; edge_no++ )
d5587 1
a5587 1
		edge_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , edge_no );
d5594 1
a5594 1
		rt_log( "After nmg_get_max_edge_inters:\n" );
d5612 2
a5613 2
struct nmg_ptbl *int_faces;
CONST struct rt_tol *tol;
d5618 2
a5619 2
	NMG_CK_PTBL( int_faces );
	RT_CK_TOL( tol );
d5622 1
a5622 1
		rt_log( "nmg_fuse_inters: i_fus=x%x, j_fus=x%x, %d edges\n" , i_fus, j_fus, NMG_TBL_END( int_faces ) );
d5628 1
a5628 1
	prev_eu = RT_LIST_PPREV_CIRC( edgeuse , &j_fus->eu->l );
d5636 1
a5636 1
		rt_log( "nmg_fuse_inter_verts: ERROR: can't find adjacent edges to kill\n" );
d5648 2
a5649 2
			rt_log( "radial join of eu's x%x and x%x\n" , i_fus->eu , radial_eu );
			rt_log( "\tx%x to x%x and x%x to x%x\n" ,
d5667 1
a5667 1
	nmg_tbl( int_faces , TBL_RM , (long *)j_fus );
d5683 2
a5684 2
struct nmg_ptbl *int_faces;
CONST struct rt_tol *tol;
d5689 1
a5689 1
		rt_log( "nmg_split_edges_at_pts( new_v = x%x , %d intersect_fus structs)\n" , new_v , NMG_TBL_END( int_faces ) );
d5691 2
a5692 2
	RT_CK_TOL( tol );
	NMG_CK_PTBL( int_faces );
d5696 1
a5696 1
	for( edge_no=0 ; edge_no < NMG_TBL_END( int_faces ) ; edge_no++ )
d5701 1
a5701 1
		i_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , edge_no );
d5707 1
a5707 1
		if( rt_pt3_pt3_equal( new_v->vg_p->coord , i_fus->pt , tol ) )
d5730 1
a5730 1
		rt_log( "After splitting edges:\n" );
d5736 1
a5736 1
	while( edge_no < NMG_TBL_END( int_faces ) )
d5742 1
a5742 1
		if( next_edge_no == NMG_TBL_END( int_faces ) )
d5745 2
a5746 2
		i_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , edge_no );
		j_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , next_edge_no );
d5771 1
a5771 1
			if( next_edge_no == NMG_TBL_END( int_faces ) )
d5774 1
a5774 1
			j_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , next_edge_no );
d5781 1
a5781 1
		rt_log( "After loops of same face\n" );
d5794 2
a5795 2
struct nmg_ptbl *int_faces;
CONST struct rt_tol *tol;
d5801 2
a5802 2
	NMG_CK_PTBL( int_faces );
	RT_CK_TOL( tol );
d5805 1
a5805 1
		rt_log( "nmg_remove_short_eus: new_v=x%x ( %f %f %f ), %d edges\n" , new_v, V3ARGS( new_v->vg_p->coord ), NMG_TBL_END( int_faces ) );
d5810 1
a5810 1
	for( edge_no=0 ; edge_no<NMG_TBL_END( int_faces ) ; edge_no++ )
d5814 1
a5814 1
		edge_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , edge_no );
d5819 1
a5819 1
		if( !rt_pt3_pt3_equal( new_v->vg_p->coord , edge_fus->vp->vg_p->coord , tol ) )
d5827 2
a5828 2
	vu = RT_LIST_FIRST( vertexuse , &new_v->vu_hd );
	while( RT_LIST_NOT_HEAD( vu , &new_v->vu_hd ) )
d5838 1
a5838 1
		vu_next = RT_LIST_PNEXT( vertexuse , &vu->l );
d5850 2
a5851 2
		lu = RT_LIST_FIRST( loopuse , &fu->lu_hd );
		while( RT_LIST_NOT_HEAD( lu , &fu->lu_hd ) )
d5858 1
a5858 1
			lu_next = RT_LIST_PNEXT( loopuse , &lu->l );
d5860 2
a5861 2
			eu = RT_LIST_FIRST( edgeuse , &lu->down_hd );
			while( RT_LIST_NOT_HEAD( eu , &lu->down_hd ) )
d5867 1
a5867 1
				eu_next = RT_LIST_PNEXT( edgeuse , &eu->l );
d5873 2
a5874 2
						RT_LIST_NOT_HEAD( vu_next , &new_v->vu_hd ) )
							vu_next = RT_LIST_PNEXT( vertexuse , &vu_next->l );
d5876 2
a5877 2
						RT_LIST_NOT_HEAD( eu_next , &lu->down_hd ) )
							eu_next = RT_LIST_PNEXT( edgeuse , &eu_next->l );
d5880 1
a5880 1
						rt_log( "\tkilling eu x%x (x%x)\n" , eu , eu->eumate_p );
d5885 1
a5885 1
				else if( rt_pt3_pt3_equal( eu->vu_p->v_p->vg_p->coord , eu->eumate_p->vu_p->v_p->vg_p->coord , tol ) )
d5889 1
a5889 1
					prev_eu = RT_LIST_PPREV_CIRC( edgeuse , &eu->l );
d5895 2
a5896 2
						RT_LIST_NOT_HEAD( vu_next , &new_v->vu_hd ) )
							vu_next = RT_LIST_PNEXT( vertexuse , &vu_next->l );
d5898 2
a5899 2
						RT_LIST_NOT_HEAD( eu_next , &lu->down_hd ) )
							eu_next = RT_LIST_PNEXT( edgeuse , &eu_next->l );
d5902 1
a5902 1
						rt_log( "\tkilling eu x%x (x%x)\n" , eu , eu->eumate_p );
d5911 2
a5912 2
						RT_LIST_NOT_HEAD( lu_next , &fu->lu_hd ) )
							lu_next = RT_LIST_PNEXT( loopuse , &lu_next->l );
d5929 1
a5929 1
					rt_log( "nmg_remove_short_eus_inter: nmg_kfu emptied shell!!!\n" );
d5948 2
a5949 2
struct nmg_ptbl *int_faces;
CONST struct rt_tol *tol;
d5955 1
a5955 1
		rt_log( "nmg_simplify_inter( new_v=x%x ( %f %f %f ), int_faces=x%x)\n",
d5959 2
a5960 2
	NMG_CK_PTBL( int_faces );
	RT_CK_TOL( tol );
d5962 1
a5962 1
	while( NMG_TBL_END( int_faces ) > 1 && edge_no < NMG_TBL_END( int_faces ) )
d5968 1
a5968 1
		i_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , edge_no );
d5970 1
a5970 1
		if( next_edge_no == NMG_TBL_END( int_faces ) )
d5972 1
a5972 1
		j_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , next_edge_no );
d6016 1
a6016 1
		else if( rt_pt3_pt3_equal( i_fus->vp->vg_p->coord , j_fus->vp->vg_p->coord , tol ) )
d6022 1
a6022 1
		else if( rt_3pts_collinear( i_fus->vp->vg_p->coord , j_fus->vp->vg_p->coord , new_v->vg_p->coord , tol ) )
d6048 1
a6048 1
				rt_log( "\tCollinear vertices x%x, x%x, and x%x\n",
d6058 1
a6058 1
					rt_log( "\tSplitting i_fus->eu x%x at vertex x%x\n" , i_fus->eu , j_fus->vp );
d6073 1
a6073 1
					rt_log( "\tSplitting j_fus->eu x%x at vertex x%x\n" , j_fus->eu , i_fus->vp );
d6084 1
a6084 1
		rt_log( "\nAfter nmg_simplify_inter:\n" );
d6101 2
a6102 2
struct nmg_ptbl *int_faces;
CONST struct rt_tol *tol;
d6108 1
a6108 1
		rt_log( "nmg_make_faces_at_vert( x%x , %d intersect_fus structs)\n" , new_v , NMG_TBL_END( int_faces ) );
d6111 2
a6112 2
	NMG_CK_PTBL( int_faces );
	RT_CK_TOL( tol );
d6114 1
a6114 1
	if( NMG_TBL_END( int_faces ) == 1 )
d6121 1
a6121 1
		i_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , 0 );
d6124 1
a6124 1
			i_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , 0 );
d6132 1
a6132 1
	if( NMG_TBL_END( int_faces ) == 2 )
d6140 2
a6141 2
		i_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , 0 );
		j_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , 1 );
d6157 1
a6157 1
	while( edge_no < NMG_TBL_END( int_faces ) )
d6169 1
a6169 1
		i_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , edge_no );
d6171 1
a6171 1
		if( next_edge_no == NMG_TBL_END( int_faces ) )
d6173 1
a6173 1
		j_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , next_edge_no );
d6209 1
a6209 1
		if( rt_3pts_collinear( i_fus->vp->vg_p->coord , j_fus->vp->vg_p->coord , new_v->vg_p->coord , tol ) )
d6221 1
a6221 1
		for( RT_LIST_FOR( eu , edgeuse , &old_lu->down_hd ) )
d6231 2
a6232 2
			rt_log( "nmg_make_faces_at_vert: ERROR: Can't find loop containing vertices x%x and x%x\n" , i_fus->vp, j_fus->vp );
			rt_log( "\t( %f %f %f ) and ( %f %f %f )\n" , V3ARGS( i_fus->vp->vg_p->coord ) , V3ARGS( j_fus->vp->vg_p->coord ) );
d6271 1
a6271 1
		for( RT_LIST_FOR( eu , edgeuse , &old_lu->down_hd ) )
d6283 1
a6283 1
			for( RT_LIST_FOR( eu , edgeuse , &new_lu->down_hd ) )
d6296 4
a6299 4
			rt_log( "nmg_make_faces_at_vert: can't find loop for new face\n" );
			rt_log( "vu1 = x%x (x%x) vu2 = x%x (x%x)\n" , vu1 , vu1->v_p , vu2 , vu2->v_p );
			rt_log( "new_v = x%x\n" , new_v );
			rt_log( "old_lu = x%x , new_lu = x%x\n" , old_lu , new_lu );
d6316 3
a6318 3
			rt_log( "nmg_make_faces_at_vert: Failed to calculate plane eqn for face:\n " );
			rt_log( "\tnew_v is x%x at ( %f %f %f )\n" , new_v , V3ARGS( new_v->vg_p->coord ) );
			if( rt_3pts_collinear( new_v->vg_p->coord,
d6321 1
a6321 1
				rt_log( "\tPoints are collinear\n" );
d6340 1
a6340 1
	struct nmg_ptbl fus_at_vert;
d6346 1
a6346 1
		rt_log( "nmg_kill_cracks_at_vertex( vp=x%x )\n" , vp );
d6351 1
a6351 1
	nmg_tbl( &fus_at_vert , TBL_INIT , (long *)NULL );
d6353 1
a6353 1
	for( RT_LIST_FOR( vu , vertexuse , &vp->vu_hd ) )
d6362 1
a6362 1
		nmg_tbl( &fus_at_vert , TBL_INS_UNIQUE , (long *)fu );
d6366 1
a6366 1
	for( fu_no=0 ; fu_no<NMG_TBL_END( &fus_at_vert ) ; fu_no++ )
d6371 1
a6371 1
		fu = (struct faceuse *)NMG_TBL_GET( &fus_at_vert , fu_no );
d6374 2
a6375 2
		lu = RT_LIST_FIRST( loopuse , &fu->lu_hd );
		while( RT_LIST_NOT_HEAD( lu , &fu->lu_hd ) )
d6383 1
a6383 1
			lu_next = RT_LIST_NEXT( loopuse , &lu->l );
d6385 1
a6385 1
			if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d6391 2
a6392 2
			eu = RT_LIST_FIRST( edgeuse , &lu->down_hd );
			while( RT_LIST_NOT_HEAD( eu , &lu->down_hd ) )
d6399 2
a6400 2
				eu_next = RT_LIST_NEXT( edgeuse , &eu->l );
				eu_prev = RT_LIST_PPREV_CIRC( edgeuse , &eu->l );
d6410 1
a6410 1
						rt_log( "ERROR: nmg_kill_cracks_at_vert: bad loopuse x%x\n" , lu );
d6435 1
a6435 1
				rt_log( "ERROR:nmg_kill_cracks_at_vert: bad shell!!!\n" );
d6438 1
a6438 1
	nmg_tbl( &fus_at_vert , TBL_FREE , (long *)NULL );
d6455 1
a6455 1
CONST struct rt_tol *tol;
d6465 1
a6465 1
	RT_CK_TOL( tol );
d6472 1
a6472 1
		i_next_eu = RT_LIST_PPREV_CIRC( edgeuse , &i_fus->eu->l );
d6474 1
a6474 1
		i_next_eu = RT_LIST_PNEXT_CIRC( edgeuse , &i_fus->eu->l );
d6477 1
a6477 1
		j_next_eu = RT_LIST_PPREV_CIRC( edgeuse , &j_fus->eu->l );
d6479 1
a6479 1
		j_next_eu = RT_LIST_PNEXT_CIRC( edgeuse , &j_fus->eu->l );
d6512 1
a6512 1
	/* calculate direction vectors for use by rt_isect_lseg3_lseg3 */
d6518 3
a6520 3
		rt_log( "nmg_dist_to_cross: checking edges x%x and x%x:\n" , i_fus , j_fus );
		rt_log( "\t( %f %f %f ) <-> ( %f %f %f )\n", V3ARGS( i_start->vg_p->coord ), V3ARGS( i_end_pt ) );
		rt_log( "\t( %f %f %f ) <-> ( %f %f %f )\n", V3ARGS( j_start->vg_p->coord ), V3ARGS( j_end_pt ) );
d6530 1
a6530 1
			rt_log( "\tBoth are free edges\n" );
d6543 2
a6544 2
				rt_log( "max_dists = %f , %f\n" , max_dist0,max_dist1 );
				rt_log( "dist = %f , %f\n" , dist[0] , dist[1] );
d6559 1
a6559 1
					rt_log( "\t\tintersection!!\n" );
d6561 1
a6561 1
					rt_log( "\t\t\t( %f %f %f )\n" , V3ARGS( tmp_pt ) );
d6563 1
a6563 1
					rt_log( "\t\t\t( %f %f %f )\n" , V3ARGS( tmp_pt ) );
d6571 1
a6571 1
				rt_mkpoint_3planes( new_pt , pl1 , pl2 , pl3 );
d6581 1
a6581 1
				rt_log( "ret_val = %d\n" , ret_val );
d6589 1
a6589 1
		if( rt_isect_lseg3_lseg3( dist , i_start->vg_p->coord , i_dir ,
d6609 1
a6609 1
				rt_log( "\tdist=%f, new_pt=( %f %f %f )\n" , dist[0] , V3ARGS( new_pt ) );
d6644 2
a6645 2
struct nmg_ptbl *int_faces;
CONST struct rt_tol *tol;
d6650 1
a6650 1
		rt_log( "nmg_fix_crossed_loops( new_v=x%x ( %f %f %f ), %d edges)\n", new_v , V3ARGS( new_v->vg_p->coord ) , NMG_TBL_END( int_faces ) );
d6653 2
a6654 2
	NMG_CK_PTBL( int_faces );
	RT_CK_TOL( tol );
d6657 1
a6657 1
	if( NMG_TBL_END( int_faces ) > 2 )
d6659 1
a6659 1
		for( edge_no=0 ; edge_no<NMG_TBL_END( int_faces ) ; edge_no++ )
d6667 1
a6667 1
			edge_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , edge_no );
d6674 1
a6674 1
			if( next_edge_no == NMG_TBL_END( int_faces ) )
d6677 1
a6677 1
			next_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , next_edge_no );
d6688 1
a6688 1
				prev_edge_no = NMG_TBL_END( int_faces ) - 1;
d6690 1
a6690 1
			prev_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , prev_edge_no );
d6704 1
a6704 1
				rt_log( "fus=x%x, prev=x%x, next=x%x, dist1=%f, dist2=%f\n",
d6706 1
a6706 1
				rt_log( "\t( %f %f %f ), ( %f %f %f )\n" , V3ARGS( pt1 ) , V3ARGS( pt2 ) );
d6710 1
a6710 1
			if( rt_pt3_pt3_equal( pt1 , pt2 , tol ) )
d6713 1
a6713 1
					rt_log( "\tMerging all three points to pt1\n" );
d6726 1
a6726 1
					rt_log( "\tMerging edge and next to pt1, moving prev to pt2\n");
d6739 1
a6739 1
					rt_log( "\tMerging edge and prev to pt2, moving next to pt1\n" );
d6753 1
a6753 1
		rt_log( "After fixing edges that intersect two edges:\n" );
d6758 1
a6758 1
	for( edge_no=0 ; edge_no<NMG_TBL_END( int_faces ) ; edge_no++ )
d6766 1
a6766 1
		edge_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , edge_no );
d6773 1
a6773 1
		if( next_edge_no == NMG_TBL_END( int_faces ) )
d6776 1
a6776 1
		next_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , next_edge_no );
d6789 2
a6790 2
				rt_log( "edge x%x intersect next edge x%x\n" , edge_fus , next_fus );
				rt_log( "\tdist=%f, ( %f %f %f )\n" , dist , V3ARGS( pt ) );
d6813 1
a6813 1
		rt_log( "After nmg_fix_crossed_loops:\n" );
d6825 2
a6826 2
CONST struct nmg_ptbl *int_faces;
CONST struct rt_tol *tol;
d6833 2
a6834 2
	NMG_CK_PTBL( int_faces );
	RT_CK_TOL( tol );
d6837 1
a6837 1
		rt_log( "nmg_calc_new_v: (%f %f %f) , %d faces\n" , V3ARGS( new_v->vg_p->coord ) , NMG_TBL_END( int_faces ) );
d6840 1
a6840 1
	i = NMG_TBL_END( int_faces );
d6847 1
a6847 1
	for( i=0 ; i<NMG_TBL_END( int_faces ) ; i++ )
d6854 1
a6854 1
		fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , i );
d6864 1
a6864 1
			if( rt_coplanar( planes[j] , pl , tol ) > 0 )
d6883 1
a6883 1
			rt_log( "nmg_cacl_new_v: Cannot solve for new geometry at ( %f %f %f )\n",
d6902 1
a6902 1
		if( rt_mkpoint_3planes( new_v->vg_p->coord , planes[0] , planes[1] , planes[2] ) )
d6904 1
a6904 1
			rt_log( "nmg_cacl_new_v: 3 planes do not intersect at a point\n" );
d6911 1
a6911 1
		rt_log( "nmg_calc_new_v: No face planes at vertex x%x (%f %f %f)\n",
d6918 1
a6918 1
		rt_log( "\tnew_v = ( %f %f %f )\n" , V3ARGS( new_v->vg_p->coord ) );
d6922 1
a6922 1
	for( i=0 ; i<NMG_TBL_END( int_faces ) ; i++ )
d6927 1
a6927 1
		fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , i );
d6934 1
a6934 1
		rt_log( "After nmg_calc_new_v:\n" );
d6961 1
a6961 1
CONST struct nmg_ptbl *faces;
d6964 1
a6964 1
CONST struct rt_tol *tol;
d6968 1
a6968 1
	struct nmg_ptbl int_faces;
d6976 1
a6976 1
		rt_log( "nmg_complex_vertex_solve( new_v = x%x , %d faces )\n" , new_v , NMG_TBL_END( faces ) );
d6979 2
a6980 2
	NMG_CK_PTBL( faces );
	RT_CK_TOL( tol );
d6987 1
a6987 1
		plane_count = NMG_TBL_END( faces );
d6992 1
a6992 1
		for( i=0 ; i<NMG_TBL_END( faces ) ; i++ )
d6994 1
a6994 1
			fp1 = (struct face *)NMG_TBL_GET( faces , i );
d6999 1
a6999 1
				rt_log( "\t plane #%d: %g %g %g %g\n", i, V4ARGS( planes[i] ) );
d7006 1
a7006 1
			for( i=0 ; i<NMG_TBL_END( faces ); i++ )
d7011 1
a7011 1
				rt_log( "\tVDOT( #%d, new_v ) - dist = %g\n", i, dot-planes[i][3] );
d7013 1
a7013 1
				for( j=0 ; j<NMG_TBL_END( faces ) ; j++ )
d7016 1
a7016 1
					rt_log( "\tVDOT( #%d, #%d ) = %g\n",i,j, dot );
d7029 1
a7029 1
			plane_count = NMG_TBL_END( faces );
d7031 1
a7031 1
			for( RT_LIST_FOR( vu, vertexuse, &new_v->vu_hd ) )
d7058 1
a7058 1
						rt_log( "\t added plane #%d: %g %g %g %g\n", plane_count, V4ARGS( planes[plane_count] ) );
d7070 1
a7070 1
			rt_log( "nmg_complex_vertex_solve: Could not calculate new geometry at ( %f %f %f )\n",
d7078 1
a7078 1
			rt_log( "nmg_complex_vertex_solve: new coords = ( %f %f %f )\n",
d7083 1
a7083 1
	nmg_tbl( &int_faces , TBL_INIT , (long *)NULL );
d7090 1
a7090 1
		nmg_tbl( &int_faces , TBL_FREE , (long *)NULL );
d7097 1
a7097 1
		nmg_tbl( &int_faces , TBL_FREE , (long *)NULL );
d7108 1
a7108 1
		nmg_tbl( &int_faces , TBL_FREE , (long *)NULL );
d7129 1
a7129 1
	for( i=0 ; i<NMG_TBL_END( &int_faces ) ; i++ )
d7133 1
a7133 1
		i_fus = (struct intersect_fus *)NMG_TBL_GET( &int_faces , i );
d7136 1
a7136 1
	nmg_tbl( &int_faces , TBL_FREE , (long *)NULL );
d7139 1
a7139 1
		rt_log( "nmg_co,mplex_vertex_solve: new coords = ( %f %f %f )\n",
d7157 1
a7157 1
CONST struct rt_tol *tol;
d7165 1
a7165 1
	RT_CK_TOL( tol );
d7167 1
a7167 1
	for( RT_LIST_FOR( fu , faceuse , &s->fu_hd ) )
d7180 1
a7180 1
		for( RT_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
d7225 1
a7225 1
	for( RT_LIST_FOR( lu , loopuse , &fu1->lu_hd ) )
d7227 1
a7227 1
		if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d7231 1
a7231 1
		for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
d7274 1
a7274 1
CONST struct rt_tol *tol;
d7282 2
a7283 2
	struct nmg_ptbl tmp_faces[2];
	struct nmg_ptbl faces;
d7288 1
a7288 1
		rt_log( "nmg_move_edge_thru_pt( mv_eu=x%x , pt=( %f %f %f) )\n" , mv_eu , V3ARGS( pt ) );
d7291 1
a7291 1
	RT_CK_TOL( tol );
d7366 1
a7366 1
			tmp_eu = RT_LIST_PNEXT_CIRC( edgeuse , &eu->l );
d7373 1
a7373 1
			tmp_eu = RT_LIST_PPREV_CIRC( edgeuse , &eu->l );
d7388 1
a7388 1
		rt_log( "Cannot handle edges with more than two radial faces\n" );
d7392 2
a7393 2
	nmg_tbl( &tmp_faces[0] , TBL_INIT , (long *)NULL );
	nmg_tbl( &tmp_faces[1] , TBL_INIT , (long *)NULL );
d7399 3
a7401 3
		rt_log( "nmg_move_edge_thru_pt: cannot handle complex vertices yet\n" );
		nmg_tbl( &tmp_faces[0] , TBL_FREE , (long *)NULL );
		nmg_tbl( &tmp_faces[1] , TBL_FREE , (long *)NULL );
d7445 1
a7445 1
			eu_next = RT_LIST_PNEXT_CIRC( edgeuse , &eu_next->l );
d7450 1
a7450 1
				rt_log( "nmg_move_edge_thru_pt: cannot calculate new plane eqn\n" );
d7503 1
a7503 1
	nmg_tbl( &faces , TBL_INIT , (long *)NULL );
d7512 1
a7512 1
		for( RT_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
d7518 1
a7518 1
			if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) == NMG_VERTEXUSE_MAGIC )
d7521 1
a7521 1
				vu = RT_LIST_FIRST( vertexuse , &lu->down_hd );
d7524 1
a7524 1
					nmg_tbl( &faces , TBL_RST , (long *)NULL );
d7529 2
a7530 2
						rt_log( "mg_move_edge_thru_pt: Cannot handle complex vertices\n" );
						nmg_tbl( &faces , TBL_FREE , (long *)NULL );
d7538 2
a7539 2
						rt_log( "nmg_move_edge_thru_pt: Could not solve simple vertex\n" );
						nmg_tbl( &faces , TBL_FREE , (long *)NULL );
d7547 1
a7547 1
			for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
d7555 1
a7555 1
					nmg_tbl( &faces , TBL_RST , (long *)NULL );
d7560 2
a7561 2
						rt_log( "mg_move_edge_thru_pt: Cannot handle complex vertices\n" );
						nmg_tbl( &faces , TBL_FREE , (long *)NULL );
d7566 1
a7566 1
					if( NMG_TBL_END( &faces ) == 1 &&
d7588 2
a7589 2
							rt_log( "nmg_move_edge_thru_pt: Could not solve simple vertex\n" );
							nmg_tbl( &faces , TBL_FREE , (long *)NULL );
d7619 1
a7619 1
	nmg_tbl( &faces , TBL_FREE , (long *)NULL );
d7632 1
a7632 1
struct rt_list *vhead;
d7645 1
a7645 1
	vp = RT_LIST_FIRST( rt_vlist , vhead );
d7649 1
a7649 1
	for( RT_LIST_FOR( vp , rt_vlist , vhead ) )
d7693 1
a7693 1
struct nmg_ptbl *bad_verts;
d7696 1
a7696 1
struct nmg_ptbl *verts;
d7701 1
a7701 1
	NMG_CK_PTBL( bad_verts );
d7712 1
a7712 1
		rt_log( "nmg_follow_free_edges_to_vertex( vpa=x%x, vpb=x%x s=x%x, eu=x%x, found=%d )\n",
d7716 1
a7716 1
	for( RT_LIST_FOR( vu , vertexuse , &eu->eumate_p->vu_p->v_p->vu_hd ) )
d7733 1
a7733 1
			rt_log( "\tchecking eu x%x: x%x ( %f %f %f )\n\t\tto x%x ( %f %f %f )\n", eu1,
d7741 1
a7741 1
				rt_log( "\t\tnot a dangling edge\n" );
d7749 1
a7749 1
				rt_log( "\t\tback the way we came\n" );
d7757 3
a7759 3
				rt_log( "\t\tfound goal\n" );
			nmg_tbl( verts , TBL_INS , (long *)vu->v_p );
			nmg_tbl( verts , TBL_INS , (long *)vpb );
d7766 1
a7766 1
				rt_log( "\t\tback at start\n" );
d7769 1
a7769 1
		else if( nmg_tbl( bad_verts , TBL_LOC , (long *)eu1->eumate_p->vu_p->v_p ) != (-1))
d7773 1
a7773 1
				rt_log( "\t\tA bad vertex\n" );
d7776 1
a7776 1
		else if( nmg_tbl( verts , TBL_LOC , (long *)eu1->eumate_p->vu_p->v_p ) != (-1))
d7780 1
a7780 1
				rt_log( "a loop\n" );
d7786 2
a7787 2
				rt_log( "\t\tinserting vertex x%x\n" , vu->v_p );
			nmg_tbl( verts , TBL_INS , (long *)vu->v_p );
d7789 1
a7789 1
				rt_log( "\t\tCalling follow edges\n" );
d7795 2
a7796 2
					rt_log( "\t\treturn is %d\n" , *found );
					rt_log( "\t\t\tremove vertex x%x\n" , vu->v_p );
d7798 1
a7798 1
				nmg_tbl( verts , TBL_RM , (long *)vu->v_p );
d7809 1
a7809 1
static struct nmg_ptbl *
d7812 1
a7812 1
struct nmg_ptbl *bad_verts;
d7816 1
a7816 1
	static struct nmg_ptbl verts;
d7820 1
a7820 1
	NMG_CK_PTBL( bad_verts );
d7828 1
a7828 1
		rt_log( "nmg_find_path( vpa=x%x ( %f %f %f ), vpb=x%x ( %f %f %f )\n",
d7830 2
a7831 2
		rt_log( "\t%d vertices to avoid\n" , NMG_TBL_END( bad_verts ) );
		for( i=0 ; i<NMG_TBL_END( bad_verts ) ; i++ )
d7835 2
a7836 2
			vpbad = (struct vertex *)NMG_TBL_GET( bad_verts , i );
			rt_log( "\tx%x ( %f %f %f )\n" , vpbad , V3ARGS( vpbad->vg_p->coord ) );
d7840 2
a7841 2
	nmg_tbl( &verts , TBL_INIT , (long *)NULL );
	nmg_tbl( &verts , TBL_INS , (long *)vpa );
d7843 1
a7843 1
	for( RT_LIST_FOR( vua , vertexuse , &vpa->vu_hd ) )
d7860 1
a7860 1
			rt_log( "\tchecking eu x%x: x%x ( %f %f %f )\n\t\tto x%x ( %f %f %f )\n", eua,
d7867 1
a7867 1
				rt_log( "\t\tback the way we came!\n" );
d7871 1
a7871 1
		if( nmg_tbl( bad_verts , TBL_LOC , (long *)eua->eumate_p->vu_p->v_p ) != (-1) )
d7874 1
a7874 1
				rt_log( "\t\tOne of the bad vertices!!\n" );
d7881 2
a7882 2
				rt_log( "\t\tfound goal!!\n" );
			nmg_tbl( &verts , TBL_INS , (long *)vpb );
d7888 1
a7888 1
			rt_log( "\tCall follow edges\n" );
d7894 2
a7895 2
		nmg_tbl( &verts , TBL_RST , ( long *)NULL );
		nmg_tbl( &verts , TBL_INS , (long *)vpa );
d7899 1
a7899 1
		nmg_tbl( &verts , TBL_INIT , (long *)NULL );
d7908 1
a7908 1
CONST struct rt_tol *tol;
d7914 1
a7914 1
	RT_CK_TOL( tol );
d7916 1
a7916 1
	for( RT_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
d7921 1
a7921 1
		if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d7924 1
a7924 1
		for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
d7962 1
a7962 1
CONST struct rt_tol *tol;
d7969 4
a7972 4
		rt_log( "Join_eus:\n" );
		rt_log( "\tv1 = x%x ( %g %g %g )\n", v1, V3ARGS( v1->vg_p->coord ) );
		rt_log( "\tv2 = x%x ( %g %g %g )\n", v2, V3ARGS( v2->vg_p->coord ) );
		rt_log( "\tv3 = x%x ( %g %g %g )\n", v3, V3ARGS( v3->vg_p->coord ) );
d7979 1
a7979 1
			rt_log( "\tNo edge found from v1 to v2\n" );
d7991 1
a7991 1
				rt_log( "Joining eus x%x and x%x\n" , eu1, eu2 );
d8002 1
a8002 1
			rt_log( "\tNo edge found from v2 to v3\n" );
d8013 1
a8013 1
				rt_log( "Joining eus x%x and x%x\n" , eu1, eu2 );
d8025 2
a8026 2
struct nmg_ptbl *verts;
CONST struct rt_tol *tol;
d8041 1
a8041 1
		rt_log( "nmg_make_connect_faces( dst=x%x, vpa=x%x ( %f %f %f ), vpb=x%x ( %f %f %f )\n",
d8043 1
a8043 1
		for( i=0 ; i<NMG_TBL_END( verts ) ; i++ )
d8047 2
a8048 2
			v = (struct vertex *)NMG_TBL_GET( verts , i );
			rt_log( "\tx%x ( %f %f %f )\n" , v , V3ARGS( v->vg_p->coord ) );
d8055 2
a8056 2
	NMG_CK_PTBL( verts );
	RT_CK_TOL( tol );
d8058 1
a8058 1
	if( NMG_TBL_END( verts ) < 1 )
d8060 1
a8060 1
		rt_log( "nmg_make_connect_faces: no list of vertices from other shell\n" );
d8063 1
a8063 1
	if( NMG_TBL_END( verts ) == 1 )
d8067 1
a8067 1
		face_verts[2] = (struct vertex *)NMG_TBL_GET( verts , 0 );
d8074 2
a8075 2
		face_verts[1] = (struct vertex *)NMG_TBL_GET( verts , 0 );
		face_verts[2] = (struct vertex *)NMG_TBL_GET( verts , 1 );
d8098 1
a8098 1
		while( rt_3pts_collinear( face_verts[0]->vg_p->coord,
d8108 1
a8108 1
			if( i+1 >= NMG_TBL_END( verts ) )
d8114 1
a8114 1
			face_verts[verts_in_face] = (struct vertex *)NMG_TBL_GET( verts , i );
d8126 1
a8126 1
				rt_log( "make face:\n" );
d8128 1
a8128 1
					rt_log( "\tx%x ( %f %f %f )\n" , face_verts[debug_int],
d8133 1
a8133 1
			lu = RT_LIST_FIRST( loopuse , &new_fu->lu_hd );
d8138 1
a8138 1
				rt_log( "Bad lu:\n" );
d8174 1
a8174 1
			if( i < NMG_TBL_END( verts ) )
d8176 1
a8176 1
				v = (struct vertex *)NMG_TBL_GET( verts , i );
d8256 1
a8256 1
			for( j=0 ; j<NMG_TBL_END( verts ) ; j++ )
d8260 1
a8260 1
				v_tmp = (struct vertex *)NMG_TBL_GET( verts, j );
d8285 1
a8285 1
			rt_log( "nmg_make_connect_faces: Looking for edges to split verts in face = %d\n", verts_in_face );
d8287 1
a8287 1
				rt_log( "\t x%x ( %g %g %g )\n", face_verts[i], V3ARGS( face_verts[i]->vg_p->coord ) );
d8300 4
a8303 4
						rt_log( "Checking collinearity of:\n" );
						rt_log( "\t x%x ( %g %g %g )\n", face_verts[i], V3ARGS( face_verts[i]->vg_p->coord ) );
						rt_log( "\t x%x ( %g %g %g )\n", face_verts[j], V3ARGS( face_verts[j]->vg_p->coord ) );
						rt_log( "\t x%x ( %g %g %g )\n", face_verts[k], V3ARGS( face_verts[k]->vg_p->coord ) );
d8306 1
a8306 1
					if( !rt_3pts_collinear( face_verts[i]->vg_p->coord,
d8311 1
a8311 1
						rt_log( "\t They are collinear\n" );
d8317 1
a8317 1
							rt_log( "\tFound eu between x%x and x%x\n", face_verts[i], face_verts[j] );
d8319 1
a8319 1
						if( !rt_dist_pt3_lseg3( &dist, pca,
d8328 1
a8328 1
							rt_log( "\t\tvertex x%x is outside eu\n" , face_verts[k] );
d8334 1
a8334 1
							rt_log( "\tFound eu between x%x and x%x\n", face_verts[i], face_verts[k] );
d8336 1
a8336 1
						if( !rt_dist_pt3_lseg3( &dist, pca,
d8345 1
a8345 1
							rt_log( "\t\tvertex x%x is outside eu\n" , face_verts[j] );
d8351 1
a8351 1
							rt_log( "\tFound eu between x%x and x%x\n", face_verts[j], face_verts[k] );
d8353 1
a8353 1
						if( !rt_dist_pt3_lseg3( &dist, pca,
d8362 1
a8362 1
							rt_log( "\t\tvertex x%x is outside eu\n" , face_verts[i] );
d8391 1
a8391 1
	struct nmg_ptbl bad_verts;	/* list of vertices to avoid when finding path
d8401 1
a8401 1
CONST struct rt_tol *tol;
d8406 2
a8407 2
	struct nmg_ptbl faces;
	struct nmg_ptbl dangles;
d8412 1
a8412 1
		rt_log( "nmg_open_shells_connect( dst=x%x , src=x%x , copy_tbl=x%x)\n" , dst , src , copy_tbl );
d8416 1
a8416 1
	RT_CK_TOL( tol );
d8430 1
a8430 1
		rt_log( "nmg_open_shells_connect: destination shell is closed!\n" );
d8436 1
a8436 1
		rt_log( "nmg_open_shells_connect: source shell is closed!\n" );
d8440 1
a8440 1
	nmg_tbl( &dangles , TBL_INIT , (long *)NULL );
d8443 1
a8443 1
	for( RT_LIST_FOR( fu , faceuse , &dst->fu_hd ) )
d8448 1
a8448 1
		for( RT_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
d8451 1
a8451 1
			if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) == NMG_VERTEXUSE_MAGIC )
d8454 1
a8454 1
			for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
d8477 1
a8477 1
					nmg_tbl( &dang->bad_verts , TBL_INIT , (long *)NULL );
d8484 1
a8484 1
					for( RT_LIST_FOR( test_vu , vertexuse , &dang->va->vu_hd ) )
d8507 1
a8507 1
								nmg_tbl( &dang->bad_verts , TBL_INS , (long *)vpbad1 );
d8511 1
a8511 1
					for( RT_LIST_FOR( test_vu , vertexuse , &dang->vb->vu_hd ) )
d8535 1
a8535 1
								nmg_tbl( &dang->bad_verts , TBL_INS , (long *)vpbad1 );
d8538 1
a8538 1
				nmg_tbl( &dangles , TBL_INS , (long *)dang );
d8545 1
a8545 1
	for( i=0 ; i<NMG_TBL_END( &dangles ) ; i++ )
d8548 1
a8548 1
		struct nmg_ptbl *verts;
d8550 1
a8550 1
		dang = (struct dangle *)NMG_TBL_GET( &dangles , i );
d8556 1
a8556 1
		if( NMG_TBL_END( verts ) > 1 )
d8560 2
a8561 2
			rt_log( "nmg_open_shells_connect: unable to make connecting face\n" );
			rt_log( "\tfor edge from x%x ( %f %f %f )\n\t\tto x%x ( %f %f %f )\n",
d8566 2
a8567 2
		nmg_tbl( verts , TBL_FREE , (long *)NULL );
		nmg_tbl( &dang->bad_verts , TBL_FREE , (long *)NULL );
d8570 1
a8570 1
	while( NMG_TBL_END( &dangles ) )
d8579 1
a8579 1
		dang = (struct dangle *)NMG_TBL_GET( &dangles , NMG_TBL_END( &dangles )-1 );
d8583 1
a8583 1
			dang = (struct dangle *)NMG_TBL_GET( &dangles, NMG_TBL_END( &dangles ) - 1 );
d8602 1
a8602 1
						if( rt_dist_pt3_lseg3( &dist, pca,
d8638 1
a8638 1
		nmg_tbl( &dangles , TBL_RM , (long *)dang );
d8642 1
a8642 1
	nmg_tbl( &dangles, TBL_FREE, (long *)NULL );
d8646 2
a8647 2
	nmg_tbl( &faces , TBL_INIT , (long *)NULL );
	for( RT_LIST_FOR( fu , faceuse , &dst->fu_hd ) )
d8651 1
a8651 1
			nmg_tbl( &faces , TBL_INS , (long *)fu );
d8653 2
a8654 2
	nmg_gluefaces( (struct faceuse **)NMG_TBL_BASEADDR( &faces) , NMG_TBL_END( &faces ) );
	nmg_tbl( &faces , TBL_FREE , (long *)NULL );
d8677 1
a8677 1
CONST struct rt_tol *tol;
d8679 1
a8679 1
	struct nmg_ptbl faces;
d8685 1
a8685 1
		rt_log( "nmg_in_vert( new_v=x%x at ( %f %f %f) )\n" , new_v , V3ARGS( new_v->vg_p->coord ) );
d8688 1
a8688 1
	RT_CK_TOL( tol );
d8690 1
a8690 1
	nmg_tbl( &faces , TBL_INIT , (long *)NULL );
d8696 1
a8696 1
		rt_log( "\tnmg_in_vert: found %d faces at new_v, %d free_edges\n",
d8704 1
a8704 1
			rt_log( "Could not solve simple vertex\n" );
d8712 1
a8712 1
			rt_log( "Could not solve complex vertex\n" );
d8717 1
a8717 1
	nmg_tbl( &faces , TBL_FREE , (long *)NULL );
d8733 1
a8733 1
	struct nmg_ptbl vertices;
d8743 1
a8743 1
	for( i=0 ; i<NMG_TBL_END( &vertices ) ; i++ )
d8747 1
a8747 1
		v = (struct vertex *)NMG_TBL_GET( &vertices , i );
d8752 1
a8752 1
	(void)nmg_tbl( &vertices , TBL_FREE , (long *)NULL );
d8756 1
a8756 1
	for( RT_LIST_FOR( r , nmgregion , &m->r_hd ) )
d8760 1
a8760 1
		for( RT_LIST_FOR( s , shell , &r->s_hd ) )
d8764 1
a8764 1
			for( RT_LIST_FOR( fu , faceuse , &s->fu_hd ) )
d8798 1
a8798 1
		rt_log( "nmg_kill_cracks( s=%x )\n" , s );
d8808 1
a8808 1
	for( RT_LIST_FOR( fu, faceuse, &s->fu_hd ) )
d8817 1
a8817 1
		for( RT_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
d8823 1
a8823 1
			if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d8826 1
a8826 1
			for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d8832 1
a8832 1
				for( RT_LIST_FOR( eu2, edgeuse, &lu->down_hd ) )
d8844 1
a8844 1
					if( eu2 == RT_LIST_PNEXT_CIRC( edgeuse, &eu->l ) )
d8849 1
a8849 1
					if( eu2 == RT_LIST_PPREV_CIRC( edgeuse, &eu->l ) )
d8864 1
a8864 1
						rt_log( "nmg_kill_cracks: found a strange crack at eu1=x%x, eu2=x%x\n", eu, eu2 );
d8883 2
a8884 2
	fu = RT_LIST_FIRST( faceuse, &s->fu_hd );
	while( RT_LIST_NOT_HEAD( fu, &s->fu_hd ) )
d8892 2
a8893 2
		fu_next = RT_LIST_PNEXT( faceuse, &fu->l );
		while( RT_LIST_NOT_HEAD( fu_next, &s->fu_hd )
d8895 1
a8895 1
				fu_next = RT_LIST_PNEXT( faceuse, &fu_next->l );
d8897 2
a8898 2
		lu = RT_LIST_FIRST( loopuse, &fu->lu_hd );
		while( RT_LIST_NOT_HEAD( lu, &fu->lu_hd ) )
d8906 1
a8906 1
			lu_next = RT_LIST_PNEXT( loopuse, &lu->l );
d8908 1
a8908 1
			if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d8915 1
a8915 1
			for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d8919 1
a8919 1
				eu_next = RT_LIST_PNEXT_CIRC( edgeuse, &eu->l );
d8959 1
a8959 1
			rt_log( "nmg_kill_cracks: ret = %d\n" , empty_shell );
d8965 1
a8965 1
		rt_log( "nmg_kill_cracks: ret = %d\n" , empty_shell );
d8978 1
a8978 1
		rt_log( "nmg_kill_zero_length_edgeuses( m=%x )\n", m );
d8982 2
a8983 2
	r = RT_LIST_FIRST( nmgregion, &m->r_hd );
	while( RT_LIST_NOT_HEAD( r, &m->r_hd ) )
d8991 1
a8991 1
		next_r = RT_LIST_PNEXT( nmgregion, &r->l );
d8993 2
a8994 2
		s = RT_LIST_FIRST( shell, &r->s_hd );
		while( RT_LIST_NOT_HEAD( s, &r->s_hd ) )
d9002 1
a9002 1
			next_s = RT_LIST_PNEXT( shell, &s->l );
d9004 2
a9005 2
			fu = RT_LIST_FIRST( faceuse, &s->fu_hd );
			while( RT_LIST_NOT_HEAD( fu, &s->fu_hd ) )
d9013 1
a9013 1
				next_fu = RT_LIST_PNEXT( faceuse, &fu->l );
d9015 1
a9015 1
					next_fu = RT_LIST_PNEXT( faceuse, &next_fu->l );
d9017 2
a9018 2
				lu = RT_LIST_FIRST( loopuse, &fu->lu_hd );
				while( RT_LIST_NOT_HEAD( lu, &fu->lu_hd ) )
d9026 1
a9026 1
					next_lu = RT_LIST_PNEXT( loopuse, &lu->l );
d9028 1
a9028 1
					if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d9034 2
a9035 2
					eu = RT_LIST_FIRST( edgeuse, &lu->down_hd );
					while( RT_LIST_NOT_HEAD( eu, &lu->down_hd ) )
d9042 2
a9043 2
						next_eu = RT_LIST_PNEXT( edgeuse, &eu->l );
						next_eu_circ = RT_LIST_PNEXT_CIRC( edgeuse, &eu->l );
d9097 1
a9097 1
CONST struct rt_tol *tol;
d9099 1
a9099 1
	struct nmg_ptbl faceuses;
d9104 1
a9104 1
	RT_CK_TOL( tol );
d9106 1
a9106 1
	nmg_tbl( &faceuses, TBL_INIT, (long *)NULL );
d9108 1
a9108 1
	for( RT_LIST_FOR( fu, faceuse, &s->fu_hd ) )
d9115 1
a9115 1
		nmg_tbl( &faceuses, TBL_INS, (long *)fu );
d9118 1
a9118 1
	for (i = 0; i < NMG_TBL_END( &faceuses ); i++)
d9127 1
a9127 1
		fu = (struct faceuse *)NMG_TBL_GET( &faceuses, i );
d9144 1
a9144 1
				rt_log( "nmg_make_faces_within_tol(): nmg_calc_face_plane() failed\n" );
d9151 1
a9151 1
	for( RT_LIST_FOR( fu, faceuse, &s->fu_hd ) )
d9158 1
a9158 1
		if( nmg_tbl( &faceuses, TBL_LOC, (long *)fu ) != (-1) )
d9163 1
a9163 1
			rt_log( "nmg_make_faces_within_tol(): nmg_calc_face_plane() failed\n" );
d9170 1
a9170 1
	nmg_tbl( &faceuses, TBL_FREE, (long *)NULL );
d9176 1
a9176 1
struct rt_tol *tol;
d9179 1
a9179 1
	struct nmg_ptbl edgeuses;
d9182 1
a9182 1
	RT_CK_TOL( tol );
d9184 1
a9184 1
	nmg_tbl( &edgeuses, TBL_INIT, (long *)0 );
d9186 1
a9186 1
	for( RT_LIST_FOR( fu, faceuse, &s->fu_hd ) )
d9195 1
a9195 1
		for( RT_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
d9202 1
a9202 1
			if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d9205 2
a9206 2
			for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
				nmg_tbl( &edgeuses, TBL_INS, (long *)eu );
d9208 1
a9208 1
			for( i=0 ; i<NMG_TBL_END( &edgeuses ); i++ )
d9212 1
a9212 1
				eu = (struct edgeuse *)NMG_TBL_GET( &edgeuses, i );
d9215 1
a9215 1
				for( j=i+1 ; j<NMG_TBL_END( &edgeuses ) ; j++ )
d9225 1
a9225 1
					eu2 = (struct edgeuse *)NMG_TBL_GET( &edgeuses, j );
d9228 1
a9228 1
					code = rt_isect_lseg3_lseg3( dist, eu->vu_p->v_p->vg_p->coord, eu_dir,
d9271 1
a9271 1
						nmg_tbl( &edgeuses, TBL_RST, (long *)0 );
d9277 1
a9277 1
			nmg_tbl( &edgeuses, TBL_RST, (long *)0 );
d9281 1
a9281 1
	nmg_tbl( &edgeuses, TBL_FREE, (long *)0 );
d9295 1
a9295 1
struct rt_list	*crv_head;
d9312 1
a9312 1
	RT_CK_LIST_HEAD( crv_head );
d9317 1
a9317 1
	for( RT_LIST_FOR( crv, edge_g_cnurb, crv_head ) )
d9328 1
a9328 1
			rt_log( "Curve does not have multiplicity equal to order at start:\n" );
d9337 1
a9337 1
			rt_log( "Curve does not have multiplicity equal to order at end:\n" );
d9348 1
a9348 1
				rt_log( "rt_join_cnurbs: curves are not the same pt_type (%d vs %d)\n",
d9358 2
a9359 2
		crv = RT_LIST_FIRST( edge_g_cnurb, crv_head );
		RT_LIST_DEQUEUE( &crv->l );
d9364 1
a9364 1
	for( RT_LIST_FOR( crv, edge_g_cnurb, crv_head ) )
d9375 1
a9375 1
	crv = RT_LIST_FIRST( edge_g_cnurb, crv_head );
d9377 2
a9378 2
	next_crv = RT_LIST_NEXT( edge_g_cnurb, &crv->l );
	while( RT_LIST_NOT_HEAD( &next_crv->l, crv_head ) )
d9401 1
a9401 1
			next_crv = RT_LIST_NEXT( edge_g_cnurb, &crv->l );
d9405 1
a9405 1
		rt_log( "rt_join_cnurbs: Curve endpoints do not match:\n" );
d9412 1
a9412 1
	crv = RT_LIST_FIRST( edge_g_cnurb, crv_head );
d9414 1
a9414 1
	for( RT_LIST_FOR( crv, edge_g_cnurb, crv_head ) )
d9424 1
a9424 1
	crv = RT_LIST_FIRST( edge_g_cnurb, crv_head );
d9438 1
a9438 1
	for( RT_LIST_FOR( crv, edge_g_cnurb, crv_head ) )
d9482 1
a9482 1
struct rt_tol *tol;
d9485 1
a9485 1
	struct rt_list crv_head;
d9503 1
a9503 1
	RT_CK_TOL( tol );
d9529 1
a9529 1
			rt_log( "rt_arc2d_to_cnurb: center and start points not at same Z value (%g vs %g)\n",
d9536 1
a9536 1
			rt_log( "rt_arc2d_to_cnurb: end and start points not at same Z value (%g vs %g)\n",
d9543 1
a9543 1
			rt_log( "rt_arc2d_to_cnurb: end and center points not at same Z value (%g vs %g)\n",
d9571 2
a9572 2
		rt_log( "rt_arc2d_to_cnurb: distances from center to start and center to end are different\n" );
		rt_log( "                        (%g and %g)\n", radius, tmp_radius );
d9585 1
a9585 1
		angle += 2.0*rt_pi;
d9587 1
a9587 1
	if( angle < 150.0*rt_pi/180.0 ) /* angle is reasonable to do in one segment */
d9601 1
a9601 1
		if( (ret_val=rt_isect_line3_line3( &dist1, &dist2, start, t1, end, t2, tol )) < 1 )
d9603 2
a9604 2
			rt_log( "rt_arc2d_to_cnurb: Cannot calculate second control point\n" );
			rt_log( "                   rt_isect_line3_line3 returns %d\n" , ret_val );
d9641 1
a9641 1
	if( angle < 1.5*rt_pi )
d9658 1
a9658 1
	RT_LIST_INIT( &crv_head );
d9671 1
a9671 1
		RT_LIST_INSERT( &crv_head, &crv->l );
d9683 2
a9684 2
struct nmg_ptbl *verts;
CONST struct rt_tol *tol;
d9689 1
a9689 1
	struct nmg_ptbl edges;
d9691 1
a9691 1
	RT_CK_TOL( tol );
d9693 1
a9693 1
	NMG_CK_PTBL( verts );
d9695 2
a9696 2
	nmg_tbl( &edges, TBL_INIT, (long *)NULL );
	nmg_tbl( &edges, TBL_INS, (long *)e );
d9700 1
a9700 1
	while( NMG_TBL_END( &edges ) )
d9705 1
a9705 1
		e1 = (struct edge *)NMG_TBL_GET( &edges, NMG_TBL_END( &edges )-1 );
d9715 1
a9715 1
		for( j=0 ; j<NMG_TBL_END( verts ) ; j++ )
d9722 1
a9722 1
			v = (struct vertex *)NMG_TBL_GET( verts, j );
d9728 1
a9728 1
			if( rt_dist_pt3_lseg3( &dist, pca, va->vg_p->coord, vb->vg_p->coord, v->vg_p->coord, tol ) )
d9734 3
a9736 3
			nmg_tbl( &edges, TBL_RM, (long *)e );
			nmg_tbl( &edges, TBL_INS, (long *)eu->e_p );
			nmg_tbl( &edges, TBL_INS, (long *)eu_new->e_p );
d9740 1
a9740 1
		nmg_tbl( &edges, TBL_RM, (long *)e1 );
d9742 1
a9742 1
	nmg_tbl( &edges, TBL_FREE, (long *)NULL );
d9749 1
a9749 1
struct rt_tol *tol;
d9751 2
a9752 2
	struct nmg_ptbl edges;
	struct nmg_ptbl verts;
d9756 1
a9756 1
	RT_CK_TOL( tol );
d9761 1
a9761 1
	for( i=0 ; i<NMG_TBL_END( &edges ); i++ )
d9766 1
a9766 1
		e = (struct edge *)NMG_TBL_GET( &edges, i );
d9771 2
a9772 2
	nmg_tbl( &edges, TBL_FREE, (long *)NULL );
	nmg_tbl( &verts, TBL_FREE, (long *)NULL );
d9781 1
a9781 1
struct nmg_ptbl *tab;
d9795 1
a9795 1
	if( NMG_TBL_END( tab ) > 8 || NMG_TBL_END( tab ) < 4 )
d9798 1
a9798 1
	for( RT_LIST_FOR( fu, faceuse, &s->fu_hd ) )
d9817 1
a9817 1
		for( RT_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
d9823 1
a9823 1
			if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d9832 1
a9832 1
			for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d9894 1
a9894 1
	for( RT_LIST_FOR( fu, faceuse, &s->fu_hd ) )
d9903 1
a9903 1
		for( RT_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
d9907 1
a9907 1
			for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d9922 1
a9922 1
	switch( NMG_TBL_END( tab ) )
d9946 1
a9946 1
	return( NMG_TBL_END( tab ) );
d9950 1
a9950 1
	nmg_tbl( tab, TBL_FREE, (long *)NULL );
d9979 1
a9979 1
	struct nmg_ptbl tab;
d9987 1
a9987 1
	r = RT_LIST_FIRST( nmgregion, &m->r_hd );
d9990 1
a9990 1
	if( RT_LIST_NEXT_NOT_HEAD( &r->l, &m->r_hd ) )
d9993 1
a9993 1
	s = RT_LIST_FIRST( shell, &r->s_hd );
d9997 1
a9997 1
	if( RT_LIST_NEXT_NOT_HEAD( &s->l, &r->s_hd ) )
d10006 1
a10006 1
			v = (struct vertex *)NMG_TBL_GET( &tab, 0 );
d10009 1
a10009 1
			v = (struct vertex *)NMG_TBL_GET( &tab, 1 );
d10012 1
a10012 1
			v = (struct vertex *)NMG_TBL_GET( &tab, 2 );
d10016 1
a10016 1
			v = (struct vertex *)NMG_TBL_GET( &tab, 3 );
d10023 1
a10023 1
			nmg_tbl( &tab, TBL_FREE, (long *)NULL );
d10027 1
a10027 1
			fu = RT_LIST_FIRST( faceuse, &s->fu_hd );
d10032 3
a10034 3
				fu = RT_LIST_PNEXT_CIRC( faceuse, &fu->l );
				lu = RT_LIST_FIRST( loopuse, &fu->lu_hd );
				for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d10042 1
a10042 1
			lu = RT_LIST_FIRST( loopuse, &fu->lu_hd );
d10044 2
a10045 2
			eu_start = RT_LIST_FIRST( edgeuse, &lu->down_hd );
			for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d10052 1
a10052 1
			eu = RT_LIST_PNEXT_CIRC( edgeuse, &eu->l );
d10060 1
a10060 1
			nmg_tbl( &tab, TBL_FREE, (long *)NULL );
d10064 1
a10064 1
			fu = RT_LIST_FIRST( faceuse, &s->fu_hd );
d10069 3
a10071 3
				fu = RT_LIST_PNEXT_CIRC( faceuse, &fu->l );
				lu = RT_LIST_FIRST( loopuse, &fu->lu_hd );
				for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d10079 1
a10079 1
			lu = RT_LIST_FIRST( loopuse, &fu->lu_hd );
d10081 1
a10081 1
			eu_start = RT_LIST_FIRST( edgeuse, &lu->down_hd );
d10084 1
a10084 1
			eu = RT_LIST_PNEXT_CIRC( edgeuse, &eu->l );
d10086 1
a10086 1
			eu = RT_LIST_PNEXT_CIRC( edgeuse, &eu->l );
d10091 2
a10092 2
			eu = RT_LIST_PNEXT_CIRC( edgeuse, &eu->l );
			eu = RT_LIST_PNEXT_CIRC( edgeuse, &eu->l );
d10095 1
a10095 1
			eu = RT_LIST_PNEXT_CIRC( edgeuse, &eu->l );
d10097 1
a10097 1
			eu = RT_LIST_PNEXT_CIRC( edgeuse, &eu->l );
d10101 1
a10101 1
			nmg_tbl( &tab, TBL_FREE, (long *)NULL );
d10106 1
a10106 1
			fu = RT_LIST_FIRST( faceuse, &s->fu_hd );
d10111 2
a10112 2
				lu = RT_LIST_FIRST( loopuse, &fu->lu_hd );
				for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d10119 2
a10120 2
					lu1 = RT_LIST_FIRST( loopuse, &fu1->lu_hd );
					for( RT_LIST_FOR( eu1, edgeuse, &lu1->down_hd ) )
d10136 1
a10136 1
			lu = RT_LIST_FIRST( loopuse, &fu->lu_hd );
d10138 2
a10139 2
			eu_start = RT_LIST_FIRST( edgeuse, &lu->down_hd );
			for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d10146 2
a10147 2
			eu = RT_LIST_PNEXT_CIRC( edgeuse, &eu->l );
			eu = RT_LIST_PNEXT_CIRC( edgeuse, &eu->l );
d10153 1
a10153 1
				eu = RT_LIST_PNEXT_CIRC( edgeuse, &eu->l );
d10160 1
a10160 1
				eu = RT_LIST_PNEXT_CIRC( edgeuse, &eu->l );
d10163 1
a10163 1
			nmg_tbl( &tab, TBL_FREE, (long *)NULL );
d10167 1
a10167 1
			fu = RT_LIST_FIRST( faceuse, &s->fu_hd );
d10173 1
a10173 1
			lu = RT_LIST_FIRST( loopuse, &fu->lu_hd );
d10175 2
a10176 2
			eu_start = RT_LIST_FIRST( edgeuse, &lu->down_hd );
			for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d10183 2
a10184 2
			eu = RT_LIST_PNEXT_CIRC( edgeuse, &eu->l );
			eu = RT_LIST_PNEXT_CIRC( edgeuse, &eu->l );
d10190 1
a10190 1
				eu = RT_LIST_PNEXT_CIRC( edgeuse, &eu->l );
d10193 1
a10193 1
			nmg_tbl( &tab, TBL_FREE, (long *)NULL );
d10223 1
a10223 1
CONST struct rt_tol *tol;
d10259 1
a10259 1
	RT_CK_TOL( tol );
d10261 1
a10261 1
	r = RT_LIST_FIRST( nmgregion, &m->r_hd );
d10264 1
a10264 1
	if( RT_LIST_NEXT_NOT_HEAD( &r->l, &m->r_hd ) )
d10267 1
a10267 1
	s = RT_LIST_FIRST( shell, &r->s_hd );
d10271 1
a10271 1
	if( RT_LIST_NEXT_NOT_HEAD( &s->l, &r->s_hd ) )
d10274 1
a10274 1
	for( RT_LIST_FOR( fu, faceuse, &s->fu_hd ) )
d10284 1
a10284 1
		for( RT_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
d10289 1
a10289 1
			if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d10296 1
a10296 1
			for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d10351 2
a10352 2
	lu = RT_LIST_FIRST( loopuse, &fu_base->lu_hd );
	for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d10374 2
a10375 2
	lu = RT_LIST_FIRST( loopuse, &fu_base->lu_hd );
	for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d10402 2
a10403 2
	lu = RT_LIST_FIRST( loopuse, &fu_top->lu_hd );
	for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d10423 2
a10424 2
	lu = RT_LIST_FIRST( loopuse, &fu_top->lu_hd );
	for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d10479 1
a10479 1
CONST struct rt_tol *tol;
d10484 1
a10484 1
	RT_CK_TOL( tol );
d10486 1
a10486 1
	if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d10492 1
a10492 1
	eu1 = RT_LIST_FIRST( edgeuse, &lu->down_hd );
d10494 2
a10495 2
	eu2 = RT_LIST_PNEXT_CIRC( edgeuse, &eu1->l );
	eu3 = RT_LIST_PNEXT_CIRC( edgeuse, &eu2->l );
d10521 3
a10523 3
			eu1 = RT_LIST_PNEXT_CIRC( edgeuse, &eu1->l );
			eu2 = RT_LIST_PNEXT_CIRC( edgeuse, &eu1->l );
			eu3 = RT_LIST_PNEXT_CIRC( edgeuse, &eu2->l );
d10534 1
a10534 1
CONST struct rt_tol *tol;
d10552 1
a10552 1
	RT_CK_TOL( tol );
d10554 1
a10554 1
	for( RT_LIST_FOR( r, nmgregion, &m->r_hd ) )
d10556 1
a10556 1
		for( RT_LIST_FOR( s, shell, &r->s_hd ) )
d10565 1
a10565 1
	dup_s = RT_LIST_FIRST( shell, &dup_r->s_hd );
d10567 1
a10567 1
	for( RT_LIST_FOR( r, nmgregion, &m->r_hd ) )
d10569 1
a10569 1
		for( RT_LIST_FOR( s, shell, &r->s_hd ) )
d10571 1
a10571 1
			for( RT_LIST_FOR( fu, faceuse, &s->fu_hd ) )
d10580 1
a10580 1
	for( RT_LIST_FOR( dup_r, nmgregion, &dup_m->r_hd ) )
d10582 1
a10582 1
		for( RT_LIST_FOR( dup_s, shell, &dup_r->s_hd ) )
d10584 1
a10584 1
			for( RT_LIST_FOR( fu , faceuse , &dup_s->fu_hd ) )
d10594 1
a10594 1
				for( RT_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
d10597 1
a10597 1
					if( RT_LIST_FIRST_MAGIC(&lu->down_hd) != NMG_EDGEUSE_MAGIC )
d10601 1
a10601 1
					for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
d10620 1
a10620 1
						rt_log( "write_shell_as_polysolid: triangulating fu x%x\n", fu );
d10624 1
a10624 1
				for( RT_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
d10627 1
a10627 1
					if( RT_LIST_FIRST_MAGIC(&lu->down_hd) != NMG_EDGEUSE_MAGIC )
d10640 1
a10640 1
	for( RT_LIST_FOR( dup_r, nmgregion, &dup_m->r_hd ) )
d10642 1
a10642 1
		for( RT_LIST_FOR( dup_s, shell, &dup_r->s_hd ) )
d10644 1
a10644 1
			for( RT_LIST_FOR( fu , faceuse , &dup_s->fu_hd ) )
d10656 1
a10656 1
				for( RT_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
d10660 1
a10660 1
					if( RT_LIST_FIRST_MAGIC(&lu->down_hd) != NMG_EDGEUSE_MAGIC )
d10665 1
a10665 1
					for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
d10672 1
a10672 1
					for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
d10699 1
a10699 1
struct rt_tol *tol;
d10705 1
a10705 1
	RT_CK_TOL( tol );
d10707 2
a10708 2
	fu = RT_LIST_FIRST( faceuse, &s->fu_hd );
	while( RT_LIST_NOT_HEAD( &fu->l, &s->fu_hd ) )
d10716 1
a10716 1
		fu_next = RT_LIST_PNEXT( faceuse, &fu->l );
d10724 1
a10724 1
		lu = RT_LIST_FIRST( loopuse, &fu->lu_hd );
d10726 1
a10726 1
		while( RT_LIST_NOT_HEAD( &lu->l, &fu->lu_hd ) )
d10737 1
a10737 1
			lu_next = RT_LIST_PNEXT( loopuse, &lu->l );
d10739 1
a10739 1
			if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d10745 2
a10746 2
			eu = RT_LIST_FIRST( edgeuse, &lu->down_hd );
			while( RT_LIST_NOT_HEAD( &eu->l, &lu->down_hd ) )
d10760 1
a10760 1
				eu_next = RT_LIST_PNEXT_CIRC( edgeuse, &eu->l );
d10767 1
a10767 1
					eu = RT_LIST_PNEXT( edgeuse, &eu->l );
d10774 1
a10774 1
				for( RT_LIST_FOR( vu, vertexuse, &v2->vu_hd ) )
d10795 1
a10795 1
					eu = RT_LIST_PNEXT( edgeuse, &eu->l );
d10818 1
a10818 1
					eu = RT_LIST_PNEXT( edgeuse, &eu->l );
d10833 2
a10834 2
				vu = RT_LIST_FIRST( vertexuse, &v2->vu_hd );
				while( RT_LIST_NOT_HEAD( &vu->l, &v2->vu_hd ) )
d10837 1
a10837 1
					next_vu = RT_LIST_PNEXT( vertexuse, &vu->l );
d10859 1
a10859 1
				if( RT_LIST_IS_EMPTY( &lu->down_hd ) )
d10876 1
a10876 1
				fu_next = RT_LIST_NEXT( faceuse, &fu_next->l );
@


11.46
log
@Moved nmg_tbl() off into bu_ptbl() in libbu/ptbl.c
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 11.45 1996/08/27 02:57:48 mike Exp mike $ (ARL)";
d6318 3
a6320 1
			if( rt_3pts_collinear( new_v , vu1->v_p , vu2->v_p , tol ) )
@


11.45
log
@Removed confusing "else" around rt_bomb() pair.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 11.44 1996/05/16 22:09:52 jra Exp mike $ (ARL)";
a2216 152

/*	N M G _ T B L
 *	maintain a table of pointers (to magic numbers/structs)
 */
int
nmg_tbl(b, func, p)
struct nmg_ptbl *b;
int func;
long *p;
{
	if (func == TBL_INIT) {
		b->magic = NMG_PTBL_MAGIC;
		b->blen=64;
		b->buffer = (long **)rt_calloc(b->blen, sizeof(long *),
			"nmg_ptbl.buffer[]");
		b->end = 0;
		if (rt_g.NMG_debug & DEBUG_INS)
			rt_log("nmg_tbl(%8x) TBL_INIT\n", b);
		return(0);
	} else if (func == TBL_RST) {
		NMG_CK_PTBL(b);
		b->end = 0;
		if (rt_g.NMG_debug & DEBUG_INS)
			rt_log("nmg_tbl(%8x) TBL_RST\n", b);
		return(0);
	} else if (func == TBL_INS) {
		register int i;

		if (rt_g.NMG_debug & DEBUG_INS)
			rt_log("nmg_tbl(%8x) TBL_INS %8x\n", b, p);

		NMG_CK_PTBL(b);

		if (b->blen == 0) (void)nmg_tbl(b, TBL_INIT, p);
		if (b->end >= b->blen)
			b->buffer = (long **)rt_realloc( (char *)b->buffer,
			    sizeof(p)*(b->blen *= 4),
			    "pointer table" );

		b->buffer[i=b->end++] = p;
		return(i);
	} else if (func == TBL_LOC) {
		/* we do this a great deal, so make it go as fast as possible.
		 * this is the biggest argument I can make for changing to an
		 * ordered list.  Someday....
		 */
		register int	k;
		register long	**pp = b->buffer;

		NMG_CK_PTBL(b);
#		include "noalias.h"
		for( k = b->end-1; k >= 0; k-- )
			if (pp[k] == p) return(k);

		return(-1);
	} else if( func == TBL_ZERO ) {
		/* set all occurrences of "p" to zero */
		register int	k;
		register long	**pp = b->buffer;

		NMG_CK_PTBL(b);
#		include "noalias.h"
		for( k = b->end-1; k >= 0; k-- )
			if (pp[k] == p) pp[k] = (long *)0;
		return( 0 );
	} else if (func == TBL_INS_UNIQUE) {
		/* we do this a great deal, so make it go as fast as possible.
		 * this is the biggest argument I can make for changing to an
		 * ordered list.  Someday....
		 */
		register int	k;
		register long	**pp = b->buffer;

		NMG_CK_PTBL(b);
#		include "noalias.h"
		for( k = b->end-1; k >= 0; k-- )
			if (pp[k] == p) return(k);

		if (b->blen <= 0 || b->end >= b->blen)  {
			/* Table needs to grow */
			return( nmg_tbl( b, TBL_INS, p ) );
		}

		if (rt_g.NMG_debug & DEBUG_INS)
			rt_log("nmg_tbl(%8x) TBL_INS_UNIQUE %8x\n", b, p);

		b->buffer[k=b->end++] = p;
		return(-1);		/* To signal that it was added */
	} else if (func == TBL_RM) {
		/* we go backwards down the list looking for occurrences
		 * of p to delete.  We do it backwards to reduce the amount
		 * of data moved when there is more than one occurrence of p
		 * in the list.  A pittance savings, unless you're doing a
		 * lot of it.
		 */
		register int end = b->end, j, k, l;
		register long **pp = b->buffer;

		NMG_CK_PTBL(b);
		if (rt_g.NMG_debug & DEBUG_INS)
			rt_log("nmg_tbl(%8x) TBL_RM %8x\n", b, p);
		for (l = b->end-1 ; l >= 0 ; --l)
			if (pp[l] == p){
				/* delete occurrence(s) of p */

				j=l+1;
				while (pp[l-1] == p) --l;

				end -= j - l;
#				include "noalias.h"
				for(k=l ; j < b->end ;)
					b->buffer[k++] = b->buffer[j++];
				b->end = end;
			}
		return(0);
	} else if (func == TBL_CAT) {
		union {
			long *l;
			struct nmg_ptbl *t;
		} d;

		NMG_CK_PTBL(b);
		d.l = p;
		NMG_CK_PTBL(d.t);
		if (rt_g.NMG_debug & DEBUG_INS)
			rt_log("nmg_tbl(%8x) TBL_CAT %8x\n", b, p);

		if ((b->blen - b->end) < d.t->end) {
			
			b->buffer = (long **)rt_realloc( (char *)b->buffer,
				sizeof(p)*(b->blen += d.t->blen),
				"pointer table (CAT)");
		}
		bcopy( (char *)d.t->buffer, (char *)&b->buffer[b->end], d.t->end*sizeof(p));
		return(0);
	} else if (func == TBL_FREE) {
		NMG_CK_PTBL(b);
		bzero((char *)b->buffer, b->blen * sizeof(p));
		rt_free((char *)b->buffer, "pointer table");
		bzero((char *)b, sizeof(struct nmg_ptbl));
		if (rt_g.NMG_debug & DEBUG_INS)
			rt_log("nmg_tbl(%8x) TBL_FREE\n", b);
		return (0);
	} else {
		NMG_CK_PTBL(b);
		rt_log("nmg_tbl(%8x) Unknown table function %d\n", b, func);
		rt_bomb("nmg_tbl");
	}
	return(-1);/* this is here to keep lint happy */
}


@


11.44
log
@Added TBL_ZERO function to nmg_tbl().
Modified nmg_loop_plane_newell() to insure plane is at center of range of vertices.
Added code to nmg_kill_cracks to kill a crack in a loop where it can be removed to create
two disconnected loops.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 11.43 1996/04/22 12:16:53 jra Exp jra $ (ARL)";
d1483 1
a1483 2
		else
			rt_bomb( "\tsrc->fumate_p faceuse contains only lu->lumate_p, but src has more!!\n" );
@


11.43
log
@Improved nmg_make_faces_within_tol().
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 11.42 1996/03/28 18:07:05 jra Exp $ (ARL)";
d1514 1
a1514 3
	point_t ave_pt;
	fastf_t pt_count=0.0;
	fastf_t inv_count;
a1528 2
	VSETALL( ave_pt, 0.0 );

a1538 3
		VADD2( ave_pt, ave_pt, vg->coord );
		pt_count += 1.0;

a1539 1

d1549 17
a1565 3
	inv_count = 1.0/pt_count;
	VSCALE( ave_pt, ave_pt, inv_count );
	pl[H] = VDOT( pl, ave_pt );
d2273 10
d8952 67
d9020 14
d9106 8
@


11.42
log
@Corrected call to nmg_lu_is_convex().
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 11.41 1996/03/28 02:33:50 butler Exp jra $ (ARL)";
d1708 2
d1740 2
d1746 1
a1746 1
		for( RT_LIST_FOR( f , face, &fg->f_hd ) )
d1748 1
a1748 1
			for( RT_LIST_FOR( lu, loopuse, &f->fu_p->lu_hd ) )
d1906 19
d9178 1
a9178 1
		for( RT_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
d9180 1
a9180 29
			NMG_CK_LOOPUSE( lu );

			if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) == NMG_VERTEXUSE_MAGIC )
			{
				vu = RT_LIST_FIRST( vertexuse, &lu->down_hd );
				dist_to_plane = DIST_PT_PLANE( vu->v_p->vg_p->coord, pl );
				if( dist_to_plane > tol->dist || dist_to_plane < -tol->dist )
				{
					triangulate = 1;
					break;
				}
			}
			else
			{
				for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
				{
					NMG_CK_EDGEUSE( eu );
					vu = eu->vu_p;
					dist_to_plane = DIST_PT_PLANE( vu->v_p->vg_p->coord, pl );
					if( dist_to_plane > tol->dist || dist_to_plane < -tol->dist )
					{
						triangulate = 1;
						break;
					}
				}
				if( triangulate )
					break;
			}
		}
a9181 2
		if( triangulate )
		{
d9187 2
a9188 1
			if( nmg_calc_face_g( fu ) )
d9190 2
a9191 2
				rt_log( "cvt_euclid_region: nmg_calc_face_g failed!!\n" );
				rt_bomb( "euclid-g: Could not calculate new face geometry\n" );
d9193 1
a9193 1

d9207 5
a9211 1
		nmg_calc_face_g( fu );
d9213 1
d10650 2
a10651 1
					if( count_npts > max_count )
d10653 7
a10666 6
					nmg_triangulate_fu( fu, tol );
				}
				else if( !nmg_lu_is_convex( lu, tol ) )
				{
					if( rt_g.NMG_debug & DEBUG_BASIC )
						rt_log( "write_shell_as_polysolid: triangulating non-convex fu x%x\n", fu );
@


11.41
log
@added bogus nmg_loop_is_convex() function to make librt compile
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 11.40 1996/03/25 21:12:47 jra Exp butler $ (ARL)";
a50 7
nmg_loop_is_convex( lu, tol )
struct loopuse *lu;
struct rt_tol *tol;
{
}

int
d10662 1
a10662 1
				else if( !nmg_loop_is_convex( lu, tol ) )
@


11.40
log
@mods to nmg_simplify_shell_edges().
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 11.39 1996/03/17 23:58:09 jra Exp jra $ (ARL)";
d49 7
@


11.39
log
@Added nmg_simplify_shell_edges().
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 11.38 1996/03/05 21:32:18 jra Exp jra $ (ARL)";
d10752 2
a10753 1
	for( RT_LIST_FOR( fu, faceuse, &s->fu_hd ) )
d10755 1
d10757 1
d10761 2
d10764 2
d10767 1
d10769 3
a10771 1
		for( RT_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
d10773 1
d10782 2
d10785 2
d10788 1
d10796 1
d10801 1
d10803 1
d10877 3
a10879 3
				/* move all uses of eu to vertex v3 */
				eu_tmp = eu->eumate_p;
				do
d10881 17
d10899 4
a10902 2
					eu_tmp = eu_tmp->radial_p->eumate_p;
				} while( eu_tmp != eu->eumate_p );
d10904 8
d10913 10
d10924 1
@


11.38
log
@Added nmg_lu_is_convex().
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 11.37 1996/02/20 16:58:18 jra Exp $ (ARL)";
d753 1
a753 1
						class = nmg_class_pt_s( eu->vu_p->v_p->vg_p->coord , outer_shell , ttol );
d10739 131
@


11.37
log
@Added nmg_to_arb(), nmg_to_tgc(), nad nmg_to_poly().
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 11.36 1996/02/16 15:41:17 jra Exp jra $ (ARL)";
d10514 63
d10656 2
a10657 1
				if( max_count > 5 ) {
d10660 7
a10666 1
						nmg_triangulate_fu( fu, tol );
@


11.36
log
@Added mat_det3() to calculate 3X3 determinants.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 11.35 1995/12/04 20:33:45 jra Exp jra $ (ARL)";
d44 1
d9822 847
@


11.35
log
@Added nmg_snurb_calc_lu_uv_orient().
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 11.34 1995/12/01 02:47:38 mike Exp jra $ (ARL)";
d934 23
@


11.34
log
@LIBNURB data structures have been fully merged withNMG data structures.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 11.33 1995/11/28 20:44:11 jra Exp $ (ARL)";
d48 122
@


11.33
log
@Changed nmg_get_fu_snurb_norm() to nmg_snurb_fu_get_norm_at_vu(). Added nmg_snurb_fu_eval()
and nmg_snurb_fu_get_norm().
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 11.32 1995/11/22 22:30:51 jra Exp $ (ARL)";
a56 1
	struct snurb srf;
a73 1
	nmg_hack_snurb( &srf, f->g.snurb_p );
d75 1
a75 1
	rt_nurb_s_eval( &srf, u, v, tmp_pt );
d77 1
a77 1
	if( RT_NURB_IS_PT_RATIONAL(srf.pt_type) )
a95 1
	struct snurb srf;
d112 1
a112 2
	nmg_hack_snurb( &srf, f->g.snurb_p );
	rt_nurb_s_norm( &srf, u, v, norm );
a124 1
	struct snurb srf;
d9194 1
a9194 1
struct cnurb *
d9198 3
a9200 3
	struct cnurb *crv,*next_crv;
	struct cnurb *new_crv=(struct cnurb *)NULL;
	struct cnurb *linear_crv;
d9218 1
a9218 1
	for( RT_LIST_FOR( crv, cnurb, crv_head ) )
d9226 1
a9226 1
		while( crv->knot.knots[++i] == crv->knot.knots[0] );
d9234 3
a9236 3
		i = crv->knot.k_size - 1;
		while( crv->knot.knots[--i] == crv->knot.knots[crv->knot.k_size - 1] );
		if( crv->knot.k_size - i - 1 != crv->order )
d9259 1
a9259 1
		crv = RT_LIST_FIRST( cnurb, crv_head );
d9265 1
a9265 1
	for( RT_LIST_FOR( crv, cnurb, crv_head ) )
d9276 1
a9276 1
	crv = RT_LIST_FIRST( cnurb, crv_head );
d9278 1
a9278 1
	next_crv = RT_LIST_NEXT( cnurb, &crv->l );
d9302 1
a9302 1
			next_crv = RT_LIST_NEXT( cnurb, &crv->l );
d9313 1
a9313 1
	crv = RT_LIST_FIRST( cnurb, crv_head );
d9315 1
a9315 1
	for( RT_LIST_FOR( crv, cnurb, crv_head ) )
d9318 1
a9318 1
		knot_length += (crv->knot.k_size - crv->order - 1);
d9325 1
a9325 1
	crv = RT_LIST_FIRST( cnurb, crv_head );
d9329 1
a9329 1
		new_crv->knot.knots[++knot_index] = crv->knot.knots[i];
d9336 1
a9336 1
	knot_delta = new_crv->knot.knots[knot_index];
d9339 1
a9339 1
	for( RT_LIST_FOR( crv, cnurb, crv_head ) )
d9342 1
a9342 1
		for( i=crv->order ; i<crv->knot.k_size-crv->order ; i++ )
d9344 1
a9344 1
			new_crv->knot.knots[++knot_index] = crv->knot.knots[i] + knot_delta;
d9349 1
a9349 1
			new_crv->knot.knots[++knot_index] = crv->knot.knots[crv->knot.k_size-1] + knot_delta;
d9351 2
a9352 2
		knot_delta += crv->knot.knots[crv->knot.k_size-1];
		last_knot = new_crv->knot.knots[knot_index];
d9361 1
a9361 1
	new_crv->knot.knots[++knot_index] = last_knot;
d9377 1
a9377 1
struct cnurb *
d9385 1
a9385 1
	struct cnurb *crv;
d9432 1
a9432 1
			return( (struct cnurb *)NULL );
d9439 1
a9439 1
			return( (struct cnurb *)NULL );
d9446 1
a9446 1
			return( (struct cnurb *)NULL );
d9474 1
a9474 1
		return( (struct cnurb *)NULL );
d9506 1
a9506 1
			return( (struct cnurb *)NULL );
d9514 1
a9514 1
			crv->knot.knots[i] = 0.0;
d9516 1
a9516 1
			crv->knot.knots[i] = 1.0;
d9575 1
a9575 1
	/* join the arc segments into one cnurb */
@


11.32
log
@Added nmg_get_fu_snurb_norm( fu, vu, norm )
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 11.31 1995/11/06 17:15:41 jra Exp $ (ARL)";
d50 1
a50 1
nmg_get_fu_snurb_norm( fu, vu, norm )
d52 43
a94 1
CONST struct vertexuse *vu;
a98 2
	struct vertexuse_a_cnurb *va;
	point_t uvw;
a100 1
	NMG_CK_VERTEXUSE( vu );
d103 1
d106 2
a107 2
		rt_log( "nmg_get_fu_snurb_norm: face has no geometry (x%x)\n", f );
		rt_bomb( "nmg_get_fu_snurb_norm: bad face\n" );
d111 2
a112 2
		rt_log( "nmg_get_fu_snurb_norm: face is not a NURB face (x%x)\n", f );
		rt_bomb( "nmg_get_fu_snurb_norm: bad face\n" );
d115 21
d138 2
a139 2
		rt_log( "nmg_get_fu_snurb_norm: vertexuse does not have an attribute (x%x)\n", vu );
		rt_bomb( "nmg_get_fu_snurb_norm: bad VU\n" );
d144 2
a145 2
		rt_log( "nmg_get_fu_snurb_norm: vertexuse does not have a cnurb attribute (x%x)\n", vu );
		rt_bomb( "nmg_get_fu_snurb_norm: bad VU\n" );
d149 3
a151 8
	VMOVE( uvw, va->param );
	if( uvw[2] )
	{
		uvw[0] = uvw[0]/uvw[2];
		uvw[1] = uvw[1]/uvw[2];
	}
	nmg_hack_snurb( &srf, f->g.snurb_p );
	rt_nurb_s_norm( &srf, uvw[0], uvw[1], norm );
a152 2
	if( (fu->orientation != OT_SAME) != (f->flip != 0 ) )
		VREVERSE( norm, norm )
d421 1
a421 1
			nmg_get_fu_snurb_norm( fu, eu1->vu_p, normal );
@


11.31
log
@Added nmg_break_edges() and nmg_break_edge_at_verts().
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 11.30 1995/10/31 20:26:28 jra Exp jra $ (ARL)";
d50 52
d364 5
a368 1
		NMG_GET_FU_NORMAL( normal, fu );
d3432 5
d3499 2
@


11.30
log
@Modified nmg_find+_top

Modified nmg_find_top_face to not depend on radial edge structures.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 11.29 1995/10/19 15:00:23 jra Exp $ (ARL)";
d9467 97
@


11.29
log
@Mods to nmg_simple_vertex_solve() and nmg_complex_vertex_solve().
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 11.28 1995/09/06 13:11:11 jra Exp jra $ (ARL)";
d115 1
d175 4
d250 12
a261 1
	/* now find the face containing e_top with "left-pointing vector" having the most extreme slope */
d267 1
a267 4
	eu = e_top->eu_p;
	eu1 = eu;
	done = 0;
	while( !done )
d269 2
a270 9
		/* don't bother with anything but faces */
		if( *eu1->up.magic_p == NMG_LOOPUSE_MAGIC )
		{
			lu = eu1->up.lu_p;
			NMG_CK_LOOPUSE( lu );
			if( *lu->up.magic_p == NMG_FACEUSE_MAGIC )
			{
				vect_t left;
				vect_t edge_dir;
d272 3
a274 3
				/* fu is a faceuse containing "eu1" */
				fu = lu->up.fu_p;
				NMG_CK_FACEUSE( fu );
d276 2
a277 5
				/* skip faces from other shells and flagged faceuses */
				if( fu->s_p != s || NMG_INDEX_TEST( flags, fu->f_p ) )
				{
					/* go on to next radial face */
					eu1 = eu1->eumate_p->radial_p;
d279 3
a281 3
					/* check if we are back where we started */
					if( eu1 == eu )
						done = 1;
d283 3
a285 2
					continue;
				}
d287 4
a290 2
				/* make a vector in the direction of "eu1" */
				VSUB2( edge_dir , eu1->vu_p->v_p->vg_p->coord , eu1->eumate_p->vu_p->v_p->vg_p->coord );
d292 3
a294 2
				/* find the normal for this faceuse */
				NMG_GET_FU_NORMAL( normal, fu );
d296 3
a298 2
				/* edge direction cross normal gives vector in face */
				VCROSS( left , edge_dir , normal );
d300 26
a325 2
				/* unitize to get slope */
				VUNITIZE( left );
d327 17
a343 17
				/* check against current most extreme slope */
				if( bottommost )
				{
					if( left[dir] < extreme_slope )
					{
						extreme_slope = left[dir];
						f_top = fu->f_p;
					}
				}
				else
				{
					if( left[dir] > extreme_slope )
					{
						extreme_slope = left[dir];
						f_top = fu->f_p;
					}
				}
a345 6
		/* go on to next radial face */
		eu1 = eu1->eumate_p->radial_p;

		/* check if we are back where we started */
		if( eu1 == eu )
			done = 1;
@


11.28
log
@Modified nmg_purge_unwanted_intersection_points() to accept an array of distances
along intersection ray corresponding to the list of vertices.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 11.27 1995/07/14 19:11:24 jra Exp $ (ARL)";
d47 2
a1148 4
				{
					rt_log( "Shell has an opening at edge ( %g %g %g ) -> ( %g %g %g )\n",
						V3ARGS( eu->vu_p->v_p->vg_p->coord ),
						V3ARGS( eu->eumate_p->vu_p->v_p->vg_p->coord ) );
a1149 1
				}
d4711 1
a4711 1
nmg_simple_vertex_solve( new_v , faces )
d4714 1
d4720 6
d4728 13
d4743 1
d4753 1
d4766 1
a4766 1
		case 2:		/* create a third plane perpendicular to first two */
d4770 30
a4799 11
			VCROSS( pl1 , fp1->g.plane_p->N , fp2->g.plane_p->N );
			pl1[3] = VDOT( vg->coord , pl1 );
			if( rt_mkpoint_3planes( vg->coord , fp1->g.plane_p->N , fp2->g.plane_p->N , pl1 ) )
			{
				rt_log( "nmg_simple_vertex_solve: Cannot find new coords for two planes\n" );
				rt_log( "\tplanes are ( %f %f %f %f ) and ( %f %f %f %f )\n",
					V4ARGS( fp1->g.plane_p->N ) ,
					V4ARGS( fp2->g.plane_p->N ) );
				rt_log( "\tcalculated third plane is ( %f %f %f %f )\n" , V4ARGS( pl1 ) );
				failed = 1;
				break;
d6779 1
a6779 1
 *	distance to all the intersectinf faces
d6787 1
a6787 1
nmg_complex_vertex_solve( new_v , faces , approximate , tol )
d6790 1
d6813 5
d6819 1
a6819 1
		planes = (plane_t *)rt_calloc( NMG_TBL_END( faces ) , sizeof( plane_t ) , "nmg_complex_vertex_solve: planes" );
d6825 69
d6896 1
a6896 1
		if( rt_isect_planes( new_v->vg_p->coord , (CONST plane_t *)planes , NMG_TBL_END( faces ) ) )
d7363 1
a7363 1
					if( nmg_simple_vertex_solve( vu->v_p , &faces ) )
d7413 1
a7413 1
						if( nmg_simple_vertex_solve( vu->v_p , &faces ) )
d7768 19
d7788 62
d7857 1
a7857 1
	int i;
d7863 1
d7889 1
a7889 1
		return;
d7930 1
a7930 2
			i++;
			if( i >= NMG_TBL_END( verts ) )
d7936 1
a7936 1
			if( verts_in_face >= max_vert_no )
d7941 1
a7941 1

d7946 3
d7950 3
a7952 3
		if( rt_g.NMG_debug & DEBUG_BASIC )
		{
			int debug_int;
d7954 5
a7958 5
			rt_log( "make face:\n" );
			for( debug_int=0 ; debug_int<verts_in_face ; debug_int++ )
				rt_log( "\tx%x ( %f %f %f )\n" , face_verts[debug_int],
					V3ARGS( face_verts[debug_int]->vg_p->coord ) );
		}
a7959 3
		if( !still_collinear )
		{
			/* make the new face */
d7974 1
d7977 1
d8036 8
a8043 2
		struct vertex *v1,*v2;
		struct edgeuse *eu;
d8045 18
a8062 3
		/* didn't make last face, must be collinear points
		 * so split an edge to get the last vertex in
		 */
d8064 18
a8081 2
		v1 = (struct vertex *)NMG_TBL_GET( verts , NMG_TBL_END( verts ) - 2 );
		NMG_CK_VERTEX( v1 );
d8083 4
a8086 2
		v2 = (struct vertex *)NMG_TBL_GET( verts , NMG_TBL_END( verts ) - 1 );
		NMG_CK_VERTEX( v2 );
d8088 24
a8111 2
		eu = nmg_findeu( vpb , v1 , dst , (struct edgeuse *)NULL , 1 );
		if( !eu )
d8113 3
a8115 2
			rt_log( "nmg_make_connect_faces: Cannot find eu from x%x to x%x\n" , vpb , v1 );
			rt_bomb( "\n" );
d8118 62
a8179 1
		(void) nmg_esplit( v2 , eu, 0 );
d8181 15
a8195 2
		if( rt_g.NMG_debug & DEBUG_BASIC )
			rt_log( "Split eu x%x (x%x -> x%x) at vertex x%x\n" , eu , eu->vu_p->v_p , eu->eumate_p->vu_p->v_p, v2 );
d8197 1
d8221 1
d8236 2
d8246 11
a8256 1
	if( nmg_ck_closed_surf( dst , tol ) )
d8262 1
a8262 1
	if( nmg_ck_closed_surf( src , tol ) )
d8295 1
d8373 1
a8373 1
	while( NMG_TBL_END( &dangles ) )
d8378 1
a8378 1
		dang = (struct dangle *)NMG_TBL_GET( &dangles , NMG_TBL_END( &dangles ) - 1 );
d8385 1
a8385 1
			nmg_make_connect_faces( dst , dang->va , dang->vb , verts , tol );
d8396 70
d8470 1
d8522 5
d8529 1
a8529 1
		if( nmg_simple_vertex_solve( new_v , &faces ) )
d8537 1
a8537 1
		if( nmg_complex_vertex_solve( new_v , &faces , approximate , tol ) )
@


11.27
log
@Modified rt_dist_line3_line3() to allow zero tolerance.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 11.26 1995/06/27 19:45:57 jra Exp jra $ (ARL)";
d2071 1
a2071 1
nmg_purge_unwanted_intersection_points(vert_list, fu, tol)
d2073 1
d2102 1
d2104 2
d2109 1
d2195 1
d2197 2
d2202 1
@


11.26
log
@Mods to rt_join_cnurbs() and rt_arcxy_to_cnurb().
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 11.25 1995/06/23 21:07:39 jra Exp jra $ (ARL)";
a1456 2
	{
		rt_log( "nmg_calc_face_plane: Cannot get general direction for face normal for fu x%x\n" , fu );
a1457 1
	}
d1778 2
d1783 11
a1793 1
	if( !NEAR_ZERO( MAGSQ( d1 ) - 1.0 , tol->dist_sq ) )
d1799 1
a1799 1
	if( !NEAR_ZERO( MAGSQ( d2 ) - 1.0 , tol->dist_sq ) )
d1809 1
a1809 1
		if( rt_dist_line_point( p1 , d1 , p2 ) > tol->dist )
d1824 1
a1824 1
	if( min_dist < tol->dist )
@


11.25
log
@Added rt_join_cnurbs() and rt_arcxy_to_cnurb().
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 11.24 1995/05/05 21:04:11 jra Exp jra $ (ARL)";
d8608 2
a8609 1
 * The list is destroyed upon succesful completion.
d8613 1
a8613 2
 *	cnurbs on the list. Linear segments may be added
 *	where consective cnurbs do not have matching endpoints.
d8696 1
a8696 1
	/* Add linear segments where segment endpoints don't match */
d8702 18
a8719 1
		if( VEQUAL( &crv->ctl_points[(crv->c_size-1)*ncoords], next_crv->ctl_points ) )
d8727 4
a8730 27
		/* Need to add a linear segment here */
		linear_crv = rt_nurb_new_cnurb( max_order, 2*max_order, 3, pt_type );

		/* Set knots for the correct order */
		for( i=0 ; i<max_order ; i++ )
			linear_crv->knot.knots[i] = 0.0;
		for( i=max_order ; i<2*max_order ; i++ )
			linear_crv->knot.knots[i] = 1.0;

		/* start point */
		VMOVE( linear_crv->ctl_points, &crv->ctl_points[(crv->c_size-1)*ncoords] );
		if( ncoords == 4 )
			linear_crv->ctl_points[3] = 1.0;

		/* end point */
		VMOVE( &linear_crv->ctl_points[2*ncoords], next_crv->ctl_points );
		if( ncoords == 4 )
			linear_crv->ctl_points[11] = 1.0;

		/* mid point */
		VBLEND2( &linear_crv->ctl_points[ncoords], 0.5, linear_crv->ctl_points, 0.5, &linear_crv->ctl_points[2*ncoords] );
		if( ncoords == 4 )
			linear_crv->ctl_points[7] = 1.0;

		RT_LIST_APPEND( &crv->l, &linear_crv->l );
		crv = next_crv;
		next_crv = RT_LIST_NEXT( cnurb, &crv->l );
d8779 1
a8779 2
			for( j=0 ; j<ncoords ; j++ )
				new_crv->ctl_points[ctl_index*ncoords+j] = crv->ctl_points[i*ncoords+j];
a8783 7
	/* Free cnurbs in list */
	while( RT_LIST_WHILE( crv, cnurb, crv_head ) )
	{
		RT_LIST_DEQUEUE( &crv->l );
		rt_nurb_free_cnurb( crv );
	}

d8787 1
a8787 1
/*	R T _ A R C X Y _ T O _ C N U R B
d8789 2
a8790 1
 * Convert a 2D arc in the XY-plane to a NURB curve
d8792 4
a8795 1
 *	coordinate value. The arc is constructed counter-clockwise
d8799 5
a8803 4
rt_arcxy_to_cnurb( center, start, end, tol )
point_t center;
point_t start;
point_t end;
d8808 3
d8820 1
d8822 1
a8822 1
	int nsegs;
d8827 17
a8843 6
	/* check for points at same Z-coordinate value */
	if( center[Z] - start[Z] > tol->dist )
	{
		rt_log( "rt_arcxy_to_cnurb: center and start points not at same Z value (%g vs %g)\n",
				center[Z], start[Z] );
		return( (struct cnurb *)NULL );
d8846 1
a8846 1
	if( end[Z] - start[Z] > tol->dist )
d8848 14
a8861 4
		rt_log( "rt_arcxy_to_cnurb: end and start points not at same Z value (%g vs %g)\n",
				end[Z], start[Z] );
		return( (struct cnurb *)NULL );
	}
d8863 6
a8868 5
	if( end[Z] - center[Z] > tol->dist )
	{
		rt_log( "rt_arcxy_to_cnurb: end and center points not at same Z value (%g vs %g)\n",
				end[Z], center[Z] );
		return( (struct cnurb *)NULL );
d8871 2
a8872 2
	/* point type is x, y, z with weighting factor (rational) */
	pt_type = RT_NURB_MAKE_PT_TYPE( 4, RT_NURB_PT_XYZ, RT_NURB_PT_RATIONAL );
d8875 14
a8888 4
	VSUB2( v1, start, center );
	radius = MAGNITUDE( v1 );
	VSUB2( v2, end, center );
	tmp_radius = MAGNITUDE( v2 );
d8891 1
a8891 1
	if( radius - tmp_radius > tol->dist )
d8893 1
a8893 1
		rt_log( "rt_arcxy_to_cnurb: distances from center to start and center to end are different\n" );
d8925 1
a8925 1
			rt_log( "rt_arcxy_to_cnurb: Cannot calculate second control point\n" );
d8940 2
a8941 2
		VMOVE( crv->ctl_points, start );
		VMOVE( &crv->ctl_points[8], end );
d8944 2
a8945 2
		crv->ctl_points[3] = 1.0;
		crv->ctl_points[11] = 1.0;
d8948 1
a8948 1
		VJOIN1( &crv->ctl_points[4], start, dist1, t1 );
d8951 1
a8951 1
		crv->ctl_points[7] = cos( angle/2.0 );
d8954 1
a8954 1
		VSCALE( &crv->ctl_points[4], &crv->ctl_points[4], crv->ctl_points[7] );
d8992 1
a8992 1
		crv = rt_arcxy_to_cnurb( center, start1, end1, tol );
@


11.24
log
@Modified nmg_purge_unwanted_intersection_points() to purge VU's
with bad magic (killed by nmg_repair_v_near_v()).
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 11.23 1995/05/02 20:46:56 jra Exp jra $ (ARL)";
d31 1
d43 1
d8604 369
@


11.23
log
@Fixed infinite loop in nmg_kill_cracks().
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 11.22 1995/04/27 12:10:07 jra Exp jra $ (ARL)";
d2085 12
@


11.22
log
@Added nmg_intersect_loops_self().
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 11.21 1995/04/07 16:55:04 jra Exp jra $ (ARL)";
a8214 2
				{
					eu = RT_LIST_PNEXT( edgeuse, &eu->l );
a8215 1
				}
@


11.21
log
@Fixed a bug in nmg_find_top_face().
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/librt/RCS/nmg_misc.c,v 11.20 95/04/04 13:23:46 jra Exp Locker: jra $ (ARL)";
d750 2
a8193 1
			struct edgeuse *eu_prev;
d8206 2
a8207 2
			eu = RT_LIST_FIRST( edgeuse, &lu->down_hd );
			while( RT_LIST_NOT_HEAD( eu, &lu->down_hd ) )
a8219 5
				if( eu != RT_LIST_FIRST( edgeuse, &lu->down_hd ) )
					eu_prev = RT_LIST_PREV( edgeuse, &eu->l );
				else
					eu_prev = (struct edgeuse *)NULL;

d8228 1
a8228 4
				if( eu_prev )
					eu = eu_prev;
				else
					eu = RT_LIST_FIRST( edgeuse, &lu->down_hd );
d8482 111
@


11.20
log
@Added some missing nmg_tbl( XXX, TBL_FREE, 0 ) class.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 11.19 1995/04/03 20:52:26 jra Exp $ (ARL)";
d352 1
a352 1
	for( *dir=X ; *dir<=Z ; *dir++ )
a3311 2
		if( NMG_INDEX_TEST( flags, f_top ) )
			rt_log(" nmg_find_top_face returned a flagged face %x\n" , f_top );
d3319 4
@


11.19
log
@Added a missing TBL_FREE to nmg_isect_shell_self().
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 11.18 1995/03/24 16:05:02 jra Exp jra $ (ARL)";
a1479 1
		nmg_tbl( &verts , TBL_INIT , (long *)NULL );
a1490 1
		nmg_tbl( &verts , TBL_INIT , (long *)NULL );
@


11.18
log
@Fixed bug in nmg_find_top_face. Added nmg_make_faces_within_tol().
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 11.17 95/03/17 15:02:48 jra Exp Locker: jra $ (ARL)";
d984 1
a984 1

@


11.17
log
@added nmg_kill_zero_length_edgeuses().
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 11.16 95/03/09 13:31:15 jra Exp Locker: jra $ (ARL)";
d132 2
d173 2
d176 7
a182 3
		if( *vu->up.magic_p == NMG_EDGEUSE_MAGIC )
		{
			struct vertexuse *vu1;
d184 3
a186 2
			eu = vu->up.eu_p;
			NMG_CK_EDGEUSE( eu );
d188 3
a190 3
			/* skip wire edges */
			if( *eu->up.magic_p != NMG_LOOPUSE_MAGIC )
				continue;
d192 3
a194 3
			/* skip wire loops */
			if( *eu->up.lu_p->up.magic_p != NMG_FACEUSE_MAGIC )
				continue;
d196 3
a198 3
			/* skip finished faces */
			if( NMG_INDEX_TEST( flags , eu->up.lu_p->up.fu_p->f_p ) )
				continue;
d200 3
a202 3
			/* skip edges from other shells */
			if( nmg_find_s_of_eu( eu ) != s )
				continue;
d204 3
a206 3
			/* get vertex at other end of this edge */
			vu1 = eu->eumate_p->vu_p;
			NMG_CK_VERTEXUSE( vu1 );
d208 3
a210 3
			/* make a unit vector in direction of edgeuse */
			VSUB2( edge , vu1->v_p->vg_p->coord , vu->v_p->vg_p->coord );
			VUNITIZE( edge );
d212 4
a215 2
			/* check against current maximum slope */
			if( bottommost )
d217 2
a218 5
				if( edge[dir] < extreme_slope )
				{
					extreme_slope = edge[dir];
					e_top = eu->e_p;
				}
d220 4
a223 1
			else
d225 2
a226 5
				if( edge[dir] > extreme_slope )
				{
					extreme_slope = edge[dir];
					e_top = eu->e_p;
				}
d266 2
a267 2
				/* skip faces from other shells */
				if( fu->s_p != s )
a391 1
	struct face *ext_f;
a417 1
	ext_f = top_faces[0].f;
d3314 2
d8184 1
a8184 2
			&& fu_next == fu->fumate_p
			&& fu_next->orientation != OT_SAME )
a8186 6
		if( fu->orientation != OT_SAME )
		{
			fu = fu_next;
			continue;
		}

a8197 2
			while( lu_next != lu->lumate_p && RT_LIST_NOT_HEAD( lu_next, &fu->lu_hd ) )
				lu_next = RT_LIST_PNEXT( loopuse, &lu_next->l );
a8211 1

d8380 109
@


11.16
log
@Added nmg_find_zero_length_edges().
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 11.15 95/03/06 10:57:25 jra Exp Locker: jra $ (ARL)";
d8264 118
@


11.15
log
@Allowed nmg_find_top_face to look at OT_OPPOSITE loopuses.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 11.14 95/03/02 15:45:39 jra Exp Locker: jra $ (ARL)";
d44 39
@


11.14
log
@Got nmg_fix_normals working again.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 11.13 95/03/01 16:51:25 jra Exp Locker: jra $ (ARL)";
d210 1
a210 1
			if( *lu->up.magic_p == NMG_FACEUSE_MAGIC && lu->orientation == OT_SAME )
@


11.13
log
@modified nmg_find_top_face to look in more than just the Z direction.
replaced call to nmg_reverse_face_and_radials() in nmg_fix_normals with a call to nmg_reverse_face().
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 11.12 95/03/01 06:20:37 mike Exp Locker: jra $ (ARL)";
d1383 1
d1434 1
d1446 1
d1452 1
a1452 1
	 * Make sure we are dealing with OT_SAME faceuse.
d1454 1
a1454 3
	if( fu->orientation != OT_SAME )
		fu = fu->fumate_p;
	if( fu->orientation != OT_SAME )
d1456 8
a1463 3
		rt_log( "nmg_calc_face_plane: fu x%x has no OT_SAME use\n" , fu );
		nmg_tbl( &verts , TBL_FREE , (long *)NULL );
		return( 1 );
d1470 2
d1510 1
a1510 1
		/* get distance from plane to orgin */
a1511 3
		pl[H] = VDOT( pl , vsum )/(fastf_t)(NMG_TBL_END( &verts));

		/* unitize direction vector */
d1514 6
d1565 2
a1566 1
			pl[H] = VDOT( pl , vsum )/(fastf_t)(NMG_TBL_END( &verts));
d1568 3
d2952 1
a2952 1
#if 0
d2966 2
d2976 9
d2986 27
a3012 1
	(void)nmg_face_fix_radial_parity( fu , tol );
d3187 1
a3187 1
#if 0
d3302 1
a3302 1
			nmg_reverse_face( fu );
d3311 1
a3311 1

d3314 1
d3321 1
a3321 1

d3324 1
d3680 1
@


11.12
log
@Changed over to use nmg_s_radial_harmonize()
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 11.11 95/02/27 16:28:48 jra Exp Locker: mike $ (ARL)";
d53 1
a53 1
 *	dir must be X,Y,Z, -X, -Y, or -Z.
d80 1
d88 1
a88 1

d277 4
d291 4
d298 1
a298 1
nmg_find_top_face( s , flags )
d300 1
a303 1
	int dir;
d305 2
a306 4

	/* try positive directions first */
	for( dir=X ; dir<=Z ; dir++ )
		if( (top_face=nmg_find_top_face_in_dir( s, dir, flags )) != (struct face *)NULL )
a308 5
	/* now try negative directions */
	for( dir=X ; dir<=Z ; dir++ )
		if( (top_face=nmg_find_top_face_in_dir( s, -dir, flags )) != (struct face *)NULL )
			return( top_face );

d311 1
d331 1
d350 1
d370 2
a371 1
	top_faces[0].f = nmg_find_top_face( outer_shell , flags );
d386 11
a396 5
		top_faces[i].f = nmg_find_top_face( s , flags );
		fu = top_faces[i].f->fu_p;
		if( fu->orientation != OT_SAME )
			fu = fu->fumate_p;
		NMG_GET_FU_NORMAL( top_faces[i].normal , fu );
d417 1
d425 1
a425 1
		if( normal[Z] < 0.0  )
d486 1
d488 5
d499 1
d507 13
a519 1
				if( test_norm[Z] > 0.0 )
d521 2
a522 9
					if( !V3RPP1_IN_RPP2( void_s->sa_p->min_pt , void_s->sa_p->max_pt , test_s->sa_p->min_pt , test_s->sa_p->max_pt ) )
						continue;

					if( test_f->max_pt[Z] > int_f->max_pt[Z]
					    && test_f->max_pt[Z] < ext_f->max_pt[Z] )
					{
						wrong_void = 1;
						break;
					}
d524 1
d560 1
d596 1
a596 1
		f = nmg_find_top_face( s , flags );
d604 1
a604 1
		if( normal[Z] > 0.0 )
d1177 65
d1351 1
a1351 1
/*	N M G _ C A L C _ F A C E _ G
d1353 1
a1353 1
 * Calculate face geometry using a least squares fit.
d1356 2
a1357 1
 * vertices in fu will participate.
a1362 5
 * This routine is not efficient for use with newly created
 * faces as it calculates the direction of the face normal
 * (old_pl), then fits a plane to the vertices. For faces
 * with a single loop, this is calculating the same thing twice.
 *
d1366 1
d1370 1
a1370 1
nmg_calc_face_g( fu_in )
d1372 1
d1376 1
a1376 1
	plane_t pl,old_pl;
d1387 1
a1388 2
	nmg_tbl( &verts , TBL_INIT , (long *)NULL );

d1391 21
d1418 16
d1436 9
a1444 1
	else
d1446 1
d1455 1
a1455 1
		rt_log( "nmg_calc_face_g: fu x%x has no OT_SAME use\n" , fu );
a1459 26
	/* find an OT_SAME loop to use for direction calculation */
	for( RT_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
	{
		if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
			continue;

		if( !got_dir && lu->orientation == OT_SAME )
		{
			fastf_t area;

			/* get direction for face normal */
			area = nmg_loop_plane_area( lu , old_pl );
			if( area > 0.0 )
			{
				got_dir = 1;
				break;
			}
		}
	}

	if( !got_dir )
	{
		rt_log( "nmg_calc_face_g: Cannot get direction for face normal for fu x%x\n" , fu );
		return( 1 );
	}

a1511 3

		/* assign new geometry to face */
		nmg_face_g( fu , pl );
a1558 3

			/* assign new geometry to face */
			nmg_face_g( fu , pl );
d1562 1
a1562 1
			rt_log( "nmg_calc_face_g: Cannot calculate plane for fu x%x\n" , fu );
d1573 21
d2698 1
a2698 1
			if( nmg_fu_planeeqn( fu , tol ) )
d2967 2
a2968 3
 * by finding the topmost face (in the z-direction) and looking at
 * the Z component of the OT_SAME faceuse. Positive is an exterior
 * shell, negative is a void shell.
d2984 1
d2994 1
a2994 1
	f = nmg_find_top_face( s , flags );
d2998 3
d3013 1
a3013 1
	if( normal[Z] == 0.0 )
d3015 1
a3015 1
	if( normal[Z] < 0.0 )
d3133 2
d3213 1
d3216 8
a3223 1
		f_top = nmg_find_top_face( s , flags );	
d3239 1
a3239 1
			rt_log( "\tnmg_fix_normals: top face is x%x, OT_SAME use is x%x\n", f_top, fu );
d3243 3
a3245 3
		/* f_top is the topmost face (in the +z direction), so its OT_SAME use should have a
		 * normal with a positive z component */
		if( normal[Z] < 0.0 )
d3250 1
a3250 1
			nmg_reverse_face_and_radials( fu , tol );
d5970 1
a5970 1
		if( nmg_fu_planeeqn( new_fu , tol ) )
@


11.11
log
@modified nmg_find_top_face() to check all six cardinal directions before giving up.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 11.10 95/02/23 14:44:50 jra Exp Locker: jra $ (ARL)";
d2813 2
d2838 1
d3006 1
d3015 6
d3123 3
d3131 3
@


11.10
log
@Added nmg_kill_cracks().
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 11.9 95/02/03 16:22:42 jra Exp Locker: jra $ (ARL)";
a44 1

d46 1
a46 1
 *	N M G _ F I N D _ T O P _ F A C E
d48 1
a48 1
 *	Finds the topmost face in a shell (in z-direction).
d52 2
a54 1

d56 1
a56 1
nmg_find_top_face( s , flags )
d58 1
d61 2
a62 2
	fastf_t max_z=(-MAX_FASTF);
	fastf_t max_slope=(-MAX_FASTF);
d64 1
d73 1
d76 1
a76 1
		rt_log( "nmg_find_top_face( s = x%x , flags = x%x )\n" , s , flags );
d80 9
a88 1
	/* find vertex with greatest z coordinate */
d102 1
a102 1
					if( eu->vu_p->v_p->vg_p->coord[Z] > max_z )
d104 5
a108 2
						max_z = eu->vu_p->v_p->vg_p->coord[Z];
						vp_top = eu->vu_p->v_p;
d110 8
d124 1
a124 1
		rt_log( "Fix_normals: Could not find uppermost vertex" );
d128 1
a128 1
	/* find edge from vp_top with largest slope in +z direction */
d164 1
a164 1
			if( edge[Z] > max_slope )
d166 5
a170 2
				max_slope = edge[Z];
				e_top = eu->e_p;
d172 8
d188 1
a188 2
	/* now find the face containing e_top with "left-pointing vector" having the greatest slope */
	max_slope = (-MAX_FASTF);
d190 10
a212 1
				vect_t normal;
d237 1
a237 1
				/* edge direction cross normal gives vetor in face */
d243 2
a244 2
				/* check against current max slope */
				if( left[Z] > max_slope )
d246 5
a250 2
					max_slope = left[Z];
					f_top = fu->f_p;
d252 8
d272 1
a272 1
		rt_log( "Nmg_find_top_face: Could not find uppermost face" );
d277 34
@


11.9
log
@Added a few debug prints to nmg_purge_unwanted_intersection_points.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 11.8 95/02/01 18:35:49 mike Exp Locker: jra $ (ARL)";
d7817 114
@


11.8
log
@Made allocation of flags[] array more conservative.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 11.7 95/01/27 13:32:28 jra Exp Locker: mike $ (ARL)";
d1808 1
d1810 2
d1904 3
@


11.7
log
@Small bug in nmg_close_shell.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 11.6 95/01/24 16:57:19 jra Exp Locker: jra $ (ARL)";
d1958 1
a1958 1
	flags = (int *)rt_calloc( m->maxindex, sizeof(int), "rebound flags[]" );
d2554 1
a2554 1
	(*trans_tbl) = (long **)rt_calloc(m->maxindex*2, sizeof(long *),
d3467 1
a3467 1
	sl_state.flags = (long *)rt_calloc( m->maxindex , sizeof( long ) , "nmg_split_loops_into_faces: flags" );
d3525 1
a3525 1
	flags = (long *)rt_calloc( m->maxindex , sizeof( long ) , "nmg_decompose_shell: flags" );
d4015 1
d4038 1
a4039 1

d4049 1
d4056 1
a4056 1
		/* rt_log("nmg_unbreak_handler: edge geom not shared\n"); */
d4070 2
a4071 1
	if( nmg_unbreak_edge( eu1 ) != 0 )  return;
d4104 1
a4104 1
	ub_state.flags = (long *)rt_calloc( m->maxindex+2 , sizeof( long ) , "nmg_unbreak_region_edges: flags" );
@


11.6
log
@Added nmg_face_bb calls to nmg_split_loops_into_faces.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 11.5 95/01/22 17:34:08 jra Exp Locker: jra $ (ARL)";
d2292 5
a2296 2
				/* already have face geometry, so don't need to call nmg_fu_planeeqn */
				nmg_face_g( fu , pl1 );
@


11.5
log
@Moved nmg_check_closed shell and used nmg_next_radial_eu() to ignore other shells.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 11.4 95/01/19 09:28:54 jra Exp Locker: jra $ (ARL)";
d3317 1
d3330 3
d3349 4
d3382 1
d3384 1
d3387 1
d3420 1
@


11.4
log
@Added nmg_check_closed_shell. Added call to nmg_face_bb in nmg_close_shell.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 11.3 95/01/13 16:20:45 jra Exp $ (ARL)";
a44 16
/*	N M G _ C H E C K _ C L O S E D _ S H E L L
 *
 *	Looks at every eu in OT_SAME fu's. If any eu
 *	has no radials, then it must be the edge of a
 *	dangling face and therfore the edge of an opening.
 *
 *  returns:
 *	0 - O.K.
 *	1 - found a hole
 */
int
nmg_check_closed_shell( s , tol )
struct shell *s;
struct rt_tol *tol;
{
	struct faceuse *fu;
a45 37
	NMG_CK_SHELL( s );
	RT_CK_TOL( tol );

	for( RT_LIST_FOR( fu , faceuse , &s->fu_hd ) )
	{
		struct loopuse *lu;

		NMG_CK_FACEUSE( fu );

		if( fu->orientation != OT_SAME )
			continue;

		for( RT_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
		{
			struct edgeuse *eu;

			NMG_CK_LOOPUSE( lu );

			if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
				continue;

			for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
			{
				if( eu->eumate_p == eu->radial_p )
				{
					rt_log( "Shell has an opening at edge ( %g %g %g ) -> ( %g %g %g )\n",
						V3ARGS( eu->vu_p->v_p->vg_p->coord ),
						V3ARGS( eu->eumate_p->vu_p->v_p->vg_p->coord ) );
					return( 1 );
				}
			}
		}
	}

	return( 0 );
}

d939 57
@


11.3
log
@Added some debug output.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 11.2 95/01/12 15:07:45 jra Exp Locker: jra $ (ARL)";
d45 54
d2290 3
@


11.2
log
@Fixed bug in nmg_make_connect_face.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 11.1 95/01/04 09:57:53 mike Rel4_4 Locker: jra $ (ARL)";
d2934 6
d2943 4
d2948 1
d2962 9
@


11.1
log
@Release_4.4
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.165 94/12/30 00:42:35 mike Exp $ (ARL)";
d7246 1
d7257 2
d7260 1
d7263 2
d7266 1
d7283 1
a7283 6
		/* make the new face */
		new_fu = nmg_cface( dst , face_verts , verts_in_face );
		lu = RT_LIST_FIRST( loopuse , &new_fu->lu_hd );
		area = nmg_loop_plane_area( lu , pl );

		if( area <= 0.0 )
d7285 4
a7288 6
			rt_bomb( "nmg_make_connect_faces: Failed to calculate plane eqn\n" );
			nmg_kfu( new_fu );
		}
		else
		{
			made_face = 1;
d7290 10
a7299 1
			nmg_face_g( new_fu , pl );
d7301 5
a7305 2
			/* glue this face in */
			nmg_glue_face_in_shell( new_fu , dst , tol );
d7307 2
@


1.165
log
@DEC Alpha
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.164 94/12/19 16:41:21 jra Exp Locker: mike $ (ARL)";
@


1.164
log
@MOds for CRAY.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.163 94/11/29 12:29:44 jra Exp $ (ARL)";
d1699 1
a1699 1
		bcopy(d.t->buffer, &b->buffer[b->end], d.t->end*sizeof(p));
d1705 1
a1705 1
		bzero(b, sizeof(struct nmg_ptbl));
@


1.163
log
@Modified nmg_move_edge_thru_pt to handle edges of dangling faces.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.162 94/11/22 14:23:19 jra Exp Locker: jra $ (ARL)";
d56 1
a56 1
struct shell *s;
d6191 1
a6191 1
		if( rt_isect_planes( new_v->vg_p->coord , planes , pl_count ) )
d6303 1
a6303 1
		if( rt_isect_planes( new_v->vg_p->coord , planes , NMG_TBL_END( faces ) ) )
@


1.162
log
@Replaced a call to nmg_fu_planeeqn with nmg_loop_plane_area.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.161 94/11/21 16:30:25 jra Exp Locker: jra $ (ARL)";
d6537 2
a6541 1
		eg = mv_eu->g.lseg_p;
d6553 3
a6555 1
			VSUB2( e_dir , v2->vg_p->coord , v1->vg_p->coord );
d6586 31
d6801 3
a6803 1
					if( nmg_simple_vertex_solve( vu->v_p , &faces ) )
d6805 37
a6841 5
						/* failed */
						rt_log( "nmg_move_edge_thru_pt: Could not solve simple vertex\n" );
						nmg_tbl( &faces , TBL_FREE , (long *)NULL );
						rt_free( (char *)flags , "mg_move_edge_thru_pt: flags" );
						return( 1 );
@


1.161
log
@Mods to nmg_move_edge_thru_pt for edges to/from same vertex
Minor mods to nmg_fix_normals.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.160 94/11/18 12:36:17 jra Exp Locker: jra $ (ARL)";
d2338 1
a2338 1
			if( nmg_fu_planeeqn( fu , tol ) )
d2340 2
@


1.160
log
@Modified nmg_move_edge_thru_pt to always VUNITIZE the edge direction.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.159 94/11/04 10:00:36 jra Exp Locker: jra $ (ARL)";
d2915 1
a2915 1
		FAST fastf_t	z;
d2920 11
a2930 4
		if( f_top->flip )
			z = - f_top->g.plane_p->N[Z];
		else
			z =   f_top->g.plane_p->N[Z];
d2934 2
a2935 2
		if( z < 0.0 )
			nmg_reverse_face_and_radials( f_top->fu_p , tol );
d6536 1
a6536 2
	eg = mv_eu->g.lseg_p;
	if( eg )
d6538 2
a6539 3
		NMG_CK_EDGE_G_LSEG(eg);
		VMOVE( e_dir , eg->e_dir );
		if( mv_eu->orientation == OT_OPPOSITE )
d6541 6
a6546 1
			VREVERSE( e_dir , e_dir );
d6548 5
a6553 5
	else
	{
		VSUB2( e_dir , v2->vg_p->coord , v1->vg_p->coord );
	}
	VUNITIZE( e_dir );
d6576 5
a6580 2
		VADD2( new_loc , v2->vg_p->coord , move_v );
		nmg_vertex_gv( v2 , new_loc );
@


1.159
log
@Fixed the wierd stuff (stupid mistakes).
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.158 94/11/04 06:31:46 mike Exp Locker: jra $ (ARL)";
a6541 1
		VUNITIZE( e_dir );
d6543 1
@


1.158
log
@Some wierd stuff
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.157 94/11/04 06:28:08 mike Exp Locker: mike $ (ARL)";
a5189 1
					struct edgeuse *eu_next;
d5195 1
a5195 5
					/* XXX This is wrong, it's a comparison!! */
					prev_eu->eumate_p->vu_p->v_p == eu->eumate_p->vu_p->v_p;

					/* XXX Keep compiler happy, this is wrong too */
					eu_next = NULL;
@


1.157
log
@Irix 6, first pass
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.156 94/11/03 10:52:02 jra Exp Locker: mike $ (ARL)";
d5196 1
d5198 3
@


1.156
log
@Added nmg_find_outer_and_void_shells (moved from iges.c)
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.155 94/10/14 10:55:44 jra Exp Locker: jra $ (ARL)";
d67 1
a67 1
	struct edgeuse *eu,*eu1,*eu2;
a676 1
	mat_t test;
d679 1
a679 1
	int i,j;
a770 1
		struct faceuse *next_fu;
a1602 6
		union {
			struct loopuse *lu;
			struct edgeuse *eu;
			struct vertexuse *vu;
			long *l;
		} pp;
a1607 1
		pp.l = p;
d2086 1
a2086 1
	int i,j;
d2152 1
a2152 1
		vect_t normal,v1,v2,tmp_norm;
a2666 4
	struct loopuse *lu;
	struct edgeuse *eu;
	struct faceuse *fu2;

d2727 1
a2727 1
	else if( normal[Z] < 0.0 )
a2898 3
	struct loopuse *lu;
	struct edgeuse *eu,*eu1,*eu2;
	struct vertexuse *vu;
a3040 1
						struct edgeuse *tmp_eu;
d3054 1
a3054 1
							tmp_eu = nmg_ebreak(eu1->vu_p->v_p, eu);
a3345 1
	long *flags;
a3909 1
	struct vertexuse *vu;
a3983 1
	long *flags;
a4150 1
	struct edgeuse *eu;
a4431 1
			struct loopuse *lu;
a4539 1
			vect_t tmp_vec,eu_dir;
a4601 1
		vect_t normal1;
a4662 1
			NMG_GET_FU_NORMAL( normal1 , fu1 );
a4687 1
			vect_t tmp_vec;
a4738 1
	vect_t diag;
a4760 1
		int found1,found2;
a5011 2
			vect_t eu_dir;

a5055 4
			struct edgeuse *new_eu;
			struct edgeuse *prev_eu;
			struct edgeuse *radial_eu;

d5068 1
a5068 1
			new_eu = nmg_esplit( i_fus->vp , j_fus->eu, 0 );
a5269 8
		struct vertexuse *vu1,*vu2;
		struct edgeuse *eu;
		struct loopuse *lu;
		struct loopuse *new_lu;
		struct loopuse *dup_lu;
		struct faceuse *new_fu;
		struct faceuse *fu;
		long **trans_tbl;
a5407 1
	struct model *m;
d5409 1
a5409 1
	int edge_no=0,next_edge_no,j;
a5417 2
	m = nmg_find_model( &new_v->magic );

a5468 1
		struct loopuse *dup_lu;
a5470 1
		long **trans_tbl;
d6267 1
a6267 2
	struct model *m;
	struct faceuse *fu1,*fu2,*fu;
a6268 2
	struct vertexuse *vu;
	struct edgeuse *eu1,*eu;
d6270 1
a6270 9
	struct intersect_fus *k_fus;
	point_t ave_pt;
	vect_t ave_norm,x_vec,y_vec;
	point_t rpp_min;
	int i,j,done;
	int unique_verts;
	int added_faces;
	int edge_no;
	static int pl_count=0;
a6309 4
	m = nmg_find_model( &new_v->magic );

	VSET( rpp_min , 0.0 , 0.0 , 0.0 );

a6387 1
	struct edgeuse *eu,*eu1,*eu2;
a6389 2
	vect_t a,b;
	point_t pa,pb,pc;
a6395 1
		int done=0;
a6502 1
	struct nmgregion *r;
a6697 1
		struct vertex *v;
a6805 1
		fastf_t edge_len_sq;
d6808 1
a6808 1
		for( i=0 ; i<vp->nused ; i++ )
a7100 1
	int last_face=0;
a7161 1
		struct edgeuse *eu;
a7265 1
		struct edgeuse *new_eu;
d7284 1
a7284 1
		new_eu = nmg_esplit( v2 , eu, 0 );
a7325 1
	int edge_no;
a7366 1
					struct edgeuse *check_eu;
a7367 1
					int i;
a7512 1
	struct model *m;
a7516 1
	int i;
a7522 2

	m = nmg_find_model( &new_v->magic );
@


1.155
log
@modified nmg_vlist_to_wire_edges to call nmg_edge_g for each edge created and a check
to avoid building zero length edges.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.154 94/10/11 19:39:08 mike Exp Locker: jra $ (ARL)";
d45 473
a2689 181
}

/*
 *	N M G _ F I N D _ T O P _ F A C E
 *
 *	Finds the topmost face in a shell (in z-direction).
 *	Expects to have a translation table (variable "flags") for
 *	the model, and will ignore face structures that have their
 *	flag set in the table.
 */

struct face *
nmg_find_top_face( s , flags )
struct shell *s;
long *flags;
{
	fastf_t max_z=(-MAX_FASTF);
	fastf_t max_slope=(-MAX_FASTF);
	vect_t edge;
	struct face *f_top=(struct face *)NULL;
	struct edge *e_top=(struct edge *)NULL;
	struct vertex *vp_top=(struct vertex *)NULL;
	struct loopuse *lu;
	struct faceuse *fu;
	struct edgeuse *eu,*eu1,*eu2;
	struct vertexuse *vu;
	int done;

	if( rt_g.NMG_debug & DEBUG_BASIC )
		rt_log( "nmg_find_top_face( s = x%x , flags = x%x )\n" , s , flags );

	NMG_CK_SHELL( s );

	/* find vertex with greatest z coordinate */
	for( RT_LIST_FOR( fu , faceuse , &s->fu_hd ) )
	{
		NMG_CK_FACEUSE( fu );
		if( NMG_INDEX_TEST( flags , fu->f_p ) )
			continue;
		for( RT_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
		{
			NMG_CK_LOOPUSE( lu );
			if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) == NMG_EDGEUSE_MAGIC )
			{
				for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
				{
					NMG_CK_EDGEUSE( eu );
					if( eu->vu_p->v_p->vg_p->coord[Z] > max_z )
					{
						max_z = eu->vu_p->v_p->vg_p->coord[Z];
						vp_top = eu->vu_p->v_p;
					}
				}
			}
		}
	}
	if( vp_top == (struct vertex *)NULL )
	{
		rt_log( "Fix_normals: Could not find uppermost vertex" );
		return( (struct face *)NULL );
	}

	/* find edge from vp_top with largest slope in +z direction */
	for( RT_LIST_FOR( vu , vertexuse , &vp_top->vu_hd ) )
	{
		NMG_CK_VERTEXUSE( vu );
		if( *vu->up.magic_p == NMG_EDGEUSE_MAGIC )
		{
			struct vertexuse *vu1;

			eu = vu->up.eu_p;
			NMG_CK_EDGEUSE( eu );

			/* skip wire edges */
			if( *eu->up.magic_p != NMG_LOOPUSE_MAGIC )
				continue;

			/* skip wire loops */
			if( *eu->up.lu_p->up.magic_p != NMG_FACEUSE_MAGIC )
				continue;

			/* skip finished faces */
			if( NMG_INDEX_TEST( flags , eu->up.lu_p->up.fu_p->f_p ) )
				continue;

			/* skip edges from other shells */
			if( nmg_find_s_of_eu( eu ) != s )
				continue;

			/* get vertex at other end of this edge */
			vu1 = eu->eumate_p->vu_p;
			NMG_CK_VERTEXUSE( vu1 );

			/* make a unit vector in direction of edgeuse */
			VSUB2( edge , vu1->v_p->vg_p->coord , vu->v_p->vg_p->coord );
			VUNITIZE( edge );

			/* check against current maximum slope */
			if( edge[Z] > max_slope )
			{
				max_slope = edge[Z];
				e_top = eu->e_p;
			}
		}
	}
	if( e_top == (struct edge *)NULL )
	{
		rt_log( "Fix_normals: Could not find uppermost edge" );
		return( (struct face *)NULL );
	}

	/* now find the face containing e_top with "left-pointing vector" having the greatest slope */
	max_slope = (-MAX_FASTF);
	eu = e_top->eu_p;
	eu1 = eu;
	done = 0;
	while( !done )
	{
		/* don't bother with anything but faces */
		if( *eu1->up.magic_p == NMG_LOOPUSE_MAGIC )
		{
			lu = eu1->up.lu_p;
			NMG_CK_LOOPUSE( lu );
			if( *lu->up.magic_p == NMG_FACEUSE_MAGIC && lu->orientation == OT_SAME )
			{
				vect_t left;
				vect_t edge_dir;
				vect_t normal;

				/* fu is a faceuse containing "eu1" */
				fu = lu->up.fu_p;
				NMG_CK_FACEUSE( fu );

				/* skip faces from other shells */
				if( fu->s_p != s )
				{
					/* go on to next radial face */
					eu1 = eu1->eumate_p->radial_p;

					/* check if we are back where we started */
					if( eu1 == eu )
						done = 1;

					continue;
				}

				/* make a vector in the direction of "eu1" */
				VSUB2( edge_dir , eu1->vu_p->v_p->vg_p->coord , eu1->eumate_p->vu_p->v_p->vg_p->coord );

				/* find the normal for this faceuse */
				NMG_GET_FU_NORMAL( normal, fu );

				/* edge direction cross normal gives vetor in face */
				VCROSS( left , edge_dir , normal );

				/* unitize to get slope */
				VUNITIZE( left );

				/* check against current max slope */
				if( left[Z] > max_slope )
				{
					max_slope = left[Z];
					f_top = fu->f_p;
				}
			}
		}
		/* go on to next radial face */
		eu1 = eu1->eumate_p->radial_p;

		/* check if we are back where we started */
		if( eu1 == eu )
			done = 1;
	}

	if( f_top == (struct face *)NULL )
	{
		rt_log( "Fix_normals: Could not find uppermost face" );
		return( (struct face *)NULL );
	}

	return( f_top );
@


1.154
log
@variable i_fus was not being initialized before use!
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.153 94/09/23 16:18:49 mike Exp Locker: mike $ (ARL)";
d6582 2
d6597 3
d6610 1
@


1.153
log
@Veryif model before stashing
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.152 94/09/23 15:48:04 jra Exp Locker: mike $ (ARL)";
d5178 1
a5196 1

@


1.152
log
@Modified nmg_unbreak_region_edges to use an edgeuse handler rather than an edge handler.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.151 94/09/10 04:37:01 mike Exp Locker: jra $ (ARL)";
d3575 1
@


1.151
log
@Converted NMG data structures to have edge_g pointer in edgeuse, not edge.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.149 94/09/03 03:01:24 mike Exp Locker: jra $ (ARL)";
a2878 1
/* state for nmg_unbreak_edge */
d3615 1
a3615 1
 *	edge visit routine for nmg_unbreak_region_edges.
d3617 1
a3617 3
 *	checks if edge "e" is a candidate to unbroken,
 *	i.e., if it was brokem earlier by nmg_ebreak and
 *	now may be mended.
d3620 1
a3620 1
 *	other uses, and,  if so, kills the second edge.
d3625 2
a3626 2
nmg_unbreak_handler( ep , state , after )
long	*ep;
d3637 2
a3638 2
	e = (struct edge *)ep;
	NMG_CK_EDGE( e );
d3642 4
a3645 2
	/* make sure we only visit this edge once */
	if( !NMG_INDEX_TEST_AND_SET( ub_state->flags , e ) )  return;
d3647 6
a3652 2
	eu1 = e->eu_p;
	NMG_CK_EDGEUSE( eu1 );
d3699 1
a3699 1
 *	each edge below the region (or any other NMG element).
d3720 1
a3720 1
	htab.vis_edge = nmg_unbreak_handler;
@


1.150
log
@JRA added nmg_mark_edges_real().
@
text
@d3648 3
a3650 1
	eg = e->eg_p;
a3664 2
	eu1 = e->eu_p;
	NMG_CK_EDGEUSE( eu1 );
d3666 1
a3666 1
	if( eu2->e_p->eg_p != eg )
a3689 7

#if 0
	/* See if vertex "B" survived, meaning it has other uses */
	if( vb->l.magic != NMG_VERTEX_MAGIC )  return;

	/* It's really unclear how to proceed here. No context info. */
#endif
d4754 1
a4754 1
		new_eu = nmg_esplit( i_fus->vp , i_fus->eu );
d4806 1
a4806 1
			new_eu = nmg_esplit( i_fus->vp , j_fus->eu );
d5110 1
a5110 1
				(void)nmg_esplit( j_fus->vp , i_fus->eu );
d5125 1
a5125 1
				(void)nmg_esplit( i_fus->vp , j_fus->eu );
d6276 1
a6276 1
	struct edge_g *eg;
d6301 1
a6301 1
	eg = mv_eu->e_p->eg_p;
d6304 1
d7054 1
a7054 1
		new_eu = nmg_esplit( v2 , eu );
@


1.149
log
@Snapshot of non-working intermediate stage in edge_g evolution.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.148 94/09/02 00:32:12 mike Exp Locker: mike $ (ARL)";
d72 30
@


1.148
log
@Changed to new face geometry pointers (g.plane_p)
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.147 94/08/29 14:07:39 jra Exp Locker: mike $ (ARL)";
d3605 1
a3605 1
	struct edge_g *eg;
d3627 2
a3628 2
	if( eg->usage < 2 )  {
		/* rt_log("nmg_unbreak_handler: usage < 2\n"); */
@


1.147
log
@Fixed bug in nmg_move_edge_thru_pt (it was reversing some faces).
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.146 94/08/10 18:54:11 gdurf Exp Locker: jra $ (ARL)";
d82 1
a82 1
CONST struct face_g *fg;
d86 1
a86 1
	NMG_CK_FACE_G( fg );
d618 1
a618 1
 * If fu does not already have a face_g associated, only
d621 2
a622 2
 * if fu has a face_g, then all vertices in any face that
 * references the same face_g will participate in the
d643 1
a643 1
	struct face_g *fg;
d659 1
a659 1
	fg = f->fg_p;
d662 1
a662 1
		NMG_CK_FACE_G( fg );
d2027 1
a2027 1
			if (fu->f_p->fg_p)
d2039 2
a2040 2
				/* XXX Perhaps this should be new_fu->f_p->fg_p ? */
				NMG_INDEX_ASSIGN( (*trans_tbl) , fu->f_p->fg_p , (long *)new_fu->f_p->fg_p );
d2405 1
a2405 1
	NMG_CK_FACE_G( f->fg_p );
d2615 1
a2615 1
			z = - f_top->fg_p->N[Z];
d2617 1
a2617 1
			z =   f_top->fg_p->N[Z];
d3851 1
a3851 1
	struct face_g *fg;
d3873 1
a3873 1
		fg = fu->f_p->fg_p;
d3882 1
a3882 1
			if( fp->fg_p == fg || rt_coplanar( fg->N , fp->fg_p->N , tol ) > 0 )
d3956 2
a3957 2
			vert_move_len = DIST_PT_PLANE( vg->coord , fp1->fg_p->N );
			VJOIN1( vg->coord , vg->coord , -vert_move_len , fp1->fg_p->N );
d3964 1
a3964 1
			VCROSS( pl1 , fp1->fg_p->N , fp2->fg_p->N );
d3966 1
a3966 1
			if( rt_mkpoint_3planes( vg->coord , fp1->fg_p->N , fp2->fg_p->N , pl1 ) )
d3970 2
a3971 1
					V4ARGS( fp1->fg_p->N ) , V4ARGS( fp2->fg_p->N ) );
d3982 1
a3982 1
			if( rt_mkpoint_3planes( vg->coord , fp1->fg_p->N , fp2->fg_p->N , fp3->fg_p->N ) )
d3985 3
a3987 3
				rt_log( "\t( %f %f %f %f )\n" , V4ARGS( fp1->fg_p->N ) );
				rt_log( "\t( %f %f %f %f )\n" , V4ARGS( fp2->fg_p->N ) );
				rt_log( "\t( %f %f %f %f )\n" , V4ARGS( fp3->fg_p->N ) );
d4042 2
a4043 2
		NMG_CK_FACE_G( fu->f_p->fg_p );
		dist = DIST_PT_PLANE( v->vg_p->coord , fu->f_p->fg_p->N );
d4369 1
a4369 1
			if( ret_val=rt_isect_2planes( start , dir , fu1->f_p->fg_p->N , fu2->f_p->fg_p->N , new_v->vg_p->coord , &tol_tmp ) )
d4375 2
a4376 2
					V4ARGS( fu1->f_p->fg_p->N ),
					V4ARGS( fu2->f_p->fg_p->N ) );
d4569 1
a4569 1
				if( NEAR_ZERO( VDOT( f->fg_p->N , edge_fus->dir ) , tol->perp ) )
d4572 1
a4572 1
				if( rt_isect_line3_plane( &dist[0] , edge_fus->start , edge_fus->dir , f->fg_p->N , tol ) > 1 )
d7358 1
a7358 1
					if( NMG_INDEX_TEST_AND_SET( flags , fu->f_p->fg_p ) )
d7361 1
a7361 1
						fu->f_p->fg_p->N[Y] = (-fu->f_p->fg_p->N[Y]);
@


1.146
log
@factored ifdefs
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.145 1994/08/09 19:38:09 mike Exp gdurf $ (ARL)";
d636 2
a637 2
nmg_calc_face_g( fu )
struct faceuse *fu;
d639 1
d655 1
d6350 2
d6357 5
d6371 1
d6373 1
d6390 7
d6398 10
a6407 2
			VSUB2( next_dir , anchor_v->vg_p->coord , pt );
			VCROSS( plane , e_dir , next_dir );
d6415 2
@


1.145
log
@Added GDurf's new "conf.h"
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.144 94/08/03 15:40:36 jra Exp Locker: mike $ (ARL)";
d32 3
a34 1
#ifdef BSD
a35 2
#else
#include <string.h>
@


1.144
log
@Rewrote nmg_make_connect_faces
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.143 94/07/15 14:02:04 jra Exp $ (ARL)";
d30 1
@


1.143
log
@Fixed bug in nmg_calc_face_g
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.142 94/07/14 10:32:15 jra Exp Locker: jra $ (ARL)";
d6813 2
d6818 2
a6819 1
	int max_verts=20;
d6821 2
d6843 1
a6843 2
	face_verts[0] = (struct vertex *)NULL;
	for( i=0 ; i<NMG_TBL_END( verts ) ; i++ )
d6845 20
a6864 5
		struct vertex *v;
		vect_t to_vpa,to_vpb;
		fastf_t dist_to_a_sq,dist_to_b_sq;
		fastf_t area;
		plane_t pl;
d6866 2
a6867 2
		v = (struct vertex *)NMG_TBL_GET( verts , i );
		NMG_CK_VERTEX( v );
d6869 2
a6870 2
		VSUB2( to_vpa , vpa->vg_p->coord , v->vg_p->coord );
		VSUB2( to_vpb , vpb->vg_p->coord , v->vg_p->coord );
d6872 7
a6878 2
		dist_to_a_sq = MAGSQ( to_vpa );
		dist_to_b_sq = MAGSQ( to_vpb );
d6880 1
a6880 6
		if( face_verts[0] == (struct vertex *)NULL )
		{
			if( dist_to_a_sq < dist_to_b_sq )
				face_verts[0] = vpa;
			else
				face_verts[0] = vpb;
d6882 2
a6883 8
			face_verts[1] = v;
			verts_in_face = 2;
		}
		else
		{
			face_verts[verts_in_face++] = v;
				
			if( !rt_3pts_collinear( face_verts[0]->vg_p->coord,
d6886 4
a6889 4
			{
				struct faceuse *new_fu;
				struct loopuse *lu;
				struct edgeuse *eu;
d6891 2
a6892 3
				if( rt_g.NMG_debug & DEBUG_BASIC )
				{
					int debug_int;
d6894 4
a6897 5
					rt_log( "make face:\n" );
					for( debug_int=0 ; debug_int<verts_in_face ; debug_int++ )
						rt_log( "\tx%x ( %f %f %f )\n" , face_verts[debug_int],
							V3ARGS( face_verts[debug_int]->vg_p->coord ) );
				}
d6899 3
a6901 11
				new_fu = nmg_cface( dst , face_verts , verts_in_face );
				lu = RT_LIST_FIRST( loopuse , &new_fu->lu_hd );
				area = nmg_loop_plane_area( lu , pl );
				if( area <= 0.0 )
				{
					rt_bomb( "nmg_make_connect_faces: Failed to calculate plane eqn\n" );
					nmg_kfu( new_fu );
				}
				else
				{
					made_face = 1;
d6903 5
a6907 1
					nmg_face_g( new_fu , pl );
d6909 4
a6912 3
					/* glue this face in */
					nmg_glue_face_in_shell( new_fu , dst , tol );
				}
d6914 8
a6921 5
				if( dist_to_b_sq <= dist_to_a_sq && face_verts[0] == vpa )
				{
					/* make middle face */
					face_verts[1] = v;
					face_verts[2] = vpb;
d6923 1
a6923 3
					if( rt_g.NMG_debug & DEBUG_BASIC )
					{
						int debug_int;
d6925 3
a6927 5
						rt_log( "make middle face:\n" );
						for( debug_int=0 ; debug_int<verts_in_face ; debug_int++ )
							rt_log( "\tx%x ( %f %f %f )\n" , face_verts[debug_int],
								V3ARGS( face_verts[debug_int]->vg_p->coord ) );
					}
d6929 15
a6943 11
					new_fu = nmg_cface( dst , face_verts , 3 );
					lu = RT_LIST_FIRST( loopuse , &new_fu->lu_hd );
					area = nmg_loop_plane_area( lu , pl );
					if( area <= 0.0 )
					{
						rt_bomb( "nmg_make_connect_faces: Failed to calculate plane eqn for middle face\n" );
						nmg_kfu( new_fu );
					}
					else
					{
						made_face = 1;
d6945 4
a6948 1
						nmg_face_g( new_fu , pl );
d6950 2
a6951 4
						/* glue this face in */
						nmg_glue_face_in_shell( new_fu , dst , tol );
					}
				}
d6953 10
a6962 7
				/* get ready for next face, if necessary */
				if( i < NMG_TBL_END( verts ) )
				{
					if( dist_to_a_sq < dist_to_b_sq )
						face_verts[0] = vpa;
					else
						face_verts[0] = vpb;
d6964 6
a6969 3
					face_verts[1] = v;
					verts_in_face = 2;
				}
d6971 2
a6972 2
			else
				made_face = 0;
d6974 1
@


1.142
log
@Added nmg_calc_face_g and nmg_tabulate_face_g_verts.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.141 94/07/11 16:46:01 jra Exp Locker: jra $ (ARL)";
d761 55
a815 2
		rt_log( "nmg_calc_face_g: Cannot calculate plane for fu x%x\n" , fu );
		failed = 1;
@


1.141
log
@Modified nmg_propagate_normals to handle edges with many radials.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.140 94/07/05 16:20:34 jra Exp Locker: jra $ (ARL)";
d73 69
d611 156
@


1.140
log
@Additional debug prints in vertex solving routines for extrusions.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.139 94/07/01 23:57:42 mike Exp $ (ARL)";
d2204 3
d2211 16
@


1.139
log
@Changed an nmg_esplit() to an nmg_ebreak().
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.138 94/07/01 11:37:48 jra Exp Locker: mike $ (ARL)";
d3700 3
d5741 4
d5806 5
d6924 1
a6924 1
		rt_log( "nmg_in_vert( new_v=x%x )\n" , new_v );
@


1.138
log
@Fixed bug in nmg_prev_radial_eu and nmg_next_radial_eu.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.137 94/06/27 10:37:38 jra Exp Locker: jra $ (ARL)";
d2449 1
a2449 1
							tmp_eu = nmg_esplit(eu1->vu_p->v_p, eu);
@


1.137
log
@Added NMG surface area calculation routines.
Added mat_determinant
Modified nmg_in_vert to use "approximate" arg.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.136 94/05/19 13:44:07 jra Exp Locker: jra $ (ARL)";
d278 2
a279 1
	NMG_CK_SHELL( s );
d317 2
a318 1
	NMG_CK_SHELL( s );
@


1.136
log
@Modified nmg_calc_new_v to use rt_isect_planes
Modified nmg_get_max_edge_inters to avoid intersecting edge rays with a plane parallel to it
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.135 94/05/17 16:18:24 jra Exp Locker: jra $ (ARL)";
d44 6
d51 22
d91 4
d96 1
a96 1
void
d106 1
d139 5
d148 2
a204 3
		if( rt_g.NMG_debug & DEBUG_BASIC )
			rt_log( "nmg_extrude_cleanup: fu=x%x\n" );

d542 97
d3695 4
d4073 2
d5604 9
a5612 1
		rt_isect_planes( new_v->vg_p->coord , planes , pl_count );
a5670 1
 *
d5673 4
d5683 1
a5683 1
nmg_complex_vertex_solve( new_v , faces , tol )
d5686 1
d5716 23
a5776 4
#if 0
	/* calculate geometry for new_v */
	nmg_calc_new_v( new_v , &int_faces , tol );
#endif
d6533 2
d6578 4
a6581 1
				if( nmg_fu_planeeqn( new_fu , tol ) )
d6583 5
d6589 1
a6589 1
				made_face = 1;
d6591 3
a6593 2
				/* glue this face in */
				nmg_glue_face_in_shell( new_fu , dst , tol );
d6612 10
a6621 2
					if( nmg_fu_planeeqn( new_fu , tol ) )
						rt_bomb( "nmg_make_connect_faces: Failed to calculate plane eqn\n" );
d6623 5
a6627 1
					nmg_glue_face_in_shell( new_fu , dst , tol );
d6890 5
d6897 1
a6897 1
nmg_in_vert( new_v , tol )
d6899 1
d6931 1
a6931 1
		if( nmg_complex_vertex_solve( new_v , &faces , tol ) )
@


1.135
log
@Added rt_isect_planes
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.134 94/04/12 11:35:02 jra Exp Locker: jra $ (ARL)";
d4060 4
d4089 4
d4122 4
d4129 6
d5406 1
a5406 1
static void
a5411 68
#if 0
	int edge_no;
	fastf_t edge_count=0.0;
	point_t ave_pt,prev_pt;
	struct intersect_fus *free_fus[2];
	struct intersect_fus *edge_fus;
	int free_edge_count=0;

	NMG_CK_VERTEX( new_v );
	NMG_CK_PTBL( int_faces );
	RT_CK_TOL( tol );

	if( rt_g.NMG_debug & DEBUG_BASIC )
		rt_log( "nmg_calc_new_v\n" );

	edge_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , NMG_TBL_END( int_faces)-1 );
	if( edge_fus->vp )
		VMOVE( prev_pt , edge_fus->vp->vg_p->coord )
	else
		VMOVE( prev_pt , new_v->vg_p->coord );

	VSET( ave_pt , 0.0 , 0.0 , 0.0 )

	/* generally, just average the intersect_fus->vp's */
	for( edge_no=0 ; edge_no<NMG_TBL_END( int_faces ) ; edge_no++ )
	{

		edge_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , edge_no );

		if( edge_fus->free_edge )
		{
			free_fus[free_edge_count++] = edge_fus;
			if( free_edge_count > 2 )
				rt_bomb( "nmg_calc_new_v: Too many free edges\n" );
		}

		if( !edge_fus->vp )
			continue;

		if( !rt_pt3_pt3_equal( prev_pt , edge_fus->vp->vg_p->coord , tol ) )
		{
			VADD2( ave_pt , ave_pt , edge_fus->vp->vg_p->coord )
			edge_count += 1.0;
			VMOVE( prev_pt , edge_fus->vp->vg_p->coord )
		}
	}

	if( edge_count > 0.0 )
	{
		fastf_t scale;

		scale = 1.0/edge_count;
		VSCALE( ave_pt , ave_pt , scale )
	}
	else if( NMG_TBL_END( int_faces ) > 0 )
	{
		/* all the intersect vertices are within tolerance of prev_pt */
		VMOVE( ave_pt , prev_pt )
	}
	else
		rt_bomb( "nmg_calc_new_v: edge_count is zero\n" );

	/* if there are two free edges, new_v should be on the same plane as the free edges */
	if( free_edge_count == 2 )
		VBLEND2( new_v->vg_p->coord , 0.5 , free_fus[0]->vp->vg_p->coord , 0.5 , free_fus[1]->vp->vg_p->coord )
	else
		VMOVE( new_v->vg_p->coord , ave_pt )
#else
d5423 5
a5427 1
	planes = (plane_t *)rt_calloc( NMG_TBL_END( int_faces ) , sizeof( plane_t ) , "nmg_calc_new_v: planes" );
d5463 3
a5465 1
	if( rt_g.NMG_debug & DEBUG_BASIC )
d5467 5
a5471 2
		for( i=0 ; i<pl_count ; i++ )
			rt_log( "Plane #%d: %f %f %f %f\n" , i , V4ARGS( planes[i] ) );
d5473 19
a5492 2
	rt_isect_planes( new_v->vg_p->coord , planes , pl_count );

a5506 1
#endif
d5513 2
d5580 5
a5584 1
	nmg_calc_new_v( new_v , &int_faces , tol );
@


1.134
log
@Added nmg_isect_shell_self
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.133 94/04/11 08:16:19 jra Exp Locker: jra $ (ARL)";
d44 68
d4090 32
d4517 1
a4517 1
	while( edge_no < NMG_TBL_END( int_faces ) )
a4565 4
		/* the two vertices should never be the same */
		if( i_fus->vp == j_fus->vp )
			rt_bomb( "nmg_simplify_inter: Two vertices are the same\n" );

d4574 1
a4574 1
		if( rt_pt3_pt3_equal( i_fus->vp->vg_p->coord , j_fus->vp->vg_p->coord , tol ) )
d4576 5
d5394 1
d5461 4
d5466 4
d5471 7
d5479 56
d5602 3
d5621 1
a5621 1

d5624 1
@


1.133
log
@fixed bug in nmg_get_edge_lines
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.132 94/04/08 16:31:45 jra Exp Locker: jra $ (ARL)";
d43 108
@


1.132
log
@Fixed bug in nmg_get_edge_lines
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.131 94/04/07 12:50:17 jra Exp Locker: jra $ (ARL)";
a3579 2
	point_t min_pt,max_pt;
	vect_t diag;
a3604 5
	/* create a large (3X) bounding box for the model */
	VSUB2( diag , r->ra_p->max_pt , r->ra_p->min_pt );
	VADD2( max_pt , r->ra_p->max_pt , diag );
	VSUB2( min_pt , r->ra_p->min_pt , diag );

a3762 19

			/* Check if the start point is reasonably near the model!! */
			if( !V3PT_IN_RPP( start , min_pt , max_pt ) )
			{
				/* Again, an incorrectly modelled FASTGEN object can trigger this
				 * check
				 */
				rt_log( "nmg_get_edge_lines: edge start point is outside region bounding box\n" );

				for( edge_no=0 ; edge_no<NMG_TBL_END( int_faces ) ; edge_no++ )
				{
					struct intersect_fus *i_fus;

					i_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , edge_no );

					rt_free( (char *)i_fus , "nmg_get_edge_lines: i_fus" );
				}
				return( 1 );
			}
@


1.131
log
@modified nmg_decompose_shell
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.130 94/03/31 16:23:12 jra Exp Locker: jra $ (ARL)";
d2454 1
a2454 1
	rt_free( (char *)sl_state.flags , "nmg_unbreak_region_edges: flags" );
d3541 1
a3541 1
		if( i_fus->eu )
d3659 26
a3684 8
		/* get the first edgeuse emanating from new_v */
		vu = RT_LIST_FIRST( vertexuse , &new_v->vu_hd );
		NMG_CK_VERTEXUSE( vu );
		eu1 = vu->up.eu_p;
		NMG_CK_EDGEUSE( eu1 );
		fu = nmg_find_fu_of_eu( eu1 );
		if( fu->orientation != OT_SAME )
			eu1 = eu1->eumate_p;
@


1.130
log
@Added nmg_shell_is_void and nmg_mv_lu_between_faces, fixed bug in nmg_decompose_shell
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.129 94/03/30 18:02:32 jra Exp Locker: jra $ (ARL)";
d44 11
d56 98
d1717 1
a1717 1
			if( *lu->up.magic_p == NMG_FACEUSE_MAGIC )
d1812 1
a2283 2
rt_log( "nmg_split_loops_handler: fu x%x has %d OT_SAME loops and %d OT_OPPOSITE loops\n", fu , otsame_loops, otopp_loops );

d2302 1
a2302 1
rt_log( "%d otsame loops\n" , otsame_loops );
a2315 1
rt_log( "\tlu x%x is OT_SAME\n" , lu );
d2330 1
a2330 1
rt_log( "\t\tlu x%x is OT_OPPOSITE inside lu x%x\n" , lu1 , lu );
a2349 1
rt_log( "\t\t\tx%x is within x%x, so not a hole in x%x\n" , lu1, lu2, lu );
a2356 2
				{
rt_log( "\t\t\tAdding x%x to list of holes in x%x\n" , lu1 , lu );
a2357 1
				}
d2361 1
a2370 2
nmg_pr_fu_briefly( new_fu , (char *)NULL );
nmg_pr_fu_briefly( new_fu->fumate_p , (char *)NULL );
a2398 1
rt_log( "ALL LOOPS should be OT_SAME, x%x is %s\n" , lu , nmg_orientation( lu->orientation ) );
a2526 14
			int face_count=1;

			NMG_CK_EDGEUSE( eu );

			/* count radial faces on this edge */
			eu1 = eu->eumate_p->radial_p;
			while( eu1 != eu && eu1 != eu->eumate_p )
			{
				/* ignore other shells */
				if( nmg_find_s_of_eu( eu1 ) == s )
					face_count++;
				eu1 = eu1->eumate_p->radial_p;
			}

d2528 1
a2528 1
			if( face_count > 2 )
a2573 14
                                	int face_count=1;

                                	NMG_CK_EDGEUSE( eu );

					/* count radial faces on this edge */
					eu1 = eu->eumate_p->radial_p;
					while( eu1 != eu && eu1 != eu->eumate_p )
					{
						/* ignore other shells */
						if( nmg_find_s_of_eu( eu1 ) == s )
							face_count++;
						eu1 = eu1->eumate_p->radial_p;
					}

d2575 1
a2575 1
					if( face_count > 2 )
d2626 6
d2643 4
d2648 1
a2648 2
				fu = nmg_find_fu_of_eu( eu1 );
				if( !NMG_INDEX_TEST( flags , fu ) )
d2650 3
a2652 2
				shells_at_edge[ NMG_INDEX_GET( flags , fu ) ]++;
				eu1 = eu1->eumate_p->radial_p;
d2658 1
a2658 1
				/* Only one face at this edge is unassigned, should be
a2660 5

				/* Make sure everything is O.K. so far */
				if( faces_at_edge & 1 )
					rt_bomb( "nmg_decompose_shell: Odd number of faces at edge\n" );

d2665 1
d2671 7
d2682 82
a2795 14
                                	int face_count = 1;

                                	NMG_CK_EDGEUSE( eu );

					/* count radial faces on this edge */
					eu1 = eu->eumate_p->radial_p;
					while( eu1 != eu && eu1 != eu->eumate_p )
					{
						/* ignore other shells */
						if( nmg_find_s_of_eu( eu1 ) == s )
							face_count++;
						eu1 = eu1->eumate_p->radial_p;
					}

d2797 1
a2797 1
					if( face_count > 2 )
a2841 13
	                                	int face_count = 1;
	                                	NMG_CK_EDGEUSE( eu );

						/* count radial faces on this edge */
						eu1 = eu->eumate_p->radial_p;
						while( eu1 != eu && eu1 != eu->eumate_p )
						{
							/* ignore other shells */
							if( nmg_find_s_of_eu( eu1 ) == s )
								face_count++;
							eu1 = eu1->eumate_p->radial_p;
						}

d2843 1
a2843 1
						if( face_count > 2 )
a3831 1
	point_t min_pt,max_pt;
a3847 5
	/* create a generous (3X) bounding box for the model */
	VSUB2( diag , r->ra_p->max_pt , r->ra_p->min_pt );
	VADD2( max_pt , r->ra_p->max_pt , diag );
	VSUB2( min_pt , r->ra_p->min_pt , diag );

a3926 18

			if( !V3PT_IN_RPP( edge_fus->pt , min_pt , max_pt ) )
			{
				/* Make sure this point is somewher around the model!! */
				int i;

				rt_log( "nmg_get_max_edge_inters: edge intersect point is outside region bounding box\n" );

				for( i=0 ; i < NMG_TBL_END( int_faces ) ; i++ )
				{
					struct intersect_fus *i_fus;

					i_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , i );

					rt_free( (char *)i_fus , "nmg_get_edge_lines: i_fus" );
				}
				return( 1 );
			}
d4170 3
d5208 4
a5211 1
	VMOVE( prev_pt , edge_fus->vp->vg_p->coord )
d5227 3
@


1.129
log
@Fixed bug in nmg_decompose_shell
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.128 94/03/30 15:48:04 jra Exp Locker: jra $ (ARL)";
d44 67
d1668 22
d1691 30
d2174 6
d2182 1
a2182 3
		struct faceuse *new_fu;
		struct loopuse *lu1;
		int first=1;
d2184 2
d2189 7
a2195 1
			struct loopuse *next_lu;
d2197 1
a2197 2
			next_lu = RT_LIST_PNEXT( loopuse , &lu->l );
			if( lu->orientation == OT_OPPOSITE )
d2199 10
a2208 2
				struct loopuse *lu1;
				int inside=0;
d2210 21
a2230 2
				/* check if this loop is within another loop */
				for( RT_LIST_FOR( lu1 , loopuse , &fu->lu_hd ) )
d2232 1
a2232 3
					int class;

					if( lu == lu1 || lu1->orientation != OT_SAME )
d2235 1
a2235 2
					class = nmg_classify_lu_lu( lu , lu1 , tol );
					if( class == NMG_CLASS_AinB )
d2237 10
a2246 2
						inside = 1;
						break;
d2250 1
a2250 1
				if( !inside )
d2252 2
a2253 8
					/* this loop is not a hole inside another loop
					 * so make it a face of its own */
					plane_t plane;

					NMG_GET_FU_PLANE( plane , fu->fumate_p );
					new_fu = nmg_mk_new_face_from_loop( lu );
					nmg_face_g( new_fu , plane );
					nmg_lu_reorient( lu , tol );
d2256 5
a2260 1
			else
d2262 2
a2263 10
				plane_t plane;

				if( first )
					first = 0;
				else
				{
					NMG_GET_FU_PLANE( plane , fu );
					new_fu = nmg_mk_new_face_from_loop( lu );
					nmg_face_g( new_fu , plane );
				}
d2265 4
a2268 1
			lu = next_lu;
d2270 1
d2272 1
a2272 1
	else
d2297 1
d2307 5
a2311 2

	/* XXXX Need code for faces with OT_OPPOSITE loops */
d2391 1
a2391 1
		rt_log( "nmg_decompose_shell( s = x%x )\n" , s );
d2442 1
a2442 1
				nmg_tbl( &shared_edges , TBL_INS , (long *)eu );
d2444 1
a2444 1
				nmg_tbl( &stack , TBL_INS , (long *)eu );
d2503 1
a2503 1
						nmg_tbl( &shared_edges , TBL_INS , (long *)eu );
d2505 1
a2505 1
						nmg_tbl( &stack , TBL_INS , (long *)eu );
d2551 1
d2553 3
d2578 1
d2583 1
a2583 1
				for( j=1 ; j<no_of_shells ; j++ )
d2587 2
a2588 10
						/* the unassigned face could belong to shell number j */
						if( new_shell_no )
						{
							/* more than one shell has only one face here
							 * cannot determine which to choose */
							new_shell_no = 0;
							break;
						}
						else
							new_shell_no = j;
d2592 2
d2644 1
a2644 1
						nmg_tbl( &shared_edges , TBL_INS , (long *)eu );
d2646 1
a2646 1
						nmg_tbl( &stack , TBL_INS , (long *)eu );
d2703 1
a2703 1
							nmg_tbl( &shared_edges , TBL_INS , (long *)eu );
d2705 1
a2705 1
							nmg_tbl( &stack , TBL_INS , (long *)eu );
d2766 4
@


1.128
log
@Modified nmg_bad_face_normals
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.127 94/03/30 14:54:02 jra Exp Locker: jra $ (ARL)";
d2288 1
a2288 1
	/* Mark first faceuse with shell number */
d2290 1
@


1.127
log
@Added some checking to nmg_move_edge_thru_pt
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.126 94/03/30 13:40:20 jra Exp Locker: jra $ (ARL)";
d50 1
a50 1
 *	less tha zero indicates an error
d5098 2
a5099 1
	vect_t old_normal,new_normal;
d5109 1
d5111 2
d5120 1
a5120 12
		/* find a good loop */
		lu = RT_LIST_FIRST( loopuse , &fu->lu_hd );
		while( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC && RT_LIST_NOT_HEAD( lu , &fu->lu_hd ) )
			lu = RT_LIST_PNEXT( loopuse , &lu->l );

		if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
			continue;

		/* find two edgeuse in the loop for calculating a new normal */
		eu = RT_LIST_FIRST( edgeuse , &lu->down_hd );
		eu1 = RT_LIST_PNEXT_CIRC( edgeuse , &eu->l );
		while( !done )
d5122 1
a5122 6
			VMOVE( pa , eu->vu_p->v_p->vg_p->coord );
			VMOVE( pb , eu1->vu_p->v_p->vg_p->coord );
			eu2 = RT_LIST_PNEXT_CIRC( edgeuse , &eu1->l );
			VMOVE( pc , eu2->vu_p->v_p->vg_p->coord );
			VSUB2( a , pa , pb );
			VSUB2( b , pc , pb );
d5124 2
a5125 11
			/* calculate new normal */
			VCROSS( new_normal , b , a );
			if( MAGSQ( new_normal ) > tol->dist_sq )
			{
				/* reverse normal if needed */
				if( lu->orientation == OT_OPPOSITE )
				{
					VREVERSE( new_normal , new_normal );
				}
				else if( lu->orientation != OT_SAME )
					rt_log( "nmg_bad_face_normals: found loopuse with %s orientation\n" , nmg_orientation( lu->orientation ) );
d5127 1
a5127 7
				/* check if old and new agree */
				if( VDOT( old_normal , new_normal ) < 0.0 )
					return( 1 );
				else
					break;
			}
			else
d5129 3
a5131 12
				/* tried the whole loop, give up */
				if( eu1 == RT_LIST_FIRST( edgeuse , &lu->down_hd ) )
				{
					rt_log( "nmg_bad_face_normals: Couldn't calculate new normal for faceuse\n" );
					done = 1;
				}
				else
				{
					/* step along loop */
					eu = eu1;
					eu1 = eu2;
				}
d5133 6
@


1.126
log
@Moved nmg_extrude_shell and nmg_extrude_cleanup to nmg_extrude.c
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.125 94/03/30 13:26:01 jra Exp Locker: jra $ (ARL)";
d5250 1
d5253 3
d5267 6
d5285 1
a5285 1
		VSUB2( e_dir , mv_eu->eumate_p->vu_p->v_p->vg_p->coord , mv_eu->vu_p->v_p->vg_p->coord );
d5302 1
a5302 1
		VSUB2( to_pt , pt , eu->vu_p->v_p->vg_p->coord );
d5307 5
a5311 4
		VADD2( new_loc , eu->vu_p->v_p->vg_p->coord , move_v );
		nmg_vertex_gv( eu->vu_p->v_p , new_loc );
		VADD2( new_loc , eu->eumate_p->vu_p->v_p->vg_p->coord , move_v );
		nmg_vertex_gv( eu->eumate_p->vu_p->v_p , new_loc );
d5315 20
d5407 1
a5414 1
		struct edgeuse *eu;
d5419 1
a5419 1
			struct nmg_ptbl faces;
d5429 1
a5429 1
					int free_edges=0;
a5430 2
					nmg_tbl( &faces , TBL_INIT , (long *)NULL );

d5432 1
a5432 1
					if( nmg_find_isect_faces( vu->v_p , &faces , &free_edges , tol ) < 4 )
d5434 4
a5437 7
						if( nmg_simple_vertex_solve( vu->v_p , &faces ) )
						{
							/* failed */
							rt_log( "nmg_move_edge_thru_pt: Could not solve simple vertex\n" );
							nmg_tbl( &faces , TBL_FREE , (long *)NULL );
							return( 1 );
						}
d5439 9
a5447 3
					else
						nmg_complex_vertex_solve( vu->v_p , &faces , tol );
					
d5452 1
a5452 2
			eu = RT_LIST_FIRST( edgeuse , &lu->down_hd );
			while( RT_LIST_NOT_HEAD( eu , &lu->down_hd ) )
a5454 1
				struct edgeuse *eu_next;
a5455 2
				eu_next = RT_LIST_PNEXT( edgeuse , &eu->l );

a5458 1
					int free_edges=0;
d5460 1
a5460 1
					nmg_tbl( &faces , TBL_INIT , (long *)NULL );
d5463 1
a5463 1
					if( nmg_find_isect_faces( vu->v_p , &faces , &free_edges , tol ) < 4 )
d5465 4
a5468 7
						if( nmg_simple_vertex_solve( vu->v_p , &faces ) )
						{
							/* failed */
							rt_log( "nmg_move_edge_thru_pt: Could not solve simple vertex\n" );
							nmg_tbl( &faces , TBL_FREE , (long *)NULL );
							return( 1 );
						}
d5470 9
a5478 2
					else
						nmg_complex_vertex_solve( vu->v_p , &faces , tol );
a5479 1
				eu = eu_next;
a5480 1
			nmg_tbl( &faces , TBL_FREE , (long *)NULL );
d5490 1
@


1.125
log
@Housecleaning
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.124 94/03/29 18:28:27 jra Exp Locker: jra $ (ARL)";
a5224 657
/*
 *	N M G _ E X T R U D E _ C L E A N U P
 *
 *	Clean up after nmg_extrude_shell.
 *	intersects each face with every other face in the shell and
 *	makes new face boundaries at the intersections.
 *	decomposes the result into seperate shells.
 *	where faces have intersected, new shells will be created.
 *	These shells are detected and killed
 */
struct shell *
nmg_extrude_cleanup( is , os , thick , tol )
struct shell *is,*os;
CONST fastf_t thick;
CONST struct rt_tol *tol;
{
	struct nmg_ptbl vertex_uses;
	struct nmg_ptbl faces;
	struct nmg_ptbl bad_loops;
	struct model *m;
	struct nmgregion *new_r,*r;
	struct faceuse *fu;
	struct loopuse *lu;
	struct edgeuse *eu;
	struct vertexuse *vu;
	struct shell *s_fu;	/* Shell to temporarily hold fu2 */
	int i,j;

	NMG_CK_SHELL( is );
	NMG_CK_SHELL( os );
	RT_CK_TOL( tol );

	if( rt_g.NMG_debug & DEBUG_BASIC )
		rt_log( "nmg_extrude_cleanup( is=x%x , os=x%x , thick=%g)\n" , is , os , thick );

	m = nmg_find_model( &is->l.magic );
	NMG_CK_MODEL( m );

	nmg_vmodel( m );

	r = is->r_p;
	NMG_CK_REGION( r );

	s_fu = nmg_msv( r );
	NMG_CK_SHELL( s_fu );

	nmg_tbl( &vertex_uses , TBL_INIT , (long *)NULL );
	nmg_tbl( &bad_loops , TBL_INIT , (long *)NULL );

	/* intersect each face with every other face in the shell */
	for( RT_LIST_FOR( fu , faceuse , &is->fu_hd ) )
	{
		struct faceuse *fu2;

		/* only look at OT_SAME faceuses */
		if( fu->orientation != OT_SAME )
			continue;

		/* consider intersection this faceuse with all the faceuses
		 * after it in the list
		 */
		fu2 = RT_LIST_PNEXT( faceuse , &fu->l );
		while( RT_LIST_NOT_HEAD( fu2 , &is->fu_hd ) )
		{
			struct face *f,*f2;
			struct faceuse *fu_tmp,*other_fu;
			plane_t pl,pl2;
			point_t start;
			vect_t dir;
			fastf_t dist;

			/* skip faceuses radial to fu or not OT_SAME */
			if( fu2->orientation != OT_SAME || nmg_faces_are_radial( fu , fu2 ) )
			{
				fu2 = RT_LIST_PNEXT( faceuse , &fu2->l );
				continue;
			}

			f = fu->f_p;
			f2 = fu2->f_p;

			/* skip faceuse pairs that don't have overlapping BB's */
			if( !V3RPP_OVERLAP( f->min_pt , f->max_pt , f2->min_pt , f2->max_pt ) )
			{
				fu2 = RT_LIST_PNEXT( faceuse , &fu2->l );
				continue;
			}

			/* XXX This section should be replaced by a call to nmg_isect_2_generic_faces
			 *  as soon as it is ready */
#if 1
			/* move fu2 to another shell to avoid radial edge problems */
			nmg_mv_fu_between_shells( s_fu, is, fu2 );
rt_log( "nmg_isect_two_generic_faces( fu1 = x%x , fu2 = x%x , tol = x%x )\n" , fu , fu2 , tol );
nmg_pr_fu_briefly( fu , "fu1: " );
nmg_pr_fu_briefly( fu2 , "fu2: " );
			nmg_isect_two_generic_faces( fu , fu2 , tol );
rt_log( "returned from nmg_isect_two_generic_faces\n" );
			/* move fu2 back where it belongs */
			while( RT_LIST_NON_EMPTY( &s_fu->fu_hd ) )
			{
				fu_tmp = RT_LIST_FIRST( faceuse , &s_fu->fu_hd );
				NMG_CK_FACEUSE( fu_tmp );
				nmg_mv_fu_between_shells( is, s_fu, fu_tmp );
			}
		}
	}
	nmg_ks( s_fu );
#else

			/* OK, do the actual intersection */
			NMG_GET_FU_PLANE( pl , fu )
			NMG_GET_FU_PLANE( pl2 , fu2 )

			/* if the two planes don't intersect, continue */
			if( rt_isect_2planes( start , dir , pl , pl2 , is->r_p->ra_p->min_pt , tol ) )
			{
				fu2 = RT_LIST_PNEXT( faceuse , &fu2->l );
				continue;
			}
rt_log( "\nIntersect line at ( %f %f %f ) in direction ( %f %f %f )\n" , V3ARGS( start ) , V3ARGS( dir ) );
			/* intersect the line found above with the two faceuses */
			for( i=0 ; i<2 ; i++ )
			{
				/* hokey way to repeat this for the two faceuses */
				if( i == 0 )
				{
					fu_tmp = fu;
					other_fu = fu2;
				}
				else
				{
					fu_tmp = fu2;
					other_fu = fu;
				}
rt_log( "Looking at fu x%x\n" , fu_tmp );

				/* intersect with each loop */
				for( RT_LIST_FOR( lu , loopuse , &fu_tmp->lu_hd ) )
				{
					int isect_count=0;
					point_t intersection;
rt_log( "\tLooking at lu x%x\n" , lu );

					if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
						continue;

					/* and each edgeuse */
					for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
					{
						struct vertex_g *vgs,*vge;
						struct edgeuse *new_eu;
						struct edgeuse *next_eu;
						int ret_val;

rt_log( "\t\tLooking at edgeuse x%x\n" , eu );
						vgs = eu->vu_p->v_p->vg_p;
						vge = eu->eumate_p->vu_p->v_p->vg_p;

						/* intersect line with edge (line segment)
						 * skip intersections at edge start vertex
						 */
						if( (ret_val=rt_isect_line_lseg( &dist , start , dir , vgs->coord , vge->coord , tol )) > 1 )
						{
							struct vertex *v_isect=(struct vertex *)NULL;

							if( isect_count > 1 )
								rt_bomb( "Too many intersections with loops\n" );
							switch( ret_val )
							{
								case 2:
									/* intersect at end of edge */
									/* add vertexuse to list */
									next_eu = RT_LIST_PNEXT_CIRC( edgeuse , eu );
rt_log( "intersection of fus x%x and x%x (lu x%x) at ( %f %f %f ) vu = x%x (end of edge )\n",
fu , fu2 , lu , V3ARGS( next_eu->vu_p->v_p->vg_p->coord ) , next_eu->vu_p );
									if( nmg_class_pt_f( next_eu->vu_p->v_p->vg_p->coord , other_fu , tol ) == NMG_CLASS_AoutB )
										break;
									nmg_tbl( &vertex_uses , TBL_INS , (long *) next_eu->vu_p );
									isect_count++;
									break;
								case 3:
									/* intersect in middle of edge */
									VJOIN1( intersection , start , dist , dir );
									if( nmg_class_pt_f( intersection , other_fu , tol ) == NMG_CLASS_AoutB )
										break;

									/* re-use existing vertices whenever possible */
									for( j=0 ; j<NMG_TBL_END( &vertex_uses ) ; j++ )
									{
										vu = (struct vertexuse *)NMG_TBL_GET( &vertex_uses , j );
										if( rt_pt3_pt3_equal( intersection , vu->v_p->vg_p->coord , tol ) )
										{
											v_isect = vu->v_p;
											break;
										}
									}
									/* split edge at intersection */
									new_eu = nmg_esplit( v_isect , eu );
									nmg_vertex_gv( new_eu->vu_p->v_p , intersection );

rt_log( "intersection of fus x%x and x%x (lu x%x) at ( %f %f %f ) vu = x%x (middle of edge )\n",
fu , fu2 , lu , V3ARGS( new_eu->vu_p->v_p->vg_p->coord ) , new_eu->vu_p );
									/* add vertexuse to list */
									nmg_tbl( &vertex_uses , TBL_INS , (long *)new_eu->vu_p );
									isect_count++;
									break;
							}
						}
					}

					/* can't handle more than two intersections */
					if( isect_count == 1 )
					{
rt_log( "Only one intersection for this loop, removing it\n" );
						nmg_tbl( &vertex_uses , TBL_RM , (long *)NMG_TBL_GET( &vertex_uses , NMG_TBL_END( &vertex_uses ) - 1 ) );
						isect_count = 0;
					}
					else if( isect_count > 2 )
					{
						rt_log( "%d intersections of line with loop\n" , isect_count );
						rt_bomb( "!!!\n" );
					}
if( isect_count )
{
	int jra;

	rt_log( "After loop intersect:\n" );
	for( jra=0 ; jra < NMG_TBL_END( &vertex_uses ) ; jra++ )
	{
		struct vertexuse *vu_tmp;
		struct edgeuse *eu_tmp;
		struct loopuse *lu_tmp;

		vu_tmp = (struct vertexuse *)NMG_TBL_GET( &vertex_uses , jra );
		eu_tmp = vu_tmp->up.eu_p;
		lu_tmp = eu_tmp->up.lu_p;
		rt_log( "\tvu = x%x, eu = x%x, lu = x%x\n" , vu_tmp , eu_tmp , lu_tmp );
	}
}	
				}
			}
			fu2 = RT_LIST_PNEXT( faceuse , &fu2->l );
		}
	}

	/* go through list of vertexuses and cut some loops */
	if( NMG_TBL_END( &vertex_uses )%4 )
	{
		rt_log( "nmg_extrude_cleanup: NMG_TBL_END( &vertex_uses ) = %d\n" , NMG_TBL_END( &vertex_uses ) );
		rt_bomb( "nmg_extrude_cleanup: Bad number of vertex uses in intersection list\n" );
	}
	for( i=0 ; i<NMG_TBL_END( &vertex_uses ) ; i += 2 )
	{
		struct vertexuse *vu1,*vu2;
		struct loopuse *old_lu[2];
		struct loopuse *new_lu[2];
		struct loopuse *chk_lu;
		struct faceuse *new_fu;
		struct faceuse *fu_cut[2];
		struct edgeuse *eu_base=NULL;
		int orientation;
		int j;

		if( i%4 )
			j = 1;
		else
			j = 0;


		/* take vertexuses off list in pairs (that's how they were put on) */
		vu1 = (struct vertexuse *)NMG_TBL_GET( &vertex_uses , i );
		vu2 = (struct vertexuse *)NMG_TBL_GET( &vertex_uses , i+1 );

		fu_cut[j] = nmg_find_fu_of_vu( vu1 );

		/* remember orientation */
		old_lu[j] = nmg_find_lu_of_vu( vu1 );
		orientation = old_lu[j]->orientation;

		/* cut loop */
		chk_lu = nmg_find_lu_of_vu( vu2 );
		if( old_lu[j] == chk_lu )
		{
			new_lu[j] = nmg_cut_loop( vu1 , vu2 );
rt_log( "cutting loop at vus x%x and x%x made new_lu x%x\n" , vu1 , vu2 , new_lu[j] );

			/* restore orientations */
#if 0
			new_lu[j]->orientation = orientation;
			old_lu[j]->orientation = orientation;
			new_lu[j]->lumate_p->orientation = orientation;
			old_lu[j]->lumate_p->orientation = orientation;
#else
			nmg_lu_reorient( new_lu[j] , tol );
			nmg_lu_reorient( old_lu[j] , tol );
#endif

#if 0
			/* make a new face from the new loop */
			new_fu = nmg_mk_new_face_from_loop( new_lu[j] );
rt_log( "made new_fu x%x\n" , new_fu );

			if( nmg_fu_planeeqn( new_fu , tol ) )
				rt_log( "Couldn't calculate plane equation for new face\n" );

			/* make sure new_fu has orientation compatible with its radial faces */
			lu = RT_LIST_FIRST( loopuse , &new_fu->lu_hd );
			for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
			{
				struct edgeuse *eu_radial;

				eu_radial = eu->radial_p;
				fu = nmg_find_fu_of_eu( eu_radial );
				if( fu == new_fu )
					continue;

				if( fu->orientation != new_fu->orientation )
				{
					nmg_reverse_face( new_fu );
rt_log( "reversing orientation of fu x%x\n" , new_fu );
				}

				break;
			}

#endif
			/* Make sure all edguese between the vertices at vu1 and vu2 share same edge */
rt_log( "Looking for radial edges between verterx x%x and x%x\n" , vu1->v_p , vu2->v_p );
			for( RT_LIST_FOR( vu , vertexuse , &vu1->v_p->vu_hd ) )
			{
				if( *vu->up.magic_p != NMG_EDGEUSE_MAGIC )
					continue;
				eu = vu->up.eu_p;
				NMG_CK_EDGEUSE( eu );
rt_log( "\tChecking edgeuse x%x on edge x%x from vertex x%x to x%x ( %f %f %f ) to ( %f %f %f ) \n" , 
eu , eu->e_p , eu->vu_p->v_p , eu->eumate_p->vu_p->v_p , V3ARGS( eu->vu_p->v_p->vg_p->coord ) , V3ARGS(  eu->eumate_p->vu_p->v_p->vg_p->coord ) );
				if( eu->eumate_p->vu_p->v_p == vu2->v_p )
				{
					if( !eu_base )
						eu_base = eu;
					else if( eu->e_p != eu_base->e_p )
					{
rt_log( "Joining eus x%x and x%x\n" , eu_base , eu );
/*						nmg_radial_join_eu_no_ck( eu_base , eu , tol ); */
						nmg_radial_join_eu( eu_base , eu , tol );
rt_log( "\tDone!\n" );
					}
				}
			}
		}

		if( i%4 )
		{
			fastf_t dist_to_plane;
			plane_t pl;
			int bad_loop=0;

			/* One loop from each face must be anti-normalward to the other
			 * face. That loop is unwanted, so put it on the "bad" list.
			 */

			/* Check the loops from first face against the second face */
			NMG_GET_FU_PLANE( pl , fu_cut[1] );
			for( RT_LIST_FOR( eu , edgeuse , &old_lu[0]->down_hd ) )
			{
				dist_to_plane = DIST_PT_PLANE( eu->vu_p->v_p->vg_p->coord , pl );
				if( dist_to_plane < (-tol->dist ) )
				{
					bad_loop = 1;
					break;
				}
			}

			if( bad_loop )
				nmg_tbl( &bad_loops , TBL_INS , (long *)old_lu[0] );
			else
			{
				for( RT_LIST_FOR( eu , edgeuse , &new_lu[0]->down_hd ) )
				{
					dist_to_plane = DIST_PT_PLANE( eu->vu_p->v_p->vg_p->coord , pl );
					if( dist_to_plane < (-tol->dist ) )
					{
						bad_loop = 1;
						break;
					}
				}
				if( bad_loop )
					nmg_tbl( &bad_loops , TBL_INS , (long *)new_lu[0] );
			}

			/* Check the loops from second face against the first face */
			bad_loop = 0;
			NMG_GET_FU_PLANE( pl , fu_cut[0] );
			for( RT_LIST_FOR( eu , edgeuse , &old_lu[1]->down_hd ) )
			{
				dist_to_plane = DIST_PT_PLANE( eu->vu_p->v_p->vg_p->coord , pl );
				if( dist_to_plane < (-tol->dist ) )
				{
					bad_loop = 1;
					break;
				}
			}

			if( bad_loop )
				nmg_tbl( &bad_loops , TBL_INS , (long *)old_lu[1] );
			else
			{
				for( RT_LIST_FOR( eu , edgeuse , &new_lu[1]->down_hd ) )
				{
					dist_to_plane = DIST_PT_PLANE( eu->vu_p->v_p->vg_p->coord , pl );
					if( dist_to_plane < (-tol->dist ) )
					{
						bad_loop = 1;
						break;
					}
				}
				if( bad_loop )
					nmg_tbl( &bad_loops , TBL_INS , (long *)new_lu[1] );
			}
		}
else
rt_log( "not cutting loop at  vus x%x and x%x (%f %f %f) (%f %f %f)\n" , vu1 , vu2 , V3ARGS( vu1->v_p->vg_p->coord ) , V3ARGS( vu2->v_p->vg_p->coord ) );
	}

	if( NMG_TBL_END( &vertex_uses ) )
#endif
	{
		/* look for self-touching loops */
		for( RT_LIST_FOR( fu , faceuse , &is->fu_hd ) )
		{
			struct loopuse *lu1;
			plane_t plane;

			if( fu->orientation != OT_SAME )
				continue;

			NMG_GET_FU_PLANE( plane , fu );

			lu = RT_LIST_LAST( loopuse , &fu->lu_hd );
			while( RT_LIST_NOT_HEAD( lu , &fu->lu_hd ) )
			{
				struct loopuse *new_lu;
				struct faceuse *new_fu;
				int orientation;

				/* check this loop */
				while( (vu=(struct vertexuse *)nmg_loop_touches_self( lu ) ) != (struct vertexuse *)NULL )
				{
					/* Split this touching loop, but give both resulting loops
					 * the same orientation as the original. This will result
					 * in the part of the loop that needs to be discarded having
					 * an incorrect orientation with respect to the face.
					 * This incorrect orientation will be discovered later by
					 * "nmg_bad_face_normals" and will result in the undesirable
					 * portion's demise
					 */
					orientation = lu->orientation;
					new_lu = nmg_split_lu_at_vu( lu , vu );
					new_lu->orientation = orientation;
					lu->orientation = orientation;
					new_lu->lumate_p->orientation = orientation;
					lu->lumate_p->orientation = orientation;
				}

				lu = RT_LIST_PLAST( loopuse , &lu->l );
			}
		}
	}

	/* if the vertex_uses list is not empty, we have work to do */
#if 0
	if( NMG_TBL_END( &vertex_uses ) )
#endif
	{
		struct nmgregion *old_r;
		struct shell *s_tmp;
		int inside_shells;

		nmg_rebound( m , tol );

		/* remember the nmgregion where "is" came from */
		old_r = is->r_p;

		/* make a new nmgregion , shell, and vertex */
		new_r = nmg_mrsv( m );

		/* s_tmp is the shell just created */
		s_tmp = RT_LIST_FIRST( shell , &new_r->s_hd );

		/* move our shell (is) to the new nmgregion
		 * in preparaion for nmg_decompose_shell.
		 * don't want to confuse pieces of this shell
		 * with other shells in "old_r"
		 */
		if( nmg_mv_shell_to_region( is , new_r ) )
			rt_bomb( "nmg_extrude_shell: Inside shell was only shell!!!\n" );

		/* kill the unused, newly created shell */
		if( nmg_ks( s_tmp ) )
			rt_bomb( "nmg_extrude_shell: Nothing got moved to new region\n" );

		/* now decompose our shell */
		if( (inside_shells=nmg_decompose_shell( is , tol )) < 2 )
		{
			/* if we still have only one shell,
			 * just move it back
			 */
rt_log( "\n%d inside shells\n" , inside_shells );
			if( nmg_mv_shell_to_region( is , old_r ) )
			{
				nmg_kr( new_r );
				new_r = NULL;
			}
		}
		else
		{
			/* look at each shell in "new_r" */
rt_log( "\n%d inside shells\n" , inside_shells );
			s_tmp = RT_LIST_FIRST( shell , &new_r->s_hd );
			while( RT_LIST_NOT_HEAD( &s_tmp->l , &new_r->s_hd ) )
			{
				struct shell *next_s;
				int kill_it=0;

				next_s = RT_LIST_PNEXT( shell , &s_tmp->l );
rt_log( "SHELL!!!\n" );
nmg_pr_s_briefly( s_tmp , (char *)NULL );

#if 0
				/* check for a shell with bad faceuse normals */
				if( nmg_bad_face_normals( s_tmp , tol ) )
				{
					/* Bad shell, kill it */
					if( nmg_ks( s_tmp ) )
					{
						nmg_kr( new_r );
						new_r = NULL;
						is = NULL;
						break;
					}
				}

				/* check if inside shell is too close to outer shell */
rt_log( "Comparing shells x%x and x%x at thickness %f tolerance dist is %f\n" , s_tmp , os , thick , tol->dist );
				if( nmg_shells_within_dist( os , s_tmp , thick , tol ) )
				{
#endif
#if 0

				for( RT_LIST_FOR( fu , faceuse , &s_tmp->fu_hd ) )
				{
					for( RT_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
					{
						if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
							continue;
				
						for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
						{
							if( nmg_check_radial( eu , tol ) )
							{
								rt_log( "BAD EU RADIALS for shell x%x\n" , s_tmp );
								kill_it = 1;
								break;
							}
						}
						if( kill_it )
							break;
					}
					if( kill_it )
						break;
				}

				if( kill_it )
				{
					/* Bad shell, kill it */
					if( nmg_ks( s_tmp ) )
					{
						nmg_kr( new_r );
						new_r = NULL;
						is = NULL;
						break;
					}
				}
#endif

				for( RT_LIST_FOR( fu , faceuse , &s_tmp->fu_hd ) )
				{
					for( RT_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
					{
						struct loopuse *bad_lu;

						for( i=0 ; i<NMG_TBL_END( &bad_loops ) ; i++ )
						{
							bad_lu = (struct loopuse *)NMG_TBL_GET( &bad_loops , i );
							if( lu == bad_lu )
							{
								kill_it = 1;
								break;
							}
						}
						if( kill_it )
							break;
					}
					if( kill_it )
						break;
				}
				if( kill_it )
				{
					/* Bad shell, kill it */
					if( nmg_ks( s_tmp ) )
					{
						nmg_kr( new_r );
						new_r = NULL;
						is = NULL;
						break;
					}
				}
				s_tmp = next_s;
			}
		}

		nmg_tbl( &bad_loops , TBL_FREE , (long *)NULL );

		if( new_r )
		{
			/* merge remaining shells in "new_r" */
			is = RT_LIST_FIRST( shell , &new_r->s_hd );
			s_tmp = RT_LIST_PNEXT( shell , &is->l );
			while( RT_LIST_NOT_HEAD( &s_tmp->l , &new_r->s_hd ) )
			{
				struct shell *next_s;

				next_s = RT_LIST_PNEXT( shell , &s_tmp->l );

				if( s_tmp == is )
				{
					s_tmp = next_s;
					continue;
				}

				nmg_js( is , s_tmp , tol );
				s_tmp = next_s;
			}

			/* move it all back into the original nmgregion */
			(void)nmg_mv_shell_to_region( is , old_r );

			/* kill the temporary nmgregion */
			if( RT_LIST_NON_EMPTY( &new_r->s_hd ) )
				rt_log( "nmg_extrude_cleanup: temporary nmgregion not empty!!\n" );
			(void)nmg_kr( new_r );
		}
	}
	return( is );
}

a6193 169
}

/*
 *	N M G _ E X T R U D E _ S H E L L
 *
 *	Hollows out a shell producing a wall thickness of thickness "thick"
 *	by creating a new "inner" shell and combining the two shells.
 *
 *	If the original shell is closed, the new shell is simply
 *	merged with the original shell.  If the original shell is open, then faces
 *	are constructed along the free edges of the two shells to make a closed shell.
 *
 */
void
nmg_extrude_shell( s , thick , tol )
struct shell *s;
CONST fastf_t thick;
CONST struct rt_tol *tol;
{
	struct nmgregion *new_r;
	struct vertex *v;
	struct vertexuse *vu;
	struct edgeuse *eu;
	struct loopuse *lu;
	struct faceuse *fu;
	struct face_g *fg_p;
	struct model *m;
	struct shell *is;	/* inside shell */
	struct nmg_ptbl vertex_uses,faces;
	long *flags;
	long **copy_tbl;
	int i,j;

	if( rt_g.NMG_debug & DEBUG_BASIC )
		rt_log( "nmg_extrude_shell( s=x%x , thick=%f)\n" , s , thick );

	NMG_CK_SHELL( s );
	RT_CK_TOL( tol );

	if( thick < 0.0 )
	{
		rt_log( "nmg_extrude_shell: thickness less than zero not allowed" );
		return;
	}

	if( thick < tol->dist )
	{
		rt_log( "nmg_extrude_shell: thickness less than tolerance not allowed" );
		return;
	}

	m = nmg_find_model( (long *)s );

	/* first make a copy of this shell */
	is = nmg_dup_shell( s , &copy_tbl );

	/* make a translation table for this model */
	flags = (long *)rt_calloc( m->maxindex , sizeof( long ) , "nmg_extrude_shell flags" );

	/* now adjust all the planes, first move them inward by distance "thick" */
	for( RT_LIST_FOR( fu , faceuse , &is->fu_hd ) )
	{
		NMG_CK_FACEUSE( fu );
		NMG_CK_FACE( fu->f_p );
		fg_p = fu->f_p->fg_p;
		NMG_CK_FACE_G( fg_p );

		/* move the faces by the distance "thick" */
		if( NMG_INDEX_TEST_AND_SET( flags , fg_p ) )
			fg_p->N[3] -= thick;
	}

	/* Reverse the normals of all the faces */
	for( RT_LIST_FOR( fu , faceuse , &is->fu_hd ) )
	{
		/* "nmg_reverse_face" does the fu and fu mate */
		if( fu->orientation == OT_SAME )
		{
			if( NMG_INDEX_TEST_AND_SET( flags , fu->f_p ) )
				nmg_reverse_face( fu );
		}
	}

	/* now start adjusting the vertices
	 * Use the original shell so that we can pass the original vertex to nmg_inside_vert
	 */
	for( RT_LIST_FOR( fu , faceuse , &s->fu_hd ) )
	{
		if( fu->orientation != OT_SAME )
			continue;

		for( RT_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
		{
			NMG_CK_LOOPUSE( lu );
			if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) == NMG_VERTEXUSE_MAGIC )
			{
				/* the vertex in a loop of one vertex
				 * must show up in an edgeuse somewhere,
				 * so don't mess with it here */
				continue;
			}
			else
			{
				for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
				{
					struct vertex *new_v;

					NMG_CK_EDGEUSE( eu );
					vu = eu->vu_p;
					NMG_CK_VERTEXUSE( vu );
					new_v = NMG_INDEX_GETP( vertex , copy_tbl , vu->v_p );
					NMG_CK_VERTEX( new_v )
					if( NMG_INDEX_TEST_AND_SET( flags , new_v ) )
					{
						/* move this vertex */
						if( nmg_in_vert( new_v , tol ) )
							rt_bomb( "Failed to get a new point from nmg_inside_vert\n" );
					}
				}
			}
		}
	}
	/* recompute the bounding boxes */
	nmg_region_a( is->r_p , tol );

	nmg_vmodel( m );

	is = nmg_extrude_cleanup( is , s , thick , tol );

	/* Inside shell is done */
	if( is )
	{
		if( nmg_ck_closed_surf( s , tol ) )
		{
			if( !nmg_ck_closed_surf( is , tol ) )
			{
				rt_log( "nmg_extrude_shell: inside shell is not closed, calling nmg_close_shell\n" );
				nmg_close_shell( is );
			}

			nmg_shell_coplanar_face_merge( is , tol , 0 );
			nmg_simplify_shell( is );

			/* now merge the inside and outside shells */
			nmg_js( s , is , tol );
		}
		else
		{
			if( nmg_ck_closed_surf( is , tol ) )
			{
				rt_log( "nmg_extrude_shell: inside shell is closed, outer isn't!!\n" );
				nmg_shell_coplanar_face_merge( is , tol , 0 );
				nmg_simplify_shell( is );
				nmg_js( s , is , tol );
			}
			else
			{
				/* connect the boundaries of the two open shells */
				nmg_open_shells_connect( s , is , copy_tbl , tol );
			}
		}
	}

	/* recompute the bounding boxes */
	nmg_region_a( s->r_p , tol );

	/* free memory */
	rt_free( (char *)flags , "nmg_extrude_shell: flags" );
	rt_free( (char *)copy_tbl , "nmg_extrude_shell: copy_tbl" );
@


1.124
log
@Working version of support routines for patch-g.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.123 94/03/28 14:48:48 jra Exp Locker: jra $ (ARL)";
d830 1
d2924 1
a2924 1
 *	Places a count of edges at this vertex where radial is mate (free_edges)
d2945 1
d2999 3
a3001 2
 *	given a vertex and a list of faces that should intersect at the
 *	vertex, calculate a new location for the vertex.
d3010 1
a3010 1
nmg_simple_vertex_solve( new_v , faces , tol )
a3012 1
CONST struct rt_tol *tol;
a3014 1
	struct rt_tol tol_tmp;
d3021 1
a3021 1
	RT_CK_TOL( tol );
d3036 2
a3037 1
		case 1:
d3042 2
a3043 1
		case 2:
d3059 2
a3060 1
		case 3:
d3153 5
d3166 3
d3227 1
a3251 40
static void
nmg_plot_inter( new_v , int_faces )
CONST struct vertex *new_v;
CONST struct nmg_ptbl *int_faces;
{
	int i,j;
	static int num=0;
	char name[24];
	FILE *fp;

	sprintf( name , "inter%d.pl" , num );
	fp = fopen( name , "w" );
	if( fp == NULL )
	{
		rt_log( "Cannot open %s\n" , name );
		perror( "nmg_plot_inter" );
		return;
	}

	rt_log( "Plotting to %s\n" , name );

	for( i=0 ; i<NMG_TBL_END( int_faces ) ; i++ )
	{
		struct intersect_fus *i_fus,*j_fus;

		j = i+1;
		if( j == NMG_TBL_END( int_faces ) )
			j = 0;

		i_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , i );
		j_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , j );

		pdv_3line( fp , new_v->vg_p->coord , i_fus->vp->vg_p->coord );
		pdv_3line( fp , j_fus->vp->vg_p->coord , i_fus->vp->vg_p->coord );
	}

	fclose( fp );
	num++;
}

d3284 1
d3302 1
d3307 1
d3324 1
d3329 1
d3354 1
a3354 1
		/* get an edgeuse emanating from new_v */
d3382 4
a3404 1

d3435 1
d3448 1
d3451 3
d3478 4
d3516 1
a3516 3
 * faces and selecting the furthest one from new_v.
 * Estimate a value for new_v coords as the average of the
 * selected intersection points.
d3520 1
a3520 1
struct vertex *new_v;
d3536 1
d3544 1
a3548 1

d3565 1
a3565 1
		/* Find intersections with other faces and keep the one
d3569 2
d3577 1
d3588 1
d3598 1
d3623 1
d3631 1
d3649 1
d3668 7
d3676 3
a3678 2
nmg_fix_folded_inters( new_v , int_faces , tol )
CONST struct vertex *new_v;
d3682 2
a3683 2
	int edge_no;
	struct vertex_g *vg;
d3685 1
a3685 3
	NMG_CK_VERTEX( new_v );
	vg = new_v->vg_p;
	NMG_CK_VERTEX_G( vg );
d3688 2
a3689 6
	for( edge_no=0 ; edge_no<NMG_TBL_END( int_faces ) ; edge_no++ )
	{
		struct intersect_fus *edge_fus,*next_fus,*prev_fus;
		fastf_t dist[2];
		int next_edge_no,prev_edge_no;
		int ret;
d3691 2
a3692 1
		edge_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , edge_no );
d3694 2
a3695 2
		if( !edge_fus->got_pt )
			continue;
d3697 7
a3703 3
		next_edge_no = edge_no + 1;
		if( next_edge_no == NMG_TBL_END( int_faces ) )
			next_edge_no = 0;
d3705 9
a3713 2
		next_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , next_edge_no );
		if( next_fus->got_pt )
d3715 4
a3718 6
			ret = rt_dist_line3_lseg3( dist , edge_fus->pt , edge_fus->dir , vg->coord , next_fus->pt , tol );
			if( ret != 1 && ret != 3 && dist[0] > 0.0 )
			{
				VJOIN1( edge_fus->pt , edge_fus->pt , dist[0] , edge_fus->dir );
				continue;
			}
d3720 2
d3723 4
a3726 3
		prev_edge_no = edge_no - 1;
		if( prev_edge_no == (-1) )
			prev_edge_no = NMG_TBL_END( int_faces ) - 1;
d3728 9
a3736 16
		prev_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , prev_edge_no );
		if( prev_fus->got_pt )
		{
			ret = rt_dist_line3_lseg3( dist , edge_fus->pt , edge_fus->dir , vg->coord , prev_fus->pt , tol );
			if( ret != 1 && ret != 3 && dist[0] > 0.0 )
			{
				VJOIN1( edge_fus->pt , edge_fus->pt , dist[0] , edge_fus->dir );
				continue;
			}
		}
	}
	if( rt_g.NMG_debug & DEBUG_BASIC )
	{
		rt_log( "After nmg_fix_folded_inters:\n" );
		nmg_pr_inter( new_v , int_faces );
	}
d3744 1
a3744 2
 * the geometry. Any points within tolerance will end up
 * with the same vertex pointer and geometry
d3759 1
d3817 1
d3826 1
a3826 1

d3830 1
d3834 4
a3838 2
			prev_eu = RT_LIST_PPREV_CIRC( edgeuse , &j_fus->eu->l );
			radial_eu = j_fus->eu->radial_p;
d3840 2
a3841 7
			if( EDGESADJ( prev_eu , j_fus->eu ) )
			{
				nmg_keu( prev_eu );
				nmg_keu( j_fus->eu );
			}
			else
				rt_log( "nmg_split_edges_at_vertex: ERROR - can't find adjacent edges to kill\n" );
d3843 1
a3843 23
			i_fus->fu[1] = j_fus->fu[1];

			if( i_fus->fu[0] && j_fus->fu[1] )
			{
				if( rt_g.NMG_debug & DEBUG_BASIC )
				{
					rt_log( "radial join of eu's x%x and x%x\n" , i_fus->eu , radial_eu );
					rt_log( "\tx%x to x%x and x%x to x%x\n" ,
						i_fus->eu->vu_p->v_p, i_fus->eu->eumate_p->vu_p->v_p,
						radial_eu->vu_p->v_p, radial_eu->eumate_p->vu_p->v_p );
				}
				nmg_radial_join_eu( i_fus->eu , radial_eu , tol );
			}

			if( !i_fus->fu[0] )
				i_fus->eu = radial_eu;
			NMG_CK_EDGEUSE( i_fus->eu );

			if( j_fus->free_edge )
				i_fus->free_edge = 1;

			nmg_tbl( int_faces , TBL_RM , (long *)j_fus );

a3846 2
			rt_free( (char *)j_fus , "nmg_split_edges_at_pts: j_fus " );

d3859 5
a3864 52
nmg_fuse_inters( i_fus , j_fus , int_faces , tol )
struct intersect_fus *i_fus;
struct intersect_fus *j_fus;
struct nmg_ptbl *int_faces;
CONST struct rt_tol *tol;
{
	struct edgeuse *radial_eu;
	struct edgeuse *prev_eu;

	RT_CK_TOL( tol );

	if( rt_g.NMG_debug & DEBUG_BASIC )
		rt_log( "nmg_fuse_inters: i_fus=x%x, j_fus=x%x, %d edges\n" , i_fus, j_fus, NMG_TBL_END( int_faces ) );

	radial_eu = j_fus->eu->radial_p;
	prev_eu = RT_LIST_PPREV_CIRC( edgeuse , &j_fus->eu->l );

	if( EDGESADJ( prev_eu , j_fus->eu ) )
	{
		nmg_keu( prev_eu );
		nmg_keu( j_fus->eu );
	}
	else
		rt_log( "nmg_fuse_inter_verts: ERROR: can't find adjacent edges to kill\n" );

	i_fus->fu[1] = j_fus->fu[1];

	if( i_fus->fu[0] && j_fus->fu[1] )
	{
		if( rt_g.NMG_debug & DEBUG_BASIC )
		{
			rt_log( "radial join of eu's x%x and x%x\n" , i_fus->eu , radial_eu );
			rt_log( "\tx%x to x%x and x%x to x%x\n" ,
				i_fus->eu->vu_p->v_p, i_fus->eu->eumate_p->vu_p->v_p,
				radial_eu->vu_p->v_p, radial_eu->eumate_p->vu_p->v_p );
		}
		nmg_radial_join_eu( i_fus->eu , radial_eu , tol );
	}

	if( !i_fus->fu[0] )
		i_fus->eu = radial_eu;
	NMG_CK_EDGEUSE( i_fus->eu );

	if( j_fus->free_edge )
		i_fus->free_edge = 1;

	nmg_tbl( int_faces , TBL_RM , (long *)j_fus );
	rt_free( (char *)j_fus , "nmg_split_edges_at_pts: j_fus " );

}

static void
d3874 1
d3880 3
d3896 1
a3896 1
#if 0
a3899 31
		struct edgeuse *eu;

		NMG_CK_VERTEXUSE( vu );

		if( *vu->up.magic_p != NMG_EDGEUSE_MAGIC )
		{
			vu = RT_LIST_PNEXT( vertexuse , &vu->l );
			continue;
		}

		eu = vu->up.eu_p;

		if( eu->eumate_p->vu_p->v_p != new_v )
		{
			vu = RT_LIST_PNEXT( vertexuse , &vu->l );
			continue;
		}

		/* edge runs from new_v to new_v, kill it */
		while( (eu->vu_p == vu || eu->eumate_p->vu_p == vu) &&
				RT_LIST_NOT_HEAD( vu , &new_v->vu_hd ) )
		{
			vu = RT_LIST_PNEXT( vertexuse , &vu->l );
		}
		nmg_keu( eu );
	}
#else

	vu = RT_LIST_FIRST( vertexuse , &new_v->vu_hd );
	while( RT_LIST_NOT_HEAD( vu , &new_v->vu_hd ) )
	{
d3919 1
d3939 1
d3954 1
d3980 1
d3996 1
d3999 1
a4008 1
#endif
a4010 98
#if 0
static void
nmg_fuse_inter_verts( new_v , int_faces , tol )
CONST struct vertex *new_v;
struct nmg_ptbl *int_faces;
CONST struct rt_tol *tol;
{
	int edge_no=0;

	if( rt_g.NMG_debug & DEBUG_BASIC )
	{
		rt_log( "nmg_fuse_inter_verts( new_v=x%x ( %f %f %f ), int_faces=x%x)\n",
			new_v, V3ARGS( new_v->vg_p->coord ) , int_faces );
	}

	NMG_CK_VERTEX( new_v );
	RT_CK_TOL( tol );

	while( edge_no < NMG_TBL_END( int_faces ) )
	{
		struct intersect_fus *edge_fus,*next_fus;
		struct edgeuse *radial_eu;
		struct edgeuse *prev_eu;
		int next_edge_no;

		next_edge_no = edge_no + 1;
		if( next_edge_no == NMG_TBL_END( int_faces ) )
			next_edge_no = 0;

		edge_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , edge_no );
		next_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , next_edge_no );

		if( next_edge_no == 0 && ( edge_fus->free_edge || next_fus->free_edge ) )
		{
			edge_no++;
			continue;
		}

		if( !edge_fus->vp || !next_fus->vp )
		{
			edge_no++;
			continue;
		}

		if( !rt_pt3_pt3_equal( edge_fus->vp->vg_p->coord , next_fus->vp->vg_p->coord , tol ) )
		{
			edge_no++;
			continue;
		}

		radial_eu = next_fus->eu->radial_p;
		prev_eu = RT_LIST_PPREV_CIRC( edgeuse , &next_fus->eu->l );

		if( rt_g.NMG_debug & DEBUG_BASIC )
			rt_log( "\tJoining vertices x%x and x%x\n" , edge_fus->vp , next_fus->vp );

		nmg_jv( edge_fus->vp , next_fus->vp );

		if( EDGESADJ( prev_eu , next_fus->eu ) )
		{
			nmg_keu( prev_eu );
			nmg_keu( next_fus->eu );
		}
		else
			rt_log( "nmg_fuse_inter_verts: ERROR: can't find adjacent edges to kill\n" );

		edge_fus->fu[1] = next_fus->fu[1];

		if( edge_fus->fu[0] && next_fus->fu[1] )
		{
			if( rt_g.NMG_debug & DEBUG_BASIC )
			{
				rt_log( "radial join of eu's x%x and x%x\n" , edge_fus->eu , radial_eu );
				rt_log( "\tx%x to x%x and x%x to x%x\n" ,
					edge_fus->eu->vu_p->v_p, edge_fus->eu->eumate_p->vu_p->v_p,
					radial_eu->vu_p->v_p, radial_eu->eumate_p->vu_p->v_p );
			}
			nmg_radial_join_eu( edge_fus->eu , radial_eu , tol );
		}

		if( !edge_fus->fu[0] )
			edge_fus->eu = radial_eu;
		NMG_CK_EDGEUSE( edge_fus->eu );

		if( next_fus->free_edge )
			edge_fus->free_edge = 1;

		nmg_tbl( int_faces , TBL_RM , (long *)next_fus );
		rt_free( (char *)next_fus , "nmg_split_edges_at_pts: next_fus " );
	}
	if( rt_g.NMG_debug & DEBUG_BASIC )
	{
		rt_log( "After vertex fusion:\n" );
		nmg_pr_inter( new_v , int_faces );
	}
}
#endif

d4030 1
d4190 1
d4291 1
d4299 2
a4300 1
		 * Find uses of the two vertices in the same loopuse */
d4340 2
a4341 2
		 * This will never be called for a vertex that borders
		 * a free edge or a hole, so all loops are OT_SAME
d4390 1
d4522 9
d4618 1
d4627 4
d4647 1
d4653 1
d4669 1
d4677 1
d4734 1
d4753 1
d4760 1
d4766 1
d4773 1
d4779 1
d4790 1
d4805 1
d4818 1
d4852 1
d4862 1
d4867 1
d4875 1
d4884 1
d4899 4
d4917 2
d4928 1
d4964 1
d5021 1
a5049 2
/*	nmg_fix_folded_inters( new_v , &int_faces , tol );	*/

d5059 1
a5059 3
#if 0
	/* fuse intersection points within tolerance */
	nmg_fuse_inter_verts( new_v , &int_faces , tol );
d5061 1
a5061 2
	/* vertex fusion will create cracks */
	nmg_kill_cracks_at_vertex( new_v );
a5062 13
	if( rt_g.NMG_debug & DEBUG_BASIC )
	{
		rt_log( "After kill cracks:\n" );
		nmg_pr_inter( new_v , &int_faces );
	}
#else
	nmg_remove_short_eus_inter( new_v , &int_faces , tol );
	nmg_simplify_inter( new_v , &int_faces , tol );
#endif
#if 0
	/* Fuse collinear edges */
	nmg_fuse_collinear_edges( new_v , &int_faces , tol );
#endif
d6062 1
a6062 1
						if( nmg_simple_vertex_solve( vu->v_p , &faces , tol ) )
d6095 1
a6095 1
						if( nmg_simple_vertex_solve( vu->v_p , &faces , tol ) )
d6194 1
d6313 1
d6462 1
d6832 1
a6832 1
		if( nmg_simple_vertex_solve( new_v , &faces , tol ) )
@


1.123
log
@Support routines for patch-g using max edge intersection with all planes.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.122 94/03/24 18:19:43 jra Exp Locker: jra $ (ARL)";
d184 12
d834 1
a834 1
	(void)nmg_tbl( &eu_tbl , TBL_INIT , NULL );
d869 1
a869 1
		nmg_tbl( &eu_tbl , TBL_FREE , NULL );
d884 1
a884 1
	(void)nmg_tbl( &vert_tbl , TBL_INIT , NULL );
d960 1
a960 1
				nmg_tbl( &vert_tbl , TBL_RST , NULL );
d998 1
a998 1
				(void)nmg_tbl( &vert_tbl , TBL_RST , NULL );
d1128 2
a1129 2
			nmg_tbl( &eu_tbl , TBL_FREE , NULL );
			nmg_tbl( &vert_tbl , TBL_FREE , NULL );
d1136 1
a1136 1
		nmg_tbl( &vert_tbl , TBL_RST , NULL );
d1175 2
a1176 2
	nmg_tbl( &eu_tbl , TBL_FREE , NULL );
	nmg_tbl( &vert_tbl , TBL_FREE , NULL );
d1227 1
a1227 1
	nmg_tbl( &faces , TBL_INIT , NULL );
d1280 1
a1280 1
	nmg_tbl( &faces , TBL_FREE , NULL );
d1641 1
a1641 1
	nmg_tbl( &stack , TBL_INIT , NULL );
d1724 1
a1724 1
	nmg_tbl( &stack , TBL_FREE , NULL );
d2245 2
a2246 2
	nmg_tbl( &stack , TBL_INIT , NULL );
	nmg_tbl( &shared_edges , TBL_INIT , NULL );
d2370 2
a2371 2
		nmg_tbl( &stack , TBL_FREE , NULL );
		nmg_tbl( &shared_edges , TBL_FREE , NULL );
d2381 1
a2381 1
		nmg_tbl( &stack , TBL_RST , NULL );
d2603 2
a2604 2
	nmg_tbl( &stack , TBL_FREE , NULL );
	nmg_tbl( &shared_edges , TBL_FREE , NULL );
d3049 3
d3062 4
a3065 1
				rt_log( "nmg_simple_vertex_solve: failed for  3 planes\n" );
d3168 1
d3178 1
d3180 2
d3185 4
a3188 1
		rt_log( "\tfu1 = x%x (face=x%x), fu2 = x%x (face=x%x)\n" , i_fus->fu[0] , fp1 , i_fus->fu[1] , fp2 );
d3197 1
d3299 2
d3302 2
a3306 3
	if( rt_g.NMG_debug & DEBUG_BASIC )
		rt_log( "nmg_get_edge_lines( new_v=x%x , int_faces=x%x )\n" , new_v , int_faces );

d3312 3
d3322 10
d3402 14
d3466 15
d3530 1
a3530 1
void
d3537 4
d3549 11
d3563 2
a3564 2
		struct intersect_fus *edge_fus,*other_fus[2];
		fastf_t max_dist;
a3579 70
		for( other_index=0 ; other_index < NMG_TBL_END( faces ) ; other_index++ )
		{
			struct face *f;
			fastf_t dist;
			int ret_val;

			f = (struct face *)NMG_TBL_GET( faces , other_index );

			if( !f )
				continue;

			/* don't intersect with planes used to calculate edge line */
			if( edge_fus->fu[0] && f == edge_fus->fu[0]->f_p )
				continue;

			if( edge_fus->fu[1] && f == edge_fus->fu[1]->f_p )
				continue;

			/* don't intersect with planes parallel to edge line */
			if( RT_VECT_ARE_PERP( VDOT( edge_fus->dir , f->fg_p->N ) , tol ) )
				continue;

			if( (ret_val=rt_isect_line3_plane( &dist , edge_fus->start , edge_fus->dir , f->fg_p->N , tol )) < 1 )
			{
				if( rt_g.NMG_debug & DEBUG_BASIC )
				{
					rt_log( "return from rt_isect_line3_plane is %d for edge %d and plane %d \n" , ret_val , edge_no , other_index );
					rt_log( "\tfor line ( %f %f %f ) -> ( %f %f %f )\n",
						V3ARGS( edge_fus->start ) , V3ARGS( edge_fus->dir ) );
					rt_log( "\tand plane ( %f %f %f %f )\n" , V4ARGS( f->fg_p->N ) );
				}
				continue;
			}
			else if( rt_g.NMG_debug & DEBUG_BASIC )
			{
				rt_log( "return from rt_isect_line3_plane is %d\n" , ret_val );
				rt_log( "\tfor line ( %f %f %f ) -> ( %f %f %f )\n",
					V3ARGS( edge_fus->start ) , V3ARGS( edge_fus->dir ) );
				rt_log( "\tand plane ( %f %f %f %f )\n" , V4ARGS( f->fg_p->N ) );
				rt_log( "\tpl dot dir = %g, tol->perp=%g\n" , VDOT( edge_fus->dir, f->fg_p->N ) , tol->perp );
				rt_log( "\tdist = %f\n" , dist );
			}

			if( dist > max_dist )
				max_dist = dist;
		}

		if( max_dist > 0.0 )
		{
			VJOIN1( edge_fus->pt , edge_fus->start , max_dist , edge_fus->dir );
			edge_fus->got_pt = 1;
		}
	}

	edge_no = 0;
	while( edge_no < NMG_TBL_END( int_faces ) )
	{
		struct intersect_fus *edge_fus,*next_fus;
		fastf_t dist[2];
		int next_edge_no;

		edge_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , edge_no );

		/* If we already have an intersect point, don`t calcaulate a new one */
		if( edge_fus->got_pt )
		{
			edge_no++;
			continue;
		}

d3584 3
a3586 2
		next_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , next_edge_no );
		while( next_fus->fu[0] == next_fus->fu[1] && next_edge_no != edge_no )
d3592 2
a3593 1
			next_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , next_edge_no );
d3596 1
a3596 1
		if( next_edge_no == edge_no )
d3598 5
a3602 2
			edge_no++;
			continue;
d3605 7
a3611 1
		if( edge_fus->free_edge && next_fus->free_edge )
d3613 5
a3617 2
			edge_no++;
			continue;
d3620 1
a3620 2
		if( rt_dist_line3_line3( dist, edge_fus->start, edge_fus->dir,
					next_fus->start, next_fus->dir , tol ) )
d3622 5
a3626 2
			edge_no++;
			continue;
d3629 1
a3629 1
		if( dist[0] < tol->dist || dist[1] < tol->dist )
d3631 2
a3632 3
			edge_no++;
			continue;
		}
d3634 3
a3636 4
		VJOIN1( edge_fus->pt , edge_fus->start , dist[0] , edge_fus->dir );
		VMOVE( next_fus->pt , edge_fus->pt );
		edge_fus->got_pt = 1;
		next_fus->got_pt = 1;
d3638 13
a3650 1
		edge_no += 2;
a3651 5
	if( rt_g.NMG_debug & DEBUG_BASIC )
	{
		rt_log( "After looking for crossed edges in nmg_get_max_edge_inters:\n" );
		nmg_pr_inter( new_v , int_faces );
	}
d3667 2
d3889 5
d3943 3
d3959 1
d3989 109
d4614 1
a4614 1
	nmg_tbl( &fus_at_vert , TBL_INIT , NULL );
a4668 1
rt_log( "Killing crack ( %f %f %f ) <-> ( %f %f %f )\n" , V3ARGS( eu->vu_p->v_p->vg_p->coord ) , V3ARGS( eu_prev->vu_p->v_p->vg_p->coord ) );
a4686 1
rt_log( "Killing loop\n" );
a4696 1
rt_log( "Killing faceuse\n" );
d4701 1
a4701 1
	nmg_tbl( &fus_at_vert , TBL_FREE , NULL );
d5169 1
a5169 1
	nmg_tbl( &int_faces , TBL_INIT , NULL );
d5175 2
d5178 1
d5182 1
a5182 1
	 * faces that meet at new_v. The intersection that is furthest
d5185 5
a5189 1
	nmg_get_max_edge_inters( new_v , &int_faces , faces , tol );
d5236 1
a5236 1
	nmg_tbl( &int_faces , TBL_FREE , NULL );
d5430 2
a5431 2
	nmg_tbl( &vertex_uses , TBL_INIT , NULL );
	nmg_tbl( &bad_loops , TBL_INIT , NULL );
d6006 1
a6006 1
		nmg_tbl( &bad_loops , TBL_FREE , NULL );
d6216 1
a6216 1
					nmg_tbl( &faces , TBL_INIT , NULL );
d6225 1
a6225 1
							nmg_tbl( &faces , TBL_FREE , NULL );
d6249 1
a6249 1
					nmg_tbl( &faces , TBL_INIT , NULL );
d6258 1
a6258 1
							nmg_tbl( &faces , TBL_FREE , NULL );
d6267 1
a6267 1
			nmg_tbl( &faces , TBL_FREE , NULL );
d6490 1
a6490 1
	nmg_tbl( &verts , TBL_INIT , NULL );
d6544 1
a6544 1
		nmg_tbl( &verts , TBL_RST , NULL );
d6940 1
a6940 1
	nmg_tbl( &faces , TBL_INIT , NULL );
d6948 1
a6948 1
	nmg_tbl( &faces , TBL_FREE , NULL );
d6982 1
a6982 1
	nmg_tbl( &faces , TBL_INIT , NULL );
d7004 1
a7004 1
	nmg_tbl( &faces , TBL_FREE , NULL );
d7208 1
a7208 1
	(void)nmg_tbl( &vertices , TBL_FREE , NULL );
@


1.122
log
@Checkpoint
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.121 94/03/18 12:54:25 jra Exp Locker: jra $ (ARL)";
d4247 2
a4248 2
		/* only two intersect points left, move new_v to the center of
		 * the connecting line. No new faces needed
d4254 1
a4254 1
		if( i_fus->vp && j_fus->vp )
a4435 5
	if( rt_g.NMG_debug & DEBUG_BASIC )
	{
		rt_log( "After make faces:\n" );
		nmg_pr_inter( new_v , int_faces );
	}
d4514 1
d4533 1
d4544 1
d4552 159
a4732 1
 * Also fuses new vertices that are within tolerance of each other
d4740 1
a4740 1
	int edge_no=0;
d4743 1
a4743 1
		rt_log( "nmg_fix_crossed_loops( new_v = x%x , %d intersect_fus structs )\n" , new_v , NMG_TBL_END( int_faces ) );
d4745 1
a4746 1
	NMG_CK_VERTEX( new_v );
d4748 2
a4749 2
	/* look for crossed edges */
	while( edge_no < NMG_TBL_END( int_faces ) )
d4751 7
a4757 12
		int next_edge_no;
		struct intersect_fus *i_fus,*j_fus;
		struct edgeuse *i_next_eu,*j_next_eu;
		vect_t i_dir,j_dir;
		struct vertex *i_start,*i_end,*j_start,*j_end;
		point_t i_end_pt,j_end_pt;
		vect_t off_plane;
		plane_t pl;
		fastf_t dist[2];
		int ret_val;
		plane_t pl1,pl2,pl3;
		point_t new_pt;
d4759 1
a4759 4
		/* will be comparing this edge with next */
		next_edge_no = edge_no + 1;
		if( next_edge_no == NMG_TBL_END( int_faces ) )
			next_edge_no = 0;
d4761 2
a4762 2
		i_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , edge_no );
		j_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , next_edge_no );
d4764 3
a4766 10
		if( i_fus->free_edge || j_fus->free_edge )
		{
			edge_no++;
			continue;
		}
		if( !i_fus->vp || !j_fus->vp )
		{
			edge_no++;
			continue;
		}
d4768 1
a4768 1
		NMG_GET_FU_PLANE( pl , i_fus->fu[1] );
d4770 4
a4773 3
		/* get edgeuses leaving from new vertices */
		i_next_eu = RT_LIST_PNEXT_CIRC( edgeuse , &i_fus->eu->l );
		j_next_eu = RT_LIST_PNEXT_CIRC( edgeuse , &j_fus->eu->l );
d4775 3
a4777 2
		NMG_CK_EDGEUSE( i_next_eu );
		NMG_CK_EDGEUSE( j_next_eu );
d4779 1
a4779 3
		/* get endpoints for these edges */
		i_end = i_next_eu->eumate_p->vu_p->v_p;
		j_end = j_next_eu->eumate_p->vu_p->v_p;
d4781 4
a4784 2
		NMG_CK_VERTEX( i_end );
		NMG_CK_VERTEX( j_end );
d4786 2
a4787 5
		/* since the other end of these edges may not have been adjusted yet
		 * project the endpoints onto the face plane
		 */
		VJOIN1( i_end_pt , i_end->vg_p->coord , -(DIST_PT_PLANE( i_end->vg_p->coord , pl )) , pl );
		VJOIN1( j_end_pt , j_end->vg_p->coord , -(DIST_PT_PLANE( j_end->vg_p->coord , pl )) , pl );
d4789 6
a4794 3
		/* get start points, guaranteed to be on plane */
		i_start =  i_next_eu->vu_p->v_p;
		j_start =  j_next_eu->vu_p->v_p;
d4796 4
a4799 2
		NMG_CK_VERTEX( i_start );
		NMG_CK_VERTEX( j_start );
d4801 15
a4815 3
		/* calculate direction vectors for use by rt_isect_lseg3_lseg3 */
		VSUB2( i_dir , i_end_pt , i_start->vg_p->coord );
		VSUB2( j_dir , j_end_pt , j_start->vg_p->coord );
d4817 11
a4827 2
		ret_val = rt_isect_lseg3_lseg3( dist , i_start->vg_p->coord , i_dir ,
			j_start->vg_p->coord , j_dir , tol );
d4829 3
a4831 7
		if( ret_val != 1 )
		{
			/* edges do not intersect or are collinear */
			if( rt_g.NMG_debug & DEBUG_BASIC )
				rt_log( "\treturn from rt_isect_lseg3_lseg3 is %d\n" , ret_val );
			edge_no++;
			continue;
d4833 1
d4835 5
a4839 5
		if( rt_g.NMG_debug & DEBUG_BASIC )
		{
			rt_log( "\tfor struct at x%x and x%X:\n" , i_fus , j_fus );
			rt_log( "\tedges intersect at distances %f and %f\n" , dist[0] , dist[1] );
		}
d4841 8
a4848 10
		if( dist[0] == 0.0 )
			VMOVE( new_pt , i_start->vg_p->coord )
		else if( dist[0] == 1.0 )
			VMOVE( new_pt , i_end_pt )
		else if( dist[1] == 0.0 )
			VMOVE( new_pt , j_start->vg_p->coord )
		else if( dist[1] == 1.0 )
			VMOVE( new_pt , j_end_pt )
		else
			VJOIN1( new_pt , i_start->vg_p->coord , dist[0] , i_dir )
d4850 1
a4850 5
		/* move all occurences of j_fus->vp to i_fus->vp
		 * and move i_fus->vp to the new point
		 */
		VMOVE( i_fus->vp->vg_p->coord , new_pt );
		VMOVE( i_fus->pt , new_pt );
d4852 2
a4853 1
		nmg_jv( i_fus->vp , j_fus->vp );
d4855 3
a4857 1
		nmg_fuse_inters( i_fus , j_fus , int_faces , tol );
d4859 30
d4892 1
a4892 1
		rt_log( "After fix crossed loops:\n" );
d4898 1
a4898 1
nmg_calc_new_v( new_v , int_faces )
d4901 1
d4905 1
a4905 1
	point_t ave_pt;
d4907 1
d4915 2
a4916 1
	VSET( ave_pt , 0.0 , 0.0 , 0.0 );
d4918 2
a4921 1
		struct intersect_fus *edge_fus;
d4932 6
a4937 2
		VADD2( ave_pt , ave_pt , edge_fus->vp->vg_p->coord );
		edge_count += 1.0;
d4940 1
a4940 1
	if( free_edge_count == 2 )
a4941 4
		VBLEND2( new_v->vg_p->coord , 0.5 , free_fus[0]->pt , 0.5 , free_fus[1]->pt );
	}
	else if( edge_count > 0.0 )
	{
d4945 1
a4945 2
		VSCALE( ave_pt , ave_pt , scale );
		VMOVE( new_v->vg_p->coord , ave_pt );
d4947 5
d4955 5
d5032 1
a5032 1
	nmg_fix_folded_inters( new_v , &int_faces , tol );
d5041 1
a5041 1
	nmg_calc_new_v( new_v , &int_faces );
a5067 6

	if( rt_g.NMG_debug & DEBUG_BASIC )
	{
		rt_log( "After second kill cracks:\n" );
		nmg_pr_inter( new_v , &int_faces );
	}
@


1.121
log
@Working version of patch-g support routines
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.120 94/03/16 13:47:17 jra Exp Locker: jra $ (ARL)";
d3126 1
d3188 4
a3191 1
			nmg_pr_fu_around_eu( i_fus->eu , &tol );
d3318 1
d3387 1
a3468 4
	point_t ave_pt;
	fastf_t edge_count=0.0;
	int free_edges=0;
	struct intersect_fus *free_fus[2];
a3475 2
	VSET( ave_pt , 0.0 , 0.0 , 0.0 );

d3543 1
a3543 1
		if( max_dist <= 0.0 )
d3545 2
a3546 1
			VMOVE( edge_fus->pt , edge_fus->start );
d3548 13
a3560 1
		else
d3562 2
a3563 1
			VJOIN1( edge_fus->pt , edge_fus->start , max_dist , edge_fus->dir );
d3566 6
a3571 1
		if( edge_fus->free_edge )
d3573 5
a3577 3
			free_fus[free_edges++] = edge_fus;
			if( free_edges > 2 )
				rt_log( "nmg_get_max_edge_inters: Too may free edges!!\n" );
d3580 31
a3610 2
		VADD2( ave_pt , ave_pt , edge_fus->pt );
		edge_count++;
d3612 5
d3618 1
a3618 1
	if( free_edges == 2 )
d3620 5
a3624 1
		VBLEND2( new_v->vg_p->coord , 0.5 , free_fus[0]->pt , 0.5 , free_fus[1]->pt );
d3626 2
a3627 1
	else
d3629 2
a3630 2
		VSCALE( ave_pt , ave_pt , 1.0/edge_count );
		VMOVE( new_v->vg_p->coord , ave_pt );
d3657 3
d3665 1
a3665 2
		ret = rt_dist_line3_lseg3( dist , edge_fus->pt , edge_fus->dir , vg->coord , next_fus->pt , tol );
		if( ret != 1 && ret != 3 && dist[0] > 0.0 )
d3667 6
a3672 2
			VJOIN1( edge_fus->pt , edge_fus->pt , dist[0] , edge_fus->dir );
			continue;
d3680 1
a3680 2
		ret = rt_dist_line3_lseg3( dist , edge_fus->pt , edge_fus->dir , vg->coord , prev_fus->pt , tol );
		if( ret != 1 && ret != 3 && dist[0] > 0.0 )
d3682 6
a3687 2
			VJOIN1( edge_fus->pt , edge_fus->pt , dist[0] , edge_fus->dir );
			continue;
d3690 5
d3889 56
d4043 1
a4043 1
/*	N M G _ F U S E _ C O L L I N E A R _ E D G E S
d4058 1
a4058 1
		rt_log( "nmg_fuse_collinear_edges( new_v=x%x ( %f %f %f ), int_faces=x%x)\n",
d4115 1
a4115 1
			rt_bomb( "nmg_kill_collinear_edges: Two vertices are the same\n" );
d4154 1
a4154 1
				rt_bomb( "nmg_collinear_edges_kill: vertex within tolerance of new_v\n" );
d4193 1
a4193 1
		rt_log( "\nAfter fusing collinear edges:\n" );
a4606 2
		struct edgeuse *prev_eu;
		struct edgeuse *radial_eu;
d4663 1
a4663 1
		if( ret_val < 0 )
d4665 3
a4667 1
			/* edges do not intersect, no problem here */
d4671 2
a4672 1
		else if( ret_val == 0 )
d4674 2
a4675 2
			/* edges are collinear */
			rt_bomb( "nmg_fix_crossed_loops: ERROR: edges are collinear\n" );
d4678 10
a4687 3
		NMG_GET_FU_PLANE( pl1 , i_fus->fu[0] );
		NMG_GET_FU_PLANE( pl2 , i_fus->fu[1] );
		NMG_GET_FU_PLANE( pl3 , j_fus->fu[1] );
a4688 7
		if( rt_mkpoint_3planes( new_pt , pl1 , pl2 , pl3 ) )
		{
			rt_log( "nmg_fix_crossed_edges: can't find new point\n" );
			edge_no++;
			continue;
		}

a4694 3
		radial_eu = j_fus->eu->radial_p;
		prev_eu = RT_LIST_PPREV_CIRC( edgeuse , &j_fus->eu->l );

d4697 1
a4697 7
		if( EDGESADJ( prev_eu , j_fus->eu ) )
		{
			nmg_keu( prev_eu );
			nmg_keu( j_fus->eu );
		}
		else
			rt_log( "nmg_fix_crossed_loops: ERROR: can't find adjacent edges to kill\n" );
d4699 7
a4705 2
		/* Eliminate the middle face */
		i_fus->fu[1] = j_fus->fu[1];
d4707 10
a4716 2
		if( i_fus->fu[0] && j_fus->fu[1] )
			nmg_radial_join_eu( i_fus->eu , radial_eu , tol );
d4718 1
a4718 3
		if( !i_fus->fu[0] )
			i_fus->eu = radial_eu;
		NMG_CK_EDGEUSE( i_fus->eu );
d4720 2
a4721 2
		if( j_fus->free_edge )
			i_fus->free_edge = 1;
d4723 1
a4723 1
		nmg_tbl( int_faces , TBL_RM , (long *)j_fus );
d4725 15
a4739 1
		rt_free( (char *)j_fus , "nmg_fix_crossed_loops: j_fus" );
d4741 16
d4759 1
a4759 1
		rt_log( "After fix crossed loops:\n" );
d4834 6
d4853 1
a4855 3

	/* fix intersection points that cause loops that cross themselves */
	nmg_fix_crossed_loops( new_v , &int_faces , tol );
@


1.120
log
@Checkpoint.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.119 94/03/13 14:45:06 jra Exp Locker: jra $ (ARL)";
d3522 1
a3522 1
					rt_log( "return from rt_isect_line3_plane is %d\n" , ret_val );
d5820 4
a5823 2
nmg_follow_free_edges_to_vertex( vpa, vpb, vpbad1, vpbad2, eu, verts, found )
CONST struct vertex *vpa,*vpb,*vpbad1,*vpbad2;
d5833 2
a5834 4
	if( vpbad1 )
		NMG_CK_VERTEX( vpbad1 );
	if( vpbad2 )
		NMG_CK_VERTEX( vpbad2 );
d5838 6
d5853 3
d5860 5
d5867 3
d5871 1
d5875 3
d5879 1
d5884 2
d5893 3
a5895 1
			*found = (-1);
d5897 1
a5897 1
		else if( eu1->eumate_p->vu_p->v_p == vpbad1 || eu1->eumate_p->vu_p->v_p == vpbad2 )
d5900 3
a5902 1
			*found = (-2);
d5904 7
d5913 2
d5916 13
a5928 1
			nmg_follow_free_edges_to_vertex( vpa , vpb , vpbad1, vpbad2 , eu1 , verts , found );
d5933 2
d5938 4
a5941 2
nmg_find_middle_verts( vpa, vpb, vpbad1, vpbad2 )
CONST struct vertex *vpa,*vpb,*vpbad1,*vpbad2;
a5949 4
	if( vpbad1 )
		NMG_CK_VERTEX( vpbad1 );
	if( vpbad2 )
		NMG_CK_VERTEX( vpbad2 );
d5953 3
a5955 1
		rt_log( "nmg_find_middle_verts( vpa=x%x ( %f %f %f ), vpb=x%x ( %f %f %f )\n",
d5957 8
a5964 6
		if( vpbad1 )
			rt_log( "\tvpbad1=x%x ( %f %f %f )\n",
				vpbad1, V3ARGS( vpbad1->vg_p->coord ) );
		if( vpbad2 )
			rt_log( "\tvpbad2=x%x ( %f %f %f )\n",
				vpbad2, V3ARGS( vpbad2->vg_p->coord ) );
d5979 3
d5986 5
d5992 3
d5996 1
d5998 4
a6001 1
		if( eua->eumate_p->vu_p->v_p == vpbad1 || eua->eumate_p->vu_p->v_p == vpbad2 )
d6003 1
d6007 2
d6014 3
a6016 1
		nmg_follow_free_edges_to_vertex( vpa, vpb, vpbad1, vpbad2, eua, &verts, &done );
d6018 1
a6018 1
		if( done > 0 )
d6025 2
a6026 2
	if( done == 1 )
		return( &verts );
d6028 1
a6028 37
    if( done < 1 )
    {
        int free_edge_count;
    	struct vertexuse *vu1,*vu4;

        rt_log( "ERROR: nmg_find_middle_verts: cannot find intervening vertices\n" );
        rt_log( "verts are: x%x ( %f %f %f ) and x%x ( %f %f %f )\n",
		vpa, V3ARGS( vpa->vg_p->coord ), vpb, V3ARGS( vpb->vg_p->coord ) );

        free_edge_count = 0;
        for( RT_LIST_FOR( vu1 , vertexuse , &vpa->vu_hd ) )
        {
            struct edgeuse *eu1;

            if( *vu1->up.magic_p != NMG_EDGEUSE_MAGIC )
                continue;

            eu1 = vu1->up.eu_p;
            if( eu1->radial_p == eu1->eumate_p )
                free_edge_count++;
        }
        rt_log( "%d free edges at vertex x%x\n" , free_edge_count , vpa );

        free_edge_count = 0;
        for( RT_LIST_FOR( vu4 , vertexuse , &vpb->vu_hd ) )
        {
            struct edgeuse *eu4;

            if( *vu4->up.magic_p != NMG_EDGEUSE_MAGIC )
                continue;

            eu4 = vu4->up.eu_p;
            if( eu4->radial_p == eu4->eumate_p )
                free_edge_count++;
        }
        rt_log( "%d free edges at vertex x%x\n" , free_edge_count , vpb );
    }
d6238 10
a6257 1
	struct vertex *vp[3];
d6259 2
a6260 1
	int vertex_count=0;
d6267 1
d6281 2
d6300 1
d6302 2
a6303 4
					struct vertex *vp1,*vp2;
					struct vertex *vpa,*vpb;
					struct vertex *vpbad1,*vpbad2;
					struct nmg_ptbl *verts;
d6306 3
a6308 9
					/* found a free edge, find corresponding edge in "src" shell */
					vpa = eu->vu_p->v_p;
					NMG_CK_VERTEX( vpa );
					vp1 = NMG_INDEX_GETP(vertex, copy_tbl, vpa );
					NMG_CK_VERTEX( vp1 );
					vpb = eu->eumate_p->vu_p->v_p;
					NMG_CK_VERTEX( vpb );
					vp2 = NMG_INDEX_GETP(vertex, copy_tbl, vpb );
					NMG_CK_VERTEX( vp2 );
d6310 13
a6322 2
					/* look for another dangling edge at this vertex
					 * to establish direction for nmg_find_middle_verts
d6326 1
a6326 2
					vpbad1 = (struct vertex *)NULL;
					for( RT_LIST_FOR( test_vu , vertexuse , &eu->vu_p->v_p->vu_hd ) )
a6329 2
						NMG_CK_VERTEXUSE( test_vu );

a6333 2
						NMG_CK_EDGEUSE( test_eu );

d6337 1
a6337 1
						if( test_eu->eumate_p != test_eu->radial_p )
d6340 11
a6350 1
						vpbad1 = test_eu->eumate_p->vu_p->v_p;
d6353 1
a6353 1
					if( !vpbad1 )
d6355 1
a6355 3
						for( RT_LIST_FOR( test_vu , vertexuse , &eu->eumate_p->vu_p->v_p->vu_hd ) )
						{
							struct edgeuse *test_eu;
d6357 2
a6358 1
							NMG_CK_VERTEXUSE( test_vu );
d6360 3
a6362 2
							if( *test_vu->up.magic_p != NMG_EDGEUSE_MAGIC )
								continue;
a6363 2
							test_eu = test_vu->up.eu_p;
							NMG_CK_EDGEUSE( test_eu );
d6365 2
a6366 2
							if( test_eu->eumate_p == eu )
								continue;
d6368 10
a6377 4
							if( test_eu->eumate_p != test_eu->radial_p )
								continue;

							vpbad1 = test_eu->eumate_p->vu_p->v_p;
d6380 5
d6386 5
a6390 4
					if( vpbad1 )
						vpbad2 = NMG_INDEX_GETP(vertex, copy_tbl, vpbad1 );
					else
						vpbad2 = (struct vertex *)NULL;
d6392 1
a6392 2
					/* find vertices between vp1 and vp2 */
					verts = nmg_find_middle_verts( vp1 , vp2 , vpbad1 , vpbad2 );
d6394 2
a6395 2
					/* make faces connecting the two shells */
					nmg_make_connect_faces( src , vpa , vpb , verts , tol );
d6397 9
a6405 3
					nmg_tbl( verts , TBL_FREE , NULL );
				}
			}
d6407 5
@


1.119
log
@Checkpoint.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.118 94/03/12 17:03:25 jra Exp Locker: jra $ (ARL)";
a1834 4
		/* just look at OT_SAME faceuses */
		if( fu->orientation != OT_SAME )
			continue;

d1847 2
d1854 2
d1860 2
d1863 1
a1863 1
					if( vu->up.eu_p == eu )
d1866 4
d1871 1
a1871 1
					eu1 = vu->up.eu_p->eumate_p;
d1888 7
d1898 10
d3269 1
d3274 1
a3274 1
		rt_log( "nmg_get_edge_lines( new_v=x%x , int_faces=x%X )\n" , new_v , int_faces );
d3281 7
a3313 2
			VSET( i_fus->start , 0.0 , 0.0 , 0.0 );
			VSET( i_fus->dir , 0.0 , 0.0 , 0.0 );
d3317 2
a3318 1
			VSUB2( eu_dir , eu->vu_p->v_p->vg_p->coord , eu->eumate_p->vu_p->v_p->vg_p->coord );
d3320 1
a3320 3
			VCROSS( tmp_vec , eu_dir , pl );
			VCROSS( i_fus->dir , pl , tmp_vec );
			VJOIN1( i_fus->start , vg->coord , -DIST_PT_PLANE( vg->coord , pl ) , pl );
a3321 5
			if( VDOT( eu_dir , i_fus->dir ) < 0.0 )
				VREVERSE( i_fus->dir , i_fus->dir );

			VUNITIZE( i_fus->dir );

d3392 1
a3392 1
			if( ret_val=rt_isect_2planes( start , dir , fu1->f_p->fg_p->N , fu2->f_p->fg_p->N , new_v->vg_p->coord , tol ) )
d3395 1
d3401 1
d3419 1
a3419 4
			VCROSS( tmp_vec , eu_dir , pl );
			VCROSS( i_fus->dir , pl , tmp_vec );
			if( VDOT( eu_dir , i_fus->dir ) < 0.0 )
				VREVERSE( i_fus->dir , i_fus->dir );
d3422 1
a3422 1
			VJOIN1( i_fus->start , vg->coord , -DIST_PT_PLANE( vg->coord , pl ) , pl );
d3438 5
a3442 2
rt_log( "After getting edge lines:\n" );
nmg_pr_inter( new_v , int_faces );
d3500 1
d3507 1
d3514 2
a3515 1
			if( rt_isect_line3_plane( &dist , edge_fus->start , edge_fus->dir , f->fg_p->N , tol ) < 1 )
d3518 21
d3543 1
a3543 1
		if( max_dist == (-MAX_FASTF))
a3544 1
			rt_log( "nmg_get_max_edge_inters: couldn't find intersection point for edge\n" );
d3548 1
d3550 1
d3660 3
d3664 4
d3681 5
a3685 2
rt_log( "After splitting edges:\n" );
nmg_pr_inter( new_v , int_faces );
a3712 2
			radial_eu = j_fus->eu->radial_p;

d3718 2
d3731 8
d3740 1
d3743 1
a3743 1
				i_fus->eu = RT_LIST_PNEXT_CIRC( edgeuse , &radial_eu->l );
d3761 5
a3765 2
rt_log( "After loops of same face\n" );
nmg_pr_inter( new_v , int_faces );
d3769 48
d3824 6
d3868 3
d3879 1
a3879 1
			rt_log( "nmg_fus_inter_verts: ERROR: can't find adjacent edges to kill\n" );
d3884 8
d3893 1
d3905 5
a3909 2
rt_log( "After vertex fusion:\n" );
nmg_pr_inter( new_v , int_faces );
d3911 1
d3913 155
d4191 1
a4191 6
		/* if the two vertices are within tolerance,
		 * they should have been fused
		 */
		if( rt_pt3_pt3_equal( i_fus->vp->vg_p->coord , j_fus->vp->vg_p->coord , tol ) )
			rt_bomb( "nmg_make_faces_at_vert: ERROR: vertices should have been fused\n" );
		else if( rt_3pts_collinear( i_fus->vp->vg_p->coord , j_fus->vp->vg_p->coord , new_v->vg_p->coord , tol ) )
d4193 2
a4194 180
			fastf_t i_dist,j_dist,diff_dist;
			vect_t i_dist_to_new_v,j_dist_to_new_v,diff_vect;
			int kill_zero_length_edges=0;

			/* all three points are collinear,
			 * don't need a new face, but
			 * may need to split edges
			 */

			VSUB2( i_dist_to_new_v , new_v->vg_p->coord , i_fus->vp->vg_p->coord );
			VSUB2( j_dist_to_new_v , new_v->vg_p->coord , j_fus->vp->vg_p->coord );

			if( VDOT( i_dist_to_new_v , j_dist_to_new_v ) < 0.0 )
			{
				/* points are collinear with new_v, but in opoosit directions */
				edge_no++;
				continue;
			}

			VSUB2( diff_vect , i_fus->vp->vg_p->coord , j_fus->vp->vg_p->coord );
			diff_dist = MAGSQ( diff_vect );
			i_dist = MAGSQ( i_dist_to_new_v );
			j_dist = MAGSQ( j_dist_to_new_v );

			if( diff_dist < tol->dist_sq )
				rt_bomb( "nmg_make_faces_at_vert: ERROR: vertices are collinear and within tolerance\n" );
			if( i_dist < tol->dist_sq )
			{
				/* i point is within tolerance of new_v
				 * fuse with new_v
				 */
				nmg_jv( new_v , i_fus->vp );
				i_fus->vp = (struct vertex *)NULL;
				i_fus->eu = (struct edgeuse *)NULL;
				kill_zero_length_edges = 1;
			}
			if( j_dist < tol->dist_sq )
			{
				/* j point is within tolerance of new_v
				 * fuse with new_v
				 */

				nmg_jv( new_v , j_fus->vp );
				j_fus->vp = (struct vertex *)NULL;
				j_fus->eu = (struct edgeuse *)NULL;
				kill_zero_length_edges = 1;
			}
			if( kill_zero_length_edges )
			{
				struct vertexuse *vu;

				vu = RT_LIST_FIRST( vertexuse , &new_v->vu_hd );
				while( RT_LIST_NOT_HEAD( vu , &new_v->vu_hd ) )
				{
					struct edgeuse *eu;

					NMG_CK_VERTEXUSE( vu );

					if( *vu->up.magic_p != NMG_EDGEUSE_MAGIC )
					{
						vu = RT_LIST_NEXT( vertexuse , &vu->l );
						continue;
					}

					eu = vu->up.eu_p;

					if( eu->vu_p->v_p == eu->eumate_p->vu_p->v_p )
					{
						struct vertexuse *next_vu;

						next_vu = vu;
						while( next_vu == eu->vu_p || next_vu == eu->eumate_p->vu_p )
							next_vu = RT_LIST_NEXT( vertexuse , &next_vu->l );

						if( nmg_keu( eu ) )
							rt_bomb( "nmg_make_faces_at_verts: ERROR: nmg_keu left empty loop\n" );

						vu = next_vu;
					}
					else
						vu = RT_LIST_NEXT( vertexuse , &vu->l );
				}
			}

			if( i_fus->free_edge && j_fus->free_edge )
			{
				edge_no++;
				continue;
			}

			if( i_dist > j_dist && j_dist > tol->dist_sq )
			{
				struct edgeuse *new_eu;
				struct edgeuse *prev_eu;
				struct edgeuse *radial_eu;

				/* j point is closer to new_v than i point
				 * split edge at j point
				 */

				new_eu = nmg_esplit( j_fus->vp , i_fus->eu );
				radial_eu = j_fus->eu->radial_p;
				prev_eu = RT_LIST_PPREV_CIRC( edgeuse , &j_fus->eu->l );

				if( EDGESADJ( prev_eu , j_fus->eu ) )
				{
					nmg_keu( prev_eu );
					nmg_keu( j_fus->eu );
					j_fus->eu = (struct edgeuse *)NULL;
				}
				else
					rt_bomb( "nmg_make_faces_at_vert: ERROR: can't find adjacent edges to kill\n" );

				i_fus->fu[1] = j_fus->fu[1];

				if( !i_fus->fu[0] )
					i_fus->eu = radial_eu;

				if( i_fus->fu[0] && j_fus->fu[1] )
				{
					NMG_CK_EDGEUSE( i_fus->eu );
					NMG_CK_EDGEUSE( radial_eu );
					nmg_radial_join_eu( i_fus->eu , radial_eu , tol );
				}

				NMG_CK_EDGEUSE( i_fus->eu );

rt_log( "eliminating intersect_fus struct at x%x\n" , j_fus );
				nmg_tbl( int_faces , TBL_RM , (long *)j_fus );
				rt_free( (char *)j_fus , "nmg_make_faces_at _vert: j_fus" );

				continue;
			}
			else if( j_dist > i_dist && i_dist > tol->dist_sq )
			{
				struct edgeuse *new_eu;
				struct edgeuse *prev_eu;
				struct edgeuse *radial_eu;

				/* i point is closer to new_v than j point
				 * split edge at i point
				 */

				new_eu = nmg_esplit( i_fus->vp , j_fus->eu );
				radial_eu = j_fus->eu->radial_p;
				prev_eu = RT_LIST_PPREV_CIRC( edgeuse , &j_fus->eu->l );

				if( EDGESADJ( prev_eu , j_fus->eu ) )
				{
					nmg_keu( prev_eu );
					nmg_keu( j_fus->eu );
					j_fus->eu = (struct edgeuse *)NULL;
				}
				else
					rt_bomb( "nmg_make_faces_at_vert: ERROR: can't find adjacent edges to kill\n" );

				i_fus->fu[1] = j_fus->fu[1];

				if( i_fus->fu[0] && j_fus->fu[1] )
				{
					NMG_CK_EDGEUSE( i_fus->eu );
					NMG_CK_EDGEUSE( radial_eu );
					nmg_radial_join_eu( i_fus->eu , radial_eu , tol );
				}

				if( !i_fus->fu[0] )
					i_fus->eu = RT_LIST_PPREV_CIRC( edgeuse , &new_eu->l );

rt_log( "Eliminating intersect_fus struct at x%x\n" , j_fus );
				nmg_tbl( int_faces , TBL_RM , (long *)j_fus );
				rt_free( (char *)j_fus , "nmg_make_faces_at_vert: j_fus" );

				NMG_CK_EDGEUSE( i_fus->eu );
				continue;
			}
			else
			{
				edge_no++;
				continue;
			}
d4298 2
d4306 5
a4310 2
rt_log( "After make faces:\n" );
nmg_pr_inter( new_v , int_faces );
d4493 5
d4594 5
a4598 2
rt_log( "After fix crossed loops:\n" );
nmg_pr_inter( new_v , int_faces );
d4671 1
a4676 2
rt_log( "After kill cracks:\n" );
nmg_pr_inter( new_v , &int_faces );
d4678 9
d4689 4
a4692 1

a4695 2
	nmg_region_a( RT_LIST_FIRST( nmgregion , &m->r_hd ) , tol );

a4697 2
rt_log( "After second kill cracks:\n" );
nmg_pr_inter( new_v , &int_faces );
d4699 6
d5819 6
a5824 3
static void
nmg_find_middle_verts( vp1 , vp2 , vp3 , vp4 )
struct vertex *vp1,*vp2,*vp3,*vp4;
d5826 1
a5826 2
    int done=0;
    struct vertexuse *vu1,*vu2,*vu3,*vu4;
d5828 7
a5834 2
    NMG_CK_VERTEX( vp1 );
    NMG_CK_VERTEX( vp4 );
d5836 1
a5836 4
    /* first check if there are no intervening vertices */
    for( RT_LIST_FOR( vu1 , vertexuse , &vp1->vu_hd ) )
    {
        struct edgeuse *eu1;
d5838 3
a5840 1
        NMG_CK_VERTEXUSE( vu1 );
d5842 1
a5842 2
        if( *vu1->up.magic_p != NMG_EDGEUSE_MAGIC )
            continue;
d5844 2
a5845 2
        eu1 = vu1->up.eu_p;
        NMG_CK_EDGEUSE( eu1 );
d5847 1
a5847 8
        if( eu1->eumate_p->vu_p->v_p == vp4 )
        {
            done = 1;
            break;
        }
    }
    if( done )
	return;
d5849 1
a5849 5
    /*  look for intervening vertices */
    /* look for the case with just one intervening vertex */
    for( RT_LIST_FOR( vu1 , vertexuse , &vp1->vu_hd ) )
    {
        struct edgeuse *eu1;
d5851 3
a5853 1
        NMG_CK_VERTEXUSE( vu1 );
d5855 3
a5857 2
        if( *vu1->up.magic_p != NMG_EDGEUSE_MAGIC )
            continue;
d5859 26
a5884 1
        eu1 = vu1->up.eu_p;
d5886 7
a5892 1
        NMG_CK_EDGEUSE( eu1 );
a5893 3
        /* must be on a free edge */
        if( eu1->eumate_p != eu1->radial_p )
            continue;
d5895 6
a5900 3
        for( RT_LIST_FOR( vu4 , vertexuse , &vp4->vu_hd ) )
        {
            struct edgeuse *eu4;
d5902 11
a5912 1
            NMG_CK_VERTEXUSE( vu4 );
d5914 2
a5915 2
            if( *vu4->up.magic_p != NMG_EDGEUSE_MAGIC )
                continue;
d5917 3
a5919 1
            eu4 = vu4->up.eu_p;
d5921 1
a5921 1
            NMG_CK_EDGEUSE( eu4 );
d5923 2
a5924 3
            /* also must be on a free edge */
            if( eu4->eumate_p != eu4->radial_p )
                continue;
d5926 1
a5926 12
            if( eu4->eumate_p->vu_p->v_p == eu1->eumate_p->vu_p->v_p )
            {
                done = 1;
                vp2 = eu4->eumate_p->vu_p->v_p;
                break;
            }
        }
        if( done )
            break;
    }
    if( done )
	return;
d5928 1
a5928 4
    /* look for two intervening vertices */
    for( RT_LIST_FOR( vu1 , vertexuse , &vp1->vu_hd ) )
    {
        struct edgeuse *eu1;
d5930 2
a5931 1
        NMG_CK_VERTEXUSE( vu1 );
d5933 2
a5934 2
        if( *vu1->up.magic_p != NMG_EDGEUSE_MAGIC )
            continue;
d5936 5
a5940 1
        eu1 = vu1->up.eu_p;
d5942 2
a5943 1
        NMG_CK_EDGEUSE( eu1 );
d5945 2
a5946 3
        /* must be on a free edge */
        if( eu1->eumate_p != eu1->radial_p )
            continue;
d5948 3
a5950 3
        for( RT_LIST_FOR( vu4 , vertexuse , &vp4->vu_hd ) )
        {
            struct edgeuse *eu4;
d5952 2
a5953 1
            NMG_CK_VERTEXUSE( vu4 );
d5955 1
a5955 44
            if( *vu4->up.magic_p != NMG_EDGEUSE_MAGIC )
                continue;

            eu4 = vu4->up.eu_p;

            NMG_CK_EDGEUSE( eu4 );

            /* also must be on a free edge */
            if( eu4->eumate_p != eu4->radial_p )
                continue;

            for( RT_LIST_FOR( vu2 , vertexuse , &eu1->eumate_p->vu_p->v_p->vu_hd ) )
            {
                struct edgeuse *eu2;

                NMG_CK_VERTEXUSE( vu2 );

                if( *vu2->up.magic_p != NMG_EDGEUSE_MAGIC )
                    continue;

                eu2 = vu2->up.eu_p;

                NMG_CK_EDGEUSE( eu2 );

                /* stick to the free edges */
                if( eu2->eumate_p != eu2->radial_p )
                    continue;

                if( eu2->eumate_p->vu_p->v_p == eu4->eumate_p->vu_p->v_p )
                {
                    done = 1;
                    vp2 = eu2->vu_p->v_p;
                    vp3 = eu2->eumate_p->vu_p->v_p;
                    break;
                }
            }
            if( done )
                break;
        }
        if( done )
            break;
    }

    if( !done )
d5958 1
d5961 2
a5962 15
        rt_log( "verts are: x%x x%x x%x x%x\n", vp1, vp2, vp3, vp4 );
        if( vp1->magic == NMG_VERTEX_MAGIC )
            rt_log( "\tvp1 x%x = ( %f %f %f )\n" , vp1 , V3ARGS( vp1->vg_p->coord ) );
        if( vp2 )
        {
            if( vp2->magic == NMG_VERTEX_MAGIC )
                rt_log( "\tvp2 x%x = ( %f %f %f )\n" , vp2 , V3ARGS( vp2->vg_p->coord ) );
        }
        if( vp3 )
        {
            if( vp3->magic == NMG_VERTEX_MAGIC )
                rt_log( "\tvp3 x%x = ( %f %f %f )\n" , vp3 , V3ARGS( vp3->vg_p->coord ) );
        }
        if( vp4->magic == NMG_VERTEX_MAGIC )
            rt_log( "\tvp4 x%x = ( %f %f %f )\n" , vp4 , V3ARGS( vp4->vg_p->coord ) );
d5965 1
a5965 1
        for( RT_LIST_FOR( vu1 , vertexuse , &vp1->vu_hd ) )
d5976 1
a5976 1
        rt_log( "%d free edges at vertex x%x\n" , free_edge_count , vp1 );
d5979 1
a5979 1
        for( RT_LIST_FOR( vu4 , vertexuse , &vp4->vu_hd ) )
d5990 1
a5990 1
        rt_log( "%d free edges at vertex x%x\n" , free_edge_count , vp4 );
d5994 4
a5997 4
static void
nmg_make_connect_faces( dst , vpa , vpb , vp1 , vp2 , vp3 , vp4 , tol )
struct shell *dst;
struct vertex *vpa,*vpb,*vp1,*vp2,*vp3,*vp4;
d6000 1
a6000 4
	int fu3_type=0;
	int fu4_type=0;
	struct faceuse *fu1,*fu2,*fu3,*fu4;
	struct vertex *verts[4];
d6002 2
a6003 9
	NMG_CK_SHELL( dst );
	NMG_CK_VERTEX( vpa );
	NMG_CK_VERTEX( vpb );
	NMG_CK_VERTEX( vp1 );
	if( vp2 )
		NMG_CK_VERTEX( vp2 );
	if( vp3 )
		NMG_CK_VERTEX( vp3 );
	NMG_CK_VERTEX( vp4 );
d6006 1
a6006 1
	if( vp3 )
d6008 1
a6008 4
		if( rt_3pts_collinear( vpb->vg_p->coord , vp3->vg_p->coord , vp4->vg_p->coord , tol ) )
		{
			vect_t to3,to4;
			fastf_t dist_to_3_sq,dist_to_4_sq;
d6010 3
a6012 1
			fu1 = (struct faceuse *)NULL;
d6014 1
a6014 11
			VSUB2( to3 , vp3->vg_p->coord , vpb->vg_p->coord );
			dist_to_3_sq = MAGSQ( to3 );
			VSUB2( to4 , vp4->vg_p->coord , vpb->vg_p->coord );
			dist_to_4_sq = MAGSQ( to4 );

			if( dist_to_3_sq > dist_to_4_sq )
				fu4_type = 1;
			else
				fu4_type = 2;
		}
		else
d6016 1
a6016 3
			verts[0] = vpb;
			verts[1] = vp3;
			verts[2] = vp4;
d6018 1
a6018 1
			fu1 = nmg_cface( dst , verts , 3 );
d6020 2
a6021 1
			if( nmg_fu_planeeqn( fu1 , tol ) )
d6023 2
a6024 6
				rt_log( "1 nmg_connect_open_shells: failed to calulate plane eqn\n" );
				rt_log( "\tFace:\n" );
				rt_log( "\t\t( %f %f %f ) -> ( %f %f %f ) -> ( %f %f %f )\n",
					V3ARGS( verts[0]->vg_p->coord ),
					V3ARGS( verts[1]->vg_p->coord ),
					V3ARGS( verts[2]->vg_p->coord ) );
d6028 1
a6028 2
	else
		vp3 = vp4;
d6030 14
a6043 1
	if( vp2 )
d6045 3
a6047 1
		if( rt_3pts_collinear( vpa->vg_p->coord , vp1->vg_p->coord , vp2->vg_p->coord , tol ) )
d6049 1
a6049 2
			vect_t to1,to2;
			fastf_t dist_to_1_sq,dist_to_2_sq;
d6051 4
a6054 1
			fu1 = (struct faceuse *)NULL;
d6056 4
a6059 4
			VSUB2( to1 , vp1->vg_p->coord , vpb->vg_p->coord );
			dist_to_1_sq = MAGSQ( to1 );
			VSUB2( to2 , vp2->vg_p->coord , vpb->vg_p->coord );
			dist_to_2_sq = MAGSQ( to2 );
d6061 20
a6080 2
			if( dist_to_1_sq > dist_to_2_sq )
				fu3_type = 1;
d6082 4
a6085 1
				fu3_type = 2;
d6089 9
a6097 4
			verts[0] = vpa;
			verts[1] = vp1;
			verts[2] = vp2;
			fu2 = nmg_cface( dst , verts , 3 );
d6099 53
a6151 8
			if( nmg_fu_planeeqn( fu2 , tol ) )
			{
				rt_log( "2 nmg_connect_open_shells: failed to calulate plane eqn\n" );
				rt_log( "\tFace:\n" );
				rt_log( "\t\t( %f %f %f ) -> ( %f %f %f ) -> ( %f %f %f )\n",
					V3ARGS( verts[0]->vg_p->coord ),
					V3ARGS( verts[1]->vg_p->coord ),
					V3ARGS( verts[2]->vg_p->coord ) );
d6153 2
a6156 2
	else
		vp2 = vp1;
d6158 1
a6158 1
	if( fu3_type )
d6160 16
a6175 3
		verts[0] = vpa;
		verts[3] = vp3;
		if( fu3_type = 1 )
d6177 2
a6178 2
			verts[2] = vp2;
			verts[3] = vp1;
a6179 38
		else
		{
			verts[2] = vp1;
			verts[3] = vp2;
		}
		fu3 = nmg_cface( dst , verts , 4 );
		if( nmg_fu_planeeqn( fu3 , tol ) )
		{
			rt_log( "3 nmg_connect_open_shells: failed to calulate plane eqn\n" );
			rt_log( "\tFace:\n" );
			rt_log( "\t\t( %f %f %f ) -> ( %f %f %f ) -> ( %f %f %f ) -> ( %f %f %f )\n",
				V3ARGS( verts[0]->vg_p->coord ),
				V3ARGS( verts[1]->vg_p->coord ),
				V3ARGS( verts[2]->vg_p->coord ),
				V3ARGS( verts[3]->vg_p->coord ) );
		}
	}
	else
	{
		verts[0] = vpa;
		verts[1] = vp2;
		verts[2] = vp3;
		fu3 = nmg_cface( dst , verts , 3 );
		if( nmg_fu_planeeqn( fu3 , tol ) )
		{
			rt_log( "4 nmg_connect_open_shells: failed to calulate plane eqn\n" );
			rt_log( "\tFace:\n" );
			rt_log( "\t\t( %f %f %f ) -> ( %f %f %f ) -> ( %f %f %f )\n",
				V3ARGS( verts[0]->vg_p->coord ),
				V3ARGS( verts[1]->vg_p->coord ),
				V3ARGS( verts[2]->vg_p->coord ) );
rt_log( "\tvpa = ( %f %f %f )\n" , V3ARGS( vpa->vg_p->coord ) );
rt_log( "\tvpb = ( %f %f %f )\n" , V3ARGS( vpb->vg_p->coord ) );
rt_log( "\tvp1 = ( %f %f %f )\n" , V3ARGS( vp1->vg_p->coord ) );
rt_log( "\tvp2 = ( %f %f %f )\n" , V3ARGS( vp2->vg_p->coord ) );
rt_log( "\tvp3 = ( %f %f %f )\n" , V3ARGS( vp3->vg_p->coord ) );
rt_log( "\tvp4 = ( %f %f %f )\n" , V3ARGS( vp4->vg_p->coord ) );
rt_log( "fu3_type = %d, fu4_typ3 = %d\n" , fu3_type , fu4_type );
d6181 1
a6181 2
		}
	}
d6183 2
a6184 25
	if( fu4_type )
	{
		verts[0] = vpb;
		verts[1] = vpa;
		if( fu4_type = 1 )
		{
			verts[2] = vp3;
			verts[3] = vp4;
		}
		else
		{
			verts[2] = vp4;
			verts[3] = vp3;
		}
		fu4 = nmg_cface( dst , verts , 4 );
		if( nmg_fu_planeeqn( fu4 , tol ) )
		{
			rt_log( "5 nmg_connect_open_shells: failed to calulate plane eqn\n" );
			rt_log( "\tFace:\n" );
			rt_log( "\t\t( %f %f %f ) -> ( %f %f %f ) -> ( %f %f %f ) -> ( %f %f %f )\n",
				V3ARGS( verts[0]->vg_p->coord ),
				V3ARGS( verts[1]->vg_p->coord ),
				V3ARGS( verts[2]->vg_p->coord ),
				V3ARGS( verts[3]->vg_p->coord ) );
		}
a6185 16
	else
	{
		verts[0] = vpb;
		verts[1] = vpa;
		verts[2] = vp3;
		fu4 = nmg_cface( dst , verts , 3 );
		if( nmg_fu_planeeqn( fu4 , tol ) )
		{
			rt_log( "6 nmg_connect_open_shells: failed to calulate plane eqn\n" );
			rt_log( "\tFace:\n" );
			rt_log( "\t\t( %f %f %f ) -> ( %f %f %f ) -> ( %f %f %f )\n",
				V3ARGS( verts[0]->vg_p->coord ),
				V3ARGS( verts[1]->vg_p->coord ),
				V3ARGS( verts[2]->vg_p->coord ) );
		}
	}
d6211 1
d6213 1
d6216 1
a6216 1
		rt_log( "nmg_open_shells_connect( dst=x%x , src=x%X , copy_tbl=x%x)\n" , dst , src , copy_tbl );
d6250 2
a6251 1
					struct vertex *vp1,*vp2,*vp3,*vp4;
d6253 3
a6257 2
					vp1 = NMG_INDEX_GETP(vertex, copy_tbl, eu->vu_p->v_p);
					NMG_CK_VERTEX( vp1 );
d6260 2
a6261 2
					vp4 = NMG_INDEX_GETP(vertex, copy_tbl, eu->eumate_p->vu_p->v_p);
					NMG_CK_VERTEX( vp4 );
d6264 2
a6265 2
					vp2 = (struct vertex *)NULL;
					vp3 = (struct vertex *)NULL;
d6267 4
a6270 2
					/* allow for up to two vertices between vp1 and vp4 */
					nmg_find_middle_verts( vp1 , vp2 , vp3 , vp4 );
d6272 54
d6327 3
a6329 1
					nmg_make_connect_faces( dst , vpa , vpb , vp1 , vp2 , vp3 , vp4 , tol );
@


1.118
log
@Checkpoint
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.117 94/03/11 19:49:20 mike Exp Locker: jra $ (ARL)";
d3113 1
d3115 7
a3121 1
	rt_log( "int_faces at vertex x%x ( %f %f %f )\n" , new_v , V3ARGS( new_v->vg_p->coord ) );
d3156 1
a3156 1
					rt_log( "****ERROR**** eu is not in fu1\n" );
d3162 1
a3162 1
					rt_log( "****ERROR**** eu is not in fu2\n" );
d3164 1
d3170 1
a3170 1
		if( i_fus->free_edge )
d3172 2
a3173 1
			if( i_fus->eu->eumate_p != i_fus->eu->radial_p )
d3175 3
d3416 2
d3608 5
d3624 2
d3641 3
a3643 3
		while( j_fus != i_fus && j_fus->fu[0]
			&& ( !j_fus->fu[1] || (j_fus->fu[0]->f_p == j_fus->fu[1]->f_p) )
			&& (j_fus->fu[0]->f_p == i_fus->fu[1]->f_p) )
d3655 3
d3692 2
d3710 2
d3727 1
a3727 1
		if( rt_pt3_pt3_equal( edge_fus->vp->vg_p->coord , next_fus->vp->vg_p->coord , tol ) )
d3729 3
a3731 2
			struct edgeuse *radial_eu;
			struct edgeuse *prev_eu;
d3733 5
a3737 2
			radial_eu = next_fus->eu->radial_p;
			prev_eu = RT_LIST_PPREV_CIRC( edgeuse , &next_fus->eu->l );
d3739 2
a3740 1
			nmg_jv( edge_fus->vp , next_fus->vp );
d3742 1
a3742 7
			if( EDGESADJ( prev_eu , next_fus->eu ) )
			{
				nmg_keu( prev_eu );
				nmg_keu( next_fus->eu );
			}
			else
				rt_log( "nmg_fus_inter_verts: ERROR: can't find adjacent edges to kill\n" );
d3744 7
a3750 1
			edge_fus->fu[1] = next_fus->fu[1];
d3752 1
a3752 2
			if( edge_fus->fu[0] && next_fus->fu[1] )
				nmg_radial_join_eu( edge_fus->eu , radial_eu , tol );
d3754 2
a3755 3
			if( !edge_fus->fu[0] )
				edge_fus->eu = radial_eu;
			NMG_CK_EDGEUSE( edge_fus->eu );
d3757 3
a3759 2
			if( next_fus->free_edge )
				edge_fus->free_edge = 1;
d3761 5
a3765 5
			nmg_tbl( int_faces , TBL_RM , (long *)next_fus );
			rt_free( (char *)next_fus , "nmg_split_edges_at_pts: next_fus " );
		}
		else
			edge_no++;
d3767 2
d3805 3
a3807 1
		i_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , 0 );
d3809 3
a3811 2
		VMOVE( new_v->vg_p->coord , i_fus->vp->vg_p->coord );
		nmg_jv( new_v , i_fus->vp );
d3827 5
a3831 3
		VCOMB2( center_pt , 0.5 , i_fus->vp->vg_p->coord , 0.5 , j_fus->vp->vg_p->coord );
		VMOVE( new_v->vg_p->coord , center_pt );

d4017 6
a4022 2
					i_fus->eu = new_eu;
				else if( j_fus->fu[1] )
d4024 1
d4027 6
d4059 4
a4062 1
				if( j_fus->fu[1] )
d4064 1
d4066 7
d4074 1
d4076 5
a4080 3

			edge_no++;
			continue;
d4174 3
d4190 2
d4470 2
d4549 2
d4562 2
a5824 1
        }
@


1.117
log
@Changed to nmg_find_lu_of_vu()
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.116 94/03/11 19:48:00 jra Exp Locker: mike $ (ARL)";
a42 7
void
nmg_find_bad_edges( magic_p )
CONST long *magic_p;
{
	struct nmg_ptbl eu_tab;
	struct rt_tol tol_tmp;
	int i;
a43 63
	tol_tmp.magic = RT_TOL_MAGIC;
	tol_tmp.dist = SQRT_SMALL_FASTF;
	tol_tmp.dist_sq = SMALL_FASTF;
	tol_tmp.perp = 0.0;
	tol_tmp.para = 1.0;

	nmg_tbl( &eu_tab , TBL_INIT , NULL );

	nmg_edgeuse_tabulate( &eu_tab , magic_p );

	rt_log( "nmg_find_bad_edges: checking %d edgeuses\n" , NMG_TBL_END( &eu_tab ) );

	for( i=0 ; i<NMG_TBL_END( &eu_tab ) ; i++ )
	{
		struct edgeuse *eur;
		struct edgeuse *eurm;
		struct edgeuse *eu;
		struct edge *e;
		int found=0;

		eu = (struct edgeuse *)NMG_TBL_GET( &eu_tab , i );

		NMG_CK_EDGEUSE( eu );
		e = eu->e_p;
		NMG_CK_EDGE( e );
		if( e->eu_p->l.magic != NMG_EDGEUSE_MAGIC )
		{
			rt_log( "ERROR: e->eu_p points to bad edgeuse\n" );
			rt_log( "eu = x%x , e = x%x , bad eu = x%x\n" , eu , e , e->eu_p );
			rt_bomb( "BAD BAD BAD\n" );
		}

		if( e->eu_p == eu || e->eu_p == eu->eumate_p )
			continue;

		eur = e->eu_p->radial_p;
		eurm = eur->eumate_p;
		if( eur == eu || eurm == eu )
			found = 1;
		while( eur != e->eu_p && eurm != e->eu_p && !found )
		{
			if( eur == eu || eurm == eu )
			{
				found = 1;
				break;
			}

			eur = eurm->radial_p;
			eurm = eur->eumate_p;
		}

		if( !found )
		{
			rt_log( "eu x%x points to e x%x which points to eu x%x, but is not in its radial list\n" , eu , e , e->eu_p );
			nmg_pr_fu_around_eu( eu , &tol_tmp );
			nmg_pr_fu_around_eu( e->eu_p , &tol_tmp );
			rt_bomb( "BAD BAD BAD\n" );
		}
		
	}
	nmg_tbl( &eu_tab , TBL_FREE , NULL );
}

d76 4
d789 1
a789 1
 *	note that note much care is taken as to how the holes are closed
a2986 7
	/* A local tolerance structure for times when I don't want tolerancing */
	tol_tmp.magic = RT_TOL_MAGIC;
	tol_tmp.dist = SQRT_SMALL_FASTF;
	tol_tmp.dist_sq = SMALL_FASTF;
	tol_tmp.perp = 0.0;
	tol_tmp.para = 1.0;

d2992 2
a2993 1
		struct face *fp1,*fp2,*fp3,*fp4,*face;
a2994 12
		vect_t vert_move_dir;
		point_t rpp_min,line_start;
		vect_t line_dir;
		point_t pts[3];
		plane_t **pls;
		plane_t **pl;
		plane_t pl1;
		vect_t normal,normal2;
		double theta;
		int k,ret_val;
		int face_no;
		int done;
d2997 1
a2997 1
			rt_log( "nmg_inside_vert: vertex not in any face planes!!!\n" );
d3013 1
a3013 1
				rt_log( "nmg_inside_vert: Cannot find new coords for two planes\n" );
d3024 3
a3026 25
				/* Check if the three planes happen to intersect at a line */
				if( ret_val=rt_isect_2planes( line_start , line_dir , fp1->fg_p->N , fp2->fg_p->N , rpp_min , &tol_tmp ) )
				{
					rt_log( "Two of three planes do not intersect (%d)\n" , ret_val );
					rt_log( "\tx%x ( %f %f %f ) %f\n" , fp1 , V3ARGS( fp1->fg_p->N ) , fp1->fg_p->N[3] );
					rt_log( "\tx%x ( %f %f %f ) %f\n" , fp2 , V3ARGS( fp2->fg_p->N ) , fp2->fg_p->N[3] );
					rt_log( "\tError at vertex ( %f %f %f )\n" , V3ARGS( vg->coord ) );
					failed = 1;
					break;
				}
				else if( ret_val=rt_isect_line3_plane( &vert_move_len , line_start , line_dir , fp3->fg_p->N , &tol_tmp )  )
				{
					rt_log( "Line is not on third plane (%d):\n" , ret_val );
					rt_log( "\tx%x ( %f %f %f ) %f\n" , fp1 , V3ARGS( fp1->fg_p->N ) , fp1->fg_p->N[3] );
					rt_log( "\tx%x ( %f %f %f ) %f\n" , fp2 , V3ARGS( fp2->fg_p->N ) , fp2->fg_p->N[3] );
					rt_log( "\tx%x ( %f %f %f ) %f\n" , fp3 , V3ARGS( fp3->fg_p->N ) , fp3->fg_p->N[3] );
					rt_log( "\tError at vertex ( %f %f %f )\n" , V3ARGS( vg->coord ) );
					failed = 1;
					break;
				}
				else
				{
					(void)rt_dist_pt3_line3( &vert_move_len , vg->coord , line_start , line_dir , vg->coord , &tol_tmp );
					break;
				}
a3036 29
/*
 *			N M G _ R A D I A L _ J O I N _ E U _ N O _ C K
 *
 *	Make all the edgeuses around eu2's edge to refer to eu1's edge,
 *	taking care to organize them into the proper angular orientation,
 *	so that the attached faces are correctly arranged radially
 *	around the edge.
 *
 *	This depends on both edges being part of face loops,
 *	with vertex and face geometry already associated.
 *
 *	Don't do a radial parity check
 *
 *  Some of the edgeuses around both edges may be wires.
 */
void
nmg_radial_join_eu_no_ck(eu1, eu2, tol)
struct edgeuse		*eu1;
struct edgeuse		*eu2;
CONST struct rt_tol	*tol;
{
	struct edgeuse	*original_eu1 = eu1;
	struct edgeuse	*nexteu;
	struct edgeuse	*eur;
	int		iteration1, iteration2;
	vect_t		xvec, yvec, zvec;
	fastf_t		abs1;
	fastf_t		abs2;
	fastf_t		absr;
a3037 213
	if( rt_g.NMG_debug & DEBUG_BASIC )
		rt_log( "nmg_radial_join_eu_no_ck( eu1=x%x , eu2=x%x )\n" , eu1 , eu2 );

	NMG_CK_EDGEUSE(eu1);
	NMG_CK_EDGEUSE(eu1->radial_p);
	NMG_CK_EDGEUSE(eu1->eumate_p);
	NMG_CK_EDGEUSE(eu2);
	NMG_CK_EDGEUSE(eu2->radial_p);
	NMG_CK_EDGEUSE(eu2->eumate_p);
	RT_CK_TOL(tol);

	if( eu1->e_p == eu2->e_p )  return;

	if( eu1->vu_p->v_p == eu2->vu_p->v_p && 
	    eu1->eumate_p->vu_p->v_p == eu2->eumate_p->vu_p->v_p )  {
	    	/* Both edgeuses are oriented in the same direction */
	} else if( eu1->vu_p->v_p == eu2->eumate_p->vu_p->v_p &&
	    eu1->eumate_p->vu_p->v_p == eu2->vu_p->v_p )  {
	    	/* Edgeuses are oriented in opposite directions */
		if (rt_g.NMG_debug & DEBUG_MESH_EU)
			rt_log("nmg_radial_join_eu_no_ck() FLIP eu2\n");
	    	eu2 = eu2->eumate_p;
	} else {
		rt_bomb("nmg_radial_join_eu_no_ck(): edgeuses don't share both vertices\n");
	}

	if( eu1->vu_p->v_p == eu1->eumate_p->vu_p->v_p )  rt_bomb("nmg_radial_join_eu_no_ck(): 0 length edge (topology)\n");

	if( rt_pt3_pt3_equal( eu1->vu_p->v_p->vg_p->coord,
	    eu1->eumate_p->vu_p->v_p->vg_p->coord, tol ) )
		rt_bomb("nmg_radial_join_eu_no_ck(): 0 length edge (geometry)\n");

	/*  Construct local coordinate system for this edge,
	 *  so all angles can be measured relative to a common reference.
	 */
	nmg_eu_2vecs_perp( xvec, yvec, zvec, original_eu1, tol );

	if (rt_g.NMG_debug & DEBUG_MESH_EU ) {
		rt_log("nmg_radial_join_eu_no_ck(eu1=x%x, eu2=x%x) e1=x%x, e2=x%x\n",
			eu1, eu2,
			eu1->e_p, eu2->e_p);
		nmg_euprint("\tJoining", eu1);
		nmg_euprint("\t     to", eu2);
		rt_log( "Faces around eu1:\n" );
		nmg_pr_fu_around_eu_vecs( eu1, xvec, yvec, zvec, tol );
		rt_log( "Faces around eu2:\n" );
		nmg_pr_fu_around_eu_vecs( eu2, xvec, yvec, zvec, tol );
	}

	for ( iteration1=0; eu2 && iteration1 < 10000; iteration1++ ) {
		int	code = 0;
		struct edgeuse	*first_eu1 = eu1;
		int	wire_skip = 0;
		/* Resume where we left off from last eu2 insertion */

		/* because faces are always created with counter-clockwise
		 * exterior loops and clockwise interior loops, radial
		 * edgeuses will never share the same vertex.  We thus make
		 * sure that eu2 is an edgeuse which might be radial to eu1
		 */
		if (eu2->vu_p->v_p == eu1->vu_p->v_p)
			eu2 = eu2->eumate_p;

		/* find a place to insert eu2 around eu1's edge */
		for ( iteration2=0; iteration2 < 10000; iteration2++ ) {
			struct faceuse	*fu1, *fu2, *fur;

			abs1 = abs2 = absr = -rt_twopi;

			eur = eu1->radial_p;
			NMG_CK_EDGEUSE(eur);

			fu2 = nmg_find_fu_of_eu(eu2);
			if( fu2 == (struct faceuse *)NULL )  {
				/* eu2 is a wire, it can go anywhere */
				goto insert;
			}
			fu1 = nmg_find_fu_of_eu(eu1);
			if( fu1 == (struct faceuse *)NULL )  {
				/* eu1 is a wire, skip on to real face eu */
				wire_skip++;
				goto cont;
			}
			fur = nmg_find_fu_of_eu(eur);
			while( fur == (struct faceuse *)NULL )  {
				/* eur is wire, advance eur */
				eur = eur->eumate_p->radial_p;
				wire_skip++;
				if( eur == eu1->eumate_p )  {
					/* Went all the way around */
					goto insert;
				}
				fur = nmg_find_fu_of_eu(eur);
			}
			NMG_CK_FACEUSE(fu1);
			NMG_CK_FACEUSE(fu2);
			NMG_CK_FACEUSE(fur);

			/*
			 *  Can't just check for shared fg here,
			 *  the angle changes by +/- 180 degrees,
			 *  depending on which side of the eu the loop is on
			 *  along this edge.
			 */
			abs1 = nmg_measure_fu_angle( eu1, xvec, yvec, zvec );
			abs2 = nmg_measure_fu_angle( eu2, xvec, yvec, zvec );
			absr = nmg_measure_fu_angle( eur, xvec, yvec, zvec );

			if (rt_g.NMG_debug & DEBUG_MESH_EU )  {
				rt_log("  abs1=%g, abs2=%g, absr=%g\n",
					abs1*rt_radtodeg,
					abs2*rt_radtodeg,
					absr*rt_radtodeg );
			}

			/* If abs1 == absr, warn about unfused faces, and skip. */
			if( NEAR_ZERO( abs1-absr, 1.0e-8 ) )  {
				if( fu1->f_p->fg_p == fur->f_p->fg_p )  {
					/* abs1 == absr, faces are fused, don't insert here. */
					if (rt_g.NMG_debug & DEBUG_MESH_EU )  {
						rt_log("fu1 and fur share face geometry x%x (flip1=%d, flip2=%d), skip\n",
							fu1->f_p->fg_p, fu1->f_p->flip, fur->f_p->flip );
					}
					goto cont;
				}

				rt_log("nmg_radial_join_eu_no_ck: WARNING 2 faces should have been fused, may be ambiguous.\n  abs1=%e, absr=%e, asb2=%e\n",
					abs1*rt_radtodeg, absr*rt_radtodeg, abs2*rt_radtodeg);
				rt_log("  fu1=x%x, f1=x%x, f1->flip=%d, fg1=x%x\n",
					fu1, fu1->f_p, fu1->f_p->flip, fu1->f_p->fg_p );
				rt_log("  fu2=x%x, f2=x%x, f2->flip=%d, fg2=x%x\n",
					fu2, fu2->f_p, fu2->f_p->flip, fu2->f_p->fg_p );
				rt_log("  fur=x%x, fr=x%x, fr->flip=%d, fgr=x%x\n",
					fur, fur->f_p, fur->f_p->flip, fur->f_p->fg_p );
				PLPRINT("  fu1", fu1->f_p->fg_p->N );
				PLPRINT("  fu2", fu2->f_p->fg_p->N );
				PLPRINT("  fur", fur->f_p->fg_p->N );
				rt_log("  skipping\n");
				goto cont;
			}

			/*
			 *  If abs1 < abs2 < absr
			 *  (taking into account 360 wrap),
			 *  then insert face here.
			 *  Special handling if abs1==abs2 or abs2==absr.
			 */
			code = nmg_is_angle_in_wedge( abs1, absr, abs2 );
			if (rt_g.NMG_debug & DEBUG_MESH_EU )
				rt_log("    code=%d %s\n", code, (code!=0)?"INSERT_HERE":"skip");
			if( code > 0 )  break;
			if( code == -1 )  {
				/* absr == abs2 */
				break;
			}
			if( code <= -2 )  {
				/* abs1 == abs2 */
				break;
			}

cont:
			if( iteration2 > 9997 )  rt_g.NMG_debug |= DEBUG_MESH_EU;
			/* If eu1 is only one pair of edgeuses, done */
			if( eu1 == eur->eumate_p )  break;
			eu1 = eur->eumate_p;
			if( eu1 == first_eu1 )  {
				/* If all eu's were wires, here is fine */
				if( wire_skip >= iteration2 )  break;
				/* Nope, something bad happened */
				rt_bomb("nmg_radial_join_eu_no_ck():  went full circle, no face insertion point.\n");
				break;
			}
		}
		if(iteration2 >= 10000)  {
			rt_bomb("nmg_radial_join_eu_no_ck: infinite loop (2)\n");
		}

		/* find the next use of the edge eu2 is on.  If eu2 and it's
		 * mate are the last uses of the edge, there will be no next
		 * edgeuse to move. (Loop termination condition).
		 */
insert:
		nexteu = eu2->radial_p;
		if (nexteu == eu2->eumate_p)
			nexteu = (struct edgeuse *)NULL;

		if (rt_g.NMG_debug & DEBUG_MESH_EU)  {
			rt_log("  Inserting.  code=%d\n", code);
			rt_log("joining eu1=x%x eu2=x%x with abs1=%g, absr=%g\n",
				eu1, eu2,
				abs1*rt_radtodeg, absr*rt_radtodeg);
		}

		/*
		 *  Make eu2 radial to eu1.
		 *  This should insert eu2 between eu1 and eu1->radial_p
		 *  (which may be less far around than eur, but thats OK).
		 */
		nmg_moveeu(eu1, eu2);

		if (rt_g.NMG_debug & DEBUG_MESH_EU)  {
			rt_log("After nmg_moveeu(), faces around original_eu1 are:\n");
			nmg_pr_fu_around_eu_vecs( original_eu1, xvec, yvec, zvec, tol );
		}

		/* Proceed to the next source edgeuse */
		eu2 = nexteu;
	}
	if( iteration1 >= 10000 )  rt_bomb("nmg_radial_join_eu_no_ck:  infinite loop (1)\n");

	if (rt_g.NMG_debug & DEBUG_MESH_EU)  rt_log("nmg_radial_join_eu_no_ck: END\n");
}

a3060 2
rt_log( "nmg_ck_vert_on_fus( v=x%x , tol->dist=%f )\n" , v , tol->dist );

a3213 148
/*	N M G _ K I L L _ S H O R T _ L U S
 *
 *	Look for loops that have less than three edges and kill them
 *
 * returns:
 *	0 - All is well
 *	1 - nmgregion r is now empty!!!
 */
int
nmg_kill_short_lus( r , tol )
struct nmgregion *r;
CONST struct rt_tol *tol;
{
	struct shell *s;
	int ret_val=0;

	if( rt_g.NMG_debug & DEBUG_BASIC )
		rt_log( "nmg_kill_short_lus( r=x%x )\n" , r );

	NMG_CK_REGION( r );

	s = RT_LIST_FIRST( shell , &r->s_hd );
	while( RT_LIST_NOT_HEAD( s , &r->s_hd ) )
	{
		int bad_shell=0;
		struct faceuse *fu;
		struct shell *next_s;

		next_s = RT_LIST_PNEXT( shell , &s->l );

		fu = RT_LIST_FIRST( faceuse , &s->fu_hd );
		while( RT_LIST_NOT_HEAD( fu , &s->fu_hd ) )
		{
			int bad_face=0;
			struct faceuse *next_fu;
			struct loopuse *lu;

			if( fu->orientation != OT_SAME )
			{
				fu = RT_LIST_PNEXT( faceuse , &fu->l );
				continue;
			}

			next_fu = RT_LIST_PNEXT( faceuse , &fu->l );
			while( RT_LIST_NOT_HEAD( next_fu , &s->fu_hd ) && next_fu->fumate_p == fu )
				next_fu = RT_LIST_PNEXT( faceuse , &next_fu->l );

			lu = RT_LIST_FIRST( loopuse , &fu->lu_hd );
			while( RT_LIST_NOT_HEAD( lu , &fu->lu_hd ) )
			{
				int eu_count=0;
				struct loopuse *next_lu;
				struct edgeuse *eu;

				next_lu = RT_LIST_PNEXT( loopuse , &lu->l );

				if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
				{
					lu = next_lu;
					continue;
				}

				for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
					eu_count++;

				if( eu_count > 2 )
				{
					lu = next_lu;
					continue;
				}

				if( eu_count < 2 )
					bad_face += nmg_klu( lu );
				else if( eu_count == 2 )
				{
					struct edgeuse *eu1,*eu2;
					struct edge *e1,*e2;

					eu1 = RT_LIST_FIRST( edgeuse , &lu->down_hd );
					eu2 = RT_LIST_PNEXT( edgeuse , &eu1->l );
					e1 = eu1->e_p;
					e2 = eu2->e_p;

					if( !EDGESADJ( eu1 , eu2 ) )
					{
						rt_log( "Build_solid: face with two edges, loop not closed\n" );
						nmg_pr_fu_briefly( fu , (char *)NULL );
						return( 1 );
					}

					bad_face += nmg_klu( lu );
					nmg_radial_join_eu( e1->eu_p , e2->eu_p , tol );
				}
				lu = next_lu;
			}
			if( bad_face )
				bad_shell += nmg_kfu( fu );

			fu = next_fu;
		}
		if( bad_shell )
			ret_val += nmg_ks( s );

		s = next_s;
	}

	return( ret_val );
}

/*	N M G _ C O M P L E X _ J V
 *
 * Does a nmg_jv(new_vp , old_vp), but also makes sure
 * that the int_faces table is updated by changing all occurrences
 * of old_vp to new_vp;
 *
 */
static void
nmg_complex_jv( old_vp , new_vp , int_faces )
struct vertex *old_vp,*new_vp;
struct nmg_ptbl *int_faces;
{
	int edge_no;

	if( rt_g.NMG_debug & DEBUG_BASIC )
		rt_log( "nmg_complex_jv( old_vp=x%x , new_vp=x%x , int_faces=x%X )\n" , old_vp , new_vp , int_faces );

	NMG_CK_VERTEX( old_vp );
	NMG_CK_VERTEX( new_vp );

	if( old_vp == new_vp )
		return;

	for( edge_no=0 ; edge_no<NMG_TBL_END( int_faces ) ; edge_no++ )
	{
		struct intersect_fus *i_fus;

		i_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , edge_no );

		if( i_fus->vp == old_vp )
		{
			i_fus->vp = new_vp;
			VMOVE( i_fus->pt , new_vp->vg_p->coord );
		}
	}

	nmg_jv( new_vp , old_vp );
}

a3235 1
	struct rt_tol tol_tmp;
a3244 7
	/* A local tolerance structure for times when I don't want tolerancing */
	tol_tmp.magic = RT_TOL_MAGIC;
	tol_tmp.dist = SQRT_SMALL_FASTF;
	tol_tmp.dist_sq = SMALL_FASTF;
	tol_tmp.perp = 0.0;
	tol_tmp.para = 1.0;

d3357 1
a3357 1
			if( ret_val=rt_isect_2planes( start , dir , fu1->f_p->fg_p->N , fu2->f_p->fg_p->N , new_v->vg_p->coord , &tol_tmp ) )
d3359 6
a3364 56
				if( ret_val == (-1) )
				{
					/* faces are coplanar */
					VMOVE( dir , eu_dir );
					VUNITIZE( dir );
					if( rt_isect_line3_plane( &dist , new_v->vg_p->coord , fu1->f_p->fg_p->N , fu2->f_p->fg_p->N , &tol_tmp ) < 1 )
					{
						rt_log( "nmg_inside_vert: Cannot find new edge between two identical planes\n" );
						continue;
					}
					VJOIN1( start , new_v->vg_p->coord , dist , normal1 );
				}
				else if( ret_val == (-2) )
				{
					/* faces are parallel but distinct */
					plane_t plane1,plane2;
					vect_t v1,v2;
					point_t p1,p2;
					fastf_t dist2[2];

					NMG_GET_FU_PLANE( plane2 , fu2 );
					NMG_GET_FU_PLANE( plane1 , fu1 );
					rt_log( "\nplanes are parallel and distinct at ( %f %f %f )\n" , V3ARGS( eu->vu_p->v_p->vg_p->coord ) );
					rt_log( "dot product of normals = %g\n" , VDOT( normal1 , plane2 ) );
					rt_log( "tol->para = %g\n" , tol->para );
					VCROSS( dir , normal1 , plane2 );
					rt_log( "cross_product of normals = ( %g %g %g )\n" , V3ARGS( dir ) );
					rt_log( "length of dir = %g\n" , MAGNITUDE( dir ) );
					VUNITIZE( dir );
					rt_log( "unitized cross_product of normals = ( %f %f %f )\n" , V3ARGS( dir ) );
					VSUB2( v1 , eu->eumate_p->vu_p->v_p->vg_p->coord , eu->vu_p->v_p->vg_p->coord );
					VUNITIZE( v1 );
					rt_log( "direction of old edge = ( %f %f %f )\n" , V3ARGS( v1 ) );
					VCROSS( v1 , dir , plane1 );
					VUNITIZE( v1 );
					VSCALE( p1 , plane1 , plane1[3] );
					VCROSS( v2 , dir , plane2 );
					VUNITIZE( v2 );
					VSCALE( p2 , plane2 , plane2[3] );
					ret_val = rt_isect_line2_line2( dist2 , p1 , v1 , p2 , v2 , &tol_tmp );
					if( ret_val == (-1) )
					{
						rt_log( "No intersection\n" );
						return( 1 );
					}
					else if( ret_val == 0 )
					{
						rt_log( "Lines are collinear\n" );
						return( 1 );
					}
					else if( ret_val == 1 )
					{
						VJOIN1( start , p1 , dist2[0] , v1 );
						rt_log( "intersection is at ( %f %f %f )\n" , V3ARGS( start ) );
					}
				}
d3367 1
a3367 1
			(void)rt_dist_pt3_line3( &dist , start , start , dir , new_v->vg_p->coord , &tol_tmp );
a3404 3
rt_log( "At end of nmg_get_edge_lines\n" );
nmg_pr_inter( new_v , int_faces );

a3424 1
	struct rt_tol tol_tmp;
d3429 1
a3429 1
/*	if( rt_g.NMG_debug & DEBUG_BASIC ) */
a3434 7
	/* A local tolerance structure for times when I don't want tolerancing */
	tol_tmp.magic = RT_TOL_MAGIC;
	tol_tmp.dist = SQRT_SMALL_FASTF;
	tol_tmp.dist_sq = SMALL_FASTF;
	tol_tmp.perp = 0.0;
	tol_tmp.para = 1.0;

a3523 2
rt_log( "nmg_fix_folded_inters( new_v = x%x , %d intersect_fus)\n" , new_v , NMG_TBL_END( int_faces ) );

d3576 1
a3576 1
/*	if( rt_g.NMG_debug & DEBUG_BASIC ) */
a3581 3
rt_log( "at start of nmg_split_edges_at_pts:\n" );
nmg_pr_inter( new_v , int_faces );

a3582 1

a3605 3
rt_log( "In nmg_split_edges_at_pts before loops of same face:\n" );
nmg_pr_inter( new_v , int_faces );

a3619 1
rt_log( "Checking intersct_fus structs x%x and x%x\n" , i_fus , j_fus );
a3629 2
			{
rt_log( "\tBoth are free edges\n" );
a3630 2
			}
rt_log( "\tremoving edge %d j_fus = x%x\n" , next_edge_no , j_fus );
a3663 2
rt_log( "in nmg_split_edges_at_pts after removing an intersect_fus struct:\n" );
nmg_pr_inter( new_v , int_faces );
a3665 1

a3667 2
rt_log( "At end of nmg_split_edges_at_pts:\n" );
nmg_pr_inter( new_v , int_faces );
d3676 1
a3676 1
	int edge_no;
a3680 3
rt_log( "nmg_fus_inter_verts( new_v = x%x , %d intersect_fus structures) \n" , new_v , NMG_TBL_END( int_faces ) );

	edge_no=0;
a3730 2
rt_log( "In nmg_fuse_inter_verts after fusing verts:\n" );
nmg_pr_inter( new_v , int_faces );
a3734 2
rt_log( "At end of nmg_fuse_inter_verts:\n" );
nmg_pr_inter( new_v , int_faces );
a3753 1
	struct rt_tol tol_tmp;
d3756 1
a3756 1
/*	if( rt_g.NMG_debug & DEBUG_BASIC ) */
a3763 7
	/* A local tolerance structure for times when I don't want tolerancing */
	tol_tmp.magic = RT_TOL_MAGIC;
	tol_tmp.dist = SQRT_SMALL_FASTF;
	tol_tmp.dist_sq = SMALL_FASTF;
	tol_tmp.perp = 0.0;
	tol_tmp.para = 1.0;

a3795 4
rt_log( "In nmg_make_faces_at_vert:\n" );
nmg_pr_inter( new_v , int_faces );
	

d3843 1
d3855 3
a3857 1
		/* if the two vertices are within tolerance, fuse them */
a3858 1
		{
a3859 1
		}
a3879 1
rt_log( "\tCollinear x%x x%x x%x\n" , i_fus->vp , j_fus->vp , new_v );
a3886 1
			{
a3887 1
			}
a3892 1
rt_log( "\tJoining x%x to x%x\n" , i_fus->vp , new_v );
a3903 1
rt_log( "\tJoining x%x to x%x\n" , j_fus->vp , new_v );
d3909 43
a3961 2
rt_log( "\tSplitting eu x%x at vertex x%x (location 1)\n" , i_fus->eu , j_fus->vp );
nmg_find_bad_edges( &m->magic );
a3962 2
rt_log( "\tAfter nmg_esplit:\n" );
nmg_find_bad_edges( &m->magic );
a3974 1
nmg_find_bad_edges( &m->magic );
a3979 2
				{
rt_log( "\tRadial join x%x and x%x\n" , i_fus->eu , radial_eu );
a3980 3
rt_log( "\tDone radial join\n" );
				}
nmg_find_bad_edges( &m->magic );
a3993 7
rt_log( "\tSplitting eu x%x at vertex x%x (location 2)\n" , j_fus->eu , i_fus->vp );
rt_log( "Before nmg_esplit, eu and mate:\n" );
nmg_pr_eu_briefly( j_fus->eu , (char *)NULL );
nmg_pr_eu_briefly( j_fus->eu->eumate_p , (char *)NULL );
rt_log( "to be split at ( %f %f %f )\n" , V3ARGS( i_fus->vp->vg_p->coord ) );
nmg_pr_fu_around_eu( j_fus->eu , tol );
nmg_find_bad_edges( &m->magic );
a3994 2
rt_log( "\tAfter nmg_esplit:\n" );
nmg_find_bad_edges( &m->magic );
a4006 1
nmg_find_bad_edges( &m->magic );
a4009 2
				{
rt_log( "\tRadial join x%x and x%x\n" , i_fus->eu , radial_eu );
a4010 3
rt_log( "\tDone radial join 2\n" );
				}
nmg_find_bad_edges( &m->magic );
a4013 3
			if( kill_zero_length_edges )
			{
				struct vertexuse *vu;
a4014 36
rt_log( "\tKilling zero length edges\n" );
nmg_find_bad_edges( &m->magic );
				vu = RT_LIST_FIRST( vertexuse , &new_v->vu_hd );
				while( RT_LIST_NOT_HEAD( vu , &new_v->vu_hd ) )
				{
					struct edgeuse *eu;

					NMG_CK_VERTEXUSE( vu );

					if( *vu->up.magic_p != NMG_EDGEUSE_MAGIC )
					{
						vu = RT_LIST_NEXT( vertexuse , &vu->l );
						continue;
					}

					eu = vu->up.eu_p;

					if( eu->vu_p->v_p == eu->eumate_p->vu_p->v_p )
					{
						struct vertexuse *next_vu;

						next_vu = vu;
						while( next_vu == eu->vu_p || next_vu == eu->eumate_p->vu_p )
							next_vu = RT_LIST_NEXT( vertexuse , &next_vu->l );

						if( nmg_keu( eu ) )
							rt_bomb( "nmg_make_faces_at_verts: ERROR: nmg_keu left empty loop\n" );

						vu = next_vu;
					}
					else
						vu = RT_LIST_NEXT( vertexuse , &vu->l );
				}
nmg_find_bad_edges( &m->magic );
			}

a4107 1
nmg_find_bad_edges( &m->magic );
a4108 1
nmg_find_bad_edges( &m->magic );
a4114 28
			struct edgeuse *eu1,*eu2,*eu3;
			struct vertex *v1,*v2,*v3;

			lu = RT_LIST_FIRST( loopuse , &new_fu->lu_hd );
			eu1 = RT_LIST_FIRST( edgeuse , &lu->down_hd );
			eu2 = RT_LIST_PNEXT_CIRC( edgeuse , &eu1->l );
			eu3 = RT_LIST_PNEXT_CIRC( edgeuse , &eu2->l );
			v1 = eu1->vu_p->v_p;
			v2 = eu2->vu_p->v_p;
			v3 = eu3->vu_p->v_p;
			if( rt_3pts_collinear( v1->vg_p->coord , v2->vg_p->coord , v3->vg_p->coord , tol ) )
				rt_log( "\tpoints are collinear (123)\n" );
			if( rt_3pts_collinear( v1->vg_p->coord , v3->vg_p->coord , v2->vg_p->coord , tol ) )
				rt_log( "\tpoints are collinear (132)\n" );
			if( rt_3pts_collinear( v2->vg_p->coord , v3->vg_p->coord , v1->vg_p->coord , tol ) )
				rt_log( "\tpoints are collinear (231)\n" );
			if( rt_3pts_collinear( v2->vg_p->coord , v1->vg_p->coord , v3->vg_p->coord , tol ) )
				rt_log( "\tpoints are collinear (213)\n" );
			if( rt_3pts_collinear( v3->vg_p->coord , v2->vg_p->coord , v1->vg_p->coord , tol ) )
				rt_log( "\tpoints are collinear (321)\n" );
			if( rt_3pts_collinear( v3->vg_p->coord , v1->vg_p->coord , v2->vg_p->coord , tol ) )
				rt_log( "\tpoints are collinear (312)\n" );
			if( rt_pt3_pt3_equal( v1->vg_p->coord , v2->vg_p->coord , tol ) )
				rt_log( "\tx%x within tolerance of x%x\n" , v1 , v2 );
			if( rt_pt3_pt3_equal( v1->vg_p->coord , v3->vg_p->coord , tol ) )
				rt_log( "\tx%x within tolerance of x%x\n" , v1 , v3 );
			if( rt_pt3_pt3_equal( v3->vg_p->coord , v2->vg_p->coord , tol ) )
				rt_log( "\tx%x within tolerance of x%x\n" , v3 , v2 );
a4134 1
	struct model *m;
a4144 2
m = nmg_find_model( &vp->magic );

a4200 12
struct rt_tol tol;
tol.magic = RT_TOL_MAGIC;
tol.dist = 0.005;
tol.dist_sq = tol.dist * tol.dist;
tol.perp = 1e-6;
tol.para = 1 - tol.perp;
nmg_pr_fu_around_eu( eu, &tol );
nmg_pr_fu_around_eu( eu_prev, &tol );

if( eu->e_p == eu_prev->e_p ) rt_log( "Edgeuses x%x and x%x share same edge x%x\n" , eu , eu_prev , eu->e_p );
rt_log( "Verify model in nmg_kill_cracks_at_vertex before keu:\n" );
nmg_vmodel( m );
a4210 1
rt_log( "nmg_keu left empty loop x%x\n" , lu );
a4213 2
rt_log( "Verify model in nmg_kill_cracks_at_vertex after keu's:\n" );
nmg_vmodel( m );
a4266 1
	struct rt_tol tol_tmp;
d4268 1
a4268 1
/*	if( rt_g.NMG_debug & DEBUG_BASIC ) */
a4273 7
	/* A local tolerance structure for times when I don't want tolerancing */
	tol_tmp.magic = RT_TOL_MAGIC;
	tol_tmp.dist = SQRT_SMALL_FASTF;
	tol_tmp.dist_sq = SMALL_FASTF;
	tol_tmp.perp = 0.0;
	tol_tmp.para = 1.0;

a4274 1
	edge_no = 0;
a4428 1
	struct rt_tol tol_tmp;
a4449 1
	nmg_find_bad_edges( &m->magic );
a4452 7
	/* A local tolerance structure for times when I don't want tolerancing */
	tol_tmp.magic = RT_TOL_MAGIC;
	tol_tmp.dist = SQRT_SMALL_FASTF;
	tol_tmp.dist_sq = SMALL_FASTF;
	tol_tmp.perp = 0.0;
	tol_tmp.para = 1.0;

a4471 1
	nmg_find_bad_edges( &m->magic );
a4474 1
	nmg_find_bad_edges( &m->magic );
a4477 1
	nmg_find_bad_edges( &m->magic );
a4480 1
	nmg_find_bad_edges( &m->magic );
a4483 1
	nmg_find_bad_edges( &m->magic );
a4488 1
	nmg_find_bad_edges( &m->magic );
a4489 3
	rt_log( "Verify model after nmg_kill_cracks_at_vertex:\n" );
	nmg_vmodel( m );

a4645 100
/*	N M G _ S H E L L S _ W I T H I N _ D I S T
 *
 * check if any vertex in shell s1 is within dist of any face in
 * shell s2.
 *
 * returns:
 *	0 - shells are not within dist of each other
 *	1 - shells are within dist of each other
 */
int
nmg_shells_within_dist( s1 , s2 , dist , tol )
CONST struct shell *s1,*s2;
CONST fastf_t dist;
CONST struct rt_tol *tol;
{
	long *flags_s2,*flags_s1;
	struct faceuse *fu1;
	struct model *m1,*m2;;

	m1 = nmg_find_model( &s1->l.magic );
	m2 = nmg_find_model( &s2->l.magic );
	flags_s1 = (long *)rt_calloc( m1->maxindex , sizeof( long ) , "nmg_shells_within_dist: flags_s1" );
	flags_s2 = (long *)rt_calloc( m2->maxindex , sizeof( long ) , "nmg_shells_within_dist: flags_s2" );

	for( RT_LIST_FOR( fu1 , faceuse , &s1->fu_hd ) )
	{
		plane_t pl1;

		if( fu1->orientation != OT_SAME )
			continue;

		NMG_GET_FU_PLANE( pl1 , fu1 );

		if( NMG_INDEX_TEST_AND_SET( flags_s1 , fu1 ) )
		{
			struct faceuse *fu2;

#ifdef SYSV
			(void)memset( flags_s2 , '\0' , m2->maxindex * sizeof( long ) );
#else
			bzero( flags_s2 , m2->maxindex * sizeof( long ) );
#endif

			for( RT_LIST_FOR( fu2 , faceuse , &s2->fu_hd ) )
			{
				struct loopuse *lu2;

				if( fu2->orientation != OT_SAME )
					continue;

				for( RT_LIST_FOR( lu2 , loopuse , &fu2->lu_hd ) )
				{
					struct edgeuse *eu2;

					if( RT_LIST_FIRST_MAGIC( &lu2->down_hd ) != NMG_EDGEUSE_MAGIC )
						continue;

					for( RT_LIST_FOR( eu2 , edgeuse , &lu2->down_hd ) )
					{
						struct vertex *v;
						struct vertex_g *vg;
						point_t pt;
						fastf_t dist_to_plane;

						v = eu2->vu_p->v_p;
						NMG_CK_VERTEX( v );
						vg = v->vg_p;
						NMG_CK_VERTEX_G( vg );

						if( NMG_INDEX_TEST_AND_SET( flags_s2 , vg ) )
						{
							dist_to_plane = DIST_PT_PLANE( vg->coord , pl1 );

							if( dist_to_plane > (dist - tol->dist ) ||
							    dist_to_plane < (-(dist - tol->dist )) )
								continue;

							/* project vertex to plane of face fu1 */
							VJOIN1( pt , vg->coord , -dist_to_plane , pl1 );

							/* check if this point is within the face */
							if( nmg_class_pt_f( pt , fu1 , tol ) != NMG_CLASS_AoutB )
							{
								rt_free( (char *)flags_s1 , "nmg_shells_within_dist: flags_s1" );
								rt_free( (char *)flags_s2 , "nmg_shells_within_dist: flags_s2" );
								return( 1 );
							}
						}
					}
				}
			}
		}
	}

	rt_free( (char *)flags_s1 , "nmg_shells_within_dist: flags_s1" );
	rt_free( (char *)flags_s2 , "nmg_shells_within_dist: flags_s2" );

	return( 0 );
}

d5603 1
d5608 2
a5609 2
	int done=0;
	struct vertexuse *vu1,*vu2,*vu3,*vu4;
d5611 2
a5612 2
	NMG_CK_VERTEX( vp1 );
	NMG_CK_VERTEX( vp4 );
d5614 4
a5617 4
	/* first check if there are no intervening vertices */
	for( RT_LIST_FOR( vu1 , vertexuse , &vp1->vu_hd ) )
	{
		struct edgeuse *eu1;
d5619 1
a5619 1
		NMG_CK_VERTEXUSE( vu1 );
d5621 2
a5622 2
		if( *vu1->up.magic_p != NMG_EDGEUSE_MAGIC )
			continue;
d5624 2
a5625 2
		eu1 = vu1->up.eu_p;
		NMG_CK_EDGEUSE( eu1 );
d5627 8
a5634 3
		/* skip edges that are not free edges */
		if( eu1->eumate_p != eu1->radial_p )
			continue;
d5636 5
a5640 6
		if( eu1->eumate_p->vu_p->v_p == vp4 )
		{
			done = 1;
			break;
		}
	}
d5642 1
a5642 7
	/* if necessary, look for intervening vertices */
	if( !done )
	{
		/* look for the case with just one intervening vertex */
		for( RT_LIST_FOR( vu1 , vertexuse , &vp1->vu_hd ) )
		{
			struct edgeuse *eu1;
d5644 2
a5645 1
			NMG_CK_VERTEXUSE( vu1 );
d5647 1
a5647 2
			if( *vu1->up.magic_p != NMG_EDGEUSE_MAGIC )
				continue;
d5649 1
a5649 1
			eu1 = vu1->up.eu_p;
d5651 3
a5653 1
			NMG_CK_EDGEUSE( eu1 );
d5655 3
a5657 3
			/* must be on a free edge */
			if( eu1->eumate_p != eu1->radial_p )
				continue;
d5659 1
a5659 3
			for( RT_LIST_FOR( vu4 , vertexuse , &vp4->vu_hd ) )
			{
				struct edgeuse *eu4;
d5661 2
a5662 1
				NMG_CK_VERTEXUSE( vu4 );
d5664 1
a5664 2
				if( *vu4->up.magic_p != NMG_EDGEUSE_MAGIC )
					continue;
d5666 1
a5666 1
				eu4 = vu4->up.eu_p;
d5668 3
a5670 1
				NMG_CK_EDGEUSE( eu4 );
d5672 12
a5683 3
				/* also must be on a free edge */
				if( eu4->eumate_p != eu4->radial_p )
					continue;
d5685 4
a5688 16
				if( eu4->eumate_p->vu_p->v_p == eu1->eumate_p->vu_p->v_p )
				{
					done = 1;
					vp2 = eu4->eumate_p->vu_p->v_p;
					break;
				}
			}
			if( done )
				break;
		}
		if( !done )
		{
			/* look for two intervening vertices */
			for( RT_LIST_FOR( vu1 , vertexuse , &vp1->vu_hd ) )
			{
				struct edgeuse *eu1;
d5690 1
a5690 1
				NMG_CK_VERTEXUSE( vu1 );
d5692 2
a5693 2
				if( *vu1->up.magic_p != NMG_EDGEUSE_MAGIC )
					continue;
d5695 1
a5695 1
				eu1 = vu1->up.eu_p;
d5697 1
a5697 1
				NMG_CK_EDGEUSE( eu1 );
d5699 3
a5701 3
				/* must be on a free edge */
				if( eu1->eumate_p != eu1->radial_p )
					continue;
d5703 3
a5705 3
				for( RT_LIST_FOR( vu4 , vertexuse , &vp4->vu_hd ) )
				{
					struct edgeuse *eu4;
d5707 1
a5707 1
					NMG_CK_VERTEXUSE( vu4 );
d5709 2
a5710 2
					if( *vu4->up.magic_p != NMG_EDGEUSE_MAGIC )
						continue;
d5712 1
a5712 1
					eu4 = vu4->up.eu_p;
d5714 1
a5714 1
					NMG_CK_EDGEUSE( eu4 );
d5716 3
a5718 3
					/* also must be on a free edge */
					if( eu4->eumate_p != eu4->radial_p )
						continue;
d5720 3
a5722 3
					for( RT_LIST_FOR( vu2 , vertexuse , &eu1->eumate_p->vu_p->v_p->vu_hd ) )
					{
						struct edgeuse *eu2;
d5724 1
a5724 1
						NMG_CK_VERTEXUSE( vu2 );
d5726 2
a5727 2
						if( *vu2->up.magic_p != NMG_EDGEUSE_MAGIC )
							continue;
d5729 1
a5729 1
						eu2 = vu2->up.eu_p;
d5731 1
a5731 1
						NMG_CK_EDGEUSE( eu2 );
d5733 3
a5735 3
						/* stick to the free edges */
						if( eu2->eumate_p != eu2->radial_p )
							continue;
d5737 15
a5751 19
						if( eu2->eumate_p->vu_p->v_p == eu4->eumate_p->vu_p->v_p )
						{
							done = 1;
							vp2 = eu2->vu_p->v_p;
							vp3 = eu2->eumate_p->vu_p->v_p;
							break;
						}
					}
					if( done )
						break;
				}
				if( done )
					break;
			}
		}
	}
	if( !done )
		rt_log( "ERROR: nmg_find_middle_verts: cannot find intervening vertices\n" );
}
d5753 51
a6130 1
	nmg_find_bad_edges( &m->magic );
a6135 1
rt_log( "\tfree-edges = %d\n" , free_edges );
@


1.116
log
@Lots of hard work.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.115 94/03/09 17:42:33 jra Exp $ (ARL)";
d546 1
a546 1
		lu = nmg_lu_of_vu( vu );
@


1.115
log
@Checkpoint.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.114 94/03/03 17:56:51 jra Exp Locker: jra $ (ARL)";
d43 7
d51 63
d2953 2
a2954 1
 *	and fills in the table with the faces
d2957 2
a2958 2
nmg_find_isect_faces( new_v , faces , tol )
struct vertex *new_v;
d2960 2
a2961 1
struct rt_tol *tol;
a2968 1
	int free_edges=0;
d3008 4
d3014 1
a3014 1
				free_edges++;
d3019 1
a3019 1
					free_edges++;
a3022 48
#if 0
	if( free_edges )
	{
		/* If the vertex is on a free edge, select just the faces
		 * that contain the free edges */
		nmg_tbl( faces , TBL_RST , NULL );
		for( RT_LIST_FOR( vu , vertexuse , &new_v->vu_hd ) )
		{
			int unique=1;

			NMG_CK_VERTEXUSE( vu );
			fu = nmg_find_fu_of_vu( vu );
			NMG_CK_FACEUSE( fu );
			if( fu->orientation != OT_SAME )
				continue;
			fg = fu->f_p->fg_p;
			NMG_CK_FACE_G( fg );

			/* check if this face is different from the ones on list */
			for( i=0 ; i<NMG_TBL_END( faces ) ; i++ )
			{
				struct face *fp;

				fp = (struct face *)NMG_TBL_GET( faces , i );
				if( fp->fg_p == fg || rt_coplanar( fg->N , fp->fg_p->N , tol ) > 0 )
				{
					unique = 0;
					break;
				}
			}

			/* if it is not already on the list, add it */
			if( unique )
			{
				/* Look for free edges containing new_v */
				eu = vu->up.eu_p;
				if( eu->eumate_p == eu->radial_p )
					nmg_tbl( faces , TBL_INS , (long *)fu->f_p );
				else
				{
					eu = RT_LIST_PLAST_CIRC( edgeuse , eu );
					if( eu->eumate_p == eu->radial_p )
						nmg_tbl( faces , TBL_INS , (long *)fu->f_p );
				}
			}
		}
	}
#endif
d3489 3
d3495 13
d3512 5
d3573 1
a3573 1
nmg_kill_short_lus( r )
d3575 1
d3640 1
a3640 1
					struct edge *e;
d3644 2
d3647 1
a3647 1
					if( eu1->vu_p->v_p != eu2->eumate_p->vu_p->v_p )
a3653 10
					if( eu1->e_p != eu2->e_p )
						nmg_moveeu( eu1 , eu2 );

					e = eu->e_p;
					(void)nmg_keu( eu1 );
					if( e->magic == NMG_EDGE_MAGIC )
					{
						if( e->eu_p->l.magic != NMG_EDGEUSE_MAGIC )
							rt_log( "ERROR: nmg_keu left edge with bad eu_p\n" );
					}
d3655 1
d3761 1
d3774 1
a3774 1
			i_fus->eu = eu->eumate_p;
d3961 3
d4091 2
d4151 3
a4164 2
		{
			edge_no++;
a4165 1
		}
d4170 4
d4179 3
a4188 2
		i_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , edge_no );

d4190 1
a4190 1
		if( next_edge_no = NMG_TBL_END( int_faces ) )
d4193 1
d4196 1
d4198 2
a4199 2
			&& ( !j_fus->fu[1] || j_fus->fu[0]->f_p == j_fus->fu[1]->f_p )
			&& j_fus->fu[0]->f_p == i_fus->fu[1]->f_p )
d4202 2
a4204 1
			new_eu = nmg_esplit( i_fus->vp , j_fus->eu );
d4206 1
a4206 3
			i_fus->fu[1] = j_fus->fu[1];

			if( i_fus->free_edge )
d4208 4
a4211 2
				struct loopuse *lu;
				int found=0;
d4213 1
a4213 3
				for( RT_LIST_FOR( lu , loopuse , &i_fus->fu[1]->lu_hd ) )
				{
					struct edgeuse *eu;
d4215 9
a4223 1
					NMG_CK_LOOPUSE( lu );
d4225 1
a4225 2
					if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
						continue;
d4227 2
a4228 3
					for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
					{
						NMG_CK_EDGEUSE( eu );
d4230 3
a4232 11
						if( eu->eumate_p->vu_p->v_p == new_v )
						{
							i_fus->eu = eu;
							found = 1;
							break;
						}
					}
					if( found )
						break;
				}
			}
d4239 3
d4245 3
d4252 2
d4267 2
d4290 2
a4291 1
			nmg_complex_jv( next_fus->vp , edge_fus->vp , int_faces );
d4293 2
a4294 1
			edge_fus->fu[1] = next_fus->fu[1];
d4296 3
a4298 1
			if( edge_fus->free_edge )
d4300 5
a4304 2
				struct loopuse *lu;
				int found=0;
d4306 1
a4306 3
				for( RT_LIST_FOR( lu , loopuse , &edge_fus->fu[1]->lu_hd ) )
				{
					struct edgeuse *eu;
d4308 2
a4309 1
					NMG_CK_LOOPUSE( lu );
d4311 3
a4313 2
					if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
						continue;
a4314 16
					for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
					{
						NMG_CK_EDGEUSE( eu );

						if( eu->eumate_p->vu_p->v_p == new_v )
						{
							edge_fus->eu = eu;
							found = 1;
							break;
						}
					}
					if( found )
						break;
				}
			}

d4320 2
d4326 2
d4345 1
d4356 2
d4396 3
d4427 2
a4428 1
		if( i_fus->free_edge && j_fus->free_edge && next_edge_no == 0 )
d4442 1
a4442 1
		if( i_fus->vp == NULL || j_fus->vp == NULL )
d4462 1
a4462 30
			struct vertex *old_vp,*new_vp;
			struct vertexuse *vu;

			/* fuse all uses of i_fus->vp to j_fus->vp */
			old_vp = i_fus->vp;
			new_vp = j_fus->vp;
			nmg_complex_jv( old_vp , new_vp , int_faces );

			/* join radial edges created by vertex fuse */
			for( RT_LIST_FOR( vu , vertexuse , &new_v->vu_hd ) )
			{
				if( *vu->up.magic_p != NMG_EDGEUSE_MAGIC )
					continue;

				eu = vu->up.eu_p;

				/* if endpoints are the same, but edges are different
				 * need to make them radial */
				if( eu->eumate_p->vu_p->v_p == i_fus->vp  &&
					eu->e_p != i_fus->eu->e_p )
				{
/*						nmg_radial_join_eu_no_ck( i_fus->eu , eu , tol ); */
						nmg_radial_join_eu( i_fus->eu , eu , tol );
				}
			}
			i_fus->fu[1] = j_fus->fu[1];
			nmg_tbl( int_faces , TBL_RM , (long *)j_fus );
			rt_free( (char *)j_fus , "nmg_make_faces_at_vert: j_fus" );

			continue;
d4468 1
a4468 1
			struct vertexuse *vu;
d4484 1
d4493 1
a4493 29
				struct vertex *old_vp,*new_vp;

				/* edge_no and next_edge_no points are within tolerance, fuse them */
				old_vp = j_fus->vp;
				new_vp = i_fus->vp;
				nmg_complex_jv( old_vp , new_vp , int_faces );

				/* join radial edges created by vertex fuse */
				for( RT_LIST_FOR( vu , vertexuse , &new_v->vu_hd ) )
				{
					if( *vu->up.magic_p != NMG_EDGEUSE_MAGIC )
						continue;

					eu = vu->up.eu_p;

					/* if endpoints are the same, but edges are different
					 * need to make them radial */
					if( eu->eumate_p->vu_p->v_p == i_fus->vp  &&
						eu->e_p != i_fus->eu->e_p )
					{
/*							nmg_radial_join_eu_no_ck( i_fus->eu , eu , tol ); */
							nmg_radial_join_eu( i_fus->eu , eu , tol );
					}
				}
				i_fus->fu[1] = j_fus->fu[1];
				nmg_tbl( int_faces , TBL_RM , (long *)j_fus );
				rt_free( (char *)j_fus , "nmg_make_faces_at_vert: j_fus" );
				j_fus = (struct intersect_fus *)NULL;
				edge_no--;
d4500 5
a4504 2

				nmg_complex_jv( i_fus->vp , new_v , int_faces );
d4506 1
a4506 1
			if( j_dist < tol->dist_sq && j_fus )
d4512 5
a4516 1
				nmg_complex_jv( j_fus->vp , new_v , int_faces );
d4518 1
a4518 1
			if( i_dist > j_dist && j_dist > tol->dist_sq && i_fus && j_fus )
d4520 4
d4528 9
a4536 3
				NMG_CK_VERTEX( j_fus->vp );
				if( j_fus->vp != i_fus->eu->vu_p->v_p &&
					j_fus->vp != i_fus->eu->eumate_p->vu_p->v_p )
d4538 6
a4543 1
					struct edgeuse *new_eu;
d4545 10
a4554 1
					new_eu = nmg_esplit( j_fus->vp , i_fus->eu );
d4556 3
d4560 1
a4560 1
			else if( j_dist > i_dist && i_dist > tol->dist_sq && i_fus && j_fus )
d4562 4
d4567 1
a4567 1
				 * split edge at j point
d4570 14
a4583 3
				NMG_CK_VERTEX( i_fus->vp );
				if( i_fus->vp != j_fus->eu->vu_p->v_p &&
					i_fus->vp != j_fus->eu->eumate_p->vu_p->v_p )
d4585 3
a4587 3
					struct edgeuse *new_eu;

					new_eu = nmg_esplit( i_fus->vp , j_fus->eu );
d4589 2
a4590 1
			}
d4592 2
a4593 5
			/* kill zero length edges created by vertex fusion */
			vu = RT_LIST_FIRST( vertexuse , &new_v->vu_hd );
			while( RT_LIST_NOT_HEAD( vu , &new_v->vu_hd ))
			{
				struct vertexuse *vu_next;
d4595 1
a4595 3
				NMG_CK_VERTEXUSE( vu );

				if( *vu->up.magic_p != NMG_EDGEUSE_MAGIC )
d4597 3
a4599 2
					vu = RT_LIST_PNEXT( vertexuse , &vu->l );
					continue;
d4601 1
d4603 5
a4607 9
				/* find next vu that will still be there after nmg_keu() */
				vu_next = RT_LIST_PNEXT( vertexuse , &vu->l );
				while ( RT_LIST_NOT_HEAD( vu_next , &new_v->vu_hd ) &&
					*vu_next->up.magic_p != NMG_EDGEUSE_MAGIC &&
					vu_next->up.eu_p->eumate_p->vu_p != vu )
						vu_next = RT_LIST_PNEXT( vertexuse , &vu_next->l );
				
				eu = vu->up.eu_p;
				NMG_CK_EDGEUSE( eu );
d4609 4
a4612 2
				/* if endpoints are both new_v kill the edge */
				if( eu->eumate_p->vu_p->v_p == new_v )
d4614 1
a4614 1
					struct edge *e;
d4616 1
a4616 3
					e = eu->e_p;
					if( nmg_keu( eu ) )
						rt_log( "ERROR: killing eu x%x left empty loop\n" , eu );
d4618 1
a4618 1
					if( e->magic == NMG_EDGE_MAGIC )
d4620 2
a4621 2
						if( e->eu_p->l.magic != NMG_EDGEUSE_MAGIC )
							rt_log( "ERROR: nmg_keu left edge with bad eu_p\n" );
d4623 18
d4642 2
a4644 2
				vu = vu_next;
			}
d4664 1
a4664 1
			rt_log( "nmg_make_faces_at_vert: Can't find loop containing vertices x%x and x%x\n" , i_fus->vp, j_fus->vp );
d4738 1
d4740 1
d4864 9
d4960 1
a4960 71
	/* first merge coincident points */
	while( edge_no < NMG_TBL_END( int_faces ) )
	{
		struct intersect_fus *i_fus,*j_fus;
		int next_edge_no;

		next_edge_no = edge_no + 1;
		if( next_edge_no == NMG_TBL_END( int_faces ) )
			next_edge_no = 0;

		i_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , edge_no );
		j_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , next_edge_no );

		NMG_CK_VERTEX( i_fus->vp );
		NMG_CK_EDGEUSE( i_fus->eu );
		NMG_CK_VERTEX( j_fus->vp );
		NMG_CK_EDGEUSE( j_fus->eu );

		if( !( i_fus->free_edge && j_fus->free_edge ) &&
			( i_fus->vp == j_fus->vp || rt_pt3_pt3_equal( i_fus->vp->vg_p->coord , j_fus->vp->vg_p->coord , tol )) )
		{
			struct vertex *old_vp,*new_vp;
			struct edgeuse *prev_eu;

			old_vp = j_fus->vp;
			new_vp = i_fus->vp;

			/* check if these are actually different vertices */
			if( old_vp != new_vp )
			{
				/* fuse the two vertices */
				nmg_complex_jv( old_vp , new_vp , int_faces );

				/* kill any cracks created */
				prev_eu = RT_LIST_PPREV_CIRC( edgeuse , &j_fus->eu->l );
				if( prev_eu->vu_p->v_p == new_vp &&
				   j_fus->eu->eumate_p->vu_p->v_p == new_vp )
				{
					struct edge *e1,*e2;

					e1 = prev_eu->e_p;
					e2 = j_fus->eu->e_p;

					if( nmg_keu( prev_eu ) || nmg_keu( j_fus->eu ) )
						rt_log( "ERROR: killing crack emptied loopuse\n" );

					if( e1->magic == NMG_EDGE_MAGIC )
					{
						if( e1->eu_p->l.magic != NMG_EDGEUSE_MAGIC )
							rt_log( "ERROR: nmg_keu left edge with bad eu_p\n" );
					}
					if( e2->magic == NMG_EDGE_MAGIC )
					{
						if( e2->eu_p->l.magic != NMG_EDGEUSE_MAGIC )
							rt_log( "ERROR: nmg_keu left edge with bad eu_p\n" );
					}

				}
			}
			/* i_fus->fu[1] is the plane being discarded */
			i_fus->fu[1] = j_fus->fu[1];

			/* eliminate one edge structure */
			nmg_tbl( int_faces , TBL_RM , (long *)j_fus );
			rt_free( (char *)j_fus , "nmg_fix_crossed_loops: j_fus" );
		}
		else
			edge_no++;
	}

	/* now look for crossed edges */
d4974 4
d5035 1
a5035 2

		if( ret_val )
d5037 3
a5039 5
			plane_t pl1,pl2,pl3;
			point_t new_pt;
			struct vertex *old_vp,*new_vp;
			fastf_t tmp_dist;
			vect_t ave_dir;
d5041 3
d5045 6
a5050 3
			NMG_GET_FU_PLANE( pl1 , i_fus->fu[0] );
			NMG_GET_FU_PLANE( pl2 , i_fus->fu[1] );
			NMG_GET_FU_PLANE( pl3 , j_fus->fu[1] );
d5052 5
a5056 6
			if( rt_mkpoint_3planes( new_pt , pl1 , pl2 , pl3 ) )
			{
				rt_log( "nmg_fix_crossed_edges: can't find new point\n" );
				edge_no++;
				continue;
			}
d5058 2
a5059 8
			/* move all occurences of j_fus->vp to i_fus->vp
			 * and move i_fus->vp to the new point
			 */
			old_vp = j_fus->vp;
			new_vp = i_fus->vp;
			VMOVE( i_fus->vp->vg_p->coord , new_pt );
			VMOVE( i_fus->pt , new_pt );
			nmg_complex_jv( old_vp , new_vp , int_faces );
d5061 1
a5061 3
			/* Eliminate the middle face */
			i_fus->fu[1] = j_fus->fu[1];
			nmg_tbl( int_faces , TBL_RM , (long *)j_fus );
d5063 4
a5066 1
			rt_free( (char *)j_fus , "nmg_fix_crossed_loops: j_fus" );
d5069 18
a5086 5
		{
			rt_log( "nmg_fix_crossed_edges: edges are colinear and overlap\n" );
			edge_no++;
			continue;
		}
d5138 1
a5138 2
	nmg_region_a( RT_LIST_FIRST( nmgregion , &m->r_hd ) , tol );
	nmg_vmodel( m );
d5168 1
a5168 1
	nmg_vmodel( m );
d5172 1
a5172 1
	nmg_vmodel( m );
d5176 1
a5176 1
	nmg_vmodel( m );
d5180 1
a5180 1
	nmg_vmodel( m );
d5182 1
d5184 2
a5186 1
	nmg_vmodel( m );
d5190 2
d6281 2
d6286 1
a6286 1
					if( nmg_find_isect_faces( vu->v_p , &faces , tol ) < 4 )
d6314 2
d6319 1
a6319 1
					if( nmg_find_isect_faces( vu->v_p , &faces , tol ) < 4 )
d6877 1
d6880 2
d6890 3
d6896 3
a6898 1
	if( nmg_find_isect_faces( new_v , &faces , tol ) < 4 )
@


1.114
log
@Checkpoint.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.113 94/02/17 16:04:17 jra Exp Locker: jra $ (ARL)";
d44 11
d56 235
d2948 1
a2948 1

d2995 1
d3059 2
a3060 11
			if( rt_isect_line3_plane( &vert_move_len , vg->coord , fp1->fg_p->N , fp1->fg_p->N , &tol_tmp ) < 1 )
			{
				rt_log( "nmg_inside_vert: Cannot find new coords for one plane\n" );
				failed = 1;
				break;
			}
			if( fp1->flip )
				VREVERSE( normal , fp1->fg_p->N )
			else
				VMOVE( normal , fp1->fg_p->N )
			VJOIN1( vg->coord , vg->coord , vert_move_len , normal );
a3064 26
#if 0
			if( fp1->flip )
				VREVERSE( normal , fp1->fg_p->N )
			else
				VMOVE( normal , fp1->fg_p->N )
			if( fp2->flip )
				VREVERSE( normal2 , fp2->fg_p->N )
			else
				VMOVE( normal2 , fp2->fg_p->N )
			VADD2( line_dir , normal , normal2 );
			if( rt_isect_line3_plane( &vert_move_len , vg->coord , line_dir , fp1->fg_p->N , &tol_tmp ) < 1 )
			{
				rt_log( "nmg_inside_vert: Cannot find new coords for two planes\n" );
				failed = 1;
				break;
			}
			VJOIN1( vg->coord , vg->coord , vert_move_len , line_dir );
#endif
#if 0
			VMOVE( rpp_min , vg->coord );
			if( rt_isect_2planes( line_start , line_dir , fp1->fg_p->N , fp2->fg_p->N , rpp_min , tol ) )
			{
				rt_log( "nmg_inside_vert: Cannot find new coords for two planes\n" );
				failed = 1;
				break;
			}
a3065 8
rt_log( "start point ( %f %f %f ) dir ( %f %f %f )\nis %g from fp1 and %g from fp2\n" , V3ARGS( line_start ) , V3ARGS( line_dir ) , DIST_PT_PLANE( line_start , fp1->fg_p->N ) , DIST_PT_PLANE( line_start , fp2->fg_p->N ) );

			(void)rt_dist_pt3_line3( &vert_move_len , vg->coord , line_start , line_dir, vg->coord, tol );
rt_log( "new point ( %f %f %f ) is %g from fp1 and %g from fp2\n" , V3ARGS( vg->coord ) , DIST_PT_PLANE( vg->coord , fp1->fg_p->N ) , DIST_PT_PLANE( vg->coord , fp2->fg_p->N ) );
rt_log( "\tfaces are x%x and x%x ( %f %f %f %f ) and ( %f %f %f %f )\n" , fp1 , fp2 , V4ARGS( fp1->fg_p->N ) , V4ARGS( fp2->fg_p->N ) );
			nmg_ck_vert_on_fus( new_v , tol );
#else

d3067 1
a3067 1
			pl1[3] = (-VDOT( vg->coord , pl1 ));
a3073 5
rt_log( "new point ( %f %f %f ) is %g from fp1 and %g from fp2\n" , V3ARGS( vg->coord ) , DIST_PT_PLANE( vg->coord , fp1->fg_p->N ) , DIST_PT_PLANE( vg->coord , fp2->fg_p->N ) );
rt_log( "\tfaces are x%x and x%x ( %f %f %f %f ) and ( %f %f %f %f )\n" , fp1 , fp2 , V4ARGS( fp1->fg_p->N ) , V4ARGS( fp2->fg_p->N ) );
			nmg_ck_vert_on_fus( new_v , tol );

#endif
d3426 1
d3441 1
d3446 8
a3453 1
		rt_log( "\tfu1 = x%x, fu2 = x%x\n" , i_fus->fu[0] , i_fus->fu[1] );
d3455 2
d3468 1
d3680 1
a3680 1
int
d3686 1
d3698 2
d3709 60
a3768 8
	/* get an edgeuse emanating from new_v */
	vu = RT_LIST_FIRST( vertexuse , &new_v->vu_hd );
	NMG_CK_VERTEXUSE( vu );
	eu1 = vu->up.eu_p;
	NMG_CK_EDGEUSE( eu1 );
	fu = nmg_find_fu_of_eu( eu1 );
	if( fu->orientation != OT_SAME )
		eu1 = eu1->eumate_p;
a3770 1

d3783 2
d3796 11
a3806 1
		i_fus->fu[1] = fu2;
d3888 4
d3893 12
d3908 8
a3915 5
		/* move on to the next edge emanating from new_v */
		eu = eu->radial_p;
		eu = RT_LIST_PNEXT_CIRC( edgeuse , eu );
		if( eu == eu1 )
			done = 1;
d3940 2
d3943 1
a3943 1
	if( rt_g.NMG_debug & DEBUG_BASIC )
d3970 2
a3971 59
		if( edge_fus->fu[0]->f_p == edge_fus->fu[1]->f_p )
			continue;
#if 0

		/* look for next entry in int_faces that has a different face */
		found1 = 0;
		next_edge_no = edge_no;
		while( !found1 )
		{
			next_edge_no++;
			if( next_edge_no == NMG_TBL_END( int_faces ) )
				next_edge_no = 0;

			if( next_edge_no == edge_no )
				break;

			other_fus[1] = (struct intersect_fus *)NMG_TBL_GET( int_faces , next_edge_no );
			if( other_fus[1]->fu[1]->f_p != edge_fus->fu[1]->f_p )
				found1 = 1;
		}

		/* look for previous entry in int_faces that has a different face */
		found2 = 0;
		prev_edge_no = edge_no;
		while( !found2 )
		{
			prev_edge_no--;
			if( prev_edge_no == (-1) )
				prev_edge_no = NMG_TBL_END( int_faces ) - 1;

			if( prev_edge_no == edge_no )
				break;

			other_fus[0] = (struct intersect_fus *)NMG_TBL_GET( int_faces , prev_edge_no );
			if( other_fus[0]->fu[0]->f_p != edge_fus->fu[0]->f_p )
				found2 = 1;
		}

		if( !found1 && !found2 )
		{
			rt_log( "nmg_get_max_edge_inters: All edges in are in the same face!!!\n" );
			continue;
		}

		/* find intersections with neighboring two faces */
		max_dist = (-MAX_FASTF);
		for( other_index=0 ; other_index<2 ; other_index++ )
		{
			struct faceuse *fu;
			plane_t pl;
			fastf_t dist;

			fu = other_fus[other_index]->fu[other_index];
			if( fu->orientation != OT_SAME )
				fu = fu->fumate_p;
			NMG_GET_FU_PLANE( pl , fu );
			
			/* intersect plane edge line */
			if( rt_isect_line3_plane( &dist , edge_fus->start , edge_fus->dir , pl , tol ) < 1 )
a3973 5
			if( dist > max_dist )
				max_dist = dist;
		}
#else

d3985 1
a3985 1
			if( !f || f == edge_fus->fu[0]->f_p || f == edge_fus->fu[1]->f_p )
d3988 6
a4000 2
#endif

d4009 7
d4020 9
a4028 2
	VSCALE( ave_pt , ave_pt , 1.0/edge_count );
	VMOVE( new_v->vg_p->coord , ave_pt );
d4031 49
d4089 1
a4089 1
void
d4095 1
a4095 1
	int edge_no=0,j;
d4097 1
a4097 1
	if( rt_g.NMG_debug & DEBUG_BASIC )
d4104 2
a4105 1
	for( edge_no=0 ; edge_no<NMG_TBL_END( int_faces ) ; edge_no++ )
a4108 5
		point_t pca;
		fastf_t dist;
		vect_t to_pca;
		struct vertex *re_use_vp;
		int prev_edge_no;
d4113 3
a4115 1
		if( i_fus->fu[0]->f_p == i_fus->fu[1]->f_p )
d4117 1
d4119 2
a4120 6
		/* Check if previous vertex already assigned the geometry for i_fus->pt */
		re_use_vp = (struct vertex *)NULL;
		prev_edge_no = edge_no - 1;
		if( prev_edge_no >= 0 )
		{
			struct intersect_fus *tmp_fus;
d4122 4
a4125 9
			tmp_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , prev_edge_no );
			if( tmp_fus->vp && rt_pt3_pt3_equal( tmp_fus->pt , i_fus->pt , tol ) )
			{
				/* found a match, use this vertex */
				re_use_vp = tmp_fus->vp;
				i_fus->vp = tmp_fus->vp;
				VMOVE( i_fus->pt , tmp_fus->pt );
			}
		}
d4127 6
a4132 4
		/* for last edge, also check first edge for re-use vertex */
		if( edge_no == NMG_TBL_END( int_faces ) - 1 )
		{
			struct intersect_fus *tmp_fus;
d4134 1
a4134 10
			tmp_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , 0 );
			if( tmp_fus->vp && rt_pt3_pt3_equal( tmp_fus->pt , i_fus->pt , tol ) )
			{
				/* found a match, use this vertex */
				re_use_vp = tmp_fus->vp;
				i_fus->vp = tmp_fus->vp;
				VMOVE( i_fus->pt , tmp_fus->pt );
			}
			
		}
d4136 9
a4144 3
		/* if this vertex isn't already part of this edge, split it */
		if( !i_fus->vp || (i_fus->vp != i_fus->eu->vu_p->v_p &&
		    i_fus->vp != i_fus->eu->eumate_p->vu_p->v_p ))
d4146 1
a4146 2
			new_eu = nmg_esplit( i_fus->vp , i_fus->eu );
			i_fus->vp = new_eu->vu_p->v_p;
d4148 5
a4152 1
			if( re_use_vp )
d4154 2
a4155 2
				struct vertexuse *vu;
				struct edgeuse *eu1,*eu2;
d4157 1
a4157 2
				/* Kill crack made by re-using previously created vertex */
				for( RT_LIST_FOR( vu , vertexuse , &re_use_vp->vu_hd ) )
d4159 1
a4159 1
					struct edge *e1,*e2;
d4161 1
a4161 2
					if( *vu->up.magic_p != NMG_EDGEUSE_MAGIC )
						continue;
d4163 1
a4163 2
					eu1 = vu->up.eu_p;
					if( eu1->eumate_p->vu_p->v_p != new_v )
d4166 3
a4168 3
					eu2 = RT_LIST_PNEXT_CIRC( edgeuse , &eu1->l );
					if( eu2->eumate_p->vu_p->v_p != re_use_vp )
						continue;
d4170 6
a4175 9
					e1 = eu1->e_p;
					e2 = eu2->e_p;
					if( nmg_keu( eu1 ) || nmg_keu( eu2 ) )
						rt_log( "ERROR empty loop needs killing\n" );

					if( e1->magic == NMG_EDGE_MAGIC )
					{
						if( e1->eu_p->l.magic != NMG_EDGEUSE_MAGIC )
							rt_log( "ERROR: nmg_keu left edge with bad eu_p\n" );
d4177 2
a4178 6
					if( e2->magic == NMG_EDGE_MAGIC )
					{
						if( e2->eu_p->l.magic != NMG_EDGEUSE_MAGIC )
							rt_log( "ERROR: nmg_keu left edge with bad eu_p\n" );
					}
					break;
d4181 9
d4191 2
a4192 3
		/* Assign geometry to the new vertex */
		if( !i_fus->vp->vg_p )
			nmg_vertex_gv( i_fus->vp , i_fus->pt );
d4194 1
d4196 12
a4207 2
	/* Now take care of edges between two loops of same face */
	edge_no = 0;
d4210 1
a4211 2
		int found=0;
		struct intersect_fus *i_fus,*j_fus;
d4213 3
a4215 1
		i_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , edge_no );
d4217 4
a4220 2
		/* here we skip any edges between two different faces */
		if( i_fus->fu[0]->f_p != i_fus->fu[1]->f_p )
d4226 1
a4226 5
		/* find the next edge that has one face the same as i_fus->fu[1]
		 * and the other face something else
		 */
		next_edge_no = edge_no;
		while( !found )
d4228 1
a4228 4
			/* go to  next edge in table */
			next_edge_no++;
			if( next_edge_no == NMG_TBL_END( int_faces ) )
				next_edge_no = 0;
d4230 1
a4230 2
			if( next_edge_no == edge_no )
				break;
d4232 4
a4235 4
			j_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , next_edge_no );
			if( j_fus->fu[0] == i_fus->fu[1] && j_fus->fu[1] != j_fus->fu[0] )
				found = 1;
		}
d4237 3
a4239 7
		/* join the edge between two loops of the same face with one
		 * at the edge of the face by splitting the first edge at a
		 * vertex from the second
		 */
		if( found )
		{
			struct edgeuse *new_eu;
d4241 1
a4241 1
			new_eu = nmg_esplit( j_fus->vp , i_fus->eu );
d4243 2
a4244 2
			/* can now safely ignore this edge */
			nmg_tbl( int_faces , TBL_RM , (long *)i_fus );
d4246 21
a4266 2
			/* free memory associated with this edge */
			rt_free( (char *)i_fus , "nmg_split_edges_at_pts: i_fus" );
d4269 1
a4269 1
			rt_log( "nmg_split_edges_at_pts: All edges are on same faces!!!\n" );
d4292 1
a4292 1
	if( rt_g.NMG_debug & DEBUG_BASIC )
d4364 6
d4384 6
d4392 2
d4416 6
a4421 3
				if( eu->eumate_p->vu_p->v_p == j_fus->vp  &&
					eu->e_p != j_fus->eu->e_p )
						nmg_radial_join_eu_no_ck( j_fus->eu , eu , tol );
d4432 1
a4432 1
			vect_t dist_to_new_v,diff_vect;
d4440 10
d4452 2
a4453 4
			VSUB2( dist_to_new_v , new_v->vg_p->coord , i_fus->vp->vg_p->coord );
			i_dist = MAGSQ( dist_to_new_v );
			VSUB2( dist_to_new_v , new_v->vg_p->coord , j_fus->vp->vg_p->coord );
			j_dist = MAGSQ( dist_to_new_v );
d4474 6
a4479 3
					if( eu->eumate_p->vu_p->v_p == j_fus->vp  &&
						eu->e_p != j_fus->eu->e_p )
							nmg_radial_join_eu_no_ck( j_fus->eu , eu , tol );
d4485 1
a4485 1

a4493 3
				nmg_tbl( int_faces , TBL_RM , (long *)i_fus );
				rt_free( (char *)i_fus , "nmg_make_faces_at_vert: i_fus" );
				i_fus = (struct intersect_fus *)NULL;
a4501 3
				nmg_tbl( int_faces , TBL_RM , (long *)j_fus );
				rt_free( (char *)j_fus , "nmg_make_faces_at_vert: j_fus" );
				j_fus = (struct intersect_fus *)NULL;
a4516 1
				edge_no++;
a4531 1
				edge_no++;
a4563 1

d4576 1
a4581 1

d4676 28
a4719 1
#if 0
a4723 1
	struct vertexuse *vu;
a4724 139

	if( rt_g.NMG_debug & DEBUG_BASIC )
		rt_log( "nmg_kill_cracks_at_vert( x%x \n" , vp );

	NMG_CK_VERTEX( vp );

m = nmg_find_model( &vp->magic );
rt_log( "nmg_vmodel( m=x%x ) just into nmg_kill_cracks_at_vertex\n" , m );
nmg_vmodel( m );

	/* loop through all uses of new_v */
	vu = RT_LIST_FIRST( vertexuse , &vp->vu_hd );
	while( RT_LIST_NOT_HEAD( vu , &vp->vu_hd ) )
	{
		struct faceuse *fu;
		struct loopuse *lu;
		struct vertexuse *vu_next;
		int bad_face=0;

		/* since we may be deleting vu's, remember where next one is */
		vu_next = RT_LIST_PNEXT( vertexuse , &vu->l );

		/* find faceuse for this vu */
		fu = nmg_find_fu_of_vu( vu );

		/* look at each loop in this face */
		lu = RT_LIST_FIRST( loopuse , &fu->lu_hd );
		while( RT_LIST_NOT_HEAD( lu , &fu->lu_hd ) )
		{
			struct loopuse *lu_next;
			struct edgeuse *eu_prev;
			struct edgeuse *eu;
			int bad_loop = 0;

			lu_next = RT_LIST_PNEXT( loopuse , &lu->l );
			eu_prev = NULL;

			/* look at edguese in this loopuse */
			eu = RT_LIST_FIRST( edgeuse , &lu->down_hd );
			while( RT_LIST_NOT_HEAD( eu , &lu->down_hd ) )
			{
				struct edgeuse *eu_next;

				eu_next = RT_LIST_PNEXT( edgeuse , &eu->l );

				/* keep track of previous edgeuse */
				if( !eu_prev )
				{
					eu_prev = eu;
					continue;
				}

				if( eu->eumate_p->vu_p->v_p == eu_prev->vu_p->v_p )
				{
					struct edge *e;

					/* This is a crack , get rid of it */

					/* first make sure we know where the next
					 * valid use of vp will be after killings
					 */
					while( vu_next == eu->eumate_p->vu_p ||
					       vu_next == eu->vu_p ||
					       vu_next == eu_prev->vu_p ||
					       vu_next == eu_prev->eumate_p->vu_p )
					{
						vu_next = RT_LIST_PNEXT( vertexuse , &vu_next->l );
					}

					e = eu_prev->e_p;
					if( nmg_keu( eu_prev ) )
					{
						if( e->magic == NMG_EDGE_MAGIC )
						{
							if( e->eu_p->l.magic != NMG_EDGEUSE_MAGIC )
								rt_log( "ERROR: nmg_keu left edge with bad eu_p\n" );
						}
rt_log( "Killing edgeuse 1 made bad loop\n" );
						bad_loop = 1;
						break;
					}
					if( e->magic == NMG_EDGE_MAGIC )
					{
						if( e->eu_p->l.magic != NMG_EDGEUSE_MAGIC )
							rt_log( "ERROR: nmg_keu left edge with bad eu_p\n" );
					}

					e = eu->e_p;
					if( nmg_keu( eu ) )
					{
						if( e->magic == NMG_EDGE_MAGIC )
						{
							if( e->eu_p->l.magic != NMG_EDGEUSE_MAGIC )
								rt_log( "ERROR: nmg_keu left edge with bad eu_p\n" );
						}
rt_log( "Killing edgeuse 2 made bad loop\n" );
						bad_loop = 1;
						break;
					}
					if( e->magic == NMG_EDGE_MAGIC )
					{
						if( e->eu_p->l.magic != NMG_EDGEUSE_MAGIC )
							rt_log( "ERROR: nmg_keu left edge with bad eu_p\n" );
					}
rt_log( "nmg_vmodel( m=x%x ) just after killing crack bad_loop = %d\n" , m , bad_loop );
nmg_vmodel( m );
					break;
				}
				else
					eu_prev = eu;

				eu = eu_next;
			}
			if( bad_loop )
			{
rt_log( "Killing loopuse\n" );
				if( nmg_klu( lu ) )
				{
					bad_face = 1;
					break;
				}
			}
			lu = lu_next;
		}

		if( bad_face )
		{
rt_log( "Killing faceuse\n" );
			if( nmg_kfu( fu ) )
				rt_log( "ERROR: Killing faceuse x%x emptied shell!!!\n" , fu );
		}

		vu = vu_next;
	}
}
#else
nmg_kill_cracks_at_vertex( vp )
CONST struct vertex *vp;
{
a4727 1
	struct model *m;
d4734 1
a4735 2
rt_log( "nmg_vmodel( m=x%x ) just into nmg_kill_cracks_at_vertex\n" , m );
nmg_vmodel( m );
d4784 2
a4786 1

d4788 1
d4791 1
a4791 1
				if( eu_prev->vu_p->v_p == eu->eumate_p->vu_p->v_p )
d4793 3
a4795 3
rt_log( "Found crack: eu's x%x and x%x, edges x%x and x%x\n" , eu , eu_prev , eu->e_p , eu_prev->e_p );
rt_log( "\t from vertex x%x to x%x to x%x\n" , eu_prev->vu_p->v_p , eu->vu_p->v_p , eu->eumate_p->vu_p->v_p );
rt_log( "\tvu's x%x and x%x , v's x%x and x%x\n" , eu->vu_p , eu_prev->vu_p , eu->vu_p->v_p , eu_prev->vu_p->v_p );
d4806 1
a4806 1
rt_log( "Killing crack made empty loop\n" );
d4810 1
a4810 1
rt_log( "nmg_vmodel( m=x%x ) just after killing crack bad_loop = %d\n" , m , bad_loop );
a4818 1
rt_log( "Killing loopuse made empty faceuse\n" );
a4826 1
rt_log( "Killing faceuse\n" );
a4832 1
#endif
d4867 1
a4867 1
	if( rt_g.NMG_debug & DEBUG_BASIC )
d4893 4
a4896 3
rt_log( "Checking vertices in nmg_fix_crossed_loops\n" );
nmg_ck_vert_on_fus( i_fus->vp , tol );
nmg_ck_vert_on_fus( j_fus->vp , tol );
d4898 2
a4899 1
		if( i_fus->vp == j_fus->vp || rt_pt3_pt3_equal( i_fus->vp->vg_p->coord , j_fus->vp->vg_p->coord , tol ) )
d4973 5
a4977 3
rt_log( "Checking vertices in nmg_fix_crossed_loops proior to cross check\n" );
nmg_ck_vert_on_fus( i_fus->vp , tol );
nmg_ck_vert_on_fus( j_fus->vp , tol );
a5055 2
rt_log( "Checking new vertex in nmg_fix_crossed_loops\n" );
nmg_ck_vert_on_fus( i_fus->vp , tol );
d5107 1
a5107 1
/*	if( rt_g.NMG_debug & DEBUG_BASIC ) */
d5113 3
a5115 3
m = nmg_find_model( &new_v->magic );
rt_log( "nmg_vmodel( m = x%x ) just into nmg_complex_vertex_solve\n" , m );
nmg_vmodel( m );
d5141 2
d5145 1
d5147 3
a5149 2
rt_log( "nmg_vmodel( m = x%x ) just after splitting edges\n" , m );
nmg_vmodel( m );
d5151 4
d5157 1
a5158 3
rt_log( "nmg_vmodel( m = x%x ) just after fix crossed loops\n" , m );
nmg_vmodel( m );

d5160 2
a5162 3
rt_log( "nmg_vmodel( m = x%x ) just after makeing faces\n" , m );
nmg_vmodel( m );

d5165 2
a5167 3
rt_log( "nmg_vmodel( m = x%x ) just after killing cracks\n" , m );
nmg_vmodel( m );

d5768 2
a5769 1
						nmg_radial_join_eu_no_ck( eu_base , eu , tol );
d6377 6
d6384 347
d6753 1
a6753 3
	struct edgeuse *eu1;
	struct edgeuse *eu2;
	struct faceuse *new_fu;
a6754 1
	int i;
d6785 2
a6786 1
			for( RT_LIST_FOR( eu1 , edgeuse , &lu->down_hd ) )
d6788 2
a6789 2
				NMG_CK_EDGEUSE( eu1 );
				if( eu1->eumate_p == eu1->radial_p )
d6791 2
a6792 4
					struct vertex *verts[3];
					struct vertex *vp1,*vp2;
					struct vertexuse *vu;
					struct faceuse *fu1,*fu2;
d6795 1
a6795 1
					vp1 = NMG_INDEX_GETP(vertex, copy_tbl, eu1->vu_p->v_p);
d6797 8
a6804 2
					vp2 = NMG_INDEX_GETP(vertex, copy_tbl, eu1->eumate_p->vu_p->v_p);
					NMG_CK_VERTEX( vp2 );
d6806 2
a6807 17
					/* Make two triangular faces connecting these two edges */
					verts[0] = eu1->vu_p->v_p;
					verts[1] = vp1;
					verts[2] = vp2;
					if( rt_3pts_distinct( verts[0]->vg_p->coord,verts[1]->vg_p->coord,verts[2]->vg_p->coord, tol ) )
					{
						fu1 = nmg_cface( dst , verts , 3 );
						if( nmg_fu_planeeqn( fu1 , tol ) )
						{
							rt_log( "nmg_connect_open_shells: failed to calulate plane eqn\n" );
							rt_log( "\tFace:\n" );
							rt_log( "\t\t( %f %f %f ) -> ( %f %f %f ) -> ( %f %f %f )\n",
								V3ARGS( verts[0]->vg_p->coord ),
								V3ARGS( verts[1]->vg_p->coord ),
								V3ARGS( verts[2]->vg_p->coord ) );
						}
					}
d6809 2
a6810 16
					verts[0] = eu1->eumate_p->vu_p->v_p;
					verts[1] = eu1->vu_p->v_p;
					verts[2] = vp2;
					if( rt_3pts_distinct( verts[0]->vg_p->coord,verts[1]->vg_p->coord,verts[2]->vg_p->coord, tol ) )
					{
						fu2 = nmg_cface( dst , verts , 3 );
						if( nmg_fu_planeeqn( fu2 , tol ) )
						{
							rt_log( "nmg_connect_open_shells: failed to calulate plane eqn\n" );
							rt_log( "\tFace:\n" );
							rt_log( "\t\t( %f %f %f ) -> ( %f %f %f ) -> ( %f %f %f )\n",
								V3ARGS( verts[0]->vg_p->coord ),
								V3ARGS( verts[1]->vg_p->coord ),
								V3ARGS( verts[2]->vg_p->coord ) );
						}
					}
@


1.113
log
@Checkpoint.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.112 94/02/16 17:56:56 jra Exp Locker: jra $ (ARL)";
d564 2
a565 1
	index = NULL;
d569 2
d954 3
d1145 3
d1149 1
d1183 3
d1360 3
d1364 2
d1492 6
d1531 1
a1531 1
		nmg_propagate_normals( fu , flags );
d1574 6
d1661 3
d1886 5
d1944 3
d2484 3
d2545 4
d2601 3
d2653 6
d2773 3
d2799 1
d2827 1
d2844 31
d2947 3
d3160 56
d3320 3
d3380 1
d3395 1
d3397 5
d3434 3
d3482 3
d3645 3
d3674 1
d3736 1
d3738 23
d3764 1
d3766 2
a3768 2
		VJOIN1( edge_fus->pt , edge_fus->start , max_dist , edge_fus->dir );

d3794 3
d3834 16
d3865 2
d3878 15
a3892 2
					nmg_keu( eu1 );
					nmg_keu( eu2 );
d3944 1
a3944 1
			(void)nmg_esplit( j_fus->vp , i_fus->eu );
d3946 2
d3978 2
a3979 1
rt_log( "nmg_make_faces_at_vert( x%x )\n" , new_v );
a4065 2
{
	struct loopuse *lu1,*lu2;
a4066 12
	lu1 = i_fus->eu->up.lu_p;
	lu2 = j_fus->eu->up.lu_p;

	rt_log( "Edge #%d:\n" , edge_no );
	rt_log( "\ti_fus->eu = x%x , j_fus->eu = x%x\n" , i_fus->eu , j_fus->eu );
	rt_log( "\ti_fus->vp = x%x , j_fus->vp = x%x\n" , i_fus->vp , j_fus->vp );
	nmg_pr_lu_briefly( lu1 , "lu1" );

	if( lu2 != lu1 )
		nmg_pr_lu_briefly( lu2 , "lu2" );
}

d4090 1
a4090 1
					nmg_radial_join_eu_no_ck( j_fus->eu , eu , tol );
a4095 22
{
	struct loopuse *lu1,*lu2;

	if( i_fus )
		lu1 = i_fus->eu->up.lu_p;
	if( j_fus )
		lu2 = j_fus->eu->up.lu_p;

	rt_log( "Edge #%d (after fusing both vertices):\n" , edge_no );
	if( i_fus && j_fus )
		rt_log( "\ti_fus->vp = x%x , j_fus->vp = x%x\n" , i_fus->vp , j_fus->vp );
	else if( i_fus )
                rt_log( "\ti_fus->vp = x%x\n" , i_fus->vp );
	else if( j_fus )
                rt_log( "\tj_fus->vp = x%x\n" , j_fus->vp );

	if( i_fus )
		nmg_pr_lu_briefly( lu1 , "lu1" );

	if( j_fus )
		nmg_pr_lu_briefly( lu2 , "lu2" );
}
d4137 1
a4137 1
						nmg_radial_join_eu_no_ck( j_fus->eu , eu , tol );
a4142 2
{
	struct loopuse *lu1,*lu2;
a4143 20
	if( i_fus )
		lu1 = i_fus->eu->up.lu_p;
	if( j_fus )
		lu2 = j_fus->eu->up.lu_p;

	rt_log( "Edge #%d (after fusing both vertices):\n" , edge_no );
	if( i_fus && j_fus )
		rt_log( "\ti_fus->vp = x%x , j_fus->vp = x%x\n" , i_fus->vp , j_fus->vp );
	else if( i_fus )
                rt_log( "\ti_fus->vp = x%x\n" , i_fus->vp );
	else if( j_fus )
                rt_log( "\tj_fus->vp = x%x\n" , j_fus->vp );

	if( i_fus )
		nmg_pr_lu_briefly( lu1 , "lu1" );

	if( j_fus )
		nmg_pr_lu_briefly( lu2 , "lu2" );
}

a4154 22
{
	struct loopuse *lu1,*lu2;

	if( i_fus )
		lu1 = i_fus->eu->up.lu_p;
	if( j_fus )
		lu2 = j_fus->eu->up.lu_p;

	rt_log( "Edge #%d (after fusing i_fus->vp with new_v):\n" , edge_no );
	if( i_fus && j_fus )
		rt_log( "\ti_fus->vp = x%x , j_fus->vp = x%x\n" , i_fus->vp , j_fus->vp );
	else if( i_fus )
                rt_log( "\ti_fus->vp = x%x\n" , i_fus->vp );
	else if( j_fus )
                rt_log( "\tj_fus->vp = x%x\n" , j_fus->vp );

	if( i_fus )
		nmg_pr_lu_briefly( lu1 , "lu1" );

	if( j_fus )
		nmg_pr_lu_briefly( lu2 , "lu2" );
}
a4165 22
{
	struct loopuse *lu1,*lu2;

	if( i_fus )
		lu1 = i_fus->eu->up.lu_p;
	if( j_fus )
		lu2 = j_fus->eu->up.lu_p;

	rt_log( "Edge #%d (after fusing j_fus->vp with new_v):\n" , edge_no );
	if( i_fus && j_fus )
		rt_log( "\ti_fus->vp = x%x , j_fus->vp = x%x\n" , i_fus->vp , j_fus->vp );
	else if( i_fus )
                rt_log( "\ti_fus->vp = x%x\n" , i_fus->vp );
	else if( j_fus )
                rt_log( "\tj_fus->vp = x%x\n" , j_fus->vp );

	if( i_fus )
		nmg_pr_lu_briefly( lu1 , "lu1" );

	if( j_fus )
		nmg_pr_lu_briefly( lu2 , "lu2" );
}
d4176 2
a4177 3
						(void)nmg_esplit( j_fus->vp , i_fus->eu );
{
	struct loopuse *lu1,*lu2;
d4179 2
a4180 19
	if( i_fus )
		lu1 = i_fus->eu->up.lu_p;
	if( j_fus )
		lu2 = j_fus->eu->up.lu_p;

	rt_log( "Edge #%d (after splitting i_fus->eu):\n" , edge_no );
	if( i_fus && j_fus )
		rt_log( "\ti_fus->vp = x%x , j_fus->vp = x%x\n" , i_fus->vp , j_fus->vp );
	else if( i_fus )
                rt_log( "\ti_fus->vp = x%x\n" , i_fus->vp );
	else if( j_fus )
                rt_log( "\tj_fus->vp = x%x\n" , j_fus->vp );

	if( i_fus )
		nmg_pr_lu_briefly( lu1 , "lu1" );

	if( j_fus )
		nmg_pr_lu_briefly( lu2 , "lu2" );
}
d4192 2
a4193 3
						(void)nmg_esplit( i_fus->vp , j_fus->eu );
{
	struct loopuse *lu1,*lu2;
d4195 2
a4196 19
	if( i_fus )
		lu1 = i_fus->eu->up.lu_p;
	if( j_fus )
		lu2 = j_fus->eu->up.lu_p;

	rt_log( "Edge #%d (after splitting j_fus->eu):\n" , edge_no );
	if( i_fus && j_fus )
		rt_log( "\ti_fus->vp = x%x , j_fus->vp = x%x\n" , i_fus->vp , j_fus->vp );
	else if( i_fus )
                rt_log( "\ti_fus->vp = x%x\n" , i_fus->vp );
	else if( j_fus )
                rt_log( "\tj_fus->vp = x%x\n" , j_fus->vp );

	if( i_fus )
		nmg_pr_lu_briefly( lu1 , "lu1" );

	if( j_fus )
		nmg_pr_lu_briefly( lu2 , "lu2" );
}
d4226 2
a4227 1
					(void)nmg_keu( eu );
d4229 1
a4229 4
				vu = vu_next;
			}
{
	struct loopuse *lu1,*lu2;
d4231 2
a4232 4
	if( i_fus )
		lu1 = i_fus->eu->up.lu_p;
	if( j_fus )
		lu2 = j_fus->eu->up.lu_p;
d4234 6
a4239 7
	rt_log( "Edge #%d (after killing zero length edges):\n" , edge_no );
	if( i_fus && j_fus )
		rt_log( "\ti_fus->vp = x%x , j_fus->vp = x%x\n" , i_fus->vp , j_fus->vp );
	else if( i_fus )
                rt_log( "\ti_fus->vp = x%x\n" , i_fus->vp );
	else if( j_fus )
                rt_log( "\tj_fus->vp = x%x\n" , j_fus->vp );
d4241 2
a4242 6
	if( i_fus )
		nmg_pr_lu_briefly( lu1 , "lu1" );

	if( j_fus )
		nmg_pr_lu_briefly( lu2 , "lu2" );
}
a4248 55
{
	struct loopuse *lu1,*lu2;

	if( i_fus )
		lu1 = i_fus->eu->up.lu_p;
	if( j_fus )
		lu2 = j_fus->eu->up.lu_p;

	rt_log( "Edge #%d (ready to make faces):\n" , edge_no );
	if( i_fus && j_fus )
		rt_log( "\ti_fus->vp = x%x , j_fus->vp = x%x\n" , i_fus->vp , j_fus->vp );
	else if( i_fus )
                rt_log( "\ti_fus->vp = x%x\n" , i_fus->vp );
	else if( j_fus )
                rt_log( "\tj_fus->vp = x%x\n" , j_fus->vp );

	if( i_fus )
		nmg_pr_lu_briefly( lu1 , "lu1" );

	if( j_fus )
		nmg_pr_lu_briefly( lu2 , "lu2" );
}
#if 0
		vu2 = (struct vertexuse *)NULL;
		for( RT_LIST_FOR( vu1 , vertexuse , &i_fus->vp->vu_hd ) )
		{
			NMG_CK_VERTEXUSE( vu1 );

			fu = nmg_find_fu_of_vu( vu1 );

			if( !fu )
				continue;

			if( fu->orientation != OT_SAME )
				continue;

			lu = nmg_find_lu_of_vu( vu1 );

			if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
				continue;

			for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
			{
				if( eu->vu_p->v_p == j_fus->vp )
				{
					vu2 = eu->vu_p;
					break;
				}
			}
			if( vu2 )
				break;
		}
		old_lu = lu;
#else

a4259 2
#endif

d4341 1
a4341 1
		if( nmg_fu_planeeqn( new_fu , &tol_tmp ) )
d4347 1
d4359 1
d4365 1
d4367 3
d4372 4
d4420 2
d4435 1
a4435 1

d4438 6
d4447 7
d4456 6
d4465 7
d4481 1
d4492 5
a4496 1
			(void)nmg_kfu( fu );
d4501 9
d4511 106
d4642 1
a4642 2
nmg_fix_crossed_loops( edge_dist , new_v , int_faces , tol )
CONST fastf_t edge_dist;
d4650 3
d4676 4
d4699 19
a4717 2
					nmg_keu( prev_eu );
					nmg_keu( j_fus->eu );
d4754 4
d4835 2
d4867 1
d4888 3
d4894 4
d4925 3
d4929 1
a4929 1
	nmg_fix_crossed_loops( 3.0 , new_v , &int_faces , tol );
d4931 3
d4936 3
d4942 3
d5221 1
a5221 1
	struct nmgregion *new_r;
d5226 1
d5233 2
a5234 1
rt_log( "nmg_extrude_cleanup\n" );
d5237 1
d5239 8
d5291 3
a5293 1
#if 0
d5295 2
d5298 8
d5308 1
d5886 3
d6182 3
d6300 3
d6363 3
d6454 2
@


1.112
log
@Checkpoint
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.111 94/02/16 09:43:44 jra Exp Locker: jra $ (ARL)";
d2726 2
a2727 8
rt_log( "Simple vertex %d faces:\n" , NMG_TBL_END( faces ) );
{
int i;
for( i=0 ; i<NMG_TBL_END( faces ) ; i++ )
{
	struct face *fp;
	struct faceuse *fu;
	plane_t pl;
a2728 13
	fp = (struct face *)NMG_TBL_GET( faces , i );
	rt_log( "\tface %d (x%x):\n" , i , fp );

	fu = fp->fu_p;
	if( fu->orientation != OT_SAME )
		fu = fu->fumate_p;

	NMG_GET_FU_PLANE( pl , fu );
	rt_log( "\t\tplane = ( %f %f %f %f )\n" , V4ARGS( pl ) );
}
}

	vg = new_v->vg_p;
a2925 1
rt_log("eu2=x%x is a wire, insert after eu1=x%x\n", eu2, eu1);
a2930 1
rt_log("eu1=x%x is a wire, skipping on\n", eu1);
a2936 1
rt_log("eur=x%x is a wire, advancing to non-wire eur\n", eur);
a2939 1
rt_log("went all the way around\n");
d3074 1
a3074 2
	double angle;		/* angle of edge (clockwise around average normal at vertex */
	point_t pt;		/* a point on this edge a small distance from the vertex */
d3153 112
d3297 1
a3297 1
 * new_v. Does not fill in "angle", "pt", or "vp".
a3316 2
rt_log( "nmg_get_edge_lines: at x%x ( %f %f %f )\n" , new_v , V3ARGS( new_v->vg_p->coord ) );

a3370 1
			NMG_GET_FU_NORMAL( normal1 , fu1 );
d3373 2
a3374 1
rt_log( "fu1 (x%x) fu2 (x%x) planes = ( %f %f %f %f ) and ( %f %f %f %f )\n" , fu1 , fu2 , V4ARGS( fu1->f_p->fg_p->N ) , V4ARGS( fu2->f_p->fg_p->N ) );
a3376 1
rt_log( "nmg_get_edge_lines: rt_isect_2planes failed returned %d\n" , ret_val );
d3444 1
d3447 1
d3460 2
a3461 2
 * for edges around new_v by calculating the intersection with each
 * face and selecting the furthest one from new_v.
a3488 1
rt_log( "\nnmg_get_max_edge_inters for vertex at ( %f %f %f )\n" , V3ARGS( new_v->vg_p->coord ) );
a3493 2
		fastf_t old_edge_len_sq;
		vect_t old_edge_vec;
d3496 1
a3496 1
		int found;
d3504 2
a3505 1
		found = 0;
d3507 1
a3507 1
		while( !found )
d3517 2
a3518 2
			if( other_fus[1]->fu[1] != edge_fus->fu[1] )
				found = 1;
d3521 2
a3522 4
		if( !found )
			rt_log( "nmg_get_max_edge_inters: All edges in are in the same face!!!\n" );

		found = 0;
d3524 1
a3524 1
		while( !found )
d3534 2
a3535 2
			if( other_fus[0]->fu[0] != edge_fus->fu[0] )
				found = 1;
d3538 2
a3539 1
		if( !found )
d3541 2
d3544 1
a3544 3
		VSUB2( old_edge_vec , edge_fus->eu->eumate_p->vu_p->v_p->vg_p->coord , new_v->vg_p->coord );
		old_edge_len_sq = MAGSQ( old_edge_vec );

a3545 2

		/* find intersections with neighboring two faces */
d3560 1
a3560 11
#if 0
			/* if intersect point is more than halfway to the next vertex, this is likely
			 * a plane that is nearly parallel to the edge line
			 */
			if( 4.0*dist*dist > old_edge_len_sq )
			{
				if( dist <  backup_max_dist )
					backup_max_dist = dist;
				continue;
			}
#endif
a3570 2
rt_log( "\tfor edge start at ( %f %f %f ) in dir ( %f %f %f )\n" , V3ARGS( edge_fus->start ) , V3ARGS( edge_fus->dir ) );
rt_log( "\t\tdist = %f, intersect at ( %f %f %f )\n" , max_dist , V3ARGS( edge_fus->pt ) );
a3577 1
rt_log( "\tave_pt = ( %f %f %f )\n" , V3ARGS( ave_pt ) );
a3579 362
/*	N M G _ G E T _ E D G E _ I N T E R S
 *
 * fill in the "pt" portion of the "intersect_fus" structure
 * for edges around new_v
 * and refine the estimate for the geometry of new_v
 */
void
nmg_get_edge_inters( new_v , dist , int_faces )
struct vertex *new_v;
CONST fastf_t dist;
struct nmg_ptbl *int_faces;
{
	struct rt_tol tol_tmp;
	point_t ave_pt;
	int edge_no;

	NMG_CK_VERTEX( new_v );

	/* A local tolerance structure for times when I don't want tolerancing */
	tol_tmp.magic = RT_TOL_MAGIC;
	tol_tmp.dist = SQRT_SMALL_FASTF;
	tol_tmp.dist_sq = SMALL_FASTF;
	tol_tmp.perp = 0.0;
	tol_tmp.para = 1.0;

rt_log( "\nat (%f %f %f): \n" , V3ARGS( new_v->vg_p->coord ) );
	VSET( ave_pt , 0.0 , 0.0 , 0.0 );
	for( edge_no=0 ; edge_no < NMG_TBL_END( int_faces ) ; edge_no++ )
	{
		struct intersect_fus *i_fus;
		fastf_t tmp_dist;
		char rcc_name[17];
		vect_t height;
		vect_t tmp_dir;
		fastf_t radius,d1,d2;

		i_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , edge_no );

		/* Make the start point at closest approach to new vertex */
		(void)rt_dist_pt3_line3( &tmp_dist , i_fus->start , i_fus->start , i_fus->dir , new_v->vg_p->coord , &tol_tmp );


		/* find a point "dist" distance along the edge line
		 * away from the start point
		 */
		VJOIN1( i_fus->pt , i_fus->start , dist , i_fus->dir );
		VADD2( ave_pt , ave_pt , i_fus->pt );

rt_log( "\tfor edge ( %f %f %f ) -> ( %f %f %f )\n",
	V3ARGS( i_fus->eu->vu_p->v_p->vg_p->coord ),
	V3ARGS( i_fus->eu->eumate_p->vu_p->v_p->vg_p->coord ) );
rt_log( "\t\tstart = ( %f %f %f ) , dir = ( %f %f %f )\n",
	V3ARGS( i_fus->start ) , V3ARGS( i_fus->dir ) );
rt_log( "\t\tintersect = ( %f %f %f )\n", V3ARGS( i_fus->pt ) );
rt_log( "\t\tpl1 = ( %f %f %f %f ) , pl2 = ( %f %f %f %f )\n" , V4ARGS( i_fus->fu[0]->f_p->fg_p->N ), V4ARGS( i_fus->fu[1]->f_p->fg_p->N ) );
VCROSS( tmp_dir , i_fus->fu[0]->f_p->fg_p->N , i_fus->fu[1]->f_p->fg_p->N );
VUNITIZE( tmp_dir );
d1 = DIST_PT_PLANE( i_fus->start , i_fus->fu[0]->f_p->fg_p->N );
d2 = DIST_PT_PLANE( i_fus->start , i_fus->fu[1]->f_p->fg_p->N );
rt_log( "\t\ttmp_dir = ( %f %f %f ), d1 = %f , d2 = %f\n" , V3ARGS(tmp_dir) , d1 , d2 );

	}
	VSCALE( ave_pt , ave_pt , (1.0/(double)(NMG_TBL_END(int_faces)) ) );
	VMOVE( new_v->vg_p->coord , ave_pt );

rt_log( "\tcenter at ( %f %f %f )\n" , V3ARGS( ave_pt ) );
}

/*	N M G _ C A L C _ A V E _ N O R M
 *
 * given a table of faces, calculate the average outward
 * pointing normal ( not unitized )
 *
 */
void
nmg_calc_ave_norm( ave_norm , faces )
point_t ave_norm;
CONST struct nmg_ptbl *faces;
{
	int i;

	VSET( ave_norm , 0.0 , 0.0 , 0.0 );
	for( i=0 ; i<NMG_TBL_END( faces ) ; i++ )
	{
		struct face *fp;
		struct faceuse *fu;
		vect_t norm;

		fp = (struct face *)NMG_TBL_GET( faces , i );
		fu = fp->fu_p;
		if( fu->orientation != OT_SAME )
			fu = fu->fumate_p;

		NMG_GET_FU_NORMAL( norm , fu );

		VADD2( ave_norm , ave_norm , norm );
	}
	VSCALE( ave_norm , ave_norm , (1.0)/((fastf_t)(NMG_TBL_END( faces ))) );
	VUNITIZE( ave_norm );
rt_log( "ave_norm = ( %f %f %f )\n" , V3ARGS( ave_norm ) );
}

/*	N M G _ C A L C _ E D G E _ A N G L E S
 *
 * fill in "angle" portion of intersect_fus structures in int_faces table
 *
 */
void
nmg_calc_edge_angles( int_faces , ave_norm , new_v , tol )
struct nmg_ptbl *int_faces;
CONST vect_t ave_norm;
CONST struct vertex *new_v;
CONST struct rt_tol *tol;
{
	struct intersect_fus *i_fus;
	vect_t x_vec,y_vec;
	struct vertex *last_v;
	fastf_t last_angle;
	int edge_no;
	struct intersect_fus *first,*last;

	NMG_CK_VERTEX( new_v );

	/* first make sure that two equal vertices aren't at the first and last edge */
	first = (struct intersect_fus *)NMG_TBL_GET( int_faces , 0 );
	last = (struct intersect_fus *)NMG_TBL_GET( int_faces , NMG_TBL_END( int_faces )-1 );
	while( first->vp == last->vp )
	{
		nmg_tbl( int_faces , TBL_RM , (long *)first );
		nmg_tbl( int_faces , TBL_INS , (long *)first );
		first = (struct intersect_fus *)NMG_TBL_GET( int_faces , 0 );
		last = (struct intersect_fus *)NMG_TBL_GET( int_faces , NMG_TBL_END( int_faces )-1 );
	}

	/* calculate reference coord system with ave_norm as the z_axis
	 * and the first edge line at angle of 2*pi
	 */
	i_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , 0 );
	VSUB2( x_vec , i_fus->pt , new_v->vg_p->coord );
	VCROSS( y_vec , ave_norm , x_vec );
	VCROSS( x_vec , y_vec , ave_norm );
	VUNITIZE( y_vec );
	VUNITIZE( x_vec );
	i_fus->angle = rt_twopi;
rt_log( "0 vp = x%x, pt = ( %f %f %f ), angle = %f\n" , i_fus->vp , V3ARGS( i_fus->pt ) , i_fus->angle );

	last_angle = rt_twopi;
	last_v = i_fus->vp;

	/* calculate angle for the rest of the edge lines */
	for( edge_no=1 ; edge_no < NMG_TBL_END( int_faces ) ; edge_no++ )
	{
		vect_t v1,v2;

		i_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , edge_no );

		if( i_fus->vp == last_v )
		{
			i_fus->angle = last_angle;
		}
		else
		{
			VSUB2( v1 , i_fus->vp->vg_p->coord , new_v->vg_p->coord );

			/* get the component of this vector in the "x_vec/y_vec" plane */
			VCOMB2( v2 , VDOT( v1 , x_vec ) , x_vec , VDOT( v1 , y_vec ) , y_vec );

			i_fus->angle = rt_angle_measure( v1 , x_vec , y_vec );
		}

		last_v = i_fus->vp;
		last_angle = i_fus->angle;
rt_log( "%d vp = x%x, pt = ( %f %f %f ), angle = %f\n" , edge_no , i_fus->vp , V3ARGS( i_fus->pt ) , i_fus->angle );
	}
}

/*	N M G _ F U S E _ C R O S S E D _ E D G E S
 *
 * The edge lines in the intersect_fus structure should depart the vertex
 * at decreasing angles. Where they don't, they must cross. Find a new common
 * point for such edge lines to eliminate the crossing
 *
 */
void
nmg_fuse_crossed_edges( int_faces , faces , tol )
struct nmg_ptbl *int_faces;
CONST struct nmg_ptbl *faces;
CONST struct rt_tol *tol;
{
	int edge_no;
	double three_halves_pi;
	struct rt_tol tol_tmp;
	int next_search_start=0;

rt_log( "nmg_fuse_crossed_edges:\n" );

	/* A local tolerance structure for times when I don't want tolerancing */
	tol_tmp.magic = RT_TOL_MAGIC;
	tol_tmp.dist = SQRT_SMALL_FASTF;
	tol_tmp.dist_sq = SMALL_FASTF;
	tol_tmp.perp = 0.0;
	tol_tmp.para = 1.0;

	three_halves_pi = rt_twopi - rt_halfpi;

	/* loop through all the structures in the table */
	while( next_search_start < NMG_TBL_END( int_faces ) )
	{
		struct intersect_fus *i_fus,*j_fus,*tmp_fus;
		plane_t pl1,pl2;
		struct faceuse *fu1,*fu2;
		point_t start,new_pt;
		vect_t dir;
		fastf_t dist,max_dist;
		fastf_t diff;
		fastf_t new_angle;
		int next_edge_no;
		int tmp_edge_no;
		int face_no;

		edge_no = next_search_start;

		/* get this edge */
		i_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , edge_no );

		/* and the next */
		next_edge_no = edge_no + 1;
		if( next_edge_no == NMG_TBL_END( int_faces ) )
			next_edge_no = 0;

		j_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , next_edge_no );
		while( j_fus->vp == i_fus->vp )
		{
			next_edge_no++;
			if( next_edge_no == NMG_TBL_END( int_faces ) )
				next_edge_no = 0;

			if( next_edge_no == edge_no )
				return;

			j_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , next_edge_no );
		}
		tmp_edge_no = next_edge_no + 1;
		if( next_edge_no < edge_no )
			next_search_start = NMG_TBL_END( int_faces );
		else
			next_search_start = tmp_edge_no;

		if( tmp_edge_no == NMG_TBL_END( int_faces ) )
			tmp_edge_no = 0;
		tmp_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , tmp_edge_no );
		while( tmp_fus->vp == j_fus->vp )
		{
			next_edge_no = tmp_edge_no;
			j_fus = tmp_fus;

			tmp_edge_no++;
			if( tmp_edge_no == NMG_TBL_END( int_faces ) )
				tmp_edge_no = 0;

			if( tmp_edge_no == edge_no )
				break;

			tmp_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , tmp_edge_no );
		}
rt_log( "Comparing edges %d and %d\n" , edge_no , next_edge_no );

		/* the first edge is at angle 2*pi, but since they should decrease,
		 * make it 0 when it's being compared to the final edge.
		 */
		if( next_edge_no == 0 )
			j_fus->angle = 0.0;

		/* get the angle between the two edges */
		diff = i_fus->angle - j_fus->angle;

		/* if greater than zero O.K., angles are decreasing.
		 * But if the angle is very big, we must be comparing 2*pi
		 * to an angle just greater than 0, which means the order is
		 * wrong
		 */
		if( diff >= 0.0 && diff < three_halves_pi )
			continue;

		if( next_edge_no < edge_no )
			next_search_start = NMG_TBL_END( int_faces );
		else
			next_search_start = next_edge_no + 1;

		/* fuse the intersection points for these two edges */
rt_log( "Fusing intersection points ( %f %f %f ) and ( %f %f %f )\n" , V3ARGS( i_fus->pt ) , V3ARGS( j_fus->pt ) );

		/* get intersect line for planes on either side of this one */
		fu1 = i_fus->fu[0];
		if( fu1->orientation != OT_SAME )
			fu1 = fu1->fumate_p;
		fu2 = j_fus->fu[1];
		if( fu2->orientation != OT_SAME )
			fu2 = fu2->fumate_p;

		NMG_GET_FU_PLANE( pl1 , fu1 );
		NMG_GET_FU_PLANE( pl2 , fu2 );

		if( rt_isect_2planes( start , dir , pl1 , pl2 , i_fus->pt , &tol_tmp ) )
			continue;

		max_dist = (-MAX_FASTF);

		for( face_no=0 ; face_no < NMG_TBL_END( faces ) ; face_no++ )
		{
			struct face *fp;
			plane_t pl;
			fastf_t dist;

			fp = (struct face *)NMG_TBL_GET( faces , face_no );

			/* don't consider planes that this edge lies in */
			if( i_fus->fu[0]->f_p == fp || i_fus->fu[1]->f_p == fp )
				continue;

			/* intersect plane edge line */
			if( rt_isect_line3_plane( &dist , start , dir , fp->fg_p->N , tol ) < 1 )
				continue;

			if( dist > max_dist )
				max_dist = dist;
		}

		VJOIN1( new_pt , start , max_dist , dir );
		new_angle = (i_fus->angle > j_fus->angle ? i_fus->angle : j_fus->angle);
rt_log( "\tto ( %f %f %f )\n" , V3ARGS( new_pt ) );

		VMOVE( i_fus->vp->vg_p->coord , new_pt );

		tmp_edge_no = edge_no;
		while( tmp_edge_no != next_edge_no )
		{
			struct vertex *old_vp;
			int j;

			tmp_edge_no++;
			if( tmp_edge_no == NMG_TBL_END( int_faces ) )
				tmp_edge_no = 0;

			tmp_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , tmp_edge_no );
			old_vp = tmp_fus->vp;
			for( j=0 ; j<NMG_TBL_END( int_faces ) ; j++ )
			{
				j_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , j );
				if( j_fus->vp == old_vp )
				{
rt_log( "\t\tMoving vertex x%x ( %f %f %f ) to new point\n" , j_fus->vp , V3ARGS( j_fus->vp->vg_p->coord ) );
					j_fus->vp = i_fus->vp;
					VMOVE( j_fus->pt , new_pt );
				}
			}

			nmg_jv( i_fus->vp , old_vp );
		}
	}
}

a3595 1
rt_log( "nmg_split_edges_at_pts:\n" );
d3598 1
d3600 1
a3600 2
nmg_pr_inter( new_v , int_faces );

d3617 1
a3618 1
		/* Look for a vertex already assigned the geometry for i_fus->pt */
a3637 1
rt_log( "Calling nmg_esplit( vp = x%x, eu = x%x )\n", i_fus->vp , i_fus->eu );
d3640 1
a3640 1
rt_log( "\tAfter Calling nmg_esplit: i_fus->eu = x%x (x%x) , x%x to x%x\n" , i_fus->eu , i_fus->eu->eumate_p , i_fus->eu->vu_p->v_p , i_fus->eu->eumate_p->vu_p->v_p );
a3659 4
rt_log( "\tKilling crack at eu's x%x and x%x\n" , eu1 , eu2 );
rt_log( "\t\tmates are x%x and x%x\n" , eu1->eumate_p , eu2->eumate_p );
rt_log( "\t\ti_fus->eu = x%x, mate = x%x\n" , i_fus->eu , i_fus->eu->eumate_p );

d3666 1
a3666 1

a3667 1
		{
a3668 2
rt_log( "\tSetting v x%x to ( %f %f %f )\n" , i_fus->vp , V3ARGS( i_fus->pt ) );
		}
d3670 1
a3670 1
nmg_pr_inter( new_v , int_faces );
d3681 1
d3688 3
d3694 1
d3707 4
d3715 1
d3717 3
a3723 3

nmg_plot_inter( new_v , int_faces );
nmg_pr_inter( new_v , int_faces );
a3740 1
	struct nmg_ptbl new_faces;
a3742 1
	int added_faces=0;
d3745 2
a3746 1
rt_log( "nmg_make_faces_at_vert x%x ( %f %f %f )\n", new_v , V3ARGS( new_v->vg_p->coord ) );
d3761 3
a3763 1
		/* only one intersect point is left, move new_v to it */
d3765 1
a3765 1
rt_log( "only one intersect point, joining x%x to x%x at ( %f %f %f )\n" , i_fus->vp , new_v , V3ARGS( i_fus->vp->vg_p->coord ) );
d3777 1
a3777 1
		 * the connecting line
a3785 2
rt_log( "only two intersect points left, move vertex x%x to center point ( %f %f %f )\n" , new_v , V3ARGS( center_pt ) );

a3789 2
	nmg_tbl( &new_faces , TBL_INIT , (long *)NULL );

a3814 1
rt_log( "\tLooking at x%x, x%x, and x%x\n" , new_v , i_fus->vp , j_fus->vp );
d3832 2
a3833 2
rt_log( "\t( %f %f %f ), ( %f %f %f ), ( %f %f %f )\n" , V3ARGS( new_v->vg_p->coord ),
	V3ARGS( i_fus->vp->vg_p->coord ), V3ARGS( j_fus->vp->vg_p->coord ) );
d3835 12
a3851 1
rt_log( "\t\tFuse the inersect points\n" );
a3860 2
				struct edgeuse *eu;

d3874 1
d3876 22
a3903 1
			struct vertex *set_i_to_null,*set_j_to_null;
d3910 1
a3910 1
rt_log( "\t\tPoints are collinear\n" );
a3916 1
rt_log( "\t\t\tdiff_dist = %f, i_dist = %f, j_dist = %f, tol->dist_sq = %f\n" , diff_dist, i_dist, j_dist, tol->dist_sq );
d3923 2
a3924 3
				old_vp = i_fus->vp;
				new_vp = j_fus->vp;
rt_log( "\t\tFusing x%x and x%x\n" , old_vp , new_vp );
a3929 2
					struct edgeuse *eu;

d3943 1
d3945 2
d3948 20
d3974 1
a3974 1
rt_log( "\t\tFusing x%x and x%x\n" , i_fus->vp , new_v );
d3977 1
d3979 22
d4007 1
a4007 1
rt_log( "\t\tFusing x%x and x%x\n" , j_fus->vp , new_v );
d4010 1
d4012 22
d4040 1
a4040 1
rt_log( "\t\ti_dist > j_dist\n" );
a4043 2
				{
rt_log( "\t\tsplitting eu x%x at vp x%x\n" , i_fus->eu , j_fus->vp );
d4045 22
a4066 1
				}
d4074 1
a4074 1
rt_log( "j_dist > i_dist\n" );
a4077 2
				{
rt_log( "\t\tsplitting eu x%x at x%x\n" , j_fus->eu , i_fus->vp );
d4079 22
a4100 1
				}
a4108 1
				struct edgeuse *eu;
d4111 1
a4111 1
				vu_next = RT_LIST_PNEXT( vertexuse , &vu->l );
d4113 2
d4116 1
d4118 7
d4134 22
d4159 2
a4160 2
		/* O.K., here is where we actually start making faces */
rt_log( "Ready to make face: vertices are x%x, x%x, and x%x\n" , new_v , i_fus->vp , j_fus->vp );
d4162 2
a4163 1
		/* find uses of the two vertices in the same loopuse */
d4165 20
d4191 4
d4215 1
d4217 4
a4220 1
		if( vu2 == NULL )
d4222 12
a4233 1
rt_log( "\t\tCan't find loop containing vertices x%x and x%x\n" , i_fus->vp, j_fus->vp );
d4238 16
a4254 2
rt_log( "Cutting lu (x%x) at vu's x%x and x%x:\n" , old_lu , vu1 , vu2 );
nmg_pr_lu_briefly( old_lu , (char *)NULL );
a4255 13
		/* recalculate loop geometry */
		nmg_face_bb( fu->f_p , tol );
rt_log( "After cutting loop, new_lu = x%x\n" , new_lu );
{
	struct vertexuse *vu;
for( RT_LIST_FOR( vu , vertexuse , &vu1->v_p->vu_hd ) )
{
	eu = vu->up.eu_p;
	if( eu->eumate_p->vu_p->v_p == vu2->v_p )
		break;
}
nmg_pr_fu_around_eu( eu , tol );
}
d4257 4
a4260 16
		/* fix orientations */
#if 0
		for( RT_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
		{
			if( lu->orientation == OT_UNSPEC )
			{
				lu->orientation = OT_SAME;
				lu->lumate_p->orientation = OT_SAME;
			}
		}
#endif
#if 0
		nmg_lu_reorient( new_lu , tol );
		nmg_lu_reorient( old_lu , tol );
#endif

a4264 4
#if 0
		{
			int ccw;
			vect_t norm;
a4265 40
			NMG_GET_FU_NORMAL( norm , fu );

			ccw = nmg_loop_is_ccw( new_lu , norm , tol );
			if( ccw > 0 )
			{
				new_lu->orientation = OT_SAME;
				new_lu->lumate_p->orientation = OT_SAME;
			}
			else if( ccw < 0 )
			{
				new_lu->orientation = OT_OPPOSITE;
				new_lu->lumate_p->orientation = OT_OPPOSITE;
			}
			else
			{
				rt_log( "Can't determine orientation of new_lu x%x\n" , new_lu );
				new_lu->orientation = OT_SAME;
				new_lu->lumate_p->orientation = OT_SAME;
			}

			ccw = nmg_loop_is_ccw( old_lu , norm , tol );
			if( ccw > 0 )
			{
				old_lu->orientation = OT_SAME;
				old_lu->lumate_p->orientation = OT_SAME;
			}
			else if( ccw < 0 )
			{
				old_lu->orientation = OT_OPPOSITE;
				old_lu->lumate_p->orientation = OT_OPPOSITE;
			}
			else
			{
				rt_log( "Can't determine orientation of old_lu x%x\n" , old_lu );
				old_lu->orientation = OT_SAME;
				old_lu->lumate_p->orientation = OT_SAME;
			}
		}
#endif

d4295 9
a4303 1
			rt_bomb( "nmg_complex_vertex_solve: can't find loop for new face\n" );
a4305 2
rt_log( "Make face from lu (x%x):\n" , lu );
nmg_pr_lu_briefly( lu , (char *)NULL );
d4313 2
a4314 1
			rt_log( "Failed to calculate plane eqn for face:\n " );
a4317 24
		/* make sure new_fu has orientation compatible with its radial faces */
		lu = RT_LIST_FIRST( loopuse , &new_fu->lu_hd );
		for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
		{
			struct edgeuse *eu_radial;

			eu_radial = eu->radial_p;
			fu = nmg_find_fu_of_eu( eu_radial );
			if( fu == new_fu )
				continue;

			if( fu->orientation != new_fu->orientation )
			{
				nmg_reverse_face( new_fu );
rt_log( "reversing orientation of fu x%x\n" , new_fu );
			}
			break;
		}


		/* Add it to the list */
		nmg_tbl( &new_faces , TBL_INS , (long *)new_fu );
		added_faces++;

a4319 6
	if( NMG_TBL_END( &new_faces ) )
	{
		/* glue the new faces together */
		nmg_gluefaces( (struct faceuse **)NMG_TBL_BASEADDR( &new_faces) , NMG_TBL_END( &new_faces ) );
		nmg_tbl( &new_faces , TBL_FREE , (long *)NULL );
	}
d4322 6
a4333 2
rt_log( "nmg_kill_cracks_at_vertex( x%x )\n" , vp );

d4336 1
d4345 1
d4348 1
d4350 2
d4362 2
d4370 2
d4383 1
a4383 1
					 * valid use of vp will be after kilings
a4391 1
rt_log( "\tKilling eu's x%x (x%x ) and x%x (x%x)\n" , eu_prev , eu_prev->eumate_p , eu , eu->eumate_p );
d4393 1
a4412 1
rt_log( "\t\tKilling empty loopuse x%x\n" , lu );
a4422 2
		{
rt_log( "\t\t\tKilling empty faceuse x%x\n" , fu );
a4423 1
		}
d4429 24
a4452 257
void
nmg_fix_edges( new_v , int_faces , faces , tol )
CONST struct vertex *new_v;
struct nmg_ptbl *int_faces;
CONST struct nmg_ptbl *faces;
CONST struct rt_tol *tol;
{
	int edge_no;
	struct rt_tol tol_tmp;

	/* A local tolerance structure for times when I don't want tolerancing */
	tol_tmp.magic = RT_TOL_MAGIC;
	tol_tmp.dist = SQRT_SMALL_FASTF;
	tol_tmp.dist_sq = SMALL_FASTF;
	tol_tmp.perp = 0.0;
	tol_tmp.para = 1.0;

rt_log( "nmg_fix_edges( new_v = x%x )\n" , new_v );

	NMG_CK_VERTEX( new_v );
	RT_CK_TOL( tol );

	/* first simplify the int_faces table by removing any entries
	 * that represent non-faces
	 */
	for( edge_no=0 ; edge_no<NMG_TBL_END( int_faces ) ; edge_no++ )
	{
		struct intersect_fus *i_fus,*j_fus;
		int next_edge_no;

		i_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , edge_no );

		next_edge_no = edge_no + 1;
		if( next_edge_no == NMG_TBL_END( int_faces ) )
			next_edge_no = 0;

		j_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , next_edge_no );

		if( i_fus->vp != j_fus->vp )
			continue;

		i_fus->fu[1] = j_fus->fu[1];
		nmg_tbl( int_faces , TBL_RM , (long *)j_fus );
	}

	edge_no = 0;
	while( edge_no < NMG_TBL_END( int_faces ) )
	{
		struct intersect_fus *i_fus,*j_fus;
		struct vertex *new_vp,*old_vp;
		plane_t pl1,pl2;
		point_t start;
		vect_t dir;
		point_t new_pt;
		vect_t old_edge_vec;
		fastf_t old_edge_len_sq;
		fastf_t dist,max_dist;
		int next_edge_no;
		int class1,class2;
		int face_no;
		int tmp_edge_no;

		i_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , edge_no );

		next_edge_no = edge_no + 1;
		if( next_edge_no == NMG_TBL_END( int_faces ) )
			next_edge_no = 0;

		j_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , next_edge_no );

		NMG_GET_FU_PLANE( pl1 , i_fus->fu[0] );
		NMG_GET_FU_PLANE( pl2 , j_fus->fu[1] );

		/* get definition of possible new edge */
		if( rt_isect_2planes( start , dir , pl1 , pl2 , i_fus->pt , tol ) )
		{
			edge_no++;
			continue;
		}

		/* if the start point of the new edge line is within both
		 * faces, then the two edges get replaced by one
		 */
		class1 = nmg_class_pt_f( start , i_fus->fu[0] , tol );
		class2 = nmg_class_pt_f( start , j_fus->fu[1] , tol );
		if( class1 != class2 )
			rt_log( "class1 = %s , class2 = %s\n" , nmg_class_name( class1 ) , nmg_class_name( class2 ) );
		if( class1 == NMG_CLASS_AoutB || class2 == NMG_CLASS_AoutB )
		{
			edge_no++;
			continue;
		}

		/* Make sure the new egde direction is not reversed */
		if( VDOT( dir , i_fus->dir ) < 0.0 )
			VREVERSE( dir , dir );

		/* Find an intersection point for this new edge */
		VSUB2( old_edge_vec , i_fus->eu->eumate_p->vu_p->v_p->vg_p->coord , new_v->vg_p->coord );
		old_edge_len_sq = MAGSQ( old_edge_vec );

		max_dist = (-MAX_FASTF);

		/* find intersection with each face */
		for( face_no=0 ; face_no<NMG_TBL_END( faces ) ; face_no++ )
		{
			struct face *fp;
			struct faceuse *fu;
			plane_t pl;
			fastf_t dist;

			fp = (struct face *)NMG_TBL_GET( faces , face_no );
			fu = fp->fu_p;
			if( fu->orientation != OT_SAME )
				fu = fu->fumate_p;
			NMG_GET_FU_PLANE( pl , fu );
			
			/* don't consider planes that this edge lies in */
			if( i_fus->fu[0]->f_p == fp || j_fus->fu[1]->f_p == fp )
				continue;

			/* intersect plane edge line */
			if( rt_isect_line3_plane( &dist , i_fus->start , i_fus->dir , pl , tol ) < 1 )
				continue;

			/* if intersect point is more than halfway to the next vertex, this is likely
			 * a plane that is nearly parallel to the edge line
			 */
			if( 4.0*dist*dist > old_edge_len_sq )
				continue;

			if( dist > max_dist )
				max_dist = dist;
		}

		if( max_dist == (-MAX_FASTF))
			rt_log( "nmg_fix_edges: couldn't find intersection point for edge\n" );

		VJOIN1( new_pt , start , max_dist , dir );
rt_log( "\tfor edge start at ( %f %f %f ) in dir ( %f %f %f )\n" , V3ARGS( start ) , V3ARGS( dir ) );
rt_log( "\t\tintersect at ( %f %f %f )\n" , V3ARGS( new_pt ) );

		old_vp = j_fus->vp;
		new_vp = i_fus->vp;

		i_fus->fu[1] = j_fus->fu[1];
		nmg_tbl( int_faces , TBL_RM , (long *)j_fus );

rt_log( "\tAdjusting other ocurrences of vertex x%x\n" , old_vp );
		for( tmp_edge_no=0 ; tmp_edge_no< NMG_TBL_END( int_faces ) ; tmp_edge_no++ )
		{
			struct intersect_fus *tmp_fus;

			tmp_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , tmp_edge_no );

			if( tmp_fus->vp == old_vp )
			{
rt_log( "\tedge_no %d - Moving x%x to x%x\n" , tmp_edge_no , tmp_fus->vp , new_vp );
				tmp_fus->vp = new_vp;
				VMOVE( tmp_fus->pt , new_pt );
			}
		}
rt_log( "nmg_jv( x%x , x%x )\n" , new_vp , old_vp );
		nmg_jv( new_vp , old_vp );
	}
}

void
nmg_fix_intersects_on_lines( int_faces , tol )
CONST struct nmg_ptbl *int_faces;
CONST struct rt_tol *tol;
{
	int edge_no;

	RT_CK_TOL( tol );

rt_log( "nmg_fix_intersects_on_lines\n" );

	for( edge_no=0 ; edge_no<NMG_TBL_END( int_faces ) ; edge_no++ )
	{
		int next_edge_no;
		struct intersect_fus *i_fus,*next_fus;
		struct vertexuse *vu;

		next_edge_no = edge_no + 1;
		if( next_edge_no == NMG_TBL_END( int_faces ) )
			next_edge_no = 0;

		i_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , edge_no );
		next_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , next_edge_no );

		/* check if i_fus->vp is on an edge containing next_fus->vp */
		for( RT_LIST_FOR( vu , vertexuse , &next_fus->vp->vu_hd ) )
		{
			struct edgeuse *eu;
			struct vertex *v1,*v2;
			int isect_ret_val;
			fastf_t dist;

			if( *vu->up.magic_p != NMG_EDGEUSE_MAGIC )
				continue;

			eu = vu->up.eu_p;
			NMG_CK_EDGEUSE( eu );
			v1 = eu->vu_p->v_p;
			NMG_CK_VERTEX( v1 );
			v2 = eu->eumate_p->vu_p->v_p;
			NMG_CK_VERTEX( v2 );

			if( i_fus->vp == v1 || i_fus->vp == v2 )
				continue;

			if( rt_isect_pt_lseg( &dist , v1->vg_p->coord , v2->vg_p->coord ,
						i_fus->vp->vg_p->coord , tol ) != 3 )
				continue;
rt_log("\tspliting eu x%x ( %f %f %f ) -> ( %f %f %f )\n\t\tat vertex x%x ( %f %f %f )\n" ,
eu , V3ARGS( eu->vu_p->v_p->vg_p->coord ) , V3ARGS( eu->eumate_p->vu_p->v_p->vg_p->coord ),
i_fus->vp , V3ARGS( i_fus->vp->vg_p->coord ) );

			(void)nmg_esplit( i_fus->vp , eu );

		}

		/* check if next_fus->vp is on an edge containing i_fus->vp */
		for( RT_LIST_FOR( vu , vertexuse , &i_fus->vp->vu_hd ) )
		{
			struct edgeuse *eu;
			struct vertex *v1,*v2;
			int isect_ret_val;
			fastf_t dist;

			if( *vu->up.magic_p != NMG_EDGEUSE_MAGIC )
				continue;

			eu = vu->up.eu_p;
			NMG_CK_EDGEUSE( eu );
			v1 = eu->vu_p->v_p;
			NMG_CK_VERTEX( v1 );
			v2 = eu->eumate_p->vu_p->v_p;
			NMG_CK_VERTEX( v2 );

			if( next_fus->vp == v1 || next_fus->vp == v2 )
				continue;

			if( rt_isect_pt_lseg( &dist , v1->vg_p->coord , v2->vg_p->coord ,
						next_fus->vp->vg_p->coord , tol ) != 3 )
				continue;

rt_log("\tspliting eu x%x ( %f %f %f ) -> ( %f %f %f )\n\t\tat vertex x%x ( %f %f %f )\n" ,
eu , V3ARGS( eu->vu_p->v_p->vg_p->coord ) , V3ARGS( eu->eumate_p->vu_p->v_p->vg_p->coord ),
next_fus->vp , V3ARGS( next_fus->vp->vg_p->coord ) );
			(void)nmg_esplit( next_fus->vp , eu );

		}
	}
}

a4462 2
rt_log( "nmg_fix_crossed_loops:\n" );

d4464 1
d4493 2
a4494 1
rt_log( "Merging intersects at x%x and x%x\n" , old_vp , new_vp );
d4497 1
d4500 1
d4502 2
a4503 1
				if( prev_eu->vu_p->v_p != new_vp || j_fus->eu->eumate_p->vu_p->v_p != new_vp )
a4504 10
					rt_log( "nmg_fix_crossed_loops: Merged vertices didn't create crack at vertex x%x ( %f %f %f )\n" , new_vp , V3ARGS( new_vp->vg_p->coord ) );
					rt_log( "prev_eu->vu_p->v_p = x%x ( %f %f %f )\n" , prev_eu->vu_p->v_p , V3ARGS( prev_eu->vu_p->v_p->vg_p->coord ) );
					rt_log( "j_fus->eu->eumate_p->vu_p->v_p = x%x ( %f %f %f )\n" , j_fus->eu->eumate_p->vu_p->v_p , V3ARGS( j_fus->eu->eumate_p->vu_p->v_p->vg_p->coord ) );
				}
				else
				{
rt_log( "nmg_fix_crossed_loops: killing eu's x%x and x%x\n" , prev_eu , j_fus->eu );
rt_log( "\tmates are x%x and x%x\n" , prev_eu->eumate_p , j_fus->eu->eumate_p );
rt_log( "\tj_fus->eu = x%x, mate = x%x\n" , j_fus->eu , j_fus->eu->eumate_p );
rt_log( "\ti_fus->eu = x%x, mate = x%x\n" , i_fus->eu , i_fus->eu->eumate_p );
d4509 1
d4511 2
a4512 1
rt_log( "\tremoving j_fus x%x from table\n" , j_fus );
d4514 1
a4514 1
nmg_pr_inter( new_v , int_faces );
d4520 1
a4520 2
nmg_plot_inter( new_v , int_faces );

d4535 1
d4545 1
d4552 1
a4561 1

d4565 1
d4572 1
a4575 7
rt_log( "\tedges:\n" );
rt_log( "\tplane = ( %f %f %f )\n" , V4ARGS( pl ) );
rt_log( "\t\tstart = ( %f %f %f ), dir = ( %f %f %f )\n" , V3ARGS( i_start->vg_p->coord ) , V3ARGS( i_dir ) );
rt_log( "\t\t\t%f off plane, dir_dot_plane = %f\n" , DIST_PT_PLANE( i_start->vg_p->coord , pl ) , VDOT( i_dir , pl ) );
rt_log( "\t\tstart = ( %f %f %f ), dir = ( %f %f %f )\n" , V3ARGS( j_start->vg_p->coord ) , V3ARGS( j_dir ) );
rt_log( "\t\t\t%f off plane, dir_dot_plane = %f\n" , DIST_PT_PLANE( j_start->vg_p->coord , pl ) , VDOT( j_dir , pl ) );

d4581 1
a4581 1
rt_log( "\t\t\tno intersection, ret_val = %d\n" , ret_val );
a4593 1
rt_log( "\t\t\tret_val = %d\n" , ret_val );
a4597 1
#if 1
a4604 8
#else
			VADD2( ave_dir , i_fus->dir , j_fus->dir );
			if( rt_isect_2planes( i_fus->start , i_fus->dir , pl1 , pl3 , new_v->vg_p->coord , &tol_tmp ) )
			{
				rt_log( "nmg_fix_crossed_edges: Cannot find new edge line\n" );
				edge_no++;
				continue;
			}
d4606 3
a4608 11
			/* make sure edge direction is not reversed */
			if( VDOT( ave_dir , i_fus->dir ) < 0.0 )
				VREVERSE( i_fus->dir , i_fus->dir );

			/* Make the start point at closest approach to new vertex */
			(void)rt_dist_pt3_line3( &tmp_dist , i_fus->start , i_fus->start , i_fus->dir , new_v->vg_p->coord , &tol_tmp );

			VJOIN1( new_pt , i_fus->start , edge_dist , i_fus->dir );
#endif
rt_log( "\t\t\tnew_point = ( %f %f %f )\n" , V3ARGS( new_pt ) );

d4614 2
d4618 2
a4619 2
nmg_plot_inter( new_v , int_faces );
nmg_pr_inter( new_v , int_faces );
a4689 1
#if 0
a4690 7
	 * at a distnace of (for now) 3.0 mm
	 */
	nmg_get_edge_inters( new_v , 3.0 , &int_faces );

#endif

	/* fill in "pt" portion of intersect_fus structures with points
a4701 20

nmg_plot_inter( new_v , &int_faces );

#if 0
	/* get the average outward pointing normal at this vertex */
	nmg_calc_ave_norm( ave_norm , faces );

	/* calculate the angles at which the edges depart the vertex */
	nmg_calc_edge_angles( &int_faces , ave_norm , new_v , tol );

	/* Now make sure they are in decreasing order.
	 * If not, fuse the intersection points
	 */
	nmg_fuse_crossed_edges( &int_faces , faces , tol );

	nmg_fix_edges( new_v , &int_faces , faces , tol );
	nmg_fix_intersects_on_lines( &int_faces , tol );
	nmg_kill_cracks_at_vertex( new_v );

#endif
@


1.111
log
@checkpoint
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.110 94/02/10 18:47:46 mike Exp Locker: jra $ (ARL)";
d3103 35
d3156 2
d3229 2
d3271 1
d3278 3
d3282 2
a3283 4
		NMG_GET_FU_NORMAL( normal1 , fu1 );
		/* find the new edge line at the intersection of these two faces
		 * the line is defined by start and dir */
		if( ret_val=rt_isect_2planes( start , dir , fu1->f_p->fg_p->N , fu2->f_p->fg_p->N , new_v->vg_p->coord , &tol_tmp ) )
d3285 5
a3289 1
			if( ret_val == (-1) )
d3291 1
a3291 38
				/* faces are coplanar */
				VMOVE( dir , eu_dir );
				VUNITIZE( dir );
				if( rt_isect_line3_plane( &dist , new_v->vg_p->coord , fu1->f_p->fg_p->N , fu2->f_p->fg_p->N , &tol_tmp ) < 1 )
				{
					rt_log( "nmg_inside_vert: Cannot find new edge between two identical planes\n" );
					continue;
				}
				VJOIN1( start , new_v->vg_p->coord , dist , normal1 );
			}
			else if( ret_val == (-2) )
			{
				/* faces are parallel but distinct */
				plane_t plane1,plane2;
				vect_t v1,v2;
				point_t p1,p2;
				fastf_t dist2[2];

				NMG_GET_FU_PLANE( plane2 , fu2 );
				NMG_GET_FU_PLANE( plane1 , fu1 );
				rt_log( "\nplanes are parallel and distinct at ( %f %f %f )\n" , V3ARGS( eu->vu_p->v_p->vg_p->coord ) );
				rt_log( "dot product of normals = %g\n" , VDOT( normal1 , plane2 ) );
				rt_log( "tol->para = %g\n" , tol->para );
				VCROSS( dir , normal1 , plane2 );
				rt_log( "cross_product of normals = ( %g %g %g )\n" , V3ARGS( dir ) );
				rt_log( "length of dir = %g\n" , MAGNITUDE( dir ) );
				VUNITIZE( dir );
				rt_log( "unitized cross_product of normals = ( %f %f %f )\n" , V3ARGS( dir ) );
				VSUB2( v1 , eu->eumate_p->vu_p->v_p->vg_p->coord , eu->vu_p->v_p->vg_p->coord );
				VUNITIZE( v1 );
				rt_log( "direction of old edge = ( %f %f %f )\n" , V3ARGS( v1 ) );
				VCROSS( v1 , dir , plane1 );
				VUNITIZE( v1 );
				VSCALE( p1 , plane1 , plane1[3] );
				VCROSS( v2 , dir , plane2 );
				VUNITIZE( v2 );
				VSCALE( p2 , plane2 , plane2[3] );
				ret_val = rt_isect_line2_line2( dist2 , p1 , v1 , p2 , v2 , &tol_tmp );
d3294 9
a3302 2
					rt_log( "No intersection\n" );
					return( 1 );
d3304 1
a3304 1
				else if( ret_val == 0 )
d3306 41
a3346 2
					rt_log( "Lines are collinear\n" );
					return( 1 );
a3347 5
				else if( ret_val == 1 )
				{
					VJOIN1( start , p1 , dist2[0] , v1 );
					rt_log( "intersection is at ( %f %f %f )\n" , V3ARGS( start ) );
				}
d3349 8
a3357 2
		/* Make the start point at closest approach to old vertex */
		(void)rt_dist_pt3_line3( &dist , start , start , dir , new_v->vg_p->coord , &tol_tmp );
a3358 6
		/* Make sure the calculated direction is away from the vertex */
		if( VDOT( eu_dir , dir ) < 0.0 )
			VREVERSE( dir , dir );
		VMOVE( i_fus->start , start );
		VMOVE( i_fus->dir , dir );

d3388 1
d3406 2
a3407 2
		struct intersect_fus *i_fus;
		fastf_t max_dist,backup_max_dist;
d3410 3
a3412 1
		int face_no;
d3414 1
a3414 1
		i_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , edge_no );
d3416 43
a3458 1
		VSUB2( old_edge_vec , i_fus->eu->eumate_p->vu_p->v_p->vg_p->coord , new_v->vg_p->coord );
a3461 1
		backup_max_dist = MAX_FASTF;
d3463 2
a3464 2
		/* find intersection with each face */
		for( face_no=0 ; face_no<NMG_TBL_END( faces ) ; face_no++ )
a3465 1
			struct face *fp;
d3470 1
a3470 2
			fp = (struct face *)NMG_TBL_GET( faces , face_no );
			fu = fp->fu_p;
a3474 4
			/* don't consider planes that this edge lies in */
			if( i_fus->fu[0]->f_p == fp || i_fus->fu[1]->f_p == fp )
				continue;

d3476 1
a3476 1
			if( rt_isect_line3_plane( &dist , i_fus->start , i_fus->dir , pl , tol ) < 1 )
a3495 2
			rt_log( "Using backup distance: %f\n" , backup_max_dist );
			max_dist = backup_max_dist;
d3498 3
a3500 3
		VJOIN1( i_fus->pt , i_fus->start , max_dist , i_fus->dir );
rt_log( "\tfor edge start at ( %f %f %f ) in dir ( %f %f %f )\n" , V3ARGS( i_fus->start ) , V3ARGS( i_fus->dir ) );
rt_log( "\t\tdist = %f, intersect at ( %f %f %f )\n" , max_dist , V3ARGS( i_fus->pt ) );
d3502 2
a3503 1
		VADD2( ave_pt , ave_pt , i_fus->pt );
d3506 1
a3506 1
	VSCALE( ave_pt , ave_pt , 1.0/((double)(NMG_TBL_END( int_faces ))) );
d3889 1
d3893 2
d3903 1
d3907 4
d3913 2
a3914 1
		for( j=0 ; j<edge_no ; j++ )
d3918 2
a3919 2
			tmp_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , j );
			if( tmp_fus->vp )
d3921 4
a3924 8
				if( rt_pt3_pt3_equal( tmp_fus->pt , i_fus->pt , tol ) )
				{
					/* found a match, use this vertex */
					re_use_vp = tmp_fus->vp;
					i_fus->vp = tmp_fus->vp;
					VMOVE( i_fus->pt , tmp_fus->pt );
					break;
				}
d3932 1
a3932 2
rt_log( "Calling nmg_esplit( vp = x%x, eu = x%x )\n\ti_fus->eu->vu_p->v_p = x%x, i_fus->eu->eumate_p->vu_p->v_p = x%x\n",
i_fus->vp , i_fus->eu , i_fus->eu->vu_p->v_p , i_fus->eu->eumate_p->vu_p->v_p );
d3935 1
d3956 2
d3972 8
d3981 35
a4015 1
	nmg_plot_inter( new_v , int_faces );
d4039 1
a4039 1
rt_log( "nmg_make_faces_at_vert ( %f %f %f )\n" , V3ARGS( new_v->vg_p->coord ) );
d4050 33
d4231 1
a4231 1
				nmg_complex_jv( j_fus->vp , new_v );
d4357 2
a4358 1
#else
d4363 49
d4448 2
d4497 2
d4548 1
d4569 1
d4581 1
d4902 3
d4910 1
d4912 1
d5001 1
a5001 1
#if 0
d5037 1
d5108 1
a5108 1
#if 1
d5114 1
a5114 1
#else
a5122 1
#endif
@


1.110
log
@Changed from EUPRINT to nmg_euprint() call.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.109 94/02/10 16:32:16 jra Exp Locker: mike $ (ARL)";
d3102 67
d3357 1
a3357 1
		fastf_t max_dist;
d3368 1
d3391 1
a3391 1

d3396 3
d3400 2
a3401 1

d3407 1
d3409 3
d3415 1
a3415 1
rt_log( "\t\tintersect at ( %f %f %f )\n" , V3ARGS( i_fus->pt ) );
a3465 1
		VADD2( ave_pt , ave_pt , i_fus->start );
d3471 1
d3797 2
a3798 1
nmg_split_edges_at_pts( int_faces , tol )
d3802 1
a3802 1
	int i,j;
d3806 1
a3806 1
	for( i=0 ; i<NMG_TBL_END( int_faces ) ; i++ )
d3813 1
d3815 1
a3815 1
		i_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , i );
d3817 1
d3819 1
a3819 1
		for( j=0 ; j<i ; j++ )
d3829 1
d3839 1
a3839 1
			i_fus->vp != i_fus->eu->eumate_p->vu_p->v_p ))
d3843 28
a3870 2
				new_eu = nmg_esplit( i_fus->vp , i_fus->eu );
				i_fus->vp = new_eu->vu_p->v_p;
d3879 2
d3902 1
a3902 1
	int i,j;
d3923 1
a3923 1
	for( i=0 ; i<NMG_TBL_END( int_faces ) ; i++ )
d3937 6
a3942 5
		i_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , i );
		j = i+1;
		if( j == NMG_TBL_END( int_faces ) )
			 j = 0;
		j_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , j );
d3946 2
d3949 1
d3953 2
d3956 1
d3960 2
d3968 1
a3970 1
			nmg_jv( j_fus->vp , i_fus->vp );
d3973 1
a3973 2
			i_fus->vp = j_fus->vp;
			i_fus->eu = NULL;
d3991 2
a3993 8
			/* make sure any other vertex pointers don't reference the now
			 * defunct vertex */
			for( j=0 ; j<NMG_TBL_END( int_faces ) ; j++ )
			{
				j_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , j );
				if( j_fus->vp == old_vp )
					j_fus->vp = new_vp;
			}
d4007 1
a4007 1

d4014 1
d4016 1
a4016 1
			if( diff_dist < tol->dist_sq && j_fus->vp )
d4020 1
a4020 2
				/* i and j points are within tolerance, fuse them */
				nmg_jv( j_fus->vp , i_fus->vp );
d4023 2
a4024 1
				i_fus->vp = j_fus->vp;
d4042 3
a4045 8
				/* make sure any other vertex pointers don't reference the now
				 * defunct vertex */
				for( j=0 ; j<NMG_TBL_END( int_faces ) ; j++ )
				{
					j_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , j );
					if( j_fus->vp == old_vp )
						j_fus->vp = new_vp;
				}
d4047 1
a4047 1
			if( i_dist < tol->dist_sq && i_fus->vp )
d4052 4
a4055 3
				nmg_jv( new_v , i_fus->vp );
				set_i_to_null = i_fus->vp;
				i_fus->vp = NULL;
d4057 1
a4057 1
			if( j_dist < tol->dist_sq && j_fus->vp )
d4062 4
a4065 3
				nmg_jv( new_v , j_fus->vp );
				set_j_to_null = j_fus->vp;
				j_fus->vp = NULL;
d4067 1
a4067 1
			if( i_dist > j_dist && j_fus->vp && i_fus->eu )
d4072 1
d4076 2
d4079 2
d4082 1
a4082 1
			else if( j_dist > i_dist && i_fus->vp && j_fus->eu )
d4087 1
d4091 2
d4094 2
a4118 6
			for( j=0 ; j<NMG_TBL_END( int_faces ) ; j++ )
			{
				j_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , j );
				if( j_fus->vp == set_i_to_null || j_fus->vp == set_j_to_null )
					j_fus->vp = NULL;
			}
d4123 1
d4125 1
a4125 5
		fu = i_fus->fu[1];
		if( fu->orientation != OT_SAME )
			fu = fu->fumate_p;
		/* put this face on the "new_faces" list for glueing */
		nmg_tbl( &new_faces , TBL_INS , (long *)fu );
d4127 2
a4128 2
		/* find uses of the two vertices in the same loopuse */
		for( RT_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
d4130 4
a4133 1
			if( RT_LIST_FIRST_MAGIC(&lu->down_hd) != NMG_EDGEUSE_MAGIC )
d4136 1
a4136 9
			vu1 = (struct vertexuse *)NULL;
			for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
			{
				if( eu->vu_p->v_p == i_fus->vp )
				{
					vu1 = eu->vu_p;
					break;
				}
			}
d4138 3
a4140 1
			vu2 = (struct vertexuse *)NULL;
d4149 1
a4149 2

			if( vu1 && vu2 )
d4154 4
a4157 1
		if( vu1 == NULL || vu2 == NULL )
d4159 1
d4260 2
d4621 196
d4877 1
a4877 1
#if 0
d4894 1
a4894 1
	nmg_split_edges_at_pts( &int_faces , tol );
d4896 5
a4911 1
#else
d4914 1
a4914 1
/*	nmg_fix_intersects_on_lines( &int_faces , tol );	*/
@


1.109
log
@Checkpoint
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.108 94/02/09 18:21:53 jra Exp Locker: jra $ (ARL)";
d2911 2
a2912 2
		EUPRINT("\tJoining", eu1);
		EUPRINT("\t     to", eu2);
@


1.108
log
@Checkpoint.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.107 94/02/09 11:02:14 jra Exp Locker: jra $ (ARL)";
d2646 1
a2646 1
	if( free_edges > 1 && NMG_TBL_END( faces ) > 3 )
d2726 21
a3292 3
		struct edgeuse *radial,*prev;
		struct faceuse *fu_of_radial;
		vect_t norm;
a3293 1
		int isect_ret;
a3296 13
		prev = RT_LIST_PPREV_CIRC( edgeuse , i_fus->eu );
		radial = prev->radial_p;
		fu_of_radial = nmg_find_fu_of_eu( radial );
		if( fu_of_radial->orientation != OT_SAME )
			fu_of_radial = fu_of_radial->fumate_p;
		NMG_GET_FU_NORMAL( norm , fu_of_radial );
		if( VDOT( norm , i_fus->dir ) > 0.0 )
			isect_ret = 2;
		else
			isect_ret = 1;

rt_log( "isect_ret = %d\n" , isect_ret );

a3308 1
			int ret_val;
d3321 1
a3321 3
			if( (ret_val=rt_isect_line3_plane( &dist , i_fus->start , i_fus->dir , pl , tol )) != isect_ret )
			{
rt_log( "\tskipping ret val of %d\n" , ret_val );
a3322 2
			}
rt_log( "\tret_val = %d\n" , ret_val );
a3718 2
 * returns:
 *	the number of unique vertex pointer created
d3720 1
a3720 1
int
d3725 1
a3725 1
	int i,j,unique_verts=0;
d3739 1
d3749 1
d3756 2
d3761 1
a3761 1
rt_log( "Calling nmg_esplit( vp = x%x , eu = x%x ), i_fus->eu->vu_p->v_p = x%x, i_fus->eu->eumate_p->vu_p->v_p = x%x\n",
d3764 1
a3766 4
		if( !i_fus->vp )
		{
			i_fus->vp = new_eu->vu_p->v_p;
		}
d3770 1
a3770 1
			unique_verts++;
a3772 1
	return( unique_verts );
d3884 1
d4056 2
d4081 2
a4082 2
		nmg_lu_reorient( new_lu , &tol_tmp );
		nmg_lu_reorient( old_lu , &tol_tmp );
d4161 2
a4162 2
nmg_kill_cracks_at_vert( int_faces )
CONST struct nmg_ptbl *int_faces;
d4164 1
a4164 1
	int i;
d4166 4
a4169 1
	for( i=0 ; i<NMG_TBL_END( int_faces ) ; i++ )
a4170 1
		struct intersect_fus *i_fus;
d4173 1
d4176 3
a4178 2
		i_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , i );
		fu = i_fus->fu[0];
d4204 12
d4248 2
d4270 2
d4275 23
d4302 8
a4309 1
		fastf_t i_dist,j_dist;
d4311 2
a4312 1
		plane_t pl1,pl2;
a4313 2
		struct vertex *old_vp,*new_vp;
		point_t new_pt;
a4314 2
		old_vp = (struct vertex *)NULL;

a4316 2
		NMG_GET_FU_PLANE( pl1 , i_fus->fu[0] );

d4323 1
d4326 6
a4331 2
		i_dist = DIST_PT_PLANE( i_fus->vp->vg_p->coord , pl2 );
		j_dist = DIST_PT_PLANE( j_fus->vp->vg_p->coord , pl1 );
d4333 8
a4340 1
		if( i_dist < (-tol->dist ) && NEAR_ZERO( j_dist , tol->dist ) )
d4342 2
a4343 3
			old_vp = i_fus->vp;
			new_vp = j_fus->vp;
			VMOVE( new_pt , j_fus->vp->vg_p->coord );
d4345 13
a4357 1
		else if( j_dist < (-tol->dist) && NEAR_ZERO( i_dist , tol->dist ) )
d4359 27
a4385 3
			old_vp = j_fus->vp;
			new_vp = i_fus->vp;
			VMOVE( new_pt , i_fus->vp->vg_p->coord );
d4387 16
a4402 1
		else if( i_dist < (-tol->dist) && j_dist < (-tol->dist ) )
d4404 1
a4404 2
			point_t start;
			vect_t dir;
d4406 3
a4408 2
			/* calculate new edge line geometry */
			if( rt_isect_2planes( start , dir , pl1 , pl2 , new_v->vg_p->coord , &tol_tmp ) )
d4410 3
a4412 1
				rt_log( "nmg_fix_edges: couldn't find new edge geometry\n" );
d4414 5
a4418 6
			else
			{
				fastf_t old_edge_len_sq;
				vect_t old_edge_vec;
				fastf_t max_dist;
				int face_no;
d4420 6
a4425 2
				VSUB2( old_edge_vec , i_fus->eu->vu_p->v_p->vg_p->coord , i_fus->eu->eumate_p->vu_p->v_p->vg_p->coord );
				old_edge_len_sq = MAGSQ( old_edge_vec );
d4427 1
a4427 1
				max_dist = (-MAX_FASTF);
d4429 1
a4429 5
				for( face_no=0 ; face_no < NMG_TBL_END( faces ) ; face_no++ )
				{
					struct face *fp;
					plane_t pl;
					fastf_t dist;
d4431 5
a4435 1
					fp = (struct face *)NMG_TBL_GET( faces , face_no );
d4437 3
a4439 3
					/* don't consider planes that this edge lies in */
					if( i_fus->fu[0]->f_p == fp || j_fus->fu[1]->f_p == fp )
						continue;
d4441 2
a4442 3
					/* intersect plane edge line */
					if( rt_isect_line3_plane( &dist , start , dir , fp->fg_p->N , tol ) < 1 )
						continue;
d4444 7
a4450 5
					/* if intersect point is more than halfway to the next vertex, this is likely
					 * a plane that is nearly parallel to the edge line
					 */
					if( 4.0*dist*dist > old_edge_len_sq )
						continue;
d4452 22
a4473 9
					if( dist > max_dist )
						max_dist = dist;
				}
				VJOIN1( i_fus->vp->vg_p->coord , start , max_dist , dir );
				old_vp = j_fus->vp;
				new_vp = i_fus->vp;
				VMOVE( new_pt , i_fus->vp->vg_p->coord );
				VMOVE( i_fus->pt , new_pt );
			}
d4476 2
a4477 1
		if( old_vp )
d4479 4
a4482 3
			for( tmp_edge_no=0 ; tmp_edge_no< NMG_TBL_END( int_faces ) ; tmp_edge_no++ )
			{
				struct intersect_fus *tmp_fus;
d4484 2
a4485 1
				tmp_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , tmp_edge_no );
d4487 19
a4505 7
				if( tmp_fus->vp == old_vp )
				{
					tmp_fus->vp = new_vp;
					VMOVE( tmp_fus->pt , new_pt );
				}
			}
			nmg_jv( new_vp , old_vp );
a4506 1
		edge_no++;
d4587 1
a4587 1
	unique_verts = nmg_split_edges_at_pts( &int_faces , tol );
d4603 2
d4608 1
a4608 2
	if( unique_verts > 2 )
		nmg_make_faces_at_vert( new_v , &int_faces , tol );
d4611 1
a4611 1
	nmg_kill_cracks_at_vert( &int_faces );
@


1.107
log
@checkpoint.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.106 94/02/04 16:26:31 jra Exp Locker: jra $ (ARL)";
d3272 3
d3276 1
d3280 13
d3302 1
d3305 1
d3308 5
a3312 1

d3318 3
a3320 1
			if( rt_isect_line3_plane( &dist , i_fus->start , i_fus->dir , fp->fg_p->N , tol ) < 1 )
d3322 2
d3466 1
a3466 1
	point_t last_pt;
d3469 1
d3473 11
d3494 1
a3494 1
rt_log( "pt = ( %f %f %f ), angle = %f\n" , V3ARGS( i_fus->pt ) , i_fus->angle );
d3497 1
a3497 1
	VMOVE( last_pt , i_fus->pt );
d3499 1
a3499 1
	/* calculate angle fo rthe rest of the edge lines */
d3506 1
a3506 1
		if( rt_pt3_pt3_equal( last_pt , i_fus->pt , tol ) )
a3508 1
			VMOVE( i_fus->pt , last_pt );
d3512 1
a3512 1
			VSUB2( v1 , i_fus->pt , new_v->vg_p->coord );
d3520 1
a3520 1
		VMOVE( last_pt , i_fus->pt );
d3522 1
a3522 1
rt_log( "pt = ( %f %f %f ), angle = %f\n" , V3ARGS( i_fus->pt ) , i_fus->angle );
d3534 1
a3534 1
nmg_fuse_crossed_edges( int_faces )
d3536 2
a3539 1
	point_t rpp_min;
d3542 1
d3544 2
d3556 1
a3556 1
	for( edge_no=0 ; edge_no < NMG_TBL_END( int_faces ) ; edge_no++ )
d3558 1
a3558 1
		struct intersect_fus *i_fus,*j_fus;
d3561 1
a3561 1
		point_t start,ave_pt;
d3563 1
a3563 1
		fastf_t dist;
d3565 1
d3567 2
d3570 6
a3575 1
		/* get this edge and the next */
a3579 1
		i_fus = (struct intersect_fus *)NMG_TBL_GET( int_faces , edge_no );
d3581 5
d3587 30
d3634 5
d3640 1
a3642 2
		VMOVE( rpp_min , i_fus->pt );

d3653 1
a3653 1
		if( rt_isect_2planes( start , dir , pl1 , pl2 , rpp_min , &tol_tmp ) )
d3656 1
a3656 6
		VCOMB2( ave_pt , 0.5 , i_fus->pt , 0.5 , j_fus->pt );
		(void)rt_dist_pt3_line3( &dist , start , start , dir , ave_pt , &tol_tmp );
rt_log( "\t\t\tFusing intersect points at ( %f %f %f ) and ( %f %f %f )\n\t\t\tto ( %f %f %f )\n" ,
V3ARGS( i_fus->pt ) , V3ARGS( j_fus->pt ) , V3ARGS( start ) );
		VMOVE( i_fus->pt , start );
		VMOVE( j_fus->pt , start );
d3658 51
a3708 5
		/* change smaller angle to equal the larger to avoid unintentional fusing later */
		if( diff > 0.0 )
			j_fus->angle = i_fus->angle;
		else
			i_fus->angle = j_fus->angle;
d3757 7
a3764 2
		new_eu = nmg_esplit( i_fus->vp , i_fus->eu );

d3799 1
d3843 1
a3843 1
		if( i_fus->vp == NULL )
a3845 3
		if( j_fus->vp == NULL )
			continue;

d3967 3
a3969 1
				(void)nmg_esplit( j_fus->vp , i_fus->eu );
d3977 3
a3979 1
				(void)nmg_esplit( i_fus->vp , j_fus->eu );
d4235 135
d4373 1
a4373 1
 *	can't do (more than three faces intersectin at a vertex)
d4446 4
d4459 2
a4460 1
	nmg_fuse_crossed_edges( &int_faces );
d4462 3
a4464 2
	/* split edges at intersection points */
	unique_verts = nmg_split_edges_at_pts( &int_faces , tol );
@


1.106
log
@Started cleanup of nmg_complex_vertex_solve
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.105 94/02/02 17:55:53 jra Exp Locker: jra $ (ARL)";
d1710 3
d2822 29
d2852 214
a3084 1
 * put the average start point in the geometry of new_v
a3096 2
	point_t rpp_min;
	point_t ave_pt;
d3104 3
a3113 3

	VSET( rpp_min , 0.0 , 0.0 , 0.0 );

d3154 1
a3154 1
		if( ret_val=rt_isect_2planes( start , dir , fu1->f_p->fg_p->N , fu2->f_p->fg_p->N , rpp_min , &tol_tmp ) )
d3230 32
a3261 1
	/* calculate average edge start point */
d3263 4
a3266 1
	for( edge_no=0 ; edge_no < NMG_TBL_END( int_faces ) ; edge_no++ )
d3269 4
d3276 2
a3277 2
		VADD2( ave_pt , ave_pt , i_fus->start );
	}
d3279 1
a3279 1
	VSCALE( ave_pt , ave_pt , (1.0)/((double)NMG_TBL_END( int_faces )) );
d3281 6
a3286 1
	VMOVE( new_v->vg_p->coord , ave_pt );
d3288 1
d3290 31
a3320 1
	return( 0 );
d3339 2
d3353 1
a3353 1
		fastf_t dist;
d3362 1
a3362 1
		(void)rt_dist_pt3_line3( &dist , i_fus->start , i_fus->start , i_fus->dir , new_v->vg_p->coord , &tol_tmp );
d3421 1
d3431 1
a3431 1
nmg_calc_edge_angles( int_faces , ave_norm , new_v )
d3435 1
d3439 2
d3443 2
d3457 3
d3467 8
a3474 3
		VSUB2( v1 , i_fus->pt , new_v->vg_p->coord );
		/* get the component of this vector in the "x_vec/y_vec" plane */
		VCOMB2( v2 , VDOT( v1 , x_vec ) , x_vec , VDOT( v1 , y_vec ) , y_vec );
d3476 8
a3483 1
		i_fus->angle = rt_angle_measure( v1 , x_vec , y_vec );
d3547 1
a3547 1
		if( diff > 0.0 && diff < three_halves_pi )
d3601 2
d3644 1
a3644 1
/*	N M G _ C O M P L E X _ V E R T E X _ S O L V E
d3646 5
a3650 2
 *	This is intended to handle the cases the "nmg_simple_vertex_solve"
 *	can't do (more than three faces intersectin at a vertex)
a3651 7
 *	This routine may create new edges and/or faces and
 *
 *	Modifies the location of "new_v"
 *
 *	returns:
 *		0 - if everything is OK
 *		1 - failure
d3653 2
a3654 3

int
nmg_complex_vertex_solve( new_v , faces , tol )
d3656 1
a3656 1
CONST struct nmg_ptbl *faces;
d3659 2
a3660 5
	struct faceuse *fu1,*fu2,*fu;
	struct face *fp1;
	struct vertexuse *vu;
	struct edgeuse *eu1,*eu;
	struct nmg_ptbl int_faces;
d3662 2
a3663 9
	struct intersect_fus *k_fus;
	point_t ave_pt;
	vect_t ave_norm,x_vec,y_vec;
	point_t rpp_min;
	int i,j,done;
	int unique_verts;
	int added_faces;
	int edge_no;
	static int pl_count=0;
a3664 4
	/* More than 3 faces intersect at vertex (new_v)
	 * Calculate intersection point along each edge
	 * emanating from new_v */

a3667 2
	VSET( rpp_min , 0.0 , 0.0 , 0.0 );

d3675 1
a3675 1
	nmg_tbl( &int_faces , TBL_INIT , NULL );
d3677 5
a3681 2
	/* get int_faces table (of intersect_fus structures) partially filled in
	 * with fu's, eu, and edge line definition
d3683 12
a3694 2
	if( nmg_get_edge_lines( new_v , &int_faces , tol ) )
		return( 1 );
d3696 6
a3701 4
	/* fill in "pt" portion of intersect_fus structures with points
	 * at a distnace of (for now) 3.0 mm
	 */
	nmg_get_edge_inters( new_v , 3.0 , &int_faces );
d3703 3
a3705 2
	/* get the average outward pointing normal at this vertex */
	nmg_calc_ave_norm( ave_norm , faces );
d3707 3
a3709 2
	/* calculate the angles at which the edges depart the vertex */
	nmg_calc_edge_angles( &int_faces , ave_norm , new_v );
d3711 2
a3712 4
	/* Now make sure they are in decreasing order.
	 * If not, fuse the intersection points
	 */
	nmg_fuse_crossed_edges( &int_faces );
d3714 2
a3715 2
	/* split edges at intersection points */
	unique_verts = nmg_split_edges_at_pts( &int_faces , tol );
d3717 5
a3721 4
	if( unique_verts > 2 )
	{
		struct nmg_ptbl new_faces;
		struct loopuse *old_lu;
d3723 6
a3728 1
		nmg_tbl( &new_faces , TBL_INIT , (long *)NULL );
d3730 4
a3733 16
		/* Need to make new faces.
		 * loop around the vertex again, looking at
		 * pairs of adjacent edges and deciding
		 * if a new face needs to be constructed
		 * from the two intersect vertices and new_v
		 */
		for( i=0 ; i<NMG_TBL_END( &int_faces ) ; i++ )
		{
			struct intersect_fus *i_fus;
			struct intersect_fus *j_fus;
			struct vertexuse *vu1,*vu2;
			struct loopuse *lu;
			struct loopuse *new_lu;
			struct loopuse *dup_lu;
			struct faceuse *new_fu;
			long **trans_tbl;
d3735 2
a3736 5
			i_fus = (struct intersect_fus *)NMG_TBL_GET( &int_faces , i );
			j = i+1;
			if( j == NMG_TBL_END( &int_faces ) )
				 j = 0;
			j_fus = (struct intersect_fus *)NMG_TBL_GET( &int_faces , j );
d3738 1
a3738 3
			/* if the two vertices are the same, no face needed */
			if( i_fus->vp == j_fus->vp )
				continue;
d3740 6
a3745 3
			/* if either vertex is null, no face needed */
			if( i_fus->vp == NULL )
				continue;
d3747 15
a3761 2
			if( j_fus->vp == NULL )
				continue;
d3763 4
a3766 2
			NMG_CK_VERTEX( i_fus->vp );
			NMG_CK_VERTEX( j_fus->vp );
d3768 8
a3775 2
			/* if the two vertices are within tolerance, fuse them */
			if( rt_pt3_pt3_equal( i_fus->vp->vg_p->coord , j_fus->vp->vg_p->coord , tol ) )
d3779 1
a3779 1
				/* fuse all uses of i_fus->vp to j_fus->vp */
a3783 1
				i_fus->eu = NULL;
d3799 1
a3799 1
						nmg_radial_join_eu( j_fus->eu , eu , tol );
d3804 1
a3804 1
				for( j=0 ; j<NMG_TBL_END( &int_faces ) ; j++ )
d3806 1
a3806 1
					j_fus = (struct intersect_fus *)NMG_TBL_GET( &int_faces , j );
d3811 1
a3811 1
			else if( rt_3pts_collinear( i_fus->vp->vg_p->coord , j_fus->vp->vg_p->coord , new_v->vg_p->coord , tol ) )
d3813 2
a3814 7
				fastf_t i_dist,j_dist,diff_dist;
				vect_t dist_to_new_v,diff_vect;
				struct vertex *set_i_to_null,*set_j_to_null;

				/* all three points are collinear,
				 * don't need a new face, but
				 * may need to split edges
d3816 29
d3846 6
a3851 6
				VSUB2( diff_vect , i_fus->vp->vg_p->coord , j_fus->vp->vg_p->coord );
				diff_dist = MAGSQ( diff_vect );
				VSUB2( dist_to_new_v , new_v->vg_p->coord , i_fus->vp->vg_p->coord );
				i_dist = MAGSQ( dist_to_new_v );
				VSUB2( dist_to_new_v , new_v->vg_p->coord , j_fus->vp->vg_p->coord );
				j_dist = MAGSQ( dist_to_new_v );
d3853 4
a3856 3
				if( diff_dist < tol->dist_sq && j_fus->vp )
				{
					struct vertex *old_vp,*new_vp;
d3858 2
a3859 5
					/* i and j points are within tolerance, fuse them */
					nmg_jv( j_fus->vp , i_fus->vp );
					old_vp = i_fus->vp;
					new_vp = j_fus->vp;
					i_fus->vp = j_fus->vp;
d3861 3
a3863 4
					/* join radial edges created by vertex fuse */
					for( RT_LIST_FOR( vu , vertexuse , &new_v->vu_hd ) )
					{
						struct edgeuse *eu;
d3865 6
a3870 37
						if( *vu->up.magic_p != NMG_EDGEUSE_MAGIC )
							continue;

						eu = vu->up.eu_p;

						/* if endpoints are the same, but edges are different
						 * need to make them radial */
						if( eu->eumate_p->vu_p->v_p == j_fus->vp  &&
							eu->e_p != j_fus->eu->e_p )
							nmg_radial_join_eu( j_fus->eu , eu , tol );
					}

					/* make sure any other vertex pointers don't reference the now
					 * defunct vertex */
					for( j=0 ; j<NMG_TBL_END( &int_faces ) ; j++ )
					{
						j_fus = (struct intersect_fus *)NMG_TBL_GET( &int_faces , j );
						if( j_fus->vp == old_vp )
							j_fus->vp = new_vp;
					}
				}
				if( i_dist < tol->dist_sq && i_fus->vp )
				{
					/* i point is within tolerance of new_v
					 * fuse with new_v
					 */
					nmg_jv( new_v , i_fus->vp );
					set_i_to_null = i_fus->vp;
					i_fus->vp = NULL;
				}
				if( j_dist < tol->dist_sq && j_fus->vp )
				{
					/* j point is within tolerance of new_v
					 * fuse with new_v
					 */
					nmg_jv( new_v , j_fus->vp );
					set_j_to_null = j_fus->vp;
d3872 3
a3874 17
				}
				if( i_dist > j_dist && j_fus->vp && i_fus->eu )
				{
					/* j point is closer to new_v than i point
					 * split edge at j point
					 */
					NMG_CK_VERTEX( j_fus->vp );
					(void)nmg_esplit( j_fus->vp , i_fus->eu );
				}
				else if( j_dist > i_dist && i_fus->vp && j_fus->eu )
				{
					/* i point is closer to new_v than j point
					 * split edge at j point
					 */
					NMG_CK_VERTEX( i_fus->vp );
					(void)nmg_esplit( i_fus->vp , j_fus->eu );
				}
d3876 1
a3876 5
				/* kill zero length edges created by vertex fusion */
				vu = RT_LIST_FIRST( vertexuse , &new_v->vu_hd );
				while( RT_LIST_NOT_HEAD( vu , &new_v->vu_hd ))
				{
					struct vertexuse *vu_next;
d3878 5
a3882 4
					NMG_CK_VERTEXUSE( vu );
					vu_next = RT_LIST_PNEXT( vertexuse , &vu->l );
					if( *vu->up.magic_p != NMG_EDGEUSE_MAGIC )
						continue;
d3884 5
a3888 2
					eu = vu->up.eu_p;
					NMG_CK_EDGEUSE( eu );
d3890 4
a3893 7
					/* if endpoints are both new_v kill the edge */
					if( eu->eumate_p->vu_p->v_p == new_v )
						(void)nmg_keu( eu );

					vu = vu_next;
				}
				for( j=0 ; j<NMG_TBL_END( &int_faces ) ; j++ )
d3895 2
a3896 3
					j_fus = (struct intersect_fus *)NMG_TBL_GET( &int_faces , j );
					if( j_fus->vp == set_i_to_null || j_fus->vp == set_j_to_null )
						j_fus->vp = NULL;
a3897 1
				continue;
d3900 2
a3901 8
			fu = i_fus->fu[1];
			if( fu->orientation != OT_SAME )
				fu = fu->fumate_p;
			/* put this face on the "new_faces" list for glueing */
			nmg_tbl( &new_faces , TBL_INS , (long *)fu );

			/* find use of i_fus->vp in faceuse "fu" */
			for( RT_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
d3903 1
a3903 5
				if( RT_LIST_FIRST_MAGIC(&lu->down_hd) != NMG_EDGEUSE_MAGIC )
					continue;

				vu1 = (struct vertexuse *)NULL;
				for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
d3905 2
a3906 5
					if( eu->vu_p->v_p == i_fus->vp )
					{
						vu1 = eu->vu_p;
						break;
					}
d3908 1
d3910 4
a3913 10
				vu2 = (struct vertexuse *)NULL;
				/* find use of j_fus->vp in faceuse "fu" */
				for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
				{
					if( eu->vu_p->v_p == j_fus->vp )
					{
						vu2 = eu->vu_p;
						break;
					}
				}
d3915 2
a3916 4
				if( vu1 && vu2 )
					break;
			}
			old_lu = lu;
d3918 2
a3919 5
			if( vu1 == NULL || vu2 == NULL )
				continue;

			/* cut the face loop across the two vertices */
rt_log( "Cutting lu (x%x):\n" , old_lu );
d3921 12
a3932 1
			new_lu = nmg_cut_loop( vu1 , vu2 );
d3934 5
a3938 2
			/* fix orientations */
			for( RT_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
d3940 2
a3941 5
				if( lu->orientation == OT_UNSPEC )
				{
					lu->orientation = OT_SAME;
					lu->lumate_p->orientation = OT_SAME;
				}
d3943 5
d3949 4
a3952 4
			/* find which loopuse contains new_v
			 * this will be the one to become a new face
			 */
			lu = NULL;
d3954 4
a3957 2
			/* first check old_lu */
			for( RT_LIST_FOR( eu , edgeuse , &old_lu->down_hd ) )
d3959 10
d3975 1
d3977 2
a3978 12
			/* if not found check new_lu */
			if( lu == NULL )
			{
				for( RT_LIST_FOR( eu , edgeuse , &new_lu->down_hd ) )
				{
					if( eu->vu_p->v_p == new_v )
					{
						lu = old_lu;
						break;
					}
				}
			}
d3980 1
a3980 4
			if( lu == NULL )
				rt_bomb( "nmg_complex_vertex_solve: can't find loop for new face\n" );

			/* make the new face from the new loop */
d3983 1
a3983 1
			new_fu = nmg_mk_new_face_from_loop( lu );
d3985 19
a4003 2
			/* calculate a plane equation for the new face */
			if( nmg_fu_planeeqn( new_fu , &tol_tmp ) )
d4005 2
a4006 2
				rt_log( "Failed to calculate plane eqn for face:\n " );
				nmg_pr_fu_briefly( new_fu , " " );
d4008 2
d4011 4
a4014 10
			/* Add it to the list */
			nmg_tbl( &new_faces , TBL_INS , (long *)new_fu );
			added_faces++;
		}
		if( NMG_TBL_END( &new_faces ) )
		{
			/* glue the new faces together */
			nmg_gluefaces( (struct faceuse **)NMG_TBL_BASEADDR( &new_faces) , NMG_TBL_END( &new_faces ) );
			nmg_tbl( &new_faces , TBL_FREE , (long *)NULL );
		}
d4016 7
d4024 7
a4030 2
	/* Where faces were not built, cracks have formed */
	for( i=0 ; i<NMG_TBL_END( &int_faces ) ; i++ )
d4033 1
d4037 1
a4037 1
		i_fus = (struct intersect_fus *)NMG_TBL_GET( &int_faces , i );
d4042 1
d4044 1
a4044 1
			struct loopuse *lu_next;
d4097 1
d4099 96
d4317 3
d4351 100
d4462 3
a4464 2
nmg_extrude_cleanup( is , tol )
struct shell *is;
d4469 1
d4479 1
d4482 2
d4487 1
d4505 1
a4505 1
			struct faceuse *fu_tmp;
d4531 1
d4547 1
a4547 1

d4553 1
d4555 2
d4558 1
d4560 3
d4569 1
d4579 1
d4582 1
d4600 7
a4606 1
									nmg_tbl( &vertex_uses , TBL_INS , (long *) eu->eumate_p->vu_p );
d4611 2
d4628 2
d4632 1
a4634 1
							isect_count++;
d4641 1
d4650 17
d4674 5
d4682 3
a4684 2
		struct loopuse *old_lu;
		struct loopuse *new_lu;
d4686 1
d4689 1
d4691 6
d4701 2
d4704 2
a4705 2
		old_lu = nmg_find_lu_of_vu( vu1 );
		orientation = old_lu->orientation;
d4708 5
a4712 1
		new_lu = nmg_cut_loop( vu1 , vu2 );
d4714 10
a4723 5
		/* restore orientations */
		new_lu->orientation = orientation;
		old_lu->orientation = orientation;
		new_lu->lumate_p->orientation = orientation;
		old_lu->lumate_p->orientation = orientation;
d4725 4
a4728 2
		/* make a new face from the new loop */
		new_fu = nmg_mk_new_face_from_loop( new_lu );
d4730 2
a4731 2
		if( nmg_fu_planeeqn( new_fu , tol ) )
			rt_log( "Couldn't calculate plane equation for new face\n" );
d4733 46
a4778 2
		/* Make sure all edguese between the vertices at vu1 and vu2 share same edge */
		for( RT_LIST_FOR( vu , vertexuse , &vu1->v_p->vu_hd ) )
d4780 3
a4782 2
			if( *vu->up.magic_p != NMG_EDGEUSE_MAGIC )
				continue;
d4784 7
a4790 2
			eu = vu->up.eu_p;
			if( eu->eumate_p->vu_p->v_p == vu2->v_p )
d4792 6
a4797 4
				if( !eu_base )
					eu_base = eu;
				else if( eu->e_p != eu_base->e_p )
					nmg_moveeu( eu_base , eu->eumate_p );
d4799 47
d4847 2
a4850 1

a4858 1
			int split_loop=0;
a4888 1
					split_loop = 1;
a4892 4

			/* make new faces from the new loops, if any */
			if( split_loop )
				nmg_split_loops_into_faces( &fu->l.magic , tol );
a4895 13
	/* reglue all the faces */
	nmg_tbl( &faces , TBL_INIT , NULL );
	for( RT_LIST_FOR( fu , faceuse , &is->fu_hd ) )
	{
		if( fu->orientation != OT_SAME )
			continue;

		nmg_tbl( &faces , TBL_INS , (long *)fu );
	}

	nmg_gluefaces( (struct faceuse **)NMG_TBL_BASEADDR( &faces ) , NMG_TBL_END( &faces ) );
	nmg_tbl( &faces , TBL_FREE , NULL );

d4897 1
d4899 1
d4905 2
d4934 1
d4944 1
d4949 2
d4952 2
d4955 1
d4968 76
d5048 2
d5067 1
a5067 1
				nmg_js( is , s_tmp );
d5486 1
a5486 1
	nmg_js( dst , src );
a5596 2
	nmg_vmodel( m );

d5669 1
a5669 1
	is = nmg_extrude_cleanup( is , tol );
d5682 3
d5686 1
a5686 1
			nmg_js( s , is );
d5693 3
a5695 1
				nmg_js( s , is );
@


1.105
log
@checkpoint
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.104 94/02/01 17:55:26 jra Exp Locker: jra $ (ARL)";
d1131 1
a1131 1
nmg_reverse_face_and_radials( fu )
d1133 1
d1144 1
a1144 1
	(void)nmg_face_fix_radial_parity( fu );
d1337 1
a1337 1
nmg_propagate_normals( fu_in , flags )
d1340 1
d1420 1
a1420 1
				nmg_reverse_face_and_radials( fu );
d1461 1
a1461 1
nmg_fix_normals( s )
d1463 1
d1494 1
a1494 1
			nmg_reverse_face_and_radials( f_top->fu_p );
d2820 3
a2822 12
/*	N M G _ C O M P L E X _ V E R T E X _ S O L V E
 *
 *	This is intended to handle the cases the "nmg_simple_vertex_solve"
 *	can't do (more than three faces intersectin at a vertex)
 *
 *	This routine may create new edges and/or faces and
 *
 *	Modifies the location of "new_v"
 *
 *	returns:
 *		0 - if everything is OK
 *		1 - failure
d2826 7
a2832 6
	struct faceuse *fu[2];
	struct edgeuse *eu;
	struct vertex *vp;
	point_t pt;
	point_t start;
	vect_t dir;
d2835 11
d2847 1
a2847 1
nmg_complex_vertex_solve( new_v , faces , tol )
d2849 1
a2849 1
CONST struct nmg_ptbl *faces;
d2852 2
a2853 2
	struct faceuse *fu1,*fu2,*fu;
	struct face *fp1;
d2855 4
a2858 2
	struct edgeuse *eu1,*eu;
	struct nmg_ptbl int_faces;
a2859 8
	point_t ave_pt;
	vect_t ave_norm;
	point_t rpp_min;
	int i,j,done;
	int unique_verts;
	int added_faces;
	int edge_no;
	static int pl_count=0;
a2860 49
	/* More than 3 faces intersect at vertex (new_v)
	 * Calculate intersection point along each edge
	 * emanating from new_v */

	NMG_CK_VERTEX( new_v );
	RT_CK_TOL( tol );
#if 0
for( i=0 ; i<NMG_TBL_END( faces ) ; i++ )
{
	char arb_name[17];
	struct face *fp;
	struct face_g *fg;
	point_t pts[8];
	point_t start;
	vect_t v1,v2;
	fastf_t dist;
	fastf_t size,thick;

	sprintf( arb_name , "pl.%d" , i );

	fp = (struct face *)NMG_TBL_GET( faces , i );
	fg = fp->fg_p;

	mat_vec_perp( v1 , fg->N );
	VCROSS( v2 , v1 , fg->N );

	VUNITIZE( v1 );
	VUNITIZE( v2 );

	dist = DIST_PT_PLANE( new_v->vg_p->coord , fg->N );
	VJOIN1( start , new_v->vg_p->coord , dist , fg->N );

	size = 100.0;
	thick = 0.0005;
	VJOIN3( pts[0] , start , size , v1 , size , v2 , thick , fg->N );
	VJOIN1( pts[1] , pts[0] , (-size*2.0) , v1 );
	VJOIN1( pts[2] , pts[1] , (-size*2.0) , v2 );
	VJOIN1( pts[3] , pts[0] , (-size*2.0) , v2 );
	for( j=0 ; j<4 ; j++ )
	{
		VJOIN1( pts[j+4] , pts[j] , -thick , fg->N );
	}

	mk_arb8( stdout , arb_name , pts );
	rt_log( "%s - fp = x%x, fg = x%x  ( %f %f %f %f )\n" , arb_name , fp , fg  , V4ARGS( fg->N ) );
}
#endif
	VSET( rpp_min , 0.0 , 0.0 , 0.0 );

a2867 1
	nmg_tbl( &int_faces , TBL_INIT , NULL );
d2869 1
a2879 3
	done = 0;
	VSET( ave_pt , 0.0 , 0.0 , 0.0 );
	unique_verts = 0;
d2881 1
d2892 1
a2977 1
		VADD2( ave_pt , ave_pt , i_fus->start );
d2979 1
a2979 1
		nmg_tbl( &int_faces , TBL_INS , (long *)i_fus );
a2985 2
	VSCALE( ave_pt , ave_pt , (1.0/(double)(NMG_TBL_END(&int_faces)) ) );
	VMOVE( new_v->vg_p->coord , ave_pt );
d2987 3
a2989 6
#if 0
	/* i_fus->start and i_fus->dir define the edge between faces i_fus->fu[0] and i_fus->fu[1]
	 * now find the intersection of this line with the other faces
	 * that is furthest up the new edge
	 */
	for( edge_no=0 ; edge_no < NMG_TBL_END( &int_faces ) ; edge_no++ )
a2991 2
		fastf_t max_dist,dist,edge_dist_sq;
		vect_t edge_vect;
d2993 1
a2993 1
		i_fus = (struct intersect_fus *)NMG_TBL_GET( &int_faces , edge_no );
d2995 2
a2996 2
		fu1 = i_fus->fu[0];
		fu2 = i_fus->fu[1];
d2998 1
a2998 3
		max_dist = (-MAX_FASTF);
		VSUB2( edge_vect , i_fus->eu->eumate_p->vu_p->v_p->vg_p->coord , i_fus->eu->vu_p->v_p->vg_p->coord );
		edge_dist_sq = MAGSQ( edge_vect );
d3000 1
a3000 4
		for( i=0 ; i<NMG_TBL_END( faces ) ; i++ )
		{
			struct face *fp1;
			point_t tmp_pt;
a3001 3
			fp1 = (struct face *)NMG_TBL_GET( faces , i );
			if( fp1 == fu1->f_p || fp1 == fu2->f_p )
				continue;
d3003 2
a3004 2
			if( rt_isect_line3_plane( &dist , i_fus->start , i_fus->dir , fp1->fg_p->N , &tol_tmp ) < 1 )
				continue;
d3006 15
a3020 1
			VJOIN1( tmp_pt , i_fus->start , dist , i_fus->dir );
d3022 6
a3027 6
			if( (dist > max_dist) && (dist*dist < edge_dist_sq) )
			{
				max_dist = dist;
				VMOVE( i_fus->pt , tmp_pt );
			}
		}
a3028 3
	}
#else

d3030 2
a3031 1
	for( edge_no=0 ; edge_no < NMG_TBL_END( &int_faces ) ; edge_no++ )
d3040 1
a3040 1
		i_fus = (struct intersect_fus *)NMG_TBL_GET( &int_faces , edge_no );
d3045 7
a3051 1
		VJOIN1( i_fus->pt , i_fus->start , 3.0 , i_fus->dir );
d3065 3
a3067 3
		sprintf( rcc_name , "edge.%d.%d" , pl_count , edge_no );
		VSCALE( height , i_fus->dir , 500.0 );
		mk_rcc( stdout , rcc_name , i_fus->start , height , 0.0005 );
a3068 1
	}
d3070 1
a3070 1
#endif
d3072 50
a3121 13
#if 0
	/* check for crossed planes where
	 * a small face gets cut off:
	 *
	 * 	  \    \         /    /
	 * 	   \    \       /    /
	 * 	    \    \     /    /
	 * 	     \    \   /    /
	 * 	      \    \ /    /
	 * 	       \    X    /
	 * 	        \  / \  /
	 * 	         \ --- /
	 * 	          \___/
d3123 8
d3132 2
a3133 1
	for( i=0 ; i<NMG_TBL_END( &int_faces ) ; i++ )
d3135 41
d3177 3
a3179 4
		struct faceuse *fu1,*fu2,*fu3;
		plane_t pl1,pl2,pl3;
		point_t start;
		point_t new_pt;
d3182 2
d3185 4
a3188 1
		i_fus = (struct intersect_fus *)NMG_TBL_GET( &int_faces , i );
d3190 2
a3191 3
		j = i + 1;
		if( j == NMG_TBL_END( &int_faces ) )
			j = 0;
d3193 5
a3197 1
		j_fus = (struct intersect_fus *)NMG_TBL_GET( &int_faces , j );
d3199 9
a3207 3
		if( i_fus->fu[1] != j_fus->fu[0] )
		{
			rt_log( "nmg_complex_vertex_solve: no match in faceuse structs\n" );
a3208 1
		}
d3210 5
d3218 1
a3218 1
		fu2 = i_fus->fu[1];
a3220 3
		fu3 = j_fus->fu[1];
		if( fu3->orientation != OT_SAME )
			fu3 = fu3->fumate_p;
a3223 1
		NMG_GET_FU_PLANE( pl3 , fu3 );
d3225 1
a3225 3
		/* get intersect line for planes 1 and 3 */
		VMOVE( rpp_min , i_fus->pt );
		if( rt_isect_2planes( start , dir , pl1 , pl3 , rpp_min , &tol_tmp ) )
d3228 2
a3229 18
		/* move start point near intersection point */
		(void)rt_dist_pt3_line3( &dist , start , start , dir , i_fus->pt , &tol_tmp );

		/* check if start point is behind plane 2 */
		dist = DIST_PT_PLANE( start , pl2 );
		if( dist < tol->dist )
			continue;

		/* the start point is to the normal-ward side of pl2
		 * fuse i_fus->pt and j_fus->pt
		 */

		VADD2( new_pt , i_fus->pt , j_fus->pt );
		VSCALE( new_pt , new_pt , 0.5 );

		/* move start point near average intersection point */
		(void)rt_dist_pt3_line3( &dist , start , start , dir , new_pt , &tol_tmp );

a3233 7
	}
#else
	VSET( ave_norm , 0.0 , 0.0 , 0.0 );
	for( i=0 ; i<NMG_TBL_END( faces ) ; i++ )
	{
		struct face *fp;
		vect_t norm;
d3235 5
a3239 8
		fp = (struct face *)NMG_TBL_GET( faces , i );
		fu = fp->fu_p;
		if( fu->orientation != OT_SAME )
			fu = fu->fumate_p;

		NMG_GET_FU_NORMAL( norm , fu );

		VADD2( ave_norm , ave_norm , norm );
d3241 1
a3241 1
	VSCALE( ave_norm , ave_norm , (1.0)/((fastf_t)(NMG_TBL_END( faces ))) );
d3243 17
a3259 4
	for( i=0 ; i<NMG_TBL_END( &int_faces ) ; i++ )
	{
		struct intersect_fus *i_fus,*j_fus;
		vect_t cross;
d3261 1
a3261 28
		i_fus = (struct intersect_fus *)NMG_TBL_GET( &int_faces , i );

		j = i + 1;
		if( j == NMG_TBL_END( &int_faces ) )
			j = 0;

		j_fus = (struct intersect_fus *)NMG_TBL_GET( &int_faces , j );

		if( i_fus->fu[1] != j_fus->fu[0] )
		{
			rt_log( "nmg_complex_vertex_solve: no match in faceuse structs\n" );
			continue;
		}

		VCROSS( cross , j_fus->dir , i_fus->dir );
		if( VDOT( cross , ave_norm ) < 0.0 )
		{
			VCOMB2( i_fus->pt , 0.5 , i_fus->pt , 0.5 , j_fus->pt );
			VMOVE( j_fus->pt , i_fus->pt );
		}
	}

#endif
pl_count++;

	/* split edges at intersection points */
	unique_verts = 0;
	for( i=0 ; i<NMG_TBL_END( &int_faces ) ; i++ )
d3269 1
a3269 1
		i_fus = (struct intersect_fus *)NMG_TBL_GET( &int_faces , i );
d3275 1
a3275 1
			tmp_fus = (struct intersect_fus *)NMG_TBL_GET( &int_faces , j );
d3299 81
@


1.104
log
@checkpoint
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.103 94/01/31 16:42:47 jra Exp Locker: jra $ (ARL)";
a43 8
int colors[7][3]={
	{255 , 0 , 0},
	{0 , 255 , 0},
	{0 , 0 , 255},
	{255 , 255 , 0},
	{0 , 255 , 255 },
	{255 , 0 , 255},
	{126 , 126 , 126 }};
d2853 1
d2867 11
d2879 29
d2925 3
d3021 1
a3021 1
		(void)rt_dist_pt3_line3( &dist , start , start , dir , new_v->vg_p->coord , tol );
d3028 1
d3037 2
d3052 1
a3080 5
		if( max_dist > (-MAX_FASTF) )
		{
			VADD2( ave_pt , ave_pt , i_fus->pt );
		}

d3083 2
a3084 1
rt_log( "at (%f %f %f): \n" , V3ARGS( new_v->vg_p->coord ) );
d3088 5
d3095 6
a3100 2
		VJOIN1( i_fus->pt , i_fus->start , 25.0 * tol->dist , i_fus->dir );
rt_log( "\tfor edge ( %f %f %f 0 -> ( %f %f %f ) intersect at ( %f %f %f )\n" ,
d3102 15
a3116 2
	V3ARGS( i_fus->eu->eumate_p->vu_p->v_p->vg_p->coord ),
	V3ARGS( i_fus->pt ) );
d3118 1
d3120 129
a3248 2
	VSCALE( ave_pt , ave_pt , (1.0/(double)(unique_verts)) );
	VMOVE( new_v->vg_p->coord , ave_pt );
@


1.103
log
@checkpoint
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.102 94/01/29 12:19:06 jra Exp Locker: jra $ (ARL)";
d44 8
d2861 1
d2865 2
d2875 2
d2900 1
a2900 1
		fastf_t max_dist,dist;
a2901 1
		point_t rpp_min;
d2993 23
a3015 4
		/* start and dir define the edge between faces fu1 and fu2
		 * now find the intersection of this line with the other faces
		 * that is furthest up the new edge
		 */
d3017 3
d3028 2
a3029 1
			if( rt_isect_line3_plane( &dist , start , dir , fp1->fg_p->N , &tol_tmp ) < 1 )
d3031 4
a3034 2
			VJOIN1( tmp_pt , start , dist , dir );
			if( dist > max_dist )
d3040 1
a3040 1
		nmg_tbl( &int_faces , TBL_INS , (long *)i_fus );
a3042 1
			unique_verts++;
d3045 1
a3045 4
		eu = eu->radial_p;
		eu = RT_LIST_PNEXT_CIRC( edgeuse , eu );
		if( eu == eu1 )
			done = 1;
d3047 14
d3108 1
a3111 19
for( i=0 ; i<NMG_TBL_END( &int_faces ) ; i++ )
{
	struct intersect_fus *i_fus;

	i_fus = (struct intersect_fus *)NMG_TBL_GET( &int_faces , i );

	rt_log( "%d intersect_fus: \n" , i );
	rt_log( "\tfu[0] = x%x\n" , i_fus->fu[0] );
	rt_log( "\tfu[1] = x%x\n" , i_fus->fu[1] );
	rt_log( "\teu = x%x\n" , i_fus->eu );
	rt_log( "\tvp = x%x\n" , i_fus->vp );
	rt_log( "\tpt = ( %f %f %f )\n" , V3ARGS( i_fus->pt ) );
	rt_log( "\tstart = ( %f %f %f )\n" , V3ARGS( i_fus->start ) );
	rt_log( "\tdir = ( %f %f %f )\n" , V3ARGS( i_fus->dir ) );

	nmg_pr_fu_briefly( i_fus->fu[0] , (char *)NULL );
	nmg_pr_fu_briefly( i_fus->fu[1] , (char *)NULL );
}

a3126 1
			int orientation;
d3341 1
d3343 1
a3343 1
			if( !vu1 || !vu2 )
d3347 2
a3348 1
			orientation = lu->orientation;
d3350 2
a3351 7
#if 0
			/* keep the original orientations */
			lu->orientation = orientation;
			lu->lumate_p->orientation = orientation;
			new_lu->orientation = orientation;
			new_lu->lumate_p->orientation = orientation;
#else
a3359 1
#endif
d3364 4
a3367 4
			fu = new_lu->up.fu_p;
			if( fu->orientation != OT_SAME )
				fu = fu->fumate_p;
			for( RT_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
d3369 1
a3369 1
				for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
d3371 10
d3383 1
a3383 1
						new_lu = lu;
a3386 2
				if( new_lu )
					break;
d3389 3
d3393 3
a3395 1
			new_fu = nmg_mk_new_face_from_loop( new_lu );
a3415 19
rt_log( "After building faces:\n" );
for( i=0 ; i<NMG_TBL_END( &int_faces ) ; i++ )
{
	struct intersect_fus *i_fus;

	i_fus = (struct intersect_fus *)NMG_TBL_GET( &int_faces , i );

	rt_log( "%d intersect_fus: \n" , i );
	rt_log( "\tfu[0] = x%x\n" , i_fus->fu[0] );
	rt_log( "\tfu[1] = x%x\n" , i_fus->fu[1] );
	rt_log( "\teu = x%x\n" , i_fus->eu );
	rt_log( "\tvp = x%x\n" , i_fus->vp );
	rt_log( "\tpt = ( %f %f %f )\n" , V3ARGS( i_fus->pt ) );
	rt_log( "\tstart = ( %f %f %f )\n" , V3ARGS( i_fus->start ) );
	rt_log( "\tdir = ( %f %f %f )\n" , V3ARGS( i_fus->dir ) );

	nmg_pr_fu_briefly( i_fus->fu[0] , (char *)NULL );
	nmg_pr_fu_briefly( i_fus->fu[1] , (char *)NULL );
}
a3482 19
rt_log( "After killing cracks:\n" );
for( i=0 ; i<NMG_TBL_END( &int_faces ) ; i++ )
{
	struct intersect_fus *i_fus;

	i_fus = (struct intersect_fus *)NMG_TBL_GET( &int_faces , i );

	rt_log( "%d intersect_fus: \n" , i );
	rt_log( "\tfu[0] = x%x\n" , i_fus->fu[0] );
	rt_log( "\tfu[1] = x%x\n" , i_fus->fu[1] );
	rt_log( "\teu = x%x\n" , i_fus->eu );
	rt_log( "\tvp = x%x\n" , i_fus->vp );
	rt_log( "\tpt = ( %f %f %f )\n" , V3ARGS( i_fus->pt ) );
	rt_log( "\tstart = ( %f %f %f )\n" , V3ARGS( i_fus->start ) );
	rt_log( "\tdir = ( %f %f %f )\n" , V3ARGS( i_fus->dir ) );

	nmg_pr_fu_briefly( i_fus->fu[0] , (char *)NULL );
	nmg_pr_fu_briefly( i_fus->fu[1] , (char *)NULL );
}
d4651 67
@


1.102
log
@Checkpoint
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.101 94/01/28 16:15:37 jra Exp Locker: jra $ (ARL)";
d3034 1
a3034 1
			if( rt_pt3_pt3_equal( tmp_fus->pt , i_fus->pt , tol ) )
d3036 6
a3041 3
				i_fus->vp = tmp_fus->vp;
				VMOVE( i_fus->pt , tmp_fus->pt );
				break;
d3064 19
a3106 1

d3118 3
d3124 1
a3124 2
				struct vertex *set_i_to_null;
				struct edgeuse *eu_base;
d3127 4
a3130 7
				while( (vu = RT_LIST_FIRST( vertexuse , &i_fus->vp->vu_hd )) != NULL )
				{
					NMG_CK_VERTEXUSE( vu );
					nmg_movevu( vu , j_fus->vp );
				}
				set_i_to_null = i_fus->vp;
				i_fus->vp = NULL;
d3133 1
a3133 1
				/* find one edgeuse from new_v to i_fus->vp */
d3142 6
a3147 5
					if( eu->eumate_p->vu_p->v_p == i_fus->vp )
					{
						eu_base = eu;
						break;
					}
d3150 2
a3151 16
				/* join radial edges */
				for( RT_LIST_FOR( vu , vertexuse , &new_v->vu_hd ) )
				{
					struct edgeuse *eu;

					if( *vu->up.magic_p != NMG_EDGEUSE_MAGIC )
						continue;

					if( eu == eu_base )
						continue;

					eu = vu->up.eu_p;
					if( eu->eumate_p->vu_p->v_p == i_fus->vp )
						nmg_radial_join_eu( eu_base , eu , tol );
				}
#if 0
d3155 2
a3156 2
					if( j_fus->vp == set_i_to_null )
						j_fus->vp = NULL;
a3157 1
#endif
d3179 2
d3182 7
a3188 1
					while( (vu = RT_LIST_FIRST( vertexuse , &i_fus->vp->vu_hd )) != NULL )
d3190 12
a3201 2
						NMG_CK_VERTEXUSE( vu );
						nmg_movevu( vu , j_fus->vp );
d3203 9
a3211 2
					set_i_to_null = i_fus->vp;
					i_fus->vp = j_fus->vp;
d3216 1
a3216 2
					 * fuse with new_v and
					 * kill edges between i point and new_v
d3218 1
a3218 15
					while( (vu = RT_LIST_FIRST( vertexuse , &i_fus->vp->vu_hd )) != NULL )
					{
						NMG_CK_VERTEXUSE( vu );
						nmg_movevu( vu , new_v );
						if( *vu->up.magic_p == NMG_EDGEUSE_MAGIC )
						{
							eu = vu->up.eu_p;
							NMG_CK_EDGEUSE( eu );
							if( eu->eumate_p->vu_p->v_p == new_v )
							{
								/* zero length edge */
								nmg_keu( eu );
							}
						}
					}
d3222 1
a3222 1
				if( j_dist < tol->dist_sq )
d3225 1
a3225 2
					 * fuse with new_v and
					 * kill edges between j point and new_v
d3227 1
a3227 15
					while( (vu = RT_LIST_FIRST( vertexuse , &j_fus->vp->vu_hd )) != NULL )
					{
						NMG_CK_VERTEXUSE( vu );
						nmg_movevu( vu , new_v );
						if( *vu->up.magic_p == NMG_EDGEUSE_MAGIC )
						{
							eu = vu->up.eu_p;
							NMG_CK_EDGEUSE( eu );
							if( eu->eumate_p->vu_p->v_p == new_v )
							{
								/* zero length edge */
								nmg_keu( eu );
							}
						}
					}
a3246 1
#if 0
d3248 20
d3271 1
a3271 1
					if( j_fus->vp == set_i_to_null|| j_fus->vp == set_j_to_null )
a3273 1
#endif
a3281 2
			lu = RT_LIST_FIRST( loopuse , &fu->lu_hd );
			vu1 = (struct vertexuse *)NULL;
d3284 1
a3284 1
			for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
d3286 5
a3290 1
				if( eu->vu_p->v_p == i_fus->vp )
d3292 5
a3296 2
					vu1 = eu->vu_p;
					break;
a3297 4
			}
			if( vu1 == (struct vertexuse *)NULL )
				rt_log( "Can't find vertex use of new i vertex use in faceuse x%x\n" , fu );
			vu2 = (struct vertexuse *)NULL;
d3299 3
a3301 4
			/* find use of j_fus->vp in faceuse "fu" */
			for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
			{
				if( eu->vu_p->v_p == j_fus->vp )
d3303 8
a3310 1
					vu2 = eu->vu_p;
a3311 1
				}
a3312 2
			if( vu2 == (struct vertexuse *)NULL )
				rt_log( "Can't find vertex use of new j vertex in faceuse\n" , fu );
d3373 1
a3373 1
			/* gluse the new faces together */
d3379 19
d3403 1
d3407 2
a3408 1
		for( RT_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
d3411 2
d3414 1
d3416 2
a3417 1
			for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
d3419 3
d3433 2
a3434 2
						rt_log( "nmg_complex_vertex_solve: nmg_keu resulted in empty loop\n" );
						return( 1 );
d3438 2
a3439 2
						rt_log( "nmg_complex_vertex_solve: nmg_keu resulted in empty loop\n" );
						return( 1 );
d3445 2
d3448 9
d3458 5
d3465 19
@


1.101
log
@Checkpoint
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.100 94/01/25 16:37:39 jra Exp Locker: jra $ (ARL)";
d3101 1
d3112 32
d3259 2
d3304 8
a3311 2
			nmg_lu_reorient( lu , tol );
			nmg_lu_reorient( new_lu , tol );
a3312 2

			new_lu = NULL;
@


1.100
log
@removed nmg_merge_shells (nmg_js performed same function)
slight mods of nmg_extrude_cleanup, nmg_decompose_shell, and nmg_split_loops_into_faces
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.99 94/01/25 09:42:04 mike Exp Locker: jra $ (ARL)";
d2826 3
a2828 1
 *	Bombs on failure
d2840 1
a2840 1
void
d2873 2
d2884 1
d2899 1
a2909 1
		/* find the new edge line (defined by start and dir) */
d2911 2
d2938 2
a2939 2
				rt_log( "dot product of normals = %f\n" , VDOT( normal1 , plane2 ) );
				rt_log( "tol->para = %f\n" , tol->para );
d2941 2
a2942 2
				rt_log( "cross_product of normals = ( %f %f %f )\n" , V3ARGS( dir ) );
				rt_log( "length of dir = %f\n" , MAGNITUDE( dir ) );
d2956 4
a2959 1
					rt_bomb( "No intersection\n" );
d2961 4
a2964 1
					rt_bomb( "Lines are collinear\n" );
d3061 6
a3066 1
		/* Need to make new faces */
d3086 1
d3090 1
d3097 1
d3102 1
d3111 1
a3111 1

d3118 1
d3126 5
d3137 1
d3140 1
d3147 1
a3147 2
					i_fus->vp = NULL;
					i_fus->eu = NULL;
d3151 4
d3175 4
d3199 3
d3207 3
d3213 1
d3221 1
d3230 1
d3243 1
d3259 1
d3262 1
a3262 1

d3268 4
d3275 6
a3280 1
			/* find which loopuse contains new_v */
d3294 2
d3297 2
d3304 2
d3311 1
d3342 4
a3345 1
						rt_bomb( "nmg_keu resulted in empty loop\n" );
d3347 4
a3350 1
						rt_bomb( "nmg_keu resulted in empty loop\n" );
d3359 1
d3368 1
d4204 4
d4209 1
a4209 1
void
d4228 4
a4231 1
		rt_bomb( "nmg_open_shells_connect: destination shell is closed!\n" );
d4234 4
a4237 1
		rt_bomb( "nmg_open_shells_connect: source shell is closed!\n" );
d4317 2
d4321 1
a4321 1
/*	N M G _ I N S I D E _ V E R T
d4331 1
a4331 2
nmg_in_vert( old_vu , new_v , copy_tbl , tol )
CONST struct vertexuse *old_vu;
a4332 1
CONST long **copy_tbl;
a4338 1
	NMG_CK_VERTEXUSE( old_vu );
a4350 1
			goto out;
d4354 7
a4360 1
		nmg_complex_vertex_solve( new_v , &faces , tol );
a4361 1
out:
d4365 1
a4365 4
	if( failed )
		return( 1 );
	else
		return( 0 );
d4480 1
a4480 1
						if( nmg_in_vert( vu , new_v , copy_tbl , tol ) )
@


1.99
log
@CONST stuff
Tweaked nmg_extrude_cleanup() to reorient new lu's.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.98 94/01/20 13:05:02 jra Exp Locker: mike $ (ARL)";
a922 50
 *	N M G _ M E R G E _ S H E L L S
 *
 *	Move everything from source shell to destination
 *	shell, then destroy source shell
 *
 */
void
nmg_merge_shells( dst , src )
struct shell *dst;
struct shell *src;
{
	struct faceuse *fu;
	struct loopuse *lu;
	struct edgeuse *eu;
	struct vertexuse *vu;

	NMG_CK_SHELL( src );
	NMG_CK_SHELL( dst );

	while( RT_LIST_NON_EMPTY( &src->fu_hd ) )
	{
		fu = RT_LIST_FIRST( faceuse , &src->fu_hd );
		NMG_CK_FACEUSE( fu );
		nmg_mv_fu_between_shells( dst , src , fu );
	}

	while( RT_LIST_NON_EMPTY( &src->lu_hd ) )
	{
		lu = RT_LIST_FIRST( loopuse , &src->lu_hd );
		NMG_CK_LOOPUSE( lu );
		nmg_mv_lu_between_shells( dst , src , lu );
	}

	while( RT_LIST_NON_EMPTY( &src->eu_hd ) )
	{
		eu = RT_LIST_FIRST( edgeuse , &src->eu_hd );
		NMG_CK_EDGEUSE( eu );
		nmg_mv_eu_between_shells( dst , src , eu );
	}

	if( src->vu_p )
	{
		NMG_CK_VERTEXUSE( src->vu_p );
		nmg_mv_vu_between_shells( dst , src , src->vu_p );
	}

	nmg_ks( src );
}

/*
d1683 1
d1697 1
d1705 1
d1730 5
a1734 2
	if( otsame_loops < 2 )
		return;
d1736 56
a1791 1
	if( otopp_loops == 0 )
d1793 1
d1810 8
a1817 1
				NMG_GET_FU_PLANE( plane , fu );
d1837 1
a1837 1
nmg_split_loops_into_faces( magic_p )
d1839 1
d1848 1
a1848 1
	NMG_CK_MODEL( m );	
d1850 2
d1857 1
d1880 1
a1880 1
nmg_decompose_shell( s )
d1882 1
d1902 1
a1902 1
	(void)nmg_split_loops_into_faces( &s->l.magic );
d1904 2
d3676 1
a3676 1
			int done=0;
d3682 3
a3684 1
			while( !done )
d3686 3
a3688 1
				done = 1;
d3690 2
a3691 1
				for( RT_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
d3693 9
a3701 11
					struct loopuse *new_lu;
					struct faceuse *new_fu;

					/* check this loop */
					if( (vu=(struct vertexuse *)nmg_loop_touches_self( lu ) ) == (struct vertexuse *)NULL )
						continue;

					/* this loop touches itself */
					done = 0;

					/* split loop */
d3703 6
d3710 2
a3711 3
					/* make a new face from the new loop */
					new_fu = nmg_mk_new_face_from_loop( new_lu );
					nmg_face_g( new_fu , plane );
d3713 3
a3715 5
					/* Determine new orientations */
					nmg_lu_reorient( lu, tol );
					nmg_lu_reorient( new_lu, tol );
				}
			}
d3761 1
a3761 1
		if( (inside_shells=nmg_decompose_shell( is )) < 2 )
a3778 1

d3814 1
a3814 1
				nmg_merge_shells( is , s_tmp );
d4223 1
a4223 1
	nmg_merge_shells( dst , src );
d4422 1
a4422 1
			nmg_merge_shells( s , is );
d4429 1
a4429 1
				nmg_merge_shells( s , is );
@


1.98
log
@Added nmg_vlist_to_wire_edges, nmg_open_shells_connect, nmg_in_vert, and nmg_extrude_shell
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.97 94/01/14 02:45:33 mike Exp Locker: jra $ (ARL)";
a3413 2
RT_EXTERN( struct vertexuse *nmg_loop_touches_self , ( struct loopuse *lu ) );

a3663 1
					int orientation;
d3666 1
a3666 1
					if( (vu=nmg_loop_touches_self( lu ) ) == 0 )
a3671 3
					/* save orientation */
					orientation = lu->orientation;

a3674 6
					/* restore orientations */
					lu->orientation = orientation;
					lu->lumate_p->orientation = orientation;
					new_lu->orientation = orientation;
					new_lu->lumate_p->orientation = orientation;

d3678 4
@


1.97
log
@Moved nmg_face_fix_radial_parity() to nmg_mod.c
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.96 94/01/13 23:12:26 mike Exp Locker: mike $ (ARL)";
d4038 384
@


1.96
log
@From nmg_reverse_face_and_radials() pulled out and enhanced
nmg_face_fix_radial_parity()/
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.95 94/01/13 10:48:39 jra Exp Locker: mike $ (ARL)";
a1170 116
}

/*
 *			N M G _ F A C E _ F I X _ R A D I A L _ P A R I T Y
 *
 *  Around an edge, consider all the edgeuses that belong to a single shell.
 *  The faceuses pertaining to those edgeuses must maintain the appropriate
 *  parity with their radial faceuses, so that OT_SAME is always radial to
 *  OT_SAME, and OT_OPPOSITE is always radial to OT_OPPOSITE.
 *
 *  If a radial edgeuse is encountered that belongs to *this* face, then
 *  it might not have been processed by this routine yet, and is ignored
 *  for the purposes of checking parity.
 *
 *  When moving faces between shells, sometimes this parity relationship
 *  needs to be fixed, which can be easily accomplished by exchanging
 *  the incorrect edgeuse with it's mate in the radial edge linkages.
 *
 *  XXX Note that this routine will not work right in the presence of
 *  XXX dangling faces.
 */
int
nmg_face_fix_radial_parity( fu )
struct faceuse *fu;
{
	struct loopuse *lu;
	struct edgeuse *eu;
	struct faceuse *fu2;
	struct shell	*s;
	long		count = 0;

	NMG_CK_FACEUSE( fu );
	s = fu->s_p;
	NMG_CK_SHELL(s);

	/* Make sure we are now dealing with the OT_SAME faceuse */
	if( fu->orientation == OT_SAME )
		fu2 = fu;
	else
		fu2 = fu->fumate_p;

	for( RT_LIST_FOR( lu , loopuse , &fu2->lu_hd ) )  {
		NMG_CK_LOOPUSE( lu );

		/* skip loops of a single vertex */
		if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
			continue;

		/*
		 *  Consider every edge of this loop.
		 *  Initial sequencing is:
		 *    before(radial), eu, eumate, after(radial)
		 */
		for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )  {
			struct edgeuse	*eumate;
			struct edgeuse	*before;
			struct edgeuse	*sbefore;	/* searched before */
			struct edgeuse	*after;

			eumate = eu->eumate_p;
			before = eu->radial_p;
			after = eumate->radial_p;
			NMG_CK_EDGEUSE(eumate);
			NMG_CK_EDGEUSE(before);
			NMG_CK_EDGEUSE(after);

			/* If no other edgeuses around edge, done. */
			if( before == eumate )
				continue;

			/*
			 *  Search in 'before' direction, until it's in
			 *  same shell.  Also ignore edgeuses from this FACE,
			 *  as they may not have been fixed yet.
			 */
			for( sbefore = before;
			     sbefore != eu && sbefore != eumate;
			     sbefore = sbefore->eumate_p->radial_p
			)  {
				struct faceuse	*bfu;
				if( nmg_find_s_of_eu(sbefore) != s )  continue;

				bfu = nmg_find_fu_of_eu(sbefore);
				/* If edgeuse isn't part of a faceuse, skip */
				if( !bfu )  continue;
				if( bfu->f_p == fu->f_p )  continue;
				/* Found a candidate */
				break;
			}

			/* If search found no others from this shell, done. */
			if( sbefore == eu || sbefore == eumate )
				continue;

			/*
			 *  'eu' is in an OT_SAME faceuse.
			 *  If the first faceuse in the 'before' direction
			 *  from this shell is OT_SAME, no fix is required.
			 */
			if( sbefore->up.lu_p->up.fu_p->orientation == OT_SAME )
				continue;

			/*
			 *  Rearrange order to be: before, eumate, eu, after.
			 *  NOTE: do NOT use sbefore here.
			 */
			before->radial_p = eumate;
			eumate->radial_p = before;

			after->radial_p = eu;
			eu->radial_p = after;
			count++;
rt_log("nmg_face_fix_radial_parity() exchanging eu=x%x & eumate=x%x on edge x%x\n", eu, eumate, eu->e_p);
		}
	}
	return count;
@


1.95
log
@Fixed nmg_move_edge_thru_pt so that it would not reverse faces
and added wire edge capability.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.94 94/01/12 17:59:01 jra Exp Locker: jra $ (ARL)";
d1173 2
a1174 1
/*	N M G _ R E V E R S E _ F A C E _ A N D _ R A D I A L S
d1176 15
a1190 3
 *	This routine calls "nmg_reverse_face" and also makes the radial
 *	pointers connect faces of like orientation (i.e., OT_SAME to OT_SAME and
 *	OT_OPPOSITE to OT_OPPOSITE).
d1192 2
a1193 3

void
nmg_reverse_face_and_radials( fu )
d1199 2
d1203 2
a1205 3
	/* reverse face */
	nmg_reverse_face( fu );

d1212 1
a1212 3
	/* now fix radials */
	for( RT_LIST_FOR( lu , loopuse , &fu2->lu_hd ) )
	{
d1219 10
a1228 4
		for( RT_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
		{
			struct edgeuse *eu_radial;
			struct edgeuse *eumate_radial;
d1230 9
a1238 2
			/* maybe nothing to swap */
			if( eu->eumate_p == eu->radial_p )
d1241 11
a1251 2
			eu_radial = eu->radial_p;
			eumate_radial = eu->eumate_p->radial_p;
d1253 10
a1262 2
			/* if the radial pointer already points to an OT_SAME faceuse, it's O.K. */
			if( eu_radial->up.lu_p->up.fu_p->orientation == OT_SAME )
d1265 19
a1283 5
			/* swap radial pointers between this edgeuse and its mate */
			eu->radial_p = eumate_radial;
			eu->eumate_p->radial_p = eu_radial;
			eu->radial_p->radial_p = eu;
			eu->eumate_p->radial_p->radial_p = eu->eumate_p;
d1286 24
@


1.94
log
@Added nmg_move_edge_thru_pt, nmg_extrude_cleanup, nmg_faces_are_radial, nmg_bad_face_normals
nmg_complex_vertex_solve, nmg_simple_vertex_solve, and nmg_find_isect_face
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.93 94/01/06 15:22:53 jra Exp Locker: jra $ (ARL)";
a3869 1
	struct nmg_ptbl shells;
d3879 1
a3879 4
	/* keep a list of affected shells */
	nmg_tbl( &shells , TBL_INIT , NULL );

	/* Move edge geometry to new point */
d3881 13
a3893 1
	VMOVE( eg->e_pt , pt );
d3895 4
a3898 3
	/* get edge direction */
	VMOVE( e_dir , eg->e_dir );
	if( mv_eu->orientation == OT_OPPOSITE )
d3900 18
a3917 1
		VREVERSE( e_dir , e_dir );
d3920 6
a3926 2
	eu = mv_eu;
	fu1 = nmg_find_fu_of_eu( eu );
d3973 4
a3976 1
				nmg_face_g( fu , plane );
a4001 2
		nmg_tbl( &shells , TBL_INS_UNIQUE , (long *)fu->s_p );

a4072 16

	/* cleanup */
	for( RT_LIST_FOR( r , nmgregion , &m->r_hd ) )
	{
		struct shell *s;

		for( RT_LIST_FOR( s , shell , &r->s_hd ) )
		{
			if( nmg_tbl( &shells , TBL_LOC , (long *)s ) != (-1) )
			{
				s = nmg_extrude_cleanup( s , tol );
			}
		}
	}

	nmg_tbl( &shells , TBL_FREE , NULL );
@


1.93
log
@Added nmg_split_loops_into_faces.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.92 93/12/27 15:08:02 jra Exp Locker: jra $ (ARL)";
d2581 1479
@


1.92
log
@Added "nmg_mk_new_face_from_loop", "nmg_mv_shell_to_region", and "rt_dist_pt3_line3".
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/librt/RCS/nmg_misc.c,v 1.91 93/12/22 15:31:24 jra Exp Locker: jra $ (ARL)";
d1697 185
d1915 2
a2463 69
}

/*	N M G _ M K _ N E W _ F A C E _ F R O M _ L O O P
 *
 *  Remove a loopuse from an existing face and construct a new face
 *  from that loop
 *
 *  Returns new faceuse as built by nmg_mf()
 *
 */
struct faceuse *
nmg_mk_new_face_from_loop( lu )
struct loopuse *lu;
{
	struct shell *s;
	struct faceuse *fu;
	struct loopuse *lu1;
	struct loopuse *lu_mate;
	int ot_same_loops=0;

	NMG_CK_LOOPUSE( lu );

	if( *lu->up.magic_p != NMG_FACEUSE_MAGIC )
	{
		rt_log( "nmg_mk_new_face_from_loop: loopuse is not in a faceuse\n" );
		return( (struct faceuse *)NULL );
	}

	fu = lu->up.fu_p;
	NMG_CK_FACEUSE( fu );

	s = fu->s_p;
	NMG_CK_SHELL( s );

	/* Count the number of exterior loops in this faceuse */
	for( RT_LIST_FOR( lu1 , loopuse , &fu->lu_hd ) )
	{
		NMG_CK_LOOPUSE( lu1 );
		if( lu1->orientation == OT_SAME )
			ot_same_loops++;
	}

	if( ot_same_loops == 1 && lu->orientation == OT_SAME )
	{
		rt_log( "nmg_mk_new_face_from_loop: cannot remove only exterior loop from faceuse\n" );
		return( (struct faceuse *)NULL );
	}

	lu_mate = lu->lumate_p;

	/* remove loopuse from faceuse */
	RT_LIST_DEQUEUE( &lu->l );

	/* remove its mate from faceuse mate */
	RT_LIST_DEQUEUE( &lu_mate->l );

	/* insert these loops in the shells list of wire loops
	 * put the original loopuse at the head of the list
	 * so that it will end up as the returned faceuse from "nmg_mf"
	 */
	RT_LIST_INSERT( &s->lu_hd , &lu_mate->l );
	RT_LIST_INSERT( &s->lu_hd , &lu->l );

	/* set the "up" pointers to the shell */
	lu->up.s_p = s;
	lu_mate->up.s_p = s;

	/* Now make the new face */
	return( nmg_mf( lu ) );
@


1.91
log
@Removed excess debug prints from nmg_decompose_shell
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.90 93/12/21 17:25:12 jra Exp Locker: jra $ (ARL)";
d2277 186
@


1.90
log
@checkpoint
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.89 93/12/14 14:12:25 jra Exp Locker: jra $ (ARL)";
a1780 6
rt_log( "After first face, %d edges on shared list\n" , NMG_TBL_END( &shared_edges ) );
for( i=0 ; i<NMG_TBL_END( &shared_edges ) ; i++ )
{
	eu = (struct edgeuse *)NMG_TBL_GET( &shared_edges , i );
	rt_log( "\t( %f %f %f ) -> ( %f %f %f )\n" , V3ARGS( eu->vu_p->v_p->vg_p->coord ) , V3ARGS( eu->eumate_p->vu_p->v_p->vg_p->coord ) );
}
a1840 6
rt_log( "After another face, %d edges on shared list\n" , NMG_TBL_END( &shared_edges ) );
for( i=0 ; i<NMG_TBL_END( &shared_edges ) ; i++ )
{
	eu = (struct edgeuse *)NMG_TBL_GET( &shared_edges , i );
	rt_log( "\t( %f %f %f ) -> ( %f %f %f )\n" , V3ARGS( eu->vu_p->v_p->vg_p->coord ) , V3ARGS( eu->eumate_p->vu_p->v_p->vg_p->coord ) );
}
a1860 1
rt_log( "No missed faces - done!!!\n" );
@


1.89
log
@First cut at new method for nmg_decokpose_shell
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.88 93/12/03 03:35:34 mike Exp Locker: jra $ (ARL)";
d1781 6
d1847 6
d1873 1
d2084 2
a2085 1
		for( RT_LIST_FOR( fu , faceuse , &s->fu_hd ) )
d2087 6
d2094 2
d2097 1
d2101 2
a2102 1
			
@


1.88
log
@Access to plane equation / surface normal in face_geometry structure
is now done through macros NMG_GET_FU_PLANE() NMG_GET_FU_NORMAL(),
which honor the f->flip flag.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.87 93/12/02 20:46:10 mike Exp Locker: mike $ (ARL)";
d1700 1
a1700 1
 *	of disjoint shells. Expects shell to be a 3-manifold (winged-edges)
d1714 2
d1725 1
d1735 1
a1735 1
	flags = (long *)rt_calloc( m->maxindex , sizeof( long ) , "nmg_fix_normals: flags" );
d1738 1
d1740 1
a1740 1
	/* first go through the shell and mark every face we can get to */
d1757 2
d1760 16
a1775 1
			nmg_tbl( &stack , TBL_INS , (long *)eu );
d1779 3
d1801 5
a1805 2
		/* if this face has already been visited, skip it */
		if( NMG_INDEX_TEST_AND_SET( flags , fu->f_p ) )
d1807 1
a1807 1
                        /* push all edgeuses of "fu" onto the stack */
d1811 1
d1814 1
d1817 2
d1820 16
a1835 1
                                        nmg_tbl( &stack , TBL_INS , (long *)eu );
d1838 3
d1851 1
a1851 1
			if( !NMG_INDEX_TEST( flags , fu->f_p ) )
d1860 4
d1865 1
d1869 4
d1875 2
a1876 3
		/* make a new shell */
		new_s = nmg_msv( r );
		no_of_shells++;
d1878 3
a1880 2
		NMG_CK_FACEUSE( missed_fu );
		fu = missed_fu;
d1882 49
a1930 1
		if( NMG_INDEX_TEST_AND_SET( flags , fu->f_p ) )
d1932 15
a1947 1
			nmg_mv_fu_between_shells( new_s , s , fu );
d1953 1
d1956 1
d1959 2
d1962 16
a1977 1
                                        nmg_tbl( &stack , TBL_INS , (long *)eu );
d1980 5
a1984 2
			if( nmg_kvu( new_s->vu_p ) )
				rt_bomb( "nmg_decompose_shell: killed shell vertex, emptied shell!!\n" );
d2009 1
a2009 1
			if( NMG_INDEX_TEST_AND_SET( flags , fu->f_p ) )
a2010 3
				/* move this face to the new shell */
				nmg_mv_fu_between_shells( new_s , s , fu );

d2019 1
d2021 16
a2036 1
	                                        nmg_tbl( &stack , TBL_INS , (long *)eu );
d2039 5
d2054 1
a2054 1
				if( !NMG_INDEX_TEST( flags , fu->f_p ) )
d2062 21
d2084 2
@


1.87
log
@Moved nmg_unbreak_edge() from nmg_misc.c to nmg_mod.c
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.86 93/11/18 02:09:21 mike Exp Locker: mike $ (ARL)";
d730 2
d770 2
a771 1
				VCROSS( inside , fu->f_p->fg_p->N , v1 );
d1041 11
a1051 1
				nmg_face_g(new_fu, fu->f_p->fg_p->N);
d1377 2
a1378 4
				/* make a normal for this faceuse */
				VMOVE( normal , fu->f_p->fg_p->N );
				if( fu->orientation == OT_OPPOSITE )
					VREVERSE( normal , normal );
d1565 2
d1570 4
d1577 1
a1577 1
		if( f_top->fg_p->N[Z] < 0.0 )
@


1.86
log
@Bounding box routines now all take a tol arg.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.85 93/11/13 00:12:36 mike Exp $ (ARL)";
a1944 120

/* XXX move to nmg_mod.c */
/*
 *			N M G _ U N B R E A K _ E D G E
 *
 *  Undoes the effect of an unwanted nmg_ebreak().
 *
 *  Eliminate the vertex between this edgeuse and the next edge,
 *  on all edgeuses radial to this edgeuse's edge.
 *  The edge geometry must be shared, and all uses of the vertex
 *  to be disposed of must originate from this edge pair.
 *
 *		     eu1          eu2
 *		*----------->*----------->*
 *		A.....e1.....B.....e2.....C
 *		*<-----------*<-----------*
 *		    eu1mate      eu2mate
 *
 *  If successful, the vertex B, the edge e2, and all the edgeuses
 *  radial to eu2 (including eu2) will have all been killed.
 *  The radial ordering around e1 will not change.
 *
 *  No new topology structures are created by this operation.
 *
 *  Returns -
 *	0	OK, edge unbroken
 *	<0	failure, nothing changed
 */
int
nmg_unbreak_edge( eu1_first )
struct edgeuse	*eu1_first;
{
	struct edgeuse	*eu1;
	struct edgeuse	*eu2;
	struct edge	*e1;
	struct edge_g	*eg;
	struct vertexuse *vu;
	struct vertex	*vb = 0;
	struct vertex	*vc;
	struct shell	*s1;
	int		ret = 0;

	NMG_CK_EDGEUSE( eu1_first );
	e1 = eu1_first->e_p;
	NMG_CK_EDGE( e1 );

	eg = e1->eg_p;
	if( !eg )  {
		rt_log( "nmg_unbreak_edge: no geometry for edge1 x%x\n" , e1 );
		ret = -1;
		goto out;
	}
	NMG_CK_EDGE_G(eg);

	/* if the edge geometry doesn't have at least two uses, this
	 * is not a candidate for unbreaking */		
	if( eg->usage < 2 )  {
		ret = -2;
		goto out;
	}

	s1 = nmg_find_s_of_eu(eu1_first);
	NMG_CK_SHELL(s1);

	eu1 = eu1_first;
	eu2 = RT_LIST_PNEXT_CIRC( edgeuse , eu1 );
	if( eu2->e_p->eg_p != eg )  {
		rt_log( "nmg_unbreak_edge: second eu geometry x%x does not match geometry x%x of edge1 x%x\n" ,
			eu2->e_p->eg_p, eg, e1 );
		ret = -3;
		goto out;
	}

	vb = eu2->vu_p->v_p;		/* middle vertex (B) */
	vc = eu2->eumate_p->vu_p->v_p;	/* end vertex (C) */

	/* all uses of this vertex must be for this edge geometry, otherwise
	 * it is not a candidate for deletion */
	for( RT_LIST_FOR( vu , vertexuse , &vb->vu_hd ) )  {
		NMG_CK_VERTEXUSE(vu);
		if( *(vu->up.magic_p) != NMG_EDGEUSE_MAGIC )  {
			/* vertex is referred to by a self-loop */
			if( vu->up.lu_p->orientation == OT_BOOLPLACE )  {
				/* This kind is transient, and safe to ignore */
				continue;
			}
			ret = -4;
			goto out;
		}
		NMG_CK_EDGE(vu->up.eu_p->e_p);
		if( vu->up.eu_p->e_p->eg_p != eg )  {
			ret = -5;
			goto out;
		}
	}

	/* visit all the edgeuse pairs radial to eu1 */
	for(;;)  {
		/* revector eu1mate's start vertex from B to C */
		nmg_movevu( eu1->eumate_p->vu_p , vc );

		/* Now kill off the unnecessary eu2 associated w/ cur eu1 */
		eu2 = RT_LIST_PNEXT_CIRC( edgeuse, eu1 );
		NMG_CK_EDGEUSE(eu2);
		if( eu2->e_p->eg_p != eg )  {
			rt_bomb("nmg_unbreak_edge:  eu2 geometry is wrong\n");
		}
		if( nmg_keu( eu2 ) )
			rt_bomb( "nmg_unbreak_edge: edgeuse parent is now empty!!\n" );

		eu1 = eu1->eumate_p->radial_p;
		if( eu1 == eu1_first )  break;
	}
out:
	if (rt_g.NMG_debug & DEBUG_POLYSECT)  {
		rt_log("nmg_unbreak_edge(eu=x%x, vb=x%x) ret = %d\n",
			eu1_first, vb, ret);
	}
	return ret;
}
@


1.85
log
@nmg_stash_model_to_file() was being over-zealous, freeing the
model it just stashed out from under the caller!
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.84 93/11/12 23:41:51 mike Exp Locker: mike $ (ARL)";
d360 3
a362 2
nmg_rebound( m )
struct model	*m;
d373 1
d391 1
a391 1
						nmg_loop_g(l);
d402 1
a402 1
					nmg_face_bb( f );
d411 1
a411 1
					nmg_loop_g(l);
d419 1
a419 1
				nmg_shell_a( s );
d423 1
a423 1
		nmg_region_a( r );
@


1.84
log
@nmg_visit_handlers_null is now globally defined, in nmg_info.c
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.83 93/11/12 22:16:51 mike Exp Locker: mike $ (ARL)";
d1891 1
a1920 1
		if( intern.idb_ptr )  rt_functab[ID_NMG].ft_ifree( &intern );
a1923 1
	rt_functab[ID_NMG].ft_ifree( &intern );
@


1.83
log
@Fixed memory leak in nmg_stash_model_to_file()
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.82 93/11/08 15:10:59 jra Exp Locker: mike $ (ARL)";
a2149 4

/* XXX This should be made a global constant */
/* XXX move to raytrace.h and ??? */
CONST struct nmg_visit_handlers  nmg_visit_handlers_null;
@


1.82
log
@Fixed another bug in nmg_tbl. In remove function, when multiple entries
match, "end" was being reset before copy was done. In some cases this
resulted in no copying.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.81 93/11/02 13:24:06 jra Exp Locker: jra $ (ARL)";
d1934 1
@


1.81
log
@Fixed nmg_find_top_face, nmg_propagate_normals, and nmg_decompose_shell to 
avoid following radials to other shells.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.80 93/10/29 04:05:22 mike Exp Locker: jra $ (ARL)";
d151 1
a151 1
				for(k=l ; j <= end ;)
d153 1
a154 2

		b->end = end;
@


1.80
log
@nmg_unbreak_edge() can't afford to ignore vu's in other shells.
Otherwise it will trip over eu's from the other shells on the next page...
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.79 93/10/28 23:48:34 mike Exp Locker: mike $ (ARL)";
d1299 4
d1347 13
d1400 1
a1400 1
/*	N M G _ P R O P O G A T E _ N O R M A L S
d1403 1
a1403 1
 *	It then checks all faceuses it can reach via radial structures, and
d1464 7
d1749 7
d1837 7
@


1.79
log
@Gave nmg_tbl()'s call to rt_calloc() a better ID string.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.78 93/10/27 16:16:59 jra Exp Locker: mike $ (ARL)";
a1985 3
		/* Ignore vu's not in this shell */
		if( nmg_find_s_of_vu( vu ) != s1 )  continue;

d1987 5
d1995 1
d2010 1
a2010 1
		if( eu2->e_p->eg_p != eg )
d2012 1
@


1.78
log
@Modified nmg_propagate_normals to avoid following face around free edges.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/librt/RCS/nmg_misc.c,v 1.77 93/10/27 13:44:26 jra Exp Locker: jra $ (ARL)";
d56 3
a58 2
		b->buffer = (long **)rt_calloc(b->blen=64,
						sizeof(p), "pointer table");
@


1.77
log
@Modified nmg_dup_shell to include translation table entries for OT_OPPOSITE faceuses
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/librt/RCS/nmg_misc.c,v 1.76 93/10/23 07:44:06 mike Exp Locker: jra $ (ARL)";
d1404 7
d1426 3
a1428 1
			NMG_PUSH( eu , &stack );
d1483 3
a1485 1
					NMG_PUSH( eu , &stack );
@


1.76
log
@Made nmg_unbreak_edge() printing conditional on DEBUG_POLYSECT
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.75 93/10/23 07:17:41 mike Exp Locker: mike $ (ARL)";
d1030 1
@


1.75
log
@Fiddled with nmg_unbreak_handler
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.74 93/10/23 03:01:59 mike Exp Locker: mike $ (ARL)";
d2003 4
a2006 3
rt_log("nmg_unbreak_edge(eu=x%x, vb=x%x) ret = %d\n", eu1_first, vb, ret);
	if( *eu1->up.magic_p == NMG_LOOPUSE_MAGIC )
		nmg_veu( &eu1->up.lu_p->down_hd, &eu1->up.lu_p->l.magic );
@


1.74
log
@Improved debug printing
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.73 93/10/22 22:28:17 mike Exp Locker: mike $ (ARL)";
d1890 1
a1891 1
	long		*flags;		/* index based array of flags for model */
d2033 1
d2058 1
a2058 1
	/* find two consecutive uses.  First look forward. */
d2071 2
d2082 11
a2092 4
	if( nmg_unbreak_edge( eu1 ) == 0 )  {
		/* keep a count of unbroken edges */
		ub_state->unbroken++;
	}
d2096 2
a2097 1
static CONST struct nmg_visit_handlers  nmg_visit_handlers_null;
@


1.73
log
@nmg_eups() and nmg_lups() eliminated, in favor of
nmg_find_s_of_lu() and nmg_find_s_of_eu().

@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.72 93/10/22 19:42:20 mike Exp Locker: mike $ (ARL)";
d281 7
a293 6
		if (rt_g.NMG_debug & DEBUG_POLYSECT) {
			rt_log("%s\tfu2lu BBox: (%g %g %g)  (%g %g %g) %s\n",
				overlap ? "keep" : "KILL",
				V3ARGS(fu2lg->min_pt), V3ARGS(fu2lg->max_pt),
				nmg_orientation(fu2lu->orientation) );
		}
d1930 1
a1930 1
	struct vertex	*vb;
d2003 1
a2003 1
rt_log("nmg_unbreak_edge(eu=x%x) ret = %d\n", eu1_first, ret);
@


1.72
log
@ANSI lint
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.71 93/10/20 23:49:05 mike Exp Locker: mike $ (ARL)";
a1885 17
/* XXX move to nmg_info.c
/*
 *			N M G _ V U P S
 *
 *  Return parent shell of vertexuse
 */
struct shell *
nmg_vups(vu)
struct vertexuse *vu;
{
	NMG_CK_VERTEXUSE(vu);

	if( *vu->up.magic_p == NMG_LOOPUSE_MAGIC )
		return nmg_lups( vu->up.lu_p );
	return nmg_eups( vu->up.eu_p );
}

d1897 2
a1937 2
rt_log("nmg_unbreak_edge(eu1=x%x)\n", eu1_first);

d1953 1
a1953 1
	s1 = nmg_eups(eu1_first);
d1973 1
a1973 1
		if( nmg_vups( vu ) != s1 )  continue;
@


1.71
log
@First working draft of nmg_unbreak_edge(), nmg_unbreak_region_edge().
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.70 93/10/20 15:23:25 mike Exp Locker: mike $ (ARL)";
d2041 3
a2043 3
long *ep;
genptr_t *state;
int after;
@


1.70
log
@General reformatting
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.69 93/10/07 11:18:44 jra Exp Locker: mike $ (ARL)";
d1886 17
a1905 1
	struct rt_tol	*tol;		/* tolerance needed for nmg_radial_join_eu */
d1910 3
a1912 1
/*	N M G _ U N B R E A K _ E D G E
d1914 114
a2037 2
 *	After an edgeuse is killed, searches for possible
 *	radials for the new edgeuse.
a2038 1

d2040 1
a2040 1
nmg_unbreak_edge( ep , state , after )
a2048 1
	long *flags;
a2049 1
	struct vertex *vb;
a2055 2
	flags = ub_state->flags;

d2057 1
a2057 1
	if( !NMG_INDEX_TEST_AND_SET( flags , e ) )  return;
d2060 2
a2061 3
	if( !eg )
	{
		rt_log( "nmg_unbreak_edge: no geomtry for edge x%x\n" , e );
d2068 2
a2069 1
	if( eg->usage < 2 )
d2071 1
d2073 1
a2073 1
	/* find two consecutive uses */
d2079 6
a2084 12
		struct edgeuse *eu_tmp;

		eu2 = RT_LIST_PLAST_CIRC( edgeuse , eu1 );
		if( eu2->e_p->eg_p != eg )
		{
			rt_log( "Cannot find second use of edge geometry for edge x%x\n" , e );
			return;
		}

		eu_tmp = eu1;
		eu1 = eu2;
		eu2 = eu_tmp;
d2095 3
a2097 11
	/* get the middle vertex */
	vb = eu2->vu_p->v_p;

	/* all uses of this vertex must be for this edge geometry, otherwise
	 * it is not a candidate for deletion */
	for( RT_LIST_FOR( vu , vertexuse , &vb->vu_hd ) )
	{
		if( *(vu->up.magic_p) != NMG_EDGEUSE_MAGIC )
			return;
		if( vu->up.eu_p->e_p->eg_p != eg )
			return;
d2099 1
d2101 2
a2102 5
	/* first move eu1's mate start where to eu2's mate starts now */
	nmg_movevu( eu1->eumate_p->vu_p , eu2->eumate_p->vu_p->v_p );
	/* O.K. kill the edgeuse */
	if( nmg_keu( eu2 ) )
		rt_bomb( "nmg_unbreak_edge: edgeuse parent is now empty!!\n" );
d2104 2
a2105 21
	/* keep a count of unbroken edges */
	ub_state->unbroken++;

	/* look for a candidate radial edges for eu1 */
	for( RT_LIST_FOR( vu , vertexuse , &eu1->vu_p->l ) )
	{
		struct edgeuse *eu;

		if( *(vu->up.magic_p) != NMG_EDGEUSE_MAGIC )
			continue;

		if( (eu = vu->up.eu_p) != eu1 )
		{
			/* this is a candidate */
			if( eu->eumate_p->vu_p->v_p == eu1->eumate_p->vu_p->v_p )
				nmg_radial_join_eu( eu1 , eu , ub_state->tol );
		}
	}
}

/*	N M G _ U N B R E A K _ R E G I O N _ E D G E S
d2107 2
a2108 2
 *	Uses the visit handler to call nmg_unbreak_edge for
 *	each edge in the region
a2111 1

d2113 2
a2114 3
nmg_unbreak_region_edges( r , tol )
struct nmgregion *r;
CONST struct rt_tol *tol;
d2117 1
a2117 1
	struct nmg_visit_handlers *htab;
d2122 1
a2122 4
	NMG_CK_REGION( r );
	RT_CK_TOL( tol );

	m = r->m_p;
d2125 2
a2126 3
	htab = (struct nmg_visit_handlers *)rt_calloc( 1 , sizeof( struct nmg_visit_handlers ) ,
			"nmg_unbreak_region_edges: nmg_visit_handlers" );
	htab->vis_edge = nmg_unbreak_edge;
d2129 1
a2129 2
	ub_state.flags = (long *)rt_calloc( m->maxindex , sizeof( long ) , "nmg_unbreak_region_edges: flags" );
	ub_state.tol = (struct rt_tol *)tol;
d2131 1
a2131 1
	nmg_visit( (long *)&r->l , htab , (genptr_t *)&ub_state );
a2134 1
	rt_free( (char *)htab , "nmg_visit_handler" );
@


1.69
log
@Added nmg_unbreak_region_edges
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.68 93/10/01 20:32:31 mike Exp Locker: jra $ (ARL)";
d1911 2
a1912 2
nmg_unbreak_edge( e , state , after )
long *e;
d1917 2
a1918 2
	struct edge *e_p;
	struct edge_g *eg_p;
d1921 2
d1924 2
a1925 2
	e_p = (struct edge *)e;
	NMG_CK_EDGE( e_p );
d1932 4
a1935 1
	if( NMG_INDEX_TEST_AND_SET( flags , e_p ) )
d1937 3
a1939 2
		struct vertexuse *vu;
		struct vertex *v_p;
d1941 16
a1956 2
		eg_p = e_p->eg_p;
		if( !eg_p )
d1958 1
a1958 1
			rt_log( "nmg_unbreak_edge: no geomtry for edge x%x\n" , e_p );
d1962 4
d1967 1
a1967 4
		/* if the edge geometry doesn't have at least two uses, this
		 * is not a candidate for unbreaking */		
		if( eg_p->usage < 2 )
			return;
d1969 8
a1976 7
		/* find two consecutive uses */
		eu1 = e_p->eu_p;
		NMG_CK_EDGEUSE( eu1 );
		eu2 = RT_LIST_PNEXT_CIRC( edgeuse , eu1 );
		if( eu2->e_p->eg_p != eg_p )
		{
			struct edgeuse *eu_tmp;
d1978 9
a1986 6
			eu2 = RT_LIST_PLAST_CIRC( edgeuse , eu1 );
			if( eu2->e_p->eg_p != eg_p )
			{
				rt_log( "Cannot find second use of edge geometry for edge x%x\n" , e_p );
				return;
			}
d1988 5
a1992 4
			eu_tmp = eu1;
			eu1 = eu2;
			eu2 = eu_tmp;
		}
d1994 2
a1995 1
		/* at this point, the situation is:
d1997 4
a2000 2
			  eu1     eu2
			*------>*------->
d2002 2
a2003 3
		*/
		/* get the middle vertex */
		v_p = eu2->vu_p->v_p;
d2005 1
a2005 3
		/* all uses of this vertex must be for this edge geometry, otherwise
		 * it is not a candidate for deletion */
		for( RT_LIST_FOR( vu , vertexuse , &v_p->vu_hd ) )
d2007 3
a2009 31
			if( *(vu->up.magic_p) != NMG_EDGEUSE_MAGIC )
				return;
			if( vu->up.eu_p->e_p->eg_p != eg_p )
				return;
		}

		/* first move eu1's mate start where to eu2's mate starts now */
		nmg_movevu( eu1->eumate_p->vu_p , eu2->eumate_p->vu_p->v_p );
		/* O.K. kill the edgeuse */
		if( nmg_keu( eu2 ) )
			rt_bomb( "nmg_unbreak_edge: edgeuse parent is now empty!!\n" );
		else
		{
			/* keep a count of unbroken edges */
			ub_state->unbroken++;

			/* look for a candidate radial edges for eu1 */
			for( RT_LIST_FOR( vu , vertexuse , &eu1->vu_p->l ) )
			{
				struct edgeuse *eu;

				if( *(vu->up.magic_p) != NMG_EDGEUSE_MAGIC )
					continue;

				if( (eu = vu->up.eu_p) != eu1 )
				{
					/* this is a candidate */
					if( eu->eumate_p->vu_p->v_p == eu1->eumate_p->vu_p->v_p )
						nmg_radial_join_eu( eu1 , eu , ub_state->tol );
				}
			}
@


1.68
log
@Moved nmg_stash_model_to_file() into nmg_misc.c.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.67 93/09/30 20:57:02 mike Exp Locker: mike $ (ARL)";
d1884 173
@


1.67
log
@Moved printing routines to nmg_pr.c
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
d42 1
a42 2
/* XXX move to raytrace.h */
NMG_EXTERN( struct faceuse *nmg_find_fu_of_eu , (struct edgeuse *eu) );
d44 1
d1834 50
@


1.66
log
@Added nmg_decompose_shell and removed ANSI-style declarations
@
text
@d4 1
a4 1
 *	As the ame implies, these are miscelaneous routines that work with
a6 2
 *	Packages included:
 *		_pr_ routines call rt_log to print the contents of NMG structs
d9 1
a11 1
 *	John R. Anderson
d14 2
a15 3
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
d17 5
d23 2
a24 2
 *	This software is Copyright (C) 1989 by the United States Army.
 *	All rights reserved.
d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/librt/RCS/nmg_misc.c,v 1.65 93/09/22 14:11:52 jra Exp Locker: jra $ (BRL)";
d42 1
a343 689
}

/*
 *			N M G _ O R I E N T A T I O N
 *
 *  Convert orientation code to string.
 */
char *
nmg_orientation(orientation)
int	orientation;
{
	switch (orientation) {
	case OT_SAME:
		return "OT_SAME";
	case OT_OPPOSITE:
		return "OT_OPPOSITE";
	case OT_NONE:
		return "OT_NONE";
	case OT_UNSPEC:
		return "OT_UNSPEC";
	case OT_BOOLPLACE:
		return "OT_BOOLPLACE";
	}
	return "OT_IS_BOGUS!!";
}

/*
 *			N M G _ P R _ O R I E N T
 *
 *	Print the orientation in a nice, english form
 */
void 
nmg_pr_orient(orientation, h)
int		orientation;
CONST char	*h;
{
	switch (orientation) {
	case OT_SAME : rt_log("%s%8s orientation\n", h, "SAME"); break;
	case OT_OPPOSITE : rt_log("%s%8s orientation\n", h, "OPPOSITE"); break;
	case OT_NONE : rt_log("%s%8s orientation\n", h, "NONE"); break;
	case OT_UNSPEC : rt_log("%s%8s orientation\n", h, "UNSPEC"); break;
	case OT_BOOLPLACE : rt_log("%s%8s orientation\n", h, "BOOLPLACE"); break;
	default : rt_log("%s%8s orientation\n", h, "BOGUS!!!"); break;
	}
}

/*
 *			N M G _ P R _ M
 */
void 
nmg_pr_m(m)
CONST struct model *m;
{
	CONST struct nmgregion *r;

	rt_log("MODEL %8x\n", m);
	if (!m || m->magic != NMG_MODEL_MAGIC) {
		rt_log("bad model magic\n");
		return;
	}
	rt_log("%8x ma_p\n", m->ma_p);

	for( RT_LIST_FOR( r, nmgregion, &m->r_hd ) )  {
		nmg_pr_r(r, (char *)NULL);
	}
}

/*
 *			M K P A D
 *
 *  NOTE:  All the nmg_pr_*() routines take an "h" (header string) pointer.
 *  This can be an arbitrary caller-provided string, as long as it is kept
 *  short.  The string will be copied over into nmg_pr_padstr[], and
 *  "h" will be changed to point there, so spaces can be added to the end.
 */
static char nmg_pr_padstr[128];
#define MKPAD(_h) { \
	if (!_h) { _h = nmg_pr_padstr; nmg_pr_padstr[0] = '\0'; } \
	else if( (_h) < nmg_pr_padstr || (_h) >= nmg_pr_padstr+sizeof(nmg_pr_padstr) )  { \
		(void)strncpy(nmg_pr_padstr, (_h), sizeof(nmg_pr_padstr)/2); \
		_h = nmg_pr_padstr; \
	} else { if (strlen(_h) < sizeof(nmg_pr_padstr)-4) (void)strcat(_h, "   "); } }

#define Return	{ h[strlen(h)-3] = '\0'; return; }

/*
 *			N M G _ P R _ R
 */
void 
nmg_pr_r(r, h)
CONST struct nmgregion *r;
char *h;
{
	struct shell *s;

	rt_log("REGION %8x\n", r);

	MKPAD(h);

	if (!r || r->l.magic != NMG_REGION_MAGIC) {
		rt_log("bad region magic\n");
		Return;
	}

	rt_log("%8x m_p\n", r->m_p);
	rt_log("%8x l.forw\n", r->l.forw);
	rt_log("%8x l.back\n", r->l.back);
	rt_log("%8x ra_p\n", r->ra_p);

	for( RT_LIST_FOR( s, shell, &r->s_hd ) )  {
		nmg_pr_s(s, h);
	}
	Return;
}

/*
 *			N M G _ P R _ S A
 */
void 
nmg_pr_sa(sa, h)
CONST struct shell_a *sa;
char *h;
{
	MKPAD(h);

	rt_log("%sSHELL_A %8x\n", h, sa);
	if (!sa || sa->magic != NMG_SHELL_A_MAGIC) {
		rt_log("bad shell_a magic\n");
		Return;
	}
	
	rt_log("%s%f %f %f Min\n", h, sa->min_pt[X], sa->min_pt[Y],
		sa->min_pt[Z]);
	rt_log("%s%f %f %f Max\n", h, sa->max_pt[X], sa->max_pt[Y],
		sa->max_pt[Z]);

	Return;
}

/*
 *			N M G _ P R _ L G
 */
void 
nmg_pr_lg(lg, h)
CONST struct loop_g *lg;
char *h;
{
	MKPAD(h);
	NMG_CK_LOOP_G(lg);
	
	rt_log("%sLOOP_G %8x\n", h, lg);
	rt_log("%s%f %f %f Min\n", h, lg->min_pt[X], lg->min_pt[Y],
		lg->min_pt[Z]);
	rt_log("%s%f %f %f Max\n", h, lg->max_pt[X], lg->max_pt[Y],
		lg->max_pt[Z]);

	Return;
}

/*
 *			N M G _ P R _ F G
 */
void 
nmg_pr_fg(fg, h)
CONST struct face_g *fg;
char *h;
{
	MKPAD(h);

	rt_log("%sFACE_G %8x\n", h, fg);
	NMG_CK_FACE_G(fg);
	
	rt_log("%s%f %f %f Min\n", h, fg->min_pt[X], fg->min_pt[Y],
		fg->min_pt[Z]);
	rt_log("%s%f %f %f Max\n", h, fg->max_pt[X], fg->max_pt[Y],
		fg->max_pt[Z]);

	rt_log("%s%fX + %fY + %fZ = %f\n", h, fg->N[0], fg->N[1],
		fg->N[2], fg->N[3]);

	Return;
}

/*
 *			N M G _ P R _ S
 */
void 
nmg_pr_s(s, h)
CONST struct shell *s;
char *h;
{
	CONST struct faceuse	*fu;
	CONST struct loopuse	*lu;
	CONST struct edgeuse	*eu;

	MKPAD(h);
	
	rt_log("%sSHELL %8x\n", h, s);
	if (!s || s->l.magic != NMG_SHELL_MAGIC) {
		rt_log("bad shell magic\n");
		Return;
	}

	rt_log("%s%8x r_p\n", h, s->r_p);
	rt_log("%s%8x l.forw\n", h, s->l.forw );
	rt_log("%s%8x l.back\n", h, s->l.back );
	rt_log("%s%8x sa_p\n", h, s->sa_p );
	if (s->sa_p)
		nmg_pr_sa(s->sa_p, h);
	
	for( RT_LIST_FOR( fu, faceuse, &s->fu_hd ) )  {
		nmg_pr_fu(fu, h);
	}

	for( RT_LIST_FOR( lu, loopuse, &s->lu_hd ) )  {
		nmg_pr_lu(lu, h);
	}

	for( RT_LIST_FOR( eu, edgeuse, &s->eu_hd ) )  {
		nmg_pr_eu(eu, h);
	}
	if (s->vu_p)
		nmg_pr_vu(s->vu_p, h);

	Return;
}

/*
 *			N M G _ P R _ S _ B R I E F L Y
 */
void 
nmg_pr_s_briefly(s, h)
CONST struct shell *s;
char *h;
{
	CONST struct faceuse	*fu;
	CONST struct loopuse	*lu;
	CONST struct edgeuse	*eu;

	MKPAD(h);
	
	rt_log("%sSHELL %8x\n", h, s);
	if (!s || s->l.magic != NMG_SHELL_MAGIC) {
		rt_log("bad shell magic\n");
		Return;
	}

	for( RT_LIST_FOR( fu, faceuse, &s->fu_hd ) )  {
		nmg_pr_fu_briefly(fu, h);
	}

	for( RT_LIST_FOR( lu, loopuse, &s->lu_hd ) )  {
		nmg_pr_lu_briefly(lu, h);
	}

	for( RT_LIST_FOR( eu, edgeuse, &s->eu_hd ) )  {
		nmg_pr_eu_briefly(eu, h);
	}
	if (s->vu_p)
		nmg_pr_vu_briefly(s->vu_p, h);

	Return;
}

/*
 *			N M G _ P R _ F
 */
void 
nmg_pr_f(f, h)
CONST struct face *f;
char *h;
{
	MKPAD(h);
	NMG_CK_FACE(f);

	rt_log("%sFACE %8x\n", h, f);
	rt_log("%s%8x fu_p\n", h, f->fu_p);
	rt_log("%s%8x fg_p\n", h, f->fg_p);
	if (f->fg_p)
		nmg_pr_fg(f->fg_p, h);

	Return;
}

/*
 *			N M G _ P R _ F U
 */
void 
nmg_pr_fu(fu, h)
CONST struct faceuse *fu;
char *h;
{
	CONST struct loopuse *lu;

	MKPAD(h);
	NMG_CK_FACEUSE(fu);

	rt_log("%sFACEUSE %8x\n", h, fu);

	if (!fu || fu->l.magic != NMG_FACEUSE_MAGIC) {
		rt_log("bad faceuse magic\n");
		Return;
	}
	
	rt_log("%s%8x s_p\n", h, fu->s_p);
	rt_log("%s%8x l.forw\n", h, fu->l.forw);
	rt_log("%s%8x l.back\n", h, fu->l.back);
	rt_log("%s%8x fumate_p\n", h, fu->fumate_p);
	nmg_pr_orient(fu->orientation, h);
	rt_log("%s%8x fua_p\n", h, fu->fua_p);

	rt_log("%s%8x f_p\n", h, fu->f_p);
	if (fu->f_p)
		nmg_pr_f(fu->f_p, h);

	for( RT_LIST_FOR( lu, loopuse, &fu->lu_hd ) )  {
		nmg_pr_lu(lu, h);
	}
	Return;
}

/*
 *			N M G _ P R _ F U _ B R I E F L Y
 */
void 
nmg_pr_fu_briefly(fu, h)
CONST struct faceuse *fu;
char *h;
{
	CONST struct loopuse *lu;

	MKPAD(h);
	NMG_CK_FACEUSE(fu);

	rt_log("%sFACEUSE %8x (%s)\n",
		h, fu, nmg_orientation(fu->orientation));

	for( RT_LIST_FOR( lu, loopuse, &fu->lu_hd ) )  {
		nmg_pr_lu_briefly(lu, h);
	}
	Return;
}

/*
 *			N M G _ P R _ L
 */
void 
nmg_pr_l(l, h)
CONST struct loop *l;
char *h;
{
	MKPAD(h);
	NMG_CK_LOOP(l);

	rt_log("%sLOOP %8x\n", h, l);
	if (!l || l->magic != NMG_LOOP_MAGIC) {
		rt_log("bad loop magic\n");
		Return;
	}
	rt_log("%s%8x lu_p\n", h, l->lu_p);
	rt_log("%s%8x lg_p\n", h, l->lg_p);
	if (l->lg_p)
		nmg_pr_lg(l->lg_p, h);

	Return;
}

/*
 *			N M G _ P R _ L U
 */
void 
nmg_pr_lu(lu, h)
CONST struct loopuse *lu;
char *h;
{
	CONST struct edgeuse	*eu;
	CONST struct vertexuse *vu;
	long		magic1;
	
	MKPAD(h);
	NMG_CK_LOOPUSE(lu);

	rt_log("%sLOOPUSE %8x\n", h, lu);

	switch (*lu->up.magic_p) {
	case NMG_SHELL_MAGIC	: rt_log("%s%8x up.s_p\n", h, lu->up.s_p);
					break;
	case NMG_FACEUSE_MAGIC	: rt_log("%s%8x up.fu_p\n", h, lu->up.fu_p);
					break;
	default			: rt_log("Bad loopuse parent magic\n");
					Return;
	}

	rt_log("%s%8x l.forw\n", h, lu->l.forw);
	rt_log("%s%8x l.back\n", h, lu->l.back);
	rt_log("%s%8x lumate_p\n", h, lu->lumate_p);
	rt_log("%s%8x lua_p\n", h, lu->lua_p);
	nmg_pr_orient(lu->orientation, h);
	rt_log("%s%8x l_p\n", h, lu->l_p);
	if (lu->l_p)
		nmg_pr_l(lu->l_p, h);


	rt_log("%s%8x down_hd.magic\n", h, lu->down_hd.magic);
	rt_log("%s%8x down_hd.forw\n", h, lu->down_hd.forw);
	rt_log("%s%8x down_hd.back\n", h, lu->down_hd.back);

	magic1 = RT_LIST_FIRST_MAGIC( &lu->down_hd );
	if (magic1 == NMG_VERTEXUSE_MAGIC) {
		vu = RT_LIST_PNEXT( vertexuse, &lu->down_hd );
		rt_log("%s%8x down_hd->forw (vu)\n", h, vu);
		nmg_pr_vu(vu, h);
	}
	else if (magic1 == NMG_EDGEUSE_MAGIC) {
		for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
			nmg_pr_eu(eu, h);
		}
	}
	else
		rt_log("bad loopuse child magic\n");

	Return;
}

/*
 *			N M G _ P R _ L U _ B R I E F L Y
 */
void 
nmg_pr_lu_briefly(lu, h)
CONST struct loopuse *lu;
char *h;
{
	CONST struct edgeuse	*eu;
	CONST struct vertexuse *vu;
	long		magic1;

	MKPAD(h);
	NMG_CK_LOOPUSE(lu);

	rt_log("%sLOOPUSE %8x, lumate_p=x%x (%s) \n",
		h, lu, lu->lumate_p, nmg_orientation(lu->orientation) );

	magic1 = RT_LIST_FIRST_MAGIC( &lu->down_hd );
	if (magic1 == NMG_VERTEXUSE_MAGIC) {
		vu = RT_LIST_PNEXT( vertexuse, &lu->down_hd );
		rt_log("%s%8x down_hd->forw (vu)\n", h, vu);
		nmg_pr_vu_briefly(vu, h);
	}
	else if (magic1 == NMG_EDGEUSE_MAGIC) {
		for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
			nmg_pr_eu_briefly(eu, h);
		}
	}
	else
		rt_log("bad loopuse child magic\n");

	Return;
}

/*
 *			N M G _ P R _ E G
 */
void
nmg_pr_eg(eg, h)
CONST struct edge_g *eg;
char *h;
{
	MKPAD(h);
	NMG_CK_EDGE_G(eg);
	
	rt_log("%sEDGE_G %8x pt:(%f %f %f)\n",
		h, eg, V3ARGS(eg->e_pt));
	rt_log("%s       use %d  dir:(%f %f %f)\n",
		h, eg->usage, V3ARGS(eg->e_dir));

	Return;
}

/*
 *			N M G _ P R _ E
 */
void 
nmg_pr_e(e, h)
CONST struct edge *e;
char *h;
{
	MKPAD(h);
	NMG_CK_EDGE(e);

	rt_log("%sEDGE %8x\n", h, e);
	if (!e || e->magic != NMG_EDGE_MAGIC) {
		rt_log("bad edge magic\n");
		Return;
	}
	rt_log("%s%8x eu_p\n", h, e->eu_p);
	rt_log("%s%8x eg_p\n", h, e->eg_p);

	if (e->eg_p)
		nmg_pr_eg(e->eg_p, h);

	Return;
}

/*
 *			N M G _ P R _ E U
 */
void 
nmg_pr_eu(eu, h)
CONST struct edgeuse *eu;
char *h;
{
	MKPAD(h);
	NMG_CK_EDGEUSE(eu);

	rt_log("%sEDGEUSE %8x\n", h, eu);

	switch (*eu->up.magic_p) {
	case NMG_SHELL_MAGIC	: rt_log("%s%8x up.s_p\n", h, eu->up.s_p);
				break;
	case NMG_LOOPUSE_MAGIC	: rt_log("%s%8x up.lu_p\n", h, eu->up.lu_p);
				break;
	default			: rt_log("bad edgeuse parent magic\n");
				Return;
	}
	rt_log("%s%8x l.forw\n", h, eu->l.forw);
	rt_log("%s%8x l.back\n", h, eu->l.back);
	rt_log("%s%8x eumate_p\n", h, eu->eumate_p);
	rt_log("%s%8x radial_p\n", h, eu->radial_p);
	rt_log("%s%8x eua_p\n", h, eu->eua_p);
	nmg_pr_orient(eu->orientation, h);
	rt_log("%s%8x e_p\n", h, eu->e_p);
	rt_log("%s%8x vu_p\n", h, eu->vu_p);
	nmg_pr_e(eu->e_p, h);
	nmg_pr_vu(eu->vu_p, h);

	Return;
}

/*
 *			N M G _ P R _ E U _ B R I E F L Y
 */
void 
nmg_pr_eu_briefly(eu, h)
CONST struct edgeuse *eu;
char *h;
{
	MKPAD(h);
	NMG_CK_EDGEUSE(eu);

	rt_log("%sEDGEUSE %8x\n", h, eu);
	nmg_pr_vu_briefly(eu->vu_p, h);

	Return;
}

/*
 *			N M G _ P R _ V G
 */
void 
nmg_pr_vg(vg, h)
CONST struct vertex_g *vg;
char *h;
{
	MKPAD(h);
	NMG_CK_VERTEX_G(vg);

	if (!vg || vg->magic != NMG_VERTEX_G_MAGIC) {
		rt_log("%sVERTEX_G %8x\n", h, vg);
		rt_log("bad vertex_g magic\n");
		Return;
	}
	rt_log("%sVERTEX_G %8x %f %f %f = XYZ coord\n",
		h, vg, V3ARGS(vg->coord) );
	Return;
}

/*
 *			N M G _ P R _ V
 */
void 
nmg_pr_v(v, h)
CONST struct vertex *v;
char *h;
{
	MKPAD(h);
	NMG_CK_VERTEX(v);

	rt_log("%sVERTEX %8x\n", h, v);
	if (!v || v->magic != NMG_VERTEX_MAGIC) {
		rt_log("bad vertex magic\n");
		Return;
	}
	/* vu_hd ? */
	rt_log("%s   vu_hd %8x\n", h, &v->vu_hd);
	rt_log("%s%8x vu_hd.forw\n", h, v->vu_hd.forw);
	rt_log("%s%8x vu_hd.back\n", h, v->vu_hd.back);


	rt_log("%s%8x vg_p\n", h, v->vg_p);
	if (v->vg_p)
		nmg_pr_vg(v->vg_p, h);

	Return;
}

/*
 *			N M G _ P R _ V U
 */
void 
nmg_pr_vu(vu, h)
CONST struct vertexuse *vu;
char *h;
{
	MKPAD(h);
	NMG_CK_VERTEXUSE(vu);

	rt_log("%sVERTEXUSE %8x\n", h, vu);
	if (!vu || vu->l.magic != NMG_VERTEXUSE_MAGIC) {
		rt_log("bad vertexuse magic\n");
		Return;
	}

	switch (*vu->up.magic_p) {
	case NMG_SHELL_MAGIC	: rt_log("%s%8x up.s_p\n", h, vu->up.s_p); break;
	case NMG_LOOPUSE_MAGIC	: rt_log("%s%8x up.lu_p\n", h, vu->up.lu_p); break;
	case NMG_EDGEUSE_MAGIC	: rt_log("%s%8x up.eu_p\n", h, vu->up.eu_p); break;
	default			: rt_log("bad vertexuse parent magic\n"); 
				Return;
	}
	rt_log("%s%8x l.forw\n", h, vu->l.forw);
	rt_log("%s%8x l.back\n", h, vu->l.back);
	rt_log("%s%8x vua_p\n", h, vu->vua_p);
	rt_log("%s%8x v_p\n", h, vu->v_p);
	nmg_pr_v(vu->v_p, h);
	
	Return;
}

/*
 *			N M G _ P R _ V U _ B R I E F L Y
 */
void 
nmg_pr_vu_briefly(vu, h)
CONST struct vertexuse *vu;
char *h;
{
	CONST struct vertex_g	*vg;

	MKPAD(h);
	NMG_CK_VERTEXUSE(vu);
	NMG_CK_VERTEX(vu->v_p);

	if( vg = vu->v_p->vg_p )  {
		NMG_CK_VERTEX_G(vg);
		rt_log("%sVERTEXUSE %8x, v=x%x, %f %f %f\n", h, vu, vu->v_p,
			V3ARGS(vg->coord) );
	} else {
		rt_log("%sVERTEXUSE %8x, v=x%x\n", h, vu, vu->v_p);
	}

	Return;
}

/*
 *			N M G _ E U P R I N T
 */
void 
nmg_euprint(str, eu)
CONST char		*str;
CONST struct edgeuse	*eu;
{
	CONST fastf_t	*eup;
	CONST fastf_t	*matep;
	
	NMG_CK_EDGEUSE(eu);
	NMG_CK_VERTEXUSE(eu->vu_p);
	NMG_CK_VERTEX(eu->vu_p->v_p);
	NMG_CK_VERTEX_G(eu->vu_p->v_p->vg_p);

	NMG_CK_EDGEUSE(eu->eumate_p);
	NMG_CK_VERTEXUSE(eu->eumate_p->vu_p);
	NMG_CK_VERTEX(eu->eumate_p->vu_p->v_p);
	NMG_CK_VERTEX_G(eu->eumate_p->vu_p->v_p->vg_p);

	eup = eu->vu_p->v_p->vg_p->coord;
	matep = eu->eumate_p->vu_p->v_p->vg_p->coord;

	rt_log("%s (%g, %g, %g -> %g, %g, %g)\n", str, eup[0], eup[1], eup[2],
		matep[0], matep[1], matep[2]);
@


1.65
log
@made nmg_pop_eu available outside of nmg_misc.c
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.64 93/09/14 22:24:19 mike Exp Locker: jra $ (BRL)";
d1174 5
a1178 1
order_tbl( struct nmg_ptbl *tbl , int **index , int tbl_size , int *loop_size )
d1231 3
a1233 1
nmg_close_shell( struct shell *s , struct rt_tol *tol )
d1610 3
a1612 1
nmg_merge_shells( struct shell *dst , struct shell *src )
d1669 3
a1671 1
nmg_dup_shell( struct shell *s , long ***trans_tbl )
d1824 2
a1825 1
*nmg_pop_eu( struct nmg_ptbl *stack )
d1850 2
a1851 1
nmg_reverse_face_and_radials( struct faceuse *fu )
d1912 3
a1914 1
nmg_find_top_face( struct shell *s , long *flags )
d2077 3
a2079 1
nmg_propagate_normals( struct faceuse *fu_in , long *flags )
d2182 2
a2183 1
nmg_fix_normals( struct shell *s )
d2255 3
a2257 1
nmg_break_long_edges( struct shell *s , struct rt_tol *tol )
d2325 195
@


1.64
log
@Added more nmg_tbl() debugging.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.63 93/08/31 14:12:28 jra Exp Locker: mike $ (BRL)";
d1813 1
a1813 1
static struct edgeuse
@


1.63
log
@added a return to nmg_break_long_edges ( number of splits ).
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.62 93/08/27 09:31:10 jra Exp Locker: jra $ (BRL)";
d56 2
d62 2
d75 1
a75 1
			rt_log("nmg_tbl Inserting %8x\n", p);
d121 1
a121 1
			rt_log("nmg_tbl Inserting %8x\n", p);
d136 2
d161 3
d178 2
d182 2
a183 1
		rt_log("Unknown table function %d\n", func);
@


1.62
log
@made nmg_break_long_edges more general (checks all edges now)
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/librt/RCS/nmg_misc.c,v 1.61 93/08/26 16:56:44 jra Exp Locker: jra $ (BRL)";
d2221 2
a2222 1
 *	ones that can be radials of the shorter ones
d2225 1
a2225 1
void
d2231 1
d2284 1
d2286 2
d2293 1
@


1.61
log
@modified nmg_dup_shell to include more entries in the translation table
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.60 93/08/23 17:08:28 jra Exp Locker: jra $ (BRL)";
d2231 1
a2231 1
	/* look for edgeuses that do not have any radials */
d2250 4
a2253 1
				if( eu->eumate_p == eu->radial_p )
d2255 1
a2255 1
					struct vertexuse *vu;
d2257 3
a2259 5
					/* found an edgeuse with no radials */
					/* look for an edgeuse that terminates on this vertex */
					for( RT_LIST_FOR( vu , vertexuse , &eu->vu_p->v_p->vu_hd ) )
					{
						struct edgeuse *eu1;
d2261 3
a2263 3
						/* skip vertexuses that are not part of an edge */
						if( *vu->up.magic_p != NMG_EDGEUSE_MAGIC )
							continue;
d2265 2
a2266 3
						/* don't consider the edge we already found!!! */
						if( vu->up.eu_p == eu )
							continue;
d2268 9
a2276 2
						/* get the mate (so it terminates at "vu" */
						eu1 = vu->up.eu_p->eumate_p;
d2278 2
a2279 9
						/* make sure it is collinear with "eu" */
						if( rt_3pts_collinear( eu->vu_p->v_p->vg_p->coord ,
							eu->eumate_p->vu_p->v_p->vg_p->coord ,
							eu1->vu_p->v_p->vg_p->coord , tol ) )
						{
							/* make sure we break the longer edge
							 * and that the edges are in opposite directions */
							vect_t v0,v1;
							struct edgeuse *tmp_eu;
d2281 2
a2282 6
							VSUB2( v0 , eu->eumate_p->vu_p->v_p->vg_p->coord , eu->vu_p->v_p->vg_p->coord );
							VSUB2( v1 , eu1->eumate_p->vu_p->v_p->vg_p->coord , eu1->vu_p->v_p->vg_p->coord );

							if (MAGSQ( v0 ) > MAGSQ( v1 ) && VDOT( v0 , v1 ) < 0.0 )
								tmp_eu = nmg_esplit(eu1->vu_p->v_p, eu);
						}
@


1.60
log
@Added nmg_break_long_edges.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.59 93/08/17 11:09:52 jra Exp Locker: jra $ (BRL)";
d1644 3
a1646 2
 *  correspondence between old and new vertices, the caller is responsible
 *  for freeing this memory.
d1670 1
d1683 1
d1685 2
d1690 1
d1692 2
d1697 1
d1699 2
d1716 1
d1739 1
d1744 1
d1746 2
d1752 1
d1754 2
d1789 1
@


1.59
log
@Added nmg_fix_normals.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.58 93/07/29 11:22:54 jra Exp Locker: jra $ (BRL)";
d2189 83
@


1.58
log
@modified nmg_dup_shell to make the translation table an implicit return.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.57 93/07/28 11:08:19 jra Exp Locker: jra $ (BRL)";
d1775 414
@


1.57
log
@Added nmg_merge_shells and nmg_dup_shell.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.56 93/07/23 16:28:09 mike Exp Locker: jra $ (BRL)";
d1642 4
d1648 1
a1648 1
nmg_dup_shell( struct shell *s )
a1655 1
	long ** trans_tbl;
d1663 1
a1663 1
	trans_tbl = (long **)rt_calloc(m->maxindex*2, sizeof(long *),
d1681 1
a1681 1
					new_lu = nmg_dup_loop( lu , &new_fu->l.magic , trans_tbl );
d1684 1
a1684 1
					new_lu = nmg_dup_loop( lu , &new_s->l.magic , trans_tbl );
d1704 1
a1704 1
		new_lu = nmg_dup_loop( lu , &new_s->l.magic , trans_tbl );
d1721 1
a1721 1
		new_v1 = NMG_INDEX_GETP(vertex, trans_tbl, old_v1);
d1723 1
a1723 1
		new_v2 = NMG_INDEX_GETP(vertex, trans_tbl, old_v2);
d1729 3
a1731 1
		NMG_INDEX_ASSIGN( trans_tbl , old_v1 , (long *)new_v1 );
d1734 3
a1736 1
		NMG_INDEX_ASSIGN( trans_tbl , old_v2 , (long *)new_v2 );
d1751 1
a1751 1
		new_v = NMG_INDEX_GETP(vertex, trans_tbl, old_v);
d1760 2
d1763 8
a1773 4

	/* free some memory */
	rt_free( (char *)trans_tbl , "nmg_dup_shell: trans_tbl" );

@


1.56
log
@Moved nmg_find_fu_of_vu() and nmg_find_lu_of_vu() from nmg_misc.c to
nmg_info.c
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.55 93/07/23 16:01:10 jra Exp Locker: mike $ (BRL)";
d40 1
a1293 17
		/* Calculate normal for new face, used to insure that we don't
		 * accidently create a face with the opposite normal */
		VSET( normal , 0.0 , 0.0 , 0.0 );
		for( i=0 ; i<loop_size ; i++ )
		{
			j = i+1;
			if( j == loop_size )
				j = 0;

			eu1 = (struct edgeuse *)NMG_TBL_GET( &eu_tbl , index[i] );
			eu2 = (struct edgeuse *)NMG_TBL_GET( &eu_tbl , index[j] );
			VSUB2( v1 , eu1->eumate_p->vu_p->v_p->vg_p->coord , eu1->vu_p->v_p->vg_p->coord );
			VSUB2( v2 , eu2->eumate_p->vu_p->v_p->vg_p->coord , eu2->vu_p->v_p->vg_p->coord );
			VCROSS( tmp_norm , v1 , v2 );
			VADD2( normal , normal , tmp_norm );
		}

d1432 3
a1434 1
				if( VDOT( inside , v2 ) < 0.0 )
d1582 180
@


1.55
log
@Added nmg_close_shell
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.54 93/07/20 20:58:10 mike Exp Locker: jra $ (BRL)";
a1145 108


struct loopuse *
nmg_find_lu_of_vu( vu )
struct vertexuse *vu;
{
	NMG_CK_VERTEXUSE( vu );
	if ( *vu->up.magic_p == NMG_LOOPUSE_MAGIC )
		return vu->up.lu_p;

	if ( *vu->up.magic_p == NMG_SHELL_MAGIC )
		return (struct loopuse *)NULL;

	NMG_CK_EDGEUSE( vu->up.eu_p );

	if ( *vu->up.eu_p->up.magic_p == NMG_SHELL_MAGIC )
		return (struct loopuse *)NULL;

	NMG_CK_LOOPUSE( vu->up.eu_p->up.lu_p );

	return vu->up.eu_p->up.lu_p;
}


#define FACE_OF_LOOP(lu) { switch (*lu->up.magic_p) { \
	case NMG_FACEUSE_MAGIC:	return lu->up.fu_p; break; \
	case NMG_SHELL_MAGIC: return (struct faceuse *)NULL; break; \
	default: \
	    rt_log("Error at %s %d:\nInvalid loopuse parent magic (0x%x %d)\n", \
		__FILE__, __LINE__, *lu->up.magic_p, *lu->up.magic_p); \
	    rt_bomb("giving up on loopuse"); \
	} }


/*	N M G _ F I N D _ F U _ O F _ V U
 *
 *	return a pointer to the parent faceuse of the vertexuse
 *	or a null pointer if vu is not a child of a faceuse.
 */
struct faceuse *
nmg_find_fu_of_vu(vu)
struct vertexuse *vu;
{
	NMG_CK_VERTEXUSE(vu);

	switch (*vu->up.magic_p) {
	case NMG_LOOPUSE_MAGIC:
		FACE_OF_LOOP( vu->up.lu_p );
		break;
	case NMG_SHELL_MAGIC:
		rt_log("nmg_find_fu_of_vu() vertexuse is child of shell, can't find faceuse\n");
		return ((struct faceuse *)NULL);
		break;
	case NMG_EDGEUSE_MAGIC:
		switch (*vu->up.eu_p->up.magic_p) {
		case NMG_LOOPUSE_MAGIC:
			FACE_OF_LOOP( vu->up.eu_p->up.lu_p );
			break;
		case NMG_SHELL_MAGIC:
			rt_log("nmg_find_fu_of_vu() vertexuse is child of shell/edgeuse, can't find faceuse\n");
			return ((struct faceuse *)NULL);
			break;
		}
		rt_log("Error at %s %d:\nInvalid loopuse parent magic 0x%x\n",
			__FILE__, __LINE__, *vu->up.lu_p->up.magic_p);
		abort();
		break;
	default:
		rt_log("Error at %s %d:\nInvalid vertexuse parent magic 0x%x\n",
			__FILE__, __LINE__,
			*vu->up.magic_p);
		abort();
		break;
	}
	rt_log("How did I get here %s %d?\n", __FILE__, __LINE__);
	abort();
}


/*	N M G _ F I N D _ F U _ O F _ E U
 *
 *	return a pointer to the faceuse that is the super-parent of this
 *	edgeuse.  If edgeuse has no super-parent faceuse, return NULL.
 */
struct faceuse *
nmg_find_fu_of_eu(eu)
struct edgeuse *eu;
{
	NMG_CK_EDGEUSE(eu);

	if (*eu->up.magic_p == NMG_LOOPUSE_MAGIC &&
		*eu->up.lu_p->up.magic_p == NMG_FACEUSE_MAGIC)
			return eu->up.lu_p->up.fu_p;

	return (struct faceuse *)NULL;			
}
#include <stdio.h>
#include <math.h>
#include <string.h>
#include "machine.h"
#include "db.h"
#include "externs.h"
#include "vmath.h"
#include "nmg.h"
#include "rtgeom.h"
#include "raytrace.h"
#include "../librt/debug.h"

@


1.54
log
@Variable fu2lg could have been used before being set.
@
text
@d13 1
d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.53 93/07/19 12:41:44 jra Exp $ (BRL)";
d1241 463
@


1.53
log
@fixed bug in nmg_tbl. TBL_RM wasn't copying the last item after a remove
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.52 93/06/09 00:33:18 butler Exp Locker: jra $ (BRL)";
d201 1
a201 1
	CONST struct loop_g	*fu2lg;
@


1.52
log
@fixed bug with nmg_find_fu_of_eu()
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.51 1993/05/22 01:46:23 mike Exp butler $ (BRL)";
d139 1
a139 1
				for(k=l ; j < end ;)
@


1.51
log
@Added nmg_pr_s_briefly()
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.50 93/05/21 23:47:06 mike Exp Locker: mike $ (BRL)";
d1235 1
a1235 1
	if (*eu->up.magic_p == NMG_LOOP_MAGIC &&
@


1.50
log
@Fixed it so that it compiles again.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.49 93/05/21 15:36:52 butler Exp Locker: mike $ (BRL)";
d550 37
@


1.49
log
@Added nmg_find_fu_of_eu();
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.48 93/05/21 03:24:43 butler Exp Locker: butler $ (BRL)";
d1171 1
a1171 2
		rt_log(stderr,
			"Error at %s %d:\nInvalid loopuse parent magic 0x%x\n",
d1200 1
a1200 1
			return *eu->up.lu_p->up.fu_p;
@


1.48
log
@added nmg_find_lu_of_vu() and nmg_find_fu_of_vu()
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.47 93/04/01 05:20:29 mike Exp Locker: butler $ (BRL)";
d1185 19
@


1.47
log
@Added magic numbers to nmg_ptbl
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.46 93/03/27 00:04:01 mike Exp Locker: mike $ (BRL)";
d1107 78
@


1.46
log
@Most routines get CONST arguments now.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.45 93/03/26 23:01:18 mike Exp Locker: mike $ (BRL)";
d50 1
d56 1
d71 1
d90 1
d104 1
d129 1
d151 1
d163 1
@


1.45
log
@Moved various checking routines from nmg_misc.c to nmg_ck.c
The polygon maker moved from nmg_misc.c to nmg_junk.c
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.44 93/03/24 02:24:46 mike Exp Locker: mike $ (BRL)";
a180 1
/* XXX Needs tol argument */
d182 4
a185 3
nmg_purge_unwanted_intersection_points(vert_list, fu)
struct nmg_ptbl *vert_list;
struct faceuse *fu;
d187 8
a194 7
	int i, j;
	struct vertexuse *vu;
	struct loopuse *lu;
	struct loopuse *fu2lu;
	struct loop_g	*lg;
	struct loop_g	*fu2lg;
	int overlap;
d196 3
d256 2
a257 3
	/* XXX Needs to be changed to V3RPP_OVERLAP_TOL */
			if (V3RPP_OVERLAP(fu2lg->min_pt, fu2lg->max_pt,
			    lg->min_pt, lg->max_pt)) {
d345 4
a348 1
/*	Print the orientation in a nice, english form
d352 2
a353 2
int	orientation;
char	*h;
d365 3
a367 1

d370 1
a370 1
struct model *m;
d372 1
a372 1
	struct nmgregion *r;
d387 2
d404 3
d409 1
a409 1
struct nmgregion *r;
d434 3
d439 1
a439 1
struct shell_a *sa;
d458 3
d463 1
a463 1
struct loop_g *lg;
d478 3
d483 1
a483 1
struct face_g *fg;
d502 3
d507 1
a507 1
struct shell *s;
d510 3
a512 3
	struct faceuse	*fu;
	struct loopuse	*lu;
	struct edgeuse	*eu;
d546 3
d551 1
a551 1
struct face *f;
d566 3
d571 1
a571 1
struct faceuse *fu;
d574 2
a575 1
	struct loopuse *lu;
d603 3
d608 1
a608 1
struct faceuse *fu;
d611 2
a612 1
	struct loopuse *lu;
d625 3
d630 1
a630 1
struct loop *l;
d648 4
d654 1
a654 1
struct loopuse *lu;
d657 2
a658 2
	struct edgeuse	*eu;
	struct vertexuse *vu;
d706 3
d711 1
a711 1
struct loopuse *lu;
d714 2
a715 2
	struct edgeuse	*eu;
	struct vertexuse *vu;
d717 1
a717 1
	
d741 3
d746 1
a746 1
struct edge_g *eg;
d760 3
d765 1
a765 1
struct edge *e;
d785 3
a787 1

d790 1
a790 1
struct edgeuse *eu;
d820 3
d825 1
a825 1
struct edgeuse *eu;
d837 3
d842 1
a842 1
struct vertex_g *vg;
d858 3
d863 1
a863 1
struct vertex *v;
d887 3
d892 1
a892 1
struct vertexuse *vu;
d920 3
d925 1
a925 1
struct vertexuse *vu;
d928 1
a928 1
	struct vertex_g	*vg;
d1058 1
a1058 1
struct model *m;
d1065 5
a1069 5
	struct nmgregion *r;
	struct shell *s;
	struct faceuse *fu;
	struct loopuse *lu;
	struct edgeuse *eu;
@


1.44
log
@Tidy up nmg_purge_unwanted_intersection_points().
Eliminated grumping about OT_UNSPEC verts in fu2.
Noted that a tol arg needs to be added.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.43 93/03/20 04:11:03 mike Exp Locker: mike $ (BRL)";
a874 389

/*
 *			N M G _ C H E C K _ R A D I A L
 *
 *	check to see if all radial uses of an edge (within a shell) are
 *	properly oriented with respect to each other.
 *
 *	Return
 *	0	OK
 *	1	bad edgeuse mate
 *	2	unclosed space
 */
int
nmg_check_radial(eu)
struct edgeuse *eu;
{
	char curr_orient;
	struct edgeuse *eur, *eu1, *eurstart;
	struct shell *s;
	pointp_t p, q;

	NMG_CK_EDGEUSE(eu);
	
	s = eu->up.lu_p->up.fu_p->s_p;
	NMG_CK_SHELL(s);

	curr_orient = eu->up.lu_p->up.fu_p->orientation;
	eur = eu->radial_p;

	/* skip the wire edges */
	while (*eur->up.magic_p == NMG_SHELL_MAGIC) {
		eur = eur->eumate_p->radial_p;
	}

	eurstart = eur;

	eu1 = eu;
	NMG_CK_EDGEUSE(eur);
	do {

		NMG_CK_LOOPUSE(eu1->up.lu_p);
		NMG_CK_FACEUSE(eu1->up.lu_p->up.fu_p);

		NMG_CK_LOOPUSE(eur->up.lu_p);
		NMG_CK_FACEUSE(eur->up.lu_p->up.fu_p);
		/* go find a radial edgeuse of the same shell
		 */
		while (eur->up.lu_p->up.fu_p->s_p != s) {
			NMG_CK_EDGEUSE(eur->eumate_p);
			if (eur->eumate_p->eumate_p != eur) {
				p = eur->vu_p->v_p->vg_p->coord;
				q = eur->eumate_p->vu_p->v_p->vg_p->coord;
				rt_log("edgeuse mate has different mate %g %g %g -> %g %g %g\n",
					p[0], p[1], p[2], q[0], q[1], q[2]);
				nmg_pr_lu(eu->up.lu_p, (char *)NULL);
				nmg_pr_lu(eu->eumate_p->up.lu_p, (char *)NULL);
				rt_log("nmg_check_radial: bad edgeuse mate\n");
				return(1);
			}
			eur = eur->eumate_p->radial_p;
			NMG_CK_EDGEUSE(eur);
			NMG_CK_LOOPUSE(eur->up.lu_p);
			NMG_CK_FACEUSE(eur->up.lu_p->up.fu_p);
		}

		/* if that radial edgeuse doesn't have the
		 * correct orientation, print & bomb
		 */
		if (eur->up.lu_p->up.fu_p->orientation != curr_orient) {
			p = eu1->vu_p->v_p->vg_p->coord;
			q = eu1->eumate_p->vu_p->v_p->vg_p->coord;
			rt_log("Radial orientation problem at edge %g %g %g -> %g %g %g\n",
				p[0], p[1], p[2], q[0], q[1], q[2]);
			rt_log("Problem Edgeuses: %8x, %8x\n", eu1, eur);
			if (rt_g.NMG_debug) {
				nmg_pr_fu(eu1->up.lu_p->up.fu_p, 0);
				rt_log("Radial loop:\n");
				nmg_pr_fu(eur->up.lu_p->up.fu_p, 0);
			}
			rt_log("nmg_check_radial: unclosed space\n");
			return(2);
		}

		eu1 = eur->eumate_p;
		curr_orient = eu1->up.lu_p->up.fu_p->orientation;
		eur = eu1->radial_p;
		while (*eur->up.magic_p == NMG_SHELL_MAGIC) {
			eur = eur->eumate_p->radial_p;
		}

	} while (eur != eurstart);
	return(0);
}

/*
 *		 	N M G _ C K _ C L O S E D _ S U R F
 *
 *  Verify that shell is closed.
 *  Do this by verifying that it is not possible to get from outside
 *  to inside the solid by crossing any face edge.
 *
 *  Returns -
 *	 0	OK
 *	!0	status code from nmg_check_radial()
 */
int
nmg_ck_closed_surf(s)
struct shell *s;
{
	struct faceuse *fu;
	struct loopuse *lu;
	struct edgeuse *eu;
	int		status;
	long		magic1;

	NMG_CK_SHELL(s);
	for( RT_LIST_FOR( fu, faceuse, &s->fu_hd ) )  {
		NMG_CK_FACEUSE(fu);
		for( RT_LIST_FOR( lu, loopuse, &fu->lu_hd ) )  {
			NMG_CK_LOOPUSE(lu);
			magic1 = RT_LIST_FIRST_MAGIC( &lu->down_hd );
			if (magic1 == NMG_EDGEUSE_MAGIC) {
				for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
					if (status=nmg_check_radial(eu))
						return(status);
				}
			} else if (magic1 == NMG_VERTEXUSE_MAGIC) {
				register struct vertexuse	*vu;
				vu = RT_LIST_FIRST( vertexuse, &lu->down_hd );
				NMG_CK_VERTEXUSE(vu);
				NMG_CK_VERTEX(vu->v_p);
			}
		}
	}
	return(0);
}

/*
 *			N M G _ C K _ C L O S E D _ R E G I O N
 *
 *  Check all the shells in a region for being closed.
 *
 *  Returns -
 *	 0	OK
 *	!0	status code from nmg_check_radial()
 */
int
nmg_ck_closed_region(r)
struct nmgregion	*r;
{
	struct shell	*s;
	int		ret;

	NMG_CK_REGION(r);
	for( RT_LIST_FOR( s, shell, &r->s_hd ) )  {
		ret = nmg_ck_closed_surf( s );
		if( ret != 0 )  return(ret);
	}
	return(0);
}


/*
 *			N M G _ P O L Y T O N M G
 *
 *	Read a polygon file and convert it to an NMG shell
 *
 *	A polygon file consists of the following:
 *	The first line consists of two integer numbers: the number of points
 *	(vertices) in the file, followed by the number of polygons in the file.
 *	This line is followed by lines for each of the
 *	verticies.  Each vertex is listed on its own line, as the 3tuple
 *	"X Y Z".  After the list of verticies comes the list of polygons.  
 *	each polygon is represented by a line containing 1) the number of
 *	verticies in the polygon, followed by 2) the indicies of the verticies
 *	that make up the polygon.
 *
 *	Implicit return:
 *		r->s_p	A new shell containing all the faces from the
 *			polygon file
 */
struct shell *
nmg_polytonmg(fp, r, tol)
FILE *fp;
struct nmgregion	*r;
CONST struct rt_tol	*tol;
{
	int i, j, num_pts, num_facets, pts_this_face, facet;
	int vl_len;
	struct vertex **v;		/* list of all vertices */
	struct vertex **vl;	/* list of vertices for this polygon*/
	point_t p;
	struct shell *s;
	struct faceuse *fu;
	struct loopuse	*lu;
	struct edgeuse *eu;
	plane_t plane;
	struct model	*m;

	s = nmg_msv(r);
	m = s->r_p->m_p;
	nmg_kvu(s->vu_p);

	/* get number of points & number of facets in file */
	if (fscanf(fp, "%d %d", &num_pts, &num_facets) != 2)
		rt_bomb("polytonmg() Error in first line of poly file\n");
	else
		if (rt_g.NMG_debug & DEBUG_POLYTO)
			rt_log("points: %d  facets: %d\n",
				num_pts, num_facets);


	v = (struct vertex **) rt_calloc(num_pts, sizeof (struct vertex *),
			"vertices");

	/* build the vertices */ 
	for (i = 0 ; i < num_pts ; ++i) {
		GET_VERTEX(v[i], m);
		v[i]->magic = NMG_VERTEX_MAGIC;
	}

	/* read in the coordinates of the vertices */
	for (i=0 ; i < num_pts ; ++i) {
		if (fscanf(fp, "%lg %lg %lg", &p[0], &p[1], &p[2]) != 3)
			rt_bomb("polytonmg() Error reading point");
		else
			if (rt_g.NMG_debug & DEBUG_POLYTO)
				rt_log("read vertex #%d (%g %g %g)\n",
					i, p[0], p[1], p[2]);

		nmg_vertex_gv(v[i], p);
	}

	vl = (struct vertex **)rt_calloc(vl_len=8, sizeof (struct vertex *),
		"vertex parameter list");

	for (facet = 0 ; facet < num_facets ; ++facet) {
		if (fscanf(fp, "%d", &pts_this_face) != 1)
			rt_bomb("polytonmg() error getting pt count for this face");

		if (rt_g.NMG_debug & DEBUG_POLYTO)
			rt_log("facet %d pts in face %d\n",
				facet, pts_this_face);

		if (pts_this_face > vl_len) {
			while (vl_len < pts_this_face) vl_len *= 2;
			vl = (struct vertex **)rt_realloc( (char *)vl,
				vl_len*sizeof(struct vertex *),
				"vertex parameter list (realloc)");
		}

		for (i=0 ; i < pts_this_face ; ++i) {
			if (fscanf(fp, "%d", &j) != 1)
				rt_bomb("polytonmg() error getting point index for v in f");
			vl[i] = v[j-1];
		}

		fu = nmg_cface(s, vl, pts_this_face);
		lu = RT_LIST_FIRST( loopuse, &fu->lu_hd );
		/* XXX should check for vertex-loop */
		eu = RT_LIST_FIRST( edgeuse, &lu->down_hd );
		NMG_CK_EDGEUSE(eu);
		if (rt_mk_plane_3pts(plane, eu->vu_p->v_p->vg_p->coord,
		    RT_LIST_PNEXT(edgeuse,eu)->vu_p->v_p->vg_p->coord,
		    RT_LIST_PLAST(edgeuse,eu)->vu_p->v_p->vg_p->coord,
		    tol ) )  {
			rt_log("At %d in %s\n", __LINE__, __FILE__);
			rt_bomb("polytonmg() cannot make plane equation\n");
		}
		else nmg_face_g(fu, plane);
	}

	for (i=0 ; i < num_pts ; ++i) {
		if( RT_LIST_IS_EMPTY( &v[i]->vu_hd ) )  continue;
		FREE_VERTEX(v[i]);
	}
	rt_free( (char *)v, "vertex array");
	return(s);
}

/*				N M G _ L U _ O F _ V U 
 *
 *	Given a vertexuse, return the loopuse somewhere above
 */
struct loopuse *
nmg_lu_of_vu(vu)
struct vertexuse *vu;
{
	NMG_CK_VERTEXUSE(vu);
	
	if (*vu->up.magic_p == NMG_EDGEUSE_MAGIC &&
		*vu->up.eu_p->up.magic_p == NMG_LOOPUSE_MAGIC)
			return(vu->up.eu_p->up.lu_p);
	else if (*vu->up.magic_p != NMG_LOOPUSE_MAGIC)
		rt_bomb("NMG vertexuse has no loopuse ancestor\n");

	return(vu->up.lu_p);		
}

/*				N M G _ L U P S
 *
 *	return parent shell for loopuse
 */
struct shell *
nmg_lups(lu)
struct loopuse *lu;
{
	if (*lu->up.magic_p == NMG_SHELL_MAGIC) return(lu->up.s_p);
	else if (*lu->up.magic_p != NMG_FACEUSE_MAGIC) 
		rt_bomb("bad parent for loopuse\n");

	return(lu->up.fu_p->s_p);
}

/*				N M G _ E U P S 
 *
 *	return parent shell of edgeuse
 */
struct shell *
nmg_eups(eu)
struct edgeuse *eu;
{
	if (*eu->up.magic_p == NMG_SHELL_MAGIC) return(eu->up.s_p);
	else if (*eu->up.magic_p != NMG_LOOPUSE_MAGIC)
		rt_bomb("bad parent for edgeuse\n");

	return(nmg_lups(eu->up.lu_p));
}

/*				N M G _ F A C E R A D I A L
 *
 *	Looking radially around an edge, find another edge in the same
 *	face as the current edge. (this could be the mate to the current edge)
 */
CONST struct edgeuse *
nmg_faceradial(eu)
CONST struct edgeuse *eu;
{
	CONST struct faceuse *fu;
	CONST struct edgeuse *eur;

	NMG_CK_EDGEUSE(eu);
	NMG_CK_LOOPUSE(eu->up.lu_p);
	fu = eu->up.lu_p->up.fu_p;
	NMG_CK_FACEUSE(fu);

	eur = eu->radial_p;

	while (*eur->up.magic_p != NMG_LOOPUSE_MAGIC ||
	    *eur->up.lu_p->up.magic_p != NMG_FACEUSE_MAGIC ||
	    eur->up.lu_p->up.fu_p->f_p != fu->f_p)
	    	eur = eur->eumate_p->radial_p;

	return(eur);
}


/*
 *	looking radially around an edge, find another edge which is a part
 *	of a face in the same shell
 */
struct edgeuse *
nmg_radial_face_edge_in_shell(eu)
struct edgeuse *eu;
{
	struct edgeuse *eur;
	struct faceuse *fu;

	NMG_CK_EDGEUSE(eu);
	NMG_CK_LOOPUSE(eu->up.lu_p);
	NMG_CK_FACEUSE(eu->up.lu_p->up.fu_p);

	fu = eu->up.lu_p->up.fu_p;
	eur = eu->radial_p;
	NMG_CK_EDGEUSE(eur);

	while (eur != eu->eumate_p) {
		if (*eur->up.magic_p == NMG_LOOPUSE_MAGIC &&
		    *eur->up.lu_p->up.magic_p == NMG_FACEUSE_MAGIC &&
		    eur->up.lu_p->up.fu_p->s_p == fu->s_p)
			break; /* found another face in shell */
		else {
			eur = eur->eumate_p->radial_p;
			NMG_CK_EDGEUSE(eur);
		}
	}
	return(eur);
}

@


1.43
log
@Some args became CONST.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.42 93/03/17 01:10:43 mike Exp Locker: mike $ (BRL)";
d181 1
d225 24
a248 5
			/* If this loop is just some drek deposited into the
			 * other loop as part of an intersection operation,
			 * it doesn't really count -- skip it.
			 */
			if (fu2lu->orientation == OT_BOOLPLACE)  continue;
a249 4
			/* Everything should be OT_SAME or OT_BOOLPLACE, but...*/
			if (fu2lu->orientation != OT_SAME)
				rt_log("nmg_purge_unwanted_intersection_points encountered %s loop in fu2\n", nmg_orientation(fu2lu->orientation));

d252 1
d268 1
a268 1
				rt_log("nmg_purge_unwanted_intersection_points This little bugger slipped in somehow.  Deleting it.\n");
d270 8
@


1.42
log
@Improved messages
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.41 93/03/15 23:52:46 mike Exp Locker: mike $ (BRL)";
d1184 1
a1184 1
struct edgeuse *
d1186 1
a1186 1
struct edgeuse *eu;
d1188 2
a1189 2
	struct faceuse *fu;
	struct edgeuse *eur;
a1192 1
	NMG_CK_FACEUSE(eu->up.lu_p->up.fu_p);
d1194 1
d1245 2
a1246 2
char *str;
struct edgeuse *eu;
d1248 2
a1249 1
	pointp_t eup, matep;
@


1.41
log
@Modified MKPAD macro to permit arbitrary user-provided string
without blowing data space to bits in the process.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.40 93/03/06 00:01:56 butler Exp Locker: mike $ (BRL)";
d906 1
a906 1
				rt_log("bad edgeuse mate\n");
d929 1
a929 1
			rt_log("unclosed space\n");
@


1.40
log
@added display of vu_hd struct to printing of vertex struct in nmg_pr_v()
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.39 1993/03/03 01:53:39 mike Exp butler $ (BRL)";
d353 7
a359 1
static char padstr[32];
d361 5
a365 2
	if (!_h) { _h = padstr; bzero(h, sizeof(padstr)); } \
	else { if (strlen(_h) < sizeof(padstr)-4) (void)strcat(_h, "   "); } }
@


1.39
log
@V3RPP_OVERLAP, DIST_PT_PLANE
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.38 93/03/03 05:35:33 butler Exp Locker: mike $ (BRL)";
d778 5
@


1.38
log
@changed nmg_pr_fu to call nmg_pr_f
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.37 1992/11/16 23:09:00 mike Exp butler $ (BRL)";
d236 1
a236 1
			if (NMG_EXTENT_OVERLAP(fu2lg->min_pt, fu2lg->max_pt,
@


1.37
log
@Moved definitions into raytrace.h
@
text
@d4 1
a4 1
 *	As the name implies, these are miscelaneous routines that work with
d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.36 92/10/20 17:51:02 mike Exp Locker: mike $ (BRL)";
d528 2
@


1.36
log
@Improved comments and messages.  Added while hunting bugs elsewhere.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.35 92/08/05 22:30:45 mike Exp Locker: mike $ (BRL)";
a38 1
/* #define DEBUG_PLEU */
a39 10
NMG_EXTERN(void			nmg_pr_fu_briefly, (struct faceuse *fu,
				char *h) );
NMG_EXTERN(void			nmg_pr_lu_briefly, (struct loopuse *lu,
				char *h) );
NMG_EXTERN(void			nmg_pr_eu_briefly, (struct edgeuse *eu,
				char *h) );
NMG_EXTERN(void			nmg_pr_vu_briefly, (struct vertexuse *vu,
				char *h) );


d293 5
d846 2
a847 1
static int nmg_check_radial(eu)
d1331 3
@


1.35
log
@made nmg_purge_unwanted_intersection_points() more robust in handling
of loops that are not OT_SAME.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.34 92/07/23 05:06:47 butler Exp Locker: mike $ (BRL)";
a233 2
			fu2lg = fu2lu->l_p->lg_p;
			NMG_CK_LOOP_G(fu2lg);
d235 3
a237 3
			/* If this loop is just some drek deposited as part of
			 * the intersection operation, it doesn't really
			 * count
d243 1
a243 1
				rt_log("purge encountered %s in vertex list\n", nmg_orientation(fu2lu->orientation));
d245 2
d262 1
a262 1
				rt_log("This little bugger slipped in somehow\n");
@


1.34
log
@changed loop bounding box check to apply to only OT_SAME loops
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.33 92/07/22 03:57:05 butler Exp Locker: butler $ (BRL)";
d201 2
d206 1
a206 1
		rt_log(" purge here (0x%08x, 0x%08x)\n", vert_list, fu);
d212 3
d216 7
d234 2
a235 1
			NMG_CK_LOOP_G(fu2lu->l_p->lg_p);
d241 3
d245 1
a245 1
			    	continue;
d247 2
a248 3
			if (NMG_EXTENT_OVERLAP(
			   fu2lu->l_p->lg_p->min_pt, fu2lu->l_p->lg_p->max_pt,
			    lu->l_p->lg_p->min_pt,   lu->l_p->lg_p->max_pt)) {
d253 6
a272 21
		} else if (rt_g.NMG_debug & DEBUG_POLYSECT) {
			rt_log("keep vu: 0x%08x (%g %g %g) lu: 0x%08x\n",
				vu,
				vu->v_p->vg_p->coord[0],
				vu->v_p->vg_p->coord[1],
				vu->v_p->vg_p->coord[2],
				lu);
			rt_log("\tlu BBox: %g %g %g  %g %g %g\n",
				lu->l_p->lg_p->min_pt[0],
				lu->l_p->lg_p->min_pt[1],
				lu->l_p->lg_p->min_pt[2],
				lu->l_p->lg_p->max_pt[0],
				lu->l_p->lg_p->max_pt[1],
				lu->l_p->lg_p->max_pt[2]);
			rt_log("\tfu2lu BBox: %g %g %g  %g %g %g\n",
				fu2lu->l_p->lg_p->min_pt[0],
				fu2lu->l_p->lg_p->min_pt[1],
				fu2lu->l_p->lg_p->min_pt[2],
				fu2lu->l_p->lg_p->max_pt[0],
				fu2lu->l_p->lg_p->max_pt[1],
				fu2lu->l_p->lg_p->max_pt[2]);
@


1.33
log
@added nmg_purge_unwanted_intersection_points()
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.32 92/07/01 01:32:58 butler Exp Locker: butler $ (BRL)";
d228 1
a228 2
			if (fu2lu->orientation != OT_SAME &&
			    fu2lu->orientation != OT_OPPOSITE)
@


1.32
log
@added nmg_count_shell_kids()
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.31 92/02/24 23:29:31 mike Exp Locker: butler $ (BRL)";
d119 4
d178 101
d646 1
a646 1
	rt_log("%sLOOPUSE %8x, lumate_p=x%x (%s)\n",
@


1.31
log
@Improved printing of nmg_pr_eg
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.30 92/02/21 06:41:59 butler Exp Locker: butler $ (BRL)";
d1232 44
@


1.30
log
@added nmg_pr_eg to print edge geometry struct
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.29 91/06/13 05:44:08 butler Exp Locker: butler $ (BRL)";
d562 1
a562 1
nmg_pr_eg(eg, h);
d569 4
a572 2
	rt_log("%sEDGE_G %8x %d  pt:(%f %f %f)  dir:(%f %f %f)",
		h, eg, eg->usage, V3ARGS(eg->e_pt), V3ARGS(eg->e_dir));
@


1.29
log
@intermediate checkpoint of revisions.  ray tracing development still in
progress.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.28 91/05/18 03:03:23 mike Exp $ (BRL)";
d561 14
d590 4
a593 1
	
d596 1
@


1.28
log
@Converted to new tolerance interface
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.27 91/04/03 02:30:44 mike Exp $ (BRL)";
d54 2
a55 1
int nmg_tbl(b, func, p)
d180 2
a181 1
int nmg_in_or_ref(vu, b)
d200 2
a201 1
char *nmg_orientation(orientation)
d221 2
a222 1
void nmg_pr_orient(orientation, h)
d237 2
a238 1
void nmg_pr_m(m)
d262 2
a263 1
void nmg_pr_r(r, h)
d289 2
a290 1
void nmg_pr_sa(sa, h)
d310 2
a311 1
void nmg_pr_lg(lg, h)
d327 2
a328 1
void nmg_pr_fg(fg, h)
d348 2
a349 1
void nmg_pr_s(s, h)
d389 2
a390 1
void nmg_pr_f(f, h)
d406 2
a407 1
void nmg_pr_fu(fu, h)
d437 2
a438 1
void nmg_pr_fu_briefly(fu, h)
d455 2
a456 1
void nmg_pr_l(l, h)
d475 2
a476 1
void nmg_pr_lu(lu, h)
d529 2
a530 1
void nmg_pr_lu_briefly(lu, h)
d561 2
a562 1
void nmg_pr_e(e, h)
d580 2
a581 1
void nmg_pr_eu(eu, h)
d612 2
a613 1
void nmg_pr_eu_briefly(eu, h)
d626 2
a627 1
void nmg_pr_vg(vg, h)
d644 2
a645 1
void nmg_pr_v(v, h)
d665 2
a666 1
void nmg_pr_vu(vu, h)
d695 2
a696 1
void nmg_pr_vu_briefly(vu, h)
d820 2
a821 1
int nmg_ck_closed_surf(s)
d896 2
a897 1
struct shell *nmg_polytonmg(fp, r, tol)
d999 2
a1000 1
struct loopuse *nmg_lu_of_vu(vu)
d1018 2
a1019 1
struct shell *nmg_lups(lu)
d1033 2
a1034 1
struct shell *nmg_eups(eu)
d1049 2
a1050 1
struct edgeuse *nmg_faceradial(eu)
d1072 3
a1074 7
/*	N M G _ M A N I F O L D _ F A C E
 *
 *	Determine if a face is a manifold or non-manifold
 *
 *	Return
 *	1	face is manifold
 *	0	face is non-manifold (has dangling edge)
d1076 3
a1078 2
int nmg_manifold_face(fu)
struct faceuse *fu;
d1080 2
a1081 2
	struct loopuse *lu;
	struct edgeuse *eu, *eur;
d1083 3
a1085 2
	for(RT_LIST_FOR(lu, loopuse, &fu->lu_hd)) {
	    NMG_CK_LOOPUSE(lu);
d1087 3
a1089 6
	    if (RT_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_EDGEUSE_MAGIC) {
	        /* go looking around each edge for a face of the same
	         * shell which isn't us and isn't our mate.  If we
	         * find us or our mate before another face of this
	         * shell, we are non-manifold.
	         */
d1091 8
a1098 17
	    	for (RT_LIST_FOR(eu, edgeuse, &lu->down_hd)) {

	            eur = eu->radial_p;
	            if ( eur == eu->eumate_p) return(0);

	            do {

		    	if (eur == eu->eumate_p)
		    		return(0);

	                if (*eur->up.magic_p == NMG_LOOPUSE_MAGIC &&
			    *eur->up.lu_p->up.magic_p == NMG_FACEUSE_MAGIC &&
			    eur->up.lu_p->up.fu_p->s_p == fu->s_p)
	            		break;

	                eur = eur->eumate_p->radial_p;
	            } while (eur != eu->radial_p);
a1099 1
	    }
d1101 1
a1101 2

	return(1);
d1104 1
d1108 2
a1109 1
void nmg_euprint(str, eu)
d1211 1
@


1.27
log
@Added nmg_pr_*_briefly() routines.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.26 91/03/01 19:46:44 mike Exp $ (BRL)";
d853 2
a854 1
/*	P O L Y T O N M G
d872 4
a875 3
struct shell *polytonmg(fd, r)
FILE *fd;
struct nmgregion *r;
d894 1
a894 1
	if (fscanf(fd, "%d %d", &num_pts, &num_facets) != 2)
d913 1
a913 1
		if (fscanf(fd, "%lg %lg %lg", &p[0], &p[1], &p[2]) != 3)
d927 1
a927 1
		if (fscanf(fd, "%d", &pts_this_face) != 1)
d942 1
a942 1
			if (fscanf(fd, "%d", &j) != 1)
d955 1
a955 1
		    1.0e-6 ) )  {
@


1.26
log
@Promoted test-and-set macros to nmg.h
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.25 91/02/28 02:06:01 mike Exp $ (BRL)";
d41 8
d50 1
d198 17
a215 8








d425 17
a472 4
	if (!lu || lu->l.magic != NMG_LOOPUSE_MAGIC) {
		rt_log("bad loopuse magic\n");
		Return;
	}
d514 31
a570 4
	if (!eu || eu->l.magic != NMG_EDGEUSE_MAGIC) {
		rt_log("bad edgeuse magic\n");
		Return;
	}
d594 13
d670 21
@


1.25
log
@Added nmg_rebound()
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.24 91/02/07 20:32:39 mike Exp $ (BRL)";
a1022 2
#define FIRST_TIME(p)	( flags[(p)->index]++ == 0 )

d1064 1
a1064 1
					if( FIRST_TIME(l) )
d1075 1
a1075 1
				if( FIRST_TIME(f) )
d1084 1
a1084 1
				if( FIRST_TIME(l) )
d1092 1
a1092 1
			if( FIRST_TIME(s) )
@


1.24
log
@Changed from NMG_LIST macros to RT_LIST macros, from rtlist.h
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.23 91/01/14 23:24:37 mike Exp $ (BRL)";
d1021 82
@


1.23
log
@externs.h must come after machine.h
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.22 90/12/08 02:22:17 mike Exp $ (BRL)";
a41 64
/*
 *			N M G _ I D E N T I F Y _ M A G I C
 *
 *  Given a number which has been found in the magic number field of
 *  a structure (which is typically the first entry),
 *  determine what kind of structure this magic number pertains to.
 *  This is called by the macro NMG_CK_MAGIC() to provide a "hint"
 *  as to what sort of pointer error might have been made.
 */
char *nmg_identify_magic( magic )
long	magic;
{
	switch(magic)  {
	default:
		return("Unknown");
	case NMG_MODEL_MAGIC:
		return("model");
	case NMG_MODEL_A_MAGIC:
		return("model_a");
	case NMG_REGION_MAGIC:
		return("region");
	case NMG_REGION_A_MAGIC:
		return("region_a");
	case NMG_SHELL_MAGIC:
		return("shell");
	case NMG_SHELL_A_MAGIC:
		return("shell_a");
	case NMG_FACE_MAGIC:
		return("face");
	case NMG_FACE_G_MAGIC:
		return("face_g");
	case NMG_FACEUSE_MAGIC:
		return("faceuse");
	case NMG_FACEUSE_A_MAGIC:
		return("faceuse_a");
	case NMG_LOOP_MAGIC:
		return("loop");
	case NMG_LOOP_G_MAGIC:
		return("loop_g");
	case NMG_LOOPUSE_MAGIC:
		return("loopuse");
	case NMG_LOOPUSE_A_MAGIC:
		return("loopuse_a");
	case NMG_EDGE_MAGIC:
		return("edge");
	case NMG_EDGE_G_MAGIC:
		return("edge_g");
	case NMG_EDGEUSE_MAGIC:
		return("edgeuse");
	case NMG_EDGEUSE_A_MAGIC:
		return("edgeuse_a");
	case NMG_VERTEX_MAGIC:
		return("vertex");
	case NMG_VERTEX_G_MAGIC:
		return("vertex_g");
	case NMG_VERTEXUSE_MAGIC:
		return("vertexuse");
	case NMG_VERTEXUSE_A_MAGIC:
		return("vertexuse_a");
	case NMG_LIST_MAGIC:
		return("nmg_list");
	}
}

d227 1
a227 1
	for( NMG_LIST( r, nmgregion, &m->r_hd ) )  {
d259 1
a259 1
	for( NMG_LIST( s, shell, &r->s_hd ) )  {
d344 1
a344 1
	for( NMG_LIST( fu, faceuse, &s->fu_hd ) )  {
d348 1
a348 1
	for( NMG_LIST( lu, loopuse, &s->lu_hd ) )  {
d352 1
a352 1
	for( NMG_LIST( eu, edgeuse, &s->eu_hd ) )  {
d401 1
a401 1
	for( NMG_LIST( lu, loopuse, &fu->lu_hd ) )  {
d466 1
a466 1
	magic1 = NMG_LIST_FIRST_MAGIC( &lu->down_hd );
d468 1
a468 1
		vu = NMG_LIST_PNEXT( vertexuse, &lu->down_hd );
d473 1
a473 1
		for( NMG_LIST( eu, edgeuse, &lu->down_hd ) )  {
d715 1
a715 1
	for( NMG_LIST( fu, faceuse, &s->fu_hd ) )  {
d717 1
a717 1
		for( NMG_LIST( lu, loopuse, &fu->lu_hd ) )  {
d719 1
a719 1
			magic1 = NMG_LIST_FIRST_MAGIC( &lu->down_hd );
d721 1
a721 1
				for( NMG_LIST( eu, edgeuse, &lu->down_hd ) )  {
d727 1
a727 1
				vu = NMG_LIST_FIRST( vertexuse, &lu->down_hd );
d753 1
a753 1
	for( NMG_LIST( s, shell, &r->s_hd ) )  {
d854 1
a854 1
		lu = NMG_LIST_FIRST( loopuse, &fu->lu_hd );
d856 1
a856 1
		eu = NMG_LIST_FIRST( edgeuse, &lu->down_hd );
d859 2
a860 2
		    NMG_LIST_PNEXT(edgeuse,eu)->vu_p->v_p->vg_p->coord,
		    NMG_LIST_PLAST(edgeuse,eu)->vu_p->v_p->vg_p->coord,
d869 1
a869 1
		if( NMG_LIST_IS_EMPTY( &v[i]->vu_hd ) )  continue;
d963 1
a963 1
	for(NMG_LIST(lu, loopuse, &fu->lu_hd)) {
d966 1
a966 1
	    if (NMG_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_EDGEUSE_MAGIC) {
d973 1
a973 1
	    	for (NMG_LIST(eu, edgeuse, &lu->down_hd)) {
@


1.22
log
@Absorbed some odds and ends from nmg_bool.c
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/librt/RCS/nmg_misc.c,v 1.21 90/05/24 23:23:35 mike Exp $ (BRL)";
a32 1
#include "externs.h"
d35 1
@


1.21
log
@GET_xxx() macros now require struct model pointers.
Added index numbers to all structs.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.20 90/05/24 20:47:41 mike Exp $ (BRL)";
d228 15
d244 8
d253 9
d924 2
a925 1
		    NMG_LIST_PLAST(edgeuse,eu)->vu_p->v_p->vg_p->coord ) )  {
d938 147
@


1.20
log
@Moved checkers to nmg_ck.c
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.19 90/05/24 19:02:19 mike Exp $ (BRL)";
d825 1
d828 1
d845 1
a845 1
		GET_VERTEX(v[i]);
@


1.19
log
@Changed arg from char to int.
@
text
@d5 1
a5 5
 *	the NMG structures.  Ordinarily, applications will not need these
 *	routines once they have been debugged.  As a result, these routines
 *	are in a separate file so that they may be omitted from linked
 *	executables that do not need them.  Someday, all machines may have
 *	shared library support.  Then this will be irrelevant.
a8 1
 *		_ck_ routines to check consistency
d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.18 90/05/23 19:43:43 mike Exp $ (BRL)";
d42 63
d106 124
d634 3
a636 1
/*	C H E C K _ R A D I A L
d645 1
a645 1
static int check_radial(eu)
d735 1
a735 1
 *	!0	status code from check_radial()
d754 1
a754 1
					if (status=check_radial(eu))
d775 1
a775 1
 *	!0	status code from check_radial()
a902 294
}


/************************************************************************
 *									*
 *			Checking Routines				*
 *									*
 ************************************************************************/


nmg_ck_e(eu, e, str)
struct edgeuse *eu;
struct edge *e;
char *str;
{
	char *errstr;
	struct edgeuse *eparent;
	errstr = rt_calloc(strlen(str)+128, 1, "nmg_ck_e error str");
	(void)sprintf(errstr, "%sedge %8x\n", str, e);
	
	NMG_CK_EDGE(e);
	NMG_CK_EDGEUSE(eu);

	eparent = e->eu_p;

	NMG_CK_EDGEUSE(eparent);
	NMG_CK_EDGEUSE(eparent->eumate_p);
	do {
		if (eparent == eu || eparent->eumate_p == eu) break;

		eparent = eparent->radial_p->eumate_p;
	} while (eparent != e->eu_p);

	if (eparent != eu && eparent->eumate_p != eu) rt_bomb(
		strcat(errstr, "Edge denies edgeuse parentage\n"));

	rt_free(errstr, "nmg_ck_e error str");
}

nmg_ck_vu(parent, vu, str)
long *parent;
struct vertexuse *vu;
char *str;
{
	char *errstr;

	errstr = rt_calloc(strlen(str)+128, 1, "nmg_ck_vu error str");
	(void)sprintf(errstr, "%svertexuse %8x\n", str, vu);
	
	if (vu->up.magic_p != parent) rt_bomb(
		strcat(errstr, "Vertexuse denies parentage\n"));

	rt_free(errstr, "nmg_ck_vu error str");
}

nmg_ck_eu(parent, eu, str)
long *parent;
struct edgeuse *eu;
char *str;
{
	char *errstr;
	struct edgeuse *eur, *eu_next, *eu_last;	

	errstr = rt_calloc(strlen(str)+128, 1, "nmg_ck_eu error str");
	(void)sprintf(errstr, "%sedgeuse %8x\n", str, eu);

	NMG_CK_EDGEUSE(eu);

	if (eu->up.magic_p != parent) rt_bomb(
		strcat(errstr, "Edgeuse child denies parentage\n"));

	if (*eu->eumate_p->up.magic_p != *eu->up.magic_p) rt_bomb(
		strcat(errstr, "eumate has differnt kind of parent\n"));
	if (*eu->up.magic_p == NMG_SHELL_MAGIC) {
		if (eu->eumate_p->up.s_p != eu->up.s_p) rt_bomb(
			strcat(errstr, "eumate in different shell\n"));

		eur = eu->radial_p;
		while (eur && eur != eu && eur != eu->eumate_p)
			eur = eur->eumate_p->radial_p;

		if (!eur) rt_bomb(strcat(errstr,
			"Radial trip from eu ended in null pointer\n"));


	} else if (*eu->up.magic_p == NMG_LOOPUSE_MAGIC) {
		if (eu->eumate_p->up.lu_p != eu->up.lu_p->lumate_p) rt_bomb(
			strcat(errstr, "eumate not in same loop\n"));

		eur = eu->radial_p;
		while (eur && eur != eu->eumate_p && eur != eu)
			eur = eur->eumate_p->radial_p;

		if (!eur) rt_bomb(
			strcat(errstr, "radial path leads to null ptr\n"));
		else if (eur == eu) rt_bomb(
			strcat(errstr, "Never saw eumate\n"));

		eu_next = NMG_LIST_PNEXT_CIRC(edgeuse, eu);
		if (eu_next->vu_p->v_p != eu->eumate_p->vu_p->v_p)
			rt_bomb("nmg_ck_eu: next and mate don't share vertex\n");

		eu_last = NMG_LIST_PLAST_CIRC(edgeuse, eu);
		if (eu_last->eumate_p->vu_p->v_p != eu->vu_p->v_p)
			rt_bomb("nmg_ck_eu: edge and last-mate don't share vertex\n");

	} else {
		rt_bomb(strcat(errstr, "Bad edgeuse parent\n"));
	}

	NMG_CK_EDGE(eu->e_p);
	nmg_ck_e(eu, eu->e_p, errstr);

	NMG_CK_VERTEXUSE(eu->vu_p);
	nmg_ck_vu(&eu->l.magic, eu->vu_p, errstr);

	rt_free(errstr, "nmg_ck_eu error str");
}

nmg_ck_lg(l, lg, str)
struct loop *l;
struct loop_g *lg;
char *str;
{
	char *errstr;
	errstr = rt_calloc(strlen(str)+128, 1, "nmg_ck_lg error str");
	(void)sprintf(errstr, "%sloop_g %8x\n", str, lg);

	NMG_CK_LOOP_G(lg);
	NMG_CK_LOOP(l);

	rt_free(errstr, "nmg_ck_lg error str");
}

nmg_ck_l(lu, l, str)
struct loopuse *lu;
struct loop *l;
char *str;
{
	char *errstr;
	errstr = rt_calloc(strlen(str)+128, 1, "nmg_ck_l error str");
	(void)sprintf(errstr, "%sloop %8x\n", str, l);

	NMG_CK_LOOP(l);
	NMG_CK_LOOPUSE(lu);

	if (l->lu_p != lu && l->lu_p->lumate_p != lu) rt_bomb(
		strcat(errstr, "Cannot get from loop to loopuse\n"));

	if (l->lg_p) nmg_ck_lg(l, l->lg_p, errstr);

	rt_free(errstr, "");
}

nmg_ck_lu(parent, lu, str)
long *parent;
struct loopuse *lu;
char *str;
{
	struct edgeuse *eu;
	struct vertexuse *vu;
	char *errstr;
	int l;
	int edgeuse_num=0;
	long	magic1;

	errstr = rt_calloc(strlen(str)+128, 1, "nmg_ck_lu error str");
	(void)sprintf(errstr, "%sloopuse %8x\n", str, lu);
	
	NMG_CK_LOOPUSE(lu);

	if (lu->up.magic_p != parent) rt_bomb(
		strcat(errstr, "loopuse child denies parentage\n") );

	/* check the parent of lu and lumate WRT each other */
	NMG_CK_LOOPUSE(lu->lumate_p);
	if (*lu->lumate_p->up.magic_p != *lu->up.magic_p) rt_bomb(
		strcat(errstr,"loopuse mate has different kind of parent\n"));

	if (*lu->up.magic_p == NMG_SHELL_MAGIC) {
		if (lu->lumate_p->up.s_p != lu->up.s_p) rt_bomb(
			strcat(errstr, "Lumate not in same shell\n") );
	} else if (*lu->up.magic_p == NMG_FACEUSE_MAGIC) {
		if (lu->lumate_p->up.fu_p != lu->up.fu_p->fumate_p) rt_bomb(
			strcat(errstr, "lumate part of different face\n"));
	} else {
		rt_bomb(strcat(errstr, "Bad loopuse parent type\n"));
	}

	NMG_CK_LOOP(lu->l_p);
	nmg_ck_l(lu, lu->l_p, errstr);

	/* check the children of the loopuse */
	magic1 = NMG_LIST_FIRST_MAGIC( &lu->down_hd );
	if (magic1 == NMG_VERTEXUSE_MAGIC) {
		vu = NMG_LIST_FIRST( vertexuse, &lu->down_hd );
		NMG_CK_VERTEXUSE(vu);
		nmg_ck_vu(&lu->l.magic, vu, errstr);
	} else if (magic1 == NMG_EDGEUSE_MAGIC) {
		l = strlen(errstr);
		for( NMG_LIST( eu, edgeuse, &lu->down_hd ) )  {
			NMG_CK_EDGEUSE(eu);
			(void)sprintf(&errstr[l], "%sedgeuse #%d (%8x)\n",
				errstr, edgeuse_num++, eu);
			nmg_ck_eu(&lu->l.magic, eu, errstr);
		}
	} else {
		rt_bomb(strcat(errstr, "Bad loopuse down pointer\n") );
	}
	rt_free(errstr, "nmg_ck_lu error str");
}

nmg_ck_fg(f, fg, str)
struct face *f;
struct face_g *fg;
char *str;
{
	char *errstr;
	errstr = rt_calloc(strlen(str)+128, 1, "nmg_ck_fg error str");
	(void)sprintf(errstr, "%sFace_g %8x\n", str, f);

	NMG_CK_FACE_G(fg);
	if (fg->N[X]==0.0 && fg->N[Y]==0.0 && fg->N[Z]==0.0 && fg->N[H]!=0.0){
		(void)sprintf(&errstr[strlen(errstr)],
			"bad NMG plane equation %fX + %fY + %fZ = %f\n",
			fg->N[X], fg->N[Y], fg->N[Z], fg->N[H]);
	        rt_bomb(errstr);
	}

	rt_free(errstr, "nmg_ck_fg error str");
}

nmg_ck_f(fu, f, str)
struct faceuse *fu;
struct face *f;
char *str;
{
	char *errstr;
	errstr = rt_calloc(strlen(str)+128, 1, "nmg_ck_f error str");
	(void)sprintf(errstr, "%sFace %8x\n", str, f);

	NMG_CK_FACE(f);
	NMG_CK_FACEUSE(fu);
	NMG_CK_FACE_G(f->fg_p);
	if (f->fu_p != fu && f->fu_p->fumate_p != fu) rt_bomb(
		strcat(errstr,"Cannot get from face to \"parent faceuse\"\n"));

	if (f->fg_p) nmg_ck_fg(f, f->fg_p, errstr);

	rt_free(errstr, "nmg_ck_f error str");
}

nmg_ck_fu(s, fu, str)
struct shell *s;
struct faceuse *fu;
char *str;
{
	char *errstr;
	int l;
	int loop_number = 0;
	struct loopuse *lu;

	NMG_CK_FACEUSE(fu);
	NMG_CK_SHELL(s);

	errstr = rt_calloc(strlen(str)+128, 1, "nmg_ck_fu error str");
	(void)sprintf(errstr, "%sFaceuse %8x\n", str, fu);

	if (fu->s_p != s) rt_bomb(
		strcat(errstr, "faceuse child denies shell parentage\n") );

	if( NMG_LIST_PNEXT_PLAST( faceuse, fu ) )
		rt_bomb( strcat(errstr, "Faceuse not lastward of next faceuse\n") );

	if( NMG_LIST_PLAST_PNEXT( faceuse, fu ) )
		rt_bomb( strcat(errstr, "Faceuse not nextward from last faceuse\n") );

	NMG_CK_FACEUSE(fu->fumate_p);
	if (fu->fumate_p->fumate_p != fu) rt_bomb(
		strcat(errstr, "Faceuse not fumate of fumate\n") );

	if (fu->fumate_p->s_p != s) rt_bomb(
		strcat(errstr, "faceuse mates not in same shell\n") );

	nmg_ck_f(fu, fu->f_p, errstr);

	l = strlen(errstr);
	for( NMG_LIST( lu, loopuse, &fu->lu_hd ) )  {
		NMG_CK_LOOPUSE(lu);
		(void)sprintf(&errstr[l] , "%sloopuse #%d (%8x)\n", 
			errstr, loop_number++, lu);
		nmg_ck_lu(&fu->l.magic, lu, errstr);
	}
	rt_free(errstr, "nmg_ck_fu error str");
@


1.18
log
@Plotting routines moved to nmg_plot.c
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.17 90/05/23 00:32:49 mike Exp $ (BRL)";
d50 2
a51 2
void nmg_pr_orient(o, h)
char	o;
d54 1
a54 1
	switch (o) {
@


1.17
log
@Improved some error messages
@
text
@d13 1
a13 2
 *		_pl_ routines use the 3d plot library to create 3d plots of
 *			NMG structs
d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.16 90/05/23 00:29:11 butler Exp $ (BRL)";
a451 471

static void nmg_pl_v(fp, v, b, R, G, B)
FILE *fp;
struct vertex *v;
struct nmg_ptbl *b;
unsigned char R, G, B;
{
	pointp_t p;
	static char label[128];

	if (nmg_tbl(b, TBL_LOC, &v->magic) >= 0) return;

	(void)nmg_tbl(b, TBL_INS, &v->magic);

	NMG_CK_VERTEX(v);
	NMG_CK_VERTEX_G(v->vg_p);
	p = v->vg_p->coord;
	pl_color(fp, 255, 255, 255);

	pd_3move(fp, p[0], p[1], p[2]);
	if (rt_g.NMG_debug & DEBUG_LABEL_PTS) {
		(void)sprintf(label, "%g %g %g", p[0], p[1], p[2]);
		pl_label(fp, label);
	}
	pd_3point(fp, p[0], p[1], p[2]);


	pl_color(fp, R, G, B);
}



#define LEE_DIVIDE_TOL	(1.0e-5)	/* sloppy tolerance */

static void nmg_eu_coord(eu, base)
struct edgeuse *eu;
point_t base;
{
	fastf_t dist1;
	struct edgeuse *peu;
	struct loopuse *lu;
	vect_t v_eu,		/* vector of edgeuse */
		v_other,	/* vector of last edgeuse */
		N;		/* normal vector for this edgeuse's face */
	pointp_t pt_other, pt_eu;

	NMG_CK_EDGEUSE(eu);
	NMG_CK_VERTEXUSE(eu->vu_p);
	NMG_CK_VERTEX(eu->vu_p->v_p);
	NMG_CK_VERTEX_G(eu->vu_p->v_p->vg_p);

	NMG_CK_EDGEUSE(eu->eumate_p);
	NMG_CK_VERTEXUSE(eu->eumate_p->vu_p);
	NMG_CK_VERTEX(eu->eumate_p->vu_p->v_p);
	NMG_CK_VERTEX_G(eu->eumate_p->vu_p->v_p->vg_p);

	pt_eu = eu->vu_p->v_p->vg_p->coord;
	pt_other = eu->eumate_p->vu_p->v_p->vg_p->coord;

	/* v_eu is the vector of the edgeuse
	 * mag is the magnitude of the edge vector
	 */
	VSUB2(v_eu, pt_other, pt_eu); 

	if (*eu->up.magic_p == NMG_SHELL_MAGIC || 
	    (*eu->up.magic_p == NMG_LOOPUSE_MAGIC &&
	     *eu->up.lu_p->up.magic_p != NMG_FACEUSE_MAGIC) ) {

		VMOVE(base, pt_eu);
	     	dist1 = MAGNITUDE(v_eu);
	     	/* whichever component of the edge is the least significant,
	     	 * we perturb 
	     	if (base[0] <= base[1] && base[0] <= base[2])
	     		base[0] += dist1 * 0.1;
	     	else if (base[1] <= base[0] && base[1] <= base[2])
	     		base[1] += dist1 * 0.1;
	     	else if (base[2] <= base[1] && base[2] <= base[0])
	     		base[2] += dist1 * 0.1;
	     	*/
		return;
	}

	if (*eu->up.magic_p != NMG_LOOPUSE_MAGIC ||
	    *eu->up.lu_p->up.magic_p != NMG_FACEUSE_MAGIC) {
		rt_log("in %s at %d edgeuse has bad parent\n", __FILE__, __LINE__);
		rt_bomb("nmg_eu_coord\n");
	}

	lu = eu->up.lu_p;

	NMG_CK_FACE(lu->up.fu_p->f_p);
	NMG_CK_FACE_G(lu->up.fu_p->f_p->fg_p);

#ifdef DEBUG_PLEU
	HPRINT("Normal", lu->up.fu_p->f_p->fg_p->N);
	nmg_pr_orient(lu->up.fu_p->orientation, "");
#endif
	VMOVE(N, lu->up.fu_p->f_p->fg_p->N);
	if (lu->up.fu_p->orientation == OT_OPPOSITE) {
		VREVERSE(N,N);
	}
#ifdef DEBUG_PLEU
	VPRINT("Adjusted Normal", N);
#endif

	VUNITIZE(v_eu);

	/* find a point not on the edge */
	peu = NMG_LIST_PLAST_CIRC( edgeuse, eu );
	pt_other = peu->vu_p->v_p->vg_p->coord;
	dist1 = rt_dist_line_point(pt_eu, v_eu, pt_other);
	while (NEAR_ZERO(dist1, LEE_DIVIDE_TOL) && peu != eu) {
		peu = NMG_LIST_PLAST_CIRC( edgeuse, peu );
		pt_other = peu->vu_p->v_p->vg_p->coord;
		dist1 = rt_dist_line_point(pt_eu, v_eu, pt_other);
	}

	/* make a vector from the "last" edgeuse (reversed) */
	VSUB2(v_other, pt_other, pt_eu); VUNITIZE(v_other);

	/* combine the two vectors to get a vector
	 * pointing to the location where the edgeuse
	 * should start
	 */
	VADD2(v_other, v_other, v_eu); VUNITIZE(v_other);
	
	/* compute the start of the edgeuse */
	VJOIN2(base, pt_eu, 0.125,v_other, 0.05,N);
}


/*	E U _ C O O R D S
 *
 *	compute a pair of coordinates for representing an edgeuse
 */
static nmg_eu_coords(eu, base, tip)
struct edgeuse *eu;
point_t base, tip;
{
	vect_t eu_vec;

	NMG_CK_EDGEUSE(eu);

	nmg_eu_coord(eu, base);
	if (*eu->up.magic_p == NMG_SHELL_MAGIC ||
	    (*eu->up.magic_p == NMG_LOOPUSE_MAGIC &&
	    *eu->up.lu_p->up.magic_p == NMG_SHELL_MAGIC) ) {

		NMG_CK_EDGEUSE(eu->eumate_p);
		nmg_eu_coord( eu->eumate_p, tip );
	}
	else if (*eu->up.magic_p == NMG_LOOPUSE_MAGIC &&
	    *eu->up.lu_p->up.magic_p == NMG_FACEUSE_MAGIC) {
	    	register struct edgeuse *eutmp;
		eutmp = NMG_LIST_PNEXT_CIRC(edgeuse, eu);
		NMG_CK_EDGEUSE(eutmp);
		nmg_eu_coord( eutmp, tip );
	} else
		rt_bomb("nmg_eu_coords: What's going on?\n");

	/* compute edgeuse vector */
	VSUB2SCALE(eu_vec, tip, base, 0.6);

	/* compute tip location from edgeuse vector */
	VADD2(tip, base, eu_vec);
}



static void nmg_eu_radial(fp, eu, tip, R, G, B)
FILE *fp;
struct edgeuse *eu;
point_t tip;
unsigned char R, G, B;
{
	point_t b2, t2, p;
	vect_t v;

	NMG_CK_EDGEUSE(eu->radial_p);
	NMG_CK_VERTEXUSE(eu->radial_p->vu_p);
	NMG_CK_VERTEX(eu->radial_p->vu_p->v_p);
	NMG_CK_VERTEX_G(eu->radial_p->vu_p->v_p->vg_p);

	nmg_eu_coords(eu->radial_p, b2, t2);

	/* form vector of other edgeuse and scale down */
	VSUB2SCALE(v, t2, b2, 0.8);

	/* find point along other edgeuse where radial pointer should touch */
	VADD2(p, b2, v);

	pl_color(fp, R, G-20, B);
	pd_3line(fp, tip[0], tip[1], tip[2], p[0], p[1], p[2]);
	pl_color(fp, R, G, B);
}

static void nmg_eu_last(fp, eu, base)
FILE *fp;
struct edgeuse *eu;
point_t base;
{
	point_t b2, t2, p;
	struct edgeuse	*eulast;
	vect_t v;

	NMG_CK_EDGEUSE(eu);
	eulast = NMG_LIST_PLAST_CIRC( edgeuse, eu );
	NMG_CK_EDGEUSE(eulast);
	NMG_CK_VERTEXUSE(eulast->vu_p);
	NMG_CK_VERTEX(eulast->vu_p->v_p);
	NMG_CK_VERTEX_G(eulast->vu_p->v_p->vg_p);

	nmg_eu_coords(eulast->radial_p, b2, t2);

	/* form vector of last edgeuse's radial edgeuse and scale down */
	VSUB2SCALE(v, t2, b2, 0.8);

	/* find point along last edgeuse's radial edgeuse
	 * where radial pointer should touch 
	 */
	VADD2(p, b2, v);

	/* get coordinates of last edgeuse */
	nmg_eu_coords(eulast, b2, t2);

	/* form vector of last edgeuse's radial pointer and scale down */
	VSUB2SCALE(v, p, t2, 0.2);

	/* find point along other edgeuse's radial pointer where 
	 * last pointer should touch
	 */
	VADD2(p, t2, v);

	pl_color(fp, 0, 200, 0);
	pd_3line(fp, base[0], base[1], base[2], p[0], p[1], p[2]);
}

static void nmg_eu_next(fp, eu, tip)
FILE *fp;
struct edgeuse *eu;
point_t tip;
{
	point_t b2, t2;
	register struct edgeuse	*nexteu;

	NMG_CK_EDGEUSE(eu);
	nexteu = NMG_LIST_PNEXT_CIRC( edgeuse, eu );
	NMG_CK_EDGEUSE(nexteu);
	NMG_CK_VERTEXUSE(nexteu->vu_p);
	NMG_CK_VERTEX(nexteu->vu_p->v_p);
	NMG_CK_VERTEX_G(nexteu->vu_p->v_p->vg_p);

	nmg_eu_coords(nexteu, b2, t2);

	pl_color(fp, 0, 100, 0);
	pd_3line(fp, tip[0], tip[1], tip[2], b2[0], b2[1], b2[2]);
}


static nmg_pl_e(fp, e, b, R, G, B)
FILE *fp;
struct edge *e;
struct nmg_ptbl *b;
unsigned char R, G, B;
{
	pointp_t p0, p1;
	point_t end0, end1;
	vect_t v;

	if (nmg_tbl(b, TBL_LOC, &e->magic) >= 0) return;

	(void)nmg_tbl(b, TBL_INS, &e->magic);
	
	NMG_CK_EDGEUSE(e->eu_p);
	NMG_CK_VERTEXUSE(e->eu_p->vu_p);
	NMG_CK_VERTEX(e->eu_p->vu_p->v_p);
	NMG_CK_VERTEX_G(e->eu_p->vu_p->v_p->vg_p);
	p0 = e->eu_p->vu_p->v_p->vg_p->coord;

	NMG_CK_VERTEXUSE(e->eu_p->eumate_p->vu_p);
	NMG_CK_VERTEX(e->eu_p->eumate_p->vu_p->v_p);
	NMG_CK_VERTEX_G(e->eu_p->eumate_p->vu_p->v_p->vg_p);
	p1 = e->eu_p->eumate_p->vu_p->v_p->vg_p->coord;

	/* leave a little room between the edge endpoints and the vertex
	 * compute endpoints by forming a vector between verets, scale vector
	 * and modify points
	 */
	VSUB2SCALE(v, p1, p0, 0.95);
	VADD2(end0, p0, v);
	VREVERSE(v, v);

	VADD2(end1, p1, v);

	pl_color(fp, R, G, B);
	pd_3line(fp, end0[0], end0[1], end0[2], end1[0], end1[1], end1[2]);
	nmg_pl_v(fp, e->eu_p->vu_p->v_p, b, R, G, B);
	nmg_pl_v(fp, e->eu_p->eumate_p->vu_p->v_p, b, R, G, B);
}


void nmg_pl_eu(fp, eu, b, R, G, B)
FILE *fp;
struct edgeuse *eu;
struct nmg_ptbl *b;
unsigned char R, G, B;
{
	point_t base, tip;

	

	NMG_CK_EDGEUSE(eu);
	NMG_CK_EDGE(eu->e_p);
	NMG_CK_VERTEXUSE(eu->vu_p);
	NMG_CK_VERTEX(eu->vu_p->v_p);
	NMG_CK_VERTEX_G(eu->vu_p->v_p->vg_p);

	NMG_CK_VERTEXUSE(eu->eumate_p->vu_p);
	NMG_CK_VERTEX(eu->eumate_p->vu_p->v_p);
	NMG_CK_VERTEX_G(eu->eumate_p->vu_p->v_p->vg_p);

	if (nmg_tbl(b, TBL_LOC, &eu->l.magic) >= 0) return;
	(void)nmg_tbl(b, TBL_INS, &eu->l.magic);

	nmg_pl_e(fp, eu->e_p, b, R, G, B);

	if (*eu->up.magic_p == NMG_LOOPUSE_MAGIC &&
	    *eu->up.lu_p->up.magic_p == NMG_FACEUSE_MAGIC) {

	    	nmg_eu_coords(eu, base, tip);
	    	if (eu->up.lu_p->up.fu_p->orientation == OT_SAME)
	    		R += 50;
		else if (eu->up.lu_p->up.fu_p->orientation == OT_OPPOSITE)
			R -= 50;
	    	else
	    		R = G = B = (unsigned char)255;

		pl_color(fp, R, G, B);

		pd_3line(fp, base[0], base[1], base[2],
			tip[0], tip[1], tip[2]);


	    	nmg_eu_radial(fp, eu, tip, R, G, B);
	    	nmg_eu_next(fp, eu, tip);
/*	    	nmg_eu_last(fp, eu, base); */
	    }
}

void nmg_pl_lu(fp, lu, b, R, G, B)
FILE *fp;
struct loopuse *lu;
struct nmg_ptbl *b;
unsigned char R, G, B;
{
	struct edgeuse	*eu;
	long		magic1;

	NMG_CK_LOOPUSE(lu);
	if (nmg_tbl(b, TBL_LOC, &lu->l.magic) >= 0) return;

	(void)nmg_tbl(b, TBL_INS, &lu->l.magic);

	magic1 = NMG_LIST_FIRST_MAGIC( &lu->down_hd );
	if (magic1 == NMG_VERTEXUSE_MAGIC &&
	    lu->orientation != OT_BOOLPLACE) {
	    	nmg_pl_v(fp, NMG_LIST_PNEXT(vertexuse, &lu->down_hd)->v_p,
	    		b, R, G, B );
	} else if (magic1 == NMG_EDGEUSE_MAGIC) {
		for( NMG_LIST( eu, edgeuse, &lu->down_hd ) )  {
			nmg_pl_eu(fp, eu, b, R, G, B);
		}
	}
}

void nmg_pl_fu(fp, fu, b, R, G, B)
FILE *fp;
struct faceuse *fu;
struct nmg_ptbl *b;
unsigned char R, G, B;
{
	struct loopuse *lu;

	NMG_CK_FACEUSE(fu);
	if (nmg_tbl(b, TBL_LOC, &fu->l.magic) >= 0) return;
	(void)nmg_tbl(b, TBL_INS, &fu->l.magic);

	for( NMG_LIST( lu, loopuse, &fu->lu_hd ) )  {
		nmg_pl_lu(fp, lu, b, R, G, B);
	}
}

void nmg_pl_s(fp, s)
FILE *fp;
struct shell *s;
{
	struct faceuse *fu;
	struct loopuse *lu;
	struct edgeuse *eu;
	struct nmg_ptbl b;


	NMG_CK_SHELL(s);

	/* get space for list of items processed */
	(void)nmg_tbl(&b, TBL_INIT, (long *)0);	

	for( NMG_LIST( fu, faceuse, &s->fu_hd ) )  {
		NMG_CK_FACEUSE(fu);
#if 0
		static unsigned color = 0xff;
#define Rcolor(_i)	(((_i&0x01)<<7)+32)
#define Gcolor(_i)	(((_i&0x02)<<6)+32)
#define Bcolor(_i)	(((_i&0x04)<<5)+32)
		nmg_pl_fu(fp, fu, &b, Rcolor(color), Gcolor(color), Bcolor(color));
		--color;
#else
		nmg_pl_fu(fp, fu, &b, 80, 100, 170);
#endif
	}

	for( NMG_LIST( lu, loopuse, &s->lu_hd ) )  {
		NMG_CK_LOOPUSE(lu);
		nmg_pl_lu(fp, lu, &b, 255, 0, 0);
	}

	for( NMG_LIST( eu, edgeuse, &s->eu_hd ) )  {
		NMG_CK_EDGEUSE(eu);
		NMG_CK_EDGE(eu->e_p);

		nmg_pl_eu(fp, eu, &b, (unsigned char)200, 
			(unsigned char)200, 
			(unsigned char)0);
	}
	if (s->vu_p) {
		nmg_pl_v(fp, s->vu_p->v_p, &b, 180, 180, 180);
	}

	if( NMG_LIST_IS_EMPTY( &s->fu_hd ) &&
	    NMG_LIST_IS_EMPTY( &s->lu_hd ) &&
	    NMG_LIST_IS_EMPTY( &s->eu_hd ) && !s->vu_p) {
	    	rt_log("WARNING nmg_pl_s() shell has no children\n");
	}

	(void)nmg_tbl(&b, TBL_FREE, (long *)NULL);
}


void nmg_pl_r(fp, r)
FILE *fp;
struct nmgregion *r;
{
	struct shell *s;

	for( NMG_LIST( s, shell, &r->s_hd ) )  {
		nmg_pl_s(fp, s);
	}
}

void nmg_pl_m(fp, m)
FILE *fp;
struct model *m;
{
	struct nmgregion *r;

	for( NMG_LIST( r, nmgregion, &m->r_hd ) )  {
		nmg_pl_r(fp, r);
	}
}


d722 7
a728 1
/**********************************************************************/
d773 1
a852 2


a872 2


a930 3



d970 1
a1012 82
}

static void plot_edge(fd, b, eu)
FILE *fd;
struct nmg_ptbl *b;
struct edgeuse *eu;
{
	struct edgeuse *eur = eu;
	do {
		nmg_pl_eu(fd, eur, b, 180, 180, 180);
		eur = eur->radial_p->eumate_p;
	} while (eur != eu);
}

void pl_isect_eu(fd, b, eu)
FILE *fd;
struct nmg_ptbl *b;
struct edgeuse *eu;
{
	struct edgeuse *eur;

	eur = eu;
	NMG_CK_EDGEUSE(eu);
	NMG_CK_LOOPUSE(eu->up.lu_p);
	NMG_CK_FACEUSE(eu->up.lu_p->up.fu_p);
	NMG_CK_SHELL(eu->up.lu_p->up.fu_p->s_p);

	do {
		NMG_CK_EDGEUSE(eur);

		if (*eur->up.magic_p == NMG_LOOPUSE_MAGIC &&
		    *eur->up.lu_p->up.magic_p == NMG_FACEUSE_MAGIC &&
		    eur->up.lu_p->up.fu_p->s_p != eu->up.lu_p->up.fu_p->s_p) {
			plot_edge(fd, b, eu);
		    	break;
		    }

		eur = eur->radial_p->eumate_p;
	} while (eur != eu);
}

void nmg_pl_isect(filename, s)
char *filename;
struct shell *s;
{
	struct faceuse *fu;
	struct loopuse *lu;
	struct edgeuse *eu;
	struct nmg_ptbl b;
	FILE *fd, *fopen();
	long	magic1;

	NMG_CK_SHELL(s);

	if ((fd=fopen(filename, "w")) == (FILE *)NULL) {
		(void)perror(filename);
		exit(-1);
	}

	(void)nmg_tbl(&b, TBL_INIT, (long *)NULL);

	rt_log("Plotting to \"%s\"\n", filename);
	for( NMG_LIST( fu, faceuse, &s->fu_hd ) )  {
		NMG_CK_FACEUSE(fu);
		for( NMG_LIST( lu, loopuse, &fu->lu_hd ) )  {
			NMG_CK_LOOPUSE(lu);
			magic1 = NMG_LIST_FIRST_MAGIC( &lu->down_hd );
			if (magic1 == NMG_EDGEUSE_MAGIC) {
				for( NMG_LIST( eu, edgeuse, &lu->down_hd ) )  {
					NMG_CK_EDGEUSE(eu);
					pl_isect_eu(fd, &b, eu);
				}
			} else if (magic1 == NMG_VERTEXUSE_MAGIC) {
				;
			} else {
				rt_bomb("nmg_pl_isect() bad loopuse down\n");
			}
		}
	}
	(void)nmg_tbl(&b, TBL_FREE, (long *)NULL);

	(void)fclose(fd);
@


1.16
log
@Various improvements
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.15 90/05/22 00:40:59 mike Exp $ (BRL)";
d894 1
a894 3
		rt_log("At %d in %s shell has no children\n",
			__LINE__, __FILE__);
		/* rt_bomb("exiting\n"); */
d1119 1
a1119 1
		rt_bomb("Error in first line of poly file\n");
d1138 1
a1138 1
			rt_bomb("Error reading point");
d1152 1
a1152 1
			rt_bomb("error getting pt count for this face");
d1167 1
a1167 1
				rt_bomb("error getting point index for v in f");
d1559 1
a1559 3
				rt_log("in %s at %d bad loopuse child\n",
					__FILE__, __LINE__);
				rt_bomb("BAD NMG struct\n");
@


1.15
log
@Shortened coord print
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.14 90/05/21 22:05:08 butler Exp $ (BRL)";
a484 114

#if 0
/*	N M G _ O F F S E T _ V E R T E X U S E
 *
 *	Compute new coordinates for vertex as if all adjoining faces
 *	of vertexuse were offset by some scalar distance "s".  The result
 *	is returned in "pt".
 *
 *
 *	Return
 *		-2	Offset faces do not intersect in single pt within tol
 *		-1	Vertexuse not child of edgeuse
 *		0	Success
 *
 *
 */
int nmg_offset_vertexuse(vu, s, pt, tol)
struct vertex *vu;
fastf_t s, tol;
point_t pt;
{
	struct edgeuse *eu, *euprev;
	struct nmg_ptbl planes;
	struct faceuse *fu;
	int i;
	union {
		char *c;
		fastf_t *f;
		long *l;
	} pl;

	NMG_CK_VERTEXUSE(vu);
	if (*vu->up.magic_p != NMG_EDGEUSE_MAGIC)
		return(-1)


	(void)nmg_tbl(&planes, TBL_INIT, (long *)NULL);

	/* collect up all the (perturbed) plane equations */
	eu = vu->up.eu_p;
	do {
		NMG_CK_EDGEUSE(eu);
		NMG_CK_LOOPUSE(eu->up.lu_p);
		fu = eu->up.lu_p->up.fu_p;
		NMG_CK_FACEUSE(fu);

		NMG_CK_FACE(fu->f_p);
		NMG_CK_FACE_G(fu->f_p->fg_p);

		pl.c = rt_calloc(1, sizeof(plane_t), "plane equation");
		VMOVE(pl.f, fu->f_p->fg_p->N, 4);

		if (fu->orientation == OT_OPPOSITE) {
			VREVERSE(pl.f, pl.f);
			pl.f[3] = -pl.f[3];
		} else 
			pl.f[3] = fu->f_p->fg_p->N[3];

		pl.f[3] += s;	/* perturbation */

		(void)nmg_tbl(&planes, TBL_INS, (long *)pl.l);

		NMG_CK_EDGEUSE(eu->last);
		euprev = eu->last->radial_p;
		NMG_CK_EDGEUSE(euprev);
		NMG_CK_VERTEXUSE(euprev->vu_p);

		if (euprev->vu_p->v_p != vu->v_p) {
			rt_bomb("there's something wrong with this model\n");
		}

		eu = euprev;
	} while (eu != vu->up.eu_p);

	/* sort and "uniq" the list of plane equations */



	if (plane.end == 1) {
		pl.l = planes.buffer;
		VADD2SCALE(pt, pl.f, s);
	} else if (plane.end == 2) {

	} else if (rt_mk_pt_nplanes(planes.buffer, planes.end, pt, tol))
		return(-2);

	/* free dynamic memory */
	for (i=0 ; i < planes.end ; ++i) {
		pl.l = planes.buffer[i];
		rt_free(pl.c);
	}

	(void)nmg_tbl(&planes, TBL_FREE, (long *)NULL);
	return(0);
}

/*
 *			N M G _ E U _ C O O R D S
 */
static nmg_eu_coords(eu, base, tip)
struct edgeuse *eu;
point_t base, tip;
{
	vect_t veu;

	nmg_offset_vertexuse(eu->vu_p, 2, base, 0.001);
	nmg_offset_vertexuse(eu->vu_p, 2, tip, 0.001);
	
	VSUB2SCALE(veu, tip, base, 0.6);
	VADD2(tip, base, veu);
}

#endif

d499 4
d504 37
a557 7
	pt_eu = eu->vu_p->v_p->vg_p->coord;
	pt_other = eu->eumate_p->vu_p->v_p->vg_p->coord;

	/* v_eu is the vector of the edgeuse
	 * mag is the magnitude of the edge vector
	 */
	VSUB2(v_eu, pt_other, pt_eu); 
d594 2
d597 3
a599 1
	nmg_eu_coord( NMG_LIST_PNEXT_CIRC(edgeuse, eu), tip );
d601 12
a879 1
		pl_color(fp, 0, 255, 0);	/* XXX ? */
d883 2
a884 2
		nmg_pl_e(fp, eu->e_p, &b, (unsigned char)255, 
			(unsigned char)255, 
d896 1
a896 1
		rt_bomb("exiting\n");
@


1.14
log
@embellished nmg_pr_lu
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.13 90/05/21 14:41:30 mike Exp $ (BRL)";
a393 1
	rt_log("%sVERTEX_G %8x\n", h, vg);
d395 1
d399 2
a400 4
	rt_log("%s%f coord[X]\n", h, vg->coord[X]);
	rt_log("%s%f coord[Y]\n", h, vg->coord[Y]);
	rt_log("%s%f coord[Z]\n", h, vg->coord[Z]);

@


1.13
log
@lint.  Some static routines got nmg_ prefix
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.12 90/05/21 11:44:58 mike Exp $ (BRL)";
d312 4
@


1.12
log
@Minor lint
@
text
@d16 1
a16 1
 *  Author -
d18 1
d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.11 90/05/18 12:24:30 mike Exp $ (BRL)";
d579 4
a582 2

static eu_coords(eu, base, tip)
d599 1
a599 1
static void eu_coord(eu, base)
d666 1
a666 1
static eu_coords(eu, base, tip)
d672 2
a673 2
	eu_coord(eu, base);
	eu_coord( NMG_LIST_PNEXT_CIRC(edgeuse, eu), tip );
d684 1
a684 1
static void eu_radial(fp, eu, tip, R, G, B)
d698 1
a698 1
	eu_coords(eu->radial_p, b2, t2);
d711 1
a711 1
static void eu_last(fp, eu, base)
d727 1
a727 1
	eu_coords(eulast->radial_p, b2, t2);
d738 1
a738 1
	eu_coords(eulast, b2, t2);
d752 1
a752 1
static void eu_next(fp, eu, tip)
d767 1
a767 1
	eu_coords(nexteu, b2, t2);
d844 1
a844 1
	    	eu_coords(eu, base, tip);
d858 3
a860 3
	    	eu_radial(fp, eu, tip, R, G, B);
	    	eu_next(fp, eu, tip);
/*	    	eu_last(fp, eu, base); */
@


1.11
log
@about 33/64th of the way converted to new linked lists ;-) LAB
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.10 90/05/18 07:26:04 butler Exp $ (BRL)";
d51 2
a52 1
char o, *h;
d833 1
a833 1
	if (nmg_tbl(b, TBL_LOC, eu) >= 0) return;
a1159 3
 *
 *		min	minimum point of the bounding RPP of the shell
 *		max	maximum point of the bounding RPP of the shell
d1222 2
a1223 1
			rt_realloc(vl, vl_len*sizeof(struct vertex *),
@


1.10
log
@Halfway converted to new double-linked-list structures ;-)
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.9 90/05/16 07:39:46 butler Exp $ (BRL)";
d1308 1
a1308 1
	struct edgeuse *eur;	
d1344 8
@


1.9
log
@rt_ routines don't need to be declared anymore because raytrace.h has gotten
a list of externs for them.
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.8 90/05/15 09:21:53 butler Exp $ (BRL)";
d68 1
d76 1
a76 3
	rt_log("%8x r_p\n", m->r_p);
	r = m->r_p;
	do {
d78 2
a79 2
		r = r->next;
	} while (r != m->r_p);
a80 2
	return;
}
d98 1
a98 1
	if (!r || r->magic != NMG_REGION_MAGIC) {
d104 2
a105 2
	rt_log("%8x next\n", r->next);
	rt_log("%8x last\n", r->last);
a106 1
	rt_log("%8x s_p\n", r->s_p);
d108 2
a109 6
	if (r->s_p) {
		s = r->s_p;
		do {
			nmg_pr_s(s, h);
			s = s->next;
		} while (s != r->s_p);
d113 1
d119 6
a124 1
	NMG_CK_SHELL_A(sa);
a125 1
	rt_log("%sSHELL_A %8x\n", h, sa);
d133 1
d149 1
d155 2
a158 1
	rt_log("%sFACE_G %8x\n", h, fg);
d174 3
a178 1
	NMG_CK_SHELL(s);
d181 2
a182 2
	if (!s || s->magic != NMG_SHELL_MAGIC) {
		rt_log ("bad magic!\n");
d185 1
d187 2
a188 2
	rt_log("%s%8x next\n", h, s->next );
	rt_log("%s%8x last\n", h, s->last );
d193 3
a195 4
	rt_log("%s%8x fu_p\n", h, s->fu_p);
	rt_log("%s%8x lu_p\n", h, s->lu_p);
	rt_log("%s%8x eu_p\n", h, s->eu_p);
	rt_log("%s%8x vu_p\n", h, s->vu_p);
d197 2
a198 6
	if (s->fu_p) {
		struct faceuse *fu = s->fu_p;
		do {
			nmg_pr_fu(fu, h);
			fu = fu->next;
		} while (fu != s->fu_p);
d200 3
a202 6
	if (s->lu_p) {
		struct loopuse *lu = s->lu_p;
		do {
			nmg_pr_lu(lu, h);
			lu = lu->next;
		} while (lu != s->lu_p);
a203 7
	if (s->eu_p) {
		struct edgeuse *eu = s->eu_p;
		do {
			nmg_pr_eu(eu, h);
			eu = eu->next;
		} while (eu != s->eu_p);
	}
d209 1
d225 1
d236 1
a236 1
	if (!fu || fu->magic != NMG_FACEUSE_MAGIC) {
d242 2
a243 2
	rt_log("%s%8x next\n", h, fu->next);
	rt_log("%s%8x last\n", h, fu->last);
a246 1
	rt_log("%s%8x lu_p\n", h, fu->lu_p);
a248 1
	nmg_pr_f(fu->f_p, h);
d250 1
a250 2
	lu = fu->lu_p;
	do {
d252 1
a252 3
		lu = lu->next;
	} while (lu != fu->lu_p);
	
d255 1
d279 3
a281 1
	struct edgeuse *eu;
d287 1
a287 1
	if (!lu || lu->magic != NMG_LOOPUSE_MAGIC) {
d301 2
a302 2
	rt_log("%s%8x next\n", h, lu->next);
	rt_log("%s%8x last\n", h, lu->last);
d311 5
a315 3
	if (*lu->down.magic_p == NMG_VERTEXUSE_MAGIC) {
		rt_log("%s%8x down.vu_p\n", h, lu->down.vu_p);
		nmg_pr_vu(lu->down.vu_p, h);
d317 2
a318 4
	else if (*lu->down.magic_p == NMG_EDGEUSE_MAGIC) {
		rt_log("%s%8x down.eu_p\n", h, lu->down.eu_p);
		eu = lu->down.eu_p;
		do {
d320 1
a320 2
			eu = eu->next;
		} while (eu != lu->down.eu_p);
d327 1
d354 1
a354 1
	if (!eu || eu->magic != NMG_EDGEUSE_MAGIC) {
d367 2
a368 2
	rt_log("%s%8x next\n", h, eu->next);
	rt_log("%s%8x last\n", h, eu->last);
d380 1
d399 1
d412 1
a412 1
	rt_log("%s%8x vu_p\n", h, v->vu_p);
d428 1
a428 1
	if (!vu || vu->magic != NMG_VERTEXUSE_MAGIC) {
d440 2
a441 2
	rt_log("%s%8x next\n", h, vu->next);
	rt_log("%s%8x last\n", h, vu->last);
d635 1
a635 1
	peu = eu->last;
d639 1
a639 1
		peu = peu->last;
d669 1
a669 1
	eu_coord(eu->next, tip);
d684 1
d713 1
d716 6
a721 4
	NMG_CK_EDGEUSE(eu->last);
	NMG_CK_VERTEXUSE(eu->last->vu_p);
	NMG_CK_VERTEX(eu->last->vu_p->v_p);
	NMG_CK_VERTEX_G(eu->last->vu_p->v_p->vg_p);
d723 1
a723 1
	eu_coords(eu->last->radial_p, b2, t2);
d734 1
a734 1
	eu_coords(eu->last, b2, t2);
d754 1
d756 6
a761 4
	NMG_CK_EDGEUSE(eu->next);
	NMG_CK_VERTEXUSE(eu->next->vu_p);
	NMG_CK_VERTEX(eu->next->vu_p->v_p);
	NMG_CK_VERTEX_G(eu->next->vu_p->v_p->vg_p);
d763 1
a763 1
	eu_coords(eu->next, b2, t2);
d833 1
a833 1
	(void)nmg_tbl(b, TBL_INS, &eu->magic);
d866 2
a867 1
	struct edgeuse *eu;	
d870 1
a870 1
	if (nmg_tbl(b, TBL_LOC, &lu->magic) >= 0) return;
d872 1
a872 1
	(void)nmg_tbl(b, TBL_INS, &lu->magic);
d874 2
a875 1
	if (*lu->down.magic_p == NMG_VERTEXUSE_MAGIC &&
d877 4
a880 5
		nmg_pl_v(fp, lu->down.vu_p->v_p, b, R, G, B);
	} else if (*lu->down.magic_p == NMG_EDGEUSE_MAGIC) {
		eu = lu->down.eu_p;

		do {
d882 1
a882 3
			eu = eu->next;
		} while (eu != lu->down.eu_p);

d895 2
a896 2
	if (nmg_tbl(b, TBL_LOC, &fu->magic) >= 0) return;
	(void)nmg_tbl(b, TBL_INS, &fu->magic);
d898 1
a898 2
	lu = fu->lu_p;
	do {
d900 1
a900 2
		lu = lu->next;
	} while (lu != fu->lu_p);
d918 2
a919 4
	if (s->fu_p) {
		NMG_CK_FACEUSE(s->fu_p);
		fu = s->fu_p;
		do {
d921 1
a921 1
			static unsigned color = 0xff;
d925 2
a926 2
			nmg_pl_fu(fp, fu, &b, Rcolor(color), Gcolor(color), Bcolor(color));
			--color;
d928 1
a928 1
			nmg_pl_fu(fp, fu, &b, 80, 100, 170);
a929 2
			fu = fu->next;
		} while (fu != s->fu_p);
d932 3
a934 8
	if (s->lu_p) {
		NMG_CK_LOOPUSE(s->lu_p);
		lu = s->fu_p->lu_p;
		do {
			nmg_pl_lu(fp, lu, &b, 255, 0, 0);

			lu = lu->next;
		} while (lu != s->fu_p->lu_p);
d937 4
a940 7
	if (s->eu_p) {
		NMG_CK_EDGEUSE(s->eu_p);
		pl_color(fp, 0, 255, 0);
		eu = s->eu_p;
		do {
			NMG_CK_EDGEUSE(eu);
			NMG_CK_EDGE(eu->e_p);
d942 3
a944 6
			nmg_pl_e(fp, eu->e_p, &b, (unsigned char)255, 
				(unsigned char)255, 
				(unsigned char)0);

			eu = eu->next;
		} while (eu != s->eu_p);
d950 3
a952 1
	if (!s->fu_p && !s->lu_p && !s->eu_p && !s->vu_p) {
d968 1
a968 2
	s = r->s_p;
	do {
d970 1
a970 2
		s = s->next;
	} while (s != r->s_p);
d979 1
a979 2
	r = m->r_p;
	do {
d981 1
a981 2
		r = r->next;
	} while (r != m->r_p);
d1075 10
a1084 2
/* 	N M G _ C K _ C L O S E D _ S U R F
 *	Verify that we have a closed object in shell s1
d1092 2
a1093 1
	int status;
d1095 21
a1115 7
	fu = s->fu_p;
	lu = fu->lu_p;
	
	do {
		if (*lu->down.magic_p == NMG_EDGEUSE_MAGIC) {
			eu = lu->down.eu_p;
			do {
d1117 15
a1131 2
				if (status=check_radial(eu))
					return(status);
d1133 5
a1137 8
				eu = eu->next;
			} while (eu != lu->down.eu_p);
		} else if (*lu->down.magic_p == NMG_VERTEXUSE_MAGIC) {
			NMG_CK_VERTEXUSE(lu->down.vu_p);
			NMG_CK_VERTEX(lu->down.vu_p->v_p);
		}
		lu = lu->next;
	} while (lu != fu->lu_p);
d1141 1
d1174 1
d1234 5
a1238 2
		fu = nmg_cface(s, vl, (unsigned)pts_this_face);
		eu = fu->lu_p->down.eu_p;
d1240 2
a1241 2
					eu->next->vu_p->v_p->vg_p->coord,
					eu->last->vu_p->v_p->vg_p->coord)) {
d1243 1
a1243 1
			rt_bomb("cannot make plane equation\n");
d1249 2
a1250 2
		if (v[i]->vu_p == (struct vertexuse *)NULL)
			FREE_VERTEX(v[i]);
d1252 1
a1252 1

a1256 1

d1353 1
a1353 1
	nmg_ck_vu(&eu->magic, eu->vu_p, errstr);
d1403 1
d1407 1
a1408 1

d1436 6
a1441 4
	if (*lu->down.magic_p == NMG_VERTEXUSE_MAGIC) {
		nmg_ck_vu(&lu->magic, lu->down.vu_p, errstr);
	} else if (*lu->down.magic_p == NMG_EDGEUSE_MAGIC) {
		NMG_CK_EDGEUSE(lu->down.eu_p);
d1443 2
a1444 2
		eu = lu->down.eu_p;
		do {
d1447 2
a1448 3
			nmg_ck_eu(&lu->magic, eu, errstr);
			eu = eu->next;
		} while (eu != lu->down.eu_p);
d1516 2
a1517 2
	if (fu->next->last != fu) rt_bomb(
		strcat(errstr, "Faceuse not lastward of next faceuse\n") );
d1519 2
a1520 2
	if (fu->last->next != fu) rt_bomb(
		strcat(errstr, "Faceuse not nextward from last faceuse\n") );
a1530 2
	NMG_CK_LOOPUSE(fu->lu_p);
	lu = fu->lu_p;
d1532 2
a1533 1
	do {
d1536 2
a1537 4
		nmg_ck_lu(&fu->magic, lu, errstr);
		lu = lu->next;
	} while (lu != fu->lu_p);

d1589 1
d1601 1
a1601 2
	fu = s->fu_p;
	do {
d1603 1
a1603 2
		lu = fu->lu_p;
		do {
d1605 3
a1607 3
			if (*lu->down.magic_p == NMG_EDGEUSE_MAGIC) {
				eu = lu->down.eu_p;
				do {
d1610 2
a1611 4

					eu = eu->next;
				} while (eu != lu->down.eu_p);
			} else if (*lu->down.magic_p == NMG_VERTEXUSE_MAGIC) {
d1618 2
a1619 6
			lu = lu->next;
		} while (lu != fu->lu_p);

		fu = fu->next;
	} while (fu != s->fu_p);

@


1.8
log
@altered check_radial to cope with radial wire edges
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_misc.c,v 1.7 90/05/09 11:37:43 butler Exp $ (BRL)";
d609 1
a609 1
	fastf_t dist1, rt_dist_line_point();
@


1.7
log
@changes?
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: nmg_misc.c,v 1.6 90/03/14 22:37:32 butler Locked $ (BRL)";
d1021 1
a1021 1
	struct edgeuse *eur, *eu1;
d1032 8
d1046 1
d1090 5
a1094 1
	} while (eur != eu->radial_p);
@


1.6
log
@*** empty log message ***
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: nmg_misc.c,v 1.5 90/03/08 04:40:59 butler Locked $ (BRL)";
d42 1
d45 3
a47 1
/* #define DEBUG_POLYTO */
d58 1
a477 1
	(void)sprintf(label, "%g %g %g", p[0], p[1], p[2]);
d479 4
a482 1
	pl_label(fp, label);
d488 6
a493 1
/*	E U _ C O O R D S
d495 11
a505 1
 *	compute a pair of coordinates for representing an edgeuse
d507 81
d592 18
a609 1
	fastf_t mag, dist1, rt_dist_line_point();
d612 2
a613 2
	vect_t v1,		/* vector of edgeuse */
		v2,		/* vector of last edgeuse/start of edgeuse plot */
d615 1
a615 1
	pointp_t p1, p0;
d635 2
a636 2
	p0 = eu->vu_p->v_p->vg_p->coord;
	p1 = eu->eumate_p->vu_p->v_p->vg_p->coord;
d638 1
a638 1
	/* v1 is the vector of the edgeuse
d641 2
a642 3
	VSUB2(v1, p1, p0); 
	mag = MAGNITUDE(v1);
	VUNITIZE(v1);
d646 3
a648 3
	p1 = peu->vu_p->v_p->vg_p->coord;
	dist1 = rt_dist_line_point(p0, v1, p1);
	while (dist1 == 0.0 && peu != eu) {
d650 2
a651 2
		p1 = peu->vu_p->v_p->vg_p->coord;
		dist1 = rt_dist_line_point(p0, v1, p1);
d654 2
a655 2
	/* make a vector from the "last" edge */
	VSUB2(v2, p1, p0); VUNITIZE(v2);
d661 1
a661 1
	VADD2(v2, v2, v1); VUNITIZE(v2);
d664 2
a665 1
	VJOIN2(base, p0, 0.125,v2, 0.01,N);
d667 19
a685 2
	mag *= 0.6;
	VJOIN1(tip, base, mag, v1);
d690 1
a690 1
static void eu_radial(fp, eu, tip)
d705 1
d707 2
d710 2
d713 1
d715 39
d767 1
d780 2
d798 10
d809 1
a809 1
	pd_3line(fp, p0[0], p0[1], p0[2], p1[0], p1[1], p1[2]);
d857 1
a857 1
	    	eu_radial(fp, eu, tip);
d859 1
a859 1

d876 2
a877 1
	if (*lu->down.magic_p == NMG_VERTEXUSE_MAGIC) {
d1011 5
d1017 1
a1017 1
static void check_radial(eu)
d1051 2
a1052 1
				rt_bomb("bad edgeuse mate\n");
d1069 7
a1075 4
			nmg_pr_fu(eu1->up.lu_p->up.fu_p, 0);
			rt_log("Radial loop:\n");
			nmg_pr_fu(eur->up.lu_p->up.fu_p, 0);
			rt_bomb("unclosed space\n");
d1082 1
a1082 1

d1088 1
a1088 1
void nmg_ck_closed_surf(s)
d1094 1
d1104 2
a1105 1
				check_radial(eu);
d1115 1
a1158 1
#ifdef DEBUG_POLYTO
d1160 3
a1162 2
		rt_log("points: %d  facets: %d\n", num_pts, num_facets);
#endif	
d1164 1
a1177 1
#ifdef DEBUG_POLYTO
d1179 4
a1182 3
			rt_log("read vertex #%d (%g %g %g)\n",
				i, p[0], p[1], p[2]);
#endif	
d1192 5
a1196 3
#ifdef DEBUG_POLYTO
		rt_log("facet %d pts in face %d\n", facet, pts_this_face);
#endif
@


1.5
log
@added nmg_cmface
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: nmg_misc.c,v 1.4 90/02/27 21:02:01 butler Locked $ (BRL)";
@


1.4
log
@preliminary boolean operations (Debug release)
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /usr/people/butler/nmg2/RCS/nmg_misc.c,v 1.6 89/12/15 17:09:09 butler Exp $ (BRL)";
a40 1
#include "fb.h"
d44 1
a44 1

d546 1
a546 1
	VJOIN2(base, p0, 0.5,v2, 0.1,N);
d917 7
a923 1
 *	(vertices) in the file
a924 1
 *
d932 1
a932 1
struct shell *polytonmg(fd, r, min, max)
a934 1
point_t min, max;
d942 3
d952 4
a955 5
	
	/* get the bounds of the model */
	if (fscanf(fd, "%lg %lg %lg %lg %lg %lg", &min[0], &max[0],
	    &min[1], &max[1], &min[2], &max[2]) != 6)
		rt_bomb("error reading bounding box\n");
a956 1

d970 5
a977 1

d984 3
a986 1

d999 9
a1007 1
		(void)nmg_cface(s, vl, (unsigned)pts_this_face);
@


1.3
log
@*** empty log message ***
@
text
@d4 12
d29 1
a29 1
static char RCSid[] = "@@(#)$Header: nmg_misc.c,v 1.2 89/12/22 03:15:13 butler Locked $ (BRL)";
d38 1
a38 1

d41 1
d44 17
d252 1
a252 1
	rt_log("%s%8x orientation\n", h, fu->orientation);
d314 1
d381 1
a381 1
	rt_log("%s%8x orientation\n", h, eu->orientation);
a403 1
	rt_log("%s%8d orientation\n", h, vg->orientation);
d457 8
d466 90
a555 1
static nmg_pl_lu(fp, lu, b, R, G, B)
d557 115
a676 1
	struct vertex_g *vg;
d679 1
a679 2
	if (nmg_tbl(b, TBL_LOC, &lu->l_p->magic) >= 0) return;
	(void)nmg_tbl(b, TBL_INS, &lu->l_p->magic);
d681 2
d684 1
a684 4
		vg = lu->down.vu_p->v_p->vg_p;
		NMG_CK_VERTEX_G(vg);
		pd_3point(fp, vg->coord[X], vg->coord[Y], vg->coord[Z]);

a687 2
		pl_color(fp, R, G, B);
#if 1
d689 1
a689 21
			NMG_CK_EDGEUSE(eu);
			NMG_CK_EDGE(eu->e_p);
			NMG_CK_VERTEXUSE(eu->vu_p);
			NMG_CK_VERTEX(eu->vu_p->v_p);
			vg = eu->vu_p->v_p->vg_p;
			NMG_CK_VERTEX_G(vg);

			if (nmg_tbl(b, TBL_LOC, &eu->e_p->magic) < 0) {
				struct vertex_g *vg2;
				pl_color(fp, R, G, B);
				vg2 = eu->eumate_p->vu_p->v_p->vg_p;
				pd_3line(fp,
				vg->coord[X], vg->coord[Y], vg->coord[Z],
				vg2->coord[X], vg2->coord[Y], vg2->coord[Z]);

				pl_color(fp, 255, 255, 255);
				pd_3point(fp, vg->coord[X], vg->coord[Y],
					vg->coord[Z]);
				pd_3point(fp, vg2->coord[X], vg2->coord[Y],
					vg2->coord[Z]);
			}
a691 9
#else
		{int cont = 0;
		do {
			NMG_CK_EDGEUSE(eu);
			NMG_CK_EDGE(eu->e_p);
			NMG_CK_VERTEXUSE(eu->vu_p);
			NMG_CK_VERTEX(eu->vu_p->v_p);
			vg = eu->vu_p->v_p->vg_p;
			NMG_CK_VERTEX_G(vg);
a692 23
			if (nmg_tbl(b, TBL_LOC, &eu->e_p->magic) < 0) {
				if (!cont) {
					vg = eu->vu_p->v_p->vg_p;
					NMG_CK_VERTEX_G(vg);
					pd_3move(fp, vg->coord[X],
						vg->coord[Y], vg->coord[Z]);
				}
				vg = eu->eumate_p->vu_p->v_p->vg_p;
				NMG_CK_VERTEX_G(vg);
				pd_3cont(fp, vg->coord[X], vg->coord[Y],
					vg->coord[Z]);

				cont = 1;
				(void)nmg_tbl(b, TBL_INS, &eu->e_p->magic);
			} else {
				cont = 0;
			}
			eu = eu->next;
		} while (eu != lu->down.eu_p);
		}
#endif


d696 1
a696 1
static nmg_pl_fu(fp, fu, b, R, G, B)
d705 2
a706 2
	if (nmg_tbl(b, TBL_LOC, &fu->f_p->magic) >= 0) return;
	(void)nmg_tbl(b, TBL_INS, &fu->f_p->magic);
a718 1
	struct vertex_g *vg1, *vg2;
d722 1
a722 1
	struct nmg_ptbl b;	
d724 1
d742 1
a742 1
			nmg_pl_fu(fp, fu, &b, 100, 100, 170);
d744 1
a744 5
			if (fu->next != s->fu_p &&
			    fu->next->f_p == fu->f_p)
			    	fu = fu->next->next;
			else
				fu = fu->next;
d754 1
a754 5
			if (lu->next != s->lu_p &&
			    lu->next->l_p == lu->l_p)
			    	lu = lu->next->next;
			else
				lu = lu->next;
d766 3
a768 1
			if (nmg_tbl(&b, TBL_LOC, &eu->e_p->magic) < 0) {
a769 17
				NMG_CK_VERTEXUSE(eu->vu_p);
				NMG_CK_VERTEX(eu->vu_p->v_p);
				vg1 = eu->vu_p->v_p->vg_p;
				NMG_CK_VERTEX_G(vg1);

				NMG_CK_VERTEXUSE(eu->eumate_p->vu_p);
				NMG_CK_VERTEX(eu->eumate_p->vu_p->v_p);
				vg2 = eu->eumate_p->vu_p->v_p->vg_p;
				NMG_CK_VERTEX_G(vg2);

				pd_3line(fp,
				vg1->coord[X], vg1->coord[Y], vg1->coord[Z],
				vg2->coord[X], vg2->coord[Y], vg2->coord[Z]);

				(void)nmg_tbl(&b, TBL_INS, &eu->e_p->magic);
			}

d774 1
a774 6
		pl_color(fp, 255, 255, 0);
		NMG_CK_VERTEXUSE(s->vu_p);
		NMG_CK_VERTEX(s->vu_p->v_p);
		NMG_CK_VERTEX_G(s->vu_p->v_p->vg_p);
		vg1 = s->vu_p->v_p->vg_p;
		pd_3point(fp, vg1->coord[X], vg1->coord[Y], vg1->coord[Z]);
d811 565
@


1.2
log
@Rudimentary face/loop partitioning (for future boolean use)
accomplished.
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /usr/people/butler/nmg2/RCS/nmg_misc.c,v 1.6 89/12/15 17:09:09 butler Exp $ (BRL)";
@


1.1
log
@Initial revision
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d131 1
a131 1
	rt_log("%s%fx + %fy + %fz + %f = 0.0\n", h, fg->N[0], fg->N[1],
d428 1
a428 1
static nmg_pl_lu(fp, lu)
d431 2
d438 2
d448 3
a450 6
		NMG_CK_EDGEUSE(eu);
		NMG_CK_VERTEXUSE(eu->vu_p);
		NMG_CK_VERTEX(eu->vu_p->v_p);
		vg = eu->vu_p->v_p->vg_p;
		NMG_CK_VERTEX_G(vg);
		pd_3move(fp, vg->coord[X], vg->coord[Y], vg->coord[Z]);
d452 5
a456 1
			vg = eu->next->vu_p->v_p->vg_p;
d458 15
a472 1
			pd_3cont(fp, vg->coord[X], vg->coord[Y], vg->coord[Z]);
d475 33
d511 1
a511 1
static nmg_pl_fu(fp, fu)
d514 2
d518 1
a518 1
	static unsigned char R=100, G=100, B=100;
d520 2
a522 3
	G += 20;
	pl_color(R, G, B);
	
d525 1
a525 1
		nmg_pl_lu(fp, lu);
d530 1
a530 1
nmg_pl_s(fp, s)
a546 1
		pl_color(fp, 100, 150, 100);
d549 10
a558 4
			if (nmg_tbl(&b, TBL_LOC, &fu->f_p->magic) < 0) {
				nmg_pl_fu(fp, fu);
				(void)nmg_tbl(&b, TBL_INS, &fu->f_p->magic);
			}
a568 1
		pl_color(fp, 255, 0, 0);
d571 1
a571 4
			if (nmg_tbl(&b, TBL_LOC, &lu->l_p->magic) < 0) {
				nmg_pl_lu(fp, lu);
				(void)nmg_tbl(&b, TBL_INS, &lu->l_p->magic);
			}
d612 1
a612 1
		pl_color(fp, 170, 170, 0);
@
