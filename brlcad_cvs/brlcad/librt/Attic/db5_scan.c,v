head	11.42;
access;
symbols
	ansi-20040405-merged:11.39.2.1
	postmerge-20040405-ansi:11.40
	premerge-20040404-ansi:11.39
	postmerge-autoconf:11.39
	autoconf-freeze:11.39
	premerge-autoconf:11.39
	ansi-20040316-freeze:11.39.2.1
	postmerge-20040315-windows:11.39
	premerge-20040315-windows:11.39
	windows-20040315-freeze:11.39
	autoconf-20031203:11.39
	autoconf-20031202:11.39
	autoconf-branch:11.39.0.10
	phong-branch:11.39.0.8
	photonmap-branch:11.39.0.6
	rel-6-1-DP:11.39
	windows-branch:11.39.0.4
	rel-6-0-2:11.37
	ansi-branch:11.39.0.2
	rel-6-0-1-branch:11.37.0.2
	hartley-6-0-post:11.38
	hartley-6-0-pre:11.37
	rel-6-0-1:11.37
	rel-6-0:11.37
	rel-5-4:11.6
	offsite-5-3-pre:11.25
	rel-5-3:11.6
	rel-5-2:11.6
	rel-5-1-branch:11.6.0.2
	rel-5-1:11.6;
locks; strict;
comment	@ * @;


11.42
date	2004.05.21.18.07.29;	author morrison;	state dead;
branches;
next	11.41;

11.41
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.40;

11.40
date	2004.04.05.08.48.56;	author morrison;	state Exp;
branches;
next	11.39;

11.39
date	2002.08.20.17.07.57;	author jra;	state Exp;
branches
	11.39.2.1;
next	11.38;

11.38
date	2002.08.15.20.55.08;	author hartley;	state Exp;
branches;
next	11.37;

11.37
date	2002.02.25.15.22.35;	author jra;	state Exp;
branches;
next	11.36;

11.36
date	2002.01.09.19.56.48;	author jra;	state Exp;
branches;
next	11.35;

11.35
date	2001.11.06.22.09.25;	author morrison;	state Exp;
branches;
next	11.34;

11.34
date	2001.10.04.14.24.52;	author bparker;	state Exp;
branches;
next	11.33;

11.33
date	2001.08.02.17.40.41;	author jra;	state Exp;
branches;
next	11.32;

11.32
date	2001.05.17.20.05.23;	author morrison;	state Exp;
branches;
next	11.31;

11.31
date	2001.04.20.22.29.41;	author morrison;	state Exp;
branches;
next	11.30;

11.30
date	2001.04.20.21.34.38;	author bparker;	state Exp;
branches;
next	11.29;

11.29
date	2001.04.20.20.00.13;	author bparker;	state Exp;
branches;
next	11.28;

11.28
date	2001.03.23.17.03.47;	author kermit;	state Exp;
branches;
next	11.27;

11.27
date	2001.03.23.16.56.36;	author kermit;	state Exp;
branches;
next	11.26;

11.26
date	2001.03.22.19.37.39;	author jra;	state Exp;
branches;
next	11.25;

11.25
date	2001.03.16.14.43.52;	author jra;	state Exp;
branches;
next	11.24;

11.24
date	2001.01.29.16.17.10;	author jra;	state Exp;
branches;
next	11.23;

11.23
date	2000.09.08.05.54.40;	author mike;	state Exp;
branches;
next	11.22;

11.22
date	2000.08.22.03.27.30;	author mike;	state Exp;
branches;
next	11.21;

11.21
date	2000.08.21.02.02.29;	author butler;	state Exp;
branches;
next	11.20;

11.20
date	2000.07.26.15.13.07;	author mike;	state Exp;
branches;
next	11.19;

11.19
date	2000.07.24.19.27.31;	author mike;	state Exp;
branches;
next	11.18;

11.18
date	2000.07.20.21.25.36;	author mike;	state Exp;
branches;
next	11.17;

11.17
date	2000.07.12.21.55.54;	author mike;	state Exp;
branches;
next	11.16;

11.16
date	2000.07.07.03.49.22;	author mike;	state Exp;
branches;
next	11.15;

11.15
date	2000.06.30.19.14.07;	author mike;	state Exp;
branches;
next	11.14;

11.14
date	2000.06.30.19.10.11;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	2000.06.30.18.03.41;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	2000.06.30.17.19.19;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	2000.06.30.14.37.20;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	2000.06.29.15.21.14;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	2000.06.28.18.04.35;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	2000.06.27.18.14.55;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	2000.06.26.19.06.55;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	2000.06.23.21.05.56;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	2000.06.23.06.36.46;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	2000.06.23.05.52.19;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	2000.06.23.03.32.41;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	2000.06.23.02.41.03;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	2000.06.23.02.12.44;	author mike;	state Exp;
branches;
next	;

11.39.2.1
date	2002.09.19.18.01.30;	author morrison;	state Exp;
branches;
next	;


desc
@@


11.42
log
@moved to src/
@
text
@/*
 *			D B 5 _ S C A N . C
 *
 *  Scan a v5 database, sending each object off to a handler.
 *
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Status -
 *	Public Domain, Distribution Unlimited.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/db5_scan.c,v 11.41 2004/05/10 15:30:46 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "db5.h"
#include "raytrace.h"

#include "./debug.h"

/*
 *			D B 5 _ S C A N
 *
 * Returns -
 *	 0	Success
 *	-1	Fatal Error
 */
int
db5_scan(
	struct db_i	*dbip,
	void		(*handler)(struct db_i *,
				const struct db5_raw_internal *,
				long addr, genptr_t client_data ),
	genptr_t	client_data )
{
	unsigned char	header[8];
	struct db5_raw_internal	raw;
	int			got;
	long			nrec;
	long			addr;

	RT_CK_DBI(dbip);
	if(RT_G_DEBUG&DEBUG_DB) bu_log("db5_scan( x%x, x%x )\n", dbip, handler);

	raw.magic = DB5_RAW_INTERNAL_MAGIC;
	nrec = 0L;

	/* Fast-path when file is already memory-mapped */
	if( dbip->dbi_mf )  {
		const unsigned char	*cp = (const unsigned char *)dbip->dbi_inmem;
		long	eof;

		BU_CK_MAPPED_FILE(dbip->dbi_mf);
		eof = dbip->dbi_mf->buflen;

		if( db5_header_is_valid( cp ) == 0 )  {
			bu_log("db5_scan ERROR:  %s is lacking a proper BRL-CAD v5 database header\n", dbip->dbi_filename);
		    	goto fatal;
		}
		cp += sizeof(header);
		addr = sizeof(header);
		while( addr < eof )  {
			if( (cp = db5_get_raw_internal_ptr( &raw, cp )) == NULL )  {
				goto fatal;
			}
			(*handler)(dbip, &raw, addr, client_data);
			nrec++;
			addr += raw.object_length;
		}
		dbip->dbi_eof = addr;
		BU_ASSERT_LONG( dbip->dbi_eof, ==, dbip->dbi_mf->buflen );
	}  else  {
		/* In a totally portable way, read the database with stdio */
		rewind( dbip->dbi_fp );
		if( fread( header, sizeof header, 1, dbip->dbi_fp ) != 1  ||
		    db5_header_is_valid( header ) == 0 )  {
			bu_log("db5_scan ERROR:  %s is lacking a proper BRL-CAD v5 database header\n", dbip->dbi_filename);
		    	goto fatal;
		}
		for(;;)  {
			addr = ftell( dbip->dbi_fp );
			if( (got = db5_get_raw_internal_fp( &raw, dbip->dbi_fp )) < 0 )  {
				if( got == -1 )  break;		/* EOF */
				goto fatal;
			}
			(*handler)(dbip, &raw, addr, client_data);
			nrec++;
			if(raw.buf)  {
				bu_free(raw.buf, "raw v5 object");
				raw.buf = NULL;
			}
		}
		dbip->dbi_eof = ftell( dbip->dbi_fp );
		rewind( dbip->dbi_fp );
	}

	dbip->dbi_nrec = nrec;		/* # obj in db, not inc. header */
	return 0;			/* success */

fatal:
	dbip->dbi_read_only = 1;	/* Writing would corrupt it worse */
	return -1;			/* fatal error */
}

struct directory *
db_diradd5(
	   struct db_i				*dbip,
	   const char				*name,
	   long					laddr,
	   unsigned char			major_type,
	   unsigned char 			minor_type,
	   unsigned char			name_hidden,
	   long					object_length,
	   struct bu_attribute_value_set	*avs)
{
	struct directory **headp;
	register struct directory *dp;
	struct bu_vls local;

	RT_CK_DBI( dbip );

	bu_vls_init(&local);
	bu_vls_strcpy(&local, name);
	if (db_dircheck(dbip, &local, 0, &headp) < 0) {
		bu_vls_free(&local);
		return DIR_NULL;
	}

	/* Duplicates the guts of db_diradd() */
	RT_GET_DIRECTORY( dp, &rt_uniresource );
	RT_CK_DIR(dp);
	BU_LIST_INIT( &dp->d_use_hd );
	RT_DIR_SET_NAMEP(dp, bu_vls_addr( &local ));	/* sets d_namep */
	bu_vls_free( &local );
	dp->d_un.ptr = NULL;
	dp->d_un.file_offset = laddr;
	dp->d_major_type = major_type;
	dp->d_minor_type = minor_type;
	switch( major_type )  {
	case DB5_MAJORTYPE_BRLCAD:
		if( minor_type == ID_COMBINATION )  {

			dp->d_flags = DIR_COMB;
			if( !avs || avs->count == 0 )  break;
			/*
			 *  check for the "region=" attribute.
			 */
			if( bu_avs_get( avs, "region" ) != NULL )
				dp->d_flags = DIR_COMB|DIR_REGION;
		} else {
			dp->d_flags = DIR_SOLID;
		}
		break;
	case DB5_MAJORTYPE_BINARY_EXPM:
	case DB5_MAJORTYPE_BINARY_UNIF:
	case DB5_MAJORTYPE_BINARY_MIME:
		/* XXX Do we want to define extra flags for this? */
		dp->d_flags = DIR_NON_GEOM;
		break;
	case DB5_MAJORTYPE_ATTRIBUTE_ONLY:
		dp->d_flags = 0;
	}
	if( name_hidden )
		dp->d_flags |= DIR_HIDDEN;
	dp->d_len = object_length;		/* in bytes */
	BU_LIST_INIT( &dp->d_use_hd );
	dp->d_animate = NULL;
	dp->d_nref = 0;
	dp->d_uses = 0;
	dp->d_forw = *headp;
	*headp = dp;

	return( dp );
}

struct directory *
db5_diradd(
	   struct db_i			*dbip,
	   const struct db5_raw_internal *rip,
	   long				laddr,
	   genptr_t			client_data )
{
	struct directory **headp;
	register struct directory *dp;
	struct bu_vls local;

	RT_CK_DBI( dbip );

	bu_vls_init(&local);
	bu_vls_strcpy(&local, rip->name.ext_buf);
	if (db_dircheck(dbip, &local, 0, &headp) < 0) {
		bu_vls_free(&local);
		return DIR_NULL;
	}

	/* Duplicates the guts of db_diradd() */
	RT_GET_DIRECTORY( dp, &rt_uniresource );
	RT_CK_DIR(dp);
	BU_LIST_INIT( &dp->d_use_hd );
	RT_DIR_SET_NAMEP(dp, bu_vls_addr(&local));	/* sets d_namep */
	bu_vls_free(&local);
	dp->d_un.file_offset = laddr;
	dp->d_major_type = rip->major_type;
	dp->d_minor_type = rip->minor_type;
	switch( rip->major_type )  {
	case DB5_MAJORTYPE_BRLCAD:
		if( rip->minor_type == ID_COMBINATION )  {
			struct bu_attribute_value_set	avs;

			dp->d_flags = DIR_COMB;
			if( rip->attributes.ext_nbytes == 0 )  break;
			/*
			 *  Crack open the attributes to
			 *  check for the "region=" attribute.
			 */
			if( db5_import_attributes( &avs, &rip->attributes ) < 0 )  {
				bu_log("db5_diradd_handler: Bad attributes on combination '%s'\n",
					rip->name);
				break;
			}
			if( bu_avs_get( &avs, "region" ) != NULL )
				dp->d_flags = DIR_COMB|DIR_REGION;
			bu_avs_free( &avs );
		} else {
			dp->d_flags = DIR_SOLID;
		}
		break;
	case DB5_MAJORTYPE_BINARY_EXPM:
	case DB5_MAJORTYPE_BINARY_UNIF:
	case DB5_MAJORTYPE_BINARY_MIME:
		/* XXX Do we want to define extra flags for this? */
		dp->d_flags = DIR_NON_GEOM;
		break;
	case DB5_MAJORTYPE_ATTRIBUTE_ONLY:
		dp->d_flags = 0;
	}
	if( rip->h_name_hidden )
		dp->d_flags |= DIR_HIDDEN;
	dp->d_len = rip->object_length;		/* in bytes */
	BU_LIST_INIT( &dp->d_use_hd );
	dp->d_animate = NULL;
	dp->d_nref = 0;
	dp->d_uses = 0;
	dp->d_forw = *headp;
	*headp = dp;

	return( dp );
}

/*
 *			D B 5 _ D I R A D D _ H A N D L E R
 *
 * In support of db5_scan, add a named entry to the directory.
 */
HIDDEN void
db5_diradd_handler(
	struct db_i		*dbip,
	const struct db5_raw_internal *rip,
	long			laddr,
	genptr_t		client_data )	/* unused client_data from db5_scan() */
{
	RT_CK_DBI(dbip);

	if( rip->h_dli == DB5HDR_HFLAGS_DLI_HEADER_OBJECT )  return;
	if( rip->h_dli == DB5HDR_HFLAGS_DLI_FREE_STORAGE )  {
		/* Record available free storage */
		rt_memfree( &(dbip->dbi_freep), rip->object_length, laddr );
		return;
	}
	
	/* If somehow it doesn't have a name, ignore it */
	if( rip->name.ext_buf == NULL )  return;

	if(RT_G_DEBUG&DEBUG_DB)  {
		bu_log("db5_diradd_handler(dbip=x%x, name='%s', addr=x%x, len=%d)\n",
			dbip, rip->name, laddr, rip->object_length );
	}

	db5_diradd( dbip, rip, laddr, client_data );

	return;
}

/*
 *			D B _ D I R B U I L D
 *
 *  A generic routine to determine the type of the database,
 *  (v4 or v5)
 *  and to invoke the appropriate db_scan()-like routine to
 *  build the in-memory directory.
 *
 *  It is the caller's responsibility to close the database in case of error.
 *
 *  Called from rt_dirbuild(), and g_submodel.c
 *
 *  Returns -
 *	0	OK
 *	-1	failure
 */
int
db_dirbuild( struct db_i *dbip )
{
	unsigned char	header[8];

	RT_CK_DBI(dbip);

	/* First, determine what version database this is */
	rewind(dbip->dbi_fp);
	if( fread( header, sizeof header, 1, dbip->dbi_fp ) != 1  )  {
		bu_log("db_dirbuild(%s) ERROR, file too short to be BRL-CAD database\n",
			dbip->dbi_filename);
		return -1;
	}

	if( db5_header_is_valid( header ) )  {
		struct directory	*dp;
		struct bu_external	ext;
		struct db5_raw_internal	raw;
		struct bu_attribute_value_set	avs;
		const char		*cp;

		/* File is v5 format */
#if 0
bu_log("NOTICE:  %s is BRL-CAD v5 format.\n", dbip->dbi_filename);
#endif
		dbip->dbi_version = 5;
		if( db5_scan( dbip, db5_diradd_handler, NULL ) < 0 )  {
			bu_log("db_dirbuild(%s): db5_scan() failed\n",
				dbip->dbi_filename);
			return -1;
		}

		/* Need to retrieve _GLOBAL object and obtain title and units */
		if( (dp = db_lookup( dbip, DB5_GLOBAL_OBJECT_NAME, LOOKUP_NOISY )) == DIR_NULL )  {
			bu_log("db_dirbuild(%s): improper database, no %s object\n",
				dbip->dbi_filename, DB5_GLOBAL_OBJECT_NAME );
			dbip->dbi_title = bu_strdup(DB5_GLOBAL_OBJECT_NAME);
			/* Missing _GLOBAL object so create it and set default title and units */
			db5_update_ident(dbip, "Untitled BRL-CAD Database",1.0);
			return 0;	/* not a fatal error, user may have deleted it */
		}
		BU_INIT_EXTERNAL(&ext);
		if( db_get_external( &ext, dp, dbip ) < 0 ||
		    db5_get_raw_internal_ptr( &raw, ext.ext_buf ) == NULL )  {
			bu_log("db_dirbuild(%s): improper database, unable to read %s object\n",
				dbip->dbi_filename, DB5_GLOBAL_OBJECT_NAME );
			return -1;
		}
		if( raw.major_type != DB5_MAJORTYPE_ATTRIBUTE_ONLY )  {
			bu_log("db_dirbuild(%s): improper database, %s exists but is not an attribute-only object\n",
				dbip->dbi_filename, DB5_GLOBAL_OBJECT_NAME );
			dbip->dbi_title = bu_strdup(DB5_GLOBAL_OBJECT_NAME);
			return 0;	/* not a fatal error, need to let user proceed to fix it */
		}
		if( db5_import_attributes( &avs, &raw.attributes ) < 0 )  {
			bu_log("db_dirbuild(%s): improper database, corrupted attribute-only %s object\n",
				dbip->dbi_filename, DB5_GLOBAL_OBJECT_NAME );
		    	bu_free_external(&ext);
			return -1;	/* this is fatal */
		}
		BU_CK_AVS( &avs );

		/* Parse out the attributes */
		if( (cp = bu_avs_get( &avs, "title" )) != NULL )  {
			dbip->dbi_title = bu_strdup( cp );
		} else {
			dbip->dbi_title = bu_strdup( "Untitled BRL-CAD database" );
		}
		if( (cp = bu_avs_get( &avs, "units" )) != NULL )  {
			double	dd;
			if( sscanf( cp, "%lf", &dd ) != 1 ||
			    NEAR_ZERO( dd, VUNITIZE_TOL ) )  {
			    	bu_log("db_dirbuild(%s): improper database, %s object attribute 'units'=%s is invalid\n",
					dbip->dbi_filename, DB5_GLOBAL_OBJECT_NAME,
				    	cp );
			    	/* Not fatal, just stick with default value from db_open() */
			} else {
				dbip->dbi_local2base = dd;
				dbip->dbi_base2local = 1/dd;
			}
		}
		if( (cp = bu_avs_get( &avs, "regionid_colortable")) != NULL )  {
			/* Import the region-id coloring table */
			db5_import_color_table( (char *)cp);
		}
		bu_avs_free( &avs );
		bu_free_external(&ext);	/* not until after done with avs! */
		return 0;
	}

	/* Make a very simple check for a v4 database */
	if( header[0] == 'I' )  {
		dbip->dbi_version = 4;
		if( db_scan( dbip, (int (*)())db_diradd, 1, NULL ) < 0 )  {
			dbip->dbi_version = 0;
		    	return -1;
		}
		return 0;		/* ok */
	}

	bu_log("db_dirbuild(%s) ERROR, file is not in BRL-CAD geometry database format\n",
		dbip->dbi_filename);
	return -1;
}

int
db_get_version(struct db_i *dbip)
{
	unsigned char	header[8];

	rewind(dbip->dbi_fp);
	if( fread( header, sizeof header, 1, dbip->dbi_fp ) != 1  )  {
		bu_log("db_get_version ERROR, file (%s) too short to be BRL-CAD database\n",
			dbip->dbi_filename);
		return -1;
	}

	if( db5_header_is_valid( header ) )
		return( 5 );
	else if( header[0] == 'I' )
		return( 4 );
	else
		return( -1 );
	
}
@


11.41
log
@change conf.h to a wrapped config.h
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/librt/db5_scan.c,v 11.40 2004/04/05 08:48:56 morrison Exp $ (ARL)";
@


11.40
log
@merge of ansi-6-0-branch into HEAD
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d20 5
a24 1
#include "conf.h"
@


11.39
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_scan.c,v 11.37 2002/02/25 15:22:35 jra Exp $ (ARL)";
d424 1
a424 2
db_get_version( dbip )
struct db_i *dbip;
@


11.39.2.1
log
@Initial ANSIfication
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_scan.c,v 11.39 2002/08/20 17:07:57 jra Exp $ (ARL)";
d424 2
a425 1
db_get_version(struct db_i *dbip)
@


11.38
log
@Converted from K&R to ANSI C - RFH
@
text
@d424 2
a425 1
db_get_version(struct db_i *dbip)
@


11.37
log
@mods to set new directory flag for non-geometry objects
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_scan.c,v 11.36 2002/01/09 19:56:48 jra Exp $ (ARL)";
d424 1
a424 2
db_get_version( dbip )
struct db_i *dbip;
@


11.36
log
@db_diradd5() now accepts NULL AVS pointer
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_scan.c,v 11.35 2001/11/06 22:09:25 morrison Exp $ (ARL)";
d175 1
a175 1
		dp->d_flags = 0;
d249 1
a249 1
		dp->d_flags = 0;
@


11.35
log
@removed v5 reference to be consistent
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_scan.c,v 11.34 2001/10/04 14:24:52 bparker Exp $ (ARL)";
d161 1
a161 1
			if( avs->count == 0 )  break;
@


11.34
log
@*- if'd out warning about v5 format
*- removed other warnings about v5
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_scan.c,v 11.33 2001/08/02 17:40:41 jra Exp $ (ARL)";
d384 1
a384 1
			dbip->dbi_title = bu_strdup( "Untitled BRL-CAD v5 database" );
@


11.33
log
@Added db_diradd5()
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_scan.c,v 11.32 2001/05/17 20:05:23 morrison Exp $ (ARL)";
d340 1
d342 1
d352 1
a352 1
			bu_log("db_dirbuild(%s): improper v5 database, no %s object\n",
d356 1
a356 1
			db5_update_ident(dbip, "Untitled v5 BRL-CAD Database",1.0);
d362 1
a362 1
			bu_log("db_dirbuild(%s): improper v5 database, unable to read %s object\n",
d367 1
a367 1
			bu_log("db_dirbuild(%s): improper v5 database, %s exists but is not an attribute-only object\n",
d373 1
a373 1
			bu_log("db_dirbuild(%s): improper v5 database, corrupted attribute-only %s object\n",
d390 1
a390 1
			    	bu_log("db_dirbuild(%s): improper v5 database, %s object attribute 'units'=%s is invalid\n",
@


11.32
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_scan.c,v 11.31 2001/04/20 22:29:41 morrison Exp $ (ARL)";
d120 71
@


11.31
log
@CONST to const
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_scan.c,v 11.30 2001/04/20 21:34:38 bparker Exp $ (ARL)";
d60 1
a60 1
	if(rt_g.debug&DEBUG_DB) bu_log("db5_scan( x%x, x%x )\n", dbip, handler);
d220 1
a220 1
	if(rt_g.debug&DEBUG_DB)  {
@


11.30
log
@*- mods for handling return value of db5_get_raw_internal_ptr()
   differently. Previous code tested for <0 to indicate
   a failed attempt. However, this routine never returns
   values less than 0. It returns NULL (0) for failure and >0
   for success.
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_scan.c,v 11.29 2001/04/20 20:00:13 bparker Exp $ (ARL)";
d67 1
a67 1
		CONST unsigned char	*cp = (CONST unsigned char *)dbip->dbi_inmem;
@


11.29
log
@*- new function db_dircheck -
   incorporates the behavior from both db_diradd()
   and db5_diradd() to check for the existence
   of "name" while computing the hash once (most
   of the time) and possibly modifying name so that
   it is unique.
*- using db_dircheck in db_diradd and db5_diradd
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_scan.c,v 11.28 2001/03/23 17:03:47 kermit Exp $ (ARL)";
d288 1
a288 1
		    db5_get_raw_internal_ptr( &raw, ext.ext_buf ) < 0 )  {
@


11.28
log
@Corrected typo in comment.
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/librt/db5_scan.c,v 11.27 2001/03/23 16:56:36 kermit Exp $ (ARL)";
d129 1
a129 1
	register struct directory **headp;
a130 1
	char *cp=NULL;
d135 5
a139 21
	if( db_lookup( dbip, rip->name.ext_buf, LOOKUP_QUIET ) != DIR_NULL )  {
		register int	c;

		bu_vls_init(&local);
		bu_vls_strcpy( &local, "A_" );
		bu_vls_strcat( &local, rip->name.ext_buf );
		cp = bu_vls_addr(&local);

		for( c = 'A'; c <= 'Z'; c++ )  {
			*cp = c;
			if( db_lookup( dbip, cp, 0 ) == DIR_NULL )
				break;
		}
		if( c > 'Z' )  {
			bu_log("db5_diradd_handler: Duplicate of name '%s', ignored\n",
				cp );
			bu_vls_free(&local);
			return( DIR_NULL );
		}
		bu_log("db5_diradd_handler: Duplicate of '%s', given temporary name '%s'\n",
			rip->name.ext_buf, cp );
d146 2
a147 6
	if( cp )  {
		RT_DIR_SET_NAMEP( dp, cp );		/* sets d_namep */
		bu_vls_free( &local );
	} else {
		RT_DIR_SET_NAMEP( dp, rip->name.ext_buf ); /* sets d_namep */
	}
a189 2

	headp = &(dbip->dbi_Head[db_dirhash(dp->d_namep)]);
@


11.27
log
@Create _GLOBAL object if missing with default title and units.
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/librt/db5_scan.c,v 11.26 2001/03/22 19:37:39 jra Exp $ (ARL)";
d305 1
a305 1
			# Missing _GLOBAL object so create it and set default title and units */
@


11.26
log
@Added support for hidden flag for database objects
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/librt/db5_scan.c,v 11.25 2001/03/16 14:43:52 jra Exp $ (ARL)";
d305 2
@


11.25
log
@db5_scan() is no longer HIDDEN
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_scan.c,v 11.24 2001/01/29 16:17:10 jra Exp $ (ARL)";
d170 2
d204 2
@


11.24
log
@dbconcat now works with v5 and v4 databases
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_scan.c,v 11.23 2000/09/08 05:54:40 mike Exp $ (ARL)";
d45 1
a45 1
HIDDEN int
@


11.23
log
@
Modified tree routines to take resource pointer.
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_scan.c,v 11.22 2000/08/22 03:27:30 mike Exp $ (ARL)";
d122 6
a127 11
/*
 *			D B 5 _ D I R A D D _ H A N D L E R
 *
 * In support of db5_scan, add a named entry to the directory.
 */
HIDDEN void
db5_diradd_handler(
	struct db_i		*dbip,
	const struct db5_raw_internal *rip,
	long			laddr,
	genptr_t		client_data )	/* unused client_data from db5_scan() */
d131 2
a132 2
	struct bu_vls	local;
	char		*cp = NULL;
d134 1
a134 18
	RT_CK_DBI(dbip);

	if( rip->h_dli == DB5HDR_HFLAGS_DLI_HEADER_OBJECT )  return;
	if( rip->h_dli == DB5HDR_HFLAGS_DLI_FREE_STORAGE )  {
		/* Record available free storage */
		rt_memfree( &(dbip->dbi_freep), rip->object_length, laddr );
		return;
	}
	
	/* If somehow it doesn't have a name, ignore it */
	if( rip->name.ext_buf == NULL )  return;

	if(rt_g.debug&DEBUG_DB)  {
		bu_log("db5_diradd_handler(dbip=x%x, name='%s', addr=x%x, len=%d)\n",
			dbip, rip->name, laddr, rip->object_length );
	}

	/* XXX Extend db_diradd() to do this, and then call it! */
d153 1
a153 1
			return;
d212 34
d365 22
@


11.22
log
@
sgi lint
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_scan.c,v 11.21 2000/08/21 02:02:29 butler Exp $ (ARL)";
d156 2
d181 3
a183 2
	BU_GETSTRUCT( dp, directory );
	dp->d_magic = RT_DIR_MAGIC;
d186 1
a186 1
		dp->d_namep = bu_strdup( cp );
d189 1
a189 1
		dp->d_namep = bu_strdup( rip->name.ext_buf );
d225 4
d283 1
@


11.21
log
@Massive compilation warnings eliminated
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_scan.c,v 11.20 2000/07/26 15:13:07 mike Exp $ (ARL)";
d249 1
a249 1
	char	header[8];
@


11.20
log
@
Support for region-id-based-coloring, both import and export
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_scan.c,v 11.19 2000/07/24 19:27:31 mike Exp $ (ARL)";
d325 1
a325 1
			db5_import_color_table(cp);
@


11.19
log
@
Changed mged/typin.c to start using libwdb interfaces.
Which means mged/ged.c now also opens a libwdb interface.
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_scan.c,v 11.18 2000/07/20 21:25:36 mike Exp $ (ARL)";
d324 2
a325 1
			/* XXX Grab the region-id coloring table here */
@


11.18
log
@
Fixed bad error message
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_scan.c,v 11.17 2000/07/12 21:55:54 mike Exp $ (ARL)";
d269 1
a269 1
bu_log("WARNING:  %s is BRL-CAD v5 format.\nWARNING:  You probably need a newer version of this program to read it.\n", dbip->dbi_filename);
@


11.17
log
@
Improved function prototypes
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_scan.c,v 11.16 2000/07/07 03:49:22 mike Exp $ (ARL)";
d176 1
a176 1
			rip->name, cp );
@


11.16
log
@
Improved error checking
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_scan.c,v 11.15 2000/06/30 19:14:07 mike Exp $ (ARL)";
d45 7
a51 7
int
db5_scan( dbip, handler, client_data )
register struct db_i	*dbip;
void			(*handler)BU_ARGS((struct db_i *,
			CONST struct db5_raw_internal *,
			long addr, genptr_t client_data));
genptr_t		client_data;	/* argument for handler */
d127 6
a132 6
void
db5_diradd_handler( dbip, rip, laddr, client_data )
register struct db_i	*dbip;
CONST struct db5_raw_internal *rip;
long			laddr;
genptr_t		client_data;	/* unused client_data from db_scan() */
d234 1
d247 1
a247 2
db_dirbuild( dbip )
struct db_i	*dbip;
@


11.15
log
@
regionid_colortable
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_scan.c,v 11.14 2000/06/30 19:10:11 mike Exp $ (ARL)";
d75 1
a75 1
		    	return -1;
d81 1
a81 1
				return -1;			/* fatal error */
d95 1
a95 1
		    	return -1;
d101 1
a101 1
				return -1;			/* fatal error */
d115 1
d117 3
a119 1
	return 0;			/* success */
d245 1
@


11.14
log
@
Now able to extract title and units from the attributes
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_scan.c,v 11.13 2000/06/30 18:03:41 mike Exp $ (ARL)";
d319 3
a321 1
		/* XXX Need to grab the region-id coloring table here too */
@


11.13
log
@
Starting to scan in _GLOBAL object
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_scan.c,v 11.12 2000/06/30 17:19:19 mike Exp $ (ARL)";
d259 4
a262 1
		struct rt_db_internal	intern;
d279 4
a282 2
		if( rt_db_get_internal( &intern, dp, dbip, NULL ) < 0 )  {
			bu_log("db_dirbuild(%s): improper v5 database, corrupted %s object\n",
d284 12
d298 25
a322 3
		BU_CK_AVS( &intern.idb_avs );
bu_avs_print( &intern.idb_avs, DB5_GLOBAL_OBJECT_NAME );
return -1;
@


11.12
log
@
Modified to use new defines
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_scan.c,v 11.11 2000/06/30 14:37:20 mike Exp $ (ARL)";
d258 3
d264 20
a283 1
		return db5_scan( dbip, db5_diradd_handler, NULL );
@


11.11
log
@
Additions for putting combinations into attributes.
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_scan.c,v 11.10 2000/06/29 15:21:14 mike Exp $ (ARL)";
d187 1
a187 1
	case DB5HDR_MAJORTYPE_BRLCAD:
d209 3
a211 1
	case DB5HDR_MAJORTYPE_OPAQUE_BINARY:
d215 1
a215 1
	case DB5HDR_MAJORTYPE_ATTRIBUTE_ONLY:
@


11.10
log
@
externs
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_scan.c,v 11.9 2000/06/28 18:04:35 mike Exp $ (ARL)";
d189 2
d192 13
a204 1
			/* XXX How to check for region attribute here? */
@


11.9
log
@
Merged BRL-CAD geometry and non-geometry major types
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_scan.c,v 11.8 2000/06/27 18:14:55 mike Exp $ (ARL)";
a36 2

BU_EXTERN(CONST unsigned char *db5_get_raw_internal_ptr, (struct db5_raw_internal *rip, unsigned char * CONST ip));
@


11.8
log
@
Employed bu_external where useful
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_scan.c,v 11.7 2000/06/26 19:06:55 mike Exp $ (ARL)";
d189 7
a195 6
	case DB5HDR_MAJORTYPE_BRLCAD_NONGEOM:
		dp->d_flags = DIR_COMB;
		/* How to check for region attribute here? */
		break;
	case DB5HDR_MAJORTYPE_BRLCAD_GEOMETRY:
		dp->d_flags = DIR_SOLID;
@


11.7
log
@
More I/O stuff
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_scan.c,v 11.6 2000/06/23 21:05:56 mike Exp $ (ARL)";
d148 1
a148 1
	if( rip->name == NULL )  return;
d155 1
a155 1
	if( db_lookup( dbip, rip->name, LOOKUP_QUIET ) != DIR_NULL )  {
d160 1
a160 1
		bu_vls_strcat( &local, rip->name );
d185 1
a185 1
		dp->d_namep = bu_strdup( rip->name );
@


11.6
log
@
DLI bits live.
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_scan.c,v 11.5 2000/06/23 06:36:46 mike Exp $ (ARL)";
d38 1
a38 326
#if 0
BU_EXTERN(CONST unsigned char *db5_get_raw_internal_ptr, (struct db5_raw_internal *rip, CONST unsigned char *ip));
#endif

/*
 *			D B 5 _ H E A D E R _ I S _ V A L I D
 *
 *  Verify that this is a valid header for a BRL-CAD v5 database.
 *
 *  Returns -
 *	0	Not valid v5 header
 *	1	Valid v5 header
 */
int
db5_header_is_valid( hp )
CONST unsigned char *hp;
{
	CONST struct db5_ondisk_header *odp = (CONST struct db5_ondisk_header *)hp;

	if( odp->db5h_magic1 != DB5HDR_MAGIC1 )  return 0;
	if( hp[7] != DB5HDR_MAGIC2 )  return 0;

	/* hflags */
	if( (odp->db5h_hflags & DB5HDR_HFLAGS_DLI_MASK) != DB5HDR_HFLAGS_DLI_HEADER_OBJECT )
		return 0;
	if( (odp->db5h_hflags & DB5HDR_HFLAGS_NAME_PRESENT) )  return 0;
	if( ((odp->db5h_hflags & DB5HDR_HFLAGS_OBJECT_WIDTH_MASK) >> DB5HDR_HFLAGS_OBJECT_WIDTH_SHIFT)
	    != DB5HDR_WIDTHCODE_8BIT )  return 0;

	/* iflags */
	if( (odp->db5h_iflags & DB5HDR_IFLAGS_ZZZ_MASK) != DB5HDR_IFLAGS_ZZZ_UNCOMPRESSED )  return 0;
	if( odp->db5h_iflags & DB5HDR_IFLAGS_ATTRIBUTES_PRESENT )  return 0;
	if( odp->db5h_iflags & DB5HDR_IFLAGS_BODY_PRESENT )  return 0;
	if( ((odp->db5h_iflags & DB5HDR_IFLAGS_INTERIOR_WIDTH_MASK) >> DB5HDR_IFLAGS_INTERIOR_WIDTH_SHIFT)
	    != DB5HDR_WIDTHCODE_8BIT )  return 0;

	/* major and minor type */
	if( odp->db5h_major_type != DB5HDR_MAJORTYPE_RESERVED )  return 0;
	if( odp->db5h_minor_type != 0 )  return 0;

	/* Check length, known to be 8-bit.  Header len=1 8-byte chunk. */
	if( hp[5] != 1 )  return 0;

	/* Ensure pad is zero */
	if( hp[6] != 0 )  return 0;

	return 1;		/* valid */
}

/*
 *			D B 5 _ S E L E C T _ L E N G T H _ E N C O D I N G
 *
 *  Given a number to encode, decide which is the smallest encoding format
 *  which will contain it.
 */
int
db5_select_length_encoding( len )
long len;
{
	if( len <= 255 )  return DB5HDR_WIDTHCODE_8BIT;
	if( len <= 65535 )  return DB5HDR_WIDTHCODE_16BIT;
	if( len < 0x7ffffffe )  return DB5HDR_WIDTHCODE_32BIT;
	return DB5HDR_WIDTHCODE_64BIT;
}

/*
 *			D B 5 _ D E C O D E _ L E N G T H
 *
 *  Given a variable-width length field in network order (XDR),
 *  store it in *lenp.
 *
 *  Note that for object_length the returned number needs to be
 *  multiplied by 8, while for the other lengths, it is already a byte count.
 *
 *  Returns -
 *	The number of bytes of input that were decoded.
 */
int
db5_decode_length( lenp, cp, format )
long			*lenp;
CONST unsigned char	*cp;
int			format;
{
	switch( format )  {
	case DB5HDR_WIDTHCODE_8BIT:
		*lenp = (*cp);
		return 1;
	case DB5HDR_WIDTHCODE_16BIT:
		*lenp = BU_GSHORT(cp);
		return 2;
	case DB5HDR_WIDTHCODE_32BIT:
		*lenp = BU_GLONG(cp);
		return 4;
	case DB5HDR_WIDTHCODE_64BIT:
#if 0
		if( sizeof(long) >= 8 )  {
			*lenp = BU_GLONGLONG(cp);
			return 8;
		}
#endif
		bu_bomb("db5_decode_length(): encountered 64-bit length on 32-bit machine\n");
	}
	bu_bomb("db5_decode_length(): unknown width code\n");
	/* NOTREACHED */
}

/*
 *			D B 5 _ E N C O D E _ L E N G T H
 *
 *  Given a value and a variable-width format spec,
 *  store it in network order (XDR).
 *
 *  Returns -
 *	pointer to next available byte.
 */
unsigned char *
db5_encode_length( cp, val, format )
unsigned char	*cp;
long		val;
int		format;
{
	switch( format )  {
	case DB5HDR_WIDTHCODE_8BIT:
		*cp = val & 0xFF;
		return cp+1;
	case DB5HDR_WIDTHCODE_16BIT:
		return bu_pshort( cp, (short)val );
	case DB5HDR_WIDTHCODE_32BIT:
		return bu_plong( cp, val );
	case DB5HDR_WIDTHCODE_64BIT:
		bu_bomb("db5_encode_length(): encountered 64-bit length\n");
	}
	bu_bomb("db5_encode_length(): unknown width code\n");
	/* NOTREACHED */
}

/*
 *			D B 5 _ C R A C K _ D I S K _ H E A D E R
 *
 *  Returns -
 *	0 on success
 *	-1 on error
 */
int
db5_crack_disk_header( rip, cp )
struct db5_raw_internal		*rip;
CONST unsigned char		*cp;
{
	if( cp[0] != DB5HDR_MAGIC1 )  return 0;

	/* hflags */
	rip->h_dli = (cp[1] & DB5HDR_HFLAGS_DLI_MASK);
	rip->h_object_width = (cp[1] & DB5HDR_HFLAGS_OBJECT_WIDTH_MASK) >>
		DB5HDR_HFLAGS_OBJECT_WIDTH_SHIFT;
	rip->h_name_present = (cp[1] & DB5HDR_HFLAGS_NAME_PRESENT);

	/* iflags */
	rip->i_object_width = (cp[2] & DB5HDR_IFLAGS_INTERIOR_WIDTH_MASK) >>
		DB5HDR_IFLAGS_INTERIOR_WIDTH_SHIFT;
	rip->i_attributes_present = (cp[2] & DB5HDR_IFLAGS_ATTRIBUTES_PRESENT);
	rip->i_body_present = (cp[2] & DB5HDR_IFLAGS_BODY_PRESENT);
	rip->i_zzz = (cp[2] & DB5HDR_IFLAGS_ZZZ_MASK);

	rip->major_type = cp[3];
	rip->minor_type = cp[4];

	if(rt_g.debug&DEBUG_DB) bu_log("db5_crack_disk_header() h_dli=%d, h_object_width=%d, h_name_present=%d, i_object_width=%d, i_attributes_present=%d, i_body_present=%d, i_zzz=%d, major=%d, minor=%d\n",
		rip->h_dli,
		rip->h_object_width,
		rip->h_name_present,
		rip->i_object_width,
		rip->i_attributes_present,
		rip->i_body_present,
		rip->i_zzz,
		rip->major_type,
		rip->minor_type );

	return 0;
}

/*
 *			D B 5 _ G E T _ R A W _ I N T E R N A L _ P T R
 *
 *  Returns -
 *	on success, pointer to first unused byte
 *	NULL, on error
 */
CONST unsigned char *
db5_get_raw_internal_ptr( rip, ip )
struct db5_raw_internal		*rip;
unsigned char		* CONST ip;
{
	CONST unsigned char	*cp = ip;

	if( db5_crack_disk_header( rip, cp ) < 0 )  return NULL;
	cp += sizeof(struct db5_ondisk_header);

	cp += db5_decode_length( &rip->object_length, cp, rip->h_object_width );
	rip->object_length <<= 3;	/* cvt 8-byte chunks to byte count */

	/* Verify trailing magic number */
	if( ip[rip->object_length-1] != DB5HDR_MAGIC2 )  {
		bu_log("db5_get_raw_internal_ptr() bad magic2\n");
		return NULL;
	}

	/* Grab name, if present */
	if( rip->h_name_present )  {
		cp += db5_decode_length( &rip->name_length, cp, rip->i_object_width );
		rip->name = (char *)cp;		/* discard CONST */
		cp += rip->name_length;
	} else {
		rip->name_length = 0;
		rip->name = NULL;
	}

	/* Point to object interior, if present */
	if( rip->i_attributes_present || rip->i_body_present )  {
		/* interior_length will include any pad bytes but not magic2 */
		/* Because it may be compressed, we don't know exact len yet */
		rip->interior_length = cp - rip->buf - 1;
		rip->interior = (unsigned char *)cp;	/* discard CONST */
	} else {
		rip->interior_length = 0;
		rip->interior = NULL;
	}

	rip->buf = NULL;	/* no buffer needs freeing */

	return ip + rip->object_length;
}

/*
 *			D B 5 _ G E T _ R A W _ I N T E R N A L _ F P
 *
 *  Returns -
 *	0 on success
 *	-1 on EOF
 *	-2 on error
 */
int
db5_get_raw_internal_fp( rip, fp )
struct db5_raw_internal	*rip;
FILE			*fp;
{
	struct db5_ondisk_header	header;
	unsigned char			lenbuf[8];
	int				count;
	int				used;
	long				want, got;
	unsigned char			*cp;

	if( fread( (unsigned char *)&header, sizeof header, 1, fp ) != 1  )  {
		if( feof(fp) )  return -1;
		bu_log("db5_get_raw_internal_fp(): fread header error\n");
		return -2;
	}
	if( db5_crack_disk_header( rip, (unsigned char *)&header ) < 0 )
		return -2;
	used = sizeof(header);

	switch( rip->h_object_width )  {
	case DB5HDR_WIDTHCODE_8BIT:
		count = 1;
		break;
	case DB5HDR_WIDTHCODE_16BIT:
		count = 2;
		break;
	case DB5HDR_WIDTHCODE_32BIT:
		count = 4;
		break;
	case DB5HDR_WIDTHCODE_64BIT:
		count = 8;
	}
	if( fread( lenbuf, count, 1, fp )  != 1 )  {
		bu_log("db5_get_raw_internal_fp(): fread lenbuf error\n");
		return -2;
	}
	used += db5_decode_length( &rip->object_length, lenbuf, rip->h_object_width );
	rip->object_length <<= 3;	/* cvt 8-byte chunks to byte count */

	/* Now that we finally know how large the object is, get it all */
	rip->buf = (unsigned char *)bu_malloc( rip->object_length, "raw v5 object" );

	*((struct db5_ondisk_header *)rip->buf) = header;	/* struct copy */
	bcopy( lenbuf, rip->buf+sizeof(header), count );

	cp = rip->buf+used;
	want = rip->object_length-used;
	BU_ASSERT_LONG( want, >, 0 );
	if( (got = fread( cp, 1, want, fp )) != want ) {
		bu_log("db5_get_raw_internal_fp(), want=%ld, got=%ld, database is too short\n",
			want, got );
		return -2;
	}

	/* Verify trailing magic number */
	if( rip->buf[rip->object_length-1] != DB5HDR_MAGIC2 )  {
		bu_log("db5_get_raw_internal_fp() bad magic2\n");
		return -2;
	}

	/* Grab name, if present */
	if( rip->h_name_present )  {
		cp += db5_decode_length( &rip->name_length, cp, rip->i_object_width );
		rip->name = (char *)cp;
		cp += rip->name_length;
	} else {
		rip->name_length = 0;
		rip->name = NULL;
	}

	/* Point to object interior, if present */
	if( rip->i_attributes_present || rip->i_body_present )  {
		/* interior_length will include any pad bytes but not magic2 */
		/* Because it may be compressed, we don't know exact len yet */
		rip->interior_length = cp - rip->buf - 1;
		rip->interior = cp;
	} else {
		rip->interior_length = 0;
		rip->interior = NULL;
	}

	return 0;		/* success */
}

a261 231
}

/*
 *			D B 5 _ E X P O R T _ O B J E C T 3
 *
 *  An experimental routine for merging together the three optional
 *  parts of an object into the final on-disk format.
 *  Results in extra data copies, but serves as a starting point for testing.
 *  Any of name, attrib, and body may be null.
 */
void
db5_export_object3( out, dli, name, attrib, body, major, minor, zzz )
struct bu_external		*out;			/* output */
int				dli;
CONST char			*name;
CONST struct bu_external	*attrib;
CONST struct bu_external	*body;
int				major;
int				minor;
int				zzz;		/* compression, someday */
{
	struct db5_ondisk_header *odp;
	register unsigned char	*cp;
	long	namelen = 0;
	long	need;
	long	ineed = 0;	/* sizes of internal parts */
	int	h_width, i_width;	
	long	togo;

	/*
	 *  First, compute an upper bound on the size buffer needed.
	 *  Over-estimate on the length fields just to keep it simple.
	 */
	need = sizeof(struct db5_ondisk_header);
	need += 8;	/* for object_length */
	if( name )  {
		namelen = strlen(name) + 1;	/* includes null */
		need += namelen + 8;
		ineed = namelen;
	}
	if( attrib )  {
		BU_CK_EXTERNAL(attrib);
		need += attrib->ext_nbytes + 8;
		ineed |= attrib->ext_nbytes;
	}
	if( body )  {
		BU_CK_EXTERNAL(body);
		need += body->ext_nbytes + 8;
		ineed |= body->ext_nbytes;
	}
	need += 8;	/* pad and magic2 */

	/* Allocate the buffer for the combined external representation */
	out->ext_magic = BU_EXTERNAL_MAGIC;
	out->ext_nbytes = 0;
	out->ext_buf = bu_malloc( need, "external object3" );

	/* Determine encoding for the two kinds of length fields */
	h_width = db5_select_length_encoding( (need+7)>>3 );
	i_width = db5_select_length_encoding( ineed );

	/* prepare combined external object */
	odp = (struct db5_ondisk_header *)out->ext_buf;
	odp->db5h_magic1 = DB5HDR_MAGIC1;

	/* hflags */
	odp->db5h_hflags = (h_width << DB5HDR_HFLAGS_OBJECT_WIDTH_SHIFT) |
			(dli & DB5HDR_HFLAGS_DLI_MASK);
	if( name )  odp->db5h_hflags |= DB5HDR_HFLAGS_NAME_PRESENT;

	/* iflags */
	odp->db5h_iflags = i_width << DB5HDR_IFLAGS_INTERIOR_WIDTH_SHIFT;
	if( attrib )  odp->db5h_iflags |= DB5HDR_IFLAGS_ATTRIBUTES_PRESENT;
	if( body )  odp->db5h_iflags |= DB5HDR_IFLAGS_BODY_PRESENT;
	odp->db5h_iflags |= zzz & DB5HDR_IFLAGS_ZZZ_MASK;

	if( zzz )  bu_bomb("db5_export_object3: compression not supported yet\n");

	/* Object_Type */
	odp->db5h_major_type = major;
	odp->db5h_minor_type = minor;

	/* Build up the rest of the record */
	cp = ((unsigned char *)out->ext_buf) + sizeof(struct db5_ondisk_header);
	cp = db5_encode_length( cp, 0L, h_width );	/* will be replaced below */

	if( name )  {
		cp = db5_encode_length( cp, namelen, i_width );
		bcopy( name, cp, namelen );	/* includes null */
		cp += namelen;
	}

	if( attrib )  {
		cp = db5_encode_length( cp, attrib->ext_nbytes, i_width );
		bcopy( attrib->ext_buf, cp, attrib->ext_nbytes );
		cp += attrib->ext_nbytes;
	}

	if( body )  {
		cp = db5_encode_length( cp, body->ext_nbytes, i_width );
		bcopy( body->ext_buf, cp, body->ext_nbytes );
		cp += body->ext_nbytes;
	}

	togo = cp - ((unsigned char *)out->ext_buf) + 1;
	togo &= 7;
	if( togo != 0 )  {
		togo = 8 - togo;
		while( togo-- > 0 )  *cp++ = '\0';
	}
	*cp++ = DB5HDR_MAGIC2;

	/* Verify multiple of 8 */
	togo = cp - ((unsigned char *)out->ext_buf);
	BU_ASSERT_LONG( togo&7, ==, 0 );

	/* Finally, go back to the header and write the actual object length */
	cp = ((unsigned char *)out->ext_buf) + sizeof(struct db5_ondisk_header);
	cp = db5_encode_length( cp, togo>>3, h_width );

	out->ext_nbytes = togo;
}

/*
 *			D B 5 _ E X P O R T _ A T T R I B U T E S
 *
 *  One attempt at encoding attribute-value information in the external
 *  format.
 *  This may not be the best or only way to do it, but it gets things
 *  started, for testing.
 *
 *  The on-disk encoding is:
 *
 *	aname1 NULL value1 NULL ... anameN NULL valueN NULL NULL
 */
void
db5_export_attributes( ext, avp )
struct bu_external		*ext;
CONST struct attribute_value_pair	*avp;
{
	int	need = 0;
	CONST struct attribute_value_pair	*avpp;
	char	*cp;

	/* First pass -- determine how much space is required */
	for( avpp = avp; avpp->name != NULL; avpp++ )  {
		need += strlen( avpp->name ) + strlen( avpp->value ) + 2;
	}
	need += 1;		/* for final null */

	ext->ext_magic = BU_EXTERNAL_MAGIC;
	ext->ext_nbytes = need;
	ext->ext_buf = bu_malloc( need, "external attributes" );

	/* Second pass -- store in external form */
	cp = (char *)ext->ext_buf;
	for( avpp = avp; avpp->name != NULL; avpp++ )  {
		need = strlen( avpp->name ) + 1;
		bcopy( avpp->name, cp, need );
		cp += need;

		need = strlen( avpp->value ) + 1;
		bcopy( avpp->value, cp, need );
		cp += need;
	}
	*cp++ = '\0';
	need = cp - ((char *)ext->ext_buf);
	BU_ASSERT_LONG( need, ==, ext->ext_nbytes );
}

/*
 *			D B 5 _ F W R I T E _ I D E N T
 *
 *  Create a header for a v5 database.
 *  This routine has the same calling sequence as db_fwrite_ident()
 *  which makes a v4 database header.
 *
 *  In the v5 database, two database objects must be created to
 *  match the semantics of what was in the v4 header:
 *
 *  First, a database header object.
 *
 *  Second, an attribute-only object named "_GLOBAL" which
 *  contains the attributes "title=" and "units=".
 *
 * Returns -
 *	 0	Success
 *	-1	Fatal Error
 */
int
db5_fwrite_ident( fp, title, local2mm )
FILE		*fp;
CONST char	*title;
double		local2mm;
{
	struct attribute_value_pair avp[3];
	struct bu_vls		units;
	struct bu_external	out;
	struct bu_external	attr;

	/* First, write the header object */
	db5_export_object3( &out, DB5HDR_HFLAGS_DLI_HEADER_OBJECT,
		NULL, NULL, NULL,
		DB5HDR_MAJORTYPE_RESERVED, 0,
		DB5HDR_IFLAGS_ZZZ_UNCOMPRESSED );
	bu_fwrite_external( fp, &out );
	bu_free_external( &out );

	/* Second, create the attribute-only object */
	bu_vls_init( &units );
	bu_vls_printf( &units, "%.25f", local2mm );

	avp[0].name = "title";
	avp[0].value = (char *)title;		/* un-CONST */
	avp[1].name = "units";
	avp[1].value = bu_vls_addr(&units);
	avp[2].name = NULL;
	avp[2].value = NULL;

	db5_export_attributes( &attr, avp );
	db5_export_object3( &out, DB5HDR_HFLAGS_DLI_APPLICATION_DATA_OBJECT,
		"_GLOBAL", &attr, NULL,
		DB5HDR_MAJORTYPE_ATTRIBUTE_ONLY, 0,
		DB5HDR_IFLAGS_ZZZ_UNCOMPRESSED);
	bu_fwrite_external( fp, &out );
	bu_free_external( &out );
	bu_free_external( &attr );

	bu_vls_free( &units );

	return 0;
@


11.5
log
@
This version actually works. :-)
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_scan.c,v 11.4 2000/06/23 05:52:19 mike Exp $ (ARL)";
d45 2
d61 2
d75 2
a76 2
	if( odp->db5h_major_type != DB5HDR_MAJORTYPE_DLI )  return 0;
	if( odp->db5h_minor_type != DB5HDR_MINORTYPE_DLI_HEADER )  return 0;
d189 1
d204 2
a205 1
	if(rt_g.debug&DEBUG_DB) bu_log("db5_crack_disk_header() h_object_width=%d, h_name_present=%d, i_object_width=%d, i_attributes_present=%d, i_body_present=%d, i_zzz=%d, major=%d, minor=%d\n",
d465 2
a466 2
	if( rip->major_type == DB5HDR_MAJORTYPE_DLI )  {
		if( rip->minor_type != DB5HDR_MINORTYPE_DLI_FREE )  return;
d598 1
a598 1
db5_export_object3( out, name, attrib, body, major, minor, zzz )
d600 1
d653 2
a654 1
	odp->db5h_hflags = h_width << DB5HDR_HFLAGS_OBJECT_WIDTH_SHIFT;
a781 1
	unsigned char	header[8];
d787 5
a791 26
	header[0] = DB5HDR_MAGIC1;

	/* hflags */
	header[1] = DB5HDR_WIDTHCODE_8BIT << DB5HDR_HFLAGS_OBJECT_WIDTH_SHIFT;

	/* iflags */
	header[2] = DB5HDR_IFLAGS_ZZZ_UNCOMPRESSED |
		(DB5HDR_WIDTHCODE_8BIT << DB5HDR_IFLAGS_INTERIOR_WIDTH_SHIFT);

	/* major and minor type */
	header[3] = DB5HDR_MAJORTYPE_DLI;
	header[4] = DB5HDR_MINORTYPE_DLI_HEADER;

	header[5] = 1;		/* One 8-byte chunk, encoded as WIDTHCODE_8BIT */

	header[6] = 0;		/* pad */
	header[7] = DB5HDR_MAGIC2;

	if( fwrite( header, sizeof(header), 1, fp ) != 1 )  {
		bu_log("db5_write_ident() write error\n");
		return -1;
	}

	/* We should get the same result if we do this */
	/* No harm in writing two headers, for testing */
	db5_export_object3( &out, NULL, NULL, NULL, DB5HDR_MAJORTYPE_DLI, DB5HDR_MINORTYPE_DLI_HEADER, DB5HDR_IFLAGS_ZZZ_UNCOMPRESSED );
d807 4
a810 1
	db5_export_object3( &out, "_GLOBAL", &attr, NULL, DB5HDR_MAJORTYPE_ATTRIBUTE_ONLY, 0, DB5HDR_IFLAGS_ZZZ_UNCOMPRESSED);
@


11.4
log
@
Added initial encodings.
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_scan.c,v 11.3 2000/06/23 03:32:41 mike Exp $ (ARL)";
d199 10
d322 1
a322 1
	if( (got = fread( cp, want, 1, fp )) != want ) {
d387 1
a387 1
	if( dbip->dbi_inmem )  {
d389 4
d400 1
a400 1
		for(;;)  {
d409 1
d563 1
a563 1
bu_log("WARNING:  %s is BRL-CAD v5 format, you need a newer version of this program to read it.\n", dbip->dbi_filename);
d699 1
d798 1
a798 1
	if( fwrite( header, sizeof(header), 1, fp ) != 0 )  {
@


11.3
log
@
Added generic db_dirbuild().
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_scan.c,v 11.2 2000/06/23 02:41:03 mike Exp $ (ARL)";
d80 17
d128 1
d133 1
d141 30
d209 1
a209 1
unsigned char * CONST
d231 1
a231 1
		rip->name = (unsigned char *)cp;	/* discard CONST */
d243 1
a243 1
		rip->interior = (unsigned char *)cp;	/* discart CONST */
d327 1
a327 1
		rip->name = cp;
d378 1
a378 1
		unsigned char	*cp = (unsigned char *)dbip->dbi_inmem;
d548 1
d566 247
@


11.2
log
@
Added fast-path for in-memory databases
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_scan.c,v 11.1 2000/06/23 02:12:44 mike Exp $ (ARL)";
d374 142
@


11.1
log
@
First draft of db5_scan.c
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
d38 4
d122 2
d154 2
d160 1
a160 1
CONST unsigned char *
d163 1
a163 1
CONST unsigned char		*ip;
d200 2
d206 2
d324 2
a325 8
	/* In a portable way, read the header (even if not rewound) */
	rewind( dbip->dbi_fp );
	if( fread( header, sizeof header, 1, dbip->dbi_fp ) != 1  ||
	    db5_header_is_valid( header ) == 0 )  {
		bu_log("db_scan ERROR:  %s is lacking a proper BRL-CAD v5 database header\n", dbip->dbi_filename);
	    	return(-1);
	}
	rewind( dbip->dbi_fp );
d327 39
a365 8
	addr = 0L;
	nrec = 0L;
	raw.magic = DB5_RAW_INTERNAL_MAGIC;
	while(1)  {
		addr = ftell( dbip->dbi_fp );
		if( (got = db5_get_raw_internal_fp( &raw, dbip->dbi_fp )) < 0 )  {
			if( got == -1 )  break;		/* EOF */
			return -1;			/* fatal error */
d367 2
a368 2
		(*handler)(dbip, &raw, addr, client_data);
		nrec++;
d371 1
a371 3
	dbip->dbi_nrec = nrec;			/* # obj in db, including header */
	dbip->dbi_eof = ftell( dbip->dbi_fp );
	rewind( dbip->dbi_fp );
d373 1
a373 1
	return 0;				/* success */
@

