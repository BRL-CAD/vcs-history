head	1.126;
access;
symbols
	ansi-20040405-merged:1.103.2.2
	postmerge-20040405-ansi:1.124
	premerge-20040404-ansi:1.123
	postmerge-autoconf:1.123
	autoconf-freeze:1.120.2.3
	premerge-autoconf:1.123
	ansi-20040316-freeze:1.103.2.1
	postmerge-20040315-windows:1.123
	premerge-20040315-windows:1.123
	windows-20040315-freeze:1.103.4.1
	autoconf-20031203:1.120.2.1
	autoconf-20031202:1.120
	autoconf-branch:1.120.0.2
	phong-branch:1.119.0.2
	photonmap-branch:1.112.0.2
	rel-6-1-DP:1.103
	windows-branch:1.103.0.4
	rel-6-0-2:1.101
	ansi-branch:1.103.0.2
	rel-6-0-1-branch:1.101.0.2
	hartley-6-0-post:1.102
	hartley-6-0-pre:1.101
	rel-6-0-1:1.101
	rel-6-0:1.99
	rel-5-4:1.54.2.9
	offsite-5-3-pre:1.70
	rel-5-3:1.54.2.8
	rel-5-2:1.54.2.2
	rel-5-1-branch:1.54.0.2
	rel-5-1:1.54;
locks; strict;
comment	@ * @;


1.126
date	2004.05.21.18.07.30;	author morrison;	state dead;
branches;
next	1.125;

1.125
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	1.124;

1.124
date	2004.04.05.08.48.56;	author morrison;	state Exp;
branches;
next	1.123;

1.123
date	2004.02.02.17.39.16;	author morrison;	state Exp;
branches;
next	1.122;

1.122
date	2003.11.19.21.45.04;	author jra;	state Exp;
branches;
next	1.121;

1.121
date	2003.11.04.19.40.24;	author morrison;	state Exp;
branches;
next	1.120;

1.120
date	2003.10.03.19.47.39;	author jra;	state Exp;
branches
	1.120.2.1;
next	1.119;

1.119
date	2003.09.10.00.31.41;	author jra;	state Exp;
branches;
next	1.118;

1.118
date	2003.09.09.12.36.15;	author jra;	state Exp;
branches;
next	1.117;

1.117
date	2003.08.25.18.44.22;	author jra;	state Exp;
branches;
next	1.116;

1.116
date	2003.08.20.00.55.06;	author jra;	state Exp;
branches;
next	1.115;

1.115
date	2003.07.29.12.09.21;	author jra;	state Exp;
branches;
next	1.114;

1.114
date	2003.07.28.18.56.42;	author jra;	state Exp;
branches;
next	1.113;

1.113
date	2003.04.25.00.56.31;	author jra;	state Exp;
branches;
next	1.112;

1.112
date	2003.04.07.12.47.19;	author jra;	state Exp;
branches
	1.112.2.1;
next	1.111;

1.111
date	2003.04.01.14.05.58;	author jra;	state Exp;
branches;
next	1.110;

1.110
date	2003.02.12.21.07.41;	author jra;	state Exp;
branches;
next	1.109;

1.109
date	2003.02.12.15.59.44;	author jra;	state Exp;
branches;
next	1.108;

1.108
date	2003.01.31.13.37.27;	author jra;	state Exp;
branches;
next	1.107;

1.107
date	2002.12.03.13.35.18;	author jra;	state Exp;
branches;
next	1.106;

1.106
date	2002.11.29.03.13.20;	author jra;	state Exp;
branches;
next	1.105;

1.105
date	2002.11.27.14.29.40;	author jra;	state Exp;
branches;
next	1.104;

1.104
date	2002.11.27.13.42.56;	author jra;	state Exp;
branches;
next	1.103;

1.103
date	2002.08.20.17.07.58;	author jra;	state Exp;
branches
	1.103.2.1
	1.103.4.1;
next	1.102;

1.102
date	2002.08.15.20.55.11;	author hartley;	state Exp;
branches;
next	1.101;

1.101
date	2002.05.29.15.13.16;	author jra;	state Exp;
branches;
next	1.100;

1.100
date	2002.04.24.19.46.31;	author jra;	state Exp;
branches;
next	1.99;

1.99
date	2002.03.21.22.00.54;	author jra;	state Exp;
branches;
next	1.98;

1.98
date	2002.03.21.05.19.22;	author jra;	state Exp;
branches;
next	1.97;

1.97
date	2002.03.20.01.50.22;	author jra;	state Exp;
branches;
next	1.96;

1.96
date	2002.03.19.04.00.28;	author jra;	state Exp;
branches;
next	1.95;

1.95
date	2002.02.25.13.57.22;	author jra;	state Exp;
branches;
next	1.94;

1.94
date	2002.02.19.03.03.09;	author jra;	state Exp;
branches;
next	1.93;

1.93
date	2002.01.24.15.50.23;	author jra;	state Exp;
branches;
next	1.92;

1.92
date	2002.01.22.19.01.43;	author jra;	state Exp;
branches;
next	1.91;

1.91
date	2001.12.13.19.35.15;	author jra;	state Exp;
branches;
next	1.90;

1.90
date	2001.12.08.21.11.18;	author jra;	state Exp;
branches;
next	1.89;

1.89
date	2001.11.29.18.10.36;	author jra;	state Exp;
branches;
next	1.88;

1.88
date	2001.11.26.19.37.16;	author butler;	state Exp;
branches;
next	1.87;

1.87
date	2001.11.22.02.12.34;	author butler;	state Exp;
branches;
next	1.86;

1.86
date	2001.11.16.14.56.30;	author jra;	state Exp;
branches;
next	1.85;

1.85
date	2001.11.08.22.32.28;	author jra;	state Exp;
branches;
next	1.84;

1.84
date	2001.11.08.15.41.45;	author butler;	state Exp;
branches;
next	1.83;

1.83
date	2001.11.07.19.35.38;	author butler;	state Exp;
branches;
next	1.82;

1.82
date	2001.10.02.19.24.28;	author jra;	state Exp;
branches;
next	1.81;

1.81
date	2001.09.26.20.48.27;	author jra;	state Exp;
branches;
next	1.80;

1.80
date	2001.09.11.12.31.42;	author jra;	state Exp;
branches;
next	1.79;

1.79
date	2001.09.04.15.26.40;	author jra;	state Exp;
branches;
next	1.78;

1.78
date	2001.07.22.02.38.16;	author jra;	state Exp;
branches;
next	1.77;

1.77
date	2001.07.09.21.28.48;	author jra;	state Exp;
branches;
next	1.76;

1.76
date	2001.05.17.20.05.24;	author morrison;	state Exp;
branches;
next	1.75;

1.75
date	2001.05.02.19.31.42;	author jra;	state Exp;
branches;
next	1.74;

1.74
date	2001.04.20.22.29.42;	author morrison;	state Exp;
branches;
next	1.73;

1.73
date	2001.04.13.14.13.45;	author jra;	state Exp;
branches;
next	1.72;

1.72
date	2001.04.05.19.35.34;	author morrison;	state Exp;
branches;
next	1.71;

1.71
date	2001.03.19.22.19.57;	author butler;	state Exp;
branches;
next	1.70;

1.70
date	2000.11.17.06.01.57;	author mike;	state Exp;
branches;
next	1.69;

1.69
date	2000.11.13.13.41.30;	author jra;	state Exp;
branches;
next	1.68;

1.68
date	2000.11.13.13.37.13;	author jra;	state Exp;
branches;
next	1.67;

1.67
date	2000.11.07.19.51.09;	author jra;	state Exp;
branches;
next	1.66;

1.66
date	2000.11.01.06.46.12;	author mike;	state Exp;
branches;
next	1.65;

1.65
date	2000.10.24.18.18.00;	author mike;	state Exp;
branches;
next	1.64;

1.64
date	2000.10.24.14.36.26;	author mike;	state Exp;
branches;
next	1.63;

1.63
date	2000.10.18.15.32.40;	author jra;	state Exp;
branches;
next	1.62;

1.62
date	2000.09.12.19.08.41;	author jra;	state Exp;
branches;
next	1.61;

1.61
date	2000.08.21.02.02.29;	author butler;	state Exp;
branches;
next	1.60;

1.60
date	2000.08.17.20.54.55;	author jra;	state Exp;
branches;
next	1.59;

1.59
date	2000.07.10.23.01.30;	author mike;	state Exp;
branches;
next	1.58;

1.58
date	2000.06.30.15.38.02;	author mike;	state Exp;
branches;
next	1.57;

1.57
date	2000.06.30.15.31.14;	author mike;	state Exp;
branches;
next	1.56;

1.56
date	2000.06.29.14.41.23;	author jra;	state Exp;
branches;
next	1.55;

1.55
date	2000.06.28.18.22.20;	author jra;	state Exp;
branches;
next	1.54;

1.54
date	2000.06.19.18.19.31;	author jra;	state Exp;
branches
	1.54.2.1;
next	1.53;

1.53
date	2000.06.05.23.45.51;	author mike;	state Exp;
branches;
next	1.52;

1.52
date	2000.06.05.23.44.47;	author mike;	state Exp;
branches;
next	1.51;

1.51
date	2000.06.05.21.17.30;	author jra;	state Exp;
branches;
next	1.50;

1.50
date	2000.05.24.01.00.08;	author mike;	state Exp;
branches;
next	1.49;

1.49
date	2000.05.22.05.12.30;	author mike;	state Exp;
branches;
next	1.48;

1.48
date	2000.05.19.05.33.40;	author mike;	state Exp;
branches;
next	1.47;

1.47
date	2000.05.19.05.23.34;	author mike;	state Exp;
branches;
next	1.46;

1.46
date	2000.05.19.02.35.42;	author mike;	state Exp;
branches;
next	1.45;

1.45
date	2000.05.18.16.54.29;	author mike;	state Exp;
branches;
next	1.44;

1.44
date	2000.05.18.16.31.11;	author mike;	state Exp;
branches;
next	1.43;

1.43
date	2000.05.18.04.15.59;	author mike;	state Exp;
branches;
next	1.42;

1.42
date	2000.05.18.02.02.26;	author mike;	state Exp;
branches;
next	1.41;

1.41
date	2000.05.12.20.19.02;	author mike;	state Exp;
branches;
next	1.40;

1.40
date	2000.05.12.01.37.21;	author mike;	state Exp;
branches;
next	1.39;

1.39
date	2000.05.12.01.29.44;	author mike;	state Exp;
branches;
next	1.38;

1.38
date	2000.05.12.01.10.38;	author mike;	state Exp;
branches;
next	1.37;

1.37
date	2000.05.11.22.09.33;	author mike;	state Exp;
branches;
next	1.36;

1.36
date	2000.05.11.21.51.19;	author mike;	state Exp;
branches;
next	1.35;

1.35
date	2000.05.11.21.48.17;	author mike;	state Exp;
branches;
next	1.34;

1.34
date	2000.05.11.21.44.48;	author mike;	state Exp;
branches;
next	1.33;

1.33
date	2000.05.11.21.25.19;	author mike;	state Exp;
branches;
next	1.32;

1.32
date	2000.05.11.03.18.47;	author mike;	state Exp;
branches;
next	1.31;

1.31
date	2000.05.09.20.45.11;	author mike;	state Exp;
branches;
next	1.30;

1.30
date	2000.05.08.20.46.57;	author mike;	state Exp;
branches;
next	1.29;

1.29
date	2000.04.15.02.04.41;	author mike;	state Exp;
branches;
next	1.28;

1.28
date	2000.04.12.02.34.31;	author mike;	state Exp;
branches;
next	1.27;

1.27
date	2000.03.29.02.43.09;	author mike;	state Exp;
branches;
next	1.26;

1.26
date	2000.03.28.21.59.04;	author mike;	state Exp;
branches;
next	1.25;

1.25
date	2000.03.07.02.14.35;	author mike;	state Exp;
branches;
next	1.24;

1.24
date	2000.03.03.21.29.07;	author jra;	state Exp;
branches;
next	1.23;

1.23
date	2000.03.02.14.46.35;	author jra;	state Exp;
branches;
next	1.22;

1.22
date	2000.02.29.20.38.39;	author mike;	state Exp;
branches;
next	1.21;

1.21
date	2000.02.10.19.45.59;	author jra;	state Exp;
branches;
next	1.20;

1.20
date	99.12.29.21.14.20;	author jra;	state Exp;
branches;
next	1.19;

1.19
date	99.12.20.21.46.37;	author jra;	state Exp;
branches;
next	1.18;

1.18
date	99.12.20.20.00.06;	author jra;	state Exp;
branches;
next	1.17;

1.17
date	99.12.16.17.28.05;	author jra;	state Exp;
branches;
next	1.16;

1.16
date	99.12.16.17.18.45;	author jra;	state Exp;
branches;
next	1.15;

1.15
date	99.12.09.20.30.16;	author jra;	state Exp;
branches;
next	1.14;

1.14
date	99.12.08.14.00.17;	author jra;	state Exp;
branches;
next	1.13;

1.13
date	99.12.07.20.59.44;	author jra;	state Exp;
branches;
next	1.12;

1.12
date	99.12.06.20.17.37;	author jra;	state Exp;
branches;
next	1.11;

1.11
date	99.11.26.22.02.53;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	99.11.26.19.35.15;	author jra;	state Exp;
branches;
next	1.9;

1.9
date	99.11.26.15.05.36;	author jra;	state Exp;
branches;
next	1.8;

1.8
date	99.11.24.14.39.52;	author jra;	state Exp;
branches;
next	1.7;

1.7
date	99.11.17.19.02.33;	author jra;	state Exp;
branches;
next	1.6;

1.6
date	99.11.17.02.41.56;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	99.11.15.13.35.20;	author jra;	state Exp;
branches;
next	1.4;

1.4
date	99.11.09.15.05.54;	author jra;	state Exp;
branches;
next	1.3;

1.3
date	99.11.08.20.11.06;	author jra;	state Exp;
branches;
next	1.2;

1.2
date	99.11.08.18.27.30;	author jra;	state Exp;
branches;
next	1.1;

1.1
date	99.11.08.15.41.51;	author jra;	state Exp;
branches;
next	;

1.54.2.1
date	2000.08.18.12.44.51;	author jra;	state Exp;
branches;
next	1.54.2.2;

1.54.2.2
date	2000.09.01.14.35.17;	author jra;	state Exp;
branches;
next	1.54.2.3;

1.54.2.3
date	2000.10.18.17.20.36;	author jra;	state Exp;
branches;
next	1.54.2.4;

1.54.2.4
date	2000.10.26.12.42.09;	author jra;	state Exp;
branches;
next	1.54.2.5;

1.54.2.5
date	2000.11.01.18.43.54;	author jra;	state Exp;
branches;
next	1.54.2.6;

1.54.2.6
date	2000.11.04.02.41.23;	author jra;	state Exp;
branches;
next	1.54.2.7;

1.54.2.7
date	2000.11.07.19.48.13;	author jra;	state Exp;
branches;
next	1.54.2.8;

1.54.2.8
date	2000.11.09.14.41.52;	author jra;	state Exp;
branches;
next	1.54.2.9;

1.54.2.9
date	2001.07.11.12.31.50;	author jra;	state Exp;
branches;
next	;

1.103.2.1
date	2002.09.19.18.01.32;	author morrison;	state Exp;
branches;
next	1.103.2.2;

1.103.2.2
date	2004.03.17.21.18.45;	author morrison;	state Exp;
branches;
next	;

1.103.4.1
date	2004.03.11.23.43.36;	author morrison;	state Exp;
branches;
next	;

1.112.2.1
date	2003.08.26.14.03.35;	author justin;	state Exp;
branches;
next	;

1.120.2.1
date	2003.12.03.16.24.06;	author erikg;	state Exp;
branches;
next	1.120.2.2;

1.120.2.2
date	2004.02.12.18.37.39;	author erikg;	state Exp;
branches;
next	1.120.2.3;

1.120.2.3
date	2004.03.15.14.07.18;	author erikg;	state Exp;
branches;
next	;


desc
@@


1.126
log
@moved to src/
@
text
@/*
 *			G _ B O T . C
 *
 *  Purpose -
 *	Intersect a ray with a bag o' triangles
 *
 *  Authors -
 *  	John R. Anderson
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1999-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSbot[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/g_bot.c,v 1.125 2004/05/10 15:30:46 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include <math.h>
#include <ctype.h>
#include "tcl.h"
#include "machine.h"
#include "vmath.h"
#include "db.h"
#include "nmg.h"
#include "raytrace.h"
#include "rtgeom.h"
#include "./debug.h"
#include "./plane.h"
#include "./bot.h"

#define GLUE(_a, _b)      _a ## _b
#define XGLUE(_a,_b)      GLUE(_a,_b)

/* Set to 32 to enable pieces by default */
int rt_bot_minpieces = RT_DEFAULT_MINPIECES;
int rt_bot_tri_per_piece = RT_DEFAULT_TRIS_PER_PIECE;

#define MAXHITS 128

#define BOT_MIN_DN	1.0e-9

#define RT_BOT_UNORIENTED_NORM( _hitp, _in_or_out)	{ \
	if( _in_or_out < 0 ) {	/* this is an exit */ \
		if( (_hitp)->hit_vpriv[X] < 0.0 ) { \
			VREVERSE( (_hitp)->hit_normal, trip->tri_N ); \
		} else { \
			VMOVE( (_hitp)->hit_normal, trip->tri_N ); \
		} \
	} else {	/* this is an entrance */ \
		if( (_hitp)->hit_vpriv[X] > 0.0 ) { \
			VREVERSE( (_hitp)->hit_normal, trip->tri_N ); \
		} else { \
			VMOVE( (_hitp)->hit_normal, trip->tri_N ); \
		} \
	} \
}

/* forward declarations needed for the included routines below */
HIDDEN int
rt_bot_makesegs(
		struct hit		*hits,
		int			nhits,
		struct soltab		*stp,
		struct xray		*rp,
		struct application	*ap,
		struct seg		*seghead,
		struct rt_piecestate	*psp);

static int
rt_bot_unoriented_segs(struct hit		*hits,
		  int			nhits,
		  struct soltab		*stp,
		  struct xray		*rp,
		  struct application	*ap,
		  struct seg		*seghead,
		  struct bot_specific	*bot);

int
rt_botface_w_normals(struct soltab	*stp,
		     struct bot_specific	*bot,
		     fastf_t		*ap,
		     fastf_t		*bp,
		     fastf_t		*cp,
		     fastf_t		*vertex_normals, /* array of nine values (three unit normals vectors) */
		     int			face_no,
		     const struct bn_tol	*tol);


#define TRI_TYPE	float
#define NORM_TYPE	signed char
#define NORMAL_SCALE	127.0
#define ONE_OVER_SCALE	(1.0/127.0)
#include "./g_bot_include.c"
#undef TRI_TYPE
#undef NORM_TYPE
#undef NORMAL_SCALE
#undef ONE_OVER_SCALE
#define TRI_TYPE	double
#define NORM_TYPE	fastf_t
#define NORMAL_SCALE	1.0
#define ONE_OVER_SCALE	1.0
#include "./g_bot_include.c"
#undef TRI_TYPE
#undef NORM_TYPE
#undef NORMAL_SCALE
#undef ONE_OVER_SCALE
					

/*
 *			R T _ B O T F A C E
 *
 *  This function is called with pointers to 3 points,
 *  and is used to prepare BOT faces.
 *  ap, bp, cp point to vect_t points.
 *
 * Return -
 *	0	if the 3 points didn't form a plane (eg, colinear, etc).
 *	#pts	(3) if a valid plane resulted.
 */
int
rt_botface_w_normals(struct soltab	*stp,
	   struct bot_specific	*bot,
	   fastf_t		*ap,
	   fastf_t		*bp,
	   fastf_t		*cp,
	   fastf_t		*vertex_normals, /* array of nine values (three unit normals vectors) */
	   int			face_no,
	   const struct bn_tol	*tol)
{

	if( bot->bot_flags & RT_BOT_USE_FLOATS ) {
		return rt_botface_w_normals_float( stp, bot, ap, bp, cp,
						   vertex_normals, face_no, tol );
	} else {
		return rt_botface_w_normals_double( stp, bot, ap, bp, cp,
						   vertex_normals, face_no, tol );
	}
}

int
rt_botface(struct soltab	*stp,
	   struct bot_specific	*bot,
	   fastf_t		*ap,
	   fastf_t		*bp,
	   fastf_t		*cp,
	   int			face_no,
	   const struct bn_tol	*tol)
{
	return( rt_botface_w_normals( stp, bot, ap, bp, cp, NULL, face_no, tol ) );
}

/*
 *	Do the prep to support pieces for a BOT/ARS
 *
 */
void
rt_bot_prep_pieces(struct bot_specific	*bot,
		   struct soltab	*stp,
		   int			ntri,
		   const struct bn_tol		*tol)
{
	if( bot->bot_flags & RT_BOT_USE_FLOATS ) {
		rt_bot_prep_pieces_float( bot, stp, ntri, tol );
	} else {
		rt_bot_prep_pieces_double( bot, stp, ntri, tol );
	}
}

/*
 *  			R T _ B O T _ P R E P
 *  
 *  Given a pointer to a GED database record, and a transformation matrix,
 *  determine if this is a valid BOT, and if so, precompute various
 *  terms of the formula.
 *  
 *  Returns -
 *  	0	BOT is OK
 *  	!0	Error in description
 *  
 *  Implicit return -
 *  	A struct bot_specific is created, and it's address is stored in
 *  	stp->st_specific for use by bot_shot().
 */
int
rt_bot_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
{
	struct rt_bot_internal		*bot_ip;


	RT_CK_DB_INTERNAL(ip);
	bot_ip = (struct rt_bot_internal *)ip->idb_ptr;
	RT_BOT_CK_MAGIC(bot_ip);

	if( bot_ip->bot_flags & RT_BOT_USE_FLOATS ) {
		return (rt_bot_prep_float( stp, bot_ip, rtip ));
	} else {
		return( rt_bot_prep_double( stp, bot_ip, rtip ));
	}
}

/*
 *			R T _ B O T _ P R I N T
 */
void
rt_bot_print(register const struct soltab *stp)
{
}

static int
rt_bot_plate_segs(struct hit		*hits,
		  int			nhits,
		  struct soltab		*stp,
		  struct xray		*rp,
		  struct application	*ap,
		  struct seg		*seghead,
		  struct bot_specific	*bot)
{
	if( bot->bot_flags & RT_BOT_USE_FLOATS ) {
		return (rt_bot_plate_segs_float( hits, nhits, stp, rp, ap, seghead, bot ));
	} else {
		return (rt_bot_plate_segs_double( hits, nhits, stp, rp, ap, seghead, bot ));
	}
}

static int
rt_bot_unoriented_segs(struct hit		*hits,
		  int			nhits,
		  struct soltab		*stp,
		  struct xray		*rp,
		  struct application	*ap,
		  struct seg		*seghead,
		  struct bot_specific	*bot)
{
	if( bot->bot_flags & RT_BOT_USE_FLOATS ) {
		return (rt_bot_unoriented_segs_float( hits, nhits, stp, rp, ap, seghead, bot ));
	} else {
		return (rt_bot_unoriented_segs_double( hits, nhits, stp, rp, ap, seghead, bot ));
	}
}



/*
 *			R T _ B O T _ M A K E S E G S
 *
 *  Given an array of hits, make segments out of them.
 *  Exactly how this is to be done depends on the mode of the BoT.
 */
HIDDEN int
rt_bot_makesegs(struct hit *hits, int nhits, struct soltab *stp, struct xray *rp, struct application *ap, struct seg *seghead, struct rt_piecestate *psp)
{
    struct bot_specific *bot = (struct bot_specific *)stp->st_specific;

    if(bot->bot_mode == RT_BOT_PLATE ||
       bot->bot_mode == RT_BOT_PLATE_NOCOS) {
	return rt_bot_plate_segs(hits, nhits, stp, rp, ap, seghead, bot);
    }

    if( bot->bot_flags & RT_BOT_USE_FLOATS ) {
	    return( rt_bot_makesegs_float( hits, nhits, stp, rp, ap, seghead, psp ) );
    } else {
	    return( rt_bot_makesegs_double( hits, nhits, stp, rp, ap, seghead, psp ) );
    }
}

/*
 *  			R T _ B O T _ S H O T
 *  
 *  Intersect a ray with a bot.
 *  If an intersection occurs, a struct seg will be acquired
 *  and filled in.
 *
 *	Notes for rt_bot_norm():
 *		hit_private contains pointer to the tri_specific structure
 *		hit_vpriv[X] contains dot product of ray direction and unit normal from tri_specific
 *  
 *  Returns -
 *  	0	MISS
 *	>0	HIT
 */
int
rt_bot_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
{
	struct bot_specific *bot = (struct bot_specific *)stp->st_specific;

	if( bot->bot_flags & RT_BOT_USE_FLOATS ) {
		return( rt_bot_shot_float( stp, rp, ap, seghead ) );
	} else {
		return( rt_bot_shot_double( stp, rp, ap, seghead ) );
	}
}

/*
 *			R T _ B O T _ P I E C E _ S H O T
 *
 *  Intersect a ray with a list of "pieces" of a BoT.
 *
 *  This routine may be invoked many times for a single ray,
 *  as the ray traverses from one space partitioning cell to the next.
 *
 *  Plate-mode (2 hit) segments will be returned immediately in seghead.
 *
 *  Generally the hits are stashed between invocations in psp.
 */
int
rt_bot_piece_shot(struct rt_piecestate *psp, struct rt_piecelist *plp, double dist_corr, register struct xray *rp, struct application *ap, struct seg *seghead)
{
	struct soltab	*stp;
	struct bot_specific *bot;

	RT_CK_PIECELIST(plp);
	stp = plp->stp;
	RT_CK_SOLTAB(stp);
	bot = (struct bot_specific *)stp->st_specific;

	if( bot->bot_flags & RT_BOT_USE_FLOATS ) {
		return( rt_bot_piece_shot_float( psp, plp, dist_corr, rp, ap, seghead ) );
	} else {
		return( rt_bot_piece_shot_double( psp, plp, dist_corr, rp, ap, seghead ) );
	}
}

/*
 *			R T _ B O T _ P I E C E _ H I T S E G S
 */
void
rt_bot_piece_hitsegs(struct rt_piecestate *psp, struct seg *seghead, struct application *ap)
{
	RT_CK_PIECESTATE(psp);
	RT_CK_AP(ap);
	RT_CK_HTBL(&psp->htab);

	/* Sort hits, Near to Far */
	rt_hitsort( psp->htab.hits, psp->htab.end );

	/* build segments */
	(void)rt_bot_makesegs( psp->htab.hits, psp->htab.end, psp->stp, &ap->a_ray, ap, seghead, psp );
}

#define RT_BOT_SEG_MISS(SEG)	(SEG).seg_stp=RT_SOLTAB_NULL

/*
 *			R T _ B O T _ V S H O T
 *
 *  Vectorized version.
 */
void
rt_bot_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		  	       /* Number of ray/object pairs */
                  	    
{
	rt_vstub( stp, rp, segp, n, ap );
}

/*
 *  			R T _ B O T _ N O R M
 *  
 *  Given ONE ray distance, return the normal and entry/exit point.
 */
void
rt_bot_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
{
	struct bot_specific *bot=(struct bot_specific *)stp->st_specific;

	if( bot->bot_flags & RT_BOT_USE_FLOATS ) {
		rt_bot_norm_float( bot, hitp, stp, rp );
	} else {
		rt_bot_norm_double( bot, hitp, stp, rp );
	}
}

/*
 *			R T _ B O T _ C U R V E
 *
 *  Return the curvature of the bot.
 */
void
rt_bot_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
{
 	cvp->crv_c1 = cvp->crv_c2 = 0;

	/* any tangent direction */
 	bn_vec_ortho( cvp->crv_pdir, hitp->hit_normal );
	cvp->crv_c1 = cvp->crv_c2 = 0;
}

/*
 *  			R T _ B O T _ U V
 *  
 *  For a hit on the surface of an bot, return the (u,v) coordinates
 *  of the hit point, 0 <= u,v <= 1.
 *  u = azimuth
 *  v = elevation
 */
void
rt_bot_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
{
}

/*
 *		R T _ B O T _ F R E E
 */
void
rt_bot_free(register struct soltab *stp)
{
	register struct bot_specific *bot =
		(struct bot_specific *)stp->st_specific;

	if( bot->bot_flags & RT_BOT_USE_FLOATS ) {
		rt_bot_free_float( bot );
	} else {
		rt_bot_free_double( bot );
	}
}

/*
 *			R T _ B O T _ C L A S S
 */
int
rt_bot_class(const struct soltab *stp, const fastf_t *min, const fastf_t *max, const struct bn_tol *tol)
{
	return RT_CLASSIFY_UNIMPLEMENTED;
}

/*
 *			R T _ B O T _ P L O T
 */
int
rt_bot_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
	LOCAL struct rt_bot_internal	*bot_ip;
	int i;

	RT_CK_DB_INTERNAL(ip);
	bot_ip = (struct rt_bot_internal *)ip->idb_ptr;
	RT_BOT_CK_MAGIC(bot_ip);

	for( i=0 ; i<bot_ip->num_faces ; i++ )
	{
		RT_ADD_VLIST( vhead, &bot_ip->vertices[bot_ip->faces[i*3]*3], BN_VLIST_LINE_MOVE );
		RT_ADD_VLIST( vhead, &bot_ip->vertices[bot_ip->faces[i*3+1]*3], BN_VLIST_LINE_DRAW );
		RT_ADD_VLIST( vhead, &bot_ip->vertices[bot_ip->faces[i*3+2]*3], BN_VLIST_LINE_DRAW );
		RT_ADD_VLIST( vhead, &bot_ip->vertices[bot_ip->faces[i*3]*3], BN_VLIST_LINE_DRAW );
	}

	return(0);
}

/*
 *			R T _ B O T _ P L O T _ P O L Y
 */
int
rt_bot_plot_poly(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
	LOCAL struct rt_bot_internal	*bot_ip;
	int i;

	RT_CK_DB_INTERNAL(ip);
	bot_ip = (struct rt_bot_internal *)ip->idb_ptr;
	RT_BOT_CK_MAGIC(bot_ip);

	/* XXX Should consider orientation here, flip if necessary. */
	for( i=0 ; i<bot_ip->num_faces ; i++ )
	{
		point_t aa, bb, cc;
		vect_t  ab, ac;
		vect_t norm;

		VMOVE( aa, &bot_ip->vertices[bot_ip->faces[i*3+0]*3] );
		VMOVE( bb, &bot_ip->vertices[bot_ip->faces[i*3+1]*3] );
		VMOVE( cc, &bot_ip->vertices[bot_ip->faces[i*3+2]*3] );

		VSUB2( ab, aa, bb );
		VSUB2( ac, aa, cc );
		VCROSS( norm, ab, ac );
		VUNITIZE(norm);
		RT_ADD_VLIST(vhead, norm, BN_VLIST_POLY_START);

		if( (bot_ip->bot_flags & RT_BOT_HAS_SURFACE_NORMALS) &&
		    (bot_ip->bot_flags & RT_BOT_USE_NORMALS) ) {
			vect_t na, nb, nc;

			VMOVE( na, &bot_ip->normals[bot_ip->face_normals[i*3+0]*3] );
			VMOVE( nb, &bot_ip->normals[bot_ip->face_normals[i*3+1]*3] );
			VMOVE( nc, &bot_ip->normals[bot_ip->face_normals[i*3+2]*3] );
			RT_ADD_VLIST( vhead, na, BN_VLIST_POLY_VERTNORM );
			RT_ADD_VLIST( vhead, aa, BN_VLIST_POLY_MOVE );
			RT_ADD_VLIST( vhead, nb, BN_VLIST_POLY_VERTNORM );
			RT_ADD_VLIST( vhead, bb, BN_VLIST_POLY_DRAW );
			RT_ADD_VLIST( vhead, nc, BN_VLIST_POLY_VERTNORM );
			RT_ADD_VLIST( vhead, cc, BN_VLIST_POLY_DRAW );
			RT_ADD_VLIST( vhead, aa, BN_VLIST_POLY_END );
		} else {
			RT_ADD_VLIST( vhead, aa, BN_VLIST_POLY_MOVE );
			RT_ADD_VLIST( vhead, bb, BN_VLIST_POLY_DRAW );
			RT_ADD_VLIST( vhead, cc, BN_VLIST_POLY_DRAW );
			RT_ADD_VLIST( vhead, aa, BN_VLIST_POLY_END );
		}
	}

	return(0);
}

/*
 *			R T _ B O T _ T E S S
 *
 *  Returns -
 *	-1	failure
 *	 0	OK.  *r points to nmgregion that holds this tessellation.
 */
int
rt_bot_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
	LOCAL struct rt_bot_internal	*bot_ip;
	struct shell *s;
	struct vertex **verts;
	point_t pt[3];
	int i;

	RT_CK_DB_INTERNAL(ip);
	bot_ip = (struct rt_bot_internal *)ip->idb_ptr;
	RT_BOT_CK_MAGIC(bot_ip);
#if 0
	if( bot_ip->mode == RT_BOT_PLATE || bot_ip->mode == RT_BOT_PLATE_NOCOS )	/* tesselation not supported */
		return( -1 );
#endif
        *r = nmg_mrsv( m );     /* Make region, empty shell, vertex */
        s = BU_LIST_FIRST(shell, &(*r)->s_hd);

	verts = (struct vertex **)bu_calloc( bot_ip->num_vertices, sizeof( struct vertex *),
		"rt_bot_tess: *verts[]" );

	for( i=0 ; i<bot_ip->num_faces ; i++ )
	{
		struct faceuse *fu;
		struct vertex **corners[3];

		if( bot_ip->orientation == RT_BOT_CW )
		{
			VMOVE( pt[2], &bot_ip->vertices[bot_ip->faces[i*3]*3] );
			VMOVE( pt[1], &bot_ip->vertices[bot_ip->faces[i*3+1]*3] );
			VMOVE( pt[0], &bot_ip->vertices[bot_ip->faces[i*3+2]*3] );
			corners[2] = &verts[bot_ip->faces[i*3]];
			corners[1] = &verts[bot_ip->faces[i*3+1]];
			corners[0] = &verts[bot_ip->faces[i*3+2]];
		}
		else
		{
			VMOVE( pt[0], &bot_ip->vertices[bot_ip->faces[i*3]*3] );
			VMOVE( pt[1], &bot_ip->vertices[bot_ip->faces[i*3+1]*3] );
			VMOVE( pt[2], &bot_ip->vertices[bot_ip->faces[i*3+2]*3] );
			corners[0] = &verts[bot_ip->faces[i*3]];
			corners[1] = &verts[bot_ip->faces[i*3+1]];
			corners[2] = &verts[bot_ip->faces[i*3+2]];
		}

		if( !bn_3pts_distinct( pt[0], pt[1], pt[2], tol )
                           || bn_3pts_collinear( pt[0], pt[1], pt[2], tol ) )
				continue;

		if( (fu=nmg_cmface( s, corners, 3 )) == (struct faceuse *)NULL )
		{
			bu_log( "rt_bot_tess() nmg_cmface() failed for face #%d\n", i );
			continue;
		}

		if( !(*corners[0])->vg_p )
			nmg_vertex_gv( *(corners[0]), pt[0] );
		if( !(*corners[1])->vg_p )
			nmg_vertex_gv( *(corners[1]), pt[1] );
		if( !(*corners[2])->vg_p )
			nmg_vertex_gv( *(corners[2]), pt[2] );

		if( nmg_calc_face_g( fu ) )
			nmg_kfu( fu );
		else if( bot_ip->mode == RT_BOT_SURFACE )
		{
			struct vertex **tmp;

			tmp = corners[0];
			corners[0] = corners[2];
			corners[2] = tmp;
			if( (fu=nmg_cmface( s, corners, 3 )) == (struct faceuse *)NULL )
				bu_log( "rt_bot_tess() nmg_cmface() failed for face #%d\n", i );
			else
				 nmg_calc_face_g( fu );
		}
	}

	bu_free( (char *)verts, "rt_bot_tess *verts[]" );

	nmg_mark_edges_real( &s->l.magic );

	nmg_region_a( *r, tol );

	if( bot_ip->mode == RT_BOT_SOLID && bot_ip->orientation == RT_BOT_UNORIENTED )
		nmg_fix_normals( s, tol );

	return( 0 );
}

/*
 *			R T _ B O T _ I M P O R T
 *
 *  Import an BOT from the database format to the internal format.
 *  Apply modeling transformations as well.
 */
int
rt_bot_import(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
{
	LOCAL struct rt_bot_internal	*bot_ip;
	union record			*rp;
	int				i;
	int				chars_used;

	BU_CK_EXTERNAL( ep );
	rp = (union record *)ep->ext_buf;
	/* Check record type */
	if( rp->u_id != DBID_BOT )  {
		bu_log("rt_bot_import: defective record\n");
		return(-1);
	}

	RT_CK_DB_INTERNAL( ip );
	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_BOT;
	ip->idb_meth = &rt_functab[ID_BOT];
	ip->idb_ptr = bu_malloc( sizeof(struct rt_bot_internal), "rt_bot_internal");
	bot_ip = (struct rt_bot_internal *)ip->idb_ptr;
	bot_ip->magic = RT_BOT_INTERNAL_MAGIC;

	bot_ip->num_vertices = bu_glong( rp->bot.bot_num_verts );
	bot_ip->num_faces = bu_glong( rp->bot.bot_num_triangles );
	bot_ip->orientation = rp->bot.bot_orientation;
	bot_ip->mode = rp->bot.bot_mode;
	bot_ip->bot_flags = 0;

	bot_ip->vertices = (fastf_t *)bu_calloc( bot_ip->num_vertices * 3, sizeof( fastf_t ), "Bot vertices" );
	bot_ip->faces = (int *)bu_calloc( bot_ip->num_faces * 3, sizeof( int ), "Bot faces" );

	for( i=0 ; i<bot_ip->num_vertices ; i++ )
	{
		point_t tmp;

		ntohd( (unsigned char *)tmp, (const unsigned char *)(&rp->bot.bot_data[i*24]), 3 );
		MAT4X3PNT( &(bot_ip->vertices[i*3]), mat, tmp );
	}

	chars_used = bot_ip->num_vertices * 3 * 8;

	for( i=0 ; i<bot_ip->num_faces ; i++ )
	{
		int index=chars_used + i * 12;

		bot_ip->faces[i*3] = bu_glong( (const unsigned char *)&rp->bot.bot_data[index] );
		bot_ip->faces[i*3 + 1] = bu_glong( (const unsigned char *)&rp->bot.bot_data[index + 4] );
		bot_ip->faces[i*3 + 2] = bu_glong( (const unsigned char *)&rp->bot.bot_data[index + 8] );
	}

	if( bot_ip->mode == RT_BOT_PLATE || bot_ip->mode == RT_BOT_PLATE_NOCOS )
	{
		chars_used = bot_ip->num_vertices * 3 * 8 + bot_ip->num_faces * 12;

		bot_ip->thickness = (fastf_t *)bu_calloc( bot_ip->num_faces, sizeof( fastf_t ), "BOT thickness" );
		for( i=0 ; i<bot_ip->num_faces ; i++ )
			ntohd( (unsigned char *)&(bot_ip->thickness[i]),
				(const unsigned char *)(&rp->bot.bot_data[chars_used + i*8]), 1 );
		bot_ip->face_mode = bu_hex_to_bitv( (const char *)(&rp->bot.bot_data[chars_used + bot_ip->num_faces * 8]) );
	}
	else
	{
		bot_ip->thickness = (fastf_t *)NULL;
		bot_ip->face_mode = (struct bu_bitv *)NULL;
	}

	return(0);			/* OK */
}

/*
 *			R T _ B O T _ E X P O R T
 *
 *  The name is added by the caller, in the usual place.
 */
int
rt_bot_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
{
	struct rt_bot_internal	*bot_ip;
	union record		*rec;
	int			i;
	int			chars_used;
	int			num_recs;
	struct bu_vls		face_mode;


	RT_CK_DB_INTERNAL(ip);
	if( ip->idb_type != ID_BOT )  return(-1);
	bot_ip = (struct rt_bot_internal *)ip->idb_ptr;
	RT_BOT_CK_MAGIC(bot_ip);

	if( bot_ip->num_normals > 0 ) {
		bu_log( "BOT surface normals not supported in older database formats, normals not saved\n" );
		bu_log( "\tPlease update to current database format using \"dbupgrade\"\n" );
	}

	BU_CK_EXTERNAL(ep);
	ep->ext_nbytes = sizeof( struct bot_rec ) - 1 +
		bot_ip->num_vertices * 3 * 8 + bot_ip->num_faces * 3 * 4;
	if( bot_ip->mode == RT_BOT_PLATE || bot_ip->mode == RT_BOT_PLATE_NOCOS )
	{
	  if( !bot_ip->face_mode )
	    {
	      bot_ip->face_mode = bu_bitv_new( bot_ip->num_faces );
	      bu_bitv_clear( bot_ip->face_mode );
	    }
	  if( !bot_ip->thickness )
	      bot_ip->thickness = (fastf_t *)bu_calloc( bot_ip->num_faces, sizeof( fastf_t ), "BOT thickness" );
	  bu_vls_init( &face_mode );
	  bu_bitv_to_hex( &face_mode, bot_ip->face_mode );
	  ep->ext_nbytes += bot_ip->num_faces * 8 + bu_vls_strlen( &face_mode ) + 1;
	}

	/* round up to the nearest granule */
	if( ep->ext_nbytes % (sizeof( union record ) ) )
	{
		ep->ext_nbytes += (sizeof( union record ) )
			- ep->ext_nbytes % (sizeof( union record ) );
	}
	num_recs = ep->ext_nbytes / sizeof( union record ) - 1;
	ep->ext_buf = (genptr_t)bu_calloc( 1, ep->ext_nbytes, "bot external");
	rec = (union record *)ep->ext_buf;

	rec->bot.bot_id = DBID_BOT;

	bu_plong( (unsigned char *)rec->bot.bot_nrec, num_recs );
	rec->bot.bot_orientation = bot_ip->orientation;
	rec->bot.bot_mode = bot_ip->mode;
	rec->bot.bot_err_mode = 0;
	bu_plong( (unsigned char *)rec->bot.bot_num_verts, bot_ip->num_vertices );
	bu_plong( (unsigned char *)rec->bot.bot_num_triangles, bot_ip->num_faces );

	/* Since libwdb users may want to operate in units other
	 * than mm, we offer the opportunity to scale the solid
	 * (to get it into mm) on the way out.
	 */


	/* convert from local editing units to mm and export
	 * to database record format
	 */
	for( i=0 ; i<bot_ip->num_vertices ; i++ )
	{
		point_t tmp;

		VSCALE( tmp, &bot_ip->vertices[i*3], local2mm );
		htond( (unsigned char *)&rec->bot.bot_data[i*24], (const unsigned char *)tmp, 3 );
	}

	chars_used = bot_ip->num_vertices * 24;

	for( i=0 ; i<bot_ip->num_faces ; i++ )
	{
		int index=chars_used + i * 12;

		bu_plong( (unsigned char *)(&rec->bot.bot_data[index]), bot_ip->faces[i*3] );
		bu_plong( (unsigned char *)(&rec->bot.bot_data[index + 4]), bot_ip->faces[i*3+1] );
		bu_plong( (unsigned char *)(&rec->bot.bot_data[index + 8]), bot_ip->faces[i*3+2] );
	}

	chars_used += bot_ip->num_faces * 12;

	if( bot_ip->mode == RT_BOT_PLATE || bot_ip->mode == RT_BOT_PLATE_NOCOS )
	{
		for( i=0 ; i<bot_ip->num_faces ; i++ )
		{
			fastf_t tmp;
			tmp = bot_ip->thickness[i] * local2mm;
			htond( (unsigned char *)&rec->bot.bot_data[chars_used], (const unsigned char *)&tmp, 1 );
			chars_used += 8;
		}
		strcpy( (char *)&rec->bot.bot_data[chars_used], bu_vls_addr( &face_mode ) );
		bu_vls_free( &face_mode );
	}

	return(0);
}

/*
 *			R T _ B O T _ I M P O R T 5
 */
int
rt_bot_import5(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
{
	struct rt_bot_internal		*bip;
	register unsigned char		*cp;
	int				i;

	BU_CK_EXTERNAL( ep );

	RT_CK_DB_INTERNAL( ip );
	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_BOT;
	ip->idb_meth = &rt_functab[ID_BOT];
	ip->idb_ptr = bu_calloc( 1, sizeof(struct rt_bot_internal), "rt_bot_internal");

	bip = (struct rt_bot_internal *)ip->idb_ptr;
	bip->magic = RT_BOT_INTERNAL_MAGIC;

	cp = ep->ext_buf;
	bip->num_vertices = bu_glong( cp );
	cp += SIZEOF_NETWORK_LONG;
	bip->num_faces = bu_glong( cp );
	cp += SIZEOF_NETWORK_LONG;
	bip->orientation = *cp++;
	bip->mode = *cp++;
	bip->bot_flags = *cp++;

	bip->vertices = (fastf_t *)bu_calloc( bip->num_vertices * 3, sizeof( fastf_t ), "BOT vertices" );
	bip->faces = (int *)bu_calloc( bip->num_faces * 3, sizeof( int ), "BOT faces" );

	for( i=0 ; i<bip->num_vertices ; i++ )
	{
		point_t tmp;

		ntohd( (unsigned char *)tmp, (const unsigned char *)cp, 3 );
		cp += SIZEOF_NETWORK_DOUBLE * 3;
		MAT4X3PNT( &(bip->vertices[i*3]), mat, tmp );
	}

	for( i=0 ; i<bip->num_faces ; i++ )
	{
		bip->faces[i*3] = bu_glong( cp );
		cp += SIZEOF_NETWORK_LONG;
		bip->faces[i*3 + 1] = bu_glong( cp );
		cp += SIZEOF_NETWORK_LONG;
		bip->faces[i*3 + 2] = bu_glong( cp );
		cp += SIZEOF_NETWORK_LONG;
	}

	if( bip->mode == RT_BOT_PLATE || bip->mode == RT_BOT_PLATE_NOCOS )
	{
		bip->thickness = (fastf_t *)bu_calloc( bip->num_faces, sizeof( fastf_t ), "BOT thickness" );
		for( i=0 ; i<bip->num_faces ; i++ )
		{
			ntohd( (unsigned char *)&(bip->thickness[i]), cp, 1 );
			cp += SIZEOF_NETWORK_DOUBLE;
		}
		bip->face_mode = bu_hex_to_bitv( (const char *)cp );
		while( *(cp++) != '\0' );
	}
	else
	{
		bip->thickness = (fastf_t *)NULL;
		bip->face_mode = (struct bu_bitv *)NULL;
	}

	if( bip->bot_flags & RT_BOT_HAS_SURFACE_NORMALS ) {
		vect_t tmp;

		bip->num_normals = bu_glong( cp );
		cp += SIZEOF_NETWORK_LONG;
		bip->num_face_normals = bu_glong( cp );
		cp += SIZEOF_NETWORK_LONG;

		if( bip->num_normals <= 0 ) {
			bip->normals = (fastf_t *)NULL;
		}
		if( bip->num_face_normals <= 0 ) {
			bip->face_normals = (int *)NULL;
		}
		if( bip->num_normals > 0 ) {
			bip->normals = (fastf_t *)bu_calloc( bip->num_normals * 3, sizeof( fastf_t ), "BOT normals" );

			for( i=0 ; i<bip->num_normals ; i++ ) {
				ntohd( (unsigned char *)tmp, (const unsigned char *)cp, 3 );
				cp += SIZEOF_NETWORK_DOUBLE * 3;
				MAT4X3VEC( &(bip->normals[i*3]), mat, tmp );
			}
		}
		if( bip->num_face_normals > 0 ) {
			bip->face_normals = (int *)bu_calloc( bip->num_face_normals * 3, sizeof( int ), "BOT face normals" );

			for( i=0 ; i<bip->num_face_normals ; i++ ) {
				bip->face_normals[i*3] = bu_glong( cp );
				cp += SIZEOF_NETWORK_LONG;
				bip->face_normals[i*3 + 1] = bu_glong( cp );
				cp += SIZEOF_NETWORK_LONG;
				bip->face_normals[i*3 + 2] = bu_glong( cp );
				cp += SIZEOF_NETWORK_LONG;
			}
		}
	} else {
		bip->normals = (fastf_t *)NULL;
		bip->face_normals = (int *)NULL;
		bip->num_normals = 0;
	}

	return(0);			/* OK */
}

/*
 *			R T _ B O T _ E X P O R T 5
 */
int
rt_bot_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
{
	struct rt_bot_internal		*bip;
	struct bu_vls			vls;
	register unsigned char		*cp;
	int				i;

	RT_CK_DB_INTERNAL( ip );

	if( ip->idb_type != ID_BOT ) return -1;
	bip = (struct rt_bot_internal *)ip->idb_ptr;
	RT_BOT_CK_MAGIC( bip );

	BU_CK_EXTERNAL( ep );

	if( bip->mode == RT_BOT_PLATE || bip->mode == RT_BOT_PLATE_NOCOS )
	{
		/* build hex string for face mode */
		bu_vls_init( &vls );
		if( bip->face_mode )
			bu_bitv_to_hex( &vls, bip->face_mode );
	}

	ep->ext_nbytes = 3				/* orientation, mode, bot_flags */
			+ SIZEOF_NETWORK_LONG * (bip->num_faces * 3 + 2) /* faces, num_faces, num_vertices */
			+ SIZEOF_NETWORK_DOUBLE * bip->num_vertices * 3; /* vertices */

	if( bip->mode == RT_BOT_PLATE || bip->mode == RT_BOT_PLATE_NOCOS ) {
		ep->ext_nbytes += SIZEOF_NETWORK_DOUBLE * bip->num_faces /* face thicknesses */
			+ bu_vls_strlen( &vls ) + 1;	/* face modes */
	}

	if( bip->bot_flags & RT_BOT_HAS_SURFACE_NORMALS ) {
		ep->ext_nbytes += SIZEOF_NETWORK_DOUBLE * bip->num_normals * 3 /* vertex normals */
			+ SIZEOF_NETWORK_LONG * (bip->num_face_normals * 3 + 2); /* indices into normals array, num_normals, num_face_normals */
	}

	ep->ext_buf = (genptr_t)bu_malloc( ep->ext_nbytes, "BOT external" );
	
	cp = ep->ext_buf;

	(void)bu_plong( cp, bip->num_vertices );
	cp += SIZEOF_NETWORK_LONG;
	(void)bu_plong( cp, bip->num_faces );
	cp += SIZEOF_NETWORK_LONG;
	*cp++ = bip->orientation;
	*cp++ = bip->mode;
	*cp++ = bip->bot_flags;

	for( i=0 ; i<bip->num_vertices ; i++ )
	{
		point_t tmp;

		VSCALE( tmp, &bip->vertices[i*3], local2mm );
		htond( cp, (unsigned char *)tmp, 3 );
		cp += SIZEOF_NETWORK_DOUBLE * 3;
	}

	for( i=0 ; i<bip->num_faces ; i++ )
	{
		(void)bu_plong( cp, bip->faces[i*3] );
		cp += SIZEOF_NETWORK_LONG;
		(void)bu_plong( cp, bip->faces[i*3 + 1] );
		cp += SIZEOF_NETWORK_LONG;
		(void)bu_plong( cp, bip->faces[i*3 + 2] );
		cp += SIZEOF_NETWORK_LONG;
	}

	if( bip->mode == RT_BOT_PLATE || bip->mode == RT_BOT_PLATE_NOCOS )
	{
		for( i=0 ; i<bip->num_faces ; i++ )
		{
			fastf_t tmp;

			tmp = bip->thickness[i] * local2mm;
			htond( cp, (const unsigned char *)&tmp, 1 );
			cp += SIZEOF_NETWORK_DOUBLE;
		}
		strcpy( (char *)cp, bu_vls_addr( &vls ) );
		cp += bu_vls_strlen( &vls );
		*cp = '\0';
		cp++;
		bu_vls_free( &vls );
	}

	if( bip->bot_flags & RT_BOT_HAS_SURFACE_NORMALS ) {
		(void)bu_plong( cp, bip->num_normals );
		cp += SIZEOF_NETWORK_LONG;
		(void)bu_plong( cp, bip->num_face_normals );
		cp += SIZEOF_NETWORK_LONG;
		if( bip->num_normals > 0 ) {
			htond( cp, (unsigned char*)bip->normals, bip->num_normals*3 );
			cp += SIZEOF_NETWORK_DOUBLE * 3 * bip->num_normals;
		}
		if( bip->num_face_normals > 0 ) {
			for( i=0 ; i<bip->num_face_normals ; i++ ) {
				(void)bu_plong( cp, bip->face_normals[i*3] );
				cp += SIZEOF_NETWORK_LONG;
				(void)bu_plong( cp, bip->face_normals[i*3 + 1] );
				cp += SIZEOF_NETWORK_LONG;
				(void)bu_plong( cp, bip->face_normals[i*3 + 2] );
				cp += SIZEOF_NETWORK_LONG;
			}
		}
	}

	return 0;
}

/*
 *			R T _ B O T _ D E S C R I B E
 *
 *  Make human-readable formatted presentation of this solid.
 *  First line describes type of solid.
 *  Additional lines are indented one tab, and give parameter values.
 */
static char *unoriented="unoriented";
static char *ccw="counter-clockwise";
static char *cw="clockwise";
static char *unknown_orientation="unknown orientation";
static char *surface="\tThis is a surface with no volume\n";
static char *solid="\tThis is a solid object (not just a surface)\n";
static char *plate="\tThis is a FASTGEN plate mode solid\n";
static char *nocos="\tThis is a plate mode solid with no obliquity angle effect\n";
static char *unknown_mode="\tunknown mode\n";
int
rt_bot_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
{
	register struct rt_bot_internal	*bot_ip =
		(struct rt_bot_internal *)ip->idb_ptr;
	char	buf[256];
	char *orientation,*mode;
	int i;

	RT_BOT_CK_MAGIC(bot_ip);
	bu_vls_strcat( str, "Bag of triangles (BOT)\n");

	switch( bot_ip->orientation )
	{
		case RT_BOT_UNORIENTED:
			orientation = unoriented;
			break;
		case RT_BOT_CCW:
			orientation = ccw;
			break;
		case RT_BOT_CW:
			orientation = cw;
			break;
		default:
			orientation = unknown_orientation;
			break;
	}
	switch( bot_ip->mode )
	{
		case RT_BOT_SURFACE:
			mode = surface;
			break;
		case RT_BOT_SOLID:
			mode = solid;
			break;
		case RT_BOT_PLATE:
			mode = plate;
			break;
	        case RT_BOT_PLATE_NOCOS:
		        mode = nocos;
		        break;
		default:
			mode = unknown_mode;
			break;
	}
	sprintf(buf, "\t%d vertices, %d faces (%s)\n",
		bot_ip->num_vertices,
		bot_ip->num_faces,
		orientation );
	bu_vls_strcat( str, buf );
	bu_vls_strcat( str, mode );
	if( (bot_ip->bot_flags & RT_BOT_HAS_SURFACE_NORMALS) && bot_ip->num_normals > 0 ) {
		bu_vls_strcat( str, "\twith surface normals" );
		if( bot_ip->bot_flags & RT_BOT_USE_NORMALS ) {
			bu_vls_strcat( str, " (they will be used)\n" );
		} else {
			bu_vls_strcat( str, " (they will be ignored)\n" );
		}
	}

	if( verbose )
	{
		for( i=0 ; i<bot_ip->num_faces ; i++ )
		{
			int j, k;
			point_t pt[3];

			for( j=0 ; j<3 ; j++ )
				VSCALE( pt[j], &bot_ip->vertices[bot_ip->faces[i*3+j]*3], mm2local );
			if( (bot_ip->bot_flags & RT_BOT_HAS_SURFACE_NORMALS) && bot_ip->num_normals > 0 ) {
				sprintf( buf, "\tface %d: (%g %g %g), (%g %g %g), (%g %g %g) normals: ", i,
					 V3ARGS( pt[0] ),
					 V3ARGS( pt[1] ),
					 V3ARGS( pt[2] ) );
				bu_vls_strcat( str, buf );
				for( k=0 ; k<3 ; k++ ) {
					int index;

					index = i*3 + k;
					if( bot_ip->face_normals[index] < 0 ||  bot_ip->face_normals[index] >= bot_ip->num_normals ) {
						bu_vls_strcat( str, "none " );
					} else {
						sprintf( buf, "(%g %g %g) ", V3ARGS( &bot_ip->normals[bot_ip->face_normals[index]*3]));
						bu_vls_strcat( str, buf );
					}
				}
				bu_vls_strcat( str, "\n" );
			} else {
				sprintf( buf, "\tface %d: (%g %g %g), (%g %g %g), (%g %g %g)\n", i,
					 V3ARGS( pt[0] ),
					 V3ARGS( pt[1] ),
					 V3ARGS( pt[2] ) );
				bu_vls_strcat( str, buf );
			}
			if( bot_ip->mode == RT_BOT_PLATE || bot_ip->mode == RT_BOT_PLATE_NOCOS )
			{
				char *face_mode;

				if( BU_BITTEST( bot_ip->face_mode, i ) )
					face_mode = "appended to hit point";
				else
					face_mode = "centered about hit point";
				sprintf( buf, "\t\tthickness = %g, %s\n", mm2local*bot_ip->thickness[i], face_mode );
				bu_vls_strcat( str, buf );
			}
		}
	}

	return(0);
}

/*
 *			R T _ B O T _ I F R E E
 *
 *  Free the storage associated with the rt_db_internal version of this solid.
 */
void
rt_bot_ifree(struct rt_db_internal *ip)
{
	register struct rt_bot_internal	*bot_ip;

	RT_CK_DB_INTERNAL(ip);
	bot_ip = (struct rt_bot_internal *)ip->idb_ptr;
	RT_BOT_CK_MAGIC(bot_ip);
	bot_ip->magic = 0;			/* sanity */

	bu_free( (char *)bot_ip->vertices, "BOT vertices" );
	bu_free( (char *)bot_ip->faces, "BOT faces" );

	if( bot_ip->mode == RT_BOT_PLATE || bot_ip->mode == RT_BOT_PLATE_NOCOS )
	{
		bu_free( (char *)bot_ip->thickness, "BOT thickness" );
		bu_free( (char *)bot_ip->face_mode, "BOT face_mode" );
	}

	bu_free( (char *)bot_ip, "bot ifree" );
	ip->idb_ptr = GENPTR_NULL;	/* sanity */
}

int
rt_bot_tnurb(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct bn_tol *tol)
{
	return( 1 );
}

int
rt_bot_xform(struct rt_db_internal *op, const fastf_t *mat, struct rt_db_internal *ip, const int free, struct db_i *dbip)
{
	struct rt_bot_internal *botip, *botop;
	register int		i;
	point_t			pt;

	RT_CK_DB_INTERNAL( ip );
	botip = (struct rt_bot_internal *)ip->idb_ptr;
	RT_BOT_CK_MAGIC(botip);

	if( op != ip && !free )
	{
		RT_INIT_DB_INTERNAL(op);
		BU_GETSTRUCT( botop, rt_bot_internal );
		botop->magic = RT_BOT_INTERNAL_MAGIC;
		botop->mode = botip->mode;
		botop->orientation = botip->orientation;
		botop->bot_flags = botip->bot_flags;
		botop->num_vertices = botip->num_vertices;
		botop->num_faces = botip->num_faces;
		if( botop->num_vertices > 0 ) {
			botop->vertices = (fastf_t *)bu_malloc( botip->num_vertices * 3 *
								sizeof( fastf_t ), "botop->vertices" );
		}
		if( botop->num_faces > 0 ) {
			botop->faces = (int *)bu_malloc( botip->num_faces * 3 *
							 sizeof( int ), "botop->faces" );
			memcpy( botop->faces, botip->faces, botop->num_faces * 3 * sizeof( int ) );
		}
		if( botip->thickness )
			botop->thickness = (fastf_t *)bu_malloc( botip->num_faces *
				sizeof( fastf_t ), "botop->thickness" );
		if( botip->face_mode )
			botop->face_mode = bu_bitv_dup( botip->face_mode );
		if( botip->thickness )
		{
			for( i=0 ; i<botip->num_faces ; i++ )
				botop->thickness[i] = botip->thickness[i];
		}

		if( botop->bot_flags & RT_BOT_HAS_SURFACE_NORMALS ) {
			botop->num_normals = botip->num_normals;
			botop->normals = (fastf_t *)bu_calloc( botop->num_normals * 3, sizeof( fastf_t ), "BOT normals" );
			botop->face_normals = (int *)bu_calloc( botop->num_faces * 3, sizeof( int ), "BOT face normals" );
			memcpy( botop->face_normals, botip->face_normals, botop->num_faces * 3 * sizeof( int ) );
		}
		op->idb_ptr = (genptr_t)botop;
		op->idb_major_type = DB5_MAJORTYPE_BRLCAD;
		op->idb_type = ID_BOT;
		op->idb_meth = &rt_functab[ID_BOT];
	}
	else
		botop = botip;

	if( ip != op ) {
		if( ip->idb_avs.magic == BU_AVS_MAGIC ) {
			bu_avs_init( &op->idb_avs, ip->idb_avs.count, "avs" );
			bu_avs_merge( &op->idb_avs, &ip->idb_avs );
		}
	}

	for( i=0 ; i<botip->num_vertices ; i++ )
	{
		MAT4X3PNT( pt, mat, &botip->vertices[i*3] );
		VMOVE( &botop->vertices[i*3], pt );
	}

	for( i=0 ; i<botip->num_normals ; i++ ) {
		MAT4X3VEC( pt, mat, &botip->normals[i*3] );
		VMOVE( &botop->normals[i*3], pt );
	}

	if( free && op != ip ) {
		rt_bot_ifree( ip );
	}

	return( 0 );
}

int
rt_bot_find_v_nearest_pt2(
	const struct rt_bot_internal *bot,
	const point_t	pt2,
	const mat_t	mat)
{
	point_t v;
	int index;
	fastf_t dist=MAX_FASTF;
	int closest=-1;

	RT_BOT_CK_MAGIC( bot );

	for( index=0 ; index < bot->num_vertices ; index++ )
	{
		fastf_t tmp_dist;
		fastf_t tmpx, tmpy;

		MAT4X3PNT( v, mat, &bot->vertices[index*3] )
		tmpx = v[X] - pt2[X];
		tmpy = v[Y] - pt2[Y];
		tmp_dist = tmpx * tmpx + tmpy * tmpy;
		if( tmp_dist < dist )
		{
			dist = tmp_dist;
			closest = index;
		}
	}

	return( closest );
}

int
rt_bot_edge_in_list( const int v1, const int v2, const int edge_list[], const int edge_count )
{
	int i, ev1, ev2;

	for( i=0 ; i<edge_count ; i++ )
	{
		ev1 = edge_list[i*2];
		ev2 = edge_list[i*2 + 1];

		if( ev1 == v1 && ev2 == v2 )
			return( 1 );

		if( ev1 == v2 && ev2 == v1 )
			return( 1 );
	}

	return( 0 );
}

/* This routine finds the edge closest to the 2D point "pt2", and returns the edge as two
 * vertex indices (vert1 and vert2). These vertices are ordered (closest to pt2 is first)
 */
int
rt_bot_find_e_nearest_pt2(
	int *vert1,
	int *vert2,
	const struct rt_bot_internal *bot,
	const point_t	pt2,
	const mat_t	mat)
{
	int i;
	int v1, v2, v3;
	fastf_t dist=MAX_FASTF, tmp_dist;
	int *edge_list;
	int edge_count=0;
	struct bn_tol tol;

	RT_BOT_CK_MAGIC( bot );

	if( bot->num_faces < 1 )
		return( -1 );

	/* first build a list of edges */
	edge_list = (int *)bu_calloc( bot->num_faces * 3 * 2, sizeof( int ), "bot edge list" );

	for( i=0 ; i<bot->num_faces ; i++ )
	{
		v1 = bot->faces[i*3];
		v2 = bot->faces[i*3 + 1];
		v3 = bot->faces[i*3 + 2];

		if( !rt_bot_edge_in_list( v1, v2, edge_list, edge_count ) )
		{
			edge_list[edge_count*2] = v1;
			edge_list[edge_count*2 + 1] = v2;
			edge_count++;
		}
		if( !rt_bot_edge_in_list( v3, v2, edge_list, edge_count ) )
		{
			edge_list[edge_count*2] = v3;
			edge_list[edge_count*2 + 1] = v2;
			edge_count++;
		}
		if( !rt_bot_edge_in_list( v1, v3, edge_list, edge_count ) )
		{
			edge_list[edge_count*2] = v1;
			edge_list[edge_count*2 + 1] = v3;
			edge_count++;
		}
	}

	/* build a tyolerance structure for the bn_dist routine */
	tol.magic = BN_TOL_MAGIC;
	tol.dist = 0.0;
	tol.dist_sq = 0.0;
	tol.perp = 0.0;
	tol.para =  1.0;

	/* now look for the closest edge */
	for( i=0 ; i<edge_count ; i++ )
	{
		point_t p1, p2, pca;
		vect_t p1_to_pca, p1_to_p2;
		int ret;

		MAT4X3PNT( p1, mat, &bot->vertices[ edge_list[i*2]*3] )
		MAT4X3PNT( p2, mat, &bot->vertices[ edge_list[i*2+1]*3] )

		ret = bn_dist_pt2_lseg2( &tmp_dist, pca, p1, p2, pt2, &tol );

		if( ret < 3 || tmp_dist < dist )
		{
			switch( ret )
			{
				case 0:
					dist = 0.0;
					if( tmp_dist < 0.5 )
					{
						*vert1 = edge_list[i*2];
						*vert2 = edge_list[i*2+1];
					}
					else
					{
						*vert1 = edge_list[i*2+1];
						*vert2 = edge_list[i*2];
					}
					break;
				case 1:
					dist = 0.0;
					*vert1 = edge_list[i*2];
					*vert2 = edge_list[i*2+1];
					break;
				case 2:
					dist = 0.0;
					*vert1 = edge_list[i*2+1];
					*vert2 = edge_list[i*2];
					break;
				case 3:
					dist = tmp_dist;
					*vert1 = edge_list[i*2];
					*vert2 = edge_list[i*2+1];
					break;
				case 4:
					dist = tmp_dist;
					*vert1 = edge_list[i*2+1];
					*vert2 = edge_list[i*2];
				case 5:
					dist = tmp_dist;
					V2SUB2( p1_to_pca, pca, p1 );
					V2SUB2( p1_to_p2, p2, p1 );
					if( MAG2SQ( p1_to_pca ) / MAG2SQ( p1_to_p2 ) < 0.25 )
					{
						*vert1 = edge_list[i*2];
						*vert2 = edge_list[i*2+1];
					}
					else
					{
						*vert1 = edge_list[i*2+1];
						*vert2 = edge_list[i*2];
					}
					break;
			}
		}
	}

	bu_free( (char *)edge_list, "bot edge list" );

	return( 0 );
}

static char *modes[]={
	"ERROR: Unrecognized mode",
	"surf",
	"volume",
	"plate",
	"plate_nocos"
};

static char *orientation[]={
	"ERROR: Unrecognized orientation",
	"no",
	"rh",
	"lh"
};

static char *los[]={
	"center",
	"append"
};

/*
 *			R T _ B O T _ T C L G E T
 *
 *  Examples -
 *	db get name fm		get los facemode bit vector
 *	db get name fm#		get los face mode of face # (center, append)
 *	db get name V		get coords for all vertices
 *	db get name V#		get coords for vertex #
 *	db get name F		get vertex indices for all faces
 *	db get name F#		get vertex indices for face #
 *	db get name f		get list of coords for all faces
 *	db get name f#		get list of 3 3tuple coords for face #
 *	db get name T		get thickness for all faces
 *	db get name T#		get thickness for face #
 *	db get name N		get list of normals
 *	db get name N#		get coords for normal #
 *	db get name fn		get list indices into normal vectors for all faces
 *	db get name fn#		get list indices into normal vectors for face #
 *	db get name nv		get num_vertices
 *	db get name nt		get num_faces
 *	db get name nn		get num_normals
 *	db get name nfn		get num_face_normals
 *	db get name mode	get mode (surf, volume, plate, plane_nocos)
 *	db get name orient	get orientation (no, rh, lh)
 *	db get name flags	get BOT flags
 */
int
rt_bot_tclget(Tcl_Interp *interp, const struct rt_db_internal *intern, const char *attr)
{
	register struct rt_bot_internal *bot=(struct rt_bot_internal *)intern->idb_ptr;
	Tcl_DString	ds;
	struct bu_vls	vls;
	int		status;
	int		i;

	RT_BOT_CK_MAGIC( bot );

	Tcl_DStringInit( &ds );
	bu_vls_init( &vls );

	if( attr == (char *)NULL )
	{
		bu_vls_strcpy( &vls, "bot" );
		bu_vls_printf( &vls, " mode %s orient %s",
				modes[bot->mode], orientation[bot->orientation] );
		bu_vls_printf( &vls, " flags {" );
		if( bot->bot_flags & RT_BOT_HAS_SURFACE_NORMALS ) {
			bu_vls_printf( &vls, " has_normals" );
		}
		if( bot->bot_flags & RT_BOT_USE_NORMALS ) {
			bu_vls_printf( &vls, " use_normals" );
		}
		if( bot->bot_flags & RT_BOT_USE_FLOATS ) {
			bu_vls_printf( &vls, " use_floats" );
		}
		bu_vls_printf( &vls, "} V {" );
		for( i=0 ; i<bot->num_vertices ; i++ )
			bu_vls_printf( &vls, " { %.25G %.25G %.25G }",
				V3ARGS( &bot->vertices[i*3] ) );
		bu_vls_strcat( &vls, "} F {" );
		for( i=0 ; i<bot->num_faces ; i++ )
			bu_vls_printf( &vls, " { %d %d %d }",
				V3ARGS( &bot->faces[i*3] ) );
		bu_vls_strcat( &vls, "}" );
		if( bot->mode == RT_BOT_PLATE || bot->mode == RT_BOT_PLATE_NOCOS )
		{
			bu_vls_strcat( &vls, " T {" );
			for( i=0 ; i<bot->num_faces ; i++ )
				bu_vls_printf( &vls, " %.25G", bot->thickness[i] );
			bu_vls_strcat( &vls, "} fm " );
			bu_bitv_to_hex( &vls, bot->face_mode );
		}
		if( bot->bot_flags & RT_BOT_HAS_SURFACE_NORMALS ) {
			bu_vls_printf( &vls, " N {" );
			for( i=0 ; i<bot->num_normals ; i++ ) {
				bu_vls_printf( &vls, " { %.25G %.25G %.25G }", V3ARGS( &bot->normals[i*3] ) );
			}
			bu_vls_printf( &vls, "} fn {" );
			for( i=0 ; i<bot->num_faces ; i++ ) {
				bu_vls_printf( &vls, " { %d %d %d }", V3ARGS( &bot->face_normals[i*3] ) );
			}
			bu_vls_printf( &vls, "}" );
		}
		status = TCL_OK;
	}
	else
	{
		if( attr[0] == 'N' )
		{
			if( attr[1] == '\0' ) {
				if( !(bot->bot_flags & RT_BOT_HAS_SURFACE_NORMALS) || bot->num_normals < 1 ) {
					bu_vls_strcat( &vls, "{}" );
				} else {
					for( i=0 ; i<bot->num_normals ; i++ ) {
						bu_vls_printf( &vls, " { %.25G %.25G %.25G }", V3ARGS( &bot->normals[i*3] ) );
					}
				}
				status = TCL_OK;
			} else {
				i = atoi( &attr[1] );
				if( i < 0 || i >= bot->num_normals ) {
					bu_vls_strcat( &vls, "Specified normal index is out of range" );
					status = TCL_ERROR;
				} else {
					bu_vls_printf( &vls, "%.25G %.25G %.25G", V3ARGS( &bot->normals[i*3] ) );
					status = TCL_OK;
				}
			}
		}
		else if( !strncmp( attr, "fn", 2 ) )
		{
			if( attr[2] == '\0' ) {
				for( i=0 ; i<bot->num_faces ; i++ ) {
					bu_vls_printf( &vls, " { %d %d %d }", V3ARGS( &bot->face_normals[i*3] ) );
				}
				status = TCL_OK;
			} else {
				i = atoi( &attr[2] );
				if( i < 0 || i >= bot->num_faces ) {
					bu_vls_strcat( &vls, "Specified face index is out of range" );
					status = TCL_ERROR;
				} else {
					bu_vls_printf( &vls, "%d %d %d", V3ARGS( &bot->face_normals[i*3] ) );
					status = TCL_OK;
				}
			}
		}
		else if( !strcmp( attr, "nn" ) )
		{
			if( !(bot->bot_flags & RT_BOT_HAS_SURFACE_NORMALS) || bot->num_normals < 1 ) {
				bu_vls_strcat( &vls, "0" );
			} else {
				bu_vls_printf( &vls, "%d", bot->num_normals );
			}
			status = TCL_OK;
		}
		else if( !strcmp( attr, "nfn" ) )
		{
			if( !(bot->bot_flags & RT_BOT_HAS_SURFACE_NORMALS) || bot->num_face_normals < 1 ) {
				bu_vls_strcat( &vls, "0" );
			} else {
				bu_vls_printf( &vls, "%d", bot->num_face_normals );
			}
			status = TCL_OK;
		}
		else if( !strncmp( attr, "fm", 2 ) )
		{
			if( bot->mode != RT_BOT_PLATE && bot->mode != RT_BOT_PLATE_NOCOS )
			{
				bu_vls_strcat( &vls, "Only plate mode BOTs have face_modes" );
				status = TCL_ERROR;
			}
			else
			{
				if( attr[2] == '\0' )
				{
					bu_bitv_to_hex( &vls, bot->face_mode );
					status = TCL_OK;
				}
				else
				{
					i = atoi( &attr[2] );
					if( i < 0 || i >=bot->num_faces )
					{
						bu_vls_printf( &vls, "face number %d out of range (0..%d)", i, bot->num_faces-1 );
						status = TCL_ERROR;
					}
					else
					{
						bu_vls_printf( &vls, "%s",
							los[BU_BITTEST( bot->face_mode, i )?1:0] );
						status = TCL_OK;
					}
				}
			}
		}
		else if( attr[0] == 'V' )
		{
			if( attr[1] != '\0' )
			{
				i = atoi( &attr[1] );
				if( i < 0 || i >=bot->num_vertices )
				{
					bu_vls_printf( &vls, "vertex number %d out of range (0..%d)", i, bot->num_vertices-1 );
					status = TCL_ERROR;
				}
				else
				{
					bu_vls_printf( &vls, "%.25G %.25G %.25G",
						V3ARGS( &bot->vertices[i*3] ) );
					status = TCL_OK;
				}
			}
			else
			{
				for( i=0 ; i<bot->num_vertices ; i++ )
					bu_vls_printf( &vls, " { %.25G %.25G %.25G }",
						V3ARGS( &bot->vertices[i*3] ) );
				status = TCL_OK;
			}
		}
		else if( attr[0] == 'F' )
		{
			/* Retrieve one face, as vertex indices */
			if( attr[1] == '\0' )
			{
				for( i=0 ; i<bot->num_faces ; i++ )
					bu_vls_printf( &vls, " { %d %d %d }",
						V3ARGS( &bot->faces[i*3] ) );
				status = TCL_OK;
			}
			else
			{
				i = atoi( &attr[1] );
				if( i < 0 || i >=bot->num_faces )
				{
					bu_vls_printf( &vls, "face number %d out of range (0..%d)", i, bot->num_faces-1 );
					status = TCL_ERROR;
				}
				else
				{
					bu_vls_printf( &vls, "%d %d %d",
						V3ARGS( &bot->faces[i*3] ) );
					status = TCL_OK;
				}
			}
		}
		else if( !strcmp( attr, "flags" ) )
		{
			bu_vls_printf( &vls, "{" );
			if( bot->bot_flags & RT_BOT_HAS_SURFACE_NORMALS ) {
				bu_vls_printf( &vls, " has_normals" );
			}
			if( bot->bot_flags & RT_BOT_USE_NORMALS ) {
				bu_vls_printf( &vls, " use_normals" );
			}
			if( bot->bot_flags & RT_BOT_USE_FLOATS ) {
				bu_vls_printf( &vls, " use_floats" );
			}
			bu_vls_printf( &vls, "}" );
			status = TCL_OK;
		}
		else if( attr[0] == 'f' )
		{
			int indx;
			/* Retrieve one face, as list of 3 3tuple coordinates */
			if( attr[1] == '\0' )
			{
				for( i=0 ; i<bot->num_faces ; i++ )  {
					indx = bot->faces[i*3];
					bu_vls_printf( &vls, " { %.25G %.25G %.25G }",
						bot->vertices[indx*3],
						bot->vertices[indx*3+1],
						bot->vertices[indx*3+2] );
					indx = bot->faces[i*3+1];
					bu_vls_printf( &vls, " { %.25G %.25G %.25G }",
						bot->vertices[indx*3],
						bot->vertices[indx*3+1],
						bot->vertices[indx*3+2] );
					indx = bot->faces[i*3+2];
					bu_vls_printf( &vls, " { %.25G %.25G %.25G }",
						bot->vertices[indx*3],
						bot->vertices[indx*3+1],
						bot->vertices[indx*3+2] );
				}
				status = TCL_OK;
			}
			else
			{
				i = atoi( &attr[1] );
				if( i < 0 || i >=bot->num_faces )
				{
					bu_vls_printf( &vls, "face number %d out of range (0..%d)", i, bot->num_faces-1 );
					status = TCL_ERROR;
				}
				else
				{
					indx = bot->faces[i*3];
					bu_vls_printf( &vls, " { %.25G %.25G %.25G }",
						bot->vertices[indx*3],
						bot->vertices[indx*3+1],
						bot->vertices[indx*3+2] );
					indx = bot->faces[i*3+1];
					bu_vls_printf( &vls, " { %.25G %.25G %.25G }",
						bot->vertices[indx*3],
						bot->vertices[indx*3+1],
						bot->vertices[indx*3+2] );
					indx = bot->faces[i*3+2];
					bu_vls_printf( &vls, " { %.25G %.25G %.25G }",
						bot->vertices[indx*3],
						bot->vertices[indx*3+1],
						bot->vertices[indx*3+2] );
					status = TCL_OK;
				}
			}
		}
		else if( attr[0] == 'T' )
		{
			if( bot->mode != RT_BOT_PLATE && bot->mode != RT_BOT_PLATE_NOCOS )
			{
				bu_vls_strcat( &vls, "Only plate mode BOTs have thicknesses" );
				status = TCL_ERROR;
			}
			else
			{
				if( attr[1] == '\0' )
				{
					for( i=0 ; i<bot->num_faces ; i++ )
						bu_vls_printf( &vls, " %.25G", bot->thickness[i] );
					status = TCL_OK;
				}
				else
				{
					i = atoi( &attr[1] );
					if( i < 0 || i >=bot->num_faces )
					{
						bu_vls_printf( &vls, "face number %d out of range (0..%d)", i, bot->num_faces-1 );
						status = TCL_ERROR;
					}
					else
					{
						bu_vls_printf( &vls, " %.25G", bot->thickness[i] );
						status = TCL_OK;
					}
				}
			}
		}
		else if( !strcmp( attr, "nv" ) )
		{
			bu_vls_printf( &vls, "%d", bot->num_vertices );
			status = TCL_OK;
		}
		else if( !strcmp( attr, "nt" ) )
		{
			bu_vls_printf( &vls, "%d", bot->num_faces );
			status = TCL_OK;
		}
		else if( !strcmp( attr, "mode" ) )
		{
			bu_vls_printf( &vls, "%s", modes[bot->mode] );
			status = TCL_OK;
		}
		else if( !strcmp( attr, "orient" ) )
		{
			bu_vls_printf( &vls, "%s", orientation[bot->orientation] );
			status = TCL_OK;
		}
		else
		{
			bu_vls_printf( &vls, "BoT has no attribute '%s'", attr );
			status = TCL_ERROR;
		}
	}

	Tcl_DStringAppend( &ds, bu_vls_addr( &vls ), -1 );
	Tcl_DStringResult( interp, &ds );
	Tcl_DStringFree( &ds );
	bu_vls_free( &vls );

	return( status );
}

/*
 *			R T _ B O T _ T C L A D J U S T
 *
 * Examples - 
 *	db adjust name fm		set los facemode bit vector
 *	db adjust name fm#		set los face mode of face # (center, append)
 *	db adjust name V		set coords for all vertices
 *	db adjust name V#		set coords for vertex #
 *	db adjust name F		set vertex indices for all faces
 *	db adjust name F#		set vertex indices for face #
 *	db adjust name T		set thickness for all faces
 *	db adjust name T#		set thickness for face #
 *	db adjust name N		set list of normals
 *	db adjust name N#		set coords for normal #
 *	db adjust name fn		set list indices into normal vectors for all faces
 *	db adjust name fn#		set list indices into normal vectors for face #
 *	db adjust name nn		set num_normals
 *	db adjust name mode		set mode (surf, volume, plate, plane_nocos)
 *	db adjust name orient		set orientation (no, rh, lh)
 *	db adjust name flags		set flags
 */
int
rt_bot_tcladjust(Tcl_Interp *interp, struct rt_db_internal *intern, int argc, char **argv)
{
	struct rt_bot_internal *bot;
	Tcl_Obj *obj, *list, **obj_array;
	int len;
	int i;

	RT_CK_DB_INTERNAL( intern );
	bot = (struct rt_bot_internal *)intern->idb_ptr;
	RT_BOT_CK_MAGIC( bot );

	while( argc >= 2 )
	{
		obj = Tcl_NewStringObj( argv[1], -1 );
		list = Tcl_NewListObj( 0, NULL );
		Tcl_ListObjAppendList( interp, list, obj );

		if( !strncmp( argv[0], "fm", 2 ) )
		{
			if( argv[0][2] == '\0' )
			{
				if( bot->face_mode )
					bu_free( (char *)bot->face_mode, "bot->face_mode" );
				bot->face_mode = bu_hex_to_bitv( argv[1] );
			}
			else
			{
				i = atoi( &(argv[0][2]) );
				if( i < 0 || i >= bot->num_faces )
				{
					Tcl_SetResult( interp, "Face number out of range", TCL_STATIC );
					Tcl_DecrRefCount( list );
					return( TCL_ERROR );
				}

				if( isdigit( *argv[1] ) )
				  {
				    if( atoi( argv[1] ) == 0 )
					BU_BITCLR( bot->face_mode, i );
				    else
					BU_BITSET( bot->face_mode, i );
				  }
				else if( !strcmp( argv[1], "append" ) )
					BU_BITSET( bot->face_mode, i );
				else
				        BU_BITCLR( bot->face_mode, i );
			}
		}
		else if( !strcmp( argv[0], "nn" ) )
		{
			int new_num=0;
			int old_num = bot->num_normals;

			new_num = atoi( Tcl_GetStringFromObj( obj, NULL ) );
			if( new_num < 0 ) {
				Tcl_SetResult( interp, "Number of normals may not be less than 0", TCL_STATIC );
				Tcl_DecrRefCount( list );
				return( TCL_ERROR );
			}

			if( new_num == 0 ) {
				bot->num_normals = 0;
				if( bot->normals ) {
					bu_free( (char *)bot->normals, "BOT normals" );
				}
				bot->normals = (fastf_t *)NULL;
			} else {
				if( new_num != old_num ) {
					bot->num_normals = new_num;
					if( bot->normals ) {
						bot->normals = (fastf_t *)bu_realloc( (char *)bot->normals,
								     bot->num_normals * 3 * sizeof( fastf_t ), "BOT normals" );
					} else {
						bot->normals = (fastf_t *)bu_calloc( bot->num_normals * 3, sizeof( fastf_t ),
										     "BOT normals" );
					}

					if( new_num > old_num ) {
						for( i = old_num ; i<new_num ; i++ ) {
							VSET( &bot->normals[i*3], 0, 0, 0 );
						}
					}
				}
				
			}
			
		}
		else if( !strncmp( argv[0], "fn", 2 ) )
		{
		    char *f_str;

		    if( argv[0][2] == '\0' )
		      {
			(void)Tcl_ListObjGetElements( interp, list, &len, &obj_array );
			if( len != bot->num_faces || len <= 0 ) {
			    Tcl_SetResult( interp, "Must provide normals for all faces!!!", TCL_STATIC );
			    Tcl_DecrRefCount( list );
			    return( TCL_ERROR );
			}
			if( bot->face_normals )
				bu_free( (char *)bot->face_normals, "BOT face_normals" );
			bot->face_normals = (int *)bu_calloc( len*3, sizeof( int ), "BOT face_normals" );
			bot->num_face_normals = len;
			for( i=0 ; i<len ; i++ ) {
				f_str = Tcl_GetStringFromObj( obj_array[i], NULL );
				while( isspace( *f_str ) ) f_str++;

				if( *f_str == '\0' ) {
					Tcl_SetResult( interp, "incomplete list of face_normals", TCL_STATIC );
					Tcl_DecrRefCount( list );
					return( TCL_ERROR );
				}
				bot->face_normals[i*3] = atoi( f_str );
				f_str = bu_next_token( f_str );
				if( *f_str == '\0' ) {
					Tcl_SetResult( interp, "incomplete list of face_normals", TCL_STATIC );
					Tcl_DecrRefCount( list );
					return( TCL_ERROR );
				}
				bot->face_normals[i*3+1] = atoi( f_str );
				f_str = bu_next_token( f_str );
				if( *f_str == '\0' ) {
					Tcl_SetResult( interp, "incomplete list of face_normals", TCL_STATIC );
					Tcl_DecrRefCount( list );
					return( TCL_ERROR );
				}
				bot->face_normals[i*3+2] = atoi( f_str );
			}
			bot->bot_flags |= RT_BOT_HAS_SURFACE_NORMALS;
		      }
		    else
		      {
			i = atoi( &argv[0][2] );
			if( i < 0 || i >= bot->num_faces )
			  {
			    Tcl_SetResult( interp, "face_normal number out of range!!!", TCL_STATIC );
			    Tcl_DecrRefCount( list );
			    return( TCL_ERROR );
			  }
			f_str = Tcl_GetStringFromObj( list, NULL );
		      	while( isspace( *f_str ) ) f_str++;
			bot->face_normals[i*3] = atoi( f_str );
			f_str = bu_next_token( f_str );
			if( *f_str == '\0' )
			  {
			    Tcl_SetResult( interp, "incomplete vertex", TCL_STATIC );
			    Tcl_DecrRefCount( list );
			    return( TCL_ERROR );
			  }
			bot->face_normals[i*3+1] = atoi( f_str );
			f_str = bu_next_token( f_str );
			if( *f_str == '\0' )
			  {
			    Tcl_SetResult( interp, "incomplete vertex", TCL_STATIC );
			    Tcl_DecrRefCount( list );
			    return( TCL_ERROR );
			  }
			bot->face_normals[i*3+2] = atoi( f_str );
		      }
		}
		else if( argv[0][0] == 'N' )
		{
		  char *v_str;

		  if( argv[0][1] == '\0' )
		    {
		      (void)Tcl_ListObjGetElements( interp, list, &len, &obj_array );
		      if( len <= 0 )
			{
			  Tcl_SetResult( interp, "Must provide at least one normal!!!", TCL_STATIC );
			  Tcl_DecrRefCount( list );
			  return( TCL_ERROR );
			}
		      bot->num_normals = len;
		      if( bot->normals )
			      bu_free( (char *)bot->normals, "BOT normals" );
		      bot->normals = (fastf_t *)bu_calloc( len*3, sizeof( fastf_t ), "BOT normals" );
		      for( i=0 ; i<len ; i++ )
			{
			  v_str = Tcl_GetStringFromObj( obj_array[i], NULL );
			  while( isspace( *v_str ) ) v_str++;
			  if( *v_str == '\0' )
			    {
			      Tcl_SetResult( interp, "incomplete list of normals", TCL_STATIC );
			      Tcl_DecrRefCount( list );
			      return( TCL_ERROR );
			    }
			  bot->normals[i*3] = atof( v_str );
			  v_str = bu_next_token( v_str );
			  if( *v_str == '\0' )
			    {
			      Tcl_SetResult( interp, "incomplete list of normals", TCL_STATIC );
			      Tcl_DecrRefCount( list );
			      return( TCL_ERROR );
			    }
			  bot->normals[i*3+1] = atof( v_str );
			  v_str = bu_next_token( v_str );
			  if( *v_str == '\0' )
			    {
			      Tcl_SetResult( interp, "incomplete list of normals", TCL_STATIC );
			      Tcl_DecrRefCount( list );
			      return( TCL_ERROR );
			    }
			  bot->normals[i*3+2] = atof( v_str );
			  Tcl_DecrRefCount( obj_array[i] );
			}
		      bot->bot_flags |= RT_BOT_HAS_SURFACE_NORMALS;
		    } else {
		      i = atoi( &argv[0][1] );
		      if( i < 0 || i >= bot->num_normals )
			{
			  Tcl_SetResult( interp, "normal number out of range!!!", TCL_STATIC );
			  Tcl_DecrRefCount( list );
			  return( TCL_ERROR );
			}
		      v_str = Tcl_GetStringFromObj( list, NULL );
		      while( isspace( *v_str ) ) v_str++;

		      bot->normals[i*3] = atof( v_str );
		      v_str = bu_next_token( v_str );
		      if( *v_str == '\0' )
			{
			  Tcl_SetResult( interp, "incomplete normal", TCL_STATIC );
			  Tcl_DecrRefCount( list );
			  return( TCL_ERROR );
			}
		      bot->normals[i*3+1] = atof( v_str );
		      v_str = bu_next_token( v_str );
		      if( *v_str == '\0' )
			{
			  Tcl_SetResult( interp, "incomplete normal", TCL_STATIC );
			  Tcl_DecrRefCount( list );
			  return( TCL_ERROR );
			}
		      bot->normals[i*3+2] = atof( v_str );
		    }
		}
		else if( argv[0][0] == 'V' )
		{
		  char *v_str;

		  if( argv[0][1] == '\0' )
		    {
		      (void)Tcl_ListObjGetElements( interp, list, &len, &obj_array );
		      if( len <= 0 )
			{
			  Tcl_SetResult( interp, "Must provide at least one vertex!!!", TCL_STATIC );
			  Tcl_DecrRefCount( list );
			  return( TCL_ERROR );
			}
		      bot->num_vertices = len;
		      if( bot->vertices )
			      bu_free( (char *)bot->vertices, "BOT vertices" );
		      bot->vertices = (fastf_t *)bu_calloc( len*3, sizeof( fastf_t ), "BOT vertices" );
		      for( i=0 ; i<len ; i++ )
			{
			  v_str = Tcl_GetStringFromObj( obj_array[i], NULL );
			  while( isspace( *v_str ) ) v_str++;
			  if( *v_str == '\0' )
			    {
			      Tcl_SetResult( interp, "incomplete list of vertices", TCL_STATIC );
			      Tcl_DecrRefCount( list );
			      return( TCL_ERROR );
			    }
			  bot->vertices[i*3] = atof( v_str );
			  v_str = bu_next_token( v_str );
			  if( *v_str == '\0' )
			    {
			      Tcl_SetResult( interp, "incomplete list of vertices", TCL_STATIC );
			      Tcl_DecrRefCount( list );
			      return( TCL_ERROR );
			    }
			  bot->vertices[i*3+1] = atof( v_str );
			  v_str = bu_next_token( v_str );
			  if( *v_str == '\0' )
			    {
			      Tcl_SetResult( interp, "incomplete list of vertices", TCL_STATIC );
			      Tcl_DecrRefCount( list );
			      return( TCL_ERROR );
			    }
			  bot->vertices[i*3+2] = atof( v_str );
			  Tcl_DecrRefCount( obj_array[i] );
			}
		    }
		  else
		    {
		      i = atoi( &argv[0][1] );
		      if( i < 0 || i >= bot->num_vertices )
			{
			  Tcl_SetResult( interp, "vertex number out of range!!!", TCL_STATIC );
			  Tcl_DecrRefCount( list );
			  return( TCL_ERROR );
			}
		      v_str = Tcl_GetStringFromObj( list, NULL );
		      while( isspace( *v_str ) ) v_str++;

		      bot->vertices[i*3] = atof( v_str );
		      v_str = bu_next_token( v_str );
		      if( *v_str == '\0' )
			{
			  Tcl_SetResult( interp, "incomplete vertex", TCL_STATIC );
			  Tcl_DecrRefCount( list );
			  return( TCL_ERROR );
			}
		      bot->vertices[i*3+1] = atof( v_str );
		      v_str = bu_next_token( v_str );
		      if( *v_str == '\0' )
			{
			  Tcl_SetResult( interp, "incomplete vertex", TCL_STATIC );
			  Tcl_DecrRefCount( list );
			  return( TCL_ERROR );
			}
		      bot->vertices[i*3+2] = atof( v_str );
		    }
		}
		else if( argv[0][0] == 'F' )
		  {
		    char *f_str;

		    if( argv[0][1] == '\0' )
		      {
			(void)Tcl_ListObjGetElements( interp, list, &len, &obj_array );
			if( len <= 0 )
			  {
			    Tcl_SetResult( interp, "Must provide at least one face!!!", TCL_STATIC );
			    Tcl_DecrRefCount( list );
			    return( TCL_ERROR );
			  }
			bot->num_faces = len;
			if( bot->faces )
				bu_free( (char *)bot->faces, "BOT faces" );
			bot->faces = (int *)bu_calloc( len*3, sizeof( int ), "BOT faces" );
			if( bot->bot_flags & RT_BOT_HAS_SURFACE_NORMALS ) {
				if( !bot->face_normals ) {
					bot->face_normals = (int *)bu_malloc( bot->num_faces * 3 * sizeof( int ),
									      "bot->face_normals" );
					bot->num_face_normals = bot->num_faces;
					for( i=0 ; i<bot->num_face_normals ; i++ ) {
						VSETALL( &bot->face_normals[i*3], -1 );
					}
				} else if( bot->num_face_normals < bot->num_faces ) {
					bot->face_normals = (int *)bu_realloc( bot->face_normals,
							     bot->num_faces * 3 * sizeof( int ), "bot->face_normals" );
					for( i=bot->num_face_normals ; i<bot->num_faces ; i++ ) {
						VSETALL( &bot->face_normals[i*3], -1 );
					}
					bot->num_face_normals = bot->num_faces;
				}
			}
			for( i=0 ; i<len ; i++ )
			  {
			    f_str = Tcl_GetStringFromObj( obj_array[i], NULL );
			    while( isspace( *f_str ) ) f_str++;

			    if( *f_str == '\0' )
			      {
				Tcl_SetResult( interp, "incomplete list of faces", TCL_STATIC );
				Tcl_DecrRefCount( list );
				return( TCL_ERROR );
			      }
			    bot->faces[i*3] = atoi( f_str );
			    f_str = bu_next_token( f_str );
			    if( *f_str == '\0' )
			      {
				Tcl_SetResult( interp, "incomplete list of faces", TCL_STATIC );
				Tcl_DecrRefCount( list );
				return( TCL_ERROR );
			      }
			    bot->faces[i*3+1] = atoi( f_str );
			    f_str = bu_next_token( f_str );
			    if( *f_str == '\0' )
			      {
				Tcl_SetResult( interp, "incomplete list of faces", TCL_STATIC );
				Tcl_DecrRefCount( list );
				return( TCL_ERROR );
			      }
			    bot->faces[i*3+2] = atoi( f_str );
			  }
		      }
		    else
		      {
			i = atoi( &argv[0][1] );
			if( i < 0 || i >= bot->num_faces )
			  {
			    Tcl_SetResult( interp, "face number out of range!!!", TCL_STATIC );
			    Tcl_DecrRefCount( list );
			    return( TCL_ERROR );
			  }
			f_str = Tcl_GetStringFromObj( list, NULL );
		      	while( isspace( *f_str ) ) f_str++;
			bot->faces[i*3] = atoi( f_str );
			f_str = bu_next_token( f_str );
			if( *f_str == '\0' )
			  {
			    Tcl_SetResult( interp, "incomplete vertex", TCL_STATIC );
			    Tcl_DecrRefCount( list );
			    return( TCL_ERROR );
			  }
			bot->faces[i*3+1] = atoi( f_str );
			f_str = bu_next_token( f_str );
			if( *f_str == '\0' )
			  {
			    Tcl_SetResult( interp, "incomplete vertex", TCL_STATIC );
			    Tcl_DecrRefCount( list );
			    return( TCL_ERROR );
			  }
			bot->faces[i*3+2] = atoi( f_str );
		      }
		  }
		else if( argv[0][0] ==  'T' )
		  {
		    char *t_str;

		    if( argv[0][1] == '\0' )
		      {
			(void)Tcl_ListObjGetElements( interp, list, &len, &obj_array );
			if( len <= 0 )
			  {
			    Tcl_SetResult( interp, "Must provide at least one thickness!!!", TCL_STATIC );
			    Tcl_DecrRefCount( list );
			    return( TCL_ERROR );
			  }
			if( len > bot->num_faces )
			  {
			    Tcl_SetResult( interp, "Too many thicknesses (there are not that many faces)!!!", TCL_STATIC );
			    Tcl_DecrRefCount( list );
			    return( TCL_ERROR );
			  }
			if( !bot->thickness ) {
				bot->thickness = (fastf_t *)bu_calloc( bot->num_faces, sizeof( fastf_t ),
								       "bot->thickness" );
			}
			for( i=0 ; i<len ; i++ )
			  {
			    bot->thickness[i] = atof( Tcl_GetStringFromObj( obj_array[i], NULL ) );
			    Tcl_DecrRefCount( obj_array[i] );
			  }
		      }
		    else
		      {
			i = atoi( &argv[0][1] );
			if( i < 0 || i >= bot->num_faces )
			  {
			    Tcl_SetResult( interp, "face number out of range!!!", TCL_STATIC );
			    Tcl_DecrRefCount( list );
			    return( TCL_ERROR );
			  }
			if( !bot->thickness ) {
				bot->thickness = (fastf_t *)bu_calloc( bot->num_faces, sizeof( fastf_t ),
								       "bot->thickness" );
			}
			t_str = Tcl_GetStringFromObj( list, NULL );
			bot->thickness[i] = atof( t_str );
		      }
		  }
		else if( !strcmp( argv[0], "mode" ) )
		  {
		    char *m_str;

		    m_str = Tcl_GetStringFromObj( list, NULL );
		    if( isdigit( *m_str ) )
		      {
			int mode;

			mode = atoi( m_str );
			if( mode < RT_BOT_SURFACE || mode > RT_BOT_PLATE_NOCOS )
			  {
			    Tcl_SetResult( interp, "unrecognized mode!!!", TCL_STATIC );
			    Tcl_DecrRefCount( list );
			    return( TCL_ERROR );
			  }
			bot->mode = mode;
		      }
		    else
		      {
			if( !strncmp( m_str, modes[RT_BOT_SURFACE], 4 ) )
			  bot->mode = RT_BOT_SURFACE;
			else if( !strcmp( m_str, modes[RT_BOT_SOLID] ) )
			  bot->mode = RT_BOT_SOLID;
			else if( !strcmp( m_str, modes[RT_BOT_PLATE] ) )
			  bot->mode = RT_BOT_PLATE;
			else if( !strcmp( m_str, modes[RT_BOT_PLATE_NOCOS] ) )
			  bot->mode = RT_BOT_PLATE_NOCOS;
			else
			  {
			    Tcl_SetResult( interp, "unrecognized mode!!!", TCL_STATIC );
			    Tcl_DecrRefCount( list );
			    return( TCL_ERROR );
			  }
		      }
		  }
		else if( !strncmp( argv[0], "orient", 6 ) )
		  {
		    char *o_str;

		    o_str = Tcl_GetStringFromObj( list, NULL );
		    if( isdigit( *o_str ) )
		      {
			int orientation;

			orientation = atoi( o_str );
			if( orientation < RT_BOT_UNORIENTED || orientation > RT_BOT_CW )
			  {
			    Tcl_SetResult( interp, "unrecognized orientation!!!", TCL_STATIC );
			    Tcl_DecrRefCount( list );
			    return( TCL_ERROR );
			  }
			bot->orientation = orientation;
		      }
		    else
		      {
			if( !strcmp( o_str, orientation[RT_BOT_UNORIENTED] ) )
			  bot->orientation = RT_BOT_UNORIENTED;
			else if( !strcmp( o_str, orientation[RT_BOT_CCW] ) )
			  bot->orientation = RT_BOT_CCW;
			else if( !strcmp( o_str, orientation[RT_BOT_CW] ) )
			  bot->orientation = RT_BOT_CW;
			else
			  {
			    Tcl_SetResult( interp, "unrecognized orientation!!!", TCL_STATIC );
			    Tcl_DecrRefCount( list );
			    return( TCL_ERROR );
			  }
		      }
		  }
		else if( !strcmp( argv[0], "flags" ) )
		  {
			  (void)Tcl_ListObjGetElements( interp, list, &len, &obj_array );
			  bot->bot_flags = 0;
			  for( i=0 ; i<len ; i++ ) {
				  char *str;

				  str = Tcl_GetStringFromObj( obj_array[i], NULL );
				  if( !strcmp( str, "has_normals" ) ) {
					  bot->bot_flags |= RT_BOT_HAS_SURFACE_NORMALS;
				  } else if( !strcmp( str, "use_normals" ) ) {
					  bot->bot_flags |= RT_BOT_USE_NORMALS;
				  } else if( !strcmp( str, "use_floats" ) ) {
					  bot->bot_flags |= RT_BOT_USE_FLOATS;
				  } else {
					  Tcl_SetResult( interp, "unrecognized flag (must be \"has_normals\", \"use_normals\", or \"use_floats\"!!!", TCL_STATIC );
					  Tcl_DecrRefCount( list );
					  return( TCL_ERROR );
				  }
			  }
		  }

		Tcl_DecrRefCount( list );

		argc -= 2;
		argv += 2;
	}

	if( bot->mode == RT_BOT_PLATE || bot->mode == RT_BOT_PLATE_NOCOS )
	  {
	    if( !bot->thickness )
	      bot->thickness = (fastf_t *)bu_calloc( bot->num_faces, sizeof( fastf_t ), "BOT thickness" );
	    if( !bot->face_mode )
	      {
		bot->face_mode = bu_bitv_new( bot->num_faces );
		bu_bitv_clear( bot->face_mode );
	      }
	  }
	else
	  {
	    if( bot->thickness )
	      {
		bu_free( (char *)bot->thickness, "BOT thickness" );
		bot->thickness = (fastf_t *)NULL;
	      }
	    if( bot->face_mode )
	      {
		bu_free( (char *)bot->face_mode, "BOT facemode" );
		bot->face_mode = (bitv_t)NULL;
	      }
	  }

	return( TCL_OK );
}

int
rt_bot_tclform( const struct rt_functab *ftp, Tcl_Interp *interp)
{
	RT_CK_FUNCTAB(ftp);

	Tcl_AppendResult( interp,
			  "mode {%s} orient {%s} V { {%f %f %f} {%f %f %f} ...} F { {%d %d %d} {%d %d %d} ...} T { %f %f %f ... } fm %s", (char *)NULL );

	return TCL_OK;		  
}

/*************************************************************************
 *
 *  BoT support routines used by MGED, converters, etc.
 *
 *************************************************************************/

/*	This routine adjusts the vertex pointers in each face so that 
 *	pointers to duplicate vertices end up pointing to the same vertex.
 *	The unused vertices are removed.
 *	Returns the number of vertices fused.
 */
int
rt_bot_vertex_fuse( struct rt_bot_internal *bot )
{
	int i,j,k;
	int count=0;

	RT_BOT_CK_MAGIC( bot );

	for( i=0 ; i<bot->num_vertices ; i++ )
	{
		j = i + 1;
		while( j < bot->num_vertices ) {
			/* specifically not using tolerances here */
			if( VEQUAL( &bot->vertices[i*3], &bot->vertices[j*3] ) )
			{
				count++;
				bot->num_vertices--;
				for( k=j ; k<bot->num_vertices ; k++ )
					VMOVE( &bot->vertices[k*3] , &bot->vertices[(k+1)*3] );
				for( k=0 ; k<bot->num_faces*3 ; k++ )
				{
					if( bot->faces[k] == j )
					{
						bot->faces[k] = i;
					}
					else if ( bot->faces[k] > j )
						bot->faces[k]--;
				}
			} else {
				j++;
			}
		}
	}

	return( count );
}

int
rt_bot_same_orientation( const int *a, const int *b )
{
	int i,j;

	for( i=0 ; i<3 ; j++ )
	{
		if( a[0] == b[i] )
		{
			i++;
			if( i == 3 )
				i = 0;
			if( a[1] == b[i] )
				return( 1 );
			else
				return( 0 );
		}
	}

	return( 0 );
}

int
rt_bot_face_fuse( struct rt_bot_internal *bot )
{
	int num_faces;
	int i,j,k,l;
	int count=0;

	RT_BOT_CK_MAGIC( bot );

	num_faces = bot->num_faces;
	for( i=0 ; i<num_faces ; i++ )
	{
		j = i+1;
		while( j<num_faces )
		{
			/* each pass through this loop either increments j or decrements num_faces */
			int match=0;
			int elim;

			for( k=i*3 ; k<(i+1)*3 ; k++ )
			{
				for( l=j*3 ; l<(j+1)*3 ; l++ )
				{
					if( bot->faces[k] == bot->faces[l] )
					{
						match++;
						break;
					}
				}
			}

			if( match != 3 )
			{
				j++;
				continue;
			}

			/* these two faces have the same vertices */
			elim = -1;
			switch( bot->mode )
			{
				case RT_BOT_PLATE:
				case RT_BOT_PLATE_NOCOS:
					/* check the face thickness and face mode */
					if( bot->thickness[i] != bot->thickness[j] ||
					    (BU_BITTEST( bot->face_mode, i )?1:0) != (BU_BITTEST( bot->face_mode, j )?1:0) )
							break;
				case RT_BOT_SOLID:
				case RT_BOT_SURFACE:
					if( bot->orientation == RT_BOT_UNORIENTED )
					{
						/* faces are identical, so eliminate one */
						elim = j;
					}
					else
					{
						/* need to check orientation */
						if( rt_bot_same_orientation( &bot->faces[i*3], &bot->faces[j*3] ) )
							elim = j;
					}
					break;
				default:
					bu_bomb( "bot_face_condense: Unrecognized BOT mode!!!\n" );
					break;
			}

			if( elim < 0 )
			{
				j++;
				continue;
			}

			/* we are eliminating face number "elim" */
			for( l=elim ; l< num_faces-1 ; l++ )
				VMOVE( &bot->faces[l*3], &bot->faces[(l+1)*3] )
			if( bot->mode == RT_BOT_PLATE || bot->mode == RT_BOT_PLATE_NOCOS )
			{
				for( l=elim ; l<num_faces-1 ; l++ )
				{
					bot->thickness[l] = bot->thickness[l+1];
					if( BU_BITTEST( bot->face_mode, l+1 ) )
						BU_BITSET( bot->face_mode, l );
					else
						BU_BITCLR( bot->face_mode, l );
				}
			}
			num_faces--;
		}
	}

	count = bot->num_faces - num_faces;

	if( count )
	{
		bot->num_faces = num_faces;
		bot->faces = (int *)bu_realloc( bot->faces, num_faces*3*sizeof( int ), "BOT faces realloc" );
		if( bot->mode == RT_BOT_PLATE || bot->mode == RT_BOT_PLATE_NOCOS )
		{
			struct bu_bitv *new_mode;

			bot->thickness = bu_realloc( bot->thickness, num_faces*sizeof( fastf_t ), "BOT thickness realloc" );
			new_mode = bu_bitv_new( num_faces );
			bu_bitv_clear( new_mode );
			for( l=0 ; l<num_faces ; l++ )
			{
				if( BU_BITTEST( bot->face_mode, l ) )
					BU_BITSET( new_mode, l );
			}
			bu_free( (char *)bot->face_mode, "BOT face_mode" );
			bot->face_mode = new_mode;
		}
	}

	return( count );
}

/*
 *
 *
 *  Get rid of unused verticies
 */
int
rt_bot_condense( struct rt_bot_internal *bot )
{
	int i,j,k;
	int num_verts;
	int dead_verts=0;
	int *verts;

	RT_BOT_CK_MAGIC( bot );

	num_verts = bot->num_vertices;
	verts = (int *)bu_calloc( num_verts, sizeof( int ), "VERTEX LIST" );

	/* walk the list of verticies, and mark each one if it is used */

	for( i=0 ; i<bot->num_faces*3 ; i++ )
	{
		j = bot->faces[i];
		if( j >= num_verts || j < 0 )
		{
			bu_log( "Illegal vertex number %d, should be 0 through %d\n", j, num_verts-1 );
			bu_bomb( "Illegal vertex number\n" );
		}
		verts[j] = 1;
	}

	/* Walk the list of verticies, eliminate each unused vertex by
	 * copying the rest of the array downwards
	 */
	i = 0;
	while( i < num_verts-dead_verts )
	{
		while( !verts[i] && i < num_verts-dead_verts )
		{
			dead_verts++;
			for( j=i ; j<num_verts-dead_verts ; j++ )
			{
				k = j+1;
				VMOVE( &bot->vertices[j*3], &bot->vertices[k*3] );
				verts[j] = verts[k];
			}
			for( j=0 ; j<bot->num_faces*3 ; j++ )
			{
				if( bot->faces[j] >= i )
					bot->faces[j]--;
			}
		}
		i++;
	}

	if( !dead_verts )
		return( 0 );

	/* Reallocate the vertex array (which should free the space 
	 * we are no longer using)
	 */
	bot->num_vertices -= dead_verts;
	bot->vertices = (fastf_t *)bu_realloc( bot->vertices, bot->num_vertices*3*sizeof( fastf_t ), "bot verts realloc" );

	return( dead_verts );
}

int
find_closest_face( fastf_t **centers, int *piece, int *old_faces, int num_faces, fastf_t *vertices )
{
	pointp_t v0, v1, v2;
	point_t center;
	int i;
	fastf_t one_third = 1.0/3.0;
	fastf_t min_dist;
	int min_face=-1;

	if( (*centers) == NULL ) {
		int count_centers=0;

		/* need to build the centers array */
		(*centers) = (fastf_t *)bu_malloc( num_faces * 3 * sizeof( fastf_t ), "center" );
		for( i=0 ; i<num_faces ; i++ ) {
			if( old_faces[i*3] < 0 ) {
				continue;
			}
			count_centers++;
			v0 = &vertices[old_faces[i*3]*3];
			v1 = &vertices[old_faces[i*3+1]*3];
			v2 = &vertices[old_faces[i*3+2]*3];
			VADD3( center, v0 , v1, v2 );
			VSCALE( &(*centers)[i*3], center, one_third );
		}
	}

	v0 = &vertices[piece[0]*3];
	v1 = &vertices[piece[1]*3];
	v2 = &vertices[piece[2]*3];

	VADD3( center, v0, v1, v2 );
	VSCALE( center, center, one_third );

	min_dist = MAX_FASTF;

	for( i=0 ; i<num_faces ; i++ ) {
		vect_t diff;
		fastf_t dist;

		if( old_faces[i*3] < 0 ) {
			continue;
		}

		VSUB2( diff, center, &(*centers)[i*3] );
		dist = MAGSQ( diff );
		if( dist < min_dist ) {
			min_dist = dist;
			min_face = i;
		}
	}

	return( min_face );
}

void
Add_unique_verts( int *piece_verts, int *v )
{
	int i, j;
	int *ptr=v;

	for( j=0 ; j<3 ; j++ ) {
		i = -1;
		while( piece_verts[++i] > -1 ) {
			if( piece_verts[i] == (*ptr) ) {
				break;
			}
		}
		if( piece_verts[i] == -1 ) { 
			piece_verts[i] = (*ptr);
		}
		ptr++;
	}
}


/*	This routine sorts the faces of the BOT such that when they are taken in groups of "tris_per_piece",
 *	each group (piece) will consist of adjacent faces
 */
int
rt_bot_sort_faces( struct rt_bot_internal *bot, int tris_per_piece )
{
	int *new_faces;		/* the sorted list of faces to be attached to the BOT at the end of this routine */
	int new_face_count=0;	/* the current number of faces in the "new_faces" list */
	int *new_norms = (int*)NULL;		/* the sorted list of vertex normals corrsponding to the "new_faces" list */
	int *old_faces;		/* a copy of the original face list from the BOT */
	int *piece;		/* a small face list, for just the faces in the current piece */
	int *piece_norms = (int*)NULL;	/* vertex normals for faces in the current piece */
	int *piece_verts;	/* a list of vertices in the current piece (each vertex appears only once) */
	unsigned char *vert_count;	/* an array used to hold the number of piece vertices that appear in each BOT face */
	int faces_left;		/* the number of faces in the "old_faces" array that have not yet been used */
	int piece_len;		/* the current number of faces in the piece */
	int max_verts;		/* the maximum number of piece_verts found in a single unused face */
	fastf_t	*centers;	/* triangle centers, used when all else fails */
	int i, j;

	RT_BOT_CK_MAGIC( bot );

	/* allocate memory for all the data */
	new_faces = (int *)bu_calloc( bot->num_faces * 3, sizeof( int ), "new_faces" );
	old_faces = (int *)bu_calloc( bot->num_faces * 3, sizeof( int ), "old_faces" );
	piece = (int *)bu_calloc( tris_per_piece * 3, sizeof( int ), "piece" );
	vert_count = (unsigned char *)bu_malloc( bot->num_faces * sizeof( unsigned char ), "vert_count" );
	piece_verts = (int *)bu_malloc( (tris_per_piece * 3 + 1) * sizeof( int ), "piece_verts" );
	centers = (fastf_t *)NULL;

	if( bot->bot_flags & RT_BOT_HAS_SURFACE_NORMALS ) {
		new_norms = (int *)bu_calloc( bot->num_faces * 3, sizeof( int ), "new_norms" );
		piece_norms = (int *)bu_calloc( tris_per_piece * 3, sizeof( int ), "piece_norms" );
	}

	/* make a copy of the faces list, this list will be modified during the process */
	for( i=0 ; i<bot->num_faces*3 ; i++) {
		old_faces[i] = bot->faces[i];
	}

	/* process until we have sorted all the faces */
	faces_left = bot->num_faces;
	while( faces_left ) {
		int cur_face;
		int done_with_piece;

		/* initialize piece_verts */
		for( i=0 ; i<tris_per_piece*3+1 ; i++ ) {
			piece_verts[i] = -1;
		}

		/* choose first unused face on the list */
		cur_face = 0;
		while( cur_face < bot->num_faces && old_faces[cur_face*3] < 0 ) {
			cur_face++;
		}

		if( cur_face >= bot->num_faces ) {
			/* all faces used, we must be done */
			break;
		}

		/* copy that face to start the piece */
		VMOVE( piece, &old_faces[cur_face*3] );
		if( bot->bot_flags & RT_BOT_HAS_SURFACE_NORMALS ) {
			VMOVE( piece_norms, &bot->face_normals[cur_face*3] );
		}

		/* also copy it to the piece vertex list */
		VMOVE( piece_verts, piece );

		/* mark this face as used */
		VSETALL( &old_faces[cur_face*3], -1 );

		/* update counts */
		piece_len = 1;
		faces_left--;

		if( faces_left == 0 ) {
			/* handle the case where the first face in a piece is the only face left */
			for( j=0 ; j<piece_len ; j++ ) {
				VMOVE( &new_faces[new_face_count*3], &piece[j*3] );
				if( bot->bot_flags & RT_BOT_HAS_SURFACE_NORMALS ) {
					VMOVE( &new_norms[new_face_count*3], &piece_norms[j*3] );
				}
				new_face_count++;
			}
			piece_len = 0;
			max_verts = 0;

			/* set flag to skip the loop below */
			done_with_piece = 1;
		} else {
			done_with_piece = 0;
		}

		while( !done_with_piece ) {
			int max_verts_min;

			/* count the number of times vertices from the current piece appear in the remaining faces */
			(void)memset( vert_count, '\0', bot->num_faces );
			max_verts = 0;
			for( i=0 ; i<bot->num_faces ; i++) {
				int vert_num;
				int v0, v1, v2;

				vert_num = i*3;
				if( old_faces[vert_num] < 0 ) {
					continue;
				}
				v0 = old_faces[vert_num];	
				v1 = old_faces[vert_num+1];
				v2 = old_faces[vert_num+2];

				j = -1;
				while( piece_verts[ ++j ] > -1 ) {
					if( v0 == piece_verts[j] ||
					    v1 == piece_verts[j] ||
					    v2 == piece_verts[j] ) {
						vert_count[i]++;
					}
				}

				if( vert_count[i] > 1 ) {
					/* add this face to the piece */
					VMOVE( &piece[piece_len*3], &old_faces[i*3] );
					if( bot->bot_flags & RT_BOT_HAS_SURFACE_NORMALS ) {
						VMOVE( &piece_norms[piece_len*3], &bot->face_normals[i*3] );
					}

					/* Add its vertices to the list of piece vertices */
					Add_unique_verts( piece_verts, &old_faces[i*3] );

					/* mark this face as used */
					VSETALL( &old_faces[i*3], -1 );

					/* update counts */
					piece_len++;
					faces_left--;
					vert_count[i] = 0;

					/* check if this piece is done */
					if( piece_len == tris_per_piece || faces_left == 0 ) {
						/* copy this piece to the "new_faces" list */
						for( j=0 ; j<piece_len ; j++ ) {
							VMOVE( &new_faces[new_face_count*3], &piece[j*3] );
							if( bot->bot_flags & RT_BOT_HAS_SURFACE_NORMALS ) {
								VMOVE( &new_norms[new_face_count*3], &piece_norms[j*3] );
							}
							new_face_count++;
						}
						piece_len = 0;
						max_verts = 0;
						done_with_piece = 1;
						break;
					}
				}
				if( vert_count[i] > max_verts ) {
					max_verts = vert_count[i];
				}
			}

			/* set this variable to 2, means look for faces with at least common edges */
			max_verts_min = 2;

			if( max_verts == 0 && !done_with_piece ) {
				/* none of the remaining faces has any vertices in common with the current piece */
				int face_to_add;

				/* resort to using triangle centers
				 * find the closest face to the first face in the piece
				 */
				face_to_add = find_closest_face( &centers, piece, old_faces, bot->num_faces, bot->vertices );

				/* Add this face to the current piece */
				VMOVE( &piece[piece_len*3], &old_faces[face_to_add*3] );
				if( bot->bot_flags & RT_BOT_HAS_SURFACE_NORMALS ) {
					VMOVE( &piece_norms[piece_len*3], &bot->face_normals[face_to_add*3] );
				}

				/* Add its vertices to the list of piece vertices */
				Add_unique_verts( piece_verts, &old_faces[face_to_add*3] );

				/* mark this face as used */
				VSETALL( &old_faces[face_to_add*3], -1 );

				/* update counts */
				piece_len++;
				faces_left--;

				/* check if this piece is done */
				if( piece_len == tris_per_piece || faces_left == 0 ) {
					/* copy this piece to the "new_faces" list */
					for( j=0 ; j<piece_len ; j++ ) {
						VMOVE( &new_faces[new_face_count*3], &piece[j*3] );
						if( bot->bot_flags & RT_BOT_HAS_SURFACE_NORMALS ) {
							VMOVE( &new_norms[new_face_count*3], &piece_norms[j*3] );
						}
						new_face_count++;
					}
					piece_len = 0;
					max_verts = 0;
					done_with_piece = 1;
				}
			} else if( max_verts == 1 && !done_with_piece ) {
				/* the best we can find is common vertices */
				max_verts_min = 1;
			} else if( !done_with_piece ) {
				/* there are some common edges, so ignore simple shared vertices */
				max_verts_min = 2;
			}

			/* now add the faces with the highest counts to the current piece
			 * do this in a loop that starts by only accepting the faces with the
			 * most vertices in common with the current piece
			 */
			while( max_verts >= max_verts_min && !done_with_piece ) {
				/* check every face */
				for( i=0 ; i<bot->num_faces ; i++ ) {
					/* if this face has enough vertices in common with the piece,
					 * add it to the piece
					 */
					if( vert_count[i] == max_verts ) {
						VMOVE( &piece[piece_len*3], &old_faces[i*3] );
						if( bot->bot_flags & RT_BOT_HAS_SURFACE_NORMALS ) {
							VMOVE( &piece_norms[piece_len*3], &bot->face_normals[i*3] );
						}
						Add_unique_verts( piece_verts, &old_faces[i*3] );
						VSETALL( &old_faces[i*3], -1 );

						piece_len++;
						faces_left--;

						/* Check if we are done */
						if( piece_len == tris_per_piece || faces_left == 0 ) {
							/* copy this piece to the "new_faces" list */
							for( j=0 ; j<piece_len ; j++ ) {
								VMOVE( &new_faces[new_face_count*3], &piece[j*3] );
								if( bot->bot_flags & RT_BOT_HAS_SURFACE_NORMALS ) {
									VMOVE( &new_norms[new_face_count*3], &piece_norms[j*3] );
								}
								new_face_count++;
							}
							piece_len = 0;
							max_verts = 0;
							done_with_piece = 1;
							break;
						}
					}
				}
				max_verts--;
			}
		}
	}

	bu_free( (char *)old_faces, "old_faces" );
	bu_free( (char *)piece, "piece" );
	bu_free( (char *)vert_count, "vert_count" );
	bu_free( (char *)piece_verts, "piece_verts" );
	if( centers ) {
		bu_free( (char *)centers, "centers" );
	}

	/* do some checking on the "new_faces" */
	if( new_face_count != bot->num_faces ) {
		bu_log( "new_face_count = %d, should be %d\n", new_face_count, bot->num_faces );
		bu_free( (char *)new_faces, "new_faces" );
		return( 1 );
	}

	bu_free( (char *)bot->faces, "bot->faces" );

	bot->faces = new_faces;

	if( bot->bot_flags & RT_BOT_HAS_SURFACE_NORMALS ) {
		bu_free( (char *)piece_norms, "piece_norms" );
		bu_free( (char *)bot->face_normals, "bot->face_normals" );
		bot->face_normals = new_norms;
	}

	return( 0 );
}

struct bot_edge {
  int v;
  int use_count;
  struct bot_edge *next;
};

static void
delete_edge( int v1, int v2, struct bot_edge **edges )
{
	struct bot_edge *edg, *prev=NULL;

	if( v1 < v2 ) {
		edg = edges[v1];
		while( edg ) {
			if( edg->v == v2 ) {
				edg->use_count--;
				if( edg->use_count < 1 ) {
					if( prev ) {
						prev->next = edg->next;
					} else {
						edges[v1] = edg->next;
					}
					edg->v = -1;
					edg->next = NULL;
					bu_free( (char *)edg, "bot_edge" );
					return;
				}
			}
			prev = edg;
			edg = edg->next;
		}
	} else {
		edg = edges[v2];
		while( edg ) {
			if( edg->v == v1 ) {
				edg->use_count--;
				if( edg->use_count < 1 ) {
					if( prev ) {
						prev->next = edg->next;
					} else {
						edges[v2] = edg->next;
					}
					edg->v = -1;
					edg->next = NULL;
					bu_free( (char *)edg, "bot_edge" );
					return;
				}
			}
			prev = edg;
			edg = edg->next;
		}
	}
}

/*
 *			D E C I M A T E _ E D G E
 *
 *	Routine to perform the actual edge decimation step
 *	The edge from v1 to v2 is eliminated by moving v1 to v2.
 *	Faces that used this edge are eliminated.
 *	Faces that used v1 will have that reference changed to v2.
 */

static int
decimate_edge( int v1, int v2, struct bot_edge **edges, int num_edges, int *faces, int num_faces, int face_del1, int face_del2 )
{
	int i;
	struct bot_edge *edg;

	/* first eliminate all the edges of the two deleted faces from the edge list */
	delete_edge( faces[face_del1*3 + 0], faces[face_del1*3 + 1], edges );
	delete_edge( faces[face_del1*3 + 1], faces[face_del1*3 + 2], edges );
	delete_edge( faces[face_del1*3 + 2], faces[face_del1*3 + 0], edges );
	delete_edge( faces[face_del2*3 + 0], faces[face_del2*3 + 1], edges );
	delete_edge( faces[face_del2*3 + 1], faces[face_del2*3 + 2], edges );
	delete_edge( faces[face_del2*3 + 2], faces[face_del2*3 + 0], edges );

	/* do the decimation */
	for( i=0 ; i<3 ; i++ ) {
		faces[face_del1*3 + i] = -1;
		faces[face_del2*3 + i] = -1;
	}
	for( i=0 ; i<num_faces*3 ; i++ ) {
		if( faces[i] == v1 ) {
			faces[i] = v2;
		}
	}

	/* update the edge list */
	/* now move all the remaining edges at edges[v1] to somewhere else */
	edg = edges[v1];
	while( edg ) {
		struct bot_edge *ptr;
		struct bot_edge *next;

		next = edg->next;

		if( edg->v < v2 ) {
			ptr = edges[edg->v];
			while( ptr ) {
				if( ptr->v == v2 ) {
					ptr->use_count++;
					edg->v = -1;
					edg->next = NULL;
					bu_free( (char *)edg, "bot edge" );
					break;
				}
				ptr = ptr->next;
			}
			if( !ptr ) {
				edg->next = edges[edg->v];
				edges[edg->v] = edg;
				edg->v = v2;
			}
		} else {
			ptr = edges[v2];
			while( ptr ) {
				if( ptr->v == edg->v ) {
					ptr->use_count++;
					edg->v = -1;
					edg->next = NULL;
					bu_free( (char *)edg, "bot edge" );
					break;
				}
				ptr = ptr->next;
			}
			if( !ptr ) {
				edg->next = edges[v2];
				edges[v2] = edg;
			}
		}

		edg = next;
	}
	edges[v1] = NULL;

	/* now change all remaining v1 references to v2 */
	for( i=0 ; i<num_edges ; i++ ) {
		struct bot_edge *next, *prev, *ptr;

		prev = NULL;
		edg = edges[i];
		/* look at edges starting from vertex #i */
		while( edg ) {
			next = edg->next;

			if( edg->v == v1 ) {
				/* this one is affected */
				edg->v = v2;	/* change v1 to v2 */
				if( v2 < i ) {
					/* disconnect this edge from list #i */
					if( prev ) {
						prev->next = next;
					} else {
						edges[i] = next;
					}

					/* this edge must move to the "v2" list */
					ptr = edges[v2];
					while( ptr ) {
						if( ptr->v == i ) {
							/* found another occurence of this edge
							 * increment use count
							 */
							ptr->use_count++;

							/* delete the original */
							edg->v = -1;
							edg->next = NULL;
							bu_free( (char *)edg, "bot edge" );
							break;
						}
						ptr = ptr->next;
					}
					if( !ptr ) {
						/* did not find another occurence, add to list */
						edg->next = edges[v2];
						edges[v2] = edg;
					}
					edg = next;
				} else {
					/* look for other occurences of this edge in this list
					 * if found, just increment use count
					 */
					ptr = edges[i];
					while( ptr ) {
						if( ptr->v == v2 && ptr != edg ) {
							/* found another occurence */
							/* increment use count */
							ptr->use_count++;

							/* disconnect original from list */
							if( prev ) {
								prev->next = next;
							} else {
								edges[i] = next;
							}

							/* free it */
							edg->v = -1;
							edg->next = NULL;
							bu_free( (char *)edg, "bot edge" );

							break;
						}
						ptr = ptr->next;
					}
					if( !ptr ) {
						prev = edg;
					}
					edg = next;
				}
			} else {
				/* unaffected edge, just continue */
				edg = next;
			}
		}
	}

	return 2;
}

/*
 *				E D G E _ C A N _ B E _ D E C I M A T E D
 *
 *	Routine to determine if the specified edge can be eliminated within the given constraints
 *		"faces" is the current working version of the BOT face list.
 *		"v1" and "v2" are the indices into the BOT vertex list, they define the edge.
 *		"max_chord_error" is the maximum distance allowed between the old surface and new.
 *		"max_normal_error" is actually the minimum dot product allowed between old and new
 *			surface normals (cosine).
 *		"min_edge_length_sq" is the square of the minimum allowed edge length.
 *		any constraint value of -1 means ignore this constraint
 *	returns 1 if edge can be eliminated without breaking conatraints, 0 otherwise
 */

/* for simplicity, only consider vertices that are shared with less than MAX_AFFECTED_FACES */
#define MAX_AFFECTED_FACES	128

static int
edge_can_be_decimated( struct rt_bot_internal *bot,
		       int *faces,
		       struct bot_edge **edges,
		       int v1,
		       int v2,
		       int *face_del1,
		       int *face_del2,
		       fastf_t max_chord_error,
		       fastf_t max_normal_error,
		       fastf_t min_edge_length_sq )
{
	int i, j, k;
	int num_faces=bot->num_faces;
	int num_edges=bot->num_vertices;
	int count, v1_count;
	int affected_count=0;
	vect_t v01, v02, v12;
	fastf_t *vertices=bot->vertices;
	int faces_affected[MAX_AFFECTED_FACES];

	if( v1 < 0 || v2 < 0 ) {
		return 0;
	}

	/* find faces to be deleted or affected */
	*face_del1 = -1;
	*face_del2 = -1;
	for( i=0 ; i<num_faces*3 ; i += 3 ) {
		count = 0;
		v1_count = 0;
		for( j=0 ; j<3 ; j++ ) {
			k = i + j;
			if( faces[k] == v1 ) {
				/* found a reference to v1, count it */
				count++;
				v1_count++;
			} else if( faces[k] == v2 ) {
				/* found a reference to v2, count it */
				count++;
			}
		}
		if( count > 1 ) {
			/* this face will get deleted */
			if( *face_del1 > -1 ) {
				*face_del2 = i/3;
			} else {
				*face_del1 = i/3;
			}
		} else if( v1_count ) {
			/* this face will be affected */
			faces_affected[affected_count] = i;
			affected_count++;
			if( affected_count >= MAX_AFFECTED_FACES ) {
				return 0;
			}
		}
	}

	/* if only one face will be deleted, do not decimate
	 * this may be a free edge
	 */
	if( *face_del2 < 0 ) {
	  return 0;
	}

	/* another  easy test to avoid moving free edges */
	if( affected_count < 1 ) {
		return 0;
	}

	/* for BOTs that are expected to have free edges, do a rigorous check for free edges */
	if( bot->mode == RT_BOT_PLATE || bot->mode == RT_BOT_SURFACE ) {
		struct bot_edge *edg;

		/* check if vertex v1 is on a free edge */
		for( i=0 ; i<num_edges ; i++ ) {
			edg = edges[i];
			while( edg ) {
				if( (i == v1 || edg->v == v1) && edg->use_count < 2 ) {
					return 0;
				}
				edg = edg->next;
			}
		}
	}

	/* calculate edge vector */
	VSUB2( v12, &vertices[v1*3], &vertices[v2*3] );

	if( min_edge_length_sq > SMALL_FASTF ) {
		if( MAGSQ( v12 ) > min_edge_length_sq ) {
			return 0;
		}
	}

	if( max_chord_error > -1.0 || max_normal_error > -1.0 ) {
		/* check if surface is within max_chord_error of vertex to be eliminated */
		/* loop through all affected faces */
		for( i=0 ; i<affected_count ; i++ ) {
			fastf_t dist;
			fastf_t dot;
			plane_t pla, plb;
			int va, vb, vc;

			/* calculate plane of this face before and after adjustment
			 *  if the normal changes too much, do not decimate
			 */

			/* first calculate original face normal (use original BOT face list) */
			va = bot->faces[faces_affected[i]];
			vb = bot->faces[faces_affected[i]+1];
			vc = bot->faces[faces_affected[i]+2];
			VSUB2( v01, &vertices[vb*3], &vertices[va*3] );
			VSUB2( v02, &vertices[vc*3], &vertices[va*3] );
			VCROSS( plb, v01, v02 );
			VUNITIZE( plb );
			plb[3] = VDOT( &vertices[va*3], plb );

			/* do the same using the working face list */
			va = faces[faces_affected[i]];
			vb = faces[faces_affected[i]+1];
			vc = faces[faces_affected[i]+2];
			/* make the proposed decimation changes */
			if( va == v1 ) {
				va = v2;
			} else if( vb == v1 ) {
				vb = v2;
			} else if( vc == v1 ) {
				vc = v2;
			}
			VSUB2( v01, &vertices[vb*3], &vertices[va*3] );
			VSUB2( v02, &vertices[vc*3], &vertices[va*3] );
			VCROSS( pla, v01, v02 );
			VUNITIZE( pla );
			pla[3] = VDOT( &vertices[va*3], pla );

			/* max_normal_error is actually a minimum dot product */
			dot = VDOT( pla, plb );
			if( max_normal_error > -1.0 && dot < max_normal_error ) {
				return 0;
			}

			/* check the distance between this new plane and vertex v1 */
			dist = fabs( DIST_PT_PLANE( &vertices[v1*3], pla ) );
			if( max_chord_error > -1.0 && dist > max_chord_error ) {
				return 0;
			}
		}
	}

	return 1;
}


/*
 *				R T _ B O T _ D E C I M A T E
 *
 *	routine to reduce the number of triangles in a BOT by edges decimation
 *		max_chord_error is the maximum error distance allowed
 *		max_normal_error is the maximum change in surface normal allowed
 *
 *	This and associated routines maintain a list of edges and their "use counts"
 *	A "free edge" is one with a use count of 1, most edges have a use count of 2
 *	When a use count reaches zero, the edge is removed from the list.
 *	The list is used to direct the edge decimation process and to avoid deforming the shape
 *	of a non-volume enclosing BOT by keeping track of use counts (and thereby free edges)
 *	If a free edge would be moved, that deciamtion is not performed.
 */
int
rt_bot_decimate( struct rt_bot_internal *bot,	/* BOT to be decimated */
		 fastf_t max_chord_error,	/* maximum allowable chord error (mm) */
		 fastf_t max_normal_error,	/* maximum allowable normal error (degrees) */
		 fastf_t min_edge_length )	/* minimum allowed edge length */
{
	int *faces;
	struct bot_edge **edges;
	fastf_t min_edge_length_sq;
	int edges_deleted=0;
	int edge_count=0;
	int face_count;
	int actual_count;
	int deleted;
	int v1, v2;
	int i, j;
	int done;

	RT_BOT_CK_MAGIC( bot );

#if 0
	if( max_chord_error <= SMALL_FASTF &&
	    max_normal_error <= SMALL_FASTF &&
	    min_edge_length <= SMALL_FASTF )
		return 0;
#endif
	/* convert normal error to something useful (a minimum dot product) */
	if( max_normal_error > -1.0 ) {
		max_normal_error = cos( max_normal_error * M_PI / 180.0 );
	}

	if( min_edge_length > SMALL_FASTF ) {
		min_edge_length_sq = min_edge_length * min_edge_length;
	} else {
		min_edge_length_sq = min_edge_length;
	}

	/* make a working copy of the face list */
	faces = (int *)bu_malloc( sizeof( int ) * bot->num_faces * 3, "faces" );
	for( i=0 ; i<bot->num_faces*3 ; i++ ) {
		faces[i] = bot->faces[i];
	}
	face_count = bot->num_faces;

	/* make a list of edges in the BOT
	 * each edge will be in the list for its lower numbered vertex index
	 */
	edges = (struct bot_edge **)bu_calloc( bot->num_vertices,
				     sizeof( struct bot_edge *), "edges" );

	/* loop through all the faces building the edge lists */
	for( i=0 ; i<bot->num_faces*3 ; i += 3 ) {
	  for( j=0 ; j<3 ; j++ ) {
	    struct bot_edge *ptr;
	    int k;

	    k = j + 1;
	    if( k > 2 ) {
	      k = 0;
	    }
	    /* v1 is starting vertex index for this edge
	     * v2 is the ending vertex index
	     */
	    v1 = faces[i+j];
	    v2 = faces[i+k];

	    /* make sure the lower index is v1 */
	    if( v2 < v1 ) {
	      int tmp;

	      tmp = v1;
	      v1 = v2;
	      v2 = tmp;
	    }

	    /* store this edge in the appropiate list */
	    ptr = edges[v1];
	    if( !ptr ) {
	      ptr = bu_calloc( 1, sizeof( struct bot_edge ), "edges[v1]" );
	      edges[v1] = ptr;
	    } else {
	      while( ptr->next && ptr->v != v2 ) ptr = ptr->next;
	      if( ptr->v == v2 ) {
		ptr->use_count++;
		continue;
	      }
	      ptr->next = bu_calloc( 1, sizeof( struct bot_edge ), "ptr->next" );
	      ptr = ptr->next;
	    }
	    edge_count++;
	    ptr->v = v2;
	    ptr->use_count++;
	    ptr->next = NULL;
	  }
	}

	/* the decimation loop */
	done = 0;
	while( !done ) {
		done = 1;

		/* visit each edge */
		for( i=0 ; i<bot->num_vertices ; i++ ) {
			struct bot_edge *ptr;
			int face_del1, face_del2;

			ptr = edges[i];
			while( ptr ) {

				/* try to avoid making 2D objects */
				if( face_count < 5 )
					break;

				/* check if this edge can be eliminated (try both directions) */
				if( edge_can_be_decimated( bot, faces, edges, i, ptr->v,
							   &face_del1, &face_del2,
							   max_chord_error,
							   max_normal_error,
							   min_edge_length_sq )) {
					face_count -= decimate_edge( i, ptr->v, edges, bot->num_vertices,
								     faces, bot->num_faces,
								     face_del1, face_del2 );
					edges_deleted++;
					done = 0;
					break;
				} else if( edge_can_be_decimated( bot, faces, edges, ptr->v, i,
								  &face_del1, &face_del2,
								  max_chord_error,
								  max_normal_error,
								  min_edge_length_sq )) {
					face_count -= decimate_edge( ptr->v, i, edges, bot->num_vertices,
								     faces, bot->num_faces,
								     face_del1, face_del2 );
					edges_deleted++;
					done = 0;
					break;
				} else {
					ptr = ptr->next;
				}
			}
		}
	}

	/* free some memory */
	for( i=0 ; i<bot->num_vertices ; i++ ) {
	  struct bot_edge *ptr, *ptr2;

	  ptr = edges[i];
	  while( ptr ) {
	    ptr2 = ptr;
	    ptr = ptr->next;
	    bu_free( (char *)ptr2, "ptr->edges" );
	  }
	}
	bu_free( (char *)edges, "edges" );

	/* condense the face list */
	actual_count = 0;
	deleted = 0;
	for( i=0 ; i<bot->num_faces*3 ; i++ ) {
		if( faces[i] < 0 ) {
			deleted++;
			continue;
		}
		if( deleted ) {
			faces[i-deleted] = faces[i];
		}
		actual_count++;
	}

	if( actual_count % 3 ) {
		bu_log( "rt_bot_decimate: face vertices count is not a multilple of 3!!\n" );
		bu_free( ( char *)faces, "faces" );
		return -1;
	}

	bu_log( "original face count = %d, edge count = %d\n",
		bot->num_faces, edge_count );
	bu_log( "\tedges deleted = %d\n", edges_deleted );
	bu_log( "\tnew face_count = %d\n", face_count );

	actual_count /= 3;

	if( face_count != actual_count ) {
		bu_log( "rt_bot_decimate: Face count is confused!!\n" );
		bu_free( ( char *)faces, "faces" );
		return -2;
	}

	bu_free( (char *)bot->faces, "bot->faces" );
	bot->faces = (int *)bu_realloc( faces, sizeof( int ) * face_count * 3, "bot->faces" );
	bot->num_faces = face_count;

	/* removed unused vertices */
	(void)rt_bot_condense( bot );

	return edges_deleted;
}

static int
smooth_bot_miss( struct application *ap )
{
	return 0;
}

static int
smooth_bot_hit( struct application *ap, struct partition *PartHeadp, struct seg *seg )
{
	struct partition *pp;
	struct soltab *stp;
	vect_t inormal, onormal;
	vect_t *normals=(vect_t *)ap->a_uptr;

	for( pp=PartHeadp->pt_forw ; pp != PartHeadp; pp = pp->pt_forw )  {
		stp = pp->pt_inseg->seg_stp;
		RT_HIT_NORMAL( inormal, pp->pt_inhit, stp, &(ap->a_ray), pp->pt_inflip );

		stp = pp->pt_outseg->seg_stp;
		RT_HIT_NORMAL( onormal, pp->pt_outhit, stp, &(ap->a_ray), pp->pt_outflip );
		if( pp->pt_inhit->hit_surfno == ap->a_user ) {
			VMOVE( normals[pp->pt_inhit->hit_surfno], inormal );
			break;
		}
		if( pp->pt_outhit->hit_surfno == ap->a_user ) {
			VMOVE( normals[pp->pt_outhit->hit_surfno], onormal );
			break;
		}
	}

	return 1;
}

int
rt_smooth_bot( struct rt_bot_internal *bot, char *bot_name, struct db_i *dbip, fastf_t norm_tol_angle )
{
	int vert_no;
	int i,j,k;
	struct rt_i *rtip;
	struct application ap;
	fastf_t normal_dot_tol=0.0;
	vect_t *normals;

	RT_BOT_CK_MAGIC( bot );

	if( norm_tol_angle < 0.0 || norm_tol_angle > M_PI ) {
		bu_log( "normal tolerance angle must be from 0 to Pi\n" );
		return( -2 );
	}

	if( (bot->orientation == RT_BOT_UNORIENTED) && (bot->mode != RT_BOT_SOLID) ) {
		bu_log( "Cannot smooth unoriented BOT primitives unless they are solid objects\n" );
		return( -3 );
	}

	normal_dot_tol = cos( norm_tol_angle );

	if( bot->normals ) {
		bu_free( (char *)bot->normals, "bot->normals" );
		bot->normals = NULL;
	}

	if( bot->face_normals ) {
		bu_free( (char *)bot->face_normals, "bot->face_normals" );
		bot->face_normals = NULL;
	}

	bot->bot_flags &= !(RT_BOT_HAS_SURFACE_NORMALS | RT_BOT_USE_NORMALS);
	bot->num_normals = 0;
	bot->num_face_normals = 0;

	/* build an array of surface normals */
	normals = (vect_t *)bu_calloc( bot->num_faces , sizeof( vect_t ), "normals" );

	if( bot->orientation == RT_BOT_UNORIENTED ) {
		/* need to do raytracing, do prepping */
		bzero( &ap, sizeof( struct application ) );
		rtip = rt_new_rti( dbip );
		ap.a_rt_i = rtip;
		ap.a_hit = smooth_bot_hit;
		ap.a_miss = smooth_bot_miss;
		ap.a_uptr = (genptr_t)normals;
		if( rt_gettree( rtip, bot_name ) ) {
			bu_log( "rt_gettree failed for %s\n", bot_name );
			return( -1 );
		}
		rt_prep( rtip );

		/* find the surface normal for each face */
		for( i=0 ; i<bot->num_faces ; i++ ) {
			vect_t a, b;
			vect_t inv_dir;

			VSUB2( a, &bot->vertices[bot->faces[i*3+1]*3], &bot->vertices[bot->faces[i*3]*3] );
			VSUB2( b, &bot->vertices[bot->faces[i*3+2]*3], &bot->vertices[bot->faces[i*3]*3] );
			VCROSS( ap.a_ray.r_dir, a, b );
			VUNITIZE( ap.a_ray.r_dir );

			/* calculate ray start point */
			VADD3( ap.a_ray.r_pt, &bot->vertices[bot->faces[i*3]*3],
			       &bot->vertices[bot->faces[i*3+1]*3],
			       &bot->vertices[bot->faces[i*3+2]*3] );
			VSCALE( ap.a_ray.r_pt, ap.a_ray.r_pt, 0.333333333333 );

			/* back out to bounding box limits */

			/* Compute the inverse of the direction cosines */
			if( ap.a_ray.r_dir[X] < -SQRT_SMALL_FASTF )  {
				inv_dir[X]=1.0/ap.a_ray.r_dir[X];
			} else if( ap.a_ray.r_dir[X] > SQRT_SMALL_FASTF )  {
				inv_dir[X]=1.0/ap.a_ray.r_dir[X];
			} else {
				ap.a_ray.r_dir[X] = 0.0;
				inv_dir[X] = INFINITY;
			}
			if( ap.a_ray.r_dir[Y] < -SQRT_SMALL_FASTF )  {
				inv_dir[Y]=1.0/ap.a_ray.r_dir[Y];
			} else if( ap.a_ray.r_dir[Y] > SQRT_SMALL_FASTF )  {
				inv_dir[Y]=1.0/ap.a_ray.r_dir[Y];
			} else {
				ap.a_ray.r_dir[Y] = 0.0;
				inv_dir[Y] = INFINITY;
			}
			if( ap.a_ray.r_dir[Z] < -SQRT_SMALL_FASTF )  {
				inv_dir[Z]=1.0/ap.a_ray.r_dir[Z];
			} else if( ap.a_ray.r_dir[Z] > SQRT_SMALL_FASTF )  {
				inv_dir[Z]=1.0/ap.a_ray.r_dir[Z];
			} else {
				ap.a_ray.r_dir[Z] = 0.0;
				inv_dir[Z] = INFINITY;
			}

			if( !rt_in_rpp( &ap.a_ray, inv_dir, rtip->mdl_min, rtip->mdl_max ) ) {
				/* ray missed!!! */
				bu_log( "ERROR: Ray missed target!!!!\n" );
			}
			VJOIN1( ap.a_ray.r_pt, ap.a_ray.r_pt, ap.a_ray.r_min, ap.a_ray.r_dir );
			ap.a_user = i;
			(void) rt_shootray( &ap );
		}
		rt_free_rti( rtip );
	} else {
		/* calculate normals */
		for( i=0 ; i<bot->num_faces ; i++ ) {
			vect_t a, b;

			VSUB2( a, &bot->vertices[bot->faces[i*3+1]*3], &bot->vertices[bot->faces[i*3]*3] );
			VSUB2( b, &bot->vertices[bot->faces[i*3+2]*3], &bot->vertices[bot->faces[i*3]*3] );
			VCROSS( normals[i], a, b );
			VUNITIZE( normals[i] );
			if( bot->orientation == RT_BOT_CW ) {
				VREVERSE( normals[i], normals[i] );
			}
		}
	}

	bot->num_normals = bot->num_faces * 3;
	bot->num_face_normals = bot->num_faces;

	bot->normals = (fastf_t *)bu_calloc( bot->num_normals * 3, sizeof( fastf_t ), "bot->normals" );
	bot->face_normals = (int *)bu_calloc( bot->num_face_normals * 3, sizeof( int ), "bot->face_normals" );

	/* process each face */
	for( i=0 ; i<bot->num_faces ; i++ ) {
		vect_t def_norm; /* default normal for this face */

		VMOVE( def_norm, normals[i] );

		/* process each vertex in his face */
		for( k=0 ; k<3 ; k++ ) {
			vect_t ave_norm;

			/* the actual vertex index */
			vert_no = bot->faces[i*3+k];
			VSETALL( ave_norm, 0.0 );

			/* find all the faces that use this vertex */
			   for( j=0 ; j<bot->num_faces*3 ; j++ ) {
				   if( bot->faces[j] == vert_no ) {
					   int the_face;

					   the_face = j / 3;

					   /* add all the normals that are within tolerance
					    * this also gets def_norm
					    */
					   if( VDOT( normals[the_face], def_norm ) >= normal_dot_tol ) {
						   VADD2( ave_norm, ave_norm, normals[the_face] );
					   }
				   }
			   }
			   VUNITIZE( ave_norm );
			   VMOVE( &bot->normals[(i*3+k)*3], ave_norm );
			   bot->face_normals[i*3+k] = i*3+k;
		}
	}

	bu_free( (char *)normals, "normals" );

	bot->bot_flags |= RT_BOT_HAS_SURFACE_NORMALS;
	bot->bot_flags |= RT_BOT_USE_NORMALS;

	return( 0 );
}
@


1.125
log
@change conf.h to a wrapped config.h
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /cvs/brlcad/librt/g_bot.c,v 1.124 2004/04/05 08:48:56 morrison Exp $ (BRL)";
@


1.124
log
@merge of ansi-6-0-branch into HEAD
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header$ (BRL)";
d21 5
a25 1
#include "conf.h"
@


1.123
log
@update copyright to include span through 2003
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.122 2003/11/19 21:45:04 jra Exp $ (BRL)";
d196 1
a196 4
rt_bot_prep( stp, ip, rtip )
struct soltab		*stp;
struct rt_db_internal	*ip;
struct rt_i		*rtip;
d216 1
a216 2
rt_bot_print( stp )
register const struct soltab *stp;
d261 1
a261 8
rt_bot_makesegs( hits, nhits, stp, rp, ap, seghead, psp )
struct hit		*hits;
int			nhits;
struct soltab		*stp;
struct xray		*rp;
struct application	*ap;
struct seg		*seghead;
struct rt_piecestate	*psp;
d293 1
a293 5
rt_bot_shot( stp, rp, ap, seghead )
struct soltab		*stp;
register struct xray	*rp;
struct application	*ap;
struct seg		*seghead;
d317 1
a317 7
rt_bot_piece_shot( psp, plp, dist_corr, rp, ap, seghead )
struct rt_piecestate	*psp;
struct rt_piecelist	*plp;
double			dist_corr;
register struct xray	*rp;
struct application	*ap;
struct seg		*seghead;
d338 1
a338 4
rt_bot_piece_hitsegs( psp, seghead, ap )
struct rt_piecestate	*psp;
struct seg		*seghead;
struct application	*ap;
d359 6
a364 6
rt_bot_vshot( stp, rp, segp, n, ap )
struct soltab	       *stp[]; /* An array of solid pointers */
struct xray		*rp[]; /* An array of ray pointers */
struct  seg            segp[]; /* array of segs (results returned) */
int		  	    n; /* Number of ray/object pairs */
struct application	*ap;
d375 1
a375 4
rt_bot_norm( hitp, stp, rp )
register struct hit	*hitp;
struct soltab		*stp;
register struct xray	*rp;
d392 1
a392 4
rt_bot_curve( cvp, hitp, stp )
register struct curvature *cvp;
register struct hit	*hitp;
struct soltab		*stp;
d410 1
a410 5
rt_bot_uv( ap, stp, hitp, uvp )
struct application	*ap;
struct soltab		*stp;
register struct hit	*hitp;
register struct uvcoord	*uvp;
d418 1
a418 2
rt_bot_free( stp )
register struct soltab *stp;
d434 1
a434 4
rt_bot_class( stp, min, max, tol )
const struct soltab    *stp;
const vect_t		min, max;
const struct bn_tol    *tol;
d443 1
a443 5
rt_bot_plot( vhead, ip, ttol, tol )
struct bu_list		*vhead;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol	*tol;
d467 1
a467 5
rt_bot_plot_poly( vhead, ip, ttol, tol )
struct bu_list		*vhead;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol	*tol;
d526 1
a526 6
rt_bot_tess( r, m, ip, ttol, tol )
struct nmgregion	**r;
struct model		*m;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol	*tol;
d623 1
a623 5
rt_bot_import( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
d699 1
a699 5
rt_bot_export( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d805 1
a805 5
rt_bot_import5( ip, ep, mat, dbip )
struct rt_db_internal           *ip;
const struct bu_external        *ep;
register const mat_t            mat;
const struct db_i               *dbip;
d918 1
a918 5
rt_bot_export5( ep, ip, local2mm, dbip )
struct bu_external              *ep;
const struct rt_db_internal     *ip;
double                          local2mm;
const struct db_i               *dbip;
d1044 1
a1044 5
rt_bot_describe( str, ip, verbose, mm2local )
struct bu_vls		*str;
const struct rt_db_internal	*ip;
int			verbose;
double			mm2local;
d1160 1
a1160 2
rt_bot_ifree( ip )
struct rt_db_internal	*ip;
d1183 1
a1183 5
rt_bot_tnurb( r, m, ip, tol )
struct nmgregion        **r;
struct model            *m;
struct rt_db_internal   *ip;
const struct bn_tol           *tol;
d1189 1
a1189 5
rt_bot_xform( op, mat, ip, free, dbip )
struct rt_db_internal *op, *ip;
const mat_t	mat;
const int free;
struct db_i	*dbip;
d1498 1
a1498 4
rt_bot_tclget( interp, intern, attr )
Tcl_Interp			*interp;
const struct rt_db_internal	*intern;
const char			*attr;
d1855 1
a1855 5
rt_bot_tcladjust( interp, intern, argc, argv )
Tcl_Interp		*interp;
struct rt_db_internal	*intern;
int			argc;
char			**argv;
@


1.122
log
@Mods to allow zero value for constraints (e.g. simplify planar faces)
@
text
@d14 1
a14 1
 *	This software is Copyright (C) 1999 by the United States Army.
d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.121 2003/11/04 19:40:24 morrison Exp $ (BRL)";
@


1.121
log
@quell unitialized data warning
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.120 2003/10/03 19:47:39 jra Exp $ (BRL)";
d3481 1
a3481 1
	if( max_chord_error > SMALL_FASTF || max_normal_error > SMALL_FASTF ) {
d3524 1
a3524 1
			if( max_normal_error > SMALL_FASTF && dot < max_normal_error ) {
d3530 1
a3530 1
			if( max_chord_error > SMALL_FASTF && dist > max_chord_error ) {
d3574 1
d3579 1
a3579 1

d3581 1
a3581 1
	if( max_normal_error > SMALL_FASTF ) {
@


1.120
log
@Improved performance of rt_bot_sort_faces()
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.119 2003/09/10 00:31:41 jra Exp $ (BRL)";
d2871 1
a2871 1
	int *new_norms;		/* the sorted list of vertex normals corrsponding to the "new_faces" list */
d2874 1
a2874 1
	int *piece_norms;	/* vertex normals for faces in the current piece */
@


1.120.2.1
log
@updates from HEAD, part 1
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.122 2003/11/19 21:45:04 jra Exp $ (BRL)";
d2871 1
a2871 1
	int *new_norms = (int*)NULL;		/* the sorted list of vertex normals corrsponding to the "new_faces" list */
d2874 1
a2874 1
	int *piece_norms = (int*)NULL;	/* vertex normals for faces in the current piece */
d3481 1
a3481 1
	if( max_chord_error > -1.0 || max_normal_error > -1.0 ) {
d3524 1
a3524 1
			if( max_normal_error > -1.0 && dot < max_normal_error ) {
d3530 1
a3530 1
			if( max_chord_error > -1.0 && dist > max_chord_error ) {
a3573 1
#if 0
d3578 1
a3578 1
#endif
d3580 1
a3580 1
	if( max_normal_error > -1.0 ) {
@


1.120.2.2
log
@merge from HEAD
@
text
@d14 1
a14 1
 *	This software is Copyright (C) 1999-2004 by the United States Army.
d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.123 2004/02/02 17:39:16 morrison Exp $ (BRL)";
@


1.120.2.3
log
@merge from head
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.120.2.2 2004/02/12 18:37:39 erikg Exp $ (BRL)";
@


1.119
log
@xform routines now handle attributes
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.118 2003/09/09 12:36:15 jra Exp $ (BRL)";
d2890 1
a2890 1
	piece_verts = (int *)bu_malloc( tris_per_piece * 3 * sizeof( int ), "piece_verts" );
d2910 1
a2910 1
		for( i=0 ; i<tris_per_piece*3 ; i++ ) {
d2983 30
a3012 2
						if( vert_count[i] > max_verts ) {
							max_verts = vert_count[i];
d3014 4
d3020 3
d3028 1
a3028 1
			if( max_verts == 0 ) {
d3067 1
a3067 1
			} else if( max_verts == 1 ) {
d3070 1
a3070 1
			} else {
d3079 1
a3079 1
			while( max_verts >= max_verts_min ) {
@


1.118
log
@Changes for normals as char arrays (plus a bug fix for bot_smooth, was missing a hit miss routine).
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.117 2003/08/25 18:44:22 jra Exp $ (BRL)";
d1323 7
d1341 1
a1341 1
	if( free && op != ip )
d1343 1
@


1.117
log
@Mods to the decimate routines to improve performance
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.116 2003/08/20 00:55:06 jra Exp $ (BRL)";
d99 1
d101 3
a103 1
#define NORM_TYPE	float
d107 2
d111 2
d116 2
d3710 6
d3789 1
@


1.116
log
@Improved checking for free edge movement in the decimation code
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.115 2003/07/29 12:09:21 jra Exp $ (BRL)";
d3094 54
d3158 1
a3158 1
decimate_edge( int v1, int v2, int *faces, int num_faces )
d3160 21
a3180 3
	int i, j, k;
	int count;		/* number of references to v1 or v2 in the current face */
	int deleted_faces=0;
d3182 37
a3218 11
	for( i=0 ; i<num_faces*3 ; i += 3 ) {
		count = 0;
		for( j=0 ; j<3 ; j++ ) {
			k = i+j;
			if( faces[k] == v2 ) {
				/* a reference to v2, count it */
				count++;
			} else if( faces[k] == v1 ) {
				/* a reference to v1, count it and change it to v2 */
				faces[k] = v2;
				count++;
d3220 3
a3222 6
		}
		if( count > 1 ) {
			/* eliminate this face */
			deleted_faces++;
			for( j=0 ; j<3 ; j++ ) {
				faces[i+j] = -1;
d3225 2
d3228 1
d3230 3
a3232 2
	return deleted_faces;
}
d3234 5
a3238 7
static int
bot_face_free_edge_count( int face, int *faces, int num_faces )
{
	int v[3];
	int edge_count[3];
	int i, j, k;
	int free_edges=0;
d3240 10
a3249 2
	VSETALL( edge_count, 0 );
	VMOVE( v, &faces[face] );
d3251 40
a3290 2
	for( i=0 ; i<num_faces*3 ; i += 3 ) {
		int c[3];
d3292 4
a3295 1
		VSETALL( c, 0 );
d3297 8
a3304 6
		if( i == face )
			continue;
		for( k=0 ; k<3 ; k++ ) {
			for( j=0 ; j<3 ; j++ ) {
				if( faces[i+k] == v[j] ) {
					c[j]++;
d3306 3
a3310 9
		if( (c[0] + c[1] + c[2]) < 2 )
			continue;

		if( c[0] && c[1] )
			edge_count[0]++;
		if( c[1] && c[2] )
			edge_count[1]++;
		if( c[2] && c[0] )
			edge_count[2]++;
d3313 1
a3313 6
	for( i=0 ; i<3 ; i++ ) {
		if( !edge_count[i] )
			free_edges++;
	}

	return( free_edges );
d3336 1
d3339 2
d3347 1
a3348 1
	int face_del1, face_del2;
d3359 2
a3360 2
	face_del1 = -1;
	face_del2 = -1;
d3377 2
a3378 2
			if( face_del1 > -1 ) {
				face_del2 = i;
d3380 1
a3380 1
				face_del1 = i;
d3395 1
a3395 1
	if( face_del2 < 0 ) {
d3406 10
a3415 9
		if( bot_face_free_edge_count( face_del1, faces, bot->num_faces ) ) {
			return 0;
		}
		if( bot_face_free_edge_count( face_del2, faces, bot->num_faces ) ) {
			return 0;
		}
		for( i=0 ; i<affected_count ; i++ ) {
			if( bot_face_free_edge_count( faces_affected[i], faces, bot->num_faces ) ) {
				return 0;
a3486 5
struct bot_edge {
  int v;
  struct bot_edge *next;
};

d3494 7
d3518 1
d3579 1
a3579 1
	      ptr = bu_malloc( sizeof( struct bot_edge ), "edges[v1]" );
d3584 1
d3587 1
a3587 1
	      ptr->next = bu_malloc( sizeof( struct bot_edge ), "ptr->next" );
d3592 1
d3597 45
a3641 23
	/* visit each edge */
	for( i=0 ; i<bot->num_vertices ; i++ ) {
	  struct bot_edge *ptr;

	  ptr = edges[i];
	  while( ptr ) {

	    /* try to avoid making 2D objects */
	    if( face_count < 5 )
	      break;

	    /* check if this edge can be eliminated (try both directions) */
	    if( edge_can_be_decimated( bot, faces, i, ptr->v,
				       max_chord_error, max_normal_error, min_edge_length_sq )) {
	      face_count -= decimate_edge( i, ptr->v, faces, bot->num_faces );
	      edges_deleted++;
	    } else if( edge_can_be_decimated( bot, faces, ptr->v, i,
				       max_chord_error, max_normal_error, min_edge_length_sq )) {
	      face_count -= decimate_edge( ptr->v, i, faces, bot->num_faces );
	      edges_deleted++;
	    }
	    ptr = ptr->next;
	  }
@


1.115
log
@Eliminated excess spaces that created non-zero length lists ( "{ }" vs "{}" )
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.114 2003/07/28 18:56:42 jra Exp $ (BRL)";
d3271 5
@


1.114
log
@Mods to allow BOT raytracing to use single precision tri_specific structs
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.113 2003/04/25 00:56:31 jra Exp $ (BRL)";
d1592 1
a1592 1
		bu_vls_printf( &vls, " } V {" );
d1596 1
a1596 1
		bu_vls_strcat( &vls, " } F {" );
d1600 1
a1600 1
		bu_vls_strcat( &vls, " }" );
d1606 1
a1606 1
			bu_vls_strcat( &vls, " } fm " );
d1614 1
a1614 1
			bu_vls_printf( &vls, " } fn {" );
d1618 1
a1618 1
			bu_vls_printf( &vls, " }" );
d1776 1
a1776 1
			bu_vls_printf( &vls, " }" );
@


1.113
log
@find_closest_face() was incorrectly indexing into the vertex array
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.112 2003/04/07 12:47:19 jra Exp $ (BRL)";
d42 3
d68 41
a131 4
	register struct tri_specific *trip;
	vect_t work;
	LOCAL fastf_t m1, m2, m3, m4;
	int i;
d133 3
a135 31
	BU_GETSTRUCT( trip, tri_specific );
	VMOVE( trip->tri_A, ap );
	VSUB2( trip->tri_BA, bp, ap );
	VSUB2( trip->tri_CA, cp, ap );
	VCROSS( trip->tri_wn, trip->tri_BA, trip->tri_CA );
	trip->tri_surfno = face_no;

	/* Check to see if this plane is a line or pnt */
	m1 = MAGNITUDE( trip->tri_BA );
	m2 = MAGNITUDE( trip->tri_CA );
	VSUB2( work, bp, cp );
	m3 = MAGNITUDE( work );
	m4 = MAGNITUDE( trip->tri_wn );
	if( m1 < 0.00001 || m2 < 0.00001 ||
	    m3 < 0.00001 || m4 < 0.00001 )  {
		bu_free( (char *)trip, "getstruct tri_specific");

		if( RT_G_DEBUG & DEBUG_SHOOT ) {
		    bu_log("%s: degenerate facet #%d\n",
			   stp->st_name, face_no);
		    bu_log( "\t(%g %g %g) (%g %g %g) (%g %g %g)\n",
			    V3ARGS( ap ), V3ARGS( bp ), V3ARGS( cp ) );
	    	}
		return(0);			/* BAD */
	}		

	if( (bot->bot_flags & RT_BOT_HAS_SURFACE_NORMALS) && (bot->bot_flags & RT_BOT_USE_NORMALS) && vertex_normals ) {
		trip->tri_normals = (fastf_t *)bu_malloc( 9 * sizeof( fastf_t ), "trip->tri_normals" );
		for( i=0 ; i<3 ; i++ ) {
			VMOVE( &trip->tri_normals[i*3], &vertex_normals[i*3] );
		}
d137 2
a138 1
		trip->tri_normals = (fastf_t *)NULL;
a139 14

	/*  wn is a normal of not necessarily unit length.
	 *  N is an outward pointing unit normal.
	 *  We depend on the points being given in CCW order here.
	 */
	VMOVE( trip->tri_N, trip->tri_wn );
	VUNITIZE( trip->tri_N );
	if( bot->bot_mode == RT_BOT_CW )
		VREVERSE( trip->tri_N, trip->tri_N );

	/* Add this face onto the linked list for this solid */
	trip->tri_forw = bot->bot_facelist;
	bot->bot_facelist = trip;
	return(3);				/* OK */
d164 2
a165 40
    struct bound_rpp	*minmax = (struct bound_rpp *)NULL;
    struct tri_specific **fap;
    register struct tri_specific *trip;
    point_t b,c;
    point_t d,e,f;
    vect_t offset;
    fastf_t los;
    int surfno;
    long num_rpps;
    int tri_per_piece, tpp_m1;

    tri_per_piece = bot->bot_tri_per_piece = rt_bot_tri_per_piece;

    num_rpps = ntri / tri_per_piece;
    if (ntri % tri_per_piece) num_rpps++;

    stp->st_npieces = num_rpps;

    fap = bot->bot_facearray = (struct tri_specific **)
	bu_malloc( sizeof(struct tri_specific *) * ntri,
		   "bot_facearray" );

    stp->st_piece_rpps = (struct bound_rpp *)
	bu_malloc( sizeof(struct bound_rpp) * num_rpps,
		   "st_piece_rpps" );


    tpp_m1 = tri_per_piece - 1;
    trip = bot->bot_facelist;
    minmax = &stp->st_piece_rpps[num_rpps-1];
    for (surfno=ntri-1 ; trip; trip = trip->tri_forw, surfno-- )  {

	if ( (surfno % tri_per_piece) == tpp_m1) {
	    /* top most surfno in a piece group */
	    /* first surf for this piece */
	    minmax = &stp->st_piece_rpps[surfno / tri_per_piece];

	    minmax->min[X] = minmax->max[X] = trip->tri_A[X];
	    minmax->min[Y] = minmax->max[Y] = trip->tri_A[Y];
	    minmax->min[Z] = minmax->max[Z] = trip->tri_A[Z];
d167 1
a167 59
	    VMINMAX( minmax->min, minmax->max, trip->tri_A);
	}

	fap[surfno] = trip;

	/* It is critical that the surfno's used in
	 * rt error messages (from hit_surfno) match
	 * the tri_surfno values, so that mged users who
	 * run "db get name f#" to see that triangle
	 * get the triangle they're expecting!
	 */
	BU_ASSERT_LONG( trip->tri_surfno, ==, surfno );

	if (bot->bot_mode == RT_BOT_PLATE ||
	   bot->bot_mode == RT_BOT_PLATE_NOCOS )  {
	    if( BU_BITTEST( bot->bot_facemode, surfno ) )  {
		/* Append full thickness on both sides */
		los = bot->bot_thickness[surfno];
	    } else {
		/* Center thickness.  Append 1/2 thickness on both sides */
		los = bot->bot_thickness[surfno] * 0.51;
	    }
	} else {
				/* Prevent the RPP from being 0 thickness */
	    los = tol->dist;	/* typ 0.005mm */
	}

	VADD2( b, trip->tri_BA, trip->tri_A );
	VADD2( c, trip->tri_CA, trip->tri_A );
	VMINMAX( minmax->min, minmax->max, b );
	VMINMAX( minmax->min, minmax->max, c );

	/* Offset face in +los */
	VSCALE( offset, trip->tri_N, los );
	VADD2( d, trip->tri_A, offset );
	VADD2( e, b, offset );
	VADD2( f, c, offset );
	VMINMAX( minmax->min, minmax->max, d );
	VMINMAX( minmax->min, minmax->max, e );
	VMINMAX( minmax->min, minmax->max, f );

	/* Offset face in -los */
	VSCALE( offset, trip->tri_N, -los );
	VADD2( d, trip->tri_A, offset );
	VADD2( e, b, offset );
	VADD2( f, c, offset );
	VMINMAX( minmax->min, minmax->max, d );
	VMINMAX( minmax->min, minmax->max, e );
	VMINMAX( minmax->min, minmax->max, f );

    }

#if 0
    for (surfno=ntri-1 ; surfno >= 0; surfno-- )  {
	trip = bot->bot_facearray[surfno];
	if (trip->tri_surfno != surfno) {
	    bu_log("trip->tri_surfno:%d != piecenum%d\n", 
		   trip->tri_surfno, surfno);
	    bu_bomb("");
a168 11
    }

    trip = bot->bot_facelist;
    while( trip ) {
	    if( trip->tri_surfno < 0 || trip->tri_surfno >= ntri ) {
		    bu_log( "%s:\n", stp->st_dp->d_namep );
		    bu_log( "\ttrip->tri_surfno = %d\n", trip->tri_surfno );
	    }
	    trip = trip->tri_forw;
    }
#endif
d193 1
a193 6
	register struct bot_specific	*bot;
	const struct bn_tol		*tol = &rtip->rti_tol;
	int				tri_index, i;
	LOCAL fastf_t			dx, dy, dz;
	LOCAL fastf_t			f;
	int				ntri = 0;
d199 4
a202 66
	BU_GETSTRUCT( bot, bot_specific );
	stp->st_specific = (genptr_t)bot;
	bot->bot_mode = bot_ip->mode;
	bot->bot_orientation = bot_ip->orientation;
	bot->bot_flags = bot_ip->bot_flags;
	if( bot_ip->thickness )
	{
		bot->bot_thickness = (fastf_t *)bu_calloc( bot_ip->num_faces, sizeof( fastf_t ), "bot_thickness" );
		for( tri_index=0 ; tri_index <  bot_ip->num_faces ; tri_index++ )
			bot->bot_thickness[tri_index] = bot_ip->thickness[tri_index];
	}
	if( bot_ip->face_mode )
		bot->bot_facemode = bu_bitv_dup( bot_ip->face_mode );
	bot->bot_facelist = (struct tri_specific *)NULL;

	VSETALL( stp->st_min, MAX_FASTF );
	VREVERSE( stp->st_max, stp->st_min );
	for( tri_index=0 ; tri_index < bot_ip->num_faces ; tri_index++ )
	{
		point_t p1, p2, p3;
		int default_normal=-1;

		VMOVE( p1, &bot_ip->vertices[bot_ip->faces[tri_index*3]*3] );
		VMOVE( p2, &bot_ip->vertices[bot_ip->faces[tri_index*3 + 1]*3] );
		VMOVE( p3, &bot_ip->vertices[bot_ip->faces[tri_index*3 + 2]*3] );
		VMINMAX( stp->st_min, stp->st_max, p1 );
		VMINMAX( stp->st_min, stp->st_max, p2 );
		VMINMAX( stp->st_min, stp->st_max, p3 );
		if( (bot_ip->bot_flags & RT_BOT_HAS_SURFACE_NORMALS) && (bot_ip->bot_flags & RT_BOT_USE_NORMALS)
			&& (bot_ip->num_normals > 0) && (bot_ip->num_face_normals > tri_index) ) {
			for( i=0 ; i<3 ; i++ ) {
				int index;

				index = bot_ip->face_normals[tri_index*3 + i];
				if( index >= 0 && index < bot_ip->num_normals ) {
					default_normal = index;
				}
			}
			if( default_normal < 0 ) {
				if( rt_botface( stp, bot, p1, p2, p3, ntri, tol ) > 0 )
					ntri++;
			} else {
				fastf_t normals[9];

				for( i=0 ; i<3 ; i++ ) {
					int index;

					index = bot_ip->face_normals[tri_index*3 + i];
					if( index < 0 || index > bot_ip->num_normals ) {
						VMOVE( &normals[i*3], &bot_ip->normals[default_normal*3] );
					} else {
						VMOVE( &normals[i*3], &bot_ip->normals[index*3] );
					}
				}
				if( rt_botface_w_normals( stp, bot, p1, p2, p3, normals, ntri, tol ) > 0 )
					ntri++;
			}
		} else {
			if( rt_botface( stp, bot, p1, p2, p3, ntri, tol ) > 0 )
				ntri++;
		}
	}

	if( bot->bot_facelist == (struct tri_specific *)0 )  {
		bu_log("bot(%s):  no faces\n", stp->st_name);
		return(-1);             /* BAD */
a203 44

	bot->bot_ntri = ntri;

	/* zero thickness will get missed by the raytracer */
	for( i=0 ; i<3 ; i++ )
	{
		if( NEAR_ZERO( stp->st_min[i] - stp->st_max[i], 1.0 ) )
		{
			stp->st_min[i] -= 0.000001;
			stp->st_max[i] += 0.000001;
		}
	}

	VADD2SCALE( stp->st_center, stp->st_max, stp->st_min, 0.5 );

	dx = (stp->st_max[X] - stp->st_min[X])/2;
	f = dx;
	dy = (stp->st_max[Y] - stp->st_min[Y])/2;
	if( dy > f )  f = dy;
	dz = (stp->st_max[Z] - stp->st_min[Z])/2;
	if( dz > f )  f = dz;
	stp->st_aradius = f;
	stp->st_bradius = sqrt(dx*dx + dy*dy + dz*dz);

	/*
	 *  Support for solid 'pieces'
	 *
	 *  Each piece can represent a number of triangles.  This is encoded
	 *  in bot->bot_tri_per_piece.
	 *
      	 *  These array allocations can't be made until the number of
	 *  triangles are known.
	 *
	 *  If the number of triangles is too small,
	 *  don't bother making pieces, the overhead isn't worth it.
	 *
	 *  To disable BoT pieces, on the RT command line specify:
	 *	-c "set rt_bot_minpieces=0"
	 */
	if( rt_bot_minpieces <= 0 )  return 0;
	if( ntri < rt_bot_minpieces )  return 0;

	rt_bot_prep_pieces(bot, stp, ntri, tol);
	return 0;
d224 2
a225 37
    register struct seg *segp;
    register int i;
    register fastf_t los;
    int surfno;


    for( i=0; i < nhits; i++ ) {
	struct tri_specific *trip=(struct tri_specific *)hits[i].hit_private;

	surfno = hits[i].hit_surfno;

	if( bot->bot_mode == RT_BOT_PLATE_NOCOS )
	    los = bot->bot_thickness[surfno];
	else {
	    los = bot->bot_thickness[surfno] / hits[i].hit_vpriv[X];
	    if( los < 0.0 )
		los = -los;
	}
	if( BU_BITTEST( bot->bot_facemode, hits[i].hit_surfno ) ) {

				/* append thickness to hit point */
	    RT_GET_SEG( segp, ap->a_resource);
	    segp->seg_stp = stp;

				/* set in hit */
	    segp->seg_in = hits[i];
	    RT_BOT_UNORIENTED_NORM( &segp->seg_in, 1 );

				/* set out hit */
	    segp->seg_out.hit_surfno = surfno;
	    segp->seg_out.hit_dist = segp->seg_in.hit_dist + los;
	    VMOVE( segp->seg_out.hit_vpriv, hits[i].hit_vpriv );
	    RT_BOT_UNORIENTED_NORM( &segp->seg_out, -1 );
	    segp->seg_out.hit_private = segp->seg_in.hit_private;
	    segp->seg_out.hit_rayp = &ap->a_ray;

	    BU_LIST_INSERT( &(seghead->l), &(segp->l) );
d227 1
a227 21
				/* center thickness about hit point */
	    RT_GET_SEG( segp, ap->a_resource);
	    segp->seg_stp = stp;

				/* set in hit */
	    segp->seg_in.hit_surfno = surfno;
	    VMOVE( segp->seg_in.hit_vpriv, hits[i].hit_vpriv );
	    RT_BOT_UNORIENTED_NORM( &segp->seg_in, 1 );
	    segp->seg_in.hit_private = hits[i].hit_private;
	    segp->seg_in.hit_dist = hits[i].hit_dist - (los*0.5 );
	    segp->seg_in.hit_rayp = &ap->a_ray;

				/* set out hit */
	    segp->seg_out.hit_surfno = surfno;
	    segp->seg_out.hit_dist = segp->seg_in.hit_dist + los;
	    VMOVE( segp->seg_out.hit_vpriv, hits[i].hit_vpriv );
	    RT_BOT_UNORIENTED_NORM( &segp->seg_out, -1 );
	    segp->seg_out.hit_private = hits[i].hit_private;
	    segp->seg_out.hit_rayp = &ap->a_ray;

	    BU_LIST_INSERT( &(seghead->l), &(segp->l) );
a228 4
    }
    /* Every hit turns into two, and makes a seg.  No leftovers */
    return( nhits*2 );

d240 4
a243 62
    register struct seg *segp;
    register int i, j;

    /*
     *  RT_BOT_SOLID, RT_BOT_UNORIENTED.
     */
    fastf_t rm_dist=0.0;
    int	removed=0;

    if( nhits == 1 ) {
	struct tri_specific *trip=(struct tri_specific *)hits[0].hit_private;

	/* make a zero length partition */
	RT_GET_SEG( segp, ap->a_resource );
	segp->seg_stp = stp;

	/* set in hit */
	segp->seg_in = hits[0];
	RT_BOT_UNORIENTED_NORM( &segp->seg_in, 1 );

	/* set out hit */
	segp->seg_out = hits[0];
	RT_BOT_UNORIENTED_NORM( &segp->seg_out, -1 );

	BU_LIST_INSERT( &(seghead->l), &(segp->l) );
	return( 1 );
    }

    /* Remove duplicate hits */
    for( i=0 ; i<nhits-1 ; i++ ) {
	fastf_t dist;

	dist = hits[i].hit_dist - hits[i+1].hit_dist;
	if( NEAR_ZERO( dist, ap->a_rt_i->rti_tol.dist ) ) {
	    removed++;
	    rm_dist = hits[i+1].hit_dist;
	    for( j=i ; j<nhits-1 ; j++ )
		hits[j] = hits[j+1];
	    nhits--;
	    i--;
	}
    }


    if( nhits == 1 )
	return( 0 );

    if( nhits&1 && removed ) {
	/* If we have an odd number of hits and have removed
	 * a duplicate, then it was likely on an edge, so
	 * remove the one we left.
	 */
	register int j;

	for( i=0 ; i<nhits ; i++ ) {
	    if( hits[i].hit_dist == rm_dist ) {
		for( j=i ; j<nhits-1 ; j++ )
		    hits[j] = hits[j+1];
		nhits--;
		i--;
		break;
	    }
a244 30
    }

    for( i=0 ; i<(nhits&~1) ; i += 2 ) {
	struct tri_specific *trip;

	RT_GET_SEG( segp, ap->a_resource );
	segp->seg_stp = stp;

	/* set in hit */
	segp->seg_in = hits[i];
	trip = (struct tri_specific *)hits[i].hit_private;
	RT_BOT_UNORIENTED_NORM( &segp->seg_in, 1 );

	/* set out hit */
	segp->seg_out = hits[i+1];
	trip = (struct tri_specific *)hits[i+1].hit_private;
	RT_BOT_UNORIENTED_NORM( &segp->seg_out, -1 );

	BU_LIST_INSERT( &(seghead->l), &(segp->l) );
    }
    if( nhits&1 ) {
	if( RT_G_DEBUG & DEBUG_SHOOT ) {
	    bu_log( "rt_bot_unoriented_segs(%s): WARNING: odd number of hits (%d), last hit ignored\n",
		    stp->st_name, nhits );
	    bu_log( "\tray = -p %g %g %g -d %g %g %g\n",
		    V3ARGS( rp->r_pt ), V3ARGS( rp->r_dir ) );
	}
	nhits--;
    }
    return( nhits );
a265 4
    register struct seg *segp;
    register int i;

    RT_CK_SOLTAB(stp);
d272 4
a275 233
    if( bot->bot_mode == RT_BOT_SURFACE ) {
	for( i=0 ; i<nhits ; i++ )
	    {
		struct tri_specific *trip=(struct tri_specific *)hits[i].hit_private;

		RT_GET_SEG( segp, ap->a_resource );
		segp->seg_stp = stp;

		/* set in hit */
		segp->seg_in = hits[i];
		RT_BOT_UNORIENTED_NORM( &segp->seg_in, 1 );

		/* set out hit */
		segp->seg_out = hits[i];
		RT_BOT_UNORIENTED_NORM( &segp->seg_out, -1 );
		BU_LIST_INSERT( &(seghead->l), &(segp->l) );
	    }
	/* Every hit turns into two, and makes a seg.  No leftovers */
	return( nhits*2 );
    }

    BU_ASSERT( bot->bot_mode == RT_BOT_SOLID );

    if( bot->bot_orientation == RT_BOT_UNORIENTED ) {
	return rt_bot_unoriented_segs(hits, nhits, stp, rp, ap,
				      seghead, bot);
    }

    /*
	 *  RT_BOT_SOLID, RT_BOT_ORIENTED.
	 *
	 *  From this point on, process very similar to a polysolid
	 */

    /* Remove duplicate hits */
    {
	register int j,k,l;

	for( i=0 ; i<nhits-1 ; i++ )
	    {
		FAST fastf_t dist;
		FAST fastf_t dn;

		dn = hits[i].hit_vpriv[X];

		k = i + 1;
		dist = hits[i].hit_dist - hits[k].hit_dist;

		/* count number of hits at this distance */
		while( NEAR_ZERO( dist, ap->a_rt_i->rti_tol.dist ) ) {
			k++;
			if( k > nhits - 1 )
				break;
			dist = hits[i].hit_dist - hits[k].hit_dist;
		}

		if( (k - i) == 2 && dn * hits[i+1].hit_vpriv[X] > 0) {
			/* a pair of hits at the same distance and both are exits or entrances,
			 * likely an edge hit, remove one */
			for( j=i ; j<nhits-1 ; j++ )
				hits[j] = hits[j+1];
			if( psp ) {
				psp->htab.end--;
			}
			nhits--;
			i--;
			continue;
		} else if( (k - i) > 2 ) {
			int keep1=-1, keep2=-1;
			int enters=0, exits=0;
			int reorder=0;
			int reorder_failed=0;

			/* more than two hits at the same distance, likely a vertex hit
			 * try to keep just two, one entrance and one exit.
			 * unless they are all entrances or all exits, then just keep one */

			/* first check if we need to do anything */
			for( j=0 ; j<k ; j++ ) {
				if( hits[j].hit_vpriv[X] > 0 )
					exits++;
				else
					enters++;
			}

			if( k%2 ) {
				if( exits == (enters - 1) ) {
					reorder = 1;
				}
			} else {
				if( exits == enters ) {
					reorder = 1;
				}
			}

			if( reorder ) {
				struct hit tmp_hit;
				int changed=0;

				for( j=i ; j<k ; j++ ) {
					int l;

					if( j%2 ) {
						if( hits[j].hit_vpriv[X] > 0 ) {
							continue;
						}
						/* should be an exit here */
						l = j+1;
						while( l < k ) {
							if( hits[l].hit_vpriv[X] > 0 ) {
								/* swap with this exit */
								tmp_hit = hits[j];
								hits[j] = hits[l];
								hits[l] = tmp_hit;
								changed = 1;
								break;
							}
							l++;
						}
						if( hits[j].hit_vpriv[X] < 0 ) {
							reorder_failed = 1;
							break;
						}
					} else {
						if( hits[j].hit_vpriv[X] < 0 ) {
							continue;
						}
						/* should be an entrance here */
						l = j+1;
						while( l < k ) {
							if( hits[l].hit_vpriv[X] < 0 ) {
								/* swap with this entrance */
								tmp_hit = hits[j];
								hits[j] = hits[l];
								hits[l] = tmp_hit;
								changed = 1;
								break;
							}
							l++;
						}
						if( hits[j].hit_vpriv[X] > 0 ) {
							reorder_failed = 1;
							break;
						}
					}
				}
				if( changed ) {
					/* if we have re-ordered these hits, make sure they are really
					 *  at the same distance.
					 */
					for( j=i+1 ; j<k ; j++ ) {
						hits[j].hit_dist = hits[i].hit_dist;
					}
				}
			} 
			if( !reorder || reorder_failed ) {

				exits = 0;
				enters = 0;
				if( i == 0 ) {
					dn = 1.0;
				} else {
					dn = hits[i-1].hit_vpriv[X];
				}
				for( j=i ; j<k ; j++ ) {
					if( hits[j].hit_vpriv[X] > 0 )
						exits++;
					else
						enters++;
					if( dn * hits[j].hit_vpriv[X] < 0 ) {
						if( keep1 < 0 ) {
							keep1 = j;
							dn = hits[j].hit_vpriv[X];
						} else if( keep2 < 0 ) {
							keep2 = j;
							dn = hits[j].hit_vpriv[X];
							break;
						}
					}
				}

				if( keep2 == -1 ) {
				/* did not find two keepers, perhaps they were all entrances or all exits */
					if( exits == k - i || enters == k - i ) {
						/* eliminate all but one entrance or exit */
						for( j=k-1 ; j>i ; j-- ) {
							/* delete this hit */
							for( l=j ; l<nhits-1 ; l++ )
								hits[l] = hits[l+1];
							if( psp ) {
								psp->htab.end--;
							}
							nhits--;
						}
						i--;
					}
				} else if( keep2 >= 0 ) {
				/* found an entrance and an exit to keep */
					for( j=k-1 ; j>=i ; j-- ) {
						if( j != keep1 && j != keep2 ) {
							/* delete this hit */
							for( l=j ; l<nhits-1 ; l++ )
								hits[l] = hits[l+1];
							if( psp ) {
								psp->htab.end--;
							}
							nhits--;
						}
					}
					i--;
				}
			}
		}
	    }
    }
#if 0
    bu_log( "nhits = %d\n", nhits );
    for( i=0 ; i<nhits ; i++ ) {
	    rt_bot_norm( &hits[i], stp, rp );
	    bu_log( "dist=%g, normal = (%g %g %g), %s\n", hits[i].hit_dist, V3ARGS( hits[i].hit_normal), hits[i].hit_vpriv[X] > 0 ? "exit" : "entrance" );
    }
#endif

    /* if first hit is an exit, it is likely due to the "piece" for the corresponding entrance
     * not being processed (this is OK, but we need to eliminate the stray exit hit)
     */
    while( nhits > 0 && hits[0].hit_vpriv[X] > 0.0 ) {
	    int j;

	    for( j=1 ; j<nhits ; j++ ) {
		    hits[j-1] = hits[j];
	    }
	    nhits--;
a276 125

    /* similar for trailing entrance hits */
    while( nhits > 0 && hits[nhits-1].hit_vpriv[X] < 0.0 ) {
	    nhits--;
    }

    if( (nhits&1) )  {
	register int i;
	/*
	 * If this condition exists, it is almost certainly due to
	 * the dn==0 check above.  Thus, we will make the last
	 * surface rather thin.
	 * This at least makes the
	 * presence of this solid known.  There may be something
	 * better we can do.
	 */

	if( nhits > 2 )
	    {
		fastf_t dot1,dot2;
		int j;

		/* likely an extra hit,
		 * look for consecutive entrances or exits */

		dot2 = 1.0;
		i = 0;
		while( i<nhits )
		    {
			dot1 = dot2;
			dot2 = hits[i].hit_vpriv[X];
			if( dot1 > 0.0 && dot2 > 0.0 )
			    {
				/* two consectutive exits,
				 * manufacture an entrance at same distance
				 * as second exit.
				 */
				/* XXX This consumes an extra hit structure in the array */
				if( psp ) {
					/* using pieces */
					(void)rt_htbl_get(&psp->htab);	/* make sure space exists in the hit array */
					hits = psp->htab.hits;
				} else if( nhits + 1 >= MAXHITS ) {
					/* not using pieces */
					bu_log( "rt_bot_makesegs: too many hits on %s\n", stp->st_dp->d_namep );
					i++;
					continue;
				}
				for( j=nhits ; j>i ; j-- )
				    hits[j] = hits[j-1];	/* struct copy */

				hits[i].hit_vpriv[X] = -hits[i].hit_vpriv[X];
				dot2 = hits[i].hit_vpriv[X];
				nhits++;
				bu_log( "\t\tadding fictitious entry at %f (%s)\n", hits[i].hit_dist, stp->st_name );
				bu_log( "\t\t\tray = (%g %g %g) -> (%g %g %g)\n", V3ARGS( ap->a_ray.r_pt ), V3ARGS( ap->a_ray.r_dir ) );
			    }
			else if( dot1 < 0.0 && dot2 < 0.0 )
			    {
				/* two consectutive entrances,
				 * manufacture an exit between them.
				 */
				/* XXX This consumes an extra hit structure in the array */

				if( psp ) {
					/* using pieces */
					(void)rt_htbl_get(&psp->htab);	/* make sure space exists in the hit array */
					hits = psp->htab.hits;
				} else if( nhits + 1 >= MAXHITS ) {
					/* not using pieces */
					bu_log( "rt_bot_makesegs: too many hits on %s\n", stp->st_dp->d_namep );
					i++;
					continue;
				}
				for( j=nhits ; j>i ; j-- )
				    hits[j] = hits[j-1];	/* struct copy */

				hits[i] = hits[i-1];	/* struct copy */
				hits[i].hit_vpriv[X] = -hits[i].hit_vpriv[X];
				dot2 = hits[i].hit_vpriv[X];
				nhits++;
				bu_log( "\t\tadding fictitious exit at %f (%s)\n", hits[i].hit_dist, stp->st_name );
				bu_log( "\t\t\tray = (%g %g %g) -> (%g %g %g)\n", V3ARGS( ap->a_ray.r_pt ), V3ARGS( ap->a_ray.r_dir ) );
			    }
			i++;
		    }
	    }
    }

    if( (nhits&1) )  {
#if 1
	/* XXX This consumes an extra hit structure in the array */
	if( psp ) {
		(void)rt_htbl_get(&psp->htab);	/* make sure space exists in the hit array */
		hits = psp->htab.hits;
	}
	if( !psp && (nhits + 1 >= MAXHITS) ) {
		bu_log( "rt_bot_makesegs: too many hits on %s\n", stp->st_dp->d_namep );
		nhits--;
	} else {
		hits[nhits] = hits[nhits-1];	/* struct copy */
		hits[nhits].hit_vpriv[X] = -hits[nhits].hit_vpriv[X];
		nhits++;
	}
#else
	nhits--;
#endif
    }

    /* nhits is even, build segments */
    for( i=0; i < nhits; i += 2 )  {
	struct tri_specific *trip;

	RT_GET_SEG(segp, ap->a_resource);
	segp->seg_stp = stp;
	segp->seg_in = hits[i];	/* struct copy */
	trip = (struct tri_specific *)hits[i].hit_private;
	RT_BOT_UNORIENTED_NORM( &segp->seg_in, 1 );
	segp->seg_out = hits[i+1];	/* struct copy */
	trip = (struct tri_specific *)hits[i+1].hit_private;
	RT_BOT_UNORIENTED_NORM( &segp->seg_out, -1 );
	BU_LIST_INSERT( &(seghead->l), &(segp->l) );
    }

    return(nhits);			/* HIT */
d302 3
a304 10
	register struct tri_specific *trip = bot->bot_facelist;
	LOCAL struct hit hits[MAXHITS];
	register struct hit *hp;
	LOCAL int	nhits;
	fastf_t		toldist, dn_plus_tol;

	nhits = 0;
	hp = &hits[0];
	if( bot->bot_orientation != RT_BOT_UNORIENTED && bot->bot_mode == RT_BOT_SOLID ) {
		toldist = stp->st_aradius / 10.0e+6;
d306 1
a306 1
		toldist = 0.0;
a307 69

	/* consider each face */
	for( ; trip; trip = trip->tri_forw )  {
		FAST fastf_t	dn;		/* Direction dot Normal */
		LOCAL fastf_t	abs_dn;
		FAST fastf_t	k;
		LOCAL fastf_t	alpha, beta;
		LOCAL vect_t	wxb;		/* vertex - ray_start */
		LOCAL vect_t	xp;		/* wxb cross ray_dir */

		/*
		 *  Ray Direction dot N.  (N is outward-pointing normal)
		 *  wn points inwards, and is not unit length.
		 */
		dn = VDOT( trip->tri_wn, rp->r_dir );

		/*
		 *  If ray lies directly along the face, (ie, dot product
		 *  is zero), drop this face.
		 */
		abs_dn = dn >= 0.0 ? dn : (-dn);
		if( abs_dn < BOT_MIN_DN ) {
			continue;
		}
		VSUB2( wxb, trip->tri_A, rp->r_pt );
		VCROSS( xp, wxb, rp->r_dir );

		dn_plus_tol = toldist + abs_dn;

		/* Check for exceeding along the one side */
		alpha = VDOT( trip->tri_CA, xp );
		if( dn < 0.0 )  alpha = -alpha;
		if( alpha < -toldist || alpha > dn_plus_tol ) {
			continue;
		}

		/* Check for exceeding along the other side */
		beta = VDOT( trip->tri_BA, xp );
		if( dn > 0.0 )  beta = -beta;
		if( beta < -toldist || beta > dn_plus_tol ) {
			continue;
		}
		if( alpha+beta > dn_plus_tol ) {
			continue;
		}
		k = VDOT( wxb, trip->tri_wn ) / dn;
		/* HIT is within planar face */
		hp->hit_magic = RT_HIT_MAGIC;
		hp->hit_dist = k;
		hp->hit_private = (genptr_t)trip;
		hp->hit_vpriv[X] = VDOT( trip->tri_N, rp->r_dir );
		hp->hit_vpriv[Y] = alpha / abs_dn;
		hp->hit_vpriv[Z] = beta / abs_dn;
		hp->hit_surfno = trip->tri_surfno;
		hp->hit_rayp = &ap->a_ray;
		if( ++nhits >= MAXHITS )  {
			bu_log("rt_bot_shot(%s): too many hits (%d)\n", stp->st_name, nhits);
			break;
		}
		hp++;
	}
	if( nhits == 0 )
		return(0);		/* MISS */

	/* Sort hits, Near to Far */
	rt_hitsort( hits, nhits );

	/* build segments */
	return rt_bot_makesegs( hits, nhits, stp, rp, ap, seghead, NULL );
a330 2
	struct resource		*resp;
	long		*sol_piece_subscr_p;
a331 2
	long		piecenum;
	register struct hit *hp;
a332 4
	const int	debug_shoot = RT_G_DEBUG & DEBUG_SHOOT;
	int		starting_hits;
	fastf_t		toldist, dn_plus_tol;
	int		trinum;
a334 1
	RT_CK_PIECESTATE(psp);
a336 2
	resp = ap->a_resource;
	RT_CK_RESOURCE(resp);
a337 4
	starting_hits = psp->htab.end;

	if( bot->bot_orientation != RT_BOT_UNORIENTED &&
	    bot->bot_mode == RT_BOT_SOLID ) {
d339 2
a340 1
		toldist = psp->stp->st_aradius / 10.0e+6;
d342 1
a342 122
		toldist = 0.0;
	}

	if( debug_shoot ) {
		bu_log( "In rt_bot_piece_shot(), looking at %d pieces\n", plp->npieces );
	}
	sol_piece_subscr_p = &(plp->pieces[plp->npieces-1]);
	for( ; sol_piece_subscr_p >= plp->pieces; sol_piece_subscr_p-- )  {
		FAST fastf_t	dn;		/* Direction dot Normal */
		LOCAL fastf_t	abs_dn;
		FAST fastf_t	k;
		LOCAL fastf_t	alpha, beta;
		LOCAL vect_t	wxb;		/* vertex - ray_start */
		LOCAL vect_t	xp;		/* wxb cross ray_dir */
		LOCAL int	face_array_index;
		LOCAL int	tris_in_piece;
		register struct tri_specific *trip;
		
		piecenum = *sol_piece_subscr_p;

		if( BU_BITTEST( psp->shot, piecenum ) )  {
			if(debug_shoot) 
			    bu_log("%s piece %d already shot\n", 
				   stp->st_name, piecenum);

			resp->re_piece_ndup++;
			continue;	/* this piece already shot */
		}

		/* Shoot a ray */
		BU_BITSET( psp->shot, piecenum );
		if(debug_shoot)
		    bu_log("%s piece %d ...\n", stp->st_name, piecenum);

		/* Now intersect with each piece, which means
		 * intesecting with each triangle that makes up 
		 * the piece.
		 */
		face_array_index = piecenum*bot->bot_tri_per_piece;
		trip = bot->bot_facearray[face_array_index];
		tris_in_piece = bot->bot_ntri - face_array_index;
		if( tris_in_piece > bot->bot_tri_per_piece ) {
			tris_in_piece = bot->bot_tri_per_piece;
		}
		for( trinum=0 ; trinum<tris_in_piece ;
		     trinum++, trip=bot->bot_facearray[face_array_index+trinum] ) {
			fastf_t dN, abs_dN;

		    if (trip->tri_surfno < (piecenum*bot->bot_tri_per_piece) ||
			trip->tri_surfno >= 
			((piecenum + 1) * bot->bot_tri_per_piece )) {
			    bu_log("trip->tri_surfno:%d != piecenum%d\n", 
				   trip->tri_surfno, piecenum);
		    }

		    /*
		     *  Ray Direction dot N.  (N is outward-pointing normal)
		     *  wn points inwards, and is not unit length.
		     *  Therefore, wn is not a good choice for this test
		     */
		    dn = VDOT( trip->tri_wn, rp->r_dir );
		    dN = VDOT( trip->tri_N, rp->r_dir );

		    /*
		     *  If ray lies directly along the face, (ie, dot product
		     *  is zero), drop this face.
		     */
		    abs_dN = dN >= 0.0 ? dN : (-dN);
		    abs_dn = dn >= 0.0 ? dn : (-dn);
		    if( abs_dN < BOT_MIN_DN ) {
			continue;
		    }
		    VSUB2( wxb, trip->tri_A, rp->r_pt );
		    VCROSS( xp, wxb, rp->r_dir );

		    dn_plus_tol = toldist + abs_dn;

		    /* Check for exceeding along the one side */
		    alpha = VDOT( trip->tri_CA, xp );
		    if( dn < 0.0 )  alpha = -alpha;
		    if( alpha < -toldist || alpha > dn_plus_tol ) {
			continue;
		    }

		    /* Check for exceeding along the other side */
		    beta = VDOT( trip->tri_BA, xp );
		    if( dn > 0.0 )  beta = -beta;
		    if( beta < -toldist || beta > dn_plus_tol ) {
			continue;
		    }
		    if( alpha+beta > dn_plus_tol ) {
			continue;
		    }
		    k = VDOT( wxb, trip->tri_wn ) / dn;

		    /* HIT is within planar face */
		    hp = rt_htbl_get( &psp->htab );
		    hp->hit_magic = RT_HIT_MAGIC;
		    hp->hit_dist = k + dist_corr;
		    hp->hit_private = (genptr_t)trip;
		    hp->hit_vpriv[X] = VDOT( trip->tri_N, rp->r_dir );
		    hp->hit_vpriv[Y] = alpha / abs_dn;
		    hp->hit_vpriv[Z] = beta / abs_dn;
		    hp->hit_surfno = trip->tri_surfno;
		    hp->hit_rayp = &ap->a_ray;
		    if(debug_shoot)
			bu_log("%s piece %d surfno %d ... HIT %g\n",
			       stp->st_name, piecenum, trip->tri_surfno, hp->hit_dist);
		} /* for (trinum...) */
	} /* for (;sol_piece_subscr_p...) */

	if( psp->htab.end > 0 &&
	    (bot->bot_mode == RT_BOT_PLATE || 
	     bot->bot_mode == RT_BOT_PLATE_NOCOS) ) {
		/*
		 * Each of these hits is really two, resulting in an instant
		 * seg.  Saving an odd number of these will confuse a_onehit
		 * processing.
		 */
		rt_hitsort( psp->htab.hits, psp->htab.end );
		return rt_bot_makesegs( psp->htab.hits, psp->htab.end,
					stp, rp, ap, seghead, psp );
a343 1
	return psp->htab.end - starting_hits;
a394 1
	struct tri_specific *trip=(struct tri_specific *)hitp->hit_private;
a395 1
	vect_t old_norm;
d397 4
a400 46
	VJOIN1( hitp->hit_point, rp->r_pt, hitp->hit_dist, rp->r_dir );
	VMOVE( old_norm, hitp->hit_normal );

	if( (bot->bot_flags & RT_BOT_HAS_SURFACE_NORMALS) && (bot->bot_flags & RT_BOT_USE_NORMALS) && trip->tri_normals ) {
		fastf_t old_ray_dot_norm, new_ray_dot_norm;
		fastf_t u, v, w; /*barycentric coords of hit point */
		int i;

		old_ray_dot_norm = VDOT( hitp->hit_normal, rp->r_dir );

		v = hitp->hit_vpriv[Y];
		if( v < 0.0 ) v = 0.0;
		if( v > 1.0 ) v = 1.0;

		w = hitp->hit_vpriv[Z];
		if( w < 0.0 ) w = 0.0;
		if( w > 1.0 ) w =  1.0;

		u = 1.0 - v - w;
		if( u < 0.0 ) u = 0.0;
		VSETALL( hitp->hit_normal, 0.0 );
		for( i=X ; i<=Z ; i++ ) {
			hitp->hit_normal[i] = u*trip->tri_normals[i] + v*trip->tri_normals[i+3] + w*trip->tri_normals[i+6];
		}

		if( bot->bot_mode == RT_BOT_PLATE || bot->bot_mode == RT_BOT_PLATE_NOCOS ) {
			if( VDOT( old_norm, hitp->hit_normal ) < 0.0 ) {
				VREVERSE( hitp->hit_normal, hitp->hit_normal );
			}
		}

		new_ray_dot_norm = VDOT( hitp->hit_normal, rp->r_dir );

		if( (old_ray_dot_norm < 0.0 && new_ray_dot_norm > 0.0) ||
		    (old_ray_dot_norm > 0.0 && new_ray_dot_norm < 0.0) ) {
			/* surface normal interpolation has produced an incompatible normal direction
			 * clamp the normal to 90 degrees to the ray direction
			 */

			vect_t tmp;

			VCROSS( tmp, rp->r_dir, hitp->hit_normal );
			VCROSS( hitp->hit_normal, tmp, rp->r_dir );
		}

		VUNITIZE( hitp->hit_normal );
a447 1
	register struct tri_specific *tri, *ptr;
d449 4
a452 8
	if( bot->bot_facearray ) {
		bu_free( (char *)bot->bot_facearray, "bot_facearray" );
		bot->bot_facearray = NULL;
	}

	if( bot->bot_thickness ) {
		bu_free( (char *)bot->bot_thickness, "bot_thickness" );
		bot->bot_thickness = NULL;
a453 18
	if( bot->bot_facemode ) {
		bu_free( (char *)bot->bot_facemode, "bot_facemode" );
		bot->bot_facemode = NULL;
	}
	ptr = bot->bot_facelist;
	while( ptr )
	{
		tri = ptr->tri_forw;
		if( ptr ) {
			if( ptr->tri_normals ) {
				bu_free( (char *)ptr->tri_normals, "bot tri_specific normals" );
			}
			bu_free( (char *)ptr, "bot tri_specific" );
		}
		ptr = tri;
	}
	bot->bot_facelist = NULL;
	bu_free( (char *)bot, "bot_specific" );
d1589 3
d1773 3
d2462 2
d2465 1
a2465 1
					  Tcl_SetResult( interp, "unrecognized flag (must be \"has_normals\" or \"use_normals\"!!!", TCL_STATIC );
@


1.112
log
@Also eliminate trailing entrance hits
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.111 2003/04/01 14:05:58 jra Exp $ (BRL)";
d3792 3
a3794 3
	v0 = &vertices[old_faces[piece[0]*3]];
	v1 = &vertices[old_faces[piece[0]*3]+1];
	v2 = &vertices[old_faces[piece[0]*3]+2];
@


1.112.2.1
log
@updated for merging
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.117 2003/08/25 18:44:22 jra Exp $ (BRL)";
a41 3
#define GLUE(_a, _b)      _a ## _b
#define XGLUE(_a,_b)      GLUE(_a,_b)

a64 41

/* forward declarations needed for the included routines below */
HIDDEN int
rt_bot_makesegs(
		struct hit		*hits,
		int			nhits,
		struct soltab		*stp,
		struct xray		*rp,
		struct application	*ap,
		struct seg		*seghead,
		struct rt_piecestate	*psp);

static int
rt_bot_unoriented_segs(struct hit		*hits,
		  int			nhits,
		  struct soltab		*stp,
		  struct xray		*rp,
		  struct application	*ap,
		  struct seg		*seghead,
		  struct bot_specific	*bot);

int
rt_botface_w_normals(struct soltab	*stp,
		     struct bot_specific	*bot,
		     fastf_t		*ap,
		     fastf_t		*bp,
		     fastf_t		*cp,
		     fastf_t		*vertex_normals, /* array of nine values (three unit normals vectors) */
		     int			face_no,
		     const struct bn_tol	*tol);

#define TRI_TYPE	float
#define NORM_TYPE	float
#include "./g_bot_include.c"
#undef TRI_TYPE
#undef NORM_TYPE
#define TRI_TYPE	double
#define NORM_TYPE	fastf_t
#include "./g_bot_include.c"
#undef TRI_TYPE
#undef NORM_TYPE
d88 4
d93 31
a123 3
	if( bot->bot_flags & RT_BOT_USE_FLOATS ) {
		return rt_botface_w_normals_float( stp, bot, ap, bp, cp,
						   vertex_normals, face_no, tol );
d125 1
a125 2
		return rt_botface_w_normals_double( stp, bot, ap, bp, cp,
						   vertex_normals, face_no, tol );
d127 14
d165 40
a204 2
	if( bot->bot_flags & RT_BOT_USE_FLOATS ) {
		rt_bot_prep_pieces_float( bot, stp, ntri, tol );
d206 1
a206 1
		rt_bot_prep_pieces_double( bot, stp, ntri, tol );
d208 69
d301 6
a306 1

d312 78
a389 4
	if( bot_ip->bot_flags & RT_BOT_USE_FLOATS ) {
		return (rt_bot_prep_float( stp, bot_ip, rtip ));
	} else {
		return( rt_bot_prep_double( stp, bot_ip, rtip ));
d391 32
d443 37
a479 2
	if( bot->bot_flags & RT_BOT_USE_FLOATS ) {
		return (rt_bot_plate_segs_float( hits, nhits, stp, rp, ap, seghead, bot ));
d481 21
a501 1
		return (rt_bot_plate_segs_double( hits, nhits, stp, rp, ap, seghead, bot ));
d503 4
d518 89
a606 4
	if( bot->bot_flags & RT_BOT_USE_FLOATS ) {
		return (rt_bot_unoriented_segs_float( hits, nhits, stp, rp, ap, seghead, bot ));
	} else {
		return (rt_bot_unoriented_segs_double( hits, nhits, stp, rp, ap, seghead, bot ));
d608 3
d632 4
d642 341
a982 4
    if( bot->bot_flags & RT_BOT_USE_FLOATS ) {
	    return( rt_bot_makesegs_float( hits, nhits, stp, rp, ap, seghead, psp ) );
    } else {
	    return( rt_bot_makesegs_double( hits, nhits, stp, rp, ap, seghead, psp ) );
d984 17
d1026 13
d1040 59
a1098 4
	if( bot->bot_flags & RT_BOT_USE_FLOATS ) {
		return( rt_bot_shot_float( stp, rp, ap, seghead ) );
	} else {
		return( rt_bot_shot_double( stp, rp, ap, seghead ) );
d1100 8
d1131 2
d1134 2
d1137 4
d1143 1
d1146 2
d1149 4
d1154 1
a1154 2
	if( bot->bot_flags & RT_BOT_USE_FLOATS ) {
		return( rt_bot_piece_shot_float( psp, plp, dist_corr, rp, ap, seghead ) );
d1156 5
a1160 1
		return( rt_bot_piece_shot_double( psp, plp, dist_corr, rp, ap, seghead ) );
d1162 118
d1331 1
d1333 11
d1345 36
a1380 4
	if( bot->bot_flags & RT_BOT_USE_FLOATS ) {
		rt_bot_norm_float( bot, hitp, stp, rp );
	} else {
		rt_bot_norm_double( bot, hitp, stp, rp );
d1428 6
d1435 19
a1453 4
	if( bot->bot_flags & RT_BOT_USE_FLOATS ) {
		rt_bot_free_float( bot );
	} else {
		rt_bot_free_double( bot );
d1455 2
d2592 1
a2592 4
		if( bot->bot_flags & RT_BOT_USE_FLOATS ) {
			bu_vls_printf( &vls, " use_floats" );
		}
		bu_vls_printf( &vls, "} V {" );
d2596 1
a2596 1
		bu_vls_strcat( &vls, "} F {" );
d2600 1
a2600 1
		bu_vls_strcat( &vls, "}" );
d2606 1
a2606 1
			bu_vls_strcat( &vls, "} fm " );
d2614 1
a2614 1
			bu_vls_printf( &vls, "} fn {" );
d2618 1
a2618 1
			bu_vls_printf( &vls, "}" );
d2773 1
a2773 4
			if( bot->bot_flags & RT_BOT_USE_FLOATS ) {
				bu_vls_printf( &vls, " use_floats" );
			}
			bu_vls_printf( &vls, "}" );
a3458 2
				  } else if( !strcmp( str, "use_floats" ) ) {
					  bot->bot_flags |= RT_BOT_USE_FLOATS;
d3460 1
a3460 1
					  Tcl_SetResult( interp, "unrecognized flag (must be \"has_normals\", \"use_normals\", or \"use_floats\"!!!", TCL_STATIC );
d3792 3
a3794 3
	v0 = &vertices[piece[0]*3];
	v1 = &vertices[piece[1]*3];
	v2 = &vertices[piece[2]*3];
a4088 54
struct bot_edge {
  int v;
  int use_count;
  struct bot_edge *next;
};

static void
delete_edge( int v1, int v2, struct bot_edge **edges )
{
	struct bot_edge *edg, *prev=NULL;

	if( v1 < v2 ) {
		edg = edges[v1];
		while( edg ) {
			if( edg->v == v2 ) {
				edg->use_count--;
				if( edg->use_count < 1 ) {
					if( prev ) {
						prev->next = edg->next;
					} else {
						edges[v1] = edg->next;
					}
					edg->v = -1;
					edg->next = NULL;
					bu_free( (char *)edg, "bot_edge" );
					return;
				}
			}
			prev = edg;
			edg = edg->next;
		}
	} else {
		edg = edges[v2];
		while( edg ) {
			if( edg->v == v1 ) {
				edg->use_count--;
				if( edg->use_count < 1 ) {
					if( prev ) {
						prev->next = edg->next;
					} else {
						edges[v2] = edg->next;
					}
					edg->v = -1;
					edg->next = NULL;
					bu_free( (char *)edg, "bot_edge" );
					return;
				}
			}
			prev = edg;
			edg = edg->next;
		}
	}
}

d4099 1
a4099 1
decimate_edge( int v1, int v2, struct bot_edge **edges, int num_edges, int *faces, int num_faces, int face_del1, int face_del2 )
d4101 3
a4103 2
	int i;
	struct bot_edge *edg;
d4105 12
a4116 16
	/* first eliminate all the edges of the two deleted faces from the edge list */
	delete_edge( faces[face_del1*3 + 0], faces[face_del1*3 + 1], edges );
	delete_edge( faces[face_del1*3 + 1], faces[face_del1*3 + 2], edges );
	delete_edge( faces[face_del1*3 + 2], faces[face_del1*3 + 0], edges );
	delete_edge( faces[face_del2*3 + 0], faces[face_del2*3 + 1], edges );
	delete_edge( faces[face_del2*3 + 1], faces[face_del2*3 + 2], edges );
	delete_edge( faces[face_del2*3 + 2], faces[face_del2*3 + 0], edges );

	/* do the decimation */
	for( i=0 ; i<3 ; i++ ) {
		faces[face_del1*3 + i] = -1;
		faces[face_del2*3 + i] = -1;
	}
	for( i=0 ; i<num_faces*3 ; i++ ) {
		if( faces[i] == v1 ) {
			faces[i] = v2;
d4118 5
a4122 43
	}

	/* update the edge list */
	/* now move all the remaining edges at edges[v1] to somewhere else */
	edg = edges[v1];
	while( edg ) {
		struct bot_edge *ptr;
		struct bot_edge *next;

		next = edg->next;

		if( edg->v < v2 ) {
			ptr = edges[edg->v];
			while( ptr ) {
				if( ptr->v == v2 ) {
					ptr->use_count++;
					edg->v = -1;
					edg->next = NULL;
					bu_free( (char *)edg, "bot edge" );
					break;
				}
				ptr = ptr->next;
			}
			if( !ptr ) {
				edg->next = edges[edg->v];
				edges[edg->v] = edg;
				edg->v = v2;
			}
		} else {
			ptr = edges[v2];
			while( ptr ) {
				if( ptr->v == edg->v ) {
					ptr->use_count++;
					edg->v = -1;
					edg->next = NULL;
					bu_free( (char *)edg, "bot edge" );
					break;
				}
				ptr = ptr->next;
			}
			if( !ptr ) {
				edg->next = edges[v2];
				edges[v2] = edg;
a4124 2

		edg = next;
a4125 1
	edges[v1] = NULL;
d4127 2
a4128 3
	/* now change all remaining v1 references to v2 */
	for( i=0 ; i<num_edges ; i++ ) {
		struct bot_edge *next, *prev, *ptr;
d4130 7
a4136 5
		prev = NULL;
		edg = edges[i];
		/* look at edges starting from vertex #i */
		while( edg ) {
			next = edg->next;
d4138 2
a4139 10
			if( edg->v == v1 ) {
				/* this one is affected */
				edg->v = v2;	/* change v1 to v2 */
				if( v2 < i ) {
					/* disconnect this edge from list #i */
					if( prev ) {
						prev->next = next;
					} else {
						edges[i] = next;
					}
d4141 2
a4142 40
					/* this edge must move to the "v2" list */
					ptr = edges[v2];
					while( ptr ) {
						if( ptr->v == i ) {
							/* found another occurence of this edge
							 * increment use count
							 */
							ptr->use_count++;

							/* delete the original */
							edg->v = -1;
							edg->next = NULL;
							bu_free( (char *)edg, "bot edge" );
							break;
						}
						ptr = ptr->next;
					}
					if( !ptr ) {
						/* did not find another occurence, add to list */
						edg->next = edges[v2];
						edges[v2] = edg;
					}
					edg = next;
				} else {
					/* look for other occurences of this edge in this list
					 * if found, just increment use count
					 */
					ptr = edges[i];
					while( ptr ) {
						if( ptr->v == v2 && ptr != edg ) {
							/* found another occurence */
							/* increment use count */
							ptr->use_count++;

							/* disconnect original from list */
							if( prev ) {
								prev->next = next;
							} else {
								edges[i] = next;
							}
d4144 1
a4144 4
							/* free it */
							edg->v = -1;
							edg->next = NULL;
							bu_free( (char *)edg, "bot edge" );
d4146 6
a4151 8
							break;
						}
						ptr = ptr->next;
					}
					if( !ptr ) {
						prev = edg;
					}
					edg = next;
a4152 3
			} else {
				/* unaffected edge, just continue */
				edg = next;
d4155 9
d4166 6
a4171 1
	return 2;
a4193 1
		       struct bot_edge **edges,
a4195 2
		       int *face_del1,
		       int *face_del2,
a4201 1
	int num_edges=bot->num_vertices;
d4203 1
d4214 2
a4215 2
	*face_del1 = -1;
	*face_del2 = -1;
d4232 2
a4233 2
			if( *face_del1 > -1 ) {
				*face_del2 = i/3;
d4235 1
a4235 1
				*face_del1 = i/3;
d4250 1
a4250 1
	if( *face_del2 < 0 ) {
d4261 5
a4265 11
		struct bot_edge *edg;

		/* check if vertex v1 is on a free edge */
		for( i=0 ; i<num_edges ; i++ ) {
			edg = edges[i];
			while( edg ) {
				if( (i == v1 || edg->v == v1) && edg->use_count < 2 ) {
					return 0;
				}
				edg = edg->next;
			}
d4336 5
a4347 7
 *
 *	This and associated routines maintain a list of edges and their "use counts"
 *	A "free edge" is one with a use count of 1, most edges have a use count of 2
 *	When a use count reaches zero, the edge is removed from the list.
 *	The list is used to direct the edge decimation process and to avoid deforming the shape
 *	of a non-volume enclosing BOT by keeping track of use counts (and thereby free edges)
 *	If a free edge would be moved, that deciamtion is not performed.
a4364 1
	int done;
d4425 1
a4425 1
	      ptr = bu_calloc( 1, sizeof( struct bot_edge ), "edges[v1]" );
a4429 1
		ptr->use_count++;
d4432 1
a4432 1
	      ptr->next = bu_calloc( 1, sizeof( struct bot_edge ), "ptr->next" );
a4436 1
	    ptr->use_count++;
d4441 23
a4463 45
	/* the decimation loop */
	done = 0;
	while( !done ) {
		done = 1;

		/* visit each edge */
		for( i=0 ; i<bot->num_vertices ; i++ ) {
			struct bot_edge *ptr;
			int face_del1, face_del2;

			ptr = edges[i];
			while( ptr ) {

				/* try to avoid making 2D objects */
				if( face_count < 5 )
					break;

				/* check if this edge can be eliminated (try both directions) */
				if( edge_can_be_decimated( bot, faces, edges, i, ptr->v,
							   &face_del1, &face_del2,
							   max_chord_error,
							   max_normal_error,
							   min_edge_length_sq )) {
					face_count -= decimate_edge( i, ptr->v, edges, bot->num_vertices,
								     faces, bot->num_faces,
								     face_del1, face_del2 );
					edges_deleted++;
					done = 0;
					break;
				} else if( edge_can_be_decimated( bot, faces, edges, ptr->v, i,
								  &face_del1, &face_del2,
								  max_chord_error,
								  max_normal_error,
								  min_edge_length_sq )) {
					face_count -= decimate_edge( ptr->v, i, edges, bot->num_vertices,
								     faces, bot->num_faces,
								     face_del1, face_del2 );
					edges_deleted++;
					done = 0;
					break;
				} else {
					ptr = ptr->next;
				}
			}
		}
@


1.111
log
@rt_bot_makesegs() now eliminates leading exit hits (these hits are due to pieces methodology
not looking at the corresponding entrance pieces (correctly so))
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.110 2003/02/12 21:07:41 jra Exp $ (BRL)";
d874 5
@


1.110
log
@Fixed a bug in rt_smooth_bot() (was not mallocing enuf memory), and now refuses to
try to smooth unoriented BOTs unless they are RT_BOT_SOLID mode.
Plate-mode BOTs can now use vertex normals.
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.109 2003/02/12 15:59:44 jra Exp $ (BRL)";
d864 13
d887 1
@


1.109
log
@rt_bot_sort_faces() now handles vertex normals also
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.108 2003/01/31 13:37:27 jra Exp $ (BRL)";
d474 1
a474 1
	    segp->seg_out.hit_vpriv[X] = hits[i].hit_vpriv[X];
d487 1
a487 1
	    segp->seg_in.hit_vpriv[X] = hits[i].hit_vpriv[X];
d496 1
a496 1
	    segp->seg_out.hit_vpriv[X] = hits[i].hit_vpriv[X];
d1314 1
d1317 1
a1335 1

d1341 6
d1900 1
d2041 1
d4547 5
a4553 1

d4653 1
a4653 1
	bot->num_face_normals = bot->num_normals;
d4656 1
a4656 1
	bot->face_normals = (int *)bu_calloc( bot->num_face_normals, sizeof( int ), "bot->face_normals" );
@


1.108
log
@Added rt_smooth_bot().
rt_bot_plot_poly() now uses vertex normals if bot_flags say to use them.
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.107 2002/12/03 13:35:18 jra Exp $ (BRL)";
d3812 4
d3821 1
d3824 1
d3826 1
a3826 1
	char *vert_count;	/* an array used to hold the number of piece vertices that appear in each BOT face */
d3835 1
a3835 2
	faces_left = bot->num_faces;

d3839 1
a3839 1
	vert_count = (char *)bu_malloc( bot->num_faces * sizeof( char ), "vert_count" );
d3843 5
d3853 1
d3871 1
d3877 3
d3895 3
d3954 3
d3973 3
d4002 3
d4016 3
d4051 6
@


1.107
log
@Surface normal interpolation modified to eliminate producing normals that are impossible
(surface normals now clamped to 90 degrees from ray direction)
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.106 2002/11/29 03:13:20 jra Exp $ (BRL)";
d1140 3
d1507 20
a1526 4
		RT_ADD_VLIST( vhead, aa, BN_VLIST_POLY_MOVE );
		RT_ADD_VLIST( vhead, bb, BN_VLIST_POLY_DRAW );
		RT_ADD_VLIST( vhead, cc, BN_VLIST_POLY_DRAW );
		RT_ADD_VLIST( vhead, aa, BN_VLIST_POLY_END );
d3815 1
a3815 1
	int *new_faces;		/* the sorted list of faces to be attached to the BOT at teh end of this routine */
d3818 1
a3818 1
	int *piece;		/* a smalled face list, for just the faces in the current piece */
d4456 194
@


1.106
log
@Now honors USE_NORMALS flag
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.105 2002/11/27 14:29:40 jra Exp $ (BRL)";
d1315 1
d1319 2
d1336 15
@


1.105
log
@Removed some left-over debug prints
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.104 2002/11/27 13:42:56 jra Exp $ (BRL)";
d119 1
a119 1
	if( bot->bot_flags & RT_BOT_HAS_SURFACE_NORMALS ) {
d340 2
a341 2
		if( (bot_ip->bot_flags & RT_BOT_HAS_SURFACE_NORMALS) &&
		    (bot_ip->num_normals > 0) && (bot_ip->num_face_normals > tri_index) ) {
d1314 1
a1314 1
	if( bot->bot_flags && RT_BOT_HAS_SURFACE_NORMALS ) {
d2095 6
a2100 1
		bu_vls_strcat( str, "\twith surface normals\n" );
d2496 1
d2518 1
a2518 1
		bu_vls_printf( &vls, " mode %s orient %s V {",
d2520 8
d2699 12
d2850 1
d3381 19
@


1.104
log
@BOT primitives can now have vertex normals
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.103 2002/08/20 17:07:58 jra Exp $ (BRL)";
a1041 1
			    bu_log( "no hit on face %d (dN = %g)\n", trip->tri_surfno, VDOT(trip->tri_N, rp->r_dir )  );
a1203 1
			    bu_log( "no hit on face %d (dN = %g)\n", trip->tri_surfno, dN );
@


1.103
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.101 2002/05/29 15:13:16 jra Exp $ (BRL)";
d50 17
d79 1
a79 1
rt_botface(struct soltab	*stp,
d84 1
d91 1
d119 9
d135 1
a135 1
		VREVERSE( trip->tri_N, trip->tri_N )
d143 12
d316 1
a316 1
	bot->bot_errmode = bot_ip->error_mode;
d332 1
d340 33
a372 2
		if( rt_botface( stp, bot, p1, p2, p3, ntri, tol ) > 0 )
			ntri++;
d450 2
d462 1
d469 1
a469 1
	    segp->seg_in.hit_vpriv[Z] = 1;
d474 2
a475 3
	    segp->seg_out.hit_vpriv[X] = segp->seg_in.hit_vpriv[X]; /* ray dir dot normal */
	    segp->seg_out.hit_vpriv[Y] = bot->bot_orientation;
	    segp->seg_out.hit_vpriv[Z] = -1; /* a clue for rt_bot_norm that this is an exit */
d487 2
a488 3
	    segp->seg_in.hit_vpriv[X] = hits[i].hit_vpriv[X]; /* ray dir dot normal */
	    segp->seg_in.hit_vpriv[Y] = bot->bot_orientation;
	    segp->seg_in.hit_vpriv[Z] = 1;
d496 2
a497 3
	    segp->seg_out.hit_vpriv[X] = segp->seg_in.hit_vpriv[X]; /* ray dir dot normal */
	    segp->seg_out.hit_vpriv[Y] = bot->bot_orientation;
	    segp->seg_out.hit_vpriv[Z] = -1;
d528 2
d536 1
a536 1
	segp->seg_in.hit_vpriv[Z] = 1;
d540 1
a540 1
	segp->seg_out.hit_vpriv[Z] = -1;
d584 2
d591 2
a592 1
	segp->seg_in.hit_vpriv[Z] = 1;
d596 2
a597 1
	segp->seg_out.hit_vpriv[Z] = -1;
d645 2
d652 1
a652 1
		segp->seg_in.hit_vpriv[Z] = 1;
d656 1
a656 1
		segp->seg_out.hit_vpriv[Z] = -1;
d912 1
d939 1
d968 2
d972 3
a974 2
	segp->seg_in = hits[i];		/* struct copy */
	segp->seg_in.hit_vpriv[Z] = 1;
d976 2
a977 1
	segp->seg_out.hit_vpriv[Z] = -1;
a993 2
 *		hit_vpriv[Y] contains the BOT solid orientation
 *		hit_vpriv[Z] contains the +1 if the hit is a entrance, or -1 for an exit
d1016 1
a1016 1
		toldist = ap->a_rt_i->rti_tol.dist;
d1042 1
d1072 2
a1073 1
		hp->hit_vpriv[Y] = bot->bot_orientation;
d1136 1
a1136 1
		toldist = ap->a_rt_i->rti_tol.dist;
d1181 1
d1193 1
d1196 1
d1202 1
d1204 2
a1205 1
		    if( abs_dn < BOT_MIN_DN ) {
d1237 2
a1238 1
		    hp->hit_vpriv[Y] = bot->bot_orientation;
d1242 2
a1243 2
			bu_log("%s piece %d ... HIT %g\n",
			       stp->st_name, piecenum, hp->hit_dist);
a1311 1
	fastf_t dn=hitp->hit_vpriv[X]; /* ray dir dot normal */
d1316 18
a1333 15
	if( hitp->hit_vpriv[Y] == RT_BOT_UNORIENTED || bot->bot_mode == RT_BOT_PLATE || bot->bot_mode == RT_BOT_PLATE_NOCOS )
	{
		if( hitp->hit_vpriv[Z] < 0 ) /* this is an out hit */
		{
			if( dn < 0.0 )
				VREVERSE( hitp->hit_normal, trip->tri_N )
			else
				VMOVE( hitp->hit_normal, trip->tri_N )
		}
		else
		{
			if( dn > 0.0 )
				VREVERSE( hitp->hit_normal, trip->tri_N )
			else
				VMOVE( hitp->hit_normal, trip->tri_N )
d1335 1
a1336 2
	else
		VMOVE( hitp->hit_normal, trip->tri_N )
d1402 4
a1405 1
		if( ptr )
d1407 1
d1638 1
a1638 1
	bot_ip->error_mode = rp->bot.bot_err_mode;
d1706 5
d1743 1
a1743 1
	rec->bot.bot_err_mode = bot_ip->error_mode;
d1813 1
a1813 1
	ip->idb_ptr = bu_malloc( sizeof(struct rt_bot_internal), "rt_bot_internal");
d1825 1
a1825 1
	bip->error_mode = *cp++;
d1865 41
d1940 1
a1940 1
	ep->ext_nbytes = 3				/* orientation, mode, error_mode */
d1944 1
a1944 1
	if( bip->mode == RT_BOT_PLATE || bip->mode == RT_BOT_PLATE_NOCOS )
d1947 6
a1954 1

d1964 1
a1964 1
	*cp++ = bip->error_mode;
d2001 21
d2096 3
d2104 1
a2104 1
			int j;
d2108 26
a2133 6
				VSCALE( pt[j], &bot_ip->vertices[bot_ip->faces[i*3+j]*3], mm2local )
			sprintf( buf, "\tface %d: (%g %g %g), (%g %g %g), (%g %g %g)\n", i,
				V3ARGS( pt[0] ),
				V3ARGS( pt[1] ),
				V3ARGS( pt[2] ) );
			bu_vls_strcat( str, buf );
d2208 1
a2208 1
		botop = (struct rt_bot_internal *)bu_malloc( sizeof( struct rt_bot_internal ), "botop" );
d2212 1
a2212 1
		botop->error_mode = botip->error_mode;
d2215 9
a2223 4
		botop->vertices = (fastf_t *)bu_malloc( botip->num_vertices * 3 *
			sizeof( fastf_t ), "botop->vertices" );
		botop->faces = (int *)bu_malloc( botip->num_faces * 3 *
			sizeof( int ), "botop->faces" );
a2228 8
		for( i=0 ; i<botip->num_vertices ; i++ )
			VMOVE( &botop->vertices[i*3], &botip->vertices[i*3] )
		for( i=0 ; i<botip->num_faces ; i++ )
		{
			botop->faces[i*3] = botip->faces[i*3];
			botop->faces[i*3+1] = botip->faces[i*3+1];
			botop->faces[i*3+2] = botip->faces[i*3+2];
		}
d2234 7
d2255 5
d2483 4
d2489 2
d2532 11
d2547 59
a2605 1
		if( !strncmp( attr, "fm", 2 ) )
d2807 20
d2880 189
d3164 17
@


1.103.4.1
log
@sync to HEAD...
@
text
@d14 1
a14 1
 *	This software is Copyright (C) 1999-2004 by the United States Army.
d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/g_bot.c,v 1.123 2004/02/02 17:39:16 morrison Exp $ (BRL)";
a41 3
#define GLUE(_a, _b)      _a ## _b
#define XGLUE(_a,_b)      GLUE(_a,_b)

a49 67
#define RT_BOT_UNORIENTED_NORM( _hitp, _in_or_out)	{ \
	if( _in_or_out < 0 ) {	/* this is an exit */ \
		if( (_hitp)->hit_vpriv[X] < 0.0 ) { \
			VREVERSE( (_hitp)->hit_normal, trip->tri_N ); \
		} else { \
			VMOVE( (_hitp)->hit_normal, trip->tri_N ); \
		} \
	} else {	/* this is an entrance */ \
		if( (_hitp)->hit_vpriv[X] > 0.0 ) { \
			VREVERSE( (_hitp)->hit_normal, trip->tri_N ); \
		} else { \
			VMOVE( (_hitp)->hit_normal, trip->tri_N ); \
		} \
	} \
}

/* forward declarations needed for the included routines below */
HIDDEN int
rt_bot_makesegs(
		struct hit		*hits,
		int			nhits,
		struct soltab		*stp,
		struct xray		*rp,
		struct application	*ap,
		struct seg		*seghead,
		struct rt_piecestate	*psp);

static int
rt_bot_unoriented_segs(struct hit		*hits,
		  int			nhits,
		  struct soltab		*stp,
		  struct xray		*rp,
		  struct application	*ap,
		  struct seg		*seghead,
		  struct bot_specific	*bot);

int
rt_botface_w_normals(struct soltab	*stp,
		     struct bot_specific	*bot,
		     fastf_t		*ap,
		     fastf_t		*bp,
		     fastf_t		*cp,
		     fastf_t		*vertex_normals, /* array of nine values (three unit normals vectors) */
		     int			face_no,
		     const struct bn_tol	*tol);


#define TRI_TYPE	float
#define NORM_TYPE	signed char
#define NORMAL_SCALE	127.0
#define ONE_OVER_SCALE	(1.0/127.0)
#include "./g_bot_include.c"
#undef TRI_TYPE
#undef NORM_TYPE
#undef NORMAL_SCALE
#undef ONE_OVER_SCALE
#define TRI_TYPE	double
#define NORM_TYPE	fastf_t
#define NORMAL_SCALE	1.0
#define ONE_OVER_SCALE	1.0
#include "./g_bot_include.c"
#undef TRI_TYPE
#undef NORM_TYPE
#undef NORMAL_SCALE
#undef ONE_OVER_SCALE
					

a61 20
rt_botface_w_normals(struct soltab	*stp,
	   struct bot_specific	*bot,
	   fastf_t		*ap,
	   fastf_t		*bp,
	   fastf_t		*cp,
	   fastf_t		*vertex_normals, /* array of nine values (three unit normals vectors) */
	   int			face_no,
	   const struct bn_tol	*tol)
{

	if( bot->bot_flags & RT_BOT_USE_FLOATS ) {
		return rt_botface_w_normals_float( stp, bot, ap, bp, cp,
						   vertex_normals, face_no, tol );
	} else {
		return rt_botface_w_normals_double( stp, bot, ap, bp, cp,
						   vertex_normals, face_no, tol );
	}
}

int
d70 43
a112 1
	return( rt_botface_w_normals( stp, bot, ap, bp, cp, NULL, face_no, tol ) );
d125 63
a187 2
	if( bot->bot_flags & RT_BOT_USE_FLOATS ) {
		rt_bot_prep_pieces_float( bot, stp, ntri, tol );
d189 36
a224 1
		rt_bot_prep_pieces_double( bot, stp, ntri, tol );
d226 11
d261 6
a266 1

d272 79
a350 5
	if( bot_ip->bot_flags & RT_BOT_USE_FLOATS ) {
		return (rt_bot_prep_float( stp, bot_ip, rtip ));
	} else {
		return( rt_bot_prep_double( stp, bot_ip, rtip ));
	}
d371 35
a405 2
	if( bot->bot_flags & RT_BOT_USE_FLOATS ) {
		return (rt_bot_plate_segs_float( hits, nhits, stp, rp, ap, seghead, bot ));
d407 23
a429 1
		return (rt_bot_plate_segs_double( hits, nhits, stp, rp, ap, seghead, bot ));
d431 4
d446 83
a528 4
	if( bot->bot_flags & RT_BOT_USE_FLOATS ) {
		return (rt_bot_unoriented_segs_float( hits, nhits, stp, rp, ap, seghead, bot ));
	} else {
		return (rt_bot_unoriented_segs_double( hits, nhits, stp, rp, ap, seghead, bot ));
d530 3
d554 4
d564 24
a587 4
    if( bot->bot_flags & RT_BOT_USE_FLOATS ) {
	    return( rt_bot_makesegs_float( hits, nhits, stp, rp, ap, seghead, psp ) );
    } else {
	    return( rt_bot_makesegs_double( hits, nhits, stp, rp, ap, seghead, psp ) );
d589 307
d908 2
d923 39
d963 32
a994 4
	if( bot->bot_flags & RT_BOT_USE_FLOATS ) {
		return( rt_bot_shot_float( stp, rp, ap, seghead ) );
	} else {
		return( rt_bot_shot_double( stp, rp, ap, seghead ) );
d996 8
d1027 2
d1030 2
d1033 4
d1039 1
d1042 2
d1045 1
d1047 4
a1050 2
	if( bot->bot_flags & RT_BOT_USE_FLOATS ) {
		return( rt_bot_piece_shot_float( psp, plp, dist_corr, rp, ap, seghead ) );
d1052 1
a1052 1
		return( rt_bot_piece_shot_double( psp, plp, dist_corr, rp, ap, seghead ) );
d1054 114
d1219 2
d1223 18
a1240 4
	if( bot->bot_flags & RT_BOT_USE_FLOATS ) {
		rt_bot_norm_float( bot, hitp, stp, rp );
	} else {
		rt_bot_norm_double( bot, hitp, stp, rp );
d1242 2
d1290 6
d1297 15
a1311 4
	if( bot->bot_flags & RT_BOT_USE_FLOATS ) {
		rt_bot_free_float( bot );
	} else {
		rt_bot_free_double( bot );
d1313 2
d1391 4
a1394 20
		if( (bot_ip->bot_flags & RT_BOT_HAS_SURFACE_NORMALS) &&
		    (bot_ip->bot_flags & RT_BOT_USE_NORMALS) ) {
			vect_t na, nb, nc;

			VMOVE( na, &bot_ip->normals[bot_ip->face_normals[i*3+0]*3] );
			VMOVE( nb, &bot_ip->normals[bot_ip->face_normals[i*3+1]*3] );
			VMOVE( nc, &bot_ip->normals[bot_ip->face_normals[i*3+2]*3] );
			RT_ADD_VLIST( vhead, na, BN_VLIST_POLY_VERTNORM );
			RT_ADD_VLIST( vhead, aa, BN_VLIST_POLY_MOVE );
			RT_ADD_VLIST( vhead, nb, BN_VLIST_POLY_VERTNORM );
			RT_ADD_VLIST( vhead, bb, BN_VLIST_POLY_DRAW );
			RT_ADD_VLIST( vhead, nc, BN_VLIST_POLY_VERTNORM );
			RT_ADD_VLIST( vhead, cc, BN_VLIST_POLY_DRAW );
			RT_ADD_VLIST( vhead, aa, BN_VLIST_POLY_END );
		} else {
			RT_ADD_VLIST( vhead, aa, BN_VLIST_POLY_MOVE );
			RT_ADD_VLIST( vhead, bb, BN_VLIST_POLY_DRAW );
			RT_ADD_VLIST( vhead, cc, BN_VLIST_POLY_DRAW );
			RT_ADD_VLIST( vhead, aa, BN_VLIST_POLY_END );
		}
d1541 1
a1541 1
	bot_ip->bot_flags = 0;
a1608 5
	if( bot_ip->num_normals > 0 ) {
		bu_log( "BOT surface normals not supported in older database formats, normals not saved\n" );
		bu_log( "\tPlease update to current database format using \"dbupgrade\"\n" );
	}

d1641 1
a1641 1
	rec->bot.bot_err_mode = 0;
d1711 1
a1711 1
	ip->idb_ptr = bu_calloc( 1, sizeof(struct rt_bot_internal), "rt_bot_internal");
d1723 1
a1723 1
	bip->bot_flags = *cp++;
a1755 1
		while( *(cp++) != '\0' );
a1762 41
	if( bip->bot_flags & RT_BOT_HAS_SURFACE_NORMALS ) {
		vect_t tmp;

		bip->num_normals = bu_glong( cp );
		cp += SIZEOF_NETWORK_LONG;
		bip->num_face_normals = bu_glong( cp );
		cp += SIZEOF_NETWORK_LONG;

		if( bip->num_normals <= 0 ) {
			bip->normals = (fastf_t *)NULL;
		}
		if( bip->num_face_normals <= 0 ) {
			bip->face_normals = (int *)NULL;
		}
		if( bip->num_normals > 0 ) {
			bip->normals = (fastf_t *)bu_calloc( bip->num_normals * 3, sizeof( fastf_t ), "BOT normals" );

			for( i=0 ; i<bip->num_normals ; i++ ) {
				ntohd( (unsigned char *)tmp, (const unsigned char *)cp, 3 );
				cp += SIZEOF_NETWORK_DOUBLE * 3;
				MAT4X3VEC( &(bip->normals[i*3]), mat, tmp );
			}
		}
		if( bip->num_face_normals > 0 ) {
			bip->face_normals = (int *)bu_calloc( bip->num_face_normals * 3, sizeof( int ), "BOT face normals" );

			for( i=0 ; i<bip->num_face_normals ; i++ ) {
				bip->face_normals[i*3] = bu_glong( cp );
				cp += SIZEOF_NETWORK_LONG;
				bip->face_normals[i*3 + 1] = bu_glong( cp );
				cp += SIZEOF_NETWORK_LONG;
				bip->face_normals[i*3 + 2] = bu_glong( cp );
				cp += SIZEOF_NETWORK_LONG;
			}
		}
	} else {
		bip->normals = (fastf_t *)NULL;
		bip->face_normals = (int *)NULL;
		bip->num_normals = 0;
	}

d1797 1
a1797 1
	ep->ext_nbytes = 3				/* orientation, mode, bot_flags */
d1801 1
a1801 1
	if( bip->mode == RT_BOT_PLATE || bip->mode == RT_BOT_PLATE_NOCOS ) {
a1803 1
	}
d1805 1
a1805 4
	if( bip->bot_flags & RT_BOT_HAS_SURFACE_NORMALS ) {
		ep->ext_nbytes += SIZEOF_NETWORK_DOUBLE * bip->num_normals * 3 /* vertex normals */
			+ SIZEOF_NETWORK_LONG * (bip->num_face_normals * 3 + 2); /* indices into normals array, num_normals, num_face_normals */
	}
a1806 1
	ep->ext_buf = (genptr_t)bu_malloc( ep->ext_nbytes, "BOT external" );
d1816 1
a1816 1
	*cp++ = bip->bot_flags;
a1849 1
		cp++;
a1852 21
	if( bip->bot_flags & RT_BOT_HAS_SURFACE_NORMALS ) {
		(void)bu_plong( cp, bip->num_normals );
		cp += SIZEOF_NETWORK_LONG;
		(void)bu_plong( cp, bip->num_face_normals );
		cp += SIZEOF_NETWORK_LONG;
		if( bip->num_normals > 0 ) {
			htond( cp, (unsigned char*)bip->normals, bip->num_normals*3 );
			cp += SIZEOF_NETWORK_DOUBLE * 3 * bip->num_normals;
		}
		if( bip->num_face_normals > 0 ) {
			for( i=0 ; i<bip->num_face_normals ; i++ ) {
				(void)bu_plong( cp, bip->face_normals[i*3] );
				cp += SIZEOF_NETWORK_LONG;
				(void)bu_plong( cp, bip->face_normals[i*3 + 1] );
				cp += SIZEOF_NETWORK_LONG;
				(void)bu_plong( cp, bip->face_normals[i*3 + 2] );
				cp += SIZEOF_NETWORK_LONG;
			}
		}
	}

a1926 8
	if( (bot_ip->bot_flags & RT_BOT_HAS_SURFACE_NORMALS) && bot_ip->num_normals > 0 ) {
		bu_vls_strcat( str, "\twith surface normals" );
		if( bot_ip->bot_flags & RT_BOT_USE_NORMALS ) {
			bu_vls_strcat( str, " (they will be used)\n" );
		} else {
			bu_vls_strcat( str, " (they will be ignored)\n" );
		}
	}
d1932 1
a1932 1
			int j, k;
d1936 6
a1941 26
				VSCALE( pt[j], &bot_ip->vertices[bot_ip->faces[i*3+j]*3], mm2local );
			if( (bot_ip->bot_flags & RT_BOT_HAS_SURFACE_NORMALS) && bot_ip->num_normals > 0 ) {
				sprintf( buf, "\tface %d: (%g %g %g), (%g %g %g), (%g %g %g) normals: ", i,
					 V3ARGS( pt[0] ),
					 V3ARGS( pt[1] ),
					 V3ARGS( pt[2] ) );
				bu_vls_strcat( str, buf );
				for( k=0 ; k<3 ; k++ ) {
					int index;

					index = i*3 + k;
					if( bot_ip->face_normals[index] < 0 ||  bot_ip->face_normals[index] >= bot_ip->num_normals ) {
						bu_vls_strcat( str, "none " );
					} else {
						sprintf( buf, "(%g %g %g) ", V3ARGS( &bot_ip->normals[bot_ip->face_normals[index]*3]));
						bu_vls_strcat( str, buf );
					}
				}
				bu_vls_strcat( str, "\n" );
			} else {
				sprintf( buf, "\tface %d: (%g %g %g), (%g %g %g), (%g %g %g)\n", i,
					 V3ARGS( pt[0] ),
					 V3ARGS( pt[1] ),
					 V3ARGS( pt[2] ) );
				bu_vls_strcat( str, buf );
			}
d2016 1
a2016 1
		BU_GETSTRUCT( botop, rt_bot_internal );
d2020 1
a2020 1
		botop->bot_flags = botip->bot_flags;
d2023 4
a2026 9
		if( botop->num_vertices > 0 ) {
			botop->vertices = (fastf_t *)bu_malloc( botip->num_vertices * 3 *
								sizeof( fastf_t ), "botop->vertices" );
		}
		if( botop->num_faces > 0 ) {
			botop->faces = (int *)bu_malloc( botip->num_faces * 3 *
							 sizeof( int ), "botop->faces" );
			memcpy( botop->faces, botip->faces, botop->num_faces * 3 * sizeof( int ) );
		}
d2032 8
a2044 7

		if( botop->bot_flags & RT_BOT_HAS_SURFACE_NORMALS ) {
			botop->num_normals = botip->num_normals;
			botop->normals = (fastf_t *)bu_calloc( botop->num_normals * 3, sizeof( fastf_t ), "BOT normals" );
			botop->face_normals = (int *)bu_calloc( botop->num_faces * 3, sizeof( int ), "BOT face normals" );
			memcpy( botop->face_normals, botip->face_normals, botop->num_faces * 3 * sizeof( int ) );
		}
a2052 7
	if( ip != op ) {
		if( ip->idb_avs.magic == BU_AVS_MAGIC ) {
			bu_avs_init( &op->idb_avs, ip->idb_avs.count, "avs" );
			bu_avs_merge( &op->idb_avs, &ip->idb_avs );
		}
	}

d2059 1
a2059 6
	for( i=0 ; i<botip->num_normals ; i++ ) {
		MAT4X3VEC( pt, mat, &botip->normals[i*3] );
		VMOVE( &botop->normals[i*3], pt );
	}

	if( free && op != ip ) {
a2060 1
	}
a2281 4
 *	db get name N		get list of normals
 *	db get name N#		get coords for normal #
 *	db get name fn		get list indices into normal vectors for all faces
 *	db get name fn#		get list indices into normal vectors for face #
a2283 2
 *	db get name nn		get num_normals
 *	db get name nfn		get num_face_normals
a2285 1
 *	db get name flags	get BOT flags
d2307 1
a2307 1
		bu_vls_printf( &vls, " mode %s orient %s",
a2308 11
		bu_vls_printf( &vls, " flags {" );
		if( bot->bot_flags & RT_BOT_HAS_SURFACE_NORMALS ) {
			bu_vls_printf( &vls, " has_normals" );
		}
		if( bot->bot_flags & RT_BOT_USE_NORMALS ) {
			bu_vls_printf( &vls, " use_normals" );
		}
		if( bot->bot_flags & RT_BOT_USE_FLOATS ) {
			bu_vls_printf( &vls, " use_floats" );
		}
		bu_vls_printf( &vls, "} V {" );
d2312 1
a2312 1
		bu_vls_strcat( &vls, "} F {" );
d2316 1
a2316 1
		bu_vls_strcat( &vls, "}" );
d2322 1
a2322 1
			bu_vls_strcat( &vls, "} fm " );
a2324 11
		if( bot->bot_flags & RT_BOT_HAS_SURFACE_NORMALS ) {
			bu_vls_printf( &vls, " N {" );
			for( i=0 ; i<bot->num_normals ; i++ ) {
				bu_vls_printf( &vls, " { %.25G %.25G %.25G }", V3ARGS( &bot->normals[i*3] ) );
			}
			bu_vls_printf( &vls, "} fn {" );
			for( i=0 ; i<bot->num_faces ; i++ ) {
				bu_vls_printf( &vls, " { %d %d %d }", V3ARGS( &bot->face_normals[i*3] ) );
			}
			bu_vls_printf( &vls, "}" );
		}
d2329 1
a2329 59
		if( attr[0] == 'N' )
		{
			if( attr[1] == '\0' ) {
				if( !(bot->bot_flags & RT_BOT_HAS_SURFACE_NORMALS) || bot->num_normals < 1 ) {
					bu_vls_strcat( &vls, "{}" );
				} else {
					for( i=0 ; i<bot->num_normals ; i++ ) {
						bu_vls_printf( &vls, " { %.25G %.25G %.25G }", V3ARGS( &bot->normals[i*3] ) );
					}
				}
				status = TCL_OK;
			} else {
				i = atoi( &attr[1] );
				if( i < 0 || i >= bot->num_normals ) {
					bu_vls_strcat( &vls, "Specified normal index is out of range" );
					status = TCL_ERROR;
				} else {
					bu_vls_printf( &vls, "%.25G %.25G %.25G", V3ARGS( &bot->normals[i*3] ) );
					status = TCL_OK;
				}
			}
		}
		else if( !strncmp( attr, "fn", 2 ) )
		{
			if( attr[2] == '\0' ) {
				for( i=0 ; i<bot->num_faces ; i++ ) {
					bu_vls_printf( &vls, " { %d %d %d }", V3ARGS( &bot->face_normals[i*3] ) );
				}
				status = TCL_OK;
			} else {
				i = atoi( &attr[2] );
				if( i < 0 || i >= bot->num_faces ) {
					bu_vls_strcat( &vls, "Specified face index is out of range" );
					status = TCL_ERROR;
				} else {
					bu_vls_printf( &vls, "%d %d %d", V3ARGS( &bot->face_normals[i*3] ) );
					status = TCL_OK;
				}
			}
		}
		else if( !strcmp( attr, "nn" ) )
		{
			if( !(bot->bot_flags & RT_BOT_HAS_SURFACE_NORMALS) || bot->num_normals < 1 ) {
				bu_vls_strcat( &vls, "0" );
			} else {
				bu_vls_printf( &vls, "%d", bot->num_normals );
			}
			status = TCL_OK;
		}
		else if( !strcmp( attr, "nfn" ) )
		{
			if( !(bot->bot_flags & RT_BOT_HAS_SURFACE_NORMALS) || bot->num_face_normals < 1 ) {
				bu_vls_strcat( &vls, "0" );
			} else {
				bu_vls_printf( &vls, "%d", bot->num_face_normals );
			}
			status = TCL_OK;
		}
		else if( !strncmp( attr, "fm", 2 ) )
a2410 15
		else if( !strcmp( attr, "flags" ) )
		{
			bu_vls_printf( &vls, "{" );
			if( bot->bot_flags & RT_BOT_HAS_SURFACE_NORMALS ) {
				bu_vls_printf( &vls, " has_normals" );
			}
			if( bot->bot_flags & RT_BOT_USE_NORMALS ) {
				bu_vls_printf( &vls, " use_normals" );
			}
			if( bot->bot_flags & RT_BOT_USE_FLOATS ) {
				bu_vls_printf( &vls, " use_floats" );
			}
			bu_vls_printf( &vls, "}" );
			status = TCL_OK;
		}
a2530 21
/*
 *			R T _ B O T _ T C L A D J U S T
 *
 * Examples - 
 *	db adjust name fm		set los facemode bit vector
 *	db adjust name fm#		set los face mode of face # (center, append)
 *	db adjust name V		set coords for all vertices
 *	db adjust name V#		set coords for vertex #
 *	db adjust name F		set vertex indices for all faces
 *	db adjust name F#		set vertex indices for face #
 *	db adjust name T		set thickness for all faces
 *	db adjust name T#		set thickness for face #
 *	db adjust name N		set list of normals
 *	db adjust name N#		set coords for normal #
 *	db adjust name fn		set list indices into normal vectors for all faces
 *	db adjust name fn#		set list indices into normal vectors for face #
 *	db adjust name nn		set num_normals
 *	db adjust name mode		set mode (surf, volume, plate, plane_nocos)
 *	db adjust name orient		set orientation (no, rh, lh)
 *	db adjust name flags		set flags
 */
d2553 3
a2555 204
		if( !strncmp( argv[0], "fm", 2 ) )
		{
			if( argv[0][2] == '\0' )
			{
				if( bot->face_mode )
					bu_free( (char *)bot->face_mode, "bot->face_mode" );
				bot->face_mode = bu_hex_to_bitv( argv[1] );
			}
			else
			{
				i = atoi( &(argv[0][2]) );
				if( i < 0 || i >= bot->num_faces )
				{
					Tcl_SetResult( interp, "Face number out of range", TCL_STATIC );
					Tcl_DecrRefCount( list );
					return( TCL_ERROR );
				}

				if( isdigit( *argv[1] ) )
				  {
				    if( atoi( argv[1] ) == 0 )
					BU_BITCLR( bot->face_mode, i );
				    else
					BU_BITSET( bot->face_mode, i );
				  }
				else if( !strcmp( argv[1], "append" ) )
					BU_BITSET( bot->face_mode, i );
				else
				        BU_BITCLR( bot->face_mode, i );
			}
		}
		else if( !strcmp( argv[0], "nn" ) )
		{
			int new_num=0;
			int old_num = bot->num_normals;

			new_num = atoi( Tcl_GetStringFromObj( obj, NULL ) );
			if( new_num < 0 ) {
				Tcl_SetResult( interp, "Number of normals may not be less than 0", TCL_STATIC );
				Tcl_DecrRefCount( list );
				return( TCL_ERROR );
			}

			if( new_num == 0 ) {
				bot->num_normals = 0;
				if( bot->normals ) {
					bu_free( (char *)bot->normals, "BOT normals" );
				}
				bot->normals = (fastf_t *)NULL;
			} else {
				if( new_num != old_num ) {
					bot->num_normals = new_num;
					if( bot->normals ) {
						bot->normals = (fastf_t *)bu_realloc( (char *)bot->normals,
								     bot->num_normals * 3 * sizeof( fastf_t ), "BOT normals" );
					} else {
						bot->normals = (fastf_t *)bu_calloc( bot->num_normals * 3, sizeof( fastf_t ),
										     "BOT normals" );
					}

					if( new_num > old_num ) {
						for( i = old_num ; i<new_num ; i++ ) {
							VSET( &bot->normals[i*3], 0, 0, 0 );
						}
					}
				}
				
			}
			
		}
		else if( !strncmp( argv[0], "fn", 2 ) )
		{
		    char *f_str;

		    if( argv[0][2] == '\0' )
		      {
			(void)Tcl_ListObjGetElements( interp, list, &len, &obj_array );
			if( len != bot->num_faces || len <= 0 ) {
			    Tcl_SetResult( interp, "Must provide normals for all faces!!!", TCL_STATIC );
			    Tcl_DecrRefCount( list );
			    return( TCL_ERROR );
			}
			if( bot->face_normals )
				bu_free( (char *)bot->face_normals, "BOT face_normals" );
			bot->face_normals = (int *)bu_calloc( len*3, sizeof( int ), "BOT face_normals" );
			bot->num_face_normals = len;
			for( i=0 ; i<len ; i++ ) {
				f_str = Tcl_GetStringFromObj( obj_array[i], NULL );
				while( isspace( *f_str ) ) f_str++;

				if( *f_str == '\0' ) {
					Tcl_SetResult( interp, "incomplete list of face_normals", TCL_STATIC );
					Tcl_DecrRefCount( list );
					return( TCL_ERROR );
				}
				bot->face_normals[i*3] = atoi( f_str );
				f_str = bu_next_token( f_str );
				if( *f_str == '\0' ) {
					Tcl_SetResult( interp, "incomplete list of face_normals", TCL_STATIC );
					Tcl_DecrRefCount( list );
					return( TCL_ERROR );
				}
				bot->face_normals[i*3+1] = atoi( f_str );
				f_str = bu_next_token( f_str );
				if( *f_str == '\0' ) {
					Tcl_SetResult( interp, "incomplete list of face_normals", TCL_STATIC );
					Tcl_DecrRefCount( list );
					return( TCL_ERROR );
				}
				bot->face_normals[i*3+2] = atoi( f_str );
			}
			bot->bot_flags |= RT_BOT_HAS_SURFACE_NORMALS;
		      }
		    else
		      {
			i = atoi( &argv[0][2] );
			if( i < 0 || i >= bot->num_faces )
			  {
			    Tcl_SetResult( interp, "face_normal number out of range!!!", TCL_STATIC );
			    Tcl_DecrRefCount( list );
			    return( TCL_ERROR );
			  }
			f_str = Tcl_GetStringFromObj( list, NULL );
		      	while( isspace( *f_str ) ) f_str++;
			bot->face_normals[i*3] = atoi( f_str );
			f_str = bu_next_token( f_str );
			if( *f_str == '\0' )
			  {
			    Tcl_SetResult( interp, "incomplete vertex", TCL_STATIC );
			    Tcl_DecrRefCount( list );
			    return( TCL_ERROR );
			  }
			bot->face_normals[i*3+1] = atoi( f_str );
			f_str = bu_next_token( f_str );
			if( *f_str == '\0' )
			  {
			    Tcl_SetResult( interp, "incomplete vertex", TCL_STATIC );
			    Tcl_DecrRefCount( list );
			    return( TCL_ERROR );
			  }
			bot->face_normals[i*3+2] = atoi( f_str );
		      }
		}
		else if( argv[0][0] == 'N' )
		{
		  char *v_str;

		  if( argv[0][1] == '\0' )
		    {
		      (void)Tcl_ListObjGetElements( interp, list, &len, &obj_array );
		      if( len <= 0 )
			{
			  Tcl_SetResult( interp, "Must provide at least one normal!!!", TCL_STATIC );
			  Tcl_DecrRefCount( list );
			  return( TCL_ERROR );
			}
		      bot->num_normals = len;
		      if( bot->normals )
			      bu_free( (char *)bot->normals, "BOT normals" );
		      bot->normals = (fastf_t *)bu_calloc( len*3, sizeof( fastf_t ), "BOT normals" );
		      for( i=0 ; i<len ; i++ )
			{
			  v_str = Tcl_GetStringFromObj( obj_array[i], NULL );
			  while( isspace( *v_str ) ) v_str++;
			  if( *v_str == '\0' )
			    {
			      Tcl_SetResult( interp, "incomplete list of normals", TCL_STATIC );
			      Tcl_DecrRefCount( list );
			      return( TCL_ERROR );
			    }
			  bot->normals[i*3] = atof( v_str );
			  v_str = bu_next_token( v_str );
			  if( *v_str == '\0' )
			    {
			      Tcl_SetResult( interp, "incomplete list of normals", TCL_STATIC );
			      Tcl_DecrRefCount( list );
			      return( TCL_ERROR );
			    }
			  bot->normals[i*3+1] = atof( v_str );
			  v_str = bu_next_token( v_str );
			  if( *v_str == '\0' )
			    {
			      Tcl_SetResult( interp, "incomplete list of normals", TCL_STATIC );
			      Tcl_DecrRefCount( list );
			      return( TCL_ERROR );
			    }
			  bot->normals[i*3+2] = atof( v_str );
			  Tcl_DecrRefCount( obj_array[i] );
			}
		      bot->bot_flags |= RT_BOT_HAS_SURFACE_NORMALS;
		    } else {
		      i = atoi( &argv[0][1] );
		      if( i < 0 || i >= bot->num_normals )
			{
			  Tcl_SetResult( interp, "normal number out of range!!!", TCL_STATIC );
			  Tcl_DecrRefCount( list );
			  return( TCL_ERROR );
			}
		      v_str = Tcl_GetStringFromObj( list, NULL );
		      while( isspace( *v_str ) ) v_str++;

		      bot->normals[i*3] = atof( v_str );
		      v_str = bu_next_token( v_str );
		      if( *v_str == '\0' )
d2557 3
a2559 3
			  Tcl_SetResult( interp, "incomplete normal", TCL_STATIC );
			  Tcl_DecrRefCount( list );
			  return( TCL_ERROR );
d2561 1
a2561 3
		      bot->normals[i*3+1] = atof( v_str );
		      v_str = bu_next_token( v_str );
		      if( *v_str == '\0' )
d2563 19
a2581 3
			  Tcl_SetResult( interp, "incomplete normal", TCL_STATIC );
			  Tcl_DecrRefCount( list );
			  return( TCL_ERROR );
a2582 2
		      bot->normals[i*3+2] = atof( v_str );
		    }
a2678 17
			if( bot->bot_flags & RT_BOT_HAS_SURFACE_NORMALS ) {
				if( !bot->face_normals ) {
					bot->face_normals = (int *)bu_malloc( bot->num_faces * 3 * sizeof( int ),
									      "bot->face_normals" );
					bot->num_face_normals = bot->num_faces;
					for( i=0 ; i<bot->num_face_normals ; i++ ) {
						VSETALL( &bot->face_normals[i*3], -1 );
					}
				} else if( bot->num_face_normals < bot->num_faces ) {
					bot->face_normals = (int *)bu_realloc( bot->face_normals,
							     bot->num_faces * 3 * sizeof( int ), "bot->face_normals" );
					for( i=bot->num_face_normals ; i<bot->num_faces ; i++ ) {
						VSETALL( &bot->face_normals[i*3], -1 );
					}
					bot->num_face_normals = bot->num_faces;
				}
			}
a2854 21
		else if( !strcmp( argv[0], "flags" ) )
		  {
			  (void)Tcl_ListObjGetElements( interp, list, &len, &obj_array );
			  bot->bot_flags = 0;
			  for( i=0 ; i<len ; i++ ) {
				  char *str;

				  str = Tcl_GetStringFromObj( obj_array[i], NULL );
				  if( !strcmp( str, "has_normals" ) ) {
					  bot->bot_flags |= RT_BOT_HAS_SURFACE_NORMALS;
				  } else if( !strcmp( str, "use_normals" ) ) {
					  bot->bot_flags |= RT_BOT_USE_NORMALS;
				  } else if( !strcmp( str, "use_floats" ) ) {
					  bot->bot_flags |= RT_BOT_USE_FLOATS;
				  } else {
					  Tcl_SetResult( interp, "unrecognized flag (must be \"has_normals\", \"use_normals\", or \"use_floats\"!!!", TCL_STATIC );
					  Tcl_DecrRefCount( list );
					  return( TCL_ERROR );
				  }
			  }
		  }
d3181 3
a3183 3
	v0 = &vertices[piece[0]*3];
	v1 = &vertices[piece[1]*3];
	v2 = &vertices[piece[2]*3];
a3228 4

/*	This routine sorts the faces of the BOT such that when they are taken in groups of "tris_per_piece",
 *	each group (piece) will consist of adjacent faces
 */
d3232 1
a3232 1
	int *new_faces;		/* the sorted list of faces to be attached to the BOT at the end of this routine */
a3233 1
	int *new_norms = (int*)NULL;		/* the sorted list of vertex normals corrsponding to the "new_faces" list */
d3235 1
a3235 2
	int *piece;		/* a small face list, for just the faces in the current piece */
	int *piece_norms = (int*)NULL;	/* vertex normals for faces in the current piece */
d3237 1
a3237 1
	unsigned char *vert_count;	/* an array used to hold the number of piece vertices that appear in each BOT face */
d3246 2
a3247 1
	/* allocate memory for all the data */
d3251 2
a3252 2
	vert_count = (unsigned char *)bu_malloc( bot->num_faces * sizeof( unsigned char ), "vert_count" );
	piece_verts = (int *)bu_malloc( (tris_per_piece * 3 + 1) * sizeof( int ), "piece_verts" );
a3254 5
	if( bot->bot_flags & RT_BOT_HAS_SURFACE_NORMALS ) {
		new_norms = (int *)bu_calloc( bot->num_faces * 3, sizeof( int ), "new_norms" );
		piece_norms = (int *)bu_calloc( tris_per_piece * 3, sizeof( int ), "piece_norms" );
	}

a3259 1
	/* process until we have sorted all the faces */
d3266 1
a3266 1
		for( i=0 ; i<tris_per_piece*3+1 ; i++ ) {
a3276 1
			/* all faces used, we must be done */
a3281 3
		if( bot->bot_flags & RT_BOT_HAS_SURFACE_NORMALS ) {
			VMOVE( piece_norms, &bot->face_normals[cur_face*3] );
		}
a3296 3
				if( bot->bot_flags & RT_BOT_HAS_SURFACE_NORMALS ) {
					VMOVE( &new_norms[new_face_count*3], &piece_norms[j*3] );
				}
d3332 2
a3333 30
					}
				}

				if( vert_count[i] > 1 ) {
					/* add this face to the piece */
					VMOVE( &piece[piece_len*3], &old_faces[i*3] );
					if( bot->bot_flags & RT_BOT_HAS_SURFACE_NORMALS ) {
						VMOVE( &piece_norms[piece_len*3], &bot->face_normals[i*3] );
					}

					/* Add its vertices to the list of piece vertices */
					Add_unique_verts( piece_verts, &old_faces[i*3] );

					/* mark this face as used */
					VSETALL( &old_faces[i*3], -1 );

					/* update counts */
					piece_len++;
					faces_left--;
					vert_count[i] = 0;

					/* check if this piece is done */
					if( piece_len == tris_per_piece || faces_left == 0 ) {
						/* copy this piece to the "new_faces" list */
						for( j=0 ; j<piece_len ; j++ ) {
							VMOVE( &new_faces[new_face_count*3], &piece[j*3] );
							if( bot->bot_flags & RT_BOT_HAS_SURFACE_NORMALS ) {
								VMOVE( &new_norms[new_face_count*3], &piece_norms[j*3] );
							}
							new_face_count++;
a3334 4
						piece_len = 0;
						max_verts = 0;
						done_with_piece = 1;
						break;
a3336 3
				if( vert_count[i] > max_verts ) {
					max_verts = vert_count[i];
				}
d3342 1
a3342 1
			if( max_verts == 0 && !done_with_piece ) {
a3352 3
				if( bot->bot_flags & RT_BOT_HAS_SURFACE_NORMALS ) {
					VMOVE( &piece_norms[piece_len*3], &bot->face_normals[face_to_add*3] );
				}
a3368 3
						if( bot->bot_flags & RT_BOT_HAS_SURFACE_NORMALS ) {
							VMOVE( &new_norms[new_face_count*3], &piece_norms[j*3] );
						}
d3375 1
a3375 1
			} else if( max_verts == 1 && !done_with_piece ) {
d3378 1
a3378 1
			} else if( !done_with_piece ) {
d3387 1
a3387 1
			while( max_verts >= max_verts_min && !done_with_piece ) {
a3394 3
						if( bot->bot_flags & RT_BOT_HAS_SURFACE_NORMALS ) {
							VMOVE( &piece_norms[piece_len*3], &bot->face_normals[i*3] );
						}
a3405 3
								if( bot->bot_flags & RT_BOT_HAS_SURFACE_NORMALS ) {
									VMOVE( &new_norms[new_face_count*3], &piece_norms[j*3] );
								}
a3438 6
	if( bot->bot_flags & RT_BOT_HAS_SURFACE_NORMALS ) {
		bu_free( (char *)piece_norms, "piece_norms" );
		bu_free( (char *)bot->face_normals, "bot->face_normals" );
		bot->face_normals = new_norms;
	}

a3441 54
struct bot_edge {
  int v;
  int use_count;
  struct bot_edge *next;
};

static void
delete_edge( int v1, int v2, struct bot_edge **edges )
{
	struct bot_edge *edg, *prev=NULL;

	if( v1 < v2 ) {
		edg = edges[v1];
		while( edg ) {
			if( edg->v == v2 ) {
				edg->use_count--;
				if( edg->use_count < 1 ) {
					if( prev ) {
						prev->next = edg->next;
					} else {
						edges[v1] = edg->next;
					}
					edg->v = -1;
					edg->next = NULL;
					bu_free( (char *)edg, "bot_edge" );
					return;
				}
			}
			prev = edg;
			edg = edg->next;
		}
	} else {
		edg = edges[v2];
		while( edg ) {
			if( edg->v == v1 ) {
				edg->use_count--;
				if( edg->use_count < 1 ) {
					if( prev ) {
						prev->next = edg->next;
					} else {
						edges[v2] = edg->next;
					}
					edg->v = -1;
					edg->next = NULL;
					bu_free( (char *)edg, "bot_edge" );
					return;
				}
			}
			prev = edg;
			edg = edg->next;
		}
	}
}

d3452 1
a3452 1
decimate_edge( int v1, int v2, struct bot_edge **edges, int num_edges, int *faces, int num_faces, int face_del1, int face_del2 )
d3454 3
a3456 2
	int i;
	struct bot_edge *edg;
d3458 12
a3469 16
	/* first eliminate all the edges of the two deleted faces from the edge list */
	delete_edge( faces[face_del1*3 + 0], faces[face_del1*3 + 1], edges );
	delete_edge( faces[face_del1*3 + 1], faces[face_del1*3 + 2], edges );
	delete_edge( faces[face_del1*3 + 2], faces[face_del1*3 + 0], edges );
	delete_edge( faces[face_del2*3 + 0], faces[face_del2*3 + 1], edges );
	delete_edge( faces[face_del2*3 + 1], faces[face_del2*3 + 2], edges );
	delete_edge( faces[face_del2*3 + 2], faces[face_del2*3 + 0], edges );

	/* do the decimation */
	for( i=0 ; i<3 ; i++ ) {
		faces[face_del1*3 + i] = -1;
		faces[face_del2*3 + i] = -1;
	}
	for( i=0 ; i<num_faces*3 ; i++ ) {
		if( faces[i] == v1 ) {
			faces[i] = v2;
d3471 5
a3475 43
	}

	/* update the edge list */
	/* now move all the remaining edges at edges[v1] to somewhere else */
	edg = edges[v1];
	while( edg ) {
		struct bot_edge *ptr;
		struct bot_edge *next;

		next = edg->next;

		if( edg->v < v2 ) {
			ptr = edges[edg->v];
			while( ptr ) {
				if( ptr->v == v2 ) {
					ptr->use_count++;
					edg->v = -1;
					edg->next = NULL;
					bu_free( (char *)edg, "bot edge" );
					break;
				}
				ptr = ptr->next;
			}
			if( !ptr ) {
				edg->next = edges[edg->v];
				edges[edg->v] = edg;
				edg->v = v2;
			}
		} else {
			ptr = edges[v2];
			while( ptr ) {
				if( ptr->v == edg->v ) {
					ptr->use_count++;
					edg->v = -1;
					edg->next = NULL;
					bu_free( (char *)edg, "bot edge" );
					break;
				}
				ptr = ptr->next;
			}
			if( !ptr ) {
				edg->next = edges[v2];
				edges[v2] = edg;
a3477 2

		edg = next;
a3478 1
	edges[v1] = NULL;
d3480 2
a3481 3
	/* now change all remaining v1 references to v2 */
	for( i=0 ; i<num_edges ; i++ ) {
		struct bot_edge *next, *prev, *ptr;
d3483 7
a3489 5
		prev = NULL;
		edg = edges[i];
		/* look at edges starting from vertex #i */
		while( edg ) {
			next = edg->next;
d3491 2
a3492 10
			if( edg->v == v1 ) {
				/* this one is affected */
				edg->v = v2;	/* change v1 to v2 */
				if( v2 < i ) {
					/* disconnect this edge from list #i */
					if( prev ) {
						prev->next = next;
					} else {
						edges[i] = next;
					}
d3494 2
a3495 40
					/* this edge must move to the "v2" list */
					ptr = edges[v2];
					while( ptr ) {
						if( ptr->v == i ) {
							/* found another occurence of this edge
							 * increment use count
							 */
							ptr->use_count++;

							/* delete the original */
							edg->v = -1;
							edg->next = NULL;
							bu_free( (char *)edg, "bot edge" );
							break;
						}
						ptr = ptr->next;
					}
					if( !ptr ) {
						/* did not find another occurence, add to list */
						edg->next = edges[v2];
						edges[v2] = edg;
					}
					edg = next;
				} else {
					/* look for other occurences of this edge in this list
					 * if found, just increment use count
					 */
					ptr = edges[i];
					while( ptr ) {
						if( ptr->v == v2 && ptr != edg ) {
							/* found another occurence */
							/* increment use count */
							ptr->use_count++;

							/* disconnect original from list */
							if( prev ) {
								prev->next = next;
							} else {
								edges[i] = next;
							}
d3497 1
a3497 4
							/* free it */
							edg->v = -1;
							edg->next = NULL;
							bu_free( (char *)edg, "bot edge" );
d3499 6
a3504 8
							break;
						}
						ptr = ptr->next;
					}
					if( !ptr ) {
						prev = edg;
					}
					edg = next;
a3505 3
			} else {
				/* unaffected edge, just continue */
				edg = next;
d3508 14
d3524 1
a3524 1
	return 2;
a3546 1
		       struct bot_edge **edges,
a3548 2
		       int *face_del1,
		       int *face_del2,
a3554 1
	int num_edges=bot->num_vertices;
d3556 1
d3567 2
a3568 2
	*face_del1 = -1;
	*face_del2 = -1;
d3585 2
a3586 2
			if( *face_del1 > -1 ) {
				*face_del2 = i/3;
d3588 1
a3588 1
				*face_del1 = i/3;
d3603 1
a3603 1
	if( *face_del2 < 0 ) {
d3614 5
a3618 11
		struct bot_edge *edg;

		/* check if vertex v1 is on a free edge */
		for( i=0 ; i<num_edges ; i++ ) {
			edg = edges[i];
			while( edg ) {
				if( (i == v1 || edg->v == v1) && edg->use_count < 2 ) {
					return 0;
				}
				edg = edg->next;
			}
d3631 1
a3631 1
	if( max_chord_error > -1.0 || max_normal_error > -1.0 ) {
d3674 1
a3674 1
			if( max_normal_error > -1.0 && dot < max_normal_error ) {
d3680 1
a3680 1
			if( max_chord_error > -1.0 && dist > max_chord_error ) {
d3689 5
a3700 7
 *
 *	This and associated routines maintain a list of edges and their "use counts"
 *	A "free edge" is one with a use count of 1, most edges have a use count of 2
 *	When a use count reaches zero, the edge is removed from the list.
 *	The list is used to direct the edge decimation process and to avoid deforming the shape
 *	of a non-volume enclosing BOT by keeping track of use counts (and thereby free edges)
 *	If a free edge would be moved, that deciamtion is not performed.
a3717 1
	int done;
a3720 1
#if 0
d3725 1
a3725 1
#endif
d3727 1
a3727 1
	if( max_normal_error > -1.0 ) {
d3778 1
a3778 1
	      ptr = bu_calloc( 1, sizeof( struct bot_edge ), "edges[v1]" );
a3782 1
		ptr->use_count++;
d3785 1
a3785 1
	      ptr->next = bu_calloc( 1, sizeof( struct bot_edge ), "ptr->next" );
a3789 1
	    ptr->use_count++;
d3794 3
a3796 9
	/* the decimation loop */
	done = 0;
	while( !done ) {
		done = 1;

		/* visit each edge */
		for( i=0 ; i<bot->num_vertices ; i++ ) {
			struct bot_edge *ptr;
			int face_del1, face_del2;
d3798 2
a3799 2
			ptr = edges[i];
			while( ptr ) {
d3801 16
a3816 32
				/* try to avoid making 2D objects */
				if( face_count < 5 )
					break;

				/* check if this edge can be eliminated (try both directions) */
				if( edge_can_be_decimated( bot, faces, edges, i, ptr->v,
							   &face_del1, &face_del2,
							   max_chord_error,
							   max_normal_error,
							   min_edge_length_sq )) {
					face_count -= decimate_edge( i, ptr->v, edges, bot->num_vertices,
								     faces, bot->num_faces,
								     face_del1, face_del2 );
					edges_deleted++;
					done = 0;
					break;
				} else if( edge_can_be_decimated( bot, faces, edges, ptr->v, i,
								  &face_del1, &face_del2,
								  max_chord_error,
								  max_normal_error,
								  min_edge_length_sq )) {
					face_count -= decimate_edge( ptr->v, i, edges, bot->num_vertices,
								     faces, bot->num_faces,
								     face_del1, face_del2 );
					edges_deleted++;
					done = 0;
					break;
				} else {
					ptr = ptr->next;
				}
			}
		}
a3872 205
}

static int
smooth_bot_miss( struct application *ap )
{
	return 0;
}

static int
smooth_bot_hit( struct application *ap, struct partition *PartHeadp, struct seg *seg )
{
	struct partition *pp;
	struct soltab *stp;
	vect_t inormal, onormal;
	vect_t *normals=(vect_t *)ap->a_uptr;

	for( pp=PartHeadp->pt_forw ; pp != PartHeadp; pp = pp->pt_forw )  {
		stp = pp->pt_inseg->seg_stp;
		RT_HIT_NORMAL( inormal, pp->pt_inhit, stp, &(ap->a_ray), pp->pt_inflip );

		stp = pp->pt_outseg->seg_stp;
		RT_HIT_NORMAL( onormal, pp->pt_outhit, stp, &(ap->a_ray), pp->pt_outflip );
		if( pp->pt_inhit->hit_surfno == ap->a_user ) {
			VMOVE( normals[pp->pt_inhit->hit_surfno], inormal );
			break;
		}
		if( pp->pt_outhit->hit_surfno == ap->a_user ) {
			VMOVE( normals[pp->pt_outhit->hit_surfno], onormal );
			break;
		}
	}

	return 1;
}

int
rt_smooth_bot( struct rt_bot_internal *bot, char *bot_name, struct db_i *dbip, fastf_t norm_tol_angle )
{
	int vert_no;
	int i,j,k;
	struct rt_i *rtip;
	struct application ap;
	fastf_t normal_dot_tol=0.0;
	vect_t *normals;

	RT_BOT_CK_MAGIC( bot );

	if( norm_tol_angle < 0.0 || norm_tol_angle > M_PI ) {
		bu_log( "normal tolerance angle must be from 0 to Pi\n" );
		return( -2 );
	}

	if( (bot->orientation == RT_BOT_UNORIENTED) && (bot->mode != RT_BOT_SOLID) ) {
		bu_log( "Cannot smooth unoriented BOT primitives unless they are solid objects\n" );
		return( -3 );
	}

	normal_dot_tol = cos( norm_tol_angle );

	if( bot->normals ) {
		bu_free( (char *)bot->normals, "bot->normals" );
		bot->normals = NULL;
	}

	if( bot->face_normals ) {
		bu_free( (char *)bot->face_normals, "bot->face_normals" );
		bot->face_normals = NULL;
	}

	bot->bot_flags &= !(RT_BOT_HAS_SURFACE_NORMALS | RT_BOT_USE_NORMALS);
	bot->num_normals = 0;
	bot->num_face_normals = 0;

	/* build an array of surface normals */
	normals = (vect_t *)bu_calloc( bot->num_faces , sizeof( vect_t ), "normals" );

	if( bot->orientation == RT_BOT_UNORIENTED ) {
		/* need to do raytracing, do prepping */
		bzero( &ap, sizeof( struct application ) );
		rtip = rt_new_rti( dbip );
		ap.a_rt_i = rtip;
		ap.a_hit = smooth_bot_hit;
		ap.a_miss = smooth_bot_miss;
		ap.a_uptr = (genptr_t)normals;
		if( rt_gettree( rtip, bot_name ) ) {
			bu_log( "rt_gettree failed for %s\n", bot_name );
			return( -1 );
		}
		rt_prep( rtip );

		/* find the surface normal for each face */
		for( i=0 ; i<bot->num_faces ; i++ ) {
			vect_t a, b;
			vect_t inv_dir;

			VSUB2( a, &bot->vertices[bot->faces[i*3+1]*3], &bot->vertices[bot->faces[i*3]*3] );
			VSUB2( b, &bot->vertices[bot->faces[i*3+2]*3], &bot->vertices[bot->faces[i*3]*3] );
			VCROSS( ap.a_ray.r_dir, a, b );
			VUNITIZE( ap.a_ray.r_dir );

			/* calculate ray start point */
			VADD3( ap.a_ray.r_pt, &bot->vertices[bot->faces[i*3]*3],
			       &bot->vertices[bot->faces[i*3+1]*3],
			       &bot->vertices[bot->faces[i*3+2]*3] );
			VSCALE( ap.a_ray.r_pt, ap.a_ray.r_pt, 0.333333333333 );

			/* back out to bounding box limits */

			/* Compute the inverse of the direction cosines */
			if( ap.a_ray.r_dir[X] < -SQRT_SMALL_FASTF )  {
				inv_dir[X]=1.0/ap.a_ray.r_dir[X];
			} else if( ap.a_ray.r_dir[X] > SQRT_SMALL_FASTF )  {
				inv_dir[X]=1.0/ap.a_ray.r_dir[X];
			} else {
				ap.a_ray.r_dir[X] = 0.0;
				inv_dir[X] = INFINITY;
			}
			if( ap.a_ray.r_dir[Y] < -SQRT_SMALL_FASTF )  {
				inv_dir[Y]=1.0/ap.a_ray.r_dir[Y];
			} else if( ap.a_ray.r_dir[Y] > SQRT_SMALL_FASTF )  {
				inv_dir[Y]=1.0/ap.a_ray.r_dir[Y];
			} else {
				ap.a_ray.r_dir[Y] = 0.0;
				inv_dir[Y] = INFINITY;
			}
			if( ap.a_ray.r_dir[Z] < -SQRT_SMALL_FASTF )  {
				inv_dir[Z]=1.0/ap.a_ray.r_dir[Z];
			} else if( ap.a_ray.r_dir[Z] > SQRT_SMALL_FASTF )  {
				inv_dir[Z]=1.0/ap.a_ray.r_dir[Z];
			} else {
				ap.a_ray.r_dir[Z] = 0.0;
				inv_dir[Z] = INFINITY;
			}

			if( !rt_in_rpp( &ap.a_ray, inv_dir, rtip->mdl_min, rtip->mdl_max ) ) {
				/* ray missed!!! */
				bu_log( "ERROR: Ray missed target!!!!\n" );
			}
			VJOIN1( ap.a_ray.r_pt, ap.a_ray.r_pt, ap.a_ray.r_min, ap.a_ray.r_dir );
			ap.a_user = i;
			(void) rt_shootray( &ap );
		}
		rt_free_rti( rtip );
	} else {
		/* calculate normals */
		for( i=0 ; i<bot->num_faces ; i++ ) {
			vect_t a, b;

			VSUB2( a, &bot->vertices[bot->faces[i*3+1]*3], &bot->vertices[bot->faces[i*3]*3] );
			VSUB2( b, &bot->vertices[bot->faces[i*3+2]*3], &bot->vertices[bot->faces[i*3]*3] );
			VCROSS( normals[i], a, b );
			VUNITIZE( normals[i] );
			if( bot->orientation == RT_BOT_CW ) {
				VREVERSE( normals[i], normals[i] );
			}
		}
	}

	bot->num_normals = bot->num_faces * 3;
	bot->num_face_normals = bot->num_faces;

	bot->normals = (fastf_t *)bu_calloc( bot->num_normals * 3, sizeof( fastf_t ), "bot->normals" );
	bot->face_normals = (int *)bu_calloc( bot->num_face_normals * 3, sizeof( int ), "bot->face_normals" );

	/* process each face */
	for( i=0 ; i<bot->num_faces ; i++ ) {
		vect_t def_norm; /* default normal for this face */

		VMOVE( def_norm, normals[i] );

		/* process each vertex in his face */
		for( k=0 ; k<3 ; k++ ) {
			vect_t ave_norm;

			/* the actual vertex index */
			vert_no = bot->faces[i*3+k];
			VSETALL( ave_norm, 0.0 );

			/* find all the faces that use this vertex */
			   for( j=0 ; j<bot->num_faces*3 ; j++ ) {
				   if( bot->faces[j] == vert_no ) {
					   int the_face;

					   the_face = j / 3;

					   /* add all the normals that are within tolerance
					    * this also gets def_norm
					    */
					   if( VDOT( normals[the_face], def_norm ) >= normal_dot_tol ) {
						   VADD2( ave_norm, ave_norm, normals[the_face] );
					   }
				   }
			   }
			   VUNITIZE( ave_norm );
			   VMOVE( &bot->normals[(i*3+k)*3], ave_norm );
			   bot->face_normals[i*3+k] = i*3+k;
		}
	}

	bu_free( (char *)normals, "normals" );

	bot->bot_flags |= RT_BOT_HAS_SURFACE_NORMALS;
	bot->bot_flags |= RT_BOT_USE_NORMALS;

	return( 0 );
@


1.103.2.1
log
@Initial ANSIfication
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.103 2002/08/20 17:07:58 jra Exp $ (BRL)";
d255 4
a258 1
rt_bot_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
d357 2
a358 1
rt_bot_print(register const struct soltab *stp)
d544 8
a551 1
rt_bot_makesegs(struct hit *hits, int nhits, struct soltab *stp, struct xray *rp, struct application *ap, struct seg *seghead, struct rt_piecestate *psp)
d916 5
a920 1
rt_bot_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
d1019 7
a1025 1
rt_bot_piece_shot(struct rt_piecestate *psp, struct rt_piecelist *plp, double dist_corr, register struct xray *rp, struct application *ap, struct seg *seghead)
d1174 4
a1177 1
rt_bot_piece_hitsegs(struct rt_piecestate *psp, struct seg *seghead, struct application *ap)
d1198 6
a1203 6
rt_bot_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		  	       /* Number of ray/object pairs */
                  	    
d1214 4
a1217 1
rt_bot_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
d1252 4
a1255 1
rt_bot_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
d1273 5
a1277 1
rt_bot_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
d1285 2
a1286 1
rt_bot_free(register struct soltab *stp)
d1321 4
a1324 1
rt_bot_class(const struct soltab *stp, const fastf_t *min, const fastf_t *max, const struct bn_tol *tol)
d1333 5
a1337 1
rt_bot_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d1361 5
a1365 1
rt_bot_plot_poly(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d1408 6
a1413 1
rt_bot_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d1510 5
a1514 1
rt_bot_import(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d1590 5
a1594 1
rt_bot_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d1695 5
a1699 1
rt_bot_import5(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d1770 5
a1774 1
rt_bot_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d1873 5
a1877 1
rt_bot_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
d1965 2
a1966 1
rt_bot_ifree(struct rt_db_internal *ip)
d1989 5
a1993 1
rt_bot_tnurb(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct bn_tol *tol)
d1999 5
a2003 1
rt_bot_xform(struct rt_db_internal *op, const fastf_t *mat, struct rt_db_internal *ip, const int free, struct db_i *dbip)
d2288 4
a2291 1
rt_bot_tclget(Tcl_Interp *interp, const struct rt_db_internal *intern, const char *attr)
d2532 5
a2536 1
rt_bot_tcladjust(Tcl_Interp *interp, struct rt_db_internal *intern, int argc, char **argv)
@


1.103.2.2
log
@sync branch with HEAD
@
text
@d14 1
a14 1
 *	This software is Copyright (C) 1999-2004 by the United States Army.
d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header$ (BRL)";
a41 3
#define GLUE(_a, _b)      _a ## _b
#define XGLUE(_a,_b)      GLUE(_a,_b)

a49 67
#define RT_BOT_UNORIENTED_NORM( _hitp, _in_or_out)	{ \
	if( _in_or_out < 0 ) {	/* this is an exit */ \
		if( (_hitp)->hit_vpriv[X] < 0.0 ) { \
			VREVERSE( (_hitp)->hit_normal, trip->tri_N ); \
		} else { \
			VMOVE( (_hitp)->hit_normal, trip->tri_N ); \
		} \
	} else {	/* this is an entrance */ \
		if( (_hitp)->hit_vpriv[X] > 0.0 ) { \
			VREVERSE( (_hitp)->hit_normal, trip->tri_N ); \
		} else { \
			VMOVE( (_hitp)->hit_normal, trip->tri_N ); \
		} \
	} \
}

/* forward declarations needed for the included routines below */
HIDDEN int
rt_bot_makesegs(
		struct hit		*hits,
		int			nhits,
		struct soltab		*stp,
		struct xray		*rp,
		struct application	*ap,
		struct seg		*seghead,
		struct rt_piecestate	*psp);

static int
rt_bot_unoriented_segs(struct hit		*hits,
		  int			nhits,
		  struct soltab		*stp,
		  struct xray		*rp,
		  struct application	*ap,
		  struct seg		*seghead,
		  struct bot_specific	*bot);

int
rt_botface_w_normals(struct soltab	*stp,
		     struct bot_specific	*bot,
		     fastf_t		*ap,
		     fastf_t		*bp,
		     fastf_t		*cp,
		     fastf_t		*vertex_normals, /* array of nine values (three unit normals vectors) */
		     int			face_no,
		     const struct bn_tol	*tol);


#define TRI_TYPE	float
#define NORM_TYPE	signed char
#define NORMAL_SCALE	127.0
#define ONE_OVER_SCALE	(1.0/127.0)
#include "./g_bot_include.c"
#undef TRI_TYPE
#undef NORM_TYPE
#undef NORMAL_SCALE
#undef ONE_OVER_SCALE
#define TRI_TYPE	double
#define NORM_TYPE	fastf_t
#define NORMAL_SCALE	1.0
#define ONE_OVER_SCALE	1.0
#include "./g_bot_include.c"
#undef TRI_TYPE
#undef NORM_TYPE
#undef NORMAL_SCALE
#undef ONE_OVER_SCALE
					

a61 20
rt_botface_w_normals(struct soltab	*stp,
	   struct bot_specific	*bot,
	   fastf_t		*ap,
	   fastf_t		*bp,
	   fastf_t		*cp,
	   fastf_t		*vertex_normals, /* array of nine values (three unit normals vectors) */
	   int			face_no,
	   const struct bn_tol	*tol)
{

	if( bot->bot_flags & RT_BOT_USE_FLOATS ) {
		return rt_botface_w_normals_float( stp, bot, ap, bp, cp,
						   vertex_normals, face_no, tol );
	} else {
		return rt_botface_w_normals_double( stp, bot, ap, bp, cp,
						   vertex_normals, face_no, tol );
	}
}

int
d70 43
a112 1
	return( rt_botface_w_normals( stp, bot, ap, bp, cp, NULL, face_no, tol ) );
d125 63
a187 2
	if( bot->bot_flags & RT_BOT_USE_FLOATS ) {
		rt_bot_prep_pieces_float( bot, stp, ntri, tol );
d189 36
a224 1
		rt_bot_prep_pieces_double( bot, stp, ntri, tol );
d226 11
d258 6
a263 1

d269 79
a347 5
	if( bot_ip->bot_flags & RT_BOT_USE_FLOATS ) {
		return (rt_bot_prep_float( stp, bot_ip, rtip ));
	} else {
		return( rt_bot_prep_double( stp, bot_ip, rtip ));
	}
d367 35
a401 2
	if( bot->bot_flags & RT_BOT_USE_FLOATS ) {
		return (rt_bot_plate_segs_float( hits, nhits, stp, rp, ap, seghead, bot ));
d403 23
a425 1
		return (rt_bot_plate_segs_double( hits, nhits, stp, rp, ap, seghead, bot ));
d427 4
d442 83
a524 4
	if( bot->bot_flags & RT_BOT_USE_FLOATS ) {
		return (rt_bot_unoriented_segs_float( hits, nhits, stp, rp, ap, seghead, bot ));
	} else {
		return (rt_bot_unoriented_segs_double( hits, nhits, stp, rp, ap, seghead, bot ));
d526 3
d543 4
d553 24
a576 4
    if( bot->bot_flags & RT_BOT_USE_FLOATS ) {
	    return( rt_bot_makesegs_float( hits, nhits, stp, rp, ap, seghead, psp ) );
    } else {
	    return( rt_bot_makesegs_double( hits, nhits, stp, rp, ap, seghead, psp ) );
d578 307
d897 2
d908 39
d948 32
a979 4
	if( bot->bot_flags & RT_BOT_USE_FLOATS ) {
		return( rt_bot_shot_float( stp, rp, ap, seghead ) );
	} else {
		return( rt_bot_shot_double( stp, rp, ap, seghead ) );
d981 8
d1006 2
d1009 2
d1012 4
d1018 1
d1021 2
d1024 1
d1026 4
a1029 2
	if( bot->bot_flags & RT_BOT_USE_FLOATS ) {
		return( rt_bot_piece_shot_float( psp, plp, dist_corr, rp, ap, seghead ) );
d1031 1
a1031 1
		return( rt_bot_piece_shot_double( psp, plp, dist_corr, rp, ap, seghead ) );
d1033 114
d1192 2
d1196 18
a1213 4
	if( bot->bot_flags & RT_BOT_USE_FLOATS ) {
		rt_bot_norm_float( bot, hitp, stp, rp );
	} else {
		rt_bot_norm_double( bot, hitp, stp, rp );
d1215 2
d1255 6
d1262 15
a1276 4
	if( bot->bot_flags & RT_BOT_USE_FLOATS ) {
		rt_bot_free_float( bot );
	} else {
		rt_bot_free_double( bot );
d1278 2
d1345 4
a1348 20
		if( (bot_ip->bot_flags & RT_BOT_HAS_SURFACE_NORMALS) &&
		    (bot_ip->bot_flags & RT_BOT_USE_NORMALS) ) {
			vect_t na, nb, nc;

			VMOVE( na, &bot_ip->normals[bot_ip->face_normals[i*3+0]*3] );
			VMOVE( nb, &bot_ip->normals[bot_ip->face_normals[i*3+1]*3] );
			VMOVE( nc, &bot_ip->normals[bot_ip->face_normals[i*3+2]*3] );
			RT_ADD_VLIST( vhead, na, BN_VLIST_POLY_VERTNORM );
			RT_ADD_VLIST( vhead, aa, BN_VLIST_POLY_MOVE );
			RT_ADD_VLIST( vhead, nb, BN_VLIST_POLY_VERTNORM );
			RT_ADD_VLIST( vhead, bb, BN_VLIST_POLY_DRAW );
			RT_ADD_VLIST( vhead, nc, BN_VLIST_POLY_VERTNORM );
			RT_ADD_VLIST( vhead, cc, BN_VLIST_POLY_DRAW );
			RT_ADD_VLIST( vhead, aa, BN_VLIST_POLY_END );
		} else {
			RT_ADD_VLIST( vhead, aa, BN_VLIST_POLY_MOVE );
			RT_ADD_VLIST( vhead, bb, BN_VLIST_POLY_DRAW );
			RT_ADD_VLIST( vhead, cc, BN_VLIST_POLY_DRAW );
			RT_ADD_VLIST( vhead, aa, BN_VLIST_POLY_END );
		}
d1486 1
a1486 1
	bot_ip->bot_flags = 0;
a1549 5
	if( bot_ip->num_normals > 0 ) {
		bu_log( "BOT surface normals not supported in older database formats, normals not saved\n" );
		bu_log( "\tPlease update to current database format using \"dbupgrade\"\n" );
	}

d1582 1
a1582 1
	rec->bot.bot_err_mode = 0;
d1648 1
a1648 1
	ip->idb_ptr = bu_calloc( 1, sizeof(struct rt_bot_internal), "rt_bot_internal");
d1660 1
a1660 1
	bip->bot_flags = *cp++;
a1692 1
		while( *(cp++) != '\0' );
a1699 41
	if( bip->bot_flags & RT_BOT_HAS_SURFACE_NORMALS ) {
		vect_t tmp;

		bip->num_normals = bu_glong( cp );
		cp += SIZEOF_NETWORK_LONG;
		bip->num_face_normals = bu_glong( cp );
		cp += SIZEOF_NETWORK_LONG;

		if( bip->num_normals <= 0 ) {
			bip->normals = (fastf_t *)NULL;
		}
		if( bip->num_face_normals <= 0 ) {
			bip->face_normals = (int *)NULL;
		}
		if( bip->num_normals > 0 ) {
			bip->normals = (fastf_t *)bu_calloc( bip->num_normals * 3, sizeof( fastf_t ), "BOT normals" );

			for( i=0 ; i<bip->num_normals ; i++ ) {
				ntohd( (unsigned char *)tmp, (const unsigned char *)cp, 3 );
				cp += SIZEOF_NETWORK_DOUBLE * 3;
				MAT4X3VEC( &(bip->normals[i*3]), mat, tmp );
			}
		}
		if( bip->num_face_normals > 0 ) {
			bip->face_normals = (int *)bu_calloc( bip->num_face_normals * 3, sizeof( int ), "BOT face normals" );

			for( i=0 ; i<bip->num_face_normals ; i++ ) {
				bip->face_normals[i*3] = bu_glong( cp );
				cp += SIZEOF_NETWORK_LONG;
				bip->face_normals[i*3 + 1] = bu_glong( cp );
				cp += SIZEOF_NETWORK_LONG;
				bip->face_normals[i*3 + 2] = bu_glong( cp );
				cp += SIZEOF_NETWORK_LONG;
			}
		}
	} else {
		bip->normals = (fastf_t *)NULL;
		bip->face_normals = (int *)NULL;
		bip->num_normals = 0;
	}

d1730 1
a1730 1
	ep->ext_nbytes = 3				/* orientation, mode, bot_flags */
d1734 1
a1734 1
	if( bip->mode == RT_BOT_PLATE || bip->mode == RT_BOT_PLATE_NOCOS ) {
a1736 1
	}
d1738 1
a1738 4
	if( bip->bot_flags & RT_BOT_HAS_SURFACE_NORMALS ) {
		ep->ext_nbytes += SIZEOF_NETWORK_DOUBLE * bip->num_normals * 3 /* vertex normals */
			+ SIZEOF_NETWORK_LONG * (bip->num_face_normals * 3 + 2); /* indices into normals array, num_normals, num_face_normals */
	}
a1739 1
	ep->ext_buf = (genptr_t)bu_malloc( ep->ext_nbytes, "BOT external" );
d1749 1
a1749 1
	*cp++ = bip->bot_flags;
a1782 1
		cp++;
a1785 21
	if( bip->bot_flags & RT_BOT_HAS_SURFACE_NORMALS ) {
		(void)bu_plong( cp, bip->num_normals );
		cp += SIZEOF_NETWORK_LONG;
		(void)bu_plong( cp, bip->num_face_normals );
		cp += SIZEOF_NETWORK_LONG;
		if( bip->num_normals > 0 ) {
			htond( cp, (unsigned char*)bip->normals, bip->num_normals*3 );
			cp += SIZEOF_NETWORK_DOUBLE * 3 * bip->num_normals;
		}
		if( bip->num_face_normals > 0 ) {
			for( i=0 ; i<bip->num_face_normals ; i++ ) {
				(void)bu_plong( cp, bip->face_normals[i*3] );
				cp += SIZEOF_NETWORK_LONG;
				(void)bu_plong( cp, bip->face_normals[i*3 + 1] );
				cp += SIZEOF_NETWORK_LONG;
				(void)bu_plong( cp, bip->face_normals[i*3 + 2] );
				cp += SIZEOF_NETWORK_LONG;
			}
		}
	}

a1855 8
	if( (bot_ip->bot_flags & RT_BOT_HAS_SURFACE_NORMALS) && bot_ip->num_normals > 0 ) {
		bu_vls_strcat( str, "\twith surface normals" );
		if( bot_ip->bot_flags & RT_BOT_USE_NORMALS ) {
			bu_vls_strcat( str, " (they will be used)\n" );
		} else {
			bu_vls_strcat( str, " (they will be ignored)\n" );
		}
	}
d1861 1
a1861 1
			int j, k;
d1865 6
a1870 26
				VSCALE( pt[j], &bot_ip->vertices[bot_ip->faces[i*3+j]*3], mm2local );
			if( (bot_ip->bot_flags & RT_BOT_HAS_SURFACE_NORMALS) && bot_ip->num_normals > 0 ) {
				sprintf( buf, "\tface %d: (%g %g %g), (%g %g %g), (%g %g %g) normals: ", i,
					 V3ARGS( pt[0] ),
					 V3ARGS( pt[1] ),
					 V3ARGS( pt[2] ) );
				bu_vls_strcat( str, buf );
				for( k=0 ; k<3 ; k++ ) {
					int index;

					index = i*3 + k;
					if( bot_ip->face_normals[index] < 0 ||  bot_ip->face_normals[index] >= bot_ip->num_normals ) {
						bu_vls_strcat( str, "none " );
					} else {
						sprintf( buf, "(%g %g %g) ", V3ARGS( &bot_ip->normals[bot_ip->face_normals[index]*3]));
						bu_vls_strcat( str, buf );
					}
				}
				bu_vls_strcat( str, "\n" );
			} else {
				sprintf( buf, "\tface %d: (%g %g %g), (%g %g %g), (%g %g %g)\n", i,
					 V3ARGS( pt[0] ),
					 V3ARGS( pt[1] ),
					 V3ARGS( pt[2] ) );
				bu_vls_strcat( str, buf );
			}
d1936 1
a1936 1
		BU_GETSTRUCT( botop, rt_bot_internal );
d1940 1
a1940 1
		botop->bot_flags = botip->bot_flags;
d1943 4
a1946 9
		if( botop->num_vertices > 0 ) {
			botop->vertices = (fastf_t *)bu_malloc( botip->num_vertices * 3 *
								sizeof( fastf_t ), "botop->vertices" );
		}
		if( botop->num_faces > 0 ) {
			botop->faces = (int *)bu_malloc( botip->num_faces * 3 *
							 sizeof( int ), "botop->faces" );
			memcpy( botop->faces, botip->faces, botop->num_faces * 3 * sizeof( int ) );
		}
d1952 8
a1964 7

		if( botop->bot_flags & RT_BOT_HAS_SURFACE_NORMALS ) {
			botop->num_normals = botip->num_normals;
			botop->normals = (fastf_t *)bu_calloc( botop->num_normals * 3, sizeof( fastf_t ), "BOT normals" );
			botop->face_normals = (int *)bu_calloc( botop->num_faces * 3, sizeof( int ), "BOT face normals" );
			memcpy( botop->face_normals, botip->face_normals, botop->num_faces * 3 * sizeof( int ) );
		}
a1972 7
	if( ip != op ) {
		if( ip->idb_avs.magic == BU_AVS_MAGIC ) {
			bu_avs_init( &op->idb_avs, ip->idb_avs.count, "avs" );
			bu_avs_merge( &op->idb_avs, &ip->idb_avs );
		}
	}

d1979 1
a1979 6
	for( i=0 ; i<botip->num_normals ; i++ ) {
		MAT4X3VEC( pt, mat, &botip->normals[i*3] );
		VMOVE( &botop->normals[i*3], pt );
	}

	if( free && op != ip ) {
a1980 1
	}
a2201 4
 *	db get name N		get list of normals
 *	db get name N#		get coords for normal #
 *	db get name fn		get list indices into normal vectors for all faces
 *	db get name fn#		get list indices into normal vectors for face #
a2203 2
 *	db get name nn		get num_normals
 *	db get name nfn		get num_face_normals
a2205 1
 *	db get name flags	get BOT flags
d2224 1
a2224 1
		bu_vls_printf( &vls, " mode %s orient %s",
a2225 11
		bu_vls_printf( &vls, " flags {" );
		if( bot->bot_flags & RT_BOT_HAS_SURFACE_NORMALS ) {
			bu_vls_printf( &vls, " has_normals" );
		}
		if( bot->bot_flags & RT_BOT_USE_NORMALS ) {
			bu_vls_printf( &vls, " use_normals" );
		}
		if( bot->bot_flags & RT_BOT_USE_FLOATS ) {
			bu_vls_printf( &vls, " use_floats" );
		}
		bu_vls_printf( &vls, "} V {" );
d2229 1
a2229 1
		bu_vls_strcat( &vls, "} F {" );
d2233 1
a2233 1
		bu_vls_strcat( &vls, "}" );
d2239 1
a2239 1
			bu_vls_strcat( &vls, "} fm " );
a2241 11
		if( bot->bot_flags & RT_BOT_HAS_SURFACE_NORMALS ) {
			bu_vls_printf( &vls, " N {" );
			for( i=0 ; i<bot->num_normals ; i++ ) {
				bu_vls_printf( &vls, " { %.25G %.25G %.25G }", V3ARGS( &bot->normals[i*3] ) );
			}
			bu_vls_printf( &vls, "} fn {" );
			for( i=0 ; i<bot->num_faces ; i++ ) {
				bu_vls_printf( &vls, " { %d %d %d }", V3ARGS( &bot->face_normals[i*3] ) );
			}
			bu_vls_printf( &vls, "}" );
		}
d2246 1
a2246 59
		if( attr[0] == 'N' )
		{
			if( attr[1] == '\0' ) {
				if( !(bot->bot_flags & RT_BOT_HAS_SURFACE_NORMALS) || bot->num_normals < 1 ) {
					bu_vls_strcat( &vls, "{}" );
				} else {
					for( i=0 ; i<bot->num_normals ; i++ ) {
						bu_vls_printf( &vls, " { %.25G %.25G %.25G }", V3ARGS( &bot->normals[i*3] ) );
					}
				}
				status = TCL_OK;
			} else {
				i = atoi( &attr[1] );
				if( i < 0 || i >= bot->num_normals ) {
					bu_vls_strcat( &vls, "Specified normal index is out of range" );
					status = TCL_ERROR;
				} else {
					bu_vls_printf( &vls, "%.25G %.25G %.25G", V3ARGS( &bot->normals[i*3] ) );
					status = TCL_OK;
				}
			}
		}
		else if( !strncmp( attr, "fn", 2 ) )
		{
			if( attr[2] == '\0' ) {
				for( i=0 ; i<bot->num_faces ; i++ ) {
					bu_vls_printf( &vls, " { %d %d %d }", V3ARGS( &bot->face_normals[i*3] ) );
				}
				status = TCL_OK;
			} else {
				i = atoi( &attr[2] );
				if( i < 0 || i >= bot->num_faces ) {
					bu_vls_strcat( &vls, "Specified face index is out of range" );
					status = TCL_ERROR;
				} else {
					bu_vls_printf( &vls, "%d %d %d", V3ARGS( &bot->face_normals[i*3] ) );
					status = TCL_OK;
				}
			}
		}
		else if( !strcmp( attr, "nn" ) )
		{
			if( !(bot->bot_flags & RT_BOT_HAS_SURFACE_NORMALS) || bot->num_normals < 1 ) {
				bu_vls_strcat( &vls, "0" );
			} else {
				bu_vls_printf( &vls, "%d", bot->num_normals );
			}
			status = TCL_OK;
		}
		else if( !strcmp( attr, "nfn" ) )
		{
			if( !(bot->bot_flags & RT_BOT_HAS_SURFACE_NORMALS) || bot->num_face_normals < 1 ) {
				bu_vls_strcat( &vls, "0" );
			} else {
				bu_vls_printf( &vls, "%d", bot->num_face_normals );
			}
			status = TCL_OK;
		}
		else if( !strncmp( attr, "fm", 2 ) )
a2327 15
		else if( !strcmp( attr, "flags" ) )
		{
			bu_vls_printf( &vls, "{" );
			if( bot->bot_flags & RT_BOT_HAS_SURFACE_NORMALS ) {
				bu_vls_printf( &vls, " has_normals" );
			}
			if( bot->bot_flags & RT_BOT_USE_NORMALS ) {
				bu_vls_printf( &vls, " use_normals" );
			}
			if( bot->bot_flags & RT_BOT_USE_FLOATS ) {
				bu_vls_printf( &vls, " use_floats" );
			}
			bu_vls_printf( &vls, "}" );
			status = TCL_OK;
		}
a2447 21
/*
 *			R T _ B O T _ T C L A D J U S T
 *
 * Examples - 
 *	db adjust name fm		set los facemode bit vector
 *	db adjust name fm#		set los face mode of face # (center, append)
 *	db adjust name V		set coords for all vertices
 *	db adjust name V#		set coords for vertex #
 *	db adjust name F		set vertex indices for all faces
 *	db adjust name F#		set vertex indices for face #
 *	db adjust name T		set thickness for all faces
 *	db adjust name T#		set thickness for face #
 *	db adjust name N		set list of normals
 *	db adjust name N#		set coords for normal #
 *	db adjust name fn		set list indices into normal vectors for all faces
 *	db adjust name fn#		set list indices into normal vectors for face #
 *	db adjust name nn		set num_normals
 *	db adjust name mode		set mode (surf, volume, plate, plane_nocos)
 *	db adjust name orient		set orientation (no, rh, lh)
 *	db adjust name flags		set flags
 */
d2466 3
a2468 204
		if( !strncmp( argv[0], "fm", 2 ) )
		{
			if( argv[0][2] == '\0' )
			{
				if( bot->face_mode )
					bu_free( (char *)bot->face_mode, "bot->face_mode" );
				bot->face_mode = bu_hex_to_bitv( argv[1] );
			}
			else
			{
				i = atoi( &(argv[0][2]) );
				if( i < 0 || i >= bot->num_faces )
				{
					Tcl_SetResult( interp, "Face number out of range", TCL_STATIC );
					Tcl_DecrRefCount( list );
					return( TCL_ERROR );
				}

				if( isdigit( *argv[1] ) )
				  {
				    if( atoi( argv[1] ) == 0 )
					BU_BITCLR( bot->face_mode, i );
				    else
					BU_BITSET( bot->face_mode, i );
				  }
				else if( !strcmp( argv[1], "append" ) )
					BU_BITSET( bot->face_mode, i );
				else
				        BU_BITCLR( bot->face_mode, i );
			}
		}
		else if( !strcmp( argv[0], "nn" ) )
		{
			int new_num=0;
			int old_num = bot->num_normals;

			new_num = atoi( Tcl_GetStringFromObj( obj, NULL ) );
			if( new_num < 0 ) {
				Tcl_SetResult( interp, "Number of normals may not be less than 0", TCL_STATIC );
				Tcl_DecrRefCount( list );
				return( TCL_ERROR );
			}

			if( new_num == 0 ) {
				bot->num_normals = 0;
				if( bot->normals ) {
					bu_free( (char *)bot->normals, "BOT normals" );
				}
				bot->normals = (fastf_t *)NULL;
			} else {
				if( new_num != old_num ) {
					bot->num_normals = new_num;
					if( bot->normals ) {
						bot->normals = (fastf_t *)bu_realloc( (char *)bot->normals,
								     bot->num_normals * 3 * sizeof( fastf_t ), "BOT normals" );
					} else {
						bot->normals = (fastf_t *)bu_calloc( bot->num_normals * 3, sizeof( fastf_t ),
										     "BOT normals" );
					}

					if( new_num > old_num ) {
						for( i = old_num ; i<new_num ; i++ ) {
							VSET( &bot->normals[i*3], 0, 0, 0 );
						}
					}
				}
				
			}
			
		}
		else if( !strncmp( argv[0], "fn", 2 ) )
		{
		    char *f_str;

		    if( argv[0][2] == '\0' )
		      {
			(void)Tcl_ListObjGetElements( interp, list, &len, &obj_array );
			if( len != bot->num_faces || len <= 0 ) {
			    Tcl_SetResult( interp, "Must provide normals for all faces!!!", TCL_STATIC );
			    Tcl_DecrRefCount( list );
			    return( TCL_ERROR );
			}
			if( bot->face_normals )
				bu_free( (char *)bot->face_normals, "BOT face_normals" );
			bot->face_normals = (int *)bu_calloc( len*3, sizeof( int ), "BOT face_normals" );
			bot->num_face_normals = len;
			for( i=0 ; i<len ; i++ ) {
				f_str = Tcl_GetStringFromObj( obj_array[i], NULL );
				while( isspace( *f_str ) ) f_str++;

				if( *f_str == '\0' ) {
					Tcl_SetResult( interp, "incomplete list of face_normals", TCL_STATIC );
					Tcl_DecrRefCount( list );
					return( TCL_ERROR );
				}
				bot->face_normals[i*3] = atoi( f_str );
				f_str = bu_next_token( f_str );
				if( *f_str == '\0' ) {
					Tcl_SetResult( interp, "incomplete list of face_normals", TCL_STATIC );
					Tcl_DecrRefCount( list );
					return( TCL_ERROR );
				}
				bot->face_normals[i*3+1] = atoi( f_str );
				f_str = bu_next_token( f_str );
				if( *f_str == '\0' ) {
					Tcl_SetResult( interp, "incomplete list of face_normals", TCL_STATIC );
					Tcl_DecrRefCount( list );
					return( TCL_ERROR );
				}
				bot->face_normals[i*3+2] = atoi( f_str );
			}
			bot->bot_flags |= RT_BOT_HAS_SURFACE_NORMALS;
		      }
		    else
		      {
			i = atoi( &argv[0][2] );
			if( i < 0 || i >= bot->num_faces )
			  {
			    Tcl_SetResult( interp, "face_normal number out of range!!!", TCL_STATIC );
			    Tcl_DecrRefCount( list );
			    return( TCL_ERROR );
			  }
			f_str = Tcl_GetStringFromObj( list, NULL );
		      	while( isspace( *f_str ) ) f_str++;
			bot->face_normals[i*3] = atoi( f_str );
			f_str = bu_next_token( f_str );
			if( *f_str == '\0' )
			  {
			    Tcl_SetResult( interp, "incomplete vertex", TCL_STATIC );
			    Tcl_DecrRefCount( list );
			    return( TCL_ERROR );
			  }
			bot->face_normals[i*3+1] = atoi( f_str );
			f_str = bu_next_token( f_str );
			if( *f_str == '\0' )
			  {
			    Tcl_SetResult( interp, "incomplete vertex", TCL_STATIC );
			    Tcl_DecrRefCount( list );
			    return( TCL_ERROR );
			  }
			bot->face_normals[i*3+2] = atoi( f_str );
		      }
		}
		else if( argv[0][0] == 'N' )
		{
		  char *v_str;

		  if( argv[0][1] == '\0' )
		    {
		      (void)Tcl_ListObjGetElements( interp, list, &len, &obj_array );
		      if( len <= 0 )
			{
			  Tcl_SetResult( interp, "Must provide at least one normal!!!", TCL_STATIC );
			  Tcl_DecrRefCount( list );
			  return( TCL_ERROR );
			}
		      bot->num_normals = len;
		      if( bot->normals )
			      bu_free( (char *)bot->normals, "BOT normals" );
		      bot->normals = (fastf_t *)bu_calloc( len*3, sizeof( fastf_t ), "BOT normals" );
		      for( i=0 ; i<len ; i++ )
			{
			  v_str = Tcl_GetStringFromObj( obj_array[i], NULL );
			  while( isspace( *v_str ) ) v_str++;
			  if( *v_str == '\0' )
			    {
			      Tcl_SetResult( interp, "incomplete list of normals", TCL_STATIC );
			      Tcl_DecrRefCount( list );
			      return( TCL_ERROR );
			    }
			  bot->normals[i*3] = atof( v_str );
			  v_str = bu_next_token( v_str );
			  if( *v_str == '\0' )
			    {
			      Tcl_SetResult( interp, "incomplete list of normals", TCL_STATIC );
			      Tcl_DecrRefCount( list );
			      return( TCL_ERROR );
			    }
			  bot->normals[i*3+1] = atof( v_str );
			  v_str = bu_next_token( v_str );
			  if( *v_str == '\0' )
			    {
			      Tcl_SetResult( interp, "incomplete list of normals", TCL_STATIC );
			      Tcl_DecrRefCount( list );
			      return( TCL_ERROR );
			    }
			  bot->normals[i*3+2] = atof( v_str );
			  Tcl_DecrRefCount( obj_array[i] );
			}
		      bot->bot_flags |= RT_BOT_HAS_SURFACE_NORMALS;
		    } else {
		      i = atoi( &argv[0][1] );
		      if( i < 0 || i >= bot->num_normals )
			{
			  Tcl_SetResult( interp, "normal number out of range!!!", TCL_STATIC );
			  Tcl_DecrRefCount( list );
			  return( TCL_ERROR );
			}
		      v_str = Tcl_GetStringFromObj( list, NULL );
		      while( isspace( *v_str ) ) v_str++;

		      bot->normals[i*3] = atof( v_str );
		      v_str = bu_next_token( v_str );
		      if( *v_str == '\0' )
d2470 3
a2472 3
			  Tcl_SetResult( interp, "incomplete normal", TCL_STATIC );
			  Tcl_DecrRefCount( list );
			  return( TCL_ERROR );
d2474 1
a2474 3
		      bot->normals[i*3+1] = atof( v_str );
		      v_str = bu_next_token( v_str );
		      if( *v_str == '\0' )
d2476 19
a2494 3
			  Tcl_SetResult( interp, "incomplete normal", TCL_STATIC );
			  Tcl_DecrRefCount( list );
			  return( TCL_ERROR );
a2495 2
		      bot->normals[i*3+2] = atof( v_str );
		    }
a2591 17
			if( bot->bot_flags & RT_BOT_HAS_SURFACE_NORMALS ) {
				if( !bot->face_normals ) {
					bot->face_normals = (int *)bu_malloc( bot->num_faces * 3 * sizeof( int ),
									      "bot->face_normals" );
					bot->num_face_normals = bot->num_faces;
					for( i=0 ; i<bot->num_face_normals ; i++ ) {
						VSETALL( &bot->face_normals[i*3], -1 );
					}
				} else if( bot->num_face_normals < bot->num_faces ) {
					bot->face_normals = (int *)bu_realloc( bot->face_normals,
							     bot->num_faces * 3 * sizeof( int ), "bot->face_normals" );
					for( i=bot->num_face_normals ; i<bot->num_faces ; i++ ) {
						VSETALL( &bot->face_normals[i*3], -1 );
					}
					bot->num_face_normals = bot->num_faces;
				}
			}
a2767 21
		else if( !strcmp( argv[0], "flags" ) )
		  {
			  (void)Tcl_ListObjGetElements( interp, list, &len, &obj_array );
			  bot->bot_flags = 0;
			  for( i=0 ; i<len ; i++ ) {
				  char *str;

				  str = Tcl_GetStringFromObj( obj_array[i], NULL );
				  if( !strcmp( str, "has_normals" ) ) {
					  bot->bot_flags |= RT_BOT_HAS_SURFACE_NORMALS;
				  } else if( !strcmp( str, "use_normals" ) ) {
					  bot->bot_flags |= RT_BOT_USE_NORMALS;
				  } else if( !strcmp( str, "use_floats" ) ) {
					  bot->bot_flags |= RT_BOT_USE_FLOATS;
				  } else {
					  Tcl_SetResult( interp, "unrecognized flag (must be \"has_normals\", \"use_normals\", or \"use_floats\"!!!", TCL_STATIC );
					  Tcl_DecrRefCount( list );
					  return( TCL_ERROR );
				  }
			  }
		  }
d3094 3
a3096 3
	v0 = &vertices[piece[0]*3];
	v1 = &vertices[piece[1]*3];
	v2 = &vertices[piece[2]*3];
a3141 4

/*	This routine sorts the faces of the BOT such that when they are taken in groups of "tris_per_piece",
 *	each group (piece) will consist of adjacent faces
 */
d3145 1
a3145 1
	int *new_faces;		/* the sorted list of faces to be attached to the BOT at the end of this routine */
a3146 1
	int *new_norms = (int*)NULL;		/* the sorted list of vertex normals corrsponding to the "new_faces" list */
d3148 1
a3148 2
	int *piece;		/* a small face list, for just the faces in the current piece */
	int *piece_norms = (int*)NULL;	/* vertex normals for faces in the current piece */
d3150 1
a3150 1
	unsigned char *vert_count;	/* an array used to hold the number of piece vertices that appear in each BOT face */
d3159 2
a3160 1
	/* allocate memory for all the data */
d3164 2
a3165 2
	vert_count = (unsigned char *)bu_malloc( bot->num_faces * sizeof( unsigned char ), "vert_count" );
	piece_verts = (int *)bu_malloc( (tris_per_piece * 3 + 1) * sizeof( int ), "piece_verts" );
a3167 5
	if( bot->bot_flags & RT_BOT_HAS_SURFACE_NORMALS ) {
		new_norms = (int *)bu_calloc( bot->num_faces * 3, sizeof( int ), "new_norms" );
		piece_norms = (int *)bu_calloc( tris_per_piece * 3, sizeof( int ), "piece_norms" );
	}

a3172 1
	/* process until we have sorted all the faces */
d3179 1
a3179 1
		for( i=0 ; i<tris_per_piece*3+1 ; i++ ) {
a3189 1
			/* all faces used, we must be done */
a3194 3
		if( bot->bot_flags & RT_BOT_HAS_SURFACE_NORMALS ) {
			VMOVE( piece_norms, &bot->face_normals[cur_face*3] );
		}
a3209 3
				if( bot->bot_flags & RT_BOT_HAS_SURFACE_NORMALS ) {
					VMOVE( &new_norms[new_face_count*3], &piece_norms[j*3] );
				}
d3245 2
a3246 30
					}
				}

				if( vert_count[i] > 1 ) {
					/* add this face to the piece */
					VMOVE( &piece[piece_len*3], &old_faces[i*3] );
					if( bot->bot_flags & RT_BOT_HAS_SURFACE_NORMALS ) {
						VMOVE( &piece_norms[piece_len*3], &bot->face_normals[i*3] );
					}

					/* Add its vertices to the list of piece vertices */
					Add_unique_verts( piece_verts, &old_faces[i*3] );

					/* mark this face as used */
					VSETALL( &old_faces[i*3], -1 );

					/* update counts */
					piece_len++;
					faces_left--;
					vert_count[i] = 0;

					/* check if this piece is done */
					if( piece_len == tris_per_piece || faces_left == 0 ) {
						/* copy this piece to the "new_faces" list */
						for( j=0 ; j<piece_len ; j++ ) {
							VMOVE( &new_faces[new_face_count*3], &piece[j*3] );
							if( bot->bot_flags & RT_BOT_HAS_SURFACE_NORMALS ) {
								VMOVE( &new_norms[new_face_count*3], &piece_norms[j*3] );
							}
							new_face_count++;
a3247 4
						piece_len = 0;
						max_verts = 0;
						done_with_piece = 1;
						break;
a3249 3
				if( vert_count[i] > max_verts ) {
					max_verts = vert_count[i];
				}
d3255 1
a3255 1
			if( max_verts == 0 && !done_with_piece ) {
a3265 3
				if( bot->bot_flags & RT_BOT_HAS_SURFACE_NORMALS ) {
					VMOVE( &piece_norms[piece_len*3], &bot->face_normals[face_to_add*3] );
				}
a3281 3
						if( bot->bot_flags & RT_BOT_HAS_SURFACE_NORMALS ) {
							VMOVE( &new_norms[new_face_count*3], &piece_norms[j*3] );
						}
d3288 1
a3288 1
			} else if( max_verts == 1 && !done_with_piece ) {
d3291 1
a3291 1
			} else if( !done_with_piece ) {
d3300 1
a3300 1
			while( max_verts >= max_verts_min && !done_with_piece ) {
a3307 3
						if( bot->bot_flags & RT_BOT_HAS_SURFACE_NORMALS ) {
							VMOVE( &piece_norms[piece_len*3], &bot->face_normals[i*3] );
						}
a3318 3
								if( bot->bot_flags & RT_BOT_HAS_SURFACE_NORMALS ) {
									VMOVE( &new_norms[new_face_count*3], &piece_norms[j*3] );
								}
a3351 6
	if( bot->bot_flags & RT_BOT_HAS_SURFACE_NORMALS ) {
		bu_free( (char *)piece_norms, "piece_norms" );
		bu_free( (char *)bot->face_normals, "bot->face_normals" );
		bot->face_normals = new_norms;
	}

a3354 54
struct bot_edge {
  int v;
  int use_count;
  struct bot_edge *next;
};

static void
delete_edge( int v1, int v2, struct bot_edge **edges )
{
	struct bot_edge *edg, *prev=NULL;

	if( v1 < v2 ) {
		edg = edges[v1];
		while( edg ) {
			if( edg->v == v2 ) {
				edg->use_count--;
				if( edg->use_count < 1 ) {
					if( prev ) {
						prev->next = edg->next;
					} else {
						edges[v1] = edg->next;
					}
					edg->v = -1;
					edg->next = NULL;
					bu_free( (char *)edg, "bot_edge" );
					return;
				}
			}
			prev = edg;
			edg = edg->next;
		}
	} else {
		edg = edges[v2];
		while( edg ) {
			if( edg->v == v1 ) {
				edg->use_count--;
				if( edg->use_count < 1 ) {
					if( prev ) {
						prev->next = edg->next;
					} else {
						edges[v2] = edg->next;
					}
					edg->v = -1;
					edg->next = NULL;
					bu_free( (char *)edg, "bot_edge" );
					return;
				}
			}
			prev = edg;
			edg = edg->next;
		}
	}
}

d3365 1
a3365 1
decimate_edge( int v1, int v2, struct bot_edge **edges, int num_edges, int *faces, int num_faces, int face_del1, int face_del2 )
d3367 3
a3369 2
	int i;
	struct bot_edge *edg;
d3371 12
a3382 16
	/* first eliminate all the edges of the two deleted faces from the edge list */
	delete_edge( faces[face_del1*3 + 0], faces[face_del1*3 + 1], edges );
	delete_edge( faces[face_del1*3 + 1], faces[face_del1*3 + 2], edges );
	delete_edge( faces[face_del1*3 + 2], faces[face_del1*3 + 0], edges );
	delete_edge( faces[face_del2*3 + 0], faces[face_del2*3 + 1], edges );
	delete_edge( faces[face_del2*3 + 1], faces[face_del2*3 + 2], edges );
	delete_edge( faces[face_del2*3 + 2], faces[face_del2*3 + 0], edges );

	/* do the decimation */
	for( i=0 ; i<3 ; i++ ) {
		faces[face_del1*3 + i] = -1;
		faces[face_del2*3 + i] = -1;
	}
	for( i=0 ; i<num_faces*3 ; i++ ) {
		if( faces[i] == v1 ) {
			faces[i] = v2;
d3384 5
a3388 43
	}

	/* update the edge list */
	/* now move all the remaining edges at edges[v1] to somewhere else */
	edg = edges[v1];
	while( edg ) {
		struct bot_edge *ptr;
		struct bot_edge *next;

		next = edg->next;

		if( edg->v < v2 ) {
			ptr = edges[edg->v];
			while( ptr ) {
				if( ptr->v == v2 ) {
					ptr->use_count++;
					edg->v = -1;
					edg->next = NULL;
					bu_free( (char *)edg, "bot edge" );
					break;
				}
				ptr = ptr->next;
			}
			if( !ptr ) {
				edg->next = edges[edg->v];
				edges[edg->v] = edg;
				edg->v = v2;
			}
		} else {
			ptr = edges[v2];
			while( ptr ) {
				if( ptr->v == edg->v ) {
					ptr->use_count++;
					edg->v = -1;
					edg->next = NULL;
					bu_free( (char *)edg, "bot edge" );
					break;
				}
				ptr = ptr->next;
			}
			if( !ptr ) {
				edg->next = edges[v2];
				edges[v2] = edg;
a3390 2

		edg = next;
a3391 1
	edges[v1] = NULL;
d3393 2
a3394 3
	/* now change all remaining v1 references to v2 */
	for( i=0 ; i<num_edges ; i++ ) {
		struct bot_edge *next, *prev, *ptr;
d3396 7
a3402 5
		prev = NULL;
		edg = edges[i];
		/* look at edges starting from vertex #i */
		while( edg ) {
			next = edg->next;
d3404 2
a3405 10
			if( edg->v == v1 ) {
				/* this one is affected */
				edg->v = v2;	/* change v1 to v2 */
				if( v2 < i ) {
					/* disconnect this edge from list #i */
					if( prev ) {
						prev->next = next;
					} else {
						edges[i] = next;
					}
d3407 2
a3408 40
					/* this edge must move to the "v2" list */
					ptr = edges[v2];
					while( ptr ) {
						if( ptr->v == i ) {
							/* found another occurence of this edge
							 * increment use count
							 */
							ptr->use_count++;

							/* delete the original */
							edg->v = -1;
							edg->next = NULL;
							bu_free( (char *)edg, "bot edge" );
							break;
						}
						ptr = ptr->next;
					}
					if( !ptr ) {
						/* did not find another occurence, add to list */
						edg->next = edges[v2];
						edges[v2] = edg;
					}
					edg = next;
				} else {
					/* look for other occurences of this edge in this list
					 * if found, just increment use count
					 */
					ptr = edges[i];
					while( ptr ) {
						if( ptr->v == v2 && ptr != edg ) {
							/* found another occurence */
							/* increment use count */
							ptr->use_count++;

							/* disconnect original from list */
							if( prev ) {
								prev->next = next;
							} else {
								edges[i] = next;
							}
d3410 1
a3410 4
							/* free it */
							edg->v = -1;
							edg->next = NULL;
							bu_free( (char *)edg, "bot edge" );
d3412 6
a3417 8
							break;
						}
						ptr = ptr->next;
					}
					if( !ptr ) {
						prev = edg;
					}
					edg = next;
a3418 3
			} else {
				/* unaffected edge, just continue */
				edg = next;
d3421 14
d3437 1
a3437 1
	return 2;
a3459 1
		       struct bot_edge **edges,
a3461 2
		       int *face_del1,
		       int *face_del2,
a3467 1
	int num_edges=bot->num_vertices;
d3469 1
d3480 2
a3481 2
	*face_del1 = -1;
	*face_del2 = -1;
d3498 2
a3499 2
			if( *face_del1 > -1 ) {
				*face_del2 = i/3;
d3501 1
a3501 1
				*face_del1 = i/3;
d3516 1
a3516 1
	if( *face_del2 < 0 ) {
d3527 5
a3531 11
		struct bot_edge *edg;

		/* check if vertex v1 is on a free edge */
		for( i=0 ; i<num_edges ; i++ ) {
			edg = edges[i];
			while( edg ) {
				if( (i == v1 || edg->v == v1) && edg->use_count < 2 ) {
					return 0;
				}
				edg = edg->next;
			}
d3544 1
a3544 1
	if( max_chord_error > -1.0 || max_normal_error > -1.0 ) {
d3587 1
a3587 1
			if( max_normal_error > -1.0 && dot < max_normal_error ) {
d3593 1
a3593 1
			if( max_chord_error > -1.0 && dist > max_chord_error ) {
d3602 5
a3613 7
 *
 *	This and associated routines maintain a list of edges and their "use counts"
 *	A "free edge" is one with a use count of 1, most edges have a use count of 2
 *	When a use count reaches zero, the edge is removed from the list.
 *	The list is used to direct the edge decimation process and to avoid deforming the shape
 *	of a non-volume enclosing BOT by keeping track of use counts (and thereby free edges)
 *	If a free edge would be moved, that deciamtion is not performed.
a3630 1
	int done;
a3633 1
#if 0
d3638 1
a3638 1
#endif
d3640 1
a3640 1
	if( max_normal_error > -1.0 ) {
d3691 1
a3691 1
	      ptr = bu_calloc( 1, sizeof( struct bot_edge ), "edges[v1]" );
a3695 1
		ptr->use_count++;
d3698 1
a3698 1
	      ptr->next = bu_calloc( 1, sizeof( struct bot_edge ), "ptr->next" );
a3702 1
	    ptr->use_count++;
d3707 3
a3709 9
	/* the decimation loop */
	done = 0;
	while( !done ) {
		done = 1;

		/* visit each edge */
		for( i=0 ; i<bot->num_vertices ; i++ ) {
			struct bot_edge *ptr;
			int face_del1, face_del2;
d3711 2
a3712 2
			ptr = edges[i];
			while( ptr ) {
d3714 16
a3729 32
				/* try to avoid making 2D objects */
				if( face_count < 5 )
					break;

				/* check if this edge can be eliminated (try both directions) */
				if( edge_can_be_decimated( bot, faces, edges, i, ptr->v,
							   &face_del1, &face_del2,
							   max_chord_error,
							   max_normal_error,
							   min_edge_length_sq )) {
					face_count -= decimate_edge( i, ptr->v, edges, bot->num_vertices,
								     faces, bot->num_faces,
								     face_del1, face_del2 );
					edges_deleted++;
					done = 0;
					break;
				} else if( edge_can_be_decimated( bot, faces, edges, ptr->v, i,
								  &face_del1, &face_del2,
								  max_chord_error,
								  max_normal_error,
								  min_edge_length_sq )) {
					face_count -= decimate_edge( ptr->v, i, edges, bot->num_vertices,
								     faces, bot->num_faces,
								     face_del1, face_del2 );
					edges_deleted++;
					done = 0;
					break;
				} else {
					ptr = ptr->next;
				}
			}
		}
a3785 205
}

static int
smooth_bot_miss( struct application *ap )
{
	return 0;
}

static int
smooth_bot_hit( struct application *ap, struct partition *PartHeadp, struct seg *seg )
{
	struct partition *pp;
	struct soltab *stp;
	vect_t inormal, onormal;
	vect_t *normals=(vect_t *)ap->a_uptr;

	for( pp=PartHeadp->pt_forw ; pp != PartHeadp; pp = pp->pt_forw )  {
		stp = pp->pt_inseg->seg_stp;
		RT_HIT_NORMAL( inormal, pp->pt_inhit, stp, &(ap->a_ray), pp->pt_inflip );

		stp = pp->pt_outseg->seg_stp;
		RT_HIT_NORMAL( onormal, pp->pt_outhit, stp, &(ap->a_ray), pp->pt_outflip );
		if( pp->pt_inhit->hit_surfno == ap->a_user ) {
			VMOVE( normals[pp->pt_inhit->hit_surfno], inormal );
			break;
		}
		if( pp->pt_outhit->hit_surfno == ap->a_user ) {
			VMOVE( normals[pp->pt_outhit->hit_surfno], onormal );
			break;
		}
	}

	return 1;
}

int
rt_smooth_bot( struct rt_bot_internal *bot, char *bot_name, struct db_i *dbip, fastf_t norm_tol_angle )
{
	int vert_no;
	int i,j,k;
	struct rt_i *rtip;
	struct application ap;
	fastf_t normal_dot_tol=0.0;
	vect_t *normals;

	RT_BOT_CK_MAGIC( bot );

	if( norm_tol_angle < 0.0 || norm_tol_angle > M_PI ) {
		bu_log( "normal tolerance angle must be from 0 to Pi\n" );
		return( -2 );
	}

	if( (bot->orientation == RT_BOT_UNORIENTED) && (bot->mode != RT_BOT_SOLID) ) {
		bu_log( "Cannot smooth unoriented BOT primitives unless they are solid objects\n" );
		return( -3 );
	}

	normal_dot_tol = cos( norm_tol_angle );

	if( bot->normals ) {
		bu_free( (char *)bot->normals, "bot->normals" );
		bot->normals = NULL;
	}

	if( bot->face_normals ) {
		bu_free( (char *)bot->face_normals, "bot->face_normals" );
		bot->face_normals = NULL;
	}

	bot->bot_flags &= !(RT_BOT_HAS_SURFACE_NORMALS | RT_BOT_USE_NORMALS);
	bot->num_normals = 0;
	bot->num_face_normals = 0;

	/* build an array of surface normals */
	normals = (vect_t *)bu_calloc( bot->num_faces , sizeof( vect_t ), "normals" );

	if( bot->orientation == RT_BOT_UNORIENTED ) {
		/* need to do raytracing, do prepping */
		bzero( &ap, sizeof( struct application ) );
		rtip = rt_new_rti( dbip );
		ap.a_rt_i = rtip;
		ap.a_hit = smooth_bot_hit;
		ap.a_miss = smooth_bot_miss;
		ap.a_uptr = (genptr_t)normals;
		if( rt_gettree( rtip, bot_name ) ) {
			bu_log( "rt_gettree failed for %s\n", bot_name );
			return( -1 );
		}
		rt_prep( rtip );

		/* find the surface normal for each face */
		for( i=0 ; i<bot->num_faces ; i++ ) {
			vect_t a, b;
			vect_t inv_dir;

			VSUB2( a, &bot->vertices[bot->faces[i*3+1]*3], &bot->vertices[bot->faces[i*3]*3] );
			VSUB2( b, &bot->vertices[bot->faces[i*3+2]*3], &bot->vertices[bot->faces[i*3]*3] );
			VCROSS( ap.a_ray.r_dir, a, b );
			VUNITIZE( ap.a_ray.r_dir );

			/* calculate ray start point */
			VADD3( ap.a_ray.r_pt, &bot->vertices[bot->faces[i*3]*3],
			       &bot->vertices[bot->faces[i*3+1]*3],
			       &bot->vertices[bot->faces[i*3+2]*3] );
			VSCALE( ap.a_ray.r_pt, ap.a_ray.r_pt, 0.333333333333 );

			/* back out to bounding box limits */

			/* Compute the inverse of the direction cosines */
			if( ap.a_ray.r_dir[X] < -SQRT_SMALL_FASTF )  {
				inv_dir[X]=1.0/ap.a_ray.r_dir[X];
			} else if( ap.a_ray.r_dir[X] > SQRT_SMALL_FASTF )  {
				inv_dir[X]=1.0/ap.a_ray.r_dir[X];
			} else {
				ap.a_ray.r_dir[X] = 0.0;
				inv_dir[X] = INFINITY;
			}
			if( ap.a_ray.r_dir[Y] < -SQRT_SMALL_FASTF )  {
				inv_dir[Y]=1.0/ap.a_ray.r_dir[Y];
			} else if( ap.a_ray.r_dir[Y] > SQRT_SMALL_FASTF )  {
				inv_dir[Y]=1.0/ap.a_ray.r_dir[Y];
			} else {
				ap.a_ray.r_dir[Y] = 0.0;
				inv_dir[Y] = INFINITY;
			}
			if( ap.a_ray.r_dir[Z] < -SQRT_SMALL_FASTF )  {
				inv_dir[Z]=1.0/ap.a_ray.r_dir[Z];
			} else if( ap.a_ray.r_dir[Z] > SQRT_SMALL_FASTF )  {
				inv_dir[Z]=1.0/ap.a_ray.r_dir[Z];
			} else {
				ap.a_ray.r_dir[Z] = 0.0;
				inv_dir[Z] = INFINITY;
			}

			if( !rt_in_rpp( &ap.a_ray, inv_dir, rtip->mdl_min, rtip->mdl_max ) ) {
				/* ray missed!!! */
				bu_log( "ERROR: Ray missed target!!!!\n" );
			}
			VJOIN1( ap.a_ray.r_pt, ap.a_ray.r_pt, ap.a_ray.r_min, ap.a_ray.r_dir );
			ap.a_user = i;
			(void) rt_shootray( &ap );
		}
		rt_free_rti( rtip );
	} else {
		/* calculate normals */
		for( i=0 ; i<bot->num_faces ; i++ ) {
			vect_t a, b;

			VSUB2( a, &bot->vertices[bot->faces[i*3+1]*3], &bot->vertices[bot->faces[i*3]*3] );
			VSUB2( b, &bot->vertices[bot->faces[i*3+2]*3], &bot->vertices[bot->faces[i*3]*3] );
			VCROSS( normals[i], a, b );
			VUNITIZE( normals[i] );
			if( bot->orientation == RT_BOT_CW ) {
				VREVERSE( normals[i], normals[i] );
			}
		}
	}

	bot->num_normals = bot->num_faces * 3;
	bot->num_face_normals = bot->num_faces;

	bot->normals = (fastf_t *)bu_calloc( bot->num_normals * 3, sizeof( fastf_t ), "bot->normals" );
	bot->face_normals = (int *)bu_calloc( bot->num_face_normals * 3, sizeof( int ), "bot->face_normals" );

	/* process each face */
	for( i=0 ; i<bot->num_faces ; i++ ) {
		vect_t def_norm; /* default normal for this face */

		VMOVE( def_norm, normals[i] );

		/* process each vertex in his face */
		for( k=0 ; k<3 ; k++ ) {
			vect_t ave_norm;

			/* the actual vertex index */
			vert_no = bot->faces[i*3+k];
			VSETALL( ave_norm, 0.0 );

			/* find all the faces that use this vertex */
			   for( j=0 ; j<bot->num_faces*3 ; j++ ) {
				   if( bot->faces[j] == vert_no ) {
					   int the_face;

					   the_face = j / 3;

					   /* add all the normals that are within tolerance
					    * this also gets def_norm
					    */
					   if( VDOT( normals[the_face], def_norm ) >= normal_dot_tol ) {
						   VADD2( ave_norm, ave_norm, normals[the_face] );
					   }
				   }
			   }
			   VUNITIZE( ave_norm );
			   VMOVE( &bot->normals[(i*3+k)*3], ave_norm );
			   bot->face_normals[i*3+k] = i*3+k;
		}
	}

	bu_free( (char *)normals, "normals" );

	bot->bot_flags |= RT_BOT_HAS_SURFACE_NORMALS;
	bot->bot_flags |= RT_BOT_USE_NORMALS;

	return( 0 );
@


1.102
log
@Converted from K&R to ANSI C - RFH
@
text
@d255 4
a258 1
rt_bot_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
d357 2
a358 1
rt_bot_print(register const struct soltab *stp)
d544 8
a551 1
rt_bot_makesegs(struct hit *hits, int nhits, struct soltab *stp, struct xray *rp, struct application *ap, struct seg *seghead, struct rt_piecestate *psp)
d916 5
a920 1
rt_bot_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
d1019 7
a1025 1
rt_bot_piece_shot(struct rt_piecestate *psp, struct rt_piecelist *plp, double dist_corr, register struct xray *rp, struct application *ap, struct seg *seghead)
d1174 4
a1177 1
rt_bot_piece_hitsegs(struct rt_piecestate *psp, struct seg *seghead, struct application *ap)
d1198 6
a1203 6
rt_bot_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		  	       /* Number of ray/object pairs */
                  	    
d1214 4
a1217 1
rt_bot_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
d1252 4
a1255 1
rt_bot_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
d1273 5
a1277 1
rt_bot_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
d1285 2
a1286 1
rt_bot_free(register struct soltab *stp)
d1321 4
a1324 1
rt_bot_class(const struct soltab *stp, const fastf_t *min, const fastf_t *max, const struct bn_tol *tol)
d1333 5
a1337 1
rt_bot_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d1361 5
a1365 1
rt_bot_plot_poly(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d1408 6
a1413 1
rt_bot_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d1510 5
a1514 1
rt_bot_import(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d1590 5
a1594 1
rt_bot_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d1695 5
a1699 1
rt_bot_import5(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d1770 5
a1774 1
rt_bot_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d1873 5
a1877 1
rt_bot_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
d1965 2
a1966 1
rt_bot_ifree(struct rt_db_internal *ip)
d1989 5
a1993 1
rt_bot_tnurb(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct bn_tol *tol)
d1999 5
a2003 1
rt_bot_xform(struct rt_db_internal *op, const fastf_t *mat, struct rt_db_internal *ip, const int free, struct db_i *dbip)
d2288 4
a2291 1
rt_bot_tclget(Tcl_Interp *interp, const struct rt_db_internal *intern, const char *attr)
d2532 5
a2536 1
rt_bot_tcladjust(Tcl_Interp *interp, struct rt_db_internal *intern, int argc, char **argv)
@


1.101
log
@rt_bot_makesegs() now tries to reorder multiple hits at same distance to get
entrance/exit pairs in correct order.
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.100 2002/04/24 19:46:31 jra Exp $ (BRL)";
d255 1
a255 4
rt_bot_prep( stp, ip, rtip )
struct soltab		*stp;
struct rt_db_internal	*ip;
struct rt_i		*rtip;
d354 1
a354 2
rt_bot_print( stp )
register const struct soltab *stp;
d540 1
a540 8
rt_bot_makesegs( hits, nhits, stp, rp, ap, seghead, psp )
struct hit		*hits;
int			nhits;
struct soltab		*stp;
struct xray		*rp;
struct application	*ap;
struct seg		*seghead;
struct rt_piecestate	*psp;
d905 1
a905 5
rt_bot_shot( stp, rp, ap, seghead )
struct soltab		*stp;
register struct xray	*rp;
struct application	*ap;
struct seg		*seghead;
d1004 1
a1004 7
rt_bot_piece_shot( psp, plp, dist_corr, rp, ap, seghead )
struct rt_piecestate	*psp;
struct rt_piecelist	*plp;
double			dist_corr;
register struct xray	*rp;
struct application	*ap;
struct seg		*seghead;
d1153 1
a1153 4
rt_bot_piece_hitsegs( psp, seghead, ap )
struct rt_piecestate	*psp;
struct seg		*seghead;
struct application	*ap;
d1174 6
a1179 6
rt_bot_vshot( stp, rp, segp, n, ap )
struct soltab	       *stp[]; /* An array of solid pointers */
struct xray		*rp[]; /* An array of ray pointers */
struct  seg            segp[]; /* array of segs (results returned) */
int		  	    n; /* Number of ray/object pairs */
struct application	*ap;
d1190 1
a1190 4
rt_bot_norm( hitp, stp, rp )
register struct hit	*hitp;
struct soltab		*stp;
register struct xray	*rp;
d1225 1
a1225 4
rt_bot_curve( cvp, hitp, stp )
register struct curvature *cvp;
register struct hit	*hitp;
struct soltab		*stp;
d1243 1
a1243 5
rt_bot_uv( ap, stp, hitp, uvp )
struct application	*ap;
struct soltab		*stp;
register struct hit	*hitp;
register struct uvcoord	*uvp;
d1251 1
a1251 2
rt_bot_free( stp )
register struct soltab *stp;
d1286 1
a1286 4
rt_bot_class( stp, min, max, tol )
const struct soltab    *stp;
const vect_t		min, max;
const struct bn_tol    *tol;
d1295 1
a1295 5
rt_bot_plot( vhead, ip, ttol, tol )
struct bu_list		*vhead;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol	*tol;
d1319 1
a1319 5
rt_bot_plot_poly( vhead, ip, ttol, tol )
struct bu_list		*vhead;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol	*tol;
d1362 1
a1362 6
rt_bot_tess( r, m, ip, ttol, tol )
struct nmgregion	**r;
struct model		*m;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol	*tol;
d1459 1
a1459 5
rt_bot_import( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
d1535 1
a1535 5
rt_bot_export( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d1636 1
a1636 5
rt_bot_import5( ip, ep, mat, dbip )
struct rt_db_internal           *ip;
const struct bu_external        *ep;
register const mat_t            mat;
const struct db_i               *dbip;
d1707 1
a1707 5
rt_bot_export5( ep, ip, local2mm, dbip )
struct bu_external              *ep;
const struct rt_db_internal     *ip;
double                          local2mm;
const struct db_i               *dbip;
d1806 1
a1806 5
rt_bot_describe( str, ip, verbose, mm2local )
struct bu_vls		*str;
const struct rt_db_internal	*ip;
int			verbose;
double			mm2local;
d1894 1
a1894 2
rt_bot_ifree( ip )
struct rt_db_internal	*ip;
d1917 1
a1917 5
rt_bot_tnurb( r, m, ip, tol )
struct nmgregion        **r;
struct model            *m;
struct rt_db_internal   *ip;
const struct bn_tol           *tol;
d1923 1
a1923 5
rt_bot_xform( op, mat, ip, free, dbip )
struct rt_db_internal *op, *ip;
const mat_t	mat;
const int free;
struct db_i	*dbip;
d2208 1
a2208 4
rt_bot_tclget( interp, intern, attr )
Tcl_Interp			*interp;
const struct rt_db_internal	*intern;
const char			*attr;
d2449 1
a2449 5
rt_bot_tcladjust( interp, intern, argc, argv )
Tcl_Interp		*interp;
struct rt_db_internal	*intern;
int			argc;
char			**argv;
@


1.100
log
@rt_bot_makesegs() was not correctly handling a one hit case
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.99 2002/03/21 22:00:54 jra Exp $ (BRL)";
d632 3
d639 2
a640 6
			if( i == 0 ) {
				dn = 1,0;
			} else {
				dn = hits[i-1].hit_vpriv[X];
			}
			for( j=i ; j<k ; j++ ) {
d645 95
a739 8
				if( dn * hits[j].hit_vpriv[X] < 0 ) {
					if( keep1 < 0 ) {
						keep1 = j;
						dn = hits[j].hit_vpriv[X];
					} else if( keep2 < 0 ) {
						keep2 = j;
						dn = hits[j].hit_vpriv[X];
						break;
a741 1
			}
d743 1
a743 1
			if( keep2 == -1 ) {
d745 10
a754 8
				if( exits == k - i || enters == k - i ) {
					/* eliminate all but one entrance or exit */
					for( j=k-1 ; j>i ; j-- ) {
						/* delete this hit */
						for( l=j ; l<nhits-1 ; l++ )
							hits[l] = hits[l+1];
						if( psp ) {
							psp->htab.end--;
d756 1
a756 1
						nhits--;
d758 1
a758 3
					i--;
				}
			} else if( keep2 >= 0 ) {
d760 9
a768 7
				for( j=k-1 ; j>=i ; j-- ) {
					if( j != keep1 && j != keep2 ) {
						/* delete this hit */
						for( l=j ; l<nhits-1 ; l++ )
							hits[l] = hits[l+1];
						if( psp ) {
							psp->htab.end--;
a769 1
						nhits--;
d771 1
a772 1
				i--;
d777 7
a783 1

@


1.99
log
@Reformatting for gcc on FREEBSD
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.98 2002/03/21 05:19:22 jra Exp $ (BRL)";
d778 2
a779 1
	} else if( nhits + 1 >= MAXHITS ) {
d781 1
a781 1
		i++;
@


1.98
log
@shot(): Increased minimum "dn" value to 1.0e-9 (experimentally determined)
to eliminate erroneous hit distances.
makesegs(): improved handling of duplicate hits
prep(): non-pieces prep was not initializing solid bounding box
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.97 2002/03/20 01:50:22 jra Exp $ (BRL)";
d603 3
a605 1
		FAST fastf_t dn=hits[i].hit_vpriv[X];
@


1.97
log
@tcladjust() was not allocating memory for face thickness array
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.96 2002/03/19 04:00:28 jra Exp $ (BRL)";
d48 2
d287 2
d596 1
a596 10
	/* Remove duplicate hits.
	 *  We remove one of a pair of hits when they are
	 *	1) close together, and
	 *	2) both "entry" or both "exit" occurrences.
	 *   Two immediate "entry" or two immediate "exit" hits suggest
	 *   that we hit both of two joined faces, while we want to hit only
	 *   one.  An "entry" followed by an "exit" (or vice versa) suggests
	 *   that we grazed an edge, and thus we should leave both
	 *   in the hit list.
	 */
d598 1
a598 1
	register int j;
d603 4
d608 11
a618 4
		dist = hits[i].hit_dist - hits[i+1].hit_dist;
		if( NEAR_ZERO( dist, ap->a_rt_i->rti_tol.dist ) &&
		    hits[i].hit_vpriv[X] * hits[i+1].hit_vpriv[X] > 0)
		    {
d620 1
a620 1
			    hits[j] = hits[j+1];
d626 61
a686 1
		    }
d862 1
a862 1
		if( abs_dn < SQRT_SMALL_FASTF ) {
a886 1

d1019 1
a1019 1
		    if( abs_dn < SQRT_SMALL_FASTF ) {
@


1.96
log
@rt_bot_makesegs() was accessing the rt_piecestate structure even when pieces
were not being used
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.95 2002/02/25 13:57:22 jra Exp $ (BRL)";
d2598 4
d2617 4
@


1.95
log
@Added minimum edge length to bot_decimate constraints
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.94 2002/02/19 03:03:09 jra Exp $ (BRL)";
d46 2
d655 10
a664 2
				(void)rt_htbl_get(&psp->htab);	/* make sure space exists in the hit array */
				hits = psp->htab.hits;
d680 10
a689 2
				(void)rt_htbl_get(&psp->htab);	/* make sure space exists in the hit array */
				hits = psp->htab.hits;
d707 11
a717 5
	(void)rt_htbl_get(&psp->htab);	/* make sure space exists in the hit array */
	hits = psp->htab.hits;
	hits[nhits] = hits[nhits-1];	/* struct copy */
	hits[nhits].hit_vpriv[X] = -hits[nhits].hit_vpriv[X];
	nhits++;
a753 1
#define MAXHITS 128
@


1.94
log
@Fixed a small memory leak (one tri_specific per bot)
added some paranoid pointer clearing
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.93 2002/01/24 15:50:23 jra Exp $ (BRL)";
d3345 2
d3359 2
a3360 1
		       fastf_t max_normal_error )
d3434 2
a3435 43
	/* check if surface is within max_chord_error of vertex to be eliminated */
	/* loop through all affected faces */
	for( i=0 ; i<affected_count ; i++ ) {
	        fastf_t dist;
                fastf_t dot;
		plane_t pla, plb;
		int va, vb, vc;

		/* calculate plane of this face before and after adjustment
		*  if the normal changes too much, do not decimate
		*/

		/* first calculate original face normal (use original BOT face list) */
		va = bot->faces[faces_affected[i]];
		vb = bot->faces[faces_affected[i]+1];
		vc = bot->faces[faces_affected[i]+2];
		VSUB2( v01, &vertices[vb*3], &vertices[va*3] );
		VSUB2( v02, &vertices[vc*3], &vertices[va*3] );
		VCROSS( plb, v01, v02 );
		VUNITIZE( plb );
		plb[3] = VDOT( &vertices[va*3], plb );

		/* do the same using the working face list */
		va = faces[faces_affected[i]];
		vb = faces[faces_affected[i]+1];
		vc = faces[faces_affected[i]+2];
		/* make the proposed decimation changes */
		if( va == v1 ) {
		  va = v2;
		} else if( vb == v1 ) {
		  vb = v2;
		} else if( vc == v1 ) {
		  vc = v2;
		}
		VSUB2( v01, &vertices[vb*3], &vertices[va*3] );
		VSUB2( v02, &vertices[vc*3], &vertices[va*3] );
		VCROSS( pla, v01, v02 );
		VUNITIZE( pla );
		pla[3] = VDOT( &vertices[va*3], pla );

		/* max_normal_error is actually a minimum dot product */
		dot = VDOT( pla, plb );
		if( dot < max_normal_error ) {
d3438 48
d3487 5
a3491 4
		/* check the distance between this new plane and vertex v1 */
		dist = fabs( DIST_PT_PLANE( &vertices[v1*3], pla ) );
		if( dist > max_chord_error ) {
		  return 0;
d3514 2
a3515 1
		 fastf_t max_normal_error )	/* maximum allowable normal error (degrees) */
d3519 1
d3530 3
a3532 1
	if( max_chord_error <= SMALL_FASTF )
d3535 4
a3538 2
	if( max_normal_error <= SMALL_FASTF )
		return 0 ;
d3540 5
a3544 2
	/* convert normal error to something useful (a minimum dot product) */
	max_normal_error = cos( max_normal_error * M_PI / 180.0 );
d3616 1
a3616 1
				       max_chord_error, max_normal_error )) {
d3620 1
a3620 1
				       max_chord_error, max_normal_error )) {
@


1.93
log
@bot decimation on plate mode or surface mode BOTs now checks to avoid eliminating free edges
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.92 2002/01/22 19:01:43 jra Exp $ (BRL)";
d1109 1
a1109 1
	if( bot->bot_facearray )
d1111 2
d1114 1
a1114 1
	if( bot->bot_thickness )
d1116 3
a1118 1
	if( bot->bot_facemode )
d1120 2
d1126 2
a1127 2
		if( tri )
			bu_free( (char *)tri, "bot tri_specific" );
d1130 1
@


1.92
log
@Added bot_decimate command (and support) to MGED
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.91 2001/12/13 19:35:15 jra Exp $ (BRL)";
d3285 44
d3404 15
@


1.91
log
@Fixed bug in rt_bot_makesegs(), needed to use HTBL routines when adding a hit
Added rt_bot_sort_faces()
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.90 2001/12/08 21:11:18 jra Exp $ (BRL)";
d3242 354
@


1.90
log
@Now uses macros to set values for rt_bot_minpieces and rt_tris_per_piece
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.89 2001/11/29 18:10:36 jra Exp $ (BRL)";
d519 1
a519 1
	    bu_log( "rt_bot_makesegs(%s): WARNING: odd number of hits (%d), last hit ignored\n",
d538 1
a538 1
rt_bot_makesegs( hits, nhits, stp, rp, ap, seghead )
d545 1
d613 3
a631 19
#if 0
	static int nerrors = 0;		/* message counter */

	if( nerrors++ < 6 )  {
	    bu_log("rt_bot_makesegs(%s): WARNING %d hits:\n", stp->st_name, nhits);
	    bu_log( "\tray start = (%g %g %g) ray dir = (%g %g %g)\n",
		    V3ARGS( rp->r_pt ), V3ARGS( rp->r_dir ) );
	    for(i=0; i < nhits; i++ )
		{
		    point_t tmp_pt;

		    VJOIN1( tmp_pt, rp->r_pt, hits[i].hit_dist, rp->r_dir );
		    if( hits[i].hit_vpriv[X] < 0.0 && bot->bot_orientation == RT_BOT_CCW )
			bu_log("\tentrance at dist=%f (%g %g %g)\n", hits[i].hit_dist, V3ARGS( tmp_pt ) );
		    else
			bu_log("\texit at dist=%f (%g %g %g)\n", hits[i].hit_dist, V3ARGS( tmp_pt ) );
		}
	}
#endif
d653 2
d670 2
d685 1
d689 2
d820 1
a820 1
	return rt_bot_makesegs( hits, nhits, stp, rp, ap, seghead );
d982 1
a982 1
					stp, rp, ap, seghead );
d1004 1
a1004 1
	(void)rt_bot_makesegs( psp->htab.hits, psp->htab.end, psp->stp, &ap->a_ray, ap, seghead );
d2953 289
@


1.89
log
@Mods to stepping through triangles in pieces shot routine. It now uses indices
rather than incrementing pointer (data may not be contiguous). Also added code
to avoid stepping beyond the last triangle.
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.88 2001/11/26 19:37:16 butler Exp $ (BRL)";
d42 3
a44 3
/* XXX Set this to 32 to enable pieces by default */
int rt_bot_minpieces = 32;
int rt_bot_tri_per_piece = 4;
@


1.88
log
@Added support for multiple triangles per piece.
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.87 2001/11/22 02:12:34 butler Exp $ (BRL)";
a138 2
    bu_log("ntri:%d num_rpps:%d\n", ntri, num_rpps);

d214 1
a214 1

d218 1
a218 1
	    bu_log("trip->tri_surfno:%d != piecenum%d", 
d224 9
a232 1

d302 2
d888 2
d912 8
a919 2
		trip = bot->bot_facearray[piecenum*bot->bot_tri_per_piece];
		for (trinum=bot->bot_tri_per_piece; trinum ; trinum--, trip++){
d924 1
a924 1
			    bu_log("trip->tri_surfno:%d != piecenum%d", 
@


1.87
log
@Report degenerate facets only when in debug mode
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.86 2001/11/16 14:56:30 jra Exp $ (BRL)";
d40 1
a40 1

d44 1
a44 1

d121 1
a121 1
    struct bound_rpp	*minmax;
d129 4
d134 6
a139 1
    stp->st_npieces = ntri;
d146 1
a146 1
	bu_malloc( sizeof(struct bound_rpp) * ntri,
d150 1
d152 1
d155 12
a167 1
	minmax = &stp->st_piece_rpps[surfno];
d177 2
a178 1
	if( bot->bot_mode == RT_BOT_PLATE || bot->bot_mode == RT_BOT_PLATE_NOCOS )  {
a190 3
	minmax->min[X] = minmax->max[X] = trip->tri_A[X];
	minmax->min[Y] = minmax->max[Y] = trip->tri_A[Y];
	minmax->min[Z] = minmax->max[Z] = trip->tri_A[Z];
d213 1
d319 5
a323 2
	 *  For now, each triangle is considered a separate piece.
	 *  These array allocations can't be made until the number of
d348 8
a355 14
/*
 *			R T _ B O T _ M A K E S E G S
 *
 *  Given an array of hits, make segments out of them.
 *  Exactly how this is to be done depends on the mode of the BoT.
 */
HIDDEN int
rt_bot_makesegs( hits, nhits, stp, rp, ap, seghead )
struct hit		*hits;
int			nhits;
struct soltab		*stp;
struct xray		*rp;
struct application	*ap;
struct seg		*seghead;
d357 4
a360 3
	struct bot_specific *bot = (struct bot_specific *)stp->st_specific;
	register struct seg *segp;
	register int i;
a361 1
	RT_CK_SOLTAB(stp);
d363 2
a364 6
	if( bot->bot_mode == RT_BOT_PLATE || bot->bot_mode == RT_BOT_PLATE_NOCOS )
	{
		for( i=0; i < nhits; i++ )
		{
			register int surfno = hits[i].hit_surfno;
			register fastf_t los;
d366 8
a373 10
			if( bot->bot_mode == RT_BOT_PLATE_NOCOS )
			  los = bot->bot_thickness[surfno];
			else
			  {
			    los = bot->bot_thickness[surfno] / hits[i].hit_vpriv[X];
			    if( los < 0.0 )
			      los = -los;
			  }
			if( BU_BITTEST( bot->bot_facemode, hits[i].hit_surfno ) )
			{
d375 2
a376 2
				RT_GET_SEG( segp, ap->a_resource);
				segp->seg_stp = stp;
d379 2
a380 2
				segp->seg_in = hits[i];
				segp->seg_in.hit_vpriv[Z] = 1;
d383 10
a392 12
				segp->seg_out.hit_surfno = surfno;
				segp->seg_out.hit_dist = segp->seg_in.hit_dist + los;
				segp->seg_out.hit_vpriv[X] = segp->seg_in.hit_vpriv[X]; /* ray dir dot normal */
				segp->seg_out.hit_vpriv[Y] = bot->bot_orientation;
				segp->seg_out.hit_vpriv[Z] = -1; /* a clue for rt_bot_norm that this is an exit */
				segp->seg_out.hit_private = segp->seg_in.hit_private;
				segp->seg_out.hit_rayp = &ap->a_ray;

				BU_LIST_INSERT( &(seghead->l), &(segp->l) );
			}
			else
			{
d394 2
a395 2
				RT_GET_SEG( segp, ap->a_resource);
				segp->seg_stp = stp;
d398 7
a404 7
				segp->seg_in.hit_surfno = surfno;
				segp->seg_in.hit_vpriv[X] = hits[i].hit_vpriv[X]; /* ray dir dot normal */
				segp->seg_in.hit_vpriv[Y] = bot->bot_orientation;
				segp->seg_in.hit_vpriv[Z] = 1;
				segp->seg_in.hit_private = hits[i].hit_private;
				segp->seg_in.hit_dist = hits[i].hit_dist - (los*0.5 );
				segp->seg_in.hit_rayp = &ap->a_ray;
d407 7
a413 7
				segp->seg_out.hit_surfno = surfno;
				segp->seg_out.hit_dist = segp->seg_in.hit_dist + los;
				segp->seg_out.hit_vpriv[X] = segp->seg_in.hit_vpriv[X]; /* ray dir dot normal */
				segp->seg_out.hit_vpriv[Y] = bot->bot_orientation;
				segp->seg_out.hit_vpriv[Z] = -1;
				segp->seg_out.hit_private = hits[i].hit_private;
				segp->seg_out.hit_rayp = &ap->a_ray;
d415 1
a415 5
				BU_LIST_INSERT( &(seghead->l), &(segp->l) );
			}
		}
		/* Every hit turns into two, and makes a seg.  No leftovers */
		return( nhits*2 );
d417 3
d421 36
a456 6
	if( bot->bot_mode == RT_BOT_SURFACE )
	{
		for( i=0 ; i<nhits ; i++ )
		{
			RT_GET_SEG( segp, ap->a_resource );
			segp->seg_stp = stp;
d458 12
a469 11
			/* set in hit */
			segp->seg_in = hits[i];
			segp->seg_in.hit_vpriv[Z] = 1;

			/* set out hit */
			segp->seg_out = hits[i];
			segp->seg_out.hit_vpriv[Z] = -1;
			BU_LIST_INSERT( &(seghead->l), &(segp->l) );
		}
		/* Every hit turns into two, and makes a seg.  No leftovers */
		return( nhits*2 );
d471 2
d474 2
a475 1
	BU_ASSERT( bot->bot_mode == RT_BOT_SOLID );
d477 29
a505 7
	if( bot->bot_orientation == RT_BOT_UNORIENTED )
	{
		/*
		 *  RT_BOT_SOLID, RT_BOT_UNORIENTED.
		 */
		fastf_t rm_dist=0.0;
		int	removed=0;
d507 13
a519 13
		if( nhits == 1 )
		{
			/* make a zero length partition */
			RT_GET_SEG( segp, ap->a_resource );
			segp->seg_stp = stp;

			/* set in hit */
			segp->seg_in = hits[0];
			segp->seg_in.hit_vpriv[Z] = 1;

			/* set out hit */
			segp->seg_out = hits[0];
			segp->seg_out.hit_vpriv[Z] = -1;
a520 3
			BU_LIST_INSERT( &(seghead->l), &(segp->l) );
			return( 1 );
		}
a521 3
		/* Remove duplicate hits */
		{
			register int j;
d523 25
a547 16
			for( i=0 ; i<nhits-1 ; i++ )
			{
				fastf_t dist;

				dist = hits[i].hit_dist - hits[i+1].hit_dist;
				if( NEAR_ZERO( dist, ap->a_rt_i->rti_tol.dist ) )
				{
					removed++;
					rm_dist = hits[i+1].hit_dist;
					for( j=i ; j<nhits-1 ; j++ )
						hits[j] = hits[j+1];
					nhits--;
					i--;
				}
			}
		}
d549 5
a553 2
		if( nhits == 1 )
			return( 0 );
d555 3
a557 17
		if( nhits&1 && removed ) {
			/* If we have an odd number of hits and have removed
			 * a duplicate, then it was likely on an edge, so
			 * remove the one we left.
			 */
			register int j;

			for( i=0 ; i<nhits ; i++ ) {
				if( hits[i].hit_dist == rm_dist ) {
					for( j=i ; j<nhits-1 ; j++ )
						hits[j] = hits[j+1];
					nhits--;
					i--;
					break;
				}
			}
		}
d559 8
a566 4
		for( i=0 ; i<(nhits&~1) ; i += 2 )
		{
			RT_GET_SEG( segp, ap->a_resource );
			segp->seg_stp = stp;
d568 1
a568 7
			/* set in hit */
			segp->seg_in = hits[i];
			segp->seg_in.hit_vpriv[Z] = 1;

			/* set out hit */
			segp->seg_out = hits[i+1];
			segp->seg_out.hit_vpriv[Z] = -1;
d570 4
a573 14
			BU_LIST_INSERT( &(seghead->l), &(segp->l) );
		}
		if( nhits&1 )
		{
			if( RT_G_DEBUG & DEBUG_SHOOT ) {
				bu_log( "rt_bot_makesegs(%s): WARNING: odd number of hits (%d), last hit ignored\n",
					stp->st_name, nhits );
				bu_log( "\tray = -p %g %g %g -d %g %g %g\n",
					V3ARGS( rp->r_pt ), V3ARGS( rp->r_dir ) );
			}
			nhits--;
		}
		return( nhits );
	}
d575 1
a575 1
	/*
d591 31
a621 2
	{
		register int j;
d623 5
a627 1
		for( i=0 ; i<nhits-1 ; i++ )
d629 1
a629 1
			FAST fastf_t dist;
d631 5
a635 9
			dist = hits[i].hit_dist - hits[i+1].hit_dist;
			if( NEAR_ZERO( dist, ap->a_rt_i->rti_tol.dist ) &&
				hits[i].hit_vpriv[X] * hits[i+1].hit_vpriv[X] > 0)
			{
				for( j=i ; j<nhits-1 ; j++ )
					hits[j] = hits[j+1];
				nhits--;
				i--;
			}
d638 24
d663 11
a673 33
	if( (nhits&1) )  {
		register int i;
		/*
		 * If this condition exists, it is almost certainly due to
		 * the dn==0 check above.  Thus, we will make the last
		 * surface rather thin.
		 * This at least makes the
		 * presence of this solid known.  There may be something
		 * better we can do.
		 */
#if 0
		static int nerrors = 0;		/* message counter */

		if( nerrors++ < 6 )  {
			bu_log("rt_bot_makesegs(%s): WARNING %d hits:\n", stp->st_name, nhits);
			bu_log( "\tray start = (%g %g %g) ray dir = (%g %g %g)\n",
				V3ARGS( rp->r_pt ), V3ARGS( rp->r_dir ) );
			for(i=0; i < nhits; i++ )
			{
				point_t tmp_pt;

				VJOIN1( tmp_pt, rp->r_pt, hits[i].hit_dist, rp->r_dir );
				if( hits[i].hit_vpriv[X] < 0.0 && bot->bot_orientation == RT_BOT_CCW )
					bu_log("\tentrance at dist=%f (%g %g %g)\n", hits[i].hit_dist, V3ARGS( tmp_pt ) );
				else
					bu_log("\texit at dist=%f (%g %g %g)\n", hits[i].hit_dist, V3ARGS( tmp_pt ) );
			}
		}
#endif
		if( nhits > 2 )
		{
			fastf_t dot1,dot2;
			int j;
d675 2
a676 2
			/* likely an extra hit,
			 * look for consecutive entrances or exits */
d678 2
a679 5
			dot2 = 1.0;
			i = 0;
			while( i<nhits )
			{
				dot1 = dot2;
d681 8
a688 36
				if( dot1 > 0.0 && dot2 > 0.0 )
				{
					/* two consectutive exits,
					 * manufacture an entrance at same distance
					 * as second exit.
					 */
					/* XXX This consumes an extra hit structure in the array */
					for( j=nhits ; j>i ; j-- )
						hits[j] = hits[j-1];	/* struct copy */

					hits[i].hit_vpriv[X] = -hits[i].hit_vpriv[X];
					dot2 = hits[i].hit_vpriv[X];
					nhits++;
					bu_log( "\t\tadding fictitious entry at %f (%s)\n", hits[i].hit_dist, stp->st_name );
				}
				else if( dot1 < 0.0 && dot2 < 0.0 )
				{
					/* two consectutive entrances,
					 * manufacture an exit between them.
					 */
					/* XXX This consumes an extra hit structure in the array */

					for( j=nhits ; j>i ; j-- )
						hits[j] = hits[j-1];	/* struct copy */

					hits[i] = hits[i-1];	/* struct copy */
					hits[i].hit_vpriv[X] = -hits[i].hit_vpriv[X];
					dot2 = hits[i].hit_vpriv[X];
					nhits++;
					bu_log( "\t\tadding fictitious exit at %f (%s)\n", hits[i].hit_dist, stp->st_name );
				}
				i++;
			}
		}
	}
	if( (nhits&1) )  {
d690 4
a693 4
		/* XXX This consumes an extra hit structure in the array */
		hits[nhits] = hits[nhits-1];	/* struct copy */
		hits[nhits].hit_vpriv[X] = -hits[nhits].hit_vpriv[X];
		nhits++;
d695 1
a695 1
		nhits--;
d697 1
a697 1
	}
d699 10
a708 10
	/* nhits is even, build segments */
	for( i=0; i < nhits; i += 2 )  {
		RT_GET_SEG(segp, ap->a_resource);
		segp->seg_stp = stp;
		segp->seg_in = hits[i];		/* struct copy */
		segp->seg_in.hit_vpriv[Z] = 1;
		segp->seg_out = hits[i+1];	/* struct copy */
		segp->seg_out.hit_vpriv[Z] = -1;
		BU_LIST_INSERT( &(seghead->l), &(segp->l) );
	}
d710 1
a710 1
	return(nhits);			/* HIT */
d853 1
d864 3
a866 1
	if( bot->bot_orientation != RT_BOT_UNORIENTED && bot->bot_mode == RT_BOT_SOLID ) {
d881 1
a881 1

d885 4
a888 1
			if(debug_shoot) bu_log("%s piece %d already shot\n", stp->st_name, piecenum);
d898 3
a900 11
		/* Now intersect with each piece */
		trip = bot->bot_facearray[piecenum];
		if (trip->tri_surfno != piecenum) {
		    bu_log("trip->tri_surfno:%d != piecenum%d", 
			   trip->tri_surfno, piecenum);
		}
		BU_ASSERT_LONG(trip->tri_surfno, ==, piecenum);

		/*
		 *  Ray Direction dot N.  (N is outward-pointing normal)
		 *  wn points inwards, and is not unit length.
d902 2
a903 1
		dn = VDOT( trip->tri_wn, rp->r_dir );
d905 19
a923 6
		/*
		 *  If ray lies directly along the face, (ie, dot product
		 *  is zero), drop this face.
		 */
		abs_dn = dn >= 0.0 ? dn : (-dn);
		if( abs_dn < SQRT_SMALL_FASTF ) {
d925 10
a934 10
		}
		VSUB2( wxb, trip->tri_A, rp->r_pt );
		VCROSS( xp, wxb, rp->r_dir );

		dn_plus_tol = toldist + abs_dn;

		/* Check for exceeding along the one side */
		alpha = VDOT( trip->tri_CA, xp );
		if( dn < 0.0 )  alpha = -alpha;
		if( alpha < -toldist || alpha > dn_plus_tol ) {
d936 1
a936 1
		}
d938 4
a941 4
		/* Check for exceeding along the other side */
		beta = VDOT( trip->tri_BA, xp );
		if( dn > 0.0 )  beta = -beta;
		if( beta < -toldist || beta > dn_plus_tol ) {
d943 2
a944 2
		}
		if( alpha+beta > dn_plus_tol ) {
d946 17
a962 2
		}
		k = VDOT( wxb, trip->tri_wn ) / dn;
a963 11
		/* HIT is within planar face */
		hp = rt_htbl_get( &psp->htab );
		hp->hit_magic = RT_HIT_MAGIC;
		hp->hit_dist = k + dist_corr;
		hp->hit_private = (genptr_t)trip;
		hp->hit_vpriv[X] = VDOT( trip->tri_N, rp->r_dir );
		hp->hit_vpriv[Y] = bot->bot_orientation;
		hp->hit_surfno = trip->tri_surfno;
		hp->hit_rayp = &ap->a_ray;
		if(debug_shoot) bu_log("%s piece %d ... HIT %g\n", stp->st_name, piecenum, hp->hit_dist);
	}
d965 2
a966 2
	    (bot->bot_mode == RT_BOT_PLATE || bot->bot_mode == RT_BOT_PLATE_NOCOS) )
	{
d968 3
a970 2
		 * Each of these hits is really two, resulting in an instant seg.
		 * Saving an odd number of these will confuse a_onehit processing.
d973 2
a974 1
		return rt_bot_makesegs( psp->htab.hits, psp->htab.end, stp, rp, ap, seghead );
@


1.86
log
@shot routines now use tolerance for calculating triangle hits (for oriented solid BOTS only)
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.85 2001/11/08 22:32:28 jra Exp $ (BRL)";
d86 6
a91 5
	    	{
			bu_log("%s: degenerate facet #%d\n",
				stp->st_name, face_no);
	    		bu_log( "\t(%g %g %g) (%g %g %g) (%g %g %g)\n",
	    			V3ARGS( ap ), V3ARGS( bp ), V3ARGS( cp ) );
@


1.85
log
@Mods to rt_bot_vertex_fuse(). It was missing some fusable vertices
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.84 2001/11/08 15:41:45 butler Exp $ (BRL)";
a469 3
					if( RT_G_DEBUG & DEBUG_SHOOT ) {
						bu_log( "Removing duplicate hit on %s at dist %g, ray = -p %g %g %g -d %g %g %g\n", stp->st_name, rm_dist, V3ARGS( rp->r_pt ), V3ARGS( rp->r_dir ) );
					}
a491 3
					if( RT_G_DEBUG & DEBUG_SHOOT ) {
						bu_log( "Removing the other hit on %s at dist = %g\n", stp->st_name, rm_dist );
					}
d697 1
d701 5
d727 1
a727 1
		if( abs_dn < SQRT_SMALL_FASTF )
d729 1
d733 2
d738 1
a738 1
		if( alpha < 0.0 || alpha > abs_dn )
d740 1
d745 1
a745 1
		if( beta < 0.0 || beta > abs_dn )
d747 2
a748 1
		if( alpha+beta > abs_dn )
d750 1
d806 1
d817 6
d865 1
a865 1
		if( abs_dn < SQRT_SMALL_FASTF )
d867 1
d871 2
d876 1
a876 1
		if( alpha < 0.0 || alpha > abs_dn )
d878 1
d883 1
a883 1
		if( beta < 0.0 || beta > abs_dn )
d885 2
a886 1
		if( alpha+beta > abs_dn )
d888 1
@


1.84
log
@A few extra comments so we can tell what the #@@$ is going on.
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.83 2001/11/07 19:35:38 butler Exp $ (BRL)";
a235 2
	bu_log("bot_shot()\n");

d2632 2
a2633 2
		for( j=i+1 ; j<bot->num_vertices ; j++ )
		{
d2650 2
@


1.83
log
@Changes to have the ARS use the BOT ray intersection code.
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.82 2001/10/02 19:24:28 jra Exp $ (BRL)";
d2797 5
d2814 3
d2828 3
d2855 3
@


1.82
log
@Routines were not setting idb_major_type in the internal structure
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.81 2001/09/26 20:48:27 jra Exp $ (BRL)";
a40 10
struct bot_specific
{
	unsigned char bot_mode;
	unsigned char bot_orientation;
	unsigned char bot_errmode;
	fastf_t *bot_thickness;
	struct bu_bitv *bot_facemode;
	struct tri_specific *bot_facelist;	/* head of linked list */
	struct tri_specific **bot_facearray;	/* head of face array */
};
d57 8
a64 7
HIDDEN int
rt_botface( stp, bot, ap, bp, cp, face_no, tol )
struct soltab *stp;
struct bot_specific *bot;
fastf_t		*ap, *bp, *cp;
int		face_no;
const struct bn_tol	*tol;
d87 1
a87 1
			bu_log("bot(%s): degenerate facet #%d\n",
d111 97
d236 2
d271 1
a271 1
	if( stp->st_specific == (genptr_t)0 )  {
d312 1
a312 74
	stp->st_npieces = ntri;

	bot->bot_facearray = (struct tri_specific **)
		bu_malloc( sizeof(struct tri_specific *) * ntri,
			"bot_facearray" );

	stp->st_piece_rpps = (struct bound_rpp *)
		bu_malloc( sizeof(struct bound_rpp) * ntri,
			"st_piece_rpps" );

	{
		struct bound_rpp	*minmax;
		const struct tri_specific **fap =
			(const struct tri_specific **)bot->bot_facearray;
		register const struct tri_specific *trip = bot->bot_facelist;
		int surfno = ntri-1;

		for( ; trip; trip = trip->tri_forw, surfno-- )  {
			point_t b,c;
			point_t d,e,f;
			vect_t offset;
			fastf_t los;

			fap[surfno] = trip;
			minmax = &stp->st_piece_rpps[surfno];

			/* It is critical that the surfno's used in
			 * rt error messages (from hit_surfno) match
			 * the tri_surfno values, so that mged users who
			 * run "db get name f#" to see that triangle
			 * get the triangle they're expecting!
			 */
			BU_ASSERT_LONG( trip->tri_surfno, ==, surfno );
			if( bot->bot_mode == RT_BOT_PLATE || bot->bot_mode == RT_BOT_PLATE_NOCOS )  {
				if( BU_BITTEST( bot->bot_facemode, surfno ) )  {
					/* Append full thickness on both sides */
					los = bot->bot_thickness[surfno];
				} else {
					/* Center thickness.  Append 1/2 thickness on both sides */
					los = bot->bot_thickness[surfno] * 0.51;
				}
			} else {
				/* Prevent the RPP from being 0 thickness */
				los = tol->dist;	/* typ 0.005mm */
			}

			minmax->min[X] = minmax->max[X] = trip->tri_A[X];
			minmax->min[Y] = minmax->max[Y] = trip->tri_A[Y];
			minmax->min[Z] = minmax->max[Z] = trip->tri_A[Z];
			VADD2( b, trip->tri_BA, trip->tri_A );
			VADD2( c, trip->tri_CA, trip->tri_A );
			VMINMAX( minmax->min, minmax->max, b );
			VMINMAX( minmax->min, minmax->max, c );

			/* Offset face in +los */
			VSCALE( offset, trip->tri_N, los );
			VADD2( d, trip->tri_A, offset );
			VADD2( e, b, offset );
			VADD2( f, c, offset );
			VMINMAX( minmax->min, minmax->max, d );
			VMINMAX( minmax->min, minmax->max, e );
			VMINMAX( minmax->min, minmax->max, f );

			/* Offset face in -los */
			VSCALE( offset, trip->tri_N, -los );
			VADD2( d, trip->tri_A, offset );
			VADD2( e, b, offset );
			VADD2( f, c, offset );
			VMINMAX( minmax->min, minmax->max, d );
			VMINMAX( minmax->min, minmax->max, e );
			VMINMAX( minmax->min, minmax->max, f );
		}
	}

d832 2
a833 1
			if(debug_shoot) bu_log("%s piece %d ...\n", stp->st_name, piecenum);
d837 4
d989 1
@


1.81
log
@Ifdef'd out some excessive logging
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.80 2001/09/11 12:31:42 jra Exp $ (BRL)";
d1228 1
d1406 1
d1744 1
@


1.80
log
@rt_bot_minpieces is now 32 by default
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.79 2001/09/04 15:26:40 jra Exp $ (BRL)";
a556 1
		static int nerrors = 0;		/* message counter */
d565 2
d583 1
a583 1

a637 1
		bu_log( "\t\tadding fictitious hit at %f (%s)\n", hits[nhits].hit_dist, stp->st_name );
@


1.79
log
@tcl_adjust routine now checks for existence before freeing vertices and faces
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.78 2001/07/22 02:38:16 jra Exp $ (BRL)";
d53 1
a53 1
int rt_bot_minpieces = 0;
@


1.78
log
@Initialized a variable for the compiler
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.77 2001/07/09 21:28:48 jra Exp $ (BRL)";
d2293 2
a2294 1
		      bu_free( (char *)bot->vertices, "BOT vertices" );
d2371 2
a2372 1
			bu_free( (char *)bot->faces, "BOT faces" );
@


1.77
log
@A bit more checking to avoid odd number of hits
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.76 2001/05/17 20:05:24 morrison Exp $ (BRL)";
d423 1
a423 1
		fastf_t rm_dist;
@


1.76
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.75 2001/05/02 19:31:42 jra Exp $ (BRL)";
d423 3
d455 5
d471 21
d509 6
a514 2
			bu_log( "rt_bot_makesegs(%s): WARNING: odd number of hits (%d), last hit ignored\n",
				stp->st_name, nhits );
@


1.75
log
@Made the code not dependent on BU_BITTEST returning 0 or 1
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.74 2001/04/20 22:29:42 morrison Exp $ (BRL)";
d750 1
a750 1
	const int	debug_shoot = rt_g.debug & DEBUG_SHOOT;
@


1.74
log
@CONST to const
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.73 2001/04/13 14:13:45 jra Exp $ (BRL)";
d2016 1
a2016 1
							los[BU_BITTEST( bot->face_mode, i )] );
d2665 1
a2665 1
						BU_BITTEST( bot->face_mode, i ) != BU_BITTEST( bot->face_mode, j ) )
@


1.73
log
@Added tclform for BoT solid
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.72 2001/04/05 19:35:34 morrison Exp $ (BRL)";
d73 1
a73 1
CONST struct bn_tol	*tol;
@


1.72
log
@updated SIGNED to signed
updated CONST to const
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.71 2001/03/19 22:19:57 butler Exp $ (BRL)";
d2539 11
@


1.71
log
@patches to merge 5.3 into 6.0
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /d/CVS/brlcad/librt/g_bot.c,v 1.70 2000/11/17 06:01:57 mike Exp $ (BRL)";
d142 1
a142 1
	CONST struct bn_tol		*tol = &rtip->rti_tol;
d234 3
a236 3
		CONST struct tri_specific **fap =
			(CONST struct tri_specific **)bot->bot_facearray;
		register CONST struct tri_specific *trip = bot->bot_facelist;
d304 1
a304 1
register CONST struct soltab *stp;
d750 1
a750 1
	CONST int	debug_shoot = rt_g.debug & DEBUG_SHOOT;
d987 3
a989 3
CONST struct soltab    *stp;
CONST vect_t		min, max;
CONST struct bn_tol    *tol;
d1001 2
a1002 2
CONST struct rt_tess_tol *ttol;
CONST struct bn_tol	*tol;
d1029 2
a1030 2
CONST struct rt_tess_tol *ttol;
CONST struct bn_tol	*tol;
d1077 2
a1078 2
CONST struct rt_tess_tol *ttol;
CONST struct bn_tol	*tol;
d1177 3
a1179 3
CONST struct bu_external	*ep;
register CONST mat_t		mat;
CONST struct db_i		*dbip;
d1214 1
a1214 1
		ntohd( (unsigned char *)tmp, (CONST unsigned char *)(&rp->bot.bot_data[i*24]), 3 );
d1224 3
a1226 3
		bot_ip->faces[i*3] = bu_glong( (CONST unsigned char *)&rp->bot.bot_data[index] );
		bot_ip->faces[i*3 + 1] = bu_glong( (CONST unsigned char *)&rp->bot.bot_data[index + 4] );
		bot_ip->faces[i*3 + 2] = bu_glong( (CONST unsigned char *)&rp->bot.bot_data[index + 8] );
d1236 2
a1237 2
				(CONST unsigned char *)(&rp->bot.bot_data[chars_used + i*8]), 1 );
		bot_ip->face_mode = bu_hex_to_bitv( (CONST char *)(&rp->bot.bot_data[chars_used + bot_ip->num_faces * 8]) );
d1256 1
a1256 1
CONST struct rt_db_internal	*ip;
d1258 1
a1258 1
CONST struct db_i		*dbip;
d1323 1
a1323 1
		htond( (unsigned char *)&rec->bot.bot_data[i*24], (CONST unsigned char *)tmp, 3 );
d1345 1
a1345 1
			htond( (unsigned char *)&rec->bot.bot_data[chars_used], (CONST unsigned char *)&tmp, 1 );
d1361 3
a1363 3
CONST struct bu_external        *ep;
register CONST mat_t            mat;
CONST struct db_i               *dbip;
d1395 1
a1395 1
		ntohd( (unsigned char *)tmp, (CONST unsigned char *)cp, 3 );
d1418 1
a1418 1
		bip->face_mode = bu_hex_to_bitv( (CONST char *)cp );
d1435 1
a1435 1
CONST struct rt_db_internal     *ip;
d1437 1
a1437 1
CONST struct db_i               *dbip;
d1507 1
a1507 1
			htond( cp, (CONST unsigned char *)&tmp, 1 );
d1538 1
a1538 1
CONST struct rt_db_internal	*ip;
d1656 1
a1656 1
CONST struct bn_tol           *tol;
d1664 2
a1665 2
CONST mat_t	mat;
CONST int free;
d1952 2
a1953 2
CONST struct rt_db_internal	*intern;
CONST char			*attr;
@


1.70
log
@
Modified MGED's "fast path" through the "ev" command for drawing polygonal
objects to (a) use the g_xxx.c plot routine rather than duplicating the
code, and (b) added methods for drawing the polygonal version.
Extended fast path to work for Bots.
Also included fixes in new DGO stuff.
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.69 2000/11/13 13:41:30 jra Exp $ (BRL)";
a298 1

a2218 1
				bu_log( "fm=%s\n", argv[1] );
d2302 2
a2303 1
		       while( isspace( *v_str ) ) v_str++;
d2342 2
a2343 1
			     while( isspace( *f_str ) ) f_str++;
d2379 1
a2379 1
			while( isspace( *f_str ) ) f_str++;
@


1.69
log
@rt_botface() was using tol->dist to prune list of faces, this was too large a tolerance.
Changed it to the same tolerance that proe-g and stl-g use.
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.68 2000/11/13 13:37:13 jra Exp $ (BRL)";
d1018 43
@


1.68
log
@Correct rt_bot_norm() handling of plate mode
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.67 2000/11/07 19:51:09 jra Exp $ (BRL)";
d92 2
a93 2
	if( m1 < tol->dist || m2 < tol->dist ||
	    m3 < tol->dist || m4 < tol->dist )  {
@


1.67
log
@makesegs was missing some hit_rayp assignments
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.66 2000/11/01 06:46:12 mike Exp $ (BRL)";
d895 1
d899 1
a899 1
	if( hitp->hit_vpriv[Y] == RT_BOT_UNORIENTED )
@


1.66
log
@
Needed seghead paramater to ft_piece_shot() to properly handle
PLATE-mode intersections, where one hit yeilds two hits
and a complete segment, all at once.
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.65 2000/10/24 18:18:00 mike Exp $ (BRL)";
d362 1
d707 1
@


1.65
log
@
More BoT function definitions
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.64 2000/10/24 14:36:26 mike Exp $ (BRL)";
d729 4
a732 2
 *  Complete (2 hit) segments will be returned as they're completed,
 *  with possibly one left-over hit being stashed between invocations.
d735 1
a735 1
rt_bot_piece_shot( psp, plp, dist_corr, rp, ap )
d741 1
d828 10
@


1.64
log
@
Added rt_bot_ prefix to all the BoT support routines,
and registered them in raytrace.h
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.63 2000/10/18 15:32:40 jra Exp $ (BRL)";
d1671 3
a1673 3
	CONST struct rt_bot_internal *bot,
	CONST point_t	pt2,
	CONST mat_t	mat)
d1728 3
a1730 3
	CONST struct rt_bot_internal *bot,
	CONST point_t	pt2,
	CONST mat_t	mat)
@


1.63
log
@Fixed a bug in db_tcl_adjust()
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.62 2000/09/12 19:08:41 jra Exp $ (BRL)";
d1670 4
a1673 4
bot_find_v_nearest_pt2( bot, pt2, mat )
CONST struct rt_bot_internal *bot;
CONST point_t	pt2;
CONST mat_t	mat;
d1702 1
a1702 2
bot_edge_in_list( v1, v2, edge_list, edge_count )
CONST int v1, v2, edge_count, edge_list[];
d1725 6
a1730 5
bot_find_e_nearest_pt2( vert1, vert2, bot, pt2, mat)
int *vert1, *vert2;
CONST struct rt_bot_internal *bot;
CONST point_t	pt2;
CONST mat_t	mat;
d1753 1
a1753 1
		if( !bot_edge_in_list( v1, v2, edge_list, edge_count ) )
d1759 1
a1759 1
		if( !bot_edge_in_list( v3, v2, edge_list, edge_count ) )
d1765 1
a1765 1
		if( !bot_edge_in_list( v1, v3, edge_list, edge_count ) )
a2134 15
char *
next_tok( str )
char *str;
{
  char *ret;

  ret = str;
  while( !isspace( *ret ) && *ret !='\0' )
    ret++;
  while( isspace( *ret ) )
    ret++;

  return( ret );
}

d2216 1
a2216 1
			  v_str = next_tok( v_str );
d2224 1
a2224 1
			  v_str = next_tok( v_str );
d2247 1
a2247 1
		      v_str = next_tok( v_str );
d2255 1
a2255 1
		      v_str = next_tok( v_str );
d2292 1
a2292 1
			    f_str = next_tok( f_str );
d2300 1
a2300 1
			    f_str = next_tok( f_str );
d2322 1
a2322 1
			f_str = next_tok( f_str );
d2330 1
a2330 1
			f_str = next_tok( f_str );
d2482 6
d2494 1
a2494 2
bot_vertex_fuse( bot )
struct rt_bot_internal *bot;
d2529 1
a2529 2
same_orientation( a, b )
int *a, *b;
d2551 1
a2551 2
bot_face_fuse( bot )
struct rt_bot_internal *bot;
d2607 1
a2607 1
						if( same_orientation( &bot->faces[i*3], &bot->faces[j*3] ) )
d2667 1
a2667 2
bot_condense( bot )
struct rt_bot_internal *bot;
@


1.62
log
@bot_vertex_fuse() noew eliminates unused vertices
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.61 2000/08/21 02:02:29 butler Exp $ (BRL)";
d1620 1
a1620 1
		RT_CK_DB_INTERNAL( op );
d2223 1
d2260 1
d2299 1
d2335 1
@


1.61
log
@Massive compilation warnings eliminated
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.60 2000/08/17 20:54:55 jra Exp $ (BRL)";
d2495 1
a2495 1
 *	The unused vertices are not removed (bot_condense will do that).
a2508 3
		point_t pt1;

		VMOVE( pt1, &bot->vertices[i*3] );
a2510 4
			point_t pt2;

			VMOVE( pt2, &bot->vertices[j*3] );

d2512 1
a2512 1
			if( VEQUAL( pt1, pt2 ) )
d2515 3
d2524 2
@


1.60
log
@Eliminated an unecessary error message
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.59 2000/07/10 23:01:30 mike Exp $ (BRL)";
d30 1
d55 64
a300 63
 *			R T _ B O T F A C E
 *
 *  This function is called with pointers to 3 points,
 *  and is used to prepare BOT faces.
 *  ap, bp, cp point to vect_t points.
 *
 * Return -
 *	0	if the 3 points didn't form a plane (eg, colinear, etc).
 *	#pts	(3) if a valid plane resulted.
 */
HIDDEN int
rt_botface( stp, bot, ap, bp, cp, face_no, tol )
struct soltab *stp;
struct bot_specific *bot;
fastf_t		*ap, *bp, *cp;
int		face_no;
CONST struct bn_tol	*tol;
{
	register struct tri_specific *trip;
	vect_t work;
	LOCAL fastf_t m1, m2, m3, m4;

	BU_GETSTRUCT( trip, tri_specific );
	VMOVE( trip->tri_A, ap );
	VSUB2( trip->tri_BA, bp, ap );
	VSUB2( trip->tri_CA, cp, ap );
	VCROSS( trip->tri_wn, trip->tri_BA, trip->tri_CA );
	trip->tri_surfno = face_no;

	/* Check to see if this plane is a line or pnt */
	m1 = MAGNITUDE( trip->tri_BA );
	m2 = MAGNITUDE( trip->tri_CA );
	VSUB2( work, bp, cp );
	m3 = MAGNITUDE( work );
	m4 = MAGNITUDE( trip->tri_wn );
	if( m1 < tol->dist || m2 < tol->dist ||
	    m3 < tol->dist || m4 < tol->dist )  {
		bu_free( (char *)trip, "getstruct tri_specific");
	    	{
			bu_log("bot(%s): degenerate facet #%d\n",
				stp->st_name, face_no);
	    		bu_log( "\t(%g %g %g) (%g %g %g) (%g %g %g)\n",
	    			V3ARGS( ap ), V3ARGS( bp ), V3ARGS( cp ) );
	    	}
		return(0);			/* BAD */
	}		

	/*  wn is a normal of not necessarily unit length.
	 *  N is an outward pointing unit normal.
	 *  We depend on the points being given in CCW order here.
	 */
	VMOVE( trip->tri_N, trip->tri_wn );
	VUNITIZE( trip->tri_N );
	if( bot->bot_mode == RT_BOT_CW )
		VREVERSE( trip->tri_N, trip->tri_N )

	/* Add this face onto the linked list for this solid */
	trip->tri_forw = bot->bot_facelist;
	bot->bot_facelist = trip;
	return(3);				/* OK */
}

/*
a837 2
	int ret;

@


1.59
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d18 1
a18 1
static const char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.58 2000/06/30 15:38:02 mike Exp $ (BRL)";
d457 3
@


1.58
log
@
export methods should not init the external structure, just check them.
@
text
@d18 1
a18 1
static char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.57 2000/06/30 15:31:14 mike Exp $ (BRL)";
@


1.57
log
@
The import/export and import5/export5 methods must NOT
re-initialize their rt_db_internal* pointer, they should just check it.
@
text
@d18 1
a18 1
static char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.56 2000/06/29 14:41:23 jra Exp $ (BRL)";
d1212 1
a1212 1
	BU_INIT_EXTERNAL(ep);
d1389 1
a1389 1
	BU_INIT_EXTERNAL( ep );
@


1.56
log
@Added some casts to make SGI compiler happy
@
text
@d18 1
a18 1
static char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.55 2000/06/28 18:22:20 jra Exp $ (BRL)";
d1133 1
a1133 1
	RT_INIT_DB_INTERNAL( ip );
d1310 1
a1310 1
	RT_INIT_DB_INTERNAL( ip );
d1617 1
a1617 1
		RT_INIT_DB_INTERNAL( op );
@


1.55
log
@Added some v5 database suport
@
text
@d18 1
a18 1
static char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.54 2000/06/19 18:19:31 jra Exp $ (BRL)";
d1357 1
a1357 1
		bip->face_mode = bu_hex_to_bitv( cp );
d1449 1
a1449 1
		strcpy( cp, bu_vls_addr( &vls ) );
@


1.54
log
@Allowed tesselator to build a 2-manifold for plate mode bots
@
text
@d18 1
a18 1
static char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.53 2000/06/05 23:45:51 mike Exp $ (BRL)";
d1292 164
@


1.54.2.1
log
@A single hit is now silently ignored
@
text
@d18 1
a18 1
static char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.54 2000/06/19 18:19:31 jra Exp $ (BRL)";
a456 3

		if( nhits == 1 )
			return( 0 );
@


1.54.2.2
log
@Improved bot_fuse() to run faster and delete excess vertices as it goes
@
text
@d18 1
a18 1
static char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.54.2.1 2000/08/18 12:44:51 jra Exp $ (BRL)";
d2331 1
a2331 1
 *	The unused vertices are removed.
d2345 3
d2350 4
d2355 1
a2355 1
			if( VEQUAL( &bot->vertices[i*3], &bot->vertices[j*3] ) )
a2357 3
				bot->num_vertices--;
				for( k=j ; k<bot->num_vertices ; k++ )
					VMOVE( &bot->vertices[k*3] , &bot->vertices[(k+1)*3] );
a2363 2
					else if ( bot->faces[k] > j )
						bot->faces[k]--;
@


1.54.2.3
log
@Fixed bug in tcl_adjust routine
@
text
@d18 1
a18 1
static char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.54.2.2 2000/09/01 14:35:17 jra Exp $ (BRL)";
a2058 1
			  while( isspace( *v_str ) ) v_str++;
a2094 1
		      while( isspace( *v_str ) ) v_str++;
a2132 1
			    while( isspace( *f_str ) ) f_str++;
a2167 1
		      	while( isspace( *f_str ) ) f_str++;
@


1.54.2.4
log
@rt_botface() was using tol->dist to prune list of faces, this was too large a tolerance.
Changed it to the same tolerance that proe-g and stl-g use.
@
text
@d18 1
a18 1
static char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.54.2.3 2000/10/18 17:20:36 jra Exp $ (BRL)";
d271 2
a272 2
	if( m1 < 0.00001 || m2 < 0.00001 ||
	    m3 < 0.00001 || m4 < 0.00001 )  {
@


1.54.2.5
log
@Mike's changes to handle plate mode BOTS in renderings
@
text
@d18 1
a18 1
static char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.54.2.4 2000/10/26 12:42:09 jra Exp $ (BRL)";
d727 2
a728 4
 *
 *  Plate-mode (2 hit) segments will be returned immediately in seghead.
 *
 *  Generally the hits are stashed between invocations in psp.
d731 1
a731 1
rt_bot_piece_shot( psp, plp, dist_corr, rp, ap, seghead )
a736 1
struct seg		*seghead;
a822 10
	}
	if( psp->htab.end > 0 &&
	    (bot->bot_mode == RT_BOT_PLATE || bot->bot_mode == RT_BOT_PLATE_NOCOS) )
	{
		/*
		 * Each of these hits is really two, resulting in an instant seg.
		 * Saving an odd number of these will confuse a_onehit processing.
		 */
		rt_hitsort( psp->htab.hits, psp->htab.end );
		return rt_bot_makesegs( psp->htab.hits, psp->htab.end, stp, rp, ap, seghead );
@


1.54.2.6
log
@Eliminated a stray call to bu_log()
@
text
@d18 1
a18 1
static char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.54.2.5 2000/11/01 18:43:54 jra Exp $ (BRL)";
d2025 1
@


1.54.2.7
log
@makesegs was missing some hit_rayp assignments
@
text
@d18 1
a18 1
static char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.54.2.6 2000/11/04 02:41:23 jra Exp $ (BRL)";
a359 1
				segp->seg_out.hit_rayp = &ap->a_ray;
a703 1
		hp->hit_rayp = &ap->a_ray;
@


1.54.2.8
log
@Correct rt_bot_norm() handling of plate mode
@
text
@d18 1
a18 1
static char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.54.2.7 2000/11/07 19:48:13 jra Exp $ (BRL)";
a894 1
	struct bot_specific *bot=(struct bot_specific *)stp->st_specific;
d898 1
a898 1
	if( hitp->hit_vpriv[Y] == RT_BOT_UNORIENTED || bot->bot_mode == RT_BOT_PLATE || bot->bot_mode == RT_BOT_PLATE_NOCOS  )
@


1.54.2.9
log
@Backporting bug fixes for release 5.4
@
text
@d18 1
a18 1
static char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.54.2.8 2000/11/09 14:41:52 jra Exp $ (BRL)";
a421 3
		fastf_t rm_dist;
		int	removed=0;

a450 2
					removed++;
					rm_dist = hits[i+1].hit_dist;
a460 18

		if( nhits&1 && removed ) {
			/* If we have an odd number of hits and have removed
			 * a duplicate, then it was likely on an edge, so
			 * remove the one we left.
			 */
			register int j;

			for( i=0 ; i<nhits ; i++ ) {
				if( hits[i].hit_dist == rm_dist ) {
					for( j=i ; j<nhits-1 ; j++ )
						hits[j] = hits[j+1];
					nhits--;
					i--;
					break;
				}
			}
		}
@


1.53
log
@
Disabled "solid pieces" code for BoTs, until odd RTG3 behavior can
be investigated.
@
text
@d18 1
a18 1
static char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.52 2000/06/05 23:44:47 mike Exp $ (BRL)";
d1028 1
a1028 1

d1031 1
a1031 1

@


1.52
log
@
Added #ifdef
@
text
@d18 1
a18 1
static char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.51 2000/06/05 21:17:30 jra Exp $ (BRL)";
d51 2
a52 1
int rt_bot_minpieces = 32;
@


1.51
log
@Made bot_free a bit more careful
@
text
@d18 1
a18 1
static char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.50 2000/05/24 01:00:08 mike Exp $ (BRL)";
d594 1
d600 3
@


1.50
log
@
Revised how 'solid pieces' state is managed from cell to cell.
Added "struct rt_htbl" to collect up hit state.
Added new method to rt_functab, ft_piece_hitsegs.
Changed args to method ft_piece_shot (removed unnecessary args).
@
text
@d18 1
a18 1
static char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.49 2000/05/22 05:12:30 mike Exp $ (BRL)";
d941 2
a942 1
	bu_free( (char *)bot->bot_facearray, "bot_facearray" );
d952 2
a953 1
		bu_free( (char *)tri, "bot tri_specific" );
@


1.49
log
@
Added some error logging.
Avoided a struct copy of the oddhit when not needed.
@
text
@d18 1
a18 1
static char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.48 2000/05/19 05:33:40 mike Exp $ (BRL)";
d308 3
d313 1
a313 1
rt_bot_makesegs( hits, nhits, stp, rp, ap, seghead, pieces_flag )
a319 1
int			pieces_flag;	/* !0 if more pieces still to come */
d375 1
d384 1
a421 2
			if( pieces_flag )  return 1;	/* save hit for later */

a473 2
			if( pieces_flag )  return 1;	/* save hit for later */

d516 1
a516 6
	if( nhits == 1 )  {
		if( pieces_flag )  return 1;	/* save hit for later */
		return 0;
	}

	if( (nhits&1) && !pieces_flag )  {
d564 1
d578 1
d592 7
a598 7
		else
		{
			hits[nhits] = hits[nhits-1];	/* struct copy */
			hits[nhits].hit_vpriv[X] = -hits[nhits].hit_vpriv[X];
			bu_log( "\t\tadding fictitious hit at %f\n", hits[nhits].hit_dist );
			nhits++;
		}
d602 1
a602 1
	for( i=0; i < (nhits&~1); i += 2 )  {
d611 1
d709 1
a709 1
	return rt_bot_makesegs( hits, nhits, stp, rp, ap, seghead, 0 );
d723 1
a723 1
rt_bot_piece_shot( psp, plp, rp, ap, seghead, resp )
d726 1
a728 2
struct seg		*seghead;
struct resource		*resp;
d730 1
d734 1
a734 3
	LOCAL struct hit hits[MAXHITS];
	register struct hit *hp = hits;
	LOCAL int	nhits = 0;
d736 2
a737 1
	CONST int		debug_shoot = rt_g.debug & DEBUG_SHOOT;
d743 1
d746 1
d806 1
a806 1
		if(debug_shoot) bu_log("%s piece %d ... HIT %g\n", stp->st_name, piecenum, k);
d808 1
a808 1
		hp->hit_dist = k;
d813 2
a814 5
		if( ++nhits >= MAXHITS )  {
			bu_log("rt_bot_piece_shot(%s): too many hits (%d)\n", stp->st_name, nhits);
			break;
		}
		hp++;
d816 13
a828 2
	if( nhits == 0 )
		return(0);		/* MISS */
d830 3
a832 8
	/* Restore left-over hit from previous invocation */
	if( psp->oddhit.hit_dist < INFINITY )  {
		if(debug_shoot) bu_log("%s piece %d ... HIT %g retrieved from oddhit\n",
			stp->st_name, psp->oddhit.hit_surfno, psp->oddhit.hit_dist);
		*hp++ = psp->oddhit;		/* struct copy */
		psp->oddhit.hit_dist = INFINITY;
		nhits++;
	}
d835 1
a835 1
	rt_hitsort( hits, nhits );
d838 1
a838 12
	{
		int ret;
		ret = rt_bot_makesegs( hits, nhits, stp, rp, ap, seghead, 1 );

		if( ret&1 )  {
			/* Save odd hit up for next entry */
			psp->oddhit = hits[ret-1];	/* struct copy */
			if(debug_shoot) bu_log("%s piece %d ... HIT %g saved in oddhit\n",
				stp->st_name, psp->oddhit.hit_surfno, psp->oddhit.hit_dist);
		}
		return ret;
	}
@


1.48
log
@
Added documentation of magic stuff for "db get".
@
text
@d18 1
a18 1
static char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.47 2000/05/19 05:23:34 mike Exp $ (BRL)";
d474 1
a474 1
			bu_log( "rt_bot_shot(%s): WARNING: odd number of hits (%d), last hit ignored\n",
d534 1
a534 1
			bu_log("rt_bot_shot(%s): WARNING %d hits:\n", stp->st_name, nhits);
d740 1
a748 8
	/* Restore left-over hit from previous invocation */
	if( psp->oddhit.hit_dist < INFINITY )  {
		hits[0] = psp->oddhit;		/* struct copy */
		psp->oddhit.hit_dist = INFINITY;
		nhits = 1;
		hp++;
	}

d762 1
d769 1
d773 1
d807 1
d823 9
d843 2
a844 1
			return ret-1;
@


1.47
log
@
Ensured that surfno subscripts match up everywhere.
@
text
@d18 1
a18 1
static char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.46 2000/05/19 02:35:42 mike Exp $ (BRL)";
d1700 19
@


1.46
log
@
Fixed more off-by-one errors.
All bot pieces are indexed from 0, not from 1.
@
text
@d18 1
a18 1
static char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.45 2000/05/18 16:54:29 mike Exp $ (BRL)";
d167 1
a167 1
		struct bound_rpp	*minmax = stp->st_piece_rpps;
d171 1
d173 1
a173 1
		for( ; trip; trip = trip->tri_forw )  {
d179 2
a180 2
			*fap = trip;
			fap++;
d182 7
d190 1
a190 1
				if( BU_BITTEST( bot->bot_facemode, trip->tri_surfno ) )  {
d192 1
a192 1
					los = bot->bot_thickness[trip->tri_surfno];
d195 1
a195 1
					los = bot->bot_thickness[trip->tri_surfno] * 0.51;
a226 2

			minmax++;
@


1.45
log
@
Fixed off-by-one errors in "db get" parameter extraction.
Added f# attribute to retrieve point list for face #.
As a convenience.
@
text
@d18 1
a18 1
static char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.44 2000/05/18 16:31:11 mike Exp $ (BRL)";
d1821 1
a1821 1
			/* Retrieve one face, as list of 3tuple coordinates */
d1845 1
a1845 1
				i = atoi( &attr[1] ) - 1;
d1986 1
a1986 1
				i = atoi( &(argv[0][2]) ) - 1;
d2054 1
a2054 1
		      i = atoi( &argv[0][1] ) - 1;
d2127 1
a2127 1
			i = atoi( &argv[0][1] ) - 1;
d2181 1
a2181 1
			i = atoi( &argv[0][1] ) - 1;
@


1.44
log
@
Added ability to retrieve a specific face, as coordinates.
@
text
@d18 1
a18 1
static char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.43 2000/05/18 04:15:59 mike Exp $ (BRL)";
d1752 1
a1752 1
					i = atoi( &attr[2] ) - 1;
d1755 1
a1755 1
						bu_vls_strcat( &vls, "face number out of range" );
d1771 1
a1771 1
				i = atoi( &attr[1] ) - 1;
d1774 1
a1774 1
					bu_vls_strcat( &vls, "vertex number out of range" );
d1804 1
a1804 1
				i = atoi( &attr[1] ) - 1;
d1807 1
a1807 1
					bu_vls_strcat( &vls, "face number out of range" );
d1821 1
a1821 1
			/* Retrieve one face, as coordinates */
d1830 10
d1848 1
a1848 1
					bu_vls_printf( &vls, "face number %d out of range", i );
d1858 10
d1889 1
a1889 1
					i = atoi( &attr[1] ) - 1;
d1892 1
a1892 1
						bu_vls_strcat( &vls, "face number out of range" );
d1925 1
a1925 1
			bu_vls_strcat( &vls, "no such attribute" );
@


1.43
log
@
Condensed some code, making it easier to ensure that no RPP has 0 thickness
on any axis.
@
text
@d18 1
a18 1
static char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.42 2000/05/18 02:02:26 mike Exp $ (BRL)";
d1794 1
d1814 34
@


1.42
log
@
Added externally settable parameter rt_bot_minpieces
@
text
@d18 1
a18 1
static char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.41 2000/05/12 20:19:02 mike Exp $ (BRL)";
d111 1
a111 1
		if( rt_botface( stp, bot, p1, p2, p3, tri_index, tol ) > 0 )
d166 1
a166 1
	if( bot->bot_mode == RT_BOT_PLATE || bot->bot_mode == RT_BOT_PLATE_NOCOS )  {
a170 1
		int	surfno = 0;
d172 1
a172 1
		for( ; trip; trip = trip->tri_forw, surfno++ )  {
d181 8
a188 3
			if( BU_BITTEST( bot->bot_facemode, surfno ) )  {
				/* Append full thickness on both sides */
				los = bot->bot_thickness[surfno];
d190 2
a191 2
				/* Center thickness.  Append 1/2 thickness on both sides */
				los = bot->bot_thickness[surfno] * 0.51;
a221 21
	} else {
		struct bound_rpp	*minmax = stp->st_piece_rpps;
		CONST struct tri_specific **fap =
			(CONST struct tri_specific **)bot->bot_facearray;
		register CONST struct tri_specific *trip = bot->bot_facelist;
		for( ; trip; trip = trip->tri_forw )  {
			point_t b,c;

			*fap = trip;
			fap++;

			minmax->min[X] = minmax->max[X] = trip->tri_A[X];
			minmax->min[Y] = minmax->max[Y] = trip->tri_A[Y];
			minmax->min[Z] = minmax->max[Z] = trip->tri_A[Z];
			VADD2( b, trip->tri_BA, trip->tri_A );
			VMINMAX( minmax->min, minmax->max, b );
			VADD2( c, trip->tri_CA, trip->tri_A );
			VMINMAX( minmax->min, minmax->max, c );
			minmax++;
		}

d268 2
a269 1
			bu_log("bot(%s): degenerate facet\n", stp->st_name);
@


1.41
log
@Took into account the thickness of the triangles when in plate mode
when building the per-piece bounding RPPs.
@
text
@d18 1
a18 1
static char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.40 2000/05/12 01:37:21 mike Exp $ (BRL)";
d51 2
d149 3
d153 2
a154 1
	if( ntri < 32 )  return 0;
a155 1
#if 1	/* Set this to '1' to enable BoT pieces */
a239 1
#endif
@


1.40
log
@
Release storage associated with solid pieces.
@
text
@d18 1
a18 1
static char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.39 2000/05/12 01:29:44 mike Exp $ (BRL)";
d144 3
d148 2
a151 1
#endif
d161 53
a213 1
	{
a231 2

			/* XXX Need to enlarge RPP for bot->bot_mode == RT_BOT_PLATE */
d235 1
@


1.39
log
@
Corrected accounting for shots, hits, and misses when pieces are involved.
@
text
@d18 1
a18 1
static char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.38 2000/05/12 01:10:38 mike Exp $ (BRL)";
d893 2
@


1.38
log
@
Removed debug print
@
text
@d18 1
a18 1
static char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.37 2000/05/11 22:09:33 mike Exp $ (BRL)";
a684 1
	CONST int	debug_shoot = rt_g.debug & DEBUG_SHOOT;
a725 3

		if(debug_shoot)bu_log("shooting %s piece %d\n", stp->st_name, piecenum );
		resp->re_piece_shots++;
@


1.37
log
@
Preserves odd hits from piece_shot to piece_shot.
Still not quite right.
@
text
@d18 1
a18 1
static char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.36 2000/05/11 21:51:19 mike Exp $ (BRL)";
a782 1
bu_log("rt_bot_piece_shot(): nhits = %d\n", nhits );
@


1.36
log
@
Cleaned up local variables some.
@
text
@d18 1
a18 1
static char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.35 2000/05/11 21:48:17 mike Exp $ (BRL)";
d360 3
a362 1
	if( bot->bot_mode == RT_BOT_SOLID )
d364 4
a367 1
		if( bot->bot_orientation == RT_BOT_UNORIENTED )
d369 1
a369 5
			if( nhits == 1 )
			{
				/* make a zero length partition */
				RT_GET_SEG( segp, ap->a_resource );
				segp->seg_stp = stp;
d371 3
a373 3
				/* set in hit */
				segp->seg_in = hits[0];
				segp->seg_in.hit_vpriv[Z] = 1;
d375 3
a377 3
				/* set out hit */
				segp->seg_out = hits[0];
				segp->seg_out.hit_vpriv[Z] = -1;
d379 3
a381 3
				BU_LIST_INSERT( &(seghead->l), &(segp->l) );
				return( 1 );
			}
d383 2
a384 41
			/* Remove duplicate hits */
			{
				register int j;

				for( i=0 ; i<nhits-1 ; i++ )
				{
					fastf_t dist;

					dist = hits[i].hit_dist - hits[i+1].hit_dist;
					if( NEAR_ZERO( dist, ap->a_rt_i->rti_tol.dist ) )
					{
						for( j=i ; j<nhits-1 ; j++ )
							hits[j] = hits[j+1];
						nhits--;
						i--;
					}
				}
			}
			if( nhits&1 )
			{
				bu_log( "rt_bot_shot(%s): WARNING: odd number of hits (%d), last hit ignored\n",
					stp->st_name, nhits );
				nhits--;
			}

			for( i=0 ; i<nhits ; i += 2 )
			{
				RT_GET_SEG( segp, ap->a_resource );
				segp->seg_stp = stp;

				/* set in hit */
				segp->seg_in = hits[i];
				segp->seg_in.hit_vpriv[Z] = 1;

				/* set out hit */
				segp->seg_out = hits[i+1];
				segp->seg_out.hit_vpriv[Z] = -1;

				BU_LIST_INSERT( &(seghead->l), &(segp->l) );
			}
			return( nhits );
d387 1
a387 12
		/* from this point on, process very similar to a polysolid */

		/* Remove duplicate hits.
		   We remove one of a pair of hits when they are
			1) close together, and
			2) both "entry" or both "exit" occurrences.
		   Two immediate "entry" or two immediate "exit" hits suggest
		   that we hit both of two joined faces, while we want to hit only
		   one.  An "entry" followed by an "exit" (or vice versa) suggests
		   that we grazed an edge, and thus we should leave both
		   in the hit list. */
		
d396 1
a396 2
				if( NEAR_ZERO( dist, ap->a_rt_i->rti_tol.dist ) &&
					hits[i].hit_vpriv[X] * hits[i+1].hit_vpriv[X] > 0)
d406 12
d419 31
a449 2
		if( nhits == 1 )
			nhits = 0;
d451 3
a453 19
		if( nhits&1 )  {
			register int i;
			static int nerrors = 0;		/* message counter */
			/*
			 * If this condition exists, it is almost certainly due to
			 * the dn==0 check above.  Thus, we will make the last
			 * surface rather thin.
			 * This at least makes the
			 * presence of this solid known.  There may be something
			 * better we can do.
			 */

			if( nerrors++ < 6 )  {
				bu_log("rt_bot_shot(%s): WARNING %d hits:\n", stp->st_name, nhits);
				bu_log( "\tray start = (%g %g %g) ray dir = (%g %g %g)\n",
					V3ARGS( rp->r_pt ), V3ARGS( rp->r_dir ) );
				for(i=0; i < nhits; i++ )
				{
					point_t tmp_pt;
d455 8
a462 6
					VJOIN1( tmp_pt, rp->r_pt, hits[i].hit_dist, rp->r_dir );
					if( hits[i].hit_vpriv[X] < 0.0 && bot->bot_orientation == RT_BOT_CCW )
						bu_log("\tentrance at dist=%f (%g %g %g)\n", hits[i].hit_dist, V3ARGS( tmp_pt ) );
					else
						bu_log("\texit at dist=%f (%g %g %g)\n", hits[i].hit_dist, V3ARGS( tmp_pt ) );
				}
d464 2
d467 22
a488 1
			if( nhits > 2 )
d490 1
a490 2
				fastf_t dot1,dot2;
				int j;
d492 15
a506 2
				/* likely an extra hit,
				 * look for consecutive entrances or exits */
d508 7
a514 3
				dot2 = 1.0;
				i = 0;
				while( i<nhits )
d516 8
a523 1
					dot1 = dot2;
d525 2
a526 30
					if( dot1 > 0.0 && dot2 > 0.0 )
					{
						/* two consectutive exits,
						 * manufacture an entrance at same distance
						 * as second exit.
						 */
						for( j=nhits ; j>i ; j-- )
							hits[j] = hits[j-1];	/* struct copy */

						hits[i].hit_vpriv[X] = -hits[i].hit_vpriv[X];
						dot2 = hits[i].hit_vpriv[X];
						nhits++;
						bu_log( "\t\tadding fictitious entry at %f (%s)\n", hits[i].hit_dist, stp->st_name );
					}
					else if( dot1 < 0.0 && dot2 < 0.0 )
					{
						/* two consectutive entrances,
						 * manufacture an exit between them.
						 */

						for( j=nhits ; j>i ; j-- )
							hits[j] = hits[j-1];	/* struct copy */

						hits[i] = hits[i-1];	/* struct copy */
						hits[i].hit_vpriv[X] = -hits[i].hit_vpriv[X];
						dot2 = hits[i].hit_vpriv[X];
						nhits++;
						bu_log( "\t\tadding fictitious exit at %f (%s)\n", hits[i].hit_dist, stp->st_name );
					}
					i++;
d528 5
d534 10
a543 7
			}
			else
			{
				hits[nhits] = hits[nhits-1];	/* struct copy */
				hits[nhits].hit_vpriv[X] = -hits[nhits].hit_vpriv[X];
				bu_log( "\t\tadding fictitious hit at %f\n", hits[nhits].hit_dist );
				nhits++;
d546 1
a546 2

		/* nhits is even, build segments */
d548 4
a551 9
			for( i=0; i < nhits; i += 2 )  {
				RT_GET_SEG(segp, ap->a_resource);
				segp->seg_stp = stp;
				segp->seg_in = hits[i];		/* struct copy */
				segp->seg_in.hit_vpriv[Z] = 1;
				segp->seg_out = hits[i+1];	/* struct copy */
				segp->seg_out.hit_vpriv[Z] = -1;
				BU_LIST_INSERT( &(seghead->l), &(segp->l) );
			}
d554 11
a698 1
bu_log("rt_bot_piece_shot %d,%d\n", ap->a_x, ap->a_y);
d786 11
a796 1
	return rt_bot_makesegs( hits, nhits, stp, rp, ap, seghead, 1 );
@


1.35
log
@
Fixed some return codes.
@
text
@d18 1
a18 1
static char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.34 2000/05/11 21:44:48 mike Exp $ (BRL)";
d271 2
a277 3
		register struct seg *segp;
		register int i;

a341 3
		register struct seg *segp;
		register int i;

a361 3
		register struct seg *segp;
		register int i;

d384 1
a384 1
				register int i, j;
d438 1
a438 1
			register int i, j;
a545 2
			register struct seg *segp;
			register int	i;
@


1.34
log
@
Reorganized common seg-assembly code into one subroutine.
@
text
@d18 1
a18 1
static char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.33 2000/05/11 21:25:19 mike Exp $ (BRL)";
d337 2
a338 1
		return( nhits );
d360 2
@


1.33
log
@
More pieces support
@
text
@d18 1
a18 1
static char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.32 2000/05/11 03:18:47 mike Exp $ (BRL)";
d258 1
a258 15
 *  			R T _ B O T _ S H O T
 *  
 *  Intersect a ray with a bot.
 *  If an intersection occurs, a struct seg will be acquired
 *  and filled in.
 *
 *	Notes for rt_bot_norm():
 *		hit_private contains pointer to the tri_specific structure
 *		hit_vpriv[X] contains dot product of ray direction and unit normal from tri_specific
 *		hit_vpriv[Y] contains the BOT solid orientation
 *		hit_vpriv[Z] contains the +1 if the hit is a entrance, or -1 for an exit
 *  
 *  Returns -
 *  	0	MISS
 *	>0	HIT
d260 4
a263 3
#define MAXHITS 128
int
rt_bot_shot( stp, rp, ap, seghead )
d265 1
a265 1
register struct xray	*rp;
d268 1
a270 4
	register struct tri_specific *trip = bot->bot_facelist;
	LOCAL struct hit hits[MAXHITS];
	register struct hit *hp;
	LOCAL int	nhits;
d272 1
a272 42
	nhits = 0;
	hp = &hits[0];

	/* consider each face */
	for( ; trip; trip = trip->tri_forw )  {
		FAST fastf_t	dn;		/* Direction dot Normal */
		LOCAL fastf_t	abs_dn;
		FAST fastf_t	k;
		LOCAL fastf_t	alpha, beta;
		LOCAL vect_t	wxb;		/* vertex - ray_start */
		LOCAL vect_t	xp;		/* wxb cross ray_dir */

		/*
		 *  Ray Direction dot N.  (N is outward-pointing normal)
		 *  wn points inwards, and is not unit length.
		 */
		dn = VDOT( trip->tri_wn, rp->r_dir );

		/*
		 *  If ray lies directly along the face, (ie, dot product
		 *  is zero), drop this face.
		 */
		abs_dn = dn >= 0.0 ? dn : (-dn);
		if( abs_dn < SQRT_SMALL_FASTF )
			continue;
		VSUB2( wxb, trip->tri_A, rp->r_pt );
		VCROSS( xp, wxb, rp->r_dir );

		/* Check for exceeding along the one side */
		alpha = VDOT( trip->tri_CA, xp );
		if( dn < 0.0 )  alpha = -alpha;
		if( alpha < 0.0 || alpha > abs_dn )
			continue;

		/* Check for exceeding along the other side */
		beta = VDOT( trip->tri_BA, xp );
		if( dn > 0.0 )  beta = -beta;
		if( beta < 0.0 || beta > abs_dn )
			continue;
		if( alpha+beta > abs_dn )
			continue;
		k = VDOT( wxb, trip->tri_wn ) / dn;
a273 20
		/* HIT is within planar face */
		hp->hit_magic = RT_HIT_MAGIC;
		hp->hit_dist = k;
		hp->hit_private = (genptr_t)trip;
		hp->hit_vpriv[X] = VDOT( trip->tri_N, rp->r_dir );
		hp->hit_vpriv[Y] = bot->bot_orientation;
		hp->hit_surfno = trip->tri_surfno;
		if( ++nhits >= MAXHITS )  {
			bu_log("rt_bot_shot(%s): too many hits (%d)\n", stp->st_name, nhits);
			break;
		}
		hp++;
	}
	if( nhits == 0 )
		return(0);		/* MISS */

	/* Sort hits, Near to Far */
	rt_hitsort( hits, nhits );

	/* build segments */
d567 97
d780 3
a782 1
	/* Now, drop into all that gore to sort hits and build segs */
d784 2
a785 4
	bu_log("rt_bot_piece_shot(): nhits = %d\n", nhits );
	bu_bomb("rt_bot_piece_shot(): got a hit, oops, need more code\n");

	return 0;	/* MISS */
@


1.32
log
@
Added debugging
@
text
@d18 1
a18 1
static char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.31 2000/05/09 20:45:11 mike Exp $ (BRL)";
d145 1
a145 1
#if 0	/* Set this to '1' to enable BoT pieces */
d176 2
d348 1
a348 14
	{
		register int i, j;
		LOCAL struct hit temp;

		for( i=0; i < nhits-1; i++ )  {
			for( j=i+1; j < nhits; j++ )  {
				if( hits[i].hit_dist <= hits[j].hit_dist )
					continue;
				temp = hits[j];		/* struct copy */
				hits[j] = hits[i];	/* struct copy */
				hits[i] = temp;		/* struct copy */
			}
		}
	}
d648 4
d667 2
a668 2
	register struct hit *hp;
	LOCAL int	nhits;
d679 8
d762 1
@


1.31
log
@
Computes per-piece RPPs into st_piece_rpps
@
text
@d18 1
a18 1
static char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.30 2000/05/08 20:46:57 mike Exp $ (BRL)";
d145 1
d147 1
d684 1
d761 1
a761 1
	bu_bomb("rt_bot_piece_shot(): needs more code\n");
@


1.30
log
@
Further progress in implementing solid "pieces"
@
text
@d18 1
a18 1
static char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.29 2000/04/15 02:04:41 mike Exp $ (BRL)";
d78 1
d109 2
a110 1
		(void)rt_botface( stp, bot, p1, p2, p3, tri_index, tol );
d139 7
a145 2
	/* XXX Should use actual face count (len of list) */
	stp->st_npieces = bot_ip->num_faces;
a146 1
	/* Support for solid 'pieces' */
d148 1
a148 1
		bu_malloc( sizeof(struct tri_specific *) * bot_ip->num_faces,
d151 4
d156 4
a159 2
		struct tri_specific **fap = bot->bot_facearray;
		register struct tri_specific *trip = bot->bot_facelist;
d161 2
d165 9
@


1.29
log
@
Code to suport solid 'pieces'.
@
text
@d18 1
a18 1
static char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.28 2000/04/12 02:34:31 mike Exp $ (BRL)";
d47 2
a48 1
	struct tri_specific *bot_facelist;
d140 15
d627 111
@


1.28
log
@
NT port, non-compat4
@
text
@d18 1
a18 1
static char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.27 2000/03/29 02:43:09 mike Exp $ (BRL)";
d135 3
@


1.27
log
@
Fixed invocation of nmg_mark_edges_real()
@
text
@d18 1
a18 1
static char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.26 2000/03/28 21:59:04 mike Exp $ (BRL)";
d679 1
a679 1
 	vec_ortho( cvp->crv_pdir, hitp->hit_normal );
@


1.26
log
@
Fixed arguments
@
text
@d18 1
a18 1
static char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.25 2000/03/07 02:14:35 mike Exp $ (BRL)";
d857 1
a857 1
	nmg_mark_edges_real( &s->l );
@


1.25
log
@
st_is_platemode was a bad idea, and has been eliminated.
@
text
@d18 1
a18 1
static char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.24 2000/03/03 21:29:07 jra Exp $ (BRL)";
d1197 1
a1197 1
rt_bot_xform( op, mat, ip, free )
d1201 1
@


1.24
log
@Corrected tclget routines
@
text
@d18 1
a18 1
static char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.23 2000/03/02 14:46:35 jra Exp $ (BRL)";
d136 1
a136 4
	if( bot->bot_mode == RT_BOT_PLATE || bot->bot_mode == RT_BOT_PLATE_NOCOS )
		stp->st_is_platemode = 1;

	return( 0 );
@


1.23
log
@Added code to remove duplicate hits in shot routine
@
text
@d18 1
a18 1
static char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.22 2000/02/29 20:38:39 mike Exp $ (BRL)";
d1648 1
a1648 1
	Tcl_DStringAppendElement( &ds, bu_vls_addr( &vls ) );
@


1.22
log
@
Added setting for st_is_platemode
@
text
@d18 1
a18 1
static char RCSbot[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.21 2000/02/10 19:45:59 jra Exp $ (BRL)";
d433 18
@


1.21
log
@Corrected rt_bot_free()
@
text
@a6 25
 * Adding a new solid type:
 *	Design disk record
 *
 *	define rt_xxx_internal --- parameters for solid
 *	define xxx_specific --- raytracing form, possibly w/precomuted terms
 *	define rt_xxx_parse --- struct bu_structparse for "db get", "db adjust", ...
 *
 *	code import/export/describe/print/ifree/plot/prep/shot/curve/uv/tess
 *
 *	edit db.h add solidrec s_type define
 *	edit rtgeom.h to add rt_xxx_internal
 *	edit table.c:
 *		RT_DECLARE_INTERFACE()
 *		struct rt_functab entry
 *		rt_id_solid()
 *	edit raytrace.h to make ID_BOT, increment ID_MAXIMUM
 *	edit db_scan.c to add the new solid to db_scan()
 *	edit Cakefile to add g_xxx.c to compile
 *
 *	Then:
 *	go to /cad/libwdb and create mk_xxx() routine
 *	go to /cad/conv and edit g2asc.c and asc2g.c to support the new solid
 *	go to /cad/librt and edit tcl.c to add the new solid to  rt_solid_type_lookup[]
 *	go to /cad/mged and create the edit support
 *
d18 1
a18 1
static char RCSbot[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/g_bot.c,v 1.20 1999/12/29 21:14:20 jra Exp $ (BRL)";
d135 3
@


1.20
log
@Eliminated some unused variables
@
text
@d43 1
a43 1
static char RCSxxx[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.19 1999/12/20 21:46:37 jra Exp $ (BRL)";
d715 1
d721 7
@


1.19
log
@Fixed a bug in bot_face_fuse()
@
text
@d43 1
a43 1
static char RCSxxx[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.18 1999/12/20 20:00:06 jra Exp $ (BRL)";
a233 2
	register CONST struct bot_specific *bot =
		(struct bot_specific *)stp->st_specific;
a493 1
			LOCAL struct hit temp;
a682 3
	register struct bot_specific *bot =
		(struct bot_specific *)stp->st_specific;

a703 2
	register struct bot_specific *bot =
		(struct bot_specific *)stp->st_specific;
d1041 3
a1043 1
			htond( (unsigned char *)&rec->bot.bot_data[chars_used], (CONST unsigned char *)&bot_ip->thickness[i], 1 );
d2089 2
a2090 1
		for( j=i+1 ; j<num_faces ; j++ )
d2092 1
d2109 2
d2112 1
d2144 2
d2147 1
a2197 1
	int count=0;
@


1.18
log
@Added bot_face_fuse()
@
text
@d43 1
a43 1
static char RCSxxx[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.17 1999/12/16 17:28:05 jra Exp $ (BRL)";
d2148 2
a2149 2
			for( l=elim*3 ; l< num_faces-1 ; l++ )
				bot->faces[l] = bot->faces[l+3];
@


1.17
log
@bot_condense() now returns the number of dead vertices eliminated.
@
text
@d43 1
a43 1
static char RCSxxx[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.16 1999/12/16 17:18:45 jra Exp $ (BRL)";
d2053 132
@


1.16
log
@Added bot_vertex_fuse() and bot_condense()
@
text
@d43 1
a43 1
static char RCSxxx[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.15 1999/12/09 20:30:16 jra Exp $ (BRL)";
d2110 2
@


1.15
log
@Added some code to insure legal BOTS
@
text
@d43 1
a43 1
static char RCSxxx[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.14 1999/12/08 14:00:17 jra Exp $ (BRL)";
d991 3
a993 3
		bu_vls_init( &face_mode );
		bu_bitv_to_hex( &face_mode, bot_ip->face_mode );
		ep->ext_nbytes += bot_ip->num_faces * 8 + bu_vls_strlen( &face_mode ) + 1;
d2014 96
@


1.14
log
@Added plate mode where LOS is exactly the assigned thickness
(no cosine obliquity angle effect)
@
text
@d43 1
a43 1
static char RCSxxx[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.13 1999/12/07 20:59:44 jra Exp $ (BRL)";
d984 7
a1946 13
		    if( bot->mode != RT_BOT_PLATE && bot->mode != RT_BOT_PLATE_NOCOS )
		      {
			if( bot->thickness )
			  {
			    bu_free( (char *)bot->thickness, "BOT thickness" );
			    bot->thickness = (fastf_t *)NULL;
			  }
			if( bot->face_mode )
			  {
			    bu_free( (char *)bot->face_mode, "BOT facemode" );
			    bot->face_mode = (bitv_t)NULL;
			  }
		      }
d1997 13
@


1.13
log
@finished tclget and tcladjust routines
@
text
@d33 1
a33 1
 *  
d35 1
a35 2
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
d39 1
a39 1
 *	This software is Copyright (C) 1990 by the United States Army.
d43 1
a43 1
static char RCSxxx[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.12 1999/12/06 20:17:37 jra Exp $ (BRL)";
d345 1
a345 1
	if( bot->bot_mode == RT_BOT_PLATE )
d355 8
a362 3
			los = bot->bot_thickness[surfno] / hits[i].hit_vpriv[X];
			if( los < 0.0 )
				los = -los;
d796 1
a796 1
	if( bot_ip->mode == RT_BOT_PLATE )	/* tesselation not supported */
d935 1
a935 1
	if( bot_ip->mode == RT_BOT_PLATE )
d982 1
a982 1
	if( bot_ip->mode == RT_BOT_PLATE )
d1038 1
a1038 1
	if( bot_ip->mode == RT_BOT_PLATE )
d1066 1
d1110 3
d1138 1
a1138 1
			if( bot_ip->mode == RT_BOT_PLATE )
d1174 1
a1174 1
	if( bot_ip->mode == RT_BOT_PLATE )
d1446 2
a1447 1
	"plate"
d1492 1
a1492 1
		if( bot->mode == RT_BOT_PLATE )
d1506 1
a1506 1
			if( bot->mode != RT_BOT_PLATE )
d1587 1
a1587 1
			if( bot->mode != RT_BOT_PLATE )
d1915 1
a1915 1
			if( mode < RT_BOT_SURFACE || mode > RT_BOT_PLATE )
d1931 2
d1940 1
a1940 1
		    if( bot->mode != RT_BOT_PLATE )
d1995 1
a1995 1
	if( bot->mode == RT_BOT_PLATE )
@


1.12
log
@
Start of Tcl interface to the BOT solid.
@
text
@d44 1
a44 1
static char RCSxxx[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.11 1999/11/26 22:02:53 mike Exp $ (BRL)";
d50 5
d1472 1
a1472 1
		bu_vls_strcpy( &vls, "BOT" );
d1478 1
a1478 1
		bu_vls_strcat( &vls, " } F { " );
d1642 15
d1665 1
a1665 1
	Tcl_Obj *obj, *list;
d1667 1
d1679 1
a1679 1
		if( !strcmp( argv[0], "fm" ) )
d1681 29
a1709 4
			bu_log( "fm=%s\n", argv[1] );
			if( bot->face_mode )
				bu_free( (char *)bot->face_mode, "bot->face_mode" );
			bot->face_mode = bu_hex_to_bitv( argv[1] );
d1711 1
a1711 1
		else if( *argv[0] == 'V' )
d1713 264
a1976 4
			bu_log( "V: %s\n", argv[1] );
			(void)Tcl_ListObjLength( interp, list, &len );
			bu_log( "Length = %d\n", len );
		}
d1983 13
@


1.11
log
@
Lint fixed
@
text
@d44 1
a44 1
static char RCSxxx[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.10 1999/11/26 19:35:15 jra Exp $ (BRL)";
d51 1
d1427 250
@


1.10
log
@Added bot_find_e_nearest_pt2() and made sure a BOT will not have zero thickness
@
text
@d44 1
a44 1
static char RCSxxx[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.9 1999/11/26 15:05:36 jra Exp $ (BRL)";
d1175 1
a1175 1
struct bn_tol           *tol;
@


1.9
log
@Added bot_find_v_nearest_pt2() and finished tesselation
@
text
@d44 1
a44 1
static char RCSxxx[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.8 1999/11/24 14:39:52 jra Exp $ (BRL)";
d94 1
a94 1
	int				tri_index;
d135 10
d1256 2
d1275 151
@


1.8
log
@Was missing some idb_meth settings for the rt_db_internal structs
@
text
@d44 1
a44 1
static char RCSxxx[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.7 1999/11/17 19:02:33 jra Exp $ (BRL)";
d776 3
d790 18
a807 3
		VMOVE( pt[0], &bot_ip->vertices[bot_ip->faces[i*3]*3] );
		VMOVE( pt[1], &bot_ip->vertices[bot_ip->faces[i*3+1]*3] );
		VMOVE( pt[2], &bot_ip->vertices[bot_ip->faces[i*3+2]*3] );
a812 3
		corners[0] = &verts[bot_ip->faces[i*3]];
		corners[1] = &verts[bot_ip->faces[i*3+1]];
		corners[2] = &verts[bot_ip->faces[i*3+2]];
d814 1
d816 2
d828 12
d848 3
d1233 30
@


1.7
log
@Corrected describe routine to do units.
@
text
@d44 1
a44 1
static char RCSxxx[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.6 1999/11/17 02:41:56 mike Exp $ (BRL)";
a69 2
static fastf_t cos_min=0.0008726;

a339 2
			if( NEAR_ZERO( hits[i].hit_vpriv[X], cos_min ) )
				continue;
d1185 1
@


1.6
log
@
Added idb_meth and st_meth pointers to allow direct access to per-solid
methods, C++ style.
@
text
@d44 1
a44 1
static char RCSxxx[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.5 1999/11/15 13:35:20 jra Exp $ (BRL)";
d1075 5
d1081 3
a1083 3
				V3ARGS( &bot_ip->vertices[bot_ip->faces[i*3]*3] ),
				V3ARGS( &bot_ip->vertices[bot_ip->faces[i*3+1]*3] ),
				V3ARGS( &bot_ip->vertices[bot_ip->faces[i*3+2]*3] ) );
d1093 1
a1093 1
				sprintf( buf, "\t\tthickness = %g, %s\n", bot_ip->thickness[i], face_mode );
d1121 2
a1122 1
	if( bot_ip->thickness )
a1123 1
	if( bot_ip->face_mode )
d1125 1
@


1.5
log
@
normals and hit points now calculated in rt_bot_norm().
@
text
@d44 1
a44 1
static char RCSxxx[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.4 1999/11/09 15:05:54 jra Exp $ (BRL)";
d853 1
@


1.4
log
@Moved normal and hit point calculation into rt_bot_norm().
@
text
@d44 1
a44 1
static char RCSxxx[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.3 1999/11/08 20:11:06 jra Exp $ (BRL)";
d205 2
d235 1
a235 1
 *		hit_vpriv[Y] contains the BOT solid mode
d304 1
a304 1
		hp->hit_vpriv[Y] = bot->bot_mode;
d361 1
d375 2
a376 1
				segp->seg_out.hit_vpriv[X] = hits[i].hit_vpriv[X]; /* ray dir dot normal */
d385 1
a406 1
			segp->seg_in.hit_vpriv[Y] = bot->bot_mode;
a410 1
			segp->seg_out.hit_vpriv[Y] = bot->bot_mode;
a430 1
				segp->seg_in.hit_vpriv[Y] = bot->bot_mode;
a434 1
				segp->seg_out.hit_vpriv[Y] = bot->bot_mode;
a454 1
				segp->seg_in.hit_vpriv[Y] = bot->bot_mode;
a458 1
				segp->seg_out.hit_vpriv[Y] = bot->bot_mode;
a593 1
				segp->seg_in.hit_vpriv[Y] = bot->bot_mode;
a595 1
				segp->seg_out.hit_vpriv[Y] = bot->bot_mode;
d638 1
a638 1
	if( hitp->hit_vpriv[Z] < 0 ) /* this is an out hit */
d640 7
a646 2
		if( dn < 0.0 )
			VREVERSE( hitp->hit_normal, trip->tri_N )
d648 6
a653 1
			VMOVE( hitp->hit_normal, trip->tri_N )
d656 1
a656 6
	{
		if( dn > 0.0 )
			VREVERSE( hitp->hit_normal, trip->tri_N )
		else
			VMOVE( hitp->hit_normal, trip->tri_N )
	}
@


1.3
log
@
shot routine now correctly computes out hit point for plate mode.
@
text
@d44 1
a44 1
static char RCSxxx[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.2 1999/11/08 18:27:30 jra Exp $ (BRL)";
d229 6
a296 2
		VJOIN1( hp->hit_point, rp->r_pt, k, rp->r_dir );

d300 3
a302 1
		VMOVE( hp->hit_normal, trip->tri_N );
d338 1
a338 1
			register fastf_t los, dn;
d340 1
a340 2
			dn = VDOT( hits[i].hit_normal, rp->r_dir );
			if( NEAR_ZERO( dn, cos_min ) )
d342 1
a342 1
			los = bot->bot_thickness[surfno] / dn;
d350 2
d353 1
a353 2
				if( dn > 0.0 )
					VREVERSE( segp->seg_in.hit_normal, segp->seg_in.hit_normal )
d355 1
a355 1
				VJOIN1( segp->seg_out.hit_point, segp->seg_in.hit_point, los, rp->r_dir );
d358 4
a361 1
				VREVERSE( segp->seg_out.hit_normal, segp->seg_in.hit_normal );
d369 2
d372 3
a374 4
				VMOVE( segp->seg_in.hit_normal, hits[i].hit_normal )
				if( dn > 0.0 )
					VREVERSE( segp->seg_in.hit_normal, segp->seg_in.hit_normal )

a375 1
				VJOIN1( segp->seg_in.hit_point, rp->r_pt, segp->seg_in.hit_dist, rp->r_dir );
d377 1
d380 4
a383 2
				VJOIN1( segp->seg_out.hit_point, rp->r_pt, segp->seg_out.hit_dist, rp->r_dir );
				VREVERSE( segp->seg_out.hit_normal, segp->seg_in.hit_normal );
d399 2
d402 4
d407 2
a408 4
			if( VDOT( segp->seg_in.hit_normal, rp->r_dir ) > 0.0 )
				VREVERSE( segp->seg_in.hit_normal, segp->seg_in.hit_normal )
			else
				VREVERSE( segp->seg_out.hit_normal, segp->seg_out.hit_normal )
d425 2
d428 4
d433 3
a435 4
				if( VDOT( segp->seg_in.hit_normal, rp->r_dir ) > 0.0 )
					VREVERSE( segp->seg_in.hit_normal, segp->seg_in.hit_normal )
				else
					VREVERSE( segp->seg_out.hit_normal, segp->seg_out.hit_normal )
d440 1
a440 1
			if( nhits%2 )
d451 2
d454 4
d459 3
a461 4
				if( VDOT( segp->seg_in.hit_normal, rp->r_dir ) > 0.0 )
					VREVERSE( segp->seg_in.hit_normal, segp->seg_in.hit_normal )
				if( VDOT( segp->seg_out.hit_normal, rp->r_dir ) < 0.0 )
					VREVERSE( segp->seg_out.hit_normal, segp->seg_out.hit_normal )
d467 1
a467 8
		if( bot->bot_orientation == RT_BOT_CW )
		{
			/* reverse all normals */
			for( i=0 ; i<nhits ; i++ )
				VREVERSE( hits[i].hit_normal, hits[i].hit_normal )
		}

		/* from this point on, process the same as a polysolid */
d489 1
a489 2
					VDOT( hits[i].hit_normal, rp->r_dir ) *
				        VDOT( hits[i+1].hit_normal, rp->r_dir) > 0)
d524 1
a524 1
					if( VDOT( rp->r_dir, hits[i].hit_normal ) < 0.0 )
d544 1
a544 1
					dot2 = VDOT( rp->r_dir, hits[i].hit_normal );
d554 2
a555 2
						VREVERSE( hits[i].hit_normal, hits[i].hit_normal );
						dot2 = VDOT( rp->r_dir, hits[i].hit_normal );
d569 2
a570 2
						VREVERSE( hits[i].hit_normal, hits[i-1].hit_normal );
						dot2 = VDOT( rp->r_dir, hits[i].hit_normal );
d581 1
a581 1
				VREVERSE( hits[nhits].hit_normal, hits[nhits-1].hit_normal );
d595 2
d598 2
d636 19
@


1.2
log
@
minor nits for compilers.
@
text
@d44 1
a44 1
static char RCSxxx[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_bot.c,v 1.1 1999/11/08 15:41:51 jra Exp $ (BRL)";
d350 1
d360 1
d367 2
d370 1
a370 2
				VJOIN1( segp->seg_in.hit_point, rp->r_pt, segp->seg_in.hit_dist, rp->r_dir );
				VMOVE( segp->seg_out.hit_normal, segp->seg_in.hit_normal );
@


1.1
log
@
the BOT (Bag'O Triangles) solid.
@
text
@d44 1
a44 1
static char RCSxxx[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_xxx.c,v 11.7 1999/10/12 17:14:38 jra Exp $ (BRL)";
d294 1
a577 1
		return(nhits);			/* HIT */
d579 1
d834 3
a836 3
		bot_ip->faces[i*3] = bu_glong( (CONST char *)&rp->bot.bot_data[index] );
		bot_ip->faces[i*3 + 1] = bu_glong( (CONST char *)&rp->bot.bot_data[index + 4] );
		bot_ip->faces[i*3 + 2] = bu_glong( (CONST char *)&rp->bot.bot_data[index + 8] );
d847 1
a847 1
		bot_ip->face_mode = bu_hex_to_bitv( (&rp->bot.bot_data[chars_used + bot_ip->num_faces * 8]) );
d949 1
a949 1
		strcpy( (unsigned char *)&rec->bot.bot_data[chars_used], bu_vls_addr( &face_mode ) );
d1096 1
a1096 1
	register point_t	pt;
d1148 2
@

