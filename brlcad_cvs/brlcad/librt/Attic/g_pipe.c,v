head	11.63;
access;
symbols
	ansi-20040405-merged:11.56.2.2
	postmerge-20040405-ansi:11.61
	premerge-20040404-ansi:11.60
	postmerge-autoconf:11.60
	autoconf-freeze:11.58.6.3
	premerge-autoconf:11.60
	ansi-20040316-freeze:11.56.2.1
	postmerge-20040315-windows:11.60
	premerge-20040315-windows:11.59
	windows-20040315-freeze:11.56.4.2
	autoconf-20031203:11.58
	autoconf-20031202:11.58
	autoconf-branch:11.58.0.6
	phong-branch:11.58.0.4
	photonmap-branch:11.58.0.2
	rel-6-1-DP:11.56
	windows-branch:11.56.0.4
	rel-6-0-2:11.54
	ansi-branch:11.56.0.2
	rel-6-0-1-branch:11.54.0.2
	hartley-6-0-post:11.55
	hartley-6-0-pre:11.54
	rel-6-0-1:11.54
	rel-6-0:11.53
	rel-5-4:11.31.2.5
	offsite-5-3-pre:11.45
	rel-5-3:11.31.2.5
	rel-5-2:11.31.2.2
	rel-5-1-branch:11.31.0.2
	rel-5-1:11.31
	rel-5-0:11.26
	rel-5-0-beta:11.25
	rel-4-5:11.18
	ctj-4-5-post:11.18
	ctj-4-5-pre:11.18
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.63
date	2004.05.21.18.07.31;	author morrison;	state dead;
branches;
next	11.62;

11.62
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.61;

11.61
date	2004.04.05.08.48.57;	author morrison;	state Exp;
branches;
next	11.60;

11.60
date	2004.03.16.20.03.08;	author morrison;	state Exp;
branches;
next	11.59;

11.59
date	2004.02.02.17.39.21;	author morrison;	state Exp;
branches;
next	11.58;

11.58
date	2003.01.20.02.06.59;	author jra;	state Exp;
branches
	11.58.6.1;
next	11.57;

11.57
date	2003.01.17.03.47.06;	author jra;	state Exp;
branches;
next	11.56;

11.56
date	2002.08.20.17.08.00;	author jra;	state Exp;
branches
	11.56.2.1
	11.56.4.1;
next	11.55;

11.55
date	2002.08.15.20.55.13;	author hartley;	state Exp;
branches;
next	11.54;

11.54
date	2002.07.17.22.51.47;	author butler;	state Exp;
branches;
next	11.53;

11.53
date	2001.10.02.19.24.30;	author jra;	state Exp;
branches;
next	11.52;

11.52
date	2001.06.14.13.20.57;	author jra;	state Exp;
branches;
next	11.51;

11.51
date	2001.04.20.22.29.46;	author morrison;	state Exp;
branches;
next	11.50;

11.50
date	2001.04.12.18.28.01;	author jra;	state Exp;
branches;
next	11.49;

11.49
date	2001.04.02.21.38.08;	author morrison;	state Exp;
branches;
next	11.48;

11.48
date	2001.03.31.01.57.08;	author morrison;	state Exp;
branches;
next	11.47;

11.47
date	2001.03.20.15.47.05;	author butler;	state Exp;
branches;
next	11.46;

11.46
date	2001.03.19.22.19.58;	author butler;	state Exp;
branches;
next	11.45;

11.45
date	2000.10.27.18.50.19;	author jra;	state Exp;
branches;
next	11.44;

11.44
date	2000.10.24.18.29.36;	author mike;	state Exp;
branches;
next	11.43;

11.43
date	2000.10.24.18.22.38;	author mike;	state Exp;
branches;
next	11.42;

11.42
date	2000.10.18.18.10.34;	author butler;	state Exp;
branches;
next	11.41;

11.41
date	2000.08.22.21.16.59;	author mike;	state Exp;
branches;
next	11.40;

11.40
date	2000.08.15.18.42.56;	author jra;	state Exp;
branches;
next	11.39;

11.39
date	2000.08.10.20.13.50;	author jra;	state Exp;
branches;
next	11.38;

11.38
date	2000.08.10.15.18.37;	author jra;	state Exp;
branches;
next	11.37;

11.37
date	2000.07.24.22.22.11;	author mike;	state Exp;
branches;
next	11.36;

11.36
date	2000.07.24.19.27.31;	author mike;	state Exp;
branches;
next	11.35;

11.35
date	2000.07.10.23.01.33;	author mike;	state Exp;
branches;
next	11.34;

11.34
date	2000.06.30.15.38.03;	author mike;	state Exp;
branches;
next	11.33;

11.33
date	2000.06.30.15.31.15;	author mike;	state Exp;
branches;
next	11.32;

11.32
date	2000.06.28.21.00.00;	author bparker;	state Exp;
branches;
next	11.31;

11.31
date	2000.04.12.02.34.35;	author mike;	state Exp;
branches
	11.31.2.1;
next	11.30;

11.30
date	99.12.06.15.18.45;	author jra;	state Exp;
branches;
next	11.29;

11.29
date	99.11.26.21.46.48;	author mike;	state Exp;
branches;
next	11.28;

11.28
date	99.11.17.02.42.00;	author mike;	state Exp;
branches;
next	11.27;

11.27
date	99.10.30.03.53.27;	author mike;	state Exp;
branches;
next	11.26;

11.26
date	99.07.02.22.19.23;	author mike;	state Exp;
branches;
next	11.25;

11.25
date	99.05.28.01.10.50;	author mike;	state Exp;
branches;
next	11.24;

11.24
date	99.05.27.20.02.42;	author mike;	state Exp;
branches;
next	11.23;

11.23
date	99.05.27.19.10.40;	author mike;	state Exp;
branches;
next	11.22;

11.22
date	99.03.11.20.06.42;	author jra;	state Exp;
branches;
next	11.21;

11.21
date	99.03.09.22.24.35;	author jra;	state Exp;
branches;
next	11.20;

11.20
date	99.01.13.21.54.04;	author mike;	state Exp;
branches;
next	11.19;

11.19
date	98.07.02.20.52.39;	author jra;	state Exp;
branches;
next	11.18;

11.18
date	96.11.19.20.25.47;	author jra;	state Exp;
branches;
next	11.17;

11.17
date	96.08.31.10.54.03;	author mike;	state Exp;
branches;
next	11.16;

11.16
date	95.08.23.19.02.59;	author jra;	state Exp;
branches;
next	11.15;

11.15
date	95.08.17.21.37.12;	author jra;	state Exp;
branches;
next	11.14;

11.14
date	95.07.28.19.20.29;	author jra;	state Exp;
branches;
next	11.13;

11.13
date	95.07.18.02.36.58;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	95.07.18.02.34.02;	author jra;	state Exp;
branches;
next	11.11;

11.11
date	95.07.14.16.38.06;	author jra;	state Exp;
branches;
next	11.10;

11.10
date	95.07.10.20.33.46;	author jra;	state Exp;
branches;
next	11.9;

11.9
date	95.07.10.13.00.59;	author jra;	state Exp;
branches;
next	11.8;

11.8
date	95.07.06.13.21.09;	author jra;	state Exp;
branches;
next	11.7;

11.7
date	95.07.05.20.16.37;	author jra;	state Exp;
branches;
next	11.6;

11.6
date	95.06.28.16.54.29;	author jra;	state Exp;
branches;
next	11.5;

11.5
date	95.05.31.19.10.25;	author jra;	state Exp;
branches;
next	11.4;

11.4
date	95.05.30.12.32.16;	author jra;	state Exp;
branches;
next	11.3;

11.3
date	95.05.26.20.34.05;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	95.05.17.18.32.51;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.56.53;	author mike;	state Rel4_4;
branches;
next	10.4;

10.4
date	94.09.30.16.24.53;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	94.08.10.18.38.35;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	93.03.03.00.55.52;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.40.22;	author mike;	state Rel4_0;
branches;
next	1.21;

1.21
date	91.09.20.23.18.30;	author butler;	state Exp;
branches;
next	1.20;

1.20
date	91.08.29.22.22.55;	author mike;	state Exp;
branches;
next	1.19;

1.19
date	91.07.19.03.52.00;	author mike;	state Exp;
branches;
next	1.18;

1.18
date	91.07.17.21.29.01;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	91.06.30.00.10.56;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	91.06.22.22.30.31;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	91.05.18.03.01.17;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	91.02.27.19.51.53;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	91.01.28.23.53.16;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	91.01.26.03.14.54;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	91.01.25.21.52.13;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	91.01.25.21.19.13;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	91.01.25.20.36.03;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	91.01.15.23.41.47;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	91.01.15.01.33.59;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	91.01.15.00.03.00;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	91.01.11.07.12.08;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	91.01.11.04.03.28;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	90.11.01.04.44.38;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	90.10.12.20.50.03;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	90.10.11.06.10.33;	author mike;	state Exp;
branches;
next	;

11.31.2.1
date	2000.08.15.17.54.39;	author jra;	state Exp;
branches;
next	11.31.2.2;

11.31.2.2
date	2000.08.15.18.39.06;	author jra;	state Exp;
branches;
next	11.31.2.3;

11.31.2.3
date	2000.10.27.18.49.08;	author jra;	state Exp;
branches;
next	11.31.2.4;

11.31.2.4
date	2000.11.04.02.43.17;	author jra;	state Exp;
branches;
next	11.31.2.5;

11.31.2.5
date	2000.11.05.00.00.58;	author jra;	state Exp;
branches;
next	;

11.56.2.1
date	2002.09.19.18.01.35;	author morrison;	state Exp;
branches;
next	11.56.2.2;

11.56.2.2
date	2004.03.17.21.18.47;	author morrison;	state Exp;
branches;
next	;

11.56.4.1
date	2002.09.26.23.04.01;	author morrison;	state Exp;
branches;
next	11.56.4.2;

11.56.4.2
date	2004.03.11.23.43.38;	author morrison;	state Exp;
branches;
next	;

11.58.6.1
date	2004.02.12.18.37.41;	author erikg;	state Exp;
branches;
next	11.58.6.2;

11.58.6.2
date	2004.03.15.14.07.20;	author erikg;	state Exp;
branches;
next	11.58.6.3;

11.58.6.3
date	2004.03.18.18.10.29;	author erikg;	state Exp;
branches;
next	;


desc
@Geometry Module for the pipe/wire solid
@


11.63
log
@moved to src/
@
text
@/*
 *			G _ P I P E . C
 *
 *  Purpose -
 *	Intersect a ray with a pipe solid
 *
 *  Authors -
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1990-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSpipe[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/g_pipe.c,v 11.62 2004/05/10 15:30:46 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <ctype.h>
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif
#ifdef HAVE_STRING_H
#include <string.h>
#endif
#include <math.h>
#include "tcl.h"
#include "machine.h"
#include "vmath.h"
#include "bu.h"
#include "bn.h"
#include "db.h"
#include "nmg.h"
#include "raytrace.h"
#include "wdb.h"
#include "rtgeom.h"
#include "./debug.h"

#ifdef WIN32
#include <float.h> //isnan function
#endif

struct id_pipe
{
	struct bu_list l;
	int	pipe_is_bend;
};

struct lin_pipe
{
	struct bu_list l;
	int	pipe_is_bend;
	vect_t	pipe_V;			/* start point for pipe section */
	vect_t	pipe_H;			/* unit vector in direction of pipe section */
	fastf_t pipe_ribase, pipe_ritop;	/* base and top inner radii */
	fastf_t pipe_ribase_sq, pipe_ritop_sq;	/* inner radii squared */
	fastf_t pipe_ridiff_sq, pipe_ridiff;	/* difference between top and base inner radii */
	fastf_t pipe_rodiff_sq, pipe_rodiff;	/* difference between top and base outer radii */
	fastf_t pipe_robase, pipe_rotop;	/* base and top outer radii */
	fastf_t pipe_robase_sq, pipe_rotop_sq;	/* outer radii squared */
	fastf_t	pipe_len;			/* length of pipe segment */
	mat_t	pipe_SoR;	/* Scale and rotate */
	mat_t	pipe_invRoS;	/* inverse rotation and scale */
};

struct bend_pipe
{
	struct bu_list l;
	int	pipe_is_bend;
	fastf_t	bend_radius;		/* distance from bend_v to center of pipe */
	fastf_t	bend_or;		/* outer radius */
	fastf_t	bend_ir;		/* inner radius */
	mat_t	bend_invR;		/* inverse rotation matrix */
	mat_t	bend_SoR;		/* Scale and rotate */
	point_t	bend_V;			/* Center of bend */
	point_t	bend_start;		/* Start of bend */
	point_t	bend_end;		/* End of bend */
	fastf_t	bend_alpha_i;		/* ratio of inner radius to bend radius */
	fastf_t	bend_alpha_o;		/* ratio of outer radius to bend radius */
	fastf_t	bend_angle;		/* Angle that bend goes through */
	vect_t	bend_ra;		/* unit vector in plane of bend (points toward start from bend_V) */
	vect_t	bend_rb;		/* unit vector in plane of bend (normal to bend_ra) */
	vect_t	bend_N;			/* unit vector normal to plane of bend */
	fastf_t	bend_R_SQ;		/* bounding sphere radius squared */
	point_t bend_min;
	point_t bend_max;
};


struct hit_list
{
	struct bu_list	l;
	struct hit	*hitp;
};

#define PIPE_MM(_v)       VMINMAX( stp->st_min, stp->st_max, _v );

#define	ARC_SEGS	16	/* number of segments used to plot a circle */

#define	PIPE_LINEAR_OUTER_BODY	1
#define	PIPE_LINEAR_INNER_BODY	2
#define	PIPE_LINEAR_TOP		3
#define	PIPE_LINEAR_BASE	4
#define PIPE_BEND_OUTER_BODY	5
#define PIPE_BEND_INNER_BODY	6
#define	PIPE_BEND_BASE		7
#define PIPE_BEND_TOP		8

RT_EXTERN( void rt_pipe_ifree, (struct rt_db_internal *ip) );


HIDDEN int
rt_bend_pipe_prep(struct soltab *stp, struct bu_list *head, fastf_t *bend_center, fastf_t *bend_start, fastf_t *bend_end, fastf_t bend_radius, fastf_t bend_angle, fastf_t *v1, fastf_t *v2, fastf_t od, fastf_t id)
{
	register struct bend_pipe *pipe;
	LOCAL vect_t	to_start,to_end;
	LOCAL mat_t	R;
	LOCAL point_t	work;
	LOCAL vect_t	tmp_vec;
	LOCAL fastf_t	f;

	pipe = (struct bend_pipe *)bu_malloc( sizeof( struct bend_pipe ), "rt_bend_pipe_prep:pipe" )	 ;
	BU_LIST_INSERT( head, &pipe->l );


	pipe->pipe_is_bend = 1;
	pipe->bend_or = od * 0.5;
	pipe->bend_ir = id * 0.5;

	VMOVE( pipe->bend_start, bend_start );
	VMOVE( pipe->bend_end, bend_end );
	VMOVE( pipe->bend_V, bend_center );
	VSUB2( to_start, bend_start, bend_center );
	pipe->bend_radius = bend_radius;
	VSUB2( to_end, bend_end, bend_center );
	VSCALE( pipe->bend_ra, to_start, 1.0/pipe->bend_radius );
	VCROSS( pipe->bend_N, to_start, to_end );
	VUNITIZE( pipe->bend_N );
	VCROSS( pipe->bend_rb, pipe->bend_N, pipe->bend_ra );

	pipe->bend_angle = bend_angle;

	/* angle goes from 0.0 at start to some angle less than PI */
	if( pipe->bend_angle >= bn_pi )
	{
		bu_log( "Error: rt_pipe_prep: Bend section bends through more than 180 degrees\n" );
		return( 1 );
	}

	pipe->bend_alpha_i = pipe->bend_ir/pipe->bend_radius;
	pipe->bend_alpha_o = pipe->bend_or/pipe->bend_radius;

	pipe->bend_R_SQ = (pipe->bend_radius + pipe->bend_or) *
				(pipe->bend_radius + pipe->bend_or);

	MAT_IDN( R );
	VMOVE( &R[0], pipe->bend_ra );
	VMOVE( &R[4], pipe->bend_rb );
	VMOVE( &R[8], pipe->bend_N );
	bn_mat_inv( pipe->bend_invR, R );
	MAT_COPY( pipe->bend_SoR, R );
	pipe->bend_SoR[15] *= pipe->bend_radius;

	/* bounding box for entire torus */
	/* X */
	VSET( tmp_vec, 1.0, 0.0, 0.0 );
	VCROSS( work, pipe->bend_N, tmp_vec );
	f = pipe->bend_or + pipe->bend_radius * MAGNITUDE(work);
	pipe->bend_min[X] = pipe->bend_V[X] - f;
	pipe->bend_max[X] = pipe->bend_V[X] + f;

	/* Y */
	VSET( tmp_vec, 0.0, 1.0, 0.0 );
	VCROSS( work, pipe->bend_N, tmp_vec );
	f = pipe->bend_or + pipe->bend_radius * MAGNITUDE(work);
	pipe->bend_min[Y] = pipe->bend_V[Y] - f;
	pipe->bend_max[Y] = pipe->bend_V[Y] + f;

	/* Z */
	VSET( tmp_vec, 0.0, 0.0, 1.0 );
	VCROSS( work, pipe->bend_N, tmp_vec );
	f = pipe->bend_or + pipe->bend_radius * MAGNITUDE(work);
	pipe->bend_min[Z] = pipe->bend_V[Z] - f;
	pipe->bend_max[Z] = pipe->bend_V[Z] + f;

	PIPE_MM( pipe->bend_min );
	PIPE_MM( pipe->bend_max );

	return( 0 );

}

HIDDEN void
rt_linear_pipe_prep(struct soltab *stp, struct bu_list *head, fastf_t *pt1, fastf_t id1, fastf_t od1, fastf_t *pt2, fastf_t id2, fastf_t od2)
{
	register struct lin_pipe *pipe;
	LOCAL mat_t	R;
	LOCAL mat_t	Rinv;
	LOCAL mat_t	S;
	LOCAL point_t work;
	LOCAL vect_t seg_ht;
	LOCAL vect_t v1,v2;

	pipe = (struct lin_pipe *)bu_malloc( sizeof( struct lin_pipe ), "rt_bend_pipe_prep:pipe" );
	BU_LIST_INSERT( head, &pipe->l );


	VMOVE( pipe->pipe_V, pt1 );

	VSUB2( seg_ht, pt2, pt1 );
	pipe->pipe_ribase = id1/2.0;
	pipe->pipe_ribase_sq = pipe->pipe_ribase * pipe->pipe_ribase;
	pipe->pipe_ritop = id2/2.0;
	pipe->pipe_ritop_sq = pipe->pipe_ritop * pipe->pipe_ritop;
	pipe->pipe_robase = od1/2.0;
	pipe->pipe_robase_sq = pipe->pipe_robase * pipe->pipe_robase;
	pipe->pipe_rotop = od2/2.0;
	pipe->pipe_rotop_sq = pipe->pipe_rotop * pipe->pipe_rotop;
	pipe->pipe_ridiff = pipe->pipe_ritop - pipe->pipe_ribase;
	pipe->pipe_ridiff_sq = pipe->pipe_ridiff * pipe->pipe_ridiff;
	pipe->pipe_rodiff = pipe->pipe_rotop - pipe->pipe_robase;
	pipe->pipe_rodiff_sq = pipe->pipe_rodiff * pipe->pipe_rodiff;
	pipe->pipe_is_bend = 0;

	pipe->pipe_len = MAGNITUDE( seg_ht );
	VSCALE( seg_ht, seg_ht, 1.0/pipe->pipe_len );
	VMOVE( pipe->pipe_H, seg_ht );
	bn_vec_ortho( v1, seg_ht );
	VCROSS( v2, seg_ht, v1 );

	/* build R matrix */
	MAT_IDN( R );
	VMOVE( &R[0], v1 );
	VMOVE( &R[4], v2 );
	VMOVE( &R[8], seg_ht );

	/* Rinv is transpose */
	bn_mat_trn( Rinv, R );

	/* Build Scale matrix */
	MAT_IDN( S );
	S[10] = 1.0/pipe->pipe_len;

	/* Compute SoR and invRoS */
	bn_mat_mul( pipe->pipe_SoR, S, R );
	bn_mat_mul( pipe->pipe_invRoS, Rinv, S );



	VJOIN2( work, pt1, od1, v1, od1, v2 );
	PIPE_MM( work )
	VJOIN2( work, pt1, -od1, v1, od1, v2 );
	PIPE_MM( work )
	VJOIN2( work, pt1, od1, v1, -od1, v2 );
	PIPE_MM( work )
	VJOIN2( work, pt1, -od1, v1, -od1, v2 );
	PIPE_MM( work )

	VJOIN2( work, pt2, od2, v1, od2, v2 );
	PIPE_MM( work )
	VJOIN2( work, pt2, -od2, v1, od2, v2 );
	PIPE_MM( work )
	VJOIN2( work, pt2, od2, v1, -od2, v2 );
	PIPE_MM( work )
	VJOIN2( work, pt2, -od2, v1, -od2, v2 );
	PIPE_MM( work )

}

/*
 *  			R T _ P I P E _ P R E P
 *  
 *  Given a pointer to a GED database record, and a transformation matrix,
 *  determine if this is a valid pipe solid, and if so, precompute various
 *  terms of the formula.
 *  
 *  Returns -
 *  	0	pipe solid is OK
 *  	!0	Error in description
 *  
 *  Implicit return -
 *  	A struct bu_list is created, and it's address is stored in
 *  	stp->st_specific for use by pipe_shot().
 */
int
rt_pipe_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
{
	register struct bu_list *head;
	struct rt_pipe_internal	*pip;
	struct wdb_pipept *pp1,*pp2,*pp3;
	point_t curr_pt;
	fastf_t curr_id, curr_od;
	fastf_t dx,dy,dz,f;

	RT_CK_DB_INTERNAL( ip );
	pip = (struct rt_pipe_internal *)ip->idb_ptr;
	RT_PIPE_CK_MAGIC(pip);

	head = (struct bu_list *)bu_malloc( sizeof( struct bu_list ), "rt_pipe_prep:head" );
	stp->st_specific = (genptr_t)head;
	BU_LIST_INIT( head );

	if( BU_LIST_IS_EMPTY( &(pip->pipe_segs_head) ) )
		return( 0 );

	pp1 = BU_LIST_FIRST( wdb_pipept, &(pip->pipe_segs_head) );
	pp2 = BU_LIST_NEXT( wdb_pipept, &pp1->l );
	if( BU_LIST_IS_HEAD( &pp2->l, &(pip->pipe_segs_head) ) )
		return( 0 );
	pp3 = BU_LIST_NEXT( wdb_pipept, &pp2->l );
	if( BU_LIST_IS_HEAD( &pp3->l ,  &(pip->pipe_segs_head) ) )
		pp3 = (struct wdb_pipept *)NULL;

	VMOVE( curr_pt, pp1->pp_coord );
	curr_od = pp1->pp_od;
	curr_id = pp1->pp_id;
	while( 1 )
	{
		vect_t n1,n2;
		vect_t norm;
		vect_t v1,v2;
		fastf_t angle;
		fastf_t dist_to_bend;
		point_t bend_start, bend_end, bend_center;

		VSUB2( n1, curr_pt, pp2->pp_coord );
		if( VNEAR_ZERO( n1, SQRT_SMALL_FASTF ) )
		{
			/* duplicate point, skip to next point */
			goto next_pt;
		}

		if( !pp3 )
		{
			/* last segment */
			rt_linear_pipe_prep( stp, head, curr_pt, curr_id, curr_od, pp2->pp_coord, pp2->pp_id, pp2->pp_od );
			break;
		}

		VSUB2( n2, pp3->pp_coord, pp2->pp_coord );
		VCROSS( norm, n1, n2 );
		VUNITIZE( n1 );
		VUNITIZE( n2 );
		angle = bn_pi - acos( VDOT( n1, n2 ) );
		dist_to_bend = pp2->pp_bendradius * tan( angle/2.0 );
		if( isnan( dist_to_bend ) || VNEAR_ZERO( norm, SQRT_SMALL_FASTF) || NEAR_ZERO( dist_to_bend, SQRT_SMALL_FASTF) )
		{
			/* points are colinear, treat as a linear segment */
			rt_linear_pipe_prep( stp, head, curr_pt, curr_id, curr_od,
				pp2->pp_coord, pp2->pp_id, pp2->pp_od );
			VMOVE( curr_pt, pp2->pp_coord );
			goto next_pt;
		}

		VJOIN1( bend_start, pp2->pp_coord, dist_to_bend, n1 );
		VJOIN1( bend_end, pp2->pp_coord, dist_to_bend, n2 );

		VUNITIZE( norm );

		/* linear section */
		rt_linear_pipe_prep( stp, head, curr_pt, curr_id, curr_od,
				bend_start, pp2->pp_id, pp2->pp_od );

		/* and bend section */
		VCROSS( v1, n1, norm );
		VCROSS( v2, v1, norm );
		VJOIN1( bend_center, bend_start, -pp2->pp_bendradius, v1 );
		rt_bend_pipe_prep( stp, head, bend_center, bend_start, bend_end, pp2->pp_bendradius, angle,
			v1, v2, pp2->pp_od, pp2->pp_id );

		VMOVE( curr_pt, bend_end );
next_pt:
		if (!pp3) break;
		curr_id = pp2->pp_id;
		curr_od = pp2->pp_od;
		pp1 = pp2;
		pp2 = pp3;
		pp3 = BU_LIST_NEXT( wdb_pipept, &pp3->l );
		if( BU_LIST_IS_HEAD( &pp3->l ,  &(pip->pipe_segs_head) ) )
			pp3 = (struct wdb_pipept *)NULL;
	}

	VSET( stp->st_center,
		(stp->st_max[X] + stp->st_min[X])/2,
		(stp->st_max[Y] + stp->st_min[Y])/2,
		(stp->st_max[Z] + stp->st_min[Z])/2 );

	dx = (stp->st_max[X] - stp->st_min[X])/2;
	f = dx;
	dy = (stp->st_max[Y] - stp->st_min[Y])/2;
	if( dy > f )  f = dy;
	dz = (stp->st_max[Z] - stp->st_min[Z])/2;
	if( dz > f )  f = dz;
	stp->st_aradius = f;
	stp->st_bradius = sqrt(dx*dx + dy*dy + dz*dz);

	return( 0 );
}

/*
 *			R T _ P I P E _ P R I N T
 */
void
rt_pipe_print(register const struct soltab *stp)
{
/*	register struct bu_list *pipe =
		(struct bu_list *)stp->st_specific; */
}

/*
 *			R T _ P I P E P T _ P R I N T
 */
void
rt_pipept_print( const struct wdb_pipept *pipe, double mm2local )
{
	point_t p1;

	bu_log( "Pipe Vertex:\n" );
	VSCALE( p1, pipe->pp_coord, mm2local );
	bu_log( "\tat (%g %g %g)\n", V3ARGS( p1 ) );
	bu_log( "\tbend radius = %g\n", pipe->pp_bendradius*mm2local );
	if( pipe->pp_id > 0.0 )
		bu_log( "\tod=%g, id=%g\n",
			pipe->pp_od*mm2local,
			pipe->pp_id*mm2local );
	else
		bu_log( "\tod=%g\n", pipe->pp_od*mm2local );
}

/*
 *			R T _ V L S _ P I P E P T
 */
void
rt_vls_pipept(
	struct bu_vls *vp,
	int seg_no,
	const struct rt_db_internal *ip,
	double mm2local)
{
	struct rt_pipe_internal *pint;
	struct wdb_pipept *pipe;
	int seg_count=0;
	char buf[256];
	point_t p1;

	pint = (struct rt_pipe_internal *)ip->idb_ptr;
	RT_PIPE_CK_MAGIC( pint );

	pipe = BU_LIST_FIRST( wdb_pipept, &pint->pipe_segs_head );
	while( ++seg_count != seg_no && BU_LIST_NOT_HEAD( &pipe->l, &pint->pipe_segs_head ) )
		pipe = BU_LIST_NEXT( wdb_pipept, &pipe->l );


	sprintf( buf, "Pipe Vertex:\n" );
	bu_vls_strcat( vp, buf );
	VSCALE( p1, pipe->pp_coord, mm2local );
	sprintf( buf, "\tat (%g %g %g)\n", V3ARGS( p1 ) );
	bu_vls_strcat( vp, buf );
	sprintf( buf, "\tbend radius = %g\n", pipe->pp_bendradius*mm2local );
	bu_vls_strcat( vp, buf );
	if( pipe->pp_id > 0.0 )
		sprintf( buf, "\tod=%g, id=%g\n",
			pipe->pp_od*mm2local,
			pipe->pp_id*mm2local );
	else
		sprintf( buf, "\tod=%g\n", pipe->pp_od*mm2local );
	bu_vls_strcat( vp, buf );
}

HIDDEN void
bend_pipe_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead, struct bend_pipe *pipe, struct hit_list *hit_headp, int *hit_count, int seg_no)
{
	LOCAL vect_t	dprime;		/* D' */
	LOCAL vect_t	pprime;		/* P' */
	LOCAL vect_t	work;		/* temporary vector */
	LOCAL bn_poly_t	C;		/* The final equation */
	LOCAL bn_complex_t	val[4];	/* The complex roots */
	LOCAL int	j;
	LOCAL int	root_count=0;
	LOCAL bn_poly_t	A, Asqr;
	LOCAL bn_poly_t	X2_Y2;		/* X**2 + Y**2 */
	LOCAL vect_t	cor_pprime;	/* new ray origin */
	LOCAL fastf_t	cor_proj;

	*hit_count = 0;

	if( !rt_in_rpp( rp, ap->a_inv_dir, pipe->bend_min, pipe->bend_max ) ) {
		return;		 /* miss */
	}

	/* Convert vector into the space of the unit torus */
	MAT4X3VEC( dprime, pipe->bend_SoR, rp->r_dir );
	VUNITIZE( dprime );

	VSUB2( work, rp->r_pt, pipe->bend_V );
	MAT4X3VEC( pprime, pipe->bend_SoR, work );

	/* normalize distance from torus.  substitute
	 * corrected pprime which contains a translation along ray
	 * direction to closest approach to vertex of torus.
	 * Translating ray origin along direction of ray to closest pt. to
	 * origin of solid's coordinate system, new ray origin is
	 * 'cor_pprime'.
	 */
	cor_proj = VDOT( pprime, dprime );
	VSCALE( cor_pprime, dprime, cor_proj );
	VSUB2( cor_pprime, pprime, cor_pprime );

	/*
	 *  Given a line and a ratio, alpha, finds the equation of the
	 *  unit torus in terms of the variable 't'.
	 *
	 *  The equation for the torus is:
	 *
	 * [ X**2 + Y**2 + Z**2 + (1 - alpha**2) ]**2 - 4*( X**2 + Y**2 ) = 0
	 *
	 *  First, find X, Y, and Z in terms of 't' for this line, then
	 *  substitute them into the equation above.
	 *
	 *  	Wx = Dx*t + Px
	 *
	 *  	Wx**2 = Dx**2 * t**2  +  2 * Dx * Px  +  Px**2
	 *  		[0]                [1]           [2]    dgr=2
	 */
	X2_Y2.dgr = 2;
	X2_Y2.cf[0] = dprime[X] * dprime[X] + dprime[Y] * dprime[Y];
	X2_Y2.cf[1] = 2.0 * (dprime[X] * cor_pprime[X] +
			     dprime[Y] * cor_pprime[Y]);
	X2_Y2.cf[2] = cor_pprime[X] * cor_pprime[X] +
		      cor_pprime[Y] * cor_pprime[Y];

	/* A = X2_Y2 + Z2 */
	A.dgr = 2;
	A.cf[0] = X2_Y2.cf[0] + dprime[Z] * dprime[Z];
	A.cf[1] = X2_Y2.cf[1] + 2.0 * dprime[Z] * cor_pprime[Z];
	A.cf[2] = X2_Y2.cf[2] + cor_pprime[Z] * cor_pprime[Z] +
		  1.0 - pipe->bend_alpha_o * pipe->bend_alpha_o;

	/* Inline expansion of (void) rt_poly_mul( &A, &A, &Asqr ) */
	/* Both polys have degree two */
	Asqr.dgr = 4;
	Asqr.cf[0] = A.cf[0] * A.cf[0];
	Asqr.cf[1] = A.cf[0] * A.cf[1] + A.cf[1] * A.cf[0];
	Asqr.cf[2] = A.cf[0] * A.cf[2] + A.cf[1] * A.cf[1] + A.cf[2] * A.cf[0];
	Asqr.cf[3] = A.cf[1] * A.cf[2] + A.cf[2] * A.cf[1];
	Asqr.cf[4] = A.cf[2] * A.cf[2];

	/* Inline expansion of bn_poly_scale( &X2_Y2, 4.0 ) and
	 * rt_poly_sub( &Asqr, &X2_Y2, &C ).
	 */
	C.dgr   = 4;
	C.cf[0] = Asqr.cf[0];
	C.cf[1] = Asqr.cf[1];
	C.cf[2] = Asqr.cf[2] - X2_Y2.cf[0] * 4.0;
	C.cf[3] = Asqr.cf[3] - X2_Y2.cf[1] * 4.0;
	C.cf[4] = Asqr.cf[4] - X2_Y2.cf[2] * 4.0;

	/*  It is known that the equation is 4th order.  Therefore,
	 *  if the root finder returns other than 4 roots, error.
	 */
	if ( (root_count = rt_poly_roots( &C, val )) != 4 ){
		if( (root_count) != 0 )  {
			bu_log("tor:  rt_poly_roots() 4!=%d\n", root_count);
			bn_pr_roots( stp->st_name, val, root_count );
		}
		return;	/* MISSED */
	}

	/*  Only real roots indicate an intersection in real space.
	 *
	 *  Look at each root returned; if the imaginary part is zero
	 *  or sufficiently close, then use the real part as one value
	 *  of 't' for the intersections
	 */
	for ( j=0, (*hit_count)=0; j < 4; j++ ){
		if( NEAR_ZERO( val[j].im, 0.0001 ) )
		{
			struct hit_list *hitp;
			fastf_t normalized_dist;
			fastf_t dist;
			point_t hit_pt;
			vect_t	to_hit;
			fastf_t	angle;

			normalized_dist = val[j].re - cor_proj;
			dist = normalized_dist * pipe->bend_radius;

			/* check if this hit is within bend angle */
			VJOIN1( hit_pt, rp->r_pt, dist, rp->r_dir );
			VSUB2( to_hit, hit_pt, pipe->bend_V );
			angle = atan2( VDOT( to_hit, pipe->bend_rb ), VDOT( to_hit, pipe->bend_ra ) );
			if( angle < 0.0 )
				angle += 2.0 * bn_pi;
			if( angle <= pipe->bend_angle )
			{
				BU_GETSTRUCT( hitp, hit_list );
				BU_GETSTRUCT( hitp->hitp, hit );
				hitp->hitp->hit_magic = RT_HIT_MAGIC;
				hitp->hitp->hit_dist = dist;
				VJOIN1( hitp->hitp->hit_vpriv, pprime, normalized_dist, dprime );
				hitp->hitp->hit_surfno = seg_no*10 + PIPE_BEND_OUTER_BODY;
				BU_LIST_INSERT( &hit_headp->l, &hitp->l );
				(*hit_count)++;
			}
		}
	}

	if( pipe->bend_alpha_i <= 0.0 )
		return;		/* no inner torus */

	/* Now do inner torus */
	A.cf[2] = X2_Y2.cf[2] + cor_pprime[Z] * cor_pprime[Z] +
		  1.0 - pipe->bend_alpha_i * pipe->bend_alpha_i;

	/* Inline expansion of (void) rt_poly_mul( &A, &A, &Asqr ) */
	/* Both polys have degree two */
	Asqr.dgr = 4;
	Asqr.cf[0] = A.cf[0] * A.cf[0];
	Asqr.cf[1] = A.cf[0] * A.cf[1] + A.cf[1] * A.cf[0];
	Asqr.cf[2] = A.cf[0] * A.cf[2] + A.cf[1] * A.cf[1] + A.cf[2] * A.cf[0];
	Asqr.cf[3] = A.cf[1] * A.cf[2] + A.cf[2] * A.cf[1];
	Asqr.cf[4] = A.cf[2] * A.cf[2];

	/* Inline expansion of bn_poly_scale( &X2_Y2, 4.0 ) and
	 * rt_poly_sub( &Asqr, &X2_Y2, &C ).
	 */
	C.dgr   = 4;
	C.cf[0] = Asqr.cf[0];
	C.cf[1] = Asqr.cf[1];
	C.cf[2] = Asqr.cf[2] - X2_Y2.cf[0] * 4.0;
	C.cf[3] = Asqr.cf[3] - X2_Y2.cf[1] * 4.0;
	C.cf[4] = Asqr.cf[4] - X2_Y2.cf[2] * 4.0;

	/*  It is known that the equation is 4th order.  Therefore,
	 *  if the root finder returns other than 4 roots, error.
	 */
	if ( (root_count = rt_poly_roots( &C, val )) != 4 ){
		if( root_count != 0 )  {
			bu_log("tor:  rt_poly_roots() 4!=%d\n", root_count);
			bn_pr_roots( stp->st_name, val, root_count );
		}
		return;	/* MISSED */
	}

	/*  Only real roots indicate an intersection in real space.
	 *
	 *  Look at each root returned; if the imaginary part is zero
	 *  or sufficiently close, then use the real part as one value
	 *  of 't' for the intersections
	 */
	for ( j=0, root_count=0; j < 4; j++ ){
		if( NEAR_ZERO( val[j].im, 0.0001 ) )
		{
			struct hit_list *hitp;
			fastf_t normalized_dist;
			fastf_t dist;
			point_t hit_pt;
			vect_t	to_hit;
			fastf_t	angle;

			normalized_dist = val[j].re - cor_proj;
			dist = normalized_dist * pipe->bend_radius;

			/* check if this hit is within bend angle */
			VJOIN1( hit_pt, rp->r_pt, dist, rp->r_dir );
			VSUB2( to_hit, hit_pt, pipe->bend_V );
			angle = atan2( VDOT( to_hit, pipe->bend_rb ), VDOT( to_hit, pipe->bend_ra ) );
			if( angle < 0.0 )
				angle += 2.0 * bn_pi;
			if( angle <= pipe->bend_angle )
			{
				BU_GETSTRUCT( hitp, hit_list );
				BU_GETSTRUCT( hitp->hitp, hit );
				hitp->hitp->hit_magic = RT_HIT_MAGIC;
				hitp->hitp->hit_dist = dist;
				VJOIN1( hitp->hitp->hit_vpriv, pprime, normalized_dist, dprime );
				hitp->hitp->hit_surfno = seg_no*10 + PIPE_BEND_INNER_BODY;
				BU_LIST_INSERT( &hit_headp->l, &hitp->l );
				root_count++;
			}
		}
	}

	*hit_count += root_count;

	return;

}

HIDDEN void
linear_pipe_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead, struct lin_pipe *pipe, struct hit_list *hit_headp, int *hit_count, int seg_no)
{
	LOCAL struct hit_list	*hitp;
	LOCAL point_t	work_pt;
	LOCAL point_t	ray_start;
	LOCAL vect_t	ray_dir;
	LOCAL double	t_tmp;
	LOCAL double	a,b,c;
	LOCAL double	descrim;

	if( pipe->pipe_is_bend )
	{
		bu_log( "linear_pipe_shot called for pipe bend\n" );
		rt_bomb( "linear_pipe_shot\n" );
	}

	*hit_count = 0;

	/* transform ray start point */
	VSUB2( work_pt, rp->r_pt, pipe->pipe_V );
	MAT4X3VEC( ray_start, pipe->pipe_SoR, work_pt );

	/* rotate ray direction */
	MAT4X3VEC( ray_dir, pipe->pipe_SoR, rp->r_dir );

	/* Intersect with outer sides */
	a = ray_dir[X]*ray_dir[X]
		+ ray_dir[Y]*ray_dir[Y]
		- ray_dir[Z]*ray_dir[Z]*pipe->pipe_rodiff_sq;
	b = 2.0*(ray_start[X]*ray_dir[X]
		+ ray_start[Y]*ray_dir[Y]
		- ray_start[Z]*ray_dir[Z]*pipe->pipe_rodiff_sq
		- ray_dir[Z]*pipe->pipe_robase*pipe->pipe_rodiff);
	c = ray_start[X]*ray_start[X]
		+ ray_start[Y]*ray_start[Y]
		- pipe->pipe_robase*pipe->pipe_robase
		- ray_start[Z]*ray_start[Z]*pipe->pipe_rodiff_sq
		- 2.0*ray_start[Z]*pipe->pipe_robase*pipe->pipe_rodiff;

	descrim = b*b - 4.0*a*c;

	if( descrim > 0.0 )
	{
		LOCAL fastf_t	sqrt_descrim;
		LOCAL point_t	hit_pt;

		sqrt_descrim = sqrt( descrim );

		t_tmp = (-b - sqrt_descrim)/(2.0*a);
		VJOIN1( hit_pt, ray_start, t_tmp, ray_dir );
		if( hit_pt[Z] >= 0.0 && hit_pt[Z] <= 1.0 )
		{
			BU_GETSTRUCT( hitp, hit_list );
			BU_GETSTRUCT( hitp->hitp, hit );
			hitp->hitp->hit_magic = RT_HIT_MAGIC;
			hitp->hitp->hit_dist = t_tmp;
			hitp->hitp->hit_surfno = seg_no*10 + PIPE_LINEAR_OUTER_BODY;
			VMOVE( hitp->hitp->hit_vpriv, hit_pt );
			hitp->hitp->hit_vpriv[Z] = (-pipe->pipe_robase - hit_pt[Z] * pipe->pipe_rodiff) *
					pipe->pipe_rodiff;
			(*hit_count)++;
			BU_LIST_INSERT( &hit_headp->l, &hitp->l );
		}

		t_tmp = (-b + sqrt_descrim)/(2.0*a);
		VJOIN1( hit_pt, ray_start, t_tmp, ray_dir );
		if( hit_pt[Z] >= 0.0 && hit_pt[Z] <= 1.0 )
		{
			BU_GETSTRUCT( hitp, hit_list );
			BU_GETSTRUCT( hitp->hitp, hit );
			hitp->hitp->hit_magic = RT_HIT_MAGIC;
			hitp->hitp->hit_dist = t_tmp;
			hitp->hitp->hit_surfno = seg_no*10 + PIPE_LINEAR_OUTER_BODY;
			VMOVE( hitp->hitp->hit_vpriv, hit_pt );
			hitp->hitp->hit_vpriv[Z] = (-pipe->pipe_robase - hit_pt[Z] * pipe->pipe_rodiff) *
					pipe->pipe_rodiff;
			(*hit_count)++;
			BU_LIST_INSERT( &hit_headp->l, &hitp->l );
		}
	}

	if( pipe->pipe_ribase > 0.0 || pipe->pipe_ritop > 0.0 )
	{
		/* Intersect with inner sides */

		a = ray_dir[X]*ray_dir[X]
			+ ray_dir[Y]*ray_dir[Y]
			- ray_dir[Z]*ray_dir[Z]*pipe->pipe_ridiff_sq;
		b = 2.0*(ray_start[X]*ray_dir[X]
			+ ray_start[Y]*ray_dir[Y]
			- ray_start[Z]*ray_dir[Z]*pipe->pipe_ridiff_sq
			- ray_dir[Z]*pipe->pipe_ribase*pipe->pipe_ridiff);
		c = ray_start[X]*ray_start[X]
			+ ray_start[Y]*ray_start[Y]
			- pipe->pipe_ribase*pipe->pipe_ribase
			- ray_start[Z]*ray_start[Z]*pipe->pipe_ridiff_sq
			- 2.0*ray_start[Z]*pipe->pipe_ribase*pipe->pipe_ridiff;

		descrim = b*b - 4.0*a*c;

		if( descrim > 0.0 )
		{
			LOCAL fastf_t	sqrt_descrim;
			LOCAL point_t	hit_pt;

			sqrt_descrim = sqrt( descrim );

			t_tmp = (-b - sqrt_descrim)/(2.0*a);
			VJOIN1( hit_pt, ray_start, t_tmp, ray_dir );
			if( hit_pt[Z] >= 0.0 && hit_pt[Z] <= 1.0 )
			{
				BU_GETSTRUCT( hitp, hit_list );
				BU_GETSTRUCT( hitp->hitp, hit );
				hitp->hitp->hit_magic = RT_HIT_MAGIC;
				hitp->hitp->hit_dist = t_tmp;
				hitp->hitp->hit_surfno = seg_no*10 + PIPE_LINEAR_INNER_BODY;
				VMOVE( hitp->hitp->hit_vpriv, hit_pt );
				hitp->hitp->hit_vpriv[Z] = (-pipe->pipe_ribase - hit_pt[Z] * pipe->pipe_ridiff) *
					pipe->pipe_ridiff;
				(*hit_count)++;
				BU_LIST_INSERT( &hit_headp->l, &hitp->l );
			}

			t_tmp = (-b + sqrt_descrim)/(2.0*a);
			VJOIN1( hit_pt, ray_start, t_tmp, ray_dir );
			if( hit_pt[Z] >= 0.0 && hit_pt[Z] <= 1.0 )
			{
				BU_GETSTRUCT( hitp, hit_list );
				BU_GETSTRUCT( hitp->hitp, hit );
				hitp->hitp->hit_magic = RT_HIT_MAGIC;
				hitp->hitp->hit_dist = t_tmp;
				hitp->hitp->hit_surfno = seg_no*10 + PIPE_LINEAR_INNER_BODY;
				VMOVE( hitp->hitp->hit_vpriv, hit_pt );
				hitp->hitp->hit_vpriv[Z] = (-pipe->pipe_ribase - hit_pt[Z] * pipe->pipe_ridiff) *
					pipe->pipe_ridiff;
				(*hit_count)++;
				BU_LIST_INSERT( &hit_headp->l, &hitp->l );
			}
		}
	}

}

HIDDEN void
pipe_start_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead, struct id_pipe *pipe, struct hit_list *hit_headp, int *hit_count, int seg_no)
{
	point_t hit_pt;
	fastf_t t_tmp;
	fastf_t radius_sq;
	struct hit_list *hitp;

	*hit_count = 0;

	if( !pipe->pipe_is_bend )
	{
		struct lin_pipe *lin=(struct lin_pipe *)(&pipe->l);
		fastf_t dist_to_plane;
		fastf_t norm_dist;
		fastf_t slant_factor;

		dist_to_plane = VDOT( lin->pipe_H, lin->pipe_V );
		norm_dist = dist_to_plane - VDOT( lin->pipe_H, rp->r_pt );
		slant_factor = VDOT( lin->pipe_H, rp->r_dir );
		if( !NEAR_ZERO( slant_factor, SMALL_FASTF ) )
		{
			vect_t to_center;

			t_tmp = norm_dist/slant_factor;
			VJOIN1( hit_pt, rp->r_pt, t_tmp, rp->r_dir );
			VSUB2( to_center, lin->pipe_V, hit_pt );
			radius_sq = MAGSQ( to_center );
			if( radius_sq <= lin->pipe_robase_sq && radius_sq >= lin->pipe_ribase_sq )
			{
				BU_GETSTRUCT( hitp, hit_list );
				BU_GETSTRUCT( hitp->hitp, hit );
				hitp->hitp->hit_magic = RT_HIT_MAGIC;
				hitp->hitp->hit_dist = t_tmp;
				hitp->hitp->hit_surfno = seg_no*10 + PIPE_LINEAR_BASE;
				(*hit_count)++;
				BU_LIST_INSERT( &hit_headp->l, &hitp->l );
			}
		}
	}
	else if( pipe->pipe_is_bend )
	{
		struct bend_pipe *bend=(struct bend_pipe *)(&pipe->l);
		fastf_t dist_to_plane;
		fastf_t norm_dist;
		fastf_t slant_factor;

		dist_to_plane = VDOT( bend->bend_rb, bend->bend_start );
		norm_dist = dist_to_plane - VDOT( bend->bend_rb, rp->r_pt );
		slant_factor = VDOT( bend->bend_rb, rp->r_dir );

		if( !NEAR_ZERO( slant_factor, SMALL_FASTF ) )
		{
			vect_t to_center;

			t_tmp = norm_dist/slant_factor;
			VJOIN1( hit_pt, rp->r_pt, t_tmp, rp->r_dir );
			VSUB2( to_center, bend->bend_start, hit_pt );
			radius_sq = MAGSQ( to_center );
			if( radius_sq <= bend->bend_or*bend->bend_or && radius_sq >= bend->bend_ir*bend->bend_ir )
			{
				BU_GETSTRUCT( hitp, hit_list );
				BU_GETSTRUCT( hitp->hitp, hit );
				hitp->hitp->hit_magic = RT_HIT_MAGIC;
				hitp->hitp->hit_dist = t_tmp;
				hitp->hitp->hit_surfno = seg_no*10 + PIPE_BEND_BASE;
				(*hit_count)++;
				BU_LIST_INSERT( &hit_headp->l, &hitp->l );
			}
		}
	}
}

HIDDEN void
pipe_end_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead, struct id_pipe *pipe, struct hit_list *hit_headp, int *hit_count, int seg_no)
{
	point_t hit_pt;
	fastf_t t_tmp;
	fastf_t radius_sq;
	struct hit_list *hitp;

	*hit_count = 0;

	if( !pipe->pipe_is_bend )
	{
		struct lin_pipe *lin=(struct lin_pipe *)(&pipe->l);
		point_t top;
		fastf_t dist_to_plane;
		fastf_t norm_dist;
		fastf_t slant_factor;

		VJOIN1( top, lin->pipe_V, lin->pipe_len, lin->pipe_H );
		dist_to_plane = VDOT( lin->pipe_H, top );
		norm_dist = dist_to_plane - VDOT( lin->pipe_H, rp->r_pt );
		slant_factor = VDOT( lin->pipe_H, rp->r_dir );
		if( !NEAR_ZERO( slant_factor, SMALL_FASTF ) )
		{
			vect_t to_center;

			t_tmp = norm_dist/slant_factor;
			VJOIN1( hit_pt, rp->r_pt, t_tmp, rp->r_dir );
			VSUB2( to_center, top, hit_pt );
			radius_sq = MAGSQ( to_center );
			if( radius_sq <= lin->pipe_rotop_sq && radius_sq >= lin->pipe_ritop_sq )
			{
				BU_GETSTRUCT( hitp, hit_list );
				BU_GETSTRUCT( hitp->hitp, hit );
				hitp->hitp->hit_magic = RT_HIT_MAGIC;
				hitp->hitp->hit_dist = t_tmp;
				hitp->hitp->hit_surfno = seg_no*10 + PIPE_LINEAR_TOP;
				(*hit_count)++;
				BU_LIST_INSERT( &hit_headp->l, &hitp->l );
			}
		}
	}
	else if( pipe->pipe_is_bend )
	{
		struct bend_pipe *bend=(struct bend_pipe *)(&pipe->l);
		vect_t to_end;
		vect_t plane_norm;
		fastf_t dist_to_plane;
		fastf_t norm_dist;
		fastf_t slant_factor;

		VSUB2( to_end, bend->bend_end, bend->bend_V );
		VCROSS( plane_norm, to_end, bend->bend_N );
		VUNITIZE( plane_norm );

		dist_to_plane = VDOT( plane_norm, bend->bend_end );
		norm_dist = dist_to_plane - VDOT( plane_norm, rp->r_pt );
		slant_factor = VDOT( plane_norm, rp->r_dir );

		if( !NEAR_ZERO( slant_factor, SMALL_FASTF ) )
		{
			vect_t to_center;

			t_tmp = norm_dist/slant_factor;
			VJOIN1( hit_pt, rp->r_pt, t_tmp, rp->r_dir );
			VSUB2( to_center, bend->bend_end, hit_pt );
			radius_sq = MAGSQ( to_center );
			if( radius_sq <= bend->bend_or*bend->bend_or && radius_sq >= bend->bend_ir*bend->bend_ir )
			{
				BU_GETSTRUCT( hitp, hit_list );
				BU_GETSTRUCT( hitp->hitp, hit );
				hitp->hitp->hit_magic = RT_HIT_MAGIC;
				hitp->hitp->hit_dist = t_tmp;
				hitp->hitp->hit_surfno = seg_no*10 + PIPE_BEND_TOP;
				(*hit_count)++;
				BU_LIST_INSERT( &hit_headp->l, &hitp->l );
			}
		}
	}
}

HIDDEN void
rt_pipe_hitsort(struct hit_list *h, int *nh, register struct xray *rp, struct soltab *stp)
{
	struct hit_list *hitp;
	struct hit_list *first;
	struct hit_list *second;
	struct hit_list *prev;
	struct hit_list *next_hit;

	hitp = BU_LIST_FIRST( hit_list, &h->l );
	while( BU_LIST_NEXT_NOT_HEAD( &hitp->l, &h->l ) )
	{
		struct hit_list *next_hit;
		struct hit_list *prev_hit;

		next_hit = BU_LIST_NEXT( hit_list, &hitp->l );
		if( hitp->hitp->hit_dist > next_hit->hitp->hit_dist )
		{
			struct hit_list *tmp;

			if( hitp == BU_LIST_FIRST( hit_list, &h->l ) )
				prev_hit = (struct hit_list *)NULL;
			else
				prev_hit = BU_LIST_PREV( hit_list, &hitp->l );

			/* move this hit to the end of the list */
			tmp = hitp;
			BU_LIST_DEQUEUE( &tmp->l );
			BU_LIST_INSERT( &h->l, &tmp->l );

			if( prev_hit )
				hitp = prev_hit;
			else
				hitp = BU_LIST_FIRST( hit_list, &h->l );
		}
		else
			hitp = next_hit;
	}

	/* delete duplicate hits */
	hitp = BU_LIST_FIRST( hit_list, &h->l );
	while( BU_LIST_NEXT_NOT_HEAD( &hitp->l, &h->l ) )
	{
		next_hit = BU_LIST_NEXT( hit_list, &hitp->l );

		if( NEAR_ZERO( hitp->hitp->hit_dist - next_hit->hitp->hit_dist, 0.00001) &&
			       hitp->hitp->hit_surfno == next_hit->hitp->hit_surfno )
		{
			struct hit_list *tmp;

			tmp = hitp;
			hitp = next_hit;
			BU_LIST_DEQUEUE( &tmp->l );
			bu_free( (char *)tmp->hitp, "rt_pipe_hitsort: tmp->hitp" );
			bu_free( (char *)tmp, "rt_pipe_hitsort: tmp" );
			(*nh)--;
			tmp = hitp;
			next_hit = BU_LIST_NEXT( hit_list, &hitp->l );
			hitp = next_hit;
			BU_LIST_DEQUEUE( &tmp->l );
			bu_free( (char *)tmp->hitp, "rt_pipe_hitsort: tmp->hitp" );
			bu_free( (char *)tmp, "rt_pipe_hitsort: tmp" );
			(*nh)--;
			if( BU_LIST_IS_HEAD( &hitp->l, &h->l ) )
				break;
		}
		else
			hitp = next_hit;
	}

	if( *nh == 1 )
	{
		while( BU_LIST_WHILE( hitp, hit_list, &h->l ) )
		{
			BU_LIST_DEQUEUE( &hitp->l );
			bu_free( (char *)hitp->hitp, "pipe_hitsort: hitp->hitp" );
			bu_free( (char *)hitp, "pipe_hitsort: hitp" );
		}
		(*nh) = 0;
		return;
	}

	if( *nh == 0 || *nh == 2 )
		return;

	/* handle cases where this pipe overlaps with itself */
	first = BU_LIST_FIRST( hit_list, &h->l );
	if( VDOT( first->hitp->hit_normal, rp->r_dir ) > 0.0 )
	{

		bu_log( "ERROR: first hit on %s (surfno = %d) is an exit at (%g %g %g)\n",
			stp->st_dp->d_namep, first->hitp->hit_surfno, V3ARGS( first->hitp->hit_point ) );
		bu_log( "\tray start = (%.12e %.12e %.12e), ray dir = (%.12e %.12e %.12e)\n",
			V3ARGS( rp->r_pt ), V3ARGS( rp->r_dir ) );

		while( BU_LIST_WHILE( hitp, hit_list, &h->l ) )
		{
			BU_LIST_DEQUEUE( &hitp->l );
			bu_free( (char *)hitp->hitp, "pipe_hitsort: hitp->hitp" );
			bu_free( (char *)hitp, "pipe_hitsort: hitp" );
		}
		(*nh) = 0;
		return;
	}

	while( BU_LIST_NOT_HEAD( &first->l, &h->l ) )
	{
		second = BU_LIST_NEXT( hit_list, &first->l );
		if( BU_LIST_IS_HEAD( &second->l, &h->l ) )
			break;

		while( BU_LIST_NOT_HEAD( &second->l, &h->l ) && VDOT( second->hitp->hit_normal, rp->r_dir ) < 0.0 )
		{
			prev = second;
			second = BU_LIST_NEXT( hit_list, &second->l );
			if( BU_LIST_NOT_HEAD( &second->l, &h->l ) )
			{
				BU_LIST_DEQUEUE( &prev->l );
				bu_free( (char *)prev->hitp, "pipe_hitsort: prev->hitp" );
				bu_free( (char *)prev, "pipe_hitsort: prev" );
				(*nh)--;
			}
		}
		prev = NULL;
		while( BU_LIST_NOT_HEAD( &second->l, &h->l ) && VDOT( second->hitp->hit_normal, rp->r_dir ) > 0.0 )
		{
			if( prev )
			{
				BU_LIST_DEQUEUE( &prev->l );
				bu_free( (char *)prev->hitp, "pipe_hitsort: prev->hitp" );
				bu_free( (char *)prev, "pipe_hitsort: prev" );
				(*nh)--;
			}
			prev = second;
			second = BU_LIST_NEXT( hit_list, &second->l );
		}
		first = second;
	}
}

/*
 *  			R T _ P I P E _ N O R M
 *  
 *  Given ONE ray distance, return the normal and entry/exit point.
 */
void
rt_pipe_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
{
	register struct bu_list		*pipe =
		(struct bu_list *)stp->st_specific;
	register struct id_pipe		*pipe_id;
	register struct lin_pipe	*pipe_lin;
	register struct bend_pipe	*pipe_bend;
	LOCAL fastf_t	w;
	LOCAL vect_t	work;
	LOCAL vect_t	work1;
	LOCAL int	segno;
	LOCAL int	i;

	segno = hitp->hit_surfno/10;

	pipe_id = BU_LIST_FIRST( id_pipe, pipe );
	for( i=1 ; i<segno ; i++ )
		pipe_id = BU_LIST_NEXT( id_pipe, &pipe_id->l );

	pipe_lin = (struct lin_pipe *)pipe_id;
	pipe_bend = (struct bend_pipe *)pipe_id;

	VJOIN1( hitp->hit_point, rp->r_pt, hitp->hit_dist, rp->r_dir );
	switch( hitp->hit_surfno%10 )
	{
		case PIPE_LINEAR_TOP:
			VMOVE( hitp->hit_normal, pipe_lin->pipe_H );
			break;
		case PIPE_LINEAR_BASE:
			VREVERSE( hitp->hit_normal, pipe_lin->pipe_H );
			break;
		case PIPE_LINEAR_OUTER_BODY:
			MAT4X3VEC( hitp->hit_normal, pipe_lin->pipe_invRoS, hitp->hit_vpriv );
			VUNITIZE( hitp->hit_normal );
			break;
		case PIPE_LINEAR_INNER_BODY:
			MAT4X3VEC( hitp->hit_normal, pipe_lin->pipe_invRoS, hitp->hit_vpriv );
			VUNITIZE( hitp->hit_normal );
			VREVERSE( hitp->hit_normal, hitp->hit_normal );
			break;
		case PIPE_BEND_OUTER_BODY:
			w = hitp->hit_vpriv[X]*hitp->hit_vpriv[X] +
			    hitp->hit_vpriv[Y]*hitp->hit_vpriv[Y] +
			    hitp->hit_vpriv[Z]*hitp->hit_vpriv[Z] +
			    1.0 - pipe_bend->bend_alpha_o*pipe_bend->bend_alpha_o;
			VSET( work,
				( w - 2.0 ) * hitp->hit_vpriv[X],
				( w - 2.0 ) * hitp->hit_vpriv[Y],
				  w * hitp->hit_vpriv[Z] );
			VUNITIZE( work );
			MAT3X3VEC( hitp->hit_normal, pipe_bend->bend_invR, work );
			break;
		case PIPE_BEND_INNER_BODY:
			w = hitp->hit_vpriv[X]*hitp->hit_vpriv[X] +
			    hitp->hit_vpriv[Y]*hitp->hit_vpriv[Y] +
			    hitp->hit_vpriv[Z]*hitp->hit_vpriv[Z] +
			    1.0 - pipe_bend->bend_alpha_o*pipe_bend->bend_alpha_o;
			VSET( work,
				( w - 2.0 ) * hitp->hit_vpriv[X],
				( w - 2.0 ) * hitp->hit_vpriv[Y],
				  w * hitp->hit_vpriv[Z] );
			VUNITIZE( work );
			MAT3X3VEC( work1, pipe_bend->bend_invR, work );
			VREVERSE( hitp->hit_normal, work1 );
			break;
		case PIPE_BEND_BASE:
			VREVERSE( hitp->hit_normal, pipe_bend->bend_rb );
			break;
		case PIPE_BEND_TOP:
			VSUB2( work, pipe_bend->bend_end, pipe_bend->bend_V );
			VCROSS( hitp->hit_normal, pipe_bend->bend_N, work );
			VUNITIZE( hitp->hit_normal );
			break;
		default:
			bu_log( "rt_pipe_norm: Unrecognized surfno (%d)\n", hitp->hit_surfno );
			break;
	}
}

/*
 *  			R T _ P I P E _ S H O T
 *  
 *  Intersect a ray with a pipe.
 *  If an intersection occurs, a struct seg will be acquired
 *  and filled in.
 *  
 *  Returns -
 *  	0	MISS
 *	>0	HIT
 */
int
rt_pipe_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
{
	register struct bu_list		*head =
		(struct bu_list *)stp->st_specific;
	register struct id_pipe		*pipe_id;
	register struct seg		*segp;
	LOCAL struct hit_list		hit_head;
	LOCAL struct hit_list		*hitp;
	LOCAL int			hit_count;
	LOCAL int			total_hits;
	LOCAL int			seg_no;
	LOCAL int			i;

	BU_LIST_INIT( &hit_head.l );

	pipe_start_shot( stp, rp, ap, seghead, BU_LIST_FIRST( id_pipe, head ),
		&hit_head, &total_hits, 1 );
	seg_no = 0;
	for( BU_LIST_FOR( pipe_id, id_pipe, head ) )
		seg_no++;
	pipe_end_shot( stp, rp, ap, seghead, BU_LIST_LAST( id_pipe, head ),
		&hit_head, &hit_count, seg_no );
	total_hits += hit_count;

	seg_no = 0;
	for( BU_LIST_FOR( pipe_id, id_pipe, head ) )
	{
		seg_no++;

		if( !pipe_id->pipe_is_bend )
		{
			linear_pipe_shot( stp, rp, ap, seghead, (struct lin_pipe *)pipe_id,
				&hit_head, &hit_count, seg_no );
			total_hits += hit_count;
		}
		else
		{
			bend_pipe_shot( stp, rp, ap, seghead, (struct bend_pipe *)pipe_id,
				&hit_head, &hit_count, seg_no );
			total_hits += hit_count;
		}
	}
	if( !total_hits )
		return( 0 );

	/* calculate hit points and normals */
	for( BU_LIST_FOR( hitp, hit_list, &hit_head.l ) )
		rt_pipe_norm( hitp->hitp, stp , rp );

	rt_pipe_hitsort( &hit_head, &total_hits, rp, stp );

	/* Build segments */
	if( total_hits%2 )
	{
		i = 0;
		bu_log( "rt_pipe_shot: bad number of hits on solid %s (%d)\n", stp->st_dp->d_namep, total_hits );
		bu_log( "Ignoring this solid for this ray\n" );
		bu_log( "\tray start = (%e %e %e), ray dir = (%e %e %e)\n", V3ARGS( rp->r_pt ), V3ARGS( rp->r_dir ) );
		for( BU_LIST_FOR( hitp, hit_list, &hit_head.l ) )
		{
			point_t hit_pt;

			bu_log( "#%d, dist = %g, surfno=%d\n" , ++i, hitp->hitp->hit_dist, hitp->hitp->hit_surfno );
			VJOIN1( hit_pt, rp->r_pt, hitp->hitp->hit_dist,  rp->r_dir );
			bu_log( "\t( %g %g %g )\n" , V3ARGS( hit_pt ) );
		}

		/* free the list of hits */
		while( BU_LIST_WHILE( hitp, hit_list, &hit_head.l ) )
		{
			BU_LIST_DEQUEUE( &hitp->l );
			bu_free( (char *)hitp->hitp, "rt_pipe_shot: hitp->hitp" );
			bu_free( (char *)hitp, "rt_pipe_shot: hitp" );
		}

		return( 0 );
	}

	hitp = BU_LIST_FIRST( hit_list, &hit_head.l );
	while( BU_LIST_NOT_HEAD( &hitp->l, &hit_head.l ) )
	{
		struct hit_list *next;

		next = BU_LIST_NEXT( hit_list, &hitp->l );

		RT_GET_SEG(segp, ap->a_resource);

		segp->seg_stp = stp;
		segp->seg_in = (*hitp->hitp);
		segp->seg_out = (*next->hitp);

		BU_LIST_INSERT( &(seghead->l), &(segp->l) );

		hitp = BU_LIST_NEXT( hit_list, &next->l );
	}

	/* free the list of hits */
	while( BU_LIST_WHILE( hitp, hit_list, &hit_head.l ) )
	{
		BU_LIST_DEQUEUE( &hitp->l );
		bu_free( (char *)hitp->hitp, "rt_pipe_shot: hitp->hitp" );
		bu_free( (char *)hitp, "rt_pipe_shot: hitp" );
	}

	if( total_hits )
		return( 1 );		/* HIT */
	else
		return(0);		/* MISS */
}

#define SEG_MISS(SEG)		(SEG).seg_stp=(struct soltab *) 0;	

/*
 *			R T_ P I P E _ V S H O T
 *
 *  Vectorized version.
 */
void
rt_pipe_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		  	       /* Number of ray/object pairs */
                  	    
{
	rt_vstub( stp, rp, segp, n, ap );
}

/*
 *			R T _ P I P E _ C U R V E
 *
 *  Return the curvature of the pipe.
 */
void
rt_pipe_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
{
/*	register struct bu_list *pipe =
		(struct bu_list *)stp->st_specific; */

 	cvp->crv_c1 = cvp->crv_c2 = 0;

	/* any tangent direction */
 	bn_vec_ortho( cvp->crv_pdir, hitp->hit_normal );
}

/*
 *  			R T _ P I P E _ U V
 *  
 *  For a hit on the surface of an pipe, return the (u,v) coordinates
 *  of the hit point, 0 <= u,v <= 1.
 *  u = azimuth
 *  v = elevation
 */
void
rt_pipe_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
{
/*	register struct bu_list *pipe =
		(struct bu_list *)stp->st_specific; */
}

/*
 *		R T _ P I P E _ F R E E
 */
void
rt_pipe_free(register struct soltab *stp)
{
#if 0
	register struct bu_list *pipe =
		(struct bu_list *)stp->st_specific;

	/* free linked list */
	while( BU_LIST_NON_EMPTY( &pipe->id.l ) )
	{
		register struct bu_list *pipe_ptr;

		pipe_ptr = (struct bu_list *)(&pipe->id.l)->forw;
		bu_free( (char *)pipe_ptr, "pipe_specific" );
	}

	/* free list head */
	bu_free( (char *)pipe, "pipe_specific head" );
#endif
}

/*
 *			R T _ P I P E _ C L A S S
 */
int
rt_pipe_class(void)
{
	return(0);
}

/*	D R A W _ P I P E _ A R C
 *
 * v1 and v2 must be unit vectors normal to each other in plane of circle
 * v1 must be in direction from center to start point (unless a full circle is
 * requested). "End" is the endpoint of arc. "Seg_count"
 * is how many straight line segements to use to draw the arc. "Full_circle"
 * is a flag to indicate that a complete circle is desired.
 */

HIDDEN void
draw_pipe_arc(struct bu_list *vhead, fastf_t radius, fastf_t *center, const fastf_t *v1, const fastf_t *v2, fastf_t *end, int seg_count, int full_circle)
{
	fastf_t		arc_angle;
	fastf_t		delta_ang;
	fastf_t		cos_del, sin_del;
	fastf_t		x, y, xnew, ynew;
	vect_t		to_end;
	point_t		pt;
	int		i;

	if( !full_circle )
	{
		VSUB2( to_end, end, center );
		arc_angle = atan2( VDOT( to_end, v2 ), VDOT( to_end, v1 ) );
		delta_ang = arc_angle/seg_count;
	}
	else
		delta_ang = 2.0*bn_pi/seg_count;

	cos_del = cos( delta_ang );
	sin_del = sin( delta_ang );

	x = radius;
	y = 0.0;
	VJOIN2( pt, center, x, v1, y, v2 );
	RT_ADD_VLIST( vhead, pt, BN_VLIST_LINE_MOVE );
	for( i=0 ; i<seg_count ; i++ )
	{
		xnew = x*cos_del - y*sin_del;
		ynew = x*sin_del + y*cos_del;
		VJOIN2( pt, center, xnew, v1, ynew, v2 );
		RT_ADD_VLIST( vhead, pt, BN_VLIST_LINE_DRAW );
		x = xnew;
		y = ynew;
	}
}

HIDDEN void
draw_linear_seg(struct bu_list *vhead, const fastf_t *p1, const fastf_t or1, const fastf_t ir1, const fastf_t *p2, const fastf_t or2, const fastf_t ir2, const fastf_t *v1, const fastf_t *v2)
{
	point_t pt;

	VJOIN1( pt, p1, or1, v1 );
	RT_ADD_VLIST( vhead, pt, BN_VLIST_LINE_MOVE );
	VJOIN1( pt, p2, or2, v1 );
	RT_ADD_VLIST( vhead, pt, BN_VLIST_LINE_DRAW );
	VJOIN1( pt, p1, or1, v2 );
	RT_ADD_VLIST( vhead, pt, BN_VLIST_LINE_MOVE );
	VJOIN1( pt, p2, or2, v2 );
	RT_ADD_VLIST( vhead, pt, BN_VLIST_LINE_DRAW );
	VJOIN1( pt, p1, -or1, v1 );
	RT_ADD_VLIST( vhead, pt, BN_VLIST_LINE_MOVE );
	VJOIN1( pt, p2, -or2, v1 );
	RT_ADD_VLIST( vhead, pt, BN_VLIST_LINE_DRAW );
	VJOIN1( pt, p1, -or1, v2 );
	RT_ADD_VLIST( vhead, pt, BN_VLIST_LINE_MOVE );
	VJOIN1( pt, p2, -or2, v2 );
	RT_ADD_VLIST( vhead, pt, BN_VLIST_LINE_DRAW );

	if( ir1 <= 0.0 && ir2 <= 0.0 )
		return;

	VJOIN1( pt, p1, ir1, v1 );
	RT_ADD_VLIST( vhead, pt, BN_VLIST_LINE_MOVE );
	VJOIN1( pt, p2, ir2, v1 );
	RT_ADD_VLIST( vhead, pt, BN_VLIST_LINE_DRAW );
	VJOIN1( pt, p1, ir1, v2 );
	RT_ADD_VLIST( vhead, pt, BN_VLIST_LINE_MOVE );
	VJOIN1( pt, p2, ir2, v2 );
	RT_ADD_VLIST( vhead, pt, BN_VLIST_LINE_DRAW );
	VJOIN1( pt, p1, -ir1, v1 );
	RT_ADD_VLIST( vhead, pt, BN_VLIST_LINE_MOVE );
	VJOIN1( pt, p2, -ir2, v1 );
	RT_ADD_VLIST( vhead, pt, BN_VLIST_LINE_DRAW );
	VJOIN1( pt, p1, -ir1, v2 );
	RT_ADD_VLIST( vhead, pt, BN_VLIST_LINE_MOVE );
	VJOIN1( pt, p2, -ir2, v2 );
	RT_ADD_VLIST( vhead, pt, BN_VLIST_LINE_DRAW );
}

HIDDEN void
draw_pipe_bend(struct bu_list *vhead, const fastf_t *center, const fastf_t *end, const fastf_t radius, const fastf_t angle, const fastf_t *v1, const fastf_t *v2, const fastf_t *norm, const fastf_t or, const fastf_t ir, fastf_t *f1, fastf_t *f2, const int seg_count)
{

	point_t	tmp_center, tmp_start, tmp_end;
	vect_t tmp_vec;
	fastf_t tmp_radius;
	fastf_t move_dist;
	vect_t end_f1,end_f2;
	mat_t mat;
	vect_t tmp_norm;

	VREVERSE( tmp_norm, norm );
	bn_mat_arb_rot( mat, center, tmp_norm, angle );
	MAT4X3VEC( tmp_vec, mat, f1 );
	VMOVE( end_f1, tmp_vec );
	MAT4X3VEC( tmp_vec, mat, f2 );
	VMOVE( end_f2, tmp_vec );

	move_dist = or * VDOT( f1, norm );
	VJOIN2( tmp_start, center, radius, v1, or, f1 );
	VJOIN1( tmp_center, center, move_dist, norm );
	VJOIN1( tmp_end, end, or, end_f1 );
	VSUB2( tmp_vec, tmp_start, tmp_center );
	tmp_radius = MAGNITUDE( tmp_vec );
	draw_pipe_arc( vhead, tmp_radius, tmp_center, v1, v2, tmp_end, seg_count, 0 );
	VJOIN2( tmp_start, center, radius, v1, -or, f1 );
	VJOIN1( tmp_center, center, -move_dist, norm );
	VJOIN1( tmp_end, end, -or, end_f1 );
	VSUB2( tmp_vec, tmp_start, tmp_center );
	tmp_radius = MAGNITUDE( tmp_vec );
	draw_pipe_arc( vhead, tmp_radius, tmp_center, v1, v2, tmp_end, seg_count, 0 );
	move_dist = or * VDOT( f2, norm );
	VJOIN2( tmp_start, center, radius, v1, or, f2 );
	VJOIN1( tmp_center, center, move_dist, norm );
	VJOIN1( tmp_end, end, or, end_f2 );
	VSUB2( tmp_vec, tmp_start, tmp_center );
	tmp_radius = MAGNITUDE( tmp_vec );
	draw_pipe_arc( vhead, tmp_radius, tmp_center, v1, v2, tmp_end, seg_count, 0 );
	VJOIN2( tmp_start, center, radius, v1, -or, f2 );
	VJOIN1( tmp_center, center, -move_dist, norm );
	VJOIN1( tmp_end, end, -or, end_f2 );
	VSUB2( tmp_vec, tmp_start, tmp_center );
	tmp_radius = MAGNITUDE( tmp_vec );
	draw_pipe_arc( vhead, tmp_radius, tmp_center, v1, v2, tmp_end, seg_count, 0 );

	if( ir <= 0.0 )
	{
		VMOVE( f1, end_f1 );
		VMOVE( f2, end_f2 );
		return;
	}

	move_dist = ir * VDOT( f1, norm );
	VJOIN2( tmp_start, center, radius, v1, ir, f1 );
	VJOIN1( tmp_center, center, move_dist, norm );
	VJOIN1( tmp_end, end, ir, end_f1 );
	VSUB2( tmp_vec, tmp_start, tmp_center );
	tmp_radius = MAGNITUDE( tmp_vec );
	draw_pipe_arc( vhead, tmp_radius, tmp_center, v1, v2, tmp_end, seg_count, 0 );
	VJOIN2( tmp_start, center, radius, v1, -ir, f1 );
	VJOIN1( tmp_center, center, -move_dist, norm );
	VJOIN1( tmp_end, end, -ir, end_f1 );
	VSUB2( tmp_vec, tmp_start, tmp_center );
	tmp_radius = MAGNITUDE( tmp_vec );
	draw_pipe_arc( vhead, tmp_radius, tmp_center, v1, v2, tmp_end, seg_count, 0 );
	move_dist = ir * VDOT( f2, norm );
	VJOIN2( tmp_start, center, radius, v1, ir, f2 );
	VJOIN1( tmp_center, center, move_dist, norm );
	VJOIN1( tmp_end, end, ir, end_f2 );
	VSUB2( tmp_vec, tmp_start, tmp_center );
	tmp_radius = MAGNITUDE( tmp_vec );
	draw_pipe_arc( vhead, tmp_radius, tmp_center, v1, v2, tmp_end, seg_count, 0 );
	VJOIN2( tmp_start, center, radius, v1, -ir, f2 );
	VJOIN1( tmp_center, center, -move_dist, norm );
	VJOIN1( tmp_end, end, -ir, end_f2 );
	VSUB2( tmp_vec, tmp_start, tmp_center );
	tmp_radius = MAGNITUDE( tmp_vec );
	draw_pipe_arc( vhead, tmp_radius, tmp_center, v1, v2, tmp_end, seg_count, 0 );

	VMOVE( f1, end_f1 );
	VMOVE( f2, end_f2 );
}

/*
 *			R T _ P I P E _ P L O T
 */
int
rt_pipe_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
	register struct wdb_pipept		*prevp;
	register struct wdb_pipept		*curp;
	register struct wdb_pipept		*nextp;
	LOCAL struct rt_pipe_internal		*pip;
	LOCAL point_t				current_point;
	LOCAL vect_t				f1,f2,f3;

	RT_CK_DB_INTERNAL(ip);
	pip = (struct rt_pipe_internal *)ip->idb_ptr;
	RT_PIPE_CK_MAGIC(pip);

	if( BU_LIST_IS_EMPTY( &pip->pipe_segs_head ) )
		return( 0 );

	prevp = BU_LIST_FIRST( wdb_pipept, &pip->pipe_segs_head );
	curp = BU_LIST_NEXT( wdb_pipept, &prevp->l );
	nextp = BU_LIST_NEXT( wdb_pipept, &curp->l );

	if( BU_LIST_IS_HEAD( &curp->l , &pip->pipe_segs_head ) )
		return( 0 );	/* nothing to plot */

	VMOVE( current_point, prevp->pp_coord );

	/* draw end at pipe start */
	VSUB2( f3, prevp->pp_coord, curp->pp_coord );
	bn_vec_ortho( f1, f3 );
	VCROSS( f2, f3, f1 );
	VUNITIZE( f2 );

	draw_pipe_arc( vhead, prevp->pp_od/2.0, prevp->pp_coord, f1, f2, f2, ARC_SEGS, 1 );
	if( prevp->pp_id > 0.0 )
		draw_pipe_arc( vhead, prevp->pp_id/2.0, prevp->pp_coord, f1, f2, f2, ARC_SEGS, 1 );

	while( 1 )
	{
		LOCAL vect_t n1,n2;
		LOCAL vect_t norm;
		LOCAL fastf_t angle;
		LOCAL fastf_t dist_to_bend;

		if( BU_LIST_IS_HEAD( &nextp->l, &pip->pipe_segs_head ) )
		{
			/* last segment */
			draw_linear_seg( vhead, current_point, prevp->pp_od/2.0, prevp->pp_id/2.0,
				curp->pp_coord, curp->pp_od/2.0, curp->pp_id/2.0, f1, f2 );
			break;
		}

		VSUB2( n1, prevp->pp_coord, curp->pp_coord );
		if( VNEAR_ZERO( n1, SQRT_SMALL_FASTF ) )
		{
			/* duplicate point, nothing to plot */
			goto next_pt;
		}
		VSUB2( n2, nextp->pp_coord, curp->pp_coord );
		VCROSS( norm, n1, n2 );
		VUNITIZE( n1 );
		VUNITIZE( n2 );
		angle = bn_pi - acos( VDOT( n1, n2 ) );
		dist_to_bend = curp->pp_bendradius * tan( angle/2.0 );
		if( isnan( dist_to_bend ) || VNEAR_ZERO( norm, SQRT_SMALL_FASTF) || NEAR_ZERO( dist_to_bend, SQRT_SMALL_FASTF) )
		{
			/* points are colinear, draw linear segment */
			draw_linear_seg( vhead, current_point, prevp->pp_od/2.0, prevp->pp_id/2.0,
				curp->pp_coord, curp->pp_od/2.0, curp->pp_id/2.0, f1, f2 );
			VMOVE( current_point, curp->pp_coord );
		}
		else
		{
			LOCAL point_t bend_center;
			LOCAL point_t bend_start;
			LOCAL point_t bend_end;
			LOCAL vect_t v1,v2;

			VUNITIZE( norm );

			/* draw linear segment to start of bend */
			VJOIN1( bend_start, curp->pp_coord, dist_to_bend, n1 );
			draw_linear_seg( vhead, current_point, prevp->pp_od/2.0, prevp->pp_id/2.0,
				bend_start, curp->pp_od/2.0, curp->pp_id/2.0, f1, f2 );

			/* draw bend */
			VJOIN1( bend_end, curp->pp_coord, dist_to_bend, n2 );
			VCROSS( v1, n1, norm );
			VCROSS( v2, v1, norm );
			VJOIN1( bend_center, bend_start, -curp->pp_bendradius, v1 );
			draw_pipe_bend( vhead, bend_center, bend_end, curp->pp_bendradius, angle, v1, v2, norm,
				curp->pp_od/2.0, curp->pp_id/2.0, f1, f2, ARC_SEGS );

			VMOVE( current_point, bend_end );
		}
next_pt:
		prevp = curp;
		curp = nextp;
		nextp = BU_LIST_NEXT( wdb_pipept, &curp->l );
	}

	draw_pipe_arc( vhead, curp->pp_od/2.0, curp->pp_coord, f1, f2, f2, ARC_SEGS, 1 );
	if( curp->pp_id > 0.0 )
		draw_pipe_arc( vhead, curp->pp_id/2.0, curp->pp_coord, f1, f2, f2, ARC_SEGS, 1 );

	return(0);
}

HIDDEN void
tesselate_pipe_start(struct wdb_pipept *pipe, int arc_segs, double sin_del, double cos_del, struct vertex ***outer_loop, struct vertex ***inner_loop, fastf_t *r1, fastf_t *r2, struct shell *s, const struct bn_tol *tol)
{
	struct faceuse *fu;
	struct loopuse *lu;
	struct edgeuse *eu;
	struct wdb_pipept *next;
	point_t pt;
	fastf_t or;
	fastf_t ir;
	fastf_t x,y,xnew,ynew;
	vect_t n;
	int i;

	NMG_CK_SHELL( s );
	BN_CK_TOL( tol );

	next = BU_LIST_NEXT( wdb_pipept, &pipe->l );

	VSUB2( n, pipe->pp_coord, next->pp_coord );
	VUNITIZE( n );
	bn_vec_ortho( r1, n );
	VCROSS( r2, n, r1 );

	or = pipe->pp_od/2.0;
	ir = pipe->pp_id/2.0;

	if( or <= tol->dist )
		return;

	if( ir > or )
	{
		bu_log( "Inner radius larger than outer radius at start of pipe solid\n" );
		return;
	}

	if( NEAR_ZERO( ir - or, tol->dist) )
		return;


	fu = nmg_cface( s, *outer_loop, arc_segs );

	x = or;
	y = 0.0;
	i = (-1);
	lu = BU_LIST_FIRST( loopuse, &fu->lu_hd );
	for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
	{
		VJOIN2( pt, pipe->pp_coord, x, r1, y, r2 );
		(*outer_loop)[++i] = eu->vu_p->v_p;
		nmg_vertex_gv( eu->vu_p->v_p, pt );
		xnew = x*cos_del - y*sin_del;
		ynew = x*sin_del + y*cos_del;
		x = xnew;
		y = ynew;
	}

	if( ir > tol->dist )
	{
		struct edgeuse *new_eu;
		struct vertexuse *vu;

		/* create a loop of a single vertex using the first vertex from the inner loop */
		lu = nmg_mlv( &fu->l.magic, (struct vertex *)NULL, OT_OPPOSITE );

		vu = BU_LIST_FIRST( vertexuse, &lu->down_hd );
		eu = nmg_meonvu( vu );
		(*inner_loop)[0] = eu->vu_p->v_p;

		x = ir;
		y = 0.0;
		VJOIN2( pt, pipe->pp_coord, x, r1, y, r2 );
		nmg_vertex_gv( (*inner_loop)[0], pt );
		/* split edges in loop for each vertex in inner loop */
		for( i=1 ; i<arc_segs ; i++ )
		{
			new_eu = nmg_eusplit( (struct vertex *)NULL, eu, 0 );
			(*inner_loop)[i] = new_eu->vu_p->v_p;
			xnew = x*cos_del - y*sin_del;
			ynew = x*sin_del + y*cos_del;
			x = xnew;
			y = ynew;
			VJOIN2( pt, pipe->pp_coord, x, r1, y, r2 );
			nmg_vertex_gv( (*inner_loop)[i], pt );
		}
	}

	else if( next->pp_id > tol->dist )
	{
		struct vertexuse *vu;

		/* make a loop of a single vertex in this face */
		lu = nmg_mlv( &fu->l.magic, (struct vertex *)NULL, OT_OPPOSITE );
		vu = BU_LIST_FIRST( vertexuse, &lu->down_hd );

		nmg_vertex_gv( vu->v_p, pipe->pp_coord );
	}

	if( nmg_calc_face_g( fu ) )
		rt_bomb( "tesselate_pipe_start: nmg_calc_face_g failed\n" );

	for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
	{
		NMG_CK_LOOPUSE( lu );

		if( BU_LIST_FIRST_MAGIC(&lu->down_hd) != NMG_EDGEUSE_MAGIC )
			continue;

		for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
		{
			NMG_CK_EDGEUSE( eu );
			eu->e_p->is_real = 1;
		}
	}
}

HIDDEN void
tesselate_pipe_linear(fastf_t *start_pt, fastf_t or, fastf_t ir, fastf_t *end_pt, fastf_t end_or, fastf_t end_ir, int arc_segs, double sin_del, double cos_del, struct vertex ***outer_loop, struct vertex ***inner_loop, fastf_t *r1, fastf_t *r2, struct shell *s, const struct bn_tol *tol)
{
	struct vertex **new_outer_loop;
	struct vertex **new_inner_loop;
	struct vertex **verts[3];
	struct faceuse *fu;
	vect_t *norms;
	vect_t n;
	fastf_t slope;
	fastf_t seg_len;
	int i,j;

	NMG_CK_SHELL( s );
	BN_CK_TOL( tol );

	norms = (vect_t *)bu_calloc( arc_segs, sizeof( vect_t ), "tesselate_pipe_linear: new normals" );

	if( end_or > tol->dist )
		new_outer_loop = (struct vertex **)bu_calloc( arc_segs, sizeof( struct vertex *),
				"tesselate_pipe_linear: new_outer_loop" );
	else
		new_outer_loop = (struct vertex **)NULL;

	if( end_ir > tol->dist )
		new_inner_loop = (struct vertex **)bu_calloc( arc_segs, sizeof( struct vertex *),
				"tesselate_pipe_linear: new_inner_loop" );
	else
		new_inner_loop = (struct vertex **)NULL;

	VSUB2( n, end_pt, start_pt );
	seg_len = MAGNITUDE( n );
	VSCALE( n, n, 1.0/seg_len );
	slope = (or - end_or)/seg_len;

	if( or > tol->dist && end_or > tol->dist )
	{
		point_t pt;
		fastf_t x,y,xnew,ynew;
		struct faceuse *fu_prev=(struct faceuse *)NULL;
		struct vertex **verts[3];

		x = 1.0;
		y = 0.0;
		VCOMB2( norms[0], x, r1, y, r2 );
		VJOIN1( norms[0], norms[0], slope, n );
		VUNITIZE( norms[0] );
		for( i=0 ; i<arc_segs ; i++ )
		{
			j = i+1;
			if( j == arc_segs )
				j = 0;

			VJOIN2( pt, end_pt, x*end_or, r1, y*end_or, r2 );
			xnew = x*cos_del - y*sin_del;
			ynew = x*sin_del + y*cos_del;
			x = xnew;
			y = ynew;
			if( i < arc_segs-1 )
			{
				VCOMB2( norms[j], x, r1, y, r2 );
				VJOIN1( norms[j], norms[j], slope, n );
				VUNITIZE( norms[j] );
			}

			if( fu_prev )
			{
				nmg_vertex_gv( new_outer_loop[i], pt );
				if( nmg_calc_face_g( fu_prev ) )
				{
					bu_log( "tesselate_pipe_linear: nmg_calc_face_g failed\n" );
					nmg_kfu( fu_prev );
				}
				else
				{
					/* assign vertexuse normals */
					struct loopuse *lu;
					struct edgeuse *eu;

					NMG_CK_FACEUSE( fu_prev );

					if( fu_prev->orientation != OT_SAME )
						fu_prev = fu_prev->fumate_p;

					lu = BU_LIST_FIRST( loopuse, &fu_prev->lu_hd );

					for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
					{
						vect_t reverse_norm;
						struct edgeuse *eu_opp_use;

						eu_opp_use = BU_LIST_PNEXT_CIRC( edgeuse, &eu->eumate_p->l );
						if( eu->vu_p->v_p == new_outer_loop[i-1] )
						{
							nmg_vertexuse_nv( eu->vu_p, norms[i-1] );
							VREVERSE( reverse_norm, norms[i-1] );
							nmg_vertexuse_nv( eu_opp_use->vu_p, reverse_norm );
						}
						else if(  eu->vu_p->v_p == (*outer_loop)[i-1] )
						{
							nmg_vertexuse_nv( eu->vu_p, norms[i-1] );
							VREVERSE( reverse_norm, norms[i-1] );
							nmg_vertexuse_nv( eu_opp_use->vu_p, reverse_norm );
						}
						else if(  eu->vu_p->v_p == new_outer_loop[i] )
						{
							nmg_vertexuse_nv( eu->vu_p, norms[i] );
							VREVERSE( reverse_norm, norms[i] );
							nmg_vertexuse_nv( eu_opp_use->vu_p, reverse_norm );
						}
						else if(  eu->vu_p->v_p == (*outer_loop)[i] )
						{
							nmg_vertexuse_nv( eu->vu_p, norms[i] );
							VREVERSE( reverse_norm, norms[i] );
							nmg_vertexuse_nv( eu_opp_use->vu_p, reverse_norm );
						}
						else
						{
							bu_log( "No vu_normal assigned at (%g %g %g)\n", V3ARGS( eu->vu_p->v_p->vg_p->coord ) );
							bu_log( "\ti=%d, arc_segs=%d, fu_prev = x%x\n" , i, arc_segs, fu_prev );
						}
					}
				}
			}

			verts[0] = &(*outer_loop)[j];
			verts[1] = &(*outer_loop)[i];
			verts[2] = &new_outer_loop[i];

			if( (fu = nmg_cmface( s, verts, 3 ) ) == NULL )
			{
				bu_log( "tesselate_pipe_linear: failed to make outer face #%d or=%g, end_or=%g\n",
						i, or, end_or );
				continue;
			}
			if( !new_outer_loop[i]->vg_p )
				nmg_vertex_gv( new_outer_loop[i], pt );

			if( nmg_calc_face_g( fu ) )
			{
				bu_log( "tesselate_pipe_linear: nmg_calc_face_g failed\n" );
				nmg_kfu( fu );
			}
			else
			{
				/* assign vertexuse normals */
				struct loopuse *lu;
				struct edgeuse *eu;

				NMG_CK_FACEUSE( fu );

				if( fu->orientation != OT_SAME )
					fu = fu->fumate_p;

				lu = BU_LIST_FIRST( loopuse, &fu->lu_hd );

				for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
				{
					vect_t reverse_norm;
					struct edgeuse *eu_opp_use;

					eu_opp_use = BU_LIST_PNEXT_CIRC( edgeuse, &eu->eumate_p->l );
					if( eu->vu_p->v_p == (*outer_loop)[0] )
					{
						nmg_vertexuse_nv( eu->vu_p, norms[0] );
						VREVERSE( reverse_norm, norms[0] );
						nmg_vertexuse_nv( eu_opp_use->vu_p, reverse_norm );
					}
					else if(  eu->vu_p->v_p == new_outer_loop[i] )
					{
						nmg_vertexuse_nv( eu->vu_p, norms[i] );
						VREVERSE( reverse_norm, norms[i] );
						nmg_vertexuse_nv( eu_opp_use->vu_p, reverse_norm );
					}
					else if(  eu->vu_p->v_p == (*outer_loop)[i] )
					{
						nmg_vertexuse_nv( eu->vu_p, norms[i] );
						VREVERSE( reverse_norm, norms[i] );
						nmg_vertexuse_nv( eu_opp_use->vu_p, reverse_norm );
					}
					else if(  eu->vu_p->v_p == (*outer_loop)[j] )
					{
						nmg_vertexuse_nv( eu->vu_p, norms[j] );
						VREVERSE( reverse_norm, norms[j] );
						nmg_vertexuse_nv( eu_opp_use->vu_p, reverse_norm );
					}
					else
					{
						bu_log( "No vu_normal assigned at (%g %g %g)\n", V3ARGS( eu->vu_p->v_p->vg_p->coord ) );
						bu_log( "\ti=%d, arc_segs=%d, fu = x%x\n" , i, arc_segs, fu );
					}
				}
			}

			verts[1] = verts[2];
			verts[2] = &new_outer_loop[j];

			if( (fu_prev = nmg_cmface( s, verts, 3 ) ) == NULL )
			{
				bu_log( "tesselate_pipe_linear: failed to make outer face #%d or=%g, end_or=%g\n",
						i, or, end_or );
				continue;
			}
			if( i == arc_segs-1 )
			{
				if( nmg_calc_face_g( fu_prev ) )
				{
					bu_log( "tesselate_pipe_linear: nmg_calc_face_g failed\n" );
					nmg_kfu( fu_prev );
				}
			}
		}
		bu_free( (char *)(*outer_loop), "tesselate_pipe_bend: outer_loop" );
		*outer_loop = new_outer_loop;
	}
	else if( or > tol->dist && end_or <= tol->dist )
	{
		struct vertex *v=(struct vertex *)NULL;

		VSUB2( norms[0], (*outer_loop)[0]->vg_p->coord, start_pt );
		VJOIN1( norms[0], norms[0], slope*or, n );
		VUNITIZE( norms[0] );
		for( i=0 ; i<arc_segs; i++ )
		{
			j = i+1;
			if( j == arc_segs )
				j = 0;

			verts[0] = &(*outer_loop)[j];
			verts[1] = &(*outer_loop)[i];
			verts[2] = &v;

			if( (fu = nmg_cmface( s, verts, 3 ) ) == NULL )
			{
				bu_log( "tesselate_pipe_linear: failed to make outer face #%d or=%g, end_or=%g\n",
						i, or, end_or );
				continue;
			}
			if( i == 0 )
				nmg_vertex_gv( v, end_pt );

			if( i < arc_segs-1 )
			{
				VSUB2( norms[j], (*outer_loop)[j]->vg_p->coord, start_pt );
				VJOIN1( norms[j], norms[j], slope*or, n );
				VUNITIZE( norms[j] );
			}

			if( nmg_calc_face_g( fu ) )
			{
				bu_log( "tesselate_pipe_linear: nmg_calc_face_g failed\n" );
				nmg_kfu( fu );
			}
			else
			{
				struct loopuse *lu;
				struct edgeuse *eu;
				struct edgeuse *eu_opp_use;
				vect_t reverse_norm;

				NMG_CK_FACEUSE( fu );
				if( fu->orientation != OT_SAME )
					fu = fu->fumate_p;

				lu = BU_LIST_FIRST( loopuse, &fu->lu_hd );
				for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
				{
					eu_opp_use = BU_LIST_PNEXT_CIRC( edgeuse, &eu->eumate_p->l );
					if( eu->vu_p->v_p == (*outer_loop)[i] )
					{
						nmg_vertexuse_nv( eu->vu_p, norms[i] );
						VREVERSE( reverse_norm, norms[i] );
						nmg_vertexuse_nv( eu_opp_use->vu_p, reverse_norm );
					}
					else if( eu->vu_p->v_p == (*outer_loop)[j] )
					{
						nmg_vertexuse_nv( eu->vu_p, norms[j] );
						VREVERSE( reverse_norm, norms[j] );
						nmg_vertexuse_nv( eu_opp_use->vu_p, reverse_norm );
					}
					else if( eu->vu_p->v_p == v )
					{
						vect_t tmp_norm;
						VBLEND2( tmp_norm, 0.5, norms[i], 0.5, norms[j] );
						VUNITIZE( tmp_norm );
						nmg_vertexuse_nv( eu->vu_p, tmp_norm );
						VREVERSE( reverse_norm, tmp_norm );
						nmg_vertexuse_nv( eu_opp_use->vu_p, reverse_norm );
					}
					else
					{
						bu_log( "No vu_normal assigned at (%g %g %g)\n", V3ARGS( eu->vu_p->v_p->vg_p->coord ) );
						bu_log( "\ti=%d, j=%d, arc_segs=%d, fu = x%x\n" , i,j, arc_segs, fu );
					}
				}
			}
		}

		bu_free( (char *)(*outer_loop), "tesselate_pipe_linear: outer_loop" );
		outer_loop[0] = &v;
	}
	else if( or <= tol->dist && end_or > tol->dist )
	{
		point_t pt,pt_next;
		fastf_t x,y,xnew,ynew;
		struct vertex **verts[3];


		x = 1.0;
		y = 0.0;
		VCOMB2( norms[0], x, r1, y, r2 );
		VJOIN1( pt_next, end_pt, end_or, norms[0] );
		VJOIN1( norms[0], norms[0], slope, n );
		VUNITIZE( norms[0] );
		for( i=0 ; i<arc_segs; i++ )
		{
			j = i + 1;
			if( j == arc_segs )
				j = 0;

			VMOVE( pt, pt_next )
			xnew = x*cos_del - y*sin_del;
			ynew = x*sin_del + y*cos_del;
			x = xnew;
			y = ynew;
			if( i < j )
			{
				VCOMB2( norms[j], x, r1, y, r2 );
				VJOIN1( pt_next, end_pt, end_or, norms[j] );
				VJOIN1( norms[j], norms[j], slope, n );
				VUNITIZE( norms[j] );
			}

			verts[0] = &(*outer_loop)[0];
			verts[1] = &new_outer_loop[i];
			verts[2] = &new_outer_loop[j];

			if( (fu = nmg_cmface( s, verts, 3 ) ) == NULL )
			{
				bu_log( "tesselate_pipe_linear: failed to make outer face #%d or=%g, end_or=%g\n",
						i, or, end_or );
				continue;
			}
			if( !(*outer_loop)[0]->vg_p )
				nmg_vertex_gv( (*outer_loop)[0], start_pt );
			if( !new_outer_loop[i]->vg_p )
				nmg_vertex_gv( new_outer_loop[i], pt );
			if( !new_outer_loop[j]->vg_p )
				nmg_vertex_gv( new_outer_loop[j], pt_next );
			if( nmg_calc_face_g( fu ) )
			{
				bu_log( "tesselate_pipe_linear: nmg_calc_face_g failed\n" );
				nmg_kfu( fu );
			}
			else
			{
				struct loopuse *lu;
				struct edgeuse *eu;
				struct edgeuse *eu_opp_use;
				vect_t reverse_norm;

				NMG_CK_FACEUSE( fu );
				if( fu->orientation != OT_SAME )
					fu = fu->fumate_p;

				lu = BU_LIST_FIRST( loopuse, &fu->lu_hd );
				for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
				{
					eu_opp_use = BU_LIST_PNEXT_CIRC( edgeuse, &eu->eumate_p->l );
					if( eu->vu_p->v_p == new_outer_loop[i] )
					{
						nmg_vertexuse_nv( eu->vu_p, norms[i] );
						VREVERSE( reverse_norm, norms[i] );
						nmg_vertexuse_nv( eu_opp_use->vu_p, reverse_norm );
					}
					else if( eu->vu_p->v_p == new_outer_loop[j] )
					{
						nmg_vertexuse_nv( eu->vu_p, norms[j] );
						VREVERSE( reverse_norm, norms[j] );
						nmg_vertexuse_nv( eu_opp_use->vu_p, reverse_norm );
					}
					else if( eu->vu_p->v_p == (*outer_loop)[0] )
					{
						vect_t tmp_norm;
						VBLEND2( tmp_norm, 0.5, norms[i], 0.5, norms[j] );
						VUNITIZE( tmp_norm );
						nmg_vertexuse_nv( eu->vu_p, tmp_norm );
						VREVERSE( reverse_norm, tmp_norm );
						nmg_vertexuse_nv( eu_opp_use->vu_p, reverse_norm );
					}
					else
					{
						bu_log( "No vu_normal assigned at (%g %g %g)\n", V3ARGS( eu->vu_p->v_p->vg_p->coord ) );
						bu_log( "\ti=%d, j=%d, arc_segs=%d, fu = x%x\n" , i,j, arc_segs, fu );
					}
				}
			}
		}
		bu_free( (char *)(*outer_loop), "tesselate_pipe_linear: outer_loop" );
		*outer_loop = new_outer_loop;
	}

	slope = (ir - end_ir)/seg_len;

	if( ir > tol->dist && end_ir > tol->dist )
	{
		point_t pt;
		fastf_t x,y,xnew,ynew;
		struct faceuse *fu_prev=(struct faceuse *)NULL;
		struct vertex **verts[3];

		x = 1.0;
		y = 0.0;
		VCOMB2( norms[0], -x, r1, -y, r2 );
		VJOIN1( norms[0], norms[0], -slope, n );
		VUNITIZE( norms[0] );
		for( i=0 ; i<arc_segs ; i++ )
		{
			j = i+1;
			if( j == arc_segs )
				j = 0;

			VJOIN2( pt, end_pt, x*end_ir, r1, y*end_ir, r2 );
			xnew = x*cos_del - y*sin_del;
			ynew = x*sin_del + y*cos_del;
			x = xnew;
			y = ynew;
			if( i < arc_segs-1 )
			{
				VCOMB2( norms[j], -x, r1, -y, r2 );
				VJOIN1( norms[j], norms[j], -slope, n );
				VUNITIZE( norms[j] );
			}

			if( fu_prev )
			{
				nmg_vertex_gv( new_inner_loop[i], pt );
				if( nmg_calc_face_g( fu_prev ) )
				{
					bu_log( "tesselate_pipe_linear: nmg_calc_face_g failed\n" );
					nmg_kfu( fu_prev );
				}
				else
				{
					/* assign vertexuse normals */
					struct loopuse *lu;
					struct edgeuse *eu;

					NMG_CK_FACEUSE( fu_prev );

					if( fu_prev->orientation != OT_SAME )
						fu_prev = fu_prev->fumate_p;

					lu = BU_LIST_FIRST( loopuse, &fu_prev->lu_hd );

					for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
					{
						vect_t reverse_norm;
						struct edgeuse *eu_opp_use;

						eu_opp_use = BU_LIST_PNEXT_CIRC( edgeuse, &eu->eumate_p->l );
						if( eu->vu_p->v_p == new_inner_loop[i-1] )
						{
							nmg_vertexuse_nv( eu->vu_p, norms[i-1] );
							VREVERSE( reverse_norm, norms[i-1] );
							nmg_vertexuse_nv( eu_opp_use->vu_p, reverse_norm );
						}
						else if(  eu->vu_p->v_p == (*inner_loop)[i-1] )
						{
							nmg_vertexuse_nv( eu->vu_p, norms[i-1] );
							VREVERSE( reverse_norm, norms[i-1] );
							nmg_vertexuse_nv( eu_opp_use->vu_p, reverse_norm );
						}
						else if(  eu->vu_p->v_p == new_inner_loop[i] )
						{
							nmg_vertexuse_nv( eu->vu_p, norms[i] );
							VREVERSE( reverse_norm, norms[i] );
							nmg_vertexuse_nv( eu_opp_use->vu_p, reverse_norm );
						}
						else if(  eu->vu_p->v_p == (*inner_loop)[i] )
						{
							nmg_vertexuse_nv( eu->vu_p, norms[i] );
							VREVERSE( reverse_norm, norms[i] );
							nmg_vertexuse_nv( eu_opp_use->vu_p, reverse_norm );
						}
						else
						{
							bu_log( "No vu_normal assigned at (%g %g %g)\n", V3ARGS( eu->vu_p->v_p->vg_p->coord ) );
							bu_log( "\ti=%d, arc_segs=%d, fu_prev = x%x\n" , i, arc_segs, fu_prev );
						}
					}
				}
			}

			verts[0] = &(*inner_loop)[j];
			verts[1] = &new_inner_loop[i];
			verts[2] = &(*inner_loop)[i];

			if( (fu = nmg_cmface( s, verts, 3 ) ) == NULL )
			{
				bu_log( "tesselate_pipe_linear: failed to make inner face #%d ir=%g, end_ir=%g\n",
						i, ir, end_ir );
				continue;
			}
			if( !new_inner_loop[i]->vg_p )
				nmg_vertex_gv( new_inner_loop[i], pt );

			if( nmg_calc_face_g( fu ) )
			{
				bu_log( "tesselate_pipe_linear: nmg_calc_face_g failed\n" );
				nmg_kfu( fu );
			}
			else
			{
				/* assign vertexuse normals */
				struct loopuse *lu;
				struct edgeuse *eu;

				NMG_CK_FACEUSE( fu );

				if( fu->orientation != OT_SAME )
					fu = fu->fumate_p;

				lu = BU_LIST_FIRST( loopuse, &fu->lu_hd );

				for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
				{
					vect_t reverse_norm;
					struct edgeuse *eu_opp_use;

					eu_opp_use = BU_LIST_PNEXT_CIRC( edgeuse, &eu->eumate_p->l );
					if( eu->vu_p->v_p == (*inner_loop)[0] )
					{
						nmg_vertexuse_nv( eu->vu_p, norms[0] );
						VREVERSE( reverse_norm, norms[0] );
						nmg_vertexuse_nv( eu_opp_use->vu_p, reverse_norm );
					}
					else if(  eu->vu_p->v_p == new_inner_loop[i] )
					{
						nmg_vertexuse_nv( eu->vu_p, norms[i] );
						VREVERSE( reverse_norm, norms[i] );
						nmg_vertexuse_nv( eu_opp_use->vu_p, reverse_norm );
					}
					else if(  eu->vu_p->v_p == (*inner_loop)[i] )
					{
						nmg_vertexuse_nv( eu->vu_p, norms[i] );
						VREVERSE( reverse_norm, norms[i] );
						nmg_vertexuse_nv( eu_opp_use->vu_p, reverse_norm );
					}
					else if(  eu->vu_p->v_p == (*inner_loop)[j] )
					{
						nmg_vertexuse_nv( eu->vu_p, norms[j] );
						VREVERSE( reverse_norm, norms[j] );
						nmg_vertexuse_nv( eu_opp_use->vu_p, reverse_norm );
					}
					else
					{
						bu_log( "No vu_normal assigned at (%g %g %g)\n", V3ARGS( eu->vu_p->v_p->vg_p->coord ) );
						bu_log( "\ti=%d, arc_segs=%d, fu = x%x\n" , i, arc_segs, fu );
					}
				}
			}

			verts[2] = verts[0];
			verts[0] = verts[1];
			verts[1] = verts[2];
			if( i == arc_segs-1 )
				verts[2] = &new_inner_loop[0];
			else
				verts[2] = &new_inner_loop[j];
			if( (fu_prev = nmg_cmface( s, verts, 3 ) ) == NULL )
			{
				bu_log( "tesselate_pipe_linear: failed to make inner face #%d ir=%g, end_ir=%g\n",
						i, ir, end_ir );
				continue;
			}
			if( i == arc_segs-1 )
			{
				if( nmg_calc_face_g( fu_prev ) )
				{
					bu_log( "tesselate_pipe_linear: nmg_calc_face_g failed\n" );
					nmg_kfu( fu_prev );
				}
			}

		}
		bu_free( (char *)(*inner_loop), "tesselate_pipe_bend: inner_loop" );
		*inner_loop = new_inner_loop;
	}
	else if( ir > tol->dist && end_ir <= tol->dist )
	{
		struct vertex *v=(struct vertex *)NULL;

		VSUB2( norms[0], (*inner_loop)[0]->vg_p->coord, start_pt );
		VJOIN1( norms[0], norms[0], -slope*ir, n );
		VUNITIZE( norms[0] );
		VREVERSE( norms[0], norms[0] );
		for( i=0 ; i<arc_segs; i++ )
		{
			j = i+1;
			if( j == arc_segs )
				j = 0;

			verts[0] = &(*inner_loop)[i];
			verts[1] = &(*inner_loop)[j];
			verts[2] = &v;

			if( (fu = nmg_cmface( s, verts, 3 ) ) == NULL )
			{
				bu_log( "tesselate_pipe_linear: failed to make inner face #%d ir=%g, end_ir=%g\n",
						i, ir, end_ir );
				continue;
			}
			if( i == 0 )
				nmg_vertex_gv( v, end_pt );

			if( i < arc_segs-1 )
			{
				VSUB2( norms[j], (*inner_loop)[j]->vg_p->coord, start_pt );
				VJOIN1( norms[j], norms[j], -slope*ir, n );
				VUNITIZE( norms[j] );
				VREVERSE( norms[j], norms[j] );
			}

			if( nmg_calc_face_g( fu ) )
			{
				bu_log( "tesselate_pipe_linear: nmg_calc_face_g failed\n" );
				nmg_kfu( fu );
			}
			else
			{
				struct loopuse *lu;
				struct edgeuse *eu;
				struct edgeuse *eu_opp_use;
				vect_t reverse_norm;

				NMG_CK_FACEUSE( fu );
				if( fu->orientation != OT_SAME )
					fu = fu->fumate_p;

				lu = BU_LIST_FIRST( loopuse, &fu->lu_hd );
				for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
				{
					eu_opp_use = BU_LIST_PNEXT_CIRC( edgeuse, &eu->eumate_p->l );
					if( eu->vu_p->v_p == (*inner_loop)[i] )
					{
						nmg_vertexuse_nv( eu->vu_p, norms[i] );
						VREVERSE( reverse_norm, norms[i] );
						nmg_vertexuse_nv( eu_opp_use->vu_p, reverse_norm );
					}
					else if( eu->vu_p->v_p == (*inner_loop)[j] )
					{
						nmg_vertexuse_nv( eu->vu_p, norms[j] );
						VREVERSE( reverse_norm, norms[j] );
						nmg_vertexuse_nv( eu_opp_use->vu_p, reverse_norm );
					}
					else if( eu->vu_p->v_p == v )
					{
						vect_t tmp_norm;
						VBLEND2( tmp_norm, 0.5, norms[i], 0.5, norms[j] );
						VUNITIZE( tmp_norm );
						nmg_vertexuse_nv( eu->vu_p, tmp_norm );
						VREVERSE( reverse_norm, tmp_norm );
						nmg_vertexuse_nv( eu_opp_use->vu_p, reverse_norm );
					}
					else
					{
						bu_log( "No vu_normal assigned at (%g %g %g)\n", V3ARGS( eu->vu_p->v_p->vg_p->coord ) );
						bu_log( "\ti=%d, j=%d, arc_segs=%d, fu = x%x\n" , i,j, arc_segs, fu );
					}
				}
			}
		}

		bu_free( (char *)(*inner_loop), "tesselate_pipe_linear: inner_loop" );
		inner_loop[0] = &v;
	}
	else if( ir <= tol->dist && end_ir > tol->dist )
	{
		point_t pt,pt_next;
		fastf_t x,y,xnew,ynew;
		struct vertex **verts[3];

		x = 1.0;
		y = 0.0;
		VCOMB2( norms[0], -x, r1, -y, r2 );
		VJOIN1( pt_next, end_pt, -end_ir, norms[0] );
		VJOIN1( norms[0], norms[0], -slope, n );
		VUNITIZE( norms[0] );
		for( i=0 ; i<arc_segs; i++ )
		{
			j = i + 1;
			if( j == arc_segs )
				j = 0;

			VMOVE( pt, pt_next )
			xnew = x*cos_del - y*sin_del;
			ynew = x*sin_del + y*cos_del;
			x = xnew;
			y = ynew;
			if( i < j )
			{
				VCOMB2( norms[j], -x, r1, -y, r2 );
				VJOIN1( pt_next, end_pt, -end_ir, norms[j] );
				VJOIN1( norms[j], norms[j], -slope, n );
				VUNITIZE( norms[j] );
			}

			verts[0] = &new_inner_loop[j];
			verts[1] = &new_inner_loop[i];
			verts[2] = &(*inner_loop)[0];

			if( (fu = nmg_cmface( s, verts, 3 ) ) == NULL )
			{
				bu_log( "tesselate_pipe_linear: failed to make inner face #%d ir=%g, end_ir=%g\n",
						i, ir, end_ir );
				continue;
			}
			if( !(*inner_loop)[0]->vg_p )
				nmg_vertex_gv( (*inner_loop)[0], start_pt );
			if( !new_inner_loop[i]->vg_p )
				nmg_vertex_gv( new_inner_loop[i], pt );
			if( !new_inner_loop[j]->vg_p )
				nmg_vertex_gv( new_inner_loop[j], pt_next );
			if( nmg_calc_face_g( fu ) )
			{
				bu_log( "tesselate_pipe_linear: nmg_calc_face_g failed\n" );
				nmg_kfu( fu );
			}
			else
			{
				struct loopuse *lu;
				struct edgeuse *eu;
				struct edgeuse *eu_opp_use;
				vect_t reverse_norm;

				NMG_CK_FACEUSE( fu );
				if( fu->orientation != OT_SAME )
					fu = fu->fumate_p;

				lu = BU_LIST_FIRST( loopuse, &fu->lu_hd );
				for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
				{
					eu_opp_use = BU_LIST_PNEXT_CIRC( edgeuse, &eu->eumate_p->l );
					if( eu->vu_p->v_p == new_inner_loop[i] )
					{
						nmg_vertexuse_nv( eu->vu_p, norms[i] );
						VREVERSE( reverse_norm, norms[i] );
						nmg_vertexuse_nv( eu_opp_use->vu_p, reverse_norm );
					}
					else if( eu->vu_p->v_p == new_inner_loop[j] )
					{
						nmg_vertexuse_nv( eu->vu_p, norms[j] );
						VREVERSE( reverse_norm, norms[j] );
						nmg_vertexuse_nv( eu_opp_use->vu_p, reverse_norm );
					}
					else if( eu->vu_p->v_p == (*inner_loop)[0] )
					{
						vect_t tmp_norm;
						VBLEND2( tmp_norm, 0.5, norms[i], 0.5, norms[j] );
						VUNITIZE( tmp_norm );
						nmg_vertexuse_nv( eu->vu_p, tmp_norm );
						VREVERSE( reverse_norm, tmp_norm );
						nmg_vertexuse_nv( eu_opp_use->vu_p, reverse_norm );
					}
					else
					{
						bu_log( "No vu_normal assigned at (%g %g %g)\n", V3ARGS( eu->vu_p->v_p->vg_p->coord ) );
						bu_log( "\ti=%d, j=%d, arc_segs=%d, fu = x%x\n" , i,j, arc_segs, fu );
					}
				}
			}
		}
		bu_free( (char *)(*inner_loop), "tesselate_pipe_linear: inner_loop" );
		*inner_loop = new_inner_loop;
	}
	bu_free( (char *)norms, "tesselate_linear_pipe: norms" );
}

HIDDEN void
tesselate_pipe_bend(fastf_t *bend_start, fastf_t *bend_end, fastf_t *bend_center, fastf_t or, fastf_t ir, int arc_segs, double sin_del, double cos_del, struct vertex ***outer_loop, struct vertex ***inner_loop, fastf_t *start_r1, fastf_t *start_r2, struct shell *s, const struct bn_tol *tol, const struct rt_tess_tol *ttol)
{
	struct vertex **new_outer_loop;
	struct vertex **new_inner_loop;
	fastf_t bend_radius;
	fastf_t bend_angle;
	fastf_t x,y,xnew,ynew;
	fastf_t delta_angle;
	mat_t rot;
	vect_t b1;
	vect_t b2;
	vect_t r1, r2;
	vect_t r1_tmp,r2_tmp;
	vect_t bend_norm;
	vect_t to_start;
	vect_t to_end;
	vect_t norm;
	point_t origin;
	point_t center;
	point_t old_center;
	int bend_segs=1;	/* minimum number of edges along bend */
	int bend_seg;
	int tol_segs;
	int i,j;

	NMG_CK_SHELL( s );
	BN_CK_TOL( tol );
	RT_CK_TESS_TOL( ttol );

	VMOVE( r1, start_r1 );
	VMOVE( r2, start_r2 );

	/* Calculate vector b1, unit vector in direction from
	 * bend center to start point
	 */
	VSUB2( to_start, bend_start, bend_center );
	bend_radius = MAGNITUDE( to_start );
	VSCALE( b1, to_start, 1.0/bend_radius );

	/* bend_norm is normal to plane of bend */
	VSUB2( to_end, bend_end, bend_center );
	VCROSS( bend_norm, b1, to_end );
	VUNITIZE( bend_norm );

	/* b1, b2, and bend_norm form a RH coord, system */
	VCROSS( b2, bend_norm, b1 );

	bend_angle = atan2( VDOT( to_end, b2 ), VDOT( to_end, b1 ) );
	if( bend_angle < 0.0 )
		bend_angle += 2.0*bn_pi;

	/* calculate number of segments to use along bend */
	if( ttol->abs > 0.0 && ttol->abs < bend_radius+or )
	{
		tol_segs = ceil( bend_angle/(2.0*acos( 1.0 - ttol->abs/(bend_radius+or) ) ) );
		if( tol_segs > bend_segs )
			bend_segs = tol_segs;
	}
	if( ttol->rel > 0.0 )
	{
		tol_segs = ceil(bend_angle/(2.0*acos( 1.0 - ttol->rel ) ) );
		if( tol_segs > bend_segs )
			bend_segs = tol_segs;
	}
	if( ttol->norm > 0.0 )
	{
		tol_segs = ceil( bend_angle/(2.0*ttol->norm ) );
		if( tol_segs > bend_segs )
			bend_segs = tol_segs;
	}

	delta_angle = bend_angle/(fastf_t)(bend_segs);

	VSETALL( origin, 0.0 );
	bn_mat_arb_rot( rot, origin, bend_norm, delta_angle);

	VMOVE( old_center, bend_start )
	for( bend_seg=0; bend_seg<bend_segs ; bend_seg++ )
	{

		new_outer_loop = (struct vertex **)bu_calloc( arc_segs, sizeof( struct vertex *),
				"tesselate_pipe_bend(): new_outer_loop" );

		MAT4X3VEC( r1_tmp, rot, r1 )
		MAT4X3VEC( r2_tmp, rot, r2 )
		VMOVE( r1, r1_tmp )
		VMOVE( r2, r2_tmp )

		VSUB2( r1_tmp, old_center, bend_center )
		MAT4X3PNT( r2_tmp, rot, r1_tmp )
		VADD2( center, r2_tmp, bend_center )

		x = or;
		y = 0.0;
		for( i=0; i<arc_segs; i++ )
		{
			struct faceuse *fu;
			struct vertex **verts[3];
			point_t pt;

			j = i+1;
			if( j == arc_segs )
				j = 0;

			verts[0] = &(*outer_loop)[j];
			verts[1] = &(*outer_loop)[i];
			verts[2] = &new_outer_loop[i];

			if( (fu=nmg_cmface( s, verts, 3 )) == NULL )
			{
				bu_log( "tesselate_pipe_bend(): nmg_cmface failed\n" );
				rt_bomb( "tesselate_pipe_bend\n" );
			}
			VJOIN2( pt, center, x, r1, y, r2 );
			if( !new_outer_loop[i]->vg_p )
				nmg_vertex_gv( new_outer_loop[i], pt );
			if( nmg_calc_face_g( fu ) )
			{
				bu_log( "tesselate_pipe_bend: nmg_calc_face_g failed\n" );
				nmg_kfu( fu );
			}
			else
			{
				struct loopuse *lu;
				struct edgeuse *eu;

				NMG_CK_FACEUSE( fu );
				if( fu->orientation != OT_SAME )
					fu = fu->fumate_p;

				lu = BU_LIST_FIRST( loopuse, &fu->lu_hd );
				for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
				{
					struct edgeuse *eu_opp_use;

					NMG_CK_EDGEUSE( eu );
					eu_opp_use = BU_LIST_PNEXT_CIRC( edgeuse, &eu->eumate_p->l );

					if( eu->vu_p->v_p == (*outer_loop)[j] )
					{
						VSUB2( norm, (*outer_loop)[j]->vg_p->coord, old_center );
						VUNITIZE( norm );
						nmg_vertexuse_nv( eu->vu_p, norm );
						VREVERSE( norm, norm );
						nmg_vertexuse_nv( eu_opp_use->vu_p, norm );
					}
					else if( eu->vu_p->v_p == (*outer_loop)[i] )
					{
						VSUB2( norm, (*outer_loop)[i]->vg_p->coord, old_center );
						VUNITIZE( norm );
						nmg_vertexuse_nv( eu->vu_p, norm );
						VREVERSE( norm, norm );
						nmg_vertexuse_nv( eu_opp_use->vu_p, norm );
					}
					else if( eu->vu_p->v_p == new_outer_loop[i] )
					{
						VSUB2( norm, new_outer_loop[i]->vg_p->coord, center );
						VUNITIZE( norm );
						nmg_vertexuse_nv( eu->vu_p, norm );
						VREVERSE( norm, norm );
						nmg_vertexuse_nv( eu_opp_use->vu_p, norm );
					}
					else
					{
						bu_log( "No vu_normal assigned at (%g %g %g)\n", V3ARGS( eu->vu_p->v_p->vg_p->coord ) );
						bu_log( "\ti=%d, j=%d, arc_segs=%d, fu = x%x\n" , i,j, arc_segs, fu );
					}
				}
			}

			xnew = x*cos_del - y*sin_del;
			ynew = x*sin_del + y*cos_del;
			x = xnew;
			y = ynew;

			verts[1] = verts[2];
			verts[2] = &new_outer_loop[j];

			if( (fu=nmg_cmface( s, verts, 3 )) == NULL )
			{
				bu_log( "tesselate_pipe_bend(): nmg_cmface failed\n" );
				rt_bomb( "tesselate_pipe_bend\n" );
			}
			VJOIN2( pt, center, x, r1, y, r2 );
			if( !(*verts[2])->vg_p )
				nmg_vertex_gv( *verts[2], pt );
			if( nmg_calc_face_g( fu ) )
			{
				bu_log( "tesselate_pipe_bend: nmg_calc_face_g failed\n" );
				nmg_kfu( fu );
			}
			else
			{
				struct loopuse *lu;
				struct edgeuse *eu;

				NMG_CK_FACEUSE( fu );
				if( fu->orientation != OT_SAME )
					fu = fu->fumate_p;

				lu = BU_LIST_FIRST( loopuse, &fu->lu_hd );
				for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
				{
					struct edgeuse *eu_opp_use;

					NMG_CK_EDGEUSE( eu );
					eu_opp_use = BU_LIST_PNEXT_CIRC( edgeuse, &eu->eumate_p->l );

					if( eu->vu_p->v_p == (*outer_loop)[j] )
					{
						VSUB2( norm, (*outer_loop)[j]->vg_p->coord, old_center );
						VUNITIZE( norm );
						nmg_vertexuse_nv( eu->vu_p, norm );
						VREVERSE( norm, norm );
						nmg_vertexuse_nv( eu_opp_use->vu_p, norm );
					}
					else if( eu->vu_p->v_p == new_outer_loop[i] )
					{
						VSUB2( norm, new_outer_loop[i]->vg_p->coord, center );
						VUNITIZE( norm );
						nmg_vertexuse_nv( eu->vu_p, norm );
						VREVERSE( norm, norm );
						nmg_vertexuse_nv( eu_opp_use->vu_p, norm );
					}
					else if( eu->vu_p->v_p == new_outer_loop[j] )
					{
						VSUB2( norm, new_outer_loop[j]->vg_p->coord, center );
						VUNITIZE( norm );
						nmg_vertexuse_nv( eu->vu_p, norm );
						VREVERSE( norm, norm );
						nmg_vertexuse_nv( eu_opp_use->vu_p, norm );
					}
					else
					{
						bu_log( "No vu_normal assigned at (%g %g %g)\n", V3ARGS( eu->vu_p->v_p->vg_p->coord ) );
						bu_log( "\ti=%d, j=%d, arc_segs=%d, fu = x%x\n" , i,j, arc_segs, fu );
					}
				}
			}
		}

		bu_free( (char *)(*outer_loop), "tesselate_pipe_bend: outer_loop" );
		*outer_loop = new_outer_loop;
		VMOVE( old_center, center );
	}

	if( ir <= tol->dist )
	{
		VMOVE( start_r1, r1 )
		VMOVE( start_r2, r2 )
		return;
	}

	VMOVE( r1, start_r1 )
	VMOVE( r2, start_r2 )

	VMOVE( old_center, bend_start )
	for( bend_seg=0; bend_seg<bend_segs ; bend_seg++ )
	{

		new_inner_loop = (struct vertex **)bu_calloc( arc_segs, sizeof( struct vertex *),
				"tesselate_pipe_bend(): new_inner_loop" );

		MAT4X3VEC( r1_tmp, rot, r1 )
		MAT4X3VEC( r2_tmp, rot, r2 )
		VMOVE( r1, r1_tmp )
		VMOVE( r2, r2_tmp )

		VSUB2( r1_tmp, old_center, bend_center )
		MAT4X3PNT( r2_tmp, rot, r1_tmp )
		VADD2( center, r2_tmp, bend_center )

		x = ir;
		y = 0.0;
		for( i=0; i<arc_segs; i++ )
		{
			struct faceuse *fu;
			struct vertex **verts[3];
			point_t pt;

			j = i + 1;
			if( j == arc_segs )
				j = 0;

			verts[0] = &(*inner_loop)[i];
			verts[1] = &(*inner_loop)[j];
			verts[2] = &new_inner_loop[i];

			if( (fu=nmg_cmface( s, verts, 3 )) == NULL )
			{
				bu_log( "tesselate_pipe_bend(): nmg_cmface failed\n" );
				rt_bomb( "tesselate_pipe_bend\n" );
			}
			VJOIN2( pt, center, x, r1, y, r2 );
			if( !new_inner_loop[i]->vg_p )
				nmg_vertex_gv( new_inner_loop[i], pt );
			if( nmg_calc_face_g( fu ) )
			{
				bu_log( "tesselate_pipe_bend: nmg_calc_face_g failed\n" );
				nmg_kfu( fu );
			}
			else
			{
				struct loopuse *lu;
				struct edgeuse *eu;

				NMG_CK_FACEUSE( fu );
				if( fu->orientation != OT_SAME )
					fu = fu->fumate_p;

				lu = BU_LIST_FIRST( loopuse, &fu->lu_hd );
				for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
				{
					struct edgeuse *eu_opp_use;

					NMG_CK_EDGEUSE( eu );
					eu_opp_use = BU_LIST_PNEXT_CIRC( edgeuse, &eu->eumate_p->l );

					if( eu->vu_p->v_p == (*inner_loop)[j] )
					{
						VSUB2( norm, old_center, (*inner_loop)[j]->vg_p->coord );
						VUNITIZE( norm );
						nmg_vertexuse_nv( eu->vu_p, norm );
						VREVERSE( norm, norm );
						nmg_vertexuse_nv( eu_opp_use->vu_p, norm );
					}
					else if( eu->vu_p->v_p == (*inner_loop)[i] )
					{
						VSUB2( norm, old_center, (*inner_loop)[i]->vg_p->coord );
						VUNITIZE( norm );
						nmg_vertexuse_nv( eu->vu_p, norm );
						VREVERSE( norm, norm );
						nmg_vertexuse_nv( eu_opp_use->vu_p, norm );
					}
					else if( eu->vu_p->v_p == new_inner_loop[i] )
					{
						VSUB2( norm, center, new_inner_loop[i]->vg_p->coord );
						VUNITIZE( norm );
						nmg_vertexuse_nv( eu->vu_p, norm );
						VREVERSE( norm, norm );
						nmg_vertexuse_nv( eu_opp_use->vu_p, norm );
					}
					else
					{
						bu_log( "No vu_normal assigned at (%g %g %g)\n", V3ARGS( eu->vu_p->v_p->vg_p->coord ) );
						bu_log( "\ti=%d, j=%d, arc_segs=%d, fu = x%x\n" , i,j, arc_segs, fu );
					}
				}
			}

			xnew = x*cos_del - y*sin_del;
			ynew = x*sin_del + y*cos_del;
			x = xnew;
			y = ynew;

			verts[0] = verts[2];
			verts[2] = &new_inner_loop[j];

			if( (fu=nmg_cmface( s, verts, 3 )) == NULL )
			{
				bu_log( "tesselate_pipe_bend(): nmg_cmface failed\n" );
				rt_bomb( "tesselate_pipe_bend\n" );
			}
			VJOIN2( pt, center, x, r1, y, r2 );
			if( !(*verts[2])->vg_p )
				nmg_vertex_gv( *verts[2], pt );
			if( nmg_calc_face_g( fu ) )
			{
				bu_log( "tesselate_pipe_bend: nmg_calc_face_g failed\n" );
				nmg_kfu( fu );
			}
			else
			{
				struct loopuse *lu;
				struct edgeuse *eu;

				NMG_CK_FACEUSE( fu );
				if( fu->orientation != OT_SAME )
					fu = fu->fumate_p;

				lu = BU_LIST_FIRST( loopuse, &fu->lu_hd );
				for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
				{
					struct edgeuse *eu_opp_use;

					NMG_CK_EDGEUSE( eu );
					eu_opp_use = BU_LIST_PNEXT_CIRC( edgeuse, &eu->eumate_p->l );

					if( eu->vu_p->v_p == (*inner_loop)[j] )
					{
						VSUB2( norm, old_center, (*inner_loop)[j]->vg_p->coord );
						VUNITIZE( norm );
						nmg_vertexuse_nv( eu->vu_p, norm );
						VREVERSE( norm, norm );
						nmg_vertexuse_nv( eu_opp_use->vu_p, norm );
					}
					else if( eu->vu_p->v_p == new_inner_loop[i] )
					{
						VSUB2( norm, center, new_inner_loop[i]->vg_p->coord );
						VUNITIZE( norm );
						nmg_vertexuse_nv( eu->vu_p, norm );
						VREVERSE( norm, norm );
						nmg_vertexuse_nv( eu_opp_use->vu_p, norm );
					}
					else if( eu->vu_p->v_p == new_inner_loop[j] )
					{
						VSUB2( norm, center, new_inner_loop[j]->vg_p->coord );
						VUNITIZE( norm );
						nmg_vertexuse_nv( eu->vu_p, norm );
						VREVERSE( norm, norm );
						nmg_vertexuse_nv( eu_opp_use->vu_p, norm );
					}
					else
					{
						bu_log( "No vu_normal assigned at (%g %g %g)\n", V3ARGS( eu->vu_p->v_p->vg_p->coord ) );
						bu_log( "\ti=%d, j=%d, arc_segs=%d, fu = x%x\n" , i,j, arc_segs, fu );
					}
				}
			}
		}
		bu_free( (char *)(*inner_loop), "tesselate_pipe_bend: inner_loop" );
		*inner_loop = new_inner_loop;
		VMOVE( old_center, center );
	}
	VMOVE( start_r1, r1 )
	VMOVE( start_r2, r2 )
}

HIDDEN void
tesselate_pipe_end(struct wdb_pipept *pipe, int arc_segs, double sin_del, double cos_del, struct vertex ***outer_loop, struct vertex ***inner_loop, struct shell *s, const struct bn_tol *tol)
{
	struct wdb_pipept *prev;
	struct faceuse *fu;
	struct loopuse *lu;

	NMG_CK_SHELL( s );
	BN_CK_TOL( tol );

	if( pipe->pp_od <= tol->dist )
		return;

	if( NEAR_ZERO( pipe->pp_od - pipe->pp_id, tol->dist) )
		return;

	if( (fu = nmg_cface( s, *outer_loop, arc_segs )) == NULL )
	{
		bu_log( "tesselate_pipe_end(): nmg_cface failed\n" );
		return;
	}
	fu = fu->fumate_p;
	if( nmg_calc_face_g( fu ) )
	{
		bu_log( "tesselate_pipe_end: nmg_calc_face_g failed\n" );
		nmg_kfu( fu );
		return;
	}

	prev = BU_LIST_PREV( wdb_pipept, &pipe->l );
	
	if( pipe->pp_id > tol->dist )
	{
		struct vertex **verts;
		int i;

		verts = (struct vertex **)bu_calloc( arc_segs, sizeof( struct vertex *),
			"tesselate_pipe_end: verts" );
		for( i=0 ; i<arc_segs; i++ )
			verts[i] = (*inner_loop)[i];

		fu = nmg_add_loop_to_face( s, fu, verts, arc_segs, OT_OPPOSITE );

		bu_free( (char *)verts, "tesselate_pipe_end: verts" );
	}

	else if( prev->pp_id > tol->dist )
	{
		struct vertexuse *vu;

		/* make a loop of a single vertex in this face */
		lu = nmg_mlv( &fu->l.magic, (struct vertex *)NULL, OT_OPPOSITE );
		vu = BU_LIST_FIRST( vertexuse, &lu->down_hd );

		nmg_vertex_gv( vu->v_p, pipe->pp_coord );
	}

	for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
	{
		struct edgeuse *eu;

		NMG_CK_LOOPUSE( lu );

		if( BU_LIST_FIRST_MAGIC(&lu->down_hd) != NMG_EDGEUSE_MAGIC )
			continue;

		for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
		{
			NMG_CK_EDGEUSE( eu );
			eu->e_p->is_real = 1;
		}
	}
}

/*
 *			R T _ P I P E _ T E S S
 *
 *	XXXX Still needs vertexuse normals!
 */
int
rt_pipe_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
	struct wdb_pipept	*pp1;
	struct wdb_pipept	*pp2;
	struct wdb_pipept	*pp3;
	point_t			curr_pt;
	struct shell *s;
	struct rt_pipe_internal *pip;
	int arc_segs=6;			/* minimum number of segments for a circle */
	int tol_segs;
	fastf_t max_diam=0.0;
	fastf_t pipe_size;
	fastf_t curr_od,curr_id;
	double delta_angle;
	double sin_del;
	double cos_del;
	point_t min_pt;
	point_t max_pt;
	vect_t min_to_max;
	vect_t r1, r2;
	struct vertex **outer_loop;
	struct vertex **inner_loop;

	RT_CK_DB_INTERNAL(ip);
	pip = (struct rt_pipe_internal *)ip->idb_ptr;
	RT_PIPE_CK_MAGIC( pip );

	BN_CK_TOL( tol );
	RT_CK_TESS_TOL( ttol );
	NMG_CK_MODEL( m );

	*r = (struct nmgregion *)NULL;

	if( BU_LIST_IS_EMPTY( &pip->pipe_segs_head ) )
		return( 0 );	/* nothing to tesselate */

	pp1 = BU_LIST_FIRST( wdb_pipept, &pip->pipe_segs_head );

	VMOVE( min_pt, pp1->pp_coord );
	VMOVE( max_pt, pp1->pp_coord );

	/* find max diameter */
	for( BU_LIST_FOR( pp1, wdb_pipept, &pip->pipe_segs_head ) )
	{
		if( pp1->pp_od > 0.0 && pp1->pp_od > max_diam )
			max_diam = pp1->pp_od;

		VMINMAX( min_pt, max_pt, pp1->pp_coord );
	}

	if( max_diam <= tol->dist )
		return( 0 );	/* nothing to tesselate */

	/* calculate pipe size for relative tolerance */
	VSUB2( min_to_max, max_pt, min_pt );
	pipe_size = MAGNITUDE( min_to_max );

	/* calculate number of segments for circles */
	if( ttol->abs > 0.0 && ttol->abs * 2.0 < max_diam )
	{
		tol_segs = ceil( bn_pi/acos( 1.0 - 2.0 * ttol->abs/max_diam) );
		if( tol_segs > arc_segs )
			arc_segs = tol_segs;
	}
	if( ttol->rel > 0.0 && 2.0 * ttol->rel * pipe_size < max_diam )
	{
		tol_segs = ceil( bn_pi/acos( 1.0 - 2.0 * ttol->rel*pipe_size/max_diam) );
		if( tol_segs > arc_segs )
			arc_segs = tol_segs;
	}
	if( ttol->norm > 0.0 )
	{
		tol_segs = ceil( bn_pi/ttol->norm );
		if( tol_segs > arc_segs )
			arc_segs = tol_segs;
	}

	*r = nmg_mrsv( m );
	s = BU_LIST_FIRST(shell, &(*r)->s_hd);

	outer_loop = (struct vertex **)bu_calloc( arc_segs, sizeof( struct vertex *),
			"rt_pipe_tess: outer_loop" );
	inner_loop = (struct vertex **)bu_calloc( arc_segs, sizeof( struct vertex *),
			"rt_pipe_tess: inner_loop" );
	delta_angle = 2.0 * bn_pi / (double)arc_segs;
	sin_del = sin( delta_angle );
	cos_del = cos( delta_angle );

	pp1 = BU_LIST_FIRST( wdb_pipept, &(pip->pipe_segs_head) );
	tesselate_pipe_start( pp1, arc_segs, sin_del, cos_del,
		&outer_loop, &inner_loop, r1, r2, s, tol );

	pp2 = BU_LIST_NEXT( wdb_pipept, &pp1->l );
	if( BU_LIST_IS_HEAD( &pp2->l, &(pip->pipe_segs_head) ) )
		return( 0 );
	pp3 = BU_LIST_NEXT( wdb_pipept, &pp2->l );
	if( BU_LIST_IS_HEAD( &pp3->l ,  &(pip->pipe_segs_head) ) )
		pp3 = (struct wdb_pipept *)NULL;

	VMOVE( curr_pt, pp1->pp_coord );
	curr_od = pp1->pp_od;
	curr_id = pp1->pp_id;
	while( 1 )
	{
		vect_t n1,n2;
		vect_t norm;
		vect_t v1;
		fastf_t angle;
		fastf_t dist_to_bend;
		point_t bend_start, bend_end, bend_center;

		VSUB2( n1, curr_pt, pp2->pp_coord );
		if( VNEAR_ZERO( n1, SQRT_SMALL_FASTF ) )
		{
			/* duplicate point, skip to next point */
			goto next_pt;
		}

		if( !pp3 )
		{
			/* last segment */
			tesselate_pipe_linear(curr_pt, curr_od/2.0, curr_id/2.0,
				pp2->pp_coord, pp2->pp_od/2.0, pp2->pp_id/2.0,
				arc_segs, sin_del, cos_del, &outer_loop, &inner_loop, r1, r2, s, tol );
			break;
		}

		VSUB2( n2, pp3->pp_coord, pp2->pp_coord );
		VCROSS( norm, n1, n2 );
		if( VNEAR_ZERO( norm, SQRT_SMALL_FASTF ) )
		{
			/* points are colinear, treat as a linear segment */
			tesselate_pipe_linear(curr_pt, curr_od/2.0, curr_id/2.0,
				pp2->pp_coord, pp2->pp_od/2.0, pp2->pp_id/2.0,
				arc_segs, sin_del, cos_del, &outer_loop, &inner_loop, r1, r2, s, tol );

			VMOVE( curr_pt, pp2->pp_coord );
			curr_id = pp2->pp_id;
			curr_od = pp2->pp_od;
			goto next_pt;
		}

		VUNITIZE( n1 );
		VUNITIZE( n2 );
		VUNITIZE( norm );

		/* linear section */
		angle = bn_pi - acos( VDOT( n1, n2 ) );
		dist_to_bend = pp2->pp_bendradius * tan( angle/2.0 );
		VJOIN1( bend_start, pp2->pp_coord, dist_to_bend, n1 );
		tesselate_pipe_linear( curr_pt, curr_od/2.0, curr_id/2.0,
				bend_start, pp2->pp_od/2.0, pp2->pp_id/2.0,
				arc_segs, sin_del, cos_del, &outer_loop, &inner_loop, r1, r2, s, tol );

		/* and bend section */
		VJOIN1( bend_end, pp2->pp_coord, dist_to_bend, n2 );
		VCROSS( v1, n1, norm );
		VJOIN1( bend_center, bend_start, -pp2->pp_bendradius, v1 );
		tesselate_pipe_bend( bend_start, bend_end, bend_center, curr_od/2.0, curr_id/2.0,
			arc_segs, sin_del, cos_del, &outer_loop, &inner_loop,
			r1, r2, s, tol, ttol );

		VMOVE( curr_pt, bend_end );
		curr_id = pp2->pp_id;
		curr_od = pp2->pp_od;
next_pt:
		pp1 = pp2;
		pp2 = pp3;
		pp3 = BU_LIST_NEXT( wdb_pipept, &pp3->l );
		if( BU_LIST_IS_HEAD( &pp3->l ,  &(pip->pipe_segs_head) ) )
			pp3 = (struct wdb_pipept *)NULL;
	}

	tesselate_pipe_end( pp2, arc_segs, sin_del, cos_del, &outer_loop, &inner_loop, s, tol );

	bu_free( (char *)outer_loop, "rt_pipe_tess: outer_loop" );
	bu_free( (char *)inner_loop, "rt_pipe_tess: inner_loop" );

	nmg_rebound( m, tol );

	return( 0 );
}

/*
 *			R T _ P I P E _ I M P O R T
 */
int
rt_pipe_import(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
{
	register struct exported_pipept *exp;
	register struct wdb_pipept	*ptp;
	struct wdb_pipept		tmp;
	struct rt_pipe_internal		*pipe;
	union record			*rp;

	BU_CK_EXTERNAL( ep );
	rp = (union record *)ep->ext_buf;
	/* Check record type */
	if( rp->u_id != DBID_PIPE )  {
		bu_log("rt_pipe_import: defective record\n");
		return(-1);
	}

	RT_CK_DB_INTERNAL( ip );
	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_PIPE;
	ip->idb_meth = &rt_functab[ID_PIPE];
	ip->idb_ptr = bu_malloc( sizeof(struct rt_pipe_internal), "rt_pipe_internal");
	pipe = (struct rt_pipe_internal *)ip->idb_ptr;
	pipe->pipe_magic = RT_PIPE_INTERNAL_MAGIC;
	pipe->pipe_count = bu_glong( rp->pwr.pwr_pt_count);

	/*
	 *  Walk the array of segments in reverse order,
	 *  allocating a linked list of segments in internal format,
	 *  using exactly the same structures as libwdb.
	 */
	BU_LIST_INIT( &pipe->pipe_segs_head );
	for( exp = &rp->pwr.pwr_data[pipe->pipe_count-1]; exp >= &rp->pwr.pwr_data[0]; exp-- )  {
		ntohd( (unsigned char *)&tmp.pp_id, exp->epp_id, 1 );
		ntohd( (unsigned char *)&tmp.pp_od, exp->epp_od, 1 );
		ntohd( (unsigned char *)&tmp.pp_bendradius, exp->epp_bendradius, 1 );
		ntohd( (unsigned char *)tmp.pp_coord, exp->epp_coord, 3 );

		/* Apply modeling transformations */
		BU_GETSTRUCT( ptp, wdb_pipept );
		ptp->l.magic = WDB_PIPESEG_MAGIC;
		MAT4X3PNT( ptp->pp_coord, mat, tmp.pp_coord );
		ptp->pp_id = tmp.pp_id / mat[15];
		ptp->pp_od = tmp.pp_od / mat[15];
		ptp->pp_bendradius = tmp.pp_bendradius / mat[15];
		BU_LIST_APPEND( &pipe->pipe_segs_head, &ptp->l );
	}

	return(0);			/* OK */
}

/*
 *			R T _ P I P E _ E X P O R T
 */
int
rt_pipe_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
{
	struct rt_pipe_internal	*pip;
	struct bu_list		*headp;
	register struct exported_pipept *epp;
	register struct wdb_pipept	*ppt;
	struct wdb_pipept		tmp;
	int		count;
	int		ngran;
	int		nbytes;
	union record	*rec;

	RT_CK_DB_INTERNAL(ip);
	if( ip->idb_type != ID_PIPE )  return(-1);
	pip = (struct rt_pipe_internal *)ip->idb_ptr;
	RT_PIPE_CK_MAGIC(pip);

	headp = &pip->pipe_segs_head;

	/* Count number of points */
	count = 0;
	for( BU_LIST_FOR( ppt, wdb_pipept, headp ) )
		count++;

	if( count < 1 )
		return(-4);			/* Not enough for 1 pipe! */

	/* Determine how many whole granules will be required */
	nbytes = sizeof(struct pipewire_rec) +
		(count-1) * sizeof(struct exported_pipept);
	ngran = (nbytes + sizeof(union record) - 1) / sizeof(union record);

	BU_CK_EXTERNAL(ep);
	ep->ext_nbytes = ngran * sizeof(union record);
	ep->ext_buf = (genptr_t)bu_calloc( 1, ep->ext_nbytes, "pipe external");
	rec = (union record *)ep->ext_buf;

	rec->pwr.pwr_id = DBID_PIPE;
	(void)bu_plong( rec->pwr.pwr_count, ngran-1 );	/* # EXTRA grans */
	(void)bu_plong( rec->pwr.pwr_pt_count, count );

	/* Convert the pipe segments to external form */
	epp = &rec->pwr.pwr_data[0];
	for( BU_LIST_FOR( ppt, wdb_pipept, headp ), epp++ )  {
		/* Convert from user units to mm */
		VSCALE( tmp.pp_coord, ppt->pp_coord, local2mm );
		tmp.pp_id = ppt->pp_id * local2mm;
		tmp.pp_od = ppt->pp_od * local2mm;
		tmp.pp_bendradius = ppt->pp_bendradius * local2mm;
		htond( epp->epp_coord, (unsigned char *)tmp.pp_coord, 3 );
		htond( epp->epp_id, (unsigned char *)&tmp.pp_id, 1 );
		htond( epp->epp_od, (unsigned char *)&tmp.pp_od, 1 );
		htond( epp->epp_bendradius, (unsigned char *)&tmp.pp_bendradius, 1 );
	}

	return(0);
}

/*
 *			R T _ P I P E _ I M P O R T 5
 */
int
rt_pipe_import5(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
{
	register struct wdb_pipept	*ptp;
	struct rt_pipe_internal		*pipe;
	fastf_t				*vec;
	int				total_count;
	int				double_count;
	int				byte_count;
	unsigned long			pipe_count;
	int				i;

	BU_CK_EXTERNAL( ep );

	pipe_count = bu_glong((unsigned char *)ep->ext_buf);
	double_count = pipe_count * 6;
	byte_count = double_count * SIZEOF_NETWORK_DOUBLE;
	total_count = 4 + byte_count;
	BU_ASSERT_LONG( ep->ext_nbytes, ==, total_count);

	RT_CK_DB_INTERNAL( ip );
	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_PIPE;
	ip->idb_meth = &rt_functab[ID_PIPE];
	ip->idb_ptr = bu_malloc( sizeof(struct rt_pipe_internal), "rt_pipe_internal");

	pipe = (struct rt_pipe_internal *)ip->idb_ptr;
	pipe->pipe_magic = RT_PIPE_INTERNAL_MAGIC;
	pipe->pipe_count = pipe_count;

	vec = (fastf_t *)bu_malloc(byte_count, "rt_pipe_import5: vec");
	/* Convert from database (network) to internal (host) format */
	ntohd((unsigned char *)vec, (unsigned char *)ep->ext_buf + 4, double_count);

	/*
	 *  Walk the array of segments in reverse order,
	 *  allocating a linked list of segments in internal format,
	 *  using exactly the same structures as libwdb.
	 */
	BU_LIST_INIT( &pipe->pipe_segs_head );
	for (i = 0; i < double_count; i += 6) {
		/* Apply modeling transformations */
		BU_GETSTRUCT( ptp, wdb_pipept );
		ptp->l.magic = WDB_PIPESEG_MAGIC;
		MAT4X3PNT( ptp->pp_coord, mat, &vec[i] );
		ptp->pp_id =		vec[i+3] / mat[15];
		ptp->pp_od =		vec[i+4] / mat[15];
		ptp->pp_bendradius =	vec[i+5] / mat[15];
		BU_LIST_INSERT( &pipe->pipe_segs_head, &ptp->l );
	}

	bu_free((genptr_t)vec, "rt_pipe_import5: vec");
	return(0);			/* OK */
}

/*
 *			R T _ P I P E _ E X P O R T 5
 */
int
rt_pipe_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
{
	struct rt_pipe_internal	*pip;
	struct bu_list		*headp;
	register struct wdb_pipept	*ppt;
	fastf_t				*vec;
	int				total_count;
	int				double_count;
	int				byte_count;
	unsigned long			pipe_count;
	int				i = 0;

	RT_CK_DB_INTERNAL(ip);
	if( ip->idb_type != ID_PIPE )  return(-1);
	pip = (struct rt_pipe_internal *)ip->idb_ptr;
	RT_PIPE_CK_MAGIC(pip);

	headp = &pip->pipe_segs_head;

	/* Count number of points */
	pipe_count = 0;
	for( BU_LIST_FOR( ppt, wdb_pipept, headp ) )
		pipe_count++;

	if( pipe_count <= 1 )
		return(-4);			/* Not enough for 1 pipe! */

	double_count = pipe_count * 6;
	byte_count = double_count * SIZEOF_NETWORK_DOUBLE;
	total_count = 4 + byte_count;
	vec = (fastf_t *)bu_malloc(byte_count, "rt_pipe_export5: vec");

	BU_CK_EXTERNAL(ep);
	ep->ext_nbytes = total_count;
	ep->ext_buf = (genptr_t)bu_malloc(ep->ext_nbytes, "pipe external");

	(void)bu_plong((unsigned char *)ep->ext_buf, pipe_count);

	/* Convert the pipe segments to external form */
	for( BU_LIST_FOR( ppt, wdb_pipept, headp ), i += 6  )  {
		/* Convert from user units to mm */
		VSCALE( &vec[i], ppt->pp_coord, local2mm );
		vec[i+3] = ppt->pp_id * local2mm;
		vec[i+4] = ppt->pp_od * local2mm;
		vec[i+5] = ppt->pp_bendradius * local2mm;
	}

	/* Convert from internal (host) to database (network) format */
	htond((unsigned char *)ep->ext_buf + 4, (unsigned char *)vec, double_count);

	bu_free((genptr_t)vec, "rt_pipe_export5: vec");
	return(0);
}

/*
 *			R T _ P I P E _ D E S C R I B E
 *
 *  Make human-readable formatted presentation of this solid.
 *  First line describes type of solid.
 *  Additional lines are indented one tab, and give parameter values.
 */
int
rt_pipe_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
{
	register struct rt_pipe_internal	*pip;
	register struct wdb_pipept	*ptp;
	char	buf[256];
	int	segno = 0;

	RT_CK_DB_INTERNAL(ip);
	pip = (struct rt_pipe_internal *)ip->idb_ptr;
	RT_PIPE_CK_MAGIC(pip);

	sprintf(buf, "pipe with %d points\n", pip->pipe_count );
	bu_vls_strcat( str, buf );

	if( !verbose )  return(0);

#if 1
	/* Too much for the MGED Display!!!! */
	for( BU_LIST_FOR( ptp, wdb_pipept, &pip->pipe_segs_head ) )  {
		sprintf(buf, "\t%d ", segno++ );
		bu_vls_strcat( str, buf );
		sprintf( buf, "\tbend radius = %g", ptp->pp_bendradius * mm2local );
		bu_vls_strcat( str, buf );
		sprintf(buf, "  od=%g", ptp->pp_od * mm2local );
		bu_vls_strcat( str, buf );
		if( ptp->pp_id > 0 )  {
			sprintf(buf, ", id  = %g", ptp->pp_id * mm2local );
			bu_vls_strcat( str, buf );
		}
		bu_vls_strcat( str, "\n" );

		sprintf(buf, "\t  at=(%g, %g, %g)\n",
			ptp->pp_coord[X] * mm2local,
			ptp->pp_coord[Y] * mm2local,
			ptp->pp_coord[Z] * mm2local );
		bu_vls_strcat( str, buf );

	}
#endif
	return(0);
}

/*
 *			R T _ P I P E _ I F R E E
 *
 *  Free the storage associated with the rt_db_internal version of this solid.
 */
void
rt_pipe_ifree(struct rt_db_internal *ip)
{
	register struct rt_pipe_internal	*pipe;
	register struct wdb_pipept	*ptp;

	RT_CK_DB_INTERNAL(ip);
	pipe = (struct rt_pipe_internal*)ip->idb_ptr;
	RT_PIPE_CK_MAGIC(pipe);

	while( BU_LIST_WHILE( ptp, wdb_pipept, &pipe->pipe_segs_head ) )  {
		BU_LIST_DEQUEUE( &(ptp->l) );
		bu_free( (char *)ptp, "wdb_pipept" );
	}
	bu_free( ip->idb_ptr, "pipe ifree" );
	ip->idb_ptr = GENPTR_NULL;
}

/*
 *			R T _ P I P E _ C K
 *
 *  Check pipe solid
 *	Bend radius must be at least as large as the outer radius
 *	All bends must have constant diameters
 *	No consecutive LINEAR sections without BENDS unless the
 *		LINEAR sections are collinear.
 */
int
rt_pipe_ck( const struct bu_list *headp )
{
	int error_count=0;
	struct wdb_pipept *cur,*prev,*next;
	fastf_t old_bend_dist=0.0;
	fastf_t new_bend_dist;
	fastf_t v2_len=0.0;

	prev = BU_LIST_FIRST( wdb_pipept, headp );
	if( prev->pp_bendradius < prev->pp_od * 0.5 )
	{
		bu_log( "Bend radius (%gmm) is less than outer radius at ( %g %g %g )\n",
			prev->pp_bendradius, V3ARGS( prev->pp_coord ) );
		error_count++;
	}
	cur = BU_LIST_NEXT( wdb_pipept, &prev->l );
	next = BU_LIST_NEXT( wdb_pipept, &cur->l );
	while( BU_LIST_NOT_HEAD( &next->l, headp ) )
	{
		vect_t v1, v2, norm;
		fastf_t v1_len;
		fastf_t angle;

		if( cur->pp_bendradius < cur->pp_od * 0.5 )
		{
			bu_log( "Bend radius (%gmm) is less than outer radius at ( %g %g %g )\n",
				cur->pp_bendradius, V3ARGS( cur->pp_coord ) );
			error_count++;
		}

		VSUB2( v1, prev->pp_coord, cur->pp_coord );
		v1_len = MAGNITUDE( v1 );
		if( v1_len > VDIVIDE_TOL )
		{
			fastf_t inv_len;

			inv_len = 1.0/v1_len;
			VSCALE( v1, v1, inv_len );
		}
		else
			VSETALL( v1, 0.0 )

		VSUB2( v2, next->pp_coord, cur->pp_coord );
		v2_len = MAGNITUDE( v2 );
		if( v2_len > VDIVIDE_TOL )
		{
			fastf_t inv_len;

			inv_len = 1.0/v2_len;
			VSCALE( v2, v2, inv_len );
		}
		else
			VSETALL( v2, 0.0 )

		VCROSS( norm, v1, v2 );
		if( VNEAR_ZERO( norm, SQRT_SMALL_FASTF) )
		{
			new_bend_dist = 0.0;
			goto next_pt;
		}

		angle = bn_pi - acos( VDOT( v1, v2 ) );
		new_bend_dist = cur->pp_bendradius * tan( angle/2.0 );

		if( new_bend_dist + old_bend_dist > v1_len )
		{
			error_count++;
			bu_log( "Bend radii (%gmm) at ( %g %g %g ) and (%gmm) at ( %g %g %g ) are too large\n",
				prev->pp_bendradius, V3ARGS( prev->pp_coord),
				cur->pp_bendradius,V3ARGS( cur->pp_coord ) );
			bu_log( "for pipe segment between ( %g %g %g ) and ( %g %g %g )\n",
				V3ARGS( prev->pp_coord ), V3ARGS( cur->pp_coord ) );
		}
next_pt:
		old_bend_dist = new_bend_dist;
		prev = cur;
		cur = next;
		next = BU_LIST_NEXT( wdb_pipept, &cur->l );
	}

	if( old_bend_dist > v2_len )
	{
		error_count++;
		bu_log( "last segment ( %g %g %g ) to ( %g %g %g ) is too short to allow\n",
			V3ARGS( prev->pp_coord ), V3ARGS( cur->pp_coord ) );
		bu_log( "bend radius of %gmm\n", prev->pp_bendradius );
	}
	return( error_count );
}


/*
 *			R T _ P I P E _ T C L _ G E T
 *
 *  Examples -
 *	db get name V#			get coordinates for vertex #
 *	db get name I#			get inner radius for vertex #
 *	db get name O#			get outer radius for vertex #
 *	db get name R#			get bendradius for vertex #
 *	db get name P#			get all data for vertex #
 *	db get name N			get number of vertices
 */

int
rt_pipe_tclget(Tcl_Interp *interp, const struct rt_db_internal *intern, const char *attr)
{
	register struct rt_pipe_internal *pipe=(struct rt_pipe_internal *)intern->idb_ptr;
	struct wdb_pipept *ptp;
	Tcl_DString	ds;
	struct bu_vls	vls;
	int		status=TCL_OK;
	int		seg_no;
	int		num_segs=0;

	RT_PIPE_CK_MAGIC( pipe );

	Tcl_DStringInit( &ds );
	bu_vls_init( &vls );

	/* count segments */
	for( BU_LIST_FOR( ptp, wdb_pipept, &pipe->pipe_segs_head ) )
		num_segs++;

	if( attr == (char *)NULL )
	{
		bu_vls_strcat( &vls, "pipe");

		seg_no = 0;
		for( BU_LIST_FOR( ptp, wdb_pipept, &pipe->pipe_segs_head ) ) {
			bu_vls_printf( &vls, " V%d { %.25G %.25G %.25G } O%d %.25G I%d %.25G R%d %.25G",
				      seg_no, V3ARGS( ptp->pp_coord ),
				      seg_no, ptp->pp_od,
				      seg_no, ptp->pp_id,
				      seg_no, ptp->pp_bendradius );
			seg_no++;
		}
	}
	else if( attr[0] == 'N' )
	{
		bu_vls_printf( &vls, "%d", num_segs );
		goto out;
	}
	else
	{
		int curr_seg=0;

		seg_no = atoi( &attr[1] );
		if( seg_no < 0 || seg_no >= num_segs ) {
			bu_vls_printf( &vls, "segment number out of range (0 - %d)", num_segs-1 );
			status = TCL_ERROR;
			goto out;
		}

		/* find the desired vertex */
		for( BU_LIST_FOR( ptp, wdb_pipept, &pipe->pipe_segs_head ) ) {
			if( curr_seg == seg_no )
				break;
			curr_seg++;
		}

		switch( attr[0] ) {
			case 'V':
				bu_vls_printf( &vls, "%.25G %.25G %.25G", V3ARGS( ptp->pp_coord ) );
				break;
			case 'I':
				bu_vls_printf( &vls, "%.25G", ptp->pp_id );
				break;
			case 'O':
				bu_vls_printf( &vls, "%.25G", ptp->pp_od );
				break;
			case 'R':
				bu_vls_printf( &vls, "%.25G", ptp->pp_bendradius );
				break;
			case 'P':
				bu_vls_printf( &vls, " V%d { %.25G %.25G %.25G } I%d %.25G O%d %.25G R%d %.25G",
					      seg_no, V3ARGS( ptp->pp_coord ),
					      seg_no, ptp->pp_id,
					      seg_no, ptp->pp_od,
					      seg_no, ptp->pp_bendradius );
				break;
			default:
				bu_vls_printf( &vls, "unrecognized attribute (%c), choices are V, I, O, R, or P", attr[0] );
				status = TCL_ERROR;
				break;
		}
	}
out:
	Tcl_DStringAppend( &ds, bu_vls_addr( &vls ), -1 );
	Tcl_DStringResult( interp, &ds );
	Tcl_DStringFree( &ds );
	bu_vls_free( &vls );

	return( status );

}

int
rt_pipe_tcladjust(Tcl_Interp *interp, struct rt_db_internal *intern, int argc, char **argv, struct resource *resp)
{
	struct rt_pipe_internal		*pipe;
	struct wdb_pipept		*ptp;
	Tcl_Obj				*obj, *list;
	int				seg_no;
	int				num_segs;
	int				curr_seg;
	fastf_t				tmp;
	char				*v_str;
	

	RT_CK_DB_INTERNAL( intern );
	pipe = (struct rt_pipe_internal *)intern->idb_ptr;
	RT_PIPE_CK_MAGIC( pipe );

	while( argc >= 2 ) {

		/* count vertices */
		num_segs = 0;
		if( pipe->pipe_segs_head.forw ) {
			for( BU_LIST_FOR( ptp, wdb_pipept, &pipe->pipe_segs_head ) )
				num_segs++;
		} else {
			BU_LIST_INIT( &pipe->pipe_segs_head );
		}
		
		if( !isdigit( argv[0][1] ) ) {
			Tcl_SetResult( interp, "no vertex number specified", TCL_STATIC );
			return( TCL_ERROR );
		}

		seg_no = atoi( &argv[0][1] );
		if( seg_no == num_segs ) {
			struct wdb_pipept *new_pt;

			new_pt = (struct wdb_pipept *)bu_calloc( 1, sizeof( struct wdb_pipept ), "New pipe segment" );
			if( num_segs > 0 ) {
				ptp = BU_LIST_LAST( wdb_pipept, &pipe->pipe_segs_head );
				*new_pt = *ptp;		/* struct copy */
				BU_LIST_INSERT( &pipe->pipe_segs_head, &new_pt->l );
				ptp = new_pt;
			} else {
				VSETALL( new_pt->pp_coord, 0.0 );
				new_pt->pp_id = 0.0;
				new_pt->pp_od = 10.0;
				new_pt->pp_bendradius = 20.0;
				BU_LIST_INSERT( &pipe->pipe_segs_head, &new_pt->l );
				ptp = new_pt;
			}
			num_segs++;
		}
		if( seg_no < 0 || seg_no >= num_segs ) {
			Tcl_SetResult( interp, "vertex number out of range", TCL_STATIC );
			return( TCL_ERROR );
		}

		/* get the specified vertex */
		curr_seg = 0;
		for( BU_LIST_FOR( ptp, wdb_pipept, &pipe->pipe_segs_head ) ) {
			if( curr_seg == seg_no )
				break;
			curr_seg++;
		}
		

		switch( argv[0][0] ) {
			case 'V':
				obj = Tcl_NewStringObj( argv[1], -1 );
				list = Tcl_NewListObj( 0, NULL );
				Tcl_ListObjAppendList( interp, list, obj );
				v_str = Tcl_GetStringFromObj( list, NULL );
				while( isspace( *v_str ) ) v_str++;
				if( *v_str == '\0' ) {
					Tcl_SetResult( interp, "incomplete vertex specification", TCL_STATIC );
					Tcl_DecrRefCount( list );
					return( TCL_ERROR );
				}
				ptp->pp_coord[0] = atof( v_str );
				v_str = bu_next_token( v_str );
				if( *v_str == '\0' ) {
					Tcl_SetResult( interp, "incomplete vertex specification", TCL_STATIC );
					Tcl_DecrRefCount( list );
					return( TCL_ERROR );
				}
				ptp->pp_coord[1] = atof( v_str );
				v_str = bu_next_token( v_str );
				if( *v_str == '\0' ) {
					Tcl_SetResult( interp, "incomplete vertex specification", TCL_STATIC );
					Tcl_DecrRefCount( list );
					return( TCL_ERROR );
				}
				ptp->pp_coord[2] = atof( v_str );
				Tcl_DecrRefCount( list );
				break;
			case 'I':
				tmp = atof( argv[1] );
				if( tmp >= ptp->pp_od ) {
					Tcl_SetResult( interp, "inner diameter must be less than outer diameter", TCL_STATIC );
					return( TCL_ERROR );
				}
				ptp->pp_id = tmp;
				break;
			case 'O':
				tmp = atof( argv[1] );
				if( tmp <= 0.0 ) {
					Tcl_SetResult( interp, "outer diameter cannot be 0.0 or less", TCL_STATIC );
					return( TCL_ERROR );
				}
				if( tmp <= ptp->pp_id ) {
					Tcl_SetResult( interp, "outer diameter must be greater than inner diameter", TCL_STATIC );
					return( TCL_ERROR );
				}
				ptp->pp_od = tmp;
				break;
			case 'R':
				tmp = atof( argv[1] );
				if( tmp < ptp->pp_od * 0.5 ) {
					Tcl_SetResult( interp, "cannot set bend radius to less than outer radius", TCL_STATIC );
					return( TCL_ERROR );
				}
				ptp->pp_bendradius = tmp;
				break;
			default:
				Tcl_SetResult( interp, "unrecognized attribute, choices are V, I, O, or R", TCL_STATIC );
				return( TCL_ERROR );
		}

		argc -= 2;
		argv += 2;
	}

	return( TCL_OK );
}
@


11.62
log
@change conf.h to a wrapped config.h
@
text
@d19 1
a19 1
static const char RCSpipe[] = "@@(#)$Header: /cvs/brlcad/librt/g_pipe.c,v 11.61 2004/04/05 08:48:57 morrison Exp $ (BRL)";
@


11.61
log
@merge of ansi-6-0-branch into HEAD
@
text
@d19 1
a19 1
static const char RCSpipe[] = "@@(#)$Header$ (BRL)";
d22 5
a26 1
#include "conf.h"
@


11.60
log
@merge of windows-6-0-branch into head
@
text
@d119 1
a119 10
rt_bend_pipe_prep( stp, head, bend_center, bend_start, bend_end, bend_radius, bend_angle, v1, v2, od, id )
struct soltab		*stp;
struct bu_list	*head;
point_t bend_center;
point_t bend_start;
point_t bend_end;
fastf_t bend_radius;
fastf_t bend_angle;
vect_t v1,v2;
fastf_t od, id;
d200 1
a200 9
rt_linear_pipe_prep( stp, head, pt1, id1, od1, pt2, id2, od2 )
struct soltab *stp;
struct bu_list *head;
point_t pt1;
fastf_t id1;
fastf_t od1;
point_t pt2;
fastf_t id2;
fastf_t od2;
d292 1
a292 4
rt_pipe_prep( stp, ip, rtip )
struct soltab		*stp;
struct rt_db_internal	*ip;
struct rt_i		*rtip;
d410 1
a410 2
rt_pipe_print( stp )
register const struct soltab *stp;
d477 1
a477 9
bend_pipe_shot( stp, rp, ap, seghead, pipe, hit_headp, hit_count, seg_no )
struct soltab           *stp;
register struct xray    *rp;
struct application      *ap;
struct seg              *seghead;
struct bend_pipe	*pipe;
struct hit_list		*hit_headp;
int			*hit_count;
int			seg_no;
d697 1
a697 9
linear_pipe_shot( stp, rp, ap, seghead, pipe, hit_headp, hit_count, seg_no )
struct soltab           *stp;
register struct xray    *rp;
struct application      *ap;
struct seg              *seghead;
struct lin_pipe		*pipe;
struct hit_list		*hit_headp;
int			*hit_count;
int			seg_no;
d841 1
a841 9
pipe_start_shot( stp, rp, ap, seghead, pipe, hit_headp, hit_count, seg_no )
struct soltab           *stp;
register struct xray    *rp;
struct application      *ap;
struct seg              *seghead;
struct id_pipe		*pipe;
struct hit_list		*hit_headp;
int			*hit_count;
int			seg_no;
d914 1
a914 9
pipe_end_shot( stp, rp, ap, seghead, pipe, hit_headp, hit_count, seg_no )
struct soltab           *stp;
register struct xray    *rp;
struct application      *ap;
struct seg              *seghead;
struct id_pipe		*pipe;
struct hit_list		*hit_headp;
int			*hit_count;
int			seg_no;
d995 1
a995 5
rt_pipe_hitsort( h, nh, rp, stp )
struct hit_list		*h;
int			*nh;
struct soltab		*stp;
register struct xray	*rp;
d1140 1
a1140 4
rt_pipe_norm( hitp, stp, rp )
register struct hit	*hitp;
struct soltab		*stp;
register struct xray	*rp;
d1231 1
a1231 5
rt_pipe_shot( stp, rp, ap, seghead )
struct soltab		*stp;
register struct xray	*rp;
struct application	*ap;
struct seg		*seghead;
d1349 6
a1354 6
rt_pipe_vshot( stp, rp, segp, n, ap )
struct soltab	       *stp[]; /* An array of solid pointers */
struct xray		*rp[]; /* An array of ray pointers */
struct  seg            segp[]; /* array of segs (results returned) */
int		  	    n; /* Number of ray/object pairs */
struct application	*ap;
d1365 1
a1365 4
rt_pipe_curve( cvp, hitp, stp )
register struct curvature *cvp;
register struct hit	*hitp;
struct soltab		*stp;
d1385 1
a1385 5
rt_pipe_uv( ap, stp, hitp, uvp )
struct application	*ap;
struct soltab		*stp;
register struct hit	*hitp;
register struct uvcoord	*uvp;
d1395 1
a1395 2
rt_pipe_free( stp )
register struct soltab *stp;
d1419 1
a1419 1
rt_pipe_class()
d1434 1
a1434 8
draw_pipe_arc( vhead, radius, center, v1, v2, end, seg_count, full_circle )
struct bu_list		*vhead;
fastf_t			radius;
point_t			center;
vect_t			v1,v2;
point_t			end;
int			seg_count;
int			full_circle;
d1472 1
a1472 6
draw_linear_seg( vhead, p1, or1, ir1, p2, or2, ir2, v1, v2 )
struct bu_list			*vhead;
const point_t			p1,p2;
const fastf_t			or1,ir1,or2,ir2;
const vect_t			v1;
const vect_t			v2;
d1515 1
a1515 10
draw_pipe_bend( vhead, center, end, radius, angle, v1, v2, norm, or, ir, f1, f2, seg_count )
struct bu_list			*vhead;
const point_t			center;
const point_t			end;
const fastf_t			radius;
const fastf_t			angle;
const vect_t			v1,v2,norm;
const fastf_t			or,ir;
vect_t				f1,f2;
const int			seg_count;
d1602 1
a1602 5
rt_pipe_plot( vhead, ip, ttol, tol )
struct bu_list		*vhead;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol		*tol;
d1709 1
a1709 10
tesselate_pipe_start( pipe, arc_segs, sin_del, cos_del, outer_loop, inner_loop, r1, r2, s, tol )
struct wdb_pipept *pipe;
int arc_segs;
double sin_del;
double cos_del;
struct vertex ***outer_loop;
struct vertex ***inner_loop;
vect_t r1,r2;
struct shell *s;
struct bn_tol *tol;
d1825 1
a1825 13
tesselate_pipe_linear( start_pt, or, ir, end_pt, end_or, end_ir, arc_segs, sin_del, cos_del, outer_loop, inner_loop, r1, r2, s, tol )
point_t start_pt;
fastf_t or,ir;
point_t end_pt;
fastf_t end_or,end_ir;
int arc_segs;
double sin_del;
double cos_del;
struct vertex **outer_loop[];
struct vertex **inner_loop[];
vect_t r1, r2;
struct shell *s;
struct bn_tol *tol;
d2604 1
a2604 14
tesselate_pipe_bend( bend_start, bend_end, bend_center, or, ir, arc_segs, sin_del, cos_del, outer_loop, inner_loop, start_r1, start_r2, s, tol, ttol )
point_t bend_start;
point_t bend_end;
point_t bend_center;
fastf_t or,ir;
int arc_segs;
double sin_del;
double cos_del;
struct vertex **outer_loop[];
struct vertex **inner_loop[];
vect_t start_r1, start_r2;
struct shell *s;
struct bn_tol *tol;
struct rt_tess_tol *ttol;
d3033 1
a3033 9
tesselate_pipe_end( pipe, arc_segs, sin_del, cos_del, outer_loop, inner_loop, s, tol )
struct wdb_pipept *pipe;
int arc_segs;
double sin_del;
double cos_del;
struct vertex ***outer_loop;
struct vertex ***inner_loop;
struct shell *s;
struct bn_tol *tol;
d3112 1
a3112 6
rt_pipe_tess( r, m, ip, ttol, tol )
struct nmgregion	**r;
struct model		*m;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol		*tol;
d3299 1
a3299 5
rt_pipe_import( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
d3353 1
a3353 5
rt_pipe_export( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d3415 1
a3415 5
rt_pipe_import5( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
d3473 1
a3473 5
rt_pipe_export5( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d3535 1
a3535 5
rt_pipe_describe( str, ip, verbose, mm2local )
struct bu_vls		*str;
const struct rt_db_internal	*ip;
int			verbose;
double			mm2local;
d3583 1
a3583 2
rt_pipe_ifree( ip )
struct rt_db_internal	*ip;
d3714 1
a3714 4
rt_pipe_tclget( interp, intern, attr )
Tcl_Interp			*interp;
const struct rt_db_internal	*intern;
const char			*attr;
d3807 1
a3807 6
rt_pipe_tcladjust( interp, intern, argc, argv, resp)
Tcl_Interp		*interp;
struct rt_db_internal	*intern;
int			argc;
char			**argv;
struct resource		*resp;
@


11.59
log
@update copyright to include span through 2003
@
text
@d19 1
a19 1
static const char RCSpipe[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pipe.c,v 11.58 2003/01/20 02:06:59 jra Exp $ (BRL)";
d26 1
d28 1
d44 4
@


11.58
log
@calculation (in rt_shootray) and use (in rt_bot_shot) of new applictaion structure field (a_inv_dir)
@
text
@d15 1
a15 1
 *	This software is Copyright (C) 1990 by the United States Army.
d19 1
a19 1
static const char RCSpipe[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pipe.c,v 11.57 2003/01/17 03:47:06 jra Exp $ (BRL)";
@


11.58.6.1
log
@merge from HEAD
@
text
@d15 1
a15 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d19 1
a19 1
static const char RCSpipe[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pipe.c,v 11.59 2004/02/02 17:39:21 morrison Exp $ (BRL)";
@


11.58.6.2
log
@merge from head
@
text
@d19 1
a19 1
static const char RCSpipe[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pipe.c,v 11.58.6.1 2004/02/12 18:37:41 erikg Exp $ (BRL)";
@


11.58.6.3
log
@merge from head
@
text
@d19 1
a19 1
static const char RCSpipe[] = "@@(#)$Header$ (BRL)";
a25 1
#ifdef HAVE_UNISTD_H
a26 1
#endif
a41 4

#ifdef WIN32
#include <float.h> //isnan function
#endif
@


11.57
log
@bend_pipe_shot() now uses bend section RPP as first check for a miss,
the prep routine now calculates the bend section RPP
@
text
@d19 1
a19 1
static const char RCSpipe[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pipe.c,v 11.56 2002/08/20 17:08:00 jra Exp $ (BRL)";
a512 1
	LOCAL vect_t	inv_dir;
d516 1
a516 24
	/* Compute the inverse of the direction cosines */
	if( ap->a_ray.r_dir[X] < -SQRT_SMALL_FASTF )  {
		inv_dir[X]=1.0/ap->a_ray.r_dir[X];
	} else if( ap->a_ray.r_dir[X] > SQRT_SMALL_FASTF )  {
		inv_dir[X]=1.0/ap->a_ray.r_dir[X];
	} else {
		inv_dir[X] = INFINITY;
	}
	if( ap->a_ray.r_dir[Y] < -SQRT_SMALL_FASTF )  {
		inv_dir[Y]=1.0/ap->a_ray.r_dir[Y];
	} else if( ap->a_ray.r_dir[Y] > SQRT_SMALL_FASTF )  {
		inv_dir[Y]=1.0/ap->a_ray.r_dir[Y];
	} else {
		inv_dir[Y] = INFINITY;
	}
	if( ap->a_ray.r_dir[Z] < -SQRT_SMALL_FASTF )  {
		inv_dir[Z]=1.0/ap->a_ray.r_dir[Z];
	} else if( ap->a_ray.r_dir[Z] > SQRT_SMALL_FASTF )  {
		inv_dir[Z]=1.0/ap->a_ray.r_dir[Z];
	} else {
		inv_dir[Z] = INFINITY;
	}

	if( !rt_in_rpp( rp, inv_dir, pipe->bend_min, pipe->bend_max ) ) {
@


11.56
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d19 1
a19 1
static const char RCSpipe[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pipe.c,v 11.54 2002/07/17 22:51:47 butler Exp $ (BRL)";
d85 2
a129 2
	LOCAL point_t	tmp_pt_min;
	LOCAL point_t	tmp_pt_max;
d178 2
a179 2
	tmp_pt_min[X] = pipe->bend_V[X] - f;
	tmp_pt_max[X] = pipe->bend_V[X] + f;
d185 2
a186 2
	tmp_pt_min[Y] = pipe->bend_V[Y] - f;
	tmp_pt_max[Y] = pipe->bend_V[Y] + f;
d192 2
a193 2
	tmp_pt_min[Z] = pipe->bend_V[Z] - f;
	tmp_pt_max[Z] = pipe->bend_V[Z] + f;
d195 2
a196 2
	PIPE_MM( tmp_pt_min );
	PIPE_MM( tmp_pt_max );
d513 1
a513 2
	LOCAL fastf_t	dist_to_pca;
	LOCAL vect_t	to_start;
d517 25
a541 5
	VSUB2( to_start, rp->r_pt, pipe->bend_V );
	dist_to_pca = VDOT( to_start, rp->r_dir );
	if( (MAGSQ( to_start ) - dist_to_pca*dist_to_pca) > pipe->bend_R_SQ )
	{
		return;			/* Miss */
@


11.56.4.1
log
@Modifications (on a 6.0 source distribution) for initial port to windows (merged with sources close to 6.0.2)
@
text
@d19 1
a19 1
static const char RCSpipe[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pipe.c,v 11.56 2002/08/20 17:08:00 jra Exp $ (BRL)";
a25 1
#ifdef HAVE_UNISTD_H
a26 1
#endif
a41 4

#ifdef WIN32
#include <float.h> //isnan function
#endif
@


11.56.4.2
log
@sync to HEAD...
@
text
@d15 1
a15 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d19 1
a19 1
static const char RCSpipe[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/g_pipe.c,v 11.56.4.1 2002/09/26 23:04:01 morrison Exp $ (BRL)";
a90 2
	point_t bend_min;
	point_t bend_max;
d134 2
d184 2
a185 2
	pipe->bend_min[X] = pipe->bend_V[X] - f;
	pipe->bend_max[X] = pipe->bend_V[X] + f;
d191 2
a192 2
	pipe->bend_min[Y] = pipe->bend_V[Y] - f;
	pipe->bend_max[Y] = pipe->bend_V[Y] + f;
d198 2
a199 2
	pipe->bend_min[Z] = pipe->bend_V[Z] - f;
	pipe->bend_max[Z] = pipe->bend_V[Z] + f;
d201 2
a202 2
	PIPE_MM( pipe->bend_min );
	PIPE_MM( pipe->bend_max );
d519 2
d524 5
a528 2
	if( !rt_in_rpp( rp, ap->a_inv_dir, pipe->bend_min, pipe->bend_max ) ) {
		return;		 /* miss */
@


11.56.2.1
log
@Initial ANSIfication
@
text
@d19 1
a19 1
static const char RCSpipe[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pipe.c,v 11.56 2002/08/20 17:08:00 jra Exp $ (BRL)";
d111 10
a120 1
rt_bend_pipe_prep(struct soltab *stp, struct bu_list *head, fastf_t *bend_center, fastf_t *bend_start, fastf_t *bend_end, fastf_t bend_radius, fastf_t bend_angle, fastf_t *v1, fastf_t *v2, fastf_t od, fastf_t id)
d203 9
a211 1
rt_linear_pipe_prep(struct soltab *stp, struct bu_list *head, fastf_t *pt1, fastf_t id1, fastf_t od1, fastf_t *pt2, fastf_t id2, fastf_t od2)
d303 4
a306 1
rt_pipe_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
d424 2
a425 1
rt_pipe_print(register const struct soltab *stp)
d492 9
a500 1
bend_pipe_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead, struct bend_pipe *pipe, struct hit_list *hit_headp, int *hit_count, int seg_no)
d725 9
a733 1
linear_pipe_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead, struct lin_pipe *pipe, struct hit_list *hit_headp, int *hit_count, int seg_no)
d877 9
a885 1
pipe_start_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead, struct id_pipe *pipe, struct hit_list *hit_headp, int *hit_count, int seg_no)
d958 9
a966 1
pipe_end_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead, struct id_pipe *pipe, struct hit_list *hit_headp, int *hit_count, int seg_no)
d1047 5
a1051 1
rt_pipe_hitsort(struct hit_list *h, int *nh, register struct xray *rp, struct soltab *stp)
d1196 4
a1199 1
rt_pipe_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
d1290 5
a1294 1
rt_pipe_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
d1412 6
a1417 6
rt_pipe_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		  	       /* Number of ray/object pairs */
                  	    
d1428 4
a1431 1
rt_pipe_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
d1451 5
a1455 1
rt_pipe_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
d1465 2
a1466 1
rt_pipe_free(register struct soltab *stp)
d1490 1
a1490 1
rt_pipe_class(void)
d1505 8
a1512 1
draw_pipe_arc(struct bu_list *vhead, fastf_t radius, fastf_t *center, const fastf_t *v1, const fastf_t *v2, fastf_t *end, int seg_count, int full_circle)
d1550 6
a1555 1
draw_linear_seg(struct bu_list *vhead, const fastf_t *p1, const fastf_t or1, const fastf_t ir1, const fastf_t *p2, const fastf_t or2, const fastf_t ir2, const fastf_t *v1, const fastf_t *v2)
d1598 10
a1607 1
draw_pipe_bend(struct bu_list *vhead, const fastf_t *center, const fastf_t *end, const fastf_t radius, const fastf_t angle, const fastf_t *v1, const fastf_t *v2, const fastf_t *norm, const fastf_t or, const fastf_t ir, fastf_t *f1, fastf_t *f2, const int seg_count)
d1694 5
a1698 1
rt_pipe_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d1805 10
a1814 1
tesselate_pipe_start(struct wdb_pipept *pipe, int arc_segs, double sin_del, double cos_del, struct vertex ***outer_loop, struct vertex ***inner_loop, fastf_t *r1, fastf_t *r2, struct shell *s, const struct bn_tol *tol)
d1930 13
a1942 1
tesselate_pipe_linear(fastf_t *start_pt, fastf_t or, fastf_t ir, fastf_t *end_pt, fastf_t end_or, fastf_t end_ir, int arc_segs, double sin_del, double cos_del, struct vertex ***outer_loop, struct vertex ***inner_loop, fastf_t *r1, fastf_t *r2, struct shell *s, const struct bn_tol *tol)
d2721 14
a2734 1
tesselate_pipe_bend(fastf_t *bend_start, fastf_t *bend_end, fastf_t *bend_center, fastf_t or, fastf_t ir, int arc_segs, double sin_del, double cos_del, struct vertex ***outer_loop, struct vertex ***inner_loop, fastf_t *start_r1, fastf_t *start_r2, struct shell *s, const struct bn_tol *tol, const struct rt_tess_tol *ttol)
d3163 9
a3171 1
tesselate_pipe_end(struct wdb_pipept *pipe, int arc_segs, double sin_del, double cos_del, struct vertex ***outer_loop, struct vertex ***inner_loop, struct shell *s, const struct bn_tol *tol)
d3250 6
a3255 1
rt_pipe_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d3442 5
a3446 1
rt_pipe_import(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d3500 5
a3504 1
rt_pipe_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d3566 5
a3570 1
rt_pipe_import5(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d3628 5
a3632 1
rt_pipe_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d3694 5
a3698 1
rt_pipe_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
d3746 2
a3747 1
rt_pipe_ifree(struct rt_db_internal *ip)
d3878 4
a3881 1
rt_pipe_tclget(Tcl_Interp *interp, const struct rt_db_internal *intern, const char *attr)
d3974 6
a3979 1
rt_pipe_tcladjust(Tcl_Interp *interp, struct rt_db_internal *intern, int argc, char **argv, struct resource *resp)
@


11.56.2.2
log
@sync branch with HEAD
@
text
@d15 1
a15 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d19 1
a19 1
static const char RCSpipe[] = "@@(#)$Header$ (BRL)";
a25 1
#ifdef HAVE_UNISTD_H
a26 1
#endif
a42 4
#ifdef WIN32
#include <float.h> //isnan function
#endif

a84 2
	point_t bend_min;
	point_t bend_max;
d119 2
d169 2
a170 2
	pipe->bend_min[X] = pipe->bend_V[X] - f;
	pipe->bend_max[X] = pipe->bend_V[X] + f;
d176 2
a177 2
	pipe->bend_min[Y] = pipe->bend_V[Y] - f;
	pipe->bend_max[Y] = pipe->bend_V[Y] + f;
d183 2
a184 2
	pipe->bend_min[Z] = pipe->bend_V[Z] - f;
	pipe->bend_max[Z] = pipe->bend_V[Z] + f;
d186 2
a187 2
	PIPE_MM( pipe->bend_min );
	PIPE_MM( pipe->bend_max );
d484 2
d489 5
a493 2
	if( !rt_in_rpp( rp, ap->a_inv_dir, pipe->bend_min, pipe->bend_max ) ) {
		return;		 /* miss */
@


11.55
log
@Converted from K&R to ANSI C - RFH
@
text
@d111 10
a120 1
rt_bend_pipe_prep(struct soltab *stp, struct bu_list *head, fastf_t *bend_center, fastf_t *bend_start, fastf_t *bend_end, fastf_t bend_radius, fastf_t bend_angle, fastf_t *v1, fastf_t *v2, fastf_t od, fastf_t id)
d203 9
a211 1
rt_linear_pipe_prep(struct soltab *stp, struct bu_list *head, fastf_t *pt1, fastf_t id1, fastf_t od1, fastf_t *pt2, fastf_t id2, fastf_t od2)
d303 4
a306 1
rt_pipe_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
d424 2
a425 1
rt_pipe_print(register const struct soltab *stp)
d492 9
a500 1
bend_pipe_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead, struct bend_pipe *pipe, struct hit_list *hit_headp, int *hit_count, int seg_no)
d725 9
a733 1
linear_pipe_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead, struct lin_pipe *pipe, struct hit_list *hit_headp, int *hit_count, int seg_no)
d877 9
a885 1
pipe_start_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead, struct id_pipe *pipe, struct hit_list *hit_headp, int *hit_count, int seg_no)
d958 9
a966 1
pipe_end_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead, struct id_pipe *pipe, struct hit_list *hit_headp, int *hit_count, int seg_no)
d1047 5
a1051 1
rt_pipe_hitsort(struct hit_list *h, int *nh, register struct xray *rp, struct soltab *stp)
d1196 4
a1199 1
rt_pipe_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
d1290 5
a1294 1
rt_pipe_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
d1412 6
a1417 6
rt_pipe_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		  	       /* Number of ray/object pairs */
                  	    
d1428 4
a1431 1
rt_pipe_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
d1451 5
a1455 1
rt_pipe_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
d1465 2
a1466 1
rt_pipe_free(register struct soltab *stp)
d1490 1
a1490 1
rt_pipe_class(void)
d1505 8
a1512 1
draw_pipe_arc(struct bu_list *vhead, fastf_t radius, fastf_t *center, const fastf_t *v1, const fastf_t *v2, fastf_t *end, int seg_count, int full_circle)
d1550 6
a1555 1
draw_linear_seg(struct bu_list *vhead, const fastf_t *p1, const fastf_t or1, const fastf_t ir1, const fastf_t *p2, const fastf_t or2, const fastf_t ir2, const fastf_t *v1, const fastf_t *v2)
d1598 10
a1607 1
draw_pipe_bend(struct bu_list *vhead, const fastf_t *center, const fastf_t *end, const fastf_t radius, const fastf_t angle, const fastf_t *v1, const fastf_t *v2, const fastf_t *norm, const fastf_t or, const fastf_t ir, fastf_t *f1, fastf_t *f2, const int seg_count)
d1694 5
a1698 1
rt_pipe_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d1805 10
a1814 1
tesselate_pipe_start(struct wdb_pipept *pipe, int arc_segs, double sin_del, double cos_del, struct vertex ***outer_loop, struct vertex ***inner_loop, fastf_t *r1, fastf_t *r2, struct shell *s, const struct bn_tol *tol)
d1930 13
a1942 1
tesselate_pipe_linear(fastf_t *start_pt, fastf_t or, fastf_t ir, fastf_t *end_pt, fastf_t end_or, fastf_t end_ir, int arc_segs, double sin_del, double cos_del, struct vertex ***outer_loop, struct vertex ***inner_loop, fastf_t *r1, fastf_t *r2, struct shell *s, const struct bn_tol *tol)
d2721 14
a2734 1
tesselate_pipe_bend(fastf_t *bend_start, fastf_t *bend_end, fastf_t *bend_center, fastf_t or, fastf_t ir, int arc_segs, double sin_del, double cos_del, struct vertex ***outer_loop, struct vertex ***inner_loop, fastf_t *start_r1, fastf_t *start_r2, struct shell *s, const struct bn_tol *tol, const struct rt_tess_tol *ttol)
d3163 9
a3171 1
tesselate_pipe_end(struct wdb_pipept *pipe, int arc_segs, double sin_del, double cos_del, struct vertex ***outer_loop, struct vertex ***inner_loop, struct shell *s, const struct bn_tol *tol)
d3250 6
a3255 1
rt_pipe_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d3442 5
a3446 1
rt_pipe_import(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d3500 5
a3504 1
rt_pipe_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d3566 5
a3570 1
rt_pipe_import5(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d3628 5
a3632 1
rt_pipe_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d3694 5
a3698 1
rt_pipe_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
d3746 2
a3747 1
rt_pipe_ifree(struct rt_db_internal *ip)
d3878 4
a3881 1
rt_pipe_tclget(Tcl_Interp *interp, const struct rt_db_internal *intern, const char *attr)
d3974 6
a3979 1
rt_pipe_tcladjust(Tcl_Interp *interp, struct rt_db_internal *intern, int argc, char **argv, struct resource *resp)
@


11.54
log
@fixed loop exit test condition in rt_pipe_prep()
@
text
@d19 1
a19 1
static const char RCSpipe[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pipe.c,v 11.53 2001/10/02 19:24:30 jra Exp $ (BRL)";
d111 1
a111 10
rt_bend_pipe_prep( stp, head, bend_center, bend_start, bend_end, bend_radius, bend_angle, v1, v2, od, id )
struct soltab		*stp;
struct bu_list	*head;
point_t bend_center;
point_t bend_start;
point_t bend_end;
fastf_t bend_radius;
fastf_t bend_angle;
vect_t v1,v2;
fastf_t od, id;
d194 1
a194 9
rt_linear_pipe_prep( stp, head, pt1, id1, od1, pt2, id2, od2 )
struct soltab *stp;
struct bu_list *head;
point_t pt1;
fastf_t id1;
fastf_t od1;
point_t pt2;
fastf_t id2;
fastf_t od2;
d286 1
a286 4
rt_pipe_prep( stp, ip, rtip )
struct soltab		*stp;
struct rt_db_internal	*ip;
struct rt_i		*rtip;
d404 1
a404 2
rt_pipe_print( stp )
register const struct soltab *stp;
d471 1
a471 9
bend_pipe_shot( stp, rp, ap, seghead, pipe, hit_headp, hit_count, seg_no )
struct soltab           *stp;
register struct xray    *rp;
struct application      *ap;
struct seg              *seghead;
struct bend_pipe	*pipe;
struct hit_list		*hit_headp;
int			*hit_count;
int			seg_no;
d696 1
a696 9
linear_pipe_shot( stp, rp, ap, seghead, pipe, hit_headp, hit_count, seg_no )
struct soltab           *stp;
register struct xray    *rp;
struct application      *ap;
struct seg              *seghead;
struct lin_pipe		*pipe;
struct hit_list		*hit_headp;
int			*hit_count;
int			seg_no;
d840 1
a840 9
pipe_start_shot( stp, rp, ap, seghead, pipe, hit_headp, hit_count, seg_no )
struct soltab           *stp;
register struct xray    *rp;
struct application      *ap;
struct seg              *seghead;
struct id_pipe		*pipe;
struct hit_list		*hit_headp;
int			*hit_count;
int			seg_no;
d913 1
a913 9
pipe_end_shot( stp, rp, ap, seghead, pipe, hit_headp, hit_count, seg_no )
struct soltab           *stp;
register struct xray    *rp;
struct application      *ap;
struct seg              *seghead;
struct id_pipe		*pipe;
struct hit_list		*hit_headp;
int			*hit_count;
int			seg_no;
d994 1
a994 5
rt_pipe_hitsort( h, nh, rp, stp )
struct hit_list		*h;
int			*nh;
struct soltab		*stp;
register struct xray	*rp;
d1139 1
a1139 4
rt_pipe_norm( hitp, stp, rp )
register struct hit	*hitp;
struct soltab		*stp;
register struct xray	*rp;
d1230 1
a1230 5
rt_pipe_shot( stp, rp, ap, seghead )
struct soltab		*stp;
register struct xray	*rp;
struct application	*ap;
struct seg		*seghead;
d1348 6
a1353 6
rt_pipe_vshot( stp, rp, segp, n, ap )
struct soltab	       *stp[]; /* An array of solid pointers */
struct xray		*rp[]; /* An array of ray pointers */
struct  seg            segp[]; /* array of segs (results returned) */
int		  	    n; /* Number of ray/object pairs */
struct application	*ap;
d1364 1
a1364 4
rt_pipe_curve( cvp, hitp, stp )
register struct curvature *cvp;
register struct hit	*hitp;
struct soltab		*stp;
d1384 1
a1384 5
rt_pipe_uv( ap, stp, hitp, uvp )
struct application	*ap;
struct soltab		*stp;
register struct hit	*hitp;
register struct uvcoord	*uvp;
d1394 1
a1394 2
rt_pipe_free( stp )
register struct soltab *stp;
d1418 1
a1418 1
rt_pipe_class()
d1433 1
a1433 8
draw_pipe_arc( vhead, radius, center, v1, v2, end, seg_count, full_circle )
struct bu_list		*vhead;
fastf_t			radius;
point_t			center;
vect_t			v1,v2;
point_t			end;
int			seg_count;
int			full_circle;
d1471 1
a1471 6
draw_linear_seg( vhead, p1, or1, ir1, p2, or2, ir2, v1, v2 )
struct bu_list			*vhead;
const point_t			p1,p2;
const fastf_t			or1,ir1,or2,ir2;
const vect_t			v1;
const vect_t			v2;
d1514 1
a1514 10
draw_pipe_bend( vhead, center, end, radius, angle, v1, v2, norm, or, ir, f1, f2, seg_count )
struct bu_list			*vhead;
const point_t			center;
const point_t			end;
const fastf_t			radius;
const fastf_t			angle;
const vect_t			v1,v2,norm;
const fastf_t			or,ir;
vect_t				f1,f2;
const int			seg_count;
d1601 1
a1601 5
rt_pipe_plot( vhead, ip, ttol, tol )
struct bu_list		*vhead;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol		*tol;
d1708 1
a1708 10
tesselate_pipe_start( pipe, arc_segs, sin_del, cos_del, outer_loop, inner_loop, r1, r2, s, tol )
struct wdb_pipept *pipe;
int arc_segs;
double sin_del;
double cos_del;
struct vertex ***outer_loop;
struct vertex ***inner_loop;
vect_t r1,r2;
struct shell *s;
struct bn_tol *tol;
d1824 1
a1824 13
tesselate_pipe_linear( start_pt, or, ir, end_pt, end_or, end_ir, arc_segs, sin_del, cos_del, outer_loop, inner_loop, r1, r2, s, tol )
point_t start_pt;
fastf_t or,ir;
point_t end_pt;
fastf_t end_or,end_ir;
int arc_segs;
double sin_del;
double cos_del;
struct vertex **outer_loop[];
struct vertex **inner_loop[];
vect_t r1, r2;
struct shell *s;
struct bn_tol *tol;
d2603 1
a2603 14
tesselate_pipe_bend( bend_start, bend_end, bend_center, or, ir, arc_segs, sin_del, cos_del, outer_loop, inner_loop, start_r1, start_r2, s, tol, ttol )
point_t bend_start;
point_t bend_end;
point_t bend_center;
fastf_t or,ir;
int arc_segs;
double sin_del;
double cos_del;
struct vertex **outer_loop[];
struct vertex **inner_loop[];
vect_t start_r1, start_r2;
struct shell *s;
struct bn_tol *tol;
struct rt_tess_tol *ttol;
d3032 1
a3032 9
tesselate_pipe_end( pipe, arc_segs, sin_del, cos_del, outer_loop, inner_loop, s, tol )
struct wdb_pipept *pipe;
int arc_segs;
double sin_del;
double cos_del;
struct vertex ***outer_loop;
struct vertex ***inner_loop;
struct shell *s;
struct bn_tol *tol;
d3111 1
a3111 6
rt_pipe_tess( r, m, ip, ttol, tol )
struct nmgregion	**r;
struct model		*m;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol		*tol;
d3298 1
a3298 5
rt_pipe_import( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
d3352 1
a3352 5
rt_pipe_export( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d3414 1
a3414 5
rt_pipe_import5( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
d3472 1
a3472 5
rt_pipe_export5( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d3534 1
a3534 5
rt_pipe_describe( str, ip, verbose, mm2local )
struct bu_vls		*str;
const struct rt_db_internal	*ip;
int			verbose;
double			mm2local;
d3582 1
a3582 2
rt_pipe_ifree( ip )
struct rt_db_internal	*ip;
d3713 1
a3713 4
rt_pipe_tclget( interp, intern, attr )
Tcl_Interp			*interp;
const struct rt_db_internal	*intern;
const char			*attr;
d3806 1
a3806 6
rt_pipe_tcladjust( interp, intern, argc, argv, resp)
Tcl_Interp		*interp;
struct rt_db_internal	*intern;
int			argc;
char			**argv;
struct resource		*resp;
@


11.53
log
@Routines were not setting idb_major_type in the internal structure
@
text
@d19 1
a19 1
static const char RCSpipe[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pipe.c,v 11.52 2001/06/14 13:20:57 jra Exp $ (BRL)";
d393 1
@


11.52
log
@rt_pipe_import5() was reversing the order of points in the pipe
@
text
@d19 1
a19 1
static const char RCSpipe[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pipe.c,v 11.51 2001/04/20 22:29:46 morrison Exp $ (BRL)";
d3462 1
d3589 1
@


11.51
log
@CONST to const
@
text
@d19 1
a19 1
static const char RCSpipe[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pipe.c,v 11.50 2001/04/12 18:28:01 jra Exp $ (BRL)";
d3614 1
a3614 1
		BU_LIST_APPEND( &pipe->pipe_segs_head, &ptp->l );
@


11.50
log
@When duplicate hits are found remove both
@
text
@d19 1
a19 1
static const char RCSpipe[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pipe.c,v 11.49 2001/04/02 21:38:08 morrison Exp $ (BRL)";
d424 1
a424 1
register CONST struct soltab *stp;
d1551 4
a1554 4
CONST point_t			p1,p2;
CONST fastf_t			or1,ir1,or2,ir2;
CONST vect_t			v1;
CONST vect_t			v2;
d1599 6
a1604 6
CONST point_t			center;
CONST point_t			end;
CONST fastf_t			radius;
CONST fastf_t			angle;
CONST vect_t			v1,v2,norm;
CONST fastf_t			or,ir;
d1606 1
a1606 1
CONST int			seg_count;
d1696 2
a1697 2
CONST struct rt_tess_tol *ttol;
CONST struct bn_tol		*tol;
d3253 2
a3254 2
CONST struct rt_tess_tol *ttol;
CONST struct bn_tol		*tol;
d3443 3
a3445 3
CONST struct bu_external	*ep;
register CONST mat_t		mat;
CONST struct db_i		*dbip;
d3500 1
a3500 1
CONST struct rt_db_internal	*ip;
d3502 1
a3502 1
CONST struct db_i		*dbip;
d3566 3
a3568 3
CONST struct bu_external	*ep;
register CONST mat_t		mat;
CONST struct db_i		*dbip;
d3627 1
a3627 1
CONST struct rt_db_internal	*ip;
d3629 1
a3629 1
CONST struct db_i		*dbip;
d3693 1
a3693 1
CONST struct rt_db_internal	*ip;
d3877 2
a3878 2
CONST struct rt_db_internal	*intern;
CONST char			*attr;
@


11.49
log
@Deprecated bn_mat_copy() for new performance version of MAT_COPY() macro in h/vmath.h.
@
text
@d19 1
a19 1
static const char RCSpipe[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pipe.c,v 11.48 2001/03/31 01:57:08 morrison Exp $ (BRL)";
d515 2
a520 1
		*hit_count = 0;
d1056 1
a1091 2
		struct hit_list *next_hit;

d1105 9
@


11.48
log
@Deprecated bn_mat_idn() and bn_mat_zero(), updated calls to h/vmath.h's MAT_IDN() and MAT_ZERO() performance improved macros.
@
text
@d19 1
a19 1
static const char RCSpipe[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pipe.c,v 11.47 2001/03/20 15:47:05 butler Exp $ (BRL)";
d170 1
a170 1
	bn_mat_copy( pipe->bend_SoR, R );
@


11.47
log
@added include of ctype.h to get prototypes for isdigit and isspace
@
text
@d19 1
a19 1
static const char RCSpipe[] = "@@(#)$Header: /n/tgm/d/CVS/brlcad/librt/g_pipe.c,v 11.46 2001/03/19 22:19:58 butler Exp $ (BRL)";
d165 1
a165 1
	bn_mat_idn( R );
d249 1
a249 1
	bn_mat_idn( R );
d258 1
a258 1
	bn_mat_idn( S );
@


11.46
log
@patches to merge 5.3 into 6.0
@
text
@d19 1
a19 1
static const char RCSpipe[] = "@@(#)$Header: /d/CVS/brlcad/librt/g_pipe.c,v 11.45 2000/10/27 18:50:19 jra Exp $ (BRL)";
d25 1
@


11.45
log
@Decreased minimum number of edges along bend (for tessellation) to 1
@
text
@d19 1
a19 1
static const char RCSpipe[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pipe.c,v 11.44 2000/10/24 18:29:36 mike Exp $ (BRL)";
d25 1
d30 1
d373 1
a1764 3
			angle = bn_pi - acos( VDOT( n1, n2 ) );
			dist_to_bend = curp->pp_bendradius * tan( angle/2.0 );

d3516 1
a3516 1
	if( count <= 1 )
d3849 250
@


11.44
log
@
Added rt_pipept_print to raytrace.h
@
text
@d19 1
a19 1
static const char RCSpipe[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pipe.c,v 11.43 2000/10/24 18:22:38 mike Exp $ (BRL)";
d2743 1
a2743 1
	int bend_segs=3;	/* minimum number of edges along bend */
@


11.43
log
@
Added pipe routine to raytrace.h
@
text
@d19 1
a19 1
static const char RCSpipe[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pipe.c,v 11.42 2000/10/18 18:10:34 butler Exp $ (BRL)";
d426 3
d430 1
a430 3
rt_pipept_print( pipe, mm2local )
struct wdb_pipept *pipe;
double mm2local;
@


11.42
log
@Patches for compiling under RedHat 7.0
@
text
@d19 1
a19 1
static const char RCSpipe[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pipe.c,v 11.41 2000/08/22 21:16:59 mike Exp $ (BRL)";
d445 3
d449 5
a453 5
vls_pipept( vp, seg_no, ip, mm2local )
struct bu_vls *vp;
int seg_no;
CONST struct rt_db_internal *ip;
double mm2local;
@


11.41
log
@
lint
@
text
@d19 1
a19 1
static const char RCSpipe[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pipe.c,v 11.40 2000/08/15 18:42:56 jra Exp $ (BRL)";
d25 3
@


11.40
log
@Further refinements to collinearity problem
@
text
@d19 1
a19 1
static const char RCSpipe[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pipe.c,v 11.39 2000/08/10 20:13:50 jra Exp $ (BRL)";
d1944 2
d1950 2
@


11.39
log
@LOCAL variables need initialization
@
text
@d19 1
a19 1
static const char RCSpipe[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pipe.c,v 11.38 2000/08/10 15:18:37 jra Exp $ (BRL)";
a335 2
		fastf_t dot;
		fastf_t dotm1;
d358 3
a360 3
		dot = VDOT( n1, n2 );
		dotm1 = fabs( dot ) - 1.0;
		if( VNEAR_ZERO( norm, SQRT_SMALL_FASTF) || NEAR_ZERO( dotm1, SQRT_SMALL_FASTF) )
d368 2
a373 3
		angle = bn_pi - acos( dot );
		dist_to_bend = pp2->pp_bendradius * tan( angle/2.0 );
		VJOIN1( bend_start, pp2->pp_coord, dist_to_bend, n1 );
a377 1
		VJOIN1( bend_end, pp2->pp_coord, dist_to_bend, n2 );
d1716 2
a1717 1
		LOCAL fastf_t dot, dotm1;
d1737 3
a1739 3
		dot = VDOT( n1, n2 );
		dotm1 = fabs( dot ) - 1.0;
		if( VNEAR_ZERO( norm, SQRT_SMALL_FASTF ) || NEAR_ZERO( dotm1, SQRT_SMALL_FASTF) )
a1748 2
			LOCAL fastf_t angle;
			LOCAL fastf_t dist_to_bend;
@


11.38
log
@Improved checking for collinear pipe segments
@
text
@d19 1
a19 1
static const char RCSpipe[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pipe.c,v 11.37 2000/07/24 22:22:11 mike Exp $ (BRL)";
d1122 5
a1126 2
		bu_log( "ERROR: first hit on %s is an exit at (%g %g %g)\n",
			stp->st_dp->d_namep, V3ARGS( first->hitp->hit_point ) );
d1286 2
a1287 2
	LOCAL int			total_hits=0;
	LOCAL int			seg_no=0;
d1294 1
@


11.37
log
@
More new-libwdb-related cleanups
@
text
@d19 1
a19 1
static const char RCSpipe[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pipe.c,v 11.36 2000/07/24 19:27:31 mike Exp $ (BRL)";
d336 2
d358 5
a362 1
		if( VNEAR_ZERO( norm, SQRT_SMALL_FASTF ) )
a370 2
		VUNITIZE( n1 );
		VUNITIZE( n2 );
d374 1
a374 1
		angle = bn_pi - acos( VDOT( n1, n2 ) );
d1328 3
a1330 1
		bu_log( "rt_pipe_shot: bad number of hits (%d)\n" , total_hits );
d1339 10
a1348 1
		rt_bomb( "rt_pipe_shot\n" );
d1716 1
d1734 5
a1738 1
		if( VNEAR_ZERO( norm, SQRT_SMALL_FASTF ) )
a1753 2
			VUNITIZE( n1 );
			VUNITIZE( n2 );
@


11.36
log
@
Changed mged/typin.c to start using libwdb interfaces.
Which means mged/ged.c now also opens a libwdb interface.
@
text
@d19 1
a19 1
static const char RCSpipe[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pipe.c,v 11.35 2000/07/10 23:01:33 mike Exp $ (BRL)";
d3733 1
a3733 1
rt_pipe_ck( const struct wdb_pipept *headp )
d3741 1
a3741 1
	prev = BU_LIST_FIRST( wdb_pipept, &headp->l );
d3750 1
a3750 1
	while( BU_LIST_NOT_HEAD( &next->l, &headp->l ) )
@


11.35
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d19 1
a19 1
static const char RCSpipe[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pipe.c,v 11.34 2000/06/30 15:38:03 mike Exp $ (BRL)";
d3733 1
a3733 2
rt_pipe_ck( headp )
struct wdb_pipept *headp;
@


11.34
log
@
export methods should not init the external structure, just check them.
@
text
@d19 1
a19 1
static char RCSpipe[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pipe.c,v 11.33 2000/06/30 15:31:15 mike Exp $ (BRL)";
@


11.33
log
@
The import/export and import5/export5 methods must NOT
re-initialize their rt_db_internal* pointer, they should just check it.
@
text
@d19 1
a19 1
static char RCSpipe[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pipe.c,v 11.32 2000/06/28 21:00:00 bparker Exp $ (BRL)";
d3496 1
a3496 1
	BU_INIT_EXTERNAL(ep);
d3623 1
a3623 1
	BU_INIT_EXTERNAL(ep);
@


11.32
log
@Add rt_pipe_import5 and rt_pipe_export5 routines.
@
text
@d19 1
a19 1
static char RCSpipe[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pipe.c,v 11.31 2000/04/12 02:34:35 mike Exp $ (BRL)";
d3423 1
a3423 1
	RT_INIT_DB_INTERNAL( ip );
d3549 1
a3549 1
	RT_INIT_DB_INTERNAL( ip );
@


11.31
log
@
NT port, non-compat4
@
text
@d19 1
a19 1
static char RCSpipe[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pipe.c,v 11.30 1999/12/06 15:18:45 jra Exp $ (BRL)";
d3519 123
@


11.31.2.1
log
@Improved detection of collinear pipe points
@
text
@d19 1
a19 1
static char RCSpipe[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pipe.c,v 11.31 2000/04/12 02:34:35 mike Exp $ (BRL)";
a335 3
		vect_t diff;
		fastf_t dot;
		fastf_t dotm1;
d356 1
a356 5
		VUNITIZE( n1 );
		VUNITIZE( n2 );
		angle = bn_pi - acos( VDOT( n1, n2 ) );
		dist_to_bend = pp2->pp_bendradius * tan( angle/2.0 );
		if( isnan( dist_to_bend ) || VNEAR_ZERO( norm, SQRT_SMALL_FASTF) || NEAR_ZERO( dist_to_bend, SQRT_SMALL_FASTF) )
d364 3
a366 2
		VJOIN1( bend_start, pp2->pp_coord, dist_to_bend, n1 );
		VJOIN1( bend_end, pp2->pp_coord, dist_to_bend, n2 );
d370 3
d377 1
d1279 2
a1280 2
	LOCAL int			total_hits;
	LOCAL int			seg_no;
a1286 1
	seg_no = 0;
a1700 2
		LOCAL fastf_t angle;
		LOCAL fastf_t dist_to_bend;
d1718 1
a1718 5
		VUNITIZE( n1 );
		VUNITIZE( n2 );
		angle = bn_pi - acos( VDOT( n1, n2 ) );
		dist_to_bend = curp->pp_bendradius * tan( angle/2.0 );
		if( isnan( dist_to_bend ) || VNEAR_ZERO( norm, SQRT_SMALL_FASTF) || NEAR_ZERO( dist_to_bend, SQRT_SMALL_FASTF) )
d1728 2
d1734 2
d1737 3
@


11.31.2.2
log
@Eliminated some unused variables
@
text
@d19 1
a19 1
static char RCSpipe[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pipe.c,v 11.31.2.1 2000/08/15 17:54:39 jra Exp $ (BRL)";
d336 3
@


11.31.2.3
log
@Decreased minimum number of edges along bend (for tessellation) to 1
@
text
@d19 1
a19 1
static char RCSpipe[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pipe.c,v 11.31.2.2 2000/08/15 18:39:06 jra Exp $ (BRL)";
d2714 1
a2714 1
	int bend_segs=1;	/* minimum number of edges along bend */
@


11.31.2.4
log
@Added tclget and tcladjust routines
@
text
@d19 1
a19 1
static char RCSpipe[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pipe.c,v 11.31.2.3 2000/10/27 18:49:08 jra Exp $ (BRL)";
a25 1
#include "tcl.h"
a36 2
BU_EXTERN( char *next_tok, (char *str ) );

a3697 226
}


/*
 *			R T _ P I P E _ T C L _ G E T
 *
 *  Examples -
 *	db get name V#			get coordinates for vertex #
 *	db get name I#			get inner radius for vertex #
 *	db get name O#			get outer radius for vertex #
 *	db get name R#			get bendradius for vertex #
 *	db get name P#			get all data for vertex #
 *	db get name N			get number of vertices
 */

int
rt_pipe_tclget( interp, intern, attr )
Tcl_Interp			*interp;
CONST struct rt_db_internal	*intern;
CONST char			*attr;
{
	register struct rt_pipe_internal *pipe=(struct rt_pipe_internal *)intern->idb_ptr;
	struct wdb_pipept *ptp;
	Tcl_DString	ds;
	struct bu_vls	vls;
	int		status=TCL_OK;
	int		seg_no;
	int		num_segs=0;

	RT_PIPE_CK_MAGIC( pipe );

	Tcl_DStringInit( &ds );
	bu_vls_init( &vls );

	/* count segments */
	for( BU_LIST_FOR( ptp, wdb_pipept, &pipe->pipe_segs_head ) )
		num_segs++;

	if( attr == (char *)NULL )
	{
		bu_vls_strcat( &vls, "pipe");

		seg_no = 0;
		for( BU_LIST_FOR( ptp, wdb_pipept, &pipe->pipe_segs_head ) ) {
			bu_vls_printf( &vls, " V%d { %.25G %.25G %.25G } I%d %.25G O%d %.25G R%d %.25G",
				      seg_no, V3ARGS( ptp->pp_coord ),
				      seg_no, ptp->pp_id,
				      seg_no, ptp->pp_od,
				      seg_no, ptp->pp_bendradius );
			seg_no++;
		}
	}
	else if( attr[0] == 'N' )
	{
		bu_vls_printf( &vls, "%d", num_segs );
		goto out;
	}
	else
	{
		int curr_seg=0;

		seg_no = atoi( &attr[1] );
		if( seg_no < 0 || seg_no >= num_segs ) {
			bu_vls_printf( &vls, "segment number out of range (0 - %d)", num_segs-1 );
			status = TCL_ERROR;
			goto out;
		}

		/* find the desired vertex */
		for( BU_LIST_FOR( ptp, wdb_pipept, &pipe->pipe_segs_head ) ) {
			if( curr_seg == seg_no )
				break;
			curr_seg++;
		}

		switch( attr[0] ) {
			case 'V':
				bu_vls_printf( &vls, "%.25G %.25G %.25G", V3ARGS( ptp->pp_coord ) );
				break;
			case 'I':
				bu_vls_printf( &vls, "%.25G", ptp->pp_id );
				break;
			case 'O':
				bu_vls_printf( &vls, "%.25G", ptp->pp_od );
				break;
			case 'R':
				bu_vls_printf( &vls, "%.25G", ptp->pp_bendradius );
				break;
			case 'P':
				bu_vls_printf( &vls, " V%d { %.25G %.25G %.25G } I%d %.25G O%d %.25G R%d %.25G",
					      seg_no, V3ARGS( ptp->pp_coord ),
					      seg_no, ptp->pp_id,
					      seg_no, ptp->pp_od,
					      seg_no, ptp->pp_bendradius );
				break;
			default:
				bu_vls_printf( &vls, "unrecognized attribute (%c), choices are V, I, O, R, or P", attr[0] );
				status = TCL_ERROR;
				break;
		}
	}
out:
	Tcl_DStringAppend( &ds, bu_vls_addr( &vls ), -1 );
	Tcl_DStringResult( interp, &ds );
	Tcl_DStringFree( &ds );
	bu_vls_free( &vls );

	return( status );

}

int
rt_pipe_tcladjust( interp, intern, argc, argv )
Tcl_Interp		*interp;
struct rt_db_internal	*intern;
int			argc;
char			**argv;
{
	struct rt_pipe_internal		*pipe;
	struct wdb_pipept		*ptp;
	Tcl_Obj				*obj, *list;
	int				seg_no;
	int				num_segs;
	int				curr_seg;
	fastf_t				tmp;
	char				*v_str;
	

	RT_CK_DB_INTERNAL( intern );
	pipe = (struct rt_pipe_internal *)intern->idb_ptr;
	RT_PIPE_CK_MAGIC( pipe );

	while( argc >= 2 ) {

		/* count vertices */
		num_segs = 0;
		for( BU_LIST_FOR( ptp, wdb_pipept, &pipe->pipe_segs_head ) )
			num_segs++;
		
		if( !isdigit( argv[0][1] ) ) {
			Tcl_SetResult( interp, "no vertex number specified", TCL_STATIC );
			return( TCL_ERROR );
		}

		seg_no = atoi( &argv[0][1] );
		if( seg_no < 0 || seg_no >= num_segs ) {
			Tcl_SetResult( interp, "vertex number out of range", TCL_STATIC );
			return( TCL_ERROR );
		}

		/* get the specified vertex */
		curr_seg = 0;
		for( BU_LIST_FOR( ptp, wdb_pipept, &pipe->pipe_segs_head ) ) {
			if( curr_seg == seg_no )
				break;
			curr_seg++;
		}
		

		switch( argv[0][0] ) {
			case 'V':
				obj = Tcl_NewStringObj( argv[1], -1 );
				list = Tcl_NewListObj( 0, NULL );
				Tcl_ListObjAppendList( interp, list, obj );
				v_str = Tcl_GetStringFromObj( list, NULL );
				while( isspace( *v_str ) ) v_str++;
				if( *v_str == '\0' ) {
					Tcl_SetResult( interp, "incomplete vertex specification", TCL_STATIC );
					Tcl_DecrRefCount( list );
					return( TCL_ERROR );
				}
				ptp->pp_coord[0] = atof( v_str );
				v_str = next_tok( v_str );
				if( *v_str == '\0' ) {
					Tcl_SetResult( interp, "incomplete vertex specification", TCL_STATIC );
					Tcl_DecrRefCount( list );
					return( TCL_ERROR );
				}
				ptp->pp_coord[1] = atof( v_str );
				v_str = next_tok( v_str );
				if( *v_str == '\0' ) {
					Tcl_SetResult( interp, "incomplete vertex specification", TCL_STATIC );
					Tcl_DecrRefCount( list );
					return( TCL_ERROR );
				}
				ptp->pp_coord[2] = atof( v_str );
				Tcl_DecrRefCount( list );
				break;
			case 'I':
				tmp = atof( argv[1] );
				if( tmp >= ptp->pp_od ) {
					Tcl_SetResult( interp, "inner diameter must be less than outer diameter", TCL_STATIC );
					return( TCL_ERROR );
				}
				ptp->pp_id = tmp;
				break;
			case 'O':
				tmp = atof( argv[1] );
				if( tmp <= 0.0 ) {
					Tcl_SetResult( interp, "outer diameter cannot be 0.0 or less", TCL_STATIC );
					return( TCL_ERROR );
				}
				if( tmp <= ptp->pp_id ) {
					Tcl_SetResult( interp, "outer diameter must be greater than inner diameter", TCL_STATIC );
					return( TCL_ERROR );
				}
				ptp->pp_od = tmp;
				break;
			case 'R':
				tmp = atof( argv[1] );
				if( tmp < ptp->pp_od * 0.5 ) {
					Tcl_SetResult( interp, "cannot set bend radius to less than outer radius", TCL_STATIC );
					return( TCL_ERROR );
				}
				ptp->pp_bendradius = tmp;
				break;
			default:
				Tcl_SetResult( interp, "unrecognized attribute, choices are V, I, O, or R", TCL_STATIC );
				return( TCL_ERROR );
		}

		argc -= 2;
		argv += 2;
	}

	return( TCL_OK );
@


11.31.2.5
log
@Mods to allow db put to work for pipes
@
text
@d19 1
a19 1
static char RCSpipe[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pipe.c,v 11.31.2.4 2000/11/04 02:43:17 jra Exp $ (BRL)";
d3490 1
a3490 1
	if( count < 1 )
d3745 1
a3745 1
			bu_vls_printf( &vls, " V%d { %.25G %.25G %.25G } O%d %.25G I%d %.25G R%d %.25G",
d3747 1
a3748 1
				      seg_no, ptp->pp_id,
d3837 2
a3838 6
		if( pipe->pipe_segs_head.forw ) {
			for( BU_LIST_FOR( ptp, wdb_pipept, &pipe->pipe_segs_head ) )
				num_segs++;
		} else {
			BU_LIST_INIT( &pipe->pipe_segs_head );
		}
a3845 19
		if( seg_no == num_segs ) {
			struct wdb_pipept *new_pt;

			new_pt = (struct wdb_pipept *)bu_calloc( 1, sizeof( struct wdb_pipept ), "New pipe segment" );
			if( num_segs > 0 ) {
				ptp = BU_LIST_LAST( wdb_pipept, &pipe->pipe_segs_head );
				*new_pt = *ptp;		/* struct copy */
				BU_LIST_INSERT( &pipe->pipe_segs_head, &new_pt->l );
				ptp = new_pt;
			} else {
				VSETALL( new_pt->pp_coord, 0.0 );
				new_pt->pp_id = 0.0;
				new_pt->pp_od = 10.0;
				new_pt->pp_bendradius = 20.0;
				BU_LIST_INSERT( &pipe->pipe_segs_head, &new_pt->l );
				ptp = new_pt;
			}
			num_segs++;
		}
@


11.30
log
@Eliminated some unused variables
@
text
@d19 1
a19 1
static char RCSpipe[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pipe.c,v 11.29 1999/11/26 21:46:48 mike Exp $ (BRL)";
d1403 1
a1403 1
 	vec_ortho( cvp->crv_pdir, hitp->hit_normal );
@


11.29
log
@
Lint cleanups
@
text
@d19 1
a19 1
static char RCSpipe[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pipe.c,v 11.28 1999/11/17 02:42:00 mike Exp $ (BRL)";
a206 1
	fastf_t dx,dy,dz,f;
a489 1
	register struct seg *segp;
a494 2
	LOCAL double	k[4];		/* The real roots */
	register int	i;
a725 1
	LOCAL point_t	hit_pt;
a728 1
	LOCAL double	radius_sq;
a873 3
	point_t work_pt;
	point_t ray_start;
	vect_t ray_dir;
a954 3
	point_t work_pt;
	point_t ray_start;
	vect_t ray_dir;
a1039 1
	register int i, j;
a1043 1
	LOCAL struct hit temp;
a1274 2
	register struct lin_pipe	*pipe_lin;
	register struct bend_pipe	*pipe_bend;
d1432 1
d1435 1
a1435 1
#if 0
a1503 3
		vect_t radial_dir;
		fastf_t local_radius;

a1668 3
	LOCAL point_t				last_pt;
	LOCAL fastf_t				delta_ang;
	LOCAL fastf_t				cos_delta, sin_delta;
a1684 4
	delta_ang = 2.0*bn_pi/ARC_SEGS;
	cos_delta = cos( delta_ang );
	sin_delta = sin( delta_ang );

a1700 1
		LOCAL point_t pt;
a1732 2
			LOCAL mat_t mat;
			LOCAL vect_t tmp_vec;
a1789 1
	struct vertex ***verts;
a1908 1
	struct wdb_pipept *next;
a2698 2
	struct vertex *start_v;
	struct vertex_g *start_vg;
a2702 4
	fastf_t start_arc_angle;
	fastf_t xstart,ystart;
	double cos_bend_del;
	double sin_bend_del;
a2710 1
	vect_t to_start_v;
a2766 2
	sin_bend_del = sin( delta_angle );
	cos_bend_del = cos( delta_angle );
a3136 1
	int i;
d3322 1
a3322 1
		vect_t v1,v2;
a3372 1
		VCROSS( v2, v1, norm );
a3413 1
	int				count;
@


11.28
log
@
Added idb_meth and st_meth pointers to allow direct access to per-solid
methods, C++ style.
@
text
@d19 1
a19 1
static char RCSpipe[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pipe.c,v 11.27 1999/10/30 03:53:27 mike Exp $ (BRL)";
d1680 1
a1680 1
struct bn_tol		*tol;
d3256 1
a3256 1
struct bn_tol		*tol;
d3444 1
a3444 1
rt_pipe_import( ip, ep, mat )
d3448 1
d3502 1
a3502 1
rt_pipe_export( ep, ip, local2mm )
d3506 1
d3574 1
a3574 1
struct rt_db_internal	*ip;
@


11.27
log
@
Added magic numbers for ray, hit, and application structures.
@
text
@d19 1
a19 1
static char RCSpipe[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pipe.c,v 11.26 1999/07/02 22:19:23 mike Exp $ (BRL)";
d3466 1
@


11.26
log
@
Removed dependence on compat4.h
@
text
@d19 1
a19 1
static char RCSpipe[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pipe.c,v 11.25 1999/05/28 01:10:50 mike Exp $ (BRL)";
d623 1
d699 1
d780 1
d796 1
d839 1
d855 1
d912 1
d943 1
d998 1
d1035 1
@


11.25
log
@
More sed4 trouble from the rule of rt_pi to bn_pi.
@
text
@d19 1
a19 1
static char RCSpipe[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pipe.c,v 11.24 1999/05/27 20:02:42 mike Exp $ (BRL)";
a35 2
#include "./complex.h"
#include "./polyno.h"
d101 1
a101 1
RT_EXTERN( void bn_pipe_ifree, (struct rt_db_internal *ip) );
d149 1
a149 1
		bu_log( "Error: bn_pipe_prep: Bend section bends through more than 180 degrees\n" );
d495 1
a495 1
	LOCAL poly	C;		/* The final equation */
d501 2
a502 2
	LOCAL poly	A, Asqr;
	LOCAL poly	X2_Y2;		/* X**2 + Y**2 */
d1506 1
a1506 1
	RT_ADD_VLIST( vhead, pt, RT_VLIST_LINE_MOVE );
d1515 1
a1515 1
		RT_ADD_VLIST( vhead, pt, RT_VLIST_LINE_DRAW );
d1532 1
a1532 1
	RT_ADD_VLIST( vhead, pt, RT_VLIST_LINE_MOVE );
d1534 1
a1534 1
	RT_ADD_VLIST( vhead, pt, RT_VLIST_LINE_DRAW );
d1536 1
a1536 1
	RT_ADD_VLIST( vhead, pt, RT_VLIST_LINE_MOVE );
d1538 1
a1538 1
	RT_ADD_VLIST( vhead, pt, RT_VLIST_LINE_DRAW );
d1540 1
a1540 1
	RT_ADD_VLIST( vhead, pt, RT_VLIST_LINE_MOVE );
d1542 1
a1542 1
	RT_ADD_VLIST( vhead, pt, RT_VLIST_LINE_DRAW );
d1544 1
a1544 1
	RT_ADD_VLIST( vhead, pt, RT_VLIST_LINE_MOVE );
d1546 1
a1546 1
	RT_ADD_VLIST( vhead, pt, RT_VLIST_LINE_DRAW );
d1552 1
a1552 1
	RT_ADD_VLIST( vhead, pt, RT_VLIST_LINE_MOVE );
d1554 1
a1554 1
	RT_ADD_VLIST( vhead, pt, RT_VLIST_LINE_DRAW );
d1556 1
a1556 1
	RT_ADD_VLIST( vhead, pt, RT_VLIST_LINE_MOVE );
d1558 1
a1558 1
	RT_ADD_VLIST( vhead, pt, RT_VLIST_LINE_DRAW );
d1560 1
a1560 1
	RT_ADD_VLIST( vhead, pt, RT_VLIST_LINE_MOVE );
d1562 1
a1562 1
	RT_ADD_VLIST( vhead, pt, RT_VLIST_LINE_DRAW );
d1564 1
a1564 1
	RT_ADD_VLIST( vhead, pt, RT_VLIST_LINE_MOVE );
d1566 1
a1566 1
	RT_ADD_VLIST( vhead, pt, RT_VLIST_LINE_DRAW );
a3329 1

@


11.24
log
@
That was an odd transformation.
rt_pi to bn_pi caught rt_pipe_internal. Ugh.
@
text
@d19 1
a19 1
static char RCSpipe[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pipe.c,v 11.23 1999/05/27 19:10:40 mike Exp $ (BRL)";
d300 1
a300 1
bn_pipe_prep( stp, ip, rtip )
d316 1
a316 1
	head = (struct bu_list *)bu_malloc( sizeof( struct bu_list ), "bn_pipe_prep:head" );
d419 1
a419 1
bn_pipe_print( stp )
d427 1
a427 1
bn_pipept_print( pipe, mm2local )
d1038 1
a1038 1
bn_pipe_hitsort( h, nh, rp, stp )
d1097 2
a1098 2
			bu_free( (char *)tmp->hitp, "bn_pipe_hitsort: tmp->hitp" );
			bu_free( (char *)tmp, "bn_pipe_hitsort: tmp" );
d1178 1
a1178 1
bn_pipe_norm( hitp, stp, rp )
d1255 1
a1255 1
			bu_log( "bn_pipe_norm: Unrecognized surfno (%d)\n", hitp->hit_surfno );
d1272 1
a1272 1
bn_pipe_shot( stp, rp, ap, seghead )
d1324 1
a1324 1
		bn_pipe_norm( hitp->hitp, stp , rp );
d1326 1
a1326 1
	bn_pipe_hitsort( &hit_head, &total_hits, rp, stp );
d1332 1
a1332 1
		bu_log( "bn_pipe_shot: bad number of hits (%d)\n" , total_hits );
d1341 1
a1341 1
		rt_bomb( "bn_pipe_shot\n" );
d1366 2
a1367 2
		bu_free( (char *)hitp->hitp, "bn_pipe_shot: hitp->hitp" );
		bu_free( (char *)hitp, "bn_pipe_shot: hitp" );
d1384 1
a1384 1
bn_pipe_vshot( stp, rp, segp, n, ap )
d1400 1
a1400 1
bn_pipe_curve( cvp, hitp, stp )
d1423 1
a1423 1
bn_pipe_uv( ap, stp, hitp, uvp )
d1437 1
a1437 1
bn_pipe_free( stp )
d1461 1
a1461 1
bn_pipe_class()
d1668 1
a1668 1
bn_pipe_plot( vhead, ip, ttol, tol )
d3243 1
a3243 1
bn_pipe_tess( r, m, ip, ttol, tol )
d3329 1
a3329 1
			"bn_pipe_tess: outer_loop" );
d3331 1
a3331 1
			"bn_pipe_tess: inner_loop" );
d3425 2
a3426 2
	bu_free( (char *)outer_loop, "bn_pipe_tess: outer_loop" );
	bu_free( (char *)inner_loop, "bn_pipe_tess: inner_loop" );
d3437 1
a3437 1
bn_pipe_import( ip, ep, mat )
d3453 1
a3453 1
		bu_log("bn_pipe_import: defective record\n");
d3493 1
a3493 1
bn_pipe_export( ep, ip, local2mm )
d3562 1
a3562 1
bn_pipe_describe( str, ip, verbose, mm2local )
d3614 1
a3614 1
bn_pipe_ifree( ip )
d3642 1
a3642 1
bn_pipe_ck( headp )
@


11.23
log
@
sed4
@
text
@d19 1
a19 1
static char RCSpipe[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pipe.c,v 11.22 1999/03/11 20:06:42 jra Exp $ (BRL)";
d28 2
d306 1
a306 1
	struct bn_pipe_internal	*pip;
d313 1
a313 1
	pip = (struct bn_pipe_internal *)ip->idb_ptr;
d452 1
a452 1
	struct bn_pipe_internal *pint;
d458 1
a458 1
	pint = (struct bn_pipe_internal *)ip->idb_ptr;
d1677 1
a1677 1
	LOCAL struct bn_pipe_internal		*pip;
d1685 1
a1685 1
	pip = (struct bn_pipe_internal *)ip->idb_ptr;
d3255 1
a3255 1
	struct bn_pipe_internal *pip;
d3272 1
a3272 1
	pip = (struct bn_pipe_internal *)ip->idb_ptr;
d3445 1
a3445 1
	struct bn_pipe_internal		*pipe;
d3459 2
a3460 2
	ip->idb_ptr = bu_malloc( sizeof(struct bn_pipe_internal), "bn_pipe_internal");
	pipe = (struct bn_pipe_internal *)ip->idb_ptr;
d3498 1
a3498 1
	struct bn_pipe_internal	*pip;
d3510 1
a3510 1
	pip = (struct bn_pipe_internal *)ip->idb_ptr;
d3568 1
a3568 1
	register struct bn_pipe_internal	*pip;
d3574 1
a3574 1
	pip = (struct bn_pipe_internal *)ip->idb_ptr;
d3617 1
a3617 1
	register struct bn_pipe_internal	*pipe;
d3621 1
a3621 1
	pipe = (struct bn_pipe_internal*)ip->idb_ptr;
@


11.22
log
@Mods to handle self-overlap a bit better (still not the best)
@
text
@d19 1
a19 1
static char RCSpipe[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pipe.c,v 11.21 1999/03/09 22:24:35 jra Exp $ (BRL)";
d39 1
a39 1
	struct rt_list l;
d45 1
a45 1
	struct rt_list l;
d62 1
a62 1
	struct rt_list l;
d84 1
a84 1
	struct rt_list	l;
d101 1
a101 1
RT_EXTERN( void rt_pipe_ifree, (struct rt_db_internal *ip) );
d107 1
a107 1
struct rt_list	*head;
d125 2
a126 2
	pipe = (struct bend_pipe *)rt_malloc( sizeof( struct bend_pipe ), "rt_bend_pipe_prep:pipe" )	 ;
	RT_LIST_INSERT( head, &pipe->l );
d147 1
a147 1
	if( pipe->bend_angle >= rt_pi )
d149 1
a149 1
		rt_log( "Error: rt_pipe_prep: Bend section bends through more than 180 degrees\n" );
d159 1
a159 1
	mat_idn( R );
d163 2
a164 2
	mat_inv( pipe->bend_invR, R );
	mat_copy( pipe->bend_SoR, R );
d199 1
a199 1
struct rt_list *head;
d216 2
a217 2
	pipe = (struct lin_pipe *)rt_malloc( sizeof( struct lin_pipe ), "rt_bend_pipe_prep:pipe" );
	RT_LIST_INSERT( head, &pipe->l );
d240 1
a240 1
	mat_vec_ortho( v1, seg_ht );
d244 1
a244 1
	mat_idn( R );
d250 1
a250 1
	mat_trn( Rinv, R );
d253 1
a253 1
	mat_idn( S );
d257 2
a258 2
	mat_mul( pipe->pipe_SoR, S, R );
	mat_mul( pipe->pipe_invRoS, Rinv, S );
d294 1
a294 1
 *  	A struct rt_list is created, and it's address is stored in
d298 1
a298 1
rt_pipe_prep( stp, ip, rtip )
d303 2
a304 2
	register struct rt_list *head;
	struct rt_pipe_internal	*pip;
d311 1
a311 1
	pip = (struct rt_pipe_internal *)ip->idb_ptr;
d314 1
a314 1
	head = (struct rt_list *)rt_malloc( sizeof( struct rt_list ), "rt_pipe_prep:head" );
d316 1
a316 1
	RT_LIST_INIT( head );
d318 1
a318 1
	if( RT_LIST_IS_EMPTY( &(pip->pipe_segs_head) ) )
d321 3
a323 3
	pp1 = RT_LIST_FIRST( wdb_pipept, &(pip->pipe_segs_head) );
	pp2 = RT_LIST_NEXT( wdb_pipept, &pp1->l );
	if( RT_LIST_IS_HEAD( &pp2->l, &(pip->pipe_segs_head) ) )
d325 2
a326 2
	pp3 = RT_LIST_NEXT( wdb_pipept, &pp2->l );
	if( RT_LIST_IS_HEAD( &pp3->l ,  &(pip->pipe_segs_head) ) )
d371 1
a371 1
		angle = rt_pi - acos( VDOT( n1, n2 ) );
d391 2
a392 2
		pp3 = RT_LIST_NEXT( wdb_pipept, &pp3->l );
		if( RT_LIST_IS_HEAD( &pp3->l ,  &(pip->pipe_segs_head) ) )
d417 1
a417 1
rt_pipe_print( stp )
d420 2
a421 2
/*	register struct rt_list *pipe =
		(struct rt_list *)stp->st_specific; */
d425 1
a425 1
rt_pipept_print( pipe, mm2local )
d431 1
a431 1
	rt_log( "Pipe Vertex:\n" );
d433 2
a434 2
	rt_log( "\tat (%g %g %g)\n", V3ARGS( p1 ) );
	rt_log( "\tbend radius = %g\n", pipe->pp_bendradius*mm2local );
d436 1
a436 1
		rt_log( "\tod=%g, id=%g\n",
d440 1
a440 1
		rt_log( "\tod=%g\n", pipe->pp_od*mm2local );
d445 1
a445 1
struct rt_vls *vp;
d450 1
a450 1
	struct rt_pipe_internal *pint;
d456 1
a456 1
	pint = (struct rt_pipe_internal *)ip->idb_ptr;
d459 3
a461 3
	pipe = RT_LIST_FIRST( wdb_pipept, &pint->pipe_segs_head );
	while( ++seg_count != seg_no && RT_LIST_NOT_HEAD( &pipe->l, &pint->pipe_segs_head ) )
		pipe = RT_LIST_NEXT( wdb_pipept, &pipe->l );
d465 1
a465 1
	rt_vls_strcat( vp, buf );
d468 1
a468 1
	rt_vls_strcat( vp, buf );
d470 1
a470 1
	rt_vls_strcat( vp, buf );
d477 1
a477 1
	rt_vls_strcat( vp, buf );
d496 1
a496 1
	LOCAL complex	val[4];	/* The complex roots */
d573 1
a573 1
	/* Inline expansion of rt_poly_scale( &X2_Y2, 4.0 ) and
d588 2
a589 2
			rt_log("tor:  rt_poly_roots() 4!=%d\n", root_count);
			rt_pr_roots( stp->st_name, val, root_count );
d618 1
a618 1
				angle += 2.0 * rt_pi;
d621 2
a622 2
				GETSTRUCT( hitp, hit_list );
				GETSTRUCT( hitp->hitp, hit );
d626 1
a626 1
				RT_LIST_INSERT( &hit_headp->l, &hitp->l );
d648 1
a648 1
	/* Inline expansion of rt_poly_scale( &X2_Y2, 4.0 ) and
d663 2
a664 2
			rt_log("tor:  rt_poly_roots() 4!=%d\n", root_count);
			rt_pr_roots( stp->st_name, val, root_count );
d693 1
a693 1
				angle += 2.0 * rt_pi;
d696 2
a697 2
				GETSTRUCT( hitp, hit_list );
				GETSTRUCT( hitp->hitp, hit );
d701 1
a701 1
				RT_LIST_INSERT( &hit_headp->l, &hitp->l );
d736 1
a736 1
		rt_log( "linear_pipe_shot called for pipe bend\n" );
d776 2
a777 2
			GETSTRUCT( hitp, hit_list );
			GETSTRUCT( hitp->hitp, hit );
d784 1
a784 1
			RT_LIST_INSERT( &hit_headp->l, &hitp->l );
d791 2
a792 2
			GETSTRUCT( hitp, hit_list );
			GETSTRUCT( hitp->hitp, hit );
d799 1
a799 1
			RT_LIST_INSERT( &hit_headp->l, &hitp->l );
d833 2
a834 2
				GETSTRUCT( hitp, hit_list );
				GETSTRUCT( hitp->hitp, hit );
d841 1
a841 1
				RT_LIST_INSERT( &hit_headp->l, &hitp->l );
d848 2
a849 2
				GETSTRUCT( hitp, hit_list );
				GETSTRUCT( hitp->hitp, hit );
d856 1
a856 1
				RT_LIST_INSERT( &hit_headp->l, &hitp->l );
d904 2
a905 2
				GETSTRUCT( hitp, hit_list );
				GETSTRUCT( hitp->hitp, hit );
d909 1
a909 1
				RT_LIST_INSERT( &hit_headp->l, &hitp->l );
d934 2
a935 2
				GETSTRUCT( hitp, hit_list );
				GETSTRUCT( hitp->hitp, hit );
d939 1
a939 1
				RT_LIST_INSERT( &hit_headp->l, &hitp->l );
d988 2
a989 2
				GETSTRUCT( hitp, hit_list );
				GETSTRUCT( hitp->hitp, hit );
d993 1
a993 1
				RT_LIST_INSERT( &hit_headp->l, &hitp->l );
d1024 2
a1025 2
				GETSTRUCT( hitp, hit_list );
				GETSTRUCT( hitp->hitp, hit );
d1029 1
a1029 1
				RT_LIST_INSERT( &hit_headp->l, &hitp->l );
d1036 1
a1036 1
rt_pipe_hitsort( h, nh, rp, stp )
d1049 2
a1050 2
	hitp = RT_LIST_FIRST( hit_list, &h->l );
	while( RT_LIST_NEXT_NOT_HEAD( &hitp->l, &h->l ) )
d1055 1
a1055 1
		next_hit = RT_LIST_NEXT( hit_list, &hitp->l );
d1060 1
a1060 1
			if( hitp == RT_LIST_FIRST( hit_list, &h->l ) )
d1063 1
a1063 1
				prev_hit = RT_LIST_PREV( hit_list, &hitp->l );
d1067 2
a1068 2
			RT_LIST_DEQUEUE( &tmp->l );
			RT_LIST_INSERT( &h->l, &tmp->l );
d1073 1
a1073 1
				hitp = RT_LIST_FIRST( hit_list, &h->l );
d1080 2
a1081 2
	hitp = RT_LIST_FIRST( hit_list, &h->l );
	while( RT_LIST_NEXT_NOT_HEAD( &hitp->l, &h->l ) )
d1085 1
a1085 1
		next_hit = RT_LIST_NEXT( hit_list, &hitp->l );
d1094 3
a1096 3
			RT_LIST_DEQUEUE( &tmp->l );
			rt_free( (char *)tmp->hitp, "rt_pipe_hitsort: tmp->hitp" );
			rt_free( (char *)tmp, "rt_pipe_hitsort: tmp" );
d1105 1
a1105 1
		while( RT_LIST_WHILE( hitp, hit_list, &h->l ) )
d1107 3
a1109 3
			RT_LIST_DEQUEUE( &hitp->l );
			rt_free( (char *)hitp->hitp, "pipe_hitsort: hitp->hitp" );
			rt_free( (char *)hitp, "pipe_hitsort: hitp" );
d1119 1
a1119 1
	first = RT_LIST_FIRST( hit_list, &h->l );
d1125 1
a1125 1
		while( RT_LIST_WHILE( hitp, hit_list, &h->l ) )
d1127 3
a1129 3
			RT_LIST_DEQUEUE( &hitp->l );
			rt_free( (char *)hitp->hitp, "pipe_hitsort: hitp->hitp" );
			rt_free( (char *)hitp, "pipe_hitsort: hitp" );
d1135 1
a1135 1
	while( RT_LIST_NOT_HEAD( &first->l, &h->l ) )
d1137 2
a1138 2
		second = RT_LIST_NEXT( hit_list, &first->l );
		if( RT_LIST_IS_HEAD( &second->l, &h->l ) )
d1141 1
a1141 1
		while( RT_LIST_NOT_HEAD( &second->l, &h->l ) && VDOT( second->hitp->hit_normal, rp->r_dir ) < 0.0 )
d1144 2
a1145 2
			second = RT_LIST_NEXT( hit_list, &second->l );
			if( RT_LIST_NOT_HEAD( &second->l, &h->l ) )
d1147 3
a1149 3
				RT_LIST_DEQUEUE( &prev->l );
				rt_free( (char *)prev->hitp, "pipe_hitsort: prev->hitp" );
				rt_free( (char *)prev, "pipe_hitsort: prev" );
d1154 1
a1154 1
		while( RT_LIST_NOT_HEAD( &second->l, &h->l ) && VDOT( second->hitp->hit_normal, rp->r_dir ) > 0.0 )
d1158 3
a1160 3
				RT_LIST_DEQUEUE( &prev->l );
				rt_free( (char *)prev->hitp, "pipe_hitsort: prev->hitp" );
				rt_free( (char *)prev, "pipe_hitsort: prev" );
d1164 1
a1164 1
			second = RT_LIST_NEXT( hit_list, &second->l );
d1176 1
a1176 1
rt_pipe_norm( hitp, stp, rp )
d1181 2
a1182 2
	register struct rt_list		*pipe =
		(struct rt_list *)stp->st_specific;
d1194 1
a1194 1
	pipe_id = RT_LIST_FIRST( id_pipe, pipe );
d1196 1
a1196 1
		pipe_id = RT_LIST_NEXT( id_pipe, &pipe_id->l );
d1253 1
a1253 1
			rt_log( "rt_pipe_norm: Unrecognized surfno (%d)\n", hitp->hit_surfno );
d1270 1
a1270 1
rt_pipe_shot( stp, rp, ap, seghead )
d1276 2
a1277 2
	register struct rt_list		*head =
		(struct rt_list *)stp->st_specific;
d1289 1
a1289 1
	RT_LIST_INIT( &hit_head.l );
d1291 1
a1291 1
	pipe_start_shot( stp, rp, ap, seghead, RT_LIST_FIRST( id_pipe, head ),
d1293 1
a1293 1
	for( RT_LIST_FOR( pipe_id, id_pipe, head ) )
d1295 1
a1295 1
	pipe_end_shot( stp, rp, ap, seghead, RT_LIST_LAST( id_pipe, head ),
d1300 1
a1300 1
	for( RT_LIST_FOR( pipe_id, id_pipe, head ) )
d1321 2
a1322 2
	for( RT_LIST_FOR( hitp, hit_list, &hit_head.l ) )
		rt_pipe_norm( hitp->hitp, stp , rp );
d1324 1
a1324 1
	rt_pipe_hitsort( &hit_head, &total_hits, rp, stp );
d1330 2
a1331 2
		rt_log( "rt_pipe_shot: bad number of hits (%d)\n" , total_hits );
		for( RT_LIST_FOR( hitp, hit_list, &hit_head.l ) )
d1335 1
a1335 1
			rt_log( "#%d, dist = %g, surfno=%d\n" , ++i, hitp->hitp->hit_dist, hitp->hitp->hit_surfno );
d1337 1
a1337 1
			rt_log( "\t( %g %g %g )\n" , V3ARGS( hit_pt ) );
d1339 1
a1339 1
		rt_bomb( "rt_pipe_shot\n" );
d1342 2
a1343 2
	hitp = RT_LIST_FIRST( hit_list, &hit_head.l );
	while( RT_LIST_NOT_HEAD( &hitp->l, &hit_head.l ) )
d1347 1
a1347 1
		next = RT_LIST_NEXT( hit_list, &hitp->l );
d1355 1
a1355 1
		RT_LIST_INSERT( &(seghead->l), &(segp->l) );
d1357 1
a1357 1
		hitp = RT_LIST_NEXT( hit_list, &next->l );
d1361 1
a1361 1
	while( RT_LIST_WHILE( hitp, hit_list, &hit_head.l ) )
d1363 3
a1365 3
		RT_LIST_DEQUEUE( &hitp->l );
		rt_free( (char *)hitp->hitp, "rt_pipe_shot: hitp->hitp" );
		rt_free( (char *)hitp, "rt_pipe_shot: hitp" );
d1382 1
a1382 1
rt_pipe_vshot( stp, rp, segp, n, ap )
d1398 1
a1398 1
rt_pipe_curve( cvp, hitp, stp )
d1403 2
a1404 2
/*	register struct rt_list *pipe =
		(struct rt_list *)stp->st_specific; */
d1421 1
a1421 1
rt_pipe_uv( ap, stp, hitp, uvp )
d1427 2
a1428 2
/*	register struct rt_list *pipe =
		(struct rt_list *)stp->st_specific; */
d1435 1
a1435 1
rt_pipe_free( stp )
d1438 2
a1439 2
	register struct rt_list *pipe =
		(struct rt_list *)stp->st_specific;
d1442 1
a1442 1
	while( RT_LIST_NON_EMPTY( &pipe->id.l ) )
d1444 1
a1444 1
		register struct rt_list *pipe_ptr;
d1446 2
a1447 2
		pipe_ptr = (struct rt_list *)(&pipe->id.l)->forw;
		rt_free( (char *)pipe_ptr, "pipe_specific" );
d1451 1
a1451 1
	rt_free( (char *)pipe, "pipe_specific head" );
d1459 1
a1459 1
rt_pipe_class()
d1475 1
a1475 1
struct rt_list		*vhead;
d1498 1
a1498 1
		delta_ang = 2.0*rt_pi/seg_count;
d1523 1
a1523 1
struct rt_list			*vhead;
d1571 1
a1571 1
struct rt_list			*vhead;
d1591 1
a1591 1
	mat_arb_rot( mat, center, tmp_norm, angle );
d1666 2
a1667 2
rt_pipe_plot( vhead, ip, ttol, tol )
struct rt_list		*vhead;
d1670 1
a1670 1
struct rt_tol		*tol;
d1675 1
a1675 1
	LOCAL struct rt_pipe_internal		*pip;
d1683 1
a1683 1
	pip = (struct rt_pipe_internal *)ip->idb_ptr;
d1686 1
a1686 1
	if( RT_LIST_IS_EMPTY( &pip->pipe_segs_head ) )
d1689 3
a1691 3
	prevp = RT_LIST_FIRST( wdb_pipept, &pip->pipe_segs_head );
	curp = RT_LIST_NEXT( wdb_pipept, &prevp->l );
	nextp = RT_LIST_NEXT( wdb_pipept, &curp->l );
d1693 1
a1693 1
	if( RT_LIST_IS_HEAD( &curp->l , &pip->pipe_segs_head ) )
d1696 1
a1696 1
	delta_ang = 2.0*rt_pi/ARC_SEGS;
d1704 1
a1704 1
	mat_vec_ortho( f1, f3 );
d1718 1
a1718 1
		if( RT_LIST_IS_HEAD( &nextp->l, &pip->pipe_segs_head ) )
d1756 1
a1756 1
			angle = rt_pi - acos( VDOT( n1, n2 ) );
d1777 1
a1777 1
		nextp = RT_LIST_NEXT( wdb_pipept, &curp->l );
d1797 1
a1797 1
struct rt_tol *tol;
d1812 1
a1812 1
	RT_CK_TOL( tol );
d1814 1
a1814 1
	next = RT_LIST_NEXT( wdb_pipept, &pipe->l );
d1818 1
a1818 1
	mat_vec_ortho( r1, n );
d1829 1
a1829 1
		rt_log( "Inner radius larger than outer radius at start of pipe solid\n" );
d1842 2
a1843 2
	lu = RT_LIST_FIRST( loopuse, &fu->lu_hd );
	for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d1862 1
a1862 1
		vu = RT_LIST_FIRST( vertexuse, &lu->down_hd );
d1890 1
a1890 1
		vu = RT_LIST_FIRST( vertexuse, &lu->down_hd );
d1898 1
a1898 1
	for( RT_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
d1902 1
a1902 1
		if( RT_LIST_FIRST_MAGIC(&lu->down_hd) != NMG_EDGEUSE_MAGIC )
d1905 1
a1905 1
		for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d1926 1
a1926 1
struct rt_tol *tol;
d1940 1
a1940 1
	RT_CK_TOL( tol );
d1942 1
a1942 1
	norms = (vect_t *)rt_calloc( arc_segs, sizeof( vect_t ), "tesselate_pipe_linear: new normals" );
d1945 1
a1945 1
		new_outer_loop = (struct vertex **)rt_calloc( arc_segs, sizeof( struct vertex *),
d1949 1
a1949 1
		new_inner_loop = (struct vertex **)rt_calloc( arc_segs, sizeof( struct vertex *),
d1992 1
a1992 1
					rt_log( "tesselate_pipe_linear: nmg_calc_face_g failed\n" );
d2006 1
a2006 1
					lu = RT_LIST_FIRST( loopuse, &fu_prev->lu_hd );
d2008 1
a2008 1
					for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d2013 1
a2013 1
						eu_opp_use = RT_LIST_PNEXT_CIRC( edgeuse, &eu->eumate_p->l );
d2040 2
a2041 2
							rt_log( "No vu_normal assigned at (%g %g %g)\n", V3ARGS( eu->vu_p->v_p->vg_p->coord ) );
							rt_log( "\ti=%d, arc_segs=%d, fu_prev = x%x\n" , i, arc_segs, fu_prev );
d2053 1
a2053 1
				rt_log( "tesselate_pipe_linear: failed to make outer face #%d or=%g, end_or=%g\n",
d2062 1
a2062 1
				rt_log( "tesselate_pipe_linear: nmg_calc_face_g failed\n" );
d2076 1
a2076 1
				lu = RT_LIST_FIRST( loopuse, &fu->lu_hd );
d2078 1
a2078 1
				for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d2083 1
a2083 1
					eu_opp_use = RT_LIST_PNEXT_CIRC( edgeuse, &eu->eumate_p->l );
d2110 2
a2111 2
						rt_log( "No vu_normal assigned at (%g %g %g)\n", V3ARGS( eu->vu_p->v_p->vg_p->coord ) );
						rt_log( "\ti=%d, arc_segs=%d, fu = x%x\n" , i, arc_segs, fu );
d2121 1
a2121 1
				rt_log( "tesselate_pipe_linear: failed to make outer face #%d or=%g, end_or=%g\n",
d2129 1
a2129 1
					rt_log( "tesselate_pipe_linear: nmg_calc_face_g failed\n" );
d2134 1
a2134 1
		rt_free( (char *)(*outer_loop), "tesselate_pipe_bend: outer_loop" );
d2156 1
a2156 1
				rt_log( "tesselate_pipe_linear: failed to make outer face #%d or=%g, end_or=%g\n",
d2172 1
a2172 1
				rt_log( "tesselate_pipe_linear: nmg_calc_face_g failed\n" );
d2186 2
a2187 2
				lu = RT_LIST_FIRST( loopuse, &fu->lu_hd );
				for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d2189 1
a2189 1
					eu_opp_use = RT_LIST_PNEXT_CIRC( edgeuse, &eu->eumate_p->l );
d2213 2
a2214 2
						rt_log( "No vu_normal assigned at (%g %g %g)\n", V3ARGS( eu->vu_p->v_p->vg_p->coord ) );
						rt_log( "\ti=%d, j=%d, arc_segs=%d, fu = x%x\n" , i,j, arc_segs, fu );
d2220 1
a2220 1
		rt_free( (char *)(*outer_loop), "tesselate_pipe_linear: outer_loop" );
d2261 1
a2261 1
				rt_log( "tesselate_pipe_linear: failed to make outer face #%d or=%g, end_or=%g\n",
d2273 1
a2273 1
				rt_log( "tesselate_pipe_linear: nmg_calc_face_g failed\n" );
d2287 2
a2288 2
				lu = RT_LIST_FIRST( loopuse, &fu->lu_hd );
				for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d2290 1
a2290 1
					eu_opp_use = RT_LIST_PNEXT_CIRC( edgeuse, &eu->eumate_p->l );
d2314 2
a2315 2
						rt_log( "No vu_normal assigned at (%g %g %g)\n", V3ARGS( eu->vu_p->v_p->vg_p->coord ) );
						rt_log( "\ti=%d, j=%d, arc_segs=%d, fu = x%x\n" , i,j, arc_segs, fu );
d2320 1
a2320 1
		rt_free( (char *)(*outer_loop), "tesselate_pipe_linear: outer_loop" );
d2361 1
a2361 1
					rt_log( "tesselate_pipe_linear: nmg_calc_face_g failed\n" );
d2375 1
a2375 1
					lu = RT_LIST_FIRST( loopuse, &fu_prev->lu_hd );
d2377 1
a2377 1
					for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d2382 1
a2382 1
						eu_opp_use = RT_LIST_PNEXT_CIRC( edgeuse, &eu->eumate_p->l );
d2409 2
a2410 2
							rt_log( "No vu_normal assigned at (%g %g %g)\n", V3ARGS( eu->vu_p->v_p->vg_p->coord ) );
							rt_log( "\ti=%d, arc_segs=%d, fu_prev = x%x\n" , i, arc_segs, fu_prev );
d2422 1
a2422 1
				rt_log( "tesselate_pipe_linear: failed to make inner face #%d ir=%g, end_ir=%g\n",
d2431 1
a2431 1
				rt_log( "tesselate_pipe_linear: nmg_calc_face_g failed\n" );
d2445 1
a2445 1
				lu = RT_LIST_FIRST( loopuse, &fu->lu_hd );
d2447 1
a2447 1
				for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d2452 1
a2452 1
					eu_opp_use = RT_LIST_PNEXT_CIRC( edgeuse, &eu->eumate_p->l );
d2479 2
a2480 2
						rt_log( "No vu_normal assigned at (%g %g %g)\n", V3ARGS( eu->vu_p->v_p->vg_p->coord ) );
						rt_log( "\ti=%d, arc_segs=%d, fu = x%x\n" , i, arc_segs, fu );
d2494 1
a2494 1
				rt_log( "tesselate_pipe_linear: failed to make inner face #%d ir=%g, end_ir=%g\n",
d2502 1
a2502 1
					rt_log( "tesselate_pipe_linear: nmg_calc_face_g failed\n" );
d2508 1
a2508 1
		rt_free( (char *)(*inner_loop), "tesselate_pipe_bend: inner_loop" );
d2531 1
a2531 1
				rt_log( "tesselate_pipe_linear: failed to make inner face #%d ir=%g, end_ir=%g\n",
d2548 1
a2548 1
				rt_log( "tesselate_pipe_linear: nmg_calc_face_g failed\n" );
d2562 2
a2563 2
				lu = RT_LIST_FIRST( loopuse, &fu->lu_hd );
				for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d2565 1
a2565 1
					eu_opp_use = RT_LIST_PNEXT_CIRC( edgeuse, &eu->eumate_p->l );
d2589 2
a2590 2
						rt_log( "No vu_normal assigned at (%g %g %g)\n", V3ARGS( eu->vu_p->v_p->vg_p->coord ) );
						rt_log( "\ti=%d, j=%d, arc_segs=%d, fu = x%x\n" , i,j, arc_segs, fu );
d2596 1
a2596 1
		rt_free( (char *)(*inner_loop), "tesselate_pipe_linear: inner_loop" );
d2636 1
a2636 1
				rt_log( "tesselate_pipe_linear: failed to make inner face #%d ir=%g, end_ir=%g\n",
d2648 1
a2648 1
				rt_log( "tesselate_pipe_linear: nmg_calc_face_g failed\n" );
d2662 2
a2663 2
				lu = RT_LIST_FIRST( loopuse, &fu->lu_hd );
				for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d2665 1
a2665 1
					eu_opp_use = RT_LIST_PNEXT_CIRC( edgeuse, &eu->eumate_p->l );
d2689 2
a2690 2
						rt_log( "No vu_normal assigned at (%g %g %g)\n", V3ARGS( eu->vu_p->v_p->vg_p->coord ) );
						rt_log( "\ti=%d, j=%d, arc_segs=%d, fu = x%x\n" , i,j, arc_segs, fu );
d2695 1
a2695 1
		rt_free( (char *)(*inner_loop), "tesselate_pipe_linear: inner_loop" );
d2698 1
a2698 1
	rt_free( (char *)norms, "tesselate_linear_pipe: norms" );
d2714 1
a2714 1
struct rt_tol *tol;
d2748 1
a2748 1
	RT_CK_TOL( tol );
d2771 1
a2771 1
		bend_angle += 2.0*rt_pi;
d2798 1
a2798 1
	mat_arb_rot( rot, origin, bend_norm, delta_angle);
d2804 1
a2804 1
		new_outer_loop = (struct vertex **)rt_calloc( arc_segs, sizeof( struct vertex *),
d2834 1
a2834 1
				rt_log( "tesselate_pipe_bend(): nmg_cmface failed\n" );
d2842 1
a2842 1
				rt_log( "tesselate_pipe_bend: nmg_calc_face_g failed\n" );
d2854 2
a2855 2
				lu = RT_LIST_FIRST( loopuse, &fu->lu_hd );
				for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d2860 1
a2860 1
					eu_opp_use = RT_LIST_PNEXT_CIRC( edgeuse, &eu->eumate_p->l );
d2888 2
a2889 2
						rt_log( "No vu_normal assigned at (%g %g %g)\n", V3ARGS( eu->vu_p->v_p->vg_p->coord ) );
						rt_log( "\ti=%d, j=%d, arc_segs=%d, fu = x%x\n" , i,j, arc_segs, fu );
d2904 1
a2904 1
				rt_log( "tesselate_pipe_bend(): nmg_cmface failed\n" );
d2912 1
a2912 1
				rt_log( "tesselate_pipe_bend: nmg_calc_face_g failed\n" );
d2924 2
a2925 2
				lu = RT_LIST_FIRST( loopuse, &fu->lu_hd );
				for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d2930 1
a2930 1
					eu_opp_use = RT_LIST_PNEXT_CIRC( edgeuse, &eu->eumate_p->l );
d2958 2
a2959 2
						rt_log( "No vu_normal assigned at (%g %g %g)\n", V3ARGS( eu->vu_p->v_p->vg_p->coord ) );
						rt_log( "\ti=%d, j=%d, arc_segs=%d, fu = x%x\n" , i,j, arc_segs, fu );
d2965 1
a2965 1
		rt_free( (char *)(*outer_loop), "tesselate_pipe_bend: outer_loop" );
d2984 1
a2984 1
		new_inner_loop = (struct vertex **)rt_calloc( arc_segs, sizeof( struct vertex *),
d3014 1
a3014 1
				rt_log( "tesselate_pipe_bend(): nmg_cmface failed\n" );
d3022 1
a3022 1
				rt_log( "tesselate_pipe_bend: nmg_calc_face_g failed\n" );
d3034 2
a3035 2
				lu = RT_LIST_FIRST( loopuse, &fu->lu_hd );
				for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d3040 1
a3040 1
					eu_opp_use = RT_LIST_PNEXT_CIRC( edgeuse, &eu->eumate_p->l );
d3068 2
a3069 2
						rt_log( "No vu_normal assigned at (%g %g %g)\n", V3ARGS( eu->vu_p->v_p->vg_p->coord ) );
						rt_log( "\ti=%d, j=%d, arc_segs=%d, fu = x%x\n" , i,j, arc_segs, fu );
d3084 1
a3084 1
				rt_log( "tesselate_pipe_bend(): nmg_cmface failed\n" );
d3092 1
a3092 1
				rt_log( "tesselate_pipe_bend: nmg_calc_face_g failed\n" );
d3104 2
a3105 2
				lu = RT_LIST_FIRST( loopuse, &fu->lu_hd );
				for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d3110 1
a3110 1
					eu_opp_use = RT_LIST_PNEXT_CIRC( edgeuse, &eu->eumate_p->l );
d3138 2
a3139 2
						rt_log( "No vu_normal assigned at (%g %g %g)\n", V3ARGS( eu->vu_p->v_p->vg_p->coord ) );
						rt_log( "\ti=%d, j=%d, arc_segs=%d, fu = x%x\n" , i,j, arc_segs, fu );
d3144 1
a3144 1
		rt_free( (char *)(*inner_loop), "tesselate_pipe_bend: inner_loop" );
d3161 1
a3161 1
struct rt_tol *tol;
d3169 1
a3169 1
	RT_CK_TOL( tol );
d3179 1
a3179 1
		rt_log( "tesselate_pipe_end(): nmg_cface failed\n" );
d3185 1
a3185 1
		rt_log( "tesselate_pipe_end: nmg_calc_face_g failed\n" );
d3190 1
a3190 1
	prev = RT_LIST_PREV( wdb_pipept, &pipe->l );
d3197 1
a3197 1
		verts = (struct vertex **)rt_calloc( arc_segs, sizeof( struct vertex *),
d3204 1
a3204 1
		rt_free( (char *)verts, "tesselate_pipe_end: verts" );
d3213 1
a3213 1
		vu = RT_LIST_FIRST( vertexuse, &lu->down_hd );
d3218 1
a3218 1
	for( RT_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
d3224 1
a3224 1
		if( RT_LIST_FIRST_MAGIC(&lu->down_hd) != NMG_EDGEUSE_MAGIC )
d3227 1
a3227 1
		for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d3241 1
a3241 1
rt_pipe_tess( r, m, ip, ttol, tol )
d3246 1
a3246 1
struct rt_tol		*tol;
d3253 1
a3253 1
	struct rt_pipe_internal *pip;
d3270 1
a3270 1
	pip = (struct rt_pipe_internal *)ip->idb_ptr;
d3273 1
a3273 1
	RT_CK_TOL( tol );
d3279 1
a3279 1
	if( RT_LIST_IS_EMPTY( &pip->pipe_segs_head ) )
d3282 1
a3282 1
	pp1 = RT_LIST_FIRST( wdb_pipept, &pip->pipe_segs_head );
d3288 1
a3288 1
	for( RT_LIST_FOR( pp1, wdb_pipept, &pip->pipe_segs_head ) )
d3306 1
a3306 1
		tol_segs = ceil( rt_pi/acos( 1.0 - 2.0 * ttol->abs/max_diam) );
d3312 1
a3312 1
		tol_segs = ceil( rt_pi/acos( 1.0 - 2.0 * ttol->rel*pipe_size/max_diam) );
d3318 1
a3318 1
		tol_segs = ceil( rt_pi/ttol->norm );
d3324 1
a3324 1
	s = RT_LIST_FIRST(shell, &(*r)->s_hd);
d3326 4
a3329 4
	outer_loop = (struct vertex **)rt_calloc( arc_segs, sizeof( struct vertex *),
			"rt_pipe_tess: outer_loop" );
	inner_loop = (struct vertex **)rt_calloc( arc_segs, sizeof( struct vertex *),
			"rt_pipe_tess: inner_loop" );
d3331 1
a3331 1
	delta_angle = 2.0 * rt_pi / (double)arc_segs;
d3335 1
a3335 1
	pp1 = RT_LIST_FIRST( wdb_pipept, &(pip->pipe_segs_head) );
d3339 2
a3340 2
	pp2 = RT_LIST_NEXT( wdb_pipept, &pp1->l );
	if( RT_LIST_IS_HEAD( &pp2->l, &(pip->pipe_segs_head) ) )
d3342 2
a3343 2
	pp3 = RT_LIST_NEXT( wdb_pipept, &pp2->l );
	if( RT_LIST_IS_HEAD( &pp3->l ,  &(pip->pipe_segs_head) ) )
d3394 1
a3394 1
		angle = rt_pi - acos( VDOT( n1, n2 ) );
d3416 2
a3417 2
		pp3 = RT_LIST_NEXT( wdb_pipept, &pp3->l );
		if( RT_LIST_IS_HEAD( &pp3->l ,  &(pip->pipe_segs_head) ) )
d3423 2
a3424 2
	rt_free( (char *)outer_loop, "rt_pipe_tess: outer_loop" );
	rt_free( (char *)inner_loop, "rt_pipe_tess: inner_loop" );
d3435 1
a3435 1
rt_pipe_import( ip, ep, mat )
d3437 1
a3437 1
CONST struct rt_external	*ep;
d3443 1
a3443 1
	struct rt_pipe_internal		*pipe;
d3447 1
a3447 1
	RT_CK_EXTERNAL( ep );
d3451 1
a3451 1
		rt_log("rt_pipe_import: defective record\n");
d3457 2
a3458 2
	ip->idb_ptr = rt_malloc( sizeof(struct rt_pipe_internal), "rt_pipe_internal");
	pipe = (struct rt_pipe_internal *)ip->idb_ptr;
d3460 1
a3460 1
	pipe->pipe_count = rt_glong( rp->pwr.pwr_pt_count);
d3467 1
a3467 1
	RT_LIST_INIT( &pipe->pipe_segs_head );
d3475 1
a3475 1
		GETSTRUCT( ptp, wdb_pipept );
d3481 1
a3481 1
		RT_LIST_APPEND( &pipe->pipe_segs_head, &ptp->l );
d3491 2
a3492 2
rt_pipe_export( ep, ip, local2mm )
struct rt_external		*ep;
d3496 2
a3497 2
	struct rt_pipe_internal	*pip;
	struct rt_list		*headp;
d3508 1
a3508 1
	pip = (struct rt_pipe_internal *)ip->idb_ptr;
d3515 1
a3515 1
	for( RT_LIST_FOR( ppt, wdb_pipept, headp ) )
d3526 1
a3526 1
	RT_INIT_EXTERNAL(ep);
d3528 1
a3528 1
	ep->ext_buf = (genptr_t)rt_calloc( 1, ep->ext_nbytes, "pipe external");
d3532 2
a3533 2
	(void)rt_plong( rec->pwr.pwr_count, ngran-1 );	/* # EXTRA grans */
	(void)rt_plong( rec->pwr.pwr_pt_count, count );
d3537 1
a3537 1
	for( RT_LIST_FOR( ppt, wdb_pipept, headp ), epp++ )  {
d3560 2
a3561 2
rt_pipe_describe( str, ip, verbose, mm2local )
struct rt_vls		*str;
d3566 1
a3566 1
	register struct rt_pipe_internal	*pip;
d3572 1
a3572 1
	pip = (struct rt_pipe_internal *)ip->idb_ptr;
d3576 1
a3576 1
	rt_vls_strcat( str, buf );
d3582 1
a3582 1
	for( RT_LIST_FOR( ptp, wdb_pipept, &pip->pipe_segs_head ) )  {
d3584 1
a3584 1
		rt_vls_strcat( str, buf );
d3586 1
a3586 1
		rt_vls_strcat( str, buf );
d3588 1
a3588 1
		rt_vls_strcat( str, buf );
d3591 1
a3591 1
			rt_vls_strcat( str, buf );
d3593 1
a3593 1
		rt_vls_strcat( str, "\n" );
d3599 1
a3599 1
		rt_vls_strcat( str, buf );
d3612 1
a3612 1
rt_pipe_ifree( ip )
d3615 1
a3615 1
	register struct rt_pipe_internal	*pipe;
d3619 1
a3619 1
	pipe = (struct rt_pipe_internal*)ip->idb_ptr;
d3622 3
a3624 3
	while( RT_LIST_WHILE( ptp, wdb_pipept, &pipe->pipe_segs_head ) )  {
		RT_LIST_DEQUEUE( &(ptp->l) );
		rt_free( (char *)ptp, "wdb_pipept" );
d3626 1
a3626 1
	rt_free( ip->idb_ptr, "pipe ifree" );
d3640 1
a3640 1
rt_pipe_ck( headp )
d3649 1
a3649 1
	prev = RT_LIST_FIRST( wdb_pipept, &headp->l );
d3652 1
a3652 1
		rt_log( "Bend radius (%gmm) is less than outer radius at ( %g %g %g )\n",
d3656 3
a3658 3
	cur = RT_LIST_NEXT( wdb_pipept, &prev->l );
	next = RT_LIST_NEXT( wdb_pipept, &cur->l );
	while( RT_LIST_NOT_HEAD( &next->l, &headp->l ) )
d3666 1
a3666 1
			rt_log( "Bend radius (%gmm) is less than outer radius at ( %g %g %g )\n",
d3702 1
a3702 1
		angle = rt_pi - acos( VDOT( v1, v2 ) );
d3708 1
a3708 1
			rt_log( "Bend radii (%gmm) at ( %g %g %g ) and (%gmm) at ( %g %g %g ) are too large\n",
d3711 1
a3711 1
			rt_log( "for pipe segment between ( %g %g %g ) and ( %g %g %g )\n",
d3718 1
a3718 1
		next = RT_LIST_NEXT( wdb_pipept, &cur->l );
d3724 1
a3724 1
		rt_log( "last segment ( %g %g %g ) to ( %g %g %g ) is too short to allow\n",
d3726 1
a3726 1
		rt_log( "bend radius of %gmm\n", prev->pp_bendradius );
@


11.21
log
@rt_pipe_hitsort had a bug (infinite loop)
@
text
@d19 1
a19 1
static char RCSpipe[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pipe.c,v 11.20 1999/01/13 21:54:04 mike Exp $ (BRL)";
d1036 5
a1040 3
rt_pipe_hitsort( h, nh )
struct hit_list *h;
int *nh;
d1046 1
d1115 1
a1115 1
	if( *nh == 0 )
d1118 1
a1118 1
	/* look for overlaps */
d1120 15
a1136 3
		struct hit_list *third;
		struct hit_list *fourth;

d1140 2
a1141 1
		else
d1143 3
a1145 4
			third = RT_LIST_NEXT( hit_list, &second->l );
			if( RT_LIST_IS_HEAD( &third->l, &h->l ) )
				break;
			else
d1147 4
a1150 3
				fourth = RT_LIST_NEXT( hit_list, &third->l );
				if( RT_LIST_IS_HEAD( &fourth->l, &h->l ) )
					break;
d1153 2
a1154 2

		if( first->hitp->hit_surfno == second->hitp->hit_surfno )
d1156 9
a1164 2
			first = third;
			continue;
d1166 25
d1192 1
a1192 11
		if( first->hitp->hit_surfno == fourth->hitp->hit_surfno )
		{
			if( second->hitp->hit_surfno == third->hitp->hit_surfno )
			{
				/* "second" to "third" is entirely inside "first" to "fourth" */
				RT_LIST_DEQUEUE( &second->l );
				rt_free( (char *)second->hitp, "pipe_hitsort: hitp->hitp" );
				rt_free( (char *)second, "pipe_hitsort: hitp" );
				RT_LIST_DEQUEUE( &third->l );
				rt_free( (char *)third->hitp, "pipe_hitsort: hitp->hitp" );
				rt_free( (char *)third, "pipe_hitsort: hitp" );
d1194 3
a1196 4
				first = RT_LIST_NEXT( hit_list, &fourth->l );
				continue;
			}
		}
d1198 2
a1199 11
		if( first->hitp->hit_surfno == third->hitp->hit_surfno )
		{
			if( second->hitp->hit_surfno == fourth->hitp->hit_surfno )
			{
				/* segemnts overlap */
				RT_LIST_DEQUEUE( &second->l );
				rt_free( (char *)second->hitp, "pipe_hitsort: hitp->hitp" );
				rt_free( (char *)second, "pipe_hitsort: hitp" );
				RT_LIST_DEQUEUE( &third->l );
				rt_free( (char *)third->hitp, "pipe_hitsort: hitp->hitp" );
				rt_free( (char *)third, "pipe_hitsort: hitp" );
d1201 54
a1254 5
				first = RT_LIST_NEXT( hit_list, &fourth->l );
				continue;
			}
		}
		first = RT_LIST_NEXT( hit_list, &first->l );
d1320 5
a1324 1
	rt_pipe_hitsort( &hit_head, &total_hits );
a1389 88
}

/*
 *  			R T _ P I P E _ N O R M
 *  
 *  Given ONE ray distance, return the normal and entry/exit point.
 */
void
rt_pipe_norm( hitp, stp, rp )
register struct hit	*hitp;
struct soltab		*stp;
register struct xray	*rp;
{
	register struct rt_list		*pipe =
		(struct rt_list *)stp->st_specific;
	register struct id_pipe		*pipe_id;
	register struct lin_pipe	*pipe_lin;
	register struct bend_pipe	*pipe_bend;
	LOCAL fastf_t	w;
	LOCAL vect_t	work;
	LOCAL vect_t	work1;
	LOCAL int	segno;
	LOCAL int	i;

	segno = hitp->hit_surfno/10;

	pipe_id = RT_LIST_FIRST( id_pipe, pipe );
	for( i=1 ; i<segno ; i++ )
		pipe_id = RT_LIST_NEXT( id_pipe, &pipe_id->l );

	pipe_lin = (struct lin_pipe *)pipe_id;
	pipe_bend = (struct bend_pipe *)pipe_id;

	VJOIN1( hitp->hit_point, rp->r_pt, hitp->hit_dist, rp->r_dir );
	switch( hitp->hit_surfno%10 )
	{
		case PIPE_LINEAR_TOP:
			VMOVE( hitp->hit_normal, pipe_lin->pipe_H );
			break;
		case PIPE_LINEAR_BASE:
			VREVERSE( hitp->hit_normal, pipe_lin->pipe_H );
			break;
		case PIPE_LINEAR_OUTER_BODY:
			MAT4X3VEC( hitp->hit_normal, pipe_lin->pipe_invRoS, hitp->hit_vpriv );
			VUNITIZE( hitp->hit_normal );
			break;
		case PIPE_LINEAR_INNER_BODY:
			MAT4X3VEC( hitp->hit_normal, pipe_lin->pipe_invRoS, hitp->hit_vpriv );
			VUNITIZE( hitp->hit_normal );
			VREVERSE( hitp->hit_normal, hitp->hit_normal );
			break;
		case PIPE_BEND_OUTER_BODY:
			w = hitp->hit_vpriv[X]*hitp->hit_vpriv[X] +
			    hitp->hit_vpriv[Y]*hitp->hit_vpriv[Y] +
			    hitp->hit_vpriv[Z]*hitp->hit_vpriv[Z] +
			    1.0 - pipe_bend->bend_alpha_o*pipe_bend->bend_alpha_o;
			VSET( work,
				( w - 2.0 ) * hitp->hit_vpriv[X],
				( w - 2.0 ) * hitp->hit_vpriv[Y],
				  w * hitp->hit_vpriv[Z] );
			VUNITIZE( work );
			MAT3X3VEC( hitp->hit_normal, pipe_bend->bend_invR, work );
			break;
		case PIPE_BEND_INNER_BODY:
			w = hitp->hit_vpriv[X]*hitp->hit_vpriv[X] +
			    hitp->hit_vpriv[Y]*hitp->hit_vpriv[Y] +
			    hitp->hit_vpriv[Z]*hitp->hit_vpriv[Z] +
			    1.0 - pipe_bend->bend_alpha_o*pipe_bend->bend_alpha_o;
			VSET( work,
				( w - 2.0 ) * hitp->hit_vpriv[X],
				( w - 2.0 ) * hitp->hit_vpriv[Y],
				  w * hitp->hit_vpriv[Z] );
			VUNITIZE( work );
			MAT3X3VEC( work1, pipe_bend->bend_invR, work );
			VREVERSE( hitp->hit_normal, work1 );
			break;
		case PIPE_BEND_BASE:
			VREVERSE( hitp->hit_normal, pipe_bend->bend_rb );
			break;
		case PIPE_BEND_TOP:
			VSUB2( work, pipe_bend->bend_end, pipe_bend->bend_V );
			VCROSS( hitp->hit_normal, pipe_bend->bend_N, work );
			VUNITIZE( hitp->hit_normal );
			break;
		default:
			rt_log( "rt_pipe_norm: Unrecognized surfno (%d)\n", hitp->hit_surfno );
			break;
	}
@


11.20
log
@Fixed htond() arg types
@
text
@d19 1
a19 1
static char RCSpipe[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pipe.c,v 11.19 1998/07/02 20:52:39 jra Exp $ (BRL)";
d1177 1
@


11.19
log
@corrected code that eliminates duplicate hits.
Added code to handle some self overlaps.
@
text
@d19 1
a19 1
static char RCSpipe[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_pipe.c,v 11.18 1996/11/19 20:25:47 jra Exp $ (BRL)";
d3475 4
a3478 4
		ntohd( &tmp.pp_id, exp->epp_id, 1 );
		ntohd( &tmp.pp_od, exp->epp_od, 1 );
		ntohd( &tmp.pp_bendradius, exp->epp_bendradius, 1 );
		ntohd( tmp.pp_coord, exp->epp_coord, 3 );
d3549 4
a3552 4
		htond( epp->epp_coord, tmp.pp_coord, 3 );
		htond( epp->epp_id, &tmp.pp_id, 1 );
		htond( epp->epp_od, &tmp.pp_od, 1 );
		htond( epp->epp_bendradius, &tmp.pp_bendradius, 1 );
@


11.18
log
@Fixed a bug in rt_pipe_shot().
@
text
@d19 1
a19 1
static char RCSpipe[] = "@@(#)$Header: /m/cad/librt/RCS/g_pipe.c,v 11.17 1996/08/31 10:54:03 mike Exp jra $ (BRL)";
d1042 2
d1084 2
a1085 1
		if( NEAR_ZERO( hitp->hitp->hit_dist - next_hit->hitp->hit_dist, 0.00001  ) )
d1109 68
@


11.17
log
@bn.h
@
text
@d19 1
a19 1
static char RCSpipe[] = "@@(#)$Header: /m/cad/librt/RCS/g_pipe.c,v 11.16 1995/08/23 19:02:59 jra Exp mike $ (BRL)";
a362 2
			curr_id = pp2->pp_id;
			curr_od = pp2->pp_od;
d383 1
a383 1
			v1, v2, curr_od, curr_id );
d386 1
a388 1
next_pt:
@


11.16
log
@Finished conversion to new pipe solid format.
@
text
@d19 1
a19 1
static char RCSpipe[] = "@@(#)$Header: /m/cad/librt/RCS/g_pipe.c,v 11.15 1995/08/17 21:37:12 jra Exp jra $ (BRL)";
d498 1
a498 1
	LOCAL complex	val[MAXP];	/* The complex roots */
@


11.15
log
@Converted to new format pipe solid.
@
text
@d19 1
a19 1
static char RCSpipe[] = "@@(#)$Header: /m/cad/librt/RCS/g_pipe.c,v 11.14 1995/07/28 19:20:29 jra Exp jra $ (BRL)";
d104 1
a104 1
int
d196 1
a196 1
void
a212 1
	LOCAL point_t top;
d271 1
a271 2
	VJOIN1( top, pt1, pipe->pipe_len, seg_ht );
	VJOIN2( work, top, od1, v1, od1, v2 );
d273 1
a273 1
	VJOIN2( work, top, -od1, v1, od1, v2 );
d275 1
a275 1
	VJOIN2( work, top, od1, v1, -od1, v2 );
d277 1
a277 1
	VJOIN2( work, top, -od1, v1, -od1, v2 );
d482 1
a482 1
void
d715 1
a715 1
void
d865 1
a865 1
void
d946 2
a947 1
void
d1410 1
a1410 1
static void
d1458 1
a1458 1
static void
d1506 1
a1506 1
static void
d1724 1
a1724 1
void
d1850 1
a1850 1
void
d1870 1
a1870 2
	vect_t norm;
	vect_t reverse_norm;
d1872 3
a1874 1
	int i;
d1879 1
d1889 5
d1901 1
a1901 1
		x = end_or;
d1903 3
d1908 5
a1912 1
			VJOIN2( pt, end_pt, x, r1, y, r2 );
d1917 6
d1932 50
d1984 1
a1984 4
			if( i == arc_segs-1 )
				verts[0] = &(*outer_loop)[0];
			else
				verts[0] = &(*outer_loop)[i+1];
a1985 1

d2002 50
d2054 2
a2055 4
			if( i == arc_segs-1 )
				verts[2] = &new_outer_loop[0];
			else
				verts[2] = &new_outer_loop[i+1];
a2069 1

d2078 3
d2083 5
a2088 5
			if( i == arc_segs-1 )
				verts[0] = &(*outer_loop)[0];
			else
				verts[0] = &(*outer_loop)[i+1];

d2099 8
d2112 43
d2166 2
a2167 1
		x = end_or;
d2169 4
a2172 1
		VJOIN2( pt_next, end_pt, x, r1, y, r2 );
d2175 4
d2184 7
a2190 1
			VJOIN2( pt_next, start_pt, x, r1, y, r2 );
d2194 1
a2194 4
			if( i == arc_segs-1 )
				verts[2] = &new_outer_loop[0];
			else
				verts[2] = &new_outer_loop[i+1];
d2202 2
d2206 2
a2207 2
			if( i+1 < arc_segs-1 && !new_outer_loop[i+1]->vg_p )
				nmg_vertex_gv( new_outer_loop[i+1], pt_next );
d2213 43
a2255 1
			
d2261 2
d2270 1
a2270 1
		x = end_ir;
d2272 3
d2277 5
a2281 1
			VJOIN2( pt, end_pt, x, r1, y, r2 );
d2286 6
d2301 50
d2353 1
a2353 4
			if( i == arc_segs-1 )
				verts[0] = &(*inner_loop)[0];
			else
				verts[0] = &(*inner_loop)[i+1];
a2354 1

d2371 50
d2428 1
a2428 1
				verts[2] = &new_inner_loop[i+1];
d2452 4
d2458 4
d2463 1
a2463 5
			if( i == arc_segs-1 )
				verts[1] = &(*inner_loop)[0];
			else
				verts[1] = &(*inner_loop)[i+1];

d2474 9
d2488 43
d2542 1
a2542 1
		x = end_ir;
d2544 4
a2547 1
		VJOIN2( pt_next, end_pt, x, r1, y, r2 );
d2550 4
d2559 7
a2565 1
			VJOIN2( pt_next, end_pt, x, r1, y, r2 );
d2567 2
a2569 5
			verts[1] = &new_inner_loop[i];
			if( i == arc_segs-1 )
				verts[0] = &new_inner_loop[0];
			else
				verts[0] = &new_inner_loop[i+1];
d2577 1
a2577 1
			if( i == 0 )
d2581 2
a2582 2
			if( i+1 < arc_segs && !new_inner_loop[i+1]->vg_p )
				nmg_vertex_gv( new_inner_loop[i+1], pt_next );
d2588 43
a2630 1
			
d2635 1
d2638 1
a2638 1
void
d2675 1
d2678 1
d2682 1
a2682 1
	int i;
d2719 1
a2719 1
		tol_segs = ceil( (fastf_t)(arc_segs)*bend_angle/2.0*rt_pi );
d2737 1
a2737 1
	VMOVE( center, bend_start )
d2749 1
a2749 1
		VSUB2( r1_tmp, center, bend_center )
d2761 5
a2765 4
			if( i == arc_segs-1 )
				verts[0] = &(*outer_loop)[0];
			else
				verts[0] = &(*outer_loop)[i+1];
d2782 48
d2837 1
a2837 4
			if( i == arc_segs-1 )
				verts[2] = &new_outer_loop[0];
			else
				verts[2] = &new_outer_loop[i+1];
d2852 4
d2857 43
d2904 1
d2917 1
a2917 1
	VMOVE( center, bend_start )
d2929 1
a2929 1
		VSUB2( r1_tmp, center, bend_center )
d2941 4
d2946 1
a2946 4
			if( i == arc_segs-1 )
				verts[1] = &(*inner_loop)[0];
			else
				verts[1] = &(*inner_loop)[i+1];
d2962 48
d3017 1
a3017 4
			if( i == arc_segs-1 )
				verts[2] = &new_inner_loop[0];
			else
				verts[2] = &new_inner_loop[i+1];
d3032 13
d3046 34
d3083 1
d3089 1
a3089 1
void
@


11.14
log
@Checkpoint (converting to new pipe solid).
@
text
@d19 1
a19 1
static char RCSpipe[] = "@@(#)$Header: /m/cad/librt/RCS/g_pipe.c,v 11.13 1995/07/18 02:36:58 mike Exp jra $ (BRL)";
d37 42
a78 42
union pipe_specific {
	struct pipe_id
	{
		struct rt_list l;
		int	pipe_type;
	} id;
	struct lin_pipe
	{
		struct rt_list l;
		int	pipe_type;
		vect_t	pipe_V;			/* start point for pipe section */
		vect_t	pipe_H;			/* unit vector in direction of pipe section */
		fastf_t pipe_ribase, pipe_ritop;	/* base and top inner radii */
		fastf_t pipe_ribase_sq, pipe_ritop_sq;	/* inner radii squared */
		fastf_t pipe_ridiff_sq, pipe_ridiff;	/* difference between top and base inner radii */
		fastf_t pipe_rodiff_sq, pipe_rodiff;	/* difference between top and base outer radii */
		fastf_t pipe_robase, pipe_rotop;	/* base and top outer radii */
		fastf_t pipe_robase_sq, pipe_rotop_sq;	/* outer radii squared */
		fastf_t	pipe_len;			/* length of pipe segment */
		mat_t	pipe_SoR;	/* Scale and rotate */
		mat_t	pipe_invRoS;	/* inverse rotation and scale */
	} lin;
	struct bend_pipe
	{
		struct rt_list l;
		int	pipe_type;
		fastf_t	bend_radius;		/* distance from bend_v to center of pipe */
		fastf_t	bend_or;		/* outer radius */
		fastf_t	bend_ir;		/* inner radius */
		mat_t	bend_invR;		/* inverse rotation matrix */
		mat_t	bend_SoR;		/* Scale and rotate */
		point_t	bend_V;			/* Center of bend */
		point_t	bend_start;		/* Start of bend */
		point_t	bend_end;		/* End of bend */
		fastf_t	bend_alpha_i;		/* ratio of inner radius to bend radius */
		fastf_t	bend_alpha_o;		/* ratio of outer radius to bend radius */
		fastf_t	bend_angle;		/* Angle that bend goes through */
		vect_t	bend_ra;		/* unit vector in plane of bend (points toward start from bend_V) */
		vect_t	bend_rb;		/* unit vector in plane of bend (normal to bend_ra) */
		vect_t	bend_N;			/* unit vector normal to plane of bend */
		fastf_t	bend_R_SQ;		/* bounding sphere radius squared */
	} bend;
d81 1
d103 1
a103 1
#if 0
d105 1
a105 1
rt_bend_pipe_prep( stp, pipe_seg, head )
d107 8
a114 2
struct wdb_pipeseg	*pipe_seg;
union pipe_specific	*head;
d116 1
a116 2
	register union pipe_specific *pipe;
	register struct wdb_pipeseg *next_seg;
d125 2
a126 8
	if( pipe_seg->ps_type != WDB_PIPESEG_TYPE_BEND )
	{
		rt_log( "rt_bend_pipe_prep called for non-bend segment (type=%d)\n", pipe_seg->ps_type );
		return( 1 );
	}

	pipe = (union pipe_specific *)rt_malloc( sizeof( union pipe_specific ), "rt_bend_pipe_prep:pipe" )	 ;
	RT_LIST_INSERT( &head->id.l, &pipe->id.l );
a127 1
	next_seg = RT_LIST_PNEXT( wdb_pipeseg, pipe_seg );
d129 14
a142 14
	pipe->id.pipe_type = WDB_PIPESEG_TYPE_BEND;
	pipe->bend.bend_or = pipe_seg->ps_od * 0.5;
	pipe->bend.bend_ir = pipe_seg->ps_id * 0.5;

	VMOVE( pipe->bend.bend_start, pipe_seg->ps_start );
	VMOVE( pipe->bend.bend_end, next_seg->ps_start );
	VMOVE( pipe->bend.bend_V, pipe_seg->ps_bendcenter );
	VSUB2( to_start, pipe_seg->ps_start, pipe_seg->ps_bendcenter );
	pipe->bend.bend_radius = MAGNITUDE( to_start );
	VSUB2( to_end, next_seg->ps_start, pipe_seg->ps_bendcenter );
	VSCALE( pipe->bend.bend_ra, to_start, 1.0/pipe->bend.bend_radius );
	VCROSS( pipe->bend.bend_N, to_start, to_end );
	VUNITIZE( pipe->bend.bend_N );
	VCROSS( pipe->bend.bend_rb, pipe->bend.bend_N, pipe->bend.bend_ra );
d144 1
a144 1
	pipe->bend.bend_angle = atan2( VDOT( to_end, pipe->bend.bend_rb ), VDOT( to_end, pipe->bend.bend_ra ) );
d147 1
a147 4
	if( pipe->bend.bend_angle < 0.0 )
		pipe->bend.bend_angle += 2.0 * M_PI;

	if( pipe->bend.bend_angle >= M_PI )
d153 2
a154 2
	pipe->bend.bend_alpha_i = pipe->bend.bend_ir/pipe->bend.bend_radius;
	pipe->bend.bend_alpha_o = pipe->bend.bend_or/pipe->bend.bend_radius;
d156 2
a157 2
	pipe->bend.bend_R_SQ = (pipe->bend.bend_radius + pipe->bend.bend_or) *
				(pipe->bend.bend_radius + pipe->bend.bend_or);
d160 6
a165 6
	VMOVE( &R[0], pipe->bend.bend_ra );
	VMOVE( &R[4], pipe->bend.bend_rb );
	VMOVE( &R[8], pipe->bend.bend_N );
	mat_inv( pipe->bend.bend_invR, R );
	mat_copy( pipe->bend.bend_SoR, R );
	pipe->bend.bend_SoR[15] *= pipe->bend.bend_radius;
d170 4
a173 4
	VCROSS( work, pipe->bend.bend_N, tmp_vec );
	f = pipe->bend.bend_or + pipe->bend.bend_radius * MAGNITUDE(work);
	tmp_pt_min[X] = pipe->bend.bend_V[X] - f;
	tmp_pt_max[X] = pipe->bend.bend_V[X] + f;
d177 4
a180 4
	VCROSS( work, pipe->bend.bend_N, tmp_vec );
	f = pipe->bend.bend_or + pipe->bend.bend_radius * MAGNITUDE(work);
	tmp_pt_min[Y] = pipe->bend.bend_V[Y] - f;
	tmp_pt_max[Y] = pipe->bend.bend_V[Y] + f;
d184 4
a187 4
	VCROSS( work, pipe->bend.bend_N, tmp_vec );
	f = pipe->bend.bend_or + pipe->bend.bend_radius * MAGNITUDE(work);
	tmp_pt_min[Z] = pipe->bend.bend_V[Z] - f;
	tmp_pt_max[Z] = pipe->bend.bend_V[Z] + f;
d197 9
a205 4
rt_linear_pipe_prep( stp, pipe_seg, head )
struct soltab		*stp;
struct wdb_pipeseg	*pipe_seg;
union pipe_specific	*head;
d208 1
a208 2
	register union pipe_specific *pipe;
	register struct wdb_pipeseg *next_seg;
d217 2
a218 2
	pipe = (union pipe_specific *)rt_malloc( sizeof( union pipe_specific ), "rt_bend_pipe_prep:pipe" );
	RT_LIST_INSERT( &head->id.l, &pipe->id.l );
a219 1
	next_seg = RT_LIST_PNEXT( wdb_pipeseg, pipe_seg );
d221 1
a221 1
	VMOVE( pipe->lin.pipe_V, pipe_seg->ps_start );
d223 18
a240 18
	VSUB2( seg_ht, next_seg->ps_start, pipe_seg->ps_start );
	pipe->lin.pipe_ribase = pipe_seg->ps_id/2.0;
	pipe->lin.pipe_ribase_sq = pipe->lin.pipe_ribase * pipe->lin.pipe_ribase;
	pipe->lin.pipe_ritop = next_seg->ps_id/2.0;
	pipe->lin.pipe_ritop_sq = pipe->lin.pipe_ritop * pipe->lin.pipe_ritop;
	pipe->lin.pipe_robase = pipe_seg->ps_od/2.0;
	pipe->lin.pipe_robase_sq = pipe->lin.pipe_robase * pipe->lin.pipe_robase;
	pipe->lin.pipe_rotop = next_seg->ps_od/2.0;
	pipe->lin.pipe_rotop_sq = pipe->lin.pipe_rotop * pipe->lin.pipe_rotop;
	pipe->lin.pipe_ridiff = pipe->lin.pipe_ritop - pipe->lin.pipe_ribase;
	pipe->lin.pipe_ridiff_sq = pipe->lin.pipe_ridiff * pipe->lin.pipe_ridiff;
	pipe->lin.pipe_rodiff = pipe->lin.pipe_rotop - pipe->lin.pipe_robase;
	pipe->lin.pipe_rodiff_sq = pipe->lin.pipe_rodiff * pipe->lin.pipe_rodiff;
	pipe->lin.pipe_type = pipe_seg->ps_type;

	pipe->lin.pipe_len = MAGNITUDE( seg_ht );
	VSCALE( seg_ht, seg_ht, 1.0/pipe->lin.pipe_len );
	VMOVE( pipe->lin.pipe_H, seg_ht );
d255 1
a255 1
	S[10] = 1.0/pipe->lin.pipe_len;
d258 2
a259 2
	mat_mul( pipe->lin.pipe_SoR, S, R );
	mat_mul( pipe->lin.pipe_invRoS, Rinv, S );
d263 11
a273 1
	VJOIN2( work, pipe_seg->ps_start, pipe_seg->ps_od, v1, pipe_seg->ps_od, v2 );
d275 1
a275 1
	VJOIN2( work, pipe_seg->ps_start, -pipe_seg->ps_od, v1, pipe_seg->ps_od, v2 );
d277 1
a277 1
	VJOIN2( work, pipe_seg->ps_start, pipe_seg->ps_od, v1, -pipe_seg->ps_od, v2 );
d279 1
a279 1
	VJOIN2( work, pipe_seg->ps_start, -pipe_seg->ps_od, v1, -pipe_seg->ps_od, v2 );
a281 12
	if( next_seg->ps_type == WDB_PIPESEG_TYPE_END )
	{
		VJOIN1( top, pipe_seg->ps_start, pipe->lin.pipe_len, seg_ht );
		VJOIN2( work, top, pipe_seg->ps_od, v1, pipe_seg->ps_od, v2 );
		PIPE_MM( work )
		VJOIN2( work, top, -pipe_seg->ps_od, v1, pipe_seg->ps_od, v2 );
		PIPE_MM( work )
		VJOIN2( work, top, pipe_seg->ps_od, v1, -pipe_seg->ps_od, v2 );
		PIPE_MM( work )
		VJOIN2( work, top, -pipe_seg->ps_od, v1, -pipe_seg->ps_od, v2 );
		PIPE_MM( work )
	}
d283 1
a283 1
#endif
d296 1
a296 1
 *  	A union pipe_specific is created, and it's address is stored in
d305 1
a305 2
#if 0
	register union pipe_specific *head;
d307 4
a310 5
	struct wdb_pipeseg *pipe_seg;
	LOCAL fastf_t dx;
	LOCAL fastf_t dy;
	LOCAL fastf_t dz;
	LOCAL fastf_t f;
d316 1
a316 1
	head = (union pipe_specific *)rt_malloc( sizeof( union pipe_specific ), "rt_pipe_prep:head" );
d318 4
a321 1
	RT_LIST_INIT( &head->id.l );
d323 12
a334 2
	/* Compute bounding sphere and RPP */
	for( RT_LIST_FOR( pipe_seg, wdb_pipeseg, &(pip->pipe_segs_head) ) )
d336 24
a359 1
		switch( pipe_seg->ps_type )
d361 7
a367 7
			case WDB_PIPESEG_TYPE_END:
				break;
			case WDB_PIPESEG_TYPE_LINEAR:
				rt_linear_pipe_prep( stp, pipe_seg, head );
				break;
			case WDB_PIPESEG_TYPE_BEND:
				rt_bend_pipe_prep( stp, pipe_seg, head );
d369 29
a414 3
#else
	return( 1 );
#endif
d424 2
a425 2
/*	register union pipe_specific *pipe =
		(union pipe_specific *)stp->st_specific; */
a483 1
#if 0
d490 1
a490 1
union pipe_specific	*pipe;
d512 1
a512 1
	VSUB2( to_start, rp->r_pt, pipe->bend.bend_V );
d514 1
a514 1
	if( (MAGSQ( to_start ) - dist_to_pca*dist_to_pca) > pipe->bend.bend_R_SQ )
d521 1
a521 1
	MAT4X3VEC( dprime, pipe->bend.bend_SoR, rp->r_dir );
d524 2
a525 2
	VSUB2( work, rp->r_pt, pipe->bend.bend_V );
	MAT4X3VEC( pprime, pipe->bend.bend_SoR, work );
d566 1
a566 1
		  1.0 - pipe->bend.bend_alpha_o * pipe->bend.bend_alpha_o;
d615 1
a615 1
			dist = normalized_dist * pipe->bend.bend_radius;
d619 2
a620 2
			VSUB2( to_hit, hit_pt, pipe->bend.bend_V );
			angle = atan2( VDOT( to_hit, pipe->bend.bend_rb ), VDOT( to_hit, pipe->bend.bend_ra ) );
d622 2
a623 2
				angle += 2.0 * M_PI;
			if( angle <= pipe->bend.bend_angle )
d636 1
a636 1
	if( pipe->bend.bend_alpha_i <= 0.0 )
d641 1
a641 1
		  1.0 - pipe->bend.bend_alpha_i * pipe->bend.bend_alpha_i;
d690 1
a690 1
			dist = normalized_dist * pipe->bend.bend_radius;
d694 2
a695 2
			VSUB2( to_hit, hit_pt, pipe->bend.bend_V );
			angle = atan2( VDOT( to_hit, pipe->bend.bend_rb ), VDOT( to_hit, pipe->bend.bend_ra ) );
d697 2
a698 2
				angle += 2.0 * M_PI;
			if( angle <= pipe->bend.bend_angle )
d738 1
a738 1
	if( pipe->pipe_type != WDB_PIPESEG_TYPE_LINEAR )
d740 1
a740 1
		rt_log( "linear_pipe_shot called for pipe type %d\n" , pipe->pipe_type );
d873 1
a873 1
struct pipe_id		*pipe;
d888 1
a888 1
	if( pipe->pipe_type == WDB_PIPESEG_TYPE_LINEAR )
d917 1
a917 1
	else if( pipe->pipe_type == WDB_PIPESEG_TYPE_BEND )
d954 1
a954 1
struct pipe_id		*pipe;
d969 1
a969 1
	if( pipe->pipe_type == WDB_PIPESEG_TYPE_LINEAR )
d1000 1
a1000 1
	else if( pipe->pipe_type == WDB_PIPESEG_TYPE_BEND )
d1111 1
a1111 1
#endif
d1130 12
a1141 11
#if 0
	register union pipe_specific *head =
		(union pipe_specific *)stp->st_specific;
	register struct pipe_id *pipe;
	register struct seg *segp;
	LOCAL struct hit_list hit_head;
	LOCAL struct hit_list *hitp;
	LOCAL int hit_count;
	LOCAL int total_hits=0;
	LOCAL int seg_no=0;
	LOCAL int i;
d1145 1
a1145 1
	pipe_start_shot( stp, rp, ap, seghead, RT_LIST_FIRST( pipe_id, &(head->id.l)),
d1147 1
a1147 1
	for( RT_LIST_FOR( pipe, pipe_id, &(head->id.l) ) )
d1149 1
a1149 1
	pipe_end_shot( stp, rp, ap, seghead, RT_LIST_LAST( pipe_id, &(head->id.l)),
d1154 1
a1154 1
	for( RT_LIST_FOR( pipe, pipe_id, &(head->id.l) ) )
d1158 7
a1164 1
		switch( pipe->pipe_type )
d1166 3
a1168 14
			case WDB_PIPESEG_TYPE_LINEAR:
				linear_pipe_shot( stp, rp, ap, seghead, (struct lin_pipe *)pipe,
					&hit_head, &hit_count, seg_no );
				total_hits += hit_count;
				break;
			case WDB_PIPESEG_TYPE_BEND:
				bend_pipe_shot( stp, rp, ap, seghead, (struct bend_pipe *)pipe,
					&hit_head, &hit_count, seg_no );
				total_hits += hit_count;
				break;
			default:
				rt_log( "rt_pipe_shot: Bad pipe type (%d)\n", pipe->pipe_type );
				rt_bomb( "rt_pipe_shot\n" );
				break;
a1169 1

a1221 3
#else
	return( 0 );
#endif
d1253 5
a1257 2
	register union pipe_specific *pipe =
		(union pipe_specific *)stp->st_specific;
d1266 6
a1271 2
	for( i=0 ; i<segno ; i++ )
		pipe = (union pipe_specific *)((&pipe->id.l)->forw);
d1277 1
a1277 1
			VMOVE( hitp->hit_normal, pipe->lin.pipe_H );
d1280 1
a1280 1
			VREVERSE( hitp->hit_normal, pipe->lin.pipe_H );
d1283 1
a1283 1
			MAT4X3VEC( hitp->hit_normal, pipe->lin.pipe_invRoS, hitp->hit_vpriv );
d1287 1
a1287 1
			MAT4X3VEC( hitp->hit_normal, pipe->lin.pipe_invRoS, hitp->hit_vpriv );
d1295 1
a1295 1
			    1.0 - pipe->bend.bend_alpha_o*pipe->bend.bend_alpha_o;
d1301 1
a1301 1
			MAT3X3VEC( hitp->hit_normal, pipe->bend.bend_invR, work );
d1307 1
a1307 1
			    1.0 - pipe->bend.bend_alpha_o*pipe->bend.bend_alpha_o;
d1313 1
a1313 1
			MAT3X3VEC( work1, pipe->bend.bend_invR, work );
d1317 1
a1317 1
			VREVERSE( hitp->hit_normal, pipe->bend.bend_rb );
d1320 2
a1321 2
			VSUB2( work, pipe->bend.bend_end, pipe->bend.bend_V );
			VCROSS( hitp->hit_normal, pipe->bend.bend_N, work );
d1341 2
a1342 2
/*	register union pipe_specific *pipe =
		(union pipe_specific *)stp->st_specific; */
d1365 2
a1366 2
/*	register union pipe_specific *pipe =
		(union pipe_specific *)stp->st_specific; */
d1376 3
a1378 3
	register union pipe_specific *pipe =
		(union pipe_specific *)stp->st_specific;

d1382 1
a1382 1
		register union pipe_specific *pipe_ptr;
d1384 1
a1384 1
		pipe_ptr = (union pipe_specific *)(&pipe->id.l)->forw;
d1390 1
d1436 1
a1436 1
		delta_ang = 2.0*M_PI/seg_count;
d1634 1
a1634 1
	delta_ang = 2.0*M_PI/ARC_SEGS;
a1724 1
#if 0
d1727 1
a1727 1
struct wdb_pipeseg *pipe;
d1740 1
a1740 1
	struct wdb_pipeseg *next;
d1752 1
a1752 14
	next = RT_LIST_NEXT( wdb_pipeseg, &pipe->l );

	if( pipe->ps_type == WDB_PIPESEG_TYPE_LINEAR )
	{
		VSUB2( n, pipe->ps_start, next->ps_start );
		VUNITIZE( n );
		mat_vec_ortho( r1, n );
		VCROSS( r2, n, r1 );

	}
	else if( pipe->ps_type == WDB_PIPESEG_TYPE_BEND )
	{
		VSUB2( r1, pipe->ps_start, pipe->ps_bendcenter );
		VUNITIZE( r1 );
d1754 4
a1757 4
		VSUB2( n, next->ps_start, pipe->ps_bendcenter );
		VCROSS( r2, r1, n );
		VUNITIZE( r2 );
	}
d1759 2
a1760 2
	or = pipe->ps_od/2.0;
	ir = pipe->ps_id/2.0;
d1783 1
a1783 1
		VJOIN2( pt, pipe->ps_start, x, r1, y, r2 );
d1806 1
a1806 1
		VJOIN2( pt, pipe->ps_start, x, r1, y, r2 );
d1817 1
a1817 1
			VJOIN2( pt, pipe->ps_start, x, r1, y, r2 );
d1822 1
a1822 1
	else if( next->ps_id > tol->dist )
d1830 1
a1830 1
		nmg_vertex_gv( vu->v_p, pipe->ps_start );
d1852 5
a1856 2
tesselate_pipe_linear( pipe, arc_segs, sin_del, cos_del, outer_loop, inner_loop, r1, r2, s, tol )
struct wdb_pipeseg *pipe;
d1866 1
a1866 1
	struct wdb_pipeseg *next;
a1872 4
	fastf_t or;
	fastf_t next_or;
	fastf_t ir;
	fastf_t next_ir;
a1878 12
	if( pipe->ps_type != WDB_PIPESEG_TYPE_LINEAR )
	{
		rt_log( "tesselate_pipe_linear() called for wrong pipe type (%d)\n", pipe->ps_type );
		rt_bomb( "tesselate_pipe_linear()\n" );
	}

	next = RT_LIST_NEXT( wdb_pipeseg, &pipe->l );

	or = pipe->ps_od/2.0;
	ir = pipe->ps_id/2.0;
	next_or = next->ps_od/2.0;
	next_ir = next->ps_id/2.0;
d1880 1
a1880 1
	if( next_or > tol->dist )
d1884 1
a1884 1
	if( next_ir > tol->dist )
d1888 1
a1888 1
	if( or > tol->dist && next_or > tol->dist )
d1895 1
a1895 1
		x = next_or;
d1899 1
a1899 1
			VJOIN2( pt, next->ps_start, x, r1, y, r2 );
d1925 2
a1926 2
				rt_log( "tesselate_pipe_linear: failed to make outer face #%d or=%g, next_or=%g\n",
						i, or, next_or );
d1945 2
a1946 2
				rt_log( "tesselate_pipe_linear: failed to make outer face #%d or=%g, next_or=%g\n",
						i, or, next_or );
d1962 1
a1962 1
	else if( or > tol->dist && next_or <= tol->dist )
d1978 2
a1979 2
				rt_log( "tesselate_pipe_linear: failed to make outer face #%d or=%g, next_or=%g\n",
						i, or, next_or );
d1983 1
a1983 1
				nmg_vertex_gv( v, next->ps_start );
d1994 1
a1994 1
	else if( or <= tol->dist && next_or > tol->dist )
d2000 1
a2000 1
		x = or;
d2002 1
a2002 1
		VJOIN2( pt_next, pipe->ps_start, x, r1, y, r2 );
d2010 1
a2010 1
			VJOIN2( pt_next, pipe->ps_start, x, r1, y, r2 );
d2021 2
a2022 2
				rt_log( "tesselate_pipe_linear: failed to make outer face #%d or=%g, next_or=%g\n",
						i, or, next_or );
d2040 1
a2040 1
	if( ir > tol->dist && next_ir > tol->dist )
d2047 1
a2047 1
		x = next_ir;
d2051 1
a2051 1
			VJOIN2( pt, next->ps_start, x, r1, y, r2 );
d2077 2
a2078 2
				rt_log( "tesselate_pipe_linear: failed to make inner face #%d ir=%g, next_ir=%g\n",
						i, ir, next_ir );
d2099 2
a2100 2
				rt_log( "tesselate_pipe_linear: failed to make inner face #%d ir=%g, next_ir=%g\n",
						i, ir, next_ir );
d2116 1
a2116 1
	else if( ir > tol->dist && next_ir <= tol->dist )
d2132 2
a2133 2
				rt_log( "tesselate_pipe_linear: failed to make inner face #%d ir=%g, next_ir=%g\n",
						i, ir, next_ir );
d2137 1
a2137 1
				nmg_vertex_gv( v, next->ps_start );
d2148 1
a2148 1
	else if( ir <= tol->dist && next_ir > tol->dist )
d2154 1
a2154 1
		x = next_ir;
d2156 1
a2156 1
		VJOIN2( pt_next, next->ps_start, x, r1, y, r2 );
d2164 1
a2164 1
			VJOIN2( pt_next, next->ps_start, x, r1, y, r2 );
d2175 2
a2176 2
				rt_log( "tesselate_pipe_linear: failed to make inner face #%d ir=%g, next_ir=%g\n",
						i, ir, next_ir );
d2180 1
a2180 1
				nmg_vertex_gv( (*inner_loop)[0], pipe->ps_start );
d2198 5
a2202 2
tesselate_pipe_bend( pipe, arc_segs, sin_del, cos_del, outer_loop, inner_loop, start_r1, start_r2, s, tol, ttol )
struct wdb_pipeseg *pipe;
a2212 1
	struct wdb_pipeseg *next;
a2218 3
	fastf_t or;
	fastf_t ir;
	fastf_t x_bend,y_bend,x_bend_new,y_bend_new;
a2247 11
	if( pipe->ps_type != WDB_PIPESEG_TYPE_BEND )
	{
		rt_log( "tesselate_pipe_bend() called with wrong pipe segment type (%d)\n" , pipe->ps_type );
		rt_bomb( "tesselate_pipe_bend()\n" );
	}

	next = RT_LIST_NEXT( wdb_pipeseg, &pipe->l );

	or = pipe->ps_od/2.0;
	ir = pipe->ps_id/2.0;

d2251 1
a2251 1
	VSUB2( to_start, pipe->ps_start, pipe->ps_bendcenter );
d2256 1
a2256 1
	VSUB2( to_end, next->ps_start, pipe->ps_bendcenter );
d2265 1
a2265 1
		bend_angle += 2.0*M_PI;
d2276 1
a2276 1
		tol_segs = ceil( (fastf_t)(arc_segs)*bend_angle/2.0*M_PI );
d2294 1
a2294 3
	x_bend = 1.0;
	y_bend = 0.0;
	VMOVE( center, pipe->ps_start )
d2306 1
a2306 1
		VSUB2( r1_tmp, center, pipe->ps_bendcenter )
d2308 1
a2308 1
		VADD2( center, r2_tmp, pipe->ps_bendcenter )
a2365 3
		x_bend = x_bend_new;
		y_bend = y_bend_new;

d2380 1
a2380 3
	x_bend = 1.0;
	y_bend = 0.0;
	VMOVE( center, pipe->ps_start )
d2392 1
a2392 1
		VSUB2( r1_tmp, center, pipe->ps_bendcenter )
d2394 1
a2394 1
		VADD2( center, r2_tmp, pipe->ps_bendcenter )
a2450 2
		x_bend = x_bend_new;
		y_bend = y_bend_new;
d2460 1
a2460 1
struct wdb_pipeseg *pipe;
d2469 1
a2469 1
	struct wdb_pipeseg *prev;
d2477 1
a2477 1
	if( pipe->ps_od <= tol->dist )
d2480 1
a2480 1
	if( NEAR_ZERO( pipe->ps_od - pipe->ps_id, tol->dist) )
d2496 1
a2496 1
	prev = RT_LIST_PREV( wdb_pipeseg, &pipe->l );
d2498 1
a2498 1
	if( pipe->ps_id > tol->dist )
d2513 1
a2513 1
	else if( prev->ps_id > tol->dist )
d2521 1
a2521 1
		nmg_vertex_gv( vu->v_p, pipe->ps_start );
a2539 1
#endif
d2554 4
a2557 1
#if 0
a2559 2
	struct wdb_pipeseg *pipe_head;
	struct wdb_pipeseg *pipe;
d2564 1
d2585 1
a2585 2
	pipe_head = (struct wdb_pipeseg *)(&pip->pipe_segs_head);
	if( RT_LIST_IS_EMPTY( &pipe_head->l ) )
d2588 1
a2588 3
	pipe = RT_LIST_FIRST( wdb_pipeseg, &pipe_head->l );
	if( pipe->ps_type == WDB_PIPESEG_TYPE_END )
		return( 0 );	/* nothing to tesselate */
d2590 2
a2591 2
	VMOVE( min_pt, pipe->ps_start );
	VMOVE( max_pt, pipe->ps_start );
d2594 1
a2594 1
	for( RT_LIST_FOR( pipe, wdb_pipeseg, &pipe_head->l ) )
d2596 2
a2597 2
		if( pipe->ps_od > 0.0 && pipe->ps_od > max_diam )
			max_diam = pipe->ps_od;
d2599 1
a2599 1
		VMINMAX( min_pt, max_pt, pipe->ps_start );
d2612 1
a2612 1
		tol_segs = ceil( M_PI/acos( 1.0 - 2.0 * ttol->abs/max_diam) );
d2618 1
a2618 1
		tol_segs = ceil( M_PI/acos( 1.0 - 2.0 * ttol->rel*pipe_size/max_diam) );
d2624 1
a2624 1
		tol_segs = ceil( M_PI/ttol->norm );
d2637 1
a2637 1
	delta_angle = 2.0 * M_PI / (double)arc_segs;
d2641 2
a2642 2
	pipe = RT_LIST_FIRST( wdb_pipeseg, &pipe_head->l );
	tesselate_pipe_start( pipe, arc_segs, sin_del, cos_del,
d2645 11
a2655 1
	for( RT_LIST_FOR( pipe, wdb_pipeseg, &pipe_head->l ) )
d2657 22
d2680 3
a2682 1
		switch( pipe->ps_type )
d2684 9
a2692 15
			case WDB_PIPESEG_TYPE_LINEAR:
				tesselate_pipe_linear( pipe, arc_segs, sin_del, cos_del,
						&outer_loop, &inner_loop, r1, r2, s, tol );
				break;
			case WDB_PIPESEG_TYPE_BEND:
				tesselate_pipe_bend( pipe, arc_segs, sin_del, cos_del,
						&outer_loop, &inner_loop, r1, r2, s, tol, ttol );
				break;
			case WDB_PIPESEG_TYPE_END:
				tesselate_pipe_end( pipe, arc_segs, sin_del, cos_del,
						&outer_loop, &inner_loop, s, tol );
				break;
			default:
				rt_log( " ERROR: rt_pipe_tess: Unrecognized segment type (%d)\n", pipe->ps_type );
				break;
d2694 31
d2726 3
a2734 3
#else
	return( 1 );
#endif
d2940 1
d2956 6
d2969 7
@


11.13
log
@Minor fixes, to get it to compile on R8000.
@
text
@d19 1
a19 1
static char RCSpipe[] = "@@(#)$Header: /m/cad/librt/RCS/g_pipe.c,v 11.12 1995/07/18 02:34:02 jra Exp mike $ (BRL)";
d102 1
d286 1
a286 1

d308 1
d355 3
d372 2
a373 2
rt_pipeseg_print( pipe, mm2local )
struct wdb_pipeseg *pipe;
d376 1
a376 3
	point_t p1,p2;
	fastf_t radius;
	struct wdb_pipeseg *next;
d378 10
a387 47
	next = RT_LIST_NEXT( wdb_pipeseg, &pipe->l );
	switch( pipe->ps_type )
	{
		case WDB_PIPESEG_TYPE_LINEAR:
			rt_log( "Linear Pipe Segment:\n" );
			VSCALE( p1, pipe->ps_start, mm2local );
			VSCALE( p2, next->ps_start, mm2local );
			rt_log( "\tfrom (%g %g %g) to (%g %g %g)\n" ,
				V3ARGS( p1 ), V3ARGS( p2 ) );
			if( pipe->ps_id > 0.0 )
				rt_log( "\tat start: od=%g, id=%g\n",
					pipe->ps_od*mm2local,
					pipe->ps_id*mm2local );
			else
				rt_log( "\tat start: od=%g\n",
					pipe->ps_od*mm2local );
			if( next->ps_id > 0.0 )
				rt_log( "\tat end: od=%g, id=%g\n",
					next->ps_od*mm2local,
					next->ps_id*mm2local );
			else
				rt_log( "\tat end: od=%g\n",
					next->ps_od*mm2local );
			break;
		case WDB_PIPESEG_TYPE_BEND:
			rt_log( "Bend Pipe Segment:\n" );
			VSCALE( p1, pipe->ps_start, mm2local );
			VSCALE( p2, next->ps_start, mm2local );
			rt_log( "\tfrom (%g %g %g) to (%g %g %g)\n" ,
				V3ARGS( p1 ), V3ARGS( p2 ) );
			VSUB2( p2, pipe->ps_start, pipe->ps_bendcenter );
			radius = MAGNITUDE( p2 );
			VSCALE( p1, pipe->ps_bendcenter, mm2local );
			rt_log( "\tBend center at (%g %g %g), bend radius = %g\n",
				V3ARGS( p1 ), radius*mm2local );
			if( pipe->ps_id > 0.0 )
				rt_log( "\tod=%g, id=%g\n",
					pipe->ps_od*mm2local,
					pipe->ps_id*mm2local );
			else
				rt_log( "\tod=%g\n", pipe->ps_od*mm2local );
			break;
		case WDB_PIPESEG_TYPE_END:
			rt_log( "End Pipe Segment\n" );
			break;
	}

d391 1
a391 1
vls_pipeseg( vp, seg_no, ip, mm2local )
a396 2
	point_t p1,p2;
	fastf_t radius;
d398 1
a398 2
	struct wdb_pipeseg *pipe;
	struct wdb_pipeseg *next;
d401 1
d406 1
a406 1
	pipe = RT_LIST_FIRST( wdb_pipeseg, &pint->pipe_segs_head );
d408 1
a408 1
		pipe = RT_LIST_NEXT( wdb_pipeseg, &pipe->l );
a409 66
	next = RT_LIST_NEXT( wdb_pipeseg, &pipe->l );
	switch( pipe->ps_type )
	{
		case WDB_PIPESEG_TYPE_LINEAR:
			sprintf( buf, "Linear Pipe Segment:\n" );
			rt_vls_strcat( vp, buf );
			VSCALE( p1, pipe->ps_start, mm2local );
			VSCALE( p2, next->ps_start, mm2local );
			sprintf( buf, "\tfrom (%g %g %g) to (%g %g %g)\n" ,
				V3ARGS( p1 ), V3ARGS( p2 ) );
			rt_vls_strcat( vp, buf );
			if( pipe->ps_id > 0.0 )
				sprintf( buf, "\tat start: od=%g, id=%g\n",
					pipe->ps_od*mm2local,
					pipe->ps_id*mm2local );
			else
				sprintf( buf, "\tat start: od=%g\n",
					pipe->ps_od*mm2local );
			rt_vls_strcat( vp, buf );
			if( next->ps_id > 0.0 )
				sprintf( buf, "\tat end: od=%g, id=%g\n",
					next->ps_od*mm2local,
					next->ps_id*mm2local );
			else
				sprintf( buf, "\tat end: od=%g\n",
					next->ps_od*mm2local );
			rt_vls_strcat( vp, buf );
			break;
		case WDB_PIPESEG_TYPE_BEND:
			sprintf( buf, "Bend Pipe Segment:\n" );
			rt_vls_strcat( vp, buf );
			VSCALE( p1, pipe->ps_start, mm2local );
			VSCALE( p2, next->ps_start, mm2local );
			sprintf( buf, "\tfrom (%g %g %g) to (%g %g %g)\n" ,
				V3ARGS( p1 ), V3ARGS( p2 ) );
			rt_vls_strcat( vp, buf );
			VSUB2( p2, pipe->ps_start, pipe->ps_bendcenter );
			radius = MAGNITUDE( p2 );
			VSCALE( p1, pipe->ps_bendcenter, mm2local );
			sprintf( buf, "\tBend center at (%g %g %g), bend radius = %g\n",
				V3ARGS( p1 ), radius*mm2local );
			rt_vls_strcat( vp, buf );
			if( pipe->ps_id > 0.0 )
				sprintf( buf, "\tod=%g, id=%g\n",
					pipe->ps_od*mm2local,
					pipe->ps_id*mm2local );
			else
				sprintf( buf, "\tod=%g\n", pipe->ps_od*mm2local );
			rt_vls_strcat( vp, buf );
			break;
		case WDB_PIPESEG_TYPE_END:
			sprintf( buf, "End Pipe Segment\n" );
			rt_vls_strcat( vp, buf );
			VSCALE( p1, pipe->ps_start, mm2local );
			sprintf( buf, "\tat (%g %g %g)\n", V3ARGS( p1 ) );
			rt_vls_strcat( vp, buf );
			if( pipe->ps_id > 0.0 )
				sprintf( buf, "\tat end: od=%g, id=%g\n",
					pipe->ps_od*mm2local,
					pipe->ps_id*mm2local );
			else
				sprintf( buf, "\tat end: od=%g\n",
					pipe->ps_od*mm2local );
			rt_vls_strcat( vp, buf );
			break;
	}
d411 14
d427 1
d1055 1
a1055 1

d1074 1
d1171 3
d1350 1
a1350 1
 * requested). "Start" and "end" are start and endpoints of arc. "Seg_count"
d1356 1
a1356 1
draw_pipe_arc( vhead, radius, center, v1, v2, start, end, seg_count, full_circle )
d1361 1
a1361 1
point_t			start,end;
d1404 6
a1409 8
draw_pipe_surface( vhead, r1, r2, base_vertex, height, v1, v2, seg_count )
struct rt_list		*vhead;
fastf_t			r1;
fastf_t			r2;
point_t			base_vertex;
vect_t			height;
vect_t			v1,v2;
int			seg_count;
d1411 18
a1428 1
	point_t		pt;
d1430 2
a1431 2
	if( r1 > 0.0 )
		draw_pipe_arc( vhead, r1, base_vertex, v1, v2, pt, pt, seg_count, 1 );
d1433 5
a1437 8
	if( r1 > 0.0 )
	{
		VJOIN1( pt, base_vertex, r1, v2 );
	}
	else
	{
		VMOVE( pt, base_vertex );
	}
d1439 1
a1439 5
	VADD2( pt, base_vertex, height );
	if( r2 > 0.0 )
	{
		VJOIN1( pt, pt, r2, v2 );
	}
d1441 1
a1441 9

	if( r1 > 0.0 )
	{
		VJOIN1( pt, base_vertex, r1, v1 );
	}
	else
	{
		VMOVE( pt, base_vertex );
	}
d1443 1
a1443 5
	VADD2( pt, base_vertex, height );
	if( r2 > 0.0 )
	{
		VJOIN1( pt, pt, r2, v1 );
	}
d1445 1
a1445 9

	if( r1 > 0.0 )
	{
		VJOIN1( pt, base_vertex, (-r1), v2 );
	}
	else
	{
		VMOVE( pt, base_vertex );
	}
d1447 1
a1447 5
	VADD2( pt, base_vertex, height );
	if( r2 > 0.0 )
	{
		VJOIN1( pt, pt, (-r2), v2 );
	}
d1449 1
d1451 56
a1506 1
	if( r1 > 0.0 )
d1508 3
a1510 1
		VJOIN1( pt, base_vertex, (-r1), v1 );
d1512 30
a1541 11
	else
	{
		VMOVE( pt, base_vertex );
	}
	RT_ADD_VLIST( vhead, pt, RT_VLIST_LINE_MOVE );
	VADD2( pt, base_vertex, height );
	if( r2 > 0.0 )
	{
		VJOIN1( pt, pt, (-r2), v1 );
	}
	RT_ADD_VLIST( vhead, pt, RT_VLIST_LINE_DRAW );
d1554 3
a1556 2
	register struct wdb_pipeseg		*psp;
	register struct wdb_pipeseg		*nextp;
d1558 2
a1559 5
	LOCAL vect_t				height;
	LOCAL vect_t				pipe_dir;
	LOCAL vect_t				v1,v2,v3;
	LOCAL vect_t				tmp_vec;
	LOCAL point_t				tmp_center;
d1562 1
a1562 1
	LOCAL int				prev_type;
d1568 10
d1582 7
a1588 1
	prev_type = 0;
d1590 5
a1594 1
	for( RT_LIST_FOR( psp, wdb_pipeseg, &pip->pipe_segs_head ) ) 
d1596 3
a1598 4
		LOCAL fastf_t radius;
		LOCAL fastf_t inv_radius;
		LOCAL vect_t end_dir;
		LOCAL point_t start,end;
d1600 1
a1600 2
		nextp = RT_LIST_PNEXT( wdb_pipeseg, &psp->l );
		switch( psp->ps_type )
d1602 5
a1606 34
			case WDB_PIPESEG_TYPE_LINEAR:
				VSUB2( height, nextp->ps_start , psp->ps_start );
				VMOVE( pipe_dir, height );
				VUNITIZE( pipe_dir );
				mat_vec_ortho( v1, pipe_dir );
				VCROSS( v2, pipe_dir, v1 );

				/* draw outer surface */
				draw_pipe_surface( vhead, psp->ps_od/2.0, nextp->ps_od/2.0,
					psp->ps_start, height, v1, v2, ARC_SEGS );

				/* draw inner surface */
				if( psp->ps_id <= 0.0 && nextp->ps_id <= 0.0 )
					break;
				draw_pipe_surface( vhead, psp->ps_id/2.0, nextp->ps_id/2.0,
					psp->ps_start, height, v1, v2, ARC_SEGS );
				prev_type = WDB_PIPESEG_TYPE_LINEAR;
				break;
			case WDB_PIPESEG_TYPE_BEND:
				if( prev_type != WDB_PIPESEG_TYPE_LINEAR )
				{
					VSUB2( v1, psp->ps_start, psp->ps_bendcenter );
					VUNITIZE( v1 );
					VSUB2( tmp_vec, nextp->ps_start, psp->ps_bendcenter );
					VCROSS( v2, tmp_vec, v1 );
					VUNITIZE( v2 );
					VCROSS( pipe_dir, v1, v2 );
				}
				if( psp->ps_od > 0.0 )
					draw_pipe_arc( vhead, psp->ps_od/2.0, psp->ps_start,
							v1, v2, tmp_center, tmp_center, ARC_SEGS, 1 );
				if( psp->ps_id > 0.0 )
					draw_pipe_arc( vhead, psp->ps_id/2.0, psp->ps_start,
							v1, v2, tmp_center, tmp_center, ARC_SEGS, 1 );
d1608 57
a1664 51
				if( psp->ps_od != nextp->ps_od )
				{
					rt_log( "Pipe solid has bend with non-constant O.D.\n" );
					return( -1 );
				}
				if( psp->ps_id != nextp->ps_id )
				{
					rt_log( "Pipe solid has bend with non-constant I.D.\n" );
					return( -1 );
				}

				/* draw bend arcs in plane of bend */
				VSUB2( v1, psp->ps_start, psp->ps_bendcenter );
				radius = MAGNITUDE( v1 );
				inv_radius = 1.0/radius;
				VSCALE( v1, v1, inv_radius );
				VCROSS( v2, pipe_dir, v1 );
				VSUB2( end_dir, nextp->ps_start, psp->ps_bendcenter );
				VUNITIZE( end_dir );
				VJOIN1( start, psp->ps_start, psp->ps_od/2.0, v1 );
				VJOIN1( end, nextp->ps_start, nextp->ps_od/2.0, end_dir );
				draw_pipe_arc( vhead, radius+psp->ps_od/2.0,
					psp->ps_bendcenter, v1, pipe_dir, start, end, ARC_SEGS, 0 );
				VJOIN1( start, psp->ps_start, -psp->ps_od/2.0, v1 );
				VJOIN1( end, nextp->ps_start, -nextp->ps_od/2.0, end_dir );
				draw_pipe_arc( vhead, radius-psp->ps_od/2.0,
					psp->ps_bendcenter, v1, pipe_dir, start, end, ARC_SEGS, 0 );
				if( psp->ps_id > 0.0 )
				{
					VJOIN1( start, psp->ps_start, psp->ps_id/2.0, v1 );
					VJOIN1( end, nextp->ps_start, nextp->ps_id/2.0, end_dir );
					draw_pipe_arc( vhead, radius+psp->ps_id/2.0,
						psp->ps_bendcenter, v1, pipe_dir, start, end, ARC_SEGS, 0 );
					VJOIN1( start, psp->ps_start, -psp->ps_id/2.0, v1 );
					VJOIN1( end, nextp->ps_start, -nextp->ps_id/2.0, end_dir );
					draw_pipe_arc( vhead, radius-psp->ps_id/2.0,
						psp->ps_bendcenter, v1, pipe_dir, start, end, ARC_SEGS, 0 );
				}

				/* draw bend arcs not in plane of bend */
				VJOIN1( tmp_center, psp->ps_bendcenter, psp->ps_od/2.0, v2 );
				VJOIN1( start, psp->ps_start, psp->ps_od/2.0, v2 );
				VJOIN1( end, nextp->ps_start, nextp->ps_od/2.0, v2 );
				draw_pipe_arc( vhead, radius,
					tmp_center, v1, pipe_dir, start, end, ARC_SEGS, 0 );

				VJOIN1( tmp_center, psp->ps_bendcenter, -psp->ps_od/2.0, v2 );
				VJOIN1( start, psp->ps_start, -psp->ps_od/2.0, v2 );
				VJOIN1( end, nextp->ps_start, -nextp->ps_od/2.0, v2 );
				draw_pipe_arc( vhead, radius,
					tmp_center, v1, pipe_dir, start, end, ARC_SEGS, 0 );
a1665 33
				if( psp->ps_id > 0.0 )
				{
					VJOIN1( tmp_center, psp->ps_bendcenter, psp->ps_id/2.0, v2 );
					VJOIN1( start, psp->ps_start, psp->ps_id/2.0, v2 );
					VJOIN1( end, nextp->ps_start, nextp->ps_id/2.0, v2 );
					draw_pipe_arc( vhead, radius,
						tmp_center, v1, pipe_dir, start, end, ARC_SEGS, 0 );

					VJOIN1( tmp_center, psp->ps_bendcenter, -psp->ps_id/2.0, v2 );
					VJOIN1( start, psp->ps_start, -psp->ps_id/2.0, v2 );
					VJOIN1( end, nextp->ps_start, -nextp->ps_id/2.0, v2 );
					draw_pipe_arc( vhead, radius,
						tmp_center, v1, pipe_dir, start, end, ARC_SEGS, 0 );
				}

				/* prepare for drawing END circles */
				VSUB2( v1, nextp->ps_start, psp->ps_bendcenter );
				VUNITIZE( v1 );
				prev_type = WDB_PIPESEG_TYPE_BEND;
				break;
			case WDB_PIPESEG_TYPE_END:
				if( psp->ps_od > 0.0 )
					draw_pipe_arc( vhead, psp->ps_od/2.0,
						psp->ps_start, v1, v2, tmp_center, tmp_center, ARC_SEGS, 1 );
				if( psp->ps_id > 0.0 )
					draw_pipe_arc( vhead, psp->ps_id/2.0,
						psp->ps_start, v1, v2, tmp_center, tmp_center, ARC_SEGS, 1 );
				break;
			default:
				rt_log("rt_pipe_plot: unknown ps_type=%d\n", psp->ps_type);
				return(-1);
		}
	}
d1669 1
d1779 1
a1779 1
#if 0
d1790 1
a1790 1
#endif
d2504 1
a2504 1
#if 0
d2515 1
a2515 1
#endif
d2532 1
d2547 1
d2667 3
d2681 3
a2683 3
	register struct exported_pipeseg *exp;
	register struct wdb_pipeseg	*psp;
	struct wdb_pipeseg		tmp;
a2695 18
	/* Count number of segments */
	count = 0;
	for( exp = &rp->pw.pw_data[0]; ; exp++ )  {
		count++;
		switch( (int)(exp->eps_type[0]) )  {
		case WDB_PIPESEG_TYPE_END:
			goto done;
		case WDB_PIPESEG_TYPE_LINEAR:
		case WDB_PIPESEG_TYPE_BEND:
			break;
		default:
			return(-2);	/* unknown segment type */
		}
	}
done:	;
	if( count <= 1 )
		return(-3);		/* Not enough for 1 pipe! */

d2701 1
a2701 1
	pipe->pipe_count = count;
d2709 5
a2713 5
	for( exp = &rp->pw.pw_data[pipe->pipe_count-1]; exp >= &rp->pw.pw_data[0]; exp-- )  {
		tmp.ps_type = (int)exp->eps_type[0];
		ntohd( tmp.ps_start, exp->eps_start, 3 );
		ntohd( &tmp.ps_id, exp->eps_id, 1 );
		ntohd( &tmp.ps_od, exp->eps_od, 1 );
d2716 7
a2722 13
		GETSTRUCT( psp, wdb_pipeseg );
		psp->ps_type = tmp.ps_type;
		psp->l.magic = WDB_PIPESEG_MAGIC;
		MAT4X3PNT( psp->ps_start, mat, tmp.ps_start );
		if( psp->ps_type == WDB_PIPESEG_TYPE_BEND )  {
			ntohd( tmp.ps_bendcenter, exp->eps_bendcenter, 3 );
			MAT4X3PNT( psp->ps_bendcenter, mat, tmp.ps_bendcenter );
		} else {
			VSETALL( psp->ps_bendcenter, 0 );
		}
		psp->ps_id = tmp.ps_id / mat[15];
		psp->ps_od = tmp.ps_od / mat[15];
		RT_LIST_APPEND( &pipe->pipe_segs_head, &psp->l );
d2739 3
a2741 3
	register struct exported_pipeseg *eps;
	register struct wdb_pipeseg	*psp;
	struct wdb_pipeseg		tmp;
d2754 1
a2754 1
	/* Count number of segments, verify that last seg is an END seg */
d2756 1
a2756 1
	for( RT_LIST_FOR( psp, wdb_pipeseg, headp ) )  {
d2758 1
a2758 14
		switch( psp->ps_type )  {
		case WDB_PIPESEG_TYPE_END:
			if( RT_LIST_NEXT_NOT_HEAD( psp, headp ) )
				return(-1);	/* Inconsistency in list */
			break;
		case WDB_PIPESEG_TYPE_LINEAR:
		case WDB_PIPESEG_TYPE_BEND:
			if( RT_LIST_NEXT_IS_HEAD( psp, headp ) )
				return(-2);	/* List ends w/o TYPE_END */
			break;
		default:
			return(-3);		/* unknown segment type */
		}
	}
d2763 2
a2764 2
	nbytes = sizeof(struct pipe_wire_rec) +
		(count-1) * sizeof(struct exported_pipeseg);
d2772 3
a2774 2
	rec->pw.pw_id = DBID_PIPE;
	(void)rt_plong( rec->pw.pw_count, ngran-1 );	/* # EXTRA grans */
d2777 2
a2778 4
	eps = &rec->pw.pw_data[0];
	for( RT_LIST_FOR( psp, wdb_pipeseg, headp ), eps++ )  {
		/* Avoid need for htonl() here */
		eps->eps_type[0] = (char)psp->ps_type;
d2780 8
a2787 8
		VSCALE( tmp.ps_start, psp->ps_start, local2mm );
		VSCALE( tmp.ps_bendcenter, psp->ps_bendcenter, local2mm );
		tmp.ps_id = psp->ps_id * local2mm;
		tmp.ps_od = psp->ps_od * local2mm;
		htond( eps->eps_start, tmp.ps_start, 3 );
		htond( eps->eps_bendcenter, tmp.ps_bendcenter, 3 );
		htond( eps->eps_id, &tmp.ps_id, 1 );
		htond( eps->eps_od, &tmp.ps_od, 1 );
d2808 1
a2808 1
	register struct wdb_pipeseg	*psp;
d2816 1
a2816 1
	sprintf(buf, "pipe with %d segments\n", pip->pipe_count );
d2821 1
a2821 1
#if 0
d2823 1
a2823 2
	for( RT_LIST_FOR( psp, wdb_pipeseg, &pip->pipe_segs_head ) )  {
		/* XXX check magic number here */
d2826 3
a2828 14
		switch( psp->ps_type )  {
		case WDB_PIPESEG_TYPE_END:
			rt_vls_strcat( str, "END" );
			break;
		case WDB_PIPESEG_TYPE_LINEAR:
			rt_vls_strcat( str, "LINEAR" );
			break;
		case WDB_PIPESEG_TYPE_BEND:
			rt_vls_strcat( str, "BEND" );
			break;
		default:
			return(-1);
		}
		sprintf(buf, "  od=%g", psp->ps_od * mm2local );
d2830 2
a2831 2
		if( psp->ps_id > 0 )  {
			sprintf(buf, ", id  = %g", psp->ps_id * mm2local );
d2836 4
a2839 4
		sprintf(buf, "\t  start=(%g, %g, %g)\n",
			psp->ps_start[X] * mm2local,
			psp->ps_start[Y] * mm2local,
			psp->ps_start[Z] * mm2local );
a2841 7
		if( psp->ps_type == WDB_PIPESEG_TYPE_BEND )  {
			sprintf(buf, "\t  bendcenter=(%g, %g, %g)\n",
				psp->ps_bendcenter[X] * mm2local,
				psp->ps_bendcenter[Y] * mm2local,
				psp->ps_bendcenter[Z] * mm2local );
			rt_vls_strcat( str, buf );
		}
d2857 1
a2857 1
	register struct wdb_pipeseg	*psp;
d2863 3
a2865 3
	while( RT_LIST_WHILE( psp, wdb_pipeseg, &pipe->pipe_segs_head ) )  {
		RT_LIST_DEQUEUE( &(psp->l) );
		rt_free( (char *)psp, "wdb_pipeseg" );
d2881 1
a2881 1
struct wdb_pipeseg *headp;
d2883 20
a2902 15
	register struct wdb_pipeseg	*psp;
	register int			error_count=0;
	LOCAL vect_t			to_start;
	LOCAL vect_t			to_end;
	LOCAL fastf_t			bend_radius_sq1;
	LOCAL fastf_t			bend_radius_sq2;
	LOCAL fastf_t			dot_prod;
	LOCAL int			seg_no=0;

	psp = RT_LIST_FIRST( wdb_pipeseg, &headp->l );
	while( RT_LIST_NOT_HEAD( &psp->l, &headp->l ) )
	{
		register struct wdb_pipeseg	*next;
		vect_t				dir1;
		vect_t				dir2;
d2904 5
a2908 1
		seg_no++;
d2910 3
a2912 1
		if( psp->l.magic != WDB_PIPESEG_MAGIC )
d2914 4
a2917 4
			rt_log( "Pipe solid segment #%d has bad MAGIC, should be x%x, but is x%x\n",
				seg_no, WDB_PIPESEG_MAGIC, psp->l.magic );
			error_count++;
			return( error_count );
d2919 2
d2922 2
a2923 12
		next = RT_LIST_PNEXT( wdb_pipeseg, &psp->l );
		if( RT_LIST_NOT_HEAD( &next->l, &headp->l ) )
		{
			if( next->l.magic != WDB_PIPESEG_MAGIC )
			{
				rt_log( "Pipe solid segment #%d has bad MAGIC, should be x%x, but is x%x\n",
					seg_no+1, WDB_PIPESEG_MAGIC, next->l.magic );
				error_count++;
				return( error_count );
			}
		}
		else if( psp->ps_type != WDB_PIPESEG_TYPE_END )
d2925 2
a2926 3
			rt_log( "Pipe solid does not end with an END segment\n" );
			error_count++;
			return( error_count );
d2929 4
a2932 1
		switch( psp->ps_type )
d2934 20
a2953 144
			case WDB_PIPESEG_TYPE_BEND:
				VSUB2( to_start, psp->ps_start, psp->ps_bendcenter );
				VSUB2( to_end, next->ps_start, psp->ps_bendcenter );
				bend_radius_sq1 = MAGSQ( to_start );
				bend_radius_sq2 = MAGSQ( to_end );
				if( !NEAR_ZERO( bend_radius_sq1 - bend_radius_sq2, RT_LEN_TOL*RT_LEN_TOL ) )
				{
					rt_log( "Pipe bend center not in center, radii = %g,%g\n",
						sqrt( bend_radius_sq1 ), sqrt( bend_radius_sq2 ) );
					error_count++;
				}
				dot_prod = VDOT( to_start, to_end )/bend_radius_sq1;
				if( dot_prod < 0.0 )
					dot_prod = (-dot_prod);
				if( NEAR_ZERO( dot_prod - 1.0, RT_DOT_TOL ) )
				{
					rt_log( "Pipe bend must be less than 180 degrees\n" );
					error_count++;
				}
				if( psp->ps_id >= psp->ps_od )
				{
					rt_log( "Pipe solid has BEND with inner radius (%g) as big as outer (%g)\n",
						psp->ps_id, psp->ps_od );
					error_count++;
				}
				if( psp->ps_od != next->ps_od )
				{
					rt_log( "Pipe solid has BEND with non-constant outer radius (%g and %g)\n",
						psp->ps_od, next->ps_od );
					error_count++;
				}
				if( psp->ps_id > 0.0 || next->ps_id > 0.0 )
				{
					if( psp->ps_id != next->ps_id )
					{
						rt_log( "Pipe solid has BEND with non-constant inner radius (%g and %g)\n",
							psp->ps_id, next->ps_id  );
						error_count++;
					}
				}
				if( next->ps_type == WDB_PIPESEG_TYPE_LINEAR )
				{
					register struct wdb_pipeseg *next_next;

					next_next = RT_LIST_PNEXT( wdb_pipeseg, &next->l );
					if( RT_LIST_IS_HEAD( &next_next->l, &headp->l ) )
					{
						rt_log( "Pipe does not end with an END segment\n" );
						error_count++;
						return( error_count );
					}
					if( next_next->l.magic != WDB_PIPESEG_MAGIC )
					{
						rt_log( "Pipe solid segment #%d has bad MAGIC, should be x%x, but is x%x\n",
							seg_no+2, WDB_PIPESEG_MAGIC, next_next->l.magic );
						error_count++;
						return( error_count );
					}

					VSUB2( dir1, next_next->ps_start, next->ps_start );
					VUNITIZE( dir1 );
					if( !NEAR_ZERO( VDOT( dir1, to_end )/sqrt( bend_radius_sq2 ), RT_DOT_TOL ) )
					{
						rt_log( "Pipe bend section doesn't mate with linear segment\n" );
						rt_log( "\t(segments #%d and #%d )\n", seg_no, seg_no+1 );
						error_count++;
					}
				}
				else if( next->ps_type == WDB_PIPESEG_TYPE_BEND )
				{
					LOCAL vect_t	next_to_start;
					LOCAL fastf_t	next_bend_radius;
					LOCAL fastf_t	dot;

					VSUB2( next_to_start, next->ps_start, next->ps_bendcenter );
					next_bend_radius = MAGNITUDE( next_to_start );
					dot = VDOT( next_to_start, to_end )/
						(next_bend_radius*sqrt( bend_radius_sq2));
					dot = dot < 0.0 ? -dot:dot;
					if( !NEAR_ZERO( dot - 1.0, RT_DOT_TOL ) )
					{
						rt_log( "Consecutive bend segments don't mate\n" );
						rt_log( "\t(segments #%d and #%d )\n", seg_no, seg_no+1 );
						error_count++;
					}
				}
				break;
			case WDB_PIPESEG_TYPE_LINEAR:
				if( psp->ps_id >= psp->ps_od )
				{
					rt_log( "Pipe solid has Linear section with inner radius (%g) as big as outer (%g)\n",
						psp->ps_id, psp->ps_od );
					error_count++;
				}

				/* pipe direction */
				VSUB2( dir1, next->ps_start, psp->ps_start );
				VUNITIZE( dir1 );

				if( next->ps_type == WDB_PIPESEG_TYPE_LINEAR )
				{
					register struct wdb_pipeseg *next_next;

					next_next = RT_LIST_PNEXT( wdb_pipeseg, &next->l );
					if( RT_LIST_IS_HEAD( &next_next->l, &headp->l ) )
					{
						rt_log( "Pipe does not end with an END segment\n" );
						error_count++;
						return( error_count );
					}
					if( next_next->l.magic != WDB_PIPESEG_MAGIC )
					{
						rt_log( "Pipe solid segment #%d has bad MAGIC, should be x%x, but is x%x\n",
							seg_no+2, WDB_PIPESEG_MAGIC, next_next->l.magic );
						error_count++;
						return( error_count );
					}

					VSUB2( dir2, next_next->ps_start, next->ps_start );
					VUNITIZE( dir2 );
					if( !NEAR_ZERO( VDOT( dir1, dir2 ) - 1.0, RT_DOT_TOL ) )
					{
						rt_log( "Pipe solid has a corner with no BEND segment\n" );
						error_count++;
					}
				}
				else if( next->ps_type == WDB_PIPESEG_TYPE_BEND )
				{
					VSUB2( to_start, next->ps_start, next->ps_bendcenter );
					if( !NEAR_ZERO( VDOT( dir1, to_start )/MAGNITUDE( to_start ), RT_DOT_TOL ) )
					{
						rt_log( "Linear pipe segment doesn't mate with bend\n" );
						rt_log( "\t(segments #%d and #%d )\n", seg_no, seg_no+1 );
						error_count++;
					}
				}
				break;
			case WDB_PIPESEG_TYPE_END:
				break;
			default:
				rt_log( "Pipe solid has unrecognized segment type\n" );
				error_count++;
		}
		psp = next;
@


11.12
log
@Added details for end of pipe segment.
@
text
@d19 1
a19 1
static char RCSpipe[] = "@@(#)$Header: /m/cad/librt/RCS/g_pipe.c,v 11.11 1995/07/14 16:38:06 jra Exp jra $ (BRL)";
d1165 1
a1165 1
	register struct hit_list hit_head;
a2699 1
		struct wdb_pipeseg *prev_pipe=(struct wdb_pipeseg *)NULL;
a2705 1
				prev_pipe = pipe;
a2709 1
				prev_pipe = pipe;
d3035 1
a3035 1
			rt_log( "Pipe solid does not end with an END segment\m" );
@


11.11
log
@Added vls_pipeseg().
@
text
@d19 1
a19 1
static char RCSpipe[] = "@@(#)$Header: /m/cad/librt/RCS/g_pipe.c,v 11.10 1995/07/10 20:33:46 jra Exp jra $ (BRL)";
d498 11
@


11.10
log
@Added rt_pipeseg_print(). Deleted overly detailed printing from describe routine.
@
text
@d19 1
a19 1
static char RCSpipe[] = "@@(#)$Header: /m/cad/librt/RCS/g_pipe.c,v 11.9 1995/07/10 13:00:59 jra Exp jra $ (BRL)";
d419 80
@


11.9
log
@import routine was not setting WDB_PIPESEG_MAGIC. Also added code to set edge->is_real flags for end edges.
@
text
@d19 1
a19 1
static char RCSpipe[] = "@@(#)$Header: /m/cad/librt/RCS/g_pipe.c,v 11.8 1995/07/06 13:21:09 jra Exp jra $ (BRL)";
d367 58
d2505 2
d2827 2
d2868 1
@


11.8
log
@Added tesselation for pipe solid.
@
text
@d19 1
a19 1
static char RCSpipe[] = "@@(#)$Header: /m/cad/librt/RCS/g_pipe.c,v 11.7 1995/07/05 20:16:37 jra Exp jra $ (BRL)";
d1705 14
d1738 2
d2375 1
d2428 15
d2644 1
@


11.7
log
@CHeckpoint.
@
text
@d19 1
a19 1
static char RCSpipe[] = "@@(#)$Header: /m/cad/librt/RCS/g_pipe.c,v 11.6 1995/06/28 16:54:29 jra Exp jra $ (BRL)";
a1627 1
rt_log( "In tesselate_pipe_start,r1 = (%g %g %g), r2 = (%g %g %g )\n", V3ARGS( r1 ), V3ARGS( r2 ) );
a1630 1
rt_log( "In tesselate_pipe_start, or = %g, ir = %g\n" , or, ir );
a1661 6
rt_log( "Outer_loop:\n" );
for( i=0 ; i<arc_segs ; i++ )
{
	rt_log( " %d %x\n", i, (*outer_loop)[i] );
	VPRINT( "\t", (*outer_loop)[i]->vg_p->coord );
}
d1691 12
a1746 18
rt_log( "In tesselate_pipe_linear: or=%g, next_or=%g\n", or, next_or );
rt_log( "\tcos_del=%g, sin_del=%g\n" , cos_del, sin_del );
rt_log( "Outer_loop:\n" );
for( i=0 ; i<arc_segs ; i++ )
{
	rt_log( " %d %x\n", i, (*outer_loop)[i] );
	VPRINT( "\t", (*outer_loop)[i]->vg_p->coord );
}
if( ir > 0.0 )
{
rt_log( "Inner_loop:\n" );
for( i=0 ; i<arc_segs ; i++ )
{
	rt_log( " %d %x\n", i, (*inner_loop)[i] );
	VPRINT( "\t", (*inner_loop)[i]->vg_p->coord );
}
}

a1753 7
#if 0
	VSUB2( n, pipe->ps_start, next->ps_start );
	VUNITIZE( n );
	mat_vec_ortho( r1, n );
	VCROSS( r2, r1, n );
#endif
rt_log( "r1=(%g %g %g ), r2=(%g %g %g)\n", V3ARGS( r1 ), V3ARGS( r2 ) );
a1760 1
rt_log( "or=%g, next_or=%g\n" , or, next_or );
a1765 1
rt_log( "\tx=%g, y=%g\n" , x, y );
a1825 6
rt_log( "New Outer_loop:\n" );
for( i=0 ; i<arc_segs ; i++ )
{
	rt_log( " %d %x\n", i, new_outer_loop[i] );
	VPRINT( "\t", new_outer_loop[i]->vg_p->coord );
}
a1831 1
rt_log( "or=%g, next_or=%g\n" , or, next_or );
a1866 1
rt_log( "or=%g, next_or=%g\n" , or, next_or );
a1902 6
rt_log( "New Outer_loop:\n" );
for( i=0 ; i<arc_segs ; i++ )
{
	rt_log( " %d %x\n", i, new_outer_loop[i] );
	VPRINT( "\t", new_outer_loop[i]->vg_p->coord );
}
a1912 1
rt_log( "ir=%g, next_ir=%g\n" , ir, next_ir );
a1917 1
rt_log( "\tx=%g, y=%g\n" , x, y );
a1979 12
rt_log( "New Inner_loop:\n" );
for( i=0 ; i<arc_segs ; i++ )
{
	rt_log( " %d %x\n", i, new_inner_loop[i] );
	VPRINT( "\t", new_inner_loop[i]->vg_p->coord );
}
rt_log( "Old Inner_loop:\n" );
for( i=0 ; i<arc_segs ; i++ )
{
	rt_log( " %d %x\n", i, (*inner_loop)[i] );
	VPRINT( "\t", (*inner_loop)[i]->vg_p->coord );
}
a1986 1
rt_log( "ir=%g, next_ir=%g\n" , ir, next_ir );
d1989 1
a1989 1
			verts[1] = &(*inner_loop)[i];
d1991 1
a1991 1
				verts[0] = &(*inner_loop)[0];
d1993 1
a1993 1
				verts[0] = &(*inner_loop)[i+1];
d2021 1
a2021 2
rt_log( "ir=%g, next_ir=%g\n" , ir, next_ir );
		x = ir;
d2023 1
a2023 1
		VJOIN2( pt_next, pipe->ps_start, x, r1, y, r2 );
d2031 1
a2031 1
			VJOIN2( pt_next, pipe->ps_start, x, r1, y, r2 );
d2033 1
a2033 1
			verts[0] = &(*inner_loop)[0];
d2036 1
a2036 1
				verts[2] = &new_inner_loop[0];
d2038 1
a2038 1
				verts[2] = &new_inner_loop[i+1];
d2047 1
a2047 1
				nmg_vertex_gv( *inner_loop[0], pipe->ps_start );
d2050 1
a2050 1
			if( i+1 < arc_segs-1 && !new_inner_loop[i+1]->vg_p )
a2061 5
rt_log( "Outer_loop:\n" );
for( i=0 ; i<arc_segs ; i++ )
{
	rt_log( " %d %x\n", i, (*outer_loop)[i] );
	VPRINT( "\t", (*outer_loop)[i]->vg_p->coord );
a2062 10
if( next_ir > tol->dist )
{
rt_log( "Inner_loop:\n" );
for( i=0 ; i<arc_segs ; i++ )
{
	rt_log( " %d %x\n", i, (*inner_loop)[i] );
	VPRINT( "\t", (*inner_loop)[i]->vg_p->coord );
}
}
}
a2120 5
rt_log( "In tesselate_pipe_bend:\n" );
VPRINT( "start: ", pipe->ps_start );
VPRINT( "bendcenter: ", pipe->ps_bendcenter );
rt_log( "\tid = %g, od = %g\n", pipe->ps_id, pipe->ps_od );
rt_log( "\tcos_del=%g, sin_del=%g\n" , cos_del, sin_del );
a2178 15
rt_log( "Outer_loop:\n" );
for( i=0 ; i<arc_segs ; i++ )
{
	rt_log( " %d %x\n", i, (*outer_loop)[i] );
	VPRINT( "\t", (*outer_loop)[i]->vg_p->coord );
}
if( ir > tol->dist )
{
rt_log( "Inner_loop:\n" );
for( i=0 ; i<arc_segs ; i++ )
{
	rt_log( " %d %x\n", i, (*inner_loop)[i] );
	VPRINT( "\t", (*inner_loop)[i]->vg_p->coord );
}
}
a2180 2
rt_log( "r1 = (%g %g %g), bend_norm = (%g %g %g)\n", V3ARGS( r1 ), V3ARGS( bend_norm ) );
rt_log( "\txstart=%g, ystart=%g\n", xstart, ystart );
a2189 1
rt_log( "new r1=(%g %g %g), new_r2=(%g %g %g), new center=(%g %g %g)\n", V3ARGS( r1 ), V3ARGS( r2 ), V3ARGS( center ) );
a2198 1
rt_log( "\tx=%g, y=%g\n" , x, y );
d2249 1
a2249 6
rt_log( "New Outer_loop:\n" );
for( i=0 ; i<arc_segs ; i++ )
{
	rt_log( " %d %x\n", i, new_outer_loop[i] );
	VPRINT( "\t", new_outer_loop[i]->vg_p->coord );
}
a2343 15
rt_log( "Outer_loop:\n" );
for( i=0 ; i<arc_segs ; i++ )
{
	rt_log( " %d %x\n", i, (*outer_loop)[i] );
	VPRINT( "\t", (*outer_loop)[i]->vg_p->coord );
}
if( ir > tol->dist )
{
rt_log( "Inner_loop:\n" );
for( i=0 ; i<arc_segs ; i++ )
{
	rt_log( " %d %x\n", i, (*inner_loop)[i] );
	VPRINT( "\t", (*inner_loop)[i]->vg_p->coord );
}
}
d2357 1
d2360 1
a2360 16
rt_log( "In tesselate_pipe_end():\n" );
rt_log( "Outer_loop:\n" );
for( i=0 ; i<arc_segs ; i++ )
{
	rt_log( " %d %x\n", i, (*outer_loop)[i] );
	VPRINT( "\t", (*outer_loop)[i]->vg_p->coord );
}
if( pipe->ps_id > tol->dist )
{
rt_log( "Inner_loop:\n" );
for( i=0 ; i<arc_segs ; i++ )
{
	rt_log( " %d %x\n", i, (*inner_loop)[i] );
	VPRINT( "\t", (*inner_loop)[i]->vg_p->coord );
}
}
d2382 2
d2399 12
d2540 3
d2544 1
@


11.6
log
@Started tesselation.
@
text
@d19 1
a19 1
static char RCSpipe[] = "@@(#)$Header: /m/cad/librt/RCS/g_pipe.c,v 11.5 1995/05/31 19:10:25 jra Exp jra $ (BRL)";
d1583 1
a1583 1
tesselate_pipe_start( pipe, arc_segs, sin_del, cos_del, outer_loop, inner_loop, s )
d1590 1
d1592 1
d1602 1
a1602 1
	vect_t r1,r2,n;
d1607 1
a1607 15

	or = pipe->ps_od/2.0;
	ir = pipe->ps_id/2.0;

	if( or <= 0.0 )
		return;

	if( ir > or )
	{
		rt_log( "Inner radius larger than outer radius at start of pipe solid\n" );
		return;
	}

	if( ir == or )
		return;
a1612 1
		/* Make r1Xr2 opposite to 'n' to get correct orientation */
d1616 1
a1616 1
		VCROSS( r2, r1, n );
a1620 1
		/* Make r1Xr2 opposite to 'n' to get correct orientation */
d1628 18
d1670 1
a1670 1
	if( ir > 0.0 )
d1672 2
a1673 1
		struct vertex **verts;
d1675 2
a1676 4
		verts = (struct vertex **)rt_calloc( arc_segs, sizeof( struct vertex *),
			"tesselate_pipe_start: verts" );
		for( i=0 ; i<arc_segs; i++ )
			verts[i] = (*inner_loop)[i];
d1678 3
a1680 2
		fu = nmg_add_loop_to_face( s, fu, verts, arc_segs, OT_OPPOSITE );
		rt_free( (char *)verts, "tesselate_pipe_start: verts" );
d1684 4
a1687 1
		for( i=0 ; i<arc_segs; i++ )
d1689 2
a1690 2
			VJOIN2( pt, pipe->ps_start, x, r1, y, r2 );
			nmg_vertex_gv( (*inner_loop)[arc_segs-1-i], pt ); /* reverse order for OT_OPPOSITE */
d1695 2
d1704 1
a1704 1
tesselate_pipe_linear( pipe, arc_segs, sin_del, cos_del, outer_loop, inner_loop, s )
d1711 1
d1713 1
d1724 1
a1724 1
	vect_t r1,r2,n;
d1728 1
d1743 19
a1761 1
	if( next_or > 0.0 )
d1765 1
a1765 1
	if( next_ir > 0.0 )
d1768 1
a1768 1

d1773 21
d1795 64
a1858 1
	if( or > 0.0 && next_or <= 0.0 )
d1861 1
d1865 1
a1865 1
			verts[1] = outer_loop[i];
d1867 1
a1867 1
				verts[0] = outer_loop[0];
d1869 1
a1869 1
				verts[0] = outer_loop[i+1];
d1873 1
a1873 1
			if( (fu = nmg_cmface( s, verts, 3 ) ) )
d1888 1
a1888 1
		rt_free( (char *)outer_loop, "tesselate_pipe_linear: outer_loop" );
d1891 1
a1891 1
	else if( or <= 0.0 && next_or > 0.0 )
d1893 1
a1893 1
		point_t pt;
d1897 1
d1900 1
d1903 1
a1903 1
			VJOIN2( pt, pipe->ps_start, x, r1, y, r2 );
d1908 1
d1910 1
a1910 1
			verts[0] = outer_loop[0];
d1917 1
a1917 1
			if( (fu = nmg_cmface( s, verts, 3 ) ) )
d1923 4
a1926 1
			nmg_vertex_gv( new_outer_loop[i], pt );
d1934 7
a1940 1
		rt_free( (char *)outer_loop, "tesselate_pipe_linear: outer_loop" );
d1944 91
a2034 1
	if( ir > 0.0 && next_ir <= 0.0 )
d2038 1
d2041 1
a2041 1
			verts[1] = inner_loop[i];
d2043 1
a2043 1
				verts[0] = inner_loop[0];
d2045 1
a2045 1
				verts[0] = inner_loop[i+1];
d2049 1
a2049 1
			if( (fu = nmg_cmface( s, verts, 3 ) ) )
d2064 1
a2064 1
		rt_free( (char *)inner_loop, "tesselate_pipe_linear: inner_loop" );
d2067 1
a2067 1
	else if( ir <= 0.0 && next_ir > 0.0 )
d2069 1
a2069 1
		point_t pt;
d2073 1
d2076 1
d2079 1
a2079 1
			VJOIN2( pt, pipe->ps_start, x, r1, y, r2 );
d2084 1
d2086 1
a2086 1
			verts[0] = inner_loop[0];
d2093 1
a2093 1
			if( (fu = nmg_cmface( s, verts, 3 ) ) )
d2101 4
a2104 1
			nmg_vertex_gv( new_inner_loop[i], pt );
d2112 1
a2112 1
		rt_free( (char *)inner_loop, "tesselate_pipe_linear: inner_loop" );
d2115 15
d2133 1
a2133 1
tesselate_pipe_bend( pipe, arc_segs, sin_del, cos_del, outer_loop, inner_loop, s, ttol )
d2140 1
d2142 1
d2161 1
d2164 2
d2170 2
d2178 1
d2181 3
d2193 1
d2200 3
d2205 3
a2208 1
	VSCALE( b1, to_start, 1.0/bend_radius );
d2211 2
d2214 1
d2243 3
d2248 1
a2248 8
	start_v = *outer_loop[0];
	NMG_CK_VERTEX( start_v );
	start_vg = start_v->vg_p;
	NMG_CK_VERTEX_G( start_vg );
	VSUB2( to_start_v, start_vg->coord, pipe->ps_start );
	start_arc_angle = atan2( VDOT( to_start_v, bend_norm ), VDOT( to_start_v, b1 ) );
	xstart = or * cos( start_arc_angle );
	ystart = or * sin( start_arc_angle );
a2250 2
		vect_t r1;
		point_t center;
d2258 9
d2269 2
d2272 9
a2280 4
		x_bend_new = x_bend*cos_bend_del - y_bend*sin_bend_del;
		y_bend_new = x_bend*sin_bend_del + y_bend*cos_bend_del;
		VBLEND2( r1, x_bend_new , b1, y_bend_new, b2 );
		VJOIN1( center, pipe->ps_bendcenter, bend_radius, r1 );
d2282 2
a2283 2
		x = xstart;
		y = ystart;
d2290 1
d2303 1
a2303 1
			VJOIN2( pt, center, x, r1, y, bend_norm );
d2328 1
a2328 1
			VJOIN2( pt, center, x, r1, y, bend_norm );
d2347 1
a2347 1
		rt_free( (char *)outer_loop, "tesselate_pipe_bend: outer_loop" );
d2351 4
a2354 1
	if( ir <= 0.0 )
d2356 1
d2358 3
d2363 1
a2363 8
	start_v = *inner_loop[0];
	NMG_CK_VERTEX( start_v );
	start_vg = start_v->vg_p;
	NMG_CK_VERTEX_G( start_vg );
	VSUB2( to_start_v, start_vg->coord, pipe->ps_start );
	start_arc_angle = atan2( VDOT( to_start_v, bend_norm ), VDOT( to_start_v, b1 ) );
	xstart = ir * cos( start_arc_angle );
	ystart = ir * sin( start_arc_angle );
a2365 2
		vect_t r1;
		point_t center;
d2370 8
a2377 4
		x_bend_new = x_bend*cos_bend_del - y_bend*sin_bend_del;
		y_bend_new = x_bend*sin_bend_del + y_bend*cos_bend_del;
		VBLEND2( r1, x_bend_new , b1, y_bend_new, b2 );
		VJOIN1( center, pipe->ps_bendcenter, bend_radius, r1 );
d2379 2
a2380 2
		x = xstart;
		y = ystart;
d2387 1
d2389 1
a2389 1
				verts[0] = inner_loop[0];
d2391 1
a2391 2
				verts[0] = inner_loop[i+1];
			verts[1] = inner_loop[i];
d2399 1
a2399 1
			VJOIN2( pt, center, x, r1, y, bend_norm );
d2413 1
a2413 1
			verts[1] = verts[2];
d2424 1
a2424 1
			VJOIN2( pt, center, x, r1, y, bend_norm );
a2433 1

d2436 1
a2436 1
		rt_free( (char *)inner_loop, "tesselate_pipe_bend: inner_loop" );
d2439 17
a2455 1
	
d2459 1
a2459 1
tesselate_pipe_end( pipe, arc_segs, sin_del, cos_del, outer_loop, inner_loop, s )
d2467 1
d2470 19
d2490 2
a2491 1
	NMG_CK_SHELL( s );
d2493 1
a2493 1
	if( pipe->ps_od <= 0.0 )
d2509 1
a2509 1
	if( pipe->ps_id > 0.0 )
d2517 1
a2517 1
			verts[i] = *inner_loop[i];
d2550 1
d2584 1
a2584 1
	if( max_diam <= 0.0 )
d2624 2
a2625 1
	tesselate_pipe_start( pipe, arc_segs, sin_del, cos_del, &outer_loop, &inner_loop, s );
d2635 1
a2635 1
						&outer_loop, &inner_loop, s );
d2640 1
a2640 1
						&outer_loop, &inner_loop, s, ttol );
d2645 1
a2645 1
						&outer_loop, &inner_loop, s );
d2926 1
d2977 4
a2980 1
				if( NEAR_ZERO( VDOT( to_start, to_end )/bend_radius_sq1 - 1.0, RT_DOT_TOL ) )
@


11.5
log
@Added some comments, bounding box for bend sections, and checks for segment mating in rt_pipe_ck.
@
text
@d19 1
a19 1
static char RCSpipe[] = "@@(#)$Header: /m/cad/librt/RCS/g_pipe.c,v 11.4 1995/05/30 12:32:16 jra Exp jra $ (BRL)";
d29 1
a29 1
#include "rtlist.h"
a30 1
#include "nmg.h"
d1582 635
d2228 116
a2343 1
	return(-1);
@


11.4
log
@Finished raytracing for pipe solid.
@
text
@d19 1
a19 1
static char RCSpipe[] = "@@(#)$Header: /m/cad/librt/RCS/g_pipe.c,v 11.3 1995/05/26 20:34:05 jra Exp jra $ (BRL)";
d48 9
a56 9
		vect_t	pipe_V;
		vect_t	pipe_H;
		fastf_t pipe_ribase, pipe_ritop;
		fastf_t pipe_ribase_sq, pipe_ritop_sq;
		fastf_t pipe_ridiff_sq, pipe_ridiff;
		fastf_t pipe_rodiff_sq, pipe_rodiff;
		fastf_t pipe_robase, pipe_rotop;
		fastf_t pipe_robase_sq, pipe_rotop_sq;
		fastf_t	pipe_len;
d64 15
a78 15
		fastf_t	bend_radius;
		fastf_t	bend_or;
		fastf_t	bend_ir;
		mat_t	bend_invR;
		mat_t	bend_SoR;
		point_t	bend_V;
		point_t	bend_start;
		point_t	bend_end;
		fastf_t	bend_alpha_i;
		fastf_t	bend_alpha_o;
		fastf_t	bend_angle;
		vect_t	bend_ra;
		vect_t	bend_rb;
		vect_t	bend_N;
		fastf_t	bend_R_SQ;	/* bounding sphere */
d113 5
d146 2
d150 7
d171 26
a196 1
	/* XXX Need bounding box calculations */
d1144 1
d1183 13
d1429 1
a1429 1
	register struct wdb_pipeseg		*np;
d1457 1
a1457 1
		np = RT_LIST_PNEXT( wdb_pipeseg, &psp->l );
d1461 1
a1461 1
				VSUB2( height, np->ps_start , psp->ps_start );
d1468 1
a1468 1
				draw_pipe_surface( vhead, psp->ps_od/2.0, np->ps_od/2.0,
d1472 1
a1472 1
				if( psp->ps_id <= 0.0 && np->ps_id <= 0.0 )
d1474 1
a1474 1
				draw_pipe_surface( vhead, psp->ps_id/2.0, np->ps_id/2.0,
d1479 9
d1495 1
a1495 1
				if( psp->ps_od != np->ps_od )
d1500 1
a1500 1
				if( psp->ps_id != np->ps_id )
d1512 1
a1512 1
				VSUB2( end_dir, np->ps_start, psp->ps_bendcenter );
d1515 1
a1515 1
				VJOIN1( end, np->ps_start, np->ps_od/2.0, end_dir );
d1519 1
a1519 1
				VJOIN1( end, np->ps_start, -np->ps_od/2.0, end_dir );
d1525 1
a1525 1
					VJOIN1( end, np->ps_start, np->ps_id/2.0, end_dir );
d1529 1
a1529 1
					VJOIN1( end, np->ps_start, -np->ps_id/2.0, end_dir );
d1537 1
a1537 1
				VJOIN1( end, np->ps_start, np->ps_od/2.0, v2 );
d1543 1
a1543 1
				VJOIN1( end, np->ps_start, -np->ps_od/2.0, v2 );
d1551 1
a1551 1
					VJOIN1( end, np->ps_start, np->ps_id/2.0, v2 );
d1557 1
a1557 1
					VJOIN1( end, np->ps_start, -np->ps_id/2.0, v2 );
d1563 1
a1563 1
				VSUB2( v1, np->ps_start, psp->ps_bendcenter );
d1863 5
d1876 2
d1880 2
a1881 2
			rt_log( "Pipe solid segment has bad MAGIC, should be x%x, but is x%x\n",
				WDB_PIPESEG_MAGIC, psp->l.magic );
d1891 2
a1892 2
				rt_log( "Pipe solid segment has bad MAGIC, should be x%x, but is x%x\n",
					WDB_PIPESEG_MAGIC, next->l.magic );
d1907 15
d1943 46
d1991 11
d2015 2
a2016 2
						rt_log( "Pipe solid segment has bad MAGIC, should be x%x, but is x%x\n",
							WDB_PIPESEG_MAGIC, next_next->l.magic );
a2020 1
					VSUB2( dir1, next->ps_start, psp->ps_start );
a2021 1
					VUNITIZE( dir1 );
d2026 10
@


11.3
log
@Checkpoint.
@
text
@d19 1
a19 1
static char RCSpipe[] = "@@(#)$Header: /m/cad/librt/RCS/g_pipe.c,v 11.2 1995/05/17 18:32:51 jra Exp $ (BRL)";
d78 1
d146 3
d353 10
d479 3
@


11.2
log
@Improved plotting, Added raytracing for linear sections.
@
text
@d19 1
a19 1
static char RCSpipe[] = "@@(#)$Header: /m/cad/librt/RCS/g_pipe.c,v 11.1 1995/01/04 09:56:53 mike Rel4_4 jra $ (BRL)";
d35 2
d38 47
a84 15
struct pipe_specific {
	struct rt_list l;
	int	pipe_type;
	vect_t	pipe_V;
	vect_t	pipe_H;
	vect_t	pipe_bend_center;
	fastf_t	pipe_len;
	fastf_t pipe_ribase, pipe_ritop;
	fastf_t pipe_ribase_sq, pipe_ritop_sq;
	fastf_t pipe_ridiff_sq, pipe_ridiff;
	fastf_t pipe_rodiff_sq, pipe_rodiff;
	fastf_t pipe_robase, pipe_rotop;
	fastf_t pipe_robase_sq, pipe_rotop_sq;
	mat_t	pipe_SoR;	/* Scale and rotate */
	mat_t	pipe_invRoS;	/* inverse rotation and scale */
d91 9
d102 142
d256 1
a256 1
 *  	A struct pipe_specific is created, and it's address is stored in
d265 1
a265 1
	register struct pipe_specific *head;
d268 4
a271 1
	fastf_t dx,dy,dz,f;
d277 1
a277 1
	GETSTRUCT( head, pipe_specific );
d279 1
a279 1
	RT_LIST_INIT( &head->l );
d284 11
a294 10
		register struct pipe_specific *pipe;
		register struct wdb_pipeseg *next_seg;
		LOCAL mat_t	R;
		LOCAL mat_t	Rinv;
		LOCAL mat_t	S;
		LOCAL point_t work;
		LOCAL point_t top;
		LOCAL vect_t seg_ht;
		LOCAL vect_t v1,v2;
		LOCAL fastf_t seg_length;
a295 74
		if( pipe_seg->ps_type == WDB_PIPESEG_TYPE_END )
			break;

		GETSTRUCT( pipe, pipe_specific );
		RT_LIST_INSERT( &head->l, &pipe->l );

		next_seg = RT_LIST_PNEXT( wdb_pipeseg, pipe_seg );

		VMOVE( pipe->pipe_V, pipe_seg->ps_start );

		VSUB2( seg_ht, next_seg->ps_start, pipe_seg->ps_start );
		VMOVE( pipe->pipe_bend_center, pipe_seg->ps_bendcenter );
		pipe->pipe_ribase = pipe_seg->ps_id/2.0;
		pipe->pipe_ribase_sq = pipe->pipe_ribase * pipe->pipe_ribase;
		pipe->pipe_ritop = next_seg->ps_id/2.0;
		pipe->pipe_ritop_sq = pipe->pipe_ritop * pipe->pipe_ritop;
		pipe->pipe_robase = pipe_seg->ps_od/2.0;
		pipe->pipe_robase_sq = pipe->pipe_robase * pipe->pipe_robase;
		pipe->pipe_rotop = next_seg->ps_od/2.0;
		pipe->pipe_rotop_sq = pipe->pipe_rotop * pipe->pipe_rotop;
		pipe->pipe_ridiff = pipe->pipe_ritop - pipe->pipe_ribase;
		pipe->pipe_ridiff_sq = pipe->pipe_ridiff * pipe->pipe_ridiff;
		pipe->pipe_rodiff = pipe->pipe_rotop - pipe->pipe_robase;
		pipe->pipe_rodiff_sq = pipe->pipe_rodiff * pipe->pipe_rodiff;
		pipe->pipe_type = pipe_seg->ps_type;

		seg_length = MAGNITUDE( seg_ht );
		pipe->pipe_len = seg_length;
		VSCALE( seg_ht, seg_ht, 1.0/seg_length );
		VMOVE( pipe->pipe_H, seg_ht );
		mat_vec_ortho( v1, seg_ht );
		VCROSS( v2, seg_ht, v1 );

		/* build R matrix */
		mat_idn( R );
		VMOVE( &R[0], v1 );
		VMOVE( &R[4], v2 );
		VMOVE( &R[8], seg_ht );

		/* Rinv is transpose */
		mat_trn( Rinv, R );

		/* Build Scale matrix */
		mat_idn( S );
		S[10] = 1.0/seg_length;

		/* Compute SoR and invRoS */
		mat_mul( pipe->pipe_SoR, S, R );
		mat_mul( pipe->pipe_invRoS, Rinv, S );



		VJOIN2( work, pipe_seg->ps_start, pipe_seg->ps_od, v1, pipe_seg->ps_od, v2 );
		PIPE_MM( work )
		VJOIN2( work, pipe_seg->ps_start, -pipe_seg->ps_od, v1, pipe_seg->ps_od, v2 );
		PIPE_MM( work )
		VJOIN2( work, pipe_seg->ps_start, pipe_seg->ps_od, v1, -pipe_seg->ps_od, v2 );
		PIPE_MM( work )
		VJOIN2( work, pipe_seg->ps_start, -pipe_seg->ps_od, v1, -pipe_seg->ps_od, v2 );
		PIPE_MM( work )

		if( next_seg->ps_type != WDB_PIPESEG_TYPE_END )
			continue;
		VJOIN1( top, pipe_seg->ps_start, seg_length, seg_ht );
		VJOIN2( work, top, pipe_seg->ps_od, v1, pipe_seg->ps_od, v2 );
		PIPE_MM( work )
		VJOIN2( work, top, -pipe_seg->ps_od, v1, pipe_seg->ps_od, v2 );
		PIPE_MM( work )
		VJOIN2( work, top, pipe_seg->ps_od, v1, -pipe_seg->ps_od, v2 );
		PIPE_MM( work )
		VJOIN2( work, top, -pipe_seg->ps_od, v1, -pipe_seg->ps_od, v2 );
		PIPE_MM( work )

	}
d320 2
a321 2
/*	register struct pipe_specific *pipe =
		(struct pipe_specific *)stp->st_specific; */
d324 215
a538 4
#define	PIPE_NORM_OUTER_BODY	1
#define	PIPE_NORM_INNER_BODY	2
#define	PIPE_NORM_TOP		3
#define	PIPE_NORM_BASE		4
d540 4
d545 1
a545 1
linear_pipe_shot( stp, rp, ap, seghead, pipe, hits, hit_count, seg_no )
d550 2
a551 2
struct pipe_specific	*pipe;
struct hit		*hits;
d555 1
d571 2
d607 6
a612 4
			hits[*hit_count].hit_dist = t_tmp;
			hits[*hit_count].hit_surfno = seg_no*10 + PIPE_NORM_OUTER_BODY;
			VMOVE( hits[*hit_count].hit_vpriv, hit_pt );
			hits[*hit_count].hit_vpriv[Z] = (-pipe->pipe_robase - hit_pt[Z] * pipe->pipe_rodiff) *
d615 1
d622 6
a627 4
			hits[*hit_count].hit_dist = t_tmp;
			hits[*hit_count].hit_surfno = seg_no*10 + PIPE_NORM_OUTER_BODY;
			VMOVE( hits[*hit_count].hit_vpriv, hit_pt );
			hits[*hit_count].hit_vpriv[Z] = (-pipe->pipe_robase - hit_pt[Z] * pipe->pipe_rodiff) *
d630 1
d664 6
a669 4
				hits[*hit_count].hit_dist = t_tmp;
				hits[*hit_count].hit_surfno = seg_no*10 + PIPE_NORM_INNER_BODY;
				VMOVE( hits[*hit_count].hit_vpriv, hit_pt );
				hits[*hit_count].hit_vpriv[Z] = (-pipe->pipe_ribase - hit_pt[Z] * pipe->pipe_ridiff) *
d672 1
d679 6
a684 4
				hits[*hit_count].hit_dist = t_tmp;
				hits[*hit_count].hit_surfno = seg_no*10 + PIPE_NORM_INNER_BODY;
				VMOVE( hits[*hit_count].hit_vpriv, hit_pt );
				hits[*hit_count].hit_vpriv[Z] = (-pipe->pipe_ribase - hit_pt[Z] * pipe->pipe_ridiff) *
d687 137
d827 16
d844 3
a846 2
	if( NEAR_ZERO( ray_dir[Z], SMALL ) )
		goto out;
d848 15
a862 27
	/* Intersect with base plane */
	t_tmp = (-ray_start[Z]/ray_dir[Z]);
	VJOIN1( hit_pt, ray_start, t_tmp, ray_dir );
	radius_sq = hit_pt[X]*hit_pt[X] + hit_pt[Y]*hit_pt[Y];
	VJOIN1( hit_pt, rp->r_pt, t_tmp, rp->r_dir );
	if( radius_sq <= pipe->pipe_robase_sq && radius_sq >= pipe->pipe_ribase_sq )
	{
		hits[*hit_count].hit_dist = t_tmp;
		hits[*hit_count].hit_surfno = seg_no*10 + PIPE_NORM_BASE;
		(*hit_count)++;
	}

	/* Intersect with top plane */
	t_tmp = (1.0 - ray_start[Z])/ray_dir[Z];
	VJOIN1( hit_pt, ray_start, t_tmp, ray_dir );
	radius_sq = hit_pt[X]*hit_pt[X] + hit_pt[Y]*hit_pt[Y];
	VJOIN1( hit_pt, rp->r_pt, t_tmp, rp->r_dir );
	if( radius_sq <= pipe->pipe_rotop_sq && radius_sq >= pipe->pipe_ritop_sq )
	{
		hits[*hit_count].hit_dist = t_tmp;
		hits[*hit_count].hit_surfno = seg_no*10 + PIPE_NORM_TOP;
		(*hit_count)++;
	}

out:
	if( (*hit_count) == 1 )
		(*hit_count) = 0;
d867 1
a867 1
register struct hit h[];
d871 1
d874 25
a898 7
	for( i=0; i < (*nh)-1; i++ )  {
		for( j=i+1; j < (*nh); j++ )  {
			if( h[i].hit_dist <= h[j].hit_dist )
				continue;
			temp = h[j];		/* struct copy */
			h[j] = h[i];		/* struct copy */
			h[i] = temp;		/* struct copy */
d900 2
d905 2
a906 1
	for( i=0; i < (*nh)-1; i++ )
d908 5
a912 1
		if( NEAR_ZERO( h[i].hit_dist - h[i+1].hit_dist , 0.0001 ) )
d914 7
a920 2
			for( j=i ; j<(*nh)-1 ; j++ )
				h[j] = h[j+1];
d923 2
d928 7
d936 1
d957 3
a959 3
	register struct pipe_specific *head =
		(struct pipe_specific *)stp->st_specific;
	register struct pipe_specific *pipe;
d961 3
d968 12
a979 1
	for( RT_LIST_FOR( pipe, pipe_specific, &head->l ) )
a980 3
		LOCAL struct hit hits[8];
		LOCAL int hit_count=0;

d986 2
a987 1
				linear_pipe_shot( stp, rp, ap, seghead, pipe, hits, &hit_count, seg_no );
d991 3
d1001 3
a1003 2
		if( !hit_count )
			continue;
d1005 1
a1005 1
		rt_pipe_hitsort( hits, &hit_count );
d1007 6
a1012 2
		/* Build segments for this pipe segment */
		if( hit_count%2 )
d1014 1
a1014 4
			rt_log( "rt_pipe_shot: bad number of hits (%d)\n" , hit_count );
			for( i=0 ; i<hit_count ; i++ )
			{
				point_t hit_pt;
d1016 3
a1018 5
				rt_log( "#%d, dist = %g, surfno=%d\n" , i, hits[i].hit_dist, hits[i].hit_surfno );
				VJOIN1( hit_pt, rp->r_pt, hits[i].hit_dist,  rp->r_dir );
				rt_log( "\t( %g %g %g )\n" , V3ARGS( hit_pt ) );
			}
			rt_bomb( "rt_pipe_shot\n" );
d1020 11
d1032 3
a1034 2
		for( i=0 ; i<hit_count ; i += 2 )
		{
d1036 1
a1036 2
			RT_GET_SEG(segp, ap->a_resource);
			segp->seg_stp = stp;
d1038 2
a1039 2
			segp->seg_in = hits[i];
			segp->seg_out = hits[i+1];
d1041 6
a1046 2
			RT_LIST_INSERT( &(seghead->l), &(segp->l) );
		}
d1084 4
a1087 2
	register struct pipe_specific *pipe =
		(struct pipe_specific *)stp->st_specific;
d1094 1
a1094 1
		pipe = RT_LIST_PNEXT( pipe_specific, &pipe->l );
d1099 2
a1100 2
		case PIPE_NORM_TOP:
			VMOVE( hitp->hit_normal, pipe->pipe_H );
d1102 2
a1103 2
		case PIPE_NORM_BASE:
			VREVERSE( hitp->hit_normal, pipe->pipe_H );
d1105 2
a1106 2
		case PIPE_NORM_OUTER_BODY:
			MAT4X3VEC( hitp->hit_normal, pipe->pipe_invRoS, hitp->hit_vpriv );
d1109 2
a1110 2
		case PIPE_NORM_INNER_BODY:
			MAT4X3VEC( hitp->hit_normal, pipe->pipe_invRoS, hitp->hit_vpriv );
d1114 20
d1151 2
a1152 2
/*	register struct pipe_specific *pipe =
		(struct pipe_specific *)stp->st_specific; */
d1175 2
a1176 2
/*	register struct pipe_specific *pipe =
		(struct pipe_specific *)stp->st_specific; */
d1186 2
a1187 2
	register struct pipe_specific *pipe =
		(struct pipe_specific *)stp->st_specific;
d1190 1
a1190 1
	while( RT_LIST_NON_EMPTY( &pipe->l ) )
d1192 1
a1192 1
		register struct pipe_specific *pipe_ptr;
d1194 1
a1194 1
		pipe_ptr = RT_LIST_FIRST( pipe_specific, &pipe->l );
d1210 12
a1221 2
void
draw_pipe_circle( vhead, r, center, v1, v2, segments )
d1223 1
a1223 1
fastf_t			r;
d1226 3
a1228 1
int			segments;
d1230 1
a1230 4
	fastf_t		x;
	fastf_t		y;
	fastf_t		xnew;
	fastf_t		ynew;
d1232 3
a1234 2
	fastf_t		cos_delta;
	fastf_t		sin_delta;
d1238 8
a1245 2
	if( r <= 0.0 )
		return;
d1247 2
a1248 3
	delta_ang = 2.0*M_PI/segments;
	cos_delta = cos( delta_ang );
	sin_delta = sin( delta_ang );
d1250 1
a1250 1
	x = r;
d1252 1
a1252 1
	VJOIN1( pt, center, x, v1 );
d1254 1
a1254 1
	for( i=0 ; i<ARC_SEGS ; i++ )
d1256 5
a1260 2
		xnew = x*cos_delta - y*sin_delta;
		ynew = x*sin_delta + y*cos_delta;
a1265 4
	x = r;
	y = 0.0;
	VJOIN1( pt, center, x, v1 );
	RT_ADD_VLIST( vhead, pt, RT_VLIST_LINE_DRAW );
d1281 1
a1281 1
		draw_pipe_circle( vhead, r1, base_vertex, v1, v2, seg_count );
a1347 42
static void
draw_pipe_arc( vhead, r_start, r_end, center, v1, v2, start, end, seg_count )
struct rt_list		*vhead;
fastf_t			r_start,r_end;
point_t			center;
vect_t			v1,v2;
point_t			start,end;
int			seg_count;
{
	fastf_t		arc_angle;
	fastf_t		delta_ang;
	fastf_t		cos_del, sin_del;
	fastf_t		x, y, xnew, ynew;
	vect_t		to_end;
	point_t		pt;
	int		i;

	VSUB2( to_end, end, center );
	arc_angle = atan2( VDOT( to_end, v2 ), VDOT( to_end, v1 ) );
	delta_ang = arc_angle/seg_count;
	cos_del = cos( delta_ang );
	sin_del = sin( delta_ang );

	x = 1.0;
	y = 0.0;
	RT_ADD_VLIST( vhead, start, RT_VLIST_LINE_MOVE );
	for( i=0 ; i<seg_count ; i++ )
	{
		vect_t radial_dir;
		fastf_t local_radius;

		xnew = x*cos_del - y*sin_del;
		ynew = x*sin_del + y*cos_del;
		VBLEND2( radial_dir, xnew, v1, ynew, v2 );
		local_radius = r_start + (fastf_t)i/(fastf_t)(seg_count-1) * (r_end - r_start);
		VJOIN1( pt, center, local_radius, radial_dir );
		RT_ADD_VLIST( vhead, pt, RT_VLIST_LINE_DRAW );
		x = xnew;
		y = ynew;
	}
}

d1382 2
a1383 2
		LOCAL fastf_t radius1,radius2;
		LOCAL fastf_t inv_radius1,inv_radius2;
d1410 2
a1411 2
					draw_pipe_circle( vhead, psp->ps_od/2.0, psp->ps_start,
							v1, v2, ARC_SEGS );
d1413 13
a1425 2
					draw_pipe_circle( vhead, psp->ps_id/2.0, psp->ps_start,
							v1, v2, ARC_SEGS );
d1429 3
a1431 3
				radius1 = MAGNITUDE( v1 );
				inv_radius1 = 1.0/radius1;
				VSCALE( v1, v1, inv_radius1 );
d1434 1
a1434 3
				radius2 = MAGNITUDE( end_dir );
				inv_radius2 = 1.0/radius2;
				VSCALE( end_dir, end_dir, inv_radius2 );
d1437 2
a1438 2
				draw_pipe_arc( vhead, radius1+psp->ps_od/2.0, radius2+np->ps_od/2.0,
					psp->ps_bendcenter, v1, pipe_dir, start, end, ARC_SEGS );
d1441 3
a1443 3
				draw_pipe_arc( vhead, radius1-psp->ps_od/2.0, radius2-np->ps_od/2.0,
					psp->ps_bendcenter, v1, pipe_dir, start, end, ARC_SEGS );
				if( psp->ps_id > 0.0 || np->ps_id > 0.0 )
d1447 2
a1448 2
					draw_pipe_arc( vhead, radius1+psp->ps_id/2.0, radius2+np->ps_id/2.0,
						psp->ps_bendcenter, v1, pipe_dir, start, end, ARC_SEGS );
d1451 2
a1452 2
					draw_pipe_arc( vhead, radius1-psp->ps_id/2.0, radius2-np->ps_id/2.0,
						psp->ps_bendcenter, v1, pipe_dir, start, end, ARC_SEGS );
d1459 2
a1460 11
				VSUB2( v1, start, tmp_center );
				radius1 = MAGNITUDE( v1 );
				inv_radius1 = 1.0/radius1;
				VSCALE( v1, v1, inv_radius1 );
				VSUB2( v3, end, tmp_center );
				radius2 = MAGNITUDE( v3 );
				VCROSS( tmp_vec, v3, v1 );
				VCROSS( v3, v1, tmp_vec );
				VUNITIZE( v3 );
				draw_pipe_arc( vhead, radius1, radius2,
					tmp_center, v1, v3, start, end, ARC_SEGS );
d1465 2
a1466 11
				VSUB2( v1, start, tmp_center );
				radius1 = MAGNITUDE( v1 );
				inv_radius1 = 1.0/radius1;
				VSCALE( v1, v1, inv_radius1 );
				VSUB2( v3, end, tmp_center );
				radius2 = MAGNITUDE( v3 );
				VCROSS( tmp_vec, v3, v1 );
				VCROSS( v3, v1, tmp_vec );
				VUNITIZE( v3 );
				draw_pipe_arc( vhead, radius1, radius2,
					tmp_center, v1, v3, start, end, ARC_SEGS );
d1468 1
a1468 1
				if( psp->ps_id > 0.0 || np->ps_id > 0.0 )
d1473 2
a1474 11
					VSUB2( v1, start, tmp_center );
					radius1 = MAGNITUDE( v1 );
					inv_radius1 = 1.0/radius1;
					VSCALE( v1, v1, inv_radius1 );
					VSUB2( v3, end, tmp_center );
					radius2 = MAGNITUDE( v3 );
					VCROSS( tmp_vec, v3, v1 );
					VCROSS( v3, v1, tmp_vec );
					VUNITIZE( v3 );
					draw_pipe_arc( vhead, radius1, radius2,
						tmp_center, v1, v3, start, end, ARC_SEGS );
d1479 2
a1480 11
					VSUB2( v1, start, tmp_center );
					radius1 = MAGNITUDE( v1 );
					inv_radius1 = 1.0/radius1;
					VSCALE( v1, v1, inv_radius1 );
					VSUB2( v3, end, tmp_center );
					radius2 = MAGNITUDE( v3 );
					VCROSS( tmp_vec, v3, v1 );
					VCROSS( v3, v1, tmp_vec );
					VUNITIZE( v3 );
					draw_pipe_arc( vhead, radius1, radius2,
						tmp_center, v1, v3, start, end, ARC_SEGS );
d1490 2
a1491 2
					draw_pipe_circle( vhead, psp->ps_od/2.0,
						psp->ps_start, v1, v2, ARC_SEGS );
d1493 2
a1494 2
					draw_pipe_circle( vhead, psp->ps_id/2.0,
						psp->ps_start, v1, v2, ARC_SEGS );
d1768 115
@


11.1
log
@Release_4.4
@
text
@d19 1
a19 1
static char RCSpipe[] = "@@(#)$Header: /m/cad/librt/RCS/g_pipe.c,v 10.4 94/09/30 16:24:53 mike Exp $ (BRL)";
d37 2
d40 11
a50 1
	/* XXX more here */
d53 4
d80 1
a80 1
/*	register struct pipe_specific *pipe; */
d82 2
d89 107
a195 1
	return(-1);	/* unfinished */
d209 203
d430 1
a430 1
/*	register struct pipe_specific *pipe =
d432 49
a480 1
	register struct seg *segp; */
d482 14
a495 1
	return(0);			/* MISS */
d527 9
a535 2
/*	register struct pipe_specific *pipe =
		(struct pipe_specific *)stp->st_specific; */
d538 21
d610 11
a620 1
	rt_free( (char *)pipe, "pipe_specific" );
d631 165
d807 11
a817 6
	register struct wdb_pipeseg	*psp;
	register struct wdb_pipeseg	*np;
	struct rt_pipe_internal	*pip;
	vect_t		head, tail;
	point_t		pt;
	int		i;
d823 152
a974 30
	np = RT_LIST_FIRST(wdb_pipeseg, &pip->pipe_segs_head);
	RT_ADD_VLIST( vhead, np->ps_start, RT_VLIST_LINE_MOVE );
	for( RT_LIST_FOR( psp, wdb_pipeseg, &pip->pipe_segs_head ) )  {
		switch( psp->ps_type )  {
		case WDB_PIPESEG_TYPE_END:
			/* Previous segment aleady connected to end plate */
			break;
		case WDB_PIPESEG_TYPE_LINEAR:
			np = RT_LIST_PNEXT(wdb_pipeseg, &psp->l);
			RT_ADD_VLIST( vhead, np->ps_start, RT_VLIST_LINE_DRAW );
			break;
		case WDB_PIPESEG_TYPE_BEND:
			VSUB2( head, psp->ps_start, psp->ps_bendcenter );
			np = RT_LIST_PNEXT(wdb_pipeseg, &psp->l);
			VSUB2( tail, np->ps_start, psp->ps_bendcenter );
			for( i=0; i <= 4; i++ )  {
				double	ang;
				double	cos_ang, sin_ang;
				ang = rt_halfpi * i / 4.0;
				cos_ang = cos(ang);
				sin_ang = sin(ang);
				VJOIN2( pt, psp->ps_bendcenter,
					cos_ang, head,
					sin_ang, tail );
				RT_ADD_VLIST( vhead, pt, RT_VLIST_LINE_DRAW );
			}
			break;
		default:
			rt_log("rt_pipe_plot: unknown ps_type=%d\n", psp->ps_type);
			return(-1);
@


10.4
log
@Null out ip->idb_ptr after freeing memory in rt_*_ifree()
@
text
@d19 1
a19 1
static char RCSpipe[] = "@@(#)$Header: /m/cad/librt/RCS/g_pipe.c,v 10.3 94/08/10 18:38:35 gdurf Exp Locker: mike $ (BRL)";
@


10.3
log
@Added include of conf.h
@
text
@d19 1
a19 1
static char RCSpipe[] = "@@(#)$Header: /m/cad/librt/RCS/g_pipe.c,v 10.2 1993/03/03 00:55:52 mike Exp gdurf $ (BRL)";
d525 1
@


10.2
log
@Changed from RT_LIST to RT_LIST_FOR
@
text
@d19 1
a19 1
static char RCSpipe[] = "@@(#)$Header: /m/cad/librt/RCS/g_pipe.c,v 10.1 91/10/12 06:40:22 mike Rel4_0 Locker: mike $ (BRL)";
d21 2
@


10.1
log
@Release_4.0
@
text
@d19 1
a19 1
static char RCSpipe[] = "@@(#)$Header: /m/cad/librt/RCS/g_pipe.c,v 1.21 91/09/20 23:18:30 butler Exp $ (BRL)";
d227 1
a227 1
	for( RT_LIST( psp, wdb_pipeseg, &pip->pipe_segs_head ) )  {
d381 1
a381 1
	for( RT_LIST( psp, wdb_pipeseg, headp ) )  {
d415 1
a415 1
	for( RT_LIST( psp, wdb_pipeseg, headp ), eps++ )  {
@


1.21
log
@removing fuzz with lint
@
text
@d19 1
a19 1
static char RCSpipe[] = "@@(#)$Header: /m/cad/librt/RCS/g_pipe.c,v 1.20 91/08/29 22:22:55 mike Exp $ (BRL)";
@


1.20
log
@needed nmg.h
@
text
@d19 1
a19 1
static char RCSpipe[] = "@@(#)$Header: /m/cad/librt/RCS/g_pipe.c,v 1.19 91/07/19 03:52:00 mike Exp $ (BRL)";
d62 1
a62 1
	register struct pipe_specific *pipe;
a63 1
	int			i;
d79 2
a80 2
	register struct pipe_specific *pipe =
		(struct pipe_specific *)stp->st_specific;
d101 1
a101 1
	register struct pipe_specific *pipe =
d103 1
a103 1
	register struct seg *segp;
d137 2
a138 2
	register struct pipe_specific *pipe =
		(struct pipe_specific *)stp->st_specific;
d154 2
a155 2
	register struct pipe_specific *pipe =
		(struct pipe_specific *)stp->st_specific;
d178 2
a179 2
	register struct pipe_specific *pipe =
		(struct pipe_specific *)stp->st_specific;
@


1.19
log
@Fixed JRA version
@
text
@d19 1
a19 1
static char RCSpipe[] = "@@(#)$Header: /m/cad/librt/RCS/g_pipe.c,v 1.18 91/07/17 21:29:01 mike Exp $ (BRL)";
d29 1
@


1.18
log
@Eliminated extra call to rt_pipe_ifree().  Problem reported by JRA.
Also added an extra error print.
@
text
@d19 1
a19 1
static char RCSpipe[] = "@@(#)$Header: /m/cad/librt/RCS/g_pipe.c,v 1.17 91/06/30 00:10:56 mike Exp $ (BRL)";
a68 1
	rt_pipe_ifree( ip );
@


1.17
log
@Some args to ft_print, ft_import, and ft_export became CONST
@
text
@d19 1
a19 1
static char RCSpipe[] = "@@(#)$Header: /m/cad/librt/RCS/g_pipe.c,v 1.16 91/06/22 22:30:31 mike Exp $ (BRL)";
d254 1
a257 2

	rt_pipe_ifree( ip );
@


1.16
log
@Tolerance can be had from ap->a_rt_i->rti_tol, so it is no longer
passed as a parameter on ft_prep, ft_shot, or ft_vshot.
ft_vshot calling sequence also changed to use application structure.
@
text
@d19 1
a19 1
static char RCSpipe[] = "@@(#)$Header: /m/cad/librt/RCS/g_pipe.c,v 1.15 91/05/18 03:01:17 mike Exp $ (BRL)";
d78 1
a78 1
register struct soltab *stp;
d281 3
a283 3
struct rt_db_internal	*ip;
struct rt_external	*ep;
register mat_t		mat;
d360 3
a362 3
struct rt_external	*ep;
struct rt_db_internal	*ip;
double			local2mm;
@


1.15
log
@Converted to new tolerance interface
@
text
@d19 1
a19 1
static char RCSpipe[] = "@@(#)$Header: /m/cad/librt/RCS/g_pipe.c,v 1.14 91/02/27 19:51:53 mike Exp $ (BRL)";
d56 1
a56 1
rt_pipe_prep( stp, ip, rtip, tol )
a59 1
CONST struct rt_tol	*tol;
d96 1
a96 1
rt_pipe_shot( stp, rp, ap, seghead, tol )
a100 1
CONST struct rt_tol	*tol;
d106 1
a106 1
	return(2);			/* HIT */
d112 1
a112 1
 *			S P H _ V S H O T
d117 1
a117 1
rt_pipe_vshot( stp, rp, segp, n, resp, tol )
d122 1
a122 2
struct resource         *resp; /* pointer to a list of free segs */
CONST struct rt_tol	*tol;
d124 1
a124 1
	rt_vstub( stp, rp, segp, n, resp, tol );
@


1.14
log
@Chagned database format to use completely machine-independent format.
In this case, only the granule count was still in machine-specific format.
Also changed meaning of pw_count to be the number of EXTRA grans used.
(matching code change in db_scan).
@
text
@d19 1
a19 1
static char RCSpipe[] = "@@(#)$Header: /m/cad/librt/RCS/g_pipe.c,v 1.14 91/02/27 19:49:20 mike Exp $ (BRL)";
d56 1
a56 1
rt_pipe_prep( stp, ip, rtip )
d60 1
d97 1
a97 1
rt_pipe_shot( stp, rp, ap, seghead )
d102 1
d119 1
a119 1
rt_pipe_vshot( stp, rp, segp, n, resp)
d125 1
d127 1
a127 1
	rt_vstub( stp, rp, segp, n, resp );
d212 1
a212 1
rt_pipe_plot( vhead, ip, abs_tol, rel_tol, norm_tol )
d215 2
a216 3
double			abs_tol;
double			rel_tol;
double			norm_tol;
d269 1
a269 1
rt_pipe_tess( r, m, ip, abs_tol, rel_tol, norm_tol )
d273 2
a274 3
double			abs_tol;
double			rel_tol;
double			norm_tol;
@


1.13
log
@Converted to new struct rt_vlist (''chunky vlist'')
@
text
@d19 1
a19 1
static char RCSpipe[] = "@@(#)$Header: /m/cad/librt/RCS/g_pipe.c,v 1.12 91/01/26 03:14:54 mike Exp $ (BRL)";
d415 1
a415 1
	rec->pw.pw_count = ngran;
@


1.12
log
@Eliminated mat parameter on ft_plot and ft_tess
@
text
@d19 1
a19 1
static char RCSpipe[] = "@@(#)$Header: /m/cad/librt/RCS/g_pipe.c,v 1.11 91/01/25 21:52:13 mike Exp $ (BRL)";
d210 1
a210 1
struct vlhead		*vhead;
d228 1
a228 1
	ADD_VL( vhead, np->ps_start, 0 );
d236 1
a236 1
			ADD_VL( vhead, np->ps_start, 1 );
d251 1
a251 1
				ADD_VL( vhead, pt, 1 );
@


1.11
log
@lint
@
text
@d19 1
a19 1
static char RCSpipe[] = "@@(#)$Header: /m/cad/librt/RCS/g_pipe.c,v 1.10 91/01/25 21:19:13 mike Exp $ (BRL)";
d209 6
a214 7
rt_pipe_plot( vhead, mat, ip, abs_tol, rel_tol, norm_tol )
struct vlhead	*vhead;
mat_t		mat;
struct rt_db_internal *ip;
double		abs_tol;
double		rel_tol;
double		norm_tol;
d267 1
a267 1
rt_pipe_tess( r, m, ip, mat, abs_tol, rel_tol, norm_tol )
a270 1
mat_t			mat;
@


1.10
log
@Converted to new function switch table interface,
using separation between internal and external forms of geometry.
@
text
@d19 1
a19 1
static char RCSpipe[] = "@@(#)$Header: /m/cad/librt/RCS/g_pipe.c,v 1.9 91/01/25 20:36:03 mike Exp $ (BRL)";
d268 1
a268 1
rt_pipe_tess( r, m, rp, mat, dp, abs_tol, rel_tol, norm_tol )
d271 1
a271 1
union record		*rp;
a272 1
struct directory	*dp;
@


1.9
log
@Added rt_ prefix to _internal structure
@
text
@d19 1
a19 1
static char RCSpipe[] = "@@(#)$Header: /m/cad/librt/RCS/g_pipe.c,v 1.8 91/01/15 23:41:47 mike Exp $ (BRL)";
a54 1
#if NEW_IF
a60 10
#else
int
rt_pipe_prep( stp, rec, rtip )
struct soltab		*stp;
union record		*rec;
struct rt_i		*rtip;
{
	struct rt_external	ext, *ep;
	struct rt_db_internal	intern, *ip;
#endif
a64 14
#if NEW_IF
	/* All set */
#else
	ep = &ext;
	RT_INIT_EXTERNAL(ep);
	ep->ext_buf = (genptr_t)rec;
	ep->ext_nbytes = stp->st_dp->d_len*sizeof(union record);
	ip = &intern;
	i = rt_pipe_import( &intern, ep, stp->st_pathmat );
	if( i < 0 )  {
		rt_log("rt_pipe_setup(%s): db import failure\n", stp->st_name);
		return(-1);		/* BAD */
	}
#endif
a207 1
#if NEW_IF
a216 14
#else
int
rt_pipe_plot( rp, mat, vhead, dp, abs_tol, rel_tol, norm_tol )
union record	*rp;
mat_t		mat;
struct vlhead	*vhead;
struct directory *dp;
double		abs_tol;
double		rel_tol;
double		norm_tol;
{
	struct rt_external	ext, *ep;
	struct rt_db_internal	intern, *ip;
#endif
a223 14
#if NEW_IF
	/* All set */
#else
	ep = &ext;
	RT_INIT_EXTERNAL(ep);
	ep->ext_buf = (genptr_t)rp;
	ep->ext_nbytes = dp->d_len*sizeof(union record);
	i = rt_pipe_import( &intern, ep, mat );
	if( i < 0 )  {
		rt_log("rt_pipe_plot(): db import failure\n");
		return(-1);		/* BAD */
	}
	ip = &intern;
#endif
@


1.8
log
@Moved pipe_internal structure to rtgeom.h
@
text
@d19 1
a19 1
static char RCSpipe[] = "@@(#)$Header: /m/cad/librt/RCS/g_pipe.c,v 1.7 91/01/15 01:33:59 mike Exp $ (BRL)";
d73 1
a73 1
	struct pipe_internal	*pip;
d91 1
a91 1
	pip = (struct pipe_internal *)ip->idb_ptr;
d259 1
a259 1
	struct pipe_internal	*pip;
d279 1
a279 1
	pip = (struct pipe_internal *)ip->idb_ptr;
d347 1
a347 1
	struct pipe_internal		*pipe;
d379 2
a380 2
	ip->idb_ptr = rt_malloc( sizeof(struct pipe_internal), "pipe_internal");
	pipe = (struct pipe_internal *)ip->idb_ptr;
d423 1
a423 1
	struct pipe_internal	*pip;
d435 1
a435 1
	pip = (struct pipe_internal *)ip->idb_ptr;
d507 1
a507 1
	register struct pipe_internal	*pip;
d513 1
a513 1
	pip = (struct pipe_internal *)ip->idb_ptr;
d572 1
a572 1
	register struct pipe_internal	*pipe;
d576 1
a576 1
	pipe = (struct pipe_internal*)ip->idb_ptr;
@


1.7
log
@Fixed magic
@
text
@d19 1
a19 1
static char RCSpipe[] = "@@(#)$Header: /m/cad/librt/RCS/g_pipe.c,v 1.6 91/01/15 00:03:00 mike Exp $ (BRL)";
d30 1
a32 8
struct pipe_internal {
	int		pipe_magic;
	int		pipe_count;
	struct wdb_pipeseg pipe_segs;
};
#define RT_PIPE_INTERNAL_MAGIC	0x77ddbbe3
#define RT_PIPE_CK_MAGIC(_p)	RT_CKMAG(_p,RT_PIPE_INTERNAL_MAGIC,"pipe_internal")

d282 1
a282 1
	np = RT_LIST_FIRST(wdb_pipeseg, &pip->pipe_segs.l);
d284 1
a284 1
	for( RT_LIST( psp, wdb_pipeseg, &pip->pipe_segs.l ) )  {
d389 1
a389 1
	RT_LIST_INIT( &pipe->pipe_segs.l );
d408 1
a408 1
		RT_LIST_APPEND( &pipe->pipe_segs.l, &psp->l );
d424 1
a424 1
	struct wdb_pipeseg	*headp;
d438 1
a438 1
	headp = &pip->pipe_segs;
d442 1
a442 1
	for( RT_LIST( psp, wdb_pipeseg, &headp->l ) )  {
d446 1
a446 1
			if( RT_LIST_NEXT_NOT_HEAD( psp, &headp->l ) )
d451 1
a451 1
			if( RT_LIST_NEXT_IS_HEAD( psp, &headp->l ) )
d476 1
a476 1
	for( RT_LIST( psp, wdb_pipeseg, &headp->l ), eps++ )  {
d521 1
a521 1
	for( RT_LIST_FOR( psp, wdb_pipeseg, &pip->pipe_segs.l ) )  {
d579 1
a579 1
	while( RT_LIST_WHILE( psp, wdb_pipeseg, &pipe->pipe_segs.l ) )  {
@


1.6
log
@Added magic numbers, export routine, units conversion
@
text
@d19 1
a19 1
static char RCSpipe[] = "@@(#)$Header: /m/cad/librt/RCS/g_pipe.c,v 1.5 91/01/11 07:12:08 mike Exp $ (BRL)";
d388 1
@


1.5
log
@Changed to have new style import/export routines, and ft_describe
routine.
@
text
@d19 1
a19 1
static char RCSpipe[] = "@@(#)$Header: /m/cad/librt/RCS/g_pipe.c,v 1.4 91/01/11 04:03:28 mike Exp $ (BRL)";
d33 1
d37 2
d42 1
d99 1
d287 1
d424 1
a424 1
rt_pipe_export( ep, ip )
d427 1
d429 68
a496 1
	return(-1);
d507 1
a507 1
rt_pipe_describe( str, ip, verbose )
d511 1
d513 1
a513 2
	register struct pipe_internal	*pip =
		(struct pipe_internal *)ip->idb_ptr;
d519 2
d525 2
d544 1
a544 1
		sprintf(buf, "  od=%g", psp->ps_od );
d547 1
a547 1
			sprintf(buf, ", id  = %g", psp->ps_id );
d552 4
a555 1
		sprintf(buf, "\t  start=(%g, %g, %g)\n", V3ARGS(psp->ps_start) );
d560 3
a562 1
				V3ARGS(psp->ps_bendcenter) );
d570 2
a572 1
 *  XXX The suffix of this name is temporary.
d578 1
a578 2
	register struct pipe_internal	*pipe =
		(struct pipe_internal*)ip->idb_ptr;
d582 2
@


1.4
log
@Changed over to new import/export interface
@
text
@a0 1
#define NEW_IF	0
d19 1
a19 1
static char RCSpipe[] = "@@(#)$Header: /m/cad/librt/RCS/g_pipe.c,v 1.3 90/11/01 04:44:38 mike Exp $ (BRL)";
d60 1
a60 1
rt_pipe_prep( stp, ep, rtip )
d62 1
a62 1
struct rt_external	*ep;
d73 1
a75 1
	struct rt_db_internal	intern;
d86 1
a86 1
#endif
d92 3
a94 2
	RT_CK_DB_INTERNAL( &intern );
	pip = (struct pipe_internal *)intern.idb_ptr;
d96 1
a96 1
	rt_pipe_ifree( &intern );
d273 1
a273 1
	i = rt_part_import( &intern, ep, mat );
d275 1
a275 1
		rt_log("rt_part_plot(): db import failure\n");
@


1.3
log
@mods
@
text
@d1 1
d6 1
a6 1
 *	Intersect a ray with a 
d20 1
a20 1
static char RCSpipe[] = "@@(#)$Header: /m/cad/librt/RCS/g_pipe.c,v 1.2 90/10/12 20:50:03 mike Exp $ (BRL)";
d42 2
d59 1
d61 7
d73 2
d76 2
a77 1
	struct pipe_internal	pi;
d80 9
a88 7
	if( rec == (union record *)0 )  {
		rec = db_getmrec( rtip->rti_dbip, stp->st_dp );
		i = rt_pipe_import( &pi, rec, stp->st_pathmat );
		rt_free( (char *)rec, "pipe record" );
	} else {
		i = rt_pipe_import( &pi, rec, stp->st_pathmat );
	}
d93 2
d96 1
d235 1
d237 10
d256 3
d261 1
a261 1
	struct pipe_internal	pi;
d266 11
a276 3
	if( rt_pipe_import( &pi, rp, mat ) < 0 )  {
		rt_log("rt_pipe_plot(%s): db import failure\n", dp->d_namep);
		return(-1);
d278 4
d283 1
a283 1
	np = RT_LIST_FIRST(wdb_pipeseg, &pi.pipe_segs.l);
d285 1
a285 1
	for( RT_LIST( psp, wdb_pipeseg, &pi.pipe_segs.l ) )  {
d315 1
a315 1
	/* XXX Need to release storage here! */
d340 3
a342 3
rt_pipe_import( pipe, rp, mat )
struct pipe_internal	*pipe;
union record		*rp;
d345 1
a345 1
	register struct exported_pipeseg *ep;
d348 3
d352 2
d361 4
a364 4
	pipe->pipe_count = 0;
	for( ep = &rp->pw.pw_data[0]; ; ep++ )  {
		pipe->pipe_count++;
		switch( (int)(ep->eps_type[0]) )  {
d375 1
a375 1
	if( pipe->pipe_count <= 1 )
d378 6
d390 5
a394 5
	for( ep = &rp->pw.pw_data[pipe->pipe_count-1]; ep >= &rp->pw.pw_data[0]; ep-- )  {
		tmp.ps_type = (int)ep->eps_type[0];
		ntohd( tmp.ps_start, ep->eps_start, 3 );
		ntohd( &tmp.ps_id, ep->eps_id, 1 );
		ntohd( &tmp.ps_od, ep->eps_od, 1 );
d401 1
a401 1
			ntohd( tmp.ps_bendcenter, ep->eps_bendcenter, 3 );
d412 93
@


1.2
log
@Added import function, and elementary drawing routine.
@
text
@d19 1
a19 1
static char RCSpipe[] = "@@(#)$Header: /m/cad/librt/RCS/g_pipe.c,v 1.1 90/10/06 02:05:30 mike Exp $ (BRL)";
d27 1
d34 1
a34 1
	struct wdb_pipeseg *pipe_segs;
d227 1
d238 3
a240 2
	ADD_VL( vhead, pi.pipe_segs->ps_start, 0 );
	for( psp = pi.pipe_segs; psp != WDB_PIPESEG_NULL; psp = psp->ps_next )  {
d246 2
a247 1
			ADD_VL( vhead, psp->ps_next->ps_start, 1 );
d251 2
a252 1
			VSUB2( tail, psp->ps_next->ps_start, psp->ps_bendcenter );
d333 1
a333 1
	pipe->pipe_segs = WDB_PIPESEG_NULL;
d352 1
a352 2
		psp->ps_next = pipe->pipe_segs;
		pipe->pipe_segs = psp;
@


1.1
log
@Initial revision
@
text
@d32 2
a33 1
	vect_t	pipe_V;
d225 42
a266 1
	return(-1);
d296 2
a297 1
	int		count;
a298 1

d306 1
a306 1
	count = 0;
d308 1
a308 1
		count++;
d320 1
a320 1
	if( count <= 1 )
d323 3
a325 1
	/*  Allocate a linked list of segments in internal format,
d328 22
@
