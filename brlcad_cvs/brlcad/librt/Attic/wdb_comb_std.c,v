head	1.23;
access;
symbols
	ansi-20040405-merged:1.19.2.2
	postmerge-20040405-ansi:1.21
	premerge-20040404-ansi:1.20
	postmerge-autoconf:1.20
	autoconf-freeze:1.19.10.2
	premerge-autoconf:1.20
	ansi-20040316-freeze:1.19.2.1
	postmerge-20040315-windows:1.20
	premerge-20040315-windows:1.20
	windows-20040315-freeze:1.19.4.1
	autoconf-20031203:1.19
	autoconf-20031202:1.19
	autoconf-branch:1.19.0.10
	phong-branch:1.19.0.8
	photonmap-branch:1.19.0.6
	rel-6-1-DP:1.19
	windows-branch:1.19.0.4
	rel-6-0-2:1.17
	ansi-branch:1.19.0.2
	rel-6-0-1-branch:1.17.0.2
	hartley-6-0-post:1.18
	hartley-6-0-pre:1.17
	rel-6-0-1:1.17
	rel-6-0:1.17
	rel-5-4:1.6
	offsite-5-3-pre:1.10
	rel-5-3:1.6
	rel-5-2:1.6
	rel-5-1-branch:1.6.0.2
	rel-5-1:1.6;
locks; strict;
comment	@ * @;


1.23
date	2004.05.21.18.07.36;	author morrison;	state dead;
branches;
next	1.22;

1.22
date	2004.05.10.15.30.47;	author erikg;	state Exp;
branches;
next	1.21;

1.21
date	2004.04.05.08.48.58;	author morrison;	state Exp;
branches;
next	1.20;

1.20
date	2004.02.02.17.39.29;	author morrison;	state Exp;
branches;
next	1.19;

1.19
date	2002.08.20.17.08.11;	author jra;	state Exp;
branches
	1.19.2.1
	1.19.4.1
	1.19.10.1;
next	1.18;

1.18
date	2002.08.15.20.55.22;	author hartley;	state Exp;
branches;
next	1.17;

1.17
date	2002.01.09.19.58.18;	author jra;	state Exp;
branches;
next	1.16;

1.16
date	2002.01.08.20.49.39;	author jra;	state Exp;
branches;
next	1.15;

1.15
date	2001.10.02.19.24.31;	author jra;	state Exp;
branches;
next	1.14;

1.14
date	2001.09.07.17.03.00;	author bparker;	state Exp;
branches;
next	1.13;

1.13
date	2001.08.28.14.25.48;	author jra;	state Exp;
branches;
next	1.12;

1.12
date	2001.05.04.14.19.25;	author bparker;	state Exp;
branches;
next	1.11;

1.11
date	2001.03.23.22.05.30;	author jra;	state Exp;
branches;
next	1.10;

1.10
date	2000.09.08.05.54.43;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	2000.08.23.01.11.51;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	2000.07.10.23.01.52;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	2000.06.29.14.33.31;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	2000.03.04.05.15.39;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	2000.01.21.20.07.09;	author butler;	state Exp;
branches;
next	1.4;

1.4
date	2000.01.03.21.42.49;	author bparker;	state Exp;
branches;
next	1.3;

1.3
date	99.12.30.05.26.20;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	99.12.29.23.23.12;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	99.12.29.21.28.40;	author bparker;	state Exp;
branches;
next	;

1.19.2.1
date	2002.09.19.18.01.48;	author morrison;	state Exp;
branches;
next	1.19.2.2;

1.19.2.2
date	2004.03.17.21.19.01;	author morrison;	state Exp;
branches;
next	;

1.19.4.1
date	2004.03.11.23.43.47;	author morrison;	state Exp;
branches;
next	;

1.19.10.1
date	2004.02.12.18.37.48;	author erikg;	state Exp;
branches;
next	1.19.10.2;

1.19.10.2
date	2004.03.15.14.07.30;	author erikg;	state Exp;
branches;
next	;


desc
@@


1.23
log
@moved to src/
@
text
@/*			W D B _C O M B _ S T D . C
 *
 *	Code to implement the database objects "c" command
 *
 *  Author -
 *      John R. Anderson
 *
 *  Source -
 *      The U. S. Army Research Laboratory
 *      Aberdeen Proving Ground, Maryland  21005-5068  USA
 *
 *  Distribution Notice -
 *      Re-distribution of this software is restricted, as described in
 *      your "Statement of Terms and Conditions for the Release of
 *      The BRL-CAD Pacakge" agreement.
 *
 *  Copyright Notice -
 *      This software is Copyright (C) 1997-2004 by the United States Army
 *      in all countries except the USA.  All rights reserved.
 *
 */

#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/wdb_comb_std.c,v 1.22 2004/05/10 15:30:47 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "tcl.h"
#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "raytrace.h"
#include "rtgeom.h"

#define	PRINT_USAGE Tcl_AppendResult(interp, "c: usage 'c [-cr] comb_name [bool_expr]'\n",\
				     (char *)NULL)

struct tokens {
	struct bu_list		l;
	short			type;
	union tree		*tp;
};

/* token types */
#define	WDB_TOK_NULL	0
#define	WDB_TOK_LPAREN	1
#define	WDB_TOK_RPAREN	2
#define	WDB_TOK_UNION	3
#define	WDB_TOK_INTER	4
#define	WDB_TOK_SUBTR	5
#define	WDB_TOK_TREE	6

HIDDEN void
wdb_free_tokens(struct bu_list *hp)
{
	struct tokens *tok;

	BU_CK_LIST_HEAD(hp);

	while (BU_LIST_WHILE(tok, tokens, hp)) {
		BU_LIST_DEQUEUE(&tok->l);
		if (tok->type == WDB_TOK_TREE) {
			if (tok->tp)
				db_free_tree(tok->tp, &rt_uniresource);
		}
	}
}

HIDDEN void
wdb_append_union(struct bu_list *hp)
{
	struct tokens *tok;

	BU_CK_LIST_HEAD( hp );

	tok = (struct tokens *)bu_malloc(sizeof(struct tokens), "tok");
	tok->type = WDB_TOK_UNION;
	tok->tp = (union tree *)NULL;
	BU_LIST_INSERT(hp, &tok->l);
}

HIDDEN void
wdb_append_inter(struct bu_list *hp)
{
	struct tokens *tok;

	BU_CK_LIST_HEAD(hp);

	tok = (struct tokens *)bu_malloc(sizeof(struct tokens), "tok");
	tok->type = WDB_TOK_INTER;
	tok->tp = (union tree *)NULL;
	BU_LIST_INSERT( hp, &tok->l );
}

HIDDEN void
wdb_append_subtr(struct bu_list *hp)
{
	struct tokens *tok;

	BU_CK_LIST_HEAD(hp);

	tok = (struct tokens *)bu_malloc(sizeof(struct tokens), "tok");
	tok->type = WDB_TOK_SUBTR;
	tok->tp = (union tree *)NULL;
	BU_LIST_INSERT( hp, &tok->l );
}

HIDDEN void
wdb_append_lparen(struct bu_list *hp)
{
	struct tokens *tok;

	BU_CK_LIST_HEAD(hp);

	tok = (struct tokens *)bu_malloc(sizeof(struct tokens), "tok");
	tok->type = WDB_TOK_LPAREN;
	tok->tp = (union tree *)NULL;
	BU_LIST_INSERT( hp, &tok->l );
}

HIDDEN void
wdb_append_rparen(struct bu_list *hp)
{
	struct tokens *tok;

	BU_CK_LIST_HEAD(hp);

	tok = (struct tokens *)bu_malloc(sizeof(struct tokens), "tok");
	tok->type = WDB_TOK_RPAREN;
	tok->tp = (union tree *)NULL;
	BU_LIST_INSERT(hp, &tok->l);
}

HIDDEN int
wdb_add_operator(Tcl_Interp *interp, struct bu_list *hp, char ch, short int *last_tok)
{
	char illegal[2];

	BU_CK_LIST_HEAD(hp);

	switch( ch )
	{
		case 'u':
			wdb_append_union(hp);
			*last_tok = WDB_TOK_UNION;
			break;
		case '+':
			wdb_append_inter(hp);
			*last_tok = WDB_TOK_INTER;
			break;
		case '-':
			wdb_append_subtr(hp);
			*last_tok = WDB_TOK_SUBTR;
			break;
		default:
			illegal[0] = ch;
			illegal[1] = '\0';
			Tcl_AppendResult(interp, "Illegal operator: ", illegal,
				", aborting\n", (char *)NULL );
			wdb_free_tokens(hp);
			return TCL_ERROR;
	}
	return TCL_OK;
}

HIDDEN int
wdb_add_operand(Tcl_Interp *interp, struct bu_list *hp, char *name)
{
	char *ptr_lparen;
	char *ptr_rparen;
	int name_len;
	union tree *node;
	struct tokens *tok;

	BU_CK_LIST_HEAD(hp);

	ptr_lparen = strchr(name, '(');
	ptr_rparen = strchr(name, ')');

	RT_GET_TREE( node, &rt_uniresource );
	node->magic = RT_TREE_MAGIC;
	node->tr_op = OP_DB_LEAF;
	node->tr_l.tl_mat = (matp_t)NULL;
	if (ptr_lparen || ptr_rparen) {
		int tmp1,tmp2;

		if (ptr_rparen)
			tmp1 = ptr_rparen - name;
		else
			tmp1 = (-1);
		if (ptr_lparen)
			tmp2 = ptr_lparen - name;
		else
			tmp2 = (-1);

		if (tmp2 == (-1) && tmp1 > 0)
			name_len = tmp1;
		else if (tmp1 == (-1) && tmp2 > 0)
			name_len = tmp2;
		else if(tmp1 > 0 && tmp2 > 0) {
			if (tmp1 < tmp2)
				name_len = tmp1;
			else
				name_len = tmp2;
		}
		else {
			Tcl_AppendResult(interp, "Cannot determine length of operand name: ",
				name, ", aborting\n", (char *)NULL);
			return (0);
		}
	} else
		name_len = strlen( name );

	node->tr_l.tl_name = (char *)bu_malloc(name_len + 1, "node name");
	strncpy(node->tr_l.tl_name, name, name_len);
	node->tr_l.tl_name[name_len] = '\0';
	tok = (struct tokens *)bu_malloc(sizeof(struct tokens), "tok");
	tok->type = WDB_TOK_TREE;
	tok->tp = node;
	BU_LIST_INSERT(hp, &tok->l);
	return (name_len);
}

HIDDEN void
wdb_do_inter(struct bu_list *hp)
{
	struct tokens *tok;

	for (BU_LIST_FOR(tok, tokens, hp )) {
		struct tokens *prev, *next;
		union tree *tp;

		if (tok->type != WDB_TOK_INTER)
			continue;

		prev = BU_LIST_PREV( tokens, &tok->l );
		next = BU_LIST_NEXT( tokens, &tok->l );

		if (prev->type !=WDB_TOK_TREE || next->type != WDB_TOK_TREE)
			continue;

		/* this is an eligible intersection operation */
		tp = (union tree *)bu_malloc( sizeof( union tree ), "tp" );
		tp->magic = RT_TREE_MAGIC;
		tp->tr_b.tb_op = OP_INTERSECT;
		tp->tr_b.tb_regionp = (struct region *)NULL;
		tp->tr_b.tb_left = prev->tp;
		tp->tr_b.tb_right = next->tp;
		BU_LIST_DEQUEUE( &tok->l );
		bu_free( (char *)tok, "tok" );
		BU_LIST_DEQUEUE( &prev->l );
		bu_free( (char *)prev, "prev" );
		next->tp = tp;
		tok = next;
	}
}

HIDDEN void
wdb_do_union_subtr(struct bu_list *hp)
{
	struct tokens *tok;

	for(BU_LIST_FOR(tok, tokens, hp)) {
		struct tokens *prev, *next;
		union tree *tp;

		if (tok->type != WDB_TOK_UNION && tok->type != WDB_TOK_SUBTR)
			continue;

		prev = BU_LIST_PREV( tokens, &tok->l );
		next = BU_LIST_NEXT( tokens, &tok->l );

		if (prev->type !=WDB_TOK_TREE || next->type != WDB_TOK_TREE)
			continue;

		/* this is an eligible operation */
		tp = (union tree *)bu_malloc( sizeof( union tree ), "tp" );
		tp->magic = RT_TREE_MAGIC;
		if (tok->type == WDB_TOK_UNION)
			tp->tr_b.tb_op = OP_UNION;
		else
			tp->tr_b.tb_op = OP_SUBTRACT;
		tp->tr_b.tb_regionp = (struct region *)NULL;
		tp->tr_b.tb_left = prev->tp;
		tp->tr_b.tb_right = next->tp;
		BU_LIST_DEQUEUE(&tok->l);
		bu_free((char *)tok, "tok");
		BU_LIST_DEQUEUE(&prev->l);
		bu_free((char *)prev, "prev");
		next->tp = tp;
		tok = next;
	}
}

HIDDEN int
wdb_do_paren(struct bu_list *hp)
{
	struct tokens *tok;

	for (BU_LIST_FOR(tok, tokens, hp)) {
		struct tokens *prev, *next;

		if (tok->type != WDB_TOK_TREE)
			continue;

		prev = BU_LIST_PREV( tokens, &tok->l );
		next = BU_LIST_NEXT( tokens, &tok->l );

		if (prev->type !=WDB_TOK_LPAREN || next->type != WDB_TOK_RPAREN)
			continue;

		/* this is an eligible operand surrounded by parens */
		BU_LIST_DEQUEUE(&next->l);
		bu_free((char *)next, "next");
		BU_LIST_DEQUEUE(&prev->l);
		bu_free((char *)prev, "prev");
	}

	if (hp->forw == hp->back && hp->forw != hp)
		return 1;	/* done */
	else if (BU_LIST_IS_EMPTY(hp))
		return -1;	/* empty tree!!!! */
	else
		return 0;	/* more to do */
		
}

HIDDEN union tree *
wdb_eval_bool(struct bu_list *hp)
{
	int done=0;
	union tree *final_tree;
	struct tokens *tok;

	while (done != 1) {
		wdb_do_inter(hp);
		wdb_do_union_subtr(hp);
		done = wdb_do_paren(hp);
	}

	if (done == 1) {
		tok = BU_LIST_NEXT(tokens, hp);
		final_tree = tok->tp;
		BU_LIST_DEQUEUE(&tok->l);
		bu_free((char *)tok, "tok");
		return(final_tree);
	}

        return (union tree *)NULL;
}

HIDDEN int
wdb_check_syntax(Tcl_Interp *interp, struct db_i *dbip, struct bu_list *hp, char *comb_name, struct directory *dp)
{
	struct tokens *tok;
	int paren_count=0;
	int paren_error=0;
	int missing_exp=0;
	int missing_op=0;
	int op_count=0;
	int arg_count=0;
	int circular_ref=0;
	int errors=0;
	short last_tok=WDB_TOK_NULL;

	if(dbip == DBI_NULL)
	  return 0;

	for( BU_LIST_FOR( tok, tokens, hp ) )
	{
		switch( tok->type )
		{
			case WDB_TOK_LPAREN:
				paren_count++;
				if( last_tok == WDB_TOK_RPAREN )
					missing_op++;
				break;
			case WDB_TOK_RPAREN:
				paren_count--;
				if( last_tok == WDB_TOK_LPAREN )
					missing_exp++;
				break;
			case WDB_TOK_UNION:
			case WDB_TOK_SUBTR:
			case WDB_TOK_INTER:
				op_count++;
				break;
			case WDB_TOK_TREE:
				arg_count++;
				if( !dp && !strcmp( comb_name, tok->tp->tr_l.tl_name ) )
					circular_ref++;
				else if( db_lookup( dbip, tok->tp->tr_l.tl_name, LOOKUP_QUIET ) == DIR_NULL )
					Tcl_AppendResult(interp, "WARNING: '",
						tok->tp->tr_l.tl_name,
						"' does not actually exist\n", (char *)NULL );
				break;
		}
		if( paren_count < 0 )
			paren_error++;
		last_tok = tok->type;
	}

	if( paren_count || paren_error )
	{
		Tcl_AppendResult(interp, "ERROR: unbalanced parenthesis\n", (char *)NULL );
		errors++;
	}

	if( missing_exp )
	{
		Tcl_AppendResult(interp, "ERROR: empty parenthesis (missing expression)\n", (char *)NULL );
		errors++;
	}

	if( missing_op )
	{
		Tcl_AppendResult(interp, "ERROR: must have operator between ')('\n", (char *)NULL );
		errors++;
	}

	if( op_count != arg_count-1 )
	{
		Tcl_AppendResult(interp, "ERROR: mismatch of operators and operands\n", (char *)NULL );
		errors++;
	}

	if( circular_ref )
	{
		Tcl_AppendResult(interp, "ERROR: combination cannot reference itself during initial creation\n", (char *)NULL );
		errors++;
	}

	if( errors )
	{
		Tcl_AppendResult(interp, "\t---------aborting!\n", (char *)NULL );
		return( 1 );
	}

	return( 0 );
}

int
wdb_comb_std_cmd(struct rt_wdb	*wdbp,
		Tcl_Interp	*interp,
		int		argc,
		char 		**argv)
{
	char				*comb_name;
	int				ch;
	int				region_flag = -1;
	register struct directory	*dp;
    	struct rt_db_internal		intern;
	struct rt_comb_internal		*comb = NULL;
	struct tokens			tok_hd;
	struct tokens			*tok;
	short				last_tok;
	int				i;
	union tree			*final_tree;

	if (wdbp->dbip->dbi_read_only) {
		Tcl_AppendResult(interp, "Database is read-only!\n", (char *)NULL);
		return TCL_ERROR;
	}

	if (argc < 3 || RT_MAXARGS < argc) {
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "helplib_alias wdb_comb_std %s", argv[0]);
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	/* Parse options */
	bu_optind = 1;	/* re-init bu_getopt() */
	while ((ch = bu_getopt(argc, argv, "cgr?")) != EOF) {
		switch (ch) {
		case 'c':
		case 'g':
			region_flag = 0;
			break;
		case 'r':
			region_flag = 1;
			break;
		/* XXX How about -p and -v for FASTGEN? */
		case '?':
		default:
			PRINT_USAGE;
			return TCL_OK;
		}
	}
	argc -= (bu_optind + 1);
	argv += bu_optind;

	comb_name = *argv++;
	if (argc == -1) {
		PRINT_USAGE;
		return TCL_OK;
	}

	if ((region_flag != -1) && (argc == 0)) {
		/*
		 *	Set/Reset the REGION flag of an existing combination
		 */
		if ((dp = db_lookup(wdbp->dbip, comb_name, LOOKUP_NOISY)) == DIR_NULL)
			return TCL_ERROR;

		if (!(dp->d_flags & DIR_COMB)) {
			Tcl_AppendResult(interp, comb_name, " is not a combination\n", (char *)0 );
			return TCL_ERROR;
		}

		if (rt_db_get_internal(&intern, dp, wdbp->dbip, (fastf_t *)NULL, &rt_uniresource) < 0) {
			Tcl_AppendResult(interp, "Database read error, aborting\n", (char *)NULL);	
			return TCL_ERROR;
		}
		comb = (struct rt_comb_internal *)intern.idb_ptr;
		RT_CK_COMB(comb);

		if (region_flag) {
			if( !comb->region_flag ) {
				/* assign values from the defaults */
				comb->region_id = wdbp->wdb_item_default++;
				comb->aircode = wdbp->wdb_air_default;
				comb->GIFTmater = wdbp->wdb_mat_default;
				comb->los = wdbp->wdb_los_default;
			}
			comb->region_flag = 1;
		}
		else
			comb->region_flag = 0;

		if (rt_db_put_internal(dp, wdbp->dbip, &intern, &rt_uniresource) < 0) {
			rt_db_free_internal(&intern, &rt_uniresource);
			Tcl_AppendResult(interp, "Database write error, aborting\n", (char *)NULL);
			return TCL_ERROR;
		}

		return TCL_OK;
	}
	/*
	 *	At this point, we know we have a Boolean expression.
	 *	If the combination already existed and region_flag is -1,
	 *	then leave its region_flag alone.
	 *	If the combination didn't exist yet,
	 *	then pretend region_flag was 0.
	 *	Otherwise, make sure to set its c_flags according to region_flag.
	 */

	dp = db_lookup( wdbp->dbip, comb_name, LOOKUP_QUIET );
	if (dp != DIR_NULL) {
		Tcl_AppendResult(interp, "ERROR: ", comb_name, " already exists\n", (char *)0 );
		return TCL_ERROR;
	}

	/* parse Boolean expression */
	BU_LIST_INIT(&tok_hd.l);
	tok_hd.type = WDB_TOK_NULL;

	last_tok = WDB_TOK_LPAREN;
	for (i=0 ; i<argc ; i++) {
		char *ptr;

		ptr = argv[i];
		while (*ptr) {
			while (*ptr == '(' || *ptr == ')') {
				switch (*ptr) {
				case '(':
					wdb_append_lparen( &tok_hd.l );
					last_tok = WDB_TOK_LPAREN;
					break;
				case ')':
					wdb_append_rparen( &tok_hd.l );
					last_tok = WDB_TOK_RPAREN;
					break;
				}
				ptr++;
			}

			if (*ptr == '\0')
				continue;

			if (last_tok == WDB_TOK_RPAREN) {
				/* next token MUST be an operator */
				if (wdb_add_operator(interp, &tok_hd.l, *ptr, &last_tok) == TCL_ERROR) {
					wdb_free_tokens(&tok_hd.l);
					if (dp != DIR_NULL)
						rt_db_free_internal(&intern, &rt_uniresource);
					return TCL_ERROR;
				}
				ptr++;
			} else if (last_tok == WDB_TOK_LPAREN) {
				/* next token MUST be an operand */
				int name_len;

				name_len = wdb_add_operand(interp, &tok_hd.l, ptr );
				if (name_len < 1) {
					wdb_free_tokens(&tok_hd.l);
					if (dp != DIR_NULL)
						rt_db_free_internal(&intern, &rt_uniresource);
					return TCL_ERROR;
				}
				last_tok = WDB_TOK_TREE;
				ptr += name_len;
			} else if (last_tok == WDB_TOK_TREE) {
				/* must be an operator */
				if (wdb_add_operator(interp, &tok_hd.l, *ptr, &last_tok) == TCL_ERROR) {
					wdb_free_tokens(&tok_hd.l);
					if (dp != DIR_NULL)
						rt_db_free_internal(&intern, &rt_uniresource);
					return TCL_ERROR;
				}
				ptr++;
			} else if (last_tok == WDB_TOK_UNION ||
				   last_tok == WDB_TOK_INTER ||
				   last_tok == WDB_TOK_SUBTR) {
				/* must be an operand */
				int name_len;

				name_len = wdb_add_operand(interp, &tok_hd.l, ptr );
				if (name_len < 1) {
					wdb_free_tokens(&tok_hd.l);
					if (dp != DIR_NULL)
						rt_db_free_internal(&intern, &rt_uniresource);
					return TCL_ERROR;
				}
				last_tok = WDB_TOK_TREE;
				ptr += name_len;
			}
		}
	}

	if (wdb_check_syntax(interp, wdbp->dbip, &tok_hd.l, comb_name, dp)) {
		wdb_free_tokens(&tok_hd.l);
		return TCL_ERROR;
	}

	/* replace any occurences of comb_name with existing tree */
	if (dp != DIR_NULL) {
		for (BU_LIST_FOR(tok, tokens, &tok_hd.l)) {
			struct rt_db_internal intern1;
			struct rt_comb_internal *comb1;

			switch (tok->type) {
			case WDB_TOK_LPAREN:
			case WDB_TOK_RPAREN:
			case WDB_TOK_UNION:
			case WDB_TOK_INTER:
			case WDB_TOK_SUBTR:
				break;
			case WDB_TOK_TREE:
				if (!strcmp(tok->tp->tr_l.tl_name, comb_name)) {
					db_free_tree( tok->tp, &rt_uniresource );
					if (rt_db_get_internal(&intern1, dp, wdbp->dbip, (fastf_t *)NULL, &rt_uniresource) < 0) {
						Tcl_AppendResult(interp, "Cannot get records for ", comb_name, "\n" );
						Tcl_AppendResult(interp, "Database read error, aborting\n", (char *)NULL);
						return TCL_ERROR;
					}
					comb1 = (struct rt_comb_internal *)intern1.idb_ptr;
					RT_CK_COMB(comb1);

					tok->tp = comb1->tree;
					comb1->tree = (union tree *)NULL;
					rt_db_free_internal(&intern1, &rt_uniresource);
				}
				break;
			default:
				Tcl_AppendResult(interp, "ERROR: Unrecognized token type\n", (char *)NULL);
				wdb_free_tokens(&tok_hd.l);
				return TCL_ERROR;
			}
		}
	}

	final_tree = wdb_eval_bool(&tok_hd.l);

	if (dp == DIR_NULL) {
		int flags;

		flags = DIR_COMB;
		BU_GETSTRUCT(comb, rt_comb_internal);
		comb->magic = RT_COMB_MAGIC;
		comb->tree = final_tree;
		bu_vls_init(&comb->shader);
		bu_vls_init(&comb->material);
		comb->region_id = -1;
		if (region_flag == (-1))
			comb->region_flag = 0;
		else
			comb->region_flag = region_flag;

		if (comb->region_flag) {
			struct bu_vls tmp_vls;

			comb->region_flag = 1;
			comb->region_id = wdbp->wdb_item_default++;;
			comb->aircode = wdbp->wdb_air_default;
			comb->los = wdbp->wdb_los_default;
			comb->GIFTmater = wdbp->wdb_mat_default;
			bu_vls_init(&tmp_vls);
			bu_vls_printf(&tmp_vls,
				"Creating region id=%d, air=%d, los=%d, GIFTmaterial=%d\n",
				comb->region_id, comb->aircode, comb->los, comb->GIFTmater);
			Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
			bu_vls_free(&tmp_vls);

			flags |= DIR_REGION;
		}

		RT_INIT_DB_INTERNAL(&intern);
		intern.idb_major_type = DB5_MAJORTYPE_BRLCAD;
		intern.idb_type = ID_COMBINATION;
		intern.idb_meth = &rt_functab[ID_COMBINATION];
		intern.idb_ptr = (genptr_t)comb;

		if ((dp=db_diradd(wdbp->dbip, comb_name, -1L, 0, flags, (genptr_t)&intern.idb_type)) == DIR_NULL) {
			Tcl_AppendResult(interp, "Failed to add ", comb_name,
					 " to directory, aborting\n" , (char *)NULL);
			return TCL_ERROR;
		}

		if (rt_db_put_internal(dp, wdbp->dbip, &intern, &rt_uniresource) < 0) {
			Tcl_AppendResult(interp, "Failed to write ", dp->d_namep, (char *)NULL );
			return TCL_ERROR;
		}
	} else {
		db_delete(wdbp->dbip, dp);

		dp->d_len = 0;
		dp->d_un.file_offset = -1;
		db_free_tree(comb->tree, &rt_uniresource);
		comb->tree = final_tree;

		if (rt_db_put_internal(dp, wdbp->dbip, &intern, &rt_uniresource) < 0) {
			Tcl_AppendResult(interp, "Failed to write ", dp->d_namep, (char *)NULL );
			return TCL_ERROR;
		}
	}

	return TCL_OK;
}

/*
 * Input a combination in standard set-theoretic notation.
 *
 * Usage:
 *        procname c [-gr] comb_name boolean_expr
 *
 * NON-PARALLEL because of rt_uniresource
 */
int
wdb_comb_std_tcl(ClientData	clientData,
		 Tcl_Interp	*interp,
		 int     	argc,
		 char    	**argv)
{
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;

	return wdb_comb_std_cmd(wdbp, interp, argc-1, argv+1);
}
@


1.22
log
@change conf.h to a wrapped config.h
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/librt/wdb_comb_std.c,v 1.21 2004/04/05 08:48:58 morrison Exp $ (BRL)";
@


1.21
log
@merge of ansi-6-0-branch into HEAD
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d27 5
a31 1
#include "conf.h"
@


1.20
log
@update copyright to include span through 2003
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_comb_std.c,v 1.19 2002/08/20 17:08:11 jra Exp $ (BRL)";
d62 1
a62 2
wdb_free_tokens(hp)
     struct bu_list *hp;
d78 1
a78 2
wdb_append_union(hp)
     struct bu_list *hp;
d91 1
a91 2
wdb_append_inter(hp)
     struct bu_list *hp;
d104 1
a104 2
wdb_append_subtr(hp)
     struct bu_list *hp;
d117 1
a117 2
wdb_append_lparen(hp)
     struct bu_list *hp;
d130 1
a130 2
wdb_append_rparen(hp)
     struct bu_list *hp;
d143 1
a143 5
wdb_add_operator(interp, hp, ch, last_tok)
     Tcl_Interp *interp;
     struct bu_list *hp;
     char ch;
     short *last_tok;
d175 1
a175 4
wdb_add_operand(interp, hp, name)
     Tcl_Interp *interp;
     struct bu_list *hp;
     char *name;
d233 1
a233 2
wdb_do_inter(hp)
     struct bu_list *hp;
d267 1
a267 2
wdb_do_union_subtr(hp)
     struct bu_list *hp;
d304 1
a304 2
wdb_do_paren(hp)
     struct bu_list *hp;
d337 1
a337 2
wdb_eval_bool(hp)
     struct bu_list *hp;
d361 1
a361 6
wdb_check_syntax(interp, dbip, hp, comb_name, dp)
     Tcl_Interp *interp;
     struct db_i *dbip;
     struct bu_list *hp;
     char *comb_name;
     struct directory *dp;
@


1.19
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d18 1
a18 1
 *      This software is Copyright (C) 1997 by the United States Army
d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_comb_std.c,v 1.17 2002/01/09 19:58:18 jra Exp $ (BRL)";
@


1.19.4.1
log
@sync to HEAD...
@
text
@d18 1
a18 1
 *      This software is Copyright (C) 1997-2004 by the United States Army
d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/wdb_comb_std.c,v 1.20 2004/02/02 17:39:29 morrison Exp $ (BRL)";
@


1.19.10.1
log
@merge from HEAD
@
text
@d18 1
a18 1
 *      This software is Copyright (C) 1997-2004 by the United States Army
d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_comb_std.c,v 1.20 2004/02/02 17:39:29 morrison Exp $ (BRL)";
@


1.19.10.2
log
@merge from head
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_comb_std.c,v 1.19.10.1 2004/02/12 18:37:48 erikg Exp $ (BRL)";
@


1.19.2.1
log
@Initial ANSIfication
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_comb_std.c,v 1.19 2002/08/20 17:08:11 jra Exp $ (BRL)";
d62 2
a63 1
wdb_free_tokens(struct bu_list *hp)
d79 2
a80 1
wdb_append_union(struct bu_list *hp)
d93 2
a94 1
wdb_append_inter(struct bu_list *hp)
d107 2
a108 1
wdb_append_subtr(struct bu_list *hp)
d121 2
a122 1
wdb_append_lparen(struct bu_list *hp)
d135 2
a136 1
wdb_append_rparen(struct bu_list *hp)
d149 5
a153 1
wdb_add_operator(Tcl_Interp *interp, struct bu_list *hp, char ch, short int *last_tok)
d185 4
a188 1
wdb_add_operand(Tcl_Interp *interp, struct bu_list *hp, char *name)
d246 2
a247 1
wdb_do_inter(struct bu_list *hp)
d281 2
a282 1
wdb_do_union_subtr(struct bu_list *hp)
d319 2
a320 1
wdb_do_paren(struct bu_list *hp)
d353 2
a354 1
wdb_eval_bool(struct bu_list *hp)
d378 6
a383 1
wdb_check_syntax(Tcl_Interp *interp, struct db_i *dbip, struct bu_list *hp, char *comb_name, struct directory *dp)
@


1.19.2.2
log
@sync branch with HEAD
@
text
@d18 1
a18 1
 *      This software is Copyright (C) 1997-2004 by the United States Army
d24 1
a24 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


1.18
log
@Converted from K&R to ANSI C - RFH
@
text
@d62 2
a63 1
wdb_free_tokens(struct bu_list *hp)
d79 2
a80 1
wdb_append_union(struct bu_list *hp)
d93 2
a94 1
wdb_append_inter(struct bu_list *hp)
d107 2
a108 1
wdb_append_subtr(struct bu_list *hp)
d121 2
a122 1
wdb_append_lparen(struct bu_list *hp)
d135 2
a136 1
wdb_append_rparen(struct bu_list *hp)
d149 5
a153 1
wdb_add_operator(Tcl_Interp *interp, struct bu_list *hp, char ch, short int *last_tok)
d185 4
a188 1
wdb_add_operand(Tcl_Interp *interp, struct bu_list *hp, char *name)
d246 2
a247 1
wdb_do_inter(struct bu_list *hp)
d281 2
a282 1
wdb_do_union_subtr(struct bu_list *hp)
d319 2
a320 1
wdb_do_paren(struct bu_list *hp)
d353 2
a354 1
wdb_eval_bool(struct bu_list *hp)
d378 6
a383 1
wdb_check_syntax(Tcl_Interp *interp, struct db_i *dbip, struct bu_list *hp, char *comb_name, struct directory *dp)
@


1.17
log
@Undo previous mod (not needed)
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_comb_std.c,v 1.16 2002/01/08 20:49:39 jra Exp $ (BRL)";
d62 1
a62 2
wdb_free_tokens(hp)
     struct bu_list *hp;
d78 1
a78 2
wdb_append_union(hp)
     struct bu_list *hp;
d91 1
a91 2
wdb_append_inter(hp)
     struct bu_list *hp;
d104 1
a104 2
wdb_append_subtr(hp)
     struct bu_list *hp;
d117 1
a117 2
wdb_append_lparen(hp)
     struct bu_list *hp;
d130 1
a130 2
wdb_append_rparen(hp)
     struct bu_list *hp;
d143 1
a143 5
wdb_add_operator(interp, hp, ch, last_tok)
     Tcl_Interp *interp;
     struct bu_list *hp;
     char ch;
     short *last_tok;
d175 1
a175 4
wdb_add_operand(interp, hp, name)
     Tcl_Interp *interp;
     struct bu_list *hp;
     char *name;
d233 1
a233 2
wdb_do_inter(hp)
     struct bu_list *hp;
d267 1
a267 2
wdb_do_union_subtr(hp)
     struct bu_list *hp;
d304 1
a304 2
wdb_do_paren(hp)
     struct bu_list *hp;
d337 1
a337 2
wdb_eval_bool(hp)
     struct bu_list *hp;
d361 1
a361 6
wdb_check_syntax(interp, dbip, hp, comb_name, dp)
     Tcl_Interp *interp;
     struct db_i *dbip;
     struct bu_list *hp;
     char *comb_name;
     struct directory *dp;
@


1.16
log
@wdb_comb_std_cmd() now handles long names
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_comb_std.c,v 1.15 2001/10/02 19:24:31 jra Exp $ (BRL)";
d709 3
d737 2
d747 4
a750 17
		if( wdbp->dbip->dbi_version < 5 ) {
			if ((dp=db_diradd(wdbp->dbip, comb_name, -1L, 0, DIR_COMB, (genptr_t)&intern.idb_type)) == DIR_NULL) {
				Tcl_AppendResult(interp, "Failed to add ", comb_name,
						 " to directory, aborting\n" , (char *)NULL);
				return TCL_ERROR;
			}
		} else {
			struct bu_attribute_value_set avs;

			bu_avs_init( &avs, 1, "avs" );
			if ((dp = db_diradd5(wdbp->dbip, comb_name, -1L, intern.idb_major_type, intern.idb_type, (unsigned char)'\0', 0, &avs )) == DIR_NULL)  {
				bu_avs_free( &avs );
				Tcl_AppendResult(interp, "An error has occured while adding '",
						 comb_name, "' to the database.\n", (char *)NULL);
				return TCL_ERROR;
			}
			bu_avs_free( &avs );
@


1.15
log
@Routines were not setting idb_major_type in the internal structure
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_comb_std.c,v 1.14 2001/09/07 17:03:00 bparker Exp $ (BRL)";
d742 17
a758 4
		if ((dp=db_diradd(wdbp->dbip, comb_name, -1L, 0, DIR_COMB, (genptr_t)&intern.idb_type)) == DIR_NULL) {
			Tcl_AppendResult(interp, "Failed to add ", comb_name,
					 " to directory, aborting\n" , (char *)NULL);
			return TCL_ERROR;
@


1.14
log
@*- use helplib_alias instead of helplib
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_comb_std.c,v 1.13 2001/08/28 14:25:48 jra Exp $ (BRL)";
d737 1
@


1.13
log
@"c" command now has a "-c" option. It now assigns region values from region defaults
when changing a combination into a region. Also now removes the "region" attribute
when changing a region into a combination.
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_comb_std.c,v 1.12 2001/05/04 14:19:25 bparker Exp $ (BRL)";
d499 1
a499 1
	  bu_vls_printf(&vls, "helplib wdb_comb_std");
@


1.12
log
@*- import more MGED commands into librt
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_comb_std.c,v 1.11 2001/03/23 22:05:30 jra Exp $ (BRL)";
d43 1
a43 1
#define	PRINT_USAGE Tcl_AppendResult(interp, "c: usage 'c [-gr] comb_name [bool_expr]'\n",\
d507 1
a507 1
	while ((ch = bu_getopt(argc, argv, "gr?")) != EOF) {
d509 1
d551 8
a558 1
		if (region_flag)
d560 1
@


1.11
log
@Support for major and minor types in directory structure
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/librt/wdb_comb_std.c,v 1.10 2000/09/08 05:54:43 mike Exp $ (BRL)";
a471 9

/*
 * Input a combination in standard set-theoretic notation.
 *
 * Usage:
 *        procname c [-gr] comb_name boolean_expr
 *
 * NON-PARALLEL because of rt_uniresource
 */
d473 4
a476 5
wdb_comb_std_tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int     argc;
     char    **argv;
a477 1
	struct rt_wdb *wdbp = (struct rt_wdb *)clientData;
d495 1
a495 1
	if (argc < 4 || RT_MAXARGS < argc){
d506 1
a506 1
	bu_optind = 2;	/* re-init bu_getopt() */
d757 19
@


1.10
log
@
Modified tree routines to take resource pointer.
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_comb_std.c,v 1.9 2000/08/23 01:11:51 mike Exp $ (BRL)";
d743 1
a743 1
		if ((dp=db_diradd(wdbp->dbip, comb_name, -1L, 0, DIR_COMB, NULL)) == DIR_NULL) {
@


1.9
log
@
lint
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_comb_std.c,v 1.8 2000/07/10 23:01:52 mike Exp $ (BRL)";
d73 1
a73 1
				db_free_tree(tok->tp);
d201 1
a201 1
	BU_GETUNION(node, tree);
d478 2
d554 1
a554 1
		if (rt_db_get_internal(&intern, dp, wdbp->dbip, (fastf_t *)NULL) < 0) {
d566 2
a567 2
		if (rt_db_put_internal(dp, wdbp->dbip, &intern) < 0) {
			rt_db_free_internal(&intern);
d621 1
a621 1
						rt_db_free_internal(&intern);
d633 1
a633 1
						rt_db_free_internal(&intern);
d643 1
a643 1
						rt_db_free_internal(&intern);
d657 1
a657 1
						rt_db_free_internal(&intern);
d686 2
a687 2
					db_free_tree( tok->tp );
					if (rt_db_get_internal(&intern1, dp, wdbp->dbip, (fastf_t *)NULL) < 0) {
d697 1
a697 1
					rt_db_free_internal(&intern1);
d749 1
a749 1
		if (rt_db_put_internal(dp, wdbp->dbip, &intern) < 0) {
d758 1
a758 1
		db_free_tree(comb->tree);
d761 1
a761 1
		if (rt_db_put_internal(dp, wdbp->dbip, &intern) < 0) {
@


1.8
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_comb_std.c,v 1.7 2000/06/29 14:33:31 mike Exp $ (BRL)";
d38 1
d492 1
a492 3
	struct rt_comb_internal		*comb;
	extern int			bu_optind;
	extern char			*bu_optarg;
@


1.7
log
@
Changed to use rt_db_free_internal()
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_comb_std.c,v 1.6 2000/03/04 05:15:39 mike Exp $ (BRL)";
@


1.6
log
@
Modified to note FASTGEN plate/volume mode as possible future extension.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_comb_std.c,v 1.5 2000/01/21 20:07:09 butler Exp $ (BRL)";
d566 1
a566 1
			rt_comb_ifree(&intern);
d620 1
a620 1
						rt_comb_ifree(&intern);
d632 1
a632 1
						rt_comb_ifree(&intern);
d642 1
a642 1
						rt_comb_ifree(&intern);
d656 1
a656 1
						rt_comb_ifree(&intern);
d696 1
a696 1
					rt_comb_ifree(&intern1);
@


1.5
log
@Removed unused variables
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_comb_std.c,v 1.4 2000/01/03 21:42:49 bparker Exp $ (BRL)";
d525 1
d576 1
a576 1
	 *	then leave its c_flags alone.
@


1.4
log
@*- merged "struct wdb_obj" into "struct rt_wdb"
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_comb_std.c,v 1.3 1999/12/30 05:26:20 mike Exp $ (BRL)";
a324 1
		union tree *tp;
a593 2
		char *ptr_next;
		union tree *node;
@


1.3
log
@
Added additional fields to wdb_obj struct, to kill global variables.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_comb_std.c,v 1.2 1999/12/29 23:23:12 mike Exp $ (BRL)";
d486 1
a486 1
	struct wdb_obj *wdbop = (struct wdb_obj *)clientData;
d501 1
a501 1
	if (wdbop->wdb_wp->dbip->dbi_read_only) {
d545 1
a545 1
		if ((dp = db_lookup(wdbop->wdb_wp->dbip, comb_name, LOOKUP_NOISY)) == DIR_NULL)
d553 1
a553 1
		if (rt_db_get_internal(&intern, dp, wdbop->wdb_wp->dbip, (fastf_t *)NULL) < 0) {
d565 1
a565 1
		if (rt_db_put_internal(dp, wdbop->wdb_wp->dbip, &intern) < 0) {
d582 1
a582 1
	dp = db_lookup( wdbop->wdb_wp->dbip, comb_name, LOOKUP_QUIET );
d667 1
a667 1
	if (wdb_check_syntax(interp, wdbop->wdb_wp->dbip, &tok_hd.l, comb_name, dp)) {
d688 1
a688 1
					if (rt_db_get_internal(&intern1, dp, wdbop->wdb_wp->dbip, (fastf_t *)NULL) < 0) {
d727 4
a730 4
			comb->region_id = wdbop->wdb_item_default++;;
			comb->aircode = wdbop->wdb_air_default;
			comb->los = wdbop->wdb_los_default;
			comb->GIFTmater = wdbop->wdb_mat_default;
d744 1
a744 1
		if ((dp=db_diradd(wdbop->wdb_wp->dbip, comb_name, -1L, 0, DIR_COMB, NULL)) == DIR_NULL) {
d750 1
a750 1
		if (rt_db_put_internal(dp, wdbop->wdb_wp->dbip, &intern) < 0) {
d755 1
a755 1
		db_delete(wdbop->wdb_wp->dbip, dp);
d762 1
a762 1
		if (rt_db_put_internal(dp, wdbop->wdb_wp->dbip, &intern) < 0) {
@


1.2
log
@
db_scan() got a client_data argument, which
db_diradd() needed to learn to ignore.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb_comb_std.c,v 1.1 1999/12/29 21:28:40 bparker Exp $ (BRL)";
a43 5
/* default region ident codes */
extern int wdb_item_default;	/* GIFT region ID */
extern int wdb_air_default;
extern int wdb_mat_default;		/* GIFT material code */
extern int wdb_los_default;	/* Line-of-sight estimate */
d727 4
a730 4
			comb->region_id = wdb_item_default++;;
			comb->aircode = wdb_air_default;
			comb->los = wdb_los_default;
			comb->GIFTmater = wdb_mat_default;
@


1.1
log
@*- import comb_std.c from MGED into librt
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/comb_std.c,v 1.20 1999/11/26 23:03:31 mike Exp $ (BRL)";
d749 1
a749 1
		if ((dp=db_diradd(wdbop->wdb_wp->dbip, comb_name, -1L, 0, DIR_COMB)) == DIR_NULL) {
@

