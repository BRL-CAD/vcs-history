head	11.32;
access;
symbols
	ansi-20040405-merged:11.28.2.2
	postmerge-20040405-ansi:11.30
	premerge-20040404-ansi:11.29
	postmerge-autoconf:11.29
	autoconf-freeze:11.28.10.2
	premerge-autoconf:11.29
	ansi-20040316-freeze:11.28.2.1
	postmerge-20040315-windows:11.29
	premerge-20040315-windows:11.29
	windows-20040315-freeze:11.28.4.1
	autoconf-20031203:11.28
	autoconf-20031202:11.28
	autoconf-branch:11.28.0.10
	phong-branch:11.28.0.8
	photonmap-branch:11.28.0.6
	rel-6-1-DP:11.28
	windows-branch:11.28.0.4
	rel-6-0-2:11.26
	ansi-branch:11.28.0.2
	rel-6-0-1-branch:11.26.0.2
	hartley-6-0-post:11.27
	hartley-6-0-pre:11.26
	rel-6-0-1:11.26
	rel-6-0:11.26
	rel-5-4:11.21
	offsite-5-3-pre:11.23
	rel-5-3:11.21
	rel-5-2:11.21
	rel-5-1-branch:11.21.0.2
	rel-5-1:11.21
	rel-5-0:11.16
	rel-5-0-beta:11.14
	rel-4-5:11.14
	ctj-4-5-post:11.14
	ctj-4-5-pre:11.14
	rel-4-4:11.1;
locks; strict;
comment	@ * @;


11.32
date	2004.05.21.18.07.33;	author morrison;	state dead;
branches;
next	11.31;

11.31
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.30;

11.30
date	2004.04.05.08.48.57;	author morrison;	state Exp;
branches;
next	11.29;

11.29
date	2004.02.02.17.39.23;	author morrison;	state Exp;
branches;
next	11.28;

11.28
date	2002.08.20.17.08.04;	author jra;	state Exp;
branches
	11.28.2.1
	11.28.4.1
	11.28.10.1;
next	11.27;

11.27
date	2002.08.15.20.55.15;	author hartley;	state Exp;
branches;
next	11.26;

11.26
date	2001.05.17.20.05.25;	author morrison;	state Exp;
branches;
next	11.25;

11.25
date	2001.04.05.19.35.35;	author morrison;	state Exp;
branches;
next	11.24;

11.24
date	2001.04.02.21.38.10;	author morrison;	state Exp;
branches;
next	11.23;

11.23
date	2000.10.18.18.10.35;	author butler;	state Exp;
branches;
next	11.22;

11.22
date	2000.07.10.23.01.41;	author mike;	state Exp;
branches;
next	11.21;

11.21
date	2000.04.01.03.04.42;	author mike;	state Exp;
branches;
next	11.20;

11.20
date	2000.04.01.01.17.53;	author mike;	state Exp;
branches;
next	11.19;

11.19
date	2000.03.28.22.39.59;	author mike;	state Exp;
branches;
next	11.18;

11.18
date	2000.03.28.22.11.15;	author mike;	state Exp;
branches;
next	11.17;

11.17
date	99.12.30.15.46.53;	author jra;	state Exp;
branches;
next	11.16;

11.16
date	99.07.02.22.19.25;	author mike;	state Exp;
branches;
next	11.15;

11.15
date	99.06.03.01.43.37;	author mike;	state Exp;
branches;
next	11.14;

11.14
date	97.07.22.17.04.13;	author jra;	state Exp;
branches;
next	11.13;

11.13
date	97.06.16.15.37.42;	author jra;	state Exp;
branches;
next	11.12;

11.12
date	97.01.14.13.18.23;	author jra;	state Exp;
branches;
next	11.11;

11.11
date	97.01.07.16.08.21;	author jra;	state Exp;
branches;
next	11.10;

11.10
date	96.09.27.08.27.30;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	96.06.11.17.28.42;	author jra;	state Exp;
branches;
next	11.8;

11.8
date	95.02.24.23.50.11;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	95.02.21.23.11.51;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	95.02.19.21.02.55;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	95.02.17.22.02.08;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	95.02.15.22.43.10;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	95.02.10.16.26.18;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	95.01.20.19.17.42;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.57.38;	author mike;	state Rel4_4;
branches;
next	1.69;

1.69
date	95.01.04.08.00.59;	author mike;	state Exp;
branches;
next	1.68;

1.68
date	94.11.04.12.17.37;	author jra;	state Exp;
branches;
next	1.67;

1.67
date	94.11.04.07.01.18;	author mike;	state Exp;
branches;
next	1.66;

1.66
date	94.09.16.23.36.55;	author mike;	state Exp;
branches;
next	1.65;

1.65
date	94.09.16.20.52.53;	author mike;	state Exp;
branches;
next	1.64;

1.64
date	94.09.16.20.45.45;	author mike;	state Exp;
branches;
next	1.63;

1.63
date	94.09.12.22.41.51;	author mike;	state Exp;
branches;
next	1.62;

1.62
date	94.09.10.23.02.21;	author jra;	state Exp;
branches;
next	1.61;

1.61
date	94.09.10.04.36.48;	author mike;	state Exp;
branches;
next	1.60;

1.60
date	94.09.03.03.01.20;	author mike;	state Exp;
branches;
next	1.59;

1.59
date	94.09.02.01.14.45;	author mike;	state Exp;
branches;
next	1.58;

1.58
date	94.09.02.00.31.59;	author mike;	state Exp;
branches;
next	1.57;

1.57
date	94.08.24.20.57.17;	author butler;	state Exp;
branches;
next	1.56;

1.56
date	94.08.09.19.37.46;	author mike;	state Exp;
branches;
next	1.55;

1.55
date	94.07.02.02.39.25;	author mike;	state Exp;
branches;
next	1.54;

1.54
date	94.07.01.23.37.14;	author mike;	state Exp;
branches;
next	1.53;

1.53
date	94.06.29.23.25.07;	author mike;	state Exp;
branches;
next	1.52;

1.52
date	94.06.29.22.40.29;	author mike;	state Exp;
branches;
next	1.51;

1.51
date	94.06.29.00.24.30;	author mike;	state Exp;
branches;
next	1.50;

1.50
date	94.06.29.00.05.01;	author mike;	state Exp;
branches;
next	1.49;

1.49
date	94.06.28.22.03.18;	author mike;	state Exp;
branches;
next	1.48;

1.48
date	94.06.24.00.04.34;	author butler;	state Exp;
branches;
next	1.47;

1.47
date	94.05.04.16.22.28;	author jra;	state Exp;
branches;
next	1.46;

1.46
date	94.04.24.22.43.18;	author mike;	state Exp;
branches;
next	1.45;

1.45
date	94.04.20.20.13.04;	author mike;	state Exp;
branches;
next	1.44;

1.44
date	94.04.19.07.17.50;	author mike;	state Exp;
branches;
next	1.43;

1.43
date	94.04.14.07.30.01;	author mike;	state Exp;
branches;
next	1.42;

1.42
date	94.03.18.03.30.20;	author mike;	state Exp;
branches;
next	1.41;

1.41
date	94.03.11.23.07.11;	author mike;	state Exp;
branches;
next	1.40;

1.40
date	94.03.11.19.36.08;	author mike;	state Exp;
branches;
next	1.39;

1.39
date	94.03.11.02.03.53;	author mike;	state Exp;
branches;
next	1.38;

1.38
date	94.03.02.18.06.14;	author mike;	state Exp;
branches;
next	1.37;

1.37
date	94.02.04.03.43.06;	author mike;	state Exp;
branches;
next	1.36;

1.36
date	94.01.25.09.44.38;	author mike;	state Exp;
branches;
next	1.35;

1.35
date	94.01.25.09.19.37;	author mike;	state Exp;
branches;
next	1.34;

1.34
date	94.01.25.08.46.06;	author mike;	state Exp;
branches;
next	1.33;

1.33
date	94.01.23.05.14.23;	author mike;	state Exp;
branches;
next	1.32;

1.32
date	94.01.23.04.18.39;	author mike;	state Exp;
branches;
next	1.31;

1.31
date	94.01.22.05.14.15;	author mike;	state Exp;
branches;
next	1.30;

1.30
date	94.01.13.18.58.09;	author mike;	state Exp;
branches;
next	1.29;

1.29
date	94.01.12.02.50.33;	author mike;	state Exp;
branches;
next	1.28;

1.28
date	93.12.23.23.12.53;	author mike;	state Exp;
branches;
next	1.27;

1.27
date	93.12.23.05.42.11;	author mike;	state Exp;
branches;
next	1.26;

1.26
date	93.12.22.06.14.48;	author mike;	state Exp;
branches;
next	1.25;

1.25
date	93.12.16.05.33.57;	author mike;	state Exp;
branches;
next	1.24;

1.24
date	93.12.14.18.47.16;	author mike;	state Exp;
branches;
next	1.23;

1.23
date	93.11.12.23.41.37;	author mike;	state Exp;
branches;
next	1.22;

1.22
date	93.11.12.23.13.31;	author mike;	state Exp;
branches;
next	1.21;

1.21
date	93.10.24.09.06.33;	author mike;	state Exp;
branches;
next	1.20;

1.20
date	93.10.22.22.28.15;	author mike;	state Exp;
branches;
next	1.19;

1.19
date	93.09.30.20.56.00;	author mike;	state Exp;
branches;
next	1.18;

1.18
date	93.07.23.16.28.29;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	93.07.20.22.46.52;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	93.07.20.21.27.10;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	93.07.20.21.16.30;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	93.06.02.10.38.11;	author jra;	state Exp;
branches;
next	1.13;

1.13
date	93.05.12.17.42.36;	author cjohnson;	state Exp;
branches;
next	1.12;

1.12
date	93.04.08.03.18.09;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	93.04.03.04.39.49;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	93.04.03.01.59.12;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	93.04.02.23.25.35;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	93.04.02.03.00.22;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	93.04.02.02.30.04;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	93.03.27.00.54.39;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	93.03.26.23.39.33;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	93.03.26.23.22.14;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	93.03.26.23.00.06;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	93.03.26.22.06.21;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	93.03.26.21.09.13;	author mike;	state Exp;
branches;
next	;

11.28.2.1
date	2002.09.19.18.01.39;	author morrison;	state Exp;
branches;
next	11.28.2.2;

11.28.2.2
date	2004.03.17.21.18.52;	author morrison;	state Exp;
branches;
next	;

11.28.4.1
date	2004.03.11.23.43.41;	author morrison;	state Exp;
branches;
next	;

11.28.10.1
date	2004.02.12.18.37.43;	author erikg;	state Exp;
branches;
next	11.28.10.2;

11.28.10.2
date	2004.03.15.14.07.26;	author erikg;	state Exp;
branches;
next	;


desc
@Routines to answer questions about NMG data structures
@


11.32
log
@moved to src/
@
text
@/*
 *			N M G _ I N F O . C
 *
 *  A companion module to nmg_mod.c which contains routines to
 *  answer questions about n-Manifold Geometry data structures.
 *  None of these routines will modify the NMG structures in any way.
 *
 *  Authors -
 *	Michael John Muuss
 *	Lee A. Butler
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Pacakge" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1993-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/nmg_info.c,v 11.31 2004/05/10 15:30:46 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif


#include <stdio.h>
#ifdef HAVE_STRING_H
#include <string.h>
#endif
#include <math.h>
#include "machine.h"
#include "vmath.h"
#include "nmg.h"
#include "raytrace.h"

/************************************************************************
 *									*
 *				MODEL Routines				*
 *									*
 ************************************************************************/

/*
 *			N M G _ F I N D _ M O D E L
 *
 *  Given a pointer to the magic number in any NMG data structure,
 *  return a pointer to the model structure that contains that NMG item.
 *
 *  The reason for the register variable is to leave the argument variable
 *  unmodified;  this may aid debugging in event of a core dump.
 */
struct model *
nmg_find_model(const long int *magic_p_arg)
{
	register const long	*magic_p = magic_p_arg;

top:
	if( magic_p == (long *)0 )  {
		bu_log("nmg_find_model(x%x) enountered null pointer\n",
			magic_p_arg );
		rt_bomb("nmg_find_model() null pointer\n");
		/* NOTREACHED */
	}

	switch( *magic_p )  {
	case NMG_MODEL_MAGIC:
		return( (struct model *)magic_p );
	case NMG_REGION_MAGIC:
		return( ((struct nmgregion *)magic_p)->m_p );
	case NMG_SHELL_MAGIC:
		return( ((struct shell *)magic_p)->r_p->m_p );
	case NMG_FACEUSE_MAGIC:
		magic_p = &((struct faceuse *)magic_p)->s_p->l.magic;
		goto top;
	case NMG_FACE_MAGIC:
		magic_p = &((struct face *)magic_p)->fu_p->l.magic;
		goto top;
	case NMG_LOOP_MAGIC:
		magic_p = ((struct loop *)magic_p)->lu_p->up.magic_p;
		goto top;
	case NMG_LOOPUSE_MAGIC:
		magic_p = ((struct loopuse *)magic_p)->up.magic_p;
		goto top;
	case NMG_EDGE_MAGIC:
		magic_p = ((struct edge *)magic_p)->eu_p->up.magic_p;
		goto top;
	case NMG_EDGEUSE_MAGIC:
		magic_p = ((struct edgeuse *)magic_p)->up.magic_p;
		goto top;
	case NMG_VERTEX_MAGIC:
		magic_p = &(BU_LIST_FIRST(vertexuse,
			&((struct vertex *)magic_p)->vu_hd)->l.magic);
		goto top;
	case NMG_VERTEXUSE_MAGIC:
		magic_p = ((struct vertexuse *)magic_p)->up.magic_p;
		goto top;

	default:
		bu_log("nmg_find_model() can't get model for magic=x%x (%s)\n",
			*magic_p, bu_identify_magic( *magic_p ) );
		rt_bomb("nmg_find_model() failure\n");
	}
	return( (struct model *)NULL );
}

void
nmg_model_bb(fastf_t *min_pt, fastf_t *max_pt, const struct model *m)
{
	struct nmgregion *r;
	register int i;

	NMG_CK_MODEL(m);

	min_pt[0] = min_pt[1] = min_pt[2] = MAX_FASTF;
	max_pt[0] = max_pt[1] = max_pt[2] = -MAX_FASTF;

	for (BU_LIST_FOR(r, nmgregion, &m->r_hd)) {
		NMG_CK_REGION(r);
		NMG_CK_REGION_A(r->ra_p);

		for (i=0 ; i < 3 ; i++) {
			if (min_pt[i] > r->ra_p->min_pt[i])
				min_pt[i] = r->ra_p->min_pt[i];
			if (max_pt[i] < r->ra_p->max_pt[i])
				max_pt[i] = r->ra_p->max_pt[i];
		}
	}
}

/************************************************************************
 *									*
 *				SHELL Routines				*
 *									*
 ************************************************************************/

/*
 *			N M G _ S H E L L _ I S _ E M P T Y
 *
 *  See if this is an invalid shell
 *  i.e., one that has absolutely nothing in it,
 *  not even a lone vertexuse.
 *
 *  Returns -
 *	1	yes, it is completely empty
 *	0	no, not empty
 */
int
nmg_shell_is_empty(register const struct shell *s)
{

	NMG_CK_SHELL(s);

	if( BU_LIST_NON_EMPTY( &s->fu_hd ) )  return 0;
	if( BU_LIST_NON_EMPTY( &s->lu_hd ) )  return 0;
	if( BU_LIST_NON_EMPTY( &s->eu_hd ) )  return 0;
	if( s->vu_p )  return 0;
	return 1;
}

/*				N M G _ F I N D _ S _ O F _ L U
 *
 *	return parent shell for loopuse
 *	formerly nmg_lups().
 */
struct shell *
nmg_find_s_of_lu(const struct loopuse *lu)
{
	if (*lu->up.magic_p == NMG_SHELL_MAGIC) return(lu->up.s_p);
	else if (*lu->up.magic_p != NMG_FACEUSE_MAGIC) 
		rt_bomb("nmg_find_s_of_lu() bad parent for loopuse\n");

	return(lu->up.fu_p->s_p);
}

/*				N M G _ F I N D _ S _ O F _ E U
 *
 *	return parent shell of edgeuse
 *	formerly nmg_eups().
 */
struct shell *
nmg_find_s_of_eu(const struct edgeuse *eu)
{
	if (*eu->up.magic_p == NMG_SHELL_MAGIC) return(eu->up.s_p);
	else if (*eu->up.magic_p != NMG_LOOPUSE_MAGIC)
		rt_bomb("nmg_find_s_of_eu() bad parent for edgeuse\n");

	return(nmg_find_s_of_lu(eu->up.lu_p));
}

/*
 *			N M G _ F I N D _ S _ O F _ V U
 *
 *  Return parent shell of vertexuse
 */
struct shell *
nmg_find_s_of_vu(const struct vertexuse *vu)
{
	NMG_CK_VERTEXUSE(vu);

	if( *vu->up.magic_p == NMG_LOOPUSE_MAGIC )
		return nmg_find_s_of_lu( vu->up.lu_p );
	return nmg_find_s_of_eu( vu->up.eu_p );
}

/************************************************************************
 *									*
 *				FACE Routines				*
 *									*
 ************************************************************************/

/*
 *			N M G _ F I N D _ F U _ O F _ E U
 *
 *	return a pointer to the faceuse that is the super-parent of this
 *	edgeuse.  If edgeuse has no grandparent faceuse, return NULL.
 */
struct faceuse *
nmg_find_fu_of_eu(const struct edgeuse *eu)
{
	NMG_CK_EDGEUSE(eu);

	if (*eu->up.magic_p == NMG_LOOPUSE_MAGIC &&
		*eu->up.lu_p->up.magic_p == NMG_FACEUSE_MAGIC)
			return eu->up.lu_p->up.fu_p;

	return (struct faceuse *)NULL;			
}

/*
 *			N M G _ F I N D _ F U _ O F _ L U
 */
struct faceuse *
nmg_find_fu_of_lu(const struct loopuse *lu)
{
	switch (*lu->up.magic_p) {
	case NMG_FACEUSE_MAGIC:
		return lu->up.fu_p;
	case NMG_SHELL_MAGIC:
		return (struct faceuse *)NULL;
	default:
	    bu_log("Error at %s %d:\nInvalid loopuse parent magic (0x%x %d)\n",
		__FILE__, __LINE__, *lu->up.magic_p, *lu->up.magic_p);
	    rt_bomb("nmg_find_fu_of_lu() giving up on loopuse");
	}
	return (struct faceuse *)NULL;
}


/*	N M G _ F I N D _ F U _ O F _ V U
 *
 *	return a pointer to the parent faceuse of the vertexuse
 *	or a null pointer if vu is not a child of a faceuse.
 */
struct faceuse *
nmg_find_fu_of_vu(const struct vertexuse *vu)
{
	NMG_CK_VERTEXUSE(vu);

	switch (*vu->up.magic_p) {
	case NMG_LOOPUSE_MAGIC:
		return nmg_find_fu_of_lu( vu->up.lu_p );
	case NMG_SHELL_MAGIC:
		if (rt_g.NMG_debug & DEBUG_BASIC) bu_log("nmg_find_fu_of_vu(vu=x%x) vertexuse is child of shell, can't find faceuse\n", vu);
		return ((struct faceuse *)NULL);
	case NMG_EDGEUSE_MAGIC:
		switch (*vu->up.eu_p->up.magic_p) {
		case NMG_LOOPUSE_MAGIC:
			return nmg_find_fu_of_lu( vu->up.eu_p->up.lu_p );
		case NMG_SHELL_MAGIC:
			if (rt_g.NMG_debug & DEBUG_BASIC) bu_log("nmg_find_fu_of_vu(vu=x%x) vertexuse is child of shell/edgeuse, can't find faceuse\n", vu);
			return ((struct faceuse *)NULL);
		}
		bu_log("Error at %s %d:\nInvalid loopuse parent magic 0x%x\n",
			__FILE__, __LINE__, *vu->up.lu_p->up.magic_p);
		abort();
		break;
	default:
		bu_log("Error at %s %d:\nInvalid vertexuse parent magic 0x%x\n",
			__FILE__, __LINE__,
			*vu->up.magic_p);
		abort();
		break;
	}
	bu_log("How did I get here %s %d?\n", __FILE__, __LINE__);
	rt_bomb("nmg_find_fu_of_vu()\n");
	return ((struct faceuse *)NULL);
}
/*
 *			N M G _ F I N D _ F U _ W I T H _ F G _ I N _ S
 *
 *  Find a faceuse in shell s1 that shares the face_g_plane structure with
 *  fu2 and has the same orientation.
 *  This may be an OT_OPPOSITE faceuse, depending on orientation.
 *  Returns NULL if no such faceuse can be found in s1.
 *  fu2 may be in s1, or in some other shell.
 */
struct faceuse *
nmg_find_fu_with_fg_in_s(const struct shell *s1, const struct faceuse *fu2)
{
	struct faceuse		*fu1;
	struct face		*f2;
	register struct face_g_plane	*fg2;

	NMG_CK_SHELL(s1);
	NMG_CK_FACEUSE(fu2);

	f2 = fu2->f_p;
	NMG_CK_FACE(f2);
	fg2 = f2->g.plane_p;
	NMG_CK_FACE_G_PLANE(fg2);

	for( BU_LIST_FOR( fu1, faceuse, &s1->fu_hd ) )  {
		register struct face	*f1;
		register struct	face_g_plane	*fg1;
		int			flip1, flip2;

		NMG_CK_FACEUSE(fu1);
		f1 = fu1->f_p;
		NMG_CK_FACE(f1);
		fg1 = fu1->f_p->g.plane_p;
		NMG_CK_FACE_G_PLANE(fg1);

		if( fg1 != fg2 )  continue;

		if( fu1 == fu2 || fu1->fumate_p == fu2 )  continue;

		/* Face geometry matches, select fu1 or it's mate */
		flip1 = (fu1->orientation != OT_SAME) != (f1->flip != 0);
		flip2 = (fu2->orientation != OT_SAME) != (f2->flip != 0);
		if( flip1 == flip2 )  return fu1;
		return fu1->fumate_p;
	}
	return (struct faceuse *)NULL;
}

/*
 *			N M G _ M E A S U R E _ F U _ A N G L E
 *
 *  Return the angle in radians from the interior portion of the faceuse
 *  associated with edgeuse 'eu', measured in the coordinate system
 *  defined by xvec and yvec, which are known to be perpendicular to
 *  each other, and to the edge vector.
 *
 *  This is done by finding the "left-ward" vector for the edge in the
 *  face, which points into the interior of the face, and measuring
 *  the angle it forms relative to xvec and yvec.
 *
 *  Wire edges are indicated by always returning angle of -pi.
 *  That will be the only case for negative returns.
 */
double
nmg_measure_fu_angle(const struct edgeuse *eu, const fastf_t *xvec, const fastf_t *yvec, const fastf_t *zvec)
{
	vect_t			left;
	double			ret;

	NMG_CK_EDGEUSE(eu);
	if( *eu->up.magic_p != NMG_LOOPUSE_MAGIC )  return -bn_pi;

	if( nmg_find_eu_leftvec( left, eu ) < 0 )  return -bn_pi;

	ret = bn_angle_measure( left, xvec, yvec );
	return ret;
}

/************************************************************************
 *									*
 *				LOOP Routines				*
 *									*
 ************************************************************************/

/*
 *			N M G _ F I N D _ L U _ O F _ V U
 */
struct loopuse *
nmg_find_lu_of_vu(const struct vertexuse *vu)
{
	NMG_CK_VERTEXUSE( vu );
	if ( *vu->up.magic_p == NMG_LOOPUSE_MAGIC )
		return vu->up.lu_p;

	if ( *vu->up.magic_p == NMG_SHELL_MAGIC )
		return (struct loopuse *)NULL;

	NMG_CK_EDGEUSE( vu->up.eu_p );

	if ( *vu->up.eu_p->up.magic_p == NMG_SHELL_MAGIC )
		return (struct loopuse *)NULL;

	NMG_CK_LOOPUSE( vu->up.eu_p->up.lu_p );

	return vu->up.eu_p->up.lu_p;
}

/*
 *			N M G _ L O O P _ I S _ A _ C R A C K
 *
 *  A "crack" is defined as a loop which has no area.
 *
 *  Example of a non-trivial "crack" loop:
 *
 *	                 <---- eu4 -----
 *	               C ############### D
 *	             | # ^ ---- eu3 --->
 *	             | # |
 *	           eu5 # eu2
 *	             | # |
 *	  <--- eu6 --V # |
 *	A ############ B 
 *	  --- eu1 ---->
 *
 *
 *  Returns -
 *	 0	Loop is not a "crack"
 *	!0	Loop *is* a "crack"
 */
int
nmg_loop_is_a_crack(const struct loopuse *lu)
{
	struct edgeuse	*cur_eu;
	struct edgeuse	*cur_eumate;
	struct vertexuse *cur_vu;
	struct vertex	*cur_v;
	struct vertexuse *next_vu;
	struct vertex	*next_v;
	struct faceuse	*fu;
	struct vertexuse *test_vu;
	struct edgeuse	*test_eu;
	struct loopuse	*test_lu;
	int		ret = 0;

	NMG_CK_LOOPUSE(lu);
	if( *lu->up.magic_p != NMG_FACEUSE_MAGIC )  {
	    	if (rt_g.NMG_debug & DEBUG_BASIC)  bu_log("lu up is not faceuse\n");
		ret = 0;
		goto out;
	}
	fu = lu->up.fu_p;
	NMG_CK_FACEUSE(fu);

	if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )  {
	    	if (rt_g.NMG_debug & DEBUG_BASIC)  bu_log("lu down is not edgeuse\n");
		ret = 0;
		goto out;
	}

	/*
	 *  For every edgeuse, see if there is another edgeuse from 'lu',
	 *  radial around this edge, which is not this edgeuse's mate.
	 */
	for( BU_LIST_FOR( cur_eu, edgeuse, &lu->down_hd ) )  {
		NMG_CK_EDGEUSE(cur_eu);
		cur_eumate = cur_eu->eumate_p;
		NMG_CK_EDGEUSE(cur_eumate);
		cur_vu = cur_eu->vu_p;
		NMG_CK_VERTEXUSE(cur_vu);
		cur_v = cur_vu->v_p;
		NMG_CK_VERTEX(cur_v);

		next_vu = cur_eumate->vu_p;
		NMG_CK_VERTEXUSE(next_vu);
		next_v = next_vu->v_p;
		NMG_CK_VERTEX(next_v);
		/* XXX It might be more efficient to walk the radial list */
		/* See if the next vertex has an edge pointing back to cur_v */
		for( BU_LIST_FOR( test_vu, vertexuse, &next_v->vu_hd ) )  {
			if( *test_vu->up.magic_p != NMG_EDGEUSE_MAGIC )  continue;
			test_eu = test_vu->up.eu_p;
			NMG_CK_EDGEUSE(test_eu);
			if( test_eu == cur_eu )  continue;	/* skip self */
			if( test_eu == cur_eumate )  continue;	/* skip mates */
			if( *test_eu->up.magic_p != NMG_LOOPUSE_MAGIC )  continue;
			test_lu = test_eu->up.lu_p;
			if( test_lu != lu )  continue;
			/* Check departing edgeuse's NEXT vertex */
			if( test_eu->eumate_p->vu_p->v_p == cur_v )  goto match;
		}
		/* No path back, this can't be a crack, abort */
		ret = 0;
		goto out;
		
		/* One edgeuse matched, all the others have to as well */
match:		;
	}
	ret = 1;
out:
    	if (rt_g.NMG_debug & DEBUG_BASIC)  {
    		bu_log("nmg_loop_is_a_crack(lu=x%x) ret=%d\n", lu, ret );
    	}
	return ret;
}

/*
 *			N M G _ L O O P _ I S _ C C W
 *
 *  Determine if loop proceeds counterclockwise (CCW) around the
 *  provided normal vector (which may be either the face normal,
 *  or the anti-normal).
 *
 *  Returns -
 *	+1	Loop is CCW, should be exterior loop.
 *	-1	Loop is CW, should be interior loop.
 *	 0	Unable to tell, error.
 *
 */
int
nmg_loop_is_ccw(const struct loopuse *lu, const fastf_t *norm, const struct bn_tol *tol)
{
	fastf_t area;
	fastf_t dot;
	plane_t pl;
	int ret;

	area = nmg_loop_plane_area( lu, pl );

	if( area <= 0.0 )
	{
		if( RT_G_DEBUG & DEBUG_MATH )
		{
			bu_log( "nmg_loop_is_ccw: Loop has no area\n" );
			nmg_pr_lu_briefly( lu, " " );
		}
		ret = 0;
		goto out;
	}

	if( NEAR_ZERO( area, tol->dist_sq ) )
	{
		if( RT_G_DEBUG & DEBUG_MATH )
		{
			bu_log( "nmg_loop_is_ccw: Loop area (%g) is less than tol->dist_sq (%g)\n", area, tol->dist_sq );
			nmg_pr_lu_briefly( lu, " " );
		}
		ret = 0;
		goto out;
	}

	dot = VDOT( norm, pl );

	if( NEAR_ZERO( dot, tol->perp ) )
	{
		if( RT_G_DEBUG & DEBUG_MATH )
		{
			bu_log( "nmg_loop_is_ccw: normal ( %g %g %g ) is in plane of loop ( %g %g %g %g ), dot = %g\n",
				V3ARGS( norm ), V4ARGS( pl ), dot );
			nmg_pr_lu_briefly( lu, " " );
		}
		ret = 0;
		goto out;
	}

	if( dot < 0.0 )
		ret = (-1 );
	else
		ret = 1;

out:
    	if (rt_g.NMG_debug & DEBUG_BASIC)
    		bu_log( "nmg_loop_is_ccw(lu=x%x) ret=%d\n" , lu, ret );

	return( ret );
}

/*
 *			N M G _ L O O P _ T O U C H E S _ S E L F
 *
 *  Search through all the vertices in a loop.
 *  If there are two distinct uses of one vertex in the loop,
 *  return true.
 *  This is useful for detecting "accordian pleats"
 *  unexpectedly showing up in a loop.
 *  Derrived from nmg_split_touchingloops().
 *
 *  Returns -
 *	vu	Yes, the loop touches itself at least once, at this vu.
 *	0	No, the loop does not touch itself.
 */
const struct vertexuse *
nmg_loop_touches_self(const struct loopuse *lu)
{
	const struct edgeuse	*eu;
	const struct vertexuse	*vu;
	const struct vertex	*v;

	if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
		return (const struct vertexuse *)0;

	/* For each edgeuse, get vertexuse and vertex */
	for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
		const struct vertexuse	*tvu;

		vu = eu->vu_p;
		NMG_CK_VERTEXUSE(vu);
		v = vu->v_p;
		NMG_CK_VERTEX(v);

		/*
		 *  For each vertexuse on vertex list,
		 *  check to see if it points up to the this loop.
		 *  If so, then there is a duplicated vertex.
		 *  Ordinarily, the vertex list will be *very* short,
		 *  so this strategy is likely to be faster than
		 *  a table-based approach, for most cases.
		 */
		for( BU_LIST_FOR( tvu, vertexuse, &v->vu_hd ) )  {
			const struct edgeuse		*teu;
			const struct loopuse		*tlu;

			if( tvu == vu )  continue;
			/*
			 *  Inline expansion of:
			 *	if(nmg_find_lu_of_vu(tvu) != lu) continue;
			 */
			if( *tvu->up.magic_p != NMG_EDGEUSE_MAGIC )  continue;
			teu = tvu->up.eu_p;
			NMG_CK_EDGEUSE(teu);
			if( *teu->up.magic_p != NMG_LOOPUSE_MAGIC )  continue;
			tlu = teu->up.lu_p;
			NMG_CK_LOOPUSE(tlu);
			if( tlu != lu )  continue;
			/*
			 *  Repeated vertex exists.
			 */
			return vu;
		}
	}
	return (const struct vertexuse *)0;
}

/************************************************************************
 *									*
 *				EDGE Routines				*
 *									*
 ************************************************************************/

/*
 *			N M G _ F I N D _ M A T C H I N G _ E U _ I N _ S
 *
 *  If shell s2 has an edge that connects the same vertices as eu1 connects,
 *  return the matching edgeuse in s2.
 *  This routine works properly regardless of whether eu1 is in s2 or not.
 *  A convenient wrapper for nmg_findeu().
 */
struct edgeuse *
nmg_find_matching_eu_in_s(const struct edgeuse *eu1, const struct shell *s2)
{
	const struct vertexuse	*vu1a, *vu1b;
	struct edgeuse		*eu2;

	NMG_CK_EDGEUSE(eu1);
	NMG_CK_SHELL(s2);

	vu1a = eu1->vu_p;
	vu1b = BU_LIST_PNEXT_CIRC( edgeuse, eu1 )->vu_p;
	NMG_CK_VERTEXUSE(vu1a);
	NMG_CK_VERTEXUSE(vu1b);
	if( (nmg_find_v_in_shell( vu1a->v_p, s2, 1 )) == (struct vertexuse *)NULL )
		return (struct edgeuse *)NULL;
	if( (nmg_find_v_in_shell( vu1b->v_p, s2, 1 )) == (struct vertexuse *)NULL )
		return (struct edgeuse *)NULL;

	/* Both vertices have vu's of eu's in s2 */

	eu2 = nmg_findeu( vu1a->v_p, vu1b->v_p, s2, eu1, 0 );
	return eu2;		/* May be NULL if no edgeuse found */
}

/*
 *			N M G _ F I N D E U
 *
 *  Find an edgeuse in a shell between a given pair of vertex structs.
 *
 *  If a given shell "s" is specified, then only edgeuses in that shell
 *  will be considered, otherwise all edgeuses in the model are fair game.
 *
 *  If a particular edgeuse "eup" is specified, then that edgeuse
 *  and it's mate will not be returned as a match.
 *
 *  If "dangling_only" is true, then an edgeuse will be matched only if
 *  there are no other edgeuses on the edge, i.e. the radial edgeuse is
 *  the same as the mate edgeuse.
 *
 *  Returns -
 *	edgeuse*	Edgeuse which matches the criteria
 *	NULL		Unable to find matching edgeuse
 */
struct edgeuse *
nmg_findeu(const struct vertex *v1, const struct vertex *v2, const struct shell *s, const struct edgeuse *eup, int dangling_only)
{
	register const struct vertexuse	*vu;
	register const struct edgeuse	*eu;
	const struct edgeuse		*eup_mate;
	int				eup_orientation;

	NMG_CK_VERTEX(v1);
	NMG_CK_VERTEX(v2);
	if(s) NMG_CK_SHELL(s);

	if(eup)  {
		struct faceuse	*fu;
		NMG_CK_EDGEUSE(eup);
		eup_mate = eup->eumate_p;
		NMG_CK_EDGEUSE(eup_mate);
		if( (fu = nmg_find_fu_of_eu(eup)) )
			eup_orientation = fu->orientation;
		else
			eup_orientation = OT_SAME;
	} else {
		eup_mate = eup;			/* NULL */
		eup_orientation = OT_SAME;
	}

	if (rt_g.NMG_debug & DEBUG_FINDEU)
		bu_log("nmg_findeu() seeking eu!=%8x/%8x between (%8x, %8x) %s\n",
			eup, eup_mate, v1, v2,
			dangling_only ? "[dangling]" : "[any]" );

	for( BU_LIST_FOR( vu, vertexuse, &v1->vu_hd ) )  {
		NMG_CK_VERTEXUSE(vu);
		if (!vu->up.magic_p)
			rt_bomb("nmg_findeu() vertexuse in vu_hd list has null parent\n");

		/* Ignore self-loops and lone shell verts */
		if (*vu->up.magic_p != NMG_EDGEUSE_MAGIC )  continue;
		eu = vu->up.eu_p;

		/* Ignore edgeuses which don't run between the right verts */
		if( eu->eumate_p->vu_p->v_p != v2 )  continue;

		if (rt_g.NMG_debug & DEBUG_FINDEU )  {
			bu_log("nmg_findeu: check eu=%8x vertex=(%8x, %8x)\n",
				eu, eu->vu_p->v_p,
				eu->eumate_p->vu_p->v_p);
		}

		/* Ignore the edgeuse to be excluded */
		if( eu == eup || eu->eumate_p == eup )  {
			if (rt_g.NMG_debug & DEBUG_FINDEU )
				bu_log("\tIgnoring -- excluded edgeuse\n");
			continue;
		}

		/* See if this edgeuse is in the proper shell */
		if( s && nmg_find_s_of_eu(eu) != s )  {
		    	if (rt_g.NMG_debug & DEBUG_FINDEU)
		    		bu_log("\tIgnoring x%x -- eu in wrong shell s=%x\n", eu, eu->up.s_p);
			continue;
		}

		/* If it's not a dangling edge, skip on */
		if( dangling_only && eu->eumate_p != eu->radial_p) {
		    	if (rt_g.NMG_debug & DEBUG_FINDEU)  {
			    	bu_log("\tIgnoring %8x/%8x (radial=x%x)\n",
			    		eu, eu->eumate_p,
					eu->radial_p );
		    	}
			continue;
		}

	    	if (rt_g.NMG_debug & DEBUG_FINDEU)
		    	bu_log("\tFound %8x/%8x\n", eu, eu->eumate_p);

		if ( *eu->up.magic_p == NMG_LOOPUSE_MAGIC &&
		     *eu->up.lu_p->up.magic_p == NMG_FACEUSE_MAGIC &&
		     eup_orientation != eu->up.lu_p->up.fu_p->orientation)
			eu = eu->eumate_p;	/* Take other orient */
		goto out;
	}
	eu = (struct edgeuse *)NULL;
out:
	if (rt_g.NMG_debug & (DEBUG_BASIC|DEBUG_FINDEU))
	    	bu_log("nmg_findeu() returns x%x\n", eu);

	return (struct edgeuse *)eu;
}

/*
 *			N M G _ F I N D _ E U _ I N _ F A C E
 *
 *  An analog to nmg_findeu(), only restricted to searching a faceuse,
 *  rather than to a whole shell.
 */
struct edgeuse *
nmg_find_eu_in_face(const struct vertex *v1, const struct vertex *v2, const struct faceuse *fu, const struct edgeuse *eup, int dangling_only)
{
	register const struct vertexuse	*vu;
	register const struct edgeuse	*eu;
	const struct edgeuse		*eup_mate;
	int				eup_orientation;

	NMG_CK_VERTEX(v1);
	NMG_CK_VERTEX(v2);
	if(fu) NMG_CK_FACEUSE(fu);

	if(eup)  {
		struct faceuse	*fu;
		NMG_CK_EDGEUSE(eup);
		eup_mate = eup->eumate_p;
		NMG_CK_EDGEUSE(eup_mate);
		if( (fu = nmg_find_fu_of_eu(eup)) )
			eup_orientation = fu->orientation;
		else
			eup_orientation = OT_SAME;
	} else {
		eup_mate = eup;			/* NULL */
		eup_orientation = OT_SAME;
	}

	if (rt_g.NMG_debug & DEBUG_FINDEU)
		bu_log("nmg_find_eu_in_face() seeking eu!=%8x/%8x between (%8x, %8x) %s\n",
			eup, eup_mate, v1, v2,
			dangling_only ? "[dangling]" : "[any]" );

	for( BU_LIST_FOR( vu, vertexuse, &v1->vu_hd ) )  {
		NMG_CK_VERTEXUSE(vu);
		if (!vu->up.magic_p)
			rt_bomb("nmg_find_eu_in_face() vertexuse in vu_hd list has null parent\n");

		/* Ignore self-loops and lone shell verts */
		if (*vu->up.magic_p != NMG_EDGEUSE_MAGIC )  continue;
		eu = vu->up.eu_p;

		/* Ignore edgeuses which don't run between the right verts */
		if( eu->eumate_p->vu_p->v_p != v2 )  continue;

		if (rt_g.NMG_debug & DEBUG_FINDEU )  {
			bu_log("nmg_find_eu_in_face: check eu=%8x vertex=(%8x, %8x)\n",
				eu, eu->vu_p->v_p,
				eu->eumate_p->vu_p->v_p);
		}

		/* Ignore the edgeuse to be excluded */
		if( eu == eup || eu->eumate_p == eup )  {
			if (rt_g.NMG_debug & DEBUG_FINDEU )
				bu_log("\tIgnoring -- excluded edgeuse\n");
			continue;
		}

		/* See if this edgeuse is in the proper faceuse */
		if( fu && nmg_find_fu_of_eu(eu) != fu )  {
		    	if (rt_g.NMG_debug & DEBUG_FINDEU)
		    		bu_log("\tIgnoring x%x -- eu not in faceuse\n", eu);
			continue;
		}

		/* If it's not a dangling edge, skip on */
		if( dangling_only && eu->eumate_p != eu->radial_p) {
		    	if (rt_g.NMG_debug & DEBUG_FINDEU)  {
			    	bu_log("\tIgnoring %8x/%8x (radial=x%x)\n",
			    		eu, eu->eumate_p,
					eu->radial_p );
		    	}
			continue;
		}

	    	if (rt_g.NMG_debug & DEBUG_FINDEU)
		    	bu_log("\tFound %8x/%8x\n", eu, eu->eumate_p);

		if ( *eu->up.magic_p == NMG_LOOPUSE_MAGIC &&
		     *eu->up.lu_p->up.magic_p == NMG_FACEUSE_MAGIC &&
		     eup_orientation != eu->up.lu_p->up.fu_p->orientation)
			eu = eu->eumate_p;	/* Take other orient */
		goto out;
	}
	eu = (struct edgeuse *)NULL;
out:
	if (rt_g.NMG_debug & (DEBUG_BASIC|DEBUG_FINDEU))
	    	bu_log("nmg_find_eu_in_face() returns x%x\n", eu);

	return (struct edgeuse *)eu;
}

/*
 *			N M G _ F I N D _ E
 *
 *  Find an edge between a given pair of vertices.
 *
 *  If a given shell "s" is specified, then only edges in that shell
 *  will be considered, otherwise all edges in the model are fair game.
 *
 *  If a particular edge "ep" is specified, then that edge
 *  will not be returned as a match.
 *
 *  Returns -
 *	edgeuse*	Edgeuse of an edge which matches the criteria
 *	NULL		Unable to find matching edge
 */
struct edgeuse *
nmg_find_e(const struct vertex *v1, const struct vertex *v2, const struct shell *s, const struct edge *ep)
{
	register const struct vertexuse	*vu;
	register const struct edgeuse	*eu;

	NMG_CK_VERTEX(v1);
	NMG_CK_VERTEX(v2);
	if(s) NMG_CK_SHELL(s);

	if (rt_g.NMG_debug & DEBUG_FINDEU)  {
		bu_log("nmg_find_e() seeking e!=%8x between (%8x, %8x)\n",
			ep, v1, v2 );
	}

	for( BU_LIST_FOR( vu, vertexuse, &v1->vu_hd ) )  {
		NMG_CK_VERTEXUSE(vu);
		if (!vu->up.magic_p)
			rt_bomb("nmg_find_e() vertexuse in vu_hd list has null parent\n");

		/* Ignore self-loops and lone shell verts */
		if (*vu->up.magic_p != NMG_EDGEUSE_MAGIC )  continue;
		eu = vu->up.eu_p;

		/* Ignore edgeuses which don't run between the right verts */
		/* We know that this eu starts at v1 */
		if( eu->eumate_p->vu_p->v_p != v2 )  continue;

		if (rt_g.NMG_debug & DEBUG_FINDEU )  {
			bu_log("nmg_find_e: check eu=%8x vertex=(%8x, %8x)\n",
				eu, eu->vu_p->v_p,
				eu->eumate_p->vu_p->v_p);
		}

		/* Ignore the edge to be excluded */
		if( eu->e_p == ep )  {
			if (rt_g.NMG_debug & DEBUG_FINDEU )
				bu_log("\tIgnoring -- excluded edge\n");
			continue;
		}

		/* See if this edgeuse is in the proper shell */
		if( s && nmg_find_s_of_eu(eu) != s )  {
		    	if (rt_g.NMG_debug & DEBUG_FINDEU)
		    		bu_log("\tIgnoring x%x -- eu in wrong shell s=%x\n", eu, eu->up.s_p);
			continue;
		}

	    	if (rt_g.NMG_debug & DEBUG_FINDEU)
		    	bu_log("\tFound %8x/%8x\n", eu, eu->eumate_p);

		if ( *eu->up.magic_p == NMG_LOOPUSE_MAGIC &&
		     *eu->up.lu_p->up.magic_p == NMG_FACEUSE_MAGIC &&
		     eu->up.lu_p->up.fu_p->orientation != OT_SAME )  {
			eu = eu->eumate_p;	/* Take other orient */
		}
		goto out;
	}
	eu = (struct edgeuse *)NULL;
out:
	if (rt_g.NMG_debug & (DEBUG_BASIC|DEBUG_FINDEU))
	    	bu_log("nmg_find_e() returns x%x\n", eu);

	return (struct edgeuse *)eu;
}

/*
 *			N M G _ F I N D _ E U _ O F _ V U
 *
 *  Return a pointer to the edgeuse which is the parent of this vertexuse.
 *
 *  A simple helper routine, which replaces the amazingly bad sequence of:
 * 	nmg_find_eu_with_vu_in_lu( nmg_find_lu_of_vu(vu), vu )
 *  that was being used in several places.
 */
struct edgeuse *
nmg_find_eu_of_vu(const struct vertexuse *vu)
{
	NMG_CK_VERTEXUSE(vu);
	if( *vu->up.magic_p != NMG_EDGEUSE_MAGIC )
		return (struct edgeuse *)NULL;
	return vu->up.eu_p;
}

/*
 *			N M G _ F I N D _ E U _ W I T H _ V U _ I N _ L U
 *
 *  Find an edgeuse starting at a given vertexuse within a loopuse.
 */
struct edgeuse *
nmg_find_eu_with_vu_in_lu(const struct loopuse *lu, const struct vertexuse *vu)
{
	register struct edgeuse	*eu;

	NMG_CK_LOOPUSE(lu);
	NMG_CK_VERTEXUSE(vu);
	if( BU_LIST_FIRST_MAGIC(&lu->down_hd) != NMG_EDGEUSE_MAGIC )
		rt_bomb("nmg_find_eu_with_vu_in_lu: loop has no edges!\n");
	for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
		NMG_CK_EDGEUSE(eu);
		if( eu->vu_p == vu )  return eu;
	}
	rt_bomb("nmg_find_eu_with_vu_in_lu:  Unable to find vu!\n");
	/* NOTREACHED */
	return((struct edgeuse *)NULL);
}

/*				N M G _ F A C E R A D I A L
 *
 *	Looking radially around an edge, find another edge in the same
 *	face as the current edge. (this could be the mate to the current edge)
 */
const struct edgeuse *
nmg_faceradial(const struct edgeuse *eu)
{
	const struct faceuse *fu;
	const struct edgeuse *eur;

	NMG_CK_EDGEUSE(eu);
	NMG_CK_LOOPUSE(eu->up.lu_p);
	fu = eu->up.lu_p->up.fu_p;
	NMG_CK_FACEUSE(fu);

	eur = eu->radial_p;

	while (*eur->up.magic_p != NMG_LOOPUSE_MAGIC ||
	    *eur->up.lu_p->up.magic_p != NMG_FACEUSE_MAGIC ||
	    eur->up.lu_p->up.fu_p->f_p != fu->f_p)
	    	eur = eur->eumate_p->radial_p;

	return(eur);
}


/*
 *			N M G _ R A D I A L _ F A C E _ E D G E _ I N _ S H E L L
 *
 *	looking radially around an edge, find another edge which is a part
 *	of a face in the same shell
 */
const struct edgeuse *
nmg_radial_face_edge_in_shell(const struct edgeuse *eu)
{
	const struct edgeuse *eur;
	const struct shell	*s;

	NMG_CK_EDGEUSE(eu);
	s = nmg_find_s_of_eu(eu);

	eur = eu->radial_p;
	NMG_CK_EDGEUSE(eur);

	while (eur != eu->eumate_p) {
		if (*eur->up.magic_p == NMG_LOOPUSE_MAGIC &&
		    *eur->up.lu_p->up.magic_p == NMG_FACEUSE_MAGIC &&
		    eur->up.lu_p->up.fu_p->s_p == s) {
			break; /* found another face in shell */
		} else {
			eur = eur->eumate_p->radial_p;
			NMG_CK_EDGEUSE(eur);
		}
	}
	return(eur);
}

/*
 *			N M G _ F I N D _ E D G E _ B E T W E E N _ 2 F U
 *
 *  Perform a topology search to determine if two faces (specified by
 *  their faceuses) share an edge in common.  If so, return an edgeuse
 *  in fu1 of that edge.
 *
 *  If there are multiple edgeuses in common, ensure that they all refer
 *  to the same edge_g_lseg geometry structure.  The intersection of two planes
 *  (non-coplanar) must be a single line.
 *
 *  Calling this routine when the two faces share face geometry
 *  and have more than one edge in common gives
 *  a NULL return, as there is no unique answer.
 *
 *  NULL is also returned if no common edge could be found.
 */
const struct edgeuse *
nmg_find_edge_between_2fu(const struct faceuse *fu1, const struct faceuse *fu2, const struct bn_tol *tol)
{
	const struct loopuse	*lu1;
	const struct edgeuse	*ret = (const struct edgeuse *)NULL;
	int			coincident;

	NMG_CK_FACEUSE(fu1);
	NMG_CK_FACEUSE(fu2);
	BN_CK_TOL(tol);

	for( BU_LIST_FOR( lu1, loopuse, &fu1->lu_hd ) )  {
		const struct edgeuse	*eu1;
		NMG_CK_LOOPUSE(lu1);
		if( BU_LIST_FIRST_MAGIC(&lu1->down_hd) == NMG_VERTEXUSE_MAGIC )
			continue;
		for( BU_LIST_FOR( eu1, edgeuse, &lu1->down_hd ) )  {
			const struct edgeuse *eur;

			NMG_CK_EDGEUSE(eu1);
			/* Walk radially around the edge */
			eur = eu1->radial_p;
			NMG_CK_EDGEUSE(eur);

			while (eur != eu1->eumate_p) {
				if (*eur->up.magic_p == NMG_LOOPUSE_MAGIC &&
				    *eur->up.lu_p->up.magic_p == NMG_FACEUSE_MAGIC &&
				    eur->up.lu_p->up.fu_p->f_p == fu2->f_p) {
				    	/* Found the other face on this edge! */
				    	if( !ret )  {
				    		/* First common edge found */
				    		if( eur->up.lu_p->up.fu_p == fu2)  {
				    			ret = eur;
				    		} else {
				    			ret = eur->eumate_p;
				    		}
				    	} else {
				    		/* Previous edge found, check edge_g_lseg */
				    		if( eur->g.lseg_p != ret->g.lseg_p )  {
				    			bu_log("eur=x%x, eg_p=x%x;  ret=x%x, eg_p=x%x\n",
				    				eur, eur->g.lseg_p,
				    				ret, ret->g.lseg_p );
				    			nmg_pr_eg( eur->g.magic_p, 0 );
				    			nmg_pr_eg( ret->g.magic_p, 0 );
				    			nmg_pr_eu_endpoints( eur, 0 );
				    			nmg_pr_eu_endpoints( ret, 0 );

							coincident = nmg_2edgeuse_g_coincident( eur, ret, tol );
							if( coincident )  {
								/* Change eur to use ret's eg */
								bu_log("nmg_find_edge_between_2fu() belatedly fusing e1=x%x, eg1=x%x, e2=x%x, eg2=x%x\n",
									eur->e_p, eur->g.lseg_p,
									ret->e_p, ret->g.lseg_p );
								nmg_jeg( ret->g.lseg_p, eur->g.lseg_p );
								/* See if there are any others. */
								nmg_model_fuse( nmg_find_model(&eur->l.magic), tol );
							} else {
					    			rt_bomb("nmg_find_edge_between_2fu() 2 faces intersect with differing edge geometries?\n");
							}
				    		}
				    	}
				}
				/* Advance to next */
				eur = eur->eumate_p->radial_p;
				NMG_CK_EDGEUSE(eur);
			}
		}
	}
	if (rt_g.NMG_debug & DEBUG_BASIC)  bu_log("nmg_find_edge_between_2fu(fu1=x%x, fu2=x%x) edgeuse=x%x\n", fu1, fu2, ret);
	return ret;

}

/*
 *  Support for nmg_find_e_nearest_pt2().
 */
struct fen2d_state {
	char		*visited;	/* array of edges already visited */
	fastf_t		mindist;	/* current min dist */
	struct edge	*ep;		/* closest edge */
	mat_t		mat;
	point_t		pt2;
	const struct bn_tol	*tol;
};

static void
nmg_find_e_pt2_handler(long int *lp, genptr_t state, int first)
{
	register struct fen2d_state	*sp = (struct fen2d_state *)state;
	register struct edge		*e = (struct edge *)lp;
	fastf_t				dist_sq;
	point_t				a2, b2;
	struct vertex			*va, *vb;
	point_t				pca;
	int				code;

	BN_CK_TOL(sp->tol);
	NMG_CK_EDGE(e);

	/* If this edge has been processed before, do nothing more */
	if( !NMG_INDEX_FIRST_TIME(sp->visited, e) )  return;

	va = e->eu_p->vu_p->v_p;
	vb = e->eu_p->eumate_p->vu_p->v_p;
	NMG_CK_VERTEX(va);
	NMG_CK_VERTEX(vb);

	MAT4X3PNT( a2, sp->mat, va->vg_p->coord );
	MAT4X3PNT( b2, sp->mat, vb->vg_p->coord );

	code = bn_dist_pt2_lseg2( &dist_sq, pca, a2, b2, sp->pt2, sp->tol );

	if( code == 0 )  dist_sq = 0;

	if( dist_sq < sp->mindist )  {
		sp->mindist = dist_sq;
		sp->ep = e;
	}
}

/*
 *			N M G _ F I N D _ E _ N E A R E S T _ P T 2
 *
 *  A geometric search routine to find the edge that is neaest to
 *  the given point, when all edges are projected into 2D using
 *  the matrix 'mat'.
 *  Useful for finding the edge nearest a mouse click, for example.
 */
struct edge *
nmg_find_e_nearest_pt2(long int *magic_p, const fastf_t *pt2, const fastf_t *mat, const struct bn_tol *tol)
    		         
             	    		/* 2d point */
           	    		/* 3d to 3d xform */
                   	     
{
	struct model			*m;
	struct nmg_visit_handlers	htab;
	struct fen2d_state		st;

	BN_CK_TOL(tol);
	m = nmg_find_model( magic_p );
	NMG_CK_MODEL(m);

	st.visited = (char *)bu_calloc(m->maxindex+1, sizeof(char), "visited[]");
	st.mindist = INFINITY;
	VMOVE( st.pt2, pt2 );
	MAT_COPY( st.mat, mat );
	st.ep = (struct edge *)NULL;
	st.tol = tol;

	htab = nmg_visit_handlers_null;		/* struct copy */
	htab.vis_edge = nmg_find_e_pt2_handler;

	nmg_visit( magic_p, &htab, (genptr_t)&st );

	bu_free( (char *)st.visited, "visited[]" );

	if( st.ep )  {
		NMG_CK_EDGE(st.ep);
		return st.ep;
	}
	return (struct edge *)NULL;
}

/*
 *			N M G _ E U _ 2 V E C S _ P E R P
 *
 *  Given an edgeuse, return two arbitrary unit-length vectors which
 *  are perpendicular to each other and to the edgeuse, such that
 *  they can be considered the +X and +Y axis, and the edgeuse is +Z.
 *  That is, X cross Y = Z.
 *
 *  Useful for erecting a coordinate system around an edge suitable
 *  for measuring the angles of other edges and faces with.
 */
void
nmg_eu_2vecs_perp(fastf_t *xvec, fastf_t *yvec, fastf_t *zvec, const struct edgeuse *eu, const struct bn_tol *tol)
{
	const struct vertex	*v1, *v2;
	fastf_t			len;

	NMG_CK_EDGEUSE(eu);
	v1 = eu->vu_p->v_p;
	NMG_CK_VERTEX(v1);
	v2 = eu->eumate_p->vu_p->v_p;
	NMG_CK_VERTEX(v2);
	if( v1 == v2 )  rt_bomb("nmg_eu_2vecs_perp() start&end vertex of edge are the same!\n");
	BN_CK_TOL(tol);

	NMG_CK_VERTEX_G(v1->vg_p);
	NMG_CK_VERTEX_G(v2->vg_p);
	VSUB2( zvec, v2->vg_p->coord, v1->vg_p->coord );
	len = MAGNITUDE(zvec);
	/* See if v1 == v2, within tol */
	if( len < tol->dist )  rt_bomb("nmg_eu_2vecs_perp(): 0-length edge (geometry)\n");
	len = 1 / len;
	VSCALE( zvec, zvec, len );

	bn_vec_perp( xvec, zvec );
	VCROSS( yvec, zvec, xvec );
}

/*
 *			N M G _ F I N D _ E U _ L E F T V E C
 *
 *  Given an edgeuse, if it is part of a faceuse, return the inward pointing
 *  "left" vector which points into the interior of this loop, and
 *  lies in the plane of the face. The left vector is unitized.
 *
 *  This routine depends on the vertex ordering in an OT_SAME loopuse being
 *  properly CCW for exterior loops, and CW for interior (hole) loops.
 *
 *  Returns -
 *	-1	if edgeuse is not part of a faceuse.
 *	 0	if left vector successfully computed into caller's array.
 */
int
nmg_find_eu_leftvec(fastf_t *left, const struct edgeuse *eu)
{
	const struct loopuse	*lu;
	const struct faceuse	*fu;
	vect_t			Norm;
	vect_t			edgevect;
	fastf_t			dot;
	struct vertex_g		*vg1;
	struct vertex_g		*vg2;
	fastf_t			edge_len_sq;
	fastf_t			sin_sq;

	NMG_CK_EDGEUSE(eu);
	if( *eu->up.magic_p != NMG_LOOPUSE_MAGIC )  return -1;
	lu = eu->up.lu_p;
	NMG_CK_LOOPUSE(lu);
	if( *lu->up.magic_p != NMG_FACEUSE_MAGIC )  return -1;
	fu = lu->up.fu_p;
	NMG_CK_FACEUSE(fu);
	NMG_CK_FACE(fu->f_p);
	NMG_CK_FACE_G_PLANE(fu->f_p->g.plane_p);

	vg1 = eu->vu_p->v_p->vg_p;
	vg2 = eu->eumate_p->vu_p->v_p->vg_p;

	/* Get unit length Normal vector for edgeuse's faceuse */
	NMG_GET_FU_NORMAL( Norm, fu );

	VSUB2( edgevect, vg2->coord, vg1->coord );
	edge_len_sq = MAGSQ( edgevect );

	dot = VDOT( edgevect, Norm );
	sin_sq = 1.0 - (dot * dot / edge_len_sq);

	if( NEAR_ZERO( sin_sq, 0.000001) )	/* we don't have a tol structure available XXX */
	{
		const struct edgeuse *eu_next;
		const struct edgeuse *eu_prev;
		vect_t next_left;
		vect_t prev_left;
		vect_t other_edge;
		int other_edge_is_parallel=1;

		bu_log( "WARNING: eu x%x (%f %f %f) parallel to normal (%f %f %f)\n", eu, V3ARGS( edgevect ), V3ARGS( Norm ) );

		eu_next = eu;
		while( other_edge_is_parallel )
		{
			eu_next = BU_LIST_PNEXT_CIRC( edgeuse, &eu_next->l );
			if( eu_next == eu )
				break;
			if( NMG_ARE_EUS_ADJACENT( eu, eu_next ) )
				continue;
			VSUB2( other_edge, eu_next->eumate_p->vu_p->v_p->vg_p->coord,
		                eu_next->vu_p->v_p->vg_p->coord );
			VUNITIZE( other_edge );
			dot = 1.0 - fabs( VDOT( other_edge, Norm ) );
			if( dot < .5 )
				other_edge_is_parallel = 0;
		}
		if( other_edge_is_parallel )
		{
			bu_log( "Cannot find edge (starting eu =x%x) that is not parallel to face normal!!!\n", eu );
			nmg_pr_fu_briefly( fu, (char *)NULL );
			rt_bomb( "Cannot find edge that is not parallel to face normal!!!\n" );
		}

		VCROSS( next_left, Norm, other_edge );
		VUNITIZE( next_left );

		eu_prev = eu;
		other_edge_is_parallel = 1;
		while( other_edge_is_parallel )
		{
			eu_prev = BU_LIST_PPREV_CIRC( edgeuse, &eu_prev->l );
			if( eu_prev == eu )
				break;
			if( NMG_ARE_EUS_ADJACENT( eu, eu_prev ) )
				continue;
			VSUB2( other_edge, eu_prev->eumate_p->vu_p->v_p->vg_p->coord,
		                eu_prev->vu_p->v_p->vg_p->coord );
			VUNITIZE( other_edge );
			dot = 1.0 - fabs( VDOT( other_edge, Norm ) );
			if( dot < .5 )
				other_edge_is_parallel = 0;
		}
		if( other_edge_is_parallel )
		{
			bu_log( "Cannot find edge (starting eu =x%x) that is not parallel to face normal!!!\n", eu );
			nmg_pr_fu_briefly( fu, (char *)NULL );
			rt_bomb( "Cannot find edge that is not parallel to face normal!!!\n" );
		}

		VCROSS( prev_left, Norm, other_edge );
		VUNITIZE( prev_left );

		VBLEND2( left, 0.5, next_left, 0.5, prev_left );
		VUNITIZE( left );
#if 0
		bu_log( "\t eu_prev (%g %g %g)<->(%g %g %g)\n",
			V3ARGS( eu_prev->vu_p->v_p->vg_p->coord ),
			V3ARGS( eu_prev->eumate_p->vu_p->v_p->vg_p->coord ) );
		bu_log( "\t eu_next (%g %g %g)<->(%g %g %g)\n",
			V3ARGS( eu_next->vu_p->v_p->vg_p->coord ),
			V3ARGS( eu_next->eumate_p->vu_p->v_p->vg_p->coord ) );
		bu_log( "\tprev_left=(%g %g %g), next_left=(%g %g %g)\n", V3ARGS( prev_left ), V3ARGS( next_left ) );
		bu_log( "\tUnitized left=(%f %f %f)\n", V3ARGS( left ) );

		nmg_pr_fu_briefly( fu, "" );
#endif
		return 0;
	}

	VCROSS( left, Norm, edgevect );
	if (rt_g.NMG_debug & DEBUG_MESH_EU ) {
		vect_t edge_unit;
		vect_t norm_x_edge;

		VMOVE( edge_unit, edgevect );
		VUNITIZE( edge_unit );
		VCROSS( norm_x_edge, Norm, edge_unit );
		bu_log( "for eu x%x from fu x%x v1=x%x, v2=x%x:\n", eu, fu, eu->vu_p->v_p, eu->eumate_p->vu_p->v_p );
		bu_log( "\t(%.10f %.10f %.10f) <-> (%.10f %.10f %.10f)\n", V3ARGS( eu->vu_p->v_p->vg_p->coord ), V3ARGS( eu->eumate_p->vu_p->v_p->vg_p->coord ) );
		bu_log( "\tedge dot norm = %.10f\n", VDOT( edge_unit, Norm ) );
		bu_log( "\tnorm X edge = (%.10f %.10f %.10f)\n", V3ARGS( norm_x_edge ) );
		bu_log( "\tnorm=(%.10f %.10f %.10f), edgevect=(%.10f %.10f %.10f), left=(%.10f %.10f %.10f )\n",
			V3ARGS( Norm ), V3ARGS( edgevect ), V3ARGS( left ) );
	}
	VUNITIZE( left );
	if (rt_g.NMG_debug & DEBUG_MESH_EU ) {
		bu_log( "\tUnitized left=(%f %f %f)\n", V3ARGS( left ) );
	}
	return 0;
}

/*
 *		N M G _ F I N D _ E U _ L E F T _ N O N _ U N I T
 *
 *  Given an edgeuse, if it is part of a faceuse, return the inward pointing
 *  "left" vector which points into the interior of this loop, and
 *  lies in the plane of the face. The left vector is not unitized.
 *
 *  This routine depends on the vertex ordering in an OT_SAME loopuse being
 *  properly CCW for exterior loops, and CW for interior (hole) loops.
 *
 *  Returns -
 *	-1	if edgeuse is not part of a faceuse.
 *	 0	if left vector successfully computed into caller's array.
 */
int
nmg_find_eu_left_non_unit(fastf_t *left, const struct edgeuse *eu)
{
	const struct loopuse	*lu;
	const struct faceuse	*fu;
	vect_t			Norm;
	vect_t			edgevect;
	pointp_t		p1,p2;

	NMG_CK_EDGEUSE(eu);
	if( *eu->up.magic_p != NMG_LOOPUSE_MAGIC )  return -1;
	lu = eu->up.lu_p;
	if( *lu->up.magic_p != NMG_FACEUSE_MAGIC )  return -1;
	fu = lu->up.fu_p;

	/* Get unit length Normal vector for edgeuse's faceuse */
	NMG_GET_FU_NORMAL( Norm, fu );

	/* Get vector in direction of edge */
	p1 = eu->vu_p->v_p->vg_p->coord;
	p2 = eu->eumate_p->vu_p->v_p->vg_p->coord;
	VSUB2( edgevect, p2, p1 );

	/* left vector is cross-product of face normal and edge direction */
	VCROSS( left, Norm, edgevect );
	return 0;
}
/*
 *			N M G _ F I N D _ O T _ S A M E _ E U _ O F _ E
 *
 *  If there is an edgeuse of an OT_SAME faceuse on this edge, return it.
 *  Only return a wire edgeuse if that is all there is.
 *  Useful for selecting a "good" edgeuse to pass to nmg_eu_2vecs_perp().
 */
struct edgeuse *
nmg_find_ot_same_eu_of_e(const struct edge *e)
{
	register struct edgeuse	*eu1;
	register struct edgeuse	*eu;
	struct faceuse		*fu;

	NMG_CK_EDGE(e);
	eu = eu1 = e->eu_p;
	do  {
		fu = nmg_find_fu_of_eu(eu);
		if( fu && fu->orientation == OT_SAME )  return eu;

		fu = nmg_find_fu_of_eu(eu->eumate_p);
		if( fu && fu->orientation == OT_SAME )  return eu->eumate_p;
		eu = eu->radial_p->eumate_p;
	} while( eu != eu1 );
	return eu1;		/* All wire */
}

/************************************************************************
 *									*
 *				VERTEX Routines				*
 *									*
 ************************************************************************/

/*
 *			N M G _ F I N D _ V _ I N _ F A C E
 *
 *	Perform a topological search to
 *	determine if the given vertex is contained in the given faceuse.
 *	If it is, return a pointer to the vertexuse which was found in the
 *	faceuse.
 *
 *  Returns NULL if not found.
 */
struct vertexuse *
nmg_find_v_in_face(const struct vertex *v, const struct faceuse *fu)
{
	struct vertexuse *vu;
	struct edgeuse *eu;
	struct loopuse *lu;

	NMG_CK_VERTEX(v);

	for( BU_LIST_FOR( vu, vertexuse, &v->vu_hd ) )  {
		NMG_CK_VERTEXUSE(vu);
		if (*vu->up.magic_p == NMG_EDGEUSE_MAGIC) {
			eu = vu->up.eu_p;
			if (*eu->up.magic_p == NMG_LOOPUSE_MAGIC) {
				lu = eu->up.lu_p;
				if (*lu->up.magic_p == NMG_FACEUSE_MAGIC && lu->up.fu_p == fu)
					return(vu);
			}

		} else if (*vu->up.magic_p == NMG_LOOPUSE_MAGIC) {
			lu = vu->up.lu_p;
			if (*lu->up.magic_p == NMG_FACEUSE_MAGIC && lu->up.fu_p == fu)
				return(vu);
		}
	}
	return((struct vertexuse *)NULL);
}

/*
 *			N M G _ F I N D _ V _ I N _ S H E L L
 *
 *  Search shell "s" for a vertexuse that refers to vertex "v".
 *  For efficiency, the search is done on the uses of "v".
 *
 *  If "edges_only" is set, only a vertexuse from an edgeuse will
 *  be returned, otherwise, vu's from self-loops and lone-shell-vu's
 *  are also candidates.
 */
struct vertexuse *
nmg_find_v_in_shell(const struct vertex *v, const struct shell *s, int edges_only)
{
	struct vertexuse	*vu;

	for( BU_LIST_FOR( vu, vertexuse, &v->vu_hd ) )  {
		NMG_CK_VERTEXUSE(vu);

		if( *vu->up.magic_p == NMG_LOOPUSE_MAGIC )  {
			if( edges_only )  continue;
			if( nmg_find_s_of_lu( vu->up.lu_p ) == s )
				return vu;
			continue;
		}
		if( *vu->up.magic_p == NMG_SHELL_MAGIC )  {
			if( edges_only )  continue;
			if( vu->up.s_p == s )
				return vu;
			continue;
		}
		if( *vu->up.magic_p != NMG_EDGEUSE_MAGIC )
			rt_bomb("nmg_find_v_in_shell(): bad vu up ptr\n");

		/* vu is being used by an edgeuse */
		if( nmg_find_s_of_eu( vu->up.eu_p ) == s )
			return vu;
	}
	return (struct vertexuse *)NULL;
}

/*
 *			N M G _ F I N D _ P T _ I N _ L U
 *
 *  Conduct a geometric search for a vertex in loopuse 'lu' which is
 *  "identical" to the given point, within the specified tolerance.
 *  The loopuse may be part of a face, or it may be wires.
 *
 *  Returns -
 *	NULL			No vertex matched
 *	(struct vertexuse *)	A matching vertexuse from that loopuse.
 */
struct vertexuse *
nmg_find_pt_in_lu(const struct loopuse *lu, const fastf_t *pt, const struct bn_tol *tol)
{
	struct edgeuse		*eu;
	vect_t			delta;
	struct vertex		*v;
	register struct vertex_g *vg;
	int			magic1;

	magic1 = BU_LIST_FIRST_MAGIC( &lu->down_hd );
	if (magic1 == NMG_VERTEXUSE_MAGIC) {
		struct vertexuse	*vu;
		vu = BU_LIST_FIRST(vertexuse, &lu->down_hd);
		v = vu->v_p;
		NMG_CK_VERTEX(v);
		if( !(vg = v->vg_p) )
			return ((struct vertexuse *)NULL);
		NMG_CK_VERTEX_G(vg);
		VSUB2(delta, vg->coord, pt);
		if ( MAGSQ(delta) <= tol->dist_sq)
			return(vu);
		return ((struct vertexuse *)NULL);
	}
	if (magic1 != NMG_EDGEUSE_MAGIC) {
		rt_bomb("nmg_find_pt_in_lu() Bogus child of loop\n");
	}

	for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
		v = eu->vu_p->v_p;
		NMG_CK_VERTEX(v);
		if( !(vg = v->vg_p) )  continue;
		NMG_CK_VERTEX_G(vg);
		VSUB2(delta, vg->coord, pt);
		if ( MAGSQ(delta) <= tol->dist_sq)
			return(eu->vu_p);
	}
	return ((struct vertexuse *)NULL);

}

/*
 *			N M G _ F I N D _ P T _ I N _ F A C E
 *
 *  Conduct a geometric search for a vertex in face 'fu' which is
 *  "identical" to the given point, within the specified tolerance.
 *
 *  Returns -
 *	NULL			No vertex matched
 *	(struct vertexuse *)	A matching vertexuse from that face.
 */
struct vertexuse *
nmg_find_pt_in_face(const struct faceuse *fu, const fastf_t *pt, const struct bn_tol *tol)
{
	register struct loopuse	*lu;
	struct vertexuse	*vu;

	NMG_CK_FACEUSE(fu);
	BN_CK_TOL(tol);

	for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )  {
		NMG_CK_LOOPUSE(lu);
		if( (vu = nmg_find_pt_in_lu(lu, pt, tol)) )
			return vu;
	}
	return ((struct vertexuse *)NULL);
}

/*
 *			N M G _ F I N D _ P T _ I N _ S H E L L
 *
 *  Given a point in 3-space and a shell pointer, try to find a vertex
 *  anywhere in the shell which is within sqrt(tol_sq) distance of
 *  the given point.
 *
 *  The algorithm is a brute force, and should be used sparingly.
 *  Mike Gigante's NUgrid technique would work well here, if
 *  searching was going to be needed for more than a few points.
 *
 *  Returns -
 *	pointer to vertex with matching geometry
 *	NULL
 *
 *  XXX Why does this return a vertex, while it's helpers return a vertexuse?
 */
struct vertex *
nmg_find_pt_in_shell(const struct shell *s, const fastf_t *pt, const struct bn_tol *tol)
{
	const struct faceuse	*fu;
	const struct loopuse	*lu;
	const struct edgeuse	*eu;
	const struct vertexuse	*vu;
	struct vertex		*v;
	const struct vertex_g	*vg;
	vect_t		delta;

	NMG_CK_SHELL(s);
	BN_CK_TOL(tol);

	fu = BU_LIST_FIRST(faceuse, &s->fu_hd);
	while (BU_LIST_NOT_HEAD(fu, &s->fu_hd) ) {
		/* Shell has faces */
		NMG_CK_FACEUSE(fu);
		if( (vu = nmg_find_pt_in_face( fu, pt, tol )) )
			return(vu->v_p);

		if (BU_LIST_PNEXT(faceuse, fu) == fu->fumate_p)
			fu = BU_LIST_PNEXT_PNEXT(faceuse, fu);
		else
			fu = BU_LIST_PNEXT(faceuse, fu);
	}

	/* Wire loopuses */
	lu = BU_LIST_FIRST(loopuse, &s->lu_hd);
	while (BU_LIST_NOT_HEAD(lu, &s->lu_hd) ) {
		NMG_CK_LOOPUSE(lu);
		if( (vu = nmg_find_pt_in_lu(lu, pt, tol)) )
			return vu->v_p;

		if (BU_LIST_PNEXT(loopuse, lu) == lu->lumate_p)
			lu = BU_LIST_PNEXT_PNEXT(loopuse, lu);
		else
			lu = BU_LIST_PNEXT(loopuse, lu);
	}

	/* Wire edgeuses */
	for (BU_LIST_FOR(eu, edgeuse, &s->eu_hd)) {
		NMG_CK_EDGEUSE(eu);
		NMG_CK_VERTEXUSE(eu->vu_p);
		v = eu->vu_p->v_p;
		NMG_CK_VERTEX(v);
		if( (vg = v->vg_p) )  {
			NMG_CK_VERTEX_G(vg);
			VSUB2( delta, vg->coord, pt );
			if( MAGSQ(delta) <= tol->dist_sq )
				return(v);
		}
	}

	/* Lone vertexuse */
	if (s->vu_p) {
		NMG_CK_VERTEXUSE(s->vu_p);
		v = s->vu_p->v_p;
		NMG_CK_VERTEX(v);
		if( (vg = v->vg_p) )  {
			NMG_CK_VERTEX_G( vg );
			VSUB2( delta, vg->coord, pt );
			if( MAGSQ(delta) <= tol->dist_sq )
				return(v);
		}
	}
	return( (struct vertex *)0 );
}

/*
 *			N M G _ F I N D _ P T _ I N _ M O D E L
 *
 *  Brute force search of the entire model to find a vertex that
 *  matches this point.
 *  XXX Shouldn't this return the _closest_ match, not just the
 *  XXX first match within tolerance?
 */
struct vertex *
nmg_find_pt_in_model(const struct model *m, const fastf_t *pt, const struct bn_tol *tol)
{
	struct nmgregion	*r;
	struct shell		*s;
	struct vertex		*v;

	NMG_CK_MODEL(m);
	BN_CK_TOL(tol);

	for( BU_LIST_FOR( r, nmgregion, &m->r_hd ) )  {
		NMG_CK_REGION(r);
		for( BU_LIST_FOR( s, shell, &r->s_hd ) )  {
			NMG_CK_SHELL(s);
			if( (v = nmg_find_pt_in_shell( s, pt, tol )) )  {
				NMG_CK_VERTEX(v);
				return v;
			}
		}
	}
	return (struct vertex *)NULL;
}

/*
 *			N M G _ I S _ V E R T E X _ I N _ E D G E L I S T
 *
 *  Returns -
 *	1	If found
 *	0	If not found
 */
int
nmg_is_vertex_in_edgelist(register const struct vertex *v, const struct bu_list *hd)
{
	register const struct edgeuse	*eu;

	NMG_CK_VERTEX(v);
	for( BU_LIST_FOR( eu, edgeuse, hd ) )  {
		NMG_CK_EDGEUSE(eu);
		NMG_CK_VERTEXUSE(eu->vu_p);
		NMG_CK_VERTEX(eu->vu_p->v_p);
		if( eu->vu_p->v_p == v )  return(1);
	}
	return(0);
}

/*
 *			N M G _ I S _ V E R T E X _ I N _ L O O P L I S T
 *
 *  Returns -
 *	1	If found
 *	0	If not found
 */
int
nmg_is_vertex_in_looplist(register const struct vertex *v, const struct bu_list *hd, int singletons)
{
	register const struct loopuse	*lu;
	long			magic1;

	NMG_CK_VERTEX(v);
	for( BU_LIST_FOR( lu, loopuse, hd ) )  {
		NMG_CK_LOOPUSE(lu);
		magic1 = BU_LIST_FIRST_MAGIC( &lu->down_hd );
		if( magic1 == NMG_VERTEXUSE_MAGIC )  {
			register const struct vertexuse	*vu;
			if( !singletons )  continue;
			vu = BU_LIST_FIRST(vertexuse, &lu->down_hd );
			NMG_CK_VERTEXUSE(vu);
			NMG_CK_VERTEX(vu->v_p);
			if( vu->v_p == v )  return(1);
		} else if( magic1 == NMG_EDGEUSE_MAGIC )  {
			if( nmg_is_vertex_in_edgelist( v, &lu->down_hd ) )
				return(1);
		} else {
			rt_bomb("nmg_is_vertex_in_loopuse() bad magic\n");
		}
	}
	return(0);
}

/*
 *			N M G _ I S _ V E R T E X _ I N _ F A C E
 *
 *  Returns -
 *	vu	One use of vertex 'v' in face 'f'.
 *	NULL	If there are no uses of 'v' in 'f'.
 */
struct vertexuse *
nmg_is_vertex_in_face(const struct vertex *v, const struct face *f)
{
	struct vertexuse	*vu;

	NMG_CK_VERTEX(v);
	NMG_CK_FACE(f);

	for( BU_LIST_FOR( vu, vertexuse, &v->vu_hd ) )  {
		register const struct edgeuse	*eu;
		register const struct loopuse	*lu;
		register const struct faceuse	*fu;

		if( *vu->up.magic_p != NMG_EDGEUSE_MAGIC )  continue;
		if( *(eu = vu->up.eu_p)->up.magic_p != NMG_LOOPUSE_MAGIC )  continue;
		lu = eu->up.lu_p;
		if( *lu->up.magic_p != NMG_FACEUSE_MAGIC )  continue;
		fu = lu->up.fu_p;
		if( fu->f_p != f )  continue;
		return vu;
	}
	return (struct vertexuse *)NULL;
}

/*
 *	N M G _ I S _ V E R T E X _ A _ S E L F L O O P _ I N _ S H E L L
 *
 *  Check to see if a given vertex is used within a shell
 *  by a wire loopuse which is a loop of a single vertex.
 *  The search could either be by the shell lu_hd, or the vu_hd.
 *
 *  Returns -
 *	0	vertex is not part of that kind of loop in the shell.
 *	1	vertex is part of a selfloop in the given shell.
 */
int
nmg_is_vertex_a_selfloop_in_shell(const struct vertex *v, const struct shell *s)
{
	const struct vertexuse *vu;

	NMG_CK_VERTEX(v);
	NMG_CK_SHELL(s);

	/* try to find the vertex in a loopuse of this shell */
	for (BU_LIST_FOR(vu, vertexuse, &v->vu_hd)) {
		register const struct loopuse	*lu;
		NMG_CK_VERTEXUSE(vu);
		if (*vu->up.magic_p != NMG_LOOPUSE_MAGIC )  continue;
		lu = vu->up.lu_p;
		NMG_CK_LOOPUSE(lu);
		if( *lu->up.magic_p != NMG_SHELL_MAGIC )  continue;
		NMG_CK_SHELL(lu->up.s_p);
		if( lu->up.s_p == s)
			return 1;
	}
	return 0;
}

/*
 *			N M G _ I S _ V E R T E X _ I N _ F A C E L I S T
 *
 *  Returns -
 *	1	If found
 *	0	If not found
 */
int
nmg_is_vertex_in_facelist(register const struct vertex *v, const struct bu_list *hd)
{
	register const struct faceuse	*fu;

	NMG_CK_VERTEX(v);
	for( BU_LIST_FOR( fu, faceuse, hd ) )  {
		NMG_CK_FACEUSE(fu);
		if( nmg_is_vertex_in_looplist( v, &fu->lu_hd, 1 ) )
			return(1);
	}
	return(0);
}

/*
 *			N M G _ I S _ E D G E _ I N _ E D G E L I S T
 *
 *  Returns -
 *	1	If found
 *	0	If not found
 */
int
nmg_is_edge_in_edgelist(const struct edge *e, const struct bu_list *hd)
{
	register const struct edgeuse	*eu;

	NMG_CK_EDGE(e);
	for( BU_LIST_FOR( eu, edgeuse, hd ) )  {
		NMG_CK_EDGEUSE(eu);
		NMG_CK_EDGE(eu->e_p);
		if( e == eu->e_p )  return(1);
	}
	return(0);
}

/*
 *			N M G _ I S _ E D G E _ I N _ L O O P L I S T
 *
 *  Returns -
 *	1	If found
 *	0	If not found
 */
int
nmg_is_edge_in_looplist(const struct edge *e, const struct bu_list *hd)
{
	register const struct loopuse	*lu;
	long			magic1;

	NMG_CK_EDGE(e);
	for( BU_LIST_FOR( lu, loopuse, hd ) )  {
		NMG_CK_LOOPUSE(lu);
		magic1 = BU_LIST_FIRST_MAGIC( &lu->down_hd );
		if( magic1 == NMG_VERTEXUSE_MAGIC )  {
			/* Loop of a single vertex does not have an edge */
			continue;
		} else if( magic1 == NMG_EDGEUSE_MAGIC )  {
			if( nmg_is_edge_in_edgelist( e, &lu->down_hd ) )
				return(1);
		} else {
			rt_bomb("nmg_is_edge_in_loopuse() bad magic\n");
		}
	}
	return(0);
}

/*
 *			N M G _ I S _ E D G E _ I N _ F A C E L I S T
 *
 *  Returns -
 *	1	If found
 *	0	If not found
 */
int
nmg_is_edge_in_facelist(const struct edge *e, const struct bu_list *hd)
{
	register const struct faceuse	*fu;

	NMG_CK_EDGE(e);
	for( BU_LIST_FOR( fu, faceuse, hd ) )  {
		NMG_CK_FACEUSE(fu);
		if( nmg_is_edge_in_looplist( e, &fu->lu_hd ) )
			return(1);
	}
	return(0);
}

/*
 *			N M G _ I S _ L O O P _ I N _ F A C E L I S T
 *
 *  Returns -
 *	1	If found
 *	0	If not found
 */
int
nmg_is_loop_in_facelist(const struct loop *l, const struct bu_list *fu_hd)
{
	register const struct faceuse	*fu;
	register const struct loopuse	*lu;

	NMG_CK_LOOP(l);
	for( BU_LIST_FOR( fu, faceuse, fu_hd ) )  {
		NMG_CK_FACEUSE(fu);
		for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )  {
			NMG_CK_LOOPUSE(lu);
			NMG_CK_LOOP(lu->l_p);
			if( l == lu->l_p )  return(1);
		}
	}
	return(0);
}

/************************************************************************
 *									*
 *				Tabulation Routines			*
 *									*
 ************************************************************************/

struct vf_state {
	char		*visited;
	struct bu_ptbl	*tabl;
};

/*
 *			N M G _ 2 R V F _ H A N D L E R
 *
 *  A private support routine for nmg_vertex_tabulate().
 *  Having just visited a vertex, if this is the first time,
 *  add it to the bu_ptbl array.
 */
static void
nmg_2rvf_handler(long int *vp, genptr_t state, int first)
{
	register struct vf_state *sp = (struct vf_state *)state;
	register struct vertex	*v = (struct vertex *)vp;

	NMG_CK_VERTEX(v);
	/* If this vertex has been processed before, do nothing more */
	if( !NMG_INDEX_FIRST_TIME(sp->visited, v) )  return;

	bu_ptbl_ins( sp->tabl, vp );
}

/*
 *			N M G _ V E R T E X _ T A B U L A T E
 *
 *  Given a pointer to any nmg data structure,
 *  build an bu_ptbl list which has every vertex
 *  pointer from there on "down" in the model, each one listed exactly once.
 */
void
nmg_vertex_tabulate(struct bu_ptbl *tab, const long int *magic_p)
{
	struct model		*m;
	struct vf_state		st;
	struct nmg_visit_handlers	handlers;

	m = nmg_find_model( magic_p );
	NMG_CK_MODEL(m);

	st.visited = (char *)bu_calloc(m->maxindex+1, sizeof(char), "visited[]");
	st.tabl = tab;

	(void)bu_ptbl_init( tab, 64, " tab");

	handlers = nmg_visit_handlers_null;		/* struct copy */
	handlers.vis_vertex = nmg_2rvf_handler;
	nmg_visit( magic_p, &handlers, (genptr_t)&st );

	bu_free( (char *)st.visited, "visited[]");
}

/*
 *			N M G _ V E R T _ A _ H A N D L E R
 *
 *  A private support routine for nmg_vertexuse_normal_tabulate().
 *  Having just visited a vertexuse-a, if this is the first time,
 *  add it to the bu_ptbl array.
 */
static void
nmg_vert_a_handler(long int *vp, genptr_t state, int first)
{
	register struct vf_state *sp = (struct vf_state *)state;
	register struct vertexuse_a_plane	*va;

	if( *vp != NMG_VERTEXUSE_A_PLANE_MAGIC )
		return;

	va = (struct vertexuse_a_plane *)vp;
	/* If this vertex normal has been processed before, do nothing more */
	if( !NMG_INDEX_FIRST_TIME(sp->visited, va) )  return;

	bu_ptbl_ins( sp->tabl, vp );
}

/*
 *			N M G _ V E R T E X U S E_ N O R M A L _ T A B U L A T E
 *
 *  Given a pointer to any nmg data structure,
 *  build an bu_ptbl list which has every vertexuse normal
 *  pointer from there on "down" in the model, each one listed exactly once.
 */
void
nmg_vertexuse_normal_tabulate(struct bu_ptbl *tab, const long int *magic_p)
{
	struct model		*m;
	struct vf_state		st;
	struct nmg_visit_handlers	handlers;

	m = nmg_find_model( magic_p );
	NMG_CK_MODEL(m);

	st.visited = (char *)bu_calloc(m->maxindex+1, sizeof(char), "visited[]");
	st.tabl = tab;

	(void)bu_ptbl_init( tab, 64, " tab");

	handlers = nmg_visit_handlers_null;		/* struct copy */
	handlers.vis_vertexuse_a = nmg_vert_a_handler;
	nmg_visit( magic_p, &handlers, (genptr_t)&st );

	bu_free( (char *)st.visited, "visited[]");
}

/*
 *			N M G _ 2 E D G E U S E _ H A N D L E R
 *
 *  A private support routine for nmg_edgeuse_tabulate().
 *  Having just visited a edgeuse, if this is the first time,
 *  add it to the bu_ptbl array.
 */
static void
nmg_2edgeuse_handler(long int *eup, genptr_t state, int first)
{
	register struct vf_state *sp = (struct vf_state *)state;
	register struct edgeuse	*eu = (struct edgeuse *)eup;

	NMG_CK_EDGEUSE(eu);
	/* If this edgeuse has been processed before, do nothing more */
	if( !NMG_INDEX_FIRST_TIME(sp->visited, eu) )  return;

	bu_ptbl_ins( sp->tabl, eup );
}

/*
 *			N M G _ E D G E U S E _ T A B U L A T E
 *
 *  Given a pointer to any nmg data structure,
 *  build an bu_ptbl list which has every edgeuse
 *  pointer from there on "down" in the model, each one listed exactly once.
 */
void
nmg_edgeuse_tabulate(struct bu_ptbl *tab, const long int *magic_p)
{
	struct model		*m;
	struct vf_state		st;
	struct nmg_visit_handlers	handlers;

	m = nmg_find_model( magic_p );
	NMG_CK_MODEL(m);

	st.visited = (char *)bu_calloc(m->maxindex+1, sizeof(char), "visited[]");
	st.tabl = tab;

	(void)bu_ptbl_init( tab, 64, " tab");

	handlers = nmg_visit_handlers_null;		/* struct copy */
	handlers.bef_edgeuse = nmg_2edgeuse_handler;
	nmg_visit( magic_p, &handlers, (genptr_t)&st );

	bu_free( (char *)st.visited, "visited[]");
}

/*
 *			N M G _ 2 E D G E _ H A N D L E R
 *
 *  A private support routine for nmg_edge_tabulate().
 *  Having just visited a edge, if this is the first time,
 *  add it to the bu_ptbl array.
 */
static void
nmg_2edge_handler(long int *ep, genptr_t state, int first)
{
	register struct vf_state *sp = (struct vf_state *)state;
	register struct edge	*e = (struct edge *)ep;

	NMG_CK_EDGE(e);
	/* If this edge has been processed before, do nothing more */
	if( !NMG_INDEX_FIRST_TIME(sp->visited, e) )  return;

	bu_ptbl_ins( sp->tabl, ep );
}

/*
 *			N M G _ E D G E _ T A B U L A T E
 *
 *  Given a pointer to any nmg data structure,
 *  build an bu_ptbl list which has every edge
 *  pointer from there on "down" in the model, each one listed exactly once.
 */
void
nmg_edge_tabulate(struct bu_ptbl *tab, const long int *magic_p)
{
	struct model		*m;
	struct vf_state		st;
	struct nmg_visit_handlers	handlers;

	m = nmg_find_model( magic_p );
	NMG_CK_MODEL(m);

	st.visited = (char *)bu_calloc(m->maxindex+1, sizeof(char), "visited[]");
	st.tabl = tab;

	(void)bu_ptbl_init( tab, 64, " tab");

	handlers = nmg_visit_handlers_null;		/* struct copy */
	handlers.vis_edge = nmg_2edge_handler;
	nmg_visit( magic_p, &handlers, (genptr_t)&st );

	bu_free( (char *)st.visited, "visited[]");
}

/*
 *			N M G _ E D G E _ G _ H A N D L E R
 *
 *  A private support routine for nmg_edge_g_tabulate().
 *  Having just visited an edge_g_lseg, if this is the first time,
 *  add it to the bu_ptbl array.
 */
static void
nmg_edge_g_handler(long int *ep, genptr_t state, int first)
{
	register struct vf_state *sp = (struct vf_state *)state;

	NMG_CK_EDGE_G_EITHER(ep);

	/* If this edge has been processed before, do nothing more */
	switch( *ep )  {
	case NMG_EDGE_G_LSEG_MAGIC:
		if( !NMG_INDEX_FIRST_TIME(sp->visited, ((struct edge_g_lseg *)ep)) )
			return;
		break;
	case NMG_EDGE_G_CNURB_MAGIC:
		if( !NMG_INDEX_FIRST_TIME(sp->visited, ((struct edge_g_cnurb *)ep)) )
			return;
		break;
	}

	bu_ptbl_ins( sp->tabl, ep );
}

/*
 *			N M G _ E D G E _ G _ T A B U L A T E
 *
 *  Given a pointer to any nmg data structure,
 *  build an bu_ptbl list which has every edge
 *  pointer from there on "down" in the model, each one listed exactly once.
 */
void
nmg_edge_g_tabulate(struct bu_ptbl *tab, const long int *magic_p)
{
	struct model		*m;
	struct vf_state		st;
	struct nmg_visit_handlers	handlers;

	m = nmg_find_model( magic_p );
	NMG_CK_MODEL(m);

	st.visited = (char *)bu_calloc(m->maxindex+1, sizeof(char), "visited[]");
	st.tabl = tab;

	(void)bu_ptbl_init( tab, 64, " tab");

	handlers = nmg_visit_handlers_null;		/* struct copy */
	handlers.vis_edge_g = nmg_edge_g_handler;
	nmg_visit( magic_p, &handlers, (genptr_t)&st );

	bu_free( (char *)st.visited, "visited[]");
}

/*
 *			N M G _ 2 F A C E _ H A N D L E R
 *
 *  A private support routine for nmg_face_tabulate().
 *  Having just visited a face, if this is the first time,
 *  add it to the bu_ptbl array.
 */
static void
nmg_2face_handler(long int *fp, genptr_t state, int first)
{
	register struct vf_state *sp = (struct vf_state *)state;
	register struct face	*f = (struct face *)fp;

	NMG_CK_FACE(f);
	/* If this face has been processed before, do nothing more */
	if( !NMG_INDEX_FIRST_TIME(sp->visited, f) )  return;

	bu_ptbl_ins( sp->tabl, fp );
}

/*
 *			N M G _ F A C E _ T A B U L A T E
 *
 *  Given a pointer to any nmg data structure,
 *  build an bu_ptbl list which has every face
 *  pointer from there on "down" in the model, each one listed exactly once.
 */
void
nmg_face_tabulate(struct bu_ptbl *tab, const long int *magic_p)
{
	struct model		*m;
	struct vf_state		st;
	struct nmg_visit_handlers	handlers;

	m = nmg_find_model( magic_p );
	NMG_CK_MODEL(m);

	st.visited = (char *)bu_calloc(m->maxindex+1, sizeof(char), "visited[]");
	st.tabl = tab;

	(void)bu_ptbl_init( tab, 64, " tab");

	handlers = nmg_visit_handlers_null;		/* struct copy */
	handlers.vis_face = nmg_2face_handler;
	nmg_visit( magic_p, &handlers, (genptr_t)&st );

	bu_free( (char *)st.visited, "visited[]");
}

/*
 *			N M G _ E D G E U S E _ W I T H _ E G _ T A B U L A T E
 *
 *  Build an bu_ptbl list which cites every edgeuse
 *  pointer that uses edge geometry "eg".
 */
void
nmg_edgeuse_with_eg_tabulate(struct bu_ptbl *tab, const struct edge_g_lseg *eg)
              			     
                        	    	/* can also be edge_g_cnurb */
{
	struct bu_list	*midway;	/* &eu->l2, midway into edgeuse */
	struct edgeuse	*eu;

	NMG_CK_EDGE_G_EITHER(eg);
	(void)bu_ptbl_init( tab, 64, " tab");

	for( BU_LIST_FOR( midway, bu_list, &eg->eu_hd2 ) )  {
		NMG_CKMAG(midway, NMG_EDGEUSE2_MAGIC, "edgeuse2 [l2]");
		eu = BU_LIST_MAIN_PTR( edgeuse, midway, l2 );
		NMG_CK_EDGEUSE(eu);
		if( eu->g.lseg_p != eg )  rt_bomb("nmg_edgeuse_with_eg_tabulate() eu disavows eg\n");
		bu_ptbl_ins_unique( tab, (long *)eu );
	}
}

struct edge_line_state {
	char			*visited;
	struct bu_ptbl		*tabl;
	point_t			pt;
	vect_t			dir;
	struct bn_tol		tol;
};

/*
 *			N M G _ L I N E _ H A N D L E R
 *
 *  A private support routine for nmg_edgeuse_on_line_tabulate.
 *  Having just visited an edgeuse, if this is the first time,
 *  and both vertices of this edgeuse lie within tol of the line,
 *  add it to the bu_ptbl array.
 */
static void
nmg_line_handler(long int *longp, genptr_t state, int first)
{
	register struct edge_line_state *sp = (struct edge_line_state *)state;
	register struct edgeuse	*eu = (struct edgeuse *)longp;

	NMG_CK_EDGEUSE(eu);
	/* If this edgeuse has been processed before, do nothing more */
	if( !NMG_INDEX_FIRST_TIME(sp->visited, eu) )  return;

	/*  If the lines are not generally parallel, don't bother with
	 *  checking the endpoints.  This helps reject very short edges
	 *  which are colinear only by virtue of being very small.
	 */
	BN_CK_TOL(&sp->tol);
	NMG_CK_EDGE_G_LSEG(eu->g.lseg_p);

	/* sp->tol.para and RT_DOT_TOL are too tight. 0.1 is 5 degrees */
	/* These are not unit vectors. */
	if( fabs( VDOT( eu->g.lseg_p->e_dir, sp->dir ) ) <
	    0.9 * MAGNITUDE(eu->g.lseg_p->e_dir) * MAGNITUDE(sp->dir) )
		return;

	if( bn_distsq_line3_pt3( sp->pt, sp->dir, eu->vu_p->v_p->vg_p->coord )
	    > sp->tol.dist_sq )
		return;
	if( bn_distsq_line3_pt3( sp->pt, sp->dir, eu->eumate_p->vu_p->v_p->vg_p->coord )
	    > sp->tol.dist_sq )
		return;

	/* Both points are within tolerance, add edgeuse to the list */
	bu_ptbl_ins( sp->tabl, longp );
}

/*
 *			N M G _ E D G E U S E _ O N _ L I N E _ T A B U L A T E
 *
 *  Given a pointer to any nmg data structure,
 *  build an bu_ptbl list which cites every edgeuse
 *  pointer from there on "down" in the model
 *  that has both vertices within tolerance of the given line.
 *
 *  XXX This routine is a potential source of major trouble.
 *  XXX If there are "nearby" edges that "should" be on the list but
 *  XXX don't make it, then the intersection calculations might
 *  XXX miss important intersections.
 *  As an admittedly grubby workaround, use 10X the distance tol here,
 *  just to get more candidates onto the list.
 *  The caller will have to wrestle with the added fuzz.
 */
void
nmg_edgeuse_on_line_tabulate(struct bu_ptbl *tab, const long int *magic_p, const fastf_t *pt, const fastf_t *dir, const struct bn_tol *tol)
{
	struct model		*m;
	struct edge_line_state		st;
	struct nmg_visit_handlers	handlers;

	m = nmg_find_model( magic_p );
	NMG_CK_MODEL(m);
	BN_CK_TOL(tol);

	st.visited = (char *)bu_calloc(m->maxindex+1, sizeof(char), "visited[]");
	st.tabl = tab;
	VMOVE( st.pt, pt );
	VMOVE( st.dir, dir );

	st.tol = *tol;					/* struct copy */
#if 0
	/* Use larger tolerance */
	st.tol.dist = 10 * tol->dist;
	st.tol.dist_sq = st.tol.dist * st.tol.dist;
#endif

	(void)bu_ptbl_init( tab, 64, " tab");

	handlers = nmg_visit_handlers_null;		/* struct copy */
	handlers.bef_edgeuse = nmg_line_handler;
	nmg_visit( magic_p, &handlers, (genptr_t)&st );

	bu_free( (char *)st.visited, "visited[]");
}

/* XXX Move to nmg_info.c */
struct e_and_v_state  {
	char		*visited;
	struct bu_ptbl	*edges;
	struct bu_ptbl	*verts;
};

/*
 *			N M G _ E _ H A N D L E R
 *
 *  A private support routine for nmg_e_and_v_tabulate().
 *
 *  Note that an edgeUSE is put on the list, to save one memory dereference
 *  in the eventual application.
 */
static void
nmg_e_handler(long int *longp, genptr_t state, int first)
{
	register struct e_and_v_state	*sp = (struct e_and_v_state *)state;
	register struct edge		*e  = (struct edge *)longp;

	NMG_CK_EDGE(e);
	/* If this edge has been processed before, do nothing more */
	if( !NMG_INDEX_FIRST_TIME(sp->visited, e) )  return;

	/* Add to list */
	bu_ptbl_ins( sp->edges, (long *)e->eu_p );
}

/*
 *			N M G _ V _ H A N D L E R
 *
 *  A private support routine for nmg_e_and_v_tabulate().
 */
static void
nmg_v_handler(long int *longp, genptr_t state, int first)
{
	register struct e_and_v_state	*sp = (struct e_and_v_state *)state;
	register struct vertex		*v  = (struct vertex *)longp;

	NMG_CK_VERTEX(v);
	/* If this vertex has been processed before, do nothing more */
	if( !NMG_INDEX_FIRST_TIME(sp->visited, v) )  return;

	/* Add to list */
	bu_ptbl_ins( sp->verts, longp );
}

/*
 *			N M G _ E _ A N D _ V _ T A B U L A T E
 *
 *  Build lists of all edges (represented by one edgeuse on that edge)
 *  and all vertices found underneath the
 *  NMG entity indicated by magic_p.
 */
void
nmg_e_and_v_tabulate(struct bu_ptbl *eutab, struct bu_ptbl *vtab, const long int *magic_p)
{
	struct model			*m;
	struct e_and_v_state		st;
	struct nmg_visit_handlers	handlers;

	m = nmg_find_model( magic_p );
	NMG_CK_MODEL(m);

	st.visited = (char *)bu_calloc(m->maxindex+1, sizeof(char), "visited[]");
	st.edges = eutab;
	st.verts = vtab;

	(void)bu_ptbl_init( eutab, 64, " eutab");
	(void)bu_ptbl_init( vtab, 64, " vtab");

	handlers = nmg_visit_handlers_null;		/* struct copy */
	handlers.vis_edge = nmg_e_handler;
	handlers.vis_vertex = nmg_v_handler;
	nmg_visit( magic_p, &handlers, (genptr_t)&st );

	bu_free( (char *)st.visited, "visited[]");
}

/*
 *			N M G _ 2 E D G E U S E _ G _ C O I N C I D E N T
 *
 *  Given two edgeuses, determine if they share the same edge geometry,
 *  either topologically, or within tolerance.
 *
 *  Returns -
 *	0	two edge geometries are not coincident
 *	1	edges geometries are everywhere coincident.
 *		(For linear edge_g_lseg, the 2 are the same line, within tol.)
 */
int
nmg_2edgeuse_g_coincident(const struct edgeuse *eu1, const struct edgeuse *eu2, const struct bn_tol *tol)
{
	struct edge_g_lseg	*eg1;
	struct edge_g_lseg	*eg2;

	NMG_CK_EDGEUSE(eu1);
	NMG_CK_EDGEUSE(eu2);
	BN_CK_TOL(tol);

	eg1 = eu1->g.lseg_p;
	eg2 = eu2->g.lseg_p;
	NMG_CK_EDGE_G_LSEG(eg1);
	NMG_CK_EDGE_G_LSEG(eg2);

	if( eg1 == eg2 )  return 1;

	/* Ensure direction vectors are generally parallel */
	/* These are not unit vectors */
	/* tol->para and RT_DOT_TOL are too tight a tolerance.  0.1 is 5 degrees */
	if( fabs(VDOT(eg1->e_dir, eg2->e_dir)) <
	    0.9 * MAGNITUDE(eg1->e_dir) * MAGNITUDE(eg2->e_dir)  )  return 0;

	/* Ensure that vertices on edge 2 are within tol of e1 */
	if( bn_distsq_line3_pt3( eg1->e_pt, eg1->e_dir,
	    eu2->vu_p->v_p->vg_p->coord ) > tol->dist_sq )  goto trouble;
	if( bn_distsq_line3_pt3( eg1->e_pt, eg1->e_dir,
	    eu2->eumate_p->vu_p->v_p->vg_p->coord ) > tol->dist_sq )  goto trouble;

	/* Ensure that vertices of both edges are within tol of other eg */
	if( bn_distsq_line3_pt3( eg2->e_pt, eg2->e_dir,
	    eu1->vu_p->v_p->vg_p->coord ) > tol->dist_sq )  goto trouble;
	if( bn_distsq_line3_pt3( eg2->e_pt, eg2->e_dir,
	    eu1->eumate_p->vu_p->v_p->vg_p->coord ) > tol->dist_sq )  goto trouble;

	/* Perhaps check for ultra-short edges (< 10*tol->dist)? */

	/* Do not use bn_isect_line3_line3() -- it's MUCH too strict */

	return 1;
trouble:
	if( !bn_2line3_colinear( eg1->e_pt, eg1->e_dir, eg2->e_pt, eg2->e_dir,
	     1e5, tol ) )
		return 0;

	/* XXX debug */
	nmg_pr_eg( &eg1->l.magic, 0 );
	nmg_pr_eg( &eg2->l.magic, 0 );
	bu_log("nmg_2edgeuse_g_coincident() lines colinear, vertex check fails, calling colinear anyway.\n");
	return 1;
}
@


11.31
log
@change conf.h to a wrapped config.h
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/librt/nmg_info.c,v 11.30 2004/04/05 08:48:57 morrison Exp $ (ARL)";
@


11.30
log
@merge of ansi-6-0-branch into HEAD
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d29 5
a33 1
#include "conf.h"
@


11.29
log
@update copyright to include span through 2003
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_info.c,v 11.28 2002/08/20 17:08:04 jra Exp $ (ARL)";
d56 1
a56 2
nmg_find_model( magic_p_arg )
const long	*magic_p_arg;
d110 1
a110 3
nmg_model_bb( min_pt, max_pt, m )
point_t min_pt, max_pt;
const struct model *m;
d151 1
a151 2
nmg_shell_is_empty(s)
register const struct shell *s;
d169 1
a169 2
nmg_find_s_of_lu(lu)
const struct loopuse *lu;
d184 1
a184 2
nmg_find_s_of_eu(eu)
const struct edgeuse *eu;
d199 1
a199 2
nmg_find_s_of_vu(vu)
const struct vertexuse *vu;
d221 1
a221 2
nmg_find_fu_of_eu(eu)
const struct edgeuse *eu;
d236 1
a236 2
nmg_find_fu_of_lu(lu)
const struct loopuse *lu;
d258 1
a258 2
nmg_find_fu_of_vu(vu)
const struct vertexuse *vu;
d301 1
a301 3
nmg_find_fu_with_fg_in_s( s1, fu2 )
const struct shell	*s1;
const struct faceuse	*fu2;
d355 1
a355 5
nmg_measure_fu_angle( eu, xvec, yvec, zvec )
const struct edgeuse	*eu;
const vect_t		xvec;
const vect_t		yvec;
const vect_t		zvec;
d379 1
a379 2
nmg_find_lu_of_vu( vu )
const struct vertexuse *vu;
d421 1
a421 2
nmg_loop_is_a_crack( lu )
const struct loopuse	*lu;
d510 1
a510 4
nmg_loop_is_ccw( lu, norm, tol )
const struct loopuse	*lu;
const plane_t		norm;
const struct bn_tol	*tol;
d582 1
a582 2
nmg_loop_touches_self( lu )
const struct loopuse	*lu;
d648 1
a648 3
nmg_find_matching_eu_in_s( eu1, s2 )
const struct edgeuse	*eu1;
const struct shell	*s2;
d691 1
a691 5
nmg_findeu(v1, v2, s, eup, dangling_only)
const struct vertex	*v1, *v2;
const struct shell	*s;
const struct edgeuse	*eup;
int		dangling_only;
d787 1
a787 6
nmg_find_eu_in_face( v1, v2, fu, eup, dangling_only )
const struct vertex	*v1;
const struct vertex	*v2;
const struct faceuse	*fu;
const struct edgeuse	*eup;
int		dangling_only;
d892 1
a892 5
nmg_find_e(v1, v2, s, ep)
const struct vertex	*v1;
const struct vertex	*v2;
const struct shell	*s;
const struct edge	*ep;
d967 1
a967 2
nmg_find_eu_of_vu(vu)
const struct vertexuse	*vu;
d981 1
a981 3
nmg_find_eu_with_vu_in_lu( lu, vu )
const struct loopuse		*lu;
const struct vertexuse	*vu;
d1004 1
a1004 2
nmg_faceradial(eu)
const struct edgeuse *eu;
d1032 1
a1032 2
nmg_radial_face_edge_in_shell(eu)
const struct edgeuse *eu;
d1074 1
a1074 4
nmg_find_edge_between_2fu(fu1, fu2, tol)
const struct faceuse	*fu1;
const struct faceuse	*fu2;
const struct bn_tol	*tol;
d1159 1
a1159 4
nmg_find_e_pt2_handler( lp, state, first )
long		*lp;
genptr_t	state;
int		first;
d1202 5
a1206 5
nmg_find_e_nearest_pt2( magic_p, pt2, mat, tol )
long		*magic_p;
const point_t	pt2;		/* 2d point */
const mat_t	mat;		/* 3d to 3d xform */
const struct bn_tol	*tol;
d1249 1
a1249 6
nmg_eu_2vecs_perp( xvec, yvec, zvec, eu, tol )
vect_t		xvec;
vect_t		yvec;
vect_t		zvec;
const struct edgeuse	*eu;
const struct bn_tol	*tol;
d1290 1
a1290 3
nmg_find_eu_leftvec( left, eu )
vect_t			left;
const struct edgeuse	*eu;
d1440 1
a1440 3
nmg_find_eu_left_non_unit( left, eu )
vect_t			left;
const struct edgeuse	*eu;
d1474 1
a1474 2
nmg_find_ot_same_eu_of_e( e )
const struct edge	*e;
d1510 1
a1510 3
nmg_find_v_in_face(v, fu)
const struct vertex	*v;
const struct faceuse	*fu;
d1548 1
a1548 4
nmg_find_v_in_shell( v, s, edges_only )
const struct vertex	*v;
const struct shell	*s;
int			edges_only;
d1589 1
a1589 4
nmg_find_pt_in_lu(lu, pt, tol)
const struct loopuse	*lu;
const point_t		pt;
const struct bn_tol	*tol;
d1639 1
a1639 4
nmg_find_pt_in_face(fu, pt, tol)
const struct faceuse	*fu;
const point_t		pt;
const struct bn_tol	*tol;
d1673 1
a1673 4
nmg_find_pt_in_shell( s, pt, tol )
const struct shell	*s;
const point_t		pt;
const struct bn_tol	*tol;
d1750 1
a1750 4
nmg_find_pt_in_model( m, pt, tol )
const struct model	*m;
const point_t		pt;
const struct bn_tol	*tol;
d1780 1
a1780 3
nmg_is_vertex_in_edgelist( v, hd )
register const struct vertex	*v;
const struct bu_list		*hd;
d1802 1
a1802 4
nmg_is_vertex_in_looplist( v, hd, singletons )
register const struct vertex	*v;
const struct bu_list		*hd;
int				singletons;
d1836 1
a1836 3
nmg_is_vertex_in_face( v, f )
const struct vertex	*v;
const struct face	*f;
d1871 1
a1871 3
nmg_is_vertex_a_selfloop_in_shell(v, s)
const struct vertex	*v;
const struct shell	*s;
d1901 1
a1901 3
nmg_is_vertex_in_facelist( v, hd )
register const struct vertex	*v;
const struct bu_list		*hd;
d1922 1
a1922 3
nmg_is_edge_in_edgelist( e, hd )
const struct edge	*e;
const struct bu_list	*hd;
d1943 1
a1943 3
nmg_is_edge_in_looplist( e, hd )
const struct edge	*e;
const struct bu_list	*hd;
d1973 1
a1973 3
nmg_is_edge_in_facelist( e, hd )
const struct edge	*e;
const struct bu_list	*hd;
d1994 1
a1994 3
nmg_is_loop_in_facelist( l, fu_hd )
const struct loop	*l;
const struct bu_list	*fu_hd;
d2030 1
a2030 4
nmg_2rvf_handler( vp, state, first )
long		*vp;
genptr_t	state;
int		first;
d2050 1
a2050 3
nmg_vertex_tabulate( tab, magic_p )
struct bu_ptbl		*tab;
const long		*magic_p;
d2079 1
a2079 4
nmg_vert_a_handler( vp, state, first )
long		*vp;
genptr_t	state;
int		first;
d2102 1
a2102 3
nmg_vertexuse_normal_tabulate( tab, magic_p )
struct bu_ptbl		*tab;
const long		*magic_p;
d2131 1
a2131 4
nmg_2edgeuse_handler( eup, state, first )
long		*eup;
genptr_t	state;
int		first;
d2151 1
a2151 3
nmg_edgeuse_tabulate( tab, magic_p )
struct bu_ptbl		*tab;
const long		*magic_p;
d2180 1
a2180 4
nmg_2edge_handler( ep, state, first )
long		*ep;
genptr_t	state;
int		first;
d2200 1
a2200 3
nmg_edge_tabulate( tab, magic_p )
struct bu_ptbl		*tab;
const long		*magic_p;
d2229 1
a2229 4
nmg_edge_g_handler( ep, state, first )
long		*ep;
genptr_t	state;
int		first;
d2258 1
a2258 3
nmg_edge_g_tabulate( tab, magic_p )
struct bu_ptbl		*tab;
const long		*magic_p;
d2287 1
a2287 4
nmg_2face_handler( fp, state, first )
long		*fp;
genptr_t	state;
int		first;
d2307 1
a2307 3
nmg_face_tabulate( tab, magic_p )
struct bu_ptbl		*tab;
const long		*magic_p;
d2335 3
a2337 3
nmg_edgeuse_with_eg_tabulate( tab, eg )
struct bu_ptbl			*tab;
const struct edge_g_lseg	*eg;	/* can also be edge_g_cnurb */
d2371 1
a2371 4
nmg_line_handler( longp, state, first )
long		*longp;
genptr_t	state;
int		first;
d2421 1
a2421 6
nmg_edgeuse_on_line_tabulate( tab, magic_p, pt, dir, tol )
struct bu_ptbl		*tab;
const long		*magic_p;
const point_t		pt;
const vect_t		dir;
const struct bn_tol	*tol;
d2468 1
a2468 4
nmg_e_handler( longp, state, first )
long		*longp;
genptr_t	state;
int		first;
d2487 1
a2487 4
nmg_v_handler( longp, state, first )
long		*longp;
genptr_t	state;
int		first;
d2508 1
a2508 4
nmg_e_and_v_tabulate( eutab, vtab, magic_p )
struct bu_ptbl		*eutab;
struct bu_ptbl		*vtab;
const long		*magic_p;
d2544 1
a2544 4
nmg_2edgeuse_g_coincident( eu1, eu2, tol )
const struct edgeuse	*eu1;
const struct edgeuse	*eu2;
const struct bn_tol	*tol;
@


11.28
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d22 1
a22 1
 *	This software is Copyright (C) 1993 by the United States Army
d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_info.c,v 11.26 2001/05/17 20:05:25 morrison Exp $ (ARL)";
@


11.28.4.1
log
@sync to HEAD...
@
text
@d22 1
a22 1
 *	This software is Copyright (C) 1993-2004 by the United States Army
d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/nmg_info.c,v 11.29 2004/02/02 17:39:23 morrison Exp $ (ARL)";
@


11.28.10.1
log
@merge from HEAD
@
text
@d22 1
a22 1
 *	This software is Copyright (C) 1993-2004 by the United States Army
d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_info.c,v 11.29 2004/02/02 17:39:23 morrison Exp $ (ARL)";
@


11.28.10.2
log
@merge from head
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_info.c,v 11.28.10.1 2004/02/12 18:37:43 erikg Exp $ (ARL)";
@


11.28.2.1
log
@Initial ANSIfication
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_info.c,v 11.28 2002/08/20 17:08:04 jra Exp $ (ARL)";
d56 2
a57 1
nmg_find_model(const long int *magic_p_arg)
d111 3
a113 1
nmg_model_bb(fastf_t *min_pt, fastf_t *max_pt, const struct model *m)
d154 2
a155 1
nmg_shell_is_empty(register const struct shell *s)
d173 2
a174 1
nmg_find_s_of_lu(const struct loopuse *lu)
d189 2
a190 1
nmg_find_s_of_eu(const struct edgeuse *eu)
d205 2
a206 1
nmg_find_s_of_vu(const struct vertexuse *vu)
d228 2
a229 1
nmg_find_fu_of_eu(const struct edgeuse *eu)
d244 2
a245 1
nmg_find_fu_of_lu(const struct loopuse *lu)
d267 2
a268 1
nmg_find_fu_of_vu(const struct vertexuse *vu)
d311 3
a313 1
nmg_find_fu_with_fg_in_s(const struct shell *s1, const struct faceuse *fu2)
d367 5
a371 1
nmg_measure_fu_angle(const struct edgeuse *eu, const fastf_t *xvec, const fastf_t *yvec, const fastf_t *zvec)
d395 2
a396 1
nmg_find_lu_of_vu(const struct vertexuse *vu)
d438 2
a439 1
nmg_loop_is_a_crack(const struct loopuse *lu)
d528 4
a531 1
nmg_loop_is_ccw(const struct loopuse *lu, const fastf_t *norm, const struct bn_tol *tol)
d603 2
a604 1
nmg_loop_touches_self(const struct loopuse *lu)
d670 3
a672 1
nmg_find_matching_eu_in_s(const struct edgeuse *eu1, const struct shell *s2)
d715 5
a719 1
nmg_findeu(const struct vertex *v1, const struct vertex *v2, const struct shell *s, const struct edgeuse *eup, int dangling_only)
d815 6
a820 1
nmg_find_eu_in_face(const struct vertex *v1, const struct vertex *v2, const struct faceuse *fu, const struct edgeuse *eup, int dangling_only)
d925 5
a929 1
nmg_find_e(const struct vertex *v1, const struct vertex *v2, const struct shell *s, const struct edge *ep)
d1004 2
a1005 1
nmg_find_eu_of_vu(const struct vertexuse *vu)
d1019 3
a1021 1
nmg_find_eu_with_vu_in_lu(const struct loopuse *lu, const struct vertexuse *vu)
d1044 2
a1045 1
nmg_faceradial(const struct edgeuse *eu)
d1073 2
a1074 1
nmg_radial_face_edge_in_shell(const struct edgeuse *eu)
d1116 4
a1119 1
nmg_find_edge_between_2fu(const struct faceuse *fu1, const struct faceuse *fu2, const struct bn_tol *tol)
d1204 4
a1207 1
nmg_find_e_pt2_handler(long int *lp, genptr_t state, int first)
d1250 5
a1254 5
nmg_find_e_nearest_pt2(long int *magic_p, const fastf_t *pt2, const fastf_t *mat, const struct bn_tol *tol)
    		         
             	    		/* 2d point */
           	    		/* 3d to 3d xform */
                   	     
d1297 6
a1302 1
nmg_eu_2vecs_perp(fastf_t *xvec, fastf_t *yvec, fastf_t *zvec, const struct edgeuse *eu, const struct bn_tol *tol)
d1343 3
a1345 1
nmg_find_eu_leftvec(fastf_t *left, const struct edgeuse *eu)
d1495 3
a1497 1
nmg_find_eu_left_non_unit(fastf_t *left, const struct edgeuse *eu)
d1531 2
a1532 1
nmg_find_ot_same_eu_of_e(const struct edge *e)
d1568 3
a1570 1
nmg_find_v_in_face(const struct vertex *v, const struct faceuse *fu)
d1608 4
a1611 1
nmg_find_v_in_shell(const struct vertex *v, const struct shell *s, int edges_only)
d1652 4
a1655 1
nmg_find_pt_in_lu(const struct loopuse *lu, const fastf_t *pt, const struct bn_tol *tol)
d1705 4
a1708 1
nmg_find_pt_in_face(const struct faceuse *fu, const fastf_t *pt, const struct bn_tol *tol)
d1742 4
a1745 1
nmg_find_pt_in_shell(const struct shell *s, const fastf_t *pt, const struct bn_tol *tol)
d1822 4
a1825 1
nmg_find_pt_in_model(const struct model *m, const fastf_t *pt, const struct bn_tol *tol)
d1855 3
a1857 1
nmg_is_vertex_in_edgelist(register const struct vertex *v, const struct bu_list *hd)
d1879 4
a1882 1
nmg_is_vertex_in_looplist(register const struct vertex *v, const struct bu_list *hd, int singletons)
d1916 3
a1918 1
nmg_is_vertex_in_face(const struct vertex *v, const struct face *f)
d1953 3
a1955 1
nmg_is_vertex_a_selfloop_in_shell(const struct vertex *v, const struct shell *s)
d1985 3
a1987 1
nmg_is_vertex_in_facelist(register const struct vertex *v, const struct bu_list *hd)
d2008 3
a2010 1
nmg_is_edge_in_edgelist(const struct edge *e, const struct bu_list *hd)
d2031 3
a2033 1
nmg_is_edge_in_looplist(const struct edge *e, const struct bu_list *hd)
d2063 3
a2065 1
nmg_is_edge_in_facelist(const struct edge *e, const struct bu_list *hd)
d2086 3
a2088 1
nmg_is_loop_in_facelist(const struct loop *l, const struct bu_list *fu_hd)
d2124 4
a2127 1
nmg_2rvf_handler(long int *vp, genptr_t state, int first)
d2147 3
a2149 1
nmg_vertex_tabulate(struct bu_ptbl *tab, const long int *magic_p)
d2178 4
a2181 1
nmg_vert_a_handler(long int *vp, genptr_t state, int first)
d2204 3
a2206 1
nmg_vertexuse_normal_tabulate(struct bu_ptbl *tab, const long int *magic_p)
d2235 4
a2238 1
nmg_2edgeuse_handler(long int *eup, genptr_t state, int first)
d2258 3
a2260 1
nmg_edgeuse_tabulate(struct bu_ptbl *tab, const long int *magic_p)
d2289 4
a2292 1
nmg_2edge_handler(long int *ep, genptr_t state, int first)
d2312 3
a2314 1
nmg_edge_tabulate(struct bu_ptbl *tab, const long int *magic_p)
d2343 4
a2346 1
nmg_edge_g_handler(long int *ep, genptr_t state, int first)
d2375 3
a2377 1
nmg_edge_g_tabulate(struct bu_ptbl *tab, const long int *magic_p)
d2406 4
a2409 1
nmg_2face_handler(long int *fp, genptr_t state, int first)
d2429 3
a2431 1
nmg_face_tabulate(struct bu_ptbl *tab, const long int *magic_p)
d2459 3
a2461 3
nmg_edgeuse_with_eg_tabulate(struct bu_ptbl *tab, const struct edge_g_lseg *eg)
              			     
                        	    	/* can also be edge_g_cnurb */
d2495 4
a2498 1
nmg_line_handler(long int *longp, genptr_t state, int first)
d2548 6
a2553 1
nmg_edgeuse_on_line_tabulate(struct bu_ptbl *tab, const long int *magic_p, const fastf_t *pt, const fastf_t *dir, const struct bn_tol *tol)
d2600 4
a2603 1
nmg_e_handler(long int *longp, genptr_t state, int first)
d2622 4
a2625 1
nmg_v_handler(long int *longp, genptr_t state, int first)
d2646 4
a2649 1
nmg_e_and_v_tabulate(struct bu_ptbl *eutab, struct bu_ptbl *vtab, const long int *magic_p)
d2685 4
a2688 1
nmg_2edgeuse_g_coincident(const struct edgeuse *eu1, const struct edgeuse *eu2, const struct bn_tol *tol)
@


11.28.2.2
log
@sync branch with HEAD
@
text
@d22 1
a22 1
 *	This software is Copyright (C) 1993-2004 by the United States Army
d26 1
a26 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
@


11.27
log
@Converted from K&R to ANSI C - RFH
@
text
@d56 2
a57 1
nmg_find_model(const long int *magic_p_arg)
d111 3
a113 1
nmg_model_bb(fastf_t *min_pt, fastf_t *max_pt, const struct model *m)
d154 2
a155 1
nmg_shell_is_empty(register const struct shell *s)
d173 2
a174 1
nmg_find_s_of_lu(const struct loopuse *lu)
d189 2
a190 1
nmg_find_s_of_eu(const struct edgeuse *eu)
d205 2
a206 1
nmg_find_s_of_vu(const struct vertexuse *vu)
d228 2
a229 1
nmg_find_fu_of_eu(const struct edgeuse *eu)
d244 2
a245 1
nmg_find_fu_of_lu(const struct loopuse *lu)
d267 2
a268 1
nmg_find_fu_of_vu(const struct vertexuse *vu)
d311 3
a313 1
nmg_find_fu_with_fg_in_s(const struct shell *s1, const struct faceuse *fu2)
d367 5
a371 1
nmg_measure_fu_angle(const struct edgeuse *eu, const fastf_t *xvec, const fastf_t *yvec, const fastf_t *zvec)
d395 2
a396 1
nmg_find_lu_of_vu(const struct vertexuse *vu)
d438 2
a439 1
nmg_loop_is_a_crack(const struct loopuse *lu)
d528 4
a531 1
nmg_loop_is_ccw(const struct loopuse *lu, const fastf_t *norm, const struct bn_tol *tol)
d603 2
a604 1
nmg_loop_touches_self(const struct loopuse *lu)
d670 3
a672 1
nmg_find_matching_eu_in_s(const struct edgeuse *eu1, const struct shell *s2)
d715 5
a719 1
nmg_findeu(const struct vertex *v1, const struct vertex *v2, const struct shell *s, const struct edgeuse *eup, int dangling_only)
d815 6
a820 1
nmg_find_eu_in_face(const struct vertex *v1, const struct vertex *v2, const struct faceuse *fu, const struct edgeuse *eup, int dangling_only)
d925 5
a929 1
nmg_find_e(const struct vertex *v1, const struct vertex *v2, const struct shell *s, const struct edge *ep)
d1004 2
a1005 1
nmg_find_eu_of_vu(const struct vertexuse *vu)
d1019 3
a1021 1
nmg_find_eu_with_vu_in_lu(const struct loopuse *lu, const struct vertexuse *vu)
d1044 2
a1045 1
nmg_faceradial(const struct edgeuse *eu)
d1073 2
a1074 1
nmg_radial_face_edge_in_shell(const struct edgeuse *eu)
d1116 4
a1119 1
nmg_find_edge_between_2fu(const struct faceuse *fu1, const struct faceuse *fu2, const struct bn_tol *tol)
d1204 4
a1207 1
nmg_find_e_pt2_handler(long int *lp, genptr_t state, int first)
d1250 5
a1254 5
nmg_find_e_nearest_pt2(long int *magic_p, const fastf_t *pt2, const fastf_t *mat, const struct bn_tol *tol)
    		         
             	    		/* 2d point */
           	    		/* 3d to 3d xform */
                   	     
d1297 6
a1302 1
nmg_eu_2vecs_perp(fastf_t *xvec, fastf_t *yvec, fastf_t *zvec, const struct edgeuse *eu, const struct bn_tol *tol)
d1343 3
a1345 1
nmg_find_eu_leftvec(fastf_t *left, const struct edgeuse *eu)
d1495 3
a1497 1
nmg_find_eu_left_non_unit(fastf_t *left, const struct edgeuse *eu)
d1531 2
a1532 1
nmg_find_ot_same_eu_of_e(const struct edge *e)
d1568 3
a1570 1
nmg_find_v_in_face(const struct vertex *v, const struct faceuse *fu)
d1608 4
a1611 1
nmg_find_v_in_shell(const struct vertex *v, const struct shell *s, int edges_only)
d1652 4
a1655 1
nmg_find_pt_in_lu(const struct loopuse *lu, const fastf_t *pt, const struct bn_tol *tol)
d1705 4
a1708 1
nmg_find_pt_in_face(const struct faceuse *fu, const fastf_t *pt, const struct bn_tol *tol)
d1742 4
a1745 1
nmg_find_pt_in_shell(const struct shell *s, const fastf_t *pt, const struct bn_tol *tol)
d1822 4
a1825 1
nmg_find_pt_in_model(const struct model *m, const fastf_t *pt, const struct bn_tol *tol)
d1855 3
a1857 1
nmg_is_vertex_in_edgelist(register const struct vertex *v, const struct bu_list *hd)
d1879 4
a1882 1
nmg_is_vertex_in_looplist(register const struct vertex *v, const struct bu_list *hd, int singletons)
d1916 3
a1918 1
nmg_is_vertex_in_face(const struct vertex *v, const struct face *f)
d1953 3
a1955 1
nmg_is_vertex_a_selfloop_in_shell(const struct vertex *v, const struct shell *s)
d1985 3
a1987 1
nmg_is_vertex_in_facelist(register const struct vertex *v, const struct bu_list *hd)
d2008 3
a2010 1
nmg_is_edge_in_edgelist(const struct edge *e, const struct bu_list *hd)
d2031 3
a2033 1
nmg_is_edge_in_looplist(const struct edge *e, const struct bu_list *hd)
d2063 3
a2065 1
nmg_is_edge_in_facelist(const struct edge *e, const struct bu_list *hd)
d2086 3
a2088 1
nmg_is_loop_in_facelist(const struct loop *l, const struct bu_list *fu_hd)
d2124 4
a2127 1
nmg_2rvf_handler(long int *vp, genptr_t state, int first)
d2147 3
a2149 1
nmg_vertex_tabulate(struct bu_ptbl *tab, const long int *magic_p)
d2178 4
a2181 1
nmg_vert_a_handler(long int *vp, genptr_t state, int first)
d2204 3
a2206 1
nmg_vertexuse_normal_tabulate(struct bu_ptbl *tab, const long int *magic_p)
d2235 4
a2238 1
nmg_2edgeuse_handler(long int *eup, genptr_t state, int first)
d2258 3
a2260 1
nmg_edgeuse_tabulate(struct bu_ptbl *tab, const long int *magic_p)
d2289 4
a2292 1
nmg_2edge_handler(long int *ep, genptr_t state, int first)
d2312 3
a2314 1
nmg_edge_tabulate(struct bu_ptbl *tab, const long int *magic_p)
d2343 4
a2346 1
nmg_edge_g_handler(long int *ep, genptr_t state, int first)
d2375 3
a2377 1
nmg_edge_g_tabulate(struct bu_ptbl *tab, const long int *magic_p)
d2406 4
a2409 1
nmg_2face_handler(long int *fp, genptr_t state, int first)
d2429 3
a2431 1
nmg_face_tabulate(struct bu_ptbl *tab, const long int *magic_p)
d2459 3
a2461 3
nmg_edgeuse_with_eg_tabulate(struct bu_ptbl *tab, const struct edge_g_lseg *eg)
              			     
                        	    	/* can also be edge_g_cnurb */
d2495 4
a2498 1
nmg_line_handler(long int *longp, genptr_t state, int first)
d2548 6
a2553 1
nmg_edgeuse_on_line_tabulate(struct bu_ptbl *tab, const long int *magic_p, const fastf_t *pt, const fastf_t *dir, const struct bn_tol *tol)
d2600 4
a2603 1
nmg_e_handler(long int *longp, genptr_t state, int first)
d2622 4
a2625 1
nmg_v_handler(long int *longp, genptr_t state, int first)
d2646 4
a2649 1
nmg_e_and_v_tabulate(struct bu_ptbl *eutab, struct bu_ptbl *vtab, const long int *magic_p)
d2685 4
a2688 1
nmg_2edgeuse_g_coincident(const struct edgeuse *eu1, const struct edgeuse *eu2, const struct bn_tol *tol)
@


11.26
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_info.c,v 11.25 2001/04/05 19:35:35 morrison Exp $ (ARL)";
d56 1
a56 2
nmg_find_model( magic_p_arg )
const long	*magic_p_arg;
d110 1
a110 3
nmg_model_bb( min_pt, max_pt, m )
point_t min_pt, max_pt;
const struct model *m;
d151 1
a151 2
nmg_shell_is_empty(s)
register const struct shell *s;
d169 1
a169 2
nmg_find_s_of_lu(lu)
const struct loopuse *lu;
d184 1
a184 2
nmg_find_s_of_eu(eu)
const struct edgeuse *eu;
d199 1
a199 2
nmg_find_s_of_vu(vu)
const struct vertexuse *vu;
d221 1
a221 2
nmg_find_fu_of_eu(eu)
const struct edgeuse *eu;
d236 1
a236 2
nmg_find_fu_of_lu(lu)
const struct loopuse *lu;
d258 1
a258 2
nmg_find_fu_of_vu(vu)
const struct vertexuse *vu;
d301 1
a301 3
nmg_find_fu_with_fg_in_s( s1, fu2 )
const struct shell	*s1;
const struct faceuse	*fu2;
d355 1
a355 5
nmg_measure_fu_angle( eu, xvec, yvec, zvec )
const struct edgeuse	*eu;
const vect_t		xvec;
const vect_t		yvec;
const vect_t		zvec;
d379 1
a379 2
nmg_find_lu_of_vu( vu )
const struct vertexuse *vu;
d421 1
a421 2
nmg_loop_is_a_crack( lu )
const struct loopuse	*lu;
d510 1
a510 4
nmg_loop_is_ccw( lu, norm, tol )
const struct loopuse	*lu;
const plane_t		norm;
const struct bn_tol	*tol;
d582 1
a582 2
nmg_loop_touches_self( lu )
const struct loopuse	*lu;
d648 1
a648 3
nmg_find_matching_eu_in_s( eu1, s2 )
const struct edgeuse	*eu1;
const struct shell	*s2;
d691 1
a691 5
nmg_findeu(v1, v2, s, eup, dangling_only)
const struct vertex	*v1, *v2;
const struct shell	*s;
const struct edgeuse	*eup;
int		dangling_only;
d787 1
a787 6
nmg_find_eu_in_face( v1, v2, fu, eup, dangling_only )
const struct vertex	*v1;
const struct vertex	*v2;
const struct faceuse	*fu;
const struct edgeuse	*eup;
int		dangling_only;
d892 1
a892 5
nmg_find_e(v1, v2, s, ep)
const struct vertex	*v1;
const struct vertex	*v2;
const struct shell	*s;
const struct edge	*ep;
d967 1
a967 2
nmg_find_eu_of_vu(vu)
const struct vertexuse	*vu;
d981 1
a981 3
nmg_find_eu_with_vu_in_lu( lu, vu )
const struct loopuse		*lu;
const struct vertexuse	*vu;
d1004 1
a1004 2
nmg_faceradial(eu)
const struct edgeuse *eu;
d1032 1
a1032 2
nmg_radial_face_edge_in_shell(eu)
const struct edgeuse *eu;
d1074 1
a1074 4
nmg_find_edge_between_2fu(fu1, fu2, tol)
const struct faceuse	*fu1;
const struct faceuse	*fu2;
const struct bn_tol	*tol;
d1159 1
a1159 4
nmg_find_e_pt2_handler( lp, state, first )
long		*lp;
genptr_t	state;
int		first;
d1202 5
a1206 5
nmg_find_e_nearest_pt2( magic_p, pt2, mat, tol )
long		*magic_p;
const point_t	pt2;		/* 2d point */
const mat_t	mat;		/* 3d to 3d xform */
const struct bn_tol	*tol;
d1249 1
a1249 6
nmg_eu_2vecs_perp( xvec, yvec, zvec, eu, tol )
vect_t		xvec;
vect_t		yvec;
vect_t		zvec;
const struct edgeuse	*eu;
const struct bn_tol	*tol;
d1290 1
a1290 3
nmg_find_eu_leftvec( left, eu )
vect_t			left;
const struct edgeuse	*eu;
d1440 1
a1440 3
nmg_find_eu_left_non_unit( left, eu )
vect_t			left;
const struct edgeuse	*eu;
d1474 1
a1474 2
nmg_find_ot_same_eu_of_e( e )
const struct edge	*e;
d1510 1
a1510 3
nmg_find_v_in_face(v, fu)
const struct vertex	*v;
const struct faceuse	*fu;
d1548 1
a1548 4
nmg_find_v_in_shell( v, s, edges_only )
const struct vertex	*v;
const struct shell	*s;
int			edges_only;
d1589 1
a1589 4
nmg_find_pt_in_lu(lu, pt, tol)
const struct loopuse	*lu;
const point_t		pt;
const struct bn_tol	*tol;
d1639 1
a1639 4
nmg_find_pt_in_face(fu, pt, tol)
const struct faceuse	*fu;
const point_t		pt;
const struct bn_tol	*tol;
d1673 1
a1673 4
nmg_find_pt_in_shell( s, pt, tol )
const struct shell	*s;
const point_t		pt;
const struct bn_tol	*tol;
d1750 1
a1750 4
nmg_find_pt_in_model( m, pt, tol )
const struct model	*m;
const point_t		pt;
const struct bn_tol	*tol;
d1780 1
a1780 3
nmg_is_vertex_in_edgelist( v, hd )
register const struct vertex	*v;
const struct bu_list		*hd;
d1802 1
a1802 4
nmg_is_vertex_in_looplist( v, hd, singletons )
register const struct vertex	*v;
const struct bu_list		*hd;
int				singletons;
d1836 1
a1836 3
nmg_is_vertex_in_face( v, f )
const struct vertex	*v;
const struct face	*f;
d1871 1
a1871 3
nmg_is_vertex_a_selfloop_in_shell(v, s)
const struct vertex	*v;
const struct shell	*s;
d1901 1
a1901 3
nmg_is_vertex_in_facelist( v, hd )
register const struct vertex	*v;
const struct bu_list		*hd;
d1922 1
a1922 3
nmg_is_edge_in_edgelist( e, hd )
const struct edge	*e;
const struct bu_list	*hd;
d1943 1
a1943 3
nmg_is_edge_in_looplist( e, hd )
const struct edge	*e;
const struct bu_list	*hd;
d1973 1
a1973 3
nmg_is_edge_in_facelist( e, hd )
const struct edge	*e;
const struct bu_list	*hd;
d1994 1
a1994 3
nmg_is_loop_in_facelist( l, fu_hd )
const struct loop	*l;
const struct bu_list	*fu_hd;
d2030 1
a2030 4
nmg_2rvf_handler( vp, state, first )
long		*vp;
genptr_t	state;
int		first;
d2050 1
a2050 3
nmg_vertex_tabulate( tab, magic_p )
struct bu_ptbl		*tab;
const long		*magic_p;
d2079 1
a2079 4
nmg_vert_a_handler( vp, state, first )
long		*vp;
genptr_t	state;
int		first;
d2102 1
a2102 3
nmg_vertexuse_normal_tabulate( tab, magic_p )
struct bu_ptbl		*tab;
const long		*magic_p;
d2131 1
a2131 4
nmg_2edgeuse_handler( eup, state, first )
long		*eup;
genptr_t	state;
int		first;
d2151 1
a2151 3
nmg_edgeuse_tabulate( tab, magic_p )
struct bu_ptbl		*tab;
const long		*magic_p;
d2180 1
a2180 4
nmg_2edge_handler( ep, state, first )
long		*ep;
genptr_t	state;
int		first;
d2200 1
a2200 3
nmg_edge_tabulate( tab, magic_p )
struct bu_ptbl		*tab;
const long		*magic_p;
d2229 1
a2229 4
nmg_edge_g_handler( ep, state, first )
long		*ep;
genptr_t	state;
int		first;
d2258 1
a2258 3
nmg_edge_g_tabulate( tab, magic_p )
struct bu_ptbl		*tab;
const long		*magic_p;
d2287 1
a2287 4
nmg_2face_handler( fp, state, first )
long		*fp;
genptr_t	state;
int		first;
d2307 1
a2307 3
nmg_face_tabulate( tab, magic_p )
struct bu_ptbl		*tab;
const long		*magic_p;
d2335 3
a2337 3
nmg_edgeuse_with_eg_tabulate( tab, eg )
struct bu_ptbl			*tab;
const struct edge_g_lseg	*eg;	/* can also be edge_g_cnurb */
d2371 1
a2371 4
nmg_line_handler( longp, state, first )
long		*longp;
genptr_t	state;
int		first;
d2421 1
a2421 6
nmg_edgeuse_on_line_tabulate( tab, magic_p, pt, dir, tol )
struct bu_ptbl		*tab;
const long		*magic_p;
const point_t		pt;
const vect_t		dir;
const struct bn_tol	*tol;
d2468 1
a2468 4
nmg_e_handler( longp, state, first )
long		*longp;
genptr_t	state;
int		first;
d2487 1
a2487 4
nmg_v_handler( longp, state, first )
long		*longp;
genptr_t	state;
int		first;
d2508 1
a2508 4
nmg_e_and_v_tabulate( eutab, vtab, magic_p )
struct bu_ptbl		*eutab;
struct bu_ptbl		*vtab;
const long		*magic_p;
d2544 1
a2544 4
nmg_2edgeuse_g_coincident( eu1, eu2, tol )
const struct edgeuse	*eu1;
const struct edgeuse	*eu2;
const struct bn_tol	*tol;
@


11.25
log
@updated SIGNED to signed
updated CONST to const
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_info.c,v 11.24 2001/04/02 21:38:10 morrison Exp $ (ARL)";
d542 1
a542 1
		if( rt_g.debug & DEBUG_MATH )
d553 1
a553 1
		if( rt_g.debug & DEBUG_MATH )
d566 1
a566 1
		if( rt_g.debug & DEBUG_MATH )
@


11.24
log
@Deprecated bn_mat_copy() for new performance version of MAT_COPY() macro in h/vmath.h.
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_info.c,v 11.23 2000/10/18 18:10:35 butler Exp $ (ARL)";
d57 1
a57 1
CONST long	*magic_p_arg;
d59 1
a59 1
	register CONST long	*magic_p = magic_p_arg;
d113 1
a113 1
CONST struct model *m;
d155 1
a155 1
register CONST struct shell *s;
d174 1
a174 1
CONST struct loopuse *lu;
d190 1
a190 1
CONST struct edgeuse *eu;
d206 1
a206 1
CONST struct vertexuse *vu;
d229 1
a229 1
CONST struct edgeuse *eu;
d245 1
a245 1
CONST struct loopuse *lu;
d268 1
a268 1
CONST struct vertexuse *vu;
d312 2
a313 2
CONST struct shell	*s1;
CONST struct faceuse	*fu2;
d368 4
a371 4
CONST struct edgeuse	*eu;
CONST vect_t		xvec;
CONST vect_t		yvec;
CONST vect_t		zvec;
d396 1
a396 1
CONST struct vertexuse *vu;
d439 1
a439 1
CONST struct loopuse	*lu;
d529 3
a531 3
CONST struct loopuse	*lu;
CONST plane_t		norm;
CONST struct bn_tol	*tol;
d602 1
a602 1
CONST struct vertexuse *
d604 1
a604 1
CONST struct loopuse	*lu;
d606 3
a608 3
	CONST struct edgeuse	*eu;
	CONST struct vertexuse	*vu;
	CONST struct vertex	*v;
d611 1
a611 1
		return (CONST struct vertexuse *)0;
d615 1
a615 1
		CONST struct vertexuse	*tvu;
d631 2
a632 2
			CONST struct edgeuse		*teu;
			CONST struct loopuse		*tlu;
d652 1
a652 1
	return (CONST struct vertexuse *)0;
d671 2
a672 2
CONST struct edgeuse	*eu1;
CONST struct shell	*s2;
d674 1
a674 1
	CONST struct vertexuse	*vu1a, *vu1b;
d716 3
a718 3
CONST struct vertex	*v1, *v2;
CONST struct shell	*s;
CONST struct edgeuse	*eup;
d721 3
a723 3
	register CONST struct vertexuse	*vu;
	register CONST struct edgeuse	*eu;
	CONST struct edgeuse		*eup_mate;
d816 4
a819 4
CONST struct vertex	*v1;
CONST struct vertex	*v2;
CONST struct faceuse	*fu;
CONST struct edgeuse	*eup;
d822 3
a824 3
	register CONST struct vertexuse	*vu;
	register CONST struct edgeuse	*eu;
	CONST struct edgeuse		*eup_mate;
d926 4
a929 4
CONST struct vertex	*v1;
CONST struct vertex	*v2;
CONST struct shell	*s;
CONST struct edge	*ep;
d931 2
a932 2
	register CONST struct vertexuse	*vu;
	register CONST struct edgeuse	*eu;
d1005 1
a1005 1
CONST struct vertexuse	*vu;
d1020 2
a1021 2
CONST struct loopuse		*lu;
CONST struct vertexuse	*vu;
d1043 1
a1043 1
CONST struct edgeuse *
d1045 1
a1045 1
CONST struct edgeuse *eu;
d1047 2
a1048 2
	CONST struct faceuse *fu;
	CONST struct edgeuse *eur;
d1072 1
a1072 1
CONST struct edgeuse *
d1074 1
a1074 1
CONST struct edgeuse *eu;
d1076 2
a1077 2
	CONST struct edgeuse *eur;
	CONST struct shell	*s;
d1115 1
a1115 1
CONST struct edgeuse *
d1117 3
a1119 3
CONST struct faceuse	*fu1;
CONST struct faceuse	*fu2;
CONST struct bn_tol	*tol;
d1121 2
a1122 2
	CONST struct loopuse	*lu1;
	CONST struct edgeuse	*ret = (CONST struct edgeuse *)NULL;
d1130 1
a1130 1
		CONST struct edgeuse	*eu1;
d1135 1
a1135 1
			CONST struct edgeuse *eur;
d1200 1
a1200 1
	CONST struct bn_tol	*tol;
d1252 3
a1254 3
CONST point_t	pt2;		/* 2d point */
CONST mat_t	mat;		/* 3d to 3d xform */
CONST struct bn_tol	*tol;
d1301 2
a1302 2
CONST struct edgeuse	*eu;
CONST struct bn_tol	*tol;
d1304 1
a1304 1
	CONST struct vertex	*v1, *v2;
d1345 1
a1345 1
CONST struct edgeuse	*eu;
d1347 2
a1348 2
	CONST struct loopuse	*lu;
	CONST struct faceuse	*fu;
d1381 2
a1382 2
		CONST struct edgeuse *eu_next;
		CONST struct edgeuse *eu_prev;
d1497 1
a1497 1
CONST struct edgeuse	*eu;
d1499 2
a1500 2
	CONST struct loopuse	*lu;
	CONST struct faceuse	*fu;
d1532 1
a1532 1
CONST struct edge	*e;
d1569 2
a1570 2
CONST struct vertex	*v;
CONST struct faceuse	*fu;
d1609 2
a1610 2
CONST struct vertex	*v;
CONST struct shell	*s;
d1653 3
a1655 3
CONST struct loopuse	*lu;
CONST point_t		pt;
CONST struct bn_tol	*tol;
d1706 3
a1708 3
CONST struct faceuse	*fu;
CONST point_t		pt;
CONST struct bn_tol	*tol;
d1743 8
a1750 8
CONST struct shell	*s;
CONST point_t		pt;
CONST struct bn_tol	*tol;
{
	CONST struct faceuse	*fu;
	CONST struct loopuse	*lu;
	CONST struct edgeuse	*eu;
	CONST struct vertexuse	*vu;
d1752 1
a1752 1
	CONST struct vertex_g	*vg;
d1823 3
a1825 3
CONST struct model	*m;
CONST point_t		pt;
CONST struct bn_tol	*tol;
d1856 2
a1857 2
register CONST struct vertex	*v;
CONST struct bu_list		*hd;
d1859 1
a1859 1
	register CONST struct edgeuse	*eu;
d1880 2
a1881 2
register CONST struct vertex	*v;
CONST struct bu_list		*hd;
d1884 1
a1884 1
	register CONST struct loopuse	*lu;
d1892 1
a1892 1
			register CONST struct vertexuse	*vu;
d1917 2
a1918 2
CONST struct vertex	*v;
CONST struct face	*f;
d1926 3
a1928 3
		register CONST struct edgeuse	*eu;
		register CONST struct loopuse	*lu;
		register CONST struct faceuse	*fu;
d1954 2
a1955 2
CONST struct vertex	*v;
CONST struct shell	*s;
d1957 1
a1957 1
	CONST struct vertexuse *vu;
d1964 1
a1964 1
		register CONST struct loopuse	*lu;
d1986 2
a1987 2
register CONST struct vertex	*v;
CONST struct bu_list		*hd;
d1989 1
a1989 1
	register CONST struct faceuse	*fu;
d2009 2
a2010 2
CONST struct edge	*e;
CONST struct bu_list	*hd;
d2012 1
a2012 1
	register CONST struct edgeuse	*eu;
d2032 2
a2033 2
CONST struct edge	*e;
CONST struct bu_list	*hd;
d2035 1
a2035 1
	register CONST struct loopuse	*lu;
d2064 2
a2065 2
CONST struct edge	*e;
CONST struct bu_list	*hd;
d2067 1
a2067 1
	register CONST struct faceuse	*fu;
d2087 2
a2088 2
CONST struct loop	*l;
CONST struct bu_list	*fu_hd;
d2090 2
a2091 2
	register CONST struct faceuse	*fu;
	register CONST struct loopuse	*lu;
d2149 1
a2149 1
CONST long		*magic_p;
d2206 1
a2206 1
CONST long		*magic_p;
d2260 1
a2260 1
CONST long		*magic_p;
d2314 1
a2314 1
CONST long		*magic_p;
d2377 1
a2377 1
CONST long		*magic_p;
d2431 1
a2431 1
CONST long		*magic_p;
d2461 1
a2461 1
CONST struct edge_g_lseg	*eg;	/* can also be edge_g_cnurb */
d2550 4
a2553 4
CONST long		*magic_p;
CONST point_t		pt;
CONST vect_t		dir;
CONST struct bn_tol	*tol;
d2649 1
a2649 1
CONST long		*magic_p;
d2686 3
a2688 3
CONST struct edgeuse	*eu1;
CONST struct edgeuse	*eu2;
CONST struct bn_tol	*tol;
@


11.23
log
@Patches for compiling under RedHat 7.0
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_info.c,v 11.22 2000/07/10 23:01:41 mike Exp $ (ARL)";
d1267 1
a1267 1
	bn_mat_copy( st.mat, mat );
@


11.22
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_info.c,v 11.21 2000/04/01 03:04:42 mike Exp $ (ARL)";
d31 3
@


11.21
log
@
missing cast
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_info.c,v 11.20 2000/04/01 01:17:53 mike Exp $ (ARL)";
@


11.20
log
@
externs for nmg_info.c added to raytrace.h
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_info.c,v 11.19 2000/03/28 22:39:59 mike Exp $ (ARL)";
d1271 1
a1271 1
	nmg_visit( magic_p, &htab, &st );
@


11.19
log
@
Cleanup, shuffle.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_info.c,v 11.18 2000/03/28 22:11:15 mike Exp $ (ARL)";
a35 3
#include "./debug.h"	/* For librt debug flags, XXX temp */

RT_EXTERN( fastf_t nmg_loop_plane_area, ( CONST struct loopuse *lu, plane_t pl ) );
d2101 6
@


11.18
log
@
Moved routines from nmg_fuse.c to nmg_info.c
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_info.c,v 11.17 1999/12/30 15:46:53 jra Exp $ (ARL)";
d2665 66
@


11.17
log
@Eliminated some unused variables
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_info.c,v 11.16 1999/07/02 22:19:25 mike Exp $ (ARL)";
d1523 27
d1906 33
@


11.16
log
@
Removed dependence on compat4.h
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_info.c,v 11.15 1999/06/03 01:43:37 mike Exp $ (ARL)";
a1386 1
		fastf_t other_dot;
d1401 1
a1401 1
			other_dot = 1.0 - fabs( VDOT( other_edge, Norm ) );
d1427 1
a1427 1
			other_dot = 1.0 - fabs( VDOT( other_edge, Norm ) );
a1502 3
	fastf_t			dot;
	fastf_t			edge_len_sq;
	fastf_t			sin_sq;
@


11.15
log
@
sed4
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_info.c,v 11.14 1997/07/22 17:04:13 jra Exp $ (ARL)";
d2407 1
a2407 1
	for( BU_LIST_FOR( midway, rt_list, &eg->eu_hd2 ) )  {
@


11.14
log
@Minor fix to nmg_find_eu_leftvec()
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 11.13 1997/06/16 15:37:42 jra Exp jra $ (ARL)";
d1264 1
a1264 1
	st.visited = (char *)rt_calloc(m->maxindex+1, sizeof(char), "visited[]");
d1267 1
a1267 1
	mat_copy( st.mat, mat );
d1276 1
a1276 1
	rt_free( (char *)st.visited, "visited[]" );
d1324 1
a1324 1
	mat_vec_perp( xvec, zvec );
d2096 1
a2096 1
	st.visited = (char *)rt_calloc(m->maxindex+1, sizeof(char), "visited[]");
d2105 1
a2105 1
	rt_free( (char *)st.visited, "visited[]");
d2153 1
a2153 1
	st.visited = (char *)rt_calloc(m->maxindex+1, sizeof(char), "visited[]");
d2162 1
a2162 1
	rt_free( (char *)st.visited, "visited[]");
d2207 1
a2207 1
	st.visited = (char *)rt_calloc(m->maxindex+1, sizeof(char), "visited[]");
d2216 1
a2216 1
	rt_free( (char *)st.visited, "visited[]");
d2261 1
a2261 1
	st.visited = (char *)rt_calloc(m->maxindex+1, sizeof(char), "visited[]");
d2270 1
a2270 1
	rt_free( (char *)st.visited, "visited[]");
d2324 1
a2324 1
	st.visited = (char *)rt_calloc(m->maxindex+1, sizeof(char), "visited[]");
d2333 1
a2333 1
	rt_free( (char *)st.visited, "visited[]");
d2378 1
a2378 1
	st.visited = (char *)rt_calloc(m->maxindex+1, sizeof(char), "visited[]");
d2387 1
a2387 1
	rt_free( (char *)st.visited, "visited[]");
d2501 1
a2501 1
	st.visited = (char *)rt_calloc(m->maxindex+1, sizeof(char), "visited[]");
d2519 1
a2519 1
	rt_free( (char *)st.visited, "visited[]");
d2596 1
a2596 1
	st.visited = (char *)rt_calloc(m->maxindex+1, sizeof(char), "visited[]");
d2608 1
a2608 1
	rt_free( (char *)st.visited, "visited[]");
@


11.13
log
@added nmg_vertexuse_normal_tabulate()
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 11.12 1997/01/14 13:18:23 jra Exp jra $ (ARL)";
d1397 2
d1417 1
d1423 2
d1444 8
a1451 1

d1454 2
@


11.12
log
@Added nmg_find_eu_left_non_unit().
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 11.11 1997/01/07 16:08:21 jra Exp jra $ (ARL)";
d2089 57
@


11.11
log
@Changes to speed up NMG raytracing.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 11.10 1996/09/27 08:27:30 mike Exp jra $ (ARL)";
d1333 1
a1333 1
 *  lies in the plane of the face.
a1350 1
	vect_t			edge_unit;
d1354 2
d1374 1
d1376 2
a1377 2
	VMOVE( edge_unit, edgevect );
	VUNITIZE( edge_unit );
d1379 1
a1379 2
	dot = 1.0 - fabs( VDOT( edge_unit, Norm ) );
	if( dot < 0.0001 && dot > (-0.0001) )
d1464 47
@


11.10
log
@Converted to using proper routine names for LIBBU and LIBBN routines.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 11.9 1996/06/11 17:28:42 jra Exp mike $ (ARL)";
d1353 2
d1366 3
d1372 1
a1372 2
	VSUB2( edgevect, eu->eumate_p->vu_p->v_p->vg_p->coord,
		eu->vu_p->v_p->vg_p->coord );
@


11.9
log
@Added code to nmg_find_eu_leftvec() to attempt to handle EU's that are parallel
to face normal (very short EU's).
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 11.8 1995/02/24 23:50:11 mike Exp jra $ (ARL)";
d63 1
a63 1
		rt_log("nmg_find_model(x%x) enountered null pointer\n",
d95 1
a95 1
		magic_p = &(RT_LIST_FIRST(vertexuse,
d103 2
a104 2
		rt_log("nmg_find_model() can't get model for magic=x%x (%s)\n",
			*magic_p, rt_identify_magic( *magic_p ) );
d123 1
a123 1
	for (RT_LIST_FOR(r, nmgregion, &m->r_hd)) {
d160 3
a162 3
	if( RT_LIST_NON_EMPTY( &s->fu_hd ) )  return 0;
	if( RT_LIST_NON_EMPTY( &s->lu_hd ) )  return 0;
	if( RT_LIST_NON_EMPTY( &s->eu_hd ) )  return 0;
d253 1
a253 1
	    rt_log("Error at %s %d:\nInvalid loopuse parent magic (0x%x %d)\n",
d276 1
a276 1
		if (rt_g.NMG_debug & DEBUG_BASIC) rt_log("nmg_find_fu_of_vu(vu=x%x) vertexuse is child of shell, can't find faceuse\n", vu);
d283 1
a283 1
			if (rt_g.NMG_debug & DEBUG_BASIC) rt_log("nmg_find_fu_of_vu(vu=x%x) vertexuse is child of shell/edgeuse, can't find faceuse\n", vu);
d286 1
a286 1
		rt_log("Error at %s %d:\nInvalid loopuse parent magic 0x%x\n",
d291 1
a291 1
		rt_log("Error at %s %d:\nInvalid vertexuse parent magic 0x%x\n",
d297 1
a297 1
	rt_log("How did I get here %s %d?\n", __FILE__, __LINE__);
d327 1
a327 1
	for( RT_LIST_FOR( fu1, faceuse, &s1->fu_hd ) )  {
d377 1
a377 1
	if( *eu->up.magic_p != NMG_LOOPUSE_MAGIC )  return -rt_pi;
d379 1
a379 1
	if( nmg_find_eu_leftvec( left, eu ) < 0 )  return -rt_pi;
d381 1
a381 1
	ret = rt_angle_measure( left, xvec, yvec );
d455 1
a455 1
	    	if (rt_g.NMG_debug & DEBUG_BASIC)  rt_log("lu up is not faceuse\n");
d462 2
a463 2
	if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )  {
	    	if (rt_g.NMG_debug & DEBUG_BASIC)  rt_log("lu down is not edgeuse\n");
d472 1
a472 1
	for( RT_LIST_FOR( cur_eu, edgeuse, &lu->down_hd ) )  {
d487 1
a487 1
		for( RT_LIST_FOR( test_vu, vertexuse, &next_v->vu_hd ) )  {
d509 1
a509 1
    		rt_log("nmg_loop_is_a_crack(lu=x%x) ret=%d\n", lu, ret );
d531 1
a531 1
CONST struct rt_tol	*tol;
d544 1
a544 1
			rt_log( "nmg_loop_is_ccw: Loop has no area\n" );
d555 1
a555 1
			rt_log( "nmg_loop_is_ccw: Loop area (%g) is less than tol->dist_sq (%g)\n", area, tol->dist_sq );
d568 1
a568 1
			rt_log( "nmg_loop_is_ccw: normal ( %g %g %g ) is in plane of loop ( %g %g %g %g ), dot = %g\n",
d583 1
a583 1
    		rt_log( "nmg_loop_is_ccw(lu=x%x) ret=%d\n" , lu, ret );
d610 1
a610 1
	if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d614 1
a614 1
	for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
d630 1
a630 1
		for( RT_LIST_FOR( tvu, vertexuse, &v->vu_hd ) )  {
d681 1
a681 1
	vu1b = RT_LIST_PNEXT_CIRC( edgeuse, eu1 )->vu_p;
d745 1
a745 1
		rt_log("nmg_findeu() seeking eu!=%8x/%8x between (%8x, %8x) %s\n",
d749 1
a749 1
	for( RT_LIST_FOR( vu, vertexuse, &v1->vu_hd ) )  {
d762 1
a762 1
			rt_log("nmg_findeu: check eu=%8x vertex=(%8x, %8x)\n",
d770 1
a770 1
				rt_log("\tIgnoring -- excluded edgeuse\n");
d777 1
a777 1
		    		rt_log("\tIgnoring x%x -- eu in wrong shell s=%x\n", eu, eu->up.s_p);
d784 1
a784 1
			    	rt_log("\tIgnoring %8x/%8x (radial=x%x)\n",
d792 1
a792 1
		    	rt_log("\tFound %8x/%8x\n", eu, eu->eumate_p);
d803 1
a803 1
	    	rt_log("nmg_findeu() returns x%x\n", eu);
d846 1
a846 1
		rt_log("nmg_find_eu_in_face() seeking eu!=%8x/%8x between (%8x, %8x) %s\n",
d850 1
a850 1
	for( RT_LIST_FOR( vu, vertexuse, &v1->vu_hd ) )  {
d863 1
a863 1
			rt_log("nmg_find_eu_in_face: check eu=%8x vertex=(%8x, %8x)\n",
d871 1
a871 1
				rt_log("\tIgnoring -- excluded edgeuse\n");
d878 1
a878 1
		    		rt_log("\tIgnoring x%x -- eu not in faceuse\n", eu);
d885 1
a885 1
			    	rt_log("\tIgnoring %8x/%8x (radial=x%x)\n",
d893 1
a893 1
		    	rt_log("\tFound %8x/%8x\n", eu, eu->eumate_p);
d904 1
a904 1
	    	rt_log("nmg_find_eu_in_face() returns x%x\n", eu);
d939 1
a939 1
		rt_log("nmg_find_e() seeking e!=%8x between (%8x, %8x)\n",
d943 1
a943 1
	for( RT_LIST_FOR( vu, vertexuse, &v1->vu_hd ) )  {
d957 1
a957 1
			rt_log("nmg_find_e: check eu=%8x vertex=(%8x, %8x)\n",
d965 1
a965 1
				rt_log("\tIgnoring -- excluded edge\n");
d972 1
a972 1
		    		rt_log("\tIgnoring x%x -- eu in wrong shell s=%x\n", eu, eu->up.s_p);
d977 1
a977 1
		    	rt_log("\tFound %8x/%8x\n", eu, eu->eumate_p);
d989 1
a989 1
	    	rt_log("nmg_find_e() returns x%x\n", eu);
d1027 1
a1027 1
	if( RT_LIST_FIRST_MAGIC(&lu->down_hd) != NMG_EDGEUSE_MAGIC )
d1029 1
a1029 1
	for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
d1119 1
a1119 1
CONST struct rt_tol	*tol;
d1127 1
a1127 1
	RT_CK_TOL(tol);
d1129 1
a1129 1
	for( RT_LIST_FOR( lu1, loopuse, &fu1->lu_hd ) )  {
d1132 1
a1132 1
		if( RT_LIST_FIRST_MAGIC(&lu1->down_hd) == NMG_VERTEXUSE_MAGIC )
d1134 1
a1134 1
		for( RT_LIST_FOR( eu1, edgeuse, &lu1->down_hd ) )  {
d1157 1
a1157 1
				    			rt_log("eur=x%x, eg_p=x%x;  ret=x%x, eg_p=x%x\n",
d1168 1
a1168 1
								rt_log("nmg_find_edge_between_2fu() belatedly fusing e1=x%x, eg1=x%x, e2=x%x, eg2=x%x\n",
d1186 1
a1186 1
	if (rt_g.NMG_debug & DEBUG_BASIC)  rt_log("nmg_find_edge_between_2fu(fu1=x%x, fu2=x%x) edgeuse=x%x\n", fu1, fu2, ret);
d1200 1
a1200 1
	CONST struct rt_tol	*tol;
d1217 1
a1217 1
	RT_CK_TOL(sp->tol);
d1231 1
a1231 1
	code = rt_dist_pt2_lseg2( &dist_sq, pca, a2, b2, sp->pt2, sp->tol );
d1254 1
a1254 1
CONST struct rt_tol	*tol;
d1260 1
a1260 1
	RT_CK_TOL(tol);
d1302 1
a1302 1
CONST struct rt_tol	*tol;
d1313 1
a1313 1
	RT_CK_TOL(tol);
d1384 1
a1384 1
		rt_log( "WARNING: eu x%x (%f %f %f) parallel to normal (%f %f %f)\n", eu, V3ARGS( edgevect ), V3ARGS( Norm ) );
d1389 1
a1389 1
			eu_next = RT_LIST_PNEXT_CIRC( edgeuse, &eu_next->l );
d1401 1
a1401 1
			rt_log( "Cannot find edge (starting eu =x%x) that is not parallel to face normal!!!\n", eu );
d1412 1
a1412 1
			eu_prev = RT_LIST_PPREV_CIRC( edgeuse, &eu_prev->l );
d1424 1
a1424 1
			rt_log( "Cannot find edge (starting eu =x%x) that is not parallel to face normal!!!\n", eu );
d1435 1
a1435 1
		rt_log( "\tUnitized left=(%f %f %f)\n", V3ARGS( left ) );
d1448 5
a1452 5
		rt_log( "for eu x%x from fu x%x v1=x%x, v2=x%x:\n", eu, fu, eu->vu_p->v_p, eu->eumate_p->vu_p->v_p );
		rt_log( "\t(%.10f %.10f %.10f) <-> (%.10f %.10f %.10f)\n", V3ARGS( eu->vu_p->v_p->vg_p->coord ), V3ARGS( eu->eumate_p->vu_p->v_p->vg_p->coord ) );
		rt_log( "\tedge dot norm = %.10f\n", VDOT( edge_unit, Norm ) );
		rt_log( "\tnorm X edge = (%.10f %.10f %.10f)\n", V3ARGS( norm_x_edge ) );
		rt_log( "\tnorm=(%.10f %.10f %.10f), edgevect=(%.10f %.10f %.10f), left=(%.10f %.10f %.10f )\n",
d1457 1
a1457 1
		rt_log( "\tUnitized left=(%f %f %f)\n", V3ARGS( left ) );
d1489 1
a1489 1
	for( RT_LIST_FOR( vu, vertexuse, &v->vu_hd ) )  {
d1526 1
a1526 1
	for( RT_LIST_FOR( vu, vertexuse, &v->vu_hd ) )  {
d1566 1
a1566 1
CONST struct rt_tol	*tol;
d1574 1
a1574 1
	magic1 = RT_LIST_FIRST_MAGIC( &lu->down_hd );
d1577 1
a1577 1
		vu = RT_LIST_FIRST(vertexuse, &lu->down_hd);
d1592 1
a1592 1
	for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
d1619 1
a1619 1
CONST struct rt_tol	*tol;
d1625 1
a1625 1
	RT_CK_TOL(tol);
d1627 1
a1627 1
	for( RT_LIST_FOR( lu, loopuse, &fu->lu_hd ) )  {
d1656 1
a1656 1
CONST struct rt_tol	*tol;
d1667 1
a1667 1
	RT_CK_TOL(tol);
d1669 2
a1670 2
	fu = RT_LIST_FIRST(faceuse, &s->fu_hd);
	while (RT_LIST_NOT_HEAD(fu, &s->fu_hd) ) {
d1676 2
a1677 2
		if (RT_LIST_PNEXT(faceuse, fu) == fu->fumate_p)
			fu = RT_LIST_PNEXT_PNEXT(faceuse, fu);
d1679 1
a1679 1
			fu = RT_LIST_PNEXT(faceuse, fu);
d1683 2
a1684 2
	lu = RT_LIST_FIRST(loopuse, &s->lu_hd);
	while (RT_LIST_NOT_HEAD(lu, &s->lu_hd) ) {
d1689 2
a1690 2
		if (RT_LIST_PNEXT(loopuse, lu) == lu->lumate_p)
			lu = RT_LIST_PNEXT_PNEXT(loopuse, lu);
d1692 1
a1692 1
			lu = RT_LIST_PNEXT(loopuse, lu);
d1696 1
a1696 1
	for (RT_LIST_FOR(eu, edgeuse, &s->eu_hd)) {
d1736 1
a1736 1
CONST struct rt_tol	*tol;
d1743 1
a1743 1
	RT_CK_TOL(tol);
d1745 1
a1745 1
	for( RT_LIST_FOR( r, nmgregion, &m->r_hd ) )  {
d1747 1
a1747 1
		for( RT_LIST_FOR( s, shell, &r->s_hd ) )  {
d1768 1
a1768 1
CONST struct rt_list		*hd;
d1773 1
a1773 1
	for( RT_LIST_FOR( eu, edgeuse, hd ) )  {
d1792 1
a1792 1
CONST struct rt_list		*hd;
d1799 1
a1799 1
	for( RT_LIST_FOR( lu, loopuse, hd ) )  {
d1801 1
a1801 1
		magic1 = RT_LIST_FIRST_MAGIC( &lu->down_hd );
d1805 1
a1805 1
			vu = RT_LIST_FIRST(vertexuse, &lu->down_hd );
d1841 1
a1841 1
	for (RT_LIST_FOR(vu, vertexuse, &v->vu_hd)) {
d1865 1
a1865 1
CONST struct rt_list		*hd;
d1870 1
a1870 1
	for( RT_LIST_FOR( fu, faceuse, hd ) )  {
d1888 1
a1888 1
CONST struct rt_list	*hd;
d1893 1
a1893 1
	for( RT_LIST_FOR( eu, edgeuse, hd ) )  {
d1911 1
a1911 1
CONST struct rt_list	*hd;
d1917 1
a1917 1
	for( RT_LIST_FOR( lu, loopuse, hd ) )  {
d1919 1
a1919 1
		magic1 = RT_LIST_FIRST_MAGIC( &lu->down_hd );
d1943 1
a1943 1
CONST struct rt_list	*hd;
d1948 1
a1948 1
	for( RT_LIST_FOR( fu, faceuse, hd ) )  {
d1966 1
a1966 1
CONST struct rt_list	*fu_hd;
d1972 1
a1972 1
	for( RT_LIST_FOR( fu, faceuse, fu_hd ) )  {
d1974 1
a1974 1
		for( RT_LIST_FOR( lu, loopuse, &fu->lu_hd ) )  {
d1985 1
a1985 1
	struct nmg_ptbl	*tabl;
d1993 1
a1993 1
 *  add it to the nmg_ptbl array.
d2008 1
a2008 1
	nmg_tbl( sp->tabl, TBL_INS, vp );
d2015 1
a2015 1
 *  build an nmg_ptbl list which has every vertex
d2020 1
a2020 1
struct nmg_ptbl		*tab;
d2033 1
a2033 1
	(void)nmg_tbl( tab, TBL_INIT, 0 );
d2047 1
a2047 1
 *  add it to the nmg_ptbl array.
d2062 1
a2062 1
	nmg_tbl( sp->tabl, TBL_INS, eup );
d2069 1
a2069 1
 *  build an nmg_ptbl list which has every edgeuse
d2074 1
a2074 1
struct nmg_ptbl		*tab;
d2087 1
a2087 1
	(void)nmg_tbl( tab, TBL_INIT, 0 );
d2101 1
a2101 1
 *  add it to the nmg_ptbl array.
d2116 1
a2116 1
	nmg_tbl( sp->tabl, TBL_INS, ep );
d2123 1
a2123 1
 *  build an nmg_ptbl list which has every edge
d2128 1
a2128 1
struct nmg_ptbl		*tab;
d2141 1
a2141 1
	(void)nmg_tbl( tab, TBL_INIT, 0 );
d2155 1
a2155 1
 *  add it to the nmg_ptbl array.
d2179 1
a2179 1
	nmg_tbl( sp->tabl, TBL_INS, ep );
d2186 1
a2186 1
 *  build an nmg_ptbl list which has every edge
d2191 1
a2191 1
struct nmg_ptbl		*tab;
d2204 1
a2204 1
	(void)nmg_tbl( tab, TBL_INIT, 0 );
d2218 1
a2218 1
 *  add it to the nmg_ptbl array.
d2233 1
a2233 1
	nmg_tbl( sp->tabl, TBL_INS, fp );
d2240 1
a2240 1
 *  build an nmg_ptbl list which has every face
d2245 1
a2245 1
struct nmg_ptbl		*tab;
d2258 1
a2258 1
	(void)nmg_tbl( tab, TBL_INIT, 0 );
d2270 1
a2270 1
 *  Build an nmg_ptbl list which cites every edgeuse
d2275 1
a2275 1
struct nmg_ptbl			*tab;
d2278 1
a2278 1
	struct rt_list	*midway;	/* &eu->l2, midway into edgeuse */
d2282 1
a2282 1
	(void)nmg_tbl( tab, TBL_INIT, 0 );
d2284 1
a2284 1
	for( RT_LIST_FOR( midway, rt_list, &eg->eu_hd2 ) )  {
d2286 1
a2286 1
		eu = RT_LIST_MAIN_PTR( edgeuse, midway, l2 );
d2289 1
a2289 1
		nmg_tbl( tab, TBL_INS_UNIQUE, (long *)eu );
d2295 1
a2295 1
	struct nmg_ptbl		*tabl;
d2298 1
a2298 1
	struct rt_tol		tol;
d2307 1
a2307 1
 *  add it to the nmg_ptbl array.
d2326 1
a2326 1
	RT_CK_TOL(&sp->tol);
d2335 1
a2335 1
	if( rt_distsq_line3_pt3( sp->pt, sp->dir, eu->vu_p->v_p->vg_p->coord )
d2338 1
a2338 1
	if( rt_distsq_line3_pt3( sp->pt, sp->dir, eu->eumate_p->vu_p->v_p->vg_p->coord )
d2343 1
a2343 1
	nmg_tbl( sp->tabl, TBL_INS, longp );
d2350 1
a2350 1
 *  build an nmg_ptbl list which cites every edgeuse
d2364 1
a2364 1
struct nmg_ptbl		*tab;
d2368 1
a2368 1
CONST struct rt_tol	*tol;
d2376 1
a2376 1
	RT_CK_TOL(tol);
d2390 1
a2390 1
	(void)nmg_tbl( tab, TBL_INIT, 0 );
d2402 2
a2403 2
	struct nmg_ptbl	*edges;
	struct nmg_ptbl	*verts;
d2428 1
a2428 1
	nmg_tbl( sp->edges, TBL_INS, (long *)e->eu_p );
d2450 1
a2450 1
	nmg_tbl( sp->verts, TBL_INS, longp );
d2462 2
a2463 2
struct nmg_ptbl		*eutab;
struct nmg_ptbl		*vtab;
d2477 2
a2478 2
	(void)nmg_tbl( eutab, TBL_INIT, 0 );
	(void)nmg_tbl( vtab, TBL_INIT, 0 );
@


11.8
log
@Added nmg_e_and_v_tabulate()
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 11.7 95/02/21 23:11:51 mike Exp Locker: mike $ (ARL)";
d1351 2
d1370 70
d1441 14
d1456 3
@


11.7
log
@Added nmg_find_e()
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 11.6 95/02/19 21:02:55 mike Exp Locker: mike $ (ARL)";
d2305 89
@


11.6
log
@replaced it with a generous 5 degree
angular tolerance as a double-check on the operation of the routine.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 11.5 95/02/17 22:02:08 mike Exp Locker: mike $ (ARL)";
d802 1
a802 1
	if (rt_g.NMG_debug & DEBUG_FINDEU)
d903 1
a903 1
	if (rt_g.NMG_debug & DEBUG_FINDEU)
d905 85
@


11.5
log
@Rewrote nmg_edgeuse_with_eg_tabulate() to use eu_hd2 list
rather than nmg_visit().
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 11.4 95/02/15 22:43:10 mike Exp Locker: mike $ (ARL)";
d2124 1
a2124 1
	CONST struct rt_tol	*tol;
d2152 1
a2152 1
	RT_CK_TOL(sp->tol);
d2154 5
a2158 4
#if 1
	/* XXX This assumes unit vectors.  These are not.  Fixing this causes lots of error messages, though. */
	/* ERROR: vu=x10063d54 v=x10050578 is on isect line, tvu=x10063614 eu=x10081b30 isn't */
	if( fabs( VDOT( eu->g.lseg_p->e_dir, sp->dir ) ) < sp->tol->para )
d2160 1
a2160 5
#else
	/* sp->tol->para and RT_DOT_TOL are too tight. 0.1 is 5 degrees */
	if( fabs( VDOT( eu->g.lseg_p->e_dir, sp->dir ) ) < 0.9 * MAGNITUDE(eu->g.lseg_p->e_dir) * MAGNITUDE(sp->dir) )
		return;
#endif
d2162 1
a2162 1
	    > sp->tol->dist_sq )
d2165 1
a2165 1
	    > sp->tol->dist_sq )
d2179 8
d2208 7
a2214 1
	st.tol = tol;
@


11.4
log
@Made squawking in nmg_find_fu_of_vu() conditional on DEBUG_BASIC.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 11.3 95/02/10 16:26:18 jra Exp Locker: mike $ (ARL)";
a2092 6
struct eg_state {
	char			*visited;
	struct nmg_ptbl		*tabl;
	CONST struct edge_g_lseg	*eg;
};

a2093 26
 *			N M G _ 2 E D G E G E O M _ H A N D L E R
 *
 *  A private support routine for nmg_edgegeom_tabulate().
 *  Having just visited an edgeuse, if this is the first time,
 *  and this edgeuse uses the designated edge geometry,
 *  add it to the nmg_ptbl array.
 */
static void
nmg_2edgegeom_handler( longp, state, first )
long		*longp;
genptr_t	state;
int		first;
{
	register struct eg_state *sp = (struct eg_state *)state;
	register struct edgeuse	*eu = (struct edgeuse *)longp;

	NMG_CK_EDGEUSE(eu);
	/* If this edgeuse has been processed before, do nothing more */
	if( !NMG_INDEX_FIRST_TIME(sp->visited, eu) )  return;

	if( eu->g.lseg_p != sp->eg )  return;

	nmg_tbl( sp->tabl, TBL_INS, longp );
}

/*
d2096 2
a2097 4
 *  Given a pointer to any nmg data structure,
 *  build an nmg_ptbl list which cites every edgeuse
 *  pointer from there on "down" in the model
 *  that uses edge geometry "eg".
d2100 3
a2102 4
nmg_edgeuse_with_eg_tabulate( tab, magic_p, eg )
struct nmg_ptbl		*tab;
CONST long		*magic_p;
CONST struct edge_g_lseg	*eg;
d2104 2
a2105 3
	struct model		*m;
	struct eg_state		st;
	struct nmg_visit_handlers	handlers;
d2107 1
a2107 10
	m = nmg_find_model( magic_p );
	NMG_CK_MODEL(m);
	NMG_CK_EDGE_G_LSEG(eg);

	/* XXX Need to re-write this to use eg->eu_hd list instead */

	st.visited = (char *)rt_calloc(m->maxindex+1, sizeof(char), "visited[]");
	st.tabl = tab;
	st.eg = eg;

d2110 7
a2116 5
	handlers = nmg_visit_handlers_null;		/* struct copy */
	handlers.bef_edgeuse = nmg_2edgegeom_handler;
	nmg_visit( magic_p, &handlers, (genptr_t)&st );

	rt_free( (char *)st.visited, "visited[]");
@


11.3
log
@Rewrote nmg_loop_is_ccw to use nmg_loop_plane_area.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 11.2 95/01/20 19:17:42 mike Exp Locker: jra $ (ARL)";
d276 1
a276 1
		rt_log("nmg_find_fu_of_vu() vertexuse is child of shell, can't find faceuse\n");
d283 1
a283 1
			rt_log("nmg_find_fu_of_vu() vertexuse is child of shell/edgeuse, can't find faceuse\n");
@


11.2
log
@Ensure left vector is unit length.
This change wasn't really necessary.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 11.1 95/01/04 09:57:38 mike Rel4_4 Locker: mike $ (ARL)";
d38 1
a520 9
 *  XXX Consider using John's loop area calculator instead.
 *
 *  Compute the "winding number" for the loop, by calculating all the angles.
 *  A simple square will have a total of +/- 2*pi.
 *  However, each "jaunt" into the interior will increase this total
 *  by pi.
 *  This information is probably useful, but here the only goal is to
 *  determine cw/ccw, so just make sure the total has reached +/- 2*pi.
 *
d533 4
a536 14
	vect_t		edge1, edge2;
	vect_t		left;
	struct edgeuse	*eu;
	struct edgeuse	*next_eu;
	struct vertexuse *this_vu, *next_vu, *third_vu;
	fastf_t		theta = 0;
	fastf_t		x,y;
	fastf_t		rad;
	fastf_t		npi = 0;	/* n * pi, hopefully */
	double		n;		/* integer part of npi */
	fastf_t		residue;	/* fractional part of npi */
	int		n_angles=0;	/* number of edge/edge angles measured */
	int		n_skip=0;	/* number of edges skipped */
	int		ret;
d538 1
a538 3
	NMG_CK_LOOPUSE(lu);
	RT_CK_TOL(tol);
	if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )  return 0;
d540 7
a546 1
	if( nmg_loop_is_a_crack(lu) )  {
d551 6
a556 11
	for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
		next_eu = RT_LIST_PNEXT_CIRC( edgeuse, eu );
		this_vu = eu->vu_p;
		next_vu = eu->eumate_p->vu_p;
		third_vu = next_eu->eumate_p->vu_p;

		/* Skip topological 0-length edges */
		if( this_vu->v_p == next_vu->v_p  ||
		    next_vu->v_p == third_vu->v_p )  {
		    	n_skip++;
		    	continue;
d558 3
d562 1
a562 14
		/* Skip edges with calculated edge lengths near 0 */
		VSUB2( edge1, next_vu->v_p->vg_p->coord, this_vu->v_p->vg_p->coord );
		if( MAGSQ(edge1) < tol->dist_sq )  {
			n_skip++;
			continue;
		}
		VSUB2( edge2, third_vu->v_p->vg_p->coord, next_vu->v_p->vg_p->coord );
		if( MAGSQ(edge2) < tol->dist_sq )  {
			n_skip++;
			continue;
		}
		/* XXX Should use magsq info from above */
		VUNITIZE(edge1);
		VUNITIZE(edge2);
d564 7
a570 16
		/* Compute (loop)inward pointing "left" vector */
		VCROSS( left, norm, edge1 );
		y = VDOT( edge2, left );
		x = VDOT( edge2, edge1 );
		rad = atan2( y, x );

		if( rt_g.debug & DEBUG_MATH )  {
			nmg_pr_eu_briefly(eu,NULL);
			VPRINT("vu1", this_vu->v_p->vg_p->coord);
			VPRINT("vu2", next_vu->v_p->vg_p->coord);
			VPRINT("edge1", edge1);
			VPRINT("edge2", edge2);
			VPRINT("left", left);
			rt_log(" e1=%g, e2=%g, n=%g, l=%g\n", MAGNITUDE(edge1),
				MAGNITUDE(edge2), MAGNITUDE(norm), MAGNITUDE(left));
			rt_log("atan2(%g,%g) = %g\n", y, x, rad);
a571 9
		theta += rad;
		n_angles++;
	}
#if 0
	rt_log(" theta = %g (%g) n_angles=%d\n", theta, theta / rt_twopi, n_angles );
	nmg_face_lu_plot( lu, this_vu, this_vu );
#endif

	if( n_angles < 3 )  {
d576 3
a578 23
	npi = theta * rt_invpi;		/* n * pi.  n should be >= 2 */

	/*  Check that 'npi' is very nearly an integer,
	 *  otherwise that is an indicator of trouble in the calculation.
	 */
	residue = modf( npi, &n );
	/* Sometimes, residue can be almost +/- 1.0, need to fold that in. */
	if( NEAR_ZERO( residue-1, 0.05 ) )  {
		residue -= 1;
		npi += 1;
	} else if( NEAR_ZERO( residue+1, 0.05 ) )  {
		residue += 1;
		npi -= 1;
	}

	if( !NEAR_ZERO( residue, 0.05 ) )  {
		rt_log("nmg_loop_is_ccw(x%x) npi=%g, n=%g, residue=%e, n_skip=%d\n",
			lu, npi, n, residue, n_skip );
	}

	/* "npi" value is normalized -1..+1, tolerance here is 1% */
	if( npi >= 2 - 0.05 )  {
		/* theta >= two pi, loop is CCW */
a579 9
		goto out;
	}
	if( npi <= -2 + 0.05 )  {
		/* theta <= -two pi, loop is CW */
		ret = -1;
		goto out;
	}
	rt_log("nmg_loop_is_ccw(x%x):  unable to determine CW/CCW, theta=%g, winding=%g*pi (%d angles, %d skip)\n",
		theta, npi, n_angles, n_skip );
a580 18
#if 0
	if( !(rt_g.debug & DEBUG_MATH) )  {
		int	save = rt_g.debug;
		/* Do it again, with details exhibited. */
		rt_g.debug |= DEBUG_MATH;
		(void)nmg_loop_is_ccw( lu, norm, tol );
		rt_g.debug = save;
	}
	nmg_pr_lu_briefly(lu, NULL);
	rt_log(" theta = %g, winding=%g*pi\n", theta, npi );
	
	rt_g.NMG_debug |= DEBUG_PLOTEM;
	nmg_face_lu_plot( lu, this_vu, this_vu );
	rt_bomb("nmg_loop_is_ccw()\n");
#else
	/* This can happen with zig-zag "crack" loops, as in Test4.r */
	ret = 0;
#endif
d582 4
a585 5
    	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		rt_log("nmg_loop_is_ccw(lu=x%x) ret=%d (%d angles, %d skip, winding=%g*pi)\n",
			lu, ret, n_angles, n_skip, npi);
    	}
	return ret;
@


11.1
log
@Release_4.4
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.69 95/01/04 08:00:59 mike Exp $ (ARL)";
a1376 1
	VUNITIZE( edgevect );
d1379 1
@


1.69
log
@Cray C90
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.68 94/11/04 12:17:37 jra Exp Locker: mike $ (ARL)";
@


1.68
log
@Modified calls to nmg_pr_eg to agree with new declaration.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.67 94/11/04 07:01:18 mike Exp Locker: jra $ (ARL)";
d549 1
a549 1
	fastf_t		npi;		/* n * pi, hopefully */
@


1.67
log
@Irix 6
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.66 94/09/16 23:36:55 mike Exp Locker: mike $ (ARL)";
d1170 2
a1171 2
				    			nmg_pr_eg( eur->g.lseg_p, 0 );
				    			nmg_pr_eg( ret->g.lseg_p, 0 );
@


1.66
log
@Added checks for edge_g_cnurb edge geometry showing up.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.65 94/09/16 20:52:53 mike Exp Locker: mike $ (ARL)";
d256 1
a276 1
		break;
a280 1
			break;
a283 1
			break;
d298 1
a727 1
			CONST struct loopuse		*newlu;
a769 1
	struct vertexuse	*vu2a, *vu2b;
d779 1
a779 1
	if( (vu2a = nmg_find_v_in_shell( vu1a->v_p, s2, 1 )) == (struct vertexuse *)NULL )
d781 1
a781 1
	if( (vu2b = nmg_find_v_in_shell( vu1b->v_p, s2, 1 )) == (struct vertexuse *)NULL )
@


1.65
log
@Eliminated edge_g crutch.
They are now explicitly edge_g_lseg.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.64 94/09/16 20:45:45 mike Exp Locker: mike $ (ARL)";
a2087 1
	register struct edge_g_lseg	*eg = (struct edge_g_lseg *)ep;
d2089 2
a2090 1
	NMG_CK_EDGE_G_LSEG(eg);
d2092 10
a2101 1
	if( !NMG_INDEX_FIRST_TIME(sp->visited, eg) )  return;
@


1.64
log
@nmg_move_eg() became nmg_jeg().
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.63 94/09/12 22:41:51 mike Exp Locker: mike $ (ARL)";
d2088 1
a2088 1
	register struct edge_g_lseg	*eg = (struct edge_g *)ep;
@


1.63
log
@Added note.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.62 94/09/10 23:02:21 jra Exp Locker: mike $ (ARL)";
d1184 1
a1184 1
								nmg_move_eg( eur->g.lseg_p, ret->g.lseg_p );
@


1.62
log
@Changed call to nmg_2edge_g_coincident to nmg_2edgeuse_coincident.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.61 94/09/10 04:36:48 mike Exp Locker: jra $ (ARL)";
d2235 2
@


1.61
log
@Converted NMG data structures to have edge_g pointer in edgeuse, not edge.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.60 94/09/03 03:01:20 mike Exp $ (ARL)";
d1178 1
a1178 1
							coincident = nmg_2edge_g_coincident( eur->e_p, ret->e_p, tol );
@


1.60
log
@Snapshot of non-working intermediate stage in edge_g evolution.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.59 94/09/02 01:14:45 mike Exp Locker: mike $ (ARL)";
d1169 1
a1169 1
				    		if( eur->e_p->eg_p != ret->e_p->eg_p )  {
d1171 4
a1174 4
				    				eur, eur->e_p->eg_p,
				    				ret, ret->e_p->eg_p );
				    			nmg_pr_eg( eur->e_p->eg_p, 0 );
				    			nmg_pr_eg( ret->e_p->eg_p, 0 );
d1182 3
a1184 3
									eur->e_p, eur->e_p->eg_p,
									ret->e_p, ret->e_p->eg_p );
								nmg_move_eg( eur->e_p->eg_p, ret->e_p->eg_p, nmg_find_s_of_eu(eur) );
d2209 1
a2209 1
	if( eu->e_p->eg_p != sp->eg )  return;
d2283 1
a2283 1
	NMG_CK_EDGE_G_LSEG(eu->e_p->eg_p);
d2287 1
a2287 1
	if( fabs( VDOT( eu->e_p->eg_p->e_dir, sp->dir ) ) < sp->tol->para )
d2291 1
a2291 1
	if( fabs( VDOT( eu->e_p->eg_p->e_dir, sp->dir ) ) < 0.9 * MAGNITUDE(eu->e_p->eg_p->e_dir) * MAGNITUDE(sp->dir) )
@


1.59
log
@More fallout from face_g changes.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.58 94/09/02 00:31:59 mike Exp Locker: mike $ (ARL)";
d1119 1
a1119 1
 *  to the same edge_g geometry structure.  The intersection of two planes
d1168 1
a1168 1
				    		/* Previous edge found, check edge_g */
d2078 1
a2078 1
 *  Having just visited an edge_g, if this is the first time,
d2088 1
a2088 1
	register struct edge_g	*eg = (struct edge_g *)ep;
d2090 1
a2090 1
	NMG_CK_EDGE_G(eg);
d2185 1
a2185 1
	CONST struct edge_g	*eg;
d2226 1
a2226 1
CONST struct edge_g	*eg;
d2234 1
a2234 1
	NMG_CK_EDGE_G(eg);
d2283 1
a2283 1
	NMG_CK_EDGE_G(eu->e_p->eg_p);
@


1.58
log
@Changed to new face geometry pointers (g.plane_p)
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.57 94/08/24 20:57:17 butler Exp Locker: mike $ (ARL)";
d329 1
a329 1
		register struct	face_g	*fg1;
@


1.57
log
@Moved declaration of nmg_visit_handlers_null to nmg_visit.c from nmg_info.c
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.56 94/08/09 19:37:46 mike Exp Locker: butler $ (ARL)";
d304 1
a304 1
 *  Find a faceuse in shell s1 that shares the face_g structure with
d317 1
a317 1
	register struct face_g	*fg2;
d324 2
a325 2
	fg2 = f2->fg_p;
	NMG_CK_FACE_G(fg2);
d335 2
a336 2
		fg1 = fu1->f_p->fg_p;
		NMG_CK_FACE_G(fg1);
d1373 1
a1373 1
	NMG_CK_FACE_G(fu->f_p->fg_p);
@


1.56
log
@Added GDurf's new "conf.h"
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.55 94/07/02 02:39:25 mike Exp Locker: mike $ (ARL)";
a37 1
CONST struct nmg_visit_handlers	nmg_visit_handlers_null;
@


1.55
log
@Changed to nmg_move_eg()
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.54 94/07/01 23:37:14 mike Exp Locker: mike $ (ARL)";
d29 1
@


1.54
log
@Added 'tol' arg to nmg_find_edge_between_2fu().
If unshared edge geometry is detected, fix it.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.53 94/06/29 23:25:07 mike Exp Locker: mike $ (ARL)";
d1184 3
a1186 2
									/* XXX Really need to move over all uses of that edge, not just this one. */
									nmg_use_edge_g( eur->e_p, ret->e_p->eg_p );
@


1.53
log
@Fixed infinte loop bug, oops.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.52 94/06/29 22:40:29 mike Exp Locker: mike $ (ARL)";
a36 3
/* XXX move to raytrace.h */
RT_EXTERN(CONST struct edgeuse *nmg_find_edge_between_2fu, (CONST struct faceuse *fu1, CONST struct faceuse *fu2));

d1129 1
a1129 1
nmg_find_edge_between_2fu(fu1, fu2)
d1132 1
d1136 1
d1140 1
d1173 16
a1188 1
				    			rt_bomb("nmg_find_edge_between_2fu() 2 faces intersect with differing edge geometries?\n");
@


1.52
log
@Added nmg_find_edge_between_2fu()
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.51 94/06/29 00:24:30 mike Exp Locker: mike $ (ARL)";
a1175 3
				} else {
					eur = eur->eumate_p->radial_p;
					NMG_CK_EDGEUSE(eur);
d1177 3
@


1.51
log
@Documented bad assumption about unit vectors in dot product test.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.50 94/06/29 00:05:01 mike Exp Locker: mike $ (ARL)";
d37 2
d1112 74
@


1.50
log
@Added nmg_edge_g_tabulate()
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.49 94/06/28 22:03:18 mike Exp Locker: mike $ (ARL)";
d2192 3
d2197 5
@


1.49
log
@Fixed comment error.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.48 94/06/24 00:04:34 butler Exp Locker: mike $ (ARL)";
d1977 54
@


1.48
log
@nmg_model_bb() fixes.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.47 94/05/04 16:22:28 jra Exp Locker: butler $ (ARL)";
d2157 1
a2157 1
 *  that has both edgeuses within tolerance of the given line.
@


1.47
log
@Added nmg_tabulate_edge
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/librt/RCS/nmg_info.c,v 1.46 94/04/24 22:43:18 mike Exp Locker: jra $ (ARL)";
d108 26
@


1.46
log
@Added nmg_edgeuse_on_line_tabulate()
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.45 94/04/20 20:13:04 mike Exp Locker: mike $ (ARL)";
d1897 54
@


1.45
log
@Moved in support routines from nmg_mesh.c
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.44 94/04/19 07:17:50 mike Exp Locker: mike $ (ARL)";
d2018 87
@


1.44
log
@Added nmg_edgeuse_with_eg_tabulate()
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.43 94/04/14 07:30:01 mike Exp Locker: mike $ (ARL)";
d326 34
d1178 88
@


1.43
log
@Added debug prints to nmg_loop_is_a_crack().
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.42 94/03/18 03:30:20 mike Exp Locker: mike $ (ARL)";
d1829 67
@


1.42
log
@Added a comment.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.41 94/03/11 23:07:11 mike Exp Locker: mike $ (ARL)";
d392 1
d395 5
a399 1
	if( *lu->up.magic_p != NMG_FACEUSE_MAGIC )  return 0;
d403 5
a407 1
	if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )  return 0;
d441 2
a442 1
		return 0;
d447 6
a452 1
	return 1;
@


1.41
log
@Fixed a variety of nits from this afternoon's code review.
Added nmg_find_eu_of_vu().
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.40 94/03/11 19:36:08 mike Exp Locker: mike $ (ARL)";
d1398 2
@


1.40
log
@Minor nits from this afternoon's code review.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.39 94/03/11 02:03:53 mike Exp Locker: mike $ (ARL)";
a355 21

/*				N M G _ L U _ O F _ V U 
 *
 *	Given a vertexuse, return the loopuse somewhere above
 * XXX Shouldn't all uses of this be replaced by nmg_find_lu_of_vu()?
 */
struct loopuse *
nmg_lu_of_vu(vu)
CONST struct vertexuse *vu;
{
	NMG_CK_VERTEXUSE(vu);
	
	if (*vu->up.magic_p == NMG_EDGEUSE_MAGIC &&
		*vu->up.eu_p->up.magic_p == NMG_LOOPUSE_MAGIC)
			return(vu->up.eu_p->up.lu_p);
	else if (*vu->up.magic_p != NMG_LOOPUSE_MAGIC)
		rt_bomb("NMG vertexuse has no loopuse ancestor\n");

	return(vu->up.lu_p);		
}

d359 15
d400 4
d443 6
d487 5
d658 4
d689 1
d708 1
a708 1
	if( (vu2a = nmg_find_v_in_shell( vu1a->v_p, s2, 0 )) == (struct vertexuse *)NULL )
d710 1
a710 1
	if( (vu2b = nmg_find_v_in_shell( vu1b->v_p, s2, 0 )) == (struct vertexuse *)NULL )
d715 1
a715 2
	eu2 = nmg_findeu( vu1a->v_p, vu1b->v_p, s2,
	    (CONST struct edgeuse *)NULL, 0 );
d755 1
d759 4
a762 4
		if (*eup->up.magic_p != NMG_LOOPUSE_MAGIC ||
		    *eup->up.lu_p->up.magic_p != NMG_FACEUSE_MAGIC )
			rt_bomb("nmg_findeu(): eup not part of a face\n");
		eup_orientation = eup->up.lu_p->up.fu_p->orientation;
d799 4
a802 28
		if( s )  {
			struct loopuse	*lu;
			if( *eu->up.magic_p == NMG_SHELL_MAGIC &&
			    eu->up.s_p != s )  {
			    	if (rt_g.NMG_debug & DEBUG_FINDEU)
			    		rt_log("\tIgnoring -- wire eu in wrong shell s=%x\n", eu->up.s_p);
				continue;
			}
			if( *eu->up.magic_p != NMG_LOOPUSE_MAGIC )
				rt_bomb("nmg_findeu() eu has bad up\n");
			lu = eu->up.lu_p;
			NMG_CK_LOOPUSE(lu);
			if( *lu->up.magic_p == NMG_SHELL_MAGIC )  {
				if( lu->up.s_p != s )  {
				    	if (rt_g.NMG_debug & DEBUG_FINDEU)
				    		rt_log("\tIgnoring -- eu of wire loop in wrong shell s=%x\n", lu->up.s_p);
					continue;
				}
			} else if( *lu->up.magic_p == NMG_FACEUSE_MAGIC )  {
				/* Edgeuse in loop in face, normal case */
				if( lu->up.fu_p->s_p != s )  {
				    	if (rt_g.NMG_debug & DEBUG_FINDEU)
				    		rt_log("\tIgnoring -- eu of lu+fu in wrong shell s=%x\n", lu->up.fu_p->s_p);
					continue;
				}
			} else {
				rt_bomb("nmg_findeu() lu->up is bad\n");
			}
d835 1
a835 1
 *  A parallel to nmg_findeu(), only restricted to a faceuse,
d856 1
d860 4
a863 4
		if (*eup->up.magic_p != NMG_LOOPUSE_MAGIC ||
		    *eup->up.lu_p->up.magic_p != NMG_FACEUSE_MAGIC )
			rt_bomb("nmg_find_eu_in_face(): eup not part of a face\n");
		eup_orientation = eup->up.lu_p->up.fu_p->orientation;
d900 4
a903 25
		if( fu )  {
			struct loopuse	*lu;
			if( *eu->up.magic_p == NMG_SHELL_MAGIC )  {
			    	if (rt_g.NMG_debug & DEBUG_FINDEU)
			    		rt_log("\tIgnoring -- wire eu not in faceuse\n");
				continue;
			}
			if( *eu->up.magic_p != NMG_LOOPUSE_MAGIC )
				rt_bomb("nmg_find_eu_in_face() eu has bad up\n");
			lu = eu->up.lu_p;
			NMG_CK_LOOPUSE(lu);
			if( *lu->up.magic_p == NMG_SHELL_MAGIC )  {
			    	if (rt_g.NMG_debug & DEBUG_FINDEU)
			    		rt_log("\tIgnoring -- eu of wire loop not in fu\n");
				continue;
			} else if( *lu->up.magic_p == NMG_FACEUSE_MAGIC )  {
				/* Edgeuse in loop in face, normal case */
				if( lu->up.fu_p != fu )  {
				    	if (rt_g.NMG_debug & DEBUG_FINDEU)
				    		rt_log("\tIgnoring -- eu of lu+fu in wrong faceuse (%x)\n", lu->up.fu_p);
					continue;
				}
			} else {
				rt_bomb("nmg_find_eu_in_face() lu->up is bad\n");
			}
d934 19
d955 1
a955 1
 *  Find an edgeuse starting at a given vertexuse within a loop(use).
@


1.39
log
@Fixed modf() residue of nearly +/- 1.
Made having a total of zero in nmg_loop_is_ccw() not be fatal,
as that can happen with "zig zag crack" loops, as in Test4.r
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.38 94/03/02 18:06:14 mike Exp Locker: mike $ (ARL)";
d195 2
a196 1
/*	N M G _ F I N D _ F U _ O F _ E U
d199 1
a199 1
 *	edgeuse.  If edgeuse has no super-parent faceuse, return NULL.
d283 1
d314 2
@


1.38
log
@Big bug in nmg_vertex_tabulate() and nmg_edgeuse_tabulate() and
nmg_face_tabulate(), which were tabulating for the entire model, rather
than using the "magic_p" argument they were called with.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.37 94/02/04 03:43:06 mike Exp Locker: mike $ (ARL)";
d35 1
d472 1
d486 5
a490 2
		if( this_vu->v_p == next_vu->v_p )  continue;
		if( next_vu->v_p == third_vu->v_p )  continue;
d494 4
a497 1
		if( MAGSQ(edge1) < tol->dist_sq )  continue;
d499 5
a503 1
		if( MAGSQ(edge2) < tol->dist_sq )  continue;
d512 12
a523 11
#if 0
		nmg_pr_eu_briefly(eu,NULL);
		VPRINT("vu1", this_vu->v_p->vg_p->coord);
		VPRINT("vu2", next_vu->v_p->vg_p->coord);
		VPRINT("edge1", edge1);
		VPRINT("edge2", edge2);
		VPRINT("left", left);
		rt_log(" e1=%g, e2=%g, n=%g, l=%g\n", MAGNITUDE(edge1),
			MAGNITUDE(edge2), MAGNITUDE(norm), MAGNITUDE(left));
		rt_log("atan2(%g,%g) = %g\n", y, x, rad);
#endif
d543 9
d553 2
a554 2
		rt_log("nmg_loop_is_ccw(x%x) npi=%g, n=%g, residue=%g\n",
			lu, npi, n, residue );
d568 11
a578 2
	rt_log("nmg_loop_is_ccw(x%x):  unable to determine CW/CCW, theta=%g, winding=%g*pi\n",
		theta, npi );
d585 4
d591 2
a592 2
		rt_log("nmg_loop_is_ccw(lu=x%x) ret=%d (%d angles, winding=%g*pi)\n",
			lu, ret, n_angles, npi);
@


1.37
log
@Improved debugging to nmg_loop_is_ccw()
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.36 94/01/25 09:44:38 mike Exp Locker: mike $ (ARL)";
d1676 1
a1676 1
	nmg_visit( &m->magic, &handlers, (genptr_t)&st );
d1730 1
a1730 1
	nmg_visit( &m->magic, &handlers, (genptr_t)&st );
d1784 1
a1784 1
	nmg_visit( &m->magic, &handlers, (genptr_t)&st );
@


1.36
log
@Added some new nmg_find_ routines, formerly from nmg_inter.c
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.35 94/01/25 09:19:37 mike Exp Locker: mike $ (ARL)";
d471 1
d520 2
a521 3
	    	if (rt_g.NMG_debug)
			rt_log("nmg_loop_is_ccw():  only %d angles, can't tell\n", n_angles);
		return 0;
d538 2
a539 1
		return 1;
d543 2
a544 1
		return -1;
d554 6
a559 1
	return 0;
@


1.35
log
@Made lots of subroutine args CONST.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.34 94/01/25 08:46:06 mike Exp Locker: mike $ (ARL)";
d626 35
d1140 43
@


1.34
log
@Broke out nmg_find_pt_in_lu().
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.33 94/01/23 05:14:23 mike Exp Locker: mike $ (ARL)";
a35 4
/* XXX Move to raytrace.h */
RT_EXTERN( struct edge *nmg_find_e_nearest_pt2, (long *magic_p,
			CONST point_t pt2, CONST mat_t mat,
			CONST struct rt_tol *tol) );
a36 1

a108 32
/*
 *			N M G _ F I N D _ P T _ I N _ M O D E L
 *
 *  Brute force search of the entire model to find a vertex that
 *  matches this point.
 */
struct vertex *
nmg_find_pt_in_model( m, pt, tol )
CONST struct model	*m;
CONST point_t		pt;
CONST struct rt_tol	*tol;
{
	struct nmgregion	*r;
	struct shell		*s;
	struct vertex		*v;

	NMG_CK_MODEL(m);
	RT_CK_TOL(tol);

	for( RT_LIST_FOR( r, nmgregion, &m->r_hd ) )  {
		NMG_CK_REGION(r);
		for( RT_LIST_FOR( s, shell, &r->s_hd ) )  {
			NMG_CK_SHELL(s);
			if( (v = nmg_find_pt_in_shell( s, pt, tol )) )  {
				NMG_CK_VERTEX(v);
				return v;
			}
		}
	}
	return (struct vertex *)NULL;
}

d147 1
a147 1
struct loopuse *lu;
d163 1
a163 1
struct edgeuse *eu;
d179 1
a179 1
struct vertexuse *vu;
d201 1
a201 1
struct edgeuse *eu;
d212 18
a229 8
#define FACE_OF_LOOP(lu) { switch (*lu->up.magic_p) { \
	case NMG_FACEUSE_MAGIC:	return lu->up.fu_p; break; \
	case NMG_SHELL_MAGIC: return (struct faceuse *)NULL; break; \
	default: \
	    rt_log("Error at %s %d:\nInvalid loopuse parent magic (0x%x %d)\n", \
		__FILE__, __LINE__, *lu->up.magic_p, *lu->up.magic_p); \
	    rt_bomb("giving up on loopuse"); \
	} }
d239 1
a239 1
struct vertexuse *vu;
d245 1
a245 2
		FACE_OF_LOOP( vu->up.lu_p );
		break;
d253 1
a253 1
			FACE_OF_LOOP( vu->up.eu_p->up.lu_p );
d332 1
a332 1
struct vertexuse *vu;
d355 1
d359 1
a359 1
struct vertexuse *vu;
a643 1
/* XXX should be CONST return */
d941 1
a941 1
struct edgeuse *
d943 1
a943 1
struct edgeuse *eu;
d945 2
a946 2
	struct edgeuse *eur;
	struct faceuse *fu;
d949 1
a949 2
	NMG_CK_LOOPUSE(eu->up.lu_p);
	NMG_CK_FACEUSE(eu->up.lu_p->up.fu_p);
a950 1
	fu = eu->up.lu_p->up.fu_p;
d957 1
a957 1
		    eur->up.lu_p->up.fu_p->s_p == fu->s_p)
d959 1
a959 1
		else {
a1085 4
#define CKLU_FOR_FU(_lu, _fu, _vu) \
	if (*_lu->up.magic_p == NMG_FACEUSE_MAGIC && _lu->up.fu_p == _fu) \
		return(_vu)

d1094 2
a1095 1
				CKLU_FOR_FU(lu, fu, vu);
d1097 1
d1100 2
a1101 1
			CKLU_FOR_FU(lu, fu, vu);
d1192 121
a1536 89
/*
 *			N M G _ F I N D _ P T _ I N _ S H E L L
 *
 *  Given a point in 3-space and a shell pointer, try to find a vertex
 *  anywhere in the shell which is within sqrt(tol_sq) distance of
 *  the given point.
 *
 *  The algorithm is a brute force, and should be used sparingly.
 *  Mike Gigante's NUgrid technique would work well here, if
 *  searching was going to be needed for more than a few points.
 *
 *  Returns -
 *	pointer to vertex with matching geometry
 *	NULL
 *
 *  XXX Why does this return a vertex, while it's helpers return a vertexuse?
 */
struct vertex *
nmg_find_pt_in_shell( s, pt, tol )
CONST struct shell	*s;
CONST point_t		pt;
CONST struct rt_tol	*tol;
{
	CONST struct faceuse	*fu;
	CONST struct loopuse	*lu;
	CONST struct edgeuse	*eu;
	CONST struct vertexuse	*vu;
	struct vertex		*v;
	CONST struct vertex_g	*vg;
	vect_t		delta;

	NMG_CK_SHELL(s);
	RT_CK_TOL(tol);

	fu = RT_LIST_FIRST(faceuse, &s->fu_hd);
	while (RT_LIST_NOT_HEAD(fu, &s->fu_hd) ) {
		/* Shell has faces */
		NMG_CK_FACEUSE(fu);
		if( (vu = nmg_find_pt_in_face( fu, pt, tol )) )
			return(vu->v_p);

		if (RT_LIST_PNEXT(faceuse, fu) == fu->fumate_p)
			fu = RT_LIST_PNEXT_PNEXT(faceuse, fu);
		else
			fu = RT_LIST_PNEXT(faceuse, fu);
	}

	/* Wire loopuses */
	lu = RT_LIST_FIRST(loopuse, &s->lu_hd);
	while (RT_LIST_NOT_HEAD(lu, &s->lu_hd) ) {
		NMG_CK_LOOPUSE(lu);
		if( (vu = nmg_find_pt_in_lu(lu, pt, tol)) )
			return vu->v_p;

		if (RT_LIST_PNEXT(loopuse, lu) == lu->lumate_p)
			lu = RT_LIST_PNEXT_PNEXT(loopuse, lu);
		else
			lu = RT_LIST_PNEXT(loopuse, lu);
	}

	/* Wire edgeuses */
	for (RT_LIST_FOR(eu, edgeuse, &s->eu_hd)) {
		NMG_CK_EDGEUSE(eu);
		NMG_CK_VERTEXUSE(eu->vu_p);
		v = eu->vu_p->v_p;
		NMG_CK_VERTEX(v);
		if( (vg = v->vg_p) )  {
			NMG_CK_VERTEX_G(vg);
			VSUB2( delta, vg->coord, pt );
			if( MAGSQ(delta) <= tol->dist_sq )
				return(v);
		}
	}

	/* Lone vertexuse */
	if (s->vu_p) {
		NMG_CK_VERTEXUSE(s->vu_p);
		v = s->vu_p->v_p;
		NMG_CK_VERTEX(v);
		if( (vg = v->vg_p) )  {
			NMG_CK_VERTEX_G( vg );
			VSUB2( delta, vg->coord, pt );
			if( MAGSQ(delta) <= tol->dist_sq )
				return(v);
		}
	}
	return( (struct vertex *)0 );
}

a1591 57

	rt_free( (char *)st.visited, "visited[]");
}

/*
 *			N M G _ 2 R E F _ H A N D L E R
 *
 *  A private support routine for nmg_region_edge_list().
 *  Having just visited an edge, if this is the first time,
 *  add it to the nmg_ptbl array.
 */
static void
nmg_2ref_handler( ep, state, first )
long		*ep;
genptr_t	state;
int		first;
{
	register struct vf_state *sp = (struct vf_state *)state;
	register struct edge	*e = (struct edge *)ep;

	NMG_CK_EDGE(e);
	/* If this edge has been processed before, do nothing more */
	if( !NMG_INDEX_FIRST_TIME(sp->visited, e) )  return;

	nmg_tbl( sp->tabl, TBL_INS, ep );
}

/*
 *                      N M G _ R E G I O N _ E D G E _ L I S T
 *
 *  Given an nmgregion, build an nmg_ptbl list which has each edge
 *  pointer in the region listed exactly once.
 * XXX How about changing to take magic_p, make name nmg_edge_tabulate() ?
 */

void
nmg_region_edge_list( tab , r )
struct nmg_ptbl	*tab;
struct nmgregion *r;
{
	struct model    *m;
	struct vf_state st;
	struct nmg_visit_handlers       handlers;

	NMG_CK_REGION(r);
	m = r->m_p;
	NMG_CK_MODEL(m);


	st.visited = (char *)rt_calloc(m->maxindex+1, sizeof(char), "visited[]");
	st.tabl = tab;

	(void)nmg_tbl( tab, TBL_INIT, 0 );

	handlers = nmg_visit_handlers_null;             /* struct copy */
	handlers.vis_edge = nmg_2ref_handler;
	nmg_visit( &r->l.magic, &handlers, (genptr_t)&st );
@


1.33
log
@Fixed bug regarding nmg_findeu() and wire edges.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.32 94/01/23 04:18:39 mike Exp Locker: mike $ (ARL)";
d1139 54
d1209 1
a1209 5
	struct edgeuse		*eu;
	vect_t			delta;
	struct vertex		*v;
	register struct vertex_g *vg;
	int			magic1;
d1216 2
a1217 24
		magic1 = RT_LIST_FIRST_MAGIC( &lu->down_hd );
		if (magic1 == NMG_VERTEXUSE_MAGIC) {
			struct vertexuse	*vu;
			vu = RT_LIST_FIRST(vertexuse, &lu->down_hd);
			v = vu->v_p;
			NMG_CK_VERTEX(v);
			if( !(vg = v->vg_p) )  continue;
			NMG_CK_VERTEX_G(vg);
			VSUB2(delta, vg->coord, pt);
			if ( MAGSQ(delta) < tol->dist_sq)
				return(vu);
		} else if (magic1 == NMG_EDGEUSE_MAGIC) {
			for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
				v = eu->vu_p->v_p;
				NMG_CK_VERTEX(v);
				if( !(vg = v->vg_p) )  continue;
				NMG_CK_VERTEX_G(vg);
				VSUB2(delta, vg->coord, pt);
				if ( MAGSQ(delta) < tol->dist_sq)
					return(eu->vu_p);
			}
		} else {
			rt_bomb("nmg_find_vu_in_face() Bogus child of loop\n");
		}
d1461 2
d1485 2
a1486 2
			if( (vu = nmg_find_pt_in_face( fu, pt, tol )) )
				return(vu->v_p);
d1488 4
a1491 4
			if (RT_LIST_PNEXT(faceuse, fu) == fu->fumate_p)
				fu = RT_LIST_PNEXT_PNEXT(faceuse, fu);
			else
				fu = RT_LIST_PNEXT(faceuse, fu);
d1494 1
a1494 32
	for (RT_LIST_FOR(lu, loopuse, &s->lu_hd)) {
		NMG_CK_LOOPUSE(lu);
		if (RT_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC) {
			vu = RT_LIST_FIRST(vertexuse, &lu->down_hd);
			NMG_CK_VERTEX(vu->v_p);
			if (vg = vu->v_p->vg_p) {
				NMG_CK_VERTEX_G(vg);
				VSUB2( delta, vg->coord, pt );
				if( MAGSQ(delta) < tol->dist_sq )
					return(vu->v_p);
			}
		} else if (RT_LIST_FIRST_MAGIC(&lu->down_hd) != NMG_EDGEUSE_MAGIC) {
			rt_log("in %s at %d ", __FILE__, __LINE__);
			rt_bomb("loopuse has bad child\n");
		} else {
			/* loopuse made of edgeuses */
			for (RT_LIST_FOR(eu, edgeuse, &lu->down_hd)) {
				
				NMG_CK_EDGEUSE(eu);
				NMG_CK_VERTEXUSE(eu->vu_p);
				v = eu->vu_p->v_p;
				NMG_CK_VERTEX(v);
				if( (vg = v->vg_p) )  {
					NMG_CK_VERTEX_G(vg);
					VSUB2( delta, vg->coord, pt );
					if( MAGSQ(delta) < tol->dist_sq )
						return(v);
				}
			}
		}
	}

d1497 3
d1501 4
a1504 8
			NMG_CK_LOOPUSE(lu);
			/* XXX what to do here? */
			rt_log("nmg_find_vu_in_face(): lu?\n");

			if (RT_LIST_PNEXT(loopuse, lu) == lu->lumate_p)
				lu = RT_LIST_PNEXT_PNEXT(loopuse, lu);
			else
				lu = RT_LIST_PNEXT(loopuse, lu);
d1507 1
d1516 1
a1516 1
			if( MAGSQ(delta) < tol->dist_sq )
d1521 1
a1521 1

d1529 1
a1529 1
			if( MAGSQ(delta) < tol->dist_sq )
@


1.32
log
@Fixed message
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.31 94/01/22 05:14:15 mike Exp Locker: mike $ (ARL)";
d744 14
a757 7
			if( *lu->up.magic_p == NMG_SHELL_MAGIC &&
			    lu->up.s_p != s )  {
			    	if (rt_g.NMG_debug & DEBUG_FINDEU)
			    		rt_log("\tIgnoring -- eu of wire loop in wrong shell s=%x\n", lu->up.s_p);
				continue;
			}
			if( *lu->up.magic_p != NMG_FACEUSE_MAGIC )
a758 5
			/* Edgeuse in loop in face, normal case */
			if( lu->up.fu_p->s_p != s )  {
			    	if (rt_g.NMG_debug & DEBUG_FINDEU)
		    		rt_log("\tIgnoring -- eu of lu+fu in wrong shell s=%x\n", lu->up.fu_p->s_p);
				continue;
d871 8
a878 2
			}
			if( *lu->up.magic_p != NMG_FACEUSE_MAGIC )
a879 5
			/* Edgeuse in loop in face, normal case */
			if( lu->up.fu_p != fu )  {
			    	if (rt_g.NMG_debug & DEBUG_FINDEU)
		    		rt_log("\tIgnoring -- eu of lu+fu in wrong faceuse (%x)\n", lu->up.fu_p);
				continue;
@


1.31
log
@Added nmg_find_eu_in_face()
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.30 94/01/13 18:58:09 mike Exp Locker: mike $ (ARL)";
d816 1
a816 1
			rt_bomb("nmg_findeu(): eup not part of a face\n");
@


1.30
log
@Used MAT4X3VEC instead of MAT4X3PNT.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.29 94/01/12 02:50:33 mike Exp Locker: mike $ (ARL)";
d783 120
@


1.29
log
@Added nmg_find_e_nearest_pt2().
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.28 93/12/23 23:12:53 mike Exp Locker: mike $ (ARL)";
d911 2
a912 2
	MAT4X3VEC( a2, sp->mat, va->vg_p->coord );
	MAT4X3VEC( b2, sp->mat, vb->vg_p->coord );
@


1.28
log
@Fixed nmg_loop_is_ccw() to properly process loops with jaunts.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.27 93/12/23 05:42:11 mike Exp Locker: mike $ (ARL)";
d36 6
d872 94
@


1.27
log
@Improved debugging on nmg_loop_is_ccw().
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.26 93/12/22 06:14:48 mike Exp Locker: mike $ (ARL)";
d461 7
a472 1
 * XXX Should the return really be a boolean?
d488 3
d545 14
a558 5
	rad = theta * rt_inv2pi;	/* "winding number" */
	x = rad-1;
	/* "rad" value is normalized -1..+1, tolerance here is 1% */
	if( NEAR_ZERO( x, 0.05 ) )  {
		/* theta = two pi, loop is CCW */
d561 2
a562 3
	x = rad + 1;
	if( NEAR_ZERO( x, 0.05 ) )  {
		/* theta = -two pi, loop is CW */
d565 2
a566 2
	rt_log("nmg_loop_is_ccw(x%x):  unable to determine CW/CCW, theta=%g, winding=%g\n",
		theta, rad );
d568 1
a568 1
	rt_log(" theta = %g, winding=%g\n", theta, theta / rt_twopi );
@


1.26
log
@Made message conditional on debugging being on.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.25 93/12/16 05:33:57 mike Exp Locker: mike $ (ARL)";
a527 1
	nmg_face_lu_plot( lu->lumate_p, this_vu, this_vu );
d536 1
a536 1
	rad = theta * rt_inv2pi;
d548 1
a548 1
	rt_log("nmg_loop_is_ccw(x%x):  unable to determine CW/CCW, theta=%g (%g)\n",
d551 3
a553 1
	rt_log(" theta = %g (%g)\n", theta, theta / rt_twopi );
a554 1
	nmg_face_lu_plot( lu->lumate_p, this_vu, this_vu );
@


1.25
log
@Added nmg_find_fu_with_fg_in_s(),
nmg_face_tabulate().
;.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.24 93/12/14 18:47:16 mike Exp Locker: mike $ (ARL)";
d532 2
a533 1
		rt_log("nmg_loop_is_ccw():  only %d angles, can't tell\n", n_angles);
@


1.24
log
@Combined nmg_model_vertex_list() and nmg_region_vertex_list() into one
routine:  nmg_vertex_tabluate().
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.23 93/11/12 23:41:37 mike Exp Locker: mike $ (ARL)";
d296 16
d313 30
d1383 1
d1408 108
@


1.23
log
@nmg_visit_handlers_null is now globally defined, in nmg_info.c
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.22 93/11/12 23:13:31 mike Exp Locker: mike $ (ARL)";
d1258 1
a1258 1
 *  A private support routine for nmg_region_vertex_list().
d1279 1
a1279 1
 *			N M G _ R E G I O N _ V E R T E X _ L I S T
d1281 3
a1283 2
 *  Given an nmgregion, build an nmg_ptbl list which has each vertex
 *  pointer in the region listed exactly once.
d1286 1
a1286 1
nmg_region_vertex_list( tab, r )
d1288 1
a1288 1
struct nmgregion	*r;
d1290 2
a1291 2
	struct model	*m;
	struct vf_state	st;
d1294 1
a1294 30
	NMG_CK_REGION(r);
	m = r->m_p;
	NMG_CK_MODEL(m);

	st.visited = (char *)rt_calloc(m->maxindex+1, sizeof(char), "visited[]");
	st.tabl = tab;

	(void)nmg_tbl( tab, TBL_INIT, 0 );

	handlers = nmg_visit_handlers_null;		/* struct copy */
	handlers.vis_vertex = nmg_2rvf_handler;
	nmg_visit( &r->l.magic, &handlers, (genptr_t)&st );

	rt_free( (char *)st.visited, "visited[]");
}

/*
 *			N M G _ M O D E L _ V E R T E X _ L I S T
 *
 *  Given an nmgmodel, build an nmg_ptbl list which has each vertex
 *  pointer in the model listed exactly once.
 */
void
nmg_model_vertex_list( tab, m )
struct nmg_ptbl		*tab;
struct model		*m;
{
	struct vf_state	st;
	struct nmg_visit_handlers	handlers;

@


1.22
log
@Added nmg_model_vertex_list().
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.21 93/10/24 09:06:33 mike Exp Locker: mike $ (ARL)";
d36 1
a36 1
static CONST struct nmg_visit_handlers	nmg_visit_handlers_null;
@


1.21
log
@Added nmg_find_pt_in_model()
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.20 93/10/22 22:28:15 mike Exp Locker: mike $ (ARL)";
d1310 28
a1358 1
/* End of borrow */
@


1.20
log
@nmg_eups() and nmg_lups() eliminated, in favor of
nmg_find_s_of_lu() and nmg_find_s_of_eu().

@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.19 93/09/30 20:56:00 mike Exp Locker: mike $ (ARL)";
d36 2
d108 32
a1249 1
static CONST struct nmg_visit_handlers	nmg_visit_handlers_null;
@


1.19
log
@Added nmg_loop_touches_self
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
d137 1
a137 1
/*				N M G _ L U P S
d140 1
d143 1
a143 1
nmg_lups(lu)
d148 1
a148 1
		rt_bomb("bad parent for loopuse\n");
d153 1
a153 1
/*				N M G _ E U P S 
d156 1
d159 1
a159 1
nmg_eups(eu)
d164 1
a164 1
		rt_bomb("bad parent for edgeuse\n");
d166 1
a166 1
	return(nmg_lups(eu->up.lu_p));
d169 16
d828 2
a829 1
nmg_find_pt_in_face(pt, fu, tol)
a830 1
CONST struct faceuse	*fu;
d1134 1
a1134 1
			if( (vu = nmg_find_pt_in_face( pt, fu, tol )) )
@


1.18
log
@Moved nmg_find_fu_of_vu() and nmg_find_lu_of_vu() from nmg_misc.c to
nmg_info.c
@
text
@d14 1
a14 1
 *	Aberdeen Proving Ground, Maryland  21005-5066
d16 5
d22 2
a23 2
 *	This software is Copyright (C) 1993 by the United States Army.
 *	All rights reserved.
d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.17 93/07/20 22:46:52 mike Exp Locker: mike $ (BRL)";
d458 64
@


1.17
log
@nmg_findeu() probably should return CONST
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.16 93/07/20 21:27:10 mike Exp Locker: mike $ (BRL)";
d168 72
d245 25
@


1.16
log
@ANSI lint
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.15 93/07/20 21:16:30 mike Exp Locker: mike $ (BRL)";
d383 1
d496 1
a496 1
	return eu;
@


1.15
log
@ANSI lint
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.14 93/06/02 10:38:11 jra Exp Locker: mike $ (BRL)";
d50 1
a50 1
	register long	*magic_p = magic_p_arg;
@


1.14
log
@Added nmg_region_edge_list routine (patterned after vertex routine)
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.13 93/05/12 17:42:36 cjohnson Exp Locker: jra $ (BRL)";
d385 3
a387 3
struct vertex	*v1, *v2;
struct shell	*s;
struct edgeuse	*eup;
d390 3
a392 3
	register struct vertexuse	*vu;
	register struct edgeuse		*eu;
	struct edgeuse			*eup_mate;
@


1.13
log
@Inserted missing CONST to make gcc happy.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.12 1993/04/08 03:18:09 mike Exp cjohnson $ (BRL)";
d1086 57
@


1.12
log
@nmg_loop_is_ccw() can't determine answer if there are only 2 edges.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.11 93/04/03 04:39:49 mike Exp Locker: mike $ (BRL)";
d48 1
a48 1
long	*magic_p_arg;
@


1.11
log
@Organized according to the great chain of being.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.10 93/04/03 01:59:12 mike Exp Locker: mike $ (BRL)";
d265 2
d282 1
d323 1
d326 1
a326 1
	rt_log(" theta = %g (%g)\n", theta, theta / rt_twopi );
d330 5
@


1.10
log
@nmg_find_vu_in_face() has changed name to nmg_find_pt_in_face()
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.9 93/04/02 23:25:35 mike Exp Locker: mike $ (BRL)";
d31 6
d101 6
d108 248
d490 93
a904 181
 *			N M G _ F I N D _ E U _ W I T H _ V U _ I N _ L U
 *
 *  Find an edgeuse starting at a given vertexuse within a loop(use).
 */
struct edgeuse *
nmg_find_eu_with_vu_in_lu( lu, vu )
CONST struct loopuse		*lu;
CONST struct vertexuse	*vu;
{
	register struct edgeuse	*eu;

	NMG_CK_LOOPUSE(lu);
	NMG_CK_VERTEXUSE(vu);
	if( RT_LIST_FIRST_MAGIC(&lu->down_hd) != NMG_EDGEUSE_MAGIC )
		rt_bomb("nmg_find_eu_with_vu_in_lu: loop has no edges!\n");
	for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
		NMG_CK_EDGEUSE(eu);
		if( eu->vu_p == vu )  return eu;
	}
	rt_bomb("nmg_find_eu_with_vu_in_lu:  Unable to find vu!\n");
	/* NOTREACHED */
	return((struct edgeuse *)NULL);
}

/*
 *			N M G _ L O O P _ I S _ A _ C R A C K
 *
 *  Returns -
 *	 0	Loop is not a "crack"
 *	!0	Loop *is* a "crack"
 */
int
nmg_loop_is_a_crack( lu )
CONST struct loopuse	*lu;
{
	struct edgeuse	*cur_eu;
	struct edgeuse	*cur_eumate;
	struct vertexuse *cur_vu;
	struct vertex	*cur_v;
	struct vertexuse *next_vu;
	struct vertex	*next_v;
	struct faceuse	*fu;
	struct vertexuse *test_vu;
	struct edgeuse	*test_eu;
	struct loopuse	*test_lu;

	NMG_CK_LOOPUSE(lu);
	if( *lu->up.magic_p != NMG_FACEUSE_MAGIC )  return 0;
	fu = lu->up.fu_p;
	NMG_CK_FACEUSE(fu);

	if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )  return 0;

	for( RT_LIST_FOR( cur_eu, edgeuse, &lu->down_hd ) )  {
		NMG_CK_EDGEUSE(cur_eu);
		cur_eumate = cur_eu->eumate_p;
		NMG_CK_EDGEUSE(cur_eumate);
		cur_vu = cur_eu->vu_p;
		NMG_CK_VERTEXUSE(cur_vu);
		cur_v = cur_vu->v_p;
		NMG_CK_VERTEX(cur_v);

		next_vu = cur_eumate->vu_p;
		NMG_CK_VERTEXUSE(next_vu);
		next_v = next_vu->v_p;
		NMG_CK_VERTEX(next_v);
		/* XXX It might be more efficient to walk the radial list */
		/* See if the next vertex has an edge pointing back to cur_v */
		for( RT_LIST_FOR( test_vu, vertexuse, &next_v->vu_hd ) )  {
			if( *test_vu->up.magic_p != NMG_EDGEUSE_MAGIC )  continue;
			test_eu = test_vu->up.eu_p;
			NMG_CK_EDGEUSE(test_eu);
			if( test_eu == cur_eu )  continue;	/* skip self */
			if( test_eu == cur_eumate )  continue;	/* skip mates */
			if( *test_eu->up.magic_p != NMG_LOOPUSE_MAGIC )  continue;
			test_lu = test_eu->up.lu_p;
			if( test_lu != lu )  continue;
			/* Check departing edgeuse's NEXT vertex */
			if( test_eu->eumate_p->vu_p->v_p == cur_v )  goto match;
		}
		/* No path back, this can't be a crack, abort */
		return 0;
		
		/* One edgeuse matched, all the others have to as well */
match:		;
	}
	return 1;
}

/*
 *			N M G _ L O O P _ I S _ C C W
 *
 *  Returns -
 *	+1	Loop is CCW, should be exterior loop.
 *	-1	Loop is CW, should be interior loop.
 *	 0	Unable to tell, error.
 */
int
nmg_loop_is_ccw( lu, norm, tol )
CONST struct loopuse	*lu;
CONST plane_t		norm;
CONST struct rt_tol	*tol;
{
	vect_t		edge1, edge2;
	vect_t		left;
	struct edgeuse	*eu;
	struct edgeuse	*next_eu;
	struct vertexuse *this_vu, *next_vu, *third_vu;
	fastf_t		theta = 0;
	fastf_t		x,y;
	fastf_t		rad;

	NMG_CK_LOOPUSE(lu);
	RT_CK_TOL(tol);
	if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )  return 0;

	for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
		next_eu = RT_LIST_PNEXT_CIRC( edgeuse, eu );
		this_vu = eu->vu_p;
		next_vu = eu->eumate_p->vu_p;
		third_vu = next_eu->eumate_p->vu_p;

		/* Skip topological 0-length edges */
		if( this_vu->v_p == next_vu->v_p )  continue;
		if( next_vu->v_p == third_vu->v_p )  continue;

		/* Skip edges with calculated edge lengths near 0 */
		VSUB2( edge1, next_vu->v_p->vg_p->coord, this_vu->v_p->vg_p->coord );
		if( MAGSQ(edge1) < tol->dist_sq )  continue;
		VSUB2( edge2, third_vu->v_p->vg_p->coord, next_vu->v_p->vg_p->coord );
		if( MAGSQ(edge2) < tol->dist_sq )  continue;
		VUNITIZE(edge1);
		VUNITIZE(edge2);

		/* Compute (loop)inward pointing "left" vector */
		VCROSS( left, norm, edge1 );
		y = VDOT( edge2, left );
		x = VDOT( edge2, edge1 );
		rad = atan2( y, x );
#if 0
		nmg_pr_eu_briefly(eu,NULL);
		VPRINT("vu1", this_vu->v_p->vg_p->coord);
		VPRINT("vu2", next_vu->v_p->vg_p->coord);
		VPRINT("edge1", edge1);
		VPRINT("edge2", edge2);
		VPRINT("left", left);
		rt_log(" e1=%g, e2=%g, n=%g, l=%g\n", MAGNITUDE(edge1),
			MAGNITUDE(edge2), MAGNITUDE(norm), MAGNITUDE(left));
		rt_log("atan2(%g,%g) = %g\n", y, x, rad);
#endif
		theta += rad;
	}
#if 0
	rt_log(" theta = %g (%g)\n", theta, theta / rt_twopi );
	nmg_face_lu_plot( lu, this_vu, this_vu );
	nmg_face_lu_plot( lu->lumate_p, this_vu, this_vu );
#endif

	rad = theta * rt_inv2pi;
	x = rad-1;
	/* "rad" value is normalized -1..+1, tolerance here is 1% */
	if( NEAR_ZERO( x, 0.05 ) )  {
		/* theta = two pi, loop is CCW */
		return 1;
	}
	x = rad + 1;
	if( NEAR_ZERO( x, 0.05 ) )  {
		/* theta = -two pi, loop is CW */
		return -1;
	}
	rt_log("nmg_loop_is_ccw(x%x):  unable to determine CW/CCW, theta=%g (%g)\n",
		theta, rad );
	nmg_pr_lu_briefly(lu, NULL);
	rt_log(" theta = %g (%g)\n", theta, theta / rt_twopi );
	nmg_face_lu_plot( lu, this_vu, this_vu );
	nmg_face_lu_plot( lu->lumate_p, this_vu, this_vu );
	rt_bomb("nmg_loop_is_ccw()\n");
	return 0;
}

/*
a1019 136
}

/*
 *			N M G _ S H E L L _ I S _ E M P T Y
 *
 *  See if this is an invalid shell
 *  i.e., one that has absolutely nothing in it,
 *  not even a lone vertexuse.
 *
 *  Returns -
 *	1	yes, it is completely empty
 *	0	no, not empty
 */
int
nmg_shell_is_empty(s)
register CONST struct shell *s;
{

	NMG_CK_SHELL(s);

	if( RT_LIST_NON_EMPTY( &s->fu_hd ) )  return 0;
	if( RT_LIST_NON_EMPTY( &s->lu_hd ) )  return 0;
	if( RT_LIST_NON_EMPTY( &s->eu_hd ) )  return 0;
	if( s->vu_p )  return 0;
	return 1;
}

/*				N M G _ L U _ O F _ V U 
 *
 *	Given a vertexuse, return the loopuse somewhere above
 */
struct loopuse *
nmg_lu_of_vu(vu)
struct vertexuse *vu;
{
	NMG_CK_VERTEXUSE(vu);
	
	if (*vu->up.magic_p == NMG_EDGEUSE_MAGIC &&
		*vu->up.eu_p->up.magic_p == NMG_LOOPUSE_MAGIC)
			return(vu->up.eu_p->up.lu_p);
	else if (*vu->up.magic_p != NMG_LOOPUSE_MAGIC)
		rt_bomb("NMG vertexuse has no loopuse ancestor\n");

	return(vu->up.lu_p);		
}

/*				N M G _ L U P S
 *
 *	return parent shell for loopuse
 */
struct shell *
nmg_lups(lu)
struct loopuse *lu;
{
	if (*lu->up.magic_p == NMG_SHELL_MAGIC) return(lu->up.s_p);
	else if (*lu->up.magic_p != NMG_FACEUSE_MAGIC) 
		rt_bomb("bad parent for loopuse\n");

	return(lu->up.fu_p->s_p);
}

/*				N M G _ E U P S 
 *
 *	return parent shell of edgeuse
 */
struct shell *
nmg_eups(eu)
struct edgeuse *eu;
{
	if (*eu->up.magic_p == NMG_SHELL_MAGIC) return(eu->up.s_p);
	else if (*eu->up.magic_p != NMG_LOOPUSE_MAGIC)
		rt_bomb("bad parent for edgeuse\n");

	return(nmg_lups(eu->up.lu_p));
}

/*				N M G _ F A C E R A D I A L
 *
 *	Looking radially around an edge, find another edge in the same
 *	face as the current edge. (this could be the mate to the current edge)
 */
CONST struct edgeuse *
nmg_faceradial(eu)
CONST struct edgeuse *eu;
{
	CONST struct faceuse *fu;
	CONST struct edgeuse *eur;

	NMG_CK_EDGEUSE(eu);
	NMG_CK_LOOPUSE(eu->up.lu_p);
	fu = eu->up.lu_p->up.fu_p;
	NMG_CK_FACEUSE(fu);

	eur = eu->radial_p;

	while (*eur->up.magic_p != NMG_LOOPUSE_MAGIC ||
	    *eur->up.lu_p->up.magic_p != NMG_FACEUSE_MAGIC ||
	    eur->up.lu_p->up.fu_p->f_p != fu->f_p)
	    	eur = eur->eumate_p->radial_p;

	return(eur);
}


/*
 *			N M G _ R A D I A L _ F A C E _ E D G E _ I N _ S H E L L
 *
 *	looking radially around an edge, find another edge which is a part
 *	of a face in the same shell
 */
struct edgeuse *
nmg_radial_face_edge_in_shell(eu)
struct edgeuse *eu;
{
	struct edgeuse *eur;
	struct faceuse *fu;

	NMG_CK_EDGEUSE(eu);
	NMG_CK_LOOPUSE(eu->up.lu_p);
	NMG_CK_FACEUSE(eu->up.lu_p->up.fu_p);

	fu = eu->up.lu_p->up.fu_p;
	eur = eu->radial_p;
	NMG_CK_EDGEUSE(eur);

	while (eur != eu->eumate_p) {
		if (*eur->up.magic_p == NMG_LOOPUSE_MAGIC &&
		    *eur->up.lu_p->up.magic_p == NMG_FACEUSE_MAGIC &&
		    eur->up.lu_p->up.fu_p->s_p == fu->s_p)
			break; /* found another face in shell */
		else {
			eur = eur->eumate_p->radial_p;
			NMG_CK_EDGEUSE(eur);
		}
	}
	return(eur);
@


1.9
log
@Added nmg_is_vertex_a_selfloop_in_shell()
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.8 93/04/02 03:00:22 mike Exp Locker: mike $ (BRL)";
d271 1
a271 1
 *			N M G _ F I N D _ V U _ I N _ F A C E
d273 6
a278 4
 *	try to find a vertex(use) in a face wich appoximately matches the
 *	coordinates given.  
 *	
 *	This is a geometric search, not a topological one.
d281 1
a281 1
nmg_find_vu_in_face(pt, fu, tol)
d309 1
a309 2
		}
		else if (magic1 == NMG_EDGEUSE_MAGIC) {
d319 1
a319 1
		} else
d321 1
d768 1
a768 1
			if( (vu = nmg_find_vu_in_face( pt, fu, tol )) )
@


1.8
log
@Added nmg_region_vertex_list().
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.7 93/04/02 02:30:04 mike Exp Locker: mike $ (BRL)";
d383 36
@


1.7
log
@Moved nmg_find_model in from nmg_mk.c
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.6 93/03/27 00:54:39 mike Exp Locker: mike $ (BRL)";
d946 60
@


1.6
log
@nmg_loop_is_ccw() needs math.h to get args to atan2() right!
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.5 93/03/26 23:39:33 mike Exp Locker: mike $ (BRL)";
d30 64
@


1.5
log
@Changed nmg_eu_with_vu_in_lu
to nmg_find_eu_with_vu_in_lu()
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.4 93/03/26 23:22:14 mike Exp Locker: mike $ (BRL)";
d25 1
d590 1
d596 2
d610 1
a610 1
	/* Value is in radians, tolerance here is 1% */
d622 5
@


1.4
log
@Changed nmg_find_loop_in_facelist() et.al. to nmg_is_loop_in_facelist().
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.3 93/03/26 23:00:06 mike Exp Locker: mike $ (BRL)";
d449 1
a449 1
 *			N M G _ E U _ W I T H _ V U _ I N _ L U
d454 1
a454 1
nmg_eu_with_vu_in_lu( lu, vu )
d463 1
a463 1
		rt_bomb("nmg_eu_with_vu_in_lu: loop has no edges!\n");
d468 1
a468 1
	rt_bomb("nmg_eu_with_vu_in_lu:  Unable to find vu!\n");
@


1.3
log
@Moved nmg_sanitize_s_lv() and nmg_shell_is_empty() from nmg_bool.c
to nmg_mod.c and nmg_info.c, respectively.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.2 93/03/26 22:06:21 mike Exp Locker: mike $ (BRL)";
d260 1
a260 1
 *			N M G _ F I N D _ V E R T E X _ I N _ E D G E L I S T
d267 1
a267 1
nmg_find_vertex_in_edgelist( v, hd )
d284 1
a284 1
 *			N M G _ F I N D _ V E R T E X _ I N _ L O O P L I S T
d291 1
a291 1
nmg_find_vertex_in_looplist( v, hd, singletons )
d311 1
a311 1
			if( nmg_find_vertex_in_edgelist( v, &lu->down_hd ) )
d314 1
a314 1
			rt_bomb("nmg_find_vertex_in_loopuse() bad magic\n");
d321 1
a321 1
 *			N M G _ F I N D _ V E R T E X _ I N _ F A C E L I S T
d328 1
a328 1
nmg_find_vertex_in_facelist( v, hd )
d337 1
a337 1
		if( nmg_find_vertex_in_looplist( v, &fu->lu_hd, 1 ) )
d344 1
a344 1
 *			N M G _ F I N D _ E D G E _ I N _ E D G E L I S T
d351 1
a351 1
nmg_find_edge_in_edgelist( e, hd )
d367 1
a367 1
 *			N M G _ F I N D _ E D G E _ I N _ L O O P L I S T
d374 1
a374 1
nmg_find_edge_in_looplist( e, hd )
d389 1
a389 1
			if( nmg_find_edge_in_edgelist( e, &lu->down_hd ) )
d392 1
a392 1
			rt_bomb("nmg_find_edge_in_loopuse() bad magic\n");
d399 1
a399 1
 *			N M G _ F I N D _ E D G E _ I N _ F A C E L I S T
d406 1
a406 1
nmg_find_edge_in_facelist( e, hd )
d415 1
a415 1
		if( nmg_find_edge_in_looplist( e, &fu->lu_hd ) )
d422 1
a422 1
 *			N M G _ F I N D _ L O O P _ I N _ F A C E L I S T
d429 1
a429 1
nmg_find_loop_in_facelist( l, fu_hd )
@


1.2
log
@Moved nmg_find_pt_in_shell() in from g_pg.c
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_info.c,v 1.1 93/03/26 21:09:13 mike Exp Locker: mike $ (BRL)";
d737 136
@


1.1
log
@Initial revision
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d455 2
a456 2
struct loopuse		*lu;
struct vertexuse	*vu;
d619 118
@
