head	11.18;
access;
symbols
	ansi-20040405-merged:11.15.2.1
	postmerge-20040405-ansi:11.16
	premerge-20040404-ansi:11.15
	postmerge-autoconf:11.15
	autoconf-freeze:11.15
	premerge-autoconf:11.15
	ansi-20040316-freeze:11.15.2.1
	postmerge-20040315-windows:11.15
	premerge-20040315-windows:11.15
	windows-20040315-freeze:11.15
	autoconf-20031203:11.15
	autoconf-20031202:11.15
	autoconf-branch:11.15.0.10
	phong-branch:11.15.0.8
	photonmap-branch:11.15.0.6
	rel-6-1-DP:11.15
	windows-branch:11.15.0.4
	rel-6-0-2:11.13
	ansi-branch:11.15.0.2
	rel-6-0-1-branch:11.13.0.2
	hartley-6-0-post:11.14
	hartley-6-0-pre:11.13
	rel-6-0-1:11.13
	rel-6-0:11.13
	rel-5-4:11.6
	offsite-5-3-pre:11.9
	rel-5-3:11.6
	rel-5-2:11.6
	rel-5-1-branch:11.6.0.2
	rel-5-1:11.6
	rel-5-0:11.3
	rel-5-0-beta:11.2
	rel-4-5:11.1
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1;
locks; strict;
comment	@ * @;


11.18
date	2004.05.21.18.07.31;	author morrison;	state dead;
branches;
next	11.17;

11.17
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.16;

11.16
date	2004.04.05.08.48.56;	author morrison;	state Exp;
branches;
next	11.15;

11.15
date	2002.08.20.17.07.59;	author jra;	state Exp;
branches
	11.15.2.1;
next	11.14;

11.14
date	2002.08.15.20.55.12;	author hartley;	state Exp;
branches;
next	11.13;

11.13
date	2001.10.02.19.24.29;	author jra;	state Exp;
branches;
next	11.12;

11.12
date	2001.06.27.13.23.13;	author jra;	state Exp;
branches;
next	11.11;

11.11
date	2001.04.20.22.29.45;	author morrison;	state Exp;
branches;
next	11.10;

11.10
date	2001.03.20.15.57.11;	author bparker;	state Exp;
branches;
next	11.9;

11.9
date	2000.07.10.23.01.32;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	2000.06.30.15.38.03;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	2000.06.30.15.31.14;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	2000.04.12.02.34.33;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	99.11.26.21.46.46;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	99.11.17.02.41.59;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	99.07.02.22.19.23;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	99.05.27.19.10.38;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.56.41;	author mike;	state Rel4_4;
branches;
next	1.5;

1.5
date	94.12.23.14.49.16;	author jra;	state Exp;
branches;
next	1.4;

1.4
date	94.11.08.03.06.42;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	94.09.30.16.24.40;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	94.08.10.18.30.56;	author gdurf;	state Exp;
branches;
next	1.1;

1.1
date	94.03.11.06.53.40;	author cjohnson;	state Exp;
branches;
next	;

11.15.2.1
date	2002.09.19.18.01.34;	author morrison;	state Exp;
branches;
next	;


desc
@A pseudo solid called a grip that is used for articulation.  Simulare
to Jack's "sites".
@


11.18
log
@moved to src/
@
text
@/*
 *			G _ G R I P . C
 *  
 *  Function -
 *  	Intersect a ray with a "grip" and return nothing.
 *
 *
 *  A GRIP is defiend by a direction normal, a center and a
 *  height/magnitued vector.  The center is the control point used
 *  for all grip movements.
 *
 *  All Ray intersections return "missed"
 *
 *  The bounding box for a grip is emtpy.
 *  
 *  Authors -
 *	Christopher T. Johnson
 *  
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1993 by Geometric Solutions, Inc.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSgrip[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/g_grip.c,v 11.17 2004/05/10 15:30:46 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "raytrace.h"
#include "nmg.h"
#include "db.h"
#include "rtgeom.h"
#include "./debug.h"

struct grip_specific {
	long	grip_magic;
	vect_t	grip_center;
	vect_t	grip_normal;
	fastf_t	grip_mag;
};
#define	GRIP_NULL	((struct grip_specific *)0)

const struct bu_structparse rt_grp_parse[] = {
	{ "%f", 3, "V", offsetof(struct rt_grip_internal, center[X]), BU_STRUCTPARSE_FUNC_NULL },
	{ "%f", 3, "N", offsetof(struct rt_grip_internal, normal[X]), BU_STRUCTPARSE_FUNC_NULL },
	{ "%f", 1, "L", offsetof(struct rt_grip_internal, mag), BU_STRUCTPARSE_FUNC_NULL },
	{ {'\0','\0','\0','\0'}, 0, (char *)NULL, 0, BU_STRUCTPARSE_FUNC_NULL }
};

/*
 *  			R T _ G R P _ P R E P
 */
int
rt_grp_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
{
	struct rt_grip_internal *gip;
	register struct grip_specific *gripp;

	gip = (struct rt_grip_internal *)ip->idb_ptr;
	RT_GRIP_CK_MAGIC(gip);

	BU_GETSTRUCT( gripp, grip_specific);
	stp->st_specific = (genptr_t)gripp;

	VMOVE(gripp->grip_normal, gip->normal);
	VMOVE(gripp->grip_center, gip->center);
	gripp->grip_mag = gip->mag;

	/* No bounding sphere or bounding RPP is possible */
	VSETALL( stp->st_min, 0.0);
	VSETALL( stp->st_max, 0.0);

	stp->st_aradius = 0.0;
	stp->st_bradius = 0.0;
	return 0;		/* OK */
}

/*
 *  			R T _ G R P _ P R I N T
 */
void
rt_grp_print(register const struct soltab *stp)
{
	register const struct grip_specific *gripp =
		(struct grip_specific *)stp->st_specific;

	if( gripp == GRIP_NULL )  {
		bu_log("grip(%s):  no data?\n", stp->st_name);
		return;
	}
	VPRINT( "Center", gripp->grip_center);
	VPRINT( "Normal", gripp->grip_normal);
	bu_log( "mag = %f\n", gripp->grip_mag);
}

/*
 *			R T _ G R P _ S H O T
 *  
 * Function -
 *	Shoot a ray at a GRIP
 *
 * Algorithm -
 * 	The intersection distance is computed.
 *  
 * Returns -
 *	0	MISS
 *	>0	HIT
 */
int
rt_grp_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
{
	return 0;	/* this has got to be the easiest */
			/* RT routine I've written */
}

#define RT_HALF_SEG_MISS(SEG)	(SEG).seg_stp=RT_SOLTAB_NULL

/*
 *			R T _ G R P _ V S H O T
 *
 *  Vectorizing version.
 */
void
rt_grp_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		  	       /* Number of ray/object pairs */
                  	    
{
	return;
}

/*
 *  			R T _ G R P _ N O R M
 *
 *  Given ONE ray distance, return the normal and entry/exit point.
 *  The normal is already filled in.
 */
void
rt_grp_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
{
	rt_bomb("rt_grp_norm: grips should never be hit.\n");
}
/*
 *			R T _ G R P _ C U R V E
 *
 *  Return the "curvature" of the grip.
 */
void
rt_grp_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
{
	rt_bomb("rt_grp_curve: nobody should be asking for curve of a grip.\n");
}

/*
 *  			R T _ G R P _ U V
 *  
 *  For a hit on a face of an HALF, return the (u,v) coordinates
 *  of the hit point.  0 <= u,v <= 1.
 *  u extends along the Xbase direction
 *  v extends along the "Ybase" direction
 *  Note that a "toroidal" map is established, varying each from
 *  0 up to 1 and then back down to 0 again.
 */
void
rt_grp_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
{
	rt_bomb("rt_grp_uv: nobody should be asking for UV of a grip.\n");
}

/*
 *			R T _ G R P _ F R E E
 */
void
rt_grp_free(struct soltab *stp)
{
	register struct grip_specific *gripp =
		(struct grip_specific *)stp->st_specific;

	bu_free( (char *)gripp, "grip_specific");
}

int
rt_grp_class(void)
{
	return(0);
}

/*
 *			R T _ G R P _ P L O T
 *
 * We represent a GRIP as a pyramid.  The center describes where
 * the center of the base is.  The normal describes which direction
 * the tip of the pyramid is.  Mag describes the distence from the
 * center to the tip. 1/4 of the width is the length of a base side.
 *
 */
int
rt_grp_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
	struct rt_grip_internal	*gip;
	vect_t xbase, ybase;	/* perpendiculars to normal */
	vect_t x1, x2;
	vect_t y1, y2;
	vect_t tip;

	RT_CK_DB_INTERNAL(ip);
	gip = (struct rt_grip_internal *)ip->idb_ptr;
	RT_GRIP_CK_MAGIC(gip);

	/* The use of "x" and "y" here is not related to the axis */
	bn_vec_perp( xbase, gip->normal );
	VCROSS( ybase, xbase, gip->normal );

	/* Arrange for the cross to be 2 meters across */
	VUNITIZE( xbase );
	VUNITIZE( ybase);
	VSCALE( xbase, xbase, gip->mag/4.0 );
	VSCALE( ybase, ybase, gip->mag/4.0 );

	VADD2( x1, gip->center, xbase );
	VSUB2( x2, gip->center, xbase );
	VADD2( y1, gip->center, ybase );
	VSUB2( y2, gip->center, ybase );

	RT_ADD_VLIST( vhead, x1, BN_VLIST_LINE_MOVE );	/* the base */
	RT_ADD_VLIST( vhead, y1, BN_VLIST_LINE_DRAW );
	RT_ADD_VLIST( vhead, x2, BN_VLIST_LINE_DRAW );
	RT_ADD_VLIST( vhead, y2, BN_VLIST_LINE_DRAW );
	RT_ADD_VLIST( vhead, x1, BN_VLIST_LINE_DRAW );

	VSCALE( tip, gip->normal, gip->mag );
	VADD2( tip, gip->center, tip );

	RT_ADD_VLIST( vhead, x1,  BN_VLIST_LINE_MOVE ); /* the sides */
	RT_ADD_VLIST( vhead, tip, BN_VLIST_LINE_DRAW );
	RT_ADD_VLIST( vhead, x2,  BN_VLIST_LINE_DRAW );
	RT_ADD_VLIST( vhead, y1,  BN_VLIST_LINE_MOVE );
	RT_ADD_VLIST( vhead, tip, BN_VLIST_LINE_DRAW );
	RT_ADD_VLIST( vhead, y2,  BN_VLIST_LINE_DRAW );
	return(0);
}

/*
 *			R T _ G R P _ I M P O R T
 *
 *  Returns -
 *	-1	failure
 *	 0	success
 */
int
rt_grp_import(struct rt_db_internal *ip, const struct bu_external *ep, const fastf_t *mat, const struct db_i *dbip)
{
	struct rt_grip_internal	*gip;
	union record	*rp;

	fastf_t		orig_eqn[3*3];
	register double	f,t;

	BU_CK_EXTERNAL( ep );
	rp = (union record *)ep->ext_buf;
	if( rp->u_id != ID_SOLID )  {
		bu_log("rt_grp_import: defective record, id=x%x\n", rp->u_id);
		return(-1);
	}

	RT_CK_DB_INTERNAL( ip );
	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_GRIP;
	ip->idb_meth = &rt_functab[ID_GRIP];
	ip->idb_ptr = bu_malloc( sizeof(struct rt_grip_internal), "rt_grip_internal");
	gip = (struct rt_grip_internal *)ip->idb_ptr;
	gip->magic = RT_GRIP_INTERNAL_MAGIC;

	rt_fastf_float( orig_eqn, rp->s.s_values, 3 );	/* 2 floats to many */

	/* Transform the point, and the normal */
	MAT4X3PNT( gip->center, mat, &orig_eqn[0] );
	MAT4X3VEC( gip->normal, mat, &orig_eqn[3] );
	if ( NEAR_ZERO(mat[15], 0.001) ) {
		rt_bomb("rt_grip_import, scale factor near zero.");
	}
	gip->mag = orig_eqn[6]/mat[15];

	/* Verify that normal has unit length */
	f = MAGNITUDE( gip->normal );
	if( f < SMALL )  {
		bu_log("rt_grp_import:  bad normal, len=%g\n", f );
		return(-1);		/* BAD */
	}
	t = f - 1.0;
	if( !NEAR_ZERO( t, 0.001 ) )  {
		/* Restore normal to unit length */
		f = 1/f;
		VSCALE( gip->normal, gip->normal, f );
	}
	return 0;			/* OK */
}

/*
 *			R T _ G R P _ E X P O R T
 */
int
rt_grp_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
{
	struct rt_grip_internal	*gip;
	union record		*rec;

	RT_CK_DB_INTERNAL(ip);
	if( ip->idb_type != ID_GRIP )  return(-1);
	gip = (struct rt_grip_internal *)ip->idb_ptr;
	RT_GRIP_CK_MAGIC(gip);

	BU_CK_EXTERNAL(ep);
	ep->ext_nbytes = sizeof(union record);
	ep->ext_buf = (genptr_t)bu_calloc( 1, ep->ext_nbytes, "grip external");
	rec = (union record *)ep->ext_buf;

	rec->s.s_id = ID_SOLID;
	rec->s.s_type = GRP;
	VMOVE(&rec->s.s_grip_N, gip->normal);
	VMOVE(&rec->s.s_grip_C, gip->center);
	rec->s.s_grip_m = gip->mag;

	return(0);
}

int
rt_grp_import5(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
{
	struct rt_grip_internal *gip;
	fastf_t			vec[7];
	register double		f,t;

	RT_CK_DB_INTERNAL( ip );
	BU_CK_EXTERNAL( ep );

	BU_ASSERT_LONG( ep->ext_nbytes, ==, SIZEOF_NETWORK_DOUBLE * 7 );

	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_GRIP;
	ip->idb_meth = &rt_functab[ID_GRIP];
	ip->idb_ptr = bu_malloc( sizeof(struct rt_grip_internal), "rt_grip_internal");

	gip = (struct rt_grip_internal *)ip->idb_ptr;
	gip->magic = RT_GRIP_INTERNAL_MAGIC;

	/* Convert from database (network) to internal (host) format */
	ntohd( (unsigned char *)vec, ep->ext_buf, 7 );

	/* Transform the point, and the normal */
	MAT4X3PNT( gip->center, mat, &vec[0] );
	MAT4X3VEC( gip->normal, mat, &vec[3] );
	if ( NEAR_ZERO(mat[15], 0.001) ) {
		rt_bomb("rt_grip_import5, scale factor near zero.");
	}
	gip->mag = vec[6]/mat[15];

	/* Verify that normal has unit length */
	f = MAGNITUDE( gip->normal );
	if( f < SMALL )  {
		bu_log("rt_grp_import:  bad normal, len=%g\n", f );
		return(-1);		/* BAD */
	}
	t = f - 1.0;
	if( !NEAR_ZERO( t, 0.001 ) )  {
		/* Restore normal to unit length */
		f = 1/f;
		VSCALE( gip->normal, gip->normal, f );
	}
	return 0;		/* OK */
}

/*
 *			R T _ G R I P _ E X P O R T 5
 *
 */
int
rt_grp_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
{
	struct rt_grip_internal *gip;
	fastf_t			vec[7];

	RT_CK_DB_INTERNAL(ip);
	if( ip->idb_type != ID_GRIP )  return(-1);
	gip = (struct rt_grip_internal *)ip->idb_ptr;
	RT_GRIP_CK_MAGIC(gip);

	BU_CK_EXTERNAL(ep);
	ep->ext_nbytes = SIZEOF_NETWORK_DOUBLE * 7;
	ep->ext_buf = (genptr_t)bu_malloc( ep->ext_nbytes, "grip external");

	VSCALE( &vec[0], gip->center, local2mm );
	VMOVE( &vec[3], gip->normal );
	vec[6] = gip->mag * local2mm;

	/* Convert from internal (host) to database (network) format */
	htond( ep->ext_buf, (unsigned char *)vec, 7 );

	return 0;
}

/*
 *			R T _ G R P _ D E S C R I B E
 *
 *  Make human-readable formatted presentation of this solid.
 *  First line describes type of solid.
 *  Additional lines are indented one tab, and give parameter values.
 */
int
rt_grp_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
{
	register struct rt_grip_internal	*gip =
		(struct rt_grip_internal *)ip->idb_ptr;
	char	buf[256];

	RT_GRIP_CK_MAGIC(gip);
	bu_vls_strcat( str, "grip\n");

	sprintf(buf, "\tN (%g, %g, %g)\n",
		V3ARGS(gip->normal));		/* should have unit length */

	bu_vls_strcat( str, buf );

	sprintf(buf, "\tC (%g %g %g) mag=%g\n",
		gip->center[0]*mm2local, gip->center[1]*mm2local,
		gip->center[2]*mm2local, gip->mag*mm2local);

	bu_vls_strcat( str, buf);
	return(0);
}

/*
 *			R T _ G R P _ I F R E E
 *
 *  Free the storage associated with the rt_db_internal version of this solid.
 */
void
rt_grp_ifree(struct rt_db_internal *ip)
{
	RT_CK_DB_INTERNAL(ip);
	bu_free( ip->idb_ptr, "grip ifree" );
	ip->idb_ptr = GENPTR_NULL;
}

/*
 *			R T _ G R P _ T E S S
 */
int
rt_grp_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
	struct rt_grip_internal	*gip;

	RT_CK_DB_INTERNAL(ip);
	gip = (struct rt_grip_internal *)ip->idb_ptr;
	RT_GRIP_CK_MAGIC(gip);

	/* XXX tess routine needed */
	return(-1);
}
@


11.17
log
@change conf.h to a wrapped config.h
@
text
@d25 1
a25 1
static const char RCSgrip[] = "@@(#)$Header: /cvs/brlcad/librt/g_grip.c,v 11.16 2004/04/05 08:48:56 morrison Exp $ (BRL)";
@


11.16
log
@merge of ansi-6-0-branch into HEAD
@
text
@d25 1
a25 1
static const char RCSgrip[] = "@@(#)$Header$ (BRL)";
d28 5
a32 1
#include "conf.h"
@


11.15
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d25 1
a25 1
static const char RCSgrip[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_grip.c,v 11.13 2001/10/02 19:24:29 jra Exp $ (BRL)";
d60 1
a60 4
rt_grp_prep( stp, ip, rtip )
struct soltab		*stp;
struct rt_db_internal	*ip;
struct rt_i		*rtip;
d88 1
a88 2
rt_grp_print( stp )
register const struct soltab *stp;
d116 1
a116 5
rt_grp_shot( stp, rp, ap, seghead )
struct soltab		*stp;
register struct xray	*rp;
struct application	*ap;
struct seg		*seghead;
d130 6
a135 6
rt_grp_vshot( stp, rp, segp, n, ap )
struct soltab	       *stp[]; /* An array of solid pointers */
struct xray		*rp[]; /* An array of ray pointers */
struct  seg            segp[]; /* array of segs (results returned) */
int		  	    n; /* Number of ray/object pairs */
struct application	*ap;
d147 1
a147 4
rt_grp_norm( hitp, stp, rp )
register struct hit *hitp;
struct soltab *stp;
register struct xray *rp;
d157 1
a157 4
rt_grp_curve( cvp, hitp, stp )
register struct curvature *cvp;
register struct hit *hitp;
struct soltab *stp;
d173 1
a173 5
rt_grp_uv( ap, stp, hitp, uvp )
struct application *ap;
struct soltab *stp;
register struct hit *hitp;
register struct uvcoord *uvp;
d182 1
a182 2
rt_grp_free( stp )
struct soltab *stp;
d191 1
a191 1
rt_grp_class()
d206 1
a206 5
rt_grp_plot( vhead, ip, ttol, tol )
struct bu_list		*vhead;
struct rt_db_internal 	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol		*tol;
d259 1
a259 5
rt_grp_import( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
const mat_t			mat;
const struct db_i		*dbip;
d311 1
a311 5
rt_grp_export( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d336 1
a336 5
rt_grp_import5( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
d386 1
a386 5
rt_grp_export5( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d418 1
a418 5
rt_grp_describe( str, ip, verbose, mm2local )
struct bu_vls		*str;
const struct rt_db_internal	*ip;
int			verbose;
double			mm2local;
d446 1
a446 2
rt_grp_ifree( ip )
struct rt_db_internal	*ip;
d457 1
a457 6
rt_grp_tess( r, m, ip, ttol, tol )
struct nmgregion	**r;
struct model		*m;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol		*tol;
@


11.15.2.1
log
@Initial ANSIfication
@
text
@d25 1
a25 1
static const char RCSgrip[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_grip.c,v 11.15 2002/08/20 17:07:59 jra Exp $ (BRL)";
d60 4
a63 1
rt_grp_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
d91 2
a92 1
rt_grp_print(register const struct soltab *stp)
d120 5
a124 1
rt_grp_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
d138 6
a143 6
rt_grp_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		  	       /* Number of ray/object pairs */
                  	    
d155 4
a158 1
rt_grp_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
d168 4
a171 1
rt_grp_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
d187 5
a191 1
rt_grp_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
d200 2
a201 1
rt_grp_free(struct soltab *stp)
d210 1
a210 1
rt_grp_class(void)
d225 5
a229 1
rt_grp_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d282 5
a286 1
rt_grp_import(struct rt_db_internal *ip, const struct bu_external *ep, const fastf_t *mat, const struct db_i *dbip)
d338 5
a342 1
rt_grp_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d367 5
a371 1
rt_grp_import5(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d421 5
a425 1
rt_grp_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d457 5
a461 1
rt_grp_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
d489 2
a490 1
rt_grp_ifree(struct rt_db_internal *ip)
d501 6
a506 1
rt_grp_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
@


11.14
log
@Converted from K&R to ANSI C - RFH
@
text
@d60 4
a63 1
rt_grp_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
d91 2
a92 1
rt_grp_print(register const struct soltab *stp)
d120 5
a124 1
rt_grp_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
d138 6
a143 6
rt_grp_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		  	       /* Number of ray/object pairs */
                  	    
d155 4
a158 1
rt_grp_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
d168 4
a171 1
rt_grp_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
d187 5
a191 1
rt_grp_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
d200 2
a201 1
rt_grp_free(struct soltab *stp)
d210 1
a210 1
rt_grp_class(void)
d225 5
a229 1
rt_grp_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d282 5
a286 1
rt_grp_import(struct rt_db_internal *ip, const struct bu_external *ep, const fastf_t *mat, const struct db_i *dbip)
d338 5
a342 1
rt_grp_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d367 5
a371 1
rt_grp_import5(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d421 5
a425 1
rt_grp_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d457 5
a461 1
rt_grp_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
d489 2
a490 1
rt_grp_ifree(struct rt_db_internal *ip)
d501 6
a506 1
rt_grp_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
@


11.13
log
@Routines were not setting idb_major_type in the internal structure
@
text
@d25 1
a25 1
static const char RCSgrip[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_grip.c,v 11.12 2001/06/27 13:23:13 jra Exp $ (BRL)";
d60 1
a60 4
rt_grp_prep( stp, ip, rtip )
struct soltab		*stp;
struct rt_db_internal	*ip;
struct rt_i		*rtip;
d88 1
a88 2
rt_grp_print( stp )
register const struct soltab *stp;
d116 1
a116 5
rt_grp_shot( stp, rp, ap, seghead )
struct soltab		*stp;
register struct xray	*rp;
struct application	*ap;
struct seg		*seghead;
d130 6
a135 6
rt_grp_vshot( stp, rp, segp, n, ap )
struct soltab	       *stp[]; /* An array of solid pointers */
struct xray		*rp[]; /* An array of ray pointers */
struct  seg            segp[]; /* array of segs (results returned) */
int		  	    n; /* Number of ray/object pairs */
struct application	*ap;
d147 1
a147 4
rt_grp_norm( hitp, stp, rp )
register struct hit *hitp;
struct soltab *stp;
register struct xray *rp;
d157 1
a157 4
rt_grp_curve( cvp, hitp, stp )
register struct curvature *cvp;
register struct hit *hitp;
struct soltab *stp;
d173 1
a173 5
rt_grp_uv( ap, stp, hitp, uvp )
struct application *ap;
struct soltab *stp;
register struct hit *hitp;
register struct uvcoord *uvp;
d182 1
a182 2
rt_grp_free( stp )
struct soltab *stp;
d191 1
a191 1
rt_grp_class()
d206 1
a206 5
rt_grp_plot( vhead, ip, ttol, tol )
struct bu_list		*vhead;
struct rt_db_internal 	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol		*tol;
d259 1
a259 5
rt_grp_import( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
const mat_t			mat;
const struct db_i		*dbip;
d311 1
a311 5
rt_grp_export( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d336 1
a336 5
rt_grp_import5( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
d386 1
a386 5
rt_grp_export5( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d418 1
a418 5
rt_grp_describe( str, ip, verbose, mm2local )
struct bu_vls		*str;
const struct rt_db_internal	*ip;
int			verbose;
double			mm2local;
d446 1
a446 2
rt_grp_ifree( ip )
struct rt_db_internal	*ip;
d457 1
a457 6
rt_grp_tess( r, m, ip, ttol, tol )
struct nmgregion	**r;
struct model		*m;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol		*tol;
@


11.12
log
@Added a structparse for the grip solid
@
text
@d25 1
a25 1
static const char RCSgrip[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_grip.c,v 11.11 2001/04/20 22:29:45 morrison Exp $ (BRL)";
d302 1
d382 1
@


11.11
log
@CONST to const
@
text
@d25 1
a25 1
static const char RCSgrip[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_grip.c,v 11.10 2001/03/20 15:57:11 bparker Exp $ (BRL)";
d48 7
@


11.10
log
@*- added import5 and export5 routines
@
text
@d25 1
a25 1
static const char RCSgrip[] = "@@(#)$Header: /d/CVS/brlcad/librt/g_grip.c,v 11.9 2000/07/10 23:01:32 mike Exp $ (BRL)";
d85 1
a85 1
register CONST struct soltab *stp;
d87 1
a87 1
	register CONST struct grip_specific *gripp =
d221 2
a222 2
CONST struct rt_tess_tol *ttol;
CONST struct bn_tol		*tol;
d277 3
a279 3
CONST struct bu_external	*ep;
CONST mat_t			mat;
CONST struct db_i		*dbip;
d332 1
a332 1
CONST struct rt_db_internal	*ip;
d334 1
a334 1
CONST struct db_i		*dbip;
d361 3
a363 3
CONST struct bu_external	*ep;
register CONST mat_t		mat;
CONST struct db_i		*dbip;
d414 1
a414 1
CONST struct rt_db_internal	*ip;
d416 1
a416 1
CONST struct db_i		*dbip;
d450 1
a450 1
CONST struct rt_db_internal	*ip;
d496 2
a497 2
CONST struct rt_tess_tol *ttol;
CONST struct bn_tol		*tol;
@


11.9
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d25 1
a25 1
static const char RCSgrip[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_grip.c,v 11.8 2000/06/30 15:38:03 mike Exp $ (BRL)";
d356 82
@


11.8
log
@
export methods should not init the external structure, just check them.
@
text
@d25 1
a25 1
static char RCSgrip[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_grip.c,v 11.7 2000/06/30 15:31:14 mike Exp $ (BRL)";
@


11.7
log
@
The import/export and import5/export5 methods must NOT
re-initialize their rt_db_internal* pointer, they should just check it.
@
text
@d25 1
a25 1
static char RCSgrip[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_grip.c,v 11.6 2000/04/12 02:34:33 mike Exp $ (BRL)";
d344 1
a344 1
	BU_INIT_EXTERNAL(ep);
@


11.6
log
@
NT port, non-compat4
@
text
@d25 1
a25 1
static char RCSgrip[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_grip.c,v 11.5 1999/11/26 21:46:46 mike Exp $ (BRL)";
d294 1
a294 1
	RT_INIT_DB_INTERNAL( ip );
@


11.5
log
@
Lint cleanups
@
text
@d25 1
a25 1
static char RCSgrip[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_grip.c,v 11.4 1999/11/17 02:41:59 mike Exp $ (BRL)";
d235 1
a235 1
	vec_perp( xbase, gip->normal );
@


11.4
log
@
Added idb_meth and st_meth pointers to allow direct access to per-solid
methods, C++ style.
@
text
@d25 1
a25 1
static char RCSgrip[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_grip.c,v 11.3 1999/07/02 22:19:23 mike Exp $ (BRL)";
d222 1
a222 1
struct bn_tol		*tol;
d275 1
a275 1
rt_grp_import( ip, ep, mat )
d279 1
d330 1
a330 1
rt_grp_export( ep, ip, local2mm )
d334 1
d368 1
a368 1
struct rt_db_internal	*ip;
d415 1
a415 1
struct bn_tol		*tol;
@


11.3
log
@
Removed dependence on compat4.h
@
text
@d25 1
a25 1
static char RCSgrip[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_grip.c,v 11.2 1999/05/27 19:10:38 mike Exp $ (BRL)";
d295 1
@


11.2
log
@
sed4
@
text
@d25 1
a25 1
static char RCSgrip[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_grip.c,v 11.1 1995/01/04 09:56:41 mike Rel4_4 $ (BRL)";
d249 5
a253 5
	RT_ADD_VLIST( vhead, x1, RT_VLIST_LINE_MOVE );	/* the base */
	RT_ADD_VLIST( vhead, y1, RT_VLIST_LINE_DRAW );
	RT_ADD_VLIST( vhead, x2, RT_VLIST_LINE_DRAW );
	RT_ADD_VLIST( vhead, y2, RT_VLIST_LINE_DRAW );
	RT_ADD_VLIST( vhead, x1, RT_VLIST_LINE_DRAW );
d258 6
a263 6
	RT_ADD_VLIST( vhead, x1,  RT_VLIST_LINE_MOVE ); /* the sides */
	RT_ADD_VLIST( vhead, tip, RT_VLIST_LINE_DRAW );
	RT_ADD_VLIST( vhead, x2,  RT_VLIST_LINE_DRAW );
	RT_ADD_VLIST( vhead, y1,  RT_VLIST_LINE_MOVE );
	RT_ADD_VLIST( vhead, tip, RT_VLIST_LINE_DRAW );
	RT_ADD_VLIST( vhead, y2,  RT_VLIST_LINE_DRAW );
@


11.1
log
@Release_4.4
@
text
@d25 1
a25 1
static char RCSgrip[] = "@@(#)$Header: /m/cad/librt/RCS/g_grip.c,v 1.5 94/12/23 14:49:16 jra Exp $ (BRL)";
d64 1
a64 1
	GETSTRUCT( gripp, grip_specific);
d91 1
a91 1
		rt_log("grip(%s):  no data?\n", stp->st_name);
d96 1
a96 1
	rt_log( "mag = %f\n", gripp->grip_mag);
d199 1
a199 1
	rt_free( (char *)gripp, "grip_specific");
d219 1
a219 1
struct rt_list		*vhead;
d222 1
a222 1
struct rt_tol		*tol;
d277 1
a277 1
CONST struct rt_external	*ep;
d286 1
a286 1
	RT_CK_EXTERNAL( ep );
d289 1
a289 1
		rt_log("rt_grp_import: defective record, id=x%x\n", rp->u_id);
d295 1
a295 1
	ip->idb_ptr = rt_malloc( sizeof(struct rt_grip_internal), "rt_grip_internal");
d312 1
a312 1
		rt_log("rt_grp_import:  bad normal, len=%g\n", f );
d329 1
a329 1
struct rt_external		*ep;
d341 1
a341 1
	RT_INIT_EXTERNAL(ep);
d343 1
a343 1
	ep->ext_buf = (genptr_t)rt_calloc( 1, ep->ext_nbytes, "grip external");
d364 1
a364 1
struct rt_vls		*str;
d374 1
a374 1
	rt_vls_strcat( str, "grip\n");
d379 1
a379 1
	rt_vls_strcat( str, buf );
d385 1
a385 1
	rt_vls_strcat( str, buf);
d399 1
a399 1
	rt_free( ip->idb_ptr, "grip ifree" );
d412 1
a412 1
struct rt_tol		*tol;
@


1.5
log
@rt_grp_describe: added multiply by mm2local for center.
@
text
@d25 1
a25 1
static char RCSgrip[] = "@@(#)$Header: /m/cad/librt/RCS/g_grip.c,v 1.4 94/11/08 03:06:42 mike Exp Locker: jra $ (BRL)";
@


1.4
log
@Irix 6
@
text
@d25 1
a25 1
static char RCSgrip[] = "@@(#)$Header: /m/cad/librt/RCS/g_grip.c,v 1.3 94/09/30 16:24:40 mike Exp Locker: mike $ (BRL)";
d382 2
a383 1
		V3ARGS(gip->center), gip->mag*mm2local);
@


1.3
log
@Null out ip->idb_ptr after freeing memory in rt_*_ifree()
@
text
@d25 1
a25 1
static char RCSgrip[] = "@@(#)$Header: /m/cad/librt/RCS/g_grip.c,v 1.2 94/08/10 18:30:56 gdurf Exp Locker: mike $ (BRL)";
a86 1
	register CONST struct rt_grip_internal *gip;
a282 2
	point_t		orig_pt;
	point_t		pt;
@


1.2
log
@Factored ifdefs
@
text
@d25 1
a25 1
static char RCSgrip[] = "@@(#)$Header: /m/cad/librt/RCS/g_grip.c,v 1.1 1994/03/11 06:53:40 cjohnson Exp gdurf $ (BRL)";
d402 1
@


1.1
log
@Initial revision
@
text
@d25 1
a25 1
static char RCSgrip[] = "@@(#)$Header: /m/cad/librt/RCS/g_grip.c,v 10.1 1993/10/14 15:01:51 cjohnson Exp cjohnson $ (BRL)";
d28 2
d33 1
a39 4

#if defined(alliant) && !defined(__STDC__)
extern double   modf();
#endif
@
