head	1.49;
access;
symbols
	ansi-20040405-merged:1.44.2.1
	postmerge-20040405-ansi:1.46
	premerge-20040404-ansi:1.46
	postmerge-autoconf:1.46
	autoconf-freeze:1.44.10.3
	premerge-autoconf:1.46
	ansi-20040316-freeze:1.44
	postmerge-20040315-windows:1.46
	premerge-20040315-windows:1.46
	windows-20040315-freeze:1.44.4.1
	autoconf-20031203:1.44.10.1
	autoconf-20031202:1.44
	autoconf-branch:1.44.0.10
	phong-branch:1.44.0.8
	photonmap-branch:1.44.0.6
	rel-6-1-DP:1.44
	windows-branch:1.44.0.4
	rel-6-0-2:1.41
	ansi-branch:1.44.0.2
	rel-6-0-1-branch:1.41.0.2
	hartley-6-0-post:1.43
	hartley-6-0-pre:1.42
	rel-6-0-1:1.41
	rel-6-0:1.41
	rel-5-4:1.17
	offsite-5-3-pre:1.31
	rel-5-3:1.17
	rel-5-2:1.17
	rel-5-1-branch:1.17.0.2
	rel-5-1:1.17
	rel-5-0:1.12
	rel-5-0-beta:1.11
	rel-4-5:1.8
	ctj-4-5-post:1.7
	ctj-4-5-pre:1.7;
locks; strict;
comment	@ * @;


1.49
date	2004.05.21.18.07.36;	author morrison;	state dead;
branches;
next	1.48;

1.48
date	2004.05.10.15.30.47;	author erikg;	state Exp;
branches;
next	1.47;

1.47
date	2004.05.04.17.51.55;	author morrison;	state Exp;
branches;
next	1.46;

1.46
date	2004.02.02.17.39.29;	author morrison;	state Exp;
branches;
next	1.45;

1.45
date	2003.11.20.07.04.44;	author morrison;	state Exp;
branches;
next	1.44;

1.44
date	2002.08.20.17.08.10;	author jra;	state Exp;
branches
	1.44.2.1
	1.44.4.1
	1.44.10.1;
next	1.43;

1.43
date	2002.08.15.20.55.22;	author hartley;	state Exp;
branches;
next	1.42;

1.42
date	2002.08.15.13.48.53;	author jra;	state Exp;
branches;
next	1.41;

1.41
date	2002.01.09.19.58.18;	author jra;	state Exp;
branches;
next	1.40;

1.40
date	2001.11.21.20.53.10;	author jra;	state Exp;
branches;
next	1.39;

1.39
date	2001.11.08.22.04.01;	author butler;	state Exp;
branches;
next	1.38;

1.38
date	2001.10.05.21.23.45;	author bparker;	state Exp;
branches;
next	1.37;

1.37
date	2001.10.02.18.25.45;	author jra;	state Exp;
branches;
next	1.36;

1.36
date	2001.10.02.17.56.42;	author jra;	state Exp;
branches;
next	1.35;

1.35
date	2001.05.01.12.57.56;	author bparker;	state Exp;
branches;
next	1.34;

1.34
date	2001.03.23.22.05.30;	author jra;	state Exp;
branches;
next	1.33;

1.33
date	2001.03.22.20.26.26;	author bparker;	state Exp;
branches;
next	1.32;

1.32
date	2001.03.20.21.54.09;	author pjt;	state Exp;
branches;
next	1.31;

1.31
date	2001.03.16.14.47.19;	author jra;	state Exp;
branches;
next	1.30;

1.30
date	2000.11.01.20.37.17;	author mike;	state Exp;
branches;
next	1.29;

1.29
date	2000.09.08.05.54.43;	author mike;	state Exp;
branches;
next	1.28;

1.28
date	2000.09.08.02.20.10;	author mike;	state Exp;
branches;
next	1.27;

1.27
date	2000.08.21.02.02.34;	author butler;	state Exp;
branches;
next	1.26;

1.26
date	2000.08.10.23.56.45;	author mike;	state Exp;
branches;
next	1.25;

1.25
date	2000.08.10.20.48.37;	author mike;	state Exp;
branches;
next	1.24;

1.24
date	2000.08.10.04.49.59;	author mike;	state Exp;
branches;
next	1.23;

1.23
date	2000.07.20.14.00.13;	author jra;	state Exp;
branches;
next	1.22;

1.22
date	2000.07.12.21.55.22;	author mike;	state Exp;
branches;
next	1.21;

1.21
date	2000.07.12.02.11.28;	author mike;	state Exp;
branches;
next	1.20;

1.20
date	2000.07.10.23.01.52;	author mike;	state Exp;
branches;
next	1.19;

1.19
date	2000.06.30.15.27.09;	author pjt;	state Exp;
branches;
next	1.18;

1.18
date	2000.06.29.18.20.56;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	2000.05.31.20.49.26;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	2000.01.03.21.44.08;	author bparker;	state Exp;
branches;
next	1.15;

1.15
date	99.12.30.02.48.01;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	99.12.29.23.23.11;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	99.11.26.22.13.39;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	99.06.03.01.22.49;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	98.05.12.17.44.20;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	98.03.26.07.37.55;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	98.03.19.15.57.01;	author jra;	state Exp;
branches;
next	1.8;

1.8
date	98.01.28.06.31.13;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	97.06.25.04.43.13;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	97.06.25.03.00.48;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	97.06.24.19.56.37;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	97.06.20.01.14.13;	author gdurf;	state Exp;
branches;
next	1.3;

1.3
date	97.06.20.00.48.00;	author gdurf;	state Exp;
branches;
next	1.2;

1.2
date	97.03.12.17.16.26;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	97.02.05.04.39.44;	author mike;	state Exp;
branches;
next	;

1.44.2.1
date	2004.03.17.21.19.01;	author morrison;	state Exp;
branches;
next	;

1.44.4.1
date	2004.03.11.23.43.47;	author morrison;	state Exp;
branches;
next	;

1.44.10.1
date	2003.12.03.16.24.08;	author erikg;	state Exp;
branches;
next	1.44.10.2;

1.44.10.2
date	2004.02.12.18.37.48;	author erikg;	state Exp;
branches;
next	1.44.10.3;

1.44.10.3
date	2004.03.15.14.07.30;	author erikg;	state Exp;
branches;
next	;


desc
@librt/wdb.c
The New Release 5.0 "libwdb" support routines.
@


1.49
log
@moved to src/
@
text
@/*
 *			W D B . C
 *
 *  Routines to allow libwdb to use librt's import/export interface,
 *  rather than having to know about the database formats directly.
 *
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 2000-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/wdb.c,v 1.48 2004/05/10 15:30:47 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "rtgeom.h"
#include "raytrace.h"
#include "wdb.h"

/*
 *			W D B _ F O P E N
 *
 *  Create a libwdb output stream destined for a disk file.
 *  This will destroy any existing file by this name, and start fresh.
 *  The file is then opened in the normal "update" mode and
 *  an in-memory directory is built along the way,
 *  allowing retrievals and object replacements as needed.
 *
 *  Users can change the database title by calling: ???
 */
struct rt_wdb *
wdb_fopen_v( const char *filename, int version )
{
	struct db_i	*dbip;

	if( rt_uniresource.re_magic != RESOURCE_MAGIC )
		rt_init_resource( &rt_uniresource, 0, NULL );

	if( (dbip = db_create( filename, version )) == DBI_NULL )
		return RT_WDB_NULL;

	return wdb_dbopen( dbip, RT_WDB_TYPE_DB_DISK );
}

struct rt_wdb *
wdb_fopen( const char *filename)
{
    return wdb_fopen_v(filename, 5);
}


/*
 *			W D B _ D B O P E N
 *
 *  Create a libwdb output stream destined for an existing BRL-CAD database,
 *  already opened via a db_open() call.
 *	RT_WDB_TYPE_DB_DISK			Add to on-disk database
 *	RT_WDB_TYPE_DB_DISK_APPEND_ONLY		Add to on-disk database, don't clobber existing names, use prefix
 *	RT_WDB_TYPE_DB_INMEM			Add to in-memory database only
 *	RT_WDB_TYPE_DB_INMEM_APPEND_ONLY	Ditto, but give errors if name in use.
 */
struct rt_wdb *
wdb_dbopen( struct db_i *dbip, int mode )
{
	struct rt_wdb	*wdbp;

	RT_CK_DBI(dbip);

	if (mode != RT_WDB_TYPE_DB_DISK	 && mode != RT_WDB_TYPE_DB_DISK_APPEND_ONLY &&
	    mode != RT_WDB_TYPE_DB_INMEM && mode != RT_WDB_TYPE_DB_INMEM_APPEND_ONLY) {
		bu_log("wdb_dbopen(%s) mode %d unknown\n",
			dbip->dbi_filename, mode );
		return RT_WDB_NULL;
	}

#if 0
	if( (mode == RT_WDB_TYPE_DB_DISK || mode == RT_WDB_TYPE_DB_DISK_APPEND_ONLY ) &&
	    dbip->dbi_read_only )  {
		/* In-mem updates happen regardless of disk read-only flag */
		bu_log("wdb_dbopen(%s): read-only\n",
			dbip->dbi_filename );
	}
#endif

	if( rt_uniresource.re_magic != RESOURCE_MAGIC )
		rt_init_resource( &rt_uniresource, 0, NULL );

	BU_GETSTRUCT(wdbp, rt_wdb);
	wdbp->l.magic = RT_WDB_MAGIC;
	wdbp->type = mode;
	wdbp->dbip = dbip;
	wdbp->dbip->dbi_wdbp = wdbp;

	/* Provide the same default tolerance that librt/prep.c does */
	wdbp->wdb_tol.magic = BN_TOL_MAGIC;
	wdbp->wdb_tol.dist = 0.005;
	wdbp->wdb_tol.dist_sq = wdbp->wdb_tol.dist * wdbp->wdb_tol.dist;
	wdbp->wdb_tol.perp = 1e-6;
	wdbp->wdb_tol.para = 1 - wdbp->wdb_tol.perp;

	wdbp->wdb_ttol.magic = RT_TESS_TOL_MAGIC;
	wdbp->wdb_ttol.abs = 0.0;
	wdbp->wdb_ttol.rel = 0.01;
	wdbp->wdb_ttol.norm = 0;
	bu_vls_init( &wdbp->wdb_prestr );

	return wdbp;

}

/* 
 *			W D B _ I M P O R T
 *
 *  Returns -
 *	0	and modified *internp;
 *	-1	ft_import failure (from rt_db_get_internal)
 *	-2	db_get_external failure (from rt_db_get_internal)
 *	-3	Attempt to import from write-only (stream) file.
 *	-4	Name not found in database TOC.
 *
 *  NON-PARALLEL because of rt_uniresource
 */
int
wdb_import(struct rt_wdb *wdbp,	struct rt_db_internal *internp,	const char *name, const mat_t mat )
{
	struct directory	*dp;

	if( (dp = db_lookup( wdbp->dbip, name, LOOKUP_QUIET )) == DIR_NULL )
		return -4;

	return rt_db_get_internal( internp, dp, wdbp->dbip, mat, &rt_uniresource );
}

/*
 *			W D B _ E X P O R T _ E X T E R N A L
 *
 *  The caller must free "ep".
 *
 *  Returns -
 *	 0	OK
 *	<0	error
 */
int
wdb_export_external(
	struct rt_wdb *wdbp,
	struct bu_external *ep,
	const char *name,
	int flags,
	unsigned char type)
{
	struct directory	*dp;

	RT_CK_WDB(wdbp);
	BU_CK_EXTERNAL(ep);

	/* Stash name into external representation */
	if( wdbp->dbip->dbi_version <= 4 )  {
		db_wrap_v4_external( ep, name );
	} else if( wdbp->dbip->dbi_version == 5 )  {
		if( db_wrap_v5_external( ep, name ) < 0 )  {
			bu_log("wdb_export_external(%s): db_wrap_v5_external error\n",
				name );
			return -4;
		}
	} else {
		bu_log("wdb_export_external(%s): version %d unsupported\n",
				name, wdbp->dbip->dbi_version );
		return -4;
	}

	switch( wdbp->type )  {

	case RT_WDB_TYPE_DB_DISK:
		if( wdbp->dbip->dbi_read_only )  {
			bu_log("wdb_export_external(%s): read-only database, write aborted\n");
			return -5;
		}
		/* If name already exists, that object will be updated. */
		dp = db_lookup( wdbp->dbip, name, LOOKUP_QUIET );
		if( dp == DIR_NULL ) {
			if( (dp = db_diradd( wdbp->dbip, name, -1L, 0, flags,
					   (genptr_t)&type )) == DIR_NULL )  {
			bu_log("wdb_export_external(%s): db_diradd error\n",
			       name );
			return -3;
			}
		}
		dp->d_flags = (dp->d_flags & ~7) | flags;
		if( db_put_external( ep, dp, wdbp->dbip ) < 0 )  {
			bu_log("wdb_export_external(%s): db_put_external error\n",
				name );
			return -3;
		}
		break;

	case RT_WDB_TYPE_DB_DISK_APPEND_ONLY:
		if( wdbp->dbip->dbi_read_only )  {
			bu_log("wdb_export_external(%s): read-only database, write aborted\n");
			return -5;
		}
		/* If name already exists, new non-conflicting name will be generated */
		if( (dp = db_diradd( wdbp->dbip, name, -1L, 0, flags,
				    (genptr_t)&type )) == DIR_NULL )  {
			bu_log("wdb_export_external(%s): db_diradd error\n",
			       name );
			return -3;
		}
		if( db_put_external( ep, dp, wdbp->dbip ) < 0 )  {
			bu_log("wdb_export_external(%s): db_put_external error\n",
				name );
			return -3;
		}
		break;

	case RT_WDB_TYPE_DB_INMEM_APPEND_ONLY:
		if( (dp = db_lookup( wdbp->dbip, name, 0 )) != DIR_NULL )  {
			bu_log("wdb_export_external(%s): ERROR, that name is already in use, and APPEND_ONLY mode has been specified.\n",
				name );
			return -3;
		}
		if( (dp = db_diradd( wdbp->dbip, name, -1L, 0, flags,
				(genptr_t)&type )) == DIR_NULL )  {
			bu_log("wdb_export_external(%s): db_diradd error\n",
			       name );
			return -3;
		}

		db_inmem( dp, ep, flags, wdbp->dbip );
		/* ep->buf has been stolen, replaced with null. */
		break;

	case RT_WDB_TYPE_DB_INMEM:
		if( (dp = db_lookup( wdbp->dbip, name, 0 )) == DIR_NULL )  {
			if( (dp = db_diradd( wdbp->dbip, name, -1L, 0, flags,
					(genptr_t)&type )) == DIR_NULL )  {
				bu_log("wdb_export_external(%s): db_diradd error\n",
				       name );
				bu_free_external( ep );
				return -3;
			}
		} else {
			dp->d_flags = (dp->d_flags & ~7) | flags;
		}

		db_inmem( dp, ep, flags, wdbp->dbip );
		/* ep->buf has been stolen, replaced with null. */
		break;
	}

	return 0;
}

/*
 *			W D B _ P U T _ I N T E R N A L
 *
 *  Convert the internal representation of a solid to the external one,
 *  and write it into the database.
 *  The internal representation is always freed.
 *  This is the analog of rt_db_put_internal() for rt_wdb objects.
 *
 *  Use this routine in preference to wdb_export() whenever the
 *  caller already has an rt_db_internal structure handy.
 *
 *  NON-PARALLEL because of rt_uniresource
 *
 *  Returns -
 *	 0	OK
 *	<0	error
 */
int
wdb_put_internal(
	struct rt_wdb *wdbp,
	const char *name,
	struct rt_db_internal *ip,
	double local2mm )
{
	struct bu_external	ext;
	int			ret;
	int			flags;

	RT_CK_WDB(wdbp);
	RT_CK_DB_INTERNAL(ip);

	if( wdbp->dbip->dbi_version <= 4 )  {
		BU_INIT_EXTERNAL( &ext );
		ret = ip->idb_meth->ft_export( &ext, ip, local2mm, wdbp->dbip, &rt_uniresource );
		if( ret < 0 )  {
			bu_log("rt_db_put_internal(%s):  solid export failure\n",
				name);
			ret = -1;
			goto out;
		}
		db_wrap_v4_external( &ext, name );
	} else {
		if( rt_db_cvt_to_external5( &ext, name, ip, local2mm, wdbp->dbip, &rt_uniresource, ip->idb_major_type ) < 0 )  {
			bu_log("wdb_export(%s): solid export failure\n",
				name );
			ret = -2;
			goto out;
		}
	}
	BU_CK_EXTERNAL( &ext );

	flags = db_flags_internal( ip );
	ret = wdb_export_external( wdbp, &ext, name, flags, ip->idb_type );
out:
	bu_free_external( &ext );
	rt_db_free_internal( ip, &rt_uniresource );
	return ret;
}

/*
 *			W D B _ E X P O R T
 *
 *  Export an in-memory representation of an object,
 *  as described in the file h/rtgeom.h, into the indicated database.
 *
 *  The internal representation (gp) is always freed.
 *
 *  WARNING: The caller must be careful not to double-free gp,
 *  particularly if it's been extracted from an rt_db_internal,
 *  e.g. by passing intern.idb_ptr for gp.
 *
 *  If the caller has an rt_db_internal structure handy already,
 *  they should call wdb_put_internal() directly -- this is a
 *  convenience routine intended primarily for internal use in LIBWDB.
 *
 *  Returns -
 *	 0	OK
 *	<0	error
 */
int
wdb_export(
	struct rt_wdb *wdbp,
	const char *name,
	genptr_t gp,
	int id,
	double local2mm )
{
	struct rt_db_internal	intern;

	RT_CK_WDB(wdbp);

	if( (id <= 0 || id > ID_MAX_SOLID) && id != ID_COMBINATION )  {
		bu_log("wdb_export(%s): id=%d bad\n",
			name, id );
		return(-1);
	}

	RT_INIT_DB_INTERNAL( &intern );
	intern.idb_major_type = DB5_MAJORTYPE_BRLCAD;
	intern.idb_type = id;
	intern.idb_ptr = gp;
	intern.idb_meth = &rt_functab[id];

	return wdb_put_internal( wdbp, name, &intern, local2mm );
}

/*
 *			W D B _ C L O S E
 *
 *  Release from associated database "file", destroy dynamic data structure.
 */
void
wdb_close( struct rt_wdb *wdbp )
{

	RT_CK_WDB(wdbp);

	/* XXX Flush any unwritten "struct matter" records here */

	db_close( wdbp->dbip );

	bu_vls_free( &wdbp->wdb_prestr );
	bu_free( (genptr_t)wdbp, "struct rt_wdb");
}
@


1.48
log
@change conf.h to a wrapped config.h
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/librt/wdb.c,v 1.47 2004/05/04 17:51:55 morrison Exp $ (ARL)";
@


1.47
log
@dbi_uses being incremented once too often?  bob seems to think so (incremented in db_open())
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d27 5
a31 1
#include "conf.h"
@


1.46
log
@update copyright to include span through 2003
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb.c,v 1.45 2003/11/20 07:04:44 morrison Exp $ (ARL)";
a111 2

	dbip->dbi_uses++;
@


1.45
log
@test commit for syncmail
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 2000 by the United States Army
d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb.c,v 1.44 2002/08/20 17:08:10 jra Exp $ (ARL)";
@


1.44
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb.c,v 1.42 2002/08/15 13:48:53 jra Exp $ (ARL)";
d145 1
a145 5
wdb_import(
	struct rt_wdb *wdbp,
	struct rt_db_internal *internp,
	const char *name,
	const mat_t mat )
@


1.44.2.1
log
@sync branch with HEAD
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 2000-2004 by the United States Army
d24 1
a24 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d145 5
a149 1
wdb_import(struct rt_wdb *wdbp,	struct rt_db_internal *internp,	const char *name, const mat_t mat )
@


1.44.4.1
log
@sync to HEAD...
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 2000-2004 by the United States Army
d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/wdb.c,v 1.46 2004/02/02 17:39:29 morrison Exp $ (ARL)";
d145 5
a149 1
wdb_import(struct rt_wdb *wdbp,	struct rt_db_internal *internp,	const char *name, const mat_t mat )
@


1.44.10.1
log
@updates from HEAD, part 1
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb.c,v 1.45 2003/11/20 07:04:44 morrison Exp $ (ARL)";
d145 5
a149 1
wdb_import(struct rt_wdb *wdbp,	struct rt_db_internal *internp,	const char *name, const mat_t mat )
@


1.44.10.2
log
@merge from HEAD
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 2000-2004 by the United States Army
d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb.c,v 1.46 2004/02/02 17:39:29 morrison Exp $ (ARL)";
@


1.44.10.3
log
@merge from head
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb.c,v 1.44.10.2 2004/02/12 18:37:48 erikg Exp $ (ARL)";
@


1.43
log
@Converted from K&R to ANSI C - RFH
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb.c,v 1.41 2002/01/09 19:58:18 jra Exp $ (ARL)";
d253 1
a253 1
		db_inmem( dp, ep, flags );
d270 1
a270 1
		db_inmem( dp, ep, flags );
@


1.42
log
@db_inmem() needed different behavior depending on db version
@
text
@d253 1
a253 1
		db_inmem( dp, ep, flags, wdbp->dbip );
d270 1
a270 1
		db_inmem( dp, ep, flags, wdbp->dbip );
@


1.41
log
@Undo previous mod (not needed)
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb.c,v 1.40 2001/11/21 20:53:10 jra Exp $ (ARL)";
d253 1
a253 1
		db_inmem( dp, ep, flags );
d270 1
a270 1
		db_inmem( dp, ep, flags );
@


1.40
log
@wdb_export_external() now handles long names
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb.c,v 1.39 2001/11/08 22:04:01 butler Exp $ (ARL)";
a176 1
	struct bu_attribute_value_set		avs;
a184 1
		bu_avs_init( &avs, 1, "avs" );
d206 5
a210 15
			if( wdbp->dbip->dbi_version <= 4 )  {
				if( (dp = db_diradd( wdbp->dbip, name, -1L, 0, flags,
						   (genptr_t)&type )) == DIR_NULL )  {
				bu_log("wdb_export_external(%s): db_diradd error\n",
				       name );
				return -3;
				}
			} else {
				if( (dp = db_diradd5( wdbp->dbip, name, -1L,
						    DB5_MAJORTYPE_BRLCAD, type, 0, 0,
						    &avs )) == DIR_NULL )  {
				bu_log("wdb_export_external(%s): db_diradd error\n",
				       name );
				return -3;
				}
d227 5
a231 14
		if( wdbp->dbip->dbi_version <= 4 )  {
			if( (dp = db_diradd( wdbp->dbip, name, -1L, 0, flags,
					    (genptr_t)&type )) == DIR_NULL )  {
				bu_log("wdb_export_external(%s): db_diradd error\n",
				       name );
				return -3;
			}
		} else {
			if( (dp = db_diradd5( wdbp->dbip, name, -1L, DB5_MAJORTYPE_BRLCAD,
					      type, 0, 0, &avs )) == DIR_NULL )  {
				bu_log("wdb_export_external(%s): db_diradd error\n",
				       name );
				return -3;
			}
d246 5
a250 14
		if( wdbp->dbip->dbi_version <= 4 )  {
			if( (dp = db_diradd( wdbp->dbip, name, -1L, 0, flags,
					(genptr_t)&type )) == DIR_NULL )  {
				bu_log("wdb_export_external(%s): db_diradd error\n",
				       name );
				return -3;
			}
		} else {
			if( (dp = db_diradd5( wdbp->dbip, name, -1L, DB5_MAJORTYPE_BRLCAD,
					      type, 0, 0, &avs )) == DIR_NULL )  {
				bu_log("wdb_export_external(%s): db_diradd error\n",
				       name );
				return -3;
			}
d259 6
a264 17
			if( wdbp->dbip->dbi_version <= 4 )  {
				if( (dp = db_diradd( wdbp->dbip, name, -1L, 0, flags,
						(genptr_t)&type )) == DIR_NULL )  {
					bu_log("wdb_export_external(%s): db_diradd error\n",
					       name );
					bu_free_external( ep );
					return -3;
				}
			} else {
				if( (dp = db_diradd5( wdbp->dbip, name, -1L,
						      DB5_MAJORTYPE_BRLCAD, type, 0, 0,
						      &avs )) == DIR_NULL )  {
					bu_log("wdb_export_external(%s): db_diradd error\n",
					       name );
					bu_free_external( ep );
					return -3;
				}
a272 4
		}

	if( wdbp->dbip->dbi_version > 4 )  {
		bu_avs_free( &avs );
@


1.39
log
@Changes to "Keep" to require both databases be in the same format
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb.c,v 1.38 2001/10/05 21:23:45 bparker Exp $ (ARL)";
d177 1
d186 1
d206 18
a223 5
		if( (dp = db_lookup( wdbp->dbip, name, LOOKUP_QUIET )) == DIR_NULL &&
		    (dp = db_diradd( wdbp->dbip, name, -1L, 0, flags, (genptr_t)&type )) == DIR_NULL )  {
			bu_log("wdb_export_external(%s): db_diradd error\n",
				name );
			return -3;
d239 14
a252 4
		if( (dp = db_diradd( wdbp->dbip, name, -1L, 0, flags, (genptr_t)&type )) == DIR_NULL )  {
			bu_log("wdb_export_external(%s): db_diradd error\n",
				name );
			return -3;
d267 14
a280 4
		if( (dp = db_diradd( wdbp->dbip, name, -1L, 0, flags, (genptr_t)&type )) == DIR_NULL )  {
			bu_log("wdb_export_external(%s): db_diradd error\n",
				name );
			return -3;
d289 17
a305 5
			if( (dp = db_diradd( wdbp->dbip, name, -1L, 0, flags, (genptr_t)&type )) == DIR_NULL )  {
				bu_log("wdb_export_external(%s): db_diradd error\n",
					name );
				bu_free_external( ep );
				return -3;
d314 4
d319 1
@


1.38
log
@*- if'ed out bu_log in wdb_dbopen that spews
   when the database is read-only
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb.c,v 1.37 2001/10/02 18:25:45 jra Exp $ (ARL)";
d51 1
a51 1
wdb_fopen( const char *filename )
d58 1
a58 1
	if( (dbip = db_create( filename, 5 )) == DBI_NULL )
d63 7
@


1.37
log
@wdb_export was not setting idb_major_type in internal struct
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb.c,v 1.36 2001/10/02 17:56:42 jra Exp $ (ARL)";
d88 1
d95 1
@


1.36
log
@wdb_put_internal() was calling rt_db_cvt_to_external5() with major type of DB5_MAJORTYPE_BRLCAD
hardwired in, changed it to use ip->idb_major_type
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb.c,v 1.35 2001/05/01 12:57:56 bparker Exp $ (ARL)";
d360 1
@


1.35
log
@*- mods to wdb_dbopen
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb.c,v 1.34 2001/03/23 22:05:30 jra Exp $ (ARL)";
d304 1
a304 1
		if( rt_db_cvt_to_external5( &ext, name, ip, local2mm, wdbp->dbip, &rt_uniresource, DB5_MAJORTYPE_BRLCAD ) < 0 )  {
@


1.34
log
@Support for major and minor types in directory structure
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/librt/wdb.c,v 1.33 2001/03/22 20:26:26 bparker Exp $ (ARL)";
d81 2
a82 1
	if( mode != RT_WDB_TYPE_DB_DISK && mode != RT_WDB_TYPE_DB_INMEM && mode != RT_WDB_TYPE_DB_DISK )  {
@


1.33
log
@*- set ptr back to wdbp
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/librt/wdb.c,v 1.32 2001/03/20 21:54:09 pjt Exp $ (ARL)";
d163 2
a164 1
	int flags )
d195 1
a195 1
		    (dp = db_diradd( wdbp->dbip, name, -1L, 0, flags, NULL )) == DIR_NULL )  {
d214 1
a214 1
		if( (dp = db_diradd( wdbp->dbip, name, -1L, 0, flags, NULL )) == DIR_NULL )  {
d232 1
a232 1
		if( (dp = db_diradd( wdbp->dbip, name, -1L, 0, flags, NULL )) == DIR_NULL )  {
d244 1
a244 1
			if( (dp = db_diradd( wdbp->dbip, name, -1L, 0, flags, NULL )) == DIR_NULL )  {
d313 1
a313 1
	ret = wdb_export_external( wdbp, &ext, name, flags );
@


1.32
log
@Added DB5_MAJORTYPE_BRLCAD as last arg. to rt_db_cvt_to_external5()
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/librt/wdb.c,v 1.31 2001/03/16 14:47:19 jra Exp $ (ARL)";
d101 1
@


1.31
log
@wdb_dbopen() now does a bu_vls_init( &wdbp->wdb_prestr ) and wdb_close does a bu_vls_free( &wdbp->wdb_prestr )
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb.c,v 1.30 2000/11/01 20:37:17 mike Exp $ (ARL)";
d301 1
a301 1
		if( rt_db_cvt_to_external5( &ext, name, ip, local2mm, wdbp->dbip, &rt_uniresource ) < 0 )  {
@


1.30
log
@
db_create() got version argument
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb.c,v 1.29 2000/09/08 05:54:43 mike Exp $ (ARL)";
d115 1
d118 1
d379 1
@


1.29
log
@
Modified tree routines to take resource pointer.
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb.c,v 1.28 2000/09/08 02:20:10 mike Exp $ (ARL)";
d58 1
a58 1
	if( (dbip = db_create( filename )) == DBI_NULL )
@


1.28
log
@
Init rt_uniresource
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb.c,v 1.27 2000/08/21 02:02:34 butler Exp $ (ARL)";
d56 1
a56 1
		rt_init_resource( &rt_uniresource, 0 );
d95 1
a95 1
		rt_init_resource( &rt_uniresource, 0 );
d128 2
d143 1
a143 1
	return rt_db_get_internal( internp, dp, wdbp->dbip, mat );
d268 2
d290 1
a290 1
		ret = ip->idb_meth->ft_export( &ext, ip, local2mm, wdbp->dbip );
d299 1
a299 1
		if( rt_db_cvt_to_external5( &ext, name, ip, local2mm, wdbp->dbip ) < 0 )  {
d312 1
a312 1
	rt_db_free_internal( ip );
@


1.27
log
@Massive compilation warnings eliminated
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb.c,v 1.26 2000/08/10 23:56:45 mike Exp $ (ARL)";
d55 3
d93 3
@


1.26
log
@
Added some essential comments, recommending the use of
wdb_put_internal() over wdb_export() whenever possible.
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb.c,v 1.25 2000/08/10 20:48:37 mike Exp $ (ARL)";
d161 1
a161 5
		if( db_wrap_v4_external( ep, name ) < 0 )  {
			bu_log("wdb_export_external(%s): db_wrap_v4_external error\n",
				name );
			return -4;
		}
@


1.25
log
@
Added comment about important use of wdb_export().
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb.c,v 1.24 2000/08/10 04:49:59 mike Exp $ (ARL)";
d261 3
d321 4
@


1.24
log
@
Provide default tolerance values on wdb_dbopen()
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb.c,v 1.23 2000/07/20 14:00:13 jra Exp $ (ARL)";
d310 8
a317 1
 *  The internal representation is always freed.
@


1.23
log
@wdb_put_internal() was missing a BU_INIT_EXTERNAL( &ext )
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb.c,v 1.22 2000/07/12 21:55:22 mike Exp $ (ARL)";
d97 12
@


1.22
log
@
Improved wdb interface
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb.c,v 1.21 2000/07/12 02:11:28 mike Exp $ (ARL)";
d268 1
@


1.21
log
@
Added wdb_version and multi-version support.
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1996 by the United States Army
d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb.c,v 1.20 2000/07/10 23:01:52 mike Exp $ (ARL)";
d43 6
a48 1
 *  The stream is established in "append-only" mode.
d51 1
a51 2
wdb_fopen( filename )
CONST char *filename;
a52 2
	struct rt_wdb	*wdbp;
	FILE		*fp;
d58 1
a58 10
	if( (fp = fopen( filename, "ab" )) == NULL )
		return RT_WDB_NULL;

	BU_GETSTRUCT(wdbp, rt_wdb);
	wdbp->l.magic = RT_WDB_MAGIC;
	wdbp->type = RT_WDB_TYPE_FILE;
	wdbp->fp = fp;
	wdbp->wdb_version = dbip->dbi_version;
	db_close(dbip);
	return wdbp;
d72 1
a72 3
wdb_dbopen( dbip, mode )
struct db_i	*dbip;
int		mode;
a94 1
	wdbp->wdb_version = dbip->dbi_version;
d112 5
a116 5
wdb_import( wdbp, internp, name, mat )
struct rt_wdb			*wdbp;
struct rt_db_internal		*internp;
CONST char			*name;
CONST mat_t			mat;
a119 3
	if( wdbp->type == RT_WDB_TYPE_FILE )
		return -3;	/* No table of contents, file is write-only */

d136 5
a140 5
wdb_export_external( wdbp, ep, name, flags )
struct rt_wdb		*wdbp;
struct bu_external	*ep;
CONST char		*name;
int			flags;
d148 1
a148 1
	if( wdbp->wdb_version <= 4 )  {
d154 1
a154 1
	} else if( wdbp->wdb_version == 5 )  {
d162 1
a162 1
				name, wdbp->wdb_version );
a167 8
	case RT_WDB_TYPE_FILE:
		if( bu_fwrite_external( wdbp->fp, ep ) < 0 )  {
			bu_log("wdb_export_external(%s): fwrite error\n",
				name );
			return(-3);
		}
		break;

d242 1
a242 1
 *			W D B _ E X P O R T
d244 4
a247 1
 *  The caller must free "gp".
d254 5
a258 6
wdb_export( wdbp, name, gp, id, local2mm )
struct rt_wdb	*wdbp;
CONST char	*name;
genptr_t	gp;
int		id;
double		local2mm;
a259 1
	struct rt_db_internal	intern;
d262 1
d264 2
a265 10
	if( (id <= 0 || id > ID_MAX_SOLID) && id != ID_COMBINATION )  {
		bu_log("wdb_export(%s): id=%d bad\n",
			name, id );
		return(-1);
	}

	RT_INIT_DB_INTERNAL( &intern );
	intern.idb_type = id;
	intern.idb_ptr = gp;
	intern.idb_meth = &rt_functab[id];
d267 2
a268 2
	if( wdbp->wdb_version <= 4 )  {
		ret = intern.idb_meth->ft_export( &ext, &intern, local2mm, wdbp->dbip );
d272 2
a273 2
			bu_free_external( &ext );
			return -2;		/* FAIL */
d277 1
a277 1
		if( rt_db_cvt_to_external5( &ext, name, &intern, local2mm, wdbp->dbip ) < 0 )  {
d280 2
a281 2
			bu_free_external( &ext );
			return(-2);				/* FAIL */
d286 3
a288 1
	ret = wdb_export_external( wdbp, &ext, name, db_flags_internal( &intern ) );
d290 1
d295 35
d332 1
a332 1
 *  Release from associated database "file", destroy dyanmic data structure.
d335 1
a335 2
wdb_close( wdbp )
struct rt_wdb	*wdbp;
d339 5
a343 6
	if( wdbp->type == RT_WDB_TYPE_FILE )  {
		fclose( wdbp->fp );
	} else {
		/* db_i is use counted */
		db_close( wdbp->dbip );
	}
@


1.20
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb.c,v 1.19 2000/06/30 15:27:09 pjt Exp $ (ARL)";
a32 1
#include "db.h"
a54 1
	db_close(dbip);
d63 2
d104 1
d159 20
d182 1
a182 9
		{
			union record	*rec;

			/* v4: Depends on solid names always being in the same place */
			rec = (union record *)ep->ext_buf;
			NAMEMOVE( name, rec->s.s_name );
		}

		if( fwrite( ep->ext_buf, ep->ext_nbytes, 1, wdbp->fp ) != 1 )  {
a238 7
		/* Stash name into external representation */
		if( db_wrap_v4_external( ep, ep, dp ) < 0 )  {
			bu_log("wdb_export_external(%s): db_wrap_v4_external error\n",
				name );
			return -4;
		}

a254 8
		/* Stash name into external representation */
		if( db_wrap_v4_external( ep, ep, dp ) < 0 )  {
			bu_log("wdb_export_external(%s): db_wrap_v4_external error\n",
				name );
			bu_free_external( ep );
			return -4;
		}

d292 1
d294 16
a309 5
	if( rt_functab[id].ft_export( &ext, &intern, local2mm, wdbp->dbip ) < 0 )  {
		bu_log("wdb_export(%s): solid export failure\n",
			name );
		bu_free_external( &ext );
		return(-2);				/* FAIL */
@


1.19
log
@Changed ID_MAXIMUM to ID_MAX_SOLID
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb.c,v 1.18 2000/06/29 18:20:56 mike Exp $ (ARL)";
@


1.18
log
@
Changed from db_free_external() to bu_free_external()
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb.c,v 1.17 2000/05/31 20:49:26 mike Exp $ (ARL)";
d285 1
a285 1
	if( (id <= 0 || id > ID_MAXIMUM) && id != ID_COMBINATION )  {
@


1.17
log
@
Track region and combination flags.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb.c,v 1.16 2000/01/03 21:44:08 bparker Exp $ (ARL)";
d242 1
a242 1
				db_free_external( ep );
d253 1
a253 1
			db_free_external( ep );
d298 1
a298 1
		db_free_external( &ext );
d304 1
a304 1
	db_free_external( &ext );
@


1.16
log
@*- now using bu_list magic because "struct wdb_obj" was merged
   into "struct rt_wdb"
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb.c,v 1.15 1999/12/30 02:48:01 mike Exp $ (ARL)";
d188 1
d220 1
a220 1
		if( (dp = db_diradd( wdbp->dbip, name, -1L, 0, 0, NULL )) == DIR_NULL )  {
d239 1
a239 1
			if( (dp = db_diradd( wdbp->dbip, name, -1L, 0, 0, NULL )) == DIR_NULL )  {
d245 2
@


1.15
log
@
Moved db_flags_internal() into db_alloc.c
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb.c,v 1.14 1999/12/29 23:23:11 mike Exp $ (ARL)";
d62 1
a62 1
	wdbp->magic = RT_WDB_MAGIC;
d101 1
a101 1
	wdbp->magic = RT_WDB_MAGIC;
@


1.14
log
@
db_scan() got a client_data argument, which
db_diradd() needed to learn to ignore.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb.c,v 1.13 1999/11/26 22:13:39 mike Exp $ (ARL)";
a107 27
}

/* XXX move to another module.  db_alloc(), probably. */
/*
 *			D B _ F L A G S _ I N T E R N A L
 *
 *  Given the internal form of a database object,
 *  return the appropriate 'flags' word for stashing in the
 *  in-memory directory of objects.
 */
int
db_flags_internal( intern )
CONST struct rt_db_internal	*intern;
{
	CONST struct rt_comb_internal	*comb;

	RT_CK_DB_INTERNAL(intern);

	if( intern->idb_type != ID_COMBINATION )
		return DIR_SOLID;

	comb = (struct rt_comb_internal *)intern->idb_ptr;
	RT_CK_COMB(comb);

	if( comb->region_flag )
		return DIR_COMB | DIR_REGION;
	return DIR_COMB;
@


1.13
log
@
Fixed CONST arg error
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb.c,v 1.12 1999/06/03 01:22:49 mike Exp $ (ARL)";
d210 1
a210 1
		    (dp = db_diradd( wdbp->dbip, name, -1L, 0, flags )) == DIR_NULL )  {
d228 1
a228 1
		if( (dp = db_diradd( wdbp->dbip, name, -1L, 0, flags )) == DIR_NULL )  {
d246 1
a246 1
		if( (dp = db_diradd( wdbp->dbip, name, -1L, 0, 0 )) == DIR_NULL )  {
d265 1
a265 1
			if( (dp = db_diradd( wdbp->dbip, name, -1L, 0, 0 )) == DIR_NULL )  {
@


1.12
log
@
sed4
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/wdb.c,v 1.11 1998/05/12 17:44:20 mike Exp $ (ARL)";
d141 1
d150 1
a150 1
CONST struct rt_db_internal	*internp;
@


1.11
log
@Added ".inmem dump" directive to Tcl interface,
to write the current state of a database out to a file.
Added db_dump() as underlying C implementation.
Added wdb_export_external() for a clean path out via LIBWDB.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/wdb.c,v 1.10 1998/03/26 07:37:55 mike Exp mike $ (ARL)";
d61 1
a61 1
	GETSTRUCT(wdbp, rt_wdb);
d100 1
a100 1
	GETSTRUCT(wdbp, rt_wdb);
d305 1
a305 1
	struct rt_external	ext;
d309 1
a309 1
		rt_log("wdb_export(%s): id=%d bad\n",
d324 1
a324 1
	RT_CK_EXTERNAL( &ext );
@


1.10
log
@Honors dbi_count use-count protocol.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/wdb.c,v 1.9 1998/03/19 15:57:01 jra Exp mike $ (ARL)";
d44 1
d52 1
d54 5
a58 1
	if( (fp = fopen( filename, "wb" )) == NULL )
d165 1
a165 1
 *			W D B _ E X P O R T
d167 1
a167 1
 *  The caller must free "gp".
d174 5
a178 6
wdb_export( wdbp, name, gp, id, local2mm )
struct rt_wdb	*wdbp;
char		*name;
genptr_t	gp;
int		id;
double		local2mm;
a179 2
	struct rt_db_internal	intern;
	struct rt_external	ext;
a180 19
	int			flags;

	if( (id <= 0 || id > ID_MAXIMUM) && id != ID_COMBINATION )  {
		rt_log("wdb_export(%s): id=%d bad\n",
			name, id );
		return(-1);
	}

	RT_INIT_DB_INTERNAL( &intern );
	intern.idb_type = id;
	intern.idb_ptr = gp;

	if( rt_functab[id].ft_export( &ext, &intern, local2mm, wdbp->dbip ) < 0 )  {
		bu_log("wdb_export(%s): solid export failure\n",
			name );
		db_free_external( &ext );
		return(-2);				/* FAIL */
	}
	RT_CK_EXTERNAL( &ext );
d182 2
d191 1
a191 1
			rec = (union record *)ext.ext_buf;
d195 2
a196 2
		if( fwrite( ext.ext_buf, ext.ext_nbytes, 1, wdbp->fp ) != 1 )  {
			bu_log("wdb_export(%s): fwrite error\n",
a197 1
			db_free_external( &ext );
d204 1
a204 1
			bu_log("wdb_export(%s): read-only database, write aborted\n");
a206 1
		flags = db_flags_internal( &intern );
d210 1
a210 1
			bu_log("wdb_export(%s): db_diradd error\n",
a211 1
			db_free_external( &ext );
d214 2
a215 2
		if( db_put_external( &ext, dp, wdbp->dbip ) < 0 )  {
			bu_log("wdb_export(%s): db_put_external error\n",
a216 1
			db_free_external( &ext );
d223 1
a223 1
			bu_log("wdb_export(%s): read-only database, write aborted\n");
a225 1
		flags = db_flags_internal( &intern );
d228 1
a228 1
			bu_log("wdb_export(%s): db_diradd error\n",
a229 1
			db_free_external( &ext );
d232 2
a233 2
		if( db_put_external( &ext, dp, wdbp->dbip ) < 0 )  {
			bu_log("wdb_export(%s): db_put_external error\n",
a234 1
			db_free_external( &ext );
d241 1
a241 1
			bu_log("wdb_export(%s): ERROR, that name is already in use, and APPEND_ONLY mode has been specified.\n",
a242 1
			db_free_external( &ext );
d246 1
a246 1
			bu_log("wdb_export(%s): db_diradd error\n",
a247 1
			db_free_external( &ext );
d252 2
a253 2
		if( db_wrap_v4_external( &ext, &ext, dp ) < 0 )  {
			bu_log("wdb_export(%s): db_wrap_v4_external error\n",
a254 1
			db_free_external( &ext );
d258 2
a259 2
		db_inmem( dp, &ext, db_flags_internal(&intern) );
		/* ext->buf has been taken; extra free call is harmless */
d265 1
a265 1
				bu_log("wdb_export(%s): db_diradd error\n",
d267 1
a267 1
				db_free_external( &ext );
d273 2
a274 2
		if( db_wrap_v4_external( &ext, &ext, dp ) < 0 )  {
			bu_log("wdb_export(%s): db_wrap_v4_external error\n",
d276 1
a276 1
			db_free_external( &ext );
d280 2
a281 2
		db_inmem( dp, &ext, db_flags_internal(&intern) );
		/* ext->buf has been taken; extra free call is harmless */
d284 43
d328 1
a328 1
	return(0);
d345 2
a346 8
		/* dbip */
		/*
		 *  All these uses reference an existing dbip that
		 *  somebody else opened with db_open().
		 *  Since the db_i structure isn't use counted,
		 *  just walk away from it here, and allow caller to
		 *  free it in their own good time.
		 */
@


1.9
log
@Cahnged to new calling sequence for ft_import and ft_export.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/wdb.c,v 1.8 1998/01/28 06:31:13 mike Exp jra $ (ARL)";
d98 3
@


1.8
log
@Added wdb_import, for symmetry and simplicity.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/wdb.c,v 1.7 1997/06/25 04:43:13 mike Exp mike $ (ARL)";
d187 1
a187 1
	if( rt_functab[id].ft_export( &ext, &intern, local2mm ) < 0 )  {
@


1.7
log
@Added DB_DISK_APPEND_ONLY as a separate mode of operating.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/wdb.c,v 1.6 1997/06/25 03:00:48 mike Exp mike $ (ARL)";
d126 27
@


1.6
log
@Added wdb_close()
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/wdb.c,v 1.5 1997/06/24 19:56:37 mike Exp mike $ (ARL)";
a39 3
/* XXX move to raytrace.h */
#define RT_CK_WDB(_p)		BU_CKMAG( _p , RT_WDB_MAGIC , "rt_wdb" )

d67 3
a69 2
 *	RT_WDB_TYPE_DB_DISK		Add to on-disk database
 *	RT_WDB_TYPE_DB_INMEM		Add to in-memory database only
d87 2
a88 1
	if( mode == RT_WDB_TYPE_DB_DISK && dbip->dbi_read_only )  {
d193 23
a215 1
		/* If name already exists, temporary name will be generated */
a306 1

@


1.5
log
@Allow MGED to start up in read-only mode
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/wdb.c,v 1.4 1997/06/20 01:14:13 gdurf Exp mike $ (ARL)";
d40 3
d260 27
@


1.4
log
@Changed WDB_* defines to RT_WDB_*
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/wdb.c,v 1.3 1997/06/20 00:48:00 gdurf Exp gdurf $ (ARL)";
d88 1
a88 1
		bu_log("wdb_dbopen(%s) database is read-only, aborting\n",
a89 1
		return RT_WDB_NULL;
d186 4
@


1.3
log
@Moved struct rt_wdb and associated defines to raytrace.h
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/wdb.c,v 1.2 1997/03/12 17:16:26 mike Exp gdurf $ (ARL)";
d53 1
a53 1
		return WDB_NULL;
d56 2
a57 2
	wdbp->magic = WDB_MAGIC;
	wdbp->type = WDB_TYPE_FILE;
d67 3
a69 3
 *	WDB_TYPE_DB_DISK		Add to on-disk database
 *	WDB_TYPE_DB_INMEM		Add to in-memory database only
 *	WDB_TYPE_DB_INMEM_APPEND_ONLY	Ditto, but give errors if name in use.
d80 1
a80 1
	if( mode != WDB_TYPE_DB_DISK && mode != WDB_TYPE_DB_INMEM && mode != WDB_TYPE_DB_DISK )  {
d83 1
a83 1
		return WDB_NULL;
d86 1
a86 1
	if( mode == WDB_TYPE_DB_DISK && dbip->dbi_read_only )  {
d90 1
a90 1
		return WDB_NULL;
d94 1
a94 1
	wdbp->magic = WDB_MAGIC;
d169 1
a169 1
	case WDB_TYPE_FILE:
d186 1
a186 1
	case WDB_TYPE_DB_DISK:
d203 1
a203 1
	case WDB_TYPE_DB_INMEM_APPEND_ONLY:
d229 1
a229 1
	case WDB_TYPE_DB_INMEM:
@


1.2
log
@Missing return code
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/wdb.c,v 1.1 1997/02/05 04:39:44 mike Exp mike $ (ARL)";
a38 13

struct rt_wdb  {
	long		magic;
	int		type;
	FILE		*fp;
	struct db_i	*dbip;
};
#define	WDB_MAGIC	0x5f576462
#define WDB_NULL	((struct rt_wdb *)NULL)
#define WDB_TYPE_FILE			1
#define WDB_TYPE_DB_DISK		2
#define WDB_TYPE_DB_INMEM		3
#define WDB_TYPE_DB_INMEM_APPEND_ONLY	4
@


1.1
log
@Initial revision
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
d110 1
@
