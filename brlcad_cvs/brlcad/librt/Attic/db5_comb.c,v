head	11.45;
access;
symbols
	ansi-20040405-merged:11.43
	postmerge-20040405-ansi:11.43
	premerge-20040404-ansi:11.43
	postmerge-autoconf:11.43
	autoconf-freeze:11.43
	premerge-autoconf:11.43
	ansi-20040316-freeze:11.43
	postmerge-20040315-windows:11.43
	premerge-20040315-windows:11.43
	windows-20040315-freeze:11.43
	autoconf-20031203:11.43
	autoconf-20031202:11.43
	autoconf-branch:11.43.0.12
	phong-branch:11.43.0.10
	photonmap-branch:11.43.0.8
	rel-6-1-DP:11.43
	windows-branch:11.43.0.6
	rel-6-0-2:11.43
	ansi-branch:11.43.0.4
	rel-6-0-1-branch:11.43.0.2
	hartley-6-0-post:11.43
	hartley-6-0-pre:11.43
	rel-6-0-1:11.43
	rel-6-0:11.42
	offsite-5-3-pre:11.27;
locks; strict;
comment	@ * @;


11.45
date	2004.05.21.18.07.29;	author morrison;	state dead;
branches;
next	11.44;

11.44
date	2004.05.10.15.30.45;	author erikg;	state Exp;
branches;
next	11.43;

11.43
date	2002.08.05.16.16.15;	author jra;	state Exp;
branches;
next	11.42;

11.42
date	2002.03.04.12.31.28;	author jra;	state Exp;
branches;
next	11.41;

11.41
date	2002.01.18.17.19.00;	author butler;	state Exp;
branches;
next	11.40;

11.40
date	2002.01.16.20.29.14;	author butler;	state Exp;
branches;
next	11.39;

11.39
date	2001.10.02.19.24.28;	author jra;	state Exp;
branches;
next	11.38;

11.38
date	2001.09.27.14.20.53;	author jra;	state Exp;
branches;
next	11.37;

11.37
date	2001.08.28.18.00.10;	author jra;	state Exp;
branches;
next	11.36;

11.36
date	2001.08.28.14.25.47;	author jra;	state Exp;
branches;
next	11.35;

11.35
date	2001.08.27.14.57.49;	author jra;	state Exp;
branches;
next	11.34;

11.34
date	2001.08.20.20.24.59;	author jra;	state Exp;
branches;
next	11.33;

11.33
date	2001.08.01.17.18.39;	author bparker;	state Exp;
branches;
next	11.32;

11.32
date	2001.07.02.17.16.33;	author jra;	state Exp;
branches;
next	11.31;

11.31
date	2001.06.29.15.30.48;	author jra;	state Exp;
branches;
next	11.30;

11.30
date	2001.05.29.20.46.01;	author jra;	state Exp;
branches;
next	11.29;

11.29
date	2001.04.20.22.29.40;	author morrison;	state Exp;
branches;
next	11.28;

11.28
date	2001.03.20.16.09.07;	author jra;	state Exp;
branches;
next	11.27;

11.27
date	2000.12.21.21.34.12;	author jra;	state Exp;
branches;
next	11.26;

11.26
date	2000.09.08.05.54.40;	author mike;	state Exp;
branches;
next	11.25;

11.25
date	2000.08.21.02.02.29;	author butler;	state Exp;
branches;
next	11.24;

11.24
date	2000.08.01.12.54.30;	author jra;	state Exp;
branches;
next	11.23;

11.23
date	2000.07.24.22.36.49;	author mike;	state Exp;
branches;
next	11.22;

11.22
date	2000.07.21.13.43.32;	author jra;	state Exp;
branches;
next	11.21;

11.21
date	2000.07.11.05.29.21;	author mike;	state Exp;
branches;
next	11.20;

11.20
date	2000.07.11.05.09.17;	author mike;	state Exp;
branches;
next	11.19;

11.19
date	2000.07.11.03.37.19;	author mike;	state Exp;
branches;
next	11.18;

11.18
date	2000.07.11.03.04.26;	author mike;	state Exp;
branches;
next	11.17;

11.17
date	2000.07.10.23.01.26;	author mike;	state Exp;
branches;
next	11.16;

11.16
date	2000.06.30.19.23.11;	author mike;	state Exp;
branches;
next	11.15;

11.15
date	2000.06.30.17.24.37;	author mike;	state Exp;
branches;
next	11.14;

11.14
date	2000.06.30.15.51.50;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	2000.06.30.14.37.20;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	2000.06.29.20.06.44;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	2000.06.29.20.04.30;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	2000.06.29.18.24.55;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	2000.06.28.22.34.03;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	2000.06.28.21.47.40;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	2000.06.28.21.41.25;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	2000.06.28.20.33.13;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	2000.06.28.20.21.59;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	2000.06.28.15.06.09;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	2000.06.27.22.00.19;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	2000.06.27.21.05.56;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	2000.06.27.18.48.43;	author mike;	state Exp;
branches;
next	;


desc
@@


11.45
log
@moved to src/
@
text
@/*
 *			D B 5 _ C O M B . C
 *
 *  Handle import/export of combinations (union tree) in v5 format.
 *
 *  The on-disk record looks like this:
 *	width byte
 *	n matricies (only non-identity matricies stored).
 *	n leaves
 *	len of RPN expression.  (len=0 signals all-union expression)
 *	depth of stack
 *	Section 1:  matricies
 *	Section 2:  leaves
 *	Section 3:  (Optional) RPN expression.
 *
 *  Encoding of a matrix is (ELEMENTS_PER_MAT * SIZEOF_NETWORK_DOUBLE) bytes,
 *  in network order (big-Endian, IEEE double precision).
 *
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Status -
 *	Public Domain, Distribution Unlimited.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/db5_comb.c,v 11.44 2004/05/10 15:30:45 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "db5.h"
#include "raytrace.h"

#include "./debug.h"


struct db_tree_counter_state {
	long	magic;
	long	n_mat;			/* # leaves with non-identity matricies */
	long	n_leaf;			/* # leaf nodes */
	long	n_oper;			/* # operator nodes */
	long	leafbytes;		/* # bytes for name section */
	int	non_union_seen;		/* boolean, 1 = non-unions seen */
};
#define DB_TREE_COUNTER_STATE_MAGIC	0x64546373	/* dTcs */
#define DB_CK_TREE_COUNTER_STATE(_p)	BU_CKMAG(_p, DB_TREE_COUNTER_STATE_MAGIC, "db_tree_counter_state");

/*
 *			D B _ T R E E _ C O U N T E R
 *
 *  Count number of non-identity matricies,
 *  number of leaf nodes, number of operator nodes, etc.
 *
 *  Returns -
 *	maximum depth of stack needed to unpack this tree, if serialized.
 *
 *  Notes -
 *	We over-estimate the size of the width fields used for
 *	holding the matrix subscripts.
 *	The caller is responsible for correcting by saying:
 *		tcsp->leafbytes -= tcsp->n_leaf * (8 - db5_enc_len[wid]);
 */
long
db_tree_counter( const union tree *tp, struct db_tree_counter_state *tcsp )
{
	long	ldepth, rdepth;

	RT_CK_TREE(tp);
	DB_CK_TREE_COUNTER_STATE(tcsp);

	switch( tp->tr_op )  {
	case OP_DB_LEAF:
		tcsp->n_leaf++;
		if( tp->tr_l.tl_mat && !bn_mat_is_identity(tp->tr_l.tl_mat) )  tcsp->n_mat++;
		/* Over-estimate storage requirement for matrix # */
		tcsp->leafbytes += strlen(tp->tr_l.tl_name) + 1 + 8;
		return 1;

	case OP_NOT:
		/* Unary ops */
		tcsp->n_oper++;
		tcsp->non_union_seen = 1;
		return 1 + db_tree_counter( tp->tr_b.tb_left, tcsp );

	case OP_UNION:
		/* This node is known to be a binary op */
		tcsp->n_oper++;
		ldepth = db_tree_counter( tp->tr_b.tb_left, tcsp );
		rdepth = db_tree_counter( tp->tr_b.tb_right, tcsp );
		if( ldepth > rdepth )  return ldepth;
		return rdepth;

	case OP_INTERSECT:
	case OP_SUBTRACT:
	case OP_XOR:
		/* This node is known to be a binary op */
		tcsp->n_oper++;
		tcsp->non_union_seen = 1;
		ldepth = db_tree_counter( tp->tr_b.tb_left, tcsp );
		rdepth = db_tree_counter( tp->tr_b.tb_right, tcsp );
		if( ldepth > rdepth )  return ldepth;
		return rdepth;

	default:
		bu_log("db_tree_counter: bad op %d\n", tp->tr_op);
		bu_bomb("db_tree_counter\n");
		/* NOTREACHED */
	}
	/* NOTREACHED */
	return 0;
}

#define DB5COMB_TOKEN_LEAF		1
#define DB5COMB_TOKEN_UNION		2
#define DB5COMB_TOKEN_INTERSECT		3
#define DB5COMB_TOKEN_SUBTRACT		4
#define DB5COMB_TOKEN_XOR		5
#define DB5COMB_TOKEN_NOT		6

struct rt_comb_v5_serialize_state  {
	long		magic;
	long		mat_num;	/* current matrix number */
	long		nmat;		/* # matricies, total */
	unsigned char	*matp;
	unsigned char	*leafp;
	unsigned char	*exprp;
	int		wid;
};
#define RT_COMB_V5_SERIALIZE_STATE_MAGIC	0x43357373	/* C5ss */
#define RT_CK_COMB_V5_SERIALIZE_STATE(_p)	BU_CKMAG(_p, RT_COMB_V5_SERIALIZE_STATE_MAGIC, "rt_comb_v5_serialize_state")

/*
 *			R T _ C O M B _ V 5 _ S E R I A L I Z E
 *
 *  In one single pass through the tree, serialize out all three
 *  output sections at once.
 */
void
rt_comb_v5_serialize(
	const union tree	*tp,
	struct rt_comb_v5_serialize_state	*ssp)
{
	int	n;
	int	mi;

	RT_CK_TREE(tp);
	RT_CK_COMB_V5_SERIALIZE_STATE(ssp);

	switch( tp->tr_op )  {
	case OP_DB_LEAF:
		/*
		 *  Encoding of the leaf:
		 *	A null-terminated name string, and
		 *	the matrix subscript.  -1 == identity.
		 */
		n = strlen(tp->tr_l.tl_name) + 1;
		bcopy( tp->tr_l.tl_name, ssp->leafp, n );
		ssp->leafp += n;

		if( tp->tr_l.tl_mat && !bn_mat_is_identity(tp->tr_l.tl_mat) )
			mi = ssp->mat_num++;
		else
			mi = -1;
		BU_ASSERT_LONG( mi, <, ssp->nmat );
		ssp->leafp = db5_encode_length( ssp->leafp, mi, ssp->wid );

		/* Encoding of the matrix */
		if( mi > -1 )  {
			htond( ssp->matp,
				(const unsigned char *)tp->tr_l.tl_mat,
				ELEMENTS_PER_MAT );
			ssp->matp += ELEMENTS_PER_MAT * SIZEOF_NETWORK_DOUBLE;
		}

		/* Encoding of the "leaf" operator */
		if( ssp->exprp )
			*ssp->exprp++ = DB5COMB_TOKEN_LEAF;
		return;

	case OP_NOT:
		/* Unary ops */
		rt_comb_v5_serialize( tp->tr_b.tb_left, ssp );
		if( ssp->exprp )
			*ssp->exprp++ = DB5COMB_TOKEN_NOT;
		return;

	case OP_UNION:
		/* This node is known to be a binary op */
		rt_comb_v5_serialize( tp->tr_b.tb_left, ssp );
		rt_comb_v5_serialize( tp->tr_b.tb_right, ssp );
		if( ssp->exprp )
			*ssp->exprp++ = DB5COMB_TOKEN_UNION;
		return;
	case OP_INTERSECT:
		/* This node is known to be a binary op */
		rt_comb_v5_serialize( tp->tr_b.tb_left, ssp );
		rt_comb_v5_serialize( tp->tr_b.tb_right, ssp );
		if( ssp->exprp )
			*ssp->exprp++ = DB5COMB_TOKEN_INTERSECT;
		return;
	case OP_SUBTRACT:
		/* This node is known to be a binary op */
		rt_comb_v5_serialize( tp->tr_b.tb_left, ssp );
		rt_comb_v5_serialize( tp->tr_b.tb_right, ssp );
		if( ssp->exprp )
			*ssp->exprp++ = DB5COMB_TOKEN_SUBTRACT;
		return;
	case OP_XOR:
		/* This node is known to be a binary op */
		rt_comb_v5_serialize( tp->tr_b.tb_left, ssp );
		rt_comb_v5_serialize( tp->tr_b.tb_right, ssp );
		if( ssp->exprp )
			*ssp->exprp++ = DB5COMB_TOKEN_XOR;
		return;

	default:
		bu_log("rt_comb_v5_serialize: bad op %d\n", tp->tr_op);
		bu_bomb("rt_comb_v5_serialize\n");
	}
}

/*
 *			R T _ C O M B _ E X P O R T 5
 */
int
rt_comb_export5(
	struct bu_external		*ep,
	const struct rt_db_internal	*ip,
	double				local2mm,
	const struct db_i		*dbip,
	struct resource			*resp)
{
	struct rt_comb_internal	*comb;
	struct db_tree_counter_state		tcs;
	struct rt_comb_v5_serialize_state	ss;
	long	max_stack_depth;
	long	need;
	int	rpn_len = 0;	/* # items in RPN expression */
	int	wid;
	unsigned char	*cp;
	unsigned char	*leafp_end;
	struct bu_attribute_value_set *avsp;
	struct bu_vls	value;

	RT_CK_DB_INTERNAL( ip );
	RT_CK_RESOURCE(resp);

	if( ip->idb_type != ID_COMBINATION ) bu_bomb("rt_comb_export5() type not ID_COMBINATION");
	comb = (struct rt_comb_internal *)ip->idb_ptr;
	RT_CK_COMB(comb);

	/* First pass -- count number of non-identity matricies,
	 * number of leaf nodes, number of operator nodes.
	 */
	bzero( (char *)&tcs, sizeof(tcs) );
	tcs.magic = DB_TREE_COUNTER_STATE_MAGIC;
	if( comb->tree )
		max_stack_depth = db_tree_counter( comb->tree, &tcs );
	else
		max_stack_depth = 0;	/* some combinations have no tree */

	if( tcs.non_union_seen )  {
		/* RPN expression needs one byte for each leaf or operator node */
		rpn_len = tcs.n_leaf + tcs.n_oper;
	} else {
		rpn_len = 0;
	}

	wid = db5_select_length_encoding(
		tcs.n_mat | tcs.n_leaf | tcs.leafbytes |
		rpn_len | max_stack_depth );

	/* Apply correction factor to tcs.leafbytes now that we know 'wid'.
	 * Ignore the slight chance that a smaller 'wid' might now be possible.
	 */
	tcs.leafbytes -= tcs.n_leaf * (8 - db5_enc_len[wid]);

	/* Second pass -- determine amount of on-disk storage needed */
	need =  1 +			/* width code */
		db5_enc_len[wid] + 	/* size for nmatricies */
		db5_enc_len[wid] +	/* size for nleaves */
		db5_enc_len[wid] +	/* size for leafbytes */
		db5_enc_len[wid] +	/* size for len of RPN */
		db5_enc_len[wid] +	/* size for max_stack_depth */
		tcs.n_mat * (ELEMENTS_PER_MAT * SIZEOF_NETWORK_DOUBLE) +	/* sizeof matrix array */
		tcs.leafbytes +		/* size for leaf nodes */
		rpn_len;		/* storage for RPN expression */

	BU_INIT_EXTERNAL(ep);
	ep->ext_nbytes = need;
#if 0
	ep->ext_buf = bu_malloc( need, "rt_comb_export5 ext_buf" );
#else
	ep->ext_buf = bu_calloc( 1, need, "rt_comb_export5 ext_buf" );
#endif

	/* Build combination's on-disk header section */
	cp = (unsigned char *)ep->ext_buf;
	*cp++ = wid;
	cp = db5_encode_length( cp, tcs.n_mat, wid );
	cp = db5_encode_length( cp, tcs.n_leaf, wid );
	cp = db5_encode_length( cp, tcs.leafbytes, wid );
	cp = db5_encode_length( cp, rpn_len, wid );
	cp = db5_encode_length( cp, max_stack_depth, wid );

	/*
	 *  The output format has three sections:
	 *	Section 1:  matricies
	 *	Section 2:  leaf nodes
	 *	Section 3:  Optional RPN expression
	 *
	 *  We have pre-computed the exact size of all three sections,
	 *  so they can all be searialized together in one pass.
	 *  Establish pointers to the start of each section.
	 */
	ss.magic = RT_COMB_V5_SERIALIZE_STATE_MAGIC;
	ss.wid = wid;
	ss.mat_num = 0;
	ss.nmat = tcs.n_mat;
	ss.matp = cp;
	ss.leafp = cp + tcs.n_mat * (ELEMENTS_PER_MAT * SIZEOF_NETWORK_DOUBLE);
	leafp_end = ss.leafp + tcs.leafbytes;
	if( rpn_len )
		ss.exprp = leafp_end;
	else
		ss.exprp = NULL;

	if( comb->tree )
		rt_comb_v5_serialize( comb->tree, &ss );

	BU_ASSERT_LONG( ss.mat_num, ==, tcs.n_mat );
	BU_ASSERT_PTR( ss.matp, ==, cp + tcs.n_mat * (ELEMENTS_PER_MAT * SIZEOF_NETWORK_DOUBLE) );
	BU_ASSERT_PTR( ss.leafp, ==, leafp_end );
	if( rpn_len )
		BU_ASSERT_PTR( ss.exprp, <=, ((unsigned char *)ep->ext_buf) + ep->ext_nbytes );

	/* Encode all the other stuff as attributes. */
	bu_vls_init( &value );
	/* WARNING:  We remove const from the ip pointer!!! */
	avsp = (struct bu_attribute_value_set *)&ip->idb_avs;
	if( avsp->magic != BU_AVS_MAGIC )
		bu_avs_init( avsp, 32, "rt_comb v5 attributes" );
	if( comb->region_flag )  {
		/* Presence of this attribute means this comb is a region. */
		/* Current code values are 0, 1, and 2; all are regions.
		 * See raytrace.h for meanings of different values
		 */
		bu_vls_trunc( &value, 0 );
		switch (comb->is_fastgen) {
		case REGION_FASTGEN_PLATE:
		    bu_vls_printf(&value, "P");
		    break;
		case REGION_FASTGEN_VOLUME:
		    bu_vls_printf(&value, "V");
		    break;
		case REGION_NON_FASTGEN: /* fallthrough */
		default:
		    bu_vls_printf(&value, "R");
		    break;
		}
		bu_avs_add_vls( avsp, "region", &value );
	} else
		bu_avs_remove( avsp, "region" );

	if( comb->inherit )
		bu_avs_add( avsp, "inherit", "1" );
	else
		bu_avs_remove( avsp, "inherit" );

	if( comb->rgb_valid )  {
		bu_vls_trunc( &value, 0 );
		bu_vls_printf( &value, "%d/%d/%d", V3ARGS(comb->rgb) );
		bu_avs_add_vls( avsp, "rgb", &value );
	} else
		bu_avs_remove( avsp, "rgb" );

	/* optical shader string goes out in Tcl format */
	if( bu_vls_strlen( &comb->shader ) > 0 )
		bu_avs_add_vls( avsp, "oshader", &comb->shader );
	else
		bu_avs_remove( avsp, "oshader" );

#if 0
	if( bu_vls_strlen( &comb->material ) > 0 )
		bu_avs_add_vls( avsp, "material", &comb->material );
	else
		bu_avs_remove( avsp, "material" );
#endif
#if 0
	if( comb->temperature > 0 )  {
		bu_vls_trunc( &value, 0 );
		bu_vls_printf( &value, "%f", comb->temperature );
		bu_avs_add_vls( avsp, "temp", &value );
	} else
		bu_avs_remove( avsp, "temp" );
#endif
	/* GIFT compatability */
	if( comb->region_id != 0 )  {
	    bu_vls_trunc( &value, 0 );
	    bu_vls_printf( &value, "%d", comb->region_id );
	    bu_avs_add_vls( avsp, "region_id", &value );
	} else
	    bu_avs_remove( avsp, "region_id" );

	if( comb->aircode != 0 )  {
	    bu_vls_trunc( &value, 0 );
	    bu_vls_printf( &value, "%d", comb->aircode );
	    bu_avs_add_vls( avsp, "aircode", &value );
	} else
	    bu_avs_remove( avsp, "aircode" );

	if( comb->GIFTmater != 0 )  {
	    bu_vls_trunc( &value, 0 );
	    bu_vls_printf( &value, "%d", comb->GIFTmater );
	    bu_avs_add_vls( avsp, "material_id", &value );
	} else
	    bu_avs_remove( avsp, "material_id" );

	if( comb->los != 0 )  {
	    bu_vls_trunc( &value, 0 );
	    bu_vls_printf( &value, "%d", comb->los );
	    bu_avs_add_vls( avsp, "los", &value );
	} else
	    bu_avs_remove( avsp, "los" );

	bu_vls_free( &value );
	return 0;	/* OK */
}

/*
 *			R T _ C O M B _ I M P O R T 5
 *
 *  Read a combination object in v5 external (on-disk) format,
 *  and convert it into the internal format described in h/rtgeom.h
 *
 *  This is an unusual conversion, because some of the data is taken
 *  from attributes, not just from the object body.
 *  By the time this is called, the attributes will already have been
 *  cracked into ip->idb_avs, we get the attributes from there.
 *
 *  Returns -
 *	0	OK
 *	-1	FAIL
 */
int
rt_comb_import5(
	struct rt_db_internal	*ip,
	const struct bu_external *ep,
	const mat_t		mat,
	const struct db_i	*dbip,
	struct resource		*resp,
	const int		minor_type)
{
	struct rt_comb_internal	*comb;
	unsigned char	*cp;
	int		wid;
	long		nmat, nleaf, rpn_len, max_stack_depth;
	long		leafbytes;
	unsigned char	*matp;
	unsigned char	*leafp;
	unsigned char	*leafp_end;
	unsigned char	*exprp;
#define MAX_V5_STACK	8000
	union tree	*stack[MAX_V5_STACK];
	union tree	**sp;			/* stack pointer */
	const char	*ap;
	int		i;

	RT_CK_DB_INTERNAL( ip );
	BU_CK_EXTERNAL(ep);
	RT_CK_DBI(dbip);
	RT_CK_RESOURCE(resp);

	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_COMBINATION;
	ip->idb_meth = &rt_functab[ID_COMBINATION];
	BU_GETSTRUCT( comb, rt_comb_internal );
	ip->idb_ptr = (genptr_t)comb;
	comb->magic = RT_COMB_MAGIC;
	bu_vls_init( &comb->shader );
	bu_vls_init( &comb->material );
	comb->temperature = -1;

	cp = ep->ext_buf;
	wid = *cp++;
	cp += db5_decode_length( &nmat, cp, wid );
	cp += db5_decode_length( &nleaf, cp, wid );
	cp += db5_decode_length( &leafbytes, cp, wid );
	cp += db5_decode_length( &rpn_len, cp, wid );
	cp += db5_decode_length( &max_stack_depth, cp, wid );
	matp = cp;
	leafp = cp + nmat * (ELEMENTS_PER_MAT * SIZEOF_NETWORK_DOUBLE);
	exprp = leafp + leafbytes;
	leafp_end = exprp;

	if( rpn_len == 0 )  {
		/* This tree is all union operators, import it as a balanced tree */

		int	i;
		struct bu_ptbl *tbl1, *tbl2;

		tbl1 = (struct bu_ptbl *)bu_malloc( sizeof( struct bu_ptbl ), "rt_comb_import5: tbl1" );
		tbl2 = (struct bu_ptbl *)bu_malloc( sizeof( struct bu_ptbl ), "rt_comb_import5: tbl2" );

		/* insert all the leaf nodes into a bu_ptbl */
		bu_ptbl_init( tbl1, nleaf, "rt_comb_import5: tbl" );
		for( i = nleaf-1; i >= 0; i-- )  {
			union tree	*tp;
			long		mi;

			RT_GET_TREE( tp, resp );
			tp->tr_l.magic = RT_TREE_MAGIC;
			tp->tr_l.tl_op = OP_DB_LEAF;
			tp->tr_l.tl_name = bu_strdup( (const char *)leafp );
			leafp += strlen( (const char *)leafp) + 1;

			/* Get matrix index */
			mi = 4095;			/* sanity */
			leafp += db5_decode_signed( &mi, leafp, wid );

			if( mi < 0 )  {
				/* Signal identity matrix */
				if( !mat || bn_mat_is_identity( mat ) ) {
					tp->tr_l.tl_mat = (matp_t)NULL;
				} else
					tp->tr_l.tl_mat = bn_mat_dup( mat );
			} else {
				mat_t diskmat;

				/* Unpack indicated matrix mi */
				BU_ASSERT_LONG( mi, <, nmat );
				ntohd( (unsigned char *)diskmat,
					&matp[mi*ELEMENTS_PER_MAT*SIZEOF_NETWORK_DOUBLE],
					ELEMENTS_PER_MAT);
				if( !mat || bn_mat_is_identity( mat ) ) {
					tp->tr_l.tl_mat = bn_mat_dup( diskmat );
				} else {
					tp->tr_l.tl_mat = (matp_t)bu_malloc(
						sizeof(mat_t), "v5comb mat");
					bn_mat_mul( tp->tr_l.tl_mat, mat, diskmat );
					if( bn_mat_is_identity( tp->tr_l.tl_mat ) ) {
						bu_free( (char *)tp->tr_l.tl_mat,"tl_mat");
						tp->tr_l.tl_mat = (matp_t)NULL;
					}
				}
			}
			bu_ptbl_ins( tbl1, (long *)tp );
		}

		/* use a second bu_ptbl to help build a balanced tree
		 *  1 - pick off pairs of pointers from tbl1
		 *  2 - make a small tree thats unions the pair
		 *  3 - insert that tree into tbl2
		 *  4 - insert any leftover pointer from tbl1 into tbl2
		 *  5 - swap tbl1 and tbl2
		 *  6 - truncate tbl2 and go to step 1
		 * stop when tbl2 has less than 2 members
		 */
		bu_ptbl_init( tbl2, (BU_PTBL_LEN( tbl1) + 1)/2, "rt_comb_import5: tbl1" );
		while( 1 ) {
			struct bu_ptbl *tmp;

			for( i=0 ; i<BU_PTBL_LEN( tbl1 ) ; i += 2 ) {
				union tree *tp1, *tp2, *unionp;
				int j;

				j = i + 1;
				tp1 = (union tree *)BU_PTBL_GET( tbl1, i );
				if( j < BU_PTBL_LEN( tbl1 ) ) {
					tp2 = (union tree *)BU_PTBL_GET( tbl1, j );
				} else {
					tp2 = (union tree *)NULL;
				}

				if( tp2 ) {
					RT_GET_TREE( unionp, resp );
					unionp->tr_b.magic = RT_TREE_MAGIC;
					unionp->tr_b.tb_op = OP_UNION;
					unionp->tr_b.tb_left = tp1;
					unionp->tr_b.tb_right = tp2;
					bu_ptbl_ins( tbl2, (long *)unionp );
				} else {
					bu_ptbl_ins( tbl2, (long *)tp1 );
				}

			}

			if( BU_PTBL_LEN( tbl2 ) == 0 ) {
				comb->tree = (union tree *)NULL;
				bu_ptbl_free( tbl1 );
				bu_ptbl_free( tbl2 );
				bu_free( (char *)tbl1, "rt_comb_import5: tbl1" );
				bu_free( (char *)tbl2, "rt_comb_import5: tbl2" );
				break;
			} else if( BU_PTBL_LEN( tbl2 ) == 1 ) {
				comb->tree = (union tree *)BU_PTBL_GET( tbl2, 0 );
				bu_ptbl_free( tbl1 );
				bu_ptbl_free( tbl2 );
				bu_free( (char *)tbl1, "rt_comb_import5: tbl1" );
				bu_free( (char *)tbl2, "rt_comb_import5: tbl2" );
				break;
			}

			tmp = tbl2;
			tbl2 = tbl1;
			tbl1 = tmp;
			bu_ptbl_trunc( tbl2, 0 );
		}
		BU_ASSERT_PTR( leafp, ==, leafp_end );
		goto finish;
	}

	/*
	 *  Bring the RPN expression back from the disk,
	 *  populating leaves and matricies in the order they are encountered.
	 */
	if( max_stack_depth > MAX_V5_STACK )  {
		bu_log("Combination needs stack depth %d, only have %d, aborted\n",
			max_stack_depth, MAX_V5_STACK);
		return -1;
	}
	sp = &stack[0];

	for( i=0; i < rpn_len; i++,exprp++ )  {
		union tree	*tp;
		long		mi;

		RT_GET_TREE( tp, resp );
		tp->tr_b.magic = RT_TREE_MAGIC;

		switch( *exprp )  {
		case DB5COMB_TOKEN_LEAF:
			tp->tr_l.tl_op = OP_DB_LEAF;
			tp->tr_l.tl_name = bu_strdup( (const char *)leafp );
			leafp += strlen( (const char *)leafp) + 1;

			/* Get matrix index */
			mi = 4095;			/* sanity */
			leafp += db5_decode_signed( &mi, leafp, wid );

			if( mi < 0 )  {
				/* Signal identity matrix */
				if( !mat || bn_mat_is_identity( mat ) ) {
					tp->tr_l.tl_mat = (matp_t)NULL;
				} else
					tp->tr_l.tl_mat = bn_mat_dup( mat );
			} else {
				mat_t diskmat;

				/* Unpack indicated matrix mi */
				BU_ASSERT_LONG( mi, <, nmat );
				ntohd( (unsigned char *)diskmat,
					&matp[mi*ELEMENTS_PER_MAT*SIZEOF_NETWORK_DOUBLE],
					ELEMENTS_PER_MAT);
				if( !mat || bn_mat_is_identity( mat ) ) {
					tp->tr_l.tl_mat = bn_mat_dup( diskmat );
				} else {
					tp->tr_l.tl_mat = (matp_t)bu_malloc(
						sizeof(mat_t), "v5comb mat");
					bn_mat_mul( tp->tr_l.tl_mat, mat, diskmat );
					if( bn_mat_is_identity( tp->tr_l.tl_mat ) ) {
						bu_free( (char *)tp->tr_l.tl_mat,"tl_mat");
						tp->tr_l.tl_mat = (matp_t)NULL;
					}
				}
			}
			break;

		case DB5COMB_TOKEN_UNION:
		case DB5COMB_TOKEN_INTERSECT:
		case DB5COMB_TOKEN_SUBTRACT:
		case DB5COMB_TOKEN_XOR:
			/* These are all binary operators */
			tp->tr_b.tb_regionp = REGION_NULL;
			tp->tr_b.tb_right = *--sp;
			RT_CK_TREE(tp->tr_b.tb_right);
			tp->tr_b.tb_left = *--sp;
			RT_CK_TREE(tp->tr_b.tb_left);
			switch( *exprp )  {
			case DB5COMB_TOKEN_UNION:
				tp->tr_b.tb_op = OP_UNION;
				break;
			case DB5COMB_TOKEN_INTERSECT:
				tp->tr_b.tb_op = OP_INTERSECT;
				break;
			case DB5COMB_TOKEN_SUBTRACT:
				tp->tr_b.tb_op = OP_SUBTRACT;
				break;
			case DB5COMB_TOKEN_XOR:
				tp->tr_b.tb_op = OP_XOR;
				break;
			}
			break;

		case DB5COMB_TOKEN_NOT:
			/* This is a unary operator */
			tp->tr_b.tb_regionp = REGION_NULL;
			tp->tr_b.tb_left = *--sp;
			RT_CK_TREE(tp->tr_b.tb_left);
			tp->tr_b.tb_right = TREE_NULL;
			tp->tr_b.tb_op = OP_NOT;
			break;
		default:
			bu_log("rt_comb_import5() unknown RPN expression token=%d, import aborted\n", *exprp);
			return -1;
		}

		/* Push this node on the stack */
		*sp++ = tp;
	}
	BU_ASSERT_PTR( leafp, ==, leafp_end );

	/* There should only be one thing left on the stack, the result */
	BU_ASSERT_PTR( sp, ==, &stack[1] );

	comb->tree = stack[0];
	RT_CK_TREE(comb->tree);

finish:
	if( ip->idb_avs.magic != BU_AVS_MAGIC )  return 0;	/* OK */

	/* Unpack the attributes */
	comb->rgb_valid = 0;
	if( (ap = bu_avs_get( &ip->idb_avs, "rgb" )) != NULL )  {
		int	ibuf[3];
		if( sscanf( ap, "%d/%d/%d", ibuf, ibuf+1, ibuf+2 ) == 3 )  {
			VMOVE( comb->rgb, ibuf );
			comb->rgb_valid = 1;
		} else {
			bu_log("unable to parse 'rgb' attribute '%s'\n", ap);
		}
	}
	if( (ap = bu_avs_get( &ip->idb_avs, "inherit" )) != NULL ) {
		comb->inherit = atoi( ap );
	}
	if( (ap = bu_avs_get( &ip->idb_avs, "region" )) != NULL )  {
	    /* Presence of this attribute implies it is a region */
	    comb->region_flag = 1;

	    /* Determine if this is a FASTGEN region */
	    switch (*ap) {
	    case 'V' : /* fallthrough */
	    case '2' :
		comb->is_fastgen = REGION_FASTGEN_VOLUME;
		break;
	    case 'P' : /* fallthrough */
	    case '1' :
		comb->is_fastgen = REGION_FASTGEN_PLATE;
		break;
	    case 'R' : /* fallthrough */
	    case '0' :
		comb->is_fastgen = REGION_NON_FASTGEN;
		break;
	    default:
		bu_log("unable to parse 'region' attribute '%s'\n", ap);
		break;
	    }

	    /* get the other GIFT "region" attributes */
	    if( (ap = bu_avs_get( &ip->idb_avs, "region_id" )) != NULL )  {
		comb->region_id = atoi( ap );
	    }
	    if( (ap = bu_avs_get( &ip->idb_avs, "aircode" )) != NULL )  {
		comb->aircode = atoi( ap );
	    }
	    if( (ap = bu_avs_get( &ip->idb_avs, "material_id" )) != NULL )  {
		comb->GIFTmater = atoi( ap );
#if 0
		bu_vls_printf( &comb->material, "gift%d", comb->GIFTmater );
#endif
	    }
	    if( (ap = bu_avs_get( &ip->idb_avs, "los" )) != NULL )  {
		comb->los = atoi( ap );
	    }
	}
	if( (ap = bu_avs_get( &ip->idb_avs, "oshader" )) != NULL )  {
		bu_vls_strcat( &comb->shader, ap );
	}

	return 0;			/* OK */
}
@


11.44
log
@change conf.h to a wrapped config.h
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/librt/db5_comb.c,v 11.43 2002/08/05 16:16:15 jra Exp $ (ARL)";
@


11.43
log
@ifdef'd out temperature code in rt_comb_export5()
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_comb.c,v 11.42 2002/03/04 12:31:28 jra Exp $ (ARL)";
d33 5
a37 1
#include "conf.h"
@


11.42
log
@Combination import noe bui;ds balanced trees for combinations which are all unions
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_comb.c,v 11.41 2002/01/18 17:19:00 butler Exp $ (ARL)";
d404 1
a404 1

d411 1
a411 1

@


11.41
log
@mods to allow "pre-release" V5 databases with the integer "region" attribute
to continue to work.
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_comb.c,v 11.40 2002/01/16 20:29:14 butler Exp $ (ARL)";
d512 2
d515 7
d562 27
d590 27
a616 10
			if( comb->tree == TREE_NULL )  {
				comb->tree = tp;
			} else {
				union tree	*unionp;
				RT_GET_TREE( unionp, resp );
				unionp->tr_b.magic = RT_TREE_MAGIC;
				unionp->tr_b.tb_op = OP_UNION;
				unionp->tr_b.tb_left = comb->tree;
				unionp->tr_b.tb_right = tp;
				comb->tree = unionp;
d618 5
@


11.40
log
@Changes to combination Regular/Plate/Volume disk format in V5 databases.
Removed auto-generated "material" attribute from regions.
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_comb.c,v 11.39 2001/10/02 19:24:28 jra Exp $ (ARL)";
d366 2
a367 1
		    bu_vls_printf(&value, "P");		break;
d369 2
a370 1
		    bu_vls_printf(&value, "V");		break;
d373 2
a374 1
		    bu_vls_printf(&value, "R");		break;
d698 3
a700 1
	    if (! strcmp("V", ap)) {
d702 3
a704 1
	    } else if (! strcmp("P", ap)) {
d706 3
a708 1
	    } else if (! strcmp("R", ap)) {
d710 2
a711 1
	    } else {
d713 1
@


11.39
log
@Routines were not setting idb_major_type in the internal structure
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_comb.c,v 11.38 2001/09/27 14:20:53 jra Exp $ (ARL)";
d360 3
a362 1
		/* Current code values are 0, 1, and 2; all are regions. */
d364 9
a372 1
		bu_vls_printf( &value, "%d", comb->is_fastgen );
d395 1
d400 1
d411 3
a413 3
		bu_vls_trunc( &value, 0 );
		bu_vls_printf( &value, "%d", comb->region_id );
		bu_avs_add_vls( avsp, "region_id", &value );
d415 1
a415 1
		bu_avs_remove( avsp, "region_id" );
d418 3
a420 3
		bu_vls_trunc( &value, 0 );
		bu_vls_printf( &value, "%d", comb->aircode );
		bu_avs_add_vls( avsp, "aircode", &value );
d422 1
a422 1
		bu_avs_remove( avsp, "aircode" );
d425 3
a427 3
		bu_vls_trunc( &value, 0 );
		bu_vls_printf( &value, "%d", comb->GIFTmater );
		bu_avs_add_vls( avsp, "giftmater", &value );
d429 1
a429 1
		bu_avs_remove( avsp, "giftmater" );
d432 3
a434 3
		bu_vls_trunc( &value, 0 );
		bu_vls_printf( &value, "%d", comb->los );
		bu_avs_add_vls( avsp, "los", &value );
d436 1
a436 1
		bu_avs_remove( avsp, "los" );
d691 30
a720 24
		int	ibuf[1];
		if( sscanf( ap, "%d", ibuf ) == 1 )  {
			/* Presence of this attribute implies it is a region  */
			comb->region_flag = 1;
			/* Value of this parameter is the FASTGEN code */
			comb->is_fastgen = ibuf[0];

			/* get the other "region" attributes */
			if( (ap = bu_avs_get( &ip->idb_avs, "region_id" )) != NULL )  {
				comb->region_id = atoi( ap );
			}
			if( (ap = bu_avs_get( &ip->idb_avs, "aircode" )) != NULL )  {
				comb->aircode = atoi( ap );
			}
			if( (ap = bu_avs_get( &ip->idb_avs, "giftmater" )) != NULL )  {
				comb->GIFTmater = atoi( ap );
				bu_vls_printf( &comb->material, "gift%d", comb->GIFTmater );
			}
			if( (ap = bu_avs_get( &ip->idb_avs, "los" )) != NULL )  {
				comb->los = atoi( ap );
			}
		} else {
			bu_log("unable to parse 'region' attribute '%s'\n", ap);
		}
@


11.38
log
@Yet another correction to import5() to handle null matrices
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_comb.c,v 11.37 2001/08/28 18:00:10 jra Exp $ (ARL)";
d474 1
@


11.37
log
@rt_comb_export5() now is careful to eliminate attributes that are not set.
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_comb.c,v 11.36 2001/08/28 14:25:47 jra Exp $ (ARL)";
a521 2
				tp->tr_l.tl_mat = (matp_t)bu_malloc(
					sizeof(mat_t), "v5comb mat");
d525 10
a534 4
				bn_mat_mul( tp->tr_l.tl_mat, mat, diskmat );
				if( bn_mat_is_identity( tp->tr_l.tl_mat ) ) {
					bu_free( (char *)tp->tr_l.tl_mat,"tl_mat");
					tp->tr_l.tl_mat = (matp_t)NULL;
a592 2
				tp->tr_l.tl_mat = (matp_t)bu_malloc(
					sizeof(mat_t), "v5comb mat");
d596 10
a605 4
				bn_mat_mul( tp->tr_l.tl_mat, mat, diskmat );
				if( bn_mat_is_identity( tp->tr_l.tl_mat ) ) {
					bu_free( (char *)tp->tr_l.tl_mat,"tl_mat");
					tp->tr_l.tl_mat = (matp_t)NULL;
@


11.36
log
@"c" command now has a "-c" option. It now assigns region values from region defaults
when changing a combination into a region. Also now removes the "region" attribute
when changing a region into a combination.
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_comb.c,v 11.35 2001/08/27 14:57:49 jra Exp $ (ARL)";
d366 1
d369 3
d378 1
d382 3
d387 3
d394 3
a396 1
	}
d402 3
a404 1
	}
d409 3
a411 1
	}
d416 3
a418 1
	}
d423 2
a424 1
	}
@


11.35
log
@import5 now handles null matrices
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_comb.c,v 11.34 2001/08/20 20:24:59 jra Exp $ (ARL)";
d364 2
a365 1
	}
@


11.34
log
@Changed db_tree_counter() to match rt_comb_v5_serialize() in counting needed matrices.
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_comb.c,v 11.33 2001/08/01 17:18:39 bparker Exp $ (ARL)";
d492 1
a492 1
				if( bn_mat_is_identity( mat ) ) {
d559 1
a559 1
				if( bn_mat_is_identity( mat ) ) {
@


11.33
log
@*- mods to rt_comb_import5 to apply
   the matrix that's passed in
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_comb.c,v 11.32 2001/07/02 17:16:33 jra Exp $ (ARL)";
d89 1
a89 1
		if( tp->tr_l.tl_mat )  tcsp->n_mat++;
@


11.32
log
@rt_comb_v5_serialize() and rt_comb_import5() were not correctly handling identity matrices
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_comb.c,v 11.31 2001/06/29 15:30:48 jra Exp $ (ARL)";
d559 4
a562 1
				tp->tr_l.tl_mat = NULL;
d564 2
d570 1
a570 1
				ntohd( (unsigned char *)tp->tr_l.tl_mat,
d573 5
@


11.31
log
@Minor fixes to get "db adjust xxx rgb none" to actually work
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_comb.c,v 11.30 2001/05/29 20:46:01 jra Exp $ (ARL)";
d175 1
a175 1
		if( tp->tr_l.tl_mat )
d183 1
a183 1
		if( tp->tr_l.tl_mat )  {
d492 4
a495 1
				tp->tr_l.tl_mat = bn_mat_dup( mat );
d507 4
@


11.30
log
@rt_comb_import5() was ignoring the passed in matrix
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_comb.c,v 11.29 2001/04/20 22:29:40 morrison Exp $ (ARL)";
d371 2
a372 1
	}
d618 1
@


11.29
log
@CONST to const
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_comb.c,v 11.28 2001/03/20 16:09:07 jra Exp $ (ARL)";
d491 1
a491 1
				tp->tr_l.tl_mat = NULL;
d493 2
d499 1
a499 1
				ntohd( (unsigned char *)tp->tr_l.tl_mat,
d502 1
@


11.28
log
@ft_import5() and ft_export5() now have a const int minor_type argument
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/librt/db5_comb.c,v 11.27 2000/12/21 21:34:12 jra Exp $ (ARL)";
d79 1
a79 1
db_tree_counter( CONST union tree *tp, struct db_tree_counter_state *tcsp )
@


11.27
log
@rt_comb_import5() was not getting the value of "inherit"
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_comb.c,v 11.26 2000/09/08 05:54:40 mike Exp $ (ARL)";
d429 2
a430 1
	struct resource		*resp)
@


11.26
log
@
Modified tree routines to take resource pointer.
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_comb.c,v 11.25 2000/08/21 02:02:29 butler Exp $ (ARL)";
d621 3
@


11.25
log
@Massive compilation warnings eliminated
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_comb.c,v 11.24 2000/08/01 12:54:30 jra Exp $ (ARL)";
d241 6
a246 5
rt_comb_export5( ep, ip, local2mm, dbip )
struct bu_external		*ep;
CONST struct rt_db_internal	*ip;
double				local2mm;
CONST struct db_i		*dbip;
d261 1
d424 6
a429 5
rt_comb_import5(ip, ep, mat, dbip)
struct rt_db_internal	*ip;
const struct bu_external *ep;
const mat_t		mat;
const struct db_i	*dbip;
d448 3
d478 1
a478 1
			BU_GETUNION( tp, tree );
d505 1
a505 1
				BU_GETUNION( unionp, tree );
d532 1
a532 1
		BU_GETUNION( tp, tree );
@


11.24
log
@Added "gift%d" as "material" in import routine for compatability with older stuff
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_comb.c,v 11.23 2000/07/24 22:36:49 mike Exp $ (ARL)";
d125 1
@


11.23
log
@
anti-lint.
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_comb.c,v 11.22 2000/07/21 13:43:32 jra Exp $ (ARL)";
d632 1
a636 1
			
@


11.22
log
@rt_comb_import5() wasn't importing the region_id, aircode, GIFTmater, or los
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_comb.c,v 11.21 2000/07/11 05:29:21 mike Exp $ (ARL)";
d124 1
@


11.21
log
@
matrix index is no longer a 'long', it's a variable-width thing.
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_comb.c,v 11.20 2000/07/11 05:09:17 mike Exp $ (ARL)";
d621 15
@


11.20
log
@
Added some debugging code for what turned out to be a problem with
db5_encode_length() on a 64-bit machine.
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_comb.c,v 11.19 2000/07/11 03:37:19 mike Exp $ (ARL)";
d522 1
a522 1
		int		mi;
d534 2
a535 2
			mi = bu_glong( leafp );
			leafp += 4;
@


11.19
log
@
A combination without a tree is still a valid combination.
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_comb.c,v 11.18 2000/07/11 03:04:26 mike Exp $ (ARL)";
d135 2
a136 1
	long		mat_num;
d157 1
d174 1
a174 1
			n = ssp->mat_num++;
d176 3
a178 2
			n = -1;
		ssp->leafp = db5_encode_length( ssp->leafp, n, ssp->wid );
d330 1
d468 1
a468 1
			int		mi;
d477 1
@


11.18
log
@
Removed debug printing
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_comb.c,v 11.17 2000/07/10 23:01:26 mike Exp $ (ARL)";
d265 4
a268 1
	max_stack_depth = db_tree_counter( comb->tree, &tcs );
a285 3
bu_log("wid=%d, n_max=%d, n_leaf=%d, n_oper=%d, leafbytes=%d, non_union_seen=%d, max_stack_depth=%d, rpn_len=%d\n",
wid, tcs.n_mat, tcs.n_leaf, tcs.n_oper, tcs.leafbytes, tcs.non_union_seen, max_stack_depth, rpn_len);

d335 2
a336 1
	rt_comb_v5_serialize( comb->tree, &ss );
a458 1
bu_log("nmat=%d, nleaf=%d, rpn_len=%d, max_stack_depth=%d\n", nmat, nleaf, rpn_len, max_stack_depth);
@


11.17
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_comb.c,v 11.16 2000/06/30 19:23:11 mike Exp $ (ARL)";
a394 2
if(getuid()==53)bu_avs_print( avsp, "comb v5 attributes");

a597 1
if(getuid()==53) bu_avs_print( &ip->idb_avs, "comb5" );
@


11.16
log
@
rt_comb_export5() now exports all attributes of a combination
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_comb.c,v 11.15 2000/06/30 17:24:37 mike Exp $ (ARL)";
@


11.15
log
@
Parsed more attributes
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_comb.c,v 11.14 2000/06/30 15:51:50 mike Exp $ (ARL)";
d373 1
d379 10
d395 1
a395 4
	/* XXX THere are more still to be converted */
	/* aircode, GIFTmater */

bu_avs_print( avsp, "comb v5 attributes");
@


11.14
log
@
Finally can import RGB attribute
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_comb.c,v 11.13 2000/06/30 14:37:20 mike Exp $ (ARL)";
d601 1
a601 1
			bu_log("unable to parse rgb attribute '%s'\n", ap);
d603 14
@


11.13
log
@
Additions for putting combinations into attributes.
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_comb.c,v 11.12 2000/06/29 20:06:44 mike Exp $ (ARL)";
d430 1
a431 2

	RT_INIT_DB_INTERNAL( ip );
d592 1
a592 1
bu_avs_print( &ip->idb_avs, "comb5" );
d595 1
a595 1
	if( (ap == bu_avs_get( &ip->idb_avs, "rgb" )) != NULL )  {
d597 1
a597 1
		if( sscanf( ap, "%d/%d/%d", V3ARGS(ibuf) ) == 3 )  {
d600 2
a602 1
		bu_log("unable to parse rgb attribute\n");
@


11.12
log
@
Noted un-const'ing of pointer
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_comb.c,v 11.11 2000/06/29 20:04:30 mike Exp $ (ARL)";
d427 1
d496 1
a496 1
		return 0;
d590 14
@


11.11
log
@
Added rt_db_cvt_to_external5()
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_comb.c,v 11.10 2000/06/29 18:24:55 mike Exp $ (ARL)";
d345 2
a346 1
	avsp = &ip->idb_avs;
@


11.10
log
@
lint
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_comb.c,v 11.9 2000/06/28 22:34:03 mike Exp $ (ARL)";
d251 1
a251 1
	struct bu_attribute_value_set avs;
d256 1
a256 1
	if( ip->idb_type != ID_COMBINATION ) bu_bomb("rt_comb_v4_export() type not ID_COMBINATION");
a335 1
bu_hexdump_external( stderr, ep, "v5comb" );
d345 3
a347 1
	bu_avs_init( &avs, 32, "rt_comb v5 attributes" );
d353 1
a353 1
		bu_avs_add_vls( &avs, "region", &value );
d356 1
a356 1
		bu_avs_add( &avs, "inherit", "1" );
d360 1
a360 1
		bu_avs_add_vls( &avs, "rgb", &value );
d364 1
a364 1
		bu_avs_add_vls( &avs, "oshader", &comb->shader );
d366 1
a366 1
		bu_avs_add_vls( &avs, "material", &comb->material );
d370 1
a370 1
		bu_avs_add_vls( &avs, "temp", &value );
d375 1
a375 1
		bu_avs_add_vls( &avs, "region_id", &value );
d380 1
a380 1
		bu_avs_add_vls( &avs, "los", &value );
d386 1
a386 2
	/* XXX Where do the attributes get put??? */
bu_avs_print( &avs, "comb v5 attributes");
d394 12
@


11.9
log
@
Initial support for writing attributes
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_comb.c,v 11.8 2000/06/28 21:47:40 mike Exp $ (ARL)";
d122 1
d450 2
a451 2
			tp->tr_l.tl_name = bu_strdup( leafp );
			leafp += strlen(leafp) + 1;
d506 2
a507 2
			tp->tr_l.tl_name = bu_strdup( leafp );
			leafp += strlen(leafp) + 1;
@


11.8
log
@
Changed "namebytes" to "leafbytes".
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_comb.c,v 11.7 2000/06/28 21:41:25 mike Exp $ (ARL)";
d250 2
d343 43
a385 1
	/* How to encode all the other stuff as attributes??? */
d387 1
@


11.7
log
@
Changed db5_comb to use variable width matrix subscripts,
and the new routine db5_decode_signed().
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_comb.c,v 11.6 2000/06/28 20:33:13 mike Exp $ (ARL)";
d57 1
a57 1
	long	namebytes;		/* # bytes for name section */
d76 1
a76 1
 *		tcsp->namebytes -= tcsp->n_leaf * (8 - db5_enc_len[wid]);
d91 1
a91 1
		tcsp->namebytes += strlen(tp->tr_l.tl_name) + 1 + 8;
d272 1
a272 1
		tcs.n_mat | tcs.n_leaf | tcs.namebytes |
d275 1
a275 1
	/* Apply correction factor to tcs.namebytes now that we know 'wid'.
d278 1
a278 1
	tcs.namebytes -= tcs.n_leaf * (8 - db5_enc_len[wid]);
d280 2
a281 2
bu_log("wid=%d, n_max=%d, n_leaf=%d, n_oper=%d, namebytes=%d, non_union_seen=%d, max_stack_depth=%d, rpn_len=%d\n",
wid, tcs.n_mat, tcs.n_leaf, tcs.n_oper, tcs.namebytes, tcs.non_union_seen, max_stack_depth, rpn_len);
d287 1
a287 1
		db5_enc_len[wid] +	/* size for namebytes */
d291 1
a291 1
		tcs.namebytes +		/* size for leaf nodes */
d307 1
a307 1
	cp = db5_encode_length( cp, tcs.namebytes, wid );
d326 1
a326 1
	leafp_end = ss.leafp + tcs.namebytes;
d360 1
a360 1
	long		namebytes;
d386 1
a386 1
	cp += db5_decode_length( &namebytes, cp, wid );
d391 1
a391 1
	exprp = leafp + namebytes;
@


11.6
log
@
Can import and export non-union-tree expressions.
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_comb.c,v 11.5 2000/06/28 20:21:59 mike Exp $ (ARL)";
d71 6
d90 2
a91 1
		tcsp->namebytes += strlen(tp->tr_l.tl_name) + 1 + SIZEOF_NETWORK_LONG;
d138 1
d174 1
a174 1
		ssp->leafp = bu_plong( ssp->leafp, n );
d249 1
a262 2
bu_log("n_max=%d, n_leaf=%d, n_oper=%d, namebytes=%d, non_union_seen=%d, max_stack_depth=%d\n",
tcs.n_mat, tcs.n_leaf, tcs.n_oper, tcs.namebytes, tcs.non_union_seen, max_stack_depth);
d275 8
d296 1
d298 3
d322 1
d326 1
d328 1
a328 1
		ss.exprp = ss.leafp + tcs.namebytes;
d337 1
a337 1
	BU_ASSERT_PTR( ss.leafp, <=, ((unsigned char *)ep->ext_buf) + ep->ext_nbytes );
d408 1
a408 2
			mi = bu_glong( leafp );
			leafp += 4;
@


11.5
log
@
First cut at being able to serialize non-union trees.
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_comb.c,v 11.4 2000/06/28 15:06:09 mike Exp $ (ARL)";
a255 1
rt_pr_tree( comb->tree, 1 );
a259 2
		bu_log("Only do groups so far, sorry\n");
		return -1;	/* FAIL */
d322 1
a322 3
	if( rpn_len == 0 )  return 0;	/* OK */

	return -1;	/* FAIL */
d344 1
a344 1
#define MAX_V5_STACK	100
a414 2
		db_ck_tree( comb->tree );
		rt_pr_tree( comb->tree, 1 );
a509 2
	db_ck_tree( comb->tree );
	rt_pr_tree( comb->tree, 1 );
@


11.4
log
@
Clarified and expanded code to match today's version of the spec.
Still not finished.
@
text
@d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_comb.c,v 11.3 2000/06/27 22:00:19 mike Exp $ (ARL)";
d118 7
d175 4
d184 2
d189 6
d196 6
d203 6
d213 2
d256 1
d268 2
a269 1
		tcs.n_mat | tcs.n_leaf | rpn_len | max_stack_depth );
d275 1
d291 1
d344 1
d347 6
d370 1
d375 2
a378 1
	cp = leafp;
d388 2
a389 2
			tp->tr_l.tl_name = bu_strdup( cp );
			cp += strlen(cp) + 1;
d392 2
a393 2
			mi = bu_glong( cp );
			cp += 4;
d422 1
d426 95
a520 1
	return -1;
@


11.3
log
@
import5 starts to work
@
text
@d7 1
a7 1
 *	width
d11 4
d16 2
a17 1
 *  Encoding of a matrix is (16 * SIZEOF_NETWORK_DOUBLE)
d30 1
a30 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_comb.c,v 11.2 2000/06/27 21:05:56 mike Exp $ (ARL)";
d52 11
d67 1
a67 1
 *  number of leaf nodes, number of operator nodes.
d70 1
a70 2
 *	1 if operators other than UNION were seen.
 *	0 if all operators seen were UNION.
d72 2
a73 7
int
db_tree_counter( tp, noperp, nleafp, nmatp, nnamesize )
CONST union tree	*tp;
long			*noperp;
long			*nleafp;
long			*nmatp;
long			*nnamesize;
d75 2
a76 1
	if( tp == TREE_NULL )  return 0;
d78 1
d82 4
a85 4
		(*nleafp)++;
		if( tp->tr_l.tl_mat )  (*nmatp)++;
		(*nnamesize) += strlen(tp->tr_l.tl_name) + 1 + SIZEOF_NETWORK_LONG;
		return 0;
d89 3
a91 2
		(*noperp)++;
		return 1 | db_tree_counter( tp->tr_b.tb_left, noperp, nleafp, nmatp, nnamesize );
d95 5
a99 3
		(*noperp)++;
		return	db_tree_counter( tp->tr_b.tb_left, noperp, nleafp, nmatp, nnamesize ) |
			db_tree_counter( tp->tr_b.tb_right, noperp, nleafp, nmatp, nnamesize );
d105 6
a110 4
		(*noperp)++;
		return 1 | 
			db_tree_counter( tp->tr_b.tb_left, noperp, nleafp, nmatp, nnamesize ) |
			db_tree_counter( tp->tr_b.tb_right, noperp, nleafp, nmatp, nnamesize );
d118 10
d129 4
a132 1
 *			R T _ C O M B _ V 5 _ S E R I A L I Z E _ L E A V E S
d135 1
a135 1
rt_comb_v5_serialize_leaves(
d137 1
a137 3
	long			*matnum,
	unsigned char		**matp,
	unsigned char		**leafp)
a140 1
	if( tp == TREE_NULL )  return;
d142 1
d152 2
a153 2
		bcopy( tp->tr_l.tl_name, *leafp, n );
		(*leafp) += n;
d156 1
a156 1
			n = (*matnum)++;
d159 1
a159 1
		*leafp = bu_plong( *leafp, n );
d163 1
a163 1
			htond( (*matp),
d165 2
a166 2
				16 );
			(*matp) += 16 * SIZEOF_NETWORK_DOUBLE;
d172 1
a172 1
		rt_comb_v5_serialize_leaves( tp->tr_b.tb_left, matnum, matp, leafp );
d180 2
a181 2
		rt_comb_v5_serialize_leaves( tp->tr_b.tb_left, matnum, matp, leafp );
		rt_comb_v5_serialize_leaves( tp->tr_b.tb_right, matnum, matp, leafp );
d185 2
a186 2
		bu_log("rt_comb_v5_serialize_leaves: bad op %d\n", tp->tr_op);
		bu_bomb("rt_comb_v5_serialize_leaves\n");
d201 3
a203 2
	long	noper=0, nleaf=0, nmat=0, nnamesize=0;
	int	full_expression;	/* 0 = all UNION */
a207 3
	unsigned char	*matp;
	unsigned char	*leafp;
	long	matnum = 0;
d218 9
a226 7
	full_expression = db_tree_counter( comb->tree, &noper,
		&nleaf, &nmat, &nnamesize );
bu_log("noper=%d, nleaf=%d, nmat=%d, nnamesize=%d\n", noper, nleaf, nmat, nnamesize);

	if( full_expression )  {
		/* XXX Calculate storage needs for RPN expression here */
		rpn_len = 0;
d229 2
d233 2
a234 1
	wid = db5_select_length_encoding( nmat | nleaf | rpn_len );
d236 1
a236 1
	/* Second pass -- determine upper bound of on-disk memory needed */
d241 4
a244 5
		nmat * (16 * SIZEOF_NETWORK_DOUBLE) +	/* sizeof matrix array */
		nnamesize;		/* size for leaf nodes */
	if( full_expression )  {
		need += rpn_len * db5_enc_len[wid];
	}
d248 1
a248 1
	ep->ext_buf = bu_malloc( need, "rt_comb_export5" );
d253 2
a254 2
	cp = db5_encode_length( cp, nmat, wid );
	cp = db5_encode_length( cp, nleaf, wid );
d256 1
d259 8
a266 4
	 *  Because matricies are fixed size, we can compute the pointer
	 *  to the start of the leaf node section now,
	 *  and output them both, together, with one tree walk
	 *  and no temporary storage.
d268 8
a275 2
	matp = cp;
	leafp = cp + nmat * (16 * SIZEOF_NETWORK_DOUBLE);
d277 1
a277 1
	rt_comb_v5_serialize_leaves( comb->tree, &matnum, &matp, &leafp );
d280 5
a284 3
	BU_ASSERT_LONG( matnum, ==, nmat );
	BU_ASSERT_PTR( matp, ==, cp + nmat * (16 * SIZEOF_NETWORK_DOUBLE) );
	BU_ASSERT_PTR( leafp, <=, ((unsigned char *)ep->ext_buf) + ep->ext_nbytes );
d288 1
a288 1
	if( full_expression == 0 )  return 0;	/* OK */
d306 1
a306 1
	long		nmat, nleaf, rpn_len;
d327 1
d329 2
a330 2
	leafp = cp + nmat * (16 * SIZEOF_NETWORK_DOUBLE);
bu_log("nmat=%d, nleaf=%d, rpn_len=%d\n", nmat, nleaf, rpn_len);
d358 2
a359 2
					&matp[mi*16*SIZEOF_NETWORK_DOUBLE],
					16);
@


11.2
log
@
Added rt_comb_import5/export5
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_comb.c,v 11.1 2000/06/27 18:48:43 mike Exp $ (ARL)";
d120 1
a120 1
		 *	A null-terminate name string,
d243 2
d251 1
d256 3
a258 3
CONST struct bu_external *ep;
CONST mat_t		mat;
CONST struct db_i	*dbip;
d260 75
@


11.1
log
@
Added rt_comb_import5/export5
@
text
@d6 8
d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_io.c,v 11.7 2000/06/27 18:14:55 mike Exp $ (ARL)";
d48 1
a48 1
 *			D B _ T R E E _ N L E A V E S
d52 4
d57 2
a58 2
void
db_tree_counter( tp, noperp, nleafp, nmatp )
d63 1
d65 1
a65 1
	if( tp == TREE_NULL )  return;
a68 3
	case OP_NOP:
		(*nleafp)++;
		return;
d71 3
a73 1
		return;
a75 2
	case OP_GUARD:
	case OP_XNOP:
d78 1
a78 2
		db_tree_counter( tp->tr_b.tb_left, noperp, nleafp, nmatp );
		return;
d81 5
d91 3
a93 3
		db_tree_counter( tp->tr_b.tb_left, noperp, nleafp, nmatp );
		db_tree_counter( tp->tr_b.tb_right, noperp, nleafp, nmatp );
		return;
d102 61
d173 9
a181 1
	long	noper=0, nleaf=0, nmat=0;
a183 1
	RT_CK_DBI(dbip);
d192 50
a241 1
	db_tree_counter( comb->tree, &noper, &nleaf, &nmat );
d243 15
a257 1
	return 0;
@

