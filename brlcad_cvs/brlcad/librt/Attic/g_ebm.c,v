head	11.41;
access;
symbols
	ansi-20040405-merged:11.36.2.2
	postmerge-20040405-ansi:11.39
	premerge-20040404-ansi:11.38
	postmerge-autoconf:11.38
	autoconf-freeze:11.36.10.3
	premerge-autoconf:11.38
	ansi-20040316-freeze:11.36.2.1
	postmerge-20040315-windows:11.38
	premerge-20040315-windows:11.37
	windows-20040315-freeze:11.36.4.2
	autoconf-20031203:11.36
	autoconf-20031202:11.36
	autoconf-branch:11.36.0.10
	phong-branch:11.36.0.8
	photonmap-branch:11.36.0.6
	rel-6-1-DP:11.36
	windows-branch:11.36.0.4
	rel-6-0-2:11.34
	ansi-branch:11.36.0.2
	rel-6-0-1-branch:11.34.0.2
	hartley-6-0-post:11.35
	hartley-6-0-pre:11.34
	rel-6-0-1:11.34
	rel-6-0:11.33
	rel-5-4:11.19
	offsite-5-3-pre:11.25
	rel-5-3:11.19
	rel-5-2:11.19
	rel-5-1-branch:11.19.0.2
	rel-5-1:11.19
	rel-5-0:11.9
	rel-5-0-beta:11.8
	rel-4-5:11.7
	ctj-4-5-post:11.7
	ctj-4-5-pre:11.7
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1;
locks; strict;
comment	@ * @;


11.41
date	2004.05.21.18.07.30;	author morrison;	state dead;
branches;
next	11.40;

11.40
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.39;

11.39
date	2004.04.05.08.48.56;	author morrison;	state Exp;
branches;
next	11.38;

11.38
date	2004.03.16.20.03.08;	author morrison;	state Exp;
branches;
next	11.37;

11.37
date	2004.02.02.17.39.20;	author morrison;	state Exp;
branches;
next	11.36;

11.36
date	2002.08.20.17.07.59;	author jra;	state Exp;
branches
	11.36.2.1
	11.36.4.1
	11.36.10.1;
next	11.35;

11.35
date	2002.08.15.20.55.11;	author hartley;	state Exp;
branches;
next	11.34;

11.34
date	2002.05.31.19.50.14;	author jra;	state Exp;
branches;
next	11.33;

11.33
date	2001.10.02.19.24.29;	author jra;	state Exp;
branches;
next	11.32;

11.32
date	2001.10.02.17.54.11;	author jra;	state Exp;
branches;
next	11.31;

11.31
date	2001.06.21.20.35.31;	author jra;	state Exp;
branches;
next	11.30;

11.30
date	2001.06.21.20.14.29;	author jra;	state Exp;
branches;
next	11.29;

11.29
date	2001.05.17.20.05.24;	author morrison;	state Exp;
branches;
next	11.28;

11.28
date	2001.04.20.22.29.43;	author morrison;	state Exp;
branches;
next	11.27;

11.27
date	2001.04.02.21.38.08;	author morrison;	state Exp;
branches;
next	11.26;

11.26
date	2001.03.31.01.57.07;	author morrison;	state Exp;
branches;
next	11.25;

11.25
date	2000.09.08.05.54.41;	author mike;	state Exp;
branches;
next	11.24;

11.24
date	2000.07.13.02.36.26;	author cjohnson;	state Exp;
branches;
next	11.23;

11.23
date	2000.07.10.23.01.30;	author mike;	state Exp;
branches;
next	11.22;

11.22
date	2000.06.30.19.43.51;	author jra;	state Exp;
branches;
next	11.21;

11.21
date	2000.06.30.15.38.02;	author mike;	state Exp;
branches;
next	11.20;

11.20
date	2000.06.30.15.31.14;	author mike;	state Exp;
branches;
next	11.19;

11.19
date	2000.04.12.02.34.32;	author mike;	state Exp;
branches;
next	11.18;

11.18
date	2000.03.29.02.43.10;	author mike;	state Exp;
branches;
next	11.17;

11.17
date	2000.03.02.03.50.57;	author mike;	state Exp;
branches;
next	11.16;

11.16
date	2000.01.14.02.15.21;	author mike;	state Exp;
branches;
next	11.15;

11.15
date	99.12.29.21.00.42;	author jra;	state Exp;
branches;
next	11.14;

11.14
date	99.12.22.02.17.59;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	99.11.26.21.46.45;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	99.11.24.23.12.06;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	99.11.24.21.44.29;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	99.11.17.02.41.57;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	99.07.02.22.19.22;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	99.05.27.19.10.37;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	97.05.19.20.51.36;	author jra;	state Exp;
branches;
next	11.6;

11.6
date	96.12.19.16.37.06;	author jra;	state Exp;
branches;
next	11.5;

11.5
date	96.08.31.11.04.24;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	96.08.29.22.49.42;	author butler;	state Exp;
branches;
next	11.3;

11.3
date	96.07.11.15.18.42;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	96.04.24.22.17.48;	author butler;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.56.32;	author mike;	state Rel4_4;
branches;
next	10.12;

10.12
date	94.12.28.12.54.42;	author jra;	state Exp;
branches;
next	10.11;

10.11
date	94.12.08.23.14.52;	author mike;	state Exp;
branches;
next	10.10;

10.10
date	94.12.01.20.11.45;	author mike;	state Exp;
branches;
next	10.9;

10.9
date	94.11.04.05.44.18;	author mike;	state Exp;
branches;
next	10.8;

10.8
date	94.10.29.02.08.20;	author mike;	state Exp;
branches;
next	10.7;

10.7
date	94.10.06.10.08.24;	author jra;	state Exp;
branches;
next	10.6;

10.6
date	94.09.20.17.43.12;	author jra;	state Exp;
branches;
next	10.5;

10.5
date	94.09.16.16.47.17;	author jra;	state Exp;
branches;
next	10.4;

10.4
date	94.08.10.18.25.26;	author gdurf;	state Exp;
branches;
next	10.3;

10.3
date	93.07.20.20.54.26;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	93.03.02.17.29.07;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.40.14;	author mike;	state Rel4_0;
branches;
next	9.26;

9.26
date	91.09.20.23.01.48;	author butler;	state Exp;
branches;
next	9.25;

9.25
date	91.08.29.22.14.33;	author mike;	state Exp;
branches;
next	9.24;

9.24
date	91.07.05.23.40.12;	author mike;	state Exp;
branches;
next	9.23;

9.23
date	91.06.30.00.08.29;	author mike;	state Exp;
branches;
next	9.22;

9.22
date	91.06.22.22.30.19;	author mike;	state Exp;
branches;
next	9.21;

9.21
date	91.06.14.06.47.57;	author mike;	state Exp;
branches;
next	9.20;

9.20
date	91.06.14.06.25.55;	author mike;	state Exp;
branches;
next	9.19;

9.19
date	91.06.14.06.22.11;	author mike;	state Exp;
branches;
next	9.18;

9.18
date	91.05.18.03.00.49;	author mike;	state Exp;
branches;
next	9.17;

9.17
date	91.02.17.20.01.35;	author mike;	state Exp;
branches;
next	9.16;

9.16
date	91.01.28.23.53.08;	author mike;	state Exp;
branches;
next	9.15;

9.15
date	91.01.26.03.14.43;	author mike;	state Exp;
branches;
next	9.14;

9.14
date	91.01.25.21.18.47;	author mike;	state Exp;
branches;
next	9.13;

9.13
date	91.01.25.19.37.38;	author mike;	state Exp;
branches;
next	9.12;

9.12
date	91.01.05.03.08.49;	author mike;	state Exp;
branches;
next	9.11;

9.11
date	90.12.21.14.38.33;	author mike;	state Exp;
branches;
next	9.10;

9.10
date	90.12.18.00.20.18;	author butler;	state Exp;
branches;
next	9.9;

9.9
date	90.12.08.06.54.30;	author mike;	state Exp;
branches;
next	9.8;

9.8
date	90.12.05.20.29.55;	author mike;	state Exp;
branches;
next	9.7;

9.7
date	90.10.15.12.00.53;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	90.10.07.21.38.43;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	90.10.06.02.05.10;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	90.03.14.15.05.44;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	89.12.29.21.22.10;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	89.10.10.16.16.53;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.56.07;	author mike;	state Rel3_5;
branches;
next	1.1;

1.1
date	89.04.17.17.18.57;	author mike;	state Exp;
branches;
next	;

11.36.2.1
date	2002.09.19.18.01.33;	author morrison;	state Exp;
branches;
next	11.36.2.2;

11.36.2.2
date	2004.03.17.21.18.45;	author morrison;	state Exp;
branches;
next	;

11.36.4.1
date	2002.09.26.23.04.01;	author morrison;	state Exp;
branches;
next	11.36.4.2;

11.36.4.2
date	2004.03.11.23.43.37;	author morrison;	state Exp;
branches;
next	;

11.36.10.1
date	2004.02.12.18.37.40;	author erikg;	state Exp;
branches;
next	11.36.10.2;

11.36.10.2
date	2004.03.15.14.07.18;	author erikg;	state Exp;
branches;
next	11.36.10.3;

11.36.10.3
date	2004.03.18.18.10.29;	author erikg;	state Exp;
branches;
next	;


desc
@Extruded bitmaps
@


11.41
log
@moved to src/
@
text
@/*
 *			G _ E B M . C
 *
 *  Purpose -
 *	Intersect a ray with an Extruded Bitmap,
 *	where the bitmap is taken from a bw(5) file.
 *
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1988-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSebm[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/g_ebm.c,v 11.40 2004/05/10 15:30:46 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <ctype.h>
#include <math.h>
#ifdef HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include <ctype.h>
#include "tcl.h"
#include "machine.h"
#include "vmath.h"
#include "db.h"
#include "nmg.h"
#include "rtgeom.h"
#include "raytrace.h"
#include "./debug.h"
#include "./fixpt.h"

/*
NOTES:
	Changed small to small11 for win32 compatibility 
*/


struct rt_ebm_specific {
	struct rt_ebm_internal	ebm_i;
	vect_t		ebm_xnorm;	/* local +X norm in model coords */
	vect_t		ebm_ynorm;
	vect_t		ebm_znorm;
	vect_t		ebm_cellsize;	/* ideal coords: size of each cell */
	vect_t		ebm_origin;	/* local coords of grid origin (0,0,0) for now */
	vect_t		ebm_large;	/* local coords of XYZ max */
	mat_t		ebm_mat;	/* model to ideal space */
};
#define RT_EBM_NULL	((struct rt_ebm_specific *)0)

#define RT_EBM_O(m)	offsetof(struct rt_ebm_internal, m)

const struct bu_structparse rt_ebm_parse[] = {
#if CRAY && !__STDC__
	{"%s",	RT_EBM_NAME_LEN, "file",	1,	BU_STRUCTPARSE_FUNC_NULL },
#else
	{"%s",	RT_EBM_NAME_LEN, "file", bu_offsetofarray(struct rt_ebm_internal, file), BU_STRUCTPARSE_FUNC_NULL },
#endif
	{"%d",	1, "w",		RT_EBM_O(xdim),		BU_STRUCTPARSE_FUNC_NULL },
	{"%d",	1, "n",		RT_EBM_O(ydim),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "d",		RT_EBM_O(tallness),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	16, "mat", bu_offsetofarray(struct rt_ebm_internal, mat), BU_STRUCTPARSE_FUNC_NULL },
	{"",	0, (char *)0, 0,			BU_STRUCTPARSE_FUNC_NULL }
};

struct ebm_hit_private {
	int	x_cell;
	int	y_cell;
};


RT_EXTERN(int rt_ebm_dda,(struct xray *rp, struct soltab *stp,
	struct application *ap, struct seg *seghead));
RT_EXTERN(int rt_seg_planeclip,(struct seg *out_hd, struct seg *in_hd,
	vect_t out_norm, fastf_t in, fastf_t out,
	struct xray *rp, struct application *ap));
RT_EXTERN( void rt_ebm_plate, ( int x1, int y1, int x2, int y2,
	double t, mat_t mat, struct bu_list *vhead ) );

/*
 *  Codes to represent surface normals.
 *  In a bitmap, there are only 4 possible normals.
 *  With this code, reverse the sign to reverse the direction.
 *  As always, the normal is expected to point outwards.
 */
#define NORM_ZPOS	3
#define NORM_YPOS	2
#define NORM_XPOS	1
#define NORM_XNEG	(-1)
#define NORM_YNEG	(-2)
#define NORM_ZNEG	(-3)

/*
 *  Regular bit addressing is used:  (0..W-1, 0..N-1),
 *  but the bitmap is stored with two cells of zeros all around,
 *  so permissible subscripts run (-2..W+1, -2..N+1).
 *  This eliminates special-case code for the boundary conditions.
 */
#define	BIT_XWIDEN	2
#define	BIT_YWIDEN	2
#define BIT(_eip,_xx,_yy)	\
	((unsigned char *)((_eip)->mp->apbuf))[ \
		((_yy)+BIT_YWIDEN)*((_eip)->xdim + \
		BIT_XWIDEN*2)+(_xx)+BIT_XWIDEN ]

/*
 *			R T _ S E G _ P L A N E C L I P
 *
 *  Take a segment chain, in sorted order (ascending hit_dist),
 *  and clip to the range (in, out) along the normal "out_norm".
 *  For the particular ray "rp", find the parametric distances:
 *	kmin is the minimum permissible parameter, "in" units away
 *	kmax is the maximum permissible parameter, "out" units away
 *
 *  Returns -
 *	1	OK: trimmed segment chain, still in sorted order
 *	0	ERROR
 */
int
rt_seg_planeclip(struct seg *out_hd, struct seg *in_hd, fastf_t *out_norm, fastf_t in, fastf_t out, struct xray *rp, struct application *ap)
{
	fastf_t		norm_dist_min, norm_dist_max;
	fastf_t		slant_factor;
	fastf_t		kmin, kmax;
	vect_t		in_norm;
	register struct seg	*curr;
	int		out_norm_code;
	int		count;

	norm_dist_min = in - VDOT( rp->r_pt, out_norm );
	slant_factor = VDOT( rp->r_dir, out_norm );	/* always abs < 1 */
	if( NEAR_ZERO( slant_factor, SQRT_SMALL_FASTF ) )  {
		if( norm_dist_min < 0.0 )  {
			bu_log("rt_seg_planeclip ERROR -- ray parallel to baseplane, outside \n");
			/* XXX Free segp chain */
			return(0);
		}
		kmin = -INFINITY;
	} else
		kmin =  norm_dist_min / slant_factor;

	VREVERSE( in_norm, out_norm );
	norm_dist_max = out - VDOT( rp->r_pt, in_norm );
	slant_factor = VDOT( rp->r_dir, in_norm );	/* always abs < 1 */
	if( NEAR_ZERO( slant_factor, SQRT_SMALL_FASTF ) )  {
		if( norm_dist_max < 0.0 )  {
			bu_log("rt_seg_planeclip ERROR -- ray parallel to baseplane, outside \n");
			/* XXX Free segp chain */
			return(0);
		}
		kmax = INFINITY;
	} else
		kmax =  norm_dist_max / slant_factor;

	if( kmin > kmax )  {
		/* If r_dir[Z] < 0, will need to swap min & max */
		slant_factor = kmax;
		kmax = kmin;
		kmin = slant_factor;
		out_norm_code = NORM_ZPOS;
	} else {
		out_norm_code = NORM_ZNEG;
	}
	if(RT_G_DEBUG&DEBUG_EBM)bu_log("kmin=%g, kmax=%g, out_norm_code=%d\n", kmin, kmax, out_norm_code );

	count = 0;
	while( BU_LIST_WHILE( curr, seg, &(in_hd->l) ) )  {
		BU_LIST_DEQUEUE( &(curr->l) );
		if(RT_G_DEBUG&DEBUG_EBM)bu_log(" rt_seg_planeclip seg( %g, %g )\n", curr->seg_in.hit_dist, curr->seg_out.hit_dist );
		if( curr->seg_out.hit_dist <= kmin )  {
			if(RT_G_DEBUG&DEBUG_EBM)bu_log("seg_out %g <= kmin %g, freeing\n", curr->seg_out.hit_dist, kmin );
			RT_FREE_SEG(curr, ap->a_resource);
			continue;
		}
		if( curr->seg_in.hit_dist >= kmax )  {
			if(RT_G_DEBUG&DEBUG_EBM)bu_log("seg_in  %g >= kmax %g, freeing\n", curr->seg_in.hit_dist, kmax );
			RT_FREE_SEG(curr, ap->a_resource);
			continue;
		}
		if( curr->seg_in.hit_dist <= kmin )  {
			if(RT_G_DEBUG&DEBUG_EBM)bu_log("seg_in = kmin %g\n", kmin );
			curr->seg_in.hit_dist = kmin;
			curr->seg_in.hit_surfno = out_norm_code;
		}
		if( curr->seg_out.hit_dist >= kmax )  {
			if(RT_G_DEBUG&DEBUG_EBM)bu_log("seg_out= kmax %g\n", kmax );
			curr->seg_out.hit_dist = kmax;
			curr->seg_out.hit_surfno = (-out_norm_code);
		}
		BU_LIST_INSERT( &(out_hd->l), &(curr->l) );
		count += 2;
	}
	return( count );
}

static int rt_ebm_normtab[3] = { NORM_XPOS, NORM_YPOS, NORM_ZPOS };


/*
 *			R T _ E B M _ D D A
 *
 *  Step through the 2-D array, in local coordinates ("ideal space").
 *
 *
 */
int
rt_ebm_dda(register struct xray *rp, struct soltab *stp, struct application *ap, struct seg *seghead)
{
	register struct rt_ebm_specific *ebmp =
		(struct rt_ebm_specific *)stp->st_specific;
	vect_t	invdir;
	double	t0;	/* in point of cell */
	double	t1;	/* out point of cell */
	double	tmax;	/* out point of entire grid */
	vect_t	t;	/* next t value for XYZ cell plane intersect */
	vect_t	delta;	/* spacing of XYZ cell planes along ray */
	int	igrid[3];/* Grid cell coordinates of cell (integerized) */
	vect_t	P;	/* hit point */
	int	inside;	/* inside/outside a solid flag */
	int	in_index;
	int	out_index;
	int	j;

	/* Compute the inverse of the direction cosines */
	if( !NEAR_ZERO( rp->r_dir[X], SQRT_SMALL_FASTF ) )  {
		invdir[X]=1.0/rp->r_dir[X];
	} else {
		invdir[X] = INFINITY;
		rp->r_dir[X] = 0.0;
	}
	if( !NEAR_ZERO( rp->r_dir[Y], SQRT_SMALL_FASTF ) )  {
		invdir[Y]=1.0/rp->r_dir[Y];
	} else {
		invdir[Y] = INFINITY;
		rp->r_dir[Y] = 0.0;
	}
	if( !NEAR_ZERO( rp->r_dir[Z], SQRT_SMALL_FASTF ) )  {
		invdir[Z]=1.0/rp->r_dir[Z];
	} else {
		invdir[Z] = INFINITY;
		rp->r_dir[Z] = 0.0;
	}

	/* intersect ray with ideal grid rpp */
	VSETALL( P, 0 );
	if( ! rt_in_rpp(rp, invdir, P, ebmp->ebm_large ) )
		return(0);	/* MISS */

	VJOIN1( P, rp->r_pt, rp->r_min, rp->r_dir );
	/* P is hit point (on RPP?) */

if(RT_G_DEBUG&DEBUG_EBM)VPRINT("ebm_origin", ebmp->ebm_origin);
if(RT_G_DEBUG&DEBUG_EBM)VPRINT("r_pt", rp->r_pt);
if(RT_G_DEBUG&DEBUG_EBM)VPRINT("P", P);
if(RT_G_DEBUG&DEBUG_EBM)VPRINT("cellsize", ebmp->ebm_cellsize);
	t0 = rp->r_min;
	tmax = rp->r_max;
if(RT_G_DEBUG&DEBUG_EBM)bu_log("[shoot: r_min=%g, r_max=%g]\n", rp->r_min, rp->r_max);

	/* find grid cell where ray first hits ideal space bounding RPP */
	igrid[X] = (P[X] - ebmp->ebm_origin[X]) / ebmp->ebm_cellsize[X];
	igrid[Y] = (P[Y] - ebmp->ebm_origin[Y]) / ebmp->ebm_cellsize[Y];
	if( igrid[X] < 0 )  {
		igrid[X] = 0;
	} else if( igrid[X] >= ebmp->ebm_i.xdim ) {
		igrid[X] = ebmp->ebm_i.xdim-1;
	}
	if( igrid[Y] < 0 )  {
		igrid[Y] = 0;
	} else if( igrid[Y] >= ebmp->ebm_i.ydim ) {
		igrid[Y] = ebmp->ebm_i.ydim-1;
	}
if(RT_G_DEBUG&DEBUG_EBM)bu_log("g[X] = %d, g[Y] = %d\n", igrid[X], igrid[Y]);

	if( rp->r_dir[X] == 0.0 && rp->r_dir[Y] == 0.0 )  {
		register struct seg	*segp;

		/*  Ray is traveling exactly along Z axis.
		 *  Just check the one cell hit.
		 *  Depend on higher level to clip ray to Z extent.
		 */
if(RT_G_DEBUG&DEBUG_EBM)bu_log("ray on local Z axis\n");
		if( BIT( &ebmp->ebm_i, igrid[X], igrid[Y] ) == 0 )
			return(0);	/* MISS */
		RT_GET_SEG(segp, ap->a_resource);
		segp->seg_stp = stp;
		segp->seg_in.hit_dist = 0;
		segp->seg_out.hit_dist = INFINITY;

		segp->seg_in.hit_vpriv[X] = 
			(double) igrid[X] / ebmp->ebm_i.xdim;
		segp->seg_in.hit_vpriv[Y] = 
			(double) igrid[Y] / ebmp->ebm_i.ydim;

		segp->seg_out.hit_vpriv[X] = 
			(double) igrid[X] / ebmp->ebm_i.xdim;
		segp->seg_out.hit_vpriv[Y] = 
			(double) igrid[Y] / ebmp->ebm_i.ydim;

		if( rp->r_dir[Z] < 0 )  {
			segp->seg_in.hit_surfno = NORM_ZPOS;
			segp->seg_out.hit_surfno = NORM_ZNEG;
		} else {
			segp->seg_in.hit_surfno = NORM_ZNEG;
			segp->seg_out.hit_surfno = NORM_ZPOS;
		}
		BU_LIST_INSERT( &(seghead->l), &(segp->l) );
		return(2);			/* HIT */
	}

	/* X setup */
	if( rp->r_dir[X] == 0.0 )  {
		t[X] = INFINITY;
		delta[X] = 0;
	} else {
		j = igrid[X];
		if( rp->r_dir[X] < 0 ) j++;
		t[X] = (ebmp->ebm_origin[X] + j*ebmp->ebm_cellsize[X] -
			rp->r_pt[X]) * invdir[X];
		delta[X] = ebmp->ebm_cellsize[X] * fabs(invdir[X]);
	}
	/* Y setup */
	if( rp->r_dir[Y] == 0.0 )  {
		t[Y] = INFINITY;
		delta[Y] = 0;
	} else {
		j = igrid[Y];
		if( rp->r_dir[Y] < 0 ) j++;
		t[Y] = (ebmp->ebm_origin[Y] + j*ebmp->ebm_cellsize[Y] -
			rp->r_pt[Y]) * invdir[Y];
		delta[Y] = ebmp->ebm_cellsize[Y] * fabs(invdir[Y]);
	}
#if 0
	/* Z setup */
	if( rp->r_dir[Z] == 0.0 )  {
		t[Z] = INFINITY;
	} else {
		/* Consider igrid[Z] to be either 0 or 1 */
		if( rp->r_dir[Z] < 0 )  {
			t[Z] = (ebmp->ebm_origin[Z] + ebmp->ebm_cellsize[Z] -
				rp->r_pt[Z]) * invdir[Z];
		} else {
			t[Z] = (ebmp->ebm_origin[Z] - rp->r_pt[Z]) * invdir[Z];
		}
	}
#endif

	/* The delta[] elements *must* be positive, as t must increase */
if(RT_G_DEBUG&DEBUG_EBM)bu_log("t[X] = %g, delta[X] = %g\n", t[X], delta[X] );
if(RT_G_DEBUG&DEBUG_EBM)bu_log("t[Y] = %g, delta[Y] = %g\n", t[Y], delta[Y] );

	/* Find face of entry into first cell -- max initial t value */
	if( t[X] == INFINITY ) {
		in_index = Y;
		t0 = t[Y];
	}
	else if( t[Y] == INFINITY ) {
		in_index = X;
		t0 = t[X];
	}
	else if( t[X] >= t[Y]  )  {
		in_index = X;
		t0 = t[X];
	} else {
		in_index = Y;
		t0 = t[Y];
	}
if(RT_G_DEBUG&DEBUG_EBM)bu_log("Entry index is %s, t0=%g\n", in_index==X ? "X" : "Y", t0);

	/* Advance to next exits */
	t[X] += delta[X];
	t[Y] += delta[Y];

	/* Ensure that next exit is after first entrance */
	if( t[X] < t0 )  {
		bu_log("*** advancing t[X]\n");
		t[X] += delta[X];
	}
	if( t[Y] < t0 )  {
		bu_log("*** advancing t[Y]\n");
		t[Y] += delta[Y];
	}
if(RT_G_DEBUG&DEBUG_EBM)bu_log("Exit t[X]=%g, t[Y]=%g\n", t[X], t[Y] );

	inside = 0;

	while( t0 < tmax ) {
		int	val;
		struct seg	*segp;

		/* find minimum exit t value */
		out_index = t[X] < t[Y] ? X : Y;

		t1 = t[out_index];

		/* Ray passes through cell igrid[XY] from t0 to t1 */
		val = BIT( &ebmp->ebm_i, igrid[X], igrid[Y] );
if(RT_G_DEBUG&DEBUG_EBM)bu_log("igrid [%d %d] from %g to %g, val=%d\n",
			igrid[X], igrid[Y],
			t0, t1, val );
if(RT_G_DEBUG&DEBUG_EBM)bu_log("Exit index is %s, t[X]=%g, t[Y]=%g\n",
			out_index==X ? "X" : "Y", t[X], t[Y] );


		if( t1 <= t0 )  bu_log("ERROR ebm t1=%g < t0=%g\n", t1, t0 );
		if( !inside )  {
			if( val > 0 )  {
				/* Handle the transition from vacuum to solid */
				/* Start of segment (entering a full voxel) */
				inside = 1;

				RT_GET_SEG(segp, ap->a_resource);
				segp->seg_stp = stp;
				segp->seg_in.hit_dist = t0;

				segp->seg_in.hit_vpriv[X] = 
					(double) igrid[X] / ebmp->ebm_i.xdim;
				segp->seg_in.hit_vpriv[Y] = 
					(double) igrid[Y] / ebmp->ebm_i.ydim;

				/* Compute entry normal */
				if( rp->r_dir[in_index] < 0 )  {
					/* Go left, entry norm goes right */
					segp->seg_in.hit_surfno =
						rt_ebm_normtab[in_index];
				}  else  {
					/* go right, entry norm goes left */
					segp->seg_in.hit_surfno =
						(-rt_ebm_normtab[in_index]);
				}
				BU_LIST_INSERT( &(seghead->l), &(segp->l) );

				if(RT_G_DEBUG&DEBUG_EBM) bu_log("START t=%g, surfno=%d\n",
					t0, segp->seg_in.hit_surfno);
			} else {
				/* Do nothing, marching through void */
			}
		} else {
			register struct seg	*tail;
			if( val > 0 )  {
				/* Do nothing, marching through solid */
			} else {
				/* End of segment (now in an empty voxel) */
				/* Handle transition from solid to vacuum */
				inside = 0;

				tail = BU_LIST_LAST( seg, &(seghead->l) );
				tail->seg_out.hit_dist = t0;

				tail->seg_out.hit_vpriv[X] = 
					(double) igrid[X] / ebmp->ebm_i.xdim;
				tail->seg_out.hit_vpriv[Y] = 
					(double) igrid[Y] / ebmp->ebm_i.ydim;

				/* Compute exit normal */
				if( rp->r_dir[in_index] < 0 )  {
					/* Go left, exit normal goes left */
					tail->seg_out.hit_surfno =
						(-rt_ebm_normtab[in_index]);
				}  else  {
					/* go right, exit norm goes right */
					tail->seg_out.hit_surfno =
						rt_ebm_normtab[in_index];
				}
				if(RT_G_DEBUG&DEBUG_EBM) bu_log("END t=%g, surfno=%d\n",
					t0, tail->seg_out.hit_surfno );
			}
		}

		/* Take next step */
		t0 = t1;
		in_index = out_index;
		t[out_index] += delta[out_index];
		if( rp->r_dir[out_index] > 0 ) {
			igrid[out_index]++;
		} else {
			igrid[out_index]--;
		}
	}

	if( inside )  {
		register struct seg	*tail;

		/* Close off the final segment */
		tail = BU_LIST_LAST( seg, &(seghead->l) );
		tail->seg_out.hit_dist = tmax;
		VSETALL(tail->seg_out.hit_vpriv, 0.0);

		/* Compute exit normal.  Previous out_index is now in_index */
		if( rp->r_dir[in_index] < 0 )  {
			/* Go left, exit normal goes left */
			tail->seg_out.hit_surfno = (-rt_ebm_normtab[in_index]);
		}  else  {
			/* go right, exit norm goes right */
			tail->seg_out.hit_surfno = rt_ebm_normtab[in_index];
		}
		if(RT_G_DEBUG&DEBUG_EBM) bu_log("closed END t=%g, surfno=%d\n",
			tmax, tail->seg_out.hit_surfno );
	}

	if( BU_LIST_IS_EMPTY( &(seghead->l) ) )
		return(0);
	return(2);
}

/*
 *			R T _ E B M _ I M P O R T
 *
 *  Read in the information from the string solid record.
 *  Then, as a service to the application, read in the bitmap
 *  and set up some of the associated internal variables.
 */
int
rt_ebm_import(struct rt_db_internal *ip, const struct bu_external *ep, const fastf_t *mat, const struct db_i *dbip)
{
	union record	*rp;
	register struct rt_ebm_internal *eip;
	struct bu_vls	str;
	int		nbytes;
	mat_t		tmat;
	struct bu_mapped_file	*mp;

	BU_CK_EXTERNAL( ep );
	rp = (union record *)ep->ext_buf;
	if( rp->u_id != DBID_STRSOL )  {
		bu_log("rt_ebm_import: defective strsol record\n");
		return(-1);
	}

	RT_CK_DB_INTERNAL( ip );
	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_EBM;
	ip->idb_meth = &rt_functab[ID_EBM];
	ip->idb_ptr = bu_calloc(1, sizeof(struct rt_ebm_internal), "rt_ebm_internal");
	eip = (struct rt_ebm_internal *)ip->idb_ptr;
	eip->magic = RT_EBM_INTERNAL_MAGIC;

	/* Provide default orientation info */
	MAT_IDN( eip->mat );

	bu_vls_init( &str );
	bu_vls_strcpy( &str, rp->ss.ss_args );
	if( bu_struct_parse( &str, rt_ebm_parse, (char *)eip ) < 0 )  {
		bu_vls_free( &str );
		bu_free( (char *)eip , "rt_ebm_import: eip" );
		ip->idb_type = ID_NULL;
		ip->idb_ptr = (genptr_t)NULL;
		return -2;
	}
	bu_vls_free( &str );

	/* Check for reasonable values */
	if( eip->file[0] == '\0' || eip->xdim < 1 ||
	    eip->ydim < 1 || eip->mat[15] <= 0.0 ||
	    eip->tallness <= 0.0 )  {
	    	bu_struct_print( "Unreasonable EBM parameters", rt_ebm_parse,
	    		(char *)eip );
	    	bu_free( (char *)eip , "rt_ebm_import: eip" );
	    	ip->idb_type = ID_NULL;
	    	ip->idb_ptr = (genptr_t)NULL;
		return -1;
	}

	/* Apply any modeling transforms to get final matrix */
	bn_mat_mul( tmat, mat, eip->mat );
	MAT_COPY( eip->mat, tmat );

	/* Get bit map from .bw(5) file */
	if( !(mp = bu_open_mapped_file_with_path( dbip->dbi_filepath, eip->file, "ebm" )) )  {
		bu_log("rt_ebm_import() unable to open '%s'\n", eip->file);
		bu_free( (char *)eip , "rt_ebm_import: eip" );
fail:
		ip->idb_type = ID_NULL;
		ip->idb_ptr = (genptr_t)NULL;
		return -1;
	}
	eip->mp = mp;
	if( mp->buflen < eip->xdim*eip->ydim )  {
		bu_log("rt_ebm_import() file '%s' is too short %d < %d\n",
			eip->file, mp->buflen, eip->xdim*eip->ydim );
		goto fail;
	}

	nbytes = (eip->xdim+BIT_XWIDEN*2)*(eip->ydim+BIT_YWIDEN*2);

	/* If first use of this file, prepare in-memory buffer */
	if( !mp->apbuf )  {
		register int	y;
		unsigned char	*cp;

		/* Prevent a multi-processor race */
		bu_semaphore_acquire(RT_SEM_MODEL);
		if( mp->apbuf )  {
			/* someone else beat us, nothing more to do */
			bu_semaphore_release(RT_SEM_MODEL);
			return 0;
		}
		mp->apbuf = (genptr_t)bu_calloc(
			1, nbytes, "rt_ebm_import bitmap" );
		mp->apbuflen = nbytes;

		bu_semaphore_release(RT_SEM_MODEL);

		/* Because of in-memory padding, read each scanline separately */
		cp = (unsigned char *)mp->buf;
		for( y=0; y < eip->ydim; y++ )  {
			/* BIT() addresses into mp->apbuf */
			bcopy( cp, &BIT( eip, 0, y), eip->xdim );
			cp += eip->xdim;
		}
	}
	return( 0 );
}

/*
 *			R T _ E B M _ E X P O R T
 *
 *  The name will be added by the caller.
 */
int
rt_ebm_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
{
	struct rt_ebm_internal	*eip;
	struct rt_ebm_internal	ebm;	/* scaled version */
	union record		*rec;
	struct bu_vls		str;

	RT_CK_DB_INTERNAL(ip);
	if( ip->idb_type != ID_EBM )  return(-1);
	eip = (struct rt_ebm_internal *)ip->idb_ptr;
	RT_EBM_CK_MAGIC(eip);
	ebm = *eip;			/* struct copy */

	/* Apply scale factor */
	ebm.mat[15] /= local2mm;

	BU_CK_EXTERNAL(ep);
	ep->ext_nbytes = sizeof(union record)*DB_SS_NGRAN;
	ep->ext_buf = (genptr_t)bu_calloc( 1, ep->ext_nbytes, "ebm external");
	rec = (union record *)ep->ext_buf;

	bu_vls_init( &str );
	bu_vls_struct_print( &str, rt_ebm_parse, (char *)&ebm );

	rec->ss.ss_id = DBID_STRSOL;
	strncpy( rec->ss.ss_keyword, "ebm", NAMESIZE-1 );
	strncpy( rec->ss.ss_args, bu_vls_addr(&str), DB_SS_LEN-1 );
	bu_vls_free( &str );

	return(0);
}


/*
 *			R T _ E B M _ I M P O R T 5
 *
 *  Read in the information from the string solid record.
 *  Then, as a service to the application, read in the bitmap
 *  and set up some of the associated internal variables.
 */
int
rt_ebm_import5(struct rt_db_internal *ip, const struct bu_external *ep, const fastf_t *mat, const struct db_i *dbip)
{
	register struct rt_ebm_internal *eip;
	struct bu_vls	str;
	int		nbytes;
	mat_t		tmat;
	struct bu_mapped_file	*mp;

	BU_CK_EXTERNAL( ep );
	RT_CK_DB_INTERNAL( ip );

	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_EBM;
	ip->idb_meth = &rt_functab[ID_EBM];
	ip->idb_ptr = bu_calloc(1, sizeof(struct rt_ebm_internal), "rt_ebm_internal");
	eip = (struct rt_ebm_internal *)ip->idb_ptr;
	eip->magic = RT_EBM_INTERNAL_MAGIC;

	/* Provide default orientation info */
	MAT_IDN( eip->mat );

	bu_vls_init( &str );
	bu_vls_strcpy( &str, ep->ext_buf );
	if( bu_struct_parse( &str, rt_ebm_parse, (char *)eip ) < 0 )  {
		bu_vls_free( &str );
		bu_free( (char *)eip , "rt_ebm_import: eip" );
		ip->idb_type = ID_NULL;
		ip->idb_ptr = (genptr_t)NULL;
		return -2;
	}
	bu_vls_free( &str );

	/* Check for reasonable values */
	if( eip->file[0] == '\0' || eip->xdim < 1 ||
	    eip->ydim < 1 || eip->mat[15] <= 0.0 ||
	    eip->tallness <= 0.0 )  {
	    	bu_struct_print( "Unreasonable EBM parameters", rt_ebm_parse,
	    		(char *)eip );
	    	bu_free( (char *)eip , "rt_ebm_import: eip" );
	    	ip->idb_type = ID_NULL;
	    	ip->idb_ptr = (genptr_t)NULL;
		return -1;
	}

	/* Apply any modeling transforms to get final matrix */
	bn_mat_mul( tmat, mat, eip->mat );
	MAT_COPY( eip->mat, tmat );

	/* Get bit map from .bw(5) file */
	if( !(mp = bu_open_mapped_file_with_path( dbip->dbi_filepath, eip->file, "ebm" )) )  {
		bu_log("rt_ebm_import() unable to open '%s'\n", eip->file);
		bu_free( (char *)eip , "rt_ebm_import: eip" );
fail:
		ip->idb_type = ID_NULL;
		ip->idb_ptr = (genptr_t)NULL;
		return -1;
	}
	eip->mp = mp;
	if( mp->buflen < eip->xdim*eip->ydim )  {
		bu_log("rt_ebm_import() file '%s' is too short %d < %d\n",
			eip->file, mp->buflen, eip->xdim*eip->ydim );
		goto fail;
	}

	nbytes = (eip->xdim+BIT_XWIDEN*2)*(eip->ydim+BIT_YWIDEN*2);

	/* If first use of this file, prepare in-memory buffer */
	if( !mp->apbuf )  {
		register int	y;
		unsigned char	*cp;

		/* Prevent a multi-processor race */
		bu_semaphore_acquire(RT_SEM_MODEL);
		if( mp->apbuf )  {
			/* someone else beat us, nothing more to do */
			bu_semaphore_release(RT_SEM_MODEL);
			return 0;
		}
		mp->apbuf = (genptr_t)bu_calloc(
			1, nbytes, "rt_ebm_import bitmap" );
		mp->apbuflen = nbytes;

		bu_semaphore_release(RT_SEM_MODEL);

		/* Because of in-memory padding, read each scanline separately */
		cp = (unsigned char *)mp->buf;
		for( y=0; y < eip->ydim; y++ )  {
			/* BIT() addresses into mp->apbuf */
			bcopy( cp, &BIT( eip, 0, y), eip->xdim );
			cp += eip->xdim;
		}
	}
	return( 0 );
}

/*
 *			R T _ E B M _ E X P O R T 5
 *
 *  The name will be added by the caller.
 */
int
rt_ebm_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
{
	struct rt_ebm_internal	*eip;
	struct rt_ebm_internal	ebm;	/* scaled version */
	struct bu_vls		str;

	RT_CK_DB_INTERNAL(ip);
	if( ip->idb_type != ID_EBM )  return(-1);
	eip = (struct rt_ebm_internal *)ip->idb_ptr;
	RT_EBM_CK_MAGIC(eip);
	ebm = *eip;			/* struct copy */

	/* Apply scale factor */
	ebm.mat[15] /= local2mm;

	BU_CK_EXTERNAL(ep);

	bu_vls_init( &str );
	bu_vls_struct_print( &str, rt_ebm_parse, (char *)&ebm );

	ep->ext_nbytes = bu_vls_strlen( &str ) + 1;
	ep->ext_buf = (genptr_t)bu_calloc( 1, ep->ext_nbytes, "ebm external");

	strcpy( ep->ext_buf , bu_vls_addr(&str) );
	bu_vls_free( &str );

	return(0);
}

/*
 *			R T _ E B M _ D E S C R I B E
 *
 *  Make human-readable formatted presentation of this solid.
 *  First line describes type of solid.
 *  Additional lines are indented one tab, and give parameter values.
 */
int
rt_ebm_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
{
	register struct rt_ebm_internal	*eip =
		(struct rt_ebm_internal *)ip->idb_ptr;
	int i;
	struct bu_vls substr;

	RT_EBM_CK_MAGIC(eip);

	bu_vls_init( &substr );
	bu_vls_strcat( str, "extruded bitmap (EBM)\n\t");

/*	bu_vls_struct_print( str, rt_ebm_parse, (char *)eip );
	bu_vls_strcat( str, "\n" );	*/

	bu_vls_printf( &substr, "  file=\"%s\" w=%d n=%d depth=%g\n   mat=",
		eip->file, eip->xdim, eip->ydim, eip->tallness*mm2local );
	bu_vls_vlscat( str, &substr );
	for( i=0 ; i<15 ; i++ )
	{
		bu_vls_trunc2( &substr, 0 );
		bu_vls_printf( &substr, "%g,", eip->mat[i] );
		bu_vls_vlscat( str, &substr );
	}
	bu_vls_trunc2( &substr, 0 );
	bu_vls_printf( &substr, "%g\n", eip->mat[15] );
	bu_vls_vlscat( str, &substr );

	bu_vls_free( &substr );

	return(0);
}

/*
 *			R T _ E B M _ I F R E E
 *
 *  Free the storage associated with the rt_db_internal version of this solid.
 */
void
rt_ebm_ifree(struct rt_db_internal *ip)
{
	register struct rt_ebm_internal	*eip;

	RT_CK_DB_INTERNAL(ip);
	eip = (struct rt_ebm_internal *)ip->idb_ptr;
	RT_EBM_CK_MAGIC(eip);

	if(eip->mp)  {
		BU_CK_MAPPED_FILE(eip->mp);
		bu_close_mapped_file(eip->mp);
	}

	eip->magic = 0;			/* sanity */
	eip->mp = (struct bu_mapped_file *)0;
	bu_free( (char *)eip, "ebm ifree" );
	ip->idb_ptr = GENPTR_NULL;	/* sanity */
	ip->idb_type = ID_NULL;		/* sanity */
}

/*
 *			R T _ E B M _ P R E P
 *
 *  Returns -
 *	0	OK
 *	!0	Failure
 *
 *  Implicit return -
 *	A struct rt_ebm_specific is created, and it's address is stored
 *	in stp->st_specific for use by rt_ebm_shot().
 */
int
rt_ebm_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
{
	struct rt_ebm_internal	*eip;
	register struct rt_ebm_specific *ebmp;
	vect_t	norm;
	vect_t	radvec;
	vect_t	diam;
	vect_t	small1;

	eip = (struct rt_ebm_internal *)ip->idb_ptr;
	RT_EBM_CK_MAGIC(eip);

	BU_GETSTRUCT( ebmp, rt_ebm_specific );
	ebmp->ebm_i = *eip;		/* struct copy */

	/* "steal" the bitmap storage */
	eip->mp = (struct bu_mapped_file *)0;	/* "steal" the mapped file */

	/* build Xform matrix from model(world) to ideal(local) space */
	bn_mat_inv( ebmp->ebm_mat, eip->mat );

	/* Pre-compute the necessary normals.  Rotate only. */
	VSET( norm, 1, 0 , 0 );
	MAT3X3VEC( ebmp->ebm_xnorm, eip->mat, norm );
	VSET( norm, 0, 1, 0 );
	MAT3X3VEC( ebmp->ebm_ynorm, eip->mat, norm );
	VSET( norm, 0, 0, 1 );
	MAT3X3VEC( ebmp->ebm_znorm, eip->mat, norm );

	stp->st_specific = (genptr_t)ebmp;

	/* Find bounding RPP of rotated local RPP */
	VSETALL( small1, 0 );
	VSET( ebmp->ebm_large, ebmp->ebm_i.xdim, ebmp->ebm_i.ydim, ebmp->ebm_i.tallness );
	bn_rotate_bbox( stp->st_min, stp->st_max, eip->mat,
		small1, ebmp->ebm_large );

	/* for now, EBM origin in ideal coordinates is at origin */
	VSETALL( ebmp->ebm_origin, 0 );
	VADD2( ebmp->ebm_large, ebmp->ebm_large, ebmp->ebm_origin );

	/* for now, EBM cell size in ideal coordinates is one unit/cell */
	VSETALL( ebmp->ebm_cellsize, 1 );

	VSUB2( diam, stp->st_max, stp->st_min );
	VADD2SCALE( stp->st_center, stp->st_min, stp->st_max, 0.5 );
	VSCALE( radvec, diam, 0.5 );
	stp->st_aradius = stp->st_bradius = MAGNITUDE( radvec );

	return(0);		/* OK */
}

/*
 *			R T _ E B M _ P R I N T
 */
void
rt_ebm_print(register const struct soltab *stp)
{
	register const struct rt_ebm_specific *ebmp =
		(struct rt_ebm_specific *)stp->st_specific;

	bu_log("ebm file = %s\n", ebmp->ebm_i.file );
	bu_log("dimensions = (%d, %d, %g)\n",
		ebmp->ebm_i.xdim, ebmp->ebm_i.ydim,
		ebmp->ebm_i.tallness );
	VPRINT("model cellsize", ebmp->ebm_cellsize);
	VPRINT("model grid origin", ebmp->ebm_origin);
}

/*
 *			R T _ E B M _ S H O T
 *
 *  Intersect a ray with an extruded bitmap.
 *  If intersection occurs, a pointer to a sorted linked list of
 *  "struct seg"s will be returned.
 *
 *  Returns -
 *	0	MISS
 *	>0	HIT
 */
int
rt_ebm_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
{
	register struct rt_ebm_specific *ebmp =
		(struct rt_ebm_specific *)stp->st_specific;
	vect_t		norm;
	struct xray	ideal_ray;
	struct seg	myhead;
	int		i;

	BU_LIST_INIT( &(myhead.l) );

	/* Transform actual ray into ideal space at origin in X-Y plane */
	MAT4X3PNT( ideal_ray.r_pt, ebmp->ebm_mat, rp->r_pt );
	MAT4X3VEC( ideal_ray.r_dir, ebmp->ebm_mat, rp->r_dir );

#if 0
bu_log("%g %g %g %g %g %g\n",
ideal_ray.r_pt[X], ideal_ray.r_pt[Y], ideal_ray.r_pt[Z],
ideal_ray.r_dir[X], ideal_ray.r_dir[Y], ideal_ray.r_dir[Z] );
#endif
	if( rt_ebm_dda( &ideal_ray, stp, ap, &myhead ) <= 0 )
		return(0);

	VSET( norm, 0, 0, -1 );		/* letters grow in +z, which is "inside" the halfspace */
	i = rt_seg_planeclip( seghead, &myhead, norm, 0.0, ebmp->ebm_i.tallness,
		&ideal_ray, ap );
#if 0
	if( segp )  {
		vect_t	a, b;
		/* Plot where WE think the ray goes */
		VJOIN1( a, rp->r_pt, segp->seg_in.hit_dist, rp->r_dir );
		VJOIN1( b, rp->r_pt, segp->seg_out.hit_dist, rp->r_dir );
		pl_color( stdout, 0, 0, 255 );	/* B */
		pdv_3line( stdout, a, b );
	}
#endif
	return(i);
}

/*
 *			R T _ E B M _ N O R M
 *
 *  Given one ray distance, return the normal and
 *  entry/exit point.
 *  This is mostly a matter of translating the stored
 *  code into the proper normal.
 */
void
rt_ebm_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
{
	register struct rt_ebm_specific *ebmp =
		(struct rt_ebm_specific *)stp->st_specific;

	VJOIN1( hitp->hit_point, rp->r_pt, hitp->hit_dist, rp->r_dir );

	switch( hitp->hit_surfno )  {
	case NORM_XPOS:
		VMOVE( hitp->hit_normal, ebmp->ebm_xnorm );
		break;
	case NORM_XNEG:
		VREVERSE( hitp->hit_normal, ebmp->ebm_xnorm );
		break;

	case NORM_YPOS:
		VMOVE( hitp->hit_normal, ebmp->ebm_ynorm );
		break;
	case NORM_YNEG:
		VREVERSE( hitp->hit_normal, ebmp->ebm_ynorm );
		break;

	case NORM_ZPOS:
		VMOVE( hitp->hit_normal, ebmp->ebm_znorm );
		break;
	case NORM_ZNEG:
		VREVERSE( hitp->hit_normal, ebmp->ebm_znorm );
		break;

	default:
		bu_log("ebm_norm(%s): surfno=%d bad\n",
			stp->st_name, hitp->hit_surfno );
		VSETALL( hitp->hit_normal, 0 );
		break;
	}
}

/*
 *			R T _ E B M _ C U R V E
 *
 *  Everything has sharp edges.  This makes things easy.
 */
void
rt_ebm_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
{
/*	register struct rt_ebm_specific *ebmp =
		(struct rt_ebm_specific *)stp->st_specific; */

	bn_vec_ortho( cvp->crv_pdir, hitp->hit_normal );
	cvp->crv_c1 = cvp->crv_c2 = 0;
}

/*
 *			R T _ E B M _ U V
 *
 *  Map the hit point in 2-D into the range 0..1
 *  untransformed X becomes U, and Y becomes V.
 */
void
rt_ebm_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
{
	uvp->uv_u = hitp->hit_vpriv[X];
	uvp->uv_v = hitp->hit_vpriv[Y];

	/* XXX should compute this based upon footprint of ray in ebm space */
	uvp->uv_du = 0.0;
	uvp->uv_dv = 0.0;
}

/*
 * 			R T _ E B M _ F R E E
 */
void
rt_ebm_free(struct soltab *stp)
{
	register struct rt_ebm_specific *ebmp =
		(struct rt_ebm_specific *)stp->st_specific;

	BU_CK_MAPPED_FILE(ebmp->ebm_i.mp);
	bu_close_mapped_file(ebmp->ebm_i.mp);

	bu_free( (char *)ebmp, "rt_ebm_specific" );
}

int
rt_ebm_class(void)
{
	return(0);
}

/*
 *			R T _ E B M _ P L O T
 */
int
rt_ebm_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
	register struct rt_ebm_internal *eip;
	register int	x,y;
	register int	following;
	register int	base;
/*	int		i; */

	RT_CK_DB_INTERNAL(ip);
	eip = (struct rt_ebm_internal *)ip->idb_ptr;
	RT_EBM_CK_MAGIC(eip);

	/* Find vertical lines */
	base = 0;	/* lint */
	for( x=0; x <= eip->xdim; x++ )  {
		following = 0;
		for( y=0; y <= eip->ydim; y++ )  {
			if( following )  {
				if( (BIT( eip, x-1, y )==0) != (BIT( eip, x, y )==0) )
					continue;
				rt_ebm_plate( x, base, x, y, eip->tallness,
					eip->mat, vhead );
				following = 0;
			} else {
				if( (BIT( eip, x-1, y )==0) == (BIT( eip, x, y )==0) )
					continue;
				following = 1;
				base = y;
			}
		}
	}

	/* Find horizontal lines */
	for( y=0; y <= eip->ydim; y++ )  {
		following = 0;
		for( x=0; x <= eip->xdim; x++ )  {
			if( following )  {
				if( (BIT( eip, x, y-1 )==0) != (BIT( eip, x, y )==0) )
					continue;
				rt_ebm_plate( base, y, x, y, eip->tallness,
					eip->mat, vhead );
				following = 0;
			} else {
				if( (BIT( eip, x, y-1 )==0) == (BIT( eip, x, y )==0) )
					continue;
				following = 1;
				base = x;
			}
		}
	}
	return(0);
}

/* either x1==x2, or y1==y2 */
void
rt_ebm_plate(int x1, int y1, int x2, int y2, double t, register fastf_t *mat, register struct bu_list *vhead)
{
	LOCAL point_t	s, p;
	LOCAL point_t	srot, prot;

	VSET( s, x1, y1, 0.0 );
	MAT4X3PNT( srot, mat, s );
	RT_ADD_VLIST( vhead, srot, BN_VLIST_LINE_MOVE );

	VSET( p, x1, y1, t );
	MAT4X3PNT( prot, mat, p );
	RT_ADD_VLIST( vhead, prot, BN_VLIST_LINE_DRAW );

	VSET( p, x2, y2, t );
	MAT4X3PNT( prot, mat, p );
	RT_ADD_VLIST( vhead, prot, BN_VLIST_LINE_DRAW );

	p[Z] = 0;
	MAT4X3PNT( prot, mat, p );
	RT_ADD_VLIST( vhead, prot, BN_VLIST_LINE_DRAW );

	RT_ADD_VLIST( vhead, srot, BN_VLIST_LINE_DRAW );
}

struct ebm_edge
{
	struct bu_list	l;
	int		x1,y1;
	int		x2,y2;
	int		left;	/* 1=>material to left, 0=>material to right */
	struct vertex	*v;	/* vertex at x1,y1 */
};

/* either x1==x2, or y1==y2 */
static void
rt_ebm_edge(int x1, int y1, int x2, int y2, int left, struct ebm_edge *edges)
{
	struct ebm_edge *new_edge;

	new_edge = (struct ebm_edge *)bu_malloc( sizeof( struct ebm_edge ) , "rt_ebm_tess: new_edge" );	

	/* make all edges go from lower values to larger */
	if( y1 < y2 || x1 < x2 )
	{
		new_edge->x1 = x1;
		new_edge->y1 = y1;
		new_edge->x2 = x2;
		new_edge->y2 = y2;
		new_edge->left = left;
	}
	else
	{
		new_edge->x1 = x2;
		new_edge->y1 = y2;
		new_edge->x2 = x1;
		new_edge->y2 = y1;
		new_edge->left = (!left);
	}
	new_edge->v = (struct vertex *)NULL;
	BU_LIST_APPEND( &edges->l , &new_edge->l );
}

static int
rt_ebm_sort_edges(struct ebm_edge *edges)
{
	struct ebm_edge loops;
	int vertical;
	int done;
	int from_x,from_y,to_x,to_y;
	int start_x,start_y;
	int max_loop_length=0;
	int loop_length;

	/* create another list to hold the edges as they are sorted */
	BU_LIST_INIT( &loops.l );

	while( BU_LIST_NON_EMPTY( &edges->l ) )
	{
		struct ebm_edge *start,*next;

		/* look for a vertical edge starting in lower left (smallest x and y ) */
		start = (struct ebm_edge *)NULL;
		next = BU_LIST_FIRST( ebm_edge , &edges->l );
		while( BU_LIST_NOT_HEAD( &next->l , &edges->l ) )
		{
			if( next->x1 != next->x2 )
			{
				next = BU_LIST_PNEXT( ebm_edge , &next->l );
				continue;	/* not a vertical edge */
			}

			if( !start )
				start = next;
			else if( next->x1 < start->x1 || next->y1 < start->y1 )
				start = next;

			next = BU_LIST_PNEXT( ebm_edge , &next->l );
		}

		if( !start )
			rt_bomb( "rt_ebm_tess: rt_ebm_sort_edges: no vertical edges left!\n" );

		/* put starting edge on the loop list */
		BU_LIST_DEQUEUE( &start->l );
		BU_LIST_INSERT( &loops.l , &start->l );

		next = (struct ebm_edge *)NULL;
		vertical = 0; 	/* look for horizontal edge */
		done = 0;
		to_x = start->x2;
		to_y = start->y2;
		from_x = start->x1;
		from_y = start->y1;
		start_x = from_x;
		start_y = from_y;
		loop_length = 1;
		while( !done )
		{
			struct ebm_edge *e,*e_poss[2];
			int poss;

			/* now find an edge that starts where this one stops (at to_x,to_y) */
			poss = 0;
			for( BU_LIST_FOR( e , ebm_edge , &edges->l ) )
			{
				if( (vertical && e->y1 == e->y2) ||
				   (!vertical && e->x1 == e->x2) )
					continue;

				if( (e->x1 == to_x && e->y1 == to_y) ||
				    (e->x2 == to_x && e->y2 == to_y) )
					e_poss[poss++] = e;
				if( poss > 2 )
					rt_bomb( "rt_ebm_tess: rt_ebm_sort_edges: too many edges at one point\n" );
			}

			if( poss == 0 )
				rt_bomb( "rt_ebm_tess: rt_ebm_sort_edges: no edge to continue loop\n" );
			if( poss == 1 )
			{
				next = e_poss[0];
			}
			else
			{
				/* must choose between two possibilities */
				if( vertical )
				{
					if( to_x < from_x )
					{
						if( e_poss[0]->y1 > to_y || e_poss[0]->y2 > to_y )
							next = e_poss[0];
						else
							next = e_poss[1];
					}
					else
					{
						if( e_poss[0]->y1 < to_y || e_poss[0]->y2 < to_y )
							next = e_poss[0];
						else
							next = e_poss[1];
					}
				}
				else
				{
					if( to_y < from_y )
					{
						if( e_poss[0]->x1 < to_x || e_poss[0]->x2 < to_x )
							next = e_poss[0];
						else
							next = e_poss[1];
					}
					else
					{
						if( e_poss[0]->x1 > to_x || e_poss[0]->x2 > to_x )
							next = e_poss[0];
						else
							next = e_poss[1];
					}
				}
			}

			if( next->x2 == to_x && next->y2 == to_y )
			{
				/* reverse direction of edge */
				next->x2 = next->x1;
				next->y2 = next->y1;
				next->x1 = to_x;
				next->y1 = to_y;
				next->left = (!next->left);
			}
			to_x = next->x2;
			to_y = next->y2;
			from_x = next->x1;
			from_y = next->y1;
			loop_length++;

			BU_LIST_DEQUEUE( &next->l );
			BU_LIST_INSERT( &loops.l , &next->l );

			if( to_x == start_x && to_y == start_y )
			{
				if( loop_length > max_loop_length )
					max_loop_length = loop_length;
				done = 1;	/* complete loop */
			}

			if( vertical )
				vertical = 0;
			else
				vertical = 1;
		}
	}

	/* move sorted list back to "edges" */
	BU_LIST_INSERT_LIST( &edges->l , &loops.l );

	return( max_loop_length );
}

/*
 *			R T _ E B M _ T E S S
 */
int
rt_ebm_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
	struct rt_ebm_internal	*eip;
	struct shell	*s;
	struct faceuse	*fu=(struct faceuse*)NULL;
	register int	i; 
	struct vertex	***vertp;	/* dynam array of ptrs to pointers */
	struct vertex	**loop_verts;
	struct ebm_edge	edges;		/* list of edges */
	struct ebm_edge *e,*start_loop;
	int		start,x,y,left;
	int		max_loop_length;
	int		loop_length;
	vect_t		height,h;

	BN_CK_TOL( tol );
	NMG_CK_MODEL( m );

	RT_CK_DB_INTERNAL(ip);
	eip = (struct rt_ebm_internal *)ip->idb_ptr;
	RT_EBM_CK_MAGIC(eip);

	BU_LIST_INIT( &edges.l );

	x = 0;
	while( x <= eip->xdim )
	{
		y = 0;
		while( y <= eip->ydim )
		{
			if( (BIT( eip , x-1 , y ) == 0 ) != (BIT( eip , x , y ) == 0 ) )
			{
				/* a vertical edge starts here */
				start = y;
				left = (BIT( eip , x , y ) != 0 );

				/* find other end */
				while( (BIT( eip , x-1 , y ) == 0 ) != (BIT( eip , x , y ) == 0 ) &&
					(BIT( eip , x , y ) != 0 ) == left )
						y++;
				rt_ebm_edge( x , start , x , y , left , &edges );
			}
			else
				y++;
		}
		x++;
	}

	y = 0;
	while( y <= eip->ydim )
	{
		x = 0;
		while( x <= eip->xdim )
		{
			if( (BIT( eip, x, y-1 )==0) != (BIT( eip, x, y )==0) )
			{
				/* a horizontal edge starts here */
				start = x;
				left = (BIT( eip , x , y-1 ) != 0 );

				/* find other end */
				while( (BIT( eip, x, y-1 )==0) != (BIT( eip, x, y )==0) &&
					(BIT( eip , x , y-1 ) != 0 ) == left )
						x++;
				rt_ebm_edge( start , y , x , y , left , &edges );
			}
			else
				x++;
		}
		y++;
	}

	/* Sort edges into loops */
	max_loop_length = rt_ebm_sort_edges( &edges );

	/* Make NMG structures */
	
	/* make region, shell, vertex */
	*r = nmg_mrsv( m );
	s = BU_LIST_FIRST(shell, &(*r)->s_hd);


	vertp = (struct vertex ***)bu_calloc( max_loop_length , sizeof( struct vertex **) ,
		"rt_ebm_tess: vertp" );
	loop_verts = (struct vertex **)bu_calloc( max_loop_length , sizeof( struct vertex *),
		"rt_ebm_tess: loop_verts" );

	e = BU_LIST_FIRST( ebm_edge , &edges.l );
	while( BU_LIST_NOT_HEAD( &e->l , &edges.l ) )
	{
		start_loop = e;
		loop_length = 0;
		vertp[loop_length++] = &start_loop->v;

		e = BU_LIST_PNEXT( ebm_edge , &start_loop->l );
		while( BU_LIST_NOT_HEAD( &e->l , &edges.l ) )
		{
			vertp[loop_length++] = &e->v;
			if( e->x2 == start_loop->x1 && e->y2 == start_loop->y1 )
			{
				struct faceuse *fu1;
				struct ebm_edge *e1;
				point_t pt_ebm,pt_model;
				int done=0;

				if( e->left )
				{
					/* make a face */
					fu1 = nmg_cmface( s , vertp , loop_length );
					NMG_CK_FACEUSE( fu1 );

					/* assign geometry to the vertices used in this face */
					e1 = start_loop;
					while( !done )
					{
						if( e1->v )
						{
							VSET( pt_ebm , e1->x1 , e1->y1 , 0.0 );
							MAT4X3PNT( pt_model , eip->mat , pt_ebm );
							nmg_vertex_gv( e1->v , pt_model );
						}
						if( e1 == e )
							done = 1;
						else
							e1 = BU_LIST_PNEXT( ebm_edge , &e1->l );
					}

					/* assign face geometry */
					if( nmg_fu_planeeqn( fu1 , tol ) )
						goto fail;

					if( !fu )
						fu = fu1;
				}
				else
				{
					/* make a hole */
					for( i=0 ; i<loop_length ; i++ )
					{
						if( *vertp[loop_length-i-1] )
							loop_verts[i] = (*vertp[loop_length-i-1]);
						else
							loop_verts[i] = (struct vertex *)NULL;
					}

					(void) nmg_add_loop_to_face( s , fu , loop_verts ,
							loop_length , OT_OPPOSITE );

					/* Assign geometry to new vertices */
					done = 0;	
					e1 = start_loop;
					i = loop_length - 1;
					while( !done )
					{
						if( !loop_verts[i]->vg_p )
						{
							VSET( pt_ebm , e1->x1 , e1->y1 , 0.0 );
							MAT4X3PNT( pt_model , eip->mat , pt_ebm );
							nmg_vertex_gv( loop_verts[i] , pt_model );
							e1->v = loop_verts[i];
						}
						if( e1 == e )
							done = 1;
						else
						{
							e1 = BU_LIST_PNEXT( ebm_edge , &e1->l );
							i--;
						}
					}
				}
				break;
			}
			e = BU_LIST_PNEXT( ebm_edge , &e->l );
		}
		e = BU_LIST_PNEXT( ebm_edge , &e->l );
	}

	/* all faces should merge into one */
	nmg_shell_coplanar_face_merge( s , tol , 1 );

	fu = BU_LIST_FIRST( faceuse , &s->fu_hd );
	NMG_CK_FACEUSE( fu );

	VSET( h , 0.0 , 0.0 , eip->tallness );
	MAT4X3VEC( height , eip->mat , h );

	nmg_extrude_face( fu , height , tol );

	nmg_region_a( *r , tol );

	(void)nmg_mark_edges_real( &s->l.magic );

	bu_free( (char *)vertp , "rt_ebm_tess: vertp" );
	bu_free( (char *)loop_verts , "rt_ebm_tess: loop_verts" );
	while( BU_LIST_NON_EMPTY( &edges.l ) )
	{
		e = BU_LIST_FIRST( ebm_edge , &edges.l );
		BU_LIST_DEQUEUE( &e->l );
		bu_free( (char *)e , "rt_ebm_tess: e" );
	}
	return( 0 );

fail:
	bu_free( (char *)vertp , "rt_ebm_tess: vertp" );
	bu_free( (char *)loop_verts , "rt_ebm_tess: loop_verts" );
	while( BU_LIST_NON_EMPTY( &edges.l ) )
	{
		e = BU_LIST_FIRST( ebm_edge , &edges.l );
		BU_LIST_DEQUEUE( &e->l );
		bu_free( (char *)e , "rt_ebm_tess: e" );
	}

	return(-1);
}

/******** Test Driver *********/
#ifdef TEST_DRIVER

FILE			*plotfp;

struct soltab		Tsolid;
struct directory	Tdir;
struct application	Tappl;
struct rt_ebm_specific	*bmsp;
struct resource		resource;
mat_t			Tmat;

main( argc, argv )
int	argc;
char	**argv;
{
	point_t	pt1;
	point_t	pt2;
	register int	x, y;
	fastf_t		xx, yy;
	mat_t		mat;
	register struct rt_ebm_specific	*ebmp;
	int		arg;
	FILE		*fp;
	union record	rec;

	if( argc > 1 )  {
		rt_g.debug |= DEBUG_EBM;
		arg = atoi(argv[1]);
	}

	plotfp = fopen( "ebm.pl", "w" );

	RT_DIR_SET_NAMEP(&Tdir, "Tsolid");
	Tsolid.st_dp = &Tdir;
	Tappl.a_purpose = "testing";
	Tappl.a_resource = &resource;
	Tsolid.st_matp = &Tmat;
	MAT_IDN( Tsolid.st_matp );

	strcpy( rec.ss.ss_keyword, "ebm" );
	strcpy( rec.ss.ss_args, "file=bm.bw w=6 n=6 d=6.0" );

	if( rt_ebm_prep( &Tsolid, &rec, 0 ) != 0 )  {
		printf("prep failed\n");
		exit(1);
	}
	rt_ebm_print( &Tsolid );
	ebmp = bmsp = (struct rt_ebm_specific *)Tsolid.st_specific;

	outline( Tsolid.st_matp, &rec );

#if 1
	if( (fp = fopen("ebm.rays", "r")) == NULL )  {
		perror("ebm.rays");
		exit(1);
	}
	for(;;)  {
		x = fscanf( fp, "%lf %lf %lf %lf %lf %lf\n",
			&pt1[X], &pt1[Y], &pt1[Z],
			&pt2[X], &pt2[Y], &pt2[Z] );
		if( x < 6 )  break;
		VADD2( pt2, pt2, pt1 );
		trial( pt1, pt2 );
	}
#endif
#if 0
	y = arg;
	for( x=0; x<=ebmp->ebm_i.xdim; x++ )  {
		VSET( pt1, 0, y, 1 );
		VSET( pt2, x, 0, 1 );
		trial( pt1, pt2 );
	}
#endif
#if 0
	y = arg;
	for( x=0; x<=ebmp->ebm_i.xdim; x++ )  {
		VSET( pt1, 0, y, 2 );
		VSET( pt2, x, 0, 4 );
		trial( pt1, pt2 );
	}
#endif
#if 0
	for( y=0; y<=ebmp->ebm_i.ydim; y++ )  {
		for( x=0; x<=ebmp->ebm_i.xdim; x++ )  {
			VSET( pt1, 0, y, 2 );
			VSET( pt2, x, 0, 4 );
			trial( pt1, pt2 );
		}
	}
#endif
#if 0
	for( y= -1; y<=ebmp->ebm_i.ydim; y++ )  {
		for( x= -1; x<=ebmp->ebm_i.xdim; x++ )  {
			VSET( pt1, x, y, 10 );
			VSET( pt2, x+2, y+3, -4 );
			trial( pt1, pt2 );
		}
	}
#endif
#if 0
	for( y=0; y<=ebmp->ebm_i.ydim; y++ )  {
		for( x=0; x<=ebmp->ebm_i.xdim; x++ )  {
			VSET( pt1, ebmp->ebm_i.xdim, y, 2 );
			VSET( pt2, x, ebmp->ebm_i.ydim, 4 );
			trial( pt1, pt2 );
		}
	}
#endif

#if 0
	for( yy = 2.0; yy < 6.0; yy += 0.3 )  {
		VSET( pt1, 0, yy, 2 );
		VSET( pt2, 6, 0, 4 );
		trial( pt1, pt2 );
	}
#endif
#if 0
	for( yy=0; yy<=ebmp->ebm_i.ydim; yy += 0.3 )  {
		for( xx=0; xx<=ebmp->ebm_i.xdim; xx += 0.3 )  {
			VSET( pt1, 0, yy, 2 );
			VSET( pt2, xx, 0, 4 );
			trial( pt1, pt2 );
		}
	}
#endif
#if 0
	for( yy=0; yy<=ebmp->ebm_i.ydim; yy += 0.3 )  {
		for( xx=0; xx<=ebmp->ebm_i.xdim; xx += 0.3 )  {
			VSET( pt1, ebmp->ebm_i.xdim, yy, 2 );
			VSET( pt2, xx, ebmp->ebm_i.ydim, 4 );
			trial( pt1, pt2 );
		}
	}
#endif

#if 0
	/* (6,5) (2,5) (3,4) (1.2,1.2)
	 * were especially troublesome */
	xx=6;
	yy=1.5;
	VSET( pt1, 0, yy, 2 );
	VSET( pt2, xx, 0, 4 );
	trial( pt1, pt2 );
#endif

#if 0
	/* (1,2) (3,2) (0,2) (0,0.3)
	 * were especially troublesome */
	xx=0;
	yy=0.3;
	VSET( pt1, ebmp->ebm_i.xdim, yy, 2 );
	VSET( pt2, xx, ebmp->ebm_i.ydim, 4 );
	trial( pt1, pt2 );
#endif

#if 0
	VSET( pt1, 0, 1.5, 2 );
	VSET( pt2, 4.75, 6, 4 );
	trial( pt1, pt2 );

	VSET( pt1, 0, 2.5, 2 );
	VSET( pt2, 4.5, 0, 4 );
	trial( pt1, pt2 );
#endif


#if 0
	/* With Z=-10, it works, but looks like trouble, due to
	 * the Z-clipping causing lots of green vectors on the 2d proj.
	 * VSET( pt1, 0.75, 1.1, -10 );
	 */
	VSET( pt1, 0.75, 1.1, 0 );
	{
		for( yy=0; yy<=ebmp->ebm_i.ydim; yy += 0.3 )  {
			for( xx=0; xx<=ebmp->ebm_i.xdim; xx += 0.3 )  {
				VSET( pt2, xx, yy, 4 );
				trial( pt1, pt2 );
			}
		}
	}
#endif
#if 0
	for( x=0; x<ebmp->ebm_i.xdim; x++ )  {
		VSET( pt1, x+0.75, 1.1, -10 );
		VSET( pt2, x+0.75, 1.1, 4 );
		trial( pt1, pt2 );
	}
#endif

	exit(0);
}

trial(p1, p2)
vect_t	p1, p2;
{
	struct seg	*segp, *next;
	fastf_t		lastk;
	struct xray	ray;
	register struct rt_ebm_specific *ebmp = bmsp;

	VMOVE( ray.r_pt, p1 );
	VSUB2( ray.r_dir, p2, p1 );
	if( MAGNITUDE( ray.r_dir ) < 1.0e-10 )
		return;
	VUNITIZE( ray.r_dir );

	printf("------- (%g, %g, %g) to (%g, %g, %g), dir=(%g, %g, %g)\n",
		ray.r_pt[X], ray.r_pt[Y], ray.r_pt[Z],
		p2[X], p2[Y], p2[Z],
		ray.r_dir[X], ray.r_dir[Y], ray.r_dir[Z] );


	segp = rt_ebm_shot( &Tsolid, &ray, &Tappl );

	lastk = 0;
	while( segp != SEG_NULL )  {
		/* Draw 2-D segments */
		draw2seg( ray.r_pt, ray.r_dir, lastk, segp->seg_in.hit_dist, 0 );
		draw2seg( ray.r_pt, ray.r_dir, segp->seg_in.hit_dist, segp->seg_out.hit_dist, 1 );
		lastk = segp->seg_out.hit_dist;

		draw3seg( segp, ray.r_pt, ray.r_dir );

		next = segp->seg_next;
		FREE_SEG(segp, Tappl.a_resource);
		segp = next;
	}
}

outline(mat, rp)
mat_t	mat;
union record	*rp;
{
	register struct rt_ebm_specific *ebmp = bmsp;
	register struct vlist	*vp;
	struct vlhead	vhead;

	vhead.vh_first = vhead.vh_last = VL_NULL;

	pl_3space( plotfp, -BIT_XWIDEN,-BIT_YWIDEN,-BIT_XWIDEN,
		 ebmp->ebm_i.xdim+BIT_XWIDEN, ebmp->ebm_i.ydim+BIT_YWIDEN, (int)(ebmp->ebm_i.tallness+1.99) );
	pl_3box( plotfp, -BIT_XWIDEN,-BIT_YWIDEN,-BIT_XWIDEN,
		 ebmp->ebm_i.xdim+BIT_XWIDEN, ebmp->ebm_i.ydim+BIT_YWIDEN, (int)(ebmp->ebm_i.tallness+1.99) );

	/* Get vlist, then just draw the vlist */
	rt_ebm_plot( rp, mat, &vhead, 0 );

	for( vp = vhead.vh_first; vp != VL_NULL; vp = vp->vl_forw )  {
		if( vp->vl_draw == 0 )
			pdv_3move( plotfp, vp->vl_pnt );
		else
			pdv_3cont( plotfp, vp->vl_pnt );
	}
	FREE_VL( vhead.vh_first );
}


draw2seg( pt, dir, k1, k2, inside )
vect_t	pt, dir;
fastf_t	k1, k2;
int	inside;
{
	vect_t	a, b;

	a[0] = pt[0] + k1 * dir[0];
	a[1] = pt[1] + k1 * dir[1];
	a[2] = 0;
	b[0] = pt[0] + k2 * dir[0];
	b[1] = pt[1] + k2 * dir[1];
	b[2] = 0;

	if( inside )
		pl_color( plotfp, 255, 0, 0 );	/* R */
	else
		pl_color( plotfp, 0, 255, 0 );	/* G */
	pdv_3line( plotfp, a, b );
}

draw3seg( segp, pt, dir )
register struct seg	*segp;
vect_t	pt, dir;
{
	vect_t	a, b;

	VJOIN1( a, pt, segp->seg_in.hit_dist, dir );
	VJOIN1( b, pt, segp->seg_out.hit_dist, dir );
	pl_color( plotfp, 0, 0, 255 );	/* B */
	pdv_3line( plotfp, a, b );
}
#endif /* test driver */

/*
 *		R T _ E B M _ T C L G E T
 *
 *	Routine to format the parameters of an EBM for "db get"
 *
 *	Legal requested parameters are:
 *		"F" - bitmap file to extrude
 *		"W" - number of cells in X direction
 *		"N" - number of cells in Y direction
 *		"H" - height of each cell (mm)
 *		"M" - matrix to transform EBM solid into model coordinates
 *
 *	no paramaters requested returns all
 */
int
rt_ebm_tclget(Tcl_Interp *interp, const struct rt_db_internal *intern, const char *attr)
{
	register struct rt_ebm_internal *ebm=(struct rt_ebm_internal *)intern->idb_ptr;
	Tcl_DString	ds;
	struct bu_vls	vls;
	int		i;

	RT_EBM_CK_MAGIC( ebm );

	Tcl_DStringInit( &ds );
	bu_vls_init( &vls );

	if( attr == (char *)NULL ) {
		bu_vls_strcpy( &vls, "ebm" );
		bu_vls_printf( &vls, " F %s W %d N %d H %.25g",
			       ebm->file, ebm->xdim, ebm->ydim, ebm->tallness );
		bu_vls_printf( &vls, " M {" );
		for( i=0 ; i<16 ; i++ )
			bu_vls_printf( &vls, " %.25g", ebm->mat[i] );
		bu_vls_printf( &vls, " }" );
	}
	else if( !strcmp( attr, "F" ) )
		bu_vls_printf( &vls, "%s", ebm->file );
	else if( !strcmp( attr, "W" ) )
		bu_vls_printf( &vls, "%d", ebm->xdim );
	else if( !strcmp( attr, "N" ) )
		bu_vls_printf( &vls, "%d", ebm->ydim );
	else if( !strcmp( attr, "H" ) )
		bu_vls_printf( &vls, "%.25g", ebm->tallness );
	else if( !strcmp( attr, "M" ) ) {
		for( i=0 ; i<16 ; i++ )
			bu_vls_printf( &vls, "%.25g ", ebm->mat[i] );
	}
	else {
		Tcl_SetResult( interp,"ERROR: Unknown attribute, choices are F, W, N, or H\n",
		TCL_STATIC );
		bu_vls_free( &vls );
		return( TCL_ERROR );       
	}

	Tcl_DStringAppend( &ds, bu_vls_addr( &vls ), -1 );
	Tcl_DStringResult( interp, &ds );
	Tcl_DStringFree( &ds );
	bu_vls_free( &vls );
	return( TCL_OK );
}


/*
 *		R T _ E B M _ T C L A D J U S T
 *
 *	Routine to adjust the parameters of an EBM
 *
 *	Legal parameters are:
 *		"F" - bitmap file to extrude
 *		"W" - number of cells in X direction
 *		"N" - number of cells in Y direction
 *		"H" - height of each cell (mm)
 *		"M" - matrix to transform EBM solid into model coordinates
 */

int
rt_ebm_tcladjust(Tcl_Interp *interp, struct rt_db_internal *intern, int argc, char **argv)
{
	struct rt_ebm_internal *ebm;

	RT_CK_DB_INTERNAL( intern );

	ebm = (struct rt_ebm_internal *)intern->idb_ptr;
	RT_EBM_CK_MAGIC( ebm );

	while( argc >= 2 ) {
		if( !strcmp( argv[0], "F" ) ) {
			if( strlen( argv[1] ) >= RT_EBM_NAME_LEN ) {
				Tcl_SetResult( interp,
					       "ERROR: File name too long",
					       TCL_STATIC );
				return( TCL_ERROR );
			}
			strcpy( ebm->file, argv[1] );
		}
		else if( !strcmp( argv[0], "W" ) ) {
			ebm->xdim = atoi( argv[1] );
		}
		else if( !strcmp( argv[0], "N" ) ) {
			ebm->ydim = atoi( argv[1] );
		}
		else if( !strcmp( argv[0], "H" ) ) {
			ebm->tallness = atof( argv[1] );
		}
		else if( !strcmp( argv[0], "M" ) ) {
			int len=16;
			fastf_t array[16];
			fastf_t *ar_ptr;

			ar_ptr = array;

			if( tcl_list_to_fastf_array( interp, argv[1], &ar_ptr, &len) !=
			    len ) {
				Tcl_SetResult( interp,
				      "ERROR: incorrect number of coefficents for matrix\n",
				      TCL_STATIC );
				return( TCL_ERROR );
			}
			MAT_COPY( ebm->mat, array )
		}
		else {
			Tcl_SetResult( interp,
			      "ERROR: illegal argument, choices are F, W, N, or H\n",
			      TCL_STATIC );
			return( TCL_ERROR );
		}
		argc -= 2;
		argv += 2;
	}
	return( TCL_OK );
}

int
rt_ebm_tclform( const struct rt_functab *ftp, Tcl_Interp *interp )
{
        RT_CK_FUNCTAB(ftp);

        Tcl_AppendResult( interp,
			  "F %s W %d N %d H %f M { %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f", (char *)NULL );

        return TCL_OK;

}


/*
 *		R T _ E B M _ M A K E
 *
 *	Routine to make a new EBM solid. The only purpose of this routine is
 *	to initialize the matrix and height to legal values.
 */
void
rt_ebm_make(const struct rt_functab *ftp, struct rt_db_internal *intern, double diameter)
{
	struct rt_ebm_internal *ebm;

	intern->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	intern->idb_type = ID_EBM;
	BU_ASSERT(&rt_functab[intern->idb_type] == ftp);

	intern->idb_meth = ftp;
	ebm = (struct rt_ebm_internal *)bu_calloc( sizeof( struct rt_ebm_internal ), 1,
				     "rt_ebm_internal");
	intern->idb_ptr = (genptr_t)ebm;
	ebm->magic = RT_EBM_INTERNAL_MAGIC;
	MAT_IDN( ebm->mat );
	ebm->tallness = 1.0;
}
@


11.40
log
@change conf.h to a wrapped config.h
@
text
@d21 1
a21 1
static const char RCSebm[] = "@@(#)$Header: /cvs/brlcad/librt/g_ebm.c,v 11.39 2004/04/05 08:48:56 morrison Exp $ (BRL)";
@


11.39
log
@merge of ansi-6-0-branch into HEAD
@
text
@d21 1
a21 1
static const char RCSebm[] = "@@(#)$Header$ (BRL)";
d24 5
a28 1
#include "conf.h"
@


11.38
log
@merge of windows-6-0-branch into head
@
text
@d132 1
a132 7
rt_seg_planeclip( out_hd, in_hd, out_norm, in, out, rp, ap )
struct seg	*out_hd;
struct seg	*in_hd;
vect_t		out_norm;
fastf_t		in, out;
struct xray	*rp;
struct application *ap;
d219 1
a219 5
rt_ebm_dda( rp, stp, ap, seghead )
register struct xray	*rp;
struct soltab		*stp;
struct application	*ap;
struct seg		*seghead;
d526 1
a526 5
rt_ebm_import( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
const mat_t			mat;
const struct db_i		*dbip;
d633 1
a633 5
rt_ebm_export( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d674 1
a674 5
rt_ebm_import5( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
const mat_t			mat;
const struct db_i		*dbip;
d775 1
a775 5
rt_ebm_export5( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d812 1
a812 5
rt_ebm_describe( str, ip, verbose, mm2local )
struct bu_vls		*str;
const struct rt_db_internal	*ip;
int			verbose;
double			mm2local;
d851 1
a851 2
rt_ebm_ifree( ip )
struct rt_db_internal	*ip;
d883 1
a883 4
rt_ebm_prep( stp, ip, rtip )
struct soltab		*stp;
struct rt_db_internal	*ip;
struct rt_i		*rtip;
d939 1
a939 2
rt_ebm_print( stp )
register const struct soltab	*stp;
d964 1
a964 5
rt_ebm_shot( stp, rp, ap, seghead )
struct soltab		*stp;
register struct xray	*rp;
struct application	*ap;
struct seg		*seghead;
d1012 1
a1012 4
rt_ebm_norm( hitp, stp, rp )
register struct hit	*hitp;
struct soltab		*stp;
register struct xray	*rp;
d1055 1
a1055 4
rt_ebm_curve( cvp, hitp, stp )
register struct curvature	*cvp;
register struct hit		*hitp;
struct soltab			*stp;
d1071 1
a1071 5
rt_ebm_uv( ap, stp, hitp, uvp )
struct application	*ap;
struct soltab		*stp;
register struct hit	*hitp;
register struct uvcoord	*uvp;
d1085 1
a1085 2
rt_ebm_free( stp )
struct soltab	*stp;
d1097 1
a1097 1
rt_ebm_class()
d1106 1
a1106 5
rt_ebm_plot( vhead, ip, ttol, tol )
struct bu_list	*vhead;
struct rt_db_internal *ip;
const struct rt_tess_tol *ttol;
const struct bn_tol		*tol;
d1161 1
a1161 6
rt_ebm_plate( x1, y1, x2, y2, t, mat, vhead )
int			x1, y1;
int			x2, y2;
double			t;
register mat_t		mat;
register struct bu_list	*vhead;
d1196 1
a1196 5
rt_ebm_edge( x1, y1, x2, y2, left, edges )
int			x1, y1;
int			x2, y2;
int			left;
struct ebm_edge		*edges;
d1224 1
a1224 2
rt_ebm_sort_edges( edges )
struct ebm_edge *edges;
d1384 1
a1384 6
rt_ebm_tess( r, m, ip, ttol, tol )
struct nmgregion	**r;
struct model		*m;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol		*tol;
d1906 1
a1906 4
rt_ebm_tclget( interp, intern, attr )
Tcl_Interp			*interp;
const struct rt_db_internal	*intern;
const char			*attr;
d1968 1
a1968 5
rt_ebm_tcladjust( interp, intern, argc, argv )
Tcl_Interp		*interp;
struct rt_db_internal	*intern;
int			argc;
char			**argv;
d2044 1
a2044 4
rt_ebm_make( ftp, intern, diameter )
const struct rt_functab	*ftp;
struct rt_db_internal	*intern;
double			diameter;
@


11.37
log
@update copyright to include span through 2003
@
text
@d21 1
a21 1
static const char RCSebm[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ebm.c,v 11.36 2002/08/20 17:07:59 jra Exp $ (BRL)";
d45 6
d924 1
a924 1
	vect_t	small;
d949 1
a949 1
	VSETALL( small, 0 );
d952 1
a952 1
		small, ebmp->ebm_large );
@


11.36
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1988 by the United States Army.
d21 1
a21 1
static const char RCSebm[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ebm.c,v 11.34 2002/05/31 19:50:14 jra Exp $ (BRL)";
@


11.36.10.1
log
@merge from HEAD
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1988-2004 by the United States Army.
d21 1
a21 1
static const char RCSebm[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ebm.c,v 11.37 2004/02/02 17:39:20 morrison Exp $ (BRL)";
@


11.36.10.2
log
@merge from head
@
text
@d21 1
a21 1
static const char RCSebm[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ebm.c,v 11.36.10.1 2004/02/12 18:37:40 erikg Exp $ (BRL)";
@


11.36.10.3
log
@merge from head
@
text
@d21 1
a21 1
static const char RCSebm[] = "@@(#)$Header$ (BRL)";
a44 6
/*
NOTES:
	Changed small to small11 for win32 compatibility 
*/


d918 1
a918 1
	vect_t	small1;
d943 1
a943 1
	VSETALL( small1, 0 );
d946 1
a946 1
		small1, ebmp->ebm_large );
@


11.36.4.1
log
@Modifications (on a 6.0 source distribution) for initial port to windows (merged with sources close to 6.0.2)
@
text
@d21 1
a21 1
static const char RCSebm[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ebm.c,v 11.36 2002/08/20 17:07:59 jra Exp $ (BRL)";
a44 6
/*
NOTES:
	Changed small to small11 for win32 compatibility 
*/


d918 1
a918 1
	vect_t	small1;
d943 1
a943 1
	VSETALL( small1, 0 );
d946 1
a946 1
		small1, ebmp->ebm_large );
@


11.36.4.2
log
@sync to HEAD...
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1988-2004 by the United States Army.
d21 1
a21 1
static const char RCSebm[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/g_ebm.c,v 11.36.4.1 2002/09/26 23:04:01 morrison Exp $ (BRL)";
@


11.36.2.1
log
@Initial ANSIfication
@
text
@d21 1
a21 1
static const char RCSebm[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ebm.c,v 11.36 2002/08/20 17:07:59 jra Exp $ (BRL)";
d126 7
a132 1
rt_seg_planeclip(struct seg *out_hd, struct seg *in_hd, fastf_t *out_norm, fastf_t in, fastf_t out, struct xray *rp, struct application *ap)
d219 5
a223 1
rt_ebm_dda(register struct xray *rp, struct soltab *stp, struct application *ap, struct seg *seghead)
d530 5
a534 1
rt_ebm_import(struct rt_db_internal *ip, const struct bu_external *ep, const fastf_t *mat, const struct db_i *dbip)
d641 5
a645 1
rt_ebm_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d686 5
a690 1
rt_ebm_import5(struct rt_db_internal *ip, const struct bu_external *ep, const fastf_t *mat, const struct db_i *dbip)
d791 5
a795 1
rt_ebm_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d832 5
a836 1
rt_ebm_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
d875 2
a876 1
rt_ebm_ifree(struct rt_db_internal *ip)
d908 4
a911 1
rt_ebm_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
d967 2
a968 1
rt_ebm_print(register const struct soltab *stp)
d993 5
a997 1
rt_ebm_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
d1045 4
a1048 1
rt_ebm_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
d1091 4
a1094 1
rt_ebm_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
d1110 5
a1114 1
rt_ebm_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
d1128 2
a1129 1
rt_ebm_free(struct soltab *stp)
d1141 1
a1141 1
rt_ebm_class(void)
d1150 5
a1154 1
rt_ebm_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d1209 6
a1214 1
rt_ebm_plate(int x1, int y1, int x2, int y2, double t, register fastf_t *mat, register struct bu_list *vhead)
d1249 5
a1253 1
rt_ebm_edge(int x1, int y1, int x2, int y2, int left, struct ebm_edge *edges)
d1281 2
a1282 1
rt_ebm_sort_edges(struct ebm_edge *edges)
d1442 6
a1447 1
rt_ebm_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d1969 4
a1972 1
rt_ebm_tclget(Tcl_Interp *interp, const struct rt_db_internal *intern, const char *attr)
d2034 5
a2038 1
rt_ebm_tcladjust(Tcl_Interp *interp, struct rt_db_internal *intern, int argc, char **argv)
d2114 4
a2117 1
rt_ebm_make(const struct rt_functab *ftp, struct rt_db_internal *intern, double diameter)
@


11.36.2.2
log
@sync branch with HEAD
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1988-2004 by the United States Army.
d21 1
a21 1
static const char RCSebm[] = "@@(#)$Header$ (BRL)";
a44 6
/*
NOTES:
	Changed small to small11 for win32 compatibility 
*/


d884 1
a884 1
	vect_t	small1;
d909 1
a909 1
	VSETALL( small1, 0 );
d912 1
a912 1
		small1, ebmp->ebm_large );
@


11.35
log
@Converted from K&R to ANSI C - RFH
@
text
@d126 7
a132 1
rt_seg_planeclip(struct seg *out_hd, struct seg *in_hd, fastf_t *out_norm, fastf_t in, fastf_t out, struct xray *rp, struct application *ap)
d219 5
a223 1
rt_ebm_dda(register struct xray *rp, struct soltab *stp, struct application *ap, struct seg *seghead)
d530 5
a534 1
rt_ebm_import(struct rt_db_internal *ip, const struct bu_external *ep, const fastf_t *mat, const struct db_i *dbip)
d641 5
a645 1
rt_ebm_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d686 5
a690 1
rt_ebm_import5(struct rt_db_internal *ip, const struct bu_external *ep, const fastf_t *mat, const struct db_i *dbip)
d791 5
a795 1
rt_ebm_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d832 5
a836 1
rt_ebm_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
d875 2
a876 1
rt_ebm_ifree(struct rt_db_internal *ip)
d908 4
a911 1
rt_ebm_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
d967 2
a968 1
rt_ebm_print(register const struct soltab *stp)
d993 5
a997 1
rt_ebm_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
d1045 4
a1048 1
rt_ebm_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
d1091 4
a1094 1
rt_ebm_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
d1110 5
a1114 1
rt_ebm_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
d1128 2
a1129 1
rt_ebm_free(struct soltab *stp)
d1141 1
a1141 1
rt_ebm_class(void)
d1150 5
a1154 1
rt_ebm_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d1209 6
a1214 1
rt_ebm_plate(int x1, int y1, int x2, int y2, double t, register fastf_t *mat, register struct bu_list *vhead)
d1249 5
a1253 1
rt_ebm_edge(int x1, int y1, int x2, int y2, int left, struct ebm_edge *edges)
d1281 2
a1282 1
rt_ebm_sort_edges(struct ebm_edge *edges)
d1442 6
a1447 1
rt_ebm_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d1969 4
a1972 1
rt_ebm_tclget(Tcl_Interp *interp, const struct rt_db_internal *intern, const char *attr)
d2034 5
a2038 1
rt_ebm_tcladjust(Tcl_Interp *interp, struct rt_db_internal *intern, int argc, char **argv)
d2114 4
a2117 1
rt_ebm_make(const struct rt_functab *ftp, struct rt_db_internal *intern, double diameter)
@


11.34
log
@rt_ebm_export5() was noe allocating quite enough memory for its external buffer (off by one)
@
text
@d21 1
a21 1
static const char RCSebm[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ebm.c,v 11.33 2001/10/02 19:24:29 jra Exp $ (BRL)";
d126 1
a126 7
rt_seg_planeclip( out_hd, in_hd, out_norm, in, out, rp, ap )
struct seg	*out_hd;
struct seg	*in_hd;
vect_t		out_norm;
fastf_t		in, out;
struct xray	*rp;
struct application *ap;
d213 1
a213 5
rt_ebm_dda( rp, stp, ap, seghead )
register struct xray	*rp;
struct soltab		*stp;
struct application	*ap;
struct seg		*seghead;
d520 1
a520 5
rt_ebm_import( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
const mat_t			mat;
const struct db_i		*dbip;
d627 1
a627 5
rt_ebm_export( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d668 1
a668 5
rt_ebm_import5( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
const mat_t			mat;
const struct db_i		*dbip;
d769 1
a769 5
rt_ebm_export5( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d806 1
a806 5
rt_ebm_describe( str, ip, verbose, mm2local )
struct bu_vls		*str;
const struct rt_db_internal	*ip;
int			verbose;
double			mm2local;
d845 1
a845 2
rt_ebm_ifree( ip )
struct rt_db_internal	*ip;
d877 1
a877 4
rt_ebm_prep( stp, ip, rtip )
struct soltab		*stp;
struct rt_db_internal	*ip;
struct rt_i		*rtip;
d933 1
a933 2
rt_ebm_print( stp )
register const struct soltab	*stp;
d958 1
a958 5
rt_ebm_shot( stp, rp, ap, seghead )
struct soltab		*stp;
register struct xray	*rp;
struct application	*ap;
struct seg		*seghead;
d1006 1
a1006 4
rt_ebm_norm( hitp, stp, rp )
register struct hit	*hitp;
struct soltab		*stp;
register struct xray	*rp;
d1049 1
a1049 4
rt_ebm_curve( cvp, hitp, stp )
register struct curvature	*cvp;
register struct hit		*hitp;
struct soltab			*stp;
d1065 1
a1065 5
rt_ebm_uv( ap, stp, hitp, uvp )
struct application	*ap;
struct soltab		*stp;
register struct hit	*hitp;
register struct uvcoord	*uvp;
d1079 1
a1079 2
rt_ebm_free( stp )
struct soltab	*stp;
d1091 1
a1091 1
rt_ebm_class()
d1100 1
a1100 5
rt_ebm_plot( vhead, ip, ttol, tol )
struct bu_list	*vhead;
struct rt_db_internal *ip;
const struct rt_tess_tol *ttol;
const struct bn_tol		*tol;
d1155 1
a1155 6
rt_ebm_plate( x1, y1, x2, y2, t, mat, vhead )
int			x1, y1;
int			x2, y2;
double			t;
register mat_t		mat;
register struct bu_list	*vhead;
d1190 1
a1190 5
rt_ebm_edge( x1, y1, x2, y2, left, edges )
int			x1, y1;
int			x2, y2;
int			left;
struct ebm_edge		*edges;
d1218 1
a1218 2
rt_ebm_sort_edges( edges )
struct ebm_edge *edges;
d1378 1
a1378 6
rt_ebm_tess( r, m, ip, ttol, tol )
struct nmgregion	**r;
struct model		*m;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol		*tol;
d1900 1
a1900 4
rt_ebm_tclget( interp, intern, attr )
Tcl_Interp			*interp;
const struct rt_db_internal	*intern;
const char			*attr;
d1962 1
a1962 5
rt_ebm_tcladjust( interp, intern, argc, argv )
Tcl_Interp		*interp;
struct rt_db_internal	*intern;
int			argc;
char			**argv;
d2038 1
a2038 4
rt_ebm_make( ftp, intern, diameter )
const struct rt_functab	*ftp;
struct rt_db_internal	*intern;
double			diameter;
@


11.33
log
@Routines were not setting idb_major_type in the internal structure
@
text
@d21 1
a21 1
static const char RCSebm[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ebm.c,v 11.32 2001/10/02 17:54:11 jra Exp $ (BRL)";
d815 1
a815 1
	ep->ext_nbytes = bu_vls_strlen( &str );
@


11.32
log
@rt_xxx_make() routines were not setting idb_major_type
@
text
@d21 1
a21 1
static const char RCSebm[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ebm.c,v 11.31 2001/06/21 20:35:31 jra Exp $ (BRL)";
d551 1
d701 1
@


11.31
log
@Added rt_ebm_make() to initialize matrix
@
text
@d21 1
a21 1
static const char RCSebm[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ebm.c,v 11.30 2001/06/21 20:14:29 jra Exp $ (BRL)";
d2119 1
@


11.30
log
@Added tclget and tcladjust routines for EBM
@
text
@d21 1
a21 1
static const char RCSebm[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ebm.c,v 11.29 2001/05/17 20:05:24 morrison Exp $ (BRL)";
d2102 27
@


11.29
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d21 1
a21 1
static const char RCSebm[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ebm.c,v 11.28 2001/04/20 22:29:43 morrison Exp $ (BRL)";
d34 2
d1951 152
@


11.28
log
@CONST to const
@
text
@d21 1
a21 1
static const char RCSebm[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ebm.c,v 11.27 2001/04/02 21:38:08 morrison Exp $ (BRL)";
d174 1
a174 1
	if(rt_g.debug&DEBUG_EBM)bu_log("kmin=%g, kmax=%g, out_norm_code=%d\n", kmin, kmax, out_norm_code );
d179 1
a179 1
		if(rt_g.debug&DEBUG_EBM)bu_log(" rt_seg_planeclip seg( %g, %g )\n", curr->seg_in.hit_dist, curr->seg_out.hit_dist );
d181 1
a181 1
			if(rt_g.debug&DEBUG_EBM)bu_log("seg_out %g <= kmin %g, freeing\n", curr->seg_out.hit_dist, kmin );
d186 1
a186 1
			if(rt_g.debug&DEBUG_EBM)bu_log("seg_in  %g >= kmax %g, freeing\n", curr->seg_in.hit_dist, kmax );
d191 1
a191 1
			if(rt_g.debug&DEBUG_EBM)bu_log("seg_in = kmin %g\n", kmin );
d196 1
a196 1
			if(rt_g.debug&DEBUG_EBM)bu_log("seg_out= kmax %g\n", kmax );
d266 4
a269 4
if(rt_g.debug&DEBUG_EBM)VPRINT("ebm_origin", ebmp->ebm_origin);
if(rt_g.debug&DEBUG_EBM)VPRINT("r_pt", rp->r_pt);
if(rt_g.debug&DEBUG_EBM)VPRINT("P", P);
if(rt_g.debug&DEBUG_EBM)VPRINT("cellsize", ebmp->ebm_cellsize);
d272 1
a272 1
if(rt_g.debug&DEBUG_EBM)bu_log("[shoot: r_min=%g, r_max=%g]\n", rp->r_min, rp->r_max);
d287 1
a287 1
if(rt_g.debug&DEBUG_EBM)bu_log("g[X] = %d, g[Y] = %d\n", igrid[X], igrid[Y]);
d296 1
a296 1
if(rt_g.debug&DEBUG_EBM)bu_log("ray on local Z axis\n");
d363 2
a364 2
if(rt_g.debug&DEBUG_EBM)bu_log("t[X] = %g, delta[X] = %g\n", t[X], delta[X] );
if(rt_g.debug&DEBUG_EBM)bu_log("t[Y] = %g, delta[Y] = %g\n", t[Y], delta[Y] );
d382 1
a382 1
if(rt_g.debug&DEBUG_EBM)bu_log("Entry index is %s, t0=%g\n", in_index==X ? "X" : "Y", t0);
d397 1
a397 1
if(rt_g.debug&DEBUG_EBM)bu_log("Exit t[X]=%g, t[Y]=%g\n", t[X], t[Y] );
d412 1
a412 1
if(rt_g.debug&DEBUG_EBM)bu_log("igrid [%d %d] from %g to %g, val=%d\n",
d415 1
a415 1
if(rt_g.debug&DEBUG_EBM)bu_log("Exit index is %s, t[X]=%g, t[Y]=%g\n",
d447 1
a447 1
				if(rt_g.debug&DEBUG_EBM) bu_log("START t=%g, surfno=%d\n",
d479 1
a479 1
				if(rt_g.debug&DEBUG_EBM) bu_log("END t=%g, surfno=%d\n",
d511 1
a511 1
		if(rt_g.debug&DEBUG_EBM) bu_log("closed END t=%g, surfno=%d\n",
@


11.27
log
@Deprecated bn_mat_copy() for new performance version of MAT_COPY() macro in h/vmath.h.
@
text
@d21 1
a21 1
static const char RCSebm[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ebm.c,v 11.26 2001/03/31 01:57:07 morrison Exp $ (BRL)";
d57 1
a57 1
CONST struct bu_structparse rt_ebm_parse[] = {
d530 3
a532 3
CONST struct bu_external	*ep;
CONST mat_t			mat;
CONST struct db_i		*dbip;
d640 1
a640 1
CONST struct rt_db_internal	*ip;
d642 1
a642 1
CONST struct db_i		*dbip;
d685 3
a687 3
CONST struct bu_external	*ep;
CONST mat_t			mat;
CONST struct db_i		*dbip;
d789 1
a789 1
CONST struct rt_db_internal	*ip;
d791 1
a791 1
CONST struct db_i		*dbip;
d830 1
a830 1
CONST struct rt_db_internal	*ip;
d964 1
a964 1
register CONST struct soltab	*stp;
d966 1
a966 1
	register CONST struct rt_ebm_specific *ebmp =
d1149 2
a1150 2
CONST struct rt_tess_tol *ttol;
CONST struct bn_tol		*tol;
d1442 2
a1443 2
CONST struct rt_tess_tol *ttol;
CONST struct bn_tol		*tol;
@


11.26
log
@Deprecated bn_mat_idn() and bn_mat_zero(), updated calls to h/vmath.h's MAT_IDN() and MAT_ZERO() performance improved macros.
@
text
@d21 1
a21 1
static const char RCSebm[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ebm.c,v 11.25 2000/09/08 05:54:41 mike Exp $ (BRL)";
d583 1
a583 1
	bn_mat_copy( eip->mat, tmat );
d732 1
a732 1
	bn_mat_copy( eip->mat, tmat );
@


11.25
log
@
Modified tree routines to take resource pointer.
@
text
@d21 1
a21 1
static const char RCSebm[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ebm.c,v 11.24 2000/07/13 02:36:26 cjohnson Exp $ (BRL)";
d556 1
a556 1
	bn_mat_idn( eip->mat );
d705 1
a705 1
	bn_mat_idn( eip->mat );
d1696 1
a1696 1
	bn_mat_idn( Tsolid.st_matp );
@


11.24
log
@LINT from gcc -Wall
@
text
@d21 1
a21 1
static const char RCSebm[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ebm.c,v 11.23 2000/07/10 23:01:30 mike Exp $ (BRL)";
d1691 1
a1691 1
	Tdir.d_namep = "Tsolid";
@


11.23
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d21 1
a21 1
static const char RCSebm[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ebm.c,v 11.22 2000/06/30 19:43:51 jra Exp $ (BRL)";
d29 5
@


11.22
log
@Added database v5 support
@
text
@d21 1
a21 1
static char RCSebm[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ebm.c,v 11.21 2000/06/30 15:38:02 mike Exp $ (BRL)";
@


11.21
log
@
export methods should not init the external structure, just check them.
@
text
@d21 1
a21 1
static char RCSebm[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ebm.c,v 11.20 2000/06/30 15:31:14 mike Exp $ (BRL)";
d664 146
@


11.20
log
@
The import/export and import5/export5 methods must NOT
re-initialize their rt_db_internal* pointer, they should just check it.
@
text
@d21 1
a21 1
static char RCSebm[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ebm.c,v 11.19 2000/04/12 02:34:32 mike Exp $ (BRL)";
d653 1
a653 1
	BU_INIT_EXTERNAL(ep);
@


11.19
log
@
NT port, non-compat4
@
text
@d21 1
a21 1
static char RCSebm[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ebm.c,v 11.18 2000/03/29 02:43:10 mike Exp $ (BRL)";
d543 1
a543 1
	RT_INIT_DB_INTERNAL( ip );
@


11.18
log
@
Fixed invocation of nmg_mark_edges_real()
@
text
@d21 1
a21 1
static char RCSebm[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ebm.c,v 11.17 2000/03/02 03:50:57 mike Exp $ (BRL)";
d944 1
a944 1
	vec_ortho( cvp->crv_pdir, hitp->hit_normal );
@


11.17
log
@
Changed to use dbi_filepath
@
text
@d21 1
a21 1
static char RCSebm[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ebm.c,v 11.16 2000/01/14 02:15:21 mike Exp $ (BRL)";
d1482 1
a1482 1
	(void)nmg_mark_edges_real( &s->l );
@


11.16
log
@
Prevent a multi-processor race.
Significant optimization:  don't re-copy on subsequent instances of same file.
@
text
@d21 1
a21 1
static char RCSebm[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ebm.c,v 11.15 1999/12/29 21:00:42 jra Exp $ (BRL)";
d581 1
a581 1
	if( !(mp = bu_open_mapped_file( eip->file, "ebm" )) )  {
@


11.15
log
@Eliminated an unused variable
@
text
@d21 1
a21 1
static char RCSebm[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ebm.c,v 11.14 1999/12/22 02:17:59 mike Exp $ (BRL)";
a532 1
	register int	y;
a534 1
	unsigned char	*cp;
d597 13
a609 2
	if( !mp->apbuf )
	{
a612 1
	}
d614 9
a622 6
	/* Because of in-memory padding, read each scanline separately */
	cp = (unsigned char *)mp->buf;
	for( y=0; y < eip->ydim; y++ )  {
		/* BIT() addresses into mp->apbuf */
		bcopy( cp, &BIT( eip, 0, y), eip->xdim );
		cp += eip->xdim;
@


11.14
log
@
Eliminated dead vars
@
text
@d21 1
a21 1
static char RCSebm[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ebm.c,v 11.13 1999/11/26 21:46:45 mike Exp $ (BRL)";
a285 1
		register struct ebm_hit_private *hp;
@


11.13
log
@
Lint cleanups
@
text
@d21 1
a21 1
static char RCSebm[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ebm.c,v 11.12 1999/11/24 23:12:06 mike Exp $ (BRL)";
a950 3
	register struct rt_ebm_specific *ebmp =
		(struct rt_ebm_specific *)stp->st_specific;

@


11.12
log
@
Made structparse tables CONST
@
text
@d21 1
a21 1
static char RCSebm[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ebm.c,v 11.11 1999/11/24 21:44:29 mike Exp $ (BRL)";
d524 1
a524 1
rt_ebm_import( ip, ep, mat )
d528 1
d623 1
a623 1
rt_ebm_export( ep, ip, local2mm )
d627 1
d669 1
a669 1
struct rt_db_internal	*ip;
d992 1
a992 1
struct bn_tol		*tol;
d1285 1
a1285 1
struct bn_tol		*tol;
@


11.11
log
@
Removed includes of compat header files rtstring.h and rtlist.h
@
text
@d21 1
a21 1
static char RCSebm[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ebm.c,v 11.10 1999/11/17 02:41:57 mike Exp $ (BRL)";
d52 1
a52 1
struct bu_structparse rt_ebm_parse[] = {
@


11.10
log
@
Added idb_meth and st_meth pointers to allow direct access to per-solid
methods, C++ style.
@
text
@d21 1
a21 1
static char RCSebm[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ebm.c,v 11.9 1999/07/02 22:19:22 mike Exp $ (BRL)";
a31 1
#include "rtlist.h"
@


11.9
log
@
Removed dependence on compat4.h
@
text
@d21 1
a21 1
static char RCSebm[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ebm.c,v 11.8 1999/05/27 19:10:37 mike Exp $ (BRL)";
d548 1
@


11.8
log
@
sed4
@
text
@d21 1
a21 1
static char RCSebm[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_ebm.c,v 11.7 1997/05/19 20:51:36 jra Exp $ (BRL)";
d55 1
a55 1
	{"%s",	RT_EBM_NAME_LEN, "file",	1,	FUNC_NULL },
d59 3
a61 3
	{"%d",	1, "w",		RT_EBM_O(xdim),		FUNC_NULL },
	{"%d",	1, "n",		RT_EBM_O(ydim),		FUNC_NULL },
	{"%f",	1, "d",		RT_EBM_O(tallness),	FUNC_NULL },
d63 1
a63 1
	{"",	0, (char *)0, 0,			FUNC_NULL }
d1057 1
a1057 1
	RT_ADD_VLIST( vhead, srot, RT_VLIST_LINE_MOVE );
d1061 1
a1061 1
	RT_ADD_VLIST( vhead, prot, RT_VLIST_LINE_DRAW );
d1065 1
a1065 1
	RT_ADD_VLIST( vhead, prot, RT_VLIST_LINE_DRAW );
d1069 1
a1069 1
	RT_ADD_VLIST( vhead, prot, RT_VLIST_LINE_DRAW );
d1071 1
a1071 1
	RT_ADD_VLIST( vhead, srot, RT_VLIST_LINE_DRAW );
@


11.7
log
@rt_ebm_dda() was selecting wrong initial t value for rays in X or Y direction.
@
text
@d21 1
a21 1
static char RCSebm[] = "@@(#)$Header: /m/cad/librt/RCS/g_ebm.c,v 11.6 1996/12/19 16:37:06 jra Exp jra $ (BRL)";
d57 1
a57 1
	{"%s",	RT_EBM_NAME_LEN, "file", offsetofarray(struct rt_ebm_internal, file), FUNC_NULL },
d62 1
a62 1
	{"%f",	16, "mat", offsetofarray(struct rt_ebm_internal, mat), FUNC_NULL },
d78 1
a78 1
	double t, mat_t mat, struct rt_list *vhead ) );
d140 1
a140 1
			rt_log("rt_seg_planeclip ERROR -- ray parallel to baseplane, outside \n");
d153 1
a153 1
			rt_log("rt_seg_planeclip ERROR -- ray parallel to baseplane, outside \n");
d170 1
a170 1
	if(rt_g.debug&DEBUG_EBM)rt_log("kmin=%g, kmax=%g, out_norm_code=%d\n", kmin, kmax, out_norm_code );
d173 3
a175 3
	while( RT_LIST_WHILE( curr, seg, &(in_hd->l) ) )  {
		RT_LIST_DEQUEUE( &(curr->l) );
		if(rt_g.debug&DEBUG_EBM)rt_log(" rt_seg_planeclip seg( %g, %g )\n", curr->seg_in.hit_dist, curr->seg_out.hit_dist );
d177 1
a177 1
			if(rt_g.debug&DEBUG_EBM)rt_log("seg_out %g <= kmin %g, freeing\n", curr->seg_out.hit_dist, kmin );
d182 1
a182 1
			if(rt_g.debug&DEBUG_EBM)rt_log("seg_in  %g >= kmax %g, freeing\n", curr->seg_in.hit_dist, kmax );
d187 1
a187 1
			if(rt_g.debug&DEBUG_EBM)rt_log("seg_in = kmin %g\n", kmin );
d192 1
a192 1
			if(rt_g.debug&DEBUG_EBM)rt_log("seg_out= kmax %g\n", kmax );
d196 1
a196 1
		RT_LIST_INSERT( &(out_hd->l), &(curr->l) );
d268 1
a268 1
if(rt_g.debug&DEBUG_EBM)rt_log("[shoot: r_min=%g, r_max=%g]\n", rp->r_min, rp->r_max);
d283 1
a283 1
if(rt_g.debug&DEBUG_EBM)rt_log("g[X] = %d, g[Y] = %d\n", igrid[X], igrid[Y]);
d293 1
a293 1
if(rt_g.debug&DEBUG_EBM)rt_log("ray on local Z axis\n");
d318 1
a318 1
		RT_LIST_INSERT( &(seghead->l), &(segp->l) );
d360 2
a361 2
if(rt_g.debug&DEBUG_EBM)rt_log("t[X] = %g, delta[X] = %g\n", t[X], delta[X] );
if(rt_g.debug&DEBUG_EBM)rt_log("t[Y] = %g, delta[Y] = %g\n", t[Y], delta[Y] );
d379 1
a379 1
if(rt_g.debug&DEBUG_EBM)rt_log("Entry index is %s, t0=%g\n", in_index==X ? "X" : "Y", t0);
d387 1
a387 1
		rt_log("*** advancing t[X]\n");
d391 1
a391 1
		rt_log("*** advancing t[Y]\n");
d394 1
a394 1
if(rt_g.debug&DEBUG_EBM)rt_log("Exit t[X]=%g, t[Y]=%g\n", t[X], t[Y] );
d409 1
a409 1
if(rt_g.debug&DEBUG_EBM)rt_log("igrid [%d %d] from %g to %g, val=%d\n",
d412 1
a412 1
if(rt_g.debug&DEBUG_EBM)rt_log("Exit index is %s, t[X]=%g, t[Y]=%g\n",
d416 1
a416 1
		if( t1 <= t0 )  rt_log("ERROR ebm t1=%g < t0=%g\n", t1, t0 );
d442 1
a442 1
				RT_LIST_INSERT( &(seghead->l), &(segp->l) );
d444 1
a444 1
				if(rt_g.debug&DEBUG_EBM) rt_log("START t=%g, surfno=%d\n",
d458 1
a458 1
				tail = RT_LIST_LAST( seg, &(seghead->l) );
d476 1
a476 1
				if(rt_g.debug&DEBUG_EBM) rt_log("END t=%g, surfno=%d\n",
d496 1
a496 1
		tail = RT_LIST_LAST( seg, &(seghead->l) );
d508 1
a508 1
		if(rt_g.debug&DEBUG_EBM) rt_log("closed END t=%g, surfno=%d\n",
d512 1
a512 1
	if( RT_LIST_IS_EMPTY( &(seghead->l) ) )
d527 1
a527 1
CONST struct rt_external	*ep;
d536 1
a536 1
	struct rt_mapped_file	*mp;
d539 1
a539 1
	RT_CK_EXTERNAL( ep );
d542 1
a542 1
		rt_log("rt_ebm_import: defective strsol record\n");
d548 1
a548 1
	ip->idb_ptr = rt_calloc(1, sizeof(struct rt_ebm_internal), "rt_ebm_internal");
d553 1
a553 1
	mat_idn( eip->mat );
d559 1
a559 1
		rt_free( (char *)eip , "rt_ebm_import: eip" );
d572 1
a572 1
	    	rt_free( (char *)eip , "rt_ebm_import: eip" );
d579 2
a580 2
	mat_mul( tmat, mat, eip->mat );
	mat_copy( eip->mat, tmat );
d583 3
a585 3
	if( !(mp = rt_open_mapped_file( eip->file, "ebm" )) )  {
		rt_log("rt_ebm_import() unable to open '%s'\n", eip->file);
		rt_free( (char *)eip , "rt_ebm_import: eip" );
d593 1
a593 1
		rt_log("rt_ebm_import() file '%s' is too short %d < %d\n",
d601 1
a601 1
		mp->apbuf = (genptr_t)rt_calloc(
d623 1
a623 1
struct rt_external		*ep;
d641 1
a641 1
	RT_INIT_EXTERNAL(ep);
d643 1
a643 1
	ep->ext_buf = (genptr_t)rt_calloc( 1, ep->ext_nbytes, "ebm external");
d718 2
a719 2
		RT_CK_MAPPED_FILE(eip->mp);
		rt_close_mapped_file(eip->mp);
d723 2
a724 2
	eip->mp = (struct rt_mapped_file *)0;
	rt_free( (char *)eip, "ebm ifree" );
d756 1
a756 1
	GETSTRUCT( ebmp, rt_ebm_specific );
d760 1
a760 1
	eip->mp = (struct rt_mapped_file *)0;	/* "steal" the mapped file */
d763 1
a763 1
	mat_inv( ebmp->ebm_mat, eip->mat );
d778 1
a778 1
	rt_rotate_bbox( stp->st_min, stp->st_max, eip->mat,
d806 2
a807 2
	rt_log("ebm file = %s\n", ebmp->ebm_i.file );
	rt_log("dimensions = (%d, %d, %g)\n",
d839 1
a839 1
	RT_LIST_INIT( &(myhead.l) );
d846 1
a846 1
rt_log("%g %g %g %g %g %g\n",
d911 1
a911 1
		rt_log("ebm_norm(%s): surfno=%d bad\n",
d970 2
a971 2
	RT_CK_MAPPED_FILE(ebmp->ebm_i.mp);
	rt_close_mapped_file(ebmp->ebm_i.mp);
d973 1
a973 1
	rt_free( (char *)ebmp, "rt_ebm_specific" );
d987 1
a987 1
struct rt_list	*vhead;
d990 1
a990 1
struct rt_tol		*tol;
d1050 1
a1050 1
register struct rt_list	*vhead;
d1076 1
a1076 1
	struct rt_list	l;
d1093 1
a1093 1
	new_edge = (struct ebm_edge *)rt_malloc( sizeof( struct ebm_edge ) , "rt_ebm_tess: new_edge" );	
d1113 1
a1113 1
	RT_LIST_APPEND( &edges->l , &new_edge->l );
d1129 1
a1129 1
	RT_LIST_INIT( &loops.l );
d1131 1
a1131 1
	while( RT_LIST_NON_EMPTY( &edges->l ) )
d1137 2
a1138 2
		next = RT_LIST_FIRST( ebm_edge , &edges->l );
		while( RT_LIST_NOT_HEAD( &next->l , &edges->l ) )
d1142 1
a1142 1
				next = RT_LIST_PNEXT( ebm_edge , &next->l );
d1151 1
a1151 1
			next = RT_LIST_PNEXT( ebm_edge , &next->l );
d1158 2
a1159 2
		RT_LIST_DEQUEUE( &start->l );
		RT_LIST_INSERT( &loops.l , &start->l );
d1178 1
a1178 1
			for( RT_LIST_FOR( e , ebm_edge , &edges->l ) )
d1251 2
a1252 2
			RT_LIST_DEQUEUE( &next->l );
			RT_LIST_INSERT( &loops.l , &next->l );
d1269 1
a1269 1
	RT_LIST_INSERT_LIST( &edges->l , &loops.l );
d1283 1
a1283 1
struct rt_tol		*tol;
d1298 1
a1298 1
	RT_CK_TOL( tol );
d1305 1
a1305 1
	RT_LIST_INIT( &edges.l );
d1362 1
a1362 1
	s = RT_LIST_FIRST(shell, &(*r)->s_hd);
d1365 1
a1365 1
	vertp = (struct vertex ***)rt_calloc( max_loop_length , sizeof( struct vertex **) ,
d1367 1
a1367 1
	loop_verts = (struct vertex **)rt_calloc( max_loop_length , sizeof( struct vertex *),
d1370 2
a1371 2
	e = RT_LIST_FIRST( ebm_edge , &edges.l );
	while( RT_LIST_NOT_HEAD( &e->l , &edges.l ) )
d1377 2
a1378 2
		e = RT_LIST_PNEXT( ebm_edge , &start_loop->l );
		while( RT_LIST_NOT_HEAD( &e->l , &edges.l ) )
d1407 1
a1407 1
							e1 = RT_LIST_PNEXT( ebm_edge , &e1->l );
d1448 1
a1448 1
							e1 = RT_LIST_PNEXT( ebm_edge , &e1->l );
d1455 1
a1455 1
			e = RT_LIST_PNEXT( ebm_edge , &e->l );
d1457 1
a1457 1
		e = RT_LIST_PNEXT( ebm_edge , &e->l );
d1463 1
a1463 1
	fu = RT_LIST_FIRST( faceuse , &s->fu_hd );
d1475 3
a1477 3
	rt_free( (char *)vertp , "rt_ebm_tess: vertp" );
	rt_free( (char *)loop_verts , "rt_ebm_tess: loop_verts" );
	while( RT_LIST_NON_EMPTY( &edges.l ) )
d1479 3
a1481 3
		e = RT_LIST_FIRST( ebm_edge , &edges.l );
		RT_LIST_DEQUEUE( &e->l );
		rt_free( (char *)e , "rt_ebm_tess: e" );
d1486 3
a1488 3
	rt_free( (char *)vertp , "rt_ebm_tess: vertp" );
	rt_free( (char *)loop_verts , "rt_ebm_tess: loop_verts" );
	while( RT_LIST_NON_EMPTY( &edges.l ) )
d1490 3
a1492 3
		e = RT_LIST_FIRST( ebm_edge , &edges.l );
		RT_LIST_DEQUEUE( &e->l );
		rt_free( (char *)e , "rt_ebm_tess: e" );
d1536 1
a1536 1
	mat_idn( Tsolid.st_matp );
@


11.6
log
@Modified describe routine to use local units.
@
text
@d21 1
a21 1
static char RCSebm[] = "@@(#)$Header: /m/cad/librt/RCS/g_ebm.c,v 11.5 1996/08/31 11:04:24 mike Exp jra $ (BRL)";
d364 9
a372 1
	if( t[X] >= t[Y] )  {
@


11.5
log
@bn.h
@
text
@d21 1
a21 1
static char RCSebm[] = "@@(#)$Header: /m/cad/librt/RCS/g_ebm.c,v 11.4 1996/08/29 22:49:42 butler Exp mike $ (BRL)";
d665 2
d669 2
d673 17
a689 2
	bu_vls_struct_print( str, rt_ebm_parse, (char *)eip );
	bu_vls_strcat( str, "\n" );
@


11.4
log
@structparse moved to libbu
@
text
@d21 1
a21 1
static char RCSebm[] = "@@(#)$Header: /m/cad/librt/RCS/g_ebm.c,v 11.3 1996/07/11 15:18:42 jra Exp butler $ (BRL)";
d524 1
a524 1
	struct rt_vls	str;
d547 4
a550 4
	rt_vls_init( &str );
	rt_vls_strcpy( &str, rp->ss.ss_args );
	if( bu_structparse( &str, rt_ebm_parse, (char *)eip ) < 0 )  {
		rt_vls_free( &str );
d556 1
a556 1
	rt_vls_free( &str );
d562 1
a562 1
	    	bu_structprint( "Unreasonable EBM parameters", rt_ebm_parse,
d622 1
a622 1
	struct rt_vls		str;
d638 2
a639 2
	RT_VLS_INIT( &str );
	bu_vls_structprint( &str, rt_ebm_parse, (char *)&ebm );
d643 2
a644 2
	strncpy( rec->ss.ss_args, rt_vls_addr(&str), DB_SS_LEN-1 );
	rt_vls_free( &str );
d658 1
a658 1
struct rt_vls		*str;
d667 1
a667 1
	rt_vls_strcat( str, "extruded bitmap (EBM)\n\t");
d669 2
a670 2
	bu_vls_structprint( str, rt_ebm_parse, (char *)eip );
	rt_vls_strcat( str, "\n" );
@


11.3
log
@Declaration fixes for IRIX 6.2
@
text
@d21 1
a21 1
static char RCSebm[] = "@@(#)$Header: /m/cad/librt/RCS/g_ebm.c,v 11.2 1996/04/24 22:17:48 butler Exp jra $ (BRL)";
d53 1
a53 1
struct structparse rt_ebm_parse[] = {
d549 1
a549 1
	if( rt_structparse( &str, rt_ebm_parse, (char *)eip ) < 0 )  {
d562 1
a562 1
	    	rt_structprint( "Unreasonable EBM parameters", rt_ebm_parse,
d639 1
a639 1
	rt_vls_structprint( &str, rt_ebm_parse, (char *)&ebm );
d669 1
a669 1
	rt_vls_structprint( str, rt_ebm_parse, (char *)eip );
@


11.2
log
@checkpoint
@
text
@d21 1
a21 1
static char RCSebm[] = "@@(#)$Header: /m/cad/librt/RCS/g_ebm.c,v 11.1 1995/01/04 09:56:32 mike Rel4_4 butler $ (BRL)";
d77 2
d1017 1
@


11.1
log
@Release_4.4
@
text
@d21 1
a21 1
static char RCSebm[] = "@@(#)$Header: /m/cad/librt/RCS/g_ebm.c,v 10.12 94/12/28 12:54:42 jra Exp $ (BRL)";
d66 6
d256 4
a259 1
	VJOIN1( P, rp->r_pt, rp->r_min, rp->r_dir );	/* P is hit point */
d285 1
d298 11
d405 1
d417 5
d451 5
d488 1
d920 5
a924 2
/*	register struct rt_ebm_specific *ebmp =
		(struct rt_ebm_specific *)stp->st_specific; */
d926 3
a928 1
	/* XXX uv should be xy in ideal space */
@


10.12
log
@import shouldn't allocate memory for apbuf if it's already been done.
@
text
@d21 1
a21 1
static char RCSebm[] = "@@(#)$Header: /m/cad/librt/RCS/g_ebm.c,v 10.11 94/12/08 23:14:52 mike Exp Locker: jra $ (BRL)";
@


10.11
log
@Extra sanity check.
@
text
@d21 1
a21 1
static char RCSebm[] = "@@(#)$Header: /m/cad/librt/RCS/g_ebm.c,v 10.10 94/12/01 20:11:45 mike Exp Locker: mike $ (BRL)";
d556 6
a561 3
	mp->apbuf = (genptr_t)rt_calloc(
		1, nbytes, "rt_ebm_import bitmap" );
	mp->apbuflen = nbytes;
@


10.10
log
@lint
@
text
@d21 1
a21 1
static char RCSebm[] = "@@(#)$Header: /m/cad/librt/RCS/g_ebm.c,v 10.9 94/11/04 05:44:18 mike Exp Locker: mike $ (BRL)";
d661 1
@


10.9
log
@Irix 6
@
text
@d21 1
a21 1
static char RCSebm[] = "@@(#)$Header: /m/cad/librt/RCS/g_ebm.c,v 10.8 94/10/29 02:08:20 mike Exp Locker: mike $ (BRL)";
d561 1
a561 1
	cp = mp->buf;
@


10.8
log
@Converted over to use rt_open_mapped_file().
@
text
@d21 1
a21 1
static char RCSebm[] = "@@(#)$Header: /m/cad/librt/RCS/g_ebm.c,v 10.7 94/10/06 10:08:24 jra Exp Locker: mike $ (BRL)";
a489 1
	FILE		*fp;
a492 1
	int		ret;
d1214 1
a1214 1
	struct shell	*s,*s2;
a1220 1
	long 		**trans_tbl;
a1223 1
	int		start_x,start_y;
a1300 2
		vect_t normal;

a1346 2
					struct faceuse *fu2;

d1356 1
a1356 1
					fu2 = nmg_add_loop_to_face( s , fu , loop_verts ,
@


10.7
log
@Added some rt_free's where rt_ebm_import returns error codes.
@
text
@d21 1
a21 1
static char RCSebm[] = "@@(#)$Header: /m/cad/librt/RCS/g_ebm.c,v 10.6 94/09/20 17:43:12 jra Exp Locker: jra $ (BRL)";
d94 3
a96 2
	(_eip)->map[((_yy)+BIT_YWIDEN)*((_eip)->xdim + \
	BIT_XWIDEN*2)+(_xx)+BIT_XWIDEN]
d495 2
d542 2
a543 9
	nbytes = (eip->xdim+BIT_XWIDEN*2)*(eip->ydim+BIT_YWIDEN*2);
	eip->map = (unsigned char *)rt_calloc(
		1, nbytes, "rt_ebm_import bitmap" );

	RES_ACQUIRE( &rt_g.res_syscall );		/* lock */
	if( (fp = fopen(eip->file, "r")) == NULL )  {
		perror(eip->file);
		RES_RELEASE( &rt_g.res_syscall );		/* unlock */
		rt_free( (char *)eip->map , "rt_ebm_import: eip->map" );
d545 1
d548 1
a548 1
		return(-1);
d550 6
a555 1
	RES_RELEASE( &rt_g.res_syscall );		/* unlock */
d557 5
d563 1
d565 3
a567 7
		RES_ACQUIRE( &rt_g.res_syscall );		/* lock */
		ret = fread( &BIT( eip, 0, y), eip->xdim, 1, fp ); /* res_syscall */
		RES_RELEASE( &rt_g.res_syscall );		/* unlock */
		if( ret != 1 )  {
			rt_log("rt_ebm_import(%s): fread error, y=%d\n",
				eip->file, y );
		}
a568 3
	RES_ACQUIRE( &rt_g.res_syscall );		/* lock */
	fclose(fp);
	RES_RELEASE( &rt_g.res_syscall );		/* unlock */
d654 4
a657 1
	if( eip->map) rt_free( (char *)eip->map, "ebm bitmap" );
d660 1
a660 1
	eip->map = (unsigned char *)0;
a693 1
	eip->map = (unsigned char *)0;	/* "steal" the bitmap storage */
d695 3
d901 3
a903 1
	rt_free( (char *)ebmp->ebm_i.map, "ebm_map" );
@


10.6
log
@Tessellator.
@
text
@d21 1
a21 1
static char RCSebm[] = "@@(#)$Header: /m/cad/librt/RCS/g_ebm.c,v 10.5 94/09/16 16:47:17 jra Exp Locker: jra $ (BRL)";
d515 3
d528 3
d547 4
d1223 1
@


10.5
log
@Checkpoint (working on tesselator).
@
text
@d21 1
a21 1
static char RCSebm[] = "@@(#)$Header: /m/cad/librt/RCS/g_ebm.c,v 10.4 94/08/10 18:25:26 gdurf Exp Locker: jra $ (BRL)";
d33 1
a35 1
#include "nmg.h"
d991 1
d997 1
a997 1
rt_ebm_edge( x1, y1, x2, y2, edges )
d1000 1
d1014 1
d1022 1
d1028 1
a1028 74
static void
rt_ebm_isect_edges( edges )
struct ebm_edge *edges;
{
	struct ebm_edge *edge1;
	struct ebm_edge *new_edge1,*new_edge2;

rt_log( "rt_ebm_isect_edges:\n" );

	/* intersect all edges with all other edges */
	for( RT_LIST_FOR( edge1 , ebm_edge , &edges->l ) )
	{
		struct ebm_edge *edge2;

		for( RT_LIST_FOR( edge2 , ebm_edge , &edges->l ) )
		{
			int isect_x,isect_y;

			if( edge1 == edge2 )
				continue;

			/* skip pairs fo edges that don't intersect */
			if( edge1->x2 <= edge2->x1 || edge1->y2 <= edge2->y1 ||
			    edge2->x2 <= edge1->x1 || edge2->y2 <= edge1->y1 )
				continue;

			if( edge1->x1 < edge2->x1 && edge1->x2 > edge2->x2 )
				isect_x = edge2->x1;
			else
				isect_x = edge1->x1;

			if( edge1->y1 < edge2->y1 && edge1->y2 > edge2->y2 )
				isect_y = edge2->y1;
			else
				isect_y = edge1->y1;
rt_log( "( %d %d ) -> ( %d %d )\n( %d %d ) -> ( %d %d )\n\t intersect at ( %d %d )\n",
edge1->x1,edge1->y1,edge1->x2,edge1->y2,edge2->x1,edge2->y1,edge2->x2,edge2->y2,isect_x,isect_y );

			new_edge1 = (struct ebm_edge *)rt_malloc( sizeof( struct ebm_edge ) , "rt_ebm_tess: new _edge1" );
			new_edge2 = (struct ebm_edge *)rt_malloc( sizeof( struct ebm_edge ) , "rt_ebm_tess: new _edge2" );

			new_edge1->x1 = isect_x;
			new_edge1->y1 = isect_y;
			new_edge1->x2 = edge1->x2;
			new_edge1->y2 = edge1->y2;
			new_edge1->v = (struct vertex *)NULL;

			edge1->x2 = isect_x;
			edge1->y2 = isect_y;
			
			new_edge2->x1 = isect_x;
			new_edge2->y1 = isect_y;
			new_edge2->x2 = edge2->x2;
			new_edge2->y2 = edge2->y2;
			new_edge2->v = (struct vertex *)NULL;

			edge2->x2 = isect_x;
			edge2->y2 = isect_y;

			RT_LIST_APPEND( &edges->l , &new_edge1->l );
			RT_LIST_APPEND( &edges->l , &new_edge2->l );
		}
	}
{
struct ebm_edge *ee;
rt_log( "Final edges:\n" );
for( RT_LIST_FOR( ee , ebm_edge , &edges->l ) )
{
	rt_log( "( %d %d ) -> ( %d %d )\n" , ee->x1,ee->y1,ee->x2,ee->y2 );
}
}
}

static void
d1037 2
a1051 2
			struct ebm_edge *next;

d1053 2
d1056 1
d1071 1
a1071 1
		RT_LIST_INSERT( &start->l , &loops.l );
d1082 1
d1147 1
d1155 1
d1161 2
d1164 1
a1164 1
			RT_LIST_INSERT( &next->l , &loops.l );
d1167 3
d1171 6
d1182 2
d1198 2
a1200 2
	struct shell	*s;
	struct vertex	**verts;	/* dynamic array of pointers */
d1202 1
a1202 1
	struct faceuse	*fu;
d1204 7
a1210 1
	int		base,x,y,following;
d1212 2
d1220 17
a1236 15
	/* Find vertical edges */
	base = 0;	/* lint */
	for( x=0; x <= eip->xdim; x++ )  {
		following = 0;
		for( y=0; y <= eip->ydim; y++ )  {
			if( following )  {
				if( (BIT( eip, x-1, y )==0) != (BIT( eip, x, y )==0) )
					continue;
				rt_ebm_edge( x, base, x, y, &edges );
				following = 0;
			} else {
				if( (BIT( eip, x-1, y )==0) == (BIT( eip, x, y )==0) )
					continue;
				following = 1;
				base = y;
d1238 2
d1241 1
d1244 17
a1260 14
	/* Find horizontal edges */
	for( y=0; y <= eip->ydim; y++ )  {
		following = 0;
		for( x=0; x <= eip->xdim; x++ )  {
			if( following )  {
				if( (BIT( eip, x, y-1 )==0) != (BIT( eip, x, y )==0) )
					continue;
				rt_ebm_edge( base, y, x, y, &edges );
				following = 0;
			} else {
				if( (BIT( eip, x, y-1 )==0) == (BIT( eip, x, y )==0) )
					continue;
				following = 1;
				base = x;
d1262 2
d1265 1
a1266 8
{
struct ebm_edge *ee;
rt_log( "Edges:\n" );
for( RT_LIST_FOR( ee , ebm_edge , &edges.l ) )
{
	rt_log( "( %d %d ) -> ( %d %d )\n" , ee->x1,ee->y1,ee->x2,ee->y2 );
}
}
d1268 2
a1269 2
	/* Intersect all edges with all others */
	rt_ebm_isect_edges( &edges );
d1271 140
a1410 10
	/* Sort edges into loops */
	rt_ebm_sort_edges( &edges );
{
struct ebm_edge *ee;
rt_log( "Sorted edges:\n" );
for( RT_LIST_FOR( ee , ebm_edge , &edges.l ) )
{
	rt_log( "( %d %d ) -> ( %d %d )\n" , ee->x1,ee->y1,ee->x2,ee->y2 );
}
}
@


10.4
log
@Added include of conf.
@
text
@d21 1
a21 1
static char RCSebm[] = "@@(#)$Header: /m/cad/librt/RCS/g_ebm.c,v 10.3 1993/07/20 20:54:26 mike Exp gdurf $ (BRL)";
d986 250
a1247 1
#if 0
d1253 2
a1254 1
#endif
d1260 61
a1320 1
	/* XXX tess routine needed */
@


10.3
log
@comment in comment.
@
text
@d21 1
a21 1
static char RCSebm[] = "@@(#)$Header: /m/cad/librt/RCS/g_ebm.c,v 10.2 93/03/02 17:29:07 mike Exp Locker: mike $ (BRL)";
d23 2
@


10.2
log
@RT_LIST_LOOP is now RT_LIST_WHILE
@
text
@d21 1
a21 1
static char RCSebm[] = "@@(#)$Header: /m/cad/librt/RCS/g_ebm.c,v 10.1 91/10/12 06:40:14 mike Rel4_0 Locker: mike $ (BRL)";
d996 7
a1002 5
/*	register int	i; 		*/
/*	struct shell	*s;		*/
/*	struct vertex	**verts;	/* dynamic array of pointers */
/*	struct vertex	***vertp;	/* dynam array of ptrs to pointers */
/*	struct faceuse	*fu;		*/
@


10.1
log
@Release_4.0
@
text
@d21 1
a21 1
static char RCSebm[] = "@@(#)$Header: /m/cad/librt/RCS/g_ebm.c,v 9.26 91/09/20 23:01:48 butler Exp $ (BRL)";
d162 1
a162 1
	while( RT_LIST_LOOP( curr, seg, &(in_hd->l) ) )  {
@


9.26
log
@removing fuzz with lint
@
text
@d21 1
a21 1
static char RCSebm[] = "@@(#)$Header: /m/cad/librt/RCS/g_ebm.c,v 9.25 91/08/29 22:14:33 mike Exp $ (BRL)";
@


9.25
log
@needs nmg.h
@
text
@d21 1
a21 1
static char RCSebm[] = "@@(#)$Header: /m/cad/librt/RCS/g_ebm.c,v 9.24 91/07/05 23:40:12 mike Exp $ (BRL)";
d60 1
a60 1
	{"%f",	16, "mat", offsetofarray(struct rt_ebm_internal,mat), FUNC_NULL },
a572 1
	register int		i;
a613 1
	register int			j;
a615 2
	char				buf[256];
	int				i;
a635 1
	register int			i;
d847 2
a848 2
	register struct rt_ebm_specific *ebmp =
		(struct rt_ebm_specific *)stp->st_specific;
d867 2
a868 2
	register struct rt_ebm_specific *ebmp =
		(struct rt_ebm_specific *)stp->st_specific;
d907 1
a907 1
	int		i;
d996 5
a1000 5
	register int	i;
	struct shell	*s;
	struct vertex	**verts;	/* dynamic array of pointers */
	struct vertex	***vertp;	/* dynam array of ptrs to pointers */
	struct faceuse	*fu;
@


9.24
log
@ANSI structure initialization
@
text
@d21 1
a21 1
static char RCSebm[] = "@@(#)$Header: /m/cad/librt/RCS/g_ebm.c,v 9.23 91/06/30 00:08:29 mike Exp $ (BRL)";
d33 1
@


9.23
log
@Some args are now CONST.
Protected all STDIO fread stuff with RES_ACQUIRE( res_syscall ).
@
text
@d21 1
a21 1
static char RCSebm[] = "@@(#)$Header: /m/cad/librt/RCS/g_ebm.c,v 9.22 91/06/22 22:30:19 mike Exp $ (BRL)";
d52 1
a52 1
	"%s",	RT_EBM_NAME_LEN, "file",	1,	FUNC_NULL,
d54 1
a54 1
	"%s",	RT_EBM_NAME_LEN, "file", offsetofarray(struct rt_ebm_internal, file), FUNC_NULL,
d56 5
a60 5
	"%d",	1, "w",		RT_EBM_O(xdim),		FUNC_NULL,
	"%d",	1, "n",		RT_EBM_O(ydim),		FUNC_NULL,
	"%f",	1, "d",		RT_EBM_O(tallness),	FUNC_NULL,
	"%f",	16, "mat", offsetofarray(struct rt_ebm_internal,mat), FUNC_NULL,
	"",	0, (char *)0, 0,			FUNC_NULL
@


9.22
log
@Tolerance can be had from ap->a_rt_i->rti_tol, so it is no longer
passed as a parameter on ft_prep, ft_shot, or ft_vshot.
ft_vshot calling sequence also changed to use application structure.
@
text
@d21 1
a21 1
static char RCSebm[] = "@@(#)$Header: /m/cad/librt/RCS/g_ebm.c,v 9.21 91/06/14 06:47:57 mike Exp $ (BRL)";
d479 3
a481 3
struct rt_db_internal	*ip;
struct rt_external	*ep;
mat_t			mat;
d490 1
d534 1
d537 1
d540 1
d544 4
a547 1
		if( fread( &BIT( eip, 0, y), eip->xdim, 1, fp ) != 1 )  {
d552 1
d554 1
d565 3
a567 3
struct rt_external	*ep;
struct rt_db_internal	*ip;
double			local2mm;
d723 1
a723 1
register struct soltab	*stp;
d725 1
a725 1
	register struct rt_ebm_specific *ebmp =
@


9.21
log
@Eliminated one last st_pathmat
@
text
@d21 1
a21 1
static char RCSebm[] = "@@(#)$Header: /m/cad/librt/RCS/g_ebm.c,v 9.20 91/06/14 06:25:55 mike Exp $ (BRL)";
d656 1
a656 1
rt_ebm_prep( stp, ip, rtip, tol )
a659 1
CONST struct rt_tol	*tol;
d739 1
a739 1
rt_ebm_shot( stp, rp, ap, seghead, tol )
a743 1
CONST struct rt_tol	*tol;
@


9.20
log
@Changed to use rt_rotate_bbox
@
text
@d21 1
a21 1
static char RCSebm[] = "@@(#)$Header: /m/cad/librt/RCS/g_ebm.c,v 9.19 91/06/14 06:22:11 mike Exp $ (BRL)";
d1017 1
d1044 2
a1045 1
	mat_idn( Tsolid.st_pathmat );
d1057 1
a1057 1
	outline( Tsolid.st_pathmat, &rec );
@


9.19
log
@Changed to new definition of string solid database record.
Eliminated uses of stp->st_pathmat.
Can now rotate and translate the solid itself, via "mat" string in db.
@
text
@d21 1
a21 1
static char RCSebm[] = "@@(#)$Header: /m/cad/librt/RCS/g_ebm.c,v 9.18 91/05/18 03:00:49 mike Exp $ (BRL)";
a644 32
 *			R T _ R O T _ B O U N D _ R P P
 *
 *  Given an RPP that defines a bounding cube in a local coordinate
 *  system, transform that cube into another coordinate system,
 *  and then find the new (usually somewhat larger) bounding RPP.
 */
void
rt_rot_bound_rpp( omin, omax, mat, imin, imax )
vect_t	omin, omax;
mat_t	mat;
vect_t	imin, imax;
{
	point_t	local;		/* vertex point in local coordinates */
	point_t	model;		/* vertex point in model coordinates */

#define ROT_VERT( a, b, c )  \
	VSET( local, a[X], b[Y], c[Z] ); \
	MAT4X3PNT( model, mat, local ); \
	VMINMAX( omin, omax, model ) \

	ROT_VERT( imin, imin, imin );
	ROT_VERT( imin, imin, imax );
	ROT_VERT( imin, imax, imin );
	ROT_VERT( imin, imax, imax );
	ROT_VERT( imax, imin, imin );
	ROT_VERT( imax, imin, imax );
	ROT_VERT( imax, imax, imin );
	ROT_VERT( imax, imax, imax );
#undef ROT_VERT
}

/*
d692 1
a692 1
	rt_rot_bound_rpp( stp->st_min, stp->st_max, eip->mat,
@


9.18
log
@Converted to new tolerance interface
@
text
@d21 1
a21 1
static char RCSebm[] = "@@(#)$Header: /m/cad/librt/RCS/g_ebm.c,v 9.17 91/02/17 20:01:35 mike Exp $ (BRL)";
d59 1
a59 1
	/* XXX might have option for ebm_origin */
a475 2
 *
 *  XXX no way to deal with mat !!!
d489 1
a489 1
	char		*cp;
d504 3
d508 1
a508 7
	cp = rp->ss.ss_str;
	/* First word is name of solid type (eg, "ebm") -- skip over it */
	while( *cp && !isspace(*cp) )  cp++;
	/* Skip all white space */
	while( *cp && isspace(*cp) )  cp++;

	rt_vls_strcpy( &str, cp );
d517 1
a517 1
	    eip->ydim < 1 ||
d519 2
a520 1
	    	rt_log("Unreasonable EBM parameters\n");
d524 4
a552 2
 *  Generally, only libwdb will set conv2mm != 1.0
 *  XXX no way to deal with local2mm !!
d561 1
d570 1
d572 3
d576 1
a576 1
	ep->ext_nbytes = sizeof(union record);
d581 1
a581 1
	rt_vls_structprint( &str, rt_ebm_parse, (char *)eip );
d584 3
a586 1
	(void)sprintf( rec->ss.ss_str, "ebm %s", rt_vls_addr( & str ) );
a587 1
	rt_vls_free( &str );
a707 1
	/* XXX this should be handled in import, not here XXX */
d709 1
a709 1
	mat_inv( ebmp->ebm_mat, stp->st_pathmat );
d711 1
a711 1
	/* Pre-compute the necessary normals */
d713 1
a713 1
	MAT4X3VEC( ebmp->ebm_xnorm, stp->st_pathmat, norm );
d715 1
a715 1
	MAT4X3VEC( ebmp->ebm_ynorm, stp->st_pathmat, norm );
d717 1
a717 1
	MAT4X3VEC( ebmp->ebm_znorm, stp->st_pathmat, norm );
d724 1
a724 1
	rt_rot_bound_rpp( stp->st_min, stp->st_max, stp->st_pathmat,
a936 1
	mat_t		mat;
a937 2
	mat_idn(mat);	/* XXX hack */

d951 1
a951 1
					mat, vhead );
d970 1
a970 1
					mat, vhead );
d1077 2
a1078 1
	strcpy( rec.ss.ss_str, "ebm file=bm.bw w=6 n=6 d=6.0" );
@


9.17
log
@Check return code from structparse
@
text
@d21 1
a21 1
static char RCSebm[] = "@@(#)$Header: /m/cad/librt/RCS/g_ebm.c,v 9.16 91/01/28 23:53:08 mike Exp $ (BRL)";
d684 1
a684 1
rt_ebm_prep( stp, ip, rtip )
d688 1
d769 1
a769 1
rt_ebm_shot( stp, rp, ap, seghead )
d774 1
d923 1
a923 1
rt_ebm_plot( vhead, ip, abs_tol, rel_tol, norm_tol )
d926 2
a927 3
double		abs_tol;
double		rel_tol;
double		norm_tol;
d1017 1
a1017 1
rt_ebm_tess( r, m, ip, abs_tol, rel_tol, norm_tol )
d1021 2
a1022 3
double		abs_tol;
double		rel_tol;
double		norm_tol;
@


9.16
log
@Converted to new struct rt_vlist (''chunky vlist'')
@
text
@d21 1
a21 1
static char RCSebm[] = "@@(#)$Header: /m/cad/librt/RCS/g_ebm.c,v 9.15 91/01/26 03:14:43 mike Exp $ (BRL)";
d514 4
a517 1
	rt_structparse( &str, rt_ebm_parse, (char *)eip );
@


9.15
log
@Eliminated mat parameter on ft_plot and ft_tess
@
text
@d21 1
a21 1
static char RCSebm[] = "@@(#)$Header: /m/cad/librt/RCS/g_ebm.c,v 9.14 91/01/25 21:18:47 mike Exp $ (BRL)";
d919 1
a919 1
struct vlhead	*vhead;
d985 1
a985 1
register struct vlhead	*vhead;
d992 1
a992 1
	ADD_VL( vhead, srot, 0 );
d996 1
a996 1
	ADD_VL( vhead, prot, 1 );
d1000 1
a1000 1
	ADD_VL( vhead, prot, 1 );
d1004 1
a1004 1
	ADD_VL( vhead, prot, 1 );
d1006 1
a1006 1
	ADD_VL( vhead, srot, 1 );
@


9.14
log
@Converted to new function switch table interface,
using separation between internal and external forms of geometry.
@
text
@d21 1
a21 1
static char RCSebm[] = "@@(#)$Header: /m/cad/librt/RCS/g_ebm.c,v 9.13 91/01/25 19:37:38 mike Exp $ (BRL)";
d700 1
d918 1
a918 1
rt_ebm_plot( vhead, mat, ip, abs_tol, rel_tol, norm_tol )
a919 1
mat_t		mat;
d930 1
d932 2
d1013 1
a1013 1
rt_ebm_tess( r, m, ip, mat, abs_tol, rel_tol, norm_tol )
a1016 1
register mat_t		mat;
@


9.13
log
@Converted to new import/export
@
text
@d21 1
a21 1
static char RCSebm[] = "@@(#)$Header: /m/cad/librt/RCS/g_ebm.c,v 9.12 91/01/05 03:08:49 mike Exp $ (BRL)";
a679 1
#if NEW_IF
a685 10
#else
int
rt_ebm_prep( stp, rec, rtip )
struct soltab	*stp;
union record	*rec;
struct rt_i	*rtip;
{
	struct rt_external	ext, *ep;
	struct rt_db_internal	intern, *ip;
#endif
a692 13

#if NEW_IF
	/* All set */
#else
	ep = &ext;
	RT_INIT_EXTERNAL(ep);
	ep->ext_buf = (genptr_t)rec;
	ep->ext_nbytes = stp->st_dp->d_len*sizeof(union record);
	ip = &intern;
	if( rt_ebm_import( ip, ep, stp->st_pathmat ) < 0 )
		return(-1);		/* BAD */
	RT_CK_DB_INTERNAL( ip );
#endif
a915 1
#if NEW_IF
a924 11
#else
int
rt_ebm_plot( rp, mat, vhead, dp )
union record	*rp;
mat_t		mat;
struct vlhead	*vhead;
struct directory *dp;
{
	struct rt_external	ext, *ep;
	struct rt_db_internal	intern, *ip;
#endif
a930 14
#if NEW_IF
	/* All set */
#else
	ep = &ext;
	RT_INIT_EXTERNAL(ep);
	ep->ext_buf = (genptr_t)rp;
	ep->ext_nbytes = dp->d_len*sizeof(union record);
	i = rt_ebm_import( &intern, ep, mat );
	if( i < 0 )  {
		rt_log("rt_ebm_plot(): db import failure\n");
		return(-1);		/* BAD */
	}
	ip = &intern;
#endif
a1008 1
#if NEW_IF
a1018 14
#else
int
rt_ebm_tess( r, m, rp, mat, dp, abs_tol, rel_tol )
struct nmgregion	**r;
struct model		*m;
register union record	*rp;
register mat_t		mat;
struct directory	*dp;
double			abs_tol;
double			rel_tol;
{
	struct rt_external	ext, *ep;
	struct rt_db_internal	intern, *ip;
#endif
a1025 14
#if NEW_IF
	/* All set */
#else
	ep = &ext;
	RT_INIT_EXTERNAL(ep);
	ep->ext_buf = (genptr_t)rp;
	ep->ext_nbytes = dp->d_len*sizeof(union record);
	i = rt_ebm_import( &intern, ep, mat );
	if( i < 0 )  {
		rt_log("rt_ebm_tess(): db import failure\n");
		return(-1);		/* BAD */
	}
	ip = &intern;
#endif
@


9.12
log
@Converted to new format for fmt entry in structparse
@
text
@d21 1
a21 1
static char RCSebm[] = "@@(#)$Header: /n/wolf/m/cad/librt/RCS/g_ebm.c,v 9.11 90/12/21 14:38:33 mike Exp $ (BRL)";
d30 2
d36 2
a37 7
#define EBM_NAME_LEN 128
struct ebm_specific {
	char		ebm_file[EBM_NAME_LEN];
	unsigned char	*ebm_map;
	int		ebm_xdim;	/* X dimension */
	int		ebm_ydim;	/* Y dimension */
	double		ebm_tallness;	/* Z dimension */
a41 1
	mat_t		ebm_mat;	/* model to ideal space */
d44 1
d46 1
a46 2
#define EBM_NULL	((struct ebm_specific *)0)
#define EBM_O(m)	offsetof(struct ebm_specific, m)
d48 2
d52 1
a52 1
	"%s",	EBM_NAME_LEN, "file",	0,		FUNC_NULL,
d54 1
a54 1
	"%s",	EBM_NAME_LEN, "file",	offsetofarray(struct ebm_specific, ebm_file), FUNC_NULL,
d56 3
a58 3
	"%d",	1, "w",		EBM_O(ebm_xdim),	FUNC_NULL,
	"%d",	1, "n",		EBM_O(ebm_ydim),	FUNC_NULL,
	"%f",	1, "d",		EBM_O(ebm_tallness),	FUNC_NULL,
a62 1
struct ebm_specific	*rt_ebm_import();
d90 3
a92 2
#define BIT(xx,yy)	ebmp->ebm_map[((yy)+BIT_YWIDEN)*(ebmp->ebm_xdim + \
				BIT_XWIDEN*2)+(xx)+BIT_XWIDEN]
d207 2
a208 2
	register struct ebm_specific *ebmp =
		(struct ebm_specific *)stp->st_specific;
d260 2
a261 2
	} else if( igrid[X] >= ebmp->ebm_xdim ) {
		igrid[X] = ebmp->ebm_xdim-1;
d265 2
a266 2
	} else if( igrid[Y] >= ebmp->ebm_ydim ) {
		igrid[Y] = ebmp->ebm_ydim-1;
d278 1
a278 1
		if( BIT( igrid[X], igrid[Y] ) == 0 )
d373 1
a373 1
		val = BIT( igrid[X], igrid[Y] );
d472 6
d479 5
a483 3
HIDDEN struct ebm_specific *
rt_ebm_import( rp )
union record	*rp;
d485 2
a486 1
	register struct ebm_specific *ebmp;
d488 2
a489 2
	FILE	*fp;
	int	nbytes;
d491 1
a491 1
	char	*cp;
d493 6
a498 1
	GETSTRUCT( ebmp, ebm_specific );
d500 6
d514 1
a514 1
	rt_structparse( &str, rt_ebm_parse, (char *)ebmp );
d518 3
a520 3
	if( ebmp->ebm_file[0] == '\0' || ebmp->ebm_xdim < 1 ||
	    ebmp->ebm_ydim < 1 ||
	    ebmp->ebm_tallness <= 0.0 )  {
d522 1
a522 2
		rt_free( (char *)ebmp, "ebm_specific" );
		return( EBM_NULL );
d526 7
a532 11
	nbytes = (ebmp->ebm_xdim+BIT_XWIDEN*2)*(ebmp->ebm_ydim+BIT_YWIDEN*2);
	ebmp->ebm_map = (unsigned char *)rt_malloc( nbytes, "ebm_import bitmap" );
#ifdef SYSV
	memset( ebmp->ebm_map, 0, nbytes );
#else
	bzero( ebmp->ebm_map, nbytes );
#endif
	if( (fp = fopen(ebmp->ebm_file, "r")) == NULL )  {
		perror(ebmp->ebm_file);
		rt_free( (char *)ebmp, "ebm_specific" );
		return( EBM_NULL );
d536 6
a541 2
	for( y=0; y < ebmp->ebm_ydim; y++ )
		(void)fread( &BIT(0, y), ebmp->ebm_xdim, 1, fp );
d543 1
a543 1
	return( ebmp );
d547 91
d677 1
a677 1
 *	A struct ebm_specific is created, and it's address is stored
d680 1
d682 8
a689 1
rt_ebm_prep( stp, rp, rtip )
d691 1
a691 1
union record	*rp;
d694 5
a698 1
	register struct ebm_specific *ebmp;
a703 2
	if( (ebmp = rt_ebm_import( rp )) == EBM_NULL )
		return(-1);	/* ERROR */
d705 19
d739 1
a739 1
	VSET( ebmp->ebm_large, ebmp->ebm_xdim, ebmp->ebm_ydim, ebmp->ebm_tallness );
d765 2
a766 2
	register struct ebm_specific *ebmp =
		(struct ebm_specific *)stp->st_specific;
d768 1
a768 1
	rt_log("ebm file = %s\n", ebmp->ebm_file );
d770 2
a771 2
		ebmp->ebm_xdim, ebmp->ebm_ydim,
		ebmp->ebm_tallness );
d794 2
a795 2
	register struct ebm_specific *ebmp =
		(struct ebm_specific *)stp->st_specific;
d816 1
a816 1
	i = rt_seg_planeclip( seghead, &myhead, norm, 0.0, ebmp->ebm_tallness,
d845 2
a846 2
	register struct ebm_specific *ebmp =
		(struct ebm_specific *)stp->st_specific;
d891 2
a892 2
	register struct ebm_specific *ebmp =
		(struct ebm_specific *)stp->st_specific;
d911 2
a912 2
	register struct ebm_specific *ebmp =
		(struct ebm_specific *)stp->st_specific;
d924 2
a925 2
	register struct ebm_specific *ebmp =
		(struct ebm_specific *)stp->st_specific;
d927 2
a928 2
	rt_free( (char *)ebmp->ebm_map, "ebm_map" );
	rt_free( (char *)ebmp, "ebm_specific" );
d940 1
d942 11
a952 1
rt_ebm_plot( rp, matp, vhead, dp )
d954 1
a954 1
matp_t		matp;
d958 4
a961 1
	register struct ebm_specific *ebmp;
d965 1
d967 17
a983 2
	if( (ebmp = rt_ebm_import( rp )) == EBM_NULL )
		return(-1);
d987 1
a987 1
	for( x=0; x <= ebmp->ebm_xdim; x++ )  {
d989 1
a989 1
		for( y=0; y <= ebmp->ebm_ydim; y++ )  {
d991 1
a991 1
				if( (BIT( x-1, y )==0) != (BIT( x, y )==0) )
d993 2
a994 2
				rt_ebm_plate( x, base, x, y, ebmp->ebm_tallness,
					matp, vhead );
d997 1
a997 1
				if( (BIT( x-1, y )==0) == (BIT( x, y )==0) )
d1006 1
a1006 1
	for( y=0; y <= ebmp->ebm_ydim; y++ )  {
d1008 1
a1008 1
		for( x=0; x <= ebmp->ebm_xdim; x++ )  {
d1010 1
a1010 1
				if( (BIT( x, y-1 )==0) != (BIT( x, y )==0) )
d1012 2
a1013 2
				rt_ebm_plate( base, y, x, y, ebmp->ebm_tallness,
					matp, vhead );
d1016 1
a1016 1
				if( (BIT( x, y-1 )==0) == (BIT( x, y )==0) )
a1022 2
	rt_free( (char *)ebmp->ebm_map, "ebm_map" );
	rt_free( (char *)ebmp, "ebm_specific" );
d1031 1
a1031 1
register matp_t		mat;
d1056 57
d1121 1
a1121 1
struct ebm_specific	*bmsp;
d1133 1
a1133 1
	register struct ebm_specific	*ebmp;
d1158 1
a1158 1
	ebmp = bmsp = (struct ebm_specific *)Tsolid.st_specific;
d1178 1
a1178 1
	for( x=0; x<=ebmp->ebm_xdim; x++ )  {
d1186 1
a1186 1
	for( x=0; x<=ebmp->ebm_xdim; x++ )  {
d1193 2
a1194 2
	for( y=0; y<=ebmp->ebm_ydim; y++ )  {
		for( x=0; x<=ebmp->ebm_xdim; x++ )  {
d1202 2
a1203 2
	for( y= -1; y<=ebmp->ebm_ydim; y++ )  {
		for( x= -1; x<=ebmp->ebm_xdim; x++ )  {
d1211 4
a1214 4
	for( y=0; y<=ebmp->ebm_ydim; y++ )  {
		for( x=0; x<=ebmp->ebm_xdim; x++ )  {
			VSET( pt1, ebmp->ebm_xdim, y, 2 );
			VSET( pt2, x, ebmp->ebm_ydim, 4 );
d1228 2
a1229 2
	for( yy=0; yy<=ebmp->ebm_ydim; yy += 0.3 )  {
		for( xx=0; xx<=ebmp->ebm_xdim; xx += 0.3 )  {
d1237 4
a1240 4
	for( yy=0; yy<=ebmp->ebm_ydim; yy += 0.3 )  {
		for( xx=0; xx<=ebmp->ebm_xdim; xx += 0.3 )  {
			VSET( pt1, ebmp->ebm_xdim, yy, 2 );
			VSET( pt2, xx, ebmp->ebm_ydim, 4 );
d1261 2
a1262 2
	VSET( pt1, ebmp->ebm_xdim, yy, 2 );
	VSET( pt2, xx, ebmp->ebm_ydim, 4 );
d1284 2
a1285 2
		for( yy=0; yy<=ebmp->ebm_ydim; yy += 0.3 )  {
			for( xx=0; xx<=ebmp->ebm_xdim; xx += 0.3 )  {
d1293 1
a1293 1
	for( x=0; x<ebmp->ebm_xdim; x++ )  {
d1309 1
a1309 1
	register struct ebm_specific *ebmp = bmsp;
d1344 1
a1344 1
	register struct ebm_specific *ebmp = bmsp;
d1351 1
a1351 1
		 ebmp->ebm_xdim+BIT_XWIDEN, ebmp->ebm_ydim+BIT_YWIDEN, (int)(ebmp->ebm_tallness+1.99) );
d1353 1
a1353 1
		 ebmp->ebm_xdim+BIT_XWIDEN, ebmp->ebm_ydim+BIT_YWIDEN, (int)(ebmp->ebm_tallness+1.99) );
@


9.11
log
@Added rt_ prefix to all routines
@
text
@d21 1
a21 1
static char RCSebm[] = "@@(#)$Header: /m/cad/librt/RCS/g_ebm.c,v 9.10 90/12/18 00:20:18 butler Exp $ (BRL)";
d62 1
a62 1
	(char *)0, 0, (char *)0, 0,			FUNC_NULL
@


9.10
log
@Converted to new structparse, with vls strings
@
text
@d2 1
a2 1
 *			E B M . C
d21 1
a21 1
static char RCSebm[] = "@@(#)$Header: /m/cad/librt/RCS/g_ebm.c,v 9.9 90/12/08 06:54:30 mike Exp $ (BRL)";
d52 1
a52 1
struct structparse ebm_parse[] = {
d65 2
a66 2
struct ebm_specific	*ebm_import();
RT_EXTERN(int ebm_dda,(struct xray *rp, struct soltab *stp,
d192 1
a192 1
static int ebm_normtab[3] = { NORM_XPOS, NORM_YPOS, NORM_ZPOS };
d196 1
a196 1
 *			E B M _ D D A
d203 1
a203 1
ebm_dda( rp, stp, ap, seghead )
d397 1
a397 1
						ebm_normtab[in_index];
d401 1
a401 1
						(-ebm_normtab[in_index]);
d426 1
a426 1
						(-ebm_normtab[in_index]);
d430 1
a430 1
						ebm_normtab[in_index];
d458 1
a458 1
			tail->seg_out.hit_surfno = (-ebm_normtab[in_index]);
d461 1
a461 1
			tail->seg_out.hit_surfno = ebm_normtab[in_index];
d473 1
a473 1
 *			E B M _ I M P O R T
d476 1
a476 1
ebm_import( rp )
d496 1
a496 1
	rt_structparse( &str, ebm_parse, (char *)ebmp );
d562 1
a562 1
 *			E B M _ P R E P
d570 1
a570 1
 *	in stp->st_specific for use by ebm_shot().
d573 1
a573 1
ebm_prep( stp, rp, rtip )
d584 1
a584 1
	if( (ebmp = ebm_import( rp )) == EBM_NULL )
d622 1
a622 1
 *			E B M _ P R I N T
d625 1
a625 1
ebm_print( stp )
d640 1
a640 1
 *			E B M _ S H O T
d651 1
a651 1
ebm_shot( stp, rp, ap, seghead )
d675 1
a675 1
	if( ebm_dda( &ideal_ray, stp, ap, &myhead ) <= 0 )
d695 1
a695 1
 *			E B M _ N O R M
d703 1
a703 1
ebm_norm( hitp, stp, rp )
d744 1
a744 1
 *			E B M _ C U R V E
d749 1
a749 1
ebm_curve( cvp, hitp, stp )
d762 1
a762 1
 *			E B M _ U V
d768 1
a768 1
ebm_uv( ap, stp, hitp, uvp )
d781 1
a781 1
 * 			E B M _ F R E E
d784 1
a784 1
ebm_free( stp )
d795 1
a795 1
ebm_class()
d801 1
a801 1
 *			E B M _ P L O T
d804 1
a804 1
ebm_plot( rp, matp, vhead, dp )
d815 1
a815 1
	if( (ebmp = ebm_import( rp )) == EBM_NULL )
d826 1
a826 1
				ebm_plate( x, base, x, y, ebmp->ebm_tallness,
d845 1
a845 1
				ebm_plate( base, y, x, y, ebmp->ebm_tallness,
d862 1
a862 1
ebm_plate( x1, y1, x2, y2, t, mat, vhead )
d931 1
a931 1
	if( ebm_prep( &Tsolid, &rec, 0 ) != 0 )  {
d935 1
a935 1
	ebm_print( &Tsolid );
d1101 1
a1101 1
	segp = ebm_shot( &Tsolid, &ray, &Tappl );
d1134 1
a1134 1
	ebm_plot( rp, mat, &vhead, 0 );
@


9.9
log
@Changed for new calling sequence for rt_structparse.
@
text
@d21 1
a21 1
static char RCSebm[] = "@@(#)$Header: /m/cad/librt/RCS/g_ebm.c,v 9.8 90/12/05 20:29:55 mike Exp $ (BRL)";
d34 1
d36 1
a36 1
	char		ebm_file[128];
d54 1
a54 1
	"%s",	"file",		0,			FUNC_NULL,
d56 1
a56 1
	"%s",	"file",	offsetofarray(struct ebm_specific, ebm_file),	FUNC_NULL,
d58 3
a60 3
	"%d",	"w",		EBM_O(ebm_xdim),	FUNC_NULL,
	"%d",	"n",		EBM_O(ebm_ydim),	FUNC_NULL,
	"%f",	"d",		EBM_O(ebm_tallness),	FUNC_NULL,
d62 1
a62 1
	(char *)0,(char *)0,	0,			FUNC_NULL
@


9.8
log
@Fixed return codes on _plot()
@
text
@d21 1
a21 1
static char RCSebm[] = "@@(#)$Header: /m/cad/librt/RCS/g_ebm.c,v 9.7 90/10/15 12:00:53 mike Exp $ (BRL)";
d479 1
a482 1
	char	*str;
d487 2
a488 1
	str = rt_strdup( rp->ss.ss_str );
a489 1
	cp = str;
d494 3
a496 2
	rt_structparse( cp, ebm_parse, (char *)ebmp );
	rt_free( str, "ss_str" );
@


9.7
log
@Changed from using hit_private to hit_surfno for surface indicator
@
text
@d21 1
a21 1
static char RCSebm[] = "@@(#)$Header: /m/cad/librt/RCS/g_ebm.c,v 9.6 90/10/07 21:38:43 mike Exp $ (BRL)";
d801 1
a801 1
void
d814 1
a814 1
		return;
d856 1
@


9.6
log
@soltab structure changed to use struct rt_list.
HeadSolid became rti_headsolid.
@
text
@d21 1
a21 1
static char RCSebm[] = "@@(#)$Header: /m/cad/librt/RCS/g_ebm.c,v 9.5 90/10/06 02:05:10 mike Exp $ (BRL)";
d178 1
a178 1
			curr->seg_in.hit_private = (char *)out_norm_code;
d183 1
a183 1
			curr->seg_out.hit_private = (char *)(-out_norm_code);
d286 2
a287 2
			segp->seg_in.hit_private = (char *)NORM_ZPOS;
			segp->seg_out.hit_private = (char *)NORM_ZNEG;
d289 2
a290 2
			segp->seg_in.hit_private = (char *)NORM_ZNEG;
			segp->seg_out.hit_private = (char *)NORM_ZPOS;
d395 1
a395 1
					segp->seg_in.hit_private = (char *)
d399 1
a399 1
					segp->seg_in.hit_private = (char *)
d404 2
a405 2
				if(rt_g.debug&DEBUG_EBM) rt_log("START t=%g, n=%d\n",
					t0, segp->seg_in.hit_private);
d424 1
a424 1
					tail->seg_out.hit_private = (char *)
d428 1
a428 1
					tail->seg_out.hit_private = (char *)
d431 2
a432 2
				if(rt_g.debug&DEBUG_EBM) rt_log("END t=%g, n=%d\n",
					t0, tail->seg_out.hit_private );
d457 1
a457 2
			tail->seg_out.hit_private = (char *)
				(-ebm_normtab[in_index]);
d460 1
a460 2
			tail->seg_out.hit_private = (char *)
				ebm_normtab[in_index];
d462 2
a463 2
		if(rt_g.debug&DEBUG_EBM) rt_log("closed END t=%g, n=%d\n",
			tmax, tail->seg_out.hit_private );
d711 1
a711 1
	switch( (int) hitp->hit_private )  {
d734 2
a735 2
		rt_log("ebm_norm(%s): norm code %d bad\n",
			stp->st_name, hitp->hit_private );
@


9.5
log
@Converted seg structures to use doubly linked lists.
@
text
@d21 1
a21 1
static char RCSebm[] = "@@(#)$Header: /m/cad/librt/RCS/g_ebm.c,v 9.4 90/03/14 15:05:44 mike Exp $ (BRL)";
d896 1
d922 2
a923 1
	Tsolid.st_name = "Tsolid";
@


9.4
log
@Changed type of st_specific to genptr_t
@
text
@d21 1
a21 1
static char RCSebm[] = "@@(#)$Header: g_ebm.c,v 9.3 89/12/29 21:22:10 mike Locked $ (BRL)";
a63 1
struct seg		*ebm_shot();
d65 5
a69 2
struct seg		*ebm_dda();
struct seg		*rt_seg_planeclip();
d105 2
a106 2
 *	segp		OK: trimmed segment chain, still in sorted order
 *	SEG_NULL	ERROR
d108 4
a111 3
struct seg *
rt_seg_planeclip( segp, out_norm, in, out, rp, ap )
struct seg	*segp;
d121 1
a121 1
	register struct seg	*curr, *next, *outseg, *lastout;
d123 1
d130 2
a131 2
			/* Free segp chain */
			return(SEG_NULL);
d143 2
a144 2
			/* Free segp chain */
			return(SEG_NULL);
d161 3
a163 3
	curr = segp;
	lastout = outseg = SEG_NULL;
	for( curr = segp; curr != SEG_NULL; curr = next )  {
a164 1
		next = curr->seg_next;
d167 1
a167 1
			FREE_SEG(curr, ap->a_resource);
d172 1
a172 1
			FREE_SEG(curr, ap->a_resource);
d185 2
a186 8
		curr->seg_next = SEG_NULL;
		if( lastout == SEG_NULL )  {
			outseg = curr;
			lastout = outseg;
		} else {
			lastout->seg_next = curr;
			lastout = curr;
		}
d188 1
a188 1
	return( outseg );
d201 2
a202 2
struct seg *
ebm_dda( rp, stp, ap )
d206 1
a218 2
	struct seg	*head;
	struct seg	*tail;
a222 2
	head = tail = SEG_NULL;

d246 1
a246 1
		return	0;	/* MISS */
d280 2
a281 2
			return(SEG_NULL);	/* MISS */
		GET_SEG(segp, ap->a_resource);
d292 2
a293 1
		return(segp);			/* HIT */
d388 1
a388 1
				GET_SEG(segp, ap->a_resource);
d402 1
a402 11
				segp->seg_next = SEG_NULL;
				if( head == SEG_NULL ||
				    tail == SEG_NULL )  {
					/* Install as beginning of list */
					tail = segp;
					head = segp;
				} else {
					/* Append to list */
					tail->seg_next = segp;
					tail = segp;
				}
d410 1
d418 1
d448 2
d451 1
d468 3
a470 1
	return(head);
d648 1
a648 1
 *	segp	HIT
d650 2
a651 2
struct seg *
ebm_shot( stp, rp, ap )
d655 1
a658 1
	struct seg	*segp;
d661 2
d664 2
d675 2
a676 1
	segp = ebm_dda( &ideal_ray, stp, ap );
d679 1
a679 1
	segp = rt_seg_planeclip( segp, norm, 0.0, ebmp->ebm_tallness,
d691 1
a691 1
	return(segp);
@


9.3
log
@Subscripts are not permitted inside offsetof() macros.
@
text
@d21 1
a21 1
static char RCSebm[] = "@@(#)$Header: g_ebm.c,v 9.2 89/10/10 16:16:53 mike Locked $ (BRL)";
d606 1
a606 1
	stp->st_specific = (int *)ebmp;
@


9.2
log
@Major overhaul, this version works.
@
text
@d21 1
a21 1
static char RCSebm[] = "@@(#)$Header: g_ebm.c,v 9.1 89/05/19 05:56:07 mike Rel3_5 $ (BRL)";
d37 3
a39 2
	int		ebm_dim[2];
	double		ebm_tallness;
d57 2
a58 2
	"%d",	"w",		EBM_O(ebm_dim[0]),	FUNC_NULL,
	"%d",	"n",		EBM_O(ebm_dim[1]),	FUNC_NULL,
d90 1
a90 1
#define BIT(xx,yy)	ebmp->ebm_map[((yy)+BIT_YWIDEN)*(ebmp->ebm_dim[X] + \
d267 2
a268 2
	} else if( igrid[X] >= ebmp->ebm_dim[X] ) {
		igrid[X] = ebmp->ebm_dim[X]-1;
d272 2
a273 2
	} else if( igrid[Y] >= ebmp->ebm_dim[Y] ) {
		igrid[Y] = ebmp->ebm_dim[Y]-1;
d508 2
a509 2
	if( ebmp->ebm_file[0] == '\0' || ebmp->ebm_dim[0] < 1 ||
	    ebmp->ebm_dim[1] < 1 ||
d517 1
a517 1
	nbytes = (ebmp->ebm_dim[X]+BIT_XWIDEN*2)*(ebmp->ebm_dim[Y]+BIT_YWIDEN*2);
d531 2
a532 2
	for( y=0; y < ebmp->ebm_dim[Y]; y++ )
		(void)fread( &BIT(0, y), ebmp->ebm_dim[X], 1, fp );
d610 1
a610 1
	VSET( ebmp->ebm_large, ebmp->ebm_dim[X], ebmp->ebm_dim[Y], ebmp->ebm_tallness );
d641 1
a641 1
		ebmp->ebm_dim[X], ebmp->ebm_dim[Y],
d823 1
a823 1
	for( x=0; x <= ebmp->ebm_dim[X]; x++ )  {
d825 1
a825 1
		for( y=0; y <= ebmp->ebm_dim[Y]; y++ )  {
d842 1
a842 1
	for( y=0; y <= ebmp->ebm_dim[Y]; y++ )  {
d844 1
a844 1
		for( x=0; x <= ebmp->ebm_dim[X]; x++ )  {
d956 1
a956 1
	for( x=0; x<=ebmp->ebm_dim[X]; x++ )  {
d964 1
a964 1
	for( x=0; x<=ebmp->ebm_dim[X]; x++ )  {
d971 2
a972 2
	for( y=0; y<=ebmp->ebm_dim[Y]; y++ )  {
		for( x=0; x<=ebmp->ebm_dim[X]; x++ )  {
d980 2
a981 2
	for( y= -1; y<=ebmp->ebm_dim[Y]; y++ )  {
		for( x= -1; x<=ebmp->ebm_dim[X]; x++ )  {
d989 4
a992 4
	for( y=0; y<=ebmp->ebm_dim[Y]; y++ )  {
		for( x=0; x<=ebmp->ebm_dim[X]; x++ )  {
			VSET( pt1, ebmp->ebm_dim[X], y, 2 );
			VSET( pt2, x, ebmp->ebm_dim[Y], 4 );
d1006 2
a1007 2
	for( yy=0; yy<=ebmp->ebm_dim[Y]; yy += 0.3 )  {
		for( xx=0; xx<=ebmp->ebm_dim[X]; xx += 0.3 )  {
d1015 4
a1018 4
	for( yy=0; yy<=ebmp->ebm_dim[Y]; yy += 0.3 )  {
		for( xx=0; xx<=ebmp->ebm_dim[X]; xx += 0.3 )  {
			VSET( pt1, ebmp->ebm_dim[X], yy, 2 );
			VSET( pt2, xx, ebmp->ebm_dim[Y], 4 );
d1039 2
a1040 2
	VSET( pt1, ebmp->ebm_dim[X], yy, 2 );
	VSET( pt2, xx, ebmp->ebm_dim[Y], 4 );
d1062 2
a1063 2
		for( yy=0; yy<=ebmp->ebm_dim[Y]; yy += 0.3 )  {
			for( xx=0; xx<=ebmp->ebm_dim[X]; xx += 0.3 )  {
d1071 1
a1071 1
	for( x=0; x<ebmp->ebm_dim[X]; x++ )  {
d1129 1
a1129 1
		 ebmp->ebm_dim[X]+BIT_XWIDEN, ebmp->ebm_dim[Y]+BIT_YWIDEN, (int)(ebmp->ebm_tallness+1.99) );
d1131 1
a1131 1
		 ebmp->ebm_dim[X]+BIT_XWIDEN, ebmp->ebm_dim[Y]+BIT_YWIDEN, (int)(ebmp->ebm_tallness+1.99) );
@


9.1
log
@Release_3.5
@
text
@a0 1

d21 1
a21 1
static char RCSebm[] = "@@(#)$Header: g_ebm.c,v 1.1 89/04/17 17:18:57 mike Exp $ (BRL)";
d25 1
d35 1
a35 1
	char		*ebm_file;
d39 1
a39 1
	vect_t		ebm_xnorm;	/* ideal +X normal in final orientation */
d42 4
d47 2
a48 1
#define BM_NULL		((struct ebm_specific *)0)
d50 12
d64 1
a64 1
struct ebm_specific	*ebm_readin();
d82 2
a83 2
 *  Normal addressing is used:  (0..W-1, 0..N-1),
 *  but the bitmap is stored with two cell of zeros all around,
d146 1
a146 1
		/* Not sure why this happens;  for now, just exchange them */
d193 1
d195 1
d199 1
a199 1
 *  Solve the 2-D intersection by stepping through the bit array.
a200 4
 *  To solve an intercept, where point[axis] == 0:
 *  Using P + k * D formulation of line, solve
 *  P[axis] + k * D[axis] = 0;
 *  k = -P[axis]/D[axis].
a201 1
 *
a202 7
struct seg_head {
	struct seg	*sh_head;
	struct seg	*sh_tail;
	struct soltab	*sh_stp;
	struct application *sh_ap;
};

d204 1
a204 1
ebm_dda( rp, ebmp, stp, ap )
a205 1
register struct ebm_specific *ebmp;
d209 16
a224 12
	fastf_t		maj_entry_k, min_entry_k;
	fastf_t		maj_exit_k, min_exit_k;
	struct fixpt	maj_pos_deltas[2], min_pos_deltas[2];
	struct fixpt	maj_exit_pos[2], min_exit_pos[2];
	struct fixpt	maj_entry_pos[2], min_entry_pos[2];
	fastf_t		maj_k_delta, min_k_delta;
	int		maj_entry_norm, min_entry_norm;
	int		majdir, mindir;
	int		minor_has_deltas;
	int		inside = 0;
	int		do_minor_backup;
	struct seg_head	head;
d226 1
a226 3
	head.sh_head = head.sh_tail = SEG_NULL;
	head.sh_stp = stp;
	head.sh_ap = ap;
d228 3
a230 10
	/* Determine major and minor axes */
	if( fabs(rp->r_dir[X]) > fabs(rp->r_dir[Y]) )  {
		majdir = X;
		mindir = Y;
		if( rp->r_dir[X] > 0 )
			maj_entry_norm = NORM_XNEG;	/* points outwards */
		else	maj_entry_norm = NORM_XPOS;
		if( rp->r_dir[Y] > 0 )
			min_entry_norm = NORM_YNEG;
		else	min_entry_norm = NORM_YPOS;
d232 2
a233 8
		majdir = Y;
		mindir = X;
		if( rp->r_dir[Y] > 0 )
			maj_entry_norm = NORM_YNEG;
		else	maj_entry_norm = NORM_YPOS;
		if( rp->r_dir[X] > 0 )
			min_entry_norm = NORM_XNEG;
		else	min_entry_norm = NORM_XPOS;
d235 2
a236 31

	/*  First, find the natural starting point on the trimmed ray.
	 *  Use it as the start point for both major and minor entry_pos
	 */
	maj_entry_k = rp->r_min;
	maj_k_delta = fabs(1.0/rp->r_dir[majdir]);
	FIXPT_FLOAT( maj_entry_pos[X], rp->r_pt[X] + maj_entry_k * rp->r_dir[X] );
	FIXPT_FLOAT( maj_entry_pos[Y], rp->r_pt[Y] + maj_entry_k * rp->r_dir[Y] );
	min_entry_pos[X] = maj_entry_pos[X];	/* struct copy */
	min_entry_pos[Y] = maj_entry_pos[Y];	/* struct copy */
	if(rt_g.debug&DEBUG_EBM) PR_FIX2("original maj_entry_pos", maj_entry_pos);

	/*
	 * The major entry point MUST be a major axis intercept,
	 * force maj_entry_pos[majdir] == integer.
	 */
	if( maj_entry_pos[majdir].f != 0 )  {
		do_minor_backup = 1;
		if( rp->r_dir[majdir] < 0 )  {
			maj_entry_pos[majdir].i++;		/* back up */
		} else {
			if( maj_entry_pos[majdir].i <= 0 )
				maj_entry_pos[majdir].i--;	/* back up */
			/* else, just truncation to int will do the trick */
		}
		maj_entry_pos[majdir].f = 0;			/* truncate to int */

		maj_entry_k = (maj_entry_pos[majdir].i - rp->r_pt[majdir]) / rp->r_dir[majdir];
		FIXPT_FLOAT( maj_entry_pos[mindir],
			rp->r_pt[mindir] + maj_entry_k * rp->r_dir[mindir] );
		if(rt_g.debug&DEBUG_EBM) PR_FIX2("actual maj_entry_pos", maj_entry_pos);
d238 2
a239 1
		do_minor_backup = 0;
d241 6
d248 12
a259 5
	maj_pos_deltas[majdir].i = rp->r_dir[majdir] < 0.0 ? -1 : 1;
	maj_pos_deltas[majdir].f = 0;
	FIXPT_FLOAT( maj_pos_deltas[mindir],
		rp->r_dir[mindir]/fabs(rp->r_dir[majdir]) );	/* should be <= 1 */
	if(rt_g.debug&DEBUG_EBM) PR_FIX2( "maj_pos_deltas", maj_pos_deltas );
d261 14
a274 22
	/*
	 *  Find the first minor axis intercept before the start position,
	 *  to "prime the pumps" in the minor direction.
	 */
	min_entry_k = rp->r_min;
	if( maj_pos_deltas[mindir].i != 0 ||
	    maj_pos_deltas[mindir].f != 0 )  {
	    	minor_has_deltas = 1;
		min_k_delta = fabs(1.0/rp->r_dir[mindir]);
		/*
		 *  The minor entry point MUST be on a minor axis intercept,
	    	 *  force min_entry_pos[mindir] == integer
	    	 */
	    	if( min_entry_pos[mindir].f != 0 || do_minor_backup)  {
			if( rp->r_dir[mindir] < 0 )  {
				min_entry_pos[mindir].i++;	/* back up */
			} else {
				if( min_entry_pos[mindir].i <= 0 )
					min_entry_pos[mindir].i--;	/* back up */
				/* else, just truncation to int will do the trick */
			}
			min_entry_pos[mindir].f = 0;		/* truncate to int */
d276 2
a277 5
			min_entry_k = (min_entry_pos[mindir].i - rp->r_pt[mindir]) / rp->r_dir[mindir];
			FIXPT_FLOAT( min_entry_pos[majdir],
				rp->r_pt[majdir] + min_entry_k * rp->r_dir[majdir] );
	    	}
		if(rt_g.debug&DEBUG_EBM) PR_FIX2( "min_entry_pos", min_entry_pos );
d279 20
a298 5
		min_pos_deltas[mindir].i = rp->r_dir[mindir] < 0.0 ? -1 : 1;
		min_pos_deltas[mindir].f = 0;
		FIXPT_FLOAT( min_pos_deltas[majdir],
			rp->r_dir[majdir]/fabs(rp->r_dir[mindir]) );	/* may be > 1 */
		if(rt_g.debug&DEBUG_EBM) PR_FIX2( "min_pos_deltas", min_pos_deltas );
d300 4
a303 3
		/* Take first minor step already, to have exit dist to check, below */
		FIXPT_ADD2( min_exit_pos[X], min_entry_pos[X], min_pos_deltas[X] );
		FIXPT_ADD2( min_exit_pos[Y], min_entry_pos[Y], min_pos_deltas[Y] );
d305 5
a309 2
	    	minor_has_deltas = 0;
		min_k_delta = 0;
d311 10
a320 4
	min_exit_k = min_entry_k + min_k_delta;
	if(rt_g.debug&DEBUG_EBM)  {
		rt_log("maj_k_delta=%g, min_k_delta=%g, major_axis=%s\n", maj_k_delta, min_k_delta, majdir==X ? "X" : "Y");
		rt_log("maj_entry_k = %g, min_entry_k = %g\n", maj_entry_k, min_entry_k );
d322 11
a332 19

	/* Take first major step */
	FIXPT_ADD2( maj_exit_pos[X], maj_entry_pos[X], maj_pos_deltas[X] );
	FIXPT_ADD2( maj_exit_pos[Y], maj_entry_pos[Y], maj_pos_deltas[Y] );
	maj_exit_k = maj_entry_k + maj_k_delta;

	/*  See if a silent minor step is needed to get past
	 *  the starting K for the major axis.
	 */
	if( minor_has_deltas )  {
		while( min_exit_k < maj_entry_k )  {
			if(rt_g.debug&DEBUG_EBM) rt_log("catch-up minor step\n");
			/* Advance minor exit to some future cell */
			min_entry_pos[X] = min_exit_pos[X];		/* struct copy */
			min_entry_pos[Y] = min_exit_pos[Y];		/* struct copy */
			FIXPT_ADD2( min_exit_pos[X], min_entry_pos[X], min_pos_deltas[X] );
			FIXPT_ADD2( min_exit_pos[Y], min_entry_pos[Y], min_pos_deltas[Y] );
			min_entry_k += min_k_delta;
			min_exit_k += min_k_delta;
d335 1
d337 3
a339 2
	while( inside >= 0 )  {
		if(rt_g.debug&DEBUG_EBM) rt_log("maj_exit_k = %g, min_exit_k = %g\n", maj_exit_k, min_exit_k );
d341 7
a347 101
		/*
		 *  First, do any minor direction exit step
		 *  which has become "due".
		 *  Minor direction steps usually happen once for
		 *  every several major direction steps (depending on slope).
		 */
		if( minor_has_deltas && min_exit_k < maj_exit_k )  {
		    	fastf_t	exit_k_diff;
			fastf_t	maj_dist;

			/*
			 * If either the entry or exit points (K values)
			 * are nearly equal, this is a shared
			 * major/minor vertex, don't bother doing
			 * a minor step partitioning in this cell,
			 * but DO push min_exit_pos along.
			 * All shared major+minor vertices should occur
			 * exactly on integer-valued grid coordinates;
			 * this is enforced.
			 */
#define VERT_TOL	(1.0e-10)
			exit_k_diff = maj_exit_k - min_exit_k;
			if(rt_g.debug&DEBUG_EBM)  {
				PR_FIX2("maj_entry_pos", maj_entry_pos);
				PR_FIX2("min_entry_pos", min_entry_pos);
				PR_FIX2("maj_exit_pos ", maj_exit_pos);
				PR_FIX2("min_exit_pos ", min_exit_pos);
				rt_log("exit_k_diff = %e\n", exit_k_diff);
			}
			if( exit_k_diff > -VERT_TOL &&
				   exit_k_diff <  VERT_TOL )  {
				/*  Exit Vertex overlap -
				 *  Do it as a regular major exit.
				 *  Force positions to exactly integer
				 *  values -- this is mandatory for
				 *  correct results.
				 */
if(rt_g.debug&DEBUG_EBM) rt_log("MINOR STEP SKIPPED -- exit vertex overlap\n");
				  
				FIXPT_ROUND( maj_exit_pos[X] );
				FIXPT_ROUND( maj_exit_pos[Y] );
				FIXPT_ROUND( min_exit_pos[X] );
				FIXPT_ROUND( min_exit_pos[Y] );
				inside = ebm_do_exit( maj_entry_k, maj_exit_k,
					maj_entry_pos, maj_exit_pos,
					rp, inside, ebmp,
					maj_entry_norm, &head );
			} else {
				if(rt_g.debug&DEBUG_EBM) rt_log("MINOR STEP\n");
				/*
			    	 *  Take a step in the minor direction.
				 *  Ensure that this step is not going
				 *  backwards along the major axis,
			    	 *  due to slight differences in the slopes
			    	 */
			    	maj_dist =
				    (FLOAT_FIXPT(min_exit_pos[majdir]) -
			    	    FLOAT_FIXPT(maj_entry_pos[majdir]) ) *
				    ( rp->r_dir[majdir] < 0.0 ? -1 : 1 );
				if(rt_g.debug&DEBUG_EBM) rt_log("maj_dist = %g\n", maj_dist);
#define DIFF_TOL	7.0/FIXPT_SCALE
			    	if( maj_dist < 0 )  {
			    		if( maj_dist < -DIFF_TOL )  {
rt_log("??? major element heading wrong way, maj_dist=%g (%d) ???\n", maj_dist, ((int)(maj_dist*FIXPT_SCALE)) );
			    		}
			    		/* Fix it up */
			    	    	min_exit_pos[majdir] = maj_entry_pos[majdir];	/* struct copy */
			    	}
				inside = ebm_do_exit( maj_entry_k, min_exit_k,
					maj_entry_pos, min_exit_pos,
					rp, inside, ebmp,
					maj_entry_norm, &head );
			    	if( inside < 0 )  break;
				inside = ebm_do_exit( min_exit_k, maj_exit_k,
					min_exit_pos, maj_exit_pos,
					rp, inside, ebmp,
					min_entry_norm, &head );
			}

			/* Advance minor exit to some future cell */
			min_entry_pos[X] = min_exit_pos[X];		/* struct copy */
			min_entry_pos[Y] = min_exit_pos[Y];		/* struct copy */
			FIXPT_ADD2( min_exit_pos[X], min_entry_pos[X], min_pos_deltas[X] );
			FIXPT_ADD2( min_exit_pos[Y], min_entry_pos[Y], min_pos_deltas[Y] );
			min_entry_k += min_k_delta;
			min_exit_k += min_k_delta;
		} else {
			/* Take regular major direction step */
			inside = ebm_do_exit( maj_entry_k, maj_exit_k,
				maj_entry_pos, maj_exit_pos,
				rp, inside, ebmp,
				maj_entry_norm, &head );
		}

		/* Loop bottom -- press on to next major direction cell */
		maj_entry_pos[X] = maj_exit_pos[X];		/* struct copy */
		maj_entry_pos[Y] = maj_exit_pos[Y];		/* struct copy */
		FIXPT_ADD2( maj_exit_pos[X], maj_entry_pos[X], maj_pos_deltas[X] );
		FIXPT_ADD2( maj_exit_pos[Y], maj_entry_pos[Y], maj_pos_deltas[Y] );
		maj_entry_k += maj_k_delta;
		maj_exit_k += maj_k_delta;
d349 1
a349 2
	return(head.sh_head);
}
d351 3
a353 16
/*
 *			E B M _ D O _ E X I T
 */
int
ebm_do_exit( entry_k, exit_k, entry_pos, exit_pos, rp, inside, ebmp, entry_norm, headp )
double		entry_k, exit_k;
struct fixpt	*entry_pos, *exit_pos;
struct xray	*rp;
int		inside;
register struct ebm_specific *ebmp;
int		entry_norm;
struct seg_head	*headp;
{
	int	test[2];
	int	val;
	struct seg *segp = SEG_NULL;
d355 4
a358 4
	if(rt_g.debug&DEBUG_EBM)  {
		rt_log("ebm_do_exit(%g,%g) inside=%d\n", entry_k, exit_k, inside );
		PR_FIX2( " entry", entry_pos );
		PR_FIX2( "  exit", exit_pos );
d360 5
d366 1
a366 13
	/*  Determine proper cell index.
	 *  If the position is exactly a positive integer (no fractional part)
	 *  then apply the subscript correction.
	 *  If direction is negative, bitmap index needs correction,
	 *  because intercept point will be on top or right edge of cell,
	 *  resulting in round-up to next largest integer.
	 */
	if( entry_pos[X].f != 0 || entry_pos[X].i < 0 || rp->r_dir[X] >= 0 )
		test[X] = entry_pos[X].i;
	else	test[X] = entry_pos[X].i - 1;
	if( entry_pos[Y].f != 0 || entry_pos[Y].i < 0 || rp->r_dir[Y] >= 0 )
		test[Y] = entry_pos[Y].i;
	else	test[Y] = entry_pos[Y].i - 1;
d368 3
a370 9
	/*
	 *  Sitting on first ring of zero cells is OK,
	 *  but the outer ring of zeros is time to quit.
	 *  The inner ring should prevent it from ever happening.
	 */
	if( test[X] < 0 ||
	    test[X] >= ebmp->ebm_dim[X] ||
	    test[Y] < 0 ||
	    test[Y] >= ebmp->ebm_dim[Y] )  {
d372 2
a373 7
		if( test[X] < -2 ||
		    test[X] > ebmp->ebm_dim[X]+1 ||
		    test[Y] < -2 ||
		    test[Y] > ebmp->ebm_dim[Y]+1 )  {
		    	if( !inside )
		    		return( -1 );		/* OK, but time to stop */
		}
d375 1
a375 12
		/*
		 *  DDA ran off the edge of the bitmap,
		 *  perhaps while still "inside" a solid.
		 *  Just print up an empty (zerp valued) cell,
		 *  and return the -1 next time through.
		 *  This accomodates the initial intercepts shifting
		 *  the ray start positions outside the normal bounds.
		 */
		val = 0;
	} else {
		val = BIT( test[X], test[Y] );
	}
d377 7
a383 3
	/* Check cell value */
	if(rt_g.debug&DEBUG_EBM) rt_log(" .....TEST bit (%d, %d) val=%d\n",
		test[X], test[Y], val );
d385 1
a385 2
	if( val )  {
		/* New cell is solid */
d387 4
a390 2
			/* Handle the transition from vacuum to solid */
			inside = 1;
d392 3
a394 4
			GET_SEG(segp, headp->sh_ap->a_resource);
			segp->seg_stp = headp->sh_stp;
			segp->seg_in.hit_dist = entry_k;
			segp->seg_in.hit_private = (char *)entry_norm;
d396 24
a419 6
			if( headp->sh_head == SEG_NULL ||
			    headp->sh_tail == SEG_NULL )  {
				/* Install as beginning of list */
				headp->sh_tail = segp;
				segp->seg_next = headp->sh_head;
				headp->sh_head = segp;
d421 1
a421 3
				/* Append to list */
				headp->sh_tail->seg_next = segp;
				headp->sh_tail = segp;
d423 7
d431 15
a445 1
			if(rt_g.debug&DEBUG_EBM) rt_log("START k=%g, n=%d\n", entry_k, entry_norm);
a446 5
	} else {
		/* New cell is empty */
		if( inside )  {
			/* Handle transition from solid to vacuum */
			inside = 0;
d448 8
a455 3
			headp->sh_tail->seg_out.hit_dist = entry_k;
			headp->sh_tail->seg_out.hit_private = (char *)(-entry_norm);
			if(rt_g.debug&DEBUG_EBM) rt_log("END k=%g, n=%d\n", entry_k, -entry_norm);
d458 20
a477 1
	return(inside);
d481 1
a481 1
 *			E B M _ R E A D I N
d484 1
a484 1
ebm_readin( rp )
d491 2
a493 4
	/* tokenize the string in the solid record ?? */
	/* Perhaps just find the first WSp char */
	/* parse each assignment w/library routine */

a494 4
	ebmp->ebm_file = "bm.bw";
	ebmp->ebm_dim[X] = 6;
	ebmp->ebm_dim[Y] = 6;
	ebmp->ebm_tallness = 6.0;
d496 19
d517 1
a517 1
	ebmp->ebm_map = (unsigned char *)rt_malloc( nbytes, "ebm_readin bitmap" );
d525 2
a526 1
		return( BM_NULL );
d528 2
d537 32
d588 2
d591 1
a591 1
	if( (ebmp = ebm_readin( rp )) == BM_NULL )
d594 2
a595 1
	/* build Xform matrix to ideal space */
d607 5
a611 3
	/* This needs to account for the rotations */
	VSETALL( stp->st_min, 0 );
	VSET( stp->st_max, ebmp->ebm_dim[X], ebmp->ebm_dim[Y], ebmp->ebm_tallness );
d613 8
d622 1
a622 1
	VSUB2SCALE( radvec, stp->st_min, stp->st_max, 0.5 );
d638 6
d667 1
d669 3
a671 1
	segp = ebm_dda( rp, ebmp, stp, ap );
d673 7
d681 12
a692 1
	segp = rt_seg_planeclip( segp, norm, 0.0, ebmp->ebm_tallness, rp, ap );
d758 3
d778 2
d808 1
a808 1
register matp_t	matp;
d817 1
a817 1
	if( (ebmp = ebm_readin( rp )) == BM_NULL )
d826 1
a826 1
				if( BIT( x-1, y ) != BIT( x, y ) )
d828 2
a829 1
				ebm_plate( x, base, x, y, ebmp->ebm_tallness, vhead );
d832 1
a832 1
				if( BIT( x-1, y ) == BIT( x, y ) )
d845 1
a845 1
				if( BIT( x, y-1 ) != BIT( x, y ) )
d847 2
a848 1
				ebm_plate( base, y, x, y, ebmp->ebm_tallness, vhead );
d851 1
a851 1
				if( BIT( x, y-1 ) == BIT( x, y ) )
d863 6
a868 3
ebm_plate( x1, y1, x2, y2, t, vhead )
double	t;
struct vlhead	*vhead;
d870 2
a871 1
	point_t	s, p;
d874 2
a875 1
	ADD_VL( vhead, s, 0 );
d878 2
a879 1
	ADD_VL( vhead, p, 1 );
d882 2
a883 1
	ADD_VL( vhead, p, 1 );
d886 2
a887 1
	ADD_VL( vhead, p, 1 );
d889 1
a889 1
	ADD_VL( vhead, s, 1 );
d912 3
d916 1
a916 1
	if( argc > 1 )
d918 2
d928 3
a930 1
	if( ebm_prep( &Tsolid, 0, 0 ) != 0 )  {
d934 1
d937 1
a937 1
	outline();
d939 14
d954 16
d979 9
d998 7
d1055 5
a1059 2
/**	for( x=0; x<ebmp->ebm_dim[X]; x++ )  { **/
	VSET( pt1, 0.75, 1.1, -10 );
d1069 1
a1069 1
#if 1
a1084 2
	vect_t		minpt, maxpt;
	vect_t		inv_dir;
a1099 28
	/*
	 *  Clip ray to bounding RPP of bitmap volume.
	 *  In real version, this would be done by rt_shootray().
	 */
	VSET( minpt, 0, 0, -INFINITY );
	VSET( maxpt, ebmp->ebm_dim[X], ebmp->ebm_dim[Y], INFINITY );
	/* Compute the inverse of the direction cosines */
	if( !NEAR_ZERO( ray.r_dir[X], SQRT_SMALL_FASTF ) )  {
		inv_dir[X]=1.0/ray.r_dir[X];
	} else {
		inv_dir[X] = INFINITY;
		ray.r_dir[X] = 0.0;
	}
	if( !NEAR_ZERO( ray.r_dir[Y], SQRT_SMALL_FASTF ) )  {
		inv_dir[Y]=1.0/ray.r_dir[Y];
	} else {
		inv_dir[Y] = INFINITY;
		ray.r_dir[Y] = 0.0;
	}
	if( !NEAR_ZERO( ray.r_dir[Z], SQRT_SMALL_FASTF ) )  {
		inv_dir[Z]=1.0/ray.r_dir[Z];
	} else {
		inv_dir[Z] = INFINITY;
		ray.r_dir[Z] = 0.0;
	}
	if( rt_in_rpp( &ray, inv_dir, minpt, maxpt ) == 0 )
		return;

d1117 3
a1119 1
outline()
d1132 2
a1133 2
	/* call bit_plot(), then just draw the vlist */
	ebm_plot( 0, 0, &vhead, 0 );
a1151 3
#if 0
printf("draw2seg (%g %g) in=%d\n", k1, k2, inside);
#endif
@


1.1
log
@Initial revision
@
text
@d22 1
a22 1
static char RCSebm[] = "@@(#)$Header: /cad/d/mike/cad/librt/RCS/ebm.c,v 1.3 88/11/28 12:22:13 mike Exp $ (BRL)";
@
