head	11.10;
access;
symbols
	ansi-20040405-merged:11.6.2.2
	postmerge-20040405-ansi:11.8
	premerge-20040404-ansi:11.7
	postmerge-autoconf:11.7
	autoconf-freeze:11.6.10.1
	premerge-autoconf:11.7
	ansi-20040316-freeze:11.6.2.1
	postmerge-20040315-windows:11.7
	premerge-20040315-windows:11.7
	windows-20040315-freeze:11.6.4.1
	autoconf-20031203:11.6
	autoconf-20031202:11.6
	autoconf-branch:11.6.0.10
	phong-branch:11.6.0.8
	photonmap-branch:11.6.0.6
	rel-6-1-DP:11.6
	windows-branch:11.6.0.4
	rel-6-0-2:11.4
	ansi-branch:11.6.0.2
	rel-6-0-1-branch:11.4.0.4
	hartley-6-0-post:11.5
	hartley-6-0-pre:11.4
	rel-6-0-1:11.4
	rel-6-0:11.4
	rel-5-4:11.4
	offsite-5-3-pre:11.4
	rel-5-3:11.4
	rel-5-2:11.4
	rel-5-1-branch:11.4.0.2
	rel-5-1:11.4
	rel-5-0:11.4
	rel-5-0-beta:11.4
	rel-4-5:11.4
	ctj-4-5-post:11.3
	ctj-4-5-pre:11.3
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.10
date	2004.05.21.18.07.34;	author morrison;	state dead;
branches;
next	11.9;

11.9
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.8;

11.8
date	2004.04.05.08.48.58;	author morrison;	state Exp;
branches;
next	11.7;

11.7
date	2004.02.02.17.39.28;	author morrison;	state Exp;
branches;
next	11.6;

11.6
date	2002.08.20.17.08.07;	author jra;	state Exp;
branches
	11.6.2.1
	11.6.4.1
	11.6.10.1;
next	11.5;

11.5
date	2002.08.15.20.55.19;	author hartley;	state Exp;
branches;
next	11.4;

11.4
date	97.09.18.20.32.45;	author jra;	state Exp;
branches;
next	11.3;

11.3
date	95.12.01.02.49.33;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	95.11.27.17.55.05;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.53.49;	author mike;	state Rel4_4;
branches
	11.1.1.1;
next	10.7;

10.7
date	94.12.27.15.20.51;	author stay;	state Exp;
branches;
next	10.6;

10.6
date	94.12.27.14.59.36;	author stay;	state Exp;
branches;
next	10.5;

10.5
date	94.08.11.01.13.58;	author gdurf;	state Exp;
branches;
next	10.4;

10.4
date	92.05.29.01.20.04;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	92.05.29.00.52.24;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	92.05.28.22.12.09;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.39.09;	author mike;	state Rel4_0;
branches;
next	1.3;

1.3
date	91.08.30.03.52.39;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	91.06.14.09.42.16;	author stay;	state Exp;
branches;
next	1.1;

1.1
date	91.05.18.02.35.35;	author stay;	state Exp;
branches;
next	;

11.1.1.1
date	98.01.29.06.43.38;	author mike;	state Rel4_5;
branches;
next	;

11.6.2.1
date	2002.09.19.18.01.44;	author morrison;	state Exp;
branches;
next	11.6.2.2;

11.6.2.2
date	2004.03.17.21.18.56;	author morrison;	state Exp;
branches;
next	;

11.6.4.1
date	2004.03.11.23.43.44;	author morrison;	state Exp;
branches;
next	;

11.6.10.1
date	2004.02.12.18.37.46;	author erikg;	state Exp;
branches;
next	;


desc
@Normal calculation
@


11.10
log
@moved to src/
@
text
@/*		N U R B _ N O R M . C
 *
 *  Function-
 *  	Calulate and return the normal of a surface given the
 *	U,V parametric values.
 *
 *  Author -
 *	Paul R. Stay
 *
 *  Source -
 *     SECAD/VLD Computing Consortium, Bldg 394
 *     The U.S. Army Ballistic Research Laboratory
 *     Aberdeen Proving Ground, Maryland 21005
 *
 * Copyright Notice -
 *     This software is Copyright (C) 1991-2004 by the United States Army.
 *     All rights reserved.
 */

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "nurb.h"

/* If the order of the surface is linear either direction
 * than approximate it.
 */

void
rt_nurb_s_norm(struct face_g_snurb *srf, fastf_t u, fastf_t v, fastf_t *norm)
{
	struct face_g_snurb *usrf, *vsrf;
	point_t uvec, vvec;
	fastf_t p;
	fastf_t se[4], ue[4], ve[4];
	int i;

	/* Case (linear, lienar) find the normal from the polygon */
	if( srf->order[0] == 2 && srf->order[1] == 2 )
	{
		/* Find the correct span to get the normal */
		rt_nurb_s_eval( srf, u, v, se);
		
		p = 0.0;
		for( i = 0; i < srf->u.k_size -1; i++)
		{
			if ( srf->u.knots[i] <= u 
				&& u < srf->u.knots[i+1] )
			{
				p = srf->u.knots[i];

				if (u == p)
					p = srf->u.knots[i+1];
				if ( u == p && i > 1)
					p = srf->u.knots[i-1];
			}
		}

		rt_nurb_s_eval( srf, p, v, ue);

		p = 0.0;
		for( i = 0; i < srf->v.k_size -1; i++)
		{
			if ( srf->v.knots[i] < v 
				&& srf->v.knots[i+1] )
			{
				p = srf->v.knots[i];
				if (v == p)
					p = srf->v.knots[i+1];
				if ( v == p && i > 1)
					p = srf->v.knots[i-1];
			}
		}

		rt_nurb_s_eval( srf, u, p, ve);		
	
		if( RT_NURB_IS_PT_RATIONAL(srf->pt_type))
		{
			ue[0] = ue[0] / ue[3];
			ue[1] = ue[1] / ue[3];
			ue[2] = ue[2] / ue[3];
			ue[3] = ue[3] / ue[3];

			ve[0] = ve[0] / ve[3];
			ve[1] = ve[1] / ve[3];
			ve[2] = ve[2] / ve[3];
			ve[3] = ve[3] / ve[3];

		}

		VSUB2(uvec, se, ue);
		VSUB2(vvec, se, ve);

		VCROSS( norm, uvec, vvec);
		VUNITIZE( norm );

		return;		

	}
	/* Case (linear, > linear) Use the linear direction to approximate
	 * the tangent to the surface 
	 */
	if( srf->order[0] == 2 && srf->order[1] > 2 )
	{
		rt_nurb_s_eval( srf, u, v, se);
		
		p = 0.0;
		for( i = 0; i < srf->u.k_size -1; i++)
		{
			if ( srf->u.knots[i] <= u 
				&& u < srf->u.knots[i+1] )
			{
				p = srf->u.knots[i];

				if (u == p)
					p = srf->u.knots[i+1];
				if ( u == p && i > 1)
					p = srf->u.knots[i-1];
			}
		}

		rt_nurb_s_eval( srf, p, v, ue);
		
		vsrf = (struct face_g_snurb *) rt_nurb_s_diff(srf, RT_NURB_SPLIT_COL);

		rt_nurb_s_eval(vsrf, u, v, ve);

		if( RT_NURB_IS_PT_RATIONAL(srf->pt_type) )
		{
			fastf_t w, inv_w;
			
			w = se[3];
			inv_w = 1.0 / w;

			ve[0] = (inv_w * ve[0]) -
				ve[3] / (w * w) * se[0];
			ve[1] = (inv_w * ve[1]) -
				ve[3] / (w * w) * se[1];
			ve[2] = (inv_w * ve[2]) -
				ve[3] / (w * w) * se[2];

			ue[0] = ue[0] / ue[3];
			ue[1] = ue[1] / ue[3];
			ue[2] = ue[2] / ue[3];
			ue[3] = ue[3] / ue[3];

			se[0] = se[0] / se[3];
			se[1] = se[1] / se[3];
			se[2] = se[2] / se[3];
			se[3] = se[3] / se[3];
		}
		
		VSUB2(uvec, se, ue);
		
		VCROSS(norm, uvec, ve);
		VUNITIZE(norm);

		rt_nurb_free_snurb(vsrf, (struct resource *)NULL);
		return;
	}
	if( srf->order[1] == 2 && srf->order[0] > 2 )
	{
		rt_nurb_s_eval( srf, u, v, se);
		
		p = 0.0;
		for( i = 0; i < srf->v.k_size -1; i++)
		{
			if ( srf->v.knots[i] <= v 
				&& v < srf->v.knots[i+1] )
			{
				p = srf->v.knots[i];

				if (v == p)
					p = srf->u.knots[i+1];
				if ( v == p && i > 1)
					p = srf->v.knots[i-1];
			}
		}

		rt_nurb_s_eval( srf, u, p, ve);

		usrf = (struct face_g_snurb *) rt_nurb_s_diff(srf, RT_NURB_SPLIT_ROW);
		
		rt_nurb_s_eval(usrf, u, v, ue);

		if( RT_NURB_IS_PT_RATIONAL(srf->pt_type) )
		{
			fastf_t w, inv_w;
			
			w = se[3];
			inv_w = 1.0 / w;

			ue[0] = (inv_w * ue[0]) -
				ue[3] / (w * w) * se[0];
			ue[1] = (inv_w * ue[1]) -
				ue[3] / (w * w) * se[1];
			ue[2] = (inv_w * ue[2]) -
				ue[3] / (w * w) * se[2];

			ve[0] = ve[0] / ve[3];
			ve[1] = ve[1] / ve[3];
			ve[2] = ve[2] / ve[3];
			ve[3] = ve[3] / ve[3];

			se[0] = se[0] / se[3];
			se[1] = se[1] / se[3];
			se[2] = se[2] / se[3];
			se[3] = se[3] / se[3];
		}

		VSUB2(vvec, se, ve);
		
		VCROSS(norm, ue, vvec);
		VUNITIZE(norm);		

		rt_nurb_free_snurb(usrf, (struct resource *)NULL);
		return;
	}
	
	/* Case Non Rational (order > 2, order > 2) */
	if( !RT_NURB_IS_PT_RATIONAL(srf->pt_type))
	{

		usrf = (struct face_g_snurb *) rt_nurb_s_diff( srf, RT_NURB_SPLIT_ROW);
		vsrf = (struct face_g_snurb *) rt_nurb_s_diff( srf, RT_NURB_SPLIT_COL);

		rt_nurb_s_eval(usrf, u,v, ue);
		rt_nurb_s_eval(vsrf, u,v, ve);
		
		VCROSS( norm, ue, ve);
		VUNITIZE( norm);

		rt_nurb_free_snurb(usrf, (struct resource *)NULL);
		rt_nurb_free_snurb(vsrf, (struct resource *)NULL);
		
		return;
	}

	/* Case Rational (order > 2, order > 2) */
	if( RT_NURB_IS_PT_RATIONAL(srf->pt_type))
	{
		fastf_t w, inv_w;
		vect_t unorm, vnorm;
		int i;

		rt_nurb_s_eval(srf, u, v, se);

		usrf = (struct face_g_snurb *) rt_nurb_s_diff( srf, RT_NURB_SPLIT_ROW);
		vsrf = (struct face_g_snurb *) rt_nurb_s_diff( srf, RT_NURB_SPLIT_COL);

		rt_nurb_s_eval(usrf, u,v, ue);

		rt_nurb_s_eval(vsrf, u,v, ve);
		
		w = se[3];
		inv_w = 1.0 / w;

		for(i = 0; i < 3; i++)
		{
			unorm[i] = (inv_w * ue[i]) -
				ue[3] / (w*w) * se[i];
			vnorm[i] = (inv_w * ve[i]) -
				ve[3] / (w*w) * se[i];
		}

		VCROSS( norm, unorm, vnorm);
		VUNITIZE( norm);

		rt_nurb_free_snurb(usrf, (struct resource *)NULL);
		rt_nurb_free_snurb(vsrf, (struct resource *)NULL);
		
		return;
	}
	return;
}
@


11.9
log
@change conf.h to a wrapped config.h
@
text
@@


11.8
log
@merge of ansi-6-0-branch into HEAD
@
text
@d20 5
a24 1
#include "conf.h"
@


11.7
log
@update copyright to include span through 2003
@
text
@d33 1
a33 4
rt_nurb_s_norm(srf, u, v, norm)
struct face_g_snurb * srf;
fastf_t u, v;
fastf_t * norm;
@


11.6
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d16 1
a16 1
 *     This software is Copyright (C) 1991 by the United States Army.
@


11.6.4.1
log
@sync to HEAD...
@
text
@d16 1
a16 1
 *     This software is Copyright (C) 1991-2004 by the United States Army.
@


11.6.10.1
log
@merge from HEAD
@
text
@d16 1
a16 1
 *     This software is Copyright (C) 1991-2004 by the United States Army.
@


11.6.2.1
log
@Initial ANSIfication
@
text
@d33 4
a36 1
rt_nurb_s_norm(struct face_g_snurb *srf, fastf_t u, fastf_t v, fastf_t *norm)
@


11.6.2.2
log
@sync branch with HEAD
@
text
@d16 1
a16 1
 *     This software is Copyright (C) 1991-2004 by the United States Army.
@


11.5
log
@Converted from K&R to ANSI C - RFH
@
text
@d33 4
a36 1
rt_nurb_s_norm(struct face_g_snurb *srf, fastf_t u, fastf_t v, fastf_t *norm)
@


11.4
log
@Mods for use of pmalloc in TNURB raytracing.
@
text
@d33 1
a33 4
rt_nurb_s_norm(srf, u, v, norm)
struct face_g_snurb * srf;
fastf_t u, v;
fastf_t * norm;
@


11.3
log
@LIBNURB data structures have been fully merged withNMG data structures.
@
text
@d164 1
a164 1
		rt_nurb_free_snurb(vsrf);
d222 1
a222 1
		rt_nurb_free_snurb(usrf);
d239 2
a240 2
		rt_nurb_free_snurb(usrf);
		rt_nurb_free_snurb(vsrf);
d275 2
a276 2
		rt_nurb_free_snurb(usrf);
		rt_nurb_free_snurb(vsrf);
@


11.2
log
@Fixed minro typos in rt_nurb_s_norm().
@
text
@d34 1
a34 1
struct snurb * srf;
d38 1
a38 1
	struct snurb *usrf, *vsrf;
d51 1
a51 1
		for( i = 0; i < srf->u_knots.k_size -1; i++)
d53 2
a54 2
			if ( srf->u_knots.knots[i] <= u 
				&& u < srf->u_knots.knots[i+1] )
d56 1
a56 1
				p = srf->u_knots.knots[i];
d59 1
a59 1
					p = srf->u_knots.knots[i+1];
d61 1
a61 1
					p = srf->u_knots.knots[i-1];
d68 1
a68 1
		for( i = 0; i < srf->v_knots.k_size -1; i++)
d70 2
a71 2
			if ( srf->v_knots.knots[i] < v 
				&& srf->v_knots.knots[i+1] )
d73 1
a73 1
				p = srf->v_knots.knots[i];
d75 1
a75 1
					p = srf->v_knots.knots[i+1];
d77 1
a77 1
					p = srf->v_knots.knots[i-1];
d114 1
a114 1
		for( i = 0; i < srf->u_knots.k_size -1; i++)
d116 2
a117 2
			if ( srf->u_knots.knots[i] <= u 
				&& u < srf->u_knots.knots[i+1] )
d119 1
a119 1
				p = srf->u_knots.knots[i];
d122 1
a122 1
					p = srf->u_knots.knots[i+1];
d124 1
a124 1
					p = srf->u_knots.knots[i-1];
d130 1
a130 1
		vsrf = (struct snurb *) rt_nurb_s_diff(srf, RT_NURB_SPLIT_COL);
d172 1
a172 1
		for( i = 0; i < srf->v_knots.k_size -1; i++)
d174 2
a175 2
			if ( srf->v_knots.knots[i] <= v 
				&& v < srf->v_knots.knots[i+1] )
d177 1
a177 1
				p = srf->v_knots.knots[i];
d180 1
a180 1
					p = srf->u_knots.knots[i+1];
d182 1
a182 1
					p = srf->v_knots.knots[i-1];
d188 1
a188 1
		usrf = (struct snurb *) rt_nurb_s_diff(srf, RT_NURB_SPLIT_ROW);
d230 2
a231 2
		usrf = (struct snurb *) rt_nurb_s_diff( srf, RT_NURB_SPLIT_ROW);
		vsrf = (struct snurb *) rt_nurb_s_diff( srf, RT_NURB_SPLIT_COL);
d254 2
a255 2
		usrf = (struct snurb *) rt_nurb_s_diff( srf, RT_NURB_SPLIT_ROW);
		vsrf = (struct snurb *) rt_nurb_s_diff( srf, RT_NURB_SPLIT_COL);
@


11.1
log
@Release_4.4
@
text
@d70 1
a70 1
			if ( srf->v_knots.knots[i] < u 
d186 1
a186 1
		rt_nurb_s_eval( srf, p, v, ve);
@


11.1.1.1
log
@Release_4.5
@
text
@d34 1
a34 1
struct face_g_snurb * srf;
d38 1
a38 1
	struct face_g_snurb *usrf, *vsrf;
d51 1
a51 1
		for( i = 0; i < srf->u.k_size -1; i++)
d53 2
a54 2
			if ( srf->u.knots[i] <= u 
				&& u < srf->u.knots[i+1] )
d56 1
a56 1
				p = srf->u.knots[i];
d59 1
a59 1
					p = srf->u.knots[i+1];
d61 1
a61 1
					p = srf->u.knots[i-1];
d68 1
a68 1
		for( i = 0; i < srf->v.k_size -1; i++)
d70 2
a71 2
			if ( srf->v.knots[i] < v 
				&& srf->v.knots[i+1] )
d73 1
a73 1
				p = srf->v.knots[i];
d75 1
a75 1
					p = srf->v.knots[i+1];
d77 1
a77 1
					p = srf->v.knots[i-1];
d114 1
a114 1
		for( i = 0; i < srf->u.k_size -1; i++)
d116 2
a117 2
			if ( srf->u.knots[i] <= u 
				&& u < srf->u.knots[i+1] )
d119 1
a119 1
				p = srf->u.knots[i];
d122 1
a122 1
					p = srf->u.knots[i+1];
d124 1
a124 1
					p = srf->u.knots[i-1];
d130 1
a130 1
		vsrf = (struct face_g_snurb *) rt_nurb_s_diff(srf, RT_NURB_SPLIT_COL);
d164 1
a164 1
		rt_nurb_free_snurb(vsrf, (struct resource *)NULL);
d172 1
a172 1
		for( i = 0; i < srf->v.k_size -1; i++)
d174 2
a175 2
			if ( srf->v.knots[i] <= v 
				&& v < srf->v.knots[i+1] )
d177 1
a177 1
				p = srf->v.knots[i];
d180 1
a180 1
					p = srf->u.knots[i+1];
d182 1
a182 1
					p = srf->v.knots[i-1];
d186 1
a186 1
		rt_nurb_s_eval( srf, u, p, ve);
d188 1
a188 1
		usrf = (struct face_g_snurb *) rt_nurb_s_diff(srf, RT_NURB_SPLIT_ROW);
d222 1
a222 1
		rt_nurb_free_snurb(usrf, (struct resource *)NULL);
d230 2
a231 2
		usrf = (struct face_g_snurb *) rt_nurb_s_diff( srf, RT_NURB_SPLIT_ROW);
		vsrf = (struct face_g_snurb *) rt_nurb_s_diff( srf, RT_NURB_SPLIT_COL);
d239 2
a240 2
		rt_nurb_free_snurb(usrf, (struct resource *)NULL);
		rt_nurb_free_snurb(vsrf, (struct resource *)NULL);
d254 2
a255 2
		usrf = (struct face_g_snurb *) rt_nurb_s_diff( srf, RT_NURB_SPLIT_ROW);
		vsrf = (struct face_g_snurb *) rt_nurb_s_diff( srf, RT_NURB_SPLIT_COL);
d275 2
a276 2
		rt_nurb_free_snurb(usrf, (struct resource *)NULL);
		rt_nurb_free_snurb(vsrf, (struct resource *)NULL);
@


10.7
log
@made nurb_norm more efficient
@
text
@@


10.6
log
@fixed calls to nurb_evaluation routines.
@
text
@d32 2
a33 2
fastf_t *
rt_nurb_s_norm(srf, u, v)
d36 1
a39 1
	fastf_t * norm = (fastf_t *)NULL;
a99 2
		norm = (fastf_t *) rt_malloc( 3 * sizeof( fastf_t ),
				"normal");
d103 1
a103 1
		return norm;		
a112 1
		norm = (fastf_t *) rt_malloc( 3 * sizeof(fastf_t),"normal");
d165 1
a165 1
		return norm;
a170 1
		norm = (fastf_t *) rt_malloc( 3 * sizeof(fastf_t),"normal");
d223 1
a223 1
		return norm;
a229 3
		norm = (fastf_t *) rt_malloc( sizeof( fastf_t) * 3, 
			"rt_nurb_norm: fastf_t for norm");

d242 1
a242 1
		return norm;
a251 3
		norm = (fastf_t *) rt_malloc( sizeof( fastf_t) * 3, 
			"rt_nurb_norm: fastf_t for norm");

d278 1
a278 1
		return norm;
d280 1
a280 2
	/* This will be a null pointer, is this an error? */
	return norm;
@


10.5
log
@Added includes
@
text
@a37 1
	fastf_t * se, * ue, *ve;
d41 1
d48 1
a48 1
		se = (fastf_t *) rt_nurb_s_eval( srf, u, v);
d65 1
a65 1
		ue = (fastf_t *)rt_nurb_s_eval( srf, p, v);
d81 1
a81 1
		ve = (fastf_t *) rt_nurb_s_eval( srf, u, p);		
a104 4
		rt_free( (char *) se, "rt_nurb_norm: se");
		rt_free( (char *) ue, "rt_nurb_norm: ue");
		rt_free( (char *) ve, "rt_nurb_norm: ve");

d113 1
a113 1
		se = (fastf_t *)rt_nurb_s_eval( srf, u, v);
d131 1
a131 1
		ue = (fastf_t *) rt_nurb_s_eval( srf, p, v);
d135 1
a135 1
		ve = (fastf_t *) rt_nurb_s_eval(vsrf, u, v);
a166 3
		rt_free((char *) se, "se");
		rt_free((char *) ue, "ue");
		rt_free((char *) ve, "ve");
d172 1
a172 1
		se = (fastf_t *) rt_nurb_s_eval( srf, u, v);
d190 1
a190 1
		ve = (fastf_t *) rt_nurb_s_eval( srf, p, v);
d193 2
a194 1
		ue = (fastf_t *) rt_nurb_s_eval(usrf, u, v);
a225 3
		rt_free((char *) se, "se");
		rt_free((char *) ve, "ve");
		rt_free((char *) ue, "ue");
d240 2
a241 2
		ue = (fastf_t *) rt_nurb_s_eval(usrf, u,v);
		ve = (fastf_t *) rt_nurb_s_eval(vsrf, u,v);
a245 2
		rt_free( (char *) ue, "rt_nurb_norm: ue");
		rt_free( (char *) ve, "rt_nurb_norm: ve");
d262 1
a262 1
		se = (fastf_t *) rt_nurb_s_eval(srf, u, v);
d267 1
a267 1
		ue = (fastf_t *) rt_nurb_s_eval(usrf, u,v);
d269 1
a269 1
		ve = (fastf_t *) rt_nurb_s_eval(vsrf, u,v);
a284 3
		rt_free( (char *) se, "rt_nurb_norm: se");
		rt_free( (char *) ue, "rt_nurb_norm: ue");
		rt_free( (char *) ve, "rt_nurb_norm: ve");
@


10.4
log
@Control polygon/mesh is now just part of the cnurb/snurb structures,
rather than being a separate structure of their own.
@
text
@d20 2
d25 1
@


10.3
log
@Modifications due to data structure revisions:  mesh and knots are no
longer pointers, but in-place structures.
@
text
@d80 1
a80 1
		if( RT_NURB_IS_PT_RATIONAL(srf->mesh.pt_type))
d138 1
a138 1
		if( RT_NURB_IS_PT_RATIONAL(srf->mesh.pt_type) )
d199 1
a199 1
		if( RT_NURB_IS_PT_RATIONAL(srf->mesh.pt_type) )
d237 1
a237 1
	if( !RT_NURB_IS_PT_RATIONAL(srf->mesh.pt_type))
d261 1
a261 1
	if( RT_NURB_IS_PT_RATIONAL(srf->mesh.pt_type))
@


10.2
log
@Expanded names of manifest constants
@
text
@d48 1
a48 1
		for( i = 0; i < srf->u_knots->k_size -1; i++)
d50 2
a51 2
			if ( srf->u_knots->knots[i] <= u 
				&& u < srf->u_knots->knots[i+1] )
d53 1
a53 1
				p = srf->u_knots->knots[i];
d56 1
a56 1
					p = srf->u_knots->knots[i+1];
d58 1
a58 1
					p = srf->u_knots->knots[i-1];
d65 1
a65 1
		for( i = 0; i < srf->v_knots->k_size -1; i++)
d67 2
a68 2
			if ( srf->v_knots->knots[i] < u 
				&& srf->v_knots->knots[i+1] )
d70 1
a70 1
				p = srf->v_knots->knots[i];
d72 1
a72 1
					p = srf->v_knots->knots[i+1];
d74 1
a74 1
					p = srf->v_knots->knots[i-1];
d80 1
a80 1
		if( RT_NURB_IS_PT_RATIONAL(srf->mesh->pt_type))
d118 1
a118 1
		for( i = 0; i < srf->u_knots->k_size -1; i++)
d120 2
a121 2
			if ( srf->u_knots->knots[i] <= u 
				&& u < srf->u_knots->knots[i+1] )
d123 1
a123 1
				p = srf->u_knots->knots[i];
d126 1
a126 1
					p = srf->u_knots->knots[i+1];
d128 1
a128 1
					p = srf->u_knots->knots[i-1];
d138 1
a138 1
		if( RT_NURB_IS_PT_RATIONAL(srf->mesh->pt_type) )
d180 1
a180 1
		for( i = 0; i < srf->v_knots->k_size -1; i++)
d182 2
a183 2
			if ( srf->v_knots->knots[i] <= v 
				&& v < srf->v_knots->knots[i+1] )
d185 1
a185 1
				p = srf->v_knots->knots[i];
d188 1
a188 1
					p = srf->u_knots->knots[i+1];
d190 1
a190 1
					p = srf->v_knots->knots[i-1];
d199 1
a199 1
		if( RT_NURB_IS_PT_RATIONAL(srf->mesh->pt_type) )
d237 1
a237 1
	if( !RT_NURB_IS_PT_RATIONAL(srf->mesh->pt_type))
d261 1
a261 1
	if( RT_NURB_IS_PT_RATIONAL(srf->mesh->pt_type))
@


10.1
log
@Release_4.0
@
text
@d80 1
a80 1
		if( EXTRACT_RAT(srf->mesh->pt_type))
d134 1
a134 1
		vsrf = (struct snurb *) rt_nurb_s_diff(srf, COL);
d138 1
a138 1
		if( EXTRACT_RAT(srf->mesh->pt_type) )
d196 1
a196 1
		usrf = (struct snurb *) rt_nurb_s_diff(srf, ROW);
d199 1
a199 1
		if( EXTRACT_RAT(srf->mesh->pt_type) )
d237 1
a237 1
	if( !EXTRACT_RAT(srf->mesh->pt_type))
d243 2
a244 2
		usrf = (struct snurb *) rt_nurb_s_diff( srf, ROW);
		vsrf = (struct snurb *) rt_nurb_s_diff( srf, COL);
d261 1
a261 1
	if( EXTRACT_RAT(srf->mesh->pt_type))
d272 2
a273 2
		usrf = (struct snurb *) rt_nurb_s_diff( srf, ROW);
		vsrf = (struct snurb *) rt_nurb_s_diff( srf, COL);
@


1.3
log
@Changed to return an explicit value at bottom of subroutine
@
text
@@


1.2
log
@fixed nurb.h
@
text
@d37 1
a37 1
	fastf_t * norm;
d301 2
a303 1

@


1.1
log
@Initial revision
@
text
@d23 1
a23 1
#include "./nurb.h"
@
