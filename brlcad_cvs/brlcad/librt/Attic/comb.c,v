head	1.24;
access;
symbols
	ansi-20040405-merged:1.19.2.3
	postmerge-20040405-ansi:1.23
	premerge-20040404-ansi:1.22
	postmerge-autoconf:1.22
	autoconf-freeze:1.21.6.2
	premerge-autoconf:1.22
	ansi-20040316-freeze:1.19.2.2
	postmerge-20040315-windows:1.22
	premerge-20040315-windows:1.22
	windows-20040315-freeze:1.19.4.1
	autoconf-20031203:1.21
	autoconf-20031202:1.21
	autoconf-branch:1.21.0.6
	phong-branch:1.21.0.4
	photonmap-branch:1.21.0.2
	rel-6-1-DP:1.19
	windows-branch:1.19.0.4
	rel-6-0-2:1.17
	ansi-branch:1.19.0.2
	rel-6-0-1-branch:1.17.0.2
	hartley-6-0-post:1.18
	hartley-6-0-pre:1.17
	rel-6-0-1:1.17
	rel-6-0:1.17
	rel-5-4:1.11
	offsite-5-3-pre:1.15
	rel-5-3:1.11
	rel-5-2:1.11
	rel-5-1-branch:1.11.0.2
	rel-5-1:1.11
	rel-5-0:1.10
	rel-5-0-beta:1.9
	rel-4-5:1.9
	ctj-4-5-post:1.9
	ctj-4-5-pre:1.9;
locks; strict;
comment	@ * @;


1.24
date	2004.05.21.18.07.29;	author morrison;	state dead;
branches;
next	1.23;

1.23
date	2004.04.05.08.48.56;	author morrison;	state Exp;
branches;
next	1.22;

1.22
date	2004.02.02.17.39.15;	author morrison;	state Exp;
branches;
next	1.21;

1.21
date	2003.01.10.18.48.26;	author morrison;	state Exp;
branches
	1.21.6.1;
next	1.20;

1.20
date	2003.01.03.01.29.49;	author morrison;	state Exp;
branches;
next	1.19;

1.19
date	2002.08.20.17.07.56;	author jra;	state Exp;
branches
	1.19.2.1
	1.19.4.1;
next	1.18;

1.18
date	2002.08.15.20.55.07;	author hartley;	state Exp;
branches;
next	1.17;

1.17
date	2002.03.01.17.58.27;	author jra;	state Exp;
branches;
next	1.16;

1.16
date	2001.03.31.01.57.06;	author morrison;	state Exp;
branches;
next	1.15;

1.15
date	2000.07.12.00.39.55;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	2000.07.10.23.01.26;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	2000.06.29.18.20.55;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	2000.06.29.14.48.37;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	99.11.24.23.02.32;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	99.06.03.00.55.47;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	97.01.30.02.34.08;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	96.12.31.01.38.08;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	96.12.04.02.50.27;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	96.10.25.02.12.33;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	96.10.23.05.29.02;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	96.10.05.09.13.54;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	96.09.27.08.27.30;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	96.07.04.02.28.12;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	96.07.03.05.01.17;	author mike;	state Exp;
branches;
next	;

1.19.2.1
date	2002.09.19.18.01.29;	author morrison;	state Exp;
branches;
next	1.19.2.2;

1.19.2.2
date	2003.02.11.03.21.54;	author morrison;	state Exp;
branches;
next	1.19.2.3;

1.19.2.3
date	2004.03.17.21.18.41;	author morrison;	state Exp;
branches;
next	;

1.19.4.1
date	2004.03.11.23.43.35;	author morrison;	state Exp;
branches;
next	;

1.21.6.1
date	2004.02.12.18.37.38;	author erikg;	state Exp;
branches;
next	1.21.6.2;

1.21.6.2
date	2004.03.15.14.07.16;	author erikg;	state Exp;
branches;
next	;


desc
@Temporary file
@


1.24
log
@moved to src/
@
text
@/*
 *			C O M B . C
 *
 * XXX Move to db_tree.c when complete.
 *
 *  Authors -
 *	John R. Anderson
 *	Michael John Muuss
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1996-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/comb.c,v 1.23 2004/04/05 08:48:56 morrison Exp $ (ARL)";
#endif


#include <stdio.h>
#include <math.h>
#include <string.h>
#include "machine.h"
#include "externs.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "nmg.h"
#include "rtgeom.h"
#include "raytrace.h"
#include "../librt/debug.h"

/* --- Begin John's pretty-printer --- */

void
Print_tree(union tree *tree)
{
	char *str;

	str = (char *)rt_pr_tree_str( tree );
	if( str != NULL )
	{
		printf( "%s\n" , str );
		bu_free( str , "Print_tree" );
	}
	else
		printf( "NULL Tree\n" );
}

int
main(int argc, char *argv[])
{
	struct db_i		*dbip;
	struct directory	*dp;
	struct rt_db_internal	ip;
	struct rt_comb_internal	*comb;
	mat_t			identity_mat;
	int			i;
	struct bu_vls		file;

	bu_debug = BU_DEBUG_MEM_CHECK | BU_DEBUG_COREDUMP;

	if( argc < 3 )
	{
		fprintf( stderr , "Usage:\n\t%s db_file object1 object2 ...\n" , argv[0] );
		exit( 1 );
	}

	MAT_IDN( identity_mat );
	bu_vls_init( &file );

	if( (dbip = db_open( argv[1] , "r" ) ) == NULL )
	{
		fprintf( stderr , "Cannot open %s\n" , argv[1] );
		perror( "test" );
		exit( 1 );
	}

	rt_init_resource( &rt_uniresource, 0, NULL );

	/* Scan the database */
	db_dirbuild( dbip );

	for( i=2 ; i<argc ; i++ )
	{
		printf( "%s\n" , argv[i] );

		dp = db_lookup( dbip , argv[i] , 1 );
		if( rt_db_get_internal( &ip, dp, dbip, NULL, &rt_uniresource ) < 0 )  {
			bu_log("import of %s failed\n", dp->d_namep);
			continue;
		}

		RT_CK_DB_INTERNAL( &ip );
		bu_mem_barriercheck();

		if( ip.idb_type != ID_COMBINATION )
		{
			bu_log( "idb_type = %d\n" , ip.idb_type );
			rt_db_free_internal( &ip, &rt_uniresource );
			continue;
		}

		comb = (struct rt_comb_internal *)ip.idb_ptr;
		RT_CK_COMB(comb);
		if( comb->region_flag )
		{
			bu_log( "\tRegion id = %d, aircode = %d GIFTmater = %d, los = %d\n",
				comb->region_id, comb->aircode, comb->GIFTmater, comb->los );
		}
		bu_log( "\trgb_valid = %d, color = %d/%d/%d\n" , comb->rgb_valid , V3ARGS( comb->rgb ) );
		bu_log( "\tshader = %s (%s)\n" ,
				bu_vls_addr( &comb->shader ),
				bu_vls_addr( &comb->material )
		);

		/* John's way */
		bu_log( "Pretty print:\n" );
		Print_tree( comb->tree );

		/* Standard way */
		bu_log( "Standard print:\n" );
		rt_pr_tree( comb->tree, 1 );

		/* Compact way */
		{
			struct bu_vls	str;
			bu_vls_init( &str );
			rt_pr_tree_vls( &str, comb->tree );
			bu_log("%s\n", bu_vls_addr(&str) );
			bu_vls_free(&str );
		}

		/* Test the support routines */
		if( db_ck_v4gift_tree( comb->tree ) < 0 )
			bu_log("ERROR: db_ck_v4gift_tree is unhappy\n");

		/* Test the lumberjacks */
		rt_db_free_internal( &ip, &rt_uniresource );

	}

	return 0;
}
@


1.23
log
@merge of ansi-6-0-branch into HEAD
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
@


1.22
log
@update copyright to include span through 2003
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/comb.c,v 1.21 2003/01/10 18:48:26 morrison Exp $ (ARL)";
d44 1
a44 2
Print_tree( tree )
union tree *tree;
d59 2
a60 1
main( int argc , char *argv[] ) {
d68 1
a68 1
        
@


1.21
log
@function was not returning a value as specified
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1996 by the United States Army
d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/comb.c,v 1.20 2003/01/03 01:29:49 morrison Exp $ (ARL)";
@


1.21.6.1
log
@merge from HEAD
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1996-2004 by the United States Army
d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/comb.c,v 1.22 2004/02/02 17:39:15 morrison Exp $ (ARL)";
@


1.21.6.2
log
@merge from head
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/comb.c,v 1.21.6.1 2004/02/12 18:37:38 erikg Exp $ (ARL)";
@


1.20
log
@removed some unused variables; cleaned up compilation warnings
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/comb.c,v 1.19 2002/08/20 17:07:56 jra Exp $ (ARL)";
d150 2
@


1.19
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/comb.c,v 1.17 2002/03/01 17:58:27 jra Exp $ (ARL)";
d59 2
a60 4
main( argc , argv )
int argc;
char *argv[];
{
a62 1
	struct bu_external	ep;
d68 1
a68 2
	FILE			*fp;

a93 2
		int j;

@


1.19.4.1
log
@sync to HEAD...
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1996-2004 by the United States Army
d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/comb.c,v 1.22 2004/02/02 17:39:15 morrison Exp $ (ARL)";
d59 4
a62 2
int
main( int argc , char *argv[] ) {
d65 1
d71 2
a72 1
        
d98 2
a155 2

	return 0;
@


1.19.2.1
log
@Initial ANSIfication
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/comb.c,v 1.19 2002/08/20 17:07:56 jra Exp $ (ARL)";
d44 2
a45 1
Print_tree(union tree *tree)
d59 3
a61 1
main(int argc, char **argv)
@


1.19.2.2
log
@removed some usused variables
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/comb.c,v 1.19.2.1 2002/09/19 18:01:29 morrison Exp $ (ARL)";
d58 1
a58 1
int main(int argc, char **argv)
d62 1
d68 1
d95 1
a152 2

    return 0;
@


1.19.2.3
log
@sync branch with HEAD
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1996-2004 by the United States Army
d24 1
a24 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d58 1
a58 1
int main(int argc, char *argv[])
d93 1
@


1.18
log
@Converted from K&R to ANSI C - RFH
@
text
@d44 2
a45 1
Print_tree(union tree *tree)
d59 3
a61 1
main(int argc, char **argv)
@


1.17
log
@Updated to get it working again
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/comb.c,v 1.16 2001/03/31 01:57:06 morrison Exp $ (ARL)";
d44 1
a44 2
Print_tree( tree )
union tree *tree;
d58 1
a58 3
main( argc , argv )
int argc;
char *argv[];
@


1.16
log
@Deprecated bn_mat_idn() and bn_mat_zero(), updated calls to h/vmath.h's MAT_IDN() and MAT_ZERO() performance improved macros.
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/comb.c,v 1.15 2000/07/12 00:39:55 mike Exp $ (ARL)";
d91 2
d103 1
a103 1
		if( rt_db_get_internal( &ip, dp, dbip, NULL ) < 0 )  {
d114 1
a114 1
			rt_db_free_internal( &ip );
d132 1
d136 1
a151 23
		/* write original external form into a file */
		bu_vls_printf( &file, "/tmp/%s.a", argv[i] );
		if( (fp = fopen(bu_vls_addr(&file), "w")) != NULL )  {
			fwrite( ep.ext_buf, ep.ext_nbytes, 1, fp );
			fclose(fp);
		}
		bu_free_external( &ep );
		bu_vls_free( &file );

		/* Convert internal back to external, and write both to files */
		bu_vls_printf( &file, "/tmp/%s.b", argv[i] );
		bu_mem_barriercheck();

		rt_db_put_internal( dp, dbip, &ip );
		bu_mem_barriercheck();

		if( (fp = fopen(bu_vls_addr(&file), "w")) != NULL )  {
			fwrite( ep.ext_buf, ep.ext_nbytes, 1, fp );
			fclose(fp);
		}
		bu_free_external( &ep );
		bu_vls_free( &file );

d153 1
a153 1
		rt_db_free_internal( &ip );
@


1.15
log
@
No longer needs db.h
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/comb.c,v 1.14 2000/07/10 23:01:26 mike Exp $ (ARL)";
d81 1
a81 1
	bn_mat_idn( identity_mat );
@


1.14
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/comb.c,v 1.13 2000/06/29 18:20:55 mike Exp $ (ARL)";
a31 1
#include "db.h"
@


1.13
log
@
Changed from db_free_external() to bu_free_external()
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/comb.c,v 1.12 2000/06/29 14:48:37 mike Exp $ (ARL)";
@


1.12
log
@
rt_db_free_internal
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/comb.c,v 1.11 1999/11/24 23:02:32 mike Exp $ (ARL)";
d155 1
a155 1
		db_free_external( &ep );
d169 1
a169 1
		db_free_external( &ep );
@


1.11
log
@
Changed to ft_ifree()
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/comb.c,v 1.10 1999/06/03 00:55:47 mike Exp $ (ARL)";
d93 1
a93 1
	db_scan(dbip, (int (*)())db_diradd, 1);
d102 1
a102 6
		if( db_get_external( &ep , dp , dbip ) )
		{
			bu_log( "db_get_external failed for %s\n" , argv[i] );
			continue;
		}
		if( rt_comb_v4_import( &ip , &ep , NULL ) < 0 )  {
d113 1
d173 1
a173 1
		ip.idb_meth->ft_ifree( &ip );
@


1.10
log
@
sed4
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/comb.c,v 1.9 1997/01/30 02:34:08 mike Exp $ (ARL)";
d177 1
a177 1
		rt_comb_ifree( &ip );
@


1.9
log
@Changed to rt_db_put_internal()
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/comb.c,v 1.8 1996/12/31 01:38:08 mike Exp mike $ (ARL)";
d40 1
a40 1
#include "/m/cad/librt/debug.h"
d50 1
a50 1
	str = rt_pr_tree_str( tree );
d54 1
a54 1
		rt_free( str , "Print_tree" );
d66 1
a66 1
	struct rt_external	ep;
d82 1
a82 1
	mat_idn( identity_mat );
d104 1
a104 1
			rt_log( "db_get_external failed for %s\n" , argv[i] );
d108 1
a108 1
			rt_log("import of %s failed\n", dp->d_namep);
d117 1
a117 1
			rt_log( "idb_type = %d\n" , ip.idb_type );
d125 1
a125 1
			rt_log( "\tRegion id = %d, aircode = %d GIFTmater = %d, los = %d\n",
d128 4
a131 4
		rt_log( "\trgb_valid = %d, color = %d/%d/%d\n" , comb->rgb_valid , V3ARGS( comb->rgb ) );
		rt_log( "\tshader = %s (%s)\n" ,
				rt_vls_addr( &comb->shader ),
				rt_vls_addr( &comb->material )
d142 2
a143 2
			struct rt_vls	str;
			rt_vls_init( &str );
d145 2
a146 2
			rt_log("%s\n", rt_vls_addr(&str) );
			rt_vls_free(&str );
d151 1
a151 1
			rt_log("ERROR: db_ck_v4gift_tree is unhappy\n");
@


1.8
log
@Moved John's pretty printer from comb.c to pr.c
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/comb.c,v 1.7 1996/12/04 02:50:27 mike Exp mike $ (ARL)";
d166 1
a166 1
		rt_v4_export( &ep, &ip, 1.0, dp );
@


1.7
log
@Combined ma_matname and ma_matparm into a single string, ma_shader.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/comb.c,v 1.6 1996/10/25 02:12:33 mike Exp mike $ (ARL)";
a43 59
char
*Recurse_tree( tree )
union tree *tree;
{
	char *left,*right;
	char *return_str;
	char op;
	int return_length;

	if( tree == NULL )
		return( (char *)NULL );
	if( tree->tr_op == OP_UNION || tree->tr_op == OP_SUBTRACT || tree->tr_op == OP_INTERSECT )
	{
		left = Recurse_tree( tree->tr_b.tb_left );
		right = Recurse_tree( tree->tr_b.tb_right );
		switch( tree->tr_op )
		{
			case OP_UNION:
				op = 'u';
				break;
			case OP_SUBTRACT:
				op = '-';
				break;
			case OP_INTERSECT:
				op = '+';
				break;
		}
		return_length = strlen( left ) + strlen( right ) + 4;
		if( op == 'u' )
			return_length += 4;
		return_str = (char *)rt_malloc( return_length , "recurse_tree: return string" );
		if( op == 'u' )
		{
			char *blankl,*blankr;

			blankl = strchr( left , ' ' );
			blankr = strchr( right , ' ' );
			if( blankl && blankr )
				sprintf( return_str , "(%s) %c (%s)" , left , op , right );
			else if( blankl && !blankr )
				sprintf( return_str , "(%s) %c %s" , left , op , right );
			else if( !blankl && blankr )
				sprintf( return_str , "%s %c (%s)" , left , op , right );
			else
				sprintf( return_str , "%s %c %s" , left , op , right );
		}
		else
			sprintf( return_str , "%s %c %s" , left , op , right );
		if( tree->tr_b.tb_left->tr_op != OP_DB_LEAF )
			rt_free( left , "Recurse_tree: left string" );
		if( tree->tr_b.tb_right->tr_op != OP_DB_LEAF )
			rt_free( right , "Recurse_tree: right string" );
		return( return_str );
	}
	else if( tree->tr_op == OP_DB_LEAF ) {
		return bu_strdup(tree->tr_l.tl_name) ;
	}
}

d50 1
a50 1
	str = Recurse_tree( tree );
@


1.6
log
@Changed to use rt_v4_export()
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/comb.c,v 1.5 1996/10/23 05:29:02 mike Exp mike $ (ARL)";
d188 2
a189 3
		rt_log( "\tmaterial name = %s, parameters = %s, (%s)\n" ,
				rt_vls_addr( &comb->shader_name ),
				rt_vls_addr( &comb->shader_param ),
@


1.5
log
@Added tests of export support, too.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/comb.c,v 1.4 1996/10/05 09:13:54 mike Exp mike $ (ARL)";
d226 1
a226 1
		rt_comb_v4_export( &ep, &ip, 1.0 );
a227 5
		{
			union record *rec;
			rec = (union record *)ep.ext_buf;
			NAMEMOVE( dp->d_namep, rec->s.s_name );
		}
@


1.4
log
@Moved rt_comb_internal to raytrace.h
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/comb.c,v 1.3 1996/09/27 08:27:30 mike Exp mike $ (ARL)";
d34 1
d36 1
d99 1
a99 1
		return tree->tr_l.tl_name ;
d130 2
d133 2
d142 1
d172 1
d213 28
d243 1
@


1.3
log
@Converted to using proper routine names for LIBBU and LIBBN routines.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/comb.c,v 1.2 1996/07/04 02:28:12 mike Exp mike $ (ARL)";
a38 34

/*
 *  In-memory format for combination.
 *  (Regions and Groups are both a kind of Combination).
 *  Move to h/wdb.h
 */
struct rt_comb_internal  {
	long		magic;
	union tree	*tree;		/* Leading to tree_db_leaf leaves */
	char		region_flag;	/* !0 ==> this COMB is a REGION */
	/* Begin GIFT compatability */
	short		region_id;
	short		aircode;
	short		GIFTmater;
	short		los;
	/* End GIFT compatability */
	char		rgb_valid;	/* !0 ==> rgb[] has valid color */
	unsigned char	rgb[3];
	struct rt_vls	shader_name;
	struct rt_vls	shader_param;
	struct rt_vls	material;
	char		inherit;
};
#define RT_COMB_MAGIC	0x436f6d49	/* "ComI" */
#define RT_CK_COMB(_p)		NMG_CKMAG( _p , RT_COMB_MAGIC , "rt_comb_internal" )


/* Internal. Ripped off from db_tree.c */
struct tree_list {
	union tree *tl_tree;
	int	tl_op;
};
#define TREE_LIST_NULL	((struct tree_list *)0)

@


1.2
log
@Eliminated need for 'tol' parameter.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/comb.c,v 1.1 1996/07/03 05:01:17 mike Exp mike $ (ARL)";
a71 243

RT_EXTERN( union tree *db_mkbool_tree , (struct tree_list *tree_list , int howfar ) );
RT_EXTERN( union tree *db_mkgift_tree , (struct tree_list *tree_list , int howfar , struct db_tree_state *tsp ) );

/*
 *		R T _ C O M B _ V 4 _ I M P O R T
 *
 *  Import a combination record from a V4 database into internal form.
 */
int
rt_comb_v4_import( ip, ep, matrix )
struct rt_db_internal		*ip;
CONST struct rt_external	*ep;
CONST matp_t			matrix;		/* NULL if identity */
{
	union record		*rp;
	struct tree_list	*tree_list;
	union tree		*tree;
	struct rt_comb_internal	*comb;
	int			i,j;
	int			node_count;

	RT_CK_EXTERNAL( ep );
	rp = (union record *)ep->ext_buf;

	if( rp[0].u_id != ID_COMB )
	{
		rt_log( "rt_comb_v4_import: Attempt to import a non-combination\n" );
		return( -1 );
	}

	/* Compute how many granules of MEMBER records follow */
	node_count = ep->ext_nbytes/sizeof( union record ) - 1;

	if( node_count )
		tree_list = (struct tree_list *)rt_calloc( node_count , sizeof( struct tree_list ) , "tree_list" );
	else
		tree_list = (struct tree_list *)NULL;

	for( j=0 ; j<node_count ; j++ )
	{
		if( rp[j+1].u_id != ID_MEMB )
		{
			rt_free( (char *)tree_list , "rt_comb_v4_import: tree_list" );
			rt_log( "rt_comb_v4_import(): granule in external buffer is not ID_MEMB, id=%d\n", rp[j+1].u_id );
			return( -1 );
		}

		switch( rp[j+1].M.m_relation )
		{
			case '+':
				tree_list[j].tl_op = OP_INTERSECT;
				break;
			case '-':
				tree_list[j].tl_op = OP_SUBTRACT;
				break;
			default:
				rt_log("rt_comb_v4_import() unknown op=x%x, assuming UNION\n", rp[j+1].M.m_relation );
				/* Fall through */
			case 'u':
				tree_list[j].tl_op = OP_UNION;
				break;
		}
		/* Build leaf node for in-memory tree */
		{
			union tree		*tp;
			struct tree_db_leaf	*mi;
			mat_t			diskmat;
			char			namebuf[NAMESIZE+2];

			GETUNION( tp, tree );
			tree_list[j].tl_tree = tp;
			tp->tr_l.magic = RT_TREE_MAGIC;
			tp->tr_l.tl_op = OP_DB_LEAF;
			strncpy( namebuf, rp[j+1].M.m_instname, NAMESIZE );
			namebuf[NAMESIZE] = '\0';	/* ensure null term */
			tp->tr_l.tl_name = rt_strdup( namebuf );

			/* See if disk record is identity matrix */
			rt_mat_dbmat( diskmat, rp[j+1].M.m_mat );
			if( mat_is_identity( diskmat ) )  {
				if( matrix == NULL )  {
					tp->tr_l.tl_mat = NULL;	/* identity */
				} else {
					tp->tr_l.tl_mat = mat_dup( matrix );
				}
			} else {
				if( matrix == NULL )  {
					tp->tr_l.tl_mat = mat_dup( diskmat );
				} else {
					mat_t	prod;
					mat_mul( prod, matrix, diskmat );
					tp->tr_l.tl_mat = mat_dup( prod );
				}
			}
rt_log("M_name=%s, matp=x%x\n", tp->tr_l.tl_name, tp->tr_l.tl_mat );
		}
	}
	if( node_count )
		tree = db_mkgift_tree( tree_list, node_count, (struct db_tree_state *)NULL );
	else
		tree = (union tree *)NULL;

	RT_INIT_DB_INTERNAL( ip );
	ip->idb_type = ID_COMBINATION;
	comb = (struct rt_comb_internal *)rt_malloc( sizeof( struct rt_comb_internal ) , "rt_comb_v4_import: rt_comb_internal" );
	ip->idb_ptr = (genptr_t)comb;
	comb->magic = RT_COMB_MAGIC;
	rt_vls_init( &comb->shader_name );
	rt_vls_init( &comb->shader_param );
	rt_vls_init( &comb->material );
	comb->tree = tree;
	comb->region_flag = (rp[0].c.c_flags == 'R');

	comb->region_id = rp[0].c.c_regionid;
	comb->aircode = rp[0].c.c_aircode;
	comb->GIFTmater = rp[0].c.c_material;
	comb->los = rp[0].c.c_los;

	comb->rgb_valid = rp[0].c.c_override;
	comb->rgb[0] = rp[0].c.c_rgb[0];
	comb->rgb[1] = rp[0].c.c_rgb[1];
	comb->rgb[2] = rp[0].c.c_rgb[2];
	rt_vls_strncpy( &comb->shader_name , rp[0].c.c_matname, 32 );
	rt_vls_strncpy( &comb->shader_param , rp[0].c.c_matparm, 60 );
	comb->inherit = rp[0].c.c_inherit;
	/* Automatic material table lookup here? */
	rt_vls_printf( &comb->material, "gift%d", comb->GIFTmater );

	return( 0 );
}

/*
 *			R T _ C O M B _ I F R E E
 *
 *  Free the storage associated with the rt_db_internal version of this combination.
 */
void
rt_comb_ifree( ip )
struct rt_db_internal	*ip;
{
	register struct rt_comb_internal	*comb;

	RT_CK_DB_INTERNAL(ip);
	comb = (struct rt_comb_internal *)ip->idb_ptr;
	RT_CK_COMB(comb);

	db_free_tree( comb->tree );
	comb->tree = NULL;

	rt_vls_free( &comb->shader_name );
	rt_vls_free( &comb->shader_param );
	rt_vls_free( &comb->material );

	comb->magic = 0;			/* sanity */
	rt_free( (char *)comb, "comb ifree" );
	ip->idb_ptr = GENPTR_NULL;	/* sanity */
}

/* -------------------- */
/* Some export support routines */

/*
 *			D B _ C K _ L E F T _ H E A V Y _ T R E E
 *
 *  Support routine for db_ck_v4gift_tree().
 *  Ensure that the tree below 'tp' is left-heavy, i.e. that there are
 *  nothing but solids on the right side of any binary operations.
 *
 *  Returns -
 *	-1	ERROR
 *	 0	OK
 */
int
db_ck_left_heavy_tree( tp, no_unions )
CONST union tree	*tp;
int			no_unions;
{
	RT_CK_TREE(tp);
	switch( tp->tr_op )  {

	case OP_DB_LEAF:
		break;

	case OP_UNION:
		if( no_unions )  return -1;
		/* else fall through */
	case OP_INTERSECT:
	case OP_SUBTRACT:
	case OP_XOR:
		if( tp->tr_b.tb_right->tr_op != OP_DB_LEAF )
			return -1;
		return db_ck_left_heavy_tree( tp->tr_b.tb_left, no_unions );

	default:
		rt_log("db_ck_left_heavy_tree: bad op %d\n", tp->tr_op);
		rt_bomb("db_ck_left_heavy_tree\n");
	}
	return 0;
}


/*
 *			D B _ C K _ V 4 G I F T _ T R E E
 *
 *  Look a gift-tree in the mouth.
 *  Ensure that this boolean tree conforms to the GIFT convention that
 *  union operations must bind the loosest.
 *  There are two stages to this check:
 *  1)  Ensure that if unions are present they are all at the root of tree,
 *  2)  Ensure non-union children of union nodes are all left-heavy
 *      (nothing but solid nodes permitted on rhs of binary operators).
 *
 *  Returns -
 *	-1	ERROR
 *	 0	OK
 */
int
db_ck_v4gift_tree( tp )
CONST union tree	*tp;
{
	RT_CK_TREE(tp);
	switch( tp->tr_op )  {

	case OP_DB_LEAF:
		break;

	case OP_UNION:
		if( db_ck_v4gift_tree( tp->tr_b.tb_left ) < 0 )
			return -1;
		return db_ck_v4gift_tree( tp->tr_b.tb_right );

	case OP_INTERSECT:
	case OP_SUBTRACT:
	case OP_XOR:
		return db_ck_left_heavy_tree( tp, 1 );

	default:
		rt_log("db_ck_v4gift_tree: bad op %d\n", tp->tr_op);
		rt_bomb("db_ck_v4gift_tree\n");
	}
	return 0;
}
@


1.1
log
@Initial revision
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
d82 1
a82 1
rt_comb_v4_import( ip, ep, matrix, tol )
a85 1
CONST struct rt_tol		*tol;
a93 1
	RT_CK_TOL( tol );
d152 1
a152 3
			/* XXX There should be rt_mat_is_identity() */
			/* XXX Could be used in librt/tree.c as well */
			if( rt_mat_is_equal( diskmat, rt_identity, tol ) )  {
a403 1
	struct rt_tol		tol;
a411 6
	tol.magic = RT_TOL_MAGIC;
	tol.dist = 0.005;
	tol.dist_sq = tol.dist * tol.dist;
	tol.perp = 1e-6;
	tol.para = 1 - tol.perp;

d436 1
a436 1
		if( rt_comb_v4_import( &ip , &ep , NULL, &tol ) < 0 )  {
@
