head	1.74;
access;
symbols
	ansi-20040405-merged:1.69.2.2
	postmerge-20040405-ansi:1.72
	premerge-20040404-ansi:1.71
	postmerge-autoconf:1.71
	autoconf-freeze:1.69.10.3
	premerge-autoconf:1.71
	ansi-20040316-freeze:1.69.2.1
	postmerge-20040315-windows:1.71
	premerge-20040315-windows:1.71
	windows-20040315-freeze:1.69.4.1
	autoconf-20031203:1.69.10.1
	autoconf-20031202:1.69
	autoconf-branch:1.69.0.10
	phong-branch:1.69.0.8
	photonmap-branch:1.69.0.6
	rel-6-1-DP:1.69
	windows-branch:1.69.0.4
	rel-6-0-2:1.67
	ansi-branch:1.69.0.2
	rel-6-0-1-branch:1.67.0.2
	hartley-6-0-post:1.68
	hartley-6-0-pre:1.67
	rel-6-0-1:1.67
	rel-6-0:1.67
	rel-5-4:1.45
	offsite-5-3-pre:1.60
	rel-5-3:1.45
	rel-5-2:1.45
	rel-5-1-branch:1.45.0.2
	rel-5-1:1.45
	rel-5-0:1.9
	rel-5-0-beta:1.7;
locks; strict;
comment	@ * @;


1.74
date	2004.05.21.18.07.31;	author morrison;	state dead;
branches;
next	1.73;

1.73
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	1.72;

1.72
date	2004.04.05.08.48.57;	author morrison;	state Exp;
branches;
next	1.71;

1.71
date	2004.02.02.17.39.21;	author morrison;	state Exp;
branches;
next	1.70;

1.70
date	2003.10.17.20.52.03;	author jra;	state Exp;
branches;
next	1.69;

1.69
date	2002.08.20.17.08.01;	author jra;	state Exp;
branches
	1.69.2.1
	1.69.4.1
	1.69.10.1;
next	1.68;

1.68
date	2002.08.15.20.55.13;	author hartley;	state Exp;
branches;
next	1.67;

1.67
date	2002.01.10.18.12.40;	author butler;	state Exp;
branches;
next	1.66;

1.66
date	2001.10.12.15.23.20;	author bparker;	state Exp;
branches;
next	1.65;

1.65
date	2001.10.02.19.24.30;	author jra;	state Exp;
branches;
next	1.64;

1.64
date	2001.05.17.20.05.25;	author morrison;	state Exp;
branches;
next	1.63;

1.63
date	2001.04.20.22.29.47;	author morrison;	state Exp;
branches;
next	1.62;

1.62
date	2001.04.02.21.38.09;	author morrison;	state Exp;
branches;
next	1.61;

1.61
date	2001.03.21.22.37.41;	author jra;	state Exp;
branches;
next	1.60;

1.60
date	2000.11.02.02.09.43;	author mike;	state Exp;
branches;
next	1.59;

1.59
date	2000.09.21.05.30.39;	author mike;	state Exp;
branches;
next	1.58;

1.58
date	2000.09.21.04.54.05;	author mike;	state Exp;
branches;
next	1.57;

1.57
date	2000.09.21.03.59.50;	author mike;	state Exp;
branches;
next	1.56;

1.56
date	2000.09.11.19.57.29;	author mike;	state Exp;
branches;
next	1.55;

1.55
date	2000.09.09.05.32.29;	author mike;	state Exp;
branches;
next	1.54;

1.54
date	2000.09.08.05.54.42;	author mike;	state Exp;
branches;
next	1.53;

1.53
date	2000.09.07.01.06.43;	author mike;	state Exp;
branches;
next	1.52;

1.52
date	2000.08.21.02.02.31;	author butler;	state Exp;
branches;
next	1.51;

1.51
date	2000.07.10.23.01.35;	author mike;	state Exp;
branches;
next	1.50;

1.50
date	2000.06.30.20.25.50;	author jra;	state Exp;
branches;
next	1.49;

1.49
date	2000.06.30.15.38.04;	author mike;	state Exp;
branches;
next	1.48;

1.48
date	2000.06.30.15.31.15;	author mike;	state Exp;
branches;
next	1.47;

1.47
date	2000.06.29.18.31.33;	author mike;	state Exp;
branches;
next	1.46;

1.46
date	2000.06.29.14.36.33;	author mike;	state Exp;
branches;
next	1.45;

1.45
date	2000.04.12.02.34.36;	author mike;	state Exp;
branches;
next	1.44;

1.44
date	2000.02.14.20.16.46;	author mike;	state Exp;
branches;
next	1.43;

1.43
date	2000.02.14.19.28.35;	author mike;	state Exp;
branches;
next	1.42;

1.42
date	2000.02.12.02.07.17;	author mike;	state Exp;
branches;
next	1.41;

1.41
date	2000.02.12.01.59.10;	author mike;	state Exp;
branches;
next	1.40;

1.40
date	2000.02.10.05.15.26;	author mike;	state Exp;
branches;
next	1.39;

1.39
date	2000.02.10.04.27.28;	author mike;	state Exp;
branches;
next	1.38;

1.38
date	2000.02.08.05.10.23;	author mike;	state Exp;
branches;
next	1.37;

1.37
date	2000.02.02.04.15.58;	author mike;	state Exp;
branches;
next	1.36;

1.36
date	2000.02.02.03.13.39;	author mike;	state Exp;
branches;
next	1.35;

1.35
date	2000.02.02.02.13.37;	author mike;	state Exp;
branches;
next	1.34;

1.34
date	2000.02.02.01.23.16;	author mike;	state Exp;
branches;
next	1.33;

1.33
date	2000.01.14.05.37.26;	author mike;	state Exp;
branches;
next	1.32;

1.32
date	2000.01.13.01.53.30;	author mike;	state Exp;
branches;
next	1.31;

1.31
date	2000.01.12.01.41.15;	author mike;	state Exp;
branches;
next	1.30;

1.30
date	2000.01.08.04.09.06;	author mike;	state Exp;
branches;
next	1.29;

1.29
date	2000.01.08.02.30.26;	author mike;	state Exp;
branches;
next	1.28;

1.28
date	2000.01.06.04.53.49;	author mike;	state Exp;
branches;
next	1.27;

1.27
date	2000.01.06.02.39.11;	author mike;	state Exp;
branches;
next	1.26;

1.26
date	2000.01.06.02.35.46;	author mike;	state Exp;
branches;
next	1.25;

1.25
date	2000.01.04.17.58.20;	author bparker;	state Exp;
branches;
next	1.24;

1.24
date	99.12.30.04.56.59;	author mike;	state Exp;
branches;
next	1.23;

1.23
date	99.12.29.23.23.11;	author mike;	state Exp;
branches;
next	1.22;

1.22
date	99.12.29.04.50.29;	author mike;	state Exp;
branches;
next	1.21;

1.21
date	99.12.29.03.06.21;	author mike;	state Exp;
branches;
next	1.20;

1.20
date	99.12.28.23.29.28;	author mike;	state Exp;
branches;
next	1.19;

1.19
date	99.12.23.06.32.29;	author mike;	state Exp;
branches;
next	1.18;

1.18
date	99.12.23.05.05.27;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	99.12.22.05.21.20;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	99.12.22.04.49.04;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	99.12.18.16.35.23;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	99.12.18.02.11.50;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	99.11.24.23.12.09;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	99.11.17.04.39.20;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	99.11.17.02.42.02;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	99.10.30.03.53.27;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	99.07.06.18.49.04;	author jra;	state Exp;
branches;
next	1.8;

1.8
date	99.07.02.22.19.24;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	99.05.27.19.10.42;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	99.01.15.16.34.57;	author jra;	state Exp;
branches;
next	1.5;

1.5
date	98.06.25.08.25.57;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	98.04.15.06.13.16;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	98.04.03.01.39.22;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	98.04.03.00.18.05;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	98.03.27.08.34.22;	author mike;	state Exp;
branches;
next	;

1.69.2.1
date	2002.09.19.18.01.37;	author morrison;	state Exp;
branches;
next	1.69.2.2;

1.69.2.2
date	2004.03.17.21.18.48;	author morrison;	state Exp;
branches;
next	;

1.69.4.1
date	2004.03.11.23.43.39;	author morrison;	state Exp;
branches;
next	;

1.69.10.1
date	2003.12.03.16.24.07;	author erikg;	state Exp;
branches;
next	1.69.10.2;

1.69.10.2
date	2004.02.12.18.37.42;	author erikg;	state Exp;
branches;
next	1.69.10.3;

1.69.10.3
date	2004.03.15.14.07.20;	author erikg;	state Exp;
branches;
next	;


desc
@librt/g_submodel.c
@


1.74
log
@moved to src/
@
text
@/*
 *			G _ S U B M O D E L . C
 *
 *  Purpose -
 *	Intersect a ray with an entire subspace full of geometry,
 *	possibly included from another .g file, with a subordinate
 *	instance of LIBRT.
 *
 *  This solid is particularly useful when instancing millions of copies
 *  of a given complex object, such as a detailed tree.
 *
 *
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" license agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 2000-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */
#ifndef lint
static const char RCSsubmodel[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/g_submodel.c,v 1.73 2004/05/10 15:30:46 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#include <string.h>
#include "machine.h"
#include "vmath.h"
#include "db.h"
#include "nmg.h"
#include "raytrace.h"
#include "rtgeom.h"

#define RT_SUBMODEL_O(m)	offsetof(struct rt_submodel_internal, m)

const struct bu_structparse rt_submodel_parse[] = {
	{"%S",	1, "file",	RT_SUBMODEL_O(file),		BU_STRUCTPARSE_FUNC_NULL },
	{"%S",	1, "treetop",	RT_SUBMODEL_O(treetop),		BU_STRUCTPARSE_FUNC_NULL },
	{"%d",	1, "meth",	RT_SUBMODEL_O(meth),		BU_STRUCTPARSE_FUNC_NULL },
	{"",	0, (char *)0, 0,			BU_STRUCTPARSE_FUNC_NULL }
};

/* ray tracing form of solid, including precomputed terms */
struct submodel_specific {
	long		magic;
	mat_t		subm2m;		/* To transform normals back out to model coords */
	mat_t		m2subm;		/* To transform rays into local coord sys */
	struct rt_i	*rtip;		/* sub model */
};
#define RT_SUBMODEL_SPECIFIC_MAGIC	0x73756253	/* subS */
#define RT_CK_SUBMODEL_SPECIFIC(_p)	BU_CKMAG(_p,RT_SUBMODEL_SPECIFIC_MAGIC,"submodel_specific")


/*
 *  			R T _ S U B M O D E L _ P R E P
 *  
 *  Given a pointer to a GED database record, and a transformation matrix,
 *  determine if this is a valid SUBMODEL, and if so, precompute various
 *  terms of the formula.
 *  
 *  Returns -
 *  	0	SUBMODEL is OK
 *  	!0	Error in description
 *  
 *  Implicit return -
 *  	A struct submodel_specific is created, and it's address is stored in
 *  	stp->st_specific for use by submodel_shot().
 */
int
rt_submodel_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
{
	struct rt_submodel_internal	*sip;
	struct submodel_specific	*submodel;
	struct rt_i			*sub_rtip;
	struct db_i			*sub_dbip;
	struct resource			*resp;
	vect_t	radvec;
	vect_t	diam;
	char	*argv[2];
	struct rt_i	**rtipp;

	RT_CK_DB_INTERNAL(ip);
	sip = (struct rt_submodel_internal *)ip->idb_ptr;
	RT_SUBMODEL_CK_MAGIC(sip);

	bu_semaphore_acquire(RT_SEM_MODEL);
	/*
	 * This code must be prepared to run in parallel
	 * without tripping over itself.
	 */
	if( bu_vls_strlen( &sip->file ) == 0 )  {
		/* No .g file name given, tree is in current .g file */
		sub_dbip = rtip->rti_dbip;
	} else {
		/* db_open will cache dbip's via bu_open_mapped_file() */
		if( (sub_dbip = db_open( bu_vls_addr( &sip->file ), "r" )) == DBI_NULL )
		    	return -1;

		/* Save the overhead of stat() calls on subsequent opens */
		if( sub_dbip->dbi_mf )  sub_dbip->dbi_mf->dont_restat = 1;

		if( !db_is_directory_non_empty(sub_dbip) )  {
			/* This is first open of db, build directory */
			if( db_dirbuild( sub_dbip ) < 0 )  {
				db_close( sub_dbip );
				bu_semaphore_release(RT_SEM_MODEL);
				return -1;
			}
		}
	}

	/*
	 *  Search for a previous exact use of this file and treetop,
	 *  so as to obtain storage efficiency from re-using it.
	 *  Search dbi_client list for a re-use of an rt_i.
	 *  rtip's are registered there by db_clone_dbi().
	 */
	for( BU_PTBL_FOR( rtipp, (struct rt_i **), &sub_dbip->dbi_clients ) )  {
		register char	*ttp;
		RT_CK_RTI(*rtipp);
		ttp = (*rtipp)->rti_treetop;
		if( ttp && strcmp( ttp, bu_vls_addr( &sip->treetop ) ) == 0 )  {
			/* Re-cycle an already prepped rti */
			sub_rtip = *rtipp;
			sub_rtip->rti_uses++;

			bu_semaphore_release(RT_SEM_MODEL);

			if( RT_G_DEBUG & (DEBUG_DB|DEBUG_SOLIDS) )  {
				bu_log("rt_submodel_prep(%s): Re-used already prepped database %s, rtip=x%lx\n",
					stp->st_dp->d_namep,
					sub_dbip->dbi_filename,
					(long)sub_rtip );
			}
			goto done;
		}
	}

	sub_rtip = rt_new_rti( sub_dbip );	/* does db_clone_dbi() */
	RT_CK_RTI(sub_rtip);

	/* Set search term before leaving critical section */
	sub_rtip->rti_treetop = bu_vls_strdup(&sip->treetop);

	bu_semaphore_release(RT_SEM_MODEL);

	if( RT_G_DEBUG & (DEBUG_DB|DEBUG_SOLIDS) )  {
		bu_log("rt_submodel_prep(%s): Opened database %s\n",
			stp->st_dp->d_namep, sub_dbip->dbi_filename );
	}

	/*
	 *  Initialize per-processor resources for the submodel.
	 *  We treewalk here with only one processor (CPU 0).
	 *  db_walk_tree() as called from
	 *  rt_gettrees() will pluck the 0th resource out of the rtip table.
	 *  rt_submodel_shot() will get additional resources as needed.
	 */
	BU_GETSTRUCT( resp, resource );
	BU_PTBL_SET(&sub_rtip->rti_resources, 0, resp);
	rt_init_resource( resp, 0, sub_rtip );

	/* Propagate some important settings downward */
	sub_rtip->useair = rtip->useair;
	sub_rtip->rti_dont_instance = rtip->rti_dont_instance;
	sub_rtip->rti_hasty_prep = rtip->rti_hasty_prep;
	sub_rtip->rti_tol = rtip->rti_tol;	/* struct copy */
	sub_rtip->rti_ttol = rtip->rti_ttol;	/* struct copy */

	if( sip->meth )  {
		sub_rtip->rti_space_partition = sip->meth;
	} else {
		sub_rtip->rti_space_partition = rtip->rti_space_partition;
	}

	argv[0] = bu_vls_addr( &sip->treetop );
	argv[1] = NULL;
	if( rt_gettrees( sub_rtip, 1, (const char **)argv, 1 ) < 0 )  {
		bu_log("submodel(%s) rt_gettrees(%s) failed\n", stp->st_name, argv[0]);
		/* Can't call rt_free_rti( sub_rtip ) because it may have
		 * already been instanced!
		 */
		return -2;
	}

	if( sub_rtip->nsolids <= 0 )  {
		bu_log("rt_submodel_prep(%s): %s No primitives found\n",
			stp->st_dp->d_namep, bu_vls_addr( &sip->file ) );
		/* Can't call rt_free_rti( sub_rtip ) because it may have
		 * already been instanced!
		 */
		return -3;
	}

	/* OK, it's going to work.  Prep the submodel. */
	/* Stay on 1 CPU because we're already multi-threaded at this point. */
	rt_prep_parallel(sub_rtip, 1);

	/* Ensure bu_ptbl rti_resources is full size.  Ptrs will be null */
	if( BU_PTBL_LEN(&sub_rtip->rti_resources) < sub_rtip->rti_resources.blen )  {
		BU_PTBL_LEN(&sub_rtip->rti_resources) = sub_rtip->rti_resources.blen;
	}

if(RT_G_DEBUG) rt_pr_cut_info( sub_rtip, stp->st_name );

done:	
	BU_GETSTRUCT( submodel, submodel_specific );
	submodel->magic = RT_SUBMODEL_SPECIFIC_MAGIC;
	stp->st_specific = (genptr_t)submodel;

	MAT_COPY( submodel->subm2m, sip->root2leaf );
	bn_mat_inv( submodel->m2subm, sip->root2leaf );
	submodel->rtip = sub_rtip;

	/* Propagage submodel bounding box back upwards, rotated&scaled. */
	bn_rotate_bbox( stp->st_min, stp->st_max,
		submodel->subm2m,
		sub_rtip->mdl_min, sub_rtip->mdl_max );

	VSUB2( diam, stp->st_max, stp->st_min );
	VADD2SCALE( stp->st_center, stp->st_min, stp->st_max, 0.5 );
	VSCALE( radvec, diam, 0.5 );
	stp->st_aradius = stp->st_bradius = MAGNITUDE( radvec );

	if( RT_G_DEBUG & (DEBUG_DB|DEBUG_SOLIDS) )  {
		bu_log("rt_submodel_prep(%s): finished loading database %s\n",
			stp->st_dp->d_namep, sub_dbip->dbi_filename );
	}

	return(0);		/* OK */
}

/*
 *			R T _ S U B M O D E L _ P R I N T
 */
void
rt_submodel_print(register const struct soltab *stp)
{
	register const struct submodel_specific *submodel =
		(struct submodel_specific *)stp->st_specific;

	RT_CK_SUBMODEL_SPECIFIC(submodel);

	bn_mat_print("subm2m", submodel->subm2m);
	bn_mat_print("m2subm", submodel->m2subm);

	bu_log_indent_delta(4);
	bu_log("submodel->rtip=x%x\n", submodel->rtip);

	/* Loop through submodel's solid table printing them too. */
	RT_VISIT_ALL_SOLTABS_START( stp, submodel->rtip )  {
		rt_pr_soltab(stp);
	} RT_VISIT_ALL_SOLTABS_END
	bu_log_indent_delta(-4);
}


/*
 *			R T _ S U B M O D E L _ A _ M I S S
 */
int
rt_submodel_a_miss(struct application *ap)
{
	return 0;
}

struct submodel_gobetween {
	struct application	*up_ap;
	struct seg		*up_seghead;
	struct soltab		*up_stp;
	fastf_t			delta;		/* distance offset */
};

/*
 *			R T _ S U B M O D E L _ A _ H I T
 */
int
rt_submodel_a_hit(struct application *ap, struct partition *PartHeadp, struct seg *segHeadp)
{
	register struct partition *pp;
	struct application	*up_ap;
	struct soltab		*up_stp;
	struct region		*up_reg;
	struct submodel_gobetween *gp;
	struct submodel_specific *submodel;
	int			count = 0;

	RT_AP_CHECK(ap);
	RT_CK_PT_HD(PartHeadp);
	gp = (struct submodel_gobetween *)ap->a_uptr;
	up_ap = gp->up_ap;
	RT_AP_CHECK(up_ap);		/* original ap, in containing  */
	RT_CK_RTI(up_ap->a_rt_i);
	up_stp = gp->up_stp;
	RT_CK_SOLTAB(up_stp);
	submodel = (struct submodel_specific *)up_stp->st_specific;
	RT_CK_SUBMODEL_SPECIFIC(submodel);

	/* Take the first containing region */
	up_reg = (struct region *)BU_PTBL_GET(&(up_stp->st_regions), 0);
	RT_CK_REGION(up_reg);

	/* Need to tackle this honestly --
	 * build a totally new segment list from the partition list,
	 * with normals, uv, and curvature already computed,
	 * and converted back into up_model coordinate system,
	 * so the lazy-evaluation routines don't have to do anything.
	 * This is probably almost as cheap as the coordinate
	 * re-mapping in the special hook routines.
	 * Then the submodel can be stacked arbitrarily deep.
	 */
	for( BU_LIST_FOR( pp, partition, (struct bu_list *)PartHeadp ) )  {
		struct seg	*up_segp;
		struct seg	*inseg;
		struct seg	*outseg;

		RT_CK_PT(pp);
		inseg = pp->pt_inseg;
		outseg = pp->pt_outseg;
		RT_CK_SEG(inseg);
		RT_CK_SEG(outseg);

		/*
		 * Construct a completely new segment
		 *   build seg_in, seg_out, and seg_stp.
		 * Take seg_in and seg_out literally, to track surfno, etc.,
		 * then update specific values.
		 */
		RT_GET_SEG(up_segp, up_ap->a_resource );
		up_segp->seg_in = inseg->seg_in;		/* struct copy */
		up_segp->seg_out = outseg->seg_out;	/* struct copy */
		up_segp->seg_stp = up_stp;

		/* Adjust for scale difference */
		MAT4XSCALOR( up_segp->seg_in.hit_dist, submodel->subm2m, inseg->seg_in.hit_dist);
		up_segp->seg_in.hit_dist -= gp->delta;
		MAT4XSCALOR( up_segp->seg_out.hit_dist, submodel->subm2m, outseg->seg_out.hit_dist);
		up_segp->seg_out.hit_dist -= gp->delta;

		BU_ASSERT_DOUBLE(up_segp->seg_in.hit_dist, <=, up_segp->seg_out.hit_dist );

		/* Link to ray in upper model, not submodel */
		up_segp->seg_in.hit_rayp = &up_ap->a_ray;
		up_segp->seg_out.hit_rayp = &up_ap->a_ray;
		
		/* Pre-calculate what would have been "lazy evaluation" */
		VJOIN1( up_segp->seg_in.hit_point,  up_ap->a_ray.r_pt,
			up_segp->seg_in.hit_dist, up_ap->a_ray.r_dir );
		VJOIN1( up_segp->seg_out.hit_point,  up_ap->a_ray.r_pt,
			up_segp->seg_out.hit_dist, up_ap->a_ray.r_dir );

		/* RT_HIT_NORMAL */
		inseg->seg_stp->st_meth->ft_norm(
			&inseg->seg_in,
			inseg->seg_stp,
			inseg->seg_in.hit_rayp );
		outseg->seg_stp->st_meth->ft_norm(
			&outseg->seg_out,
			outseg->seg_stp,
			outseg->seg_out.hit_rayp );
/* XXX error checking */
	{ fastf_t cosine = fabs(VDOT( ap->a_ray.r_dir, inseg->seg_in.hit_normal ));
		if( cosine > 1.00001 )  {
			bu_log("rt_submodel_a_hit() cos=1+%g, %s surfno=%d\n",
				cosine-1,
				inseg->seg_stp->st_dp->d_namep,
				inseg->seg_in.hit_surfno );
			VPRINT("inseg->seg_in.hit_normal", inseg->seg_in.hit_normal);
		}
	}
		MAT3X3VEC( up_segp->seg_in.hit_normal, submodel->subm2m,
			inseg->seg_in.hit_normal );
/* XXX error checking */
	{ fastf_t cosine = fabs(VDOT( up_ap->a_ray.r_dir, up_segp->seg_in.hit_normal ));
		if( cosine > 1.00001 )  {
			bu_log("rt_submodel_a_hit() cos=1+%g, %s surfno=%d\n",
				cosine-1,
				inseg->seg_stp->st_dp->d_namep,
				inseg->seg_in.hit_surfno );
			VPRINT("up_segp->seg_in.hit_normal", up_segp->seg_in.hit_normal);
		}
	}
		MAT3X3VEC( up_segp->seg_out.hit_normal, submodel->subm2m,
			outseg->seg_out.hit_normal );

		/* RT_HIT_UV */
		{
			struct uvcoord	uv;
			RT_HIT_UVCOORD( ap, inseg->seg_stp, &inseg->seg_in, &uv );
			up_segp->seg_in.hit_vpriv[X] = uv.uv_u;
			up_segp->seg_in.hit_vpriv[Y] = uv.uv_v;
			if( uv.uv_du >= uv.uv_dv )
				up_segp->seg_in.hit_vpriv[Z] = uv.uv_du;
			else
				up_segp->seg_in.hit_vpriv[Z] = uv.uv_dv;

			RT_HIT_UVCOORD( ap, outseg->seg_stp, &outseg->seg_out, &uv );
			up_segp->seg_out.hit_vpriv[X] = uv.uv_u;
			up_segp->seg_out.hit_vpriv[Y] = uv.uv_v;
			if( uv.uv_du >= uv.uv_dv )
				up_segp->seg_out.hit_vpriv[Z] = uv.uv_du;
			else
				up_segp->seg_out.hit_vpriv[Z] = uv.uv_dv;
		}

		/* RT_HIT_CURVATURE */
		/* no place to stash curvature data! */

		/*
		 *  Here, the surfno reported upwards is the solid's
		 *  index (bit) number in the submodel.
		 *  This can be used as subscript to rti_Solids[]
		 *  to retrieve the identity of the solid that was hit.
		 */
		up_segp->seg_in.hit_surfno = inseg->seg_stp->st_bit;
		up_segp->seg_out.hit_surfno = outseg->seg_stp->st_bit;

		/* Put this segment on caller's shot routine seglist */
		BU_LIST_INSERT( &(gp->up_seghead->l), &(up_segp->l) );
		count++;
	}
	return count;
}

/*
 *  			R T _ S U B M O D E L _ S H O T
 *  
 *  Intersect a ray with a submodel.
 *  If an intersection occurs, a struct seg will be acquired
 *  and filled in.
 *  
 *  Returns -
 *  	0	MISS
 *	>0	HIT
 */
int
rt_submodel_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
{
	register struct submodel_specific *submodel =
		(struct submodel_specific *)stp->st_specific;
	struct application	sub_ap;
	struct submodel_gobetween	gb;
	vect_t			vdiff;
	int			code;
	struct bu_ptbl		*restbl;
	struct resource		*resp;
	int			cpu;

	RT_CK_SOLTAB(stp);
	RT_CK_RTI(ap->a_rt_i);
	RT_CK_SUBMODEL_SPECIFIC(submodel);

	gb.up_ap = ap;
	gb.up_seghead = seghead;
	gb.up_stp = stp;

	sub_ap = *ap;		/* struct copy */
	sub_ap.a_rt_i = submodel->rtip;
	sub_ap.a_hit = rt_submodel_a_hit;
	sub_ap.a_miss = rt_submodel_a_miss;
	sub_ap.a_uptr = (genptr_t)&gb;
	sub_ap.a_purpose = "rt_submodel_shot";

	/* Ensure even # of accurate hits, for building good partitions */
	if( sub_ap.a_onehit < 0 )  {
		if( sub_ap.a_onehit&1 )  sub_ap.a_onehit--;
	} else {
		if( sub_ap.a_onehit&1 )  sub_ap.a_onehit++;
	}

	/*
	 * Obtain the resource structure for this CPU.
	 * No need to semaphore because there is one pointer per cpu already.
	 */
	restbl = &submodel->rtip->rti_resources;	/* a ptbl */
	cpu = ap->a_resource->re_cpu;
	BU_ASSERT_LONG( cpu, <, BU_PTBL_END(restbl) );
	if( (resp = (struct resource *)BU_PTBL_GET(restbl, cpu)) == NULL )  {
		/* First ray for this cpu for this submodel, alloc up */
		BU_GETSTRUCT( resp, resource );
		BU_PTBL_SET(restbl, cpu, resp);
		rt_init_resource( resp, cpu, submodel->rtip );
	}
	RT_CK_RESOURCE(resp);
	sub_ap.a_resource = resp;

	/* shootray already computed a_ray.r_min & r_max for us */
	/* Construct the ray in submodel coords. */
	/* Do this in a repeatable way */
	/* Distances differ only by a scale factor of m[15] */
	MAT4X3PNT( sub_ap.a_ray.r_pt, submodel->m2subm, ap->a_ray.r_pt );
	MAT3X3VEC( sub_ap.a_ray.r_dir, submodel->m2subm, ap->a_ray.r_dir );

	/* NOTE: ap->a_ray.r_pt is not the same as rp->r_pt! */
	/* This changes the distances */
	VSUB2( vdiff, rp->r_pt, ap->a_ray.r_pt );
	gb.delta = VDOT( vdiff, ap->a_ray.r_dir );

	code = rt_shootray( &sub_ap );

	if( code <= 0 )  return 0;	/* MISS */

	/* All the real (sneaky) work is done in the hit routine */
	/* a_hit routine will have added the segs to seghead */

	return 1;		/* HIT */
}

#define RT_SUBMODEL_SEG_MISS(SEG)	(SEG).seg_stp=RT_SOLTAB_NULL

/*
 *			R T _ S U B M O D E L _ V S H O T
 *
 *  Vectorized version.
 */
void
rt_submodel_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		  	       /* Number of ray/object pairs */
                  	    
{
	rt_vstub( stp, rp, segp, n, ap );
}

/*
 *  			R T _ S U B M O D E L _ N O R M
 *  
 *  Given ONE ray distance, return the normal and entry/exit point.
 */
void
rt_submodel_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
{
	RT_CK_HIT(hitp);

	/* hitp->hit_point is already valid */
	/* hitp->hit_normal is already valid */
/* XXX error checking */
	{ fastf_t cosine = fabs(VDOT( rp->r_dir, hitp->hit_normal ));
		if( cosine > 1.00001 )  {
			bu_log("rt_submodel_norm() cos=1+%g, %s surfno=%d\n",
				cosine-1,
				stp->st_dp->d_namep,
				hitp->hit_surfno );
		}
	}
}

/*
 *			R T _ S U B M O D E L _ C U R V E
 *
 *  Return the curvature of the submodel.
 */
void
rt_submodel_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
{
 	cvp->crv_c1 = cvp->crv_c2 = 0;

	/* any tangent direction */
 	bn_vec_ortho( cvp->crv_pdir, hitp->hit_normal );

	/* XXX This will never be called */
	bu_log("rt_submodel_curve() not implemented, need extra fields in 'struct hit'\n");
}

/*
 *  			R T _ S U B M O D E L _ U V
 *  
 *  For a hit on the surface of an submodel, return the (u,v) coordinates
 *  of the hit point, 0 <= u,v <= 1.
 *  u = azimuth
 *  v = elevation
 */
void
rt_submodel_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
{
	RT_CK_HIT(hitp);

	uvp->uv_u = hitp->hit_vpriv[X];
	uvp->uv_v = hitp->hit_vpriv[Y];
	uvp->uv_du = uvp->uv_dv = hitp->hit_vpriv[Z];
}

/*
 *		R T _ S U B M O D E L _ F R E E
 */
void
rt_submodel_free(register struct soltab *stp)
{
	register struct submodel_specific *submodel =
		(struct submodel_specific *)stp->st_specific;
	struct resource	**rpp;
	struct rt_i	*rtip;

	RT_CK_SUBMODEL_SPECIFIC(submodel);
	rtip = submodel->rtip;
	RT_CK_RTI(rtip);

	/* Specificially free resource structures here */
	BU_CK_PTBL( &rtip->rti_resources );
	for( BU_PTBL_FOR( rpp, (struct resource **), &rtip->rti_resources ) )  {
		if( *rpp == NULL )  continue;
		if( *rpp == &rt_uniresource )  continue;
		RT_CK_RESOURCE(*rpp);
		/* Cleans but does not free the resource struct */
		rt_clean_resource(rtip, *rpp);
		bu_free( *rpp, "struct resource (submodel)" );
		/* Forget remembered ptr */
		*rpp = NULL;
	}
	/* Keep the ptbl allocated. */

	rt_free_rti( submodel->rtip );

	bu_free( (genptr_t)submodel, "submodel_specific" );
}

/*
 *			R T _ S U B M O D E L _ C L A S S
 */
int
rt_submodel_class(const struct soltab *stp, const fastf_t *min, const fastf_t *max, const struct bn_tol *tol)
{
	return RT_CLASSIFY_UNIMPLEMENTED;
}

struct goodies {
	struct db_i		*dbip;
	struct bu_list		*vheadp;
};

/*
 *			R T _ S U B M O D E L _ W I R E F R A M E _ L E A F
 *
 *  This routine must be prepared to run in parallel.
 *  This routine should be generally exported for other uses.
 */
HIDDEN union tree *rt_submodel_wireframe_leaf(struct db_tree_state *tsp, struct db_full_path *pathp, struct rt_db_internal *ip, genptr_t client_data)
{
	union tree	*curtree;
	struct goodies	*gp;

	RT_CK_TESS_TOL(tsp->ts_ttol);
	BN_CK_TOL(tsp->ts_tol);
	RT_CK_DB_INTERNAL(ip );
	RT_CK_RESOURCE(tsp->ts_resp);

	gp = (struct goodies *)tsp->ts_m;	/* hack */
	RT_CK_DBI(gp->dbip);

	/* NON-PARALLEL access to vlist pointed to by vheadp is not semaphored */
	if(bu_is_parallel()) bu_bomb("rt_submodel_wireframe_leaf() non-parallel code\n");

	if(RT_G_DEBUG&DEBUG_TREEWALK)  {
		char	*sofar = db_path_to_string(pathp);

		bu_log("rt_submodel_wireframe_leaf(%s) path=%s\n",
			ip->idb_meth->ft_name, sofar );
		bu_free((genptr_t)sofar, "path string");
	}

	if( ip->idb_meth->ft_plot(
	    gp->vheadp, ip,
	    tsp->ts_ttol, tsp->ts_tol ) < 0 )  {
		bu_log("rt_submodel_wireframe_leaf(%s): %s plot failure\n",
			ip->idb_meth->ft_name,
			DB_FULL_PATH_CUR_DIR(pathp)->d_namep );
		return(TREE_NULL);		/* ERROR */
	}

	/* Indicate success by returning something other than TREE_NULL */
	RT_GET_TREE( curtree, tsp->ts_resp);
	curtree->magic = RT_TREE_MAGIC;
	curtree->tr_op = OP_NOP;

	return( curtree );
}

/*
 *			R T _ S U B M O D E L _ P L O T
 *
 *  Not unlike mged/dodraw.c drawtrees()
 *
 *  Note:  The submodel will be drawn entirely in one color
 *  (for mged, typically this is red),
 *  because we can't return a vlblock, only one vlist,
 *  which by definition, is all one color.
 */
int
rt_submodel_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
	LOCAL struct rt_submodel_internal	*sip;
	struct db_tree_state	state;
	int			ret;
	char			*argv[2];
	struct goodies		good;

	RT_CK_DB_INTERNAL(ip);
	sip = (struct rt_submodel_internal *)ip->idb_ptr;
	RT_SUBMODEL_CK_MAGIC(sip);

	/*	BU_LIST_INIT( vhead ); */

	state = rt_initial_tree_state;	/* struct copy */
	state.ts_ttol = ttol;
	state.ts_tol = tol;
	MAT_COPY( state.ts_mat, sip->root2leaf );

	state.ts_m = (struct model **)&good;	/* hack -- passthrough to rt_submodel_wireframe_leaf() */
	good.vheadp = vhead;

	if( bu_vls_strlen( &sip->file ) != 0 )  {
		/* db_open will cache dbip's via bu_open_mapped_file() */
		if( (good.dbip = db_open( bu_vls_addr( &sip->file ), "r" )) == DBI_NULL )  {
			bu_log("rt_submodel_plot() db_open(%s) failure\n", bu_vls_addr( &sip->file ));
			return -1;
		}
		if( !db_is_directory_non_empty(good.dbip) )  {
			/* This is first open of this database, build directory */
			if( db_dirbuild( good.dbip ) < 0 )  {
				bu_log("rt_submodel_plot() db_dirbuild() failure\n");
				db_close(good.dbip);
				return -1;
			}
		}
	} else {
		/* Make another use of the current database */
		RT_CK_DBI(sip->dbip);
		good.dbip = (struct db_i *)sip->dbip;	/* un-const-cast */
		/* good.dbip->dbi_uses++; */	/* don't close it either */
	}

	argv[0] = bu_vls_addr( &sip->treetop );
	argv[1] = NULL;
	ret = db_walk_tree( good.dbip, 1, (const char **)argv,
		1,
		&state,
		0,			/* take all regions */
		NULL,			/* rt_submodel_wireframe_region_end */
		rt_submodel_wireframe_leaf,
		(genptr_t)NULL );

	if( ret < 0 )  bu_log("rt_submodel_plot() db_walk_tree(%s) failure\n", bu_vls_addr( &sip->treetop ));
	if( bu_vls_strlen( &sip->file ) != 0 )
		db_close(good.dbip);
	return ret;
}

/*
 *			R T _ S U B M O D E L _ T E S S
 *
 *  Returns -
 *	-1	failure
 *	 0	OK.  *r points to nmgregion that holds this tessellation.
 */
int
rt_submodel_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
	LOCAL struct rt_submodel_internal	*sip;

	RT_CK_DB_INTERNAL(ip);
	sip = (struct rt_submodel_internal *)ip->idb_ptr;
	RT_SUBMODEL_CK_MAGIC(sip);

	return(-1);
}

/*
 *			R T _ S U B M O D E L _ I M P O R T
 *
 *  Import an SUBMODEL from the database format to the internal format.
 *  Apply modeling transformations as well.
 */
int
rt_submodel_import(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
{
	LOCAL struct rt_submodel_internal	*sip;
	union record			*rp;
	struct bu_vls		str;

	BU_CK_EXTERNAL( ep );
	RT_CK_DBI(dbip);

	rp = (union record *)ep->ext_buf;
	/* Check record type */
	if( rp->u_id != DBID_STRSOL )  {
		bu_log("rt_submodel_import: defective strsol record\n");
		return(-1);
	}

	RT_CK_DB_INTERNAL( ip );
	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_SUBMODEL;
	ip->idb_meth = &rt_functab[ID_SUBMODEL];
	ip->idb_ptr = bu_malloc( sizeof(struct rt_submodel_internal), "rt_submodel_internal");
	sip = (struct rt_submodel_internal *)ip->idb_ptr;
	sip->magic = RT_SUBMODEL_INTERNAL_MAGIC;
	sip->dbip = dbip;

	MAT_COPY( sip->root2leaf, mat );

	bu_vls_init( &str );
	bu_vls_strcpy( &str, rp->ss.ss_args );
#if 0
bu_log("rt_submodel_import: '%s'\n", rp->ss.ss_args);
#endif
	if( bu_struct_parse( &str, rt_submodel_parse, (char *)sip ) < 0 )  {
		bu_vls_free( &str );
fail:
		bu_free( (char *)sip , "rt_submodel_import: sip" );
		ip->idb_type = ID_NULL;
		ip->idb_ptr = (genptr_t)NULL;
		return -2;
	}
	bu_vls_free( &str );

	/* Check for reasonable values */
	if( bu_vls_strlen( &sip->treetop ) == 0 )  {
		bu_log("rt_submodel_import() treetop= must be specified\n");
		goto fail;
	}
#if 0
bu_log("import: file='%s', treetop='%s', meth=%d\n", bu_vls_addr( &sip->file ), bu_vls_addr( &sip->treetop ), sip->meth);
bn_mat_print("root2leaf", sip->root2leaf );
#endif

	return(0);			/* OK */
}

/*
 *			R T _ S U B M O D E L _ E X P O R T
 *
 *  The name is added by the caller, in the usual place.
 */
int
rt_submodel_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
{
	struct rt_submodel_internal	*sip;
	union record		*rec;
	struct bu_vls		str;

	RT_CK_DB_INTERNAL(ip);
	if( ip->idb_type != ID_SUBMODEL )  return(-1);
	sip = (struct rt_submodel_internal *)ip->idb_ptr;
	RT_SUBMODEL_CK_MAGIC(sip);
#if 0
bu_log("export: file='%s', treetop='%s', meth=%d\n", bu_vls_addr( &sip->file ), bu_vls_addr( &sip->treetop ), sip->meth);
#endif

	/* Ignores scale factor */
	BU_ASSERT( local2mm == 1.0 );

	BU_CK_EXTERNAL(ep);
	ep->ext_nbytes = sizeof(union record)*DB_SS_NGRAN;
	ep->ext_buf = bu_calloc( 1, ep->ext_nbytes, "submodel external");
	rec = (union record *)ep->ext_buf;

	bu_vls_init( &str );
	bu_vls_struct_print( &str, rt_submodel_parse, (char *)sip );

	rec->ss.ss_id = DBID_STRSOL;
	strncpy( rec->ss.ss_keyword, "submodel", NAMESIZE-1 );
	strncpy( rec->ss.ss_args, bu_vls_addr(&str), DB_SS_LEN-1 );
	bu_vls_free( &str );
#if 0
bu_log("rt_submodel_export: '%s'\n", rec->ss.ss_args);
#endif

	return(0);
}


/*
 *			R T _ S U B M O D E L _ I M P O R T 5
 *
 *  Import an SUBMODEL from the database format to the internal format.
 *  Apply modeling transformations as well.
 */
int
rt_submodel_import5(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
{
	LOCAL struct rt_submodel_internal	*sip;
	struct bu_vls		str;

	BU_CK_EXTERNAL( ep );
	RT_CK_DBI(dbip);

	RT_CK_DB_INTERNAL( ip );
	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_SUBMODEL;
	ip->idb_meth = &rt_functab[ID_SUBMODEL];
	ip->idb_ptr = bu_malloc( sizeof(struct rt_submodel_internal), "rt_submodel_internal");
	sip = (struct rt_submodel_internal *)ip->idb_ptr;
	sip->magic = RT_SUBMODEL_INTERNAL_MAGIC;
	sip->dbip = dbip;

	MAT_COPY( sip->root2leaf, mat );

	bu_vls_init( &str );
	bu_vls_strncpy( &str, ep->ext_buf, ep->ext_nbytes );
#if 0
bu_log("rt_submodel_import: '%s'\n", rp->ss.ss_args);
#endif
	if( bu_struct_parse( &str, rt_submodel_parse, (char *)sip ) < 0 )  {
		bu_vls_free( &str );
fail:
		bu_free( (char *)sip , "rt_submodel_import: sip" );
		ip->idb_type = ID_NULL;
		ip->idb_ptr = (genptr_t)NULL;
		return -2;
	}
	bu_vls_free( &str );

	/* Check for reasonable values */
	if( bu_vls_strlen( &sip->treetop ) == 0 )  {
		bu_log("rt_submodel_import() treetop= must be specified\n");
		goto fail;
	}
#if 0
bu_log("import: file='%s', treetop='%s', meth=%d\n", bu_vls_addr( &sip->file ), bu_vls_addr( &sip->treetop ), sip->meth);
bn_mat_print("root2leaf", sip->root2leaf );
#endif

	return(0);			/* OK */
}

/*
 *			R T _ S U B M O D E L _ E X P O R T 5
 *
 *  The name is added by the caller, in the usual place.
 */
int
rt_submodel_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
{
	struct rt_submodel_internal	*sip;
	struct bu_vls		str;

	RT_CK_DB_INTERNAL(ip);
	if( ip->idb_type != ID_SUBMODEL )  return(-1);
	sip = (struct rt_submodel_internal *)ip->idb_ptr;
	RT_SUBMODEL_CK_MAGIC(sip);
#if 0
bu_log("export: file='%s', treetop='%s', meth=%d\n", bu_vls_addr( &sip->file ), bu_vls_addr( &sip->treetop ), sip->meth);
#endif

	/* Ignores scale factor */
	BU_ASSERT( local2mm == 1.0 );
	BU_CK_EXTERNAL(ep);

	bu_vls_init( &str );
	bu_vls_struct_print( &str, rt_submodel_parse, (char *)sip );
	ep->ext_nbytes = bu_vls_strlen( &str );
	ep->ext_buf = bu_calloc( 1, ep->ext_nbytes, "submodel external");

	strncpy(ep->ext_buf, bu_vls_addr(&str), ep->ext_nbytes);
	bu_vls_free( &str );
#if 0
bu_log("rt_submodel_export: '%s'\n", rec->ss.ss_args);
#endif

	return(0);
}

/*
 *			R T _ S U B M O D E L _ D E S C R I B E
 *
 *  Make human-readable formatted presentation of this solid.
 *  First line describes type of solid.
 *  Additional lines are indented one tab, and give parameter values.
 */
int
rt_submodel_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
{
	register struct rt_submodel_internal	*sip =
		(struct rt_submodel_internal *)ip->idb_ptr;

	RT_SUBMODEL_CK_MAGIC(sip);
	bu_vls_strcat( str, "instanced submodel (SUBMODEL)\n");

	bu_vls_printf(str, "\tfile='%s', treetop='%s', meth=%d\n",
		bu_vls_addr( &sip->file ),
		bu_vls_addr( &sip->treetop ),
		sip->meth );

	return(0);
}

/*
 *			R T _ S U B M O D E L _ I F R E E
 *
 *  Free the storage associated with the rt_db_internal version of this solid.
 */
void
rt_submodel_ifree(struct rt_db_internal *ip)
{
	register struct rt_submodel_internal	*sip;

	RT_CK_DB_INTERNAL(ip);
	sip = (struct rt_submodel_internal *)ip->idb_ptr;
	RT_SUBMODEL_CK_MAGIC(sip);
	sip->magic = 0;			/* sanity */

	bu_free( (genptr_t)sip, "submodel ifree" );
	ip->idb_ptr = GENPTR_NULL;	/* sanity */
}
@


1.73
log
@change conf.h to a wrapped config.h
@
text
@d30 1
a30 1
static const char RCSsubmodel[] = "@@(#)$Header: /cvs/brlcad/librt/g_submodel.c,v 1.72 2004/04/05 08:48:57 morrison Exp $ (BRL)";
@


1.72
log
@merge of ansi-6-0-branch into HEAD
@
text
@d30 1
a30 1
static const char RCSsubmodel[] = "@@(#)$Header$ (BRL)";
d33 5
a37 1
#include "conf.h"
@


1.71
log
@update copyright to include span through 2003
@
text
@d30 1
a30 1
static const char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.70 2003/10/17 20:52:03 jra Exp $ (BRL)";
d81 1
a81 4
rt_submodel_prep( stp, ip, rtip )
struct soltab		*stp;
struct rt_db_internal	*ip;
struct rt_i		*rtip;
d248 1
a248 2
rt_submodel_print( stp )
register const struct soltab *stp;
d273 1
a273 2
rt_submodel_a_miss( ap )
struct application	*ap;
d289 1
a289 4
rt_submodel_a_hit( ap, PartHeadp, segHeadp )
struct application	*ap;
struct partition	*PartHeadp;
struct seg		*segHeadp;
d448 1
a448 5
rt_submodel_shot( stp, rp, ap, seghead )
struct soltab		*stp;
register struct xray	*rp;
struct application	*ap;
struct seg		*seghead;
d528 6
a533 6
rt_submodel_vshot( stp, rp, segp, n, ap )
struct soltab	       *stp[]; /* An array of solid pointers */
struct xray		*rp[]; /* An array of ray pointers */
struct  seg            segp[]; /* array of segs (results returned) */
int		  	    n; /* Number of ray/object pairs */
struct application	*ap;
d544 1
a544 4
rt_submodel_norm( hitp, stp, rp )
register struct hit	*hitp;
struct soltab		*stp;
register struct xray	*rp;
d567 1
a567 4
rt_submodel_curve( cvp, hitp, stp )
register struct curvature *cvp;
register struct hit	*hitp;
struct soltab		*stp;
d587 1
a587 5
rt_submodel_uv( ap, stp, hitp, uvp )
struct application	*ap;
struct soltab		*stp;
register struct hit	*hitp;
register struct uvcoord	*uvp;
d600 1
a600 2
rt_submodel_free( stp )
register struct soltab *stp;
d634 1
a634 4
rt_submodel_class( stp, min, max, tol )
const struct soltab    *stp;
const vect_t		min, max;
const struct bn_tol    *tol;
d650 1
a650 5
HIDDEN union tree *rt_submodel_wireframe_leaf( tsp, pathp, ip, client_data )
struct db_tree_state	*tsp;
struct db_full_path	*pathp;
struct rt_db_internal	*ip;
genptr_t		client_data;
d702 1
a702 5
rt_submodel_plot( vhead, ip, ttol, tol )
struct bu_list		*vhead;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol	*tol;
d769 1
a769 6
rt_submodel_tess( r, m, ip, ttol, tol )
struct nmgregion	**r;
struct model		*m;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol	*tol;
d787 1
a787 5
rt_submodel_import( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
d848 1
a848 5
rt_submodel_export( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d892 1
a892 5
rt_submodel_import5( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
d945 1
a945 5
rt_submodel_export5( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d984 1
a984 5
rt_submodel_describe( str, ip, verbose, mm2local )
struct bu_vls		*str;
const struct rt_db_internal	*ip;
int			verbose;
double			mm2local;
d1006 1
a1006 2
rt_submodel_ifree( ip )
struct rt_db_internal	*ip;
@


1.70
log
@rt_submodel_import5() was using bu_vls_strcpy() to copy a bu_external buffer.
Must use bu_vls_strncpy() since there is no NULL termination.
Also commented out "BU_LIST_INIT( vhead )" in rt_submodel_plot() so it doesn't
blow away everything prior.
@
text
@d26 1
a26 1
 *	This software is Copyright (C) 2000 by the United States Army
d30 1
a30 1
static const char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.69 2002/08/20 17:08:01 jra Exp $ (BRL)";
@


1.69
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d30 1
a30 1
static const char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.67 2002/01/10 18:12:40 butler Exp $ (BRL)";
d748 1
a748 1
	BU_LIST_INIT( vhead );
d963 1
a963 1
	bu_vls_strcpy( &str, ep->ext_buf );
@


1.69.4.1
log
@sync to HEAD...
@
text
@d26 1
a26 1
 *	This software is Copyright (C) 2000-2004 by the United States Army
d30 1
a30 1
static const char RCSsubmodel[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/g_submodel.c,v 1.71 2004/02/02 17:39:21 morrison Exp $ (BRL)";
d748 1
a748 1
	/*	BU_LIST_INIT( vhead ); */
d963 1
a963 1
	bu_vls_strncpy( &str, ep->ext_buf, ep->ext_nbytes );
@


1.69.10.1
log
@updates from HEAD, part 1
@
text
@d30 1
a30 1
static const char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.70 2003/10/17 20:52:03 jra Exp $ (BRL)";
d748 1
a748 1
	/*	BU_LIST_INIT( vhead ); */
d963 1
a963 1
	bu_vls_strncpy( &str, ep->ext_buf, ep->ext_nbytes );
@


1.69.10.2
log
@merge from HEAD
@
text
@d26 1
a26 1
 *	This software is Copyright (C) 2000-2004 by the United States Army
d30 1
a30 1
static const char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.71 2004/02/02 17:39:21 morrison Exp $ (BRL)";
@


1.69.10.3
log
@merge from head
@
text
@d30 1
a30 1
static const char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.69.10.2 2004/02/12 18:37:42 erikg Exp $ (BRL)";
@


1.69.2.1
log
@Initial ANSIfication
@
text
@d30 1
a30 1
static const char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.69 2002/08/20 17:08:01 jra Exp $ (BRL)";
d81 4
a84 1
rt_submodel_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
d251 2
a252 1
rt_submodel_print(register const struct soltab *stp)
d277 2
a278 1
rt_submodel_a_miss(struct application *ap)
d294 4
a297 1
rt_submodel_a_hit(struct application *ap, struct partition *PartHeadp, struct seg *segHeadp)
d456 5
a460 1
rt_submodel_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
d540 6
a545 6
rt_submodel_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		  	       /* Number of ray/object pairs */
                  	    
d556 4
a559 1
rt_submodel_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
d582 4
a585 1
rt_submodel_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
d605 5
a609 1
rt_submodel_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
d622 2
a623 1
rt_submodel_free(register struct soltab *stp)
d657 4
a660 1
rt_submodel_class(const struct soltab *stp, const fastf_t *min, const fastf_t *max, const struct bn_tol *tol)
d676 5
a680 1
HIDDEN union tree *rt_submodel_wireframe_leaf(struct db_tree_state *tsp, struct db_full_path *pathp, struct rt_db_internal *ip, genptr_t client_data)
d732 5
a736 1
rt_submodel_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d803 6
a808 1
rt_submodel_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d826 5
a830 1
rt_submodel_import(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d891 5
a895 1
rt_submodel_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d939 5
a943 1
rt_submodel_import5(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d996 5
a1000 1
rt_submodel_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d1039 5
a1043 1
rt_submodel_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
d1065 2
a1066 1
rt_submodel_ifree(struct rt_db_internal *ip)
@


1.69.2.2
log
@sync branch with HEAD
@
text
@d26 1
a26 1
 *	This software is Copyright (C) 2000-2004 by the United States Army
d30 1
a30 1
static const char RCSsubmodel[] = "@@(#)$Header$ (BRL)";
d714 1
a714 1
	/*	BU_LIST_INIT( vhead ); */
d912 1
a912 1
	bu_vls_strncpy( &str, ep->ext_buf, ep->ext_nbytes );
@


1.68
log
@Converted from K&R to ANSI C - RFH
@
text
@d81 4
a84 1
rt_submodel_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
d251 2
a252 1
rt_submodel_print(register const struct soltab *stp)
d277 2
a278 1
rt_submodel_a_miss(struct application *ap)
d294 4
a297 1
rt_submodel_a_hit(struct application *ap, struct partition *PartHeadp, struct seg *segHeadp)
d456 5
a460 1
rt_submodel_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
d540 6
a545 6
rt_submodel_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		  	       /* Number of ray/object pairs */
                  	    
d556 4
a559 1
rt_submodel_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
d582 4
a585 1
rt_submodel_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
d605 5
a609 1
rt_submodel_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
d622 2
a623 1
rt_submodel_free(register struct soltab *stp)
d657 4
a660 1
rt_submodel_class(const struct soltab *stp, const fastf_t *min, const fastf_t *max, const struct bn_tol *tol)
d676 5
a680 1
HIDDEN union tree *rt_submodel_wireframe_leaf(struct db_tree_state *tsp, struct db_full_path *pathp, struct rt_db_internal *ip, genptr_t client_data)
d732 5
a736 1
rt_submodel_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d803 6
a808 1
rt_submodel_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d826 5
a830 1
rt_submodel_import(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d891 5
a895 1
rt_submodel_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d939 5
a943 1
rt_submodel_import5(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d996 5
a1000 1
rt_submodel_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d1039 5
a1043 1
rt_submodel_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
d1065 2
a1066 1
rt_submodel_ifree(struct rt_db_internal *ip)
@


1.67
log
@Changed word "solids" to indicate "prims" or primitives"
@
text
@d30 1
a30 1
static const char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.66 2001/10/12 15:23:20 bparker Exp $ (BRL)";
d81 1
a81 4
rt_submodel_prep( stp, ip, rtip )
struct soltab		*stp;
struct rt_db_internal	*ip;
struct rt_i		*rtip;
d248 1
a248 2
rt_submodel_print( stp )
register const struct soltab *stp;
d273 1
a273 2
rt_submodel_a_miss( ap )
struct application	*ap;
d289 1
a289 4
rt_submodel_a_hit( ap, PartHeadp, segHeadp )
struct application	*ap;
struct partition	*PartHeadp;
struct seg		*segHeadp;
d448 1
a448 5
rt_submodel_shot( stp, rp, ap, seghead )
struct soltab		*stp;
register struct xray	*rp;
struct application	*ap;
struct seg		*seghead;
d528 6
a533 6
rt_submodel_vshot( stp, rp, segp, n, ap )
struct soltab	       *stp[]; /* An array of solid pointers */
struct xray		*rp[]; /* An array of ray pointers */
struct  seg            segp[]; /* array of segs (results returned) */
int		  	    n; /* Number of ray/object pairs */
struct application	*ap;
d544 1
a544 4
rt_submodel_norm( hitp, stp, rp )
register struct hit	*hitp;
struct soltab		*stp;
register struct xray	*rp;
d567 1
a567 4
rt_submodel_curve( cvp, hitp, stp )
register struct curvature *cvp;
register struct hit	*hitp;
struct soltab		*stp;
d587 1
a587 5
rt_submodel_uv( ap, stp, hitp, uvp )
struct application	*ap;
struct soltab		*stp;
register struct hit	*hitp;
register struct uvcoord	*uvp;
d600 1
a600 2
rt_submodel_free( stp )
register struct soltab *stp;
d634 1
a634 4
rt_submodel_class( stp, min, max, tol )
const struct soltab    *stp;
const vect_t		min, max;
const struct bn_tol    *tol;
d650 1
a650 5
HIDDEN union tree *rt_submodel_wireframe_leaf( tsp, pathp, ip, client_data )
struct db_tree_state	*tsp;
struct db_full_path	*pathp;
struct rt_db_internal	*ip;
genptr_t		client_data;
d702 1
a702 5
rt_submodel_plot( vhead, ip, ttol, tol )
struct bu_list		*vhead;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol	*tol;
d769 1
a769 6
rt_submodel_tess( r, m, ip, ttol, tol )
struct nmgregion	**r;
struct model		*m;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol	*tol;
d787 1
a787 5
rt_submodel_import( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
d848 1
a848 5
rt_submodel_export( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d892 1
a892 5
rt_submodel_import5( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
d945 1
a945 5
rt_submodel_export5( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d984 1
a984 5
rt_submodel_describe( str, ip, verbose, mm2local )
struct bu_vls		*str;
const struct rt_db_internal	*ip;
int			verbose;
double			mm2local;
d1006 1
a1006 2
rt_submodel_ifree( ip )
struct rt_db_internal	*ip;
@


1.66
log
@*- fixed bug in rt_submodel_export5() that
   was causing a segmentation fault
@
text
@d30 1
a30 1
static const char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.65 2001/10/02 19:24:30 jra Exp $ (BRL)";
d201 1
a201 1
		bu_log("rt_submodel_prep(%s): %s No solids found\n",
@


1.65
log
@Routines were not setting idb_major_type in the internal structure
@
text
@d30 1
a30 1
static const char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.64 2001/05/17 20:05:25 morrison Exp $ (BRL)";
d1022 1
a1022 1
	strcpy( ep->ext_buf, bu_vls_addr(&str) );
@


1.64
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d30 1
a30 1
static const char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.63 2001/04/20 22:29:47 morrison Exp $ (BRL)";
d847 1
d952 1
@


1.63
log
@CONST to const
@
text
@d30 1
a30 1
static const char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.62 2001/04/02 21:38:09 morrison Exp $ (BRL)";
d143 1
a143 1
			if( rt_g.debug & (DEBUG_DB|DEBUG_SOLIDS) )  {
d161 1
a161 1
	if( rt_g.debug & (DEBUG_DB|DEBUG_SOLIDS) )  {
d218 1
a218 1
if(rt_g.debug) rt_pr_cut_info( sub_rtip, stp->st_name );
d239 1
a239 1
	if( rt_g.debug & (DEBUG_DB|DEBUG_SOLIDS) )  {
d696 1
a696 1
	if(rt_g.debug&DEBUG_TREEWALK)  {
@


1.62
log
@Deprecated bn_mat_copy() for new performance version of MAT_COPY() macro in h/vmath.h.
@
text
@d30 1
a30 1
static const char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.61 2001/03/21 22:37:41 jra Exp $ (BRL)";
d47 1
a47 1
CONST struct bu_structparse rt_submodel_parse[] = {
d192 1
a192 1
	if( rt_gettrees( sub_rtip, 1, (CONST char **)argv, 1 ) < 0 )  {
d252 1
a252 1
register CONST struct soltab *stp;
d254 1
a254 1
	register CONST struct submodel_specific *submodel =
d658 3
a660 3
CONST struct soltab    *stp;
CONST vect_t		min, max;
CONST struct bn_tol    *tol;
d735 2
a736 2
CONST struct rt_tess_tol *ttol;
CONST struct bn_tol	*tol;
d775 1
a775 1
		good.dbip = (struct db_i *)sip->dbip;	/* un-CONST-cast */
d781 1
a781 1
	ret = db_walk_tree( good.dbip, 1, (CONST char **)argv,
d807 2
a808 2
CONST struct rt_tess_tol *ttol;
CONST struct bn_tol	*tol;
d828 3
a830 3
CONST struct bu_external	*ep;
register CONST mat_t		mat;
CONST struct db_i		*dbip;
d892 1
a892 1
CONST struct rt_db_internal	*ip;
d894 1
a894 1
CONST struct db_i		*dbip;
d940 3
a942 3
CONST struct bu_external	*ep;
register CONST mat_t		mat;
CONST struct db_i		*dbip;
d996 1
a996 1
CONST struct rt_db_internal	*ip;
d998 1
a998 1
CONST struct db_i		*dbip;
d1039 1
a1039 1
CONST struct rt_db_internal	*ip;
@


1.61
log
@Submodel now has unlimited length names
@
text
@d30 1
a30 1
static const char RCSsubmodel[] = "@@(#)$Header: /d/CVS/brlcad/librt/g_submodel.c,v 1.60 2000/11/02 02:09:43 mike Exp $ (BRL)";
d225 1
a225 1
	bn_mat_copy( submodel->subm2m, sip->root2leaf );
d753 1
a753 1
	bn_mat_copy( state.ts_mat, sip->root2leaf );
d854 1
a854 1
	bn_mat_copy( sip->root2leaf, mat );
d958 1
a958 1
	bn_mat_copy( sip->root2leaf, mat );
@


1.60
log
@
Changed calls to db_scan(...db_diradd...) to db_dirbuild(),
which can handle both v4 and v5 databases.
@
text
@d30 1
a30 1
static const char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.59 2000/09/21 05:30:39 mike Exp $ (BRL)";
d48 2
a49 2
	{"%s",	128, "file",	bu_offsetofarray(struct rt_submodel_internal, file), BU_STRUCTPARSE_FUNC_NULL },
	{"%s",	128, "treetop", bu_offsetofarray(struct rt_submodel_internal, treetop), BU_STRUCTPARSE_FUNC_NULL },
a53 2


d105 1
a105 1
	if( sip->file[0] == '\0' )  {
d110 1
a110 1
		if( (sub_dbip = db_open( sip->file, "r" )) == DBI_NULL )
d136 1
a136 1
		if( ttp && strcmp( ttp, sip->treetop ) == 0 )  {
d157 1
a157 1
	sub_rtip->rti_treetop = bu_strdup(sip->treetop);
d190 1
a190 1
	argv[0] = sip->treetop;
d202 1
a202 1
			stp->st_dp->d_namep, sip->file );
d758 1
a758 1
	if( sip->file[0] != '\0' )  {
d760 2
a761 2
		if( (good.dbip = db_open( sip->file, "r" )) == DBI_NULL )  {
			bu_log("rt_submodel_plot() db_open(%s) failure\n", sip->file);
d779 1
a779 1
	argv[0] = sip->treetop;
d789 2
a790 2
	if( ret < 0 )  bu_log("rt_submodel_plot() db_walk_tree(%s) failure\n", sip->treetop);
	if( sip->file[0] != '\0' )
d872 1
a872 1
	if( sip->treetop[0] == '\0' )  {
d877 1
a877 1
bu_log("import: file='%s', treetop='%s', meth=%d\n", sip->file, sip->treetop, sip->meth);
d905 1
a905 1
bu_log("export: file='%s', treetop='%s', meth=%d\n", sip->file, sip->treetop, sip->meth);
d976 1
a976 1
	if( sip->treetop[0] == '\0' )  {
d981 1
a981 1
bu_log("import: file='%s', treetop='%s', meth=%d\n", sip->file, sip->treetop, sip->meth);
d1008 1
a1008 1
bu_log("export: file='%s', treetop='%s', meth=%d\n", sip->file, sip->treetop, sip->meth);
d1050 2
a1051 2
		sip->file,
		sip->treetop,
@


1.59
log
@
A less convoluted way of doing the same thing.
@
text
@d30 1
a30 1
static const char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.58 2000/09/21 04:54:05 mike Exp $ (BRL)";
d120 1
a120 1
			if( db_scan( sub_dbip, (int (*)())db_diradd, 1, NULL ) < 0 )  {
d768 2
a769 2
			if( db_scan( good.dbip, (int (*)())db_diradd, 1, NULL ) < 0 )  {
				bu_log("rt_submodel_plot() db_scan() failure\n");
@


1.58
log
@
For parallel tree-walking of submodels, we actually have to _allocate_
a new resource structure.
@
text
@d30 1
a30 1
static const char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.57 2000/09/21 03:59:50 mike Exp $ (BRL)";
d92 1
a92 1
	struct resource			**respp;
d175 3
a177 3
	respp = (struct resource **)&BU_PTBL_GET(&sub_rtip->rti_resources, 0);
	BU_GETSTRUCT( *respp, resource );
	rt_init_resource( *respp, 0, sub_rtip );
@


1.57
log
@
Added error checking, until the error can be found.
@
text
@d30 1
a30 1
static const char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.56 2000/09/11 19:57:29 mike Exp $ (BRL)";
d92 1
a92 1
	struct resource			*resp;
d171 1
d175 3
a177 2
	resp = (struct resource *)BU_PTBL_GET(&sub_rtip->rti_resources, 0);
	rt_init_resource( resp, 0, sub_rtip );
@


1.56
log
@
Removed obsolete surfno check
@
text
@d30 1
a30 1
static const char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.55 2000/09/09 05:32:29 mike Exp $ (BRL)";
d380 10
d392 10
d565 9
@


1.55
log
@
Changed to assign surfno values on submodel hits.
@
text
@d30 1
a30 1
static const char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.54 2000/09/08 05:54:42 mike Exp $ (BRL)";
a542 2
	if( hitp->hit_surfno != 17 )  bu_bomb("rt_submodel surfno mis-match\n");

a582 2

	if( hitp->hit_surfno != 17 )  bu_bomb("rt_submodel surfno mis-match\n");
@


1.54
log
@
Modified tree routines to take resource pointer.
@
text
@d30 1
a30 1
static const char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.53 2000/09/07 01:06:43 mike Exp $ (BRL)";
d408 5
a412 2
		/* Leave behind a distinctive surfno marker
		 * in case app is using it for something.
d414 2
a415 2
		up_segp->seg_in.hit_surfno = 17;
		up_segp->seg_out.hit_surfno = 17;
@


1.53
log
@
resource handling
@
text
@d30 1
a30 1
static const char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.52 2000/08/21 02:02:31 butler Exp $ (BRL)";
d171 1
d175 1
a175 1
	rt_init_resource( resp, 0 );
d477 1
a477 5
	if( !( cpu < BU_PTBL_END(restbl) ) )  {
		bu_log("ptbl_end=%d, ptbl_blen=%d, cpu=%d\n",
			BU_PTBL_END(restbl), restbl->blen, cpu );
	}
	BU_ASSERT( cpu < BU_PTBL_END(restbl) );
d482 1
a482 1
		rt_init_resource( resp, cpu );
d599 20
d660 1
d686 1
a686 1
	BU_GETUNION( curtree, tree );
@


1.52
log
@Massive compilation warnings eliminated
@
text
@d30 1
a30 1
static const char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.51 2000/07/10 23:01:35 mike Exp $ (BRL)";
d92 1
d168 8
d484 1
a484 2
		/* XXX Should be a BU_PTBL_SET() */
		BU_PTBL_GET(restbl, cpu) = (long *)resp;
@


1.51
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d30 1
a30 1
static const char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.50 2000/06/30 20:25:50 jra Exp $ (BRL)";
d37 1
a91 2
	struct soltab			*sub_stp;
	struct region			*rp;
a294 1
	fastf_t			delta;
a430 2
	register struct seg *segp;
	CONST struct bn_tol	*tol = &ap->a_rt_i->rti_tol;
a551 3
	register struct submodel_specific *submodel =
		(struct submodel_specific *)stp->st_specific;

a685 1
	struct db_i		*dbip;
@


1.50
log
@Added database v5 support
@
text
@d30 1
a30 1
static char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.49 2000/06/30 15:38:04 mike Exp $ (BRL)";
@


1.49
log
@
export methods should not init the external structure, just check them.
@
text
@d30 1
a30 1
static char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.48 2000/06/30 15:31:15 mike Exp $ (BRL)";
d876 99
@


1.48
log
@
The import/export and import5/export5 methods must NOT
re-initialize their rt_db_internal* pointer, they should just check it.
@
text
@d30 1
a30 1
static char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.47 2000/06/29 18:31:33 mike Exp $ (BRL)";
d865 1
a865 1
	BU_INIT_EXTERNAL(ep);
@


1.47
log
@
Updated for new calling sequence to db_walktree leaf()
@
text
@d30 1
a30 1
static char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.46 2000/06/29 14:36:33 mike Exp $ (BRL)";
d800 1
a800 1
	RT_INIT_DB_INTERNAL( ip );
@


1.46
log
@
rt_db_free_internal
@
text
@d30 1
a30 1
static char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.45 2000/04/12 02:34:36 mike Exp $ (BRL)";
d630 1
a630 1
HIDDEN union tree *rt_submodel_wireframe_leaf( tsp, pathp, ep, id, client_data )
d633 1
a633 2
struct bu_external	*ep;
int			id;
a635 1
	struct rt_db_internal	intern;
d641 1
d653 1
a653 1
			rt_functab[id].ft_name, sofar );
d657 2
a658 14
    	RT_INIT_DB_INTERNAL(&intern);
	if( rt_functab[id].ft_import( &intern, ep, tsp->ts_mat, gp->dbip ) < 0 )  {
		bu_log("rt_submodel_wireframe_leaf(%s): %s solid import failure\n",
			rt_functab[id].ft_name,
			DB_FULL_PATH_CUR_DIR(pathp)->d_namep );

		rt_db_free_internal( &intern );
		return(TREE_NULL);		/* ERROR */
	}
	RT_CK_DB_INTERNAL( &intern );

	if( rt_functab[id].ft_plot(
	    gp->vheadp,
	    &intern,
d661 1
a661 1
			rt_functab[id].ft_name,
a662 2

		rt_db_free_internal( &intern );
a664 2

	rt_db_free_internal( &intern );
@


1.45
log
@
NT port, non-compat4
@
text
@d30 1
a30 1
static char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.44 2000/02/14 20:16:46 mike Exp $ (BRL)";
d664 1
a664 1
		if( intern.idb_ptr )  intern.idb_meth->ft_ifree( &intern );
d677 1
a677 1
		rt_functab[id].ft_ifree( &intern );
d681 1
a681 1
	intern.idb_meth->ft_ifree( &intern );
@


1.44
log
@
Improved error recovery
@
text
@d30 1
a30 1
static char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.43 2000/02/14 19:28:35 mike Exp $ (BRL)";
d562 1
a562 1
 	vec_ortho( cvp->crv_pdir, hitp->hit_normal );
@


1.43
log
@
Another MAT4X3VEC which should have been MAT3X3VEC
@
text
@d30 1
a30 1
static char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.42 2000/02/12 02:07:17 mike Exp $ (BRL)";
d185 3
a187 1
		rt_free_rti( sub_rtip );
d194 3
a196 1
		rt_free_rti( sub_rtip );
@


1.42
log
@
Took out all the debugging prints.
@
text
@d30 1
a30 1
static char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.41 2000/02/12 01:59:10 mike Exp $ (BRL)";
d487 1
a487 1
	MAT4X3VEC( sub_ap.a_ray.r_dir, submodel->m2subm, ap->a_ray.r_dir );
@


1.41
log
@
This version has mongo normal debugging.  I'm committing it
in case I need the code back later.
It also fixes a normal scaling bug.
@
text
@d30 1
a30 1
static char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.40 2000/02/10 05:15:26 mike Exp $ (BRL)";
a119 1
bu_log("rt_submodel_prep(%s) doing db_scan\n", stp->st_name);
a126 1
if(sub_dbip == rtip->rti_dbip) bu_log("rt_submodel_prep(%s): re-attached to parent's database %s\n", stp->st_name, sub_dbip->dbi_filename);
a162 2
bu_log("rt_submodel_prep(%s) rtip=x%x, sub_rtip=x%x\n", stp->st_name, rtip, sub_rtip);

a182 1
bu_log("submodel(%s) starting rt_gettrees %s\n", stp->st_name, argv[0]);
a187 1
bu_log("submodel(%s) finished rt_gettrees\n", stp->st_name);
d205 1
a205 1
rt_pr_cut_info( sub_rtip, stp->st_name );
a363 15
if(BN_VEC_NON_UNIT_LEN(inseg->seg_in.hit_normal) ) {
bu_log("submodel(%s) bad inseg normal, %d\n",
inseg->seg_stp->st_name, count);
VPRINT("inseg->seg_in.hit_normal", inseg->seg_in.hit_normal);
		bu_log("\n**********shootray cpu=%d  %d,%d lvl=%d (%s)\n",
			99,
			ap->a_x, ap->a_y,
			ap->a_level,
			ap->a_purpose != (char *)0 ? ap->a_purpose : "?" );
		bu_log("Pnt (%g, %g, %g) a_onehit=%d\n",
			V3ARGS(ap->a_ray.r_pt),
			ap->a_onehit );
		VPRINT("Dir", ap->a_ray.r_dir);
mat_print("subm2m", submodel->subm2m);
rt_pr_pt(ap->a_rt_i, pp);}
a367 15
if(BN_VEC_NON_UNIT_LEN(outseg->seg_out.hit_normal) ) {
bu_log("submodel(%s) bad outseg normal, %d\n",
outseg->seg_stp->st_name,count);
VPRINT("outseg->seg_in.hit_normal", outseg->seg_out.hit_normal);
		bu_log("\n**********shootray cpu=%d  %d,%d lvl=%d (%s)\n",
			99,
			ap->a_x, ap->a_y,
			ap->a_level,
			ap->a_purpose != (char *)0 ? ap->a_purpose : "?" );
		bu_log("Pnt (%g, %g, %g) a_onehit=%d\n",
			V3ARGS(ap->a_ray.r_pt),
			ap->a_onehit );
		VPRINT("Dir", ap->a_ray.r_dir);
mat_print("subm2m", submodel->subm2m);
rt_pr_pt(ap->a_rt_i, pp);}
a369 15
if(BN_VEC_NON_UNIT_LEN(up_segp->seg_in.hit_normal) ) {
bu_log("submodel(%s) bad up_seg in normal, %d\n",
inseg->seg_stp->st_name,count);
VPRINT("up_segp->seg_in.hit_normal", up_segp->seg_in.hit_normal);
		bu_log("\n**********shootray cpu=%d  %d,%d lvl=%d (%s)\n",
			99,
			ap->a_x, ap->a_y,
			ap->a_level,
			ap->a_purpose != (char *)0 ? ap->a_purpose : "?" );
		bu_log("Pnt (%g, %g, %g) a_onehit=%d\n",
			V3ARGS(ap->a_ray.r_pt),
			ap->a_onehit );
		VPRINT("Dir", ap->a_ray.r_dir);
mat_print("subm2m", submodel->subm2m);
rt_pr_pt(ap->a_rt_i, pp);}
a371 15
if(BN_VEC_NON_UNIT_LEN(up_segp->seg_out.hit_normal) ) {
bu_log("submodel(%s) bad up_seg out normal, %d\n",
outseg->seg_stp->st_name,count);
VPRINT("up_segp->seg_out.hit_normal", up_segp->seg_out.hit_normal);
		bu_log("\n**********shootray cpu=%d  %d,%d lvl=%d (%s)\n",
			99,
			ap->a_x, ap->a_y,
			ap->a_level,
			ap->a_purpose != (char *)0 ? ap->a_purpose : "?" );
		bu_log("Pnt (%g, %g, %g) a_onehit=%d\n",
			V3ARGS(ap->a_ray.r_pt),
			ap->a_onehit );
		VPRINT("Dir", ap->a_ray.r_dir);
mat_print("subm2m", submodel->subm2m);
rt_pr_pt(ap->a_rt_i, pp);}
@


1.40
log
@
Print more debug info.
@
text
@d30 1
a30 1
static char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.39 2000/02/10 04:27:28 mike Exp $ (BRL)";
d370 15
d389 16
a404 1
		MAT4X3VEC( up_segp->seg_in.hit_normal, submodel->subm2m,
d406 16
a421 1
		MAT4X3VEC( up_segp->seg_out.hit_normal, submodel->subm2m,
d423 15
d519 7
@


1.39
log
@
Fixed bug with not setting search term inside critical section.
@
text
@d30 1
a30 1
static char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.38 2000/02/08 05:10:23 mike Exp $ (BRL)";
d211 1
a211 8
	bu_log("%s: %s= %d nu, %d cut, %d box (%d empty)\n",
		stp->st_name,
		sub_rtip->rti_space_partition == RT_PART_NUGRID ?
			"NUGrid" : "NUBSP",
		sub_rtip->rti_ncut_by_type[CUT_NUGRIDNODE],
		sub_rtip->rti_ncut_by_type[CUT_CUTNODE],
		sub_rtip->rti_ncut_by_type[CUT_BOXNODE],
		sub_rtip->nempty_cells );
@


1.38
log
@
Fixed nasty typo!
@
text
@d30 1
a30 1
static char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.37 2000/02/02 04:15:58 mike Exp $ (BRL)";
d160 3
a177 1
	sub_rtip->rti_treetop = bu_strdup(sip->treetop);
d210 9
@


1.37
log
@
Added more error checking.
@
text
@d30 1
a30 1
static char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.36 2000/02/02 03:13:39 mike Exp $ (BRL)";
d347 3
a349 1
		up_segp->seg_in.hit_dist -= gp->delta;
@


1.36
log
@
Made even more honest, by operating on partition lists rather than
seg lists.
@
text
@d30 1
a30 1
static char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.35 2000/02/02 02:13:37 mike Exp $ (BRL)";
d328 3
a330 1
		outseg = outseg;
@


1.35
log
@
Removed commented-out code for the "dis-honest" way.
@
text
@d30 1
a30 1
static char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.34 2000/02/02 01:23:16 mike Exp $ (BRL)";
a289 1
	struct seg		*segp;
d313 1
a313 1
	 * build a totally new segment list,
d315 2
a316 2
	 * and converted back into up_model coordinate system.
	 * So the lazy-evaluation routines don't have to do anything.
a319 1
XXX This should operate on the evaluated partition list!!
d321 1
a321 1
	for( BU_LIST_FOR( segp, seg, &(segHeadp->l) ) )  {
d323 2
a324 1
		RT_CHECK_SEG(segp);
d326 10
a335 1
		/* Construct a completely new segment */
d337 2
a338 2

		*up_segp = *segp;	/* struct copy */
d342 3
a344 1
		MAT4XSCALOR( up_segp->seg_in.hit_dist, submodel->subm2m, segp->seg_in.hit_dist);
a345 2
		MAT4XSCALOR( up_segp->seg_out.hit_dist, submodel->subm2m, segp->seg_out.hit_dist);
		up_segp->seg_out.hit_dist -= gp->delta;
d358 8
a365 4
		segp->seg_stp->st_meth->ft_norm( &segp->seg_in,
			segp->seg_stp, segp->seg_in.hit_rayp );
		segp->seg_stp->st_meth->ft_norm( &segp->seg_out,
			segp->seg_stp, segp->seg_out.hit_rayp );
d367 1
a367 1
			segp->seg_in.hit_normal );
d369 1
a369 1
			segp->seg_out.hit_normal );
d374 1
a374 1
			RT_HIT_UVCOORD( ap, segp->seg_stp, &segp->seg_in, &uv );
d382 1
a382 1
			RT_HIT_UVCOORD( ap, segp->seg_stp, &segp->seg_out, &uv );
d394 2
a395 2
		/* Leave behind a distinctive marker to make sure we're
		 * getting the right stuff back in the hooked functions.
@


1.34
log
@
Eliminated rti_nobool in favor of a_segs_only
@
text
@a0 2
#define HONEST_WAY	1

d30 1
a30 1
static char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.33 2000/01/14 05:37:26 mike Exp $ (BRL)";
a64 3
#if !HONEST_WAY
CONST extern struct rt_functab rt_submodelhook_functab;
#endif
a208 34
#if !HONEST_WAY
	/*
	 *  Record the "up" pointer from the sub model.
	 */
	/* XXX This is evil and must be eliminated */
	sub_rtip->rti_up = stp;

	/*
	 *  XXX Idea? Here, just rip off the regions and solids from the
	 *  submodel, and make them part of the main model.
	 *  Then just stealing segs will be OK.
	 */
	while( BU_LIST_NON_EMPTY( &sub_rtip->HeadRegion ) )  {
		rp = BU_LIST_FIRST( region, &sub_rtip->HeadRegion );
		BU_LIST_DEQUEUE( &(rp->l) );

		bu_semaphore_acquire( RT_SEM_RESULTS );	/* enter critical section */
		/* Add to up_rtip's list */
		BU_LIST_INSERT( &rtip->HeadRegion, &(rp->l) );
		rp->reg_bit = rtip->nregions++;	/* Assign bit vector pos. */
		bu_semaphore_release( RT_SEM_RESULTS );	/* leave critical section */

	}

	/*
	 *  Visit all solids in sub_rtip and change their st_meth
	 *  pointers to our hook routines,
	 *  for coordinate system transformations.
	 */
	RT_VISIT_ALL_SOLTABS_START( sub_stp, sub_rtip )  {
		sub_stp->st_meth = &rt_submodelhook_functab;
	} RT_VISIT_ALL_SOLTABS_END
#endif

d321 1
a321 1
	 * Alternatively, submodels can't include submodels.
a322 1
#if HONEST_WAY
a391 22
#else
	/* Steal & xform the segment list */
	while( BU_LIST_NON_EMPTY( &(segHeadp->l) ) ) {
		segp = BU_LIST_FIRST( seg, &(segHeadp->l) );
		RT_CHECK_SEG(segp);
		BU_LIST_DEQUEUE( &(segp->l) );

		/* Adjust for scale difference */
		MAT4XSCALOR( segp->seg_in.hit_dist, submodel->subm2m, segp->seg_in.hit_dist);
		segp->seg_in.hit_dist -= gp->delta;
		MAT4XSCALOR( segp->seg_out.hit_dist, submodel->subm2m, segp->seg_out.hit_dist);
		segp->seg_out.hit_dist -= gp->delta;

		/* Link to ray in upper model, not submodel */
		segp->seg_in.hit_rayp = &up_ap->a_ray;
		segp->seg_out.hit_rayp = &up_ap->a_ray;

		/* Put this segment on caller's shot routine seglist */
		BU_LIST_INSERT( &(gp->up_seghead->l), &(segp->l) );
		count++;
	}
#endif
a472 4
	/* set flag indicating not to bother with boolean computation. */
	sub_ap.a_segs_only = 1;
	/* What about a_onehit? */

a922 400


#if !HONEST_WAY

/* ============================================================ */
/*								*/
/*	Hooks applied to all solids in the submodel,		*/
/*	to intermediate between model and submodel coords.	*/
/*								*/
/* ============================================================ */

/*
 *  			R T _ S U B M O D E L H O O K _ P R E P
 */
int
rt_submodelhook_prep( stp, ip, rtip )
struct soltab		*stp;
struct rt_db_internal	*ip;
struct rt_i		*rtip;
{
	bu_bomb("rt_submodelhook_prep()\n");
	/* NOTREACHED */
}

/*
 *			R T _ S U B M O D E L H O O K _ P R I N T
 */
void
rt_submodelhook_print( stp )
register CONST struct soltab *stp;
{
	rt_functab[stp->st_id].ft_print(stp);
}

/*
 *  			R T _ S U B M O D E L H O O K _ S H O T
 *  
 *  Intersect a ray with an object in a submodel.
 *  If an intersection occurs, a struct seg will be acquired
 *  and filled in.
 *  
 *  Returns -
 *  	0	MISS
 *	>0	HIT
 */
int
rt_submodelhook_shot( stp, rp, ap, seghead )
struct soltab		*stp;
register struct xray	*rp;
struct application	*ap;
struct seg		*seghead;
{
	return rt_functab[stp->st_id].ft_shot( stp, rp, ap, seghead );
}

/*
 *			R T _ S U B M O D E L H O O K _ V S H O T
 *
 *  Vectorized version.
 */
void
rt_submodelhook_vshot( stp, rp, segp, n, ap )
struct soltab	       *stp[]; /* An array of solid pointers */
struct xray		*rp[]; /* An array of ray pointers */
struct  seg            segp[]; /* array of segs (results returned) */
int		  	    n; /* Number of ray/object pairs */
struct application	*ap;
{
	bu_bomb("rt_submodelhook_vshot\n");
}

/*
 *  			R T _ S U B M O D E L H O O K _ N O R M
 *  
 *  Given ONE ray distance, return the normal and entry/exit point.
 *
 *  Pass the original ray through the world-to-submodel transform,
 *  then send the normal back through the inverse transform.
 */
void
rt_submodelhook_norm( hitp, stp, rp )
register struct hit	*hitp;
struct soltab		*stp;
register struct xray	*rp;
{
	struct rt_i	*sub_rtip;
	struct soltab	*upper_stp;	/* The submodel "solid" */
	struct xray	sub_xray;
	vect_t		sub_norm;
	register struct submodel_specific *submodel;
	struct hit	sub_hit;

	sub_rtip = stp->st_rtip;
	RT_CK_RTI(sub_rtip);

	/* XXX There should be more than one of these */
	upper_stp = sub_rtip->rti_up;
	RT_CK_SOLTAB(upper_stp);
/* XXX Really need some other way to get upper_stp */

	submodel = (struct submodel_specific *)upper_stp->st_specific;
	RT_CK_SUBMODEL_SPECIFIC(submodel);

	/* Reconstruct the ray in submodel coords */
	MAT4X3PNT( sub_xray.r_pt, submodel->m2subm, rp->r_pt );
	MAT4X3VEC( sub_xray.r_dir, submodel->m2subm, rp->r_dir );

	/* Reconstruct the hit in submodel coords */
	sub_hit = *hitp;		/* struct copy */
	MAT4XSCALOR( sub_hit.hit_dist, submodel->m2subm, hitp->hit_dist );
	VJOIN1( hitp->hit_point, sub_xray.r_pt, sub_hit.hit_dist, sub_xray.r_dir );
	hitp->hit_rayp = &sub_xray;

	rt_functab[stp->st_id].ft_norm( &sub_hit, stp, &sub_xray );

	/* Convert the normal back to model coords */
	MAT4X3VEC( hitp->hit_normal, submodel->subm2m, sub_hit.hit_normal );
}

/*
 *			R T _ S U B M O D E L H O O K _ C U R V E
 *
 *  Return the curvature of the submodel solid.
 */
void
rt_submodelhook_curve( cvp, hitp, stp )
register struct curvature *cvp;
register struct hit	*hitp;
struct soltab		*stp;
{
	struct rt_i	*sub_rtip;
	struct soltab	*upper_stp;	/* The submodel "solid" */
	struct xray	sub_xray;
	struct hit	sub_hit;
	vect_t		sub_pdir;
	register struct submodel_specific *submodel;
/* XXX How do we get original ray??? */
struct xray *rp = (struct xray *)NULL;
bu_bomb("rt_submodelhook_curve() -- no rp?\n");

	sub_rtip = stp->st_rtip;
	RT_CK_RTI(sub_rtip);

	/* XXX There should be more than one of these */
	upper_stp = sub_rtip->rti_up;
	RT_CK_SOLTAB(upper_stp);
	submodel = (struct submodel_specific *)upper_stp->st_specific;
	RT_CK_SUBMODEL_SPECIFIC(submodel);

	/* Reconstruct the ray in submodel coords */
	sub_xray.magic = RT_RAY_MAGIC;
	sub_xray.index = -42;
	MAT4X3PNT( sub_xray.r_pt, submodel->m2subm, rp->r_pt );
	MAT4X3VEC( sub_xray.r_dir, submodel->m2subm, rp->r_dir );

	/*
	 * Convert the dist, point, & normal back to submodel coords.
	 */
	sub_hit = *hitp;		/* struct copy */
	/* Rescale the distance */
	MAT4XSCALOR( sub_hit.hit_dist, submodel->m2subm, hitp->hit_dist );
	/* Recompute the hit point */
	VJOIN1( sub_hit.hit_point, sub_xray.r_pt, sub_hit.hit_dist, sub_xray.r_dir );
	/* Convert the surface normal */
	MAT4X3VEC( sub_hit.hit_normal, submodel->m2subm, hitp->hit_normal );
	sub_hit.hit_rayp = &sub_xray;

	rt_functab[stp->st_id].ft_curve( cvp, &sub_hit, stp );

	/* Convert the pdir back to model coords */
	VMOVE( sub_pdir, cvp->crv_pdir );
	MAT4X3VEC( cvp->crv_pdir, submodel->subm2m, sub_pdir );

	/* The curvature numbers don't change */
}

/*
 *  			R T _ S U B M O D E L H O O K _ U V
 *  
 *  For a hit on the surface of an submodelhook, return the (u,v) coordinates
 *  of the hit point, 0 <= u,v <= 1.
 *  u = azimuth
 *  v = elevation
 */
void
rt_submodelhook_uv( ap, stp, hitp, uvp )
struct application	*ap;
struct soltab		*stp;
register struct hit	*hitp;
register struct uvcoord	*uvp;
{
	struct rt_i	*sub_rtip;
	struct soltab	*upper_stp;	/* The submodel "solid" */
	struct hit	sub_hit;
	register struct submodel_specific *submodel;
	struct application	sub_ap;

	sub_rtip = stp->st_rtip;
	RT_CK_RTI(sub_rtip);
	upper_stp = sub_rtip->rti_up;
	RT_CK_SOLTAB(upper_stp);
	submodel = (struct submodel_specific *)upper_stp->st_specific;
	RT_CK_SUBMODEL_SPECIFIC(submodel);

	/* Have to convert application struct, for "ray footprint" stuff */
	sub_ap = *ap;			/* struct copy */

	/* Reconstruct the ray in submodel coords */
	sub_ap.a_ray.magic = RT_RAY_MAGIC;
	sub_ap.a_ray.index = -42;
	MAT4X3PNT( sub_ap.a_ray.r_pt, submodel->m2subm, ap->a_ray.r_pt );
	MAT4X3VEC( sub_ap.a_ray.r_dir, submodel->m2subm, ap->a_ray.r_dir );

	/*
	 * Convert the dist, point, & normal back to submodel coords.
	 */
	sub_hit = *hitp;		/* struct copy */
	/* Rescale the distance */
	MAT4XSCALOR( sub_hit.hit_dist, submodel->m2subm, hitp->hit_dist );
	/* Recompute the hit point */
	VJOIN1( sub_hit.hit_point, sub_ap.a_ray.r_pt, sub_hit.hit_dist, sub_ap.a_ray.r_dir );
	/* Convert the surface normal */
	MAT4X3VEC( sub_hit.hit_normal, submodel->m2subm, hitp->hit_normal );
	sub_hit.hit_rayp = &sub_ap.a_ray;

	rt_functab[stp->st_id].ft_uv( ap, stp, &sub_hit, uvp );

	/* No transformation of u and v values are necessary */
}

/*
 *		R T _ S U B M O D E L H O O K _ F R E E
 */
void
rt_submodelhook_free( stp )
register struct soltab *stp;
{
	rt_functab[stp->st_id].ft_free( stp );
}

/*
 *			R T _ S U B M O D E L H O O K _ C L A S S
 */
int
rt_submodelhook_class( stp, min, max, tol )
CONST struct soltab    *stp;
CONST vect_t		min, max;
CONST struct bn_tol    *tol;
{
	struct rt_i	*sub_rtip;
	struct soltab	*upper_stp;	/* The submodel "solid" */
	register struct submodel_specific *submodel;
	point_t		sub_min, sub_max;
	struct bn_tol	sub_tol;

	sub_rtip = stp->st_rtip;
	RT_CK_RTI(sub_rtip);
	upper_stp = sub_rtip->rti_up;
	RT_CK_SOLTAB(upper_stp);
	submodel = (struct submodel_specific *)upper_stp->st_specific;
	RT_CK_SUBMODEL_SPECIFIC(submodel);
	
	/* Transform min and max points */
	MAT4X3PNT( sub_min, submodel->m2subm, min );
	MAT4X3PNT( sub_max, submodel->m2subm, max );

	/* Scale tol */
	sub_tol.magic = tol->magic;
	MAT4XSCALOR(sub_tol.dist, submodel->m2subm, tol->dist );
	sub_tol.dist_sq = sub_tol.dist * sub_tol.dist;
	sub_tol.perp = sub_tol.perp;
	sub_tol.para = sub_tol.para;

	return rt_functab[stp->st_id].ft_classify( stp, sub_min, sub_max, &sub_tol );
}

/*
 *			R T _ S U B M O D E L H O O K _ P L O T
 */
int
rt_submodelhook_plot( vhead, ip, ttol, tol )
struct bu_list		*vhead;
struct rt_db_internal	*ip;
CONST struct rt_tess_tol *ttol;
CONST struct bn_tol	*tol;
{
	bu_bomb("rt_submodelhook_plot\n");
	/* NOTREACHED */
}

/*
 *			R T _ S U B M O D E L H O O K _ T E S S
 *
 *  Returns -
 *	-1	failure
 *	 0	OK.  *r points to nmgregion that holds this tessellation.
 */
int
rt_submodelhook_tess( r, m, ip, ttol, tol )
struct nmgregion	**r;
struct model		*m;
struct rt_db_internal	*ip;
CONST struct rt_tess_tol *ttol;
CONST struct bn_tol	*tol;
{
	bu_bomb("rt_submodelhook_tess\n");
	/* NOTREACHED */
}

/*
 *			R T _ S U B M O D E L H O O K _ I M P O R T
 *
 */
int
rt_submodelhook_import( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
CONST struct bu_external	*ep;
register CONST mat_t		mat;
CONST struct db_i		*dbip;
{
	bu_bomb("rt_submodelhook_import\n");
	/* NOTREACHED */
}

/*
 *			R T _ S U B M O D E L H O O K _ E X P O R T
 */
int
rt_submodelhook_export( ep, ip, local2mm, dbip )
struct bu_external		*ep;
CONST struct rt_db_internal	*ip;
double				local2mm;
CONST struct db_i		*dbip;
{
	bu_bomb("rt_submodelhook_export\n");
	/* NOTREACHED */
}

/*
 *			R T _ S U B M O D E L H O O K _ D E S C R I B E
 *
 *  Make human-readable formatted presentation of this solid.
 *  First line describes type of solid.
 *  Additional lines are indented one tab, and give parameter values.
 */
int
rt_submodelhook_describe( str, ip, verbose, mm2local )
struct bu_vls		*str;
CONST struct rt_db_internal	*ip;
int			verbose;
double			mm2local;
{
	bu_bomb("rt_submodelhook_describe\n");
	/* NOTREACHED */
}

/*
 *			R T _ S U B M O D E L H O O K _ I F R E E
 *
 *  Free the storage associated with the rt_db_internal version of this solid.
 */
void
rt_submodelhook_ifree( ip )
struct rt_db_internal	*ip;
{
	rt_functab[ip->idb_type].ft_ifree( ip );
}

/*
 *			R T _ S U B M O D E L H O O K _ X F O R M
 *
 *  Create transformed version of internal form.  Free *ip if requested.
 *  Implement this if it's faster than doing an export/import cycle.
 */
int
rt_submodelhook_xform( op, mat, ip, free )
struct rt_db_internal	*op;
CONST mat_t		mat;
struct rt_db_internal	*ip;
int			free;
{
	bu_bomb("rt_submodelhook_xform\n");
	/* NOTREACHED */
}

CONST struct rt_functab rt_submodelhook_functab = {
	RT_FUNCTAB_MAGIC, "ID_SUBMODELHOOK", "submdhk",
		0,		/* hooks only */
		rt_submodelhook_prep,	rt_submodelhook_shot,	rt_submodelhook_print,	rt_submodelhook_norm,
		rt_submodelhook_uv,		rt_submodelhook_curve,	rt_submodelhook_class,	rt_submodelhook_free,
		rt_submodelhook_plot,	NULL,		rt_submodelhook_tess,	NULL,
		rt_submodelhook_import,	rt_submodelhook_export,	rt_submodelhook_ifree,
		rt_submodelhook_describe,	rt_submodelhook_xform,	NULL,
		0, 0,
/* 		rt_parsetab_tclget, rt_parsetab_tcladjust, rt_parsetab_tclform, */
		NULL, NULL, NULL,
		NULL,
};

#endif /* !HONEST_WAY */
@


1.33
log
@
Temporarily added some debugging messages.
Also fixed a few error handler cases, which weren't being used.
@
text
@d32 1
a32 1
static char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.32 2000/01/13 01:53:30 mike Exp $ (BRL)";
d536 2
a537 2
/* XXX rt_shootray() doesn't pay attention yet. */
	submodel->rtip->rti_nobool = 1;
@


1.32
log
@
Don't do stat() syscalls
@
text
@d32 1
a32 1
static char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.31 2000/01/12 01:41:15 mike Exp $ (BRL)";
d108 2
a109 1
	/* This code must be prepared to run in parallel
d125 1
d133 1
d167 2
d190 1
d192 2
a193 1
		rt_free_rti( rtip );
d196 1
d201 1
@


1.31
log
@
Major performance boost to the submodel, by using rti_resource to
hold an array of resource structures, one per cpu.
@
text
@d32 1
a32 1
static char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.30 2000/01/08 04:09:06 mike Exp $ (BRL)";
d118 4
@


1.30
log
@
Gak, the resource structures.
@
text
@d32 1
a32 1
static char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.29 2000/01/08 02:30:26 mike Exp $ (BRL)";
d196 5
a468 1
	struct resource		res;
d470 3
d489 20
a508 6
	/* Special handling for the resources structure */
	/* One is needed per CPU per rtip */
	/* For starters, allocate and free per ray */
	bzero( (char *)&res, sizeof(res) );
	rt_init_resource( &res, ap->a_resource->re_cpu );
	sub_ap.a_resource = &res;
a526 2

	rt_clean_resource( submodel->rtip, &res );
@


1.29
log
@
Added db_is_directory_non_empty()
@
text
@d32 1
a32 1
static char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.28 2000/01/06 04:53:49 mike Exp $ (BRL)";
d464 2
d482 7
d505 5
a509 1
	if( rt_shootray( &sub_ap ) <= 0 )  return 0;	/* MISS */
@


1.28
log
@
This version has what it takes
@
text
@d32 1
a32 1
static char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.27 2000/01/06 02:39:11 mike Exp $ (BRL)";
d118 1
a118 1
		if( sub_dbip->dbi_uses <= 1 )  {
d731 1
a731 1
		if( good.dbip->dbi_uses <= 1 )  {
@


1.27
log
@
Revised comments
@
text
@d1 2
d32 1
a32 1
static char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.26 2000/01/06 02:35:46 mike Exp $ (BRL)";
d67 1
d69 1
d101 1
a106 5
/* XXX How do we match a previous exact use of this file and treetop list,
 * XXX so as to get any sort of efficiency out of instancing it?
 * XXX That would be silly, because then they would overlap!  Don't bother.
 * (This might happen if a submodel is both subtracted and unioned).
 */
a126 1
	/* XXX Need to search dbi_client list here */
d128 28
a155 1
	sub_rtip = rt_new_rti( sub_dbip );
d171 1
d196 1
d228 1
d230 1
a230 1
	
d344 1
a344 1
#if 1
d804 2
d871 1
d873 1
d876 1
d890 1
d892 1
d946 1
d1342 2
@


1.26
log
@
Got the "honest way" to start working.
@
text
@d6 1
a6 1
 *	included from another .g file, as a subordinate
d9 2
a10 2
 * Adding a new solid type:
 *	Design disk record
a11 2
 *	define rt_submodel_internal --- parameters for solid
 *	define submodel_specific --- raytracing form, possibly w/precomuted terms
d13 2
a14 16
 *	code import/export/describe/print/ifree/plot/prep/shot/curve/uv/tess
 *
 *	edit db.h add solidrec s_type define
 *	edit rtgeom.h to add rt_submodel_internal
 *	edit table.c:
 *		RT_DECLARE_INTERFACE()
 *		struct rt_functab entry
 *		rt_id_solid()
 *	edit raytrace.h to make ID_SUBMODEL, increment ID_MAXIMUM
 *	edit Cakefile to add g_submodel.c to compile
 *
 *	Then:
 *	go to /cad/libwdb and create mk_submodel() routine
 *	go to /cad/mged and create the edit support
 *
 *  Authors -
d17 1
a17 2
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
d20 5
d26 2
a27 2
 *	This software is Copyright (C) 1998 by the United States Army.
 *	All rights reserved.
d30 1
a30 1
static char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.25 2000/01/04 17:58:20 bparker Exp $ (BRL)";
@


1.25
log
@*- add client_data to db_walk_tree
@
text
@d42 1
a42 1
static char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.24 1999/12/30 04:56:59 mike Exp $ (BRL)";
d327 1
a327 1
#if 0
d365 18
a382 2
		/* gak, no place to stash uv data! */
		/* Could use hit_vpriv and hit_private */
d386 10
d516 1
a516 2
	register struct submodel_specific *submodel =
		(struct submodel_specific *)stp->st_specific;
d518 1
a518 1
	VJOIN1( hitp->hit_point, rp->r_pt, hitp->hit_dist, rp->r_dir );
d520 2
a521 2
	/* XXX This will never be called */
	bu_log("rt_submodel_norm() shouldn't have been called\n");
d544 1
a544 1
	bu_log("rt_submodel_curve() shouldn't have been called\n");
d562 3
a564 2
	register struct submodel_specific *submodel =
		(struct submodel_specific *)stp->st_specific;
d566 3
a568 2
	/* XXX This will never be called */
	bu_log("rt_submodel_uv() shouldn't have been called\n");
d1013 2
d1018 1
d1061 2
@


1.24
log
@
Additional datastructures to support the submodel.
@
text
@d42 1
a42 1
static char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.23 1999/12/29 23:23:11 mike Exp $ (BRL)";
d582 1
a582 1
HIDDEN union tree *rt_submodel_wireframe_leaf( tsp, pathp, ep, id )
d587 1
d709 2
a710 1
		rt_submodel_wireframe_leaf );
@


1.23
log
@
db_scan() got a client_data argument, which
db_diradd() needed to learn to ignore.
@
text
@d42 1
a42 1
static char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.22 1999/12/29 04:50:29 mike Exp $ (BRL)";
d119 4
d134 1
d139 7
a150 3
	sub_rtip = rt_new_rti( sub_dbip );
	if( sub_rtip == RTI_NULL )  return -1;

d184 1
d279 1
d308 1
a308 1
	up_stp = ap->a_rt_i->rti_up;
d317 50
a366 1
	
d368 4
d392 1
d418 1
a418 1
	struct application	nap;
d428 1
d430 6
a435 7
	nap = *ap;		/* struct copy */
	nap.a_rt_i = submodel->rtip;
	nap.a_hit = rt_submodel_a_hit;
	nap.a_miss = rt_submodel_a_miss;
	nap.a_uptr = (genptr_t)&gb;
	nap.a_dist = submodel->m2subm[15];	/* scale, local to world */
	nap.a_purpose = "rt_submodel_shot";
d441 2
a442 2
	MAT4X3PNT( nap.a_ray.r_pt, submodel->m2subm, ap->a_ray.r_pt );
	MAT4X3VEC( nap.a_ray.r_dir, submodel->m2subm, ap->a_ray.r_dir );
d453 1
a453 1
	if( rt_shootray( &nap ) <= 0 )  return 0;	/* MISS */
d986 1
@


1.22
log
@
Handle the fact that ap->a_ray.r_pt is not the same as rp->r_pt
when a ray is being shot.
@
text
@d42 1
a42 1
static char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.21 1999/12/29 03:06:21 mike Exp $ (BRL)";
d128 1
a128 1
			if( db_scan( sub_dbip, (int (*)())db_diradd, 1 ) < 0 )  {
d623 1
a623 1
			if( db_scan( good.dbip, (int (*)())db_diradd, 1 ) < 0 )  {
@


1.21
log
@
Added more debugging
@
text
@d42 1
a42 1
static char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.20 1999/12/28 23:29:28 mike Exp $ (BRL)";
d269 1
d287 2
d299 3
d306 2
d314 5
a318 5
		/* Adjust for new start point & matrix scaling */
		segp->seg_in.hit_dist = up_ap->a_ray.r_min +
			segp->seg_in.hit_dist * ap->a_dist;
		segp->seg_out.hit_dist = up_ap->a_ray.r_min +
			segp->seg_out.hit_dist * ap->a_dist;
d320 1
a353 1
	point_t			startpt;
d355 1
d379 5
d581 5
d915 1
d928 7
a934 1
	rt_functab[stp->st_id].ft_norm( hitp, stp, &sub_xray );
d937 1
a937 2
	VMOVE( sub_norm, hitp->hit_normal );
	MAT4X3VEC( hitp->hit_normal, submodel->subm2m, sub_norm );
@


1.20
log
@
Added recursive printing
@
text
@d42 1
a42 1
static char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.19 1999/12/23 06:32:29 mike Exp $ (BRL)";
d134 5
d222 5
d361 1
@


1.19
log
@
Further progress.
@
text
@d42 1
a42 1
static char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.18 1999/12/23 05:05:27 mike Exp $ (BRL)";
d231 12
@


1.18
log
@
This version steals the segs.
@
text
@d42 1
a42 1
static char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.17 1999/12/22 05:21:20 mike Exp $ (BRL)";
a54 5
#include "./debug.h"

/* XXX move to vmath.h */
#define MAT4XSCALOR(o,m,i) \
	{(o) = (i) / (m)[15];}
d105 1
d177 11
d264 1
d295 1
d297 1
a297 14

#if 0
	/* Steal the partition list */
	while( (pp=PartHeadp->pt_forw) != PartHeadp )  {
		RT_CK_PT(pp);
		DEQUEUE_PT(pp);

		pp->pt_regionp = up_reg;

	/* XXX These need to be sort/merged into the Final list! */
		INSERT_PT( pp, up_ap->a_Final_Part_hdp );
	}
#endif
	return 1;
a339 2
/* XXX Need a per-processor place to stash this new ray! (Application struct) */
/* Need to malloc it, and queue it for destruction in caller's application struct */
d347 4
d354 1
a355 1
	/* a_hit routine will add segs to seghead */
@


1.17
log
@
This version can raytrace.
@
text
@d42 1
a42 1
static char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.16 1999/12/22 04:49:04 mike Exp $ (BRL)";
d120 2
a121 1
 * XXX That would be stilly, because then they would overlap!  Don't bother.
d167 3
a169 1
	/* OK, it's going to work. */
d177 6
a225 30
/*
 */
void
rt_submodel_normal_hook( hitp, stp, rp )
register struct hit	*hitp;
struct soltab		*stp;
register struct xray	*rp;
{
	struct rt_i	*sub_rtip;
	struct submodel_specific	*submodel;
	struct soltab	*up_stp;
	vect_t		norm;

	sub_rtip = stp->st_rtip;
#if 0
	up_stp = (struct soltab *)sub_rtip->rti_up;
	RT_CK_SOLTAB(up_stp);
	submodel = (struct submodel_specific *)up_stp->st_specific;
	RT_CK_SUBMODEL_SPECIFIC(submodel);

	/* Obtain normal for submodel's solid in that coordinate system */
	up_stp->st_meth->ft_norm(hitp, up_stp, hitp->hit_rayp);

	/* Re-project normal back into our model space */
	VMOVE( norm, hitp->hit_normal );
	MAT4X3VEC( hitp->hit_normal, submodel->subm2m, norm );
#else
	bu_log("rt_submodel_normal_hook() not implemented (yet)\n");
#endif
}
d237 5
d252 1
a252 2
	register struct application	*oap =
		(struct application *)ap->a_uptr;
d256 1
d258 1
d260 4
a263 2
	RT_AP_CHECK(oap);		/* original ap, in containing  */
	RT_CK_RTI(oap->a_rt_i);
a274 1
		BU_LIST_INSERT( &(oap->a_finished_segs_hdp->l), &(segp->l) );
d277 1
a277 1
		segp->seg_in.hit_dist = oap->a_ray.r_min +
d279 1
a279 1
		segp->seg_out.hit_dist = oap->a_ray.r_min +
d282 5
a286 2
		segp->seg_in.hit_rayp = &oap->a_ray;
		segp->seg_out.hit_rayp = &oap->a_ray;
d289 1
d298 1
a298 1
		INSERT_PT( pp, oap->a_Final_Part_hdp );
d300 1
d328 1
d334 3
d341 1
a341 1
	nap.a_uptr = (genptr_t)ap;
d357 1
a357 2
	/* Trick:  We added nothing to seghead, but we signal hit */
	/* (If a_onehit is set, we may need to cons up a dummy hit) */
@


1.16
log
@
This version can draw wireframes
@
text
@d42 1
a42 1
static char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.15 1999/12/18 16:35:23 mike Exp $ (BRL)";
d271 2
d275 1
a275 1
	RT_AP_CHECK(oap);
d277 5
d296 2
a297 6
		/* XXX seg_in->seg_rayp needs to be changed! */

		/* Need to set hook to catch norm and curve ops,
		 * and to revector them here, so that xforms can be done.
		 */

d304 3
@


1.15
log
@
Fixed typo in macro name
@
text
@d42 1
a42 1
static char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.14 1999/12/18 02:11:50 mike Exp $ (BRL)";
d126 1
a126 2
		/* XXX Might want to cache & reuse dbip's, to save scans */
		/* XXX Create a db_open_mappedfile() interface */
d129 6
a134 4
		/* XXX How to see if scan has already been done? */
		if( db_scan( sub_dbip, (int (*)())db_diradd, 1 ) < 0 )  {
			db_close( sub_dbip );
			return -1;
d472 2
a473 2
	struct db_i	*dbip;
	struct bu_list	*vheadp;
d572 1
a572 1
	state.ts_m = (struct model **)&good;	/* hack */
d576 1
a576 1
		/* Any good way to cache good.dbip's ? */
d581 8
d590 4
a593 7
		bu_log("rt_submodel_plot(): no source of DBIP yet?!?\n");
		return -1;
	}
	if( db_scan( good.dbip, (int (*)())db_diradd, 1 ) < 0 )  {
		bu_log("rt_submodel_plot() db_scan() failure\n");
		db_close(good.dbip);
		return -1;
d606 2
a607 1
	db_close(good.dbip);
d666 1
@


1.14
log
@
Progress.  More remains to do.
@
text
@d42 1
a42 1
static char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.13 1999/11/24 23:12:09 mike Exp $ (BRL)";
d57 4
a884 4

/* XXX move to vmath.h */
#define MAT4X3SCALOR(o,m,i) \
	{(o) = (i) / (m)[15];}
@


1.13
log
@
Made structparse tables CONST
@
text
@d42 1
a42 1
static char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.12 1999/11/17 04:39:20 mike Exp $ (BRL)";
d78 2
d105 1
d116 1
d123 1
d163 9
a171 2
	/* Register ourselves with containing rtip, for linked
	 * preps, frees, etc.
d173 3
a175 4
#if 0
	bu_ptbl_insert_unique( &rtip->rti_sub_rtip, (long *)sub_rtip );
	sub_rtip->rti_up = (genptr_t)stp;
#endif
d341 4
a344 3
	/* Make starting point reasonable once in local coord system */
	VJOIN1( startpt, ap->a_ray.r_pt, ap->a_ray.r_min, ap->a_ray.r_dir );
	MAT4X3PNT( nap.a_ray.r_pt, submodel->m2subm, startpt );
d774 389
@


1.12
log
@
Added 3 new fields to rt_functab, in order to better support the TCL
interface to db get and db put.
@
text
@d42 1
a42 1
static char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.11 1999/11/17 02:42:02 mike Exp $ (BRL)";
d59 1
a59 1
struct bu_structparse rt_submodel_parse[] = {
@


1.11
log
@
Added idb_meth and st_meth pointers to allow direct access to per-solid
methods, C++ style.
@
text
@d42 1
a42 1
static char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.10 1999/10/30 03:53:27 mike Exp $ (BRL)";
a55 16

/* parameters for solid, internal representation
 * This goes in rtgeom.h
 */
/* parameters for solid, internal representation */
struct rt_submodel_internal {
	long	magic;
	char	file[128];	/* .g filename, 0-len --> this database. */
	char	treetop[128];	/* one treetop only */
	int	meth;		/* space partitioning method */
	/* other option flags (lazy prep, etc.)?? */
	/* REMAINING ELEMENTS PROVIDED BY IMPORT, UNUSED BY EXPORT */
	mat_t	root2leaf;
};
#define RT_SUBMODEL_INTERNAL_MAGIC	0x7375626d	/* subm */
#define RT_SUBMODEL_CK_MAGIC(_p)	BU_CKMAG(_p,RT_SUBMODEL_INTERNAL_MAGIC,"rt_submodel_internal")
@


1.10
log
@
Added magic numbers for ray, hit, and application structures.
@
text
@d42 1
a42 1
static char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.9 1999/07/06 18:49:04 jra Exp $ (BRL)";
d181 1
d230 1
a231 1
	sub_rtip = stp->st_rtip;
d237 4
a240 6
	rt_functab[stp->st_id].ft_norm(hitp, stp, rayp);
	/* XXX This can't be done more than once per hit,
	 * as it corrupts the hit_normal field.
	 * We have no control over whether application will want more. :-(
	 * The TCL and NIRT interfaces certainly will...
	 */
d243 2
a245 1

d343 2
d395 1
d418 1
d440 1
d514 1
a514 1
		if( intern.idb_ptr )  rt_functab[id].ft_ifree( &intern );
d531 1
a531 1
	rt_functab[id].ft_ifree( &intern );
d655 1
@


1.9
log
@Converted a undefined reference (bu_free_rti) to rt_free_rti (fallout from the compat4 sed script, I suspect)
@
text
@d42 1
a42 1
static char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.8 1999/07/02 22:19:24 mike Exp $ (BRL)";
d288 2
@


1.8
log
@
Removed dependence on compat4.h
@
text
@d42 1
a42 1
static char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.7 1999/05/27 19:10:42 mike Exp $ (BRL)";
d162 1
a162 1
		bu_free_rti( rtip );
d446 1
a446 1
	bu_free_rti( submodel->rtip );
@


1.7
log
@
sed4
@
text
@d42 1
a42 1
static char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.6 1999/01/15 16:34:57 jra Exp $ (BRL)";
d78 2
a79 2
	{"%d",	1, "meth",	RT_SUBMODEL_O(meth),		FUNC_NULL },
	{"",	0, (char *)0, 0,			FUNC_NULL }
d162 1
a162 1
		rt_free_rti( rtip );
d446 1
a446 1
	rt_free_rti( submodel->rtip );
@


1.6
log
@ifdef'd out some debug logging.
@
text
@d42 1
a42 1
static char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.5 1998/06/25 08:25:57 mike Exp $ (BRL)";
d71 1
a71 1
#define RT_SUBMODEL_CK_MAGIC(_p)	RT_CKMAG(_p,RT_SUBMODEL_INTERNAL_MAGIC,"rt_submodel_internal")
d76 2
a77 2
	{"%s",	128, "file",	offsetofarray(struct rt_submodel_internal, file), FUNC_NULL },
	{"%s",	128, "treetop", offsetofarray(struct rt_submodel_internal, treetop), FUNC_NULL },
d92 1
a92 1
#define RT_CK_SUBMODEL_SPECIFIC(_p)	RT_CKMAG(_p,RT_SUBMODEL_SPECIFIC_MAGIC,"submodel_specific")
d186 2
a187 2
	mat_copy( submodel->subm2m, sip->root2leaf );
	mat_inv( submodel->m2subm, sip->root2leaf );
d326 1
a326 1
	CONST struct rt_tol	*tol = &ap->a_rt_i->rti_tol;
d562 1
a562 1
	mat_copy( state.ts_mat, sip->root2leaf );
d610 1
a610 1
CONST struct rt_tol	*tol;
d630 1
a630 1
CONST struct rt_external	*ep;
d638 1
a638 1
	RT_CK_EXTERNAL( ep );
d642 1
a642 1
		rt_log("rt_submodel_import: defective strsol record\n");
d662 1
a662 1
		rt_free( (char *)sip , "rt_submodel_import: sip" );
d689 1
a689 1
struct rt_external		*ep;
d706 1
a706 1
	RT_INIT_EXTERNAL(ep);
d741 1
a741 1
	rt_vls_strcat( str, "instanced submodel (SUBMODEL)\n");
@


1.5
log
@function should be type void
@
text
@d42 1
a42 1
static char RCSsubmodel[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_submodel.c,v 1.4 1998/04/15 06:13:16 mike Exp $ (BRL)";
d656 1
d658 1
d674 1
d677 1
@


1.4
log
@Now actually ray-traces, modulo no materials having been linked
via reg_mfuncs (rt/do.c)
@
text
@d42 1
a42 1
static char RCSsubmodel[] = "@@(#)$Header: /m/cad/librt/RCS/g_submodel.c,v 1.3 1998/04/03 01:39:22 mike Exp mike $ (BRL)";
d218 1
@


1.3
log
@ft_plot interface works.
@
text
@d42 1
a42 1
static char RCSsubmodel[] = "@@(#)$Header: /m/cad/librt/RCS/g_submodel.c,v 1.2 1998/04/03 00:18:05 mike Exp mike $ (BRL)";
d118 1
d127 3
d132 1
a132 1
		sub_rtip = rt_new_rti( rtip->rti_dbip );
d134 8
a141 2
		/* XXX Might want to cache & reuse dbip's, to save dirbuilds */
		sub_rtip = rt_dirbuild( sip->file, NULL, 0 );
d143 1
a158 1
	rt_bomb("XXX Gak, rt_gettrees can't be used recursively\n");
d183 1
d280 1
a280 3
#if 0
		BU_LIST_INSERT( oap->a_finished_segs_p, &(segp->l) );
#endif
d295 1
a295 2
	/* ??? Do these need to be sort/merged into the Final list? */
	for( pp=PartHeadp->pt_forw; pp != PartHeadp; pp = pp->pt_forw )  {
d298 2
a299 3
#if 0
		INSERT_PT( pp, oap->a_Final_Part_p );
#endif
d329 2
@


1.2
log
@Almost compiles.
@
text
@d42 1
a42 1
static char RCSsubmodel[] = "@@(#)$Header: /m/cad/librt/RCS/g_submodel.c,v 1.1 1998/03/27 08:34:22 mike Exp mike $ (BRL)";
d261 1
a261 1
	RT_AP_CK(oap);
d552 1
d557 8
a564 2
	/* Any good way to cache good.dbip's ? */
	if( (good.dbip = db_open( sip->file, "r" )) == DBI_NULL )
d566 1
d568 1
d582 1
d642 2
d646 1
d662 2
d682 1
d688 1
d690 1
a690 1
bu_bomb("rt_submodel_export()\n");
a691 1
#if 0
d693 2
a694 2
	ep->ext_nbytes = sizeof(union record);
	ep->ext_buf = (genptr_t)rt_calloc( 1, ep->ext_nbytes, "submodel external");
d697 2
a698 2
	rec->s.s_id = ID_SOLID;
	rec->s.s_type = SUBMODEL;	/* GED primitive type from db.h */
d700 5
a704 14
	/* Since libwdb users may want to operate in units other
	 * than mm, we offer the opportunity to scale the solid
	 * (to get it into mm) on the way out.
	 */


	/* convert from local editing units to mm and export
	 * to database record format
	 *
	 * Warning: type conversion: double to float
	 */
	VSCALE( &rec->s.s_values[0], sip->submodel_V, local2mm );
	rec->s.s_values[3] = sip->submodel_radius * local2mm;
#endif
@


1.1
log
@Initial revision
@
text
@d38 1
a38 1
 *	This software is Copyright (C) 1990 by the United States Army.
d42 1
a42 1
static char RCSsubmodel[] = "@@(#)$Header: /m/cad/librt/RCS/g_submodel.c,v 11.5 1998/03/26 07:55:57 mike Exp $ (BRL)";
d63 3
a65 4
	char	gfile[128];	/* .g filename, 0-len --> this database. */
	int	ntrees;
	char	*trees[8];	/* GAK, want variable sized array */
	int	partition_meth;	/* space partitioning method */
d73 10
d120 1
d126 1
a126 1
	if( sip->gname[0] == '\0' )  {
d131 1
a131 1
		sub_rtip = rt_dirbuild( sip->gname, NULL, 0 );
d142 2
a143 2
	if( sip->partition_meth )  {
		sub_rtip->rti_space_partition = sip->partition_meth;
d149 3
a151 1
	if( rt_gettrees( sub_rtip, sip->ntrees, sip->trees, 1 ) < 0 )  {
d158 1
a158 1
			stp->st_namep, sip->gname );
d167 1
d170 1
d180 3
a182 2
	rt_rotate_bbox( stp->st_min, sub_rtip->mdl_min,
		stp->st_max, sub_rtip->mdl_max );
d217 1
d232 1
d237 11
d258 1
d266 1
a266 1
		segp = BU_LIST_FIRST( seg, &(in_hd->l) );
d269 1
d271 1
d290 1
d292 1
d326 3
a328 3
	nap.a_hit = rt_submodel_hit;
	nap.a_miss = rt_submodel_miss;
	nap.a_user = (genptr)ap;
d436 3
a438 1
	rt_free( (char *)submodel, "submodel_specific" );
d453 71
d526 2
d531 1
a531 1
struct rt_list		*vhead;
d534 1
a534 1
CONST struct rt_tol	*tol;
d537 5
d547 28
a574 1
	return(-1);
d616 1
d621 2
a622 2
	if( rp->u_id != ID_SOLID )  {
		rt_log("rt_submodel_import: defective record\n");
d628 1
a628 1
	ip->idb_ptr = rt_malloc( sizeof(struct rt_submodel_internal), "rt_submodel_internal");
d632 17
a648 1
	MAT4X3PNT( sip->submodel_V, mat, &rp->s.s_values[0] );
d673 3
d697 1
d711 1
a711 1
struct rt_vls		*str;
a717 1
	char	buf[256];
d720 1
a720 1
	rt_vls_strcat( str, "truncated general submodel (SUBMODEL)\n");
d722 4
a725 5
	sprintf(buf, "\tV (%g, %g, %g)\n",
		sip->v[X] * mm2local,
		sip->v[Y] * mm2local,
		sip->v[Z] * mm2local );
	rt_vls_strcat( str, buf );
d746 1
a746 1
	rt_free( (char *)sip, "submodel ifree" );
@
