head	11.15;
access;
symbols
	ansi-20040405-merged:11.11.2.2
	postmerge-20040405-ansi:11.13
	premerge-20040404-ansi:11.12
	postmerge-autoconf:11.12
	autoconf-freeze:11.11.10.2
	premerge-autoconf:11.12
	ansi-20040316-freeze:11.11.2.1
	postmerge-20040315-windows:11.12
	premerge-20040315-windows:11.12
	windows-20040315-freeze:11.11.4.1
	autoconf-20031203:11.11
	autoconf-20031202:11.11
	autoconf-branch:11.11.0.10
	phong-branch:11.11.0.8
	photonmap-branch:11.11.0.6
	rel-6-1-DP:11.11
	windows-branch:11.11.0.4
	rel-6-0-2:11.9
	ansi-branch:11.11.0.2
	rel-6-0-1-branch:11.9.0.2
	hartley-6-0-post:11.10
	hartley-6-0-pre:11.9
	rel-6-0-1:11.9
	rel-6-0:11.9
	rel-5-4:11.6
	offsite-5-3-pre:11.9
	rel-5-3:11.6
	rel-5-2:11.6
	rel-5-1-branch:11.6.0.2
	rel-5-1:11.6
	rel-5-0:11.6
	rel-5-0-beta:11.6
	rel-4-5:11.5
	ctj-4-5-post:11.3
	ctj-4-5-pre:11.3
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.2
	rel-1-10:4.1
	rt-2:2.1;
locks; strict;
comment	@ * @;


11.15
date	2004.05.21.18.07.32;	author morrison;	state dead;
branches;
next	11.14;

11.14
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.13;

11.13
date	2004.04.05.08.48.57;	author morrison;	state Exp;
branches;
next	11.12;

11.12
date	2004.02.02.17.39.22;	author morrison;	state Exp;
branches;
next	11.11;

11.11
date	2002.08.20.17.08.02;	author jra;	state Exp;
branches
	11.11.2.1
	11.11.4.1
	11.11.10.1;
next	11.10;

11.10
date	2002.08.15.20.55.14;	author hartley;	state Exp;
branches;
next	11.9;

11.9
date	2000.07.12.00.38.04;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	2000.07.12.00.37.23;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	2000.07.10.23.01.38;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	99.05.10.21.30.47;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	97.12.16.02.05.01;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	97.12.16.02.04.04;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	95.11.02.21.05.17;	author cjohnson;	state Exp;
branches;
next	11.2;

11.2
date	95.07.27.17.39.16;	author gdurf;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.57.19;	author mike;	state Rel4_4;
branches;
next	10.4;

10.4
date	94.12.27.17.21.40;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	94.08.10.18.44.23;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	93.10.28.23.41.25;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.40.36;	author mike;	state Rel4_0;
branches;
next	9.3;

9.3
date	91.08.29.22.25.59;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	90.12.07.05.13.21;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.56.48;	author mike;	state Rel3_5;
branches;
next	8.2;

8.2
date	88.12.06.00.03.11;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.31.26;	author mike;	state Rel3_0;
branches;
next	7.1;

7.1
date	87.11.02.23.33.42;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.07.56.00;	author mike;	state Rel;
branches;
next	5.3;

5.3
date	87.07.10.04.52.54;	author mike;	state Exp;
branches;
next	5.2;

5.2
date	87.06.27.03.40.35;	author mike;	state Exp;
branches;
next	5.1;

5.1
date	87.06.24.22.11.45;	author mike;	state Rel;
branches;
next	4.2;

4.2
date	87.02.12.22.11.27;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.45.24;	author mike;	state Rel1;
branches;
next	3.5;

3.5
date	86.11.15.06.42.05;	author mike;	state Exp;
branches;
next	3.4;

3.4
date	86.08.12.04.15.50;	author mike;	state Exp;
branches;
next	3.3;

3.3
date	86.07.19.04.41.50;	author mike;	state Exp;
branches;
next	3.2;

3.2
date	86.07.11.01.32.12;	author mike;	state Exp;
branches;
next	3.1;

3.1
date	86.06.11.00.34.36;	author mike;	state Exp;
branches;
next	3.0;

3.0
date	86.06.10.01.33.15;	author mike;	state Exp;
branches;
next	2.3;

2.3
date	86.06.09.21.50.35;	author mike;	state Exp;
branches;
next	2.2;

2.2
date	85.10.02.22.34.53;	author mike;	state Exp;
branches;
next	2.1;

2.1
date	85.08.31.06.05.31;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	85.07.30.05.52.52;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	85.05.29.00.15.41;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	85.03.25.17.46.19;	author mike;	state Exp;
branches;
next	;

11.11.2.1
date	2002.09.19.18.01.37;	author morrison;	state Exp;
branches;
next	11.11.2.2;

11.11.2.2
date	2004.03.17.21.18.50;	author morrison;	state Exp;
branches;
next	;

11.11.4.1
date	2004.03.11.23.43.40;	author morrison;	state Exp;
branches;
next	;

11.11.10.1
date	2004.02.12.18.37.42;	author erikg;	state Exp;
branches;
next	11.11.10.2;

11.11.10.2
date	2004.03.15.14.07.23;	author erikg;	state Exp;
branches;
next	;


desc
@Support for material code
@


11.15
log
@moved to src/
@
text
@/*
 *  			M A T E R . C
 *  
 *  Code to deal with establishing and maintaining the tables which
 *  map region ID codes into worthwhile material information
 *  (colors and outboard database "handles").
 *
 *  These really are "db_" routines, more fundamental than "rt_".
 *
 *  Functions -
 *	color_addrec	Called by rt_dirbuild on startup
 *	color_map	Map one region reference to a material
 *
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1985-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSmater[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/mater.c,v 11.14 2004/05/10 15:30:46 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include "machine.h"
#include "vmath.h"
#include "mater.h"
#include "raytrace.h"
#include "./debug.h"

/*
 *  It is expected that entries on this mater list will be sorted
 *  in strictly ascending order, with no overlaps (ie, monotonicly
 * increasing).
 */
struct mater *rt_material_head = MATER_NULL;

void	rt_insert_color(struct mater *newp);

/*
 *			R T _ P R _ M A T E R
 */
void
rt_pr_mater(register struct mater *mp)
{
	(void)bu_log( "%5d..%d\t", mp->mt_low, mp->mt_high );
	(void)bu_log( "%d,%d,%d\t", mp->mt_r, mp->mt_g, mp->mt_b);
}

/*
 *  			R T _ C O L O R _ A D D R E C
 *  
 *  Called from db_scan() when initially scanning database.
 */
void
rt_color_addrec( int low, int hi, int r, int g, int b, long addr )
{
	register struct mater *mp;

	BU_GETSTRUCT( mp, mater );
	mp->mt_low = low;
	mp->mt_high = hi;
	mp->mt_r = r;
	mp->mt_g = g;
	mp->mt_b = b;
/*	mp->mt_handle = bu_strdup( recp->md.md_material ); */
	mp->mt_daddr = addr;
	rt_insert_color( mp );
}

/*
 *  			R T _ I N S E R T _ C O L O R
 *
 *  While any additional database records are created and written here,
 *  it is the responsibility of the caller to color_putrec(newp) if needed.
 */
void
rt_insert_color( struct mater *newp )
{
	register struct mater *mp;
	register struct mater *zot;

	if( rt_material_head == MATER_NULL || newp->mt_high < rt_material_head->mt_low )  {
		/* Insert at head of list */
		newp->mt_forw = rt_material_head;
		rt_material_head = newp;
		return;
	}
	if( newp->mt_low < rt_material_head->mt_low )  {
		/* Insert at head of list, check for redefinition */
		newp->mt_forw = rt_material_head;
		rt_material_head = newp;
		goto check_overlap;
	}
	for( mp = rt_material_head; mp != MATER_NULL; mp = mp->mt_forw )  {
		if( mp->mt_low == newp->mt_low  &&
		    mp->mt_high <= newp->mt_high )  {
			bu_log("dropping overwritten region-id based material property entry:\n");
			newp->mt_forw = mp->mt_forw;
			rt_pr_mater( mp );
			*mp = *newp;		/* struct copy */
			bu_free( (char *)newp, "getstruct mater" );
			newp = mp;
			goto check_overlap;
		}
		if( mp->mt_low  < newp->mt_low  &&
		    mp->mt_high > newp->mt_high )  {
			/* New range entirely contained in old range; split */
			bu_log("Splitting region-id based material property entry into 3 ranges\n");
			BU_GETSTRUCT( zot, mater );
			*zot = *mp;		/* struct copy */
			zot->mt_daddr = MATER_NO_ADDR;
			/* zot->mt_high = mp->mt_high; */
			zot->mt_low = newp->mt_high+1;
			mp->mt_high = newp->mt_low-1;
			/* mp, newp, zot */
			/* zot->mt_forw = mp->mt_forw; */
			newp->mt_forw = zot;
			mp->mt_forw = newp;
			rt_pr_mater( mp );
			rt_pr_mater( newp );
			rt_pr_mater( zot );
			return;
		}
		if( mp->mt_high > newp->mt_low )  {
			/* Overlap to the left: Shorten preceeding entry */
			bu_log("Shortening region-id based material property entry lhs range, from:\n");
			rt_pr_mater( mp );
			bu_log("to:\n");
			mp->mt_high = newp->mt_low-1;
			rt_pr_mater( mp );
			/* Now append */
			newp->mt_forw = mp->mt_forw;
			mp->mt_forw = newp;
			goto check_overlap;
		}
		if( mp->mt_forw == MATER_NULL ||
		    newp->mt_low < mp->mt_forw->mt_low )  {
			/* Append */
			newp->mt_forw = mp->mt_forw;
			mp->mt_forw = newp;
			goto check_overlap;
		}
	}
	bu_log("fell out of rt_insert_color loop, append region-id based material property entry to end of list\n");
	/* Append at end */
	newp->mt_forw = MATER_NULL;
	mp->mt_forw = newp;
	return;

	/* Check for overlap, ie, redefinition of following colors */
check_overlap:
	while( newp->mt_forw != MATER_NULL &&
	       newp->mt_high >= newp->mt_forw->mt_low )  {
		if( newp->mt_high >= newp->mt_forw->mt_high )  {
			/* Drop this mater struct */
			zot = newp->mt_forw;
			newp->mt_forw = zot->mt_forw;
			bu_log("dropping overlaping region-id based material property entry:\n");
			rt_pr_mater( zot );
			bu_free( (char *)zot, "getstruct mater" );
			continue;
		}
		if( newp->mt_high >= newp->mt_forw->mt_low )  {
			/* Shorten this mater struct, then done */
			bu_log("Shortening region-id based material property entry rhs range, from:\n");
			rt_pr_mater( newp->mt_forw );
			bu_log("to:\n");
			newp->mt_forw->mt_low = newp->mt_high+1;
			rt_pr_mater( newp->mt_forw );
			continue;	/* more conservative than returning */
		}
	}
}

/*
 *  			R T _ R E G I O N _ C O L O R _ M A P
 *
 *  If the GIFT regionid of this region falls into a mapped area
 *  of regionid-driven color override.
 */
void
rt_region_color_map(register struct region *regp)
{
	register struct mater *mp;

	if( regp == REGION_NULL )  {
		bu_log("color_map(NULL)\n");
		return;
	}
	for( mp = rt_material_head; mp != MATER_NULL; mp = mp->mt_forw )  {
		if( regp->reg_regionid <= mp->mt_high &&
		    regp->reg_regionid >= mp->mt_low ) {
		    	regp->reg_mater.ma_color_valid = 1;
			regp->reg_mater.ma_color[0] =
				(((double)mp->mt_r)+0.5)*bn_inv255;
			regp->reg_mater.ma_color[1] =
				(((double)mp->mt_g)+0.5)*bn_inv255;
			regp->reg_mater.ma_color[2] =
				(((double)mp->mt_b)+0.5)*bn_inv255;
			return;
		}
	}
}

/*
 *			R T _ C O L O R _ F R E E
 *
 *  Really should be db_color_free().
 *  Called from db_close().
 */
void
rt_color_free(void)
{
	register struct mater *mp;

	while( (mp = rt_material_head) != MATER_NULL )  {
		rt_material_head = mp->mt_forw;	/* Dequeue 'mp' */
		/* mt_handle? */
		bu_free( (char *)mp, "getstruct mater" );
	}
}
@


11.14
log
@change conf.h to a wrapped config.h
@
text
@d27 1
a27 1
static const char RCSmater[] = "@@(#)$Header: /cvs/brlcad/librt/mater.c,v 11.13 2004/04/05 08:48:57 morrison Exp $ (BRL)";
@


11.13
log
@merge of ansi-6-0-branch into HEAD
@
text
@d27 1
a27 1
static const char RCSmater[] = "@@(#)$Header$ (BRL)";
d30 5
a34 1
#include "conf.h"
@


11.12
log
@update copyright to include span through 2003
@
text
@d27 1
a27 1
static const char RCSmater[] = "@@(#)$Header: /c/CVS/brlcad/librt/mater.c,v 11.11 2002/08/20 17:08:02 jra Exp $ (BRL)";
d46 1
a46 1
void	rt_insert_color();
d52 1
a52 2
rt_pr_mater( mp )
register struct mater *mp;
d191 1
a191 2
rt_region_color_map( regp )
register struct region *regp;
d221 1
a221 1
rt_color_free()
@


11.11
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d23 1
a23 1
 *	This software is Copyright (C) 1985 by the United States Army.
d27 1
a27 1
static const char RCSmater[] = "@@(#)$Header: /c/CVS/brlcad/librt/mater.c,v 11.9 2000/07/12 00:38:04 mike Exp $ (BRL)";
@


11.11.4.1
log
@sync to HEAD...
@
text
@d23 1
a23 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d27 1
a27 1
static const char RCSmater[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/mater.c,v 11.12 2004/02/02 17:39:22 morrison Exp $ (BRL)";
@


11.11.10.1
log
@merge from HEAD
@
text
@d23 1
a23 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d27 1
a27 1
static const char RCSmater[] = "@@(#)$Header: /c/CVS/brlcad/librt/mater.c,v 11.12 2004/02/02 17:39:22 morrison Exp $ (BRL)";
@


11.11.10.2
log
@merge from head
@
text
@d27 1
a27 1
static const char RCSmater[] = "@@(#)$Header: /c/CVS/brlcad/librt/mater.c,v 11.11.10.1 2004/02/12 18:37:42 erikg Exp $ (BRL)";
@


11.11.2.1
log
@Initial ANSIfication
@
text
@d27 1
a27 1
static const char RCSmater[] = "@@(#)$Header: /c/CVS/brlcad/librt/mater.c,v 11.11 2002/08/20 17:08:02 jra Exp $ (BRL)";
d46 1
a46 1
void	rt_insert_color(struct mater *newp);
d52 2
a53 1
rt_pr_mater(register struct mater *mp)
d192 2
a193 1
rt_region_color_map(register struct region *regp)
d223 1
a223 1
rt_color_free(void)
@


11.11.2.2
log
@sync branch with HEAD
@
text
@d23 1
a23 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d27 1
a27 1
static const char RCSmater[] = "@@(#)$Header$ (BRL)";
@


11.10
log
@Converted from K&R to ANSI C - RFH
@
text
@d46 1
a46 1
void	rt_insert_color(struct mater *newp);
d52 2
a53 1
rt_pr_mater(register struct mater *mp)
d192 2
a193 1
rt_region_color_map(register struct region *regp)
d223 1
a223 1
rt_color_free(void)
@


11.9
log
@
No longer need db.h
@
text
@d27 1
a27 1
static const char RCSmater[] = "@@(#)$Header: /c/CVS/brlcad/librt/mater.c,v 11.8 2000/07/12 00:37:23 mike Exp $ (BRL)";
d46 1
a46 1
void	rt_insert_color();
d52 1
a52 2
rt_pr_mater( mp )
register struct mater *mp;
d191 1
a191 2
rt_region_color_map( regp )
register struct region *regp;
d221 1
a221 1
rt_color_free()
@


11.8
log
@
Changed template of rt_color_addrec()
@
text
@d27 1
a27 1
static const char RCSmater[] = "@@(#)$Header: /c/CVS/brlcad/librt/mater.c,v 11.7 2000/07/10 23:01:38 mike Exp $ (BRL)";
a34 1
#include "db.h"
@


11.7
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d27 1
a27 1
static const char RCSmater[] = "@@(#)$Header: /c/CVS/brlcad/librt/mater.c,v 11.6 1999/05/10 21:30:47 mike Exp $ (BRL)";
d49 4
a52 1
static void
d66 1
a66 3
rt_color_addrec( recp, addr )
union record *recp;
long addr;
d71 5
a75 5
	mp->mt_low = recp->md.md_low;
	mp->mt_high = recp->md.md_hi;
	mp->mt_r = recp->md.md_r;
	mp->mt_g = recp->md.md_g;
	mp->mt_b = recp->md.md_b;
d82 1
a82 1
 *  			I N S E R T _ C O L O R
d88 1
a88 2
rt_insert_color( newp )
register struct mater *newp;
@


11.6
log
@Variable name changed from ma_override to ma_color_valid
@
text
@d27 1
a27 1
static char RCSmater[] = "@@(#)$Header: /c/CVS/brlcad/librt/mater.c,v 11.5 1997/12/16 02:05:01 mike Exp $ (BRL)";
@


11.5
log
@sed4
@
text
@d27 1
a27 1
static char RCSmater[] = "@@(#)$Header: /m/cad/librt/RCS/mater.c,v 11.4 1997/12/16 02:04:04 mike Exp mike $ (BRL)";
d205 1
a205 1
		    	regp->reg_mater.ma_override = 1;
@


11.4
log
@CJohnson mod
@
text
@d27 1
a27 1
static char RCSmater[] = "@@(#)$Header: /m/cad/librt/RCS/mater.c,v 11.3 1995/11/02 21:05:17 cjohnson Exp cjohnson $ (BRL)";
d53 2
a54 2
	(void)rt_log( "%5d..%d\t", mp->mt_low, mp->mt_high );
	(void)rt_log( "%d,%d,%d\t", mp->mt_r, mp->mt_g, mp->mt_b);
d69 1
a69 1
	GETSTRUCT( mp, mater );
d75 1
a75 1
/*	mp->mt_handle = rt_strdup( recp->md.md_material ); */
d108 1
a108 1
			rt_log("dropping overwritten region-id based material property entry:\n");
d112 1
a112 1
			rt_free( (char *)newp, "getstruct mater" );
d119 2
a120 2
			rt_log("Splitting region-id based material property entry into 3 ranges\n");
			GETSTRUCT( zot, mater );
d137 1
a137 1
			rt_log("Shortening region-id based material property entry lhs range, from:\n");
d139 1
a139 1
			rt_log("to:\n");
d155 1
a155 1
	rt_log("fell out of rt_insert_color loop, append region-id based material property entry to end of list\n");
d169 1
a169 1
			rt_log("dropping overlaping region-id based material property entry:\n");
d171 1
a171 1
			rt_free( (char *)zot, "getstruct mater" );
d176 1
a176 1
			rt_log("Shortening region-id based material property entry rhs range, from:\n");
d178 1
a178 1
			rt_log("to:\n");
d199 1
a199 1
		rt_log("color_map(NULL)\n");
d207 1
a207 1
				(((double)mp->mt_r)+0.5)*rt_inv255;
d209 1
a209 1
				(((double)mp->mt_g)+0.5)*rt_inv255;
d211 1
a211 1
				(((double)mp->mt_b)+0.5)*rt_inv255;
d231 1
a231 1
		rt_free( (char *)mp, "getstruct mater" );
@


11.3
log
@Make sure that things that are rt_malloced get rt_freed.
@
text
@d27 1
a27 1
static char RCSmater[] = "@@(#)$Header: /m/cad/librt/RCS/mater.c,v 11.2 1995/07/27 17:39:16 gdurf Exp cjohnson $ (BRL)";
d112 1
a112 1
			rt_free( newp, "getstruct mater" );
d171 1
a171 1
			rt_free( zot, "getstruct mater" );
@


11.2
log
@Converted fprintf(stderr to rt_log(
@
text
@d27 1
a27 1
static char RCSmater[] = "@@(#)$Header: /m/cad/librt/RCS/mater.c,v 11.1 1995/01/04 09:57:19 mike Rel4_4 gdurf $ (BRL)";
d112 1
a112 1
			free( newp );
d171 1
a171 1
			free( zot );
@


11.1
log
@Release_4.4
@
text
@d27 1
a27 1
static char RCSmater[] = "@@(#)$Header: /m/cad/librt/RCS/mater.c,v 10.4 94/12/27 17:21:40 mike Exp $ (BRL)";
d53 2
a54 2
	(void)fprintf(stderr, "%5d..%d\t", mp->mt_low, mp->mt_high );
	(void)fprintf(stderr, "%d,%d,%d\t", mp->mt_r, mp->mt_g, mp->mt_b);
d108 1
a108 1
			(void)fprintf(stderr,"dropping overwritten region-id based material property entry:\n");
d119 1
a119 1
			(void)fprintf(stderr,"Splitting region-id based material property entry into 3 ranges\n");
d137 1
a137 1
			(void)fprintf(stderr,"Shortening region-id based material property entry lhs range, from:\n");
d139 1
a139 1
			(void)fprintf(stderr,"to:\n");
d155 1
a155 1
	(void)fprintf(stderr,"fell out of rt_insert_color loop, append region-id based material property entry to end of list\n");
d169 1
a169 1
			(void)fprintf(stderr,"dropping overlaping region-id based material property entry:\n");
d176 1
a176 1
			(void)fprintf(stderr,"Shortening region-id based material property entry rhs range, from:\n");
d178 1
a178 1
			(void)fprintf(stderr,"to:\n");
d199 1
a199 1
		fprintf(stderr,"color_map(NULL)\n");
@


10.4
log
@Bug 247.  rt_ prefix
@
text
@d27 1
a27 1
static char RCSmater[] = "@@(#)$Header: /m/cad/librt/RCS/mater.c,v 10.3 94/08/10 18:44:23 gdurf Exp Locker: mike $ (BRL)";
@


10.3
log
@Added include of conf.h
@
text
@d27 1
a27 1
static char RCSmater[] = "@@(#)$Header: /m/cad/librt/RCS/mater.c,v 10.2 1993/10/28 23:41:25 mike Exp gdurf $ (BRL)";
d45 1
a45 1
struct mater *MaterHead = MATER_NULL;
d93 1
a93 1
	if( MaterHead == MATER_NULL || newp->mt_high < MaterHead->mt_low )  {
d95 2
a96 2
		newp->mt_forw = MaterHead;
		MaterHead = newp;
d99 1
a99 1
	if( newp->mt_low < MaterHead->mt_low )  {
d101 2
a102 2
		newp->mt_forw = MaterHead;
		MaterHead = newp;
d105 1
a105 1
	for( mp = MaterHead; mp != MATER_NULL; mp = mp->mt_forw )  {
d202 1
a202 1
	for( mp = MaterHead; mp != MATER_NULL; mp = mp->mt_forw )  {
d228 2
a229 2
	while( (mp = MaterHead) != MATER_NULL )  {
		MaterHead = mp->mt_forw;	/* Dequeue 'mp' */
@


10.2
log
@Added rt_color_free(), called from db_close().
@
text
@d27 1
a27 1
static char RCSmater[] = "@@(#)$Header: /m/cad/librt/RCS/mater.c,v 10.1 91/10/12 06:40:36 mike Rel4_0 Locker: mike $ (BRL)";
d29 2
@


10.1
log
@Release_4.0
@
text
@d8 2
d27 1
a27 1
static char RCSmater[] = "@@(#)$Header: /m/cad/librt/RCS/mater.c,v 9.3 91/08/29 22:25:59 mike Exp $ (BRL)";
d58 1
a58 1
 *  Called from rt_dirbuild() when initially scanning database.
d212 18
@


9.3
log
@ANSI type conversion
@
text
@d25 1
a25 1
static char RCSmater[] = "@@(#)$Header: /m/cad/librt/RCS/mater.c,v 9.2 90/12/07 05:13:21 mike Exp $ (BRL)";
@


9.2
log
@Made messages more descriptive
@
text
@d25 1
a25 1
static char RCSmater[] = "@@(#)$Header: /m/cad/librt/RCS/mater.c,v 9.1 89/05/19 05:56:48 mike Rel3_5 $ (BRL)";
d202 6
a207 3
		    	regp->reg_mater.ma_color[0] = (mp->mt_r+0.5)*rt_inv255;
		    	regp->reg_mater.ma_color[1] = (mp->mt_g+0.5)*rt_inv255;
		    	regp->reg_mater.ma_color[2] = (mp->mt_b+0.5)*rt_inv255;
@


9.1
log
@Release_3.5
@
text
@d25 1
a25 1
static char RCSmater[] = "@@(#)$Header: mater.c,v 8.2 88/12/06 00:03:11 mike Exp $ (BRL)";
d104 1
a104 1
			(void)fprintf(stderr,"dropping overwritten entry:\n");
d115 1
a115 1
			(void)fprintf(stderr,"Splitting into 3 ranges\n");
d133 1
a133 1
			(void)fprintf(stderr,"Shortening lhs range, from:\n");
d151 1
a151 1
	(void)fprintf(stderr,"fell out of rt_insert_color loop, append to end\n");
d165 1
a165 1
			(void)fprintf(stderr,"dropping overlaping entry:\n");
d172 1
a172 1
			(void)fprintf(stderr,"Shortening rhs range, from:\n");
@


8.2
log
@Made rt_insert_color() global.
@
text
@d25 1
a25 1
static char RCSmater[] = "@@(#)$Header: /cad/d/mike/cad/librt/RCS/mater.c,v 1.2 88/10/30 00:05:59 mike Exp $ (BRL)";
@


8.1
log
@Release_3.0
@
text
@d25 1
a25 1
static char RCSmater[] = "@@(#)$Header: mater.c,v 7.1 87/11/02 23:33:42 mike Rel $ (BRL)";
d43 1
a43 1
static void rt_insert_color();
d82 1
a82 1
static void
@


7.1
log
@Release 2.3
@
text
@d25 1
a25 1
static char RCSmater[] = "@@(#)$Header: mater.c,v 6.1 87/07/11 07:56:00 mike Rel $ (BRL)";
@


6.1
log
@Release 2.0
@
text
@d25 1
a25 1
static char RCSmater[] = "@@(#)$Header: mater.c,v 5.3 87/07/10 04:52:54 mike Exp $ (BRL)";
@


5.3
log
@When converting integer RGB to 0..1 floats, changed to
add 0.5 and multiply by rt_inv255.
@
text
@d25 1
a25 1
static char RCSmater[] = "@@(#)$Header: mater.c,v 5.2 87/06/27 03:40:35 mike Locked $ (BRL)";
@


5.2
log
@ma_rgb -> ma_color
@
text
@d25 1
a25 1
static char RCSmater[] = "@@(#)$Header: mater.c,v 5.1 87/06/24 22:11:45 mike Locked $ (BRL)";
d202 3
a204 3
		    	regp->reg_mater.ma_color[0] = mp->mt_r/255.;
		    	regp->reg_mater.ma_color[1] = mp->mt_g/255.;
		    	regp->reg_mater.ma_color[2] = mp->mt_b/255.;
@


5.1
log
@Release 1.24
@
text
@d25 1
a25 1
static char RCSmater[] = "@@(#)$Header: mater.c,v 4.2 87/02/12 22:11:27 mike Exp $ (BRL)";
d202 3
a204 3
		    	regp->reg_mater.ma_rgb[0] = mp->mt_r;
		    	regp->reg_mater.ma_rgb[1] = mp->mt_g;
		    	regp->reg_mater.ma_rgb[2] = mp->mt_b;
@


4.2
log
@Release 1.20 -- First Formal Release
@
text
@d25 1
a25 1
static char RCSmater[] = "@@(#)$Header: mater.c,v 4.1 86/12/29 03:45:24 mike Rel1 $ (BRL)";
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d25 1
a25 1
static char RCSmater[] = "@@(#)$Header: mater.c,v 3.5 86/11/15 06:42:05 mike Exp $ (BRL)";
@


3.5
log
@Removed old reference to mt_handle.
@
text
@d25 1
a25 1
static char RCSmater[] = "@@(#)$Header: mater.c,v 3.4 86/08/12 04:15:50 mike Exp $ (BRL)";
@


3.4
log
@Changed #include directives for use with CC -I convention
@
text
@d25 1
a25 1
static char RCSmater[] = "@@(#)$Header: mater.c,v 3.3 86/07/19 04:41:50 mike Exp $ (BRL)";
a50 1
	(void)fprintf(stderr, "%s\n", mp->mt_handle );
@


3.3
log
@header file change
@
text
@d25 1
a25 1
static char RCSmater[] = "@@(#)$Header: mater.c,v 3.2 86/07/11 01:32:12 mike Exp $ (BRL)";
d29 6
a34 6
#include "../h/machine.h"
#include "../h/vmath.h"
#include "../h/db.h"
#include "../h/mater.h"
#include "../h/raytrace.h"
#include "debug.h"
@


3.2
log
@Cleanups inspired by the crummy compiler on the Cray XMP
@
text
@d25 1
a25 1
static char RCSmater[] = "@@(#)$Header: mater.c,v 3.1 86/06/11 00:34:36 mike Exp $ (BRL)";
a32 1
#include "rtdir.h"
@


3.1
log
@Support for new object-oriented material-property code.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: mater.c,v 3.0 86/06/10 01:33:15 mike Exp $ (BRL)";
@


3.0
log
@rt/ and librt/ separated,
global datastructures simplified.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: mater.c,v 2.3 86/06/09 21:50:35 mike Exp $ (BRL)";
d44 1
a44 2
void color_addrec();
static void insert_color();
d47 1
a47 1
pr_mater( mp )
d56 1
a56 1
 *  			C O L O R _ A D D R E C
d61 1
a61 1
color_addrec( recp, addr )
d75 1
a75 1
	insert_color( mp );
d85 1
a85 1
insert_color( newp )
d108 1
a108 1
			pr_mater( mp );
d128 3
a130 3
			pr_mater( mp );
			pr_mater( newp );
			pr_mater( zot );
d136 1
a136 1
			pr_mater( mp );
d139 1
a139 1
			pr_mater( mp );
d153 1
a153 1
	(void)fprintf(stderr,"fell out of insert_color loop, append to end\n");
d168 1
a168 1
			pr_mater( zot );
d175 1
a175 1
			pr_mater( newp->mt_forw );
d178 1
a178 1
			pr_mater( newp->mt_forw );
a183 8
static struct mater default_mater = {
	0, 32767,
	99,
	255, 0, 0,		/* red */
	"{default mater}",
	MATER_NO_ADDR, 0
};

d185 1
a185 1
 *  			C O L O R _ M A P
d187 2
a188 2
 *  Map one region description into a material description
 *  mater structure.
d191 1
a191 1
color_map( regp )
d203 4
a206 1
			regp->reg_materp = (char *)mp;
a209 1
	regp->reg_materp = (char *)&default_mater;
@


2.3
log
@rt and librt separated
@
text
@d9 1
a9 1
 *	color_addrec	Called by dir_build on startup
d25 1
a25 1
static char RCSid[] = "@@(#)$Header: mater.c,v 2.2 85/10/02 22:34:53 mike Exp $ (BRL)";
a28 1
#include "debug.h"
d35 1
d59 1
a59 1
 *  Called from dir_build() when initially scanning database.
d74 1
a74 1
/*	mp->mt_handle = strdup( recp->md.md_material ); */
@


2.2
log
@Intermediate stage along the way to new material properties.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: mater.c,v 2.1 85/08/31 06:05:31 mike Exp $ (BRL)";
d35 1
a35 1
#include "raytrace.h"
@


2.1
log
@Version 2 of RT
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: mater.c,v 1.3 85/07/30 05:52:52 mike Exp $ (BRL)";
d74 1
a74 1
	mp->mt_handle = strdup( recp->md.md_material );
@


1.3
log
@Revised for joint GED/RT vmath.h;  some storage cleanups.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: mater.c,v 1.2 85/05/29 00:15:41 mike Exp $ (BRL)";
d199 1
a199 1
char *
d205 4
a208 2
	if( regp == REGION_NULL )
		return( (char *)&default_mater );
d212 2
a213 1
			return( (char *)mp );
d216 1
a216 1
	return( (char *)&default_mater );
@


1.2
log
@Moved region and material pointer from solid structure to tree (leaf)
nodes, added path matrix and use count to solid structure, to permit
solids referenced with identical path matrices to "share",
resulting in far greater speed.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: mater.c,v 1.1 85/03/25 17:46:19 mike Exp $ (BRL)";
d30 2
a32 1
#include "vmath.h"
@


1.1
log
@Initial revision
@
text
@d10 1
a10 1
 *	color_soltab	Apply colors to the solid table
d25 1
a25 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d193 1
a193 1
 *  			C O L O R _ S O L T A B
d195 1
a195 1
 *  Pass through the solid table and set pointer to appropriate
a196 1
 *  Called by the display manager anytime the color mappings change.
d198 3
a200 2
void
color_soltab()
a201 1
	register struct soltab *sp;
d204 6
a209 9
	for( sp = HeadSolid; sp != SOLTAB_NULL; sp = sp->st_forw )  {
		if( sp->st_regionp == REGION_NULL )
			continue;
		for( mp = MaterHead; mp != MATER_NULL; mp = mp->mt_forw )  {
			if( sp->st_regionp->reg_regionid <= mp->mt_high &&
			    sp->st_regionp->reg_regionid >= mp->mt_low ) {
				sp->st_materp = (char *)mp;
				goto done;
			}
a210 2
		sp->st_materp = (char *)&default_mater;
done: ;
d212 1
@
