head	11.2;
access;
symbols
	postmerge-20051223-bobWinPort:11.1
	rel-7-6-branch:11.1.0.12
	ansi-20040405-merged:11.1.10.1
	postmerge-20040405-ansi:11.1
	autoconf-freeze:11.1.6.3
	postmerge-20040315-windows:11.1
	windows-20040315-freeze:11.1.8.1
	autoconf-20031203:11.1.6.1
	autoconf-branch:11.1.0.6
	phong-branch:11.1.0.4
	photonmap-branch:11.1.0.2
	windows-branch:11.1.0.8
	ansi-branch:11.1.0.10
	hartley-6-0-pre:11.1
	rel-4-5:11.1
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.2
	rel-1-10:4.1
	rt-2:2.1
	release-7-0:11.1;
locks; strict;
comment	@ * @;


11.2
date	2007.11.29.18.30.03;	author brlcad;	state dead;
branches;
next	11.1;

11.1
date	95.01.04.09.58.26;	author mike;	state Rel4_4;
branches
	11.1.2.1
	11.1.4.1
	11.1.6.1
	11.1.8.1
	11.1.10.1
	11.1.12.1;
next	10.6;

10.6
date	94.12.30.10.33.45;	author stay;	state Exp;
branches;
next	10.5;

10.5
date	94.12.27.17.14.38;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	94.12.22.00.25.28;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	94.08.23.17.27.15;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	94.08.10.19.37.47;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.40.55;	author mike;	state Rel4_0;
branches;
next	9.3;

9.3
date	91.07.19.01.05.12;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	91.03.13.16.41.16;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.56.58;	author mike;	state Rel3_5;
branches
	9.1.1.1;
next	8.2;

8.2
date	89.03.06.16.07.01;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.31.32;	author mike;	state Rel3_0;
branches;
next	7.2;

7.2
date	88.09.17.07.02.26;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.33.50;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.07.56.09;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.11.55;	author mike;	state Rel;
branches;
next	4.2;

4.2
date	87.02.12.22.11.35;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.45.35;	author mike;	state Rel1;
branches;
next	3.5;

3.5
date	86.12.19.04.19.59;	author mike;	state Exp;
branches;
next	3.4;

3.4
date	86.12.13.05.42.32;	author mike;	state Exp;
branches;
next	3.3;

3.3
date	86.10.11.02.18.35;	author mike;	state Exp;
branches;
next	3.2;

3.2
date	86.08.12.04.16.05;	author mike;	state Exp;
branches;
next	3.1;

3.1
date	86.07.11.01.32.19;	author mike;	state Exp;
branches;
next	3.0;

3.0
date	86.06.10.01.33.22;	author mike;	state Exp;
branches;
next	2.3;

2.3
date	85.11.19.21.18.05;	author mike;	state Exp;
branches;
next	2.2;

2.2
date	85.09.10.00.28.14;	author mike;	state Exp;
branches;
next	2.1;

2.1
date	85.08.31.06.05.39;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	85.07.30.05.54.15;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	85.06.05.01.44.37;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	85.06.03.17.29.20;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	85.03.29.22.34.52;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	85.03.27.11.57.28;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	85.03.25.11.53.43;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	85.03.25.11.46.37;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	85.02.09.05.08.21;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	85.01.28.15.49.53;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	84.11.23.20.54.18;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	84.11.20.20.14.37;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	84.09.06.03.58.48;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	84.08.21.01.18.34;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	84.08.20.22.43.51;	author mike;	state Exp;
branches;
next	;

9.1.1.1
date	91.03.14.04.04.04;	author mike;	state Exp;
branches;
next	;

11.1.2.1
date	2003.08.26.14.03.35;	author justin;	state Exp;
branches;
next	;

11.1.4.1
date	2003.09.13.18.02.22;	author butler;	state Exp;
branches;
next	;

11.1.6.1
date	2003.12.03.16.24.07;	author erikg;	state Exp;
branches;
next	11.1.6.2;

11.1.6.2
date	2004.02.12.18.37.47;	author erikg;	state Exp;
branches;
next	11.1.6.3;

11.1.6.3
date	2004.03.15.14.07.29;	author erikg;	state Exp;
branches;
next	;

11.1.8.1
date	2004.03.11.23.43.45;	author morrison;	state Exp;
branches;
next	;

11.1.10.1
date	2004.03.17.21.18.57;	author morrison;	state Exp;
branches;
next	;

11.1.12.1
date	95.01.04.09.58.26;	author brlcad;	state dead;
branches;
next	11.1.12.2;

11.1.12.2
date	2005.11.13.17.44.59;	author brlcad;	state Exp;
branches;
next	;


desc
@Polynomial package.
@


11.2
log
@once again, try to delete these zombie files that have again mysteriously shown up after an update
@
text
@/*
 *  			P O L Y L I B . C
 *
 *	Library for dealing with polynomials.
 *
 *  Functions -
 *	rt_poly_mul		Multiply two polynomials
 *	rt_poly_scale	Scale a polynomial
 *	rt_poly_add		Add two polynomials
 *	rt_poly_sub		Subtract two polynomials
 *	rt_poly_synthetic_division		Divide 1 poly into another using Synthetic Division
 *	quadratic	Solve quadratic formula
 *	cubic		Solve cubic forumla
 *	rt_pr_poly	Print a polynomial
 *
 *  Author -
 *	Jeff Hanes
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1985 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static char RCSpolylib[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/librt/Attic/polylib.c,v 11.1 1995/01/04 09:58:26 mike Rel4_4 $ (BRL)";
#endif

#include "conf.h"

#include <stdio.h>
#include <math.h>
#include <signal.h>
#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "raytrace.h"
#include "rtstring.h"
#include "./polyno.h"
#include "./complex.h"

extern void	rt_pr_poly();

#ifndef M_PI
#define M_PI	3.14159265358979323846
#endif
#define PI_DIV_3	(M_PI/3.0)
static poly	Zpoly = { 0, 0.0 };

/*
 *	rt_poly_mul -- multiply two polynomials
 */
poly *
rt_poly_mul(m1,m2,product)
register poly	*m1, *m2, *product;
{
	if( m1->dgr == 1 && m2->dgr == 1 )  {
		product->dgr = 2;
		product->cf[0] = m1->cf[0] * m2->cf[0];
		product->cf[1] = m1->cf[0] * m2->cf[1] +
				 m1->cf[1] * m2->cf[0];
		product->cf[2] = m1->cf[1] * m2->cf[1];
		return(product);
	}
	if( m1->dgr == 2 && m2->dgr == 2 )  {
		product->dgr = 4;
		product->cf[0] = m1->cf[0] * m2->cf[0];
		product->cf[1] = m1->cf[0] * m2->cf[1] +
				 m1->cf[1] * m2->cf[0];
		product->cf[2] = m1->cf[0] * m2->cf[2] +
				 m1->cf[1] * m2->cf[1] +
				 m1->cf[2] * m2->cf[0];
		product->cf[3] = m1->cf[1] * m2->cf[2] +
				 m1->cf[2] * m2->cf[1];
		product->cf[4] = m1->cf[2] * m2->cf[2];
		return(product);
	}

	/* Not one of the common (or easy) cases. */
	{
		register int		ct1, ct2;

		*product = Zpoly;

		/* If the degree of the product will be larger than the
		 * maximum size allowed in "polyno.h", then return a null
		 * pointer to indicate failure.
		 */
		if ( (product->dgr = m1->dgr + m2->dgr) > MAXP )
			return PM_NULL;

		for ( ct1=0; ct1 <= m1->dgr; ++ct1 ){
			for ( ct2=0; ct2 <= m2->dgr; ++ct2 ){
				product->cf[ct1+ct2] +=
					m1->cf[ct1] * m2->cf[ct2];
			}
		}
	}
	return product;
}


/*
 *	rt_poly_scale -- scale a polynomial
 */
poly *
rt_poly_scale(eqn,factor)
register poly	*eqn;
double	factor;
{
	register int		cnt;

	for ( cnt=0; cnt <= eqn->dgr; ++cnt ){
		eqn->cf[cnt] *= factor;
	}
	return eqn;
}


/*
 *	rt_poly_add -- add two polynomials
 */
poly *
rt_poly_add(poly1,poly2,sum)
register poly	*poly1, *poly2, *sum;
{
	LOCAL poly		tmp;
	register int		i, offset;

	offset = Abs(poly1->dgr - poly2->dgr);

	tmp = Zpoly;

	if ( poly1->dgr >= poly2->dgr ){
		*sum = *poly1;
		for ( i=0; i <= poly2->dgr; ++i ){
			tmp.cf[i+offset] = poly2->cf[i];
		}
	} else {
		*sum = *poly2;
		for ( i=0; i <= poly1->dgr; ++i ){
			tmp.cf[i+offset] = poly1->cf[i];
		}
	}

	for ( i=0; i <= sum->dgr; ++i ){
		sum->cf[i] += tmp.cf[i];
	}
	return sum;
}


/*
 *	rt_poly_sub -- subtract two polynomials
 */
poly *
rt_poly_sub(poly1,poly2,diff)
register poly	*poly1, *poly2, *diff;
{
	LOCAL poly		tmp;
	register int		i, offset;

	offset = Abs(poly1->dgr - poly2->dgr);

	*diff = Zpoly;
	tmp = Zpoly;

	if ( poly1->dgr >= poly2->dgr ){
		*diff = *poly1;
		for ( i=0; i <= poly2->dgr; ++i ){
			tmp.cf[i+offset] = poly2->cf[i];
		}
	} else {
		diff->dgr = poly2->dgr;
		for ( i=0; i <= poly1->dgr; ++i ){
			diff->cf[i+offset] = poly1->cf[i];
		}
		tmp = *poly2;
	}

	for ( i=0; i <= diff->dgr; ++i ){
		diff->cf[i] -= tmp.cf[i];
	}
	return diff;
}


/*	>>>  s y n D i v ( )  <<<
 *	Divides any polynomial into any other polynomial using synthetic
 *	division.  Both polynomials must have real coefficients.
 */
void
rt_poly_synthetic_division(dvdend,dvsor,quo,rem)
register poly	*dvdend, *dvsor, *quo, *rem;
{
	register int	div;
	register int	n;

	*quo = *dvdend;
	*rem = Zpoly;

	if ((quo->dgr = dvdend->dgr - dvsor->dgr) < 0)
		quo->dgr = -1;
	if ((rem->dgr = dvsor->dgr - 1) > dvdend->dgr)
		rem->dgr = dvdend->dgr;

	for ( n=0; n <= quo->dgr; ++n){
		quo->cf[n] /= dvsor->cf[0];
		for ( div=1; div <= dvsor->dgr; ++div){
			quo->cf[n+div] -= quo->cf[n] * dvsor->cf[div];
		}
	}
	for ( n=1; n<=(rem->dgr+1); ++n){
		rem->cf[n-1] = quo->cf[quo->dgr+n];
		quo->cf[quo->dgr+n] = 0;
	}
}


/*	>>>  q u a d r a t i c ( )  <<<
 *
 *	Uses the quadratic formula to find the roots (in `complex' form)
 *	of any quadratic equation with real coefficients.
 */
void
rt_poly_quadratic_roots( quadrat, root )
register poly		*quadrat;
register complex	root[];
{
	LOCAL fastf_t	discrim, denom, rad;

	if( NEAR_ZERO( quadrat->cf[0], SMALL ) )  {
		/* root = -cf[2] / cf[1] */
		if( NEAR_ZERO( quadrat->cf[1], SMALL ) )  {
			/* No solution.  Now what? */
			rt_log("rt_poly_quadratic_roots(): ERROR, no solution\n");
			return;
		}
		/* Fake it as a repeated root. */
		root[0].re = root[1].re = -quadrat->cf[2]/quadrat->cf[1];
		root[0].im = root[1].im = 0.0;
		return;
	}
	/* What to do if cf[1] > SQRT_MAX_FASTF ? */

	discrim = quadrat->cf[1]*quadrat->cf[1] - 4.0* quadrat->cf[0]*quadrat->cf[2];
	denom = 0.5 / quadrat->cf[0];
	if ( discrim >= 0.0 ){
		rad = sqrt( discrim );
		root[0].re = ( -quadrat->cf[1] + rad ) * denom;
		root[1].re = ( -quadrat->cf[1] - rad ) * denom;
		root[1].im = root[0].im = 0.0;
	} else {
		root[1].re = root[0].re = -quadrat->cf[1] * denom;
		root[1].im = -(root[0].im = sqrt( -discrim ) * denom);
	}
}


#define SQRT3			1.732050808
#define THIRD			0.333333333333333333333333333
#define INV_TWENTYSEVEN		0.037037037037037037037037037
#define	CUBEROOT( a )	(( (a) >= 0.0 ) ? pow( a, THIRD ) : -pow( -(a), THIRD ))

/*	>>>  c u b i c ( )  <<<
 *
 *	Uses the cubic formula to find the roots ( in `complex' form )
 *	of any cubic equation with real coefficients.
 *
 *	to solve a polynomial of the form:
 *
 *		X**3 + c1*X**2 + c2*X + c3 = 0,
 *
 *	first reduce it to the form:
 *
 *		Y**3 + a*Y + b = 0,
 *
 *	where
 *		Y = X + c1/3,
 *	and
 *		a = c2 - c1**2/3,
 *		b = ( 2*c1**3 - 9*c1*c2 + 27*c3 )/27.
 *
 *	Then we define the value delta,   D = b**2/4 + a**3/27.
 *
 *	If D > 0, there will be one real root and two conjugate
 *	complex roots.
 *	If D = 0, there will be three real roots at least two of
 *	which are equal.
 *	If D < 0, there will be three unequal real roots.
 *
 *	Returns 1 for success, 0 for fail.
 */
static int expecting_fpe = 0;
static jmp_buf abort_buf;
HIDDEN void rt_catch_FPE(sig)
int	sig;
{
	if( !expecting_fpe )
		rt_bomb("unexpected SIGFPE!");
	if( !rt_g.rtg_parallel )
		(void)signal(SIGFPE, rt_catch_FPE);	/* Renew handler */
	longjmp(abort_buf, 1);	/* return error code */
}

int
rt_poly_cubic_roots( eqn, root )
register poly		*eqn;
register complex	root[];
{
	LOCAL fastf_t	a, b, c1, c1_3rd, delta;
	register int	i;
	static int	first_time = 1;
	
	if( !rt_g.rtg_parallel ) {
		/* abort_buf is NOT parallel! */
		if( first_time )  {
			first_time = 0;
			(void)signal(SIGFPE, rt_catch_FPE);
		}
		expecting_fpe = 1;
		if( setjmp( abort_buf ) )  {
			(void)signal(SIGFPE, rt_catch_FPE);
			rt_log("rt: rt_poly_cubic_roots() Floating Point Error\n");
			return(0);	/* FAIL */
		}
	}

	c1 = eqn->cf[1];
	if( Abs(c1) > SQRT_MAX_FASTF )  return(0);	/* FAIL */
	c1_3rd = c1 * THIRD;
	a = eqn->cf[2] - c1*c1_3rd;
	if( Abs(a) > SQRT_MAX_FASTF )  return(0);	/* FAIL */
	b = (2.0*c1*c1*c1 - 9.0*c1*eqn->cf[2] + 27.0*eqn->cf[3])*INV_TWENTYSEVEN;
	if( Abs(b) > SQRT_MAX_FASTF )  return(0);	/* FAIL */

	if( (delta = a*a) > SQRT_MAX_FASTF ) return(0);	/* FAIL */
	delta = b*b*0.25 + delta*a*INV_TWENTYSEVEN;

	if ( delta > 0.0 ){
		LOCAL fastf_t		r_delta, A, B;

		r_delta = sqrt( delta );
		A = B = -0.5 * b;
		A += r_delta;
		B -= r_delta;

		A = CUBEROOT( A );
		B = CUBEROOT( B );

		root[2].re = root[1].re = -0.5 * ( root[0].re = A + B );

		root[0].im = 0.0;
		root[2].im = -( root[1].im = (A - B)*SQRT3*0.5 );
	} else if ( delta == 0.0 ){
		LOCAL fastf_t	b_2;
		b_2 = -0.5 * b;

		root[0].re = 2.0* CUBEROOT( b_2 );
		root[2].re = root[1].re = -0.5 * root[0].re;
		root[2].im = root[1].im = root[0].im = 0.0;
	} else {
		LOCAL fastf_t		phi, fact;
		LOCAL fastf_t		cs_phi, sn_phi_s3;

		if( a >= 0.0 )  {
			fact = 0.0;
			phi = 0.0;
			cs_phi = 1.0;		/* cos( phi ); */
			sn_phi_s3 = 0.0;	/* sin( phi ) * SQRT3; */
		} else {
			FAST fastf_t	f;
			a *= -THIRD;
			fact = sqrt( a );
			if( (f = b * (-0.5) / (a*fact)) >= 1.0 )  {
				phi = 0.0;
				cs_phi = 1.0;		/* cos( phi ); */
				sn_phi_s3 = 0.0;	/* sin( phi ) * SQRT3; */
			}  else if( f <= -1.0 )  {
				phi = PI_DIV_3;
				cs_phi = cos( phi );
				sn_phi_s3 = sin( phi ) * SQRT3;
			}  else  {
				phi = acos( f ) * THIRD;
				cs_phi = cos( phi );
				sn_phi_s3 = sin( phi ) * SQRT3;
			}
		}

		root[0].re = 2.0*fact*cs_phi;
		root[1].re = fact*(  sn_phi_s3 - cs_phi);
		root[2].re = fact*( -sn_phi_s3 - cs_phi);
		root[2].im = root[1].im = root[0].im = 0.0;
	}
	for ( i=0; i < 3; ++i )
		root[i].re -= c1_3rd;
	expecting_fpe = 0;
	return(1);		/* OK */
}


/*	>>>  q u a r t i c ( )  <<<
 *
 *	Uses the quartic formula to find the roots ( in `complex' form )
 *	of any quartic equation with real coefficients.
 *
 *	Returns 1 for success, 0 for fail.
 */
int
rt_poly_quartic_roots( eqn, root )
register poly		*eqn;
register complex	root[];
{
	LOCAL poly		cube, quad1, quad2;
	LOCAL complex		u[3];
	LOCAL fastf_t		U, p, q, q1, q2;
#define Max3(a,b,c) ((c)>((a)>(b)?(a):(b)) ? (c) : ((a)>(b)?(a):(b)))

	cube.dgr = 3;
	cube.cf[0] = 1.0;
	cube.cf[1] = -eqn->cf[2];
	cube.cf[2] = eqn->cf[3]*eqn->cf[1]
			- 4*eqn->cf[4];
	cube.cf[3] = -eqn->cf[3]*eqn->cf[3]
			- eqn->cf[4]*eqn->cf[1]*eqn->cf[1]
			+ 4*eqn->cf[4]*eqn->cf[2];

	if( !rt_poly_cubic_roots( &cube, u ) )  {
		return( 0 );		/* FAIL */
	}
	if ( u[1].im != 0.0 ){
		U = u[0].re;
	} else {
		U = Max3( u[0].re, u[1].re, u[2].re );
	}

	p = eqn->cf[1]*eqn->cf[1]*0.25 + U - eqn->cf[2];
	U *= 0.5;
	q = U*U - eqn->cf[4];
	if( p < 0 )  {
		if( p < -1.0e-8 )  {
			return(0);	/* FAIL */
		}
		p = 0;
	} else {
		p = sqrt( p );
	}
	if( q < 0 )  {
		if( q < -1.0e-8 )  {
			return(0);	/* FAIL */
		}
		q = 0;
	} else {
		q = sqrt( q );
	}

	quad1.dgr = quad2.dgr = 2;
	quad1.cf[0] = quad2.cf[0] = 1.0;
	quad1.cf[1] = eqn->cf[1]*0.5;
	quad2.cf[1] = quad1.cf[1] + p;
	quad1.cf[1] -= p;
	
	q1 = U - q;
	q2 = U + q;

	p = quad1.cf[1]*q2 + quad2.cf[1]*q1 - eqn->cf[3];
	if( Abs( p ) < 1.0e-8){
		quad1.cf[2] = q1;
		quad2.cf[2] = q2;
	} else {
		q = quad1.cf[1]*q1 + quad2.cf[1]*q2 - eqn->cf[3];
		if( Abs( q ) < 1.0e-8 ){
			quad1.cf[2] = q2;
			quad2.cf[2] = q1;
		} else {
			return(0);	/* FAIL */
		}
	}

	rt_poly_quadratic_roots( &quad1, root );
	rt_poly_quadratic_roots( &quad2, &root[2] );
	return(1);		/* SUCCESS */
}


/*
 *			R T _ P R _ P O L Y
 */
void
rt_pr_poly(title, eqn)
char		*title;
register poly	*eqn;
{
	register int	n;
	register int	exp;
	struct rt_vls	str;
	char		buf[48];

	rt_vls_init( &str );
	rt_vls_extend( &str, 196 );
	rt_vls_strcat( &str, title );
	sprintf(buf, " polynomial, degree = %d\n", eqn->dgr);
	rt_vls_strcat( &str, buf );

	exp = eqn->dgr;
	for ( n=0; n<=eqn->dgr; n++,exp-- )  {
		register double coeff = eqn->cf[n];
		if( n > 0 )  {
			if( coeff < 0 )  {
				rt_vls_strcat( &str, " - " );
				coeff = -coeff;
			}  else  {
				rt_vls_strcat( &str, " + " );
			}
		}
		sprintf( buf, "%g", coeff );
		rt_vls_strcat( &str, buf );
		if( exp > 1 )  {
			sprintf( buf, " *X^%d", exp );
			rt_vls_strcat( &str, buf );
		} else if( exp == 1 )  {

			rt_vls_strcat( &str, " *X" );
		} else {
			/* For constant term, add nothing */
		}
	}
	rt_vls_strcat( &str, "\n" );
	rt_log( "%s", rt_vls_addr(&str) );
	rt_vls_free( &str );
}

/*
 *			R T _ P R _ R O O T S
 */
void
rt_pr_roots( title, roots, n )
char	*title;
complex	roots[];
int	n;
{
	register int	i;

	rt_log("%s: %d roots:\n", title, n );
	for( i=0; i<n; i++ )  {
		rt_log("%4d %e + i * %e\n", i, roots[i].re, roots[i].im );
	}
}
@


11.1
log
@Release_4.4
@
text
@d29 1
a29 1
static char RCSpolylib[] = "@@(#)$Header: /m/cad/librt/RCS/polylib.c,v 10.6 94/12/30 10:33:45 stay Exp $ (BRL)";
@


11.1.12.1
log
@file polylib.c was added on branch rel-7-6-branch on 2005-11-13 17:44:59 +0000
@
text
@d1 551
@


11.1.12.2
log
@more merging changes from HEAD aka rel-7-6-4 to the rel-7-6-branch, adding the items that were moved and resolving rcs keyword conflicts
@
text
@a0 551
/*
 *  			P O L Y L I B . C
 *
 *	Library for dealing with polynomials.
 *
 *  Functions -
 *	rt_poly_mul		Multiply two polynomials
 *	rt_poly_scale	Scale a polynomial
 *	rt_poly_add		Add two polynomials
 *	rt_poly_sub		Subtract two polynomials
 *	rt_poly_synthetic_division		Divide 1 poly into another using Synthetic Division
 *	quadratic	Solve quadratic formula
 *	cubic		Solve cubic forumla
 *	rt_pr_poly	Print a polynomial
 *
 *  Author -
 *	Jeff Hanes
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1985 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static char RCSpolylib[] = "@@(#)$Header$ (BRL)";
#endif

#include "conf.h"

#include <stdio.h>
#include <math.h>
#include <signal.h>
#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "raytrace.h"
#include "rtstring.h"
#include "./polyno.h"
#include "./complex.h"

extern void	rt_pr_poly();

#ifndef M_PI
#define M_PI	3.14159265358979323846
#endif
#define PI_DIV_3	(M_PI/3.0)
static poly	Zpoly = { 0, 0.0 };

/*
 *	rt_poly_mul -- multiply two polynomials
 */
poly *
rt_poly_mul(m1,m2,product)
register poly	*m1, *m2, *product;
{
	if( m1->dgr == 1 && m2->dgr == 1 )  {
		product->dgr = 2;
		product->cf[0] = m1->cf[0] * m2->cf[0];
		product->cf[1] = m1->cf[0] * m2->cf[1] +
				 m1->cf[1] * m2->cf[0];
		product->cf[2] = m1->cf[1] * m2->cf[1];
		return(product);
	}
	if( m1->dgr == 2 && m2->dgr == 2 )  {
		product->dgr = 4;
		product->cf[0] = m1->cf[0] * m2->cf[0];
		product->cf[1] = m1->cf[0] * m2->cf[1] +
				 m1->cf[1] * m2->cf[0];
		product->cf[2] = m1->cf[0] * m2->cf[2] +
				 m1->cf[1] * m2->cf[1] +
				 m1->cf[2] * m2->cf[0];
		product->cf[3] = m1->cf[1] * m2->cf[2] +
				 m1->cf[2] * m2->cf[1];
		product->cf[4] = m1->cf[2] * m2->cf[2];
		return(product);
	}

	/* Not one of the common (or easy) cases. */
	{
		register int		ct1, ct2;

		*product = Zpoly;

		/* If the degree of the product will be larger than the
		 * maximum size allowed in "polyno.h", then return a null
		 * pointer to indicate failure.
		 */
		if ( (product->dgr = m1->dgr + m2->dgr) > MAXP )
			return PM_NULL;

		for ( ct1=0; ct1 <= m1->dgr; ++ct1 ){
			for ( ct2=0; ct2 <= m2->dgr; ++ct2 ){
				product->cf[ct1+ct2] +=
					m1->cf[ct1] * m2->cf[ct2];
			}
		}
	}
	return product;
}


/*
 *	rt_poly_scale -- scale a polynomial
 */
poly *
rt_poly_scale(eqn,factor)
register poly	*eqn;
double	factor;
{
	register int		cnt;

	for ( cnt=0; cnt <= eqn->dgr; ++cnt ){
		eqn->cf[cnt] *= factor;
	}
	return eqn;
}


/*
 *	rt_poly_add -- add two polynomials
 */
poly *
rt_poly_add(poly1,poly2,sum)
register poly	*poly1, *poly2, *sum;
{
	LOCAL poly		tmp;
	register int		i, offset;

	offset = Abs(poly1->dgr - poly2->dgr);

	tmp = Zpoly;

	if ( poly1->dgr >= poly2->dgr ){
		*sum = *poly1;
		for ( i=0; i <= poly2->dgr; ++i ){
			tmp.cf[i+offset] = poly2->cf[i];
		}
	} else {
		*sum = *poly2;
		for ( i=0; i <= poly1->dgr; ++i ){
			tmp.cf[i+offset] = poly1->cf[i];
		}
	}

	for ( i=0; i <= sum->dgr; ++i ){
		sum->cf[i] += tmp.cf[i];
	}
	return sum;
}


/*
 *	rt_poly_sub -- subtract two polynomials
 */
poly *
rt_poly_sub(poly1,poly2,diff)
register poly	*poly1, *poly2, *diff;
{
	LOCAL poly		tmp;
	register int		i, offset;

	offset = Abs(poly1->dgr - poly2->dgr);

	*diff = Zpoly;
	tmp = Zpoly;

	if ( poly1->dgr >= poly2->dgr ){
		*diff = *poly1;
		for ( i=0; i <= poly2->dgr; ++i ){
			tmp.cf[i+offset] = poly2->cf[i];
		}
	} else {
		diff->dgr = poly2->dgr;
		for ( i=0; i <= poly1->dgr; ++i ){
			diff->cf[i+offset] = poly1->cf[i];
		}
		tmp = *poly2;
	}

	for ( i=0; i <= diff->dgr; ++i ){
		diff->cf[i] -= tmp.cf[i];
	}
	return diff;
}


/*	>>>  s y n D i v ( )  <<<
 *	Divides any polynomial into any other polynomial using synthetic
 *	division.  Both polynomials must have real coefficients.
 */
void
rt_poly_synthetic_division(dvdend,dvsor,quo,rem)
register poly	*dvdend, *dvsor, *quo, *rem;
{
	register int	div;
	register int	n;

	*quo = *dvdend;
	*rem = Zpoly;

	if ((quo->dgr = dvdend->dgr - dvsor->dgr) < 0)
		quo->dgr = -1;
	if ((rem->dgr = dvsor->dgr - 1) > dvdend->dgr)
		rem->dgr = dvdend->dgr;

	for ( n=0; n <= quo->dgr; ++n){
		quo->cf[n] /= dvsor->cf[0];
		for ( div=1; div <= dvsor->dgr; ++div){
			quo->cf[n+div] -= quo->cf[n] * dvsor->cf[div];
		}
	}
	for ( n=1; n<=(rem->dgr+1); ++n){
		rem->cf[n-1] = quo->cf[quo->dgr+n];
		quo->cf[quo->dgr+n] = 0;
	}
}


/*	>>>  q u a d r a t i c ( )  <<<
 *
 *	Uses the quadratic formula to find the roots (in `complex' form)
 *	of any quadratic equation with real coefficients.
 */
void
rt_poly_quadratic_roots( quadrat, root )
register poly		*quadrat;
register complex	root[];
{
	LOCAL fastf_t	discrim, denom, rad;

	if( NEAR_ZERO( quadrat->cf[0], SMALL ) )  {
		/* root = -cf[2] / cf[1] */
		if( NEAR_ZERO( quadrat->cf[1], SMALL ) )  {
			/* No solution.  Now what? */
			rt_log("rt_poly_quadratic_roots(): ERROR, no solution\n");
			return;
		}
		/* Fake it as a repeated root. */
		root[0].re = root[1].re = -quadrat->cf[2]/quadrat->cf[1];
		root[0].im = root[1].im = 0.0;
		return;
	}
	/* What to do if cf[1] > SQRT_MAX_FASTF ? */

	discrim = quadrat->cf[1]*quadrat->cf[1] - 4.0* quadrat->cf[0]*quadrat->cf[2];
	denom = 0.5 / quadrat->cf[0];
	if ( discrim >= 0.0 ){
		rad = sqrt( discrim );
		root[0].re = ( -quadrat->cf[1] + rad ) * denom;
		root[1].re = ( -quadrat->cf[1] - rad ) * denom;
		root[1].im = root[0].im = 0.0;
	} else {
		root[1].re = root[0].re = -quadrat->cf[1] * denom;
		root[1].im = -(root[0].im = sqrt( -discrim ) * denom);
	}
}


#define SQRT3			1.732050808
#define THIRD			0.333333333333333333333333333
#define INV_TWENTYSEVEN		0.037037037037037037037037037
#define	CUBEROOT( a )	(( (a) >= 0.0 ) ? pow( a, THIRD ) : -pow( -(a), THIRD ))

/*	>>>  c u b i c ( )  <<<
 *
 *	Uses the cubic formula to find the roots ( in `complex' form )
 *	of any cubic equation with real coefficients.
 *
 *	to solve a polynomial of the form:
 *
 *		X**3 + c1*X**2 + c2*X + c3 = 0,
 *
 *	first reduce it to the form:
 *
 *		Y**3 + a*Y + b = 0,
 *
 *	where
 *		Y = X + c1/3,
 *	and
 *		a = c2 - c1**2/3,
 *		b = ( 2*c1**3 - 9*c1*c2 + 27*c3 )/27.
 *
 *	Then we define the value delta,   D = b**2/4 + a**3/27.
 *
 *	If D > 0, there will be one real root and two conjugate
 *	complex roots.
 *	If D = 0, there will be three real roots at least two of
 *	which are equal.
 *	If D < 0, there will be three unequal real roots.
 *
 *	Returns 1 for success, 0 for fail.
 */
static int expecting_fpe = 0;
static jmp_buf abort_buf;
HIDDEN void rt_catch_FPE(sig)
int	sig;
{
	if( !expecting_fpe )
		rt_bomb("unexpected SIGFPE!");
	if( !rt_g.rtg_parallel )
		(void)signal(SIGFPE, rt_catch_FPE);	/* Renew handler */
	longjmp(abort_buf, 1);	/* return error code */
}

int
rt_poly_cubic_roots( eqn, root )
register poly		*eqn;
register complex	root[];
{
	LOCAL fastf_t	a, b, c1, c1_3rd, delta;
	register int	i;
	static int	first_time = 1;
	
	if( !rt_g.rtg_parallel ) {
		/* abort_buf is NOT parallel! */
		if( first_time )  {
			first_time = 0;
			(void)signal(SIGFPE, rt_catch_FPE);
		}
		expecting_fpe = 1;
		if( setjmp( abort_buf ) )  {
			(void)signal(SIGFPE, rt_catch_FPE);
			rt_log("rt: rt_poly_cubic_roots() Floating Point Error\n");
			return(0);	/* FAIL */
		}
	}

	c1 = eqn->cf[1];
	if( Abs(c1) > SQRT_MAX_FASTF )  return(0);	/* FAIL */
	c1_3rd = c1 * THIRD;
	a = eqn->cf[2] - c1*c1_3rd;
	if( Abs(a) > SQRT_MAX_FASTF )  return(0);	/* FAIL */
	b = (2.0*c1*c1*c1 - 9.0*c1*eqn->cf[2] + 27.0*eqn->cf[3])*INV_TWENTYSEVEN;
	if( Abs(b) > SQRT_MAX_FASTF )  return(0);	/* FAIL */

	if( (delta = a*a) > SQRT_MAX_FASTF ) return(0);	/* FAIL */
	delta = b*b*0.25 + delta*a*INV_TWENTYSEVEN;

	if ( delta > 0.0 ){
		LOCAL fastf_t		r_delta, A, B;

		r_delta = sqrt( delta );
		A = B = -0.5 * b;
		A += r_delta;
		B -= r_delta;

		A = CUBEROOT( A );
		B = CUBEROOT( B );

		root[2].re = root[1].re = -0.5 * ( root[0].re = A + B );

		root[0].im = 0.0;
		root[2].im = -( root[1].im = (A - B)*SQRT3*0.5 );
	} else if ( delta == 0.0 ){
		LOCAL fastf_t	b_2;
		b_2 = -0.5 * b;

		root[0].re = 2.0* CUBEROOT( b_2 );
		root[2].re = root[1].re = -0.5 * root[0].re;
		root[2].im = root[1].im = root[0].im = 0.0;
	} else {
		LOCAL fastf_t		phi, fact;
		LOCAL fastf_t		cs_phi, sn_phi_s3;

		if( a >= 0.0 )  {
			fact = 0.0;
			phi = 0.0;
			cs_phi = 1.0;		/* cos( phi ); */
			sn_phi_s3 = 0.0;	/* sin( phi ) * SQRT3; */
		} else {
			FAST fastf_t	f;
			a *= -THIRD;
			fact = sqrt( a );
			if( (f = b * (-0.5) / (a*fact)) >= 1.0 )  {
				phi = 0.0;
				cs_phi = 1.0;		/* cos( phi ); */
				sn_phi_s3 = 0.0;	/* sin( phi ) * SQRT3; */
			}  else if( f <= -1.0 )  {
				phi = PI_DIV_3;
				cs_phi = cos( phi );
				sn_phi_s3 = sin( phi ) * SQRT3;
			}  else  {
				phi = acos( f ) * THIRD;
				cs_phi = cos( phi );
				sn_phi_s3 = sin( phi ) * SQRT3;
			}
		}

		root[0].re = 2.0*fact*cs_phi;
		root[1].re = fact*(  sn_phi_s3 - cs_phi);
		root[2].re = fact*( -sn_phi_s3 - cs_phi);
		root[2].im = root[1].im = root[0].im = 0.0;
	}
	for ( i=0; i < 3; ++i )
		root[i].re -= c1_3rd;
	expecting_fpe = 0;
	return(1);		/* OK */
}


/*	>>>  q u a r t i c ( )  <<<
 *
 *	Uses the quartic formula to find the roots ( in `complex' form )
 *	of any quartic equation with real coefficients.
 *
 *	Returns 1 for success, 0 for fail.
 */
int
rt_poly_quartic_roots( eqn, root )
register poly		*eqn;
register complex	root[];
{
	LOCAL poly		cube, quad1, quad2;
	LOCAL complex		u[3];
	LOCAL fastf_t		U, p, q, q1, q2;
#define Max3(a,b,c) ((c)>((a)>(b)?(a):(b)) ? (c) : ((a)>(b)?(a):(b)))

	cube.dgr = 3;
	cube.cf[0] = 1.0;
	cube.cf[1] = -eqn->cf[2];
	cube.cf[2] = eqn->cf[3]*eqn->cf[1]
			- 4*eqn->cf[4];
	cube.cf[3] = -eqn->cf[3]*eqn->cf[3]
			- eqn->cf[4]*eqn->cf[1]*eqn->cf[1]
			+ 4*eqn->cf[4]*eqn->cf[2];

	if( !rt_poly_cubic_roots( &cube, u ) )  {
		return( 0 );		/* FAIL */
	}
	if ( u[1].im != 0.0 ){
		U = u[0].re;
	} else {
		U = Max3( u[0].re, u[1].re, u[2].re );
	}

	p = eqn->cf[1]*eqn->cf[1]*0.25 + U - eqn->cf[2];
	U *= 0.5;
	q = U*U - eqn->cf[4];
	if( p < 0 )  {
		if( p < -1.0e-8 )  {
			return(0);	/* FAIL */
		}
		p = 0;
	} else {
		p = sqrt( p );
	}
	if( q < 0 )  {
		if( q < -1.0e-8 )  {
			return(0);	/* FAIL */
		}
		q = 0;
	} else {
		q = sqrt( q );
	}

	quad1.dgr = quad2.dgr = 2;
	quad1.cf[0] = quad2.cf[0] = 1.0;
	quad1.cf[1] = eqn->cf[1]*0.5;
	quad2.cf[1] = quad1.cf[1] + p;
	quad1.cf[1] -= p;
	
	q1 = U - q;
	q2 = U + q;

	p = quad1.cf[1]*q2 + quad2.cf[1]*q1 - eqn->cf[3];
	if( Abs( p ) < 1.0e-8){
		quad1.cf[2] = q1;
		quad2.cf[2] = q2;
	} else {
		q = quad1.cf[1]*q1 + quad2.cf[1]*q2 - eqn->cf[3];
		if( Abs( q ) < 1.0e-8 ){
			quad1.cf[2] = q2;
			quad2.cf[2] = q1;
		} else {
			return(0);	/* FAIL */
		}
	}

	rt_poly_quadratic_roots( &quad1, root );
	rt_poly_quadratic_roots( &quad2, &root[2] );
	return(1);		/* SUCCESS */
}


/*
 *			R T _ P R _ P O L Y
 */
void
rt_pr_poly(title, eqn)
char		*title;
register poly	*eqn;
{
	register int	n;
	register int	exp;
	struct rt_vls	str;
	char		buf[48];

	rt_vls_init( &str );
	rt_vls_extend( &str, 196 );
	rt_vls_strcat( &str, title );
	sprintf(buf, " polynomial, degree = %d\n", eqn->dgr);
	rt_vls_strcat( &str, buf );

	exp = eqn->dgr;
	for ( n=0; n<=eqn->dgr; n++,exp-- )  {
		register double coeff = eqn->cf[n];
		if( n > 0 )  {
			if( coeff < 0 )  {
				rt_vls_strcat( &str, " - " );
				coeff = -coeff;
			}  else  {
				rt_vls_strcat( &str, " + " );
			}
		}
		sprintf( buf, "%g", coeff );
		rt_vls_strcat( &str, buf );
		if( exp > 1 )  {
			sprintf( buf, " *X^%d", exp );
			rt_vls_strcat( &str, buf );
		} else if( exp == 1 )  {

			rt_vls_strcat( &str, " *X" );
		} else {
			/* For constant term, add nothing */
		}
	}
	rt_vls_strcat( &str, "\n" );
	rt_log( "%s", rt_vls_addr(&str) );
	rt_vls_free( &str );
}

/*
 *			R T _ P R _ R O O T S
 */
void
rt_pr_roots( title, roots, n )
char	*title;
complex	roots[];
int	n;
{
	register int	i;

	rt_log("%s: %d roots:\n", title, n );
	for( i=0; i<n; i++ )  {
		rt_log("%4d %e + i * %e\n", i, roots[i].re, roots[i].im );
	}
}
@


11.1.10.1
log
@sync branch with HEAD
@
text
@d29 1
a29 1
static char RCSpolylib[] = "@@(#)$Header$ (BRL)";
@


11.1.8.1
log
@sync to HEAD...
@
text
@d29 1
a29 1
static char RCSpolylib[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/Attic/polylib.c,v 11.1 1995/01/04 09:58:26 mike Rel4_4 $ (BRL)";
@


11.1.6.1
log
@updates from HEAD, part 1
@
text
@d29 1
a29 1
static char RCSpolylib[] = "@@(#)$Header: /c/CVS/brlcad/librt/Attic/polylib.c,v 11.1 1995/01/04 09:58:26 mike Rel4_4 $ (BRL)";
@


11.1.6.2
log
@merge from HEAD
@
text
@@


11.1.6.3
log
@merge from head
@
text
@d29 1
a29 1
static char RCSpolylib[] = "@@(#)$Header: /c/CVS/brlcad/librt/Attic/polylib.c,v 11.1.6.2 2004/02/12 18:37:47 erikg Exp $ (BRL)";
@


11.1.4.1
log
@Merged head into branch
@
text
@d29 1
a29 1
static char RCSpolylib[] = "@@(#)$Header: /c/CVS/brlcad/librt/Attic/polylib.c,v 11.1 1995/01/04 09:58:26 mike Rel4_4 $ (BRL)";
@


11.1.2.1
log
@updated for merging
@
text
@d29 1
a29 1
static char RCSpolylib[] = "@@(#)$Header: /c/CVS/brlcad/librt/Attic/polylib.c,v 11.1 1995/01/04 09:58:26 mike Rel4_4 $ (BRL)";
@


10.6
log
@deleted extra call to setjmp.h since raytrace.h always calls setjmp.h 
anyways
@
text
@d29 1
a29 1
static char RCSpolylib[] = "@@(#)$Header: /m/cad/librt/RCS/polylib.c,v 10.5 94/12/27 17:14:38 mike Exp Locker: stay $ (BRL)";
@


10.5
log
@Fix to bug #247
Added rt_prefix and regularized names like polyRoots into rt_poly_roots.
@
text
@d29 1
a29 1
static char RCSpolylib[] = "@@(#)$Header: /m/cad/librt/RCS/polylib.c,v 10.4 94/12/22 00:25:28 mike Exp Locker: mike $ (BRL)";
a36 1
#include <setjmp.h>
@


10.4
log
@From: Ingbert Graf <graf@@conmuc.de.convex.com>
HP couldn't handle previous Max3 macro.
@
text
@d7 5
a11 5
 *	polyMul		Multiply two polynomials
 *	polyScal	Scale a polynomial
 *	polyAdd		Add two polynomials
 *	polySub		Subtract two polynomials
 *	synDiv		Divide 1 poly into another using Synthetic Division
d29 1
a29 1
static char RCSpolylib[] = "@@(#)$Header: /m/cad/librt/RCS/polylib.c,v 10.3 94/08/23 17:27:15 gdurf Exp Locker: mike $ (BRL)";
d55 1
a55 1
 *	polyMul -- multiply two polynomials
d58 1
a58 1
polyMul(m1,m2,product)
d108 1
a108 1
 *	polyScal -- scale a polynomial
d111 1
a111 1
polyScal(eqn,factor)
d125 1
a125 1
 *	polyAdd -- add two polynomials
d128 1
a128 1
polyAdd(poly1,poly2,sum)
d158 1
a158 1
 *	polySub -- subtract two polynomials
d161 1
a161 1
polySub(poly1,poly2,diff)
d197 1
a197 1
synDiv(dvdend,dvsor,quo,rem)
d230 1
a230 1
quadratic( quadrat, root )
d240 1
a240 1
			rt_log("quadratic(): ERROR, no solution\n");
d300 1
a300 1
HIDDEN void catch_FPE(sig)
d306 1
a306 1
		(void)signal(SIGFPE, catch_FPE);	/* Renew handler */
d311 1
a311 1
cubic( eqn, root )
d323 1
a323 1
			(void)signal(SIGFPE, catch_FPE);
d327 2
a328 2
			(void)signal(SIGFPE, catch_FPE);
			rt_log("rt: cubic() Floating Point Error\n");
d414 1
a414 1
quartic( eqn, root )
d432 1
a432 1
	if( !cubic( &cube, u ) )  {
d484 2
a485 2
	quadratic( &quad1, root );
	quadratic( &quad2, &root[2] );
@


10.3
log
@Fix typo
@
text
@d29 1
a29 1
static char RCSpolylib[] = "@@(#)$Header: /m/cad/librt/RCS/polylib.c,v 10.2 1994/08/10 19:37:47 gdurf Exp gdurf $ (BRL)";
d421 1
a421 1
#define Max3( a, b, c )		( Max( c, Max( a, b )) )
@


10.2
log
@Factored ifdefs
@
text
@d29 1
a29 1
static char RCSpolylib[] = "@@(#)$Header: /m/cad/librt/RCS/polylib.c,v 10.1 1991/10/12 06:40:55 mike Rel4_0 gdurf $ (BRL)";
d39 1
d41 1
d304 2
a305 2
		rt_bomb("unexpected SIGFPE! sig=%d\n", sig);
	if( !rt_g.parallel )
d319 1
a319 1
	if( !rt_g.parallel ) {
@


10.1
log
@Release_4.0
@
text
@d29 1
a29 1
static char RCSpolylib[] = "@@(#)$Header: /m/cad/librt/RCS/polylib.c,v 9.3 91/07/19 01:05:12 mike Exp $ (BRL)";
d32 2
d303 2
a304 3
#ifdef SYSV
	(void)signal(SIGFPE, catch_FPE);	/* Renew handler */
#endif				
d317 12
a328 11
#if !defined(PARALLEL) && !defined(CRAY)
	/* abort_buf is NOT parallel! */
	if( first_time )  {
		first_time = 0;
		(void)signal(SIGFPE, catch_FPE);
	}
	expecting_fpe = 1;
	if( setjmp( abort_buf ) )  {
		(void)signal(SIGFPE, catch_FPE);
		rt_log("rt: cubic() Floating Point Error\n");
		return(0);	/* FAIL */
a329 1
#endif
@


9.3
log
@"quad" seems to be a reserved word on the IBM
@
text
@d29 1
a29 1
static char RCSpolylib[] = "@@(#)$Header: /m/cad/librt/RCS/polylib.c,v 9.2 91/03/13 16:41:16 mike Exp $ (BRL)";
@


9.2
log
@Added lots of error checking to try to avoid floating point exceptions.
(And seriously wrong results!)
This fixes the "TGC at az=0" bug.
Still more error checking could be done.
@
text
@d29 1
a29 1
static char RCSpolylib[] = "@@(#)$Header: /m/cad/librt/RCS/polylib.c,v 9.1 89/05/19 05:56:58 mike Rel3_5 $ (BRL)";
d226 2
a227 2
quadratic( quad, root )
register poly		*quad;
d232 1
a232 1
	if( NEAR_ZERO( quad->cf[0], SMALL ) )  {
d234 1
a234 1
		if( NEAR_ZERO( quad->cf[1], SMALL ) )  {
d240 1
a240 1
		root[0].re = root[1].re = -quad->cf[2]/quad->cf[1];
d246 2
a247 2
	discrim = quad->cf[1]*quad->cf[1] - 4.0* quad->cf[0]*quad->cf[2];
	denom = 0.5 / quad->cf[0];
d250 2
a251 2
		root[0].re = ( -quad->cf[1] + rad ) * denom;
		root[1].re = ( -quad->cf[1] - rad ) * denom;
d254 1
a254 1
		root[1].re = root[0].re = -quad->cf[1] * denom;
@


9.1
log
@Release_3.5
@
text
@d14 1
a14 1
 *	pr_poly		Print a polynomial
d29 1
a29 1
static char RCSpolylib[] = "@@(#)$Header: polylib.c,v 8.2 89/03/06 16:07:01 mike Exp $ (BRL)";
d38 1
d42 2
d232 14
d331 1
d334 1
d336 1
d338 2
a339 1
	delta = b*b*0.25 + a*a*a*INV_TWENTYSEVEN;
d367 1
a367 2
		if( a > 0.0 )  {
			rt_log("cubic: sqrt(%f)\n", fact);
d370 4
a373 1
		} else {	FAST fastf_t	f;
d376 1
a376 1
			if( (f = b * (-0.5) / (a*fact)) >= 1.0 )
d378 3
a380 2
			else
			if( f <= -1.0 )
d382 3
a384 1
			else
d386 3
a389 2
		cs_phi = cos( phi );
		sn_phi_s3 = sin( phi ) * SQRT3;
d429 1
a429 1
	if( !cubic( &cube, u ) )
d431 1
a437 1
#define NearZero( a )		{ if ( a < 0.0 && a > -1.0e-8 ) a = 0.0; }
d441 5
a445 4
	NearZero( p );
	NearZero( q );
	if ( p < 0 || q < 0 ){
		return(0);	/* FAIL */
d448 7
d472 2
a473 2
		p = quad1.cf[1]*q1 + quad2.cf[1]*q2 - eqn->cf[3];
		if( Abs( p ) < 1.0e-8 ){
d476 1
a476 1
		} else
d478 1
d488 1
a488 1
 *			P R _ P O L Y
d491 2
a492 1
pr_poly(eqn)
d496 3
d500 28
a527 3
	rt_log("\nDegree of polynomial = %d\n",eqn->dgr);
	for ( n=0; n<=eqn->dgr; ++n){
		rt_log(" %g ",eqn->cf[n]);
d529 20
a548 1
	rt_log("\n");
@


9.1.1.1
log
@Revisions from 13-March-91 version of the source,
applied to BRL-CAD Release 3.7

@
text
@a0 6
#if defined(vax) || (defined(sgi) && !defined(mips))
#define SQRT_MAX_FASTF		1.0e18	/* This squared just avoids overflow */
#else
#define SQRT_MAX_FASTF		1.0e36	/* This squared just avoids overflow */
#endif

d29 1
a29 1
static char RCSpolylib[] = "@@(#)$Header: polylib.c,v 9.1 89/05/19 05:56:58 mike Rel3_5 $ (BRL)";
a313 1
	if( Abs(c1) > SQRT_MAX_FASTF )  return(0);	/* FAIL */
a315 1
	if( Abs(a) > SQRT_MAX_FASTF )  return(0);	/* FAIL */
a316 1
	if( Abs(b) > SQRT_MAX_FASTF )  return(0);	/* FAIL */
d318 1
a318 2
	if( (delta = a*a) > SQRT_MAX_FASTF ) return(0);	/* FAIL */
	delta = b*b*0.25 + delta*a*INV_TWENTYSEVEN;
d346 1
a346 1
		if( a >= 0.0 )  {
@


8.2
log
@ansii signal handling
@
text
@d29 1
a29 1
static char RCSpolylib[] = "@@(#)$Header: polylib.c,v 8.1 88/10/05 00:31:32 mike Locked $ (BRL)";
@


8.1
log
@Release_3.0
@
text
@d29 1
a29 1
static char RCSpolylib[] = "@@(#)$Header: polylib.c,v 7.2 88/09/17 07:02:26 mike Exp $ (BRL)";
d279 3
a281 1
HIDDEN void catch_FPE()  {
d283 1
a283 1
		rt_bomb("unexpected SIGFPE!\n");
@


7.2
log
@cray-->CRAY
@
text
@d29 1
a29 1
static char RCSpolylib[] = "@@(#)$Header: polylib.c,v 7.1 87/11/02 23:33:50 mike Locked $ (BRL)";
@


7.1
log
@Release 2.3
@
text
@d29 1
a29 1
static char RCSpolylib[] = "@@(#)$Header: polylib.c,v 6.1 87/07/11 07:56:09 mike Rel $ (BRL)";
d297 1
a297 1
#ifndef PARALLEL
a300 1
#ifndef cray
a301 1
#endif cray
@


6.1
log
@Release 2.0
@
text
@d29 1
a29 1
static char RCSpolylib[] = "@@(#)$Header: polylib.c,v 5.1 87/06/24 22:11:55 mike Rel $ (BRL)";
@


5.1
log
@Release 1.24
@
text
@d29 1
a29 1
static char RCSpolylib[] = "@@(#)$Header: polylib.c,v 4.2 87/02/12 22:11:35 mike Exp $ (BRL)";
@


4.2
log
@Release 1.20 -- First Formal Release
@
text
@d29 1
a29 1
static char RCSpolylib[] = "@@(#)$Header: polylib.c,v 4.1 86/12/29 03:45:35 mike Rel1 $ (BRL)";
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d29 1
a29 1
static char RCSpolylib[] = "@@(#)$Header: polylib.c,v 3.5 86/12/19 04:19:59 mike Exp $ (BRL)";
@


3.5
log
@Don't bother with signals on Cray -- exponent range is huge
@
text
@d29 1
a29 1
static char RCSpolylib[] = "@@(#)$Header: polylib.c,v 3.4 86/12/13 05:42:32 mike Locked $ (BRL)";
@


3.4
log
@Improved handling of machine epsilon with some new defines.
@
text
@d29 1
a29 1
static char RCSpolylib[] = "@@(#)$Header: polylib.c,v 3.3 86/10/11 02:18:35 mike Locked $ (BRL)";
d301 1
d303 1
@


3.3
log
@Added SYSV code for SIGFPE
@
text
@d29 1
a29 1
static char RCSpolylib[] = "@@(#)$Header: polylib.c,v 3.2 86/08/12 04:16:05 mike Exp $ (BRL)";
d408 1
a408 1
#define NearZero( a )		{ if ( a < 0.0 && a > -SMALL ) a = 0.0; }
d431 1
a431 1
	if( Abs( p ) < SMALL){
d436 1
a436 1
		if( Abs( p ) < SMALL ){
@


3.2
log
@Changed #include directives for use with CC -I convention
@
text
@d29 1
a29 1
static char RCSpolylib[] = "@@(#)$Header: polylib.c,v 3.1 86/07/11 01:32:19 mike Exp $ (BRL)";
d282 3
d297 1
a297 1
#ifndef HEP
@


3.1
log
@Cleanups inspired by the crummy compiler on the Cray XMP
@
text
@d29 1
a29 1
static char RCSpolylib[] = "@@(#)$Header: polylib.c,v 3.0 86/06/10 01:33:22 mike Exp $ (BRL)";
d36 4
a39 4
#include "../h/machine.h"
#include "../h/vmath.h"
#include "polyno.h"
#include "complex.h"
@


3.0
log
@rt/ and librt/ separated,
global datastructures simplified.
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: polylib.c,v 2.3 85/11/19 21:18:05 mike Exp $ (BRL)";
@


2.3
log
@Fixed bad calls to acos().
Optimizations by Moss, Gwyn, and Ron.
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: polylib.c,v 2.2 85/09/10 00:28:14 mike Exp $ (BRL)";
d40 1
a40 1
#include "debug.h"
d281 1
a281 1
		rtbomb("unexpected SIGFPE!\n");
d303 1
a303 4
		rtlog("rt: cubic() Floating Point Error\n");
		if( debug & DEBUG_ROOTS )  {
			pr_poly(eqn);
		}
d342 1
a342 1
			rtlog("cubic: sqrt(%f)\n", fact);
d455 1
a455 1
	rtlog("\nDegree of polynomial = %d\n",eqn->dgr);
d457 1
a457 1
		rtlog(" %g ",eqn->cf[n]);
d459 1
a459 1
	rtlog("\n");
@


2.2
log
@Made FPE catcher HIDDEN instead of static, with new name, so
that it shows up better in core dumps.
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: polylib.c,v 2.1 85/08/31 06:05:39 mike Exp $ (BRL)";
d41 4
a44 1

a233 1
		root[0].im = 0.0;
d235 1
a235 1
		root[1].im = 0.0;
d237 2
a238 5
		rad = sqrt( -discrim );
		root[0].re = -quad->cf[1] * denom;
		root[0].im =  rad * denom;
		root[1].re = -quad->cf[1] * denom;
		root[1].im = -rad * denom;
d246 1
a246 1
#define	CUBEROOT( a )	(( a >= 0.0 ) ? pow( a, THIRD ) : -pow( -a, THIRD ))
d290 1
a290 1
	LOCAL fastf_t	a, b, c1, delta;
d312 2
a313 2

	a = eqn->cf[2] - c1*c1*THIRD;
d322 3
a324 2
		A = -0.5 * b + r_delta;
		B = -0.5 * b - r_delta;
d342 1
a342 1
		LOCAL fastf_t		cs_phi, sn_phi;
d344 1
a344 1
		if( (fact = -THIRD * a) < 0.0 )  {
d348 10
a357 3
		} else {
			fact = sqrt( fact );
			phi = acos( b * (-0.5) / (fact*fact*fact) ) * THIRD;
d360 1
a360 1
		sn_phi = sin( phi );
d362 3
a364 4
		root[0].re = 2.0*fact*cs_phi; 
		root[1].re = fact*(  SQRT3*sn_phi - cs_phi);
		root[2].re = fact*( -SQRT3*sn_phi - cs_phi);

d367 2
a368 3
	for ( i=0; i < 3; ++i ){
		root[i].re -= c1 * THIRD;
	}
d410 2
a411 1
	q = U*U*0.25 - eqn->cf[4];
d423 6
a428 4
	quad1.cf[1] = eqn->cf[1]*0.5 - p;
	quad2.cf[1] = eqn->cf[1]*0.5 + p;
	q1 = U*0.5 - q;
	q2 = U*0.5 + q;
@


2.1
log
@Version 2 of RT
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: polylib.c,v 1.14 85/07/30 05:54:15 mike Exp $ (BRL)";
d280 1
a280 1
static void cubic_catch()  {
d299 1
a299 1
		(void)signal(SIGFPE, cubic_catch);
d303 1
a303 1
		(void)signal(SIGFPE, cubic_catch);
@


1.14
log
@Changes for merged GED & RT vmath.h
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: polylib.c,v 1.13 85/06/05 01:44:37 mike Exp $ (BRL)";
d295 2
d304 1
a304 1
		fprintf(stderr,"rt: cubic() Floating Point Error\n");
d310 1
d345 1
a345 1
			fprintf(stderr,"cubic: sqrt(%f)\n", fact);
d450 1
a450 1
	fprintf(stderr,"\nDegree of polynomial = %d\n",eqn->dgr);
d452 1
a452 1
		fprintf(stderr," %g ",eqn->cf[n]);
d454 1
a454 1
	fprintf(stderr,"\n");
@


1.13
log
@Shuffled error printing.
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: polylib.c,v 1.12 85/06/03 17:29:20 mike Exp $ (BRL)";
d36 2
a37 1
#include "vmath.h"
@


1.12
log
@Cleanups to allow compilation on SGI IRIS 2400.
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: polylib.c,v 1.11 85/03/29 22:34:52 mike Exp $ (BRL)";
a293 1

d301 1
a302 1
			fprintf(stderr,"cubic Floating Point Error on:\n");
@


1.11
log
@Added error checking, improved efficiency;
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: polylib.c,v 1.10 85/03/27 11:57:28 mike Exp $ (BRL)";
d246 1
a246 1
#define	CUBEROOT( a )	( a >= 0.0 ) ? pow( a, THIRD ) : -pow( -a, THIRD )
@


1.10
log
@Changed to only call signal(SIGFPE) once, rather than every time.
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: polylib.c,v 1.9 85/03/25 11:53:43 mike Exp $ (BRL)";
d226 1
a226 1
	denom = 2.0* quad->cf[0];
d229 1
a229 1
		root[0].re = ( -quad->cf[1] + rad )/ denom;
d231 1
a231 1
		root[1].re = ( -quad->cf[1] - rad )/ denom;
d235 4
a238 4
		root[0].re = -quad->cf[1] / denom;
		root[0].im =  rad / denom;
		root[1].re = -quad->cf[1] / denom;
		root[1].im = -rad / denom;
d243 5
d311 2
a312 2
	a = eqn->cf[2] - c1*c1/3.0;
	b = ( 2.0*c1*c1*c1 - 9.0*c1*eqn->cf[2] + 27.0*eqn->cf[3] )/27.0;
d314 1
a314 1
	delta = b*b/4.0 + a*a*a/27.0;
a315 5
#define SQRT3			1.732050808

#define third			.3333333333333333333333333
#define	CubeRoot( a )	( a >= 0.0 ) ? pow( a, third ) : -pow( -a, third )

d320 2
a321 2
		A = -b*0.5 + r_delta;
		B = -b*0.5 - r_delta;
d323 2
a324 2
		A = CubeRoot( A );
		B = CubeRoot( B );
d326 1
a326 1
		root[2].re = root[1].re = -( root[0].re = A + B )*0.5;
d332 1
a332 1
		b_2 = -b*0.5;
d334 2
a335 2
		root[0].re = 2.0* CubeRoot( b_2 );
		root[2].re = root[1].re = -root[0].re*0.5;
d338 1
a338 1
		LOCAL fastf_t		cs_3phi, phi, fact;
d341 8
a348 3
		fact = sqrt( -a/3.0 );
		cs_3phi = ( -b*0.5 )/( fact*fact*fact );
		phi = acos( cs_3phi )/3.0;
d353 2
a354 2
		root[1].re = fact*( -cs_phi + SQRT3*sn_phi );
		root[2].re = fact*( -cs_phi - SQRT3*sn_phi );
d359 1
a359 1
		root[i].re -= c1/3.0;
d401 2
a402 2
	p = eqn->cf[1]*eqn->cf[1]/4.0 + U - eqn->cf[2];
	q = U*U/4.0 - eqn->cf[4];
d418 3
a420 1
	if ( Abs( quad1.cf[1]*q2 + quad2.cf[1]*q1 - eqn->cf[3] ) < SMALL){
a422 3
	} else if ( Abs( quad1.cf[1]*q1 + quad2.cf[1]*q2 - eqn->cf[3]) < SMALL ){
		quad1.cf[2] = q2;
		quad2.cf[2] = q1;
d424 6
a429 1
		return(0);	/* FAIL */
@


1.9
log
@Added include for debug.h
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: polylib.c,v 1.8 85/03/25 11:46:37 mike Exp $ (BRL)";
d272 1
d275 2
d285 4
a288 3
	LOCAL fastf_t		a, b, c1, delta;
	register int		i;
	void (*sav)();
d290 5
a294 1
	sav=signal(SIGFPE, cubic_catch);
d296 1
a296 1
		signal(SIGFPE, sav);
d356 1
a356 1
	(void)signal(SIGFPE, sav);
@


1.8
log
@Housekeeping
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d39 1
@


1.7
log
@Added special cases to polyMul() for substantial efficiency gain.
@
text
@d2 25
a26 1
 *  		P O L Y L I B . C
d28 4
a272 1
	fprintf(stderr,"cubic FPE\n");
d288 4
a291 1
		pr_poly(eqn);
@


1.6
log
@Added error returns from cubic() and quartic(),
tried to add SIGFPE catching within cubic().
@
text
@d18 2
a19 2
polyMul(mult1,mult2,product)
register poly	*mult1, *mult2, *product;
d21 21
a41 1
	register int		ct1, ct2;
d43 3
a45 1
	*product = Zpoly;
d47 1
a47 6
	/* If the degree of the product will be larger than the
	 * maximum size allowed in "polyno.h", then return a null
	 * pointer to indicate failure.
	 */
	if ( (product->dgr = mult1->dgr + mult2->dgr) > MAXP )
		return PM_NULL;
d49 12
a60 3
	for ( ct1=0; ct1 <= mult1->dgr; ++ct1 ){
		for ( ct2=0; ct2 <= mult2->dgr; ++ct2 ){
			product->cf[ct1+ct2] += mult1->cf[ct1]*mult2->cf[ct2];
@


1.5
log
@Added LOCAL, fastf_t declarations.
Made shootray() recursive.
@
text
@d6 2
d214 2
d217 7
a223 1
void
a226 1

d230 1
d232 7
d255 2
a256 2
		A = -b/2.0 + r_delta;
		B = -b/2.0 - r_delta;
d261 1
a261 1
		root[2].re = root[1].re = -( root[0].re = A + B )/2.0;
d264 1
a264 1
		root[2].im = -( root[1].im = (A - B)*SQRT3/2.0 );
d267 1
a267 1
		b_2 = -b/2.0;
d270 1
a270 1
		root[2].re = root[1].re = -root[0].re/2.0;
d277 1
a277 1
		cs_3phi = ( -b/2.0 )/( fact*fact*fact );
d291 2
d300 2
d303 1
a303 1
void
a306 1

d322 2
a323 1
	cubic( &cube, u );
d336 1
a336 1
		return;
d344 4
a347 4
	quad1.cf[1] = eqn->cf[1]/2.0 - p;
	quad2.cf[1] = eqn->cf[1]/2.0 + p;
	q1 = U/2.0 - q;
	q2 = U/2.0 + q;
d355 1
a355 1
		return;
d360 1
@


1.4
log
@General cleanup
@
text
@d4 5
a8 4
#include	<stdio.h>
#include	<math.h>
#include	"./polyno.h"
#include	"./complex.h"
d63 1
a63 1
	static poly		tmp;
d96 1
a96 1
	static poly		tmp;
d166 1
a166 1
	static double	discrim, denom, rad;
d219 1
a219 1
	static double		a, b, c1, delta;
d235 1
a235 1
		static double		r_delta, A, B;
d249 1
a249 1
		static double	b_2;
d256 2
a257 2
		static double		cs_3phi, phi, fact;
		static double		cs_phi, sn_phi;
d288 3
a290 3
	static poly		cube, quad1, quad2;
	static complex		u[3];
	static double		U, p, q, q1, q2;
@


1.3
log
@New version from Jeff Haynes
@
text
@d1 5
a7 1
#include	<math.h>
d9 1
a9 1
poly	Zpoly = { 0, 0.0 };
d342 1
a342 1
 *			P R N T P O L Y
d345 1
a345 1
prntpoly(eqn)
d350 1
a350 1
	printf("\nDegree of polynomial = %d\n",eqn->dgr);
d352 1
a352 1
		printf(" %g ",eqn->cf[n]);
d354 1
a354 1
	printf("\n");
@


1.2
log
@Efficiency modifications.
@
text
@a4 2
#define	Abs( a )	((a) >= 0 ? (a) : -(a))

d153 1
a153 1
 *	Uses the quadratic formula to find the roots (in 'complex' form)
d157 1
a157 1
quadratic(quad,root1,root2)
d159 1
a159 1
register complex	*root1, *root2;
d161 1
a161 1
	static double	discrim, denom;
a164 1

d166 5
a170 4
		root1->re = ( -quad->cf[1] + sqrt(discrim) )/ denom;
		root1->im = 0.0;
		root2->re = ( -quad->cf[1] - sqrt(discrim) )/ denom;
		root2->im = 0.0;
d172 5
a176 5
		discrim = Abs(discrim);
		root1->re = -quad->cf[1] / denom;
		root1->im =  sqrt(discrim) / denom;
		root2->re = -quad->cf[1] / denom;
		root2->im = -sqrt(discrim) / denom;
d179 157
@


1.1
log
@Initial revision
@
text
@d10 2
a11 5
	polyMul -- multiply two polynomials


*/

d14 1
a14 2
poly	*mult1, *mult2, *product;

d37 2
a38 5
	polyScal -- scale a polynomial


*/

d41 1
a41 1
poly	*eqn;
a42 1

d54 2
a55 6
	polyAdd -- add two polynomials



*/

d58 1
a58 2
poly	*poly1, *poly2, *sum;

d60 1
a60 1
	poly			tmp;
d87 2
a88 6
	polySub -- subtract two polynomials



*/

d91 1
a91 2
poly	*poly1, *poly2, *diff;

d93 1
a93 1
	poly			tmp;
d127 1
a127 2
poly	*dvdend, *dvsor, *quo, *rem;

d129 2
a130 1
 	int	qcnt, div, rno;
d140 2
a141 2
	for ( qcnt=0; qcnt <= quo->dgr; ++qcnt){
		quo->cf[qcnt] /= dvsor->cf[0];
d143 1
a143 1
			quo->cf[qcnt+div] -= quo->cf[qcnt] * dvsor->cf[div];
d146 3
a148 3
	for ( rno=1; rno<=(rem->dgr+1); ++rno){
		rem->cf[rno-1] = quo->cf[quo->dgr+rno];
		quo->cf[quo->dgr+rno] = 0;
a149 1
	return;
d154 1
d160 2
a161 3
poly		*quad;
complex		*root1, *root2;

d163 1
a163 1
	double		discrim, denom;
a179 1
	return;
d182 3
a184 1

d187 1
a187 2
poly	*eqn;

d189 1
a189 1
	int	n;  /*  trivial loop counter  */
a195 2

	return;
a196 1

@
