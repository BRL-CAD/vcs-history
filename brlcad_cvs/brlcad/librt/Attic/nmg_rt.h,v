head	11.7;
access;
symbols
	rel-5-0:11.6
	rel-5-0-beta:11.6
	rel-4-5:11.6
	ctj-4-5-post:11.6
	ctj-4-5-pre:11.6
	rel-4-4:11.1;
locks; strict;
comment	@ * @;


11.7
date	99.12.18.00.44.45;	author mike;	state dead;
branches;
next	11.6;

11.6
date	97.01.09.16.33.11;	author jra;	state Exp;
branches;
next	11.5;

11.5
date	97.01.07.22.58.23;	author jra;	state Exp;
branches;
next	11.4;

11.4
date	97.01.07.16.08.21;	author jra;	state Exp;
branches;
next	11.3;

11.3
date	96.05.16.21.45.55;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	95.02.17.09.14.48;	author butler;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.58.14;	author mike;	state Rel4_4;
branches;
next	1.14;

1.14
date	94.09.21.03.37.50;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	94.08.24.22.48.45;	author butler;	state Exp;
branches;
next	1.12;

1.12
date	94.08.20.05.28.08;	author butler;	state Exp;
branches;
next	1.11;

1.11
date	94.07.01.01.38.30;	author butler;	state Exp;
branches;
next	1.10;

1.10
date	94.06.22.03.08.42;	author butler;	state Exp;
branches;
next	1.9;

1.9
date	94.06.21.18.40.41;	author butler;	state Exp;
branches;
next	1.8;

1.8
date	94.06.15.23.42.37;	author butler;	state Exp;
branches;
next	1.7;

1.7
date	94.02.24.06.43.48;	author butler;	state Exp;
branches;
next	1.6;

1.6
date	93.10.20.01.03.35;	author butler;	state Exp;
branches;
next	1.5;

1.5
date	93.09.02.16.17.19;	author butler;	state Exp;
branches;
next	1.4;

1.4
date	93.09.01.20.22.30;	author butler;	state Exp;
branches;
next	1.3;

1.3
date	93.09.01.01.26.54;	author butler;	state Exp;
branches;
next	1.2;

1.2
date	93.07.23.15.56.10;	author butler;	state Exp;
branches;
next	1.1;

1.1
date	93.06.04.17.08.11;	author butler;	state Exp;
branches;
next	;


desc
@Header file for structures used in ray-tracing NMG's
@


11.7
log
@
The contents were long ago moved into raytrace.h
@
text
@/*
 *			N M G _ R T . H
 */

/* This file is now part of raytrace.h */
@


11.6
log
@Moved nmg_rt.h into raytrace.h.
@
text
@@


11.5
log
@Changed plane_pt in struct ray data to a point_t instead of pointp_t.
@
text
@a2 18
 *
 *  Author -
 *	Lee A. Butler
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1994 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 *
 *  $Header: /m/cad/librt/RCS/nmg_rt.h,v 11.4 1997/01/07 16:08:21 jra Exp jra $
d5 1
a5 208
/* defining the following flag will improve NMG raytrace speed by eliminating some checking
 * Use with CAUTION!!! */
#define FAST_NMG	1

#define NMG_HIT_LIST	0
#define NMG_MISS_LIST	1
#define NMG_RT_HIT_MAGIC 0x48697400	/* "Hit" */
#define NMG_RT_HIT_SUB_MAGIC 0x48696d00	/* "Him" */
#define NMG_RT_MISS_MAGIC 0x4d697300	/* "Mis" */


/* These values are for the hitmiss "in_out" variable and indicate the
 * nature of the hit when known
 */
#define HMG_INBOUND_STATE(_hm) (((_hm)->in_out & 0x0f0) >> 4)
#define HMG_OUTBOUND_STATE(_hm) ((_hm)->in_out & 0x0f)


#define NMG_RAY_STATE_INSIDE	1
#define NMG_RAY_STATE_ON	2
#define NMG_RAY_STATE_OUTSIDE	4

#define HMG_HIT_IN_IN	0x11	/* hit internal structure */
#define HMG_HIT_IN_OUT	0x14	/* breaking out */
#define HMG_HIT_OUT_IN	0x41	/* breaking in */
#define HMG_HIT_OUT_OUT 0x44	/* edge/vertex graze */
#define HMG_HIT_IN_ON	0x12
#define HMG_HIT_ON_IN	0x21
#define HMG_HIT_ON_ON	0x22
#define HMG_HIT_OUT_ON	0x42
#define HMG_HIT_ON_OUT	0x24
#define HMG_HIT_ANY_ANY	0x88	/* hit on non-3-mainifold */

#define	NMG_VERT_ENTER 1
#define NMG_VERT_ENTER_LEAVE 0
#define NMG_VERT_LEAVE -1
#define NMG_VERT_UNKNOWN -2

#define NMG_HITMISS_SEG_IN 0x696e00	/* "in" */
#define NMG_HITMISS_SEG_OUT 0x6f757400	/* "out" */

struct hitmiss {
	struct rt_list	l;
	struct hit	hit;
	fastf_t		dist_in_plane;	/* distance from plane intersect */
	int		in_out;		/* status of ray as it transitions
					 * this hit point.
					 */
	long		*inbound_use;
	vect_t		inbound_norm;
	long		*outbound_use;
	vect_t		outbound_norm;
	int		start_stop;	/* is this a seg_in or seg_out */
	struct hitmiss	*other;		/* for keeping track of the other
					 * end of the segment when we know
					 * it
					 */
};

#define NMG_CK_HITMISS(hm) {\
	switch (hm->l.magic) { \
	case NMG_RT_HIT_MAGIC: \
	case NMG_RT_HIT_SUB_MAGIC: \
	case NMG_RT_MISS_MAGIC: \
		break; \
	case NMG_MISS_LIST: \
		rt_log("%s[%d]: struct hitmiss has  NMG_MISS_LIST magic #\n",\
			__FILE__, __LINE__); \
		rt_bomb("going down in flames\n"); \
	case NMG_HIT_LIST: \
		rt_log("%s[%d]: struct hitmiss has  NMG_MISS_LIST magic #\n",\
			__FILE__, __LINE__); \
		rt_bomb("going down in flames\n"); \
	default: \
		rt_log("%s[%d]: bad struct hitmiss magic: %d:(0x%08x)\n", \
			__FILE__, __LINE__, hm->l.magic, hm->l.magic); \
		rt_bomb("going down in flames\n"); \
	}\
	if (!hm->hit.hit_private) { \
		rt_log("%s[%d]: NULL hit_private in hitmiss struct\n", \
			__FILE__, __LINE__); \
		rt_bomb("going down in flames\n"); \
	} \
}

#define NMG_CK_HITMISS_LISTS(a_hit, rd) { \
    for (RT_LIST_FOR(a_hit, hitmiss, &rd->rd_hit)){NMG_CK_HITMISS(a_hit);} \
    for (RT_LIST_FOR(a_hit, hitmiss, &rd->rd_miss)){NMG_CK_HITMISS(a_hit);} }


/*	Ray Data structure
 *
 * A)	the hitmiss table has one element for each nmg structure in the
 *	nmgmodel.  The table keeps track of which elements have been
 *	processed before and which haven't.  Elements in this table
 *	will either be:
 *		(NULL)		item not previously processed
 *		hitmiss ptr	item previously processed
 *
 *	the 0th item in the array is a pointer to the head of the "hit"
 *	list.  The 1th item in the array is a pointer to the head of the
 *	"miss" list.
 *
 * B)	If plane_pt is non-null then we are currently processing a face
 *	intersection.  The plane_dist and ray_dist_to_plane are valid.
 *	The ray/edge intersector should check the distance from the plane
 *	intercept to the edge and update "plane_closest" if the current
 *	edge is closer to the intercept than the previous closest object.
 */
#define NMG_PCA_EDGE	1
#define NMG_PCA_EDGE_VERTEX 2
#define NMG_PCA_VERTEX 3
#define NMG_RAY_DATA_MAGIC 0x1651771
#define NMG_CK_RD(_rd) NMG_CKMAG(_rd, NMG_RAY_DATA_MAGIC, "ray data");
struct ray_data {
	long magic;
	struct model		*rd_m;
	char			*manifolds; /*  structure 1-3manifold table */
	vect_t			rd_invdir;
	struct xray		*rp;
	struct application	*ap;
	struct seg		*seghead;
	struct soltab 		*stp;
	struct rt_tol		*tol;
	struct hitmiss	**hitmiss;	/* 1 struct hitmiss ptr per elem. */
	struct rt_list	rd_hit;		/* list of hit elements */
	struct rt_list	rd_miss;	/* list of missed/sub-hit elements */

/* The following are to support isect_ray_face() */

	/* plane_pt is the intercept point of the ray with the plane of the
	 * face.
	 */
	point_t	plane_pt;	/* ray/plane(face) intercept point */

	/* ray_dist_to_plane is the parametric distance along the ray from
	 * the ray origin (rd->rp->r_pt) to the ray/plane intercept point
	 */
	fastf_t		ray_dist_to_plane; /* ray parametric dist to plane */

	/* the "face_subhit" element is a boolean used by isect_ray_face
	 * and [e|v]u_touch_func to record the fact that the ray/(plane/face)
	 * intercept point was within tolerance of an edge/vertex of the face.
	 * In such instances, isect_ray_face does NOT need to generate a hit 
	 * point for the face, as the hit point for the edge/vertex will 
	 * suffice.
	 */
	int		face_subhit;	

	/* the "classifying_ray" flag indicates that this ray is being used to
	 * classify a point, so that the "eu_touch" and "vu_touch" functions
	 * should not be called.
	 */
	int		classifying_ray;
};


#if FAST_NMG
#define GET_HITMISS(_p) { \
	(_p) = (struct hitmiss *)rt_calloc(1, sizeof(struct hitmiss), "hitmiss"); \
	}

#define FREE_HITMISS(_p) { \
	(void)rt_free( (char *)_p,  "hitmiss"); \
	}

#define NMG_FREE_HITLIST(_p) { \
	struct hitmiss *_hit; \
	while ( RT_LIST_WHILE(_hit, hitmiss, _p)) { \
		RT_LIST_DEQUEUE( &_hit->l ); \
		FREE_HITMISS( _hit ); \
	} }
#else
#define GET_HITMISS(_p) { \
	char str[64]; \
	(void)sprintf(str, "GET_HITMISS %s %d", __FILE__, __LINE__); \
	(_p) = (struct hitmiss *)rt_calloc(1, sizeof(struct hitmiss), str); \
	}

#define FREE_HITMISS(_p) { \
	char str[64]; \
	(void)sprintf(str, "FREE_HITMISS %s %d", __FILE__, __LINE__); \
	(void)rt_free( (char *)_p,  str); \
	}

#define NMG_FREE_HITLIST(_p) { \
	struct hitmiss *_hit; \
	while ( RT_LIST_WHILE(_hit, hitmiss, _p)) { \
		NMG_CK_HITMISS(_hit); \
		RT_LIST_DEQUEUE( &_hit->l ); \
		FREE_HITMISS( _hit ); \
	} }

#endif

#define HIT 1	/* a hit on a face */
#define MISS 0	/* a miss on the face */


#define nmg_rt_bomb(rd, str) { \
	rt_log("%s", str); \
	if (rt_g.NMG_debug & DEBUG_NMGRT) rt_bomb("End of diagnostics"); \
	RT_LIST_INIT(&rd->rd_hit); \
	RT_LIST_INIT(&rd->rd_miss); \
	rt_g.NMG_debug |= DEBUG_NMGRT; \
	nmg_isect_ray_model(rd); \
	(void) nmg_ray_segs(rd); \
	rt_bomb("Should have bombed before this\n"); }
@


11.4
log
@Changes to speed up NMG raytracing.
@
text
@d20 1
a20 1
 *  $Header: /m/cad/librt/RCS/nmg_rt.h,v 11.3 1996/05/16 21:45:55 jra Exp jra $
d156 1
a156 1
	pointp_t	plane_pt;	/* ray/plane(face) intercept point */
@


11.3
log
@Added "classifying_ray" field to ray_data structure.
@
text
@d20 1
a20 1
 *  $Header: /m/cad/librt/RCS/nmg_rt.h,v 11.2 1995/02/17 09:14:48 butler Exp jra $
d23 4
d180 16
a207 1

d215 2
@


11.2
log
@#defined NMG_CK_RD()
@
text
@d20 1
a20 1
 *  $Header: /m/cad/librt/RCS/nmg_rt.h,v 11.1 1995/01/04 09:58:14 mike Rel4_4 butler $
d167 6
@


11.1
log
@Release_4.4
@
text
@d20 1
a20 1
 *  $Header: /m/cad/librt/RCS/nmg_rt.h,v 1.14 94/09/21 03:37:50 mike Exp $
d132 1
@


1.14
log
@deleted "manifolds" from struct model, and moved it to struct ray_data.
Added extra argument to nmg_dangling_face().
@
text
@d20 1
a20 1
 *  $Header: /m/cad/h/RCS/machine.h,v 10.6 1994/08/25 14:54:22 gdurf Exp $
@


1.13
log
@checkpoint
@
text
@d1 22
d135 1
@


1.12
log
@checkpoint
@
text
@d11 4
d145 1
d147 4
a150 2
	(_p) = (struct hitmiss *)rt_calloc(1, sizeof(struct hitmiss), \
		"GET_HITMISS"); }
d152 14
@


1.11
log
@checkpoint
@
text
@d42 1
d44 1
d72 1
a72 1
		rt_log("%s[%d]: NULL hit_private in hitmiss structj\n", \
d77 4
@


1.10
log
@changed defines for ray state
@
text
@d21 1
d24 1
d41 2
@


1.9
log
@checkpoint
@
text
@d11 3
a13 2
#define NMG_HIT_INBOUND 1
#define NMG_HIT_OUTBOUND -1
d15 8
a22 8
#define HMG_HIT_IN_IN	1
#define HMG_HIT_IN_OUT	2
#define HMG_HIT_OUT_IN	4
#define HMG_HIT_OUT_OUT 8	/* vertex/edge grazing */
#define HMG_HIT_IN_ON	16
#define HMG_HIT_ON_IN	32
#define HMG_HIT_OUT_ON	64
#define HMG_HIT_ON_OUT	128
@


1.8
log
@checkpoint
@
text
@d7 7
d108 5
d114 14
a127 6
	fastf_t		ray_dist_to_plane; /* parametric dist to plane */
	fastf_t		plane_dist;	/* dist in plane (item -> plane_pt) */
	long		*plane_closest;	/* ptr to item with min(plane_dist) */
	int		plane_dist_type;/* is PCA at an  edge-span,
					 *  edge-vertex, or vertex?
					 */
@


1.7
log
@Added defines for VERT enter/leave status
@
text
@d38 27
@


1.6
log
@checkpoing
@
text
@d16 5
@


1.5
log
@checkpoint
@
text
@d7 9
d23 4
a26 1
	int		in_out;		/* is this a seg_in or seg_out */
d55 1
d87 9
@


1.4
log
@checkpoint
@
text
@d44 8
a51 3
	struct xray	*rp;
	struct rt_tol	*tol;
	vect_t		invdir;
d72 1
@


1.3
log
@checkpoint
@
text
@d47 3
a49 3
	struct hitmiss	**hitmiss;	/* 1 hitmiss struct ptr for each obj */
	struct rt_list	nmg_hits;	/* objects which have been hit */
	struct rt_list	nmg_misses;	/* objects which have been missed/sub-hit */
@


1.2
log
@About to make radical change?
@
text
@d40 3
a45 1
	struct hitmiss	**hitmiss;	/* 1 hitmiss struct for ea obj */
d47 5
a51 1
	pointp_t	plane_pt;	/* ray plane(face) intercept point */
d55 3
@


1.1
log
@Initial revision
@
text
@d21 19
d43 1
a43 1
	struct hitmiss	**hitmiss;
d45 4
a48 4
	pointp_t	plane_pt;
	fastf_t		plane_dist;
	fastf_t		ray_dist_to_plane;
	long		*plane_closest;
@
