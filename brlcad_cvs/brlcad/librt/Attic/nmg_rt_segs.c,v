head	11.27;
access;
symbols
	ansi-20040405-merged:11.23.2.2
	postmerge-20040405-ansi:11.25
	premerge-20040404-ansi:11.24
	postmerge-autoconf:11.24
	autoconf-freeze:11.23.10.2
	premerge-autoconf:11.24
	ansi-20040316-freeze:11.23.2.1
	postmerge-20040315-windows:11.24
	premerge-20040315-windows:11.24
	windows-20040315-freeze:11.23.4.1
	autoconf-20031203:11.23
	autoconf-20031202:11.23
	autoconf-branch:11.23.0.10
	phong-branch:11.23.0.8
	photonmap-branch:11.23.0.6
	rel-6-1-DP:11.23
	windows-branch:11.23.0.4
	rel-6-0-2:11.21
	ansi-branch:11.23.0.2
	rel-6-0-1-branch:11.21.0.2
	hartley-6-0-post:11.22
	hartley-6-0-pre:11.21
	rel-6-0-1:11.21
	rel-6-0:11.21
	rel-5-4:11.16
	offsite-5-3-pre:11.19
	rel-5-3:11.16
	rel-5-2:11.16
	rel-5-1-branch:11.16.0.2
	rel-5-1:11.16
	rel-5-0:11.15
	rel-5-0-beta:11.14
	rel-4-5:11.14
	ctj-4-5-post:11.13
	ctj-4-5-pre:11.13
	rel-4-4:11.1;
locks; strict;
comment	@ * @;


11.27
date	2004.05.21.18.07.34;	author morrison;	state dead;
branches;
next	11.26;

11.26
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.25;

11.25
date	2004.04.05.08.48.57;	author morrison;	state Exp;
branches;
next	11.24;

11.24
date	2004.02.02.17.39.26;	author morrison;	state Exp;
branches;
next	11.23;

11.23
date	2002.08.20.17.08.06;	author jra;	state Exp;
branches
	11.23.2.1
	11.23.4.1
	11.23.10.1;
next	11.22;

11.22
date	2002.08.15.20.55.18;	author hartley;	state Exp;
branches;
next	11.21;

11.21
date	2001.11.05.21.20.06;	author morrison;	state Exp;
branches;
next	11.20;

11.20
date	2001.04.20.22.29.53;	author morrison;	state Exp;
branches;
next	11.19;

11.19
date	2000.08.23.00.58.50;	author mike;	state Exp;
branches;
next	11.18;

11.18
date	2000.08.21.02.02.33;	author butler;	state Exp;
branches;
next	11.17;

11.17
date	2000.07.10.23.01.45;	author mike;	state Exp;
branches;
next	11.16;

11.16
date	99.12.30.15.41.58;	author jra;	state Exp;
branches;
next	11.15;

11.15
date	99.06.03.01.43.37;	author mike;	state Exp;
branches;
next	11.14;

11.14
date	97.09.23.21.03.16;	author jra;	state Exp;
branches;
next	11.13;

11.13
date	97.01.14.13.23.58;	author jra;	state Exp;
branches;
next	11.12;

11.12
date	97.01.09.16.15.46;	author jra;	state Exp;
branches;
next	11.11;

11.11
date	97.01.07.16.08.21;	author jra;	state Exp;
branches;
next	11.10;

11.10
date	96.09.27.08.27.30;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	96.08.29.22.52.21;	author butler;	state Exp;
branches;
next	11.8;

11.8
date	96.08.27.05.48.54;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	96.07.12.12.17.41;	author jra;	state Exp;
branches;
next	11.6;

11.6
date	96.04.24.22.18.36;	author butler;	state Exp;
branches;
next	11.5;

11.5
date	95.03.03.12.06.34;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	95.03.03.11.35.07;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	95.03.01.07.48.21;	author butler;	state Exp;
branches;
next	11.2;

11.2
date	95.02.21.11.16.59;	author butler;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.58.17;	author mike;	state Rel4_4;
branches;
next	1.20;

1.20
date	94.12.30.11.03.26;	author stay;	state Exp;
branches;
next	1.19;

1.19
date	94.12.20.15.15.47;	author jra;	state Exp;
branches;
next	1.18;

1.18
date	94.11.08.03.43.43;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	94.11.08.03.35.57;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	94.09.01.23.53.31;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	94.09.01.23.34.43;	author butler;	state Exp;
branches;
next	1.14;

1.14
date	94.08.24.22.48.54;	author butler;	state Exp;
branches;
next	1.13;

1.13
date	94.08.20.05.28.18;	author butler;	state Exp;
branches;
next	1.12;

1.12
date	94.08.16.16.51.18;	author butler;	state Exp;
branches;
next	1.11;

1.11
date	94.08.10.20.33.02;	author gdurf;	state Exp;
branches;
next	1.10;

1.10
date	94.07.01.01.38.37;	author butler;	state Exp;
branches;
next	1.9;

1.9
date	94.06.22.17.20.52;	author butler;	state Exp;
branches;
next	1.8;

1.8
date	94.06.15.23.42.37;	author butler;	state Exp;
branches;
next	1.7;

1.7
date	93.12.03.03.35.49;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	93.10.20.01.03.23;	author butler;	state Exp;
branches;
next	1.5;

1.5
date	93.09.02.16.17.19;	author butler;	state Exp;
branches;
next	1.4;

1.4
date	93.09.01.20.22.30;	author butler;	state Exp;
branches;
next	1.3;

1.3
date	93.09.01.01.26.54;	author butler;	state Exp;
branches;
next	1.2;

1.2
date	93.07.23.15.56.10;	author butler;	state Exp;
branches;
next	1.1;

1.1
date	93.06.04.17.08.11;	author butler;	state Exp;
branches;
next	;

11.23.2.1
date	2002.09.19.18.01.41;	author morrison;	state Exp;
branches;
next	11.23.2.2;

11.23.2.2
date	2004.03.17.21.18.55;	author morrison;	state Exp;
branches;
next	;

11.23.4.1
date	2004.03.11.23.43.43;	author morrison;	state Exp;
branches;
next	;

11.23.10.1
date	2004.02.12.18.37.45;	author erikg;	state Exp;
branches;
next	11.23.10.2;

11.23.10.2
date	2004.03.15.14.07.28;	author erikg;	state Exp;
branches;
next	;


desc
@Code to build segments from list of hit points.
@


11.27
log
@moved to src/
@
text
@/*
 *			N M G _ R T _ S E G S. C
 *
 *	Support routines for raytracing an NMG.
 *
 *  Author -
 *	Lee A. Butler
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066  USA
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1993-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/nmg_rt_segs.c,v 11.26 2004/05/10 15:30:46 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <string.h>
#include <math.h>
#include "machine.h"
#include "vmath.h"
#include "nmg.h"
#include "raytrace.h"
#include "plot3.h"

/*	EDGE-FACE correlation data
 * 	used in edge_hit() for 3manifold case
 */
struct ef_data {
    	fastf_t		fdotr;	/* face vector VDOT with ray */
    	fastf_t		fdotl;	/* face vector VDOT with ray-left */
    	fastf_t		ndotr;	/* face normal VDOT with ray */
    	struct edgeuse *eu;
};

#if 0
static const 
struct bu_structparse rt_ef_parsetab[] = {
	{"%f", 1, "fdotr", offsetof(struct ef_data, fdotr), BU_STRUCTPARSE_FUNC_NULL},
	{"%f", 1, "fdotl", offsetof(struct ef_data, fdotl), BU_STRUCTPARSE_FUNC_NULL},
	{"%f", 1, "ndotr", offsetof(struct ef_data, ndotr), BU_STRUCTPARSE_FUNC_NULL},
	{"%x", 1, "eu",   offsetof(struct ef_data, eu),   BU_STRUCTPARSE_FUNC_NULL},
	{"", 0, (char *)NULL,	  0,			  BU_STRUCTPARSE_FUNC_NULL}
};

static const
struct bu_structparse rt_hit_parsetab[] = {
{"%f", 1, "hit_dist", offsetof(struct hit, hit_dist), BU_STRUCTPARSE_FUNC_NULL},
{"%f", 3, "hit_point", bu_offsetofarray(struct hit, hit_point), BU_STRUCTPARSE_FUNC_NULL},
{"%f", 4, "hit_normal", bu_offsetofarray(struct hit, hit_normal), BU_STRUCTPARSE_FUNC_NULL},
{"%f", 3, "hit_vpriv", bu_offsetofarray(struct hit, hit_vpriv), BU_STRUCTPARSE_FUNC_NULL},
{"%x", 1, "hit_private", offsetof(struct hit, hit_private), BU_STRUCTPARSE_FUNC_NULL},
{"%d", 1, "hit_surfno", offsetof(struct hit, hit_surfno), BU_STRUCTPARSE_FUNC_NULL},
{"", 0, (char *)NULL,	  0,			  BU_STRUCTPARSE_FUNC_NULL}
};
#endif

#define CK_SEGP(_p) if ( !(_p) || !(*(_p)) ) {\
	bu_log("%s[line:%d]: Bad seg_p pointer\n", __FILE__, __LINE__); \
	nmg_rt_segs_exit("Goodbye"); }
#define DO_LONGJMP
#ifdef DO_LONGJMP
jmp_buf nmg_longjump_env;
#define nmg_rt_segs_exit(_s) {bu_log("%s\n",_s);longjmp(nmg_longjump_env, -1);}
#else
#define nmg_rt_segs_exit(_s) rt_bomb(_s)
#endif



static void
print_seg_list(struct seg *seghead, int seg_count, char *s)
{
	struct seg *seg_p;

	bu_log("Segment List (%d segnemts) (%s):\n", seg_count, s);
	/* print debugging data before returning */
	bu_log("Seghead:\n0x%08x magic: 0x%0x(%d) forw:0x%08x back:0x%08x\n\n",
			seghead,
			seghead->l.magic,
			seghead->l.forw,
			seghead->l.back);

	for (BU_LIST_FOR(seg_p, seg, &seghead->l) ) {
		bu_log("0x%08x magic: 0x%0x(%d) forw:0x%08x back:0x%08x\n",
			seg_p,
			seg_p->l.magic,
			seg_p->l.forw,
			seg_p->l.back);
		bu_log("dist %g  pt(%g,%g,%g)  N(%g,%g,%g)  =>\n",
		seg_p->seg_in.hit_dist,
		seg_p->seg_in.hit_point[0],
		seg_p->seg_in.hit_point[1],
		seg_p->seg_in.hit_point[2],
		seg_p->seg_in.hit_normal[0],
		seg_p->seg_in.hit_normal[1],
		seg_p->seg_in.hit_normal[2]);
		bu_log("dist %g  pt(%g,%g,%g)  N(%g,%g,%g)\n",
		seg_p->seg_out.hit_dist,
		seg_p->seg_out.hit_point[0],
		seg_p->seg_out.hit_point[1],
		seg_p->seg_out.hit_point[2],
		seg_p->seg_out.hit_normal[0],
		seg_p->seg_out.hit_normal[1],
		seg_p->seg_out.hit_normal[2]);
	}
}

static void
pl_ray(struct ray_data *rd)
{
	FILE *fd;
	char name[80];
	static int plot_file_number=0;
	struct hitmiss *a_hit;
	int old_state = NMG_RAY_STATE_OUTSIDE;
	int in_state;
	int out_state;
	point_t old_point;
	point_t end_point;
	int old_cond = 0;

	sprintf(name, "nmg_ray%02d.pl", plot_file_number++);
	if ((fd=fopen(name, "w")) == (FILE *)NULL) {
		perror(name);
		abort();
	} else
		bu_log("overlay %s\n", name);

	VMOVE(old_point, rd->rp->r_pt);

	for (BU_LIST_FOR(a_hit, hitmiss, &rd->rd_hit)) {
#ifndef FAST_NMG
		NMG_CK_HITMISS(a_hit);
#endif

		in_state = HMG_INBOUND_STATE(a_hit);
		out_state = HMG_OUTBOUND_STATE(a_hit);

		if (in_state == old_state) {
			switch(in_state) {
			case NMG_RAY_STATE_INSIDE:
				pl_color(fd, 55, 255, 55);
				pdv_3line(fd, old_point, a_hit->hit.hit_point);
				break;
			case NMG_RAY_STATE_ON:
				pl_color(fd, 155, 155, 255);
				pdv_3line(fd, old_point, a_hit->hit.hit_point);
				break;
			case NMG_RAY_STATE_OUTSIDE:
				pl_color(fd, 255, 255, 255);
				pdv_3line(fd, old_point, a_hit->hit.hit_point);
				break;
			}
			old_cond = 0;
		} else {
			if (old_cond) {
				pl_color(fd, 255, 155, 255);
				old_cond = 0;
			} else {
				pl_color(fd, 255, 55, 255);
				old_cond = 1;
			}
			pdv_3line(fd, old_point, a_hit->hit.hit_point);
		}
		VMOVE(old_point, a_hit->hit.hit_point);
		old_state = out_state;
	}

	if (old_state == NMG_RAY_STATE_OUTSIDE)
		pl_color(fd, 255, 255, 255);
	else
		pl_color(fd, 255, 55, 255);

	VADD2(end_point, old_point, rd->rp->r_dir);
	pdv_3line(fd, old_point, end_point);

	fclose(fd);
}

/*
 *		N E X T _ S T A T E _ T A B L E
 *
 *			Current_State
 *	Input	|  0   1     2    3    4    5    6
 *	-------------------------------------------
 *	O_N  =	| i1   1   Ci1    5    1    5    5
 *	O_N !=	| i1  1|E  Ci1   C1  Ci1  Ci1  Ci1
 *	N_N  =	|  E   1     E    3    E    1    1
 *	N_N !=	|  E   1     E    E    E    1    1   
 *	N_O  =	|  E  o2    o2  ?o2    E   o2   o2
 *	N_O !=	|  E  o2    o2    E    E   o2   o2
 *	O_O  =	|io3  o2    o2    3    3    6    6
 *	O_O !=	|io3 o2|E Cio3 Cio3 Cio3 Cio3 Cio3
 *	A_A  =	|io4   1     2    3    4    5    6
 *	A_A !=	|io4   1  Cio4 Cio4 Cio4 Cio4 Cio4
 *	EOI     |  N   E    CN   CN   CN   CN   CN   
 *
 *	=	-> ray dist to point within tol (along ray) of last hit point
 *	!=	-> ray dist to point outside tol (along ray) of last hit point
 *
 *	State Prefix
 *	C	segment now completed, add to list & alloc new segment
 *	i	set inpoint for current segment
 *	o	set outpoint for current segment
 *	
 *	State
 *	E	Error termination
 *	N	Normal termination
 *	1	"Entering" solid
 *	2	"Leaving" solid
 *	3	O_O from outside state
 *	4	A_A from outside state
 *	5	O_O=O_N		Fuzzy state 1 or state 2 from state 3
 *	6	0_0=O_N=O_O
 */


static void
set_inpoint(struct seg **seg_p, struct hitmiss *a_hit, struct soltab *stp, struct application *ap)
          	        	/* The segment we're building */
              	       		/* The input hit point */
             	     
                  	    
{
	if ( !seg_p ) {
		bu_log("%s[line:%d]: Null pointer to segment pointer\n",
			__FILE__, __LINE__);
		nmg_rt_segs_exit("Goodbye");
	}
		
	/* if we don't have a seg struct yet, get one */
	if ( *seg_p == (struct seg *)NULL ) {
		RT_GET_SEG(*seg_p, ap->a_resource);
		(*seg_p)->seg_stp = stp;
	}

	/* copy the "in" hit */
	bcopy(&a_hit->hit, &(*seg_p)->seg_in, sizeof(struct hit));

	/* copy the normal */
	VMOVE((*seg_p)->seg_in.hit_normal, a_hit->inbound_norm);

	if (rt_g.NMG_debug & DEBUG_RT_SEGS) {
		bu_log("Set seg_in:\n\tdist %g  pt(%g,%g,%g)  N(%g,%g,%g)\n",
		(*seg_p)->seg_in.hit_dist,
		(*seg_p)->seg_in.hit_point[0],
		(*seg_p)->seg_in.hit_point[1],
		(*seg_p)->seg_in.hit_point[2],
		(*seg_p)->seg_in.hit_normal[0],
		(*seg_p)->seg_in.hit_normal[1],
		(*seg_p)->seg_in.hit_normal[2]);
	}
}

static void
set_outpoint(struct seg **seg_p, struct hitmiss *a_hit)
          	        	/* The segment we're building */
              	       		/* The input hit point */
{
	if ( !seg_p ) {
		bu_log("%s[line:%d]: Null pointer to segment pointer\n",
			__FILE__, __LINE__);
		nmg_rt_segs_exit("Goodbye");
	}
		
	/* if we don't have a seg struct yet, get one */
	if ( *seg_p == (struct seg *)NULL )
		nmg_rt_segs_exit("bad seg pointer\n");

	/* copy the "out" hit */
	bcopy(&a_hit->hit, &(*seg_p)->seg_out, sizeof(struct hit));

	/* copy the normal */
	VMOVE((*seg_p)->seg_out.hit_normal, a_hit->outbound_norm);

	if (rt_g.NMG_debug & DEBUG_RT_SEGS) {
		bu_log("Set seg_out:\n\tdist %g  pt(%g,%g,%g)  N(%g,%g,%g)  =>\n",
		(*seg_p)->seg_in.hit_dist,
		(*seg_p)->seg_in.hit_point[0],
		(*seg_p)->seg_in.hit_point[1],
		(*seg_p)->seg_in.hit_point[2],
		(*seg_p)->seg_in.hit_normal[0],
		(*seg_p)->seg_in.hit_normal[1],
		(*seg_p)->seg_in.hit_normal[2]);
		bu_log("\tdist %g  pt(%g,%g,%g)  N(%g,%g,%g)\n",
		(*seg_p)->seg_out.hit_dist,
		(*seg_p)->seg_out.hit_point[0],
		(*seg_p)->seg_out.hit_point[1],
		(*seg_p)->seg_out.hit_point[2],
		(*seg_p)->seg_out.hit_normal[0],
		(*seg_p)->seg_out.hit_normal[1],
		(*seg_p)->seg_out.hit_normal[2]);
	}
}



static int
state0(struct seg *seghead, struct seg **seg_p, int *seg_count, struct hitmiss *a_hit, struct soltab *stp, struct application *ap, struct bn_tol *tol)
          	         	/* intersection w/ ray */
          	        	/* The segment we're building */
   		           	/* The number of valid segments built */
              	       		/* The input hit point */
             	     
                       
             	     
{
	int ret_val = -1;

	switch (a_hit->in_out) {
	case HMG_HIT_OUT_IN:
	case HMG_HIT_OUT_ON:
		/* save the in-hit point */
		set_inpoint(seg_p, a_hit, stp, ap);
		ret_val = 1;
		break;
	case HMG_HIT_ON_ON:
	case HMG_HIT_IN_IN:
	case HMG_HIT_ON_IN:
	case HMG_HIT_IN_ON:
	case HMG_HIT_IN_OUT:
	case HMG_HIT_ON_OUT:
		/* error */
		bu_log("%s[line:%d]: State transition error: exit without entry.\n",
			__FILE__, __LINE__);
		ret_val = -2;
		break;
	case HMG_HIT_OUT_OUT:
		/* Save the in/out points */
		set_inpoint(seg_p, a_hit, stp, ap);
		set_outpoint(seg_p, a_hit);
		ret_val = 3;
		break;
	case HMG_HIT_ANY_ANY:
		/* Save the in/out points */
		set_inpoint(seg_p, a_hit, stp, ap);
		set_outpoint(seg_p, a_hit);
		ret_val = 4;
		break;
	default:
		bu_log("%s[line:%d]: bogus hit in/out status\n",
			__FILE__, __LINE__);
		nmg_rt_segs_exit("Goodbye\n");
		break;
	}

	return ret_val;
}

static int
state1(struct seg *seghead, struct seg **seg_p, int *seg_count, struct hitmiss *a_hit, struct soltab *stp, struct application *ap, struct bn_tol *tol)
          	         	/* intersection w/ ray */
          	        	/* The segment we're building */
   		           	/* The number of valid segments built */
              	       		/* The input hit point */
             	     
                       
             	     
{
	int ret_val = -1;

	switch (a_hit->in_out) {
	case HMG_HIT_OUT_ON:
	case HMG_HIT_OUT_IN:
	case HMG_HIT_IN_IN:
	case HMG_HIT_ON_IN:
	case HMG_HIT_IN_ON:
	case HMG_HIT_ON_ON:
		ret_val = 1;
		break;
	case HMG_HIT_ON_OUT:
	case HMG_HIT_IN_OUT:
		set_outpoint(seg_p, a_hit);
		ret_val = 2;
		break;
	case HMG_HIT_OUT_OUT:
		/* XXX possibly an error condition if not within tol */
		set_outpoint(seg_p, a_hit);
		ret_val = 2;
		break;
	case HMG_HIT_ANY_ANY:
		ret_val = 1;
		break;
	default:
		bu_log("%s[line:%d]: bogus hit in/out status\n",
			__FILE__, __LINE__);
		nmg_rt_segs_exit("Goodbye\n");
		break;
	}

	return ret_val;
}

static int
state2(struct seg *seghead, struct seg **seg_p, int *seg_count, struct hitmiss *a_hit, struct soltab *stp, struct application *ap, struct bn_tol *tol)
          	         	/* intersection w/ ray */
          	        	/* The segment we're building */
   		           	/* The number of valid segments built */
              	       		/* The input hit point */
             	     
                       
             	     
{
	int ret_val = -1;
	double delta;

	switch (a_hit->in_out) {
	case HMG_HIT_OUT_ON:
	case HMG_HIT_OUT_IN:
		/* Segment completed.  Insert into segment list */
		BU_LIST_MAGIC_SET( &( (*seg_p)->l ), RT_SEG_MAGIC);
		BU_LIST_INSERT(&(seghead->l), &((*seg_p)->l) );
		(*seg_count)++;

		/* start new segment */
		(*seg_p) = (struct seg *)NULL;
		set_inpoint(seg_p, a_hit, stp, ap);

		ret_val = 1;
		break;
	case HMG_HIT_IN_IN:
	case HMG_HIT_ON_ON:
	case HMG_HIT_ON_IN:
	case HMG_HIT_IN_ON:
		/* Error */
		bu_log("%s[line:%d]: State transition error.\n",
			__FILE__, __LINE__);
		ret_val = -2;
		break;
	case HMG_HIT_ON_OUT:
	case HMG_HIT_IN_OUT:
		/* progress the out-point */
		set_outpoint(seg_p, a_hit);
		ret_val = 2;
		break;
	case HMG_HIT_OUT_OUT:
		CK_SEGP(seg_p);
		BN_CK_TOL(tol);
		delta = fabs((*seg_p)->seg_in.hit_dist - a_hit->hit.hit_dist);
		if ( delta < tol->dist) {
			set_outpoint(seg_p, a_hit);
			ret_val = 2;
			break;
		}
		/* complete the segment */
		BU_LIST_MAGIC_SET( &( (*seg_p)->l ), RT_SEG_MAGIC);
		BU_LIST_INSERT(&(seghead->l), &((*seg_p)->l) );
		(*seg_count)++;

		/* start new segment */
		(*seg_p) = (struct seg *)NULL;
		set_inpoint(seg_p, a_hit, stp, ap);
		set_outpoint(seg_p, a_hit);

		ret_val = 3;
		break;
	case HMG_HIT_ANY_ANY:
		CK_SEGP(seg_p);
		BN_CK_TOL(tol);
		delta = fabs((*seg_p)->seg_in.hit_dist - a_hit->hit.hit_dist);
		if ( delta < tol->dist) {
			set_outpoint(seg_p, a_hit);
			ret_val = 2;
			break;
		}
		/* complete the segment */
		BU_LIST_MAGIC_SET( &( (*seg_p)->l ), RT_SEG_MAGIC);
		BU_LIST_INSERT(&(seghead->l), &((*seg_p)->l) );
		(*seg_count)++;

		/* start new segment */
		(*seg_p) = (struct seg *)NULL;
		set_inpoint(seg_p, a_hit, stp, ap);
		set_outpoint(seg_p, a_hit);

		ret_val = 4;
		break;
	default:
		bu_log("%s[line:%d]: bogus hit in/out status\n",
			__FILE__, __LINE__);
		nmg_rt_segs_exit("Goodbye\n");
		break;
	}

	return ret_val;
}

static int
state3(struct seg *seghead, struct seg **seg_p, int *seg_count, struct hitmiss *a_hit, struct soltab *stp, struct application *ap, struct bn_tol *tol)
          	         	/* intersection w/ ray */
          	        	/* The segment we're building */
   		           	/* The number of valid segments built */
              	       		/* The input hit point */
             	     
                       
             	     
{
	int ret_val = -1;
	double delta;

	CK_SEGP(seg_p);
	BN_CK_TOL(tol);
	delta = fabs((*seg_p)->seg_in.hit_dist - a_hit->hit.hit_dist);

	switch (a_hit->in_out) {
	case HMG_HIT_OUT_ON:
	case HMG_HIT_OUT_IN:
		if ( delta < tol->dist) {
			ret_val = 5;
		} else {
			/* complete the segment */
			BU_LIST_MAGIC_SET( &( (*seg_p)->l ), RT_SEG_MAGIC);
			BU_LIST_INSERT(&(seghead->l), &((*seg_p)->l) );
			(*seg_count)++;

			/* start new segment */
			(*seg_p) = (struct seg *)NULL;
			set_inpoint(seg_p, a_hit, stp, ap);

			ret_val = 1;
		}
		break;
	case HMG_HIT_IN_IN:
	case HMG_HIT_ON_IN:
	case HMG_HIT_IN_ON:
	case HMG_HIT_ON_ON:
		if ( delta < tol->dist) {
			ret_val = 3;
		} else {
			/* Error */
			bu_log("%s[line:%d]: State transition error.\n",
				__FILE__, __LINE__);
			ret_val = -2;
		}
		break;
	case HMG_HIT_ON_OUT:
	case HMG_HIT_IN_OUT:
		/*
		 * This can happen when the ray hits an edge/vertex and
		 * (due to floating point fuzz) also appears to have a 
		 * hit point in the area of a face:
		 *
		 * ------->o
		 *	  / \------------>
		 *	 /   \
		 *
		 */
		set_outpoint(seg_p, a_hit);
		ret_val = 2;
		break;
	case HMG_HIT_OUT_OUT:
		if (delta > tol->dist) {
			/* complete the segment */
			BU_LIST_MAGIC_SET( &( (*seg_p)->l ), RT_SEG_MAGIC);
			BU_LIST_INSERT(&(seghead->l), &((*seg_p)->l) );
			(*seg_count)++;

			/* start new segment */
			(*seg_p) = (struct seg *)NULL;
			set_inpoint(seg_p, a_hit, stp, ap);
			set_outpoint(seg_p, a_hit);
		}
		ret_val = 3;
		break;
	case HMG_HIT_ANY_ANY:
		if (delta < tol->dist) {
			ret_val = 3;
		} else {
			/* complete the segment */
			BU_LIST_MAGIC_SET( &( (*seg_p)->l ), RT_SEG_MAGIC);
			BU_LIST_INSERT(&(seghead->l), &((*seg_p)->l) );
			(*seg_count)++;

			/* start new segment */
			(*seg_p) = (struct seg *)NULL;
			set_inpoint(seg_p, a_hit, stp, ap);
			ret_val = 4;
		}
		break;
	default:
		bu_log("%s[line:%d]: bogus hit in/out status\n",
			__FILE__, __LINE__);
		nmg_rt_segs_exit("Goodbye\n");
		break;
	}

	return ret_val;
}

static int
state4(struct seg *seghead, struct seg **seg_p, int *seg_count, struct hitmiss *a_hit, struct soltab *stp, struct application *ap, struct bn_tol *tol)
          	         	/* intersection w/ ray */
          	        	/* The segment we're building */
   		           	/* The number of valid segments built */
              	       		/* The input hit point */
             	     
                       
             	     
{
	int ret_val = -1;
	double delta;

	switch (a_hit->in_out) {
	case HMG_HIT_OUT_ON:
	case HMG_HIT_OUT_IN:
		CK_SEGP(seg_p);
		BN_CK_TOL(tol);
		delta = fabs((*seg_p)->seg_in.hit_dist - a_hit->hit.hit_dist);
		if (delta > tol->dist) {
			/* complete the segment */
			BU_LIST_MAGIC_SET( &( (*seg_p)->l ), RT_SEG_MAGIC);
			BU_LIST_INSERT(&(seghead->l), &((*seg_p)->l) );
			(*seg_count)++;

			/* start new segment */
			(*seg_p) = (struct seg *)NULL;
			set_inpoint(seg_p, a_hit, stp, ap);
		}
		ret_val = 1;
		break;
	case HMG_HIT_IN_IN:
	case HMG_HIT_ON_IN:
	case HMG_HIT_IN_ON:
	case HMG_HIT_ON_ON:
	case HMG_HIT_ON_OUT:
	case HMG_HIT_IN_OUT:
		/* Error */
		bu_log("%s[line:%d]: State transition error.\n",
			__FILE__, __LINE__);
		ret_val = -2;
		break;
	case HMG_HIT_OUT_OUT:
		CK_SEGP(seg_p);
		BN_CK_TOL(tol);
		delta = fabs((*seg_p)->seg_in.hit_dist - a_hit->hit.hit_dist);
		if (delta > tol->dist) {
			/* complete the segment */
			BU_LIST_MAGIC_SET( &( (*seg_p)->l ), RT_SEG_MAGIC);
			BU_LIST_INSERT(&(seghead->l), &((*seg_p)->l) );
			(*seg_count)++;

			/* start new segment */
			(*seg_p) = (struct seg *)NULL;
			set_inpoint(seg_p, a_hit, stp, ap);
			set_outpoint(seg_p, a_hit);
		}
		ret_val = 3;
		break;
	case HMG_HIT_ANY_ANY:
		CK_SEGP(seg_p);
		BN_CK_TOL(tol);
		delta = fabs((*seg_p)->seg_in.hit_dist - a_hit->hit.hit_dist);
		if (delta > tol->dist) {
			/* complete the segment */
			BU_LIST_MAGIC_SET( &( (*seg_p)->l ), RT_SEG_MAGIC);
			BU_LIST_INSERT(&(seghead->l), &((*seg_p)->l) );
			(*seg_count)++;

			/* start new segment */
			(*seg_p) = (struct seg *)NULL;
			set_inpoint(seg_p, a_hit, stp, ap);
			set_outpoint(seg_p, a_hit);
		}
		ret_val = 4;
		break;
	default:
		bu_log("%s[line:%d]: bogus hit in/out status\n",
			__FILE__, __LINE__);
		nmg_rt_segs_exit("Goodbye\n");
		break;
	}

	return ret_val;
}

static int
state5(struct seg *seghead, struct seg **seg_p, int *seg_count, struct hitmiss *a_hit, struct soltab *stp, struct application *ap, struct bn_tol *tol)
          	         	/* intersection w/ ray */
          	        	/* The segment we're building */
   		           	/* The number of valid segments built */
              	       		/* The input hit point */
             	     
                       
             	     
{
	int ret_val = -1;
	double delta;

	switch (a_hit->in_out) {
	case HMG_HIT_OUT_ON:
	case HMG_HIT_OUT_IN:
		CK_SEGP(seg_p);
		BN_CK_TOL(tol);
		delta = fabs((*seg_p)->seg_in.hit_dist - a_hit->hit.hit_dist);
		if (delta < tol->dist) {
			ret_val = 5;
		} else {
			/* complete the segment */
			BU_LIST_MAGIC_SET( &( (*seg_p)->l ), RT_SEG_MAGIC);
			BU_LIST_INSERT(&(seghead->l), &((*seg_p)->l) );
			(*seg_count)++;

			/* start new segment */
			(*seg_p) = (struct seg *)NULL;
			set_inpoint(seg_p, a_hit, stp, ap);
			ret_val = 1;
		}
		break;
	case HMG_HIT_IN_IN:
	case HMG_HIT_ON_IN:
	case HMG_HIT_IN_ON:
	case HMG_HIT_ON_ON:
		ret_val = 1;
		break;
	case HMG_HIT_ON_OUT:
	case HMG_HIT_IN_OUT:
		set_outpoint(seg_p, a_hit);
		ret_val = 2;
		break;
	case HMG_HIT_OUT_OUT:
		CK_SEGP(seg_p);
		BN_CK_TOL(tol);
		delta = fabs((*seg_p)->seg_in.hit_dist - a_hit->hit.hit_dist);
		if (delta < tol->dist) {
			ret_val = 6;
		} else {
			/* complete the segment */
			BU_LIST_MAGIC_SET( &( (*seg_p)->l ), RT_SEG_MAGIC);
			BU_LIST_INSERT(&(seghead->l), &((*seg_p)->l) );
			(*seg_count)++;

			/* start new segment */
			(*seg_p) = (struct seg *)NULL;
			set_inpoint(seg_p, a_hit, stp, ap);
			set_outpoint(seg_p, a_hit);
			ret_val = 3;
		}
		break;
	case HMG_HIT_ANY_ANY:
		CK_SEGP(seg_p);
		BN_CK_TOL(tol);
		delta = fabs((*seg_p)->seg_in.hit_dist - a_hit->hit.hit_dist);
		if (delta < tol->dist) {
			ret_val = 5;
		} else {
			/* complete the segment */
			BU_LIST_MAGIC_SET( &( (*seg_p)->l ), RT_SEG_MAGIC);
			BU_LIST_INSERT(&(seghead->l), &((*seg_p)->l) );
			(*seg_count)++;

			/* start new segment */
			(*seg_p) = (struct seg *)NULL;
			set_inpoint(seg_p, a_hit, stp, ap);
			set_outpoint(seg_p, a_hit);
			ret_val = 4;
		}
		break;
	default:
		bu_log("%s[line:%d]: bogus hit in/out status\n",
			__FILE__, __LINE__);
		nmg_rt_segs_exit("Goodbye\n");
		break;
	}

	return ret_val;
}

static int
state6(struct seg *seghead, struct seg **seg_p, int *seg_count, struct hitmiss *a_hit, struct soltab *stp, struct application *ap, struct bn_tol *tol)
          	         	/* intersection w/ ray */
          	        	/* The segment we're building */
   		           	/* The number of valid segments built */
              	       		/* The input hit point */
             	     
                       
             	     
{
	int ret_val = -1;
	double delta;

	switch (a_hit->in_out) {
	case HMG_HIT_OUT_ON:
	case HMG_HIT_OUT_IN:
		CK_SEGP(seg_p);
		BN_CK_TOL(tol);
		delta = fabs((*seg_p)->seg_in.hit_dist - a_hit->hit.hit_dist);
		if (delta < tol->dist) {
			ret_val = 5;
		} else {
			/* complete the segment */
			BU_LIST_MAGIC_SET( &( (*seg_p)->l ), RT_SEG_MAGIC);
			BU_LIST_INSERT(&(seghead->l), &((*seg_p)->l) );
			(*seg_count)++;

			/* start new segment */
			(*seg_p) = (struct seg *)NULL;
			set_inpoint(seg_p, a_hit, stp, ap);
			ret_val = 1;
		}
		break;
	case HMG_HIT_IN_IN:
	case HMG_HIT_ON_IN:
	case HMG_HIT_IN_ON:
	case HMG_HIT_ON_ON:
		ret_val = 1;
		break;
	case HMG_HIT_ON_OUT:
	case HMG_HIT_IN_OUT:
		set_outpoint(seg_p, a_hit);
		ret_val = 2;
		break;
	case HMG_HIT_OUT_OUT:
		CK_SEGP(seg_p);
		BN_CK_TOL(tol);
		delta = fabs((*seg_p)->seg_in.hit_dist - a_hit->hit.hit_dist);
		if (delta < tol->dist) {
			ret_val = 6;
		} else {
			/* complete the segment */
			BU_LIST_MAGIC_SET( &( (*seg_p)->l ), RT_SEG_MAGIC);
			BU_LIST_INSERT(&(seghead->l), &((*seg_p)->l) );
			(*seg_count)++;

			/* start new segment */
			(*seg_p) = (struct seg *)NULL;
			set_inpoint(seg_p, a_hit, stp, ap);
			set_outpoint(seg_p, a_hit);
			ret_val = 3;
		}
		break;
	case HMG_HIT_ANY_ANY:
		CK_SEGP(seg_p);
		BN_CK_TOL(tol);
		delta = fabs((*seg_p)->seg_in.hit_dist - a_hit->hit.hit_dist);
		if (delta < tol->dist) {
			ret_val = 6;
		} else {
			/* complete the segment */
			BU_LIST_MAGIC_SET( &( (*seg_p)->l ), RT_SEG_MAGIC);
			BU_LIST_INSERT(&(seghead->l), &((*seg_p)->l) );
			(*seg_count)++;

			/* start new segment */
			(*seg_p) = (struct seg *)NULL;
			set_inpoint(seg_p, a_hit, stp, ap);
			set_outpoint(seg_p, a_hit);
			ret_val = 4;
		}
		break;
	default:
		bu_log("%s[line:%d]: bogus hit in/out status\n",
			__FILE__, __LINE__);
		nmg_rt_segs_exit("Goodbye\n");
		break;
	}

	return ret_val;
}


static int (*state_table[7])() = {
	state0, state1, state2, state3,
	state4, state5, state6
};


static int
nmg_bsegs(struct ray_data *rd, struct application *ap, struct seg *seghead, struct soltab *stp)
               		    
                  	    
          		         	/* intersection w/ ray */
             		     
{
	int ray_state = 0;
	int new_state;
	struct hitmiss *a_hit = (struct hitmiss *)NULL;
	struct hitmiss *hm = (struct hitmiss *)NULL;
	struct seg *seg_p = (struct seg *)NULL;
	int seg_count = 0;

#ifndef FAST_NMG
	NMG_CK_HITMISS_LISTS(a_hit, rd);
#endif

	for (BU_LIST_FOR(a_hit, hitmiss, &rd->rd_hit)) {
#ifndef FAST_NMG
		NMG_CK_HITMISS(a_hit);
#endif

		new_state = state_table[ray_state](seghead, &seg_p,
							&seg_count, a_hit,
							stp, ap, rd->tol);
		if (new_state < 0) {
			/* state transition error.  Print out the hit list
			 * and indicate where we were in processing it.
			 */
			for (BU_LIST_FOR(hm, hitmiss, &rd->rd_hit)) {
				if (hm == a_hit) {
					bu_log("======= State %d ======\n",
						ray_state);
					nmg_rt_print_hitmiss(hm);
					bu_log("================\n");
				} else 
					nmg_rt_print_hitmiss(hm);
			}

			/* Now bomb off */
			bu_log("Primitive: %s, pixel=%d %d, lvl=%d %s\n",
				rd->stp->st_dp->d_namep,
				rd->ap->a_x, rd->ap->a_y, rd->ap->a_level,
				rd->ap->a_purpose );
		    	bu_log("Ray: pt:(%g %g %g) dir:(%g %g %g)\n",
		    		V3ARGS(rd->rp->r_pt), V3ARGS(rd->rp->r_dir) );
			nmg_rt_segs_exit("Goodbye\n");
		}

		ray_state = new_state;
	}

	/* Check to make sure the input ran out in the right place 
	 * in the state table.
	 */
	if (ray_state == 1) {
		bu_log("%s[line:%d]: Input ended at non-terminal FSM state\n",
			__FILE__, __LINE__);

	    	bu_log("Ray: pt:(%g %g %g) dir:(%g %g %g)\n",
	    		V3ARGS(rd->rp->r_pt), V3ARGS(rd->rp->r_dir) );
		
		bu_log("Primitive: %s, pixel=%d %d, lvl=%d %s\n",
			stp->st_dp->d_namep,
			ap->a_x, ap->a_y, ap->a_level,
			ap->a_purpose );
		nmg_rt_segs_exit("Goodbye");
	}

	/* Insert the last segment if appropriate */
	if (ray_state > 1) {
		/* complete the segment */
		BU_LIST_MAGIC_SET( &( seg_p->l ), RT_SEG_MAGIC);
		BU_LIST_INSERT(&(seghead->l), &(seg_p->l) );
		seg_count++;
	}

	return seg_count;
}

/*
 *	If a_tbl and next_tbl have an element in common, return it.
 *	Otherwise return a NULL pointer.
 */
static long *
common_topo(struct bu_ptbl *a_tbl, struct bu_ptbl *next_tbl)
{
	long **p;

	for (p = &a_tbl->buffer[a_tbl->end] ; p >= a_tbl->buffer ; p--) {
		if (bu_ptbl_locate(next_tbl, *p) >= 0)
			return *p;
	}

	return (long *)NULL;
}


static void
visitor(long int *l_p, genptr_t tbl, int after)
{
	(void)bu_ptbl_ins_unique( (struct bu_ptbl *)tbl, l_p);
}

/*
 *	Add an element provided by nmg_visit to a bu_ptbl struct.
 */
static void
build_topo_list(long int *l_p, struct bu_ptbl *tbl)
{
	struct nmg_visit_handlers htab;
	struct loopuse *lu;
	struct edgeuse *eu;
	struct edgeuse *eu_p;
	struct vertexuse *vu;
	struct vertexuse *vu_p;
	int radial_not_mate=0;

	if (!l_p) {
		bu_log("%s:%d NULL l_p\n", __FILE__, __LINE__);
		nmg_rt_segs_exit("");
	}

	switch (*l_p) {
	case NMG_FACEUSE_MAGIC:
		htab = nmg_visit_handlers_null;
		htab.vis_face = htab.vis_edge = htab.vis_vertex = visitor;
		nmg_visit(l_p, &htab, (genptr_t *)tbl);
		break;
	case NMG_EDGEUSE_MAGIC:
		eu = eu_p = (struct edgeuse *)l_p;
		do {
			/* if the parent of this edgeuse is a face loopuse
			 * add the face to the list of shared topology
			 */
			if (*eu->up.magic_p == NMG_LOOPUSE_MAGIC &&
			    *eu->up.lu_p->up.magic_p == NMG_FACEUSE_MAGIC)
				bu_ptbl_ins_unique(tbl,
					(long *)eu->up.lu_p->up.fu_p->f_p);

			if (radial_not_mate)	eu = eu->radial_p;
			else			eu = eu->eumate_p;
			radial_not_mate = ! radial_not_mate;
		} while (eu != eu_p);

		bu_ptbl_ins_unique(tbl, (long *)eu->e_p);
		bu_ptbl_ins_unique(tbl, (long *)eu->vu_p->v_p);
		bu_ptbl_ins_unique(tbl, (long *)eu->eumate_p->vu_p->v_p);

		break;
	case NMG_VERTEXUSE_MAGIC:
		vu_p = (struct vertexuse *)l_p;
		bu_ptbl_ins_unique(tbl, (long *)vu_p->v_p);

		for (BU_LIST_FOR(vu, vertexuse, &vu_p->v_p->vu_hd)) {
			lu = (struct loopuse *)NULL;
			switch (*vu->up.magic_p) {
			case NMG_EDGEUSE_MAGIC:
				eu = vu->up.eu_p;
				bu_ptbl_ins_unique(tbl, (long *)eu->e_p);
				if (*eu->up.magic_p !=  NMG_LOOPUSE_MAGIC)
					break;

				lu = eu->up.lu_p;
				/* fallthrough */

			case NMG_LOOPUSE_MAGIC:
				if ( ! lu ) lu = vu->up.lu_p;

				if (*lu->up.magic_p == NMG_FACEUSE_MAGIC)
					bu_ptbl_ins_unique(tbl,
						(long *)lu->up.fu_p->f_p);
				break;
			case NMG_SHELL_MAGIC:
				break;
			default:
				bu_log("%s[%d]: Bogus vertexuse parent magic:%s.",
					bu_identify_magic( *vu->up.magic_p ));
				nmg_rt_segs_exit("goodbye");
			}
		}
		break;
	default:
		bu_log("%s[%d]: Bogus magic number pointer:%s",
			bu_identify_magic( *l_p ) );
		nmg_rt_segs_exit("goodbye");
	}
}

static void
unresolved(struct hitmiss *a_hit, struct hitmiss *next_hit, struct bu_ptbl *a_tbl, struct bu_ptbl *next_tbl, struct hitmiss *hd, struct ray_data *rd)
{

	struct hitmiss *hm;
	register long **l_p;
	register long **b;

	bu_log("Unable to fix state transition--->\n");
	bu_log( "\tray start = (%f %f %f) dir = (%f %f %f)\n",
		V3ARGS( rd->rp->r_pt ), V3ARGS( rd->rp->r_dir ) );
	for (BU_LIST_FOR(hm, hitmiss, &hd->l)) {
		if (hm == next_hit) {
			bu_log("======= ======\n");
			nmg_rt_print_hitmiss(hm);
			bu_log("================\n");
		} else
			nmg_rt_print_hitmiss(hm);
	}

	bu_log("topo table A\n");
	b = &a_tbl->buffer[a_tbl->end];
	l_p = &a_tbl->buffer[0];
	for ( ; l_p < b ; l_p ++)
		bu_log("\t0x%08x %s\n",**l_p, bu_identify_magic( **l_p));

	bu_log("topo table NEXT\n");
	b = &next_tbl->buffer[next_tbl->end];
	l_p = &next_tbl->buffer[0];
	for ( ; l_p < b ; l_p ++)
		bu_log("\t0x%08x %s\n",**l_p, bu_identify_magic( **l_p));

	bu_log("<---Unable to fix state transition\n");
	pl_ray(rd);
	bu_log("Primitive: %s, pixel=%d %d,  lvl=%d %s\n",
		rd->stp->st_dp->d_namep,
		rd->ap->a_x, rd->ap->a_y, rd->ap->a_level,
		rd->ap->a_purpose );
}


static int
check_hitstate(struct hitmiss *hd, struct ray_data *rd)
{
	struct hitmiss *a_hit;
	struct hitmiss *next_hit;
	int ibs;
	int obs;
	struct bu_ptbl *a_tbl = (struct bu_ptbl *)NULL;
	struct bu_ptbl *next_tbl = (struct bu_ptbl *)NULL;
	struct bu_ptbl *tbl_p = (struct bu_ptbl *)NULL;
	long *long_ptr;

	BU_CK_LIST_HEAD(&hd->l);

#ifndef FAST_NMG
	NMG_CK_HITMISS_LISTS(a_hit, rd);
#endif

	/* find that first "OUTSIDE" point */
	a_hit = BU_LIST_FIRST(hitmiss, &hd->l);
#ifndef FAST_NMG
	NMG_CK_HITMISS(a_hit);
#endif
	if (((a_hit->in_out & 0x0f0) >> 4) != NMG_RAY_STATE_OUTSIDE ||
	    rt_g.NMG_debug & DEBUG_RT_SEGS) {
		bu_log("check_hitstate()\n");
	     	nmg_rt_print_hitlist(hd);

	    	bu_log("Ray: pt:(%g %g %g) dir:(%g %g %g)\n",
	    		V3ARGS(rd->rp->r_pt), V3ARGS(rd->rp->r_dir) );
	}

	while( a_hit != hd &&
		((a_hit->in_out & 0x0f0) >> 4) != NMG_RAY_STATE_OUTSIDE) {
		

#ifndef FAST_NMG
		NMG_CK_HITMISS(a_hit);
#endif
		/* this better be a 2-manifold face */
		bu_log("%s[%d]: This better be a 2-manifold face\n",
			__FILE__, __LINE__);
		bu_log("Primitive: %s, pixel=%d %d,  lvl=%d %s\n",
				rd->stp->st_dp->d_namep,
				rd->ap->a_x, rd->ap->a_y, rd->ap->a_level,
				rd->ap->a_purpose );
		a_hit = BU_LIST_PNEXT(hitmiss, a_hit);
		if (a_hit != hd) {
#ifndef FAST_NMG
			NMG_CK_HITMISS(a_hit);
#endif
		}
	}
	if (a_hit == hd) return 1;

	a_tbl = (struct bu_ptbl *)
		bu_calloc(1, sizeof(struct bu_ptbl), "a_tbl");
	bu_ptbl_init(a_tbl, 64, "a_tbl");


	next_tbl = (struct bu_ptbl *)
		bu_calloc(1, sizeof(struct bu_ptbl), "next_tbl");
	bu_ptbl_init(next_tbl, 64, "next_tbl");

	/* check the state transition on the rest of the hit points */
	while ((next_hit = BU_LIST_PNEXT(hitmiss, &a_hit->l)) != hd) {
#ifndef FAST_NMG
		NMG_CK_HITMISS(next_hit);
#endif
		ibs = HMG_INBOUND_STATE(next_hit);
		obs = HMG_OUTBOUND_STATE(a_hit);
		if (ibs != obs) {
			/* if these two hits share some common topological
			 * element, then we can fix things.
			 *
			 * First we build the table of elements associated
			 * with each hit.
			 */

			bu_ptbl_reset(a_tbl);

#ifndef FAST_NMG
			NMG_CK_HITMISS(a_hit);
#endif
			build_topo_list(a_hit->outbound_use, a_tbl);

			bu_ptbl_reset(next_tbl);
#ifndef FAST_NMG
			NMG_CK_HITMISS(next_hit);
#endif
			build_topo_list(next_hit->outbound_use, next_tbl);


			/* If the tables have elements in common,
			 *   then resolve the conflict by
			 *	morphing the two hits to match.
			 *   else
			 *	This is a real conflict.
			 */
			if ( (long_ptr = common_topo(a_tbl, next_tbl)) ) {
				/* morf the two hit points */
				a_hit->in_out = (a_hit->in_out & 0x0f0) + 
					NMG_RAY_STATE_ON;
				a_hit->outbound_use = long_ptr;

				next_hit->in_out = (next_hit->in_out & 0x0f) +
					(NMG_RAY_STATE_ON << 4);
				a_hit->inbound_use = long_ptr;

			} else 
				unresolved(a_hit, next_hit,
						a_tbl, next_tbl, hd, rd);

		}

		/* save next_tbl as a_tbl for next iteration */
		tbl_p = a_tbl;
		a_tbl = next_tbl;
		next_tbl = tbl_p;

		a_hit = next_hit;
	}

	bu_ptbl_free(next_tbl);
	bu_ptbl_free(a_tbl);
	(void)bu_free( (char *)a_tbl, "a_tbl");
	(void)bu_free( (char *)next_tbl, "next_tbl");

	return 0;
}

/*	N M G _ R A Y _ S E G S
 *
 *	Obtain the list of ray segments which intersect with the nmg.
 *	This routine does all of the "work" for rt_nmg_shot()
 *
 *	Return:
 *		# of segments added to list.
 */
int
nmg_ray_segs(struct ray_data *rd)
{
	struct hitmiss *a_hit;
	static int last_miss=0;

#ifdef DO_LONGJMP
	if (setjmp(nmg_longjump_env) != 0) {
		return 0;
	}
#endif

#ifndef FAST_NMG
	NMG_CK_HITMISS_LISTS(a_hit, rd);
#endif

	if (BU_LIST_IS_EMPTY(&rd->rd_hit)) {

		NMG_FREE_HITLIST( &rd->rd_miss, rd->ap );

		if (rt_g.NMG_debug & DEBUG_RT_SEGS) {
			if (last_miss)	bu_log(".");
			else		bu_log("ray missed NMG\n");
		}
		last_miss = 1;
		return(0);			/* MISS */
	} else if (rt_g.NMG_debug & DEBUG_RT_SEGS) {
		int seg_count=0;

		print_seg_list(rd->seghead, seg_count, "before");

		bu_log("\n\nnmg_ray_segs(rd)\nsorted nmg/ray hit list\n");

		for (BU_LIST_FOR(a_hit, hitmiss, &rd->rd_hit))
			nmg_rt_print_hitmiss(a_hit);
	}

	last_miss = 0;

	if (check_hitstate((struct hitmiss *)&rd->rd_hit, rd)) {
		NMG_FREE_HITLIST( &rd->rd_hit, rd->ap );
		NMG_FREE_HITLIST( &rd->rd_miss, rd->ap );
		return 0;
	}

	if (rt_g.NMG_debug & DEBUG_RT_SEGS) {
		bu_log("----------morphed nmg/ray hit list---------\n");
		for (BU_LIST_FOR(a_hit, hitmiss, &rd->rd_hit))
			nmg_rt_print_hitmiss(a_hit);

		pl_ray(rd);
	}

	{
		int seg_count = nmg_bsegs(rd, rd->ap, rd->seghead, rd->stp);


		NMG_FREE_HITLIST( &rd->rd_hit, rd->ap );
		NMG_FREE_HITLIST( &rd->rd_miss, rd->ap );


		if (rt_g.NMG_debug & DEBUG_RT_SEGS) {
			/* print debugging data before returning */
			print_seg_list(rd->seghead, seg_count, "after");
		}
		return(seg_count);
	}
}

@


11.26
log
@change conf.h to a wrapped config.h
@
text
@d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/librt/nmg_rt_segs.c,v 11.25 2004/04/05 08:48:57 morrison Exp $ (BRL)";
@


11.25
log
@merge of ansi-6-0-branch into HEAD
@
text
@d18 1
a18 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d21 5
a25 1
#include "conf.h"
@


11.24
log
@update copyright to include span through 2003
@
text
@d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_rt_segs.c,v 11.23 2002/08/20 17:08:06 jra Exp $ (BRL)";
d78 1
a78 4
print_seg_list(seghead, seg_count, s)
struct seg *seghead;
int seg_count;
char *s;
d116 1
a116 2
pl_ray(rd)
struct ray_data	*rd;
d226 5
a230 5
set_inpoint(seg_p, a_hit, stp, ap)
struct seg	**seg_p;	/* The segment we're building */
struct hitmiss	*a_hit;		/* The input hit point */
struct soltab	*stp;
struct application	*ap;
d263 3
a265 3
set_outpoint(seg_p, a_hit)
struct seg	**seg_p;	/* The segment we're building */
struct hitmiss	*a_hit;		/* The input hit point */
d306 8
a313 8
state0(seghead, seg_p, seg_count, a_hit, stp, ap, tol)
struct seg	*seghead;	/* intersection w/ ray */
struct seg	**seg_p;	/* The segment we're building */
int		*seg_count;	/* The number of valid segments built */
struct hitmiss	*a_hit;		/* The input hit point */
struct soltab	*stp;
struct application *ap;
struct bn_tol	*tol;
d358 8
a365 8
state1(seghead, seg_p, seg_count, a_hit, stp, ap, tol)
struct seg	*seghead;	/* intersection w/ ray */
struct seg	**seg_p;	/* The segment we're building */
int		*seg_count;	/* The number of valid segments built */
struct hitmiss	*a_hit;		/* The input hit point */
struct soltab	*stp;
struct application *ap;
struct bn_tol	*tol;
d402 8
a409 8
state2(seghead, seg_p, seg_count, a_hit, stp, ap, tol)
struct seg	*seghead;	/* intersection w/ ray */
struct seg	**seg_p;	/* The segment we're building */
int		*seg_count;	/* The number of valid segments built */
struct hitmiss	*a_hit;		/* The input hit point */
struct soltab	*stp;
struct application *ap;
struct bn_tol	*tol;
d496 8
a503 8
state3(seghead, seg_p, seg_count, a_hit, stp, ap, tol)
struct seg	*seghead;	/* intersection w/ ray */
struct seg	**seg_p;	/* The segment we're building */
int		*seg_count;	/* The number of valid segments built */
struct hitmiss	*a_hit;		/* The input hit point */
struct soltab	*stp;
struct application *ap;
struct bn_tol	*tol;
d598 8
a605 8
state4(seghead, seg_p, seg_count, a_hit, stp, ap, tol)
struct seg	*seghead;	/* intersection w/ ray */
struct seg	**seg_p;	/* The segment we're building */
int		*seg_count;	/* The number of valid segments built */
struct hitmiss	*a_hit;		/* The input hit point */
struct soltab	*stp;
struct application *ap;
struct bn_tol	*tol;
d684 8
a691 8
state5(seghead, seg_p, seg_count, a_hit, stp, ap, tol)
struct seg	*seghead;	/* intersection w/ ray */
struct seg	**seg_p;	/* The segment we're building */
int		*seg_count;	/* The number of valid segments built */
struct hitmiss	*a_hit;		/* The input hit point */
struct soltab	*stp;
struct application *ap;
struct bn_tol	*tol;
d776 8
a783 8
state6(seghead, seg_p, seg_count, a_hit, stp, ap, tol)
struct seg	*seghead;	/* intersection w/ ray */
struct seg	**seg_p;	/* The segment we're building */
int		*seg_count;	/* The number of valid segments built */
struct hitmiss	*a_hit;		/* The input hit point */
struct soltab	*stp;
struct application *ap;
struct bn_tol	*tol;
d875 5
a879 5
nmg_bsegs(rd, ap, seghead, stp)
struct ray_data		*rd;
struct application	*ap;
struct seg		*seghead;	/* intersection w/ ray */
struct soltab		*stp;
d960 1
a960 3
common_topo(a_tbl, next_tbl)
struct bu_ptbl *a_tbl;
struct bu_ptbl *next_tbl;
d974 1
a974 4
visitor(l_p, tbl, after)
long *l_p;
genptr_t tbl;
int after;
d983 1
a983 3
build_topo_list(l_p, tbl)
long *l_p;
struct bu_ptbl *tbl;
d1065 1
a1065 7
unresolved(a_hit, next_hit, a_tbl, next_tbl, hd, rd)
struct hitmiss *a_hit;
struct hitmiss *next_hit;
struct bu_ptbl  *a_tbl;
struct bu_ptbl  *next_tbl;
struct hitmiss *hd;
struct ray_data *rd;
d1106 1
a1106 3
check_hitstate(hd, rd)
struct hitmiss *hd;
struct ray_data	*rd;
d1245 1
a1245 2
nmg_ray_segs(rd)
struct ray_data	*rd;
@


11.23
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d14 1
a14 1
 *	This software is Copyright (C) 1993 by the United States Army.
d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_rt_segs.c,v 11.21 2001/11/05 21:20:06 morrison Exp $ (BRL)";
@


11.23.4.1
log
@sync to HEAD...
@
text
@d14 1
a14 1
 *	This software is Copyright (C) 1993-2004 by the United States Army.
d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/nmg_rt_segs.c,v 11.24 2004/02/02 17:39:26 morrison Exp $ (BRL)";
@


11.23.10.1
log
@merge from HEAD
@
text
@d14 1
a14 1
 *	This software is Copyright (C) 1993-2004 by the United States Army.
d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_rt_segs.c,v 11.24 2004/02/02 17:39:26 morrison Exp $ (BRL)";
@


11.23.10.2
log
@merge from head
@
text
@d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_rt_segs.c,v 11.23.10.1 2004/02/12 18:37:45 erikg Exp $ (BRL)";
@


11.23.2.1
log
@Initial ANSIfication
@
text
@d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_rt_segs.c,v 11.23 2002/08/20 17:08:06 jra Exp $ (BRL)";
d78 4
a81 1
print_seg_list(struct seg *seghead, int seg_count, char *s)
d119 2
a120 1
pl_ray(struct ray_data *rd)
d230 5
a234 5
set_inpoint(struct seg **seg_p, struct hitmiss *a_hit, struct soltab *stp, struct application *ap)
          	        	/* The segment we're building */
              	       		/* The input hit point */
             	     
                  	    
d267 3
a269 3
set_outpoint(struct seg **seg_p, struct hitmiss *a_hit)
          	        	/* The segment we're building */
              	       		/* The input hit point */
d310 8
a317 8
state0(struct seg *seghead, struct seg **seg_p, int *seg_count, struct hitmiss *a_hit, struct soltab *stp, struct application *ap, struct bn_tol *tol)
          	         	/* intersection w/ ray */
          	        	/* The segment we're building */
   		           	/* The number of valid segments built */
              	       		/* The input hit point */
             	     
                       
             	     
d362 8
a369 8
state1(struct seg *seghead, struct seg **seg_p, int *seg_count, struct hitmiss *a_hit, struct soltab *stp, struct application *ap, struct bn_tol *tol)
          	         	/* intersection w/ ray */
          	        	/* The segment we're building */
   		           	/* The number of valid segments built */
              	       		/* The input hit point */
             	     
                       
             	     
d406 8
a413 8
state2(struct seg *seghead, struct seg **seg_p, int *seg_count, struct hitmiss *a_hit, struct soltab *stp, struct application *ap, struct bn_tol *tol)
          	         	/* intersection w/ ray */
          	        	/* The segment we're building */
   		           	/* The number of valid segments built */
              	       		/* The input hit point */
             	     
                       
             	     
d500 8
a507 8
state3(struct seg *seghead, struct seg **seg_p, int *seg_count, struct hitmiss *a_hit, struct soltab *stp, struct application *ap, struct bn_tol *tol)
          	         	/* intersection w/ ray */
          	        	/* The segment we're building */
   		           	/* The number of valid segments built */
              	       		/* The input hit point */
             	     
                       
             	     
d602 8
a609 8
state4(struct seg *seghead, struct seg **seg_p, int *seg_count, struct hitmiss *a_hit, struct soltab *stp, struct application *ap, struct bn_tol *tol)
          	         	/* intersection w/ ray */
          	        	/* The segment we're building */
   		           	/* The number of valid segments built */
              	       		/* The input hit point */
             	     
                       
             	     
d688 8
a695 8
state5(struct seg *seghead, struct seg **seg_p, int *seg_count, struct hitmiss *a_hit, struct soltab *stp, struct application *ap, struct bn_tol *tol)
          	         	/* intersection w/ ray */
          	        	/* The segment we're building */
   		           	/* The number of valid segments built */
              	       		/* The input hit point */
             	     
                       
             	     
d780 8
a787 8
state6(struct seg *seghead, struct seg **seg_p, int *seg_count, struct hitmiss *a_hit, struct soltab *stp, struct application *ap, struct bn_tol *tol)
          	         	/* intersection w/ ray */
          	        	/* The segment we're building */
   		           	/* The number of valid segments built */
              	       		/* The input hit point */
             	     
                       
             	     
d879 5
a883 5
nmg_bsegs(struct ray_data *rd, struct application *ap, struct seg *seghead, struct soltab *stp)
               		    
                  	    
          		         	/* intersection w/ ray */
             		     
d964 3
a966 1
common_topo(struct bu_ptbl *a_tbl, struct bu_ptbl *next_tbl)
d980 4
a983 1
visitor(long int *l_p, genptr_t tbl, int after)
d992 3
a994 1
build_topo_list(long int *l_p, struct bu_ptbl *tbl)
d1076 7
a1082 1
unresolved(struct hitmiss *a_hit, struct hitmiss *next_hit, struct bu_ptbl *a_tbl, struct bu_ptbl *next_tbl, struct hitmiss *hd, struct ray_data *rd)
d1123 3
a1125 1
check_hitstate(struct hitmiss *hd, struct ray_data *rd)
d1264 2
a1265 1
nmg_ray_segs(struct ray_data *rd)
@


11.23.2.2
log
@sync branch with HEAD
@
text
@d14 1
a14 1
 *	This software is Copyright (C) 1993-2004 by the United States Army.
d18 1
a18 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.22
log
@Converted from K&R to ANSI C - RFH
@
text
@d78 4
a81 1
print_seg_list(struct seg *seghead, int seg_count, char *s)
d119 2
a120 1
pl_ray(struct ray_data *rd)
d230 5
a234 5
set_inpoint(struct seg **seg_p, struct hitmiss *a_hit, struct soltab *stp, struct application *ap)
          	        	/* The segment we're building */
              	       		/* The input hit point */
             	     
                  	    
d267 3
a269 3
set_outpoint(struct seg **seg_p, struct hitmiss *a_hit)
          	        	/* The segment we're building */
              	       		/* The input hit point */
d310 8
a317 8
state0(struct seg *seghead, struct seg **seg_p, int *seg_count, struct hitmiss *a_hit, struct soltab *stp, struct application *ap, struct bn_tol *tol)
          	         	/* intersection w/ ray */
          	        	/* The segment we're building */
   		           	/* The number of valid segments built */
              	       		/* The input hit point */
             	     
                       
             	     
d362 8
a369 8
state1(struct seg *seghead, struct seg **seg_p, int *seg_count, struct hitmiss *a_hit, struct soltab *stp, struct application *ap, struct bn_tol *tol)
          	         	/* intersection w/ ray */
          	        	/* The segment we're building */
   		           	/* The number of valid segments built */
              	       		/* The input hit point */
             	     
                       
             	     
d406 8
a413 8
state2(struct seg *seghead, struct seg **seg_p, int *seg_count, struct hitmiss *a_hit, struct soltab *stp, struct application *ap, struct bn_tol *tol)
          	         	/* intersection w/ ray */
          	        	/* The segment we're building */
   		           	/* The number of valid segments built */
              	       		/* The input hit point */
             	     
                       
             	     
d500 8
a507 8
state3(struct seg *seghead, struct seg **seg_p, int *seg_count, struct hitmiss *a_hit, struct soltab *stp, struct application *ap, struct bn_tol *tol)
          	         	/* intersection w/ ray */
          	        	/* The segment we're building */
   		           	/* The number of valid segments built */
              	       		/* The input hit point */
             	     
                       
             	     
d602 8
a609 8
state4(struct seg *seghead, struct seg **seg_p, int *seg_count, struct hitmiss *a_hit, struct soltab *stp, struct application *ap, struct bn_tol *tol)
          	         	/* intersection w/ ray */
          	        	/* The segment we're building */
   		           	/* The number of valid segments built */
              	       		/* The input hit point */
             	     
                       
             	     
d688 8
a695 8
state5(struct seg *seghead, struct seg **seg_p, int *seg_count, struct hitmiss *a_hit, struct soltab *stp, struct application *ap, struct bn_tol *tol)
          	         	/* intersection w/ ray */
          	        	/* The segment we're building */
   		           	/* The number of valid segments built */
              	       		/* The input hit point */
             	     
                       
             	     
d780 8
a787 8
state6(struct seg *seghead, struct seg **seg_p, int *seg_count, struct hitmiss *a_hit, struct soltab *stp, struct application *ap, struct bn_tol *tol)
          	         	/* intersection w/ ray */
          	        	/* The segment we're building */
   		           	/* The number of valid segments built */
              	       		/* The input hit point */
             	     
                       
             	     
d879 5
a883 5
nmg_bsegs(struct ray_data *rd, struct application *ap, struct seg *seghead, struct soltab *stp)
               		    
                  	    
          		         	/* intersection w/ ray */
             		     
d964 3
a966 1
common_topo(struct bu_ptbl *a_tbl, struct bu_ptbl *next_tbl)
d980 4
a983 1
visitor(long int *l_p, genptr_t tbl, int after)
d992 3
a994 1
build_topo_list(long int *l_p, struct bu_ptbl *tbl)
d1076 7
a1082 1
unresolved(struct hitmiss *a_hit, struct hitmiss *next_hit, struct bu_ptbl *a_tbl, struct bu_ptbl *next_tbl, struct hitmiss *hd, struct ray_data *rd)
d1123 3
a1125 1
check_hitstate(struct hitmiss *hd, struct ray_data *rd)
d1264 2
a1265 1
nmg_ray_segs(struct ray_data *rd)
@


11.21
log
@Solid to Primitive naming convention conversions
@
text
@d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_rt_segs.c,v 11.20 2001/04/20 22:29:53 morrison Exp $ (BRL)";
d78 1
a78 4
print_seg_list(seghead, seg_count, s)
struct seg *seghead;
int seg_count;
char *s;
d116 1
a116 2
pl_ray(rd)
struct ray_data	*rd;
d226 5
a230 5
set_inpoint(seg_p, a_hit, stp, ap)
struct seg	**seg_p;	/* The segment we're building */
struct hitmiss	*a_hit;		/* The input hit point */
struct soltab	*stp;
struct application	*ap;
d263 3
a265 3
set_outpoint(seg_p, a_hit)
struct seg	**seg_p;	/* The segment we're building */
struct hitmiss	*a_hit;		/* The input hit point */
d306 8
a313 8
state0(seghead, seg_p, seg_count, a_hit, stp, ap, tol)
struct seg	*seghead;	/* intersection w/ ray */
struct seg	**seg_p;	/* The segment we're building */
int		*seg_count;	/* The number of valid segments built */
struct hitmiss	*a_hit;		/* The input hit point */
struct soltab	*stp;
struct application *ap;
struct bn_tol	*tol;
d358 8
a365 8
state1(seghead, seg_p, seg_count, a_hit, stp, ap, tol)
struct seg	*seghead;	/* intersection w/ ray */
struct seg	**seg_p;	/* The segment we're building */
int		*seg_count;	/* The number of valid segments built */
struct hitmiss	*a_hit;		/* The input hit point */
struct soltab	*stp;
struct application *ap;
struct bn_tol	*tol;
d402 8
a409 8
state2(seghead, seg_p, seg_count, a_hit, stp, ap, tol)
struct seg	*seghead;	/* intersection w/ ray */
struct seg	**seg_p;	/* The segment we're building */
int		*seg_count;	/* The number of valid segments built */
struct hitmiss	*a_hit;		/* The input hit point */
struct soltab	*stp;
struct application *ap;
struct bn_tol	*tol;
d496 8
a503 8
state3(seghead, seg_p, seg_count, a_hit, stp, ap, tol)
struct seg	*seghead;	/* intersection w/ ray */
struct seg	**seg_p;	/* The segment we're building */
int		*seg_count;	/* The number of valid segments built */
struct hitmiss	*a_hit;		/* The input hit point */
struct soltab	*stp;
struct application *ap;
struct bn_tol	*tol;
d598 8
a605 8
state4(seghead, seg_p, seg_count, a_hit, stp, ap, tol)
struct seg	*seghead;	/* intersection w/ ray */
struct seg	**seg_p;	/* The segment we're building */
int		*seg_count;	/* The number of valid segments built */
struct hitmiss	*a_hit;		/* The input hit point */
struct soltab	*stp;
struct application *ap;
struct bn_tol	*tol;
d684 8
a691 8
state5(seghead, seg_p, seg_count, a_hit, stp, ap, tol)
struct seg	*seghead;	/* intersection w/ ray */
struct seg	**seg_p;	/* The segment we're building */
int		*seg_count;	/* The number of valid segments built */
struct hitmiss	*a_hit;		/* The input hit point */
struct soltab	*stp;
struct application *ap;
struct bn_tol	*tol;
d776 8
a783 8
state6(seghead, seg_p, seg_count, a_hit, stp, ap, tol)
struct seg	*seghead;	/* intersection w/ ray */
struct seg	**seg_p;	/* The segment we're building */
int		*seg_count;	/* The number of valid segments built */
struct hitmiss	*a_hit;		/* The input hit point */
struct soltab	*stp;
struct application *ap;
struct bn_tol	*tol;
d875 5
a879 5
nmg_bsegs(rd, ap, seghead, stp)
struct ray_data		*rd;
struct application	*ap;
struct seg		*seghead;	/* intersection w/ ray */
struct soltab		*stp;
d960 1
a960 3
common_topo(a_tbl, next_tbl)
struct bu_ptbl *a_tbl;
struct bu_ptbl *next_tbl;
d974 1
a974 4
visitor(l_p, tbl, after)
long *l_p;
genptr_t tbl;
int after;
d983 1
a983 3
build_topo_list(l_p, tbl)
long *l_p;
struct bu_ptbl *tbl;
d1065 1
a1065 7
unresolved(a_hit, next_hit, a_tbl, next_tbl, hd, rd)
struct hitmiss *a_hit;
struct hitmiss *next_hit;
struct bu_ptbl  *a_tbl;
struct bu_ptbl  *next_tbl;
struct hitmiss *hd;
struct ray_data *rd;
d1106 1
a1106 3
check_hitstate(hd, rd)
struct hitmiss *hd;
struct ray_data	*rd;
d1245 1
a1245 2
nmg_ray_segs(rd)
struct ray_data	*rd;
@


11.20
log
@CONST to const
@
text
@d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_rt_segs.c,v 11.19 2000/08/23 00:58:50 mike Exp $ (BRL)";
d919 1
a919 1
			bu_log("Solid: %s, pixel=%d %d, lvl=%d %s\n",
d941 1
a941 1
		bu_log("Solid: %s, pixel=%d %d, lvl=%d %s\n",
d1115 1
a1115 1
	bu_log("Solid: %s, pixel=%d %d,  lvl=%d %s\n",
d1166 1
a1166 1
		bu_log("Solid: %s, pixel=%d %d,  lvl=%d %s\n",
@


11.19
log
@
warning: variable `seg_count' might be clobbered by `longjmp' or `vfork'
@
text
@d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_rt_segs.c,v 11.18 2000/08/21 02:02:33 butler Exp $ (BRL)";
d43 1
a43 1
static CONST 
d52 1
a52 1
static CONST
@


11.18
log
@Massive compilation warnings eliminated
@
text
@d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_rt_segs.c,v 11.17 2000/07/10 23:01:45 mike Exp $ (BRL)";
a1267 1
	int seg_count=0;
d1291 1
d1317 2
a1318 1
	seg_count = nmg_bsegs(rd, rd->ap, rd->seghead, rd->stp);
d1321 2
a1322 2
	NMG_FREE_HITLIST( &rd->rd_hit, rd->ap );
	NMG_FREE_HITLIST( &rd->rd_miss, rd->ap );
d1325 5
a1329 3
	if (rt_g.NMG_debug & DEBUG_RT_SEGS) {
		/* print debugging data before returning */
		print_seg_list(rd->seghead, seg_count, "after");
a1330 2

	return(seg_count);
@


11.17
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_rt_segs.c,v 11.16 1999/12/30 15:41:58 jra Exp $ (BRL)";
d24 1
d30 1
d1223 1
a1223 1
			if (long_ptr = common_topo(a_tbl, next_tbl)) {
@


11.16
log
@ifdef'd out some unused variables
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_rt_segs.c,v 11.15 1999/06/03 01:43:37 mike Exp $ (BRL)";
@


11.15
log
@
sed4
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_rt_segs.c,v 11.14 1997/09/23 21:03:16 jra Exp $ (BRL)";
d40 1
d60 1
a60 1

@


11.14
log
@Added a debug print
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_segs.c,v 11.13 1997/01/14 13:23:58 jra Exp jra $ (BRL)";
d1177 1
a1177 1
		rt_calloc(1, sizeof(struct bu_ptbl), "a_tbl");
d1182 1
a1182 1
		rt_calloc(1, sizeof(struct bu_ptbl), "next_tbl");
d1246 2
a1247 2
	(void)rt_free( (char *)a_tbl, "a_tbl");
	(void)rt_free( (char *)next_tbl, "next_tbl");
@


11.13
log
@Modified invocations of NMG_FREE_HITLIST to use resources.
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_segs.c,v 11.12 1997/01/09 16:15:46 jra Exp jra $ (BRL)";
d1087 2
@


11.12
log
@Removed include of nmg_rt.h.
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_segs.c,v 11.11 1997/01/07 16:08:21 jra Exp jra $ (BRL)";
d1278 1
a1278 1
		NMG_FREE_HITLIST( &rd->rd_miss );
d1299 2
a1300 2
		NMG_FREE_HITLIST( &rd->rd_hit );
		NMG_FREE_HITLIST( &rd->rd_miss );
d1315 2
a1316 2
	NMG_FREE_HITLIST( &rd->rd_hit );
	NMG_FREE_HITLIST( &rd->rd_miss );
@


11.11
log
@Changes to speed up NMG raytracing.
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_segs.c,v 11.10 1996/09/27 08:27:30 mike Exp jra $ (BRL)";
a28 1
#include "./nmg_rt.h"
@


11.10
log
@Converted to using proper routine names for LIBBU and LIBBN routines.
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_segs.c,v 11.9 1996/08/29 22:52:21 butler Exp mike $ (BRL)";
d141 1
d143 1
d890 1
d892 1
d895 1
d897 1
d1134 1
d1136 1
d1140 1
d1142 1
d1156 1
d1158 1
d1168 1
d1170 1
d1186 1
d1188 1
d1201 1
d1203 1
d1207 1
d1209 1
d1273 1
d1275 1
@


11.9
log
@structparse moved to libbu
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_segs.c,v 11.8 1996/08/27 05:48:54 mike Exp butler $ (BRL)";
d43 5
a47 5
	{"%f", 1, "fdotr", offsetof(struct ef_data, fdotr), FUNC_NULL},
	{"%f", 1, "fdotl", offsetof(struct ef_data, fdotl), FUNC_NULL},
	{"%f", 1, "ndotr", offsetof(struct ef_data, ndotr), FUNC_NULL},
	{"%x", 1, "eu",   offsetof(struct ef_data, eu),   FUNC_NULL},
	{"", 0, (char *)NULL,	  0,			  FUNC_NULL}
d52 7
a58 7
{"%f", 1, "hit_dist", offsetof(struct hit, hit_dist), FUNC_NULL},
{"%f", 3, "hit_point", offsetofarray(struct hit, hit_point), FUNC_NULL},
{"%f", 4, "hit_normal", offsetofarray(struct hit, hit_normal), FUNC_NULL},
{"%f", 3, "hit_vpriv", offsetofarray(struct hit, hit_vpriv), FUNC_NULL},
{"%x", 1, "hit_private", offsetof(struct hit, hit_private), FUNC_NULL},
{"%d", 1, "hit_surfno", offsetof(struct hit, hit_surfno), FUNC_NULL},
{"", 0, (char *)NULL,	  0,			  FUNC_NULL}
d63 1
a63 1
	rt_log("%s[line:%d]: Bad seg_p pointer\n", __FILE__, __LINE__); \
d68 1
a68 1
#define nmg_rt_segs_exit(_s) {rt_log("%s\n",_s);longjmp(nmg_longjump_env, -1);}
d83 1
a83 1
	rt_log("Segment List (%d segnemts) (%s):\n", seg_count, s);
d85 1
a85 1
	rt_log("Seghead:\n0x%08x magic: 0x%0x(%d) forw:0x%08x back:0x%08x\n\n",
d91 2
a92 2
	for (RT_LIST_FOR(seg_p, seg, &seghead->l) ) {
		rt_log("0x%08x magic: 0x%0x(%d) forw:0x%08x back:0x%08x\n",
d97 1
a97 1
		rt_log("dist %g  pt(%g,%g,%g)  N(%g,%g,%g)  =>\n",
d105 1
a105 1
		rt_log("dist %g  pt(%g,%g,%g)  N(%g,%g,%g)\n",
d136 1
a136 1
		rt_log("overlay %s\n", name);
d140 1
a140 1
	for (RT_LIST_FOR(a_hit, hitmiss, &rd->rd_hit)) {
d233 1
a233 1
		rt_log("%s[line:%d]: Null pointer to segment pointer\n",
d251 1
a251 1
		rt_log("Set seg_in:\n\tdist %g  pt(%g,%g,%g)  N(%g,%g,%g)\n",
d268 1
a268 1
		rt_log("%s[line:%d]: Null pointer to segment pointer\n",
d284 1
a284 1
		rt_log("Set seg_out:\n\tdist %g  pt(%g,%g,%g)  N(%g,%g,%g)  =>\n",
d292 1
a292 1
		rt_log("\tdist %g  pt(%g,%g,%g)  N(%g,%g,%g)\n",
d313 1
a313 1
struct rt_tol	*tol;
d331 1
a331 1
		rt_log("%s[line:%d]: State transition error: exit without entry.\n",
d348 1
a348 1
		rt_log("%s[line:%d]: bogus hit in/out status\n",
d365 1
a365 1
struct rt_tol	*tol;
d392 1
a392 1
		rt_log("%s[line:%d]: bogus hit in/out status\n",
d409 1
a409 1
struct rt_tol	*tol;
d418 2
a419 2
		RT_LIST_MAGIC_SET( &( (*seg_p)->l ), RT_SEG_MAGIC);
		RT_LIST_INSERT(&(seghead->l), &((*seg_p)->l) );
d433 1
a433 1
		rt_log("%s[line:%d]: State transition error.\n",
d445 1
a445 1
		RT_CK_TOL(tol);
d453 2
a454 2
		RT_LIST_MAGIC_SET( &( (*seg_p)->l ), RT_SEG_MAGIC);
		RT_LIST_INSERT(&(seghead->l), &((*seg_p)->l) );
d466 1
a466 1
		RT_CK_TOL(tol);
d474 2
a475 2
		RT_LIST_MAGIC_SET( &( (*seg_p)->l ), RT_SEG_MAGIC);
		RT_LIST_INSERT(&(seghead->l), &((*seg_p)->l) );
d486 1
a486 1
		rt_log("%s[line:%d]: bogus hit in/out status\n",
d503 1
a503 1
struct rt_tol	*tol;
d509 1
a509 1
	RT_CK_TOL(tol);
d519 2
a520 2
			RT_LIST_MAGIC_SET( &( (*seg_p)->l ), RT_SEG_MAGIC);
			RT_LIST_INSERT(&(seghead->l), &((*seg_p)->l) );
d538 1
a538 1
			rt_log("%s[line:%d]: State transition error.\n",
d561 2
a562 2
			RT_LIST_MAGIC_SET( &( (*seg_p)->l ), RT_SEG_MAGIC);
			RT_LIST_INSERT(&(seghead->l), &((*seg_p)->l) );
d577 2
a578 2
			RT_LIST_MAGIC_SET( &( (*seg_p)->l ), RT_SEG_MAGIC);
			RT_LIST_INSERT(&(seghead->l), &((*seg_p)->l) );
d588 1
a588 1
		rt_log("%s[line:%d]: bogus hit in/out status\n",
d605 1
a605 1
struct rt_tol	*tol;
d614 1
a614 1
		RT_CK_TOL(tol);
d618 2
a619 2
			RT_LIST_MAGIC_SET( &( (*seg_p)->l ), RT_SEG_MAGIC);
			RT_LIST_INSERT(&(seghead->l), &((*seg_p)->l) );
d635 1
a635 1
		rt_log("%s[line:%d]: State transition error.\n",
d641 1
a641 1
		RT_CK_TOL(tol);
d645 2
a646 2
			RT_LIST_MAGIC_SET( &( (*seg_p)->l ), RT_SEG_MAGIC);
			RT_LIST_INSERT(&(seghead->l), &((*seg_p)->l) );
d658 1
a658 1
		RT_CK_TOL(tol);
d662 2
a663 2
			RT_LIST_MAGIC_SET( &( (*seg_p)->l ), RT_SEG_MAGIC);
			RT_LIST_INSERT(&(seghead->l), &((*seg_p)->l) );
d674 1
a674 1
		rt_log("%s[line:%d]: bogus hit in/out status\n",
d691 1
a691 1
struct rt_tol	*tol;
d700 1
a700 1
		RT_CK_TOL(tol);
d706 2
a707 2
			RT_LIST_MAGIC_SET( &( (*seg_p)->l ), RT_SEG_MAGIC);
			RT_LIST_INSERT(&(seghead->l), &((*seg_p)->l) );
d729 1
a729 1
		RT_CK_TOL(tol);
d735 2
a736 2
			RT_LIST_MAGIC_SET( &( (*seg_p)->l ), RT_SEG_MAGIC);
			RT_LIST_INSERT(&(seghead->l), &((*seg_p)->l) );
d748 1
a748 1
		RT_CK_TOL(tol);
d754 2
a755 2
			RT_LIST_MAGIC_SET( &( (*seg_p)->l ), RT_SEG_MAGIC);
			RT_LIST_INSERT(&(seghead->l), &((*seg_p)->l) );
d766 1
a766 1
		rt_log("%s[line:%d]: bogus hit in/out status\n",
d783 1
a783 1
struct rt_tol	*tol;
d792 1
a792 1
		RT_CK_TOL(tol);
d798 2
a799 2
			RT_LIST_MAGIC_SET( &( (*seg_p)->l ), RT_SEG_MAGIC);
			RT_LIST_INSERT(&(seghead->l), &((*seg_p)->l) );
d821 1
a821 1
		RT_CK_TOL(tol);
d827 2
a828 2
			RT_LIST_MAGIC_SET( &( (*seg_p)->l ), RT_SEG_MAGIC);
			RT_LIST_INSERT(&(seghead->l), &((*seg_p)->l) );
d840 1
a840 1
		RT_CK_TOL(tol);
d846 2
a847 2
			RT_LIST_MAGIC_SET( &( (*seg_p)->l ), RT_SEG_MAGIC);
			RT_LIST_INSERT(&(seghead->l), &((*seg_p)->l) );
d858 1
a858 1
		rt_log("%s[line:%d]: bogus hit in/out status\n",
d890 1
a890 1
	for (RT_LIST_FOR(a_hit, hitmiss, &rd->rd_hit)) {
d900 1
a900 1
			for (RT_LIST_FOR(hm, hitmiss, &rd->rd_hit)) {
d902 1
a902 1
					rt_log("======= State %d ======\n",
d905 1
a905 1
					rt_log("================\n");
d911 1
a911 1
			rt_log("Solid: %s, pixel=%d %d, lvl=%d %s\n",
d915 1
a915 1
		    	rt_log("Ray: pt:(%g %g %g) dir:(%g %g %g)\n",
d927 1
a927 1
		rt_log("%s[line:%d]: Input ended at non-terminal FSM state\n",
d930 1
a930 1
	    	rt_log("Ray: pt:(%g %g %g) dir:(%g %g %g)\n",
d933 1
a933 1
		rt_log("Solid: %s, pixel=%d %d, lvl=%d %s\n",
d943 2
a944 2
		RT_LIST_MAGIC_SET( &( seg_p->l ), RT_SEG_MAGIC);
		RT_LIST_INSERT(&(seghead->l), &(seg_p->l) );
d957 2
a958 2
struct nmg_ptbl *a_tbl;
struct nmg_ptbl *next_tbl;
d963 1
a963 1
		if (nmg_tbl(next_tbl, TBL_LOC, *p) >= 0)
d977 1
a977 1
	(void)nmg_tbl( (struct nmg_ptbl *)tbl, TBL_INS_UNIQUE, l_p);
d981 1
a981 1
 *	Add an element provided by nmg_visit to a nmg_ptbl struct.
d986 1
a986 1
struct nmg_ptbl *tbl;
d997 1
a997 1
		rt_log("%s:%d NULL l_p\n", __FILE__, __LINE__);
d1015 1
a1015 1
				nmg_tbl(tbl, TBL_INS_UNIQUE,
d1023 3
a1025 3
		nmg_tbl(tbl, TBL_INS_UNIQUE, (long *)eu->e_p);
		nmg_tbl(tbl, TBL_INS_UNIQUE, (long *)eu->vu_p->v_p);
		nmg_tbl(tbl, TBL_INS_UNIQUE, (long *)eu->eumate_p->vu_p->v_p);
d1030 1
a1030 1
		nmg_tbl(tbl, TBL_INS_UNIQUE, (long *)vu_p->v_p);
d1032 1
a1032 1
		for (RT_LIST_FOR(vu, vertexuse, &vu_p->v_p->vu_hd)) {
d1037 1
a1037 1
				nmg_tbl(tbl, TBL_INS_UNIQUE, (long *)eu->e_p);
d1048 1
a1048 1
					nmg_tbl(tbl, TBL_INS_UNIQUE,
d1054 2
a1055 2
				rt_log("%s[%d]: Bogus vertexuse parent magic:%s.",
					rt_identify_magic( *vu->up.magic_p ));
d1061 2
a1062 2
		rt_log("%s[%d]: Bogus magic number pointer:%s",
			rt_identify_magic( *l_p ) );
d1071 2
a1072 2
struct nmg_ptbl  *a_tbl;
struct nmg_ptbl  *next_tbl;
d1081 2
a1082 2
	rt_log("Unable to fix state transition--->\n");
	for (RT_LIST_FOR(hm, hitmiss, &hd->l)) {
d1084 1
a1084 1
			rt_log("======= ======\n");
d1086 1
a1086 1
			rt_log("================\n");
d1091 1
a1091 1
	rt_log("topo table A\n");
d1095 1
a1095 1
		rt_log("\t0x%08x %s\n",**l_p, rt_identify_magic( **l_p));
d1097 1
a1097 1
	rt_log("topo table NEXT\n");
d1101 1
a1101 1
		rt_log("\t0x%08x %s\n",**l_p, rt_identify_magic( **l_p));
d1103 1
a1103 1
	rt_log("<---Unable to fix state transition\n");
d1105 1
a1105 1
	rt_log("Solid: %s, pixel=%d %d,  lvl=%d %s\n",
d1121 3
a1123 3
	struct nmg_ptbl *a_tbl = (struct nmg_ptbl *)NULL;
	struct nmg_ptbl *next_tbl = (struct nmg_ptbl *)NULL;
	struct nmg_ptbl *tbl_p = (struct nmg_ptbl *)NULL;
d1126 1
a1126 1
	RT_CK_LIST_HEAD(&hd->l);
d1131 1
a1131 1
	a_hit = RT_LIST_FIRST(hitmiss, &hd->l);
d1135 1
a1135 1
		rt_log("check_hitstate()\n");
d1138 1
a1138 1
	    	rt_log("Ray: pt:(%g %g %g) dir:(%g %g %g)\n",
d1148 1
a1148 1
		rt_log("%s[%d]: This better be a 2-manifold face\n",
d1150 1
a1150 1
		rt_log("Solid: %s, pixel=%d %d,  lvl=%d %s\n",
d1154 1
a1154 1
		a_hit = RT_LIST_PNEXT(hitmiss, a_hit);
d1161 3
a1163 3
	a_tbl = (struct nmg_ptbl *)
		rt_calloc(1, sizeof(struct nmg_ptbl), "a_tbl");
	nmg_tbl(a_tbl, TBL_INIT, (long *)NULL);
d1166 3
a1168 3
	next_tbl = (struct nmg_ptbl *)
		rt_calloc(1, sizeof(struct nmg_ptbl), "next_tbl");
	nmg_tbl(next_tbl, TBL_INIT, (long *)NULL);
d1171 1
a1171 1
	while ((next_hit = RT_LIST_PNEXT(hitmiss, &a_hit->l)) != hd) {
d1183 1
a1183 1
			nmg_tbl(a_tbl, TBL_RST, (long *)NULL);
d1188 1
a1188 1
			nmg_tbl(next_tbl, TBL_RST, (long *)NULL);
d1223 2
a1224 2
	nmg_tbl(next_tbl, TBL_FREE, (long *)NULL);
	nmg_tbl(a_tbl, TBL_FREE, (long *)NULL);
d1255 1
a1255 1
	if (RT_LIST_IS_EMPTY(&rd->rd_hit)) {
d1260 2
a1261 2
			if (last_miss)	rt_log(".");
			else		rt_log("ray missed NMG\n");
d1269 1
a1269 1
		rt_log("\n\nnmg_ray_segs(rd)\nsorted nmg/ray hit list\n");
d1271 1
a1271 1
		for (RT_LIST_FOR(a_hit, hitmiss, &rd->rd_hit))
d1284 2
a1285 2
		rt_log("----------morphed nmg/ray hit list---------\n");
		for (RT_LIST_FOR(a_hit, hitmiss, &rd->rd_hit))
@


11.8
log
@Changed name of global symbol 'env' because it was conflicting
with application-specific variables.
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_segs.c,v 11.7 1996/07/12 12:17:41 jra Exp mike $ (BRL)";
d42 1
a42 1
struct structparse rt_ef_parsetab[] = {
d51 1
a51 1
struct structparse rt_hit_parsetab[] = {
@


11.7
log
@Minor Mods for IRIX 6.2
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_segs.c,v 11.6 1996/04/24 22:18:36 butler Exp jra $ (BRL)";
d67 2
a68 2
jmp_buf env;
#define nmg_rt_segs_exit(_s) {rt_log("%s\n",_s);longjmp(env, -1);}
d1248 1
a1248 1
	if (setjmp(env) != 0) {
@


11.6
log
@moved/modified pl_ray()
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_segs.c,v 11.5 1995/03/03 12:06:34 mike Exp butler $ (BRL)";
d75 1
a75 1
static
@


11.5
log
@solid/pixel debugging output
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_segs.c,v 11.4 95/03/03 11:35:07 mike Exp Locker: mike $ (BRL)";
d116 67
d184 3
d911 4
a914 4
			rt_log("Solid: %s, pixel=%d,%d, lvl=%d %s\n",
				stp->st_dp->d_namep,
				ap->a_x, ap->a_y, ap->a_level,
				ap->a_purpose );
d933 1
a933 1
		rt_log("Solid: %s, pixel=%d,%d, lvl=%d %s\n",
d1068 1
a1068 1
unresolved(a_hit, next_hit, a_tbl, next_tbl, hd)
d1074 1
d1087 1
a1087 1
		} else 
d1102 1
a1102 1
	
d1104 5
d1150 4
d1211 1
a1211 1
						a_tbl, next_tbl, hd);
a1230 70
static void
pl_ray(rd)
struct ray_data	*rd;
{
	FILE *fd;
	char name[80];
	static int plot_file_number=0;
	struct hitmiss *a_hit;
	int old_state = NMG_RAY_STATE_OUTSIDE;
	int in_state;
	int out_state;
	point_t old_point;
	point_t end_point;
	int old_cond = 0;

	sprintf(name, "nmg_ray%02d.pl", plot_file_number++);
	if ((fd=fopen(name, "w")) == (FILE *)NULL) {
		perror(name);
		abort();
	} else
		rt_log("overlay %s\n", name);

	VMOVE(old_point, rd->rp->r_pt);

	for (RT_LIST_FOR(a_hit, hitmiss, &rd->rd_hit)) {
		NMG_CK_HITMISS(a_hit);

		in_state = HMG_INBOUND_STATE(a_hit);
		out_state = HMG_OUTBOUND_STATE(a_hit);

		if (in_state == old_state) {
			switch(in_state) {
			case NMG_RAY_STATE_INSIDE:
				pl_color(fd, 55, 255, 55);
				pdv_3line(fd, old_point, a_hit->hit.hit_point);
				break;
			case NMG_RAY_STATE_ON:
				pl_color(fd, 155, 155, 255);
				pdv_3line(fd, old_point, a_hit->hit.hit_point);
				break;
			case NMG_RAY_STATE_OUTSIDE:
				pl_color(fd, 255, 255, 255);
				pdv_3line(fd, old_point, a_hit->hit.hit_point);
				break;
			}
			old_cond = 0;
		} else {
			if (old_cond) {
				pl_color(fd, 255, 155, 255);
				old_cond = 0;
			} else {
				pl_color(fd, 255, 55, 255);
				old_cond = 1;
			}
			pdv_3line(fd, old_point, a_hit->hit.hit_point);
		}
		VMOVE(old_point, a_hit->hit.hit_point);
		old_state = out_state;
	}

	if (old_state == NMG_RAY_STATE_OUTSIDE)
		pl_color(fd, 255, 255, 255);
	else
		pl_color(fd, 255, 55, 255);

	VADD2(end_point, old_point, rd->rp->r_dir);
	pdv_3line(fd, old_point, end_point);

	fclose(fd);
}
@


11.4
log
@Added printing of solid name and pixel coordinate.
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_segs.c,v 11.3 95/03/01 07:48:21 butler Exp Locker: mike $ (BRL)";
d863 4
@


11.3
log
@checkpoint
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_segs.c,v 11.2 1995/02/21 11:16:59 butler Exp butler $ (BRL)";
d841 4
@


11.2
log
@checkpoint
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_segs.c,v 11.1 1995/01/04 09:58:17 mike Rel4_4 butler $ (BRL)";
d1143 67
d1211 2
d1269 2
@


11.1
log
@Release_4.4
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_segs.c,v 1.20 94/12/30 11:03:26 stay Exp $ (BRL)";
d64 9
a72 1
	rt_bomb("Goodbye"); }
d165 1
a165 1
		rt_bomb("Goodbye");
d200 1
a200 1
		rt_bomb("Goodbye");
d205 1
a205 1
		rt_bomb("bad seg pointer\n");
d280 1
a280 1
		rt_bomb("Goodbye\n");
d324 1
a324 1
		rt_bomb("Goodbye\n");
d418 1
a418 1
		rt_bomb("Goodbye\n");
d520 1
a520 1
		rt_bomb("Goodbye\n");
d606 1
a606 1
		rt_bomb("Goodbye\n");
d698 1
a698 1
		rt_bomb("Goodbye\n");
d790 1
a790 1
		rt_bomb("Goodbye\n");
d841 3
a843 1
			rt_bomb("Goodbye\n");
d855 5
a859 1
		rt_bomb("Goodbye");
d918 5
d978 1
a978 1
				rt_bomb("goodbye");
d985 1
a985 1
		rt_bomb("goodbye");
d1028 2
a1029 2
static void
check_hitstate(hd)
d1031 1
d1042 4
d1048 9
d1058 5
a1062 2
	while( a_hit != hd && 
	     ((a_hit->in_out & 0x0f0)>>4) != NMG_RAY_STATE_OUTSIDE) {
d1067 3
d1071 1
a1071 1

d1084 1
d1096 2
d1101 1
d1139 2
d1148 3
d1160 6
d1190 5
a1194 1
	check_hitstate((struct hitmiss *)&rd->rd_hit);
a1205 1

@


1.20
log
@fixed initialization error, on the vax, a space is required between
the "=" and the "operand" for initialization, thus
	p=&a_tbl->buffer[a_tbl->end] becomes
	p = &a_tbl->buffer[a_tbl->end]
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_segs.c,v 1.19 94/12/20 15:15:47 jra Exp Locker: stay $ (BRL)";
@


1.19
log
@Minor mod for CRAY.
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_segs.c,v 1.18 94/11/08 03:43:43 mike Exp $ (BRL)";
d870 1
a870 1
	for (p=&a_tbl->buffer[a_tbl->end] ; p >= a_tbl->buffer ; p--) {
@


1.18
log
@Irix 6.
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_segs.c,v 1.17 94/11/08 03:35:57 mike Exp Locker: mike $ (BRL)";
d1136 1
a1136 1
	check_hitstate(&rd->rd_hit);
@


1.17
log
@JRA fix to make tabs explicit
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_segs.c,v 1.16 94/09/01 23:53:31 mike Exp Locker: jra $ (BRL)";
d41 2
a42 2
static
struct structparse ef_parsetab[] = {
d50 2
a51 2
static
struct structparse hit_parsetab[] = {
a289 1
	double delta;
d785 2
a1014 1
	int curr_state;
a1016 3
	int bad_state;
	char *a_list;
	char *next_list;
a1019 1
	struct nmg_visit_handlers       htab;
a1021 3
	htab = nmg_visit_handlers_null;	/* struct copy */
	htab.vis_face = htab.vis_edge = htab.vis_vertex = visitor;

a1043 1
	curr_state = HMG_OUTBOUND_STATE(a_hit);
@


1.16
log
@Fixed pointer problem that was preventing compilation on VAPOR
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_segs.c,v 1.15 94/09/01 23:34:43 butler Exp Locker: mike $ (BRL)";
d173 1
a173 1
		rt_log("Set seg_in:\n\  dist %g  pt(%g,%g,%g)  N(%g,%g,%g)\n",
d206 1
a206 1
		rt_log("Set seg_out:\n\  dist %g  pt(%g,%g,%g)  N(%g,%g,%g)  =>\n",
d214 1
a214 1
		rt_log("  dist %g  pt(%g,%g,%g)  N(%g,%g,%g)\n",
@


1.15
log
@checkpoint
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_segs.c,v 1.14 1994/08/24 22:48:54 butler Exp butler $ (BRL)";
d881 1
a881 1
struct nmg_ptbl *tbl;
d884 1
a884 1
	(void)nmg_tbl(tbl, TBL_INS_UNIQUE, l_p);
@


1.14
log
@checkpoint
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_segs.c,v 1.13 94/08/20 05:28:18 butler Exp Locker: butler $ (BRL)";
d877 10
d891 3
a893 4
visitor(l, tbl, i)
long *l;
genptr_t tbl;
int i;
d895 72
a966 1
	(void)nmg_tbl((struct nmg_ptbl *)tbl, TBL_INS_UNIQUE, l);
d969 8
d978 30
d1064 1
a1064 2
			
			nmg_visit((long *)a_hit->outbound_use, &htab, a_tbl);
d1067 1
a1067 2
			nmg_visit((long *)next_hit->inbound_use, &htab,
					next_tbl);
d1086 4
a1089 3
			} else {
				rt_bomb("Unable to fix state transition\n");
			}
@


1.13
log
@checkpoint
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_segs.c,v 1.12 94/08/16 16:51:18 butler Exp Locker: butler $ (BRL)";
d253 1
a253 1
		rt_log("%s[line:%d]: State transition error.\n",
d855 2
d858 10
d869 4
a872 2
	if (rt_g.NMG_debug & DEBUG_RT_SEGS && RT_LIST_NON_EMPTY(&rd->rd_miss))
		rt_log("freeing miss point(s)\n");
d874 46
a919 5
	while ( RT_LIST_NON_EMPTY(&rd->rd_miss) ) {
		a_hit = RT_LIST_FIRST(hitmiss, &rd->rd_miss);
		NMG_CK_HITMISS(a_hit);
		RT_LIST_DEQUEUE( &a_hit->l );
		rt_free((char *)a_hit, "freeing miss point");
d922 65
a986 1
	return seg_count;
a989 1

d1006 3
d1027 8
a1036 2
	if (!(rt_g.NMG_debug & DEBUG_RT_SEGS))
		return(seg_count);
d1038 9
a1046 2
	/* print debugging data before returning */
	print_seg_list(rd->seghead, seg_count, "after");
@


1.12
log
@checkpoint
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_segs.c,v 1.11 94/08/10 20:33:02 gdurf Exp Locker: butler $ (BRL)";
d24 1
d61 6
d68 1
a68 1
print_seg_list(seghead)
d70 2
d75 1
a75 1
	rt_log("Segment List:\n");
d77 6
d84 6
a89 1
		rt_log("dist %g  pt(%g,%g,%g)  N(%g,%g,%g)  =>  ",
d113 13
a125 12
 *	Input	| 0   1   2   3   4   5   6
 *	-------------------------------------
 *	O_N  =	| 1   1  C1   5   1   5   5
 *	O_N !=	| 1  1|E C1  C1  C1  C1  C1
 *	N_N  =	| E   1   E   3   E   1   6    
 *	N_N !=	| E   1   E   E   E   1   1   
 *	N_O  =	| E   2   2  ?2   E   2   2
 *	N_O !=	| E   2   2   E   E   2   2
 *	O_O  =	| 3   2   2   3   3   6   6
 *	O_O !=	| 3  2|E C3  C3  C3  C3  C3
 *	A_A  =	| 4   1   2   3   4   8   6
 *	A_A !=	| 4   1  C4  C4  C4  C4  C4
a126 1
 *
a129 1
 *
d131 4
a134 3
 *	C	current segment now completed
 *	C_	Previous segment now completed
 *
d137 1
d147 18
d166 2
d169 2
d172 11
d184 14
d199 2
d202 2
d205 19
a224 8
#define MAKE_SEG(in_hit, out_hit) \
	RT_GET_SEG(seg_p, ap->a_resource); \
	RT_CK_SEG(seg_p); \
	seg_p->seg_stp = stp; \
	bcopy(&in_hit->hit, &seg_p->seg_in, sizeof(struct hit)); \
	bcopy(&out_hit->hit, &seg_p->seg_out, sizeof(struct hit)); \
	seg_count++; \
	RT_LIST_INSERT(&(seghead->l), &(seg_p->l) )
d227 11
d239 40
d280 516
d802 5
a806 3
	int ray_state = NMG_RAY_STATE_OUTSIDE;
	struct hitmiss *in_hit = (struct hitmiss *)NULL;
	struct hitmiss *a_hit;
a807 1
	struct seg *seg_p;
d811 1
a811 4

	while (RT_LIST_NON_EMPTY(&rd->rd_hit) ) {

		a_hit = RT_LIST_FIRST(hitmiss, &rd->rd_hit);
a812 1
		RT_LIST_DEQUEUE( &a_hit->l );
d814 16
a829 11
		if (ray_state == NMG_RAY_STATE_OUTSIDE) {
			switch (a_hit->in_out) {
			case HMG_HIT_OUT_IN:
			case HMG_HIT_OUT_ON:
				in_hit = a_hit;
				break;
			case HMG_HIT_ANY_ANY:
				/* Hit a Non-3-Manifold */
			case HMG_HIT_OUT_OUT:
				if (in_hit)
					rt_bomb("What should I have done?\n");
d831 3
a833 6
				/* build the seg */
				MAKE_SEG(a_hit, a_hit);
				VMOVE(seg_p->seg_in.hit_normal,
					a_hit->inbound_norm);
				VMOVE(seg_p->seg_out.hit_normal,
					a_hit->outbound_norm);
d835 2
a836 20
				ray_state = NMG_RAY_STATE_INSIDE;
				break;
			case HMG_HIT_IN_IN:
			case HMG_HIT_IN_ON:
			case HMG_HIT_ON_IN:
			case HMG_HIT_ON_ON:
				if (!in_hit)
					rt_bomb("How did I get in?\n");
				/* if we're already inside, just eat this */
				break;
			case HMG_HIT_IN_OUT:
			case HMG_HIT_ON_OUT:
				if (!in_hit)
					rt_bomb("How can I be leaving when I haven't entered?\n");
				/* build the seg */
				MAKE_SEG(in_hit, a_hit);
				VMOVE(seg_p->seg_in.hit_normal,
					in_hit->inbound_norm);
				VMOVE(seg_p->seg_out.hit_normal,
					a_hit->outbound_norm);
d838 8
a845 24
				in_hit = (struct hitmiss *)NULL;
				ray_state = NMG_RAY_STATE_INSIDE;
				break;
			default:
				rt_bomb("Bogus ray state while leaving\n");
				break;
			}
		} else { /* ray_state == NMG_RAY_STATE_INSIDE */
			switch (a_hit->in_out) {
			case HMG_HIT_IN_OUT:
			case HMG_HIT_ON_OUT:
				/* "eat" the hit point */
				break;
			case HMG_HIT_IN_IN:
			case HMG_HIT_IN_ON:
			case HMG_HIT_ON_IN:
			case HMG_HIT_ON_ON:
				rt_bomb("I've already left the NMG and this guy wants to stay inside\n");
				break;
			case HMG_HIT_OUT_IN:
			case HMG_HIT_OUT_ON:
				ray_state = NMG_RAY_STATE_OUTSIDE;
				in_hit = a_hit;
				break;
d847 6
a852 15
			case HMG_HIT_ANY_ANY:
			case HMG_HIT_OUT_OUT:
				ray_state = NMG_RAY_STATE_OUTSIDE;
				/* build the seg */
				MAKE_SEG(a_hit, a_hit);
				VMOVE(seg_p->seg_in.hit_normal,
					in_hit->inbound_norm);
				VMOVE(seg_p->seg_out.hit_normal,
					a_hit->outbound_norm);
				break;
			default:
				rt_bomb("Bogus ray state while leaving\n");
				break;
			}
		}
d856 1
d896 2
d912 1
a912 1
	print_seg_list(rd->seghead);
@


1.11
log
@Added include of conf.h
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_segs.c,v 1.10 94/07/01 01:38:37 butler Exp Locker: butler $ (BRL)";
d90 1
a90 409
 *	We know we've hit a wire.  Make the appropriate 0-length segment.
 *	The caller is responsible for removing the hit point from the hitlist.
 */
static int
wire_hit(e_p, seg_p, rp, a_hit)
struct edge	*e_p;
struct seg	*seg_p;
struct xray	*rp;
struct hitmiss	*a_hit;
{

	vect_t eray;

	/* we've got a wire edge.
	 *
	 * Generate a normal for the edge which is perpendicular to
	 * the edge in the plane formed by the ray and the edge.
	 *
	 */

	bcopy(&a_hit->hit, &seg_p->seg_in, sizeof(struct hit));
	bcopy(&a_hit->hit, &seg_p->seg_out, sizeof(struct hit));

	/* make the normal for the ray
	 *
	 * make ray of edge
	 */
	VSUB2(eray, e_p->eu_p->vu_p->v_p->vg_p->coord,
		e_p->eu_p->eumate_p->vu_p->v_p->vg_p->coord);
	
	/* make N perpendicular to ray and edge */
	VCROSS(seg_p->seg_in.hit_normal, rp->r_dir, eray);

	/* make N point toward ray origin in plane of ray and edge */
	VCROSS(seg_p->seg_in.hit_normal, eray,
		seg_p->seg_in.hit_normal);

	/* reverse normal for out-point */
	VREVERSE(seg_p->seg_out.hit_normal, seg_p->seg_in.hit_normal);

	return(2);

}

#define LEFT_MIN_ENTER	0
#define LEFT_MIN_EXIT	1
#define LEFT_MAX_ENTER	2
#define LEFT_MAX_EXIT	3
#define RIGHT_MIN_ENTER	4
#define RIGHT_MIN_EXIT	5
#define RIGHT_MAX_ENTER	6
#define RIGHT_MAX_EXIT	7


static void
sort_eus(prime_uses, e_p, tbl, rp, left_vect)
struct ef_data prime_uses[];
struct edge *e_p;
char tbl[];
struct xray *rp;
vect_t left_vect;
{
	struct ef_data tmp;
	struct face_g *fg_p;
	vect_t face_vect;
	vect_t edge_vect;
	vect_t edge_opp_vect;
	vect_t eu_vect;
	struct edgeuse *teu;

	if (rt_g.NMG_debug & DEBUG_RT_SEGS)
		rt_log("sort_eus\n");

	NMG_CK_EDGE(e_p);
	NMG_CK_EDGE_G(e_p->eg_p);


	if (rt_g.NMG_debug & DEBUG_RT_SEGS)
		VPRINT("ray_vect", rp->r_dir);

	VMOVE(edge_vect, e_p->eg_p->e_dir);
	VREVERSE(edge_opp_vect, e_p->eg_p->e_dir);
	if (rt_g.NMG_debug & DEBUG_RT_SEGS)
		VPRINT("edge_vect", edge_vect);

	/* compute the "left" vector  which is perpendicular to the edge
	 * and the ray
	 */
	VCROSS(left_vect, edge_vect, rp->r_dir);

	if (rt_g.NMG_debug & DEBUG_RT_SEGS)
		VPRINT("left_vect", left_vect);

	VUNITIZE(left_vect);

	/* compute the relevant dot products for each edge/face about
	 * this edge.
	 */
	tmp.eu = e_p->eu_p;
	do {
	    plane_t	plane;
	    /* we only care about the 3-manifold edge uses */
		
	    if (NMG_MANIFOLDS(tbl, tmp.eu) & NMG_3MANIFOLD) {

		NMG_CK_LOOPUSE(tmp.eu->up.lu_p);
		NMG_CK_FACEUSE(tmp.eu->up.lu_p->up.fu_p);
		   NMG_CK_FACE(tmp.eu->up.lu_p->up.fu_p->f_p);
		 NMG_CK_FACE_G(tmp.eu->up.lu_p->up.fu_p->f_p->fg_p);

		fg_p = tmp.eu->up.lu_p->up.fu_p->f_p->fg_p;
		NMG_GET_FU_PLANE( plane, tmp.eu->up.lu_p->up.fu_p );

		if (rt_g.NMG_debug & DEBUG_RT_SEGS) {
			rt_log("\n");
			HPRINT("plane_eqn", plane);
		}
		
		if (tmp.eu->up.lu_p->up.fu_p->orientation == OT_SAME)
			teu = tmp.eu;
		else
			teu = tmp.eu->eumate_p;

		VSUB2(eu_vect, teu->vu_p->v_p->vg_p->coord,
			teu->eumate_p->vu_p->v_p->vg_p->coord);

		if (VDOT(e_p->eg_p->e_dir, eu_vect) < 0) {
			VCROSS(face_vect, edge_opp_vect, plane);
		} else {
			VCROSS(face_vect, edge_vect, plane);
		}
		VUNITIZE(face_vect);

		if (rt_g.NMG_debug & DEBUG_RT_SEGS) {
			VPRINT("face_vect", face_vect);
		}
		/* figure out if this is one of the prime edgeuses */
		tmp.fdotr = VDOT(face_vect, rp->r_dir);
		tmp.fdotl = VDOT(face_vect, left_vect);
		tmp.ndotr = VDOT(plane,     rp->r_dir);

#define SAVE(a) prime_uses[a].fdotl = tmp.fdotl;	\
		prime_uses[a].fdotr = tmp.fdotr;	\
		prime_uses[a].ndotr = tmp.ndotr;	\
		prime_uses[a].eu = tmp.eu

		if (rt_g.NMG_debug & DEBUG_RT_SEGS)
			rt_structprint("tmp", ef_parsetab, (char *)&tmp);

		if (tmp.fdotl >= 0.0) {
			/* face is on "left" of ray */
			if ( tmp.ndotr > 0.0 ) {
				/* ray is "leaving" face */
				if (tmp.fdotr < prime_uses[LEFT_MIN_EXIT].fdotr) {
					SAVE(LEFT_MIN_EXIT);
				}
				if (tmp.fdotr > prime_uses[LEFT_MAX_EXIT].fdotr) {
					SAVE(LEFT_MAX_EXIT);
				}
			} else {
				/* ray is "entering" face */
				if (tmp.fdotr < prime_uses[LEFT_MIN_ENTER].fdotr) {
					SAVE(LEFT_MIN_ENTER);
				}
				if (tmp.fdotr > prime_uses[LEFT_MAX_ENTER].fdotr) {
					SAVE(LEFT_MAX_ENTER);
				}
			}
		} else {
			/* face is on "right" of ray */
			if ( tmp.ndotr > 0.0 ) {
				/* ray is "leaving face */
				if (tmp.fdotr < prime_uses[RIGHT_MIN_EXIT].fdotr) {
					SAVE(RIGHT_MIN_EXIT);
				}
				if (tmp.fdotr > prime_uses[RIGHT_MAX_EXIT].fdotr) {
					SAVE(RIGHT_MAX_EXIT);
				}
			} else {
				/* ray is "entering" face */
				if (tmp.fdotr < prime_uses[RIGHT_MIN_ENTER].fdotr) {
					SAVE(RIGHT_MIN_ENTER);
				}
				if (tmp.fdotr > prime_uses[RIGHT_MAX_ENTER].fdotr) {
					SAVE(RIGHT_MAX_ENTER);
				}
			}
		}
	    }
	    tmp.eu = tmp.eu->radial_p->eumate_p;

	} while (tmp.eu != e_p->eu_p);
}


static
v_neighborhood(v_p, tbl, rp)
struct vertex *v_p;
char		*tbl;
struct xray	*rp;
{

	NMG_CK_VERTEX(v_p);
	

}


/*
 *	if we hit a 3 manifold for seg_in we enter the solid
 *	if we hit a 3 manifold for seg_out we leave the solid
 *	if we hit a 0,1or2 manifold for seg_in, we enter/leave the solid.
 *	if we hit a 0,1or2 manifold for seg_out, we ignore it.
 */
static int
vertex_hit(v_p, seg_p, rp, tbl, a_hit, filled)
struct vertex	*v_p;
struct seg	*seg_p;
struct xray	*rp;
char		*tbl;
struct hitmiss	*a_hit;
int		filled;
{

	char manifolds = NMG_MANIFOLDS(tbl, v_p);
	struct faceuse *fu_p;
	struct vertexuse *vu_p;
	int entries = 0;
	int exits = 0;
	vect_t	saved_normal;
	fastf_t BestRdotN = 5.0;
	fastf_t RdotN;
	struct face_g *fg;
	vect_t	normal;

	if (manifolds & NMG_3MANIFOLD) {

		for (RT_LIST_FOR(vu_p, vertexuse, &v_p->vu_hd)) {
			if (NMG_MANIFOLDS(tbl, vu_p) & NMG_3MANIFOLD ||
			    NMG_MANIFOLDS(tbl, vu_p) & NMG_2MANIFOLD) {

				switch (*vu_p->up.magic_p) {
				case NMG_EDGEUSE_MAGIC:
					NMG_CK_LOOPUSE(vu_p->up.eu_p->up.lu_p);
					NMG_CK_FACEUSE(vu_p->up.eu_p->up.lu_p->up.fu_p);
					   NMG_CK_FACE(vu_p->up.eu_p->up.lu_p->up.fu_p->f_p);
					 NMG_CK_FACE_G(vu_p->up.eu_p->up.lu_p->up.fu_p->f_p->fg_p);
					fg = vu_p->up.eu_p->up.lu_p->up.fu_p->f_p->fg_p;
					NMG_GET_FU_NORMAL( normal, vu_p->up.eu_p->up.lu_p->up.fu_p );

					break;
				case NMG_LOOPUSE_MAGIC:
					NMG_CK_FACEUSE(vu_p->up.eu_p->up.lu_p->up.fu_p);
					NMG_CK_FACE(vu_p->up.eu_p->up.lu_p->up.fu_p->f_p);
					NMG_CK_FACE_G(vu_p->up.eu_p->up.lu_p->up.fu_p->f_p->fg_p);
					fg = vu_p->up.eu_p->up.lu_p->up.fu_p->f_p->fg_p;
					NMG_GET_FU_NORMAL( normal, vu_p->up.eu_p->up.lu_p->up.fu_p );
					break;
				}

				if ((RdotN = VDOT(rp->r_dir, normal)) < 0) {
					entries++;
					if (-1.0 * RdotN < BestRdotN) {
						BestRdotN = fabs(RdotN);
						VMOVE(saved_normal, normal);
					}
				} else {
					exits++;
					if (RdotN < BestRdotN) {
						BestRdotN = fabs(RdotN);
						VMOVE(saved_normal, normal);
					}
				}
			}
		}

		if (entries && !exits && filled == 0) {
			/* single in-bound hit */
			bcopy(&a_hit->hit, &seg_p->seg_in,sizeof(struct hit));
			VMOVE(seg_p->seg_in.hit_normal, saved_normal);
			filled++;
		} else if (exits && !entries && filled) {
			/* single out-bound hit */
			bcopy(&a_hit->hit, &seg_p->seg_in,sizeof(struct hit));
			VMOVE(seg_p->seg_in.hit_normal, saved_normal);
			filled++;
		}else {

			/* there are both faces which the ray "enters" and
			 * faces which it "exits" at this vertex  We have
			 * to determine what is really happening here.
			 */
			v_neighborhood(v_p, tbl, rp);
		}

		RT_LIST_DEQUEUE(&a_hit->l);
		rt_free((char *)a_hit, "freeing hitpoint");

	} else if (manifolds & NMG_2MANIFOLD) {
	    /* we've hit the corner of a dangling face */
	    if (filled == 0) {
		register int found=0;

		/* find a surface normal */
		for (RT_LIST_FOR(vu_p, vertexuse, &v_p->vu_hd)) {

			if (NMG_MANIFOLDS(tbl, vu_p) & NMG_2MANIFOLD &&
			    !(NMG_MANIFOLDS(tbl, vu_p) & NMG_3MANIFOLD) ) {
				found = 1; break;
			}
		}
		
		bcopy(&a_hit->hit, &seg_p->seg_in, sizeof(struct hit));
		bcopy(&a_hit->hit, &seg_p->seg_out, sizeof(struct hit));

		if (found) {
			/* we've found a 2manifold vertexuse.
			 * get a pointer to the faceuse and get the
			 * normal from the face
			 */

			if (*vu_p->up.magic_p == NMG_EDGEUSE_MAGIC)
				fu_p = vu_p->up.eu_p->up.lu_p->up.fu_p;
			else if (*vu_p->up.magic_p == NMG_LOOPUSE_MAGIC)
				fu_p = vu_p->up.lu_p->up.fu_p;
			else  {
				fu_p = (struct faceuse *)NULL;
				rt_bomb("vertex_hit: bad vu->up\n");
				/* NOTREACHED */
			}
			NMG_GET_FU_NORMAL( normal, fu_p );

			if (VDOT(normal, rp->r_dir) > 0.0) {
				VREVERSE(seg_p->seg_in.hit_normal, normal);
				VMOVE(seg_p->seg_out.hit_normal, normal);
			} else {
				VMOVE(seg_p->seg_in.hit_normal, normal);
				VREVERSE(seg_p->seg_out.hit_normal, normal);
			}

		} else {
			/* we didn't find a face.  How did this happen? */
			rt_log("2manifold lone vertex?\n");
			VREVERSE(seg_p->seg_in.hit_normal, rp->r_dir);
			VMOVE(seg_p->seg_out.hit_normal, rp->r_dir);

			filled = 2;
		}
	    }
	    RT_LIST_DEQUEUE(&a_hit->l);
	    rt_free((char *)a_hit, "freeing hitpoint");

	} else if (manifolds & NMG_1MANIFOLD) {
	    /* we've hit the end of a wire.
	     * this is the same as for hitting a wire.
	     */
	    if (filled == 0) {
		/* go looking for a wire edge */
		for (RT_LIST_FOR(vu_p, vertexuse, &v_p->vu_hd)) {
		    /* if we find an edge which is only a 1 manifold
		     * we'll call edge_hit with it
		     */
		    if (*vu_p->up.magic_p == NMG_EDGEUSE_MAGIC &&
			! (NMG_MANIFOLDS(tbl, vu_p->up.eu_p->e_p) &
			(NMG_3MANIFOLD|NMG_2MANIFOLD)) &&
			(NMG_MANIFOLDS(tbl, vu_p->up.eu_p->e_p) &
			NMG_1MANIFOLD) ) {
			    filled = wire_hit(vu_p->up.eu_p->e_p,
						seg_p, rp, a_hit);
						
			    break;
		    }
		}
		if (filled == 0) {
			/* we didn't find an edge.  How did this happen? */
			rt_log("1manifold lone vertex?\n");
			bcopy(&a_hit->hit, &seg_p->seg_in, sizeof(struct hit));
			bcopy(&a_hit->hit, &seg_p->seg_out, sizeof(struct hit));
			VREVERSE(seg_p->seg_in.hit_normal, rp->r_dir);
			VMOVE(seg_p->seg_out.hit_normal, rp->r_dir);

			filled = 2;
		}
	    }
	    RT_LIST_DEQUEUE(&a_hit->l);
	    rt_free((char *)a_hit, "freeing hitpoint");

	} else if (manifolds & NMG_0MANIFOLD ) {
	    if (filled == 0) {
		/* we've hit a lone vertex */
		bcopy(&a_hit->hit, &seg_p->seg_in, sizeof(struct hit));
		bcopy(&a_hit->hit, &seg_p->seg_out, sizeof(struct hit));
		VREVERSE(seg_p->seg_in.hit_normal, rp->r_dir);
		VMOVE(seg_p->seg_out.hit_normal, rp->r_dir);

		filled = 2;
	    }
	    RT_LIST_DEQUEUE(&a_hit->l);
	    rt_free((char *)a_hit, "freeing hitpoint");
	}

	return(filled);
}



/*
 *	Fill in a seg struct to reflect a grazing hit of a solid on an
 *	edge.
d92 31
a122 7
 *	^  /___
 *	| /____
 *	|/_____
 *	o______
 *	|\_____
 *	| \____
 *	|  \___
a123 10
static void
edge_ray_graze(a_hit, seg_p, i_u, in, out, s)
struct seg	*seg_p;
struct hitmiss	*a_hit;
struct ef_data i_u[8];	/* "important" uses of edge */
int in, out;
char *s;
{
	if (rt_g.NMG_debug & DEBUG_RT_SEGS)
		rt_log("edge_ray_graze(%s)\n", s);
a124 8
	bcopy(&a_hit->hit, &seg_p->seg_in, sizeof(struct hit));
	bcopy(&a_hit->hit, &seg_p->seg_out, sizeof(struct hit));
				
	NMG_GET_FU_NORMAL( seg_p->seg_in.hit_normal,
		i_u[in].eu->up.lu_p->up.fu_p );
				
	NMG_GET_FU_NORMAL( seg_p->seg_out.hit_normal,
		i_u[out].eu->up.lu_p->up.fu_p );
a125 2
	RT_LIST_DEQUEUE(&a_hit->l);
	rt_free((char *)a_hit, "freeing hitpoint");
a126 11
}
/*
 *	Fill in a seg struct to reflect entering a solid at a point
 *	on the edge.
 */
static void
edge_enter_solid(a_hit, seg_p, i_u)
struct seg	*seg_p;
struct hitmiss	*a_hit;
struct ef_data *i_u;	/* "important" uses of edge */
{
a127 13
	if (rt_g.NMG_debug & DEBUG_RT_SEGS)
		rt_log("edge_enter_solid()\n");
	/* we enter solid, normal from face
	 * with most anti-rayward normal
	 *
	 *	____ ______
	 *      ____^______
	 *      ____|______
    	 *	____o______
	 *	___/|\_____
	 *	__/ | \____
	 *	_/  |  \___
	 */
a128 6
		if (rt_g.NMG_debug & DEBUG_RT_SEGS) {
			rt_log("edge_enter_solid w/ ray_hit_distance %g (%g %g %g)",
				a_hit->hit.hit_dist,
				a_hit->hit.hit_point[0],
				a_hit->hit.hit_point[1],
				a_hit->hit.hit_point[2]);
a129 8
			switch ( *(int*)a_hit->hit.hit_private) {
			case NMG_FACE_MAGIC: rt_log("\tface\n"); break;
			case NMG_EDGE_MAGIC: rt_log("\tedge\n"); break;
			case NMG_VERTEX_MAGIC: rt_log("\tvertex\n"); break;
			default : rt_log(" hit unknown magic (%d)\n", 
				*(int*)a_hit->hit.hit_private); break;
			}
		}
a130 1
	bcopy(&a_hit->hit, &seg_p->seg_in, sizeof(struct hit));
a131 7
	if (i_u[LEFT_MIN_ENTER].ndotr < i_u[RIGHT_MIN_ENTER].ndotr) {
		NMG_GET_FU_NORMAL( seg_p->seg_in.hit_normal,
			i_u[LEFT_MIN_ENTER].eu->up.lu_p->up.fu_p );
	} else {
		NMG_GET_FU_NORMAL( seg_p->seg_in.hit_normal,
			i_u[RIGHT_MIN_ENTER].eu->up.lu_p->up.fu_p );
	}
a132 2
	RT_LIST_DEQUEUE(&a_hit->l);
	rt_free((char *)a_hit, "freeing hitpoint");
a133 510
}



/*
 *	Fill in seg struct to reflect hitting an edge & exiting solid
 *	at same point on edge
 */
static void
edge_zero_depth_hit(a_hit, seg_p, i_u)
struct seg	*seg_p;
struct hitmiss	*a_hit;
struct ef_data *i_u;	/* "important" uses of edge */
{

	if (rt_g.NMG_debug & DEBUG_RT_SEGS)
		rt_log("edge_zero_depth_hit()\n");
	/* zero depth hit
    	 *
	 *	_\  ^  /___
	 *	__\ | /____
	 *	___\|/_____
    	 *	____o______
	 *	___/|\_____
	 *	__/ | \____
	 *	_/  |  \___
	 */
	bcopy(&a_hit->hit, &seg_p->seg_in, sizeof(struct hit));
	bcopy(&a_hit->hit, &seg_p->seg_out, sizeof(struct hit));

    	/* choose an entry hit normal */
	if (i_u[LEFT_MIN_ENTER].ndotr < i_u[RIGHT_MIN_ENTER].ndotr) {
		NMG_GET_FU_NORMAL( seg_p->seg_in.hit_normal,
			i_u[LEFT_MIN_ENTER].eu->up.lu_p->up.fu_p );
	} else {
		NMG_GET_FU_NORMAL( seg_p->seg_in.hit_normal,
			i_u[RIGHT_MIN_ENTER].eu->up.lu_p->up.fu_p );
	}

    	/* choose an exit hit normal */
	if (i_u[LEFT_MIN_EXIT].ndotr > i_u[RIGHT_MIN_EXIT].ndotr) {
		NMG_GET_FU_NORMAL( seg_p->seg_out.hit_normal,
			i_u[LEFT_MIN_EXIT].eu->up.lu_p->up.fu_p );
	} else {
		NMG_GET_FU_NORMAL( seg_p->seg_out.hit_normal,
			i_u[RIGHT_MIN_EXIT].eu->up.lu_p->up.fu_p );
	}
	RT_LIST_DEQUEUE(&a_hit->l);
	rt_free((char *)a_hit, "freeing hitpoint");

}

/*
 *	Fill in seg structure to reflect that the ray leaves the solid at
 *	this hit location.
 */
static void
edge_leave_solid(a_hit, seg_p, i_u)
struct seg	*seg_p;
struct hitmiss	*a_hit;
struct ef_data *i_u;	/* "important" uses of edge */
{

	if (rt_g.NMG_debug & DEBUG_RT_SEGS)
		rt_log("edge_leave_solid()\n");
	/* leave solid
	*
	* 	   ^
	*	   |
	*	   o
	*	  /|\
	*	 /_|_\
	*	/__|__\
	*          |
	*/

	bcopy(&a_hit->hit, &seg_p->seg_out, sizeof(struct hit));

	/* pick an exit normal */
	if (i_u[LEFT_MIN_EXIT].ndotr > i_u[RIGHT_MIN_EXIT].ndotr) {
		NMG_GET_FU_NORMAL( seg_p->seg_out.hit_normal,
			i_u[LEFT_MIN_EXIT].eu->up.lu_p->up.fu_p);

	} else {
		NMG_GET_FU_NORMAL( seg_p->seg_out.hit_normal,
			i_u[RIGHT_MIN_EXIT].eu->up.lu_p->up.fu_p);
	}

	RT_LIST_DEQUEUE(&a_hit->l);
	rt_free((char *)a_hit, "freeing hitpoint");

}

static void
edge_confusion(a_hit, i_u, file, line)
struct hitmiss	*a_hit;
struct ef_data i_u[8];	/* "important" uses of edge */
char *file;
int line;
{

	if (file)
		rt_log("edge_hit() in %s at %d is confused\n", file, line);

	rt_structprint("LEFT_MIN_ENTER", ef_parsetab,
		(char *)&i_u[LEFT_MIN_ENTER]);
	rt_structprint("LEFT_MIN_EXIT", ef_parsetab,
		(char *)&i_u[LEFT_MIN_EXIT]);
	rt_structprint("LEFT_MAX_ENTER", ef_parsetab,
		(char *)&i_u[LEFT_MAX_ENTER]);
	rt_structprint("LEFT_MAX_EXIT", ef_parsetab,
		(char *)&i_u[LEFT_MAX_EXIT]);
	rt_structprint("RIGHT_MIN_ENTER", ef_parsetab,
		(char *)&i_u[RIGHT_MIN_ENTER]);
	rt_structprint("RIGHT_MIN_EXIT", ef_parsetab,
		(char *)&i_u[RIGHT_MIN_EXIT]);
	rt_structprint("RIGHT_MAX_ENTER", ef_parsetab,
		(char *)&i_u[RIGHT_MAX_ENTER]);
	rt_structprint("RIGHT_MAX_EXIT", ef_parsetab,
		(char *)&i_u[RIGHT_MAX_EXIT]);

}

/*
 *	if we hit a 3 manifold for seg_in we enter the solid
 *	if we hit a 3 manifold for seg_out we leave the solid
 *	if we hit a 1or2 manifold for seg_in, we enter/leave the solid.
 *	if we hit a 1or2 manifold for seg_out, we ignore it.
 */
static int
edge_hit(e_p, seg_p, rp, tbl, a_hit, filled)
struct edge	*e_p;
struct seg	*seg_p;
struct xray	*rp;
char		*tbl;
struct hitmiss	*a_hit;
int		filled;
{

	struct edgeuse *eu_p;
	char manifolds = NMG_MANIFOLDS(tbl, e_p);
	
	if (rt_g.NMG_debug & DEBUG_RT_SEGS)
		rt_log("edge_hit()\n");

	if (manifolds & NMG_3MANIFOLD) {
	
	    /* if the ray enters or leaves the solid via an edge, it is at
	     * the juncture of exactly two faces.  To determine which two
	     * faces, it is necessary to sort the faces about this edge
	     * radially about the edge.
	     *
	     * Taking the cross product of an edgeuse vector and the face
	     * normal, we get a pointer "into" and "along the surface" of
	     * the face.  We enter the solid between the two faces for which
	     * these "face vectors" are most anti-ray-ward and whose surface
	     * normals have an anti-ray-ward component.  There must
	     * be such a face on each "side" of the edge to enter or leave
	     * the solid at this edge.
	     *
	     * Likewise, we leave the solid between the two faces for which
	     * the "face vectors" are most ray-ward and whose surface normals
	     * have a ray-ward component.
	     *
	     * To differentiate sidedness, we cross the ray with an edge
	     * vector to get a vector perpendicular to the edge and the ray.
	     * this vector is said to point "left" of the ray wrt the edge.
	     *
	     *		 	^  _
	     *			|  /|
	     *			| /
	     *			|/
	     *	 "left"	<-------/
	     *		       /|
	     *		      / |
	     *		     /  |
	     *		   ray  edge
	     *
	     *
	     * If we are found to be entering the solid at an edge, we leave
	     * it again at the edge if there is a pair of "exit" faces
	     * (faces on each side of the ray/edge with ray-ward pointing
	     * "face vectors")
	     * "behind" the entry faces.  Likewise, a ray leaving a solid at
	     * an edge may re-enter the solid at the edge if there are a
	     * pair of "entry" faces "behind" the exit faces.
	     */
	    vect_t left_vect;
	    struct ef_data i_u[8];	/* "important" uses of edge */
	    register int i;

	    /*
	     * First we "sort" the faces to find the "important" ones.
	     */

	    bzero(i_u, sizeof(i_u));

	    i_u[LEFT_MIN_ENTER].fdotr = 2.0;
	    i_u[LEFT_MAX_ENTER].fdotr = -2.0;
	    i_u[LEFT_MIN_EXIT].fdotr = 2.0;
	    i_u[LEFT_MAX_EXIT].fdotr = -2.0;

	    i_u[RIGHT_MIN_ENTER].fdotr = 2.0;
	    i_u[RIGHT_MAX_ENTER].fdotr = -2.0;
	    i_u[RIGHT_MIN_EXIT].fdotr = 2.0;
	    i_u[RIGHT_MAX_EXIT].fdotr = -2.0;

	    sort_eus(i_u, e_p, tbl, rp, left_vect);

	    if (rt_g.NMG_debug & DEBUG_RT_SEGS) {
		rt_log("\nedge_hit 3MANIFOLD\n");
		edge_confusion(a_hit, i_u, (char *)NULL, 0);
	    }

	    /* now find the two faces we're looking for */
	    if (filled) {
		/* we're looking for an exit (then entry) point */

		if (i_u[LEFT_MIN_EXIT].eu) {
			if (i_u[RIGHT_MIN_EXIT].eu) {
				if (i_u[LEFT_MAX_ENTER].eu !=
				    i_u[LEFT_MIN_ENTER].eu &&
				    i_u[RIGHT_MAX_ENTER].eu !=
				    i_u[RIGHT_MIN_ENTER].eu ){

					/* leave & re-enter solid */

					if (rt_g.NMG_debug & DEBUG_RT_SEGS)
						rt_log("edge_hit leave&re-enter\n");

					RT_LIST_DEQUEUE(&a_hit->l);
					rt_free((char *)a_hit,
						"freeing hitpoint");

				} else {
					/* leave solid */
					edge_leave_solid(a_hit, seg_p, i_u);
					filled++;
				}
			} else if (i_u[LEFT_MAX_ENTER].eu){
				/* graze exterior of solid on left */

				RT_LIST_DEQUEUE(&a_hit->l);
				rt_free((char *)a_hit, "freeing hitpoint");

				if (rt_g.NMG_debug & DEBUG_RT_SEGS)
					rt_log("edge_hit graze exterior on left\n");
			} else {
				/* What's going on? */

				edge_confusion(a_hit, i_u, __FILE__, __LINE__);
				rt_bomb("goodbye\n");

				RT_LIST_DEQUEUE(&a_hit->l);
				rt_free((char *)a_hit, "freeing hitpoint");
			}
		} else if (i_u[RIGHT_MIN_EXIT].eu &&
		    i_u[RIGHT_MAX_ENTER].eu != i_u[RIGHT_MIN_EXIT].eu) {

			/* grazing exterior of solid on right */
			if (rt_g.NMG_debug & DEBUG_RT_SEGS)
				rt_log("edge_hit graze exterior on right\n");
			RT_LIST_DEQUEUE(&a_hit->l);
			rt_free((char *)a_hit, "freeing hitpoint");
		} else {
			/* What's going on? */
    			edge_confusion(a_hit, i_u, __FILE__, __LINE__);
			rt_bomb("goodbye\n");

			RT_LIST_DEQUEUE(&a_hit->l);
			rt_free((char *)a_hit, "freeing hitpoint");
		}

	    } else if (i_u[LEFT_MIN_ENTER].eu) /* filled == 0 */ {
		/* we're looking for an entry (then exit) point on the 
		 * solid at this point.
		 */

		if (i_u[RIGHT_MIN_ENTER].eu) {
			if (i_u[LEFT_MAX_ENTER].eu !=
			    i_u[LEFT_MIN_ENTER].eu &&
			    i_u[RIGHT_MAX_ENTER].eu != 
			    i_u[RIGHT_MIN_ENTER].eu ) {
				edge_zero_depth_hit(a_hit, seg_p, i_u);
    				filled = 2;
			} else {
				edge_enter_solid(a_hit, seg_p, i_u);
    				filled = 1;
				if (rt_g.NMG_debug & DEBUG_RT_SEGS) {
					rt_log("added %d to segment: ", filled);
					rt_pr_seg(seg_p);
				}
			}
		} else if (i_u[LEFT_MAX_EXIT].eu &&
			i_u[LEFT_MAX_EXIT].eu !=
			i_u[LEFT_MAX_ENTER].eu) {

			/* grazing hit on solid to left
			 *
			 *	__\ ^
			 *	___\|
			 *	____o
			 *	___/|
			 *	__/ |
			 */
			edge_ray_graze(a_hit, seg_p, i_u,
					LEFT_MIN_ENTER, LEFT_MAX_EXIT, "left");
			filled = 2;
		} else {
			/* How did I get here? */
    			edge_confusion(a_hit, i_u, __FILE__, __LINE__);
			rt_bomb("goodbye\n");

			RT_LIST_DEQUEUE(&a_hit->l);
			rt_free((char *)a_hit, "freeing hitpoint");
		}
	    } else if (i_u[RIGHT_MIN_ENTER].eu &&
			i_u[RIGHT_MAX_EXIT].eu !=
			i_u[RIGHT_MIN_ENTER].eu) {
    			/* grazing hit on solid to right
		   	 *
			 *	^ /____
			 *	|/_____
			 *	o______
			 *	|\_____
			 *	| \____
    			 */
			edge_ray_graze(a_hit, seg_p, i_u,
				RIGHT_MIN_ENTER, RIGHT_MAX_EXIT, "right");
			filled = 2;
	    } else {
    			/* How did this happen? */
    			edge_confusion(a_hit, i_u, __FILE__, __LINE__);
			rt_bomb("goodbye\n");

			RT_LIST_DEQUEUE(&a_hit->l);
			rt_free((char *)a_hit, "freeing hitpoint");
	    }

	} else if (manifolds & NMG_2MANIFOLD) {
	    if (filled == 0) {
		/* hit a 2-manifold in space ( dangling face ) */

		bcopy(&a_hit->hit, &seg_p->seg_in, sizeof(struct hit));
		bcopy(&a_hit->hit, &seg_p->seg_out, sizeof(struct hit));

		eu_p = e_p->eu_p;

		/* go looking for a use of this edge in a 2-Manifold */

		while ( ! (NMG_MANIFOLDS(tbl, eu_p) & NMG_2MANIFOLD) &&
		    eu_p->radial_p->eumate_p != e_p->eu_p)
			eu_p = eu_p->radial_p->eumate_p;

		if (NMG_MANIFOLDS(tbl, eu_p) & NMG_2MANIFOLD ) {
			vect_t	normal;
			NMG_GET_FU_NORMAL( normal, eu_p->up.lu_p->up.fu_p );

			if (VDOT(normal, rp->r_dir) > 0.0) {
				VMOVE(seg_p->seg_out.hit_normal, normal);
				VREVERSE(seg_p->seg_in.hit_normal, normal);
			} else {
				VMOVE(seg_p->seg_in.hit_normal, normal);
				VREVERSE(seg_p->seg_out.hit_normal, normal);
			}
		}
		
	    }
	    RT_LIST_DEQUEUE(&a_hit->l);
	    rt_free((char *)a_hit, "freeing hitpoint");

	} else if (manifolds & NMG_1MANIFOLD) {
	    if (filled == 0) {
		filled = wire_hit(e_p, seg_p, rp, a_hit);
	    }
	    RT_LIST_DEQUEUE(&a_hit->l);
	    rt_free((char *)a_hit, "freeing hitpoint");
	}

	return(filled);
}

/*
 *	if we hit a 3 manifold face for seg_in, we're entering a solid
 *	if we hit a 3 manifold face for seg_out, we're leaving a solid
 *	if we hit a 2 manifold face for seg_in, we're entering/leaving a solid
 *	if we hit a 2 manifold face for seg_out, it's ignored
 */
static int
face_hit(f_p, seg_p, rp, tbl, a_hit, filled)
struct face	*f_p;
struct seg	*seg_p;
struct xray	*rp;
char		*tbl;
struct hitmiss	*a_hit;
int		filled;
{

	char manifolds = NMG_MANIFOLDS(tbl, f_p);
	vect_t	normal;

	RT_CK_SEG(seg_p);

	if( f_p->flip ) {
		VREVERSE( normal, f_p->fg_p->N );
	} else {
		VMOVE( normal, f_p->fg_p->N );
	}

	if (manifolds & NMG_3MANIFOLD) {
		if (filled == 0) {
			/* entering solid */
			bcopy(&a_hit->hit, &seg_p->seg_in, sizeof(struct hit));
			VMOVE(seg_p->seg_in.hit_normal, normal);
			filled = 1;
		} else {
			/* leaving solid */
			bcopy(&a_hit->hit, &seg_p->seg_out, sizeof(struct hit));
			VMOVE(seg_p->seg_out.hit_normal, normal);
			filled = 2;
		}

		if (rt_g.NMG_debug & DEBUG_RT_SEGS) {
			rt_log("added %d to segment: ", filled);
			rt_pr_seg(seg_p);
 		}

	} else if (filled == 0) {
		/* just hit an exterior dangling face */

		bcopy(&a_hit->hit, &seg_p->seg_in, sizeof(struct hit));
		bcopy(&a_hit->hit, &seg_p->seg_out, sizeof(struct hit));
		if (VDOT(normal, rp->r_dir) <= 0.0) {
			/* face normal points back along ray */
			VMOVE(seg_p->seg_in.hit_normal, normal);
			VMOVE(seg_p->seg_out.hit_normal, normal);
		} else {
			VREVERSE(seg_p->seg_in.hit_normal, normal);
			VREVERSE(seg_p->seg_out.hit_normal, normal);
		}

		filled = 2;
		if (rt_g.NMG_debug & DEBUG_RT_SEGS) {
			rt_log("added %d to segment: ", filled);
			rt_pr_seg(seg_p);
		}
	}

	RT_LIST_DEQUEUE(&a_hit->l);
	rt_free((char *)a_hit, "freeing hitpoint");

	return(filled);
}

/*
 *	Faced with an apparent conflict in the ray state, see if we can
 *	reconcile the conflict.
 *
 *	If we can reconcile the conflict
 *		return a non-zero,
 *	otherwise
 *		return zero.
 */
static int
reconcile(prev_hit, curr_hit)
struct hitmiss *curr_hit;
struct hitmiss *prev_hit;
{
	struct faceuse *fu;

	NMG_CK_HITMISS(curr_hit);

	/* if we have a conflict on the very first hit, there is nothing 
	 * to do about it;
	 */
	if (!prev_hit)
		return 0;

	/* If we have a conflict between a hit on a face, and a hit on an
	 * edge or vertex of that face, then we can resolve the issue.
	 */
	if ( *prev_hit->outbound_use == NMG_EDGEUSE_MAGIC &&
	    *curr_hit->inbound_use == NMG_FACEUSE_MAGIC) {
		fu=nmg_find_fu_of_eu((struct edgeuse *)prev_hit->outbound_use);
		if ((long *)fu == curr_hit->inbound_use ||
		    (long *)fu->fumate_p == curr_hit->inbound_use)
			return 1;
	} else if (*curr_hit->inbound_use == NMG_EDGEUSE_MAGIC &&
	    *prev_hit->outbound_use == NMG_FACEUSE_MAGIC) {
		fu=nmg_find_fu_of_eu((struct edgeuse *)curr_hit->inbound_use);
		if ((long *)fu == prev_hit->outbound_use ||
		    (long *)fu->fumate_p == prev_hit->outbound_use)
			return 1;
	} else if ( *prev_hit->outbound_use == NMG_VERTEXUSE_MAGIC &&
	    *curr_hit->inbound_use == NMG_FACEUSE_MAGIC) {
		fu=nmg_find_fu_of_vu((struct vertexuse *)prev_hit->outbound_use);
		if ((long *)fu == curr_hit->inbound_use ||
		    (long *)fu->fumate_p == curr_hit->inbound_use)
			return 1;
	} else if (*curr_hit->outbound_use == NMG_VERTEXUSE_MAGIC &&
	    *prev_hit->inbound_use == NMG_FACEUSE_MAGIC) {
		fu=nmg_find_fu_of_vu((struct vertexuse *)curr_hit->inbound_use);
		if ((long *)fu == prev_hit->outbound_use ||
		    (long *)fu->fumate_p == prev_hit->outbound_use)
			return 1;
	}
	return 0;
}


d181 4
d202 4
d237 4
d250 3
a256 2
		if (rt_g.NMG_debug & DEBUG_RT_SEGS)
			rt_log("freeing miss point\n");
a262 7
static int
nmg_build_segs(rd, ap, seghead, stp)
struct ray_data		*rd;
struct application	*ap;
struct seg		*seghead;	/* intersection w/ ray */
struct soltab		*stp;
{
a263 8
	struct seg *seg_p;
	int seg_count=0;
	struct hitmiss *curr_hit;
	struct hitmiss *prev_hit;
	char *tbl;
	int hits_filled;
	static struct hitmiss dummy;
		
a264 212

	tbl = rd->rd_m->manifolds;

	/* build up the list of segments based upon the hit points.
	 */

	curr_hit = (struct hitmiss *)NULL;
	hits_filled = 0;

	while (RT_LIST_NON_EMPTY(&rd->rd_hit) ) {

		prev_hit = curr_hit;
		curr_hit = RT_LIST_FIRST(hitmiss, &rd->rd_hit);
		NMG_CK_HITMISS(curr_hit);
		RT_LIST_DEQUEUE( &curr_hit->l );

/* 					Current Ray State
 * Next Element			Inside		On		Outside
 * ----------------------------------------------------------------------
 * HMG_HIT_IN_IN		OK		?OK		BAD
 * HMG_HIT_IN_OUT		OK		?OK		BAD
 * HMG_HIT_OUT_IN		BAD		BAD		OK
 * HMG_HIT_OUT_OUT		BAD		BAD		OK
 * HMG_HIT_IN_ON		OK		?OK		BAD
 * HMG_HIT_ON_IN		?OK		OK		BAD
 * HMG_HIT_OUT_ON		BAD		BAD		OK
 * HMG_HIT_ON_OUT		?OK		OK		BAD
 * HMG_HIT_ANY_ANY		OK->Inside	OK->On		OK->Outside
 */

		if (!prev_hit || (prev_hit->in_out & 0x0f) == NMG_RAY_STATE_OUTSIDE) {

			switch (curr_hit->in_out) {
			case HMG_HIT_IN_IN   :
			case HMG_HIT_IN_OUT  :
			case HMG_HIT_IN_ON   :
			case HMG_HIT_ON_IN   :
			case HMG_HIT_ON_OUT  :
				rt_log("%s %d: ray state violation\n\tNMG_RAY_STATE_OUTSIDE followed by hit:\n\t",
					__FILE__, __LINE__);
				nmg_rt_print_hitmiss(curr_hit);
				if (reconcile(prev_hit, curr_hit))
					rt_log("---- reconciled ----\n");
				else
					rt_bomb("bombing");
				break;

			case HMG_HIT_OUT_ON  :
				/* fallthrough */
			case HMG_HIT_OUT_IN  :
#if 0
				if (hits_filled != 0)
					rt_bomb("Why hits_filled != 0?\n");
				RT_GET_SEG(seg_p, ap->a_resource);
				RT_CK_SEG(seg_p);
				seg_p->seg_stp = stp;
				bcopy(&curr_hit->hit, seg_p->seg_in,
					sizeof(struct hit));
				hits_filled = 1;
#endif
				break;
			case HMG_HIT_OUT_OUT :
#if 0
				if (hits_filled != 0)
					rt_bomb("Why hits_filled != 0?\n");
				RT_GET_SEG(seg_p, ap->a_resource);
				RT_CK_SEG(seg_p);
				seg_p->seg_stp = stp;
				bcopy(&curr_hit->hit, seg_p->seg_in,
					sizeof(struct hit));
				bcopy(&curr_hit->hit, seg_p->seg_out,
					sizeof(struct hit));
#endif
				break;
			case HMG_HIT_ANY_ANY  :
				/* hits_filled better be 0 */
				/* copy 2 hits */
				/* hits_filled = 0 */
				break;
			default:
				rt_log("%s %d: Bogus in_out value 0x%0x\n",
					__FILE__, __LINE__, curr_hit->in_out);
				break;
			}
		} else if ((prev_hit->in_out & 0x0f) == NMG_RAY_STATE_INSIDE ||
		    (prev_hit->in_out & 0x0f) == NMG_RAY_STATE_ON) {
			switch (curr_hit->in_out) {
			case HMG_HIT_ANY_ANY  :
				/* fallthrough */
			case HMG_HIT_IN_IN   :
				/* copy 2 hits */
				break;
			case HMG_HIT_IN_OUT  :
				/* hits_filled should be 1 */
				/* copy 1 hit */
				break;
			case HMG_HIT_IN_ON   :
				/* copy 2 hits */
				break;
			case HMG_HIT_ON_IN   :
				/* copy 2 hits */
				break;
			case HMG_HIT_ON_OUT  :
				/* hits_filled should be 1 */
				/* copy 1 hit */
				break;

				break;

			case HMG_HIT_OUT_IN  :
			case HMG_HIT_OUT_OUT :
			case HMG_HIT_OUT_ON  :
				switch (prev_hit->in_out & 0x0f) {
				case NMG_RAY_STATE_ON:
					rt_log("%s %d: ray state violation\n\tNMG_RAY_STATE_INSIDE followed by hit:\n\t",
						__FILE__, __LINE__);
					break;
				case NMG_RAY_STATE_INSIDE:
					rt_log("%s %d: ray state violation\n\tNMG_RAY_STATE_INSIDE followed by hit:\n\t",
						__FILE__, __LINE__);
					break;
				}
				nmg_rt_print_hitmiss(curr_hit);
				if (reconcile(prev_hit, curr_hit))
					rt_log("---- reconciled ----\n");
				else
					rt_bomb("bombing");
				break;
			default:
				rt_log("%s %d: Bogus in_out value 0x%0x\n",
					__FILE__, __LINE__, curr_hit->in_out);
				break;
			}
		}

#if 0



state = out;
inpoint = null;

while (get hit) {

    if (state = out)
	switch (in_out)
	case OUT_ON: 
	case OUT_IN: inpoint = hit
		break;
	case IN_IN:
	case ON_IN:
	case IN_ON:
	case ON_ON:	
		if (inpoint)
			/* eat it */
		else
			error
		break;
	case IN_OUT:
	case ON_OUT:
		if (inpoint) {
			build seg
			state = in
		} else error
		break;
	case OUT_OUT
		if (!inpoint)
			build seg on point
		else
			build seg?
    else /* state == in */
	switch (in_out)
	case HMG_HIT_IN_OUT:	/* eat it */
	case HMG_HIT_ON_OUT:	/* eat it */

	case HMG_HIT_OUT_IN:	/* state = out, inpoint = hit */
	case HMG_HIT_OUT_ON:	/* state = out, inpoint = hit */
	case HMG_HIT_OUT_OUT:	/* state = out, build seg on point */
}


		switch (hits_filled) {
		case 1:
		case 2:
			if (!seg_p) {
			RT_GET_SEG(seg_p, ap->a_resource);
			RT_CK_SEG(seg_p);
			seg_p->seg_stp = stp;
			bcopy(&curr_hit->hit, seg_p->seg_in, sizeof(struct hit));

			/* fallthrough */
		case 0:
		}



		

	    ++seg_count;
	    if (rt_g.NMG_debug & DEBUG_RT_SEGS) {
		rt_log("adding segment %d to seg list\n", seg_count);
		rt_pr_seg(seg_p);
	    }

	    RT_LIST_INSERT(&(seghead->l), &(seg_p->l) );
#endif
	}
	return(seg_count);

}


d276 1
d281 5
a285 2
		if (rt_g.NMG_debug & DEBUG_RT_SEGS)
			rt_log("ray missed NMG\n");
d289 1
a289 1
		rt_log("\nnmg_ray_segs(rd)\nsorted nmg/ray hit list\n");
d294 2
@


1.10
log
@checkpoint
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_segs.c,v 1.9 1994/06/22 17:20:52 butler Exp butler $ (BRL)";
d21 2
d1120 3
d1198 11
d1452 2
@


1.9
log
@checkpoint
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_segs.c,v 1.8 94/06/15 23:42:37 butler Exp Locker: butler $ (BRL)";
d64 1
d199 1
a199 1
	    	NMG_GET_FU_PLANE( plane, tmp.eu->up.lu_p->up.fu_p );
d202 1
a202 1
		    	rt_log("\n");
d205 5
a209 5
	    	
	    	if (tmp.eu->up.lu_p->up.fu_p->orientation == OT_SAME)
	    		teu = tmp.eu;
	    	else
	    		teu = tmp.eu->eumate_p;
d211 2
a212 2
	    	VSUB2(eu_vect, teu->vu_p->v_p->vg_p->coord,
	    		teu->eumate_p->vu_p->v_p->vg_p->coord);
d214 1
a214 1
	    	if (VDOT(e_p->eg_p->e_dir, eu_vect) < 0) {
d216 1
a216 1
	    	} else {
d218 1
a218 1
	    	}
d221 1
a221 1
	    	if (rt_g.NMG_debug & DEBUG_RT_SEGS) {
d223 1
a223 1
	    	}
d234 2
a235 2
	    	if (rt_g.NMG_debug & DEBUG_RT_SEGS)
		    	rt_structprint("tmp", ef_parsetab, (char *)&tmp);
d349 1
a349 1
			    		entries++;
d389 1
a389 1
	    	register int found=0;
d391 2
a392 2
	    	/* find a surface normal */
	    	for (RT_LIST_FOR(vu_p, vertexuse, &v_p->vu_hd)) {
d394 6
a399 6
	    		if (NMG_MANIFOLDS(tbl, vu_p) & NMG_2MANIFOLD &&
	    		    !(NMG_MANIFOLDS(tbl, vu_p) & NMG_3MANIFOLD) ) {
	    		    	found = 1; break;
	    		}
	    	}
	    	
d403 5
a407 5
	    	if (found) {
		    	/* we've found a 2manifold vertexuse.
		    	 * get a pointer to the faceuse and get the
		    	 * normal from the face
		    	 */
d409 10
a418 10
		    	if (*vu_p->up.magic_p == NMG_EDGEUSE_MAGIC)
		    		fu_p = vu_p->up.eu_p->up.lu_p->up.fu_p;
		    	else if (*vu_p->up.magic_p == NMG_LOOPUSE_MAGIC)
		    		fu_p = vu_p->up.lu_p->up.fu_p;
	    		else  {
	    			fu_p = (struct faceuse *)NULL;
	    			rt_bomb("vertex_hit: bad vu->up\n");
	    			/* NOTREACHED */
	    		}
	    		NMG_GET_FU_NORMAL( normal, fu_p );
d420 1
a420 1
		    	if (VDOT(normal, rp->r_dir) > 0.0) {
d423 1
a423 1
		    	} else {
d426 1
a426 1
		    	}
d429 2
a430 2
	    		/* we didn't find a face.  How did this happen? */
	    		rt_log("2manifold lone vertex?\n");
d435 1
a435 1
	    	}
d445 1
a445 1
	    	/* go looking for a wire edge */
d456 2
a457 2
			    			seg_p, rp, a_hit);
			    			
d461 3
a463 3
	    	if (filled == 0) {
	    		/* we didn't find an edge.  How did this happen? */
	    		rt_log("1manifold lone vertex?\n");
d470 1
a470 1
	    	}
d522 1
a522 1
	    			
d727 1
a727 1
	    	rt_log("edge_hit()\n");
d794 2
a795 2
	    	rt_log("\nedge_hit 3MANIFOLD\n");
	    	edge_confusion(a_hit, i_u, (char *)NULL, 0);
d800 1
a800 1
	    	/* we're looking for an exit (then entry) point */
d802 6
a807 6
	    	if (i_u[LEFT_MIN_EXIT].eu) {
	    		if (i_u[RIGHT_MIN_EXIT].eu) {
	    			if (i_u[LEFT_MAX_ENTER].eu !=
	    			    i_u[LEFT_MIN_ENTER].eu &&
	    			    i_u[RIGHT_MAX_ENTER].eu !=
	    			    i_u[RIGHT_MIN_ENTER].eu ){
d809 1
a809 1
	    			    	/* leave & re-enter solid */
d818 7
a824 7
	    			} else {
	    				/* leave solid */
	    				edge_leave_solid(a_hit, seg_p, i_u);
	    				filled++;
	    			}
	    		} else if (i_u[LEFT_MAX_ENTER].eu){
	    			/* graze exterior of solid on left */
d831 2
a832 2
	    		} else {
	    			/* What's going on? */
d834 1
a834 1
	    			edge_confusion(a_hit, i_u, __FILE__, __LINE__);
d839 2
a840 2
	    		}
	    	} else if (i_u[RIGHT_MIN_EXIT].eu &&
d843 1
a843 1
	    		/* grazing exterior of solid on right */
d848 2
a849 2
	    	} else {
	    		/* What's going on? */
d855 1
a855 1
	    	}
d858 2
a859 2
	    	/* we're looking for an entry (then exit) point on the 
	    	 * solid at this point.
d878 2
a879 2
	    		i_u[LEFT_MAX_EXIT].eu !=
	    		i_u[LEFT_MAX_ENTER].eu) {
d893 1
a893 1
	    		/* How did I get here? */
d907 1
a907 1
		    	 *	o______
d910 1
a910 1
    		    	 */
d925 1
a925 1
	    	/* hit a 2-manifold in space ( dangling face ) */
d930 1
a930 1
	    	eu_p = e_p->eu_p;
d932 1
a932 1
	    	/* go looking for a use of this edge in a 2-Manifold */
d934 1
a934 1
	    	while ( ! (NMG_MANIFOLDS(tbl, eu_p) & NMG_2MANIFOLD) &&
d938 3
a940 3
	    	if (NMG_MANIFOLDS(tbl, eu_p) & NMG_2MANIFOLD ) {
	    		vect_t	normal;
	    		NMG_GET_FU_NORMAL( normal, eu_p->up.lu_p->up.fu_p );
d942 4
a945 4
		    	if (VDOT(normal, rp->r_dir) > 0.0) {
		    		VMOVE(seg_p->seg_out.hit_normal, normal);
		    		VREVERSE(seg_p->seg_in.hit_normal, normal);
		    	} else {
d947 4
a950 4
		    		VREVERSE(seg_p->seg_out.hit_normal, normal);
		    	}
	    	}
	    	
d1009 1
a1009 1
		}
d1038 15
d1054 51
d1106 91
d1206 2
a1207 1
	struct hitmiss *a_hit;
d1210 2
d1213 1
d1219 3
a1222 3
	    RT_GET_SEG(seg_p, ap->a_resource);
	    RT_CK_SEG(seg_p);
	    seg_p->seg_stp = stp;
d1224 4
a1227 1
	    hits_filled = 0;
d1229 13
a1241 8
	    while (hits_filled < 2 ) {
	    	if (RT_LIST_IS_EMPTY(&rd->rd_hit) && hits_filled > 0) {
	    		rt_log("empty list?\n");
	    		print_seg_list(seghead);
	    		rt_bomb("Infinite NMG?");
	    	}
		a_hit = RT_LIST_FIRST(hitmiss, &rd->rd_hit);
		NMG_CK_HITMISS(a_hit);
d1243 1
a1243 2
		if (rt_g.NMG_debug & DEBUG_RT_SEGS)
			nmg_rt_print_hitmiss(a_hit);
d1245 14
d1260 86
a1345 18
		switch (*(int *)a_hit->hit.hit_private) {
		case NMG_VERTEX_MAGIC:
			hits_filled = vertex_hit(
			(struct vertex *)a_hit->hit.hit_private,
			seg_p, rd->rp, tbl, a_hit, hits_filled);
			break;
		case NMG_EDGE_MAGIC:
			hits_filled = edge_hit(
			(struct edge *)a_hit->hit.hit_private,
			seg_p, rd->rp, tbl, a_hit, hits_filled);
			break;
		case NMG_FACE_MAGIC:
			hits_filled = face_hit(
			(struct face *)a_hit->hit.hit_private,
			seg_p, rd->rp, tbl, a_hit, hits_filled);
			break;
		default: rt_log("bogus topology hit?\n"); abort();
			break;
a1346 1
	    }
d1348 1
d1350 61
d1413 1
a1413 1
	    	rt_log("adding segment %d to seg list\n", seg_count);
d1418 1
d1445 2
a1446 35
		for (RT_LIST_FOR(a_hit, hitmiss, &rd->rd_hit)) {
			rt_log("ray_hit_distance %g (%g %g %g)",
				a_hit->hit.hit_dist,
				a_hit->hit.hit_point[0],
				a_hit->hit.hit_point[1],
				a_hit->hit.hit_point[2]);

			if (a_hit->in_out & HMG_HIT_IN_IN)
				rt_log(" HMG_HIT_IN_IN  ");
			if (a_hit->in_out & HMG_HIT_IN_OUT)
				rt_log(" HMG_HIT_IN_OUT ");
			if (a_hit->in_out & HMG_HIT_OUT_IN)
				rt_log(" HMG_HIT_OUT_IN ");
			if (a_hit->in_out & HMG_HIT_IN_IN)
				rt_log(" HMG_HIT_IN_IN  ");
			if (a_hit->in_out & HMG_HIT_IN_ON)
				rt_log(" HMG_HIT_IN_ON  ");
			if (a_hit->in_out & HMG_HIT_ON_IN)
				rt_log(" HMG_HIT_ON_IN  ");
			if (a_hit->in_out & HMG_HIT_OUT_ON)
				rt_log(" HMG_HIT_OUT_ON ");
			if (a_hit->in_out & HMG_HIT_ON_OUT)
				rt_log(" HMG_HIT_ON_OUT ");
			if ( (a_hit->in_out & 0xFF) == 0 )
				rt_log(" -No hit sense- ");

			switch ( *(int*)a_hit->hit.hit_private) {
			case NMG_FACE_MAGIC: rt_log("\tface\n"); break;
			case NMG_EDGE_MAGIC: rt_log("\tedge\n"); break;
			case NMG_VERTEX_MAGIC: rt_log("\tvertex\n"); break;
			default : rt_log(" hit unknown magic (%d)\n", 
				*(int*)a_hit->hit.hit_private); break;
			}

		}
d1449 1
a1450 2
	seg_count = nmg_build_segs(rd, rd->ap, rd->seghead, rd->stp);
	
@


1.8
log
@checkpoint
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_segs.c,v 1.7 1993/12/03 03:35:49 mike Exp butler $ (BRL)";
d1073 2
a1074 6
		if (rt_g.NMG_debug & DEBUG_RT_SEGS) {
			rt_log("build_seg w/ ray_hit_distance %g (%g %g %g)",
				a_hit->hit.hit_dist,
				a_hit->hit.hit_point[0],
				a_hit->hit.hit_point[1],
				a_hit->hit.hit_point[2]);
a1075 8
			switch ( *(int*)a_hit->hit.hit_private) {
			case NMG_FACE_MAGIC: rt_log("\tface\n"); break;
			case NMG_EDGE_MAGIC: rt_log("\tedge\n"); break;
			case NMG_VERTEX_MAGIC: rt_log("\tvertex\n"); break;
			default : rt_log(" hit unknown magic (%d)\n", 
				*(int*)a_hit->hit.hit_private); break;
			}
		}
a1076 1

d1130 1
a1130 1
		rt_log("\nsorted nmg/ray hit list\n");
@


1.7
log
@Access to plane equation / surface normal in face_geometry structure
is now done through macros NMG_GET_FU_PLANE() NMG_GET_FU_NORMAL(),
which honor the f->flip flag.
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_segs.c,v 1.6 93/10/20 01:03:23 butler Exp Locker: mike $ (BRL)";
d1071 1
d1088 1
@


1.6
log
@checkpoing
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_segs.c,v 1.5 1993/09/02 16:17:19 butler Exp butler $ (BRL)";
d187 1
d198 2
d202 1
a202 1
			HPRINT("face_normal", fg_p->N);
d214 1
a214 1
			VCROSS(face_vect, edge_opp_vect, fg_p->N);
d216 1
a216 1
			VCROSS(face_vect, edge_vect, fg_p->N);
d226 1
a226 1
		tmp.ndotr = VDOT(fg_p->N,   rp->r_dir);
d320 1
d335 1
d343 1
d347 1
a347 1
				if ((RdotN = VDOT(rp->r_dir, fg->N)) < 0) {
d351 1
a351 1
						VMOVE(saved_normal, fg->N);
d357 1
a357 1
						VMOVE(saved_normal, fg->N);
d417 1
d419 3
a421 5
		    	if (VDOT(fu_p->f_p->fg_p->N, rp->r_dir) > 0.0) {
				VREVERSE(seg_p->seg_in.hit_normal,
					fu_p->f_p->fg_p->N);
				VMOVE(seg_p->seg_out.hit_normal,
					fu_p->f_p->fg_p->N);
d423 2
a424 4
				VMOVE(seg_p->seg_in.hit_normal,
					fu_p->f_p->fg_p->N);
				VREVERSE(seg_p->seg_out.hit_normal,
					fu_p->f_p->fg_p->N);
a512 1

d519 2
a520 2
	VMOVE(seg_p->seg_in.hit_normal,
		i_u[in].eu->up.lu_p->up.fu_p->f_p->fg_p->N);
d522 2
a523 2
	VMOVE(seg_p->seg_out.hit_normal,
		i_u[out].eu->up.lu_p->up.fu_p->f_p->fg_p->N);
d573 2
a574 2
		VMOVE(seg_p->seg_in.hit_normal,
		    i_u[LEFT_MIN_ENTER].eu->up.lu_p->up.fu_p->f_p->fg_p->N);
d576 2
a577 2
		VMOVE(seg_p->seg_in.hit_normal,
		    i_u[RIGHT_MIN_ENTER].eu->up.lu_p->up.fu_p->f_p->fg_p->N);
d615 2
a616 2
		VMOVE(seg_p->seg_in.hit_normal,
		    i_u[LEFT_MIN_ENTER].eu->up.lu_p->up.fu_p->f_p->fg_p->N);
d618 2
a619 2
		VMOVE(seg_p->seg_in.hit_normal,
		    i_u[RIGHT_MIN_ENTER].eu->up.lu_p->up.fu_p->f_p->fg_p->N);
d624 2
a625 2
		VMOVE(seg_p->seg_out.hit_normal,
		    i_u[LEFT_MIN_EXIT].eu->up.lu_p->up.fu_p->f_p->fg_p->N);
d627 2
a628 2
		VMOVE(seg_p->seg_out.hit_normal,
		    i_u[RIGHT_MIN_EXIT].eu->up.lu_p->up.fu_p->f_p->fg_p->N);
d663 2
a664 2
		VMOVE(seg_p->seg_out.hit_normal,
			i_u[LEFT_MIN_EXIT].eu->up.lu_p->up.fu_p->f_p->fg_p->N);
d667 2
a668 2
		VMOVE(seg_p->seg_out.hit_normal,
			i_u[RIGHT_MIN_EXIT].eu->up.lu_p->up.fu_p->f_p->fg_p->N);
d938 2
a939 2
	    		fastf_t *normal =
	    			&eu_p->up.lu_p->up.fu_p->f_p->fg_p->N[0];
d982 1
d986 6
d996 1
a996 1
			VMOVE(seg_p->seg_in.hit_normal, f_p->fg_p->N);
d1001 1
a1001 1
			VMOVE(seg_p->seg_out.hit_normal, f_p->fg_p->N);
d1015 1
a1015 1
		if (VDOT(f_p->fg_p->N, rp->r_dir) <= 0.0) {
d1017 2
a1018 2
			VMOVE(seg_p->seg_in.hit_normal, f_p->fg_p->N);
			VMOVE(seg_p->seg_out.hit_normal, f_p->fg_p->N);
d1020 2
a1021 2
			VREVERSE(seg_p->seg_in.hit_normal, f_p->fg_p->N);
			VREVERSE(seg_p->seg_out.hit_normal, f_p->fg_p->N);
@


1.5
log
@checkpoint
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_segs.c,v 1.4 1993/09/01 20:22:30 butler Exp butler $ (BRL)";
d157 1
a157 1
	if (rt_g.NMG_debug & DEBUG_NMGRT)
d164 2
a165 1
	VPRINT("ray_vect", rp->r_dir);
d169 2
a170 1
	VPRINT("edge_vect", edge_vect);
d177 2
a178 1
	VPRINT("left_vect", left_vect);
d197 1
a197 1
		if (rt_g.NMG_debug & DEBUG_NMGRT) {
d217 1
a217 1
	    	if (rt_g.NMG_debug & DEBUG_NMGRT) {
d230 1
a230 1
	    	if (rt_g.NMG_debug & DEBUG_NMGRT)
d511 1
a511 1
	if (rt_g.NMG_debug & DEBUG_NMGRT)
d538 1
a538 1
	if (rt_g.NMG_debug & DEBUG_NMGRT)
d552 1
a552 1
		if (rt_g.NMG_debug & DEBUG_NMGRT) {
d596 1
a596 1
	if (rt_g.NMG_debug & DEBUG_NMGRT)
d644 1
a644 1
	if (rt_g.NMG_debug & DEBUG_NMGRT)
d723 1
a723 1
	if (rt_g.NMG_debug & DEBUG_NMGRT)
d790 1
a790 1
	    if (rt_g.NMG_debug & DEBUG_NMGRT) {
d808 1
a808 1
					if (rt_g.NMG_debug & DEBUG_NMGRT)
d826 1
a826 1
				if (rt_g.NMG_debug & DEBUG_NMGRT)
d841 1
a841 1
			if (rt_g.NMG_debug & DEBUG_NMGRT)
d869 4
a872 2
				rt_log("added %d to segment: ", filled);
				rt_pr_seg(seg_p);
d996 1
a996 1
		if (rt_g.NMG_debug & DEBUG_NMGRT) {
d1016 1
a1016 1
		if (rt_g.NMG_debug & DEBUG_NMGRT) {
d1063 1
a1063 1
		if (rt_g.NMG_debug & DEBUG_NMGRT) {
d1102 1
a1102 1
	    if (rt_g.NMG_debug & DEBUG_NMGRT) {
d1127 1
a1127 1
		if (rt_g.NMG_debug & DEBUG_NMGRT)
d1130 1
a1130 1
	} else /* if (rt_g.NMG_debug & DEBUG_NMGRT) */{
d1141 19
d1167 1
d1174 1
a1174 1
	if (!(rt_g.NMG_debug & DEBUG_NMGRT))
@


1.4
log
@checkpoint
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_segs.c,v 1.3 1993/09/01 01:26:54 butler Exp butler $ (BRL)";
d1025 2
a1026 2
build_segs(hl, ap, nmg_spec, seghead, rp, stp)
struct hitmiss		*hl;
a1027 1
struct nmg_specific	*nmg_spec;
a1028 1
register struct xray	*rp;	/* info about the ray */
d1038 1
a1038 1
	tbl = nmg_spec->nmg_model->manifolds;
d1043 1
a1043 1
	while (RT_LIST_NON_EMPTY(&hl->l) ) {
d1051 1
a1051 1
	    	if (RT_LIST_IS_EMPTY(&hl->l) && hits_filled > 0) {
d1056 1
a1056 1
		a_hit = RT_LIST_FIRST(hitmiss, &hl->l);
d1078 1
a1078 1
			seg_p, rp, tbl, a_hit, hits_filled);
d1083 1
a1083 1
			seg_p, rp, tbl, a_hit, hits_filled);
d1088 1
a1088 1
			seg_p, rp, tbl, a_hit, hits_filled);
d1109 1
a1109 1
/*	N M G _ R A Y _ I S E C T _ S E G S
d1115 2
a1116 6
nmg_ray_isect_segs(stp, rp, ap, seghead, nmg_spec)
struct soltab		*stp;
register struct xray	*rp;	/* info about the ray */
struct application	*ap;	
struct seg		*seghead;	/* intersection w/ ray */
struct nmg_specific	*nmg_spec;
d1118 1
a1118 4

	struct hitmiss *hl, *a_hit;
	struct seg *seg_p;
	struct ray_data rd;
d1121 1
a1121 28
	rt_g.NMG_debug = rt_g.NMG_debug | DEBUG_NMGRT;
	rt_log("============================ New Ray ===================================\n");
	rt_log("Screen pos(%d %d)\n", ap->a_x, ap->a_y);

	rd.rp = rp;
	rd.tol = &ap->a_rt_i->rti_tol;
	VMOVE(rd.invdir, nmg_spec->nmg_invdir);

	/* create a table to keep track of which elements have been
	 * processed before and which haven't.  Elements in this table
	 * will either be:
	 *		(NULL)		item not previously processed
	 *		hitmiss ptr	item previously processed
	 *
	 */
	rd.hitmiss = (struct hitmiss **)rt_calloc( m->maxindex, sizeof(struct hitmiss *),
		"nmg geom hit list");

	/* initialize the lists of things that have been hit/missed */
	RT_LIST_INIT(&rd.nmg_hits);
	RT_LIST_INIT(&rd.nmg_misses);

	/* Shoot the ray */
	nmg_isect_ray_model(rd, nmg_spec->nmg_model);

	rt_g.NMG_debug = rt_g.NMG_debug & ~DEBUG_NMGRT;

	if (RT_LIST_IS_EMPTY(&rd.nmg_hits)) {
d1128 2
a1129 1
		for (RT_LIST_FOR(a_hit, hitmiss, &rd.nmg_hits) {
d1146 2
a1147 2
#if 0
	seg_count = build_segs(&, ap, nmg_spec, seghead, rp, stp);
d1153 1
a1153 1
	print_seg_list(seghead);
a1155 3
#else
	return(0);
#endif
@


1.3
log
@checkpoint
@
text
@d2 1
a2 1
 *			N M G _ R T . C
d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_segs.c,v 1.2 1993/07/23 15:56:10 butler Exp butler $ (BRL)";
d1127 1
d1134 18
d1153 1
a1153 2
	hl = nmg_isect_ray_model(rp, nmg_spec->nmg_invdir,
		nmg_spec->nmg_model, &ap->a_rt_i->rti_tol);
d1157 1
a1157 1
	if (! hl || RT_LIST_IS_EMPTY(&hl->l)) {
d1164 1
a1164 1
		for (RT_LIST_FOR(a_hit, hitmiss, &hl->l)) {
d1181 2
a1182 1
	seg_count = build_segs(hl, ap, nmg_spec, seghead, rp, stp);
d1191 3
@


1.2
log
@About to make radical change?
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt_segs.c,v 1.1 1993/06/04 17:08:11 butler Exp butler $ (BRL)";
d1129 1
a1129 1
/*	rt_g.NMG_debug = rt_g.NMG_debug | DEBUG_NMGRT;
d1137 1
@


1.1
log
@Initial revision
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_rt.c,v 10.9 1993/05/20 21:07:13 butler Exp butler $ (BRL)";
d24 1
d26 1
a26 2
#include "nmg.h"
#include "nmg_rt.h"
d58 28
d95 1
a95 1
struct hitlist	*a_hit;
d194 4
a197 2
	    	rt_log("\n");
		HPRINT("face_normal", fg_p->N);
d214 3
a216 2
		VPRINT("face_vect", face_vect);

d227 2
a228 2
	    	rt_structprint("tmp", ef_parsetab, (char *)&tmp);
	    	
d301 1
a301 1
struct hitlist	*a_hit;
d502 1
a502 1
struct hitlist	*a_hit;
d531 1
a531 1
struct hitlist	*a_hit;
d589 1
a589 1
struct hitlist	*a_hit;
d637 1
a637 1
struct hitlist	*a_hit;
d673 1
a673 1
struct hitlist	*a_hit;
d713 1
a713 1
struct hitlist	*a_hit;
d970 1
a970 1
struct hitlist	*a_hit;
d1026 1
a1026 1
struct hitlist		*hl;
d1036 1
a1036 1
	struct hitlist *a_hit;
a1046 1

a1047 1

d1053 3
a1055 1
	    	if (RT_LIST_IS_EMPTY(&hl->l) && hits_filled > 0)
d1057 2
a1058 2
	    	
		a_hit = RT_LIST_FIRST(hitlist, &hl->l);
d1125 1
a1125 1
	struct hitlist *hl, *a_hit;
d1129 4
d1134 4
a1137 3
	hl = nmg_isect_ray(rp, nmg_spec->nmg_invdir, nmg_spec->nmg_model,
		&ap->a_rt_i->rti_tol);
		
d1142 1
a1142 1
	}
a1143 1
	if (rt_g.NMG_debug & DEBUG_NMGRT) {
d1145 1
a1145 1
		for (RT_LIST_FOR(a_hit, hitlist, &hl->l)) {
d1168 1
a1168 19
	rt_log("segment list (%d)\n", seg_count);
	for (RT_LIST_FOR(seg_p, seg, &seghead->l) ) {
		rt_log("dist %g  pt(%g,%g,%g)  N(%g,%g,%g)  =>  ",
		seg_p->seg_in.hit_dist,
		seg_p->seg_in.hit_point[0],
		seg_p->seg_in.hit_point[1],
		seg_p->seg_in.hit_point[2],
		seg_p->seg_in.hit_normal[0],
		seg_p->seg_in.hit_normal[1],
		seg_p->seg_in.hit_normal[2]);
		rt_log("dist %g  pt(%g,%g,%g)  N(%g,%g,%g)\n",
		seg_p->seg_out.hit_dist,
		seg_p->seg_out.hit_point[0],
		seg_p->seg_out.hit_point[1],
		seg_p->seg_out.hit_point[2],
		seg_p->seg_out.hit_normal[0],
		seg_p->seg_out.hit_normal[1],
		seg_p->seg_out.hit_normal[2]);
	}
a1169 2
	rt_log("returning\n");

d1171 1
a1172 1
}
@
