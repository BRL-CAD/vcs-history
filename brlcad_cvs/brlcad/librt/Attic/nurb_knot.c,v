head	11.13;
access;
symbols
	ansi-20040405-merged:11.9.2.2
	postmerge-20040405-ansi:11.11
	premerge-20040404-ansi:11.10
	postmerge-autoconf:11.10
	autoconf-freeze:11.9.10.1
	premerge-autoconf:11.10
	ansi-20040316-freeze:11.9.2.1
	postmerge-20040315-windows:11.10
	premerge-20040315-windows:11.10
	windows-20040315-freeze:11.9.4.1
	autoconf-20031203:11.9
	autoconf-20031202:11.9
	autoconf-branch:11.9.0.10
	phong-branch:11.9.0.8
	photonmap-branch:11.9.0.6
	rel-6-1-DP:11.9
	windows-branch:11.9.0.4
	rel-6-0-2:11.7
	ansi-branch:11.9.0.2
	rel-6-0-1-branch:11.7.0.2
	hartley-6-0-post:11.8
	hartley-6-0-pre:11.7
	rel-6-0-1:11.7
	rel-6-0:11.7
	rel-5-4:11.5.2.1
	offsite-5-3-pre:11.6
	rel-5-3:11.5.2.1
	rel-5-2:11.5
	rel-5-1-branch:11.5.0.2
	rel-5-1:11.5
	rel-5-0:11.5
	rel-5-0-beta:11.4
	rel-4-5:11.4
	ctj-4-5-post:11.2
	ctj-4-5-pre:11.2
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.13
date	2004.05.21.18.07.34;	author morrison;	state dead;
branches;
next	11.12;

11.12
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.11;

11.11
date	2004.04.05.08.48.58;	author morrison;	state Exp;
branches;
next	11.10;

11.10
date	2004.02.02.17.39.28;	author morrison;	state Exp;
branches;
next	11.9;

11.9
date	2002.08.20.17.08.07;	author jra;	state Exp;
branches
	11.9.2.1
	11.9.4.1
	11.9.10.1;
next	11.8;

11.8
date	2002.08.15.20.55.19;	author hartley;	state Exp;
branches;
next	11.7;

11.7
date	2001.04.20.22.29.54;	author morrison;	state Exp;
branches;
next	11.6;

11.6
date	2000.11.14.21.13.21;	author jra;	state Exp;
branches;
next	11.5;

11.5
date	99.06.03.01.39.15;	author mike;	state Exp;
branches
	11.5.2.1;
next	11.4;

11.4
date	97.10.06.21.35.36;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	97.09.18.20.32.45;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	96.12.31.01.09.27;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.53.48;	author mike;	state Rel4_4;
branches
	11.1.1.1;
next	10.6;

10.6
date	94.11.04.05.35.33;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	94.08.11.01.13.07;	author gdurf;	state Exp;
branches;
next	10.4;

10.4
date	92.06.03.01.29.53;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	92.06.02.22.48.50;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	92.05.29.00.52.23;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.39.08;	author mike;	state Rel4_0;
branches;
next	1.4;

1.4
date	91.09.20.23.36.41;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	91.06.23.03.42.20;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	91.06.14.09.42.15;	author stay;	state Exp;
branches;
next	1.1;

1.1
date	91.05.18.02.35.31;	author stay;	state Exp;
branches;
next	;

11.1.1.1
date	98.01.29.06.43.38;	author mike;	state Rel4_5;
branches;
next	;

11.5.2.1
date	2000.11.14.21.35.30;	author jra;	state Exp;
branches;
next	;

11.9.2.1
date	2002.09.19.18.01.44;	author morrison;	state Exp;
branches;
next	11.9.2.2;

11.9.2.2
date	2004.03.17.21.18.56;	author morrison;	state Exp;
branches;
next	;

11.9.4.1
date	2004.03.11.23.43.44;	author morrison;	state Exp;
branches;
next	;

11.9.10.1
date	2004.02.12.18.37.46;	author erikg;	state Exp;
branches;
next	;


desc
@Knot insertion
@


11.13
log
@moved to src/
@
text
@/* 
 *       N U R B _ K N O T . C
 *
 * Function -
 *     Various knot vector routines.
 * 
 * Author -
 *     Paul R. Stay
 *
 * Source -
 *     SECAD/VLD Computing Consortium, Bldg 394
 *     The U.S. Army Ballistic Research Laboratory
 *     Aberdeen Proving Ground, Maryland 21005
 *
 * Copyright Notice -
 *     This software is Copyright (C) 1990-2004 by the United States Army.
 *     All rights reserved.
 */

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "nurb.h"

/* rt_nurb_kvknot()
 * Generate a open knot vector with n=order knots at the beginning of
 * the sequence and n knots at the end of the sequence with a lower,
 * and an upper value and num knots in between
 */

void
rt_nurb_kvknot(register struct knot_vector *new_knots, int order, fastf_t lower, fastf_t upper, int num, struct resource *res)
{
	register int	i;
	int	total;
	fastf_t knot_step;

	total = order * 2 + num;

	knot_step = (upper - lower) / ( num + 1 );

	new_knots->k_size = total;

	new_knots->knots = (fastf_t * ) bu_malloc ( sizeof( fastf_t) * total,
		    "rt_nurb_kvknot: new knots values");

	for ( i = 0; i < order; i++)
		new_knots->knots[i] = lower;

	for ( i = order; i <= (num + order - 1); i++)
		new_knots->knots[i] = new_knots->knots[i-1] + knot_step;

	for ( i = ( num + order ) ; i < total; i++)
		new_knots->knots[i] = upper;
}


/* rt_nurb_kvmult()
 *	Construct a new knot vector which is the same as the passed in
 * knot vector except it has multiplicity of num of val. It checks to see if 
 * val already is a multiple knot. 
 */
void
rt_nurb_kvmult(struct knot_vector *new_kv, const struct knot_vector *kv, int num, register fastf_t val, struct resource *res)
{
	int	n;
	register int	i;
	struct knot_vector check;

	n = rt_nurb_kvcheck( val, kv );

	check.k_size = num - n;
	if( check.k_size <= 0 )  {
		bu_log("rt_nurb_kvmult(new_kv=x%x, kv=x%x, num=%d, val=%g)\n",
			new_kv, kv, num, val);
		rt_nurb_pr_kv(kv);
		rt_bomb("rt_nurb_kvmult\n");
	}

	check.knots = (fastf_t * ) bu_malloc( sizeof(fastf_t) * check.k_size,
		    "rt_nurb_kvmult: check knots");

	for ( i = 0; i < num - n; i++)
		check.knots[i] = val;

	rt_nurb_kvmerge( new_kv, &check, kv, res);

	/* free up old knot values */
	bu_free((char *)check.knots, "rt_nurb_kvmult:check knots");
}


/* rt_nurb_kvgen( )
 * 	Generate a knot vector with num knots from lower value to 
 * 	the upper  value.
 */

void
rt_nurb_kvgen(register struct knot_vector *kv, fastf_t lower, fastf_t upper, int num, struct resource *res)
{
	register int	i;
	register fastf_t inc;

	inc = (upper - lower) / ( num + 1 );

	kv->k_size = num;

	kv->knots = (fastf_t * ) bu_malloc ( sizeof( fastf_t) * num, 
		    "rt_nurb_kvgen: kv knots");

	for ( i = 1; i <= num; i++)
		kv->knots[i-1] = lower + i * inc;
}


/* rt_nurb_kvmerge()
 *	Merge two knot vectors together and return the new resulting 
 *	knot vector.
 */

void
rt_nurb_kvmerge(struct knot_vector *new_knots, const struct knot_vector *kv1, const struct knot_vector *kv2, struct resource *res)
{
	int	kv1_ptr = 0;
	int	kv2_ptr = 0;
	int	new_ptr;

	new_knots->k_size = kv1->k_size + kv2->k_size;

	new_knots->knots = (fastf_t * ) bu_malloc( 
		    sizeof (fastf_t) * new_knots->k_size,
		    "rt_nurb_kvmerge: new knot values");

	for ( new_ptr = 0; new_ptr < new_knots->k_size; new_ptr++) {
		if ( kv1_ptr >= kv1->k_size )
			new_knots->knots[new_ptr] = kv2->knots[kv2_ptr++];
		else if ( kv2_ptr >= kv2->k_size )
			new_knots->knots[new_ptr] = kv1->knots[kv1_ptr++];
		else if ( kv1->knots[kv1_ptr] < kv2->knots[kv2_ptr])
			new_knots->knots[new_ptr] = kv1->knots[kv1_ptr++];
		else
			new_knots->knots[new_ptr] = kv2->knots[kv2_ptr++];
	}
}


/* rt_nurb_kvcheck()
 *	Checks to see if the knot (val) exists in the Knot Vector and
 *	returns its multiplicity.
 */

int
rt_nurb_kvcheck(fastf_t val, register const struct knot_vector *kv)
{
	register int	kv_num = 0;
	register int	i;

	for ( i = 0; i < kv->k_size; i++) {
		if ( val == kv->knots[i] )
			kv_num++;
	}

	return kv_num;
}


/* rt_nurb_kvextract()
 *	Extract the portion of the knot vector from kv->knots[lower] to
 *	kv->knots[upper]
 */

void
rt_nurb_kvextract(struct knot_vector *new_kv, register const struct knot_vector *kv, int lower, int upper, struct resource *res)
{
	register int	i;
	register fastf_t *ptr;

	new_kv->knots = (fastf_t * ) bu_malloc ( 
		    sizeof (fastf_t) * (upper - lower),
		    "spl_kvextract: nkw kv values" );

	new_kv->k_size = upper - lower;
	ptr = new_kv->knots;

	for ( i = lower; i < upper; i++)
		*ptr++ = kv->knots[i];
}


/* rt_nurb_kvcopy()
 *	Generic copy the knot vector and pass a new one in.
 */

void
rt_nurb_kvcopy(struct knot_vector *new_kv, register const struct knot_vector *old_kv, struct resource *res)
{
	register int	i;

	new_kv->k_size = old_kv->k_size;

	new_kv->knots = (fastf_t * ) bu_malloc( sizeof( fastf_t) * 
		    new_kv->k_size, "spl_kvcopy: new knot values");

	for ( i = 0; i < new_kv->k_size; i++)
		new_kv->knots[i] = old_kv->knots[i];
}


/* rt_nurb_kvnorm()
 *	Normalize the knot vector so its values are from zero to one.
 */

/* XXX Need to check to see if the lower value is zero */
void
rt_nurb_kvnorm(register struct knot_vector *kv)
{
	register fastf_t upper;
	register int	i;

	upper = kv->knots[kv->k_size - 1];
	if( NEAR_ZERO( upper, SMALL ) )
		upper = 0;
	else
		upper = 1 / upper;

	for ( i = 0; i < kv->k_size; i++)
		kv->knots[i] *= upper;
}


/* knot_index()
 *	Calculates and returns the index of the value for the knot vector
 *
 * XXX It is hard to know what tolerance to use here for the comparisons.
 */

int
rt_nurb_knot_index(const struct knot_vector *kv, fastf_t k_value, int order)
{
	int	i;
	fastf_t  knt;
	int	k_index;

	if ( k_value < ( knt = *(kv->knots + order - 1))) {
		if (fabs( k_value - knt) < 0.0001) {
			k_value = knt;
		} else
			return - 1;
	}

	if ( k_value > ( knt = *(kv->knots + kv->k_size - order + 1)) ) {
		if (fabs( k_value - knt) < 0.0001) {
			k_value = knt;
		} else
			return - 1;
	}

	if ( k_value == kv->knots[ kv->k_size - order + 1] )
		k_index = kv->k_size - order - 1;
	else if ( k_value == kv->knots[ order - 1] )
		k_index = order - 1;
	else
	 {
		k_index = 0;
		for ( i = 0; i < kv->k_size - 1; i++)
			if ( kv->knots[i] < k_value && k_value <= kv->knots[i+1] )
				k_index = i;

	}

	return k_index;
}


/* rt_nurb_gen_knot_vector()
 * Generate a open knot vector with n=order knots at the beginning of
 * the sequence and n knots at the end of the sequence.
 */

void
rt_nurb_gen_knot_vector(register struct knot_vector *new_knots, int order, fastf_t lower, fastf_t upper, struct resource *res)
{
    register int i;
    int total;

    total = order * 2;

    new_knots->k_size = total;

    new_knots->knots = (fastf_t *) bu_malloc ( sizeof( fastf_t) * total,
		"rt_nurb_gen_knot_vector: new knots values");

    for ( i = 0; i < order; i++)
        new_knots->knots[i] = lower;

    for ( i = order; i < total; i++)
        new_knots->knots[i] = upper;
}
@


11.12
log
@change conf.h to a wrapped config.h
@
text
@@


11.11
log
@merge of ansi-6-0-branch into HEAD
@
text
@d20 5
a24 1
#include "conf.h"
@


11.10
log
@update copyright to include span through 2003
@
text
@d36 1
a36 7
rt_nurb_kvknot( new_knots, order, lower, upper, num, res)
register struct knot_vector *new_knots;
int	order;
fastf_t lower;
fastf_t upper;
int	num;
struct resource *res;
d68 1
a68 6
rt_nurb_kvmult( new_kv, kv, num, val, res)
struct knot_vector	*new_kv;
const struct knot_vector *kv;
int			num;
register fastf_t	val;
struct resource *res;
d103 1
a103 5
rt_nurb_kvgen( kv, lower, upper, num, res)
register struct knot_vector *kv;
int	num;
fastf_t lower, upper;
struct resource *res;
d126 1
a126 5
rt_nurb_kvmerge( new_knots, kv1, kv2, res )
struct knot_vector *new_knots;
const struct knot_vector *kv1;
const struct knot_vector *kv2;
struct resource *res;
d157 1
a157 3
rt_nurb_kvcheck( val, kv)
fastf_t val;
register const struct knot_vector *kv;
d177 1
a177 5
rt_nurb_kvextract( new_kv, kv, lower, upper, res)
struct knot_vector	*new_kv;
register const struct knot_vector *kv;
int	upper, lower;
struct resource *res;
d199 1
a199 4
rt_nurb_kvcopy( new_kv, old_kv, res )
struct knot_vector	*new_kv;
register const struct knot_vector *old_kv;
struct resource *res;
d219 1
a219 2
rt_nurb_kvnorm( kv )
register struct knot_vector *kv;
d242 1
a242 4
rt_nurb_knot_index( kv, k_value, order)
const struct knot_vector *kv;
fastf_t k_value;
int	order;
d285 1
a285 6
rt_nurb_gen_knot_vector( new_knots, order, lower, upper, res)
register struct knot_vector *new_knots;
int		order;
fastf_t		lower;
fastf_t		upper;
struct resource *res;
@


11.9
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d16 1
a16 1
 *     This software is Copyright (C) 1990 by the United States Army.
@


11.9.4.1
log
@sync to HEAD...
@
text
@d16 1
a16 1
 *     This software is Copyright (C) 1990-2004 by the United States Army.
@


11.9.10.1
log
@merge from HEAD
@
text
@d16 1
a16 1
 *     This software is Copyright (C) 1990-2004 by the United States Army.
@


11.9.2.1
log
@Initial ANSIfication
@
text
@d36 7
a42 1
rt_nurb_kvknot(register struct knot_vector *new_knots, int order, fastf_t lower, fastf_t upper, int num, struct resource *res)
d74 6
a79 1
rt_nurb_kvmult(struct knot_vector *new_kv, const struct knot_vector *kv, int num, register fastf_t val, struct resource *res)
d114 5
a118 1
rt_nurb_kvgen(register struct knot_vector *kv, fastf_t lower, fastf_t upper, int num, struct resource *res)
d141 5
a145 1
rt_nurb_kvmerge(struct knot_vector *new_knots, const struct knot_vector *kv1, const struct knot_vector *kv2, struct resource *res)
d176 3
a178 1
rt_nurb_kvcheck(fastf_t val, register const struct knot_vector *kv)
d198 5
a202 1
rt_nurb_kvextract(struct knot_vector *new_kv, register const struct knot_vector *kv, int lower, int upper, struct resource *res)
d224 4
a227 1
rt_nurb_kvcopy(struct knot_vector *new_kv, register const struct knot_vector *old_kv, struct resource *res)
d247 2
a248 1
rt_nurb_kvnorm(register struct knot_vector *kv)
d271 4
a274 1
rt_nurb_knot_index(const struct knot_vector *kv, fastf_t k_value, int order)
d317 6
a322 1
rt_nurb_gen_knot_vector(register struct knot_vector *new_knots, int order, fastf_t lower, fastf_t upper, struct resource *res)
@


11.9.2.2
log
@sync branch with HEAD
@
text
@d16 1
a16 1
 *     This software is Copyright (C) 1990-2004 by the United States Army.
@


11.8
log
@Converted from K&R to ANSI C - RFH
@
text
@d36 7
a42 1
rt_nurb_kvknot(register struct knot_vector *new_knots, int order, fastf_t lower, fastf_t upper, int num, struct resource *res)
d74 6
a79 1
rt_nurb_kvmult(struct knot_vector *new_kv, const struct knot_vector *kv, int num, register fastf_t val, struct resource *res)
d114 5
a118 1
rt_nurb_kvgen(register struct knot_vector *kv, fastf_t lower, fastf_t upper, int num, struct resource *res)
d141 5
a145 1
rt_nurb_kvmerge(struct knot_vector *new_knots, const struct knot_vector *kv1, const struct knot_vector *kv2, struct resource *res)
d176 3
a178 1
rt_nurb_kvcheck(fastf_t val, register const struct knot_vector *kv)
d198 5
a202 1
rt_nurb_kvextract(struct knot_vector *new_kv, register const struct knot_vector *kv, int lower, int upper, struct resource *res)
d224 4
a227 1
rt_nurb_kvcopy(struct knot_vector *new_kv, register const struct knot_vector *old_kv, struct resource *res)
d247 2
a248 1
rt_nurb_kvnorm(register struct knot_vector *kv)
d271 4
a274 1
rt_nurb_knot_index(const struct knot_vector *kv, fastf_t k_value, int order)
d317 6
a322 1
rt_nurb_gen_knot_vector(register struct knot_vector *new_knots, int order, fastf_t lower, fastf_t upper, struct resource *res)
@


11.7
log
@CONST to const
@
text
@d36 1
a36 7
rt_nurb_kvknot( new_knots, order, lower, upper, num, res)
register struct knot_vector *new_knots;
int	order;
fastf_t lower;
fastf_t upper;
int	num;
struct resource *res;
d68 1
a68 6
rt_nurb_kvmult( new_kv, kv, num, val, res)
struct knot_vector	*new_kv;
const struct knot_vector *kv;
int			num;
register fastf_t	val;
struct resource *res;
d103 1
a103 5
rt_nurb_kvgen( kv, lower, upper, num, res)
register struct knot_vector *kv;
int	num;
fastf_t lower, upper;
struct resource *res;
d126 1
a126 5
rt_nurb_kvmerge( new_knots, kv1, kv2, res )
struct knot_vector *new_knots;
const struct knot_vector *kv1;
const struct knot_vector *kv2;
struct resource *res;
d157 1
a157 3
rt_nurb_kvcheck( val, kv)
fastf_t val;
register const struct knot_vector *kv;
d177 1
a177 5
rt_nurb_kvextract( new_kv, kv, lower, upper, res)
struct knot_vector	*new_kv;
register const struct knot_vector *kv;
int	upper, lower;
struct resource *res;
d199 1
a199 4
rt_nurb_kvcopy( new_kv, old_kv, res )
struct knot_vector	*new_kv;
register const struct knot_vector *old_kv;
struct resource *res;
d219 1
a219 2
rt_nurb_kvnorm( kv )
register struct knot_vector *kv;
d242 1
a242 4
rt_nurb_knot_index( kv, k_value, order)
const struct knot_vector *kv;
fastf_t k_value;
int	order;
d285 1
a285 6
rt_nurb_gen_knot_vector( new_knots, order, lower, upper, res)
register struct knot_vector *new_knots;
int		order;
fastf_t		lower;
fastf_t		upper;
struct resource *res;
@


11.6
log
@Eliminated pmalloc (a failed experiment)
@
text
@d76 1
a76 1
CONST struct knot_vector *kv;
d143 2
a144 2
CONST struct knot_vector *kv1;
CONST struct knot_vector *kv2;
d178 1
a178 1
register CONST struct knot_vector *kv;
d200 1
a200 1
register CONST struct knot_vector *kv;
d226 1
a226 1
register CONST struct knot_vector *old_kv;
d272 1
a272 1
CONST struct knot_vector *kv;
@


11.5
log
@
sed4
@
text
@d54 1
a54 5
	if( res )
		new_knots->knots = (fastf_t * ) rt_pmalloc ( sizeof( fastf_t) * total,
		    &res->re_pmem);
	else
		new_knots->knots = (fastf_t * ) bu_malloc ( sizeof( fastf_t) * total,
d95 1
a95 5
	if( res )
		check.knots = (fastf_t * ) rt_pmalloc( sizeof(fastf_t) * check.k_size,
		    &res->re_pmem);
	else
		check.knots = (fastf_t * ) bu_malloc( sizeof(fastf_t) * check.k_size,
d104 1
a104 4
	if( res )
		rt_pfree((char *)check.knots, &res->re_pmem);
	else
		bu_free((char *)check.knots, "rt_nurb_kvmult:check knots");
d127 1
a127 5
	if( res )
		kv->knots = (fastf_t * ) rt_pmalloc ( sizeof( fastf_t) * num, 
		    &res->re_pmem);
	else
		kv->knots = (fastf_t * ) bu_malloc ( sizeof( fastf_t) * num, 
d153 1
a153 6
	if( res )
		new_knots->knots = (fastf_t * ) rt_pmalloc( 
		    sizeof (fastf_t) * new_knots->k_size,
		    &res->re_pmem);
	else
		new_knots->knots = (fastf_t * ) bu_malloc( 
d207 1
a207 6
	if( res )
		new_kv->knots = (fastf_t * ) rt_pmalloc ( 
		    sizeof (fastf_t) * (upper - lower),
		    &res->re_pmem );
	else
		new_kv->knots = (fastf_t * ) bu_malloc ( 
d233 1
a233 5
	if( res )
		new_kv->knots = (fastf_t * ) rt_pmalloc( sizeof( fastf_t) * 
		    new_kv->k_size, &res->re_pmem);
	else
		new_kv->knots = (fastf_t * ) bu_malloc( sizeof( fastf_t) * 
d331 1
a331 5
    if( res )
	    new_knots->knots = (fastf_t *) rt_pmalloc ( sizeof( fastf_t) * total,
		&res->re_pmem);
    else
	    new_knots->knots = (fastf_t *) bu_malloc ( sizeof( fastf_t) * total,
@


11.5.2.1
log
@Eliminated pmalloc (a failed experiment)
@
text
@d54 5
a58 1
	new_knots->knots = (fastf_t * ) bu_malloc ( sizeof( fastf_t) * total,
d99 5
a103 1
	check.knots = (fastf_t * ) bu_malloc( sizeof(fastf_t) * check.k_size,
d112 4
a115 1
	bu_free((char *)check.knots, "rt_nurb_kvmult:check knots");
d138 5
a142 1
	kv->knots = (fastf_t * ) bu_malloc ( sizeof( fastf_t) * num, 
d168 6
a173 1
	new_knots->knots = (fastf_t * ) bu_malloc( 
d227 6
a232 1
	new_kv->knots = (fastf_t * ) bu_malloc ( 
d258 5
a262 1
	new_kv->knots = (fastf_t * ) bu_malloc( sizeof( fastf_t) * 
d360 5
a364 1
    new_knots->knots = (fastf_t *) bu_malloc ( sizeof( fastf_t) * total,
@


11.4
log
@rt_pmalloc
@
text
@d58 1
a58 1
		new_knots->knots = (fastf_t * ) rt_malloc ( sizeof( fastf_t) * total,
d103 1
a103 1
		check.knots = (fastf_t * ) rt_malloc( sizeof(fastf_t) * check.k_size,
d115 1
a115 1
		rt_free((char *)check.knots, "rt_nurb_kvmult:check knots");
d142 1
a142 1
		kv->knots = (fastf_t * ) rt_malloc ( sizeof( fastf_t) * num, 
d173 1
a173 1
		new_knots->knots = (fastf_t * ) rt_malloc( 
d232 1
a232 1
		new_kv->knots = (fastf_t * ) rt_malloc ( 
d262 1
a262 1
		new_kv->knots = (fastf_t * ) rt_malloc( sizeof( fastf_t) * 
d364 1
a364 1
	    new_knots->knots = (fastf_t *) rt_malloc ( sizeof( fastf_t) * total,
@


11.3
log
@Mods for use of pmalloc in TNURB raytracing.
@
text
@d55 1
a55 1
		new_knots->knots = (fastf_t * ) pmalloc ( sizeof( fastf_t) * total,
d100 1
a100 1
		check.knots = (fastf_t * ) pmalloc( sizeof(fastf_t) * check.k_size,
d113 1
a113 1
		pfree((char *)check.knots, &res->re_pmem);
d139 1
a139 1
		kv->knots = (fastf_t * ) pmalloc ( sizeof( fastf_t) * num, 
d169 1
a169 1
		new_knots->knots = (fastf_t * ) pmalloc( 
d228 1
a228 1
		new_kv->knots = (fastf_t * ) pmalloc ( 
d259 1
a259 1
		new_kv->knots = (fastf_t * ) pmalloc( sizeof( fastf_t) * 
d361 1
a361 1
	    new_knots->knots = (fastf_t *) pmalloc ( sizeof( fastf_t) * total,
@


11.2
log
@libbu
@
text
@d36 1
a36 1
rt_nurb_kvknot( new_knots, order, lower, upper, num)
d42 1
d54 6
a59 2
	new_knots->knots = (fastf_t * ) rt_malloc ( sizeof( fastf_t) * total,
	    "rt_nurb_kvknot: new knots values");
d78 1
a78 1
rt_nurb_kvmult( new_kv, kv, num, val)
d83 1
d98 7
a104 2
	check.knots = (fastf_t * ) rt_malloc( sizeof(fastf_t) * check.k_size,
	    "rt_nurb_kvmult: check knots");
d109 1
a109 1
	rt_nurb_kvmerge( new_kv, &check, kv);
d112 4
a115 1
	rt_free((char *)check.knots, "rt_nurb_kvmult:check knots");
d125 1
a125 1
rt_nurb_kvgen( kv, lower, upper, num)
d129 1
d137 7
a143 2
	kv->knots = (fastf_t * ) rt_malloc ( sizeof( fastf_t) * num, 
	    "rt_nurb_kvgen: kv knots");
d156 1
a156 1
rt_nurb_kvmerge( new_knots, kv1, kv2 )
d160 1
d168 8
a175 3
	new_knots->knots = (fastf_t * ) rt_malloc( 
	    sizeof (fastf_t) * new_knots->k_size,
	    "rt_nurb_kvmerge: new knot values");
d218 1
a218 1
rt_nurb_kvextract( new_kv, kv, lower, upper)
d222 1
d227 9
a235 3
	new_kv->knots = (fastf_t * ) rt_malloc ( 
	    sizeof (fastf_t) * (upper - lower),
	    "spl_kvextract: nkw kv values" );
d249 1
a249 1
rt_nurb_kvcopy( new_kv, old_kv )
d252 1
d257 7
a263 2
	new_kv->knots = (fastf_t * ) rt_malloc( sizeof( fastf_t) * 
	    new_kv->k_size, "spl_kvcopy: new knot values");
d346 1
a346 1
rt_nurb_gen_knot_vector( new_knots, order, lower, upper)
d351 1
d360 5
a364 1
    new_knots->knots = (fastf_t *) rt_malloc ( sizeof( fastf_t) * total,
@


11.1
log
@Release_4.4
@
text
@d87 1
a87 1
		rt_log("rt_nurb_kvmult(new_kv=x%x, kv=x%x, num=%d, val=%g)\n",
@


11.1.1.1
log
@Release_4.5
@
text
@d36 1
a36 1
rt_nurb_kvknot( new_knots, order, lower, upper, num, res)
a41 1
struct resource *res;
d53 2
a54 6
	if( res )
		new_knots->knots = (fastf_t * ) rt_pmalloc ( sizeof( fastf_t) * total,
		    &res->re_pmem);
	else
		new_knots->knots = (fastf_t * ) rt_malloc ( sizeof( fastf_t) * total,
		    "rt_nurb_kvknot: new knots values");
d73 1
a73 1
rt_nurb_kvmult( new_kv, kv, num, val, res)
a77 1
struct resource *res;
d87 1
a87 1
		bu_log("rt_nurb_kvmult(new_kv=x%x, kv=x%x, num=%d, val=%g)\n",
d92 2
a93 7

	if( res )
		check.knots = (fastf_t * ) rt_pmalloc( sizeof(fastf_t) * check.k_size,
		    &res->re_pmem);
	else
		check.knots = (fastf_t * ) rt_malloc( sizeof(fastf_t) * check.k_size,
		    "rt_nurb_kvmult: check knots");
d98 1
a98 1
	rt_nurb_kvmerge( new_kv, &check, kv, res);
d101 1
a101 4
	if( res )
		rt_pfree((char *)check.knots, &res->re_pmem);
	else
		rt_free((char *)check.knots, "rt_nurb_kvmult:check knots");
d111 1
a111 1
rt_nurb_kvgen( kv, lower, upper, num, res)
a114 1
struct resource *res;
d122 2
a123 7

	if( res )
		kv->knots = (fastf_t * ) rt_pmalloc ( sizeof( fastf_t) * num, 
		    &res->re_pmem);
	else
		kv->knots = (fastf_t * ) rt_malloc ( sizeof( fastf_t) * num, 
		    "rt_nurb_kvgen: kv knots");
d136 1
a136 1
rt_nurb_kvmerge( new_knots, kv1, kv2, res )
a139 1
struct resource *res;
d147 3
a149 8
	if( res )
		new_knots->knots = (fastf_t * ) rt_pmalloc( 
		    sizeof (fastf_t) * new_knots->k_size,
		    &res->re_pmem);
	else
		new_knots->knots = (fastf_t * ) rt_malloc( 
		    sizeof (fastf_t) * new_knots->k_size,
		    "rt_nurb_kvmerge: new knot values");
d192 1
a192 1
rt_nurb_kvextract( new_kv, kv, lower, upper, res)
a195 1
struct resource *res;
d200 3
a202 9
	if( res )
		new_kv->knots = (fastf_t * ) rt_pmalloc ( 
		    sizeof (fastf_t) * (upper - lower),
		    &res->re_pmem );
	else
		new_kv->knots = (fastf_t * ) rt_malloc ( 
		    sizeof (fastf_t) * (upper - lower),
		    "spl_kvextract: nkw kv values" );

d216 1
a216 1
rt_nurb_kvcopy( new_kv, old_kv, res )
a218 1
struct resource *res;
d223 2
a224 7

	if( res )
		new_kv->knots = (fastf_t * ) rt_pmalloc( sizeof( fastf_t) * 
		    new_kv->k_size, &res->re_pmem);
	else
		new_kv->knots = (fastf_t * ) rt_malloc( sizeof( fastf_t) * 
		    new_kv->k_size, "spl_kvcopy: new knot values");
d307 1
a307 1
rt_nurb_gen_knot_vector( new_knots, order, lower, upper, res)
a311 1
struct resource *res;
d320 1
a320 5
    if( res )
	    new_knots->knots = (fastf_t *) rt_pmalloc ( sizeof( fastf_t) * total,
		&res->re_pmem);
    else
	    new_knots->knots = (fastf_t *) rt_malloc ( sizeof( fastf_t) * total,
@


10.6
log
@Irix 6
@
text
@@


10.5
log
@Added includes
@
text
@a314 1
    fastf_t knot_step;
@


10.4
log
@Made epsilon values explicit.
@
text
@d20 2
d26 1
@


10.3
log
@Added error checking for kvmult producing knot vector of length 0
@
text
@d253 2
d268 1
a268 1
		if (APX_EQ( k_value, knt)) {
d275 1
a275 1
		if (APX_EQ( k_value, knt)) {
@


10.2
log
@Modifications due to data structure revisions:  mesh and knots are no
longer pointers, but in-place structures.
@
text
@d83 7
a89 1
	check.knots = (fastf_t * ) rt_malloc( sizeof(fastf_t) * (num - n),
@


10.1
log
@Release_4.0
@
text
@d32 3
a34 2
struct knot_vector *
rt_nurb_kvknot( order, lower, upper, num)
a42 1
	register struct knot_vector *new_knots;
a47 2
	new_knots = (struct knot_vector *) rt_malloc ( sizeof( struct knot_vector ), 
	    "rt_nurb__kvknot: new knot struct");
a60 2

	return new_knots;
d69 6
a74 6

struct knot_vector *
rt_nurb_kvmult( kv, num, val)
struct knot_vector *kv;
int	num;
register fastf_t val;
d78 1
a78 2
	register struct knot_vector *check;
	struct knot_vector *new_kv;
d82 2
a83 4
	check = (struct knot_vector *) rt_malloc ( sizeof ( struct knot_vector ),
	    "rt_nurb_kvmult: check" );
	check->k_size = num - n;
	check->knots = (fastf_t * ) rt_malloc( sizeof(fastf_t) * (num - n),
d87 1
a87 1
		check->knots[i] = val;
d89 1
a89 1
	new_kv = (struct knot_vector *) rt_nurb_kvmerge( check, kv);
d92 1
a92 6
	rt_free((char *)check->knots, "rt_nurb_kvmult:check knots");

	/* free up the old */
	rt_free((char *)check, "rt_nurb_kvmult: check");

	return new_kv;
d101 3
a103 3

struct knot_vector *
rt_nurb_kvgen( lower, upper, num)
a108 1
	register struct knot_vector *kv;
a111 3
	kv = (struct knot_vector *) rt_malloc ( sizeof (struct knot_vector ), 
	    "rt_nurb_kvgen: kv struct");

a117 3

	return kv;

d126 5
a130 3
struct knot_vector *
rt_nurb_kvmerge( kv1, kv2 )
struct knot_vector *kv1, *kv2;
d132 3
a134 2
	struct knot_vector * new_knots;
	int	kv1_ptr = 0, kv2_ptr = 0, new_ptr;
a135 4
	new_knots = (struct knot_vector *) rt_malloc ( 
	    sizeof (struct knot_vector ),
	    "rt_nurb_kvmerge: new knots struct");

a151 3

	return new_knots;

d163 1
a163 1
register struct knot_vector *kv;
d182 4
a185 3
struct knot_vector *
rt_nurb_kvextract( kv, lower, upper)
register struct knot_vector *kv;
a187 1
	struct knot_vector *new_kv;
a190 2
	new_kv = (struct knot_vector *) rt_malloc ( sizeof ( struct knot_vector ),
	    "spl_kvextract: new kv struct" );
a198 3

	return new_kv;

d206 4
a209 3
struct knot_vector *
rt_nurb_kvcopy( old_kv )
register struct knot_vector *old_kv;
a211 1
	struct knot_vector *new_kv;
a212 2
	new_kv = (struct knot_vector *) rt_malloc( sizeof ( struct knot_vector ),
	    "spl_kvcopy: new knot struct" );
a218 2

	return new_kv;
d226 1
a226 1
/* Need to check to see if the lower value is zero */
a233 1

d235 4
d241 1
a241 1
		kv->knots[i] /= upper;
d251 1
a251 1
struct knot_vector *kv;
d295 6
a300 4
struct knot_vector *
rt_nurb_gen_knot_vector( order, lower, upper)
int order;
fastf_t lower, upper;
a304 1
    register struct knot_vector * new_knots;
a307 3
    new_knots = (struct knot_vector *) rt_malloc ( sizeof( struct knot_vector ), 
		"rt_nurb_gen_knot_vector: new knot struct");

a317 2

    return new_knots;
@


1.4
log
@Added math.h
@
text
@@


1.3
log
@minor lint
@
text
@d21 1
@


1.2
log
@fixed nurb.h
@
text
@d33 4
a36 2
int	order, num;
fastf_t lower, upper;
@


1.1
log
@Initial revision
@
text
@d23 1
a23 1
#include "./nurb.h"
@
