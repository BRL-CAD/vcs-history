head	1.62;
access;
symbols
	ansi-20040405-merged:1.54.2.2
	postmerge-20040405-ansi:1.60
	premerge-20040404-ansi:1.59
	postmerge-autoconf:1.59
	autoconf-freeze:1.57.4.2
	premerge-autoconf:1.59
	ansi-20040316-freeze:1.54.2.1
	postmerge-20040315-windows:1.59
	premerge-20040315-windows:1.59
	windows-20040315-freeze:1.54.4.1
	autoconf-20031203:1.57
	autoconf-20031202:1.57
	autoconf-branch:1.57.0.4
	phong-branch:1.57.0.2
	photonmap-branch:1.55.0.2
	rel-6-1-DP:1.55
	windows-branch:1.54.0.4
	rel-6-0-2:1.52
	ansi-branch:1.54.0.2
	rel-6-0-1-branch:1.52.0.2
	hartley-6-0-post:1.53
	hartley-6-0-pre:1.52
	rel-6-0-1:1.52
	rel-6-0:1.52
	rel-5-4:1.23.2.2
	offsite-5-3-pre:1.36
	rel-5-3:1.23.2.2
	rel-5-2:1.23
	rel-5-1-branch:1.23.0.2
	rel-5-1:1.23
	rel-5-0:1.7
	rel-5-0-beta:1.5;
locks; strict;
comment	@ * @;


1.62
date	2004.05.21.18.07.30;	author morrison;	state dead;
branches;
next	1.61;

1.61
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	1.60;

1.60
date	2004.04.05.08.48.56;	author morrison;	state Exp;
branches;
next	1.59;

1.59
date	2004.02.03.21.45.26;	author jra;	state Exp;
branches;
next	1.58;

1.58
date	2004.02.02.17.39.20;	author morrison;	state Exp;
branches;
next	1.57;

1.57
date	2003.09.10.13.11.39;	author jra;	state Exp;
branches
	1.57.4.1;
next	1.56;

1.56
date	2003.09.10.00.31.41;	author jra;	state Exp;
branches;
next	1.55;

1.55
date	2002.09.26.20.42.46;	author jra;	state Exp;
branches;
next	1.54;

1.54
date	2002.08.20.17.07.59;	author jra;	state Exp;
branches
	1.54.2.1
	1.54.4.1;
next	1.53;

1.53
date	2002.08.15.20.55.12;	author hartley;	state Exp;
branches;
next	1.52;

1.52
date	2001.10.23.13.53.47;	author jra;	state Exp;
branches;
next	1.51;

1.51
date	2001.10.19.03.44.51;	author jra;	state Exp;
branches;
next	1.50;

1.50
date	2001.10.02.19.24.29;	author jra;	state Exp;
branches;
next	1.49;

1.49
date	2001.09.27.00.33.56;	author jra;	state Exp;
branches;
next	1.48;

1.48
date	2001.09.26.20.49.45;	author jra;	state Exp;
branches;
next	1.47;

1.47
date	2001.08.22.15.09.38;	author jra;	state Exp;
branches;
next	1.46;

1.46
date	2001.08.10.19.51.09;	author rbowers;	state Exp;
branches;
next	1.45;

1.45
date	2001.06.26.18.17.31;	author jra;	state Exp;
branches;
next	1.44;

1.44
date	2001.06.26.18.01.06;	author jra;	state Exp;
branches;
next	1.43;

1.43
date	2001.06.21.18.07.25;	author jra;	state Exp;
branches;
next	1.42;

1.42
date	2001.04.27.12.48.09;	author jra;	state Exp;
branches;
next	1.41;

1.41
date	2001.04.27.12.45.39;	author jra;	state Exp;
branches;
next	1.40;

1.40
date	2001.04.25.12.45.57;	author jra;	state Exp;
branches;
next	1.39;

1.39
date	2001.04.20.22.29.44;	author morrison;	state Exp;
branches;
next	1.38;

1.38
date	2001.04.13.15.13.29;	author jra;	state Exp;
branches;
next	1.37;

1.37
date	2001.03.19.22.19.58;	author butler;	state Exp;
branches;
next	1.36;

1.36
date	2001.02.05.16.25.29;	author jra;	state Exp;
branches;
next	1.35;

1.35
date	2000.12.05.15.12.27;	author jra;	state Exp;
branches;
next	1.34;

1.34
date	2000.11.16.21.27.38;	author jra;	state Exp;
branches;
next	1.33;

1.33
date	2000.09.08.05.54.41;	author mike;	state Exp;
branches;
next	1.32;

1.32
date	2000.09.01.02.20.38;	author mike;	state Exp;
branches;
next	1.31;

1.31
date	2000.08.21.02.02.30;	author butler;	state Exp;
branches;
next	1.30;

1.30
date	2000.07.21.19.42.30;	author jra;	state Exp;
branches;
next	1.29;

1.29
date	2000.07.10.23.01.31;	author mike;	state Exp;
branches;
next	1.28;

1.28
date	2000.06.30.15.57.51;	author mike;	state Exp;
branches;
next	1.27;

1.27
date	2000.06.30.15.38.03;	author mike;	state Exp;
branches;
next	1.26;

1.26
date	2000.06.30.15.31.14;	author mike;	state Exp;
branches;
next	1.25;

1.25
date	2000.06.29.20.21.00;	author jra;	state Exp;
branches;
next	1.24;

1.24
date	2000.06.29.15.53.25;	author mike;	state Exp;
branches;
next	1.23;

1.23
date	2000.05.11.21.22.35;	author mike;	state Exp;
branches
	1.23.2.1;
next	1.22;

1.22
date	2000.03.28.21.59.05;	author mike;	state Exp;
branches;
next	1.21;

1.21
date	2000.03.16.13.39.27;	author jra;	state Exp;
branches;
next	1.20;

1.20
date	2000.03.03.21.29.08;	author jra;	state Exp;
branches;
next	1.19;

1.19
date	2000.03.02.14.47.28;	author jra;	state Exp;
branches;
next	1.18;

1.18
date	2000.03.01.18.30.48;	author jra;	state Exp;
branches;
next	1.17;

1.17
date	2000.03.01.16.34.10;	author jra;	state Exp;
branches;
next	1.16;

1.16
date	2000.02.10.19.49.45;	author jra;	state Exp;
branches;
next	1.15;

1.15
date	2000.02.01.20.11.34;	author jra;	state Exp;
branches;
next	1.14;

1.14
date	2000.02.01.20.03.25;	author jra;	state Exp;
branches;
next	1.13;

1.13
date	2000.01.31.13.40.50;	author jra;	state Exp;
branches;
next	1.12;

1.12
date	99.12.29.21.11.26;	author jra;	state Exp;
branches;
next	1.11;

1.11
date	99.11.26.22.02.53;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	99.11.26.21.46.46;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	99.11.24.14.39.52;	author jra;	state Exp;
branches;
next	1.8;

1.8
date	99.11.17.02.41.58;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	99.07.02.22.47.22;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	99.07.02.22.19.23;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	99.05.27.19.10.38;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	99.01.13.21.49.11;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	98.09.14.15.59.17;	author bparker;	state Exp;
branches;
next	1.2;

1.2
date	98.06.25.07.46.30;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	98.05.29.14.19.18;	author jra;	state Exp;
branches;
next	;

1.23.2.1
date	2000.11.16.21.22.35;	author jra;	state Exp;
branches;
next	1.23.2.2;

1.23.2.2
date	2000.11.18.05.17.23;	author jra;	state Exp;
branches;
next	;

1.54.2.1
date	2002.09.19.18.01.33;	author morrison;	state Exp;
branches;
next	1.54.2.2;

1.54.2.2
date	2004.03.17.21.18.46;	author morrison;	state Exp;
branches;
next	;

1.54.4.1
date	2004.03.11.23.43.37;	author morrison;	state Exp;
branches;
next	;

1.57.4.1
date	2004.02.12.18.37.40;	author erikg;	state Exp;
branches;
next	1.57.4.2;

1.57.4.2
date	2004.03.15.14.07.19;	author erikg;	state Exp;
branches;
next	;


desc
@First cut at extrusion solid
@


1.62
log
@moved to src/
@
text
@/*
 *			G _ E X T R U D E . C
 *
 *  Purpose -
 *	Provide support for solids of extrusion
 *
 * Adding a new solid type:
 *	Design disk record
 *
 *	define rt_extrude_internal --- parameters for solid
 *	define extrude_specific --- raytracing form, possibly w/precomuted terms
 *
 *	code import/export/describe/print/ifree/plot/prep/shot/curve/uv/tess
 *
 *	edit db.h add solidrec s_type define
 *	edit rtgeom.h to add rt_extrude_internal
 *	edit table.c:
 *		RT_DECLARE_INTERFACE()
 *		struct rt_functab entry
 *		rt_id_solid()
 *	edit raytrace.h to make ID_EXTRUDE, increment ID_MAXIMUM
 *	edit db_scan.c to add support for new solid type
 *	edit Cakefile to add g_extrude.c to compile
 *
 *	Then:
 *	go to /cad/libwdb and create mk_extrude() routine
 *	go to /cad/mged and create the edit support
 *
 *  Authors -
 *  	John R. Anderson
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1990-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSextrude[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/g_extrude.c,v 1.61 2004/05/10 15:30:46 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include "tcl.h"
#include "machine.h"
#include "vmath.h"
#include "db.h"
#include "nmg.h"
#include "rtgeom.h"
#include "raytrace.h"
#include "nurb.h"
#include "./debug.h"

extern int seg_to_vlist( struct bu_list *vhead, const struct rt_tess_tol *ttol, point_t	V,
			 vect_t	u_vec, vect_t v_vec, struct rt_sketch_internal *sketch_ip, genptr_t seg);

struct extrude_specific {
	mat_t rot, irot;	/* rotation and translation to get extrsuion vector in +z direction with V at origin */
	vect_t unit_h;		/* unit vector in direction of extrusion vector */
	vect_t u_vec;		/* u vector rotated and projected */
	vect_t v_vec;		/* v vector rotated and projected */
	fastf_t	uv_scale;	/* length of original, untransformed u_vec */
	vect_t rot_axis;	/* axis of rotation for rotation matrix */
	vect_t perp;		/* vector in pl1_rot plane and normal to rot_axis */
	plane_t pl1, pl2;	/* plane equations of the top and bottom planes (not rotated) */
	plane_t pl1_rot;	/* pl1 rotated by rot */
	point_t *verts;		/* sketch vertices projected onto a plane normal to extrusion vector */
	struct curve crv;	/* copy of the referenced curve */
};

static struct bn_tol extr_tol={			/* a fake tolerance structure for the intersection routines */
	BN_TOL_MAGIC,
	RT_LEN_TOL,
	RT_LEN_TOL*RT_LEN_TOL,
	0.0,
	1.0};

#define MAX_HITS 64

/* defines for surf_no in the hit struct (a negative surf_no indicates an exit point) */
#define TOP_FACE	1	/* extruded face */
#define BOTTOM_FACE	2	/* face in uv-plane */
#define LINE_SEG	3
#define CARC_SEG	4
#define NURB_SEG	5
#define BEZIER_SEG	6

/* defines for loop classification */
#define UNKNOWN		0
#define	A_IN_B		1
#define	B_IN_A		2
#define	DISJOINT	3

#define LOOPA		1
#define LOOPB		2

/*
 *  			R T _ E X T R U D E _ P R E P
 *  
 *  Given a pointer to a GED database record, and a transformation matrix,
 *  determine if this is a valid EXTRUDE, and if so, precompute various
 *  terms of the formula.
 *  
 *  Returns -
 *  	0	EXTRUDE is OK
 *  	!0	Error in description
 *  
 *  Implicit return -
 *  	A struct extrude_specific is created, and it's address is stored in
 *  	stp->st_specific for use by extrude_shot().
 */
int
rt_extrude_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
{
	struct rt_extrude_internal *eip;
	register struct extrude_specific *extr;
	struct rt_sketch_internal *skt;
	LOCAL vect_t tmp, xyz[3];
	fastf_t tmp_f, ldir[3];
	int i, j;
	int vert_count;
	int curr_vert;

	eip = (struct rt_extrude_internal *)ip->idb_ptr;
	RT_EXTRUDE_CK_MAGIC( eip );
	skt = eip->skt;
	RT_SKETCH_CK_MAGIC( skt );

	/* make sure the curve is valid */
	if( rt_check_curve( &skt->skt_curve, skt, 1 ) )
	{
		bu_log( "ERROR: referenced sketch (%s) is bad!!!\n",
			eip->sketch_name );
		return( -1 );
	}

	BU_GETSTRUCT( extr, extrude_specific );
	stp->st_specific = (genptr_t)extr;

	VMOVE( extr->unit_h, eip->h );
	VUNITIZE(extr->unit_h );

	/* the length of the u_vec is used for scaling radii of circular arcs
	 * the u_vec and the v_vec must have the same length
	 */
	extr->uv_scale = MAGNITUDE( eip->u_vec );

	/* build a transformation matrix to rotate extrusion vector to z-axis */
	VSET( tmp, 0, 0, 1 )
	bn_mat_fromto( extr->rot, eip->h, tmp );

	/* and translate to origin */
	extr->rot[MDX] = -VDOT( eip->V, &extr->rot[0] );
	extr->rot[MDY] = -VDOT( eip->V, &extr->rot[4] );
	extr->rot[MDZ] = -VDOT( eip->V, &extr->rot[8] );

	/* and save the inverse */
	bn_mat_inv( extr->irot, extr->rot );

	/* calculate plane equations of top and bottom planes */
	VCROSS( extr->pl1, eip->u_vec, eip->v_vec );
	VUNITIZE( extr->pl1 )
	extr->pl1[3] = VDOT( extr->pl1, eip->V );
	VMOVE( extr->pl2, extr->pl1 );
	VADD2( tmp, eip->V, eip->h );
	extr->pl2[3] = VDOT( extr->pl2, tmp );

	vert_count = skt->vert_count;
	/* count how many additional vertices we will need for arc centers */
	for( i=0 ; i<skt->skt_curve.seg_count ; i++ )
	{
		struct carc_seg *csg=(struct carc_seg *)skt->skt_curve.segments[i];

		if( csg->magic != CURVE_CARC_MAGIC )
			continue;

		if( csg->radius <= 0.0 )
			continue;

		vert_count++;
	}

	/* apply the rotation matrix to all the vertices, and start bounding box calculation */
	if( vert_count )
		extr->verts = (point_t *)bu_calloc( vert_count, sizeof( point_t ), "extr->verts" );
	VSETALL( stp->st_min, MAX_FASTF );
	VSETALL( stp->st_max, -MAX_FASTF );
	for( i=0 ; i<skt->vert_count ; i++ )
	{
		VJOIN2( tmp, eip->V, skt->verts[i][0], eip->u_vec, skt->verts[i][1], eip->v_vec );
		VMINMAX( stp->st_min, stp->st_max, tmp );
		MAT4X3PNT( extr->verts[i], extr->rot, tmp );
		VADD2( tmp, tmp, eip->h );
		VMINMAX( stp->st_min, stp->st_max, tmp );
	}
	curr_vert = skt->vert_count;

	/* and the u,v vectors */
	MAT4X3VEC( extr->u_vec, extr->rot, eip->u_vec );
	MAT4X3VEC( extr->v_vec, extr->rot, eip->v_vec );

	/* calculate the rotated pl1 */
	VCROSS( extr->pl1_rot, extr->u_vec, extr->v_vec );
	VUNITIZE( extr->pl1_rot );
	extr->pl1_rot[3] = VDOT( extr->pl1_rot, extr->verts[0] );

	VSET( tmp, 0, 0, 1 )
	tmp_f = VDOT( tmp, extr->unit_h );
	if( tmp_f < 0.0 )
		tmp_f = -tmp_f;
	tmp_f -= 1.0;
	if( NEAR_ZERO( tmp_f, SQRT_SMALL_FASTF ) )
	{
		VSET( extr->rot_axis, 1.0, 0.0, 0.0 );
		VSET( extr->perp, 0.0, 1.0, 0.0 );
	}
	else
	{
		VCROSS( extr->rot_axis, tmp, extr->unit_h );
		VUNITIZE( extr->rot_axis );
		if( MAGNITUDE( extr->rot_axis ) < SQRT_SMALL_FASTF )
		{
			VSET( extr->rot_axis, 1.0, 0.0, 0.0 );
			VSET( extr->perp, 0.0, 1.0, 0.0 );
		}
		else
		{
			VCROSS( extr->perp, extr->rot_axis, extr->pl1_rot );
			VUNITIZE( extr->perp );
		}
	}

	/* copy the curve */
	rt_copy_curve( &extr->crv, &skt->skt_curve );

	VSET( xyz[X], 1, 0, 0 );
	VSET( xyz[Y], 0, 1, 0 );
	VSET( xyz[Z], 0, 0, 1 );

	for( i=X ; i<=Z ; i++ ) {
		VCROSS( tmp, extr->unit_h, xyz[i] );
		ldir[i] = MAGNITUDE( tmp );
	}

	/* if any part of the curve is a circular arc, the arc may extend beyond the listed vertices */
	for( i=0 ; i<skt->skt_curve.seg_count ; i++ )
	{
		struct carc_seg *csg=(struct carc_seg *)skt->skt_curve.segments[i];
		struct carc_seg *csg_extr=(struct carc_seg *)extr->crv.segments[i];
		point_t center;

		if( csg->magic != CURVE_CARC_MAGIC )
			continue;

		if( csg->radius <= 0.0 )	/* full circle */
		{
			point_t start;
			fastf_t radius;

			csg_extr->center = csg->end;
			VJOIN2( start, eip->V, skt->verts[csg->start][0], eip->u_vec, skt->verts[csg->start][1], eip->v_vec );
			VJOIN2( center, eip->V, skt->verts[csg->end][0], eip->u_vec, skt->verts[csg->end][1], eip->v_vec );
			VSUB2( tmp, start, center );
			radius = MAGNITUDE( tmp );
			csg_extr->radius = -radius;	/* need the correct magnitude for normal calculation */

			for( j=X ; j<=Z ; j++ ) {
				tmp_f = radius * ldir[j];
				VJOIN1( tmp, center, tmp_f, xyz[j] );
				VMINMAX( stp->st_min, stp->st_max, tmp );
				VADD2( tmp, tmp, eip->h );
				VMINMAX( stp->st_min, stp->st_max, tmp );

				VJOIN1( tmp, center, -tmp_f, xyz[j] );
				VMINMAX( stp->st_min, stp->st_max, tmp );
				VADD2( tmp, tmp, eip->h );
				VMINMAX( stp->st_min, stp->st_max, tmp );
			}
		}
		else	/* circular arc */
		{
			point_t start, end, mid;
			vect_t s_to_m;
			vect_t bisector;
			fastf_t dist;
			fastf_t magsq_s2m;

			VJOIN2( start, eip->V, skt->verts[csg->start][0], eip->u_vec, skt->verts[csg->start][1], eip->v_vec );
			VJOIN2( end, eip->V, skt->verts[csg->end][0], eip->u_vec, skt->verts[csg->end][1], eip->v_vec );
			VBLEND2( mid, 0.5, start, 0.5, end );
			VSUB2( s_to_m, mid, start );
			VCROSS( bisector, extr->pl1, s_to_m );
			VUNITIZE( bisector );
			magsq_s2m = MAGSQ( s_to_m );
			csg_extr->radius = csg->radius * extr->uv_scale;
			if( magsq_s2m > csg_extr->radius*csg_extr->radius )
			{
				fastf_t max_radius;

				max_radius = sqrt( magsq_s2m );
				if( NEAR_ZERO( max_radius - csg_extr->radius, RT_LEN_TOL ) )
					csg_extr->radius = max_radius;
				else
				{
					bu_log( "Impossible radius for circular arc in extrusion (%s), is %g, cannot be more than %g!!!\n", 
							stp->st_dp->d_namep, csg_extr->radius, sqrt(magsq_s2m)  );
					bu_log( "Difference is %g\n", max_radius - csg->radius );
					return( -1 );
				}
			}
			dist = sqrt( csg_extr->radius*csg_extr->radius - magsq_s2m );

			/* save arc center */
			if( csg->center_is_left )
				VJOIN1( center, mid, dist, bisector )
			else
				VJOIN1( center, mid, -dist, bisector )
			MAT4X3PNT( extr->verts[curr_vert], extr->rot, center );
			csg_extr->center = curr_vert;
			curr_vert++;

			for( j=X ; j<=Z ; j++ ) {
				tmp_f = csg_extr->radius * ldir[j];
				VJOIN1( tmp, center, tmp_f, xyz[j] );
				VMINMAX( stp->st_min, stp->st_max, tmp );
				VADD2( tmp, tmp, eip->h );
				VMINMAX( stp->st_min, stp->st_max, tmp );

				VJOIN1( tmp, center, -tmp_f, xyz[j] );
				VMINMAX( stp->st_min, stp->st_max, tmp );
				VADD2( tmp, tmp, eip->h );
				VMINMAX( stp->st_min, stp->st_max, tmp );
			}
		}
	}

	VBLEND2( stp->st_center, 0.5, stp->st_min, 0.5, stp->st_max );
	VSUB2( tmp, stp->st_max, stp->st_min );
	stp->st_aradius = 0.5 * MAGNITUDE( tmp );
	stp->st_bradius = stp->st_aradius;

	return(0);              /* OK */
}

/*
 *			R T _ E X T R U D E _ P R I N T
 */
void
rt_extrude_print(register const struct soltab *stp)
{
}

int
get_quadrant(fastf_t *v, fastf_t *local_x, fastf_t *local_y, fastf_t *vx, fastf_t *vy)
{

	*vx = V2DOT( v, local_x );
	*vy = V2DOT( v, local_y );

	if( *vy >= 0.0 )
	{
		if( *vx >= 0.0 )
			return( 1 );
		else
			return( 2 );
	}
	else
	{
		if( *vx >= 0.0 )
			return( 4 );
		else
			return( 3 );
	}
}

int
isect_line2_ellipse(fastf_t *dist, fastf_t *ray_start, fastf_t *ray_dir, fastf_t *center, fastf_t *ra, fastf_t *rb)
{
	fastf_t a, b, c;
	point2d_t pmc;
	fastf_t pmcda, pmcdb;
	fastf_t ra_sq, rb_sq;
	fastf_t ra_4, rb_4;
	fastf_t dda, ddb;
	fastf_t disc;

	V2SUB2( pmc, ray_start, center );
	pmcda = V2DOT( pmc, ra );
	pmcdb = V2DOT( pmc, rb );
	ra_sq = V2DOT( ra, ra );
	ra_4 = ra_sq * ra_sq;
	rb_sq = V2DOT( rb, rb );
	rb_4 = rb_sq * rb_sq;
	if( ra_4 < SMALL_FASTF || rb_4 < SMALL_FASTF )
	{
		bu_log( "ray (%g %g %g) -> (%g %g %g), semi-axes  = (%g %g %g) and (%g %g %g), center = (%g %g %g)\n",
			V3ARGS( ray_start ), V3ARGS( ray_dir ), V3ARGS( ra ), V3ARGS( rb ), V3ARGS( center ) );
		bu_bomb( "ERROR: isect_line2_ellipse: semi-axis length is too small!!!\n" );
	}

	dda = V2DOT( ray_dir, ra );
	ddb = V2DOT( ray_dir, rb );

	a = dda*dda/ra_4 + ddb*ddb/rb_4;
	b = 2.0 * (pmcda*dda/ra_4 + pmcdb*ddb/rb_4);
	c = pmcda*pmcda/ra_4 + pmcdb*pmcdb/rb_4 - 1.0;

	disc = b*b - 4.0*a*c;
	if( disc < 0.0 )
		return( 0 );

	if( disc <= SMALL_FASTF )
	{
		dist[0] = -b/(2.0*a);
		return( 1 );
	}

	dist[0] = (-b - sqrt( disc )) / (2.0*a);
	dist[1] = (-b + sqrt( disc )) / (2.0*a);
	return( 2 );
}


int
isect_line_earc(fastf_t *dist, fastf_t *ray_start, fastf_t *ray_dir, fastf_t *center, fastf_t *ra, fastf_t *rb, fastf_t *norm, fastf_t *start, fastf_t *end, int orientation)
                
                  
               
                           
                    
                	/* 0 -> ccw, !0 -> cw */
{
	int dist_count;
	vect_t local_x, local_y, local_z;
	fastf_t vx, vy;
	fastf_t ex, ey;
	fastf_t sx, sy;
	int quad_start, quad_end, quad_pt;
	point2d_t to_pt, pt;
	int i;

	dist_count = isect_line2_ellipse( dist, ray_start, ray_dir, center, ra, rb);

	if( dist_count == 0 )
		return( 0 );

	if( orientation )
		VREVERSE( local_z, norm )
	else
		VMOVE( local_z, norm )

	VMOVE( local_x, ra );

	VCROSS( local_y, local_z, local_x );

	V2SUB2( to_pt, end, center );
	quad_end = get_quadrant( to_pt, local_x, local_y, &ex, &ey );
	V2SUB2( to_pt, start, center );
	quad_start = get_quadrant( to_pt, local_x, local_y, &sx, &sy );

	i = 0;
	while( i < dist_count )
	{
		int omit;

		omit = 0;
		V2JOIN1( pt, ray_start, dist[i], ray_dir );
		V2SUB2( to_pt, pt, center );
		quad_pt = get_quadrant( to_pt, local_x, local_y, &vx, &vy );

		if( quad_start < quad_end )
		{
			if( quad_pt > quad_end )
				omit = 1;
			else if( quad_pt < quad_start )
				omit = 1;
			else if( quad_pt == quad_end )
			{
				switch( quad_pt )
				{
					case 1:
					case 2:
						if( vx < ex )
							omit = 1;
						break;
					case 3:
					case 4:
						if( vx > ex )
							omit = 1;
						break;
				}
			}
			else if( quad_pt == quad_start )
			{
				switch( quad_pt )
				{
					case 1:
					case 2:
						if( vx > sx )
							omit = 1;
						break;
					case 3:
					case 4:
						if( vx < sx )
							omit = 1;
						break;
				}
			}
		}
		else if( quad_start > quad_end )
		{
			if( quad_pt > quad_end && quad_pt < quad_start )
				omit = 1;
			else if( quad_pt == quad_end )
			{
				switch( quad_pt )
				{
					case 1:
					case 2:
						if( vx < ex )
							omit = 1;
						break;
					case 3:
					case 4:
						if( vx > ex )
							omit = 1;
						break;
				}
			}
			else if( quad_pt == quad_start )
			{
				switch( quad_pt )
				{
					case 1:
					case 2:
						if( vx > sx )
							omit = 1;
						break;
					case 3:
					case 4:
						if( vx < sx )
							omit = 1;
						break;
				}
			}
		}
		else		/* quad_start == quad_end */
		{
			if( quad_pt != quad_start )
				omit = 1;
			else
			{
				switch( quad_pt )
				{
					case 1:
					case 2:
						if( vx < ex || vx > sx )
							omit = 1;
						break;
					case 3:
					case 4:
						if( vx > ex || vx < sx )
							omit = 1;
						break;
				}
			}
		}
		if( omit )
		{
			if( i == 0 )
				dist[0] = dist[1];
			dist_count--;
		}
		else
			i++;
	}

	return( dist_count );
}



/*
 *  			R T _ E X T R U D E _ S H O T
 *  
 *  Intersect a ray with a extrude.
 *  If an intersection occurs, a struct seg will be acquired
 *  and filled in.
 *  
 *  Returns -
 *  	0	MISS
 *	>0	HIT
 */
int
rt_extrude_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
{
	struct extrude_specific *extr=(struct extrude_specific *)stp->st_specific;
	register int i, j, k;
	fastf_t dist_top, dist_bottom, to_bottom=0;
	fastf_t dist[2];
	fastf_t dot_pl1, dir_dot_z;
	point_t tmp, tmp2;
	point_t ray_start, ray_dir, ray_dir_unit;	/* 2D */
	struct curve *crv;
	struct hit hits[MAX_HITS];
	fastf_t dists_before[MAX_HITS];
	fastf_t dists_after[MAX_HITS];
	fastf_t *dists=NULL;
	int dist_count=0;
	int hit_count=0;
	int hits_before_bottom=0, hits_after_top=0;
	int code;
	int check_inout=0;
	int top_face=TOP_FACE, bot_face=BOTTOM_FACE;
	int surfno= -42;
	int free_dists=0;
	point2d_t *verts;
	point2d_t *intercept;
	point2d_t *normal;
	point2d_t ray_perp;

	crv = &extr->crv;

	/* intersect with top and bottom planes */
	dot_pl1 = VDOT( rp->r_dir, extr->pl1 );
	if( NEAR_ZERO( dot_pl1, SMALL_FASTF ) )
	{
		/* ray is parallel to top and bottom faces */
		dist_bottom = DIST_PT_PLANE( rp->r_pt, extr->pl1 );
		dist_top = DIST_PT_PLANE( rp->r_pt, extr->pl2 );
		if( dist_bottom < 0.0 && dist_top < 0.0 )
			return( 0 );
		if( dist_bottom > 0.0 && dist_top > 0.0 )
			return( 0 );
		dist_bottom = -MAX_FASTF;
		dist_top = MAX_FASTF;
	}
	else
	{
		dist_bottom = -DIST_PT_PLANE( rp->r_pt, extr->pl1 )/dot_pl1;
		to_bottom = dist_bottom;					/* need to remember this */
		dist_top = -DIST_PT_PLANE( rp->r_pt, extr->pl2 )/dot_pl1;	/* pl1 and pl2 are parallel */
		if( dist_bottom > dist_top )
		{
			fastf_t tmp1;

			tmp1 = dist_bottom;
			dist_bottom = dist_top;
			dist_top = tmp1;
			top_face = BOTTOM_FACE;
			bot_face = TOP_FACE;
		}
	}

	/* rotate ray */
	MAT4X3PNT( ray_start, extr->rot, rp->r_pt );
	MAT4X3VEC( ray_dir, extr->rot, rp->r_dir );

	dir_dot_z = ray_dir[Z];
	if( dir_dot_z < 0.0 )
		dir_dot_z = -dir_dot_z;

	if( NEAR_ZERO( dir_dot_z - 1.0, SMALL_FASTF ) )
	{
		/* ray is parallel to extrusion vector
		 * set mode to just count intersections for Jordan Theorem
		 */
		check_inout = 1;

		/* set the ray start to the intersection of the original ray and the base plane */
		VJOIN1( tmp, rp->r_pt, to_bottom, rp->r_dir );
		MAT4X3PNT( ray_start, extr->rot, tmp );

		/* use the u vector as the ray direction */
		VMOVE( ray_dir, extr->u_vec );
	}

	/* intersect with projected curve */
	for( i=0 ; i<crv->seg_count ; i++ )
	{
		long *lng=(long *)crv->segments[i];
		struct line_seg *lsg;
		struct carc_seg *csg=NULL;
		struct bezier_seg *bsg=NULL;
		fastf_t diff;

		free_dists = 0;
		switch( *lng )
		{
			case CURVE_LSEG_MAGIC:
				lsg = (struct line_seg *)lng;
				VSUB2( tmp, extr->verts[lsg->end], extr->verts[lsg->start] );
				VMOVE( tmp2, extr->verts[lsg->start] );
				code = bn_isect_line2_line2( dist, ray_start, ray_dir, tmp2, tmp, &extr_tol );
				if( code < 1 )
					continue;

				if( dist[1] > 1.0 || dist[1] < 0.0 )
					continue;

				dists = dist;
				dist_count = 1;
				surfno = LINE_SEG;
				break;
			case CURVE_CARC_MAGIC:
				/* circular arcs become elliptical arcs when projected in the XY-plane */
				csg = (struct carc_seg *)lng;
				{
					vect_t ra, rb;
					fastf_t radius;

					if( csg->radius <= 0.0 )
					{
						/* full circle */
						radius = -csg->radius;

						/* build the ellipse, this actually builds a circle in 3D,
						 * but the intersection routine only uses the X and Y components
						 */
						VSCALE( ra, extr->rot_axis, radius );
						VSCALE( rb, extr->perp, radius );

						dist_count = isect_line2_ellipse( dist, ray_start, ray_dir, extr->verts[csg->end], ra, rb );
						MAT4X3PNT( tmp, extr->irot, extr->verts[csg->end] ); /* used later in hit->vpriv */
					}
					else
					{
						VSCALE( ra, extr->rot_axis, csg->radius );
						VSCALE( rb, extr->perp, csg->radius );
						dist_count = isect_line_earc( dist, ray_start, ray_dir, extr->verts[csg->center], ra, rb, extr->pl1_rot, extr->verts[csg->start], extr->verts[csg->end], csg->orientation );
						MAT4X3PNT( tmp, extr->irot, extr->verts[csg->center] ); /* used later in hit->vpriv */
					}
				}
				if( dist_count < 1 )
					continue;

				dists = dist;
				surfno = CARC_SEG;
				break;
			case CURVE_BEZIER_MAGIC:
				bsg = (struct bezier_seg *)lng;
				verts = (point2d_t *)bu_calloc( bsg->degree + 1, sizeof( point2d_t ), "Bezier verts" );
				for( j=0 ; j<=bsg->degree ; j++ ) {
					V2MOVE( verts[j], extr->verts[bsg->ctl_points[j]] );
				}
				V2MOVE( ray_dir_unit, ray_dir );
				diff = sqrt( MAG2SQ( ray_dir ) );
				ray_dir_unit[X] /= diff;
				ray_dir_unit[Y] /= diff;
				ray_dir_unit[Z] = 0.0;
				ray_perp[X] = ray_dir[Y];
				ray_perp[Y] = -ray_dir[X];
				dist_count = FindRoots( verts, bsg->degree, &intercept, &normal, ray_start, ray_dir_unit, ray_perp,
							0, extr_tol.dist );
				if( dist_count ) {
					free_dists = 1;
					dists = (fastf_t *)bu_calloc( dist_count, sizeof( fastf_t ), "dists (Bezier)" );
					for( j=0 ; j<dist_count ; j++ ) {
						point2d_t to_pt;
						V2SUB2( to_pt, intercept[j], ray_start );
						dists[j] = V2DOT( to_pt, ray_dir_unit) / diff;
					}
					bu_free( (char *)intercept, "Bezier intercept" );
					surfno = BEZIER_SEG;
				}
				bu_free( (char *)verts, "Bezier verts" );
				break;
			case CURVE_NURB_MAGIC:
				break;
			default:
				bu_log( "Unrecognized segment type in sketch (%s) referenced by extrusion (%s)\n",
					stp->st_dp->d_namep );
				bu_bomb( "Unrecognized segment type in sketch\n" );
				break;
		}

		/* eliminate duplicate hit distances */
		for( j=0 ; j<hit_count ; j++ )
		{
			k = 0;
			while( k < dist_count )
			{
				diff = dists[k] - hits[j].hit_dist;
				if( NEAR_ZERO( diff, extr_tol.dist ) )
				{
					int n;
					for( n=k ; n<dist_count-1 ; n++ ) {
						dists[n] = dists[n+1];
						if( *lng == CURVE_BEZIER_MAGIC ) {
							V2MOVE( normal[n], normal[n+1] );
						}
					}
					dist_count--;
				}
				else
					k++;
			}
		}

		/* eliminate duplicate hits below the bottom plane of the extrusion */
		for( j=0 ; j<hits_before_bottom ; j++ )
		{
			k = 0;
			while( k < dist_count )
			{
				diff = dists[k] - dists_before[j];
				if( NEAR_ZERO( diff, extr_tol.dist ) )
				{
					int n;

					for( n=k ; n<dist_count-1 ; n++ ) {
						dists[n] = dists[n+1];
						if( *lng == CURVE_BEZIER_MAGIC ) {
							V2MOVE( normal[n], normal[n+1] );
						}
					}
					dist_count--;
				}
				else
					k++;
			}
		}

		/* eliminate duplicate hits above the top plane of the extrusion */
		for( j=0 ; j<hits_after_top ; j++ )
		{
			k = 0;
			while( k < dist_count )
			{
				diff = dists[k] - dists_after[j];
				if( NEAR_ZERO( diff, extr_tol.dist ) )
				{
					int n;

					for( n=k ; n<dist_count-1 ; n++ )
						dists[n] = dists[n+1];
					dist_count--;
				}
				else
					k++;
			}
		}

		/* if we are just doing the Jordan curve thereom */
		if( check_inout )
		{
			for( j=0 ; j<dist_count ; j++ )
			{
				if( dists[j] < 0.0 )
					hit_count++;
			}
			continue;
		}

		/* process remaining distances into hits */
		for( j=0 ; j<dist_count ; j++ )
		{
			if( dists[j] < dist_bottom )
			{
				if( hits_before_bottom >= MAX_HITS )
				{
					bu_log( "ERROR: rt_extrude_shot: too many hits before bottom on extrusion (%s), limit is %d\n",
					stp->st_dp->d_namep, MAX_HITS );
					bu_bomb( "ERROR: rt_extrude_shot: too many hits before bottom on extrusion\n" );
				}
				dists_before[hits_before_bottom] = dists[j];
				hits_before_bottom++;
				continue;
			}
			if( dists[j] > dist_top )
			{
				if( hits_after_top >= MAX_HITS )
				{
					bu_log( "ERROR: rt_extrude_shot: too many hits after top on extrusion (%s), limit is %d\n",
					stp->st_dp->d_namep, MAX_HITS );
					bu_bomb( "ERROR: rt_extrude_shot: too many hits after top on extrusion\n" );
				}
				dists_after[hits_after_top] = dists[j];
				hits_after_top++;

				continue;
			}

			/* got a hit at distance dists[j] */
			if( hit_count >= MAX_HITS )
			{
				bu_log( "Too many hits on extrusion (%s), limit is %d\n",
					stp->st_dp->d_namep, MAX_HITS );
				bu_bomb( "Too many hits on extrusion\n" );
			}
			hits[hit_count].hit_magic = RT_HIT_MAGIC;
			hits[hit_count].hit_dist = dists[j];
			hits[hit_count].hit_surfno = surfno;
			switch( *lng )
			{
				case CURVE_CARC_MAGIC:
					hits[hit_count].hit_private = (genptr_t)csg; 
					VMOVE( hits[hit_count].hit_vpriv, tmp );
					break;
				case CURVE_LSEG_MAGIC:
					VMOVE( hits[hit_count].hit_vpriv, tmp );
					break;
				case CURVE_BEZIER_MAGIC:
					V2MOVE( hits[hit_count].hit_vpriv, normal[j] );
					hits[hit_count].hit_vpriv[Z] = 0.0;
					break;
				default:
					bu_log( "ERROR: rt_extrude_shot: unrecognized segment type in solid %s\n",
						stp->st_dp->d_namep );
					bu_bomb( "ERROR: rt_extrude_shot: unrecognized segment type in solid\n" );
					break;
			}
			hit_count++;
		}
		if( free_dists )
			bu_free( (char *)dists, "dists" );
	}

	if( check_inout )
	{
		if( hit_count&1 )
		{
			register struct seg *segp;

			hit_count = 2;
			hits[0].hit_magic = RT_HIT_MAGIC;
			hits[0].hit_dist = dist_bottom;
			hits[0].hit_surfno = bot_face;
			VMOVE( hits[0].hit_normal, extr->pl1 );

			hits[1].hit_magic = RT_HIT_MAGIC;
			hits[1].hit_dist = dist_top;
			hits[1].hit_surfno = -top_face;
			VMOVE( hits[1].hit_normal, extr->pl1 );

			RT_GET_SEG(segp, ap->a_resource);
			segp->seg_stp = stp;
			segp->seg_in = hits[0];		/* struct copy */
			segp->seg_out = hits[1];	/* struct copy */
			BU_LIST_INSERT( &(seghead->l), &(segp->l) );
			return( 2 );
		}
		else
		{
			return( 0 );
		}
	}

	if( hit_count )
	{
		/* Sort hits, Near to Far */
		rt_hitsort( hits, hit_count );
	}

	if( hits_before_bottom & 1 )
	{
		if( hit_count >= MAX_HITS )
		{
			bu_log( "Too many hits on extrusion (%s), limit is %d\n",
				stp->st_dp->d_namep, MAX_HITS );
			bu_bomb( "Too many hits on extrusion\n" );
		}
		for( i=hit_count-1 ; i>=0 ; i-- )
			hits[i+1] = hits[i];
		hits[0].hit_magic = RT_HIT_MAGIC;
		hits[0].hit_dist = dist_bottom;
		hits[0].hit_surfno = bot_face;
		VMOVE( hits[0].hit_normal, extr->pl1 );
		hit_count++;
	}

	if( hits_after_top & 1 )
	{
		if( hit_count >= MAX_HITS )
		{
			bu_log( "Too many hits on extrusion (%s), limit is %d\n",
				stp->st_dp->d_namep, MAX_HITS );
			bu_bomb( "Too many hits on extrusion\n" );
		}
		hits[hit_count].hit_magic = RT_HIT_MAGIC;
		hits[hit_count].hit_dist = dist_top;
		hits[hit_count].hit_surfno = top_face;
		VMOVE( hits[hit_count].hit_normal, extr->pl1 );
		hit_count++;
	}

	if( hit_count%2 )
	{
		point_t pt;

		if( hit_count != 1 ) {
			bu_log( "ERROR: rt_extrude_shot(): odd number of hits (%d) (ignoring last hit)\n", hit_count );
			bu_log( "ray start = (%20.10f %20.10f %20.10f)\n", V3ARGS( rp->r_pt ) );
			bu_log( "\tray dir = (%20.10f %20.10f %20.10f)", V3ARGS( rp->r_dir ) );
			VJOIN1( pt, rp->r_pt, hits[hit_count-1].hit_dist, rp->r_dir );
			bu_log( "\tignored hit at (%g %g %g)\n", V3ARGS( pt ) );
		}
		hit_count--;
	}

	/* build segments */
	{
		register struct seg *segp;

		for( i=0; i < hit_count; i += 2 )  {
			RT_GET_SEG(segp, ap->a_resource);
			segp->seg_stp = stp;
			segp->seg_in = hits[i];		/* struct copy */
			segp->seg_out = hits[i+1];	/* struct copy */
			segp->seg_out.hit_surfno = -segp->seg_out.hit_surfno;	/* for exit hits */
			BU_LIST_INSERT( &(seghead->l), &(segp->l) );
		}
	}

	return( hit_count );
}

#define RT_EXTRUDE_SEG_MISS(SEG)	(SEG).seg_stp=RT_SOLTAB_NULL

/*
 *			R T _ E X T R U D E _ V S H O T
 *
 *  Vectorized version.
 */
void
rt_extrude_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		  	       /* Number of ray/object pairs */
                  	    
{
	rt_vstub( stp, rp, segp, n, ap );
}

/*
 *  			R T _ E X T R U D E _ N O R M
 *  
 *  Given ONE ray distance, return the normal and entry/exit point.
 */
void
rt_extrude_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
{
        struct extrude_specific *extr=(struct extrude_specific *)stp->st_specific;
	fastf_t alpha;
	point_t hit_in_plane;
	vect_t tmp, tmp2;

	VJOIN1( hitp->hit_point, rp->r_pt, hitp->hit_dist, rp->r_dir );

	switch( hitp->hit_surfno )
	{
		case LINE_SEG:
			MAT4X3VEC( tmp, extr->irot, hitp->hit_vpriv );
			VCROSS( hitp->hit_normal, extr->unit_h, tmp );
			VUNITIZE( hitp->hit_normal );
			break;
		case -LINE_SEG:
			MAT4X3VEC( tmp, extr->irot, hitp->hit_vpriv );
			VCROSS( hitp->hit_normal, extr->unit_h, tmp );
			VUNITIZE( hitp->hit_normal );
			break;
		case TOP_FACE:
		case BOTTOM_FACE:
		case -TOP_FACE:
		case -BOTTOM_FACE:
			break;
		case CARC_SEG:
		case -CARC_SEG:
			alpha = DIST_PT_PLANE( hitp->hit_point, extr->pl1 ) / VDOT( extr->unit_h, extr->pl1 );
			VJOIN1( hit_in_plane, hitp->hit_point, -alpha, extr->unit_h );
			VSUB2( tmp, hit_in_plane, hitp->hit_vpriv );
			VCROSS( tmp2, extr->pl1, tmp );
			VCROSS( hitp->hit_normal, tmp2, extr->unit_h );
			VUNITIZE( hitp->hit_normal );
			break;
		case BEZIER_SEG:
		case -BEZIER_SEG:
			MAT4X3VEC( hitp->hit_normal, extr->irot, hitp->hit_vpriv );
			VUNITIZE( hitp->hit_normal );
			break;
		default:
			bu_bomb( "ERROR: rt_extrude_norm(): unrecognized surf_no in hit structure!!!\n" );
			break;
	}
	if( hitp->hit_surfno < 0 )
	{
		if( VDOT( hitp->hit_normal, rp->r_dir ) < 0.0 )
			VREVERSE( hitp->hit_normal, hitp->hit_normal );
	}
	else
	{
		if( VDOT( hitp->hit_normal, rp->r_dir ) > 0.0 )
			VREVERSE( hitp->hit_normal, hitp->hit_normal );
	}

}

/*
 *			R T _ E X T R U D E _ C U R V E
 *
 *  Return the curvature of the extrude.
 */
void
rt_extrude_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
{
        struct extrude_specific *extr=(struct extrude_specific *)stp->st_specific;
	struct carc_seg *csg;
	fastf_t radius, a, b, a_sq, b_sq;
	fastf_t curvature, tmp, dota, dotb;
	fastf_t der;
	vect_t diff;
	vect_t ra, rb;

	switch( hitp->hit_surfno )
	{
		case LINE_SEG:
		case -LINE_SEG:
			VMOVE( cvp->crv_pdir, hitp->hit_vpriv );
			VUNITIZE( cvp->crv_pdir );
			cvp->crv_c1 = cvp->crv_c2 = 0;
			break;
		case CARC_SEG:
		case -CARC_SEG:
			/* curvature for an ellipse (the rotated and projected circular arc) in XY-plane
			 * based on curvature for ellipse = |ra||rb|/(|derivative|**3)
			 */
			csg = (struct carc_seg *)hitp->hit_private;
			VCROSS( cvp->crv_pdir, extr->unit_h, hitp->hit_normal );
			VSUB2( diff, hitp->hit_point, hitp->hit_vpriv );
			if( csg->radius < 0.0 )
				radius = -csg->radius;
			else
				radius = csg->radius;
			VSCALE( ra, extr->rot_axis, radius );
			VSCALE( rb, extr->perp, radius );
			
			a_sq = MAG2SQ( ra );
			b_sq = MAG2SQ( rb );
			a = sqrt( a_sq );
			b = sqrt( b_sq );
			dota = VDOT( diff, ra );
			dotb = VDOT( diff, rb );
			tmp = (a_sq/(b_sq*b_sq))*dotb*dotb + (b_sq/(a_sq*a_sq))*dota*dota;
			der = sqrt( tmp );
			curvature = a*b/(der*der*der);
			if( VDOT( hitp->hit_normal, diff ) > 0.0 )
				cvp->crv_c1 = curvature;
			else
				cvp->crv_c1 = -curvature;
			cvp->crv_c2 = 0;
			break;
	}
}

/*
 *  			R T _ E X T R U D E _ U V
 *  
 *  For a hit on the surface of an extrude, return the (u,v) coordinates
 *  of the hit point, 0 <= u,v <= 1.
 *  u = azimuth
 *  v = elevation
 */
void
rt_extrude_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
{
}

/*
 *		R T _ E X T R U D E _ F R E E
 */
void
rt_extrude_free(register struct soltab *stp)
{
	register struct extrude_specific *extrude =
		(struct extrude_specific *)stp->st_specific;

	if( extrude->verts )
		bu_free( (char *)extrude->verts, "extrude->verts" );
	rt_curve_free( &(extrude->crv) );
	bu_free( (char *)extrude, "extrude_specific" );
}

/*
 *			R T _ E X T R U D E _ C L A S S
 */
int
rt_extrude_class(void)
{
	return(0);
}

/*
 *			R T _ E X T R U D E _ P L O T
 */
int
rt_extrude_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
	LOCAL struct rt_extrude_internal	*extrude_ip;
	struct curve			*crv=(struct curve *)NULL;
	struct rt_sketch_internal	*sketch_ip;
	point_t				end_of_h;
	int				i1, i2, nused1, nused2;
	struct bn_vlist			*vp1, *vp2, *vp2_start;

	RT_CK_DB_INTERNAL(ip);
	extrude_ip = (struct rt_extrude_internal *)ip->idb_ptr;
	RT_EXTRUDE_CK_MAGIC(extrude_ip);

	if( !extrude_ip->skt )
	{
		bu_log( "rt_extrude_plot: ERROR: no sketch for extrusion!!!!\n" );

		RT_ADD_VLIST( vhead, extrude_ip->V, BN_VLIST_LINE_MOVE );
		RT_ADD_VLIST( vhead, extrude_ip->V, BN_VLIST_LINE_DRAW );
		return( 0 );
	}

	sketch_ip = extrude_ip->skt;
	RT_SKETCH_CK_MAGIC( sketch_ip );

	crv = &sketch_ip->skt_curve;

	/* plot bottom curve */
	vp1 = BU_LIST_LAST( bn_vlist, vhead );
	nused1 = vp1->nused;
	if( curve_to_vlist( vhead, ttol, extrude_ip->V, extrude_ip->u_vec, extrude_ip->v_vec, sketch_ip, crv ) )
	{
		bu_log( "Error: sketch (%s) references non-existent vertices!!!\n",
			extrude_ip->sketch_name );
		return( -1 );
	}

	/* plot top curve */
	VADD2( end_of_h, extrude_ip->V, extrude_ip->h );
	vp2 = BU_LIST_LAST( bn_vlist, vhead );
	nused2 = vp2->nused;
	curve_to_vlist( vhead, ttol, end_of_h, extrude_ip->u_vec, extrude_ip->v_vec, sketch_ip, crv );
	
	/* plot connecting lines */
	vp2_start = vp2;
	i1 = nused1;
	if( i1 >= vp1->nused )
	{
		i1 = 0;
		vp1 = BU_LIST_NEXT( bn_vlist, &vp1->l );
	}
	i2 = nused2;
	if( i2 >= vp2->nused )
	{
		i2 = 0;
		vp2 = BU_LIST_NEXT( bn_vlist, &vp2->l );
		nused2--;
	}
	while( vp1 != vp2_start || i1 != nused2 )
	{
		RT_ADD_VLIST( vhead, vp1->pt[i1], BN_VLIST_LINE_MOVE );
		RT_ADD_VLIST( vhead, vp2->pt[i2], BN_VLIST_LINE_DRAW );
		i1++;
		if( i1 >= vp1->nused )
		{
			i1 = 0;
			vp1 = BU_LIST_NEXT( bn_vlist, &vp1->l );
		}
		i2++;
		if( i2 >= vp2->nused )
		{
			i2 = 0;
			vp2 = BU_LIST_NEXT( bn_vlist, &vp2->l );
		}
	}

	return(0);
}

void
get_indices( genptr_t seg, int *start, int *end )
{
	struct carc_seg *csg;
	struct nurb_seg *nsg;
	struct bezier_seg *bsg;
	struct line_seg *lsg=(struct line_seg *)seg;

	switch (lsg->magic) {
		case CURVE_LSEG_MAGIC:
			*start = lsg->start;
			*end = lsg->end;
			break;
		case CURVE_CARC_MAGIC:
			csg = (struct carc_seg *)seg;
			if( csg->radius < 0.0 ) {
				*start = csg->start;
				*end = *start;
				break;
			}
			*start = csg->start;
			*end = csg->end;
			break;
		case CURVE_NURB_MAGIC:
			nsg = (struct nurb_seg *)seg;
			*start = nsg->ctl_points[0];
			*end = nsg->ctl_points[nsg->c_size-1];
			break;
		case CURVE_BEZIER_MAGIC:
			bsg = (struct bezier_seg *)seg;
			*start = bsg->ctl_points[0];
			*end = bsg->ctl_points[bsg->degree];
			break;
	}
}

void
get_seg_midpoint( genptr_t seg, struct rt_sketch_internal *skt, point2d_t pt )
{
	struct edge_g_cnurb eg;
	point_t tmp_pt;
	struct line_seg *lsg;
	struct carc_seg *csg;
	struct nurb_seg *nsg;
	struct bezier_seg *bsg;
	long *lng;
	point2d_t *V;
	point2d_t pta;
	int i;
	int coords;

	lng = (long *)seg;

	switch( *lng )
		{
		case CURVE_LSEG_MAGIC:
			lsg = (struct line_seg *)lng;
			VADD2_2D( pta, skt->verts[lsg->start], skt->verts[lsg->end] );
			VSCALE_2D( pt, pta, 0.5 );
			break;
		case CURVE_CARC_MAGIC:
			csg = (struct carc_seg *)lng;
			if( csg->radius < 0.0 ) {
				VMOVE_2D( pt, skt->verts[csg->start] );
			} else {
				point2d_t start2d, end2d, mid_pt, s2m, dir, center2d;
				fastf_t tmp_len, len_sq, mid_ang, s2m_len_sq, cross_z;
				fastf_t start_ang, end_ang;

				/* this is an arc (not a full circle) */
				V2MOVE( start2d, skt->verts[csg->start] );
				V2MOVE( end2d, skt->verts[csg->end] );
				mid_pt[0] = (start2d[0] + end2d[0]) * 0.5;
				mid_pt[1] = (start2d[1] + end2d[1]) * 0.5;
				V2SUB2( s2m, mid_pt, start2d );
				dir[0] = -s2m[1];
				dir[1] = s2m[0];
				s2m_len_sq =  s2m[0]*s2m[0] + s2m[1]*s2m[1];
				if( s2m_len_sq < SMALL_FASTF ) {
					bu_log( "start and end points are too close together in circular arc of sketch\n" );
					break;
				}
				len_sq = csg->radius*csg->radius - s2m_len_sq;
				if( len_sq < 0.0 ) {
					bu_log( "Impossible radius for specified start and end points in circular arc\n");
					break;
				}
				tmp_len = sqrt( dir[0]*dir[0] + dir[1]*dir[1] );
				dir[0] = dir[0] / tmp_len;
				dir[1] = dir[1] / tmp_len;
				tmp_len = sqrt( len_sq );
				V2JOIN1( center2d, mid_pt, tmp_len, dir );

				/* check center location */
				cross_z = ( end2d[X] - start2d[X] )*( center2d[Y] - start2d[Y] ) -
					( end2d[Y] - start2d[Y] )*( center2d[X] - start2d[X] );
				if( !(cross_z > 0.0 && csg->center_is_left) ) {
					V2JOIN1( center2d, mid_pt, -tmp_len, dir );
				}
				start_ang = atan2( start2d[Y]-center2d[Y], start2d[X]-center2d[X] );
				end_ang = atan2( end2d[Y]-center2d[Y], end2d[X]-center2d[X] );
				if( csg->orientation ) { /* clock-wise */
					while( end_ang > start_ang )
						end_ang -= 2.0 * M_PI;
				}	
				else { /* counter-clock-wise */
					while( end_ang < start_ang )
						end_ang += 2.0 * M_PI;
				}

				/* get mid angle */
				mid_ang = (start_ang + end_ang ) * 0.5;

				/* calculate mid point */
				pt[X] = center2d[X] + csg->radius * cos( mid_ang );
				pt[Y] = center2d[Y] + csg->radius * sin( mid_ang );
					break;
				}
			break;
		case CURVE_NURB_MAGIC:
			nsg = (struct nurb_seg *)lng;

			eg.l.magic = NMG_EDGE_G_CNURB_MAGIC;
			eg.order = nsg->order;
			eg.k.k_size = nsg->k.k_size;
			eg.k.knots = nsg->k.knots;
			eg.c_size = nsg->c_size;
			coords = 2 + RT_NURB_IS_PT_RATIONAL( nsg->pt_type );
			eg.pt_type = RT_NURB_MAKE_PT_TYPE( coords, 2, RT_NURB_IS_PT_RATIONAL( nsg->pt_type ) );
			eg.ctl_points = (fastf_t *)bu_malloc( nsg->c_size * coords * sizeof( fastf_t ), "eg.ctl_points" );
			if( RT_NURB_IS_PT_RATIONAL( nsg->pt_type ) ) {
				for( i=0 ; i<nsg->c_size ; i++ ) {
					VMOVE_2D( &eg.ctl_points[i*coords], skt->verts[nsg->ctl_points[i]] );
					eg.ctl_points[(i+1)*coords - 1] = nsg->weights[i];
				}
			}
			else {
				for( i=0 ; i<nsg->c_size ; i++ ) {
					VMOVE_2D( &eg.ctl_points[i*coords], skt->verts[nsg->ctl_points[i]] );
				}
			}
			rt_nurb_c_eval( &eg, (nsg->k.knots[nsg->k.k_size-1] - nsg->k.knots[0]) * 0.5, tmp_pt );
			if( RT_NURB_IS_PT_RATIONAL( nsg->pt_type ) ) {
				int j;

				for( j=0 ; j<coords-1 ; j++ )
					pt[j] = tmp_pt[j] / tmp_pt[coords-1];
			} else {
				V2MOVE( pt, tmp_pt );
			}
			bu_free( (char *)eg.ctl_points, "eg.ctl_points" );
			break;
		case CURVE_BEZIER_MAGIC:
			bsg = (struct bezier_seg *)lng;
			V = (point2d_t *)bu_calloc( bsg->degree+1, sizeof( point2d_t ), "Bezier control points" );
			for( i=0 ; i<= bsg->degree ; i++ ) {
				VMOVE_2D( V[i], skt->verts[bsg->ctl_points[i]] );
			}
			Bezier( V, bsg->degree, 0.51, NULL, NULL, pt, NULL );
			bu_free( (char *)V, "Bezier control points" );
			break;
		default:
			bu_bomb( "Unrecognized segment type in sketch\n");
			break;
		}
}

struct loop_inter {
	int			which_loop;
	int			vert_index;	/* index of vertex intersected, or -1 if no hit on a vertex */
	fastf_t			dist;		/* hit distance */
	struct loop_inter	*next;
};

void
isect_2D_loop_ray( point2d_t pta, point2d_t dir, struct bu_ptbl *loop, struct loop_inter **root,
		   int which_loop, struct rt_sketch_internal *ip, struct bn_tol *tol )
{
	int i, j;
	int code;
	point2d_t norm;
	fastf_t dist[2];

	norm[0] = -dir[1];
	norm[1] = dir[0];
 
	for( i=0 ; i<BU_PTBL_END( loop ) ; i++ ) {
		long *lng;
		struct loop_inter *inter;
		struct line_seg *lsg=NULL;
		struct carc_seg *csg=NULL;
		struct bezier_seg *bsg=NULL;
		point2d_t d1;
		point2d_t diff;
		fastf_t radius;
		point2d_t *verts;
		point2d_t *intercept;
		point2d_t *normal;

		lng = BU_PTBL_GET( loop, i );
		switch( *lng ) {
			case CURVE_LSEG_MAGIC:
				lsg = (struct line_seg *)lng;
				V2SUB2( d1, ip->verts[lsg->end], ip->verts[lsg->start] );
				code = bn_isect_line2_lseg2( dist, pta, dir, ip->verts[lsg->start], d1, tol );
				if( code < 0 )
					break;
				if( code == 0 ) {
					/* edge is collinear with ray */
					/* add two intersections, one at each end vertex */
					inter = (struct loop_inter *)bu_calloc( sizeof( struct loop_inter ), 1,
										"loop intersection" );
					inter->which_loop = which_loop;
					inter->vert_index = lsg->start;
					inter->dist = dist[0];
					inter->next = NULL;
					if( !(*root) ) {
						(*root) = inter;
					} else {
						inter->next = (*root);
						(*root) = inter;
					}
					inter = (struct loop_inter *)bu_calloc( sizeof( struct loop_inter ), 1,
										"loop intersection" );
					inter->which_loop = which_loop;
					inter->vert_index = lsg->end;
					inter->dist = dist[1];
					inter->next = NULL;
					inter->next = (*root);
					(*root) = inter;
				} else if( code == 1 ) {
					/* hit at start vertex */
					inter = (struct loop_inter *)bu_calloc( sizeof( struct loop_inter ), 1,
										"loop intersection" );
					inter->which_loop = which_loop;
					inter->vert_index = lsg->start;
					inter->dist = dist[0];
					inter->next = NULL;
					if( !(*root) ) {
						(*root) = inter;
					} else {
						inter->next = (*root);
						(*root) = inter;
					}
				} else if( code == 2 ) {
					/* hit at end vertex */
					inter = (struct loop_inter *)bu_calloc( sizeof( struct loop_inter ), 1,
										"loop intersection" );
					inter->which_loop = which_loop;
					inter->vert_index = lsg->end;
					inter->dist = dist[0];
					inter->next = NULL;
					if( !(*root) ) {
						(*root) = inter;
					} else {
						inter->next = (*root);
						(*root) = inter;
					}
				} else {
					/* hit on edge, not at a vertex */
					inter = (struct loop_inter *)bu_calloc( sizeof( struct loop_inter ), 1,
										"loop intersection" );
					inter->which_loop = which_loop;
					inter->vert_index = -1;
					inter->dist = dist[0];
					inter->next = NULL;
					if( !(*root) ) {
						(*root) = inter;
					} else {
						inter->next = (*root);
						(*root) = inter;
					}
				}
				break;
			case CURVE_CARC_MAGIC:
				csg = (struct carc_seg *)lng;
				radius = csg->radius;
				if( csg->radius <= 0.0 ) {
					point2d_t ra, rb;

					V2SUB2( diff, ip->verts[csg->start], ip->verts[csg->end] );
					radius = sqrt( MAG2SQ( diff ) );
					ra[X] = radius;
					ra[Y] = 0.0;
					rb[X] = 0.0;
					rb[Y] = radius;
					code = isect_line2_ellipse( dist, pta, dir, ip->verts[csg->end],
								    ra, rb );

					if( code <= 0 )
						break;
					for( j=0 ; j<code ; j++ ) {
						inter = (struct loop_inter *)bu_calloc( sizeof( struct loop_inter ), 1,
										"loop intersection" );
						inter->which_loop = which_loop;
						inter->vert_index = -1;
						inter->dist = dist[j];
						inter->next = NULL;
						if( !(*root) ) {
							(*root) = inter;
						} else {
							inter->next = (*root);
							(*root) = inter;
						}
					}
					
				} else {
					point2d_t ra, rb;
					vect_t s2m, tmp_dir;
					point2d_t start2d, end2d, mid_pt, center2d;
					fastf_t s2m_len_sq, len_sq, tmp_len, cross_z;

					V2MOVE( start2d, ip->verts[csg->start] );
					V2MOVE( end2d, ip->verts[csg->end] );
					mid_pt[0] = (start2d[0] + end2d[0]) * 0.5;
					mid_pt[1] = (start2d[1] + end2d[1]) * 0.5;
					V2SUB2( s2m, mid_pt, start2d )
						tmp_dir[0] = -s2m[1];
					tmp_dir[1] = s2m[0];
					s2m_len_sq =  s2m[0]*s2m[0] + s2m[1]*s2m[1];
					if( s2m_len_sq < SMALL_FASTF )
						{
							bu_log( "start and end points are too close together in circular arc of sketch\n" );
							break;
						}
					len_sq = radius*radius - s2m_len_sq;
					if( len_sq < 0.0 )
						{
							bu_log( "Impossible radius for specified start and end points in circular arc\n");
							break;
						}
					tmp_len = sqrt( tmp_dir[0]*tmp_dir[0] + tmp_dir[1]*tmp_dir[1] );
					tmp_dir[0] = tmp_dir[0] / tmp_len;
					tmp_dir[1] = tmp_dir[1] / tmp_len;
					tmp_len = sqrt( len_sq );
					V2JOIN1( center2d, mid_pt, tmp_len, tmp_dir )

						/* check center location */
						cross_z = ( end2d[X] - start2d[X] )*( center2d[Y] - start2d[Y] ) -
						( end2d[Y] - start2d[Y] )*( center2d[X] - start2d[X] );
					if( !(cross_z > 0.0 && csg->center_is_left) )
						V2JOIN1( center2d, mid_pt, -tmp_len, tmp_dir );

					ra[X] = radius;
					ra[Y] = 0.0;
					rb[X] = 0.0;
					rb[Y] = radius;
					code = isect_line_earc( dist, pta, dir, center2d, ra, rb,
								norm, ip->verts[csg->start], ip->verts[csg->end],
								csg->orientation );
					if( code <= 0 )
						break;
					for( j=0 ; j<code ; j++ ) {
						inter = (struct loop_inter *)bu_calloc( sizeof( struct loop_inter ), 1,
										"loop intersection" );
						inter->which_loop = which_loop;
						inter->vert_index = -1;
						inter->dist = dist[j];
						inter->next = NULL;
						if( !(*root) ) {
							(*root) = inter;
						} else {
							inter->next = (*root);
							(*root) = inter;
						}
					}
				}
				break;
			case CURVE_BEZIER_MAGIC:
				bsg = (struct bezier_seg *)lng;
				intercept = NULL;
				normal = NULL;
				verts = (point2d_t *)bu_calloc( bsg->degree + 1, sizeof( point2d_t ), "Bezier verts" );
				for( j=0 ; j<=bsg->degree ; j++ ) {
					V2MOVE( verts[j], ip->verts[bsg->ctl_points[j]] );
				}
				code = FindRoots( verts, bsg->degree, &intercept, &normal, pta, dir, norm, 0, tol->dist );
				for( j=0 ; j<code ; j++ ) {
					V2SUB2( diff, intercept[j], pta );
					dist[0] = sqrt( MAG2SQ( diff ) );
					inter = (struct loop_inter *)bu_calloc( sizeof( struct loop_inter ), 1,
										"loop intersection" );
					inter->which_loop = which_loop;
					inter->vert_index = -1;
					inter->dist = dist[0];
					inter->next = NULL;
					if( !(*root) ) {
						(*root) = inter;
					} else {
						inter->next = (*root);
						(*root) = inter;
					}
				}
				if( (*intercept) )
					bu_free( (char *)intercept, "Bezier Intercepts" );
				if( (*normal) )
					bu_free( (char *)normal, "Bezier normals" );
				bu_free( ( char *)verts, "Bezier Ctl points" );
				break;
			default:
				bu_log( "isect_2D_loop_ray: Unrecognized curve segment type x%x\n", *lng );
				bu_bomb( "isect_2D_loop_ray: Unrecognized curve segment type\n" );
				break;
		}
	}
}

static void
sort_intersections( struct loop_inter **root, struct bn_tol *tol )
{
	struct loop_inter *ptr, *prev, *pprev;
	int done=0;
	fastf_t diff;

	/* eliminate any duplicates */
	ptr = (*root);
	while( ptr->next ) {
		prev = ptr;
		ptr = ptr->next;
		if( ptr->vert_index > -1 && ptr->vert_index == prev->vert_index ) {
			prev->next = ptr->next;
			bu_free( (char *)ptr, "struct loop_inter" );
			ptr = prev;
		}
	}

	ptr = (*root);
	while( ptr->next ) {
		prev = ptr;
		ptr = ptr->next;
		diff = fabs( ptr->dist - prev->dist );
		if( diff < tol->dist ) {
			prev->next = ptr->next;
			bu_free( (char *)ptr, "struct loop_inter" );
			ptr = prev;
		}
	}

	while( !done ) {
		done = 1;
		ptr = (*root);
		prev = NULL;
		pprev = NULL;
		while( ptr->next ) {
			pprev = prev;
			prev = ptr;
			ptr = ptr->next;
			if( ptr->dist < prev->dist ) {
				done = 0;
				if( pprev ) {
					prev->next = ptr->next;
					pprev->next = ptr;
					ptr->next = prev;
				} else {
					prev->next = ptr->next;
					ptr->next = prev;
					(*root) = ptr;
				}
			}
		}
	}
}

int
classify_sketch_loops( struct bu_ptbl *loopa, struct bu_ptbl *loopb, struct rt_sketch_internal *ip )
{
	struct loop_inter *inter_root=NULL, *ptr, *tmp;
	struct bn_tol tol;
	point2d_t pta, ptb;
	point2d_t dir;
	genptr_t seg;
	fastf_t inv_len;
	int loopa_count=0, loopb_count=0;
	int ret=UNKNOWN;

	BU_CK_PTBL( loopa );
	BU_CK_PTBL( loopb );
	RT_SKETCH_CK_MAGIC( ip );

	tol.magic = BN_TOL_MAGIC;
	tol.dist = 0.005;
	tol.dist_sq = tol.dist * tol.dist;
	tol.perp = 1.0e-5;;
	tol.para = 1.0 - tol.perp;

	/* find points on a midpoint of a segment for each loop */
	seg = (genptr_t)BU_PTBL_GET( loopa, 0 );
	get_seg_midpoint( seg, ip, pta );
	seg = (genptr_t)BU_PTBL_GET( loopb, 0 );
	get_seg_midpoint( seg, ip, ptb );

	V2SUB2( dir, ptb, pta );
	inv_len = 1.0 / sqrt( MAGSQ_2D( dir ) );
	V2SCALE( dir, dir, inv_len );
	
	/* intersect pta<->ptb line with both loops */
        isect_2D_loop_ray( pta, dir, loopa, &inter_root, LOOPA, ip, &tol );
	isect_2D_loop_ray( pta, dir, loopb, &inter_root, LOOPB, ip, &tol );

	sort_intersections( &inter_root, &tol );

	/* examine intercepts to determine loop relationship */
	ptr = inter_root;
	while( ptr ) {
		tmp = ptr;
		if( ret == UNKNOWN ) {
			if( ptr->which_loop == LOOPA ) {
				loopa_count++;
				if( loopa_count && loopb_count ) {
					if( loopb_count % 2 ) {
						ret = A_IN_B;
					} else {
						ret = DISJOINT;
					}
				}
			} else {
				loopb_count++;
				if( loopa_count && loopb_count ) {
					if( loopa_count % 2 ) {
						ret = B_IN_A;
					} else {
						ret = DISJOINT;
					}
				}
			}
		}
		ptr = ptr->next;
		bu_free( (char *)tmp, "loop intercept" );
	}

	return( ret );
}

/*
 *			R T _ E X T R U D E _ T E S S
 *
 *  Returns -
 *	-1	failure
 *	 0	OK.  *r points to nmgregion that holds this tessellation.
 */
int
rt_extrude_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
#if 0
	return( -1 );
#else
	struct bu_list			vhead;
	struct shell			*s;
	struct faceuse			*fu;
	struct vertex			***verts;
	struct vertex			**vertsa;
	int				vert_count=0;
	struct rt_extrude_internal	*extrude_ip;
	struct rt_sketch_internal	*sketch_ip;
	struct curve			*crv=(struct curve *)NULL;
	struct bu_ptbl			*aloop=NULL, loops, **containing_loops, *outer_loop;
	int				i, j, k;
	int				*used_seg;
	struct bn_vlist			*vlp;
	plane_t				pl;

	RT_CK_DB_INTERNAL(ip);
	extrude_ip = (struct rt_extrude_internal *)ip->idb_ptr;
	RT_EXTRUDE_CK_MAGIC(extrude_ip);

	if( !extrude_ip->skt )
	{
		bu_log( "rt_extrude_tess: ERROR: no sketch for extrusion!!!!\n" );
		return( -1 );
	}

	sketch_ip = extrude_ip->skt;
	RT_SKETCH_CK_MAGIC( sketch_ip );

	crv = &sketch_ip->skt_curve;

	if( crv->seg_count < 1 )
		return( 0 );

	/* find all the loops */
	used_seg = (int *)bu_calloc( crv->seg_count, sizeof( int ), "used_seg" );
	bu_ptbl_init( &loops, 5, "loops" );
	for( i=0 ; i<crv->seg_count ; i++ ) {
		genptr_t cur_seg;
		int loop_start, loop_end;
		int seg_start, seg_end;

		if( used_seg[i] )
			continue;

		aloop = (struct bu_ptbl *)bu_calloc( 1, sizeof( struct bu_ptbl ), "aloop" );
		bu_ptbl_init( aloop, 5, "aloop" );

		bu_ptbl_ins( aloop, (long *)crv->segments[i] );
		used_seg[i] = 1;
		cur_seg = crv->segments[i];
		get_indices( cur_seg, &loop_start, &loop_end );

		while( loop_end != loop_start ) {
			int j;
			int added_seg;

			added_seg = 0;
			for( j=0 ; j<crv->seg_count ; j++ ) {
				if( used_seg[j] )
					continue;

				get_indices( crv->segments[j], &seg_start, &seg_end );
				if( seg_start != seg_end && seg_start == loop_end ) {
					added_seg++;
					bu_ptbl_ins( aloop, (long *)crv->segments[j] );
					used_seg[j] = 1;
					loop_end = seg_end;
					if( loop_start == loop_end )
						break;
				}
			}
			if( !added_seg ) {
				bu_log( "rt_extrude_tess: A loop is not closed in sketch %s\n",
					extrude_ip->sketch_name );
				bu_log( "\ttessellation failed!!\n" );
				for( j=0 ; j<BU_PTBL_END( &loops ) ; j++ ) {
					aloop = (struct bu_ptbl *)BU_PTBL_GET( &loops, j );
					bu_ptbl_free( aloop );
					bu_free( (char *)aloop, "aloop" );
				}
				bu_ptbl_free( &loops );
				bu_free( ( char *)used_seg, "used_seg" );
				return( -2 );
			}
		}
		bu_ptbl_ins( &loops, (long *)aloop );
	}
	bu_free( ( char *)used_seg, "used_seg" );

	/* sort the loops to find inside/outside relationships */
	containing_loops = (struct bu_ptbl **)bu_calloc( BU_PTBL_END( &loops ),
							 sizeof( struct bu_ptbl *), "containing_loops" );
	for( i=0 ; i<BU_PTBL_END( &loops ) ; i++ ) {
		containing_loops[i] = (struct bu_ptbl *)bu_calloc( 1, sizeof( struct bu_ptbl ), "containing_loops[i]" );
		bu_ptbl_init( containing_loops[i], BU_PTBL_END( &loops ), "containing_loops[i]" );
	}

	for( i=0 ; i<BU_PTBL_END( &loops ) ; i++ ) {
		struct bu_ptbl *loopa;
		int j;

		loopa = (struct bu_ptbl *)BU_PTBL_GET( &loops, i );
		for( j=i+1 ; j<BU_PTBL_END( &loops ) ; j++ ) {
			struct bu_ptbl *loopb;

			loopb = (struct bu_ptbl *)BU_PTBL_GET( &loops, j );
			switch( classify_sketch_loops( loopa, loopb, sketch_ip ) ) {
				case A_IN_B:
					bu_ptbl_ins( containing_loops[i], (long *)loopb );
					break;
				case B_IN_A:
					bu_ptbl_ins( containing_loops[j], (long *)loopa );
					break;
				case DISJOINT:
					break;
				default:
					bu_log( "rt_extrude_tess: Failed to classify loops!!\n" );
					goto failed;
			}
		}
	}

	/* make loops */

	/* find an outermost loop */
	outer_loop = (struct bu_ptbl *)NULL;
	for( i=0 ; i<BU_PTBL_END( &loops ) ; i++ ) {
		if( BU_PTBL_END( containing_loops[i] ) == 0 ) {
			outer_loop = (struct bu_ptbl *)BU_PTBL_GET( &loops, i );
			break;
		}
	}

	if( !outer_loop ) {
		bu_log( "No outer loop in sketch %s\n", extrude_ip->sketch_name );
		bu_log( "\ttessellation failed\n" );
		for( i=0 ; i<BU_PTBL_END( &loops ) ; i++ ) { 
		}
		for( i=0 ; i<BU_PTBL_END( &loops ) ; i++ ) {
			aloop = (struct bu_ptbl *)BU_PTBL_GET( &loops, i );
			bu_ptbl_free( aloop );
			bu_free( (char *)aloop, "aloop" );
			bu_ptbl_free( containing_loops[i] );
			bu_free( (char *)containing_loops[i], "aloop" );
		}
		bu_ptbl_free( &loops );
		bu_free( (char *)containing_loops, "containing_loops" );
	}

	BU_LIST_INIT( &vhead );
	if( BU_LIST_UNINITIALIZED( &rt_g.rtg_vlfree ) ) {
		BU_LIST_INIT( &rt_g.rtg_vlfree );
	}
	for( i=0 ; i<BU_PTBL_END( outer_loop ) ; i++ ) {
		genptr_t seg;

		seg = (genptr_t)BU_PTBL_GET( outer_loop, i );
		if( seg_to_vlist( &vhead, ttol, extrude_ip->V, extrude_ip->u_vec, extrude_ip->v_vec, sketch_ip, seg ) )
			goto failed;
	}

	/* count vertices */
	vert_count = 0;
	for( BU_LIST_FOR( vlp, bn_vlist, &vhead ) ) {
		for( i=0 ; i<vlp->nused ; i++ ) {
			if( vlp->cmd[i] == BN_VLIST_LINE_DRAW )
				vert_count++;
		}
	}

	*r = nmg_mrsv( m );
	s = BU_LIST_FIRST( shell, &((*r)->s_hd) );

	/* make initial face from outer_loop */
	verts = (struct vertex ***)bu_calloc( vert_count, sizeof( struct vertex **), "verts" );
	for( i=0 ; i<vert_count ; i++ ) {
		verts[i] = (struct vertex **)bu_calloc( 1, sizeof( struct vertex *), "verts[i]" );
	}

	fu = nmg_cmface( s, verts, vert_count );
	j = 0;
	for( BU_LIST_FOR( vlp, bn_vlist, &vhead ) ) {
		for( i=0 ; i<vlp->nused ; i++ ) {
			if( vlp->cmd[i] == BN_VLIST_LINE_DRAW ) {
				nmg_vertex_gv( *verts[j], vlp->pt[i] );
				j++;
			}
		}
	}
	BN_FREE_VLIST( &rt_g.rtg_vlfree, &vhead );

	/* make sure face normal is in correct direction */
	bu_free( (char *)verts, "verts" );
	if( nmg_calc_face_plane( fu, pl ) ) {
		bu_log( "Failed to calculate face plane for extrusion\n" );
		return( -1 );
	}
	nmg_face_g( fu, pl );
	if( VDOT( pl, extrude_ip->h ) > 0.0 ) {
		nmg_reverse_face( fu );
		fu = fu->fumate_p;
	}

	/* add the rest of the loops */
	for( i=0 ; i<BU_PTBL_END( &loops ) ; i++ ) {
		int fdir;
		vect_t cross;
		fastf_t pt_count=0.0;
		fastf_t dot;
		int rev=0;

		aloop = (struct bu_ptbl *)BU_PTBL_GET( &loops, i );
		if( aloop == outer_loop )
			continue;

		if( BU_PTBL_END( containing_loops[i] ) % 2 ) {
			fdir = OT_OPPOSITE;
		} else {
			fdir = OT_SAME;
		}

		for( j=0 ; j<BU_PTBL_END( aloop ) ; j++ ) {
			genptr_t seg;

			seg = (genptr_t)BU_PTBL_GET( aloop, j );
			if( seg_to_vlist( &vhead, ttol, extrude_ip->V,
					  extrude_ip->u_vec, extrude_ip->v_vec, sketch_ip, seg ) )
				goto failed;
		}

		/* calculate plane of this loop */
		VSETALLN( pl, 0.0, 4 );
		for( BU_LIST_FOR( vlp, bn_vlist, &vhead ) ) {
			for( j=1 ; j<vlp->nused ; j++ ) {
				if( vlp->cmd[j] == BN_VLIST_LINE_DRAW ) {
					VCROSS( cross, vlp->pt[j-1], vlp->pt[j] );
					VADD2( pl, pl, cross );
				}
			}
		}

		VUNITIZE( pl );

		for( BU_LIST_FOR( vlp, bn_vlist, &vhead ) ) {
			for( j=1 ; j<vlp->nused ; j++ ) {
				if( vlp->cmd[j] == BN_VLIST_LINE_DRAW ) {
					pl[3] += VDOT( pl, vlp->pt[j] );
					pt_count++;
				}
			}
		}
		pl[3] /= pt_count;

		dot = -VDOT( pl, extrude_ip->h );
		rev = 0;
		if( fdir == OT_SAME && dot < 0.0 )
			rev = 1;
		else if( fdir == OT_OPPOSITE && dot > 0.0 )
			rev = 1;

		vertsa = (struct vertex **)bu_calloc( pt_count, sizeof( struct vertex *), "verts" );

		fu = nmg_add_loop_to_face( s, fu, vertsa, pt_count, fdir );

		k = 0;
		for( BU_LIST_FOR( vlp, bn_vlist, &vhead ) ) {
			for( j=1 ; j<vlp->nused ; j++ ) {
				if( vlp->cmd[j] == BN_VLIST_LINE_DRAW ) {
					if( rev ) {
						nmg_vertex_gv( vertsa[(int)(pt_count) - k - 1], vlp->pt[j] );
					} else {
						nmg_vertex_gv( vertsa[k], vlp->pt[j] );
					}
					k++;
				}
			}
		}
		RT_FREE_VLIST( &vhead );
	}

	/* extrude this face */
	if( nmg_extrude_face( fu, extrude_ip->h, tol ) ) {
		bu_log( "Failed to extrude face sketch\n" );
		return( -1 );
	}

	nmg_region_a( *r, tol );

	return( 0 );

 failed:
	for( i=0 ; i<BU_PTBL_END( &loops ) ; i++ ) {
		bu_ptbl_free( containing_loops[i] );
		bu_free( (char *)containing_loops[i], "containing_loops[i]" );
	}
	bu_free( (char *)containing_loops, "containing_loops" );
	bu_ptbl_free( aloop );
	bu_free( (char *)aloop, "aloop" );
	return( -1 );
#endif
}

/*
 *			R T _ E X T R U D E _ I M P O R T
 *
 *  Import an EXTRUDE from the database format to the internal format.
 *  Apply modeling transformations as well.
 */
int
rt_extrude_import(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip, struct resource *resp)
{
	LOCAL struct rt_extrude_internal	*extrude_ip;
	struct rt_db_internal			tmp_ip;
	struct directory			*dp;
	char					*sketch_name;
	union record				*rp;
	char					*ptr;
	point_t					tmp_vec;

	BU_CK_EXTERNAL( ep );
	rp = (union record *)ep->ext_buf;
	/* Check record type */
	if( rp->u_id != DBID_EXTR )  {
		bu_log("rt_extrude_import: defective record\n");
		return(-1);
	}

	RT_CK_DB_INTERNAL( ip );
	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_EXTRUDE;
	ip->idb_meth = &rt_functab[ID_EXTRUDE];
	ip->idb_ptr = bu_malloc( sizeof(struct rt_extrude_internal), "rt_extrude_internal");
	extrude_ip = (struct rt_extrude_internal *)ip->idb_ptr;
	extrude_ip->magic = RT_EXTRUDE_INTERNAL_MAGIC;

	sketch_name = (char *)rp + sizeof( struct extr_rec );
	if( !dbip )
		extrude_ip->skt = (struct rt_sketch_internal *)NULL;
	else if( (dp=db_lookup( dbip, sketch_name, LOOKUP_NOISY)) == DIR_NULL )
	{
		bu_log( "rt_extrude_import: ERROR: Cannot find sketch (%.16s) for extrusion (%.16s)\n",
			sketch_name, rp->extr.ex_name );
		extrude_ip->skt = (struct rt_sketch_internal *)NULL;
	}
	else
	{
		if( rt_db_get_internal( &tmp_ip, dp, dbip, bn_mat_identity, resp ) != ID_SKETCH )
		{
			bu_log( "rt_extrude_import: ERROR: Cannot import sketch (%.16s) for extrusion (%.16s)\n",
				sketch_name, rp->extr.ex_name );
			bu_free( ip->idb_ptr, "extrusion" );
			return( -1 );
		}
		else
			extrude_ip->skt = (struct rt_sketch_internal *)tmp_ip.idb_ptr;
	}

	ntohd( (unsigned char *)tmp_vec, rp->extr.ex_V, ELEMENTS_PER_VECT );
	MAT4X3PNT( extrude_ip->V, mat, tmp_vec );
	ntohd( (unsigned char *)tmp_vec, rp->extr.ex_h, ELEMENTS_PER_VECT );
	MAT4X3VEC( extrude_ip->h, mat, tmp_vec );
	ntohd( (unsigned char *)tmp_vec, rp->extr.ex_uvec, ELEMENTS_PER_VECT );
	MAT4X3VEC( extrude_ip->u_vec, mat, tmp_vec );
	ntohd( (unsigned char *)tmp_vec, rp->extr.ex_vvec, ELEMENTS_PER_VECT );
	MAT4X3VEC( extrude_ip->v_vec, mat, tmp_vec );
	extrude_ip->keypoint = bu_glong( rp->extr.ex_key );

	ptr = (char *)rp;
	ptr += sizeof( struct extr_rec );
	extrude_ip->sketch_name = (char *)bu_calloc( 17, sizeof( char ), "Extrude sketch name" );
	strncpy( extrude_ip->sketch_name, ptr, 16 );

	return(0);			/* OK */
}

/*
 *			R T _ E X T R U D E _ E X P O R T
 *
 *  The name is added by the caller, in the usual place.
 */
int
rt_extrude_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
{
	struct rt_extrude_internal	*extrude_ip;
	vect_t				tmp_vec;
	union record			*rec;
	unsigned char			*ptr;

	RT_CK_DB_INTERNAL(ip);
	if( ip->idb_type != ID_EXTRUDE )  return(-1);
	extrude_ip = (struct rt_extrude_internal *)ip->idb_ptr;
	RT_EXTRUDE_CK_MAGIC(extrude_ip);

	BU_CK_EXTERNAL(ep);
	ep->ext_nbytes = 2*sizeof( union record );
	ep->ext_buf = (genptr_t)bu_calloc( 1, ep->ext_nbytes, "extrusion external");
	rec = (union record *)ep->ext_buf;

	rec->extr.ex_id = DBID_EXTR;

	VSCALE( tmp_vec, extrude_ip->V, local2mm );
	htond( rec->extr.ex_V, (unsigned char *)tmp_vec, ELEMENTS_PER_VECT );
	VSCALE( tmp_vec, extrude_ip->h, local2mm );
	htond( rec->extr.ex_h, (unsigned char *)tmp_vec, ELEMENTS_PER_VECT );
	VSCALE( tmp_vec, extrude_ip->u_vec, local2mm );
	htond( rec->extr.ex_uvec, (unsigned char *)tmp_vec, ELEMENTS_PER_VECT );
	VSCALE( tmp_vec, extrude_ip->v_vec, local2mm );
	htond( rec->extr.ex_vvec, (unsigned char *)tmp_vec, ELEMENTS_PER_VECT );
	bu_plong( rec->extr.ex_key, extrude_ip->keypoint );
	bu_plong( rec->extr.ex_count, 1 );

	ptr = (unsigned char *)rec;
	ptr += sizeof( struct extr_rec );

	strcpy( (char *)ptr, extrude_ip->sketch_name );

	return(0);
}


/*
 *			R T _ E X T R U D E _ E X P O R T 5
 *
 *  The name is added by the caller, in the usual place.
 */
int
rt_extrude_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
{
	struct rt_extrude_internal	*extrude_ip;
	vect_t				tmp_vec[4];
	unsigned char			*ptr;

	RT_CK_DB_INTERNAL(ip);
	if( ip->idb_type != ID_EXTRUDE )  return(-1);

	extrude_ip = (struct rt_extrude_internal *)ip->idb_ptr;
	RT_EXTRUDE_CK_MAGIC(extrude_ip);

	BU_CK_EXTERNAL(ep);
	ep->ext_nbytes = 4 * ELEMENTS_PER_VECT * SIZEOF_NETWORK_DOUBLE + SIZEOF_NETWORK_LONG + strlen( extrude_ip->sketch_name ) + 1;
	ep->ext_buf = (genptr_t)bu_calloc( 1, ep->ext_nbytes, "extrusion external");
	ptr = (unsigned char *)ep->ext_buf;

	VSCALE( tmp_vec[0], extrude_ip->V, local2mm );
	VSCALE( tmp_vec[1], extrude_ip->h, local2mm );
	VSCALE( tmp_vec[2], extrude_ip->u_vec, local2mm );
	VSCALE( tmp_vec[3], extrude_ip->v_vec, local2mm );
	htond( ptr, (unsigned char *)tmp_vec, ELEMENTS_PER_VECT*4 );
	ptr += ELEMENTS_PER_VECT * 4 * SIZEOF_NETWORK_DOUBLE;
	bu_plong( ptr, extrude_ip->keypoint );
	ptr += SIZEOF_NETWORK_LONG;
	strcpy( (char *)ptr, extrude_ip->sketch_name );

	return(0);
}


/*
 *			R T _ E X T R U D E _ I M P O R T 5
 *
 *  Import an EXTRUDE from the database format to the internal format.
 *  Apply modeling transformations as well.
 */
int
rt_extrude_import5(
	struct rt_db_internal		*ip,
	const struct bu_external	*ep,
	register const mat_t		mat,
	const struct db_i		*dbip,
	struct resource			*resp,
	const int			minor_type )
{
	LOCAL struct rt_extrude_internal	*extrude_ip;
	struct rt_db_internal			tmp_ip;
	struct directory			*dp;
	char					*sketch_name;
	unsigned char				*ptr;
	point_t					tmp_vec[4];

	BU_CK_EXTERNAL( ep );

	RT_CK_DB_INTERNAL( ip );
	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_EXTRUDE;
	ip->idb_meth = &rt_functab[ID_EXTRUDE];
	ip->idb_ptr = bu_malloc( sizeof(struct rt_extrude_internal), "rt_extrude_internal");
	extrude_ip = (struct rt_extrude_internal *)ip->idb_ptr;
	extrude_ip->magic = RT_EXTRUDE_INTERNAL_MAGIC;

	ptr = (unsigned char *)ep->ext_buf;
	sketch_name = (char *)ptr + ELEMENTS_PER_VECT*4*SIZEOF_NETWORK_DOUBLE + SIZEOF_NETWORK_LONG;
	if( !dbip )
		extrude_ip->skt = (struct rt_sketch_internal *)NULL;
	else if( (dp=db_lookup( dbip, sketch_name, LOOKUP_NOISY)) == DIR_NULL )
	{
		bu_log( "rt_extrude_import: ERROR: Cannot find sketch (%s) for extrusion\n",
			sketch_name );
		extrude_ip->skt = (struct rt_sketch_internal *)NULL;
	}
	else
	{
		if( rt_db_get_internal( &tmp_ip, dp, dbip, bn_mat_identity, resp ) != ID_SKETCH )
		{
			bu_log( "rt_extrude_import: ERROR: Cannot import sketch (%s) for extrusion\n",
				sketch_name );
			bu_free( ip->idb_ptr, "extrusion" );
			return( -1 );
		}
		else
			extrude_ip->skt = (struct rt_sketch_internal *)tmp_ip.idb_ptr;
	}

	ntohd( (unsigned char *)tmp_vec, ptr, ELEMENTS_PER_VECT*4 );
	MAT4X3PNT( extrude_ip->V, mat, tmp_vec[0] );
	MAT4X3VEC( extrude_ip->h, mat, tmp_vec[1] );
	MAT4X3VEC( extrude_ip->u_vec, mat, tmp_vec[2] );
	MAT4X3VEC( extrude_ip->v_vec, mat, tmp_vec[3] );
	ptr += ELEMENTS_PER_VECT * 4 * SIZEOF_NETWORK_DOUBLE;
	extrude_ip->keypoint = bu_glong( ptr );
	ptr += SIZEOF_NETWORK_LONG;
	extrude_ip->sketch_name = bu_strdup( (const char *)ptr );

	return(0);			/* OK */
}

/*
 *			R T _ E X T R U D E _ D E S C R I B E
 *
 *  Make human-readable formatted presentation of this solid.
 *  First line describes type of solid.
 *  Additional lines are indented one tab, and give parameter values.
 */
int
rt_extrude_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
{
	register struct rt_extrude_internal	*extrude_ip =
		(struct rt_extrude_internal *)ip->idb_ptr;
	char	buf[256];
	point_t V;
	vect_t h, u, v;

	RT_EXTRUDE_CK_MAGIC(extrude_ip);
	bu_vls_strcat( str, "2D extrude (EXTRUDE)\n");
	VSCALE( V, extrude_ip->V, mm2local );
	VSCALE( h, extrude_ip->h, mm2local );
	VSCALE( u, extrude_ip->u_vec, mm2local );
	VSCALE( v, extrude_ip->v_vec, mm2local );
	sprintf( buf, "\tV = (%g %g %g)\n\tH = (%g %g %g)\n\tu_dir = (%g %g %g)\n\tv_dir = (%g %g %g)\n",
		V3ARGS( V ),
		V3ARGS( h ),
		V3ARGS( u ),
		V3ARGS( v ) );
	bu_vls_strcat( str, buf );
	sprintf( buf, "\tsketch name: %s\n",
		extrude_ip->sketch_name );
	bu_vls_strcat( str, buf );
	

	return(0);
}

/*
 *			R T _ E X T R U D E _ I F R E E
 *
 *  Free the storage associated with the rt_db_internal version of this solid.
 */
void
rt_extrude_ifree(struct rt_db_internal *ip)
{
	register struct rt_extrude_internal	*extrude_ip;
	struct rt_db_internal			tmp_ip;

	RT_CK_DB_INTERNAL(ip);
	extrude_ip = (struct rt_extrude_internal *)ip->idb_ptr;
	RT_EXTRUDE_CK_MAGIC(extrude_ip);
	if( extrude_ip->skt )
	{
		RT_INIT_DB_INTERNAL( &tmp_ip );
		tmp_ip.idb_major_type = DB5_MAJORTYPE_BRLCAD;
		tmp_ip.idb_type = ID_SKETCH;
		tmp_ip.idb_ptr = (genptr_t)extrude_ip->skt;
		tmp_ip.idb_meth = &rt_functab[ID_SKETCH];
		rt_sketch_ifree( &tmp_ip );
	}
	extrude_ip->magic = 0;			/* sanity */

	bu_free( extrude_ip->sketch_name, "Extrude sketch_name" );
	bu_free( (char *)extrude_ip, "extrude ifree" );
	ip->idb_ptr = GENPTR_NULL;	/* sanity */
}

int
rt_extrude_xform(
	struct rt_db_internal *op,
	const mat_t mat,
	struct rt_db_internal *ip,
	int free,
	struct db_i *dbip,
	struct resource *resp)
{
	struct rt_extrude_internal	*eip, *eop;
	point_t tmp_vec;

	RT_CK_DB_INTERNAL( ip );
	RT_CK_RESOURCE(resp)
	eip = (struct rt_extrude_internal *)ip->idb_ptr;
	RT_EXTRUDE_CK_MAGIC( eip );

	if( bu_debug&BU_DEBUG_MEM_CHECK )
	{
		bu_log( "Barrier check at start of extrude_xform():\n" );
		bu_mem_barriercheck();
	}

	if( op != ip )
	{
		RT_INIT_DB_INTERNAL( op );
		eop = (struct rt_extrude_internal *)bu_malloc( sizeof( struct rt_extrude_internal ), "eop" );
		eop->magic = RT_EXTRUDE_INTERNAL_MAGIC;
		eop->sketch_name = bu_strdup( eip->sketch_name );
		op->idb_ptr = (genptr_t)eop;
		op->idb_meth = &rt_functab[ID_EXTRUDE];
		op->idb_major_type = DB5_MAJORTYPE_BRLCAD;
		op->idb_type = ID_EXTRUDE;
		if( ip->idb_avs.magic == BU_AVS_MAGIC ) {
			bu_avs_init( &op->idb_avs, ip->idb_avs.count, "avs" );
			bu_avs_merge( &op->idb_avs, &ip->idb_avs );
		}
	}
	else
		eop = (struct rt_extrude_internal *)ip->idb_ptr;

	MAT4X3PNT( tmp_vec, mat, eip->V );
	VMOVE( eop->V, tmp_vec );
	MAT4X3VEC( tmp_vec, mat, eip->h );
	VMOVE( eop->h, tmp_vec );
	MAT4X3VEC( tmp_vec, mat, eip->u_vec );
	VMOVE( eop->u_vec, tmp_vec );
	MAT4X3VEC( tmp_vec, mat, eip->v_vec );
	VMOVE( eop->v_vec, tmp_vec );
	eop->keypoint = eip->keypoint;

	if( free && ip != op )
	{
		eop->skt = eip->skt;
		eip->skt = (struct rt_sketch_internal *)NULL;
		rt_db_free_internal( ip, resp );
	}
	else if( eip->skt )
		eop->skt = rt_copy_sketch( eip->skt );
	else
		eop->skt = (struct rt_sketch_internal *)NULL;

	if( bu_debug&BU_DEBUG_MEM_CHECK )
	{
		bu_log( "Barrier check at end of extrude_xform():\n" );
		bu_mem_barriercheck();
	}

	return( 0 );		
}

int
rt_extrude_tclform( const struct rt_functab *ftp, Tcl_Interp *interp )
{
        RT_CK_FUNCTAB(ftp);

        Tcl_AppendResult( interp,
			  "V {%f %f %f} H {%f %f %f} A {%f %f %f} B {%f %f %f} S %s K %d", (char *)NULL );

        return TCL_OK;

}

int
rt_extrude_tclget(Tcl_Interp *interp, const struct rt_db_internal *intern, const char *attr)
{
	register struct rt_extrude_internal *extr=(struct rt_extrude_internal *) intern->idb_ptr;
        Tcl_DString     ds;
        struct bu_vls   vls;
	int ret=TCL_OK;

	RT_EXTRUDE_CK_MAGIC( extr );

	Tcl_DStringInit( &ds );
	bu_vls_init( &vls );


	if( attr == (char *)NULL )
	{
		bu_vls_strcpy( &vls, "extrude" );
		bu_vls_printf( &vls, " V {%.25g %.25g %.25g}", V3ARGS( extr->V ) );
		bu_vls_printf( &vls, " H {%.25g %.25g %.25g}", V3ARGS( extr->h ) );
		bu_vls_printf( &vls, " A {%.25g %.25g %.25g}", V3ARGS( extr->u_vec ) );
		bu_vls_printf( &vls, " B {%.25g %.25g %.25g}", V3ARGS( extr->v_vec ) );
		bu_vls_printf( &vls, " S %s", extr->sketch_name );
		bu_vls_printf( &vls, " K %d", extr->keypoint );
	}
	else if( *attr == 'V' )
		bu_vls_printf( &vls, "%.25g %.25g %.25g", V3ARGS( extr->V ) );
	else if( *attr == 'H' )
		bu_vls_printf( &vls, "%.25g %.25g %.25g", V3ARGS( extr->h ) );
	else if( *attr == 'A' )
		bu_vls_printf( &vls, "%.25g %.25g %.25g", V3ARGS( extr->u_vec ) );
	else if( *attr == 'B' )
		bu_vls_printf( &vls, "%.25g %.25g %.25g", V3ARGS( extr->v_vec ) );
	else if( *attr == 'S' )
		bu_vls_printf( &vls, "%s", extr->sketch_name );
	else if( *attr == 'K' )
		bu_vls_printf( &vls, "%d", extr->keypoint );
	else
	{
		bu_vls_strcat( &vls, "ERROR: unrecognized attribute, must be V, H, A, B, S, or K!!!" );
		ret = TCL_ERROR;
	}

        Tcl_DStringAppend( &ds, bu_vls_addr( &vls ), -1 );
        Tcl_DStringResult( interp, &ds );
        Tcl_DStringFree( &ds );
        bu_vls_free( &vls );
        return( ret );
}

int
rt_extrude_tcladjust(Tcl_Interp *interp, struct rt_db_internal *intern, int argc, char **argv)
{
        struct rt_extrude_internal *extr;
        fastf_t *new;
	fastf_t len;

        RT_CK_DB_INTERNAL( intern );
        extr = (struct rt_extrude_internal *)intern->idb_ptr;
        RT_EXTRUDE_CK_MAGIC( extr );

	while( argc >= 2 )
	{
		int array_len=3;

		if( *argv[0] == 'V' )
		{
			new = extr->V;
			if( tcl_list_to_fastf_array( interp, argv[1], &new, &array_len ) !=
			    array_len ) {
				Tcl_SetResult( interp,
				      "ERROR: incorrect number of coordinates for vertex\n",
				      TCL_STATIC );
				return( TCL_ERROR );
			}
		}
		else if( *argv[0] == 'H' )
		{
			new = extr->h;
			if( tcl_list_to_fastf_array( interp, argv[1], &new, &array_len ) !=
			    array_len ) {
				Tcl_SetResult( interp,
				      "ERROR: incorrect number of coordinates for vector\n",
				      TCL_STATIC );
				return( TCL_ERROR );
			}
		}
		else if( *argv[0] == 'A' )
		{
			new = extr->u_vec;
			if( tcl_list_to_fastf_array( interp, argv[1], &new, &array_len ) !=
			    array_len ) {
				Tcl_SetResult( interp,
				      "ERROR: incorrect number of coordinates for vector\n",
				      TCL_STATIC );
				return( TCL_ERROR );
			}

			/* insure that u_vec and v_vec are the same length */
			len = MAGNITUDE( extr->u_vec );
			VUNITIZE( extr->v_vec );
			VSCALE( extr->v_vec, extr->v_vec, len );
		}
		else if( *argv[0] == 'B' )
		{
			new = extr->v_vec;
			if( tcl_list_to_fastf_array( interp, argv[1], &new, &array_len ) !=
			    array_len ) {
				Tcl_SetResult( interp,
				      "ERROR: incorrect number of coordinates for vector\n",
				      TCL_STATIC );
				return( TCL_ERROR );
			}
			/* insure that u_vec and v_vec are the same length */
			len = MAGNITUDE( extr->v_vec );
			VUNITIZE( extr->u_vec );
			VSCALE( extr->u_vec, extr->u_vec, len );
		}
		else if( *argv[0] =='K' )
			extr->keypoint = atoi( argv[1] );
		else if( *argv[0] == 'S' ) {
			if( extr->sketch_name )
				bu_free( (char *)extr->sketch_name, "rt_extrude_tcladjust: sketch_name" );
			extr->sketch_name = bu_strdup( argv[1] );
		}

		argc -= 2;
		argv += 2;
	}

	return( TCL_OK );
}





@


1.61
log
@change conf.h to a wrapped config.h
@
text
@d41 1
a41 1
static const char RCSextrude[] = "@@(#)$Header: /cvs/brlcad/librt/g_extrude.c,v 1.60 2004/04/05 08:48:56 morrison Exp $ (BRL)";
@


1.60
log
@merge of ansi-6-0-branch into HEAD
@
text
@d41 1
a41 1
static const char RCSextrude[] = "@@(#)$Header$ (BRL)";
d44 5
a48 1
#include "conf.h"
@


1.59
log
@Corrected signature for rt_extrude_import5()
@
text
@d41 1
a41 1
static const char RCSextrude[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_extrude.c,v 1.58 2004/02/02 17:39:20 morrison Exp $ (BRL)";
d122 1
a122 4
rt_extrude_prep( stp, ip, rtip )
struct soltab		*stp;
struct rt_db_internal	*ip;
struct rt_i		*rtip;
d358 1
a358 2
rt_extrude_print( stp )
register const struct soltab *stp;
d363 1
a363 4
get_quadrant( v, local_x, local_y, vx, vy )
vect_t local_x, local_y;
point2d_t v;
fastf_t *vx, *vy;
d386 1
a386 4
isect_line2_ellipse( dist, ray_start, ray_dir, center, ra, rb )
fastf_t dist[2];
point_t ray_start, center;
vect_t ray_dir, ra, rb;
d434 7
a440 7
isect_line_earc( dist, ray_start, ray_dir, center, ra, rb, norm, start, end, orientation )
fastf_t dist[2];
point_t ray_start;
vect_t ray_dir;
point_t center, start, end;
vect_t ra, rb, norm;
int orientation;	/* 0 -> ccw, !0 -> cw */
d604 1
a604 5
rt_extrude_shot( stp, rp, ap, seghead )
struct soltab		*stp;
register struct xray	*rp;
struct application	*ap;
struct seg		*seghead;
d1035 6
a1040 6
rt_extrude_vshot( stp, rp, segp, n, ap )
struct soltab	       *stp[]; /* An array of solid pointers */
struct xray		*rp[]; /* An array of ray pointers */
struct  seg            segp[]; /* array of segs (results returned) */
int		  	    n; /* Number of ray/object pairs */
struct application	*ap;
d1051 1
a1051 4
rt_extrude_norm( hitp, stp, rp )
register struct hit	*hitp;
struct soltab		*stp;
register struct xray	*rp;
d1114 1
a1114 4
rt_extrude_curve( cvp, hitp, stp )
register struct curvature *cvp;
register struct hit	*hitp;
struct soltab		*stp;
d1174 1
a1174 5
rt_extrude_uv( ap, stp, hitp, uvp )
struct application	*ap;
struct soltab		*stp;
register struct hit	*hitp;
register struct uvcoord	*uvp;
d1182 1
a1182 2
rt_extrude_free( stp )
register struct soltab *stp;
d1197 1
a1197 1
rt_extrude_class()
d1206 1
a1206 5
rt_extrude_plot( vhead, ip, ttol, tol )
struct bu_list		*vhead;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol	*tol;
d1826 1
a1826 6
rt_extrude_tess( r, m, ip, ttol, tol )
struct nmgregion	**r;
struct model		*m;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol	*tol;
d2140 1
a2140 6
rt_extrude_import( ip, ep, mat, dbip, resp )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
struct resource			*resp;
d2212 1
a2212 5
rt_extrude_export( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d2257 1
a2257 5
rt_extrude_export5( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d2364 1
a2364 5
rt_extrude_describe( str, ip, verbose, mm2local )
struct bu_vls		*str;
const struct rt_db_internal	*ip;
int			verbose;
double			mm2local;
d2398 1
a2398 2
rt_extrude_ifree( ip )
struct rt_db_internal	*ip;
d2506 1
a2506 4
rt_extrude_tclget( interp, intern, attr )
Tcl_Interp                      *interp;
const struct rt_db_internal     *intern;
const char                      *attr;
d2555 1
a2555 5
rt_extrude_tcladjust( interp, intern, argc, argv )
Tcl_Interp              *interp;
struct rt_db_internal   *intern;
int                     argc;
char                    **argv;
@


1.58
log
@update copyright to include span through 2003
@
text
@d41 1
a41 1
static const char RCSextrude[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_extrude.c,v 1.57 2003/09/10 13:11:39 jra Exp $ (BRL)";
d2347 2
a2348 1
	struct resource			*resp)
@


1.57
log
@Corrected a memory leak in rt_extrude_xform()
@
text
@d37 1
a37 1
 *	This software is Copyright (C) 1990 by the United States Army.
d41 1
a41 1
static const char RCSextrude[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_extrude.c,v 1.56 2003/09/10 00:31:41 jra Exp $ (BRL)";
@


1.57.4.1
log
@merge from HEAD
@
text
@d37 1
a37 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d41 1
a41 1
static const char RCSextrude[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_extrude.c,v 1.59 2004/02/03 21:45:26 jra Exp $ (BRL)";
d2347 1
a2347 2
	struct resource			*resp,
	const int			minor_type )
@


1.57.4.2
log
@merge from head
@
text
@d41 1
a41 1
static const char RCSextrude[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_extrude.c,v 1.57.4.1 2004/02/12 18:37:40 erikg Exp $ (BRL)";
@


1.56
log
@xform routines now handle attributes
@
text
@d41 1
a41 1
static const char RCSextrude[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_extrude.c,v 1.55 2002/09/26 20:42:46 jra Exp $ (BRL)";
d2501 1
a2522 1
	eop->sketch_name = bu_strdup( eip->sketch_name );
@


1.55
log
@Eliminated an unused variable
@
text
@d41 1
a41 1
static const char RCSextrude[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_extrude.c,v 1.54 2002/08/20 17:07:59 jra Exp $ (BRL)";
d2505 4
@


1.54
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d41 1
a41 1
static const char RCSextrude[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_extrude.c,v 1.52 2001/10/23 13:53:47 jra Exp $ (BRL)";
a1783 1
	struct curve *crv;
a1791 2

	crv = &ip->skt_curve;
@


1.54.4.1
log
@sync to HEAD...
@
text
@d37 1
a37 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d41 1
a41 1
static const char RCSextrude[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/g_extrude.c,v 1.59 2004/02/03 21:45:26 jra Exp $ (BRL)";
d1784 1
d1794 2
d2350 1
a2350 2
	struct resource			*resp,
	const int			minor_type )
a2503 1
		eop->sketch_name = bu_strdup( eip->sketch_name );
a2507 4
		if( ip->idb_avs.magic == BU_AVS_MAGIC ) {
			bu_avs_init( &op->idb_avs, ip->idb_avs.count, "avs" );
			bu_avs_merge( &op->idb_avs, &ip->idb_avs );
		}
d2521 1
@


1.54.2.1
log
@Initial ANSIfication
@
text
@d41 1
a41 1
static const char RCSextrude[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_extrude.c,v 1.54 2002/08/20 17:07:59 jra Exp $ (BRL)";
d122 4
a125 1
rt_extrude_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
d361 2
a362 1
rt_extrude_print(register const struct soltab *stp)
d367 4
a370 1
get_quadrant(fastf_t *v, fastf_t *local_x, fastf_t *local_y, fastf_t *vx, fastf_t *vy)
d393 4
a396 1
isect_line2_ellipse(fastf_t *dist, fastf_t *ray_start, fastf_t *ray_dir, fastf_t *center, fastf_t *ra, fastf_t *rb)
d444 7
a450 7
isect_line_earc(fastf_t *dist, fastf_t *ray_start, fastf_t *ray_dir, fastf_t *center, fastf_t *ra, fastf_t *rb, fastf_t *norm, fastf_t *start, fastf_t *end, int orientation)
                
                  
               
                           
                    
                	/* 0 -> ccw, !0 -> cw */
d614 5
a618 1
rt_extrude_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
d1049 6
a1054 6
rt_extrude_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		  	       /* Number of ray/object pairs */
                  	    
d1065 4
a1068 1
rt_extrude_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
d1131 4
a1134 1
rt_extrude_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
d1194 5
a1198 1
rt_extrude_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
d1206 2
a1207 1
rt_extrude_free(register struct soltab *stp)
d1222 1
a1222 1
rt_extrude_class(void)
d1231 5
a1235 1
rt_extrude_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d1858 6
a1863 1
rt_extrude_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d2177 6
a2182 1
rt_extrude_import(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip, struct resource *resp)
d2254 5
a2258 1
rt_extrude_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d2303 5
a2307 1
rt_extrude_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d2413 5
a2417 1
rt_extrude_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
d2451 2
a2452 1
rt_extrude_ifree(struct rt_db_internal *ip)
d2556 4
a2559 1
rt_extrude_tclget(Tcl_Interp *interp, const struct rt_db_internal *intern, const char *attr)
d2608 5
a2612 1
rt_extrude_tcladjust(Tcl_Interp *interp, struct rt_db_internal *intern, int argc, char **argv)
@


1.54.2.2
log
@sync branch with HEAD
@
text
@d37 1
a37 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d41 1
a41 1
static const char RCSextrude[] = "@@(#)$Header$ (BRL)";
d1755 1
d1765 2
d2303 1
a2303 2
	struct resource			*resp,
	const int			minor_type )
a2451 1
		eop->sketch_name = bu_strdup( eip->sketch_name );
a2455 4
		if( ip->idb_avs.magic == BU_AVS_MAGIC ) {
			bu_avs_init( &op->idb_avs, ip->idb_avs.count, "avs" );
			bu_avs_merge( &op->idb_avs, &ip->idb_avs );
		}
d2469 1
@


1.53
log
@Converted from K&R to ANSI C - RFH
@
text
@d122 4
a125 1
rt_extrude_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
d361 2
a362 1
rt_extrude_print(register const struct soltab *stp)
d367 4
a370 1
get_quadrant(fastf_t *v, fastf_t *local_x, fastf_t *local_y, fastf_t *vx, fastf_t *vy)
d393 4
a396 1
isect_line2_ellipse(fastf_t *dist, fastf_t *ray_start, fastf_t *ray_dir, fastf_t *center, fastf_t *ra, fastf_t *rb)
d444 7
a450 7
isect_line_earc(fastf_t *dist, fastf_t *ray_start, fastf_t *ray_dir, fastf_t *center, fastf_t *ra, fastf_t *rb, fastf_t *norm, fastf_t *start, fastf_t *end, int orientation)
                
                  
               
                           
                    
                	/* 0 -> ccw, !0 -> cw */
d614 5
a618 1
rt_extrude_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
d1049 6
a1054 6
rt_extrude_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		  	       /* Number of ray/object pairs */
                  	    
d1065 4
a1068 1
rt_extrude_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
d1131 4
a1134 1
rt_extrude_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
d1194 5
a1198 1
rt_extrude_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
d1206 2
a1207 1
rt_extrude_free(register struct soltab *stp)
d1222 1
a1222 1
rt_extrude_class(void)
d1231 5
a1235 1
rt_extrude_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d1858 6
a1863 1
rt_extrude_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d2177 6
a2182 1
rt_extrude_import(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip, struct resource *resp)
d2254 5
a2258 1
rt_extrude_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d2303 5
a2307 1
rt_extrude_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d2413 5
a2417 1
rt_extrude_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
d2451 2
a2452 1
rt_extrude_ifree(struct rt_db_internal *ip)
d2556 4
a2559 1
rt_extrude_tclget(Tcl_Interp *interp, const struct rt_db_internal *intern, const char *attr)
d2608 5
a2612 1
rt_extrude_tcladjust(Tcl_Interp *interp, struct rt_db_internal *intern, int argc, char **argv)
@


1.52
log
@Single hits are ignored
@
text
@d41 1
a41 1
static const char RCSextrude[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_extrude.c,v 1.51 2001/10/19 03:44:51 jra Exp $ (BRL)";
d122 1
a122 4
rt_extrude_prep( stp, ip, rtip )
struct soltab		*stp;
struct rt_db_internal	*ip;
struct rt_i		*rtip;
d358 1
a358 2
rt_extrude_print( stp )
register const struct soltab *stp;
d363 1
a363 4
get_quadrant( v, local_x, local_y, vx, vy )
vect_t local_x, local_y;
point2d_t v;
fastf_t *vx, *vy;
d386 1
a386 4
isect_line2_ellipse( dist, ray_start, ray_dir, center, ra, rb )
fastf_t dist[2];
point_t ray_start, center;
vect_t ray_dir, ra, rb;
d434 7
a440 7
isect_line_earc( dist, ray_start, ray_dir, center, ra, rb, norm, start, end, orientation )
fastf_t dist[2];
point_t ray_start;
vect_t ray_dir;
point_t center, start, end;
vect_t ra, rb, norm;
int orientation;	/* 0 -> ccw, !0 -> cw */
d604 1
a604 5
rt_extrude_shot( stp, rp, ap, seghead )
struct soltab		*stp;
register struct xray	*rp;
struct application	*ap;
struct seg		*seghead;
d1035 6
a1040 6
rt_extrude_vshot( stp, rp, segp, n, ap )
struct soltab	       *stp[]; /* An array of solid pointers */
struct xray		*rp[]; /* An array of ray pointers */
struct  seg            segp[]; /* array of segs (results returned) */
int		  	    n; /* Number of ray/object pairs */
struct application	*ap;
d1051 1
a1051 4
rt_extrude_norm( hitp, stp, rp )
register struct hit	*hitp;
struct soltab		*stp;
register struct xray	*rp;
d1114 1
a1114 4
rt_extrude_curve( cvp, hitp, stp )
register struct curvature *cvp;
register struct hit	*hitp;
struct soltab		*stp;
d1174 1
a1174 5
rt_extrude_uv( ap, stp, hitp, uvp )
struct application	*ap;
struct soltab		*stp;
register struct hit	*hitp;
register struct uvcoord	*uvp;
d1182 1
a1182 2
rt_extrude_free( stp )
register struct soltab *stp;
d1197 1
a1197 1
rt_extrude_class()
d1206 1
a1206 5
rt_extrude_plot( vhead, ip, ttol, tol )
struct bu_list		*vhead;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol	*tol;
d1829 1
a1829 6
rt_extrude_tess( r, m, ip, ttol, tol )
struct nmgregion	**r;
struct model		*m;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol	*tol;
d2143 1
a2143 6
rt_extrude_import( ip, ep, mat, dbip, resp )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
struct resource			*resp;
d2215 1
a2215 5
rt_extrude_export( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d2260 1
a2260 5
rt_extrude_export5( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d2366 1
a2366 5
rt_extrude_describe( str, ip, verbose, mm2local )
struct bu_vls		*str;
const struct rt_db_internal	*ip;
int			verbose;
double			mm2local;
d2400 1
a2400 2
rt_extrude_ifree( ip )
struct rt_db_internal	*ip;
d2504 1
a2504 4
rt_extrude_tclget( interp, intern, attr )
Tcl_Interp                      *interp;
const struct rt_db_internal     *intern;
const char                      *attr;
d2553 1
a2553 5
rt_extrude_tcladjust( interp, intern, argc, argv )
Tcl_Interp              *interp;
struct rt_db_internal   *intern;
int                     argc;
char                    **argv;
@


1.51
log
@extrusion tessellator was not freeing some memory
@
text
@d41 1
a41 1
static const char RCSextrude[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_extrude.c,v 1.50 2001/10/02 19:24:29 jra Exp $ (BRL)";
d1014 7
a1020 5
		bu_log( "ERROR: rt_extrude_shot(): odd number of hits (%d) (ignoring last hit)\n", hit_count );
		bu_log( "ray start = (%20.10f %20.10f %20.10f)\n", V3ARGS( rp->r_pt ) );
		bu_log( "\tray dir = (%20.10f %20.10f %20.10f)", V3ARGS( rp->r_dir ) );
		VJOIN1( pt, rp->r_pt, hits[hit_count-1].hit_dist, rp->r_dir );
		bu_log( "\tignored hit at (%g %g %g)\n", V3ARGS( pt ) );
@


1.50
log
@Routines were not setting idb_major_type in the internal structure
@
text
@d41 1
a41 1
static const char RCSextrude[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_extrude.c,v 1.49 2001/09/27 00:33:56 jra Exp $ (BRL)";
d1470 1
a1470 1
			Bezier( V, bsg->degree, 0.5, NULL, NULL, pt, NULL );
d2143 1
@


1.49
log
@corrected bug in isect_2D_loop_ray() for arcs and fixed some lint
@
text
@d41 1
a41 1
static const char RCSextrude[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_extrude.c,v 1.48 2001/09/26 20:49:45 jra Exp $ (BRL)";
d2198 1
d2359 1
d2460 1
d2503 1
@


1.48
log
@Extrusion now has tesselation support
@
text
@d41 1
a41 1
static const char RCSextrude[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_extrude.c,v 1.47 2001/08/22 15:09:38 jra Exp $ (BRL)";
d63 3
d1588 1
d1619 1
d1655 5
a1659 1
					code = isect_line_earc( dist, pta, dir, center2d, csg->radius, csg->radius,
a1783 2
	long *lng;
	int i;
a1784 2
	fastf_t dist[2];
	int code;
d1875 1
a1875 1
	struct bu_ptbl			*aloop, loops, **containing_loops, *outer_loop;
@


1.47
log
@switched to using bu_strdup() instead of strdup() in import5 routine
@
text
@d41 1
a41 1
static const char RCSextrude[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_extrude.c,v 1.46 2001/08/10 19:51:09 rbowers Exp $ (BRL)";
d94 9
d1309 534
d1858 302
a2159 1
	return(-1);
@


1.46
log
@
-* changed a VDOT to V2DOT to eliminate a subscript out of range warning.
@
text
@d41 1
a41 1
static const char RCSextrude[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_extrude.c,v 1.45 2001/06/26 18:17:31 jra Exp $ (BRL)";
d1546 1
a1546 1
	extrude_ip->sketch_name = strdup( (const char *)ptr );
@


1.45
log
@tcladjust() now enforces the rule that u_vec and v_vec must be of equal length
@
text
@d41 1
a41 1
static const char RCSextrude[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_extrude.c,v 1.44 2001/06/26 18:01:06 jra Exp $ (BRL)";
d772 1
a772 1
						dists[j] = VDOT( to_pt, ray_dir_unit) / diff;
@


1.44
log
@Prep() and shot() routines were having problems if u_vec or v_vec were
not unit length. Now uses length of u_vec to scale arc radii (still
requires u_vec and v_vec to be the same length)
@
text
@d41 1
a41 1
static const char RCSextrude[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_extrude.c,v 1.43 2001/06/21 18:07:25 jra Exp $ (BRL)";
d1760 1
d1802 5
d1818 4
@


1.43
log
@Continueing to add tcladjust and tclget support
@
text
@d41 1
a41 1
static const char RCSextrude[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_extrude.c,v 1.42 2001/04/27 12:48:09 jra Exp $ (BRL)";
d68 1
d143 5
d255 1
a255 1
		if( csg->radius <= 0.0 )
d280 1
a280 1
		else
d295 2
a296 1
			if( magsq_s2m > csg->radius*csg->radius )
d301 2
a302 2
				if( NEAR_ZERO( max_radius - csg->radius, RT_LEN_TOL ) )
					csg->radius = max_radius;
d306 1
a306 1
							stp->st_dp->d_namep, csg->radius, sqrt(magsq_s2m)  );
d311 1
a311 1
			dist = sqrt( csg->radius*csg->radius - magsq_s2m );
d323 1
a323 1
				tmp_f = csg->radius * ldir[j];
d728 3
a730 1
						/* build the ellipse */
@


1.42
log
@Needed to include nurb.h
@
text
@d41 1
a41 1
static const char RCSextrude[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_extrude.c,v 1.41 2001/04/27 12:45:39 jra Exp $ (BRL)";
a1749 1
        int ret;
d1763 7
a1769 2
			if( (ret=tcl_list_to_fastf_array( interp, argv[1], &new, &array_len ) ) )
				return( ret );
d1774 7
a1780 2
			if( (ret=tcl_list_to_fastf_array( interp, argv[1], &new, &array_len ) ) )
				return( ret );
d1785 7
a1791 2
			if( (ret=tcl_list_to_fastf_array( interp, argv[1], &new, &array_len ) ) )
				return( ret );
d1796 7
a1802 2
			if( (ret=tcl_list_to_fastf_array( interp, argv[1], &new, &array_len ) ) )
				return( ret );
d1818 5
@


1.41
log
@Initial support for raytracing extrusions with Bezier curve segments
@
text
@d41 1
a41 1
static const char RCSextrude[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_extrude.c,v 1.40 2001/04/25 12:45:57 jra Exp $ (BRL)";
d60 1
@


1.40
log
@the "sketch_name" field of the internal form of extrusion is now a malloced string
@
text
@d41 1
a41 1
static const char RCSextrude[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_extrude.c,v 1.39 2001/04/20 22:29:44 morrison Exp $ (BRL)";
a61 1

d90 1
d606 1
a606 1
	point_t ray_start, ray_dir;	/* 2D */
d620 4
d687 1
d690 1
a690 3
		if( free_dists )
			bu_free( (char *)dists, "dists" );

a705 1
				free_dists = 0;
a738 1
				free_dists = 0;
d741 28
d778 1
d788 1
a788 1
					for( n=k ; n<dist_count-1 ; n++ )
d790 4
d800 2
d812 1
a812 1
					for( n=k ; n<dist_count-1 ; n++ )
d814 4
d824 2
d845 1
a845 1

d856 1
d904 4
d916 2
a919 3
	if( free_dists )
		bu_free( (char *)dists, "dists" );

d990 2
d994 3
a996 1
		bu_log( "ray dir = (%20.10f %20.10f %20.10f)", V3ARGS( rp->r_dir ) );
d1077 5
@


1.39
log
@CONST to const
@
text
@d41 1
a41 1
static const char RCSextrude[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_extrude.c,v 1.38 2001/04/13 15:13:29 jra Exp $ (BRL)";
d1731 5
a1735 2
		else if( *argv[0] == 'S' )
			NAMEMOVE( argv[1], extr->sketch_name );
@


1.38
log
@Added tclform for cline and extrude solids
@
text
@d41 1
a41 1
static const char RCSextrude[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_extrude.c,v 1.37 2001/03/19 22:19:58 butler Exp $ (BRL)";
d342 1
a342 1
register CONST struct soltab *stp;
d1155 2
a1156 2
CONST struct rt_tess_tol *ttol;
CONST struct bn_tol	*tol;
d1247 2
a1248 2
CONST struct rt_tess_tol *ttol;
CONST struct bn_tol	*tol;
d1262 3
a1264 3
CONST struct bu_external	*ep;
register CONST mat_t		mat;
CONST struct db_i		*dbip;
d1338 1
a1338 1
CONST struct rt_db_internal	*ip;
d1340 1
a1340 1
CONST struct db_i		*dbip;
d1387 1
a1387 1
CONST struct rt_db_internal	*ip;
d1389 1
a1389 1
CONST struct db_i		*dbip;
d1429 3
a1431 3
	CONST struct bu_external	*ep,
	register CONST mat_t		mat,
	CONST struct db_i		*dbip,
d1496 1
a1496 1
CONST struct rt_db_internal	*ip;
d1637 2
a1638 2
CONST struct rt_db_internal     *intern;
CONST char                      *attr;
@


1.37
log
@patches to merge 5.3 into 6.0
@
text
@d41 1
a41 1
static const char RCSextrude[] = "@@(#)$Header: /d/CVS/brlcad/librt/g_extrude.c,v 1.36 2001/02/05 16:25:29 jra Exp $ (BRL)";
d1620 12
@


1.36
log
@Extrusion now must bu_strdup() its sketch name (long names allowed)
@
text
@d41 1
a41 1
static const char RCSextrude[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_extrude.c,v 1.35 2000/12/05 15:12:27 jra Exp $ (BRL)";
d121 1
a121 1
	
d176 1
a176 1
	/* apply the rotation matrix  to all the vertices */
d394 3
d398 1
a407 1

d411 1
a411 1
	if( disc == 0.0 )
d581 1
d700 1
a757 1

@


1.35
log
@Corrected bounding box calculations and further improved processing for extrusions along z-axis
@
text
@d41 1
a41 1
static const char RCSextrude[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_extrude.c,v 1.34 2000/11/16 21:27:38 jra Exp $ (BRL)";
d1577 1
a1577 1
		RT_CK_DB_INTERNAL( op );
d1596 1
a1596 1
	strncpy( eop->sketch_name, eip->sketch_name, 16 );
@


1.34
log
@Fixed a bug for extrusions along the z-axis
@
text
@d41 1
a41 1
static const char RCSextrude[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_extrude.c,v 1.33 2000/09/08 05:54:41 mike Exp $ (BRL)";
d116 3
a118 3
	LOCAL vect_t tmp, tmp2;
	fastf_t tmp_f;
	int i;
a152 26
	tmp_f = VDOT( tmp, extr->unit_h );
	if( tmp_f < 0.0 )
		tmp_f = -tmp_f;
	tmp_f -= 1.0;
	if( NEAR_ZERO( tmp_f, SQRT_SMALL_FASTF ) )
	{
		VSET( extr->rot_axis, 1.0, 0.0, 0.0 );
		VSET( extr->perp, 0.0, 1.0, 0.0 );
	}
	else
	{
		VCROSS( extr->rot_axis, tmp, extr->unit_h );
		VUNITIZE( extr->rot_axis );
		if( MAGNITUDE( extr->rot_axis ) < SQRT_SMALL_FASTF )
		{
			VSET( extr->rot_axis, 1.0, 0.0, 0.0 );
			VSET( extr->perp, 0.0, 1.0, 0.0 );
		}
		else
		{
			VCROSS( tmp2, tmp, extr->rot_axis );
			MAT4X3VEC( extr->perp, extr->rot, tmp2 );
			VUNITIZE( extr->perp );
		}
	}

d186 2
d200 26
d229 9
d259 13
a271 8
			VJOIN1( tmp, center, radius, eip->u_vec );
			VMINMAX( stp->st_min, stp->st_max, tmp );
			VJOIN1( tmp, center, -radius, eip->u_vec );
			VMINMAX( stp->st_min, stp->st_max, tmp );
			VJOIN1( tmp, center, radius, eip->v_vec );
			VMINMAX( stp->st_min, stp->st_max, tmp );
			VJOIN1( tmp, center, -radius, eip->v_vec );
			VMINMAX( stp->st_min, stp->st_max, tmp );
d288 1
a288 1
			if( magsq_s2m >= csg->radius*csg->radius )
d290 12
a301 3
				bu_log( "Impossible radius for circular arc in extrusion (%s)!!!\n", 
						stp->st_dp->d_namep );
				return( -1 );
d314 12
a325 8
			VJOIN1( tmp, center, csg->radius, eip->u_vec );
			VMINMAX( stp->st_min, stp->st_max, tmp );
			VJOIN1( tmp, center, -csg->radius, eip->u_vec );
			VMINMAX( stp->st_min, stp->st_max, tmp );
			VJOIN1( tmp, center, csg->radius, eip->v_vec );
			VMINMAX( stp->st_min, stp->st_max, tmp );
			VJOIN1( tmp, center, -csg->radius, eip->v_vec );
			VMINMAX( stp->st_min, stp->st_max, tmp );
a328 4
	VADD2( tmp, stp->st_min, eip->h );
	VADD2( tmp2, stp->st_max, eip->h );
	VMINMAX( stp->st_min, stp->st_max, tmp );
	VMINMAX( stp->st_min, stp->st_max, tmp2 );
@


1.33
log
@
Modified tree routines to take resource pointer.
@
text
@d41 1
a41 1
static const char RCSextrude[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_extrude.c,v 1.32 2000/09/01 02:20:38 mike Exp $ (BRL)";
d166 11
a176 3
		VCROSS( tmp2, tmp, extr->rot_axis );
		MAT4X3VEC( extr->perp, extr->rot, tmp2 );
		VUNITIZE( extr->perp );
@


1.32
log
@
lint
@
text
@d41 1
a41 1
static const char RCSextrude[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_extrude.c,v 1.31 2000/08/21 02:02:30 butler Exp $ (BRL)";
d1223 1
a1223 1
rt_extrude_import( ip, ep, mat, dbip )
d1228 1
d1264 1
a1264 1
		if( rt_db_get_internal( &tmp_ip, dp, dbip, bn_mat_identity ) != ID_SKETCH )
d1390 6
a1395 5
rt_extrude_import5( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
CONST struct bu_external	*ep;
register CONST mat_t		mat;
CONST struct db_i		*dbip;
d1425 1
a1425 1
		if( rt_db_get_internal( &tmp_ip, dp, dbip, bn_mat_identity ) != ID_SKETCH )
d1520 7
a1526 6
rt_extrude_xform( op, mat, ip, free, dbip )
struct rt_db_internal *op;
CONST mat_t mat;
struct rt_db_internal *ip;
int free;
struct db_i *dbip;
d1532 1
d1569 1
a1569 1
		rt_db_free_internal( ip );
@


1.31
log
@Massive compilation warnings eliminated
@
text
@d41 1
a41 1
static const char RCSextrude[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_extrude.c,v 1.30 2000/07/21 19:42:30 jra Exp $ (BRL)";
d565 1
a565 1
	fastf_t dist_top, dist_bottom, to_bottom;
d574 2
a575 2
	fastf_t *dists;
	int dist_count;
d581 1
a581 1
	int surfno;
d645 1
a645 1
		struct carc_seg *csg;
@


1.30
log
@The RT_INIT_DB_INTERNAL() in rt_extrude_ifree() really does need to be an RT_INIT_DB_INTERNAL()
@
text
@d41 1
a41 1
static const char RCSextrude[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_extrude.c,v 1.29 2000/07/10 23:01:31 mike Exp $ (BRL)";
d58 1
a59 1
#include "rtgeom.h"
a61 2
/* From g_sketch.c */
BU_EXTERN( struct rt_sketch_internal *rt_copy_sketch, (CONST struct rt_sketch_internal *sketch_ip ) );
d118 1
a118 1
	int i, curve_no;
d340 48
a543 46
int
isect_line2_ellipse( dist, ray_start, ray_dir, center, ra, rb )
fastf_t dist[2];
point_t ray_start, center;
vect_t ray_dir, ra, rb;
{
	fastf_t a, b, c;
	point2d_t pmc;
	fastf_t pmcda, pmcdb;
	fastf_t ra_sq, rb_sq;
	fastf_t ra_4, rb_4;
	fastf_t dda, ddb;
	fastf_t disc;

	V2SUB2( pmc, ray_start, center );
	pmcda = V2DOT( pmc, ra );
	pmcdb = V2DOT( pmc, rb );
	ra_sq = V2DOT( ra, ra );
	ra_4 = ra_sq * ra_sq;
	rb_sq = V2DOT( rb, rb );
	rb_4 = rb_sq * rb_sq;
	if( ra_4 < SMALL_FASTF || rb_4 < SMALL_FASTF )
		bu_bomb( "ERROR: isect_line2_ellipse: semi-axis length is too small!!!\n" );

	dda = V2DOT( ray_dir, ra );
	ddb = V2DOT( ray_dir, rb );

	a = dda*dda/ra_4 + ddb*ddb/rb_4;
	b = 2.0 * (pmcda*dda/ra_4 + pmcdb*ddb/rb_4);
	c = pmcda*pmcda/ra_4 + pmcdb*pmcdb/rb_4 - 1.0;

	disc = b*b - 4.0*a*c;

	if( disc < 0.0 )
		return( 0 );

	if( disc == 0.0 )
	{
		dist[0] = -b/(2.0*a);
		return( 1 );
	}

	dist[0] = (-b - sqrt( disc )) / (2.0*a);
	dist[1] = (-b + sqrt( disc )) / (2.0*a);
	return( 2 );
}
d1098 1
a1098 1
	rt_curve_free( extrude->crv );
a1122 1
	int				curve_no;
@


1.29
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d41 1
a41 1
static const char RCSextrude[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_extrude.c,v 1.28 2000/06/30 15:57:51 mike Exp $ (BRL)";
d1505 1
a1505 1
		RT_CK_DB_INTERNAL( &tmp_ip );
@


1.28
log
@
Fixed lint.
Used manifest constants.
@
text
@d41 1
a41 1
static char RCSextrude[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_extrude.c,v 1.27 2000/06/30 15:38:03 mike Exp $ (BRL)";
@


1.27
log
@
export methods should not init the external structure, just check them.
@
text
@d41 1
a41 1
static char RCSextrude[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_extrude.c,v 1.26 2000/06/30 15:31:14 mike Exp $ (BRL)";
d1275 1
a1275 1
	ntohd( (unsigned char *)tmp_vec, rp->extr.ex_V, 3 );
d1277 1
a1277 1
	ntohd( (unsigned char *)tmp_vec, rp->extr.ex_h, 3 );
d1279 1
a1279 1
	ntohd( (unsigned char *)tmp_vec, rp->extr.ex_uvec, 3 );
d1281 1
a1281 1
	ntohd( (unsigned char *)tmp_vec, rp->extr.ex_vvec, 3 );
d1323 1
a1323 1
	htond( rec->extr.ex_V, (unsigned char *)tmp_vec, 3 );
d1325 1
a1325 1
	htond( rec->extr.ex_h, (unsigned char *)tmp_vec, 3 );
d1327 1
a1327 1
	htond( rec->extr.ex_uvec, (unsigned char *)tmp_vec, 3 );
d1329 1
a1329 1
	htond( rec->extr.ex_vvec, (unsigned char *)tmp_vec, 3 );
d1365 1
a1365 1
	ep->ext_nbytes = 4 * 3 * SIZEOF_NETWORK_DOUBLE + SIZEOF_NETWORK_LONG + strlen( extrude_ip->sketch_name ) + 1;
d1373 2
a1374 2
	htond( ptr, (unsigned char *)tmp_vec, 3*4 );
	ptr += 3 * 4 * SIZEOF_NETWORK_DOUBLE;
d1413 1
a1413 1
	sketch_name = (char *)ptr + 3*4*SIZEOF_NETWORK_DOUBLE + SIZEOF_NETWORK_LONG;
d1435 1
a1435 1
	ntohd( (unsigned char *)tmp_vec, ptr, 3*4 );
d1440 1
a1440 1
	ptr += 3 * 4 * SIZEOF_NETWORK_DOUBLE;
d1443 1
a1443 1
	extrude_ip->sketch_name = strdup( ptr );
@


1.26
log
@
The import/export and import5/export5 methods must NOT
re-initialize their rt_db_internal* pointer, they should just check it.
@
text
@d41 1
a41 1
static char RCSextrude[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_extrude.c,v 1.25 2000/06/29 20:21:00 jra Exp $ (BRL)";
d1315 1
a1315 1
	BU_INIT_EXTERNAL(ep);
d1364 1
a1364 1
	BU_INIT_EXTERNAL(ep);
@


1.25
log
@Added database v5 support
@
text
@d41 1
a41 1
static char RCSextrude[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_extrude.c,v 1.24 2000/06/29 15:53:25 mike Exp $ (BRL)";
d1246 1
a1246 1
	RT_INIT_DB_INTERNAL( ip );
d1405 1
a1405 1
	RT_INIT_DB_INTERNAL( ip );
d1505 1
a1505 1
		RT_INIT_DB_INTERNAL( &tmp_ip );
d1541 1
a1541 1
		RT_INIT_DB_INTERNAL( op );
@


1.24
log
@
rt_db_free_internal()
@
text
@d41 1
a41 1
static char RCSextrude[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_extrude.c,v 1.23 2000/05/11 21:22:35 mike Exp $ (BRL)";
d48 5
d1287 1
d1336 42
a1377 1
	strncpy( (char *)ptr, extrude_ip->sketch_name, 16 );
d1382 66
d1480 1
a1480 1
	sprintf( buf, "\tsketch name: %.16s\n",
d1513 1
@


1.23
log
@
Changed to use  rt_hitsort().
@
text
@d41 1
a41 1
static char RCSextrude[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_extrude.c,v 1.22 2000/03/28 21:59:05 mike Exp $ (BRL)";
d1452 1
a1452 2
		rt_functab[ip->idb_type].ft_ifree( ip );
		ip->idb_ptr = (genptr_t) 0;
@


1.23.2.1
log
@Fixed a bug for extrusions along z-axis
@
text
@d41 1
a41 1
static char RCSextrude[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_extrude.c,v 1.23 2000/05/11 21:22:35 mike Exp $ (BRL)";
d118 1
a118 1

d163 3
a165 11
		if( MAGNITUDE( extr->rot_axis ) < SQRT_SMALL_FASTF )
		{
			VSET( extr->rot_axis, 1.0, 0.0, 0.0 );
			VSET( extr->perp, 0.0, 1.0, 0.0 );
		}
		else
		{
			VCROSS( tmp2, tmp, extr->rot_axis );
			MAT4X3VEC( extr->perp, extr->rot, tmp2 );
			VUNITIZE( extr->perp );
		}
a514 2
	{
		bu_log( "ray (%g %g %g) -> (%g %g %g), semi-axes lengths = %g %g\n", V3ARGS( ray_start ), V3ARGS( ray_dir ), ra, rb );
a515 1
	}
@


1.23.2.2
log
@Corrected bounding box calculation
@
text
@d41 1
a41 1
static char RCSextrude[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_extrude.c,v 1.23.2.1 2000/11/16 21:22:35 jra Exp $ (BRL)";
d113 3
a115 3
	LOCAL vect_t tmp, tmp2, xyz[3];
	fastf_t tmp_f, ldir[3];
	int i, j, curve_no;
d150 26
d199 1
a199 1
	/* apply the rotation matrix to all the vertices, and start bounding box calculation */
a208 2
		VADD2( tmp, tmp, eip->h );
		VMINMAX( stp->st_min, stp->st_max, tmp );
a220 26
	VSET( tmp, 0, 0, 1 )
	tmp_f = VDOT( tmp, extr->unit_h );
	if( tmp_f < 0.0 )
		tmp_f = -tmp_f;
	tmp_f -= 1.0;
	if( NEAR_ZERO( tmp_f, SQRT_SMALL_FASTF ) )
	{
		VSET( extr->rot_axis, 1.0, 0.0, 0.0 );
		VSET( extr->perp, 0.0, 1.0, 0.0 );
	}
	else
	{
		VCROSS( extr->rot_axis, tmp, extr->unit_h );
		VUNITIZE( extr->rot_axis );
		if( MAGNITUDE( extr->rot_axis ) < SQRT_SMALL_FASTF )
		{
			VSET( extr->rot_axis, 1.0, 0.0, 0.0 );
			VSET( extr->perp, 0.0, 1.0, 0.0 );
		}
		else
		{
			VCROSS( extr->perp, extr->rot_axis, extr->pl1_rot );
			VUNITIZE( extr->perp );
		}
	}

a223 9
	VSET( xyz[X], 1, 0, 0 );
	VSET( xyz[Y], 0, 1, 0 );
	VSET( xyz[Z], 0, 0, 1 );

	for( i=X ; i<=Z ; i++ ) {
		VCROSS( tmp, extr->unit_h, xyz[i] );
		ldir[i] = MAGNITUDE( tmp );
	}

d245 8
a252 13

			for( j=X ; j<=Z ; j++ ) {
				tmp_f = radius * ldir[j];
				VJOIN1( tmp, center, tmp_f, xyz[j] );
				VMINMAX( stp->st_min, stp->st_max, tmp );
				VADD2( tmp, tmp, eip->h );
				VMINMAX( stp->st_min, stp->st_max, tmp );

				VJOIN1( tmp, center, -tmp_f, xyz[j] );
				VMINMAX( stp->st_min, stp->st_max, tmp );
				VADD2( tmp, tmp, eip->h );
				VMINMAX( stp->st_min, stp->st_max, tmp );
			}
d269 1
a269 1
			if( magsq_s2m > csg->radius*csg->radius )
d271 3
a273 12
				fastf_t max_radius;

				max_radius = sqrt( magsq_s2m );
				if( NEAR_ZERO( max_radius - csg->radius, RT_LEN_TOL ) )
					csg->radius = max_radius;
				else
				{
					bu_log( "Impossible radius for circular arc in extrusion (%s), is %g, cannot be more than %g!!!\n", 
							stp->st_dp->d_namep, csg->radius, sqrt(magsq_s2m)  );
					bu_log( "Difference is %g\n", max_radius - csg->radius );
					return( -1 );
				}
d286 8
a293 12
			for( j=X ; j<=Z ; j++ ) {
				tmp_f = csg->radius * ldir[j];
				VJOIN1( tmp, center, tmp_f, xyz[j] );
				VMINMAX( stp->st_min, stp->st_max, tmp );
				VADD2( tmp, tmp, eip->h );
				VMINMAX( stp->st_min, stp->st_max, tmp );

				VJOIN1( tmp, center, -tmp_f, xyz[j] );
				VMINMAX( stp->st_min, stp->st_max, tmp );
				VADD2( tmp, tmp, eip->h );
				VMINMAX( stp->st_min, stp->st_max, tmp );
			}
d297 4
d524 1
a524 2
		bu_log( "ray (%g %g %g) -> (%g %g %g), semi-axes  = (%g %g %g) and (%g %g %g), center = (%g %g %g)\n",
			V3ARGS( ray_start ), V3ARGS( ray_dir ), V3ARGS( ra ), V3ARGS( rb ), V3ARGS( center ) );
d540 1
a540 1
	if( disc <= SMALL_FASTF )
a668 1

d726 1
@


1.22
log
@
Fixed arguments
@
text
@d41 1
a41 1
static char RCSextrude[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_extrude.c,v 1.21 2000/03/16 13:39:27 jra Exp $ (BRL)";
d865 1
a865 14
		{
			register int j;
			LOCAL struct hit temp;

			for( i=0; i < hit_count-1; i++ )  {
				for( j=i+1; j < hit_count; j++ )  {
					if( hits[i].hit_dist <= hits[j].hit_dist )
						continue;
					temp = hits[j];		/* struct copy */
					hits[j] = hits[i];	/* struct copy */
					hits[i] = temp;		/* struct copy */
				}
			}
		}
@


1.21
log
@Sketch solid can only have one curve now
@
text
@d41 1
a41 1
static char RCSextrude[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_extrude.c,v 1.20 2000/03/03 21:29:08 jra Exp $ (BRL)";
d1418 1
a1418 1
rt_extrude_xform( op, mat, ip, free )
d1423 1
@


1.20
log
@Corrected tclget routines
@
text
@d41 1
a41 1
static char RCSextrude[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_extrude.c,v 1.19 2000/03/02 14:47:28 jra Exp $ (BRL)";
a123 18
	/* find referenced curve */
	curve_no = -1;
	for( i=0 ; i<skt->curve_count ; i++ )
	{
		if( !strcmp( skt->curves[i].crv_name, eip->curve_name ) )
		{
			curve_no = i;
			break;
		}
	}

	if( curve_no < 0 )
	{
		bu_log( "ERROR: rt_extrude_prep(): solid (%s) references non-existent curve (%s) in sketch (%s)\n",
			stp->st_dp->d_namep, eip->curve_name, eip->sketch_name );
		return( -1 );	/* failure */
	}

d125 1
a125 1
	if( rt_check_curve( &skt->curves[curve_no], skt, 1 ) )
d127 2
a128 2
		bu_log( "ERROR: referenced curve (%s) in sketch (%s) is bad!!!\n",
			eip->curve_name, eip->sketch_name );
d178 1
a178 1
	for( i=0 ; i<skt->curves[curve_no].seg_count ; i++ )
d180 1
a180 1
		struct carc_seg *csg=(struct carc_seg *)skt->curves[curve_no].segments[i];
d214 1
a214 1
	rt_copy_curve( &extr->crv, &skt->curves[curve_no] );
d217 1
a217 1
	for( i=0 ; i<skt->curves[curve_no].seg_count ; i++ )
d219 1
a219 1
		struct carc_seg *csg=(struct carc_seg *)skt->curves[curve_no].segments[i];
d263 2
a264 2
				bu_log( "Impossible radius for circular arc (%s) in extrusion (%s)!!!\n", 
						extr->crv.crv_name, stp->st_dp->d_namep );
d700 3
a702 3
				bu_log( "Unrecognized curve segment type in curve (%s) referenced by extrusion (%s)\n",
					crv->crv_name, stp->st_dp->d_namep );
				bu_bomb( "Unrecognized curve segment type in curve\n" );
d1153 1
a1153 16
	/* find the curve for this extrusion */
	for( curve_no=0 ; curve_no < sketch_ip->curve_count ; curve_no++ )
	{
		if( !strncmp( extrude_ip->curve_name, sketch_ip->curves[curve_no].crv_name, SKETCH_NAME_LEN ) )
		{
			crv = &sketch_ip->curves[curve_no];
			break;
		}
	}

	if( !crv )
	{
		bu_log( "rt_extrude_plot: ERROR: cannot find curve named '%.16s' in sketch named '%.16s'\n",
			extrude_ip->curve_name, extrude_ip->sketch_name );
		return( -1 );
	}
d1160 2
a1161 2
		bu_log( "Error: curve (%s) in sketch (%s) references non-existent vertices!!!\n",
			crv->crv_name, extrude_ip->sketch_name );
a1295 2
	ptr += 16;
	strncpy( extrude_ip->curve_name, ptr, 16 );
a1343 2
	ptr += 16;
	strncpy( (char *)ptr, extrude_ip->curve_name, 16 );
d1380 2
a1381 3
	sprintf( buf, "\tsketch name: %.16s\n\tcurve name: %.16s\n",
		extrude_ip->sketch_name,
		extrude_ip->curve_name );
a1458 1
	strncpy( eop->curve_name, eip->curve_name, 16 );
d1505 1
a1505 1
		bu_vls_printf( &vls, " S %s C %s", extr->sketch_name, extr->curve_name );
a1517 2
	else if( *attr == 'C' )
		bu_vls_printf( &vls, "%s", extr->curve_name );
d1522 1
a1522 1
		bu_vls_strcat( &vls, "ERROR: unrecognized attribute, must be V, H, A, B, S, C, or K!!!" );
a1579 2
		else if( *argv[0] =='C' )
			NAMEMOVE( argv[1], extr->curve_name );
@


1.19
log
@Eliminated FGP solid and added cline solid
@
text
@d41 1
a41 1
static char RCSextrude[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_extrude.c,v 1.18 2000/03/01 18:30:48 jra Exp $ (BRL)";
d1567 1
a1567 1
        Tcl_DStringAppendElement( &ds, bu_vls_addr( &vls ) );
@


1.18
log
@Fixed a bug in rt_extrude_xform()
@
text
@d41 1
a41 1
static char RCSextrude[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_extrude.c,v 1.17 2000/03/01 16:34:10 jra Exp $ (BRL)";
a88 2
#define DEBUG	0

a315 15
#if DEBUG
	bn_mat_print( "Rotation matrix", extr->rot );
	VPRINT( "extrusion vector", eip->h );
	MAT4X3VEC( tmp, extr->rot, eip->h )
	VPRINT( "         rotated", tmp );
	VPRINT( "solid vertex", eip->V );
	MAT4X3PNT( tmp, extr->rot, eip->V );
	VPRINT( "     rotated", tmp );
	VPRINT( "bounding box min", stp->st_min );
	VPRINT( "bounding box max", stp->st_max );
	VPRINT( "bounding sphere center", stp->st_center );
	bu_log( "approximating sphere radius = %g\n", stp->st_aradius );
	bu_log( "bounding sphere radius = %g\n", stp->st_bradius );
#endif

a598 3
#if DEBUG
bu_log( "in rt_extrude_shot: ray start = (%g %g %g), dir=(%g %g %g)\n", V3ARGS( rp->r_pt ), V3ARGS( rp->r_dir ) );
#endif
a605 4
#if DEBUG
bu_log( "Ray is parallel to top and bottom faces\n" );
bu_log( "\tdist_bottom=%g, dist_top = %g\n", dist_bottom, dist_top );
#endif
a627 3
#if DEBUG
bu_log( "\tdist_bottom=%g, dist_top = %g\n", dist_bottom, dist_top );
#endif
a632 3
#if DEBUG
bu_log( "transformed ray: (%g %g %g), in dir (%g %g %g)\n", V3ARGS( ray_start ), V3ARGS( ray_dir ) );
#endif
a650 4
#if DEBUG
bu_log( "ray is parallel to extrusion vector, using pt=(%g %g %g), dir=(%g %g %g) to check in/out\n",
V3ARGS( ray_start ), V3ARGS( ray_dir ) );
#endif
a670 4
#if DEBUG
bu_log( "Intersection line segment (%g %g %g)<->(%g %g %g)\n", V3ARGS( extr->verts[lsg->start] ), V3ARGS( extr->verts[lsg->end] ) );
bu_log( "\tintersection code is %d, dist[0]=%g, dist[1]=%g\n", code, dist[0], dist[1] );
#endif
d733 1
a733 3
#if DEBUG
bu_log( "\tskipping this intersection (same dist as a previous one)\n" );
#endif
d751 1
a751 3
#if DEBUG
bu_log( "\tskipping this intersection (same dist as a previous one)\n" );
#endif
d769 1
a769 3
#if DEBUG
bu_log( "\tskipping this intersection (same dist as a previous one)\n" );
#endif
a801 3
#if DEBUG
bu_log( "hit before bottom is now %d\n", hits_before_bottom );
#endif
d814 1
a814 3
#if DEBUG
bu_log( "hit after top is now %d\n", hits_after_top );
#endif
a818 3
#if DEBUG
bu_log( "got a hit at dist=%g\n", dist[0] );
#endif
a871 3
#if DEBUG
bu_log( "hit top and bottom faces\n" );
#endif
a875 3
#if DEBUG
bu_log( "returning 0\n" );
#endif
a879 3
#if DEBUG
bu_log( "hit_count = %d\n", hit_count );
#endif
a900 3
#if DEBUG
bu_log( "Adding bottom face hit at dist=%g\n", dist_bottom );
#endif
a917 3
#if DEBUG
bu_log( "Adding top face hit at dist=%g\n", dist_top );
#endif
a935 1
bu_bomb( "ERROR\n" );
d952 1
a952 3
#if DEBUG
bu_log( "returning %d hits\n", hit_count );
#endif
d1402 2
d1407 4
d1412 4
a1415 4
		V3ARGS( extrude_ip->V ),
		V3ARGS( extrude_ip->h ),
		V3ARGS( extrude_ip->u_vec ),
		V3ARGS( extrude_ip->v_vec ) );
@


1.17
log
@Fixed a bug in rt_extrude_tcladjust()
@
text
@d41 1
a41 1
static char RCSextrude[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_extrude.c,v 1.16 2000/02/10 19:49:45 jra Exp $ (BRL)";
d1545 2
@


1.16
log
@continued development of the sketch and extrusion solids
@
text
@d41 1
a41 1
static char RCSextrude[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/g_extrude.c,v 1.15 2000/02/01 20:11:34 jra Exp $ (BRL)";
d1653 1
d1658 1
a1658 1
			if( (ret=tcl_list_to_fastf_array( interp, argv[1], &new, 3 ) ) )
d1664 1
a1664 1
			if( (ret=tcl_list_to_fastf_array( interp, argv[1], &new, 3 ) ) )
d1670 1
a1670 1
			if( (ret=tcl_list_to_fastf_array( interp, argv[1], &new, 3 ) ) )
d1676 1
a1676 1
			if( (ret=tcl_list_to_fastf_array( interp, argv[1], &new, 3 ) ) )
@


1.15
log
@Added a comment
@
text
@d41 1
a41 1
static char RCSextrude[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_extrude.c,v 1.14 2000/02/01 20:03:25 jra Exp $ (BRL)";
d48 1
d144 8
d212 2
a213 1
	extr->verts = (point_t *)bu_calloc( vert_count, sizeof( point_t ), "extr->verts" );
d1192 3
d1261 6
a1266 1
	curve_to_vlist( vhead, ttol, extrude_ip->V, extrude_ip->u_vec, extrude_ip->v_vec, sketch_ip, crv );
d1580 110
@


1.14
log
@Improved curvature calculation for circlular arc segments
@
text
@d41 1
a41 1
static char RCSextrude[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_extrude.c,v 1.13 2000/01/31 13:40:50 jra Exp $ (BRL)";
d1110 1
d1124 3
d1144 2
a1145 2
			tmp = sqrt( tmp );
			curvature = a*b/(tmp*tmp*tmp);
@


1.13
log
@Getting the extrusion and sketch to work - not quite finished
@
text
@d41 1
a41 1
static char RCSextrude[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_extrude.c,v 1.12 1999/12/29 21:11:26 jra Exp $ (BRL)";
d1108 2
a1109 1
	fastf_t radius;
d1111 1
d1130 12
d1143 1
a1143 1
				cvp->crv_c1 = 1.0 / radius;
d1145 1
a1145 1
				cvp->crv_c1 = -1.0 / radius;
d1343 3
a1345 1
	if( (dp=db_lookup( dbip, sketch_name, LOOKUP_NOISY)) == DIR_NULL )
@


1.12
log
@Eliminated some unused variables
@
text
@d41 1
a41 1
static char RCSextrude[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_extrude.c,v 1.11 1999/11/26 22:02:53 mike Exp $ (BRL)";
d60 10
a69 1
	fastf_t mag_h;
d72 15
a86 69
/*
 *			R T _ E X T R _ R O T A T E
 *
 *			(copied from rt_tgc_rotate)
 *
 *  To rotate vectors  A  and  B  ( where  A  is perpendicular to  B )
 *  to the X and Y axes respectively, create a rotation matrix
 *
 *	    | A' |
 *	R = | B' |
 *	    | C' |
 *
 *  where  A',  B'  and  C'  are vectors such that
 *
 *	A' = A/|A|	B' = B/|B|	C' = C/|C|
 *
 *  where    C = H - ( H.A' )A' - ( H.B' )B'
 *
 *  The last operation ( Gram Schmidt method ) finds the component
 *  of the vector  H  perpendicular  A  and to  B.  This is, therefore
 *  the normal for the base and top of the extrusion.
 */
static void
rt_extr_rotate( eip, Rot, Inv  )
CONST struct rt_extrude_internal *eip;
mat_t		Rot, Inv;
{
	LOCAL vect_t	uA, uB, uC;	/*  unit vectors		*/
	LOCAL fastf_t	mag_ha,		/*  magnitude of H in the	*/
			mag_hb;		/*    A and B directions	*/
	LOCAL mat_t	tmp_mat1, tmp_mat2;
	LOCAL vect_t	tmp_h;

	/* copy A and B, then 'unitize' the results			*/
	VMOVE( uA, eip->u_vec );
	VUNITIZE( uA );
	VMOVE( uB, eip->v_vec );
	VUNITIZE( uB );

	/*  Find component of H in the A direction			*/
	mag_ha = VDOT( eip->h, uA );
	/*  Find component of H in the B direction			*/
	mag_hb = VDOT( eip->h, uB );

	/*  Subtract the A and B components of H to find the component
	 *  perpendicular to both, then 'unitize' the result.
	 */
	VJOIN2( uC, eip->h, -mag_ha, uA, -mag_hb, uB );
	VUNITIZE( uC );

	bn_mat_idn( Rot );
	bn_mat_idn( Inv );
	bn_mat_idn( tmp_mat1 );
	bn_mat_idn( tmp_mat2 );

	tmp_mat1[0] = uA[X];
	tmp_mat1[1] = uA[Y];
	tmp_mat1[2] = uA[Z];

	tmp_mat1[4] = uB[X];
	tmp_mat1[5] = uB[Y];
	tmp_mat1[6] = uB[Z];

	tmp_mat1[8]  = uC[X];
	tmp_mat1[9]  = uC[Y];
	tmp_mat1[10] = uC[Z];

	MAT_DELTAS_VEC_NEG( Rot, eip->V )
	bn_mat_mul2( tmp_mat1, Rot );
d88 1
a88 8
	MAT4X3VEC( tmp_h, Rot, eip->h );

	tmp_mat2[2] = tmp_h[X]/tmp_h[Z];
	tmp_mat2[6] = tmp_h[Y]/tmp_h[Z];

	bn_mat_mul2( tmp_mat2, Rot );

}
d113 6
a118 2
	LOCAL mat_t	Rot, iRot;
	LOCAL point_t	tmp_pt;
d122 20
d146 76
a221 2
	rt_extr_rotate( eip, Rot, iRot );
	bn_mat_print( "extrude rotation", Rot );
d223 99
a321 10
	MAT4X3PNT( tmp_pt, Rot, eip->V );
	VPRINT( "original Vertex:", eip->V );
	VPRINT( "rotated vertex:", tmp_pt );
	MAT4X3VEC( tmp_pt, Rot, eip->h );
	VPRINT( "orinal height:", eip->h );
	VPRINT( "rotated height:", tmp_pt );
	MAT4X3VEC( tmp_pt, Rot, eip->u_vec );
	VPRINT( "rotated u_vec:", tmp_pt );
	MAT4X3VEC( tmp_pt, Rot, eip->v_vec );
	VPRINT( "rotated v_vec:", tmp_pt );
d335 230
d583 431
a1013 1
	return(0);			/* MISS */
d1045 5
d1051 42
d1106 4
a1109 1
 	cvp->crv_c1 = cvp->crv_c2 = 0;
d1111 24
a1134 2
	/* any tangent direction */
 	vec_ortho( cvp->crv_pdir, hitp->hit_normal );
d1198 9
d1321 7
d1333 1
a1333 1
		return( -1 );
d1335 1
a1335 2

	if( rt_db_get_internal( &tmp_ip, dp, dbip, bn_mat_identity ) != ID_SKETCH )
d1337 9
a1345 3
		bu_log( "rt_extrude_import: ERROR: Cannot import sketch (%.16s) for extrusion (%.16s)\n",
			sketch_name, rp->extr.ex_name );
		return( -1 );
a1347 8
	RT_INIT_DB_INTERNAL( ip );
	ip->idb_type = ID_EXTRUDE;
	ip->idb_meth = &rt_functab[ID_EXTRUDE];
	ip->idb_ptr = bu_malloc( sizeof(struct rt_extrude_internal), "rt_extrude_internal");
	extrude_ip = (struct rt_extrude_internal *)ip->idb_ptr;
	extrude_ip->magic = RT_EXTRUDE_INTERNAL_MAGIC;
	extrude_ip->skt = (struct rt_sketch_internal *)tmp_ip.idb_ptr;

d1530 2
d1533 1
a1533 1
		eop->skt = rt_copy_sketch( eip->skt );
@


1.11
log
@
Lint fixed
@
text
@d41 1
a41 1
static char RCSextrude[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_extrude.c,v 1.10 1999/11/26 21:46:46 mike Exp $ (BRL)";
a197 2
	register CONST struct extrude_specific *extrude =
		(struct extrude_specific *)stp->st_specific;
a249 3
	register struct extrude_specific *extrude =
		(struct extrude_specific *)stp->st_specific;

a263 3
	register struct extrude_specific *extrude =
		(struct extrude_specific *)stp->st_specific;

a284 2
	register struct extrude_specific *extrude =
		(struct extrude_specific *)stp->st_specific;
a321 1
	struct directory		*dp;
a322 6
	long				*lng;
	int				seg_no;
	struct line_seg			*lsg;
	int				first=1;
	int				start, end, prev=-1;
	point_t				pt;
d324 2
d352 3
a354 34
	for( seg_no=0 ; seg_no < crv->seg_count ; seg_no++ )
	{
		lng = (long *)crv->segments[seg_no];
		switch( *lng )
		{
			case CURVE_LSEG_MAGIC:
				lsg = (struct line_seg *)lng;
				if( crv->reverse[seg_no] )
				{
					end = lsg->start;
					start = lsg->end;
				}
				else
				{
					start = lsg->start;
					end = lsg->end;
				}
				if( first || start != prev )
				{
					VJOIN2( pt, extrude_ip->V, sketch_ip->verts[start][0], extrude_ip->u_vec, sketch_ip->verts[start][1], extrude_ip->v_vec);
					RT_ADD_VLIST( vhead, pt, BN_VLIST_LINE_MOVE )
				}
				VJOIN2( pt, extrude_ip->V, sketch_ip->verts[end][0], extrude_ip->u_vec, sketch_ip->verts[end][1], extrude_ip->v_vec);
				RT_ADD_VLIST( vhead, pt, BN_VLIST_LINE_DRAW );
				prev = end;
				break;
			default:
			{
				bu_log( "rt_extrude_plot: ERROR: unrecognized segment type!!!!\n" );
				return( -1 );
			}
		}
		first = 0;
	}
a356 1
	first = 1;
d358 20
a377 1
	for( seg_no=0 ; seg_no < crv->seg_count ; seg_no++ )
d379 4
a382 2
		lng = (long *)crv->segments[seg_no];
		switch( *lng )
d384 2
a385 26
			case CURVE_LSEG_MAGIC:
				lsg = (struct line_seg *)lng;
				if( crv->reverse[seg_no] )
				{
					end = lsg->start;
					start = lsg->end;
				}
				else
				{
					start = lsg->start;
					end = lsg->end;
				}
				if( first || start != prev )
				{
					VJOIN2( pt, end_of_h, sketch_ip->verts[start][0], extrude_ip->u_vec, sketch_ip->verts[start][1], extrude_ip->v_vec);
					RT_ADD_VLIST( vhead, pt, BN_VLIST_LINE_MOVE )
				}
				VJOIN2( pt, end_of_h, sketch_ip->verts[end][0], extrude_ip->u_vec, sketch_ip->verts[end][1], extrude_ip->v_vec);
				RT_ADD_VLIST( vhead, pt, BN_VLIST_LINE_DRAW );
				prev = end;
				break;
			default:
			{
				bu_log( "rt_extrude_plot: ERROR: unrecognized segment type!!!!\n" );
				return( -1 );
			}
d387 2
a388 10
		first = 0;
	}

	/* plot connecting lines */
	for( seg_no=0 ; seg_no < crv->seg_count ; seg_no++ )
	{
		point_t pt2;

		lng = (long *)crv->segments[seg_no];
		switch( *lng )
d390 2
a391 17
			case CURVE_LSEG_MAGIC:
				lsg = (struct line_seg *)lng;
				if( crv->reverse[seg_no] )
					end = lsg->start;
				else
					end = lsg->end;
				VJOIN2( pt, extrude_ip->V, sketch_ip->verts[end][0], extrude_ip->u_vec, sketch_ip->verts[end][1], extrude_ip->v_vec);
				VJOIN2( pt2, end_of_h, sketch_ip->verts[end][0], extrude_ip->u_vec, sketch_ip->verts[end][1], extrude_ip->v_vec);
				RT_ADD_VLIST( vhead, pt, BN_VLIST_LINE_MOVE )
				RT_ADD_VLIST( vhead, pt2, BN_VLIST_LINE_DRAW );
				prev = end;
				break;
			default:
			{
				bu_log( "rt_extrude_plot: ERROR: unrecognized segment type!!!!\n" );
				return( -1 );
			}
a392 1
		first = 0;
a429 1
	struct rt_sketch_internal		*sketch_ip;
a552 2
	int curve_no;
	int seg_no;
a582 4
	struct curve				*crv;
	int					curve_no;
	genptr_t				*seg_ptr;
	int					seg_no;
@


1.10
log
@
Lint cleanups
@
text
@d41 1
a41 1
static char RCSextrude[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_extrude.c,v 1.9 1999/11/24 14:39:52 jra Exp $ (BRL)";
d56 2
a57 1
RT_EXTERN( struct rt_sketch_internal *copy_sketch, (struct rt_sketch_internal *sketch_ip ) );
d501 1
a501 1
struct db_i		*dbip;
d732 1
a732 1
		eop->skt = copy_sketch( eip->skt );
@


1.9
log
@Was missing some idb_meth settings for the rt_db_internal structs
@
text
@d41 1
a41 1
static char RCSextrude[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_extrude.c,v 1.8 1999/11/17 02:41:58 mike Exp $ (BRL)";
d326 1
a326 1
struct bn_tol		*tol;
d484 1
a484 1
struct bn_tol		*tol;
d621 1
a621 1
struct rt_db_internal	*ip;
@


1.8
log
@
Added idb_meth and st_meth pointers to allow direct access to per-solid
methods, C++ style.
@
text
@d41 1
a41 1
static char RCSextrude[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_extrude.c,v 1.7 1999/07/02 22:47:22 mike Exp $ (BRL)";
d672 1
@


1.7
log
@
Fixed script-induced typos
@
text
@d41 1
a41 1
static char RCSextrude[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_extrude.c,v 1.6 1999/07/02 22:19:23 mike Exp $ (BRL)";
d536 1
@


1.6
log
@
Removed dependence on compat4.h
@
text
@d41 1
a41 1
static char RCSextrude[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_extrude.c,v 1.5 1999/05/27 19:10:38 mike Exp $ (BRL)";
d130 1
a130 1
	bn_bn_mat_mul2( tmp_mat1, Rot );
d137 1
a137 1
	bn_bn_mat_mul2( tmp_mat2, Rot );
@


1.5
log
@
sed4
@
text
@d41 1
a41 1
static char RCSextrude[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_extrude.c,v 1.4 1999/01/13 21:49:11 mike Exp $ (BRL)";
d130 1
a130 1
	bn_mat_mul2( tmp_mat1, Rot );
d137 1
a137 1
	bn_mat_mul2( tmp_mat2, Rot );
d386 1
a386 1
					RT_ADD_VLIST( vhead, pt, RT_VLIST_LINE_MOVE )
d389 1
a389 1
				RT_ADD_VLIST( vhead, pt, RT_VLIST_LINE_DRAW );
d424 1
a424 1
					RT_ADD_VLIST( vhead, pt, RT_VLIST_LINE_MOVE )
d427 1
a427 1
				RT_ADD_VLIST( vhead, pt, RT_VLIST_LINE_DRAW );
d455 2
a456 2
				RT_ADD_VLIST( vhead, pt, RT_VLIST_LINE_MOVE )
				RT_ADD_VLIST( vhead, pt2, RT_VLIST_LINE_DRAW );
@


1.4
log
@Fixed args to htond()
@
text
@d41 1
a41 1
static char RCSextrude[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_extrude.c,v 1.3 1998/09/14 15:59:17 bparker Exp $ (BRL)";
d112 4
a115 4
	mat_idn( Rot );
	mat_idn( Inv );
	mat_idn( tmp_mat1 );
	mat_idn( tmp_mat2 );
d170 1
a170 1
	GETSTRUCT( extr, extrude_specific );
d306 1
a306 1
	rt_free( (char *)extrude, "extrude_specific" );
d323 1
a323 1
struct rt_list		*vhead;
d326 1
a326 1
struct rt_tol		*tol;
d484 1
a484 1
struct rt_tol		*tol;
d498 1
a498 1
CONST struct rt_external	*ep;
d511 1
a511 1
	RT_CK_EXTERNAL( ep );
d515 1
a515 1
		rt_log("rt_extrude_import: defective record\n");
d567 1
a567 1
struct rt_external		*ep;
d582 1
a582 1
	RT_INIT_EXTERNAL(ep);
d584 1
a584 1
	ep->ext_buf = (genptr_t)rt_calloc( 1, ep->ext_nbytes, "extrusion external");
d619 1
a619 1
struct rt_vls		*str;
d631 1
a631 1
	rt_vls_strcat( str, "2D extrude (EXTRUDE)\n");
d637 1
a637 1
	rt_vls_strcat( str, buf );
d641 1
a641 1
	rt_vls_strcat( str, buf );
@


1.3
log
@*- fix typos
@
text
@d41 1
a41 1
static char RCSextrude[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_extrude.c,v 1.2 1998/06/25 07:46:30 mike Exp $ (BRL)";
d541 1
a541 1
	ntohd( tmp_vec, rp->extr.ex_V, 3 );
d543 1
a543 1
	ntohd( tmp_vec, rp->extr.ex_h, 3 );
d545 1
a545 1
	ntohd( tmp_vec, rp->extr.ex_uvec, 3 );
d547 1
a547 1
	ntohd( tmp_vec, rp->extr.ex_vvec, 3 );
d590 1
a590 1
	htond( rec->extr.ex_V, tmp_vec, 3 );
d592 1
a592 1
	htond( rec->extr.ex_h, tmp_vec, 3 );
d594 1
a594 1
	htond( rec->extr.ex_uvec, tmp_vec, 3 );
d596 1
a596 1
	htond( rec->extr.ex_vvec, tmp_vec, 3 );
@


1.2
log
@Port to sun4
@
text
@d41 1
a41 1
static char RCSextrude[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_extrude.c,v 1.1 1998/05/29 14:19:18 jra Exp $ (BRL)";
d187 1
d603 1
a603 1
	strncpy( ptr, extrude_ip->sketch_name, 16 );
d605 1
a605 1
	strncpy( ptr, extrude_ip->curve_name, 16 );
@


1.1
log
@Initial revision
@
text
@d41 1
a41 1
static char RCSextrude[] = "@@(#)$Header: /m/cad/librt/RCS/g_extrude.c,v 11.2 1997/09/22 05:16:19 butler Exp $ (BRL)";
d599 1
a599 1
	ptr = (char *)rec;
@
