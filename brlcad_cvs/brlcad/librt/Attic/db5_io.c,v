head	11.74;
access;
symbols
	ansi-20040405-merged:11.69.2.2
	postmerge-20040405-ansi:11.72
	premerge-20040404-ansi:11.71
	postmerge-autoconf:11.71
	autoconf-freeze:11.71
	premerge-autoconf:11.71
	ansi-20040316-freeze:11.69.2.1
	postmerge-20040315-windows:11.71
	premerge-20040315-windows:11.71
	windows-20040315-freeze:11.69.4.1
	autoconf-20031203:11.71
	autoconf-20031202:11.71
	autoconf-branch:11.71.0.6
	phong-branch:11.71.0.4
	photonmap-branch:11.71.0.2
	rel-6-1-DP:11.69
	windows-branch:11.69.0.4
	rel-6-0-2:11.67
	ansi-branch:11.69.0.2
	rel-6-0-1-branch:11.67.0.2
	hartley-6-0-post:11.68
	hartley-6-0-pre:11.67
	rel-6-0-1:11.67
	rel-6-0:11.67
	offsite-5-3-pre:11.50;
locks; strict;
comment	@ * @;


11.74
date	2004.05.21.18.07.29;	author morrison;	state dead;
branches;
next	11.73;

11.73
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.72;

11.72
date	2004.04.05.08.48.56;	author morrison;	state Exp;
branches;
next	11.71;

11.71
date	2002.10.31.19.34.20;	author jra;	state Exp;
branches;
next	11.70;

11.70
date	2002.10.31.19.29.50;	author jra;	state Exp;
branches;
next	11.69;

11.69
date	2002.08.20.17.07.57;	author jra;	state Exp;
branches
	11.69.2.1
	11.69.4.1;
next	11.68;

11.68
date	2002.08.15.20.55.08;	author hartley;	state Exp;
branches;
next	11.67;

11.67
date	2001.10.04.18.49.07;	author tranese;	state Exp;
branches;
next	11.66;

11.66
date	2001.09.19.21.06.01;	author jra;	state Exp;
branches;
next	11.65;

11.65
date	2001.05.17.20.05.23;	author morrison;	state Exp;
branches;
next	11.64;

11.64
date	2001.05.14.01.47.50;	author jra;	state Exp;
branches;
next	11.63;

11.63
date	2001.04.20.22.29.40;	author morrison;	state Exp;
branches;
next	11.62;

11.62
date	2001.04.20.21.34.38;	author bparker;	state Exp;
branches;
next	11.61;

11.61
date	2001.04.15.02.18.43;	author jra;	state Exp;
branches;
next	11.60;

11.60
date	2001.04.05.13.08.19;	author jra;	state Exp;
branches;
next	11.59;

11.59
date	2001.03.28.14.49.39;	author jra;	state Exp;
branches;
next	11.58;

11.58
date	2001.03.23.22.05.29;	author jra;	state Exp;
branches;
next	11.57;

11.57
date	2001.03.22.19.37.39;	author jra;	state Exp;
branches;
next	11.56;

11.56
date	2001.03.22.18.10.53;	author bparker;	state Exp;
branches;
next	11.55;

11.55
date	2001.03.21.21.00.30;	author jra;	state Exp;
branches;
next	11.54;

11.54
date	2001.03.21.20.56.59;	author jra;	state Exp;
branches;
next	11.53;

11.53
date	2001.03.21.19.00.38;	author pjt;	state Exp;
branches;
next	11.52;

11.52
date	2001.03.20.21.54.41;	author pjt;	state Exp;
branches;
next	11.51;

11.51
date	2001.03.20.16.09.07;	author jra;	state Exp;
branches;
next	11.50;

11.50
date	2000.09.08.05.54.40;	author mike;	state Exp;
branches;
next	11.49;

11.49
date	2000.08.22.20.35.52;	author mike;	state Exp;
branches;
next	11.48;

11.48
date	2000.08.21.02.02.29;	author butler;	state Exp;
branches;
next	11.47;

11.47
date	2000.08.19.20.15.59;	author mike;	state Exp;
branches;
next	11.46;

11.46
date	2000.08.15.05.01.02;	author mike;	state Exp;
branches;
next	11.45;

11.45
date	2000.08.15.04.50.44;	author mike;	state Exp;
branches;
next	11.44;

11.44
date	2000.08.10.23.56.44;	author mike;	state Exp;
branches;
next	11.43;

11.43
date	2000.08.10.03.53.59;	author mike;	state Exp;
branches;
next	11.42;

11.42
date	2000.07.26.15.13.07;	author mike;	state Exp;
branches;
next	11.41;

11.41
date	2000.07.25.22.40.48;	author mike;	state Exp;
branches;
next	11.40;

11.40
date	2000.07.25.16.46.05;	author butler;	state Exp;
branches;
next	11.39;

11.39
date	2000.07.13.00.45.18;	author mike;	state Exp;
branches;
next	11.38;

11.38
date	2000.07.12.04.28.06;	author mike;	state Exp;
branches;
next	11.37;

11.37
date	2000.07.12.02.08.29;	author mike;	state Exp;
branches;
next	11.36;

11.36
date	2000.07.11.05.08.46;	author mike;	state Exp;
branches;
next	11.35;

11.35
date	2000.07.11.04.05.52;	author mike;	state Exp;
branches;
next	11.34;

11.34
date	2000.07.11.03.18.51;	author mike;	state Exp;
branches;
next	11.33;

11.33
date	2000.07.11.02.43.39;	author mike;	state Exp;
branches;
next	11.32;

11.32
date	2000.07.08.01.57.04;	author mike;	state Exp;
branches;
next	11.31;

11.31
date	2000.07.07.22.55.07;	author mike;	state Exp;
branches;
next	11.30;

11.30
date	2000.07.07.22.33.30;	author mike;	state Exp;
branches;
next	11.29;

11.29
date	2000.07.07.05.20.11;	author mike;	state Exp;
branches;
next	11.28;

11.28
date	2000.07.07.03.56.32;	author mike;	state Exp;
branches;
next	11.27;

11.27
date	2000.07.07.03.49.41;	author mike;	state Exp;
branches;
next	11.26;

11.26
date	2000.06.30.21.39.46;	author mike;	state Exp;
branches;
next	11.25;

11.25
date	2000.06.30.19.47.30;	author mike;	state Exp;
branches;
next	11.24;

11.24
date	2000.06.30.19.09.41;	author mike;	state Exp;
branches;
next	11.23;

11.23
date	2000.06.30.18.35.40;	author mike;	state Exp;
branches;
next	11.22;

11.22
date	2000.06.30.17.36.56;	author mike;	state Exp;
branches;
next	11.21;

11.21
date	2000.06.30.16.35.09;	author pjt;	state Exp;
branches;
next	11.20;

11.20
date	2000.06.30.15.52.33;	author mike;	state Exp;
branches;
next	11.19;

11.19
date	2000.06.30.14.37.20;	author mike;	state Exp;
branches;
next	11.18;

11.18
date	2000.06.29.20.09.47;	author mike;	state Exp;
branches;
next	11.17;

11.17
date	2000.06.29.20.04.30;	author mike;	state Exp;
branches;
next	11.16;

11.16
date	2000.06.29.18.54.00;	author mike;	state Exp;
branches;
next	11.15;

11.15
date	2000.06.29.18.20.55;	author mike;	state Exp;
branches;
next	11.14;

11.14
date	2000.06.29.17.58.28;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	2000.06.29.15.55.46;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	2000.06.29.15.21.14;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	2000.06.28.21.41.25;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	2000.06.28.18.04.35;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	2000.06.28.16.34.57;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	2000.06.27.21.05.57;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	2000.06.27.18.14.55;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	2000.06.27.17.33.13;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	2000.06.27.14.26.13;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	2000.06.27.14.15.39;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	2000.06.26.21.19.54;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	2000.06.26.19.47.56;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	2000.06.26.19.06.55;	author mike;	state Exp;
branches;
next	;

11.69.2.1
date	2002.09.19.18.01.29;	author morrison;	state Exp;
branches;
next	11.69.2.2;

11.69.2.2
date	2004.03.17.21.18.43;	author morrison;	state Exp;
branches;
next	;

11.69.4.1
date	2004.03.11.23.43.35;	author morrison;	state Exp;
branches;
next	;


desc
@@


11.74
log
@moved to src/
@
text
@/*
 *			D B 5 _ I O . C
 *
 *  Handle import/export and IO of v5 database objects.
 *
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Status -
 *	Public Domain, Distribution Unlimited.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/db5_io.c,v 11.73 2004/05/10 15:30:46 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "db5.h"
#include "raytrace.h"

#include "mater.h"

#include "./debug.h"

/* Number of bytes used for each value of DB5HDR_WIDTHCODE_* */
const int db5_enc_len[4] = {
	1,
	2,
	4,
	8
};

/*
 *			D B 5 _ H E A D E R _ I S _ V A L I D
 *
 *  Verify that this is a valid header for a BRL-CAD v5 database.
 *
 *  Returns -
 *	0	Not valid v5 header
 *	1	Valid v5 header
 */
int
db5_header_is_valid(const unsigned char *hp)
{
	const struct db5_ondisk_header *odp = (const struct db5_ondisk_header *)hp;

	if( odp->db5h_magic1 != DB5HDR_MAGIC1 )  return 0;
	if( hp[7] != DB5HDR_MAGIC2 )  return 0;

	/* hflags */
	if( (odp->db5h_hflags & DB5HDR_HFLAGS_DLI_MASK) != DB5HDR_HFLAGS_DLI_HEADER_OBJECT )
		return 0;
	if( (odp->db5h_hflags & DB5HDR_HFLAGS_NAME_PRESENT) )  return 0;
	if( ((odp->db5h_hflags & DB5HDR_HFLAGS_OBJECT_WIDTH_MASK) >> DB5HDR_HFLAGS_OBJECT_WIDTH_SHIFT)
	    != DB5HDR_WIDTHCODE_8BIT )  return 0;

	/* aflags */
	if( (odp->db5h_aflags & DB5HDR_AFLAGS_ZZZ_MASK) != DB5_ZZZ_UNCOMPRESSED )  return 0;
	if( odp->db5h_aflags & DB5HDR_AFLAGS_PRESENT )  return 0;
	if( ((odp->db5h_aflags & DB5HDR_AFLAGS_WIDTH_MASK) >> DB5HDR_AFLAGS_WIDTH_SHIFT)
	    != DB5HDR_WIDTHCODE_8BIT )  return 0;

	/* bflags */
	if( (odp->db5h_bflags & DB5HDR_BFLAGS_ZZZ_MASK) != DB5_ZZZ_UNCOMPRESSED )  return 0;
	if( odp->db5h_bflags & DB5HDR_BFLAGS_PRESENT )  return 0;
	if( ((odp->db5h_bflags & DB5HDR_BFLAGS_WIDTH_MASK) >> DB5HDR_BFLAGS_WIDTH_SHIFT)
	    != DB5HDR_WIDTHCODE_8BIT )  return 0;

	/* major and minor type */
	if( odp->db5h_major_type != DB5_MAJORTYPE_RESERVED )  return 0;
	if( odp->db5h_minor_type != 0 )  return 0;

	/* Check length, known to be 8-bit.  Header len=1 8-byte chunk. */
	if( hp[6] != 1 )  return 0;

	return 1;		/* valid */
}

/*
 *			D B 5 _ S E L E C T _ L E N G T H _ E N C O D I N G
 *
 *  Given a number to encode, decide which is the smallest encoding format
 *  which will contain it.
 */
int
db5_select_length_encoding(long int len)
{
	if( len <= 255 )  return DB5HDR_WIDTHCODE_8BIT;
	if( len <= 65535 )  return DB5HDR_WIDTHCODE_16BIT;
	if( len < 0x7ffffffe )  return DB5HDR_WIDTHCODE_32BIT;
	return DB5HDR_WIDTHCODE_64BIT;
}

/*
 *			D B 5 _ D E C O D E _ L E N G T H
 *
 *  Given a variable-width length field in network order (XDR),
 *  store it in *lenp.
 *
 *  This routine processes unsigned values.
 *
 *  Returns -
 *	The number of bytes of input that were decoded.
 */
int
db5_decode_length(long int *lenp, const unsigned char *cp, int format)
{
	switch( format )  {
	case DB5HDR_WIDTHCODE_8BIT:
		*lenp = (*cp);
		return 1;
	case DB5HDR_WIDTHCODE_16BIT:
		*lenp = BU_GSHORT(cp);
		return 2;
	case DB5HDR_WIDTHCODE_32BIT:
		*lenp = BU_GLONG(cp);
		return 4;
	case DB5HDR_WIDTHCODE_64BIT:
#if defined(IRIX64)
		if( sizeof(long) >= 8 )  {
			*lenp = BU_GLONGLONG(cp);
			return 8;
		}
#endif
		bu_bomb("db5_decode_length(): encountered 64-bit length on 32-bit machine\n");
	}
	bu_bomb("db5_decode_length(): unknown width code\n");
	return 0;
}

/*
 *			D B 5 _ D E C O D E _ S I G N E D
 *
 *  Given a variable-width length field in network order (XDR),
 *  store it in *lenp.
 *
 *  This routine processes signed values.
 *
 *  Returns -
 *	The number of bytes of input that were decoded.
 */
int
db5_decode_signed(long int *lenp, const unsigned char *cp, int format)
{
	switch( format )  {
	case DB5HDR_WIDTHCODE_8BIT:
		if( (*lenp = (*cp)) & 0x80 ) *lenp |= (-1L ^ 0xFF);
		return 1;
	case DB5HDR_WIDTHCODE_16BIT:
		if( (*lenp = BU_GSHORT(cp)) & 0x8000 )  *lenp |= (-1L ^ 0xFFFF);
		return 2;
	case DB5HDR_WIDTHCODE_32BIT:
		if( (*lenp = BU_GLONG(cp)) & 0x80000000 )
			*lenp |= (-1L ^ 0xFFFFFFFF);
		return 4;
	case DB5HDR_WIDTHCODE_64BIT:
#if defined(IRIX64)
		if( sizeof(long) >= 8 )  {
			*lenp = BU_GLONGLONG(cp);
			return 8;
		}
#endif
		bu_bomb("db5_decode_length(): encountered 64-bit length on 32-bit machine\n");
	}
	bu_bomb("db5_decode_length(): unknown width code\n");
	return 0;
}

/*
 *			D B 5 _ E N C O D E _ L E N G T H
 *
 *  Given a value and a variable-width format spec,
 *  store it in network order (XDR).
 *
 *  Returns -
 *	pointer to next available byte.
 */
unsigned char *
db5_encode_length(
	unsigned char	*cp,
	long		val,
	int		format)
{
	switch( format )  {
	case DB5HDR_WIDTHCODE_8BIT:
		*cp = val & 0xFF;
		return cp+1;
	case DB5HDR_WIDTHCODE_16BIT:
		return bu_pshort( cp, (short)val );
	case DB5HDR_WIDTHCODE_32BIT:
		return bu_plong( cp, val );
	case DB5HDR_WIDTHCODE_64BIT:
#if defined(IRIX64)
#endif
		bu_bomb("db5_encode_length(): encountered 64-bit length\n");
	}
	bu_bomb("db5_encode_length(): unknown width code\n");
	return 0;
}

/*
 *			D B 5 _ C R A C K _ D I S K _ H E A D E R
 *
 *  Returns -
 *	0 on success
 *	-1 on error
 */
int
db5_crack_disk_header(struct db5_raw_internal *rip, const unsigned char *cp)
{
	if( cp[0] != DB5HDR_MAGIC1 )  {
		bu_log("db5_crack_disk_header() bad magic1 -- database has become corrupted\n expected x%x, got x%x\n",
			DB5HDR_MAGIC1, cp[0]);
		if( cp[0] == 'I' )
		  bu_log ("Concatenation of different database versions detected.\n");
		  bu_log ("Run 'dbupgrade' on all databases before concatenation (cat command).\n");
		
		return 0;
	}

	/* hflags */
	rip->h_dli = (cp[1] & DB5HDR_HFLAGS_DLI_MASK);
	rip->h_object_width = (cp[1] & DB5HDR_HFLAGS_OBJECT_WIDTH_MASK) >>
		DB5HDR_HFLAGS_OBJECT_WIDTH_SHIFT;
	rip->h_name_present = (cp[1] & DB5HDR_HFLAGS_NAME_PRESENT);
	rip->h_name_hidden = (cp[1] & DB5HDR_HFLAGS_HIDDEN_OBJECT);
	rip->h_name_width = (cp[1] & DB5HDR_HFLAGS_NAME_WIDTH_MASK) >>
		DB5HDR_HFLAGS_NAME_WIDTH_SHIFT;

	/* aflags */
	rip->a_width = (cp[2] & DB5HDR_AFLAGS_WIDTH_MASK) >>
		DB5HDR_AFLAGS_WIDTH_SHIFT;
	rip->a_present = (cp[2] & DB5HDR_AFLAGS_PRESENT);
	rip->a_zzz = (cp[2] & DB5HDR_AFLAGS_ZZZ_MASK);

	/* bflags */
	rip->b_width = (cp[3] & DB5HDR_BFLAGS_WIDTH_MASK) >>
		DB5HDR_BFLAGS_WIDTH_SHIFT;
	rip->b_present = (cp[3] & DB5HDR_BFLAGS_PRESENT);
	rip->b_zzz = (cp[3] & DB5HDR_BFLAGS_ZZZ_MASK);

	rip->major_type = cp[4];
	rip->minor_type = cp[5];

	if(RT_G_DEBUG&DEBUG_DB) bu_log("db5_crack_disk_header()\n\
	h_dli=%d, h_object_width=%d, h_name_present=%d, h_name_width=%d,\n\
	a_width=%d, a_present=%d, a_zzz=%d,\n\
	b_width=%d, b_present=%d, b_zzz=%d, major=%d, minor=%d\n",
		rip->h_dli,
		rip->h_object_width,
		rip->h_name_present,
		rip->h_name_width,
		rip->a_width,
		rip->a_present,
		rip->a_zzz,
		rip->b_width,
		rip->b_present,
		rip->b_zzz,
		rip->major_type,
		rip->minor_type );

	return 0;
}

/*
 *			D B 5 _ G E T _ R A W _ I N T E R N A L _ P T R
 *
 *  Returns -
 *	on success, pointer to first unused byte
 *	NULL, on error
 */
const unsigned char *
db5_get_raw_internal_ptr( struct db5_raw_internal *rip, const unsigned char *ip)
{
	const unsigned char	*cp = ip;

	if( db5_crack_disk_header( rip, cp ) < 0 )  return NULL;
	cp += sizeof(struct db5_ondisk_header);

	cp += db5_decode_length( &rip->object_length, cp, rip->h_object_width );
	rip->object_length <<= 3;	/* cvt 8-byte chunks to byte count */

	if( rip->object_length < sizeof(struct db5_ondisk_header) )  {
		bu_log("db5_get_raw_internal_ptr(): object_length=%ld is too short, database is corrupted\n",
			rip->object_length);
		return NULL;
	}

	/* Verify trailing magic number */
	if( ip[rip->object_length-1] != DB5HDR_MAGIC2 )  {
		bu_log("db5_get_raw_internal_ptr() bad magic2 -- database has become corrupted.\n expected x%x, got x%x\n",
			DB5HDR_MAGIC2, ip[rip->object_length-1] );
		return NULL;
	}

	BU_INIT_EXTERNAL( &rip->name );
	BU_INIT_EXTERNAL( &rip->body );
	BU_INIT_EXTERNAL( &rip->attributes );

	/* Grab name, if present */
	if( rip->h_name_present )  {
		cp += db5_decode_length( &rip->name.ext_nbytes,
			cp, rip->h_name_width );
		rip->name.ext_buf = (genptr_t)cp;	/* discard const */
		cp += rip->name.ext_nbytes;
	}

	/* Point to attributes, if present */
	if( rip->a_present )  {
		cp += db5_decode_length( &rip->attributes.ext_nbytes,
			cp, rip->a_width );
		rip->attributes.ext_buf = (genptr_t)cp;	/* discard const */
		cp += rip->attributes.ext_nbytes;
	}

	/* Point to body, if present */
	if( rip->b_present )  {
		cp += db5_decode_length( &rip->body.ext_nbytes,
			cp, rip->b_width );
		rip->body.ext_buf = (genptr_t)cp;	/* discard const */
		cp += rip->body.ext_nbytes;
	}

	rip->buf = NULL;	/* no buffer needs freeing */

	return ip + rip->object_length;
}

/*
 *			D B 5 _ G E T _ R A W _ I N T E R N A L _ F P
 *
 *  Returns -
 *	0 on success
 *	-1 on EOF
 *	-2 on error
 */
int
db5_get_raw_internal_fp(struct db5_raw_internal *rip, FILE *fp)
{
	struct db5_ondisk_header	header;
	unsigned char			lenbuf[8];
	int				count = 0;
	int				used;
	long				want, got;
	unsigned char			*cp;

	if( fread( (unsigned char *)&header, sizeof header, 1, fp ) != 1  )  {
		if( feof(fp) )  return -1;
		bu_log("db5_get_raw_internal_fp(): fread header error\n");
		return -2;
	}
	if( db5_crack_disk_header( rip, (unsigned char *)&header ) < 0 )
		return -2;
	used = sizeof(header);

	switch( rip->h_object_width )  {
	case DB5HDR_WIDTHCODE_8BIT:
		count = 1;
		break;
	case DB5HDR_WIDTHCODE_16BIT:
		count = 2;
		break;
	case DB5HDR_WIDTHCODE_32BIT:
		count = 4;
		break;
	case DB5HDR_WIDTHCODE_64BIT:
		count = 8;
	}
	if( fread( lenbuf, count, 1, fp )  != 1 )  {
		bu_log("db5_get_raw_internal_fp(): fread lenbuf error\n");
		return -2;
	}
	used += db5_decode_length( &rip->object_length, lenbuf, rip->h_object_width );
	rip->object_length <<= 3;	/* cvt 8-byte chunks to byte count */

	if( rip->object_length < sizeof(struct db5_ondisk_header) )  {
		bu_log("db5_get_raw_internal_fp(): object_length=%ld is too short, database is corrupted\n",
			rip->object_length);
		return -1;
	}

	/* Now that we finally know how large the object is, get it all */
	rip->buf = (unsigned char *)bu_malloc( rip->object_length, "raw v5 object" );

	*((struct db5_ondisk_header *)rip->buf) = header;	/* struct copy */
	bcopy( lenbuf, rip->buf+sizeof(header), count );

	cp = rip->buf+used;
	want = rip->object_length-used;
	BU_ASSERT_LONG( want, >, 0 );
	if( (got = fread( cp, 1, want, fp )) != want ) {
		bu_log("db5_get_raw_internal_fp(), want=%ld, got=%ld, database is too short\n",
			want, got );
		return -2;
	}

	/* Verify trailing magic number */
	if( rip->buf[rip->object_length-1] != DB5HDR_MAGIC2 )  {
		bu_log("db5_get_raw_internal_fp() bad magic2 -- database has become corrupted.\n expected x%x, got x%x\n",
			DB5HDR_MAGIC2, rip->buf[rip->object_length-1] );
		return -2;
	}

	BU_INIT_EXTERNAL( &rip->name );
	BU_INIT_EXTERNAL( &rip->body );
	BU_INIT_EXTERNAL( &rip->attributes );

	/* Grab name, if present */
	if( rip->h_name_present )  {
		cp += db5_decode_length( &rip->name.ext_nbytes,
			cp, rip->h_name_width );
		rip->name.ext_buf = (genptr_t)cp;	/* discard const */
		cp += rip->name.ext_nbytes;
	}

	/* Point to attributes, if present */
	if( rip->a_present )  {
		cp += db5_decode_length( &rip->attributes.ext_nbytes,
			cp, rip->a_width );
		rip->attributes.ext_buf = (genptr_t)cp;	/* discard const */
		cp += rip->attributes.ext_nbytes;
	}

	/* Point to body, if present */
	if( rip->b_present )  {
		cp += db5_decode_length( &rip->body.ext_nbytes,
			cp, rip->b_width );
		rip->body.ext_buf = (genptr_t)cp;	/* discard const */
		cp += rip->body.ext_nbytes;
	}

	return 0;		/* success */
}

/*
 *			D B 5 _ E X P O R T _ O B J E C T 3
 *
 *  A routine for merging together the three optional
 *  parts of an object into the final on-disk format.
 *  Results in extra data copies, but serves as a starting point for testing.
 *  Any of name, attrib, and body may be null.
 */
void
db5_export_object3(
	struct bu_external *out,
	int dli,
	const char *name,
	const unsigned char hidden,
	const struct bu_external *attrib,
	const struct bu_external *body,
	int major,
	int minor,
	int a_zzz,
	int b_zzz )
{
	struct db5_ondisk_header *odp;
	register unsigned char	*cp;
	long	namelen = 0;
	long	need;
	int	h_width, n_width, a_width, b_width;
	long	togo;

	/*
	 *  First, compute an upper bound on the size buffer needed.
	 *  Over-estimate on the length fields just to keep it simple.
	 */
	need = sizeof(struct db5_ondisk_header);
	need += 8;	/* for object_length */
	if( name )  {
		namelen = strlen(name) + 1;	/* includes null */
		if( namelen > 1 )  {
			n_width = db5_select_length_encoding(namelen);
			need += namelen + db5_enc_len[n_width];
		} else {
			name = NULL;
			namelen = 0;
			n_width = 0;
		}
	} else {
		n_width = 0;
	}
	if( attrib )  {
		BU_CK_EXTERNAL(attrib);
		if( attrib->ext_nbytes > 0 )  {
			a_width = db5_select_length_encoding(attrib->ext_nbytes);
			need += attrib->ext_nbytes + db5_enc_len[a_width];
		} else {
			attrib = NULL;
			a_width = 0;
		}
	} else {
		a_width = 0;
	}
	if( body )  {
		BU_CK_EXTERNAL(body);
		if( body->ext_nbytes > 0 )  {
			b_width = db5_select_length_encoding(body->ext_nbytes);
			need += body->ext_nbytes + db5_enc_len[b_width];
		} else {
			body = NULL;
			b_width = 0;
		}
	} else {
		b_width = 0;
	}
	need += 8;	/* pad and magic2 */

	/* Allocate the buffer for the combined external representation */
	out->ext_magic = BU_EXTERNAL_MAGIC;
	out->ext_buf = bu_malloc( need, "external object3" );
	out->ext_nbytes = need;		/* will be trimmed, below */

	/* Determine encoding for the header length field */
	h_width = db5_select_length_encoding( (need+7)>>3 );

	/* prepare combined external object */
	odp = (struct db5_ondisk_header *)out->ext_buf;
	odp->db5h_magic1 = DB5HDR_MAGIC1;

	/* hflags */
	odp->db5h_hflags = (h_width << DB5HDR_HFLAGS_OBJECT_WIDTH_SHIFT) |
			(dli & DB5HDR_HFLAGS_DLI_MASK);
	if( name )  {
		odp->db5h_hflags |= DB5HDR_HFLAGS_NAME_PRESENT |
			(n_width << DB5HDR_HFLAGS_NAME_WIDTH_SHIFT);
		
	}
	if( hidden ) {
		odp->db5h_hflags |= DB5HDR_HFLAGS_HIDDEN_OBJECT;
	}

	/* aflags */
	odp->db5h_aflags = a_width << DB5HDR_AFLAGS_WIDTH_SHIFT;
	if( attrib )  odp->db5h_aflags |= DB5HDR_AFLAGS_PRESENT;
	odp->db5h_aflags |= a_zzz & DB5HDR_AFLAGS_ZZZ_MASK;

	/* bflags */
	odp->db5h_bflags = b_width << DB5HDR_BFLAGS_WIDTH_SHIFT;
	if( body )  odp->db5h_bflags |= DB5HDR_BFLAGS_PRESENT;
	odp->db5h_bflags |= b_zzz & DB5HDR_BFLAGS_ZZZ_MASK;

	if( a_zzz || b_zzz )  bu_bomb("db5_export_object3: compression not supported yet\n");

	/* Object_Type */
	odp->db5h_major_type = major;
	odp->db5h_minor_type = minor;

	/* Build up the rest of the record */
	cp = ((unsigned char *)out->ext_buf) + sizeof(struct db5_ondisk_header);
	cp = db5_encode_length( cp, 7L, h_width );	/* will be replaced below */

	if( name )  {
		cp = db5_encode_length( cp, namelen, n_width );
		bcopy( name, cp, namelen );	/* includes null */
		cp += namelen;
	}

	if( attrib )  {
		/* minimum buffer length is a one byte attribute name, followed by a NULL name termination,
		 * followed by no bytes (for an empty value), followed by a NULL value termination,
		 * followed by a NULL attribute-value termination. Minimum is 4 bytes
		 */
BU_ASSERT_PTR( attrib->ext_nbytes, >=, 4 );
		cp = db5_encode_length( cp, attrib->ext_nbytes, a_width );
		bcopy( attrib->ext_buf, cp, attrib->ext_nbytes );
		cp += attrib->ext_nbytes;
	}

	if( body )  {
		cp = db5_encode_length( cp, body->ext_nbytes, b_width );
		bcopy( body->ext_buf, cp, body->ext_nbytes );
		cp += body->ext_nbytes;
	}

	togo = cp - ((unsigned char *)out->ext_buf) + 1;
	togo &= 7;
	if( togo != 0 )  {
		togo = 8 - togo;
		while( togo-- > 0 )  *cp++ = '\0';
	}
	*cp++ = DB5HDR_MAGIC2;

	/* Verify multiple of 8 */
	togo = cp - ((unsigned char *)out->ext_buf);
	BU_ASSERT_LONG( togo&7, ==, 0 );

	/* Finally, go back to the header and write the actual object length */
	cp = ((unsigned char *)out->ext_buf) + sizeof(struct db5_ondisk_header);
	cp = db5_encode_length( cp, togo>>3, h_width );

	out->ext_nbytes = togo;
	BU_ASSERT_LONG( out->ext_nbytes, >=, 8 );
}

/*
 *			D B 5 _ M A K E _ F R E E _ O B J E C T _ H D R
 *
 *  Make only the front (header) portion of a free object.
 *  This is used when operating on very large contiguous free objects
 *  in the database (e.g. 50 MBytes).
 */
void
db5_make_free_object_hdr( struct bu_external *ep, long length )
{
	struct db5_ondisk_header *odp;
	int		h_width;
	unsigned char	*cp;

	BU_CK_EXTERNAL(ep);

	BU_ASSERT_LONG( length, >=, 8 );
	BU_ASSERT_LONG( length&7, ==, 0 );

	/* Reserve enough space to hold any free header, even w/64-bit len */
	ep->ext_nbytes = 8+8;
	ep->ext_buf = bu_calloc( 1, ep->ext_nbytes, "db5_make_free_object_hdr" );

	/* Determine encoding for the header length field */
	h_width = db5_select_length_encoding( length>>3 );

	/* prepare header of external object */
	odp = (struct db5_ondisk_header *)ep->ext_buf;
	odp->db5h_magic1 = DB5HDR_MAGIC1;
	odp->db5h_hflags = (h_width << DB5HDR_HFLAGS_OBJECT_WIDTH_SHIFT) |
			DB5HDR_HFLAGS_DLI_FREE_STORAGE;

	cp = ((unsigned char *)ep->ext_buf) + sizeof(struct db5_ondisk_header);
	cp = db5_encode_length( cp, length>>3, h_width );
}

/*
 *			D B 5 _ M A K E _ F R E E _ O B J E C T
 *
 *  Make a complete, zero-filled, free object.
 *  Note that free objects can sometimes get quite large.
 */
void
db5_make_free_object( struct bu_external *ep, long length )
{
	struct db5_ondisk_header *odp;
	int		h_width;
	unsigned char	*cp;

	BU_CK_EXTERNAL(ep);

	BU_ASSERT_LONG( length, >=, 8 );
	BU_ASSERT_LONG( length&7, ==, 0 );

	ep->ext_buf = bu_calloc( 1, length, "db5_make_free_object" );
	ep->ext_nbytes = length;

	/* Determine encoding for the header length field */
	h_width = db5_select_length_encoding( length>>3 );

	/* prepare combined external object */
	odp = (struct db5_ondisk_header *)ep->ext_buf;
	odp->db5h_magic1 = DB5HDR_MAGIC1;
	odp->db5h_hflags = (h_width << DB5HDR_HFLAGS_OBJECT_WIDTH_SHIFT) |
			DB5HDR_HFLAGS_DLI_FREE_STORAGE;

	cp = ((unsigned char *)ep->ext_buf) + sizeof(struct db5_ondisk_header);
	cp = db5_encode_length( cp, length>>3, h_width );

	cp = ((unsigned char *)ep->ext_buf) + length-1;
	*cp = DB5HDR_MAGIC2;
}

/*
 *			D B 5 _ I M P O R T _ A T T R I B U T E S
 *
 *  Convert the on-disk encoding into a handy easy-to-use
 *  bu_attribute_value_set structure.
 *  Take advantage of the readonly_min/readonly_max capability
 *  so that we don't have to bu_strdup() each string, but can
 *  simply point to it in the provided buffer *ap.
 *  Important implication:  don't free *ap until you're done with this avs.
 *
 *  The upshot of this is that bu_avs_add() and bu_avs_remove() can
 *  be safely used with this *avs.
 *
 *  The input *avs should not have been previously initialized.
 *
 *  Returns -
 *	>0	count of attributes successfully imported
 *	-1	Error, mal-formed input
 */
int
db5_import_attributes( struct bu_attribute_value_set *avs, const struct bu_external *ap )
{
	const char	*cp;
	const char	*ep;
	int		count = 0;


	BU_CK_EXTERNAL(ap);

	BU_ASSERT_LONG( ap->ext_nbytes, >=, 4 );

	/* First pass -- count number of attributes */
	cp = (const char *)ap->ext_buf;
	ep = (const char *)ap->ext_buf+ap->ext_nbytes;

	/* Null "name" string indicates end of attribute list */
	while( *cp != '\0' )  {
		if( cp >= ep )  {
			bu_log("db5_import_attributes() ran off end of buffer, database is corrupted\n");
			return -1;
		}
		cp += strlen(cp)+1;	/* name */
		cp += strlen(cp)+1;	/* value */
		count++;
	}
	/* Ensure we're exactly at the end */
	BU_ASSERT_PTR( cp+1, ==, ep );

	bu_avs_init( avs, count+3, "db5_import_attributes" );

#if 0
	/* XXX regression test "shaders.sh" bombs when this code is used! */
	/* Conserve malloc/free activity -- use strings in input buffer */
	/* Signal region of memory that input comes from */
	avs->readonly_min = ap->ext_buf;
	avs->readonly_max = avs->readonly_min + ap->ext_nbytes-1;

	/* Second pass -- populate attributes.  Peek inside struct. */
	cp = (const char *)ap->ext_buf;
	app = avs->avp;
	while( *cp != '\0' )  {
		app->name = cp;
		cp += strlen(cp)+1;	/* name */
		app->value = cp;
		cp += strlen(cp)+1;	/* value */
		app++;
		avs->count++;
	}
	app->name = NULL;
	app->value = NULL;
#else
	/* Expensive but safer version */
	cp = (const char *)ap->ext_buf;
	while( *cp != '\0' )  {
		const char	*newname = cp;
		cp += strlen(cp)+1;	/* name */
		bu_avs_add( avs, newname, cp );
		cp += strlen(cp)+1;	/* value */
	}
#endif
	BU_ASSERT_PTR( cp+1, ==, ep );
	BU_ASSERT_LONG( avs->count, <, avs->max );
	BU_ASSERT_LONG( avs->count, ==, count );

if(bu_debug & BU_DEBUG_AVS)  bu_avs_print(avs, "db5_import_attributes");
	return avs->count;
}

/*
 *			D B 5 _ E X P O R T _ A T T R I B U T E S
 *
 *  Encode the attribute-value pair information into the external
 *  on-disk format.
 *
 *  The on-disk encoding is:
 *
 *	aname1 NULL value1 NULL ... anameN NULL valueN NULL NULL
 *
 *  'ext' is initialized on behalf of the caller.
 */
void
db5_export_attributes( struct bu_external *ext, const struct bu_attribute_value_set *avs )
{
	int	need = 0;
	const struct bu_attribute_value_pair	*avpp;
	char	*cp;
	int	i;

	BU_CK_AVS( avs );
	avpp = avs->avp;

	BU_INIT_EXTERNAL(ext);
	if( avs->count <= 0 )  return;
if(bu_debug & BU_DEBUG_AVS)  bu_avs_print(avs, "db5_export_attributes");

	/* First pass -- determine how much space is required */
	for( i = 0; i < avs->count; i++, avpp++ )  {
		need += strlen( avpp->name ) + strlen( avpp->value ) + 2;
	}
	if( need <= 0 )  return;
	need += 1;		/* for final null */

	ext->ext_nbytes = need;
	ext->ext_buf = bu_malloc( need, "external attributes" );

	/* Second pass -- store in external form */
	cp = (char *)ext->ext_buf;
	avpp = avs->avp;
	for( i = 0; i < avs->count; i++, avpp++ )  {
		need = strlen( avpp->name ) + 1;
		bcopy( avpp->name, cp, need );
		cp += need;

		need = strlen( avpp->value ) + 1;
		bcopy( avpp->value, cp, need );
		cp += need;
	}
	*cp++ = '\0';
	need = cp - ((char *)ext->ext_buf);
	BU_ASSERT_LONG( need, ==, ext->ext_nbytes );
}



/*
 *			D B 5 _ R E P L A C E _ A T T R I B U T E S
 *
 *  Replace the attributes of a given database object.
 *  For efficiency, this is done without looking at the object body at all.
 *
 *  Contents of the bu_attribute_value_set are freed, but not the struct itself.
 *
 *  Returns -
 *	0 on success
 *	<0 on error
 */
int
db5_replace_attributes( struct directory *dp, struct bu_attribute_value_set *avsp, struct db_i *dbip )
{
	struct bu_external	ext;
	struct db5_raw_internal	raw;
	struct bu_external	attr;
	struct bu_external	ext2;
	int			ret;

	RT_CK_DIR(dp);
	BU_CK_AVS(avsp);
	RT_CK_DBI(dbip);

	if(RT_G_DEBUG&DEBUG_DB)  {
		bu_log("db5_replace_attributes(%s) dbip=x%x\n",
			dp->d_namep, dbip );
		bu_avs_print( avsp, "new attributes" );
	}

	if( dbip->dbi_read_only )  {
		bu_log("db5_replace_attributes(%s):  READ-ONLY file\n",
			dbip->dbi_filename);
		return -1;
	}

	BU_ASSERT_LONG( dbip->dbi_version, ==, 5 );

	if( db_get_external( &ext, dp, dbip ) < 0 )
		return -2;		/* FAIL */

	if (db5_get_raw_internal_ptr(&raw, ext.ext_buf) == NULL) {
		bu_log("db5_replace_attributes(%s):  import failure\n",
			dp->d_namep );
		bu_free_external( &ext );
		return -3;
	}

	db5_export_attributes( &attr, avsp );
	BU_INIT_EXTERNAL(&ext2);
	db5_export_object3( &ext2,
		raw.h_dli,
		dp->d_namep,
		raw.h_name_hidden,
		&attr,
		&raw.body,
		raw.major_type, raw.minor_type,
		raw.a_zzz, raw.b_zzz );

	/* Write it */
	ret = db_put_external5( &ext2, dp, dbip );
	if( ret < 0 )  bu_log("db5_update_attributes(%s):  db_put_external5() failure\n",
		dp->d_namep );

	bu_free_external( &attr );
	bu_free_external( &ext2 );
	bu_free_external( &ext );		/* 'raw' is now invalid */
	bu_avs_free( avsp );

	return ret;
}

/*
 *			D B 5 _ U P D A T E _ A T T R I B U T E S
 *
 *  Update an arbitrary number of attributes on a given database object.
 *  For efficiency, this is done without looking at the object body at all.
 *
 *  Contents of the bu_attribute_value_set are freed, but not the struct itself.
 *
 *  Returns -
 *	0 on success
 *	<0 on error
 */
int
db5_update_attributes( struct directory *dp, struct bu_attribute_value_set *avsp, struct db_i *dbip )
{
	struct bu_external	ext;
	struct db5_raw_internal	raw;
	struct bu_attribute_value_set old_avs;
	struct bu_external	attr;
	struct bu_external	ext2;
	int			ret;

	RT_CK_DIR(dp);
	BU_CK_AVS(avsp);
	RT_CK_DBI(dbip);

	if(RT_G_DEBUG&DEBUG_DB)  {
		bu_log("db5_update_attributes(%s) dbip=x%x\n",
			dp->d_namep, dbip );
		bu_avs_print( avsp, "new attributes" );
	}

	if( dbip->dbi_read_only )  {
		bu_log("db5_update_attributes(%s):  READ-ONLY file\n",
			dbip->dbi_filename);
		return -1;
	}

	BU_ASSERT_LONG( dbip->dbi_version, ==, 5 );

	if( db_get_external( &ext, dp, dbip ) < 0 )
		return -2;		/* FAIL */

	if (db5_get_raw_internal_ptr(&raw, ext.ext_buf) == NULL) {
		bu_log("db5_update_attributes(%s):  import failure\n",
			dp->d_namep );
		bu_free_external( &ext );
		return -3;
	}

	if( raw.attributes.ext_buf )  {
		if( db5_import_attributes( &old_avs, &raw.attributes ) < 0 )  {
			bu_log("db5_update_attributes(%s):  mal-formed attributes in database\n",
				dp->d_namep );
			bu_free_external( &ext );
			return -8;
		}
	} else {
		bu_avs_init( &old_avs, 4, "db5_update_attributes" );
	}

	bu_avs_merge( &old_avs, avsp );

	db5_export_attributes( &attr, &old_avs );
	BU_INIT_EXTERNAL(&ext2);
	db5_export_object3( &ext2,
		raw.h_dli,
		dp->d_namep,
		raw.h_name_hidden,
		&attr,
		&raw.body,
		raw.major_type, raw.minor_type,
		raw.a_zzz, raw.b_zzz );

	/* Write it */
	ret = db_put_external5( &ext2, dp, dbip );
	if( ret < 0 )  bu_log("db5_update_attributes(%s):  db_put_external5() failure\n",
		dp->d_namep );

	bu_free_external( &attr );
	bu_free_external( &ext2 );
	bu_free_external( &ext );		/* 'raw' is now invalid */
	bu_avs_free( &old_avs );
	bu_avs_free( avsp );

	return ret;
}

/*
 *			D B 5 _ U P D A T E _ A T T R I B U T E
 *
 *  A convenience routine to update the value of a single attribute.
 *
 *  Returns -
 *	0 on success
 *	<0 on error
 */
int
db5_update_attribute( const char *obj_name, const char *aname, const char *value, struct db_i *dbip )
{
	struct directory	*dp;
	struct bu_attribute_value_set avs;

	RT_CK_DBI(dbip);
	if( (dp = db_lookup( dbip, obj_name, LOOKUP_NOISY )) == DIR_NULL )
		return -1;

	bu_avs_init( &avs, 2, "db5_update_attribute" );
	bu_avs_add( &avs, aname, value );

	return db5_update_attributes( dp, &avs, dbip );
}

/*
 *			D B 5 _ U P D A T E _ I D E N T
 *
 *  Update the _GLOBAL object, which in v5 serves the place of the
 *  "ident" header record in v4 as the place to stash global information.
 *  Since every database will have one of these things,
 *  it's no problem to update it.
 *
 * Returns -
 *	 0	Success
 *	-1	Fatal Error
 */
int db5_update_ident( struct db_i *dbip, const char *title, double local2mm )
{
	struct bu_attribute_value_set	avs;
	struct directory		*dp;
	struct bu_vls			units;
	int				ret;

	RT_CK_DBI(dbip);

	if( (dp = db_lookup( dbip, DB5_GLOBAL_OBJECT_NAME, LOOKUP_QUIET )) == DIR_NULL )  {
		struct bu_external	global;
		unsigned char		minor_type=0;

		bu_log("db5_update_ident() WARNING: %s object is missing, creating new one.\nYou may have lost important global state when you deleted this object.\n",
			DB5_GLOBAL_OBJECT_NAME );

		/* OK, make one.  It will be empty to start with, updated below. */
		db5_export_object3( &global,
			DB5HDR_HFLAGS_DLI_APPLICATION_DATA_OBJECT,
			DB5_GLOBAL_OBJECT_NAME, DB5HDR_HFLAGS_HIDDEN_OBJECT, NULL, NULL,
			DB5_MAJORTYPE_ATTRIBUTE_ONLY, 0,
			DB5_ZZZ_UNCOMPRESSED, DB5_ZZZ_UNCOMPRESSED );

		dp = db_diradd( dbip, DB5_GLOBAL_OBJECT_NAME, -1L, 0, 0, (genptr_t)&minor_type);
		dp->d_major_type = DB5_MAJORTYPE_ATTRIBUTE_ONLY;
		if( db_put_external( &global, dp, dbip ) < 0 )  {
			bu_log("db5_update_ident() unable to create replacement %s object!\n", DB5_GLOBAL_OBJECT_NAME );
			bu_free_external(&global);
			return -1;
		}
		bu_free_external(&global);
	}

	bu_vls_init( &units );
	bu_vls_printf( &units, "%.25e", local2mm );

	bu_avs_init( &avs, 4, "db5_update_ident" );
	bu_avs_add( &avs, "title", title );
	bu_avs_add( &avs, "units", bu_vls_addr(&units) );

	ret = db5_update_attributes( dp, &avs, dbip );
	bu_vls_free( &units );

	dbip->dbi_title = bu_strdup(title);

	return ret;
}

/*
 *			D B 5 _ F W R I T E _ I D E N T
 *
 *  Create a header for a v5 database.
 *  This routine has the same calling sequence as db_fwrite_ident()
 *  which makes a v4 database header.
 *
 *  In the v5 database, two database objects must be created to
 *  match the semantics of what was in the v4 header:
 *
 *  First, a database header object.
 *
 *  Second, create a specially named attribute-only object which
 *  contains the attributes "title=" and "units=".
 *
 *  This routine should only be used by db_create().
 *  Everyone else should use db5_update_ident().
 *
 * Returns -
 *	 0	Success
 *	-1	Fatal Error
 */
int
db5_fwrite_ident(FILE *fp, const char *title, double local2mm)
{
	struct bu_attribute_value_set avs;
	struct bu_vls		units;
	struct bu_external	out;
	struct bu_external	attr;

	if( local2mm <= 0 )  {
		bu_log("db5_fwrite_ident(%s, %g) local2mm <= 0\n",
			title, local2mm );
		return -1;
	}

	/* First, write the header object */
	db5_export_object3( &out, DB5HDR_HFLAGS_DLI_HEADER_OBJECT,
		NULL, 0, NULL, NULL,
		DB5_MAJORTYPE_RESERVED, 0,
		DB5_ZZZ_UNCOMPRESSED, DB5_ZZZ_UNCOMPRESSED );
	if( bu_fwrite_external( fp, &out ) < 0 )  return -1;
	bu_free_external( &out );

	/* Second, create the attribute-only object */
	bu_vls_init( &units );
	bu_vls_printf( &units, "%.25e", local2mm );

	bu_avs_init( &avs, 4, "db5_fwrite_ident" );
	bu_avs_add( &avs, "title", title );
	bu_avs_add( &avs, "units", bu_vls_addr(&units) );

	db5_export_attributes( &attr, &avs );
	db5_export_object3( &out, DB5HDR_HFLAGS_DLI_APPLICATION_DATA_OBJECT,
		DB5_GLOBAL_OBJECT_NAME, DB5HDR_HFLAGS_HIDDEN_OBJECT, &attr, NULL,
		DB5_MAJORTYPE_ATTRIBUTE_ONLY, 0,
		DB5_ZZZ_UNCOMPRESSED, DB5_ZZZ_UNCOMPRESSED );
	if( bu_fwrite_external( fp, &out ) < 0 )  return -1;
	bu_free_external( &out );
	bu_free_external( &attr );
	bu_avs_free( &avs );

	bu_vls_free( &units );

	return 0;
}

/*
 *			R T _ D B _ C V T _ T O _ E X T E R N A L 5
 *
 *  The attributes are taken from ip->idb_avs
 *
 *  If present, convert attributes to on-disk format.
 *  This must happen after exporting the body, in case the
 *  ft_export5() method happened to extend the attribute set.
 *  Combinations are one "solid" which does this.
 *
 *  The internal representation is NOT freed, that's the caller's job.
 *
 *  The 'ext' pointer is accepted in uninitialized form, and
 *  an initialized structure is always returned, so that
 *  the caller may free it even when an error return is given.
 *
 *  Returns -
 *	0	OK
 *	-1	FAIL
 */
int
rt_db_cvt_to_external5(
	struct bu_external *ext,
	const char *name,
	const struct rt_db_internal *ip,
	double conv2mm,
	struct db_i *dbip,
	struct resource *resp,
	const int major)
{
	struct bu_external	attributes;
	struct bu_external	body;
	int			minor;

	RT_CK_DB_INTERNAL( ip );
	if(dbip) RT_CK_DBI(dbip);	/* may be null */
	RT_CK_RESOURCE(resp);
	BU_INIT_EXTERNAL( &body );

	minor = ip->idb_type;	/* XXX not necessarily v5 numbers. */

	/* Scale change on export is 1.0 -- no change */
	if( ip->idb_meth->ft_export5( &body, ip, conv2mm, dbip, resp, minor ) < 0 )  {
		bu_log("rt_db_cvt_to_external5(%s):  ft_export5 failure\n",
			name);
		bu_free_external( &body );
		BU_INIT_EXTERNAL(ext);
		return -1;		/* FAIL */
	}
	BU_CK_EXTERNAL( &body );

	/* If present, convert attributes to on-disk format. */
	if( ip->idb_avs.magic == BU_AVS_MAGIC )  {
		db5_export_attributes( &attributes, &ip->idb_avs );
		BU_CK_EXTERNAL( &attributes );
	} else {
		BU_INIT_EXTERNAL(&attributes);
	}

	db5_export_object3( ext, DB5HDR_HFLAGS_DLI_APPLICATION_DATA_OBJECT,
		name, 0, &attributes, &body,
		major, minor,
		DB5_ZZZ_UNCOMPRESSED, DB5_ZZZ_UNCOMPRESSED );
	BU_CK_EXTERNAL( ext );
	bu_free_external( &body );
	bu_free_external( &attributes );

	return 0;		/* OK */
}

/*
 *			D B _ W R A P _ V 5 _ E X T E R N A L
 *
 *  Modify name of external object, if necessary.
 */
int
db_wrap_v5_external( struct bu_external *ep, const char *name )
{
	struct db5_raw_internal	raw;
	struct bu_external	tmp;

	BU_CK_EXTERNAL(ep);

	/* Crack the external form into parts */
	if( db5_get_raw_internal_ptr( &raw, (unsigned char *)ep->ext_buf ) == NULL )  {
		bu_log("db_put_external5(%s) failure in db5_get_raw_internal_ptr()\n",
			name);
		return -1;
	}
	BU_ASSERT_LONG( raw.h_dli, ==, DB5HDR_HFLAGS_DLI_APPLICATION_DATA_OBJECT );

	/* See if name needs to be changed */
	if( raw.name.ext_buf == NULL || strcmp( name, raw.name.ext_buf ) != 0 )  {
		/* Name needs to be changed.  Create new external form.
		 * Make temporary copy so input isn't smashed
		 * as new external object is constructed.
		 */
		tmp = *ep;		/* struct copy */
		BU_INIT_EXTERNAL(ep);

		db5_export_object3( ep,
			DB5HDR_HFLAGS_DLI_APPLICATION_DATA_OBJECT,
			name,
			raw.h_name_hidden,
			&raw.attributes,
			&raw.body,
			raw.major_type, raw.minor_type,
			raw.a_zzz, raw.b_zzz );
		/* 'raw' is invalid now, 'ep' has new external form. */
		bu_free_external( &tmp );
		return 0;
	}

	/* No changes needed, input object is properly named */
	return 0;
}


/*
 *
 *			D B _ P U T _ E X T E R N A L 5
 *
 *  Given that caller already has an external representation of
 *  the database object,  update it to have a new name
 *  (taken from dp->d_namep) in that external representation,
 *  and write the new object into the database, obtaining different storage if
 *  the size has changed.
 *
 *  Changing the name on a v5 object is a relatively expensive operation.
 *
 *  Caller is responsible for freeing memory of external representation,
 *  using bu_free_external().
 *
 *  This routine is used to efficiently support MGED's "cp" and "keep"
 *  commands, which don't need to import and decompress
 *  objects just to rename and copy them.
 *
 *  Returns -
 *	-1	error
 *	 0	success
 */
int
db_put_external5(struct bu_external *ep, struct directory *dp, struct db_i *dbip)
{
	RT_CK_DBI(dbip);
	RT_CK_DIR(dp);
	BU_CK_EXTERNAL(ep);

	if(RT_G_DEBUG&DEBUG_DB) bu_log("db_put_external5(%s) ep=x%x, dbip=x%x, dp=x%x\n",
		dp->d_namep, ep, dbip, dp );

	if( dbip->dbi_read_only )  {
		bu_log("db_put_external5(%s):  READ-ONLY file\n",
			dbip->dbi_filename);
		return -1;
	}

	BU_ASSERT_LONG( dbip->dbi_version, ==, 5 );

	/* First, change the name. */
	if( db_wrap_v5_external( ep, dp->d_namep ) < 0 )  {
		bu_log("db_put_external5(%s) failure in db_wrap_v5_external()\n",
			dp->d_namep);
		return -1;
	}

	/* Second, obtain storage for final object */
	if( ep->ext_nbytes != dp->d_len || dp->d_addr == -1L )  {
		if( db5_realloc( dbip, dp, ep ) < 0 )  {
			bu_log("db_put_external(%s) db_realloc5() failed\n", dp->d_namep);
			return -5;
		}
	}
	BU_ASSERT_LONG( ep->ext_nbytes, ==, dp->d_len );

	if( dp->d_flags & RT_DIR_INMEM )  {
		bcopy( (char *)ep->ext_buf, dp->d_un.ptr, ep->ext_nbytes );
		return 0;
	}

	if( db_write( dbip, (char *)ep->ext_buf, ep->ext_nbytes, dp->d_addr ) < 0 )  {
		return -1;
	}
	return 0;
}

/*
 *			R T _ D B _ P U T _ I N T E R N A L 5
 *
 *  Convert the internal representation of a solid to the external one,
 *  and write it into the database.
 *
 *  Applications and middleware shouldn't call this directly, they
 *  should use the version-generic interface "rt_db_put_internal()".
 *
 *  The internal representation is always freed.
 *  (Not the pointer, just the contents).
 *
 *  Returns -
 *	<0	error
 *	 0	success
 */
int
rt_db_put_internal5(
	struct directory	*dp,
	struct db_i		*dbip,
	struct rt_db_internal	*ip,
	struct resource		*resp,
	const int		major)
{
	struct bu_external	ext;

	RT_CK_DIR(dp);
	RT_CK_DBI(dbip);
	RT_CK_DB_INTERNAL( ip );
	RT_CK_RESOURCE(resp);

	BU_ASSERT_LONG( dbip->dbi_version, ==, 5 );

	if( rt_db_cvt_to_external5( &ext, dp->d_namep, ip, 1.0, dbip, resp, major ) < 0 )  {
		bu_log("rt_db_put_internal5(%s):  export failure\n",
			dp->d_namep);
		goto fail;
	}
	BU_CK_EXTERNAL( &ext );

	if( ext.ext_nbytes != dp->d_len || dp->d_addr == -1L )  {
		if( db5_realloc( dbip, dp, &ext ) < 0 )  {
			bu_log("rt_db_put_internal5(%s) db_realloc5() failed\n", dp->d_namep);
			goto fail;
		}
	}
	BU_ASSERT_LONG( ext.ext_nbytes, ==, dp->d_len );

	if( dp->d_flags & RT_DIR_INMEM )  {
		bcopy( (char *)ext.ext_buf, dp->d_un.ptr, ext.ext_nbytes );
		goto ok;
	}

	if( db_write( dbip, (char *)ext.ext_buf, ext.ext_nbytes, dp->d_addr ) < 0 )  {
		goto fail;
	}
ok:
	bu_free_external( &ext );
	rt_db_free_internal( ip, resp );
	return 0;			/* OK */

fail:
	bu_free_external( &ext );
	rt_db_free_internal( ip, resp );
	return -2;		/* FAIL */
}

/*
 *			R T _ D B _ E X T E R N A L 5 _ T O _ I N T E R N A L 5
 *
 *  Given an object in external form, convert it to internal form.
 *  The caller is responsible for freeing the external form.
 *
 *  Returns -
 *	<0	On error
 *	id	On success.
 */
int
rt_db_external5_to_internal5(
	struct rt_db_internal		*ip,
	const struct bu_external	*ep,
	const char			*name,
	const struct db_i		*dbip,
	const mat_t			mat,
	struct resource			*resp)
{
	register int		id;
	struct db5_raw_internal	raw;

	BU_CK_EXTERNAL(ep);
	RT_CK_DB_INTERNAL(ip);
	RT_CK_DBI(dbip);

	BU_ASSERT_LONG( dbip->dbi_version, ==, 5 );

	if (db5_get_raw_internal_ptr(&raw, ep->ext_buf) == NULL) {
		bu_log("rt_db_external5_to_internal5(%s):  import failure\n",
			name );
		return -3;
	}

	if(( raw.major_type == DB5_MAJORTYPE_BRLCAD )
	 ||( raw.major_type == DB5_MAJORTYPE_BINARY_UNIF)) {
		/* As a convenience to older ft_import routines */
		if( mat == NULL )  mat = bn_mat_identity;
	} else {
		bu_log("rt_db_external5_to_internal5(%s):  unable to import non-BRL-CAD object, major=%d\n",
			name, raw.major_type );
		return -1;		/* FAIL */
	}

	/* If attributes are present in the object, make them available
	 * in the internal form.
	 */
	if( raw.attributes.ext_buf )  {
		if( db5_import_attributes( &ip->idb_avs, &raw.attributes ) < 0 )  {
			bu_log("rt_db_external5_to_internal5(%s):  mal-formed attributes in database\n",
				name );
			return -8;
		}
	}

	if( !raw.body.ext_buf )  {
		bu_log("rt_db_external5_to_internal5(%s):  object has no body\n",
			name );
		return -4;
	}

	/*
	 *	XXX	This is a kludge, but it works for starters
	 */
	switch ( raw.major_type ) {
	    case DB5_MAJORTYPE_BRLCAD:
		id = raw.minor_type; break;
	    case DB5_MAJORTYPE_BINARY_UNIF:
		id = ID_BINUNIF; break;
	    default:
		bu_log("rt_db_external5_to_internal5(%s): don't yet handle major_type %d\n", name, raw.major_type);
		return -1;
	}
	/* ip has already been initialized, and should not be re-initted */
	if( rt_functab[id].ft_import5( ip, &raw.body, mat, dbip, resp, raw.minor_type ) < 0 )  {
		bu_log("rt_db_external5_to_internal5(%s):  import failure\n",
			name );
		rt_db_free_internal( ip, resp );
		return -1;		/* FAIL */
	}
	/* Don't free &raw.body */

	RT_CK_DB_INTERNAL( ip );
	ip->idb_major_type = raw.major_type;
	ip->idb_minor_type = raw.minor_type;
	ip->idb_meth = &rt_functab[id];

	return id;			/* OK */
}

/*
 *			R T _ D B _ G E T _ I N T E R N A L 5
 *
 *  Get an object from the database, and convert it into it's internal
 *  representation.
 *
 *  Applications and middleware shouldn't call this directly, they
 *  should use the generic interface "rt_db_get_internal()".
 *
 *  Returns -
 *	<0	On error
 *	id	On success.
 */
int
rt_db_get_internal5(
	struct rt_db_internal	*ip,
	const struct directory	*dp,
	const struct db_i	*dbip,
	const mat_t		mat,
	struct resource		*resp)
{
	struct bu_external	ext;
	int			ret;

	BU_INIT_EXTERNAL(&ext);
	RT_INIT_DB_INTERNAL(ip);

	BU_ASSERT_LONG( dbip->dbi_version, ==, 5 );

	if( db_get_external( &ext, dp, dbip ) < 0 )
		return -2;		/* FAIL */

	ret = rt_db_external5_to_internal5( ip, &ext, dp->d_namep, dbip, mat, resp );
	bu_free_external(&ext);
	return ret;
}

/*
 *  XXX The material head should be attached to the db_i, not global.
 */
void
db5_export_color_table( struct bu_vls *ostr, struct db_i *dbip )
{
	struct mater *mp;

	BU_CK_VLS(ostr);
	RT_CK_DBI(dbip);

	for( mp = rt_material_head; mp != MATER_NULL; mp = mp->mt_forw )  {
		bu_vls_printf(ostr,
			"{%d %d %d %d %d} ",
			mp->mt_low,
			mp->mt_high,
			mp->mt_r,
			mp->mt_g,
			mp->mt_b );
	}
}

/*
 *			D B 5 _ I M P O R T _ C O L O R _ T A B L E
 */
void
db5_import_color_table( char *cp )
{
	char	*sp = cp;
	int	low, high, r, g, b;

	while( (sp = strchr( sp, '{' )) != NULL )  {
		sp++;
		if( sscanf( sp, "%d %d %d %d %d", &low, &high, &r, &g, &b ) != 5 )  break;
		rt_color_addrec( low, high, r, g, b, -1L );
	}
}

/*
 *			D B 5 _ P U T _ C O L O R _ T A B L E
 *
 *  Put the old region-id-color-table into the global object.
 *  A null attribute is set if the material table is empty.
 *
 *  Returns -
 *	<0	error
 *	0	OK
 */
int
db5_put_color_table( struct db_i *dbip )
{
	struct bu_vls	str;
	int	ret;

	RT_CK_DBI(dbip);
	BU_ASSERT_LONG( dbip->dbi_version, ==, 5 );

	bu_vls_init(&str);
	db5_export_color_table( &str, dbip );

	ret = db5_update_attribute( DB5_GLOBAL_OBJECT_NAME,
		"regionid_colortable", bu_vls_addr(&str), dbip );

	bu_vls_free( &str );
	return ret;
}

/*			D B _ G E T _ A T T R I B U T E S
 *
 *	Get attributes for an object pointed to by *dp
 *
 *	returns:
 *		0 - all is well
 *		<0 - error
 */
int
db5_get_attributes( const struct db_i *dbip, struct bu_attribute_value_set *avs, const struct directory *dp )
{
	struct bu_external	ext;
	struct db5_raw_internal	raw;

	RT_CK_DBI( dbip );

	if( dbip->dbi_version < 5 )
		return 0;	/* not an error, just no attributes */

	RT_CK_DIR( dp );

	BU_INIT_EXTERNAL(&ext);

	if( db_get_external( &ext, dp, dbip ) < 0 )
		return -1;		/* FAIL */

	if (db5_get_raw_internal_ptr(&raw, ext.ext_buf) == NULL) {
		bu_free_external( &ext );
		return -2;
	}

	if( raw.attributes.ext_buf )  {
		if( db5_import_attributes( avs, &raw.attributes ) < 0 ) {
			bu_free_external( &ext );
			return -3;
		}
	} else {
		bu_avs_init( avs, 0, "db_get_attributes" );
	}

	bu_free_external( &ext );
	return 0;
}
@


11.73
log
@change conf.h to a wrapped config.h
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/librt/db5_io.c,v 11.72 2004/04/05 08:48:56 morrison Exp $ (ARL)";
@


11.72
log
@merge of ansi-6-0-branch into HEAD
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d20 5
a24 1
#include "conf.h"
@


11.71
log
@Same fix as previous, different place
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_io.c,v 11.70 2002/10/31 19:29:50 jra Exp $ (ARL)";
d58 1
a58 2
db5_header_is_valid( hp )
const unsigned char *hp;
d101 1
a101 2
db5_select_length_encoding( len )
long len;
d121 1
a121 4
db5_decode_length( lenp, cp, format )
long			*lenp;
const unsigned char	*cp;
int			format;
d158 1
a158 4
db5_decode_signed( lenp, cp, format )
long			*lenp;
const unsigned char	*cp;
int			format;
d224 1
a224 3
db5_crack_disk_header( rip, cp )
struct db5_raw_internal		*rip;
const unsigned char		*cp;
d353 1
a353 3
db5_get_raw_internal_fp( rip, fp )
struct db5_raw_internal	*rip;
FILE			*fp;
d1096 1
a1096 4
db5_fwrite_ident( fp, title, local2mm )
FILE		*fp;
const char	*title;
double		local2mm;
@


11.70
log
@db5_export_object3() had an assertion that the exported form of a attribute/value pair must be at least 5 bytes.
This assumes at least one byte for the value. If the value is the empty string, 4 bytes can occur. changed
assertion to 4 bytes
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_io.c,v 11.69 2002/08/20 17:07:57 jra Exp $ (ARL)";
d724 1
a724 1
	BU_ASSERT_LONG( ap->ext_nbytes, >=, 5 );
@


11.69
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_io.c,v 11.67 2001/10/04 18:49:07 tranese Exp $ (ARL)";
d586 5
a590 1
BU_ASSERT_PTR( attrib->ext_nbytes, >=, 5 );
@


11.69.4.1
log
@sync to HEAD...
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/db5_io.c,v 11.71 2002/10/31 19:34:20 jra Exp $ (ARL)";
d586 1
a586 5
		/* minimum buffer length is a one byte attribute name, followed by a NULL name termination,
		 * followed by no bytes (for an empty value), followed by a NULL value termination,
		 * followed by a NULL attribute-value termination. Minimum is 4 bytes
		 */
BU_ASSERT_PTR( attrib->ext_nbytes, >=, 4 );
d720 1
a720 1
	BU_ASSERT_LONG( ap->ext_nbytes, >=, 4 );
@


11.69.2.1
log
@Initial ANSIfication
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_io.c,v 11.69 2002/08/20 17:07:57 jra Exp $ (ARL)";
d58 2
a59 1
db5_header_is_valid(const unsigned char *hp)
d102 2
a103 1
db5_select_length_encoding(long int len)
d123 4
a126 1
db5_decode_length(long int *lenp, const unsigned char *cp, int format)
d163 4
a166 1
db5_decode_signed(long int *lenp, const unsigned char *cp, int format)
d232 3
a234 1
db5_crack_disk_header(struct db5_raw_internal *rip, const unsigned char *cp)
d363 3
a365 1
db5_get_raw_internal_fp(struct db5_raw_internal *rip, FILE *fp)
d1104 4
a1107 1
db5_fwrite_ident(FILE *fp, const char *title, double local2mm)
@


11.69.2.2
log
@sync branch with HEAD
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d574 1
a574 5
		/* minimum buffer length is a one byte attribute name, followed by a NULL name termination,
		 * followed by no bytes (for an empty value), followed by a NULL value termination,
		 * followed by a NULL attribute-value termination. Minimum is 4 bytes
		 */
BU_ASSERT_PTR( attrib->ext_nbytes, >=, 4 );
d708 1
a708 1
	BU_ASSERT_LONG( ap->ext_nbytes, >=, 4 );
@


11.68
log
@Converted from K&R to ANSI C - RFH
@
text
@d58 2
a59 1
db5_header_is_valid(const unsigned char *hp)
d102 2
a103 1
db5_select_length_encoding(long int len)
d123 4
a126 1
db5_decode_length(long int *lenp, const unsigned char *cp, int format)
d163 4
a166 1
db5_decode_signed(long int *lenp, const unsigned char *cp, int format)
d232 3
a234 1
db5_crack_disk_header(struct db5_raw_internal *rip, const unsigned char *cp)
d363 3
a365 1
db5_get_raw_internal_fp(struct db5_raw_internal *rip, FILE *fp)
d1104 4
a1107 1
db5_fwrite_ident(FILE *fp, const char *title, double local2mm)
@


11.67
log
@Changed log message in db5_crack_disk_header.
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_io.c,v 11.66 2001/09/19 21:06:01 jra Exp $ (ARL)";
d58 1
a58 2
db5_header_is_valid( hp )
const unsigned char *hp;
d101 1
a101 2
db5_select_length_encoding( len )
long len;
d121 1
a121 4
db5_decode_length( lenp, cp, format )
long			*lenp;
const unsigned char	*cp;
int			format;
d158 1
a158 4
db5_decode_signed( lenp, cp, format )
long			*lenp;
const unsigned char	*cp;
int			format;
d224 1
a224 3
db5_crack_disk_header( rip, cp )
struct db5_raw_internal		*rip;
const unsigned char		*cp;
d353 1
a353 3
db5_get_raw_internal_fp( rip, fp )
struct db5_raw_internal	*rip;
FILE			*fp;
d1092 1
a1092 4
db5_fwrite_ident( fp, title, local2mm )
FILE		*fp;
const char	*title;
double		local2mm;
@


11.66
log
@db5_update_ident() was not setting major and minor types for _GLOBAL
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_io.c,v 11.65 2001/05/17 20:05:23 morrison Exp $ (ARL)";
d240 3
a242 1
			bu_log("It looks like a v4 database was concatenated onto a v5 database.\nConvert using g4-g5 before the 'cat', or use the MGED 'concat' command.\n");
@


11.65
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_io.c,v 11.64 2001/05/14 01:47:50 jra Exp $ (ARL)";
d1042 1
a1042 1
		unsigned char		minor_type='0';
d1055 1
@


11.64
log
@Added db5_replace_attributes()
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_io.c,v 11.63 2001/04/20 22:29:40 morrison Exp $ (ARL)";
d268 1
a268 1
	if(rt_g.debug&DEBUG_DB) bu_log("db5_crack_disk_header()\n\
d858 1
a858 1
	if(rt_g.debug&DEBUG_DB)  {
d932 1
a932 1
	if(rt_g.debug&DEBUG_DB)  {
d1296 1
a1296 1
	if(rt_g.debug&DEBUG_DB) bu_log("db_put_external5(%s) ep=x%x, dbip=x%x, dp=x%x\n",
@


11.63
log
@CONST to const
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_io.c,v 11.62 2001/04/20 21:34:38 bparker Exp $ (ARL)";
d829 75
@


11.62
log
@*- mods for handling return value of db5_get_raw_internal_ptr()
   differently. Previous code tested for <0 to indicate
   a failed attempt. However, this routine never returns
   values less than 0. It returns NULL (0) for failure and >0
   for success.
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_io.c,v 11.61 2001/04/15 02:18:43 jra Exp $ (ARL)";
d59 1
a59 1
CONST unsigned char *hp;
d61 1
a61 1
	CONST struct db5_ondisk_header *odp = (CONST struct db5_ondisk_header *)hp;
d125 1
a125 1
CONST unsigned char	*cp;
d165 1
a165 1
CONST unsigned char	*cp;
d234 1
a234 1
CONST unsigned char		*cp;
d298 1
a298 1
	CONST unsigned char	*cp = ip;
d327 1
a327 1
		rip->name.ext_buf = (genptr_t)cp;	/* discard CONST */
d335 1
a335 1
		rip->attributes.ext_buf = (genptr_t)cp;	/* discard CONST */
d343 1
a343 1
		rip->body.ext_buf = (genptr_t)cp;	/* discard CONST */
d437 1
a437 1
		rip->name.ext_buf = (genptr_t)cp;	/* discard CONST */
d445 1
a445 1
		rip->attributes.ext_buf = (genptr_t)cp;	/* discard CONST */
d453 1
a453 1
		rip->body.ext_buf = (genptr_t)cp;	/* discard CONST */
d472 4
a475 4
	CONST char *name,
	CONST unsigned char hidden,
	CONST struct bu_external *attrib,
	CONST struct bu_external *body,
d793 1
a793 1
	CONST struct bu_attribute_value_pair	*avpp;
d1028 1
a1028 1
CONST char	*title;
d1101 1
a1101 1
	CONST int major)
d1281 1
a1281 1
	CONST int		major)
@


11.61
log
@db5_get_attributes() was not initializing the AVS when there are no attributes
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_io.c,v 11.60 2001/04/05 13:08:19 jra Exp $ (ARL)";
d874 1
a874 1
	if( db5_get_raw_internal_ptr( &raw, ext.ext_buf ) < 0 )  {
d1354 1
a1354 1
	if( db5_get_raw_internal_ptr( &raw, ep->ext_buf ) < 0 )  {
d1546 1
a1546 1
	if( db5_get_raw_internal_ptr( &raw, ext.ext_buf ) < 0 ) {
@


11.60
log
@Added db5_get_attributes()
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_io.c,v 11.59 2001/03/28 14:49:39 jra Exp $ (ARL)";
d1556 2
@


11.59
log
@changed db5_export_object3() to ANSI style declaration to agree with raytrace.h.
Eliminated unused variable (old_title) from db5_update_ident().
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_io.c,v 11.58 2001/03/23 22:05:29 jra Exp $ (ARL)";
d1518 42
@


11.58
log
@Support for major and minor types in directory structure
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/librt/db5_io.c,v 11.57 2001/03/22 19:37:39 jra Exp $ (ARL)";
d469 11
a479 11
db5_export_object3( out, dli, name, hidden, attrib, body, major, minor, a_zzz, b_zzz )
struct bu_external		*out;			/* output */
int				dli;
CONST char			*name;
CONST unsigned char		hidden;
CONST struct bu_external	*attrib;
CONST struct bu_external	*body;
int				major;
int				minor;
int				a_zzz;		/* compression, someday */
int				b_zzz;
a961 1
	char				*old_title;
a997 1
	old_title = dbip->dbi_title;
@


11.57
log
@Added support for hidden flag for database objects
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/librt/db5_io.c,v 11.56 2001/03/22 18:10:53 bparker Exp $ (ARL)";
d968 1
d980 1
a980 1
		dp = db_diradd( dbip, DB5_GLOBAL_OBJECT_NAME, -1L, 0, 0, NULL );
@


11.56
log
@*- mods to db5_update_ident - update dbi_title
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/librt/db5_io.c,v 11.55 2001/03/21 21:00:30 jra Exp $ (ARL)";
d249 1
d469 1
a469 1
db5_export_object3( out, dli, name, attrib, body, major, minor, a_zzz, b_zzz )
d473 1
d553 3
d899 1
d975 1
a975 1
			DB5_GLOBAL_OBJECT_NAME, NULL, NULL,
d1045 1
a1045 1
		NULL, NULL, NULL,
d1061 1
a1061 1
		DB5_GLOBAL_OBJECT_NAME, &attr, NULL,
d1134 1
a1134 1
		name, &attributes, &body,
d1177 1
@


11.55
log
@Oops, missed part of that debug print
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/librt/db5_io.c,v 11.54 2001/03/21 20:56:59 jra Exp $ (ARL)";
d952 5
a956 4
	struct bu_attribute_value_set avs;
	struct directory *dp;
	struct bu_vls	units;
	int		ret;
d991 4
@


11.54
log
@Removed a debug print
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/librt/db5_io.c,v 11.53 2001/03/21 19:00:38 pjt Exp $ (ARL)";
a1387 1
	    raw.major_type, raw.minor_type, id);
@


11.53
log
@idb_type in struct rt_db_internal has been replaced by
idb_major_type and idb_minor_type
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/librt/db5_io.c,v 11.52 2001/03/20 21:54:41 pjt Exp $ (ARL)";
a1387 1
	bu_log("raw.major=%d, raw.minor=%d, id=%d\n",
@


11.52
log
@COB 20 Mar 2001
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/librt/db5_io.c,v 11.51 2001/03/20 16:09:07 jra Exp $ (ARL)";
a1350 1
		id = raw.minor_type;
d1376 14
d1391 1
a1391 1
	if( rt_functab[id].ft_import5( ip, &raw.body, mat, dbip, resp, id ) < 0 )  {
d1400 2
a1401 1
	ip->idb_type = id;
d1403 1
@


11.51
log
@ft_import5() and ft_export5() now have a const int minor_type argument
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/librt/db5_io.c,v 11.50 2000/09/08 05:54:40 mike Exp $ (ARL)";
d1090 2
a1091 1
	struct resource *resp)
d1095 1
a1095 1
	int			major, minor;
a1101 1
	major = DB5_MAJORTYPE_BRLCAD;
d1269 2
a1270 1
	struct resource		*resp)
d1281 1
a1281 1
	if( rt_db_cvt_to_external5( &ext, dp->d_namep, ip, 1.0, dbip, resp ) < 0 )  {
d1344 1
a1344 1
		bu_log("rt_db_get_internal5(%s):  import failure\n",
d1349 2
a1350 1
	if( raw.major_type == DB5_MAJORTYPE_BRLCAD )  {
d1355 1
a1355 1
		bu_log("rt_db_get_internal5(%s):  unable to import non-BRL-CAD object, major=%d\n",
d1365 1
a1365 1
			bu_log("rt_db_get_internal5(%s):  mal-formed attributes in database\n",
d1372 1
a1372 1
		bu_log("rt_db_get_internal5(%s):  object has no body\n",
d1379 1
a1379 1
		bu_log("rt_db_get_internal5(%s):  import failure\n",
@


11.50
log
@
Modified tree routines to take resource pointer.
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_io.c,v 11.49 2000/08/22 20:35:52 mike Exp $ (ARL)";
d1101 3
d1105 1
a1105 1
	if( ip->idb_meth->ft_export5( &body, ip, conv2mm, dbip, resp ) < 0 )  {
a1121 3
	major = DB5_MAJORTYPE_BRLCAD;
	minor = ip->idb_type;	/* XXX not necessarily v5 numbers. */

d1376 1
a1376 1
	if( rt_functab[id].ft_import5( ip, &raw.body, mat, dbip, resp ) < 0 )  {
@


11.49
log
@
Fixed lint
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_io.c,v 11.48 2000/08/21 02:02:29 butler Exp $ (ARL)";
d1089 2
a1090 1
	struct db_i *dbip)
d1098 1
d1102 1
a1102 1
	if( ip->idb_meth->ft_export5( &body, ip, conv2mm, dbip ) < 0 )  {
d1265 5
a1269 4
rt_db_put_internal5( dp, dbip, ip )
struct directory	*dp;
struct db_i		*dbip;
struct rt_db_internal	*ip;
d1276 1
d1280 1
a1280 1
	if( rt_db_cvt_to_external5( &ext, dp->d_namep, ip, 1.0, dbip ) < 0 )  {
d1305 1
a1305 1
	rt_db_free_internal( ip );
d1310 1
a1310 1
	rt_db_free_internal( ip );
a1314 51
 *			R T _ F W R I T E _ I N T E R N A L 5
 *
 *  Put an object in internal format out onto a file in external format.
 *
 *  The internal representation is always freed.
 *
 *  Can't really require a dbip parameter, as many callers won't have one.
 *
 *  Returns -
 *	0	OK
 *	<0	error
 *
 *  This routine isn't used anymore.
 *  NOTE:  Potential users of this routine really should consider using
 *  wdb_put_internal() instead!
 */
int
rt_fwrite_internal5( fp, name, ip, conv2mm )
FILE			*fp;
CONST char		*name;
struct rt_db_internal	*ip;
double			conv2mm;
{
	struct bu_external	ext;

	RT_CK_DB_INTERNAL(ip);
	RT_CK_FUNCTAB( ip->idb_meth );

	if( rt_db_cvt_to_external5( &ext, name, ip, conv2mm, NULL ) < 0 )  {
		bu_log("rt_fwrite_internal5(%s):  export failure\n",
			name);
		bu_free_external( &ext );
		rt_db_free_internal( ip );
		return -1;		/* FAIL */
	}
	BU_CK_EXTERNAL( &ext );

	if( bu_fwrite_external( fp, &ext ) < 0 )  {
		bu_log("rt_fwrite_internal5(%s): bu_fwrite_external() error\n",
			name );
		bu_free_external( &ext );
		rt_db_free_internal( ip );
		return -2;		/* FAIL */
	}
	bu_free_external( &ext );
	rt_db_free_internal( ip );
	return 0;

}

/*
d1330 2
a1331 1
	const mat_t			mat)
d1376 1
a1376 1
	if( rt_functab[id].ft_import5( ip, &raw.body, mat, dbip ) < 0 )  {
d1379 1
a1379 1
		rt_db_free_internal( ip );
d1404 6
a1409 5
rt_db_get_internal5( ip, dp, dbip, mat )
struct rt_db_internal	*ip;
CONST struct directory	*dp;
CONST struct db_i	*dbip;
CONST mat_t		mat;
d1422 1
a1422 1
	ret = rt_db_external5_to_internal5( ip, &ext, dp->d_namep, dbip, mat );
@


11.48
log
@Massive compilation warnings eliminated
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_io.c,v 11.47 2000/08/19 20:15:59 mike Exp $ (ARL)";
d366 1
a366 1
	int				count;
@


11.47
log
@
Added db5_make_free_object_hdr(), to support building
very large free objects (e.g. 50MBytes).
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_io.c,v 11.46 2000/08/15 05:01:02 mike Exp $ (ARL)";
d709 1
a709 1
	struct bu_attribute_value_pair *app;
@


11.46
log
@
Added safer code for db5_import_attributes().
This allows regression test "shaders.sh" to run.
More investigation into the problem with the efficient version is needed.
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_io.c,v 11.45 2000/08/15 04:50:44 mike Exp $ (ARL)";
d612 36
d649 3
@


11.45
log
@
1)  If _GLOBAL object is deleted, a new one will be made as needed.
2)  Fixed bounds-checking bug in exporting of attribute/value pairs.
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_io.c,v 11.44 2000/08/10 23:56:44 mike Exp $ (ARL)";
d695 3
d713 12
a727 3

	app->name = NULL;
	app->value = NULL;
@


11.44
log
@
Added some essential comments, recommending the use of
wdb_put_internal() over wdb_export() whenever possible.
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_io.c,v 11.43 2000/08/10 03:53:59 mike Exp $ (ARL)";
d717 1
d739 1
d746 1
d749 1
a749 1
	for( avpp = avs->avp; avpp->name != NULL; avpp++ )  {
d760 2
a761 1
	for( avpp = avs->avp; avpp->name != NULL; avpp++ )  {
d891 1
a891 1
 *  "ident" header record in v4.
d908 20
a927 4
	if( (dp = db_lookup( dbip, DB5_GLOBAL_OBJECT_NAME, LOOKUP_NOISY )) == DIR_NULL )  {
		bu_log("db5_update_ident() %s object is missing!\n", DB5_GLOBAL_OBJECT_NAME );
		/* XXX Really should create one here */
		return -1;
@


11.43
log
@
Broke out rt_db_external5_to_internal5().
It turned out not to be necessary, but seemed worth keeping
as a separate function.
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_io.c,v 11.42 2000/07/26 15:13:07 mike Exp $ (ARL)";
a1242 1
 *  Used by LIBWDB.
d1252 3
a1254 1
 *  NOTE:  Users of this should be using wdb_export() instead!
@


11.42
log
@
Support for region-id-based-coloring, both import and export
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_io.c,v 11.41 2000/07/25 22:40:48 mike Exp $ (ARL)";
d1290 1
a1290 1
 *			R T _ D B _ G E T _ I N T E R N A L 5
d1292 2
a1293 5
 *  Get an object from the database, and convert it into it's internal
 *  representation.
 *
 *  Applications and middleware shouldn't call this directly, they
 *  should use the generic interface "rt_db_get_internal()".
d1300 6
a1305 5
rt_db_get_internal5( ip, dp, dbip, mat )
struct rt_db_internal	*ip;
CONST struct directory	*dp;
CONST struct db_i	*dbip;
CONST mat_t		mat;
a1306 1
	struct bu_external	ext;
d1310 3
a1312 2
	BU_INIT_EXTERNAL(&ext);
	RT_INIT_DB_INTERNAL(ip);
d1316 1
a1316 4
	if( db_get_external( &ext, dp, dbip ) < 0 )
		return -2;		/* FAIL */

	if( db5_get_raw_internal_ptr( &raw, ext.ext_buf ) < 0 )  {
d1318 1
a1318 2
			dp->d_namep );
		bu_free_external( &ext );
d1328 1
a1328 2
			dp->d_namep, raw.major_type );
		bu_free_external( &ext );
d1338 1
a1338 1
				dp->d_namep );
d1345 1
a1345 2
			dp->d_namep );
		bu_free_external( &ext );
d1352 1
a1352 1
			dp->d_namep );
a1353 1
		bu_free_external( &ext );
a1355 1
	bu_free_external( &ext );
d1362 36
@


11.41
log
@
libwdb additions for writing NMGs at BoTs.
Initial support for writing region-id-based-color table.
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_io.c,v 11.40 2000/07/25 16:46:05 butler Exp $ (ARL)";
d1396 3
d1400 1
a1400 1
db5_import_color_table( struct bu_vls *istr )
d1402 8
d1429 1
d1435 1
a1435 1
		"material", bu_vls_addr(&str), dbip );
@


11.40
log
@Fixed bad practice in db5_update_ident definition: implicit int return
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_io.c,v 11.39 2000/07/13 00:45:18 mike Exp $ (ARL)";
d36 2
d1372 55
@


11.39
log
@
Added db5_update_attributes()
Added db5_update_ident()
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_io.c,v 11.38 2000/07/12 04:28:06 mike Exp $ (ARL)";
d893 1
a893 1
db5_update_ident( struct db_i *dbip, const char *title, double local2mm )
@


11.38
log
@
IRIX64
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_io.c,v 11.37 2000/07/12 02:08:29 mike Exp $ (ARL)";
d770 151
d934 3
@


11.37
log
@
Broke out db_wrap_v5_external() separately.
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_io.c,v 11.36 2000/07/11 05:08:46 mike Exp $ (ARL)";
d137 1
a137 1
#if 0
d214 2
@


11.36
log
@
Fixed for first 64-bit machine.
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_io.c,v 11.35 2000/07/11 04:05:52 mike Exp $ (ARL)";
d38 1
d903 47
a974 3
	struct db5_raw_internal	raw;
	struct bu_external	tmp;

d978 1
d991 2
a992 4

	/* Crack the external form into parts */
	if( db5_get_raw_internal_ptr( &raw, (unsigned char *)ep->ext_buf ) == NULL )  {
		bu_log("db_put_external5(%s) failure in db5_get_raw_internal_ptr()\n",
a995 18
	BU_ASSERT_LONG( raw.h_dli, ==, DB5HDR_HFLAGS_DLI_APPLICATION_DATA_OBJECT );

	/* See if name needs to be changed */
	if( raw.name.ext_buf == NULL || strcmp( dp->d_namep, raw.name.ext_buf ) != 0 )  {
		/* Name needs to be changed.  Create new external form. */
		tmp = *ep;		/* struct copy */
		BU_INIT_EXTERNAL(ep);

		db5_export_object3( ep,
			DB5HDR_HFLAGS_DLI_APPLICATION_DATA_OBJECT,
			dp->d_namep,
			&raw.attributes,
			&raw.body,
			raw.major_type, raw.minor_type,
			raw.a_zzz, raw.b_zzz );
		bu_free_external( &tmp );
		/* 'raw' is invalid now, 'ep' has new external form. */
	}
d1094 2
@


11.35
log
@
Changed to %e format
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_io.c,v 11.34 2000/07/11 03:18:51 mike Exp $ (ARL)";
d167 1
a167 1
		if( (*lenp = (*cp)) & 0x80 ) *lenp |= 0xFFFFFF00;
d170 1
a170 1
		if( (*lenp = BU_GSHORT(cp)) & 0x8000 )  *lenp |= 0xFFFF0000;
d173 2
a174 1
		*lenp = BU_GLONG(cp);
d177 1
a177 1
#if 0
@


11.34
log
@
Added check for out-of-range local2mm value.
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_io.c,v 11.33 2000/07/11 02:43:39 mike Exp $ (ARL)";
d811 1
a811 1
	bu_vls_printf( &units, "%.25f", local2mm );
@


11.33
log
@
Removed early debugging code.
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_io.c,v 11.32 2000/07/08 01:57:04 mike Exp $ (ARL)";
d794 6
@


11.32
log
@
Added error checking
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_io.c,v 11.31 2000/07/07 22:55:07 mike Exp $ (ARL)";
a602 1
if(getuid()==53) bu_hexdump_external(stderr, out, "v5 ext");
a1154 1
if(getuid()==53) bu_avs_print( &ip->idb_avs, "rt_db_get_internal5: attributes.ext_buf");
@


11.31
log
@
Provided db_put_external5() to allow more efficient
'cp' and 'keep' commands in mged.
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_io.c,v 11.30 2000/07/07 22:33:30 mike Exp $ (ARL)";
d801 1
a801 1
	bu_fwrite_external( fp, &out );
d817 1
a817 1
	bu_fwrite_external( fp, &out );
@


11.30
log
@
Changed rt_db_put_internal5() to directly write out the object,
to avoid the overhead of re-building the name string that would
be incurred by using db_put_external5().
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_io.c,v 11.29 2000/07/07 05:20:11 mike Exp $ (ARL)";
d462 1
a462 1
db5_export_object3( out, dli, name, attrib, body, major, minor, zzz )
d470 2
a471 1
int				zzz;		/* compression, someday */
d549 1
a549 1
	odp->db5h_aflags |= zzz & DB5HDR_AFLAGS_ZZZ_MASK;
d554 1
a554 1
	odp->db5h_bflags |= zzz & DB5HDR_BFLAGS_ZZZ_MASK;
d556 1
a556 1
	if( zzz )  bu_bomb("db5_export_object3: compression not supported yet\n");
d800 1
a800 1
		DB5_ZZZ_UNCOMPRESSED );
d816 1
a816 1
		DB5_ZZZ_UNCOMPRESSED);
d887 1
a887 1
		DB5_ZZZ_UNCOMPRESSED);
d893 90
@


11.29
log
@
lint
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_io.c,v 11.28 2000/07/07 03:56:32 mike Exp $ (ARL)";
d901 1
a901 1
 *  should use the generic interface "rt_db_get_internal()".
d904 1
d927 1
a927 3
		bu_free_external( &ext );
		rt_db_free_internal( ip );
		return -1;		/* FAIL */
d931 11
a941 4
	if( db_put_external( &ext, dp, dbip ) < 0 )  {
		bu_free_external( &ext );
		rt_db_free_internal( ip );
		return -2;		/* FAIL */
d944 4
d951 5
@


11.28
log
@
Wrong length was being written in header of free records.
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_io.c,v 11.27 2000/07/07 03:49:41 mike Exp $ (ARL)";
d145 1
a145 1
	/* NOTREACHED */
d185 1
a185 1
	/* NOTREACHED */
d215 1
a215 1
	/* NOTREACHED */
a915 2
	int			major, minor;
	int			ret;
a964 1
	int			major, minor;
@


11.27
log
@
Remember to write length of free object into free object.
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_io.c,v 11.26 2000/06/30 21:39:46 mike Exp $ (ARL)";
d633 1
a633 1
	cp = db5_encode_length( cp, length, h_width );
@


11.26
log
@
Added support for making free-storage objects
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_io.c,v 11.25 2000/06/30 19:47:30 mike Exp $ (ARL)";
d631 3
@


11.25
log
@
Added error checking.
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_io.c,v 11.24 2000/06/30 19:09:41 mike Exp $ (ARL)";
d603 31
@


11.24
log
@
Removed some debug blather
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_io.c,v 11.23 2000/06/30 18:35:40 mike Exp $ (ARL)";
d888 2
@


11.23
log
@
Have to initialize before importing.
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_io.c,v 11.22 2000/06/30 17:36:56 mike Exp $ (ARL)";
a1011 1
if(getuid()==53) bu_hexdump_external( stderr, &raw.attributes, "rt_db_get_internal5: raw.attributes");
@


11.22
log
@
Parameterized name of _GLOBAL
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_io.c,v 11.21 2000/06/30 16:35:09 pjt Exp $ (ARL)";
d683 2
a684 4
 *  One attempt at encoding attribute-value information in the external
 *  format.
 *  This may not be the best or only way to do it, but it gets things
 *  started, for testing.
d689 2
d826 1
@


11.21
log
@Changed some DB5HDR_blah_blah #defines to be DB5_blah_blah
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_io.c,v 11.20 2000/06/30 15:52:33 mike Exp $ (ARL)";
d743 1
a743 1
 *  Second, an attribute-only object named "_GLOBAL" which
d779 1
a779 1
		"_GLOBAL", &attr, NULL,
@


11.20
log
@
Added debugging and comments.
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_io.c,v 11.19 2000/06/30 14:37:20 mike Exp $ (ARL)";
d71 1
a71 1
	if( (odp->db5h_aflags & DB5HDR_AFLAGS_ZZZ_MASK) != DB5HDR_ZZZ_UNCOMPRESSED )  return 0;
d77 1
a77 1
	if( (odp->db5h_bflags & DB5HDR_BFLAGS_ZZZ_MASK) != DB5HDR_ZZZ_UNCOMPRESSED )  return 0;
d83 1
a83 1
	if( odp->db5h_major_type != DB5HDR_MAJORTYPE_RESERVED )  return 0;
d764 2
a765 2
		DB5HDR_MAJORTYPE_RESERVED, 0,
		DB5HDR_ZZZ_UNCOMPRESSED );
d780 2
a781 2
		DB5HDR_MAJORTYPE_ATTRIBUTE_ONLY, 0,
		DB5HDR_ZZZ_UNCOMPRESSED);
d845 1
a845 1
	major = DB5HDR_MAJORTYPE_BRLCAD;
d851 1
a851 1
		DB5HDR_ZZZ_UNCOMPRESSED);
d996 1
a996 1
	if( raw.major_type == DB5HDR_MAJORTYPE_BRLCAD )  {
@


11.19
log
@
Additions for putting combinations into attributes.
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_io.c,v 11.18 2000/06/29 20:09:47 mike Exp $ (ARL)";
d865 3
d963 3
d1011 1
d1017 1
d1027 1
@


11.18
log
@
Macro typo
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_io.c,v 11.17 2000/06/29 20:04:30 mike Exp $ (ARL)";
d487 8
a494 2
		n_width = db5_select_length_encoding(namelen);
		need += namelen + db5_enc_len[n_width];
d500 7
a506 2
		a_width = db5_select_length_encoding(attrib->ext_nbytes);
		need += attrib->ext_nbytes + db5_enc_len[a_width];
d512 7
a518 2
		b_width = db5_select_length_encoding(body->ext_nbytes);
		need += body->ext_nbytes + db5_enc_len[b_width];
d572 1
d693 1
a693 3
db5_export_attributes( ext, avp )
struct bu_external		*ext;
CONST struct bu_attribute_value_pair	*avp;
d699 6
d706 1
a706 1
	for( avpp = avp; avpp->name != NULL; avpp++ )  {
d709 1
a711 1
	ext->ext_magic = BU_EXTERNAL_MAGIC;
d717 1
a717 1
	for( avpp = avp; avpp->name != NULL; avpp++ )  {
d756 1
a756 1
	struct bu_attribute_value_pair avp[3];
d773 3
a775 6
	avp[0].name = "title";
	avp[0].value = (char *)title;		/* un-CONST */
	avp[1].name = "units";
	avp[1].value = bu_vls_addr(&units);
	avp[2].name = NULL;
	avp[2].value = NULL;
d777 1
a777 1
	db5_export_attributes( &attr, avp );
d785 1
d839 1
a839 1
		db5_export_attributes( &attributes, ip->idb_avs.avp );
d999 11
@


11.17
log
@
Added rt_db_cvt_to_external5()
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_io.c,v 11.16 2000/06/29 18:54:00 mike Exp $ (ARL)";
d862 1
a862 1
	RT_CK_DIRECTORY(dp);
@


11.16
log
@
Attributes are found in rt_db_internal struct
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_io.c,v 11.15 2000/06/29 18:20:55 mike Exp $ (ARL)";
d585 1
d774 67
a844 1
 *  On success only, the internal representation is freed.
d846 1
a846 1
 *  The attributes are taken from ip->idb_avs
a857 1
	struct bu_external	body;
d862 2
a863 1
	BU_INIT_EXTERNAL(&ext);
d866 2
a867 4
	/* Scale change on export is 1.0 -- no change */
	ret = ip->idb_meth->ft_export5( &body, ip, 1.0, dbip );
	if( ret < 0 )  {
		bu_log("rt_db_put_internal5(%s):  solid export failure\n",
d869 1
d871 1
a871 2
		bu_free_external( &body );
		return -2;		/* FAIL */
d873 1
a873 10
	rt_db_free_internal( ip );

	major = DB5HDR_MAJORTYPE_BRLCAD;
	minor = ip->idb_type;	/* XXX not necessarily v5 numbers. */

	db5_export_object3( &ext, DB5HDR_HFLAGS_DLI_APPLICATION_DATA_OBJECT,
		dp->d_namep, ip->idb_avs, &body,
		major, minor,
		DB5HDR_ZZZ_UNCOMPRESSED);
	bu_free_external( &body );
d877 2
a878 1
		return -1;		/* FAIL */
d882 1
d892 2
d902 4
a905 4
FILE				*fp;
CONST char			*name;
CONST struct rt_db_internal	*ip;
double				conv2mm;
a906 1
	struct bu_external	body;
d913 6
a918 6
	BU_INIT_EXTERNAL( &body );
	if( ip->idb_meth->ft_export5( &body, ip, conv2mm, NULL /*dbip*/ ) < 0 )  {
		bu_log("rt_fwrite_internal5(%s): solid export failure\n",
			name );
		bu_free_external( &body );
		return -2;				/* FAIL */
d920 1
a920 11
	BU_CK_EXTERNAL( &body );

	major = DB5HDR_MAJORTYPE_BRLCAD;
	minor = ip->idb_type;	/* XXX not necessarily v5 numbers. */

	BU_INIT_EXTERNAL( &ext );
	db5_export_object3( &ext, DB5HDR_HFLAGS_DLI_APPLICATION_DATA_OBJECT,
		name, ip->idb_avs, &body,
		major, minor,
		DB5HDR_ZZZ_UNCOMPRESSED);
	bu_free_external( &body );
d926 2
a927 1
		return -3;
d930 1
@


11.15
log
@
Changed from db_free_external() to bu_free_external()
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_io.c,v 11.14 2000/06/29 17:58:28 mike Exp $ (ARL)";
d639 1
a639 1
	avs->readonly_max = ap->ext_buf + ap->ext_nbytes-1;
d779 2
d786 1
a786 1
rt_db_put_internal5( dp, dbip, ip, attr )
a789 1
CONST struct bu_attribute_value_pair	*attr;
d814 1
a814 1
		dp->d_namep, attr, &body,
d841 1
a841 1
rt_fwrite_internal5( fp, name, ip, conv2mm, attr )
a845 1
CONST struct bu_attribute_value_pair	*attr;
d868 1
a868 1
		name, attr, &body,
@


11.14
log
@
Added db5_import_attributes()
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_io.c,v 11.13 2000/06/29 15:55:46 mike Exp $ (ARL)";
d804 1
a804 1
		db_free_external( &body );
d816 1
a816 1
	db_free_external( &body );
d819 1
a819 1
		db_free_external( &ext );
d823 1
a823 1
	db_free_external( &ext );
d858 1
a858 1
		db_free_external( &body );
d871 1
a871 1
	db_free_external( &body );
d876 1
a876 1
		db_free_external( &ext );
d879 1
a879 1
	db_free_external( &ext );
d916 1
a916 1
		db_free_external( &ext );
d927 1
a927 1
		db_free_external( &ext );
d934 1
a934 1
		db_free_external( &ext );
d942 1
a942 1
		db_free_external( &ext );
d945 1
a945 1
	db_free_external( &ext );
@


11.13
log
@
Added error checking,
particularly to test for the case of a v4 database being cat'ed
onto the end of a v5 database.
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_io.c,v 11.12 2000/06/29 15:21:14 mike Exp $ (ARL)";
d585 75
@


11.12
log
@
externs
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_io.c,v 11.11 2000/06/28 21:41:25 mike Exp $ (ARL)";
d230 7
a236 1
	if( cp[0] != DB5HDR_MAGIC1 )  return 0;
d299 6
d307 2
a308 1
		bu_log("db5_get_raw_internal_ptr() bad magic2\n");
d394 6
d417 2
a418 1
		bu_log("db5_get_raw_internal_fp() bad magic2\n");
@


11.11
log
@
Changed db5_comb to use variable width matrix subscripts,
and the new routine db5_decode_signed().
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_io.c,v 11.10 2000/06/28 18:04:35 mike Exp $ (ARL)";
a37 2
BU_EXTERN(CONST unsigned char *db5_get_raw_internal_ptr, (struct db5_raw_internal *rip, unsigned char * CONST ip));

d282 2
a283 4
CONST unsigned char *
db5_get_raw_internal_ptr( rip, ip )
struct db5_raw_internal		*rip;
unsigned char		* CONST ip;
@


11.10
log
@
Merged BRL-CAD geometry and non-geometry major types
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_io.c,v 11.9 2000/06/28 16:34:57 mike Exp $ (ARL)";
d116 1
a116 2
 *  Note that for object_length the returned number needs to be
 *  multiplied by 8, while for the other lengths, it is already a byte count.
d133 40
@


11.9
log
@
Combinations have a different major type.
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_io.c,v 11.8 2000/06/27 21:05:57 mike Exp $ (ARL)";
d673 1
d677 1
d679 2
a680 7
	if( ip->idb_type == ID_COMBINATION )  {
		major = DB5HDR_MAJORTYPE_BRLCAD_NONGEOM;
		minor = 1;
	} else {
		major = DB5HDR_MAJORTYPE_BRLCAD_GEOMETRY;
		minor = ip->idb_type;	/* XXX not necessarily v5 numbers. */
	}
a692 3
    	if( ip->idb_ptr )  ip->idb_meth->ft_ifree( ip );

	RT_INIT_DB_INTERNAL(ip);
d733 2
a734 7
	if( ip->idb_type == ID_COMBINATION )  {
		major = DB5HDR_MAJORTYPE_BRLCAD_NONGEOM;
		minor = 1;
	} else {
		major = DB5HDR_MAJORTYPE_BRLCAD_GEOMETRY;
		minor = ip->idb_type;	/* XXX not necessarily v5 numbers. */
	}
d790 1
a790 3
	if( raw.major_type == DB5HDR_MAJORTYPE_BRLCAD_NONGEOM )  {
		id = ID_COMBINATION;
	} else if( raw.major_type == DB5HDR_MAJORTYPE_BRLCAD_GEOMETRY )  {
d811 1
a811 1
	    	if( ip->idb_ptr )  ip->idb_meth->ft_ifree( ip );
@


11.8
log
@
Added rt_comb_import5/export5
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_io.c,v 11.7 2000/06/27 18:14:55 mike Exp $ (ARL)";
d677 7
a683 3
	/* What about combinations? */
	major = DB5HDR_MAJORTYPE_BRLCAD_GEOMETRY;
	minor = ip->idb_type;	/* XXX not necessarily v5 numbers. */
d739 7
a745 3
	/* What about combinations? */
	major = DB5HDR_MAJORTYPE_BRLCAD_GEOMETRY;
	minor = ip->idb_type;	/* XXX not necessarily v5 numbers. */
@


11.7
log
@
Employed bu_external where useful
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_io.c,v 11.6 2000/06/27 17:33:13 mike Exp $ (ARL)";
d40 1
a40 1
CONST static int db5_enc_len[4] = {
d161 4
a164 4
db5_encode_length( cp, val, format )
unsigned char	*cp;
long		val;
int		format;
a454 1
	out->ext_nbytes = 0;
d456 1
a456 1
	out->ext_nbytes = need;		/* temporary */
@


11.6
log
@
Added rt_db_get_internal5()
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_io.c,v 11.5 2000/06/27 14:26:13 mike Exp $ (ARL)";
d264 4
d270 4
a273 6
		cp += db5_decode_length( &rip->name_length, cp, rip->h_name_width );
		rip->name = (char *)cp;		/* discard CONST */
		cp += rip->name_length;
	} else {
		rip->name_length = 0;
		rip->name = NULL;
d278 4
a281 6
		cp += db5_decode_length( &rip->attribute_length, cp, rip->a_width );
		rip->attributes = (unsigned char *)cp;	/* discard CONST */
		cp += rip->attribute_length;
	} else {
		rip->attribute_length = 0;
		rip->attributes = NULL;
d286 4
a289 6
		cp += db5_decode_length( &rip->body_length, cp, rip->b_width );
		rip->body = (unsigned char *)cp;	/* discard CONST */
		cp += rip->body_length;
	} else {
		rip->body_length = 0;
		rip->body = NULL;
d367 4
d373 4
a376 6
		cp += db5_decode_length( &rip->name_length, cp, rip->h_name_width );
		rip->name = (char *)cp;
		cp += rip->name_length;
	} else {
		rip->name_length = 0;
		rip->name = NULL;
d381 4
a384 6
		cp += db5_decode_length( &rip->attribute_length, cp, rip->a_width );
		rip->attributes = (unsigned char *)cp;	/* discard CONST */
		cp += rip->attribute_length;
	} else {
		rip->attribute_length = 0;
		rip->attributes = NULL;
d389 4
a392 6
		cp += db5_decode_length( &rip->body_length, cp, rip->b_width );
		rip->body = (unsigned char *)cp;	/* discard CONST */
		cp += rip->body_length;
	} else {
		rip->body_length = 0;
		rip->body = NULL;
a777 1
	struct bu_external	body;
d807 1
a807 1
	if( !raw.body )  {
d814 1
a814 5
	BU_INIT_EXTERNAL(&body);
	body.ext_nbytes = raw.body_length;
	body.ext_buf = raw.body;
	
	if( rt_functab[id].ft_import5( ip, &body, mat, dbip ) < 0 )  {
d822 1
a822 1
	/* Don't free &body */
@


11.5
log
@
Opps, inited in wrong place
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_io.c,v 11.4 2000/06/27 14:15:39 mike Exp $ (ARL)";
d760 77
@


11.4
log
@
Clean
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_io.c,v 11.3 2000/06/26 21:19:54 mike Exp $ (ARL)";
d534 1
d744 1
a750 1
	BU_INIT_EXTERNAL( &ext );
@


11.3
log
@
Code modified to track design changes --
extra header byte, extra compression bits, separate name_len.
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_io.c,v 11.2 2000/06/26 19:47:56 mike Exp $ (ARL)";
d730 1
d749 1
@


11.2
log
@
Added db5_io.c
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_io.c,v 11.1 2000/06/26 19:06:55 mike Exp $ (ARL)";
d40 7
d72 10
a81 5
	/* iflags */
	if( (odp->db5h_iflags & DB5HDR_IFLAGS_ZZZ_MASK) != DB5HDR_IFLAGS_ZZZ_UNCOMPRESSED )  return 0;
	if( odp->db5h_iflags & DB5HDR_IFLAGS_ATTRIBUTES_PRESENT )  return 0;
	if( odp->db5h_iflags & DB5HDR_IFLAGS_BODY_PRESENT )  return 0;
	if( ((odp->db5h_iflags & DB5HDR_IFLAGS_INTERIOR_WIDTH_MASK) >> DB5HDR_IFLAGS_INTERIOR_WIDTH_SHIFT)
d89 1
a89 4
	if( hp[5] != 1 )  return 0;

	/* Ensure pad is zero */
	if( hp[6] != 0 )  return 0;
d200 2
d203 19
a221 11
	/* iflags */
	rip->i_object_width = (cp[2] & DB5HDR_IFLAGS_INTERIOR_WIDTH_MASK) >>
		DB5HDR_IFLAGS_INTERIOR_WIDTH_SHIFT;
	rip->i_attributes_present = (cp[2] & DB5HDR_IFLAGS_ATTRIBUTES_PRESENT);
	rip->i_body_present = (cp[2] & DB5HDR_IFLAGS_BODY_PRESENT);
	rip->i_zzz = (cp[2] & DB5HDR_IFLAGS_ZZZ_MASK);

	rip->major_type = cp[3];
	rip->minor_type = cp[4];

	if(rt_g.debug&DEBUG_DB) bu_log("db5_crack_disk_header() h_dli=%d, h_object_width=%d, h_name_present=%d, i_object_width=%d, i_attributes_present=%d, i_body_present=%d, i_zzz=%d, major=%d, minor=%d\n",
d225 7
a231 4
		rip->i_object_width,
		rip->i_attributes_present,
		rip->i_body_present,
		rip->i_zzz,
d266 1
a266 1
		cp += db5_decode_length( &rip->name_length, cp, rip->i_object_width );
d274 15
a288 6
	/* Point to object interior, if present */
	if( rip->i_attributes_present || rip->i_body_present )  {
		/* interior_length will include any pad bytes but not magic2 */
		/* Because it may be compressed, we don't know exact len yet */
		rip->interior_length = cp - rip->buf - 1;
		rip->interior = (unsigned char *)cp;	/* discard CONST */
d290 2
a291 2
		rip->interior_length = 0;
		rip->interior = NULL;
d371 1
a371 1
		cp += db5_decode_length( &rip->name_length, cp, rip->i_object_width );
d379 5
a383 6
	/* Point to object interior, if present */
	if( rip->i_attributes_present || rip->i_body_present )  {
		/* interior_length will include any pad bytes but not magic2 */
		/* Because it may be compressed, we don't know exact len yet */
		rip->interior_length = cp - rip->buf - 1;
		rip->interior = cp;
d385 12
a396 2
		rip->interior_length = 0;
		rip->interior = NULL;
d425 1
a425 2
	long	ineed = 0;	/* sizes of internal parts */
	int	h_width, i_width;	
d436 4
a439 2
		need += namelen + 8;
		ineed = namelen;
d443 4
a446 2
		need += attrib->ext_nbytes + 8;
		ineed |= attrib->ext_nbytes;
d450 4
a453 2
		need += body->ext_nbytes + 8;
		ineed |= body->ext_nbytes;
d463 1
a463 1
	/* Determine encoding for the two kinds of length fields */
a464 1
	i_width = db5_select_length_encoding( ineed );
d473 5
a477 1
	if( name )  odp->db5h_hflags |= DB5HDR_HFLAGS_NAME_PRESENT;
d479 9
a487 5
	/* iflags */
	odp->db5h_iflags = i_width << DB5HDR_IFLAGS_INTERIOR_WIDTH_SHIFT;
	if( attrib )  odp->db5h_iflags |= DB5HDR_IFLAGS_ATTRIBUTES_PRESENT;
	if( body )  odp->db5h_iflags |= DB5HDR_IFLAGS_BODY_PRESENT;
	odp->db5h_iflags |= zzz & DB5HDR_IFLAGS_ZZZ_MASK;
d500 1
a500 1
		cp = db5_encode_length( cp, namelen, i_width );
d506 1
a506 1
		cp = db5_encode_length( cp, attrib->ext_nbytes, i_width );
d512 1
a512 1
		cp = db5_encode_length( cp, body->ext_nbytes, i_width );
d617 1
a617 1
		DB5HDR_IFLAGS_ZZZ_UNCOMPRESSED );
d636 1
a636 1
		DB5HDR_IFLAGS_ZZZ_UNCOMPRESSED);
d688 1
a688 1
		DB5HDR_IFLAGS_ZZZ_UNCOMPRESSED);
d745 1
a745 1
		DB5HDR_IFLAGS_ZZZ_UNCOMPRESSED);
@


11.1
log
@
More I/O stuff
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db5_scan.c,v 11.6 2000/06/23 21:05:56 mike Exp $ (ARL)";
d416 1
d445 1
a445 1
	cp = db5_encode_length( cp, 0L, h_width );	/* will be replaced below */
d606 1
a606 1
rt_db_put_internal5( dp, dbip, ip )
d610 1
d612 1
d614 1
d621 1
a621 1
	ret = ip->idb_meth->ft_export( &ext, ip, 1.0, dbip );
d623 1
a623 1
		bu_log("rt_db_put_internal(%s):  solid export failure\n",
d625 1
a625 1
		db_free_external( &ext );
d629 10
d678 1
a678 1
	if( ip->idb_meth->ft_export( &body, ip, conv2mm, NULL /*dbip*/ ) < 0 )  {
d696 2
a697 2
	if( db_fwrite_external( fp, name, &ext ) < 0 )  {
		bu_log("rt_fwrite_internal(%s): db_fwrite_external() error\n",
@

