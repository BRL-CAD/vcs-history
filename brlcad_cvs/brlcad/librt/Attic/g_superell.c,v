head	11.3;
access;
symbols
	ansi-20040405-merged:1.1.2.3
	postmerge-20040405-ansi:11.1
	ansi-20040316-freeze:1.1.2.3
	ansi-branch:1.1.0.2;
locks; strict;
comment	@ * @;


11.3
date	2004.05.21.18.07.31;	author morrison;	state dead;
branches;
next	11.2;

11.2
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.1;

11.1
date	2004.04.05.08.48.57;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.31.00.12.29;	author morrison;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2003.01.31.00.12.29;	author morrison;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2003.02.02.06.12.44;	author morrison;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2003.02.11.00.12.19;	author morrison;	state Exp;
branches;
next	;


desc
@@


11.3
log
@moved to src/
@
text
@/*
 *			G _ S U P E R E L L . C
 *
 *  Purpose -
 *
 *      NOTICE: this primitive is incomplete and should beconsidered
 *              experimental.  this primitive will exhibit several
 *              instabilities in the existing root solver method.
 *       
 *	Intersect a ray with a Superquadratic Ellipsoid
 *
 *  Authors -
 *      Christopher Sean Morrison (Programming)
 *      Edwin O. Davisson (Mathematics)
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1985 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSsuperell[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/g_superell.c,v 11.2 2004/05/10 15:30:46 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef HAVE_STRING_H
#include <string.h>
#endif
#include <math.h>
#include "machine.h"
#include "vmath.h"
#include "db.h"
#include "nmg.h"
#include "raytrace.h"
#include "nurb.h"
#include "rtgeom.h"
#include "./debug.h"

const struct bu_structparse rt_superell_parse[] = {
    { "%f", 3, "V", offsetof(struct rt_superell_internal, v[X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 3, "A", offsetof(struct rt_superell_internal, a[X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 3, "B", offsetof(struct rt_superell_internal, b[X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 3, "C", offsetof(struct rt_superell_internal, c[X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 1, "n", offsetof(struct rt_superell_internal, n), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 1, "e", offsetof(struct rt_superell_internal, e), BU_STRUCTPARSE_FUNC_NULL },
    { {'\0','\0','\0','\0'}, 0, (char *)NULL, 0, BU_STRUCTPARSE_FUNC_NULL }
 };


/*
 *  Algorithm:
 *  
 *  Given V, A, B, and C, there is a set of points on this superellipsoid
 *  
 *  { (x,y,z) | (x,y,z) is on superellipsoid defined by V, A, B, C }
 *  
 *  Through a series of Affine Transformations, this set will be
 *  transformed into a set of points on a unit sphere at the origin
 *  
 *  { (x',y',z') | (x',y',z') is on Sphere at origin }
 *  
 *  The transformation from X to X' is accomplished by:
 *  
 *  X' = S(R( X - V ))
 *  
 *  where R(X) =  ( A/(|A|) )
 *  		 (  B/(|B|)  ) . X
 *  		  ( C/(|C|) )
 *  
 *  and S(X) =	 (  1/|A|   0     0   )
 *  		(    0    1/|B|   0    ) . X
 *  		 (   0      0   1/|C| )
 *  
 *  To find the intersection of a line with the superellipsoid, consider
 *  the parametric line L:
 *  
 *  	L : { P(n) | P + t(n) . D }
 *  
 *  Call W the actual point of intersection between L and the superellipsoid.
 *  Let W' be the point of intersection between L' and the unit sphere.
 *  
 *  	L' : { P'(n) | P' + t(n) . D' }
 *  
 *  W = invR( invS( W' ) ) + V
 *  
 *  Where W' = k D' + P'.
 *  
 *  Let dp = D' dot P'
 *  Let dd = D' dot D'
 *  Let pp = P' dot P'
 *  
 *  and k = [ -dp +/- sqrt( dp*dp - dd * (pp - 1) ) ] / dd
 *  which is constant.
 *  
 *  Now, D' = S( R( D ) )
 *  and  P' = S( R( P - V ) )
 *  
 *  Substituting,
 *  
 *  W = V + invR( invS[ k *( S( R( D ) ) ) + S( R( P - V ) ) ] )
 *    = V + invR( ( k * R( D ) ) + R( P - V ) )
 *    = V + k * D + P - V
 *    = k * D + P
 *  
 *  Note that ``k'' is constant, and is the same in the formulations
 *  for both W and W'.
 *  
 *  NORMALS.  Given the point W on the superellipsoid, what is the vector
 *  normal to the tangent plane at that point?
 *  
 *  Map W onto the unit sphere, ie:  W' = S( R( W - V ) ).
 *  
 *  Plane on unit sphere at W' has a normal vector of the same value(!).
 *  N' = W'
 *  
 *  The plane transforms back to the tangent plane at W, and this
 *  new plane (on the superellipsoid) has a normal vector of N, viz:
 *  
 *  N = inverse[ transpose( inverse[ S o R ] ) ] ( N' )
 *
 *  because if H is perpendicular to plane Q, and matrix M maps from
 *  Q to Q', then inverse[ transpose(M) ] (H) is perpendicular to Q'.
 *  Here, H and Q are in "prime space" with the unit sphere.
 *  [Somehow, the notation here is backwards].
 *  So, the mapping matrix M = inverse( S o R ), because
 *  S o R maps from normal space to the unit sphere.
 *
 *  N = inverse[ transpose( inverse[ S o R ] ) ] ( N' )
 *    = inverse[ transpose(invR o invS) ] ( N' )
 *    = inverse[ transpose(invS) o transpose(invR) ] ( N' )
 *    = inverse[ inverse(S) o R ] ( N' )
 *    = invR o S ( N' )
 *
 *    = invR o S ( W' )
 *    = invR( S( S( R( W - V ) ) ) )
 *
 *  because inverse(R) = transpose(R), so R = transpose( invR ),
 *  and S = transpose( S ).
 *
 *  Note that the normal vector N produced above will not have unit length.
 */

struct superell_specific {
  vect_t superell_V; /* Vector to center of superellipsoid */
  vect_t superell_Au; /* unit-length A vector */
  vect_t superell_Bu;
  vect_t superell_Cu;
  double superell_n; /* north-south curvature power */
  double superell_e; /* east-west curvature power */
  double superell_invmsAu; /* 1.0 / |Au|^2 */
  double superell_invmsBu; /* 1.0 / |Bu|^2 */
  double superell_invmsCu; /* 1.0 / |Cu|^2 */
  vect_t superell_invsq;
  mat_t	superell_SoR; /* matrix for local cordinate system, Scale(Rotate(V))*/
  mat_t superell_invRSSR; /* invR(Scale(Scale(Rot(V)))) */
  mat_t superell_invR; /* transposed rotation matrix */
};
#define SUPERELL_NULL	((struct superell_specific *)0)

/*
 *  			R T _ S U P E R E L L _ P R E P
 *  
 *  Given a pointer to a GED database record, and a transformation matrix,
 *  determine if this is a valid superellipsoid, and if so, precompute various
 *  terms of the formula.
 *  
 *  Returns -
 *  	0	SUPERELL is OK
 *  	!0	Error in description
 *  
 *  Implicit return -
 *  	A struct superell_specific is created, and it's address is stored in
 *  	stp->st_specific for use by rt_superell_shot().
 */
int
rt_superell_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
{
  
  register struct superell_specific *superell;
  struct rt_superell_internal	*eip;
  LOCAL fastf_t	magsq_a, magsq_b, magsq_c;
  LOCAL mat_t	R, TEMP;
  LOCAL vect_t	Au, Bu, Cu;	/* A,B,C with unit length */
  LOCAL vect_t	w1, w2, P;	/* used for bounding RPP */
  LOCAL fastf_t	f;
  
  eip = (struct rt_superell_internal *)ip->idb_ptr;
  RT_SUPERELL_CK_MAGIC(eip);
  
  /* Validate that |A| > 0, |B| > 0, |C| > 0 */
  magsq_a = MAGSQ( eip->a );
  magsq_b = MAGSQ( eip->b );
  magsq_c = MAGSQ( eip->c );
  
  if( magsq_a < rtip->rti_tol.dist || magsq_b < rtip->rti_tol.dist || magsq_c < rtip->rti_tol.dist ) {
    bu_log("superell(%s):  zero length A(%g), B(%g), or C(%g) vector\n",
	   stp->st_name, magsq_a, magsq_b, magsq_c );
    return(1);		/* BAD */
  }
  if (eip->n < rtip->rti_tol.dist || eip->e < rtip->rti_tol.dist) {
    bu_log("superell(%s):  zero length <n,e> curvature (%g, %g) causes problems\n", 
	   stp->st_name, eip->n, eip->e);
    /* BAD */
  }
  if (eip->n > 10000.0 || eip->e > 10000.0) {
    bu_log("superell(%s):  very large <n,e> curvature (%g, %g) causes problems\n", 
	   stp->st_name, eip->n, eip->e);
    /* BAD */
  }
  
  /* Create unit length versions of A,B,C */
  f = 1.0/sqrt(magsq_a);
  VSCALE( Au, eip->a, f );
  f = 1.0/sqrt(magsq_b);
  VSCALE( Bu, eip->b, f );
  f = 1.0/sqrt(magsq_c);
  VSCALE( Cu, eip->c, f );
  
  /* Validate that A.B == 0, B.C == 0, A.C == 0 (check dir only) */
  f = VDOT( Au, Bu );
  if( ! NEAR_ZERO(f, rtip->rti_tol.dist) )  {
    bu_log("superell(%s):  A not perpendicular to B, f=%f\n",stp->st_name, f);
    return(1);		/* BAD */
  }
  f = VDOT( Bu, Cu );
  if( ! NEAR_ZERO(f, rtip->rti_tol.dist) )  {
    bu_log("superell(%s):  B not perpendicular to C, f=%f\n",stp->st_name, f);
    return(1);		/* BAD */
  }
  f = VDOT( Au, Cu );
  if( ! NEAR_ZERO(f, rtip->rti_tol.dist) )  {
    bu_log("superell(%s):  A not perpendicular to C, f=%f\n",stp->st_name, f);
    return(1);		/* BAD */
  }
  
  /* Solid is OK, compute constant terms now */

  BU_GETSTRUCT( superell, superell_specific );
  stp->st_specific = (genptr_t)superell;

  superell->superell_n = eip->n;
  superell->superell_e = eip->e;

  VMOVE( superell->superell_V, eip->v );

  VSET( superell->superell_invsq, 1.0/magsq_a, 1.0/magsq_b, 1.0/magsq_c );
  VMOVE( superell->superell_Au, Au );
  VMOVE( superell->superell_Bu, Bu );
  VMOVE( superell->superell_Cu, Cu );

  /* compute the inverse magnitude square for equations during shot */
  superell->superell_invmsAu = 1.0 / magsq_a;
  superell->superell_invmsBu = 1.0 / magsq_b;
  superell->superell_invmsCu = 1.0 / magsq_c;

  /* compute the rotation matrix */
  MAT_IDN(R);
  VMOVE( &R[0], Au );
  VMOVE( &R[4], Bu );
  VMOVE( &R[8], Cu );
  bn_mat_trn( superell->superell_invR, R );

  /* computer invRSSR */
  MAT_IDN(superell->superell_invRSSR);
  MAT_IDN(TEMP);
  TEMP[0] = superell->superell_invsq[0];
  TEMP[5] = superell->superell_invsq[1];
  TEMP[10] = superell->superell_invsq[2];
  bn_mat_mul(TEMP, TEMP, R);
  bn_mat_mul(superell->superell_invRSSR, superell->superell_invR, TEMP);

  /* compute Scale(Rotate(vect)) */
  MAT_IDN(superell->superell_SoR);
  VSCALE( &superell->superell_SoR[0], eip->a, superell->superell_invsq[0]);
  VSCALE( &superell->superell_SoR[4], eip->b, superell->superell_invsq[1]);
  VSCALE( &superell->superell_SoR[8], eip->c, superell->superell_invsq[2]);

  /* Compute bounding sphere */
  VMOVE( stp->st_center, eip->v );
  f = magsq_a;
  if( magsq_b > f )
    f = magsq_b;
  if( magsq_c > f )
    f = magsq_c;
  stp->st_aradius = stp->st_bradius = sqrt(f);
  
  /* Compute bounding RPP */
  VSET( w1, magsq_a, magsq_b, magsq_c );
  
  /* X */
  VSET( P, 1.0, 0, 0 );		/* bounding plane normal */
  MAT3X3VEC( w2, R, P );		/* map plane to local coord syst */
  VELMUL( w2, w2, w2 );		/* square each term */
  f = VDOT( w1, w2 );
  f = sqrt(f);
  stp->st_min[X] = superell->superell_V[X] - f;	/* V.P +/- f */
  stp->st_max[X] = superell->superell_V[X] + f;
  
  /* Y */
  VSET( P, 0, 1.0, 0 );		/* bounding plane normal */
  MAT3X3VEC( w2, R, P );		/* map plane to local coord syst */
  VELMUL( w2, w2, w2 );		/* square each term */
  f = VDOT( w1, w2 );
  f = sqrt(f);
  stp->st_min[Y] = superell->superell_V[Y] - f;	/* V.P +/- f */
  stp->st_max[Y] = superell->superell_V[Y] + f;
  
  /* Z */
  VSET( P, 0, 0, 1.0 );		/* bounding plane normal */
  MAT3X3VEC( w2, R, P );		/* map plane to local coord syst */
  VELMUL( w2, w2, w2 );		/* square each term */
  f = VDOT( w1, w2 );
  f = sqrt(f);
  stp->st_min[Z] = superell->superell_V[Z] - f;	/* V.P +/- f */
  stp->st_max[Z] = superell->superell_V[Z] + f;
  
  return(0);			/* OK */
}

/*
 *			R T _ S U P E R E L L _ P R I N T
 */
void
rt_superell_print(register const struct soltab *stp)
{
	register struct superell_specific *superell =
		(struct superell_specific *)stp->st_specific;

	VPRINT("V", superell->superell_V);
}

/*
 *  			R T _ S U P E R E L L _ S H O T
 *  
 *  Intersect a ray with an superellipsoid, where all constant terms have
 *  been precomputed by rt_superell_prep().  If an intersection occurs,
 *  a struct seg will be acquired and filled in.
 *  
 *  Returns -
 *  	0	MISS
 *	>0	HIT
 */
int
rt_superell_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
{
  static int counter=10;

#if 1
  register struct superell_specific *superell = (struct superell_specific *)stp->st_specific;
  LOCAL bn_poly_t equation; /* equation of superell to be solved */
  LOCAL vect_t translated;  /* translated shot vector */
  LOCAL vect_t newShotPoint; /* P' */
  LOCAL vect_t newShotDir; /* D' */
  LOCAL vect_t normalizedShotPoint; /* P' with normalized dist from superell */
  LOCAL bn_complex_t complexRoot[4]; /* roots returned from poly solver */
  LOCAL double realRoot[4];  /* real ray distance values */
  register int i,j;
  register struct seg *segp;

  /* translate ray point */
  /*  VSUB2(translated, rp->r_pt, superell->superell_V); */
  (translated)[X] = (rp->r_pt)[X] - (superell->superell_V)[X];
  (translated)[Y] = (rp->r_pt)[Y] - (superell->superell_V)[Y];
  (translated)[Z] = (rp->r_pt)[Z] - (superell->superell_V)[Z];

  /* scale and rotate point to get P' */

  /*  MAT4X3VEC(newShotPoint, superell->superell_SoR, translated); */
  newShotPoint[X] = (superell->superell_SoR[0]*translated[X] + superell->superell_SoR[1]*translated[Y] + superell->superell_SoR[ 2]*translated[Z]) * 1.0/(superell->superell_SoR[15]);
  newShotPoint[Y] = (superell->superell_SoR[4]*translated[X] + superell->superell_SoR[5]*translated[Y] + superell->superell_SoR[ 6]*translated[Z]) * 1.0/(superell->superell_SoR[15]);
  newShotPoint[Z] = (superell->superell_SoR[8]*translated[X] + superell->superell_SoR[9]*translated[Y] + superell->superell_SoR[10]*translated[Z]) * 1.0/(superell->superell_SoR[15]);

  /* translate ray direction vector */
  MAT4X3VEC(newShotDir, superell->superell_SoR, rp->r_dir);
  VUNITIZE(newShotDir);

  /* normalize distance from the superell.  substitues a corrected ray
   * point, which contains a translation along the ray direction to the 
   * closest approach to vertex of the superell.  Translating the ray
   * along the direction of the ray to the closest point near the
   * primitives center vertex.  New ray origin is hence, normalized.
   */
  VSCALE( normalizedShotPoint, newShotDir, 
	  VDOT( newShotPoint, newShotDir ));
  VSUB2( normalizedShotPoint, newShotPoint, normalizedShotPoint );

  /* Now generate the polynomial equation for passing to the root finder */
  
  equation.dgr = 2;

  equation.cf[0] = newShotPoint[X] * newShotPoint[X] * superell->superell_invmsAu + newShotPoint[Y] * newShotPoint[Y] * superell->superell_invmsBu + newShotPoint[Z] * newShotPoint[Z] * superell->superell_invmsCu - 1;
  equation.cf[1] = 2 * newShotDir[X] * newShotPoint[X] * superell->superell_invmsAu + 2 * newShotDir[Y] * newShotPoint[Y] * superell->superell_invmsBu + 2 * newShotDir[Z] * newShotPoint[Z] * superell->superell_invmsCu;
  equation.cf[2] = newShotDir[X] * newShotDir[X] * superell->superell_invmsAu  + newShotDir[Y] * newShotDir[Y] * superell->superell_invmsBu + newShotDir[Z] * newShotDir[Z] * superell->superell_invmsCu;

  if ( (i = rt_poly_roots( &equation, complexRoot)) != 2 ) {
    if (i != 0) {
      bu_log("superell, rt_poly_roots() 2 != %d\n", i);
      bn_pr_roots(stp->st_name, complexRoot, i);
    }
    return (0); /* MISS */
  }

  /* XXX BEGIN CUT */
  /*  Only real roots indicate an intersection in real space.
   *
   *  Look at each root returned; if the imaginary part is zero
   *  or sufficiently close, then use the real part as one value
   *  of 't' for the intersections
   */
  for ( j=0, i=0; j < 2; j++ ){
    if( NEAR_ZERO( complexRoot[j].im, 0.001 ) )
      realRoot[i++] = complexRoot[j].re;
  }
  
  /* reverse above translation by adding distance to all 'k' values. */
  //  for( j = 0; j < i; ++j )
  //    realRoot[j] -= VDOT(newShotPoint, newShotDir);
  
  /* Here, 'i' is number of points found */
  switch( i )  {
  case 0:
    return(0);		/* No hit */
    
  default:
    bu_log("rt_superell_shot: reduced 4 to %d roots\n",i);
    bn_pr_roots( stp->st_name, complexRoot, 4 );
    return(0);		/* No hit */
    
  case 2:
    {
      /* Sort most distant to least distant. */
      FAST fastf_t	u;
      if( (u=realRoot[0]) < realRoot[1] )  {
	/* bubble larger towards [0] */
	realRoot[0] = realRoot[1];
	realRoot[1] = u;
      }
    }
    break;
  case 4:
    {
      register short	n;
      register short	lim;
      
      /*  Inline rt_pt_sort().  Sorts realRoot[] into descending order. */
      for( lim = i-1; lim > 0; lim-- )  {
	for( n = 0; n < lim; n++ )  {
	  FAST fastf_t	u;
	  if( (u=realRoot[n]) < realRoot[n+1] )  {
	    /* bubble larger towards [0] */
	    realRoot[n] = realRoot[n+1];
	    realRoot[n+1] = u;
	  }
	}
      }
    }
    break;
  }

  if (counter > 0) {
    bu_log("realroot: in %d  out %d\n", realRoot[1], realRoot[0]);
    counter--;
  }


  /* Now, t[0] > t[npts-1] */
  /* realRoot[1] is entry point, and realRoot[0] is farthest exit point */
  RT_GET_SEG(segp, ap->a_resource);
  segp->seg_stp = stp;
  segp->seg_in.hit_dist = realRoot[1];
  segp->seg_out.hit_dist = realRoot[0];
  //  segp->seg_in.hit_surfno = segp->seg_out.hit_surfno = 0;
  /* Set aside vector for rt_superell_norm() later */
  //  VJOIN1( segp->seg_in.hit_vpriv, newShotPoint, realRoot[1], newShotDir );
  //  VJOIN1( segp->seg_out.hit_vpriv, newShotPoint, realRoot[0], newShotDir );
  BU_LIST_INSERT( &(seghead->l), &(segp->l) );
  
  if( i == 2 ) {
    return(2);			/* HIT */
  }
  
  /* 4 points */
  /* realRoot[3] is entry point, and realRoot[2] is exit point */
  RT_GET_SEG(segp, ap->a_resource);
  segp->seg_stp = stp;
  segp->seg_in.hit_dist = realRoot[3]*superell->superell_e;
  segp->seg_out.hit_dist = realRoot[2]*superell->superell_e;
  segp->seg_in.hit_surfno = segp->seg_out.hit_surfno = 1;
  VJOIN1( segp->seg_in.hit_vpriv, newShotPoint, realRoot[3], newShotDir );
  VJOIN1( segp->seg_out.hit_vpriv, newShotPoint, realRoot[2], newShotDir );
  BU_LIST_INSERT( &(seghead->l), &(segp->l) );
  return(4);			/* HIT */
  /* XXX END CUT */
  
  /* Is there any possibility of hitting another segment?  Only when there
   * is a concave curvature (<n,e> > <2.0, 2.0>).
   */
  if ( (superell->superell_n > 2.0) || (superell->superell_e > 2.0) ) {
    
  }

  return 1;
#else
  /* XXX ell code */
	register struct superell_specific *superell =
		(struct superell_specific *)stp->st_specific;
	register struct seg *segp;
	LOCAL vect_t	dprime;		/* D' */
	LOCAL vect_t	pprime;		/* P' */
	LOCAL vect_t	xlated;		/* translated vector */
	LOCAL fastf_t	dp, dd;		/* D' dot P', D' dot D' */
	LOCAL fastf_t	k1, k2;		/* distance constants of solution */
	FAST fastf_t	root;		/* root of radical */

	/* out, Mat, vect */
	MAT4X3VEC( dprime, superell->superell_SoR, rp->r_dir );
	VSUB2( xlated, rp->r_pt, superell->superell_V );
	MAT4X3VEC( pprime, superell->superell_SoR, xlated );

	dp = VDOT( dprime, pprime );
	dd = VDOT( dprime, dprime );

	if( (root = dp*dp - dd * (VDOT(pprime,pprime)-1.0)) < 0 )
		return(0);		/* No hit */
	root = sqrt(root);

	RT_GET_SEG(segp, ap->a_resource);
	segp->seg_stp = stp;
	if( (k1=(-dp+root)/dd) <= (k2=(-dp-root)/dd) )  {
		/* k1 is entry, k2 is exit */
		segp->seg_in.hit_dist = k1;
		segp->seg_out.hit_dist = k2;

		/* !!! please room */
		if (counter > 0) {
		  bu_log("realroot: in %d  out %d\n", k1, k2);
		  counter--;
		}

	} else {
		/* k2 is entry, k1 is exit */
		segp->seg_in.hit_dist = k2;
		segp->seg_out.hit_dist = k1;

		/* !!! please room */
		if (counter > 0) {
		  bu_log("realroot: in %d  out %d\n", k2, k1);
		  counter--;
		}

	}


	BU_LIST_INSERT( &(seghead->l), &(segp->l) );
	return(2);			/* HIT */


#endif
}


/*
 *			R T _ S U P E R E L L _ V S H O T
 *
 *  This is the Becker vector version.
 */
void
rt_superell_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		  	       /* Number of ray/object pairs */
                  	    
{
  return;
}


/*
 *  			R T _ S U P E R E L L _ N O R M
 *  
 *  Given ONE ray distance, return the normal and entry/exit point.
 */
void
rt_superell_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
{
  register struct superell_specific *superell =
    (struct superell_specific *)stp->st_specific;

  LOCAL vect_t xlated;
  LOCAL fastf_t scale;

  VJOIN1( hitp->hit_point, rp->r_pt, hitp->hit_dist, rp->r_dir );
  VSUB2( xlated, hitp->hit_point, superell->superell_V );
  MAT4X3VEC( hitp->hit_normal, superell->superell_invRSSR, xlated );
  scale = 1.0 / MAGNITUDE( hitp->hit_normal );
  VSCALE( hitp->hit_normal, hitp->hit_normal, scale );

  return;
}


/*
 *			R T _ S U P E R E L L _ C U R V E
 *
 *  Return the curvature of the superellipsoid.
 */
void
rt_superell_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
{
  bu_log("called rt_superell_curve!\n");
  return;
}


/*
 *  			R T _ S U P E R E L L _ U V
 *  
 *  For a hit on the surface of an SUPERELL, return the (u,v) coordinates
 *  of the hit point, 0 <= u,v <= 1.
 *  u = azimuth
 *  v = elevation
 */
void
rt_superell_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
{
  bu_log("called rt_superell_uv!\n");
  return;
}

/*
 *			R T _ S U P E R E L L _ F R E E
 */
void
rt_superell_free(register struct soltab *stp)
{
	register struct superell_specific *superell =
		(struct superell_specific *)stp->st_specific;

	bu_free( (char *)superell, "superell_specific" );
}


int
rt_superell_class(void)
{
	return(0);
}


/*
 *			R T _ S U P E R E L L _ 1 6 P T S
 *
 * Also used by the TGC code
 */
#define SUPERELLOUT(n)	ov+(n-1)*3
void
rt_superell_16pts(register fastf_t *ov,
	     register fastf_t *V,
	     fastf_t *A,
	     fastf_t *B)
{
	static fastf_t c, d, e, f,g,h;

	e = h = .92388;			/* cos(22.5) */
	c = d = .707107;		/* cos(45) */
	g = f = .382683;		/* cos(67.5) */

	/*
	 * For angle theta, compute surface point as
	 *
	 *	V  +  cos(theta) * A  + sin(theta) * B
	 *
	 * note that sin(theta) is cos(90-theta).
	 */

	VADD2( SUPERELLOUT(1), V, A );
	VJOIN2( SUPERELLOUT(2), V, e, A, f, B );
	VJOIN2( SUPERELLOUT(3), V, c, A, d, B );
	VJOIN2( SUPERELLOUT(4), V, g, A, h, B );
	VADD2( SUPERELLOUT(5), V, B );
	VJOIN2( SUPERELLOUT(6), V, -g, A, h, B );
	VJOIN2( SUPERELLOUT(7), V, -c, A, d, B );
	VJOIN2( SUPERELLOUT(8), V, -e, A, f, B );
	VSUB2( SUPERELLOUT(9), V, A );
	VJOIN2( SUPERELLOUT(10), V, -e, A, -f, B );
	VJOIN2( SUPERELLOUT(11), V, -c, A, -d, B );
	VJOIN2( SUPERELLOUT(12), V, -g, A, -h, B );
	VSUB2( SUPERELLOUT(13), V, B );
	VJOIN2( SUPERELLOUT(14), V, g, A, -h, B );
	VJOIN2( SUPERELLOUT(15), V, c, A, -d, B );
	VJOIN2( SUPERELLOUT(16), V, e, A, -f, B );
}

/*
 *			R T _ S U P E R E L L _ P L O T
 */
int
rt_superell_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
	register int		i;
	struct rt_superell_internal	*eip;
	fastf_t top[16*3];
	fastf_t middle[16*3];
	fastf_t bottom[16*3];

	RT_CK_DB_INTERNAL(ip);
	eip = (struct rt_superell_internal *)ip->idb_ptr;
	RT_SUPERELL_CK_MAGIC(eip);

	rt_superell_16pts( top, eip->v, eip->a, eip->b );
	rt_superell_16pts( bottom, eip->v, eip->b, eip->c );
	rt_superell_16pts( middle, eip->v, eip->a, eip->c );

	RT_ADD_VLIST( vhead, &top[15*ELEMENTS_PER_VECT], BN_VLIST_LINE_MOVE );
	for( i=0; i<16; i++ )  {
		RT_ADD_VLIST( vhead, &top[i*ELEMENTS_PER_VECT], BN_VLIST_LINE_DRAW );
	}

	RT_ADD_VLIST( vhead, &bottom[15*ELEMENTS_PER_VECT], BN_VLIST_LINE_MOVE );
	for( i=0; i<16; i++ )  {
		RT_ADD_VLIST( vhead, &bottom[i*ELEMENTS_PER_VECT], BN_VLIST_LINE_DRAW );
	}

	RT_ADD_VLIST( vhead, &middle[15*ELEMENTS_PER_VECT], BN_VLIST_LINE_MOVE );
	for( i=0; i<16; i++ )  {
		RT_ADD_VLIST( vhead, &middle[i*ELEMENTS_PER_VECT], BN_VLIST_LINE_DRAW );
	}
	return(0);
}

#if 0
static point_t	octa_verts[6] = {
	{ 1, 0, 0 },	/* XPLUS */
	{-1, 0, 0 },	/* XMINUS */
	{ 0, 1, 0 },	/* YPLUS */
	{ 0,-1, 0 },	/* YMINUS */
	{ 0, 0, 1 },	/* ZPLUS */
	{ 0, 0,-1 }	/* ZMINUS */
};

#define XPLUS 0
#define XMIN  1
#define YPLUS 2
#define YMIN  3
#define ZPLUS 4
#define ZMIN  5
#endif

/* Vertices of a unit octahedron */
/* These need to be organized properly to give reasonable normals */
/* static struct usvert {
 * 	int	a;
 * 	int	b;
 * 	int	c;
 * } octahedron[8] = {
 *     { XPLUS, ZPLUS, YPLUS },
 *     { YPLUS, ZPLUS, XMIN  },
 *     { XMIN , ZPLUS, YMIN  },
 *     { YMIN , ZPLUS, XPLUS },
 *     { XPLUS, YPLUS, ZMIN  },
 *     { YPLUS, XMIN , ZMIN  },
 *     { XMIN , YMIN , ZMIN  },
 *     { YMIN , XPLUS, ZMIN  }
 * };
 */
struct superell_state {
	struct shell	*s;
	struct rt_superell_internal	*eip;
	mat_t		invRinvS;
	mat_t		invRoS;
	fastf_t		theta_tol;
};

struct superell_vert_strip {
	int		nverts_per_strip;
	int		nverts;
	struct vertex	**vp;
	vect_t		*norms;
	int		nfaces;
	struct faceuse	**fu;
};

/*
 *			R T _ S U P E R E L L _ T E S S
 *
 *  Tesssuperellate an superellipsoid.
 *
 *  The strategy is based upon the approach of Jon Leech 3/24/89,
 *  from program "sphere", which generates a polygon mesh
 *  approximating a sphere by
 *  recursive subdivision. First approximation is an octahedron;
 *  each level of refinement increases the number of polygons by
 *  a factor of 4.
 *  Level 3 (128 polygons) is a good tradeoff if gouraud
 *  shading is used to render the database.
 *
 *  At the start, points ABC lie on surface of the unit sphere.
 *  Pick DEF as the midpoints of the three edges of ABC.
 *  Normalize the new points to lie on surface of the unit sphere.
 *
 *	  1
 *	  B
 *	 /\
 *    3 /  \ 4
 *    D/____\E
 *    /\    /\
 *   /	\  /  \
 *  /____\/____\
 * A      F     C
 * 0      5     2
 *
 *  Returns -
 *	-1	failure
 *	 0	OK.  *r points to nmgregion that holds this tesssuperellation.
 */
int
rt_superell_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
  bu_log("rt_superell_tess called!\n");
  return -1;
}

/*
 *			R T _ S U P E R E L L _ I M P O R T
 *
 *  Import an superellipsoid/sphere from the database format to
 *  the internal structure.
 *  Apply modeling transformations as wsuperell.
 */
int
rt_superell_import(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
{
	struct rt_superell_internal	*eip;
	union record		*rp;
	LOCAL fastf_t	vec[3*4 + 2];

	BU_CK_EXTERNAL( ep );
	rp = (union record *)ep->ext_buf;
	/* Check record type */
	if( rp->u_id != ID_SOLID )  {
		bu_log("rt_superell_import: defective record\n");
		return(-1);
	}

	RT_CK_DB_INTERNAL( ip );
	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_SUPERELL;
	ip->idb_meth = &rt_functab[ID_SUPERELL];
	ip->idb_ptr = bu_malloc( sizeof(struct rt_superell_internal), "rt_superell_internal");
	eip = (struct rt_superell_internal *)ip->idb_ptr;
	eip->magic = RT_SUPERELL_INTERNAL_MAGIC;

	/* Convert from database to internal format */
	rt_fastf_float( vec, rp->s.s_values, 4 );

	/* Apply modeling transformations */
	MAT4X3PNT( eip->v, mat, &vec[0*3] );
	MAT4X3VEC( eip->a, mat, &vec[1*3] );
	MAT4X3VEC( eip->b, mat, &vec[2*3] );
	MAT4X3VEC( eip->c, mat, &vec[3*3] );
	eip->n = rp->s.s_values[12];
	eip->e = rp->s.s_values[13];

	return(0);		/* OK */
}

/*
 *			R T _ S U P E R E L L _ E X P O R T
 */
int
rt_superell_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
{
	struct rt_superell_internal	*tip;
	union record		*rec;

	RT_CK_DB_INTERNAL(ip);
	if( ip->idb_type != ID_SUPERELL )  return(-1);
	tip = (struct rt_superell_internal *)ip->idb_ptr;
	RT_SUPERELL_CK_MAGIC(tip);

	BU_CK_EXTERNAL(ep);
	ep->ext_nbytes = sizeof(union record);
	ep->ext_buf = (genptr_t)bu_calloc( 1, ep->ext_nbytes, "superell external");
	rec = (union record *)ep->ext_buf;

	rec->s.s_id = ID_SOLID;
	rec->s.s_type = SUPERELL;

	/* NOTE: This also converts to dbfloat_t */
	VSCALE( &rec->s.s_values[0], tip->v, local2mm );
	VSCALE( &rec->s.s_values[3], tip->a, local2mm );
	VSCALE( &rec->s.s_values[6], tip->b, local2mm );
	VSCALE( &rec->s.s_values[9], tip->c, local2mm );

	printf("SUPERELL: %g %g\n", tip->n, tip->e);

	rec->s.s_values[12] = tip->n;
	rec->s.s_values[13] = tip->e;

	return(0);
}

/*
 *			R T _ S U P E R E L L _ I M P O R T 5
 *
 *  Import an superellipsoid/sphere from the database format to
 *  the internal structure.
 *  Apply modeling transformations as wsuperell.
 */
int
rt_superell_import5(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
{
	struct rt_superell_internal	*eip;
	fastf_t			vec[ELEMENTS_PER_VECT*4 + 2];

	RT_CK_DB_INTERNAL( ip );
	BU_CK_EXTERNAL( ep );

	BU_ASSERT_LONG( ep->ext_nbytes, ==, SIZEOF_NETWORK_DOUBLE * (ELEMENTS_PER_VECT*4 + 2));

	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_SUPERELL;
	ip->idb_meth = &rt_functab[ID_SUPERELL];
	ip->idb_ptr = bu_malloc( sizeof(struct rt_superell_internal), "rt_superell_internal");

	eip = (struct rt_superell_internal *)ip->idb_ptr;
	eip->magic = RT_SUPERELL_INTERNAL_MAGIC;

	/* Convert from database (network) to internal (host) format */
	ntohd( (unsigned char *)vec, ep->ext_buf, ELEMENTS_PER_VECT*4 + 2);

	/* Apply modeling transformations */
	MAT4X3PNT( eip->v, mat, &vec[0*ELEMENTS_PER_VECT] );
	MAT4X3VEC( eip->a, mat, &vec[1*ELEMENTS_PER_VECT] );
	MAT4X3VEC( eip->b, mat, &vec[2*ELEMENTS_PER_VECT] );
	MAT4X3VEC( eip->c, mat, &vec[3*ELEMENTS_PER_VECT] );
	eip->n = vec[4*ELEMENTS_PER_VECT];
	eip->e = vec[4*ELEMENTS_PER_VECT + 1];

	return 0;		/* OK */
}

/*
 *			R T _ S U P E R E L L _ E X P O R T 5
 *
 *  The external format is:
 *	V point
 *	A vector
 *	B vector
 *	C vector
 */
int
rt_superell_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
{
	struct rt_superell_internal	*eip;
	fastf_t			vec[ELEMENTS_PER_VECT*4 + 2];

	RT_CK_DB_INTERNAL(ip);
	if( ip->idb_type != ID_SUPERELL )  return(-1);
	eip = (struct rt_superell_internal *)ip->idb_ptr;
	RT_SUPERELL_CK_MAGIC(eip);

	BU_CK_EXTERNAL(ep);
	ep->ext_nbytes = SIZEOF_NETWORK_DOUBLE * (ELEMENTS_PER_VECT*4 + 2);
	ep->ext_buf = (genptr_t)bu_malloc( ep->ext_nbytes, "superell external");

	/* scale 'em into local buffer */
	VSCALE( &vec[0*ELEMENTS_PER_VECT], eip->v, local2mm );
	VSCALE( &vec[1*ELEMENTS_PER_VECT], eip->a, local2mm );
	VSCALE( &vec[2*ELEMENTS_PER_VECT], eip->b, local2mm );
	VSCALE( &vec[3*ELEMENTS_PER_VECT], eip->c, local2mm );

	vec[4*ELEMENTS_PER_VECT] = eip->n;
	vec[4*ELEMENTS_PER_VECT + 1] = eip->e;

	/* Convert from internal (host) to database (network) format */
	htond( ep->ext_buf, (unsigned char *)vec, ELEMENTS_PER_VECT*4 + 2 );

	return 0;
}

/*
 *			R T _ S U P E R E L L _ D E S C R I B E
 *
 *  Make human-readable formatted presentation of this solid.
 *  First line describes type of solid.
 *  Additional lines are indented one tab, and give parameter values.
 */
int
rt_superell_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
{
	register struct rt_superell_internal	*tip =
		(struct rt_superell_internal *)ip->idb_ptr;
	fastf_t	mag_a, mag_b, mag_c;
	char	buf[256];
	double	angles[5];
	vect_t	unitv;

	RT_SUPERELL_CK_MAGIC(tip);
	bu_vls_strcat( str, "superellipsoid (SUPERELL)\n");

	sprintf(buf, "\tV (%g, %g, %g)\n",
		tip->v[X] * mm2local,
		tip->v[Y] * mm2local,
		tip->v[Z] * mm2local );
	bu_vls_strcat( str, buf );

	mag_a = MAGNITUDE(tip->a);
	mag_b = MAGNITUDE(tip->b);
	mag_c = MAGNITUDE(tip->c);

	sprintf(buf, "\tA (%g, %g, %g) mag=%g\n",
		tip->a[X] * mm2local,
		tip->a[Y] * mm2local,
		tip->a[Z] * mm2local,
		mag_a * mm2local);
	bu_vls_strcat( str, buf );

	sprintf(buf, "\tB (%g, %g, %g) mag=%g\n",
		tip->b[X] * mm2local,
		tip->b[Y] * mm2local,
		tip->b[Z] * mm2local,
		mag_b * mm2local);
	bu_vls_strcat( str, buf );

	sprintf(buf, "\tC (%g, %g, %g) mag=%g\n",
		tip->c[X] * mm2local,
		tip->c[Y] * mm2local,
		tip->c[Z] * mm2local,
		mag_c * mm2local);
	bu_vls_strcat( str, buf );

	sprintf(buf, "\t<n,e> (%g, %g)\n", tip->n, tip->e);
	bu_vls_strcat(str, buf);

	if( !verbose )  return(0);

	VSCALE( unitv, tip->a, 1/mag_a );
	rt_find_fallback_angle( angles, unitv );
	rt_pr_fallback_angle( str, "\tA", angles );

	VSCALE( unitv, tip->b, 1/mag_b );
	rt_find_fallback_angle( angles, unitv );
	rt_pr_fallback_angle( str, "\tB", angles );

	VSCALE( unitv, tip->c, 1/mag_c );
	rt_find_fallback_angle( angles, unitv );
	rt_pr_fallback_angle( str, "\tC", angles );

	return(0);
}

/*
 *			R T _ S U P E R E L L _ I F R E E
 *
 *  Free the storage associated with the rt_db_internal version of this solid.
 */
void
rt_superell_ifree(struct rt_db_internal *ip)
{
	RT_CK_DB_INTERNAL(ip);
	bu_free( ip->idb_ptr, "superell ifree" );
	ip->idb_ptr = GENPTR_NULL;
}

/*  The U parameter runs south to north.
 *  In order to orient loop CCW, need to start with 0,1-->0,0 transition
 *  at the south pole.
 */
static const fastf_t rt_superell_uvw[5*ELEMENTS_PER_VECT] = {
	0, 1, 0,
	0, 0, 0,
	1, 0, 0,
	1, 1, 0,
	0, 1, 0
};

/*
 *			R T _ S U P E R E L L _ T N U R B
 */
int
rt_superell_tnurb(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct bn_tol *tol)
{
  bu_log("rt_superell_tnurb called!\n");
	return 0;
}

@


11.2
log
@change conf.h to a wrapped config.h
@
text
@d26 1
a26 1
static const char RCSsuperell[] = "@@(#)$Header: /cvs/brlcad/librt/g_superell.c,v 11.1 2004/04/05 08:48:57 morrison Exp $ (BRL)";
@


11.1
log
@merge of ansi-6-0-branch into HEAD
@
text
@d26 1
a26 1
static const char RCSsuperell[] = "@@(#)$Header$ (BRL)";
d29 5
a33 1
#include "conf.h"
@


1.1
log
@file g_superell.c was initially added on branch ansi-6-0-branch.
@
text
@d1 1094
@


1.1.2.1
log
@Added initial stubbed support for a new primitive -- a superquadric ellipsoid.  The primitive may be created in mged, but it has the same guts as the ellipsoid
@
text
@a0 1608
/*
 *			G _ S U P E R E L L . C
 *
 *  Purpose -
 *	Intersect a ray with a Superquadratic Ellipsoid
 *
 *  Authors -
 *      Christopher Sean Morrison
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1985 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSsuperell[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_superell.c,v 1.1.1.1 2003/01/20 18:01:33 morrison Exp $ (BRL)";
#endif

#include "conf.h"

#include <stdio.h>
#ifdef HAVE_STRING_H
#include <string.h>
#endif
#include <math.h>
#include "machine.h"
#include "vmath.h"
#include "db.h"
#include "nmg.h"
#include "raytrace.h"
#include "nurb.h"
#include "rtgeom.h"
#include "./debug.h"

const struct bu_structparse rt_superell_parse[] = {
    { "%f", 3, "V", offsetof(struct rt_superell_internal, v[X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 3, "A", offsetof(struct rt_superell_internal, a[X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 3, "B", offsetof(struct rt_superell_internal, b[X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 3, "C", offsetof(struct rt_superell_internal, c[X]), BU_STRUCTPARSE_FUNC_NULL },
    { {'\0','\0','\0','\0'}, 0, (char *)NULL, 0, BU_STRUCTPARSE_FUNC_NULL }
 };


/*
 *  Algorithm:
 *  
 *  Given V, A, B, and C, there is a set of points on this superellipsoid
 *  
 *  { (x,y,z) | (x,y,z) is on superellipsoid defined by V, A, B, C }
 *  
 *  Through a series of Affine Transformations, this set will be
 *  transformed into a set of points on a unit sphere at the origin
 *  
 *  { (x',y',z') | (x',y',z') is on Sphere at origin }
 *  
 *  The transformation from X to X' is accomplished by:
 *  
 *  X' = S(R( X - V ))
 *  
 *  where R(X) =  ( A/(|A|) )
 *  		 (  B/(|B|)  ) . X
 *  		  ( C/(|C|) )
 *  
 *  and S(X) =	 (  1/|A|   0     0   )
 *  		(    0    1/|B|   0    ) . X
 *  		 (   0      0   1/|C| )
 *  
 *  To find the intersection of a line with the superellipsoid, consider
 *  the parametric line L:
 *  
 *  	L : { P(n) | P + t(n) . D }
 *  
 *  Call W the actual point of intersection between L and the superellipsoid.
 *  Let W' be the point of intersection between L' and the unit sphere.
 *  
 *  	L' : { P'(n) | P' + t(n) . D' }
 *  
 *  W = invR( invS( W' ) ) + V
 *  
 *  Where W' = k D' + P'.
 *  
 *  Let dp = D' dot P'
 *  Let dd = D' dot D'
 *  Let pp = P' dot P'
 *  
 *  and k = [ -dp +/- sqrt( dp*dp - dd * (pp - 1) ) ] / dd
 *  which is constant.
 *  
 *  Now, D' = S( R( D ) )
 *  and  P' = S( R( P - V ) )
 *  
 *  Substituting,
 *  
 *  W = V + invR( invS[ k *( S( R( D ) ) ) + S( R( P - V ) ) ] )
 *    = V + invR( ( k * R( D ) ) + R( P - V ) )
 *    = V + k * D + P - V
 *    = k * D + P
 *  
 *  Note that ``k'' is constant, and is the same in the formulations
 *  for both W and W'.
 *  
 *  NORMALS.  Given the point W on the superellipsoid, what is the vector
 *  normal to the tangent plane at that point?
 *  
 *  Map W onto the unit sphere, ie:  W' = S( R( W - V ) ).
 *  
 *  Plane on unit sphere at W' has a normal vector of the same value(!).
 *  N' = W'
 *  
 *  The plane transforms back to the tangent plane at W, and this
 *  new plane (on the superellipsoid) has a normal vector of N, viz:
 *  
 *  N = inverse[ transpose( inverse[ S o R ] ) ] ( N' )
 *
 *  because if H is perpendicular to plane Q, and matrix M maps from
 *  Q to Q', then inverse[ transpose(M) ] (H) is perpendicular to Q'.
 *  Here, H and Q are in "prime space" with the unit sphere.
 *  [Somehow, the notation here is backwards].
 *  So, the mapping matrix M = inverse( S o R ), because
 *  S o R maps from normal space to the unit sphere.
 *
 *  N = inverse[ transpose( inverse[ S o R ] ) ] ( N' )
 *    = inverse[ transpose(invR o invS) ] ( N' )
 *    = inverse[ transpose(invS) o transpose(invR) ] ( N' )
 *    = inverse[ inverse(S) o R ] ( N' )
 *    = invR o S ( N' )
 *
 *    = invR o S ( W' )
 *    = invR( S( S( R( W - V ) ) ) )
 *
 *  because inverse(R) = transpose(R), so R = transpose( invR ),
 *  and S = transpose( S ).
 *
 *  Note that the normal vector N produced above will not have unit length.
 */

struct superell_specific {
	vect_t	superell_V;		/* Vector to center of superellipsoid */
	vect_t	superell_Au;		/* unit-length A vector */
	vect_t	superell_Bu;
	vect_t	superell_Cu;
	vect_t	superell_invsq;	/* [ 1/(|A|**2), 1/(|B|**2), 1/(|C|**2) ] */
	mat_t	superell_SoR;	/* Scale(Rot(vect)) */
	mat_t	superell_invRSSR;	/* invRot(Scale(Scale(Rot(vect)))) */
};
#define SUPERELL_NULL	((struct superell_specific *)0)

/*
 *  			R T _ S U P E R E L L _ P R E P
 *  
 *  Given a pointer to a GED database record, and a transformation matrix,
 *  determine if this is a valid superellipsoid, and if so, precompute various
 *  terms of the formula.
 *  
 *  Returns -
 *  	0	SUPERELL is OK
 *  	!0	Error in description
 *  
 *  Implicit return -
 *  	A struct superell_specific is created, and it's address is stored in
 *  	stp->st_specific for use by rt_superell_shot().
 */
int
rt_superell_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
{
	register struct superell_specific *superell;
	struct rt_superell_internal	*eip;
	LOCAL fastf_t	magsq_a, magsq_b, magsq_c;
	LOCAL mat_t	R;
	LOCAL mat_t	Rinv;
	LOCAL mat_t	SS;
	LOCAL mat_t	mtemp;
	LOCAL vect_t	Au, Bu, Cu;	/* A,B,C with unit length */
	LOCAL vect_t	w1, w2, P;	/* used for bounding RPP */
	LOCAL fastf_t	f;

	eip = (struct rt_superell_internal *)ip->idb_ptr;
	RT_SUPERELL_CK_MAGIC(eip);

	/* Validate that |A| > 0, |B| > 0, |C| > 0 */
	magsq_a = MAGSQ( eip->a );
	magsq_b = MAGSQ( eip->b );
	magsq_c = MAGSQ( eip->c );

	/* XXX this coded constant stuff will bite us someday soon */
	if( magsq_a < 0.005 || magsq_b < 0.005 || magsq_c < 0.005 ) {
		bu_log("sph(%s):  zero length A(%g), B(%g), or C(%g) vector\n",
			stp->st_name, magsq_a, magsq_b, magsq_c );
		return(1);		/* BAD */
	}

	/* Create unit length versions of A,B,C */
	f = 1.0/sqrt(magsq_a);
	VSCALE( Au, eip->a, f );
	f = 1.0/sqrt(magsq_b);
	VSCALE( Bu, eip->b, f );
	f = 1.0/sqrt(magsq_c);
	VSCALE( Cu, eip->c, f );

	/* Validate that A.B == 0, B.C == 0, A.C == 0 (check dir only) */
	f = VDOT( Au, Bu );
	if( ! NEAR_ZERO(f, 0.005) )  {
		bu_log("superell(%s):  A not perpendicular to B, f=%f\n",stp->st_name, f);
		return(1);		/* BAD */
	}
	f = VDOT( Bu, Cu );
	if( ! NEAR_ZERO(f, 0.005) )  {
		bu_log("superell(%s):  B not perpendicular to C, f=%f\n",stp->st_name, f);
		return(1);		/* BAD */
	}
	f = VDOT( Au, Cu );
	if( ! NEAR_ZERO(f, 0.005) )  {
		bu_log("superell(%s):  A not perpendicular to C, f=%f\n",stp->st_name, f);
		return(1);		/* BAD */
	}

	/* Solid is OK, compute constant terms now */
	BU_GETSTRUCT( superell, superell_specific );
	stp->st_specific = (genptr_t)superell;

	VMOVE( superell->superell_V, eip->v );

	VSET( superell->superell_invsq, 1.0/magsq_a, 1.0/magsq_b, 1.0/magsq_c );
	VMOVE( superell->superell_Au, Au );
	VMOVE( superell->superell_Bu, Bu );
	VMOVE( superell->superell_Cu, Cu );

	MAT_IDN( superell->superell_SoR );
	MAT_IDN( R );

	/* Compute R and Rinv matrices */
	VMOVE( &R[0], Au );
	VMOVE( &R[4], Bu );
	VMOVE( &R[8], Cu );
	bn_mat_trn( Rinv, R );			/* inv of rot mat is trn */

	/* Compute SoS (Affine transformation) */
	MAT_IDN( SS );
	SS[ 0] = superell->superell_invsq[0];
	SS[ 5] = superell->superell_invsq[1];
	SS[10] = superell->superell_invsq[2];

	/* Compute invRSSR */
	bn_mat_mul( mtemp, SS, R );
	bn_mat_mul( superell->superell_invRSSR, Rinv, mtemp );

	/* Compute SoR */
	VSCALE( &superell->superell_SoR[0], eip->a, superell->superell_invsq[0] );
	VSCALE( &superell->superell_SoR[4], eip->b, superell->superell_invsq[1] );
	VSCALE( &superell->superell_SoR[8], eip->c, superell->superell_invsq[2] );

	/* Compute bounding sphere */
	VMOVE( stp->st_center, eip->v );
	f = magsq_a;
	if( magsq_b > f )
		f = magsq_b;
	if( magsq_c > f )
		f = magsq_c;
	stp->st_aradius = stp->st_bradius = sqrt(f);

	/* Compute bounding RPP */
	VSET( w1, magsq_a, magsq_b, magsq_c );

	/* X */
	VSET( P, 1.0, 0, 0 );		/* bounding plane normal */
	MAT3X3VEC( w2, R, P );		/* map plane to local coord syst */
	VELMUL( w2, w2, w2 );		/* square each term */
	f = VDOT( w1, w2 );
	f = sqrt(f);
	stp->st_min[X] = superell->superell_V[X] - f;	/* V.P +/- f */
	stp->st_max[X] = superell->superell_V[X] + f;

	/* Y */
	VSET( P, 0, 1.0, 0 );		/* bounding plane normal */
	MAT3X3VEC( w2, R, P );		/* map plane to local coord syst */
	VELMUL( w2, w2, w2 );		/* square each term */
	f = VDOT( w1, w2 );
	f = sqrt(f);
	stp->st_min[Y] = superell->superell_V[Y] - f;	/* V.P +/- f */
	stp->st_max[Y] = superell->superell_V[Y] + f;

	/* Z */
	VSET( P, 0, 0, 1.0 );		/* bounding plane normal */
	MAT3X3VEC( w2, R, P );		/* map plane to local coord syst */
	VELMUL( w2, w2, w2 );		/* square each term */
	f = VDOT( w1, w2 );
	f = sqrt(f);
	stp->st_min[Z] = superell->superell_V[Z] - f;	/* V.P +/- f */
	stp->st_max[Z] = superell->superell_V[Z] + f;

	return(0);			/* OK */
}

/*
 *			R T _ S U P E R E L L _ P R I N T
 */
void
rt_superell_print(register const struct soltab *stp)
{
	register struct superell_specific *superell =
		(struct superell_specific *)stp->st_specific;

	VPRINT("V", superell->superell_V);
	bn_mat_print("S o R", superell->superell_SoR );
	bn_mat_print("invRSSR", superell->superell_invRSSR );
}

/*
 *  			R T _ S U P E R E L L _ S H O T
 *  
 *  Intersect a ray with an superellipsoid, where all constant terms have
 *  been precomputed by rt_superell_prep().  If an intersection occurs,
 *  a struct seg will be acquired and filled in.
 *  
 *  Returns -
 *  	0	MISS
 *	>0	HIT
 */
int
rt_superell_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
{
	register struct superell_specific *superell =
		(struct superell_specific *)stp->st_specific;
	register struct seg *segp;
	LOCAL vect_t	dprime;		/* D' */
	LOCAL vect_t	pprime;		/* P' */
	LOCAL vect_t	xlated;		/* translated vector */
	LOCAL fastf_t	dp, dd;		/* D' dot P', D' dot D' */
	LOCAL fastf_t	k1, k2;		/* distance constants of solution */
	FAST fastf_t	root;		/* root of radical */

	/* out, Mat, vect */
	MAT4X3VEC( dprime, superell->superell_SoR, rp->r_dir );
	VSUB2( xlated, rp->r_pt, superell->superell_V );
	MAT4X3VEC( pprime, superell->superell_SoR, xlated );

	dp = VDOT( dprime, pprime );
	dd = VDOT( dprime, dprime );

	if( (root = dp*dp - dd * (VDOT(pprime,pprime)-1.0)) < 0 )
		return(0);		/* No hit */
	root = sqrt(root);

	RT_GET_SEG(segp, ap->a_resource);
	segp->seg_stp = stp;
	if( (k1=(-dp+root)/dd) <= (k2=(-dp-root)/dd) )  {
		/* k1 is entry, k2 is exit */
		segp->seg_in.hit_dist = k1;
		segp->seg_out.hit_dist = k2;
	} else {
		/* k2 is entry, k1 is exit */
		segp->seg_in.hit_dist = k2;
		segp->seg_out.hit_dist = k1;
	}
	BU_LIST_INSERT( &(seghead->l), &(segp->l) );
	return(2);			/* HIT */
}

#define RT_SUPERELL_SEG_MISS(SEG)	(SEG).seg_stp=RT_SOLTAB_NULL

/*
 *			R T _ S U P E R E L L _ V S H O T
 *
 *  This is the Becker vector version.
 */
void
rt_superell_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		  	       /* Number of ray/object pairs */
                  	    
{
	register int    i;
	register struct superell_specific *superell;
	LOCAL vect_t	dprime;		/* D' */
	LOCAL vect_t	pprime;		/* P' */
	LOCAL vect_t	xlated;		/* translated vector */
	LOCAL fastf_t	dp, dd;		/* D' dot P', D' dot D' */
	LOCAL fastf_t	k1, k2;		/* distance constants of solution */
	FAST fastf_t	root;		/* root of radical */

	/* for each ray/superellipse pair */
#	include "noalias.h"
	for(i = 0; i < n; i++){
#if !CRAY /* XXX currently prevents vectorization on cray */
	 	if (stp[i] == 0) continue; /* stp[i] == 0 signals skip ray */
#endif
		superell = (struct superell_specific *)stp[i]->st_specific;

		MAT4X3VEC( dprime, superell->superell_SoR, rp[i]->r_dir );
		VSUB2( xlated, rp[i]->r_pt, superell->superell_V );
		MAT4X3VEC( pprime, superell->superell_SoR, xlated );

		dp = VDOT( dprime, pprime );
		dd = VDOT( dprime, dprime );

		if( (root = dp*dp - dd * (VDOT(pprime,pprime)-1.0)) < 0 ) {
			RT_SUPERELL_SEG_MISS(segp[i]);		/* No hit */
		}
	        else {
			root = sqrt(root);

			segp[i].seg_stp = stp[i];

			if( (k1=(-dp+root)/dd) <= (k2=(-dp-root)/dd) )  {
				/* k1 is entry, k2 is exit */
				segp[i].seg_in.hit_dist = k1;
				segp[i].seg_out.hit_dist = k2;
			} else {
				/* k2 is entry, k1 is exit */
				segp[i].seg_in.hit_dist = k2;
				segp[i].seg_out.hit_dist = k1;
			}
		}
	}
}

/*
 *  			R T _ S U P E R E L L _ N O R M
 *  
 *  Given ONE ray distance, return the normal and entry/exit point.
 */
void
rt_superell_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
{
	register struct superell_specific *superell =
		(struct superell_specific *)stp->st_specific;
	LOCAL vect_t xlated;
	LOCAL fastf_t scale;

	VJOIN1( hitp->hit_point, rp->r_pt, hitp->hit_dist, rp->r_dir );
	VSUB2( xlated, hitp->hit_point, superell->superell_V );
	MAT4X3VEC( hitp->hit_normal, superell->superell_invRSSR, xlated );
	scale = 1.0 / MAGNITUDE( hitp->hit_normal );
	VSCALE( hitp->hit_normal, hitp->hit_normal, scale );

	/* tuck away this scale for the curvature routine */
	hitp->hit_vpriv[X] = scale;
}

/*
 *			R T _ S U P E R E L L _ C U R V E
 *
 *  Return the curvature of the superellipsoid.
 */
void
rt_superell_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
{
	register struct superell_specific *superell =
		(struct superell_specific *)stp->st_specific;
	vect_t	u, v;			/* basis vectors (with normal) */
	vect_t	vec1, vec2;		/* eigen vectors */
	vect_t	tmp;
	fastf_t	a, b, c, scale;

	/*
	 * choose a tangent plane coordinate system
	 *  (u, v, normal) form a right-handed triple
	 */
	bn_vec_ortho( u, hitp->hit_normal );
	VCROSS( v, hitp->hit_normal, u );

	/* get the saved away scale factor */
	scale = - hitp->hit_vpriv[X];

	/* find the second fundamental form */
	MAT4X3VEC( tmp, superell->superell_invRSSR, u );
	a = VDOT(u, tmp) * scale;
	b = VDOT(v, tmp) * scale;
	MAT4X3VEC( tmp, superell->superell_invRSSR, v );
	c = VDOT(v, tmp) * scale;

	bn_eigen2x2( &cvp->crv_c1, &cvp->crv_c2, vec1, vec2, a, b, c );
	VCOMB2( cvp->crv_pdir, vec1[X], u, vec1[Y], v );
	VUNITIZE( cvp->crv_pdir );
}

/*
 *  			R T _ S U P E R E L L _ U V
 *  
 *  For a hit on the surface of an SUPERELL, return the (u,v) coordinates
 *  of the hit point, 0 <= u,v <= 1.
 *  u = azimuth
 *  v = elevation
 */
void
rt_superell_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
{
	register struct superell_specific *superell =
		(struct superell_specific *)stp->st_specific;
	LOCAL vect_t work;
	LOCAL vect_t pprime;
	LOCAL fastf_t r;

	/* hit_point is on surface;  project back to unit sphere,
	 * creating a vector from vertex to hit point which always
	 * has length=1.0
	 */
	VSUB2( work, hitp->hit_point, superell->superell_V );
	MAT4X3VEC( pprime, superell->superell_SoR, work );
	/* Assert that pprime has unit length */

	/* U is azimuth, atan() range: -pi to +pi */
	uvp->uv_u = bn_atan2( pprime[Y], pprime[X] ) * bn_inv2pi;
	if( uvp->uv_u < 0 )
		uvp->uv_u += 1.0;
	/*
	 *  V is elevation, atan() range: -pi/2 to +pi/2,
	 *  because sqrt() ensures that X parameter is always >0
	 */
	uvp->uv_v = bn_atan2( pprime[Z],
		sqrt( pprime[X] * pprime[X] + pprime[Y] * pprime[Y]) ) *
		bn_invpi + 0.5;

	/* approximation: r / (circumference, 2 * pi * aradius) */
	r = ap->a_rbeam + ap->a_diverge * hitp->hit_dist;
	uvp->uv_du = uvp->uv_dv =
		bn_inv2pi * r / stp->st_aradius;
}

/*
 *			R T _ S U P E R E L L _ F R E E
 */
void
rt_superell_free(register struct soltab *stp)
{
	register struct superell_specific *superell =
		(struct superell_specific *)stp->st_specific;

	bu_free( (char *)superell, "superell_specific" );
}

int
rt_superell_class(void)
{
	return(0);
}

/*
 *			R T _ S U P E R E L L _ 1 6 P T S
 *
 * Also used by the TGC code
 */
#define SUPERELLOUT(n)	ov+(n-1)*3
void
rt_superell_16pts(register fastf_t *ov,
	     register fastf_t *V,
	     fastf_t *A,
	     fastf_t *B)
{
	static fastf_t c, d, e, f,g,h;

	e = h = .92388;			/* cos(22.5) */
	c = d = .707107;		/* cos(45) */
	g = f = .382683;		/* cos(67.5) */

	/*
	 * For angle theta, compute surface point as
	 *
	 *	V  +  cos(theta) * A  + sin(theta) * B
	 *
	 * note that sin(theta) is cos(90-theta).
	 */

	VADD2( SUPERELLOUT(1), V, A );
	VJOIN2( SUPERELLOUT(2), V, e, A, f, B );
	VJOIN2( SUPERELLOUT(3), V, c, A, d, B );
	VJOIN2( SUPERELLOUT(4), V, g, A, h, B );
	VADD2( SUPERELLOUT(5), V, B );
	VJOIN2( SUPERELLOUT(6), V, -g, A, h, B );
	VJOIN2( SUPERELLOUT(7), V, -c, A, d, B );
	VJOIN2( SUPERELLOUT(8), V, -e, A, f, B );
	VSUB2( SUPERELLOUT(9), V, A );
	VJOIN2( SUPERELLOUT(10), V, -e, A, -f, B );
	VJOIN2( SUPERELLOUT(11), V, -c, A, -d, B );
	VJOIN2( SUPERELLOUT(12), V, -g, A, -h, B );
	VSUB2( SUPERELLOUT(13), V, B );
	VJOIN2( SUPERELLOUT(14), V, g, A, -h, B );
	VJOIN2( SUPERELLOUT(15), V, c, A, -d, B );
	VJOIN2( SUPERELLOUT(16), V, e, A, -f, B );
}

/*
 *			R T _ S U P E R E L L _ P L O T
 */
int
rt_superell_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
	register int		i;
	struct rt_superell_internal	*eip;
	fastf_t top[16*3];
	fastf_t middle[16*3];
	fastf_t bottom[16*3];

	RT_CK_DB_INTERNAL(ip);
	eip = (struct rt_superell_internal *)ip->idb_ptr;
	RT_SUPERELL_CK_MAGIC(eip);

	rt_superell_16pts( top, eip->v, eip->a, eip->b );
	rt_superell_16pts( bottom, eip->v, eip->b, eip->c );
	rt_superell_16pts( middle, eip->v, eip->a, eip->c );

	RT_ADD_VLIST( vhead, &top[15*ELEMENTS_PER_VECT], BN_VLIST_LINE_MOVE );
	for( i=0; i<16; i++ )  {
		RT_ADD_VLIST( vhead, &top[i*ELEMENTS_PER_VECT], BN_VLIST_LINE_DRAW );
	}

	RT_ADD_VLIST( vhead, &bottom[15*ELEMENTS_PER_VECT], BN_VLIST_LINE_MOVE );
	for( i=0; i<16; i++ )  {
		RT_ADD_VLIST( vhead, &bottom[i*ELEMENTS_PER_VECT], BN_VLIST_LINE_DRAW );
	}

	RT_ADD_VLIST( vhead, &middle[15*ELEMENTS_PER_VECT], BN_VLIST_LINE_MOVE );
	for( i=0; i<16; i++ )  {
		RT_ADD_VLIST( vhead, &middle[i*ELEMENTS_PER_VECT], BN_VLIST_LINE_DRAW );
	}
	return(0);
}

#if 0
static point_t	octa_verts[6] = {
	{ 1, 0, 0 },	/* XPLUS */
	{-1, 0, 0 },	/* XMINUS */
	{ 0, 1, 0 },	/* YPLUS */
	{ 0,-1, 0 },	/* YMINUS */
	{ 0, 0, 1 },	/* ZPLUS */
	{ 0, 0,-1 }	/* ZMINUS */
};

#define XPLUS 0
#define XMIN  1
#define YPLUS 2
#define YMIN  3
#define ZPLUS 4
#define ZMIN  5
#endif

/* Vertices of a unit octahedron */
/* These need to be organized properly to give reasonable normals */
/* static struct usvert {
 * 	int	a;
 * 	int	b;
 * 	int	c;
 * } octahedron[8] = {
 *     { XPLUS, ZPLUS, YPLUS },
 *     { YPLUS, ZPLUS, XMIN  },
 *     { XMIN , ZPLUS, YMIN  },
 *     { YMIN , ZPLUS, XPLUS },
 *     { XPLUS, YPLUS, ZMIN  },
 *     { YPLUS, XMIN , ZMIN  },
 *     { XMIN , YMIN , ZMIN  },
 *     { YMIN , XPLUS, ZMIN  }
 * };
 */
struct superell_state {
	struct shell	*s;
	struct rt_superell_internal	*eip;
	mat_t		invRinvS;
	mat_t		invRoS;
	fastf_t		theta_tol;
};

struct superell_vert_strip {
	int		nverts_per_strip;
	int		nverts;
	struct vertex	**vp;
	vect_t		*norms;
	int		nfaces;
	struct faceuse	**fu;
};

/*
 *			R T _ S U P E R E L L _ T E S S
 *
 *  Tesssuperellate an superellipsoid.
 *
 *  The strategy is based upon the approach of Jon Leech 3/24/89,
 *  from program "sphere", which generates a polygon mesh
 *  approximating a sphere by
 *  recursive subdivision. First approximation is an octahedron;
 *  each level of refinement increases the number of polygons by
 *  a factor of 4.
 *  Level 3 (128 polygons) is a good tradeoff if gouraud
 *  shading is used to render the database.
 *
 *  At the start, points ABC lie on surface of the unit sphere.
 *  Pick DEF as the midpoints of the three edges of ABC.
 *  Normalize the new points to lie on surface of the unit sphere.
 *
 *	  1
 *	  B
 *	 /\
 *    3 /  \ 4
 *    D/____\E
 *    /\    /\
 *   /	\  /  \
 *  /____\/____\
 * A      F     C
 * 0      5     2
 *
 *  Returns -
 *	-1	failure
 *	 0	OK.  *r points to nmgregion that holds this tesssuperellation.
 */
int
rt_superell_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
	LOCAL mat_t	R;
	LOCAL mat_t	S;
	LOCAL mat_t	invR;
	LOCAL mat_t	invS;
	LOCAL vect_t	Au, Bu, Cu;	/* A,B,C with unit length */
	LOCAL fastf_t	Alen, Blen, Clen;
	LOCAL fastf_t	invAlen, invBlen, invClen;
	LOCAL fastf_t	magsq_a, magsq_b, magsq_c;
	LOCAL fastf_t	f;
	struct superell_state	state;
	register int		i;
	fastf_t		radius;
	int		nsegs;
	int		nstrips;
	struct superell_vert_strip	*strips;
	int		j;
	struct vertex		**vertp[4];
	int	faceno;
	int	stripno;
	int	boff;		/* base offset */
	int	toff;		/* top offset */
	int	blim;		/* base subscript limit */
	int	tlim;		/* top subscrpit limit */
	fastf_t	rel;		/* Absolutized relative tolerance */

	RT_CK_DB_INTERNAL(ip);
	state.eip = (struct rt_superell_internal *)ip->idb_ptr;
	RT_SUPERELL_CK_MAGIC(state.eip);

	/* Validate that |A| > 0, |B| > 0, |C| > 0 */
	magsq_a = MAGSQ( state.eip->a );
	magsq_b = MAGSQ( state.eip->b );
	magsq_c = MAGSQ( state.eip->c );
	if( magsq_a < 0.005 || magsq_b < 0.005 || magsq_c < 0.005 ) {
		bu_log("rt_superell_tess():  zero length A, B, or C vector\n");
		return(-2);		/* BAD */
	}

	/* Create unit length versions of A,B,C */
	invAlen = 1.0/(Alen = sqrt(magsq_a));
	VSCALE( Au, state.eip->a, invAlen );
	invBlen = 1.0/(Blen = sqrt(magsq_b));
	VSCALE( Bu, state.eip->b, invBlen );
	invClen = 1.0/(Clen = sqrt(magsq_c));
	VSCALE( Cu, state.eip->c, invClen );

	/* Validate that A.B == 0, B.C == 0, A.C == 0 (check dir only) */
	f = VDOT( Au, Bu );
	if( ! NEAR_ZERO(f, 0.005) )  {
		bu_log("superell():  A not perpendicular to B, f=%f\n", f);
		return(-3);		/* BAD */
	}
	f = VDOT( Bu, Cu );
	if( ! NEAR_ZERO(f, 0.005) )  {
		bu_log("superell():  B not perpendicular to C, f=%f\n", f);
		return(-3);		/* BAD */
	}
	f = VDOT( Au, Cu );
	if( ! NEAR_ZERO(f, 0.005) )  {
		bu_log("superell():  A not perpendicular to C, f=%f\n", f);
		return(-3);		/* BAD */
	}

	{
		vect_t	axb;
		VCROSS( axb, Au, Bu );
		f = VDOT( axb, Cu );
		if( f < 0 )  {
			VREVERSE( Cu, Cu );
			VREVERSE( state.eip->c, state.eip->c );
		}
	}

	/* Compute R and Rinv matrices */
	MAT_IDN( R );
	VMOVE( &R[0], Au );
	VMOVE( &R[4], Bu );
	VMOVE( &R[8], Cu );
	bn_mat_trn( invR, R );			/* inv of rot mat is trn */

	/* Compute S and invS matrices */
	/* invS is just 1/diagonal elements */
	MAT_IDN( S );
	S[ 0] = invAlen;
	S[ 5] = invBlen;
	S[10] = invClen;
	bn_mat_inv( invS, S );

	/* invRinvS, for converting points from unit sphere to model */
	bn_mat_mul( state.invRinvS, invR, invS );

	/* invRoS, for converting normals from unit sphere to model */
	bn_mat_mul( state.invRoS, invR, S );

	/* Compute radius of bounding sphere */
	radius = Alen;
	if( Blen > radius )
		radius = Blen;
	if( Clen > radius )
		radius = Clen;

	/*
	 *  Establish tolerances
	 */
	if( ttol->rel <= 0.0 || ttol->rel >= 1.0 )  {
		rel = 0.0;		/* none */
	} else {
		/* Convert rel to absolute by scaling by radius */
		rel = ttol->rel * radius;
	}
	if( ttol->abs <= 0.0 )  {
		if( rel <= 0.0 )  {
			/* No tolerance given, use a default */
			rel = 0.10 * radius;	/* 10% */
		} else {
			/* Use absolute-ized relative tolerance */
		}
	} else {
		/* Absolute tolerance was given, pick smaller */
		if( ttol->rel <= 0.0 || rel > ttol->abs )
		{
			rel = ttol->abs;
			if( rel > radius )
				rel = radius;
		}
	}

	/*
	 *  Converte distance tolerance into a maximum permissible
	 *  angle tolerance.  'radius' is largest radius.
	 */
	state.theta_tol = 2 * acos( 1.0 - rel / radius );

	/* To ensure normal tolerance, remain below this angle */
	if( ttol->norm > 0.0 && ttol->norm < state.theta_tol )  {
		state.theta_tol = ttol->norm;
	}

	*r = nmg_mrsv( m );	/* Make region, empty shell, vertex */
	state.s = BU_LIST_FIRST(shell, &(*r)->s_hd);

	/* Find the number of segments to divide 90 degrees worth into */
	nsegs = (int)(bn_halfpi / state.theta_tol + 0.999);
	if( nsegs < 2 )  nsegs = 2;

	/*  Find total number of strips of vertices that will be needed.
	 *  nsegs for each hemisphere, plus the equator.
	 *  Note that faces are listed in the the stripe ABOVE, ie, toward
	 *  the poles.  Thus, strips[0] will have 4 faces.
	 */
	nstrips = 2 * nsegs + 1;
	strips = (struct superell_vert_strip *)bu_calloc( nstrips,
		sizeof(struct superell_vert_strip), "strips[]" );

	/* North pole */
	strips[0].nverts = 1;
	strips[0].nverts_per_strip = 0;
	strips[0].nfaces = 4;
	/* South pole */
	strips[nstrips-1].nverts = 1;
	strips[nstrips-1].nverts_per_strip = 0;
	strips[nstrips-1].nfaces = 4;
	/* equator */
	strips[nsegs].nverts = nsegs * 4;
	strips[nsegs].nverts_per_strip = nsegs;
	strips[nsegs].nfaces = 0;

	for( i=1; i<nsegs; i++ )  {
		strips[i].nverts_per_strip =
			strips[nstrips-1-i].nverts_per_strip = i;
		strips[i].nverts =
			strips[nstrips-1-i].nverts = i * 4;
		strips[i].nfaces =
			strips[nstrips-1-i].nfaces = (2 * i + 1)*4;
	}
	/* All strips have vertices and normals */
	for( i=0; i<nstrips; i++ )  {
		strips[i].vp = (struct vertex **)bu_calloc( strips[i].nverts,
			sizeof(struct vertex *), "strip vertex[]" );
		strips[i].norms = (vect_t *)bu_calloc( strips[i].nverts,
			sizeof( vect_t ), "strip normals[]" );
	}
	/* All strips have faces, except for the equator */
	for( i=0; i < nstrips; i++ )  {
		if( strips[i].nfaces <= 0 )  continue;
		strips[i].fu = (struct faceuse **)bu_calloc( strips[i].nfaces,
			sizeof(struct faceuse *), "strip faceuse[]" );
	}

	/* First, build the triangular mesh topology */
	/* Do the top. "toff" in i-1 is UP, towards +B */
	for( i = 1; i <= nsegs; i++ )  {
		faceno = 0;
		tlim = strips[i-1].nverts;
		blim = strips[i].nverts;
		for( stripno=0; stripno<4; stripno++ )  {
			toff = stripno * strips[i-1].nverts_per_strip;
			boff = stripno * strips[i].nverts_per_strip;

			/* Connect this quarter strip */
			for( j = 0; j < strips[i].nverts_per_strip; j++ )  {

				/* "Right-side-up" triangle */
				vertp[0] = &(strips[i].vp[j+boff]);
				vertp[1] = &(strips[i-1].vp[(j+toff)%tlim]);
				vertp[2] = &(strips[i].vp[(j+1+boff)%blim]);
				if( (strips[i-1].fu[faceno++] = nmg_cmface(state.s, vertp, 3 )) == 0 )  {
					bu_log("rt_superell_tess() nmg_cmface failure\n");
					goto fail;
				}
				if( j+1 >= strips[i].nverts_per_strip )  break;

				/* Follow with interior "Up-side-down" triangle */
				vertp[0] = &(strips[i].vp[(j+1+boff)%blim]);
				vertp[1] = &(strips[i-1].vp[(j+toff)%tlim]);
				vertp[2] = &(strips[i-1].vp[(j+1+toff)%tlim]);
				if( (strips[i-1].fu[faceno++] = nmg_cmface(state.s, vertp, 3 )) == 0 )  {
					bu_log("rt_superell_tess() nmg_cmface failure\n");
					goto fail;
				}
			}
		}
	}
	/* Do the bottom.  Everything is upside down. "toff" in i+1 is DOWN */
	for( i = nsegs; i < nstrips; i++ )  {
		faceno = 0;
		tlim = strips[i+1].nverts;
		blim = strips[i].nverts;
		for( stripno=0; stripno<4; stripno++ )  {
			toff = stripno * strips[i+1].nverts_per_strip;
			boff = stripno * strips[i].nverts_per_strip;

			/* Connect this quarter strip */
			for( j = 0; j < strips[i].nverts_per_strip; j++ )  {

				/* "Right-side-up" triangle */
				vertp[0] = &(strips[i].vp[j+boff]);
				vertp[1] = &(strips[i].vp[(j+1+boff)%blim]);
				vertp[2] = &(strips[i+1].vp[(j+toff)%tlim]);
				if( (strips[i+1].fu[faceno++] = nmg_cmface(state.s, vertp, 3 )) == 0 )  {
					bu_log("rt_superell_tess() nmg_cmface failure\n");
					goto fail;
				}
				if( j+1 >= strips[i].nverts_per_strip )  break;

				/* Follow with interior "Up-side-down" triangle */
				vertp[0] = &(strips[i].vp[(j+1+boff)%blim]);
				vertp[1] = &(strips[i+1].vp[(j+1+toff)%tlim]);
				vertp[2] = &(strips[i+1].vp[(j+toff)%tlim]);
				if( (strips[i+1].fu[faceno++] = nmg_cmface(state.s, vertp, 3 )) == 0 )  {
					bu_log("rt_superell_tess() nmg_cmface failure\n");
					goto fail;
				}
			}
		}
	}

	/*  Compute the geometry of each vertex.
	 *  Start with the location in the unit sphere, and project back.
	 *  i=0 is "straight up" along +B.
	 */
	for( i=0; i < nstrips; i++ )  {
		double	alpha;		/* decline down from B to A */
		double	beta;		/* angle around equator (azimuth) */
		fastf_t		cos_alpha, sin_alpha;
		fastf_t		cos_beta, sin_beta;
		point_t		sphere_pt;
		point_t		model_pt;

		alpha = (((double)i) / (nstrips-1));
		cos_alpha = cos(alpha*bn_pi);
		sin_alpha = sin(alpha*bn_pi);
		for( j=0; j < strips[i].nverts; j++ )  {

			beta = ((double)j) / strips[i].nverts;
			cos_beta = cos(beta*bn_twopi);
			sin_beta = sin(beta*bn_twopi);
			VSET( sphere_pt,
				cos_beta * sin_alpha,
				cos_alpha,
				sin_beta * sin_alpha );
			/* Convert from ideal sphere coordinates */
			MAT4X3PNT( model_pt, state.invRinvS, sphere_pt );
			VADD2( model_pt, model_pt, state.eip->v );
			/* Associate vertex geometry */
			nmg_vertex_gv( strips[i].vp[j], model_pt );

			/* Convert sphere normal to superellipsoid normal */
			MAT4X3VEC( strips[i].norms[j], state.invRoS, sphere_pt );
			/* May not be unit length anymore */
			VUNITIZE( strips[i].norms[j] );
		}
	}

	/* Associate face geometry.  Equator has no faces */
	for( i=0; i < nstrips; i++ )  {
		for( j=0; j < strips[i].nfaces; j++ )  {
			if( nmg_fu_planeeqn( strips[i].fu[j], tol ) < 0 )
				goto fail;
		}
	}

	/* Associate normals with vertexuses */
	for( i=0; i < nstrips; i++ )
	{
		for( j=0; j < strips[i].nverts; j++ )
		{
			struct faceuse *fu;
			struct vertexuse *vu;
			vect_t norm_opp;

			NMG_CK_VERTEX( strips[i].vp[j] );
			VREVERSE( norm_opp , strips[i].norms[j] )

			for( BU_LIST_FOR( vu , vertexuse , &strips[i].vp[j]->vu_hd ) )
			{
				fu = nmg_find_fu_of_vu( vu );
				NMG_CK_FACEUSE( fu );
				/* get correct direction of normals depending on
				 * faceuse orientation
				 */
				if( fu->orientation == OT_SAME )
					nmg_vertexuse_nv( vu , strips[i].norms[j] );
				else if( fu->orientation == OT_OPPOSITE )
					nmg_vertexuse_nv( vu , norm_opp );
			}
		}
	}

	/* Compute "geometry" for region and shell */
	nmg_region_a( *r, tol );

	/* Release memory */
	/* All strips have vertices and normals */
	for( i=0; i<nstrips; i++ )  {
		bu_free( (char *)strips[i].vp, "strip vertex[]" );
		bu_free( (char *)strips[i].norms, "strip norms[]" );
	}
	/* All strips have faces, except for equator */
	for( i=0; i < nstrips; i++ )  {
		if( strips[i].fu == (struct faceuse **)0 )  continue;
		bu_free( (char *)strips[i].fu, "strip faceuse[]" );
	}
	bu_free( (char *)strips, "strips[]" );
	return(0);
fail:
	/* Release memory */
	/* All strips have vertices and normals */
	for( i=0; i<nstrips; i++ )  {
		bu_free( (char *)strips[i].vp, "strip vertex[]" );
		bu_free( (char *)strips[i].norms, "strip norms[]" );
	}
	/* All strips have faces, except for equator */
	for( i=0; i < nstrips; i++ )  {
		if( strips[i].fu == (struct faceuse **)0 )  continue;
		bu_free( (char *)strips[i].fu, "strip faceuse[]" );
	}
	bu_free( (char *)strips, "strips[]" );
	return(-1);
}

/*
 *			R T _ S U P E R E L L _ I M P O R T
 *
 *  Import an superellipsoid/sphere from the database format to
 *  the internal structure.
 *  Apply modeling transformations as wsuperell.
 */
int
rt_superell_import(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
{
	struct rt_superell_internal	*eip;
	union record		*rp;
	LOCAL fastf_t	vec[3*4];

	BU_CK_EXTERNAL( ep );
	rp = (union record *)ep->ext_buf;
	/* Check record type */
	if( rp->u_id != ID_SOLID )  {
		bu_log("rt_superell_import: defective record\n");
		return(-1);
	}

	RT_CK_DB_INTERNAL( ip );
	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_SUPERELL;
	ip->idb_meth = &rt_functab[ID_SUPERELL];
	ip->idb_ptr = bu_malloc( sizeof(struct rt_superell_internal), "rt_superell_internal");
	eip = (struct rt_superell_internal *)ip->idb_ptr;
	eip->magic = RT_SUPERELL_INTERNAL_MAGIC;

	/* Convert from database to internal format */
	rt_fastf_float( vec, rp->s.s_values, 4 );

	/* Apply modeling transformations */
	MAT4X3PNT( eip->v, mat, &vec[0*3] );
	MAT4X3VEC( eip->a, mat, &vec[1*3] );
	MAT4X3VEC( eip->b, mat, &vec[2*3] );
	MAT4X3VEC( eip->c, mat, &vec[3*3] );

	return(0);		/* OK */
}

/*
 *			R T _ S U P E R E L L _ E X P O R T
 */
int
rt_superell_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
{
	struct rt_superell_internal	*tip;
	union record		*rec;

	RT_CK_DB_INTERNAL(ip);
	if( ip->idb_type != ID_SUPERELL )  return(-1);
	tip = (struct rt_superell_internal *)ip->idb_ptr;
	RT_SUPERELL_CK_MAGIC(tip);

	BU_CK_EXTERNAL(ep);
	ep->ext_nbytes = sizeof(union record);
	ep->ext_buf = (genptr_t)bu_calloc( 1, ep->ext_nbytes, "superell external");
	rec = (union record *)ep->ext_buf;

	rec->s.s_id = ID_SOLID;
	rec->s.s_type = SUPERELL;

	/* NOTE: This also converts to dbfloat_t */
	VSCALE( &rec->s.s_values[0], tip->v, local2mm );
	VSCALE( &rec->s.s_values[3], tip->a, local2mm );
	VSCALE( &rec->s.s_values[6], tip->b, local2mm );
	VSCALE( &rec->s.s_values[9], tip->c, local2mm );

	return(0);
}

/*
 *			R T _ S U P E R E L L _ I M P O R T 5
 *
 *  Import an superellipsoid/sphere from the database format to
 *  the internal structure.
 *  Apply modeling transformations as wsuperell.
 */
int
rt_superell_import5(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
{
	struct rt_superell_internal	*eip;
	fastf_t			vec[ELEMENTS_PER_VECT*4];

	RT_CK_DB_INTERNAL( ip );
	BU_CK_EXTERNAL( ep );

	BU_ASSERT_LONG( ep->ext_nbytes, ==, SIZEOF_NETWORK_DOUBLE * ELEMENTS_PER_VECT*4 );

	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_SUPERELL;
	ip->idb_meth = &rt_functab[ID_SUPERELL];
	ip->idb_ptr = bu_malloc( sizeof(struct rt_superell_internal), "rt_superell_internal");

	eip = (struct rt_superell_internal *)ip->idb_ptr;
	eip->magic = RT_SUPERELL_INTERNAL_MAGIC;

	/* Convert from database (network) to internal (host) format */
	ntohd( (unsigned char *)vec, ep->ext_buf, ELEMENTS_PER_VECT*4 );

	/* Apply modeling transformations */
	MAT4X3PNT( eip->v, mat, &vec[0*ELEMENTS_PER_VECT] );
	MAT4X3VEC( eip->a, mat, &vec[1*ELEMENTS_PER_VECT] );
	MAT4X3VEC( eip->b, mat, &vec[2*ELEMENTS_PER_VECT] );
	MAT4X3VEC( eip->c, mat, &vec[3*ELEMENTS_PER_VECT] );

	return 0;		/* OK */
}

/*
 *			R T _ S U P E R E L L _ E X P O R T 5
 *
 *  The external format is:
 *	V point
 *	A vector
 *	B vector
 *	C vector
 */
int
rt_superell_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
{
	struct rt_superell_internal	*eip;
	fastf_t			vec[ELEMENTS_PER_VECT*4];

	RT_CK_DB_INTERNAL(ip);
	if( ip->idb_type != ID_SUPERELL )  return(-1);
	eip = (struct rt_superell_internal *)ip->idb_ptr;
	RT_SUPERELL_CK_MAGIC(eip);

	BU_CK_EXTERNAL(ep);
	ep->ext_nbytes = SIZEOF_NETWORK_DOUBLE * ELEMENTS_PER_VECT*4;
	ep->ext_buf = (genptr_t)bu_malloc( ep->ext_nbytes, "superell external");

	/* scale 'em into local buffer */
	VSCALE( &vec[0*ELEMENTS_PER_VECT], eip->v, local2mm );
	VSCALE( &vec[1*ELEMENTS_PER_VECT], eip->a, local2mm );
	VSCALE( &vec[2*ELEMENTS_PER_VECT], eip->b, local2mm );
	VSCALE( &vec[3*ELEMENTS_PER_VECT], eip->c, local2mm );

	/* Convert from internal (host) to database (network) format */
	htond( ep->ext_buf, (unsigned char *)vec, ELEMENTS_PER_VECT*4 );

	return 0;
}

/*
 *			R T _ S U P E R E L L _ D E S C R I B E
 *
 *  Make human-readable formatted presentation of this solid.
 *  First line describes type of solid.
 *  Additional lines are indented one tab, and give parameter values.
 */
int
rt_superell_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
{
	register struct rt_superell_internal	*tip =
		(struct rt_superell_internal *)ip->idb_ptr;
	fastf_t	mag_a, mag_b, mag_c;
	char	buf[256];
	double	angles[5];
	vect_t	unitv;

	RT_SUPERELL_CK_MAGIC(tip);
	bu_vls_strcat( str, "superellipsoid (SUPERELL)\n");

	sprintf(buf, "\tV (%g, %g, %g)\n",
		tip->v[X] * mm2local,
		tip->v[Y] * mm2local,
		tip->v[Z] * mm2local );
	bu_vls_strcat( str, buf );

	mag_a = MAGNITUDE(tip->a);
	mag_b = MAGNITUDE(tip->b);
	mag_c = MAGNITUDE(tip->c);

	sprintf(buf, "\tA (%g, %g, %g) mag=%g\n",
		tip->a[X] * mm2local,
		tip->a[Y] * mm2local,
		tip->a[Z] * mm2local,
		mag_a * mm2local);
	bu_vls_strcat( str, buf );

	sprintf(buf, "\tB (%g, %g, %g) mag=%g\n",
		tip->b[X] * mm2local,
		tip->b[Y] * mm2local,
		tip->b[Z] * mm2local,
		mag_b * mm2local);
	bu_vls_strcat( str, buf );

	sprintf(buf, "\tC (%g, %g, %g) mag=%g\n",
		tip->c[X] * mm2local,
		tip->c[Y] * mm2local,
		tip->c[Z] * mm2local,
		mag_c * mm2local);
	bu_vls_strcat( str, buf );

	if( !verbose )  return(0);

	VSCALE( unitv, tip->a, 1/mag_a );
	rt_find_fallback_angle( angles, unitv );
	rt_pr_fallback_angle( str, "\tA", angles );

	VSCALE( unitv, tip->b, 1/mag_b );
	rt_find_fallback_angle( angles, unitv );
	rt_pr_fallback_angle( str, "\tB", angles );

	VSCALE( unitv, tip->c, 1/mag_c );
	rt_find_fallback_angle( angles, unitv );
	rt_pr_fallback_angle( str, "\tC", angles );

	return(0);
}

/*
 *			R T _ S U P E R E L L _ I F R E E
 *
 *  Free the storage associated with the rt_db_internal version of this solid.
 */
void
rt_superell_ifree(struct rt_db_internal *ip)
{
	RT_CK_DB_INTERNAL(ip);
	bu_free( ip->idb_ptr, "superell ifree" );
	ip->idb_ptr = GENPTR_NULL;
}

/*  The U parameter runs south to north.
 *  In order to orient loop CCW, need to start with 0,1-->0,0 transition
 *  at the south pole.
 */
static const fastf_t rt_superell_uvw[5*ELEMENTS_PER_VECT] = {
	0, 1, 0,
	0, 0, 0,
	1, 0, 0,
	1, 1, 0,
	0, 1, 0
};

/*
 *			R T _ S U P E R E L L _ T N U R B
 */
int
rt_superell_tnurb(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct bn_tol *tol)
{
	LOCAL mat_t	R;
	LOCAL mat_t	S;
	LOCAL mat_t	invR;
	LOCAL mat_t	invS;
	mat_t		invRinvS;
	mat_t		invRoS;
	LOCAL mat_t	unit2model;
	LOCAL mat_t	xlate;
	LOCAL vect_t	Au, Bu, Cu;	/* A,B,C with unit length */
	LOCAL fastf_t	Alen, Blen, Clen;
	LOCAL fastf_t	invAlen, invBlen, invClen;
	LOCAL fastf_t	magsq_a, magsq_b, magsq_c;
	LOCAL fastf_t	f;
	register int		i;
	fastf_t		radius;
	struct rt_superell_internal	*eip;
	struct vertex		*verts[8];
	struct vertex		**vertp[4];
	struct faceuse		*fu;
	struct shell		*s;
	struct loopuse		*lu;
	struct edgeuse		*eu;
	point_t			pole;

	RT_CK_DB_INTERNAL(ip);
	eip = (struct rt_superell_internal *)ip->idb_ptr;
	RT_SUPERELL_CK_MAGIC(eip);

	/* Validate that |A| > 0, |B| > 0, |C| > 0 */
	magsq_a = MAGSQ( eip->a );
	magsq_b = MAGSQ( eip->b );
	magsq_c = MAGSQ( eip->c );
	if( magsq_a < 0.005 || magsq_b < 0.005 || magsq_c < 0.005 ) {
		bu_log("rt_superell_tess():  zero length A, B, or C vector\n");
		return(-2);		/* BAD */
	}

	/* Create unit length versions of A,B,C */
	invAlen = 1.0/(Alen = sqrt(magsq_a));
	VSCALE( Au, eip->a, invAlen );
	invBlen = 1.0/(Blen = sqrt(magsq_b));
	VSCALE( Bu, eip->b, invBlen );
	invClen = 1.0/(Clen = sqrt(magsq_c));
	VSCALE( Cu, eip->c, invClen );

	/* Validate that A.B == 0, B.C == 0, A.C == 0 (check dir only) */
	f = VDOT( Au, Bu );
	if( ! NEAR_ZERO(f, 0.005) )  {
		bu_log("superell():  A not perpendicular to B, f=%f\n", f);
		return(-3);		/* BAD */
	}
	f = VDOT( Bu, Cu );
	if( ! NEAR_ZERO(f, 0.005) )  {
		bu_log("superell():  B not perpendicular to C, f=%f\n", f);
		return(-3);		/* BAD */
	}
	f = VDOT( Au, Cu );
	if( ! NEAR_ZERO(f, 0.005) )  {
		bu_log("superell():  A not perpendicular to C, f=%f\n", f);
		return(-3);		/* BAD */
	}

	{
		vect_t	axb;
		VCROSS( axb, Au, Bu );
		f = VDOT( axb, Cu );
		if( f < 0 )  {
			VREVERSE( Cu, Cu );
			VREVERSE( eip->c, eip->c );
		}
	}

	/* Compute R and Rinv matrices */
	MAT_IDN( R );
	VMOVE( &R[0], Au );
	VMOVE( &R[4], Bu );
	VMOVE( &R[8], Cu );
	bn_mat_trn( invR, R );			/* inv of rot mat is trn */

	/* Compute S and invS matrices */
	/* invS is just 1/diagonal elements */
	MAT_IDN( S );
	S[ 0] = invAlen;
	S[ 5] = invBlen;
	S[10] = invClen;
	bn_mat_inv( invS, S );

	/* invRinvS, for converting points from unit sphere to model */
	bn_mat_mul( invRinvS, invR, invS );

	/* invRoS, for converting normals from unit sphere to model */
	bn_mat_mul( invRoS, invR, S );

	/* Compute radius of bounding sphere */
	radius = Alen;
	if( Blen > radius )
		radius = Blen;
	if( Clen > radius )
		radius = Clen;

	MAT_IDN( xlate );
	MAT_DELTAS_VEC( xlate, eip->v );
	bn_mat_mul( unit2model, xlate, invRinvS );

	/*
	 *  --- Build Topology ---
	 *
	 *  There is a vertex at either pole, and a single longitude line.
	 *  There is a single face, an snurb with singularities.
	 *  vert[0] is the south pole, and is the first row of the ctl_points.
	 *  vert[1] is the north pole, and is the last row of the ctl_points.
	 *
	 *  Somewhat surprisingly, the U parameter runs from south to north.
	 */
	for( i=0; i<8; i++ )  verts[i] = (struct vertex *)0;

	*r = nmg_mrsv( m );	/* Make region, empty shell, vertex */
	s = BU_LIST_FIRST(shell, &(*r)->s_hd);

	vertp[0] = &verts[0];
	vertp[1] = &verts[0];
	vertp[2] = &verts[1];
	vertp[3] = &verts[1];

	if( (fu = nmg_cmface( s, vertp, 4 )) == 0 )  {
		bu_log("rt_superell_tnurb(%s): nmg_cmface() fail on face\n");
		return -1;
	}

	/* March around the fu's loop assigning uv parameter values */
	lu = BU_LIST_FIRST( loopuse, &fu->lu_hd );
	NMG_CK_LOOPUSE(lu);
	eu = BU_LIST_FIRST( edgeuse, &lu->down_hd );
	NMG_CK_EDGEUSE(eu);

	/* Loop always has Counter-Clockwise orientation (CCW) */
	for( i=0; i < 4; i++ )  {
		nmg_vertexuse_a_cnurb( eu->vu_p, &rt_superell_uvw[i*ELEMENTS_PER_VECT] );
		nmg_vertexuse_a_cnurb( eu->eumate_p->vu_p, &rt_superell_uvw[(i+1)*ELEMENTS_PER_VECT] );
		eu = BU_LIST_NEXT( edgeuse, &eu->l );
	}

	/* Associate vertex geometry */
	VSUB2( pole, eip->v, eip->c );		/* south pole */
	nmg_vertex_gv( verts[0], pole );
	VADD2( pole, eip->v, eip->c );
	nmg_vertex_gv( verts[1], pole );	/* north pole */

 	/* Build snurb, transformed into final position */
	/*nmg_sphere_face_snurb( fu, unit2model );*/

	/* Associate edge geometry (trimming curve) -- linear in param space */
	eu = BU_LIST_FIRST( edgeuse, &lu->down_hd );
	NMG_CK_EDGEUSE(eu);
	for( i=0; i < 4; i++ )  {
#if 0
struct snurb sn;
fastf_t	param[4];
bu_log("\neu=x%x, vu=x%x, v=x%x  ", eu, eu->vu_p, eu->vu_p->v_p);
VPRINT("xyz", eu->vu_p->v_p->vg_p->coord);
nmg_hack_snurb( &sn, fu->f_p->g.snurb_p );
VPRINT("uv", eu->vu_p->a.cnurb_p->param);
rt_nurb_s_eval( &sn, V2ARGS(eu->vu_p->a.cnurb_p->param), param );
VPRINT("surf(u,v)", param);
#endif

		nmg_edge_g_cnurb_plinear(eu);
		eu = BU_LIST_NEXT( edgeuse, &eu->l );
	}

	/* Compute "geometry" for region and shell */
	nmg_region_a( *r, tol );

	return 0;
}

/*
 *  u,v=(0,0) is supposed to be the south pole, at Z=-1.0
 *  The V direction runs from the south to the north pole.
 */
static void
nmg_sphere_face_snurb(struct faceuse *fu, const matp_t m)
{
	struct face_g_snurb	*fg;
	FAST fastf_t root2_2;
	register fastf_t	*op;

	NMG_CK_FACEUSE(fu);
	root2_2 = sqrt(2.0)*0.5;

	/* Let the library allocate all the storage */
	/* The V direction runs from south to north pole */
	nmg_face_g_snurb( fu,
		3, 3,		/* u,v order */
		8, 12,		/* Number of knots, u,v */
		NULL, NULL,	/* initial u,v knot vectors */
		9, 5,		/* n_rows, n_cols */
		RT_NURB_MAKE_PT_TYPE( 4, RT_NURB_PT_XYZ, RT_NURB_PT_RATIONAL ),
		NULL );		/* initial mesh */

	fg = fu->f_p->g.snurb_p;
	NMG_CK_FACE_G_SNURB(fg);

	fg->v.knots[ 0] = 0;
	fg->v.knots[ 1] = 0;
	fg->v.knots[ 2] = 0;
	fg->v.knots[ 3] = 0.25;
	fg->v.knots[ 4] = 0.25;
	fg->v.knots[ 5] = 0.5;
	fg->v.knots[ 6] = 0.5;
	fg->v.knots[ 7] = 0.75;
	fg->v.knots[ 8] = 0.75;
	fg->v.knots[ 9] = 1;
	fg->v.knots[10] = 1;
	fg->v.knots[11] = 1;

	fg->u.knots[0] = 0;
	fg->u.knots[1] = 0;
	fg->u.knots[2] = 0;
	fg->u.knots[3] = 0.5;
	fg->u.knots[4] = 0.5;
	fg->u.knots[5] = 1;
	fg->u.knots[6] = 1;
	fg->u.knots[7] = 1;

	op = fg->ctl_points;

/* Inspired by MAT4X4PNT */
#define M(x,y,z,w)	{ \
	*op++ = m[ 0]*(x) + m[ 1]*(y) + m[ 2]*(z) + m[ 3]*(w);\
	*op++ = m[ 4]*(x) + m[ 5]*(y) + m[ 6]*(z) + m[ 7]*(w);\
	*op++ = m[ 8]*(x) + m[ 9]*(y) + m[10]*(z) + m[11]*(w);\
	*op++ = m[12]*(x) + m[13]*(y) + m[14]*(z) + m[15]*(w); }


	M(   0     ,   0     ,-1.0     , 1.0     );
	M( root2_2 ,   0     ,-root2_2 , root2_2 );
	M( 1.0     ,   0     ,   0     , 1.0     );
	M( root2_2 ,   0     , root2_2 , root2_2 );
	M(   0     ,   0     , 1.0     , 1.0     );

	M(   0     ,   0     ,-root2_2 , root2_2 );
	M( 0.5     ,-0.5     ,-0.5     , 0.5     );
	M( root2_2 ,-root2_2 ,   0     , root2_2 );
	M( 0.5     ,-0.5     , 0.5     , 0.5     );
	M(   0     ,   0     , root2_2 , root2_2 );

	M(   0     ,   0     ,-1.0     , 1.0     );
	M(   0     ,-root2_2 ,-root2_2 , root2_2 );
	M(   0     ,-1.0     ,   0     , 1.0     );
	M(   0     ,-root2_2 , root2_2 , root2_2 );
	M(   0     ,   0     , 1.0     , 1.0     );

	M(   0     ,   0     ,-root2_2 , root2_2 );
	M(-0.5     ,-0.5     ,-0.5     , 0.5     );
	M(-root2_2 ,-root2_2 ,   0     , root2_2 );
	M(-0.5     ,-0.5     , 0.5     , 0.5     );
	M(   0     ,   0     , root2_2 , root2_2 );

	M(   0     ,   0     ,-1.0     , 1.0     );
	M(-root2_2 ,   0     ,-root2_2 , root2_2 );
	M(-1.0     ,   0     ,   0     , 1.0     );
	M(-root2_2 ,   0     , root2_2 , root2_2 );
	M(   0     ,   0     , 1.0     , 1.0     );

	M(   0     ,   0     ,-root2_2 , root2_2 );
	M(-0.5     , 0.5     ,-0.5     , 0.5     );
	M(-root2_2 , root2_2 ,   0     , root2_2 );
	M(-0.5     , 0.5     , 0.5     , 0.5     );
	M(   0     ,   0     , root2_2 , root2_2 );

	M(   0     ,   0     ,-1.0     , 1.0     );
	M(   0     , root2_2 ,-root2_2 , root2_2 );
	M(   0     , 1.0     ,   0     , 1.0     );
	M(   0     , root2_2 , root2_2 , root2_2 );
	M(   0     ,   0     , 1.0     , 1.0     );

	M(   0     ,   0     ,-root2_2 , root2_2 );
	M( 0.5     , 0.5     ,-0.5     , 0.5     );
	M( root2_2 , root2_2 ,   0     , root2_2 );
	M( 0.5     , 0.5     , 0.5     , 0.5     );
	M(   0     ,   0     , root2_2 , root2_2 );

	M(   0     ,   0     ,-1.0     , 1.0     );
	M( root2_2 ,   0     ,-root2_2 , root2_2 );
	M( 1.0     ,   0     ,   0     , 1.0     );
	M( root2_2 ,   0     , root2_2 , root2_2 );
	M(   0     ,   0     , 1.0     , 1.0     );
}
@


1.1.2.2
log
@Added the superell specific options and database support for <n,e>, the north-south and east-west curvature params.
@
text
@d8 1
a8 2
 *      Christopher Sean Morrison (Programming)
 *      Edwin O. Davisson (Mathmatics)
d20 1
a20 1
static const char RCSsuperell[] = "@@(#)$Header: /c/CVS/brlcad/librt/Attic/g_superell.c,v 1.1.2.1 2003/01/31 00:12:29 morrison Exp $ (BRL)";
a43 2
    { "%f", 1, "n", offsetof(struct rt_superell_internal, n), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 1, "e", offsetof(struct rt_superell_internal, e), BU_STRUCTPARSE_FUNC_NULL },
d146 3
a148 2
  double superell_n; /* north-south curvature power */
  double superell_e; /* east-west curvature power */
d190 1
a190 1
	if( magsq_a < rtip->rti_tol.dist || magsq_b < rtip->rti_tol.dist || magsq_c < rtip->rti_tol.dist ) {
d206 1
a206 1
	if( ! NEAR_ZERO(f, rtip->rti_tol.dist) )  {
d211 1
a211 1
	if( ! NEAR_ZERO(f, rtip->rti_tol.dist) )  {
d216 1
a216 1
	if( ! NEAR_ZERO(f, rtip->rti_tol.dist) )  {
a221 1

d227 1
a227 1
	//	VSET( superell->superell_invsq, 1.0/magsq_a, 1.0/magsq_b, 1.0/magsq_c );
d232 24
d308 2
d326 35
a360 1
  return 0;
d363 1
d378 43
a420 1
  return;
a422 1

d431 13
a443 1
  return;
a445 1

d454 27
a480 1
  return 0;
a482 1

d494 30
a523 1
  return;
a537 1

a543 1

d713 359
a1071 1
  return -1;
d1086 1
a1086 1
	LOCAL fastf_t	vec[3*4 + 2];
a1111 2
	eip->n = rp->s.s_values[12];
	eip->e = rp->s.s_values[13];
a1143 5
	printf("SUPERELL: %g %g\n", tip->n, tip->e);

	rec->s.s_values[12] = tip->n;
	rec->s.s_values[13] = tip->e;

d1158 1
a1158 1
	fastf_t			vec[ELEMENTS_PER_VECT*4 + 2];
d1163 1
a1163 1
	BU_ASSERT_LONG( ep->ext_nbytes, ==, SIZEOF_NETWORK_DOUBLE * (ELEMENTS_PER_VECT*4 + 2));
d1174 1
a1174 1
	ntohd( (unsigned char *)vec, ep->ext_buf, ELEMENTS_PER_VECT*4 + 2);
a1180 2
	eip->n = vec[4*ELEMENTS_PER_VECT];
	eip->e = vec[4*ELEMENTS_PER_VECT + 1];
d1198 1
a1198 1
	fastf_t			vec[ELEMENTS_PER_VECT*4 + 2];
d1206 1
a1206 1
	ep->ext_nbytes = SIZEOF_NETWORK_DOUBLE * (ELEMENTS_PER_VECT*4 + 2);
a1214 3
	vec[4*ELEMENTS_PER_VECT] = eip->n;
	vec[4*ELEMENTS_PER_VECT + 1] = eip->e;

d1216 1
a1216 1
	htond( ep->ext_buf, (unsigned char *)vec, ELEMENTS_PER_VECT*4 + 2 );
a1271 3
	sprintf(buf, "\t<n,e> (%g, %g)\n", tip->n, tip->e);
	bu_vls_strcat(str, buf);

d1320 173
d1503 105
a1607 1
  return;
@


1.1.2.3
log
@updated the superellipsoid's normal and shot routines to mimic the ellipsoid, yet using the polynomial root solver (instead of computing root directly for t value)
@
text
@d9 1
a9 1
 *      Edwin O. Davisson (Mathematics)
d21 1
a21 1
static const char RCSsuperell[] = "@@(#)$Header: /c/CVS/brlcad/librt/Attic/g_superell.c,v 1.1.2.2 2003/02/02 06:12:44 morrison Exp $ (BRL)";
d145 4
a148 4
  vect_t superell_V; /* Vector to center of superellipsoid */
  vect_t superell_Au; /* unit-length A vector */
  vect_t superell_Bu;
  vect_t superell_Cu;
a150 7
  double superell_invmsAu; /* 1.0 / |Au|^2 */
  double superell_invmsBu; /* 1.0 / |Bu|^2 */
  double superell_invmsCu; /* 1.0 / |Cu|^2 */
  vect_t superell_invsq;
  mat_t	superell_SoR; /* matrix for local cordinate system, Scale(Rotate(V))*/
  mat_t superell_invRSSR; /* invR(Scale(Scale(Rot(V)))) */
  mat_t superell_invR; /* transposed rotation matrix */
d172 103
a274 140
  
  register struct superell_specific *superell;
  struct rt_superell_internal	*eip;
  LOCAL fastf_t	magsq_a, magsq_b, magsq_c;
  LOCAL mat_t	R, TEMP;
  LOCAL vect_t	Au, Bu, Cu;	/* A,B,C with unit length */
  LOCAL vect_t	w1, w2, P;	/* used for bounding RPP */
  LOCAL fastf_t	f;
  
  eip = (struct rt_superell_internal *)ip->idb_ptr;
  RT_SUPERELL_CK_MAGIC(eip);
  
  /* Validate that |A| > 0, |B| > 0, |C| > 0 */
  magsq_a = MAGSQ( eip->a );
  magsq_b = MAGSQ( eip->b );
  magsq_c = MAGSQ( eip->c );
  
  if( magsq_a < rtip->rti_tol.dist || magsq_b < rtip->rti_tol.dist || magsq_c < rtip->rti_tol.dist ) {
    bu_log("superell(%s):  zero length A(%g), B(%g), or C(%g) vector\n",
	   stp->st_name, magsq_a, magsq_b, magsq_c );
    return(1);		/* BAD */
  }
  if (eip->n < rtip->rti_tol.dist || eip->e < rtip->rti_tol.dist) {
    bu_log("superell(%s):  zero length <n,e> curvature (%g, %g) causes problems\n", 
	   stp->st_name, eip->n, eip->e);
    /* BAD */
  }
  if (eip->n > 10000.0 || eip->e > 10000.0) {
    bu_log("superell(%s):  very large <n,e> curvature (%g, %g) causes problems\n", 
	   stp->st_name, eip->n, eip->e);
    /* BAD */
  }
  
  /* Create unit length versions of A,B,C */
  f = 1.0/sqrt(magsq_a);
  VSCALE( Au, eip->a, f );
  f = 1.0/sqrt(magsq_b);
  VSCALE( Bu, eip->b, f );
  f = 1.0/sqrt(magsq_c);
  VSCALE( Cu, eip->c, f );
  
  /* Validate that A.B == 0, B.C == 0, A.C == 0 (check dir only) */
  f = VDOT( Au, Bu );
  if( ! NEAR_ZERO(f, rtip->rti_tol.dist) )  {
    bu_log("superell(%s):  A not perpendicular to B, f=%f\n",stp->st_name, f);
    return(1);		/* BAD */
  }
  f = VDOT( Bu, Cu );
  if( ! NEAR_ZERO(f, rtip->rti_tol.dist) )  {
    bu_log("superell(%s):  B not perpendicular to C, f=%f\n",stp->st_name, f);
    return(1);		/* BAD */
  }
  f = VDOT( Au, Cu );
  if( ! NEAR_ZERO(f, rtip->rti_tol.dist) )  {
    bu_log("superell(%s):  A not perpendicular to C, f=%f\n",stp->st_name, f);
    return(1);		/* BAD */
  }
  
  /* Solid is OK, compute constant terms now */

  BU_GETSTRUCT( superell, superell_specific );
  stp->st_specific = (genptr_t)superell;

  superell->superell_n = eip->n;
  superell->superell_e = eip->e;

  VMOVE( superell->superell_V, eip->v );

  VSET( superell->superell_invsq, 1.0/magsq_a, 1.0/magsq_b, 1.0/magsq_c );
  VMOVE( superell->superell_Au, Au );
  VMOVE( superell->superell_Bu, Bu );
  VMOVE( superell->superell_Cu, Cu );

  /* compute the inverse magnitude square for equations during shot */
  superell->superell_invmsAu = 1.0 / magsq_a;
  superell->superell_invmsBu = 1.0 / magsq_b;
  superell->superell_invmsCu = 1.0 / magsq_c;

  /* compute the rotation matrix */
  MAT_IDN(R);
  VMOVE( &R[0], Au );
  VMOVE( &R[4], Bu );
  VMOVE( &R[8], Cu );
  bn_mat_trn( superell->superell_invR, R );

  /* computer invRSSR */
  MAT_IDN(superell->superell_invRSSR);
  MAT_IDN(TEMP);
  TEMP[0] = superell->superell_invsq[0];
  TEMP[5] = superell->superell_invsq[1];
  TEMP[10] = superell->superell_invsq[2];
  bn_mat_mul(TEMP, TEMP, R);
  bn_mat_mul(superell->superell_invRSSR, superell->superell_invR, TEMP);

  /* compute Scale(Rotate(vect)) */
  MAT_IDN(superell->superell_SoR);
  VSCALE( &superell->superell_SoR[0], eip->a, superell->superell_invsq[0]);
  VSCALE( &superell->superell_SoR[4], eip->b, superell->superell_invsq[1]);
  VSCALE( &superell->superell_SoR[8], eip->c, superell->superell_invsq[2]);

  /* Compute bounding sphere */
  VMOVE( stp->st_center, eip->v );
  f = magsq_a;
  if( magsq_b > f )
    f = magsq_b;
  if( magsq_c > f )
    f = magsq_c;
  stp->st_aradius = stp->st_bradius = sqrt(f);
  
  /* Compute bounding RPP */
  VSET( w1, magsq_a, magsq_b, magsq_c );
  
  /* X */
  VSET( P, 1.0, 0, 0 );		/* bounding plane normal */
  MAT3X3VEC( w2, R, P );		/* map plane to local coord syst */
  VELMUL( w2, w2, w2 );		/* square each term */
  f = VDOT( w1, w2 );
  f = sqrt(f);
  stp->st_min[X] = superell->superell_V[X] - f;	/* V.P +/- f */
  stp->st_max[X] = superell->superell_V[X] + f;
  
  /* Y */
  VSET( P, 0, 1.0, 0 );		/* bounding plane normal */
  MAT3X3VEC( w2, R, P );		/* map plane to local coord syst */
  VELMUL( w2, w2, w2 );		/* square each term */
  f = VDOT( w1, w2 );
  f = sqrt(f);
  stp->st_min[Y] = superell->superell_V[Y] - f;	/* V.P +/- f */
  stp->st_max[Y] = superell->superell_V[Y] + f;
  
  /* Z */
  VSET( P, 0, 0, 1.0 );		/* bounding plane normal */
  MAT3X3VEC( w2, R, P );		/* map plane to local coord syst */
  VELMUL( w2, w2, w2 );		/* square each term */
  f = VDOT( w1, w2 );
  f = sqrt(f);
  stp->st_min[Z] = superell->superell_V[Z] - f;	/* V.P +/- f */
  stp->st_max[Z] = superell->superell_V[Z] + f;
  
  return(0);			/* OK */
d303 1
a303 213
  static int counter=10;

#if 1
  register struct superell_specific *superell = (struct superell_specific *)stp->st_specific;
  LOCAL bn_poly_t equation; /* equation of superell to be solved */
  LOCAL vect_t translated;  /* translated shot vector */
  LOCAL vect_t newShotPoint; /* P' */
  LOCAL vect_t newShotDir; /* D' */
  LOCAL vect_t normalizedShotPoint; /* P' with normalized dist from superell */
  LOCAL bn_complex_t complexRoot[4]; /* roots returned from poly solver */
  LOCAL double realRoot[4];  /* real ray distance values */
  register int i,j;
  register struct seg *segp;

  /* translate ray point */
  /*  VSUB2(translated, rp->r_pt, superell->superell_V); */
  (translated)[X] = (rp->r_pt)[X] - (superell->superell_V)[X];
  (translated)[Y] = (rp->r_pt)[Y] - (superell->superell_V)[Y];
  (translated)[Z] = (rp->r_pt)[Z] - (superell->superell_V)[Z];

  /* scale and rotate point to get P' */

  /*  MAT4X3VEC(newShotPoint, superell->superell_SoR, translated); */
  newShotPoint[X] = (superell->superell_SoR[0]*translated[X] + superell->superell_SoR[1]*translated[Y] + superell->superell_SoR[ 2]*translated[Z]) * 1.0/(superell->superell_SoR[15]);
  newShotPoint[Y] = (superell->superell_SoR[4]*translated[X] + superell->superell_SoR[5]*translated[Y] + superell->superell_SoR[ 6]*translated[Z]) * 1.0/(superell->superell_SoR[15]);
  newShotPoint[Z] = (superell->superell_SoR[8]*translated[X] + superell->superell_SoR[9]*translated[Y] + superell->superell_SoR[10]*translated[Z]) * 1.0/(superell->superell_SoR[15]);

  /* translate ray direction vector */
  MAT4X3VEC(newShotDir, superell->superell_SoR, rp->r_dir);
  VUNITIZE(newShotDir);

  /* normalize distance from the superell.  substitues a corrected ray
   * point, which contains a translation along the ray direction to the 
   * closest approach to vertex of the superell.  Translating the ray
   * along the direction of the ray to the closest point near the
   * primitives center vertex.  New ray origin is hence, normalized.
   */
  VSCALE( normalizedShotPoint, newShotDir, 
	  VDOT( newShotPoint, newShotDir ));
  VSUB2( normalizedShotPoint, newShotPoint, normalizedShotPoint );

  /* Now generate the polynomial equation for passing to the root finder */
  
  equation.dgr = 2;

  equation.cf[0] = newShotPoint[X] * newShotPoint[X] * superell->superell_invmsAu + newShotPoint[Y] * newShotPoint[Y] * superell->superell_invmsBu + newShotPoint[Z] * newShotPoint[Z] * superell->superell_invmsCu - 1;
  equation.cf[1] = 2 * newShotDir[X] * newShotPoint[X] * superell->superell_invmsAu + 2 * newShotDir[Y] * newShotPoint[Y] * superell->superell_invmsBu + 2 * newShotDir[Z] * newShotPoint[Z] * superell->superell_invmsCu;
  equation.cf[2] = newShotDir[X] * newShotDir[X] * superell->superell_invmsAu  + newShotDir[Y] * newShotDir[Y] * superell->superell_invmsBu + newShotDir[Z] * newShotDir[Z] * superell->superell_invmsCu;

  if ( (i = rt_poly_roots( &equation, complexRoot)) != 2 ) {
    if (i != 0) {
      bu_log("superell, rt_poly_roots() 2 != %d\n", i);
      bn_pr_roots(stp->st_name, complexRoot, i);
    }
    return (0); /* MISS */
  }

  /* XXX BEGIN CUT */
  /*  Only real roots indicate an intersection in real space.
   *
   *  Look at each root returned; if the imaginary part is zero
   *  or sufficiently close, then use the real part as one value
   *  of 't' for the intersections
   */
  for ( j=0, i=0; j < 2; j++ ){
    if( NEAR_ZERO( complexRoot[j].im, 0.001 ) )
      realRoot[i++] = complexRoot[j].re;
  }
  
  /* reverse above translation by adding distance to all 'k' values. */
  //  for( j = 0; j < i; ++j )
  //    realRoot[j] -= VDOT(newShotPoint, newShotDir);
  
  /* Here, 'i' is number of points found */
  switch( i )  {
  case 0:
    return(0);		/* No hit */
    
  default:
    bu_log("rt_superell_shot: reduced 4 to %d roots\n",i);
    bn_pr_roots( stp->st_name, complexRoot, 4 );
    return(0);		/* No hit */
    
  case 2:
    {
      /* Sort most distant to least distant. */
      FAST fastf_t	u;
      if( (u=realRoot[0]) < realRoot[1] )  {
	/* bubble larger towards [0] */
	realRoot[0] = realRoot[1];
	realRoot[1] = u;
      }
    }
    break;
  case 4:
    {
      register short	n;
      register short	lim;
      
      /*  Inline rt_pt_sort().  Sorts realRoot[] into descending order. */
      for( lim = i-1; lim > 0; lim-- )  {
	for( n = 0; n < lim; n++ )  {
	  FAST fastf_t	u;
	  if( (u=realRoot[n]) < realRoot[n+1] )  {
	    /* bubble larger towards [0] */
	    realRoot[n] = realRoot[n+1];
	    realRoot[n+1] = u;
	  }
	}
      }
    }
    break;
  }

  if (counter > 0) {
    bu_log("realroot: in %d  out %d\n", realRoot[1], realRoot[0]);
    counter--;
  }


  /* Now, t[0] > t[npts-1] */
  /* realRoot[1] is entry point, and realRoot[0] is farthest exit point */
  RT_GET_SEG(segp, ap->a_resource);
  segp->seg_stp = stp;
  segp->seg_in.hit_dist = realRoot[1];
  segp->seg_out.hit_dist = realRoot[0];
  //  segp->seg_in.hit_surfno = segp->seg_out.hit_surfno = 0;
  /* Set aside vector for rt_superell_norm() later */
  //  VJOIN1( segp->seg_in.hit_vpriv, newShotPoint, realRoot[1], newShotDir );
  //  VJOIN1( segp->seg_out.hit_vpriv, newShotPoint, realRoot[0], newShotDir );
  BU_LIST_INSERT( &(seghead->l), &(segp->l) );
  
  if( i == 2 ) {
    return(2);			/* HIT */
  }
  
  /* 4 points */
  /* realRoot[3] is entry point, and realRoot[2] is exit point */
  RT_GET_SEG(segp, ap->a_resource);
  segp->seg_stp = stp;
  segp->seg_in.hit_dist = realRoot[3]*superell->superell_e;
  segp->seg_out.hit_dist = realRoot[2]*superell->superell_e;
  segp->seg_in.hit_surfno = segp->seg_out.hit_surfno = 1;
  VJOIN1( segp->seg_in.hit_vpriv, newShotPoint, realRoot[3], newShotDir );
  VJOIN1( segp->seg_out.hit_vpriv, newShotPoint, realRoot[2], newShotDir );
  BU_LIST_INSERT( &(seghead->l), &(segp->l) );
  return(4);			/* HIT */
  /* XXX END CUT */
  
  /* Is there any possibility of hitting another segment?  Only when there
   * is a concave curvature (<n,e> > <2.0, 2.0>).
   */
  if ( (superell->superell_n > 2.0) || (superell->superell_e > 2.0) ) {
    
  }

  return 1;
#else
  /* XXX ell code */
	register struct superell_specific *superell =
		(struct superell_specific *)stp->st_specific;
	register struct seg *segp;
	LOCAL vect_t	dprime;		/* D' */
	LOCAL vect_t	pprime;		/* P' */
	LOCAL vect_t	xlated;		/* translated vector */
	LOCAL fastf_t	dp, dd;		/* D' dot P', D' dot D' */
	LOCAL fastf_t	k1, k2;		/* distance constants of solution */
	FAST fastf_t	root;		/* root of radical */

	/* out, Mat, vect */
	MAT4X3VEC( dprime, superell->superell_SoR, rp->r_dir );
	VSUB2( xlated, rp->r_pt, superell->superell_V );
	MAT4X3VEC( pprime, superell->superell_SoR, xlated );

	dp = VDOT( dprime, pprime );
	dd = VDOT( dprime, dprime );

	if( (root = dp*dp - dd * (VDOT(pprime,pprime)-1.0)) < 0 )
		return(0);		/* No hit */
	root = sqrt(root);

	RT_GET_SEG(segp, ap->a_resource);
	segp->seg_stp = stp;
	if( (k1=(-dp+root)/dd) <= (k2=(-dp-root)/dd) )  {
		/* k1 is entry, k2 is exit */
		segp->seg_in.hit_dist = k1;
		segp->seg_out.hit_dist = k2;

		/* !!! please room */
		if (counter > 0) {
		  bu_log("realroot: in %d  out %d\n", k1, k2);
		  counter--;
		}

	} else {
		/* k2 is entry, k1 is exit */
		segp->seg_in.hit_dist = k2;
		segp->seg_out.hit_dist = k1;

		/* !!! please room */
		if (counter > 0) {
		  bu_log("realroot: in %d  out %d\n", k2, k1);
		  counter--;
		}

	}


	BU_LIST_INSERT( &(seghead->l), &(segp->l) );
	return(2);			/* HIT */


#endif
a331 12
  register struct superell_specific *superell =
    (struct superell_specific *)stp->st_specific;

  LOCAL vect_t xlated;
  LOCAL fastf_t scale;

  VJOIN1( hitp->hit_point, rp->r_pt, hitp->hit_dist, rp->r_dir );
  VSUB2( xlated, hitp->hit_point, superell->superell_V );
  MAT4X3VEC( hitp->hit_normal, superell->superell_invRSSR, xlated );
  scale = 1.0 / MAGNITUDE( hitp->hit_normal );
  VSCALE( hitp->hit_normal, hitp->hit_normal, scale );

d344 1
a344 2
  bu_log("called rt_superell_curve!\n");
  return;
a358 1
  bu_log("called rt_superell_uv!\n");
a550 1
  bu_log("rt_superell_tess called!\n");
a814 1
  bu_log("rt_superell_tnurb called!\n");
d818 9
@


