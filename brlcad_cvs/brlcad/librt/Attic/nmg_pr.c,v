head	11.31;
access;
symbols
	ansi-20040405-merged:11.27.2.2
	postmerge-20040405-ansi:11.29
	premerge-20040404-ansi:11.28
	postmerge-autoconf:11.28
	autoconf-freeze:11.27.10.2
	premerge-autoconf:11.28
	ansi-20040316-freeze:11.27.2.1
	postmerge-20040315-windows:11.28
	premerge-20040315-windows:11.28
	windows-20040315-freeze:11.27.4.1
	autoconf-20031203:11.27
	autoconf-20031202:11.27
	autoconf-branch:11.27.0.10
	phong-branch:11.27.0.8
	photonmap-branch:11.27.0.6
	rel-6-1-DP:11.27
	windows-branch:11.27.0.4
	rel-6-0-2:11.25
	ansi-branch:11.27.0.2
	rel-6-0-1-branch:11.25.0.2
	hartley-6-0-post:11.26
	hartley-6-0-pre:11.25
	rel-6-0-1:11.25
	rel-6-0:11.25
	rel-5-4:11.22
	offsite-5-3-pre:11.24
	rel-5-3:11.22
	rel-5-2:11.22
	rel-5-1-branch:11.22.0.2
	rel-5-1:11.22
	rel-5-0:11.21
	rel-5-0-beta:11.20
	rel-4-5:11.20
	ctj-4-5-post:11.18
	ctj-4-5-pre:11.18
	rel-4-4:11.1;
locks; strict;
comment	@ * @;


11.31
date	2004.05.21.18.07.33;	author morrison;	state dead;
branches;
next	11.30;

11.30
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.29;

11.29
date	2004.04.05.08.48.57;	author morrison;	state Exp;
branches;
next	11.28;

11.28
date	2004.02.02.17.39.25;	author morrison;	state Exp;
branches;
next	11.27;

11.27
date	2002.08.20.17.08.05;	author jra;	state Exp;
branches
	11.27.2.1
	11.27.4.1
	11.27.10.1;
next	11.26;

11.26
date	2002.08.15.20.55.17;	author hartley;	state Exp;
branches;
next	11.25;

11.25
date	2001.04.05.19.35.36;	author morrison;	state Exp;
branches;
next	11.24;

11.24
date	2000.08.21.02.02.33;	author butler;	state Exp;
branches;
next	11.23;

11.23
date	2000.07.10.23.01.45;	author mike;	state Exp;
branches;
next	11.22;

11.22
date	99.12.30.15.47.41;	author jra;	state Exp;
branches;
next	11.21;

11.21
date	99.06.03.01.43.37;	author mike;	state Exp;
branches;
next	11.20;

11.20
date	97.09.18.20.30.28;	author jra;	state Exp;
branches;
next	11.19;

11.19
date	97.09.09.13.52.30;	author jra;	state Exp;
branches;
next	11.18;

11.18
date	97.06.13.21.42.51;	author mike;	state Exp;
branches;
next	11.17;

11.17
date	96.09.30.16.03.24;	author jra;	state Exp;
branches;
next	11.16;

11.16
date	96.09.27.08.27.30;	author mike;	state Exp;
branches;
next	11.15;

11.15
date	96.08.27.03.04.09;	author mike;	state Exp;
branches;
next	11.14;

11.14
date	96.07.12.12.17.41;	author jra;	state Exp;
branches;
next	11.13;

11.13
date	96.06.11.17.39.41;	author jra;	state Exp;
branches;
next	11.12;

11.12
date	96.04.22.12.21.08;	author jra;	state Exp;
branches;
next	11.11;

11.11
date	96.03.05.21.37.21;	author jra;	state Exp;
branches;
next	11.10;

11.10
date	95.11.27.15.50.04;	author jra;	state Exp;
branches;
next	11.9;

11.9
date	95.09.06.13.12.04;	author jra;	state Exp;
branches;
next	11.8;

11.8
date	95.08.21.14.20.43;	author jra;	state Exp;
branches;
next	11.7;

11.7
date	95.06.27.14.05.57;	author jra;	state Exp;
branches;
next	11.6;

11.6
date	95.06.27.13.57.48;	author jra;	state Exp;
branches;
next	11.5;

11.5
date	95.05.10.12.57.53;	author jra;	state Exp;
branches;
next	11.4;

11.4
date	95.02.15.21.04.57;	author jra;	state Exp;
branches;
next	11.3;

11.3
date	95.02.03.03.06.41;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	95.02.03.02.53.18;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.58.10;	author mike;	state Rel4_4;
branches;
next	1.21;

1.21
date	94.11.18.12.37.14;	author jra;	state Exp;
branches;
next	1.20;

1.20
date	94.11.18.10.49.54;	author jra;	state Exp;
branches;
next	1.19;

1.19
date	94.11.05.00.34.49;	author mike;	state Exp;
branches;
next	1.18;

1.18
date	94.11.04.12.38.32;	author jra;	state Exp;
branches;
next	1.17;

1.17
date	94.09.21.03.50.14;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	94.09.10.04.37.16;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	94.09.03.03.01.46;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	94.09.02.19.07.52;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	94.09.02.17.58.30;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	94.09.02.01.14.52;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	94.09.02.00.32.43;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	94.08.10.18.55.20;	author gdurf;	state Exp;
branches;
next	1.9;

1.9
date	94.08.09.19.38.25;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	94.07.01.23.42.00;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	94.04.25.03.15.50;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	94.04.22.05.52.03;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	94.03.10.06.47.03;	author butler;	state Exp;
branches;
next	1.4;

1.4
date	94.01.25.08.33.20;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	93.12.27.22.45.39;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	93.10.01.20.01.14;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	93.09.30.20.56.39;	author mike;	state Exp;
branches;
next	;

11.27.2.1
date	2002.09.19.18.01.41;	author morrison;	state Exp;
branches;
next	11.27.2.2;

11.27.2.2
date	2004.03.17.21.18.54;	author morrison;	state Exp;
branches;
next	;

11.27.4.1
date	2004.03.11.23.43.43;	author morrison;	state Exp;
branches;
next	;

11.27.10.1
date	2004.02.12.18.37.45;	author erikg;	state Exp;
branches;
next	11.27.10.2;

11.27.10.2
date	2004.03.15.14.07.28;	author erikg;	state Exp;
branches;
next	;


desc
@Routines to print NMG structures
@


11.31
log
@moved to src/
@
text
@/*
 *			N M G _ P R . C
 *
 *  Purpose -
 *	Contains routines to print or describe NMG data structures.
 *	These routines are always available (not conditionally compiled)
 *	so that NMG programmers can always format and print
 *	their data structures.
 *
 *  Authors -
 *	Lee A. Butler
 *	Michael John Muuss
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Pacakge" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1993-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/nmg_pr.c,v 11.30 2004/05/10 15:30:46 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif


#include <stdio.h>
#ifdef USE_STRING_H
# include <string.h>
#else
# include <strings.h>
#endif
#include "machine.h"
#include "vmath.h"
#include "externs.h"
#include "nmg.h"
#include "raytrace.h"
#include "nurb.h"

/*
 *			N M G _ O R I E N T A T I O N
 *
 *  Convert orientation code to string.
 */
char *
nmg_orientation(int orientation)
{
	switch (orientation) {
	case OT_SAME:
		return "OT_SAME";
	case OT_OPPOSITE:
		return "OT_OPPOSITE";
	case OT_NONE:
		return "OT_NONE";
	case OT_UNSPEC:
		return "OT_UNSPEC";
	case OT_BOOLPLACE:
		return "OT_BOOLPLACE";
	}
	return "OT_IS_BOGUS!!";
}

/*
 *			N M G _ P R _ O R I E N T
 *
 *	Print the orientation in a nice, english form
 */
void 
nmg_pr_orient(int orientation, const char *h)
{
	switch (orientation) {
	case OT_SAME : bu_log("%s%8s orientation\n", h, "SAME"); break;
	case OT_OPPOSITE : bu_log("%s%8s orientation\n", h, "OPPOSITE"); break;
	case OT_NONE : bu_log("%s%8s orientation\n", h, "NONE"); break;
	case OT_UNSPEC : bu_log("%s%8s orientation\n", h, "UNSPEC"); break;
	case OT_BOOLPLACE : bu_log("%s%8s orientation\n", h, "BOOLPLACE"); break;
	default : bu_log("%s%8s orientation\n", h, "BOGUS!!!"); break;
	}
}

/*
 *			N M G _ P R _ M
 */
void 
nmg_pr_m(const struct model *m)
{
	const struct nmgregion *r;

	bu_log("MODEL %8x\n", m);
	if (!m || m->magic != NMG_MODEL_MAGIC) {
		bu_log("bad model magic\n");
		return;
	}
	bu_log("%ld maxindex\n", m->maxindex);

	for( BU_LIST_FOR( r, nmgregion, &m->r_hd ) )  {
		nmg_pr_r(r, (char *)NULL);
	}
}

/*
 *			M K P A D
 *
 *  NOTE:  All the nmg_pr_*() routines take an "h" (header string) pointer.
 *  This can be an arbitrary caller-provided string, as long as it is kept
 *  short.  The string will be copied over into nmg_pr_padstr[], and
 *  "h" will be changed to point there, so spaces can be added to the end.
 */
static char nmg_pr_padstr[128];
#define MKPAD(_h) { \
	if (!_h) { _h = nmg_pr_padstr; nmg_pr_padstr[0] = '\0'; } \
	else if( (_h) < nmg_pr_padstr || (_h) >= nmg_pr_padstr+sizeof(nmg_pr_padstr) )  { \
		(void)strncpy(nmg_pr_padstr, (_h), sizeof(nmg_pr_padstr)/2); \
		_h = nmg_pr_padstr; \
	} else { if (strlen(_h) < sizeof(nmg_pr_padstr)-4) (void)strcat(_h, "   "); } }

#define Return	{ h[strlen(h)-3] = '\0'; return; }

/*
 *			N M G _ P R _ R
 */
void 
nmg_pr_r(const struct nmgregion *r, char *h)
{
	struct shell *s;

	bu_log("REGION %8x\n", r);

	MKPAD(h);

	if (!r || r->l.magic != NMG_REGION_MAGIC) {
		bu_log("bad region magic\n");
		Return;
	}

	bu_log("%8x m_p\n", r->m_p);
	bu_log("%8x l.forw\n", r->l.forw);
	bu_log("%8x l.back\n", r->l.back);
	bu_log("%8x ra_p\n", r->ra_p);

	for( BU_LIST_FOR( s, shell, &r->s_hd ) )  {
		nmg_pr_s(s, h);
	}
	Return;
}

/*
 *			N M G _ P R _ S A
 */
void 
nmg_pr_sa(const struct shell_a *sa, char *h)
{
	MKPAD(h);

	bu_log("%sSHELL_A %8x\n", h, sa);
	if (!sa || sa->magic != NMG_SHELL_A_MAGIC) {
		bu_log("bad shell_a magic\n");
		Return;
	}
	
	bu_log("%s%f %f %f Min\n", h, sa->min_pt[X], sa->min_pt[Y],
		sa->min_pt[Z]);
	bu_log("%s%f %f %f Max\n", h, sa->max_pt[X], sa->max_pt[Y],
		sa->max_pt[Z]);

	Return;
}

/*
 *			N M G _ P R _ L G
 */
void 
nmg_pr_lg(const struct loop_g *lg, char *h)
{
	MKPAD(h);
	NMG_CK_LOOP_G(lg);
	
	bu_log("%sLOOP_G %8x\n", h, lg);
	bu_log("%s%f %f %f Min\n", h, lg->min_pt[X], lg->min_pt[Y],
		lg->min_pt[Z]);
	bu_log("%s%f %f %f Max\n", h, lg->max_pt[X], lg->max_pt[Y],
		lg->max_pt[Z]);

	Return;
}

/*
 *			N M G _ P R _ F G
 */
void 
nmg_pr_fg(const long int *magic, char *h)
{
	const struct face_g_snurb *fgs;
	int ncoords;
	int i,j,k,l;

	MKPAD(h);

	switch( *magic )  {
	case NMG_FACE_G_PLANE_MAGIC:
		bu_log("%sFACE_G_PLANE %8x\n", h, magic);

		bu_log("%s%fX + %fY + %fZ = %f\n", h,
			V4ARGS( ((struct face_g_plane *)magic)->N ) );
		break;
	case NMG_FACE_G_SNURB_MAGIC:
		fgs = (struct face_g_snurb *)magic;
		bu_log("%sFACE_G_SNURB %8x\n", h, magic);
		bu_log( "%s  order (%d, %d)\n", h, fgs->order[0], fgs->order[1] );
		bu_log( "%s  U knots: size=%d", h, fgs->u.k_size );
		for( i=0 ; i<fgs->u.k_size ; i++ )
			bu_log( " %f", fgs->u.knots[i] );
		bu_log( "\n%s  V knots: size=%d", h, fgs->v.k_size );
		for( i=0 ; i<fgs->v.k_size ; i++ )
			bu_log( " %f", fgs->v.knots[i] );
		bu_log( "\n%s  Mesh size = (%d X %d), pt_type = %d\n", h, fgs->s_size[0], fgs->s_size[1], fgs->pt_type );
		ncoords = RT_NURB_EXTRACT_COORDS( fgs->pt_type );
		l = 0;
		for( i=0 ; i<fgs->s_size[0] ; i++ )
		{
			bu_log( "%s  ", h );
			for( j=0 ; j<fgs->s_size[1] ; j++ )
			{
				bu_log( " (", h );
				for( k=0 ; k<ncoords ; k++ )
					bu_log( "%f ", fgs->ctl_points[l+k] );
				bu_log( ")" );
				l += ncoords;
			}
			bu_log( "\n" );
		}
		break;
	default:
		rt_bomb("nmg_pr_fg() bad magic\n");
	}

	Return;
}

/*
 *			N M G _ P R _ S
 */
void 
nmg_pr_s(const struct shell *s, char *h)
{
	const struct faceuse	*fu;
	const struct loopuse	*lu;
	const struct edgeuse	*eu;

	MKPAD(h);
	
	bu_log("%sSHELL %8x\n", h, s);
	if (!s || s->l.magic != NMG_SHELL_MAGIC) {
		bu_log("bad shell magic\n");
		Return;
	}

	bu_log("%s%8x r_p\n", h, s->r_p);
	bu_log("%s%8x l.forw\n", h, s->l.forw );
	bu_log("%s%8x l.back\n", h, s->l.back );
	bu_log("%s%8x sa_p\n", h, s->sa_p );
	if (s->sa_p)
		nmg_pr_sa(s->sa_p, h);
	
	for( BU_LIST_FOR( fu, faceuse, &s->fu_hd ) )  {
		nmg_pr_fu(fu, h);
	}

	for( BU_LIST_FOR( lu, loopuse, &s->lu_hd ) )  {
		nmg_pr_lu(lu, h);
	}

	for( BU_LIST_FOR( eu, edgeuse, &s->eu_hd ) )  {
		nmg_pr_eu(eu, h);
	}
	if (s->vu_p)
		nmg_pr_vu(s->vu_p, h);

	Return;
}

/*
 *			N M G _ P R _ S _ B R I E F L Y
 */
void 
nmg_pr_s_briefly(const struct shell *s, char *h)
{
	const struct faceuse	*fu;
	const struct loopuse	*lu;
	const struct edgeuse	*eu;

	MKPAD(h);
	
	bu_log("%sSHELL %8x\n", h, s);
	if (!s || s->l.magic != NMG_SHELL_MAGIC) {
		bu_log("bad shell magic\n");
		Return;
	}

	for( BU_LIST_FOR( fu, faceuse, &s->fu_hd ) )  {
		nmg_pr_fu_briefly(fu, h);
	}

	for( BU_LIST_FOR( lu, loopuse, &s->lu_hd ) )  {
		nmg_pr_lu_briefly(lu, h);
	}

	for( BU_LIST_FOR( eu, edgeuse, &s->eu_hd ) )  {
		nmg_pr_eu_briefly(eu, h);
	}
	if (s->vu_p)
		nmg_pr_vu_briefly(s->vu_p, h);

	Return;
}

/*
 *			N M G _ P R _ F
 */
void 
nmg_pr_f(const struct face *f, char *h)
{
	MKPAD(h);
	NMG_CK_FACE(f);

	bu_log("%sFACE %8x\n", h, f);
	bu_log("%s%8x fu_p\n", h, f->fu_p);
	bu_log("%s%8x g.magic_p\n", h, f->g.magic_p);
	
	bu_log("%s%f %f %f Min\n", h, f->min_pt[X], f->min_pt[Y],
		f->min_pt[Z]);
	bu_log("%s%f %f %f Max\n", h, f->max_pt[X], f->max_pt[Y],
		f->max_pt[Z]);

	bu_log("%s%d Flip\n", h, f->flip );

	if (f->g.plane_p)
		nmg_pr_fg(f->g.magic_p, h);

	Return;
}

/*
 *			N M G _ P R _ F U
 */
void 
nmg_pr_fu(const struct faceuse *fu, char *h)
{
	const struct loopuse *lu;

	MKPAD(h);
	NMG_CK_FACEUSE(fu);

	bu_log("%sFACEUSE %8x\n", h, fu);

	if (!fu || fu->l.magic != NMG_FACEUSE_MAGIC) {
		bu_log("bad faceuse magic\n");
		Return;
	}
	
	bu_log("%s%8x s_p\n", h, fu->s_p);
	bu_log("%s%8x l.forw\n", h, fu->l.forw);
	bu_log("%s%8x l.back\n", h, fu->l.back);
	bu_log("%s%8x fumate_p\n", h, fu->fumate_p);
	nmg_pr_orient(fu->orientation, h);

	bu_log("%s%8x f_p\n", h, fu->f_p);
	if (fu->f_p)
		nmg_pr_f(fu->f_p, h);

	for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )  {
		nmg_pr_lu(lu, h);
	}
	Return;
}

/*
 *			N M G _ P R _ F U _ B R I E F L Y
 */
void 
nmg_pr_fu_briefly(const struct faceuse *fu, char *h)
{
	const struct loopuse *lu;
	struct face *f;

	MKPAD(h);
	NMG_CK_FACEUSE(fu);
	f = fu->f_p;

	if( f->g.magic_p && *f->g.magic_p == NMG_FACE_G_PLANE_MAGIC )
	{
		bu_log("%sFACEUSE %8x (%s) f_p=x%x fg=x%x flip=%d pl= %f %f %f %f\n",
			h, fu, nmg_orientation(fu->orientation), fu->f_p, f->g.magic_p, fu->f_p->flip, V4ARGS( f->g.plane_p->N ));
	}
	else
		bu_log("%sFACEUSE %8x (%s) f_p=x%x\n",
			h, fu, nmg_orientation(fu->orientation), fu->f_p);

	for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )  {
		nmg_pr_lu_briefly(lu, h);
	}
	Return;
}

/*
 *			N M G _ P R _ L
 */
void 
nmg_pr_l(const struct loop *l, char *h)
{
	MKPAD(h);
	NMG_CK_LOOP(l);

	bu_log("%sLOOP %8x\n", h, l);
	if (!l || l->magic != NMG_LOOP_MAGIC) {
		bu_log("bad loop magic\n");
		Return;
	}
	bu_log("%s%8x lu_p\n", h, l->lu_p);
	bu_log("%s%8x lg_p\n", h, l->lg_p);
	if (l->lg_p)
		nmg_pr_lg(l->lg_p, h);

	Return;
}

/*
 *			N M G _ P R _ L U
 */
void 
nmg_pr_lu(const struct loopuse *lu, char *h)
{
	const struct edgeuse	*eu;
	const struct vertexuse *vu;
	long		magic1;
	
	MKPAD(h);
	NMG_CK_LOOPUSE(lu);

	bu_log("%sLOOPUSE %8x\n", h, lu);

	switch (*lu->up.magic_p) {
	case NMG_SHELL_MAGIC	: bu_log("%s%8x up.s_p\n", h, lu->up.s_p);
					break;
	case NMG_FACEUSE_MAGIC	: bu_log("%s%8x up.fu_p\n", h, lu->up.fu_p);
					break;
	default			: bu_log("Bad loopuse parent magic\n");
					Return;
	}

	bu_log("%s%8x l.forw\n", h, lu->l.forw);
	bu_log("%s%8x l.back\n", h, lu->l.back);
	bu_log("%s%8x lumate_p\n", h, lu->lumate_p);
	nmg_pr_orient(lu->orientation, h);
	bu_log("%s%8x l_p\n", h, lu->l_p);
	if (lu->l_p)
		nmg_pr_l(lu->l_p, h);


	bu_log("%s%8x down_hd.magic\n", h, lu->down_hd.magic);
	bu_log("%s%8x down_hd.forw\n", h, lu->down_hd.forw);
	bu_log("%s%8x down_hd.back\n", h, lu->down_hd.back);

	magic1 = BU_LIST_FIRST_MAGIC( &lu->down_hd );
	if (magic1 == NMG_VERTEXUSE_MAGIC) {
		vu = BU_LIST_PNEXT( vertexuse, &lu->down_hd );
		bu_log("%s%8x down_hd->forw (vu)\n", h, vu);
		nmg_pr_vu(vu, h);
	}
	else if (magic1 == NMG_EDGEUSE_MAGIC) {
		for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
			nmg_pr_eu(eu, h);
		}
	}
	else
		bu_log("bad loopuse child magic\n");

	Return;
}

/*
 *			N M G _ P R _ L U _ B R I E F L Y
 */
void 
nmg_pr_lu_briefly(const struct loopuse *lu, char *h)
{
	const struct edgeuse	*eu;
	const struct vertexuse *vu;
	long		magic1;

	MKPAD(h);
	NMG_CK_LOOPUSE(lu);

	bu_log("%sLOOPUSE %8x, lumate_p=x%x (%s) \n",
		h, lu, lu->lumate_p, nmg_orientation(lu->orientation) );

	magic1 = BU_LIST_FIRST_MAGIC( &lu->down_hd );
	if (magic1 == NMG_VERTEXUSE_MAGIC) {
		vu = BU_LIST_PNEXT( vertexuse, &lu->down_hd );
		bu_log("%s%8x down_hd->forw (vu)\n", h, vu);
		nmg_pr_vu_briefly(vu, h);
	}
	else if (magic1 == NMG_EDGEUSE_MAGIC) {
		for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
			nmg_pr_eu_briefly(eu, h);
		}
	}
	else
		bu_log("bad loopuse child magic\n");

	Return;
}

/*
 *			N M G _ P R _ E G
 *
 * Expects a pointer to the magic number of an edge geometry structure
 * either edge_g_lseg or edge_g_cnurb structures.
 */
void
nmg_pr_eg(const long int *eg_magic_p, char *h)
{
	MKPAD(h);
	NMG_CK_EDGE_G_EITHER(eg_magic_p);

	switch( *eg_magic_p )
	{
		case NMG_EDGE_G_LSEG_MAGIC:
		{
			struct edge_g_lseg *eg_l=(struct edge_g_lseg *)eg_magic_p;

			bu_log("%sEDGE_G_LSEG %8x pt:(%f %f %f)\n",
				h, eg_l, V3ARGS(eg_l->e_pt));
			bu_log("%s       eu uses=%d  dir:(%f %f %f)\n",
				h, bu_list_len( &eg_l->eu_hd2 ), V3ARGS(eg_l->e_dir));
			break;
		}
		case NMG_EDGE_G_CNURB_MAGIC:
		{
			struct edge_g_cnurb *eg_c=(struct edge_g_cnurb *)eg_magic_p;
			int i,j,l;
			int ncoords;

			bu_log( "%sEDGE_G_CNURB %8x\n" , h , eg_c );
			bu_log( "%s  order=%d, %d ctl pts, pt_type=%d\n",
				h, eg_c->order, eg_c->c_size, eg_c->pt_type );
			bu_log( "%s  knot vector (len=%d):", h, eg_c->k.k_size );
			for( i=0 ; i<eg_c->k.k_size ; i++ )
				bu_log( " %f", eg_c->k.knots[i] );
			bu_log( "\n" );
			ncoords = RT_NURB_EXTRACT_COORDS( eg_c->pt_type );
			l = 0;
			bu_log( "%s  control points: ", h );
			for( i=0 ; i<eg_c->c_size ; i++ )
			{
				bu_log( "(" );
				for( j=0 ; j<ncoords ; j++ )
					bu_log( "%f ", eg_c->ctl_points[l+j] );
				bu_log( ")" );
				l += ncoords;
			}
			bu_log( "\n" );
			break;
		}
	}

	Return;
}

/*
 *			N M G _ P R _ E
 */
void 
nmg_pr_e(const struct edge *e, char *h)
{
	MKPAD(h);
	NMG_CK_EDGE(e);

	bu_log("%sEDGE %8x\n", h, e);
	if (!e || e->magic != NMG_EDGE_MAGIC) {
		bu_log("bad edge magic\n");
		Return;
	}
	bu_log("%s%8x eu_p\n", h, e->eu_p);

	Return;
}

/*
 *			N M G _ P R _ E U
 */
void 
nmg_pr_eu(const struct edgeuse *eu, char *h)
{
	MKPAD(h);
	NMG_CK_EDGEUSE(eu);

	bu_log("%sEDGEUSE %8x\n", h, eu);

	switch (*eu->up.magic_p) {
	case NMG_SHELL_MAGIC	: bu_log("%s%8x up.s_p\n", h, eu->up.s_p);
				break;
	case NMG_LOOPUSE_MAGIC	: bu_log("%s%8x up.lu_p\n", h, eu->up.lu_p);
				break;
	default			: bu_log("bad edgeuse parent magic\n");
				Return;
	}
	bu_log("%s%8x l.forw\n", h, eu->l.forw);
	bu_log("%s%8x l.back\n", h, eu->l.back);
	bu_log("%s%8x eumate_p\n", h, eu->eumate_p);
	bu_log("%s%8x radial_p\n", h, eu->radial_p);
	nmg_pr_orient(eu->orientation, h);
	bu_log("%s%8x e_p\n", h, eu->e_p);
	bu_log("%s%8x vu_p\n", h, eu->vu_p);
	bu_log("%s%8x g.magic_p\n", h, eu->g.magic_p);
	nmg_pr_e(eu->e_p, h);
	nmg_pr_vu(eu->vu_p, h);

	if (eu->g.magic_p)
		nmg_pr_eg(eu->g.magic_p, h);

	Return;
}

/*
 *			N M G _ P R _ E U _ B R I E F L Y
 */
void 
nmg_pr_eu_briefly(const struct edgeuse *eu, char *h)
{
	MKPAD(h);
	NMG_CK_EDGEUSE(eu);

	bu_log("%sEDGEUSE %8x, g=%8x, e_p=%8x\n", h, eu, eu->g.magic_p, eu->e_p);
	nmg_pr_vu_briefly(eu->vu_p, h);

	Return;
}

/*
 *			N M G _ P R _ E U _ E N D P O I N T S
 */
void 
nmg_pr_eu_endpoints(const struct edgeuse *eu, char *h)
{
	struct vertex_g	*vg1, *vg2;

	MKPAD(h);
	NMG_CK_EDGEUSE(eu);

	vg1 = eu->vu_p->v_p->vg_p;
	vg2 = eu->eumate_p->vu_p->v_p->vg_p;
	NMG_CK_VERTEX_G(vg1);
	NMG_CK_VERTEX_G(vg2);

	bu_log("%sEDGEUSE %8x\n%s  (%g, %g, %g) -- (%g, %g, %g)\n", h, eu, h,
		V3ARGS(vg1->coord),
		V3ARGS(vg2->coord) );

	Return;
}

/*
 *			N M G _ P R _ V G
 */
void 
nmg_pr_vg(const struct vertex_g *vg, char *h)
{
	MKPAD(h);
	NMG_CK_VERTEX_G(vg);

	if (!vg || vg->magic != NMG_VERTEX_G_MAGIC) {
		bu_log("%sVERTEX_G %8x\n", h, vg);
		bu_log("bad vertex_g magic\n");
		Return;
	}
	bu_log("%sVERTEX_G %8x %f %f %f = XYZ coord\n",
		h, vg, V3ARGS(vg->coord) );
	Return;
}

/*
 *			N M G _ P R _ V
 */
void 
nmg_pr_v(const struct vertex *v, char *h)
{
	MKPAD(h);
	NMG_CK_VERTEX(v);

	bu_log("%sVERTEX %8x\n", h, v);
	if (!v || v->magic != NMG_VERTEX_MAGIC) {
		bu_log("bad vertex magic\n");
		Return;
	}
	/* vu_hd ? */
	bu_log("%s   vu_hd %8x\n", h, &v->vu_hd);
	bu_log("%s%8x vu_hd.forw\n", h, v->vu_hd.forw);
	bu_log("%s%8x vu_hd.back\n", h, v->vu_hd.back);


	bu_log("%s%8x vg_p\n", h, v->vg_p);
	if (v->vg_p)
		nmg_pr_vg(v->vg_p, h);

	Return;
}

/*
 *			N M G _ P R _ V U
 */
void 
nmg_pr_vu(const struct vertexuse *vu, char *h)
{
	MKPAD(h);
	NMG_CK_VERTEXUSE(vu);

	bu_log("%sVERTEXUSE %8x\n", h, vu);
	if (!vu || vu->l.magic != NMG_VERTEXUSE_MAGIC) {
		bu_log("bad vertexuse magic\n");
		Return;
	}

	switch (*vu->up.magic_p) {
	case NMG_SHELL_MAGIC	: bu_log("%s%8x up.s_p\n", h, vu->up.s_p); break;
	case NMG_LOOPUSE_MAGIC	: bu_log("%s%8x up.lu_p\n", h, vu->up.lu_p); break;
	case NMG_EDGEUSE_MAGIC	: bu_log("%s%8x up.eu_p\n", h, vu->up.eu_p); break;
	default			: bu_log("bad vertexuse parent magic\n"); 
				Return;
	}
	bu_log("%s%8x l.forw\n", h, vu->l.forw);
	bu_log("%s%8x l.back\n", h, vu->l.back);
	if( vu->a.magic_p )  switch( *vu->a.magic_p )  {
	case NMG_VERTEXUSE_A_PLANE_MAGIC:
		bu_log("%s%8x a.plane_p\n", h, vu->a.plane_p);
		bu_log("%s normal: %f %f %f\n", h, V3ARGS( vu->a.plane_p->N ) );
		break;
	case NMG_VERTEXUSE_A_CNURB_MAGIC:
		bu_log("%s%8x a.cnurb_p\n", h, vu->a.cnurb_p);
		break;
	}
	bu_log("%s%8x v_p\n", h, vu->v_p);
	nmg_pr_v(vu->v_p, h);
	if( vu->a.magic_p )  nmg_pr_vua( vu->a.magic_p, h );

	Return;
}

/*
 *			N M G _ P R _ V U _ B R I E F L Y
 */
void 
nmg_pr_vu_briefly(const struct vertexuse *vu, char *h)
{
	const struct vertex_g	*vg;

	MKPAD(h);
	NMG_CK_VERTEXUSE(vu);
	NMG_CK_VERTEX(vu->v_p);

	if( (vg = vu->v_p->vg_p) )  {
		NMG_CK_VERTEX_G(vg);
		bu_log("%sVERTEXUSE %8x, v=x%x, %f %f %f\n", h, vu, vu->v_p,
			V3ARGS(vg->coord) );
	} else {
		bu_log("%sVERTEXUSE %8x, v=x%x\n", h, vu, vu->v_p);
	}

	Return;
}

/*
 *			N M G _ P R _ V U A
 */
void
nmg_pr_vua(const long int *magic_p, char *h)
{
	MKPAD(h);

	bu_log("%sVERTEXUSE_A %8x\n", h, magic_p);
	if (!magic_p)  {
		bu_log("bad vertexuse_a magic\n");
		Return;
	}

	switch( *magic_p )  {
	case NMG_VERTEXUSE_A_PLANE_MAGIC:
		bu_log("%s N=(%g, %g, %g, %g)\n", h,
			V3ARGS( ((struct vertexuse_a_plane *)magic_p)->N ) );
		break;
	case NMG_VERTEXUSE_A_CNURB_MAGIC:
		bu_log("%s param=(%g, %g, %g)\n", h,
			V3ARGS( ((struct vertexuse_a_cnurb *)magic_p)->param ) );
		break;
	}

	Return;
}


/*
 *			N M G _ E U P R I N T
 */
void 
nmg_euprint(const char *str, const struct edgeuse *eu)
{
	const fastf_t	*eup;
	const fastf_t	*matep;
	
	NMG_CK_EDGEUSE(eu);
	NMG_CK_VERTEXUSE(eu->vu_p);
	NMG_CK_VERTEX(eu->vu_p->v_p);
	NMG_CK_VERTEX_G(eu->vu_p->v_p->vg_p);

	NMG_CK_EDGEUSE(eu->eumate_p);
	NMG_CK_VERTEXUSE(eu->eumate_p->vu_p);
	NMG_CK_VERTEX(eu->eumate_p->vu_p->v_p);
	NMG_CK_VERTEX_G(eu->eumate_p->vu_p->v_p->vg_p);

	eup = eu->vu_p->v_p->vg_p->coord;
	matep = eu->eumate_p->vu_p->v_p->vg_p->coord;

	bu_log("%s (%g, %g, %g -> %g, %g, %g)\n", str, eup[0], eup[1], eup[2],
		matep[0], matep[1], matep[2]);
}
/*
 *			N M G _ P R _ P T B L
 *
 *  Print an bu_ptbl array for inspection.
 */
void
nmg_pr_ptbl(const char *title, const struct bu_ptbl *tbl, int verbose)
{
	register long	**lp;

	BU_CK_PTBL(tbl);
	bu_log("%s: bu_ptbl array with %d entries\n",
		title, tbl->end );

	if( !verbose )  return;

	for( lp = (long **)BU_PTBL_BASEADDR(tbl);
	     lp <= (long **)BU_PTBL_LASTADDR(tbl); lp++
	)  {
		if( *lp == 0 )  {
			bu_log("  %.8x NULL entry\n", *lp);
			continue;
		}
		switch(**lp)  {
		default:
			bu_log("  %.8x %s\n", *lp, bu_identify_magic(**lp) );
			break;
		case NMG_EDGEUSE_MAGIC:
			bu_log("  %.8x edgeuse vu=%x, far vu=%x\n",
				*lp,
				((struct edgeuse *)*lp)->vu_p,
				BU_LIST_PNEXT_CIRC(edgeuse, *lp)->vu_p );
			break;
		case NMG_VERTEXUSE_MAGIC:
			bu_log("  %.8x vertexuse v=%x\n",
				*lp,
				((struct vertexuse *)*lp)->v_p );
			break;
		}
	}
}

/*
 *			N M G _ P R _ P T B L _ V E R T _ L I S T
 *
 *  Print a ptbl array as a vertex list.
 */
void
nmg_pr_ptbl_vert_list(const char *str, const struct bu_ptbl *tbl, const fastf_t *mag)
{
	int			i;
	const struct vertexuse	**vup;
	const struct vertexuse	*vu;
	const struct vertex	*v;
	const struct vertex_g	*vg;

    	bu_log("nmg_pr_ptbl_vert_list(%s):\n", str);

	vup = (const struct vertexuse **)tbl->buffer;
	for (i=0 ; i < tbl->end ; ++i) {
		vu = vup[i];
		if( vu->l.magic != NMG_VERTEXUSE_MAGIC )
		{
			bu_log( "\tWARNING: vertexuse #%d has bad MAGIC (%x)\n" , i, vu->l.magic );
			continue;
		}
		NMG_CK_VERTEXUSE(vu);
		v = vu->v_p;
		NMG_CK_VERTEX(v);
		vg = v->vg_p;
		NMG_CK_VERTEX_G(vg);
		bu_log("%d\t%g, %g, %g\t", i, V3ARGS(vg->coord) );
		if (*vu->up.magic_p == NMG_EDGEUSE_MAGIC) {
			bu_log("EDGEUSE");
		} else if (*vu->up.magic_p == NMG_LOOPUSE_MAGIC) {
			bu_log("LOOPUSE");
			if ((struct vertexuse *)vu->up.lu_p->down_hd.forw != vu) {
				bu_log("ERROR vertexuse's parent disowns us!\n");
				if (((struct vertexuse *)(vu->up.lu_p->lumate_p->down_hd.forw))->l.magic == NMG_VERTEXUSE_MAGIC)
					rt_bomb("lumate has vertexuse\n");
				rt_bomb("lumate has garbage\n");
			}
		} else {
			bu_log("vu up UNKNOWN");
		}
		bu_log("\tv=x%x, vu=x%x, dist=%g\n", v , vu, mag[i] );
	}
}

/* 
 *			N M G _ P R _ O N E _ E U _ V E C S
 *
 *  Common formatting code for edgeuses and edgeuse mates.
 *  Does not mind wire edges.
 */
void
nmg_pr_one_eu_vecs(const struct edgeuse *eu, const fastf_t *xvec, const fastf_t *yvec, const fastf_t *zvec, const struct bn_tol *tol)
{
	const struct loopuse	*lu;
	const struct faceuse	*fu;
	const struct face	*f;
	const struct shell	*s;
	char			*lu_orient;
	char			*fu_orient;

	NMG_CK_EDGEUSE(eu);
	lu = (struct loopuse *)NULL;
	lu_orient = "W";
	fu = (struct faceuse *)NULL;
	fu_orient = "W";
	f = (struct face *)NULL;
	if( *eu->up.magic_p == NMG_LOOPUSE_MAGIC )  {
		lu = eu->up.lu_p;
		NMG_CK_LOOPUSE(lu);
		/* +3 is to skip the "OT_" prefix */
		lu_orient = nmg_orientation(lu->orientation)+3;
		if( *lu->up.magic_p == NMG_FACEUSE_MAGIC )  {
			fu = lu->up.fu_p;
			NMG_CK_FACEUSE(fu);
			fu_orient = nmg_orientation(fu->orientation)+3;
			f = fu->f_p;
			s = fu->s_p;
		} else {
			s = lu->up.s_p;
		}
	} else {
		s = eu->up.s_p;
	}
	NMG_CK_SHELL(s);
	if( f && *f->g.magic_p == NMG_FACE_G_SNURB_MAGIC )
	{
		bu_log(" %8.8x, lu=%8.8x=%1.1s, f=%8.8x, fu=%8.8x=%1.1s, s=%8.8x SNURB\n",
			eu,
			lu, lu_orient,
			f,
			fu, fu_orient,
			s );
	}
	else
	{
		bu_log(" %8.8x, lu=%8.8x=%1.1s, f=%8.8x, fu=%8.8x=%1.1s, s=%8.8x %g deg\n",
			eu,
			lu, lu_orient,
			f,
			fu, fu_orient,
			s,
			nmg_measure_fu_angle(eu, xvec, yvec, zvec) * bn_radtodeg );
	}
}

/*
 *			N M G _ P R _ F U _ A R O U N D _ E U _ V E C S
 */
void
nmg_pr_fu_around_eu_vecs(const struct edgeuse *eu, const fastf_t *xvec, const fastf_t *yvec, const fastf_t *zvec, const struct bn_tol *tol)
{
	const struct edgeuse	*eu1;

	NMG_CK_EDGEUSE(eu);
	BN_CK_TOL(tol);
	bu_log("nmg_pr_fu_around_eu_vecs(eu=x%x) e=x%x\n", eu, eu->e_p);

	/* To go correct way around, start with arg's mate,
	 * so that arg, then radial, will follow.
	 */
	eu = eu->eumate_p;

	eu1 = eu;
	do {
		/* First, the edgeuse mate */
		nmg_pr_one_eu_vecs( eu1, xvec, yvec, zvec, tol );

		/* Second, the edgeuse itself (mate's mate) */
		eu1 = eu1->eumate_p;
		nmg_pr_one_eu_vecs( eu1, xvec, yvec, zvec, tol );

		/* Now back around to the radial edgeuse */
		eu1 = eu1->radial_p;
	} while( eu1 != eu );
}

/*
 *			N M G _ P R _ F U _ A R O U N D _ E U
 *
 *  A debugging routine to print all the faceuses around a given edge,
 *  starting with the given edgeuse.
 *  The normal of the  first face is considered to be "0 degrees",
 *  and the rest are measured from there.
 */
void
nmg_pr_fu_around_eu(const struct edgeuse *eu, const struct bn_tol *tol)
{
	vect_t			xvec, yvec, zvec;

	NMG_CK_EDGEUSE(eu);
	BN_CK_TOL(tol);
	bu_log("nmg_pr_fu_around_eu(x%x)\n", eu);

	if( eu->vu_p->v_p == eu->eumate_p->vu_p->v_p || *eu->g.magic_p == NMG_EDGE_G_CNURB_MAGIC )
	{
		VSET( xvec , 1 , 0 , 0 );
		VSET( yvec , 0 , 1 , 0 );
		VSET( zvec , 0 , 0 , 1 );
	}
	else
	{
		/* Erect coordinate system around eu */
		nmg_eu_2vecs_perp( xvec, yvec, zvec, eu, tol );
	}

	nmg_pr_fu_around_eu_vecs( eu, xvec, yvec, zvec, tol );
}

/*
 *			N M G _ P L _ L U _ A R O U N D _ E U
 *
 *  Plot all the loopuses around an edgeuse.
 *  Don't bother drawing the loopuse mates.
 */
void
nmg_pl_lu_around_eu(const struct edgeuse *eu)
{
	FILE			*fp;
	const struct edgeuse	*eu1;
	const struct loopuse	*lu1;
	long			*b;
	static int		num;
	char			buf[128];

	NMG_CK_EDGEUSE(eu);

	sprintf(buf, "eu_vicinity%d.pl", num++);
	if( (fp = fopen(buf, "w")) == NULL )  {
		perror(buf);
		return;
	}

	b = (long *)bu_calloc( nmg_find_model((long *)eu)->maxindex, sizeof(long),
		"nmg_pl_lu_around_eu flag[]" );

	/* To go correct way around, start with arg's mate,
	 * so that arg, then radial, will follow.
	 */
	eu = eu->eumate_p;

	eu1 = eu;
	do {
		/* First, the edgeuse mate */
		/* Second, the edgeuse itself (mate's mate) */
		eu1 = eu1->eumate_p;

		if (*eu1->up.magic_p == NMG_LOOPUSE_MAGIC )  {
			lu1 = eu1->up.lu_p;
			nmg_pl_lu(fp, lu1, b, 80, 100, 170);
		}

		/* Now back around to the radial edgeuse */
		eu1 = eu1->radial_p;
	} while( eu1 != eu );

	bu_free( (char *)b, "nmg_pl_lu_around_eu flag[]" );
	fclose(fp);
	bu_log("Wrote %s\n", buf);
}

/*
 *			N M G _ P R _ F U S _ I N _ F G
 *
 *  For either kind of face geometry, print the list of all faces & faceuses
 *  that share this geometry.
 */
void
nmg_pr_fus_in_fg(const long int *fg_magic)
{
	struct face	*f;

	NMG_CK_FACE_G_EITHER(fg_magic);
	bu_log("nmg_pr_fus_in_fg(x%x):\n", fg_magic);
	for( BU_LIST_FOR( f, face, &(((struct face_g_plane *)fg_magic)->f_hd) ) )  {
		NMG_CK_FACE(f);
		NMG_CK_FACEUSE(f->fu_p);
		bu_log(" f=x%x, fu=x%x, fumate=x%x\n",
			f, f->fu_p, f->fu_p->fumate_p );
	}
}
@


11.30
log
@change conf.h to a wrapped config.h
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/librt/nmg_pr.c,v 11.29 2004/04/05 08:48:57 morrison Exp $ (ARL)";
@


11.29
log
@merge of ansi-6-0-branch into HEAD
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d31 5
a35 1
#include "conf.h"
@


11.28
log
@update copyright to include span through 2003
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_pr.c,v 11.27 2002/08/20 17:08:05 jra Exp $ (ARL)";
d51 1
a51 2
nmg_orientation(orientation)
int	orientation;
d74 1
a74 3
nmg_pr_orient(orientation, h)
int		orientation;
const char	*h;
d90 1
a90 2
nmg_pr_m(m)
const struct model *m;
d128 1
a128 3
nmg_pr_r(r, h)
const struct nmgregion *r;
char *h;
d156 1
a156 3
nmg_pr_sa(sa, h)
const struct shell_a *sa;
char *h;
d178 1
a178 3
nmg_pr_lg(lg, h)
const struct loop_g *lg;
char *h;
d196 1
a196 3
nmg_pr_fg(magic, h)
const long *magic;
char *h;
d249 1
a249 3
nmg_pr_s(s, h)
const struct shell *s;
char *h;
d291 1
a291 3
nmg_pr_s_briefly(s, h)
const struct shell *s;
char *h;
d326 1
a326 3
nmg_pr_f(f, h)
const struct face *f;
char *h;
d352 1
a352 3
nmg_pr_fu(fu, h)
const struct faceuse *fu;
char *h;
d386 1
a386 3
nmg_pr_fu_briefly(fu, h)
const struct faceuse *fu;
char *h;
d414 1
a414 3
nmg_pr_l(l, h)
const struct loop *l;
char *h;
d436 1
a436 3
nmg_pr_lu(lu, h)
const struct loopuse *lu;
char *h;
d490 1
a490 3
nmg_pr_lu_briefly(lu, h)
const struct loopuse *lu;
char *h;
d526 1
a526 3
nmg_pr_eg(eg_magic_p, h)
const long *eg_magic_p;
char *h;
d579 1
a579 3
nmg_pr_e(e, h)
const struct edge *e;
char *h;
d598 1
a598 3
nmg_pr_eu(eu, h)
const struct edgeuse *eu;
char *h;
d634 1
a634 3
nmg_pr_eu_briefly(eu, h)
const struct edgeuse *eu;
char *h;
d649 1
a649 3
nmg_pr_eu_endpoints(eu, h)
const struct edgeuse *eu;
char *h;
d672 1
a672 3
nmg_pr_vg(vg, h)
const struct vertex_g *vg;
char *h;
d691 1
a691 3
nmg_pr_v(v, h)
const struct vertex *v;
char *h;
d718 1
a718 3
nmg_pr_vu(vu, h)
const struct vertexuse *vu;
char *h;
d758 1
a758 3
nmg_pr_vu_briefly(vu, h)
const struct vertexuse *vu;
char *h;
d781 1
a781 3
nmg_pr_vua(magic_p, h)
const long	*magic_p;
char *h;
d810 1
a810 3
nmg_euprint(str, eu)
const char		*str;
const struct edgeuse	*eu;
d837 1
a837 4
nmg_pr_ptbl( title, tbl, verbose )
const char		*title;
const struct bu_ptbl	*tbl;
int			verbose;
d879 1
a879 4
nmg_pr_ptbl_vert_list( str, tbl, mag )
const char		*str;
const struct bu_ptbl	*tbl;
const fastf_t		*mag;
d927 1
a927 6
nmg_pr_one_eu_vecs( eu, xvec, yvec, zvec, tol )
const struct edgeuse	*eu;
const vect_t		xvec;
const vect_t		yvec;
const vect_t		zvec;
const struct bn_tol	*tol;
d985 1
a985 6
nmg_pr_fu_around_eu_vecs( eu, xvec, yvec, zvec, tol )
const struct edgeuse	*eu;
const vect_t		xvec;
const vect_t		yvec;
const vect_t		zvec;
const struct bn_tol	*tol;
d1021 1
a1021 3
nmg_pr_fu_around_eu( eu, tol )
const struct edgeuse *eu;
const struct bn_tol	*tol;
d1051 1
a1051 2
nmg_pl_lu_around_eu(eu)
const struct edgeuse	*eu;
d1103 1
a1103 2
nmg_pr_fus_in_fg(fg_magic)
const long	*fg_magic;
@


11.27
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d24 1
a24 1
 *	This software is Copyright (C) 1993 by the United States Army
d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_pr.c,v 11.25 2001/04/05 19:35:36 morrison Exp $ (ARL)";
@


11.27.4.1
log
@sync to HEAD...
@
text
@d24 1
a24 1
 *	This software is Copyright (C) 1993-2004 by the United States Army
d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/nmg_pr.c,v 11.28 2004/02/02 17:39:25 morrison Exp $ (ARL)";
@


11.27.10.1
log
@merge from HEAD
@
text
@d24 1
a24 1
 *	This software is Copyright (C) 1993-2004 by the United States Army
d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_pr.c,v 11.28 2004/02/02 17:39:25 morrison Exp $ (ARL)";
@


11.27.10.2
log
@merge from head
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_pr.c,v 11.27.10.1 2004/02/12 18:37:45 erikg Exp $ (ARL)";
@


11.27.2.1
log
@Initial ANSIfication
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_pr.c,v 11.27 2002/08/20 17:08:05 jra Exp $ (ARL)";
d51 2
a52 1
nmg_orientation(int orientation)
d75 3
a77 1
nmg_pr_orient(int orientation, const char *h)
d93 2
a94 1
nmg_pr_m(const struct model *m)
d132 3
a134 1
nmg_pr_r(const struct nmgregion *r, char *h)
d162 3
a164 1
nmg_pr_sa(const struct shell_a *sa, char *h)
d186 3
a188 1
nmg_pr_lg(const struct loop_g *lg, char *h)
d206 3
a208 1
nmg_pr_fg(const long int *magic, char *h)
d261 3
a263 1
nmg_pr_s(const struct shell *s, char *h)
d305 3
a307 1
nmg_pr_s_briefly(const struct shell *s, char *h)
d342 3
a344 1
nmg_pr_f(const struct face *f, char *h)
d370 3
a372 1
nmg_pr_fu(const struct faceuse *fu, char *h)
d406 3
a408 1
nmg_pr_fu_briefly(const struct faceuse *fu, char *h)
d436 3
a438 1
nmg_pr_l(const struct loop *l, char *h)
d460 3
a462 1
nmg_pr_lu(const struct loopuse *lu, char *h)
d516 3
a518 1
nmg_pr_lu_briefly(const struct loopuse *lu, char *h)
d554 3
a556 1
nmg_pr_eg(const long int *eg_magic_p, char *h)
d609 3
a611 1
nmg_pr_e(const struct edge *e, char *h)
d630 3
a632 1
nmg_pr_eu(const struct edgeuse *eu, char *h)
d668 3
a670 1
nmg_pr_eu_briefly(const struct edgeuse *eu, char *h)
d685 3
a687 1
nmg_pr_eu_endpoints(const struct edgeuse *eu, char *h)
d710 3
a712 1
nmg_pr_vg(const struct vertex_g *vg, char *h)
d731 3
a733 1
nmg_pr_v(const struct vertex *v, char *h)
d760 3
a762 1
nmg_pr_vu(const struct vertexuse *vu, char *h)
d802 3
a804 1
nmg_pr_vu_briefly(const struct vertexuse *vu, char *h)
d827 3
a829 1
nmg_pr_vua(const long int *magic_p, char *h)
d858 3
a860 1
nmg_euprint(const char *str, const struct edgeuse *eu)
d887 4
a890 1
nmg_pr_ptbl(const char *title, const struct bu_ptbl *tbl, int verbose)
d932 4
a935 1
nmg_pr_ptbl_vert_list(const char *str, const struct bu_ptbl *tbl, const fastf_t *mag)
d983 6
a988 1
nmg_pr_one_eu_vecs(const struct edgeuse *eu, const fastf_t *xvec, const fastf_t *yvec, const fastf_t *zvec, const struct bn_tol *tol)
d1046 6
a1051 1
nmg_pr_fu_around_eu_vecs(const struct edgeuse *eu, const fastf_t *xvec, const fastf_t *yvec, const fastf_t *zvec, const struct bn_tol *tol)
d1087 3
a1089 1
nmg_pr_fu_around_eu(const struct edgeuse *eu, const struct bn_tol *tol)
d1119 2
a1120 1
nmg_pl_lu_around_eu(const struct edgeuse *eu)
d1172 2
a1173 1
nmg_pr_fus_in_fg(const long int *fg_magic)
@


11.27.2.2
log
@sync branch with HEAD
@
text
@d24 1
a24 1
 *	This software is Copyright (C) 1993-2004 by the United States Army
d28 1
a28 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
@


11.26
log
@Converted from K&R to ANSI C - RFH
@
text
@d51 2
a52 1
nmg_orientation(int orientation)
d75 3
a77 1
nmg_pr_orient(int orientation, const char *h)
d93 2
a94 1
nmg_pr_m(const struct model *m)
d132 3
a134 1
nmg_pr_r(const struct nmgregion *r, char *h)
d162 3
a164 1
nmg_pr_sa(const struct shell_a *sa, char *h)
d186 3
a188 1
nmg_pr_lg(const struct loop_g *lg, char *h)
d206 3
a208 1
nmg_pr_fg(const long int *magic, char *h)
d261 3
a263 1
nmg_pr_s(const struct shell *s, char *h)
d305 3
a307 1
nmg_pr_s_briefly(const struct shell *s, char *h)
d342 3
a344 1
nmg_pr_f(const struct face *f, char *h)
d370 3
a372 1
nmg_pr_fu(const struct faceuse *fu, char *h)
d406 3
a408 1
nmg_pr_fu_briefly(const struct faceuse *fu, char *h)
d436 3
a438 1
nmg_pr_l(const struct loop *l, char *h)
d460 3
a462 1
nmg_pr_lu(const struct loopuse *lu, char *h)
d516 3
a518 1
nmg_pr_lu_briefly(const struct loopuse *lu, char *h)
d554 3
a556 1
nmg_pr_eg(const long int *eg_magic_p, char *h)
d609 3
a611 1
nmg_pr_e(const struct edge *e, char *h)
d630 3
a632 1
nmg_pr_eu(const struct edgeuse *eu, char *h)
d668 3
a670 1
nmg_pr_eu_briefly(const struct edgeuse *eu, char *h)
d685 3
a687 1
nmg_pr_eu_endpoints(const struct edgeuse *eu, char *h)
d710 3
a712 1
nmg_pr_vg(const struct vertex_g *vg, char *h)
d731 3
a733 1
nmg_pr_v(const struct vertex *v, char *h)
d760 3
a762 1
nmg_pr_vu(const struct vertexuse *vu, char *h)
d802 3
a804 1
nmg_pr_vu_briefly(const struct vertexuse *vu, char *h)
d827 3
a829 1
nmg_pr_vua(const long int *magic_p, char *h)
d858 3
a860 1
nmg_euprint(const char *str, const struct edgeuse *eu)
d887 4
a890 1
nmg_pr_ptbl(const char *title, const struct bu_ptbl *tbl, int verbose)
d932 4
a935 1
nmg_pr_ptbl_vert_list(const char *str, const struct bu_ptbl *tbl, const fastf_t *mag)
d983 6
a988 1
nmg_pr_one_eu_vecs(const struct edgeuse *eu, const fastf_t *xvec, const fastf_t *yvec, const fastf_t *zvec, const struct bn_tol *tol)
d1046 6
a1051 1
nmg_pr_fu_around_eu_vecs(const struct edgeuse *eu, const fastf_t *xvec, const fastf_t *yvec, const fastf_t *zvec, const struct bn_tol *tol)
d1087 3
a1089 1
nmg_pr_fu_around_eu(const struct edgeuse *eu, const struct bn_tol *tol)
d1119 2
a1120 1
nmg_pl_lu_around_eu(const struct edgeuse *eu)
d1172 2
a1173 1
nmg_pr_fus_in_fg(const long int *fg_magic)
@


11.25
log
@updated SIGNED to signed
updated CONST to const
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_pr.c,v 11.24 2000/08/21 02:02:33 butler Exp $ (ARL)";
d51 1
a51 2
nmg_orientation(orientation)
int	orientation;
d74 1
a74 3
nmg_pr_orient(orientation, h)
int		orientation;
const char	*h;
d90 1
a90 2
nmg_pr_m(m)
const struct model *m;
d128 1
a128 3
nmg_pr_r(r, h)
const struct nmgregion *r;
char *h;
d156 1
a156 3
nmg_pr_sa(sa, h)
const struct shell_a *sa;
char *h;
d178 1
a178 3
nmg_pr_lg(lg, h)
const struct loop_g *lg;
char *h;
d196 1
a196 3
nmg_pr_fg(magic, h)
const long *magic;
char *h;
d249 1
a249 3
nmg_pr_s(s, h)
const struct shell *s;
char *h;
d291 1
a291 3
nmg_pr_s_briefly(s, h)
const struct shell *s;
char *h;
d326 1
a326 3
nmg_pr_f(f, h)
const struct face *f;
char *h;
d352 1
a352 3
nmg_pr_fu(fu, h)
const struct faceuse *fu;
char *h;
d386 1
a386 3
nmg_pr_fu_briefly(fu, h)
const struct faceuse *fu;
char *h;
d414 1
a414 3
nmg_pr_l(l, h)
const struct loop *l;
char *h;
d436 1
a436 3
nmg_pr_lu(lu, h)
const struct loopuse *lu;
char *h;
d490 1
a490 3
nmg_pr_lu_briefly(lu, h)
const struct loopuse *lu;
char *h;
d526 1
a526 3
nmg_pr_eg(eg_magic_p, h)
const long *eg_magic_p;
char *h;
d579 1
a579 3
nmg_pr_e(e, h)
const struct edge *e;
char *h;
d598 1
a598 3
nmg_pr_eu(eu, h)
const struct edgeuse *eu;
char *h;
d634 1
a634 3
nmg_pr_eu_briefly(eu, h)
const struct edgeuse *eu;
char *h;
d649 1
a649 3
nmg_pr_eu_endpoints(eu, h)
const struct edgeuse *eu;
char *h;
d672 1
a672 3
nmg_pr_vg(vg, h)
const struct vertex_g *vg;
char *h;
d691 1
a691 3
nmg_pr_v(v, h)
const struct vertex *v;
char *h;
d718 1
a718 3
nmg_pr_vu(vu, h)
const struct vertexuse *vu;
char *h;
d758 1
a758 3
nmg_pr_vu_briefly(vu, h)
const struct vertexuse *vu;
char *h;
d781 1
a781 3
nmg_pr_vua(magic_p, h)
const long	*magic_p;
char *h;
d810 1
a810 3
nmg_euprint(str, eu)
const char		*str;
const struct edgeuse	*eu;
d837 1
a837 4
nmg_pr_ptbl( title, tbl, verbose )
const char		*title;
const struct bu_ptbl	*tbl;
int			verbose;
d879 1
a879 4
nmg_pr_ptbl_vert_list( str, tbl, mag )
const char		*str;
const struct bu_ptbl	*tbl;
const fastf_t		*mag;
d927 1
a927 6
nmg_pr_one_eu_vecs( eu, xvec, yvec, zvec, tol )
const struct edgeuse	*eu;
const vect_t		xvec;
const vect_t		yvec;
const vect_t		zvec;
const struct bn_tol	*tol;
d985 1
a985 6
nmg_pr_fu_around_eu_vecs( eu, xvec, yvec, zvec, tol )
const struct edgeuse	*eu;
const vect_t		xvec;
const vect_t		yvec;
const vect_t		zvec;
const struct bn_tol	*tol;
d1021 1
a1021 3
nmg_pr_fu_around_eu( eu, tol )
const struct edgeuse *eu;
const struct bn_tol	*tol;
d1051 1
a1051 2
nmg_pl_lu_around_eu(eu)
const struct edgeuse	*eu;
d1103 1
a1103 2
nmg_pr_fus_in_fg(fg_magic)
const long	*fg_magic;
@


11.24
log
@Massive compilation warnings eliminated
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_pr.c,v 11.23 2000/07/10 23:01:45 mike Exp $ (ARL)";
d77 1
a77 1
CONST char	*h;
d94 1
a94 1
CONST struct model *m;
d96 1
a96 1
	CONST struct nmgregion *r;
d133 1
a133 1
CONST struct nmgregion *r;
d163 1
a163 1
CONST struct shell_a *sa;
d187 1
a187 1
CONST struct loop_g *lg;
d207 1
a207 1
CONST long *magic;
d210 1
a210 1
	CONST struct face_g_snurb *fgs;
d262 1
a262 1
CONST struct shell *s;
d265 3
a267 3
	CONST struct faceuse	*fu;
	CONST struct loopuse	*lu;
	CONST struct edgeuse	*eu;
d306 1
a306 1
CONST struct shell *s;
d309 3
a311 3
	CONST struct faceuse	*fu;
	CONST struct loopuse	*lu;
	CONST struct edgeuse	*eu;
d343 1
a343 1
CONST struct face *f;
d371 1
a371 1
CONST struct faceuse *fu;
d374 1
a374 1
	CONST struct loopuse *lu;
d407 1
a407 1
CONST struct faceuse *fu;
d410 1
a410 1
	CONST struct loopuse *lu;
d437 1
a437 1
CONST struct loop *l;
d461 1
a461 1
CONST struct loopuse *lu;
d464 2
a465 2
	CONST struct edgeuse	*eu;
	CONST struct vertexuse *vu;
d517 1
a517 1
CONST struct loopuse *lu;
d520 2
a521 2
	CONST struct edgeuse	*eu;
	CONST struct vertexuse *vu;
d555 1
a555 1
CONST long *eg_magic_p;
d610 1
a610 1
CONST struct edge *e;
d631 1
a631 1
CONST struct edgeuse *eu;
d669 1
a669 1
CONST struct edgeuse *eu;
d686 1
a686 1
CONST struct edgeuse *eu;
d711 1
a711 1
CONST struct vertex_g *vg;
d732 1
a732 1
CONST struct vertex *v;
d761 1
a761 1
CONST struct vertexuse *vu;
d803 1
a803 1
CONST struct vertexuse *vu;
d806 1
a806 1
	CONST struct vertex_g	*vg;
d828 1
a828 1
CONST long	*magic_p;
d859 2
a860 2
CONST char		*str;
CONST struct edgeuse	*eu;
d862 2
a863 2
	CONST fastf_t	*eup;
	CONST fastf_t	*matep;
d888 2
a889 2
CONST char		*title;
CONST struct bu_ptbl	*tbl;
d933 3
a935 3
CONST char		*str;
CONST struct bu_ptbl	*tbl;
CONST fastf_t		*mag;
d938 4
a941 4
	CONST struct vertexuse	**vup;
	CONST struct vertexuse	*vu;
	CONST struct vertex	*v;
	CONST struct vertex_g	*vg;
d945 1
a945 1
	vup = (CONST struct vertexuse **)tbl->buffer;
d984 10
a993 10
CONST struct edgeuse	*eu;
CONST vect_t		xvec;
CONST vect_t		yvec;
CONST vect_t		zvec;
CONST struct bn_tol	*tol;
{
	CONST struct loopuse	*lu;
	CONST struct faceuse	*fu;
	CONST struct face	*f;
	CONST struct shell	*s;
d1047 5
a1051 5
CONST struct edgeuse	*eu;
CONST vect_t		xvec;
CONST vect_t		yvec;
CONST vect_t		zvec;
CONST struct bn_tol	*tol;
d1053 1
a1053 1
	CONST struct edgeuse	*eu1;
d1088 2
a1089 2
CONST struct edgeuse *eu;
CONST struct bn_tol	*tol;
d1120 1
a1120 1
CONST struct edgeuse	*eu;
d1123 2
a1124 2
	CONST struct edgeuse	*eu1;
	CONST struct loopuse	*lu1;
d1173 1
a1173 1
CONST long	*fg_magic;
@


11.23
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_pr.c,v 11.22 1999/12/30 15:47:41 jra Exp $ (ARL)";
d812 1
a812 1
	if( vg = vu->v_p->vg_p )  {
@


11.22
log
@Eliminated an unused variable
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_pr.c,v 11.21 1999/06/03 01:43:37 mike Exp $ (ARL)";
@


11.21
log
@
sed4
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_pr.c,v 11.20 1997/09/18 20:30:28 jra Exp $ (ARL)";
a411 1
	struct face_g_plane *fg;
@


11.20
log
@Added face geometry pointer to data printed by nmg_pr_fu_briefly().
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_pr.c,v 11.19 1997/09/09 13:52:30 jra Exp $ (ARL)";
d1138 1
a1138 1
	b = (long *)rt_calloc( nmg_find_model((long *)eu)->maxindex, sizeof(long),
d1161 1
a1161 1
	rt_free( (char *)b, "nmg_pl_lu_around_eu flag[]" );
@


11.19
log
@Added flip flag to nmg_pr_f().
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_pr.c,v 11.18 1997/06/13 21:42:51 mike Exp jra $ (ARL)";
d420 2
a421 2
		bu_log("%sFACEUSE %8x (%s) f_p=x%x flip=%d pl= %f %f %f %f\n",
			h, fu, nmg_orientation(fu->orientation), fu->f_p, fu->f_p->flip, V4ARGS( f->g.plane_p->N ));
@


11.18
log
@rt_list_len became bu_list_len
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_pr.c,v 11.17 1996/09/30 16:03:24 jra Exp mike $ (ARL)";
d357 2
@


11.17
log
@MOd to nmg_pr_fu_briefly() to allow printing of FU with no face geomatry assigned.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_pr.c,v 11.16 1996/09/27 08:27:30 mike Exp jra $ (ARL)";
d569 1
a569 1
				h, rt_list_len( &eg_l->eu_hd2 ), V3ARGS(eg_l->e_dir));
@


11.16
log
@Converted to using proper routine names for LIBBU and LIBBN routines.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_pr.c,v 11.15 1996/08/27 03:04:09 mike Exp mike $ (ARL)";
d416 1
a416 1
	if( *f->g.magic_p == NMG_FACE_G_PLANE_MAGIC )
@


11.15
log
@Eliminated confusing "else" statements after rt_bomb().
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_pr.c,v 11.14 1996/07/12 12:17:41 jra Exp mike $ (ARL)";
d80 6
a85 6
	case OT_SAME : rt_log("%s%8s orientation\n", h, "SAME"); break;
	case OT_OPPOSITE : rt_log("%s%8s orientation\n", h, "OPPOSITE"); break;
	case OT_NONE : rt_log("%s%8s orientation\n", h, "NONE"); break;
	case OT_UNSPEC : rt_log("%s%8s orientation\n", h, "UNSPEC"); break;
	case OT_BOOLPLACE : rt_log("%s%8s orientation\n", h, "BOOLPLACE"); break;
	default : rt_log("%s%8s orientation\n", h, "BOGUS!!!"); break;
d98 1
a98 1
	rt_log("MODEL %8x\n", m);
d100 1
a100 1
		rt_log("bad model magic\n");
d103 1
a103 1
	rt_log("%ld maxindex\n", m->maxindex);
d105 1
a105 1
	for( RT_LIST_FOR( r, nmgregion, &m->r_hd ) )  {
d138 1
a138 1
	rt_log("REGION %8x\n", r);
d143 1
a143 1
		rt_log("bad region magic\n");
d147 4
a150 4
	rt_log("%8x m_p\n", r->m_p);
	rt_log("%8x l.forw\n", r->l.forw);
	rt_log("%8x l.back\n", r->l.back);
	rt_log("%8x ra_p\n", r->ra_p);
d152 1
a152 1
	for( RT_LIST_FOR( s, shell, &r->s_hd ) )  {
d168 1
a168 1
	rt_log("%sSHELL_A %8x\n", h, sa);
d170 1
a170 1
		rt_log("bad shell_a magic\n");
d174 1
a174 1
	rt_log("%s%f %f %f Min\n", h, sa->min_pt[X], sa->min_pt[Y],
d176 1
a176 1
	rt_log("%s%f %f %f Max\n", h, sa->max_pt[X], sa->max_pt[Y],
d193 2
a194 2
	rt_log("%sLOOP_G %8x\n", h, lg);
	rt_log("%s%f %f %f Min\n", h, lg->min_pt[X], lg->min_pt[Y],
d196 1
a196 1
	rt_log("%s%f %f %f Max\n", h, lg->max_pt[X], lg->max_pt[Y],
d218 1
a218 1
		rt_log("%sFACE_G_PLANE %8x\n", h, magic);
d220 1
a220 1
		rt_log("%s%fX + %fY + %fZ = %f\n", h,
d225 3
a227 3
		rt_log("%sFACE_G_SNURB %8x\n", h, magic);
		rt_log( "%s  order (%d, %d)\n", h, fgs->order[0], fgs->order[1] );
		rt_log( "%s  U knots: size=%d", h, fgs->u.k_size );
d229 2
a230 2
			rt_log( " %f", fgs->u.knots[i] );
		rt_log( "\n%s  V knots: size=%d", h, fgs->v.k_size );
d232 2
a233 2
			rt_log( " %f", fgs->v.knots[i] );
		rt_log( "\n%s  Mesh size = (%d X %d), pt_type = %d\n", h, fgs->s_size[0], fgs->s_size[1], fgs->pt_type );
d238 1
a238 1
			rt_log( "%s  ", h );
d241 1
a241 1
				rt_log( " (", h );
d243 2
a244 2
					rt_log( "%f ", fgs->ctl_points[l+k] );
				rt_log( ")" );
d247 1
a247 1
			rt_log( "\n" );
d271 1
a271 1
	rt_log("%sSHELL %8x\n", h, s);
d273 1
a273 1
		rt_log("bad shell magic\n");
d277 4
a280 4
	rt_log("%s%8x r_p\n", h, s->r_p);
	rt_log("%s%8x l.forw\n", h, s->l.forw );
	rt_log("%s%8x l.back\n", h, s->l.back );
	rt_log("%s%8x sa_p\n", h, s->sa_p );
d284 1
a284 1
	for( RT_LIST_FOR( fu, faceuse, &s->fu_hd ) )  {
d288 1
a288 1
	for( RT_LIST_FOR( lu, loopuse, &s->lu_hd ) )  {
d292 1
a292 1
	for( RT_LIST_FOR( eu, edgeuse, &s->eu_hd ) )  {
d315 1
a315 1
	rt_log("%sSHELL %8x\n", h, s);
d317 1
a317 1
		rt_log("bad shell magic\n");
d321 1
a321 1
	for( RT_LIST_FOR( fu, faceuse, &s->fu_hd ) )  {
d325 1
a325 1
	for( RT_LIST_FOR( lu, loopuse, &s->lu_hd ) )  {
d329 1
a329 1
	for( RT_LIST_FOR( eu, edgeuse, &s->eu_hd ) )  {
d349 3
a351 3
	rt_log("%sFACE %8x\n", h, f);
	rt_log("%s%8x fu_p\n", h, f->fu_p);
	rt_log("%s%8x g.magic_p\n", h, f->g.magic_p);
d353 1
a353 1
	rt_log("%s%f %f %f Min\n", h, f->min_pt[X], f->min_pt[Y],
d355 1
a355 1
	rt_log("%s%f %f %f Max\n", h, f->max_pt[X], f->max_pt[Y],
d377 1
a377 1
	rt_log("%sFACEUSE %8x\n", h, fu);
d380 1
a380 1
		rt_log("bad faceuse magic\n");
d384 4
a387 4
	rt_log("%s%8x s_p\n", h, fu->s_p);
	rt_log("%s%8x l.forw\n", h, fu->l.forw);
	rt_log("%s%8x l.back\n", h, fu->l.back);
	rt_log("%s%8x fumate_p\n", h, fu->fumate_p);
d390 1
a390 1
	rt_log("%s%8x f_p\n", h, fu->f_p);
d394 1
a394 1
	for( RT_LIST_FOR( lu, loopuse, &fu->lu_hd ) )  {
d418 1
a418 1
		rt_log("%sFACEUSE %8x (%s) f_p=x%x flip=%d pl= %f %f %f %f\n",
d422 1
a422 1
		rt_log("%sFACEUSE %8x (%s) f_p=x%x\n",
d425 1
a425 1
	for( RT_LIST_FOR( lu, loopuse, &fu->lu_hd ) )  {
d442 1
a442 1
	rt_log("%sLOOP %8x\n", h, l);
d444 1
a444 1
		rt_log("bad loop magic\n");
d447 2
a448 2
	rt_log("%s%8x lu_p\n", h, l->lu_p);
	rt_log("%s%8x lg_p\n", h, l->lg_p);
d470 1
a470 1
	rt_log("%sLOOPUSE %8x\n", h, lu);
d473 1
a473 1
	case NMG_SHELL_MAGIC	: rt_log("%s%8x up.s_p\n", h, lu->up.s_p);
d475 1
a475 1
	case NMG_FACEUSE_MAGIC	: rt_log("%s%8x up.fu_p\n", h, lu->up.fu_p);
d477 1
a477 1
	default			: rt_log("Bad loopuse parent magic\n");
d481 3
a483 3
	rt_log("%s%8x l.forw\n", h, lu->l.forw);
	rt_log("%s%8x l.back\n", h, lu->l.back);
	rt_log("%s%8x lumate_p\n", h, lu->lumate_p);
d485 1
a485 1
	rt_log("%s%8x l_p\n", h, lu->l_p);
d490 3
a492 3
	rt_log("%s%8x down_hd.magic\n", h, lu->down_hd.magic);
	rt_log("%s%8x down_hd.forw\n", h, lu->down_hd.forw);
	rt_log("%s%8x down_hd.back\n", h, lu->down_hd.back);
d494 1
a494 1
	magic1 = RT_LIST_FIRST_MAGIC( &lu->down_hd );
d496 2
a497 2
		vu = RT_LIST_PNEXT( vertexuse, &lu->down_hd );
		rt_log("%s%8x down_hd->forw (vu)\n", h, vu);
d501 1
a501 1
		for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
d506 1
a506 1
		rt_log("bad loopuse child magic\n");
d526 1
a526 1
	rt_log("%sLOOPUSE %8x, lumate_p=x%x (%s) \n",
d529 1
a529 1
	magic1 = RT_LIST_FIRST_MAGIC( &lu->down_hd );
d531 2
a532 2
		vu = RT_LIST_PNEXT( vertexuse, &lu->down_hd );
		rt_log("%s%8x down_hd->forw (vu)\n", h, vu);
d536 1
a536 1
		for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
d541 1
a541 1
		rt_log("bad loopuse child magic\n");
d566 1
a566 1
			rt_log("%sEDGE_G_LSEG %8x pt:(%f %f %f)\n",
d568 1
a568 1
			rt_log("%s       eu uses=%d  dir:(%f %f %f)\n",
d578 2
a579 2
			rt_log( "%sEDGE_G_CNURB %8x\n" , h , eg_c );
			rt_log( "%s  order=%d, %d ctl pts, pt_type=%d\n",
d581 1
a581 1
			rt_log( "%s  knot vector (len=%d):", h, eg_c->k.k_size );
d583 2
a584 2
				rt_log( " %f", eg_c->k.knots[i] );
			rt_log( "\n" );
d587 1
a587 1
			rt_log( "%s  control points: ", h );
d590 1
a590 1
				rt_log( "(" );
d592 2
a593 2
					rt_log( "%f ", eg_c->ctl_points[l+j] );
				rt_log( ")" );
d596 1
a596 1
			rt_log( "\n" );
d615 1
a615 1
	rt_log("%sEDGE %8x\n", h, e);
d617 1
a617 1
		rt_log("bad edge magic\n");
d620 1
a620 1
	rt_log("%s%8x eu_p\n", h, e->eu_p);
d636 1
a636 1
	rt_log("%sEDGEUSE %8x\n", h, eu);
d639 1
a639 1
	case NMG_SHELL_MAGIC	: rt_log("%s%8x up.s_p\n", h, eu->up.s_p);
d641 1
a641 1
	case NMG_LOOPUSE_MAGIC	: rt_log("%s%8x up.lu_p\n", h, eu->up.lu_p);
d643 1
a643 1
	default			: rt_log("bad edgeuse parent magic\n");
d646 4
a649 4
	rt_log("%s%8x l.forw\n", h, eu->l.forw);
	rt_log("%s%8x l.back\n", h, eu->l.back);
	rt_log("%s%8x eumate_p\n", h, eu->eumate_p);
	rt_log("%s%8x radial_p\n", h, eu->radial_p);
d651 3
a653 3
	rt_log("%s%8x e_p\n", h, eu->e_p);
	rt_log("%s%8x vu_p\n", h, eu->vu_p);
	rt_log("%s%8x g.magic_p\n", h, eu->g.magic_p);
d674 1
a674 1
	rt_log("%sEDGEUSE %8x, g=%8x, e_p=%8x\n", h, eu, eu->g.magic_p, eu->e_p);
d698 1
a698 1
	rt_log("%sEDGEUSE %8x\n%s  (%g, %g, %g) -- (%g, %g, %g)\n", h, eu, h,
d717 2
a718 2
		rt_log("%sVERTEX_G %8x\n", h, vg);
		rt_log("bad vertex_g magic\n");
d721 1
a721 1
	rt_log("%sVERTEX_G %8x %f %f %f = XYZ coord\n",
d737 1
a737 1
	rt_log("%sVERTEX %8x\n", h, v);
d739 1
a739 1
		rt_log("bad vertex magic\n");
d743 3
a745 3
	rt_log("%s   vu_hd %8x\n", h, &v->vu_hd);
	rt_log("%s%8x vu_hd.forw\n", h, v->vu_hd.forw);
	rt_log("%s%8x vu_hd.back\n", h, v->vu_hd.back);
d748 1
a748 1
	rt_log("%s%8x vg_p\n", h, v->vg_p);
d766 1
a766 1
	rt_log("%sVERTEXUSE %8x\n", h, vu);
d768 1
a768 1
		rt_log("bad vertexuse magic\n");
d773 4
a776 4
	case NMG_SHELL_MAGIC	: rt_log("%s%8x up.s_p\n", h, vu->up.s_p); break;
	case NMG_LOOPUSE_MAGIC	: rt_log("%s%8x up.lu_p\n", h, vu->up.lu_p); break;
	case NMG_EDGEUSE_MAGIC	: rt_log("%s%8x up.eu_p\n", h, vu->up.eu_p); break;
	default			: rt_log("bad vertexuse parent magic\n"); 
d779 2
a780 2
	rt_log("%s%8x l.forw\n", h, vu->l.forw);
	rt_log("%s%8x l.back\n", h, vu->l.back);
d783 2
a784 2
		rt_log("%s%8x a.plane_p\n", h, vu->a.plane_p);
		rt_log("%s normal: %f %f %f\n", h, V3ARGS( vu->a.plane_p->N ) );
d787 1
a787 1
		rt_log("%s%8x a.cnurb_p\n", h, vu->a.cnurb_p);
d790 1
a790 1
	rt_log("%s%8x v_p\n", h, vu->v_p);
d813 1
a813 1
		rt_log("%sVERTEXUSE %8x, v=x%x, %f %f %f\n", h, vu, vu->v_p,
d816 1
a816 1
		rt_log("%sVERTEXUSE %8x, v=x%x\n", h, vu, vu->v_p);
d832 1
a832 1
	rt_log("%sVERTEXUSE_A %8x\n", h, magic_p);
d834 1
a834 1
		rt_log("bad vertexuse_a magic\n");
d840 1
a840 1
		rt_log("%s N=(%g, %g, %g, %g)\n", h,
d844 1
a844 1
		rt_log("%s param=(%g, %g, %g)\n", h,
d877 1
a877 1
	rt_log("%s (%g, %g, %g -> %g, %g, %g)\n", str, eup[0], eup[1], eup[2],
d883 1
a883 1
 *  Print an nmg_ptbl array for inspection.
d888 1
a888 1
CONST struct nmg_ptbl	*tbl;
d893 2
a894 2
	NMG_CK_PTBL(tbl);
	rt_log("%s: nmg_ptbl array with %d entries\n",
d899 2
a900 2
	for( lp = (long **)NMG_TBL_BASEADDR(tbl);
	     lp <= (long **)NMG_TBL_LASTADDR(tbl); lp++
d903 1
a903 1
			rt_log("  %.8x NULL entry\n", *lp);
d908 1
a908 1
			rt_log("  %.8x %s\n", *lp, rt_identify_magic(**lp) );
d911 1
a911 1
			rt_log("  %.8x edgeuse vu=%x, far vu=%x\n",
d914 1
a914 1
				RT_LIST_PNEXT_CIRC(edgeuse, *lp)->vu_p );
d917 1
a917 1
			rt_log("  %.8x vertexuse v=%x\n",
d933 1
a933 1
CONST struct nmg_ptbl	*tbl;
d942 1
a942 1
    	rt_log("nmg_pr_ptbl_vert_list(%s):\n", str);
d949 1
a949 1
			rt_log( "\tWARNING: vertexuse #%d has bad MAGIC (%x)\n" , i, vu->l.magic );
d957 1
a957 1
		rt_log("%d\t%g, %g, %g\t", i, V3ARGS(vg->coord) );
d959 1
a959 1
			rt_log("EDGEUSE");
d961 1
a961 1
			rt_log("LOOPUSE");
d963 1
a963 1
				rt_log("ERROR vertexuse's parent disowns us!\n");
d969 1
a969 1
			rt_log("vu up UNKNOWN");
d971 1
a971 1
		rt_log("\tv=x%x, vu=x%x, dist=%g\n", v , vu, mag[i] );
d987 1
a987 1
CONST struct rt_tol	*tol;
d1022 1
a1022 1
		rt_log(" %8.8x, lu=%8.8x=%1.1s, f=%8.8x, fu=%8.8x=%1.1s, s=%8.8x SNURB\n",
d1031 1
a1031 1
		rt_log(" %8.8x, lu=%8.8x=%1.1s, f=%8.8x, fu=%8.8x=%1.1s, s=%8.8x %g deg\n",
d1037 1
a1037 1
			nmg_measure_fu_angle(eu, xvec, yvec, zvec) * rt_radtodeg );
d1050 1
a1050 1
CONST struct rt_tol	*tol;
d1055 2
a1056 2
	RT_CK_TOL(tol);
	rt_log("nmg_pr_fu_around_eu_vecs(eu=x%x) e=x%x\n", eu, eu->e_p);
d1088 1
a1088 1
CONST struct rt_tol	*tol;
d1093 2
a1094 2
	RT_CK_TOL(tol);
	rt_log("nmg_pr_fu_around_eu(x%x)\n", eu);
d1161 1
a1161 1
	rt_log("Wrote %s\n", buf);
d1177 2
a1178 2
	rt_log("nmg_pr_fus_in_fg(x%x):\n", fg_magic);
	for( RT_LIST_FOR( f, face, &(((struct face_g_plane *)fg_magic)->f_hd) ) )  {
d1181 1
a1181 1
		rt_log(" f=x%x, fu=x%x, fumate=x%x\n",
@


11.14
log
@Minor Mods for IRIX 6.2
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_pr.c,v 11.13 1996/06/11 17:39:41 jra Exp jra $ (ARL)";
d966 1
a966 2
				else
					rt_bomb("lumate has garbage\n");
d969 1
a969 1
			rt_log("UNKNOWN");
@


11.13
log
@Added "flip" flag to nmg_pr_fu_briefly().
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_pr.c,v 11.12 1996/04/22 12:21:08 jra Exp jra $ (ARL)";
d982 1
@


11.12
log
@Added face plane to output for nmg_pr_fu_briefly().
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_pr.c,v 11.11 1996/03/05 21:37:21 jra Exp jra $ (ARL)";
d418 2
a419 2
		rt_log("%sFACEUSE %8x (%s) f_p=x%x pl= %f %f %f %f\n",
			h, fu, nmg_orientation(fu->orientation), fu->f_p, V4ARGS( f->g.plane_p->N ));
@


11.11
log
@Added face pointer to output in nmg_fu_pr_briefly().
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_pr.c,v 11.10 1995/11/27 15:50:04 jra Exp $ (ARL)";
d409 2
d414 1
d416 8
a423 2
	rt_log("%sFACEUSE %8x (%s) f_p=x%x\n",
		h, fu, nmg_orientation(fu->orientation), fu->f_p);
@


11.10
log
@Mods to nmg_pr_one_eu_vecs() and nmg_pr_fu_around_eu() to handle NURBS (sort of).
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_pr.c,v 11.9 1995/09/06 13:12:04 jra Exp jra $ (ARL)";
d413 2
a414 2
	rt_log("%sFACEUSE %8x (%s)\n",
		h, fu, nmg_orientation(fu->orientation));
@


11.9
log
@Modified nmg_pr_ptbl_vert_list() to accept an array of distancesalong intersection ray  list of vertices.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_pr.c,v 11.8 1995/08/21 14:20:43 jra Exp jra $ (ARL)";
d1011 19
a1029 7
	rt_log(" %8.8x, lu=%8.8x=%1.1s, f=%8.8x, fu=%8.8x=%1.1s, s=%8.8x %g deg\n",
		eu,
		lu, lu_orient,
		f,
		fu, fu_orient,
		s,
		nmg_measure_fu_angle(eu, xvec, yvec, zvec) * rt_radtodeg );
d1087 1
a1087 1
	if( eu->vu_p->v_p == eu->eumate_p->vu_p->v_p )
@


11.8
log
@Added printing of vertexuse normal to nmg_pr_vu().
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_pr.c,v 11.7 1995/06/27 14:05:57 jra Exp $ (ARL)";
d922 1
a922 1
nmg_pr_ptbl_vert_list( str, tbl )
d925 1
d963 1
a963 1
		rt_log("\tv=x%x, vu=x%x\n", v , vu);
@


11.7
log
@Added pt_type output for edge cnurb geometry.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_pr.c,v 11.6 1995/06/27 13:57:48 jra Exp $ (ARL)";
d775 1
@


11.6
log
@Added output for nurb face geometry and edge geometry.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_pr.c,v 11.5 1995/05/10 12:57:53 jra Exp $ (ARL)";
d570 2
a571 1
			rt_log( "%s  order=%d, %d ctl pts\n", h, eg_c->order, eg_c->c_size );
@


11.5
log
@Added warning for vertexuses with bad magic (killed by nmg_repair_v_near_v).
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_pr.c,v 11.4 1995/02/15 21:04:57 jra Exp jra $ (ARL)";
d43 1
d210 4
d224 1
d226 23
a248 1
		/* XXX What else? */
d566 3
d571 16
@


11.4
log
@Added e_p to output for nmg_pr_eu_briefly.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_pr.c,v 11.3 95/02/03 03:06:41 mike Exp Locker: jra $ (ARL)";
d888 5
@


11.3
log
@Moved 2 routines from nmg_inter.c to nmg_pr.c
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_pr.c,v 11.2 95/02/03 02:53:18 mike Exp Locker: mike $ (ARL)";
d617 1
a617 1
	rt_log("%sEDGEUSE %8x, g=%8x\n", h, eu, eu->g.magic_p);
@


11.2
log
@Added edge_g printing to nmg_pr_eu_briefly().
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_pr.c,v 11.1 95/01/04 09:58:10 mike Rel4_4 Locker: mike $ (ARL)";
d1033 75
@


11.1
log
@Release_4.4
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_pr.c,v 1.21 94/11/18 12:37:14 jra Exp $ (ARL)";
d617 1
a617 1
	rt_log("%sEDGEUSE %8x\n", h, eu);
@


1.21
log
@Fixed typo in previous revision.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_pr.c,v 1.20 94/11/18 10:49:54 jra Exp Locker: jra $ (ARL)";
@


1.20
log
@Modified nmg_pr_fu_around_eu to handle edges to/from same vertex.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_pr.c,v 1.19 94/11/05 00:34:49 mike Exp Locker: jra $ (ARL)";
d1024 1
a1024 1
		VSET( zvec , 0 , 1 , 1 );
@


1.19
log
@Irix 6
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_pr.c,v 1.18 94/11/04 12:38:32 jra Exp Locker: mike $ (ARL)";
d1020 11
a1030 2
	/* Erect coordinate system around eu */
	nmg_eu_2vecs_perp( xvec, yvec, zvec, eu, tol );
@


1.18
log
@Modified nmg_pr_eg to handle both types of edge geometries.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_pr.c,v 1.17 94/09/21 03:50:14 mike Exp Locker: jra $ (ARL)";
d783 1
a783 1
			V4ARGS( ((struct vertexuse_a_plane *)magic_p)->N ) );
a976 5
	CONST struct loopuse	*lu;
	CONST struct faceuse	*fu;
	CONST struct face	*f;
	int			lu_orient;
	int			fu_orient;
a1013 3
	CONST struct edgeuse	*eu1;
	CONST struct loopuse	*lu;
	CONST struct faceuse	*fu;
@


1.17
log
@Eliminated model_a structure
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_pr.c,v 1.16 94/09/10 04:37:16 mike Exp Locker: mike $ (ARL)";
d512 2
a513 1
 * XXX This is presently just nmg_pr_eg_lseg().
d516 2
a517 3
nmg_pr_eg(eg, h)
CONST struct edge_g_lseg	*eg;
/*  CONST long *eg;  */
d521 1
a521 6
	NMG_CK_EDGE_G_LSEG(eg);
	
	rt_log("%sEDGE_G %8x pt:(%f %f %f)\n",
		h, eg, V3ARGS(eg->e_pt));
	rt_log("%s       eu uses=%d  dir:(%f %f %f)\n",
		h, rt_list_len( &eg->eu_hd2 ), V3ARGS(eg->e_dir));
d523 21
d601 1
a601 1
		nmg_pr_eg(eu->g.lseg_p, h);
@


1.16
log
@Converted NMG data structures to have edge_g pointer in edgeuse, not edge.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_pr.c,v 1.15 94/09/03 03:01:46 mike Exp $ (ARL)";
a101 1
	rt_log("%8x ma_p\n", m->ma_p);
@


1.15
log
@Snapshot of non-working intermediate stage in edge_g evolution.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_pr.c,v 1.14 94/09/02 19:07:52 mike Exp Locker: mike $ (ARL)";
d512 2
a548 1
	rt_log("%s%8x eg_p\n", h, e->eg_p);
a549 3
	if (e->eg_p)
		nmg_pr_eg(e->eg_p, h);

d581 1
d585 3
d719 2
a720 1
	
d748 31
@


1.14
log
@vertexuse_a is now vertexuse_a_plane and vertexuse_a_cnurb
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_pr.c,v 1.13 94/09/02 17:58:30 mike Exp Locker: mike $ (ARL)";
d515 2
a516 1
CONST struct edge_g *eg;
d520 1
a520 1
	NMG_CK_EDGE_G(eg);
d524 2
a525 2
	rt_log("%s       use %d  dir:(%f %f %f)\n",
		h, eg->usage, V3ARGS(eg->e_dir));
@


1.13
log
@faceuse_a, loopuse_a, and edgeuse_a have been eliminated.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_pr.c,v 1.12 94/09/02 01:14:52 mike Exp Locker: mike $ (ARL)";
d706 8
a713 1
	rt_log("%s%8x vua_p\n", h, vu->vua_p);
@


1.12
log
@More fallout from face_g changes.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_pr.c,v 1.11 94/09/02 00:32:43 mike Exp Locker: mike $ (ARL)";
a361 1
	rt_log("%s%8x fua_p\n", h, fu->fua_p);
a447 1
	rt_log("%s%8x lua_p\n", h, lu->lua_p);
a578 1
	rt_log("%s%8x eua_p\n", h, eu->eua_p);
@


1.11
log
@Changed to new face geometry pointers (g.plane_p)
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_pr.c,v 1.10 94/08/10 18:55:20 gdurf Exp Locker: mike $ (ARL)";
d206 2
a207 2
nmg_pr_fg(fg, h)
CONST struct face_g_plane *fg;
d212 3
a214 2
	rt_log("%sFACE_G %8x\n", h, fg);
	NMG_CK_FACE_G_PLANE(fg);
d216 10
a225 2
	rt_log("%s%fX + %fY + %fZ = %f\n", h, fg->N[0], fg->N[1],
		fg->N[2], fg->N[3]);
d332 1
a332 1
		nmg_pr_fg(f->g.plane_p, h);
@


1.10
log
@Factored ifdefs
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_pr.c,v 1.9 1994/08/09 19:38:25 mike Exp gdurf $ (ARL)";
d207 1
a207 1
CONST struct face_g *fg;
d213 1
a213 1
	NMG_CK_FACE_G(fg);
d315 1
a315 1
	rt_log("%s%8x fg_p\n", h, f->fg_p);
d322 2
a323 2
	if (f->fg_p)
		nmg_pr_fg(f->fg_p, h);
@


1.9
log
@Added GDurf's new "conf.h"
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_pr.c,v 1.8 94/07/01 23:42:00 mike Exp Locker: mike $ (ARL)";
d33 3
a35 1
#ifdef BSD
a36 2
#else
# include <string.h>
@


1.8
log
@Added nmg_pr_eu_endpoints()
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_pr.c,v 1.7 94/04/25 03:15:50 mike Exp Locker: mike $ (ARL)";
d31 1
@


1.7
log
@Made printing of an nmg_ptbl slightly more pretty.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_pr.c,v 1.6 94/04/22 05:52:03 mike Exp Locker: mike $ (ARL)";
d594 25
@


1.6
log
@Moved nmg_pr_ptbl() from nmg_inter.c to nmg_pr.c
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_pr.c,v 1.5 94/03/10 06:47:03 butler Exp Locker: mike $ (ARL)";
d755 20
a774 1
		rt_log("  %.8x %s\n", *lp, rt_identify_magic(**lp) );
@


1.5
log
@added line to nmg_pr_m() to print the maxindex element of the model struct.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_pr.c,v 1.4 1994/01/25 08:33:20 mike Exp butler $ (ARL)";
d732 25
@


1.4
log
@Moved nmg_pr_fu_around_eu() et.al. from nmg_ck.c to nmg_pr.c
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_pr.c,v 1.3 93/12/27 22:45:39 mike Exp Locker: mike $ (ARL)";
d102 1
@


1.3
log
@Moved bounding box for faces from struct face_g to struct face.
Necessary because face geometry is now shared by multiple faces
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_pr.c,v 1.2 93/10/01 20:01:14 mike Exp Locker: mike $ (ARL)";
d776 122
@


1.2
log
@Added missing CONST
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_pr.c,v 1.1 93/09/30 20:56:39 mike Exp Locker: mike $ (ARL)";
a211 5
	
	rt_log("%s%f %f %f Min\n", h, fg->min_pt[X], fg->min_pt[Y],
		fg->min_pt[Z]);
	rt_log("%s%f %f %f Max\n", h, fg->max_pt[X], fg->max_pt[Y],
		fg->max_pt[Z]);
d314 6
@


1.1
log
@Initial revision
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
d750 1
a750 1
	vup = (struct vertexuse **)tbl->buffer;
@
