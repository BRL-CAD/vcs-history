head	11.86;
access;
symbols
	ansi-20040405-merged:11.77.2.2
	postmerge-20040405-ansi:11.84
	premerge-20040404-ansi:11.83
	postmerge-autoconf:11.83
	autoconf-freeze:11.80.4.3
	premerge-autoconf:11.83
	ansi-20040316-freeze:11.77.2.1
	postmerge-20040315-windows:11.83
	premerge-20040315-windows:11.83
	windows-20040315-freeze:11.77.4.1
	autoconf-20031203:11.80.4.1
	autoconf-20031202:11.80
	autoconf-branch:11.80.0.4
	phong-branch:11.80.0.2
	photonmap-branch:11.79.0.2
	rel-6-1-DP:11.78
	windows-branch:11.77.0.4
	rel-6-0-2:11.75
	ansi-branch:11.77.0.2
	rel-6-0-1-branch:11.75.0.2
	hartley-6-0-post:11.76
	hartley-6-0-pre:11.75
	rel-6-0-1:11.75
	rel-6-0:11.73
	rel-5-4:11.55.2.1
	offsite-5-3-pre:11.66
	rel-5-3:11.55.2.1
	rel-5-2:11.55
	rel-5-1-branch:11.55.0.2
	rel-5-1:11.55
	rel-5-0:11.41
	rel-5-0-beta:11.37
	rel-4-5:11.25
	ctj-4-5-post:11.22
	ctj-4-5-pre:11.20
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.86
date	2004.05.21.18.07.35;	author morrison;	state dead;
branches;
next	11.85;

11.85
date	2004.05.10.15.30.47;	author erikg;	state Exp;
branches;
next	11.84;

11.84
date	2004.04.05.08.48.58;	author morrison;	state Exp;
branches;
next	11.83;

11.83
date	2004.02.02.17.39.28;	author morrison;	state Exp;
branches;
next	11.82;

11.82
date	2003.10.29.17.55.28;	author jra;	state Exp;
branches;
next	11.81;

11.81
date	2003.10.17.23.41.48;	author jra;	state Exp;
branches;
next	11.80;

11.80
date	2003.07.11.14.18.26;	author jra;	state Exp;
branches
	11.80.4.1;
next	11.79;

11.79
date	2003.04.07.17.56.39;	author jra;	state Exp;
branches
	11.79.2.1;
next	11.78;

11.78
date	2002.09.30.14.02.27;	author jra;	state Exp;
branches;
next	11.77;

11.77
date	2002.08.20.17.08.09;	author jra;	state Exp;
branches
	11.77.2.1
	11.77.4.1;
next	11.76;

11.76
date	2002.08.15.20.55.21;	author hartley;	state Exp;
branches;
next	11.75;

11.75
date	2002.08.02.17.49.58;	author jra;	state Exp;
branches;
next	11.74;

11.74
date	2002.05.29.15.02.57;	author jra;	state Exp;
branches;
next	11.73;

11.73
date	2002.02.20.16.18.51;	author jra;	state Exp;
branches;
next	11.72;

11.72
date	2002.02.20.16.02.22;	author jra;	state Exp;
branches;
next	11.71;

11.71
date	2002.01.10.18.12.41;	author butler;	state Exp;
branches;
next	11.70;

11.70
date	2001.05.17.20.05.25;	author morrison;	state Exp;
branches;
next	11.69;

11.69
date	2001.05.11.15.32.17;	author jra;	state Exp;
branches;
next	11.68;

11.68
date	2001.05.08.20.12.21;	author jra;	state Exp;
branches;
next	11.67;

11.67
date	2001.03.19.22.19.58;	author butler;	state Exp;
branches;
next	11.66;

11.66
date	2001.02.23.20.21.23;	author jra;	state Exp;
branches;
next	11.65;

11.65
date	2000.11.14.21.13.22;	author jra;	state Exp;
branches;
next	11.64;

11.64
date	2000.09.21.04.49.25;	author mike;	state Exp;
branches;
next	11.63;

11.63
date	2000.09.20.03.10.32;	author mike;	state Exp;
branches;
next	11.62;

11.62
date	2000.09.08.05.54.42;	author mike;	state Exp;
branches;
next	11.61;

11.61
date	2000.09.07.01.06.43;	author mike;	state Exp;
branches;
next	11.60;

11.60
date	2000.09.01.22.16.14;	author mike;	state Exp;
branches;
next	11.59;

11.59
date	2000.07.13.02.36.27;	author cjohnson;	state Exp;
branches;
next	11.58;

11.58
date	2000.07.12.00.39.14;	author mike;	state Exp;
branches;
next	11.57;

11.57
date	2000.07.10.23.01.47;	author mike;	state Exp;
branches;
next	11.56;

11.56
date	2000.06.30.15.27.09;	author pjt;	state Exp;
branches;
next	11.55;

11.55
date	2000.05.12.19.10.38;	author mike;	state Exp;
branches
	11.55.2.1;
next	11.54;

11.54
date	2000.05.12.01.37.21;	author mike;	state Exp;
branches;
next	11.53;

11.53
date	2000.05.12.01.10.59;	author mike;	state Exp;
branches;
next	11.52;

11.52
date	2000.04.12.02.34.38;	author mike;	state Exp;
branches;
next	11.51;

11.51
date	2000.02.29.20.34.37;	author mike;	state Exp;
branches;
next	11.50;

11.50
date	2000.01.29.04.23.38;	author mike;	state Exp;
branches;
next	11.49;

11.49
date	2000.01.14.22.30.39;	author mike;	state Exp;
branches;
next	11.48;

11.48
date	2000.01.12.01.41.15;	author mike;	state Exp;
branches;
next	11.47;

11.47
date	2000.01.11.21.34.45;	author mike;	state Exp;
branches;
next	11.46;

11.46
date	99.12.30.04.57.00;	author mike;	state Exp;
branches;
next	11.45;

11.45
date	99.12.28.23.33.59;	author mike;	state Exp;
branches;
next	11.44;

11.44
date	99.12.23.06.00.04;	author mike;	state Exp;
branches;
next	11.43;

11.43
date	99.11.26.20.49.33;	author mike;	state Exp;
branches;
next	11.42;

11.42
date	99.11.12.20.54.17;	author mike;	state Exp;
branches;
next	11.41;

11.41
date	99.06.03.01.57.01;	author mike;	state Exp;
branches;
next	11.40;

11.40
date	99.06.03.01.55.15;	author mike;	state Exp;
branches;
next	11.39;

11.39
date	99.06.03.01.54.25;	author mike;	state Exp;
branches;
next	11.38;

11.38
date	99.06.03.01.39.15;	author mike;	state Exp;
branches;
next	11.37;

11.37
date	98.03.26.08.15.32;	author mike;	state Exp;
branches;
next	11.36;

11.36
date	98.03.26.07.35.27;	author mike;	state Exp;
branches;
next	11.35;

11.35
date	98.03.26.07.24.12;	author mike;	state Exp;
branches;
next	11.34;

11.34
date	98.03.26.07.17.59;	author mike;	state Exp;
branches;
next	11.33;

11.33
date	98.03.26.07.09.09;	author mike;	state Exp;
branches;
next	11.32;

11.32
date	98.03.26.06.52.21;	author mike;	state Exp;
branches;
next	11.31;

11.31
date	98.03.26.06.45.23;	author mike;	state Exp;
branches;
next	11.30;

11.30
date	98.03.24.08.30.24;	author mike;	state Exp;
branches;
next	11.29;

11.29
date	98.03.24.08.22.03;	author mike;	state Exp;
branches;
next	11.28;

11.28
date	98.03.24.06.31.23;	author mike;	state Exp;
branches;
next	11.27;

11.27
date	98.03.24.04.47.33;	author mike;	state Exp;
branches;
next	11.26;

11.26
date	98.03.19.15.57.01;	author jra;	state Exp;
branches;
next	11.25;

11.25
date	97.12.16.00.14.40;	author mike;	state Exp;
branches;
next	11.24;

11.24
date	97.10.06.15.34.13;	author mike;	state Exp;
branches;
next	11.23;

11.23
date	97.09.18.20.32.45;	author jra;	state Exp;
branches;
next	11.22;

11.22
date	97.09.02.13.59.11;	author gdurf;	state Exp;
branches;
next	11.21;

11.21
date	97.08.28.21.39.03;	author mike;	state Exp;
branches;
next	11.20;

11.20
date	97.03.07.06.17.13;	author mike;	state Exp;
branches;
next	11.19;

11.19
date	97.03.07.06.11.23;	author mike;	state Exp;
branches;
next	11.18;

11.18
date	97.01.30.19.58.35;	author jra;	state Exp;
branches;
next	11.17;

11.17
date	97.01.10.15.31.01;	author jra;	state Exp;
branches;
next	11.16;

11.16
date	97.01.09.19.29.59;	author bparker;	state Exp;
branches;
next	11.15;

11.15
date	96.12.04.02.50.27;	author mike;	state Exp;
branches;
next	11.14;

11.14
date	96.10.19.06.17.45;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	96.09.27.08.27.30;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	96.09.24.05.15.13;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	96.08.31.05.16.39;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	96.08.31.04.27.05;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	96.08.31.04.20.54;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	96.08.31.04.03.14;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	96.08.31.03.15.29;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	96.08.31.02.19.01;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	96.08.29.06.06.14;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	96.08.28.10.03.46;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	95.10.31.21.52.39;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	95.03.18.04.18.08;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.58.29;	author mike;	state Rel4_4;
branches;
next	10.6;

10.6
date	94.12.09.01.21.33;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	94.08.10.19.41.06;	author gdurf;	state Exp;
branches;
next	10.4;

10.4
date	94.05.10.11.02.36;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	94.03.18.01.10.37;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	92.05.04.15.59.53;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.40.57;	author mike;	state Rel4_0;
branches;
next	1.31;

1.31
date	91.07.16.00.06.31;	author mike;	state Exp;
branches;
next	1.30;

1.30
date	91.07.10.00.37.43;	author mike;	state Exp;
branches;
next	1.29;

1.29
date	91.06.30.23.17.54;	author mike;	state Exp;
branches;
next	1.28;

1.28
date	91.06.30.22.24.23;	author mike;	state Exp;
branches;
next	1.27;

1.27
date	91.06.30.19.08.15;	author mike;	state Exp;
branches;
next	1.26;

1.26
date	91.06.29.22.14.07;	author mike;	state Exp;
branches;
next	1.25;

1.25
date	91.06.25.04.43.34;	author mike;	state Exp;
branches;
next	1.24;

1.24
date	91.06.14.06.52.26;	author mike;	state Exp;
branches;
next	1.23;

1.23
date	91.05.18.03.03.34;	author mike;	state Exp;
branches;
next	1.22;

1.22
date	91.01.28.23.52.39;	author mike;	state Exp;
branches;
next	1.21;

1.21
date	91.01.26.03.16.51;	author mike;	state Exp;
branches;
next	1.20;

1.20
date	91.01.26.02.53.43;	author mike;	state Exp;
branches;
next	1.19;

1.19
date	91.01.25.21.19.41;	author mike;	state Exp;
branches;
next	1.18;

1.18
date	90.12.18.00.18.50;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	90.12.11.22.09.03;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	90.11.02.03.11.20;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	90.11.02.02.10.34;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	90.10.07.21.38.51;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	90.10.06.02.52.28;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	90.10.04.21.00.06;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	90.07.31.01.01.22;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	90.07.31.00.42.04;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	90.07.30.12.21.05;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	90.04.26.02.10.53;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	90.04.12.04.00.37;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	90.04.12.03.03.20;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	90.01.06.04.52.37;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	90.01.06.04.09.24;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	90.01.06.04.04.44;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	89.12.30.05.23.59;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	89.10.10.16.11.23;	author mike;	state Exp;
branches;
next	;

11.55.2.1
date	2000.11.14.21.35.30;	author jra;	state Exp;
branches;
next	;

11.77.2.1
date	2002.09.19.18.01.46;	author morrison;	state Exp;
branches;
next	11.77.2.2;

11.77.2.2
date	2004.03.17.21.18.57;	author morrison;	state Exp;
branches;
next	;

11.77.4.1
date	2004.03.11.23.43.45;	author morrison;	state Exp;
branches;
next	;

11.79.2.1
date	2003.08.26.14.03.36;	author justin;	state Exp;
branches;
next	;

11.80.4.1
date	2003.12.03.16.24.07;	author erikg;	state Exp;
branches;
next	11.80.4.2;

11.80.4.2
date	2004.02.12.18.37.47;	author erikg;	state Exp;
branches;
next	11.80.4.3;

11.80.4.3
date	2004.03.15.14.07.29;	author erikg;	state Exp;
branches;
next	;


desc
@Contains rt_prep() and rt_clean()
@


11.86
log
@moved to src/
@
text
@/*
 *			P R E P
 *
 *  Manage one-time preparations to be done before actual
 *  ray-tracing can commence.
 *
 *
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1990-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSprep[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/prep.c,v 11.85 2004/05/10 15:30:47 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "raytrace.h"
#include "plot3.h"
#include "./debug.h"
#include <unistd.h>

BU_EXTERN(void		rt_ck, (struct rt_i	*rtip));

HIDDEN void	rt_solid_bitfinder(register union tree *treep, struct region *regp, struct resource *resp);

extern struct resource	rt_uniresource;		/* from shoot.c */

/* XXX Need rt_init_rtg(), rt_clean_rtg() */

/*
 *			R T _ N E W _ R T I
 *
 *  Given a db_i database instance, create an rt_i instance.
 *  If caller just called db_open, they need to do a db_close(),
 *  because we have cloned our own instance of the db_i.
 */
struct rt_i *
rt_new_rti(struct db_i *dbip)
{
	register struct rt_i	*rtip;
	register int		i;

	RT_CK_DBI( dbip );

	/* XXX Move to rt_global_init() ? */
	if( BU_LIST_FIRST( bu_list, &rt_g.rtg_vlfree ) == 0 )  {
		BU_LIST_INIT( &rt_g.rtg_vlfree );
	}

	BU_GETSTRUCT( rtip, rt_i );
	rtip->rti_magic = RTI_MAGIC;
	for( i=0; i < RT_DBNHASH; i++ )  {
		BU_LIST_INIT( &(rtip->rti_solidheads[i]) );
	}
	rtip->rti_dbip = db_clone_dbi( dbip, (long *)rtip );
	rtip->needprep = 1;

	BU_LIST_INIT( &rtip->HeadRegion );

	/* This table is used for discovering the per-cpu resource structures */
	bu_ptbl_init( &rtip->rti_resources, MAX_PSW+1, "rti_resources ptbl" );
	BU_PTBL_END(&rtip->rti_resources) = MAX_PSW+1;	/* Make 'em all available */

	rt_uniresource.re_magic = RESOURCE_MAGIC;

	/* list of invisible light regions to be deleted after light_init() */
	bu_ptbl_init( &rtip->delete_regs, 8, "rt_i delete regions list" );

	VSETALL( rtip->mdl_min,  INFINITY );
	VSETALL( rtip->mdl_max, -INFINITY );
	VSETALL( rtip->rti_inf_box.bn.bn_min, -0.1 );
	VSETALL( rtip->rti_inf_box.bn.bn_max,  0.1 );
	rtip->rti_inf_box.bn.bn_type = CUT_BOXNODE;

	/* XXX These defaults need to be improved */
	rtip->rti_tol.magic = BN_TOL_MAGIC;
	rtip->rti_tol.dist = 0.0005;
	rtip->rti_tol.dist_sq = rtip->rti_tol.dist * rtip->rti_tol.dist;
	rtip->rti_tol.perp = 1e-6;
	rtip->rti_tol.para = 1 - rtip->rti_tol.perp;

	rtip->rti_ttol.magic = RT_TESS_TOL_MAGIC;
	rtip->rti_ttol.abs = 0.0;
	rtip->rti_ttol.rel = 0.01;
	rtip->rti_ttol.norm = 0;

	rtip->rti_max_beam_radius = 175.0/2;	/* Largest Army bullet */

	/* This sets the space partitioning algorithm to Mike's original
	 * non-uniform binary space paritioning tree.
	 * If you change this to anything else, you must also modify
	 * "rt_find_backing_dist()" (in shoot.c), to handle the different
	 * alogorithm            -JRA
	 */
	rtip->rti_space_partition = RT_PART_NUBSPT;

	rtip->rti_nugrid_dimlimit = 0;
	rtip->rti_nu_gfactor = RT_NU_GFACTOR_DEFAULT;

	/*
	 *  Zero the solid instancing counters in dbip database instance.
	 *  Done here because the same dbip could be used by multiple
	 *  rti's, and rt_gettrees() can be called multiple times on
	 *  this one rtip.
	 *  There is a race (collision!) here on d_uses if rt_gettrees()
	 *  is called on another rtip of the same dbip
	 *  before this rtip is done
	 *  with all it's treewalking.
	 */
	for( i=0; i < RT_DBNHASH; i++ )  {
		register struct directory	*dp;

		dp = rtip->rti_dbip->dbi_Head[i];
		for( ; dp != DIR_NULL; dp = dp->d_forw )
			dp->d_uses = 0;
	}

	return rtip;
}

/*
 *			R T _ F R E E _ R T I
 *
 *  Release all the dynamic storage acquired by rt_dirbuild() and
 *  any subsequent ray-tracing operations.
 *
 *  Any PARALLEL resource structures are freed by rt_clean().
 *  Note that the rt_g structure needs to be cleaned separately.
 */
void
rt_free_rti(struct rt_i *rtip)
{
	RT_CK_RTI(rtip);

	rt_clean( rtip );

#if 0
	/* XXX These can't be freed here either, because we allocated
	 * them all on rt_uniresource, which doesn't discriminate
	 * on which db_i they go with.
	 */

	/* The 'struct directory' guys are malloc()ed in big blocks */
	resp->re_directory_hd = NULL;	/* abandon list */
	if( BU_LIST_IS_INITIALIZED( &resp->re_directory_blocks.l ) )  {
		struct directory **dpp;
		BU_CK_PTBL( &resp->re_directory_blocks );
		for( BU_PTBL_FOR( dpp, (struct directory **), &resp->re_directory_blocks ) )  {
			RT_CK_DIR(*dpp);	/* Head of block will be a valid seg */
			bu_free( (genptr_t)(*dpp), "struct directory block" );
		}
		bu_ptbl_free( &resp->re_directory_blocks );
	}
#endif

	db_close_client( rtip->rti_dbip, (long *)rtip );
	rtip->rti_dbip = (struct db_i *)NULL;

	/* Freeing the actual resource structures's memory is the app's job */
	bu_ptbl_free( &rtip->rti_resources );

	bu_free( (char *)rtip, "struct rt_i" );
}

/*
 *  			R T _ P R E P _ P A R A L L E L
 *  
 *  This routine should be called just before the first call to rt_shootray().
 *  It should only be called ONCE per execution, unless rt_clean() is
 *  called inbetween.
 *
 *  Because this can be called from rt_shootray(), it may potentially be
 *  called ncpu times, hence the critical section.
 */
void
rt_prep_parallel(register struct rt_i *rtip, int ncpu)
{
	register struct region *regp;
	register struct soltab *stp;
	register int		i;
	struct resource		*resp;
	vect_t			diag;

	RT_CK_RTI(rtip);

	if(RT_G_DEBUG&DEBUG_REGIONS)  bu_log("rt_prep_parallel(%s,%d,ncpu=%d) START\n",
			rtip->rti_dbip->dbi_filename,
			rtip->rti_dbip->dbi_uses, ncpu);

	bu_semaphore_acquire(RT_SEM_RESULTS);	/* start critical section */
	if(!rtip->needprep)  {
		bu_log("WARNING: rt_prep_parallel(%s,%d) invoked a second time, ignored",
			rtip->rti_dbip->dbi_filename,
			rtip->rti_dbip->dbi_uses);
		bu_semaphore_release(RT_SEM_RESULTS);
		return;
	}

	if( rtip->nsolids <= 0 )  {
		if( rtip->rti_air_discards > 0 )
			bu_log("rt_prep_parallel(%s,%d): %d primitives discarded due to air regions\n",
				rtip->rti_dbip->dbi_filename,
				rtip->rti_dbip->dbi_uses,
				rtip->rti_air_discards );
		rt_bomb("rt_prep_parallel:  no primitives left to prep");
	}

	/* In case everything is a halfspace, set a minimum space */
	if( rtip->mdl_min[X] >= INFINITY )  {
		bu_log("All primitives are halfspaces, setting minimum\n");
		VSETALL( rtip->mdl_min, -1 );
	}
	if( rtip->mdl_max[X] <= -INFINITY )  {
		bu_log("All primitives are halfspaces, setting maximum\n");
		VSETALL( rtip->mdl_max, 1 );
	}

	/*
	 *  Enlarge the model RPP just slightly, to avoid nasty
	 *  effects with a solid's face being exactly on the edge
	 */
	rtip->mdl_min[X] = floor( rtip->mdl_min[X] );
	rtip->mdl_min[Y] = floor( rtip->mdl_min[Y] );
	rtip->mdl_min[Z] = floor( rtip->mdl_min[Z] );
	rtip->mdl_max[X] = ceil( rtip->mdl_max[X] );
	rtip->mdl_max[Y] = ceil( rtip->mdl_max[Y] );
	rtip->mdl_max[Z] = ceil( rtip->mdl_max[Z] );

	/* Compute radius of a model bounding sphere */
	VSUB2( diag, rtip->mdl_max, rtip->mdl_min );
	rtip->rti_radius = 0.5 * MAGNITUDE(diag);

	/*  If a resource structure has been provided for us, use it. */
	resp = (struct resource *)BU_PTBL_GET(&rtip->rti_resources, 0);
	if( !resp )  resp = &rt_uniresource;
	RT_CK_RESOURCE(resp);

	/*  Build array of region pointers indexed by reg_bit.
	 *  Optimize each region's expression tree.
	 *  Set this region's bit in the bit vector of every solid
	 *  contained in the subtree.
	 */
	rtip->Regions = (struct region **)bu_calloc(
		rtip->nregions, sizeof(struct region *),
		"rtip->Regions[]" );
	if(RT_G_DEBUG&DEBUG_REGIONS)  bu_log("rt_prep_parallel(%s,%d) about to optimize regions\n",
			rtip->rti_dbip->dbi_filename,
			rtip->rti_dbip->dbi_uses);
	for( BU_LIST_FOR( regp, region, &(rtip->HeadRegion) ) )  {
		/* Ensure bit numbers are unique */
		BU_ASSERT_PTR(rtip->Regions[regp->reg_bit], ==, REGION_NULL);
		rtip->Regions[regp->reg_bit] = regp;
		rt_optim_tree( regp->reg_treetop, resp );
		rt_solid_bitfinder( regp->reg_treetop, regp, resp );
		if(RT_G_DEBUG&DEBUG_REGIONS)  {
			db_ck_tree( regp->reg_treetop);
			rt_pr_region( regp );
		}
	}
	if(RT_G_DEBUG&DEBUG_REGIONS)  {
		bu_log("rt_prep_parallel() printing primitives' region pointers\n");
		RT_VISIT_ALL_SOLTABS_START( stp, rtip )  {
			bu_log("solid %s ", stp->st_name);
			bu_pr_ptbl( "st_regions", &stp->st_regions, 1 );
		} RT_VISIT_ALL_SOLTABS_END
	}

	/*  Space for array of soltab pointers indexed by solid bit number.
	 *  Include enough extra space for an extra bitv_t's worth of bits,
	 *  to handle round-up.
	 */
	rtip->rti_Solids = (struct soltab **)bu_calloc(
		rtip->nsolids + (1<<BITV_SHIFT), sizeof(struct soltab *),
		"rtip->rti_Solids[]" );
	/*
	 *  Build array of solid table pointers indexed by solid ID.
	 *  Last element for each kind will be found in
	 *	rti_sol_by_type[id][rti_nsol_by_type[id]-1]
	 */
	RT_VISIT_ALL_SOLTABS_START( stp, rtip )  {
		/* Ensure bit numbers are unique */
		register struct soltab **ssp = &rtip->rti_Solids[stp->st_bit];
		if( *ssp != SOLTAB_NULL )  {
			bu_log("rti_Solids[%d] is non-empty! rtip=x%x\n", stp->st_bit, rtip);
			bu_log("Existing entry is (st_rtip=x%x):\n", (*ssp)->st_rtip);
			rt_pr_soltab(*ssp);
			bu_log("2nd soltab also claiming that bit is (st_rtip=x%x):\n", stp->st_rtip);
			rt_pr_soltab(stp);
		}
		BU_ASSERT_PTR(*ssp, ==, SOLTAB_NULL);
		*ssp = stp;
		rtip->rti_nsol_by_type[stp->st_id]++;
	} RT_VISIT_ALL_SOLTABS_END

	/* Find solid type with maximum length (for rt_shootray) */
	rtip->rti_maxsol_by_type = 0;
	for( i=0; i <= ID_MAX_SOLID; i++ )  {
		if( rtip->rti_nsol_by_type[i] > rtip->rti_maxsol_by_type )
			rtip->rti_maxsol_by_type = rtip->rti_nsol_by_type[i];
	}
	/* Malloc the storage and zero the counts */
	for( i=0; i <= ID_MAX_SOLID; i++ )  {
		if( rtip->rti_nsol_by_type[i] <= 0 )  continue;
		rtip->rti_sol_by_type[i] = (struct soltab **)bu_calloc(
			rtip->rti_nsol_by_type[i],
			sizeof(struct soltab *),
			"rti_sol_by_type[]" );
		rtip->rti_nsol_by_type[i] = 0;
	}
	/* Fill in the array and rebuild the count (aka index) */
	RT_VISIT_ALL_SOLTABS_START( stp, rtip )  {
		register int	id;
		id = stp->st_id;
		rtip->rti_sol_by_type[id][rtip->rti_nsol_by_type[id]++] = stp;
	} RT_VISIT_ALL_SOLTABS_END
	if( RT_G_DEBUG & (DEBUG_DB|DEBUG_SOLIDS) )  {
		bu_log("rt_prep_parallel(%s,%d) printing number of prims by type\n",
			rtip->rti_dbip->dbi_filename,
			rtip->rti_dbip->dbi_uses);
		for( i=1; i <= ID_MAX_SOLID; i++ )  {
			bu_log("%5d %s (%d)\n",
				rtip->rti_nsol_by_type[i],
				rt_functab[i].ft_name,
				i );
		}
	}

	/* If region-id expression file exists, process it */
	rt_regionfix(rtip);
	
	/* For plotting, compute a slight enlargement of the model RPP,
	 * to allow room for rays clipped to the model RPP to be depicted.
	 * Always do this, because application debugging may use it too.
	 */
	{
		register fastf_t f, diff;

		diff = (rtip->mdl_max[X] - rtip->mdl_min[X]);
		f = (rtip->mdl_max[Y] - rtip->mdl_min[Y]);
		if( f > diff )  diff = f;
		f = (rtip->mdl_max[Z] - rtip->mdl_min[Z]);
		if( f > diff )  diff = f;
		diff *= 0.1;	/* 10% expansion of box */
		rtip->rti_pmin[0] = rtip->mdl_min[0] - diff;
		rtip->rti_pmin[1] = rtip->mdl_min[1] - diff;
		rtip->rti_pmin[2] = rtip->mdl_min[2] - diff;
		rtip->rti_pmax[0] = rtip->mdl_max[0] + diff;
		rtip->rti_pmax[1] = rtip->mdl_max[1] + diff;
		rtip->rti_pmax[2] = rtip->mdl_max[2] + diff;
	}

	/*
	 *	Partition space
	 *
	 *  Multiple CPUs can be used here.
	 */
	for( i=1; i<=CUT_MAXIMUM; i++ ) rtip->rti_ncut_by_type[i] = 0;
	rt_cut_it(rtip, ncpu);

	/* Release storage used for bounding RPPs of solid "pieces" */
	RT_VISIT_ALL_SOLTABS_START( stp, rtip )  {
		if( stp->st_piece_rpps )  {
			bu_free( (char *)stp->st_piece_rpps, "st_piece_rpps[]" );
			stp->st_piece_rpps = NULL;
		}
	} RT_VISIT_ALL_SOLTABS_END

	/* Plot bounding RPPs */
	if( (RT_G_DEBUG&DEBUG_PLOTBOX) )  {
		FILE	*plotfp;

		if( (plotfp=fopen("rtrpp.plot", "w"))!=NULL) {
			/* Plot solid bounding boxes, in white */
			pl_color( plotfp, 255, 255, 255 );
			rt_plot_all_bboxes( plotfp, rtip );
			(void)fclose(plotfp);
		}
	}

	/* Plot solid outlines */
	if( (RT_G_DEBUG&DEBUG_PLOTSOLIDS) )  {
		FILE		*plotfp;

		if( (plotfp=fopen("rtsolids.pl", "w")) != NULL)  {
			rt_plot_all_solids( plotfp, rtip, resp );
			(void)fclose(plotfp);
		}
	}
	rtip->needprep = 0;		/* prep is done */
	bu_semaphore_release(RT_SEM_RESULTS);	/* end critical section */

	if(RT_G_DEBUG&DEBUG_REGIONS)  bu_log("rt_prep_parallel(%s,%d,ncpu=%d) FINISH\n",
			rtip->rti_dbip->dbi_filename,
			rtip->rti_dbip->dbi_uses, ncpu);
}

/*
 *			R T _ P R E P
 *
 *  Compatability stub.  Only uses 1 CPU.
 */
void
rt_prep(register struct rt_i *rtip)
{
	RT_CK_RTI(rtip);
	rt_prep_parallel(rtip, 1);
}

/*
 *			R T _ P L O T _ A L L _ B B O X E S
 *
 *  Plot the bounding boxes of all the active solids.
 *  Color may be set in advance by the caller.
 */
void
rt_plot_all_bboxes(FILE *fp, struct rt_i *rtip)
{
	register struct soltab	*stp;

	RT_CK_RTI(rtip);
	pdv_3space( fp, rtip->rti_pmin, rtip->rti_pmax );
	RT_VISIT_ALL_SOLTABS_START( stp, rtip )  {
		/* Ignore "dead" solids in the list.  (They failed prep) */
		if( stp->st_aradius <= 0 )  continue;
		/* Don't draw infinite solids */
		if( stp->st_aradius >= INFINITY )
			continue;
		pdv_3box( fp, stp->st_min, stp->st_max );
	} RT_VISIT_ALL_SOLTABS_END
}

/*
 *			R T _ P L O T _ A L L _ S O L I D S
 */
void
rt_plot_all_solids(
	FILE		*fp,
	struct rt_i	*rtip,
	struct resource	*resp)
{
	register struct soltab	*stp;

	RT_CK_RTI(rtip);

	pdv_3space( fp, rtip->rti_pmin, rtip->rti_pmax );

	RT_VISIT_ALL_SOLTABS_START( stp, rtip )  {
		/* Ignore "dead" solids in the list.  (They failed prep) */
		if( stp->st_aradius <= 0 )  continue;

		/* Don't draw infinite solids */
		if( stp->st_aradius >= INFINITY )
			continue;

		(void)rt_plot_solid( fp, rtip, stp, resp );
	} RT_VISIT_ALL_SOLTABS_END
}

/*
 *			R T _ V L I S T _ S O L I D
 *
 *  "Draw" a solid with the same kind of wireframes that MGED would display,
 *  appending vectors to an already initialized vlist head.
 *
 *  Returns -
 *	<0	failure
 *	 0	OK
 */
int
rt_vlist_solid(
	struct bu_list		*vhead,
	struct rt_i		*rtip,
	const struct soltab	*stp,
	struct resource		*resp)
{
	struct rt_db_internal		intern;

	if( rt_db_get_internal( &intern, stp->st_dp, rtip->rti_dbip, stp->st_matp, resp ) < 0 )  {
		bu_log("rt_vlist_solid(%s): rt_db_get_internal() failed\n",
			stp->st_name);
		return(-1);			/* FAIL */
	}
	RT_CK_DB_INTERNAL( &intern );

	if( rt_functab[intern.idb_type].ft_plot(
		vhead,
		&intern,
		&rtip->rti_ttol,
		&rtip->rti_tol
	    ) < 0 )  {
		bu_log("rt_vlist_solid(%s): ft_plot() failure\n",
			stp->st_name);
		rt_db_free_internal( &intern, resp );
	    	return(-2);
	}
	rt_db_free_internal( &intern, resp );
	return 0;
}

/*
 *			R T _ P L O T _ S O L I D
 *
 *  Plot a solid with the same kind of wireframes that MGED would display,
 *  in UNIX-plot form, on the indicated file descriptor.
 *  The caller is responsible for calling pdv_3space().
 *
 *  Returns -
 *	<0	failure
 *	 0	OK
 */
int
rt_plot_solid(
	register FILE		*fp,
	struct rt_i		*rtip,
	const struct soltab	*stp,
	struct resource		*resp)
{
	struct bu_list			vhead;
	struct region			*regp;

	RT_CK_RTI(rtip);
	RT_CK_SOLTAB(stp);

	BU_LIST_INIT( &vhead );

	if( rt_vlist_solid( &vhead, rtip, stp, resp ) < 0 )  {
		bu_log("rt_plot_solid(%s): rt_vlist_solid() failed\n",
			stp->st_name);
		return(-1);			/* FAIL */
	}

	if( BU_LIST_IS_EMPTY( &vhead ) )  {
		bu_log("rt_plot_solid(%s): no vectors to plot?\n",
			stp->st_name);
		return(-3);		/* FAIL */
	}

	/* Take color from one region */
	if( (regp = (struct region *)BU_PTBL_GET(&stp->st_regions,0)) != REGION_NULL )  {
		pl_color( fp,
			(int)(255*regp->reg_mater.ma_color[0]),
			(int)(255*regp->reg_mater.ma_color[1]),
			(int)(255*regp->reg_mater.ma_color[2]) );
	}

	rt_vlist_to_uplot( fp, &vhead );

	RT_FREE_VLIST( &vhead );
	return(0);			/* OK */
}

/*			R T _ I N I T _ R E S O U R C E
 *
 *  initialize memory resources.
 *	This routine should initialize all the same resources
 *	that rt_clean_resource() releases.
 *	It shouldn't allocate any dynamic memory, just init pointers & lists.
 *
 *  if( BU_LIST_UNINITIALIZED( &resp->re_parthead ) )
 *  indicates that this initialization is needed.
 *
 *  Note that this routine is also called as part of rt_clean_resource().
 *
 *  Special case, resp == rt_uniresource, rtip may be NULL (but give it if you have it).
 */
void
rt_init_resource(
	struct resource *resp,
	int		cpu_num,
	struct rt_i	*rtip)
{

	if( resp == &rt_uniresource )  {
		cpu_num = MAX_PSW;		/* array is [MAX_PSW+1] just for this */
		if(rtip)  RT_CK_RTI(rtip);	/* check it if provided */
	} else {
		BU_ASSERT_PTR( resp, !=, NULL );
		BU_ASSERT_LONG( cpu_num, >=, 0 );
		if( rtip->rti_treetop ) {
			/* this is a submodel */
			BU_ASSERT_LONG( cpu_num, <, rtip->rti_resources.blen );
		} else {
			BU_ASSERT_LONG( cpu_num, <, MAX_PSW );
		}
		RT_CK_RTI(rtip);		/* mandatory */
	}

	resp->re_magic = RESOURCE_MAGIC;
	resp->re_cpu = cpu_num;

	/* XXX resp->re_randptr is an "application" (rt) level field. For now. */

	if( BU_LIST_UNINITIALIZED( &resp->re_seg ) )
		BU_LIST_INIT( &resp->re_seg )

	if( BU_LIST_UNINITIALIZED( &resp->re_seg_blocks.l ) )
		bu_ptbl_init( &resp->re_seg_blocks, 64, "re_seg_blocks ptbl" );

	if( BU_LIST_UNINITIALIZED( &resp->re_directory_blocks.l ) )
		bu_ptbl_init( &resp->re_directory_blocks, 64, "re_directory_blocks ptbl" );

	if( BU_LIST_UNINITIALIZED( &resp->re_parthead ) )
		BU_LIST_INIT( &resp->re_parthead )

	if( BU_LIST_UNINITIALIZED( &resp->re_solid_bitv ) )
		BU_LIST_INIT( &resp->re_solid_bitv )

	if( BU_LIST_UNINITIALIZED( &resp->re_region_ptbl ) )
		BU_LIST_INIT( &resp->re_region_ptbl )

	if( BU_LIST_UNINITIALIZED( &resp->re_nmgfree ) )
		BU_LIST_INIT( &resp->re_nmgfree )

	resp->re_boolstack = NULL;
	resp->re_boolslen = 0;

	if( rtip == NULL )  return;	/* only in rt_uniresource case */

	/* Ensure that this CPU's resource structure is registered in rt_i */
	/* It may already be there when we're called from rt_clean_resource */
	{
		struct resource	*ores = (struct resource *)
			BU_PTBL_GET(&rtip->rti_resources, cpu_num);
		if( ores != NULL && ores != resp )  {
			bu_log("rt_init_resource(cpu=%d) re-registering resource, had x%x, new=x%x\n",
				cpu_num,
				ores,
				resp );
			bu_bomb("rt_init_resource() re-registration\n");
		}
		BU_PTBL_SET(&rtip->rti_resources, cpu_num, resp);
	}
}

/*
 *			R T _ C L E A N _ R E S O U R C E
 *
 *  Deallocate the per-cpu "private" memory resources.
 *	segment freelist
 *	hitmiss freelist for NMG raytracer
 *	partition freelist
 *	solid_bitv freelist
 *	region_ptbl freelist
 *	re_boolstack
 *
 *  Some care is required, as rt_uniresource may not be fully initialized
 *  before it gets freed.
 *
 *  Note that the resource struct's storage is not freed (it may be static
 *  or otherwise allocated by a LIBRT application) but any dynamic
 *  memory pointed to by it is freed.
 *
 *  One exception to this is that the re_directory_hd and re_directory_blocks
 *  are not touched, because the "directory" structures (which are really
 *  part of the db_i) continue to be in use.
 */
void
rt_clean_resource(struct rt_i *rtip, struct resource *resp)
{
	RT_CK_RTI(rtip);
	RT_CK_RESOURCE(resp);

	/*  The 'struct seg' guys are malloc()ed in blocks, not individually,
	 *  so they're kept track of two different ways.
	 */
	BU_LIST_INIT( &resp->re_seg );	/* abandon the list of individuals */
	if( BU_LIST_IS_INITIALIZED( &resp->re_seg_blocks.l ) )  {
		struct seg **spp;
		BU_CK_PTBL( &resp->re_seg_blocks );
		for( BU_PTBL_FOR( spp, (struct seg **), &resp->re_seg_blocks ) )  {
			RT_CK_SEG(*spp);	/* Head of block will be a valid seg */
			bu_free( (genptr_t)(*spp), "struct seg block" );
		}
		bu_ptbl_free( &resp->re_seg_blocks );
	}

	/*
	 *  The 'struct directory' guys are malloc()ed in big blocks,
	 *  but CAN'T BE FREED HERE!  We are not done with the db_i yet.
	 */

	/* The "struct hitmiss' guys are individually malloc()ed */
	if( BU_LIST_IS_INITIALIZED( &resp->re_nmgfree ) )  {
		struct hitmiss *hitp;
		while( BU_LIST_WHILE( hitp, hitmiss, &resp->re_nmgfree ) )  {
			NMG_CK_HITMISS(hitp);
			BU_LIST_DEQUEUE( (struct bu_list *)hitp );
			bu_free( (genptr_t)hitp, "struct hitmiss" );
		}
	}

	/* The 'struct partition' guys are individually malloc()ed */
	if( BU_LIST_IS_INITIALIZED( &resp->re_parthead ) )  {
		struct partition *pp;
		while( BU_LIST_WHILE( pp, partition, &resp->re_parthead ) )  {
			RT_CK_PT(pp);
			BU_LIST_DEQUEUE( (struct bu_list *)pp );
			bu_ptbl_free( &pp->pt_seglist );
			bu_free( (genptr_t)pp, "struct partition" );
		}
	}

	/* The 'struct bu_bitv' guys on re_solid_bitv are individually malloc()ed */
	if( BU_LIST_IS_INITIALIZED( &resp->re_solid_bitv ) )  {
		struct bu_bitv	*bvp;
		while( BU_LIST_WHILE( bvp, bu_bitv, &resp->re_solid_bitv ) )  {
			BU_CK_BITV( bvp );
			BU_LIST_DEQUEUE( &bvp->l );
			bvp->nbits = 0;		/* sanity */
			bu_free( (genptr_t)bvp, "struct bu_bitv" );
		}
	}

	/* The 'struct bu_ptbl' guys on re_region_ptbl are individually malloc()ed */
	if( BU_LIST_IS_INITIALIZED( &resp->re_region_ptbl ) )  {
		struct bu_ptbl	*tabp;
		while( BU_LIST_WHILE( tabp, bu_ptbl, &resp->re_region_ptbl ) )  {
			BU_CK_PTBL(tabp);
			BU_LIST_DEQUEUE( &tabp->l );
			bu_ptbl_free( tabp );
			bu_free( (genptr_t)tabp, "struct bu_ptbl" );
		}
	}

	/* The 're_tree' guys are individually malloc()ed and linked using the 'tb_left' field */
	if( resp->re_tree_hd != TREE_NULL ) {
		union tree *tp;

		tp = resp->re_tree_hd;
		while( tp != TREE_NULL ) {
			resp->re_tree_hd = tp->tr_b.tb_left;
			bu_free( (char *)tp, "union tree in resource struct" );
			tp = resp->re_tree_hd;
		}
	}

	/* 're_boolstack' is a simple pointer */
	if( resp->re_boolstack )  {
		bu_free( (genptr_t)resp->re_boolstack, "boolstack" );
		resp->re_boolstack = NULL;
		resp->re_boolslen = 0;
	}

/* Release the state variables for 'solid pieces' */
	rt_res_pieces_clean( resp, rtip );

	/* Reinitialize pointers, to be tidy.  No storage is allocated. */
	rt_init_resource( resp, resp->re_cpu, rtip );
}

struct bu_bitv *
get_solidbitv( long nbits, struct resource *resp )
{
	struct bu_bitv *solidbits;
	int counter=0;

	if( resp->re_solid_bitv.magic != BU_LIST_HEAD_MAGIC ) {
		bu_bomb( "Bad magic number in re_solid_btiv list\n" );
	}

	if( BU_LIST_IS_EMPTY( &resp->re_solid_bitv ) )  {
		solidbits = bu_bitv_new( nbits );
	} else {
		for( BU_LIST_FOR( solidbits, bu_bitv, &resp->re_solid_bitv ) ) {
			if( solidbits->nbits >= nbits ) {
				BU_LIST_DEQUEUE( &solidbits->l );
				BU_CK_BITV(solidbits);
				break;
			}
			counter++;
		}
		if( solidbits == (struct bu_bitv *)&resp->re_solid_bitv ) {
			solidbits = bu_bitv_new( nbits );
		}
	}

	return( solidbits );
}

/*
 *			R T _ C L E A N
 *
 *  Release all the dynamic storage associated with a particular rt_i
 *  structure, except for the database instance information (dir, etc)
 *  and the rti_resources ptbl.
 *
 *  Note that an animation script can invoke a "clean" operation before
 *  anything has been prepped.
 */
void
rt_clean(register struct rt_i *rtip)
{
	register struct region *regp;
	register struct bu_list	*head;
	register struct soltab *stp;
	int	i;

	RT_CK_RTI(rtip);

	/* DEBUG: Ensure that all region trees are valid */
	for( BU_LIST_FOR( regp, region, &(rtip->HeadRegion) ) )  {
		RT_CK_REGION(regp);
		db_ck_tree( regp->reg_treetop );
	}
	/*  
	 *  Clear out the region table
	 *  db_free_tree() will delete most soltab structures.
	 */
	while( BU_LIST_WHILE( regp, region, &rtip->HeadRegion ) )  {
		RT_CK_REGION(regp);
		BU_LIST_DEQUEUE(&(regp->l));
		db_free_tree( regp->reg_treetop, &rt_uniresource );
		bu_free( (genptr_t)regp->reg_name, "region name str");
		regp->reg_name = (char *)0;
		if( regp->reg_mater.ma_shader )
		{
			bu_free( (genptr_t)regp->reg_mater.ma_shader, "ma_shader" );
			regp->reg_mater.ma_shader = (char *)NULL;
		}
		if( regp->attr_values ) {
			i = 0;
			while( regp->attr_values[i] ) {
				bu_mro_free( regp->attr_values[i] );
				i++;
			}
			bu_free( (char *)regp->attr_values, "regp->attr_values" );
		}
		bu_free( (genptr_t)regp, "struct region");
	}
	rtip->nregions = 0;

	/*
	 *  Clear out the solid table, AFTER doing the region table.
	 *  Can't use RT_VISIT_ALL_SOLTABS_START here
	 */
	head = &(rtip->rti_solidheads[0]);
	for( ; head < &(rtip->rti_solidheads[RT_DBNHASH]); head++ )  {
		while( BU_LIST_WHILE( stp, soltab, head ) )  {
			RT_CHECK_SOLTAB(stp);
			rt_free_soltab(stp);
		}
	}
	rtip->nsolids = 0;

	/* Clean out the array of pointers to regions, if any */
	if( rtip->Regions )  {
		bu_free( (char *)rtip->Regions, "rtip->Regions[]" );
		rtip->Regions = (struct region **)0;

		/* Free space partitions */
		rt_fr_cut( rtip, &(rtip->rti_CutHead) );
		bzero( (char *)&(rtip->rti_CutHead), sizeof(union cutter) );
		rt_fr_cut( rtip, &(rtip->rti_inf_box) );
		bzero( (char *)&(rtip->rti_inf_box), sizeof(union cutter) );
	}
	rt_cut_clean(rtip);

	/* Free animation structures */
/* XXX modify to only free those from this rtip */
	db_free_anim(rtip->rti_dbip);

	/* Free array of solid table pointers indexed by solid ID */
	for( i=0; i <= ID_MAX_SOLID; i++ )  {
		if( rtip->rti_nsol_by_type[i] <= 0 )  continue;
		bu_free( (char *)rtip->rti_sol_by_type[i], "sol_by_type" );
		rtip->rti_sol_by_type[i] = (struct soltab **)0;
	}
	if( rtip->rti_Solids )  {
		bu_free( (char *)rtip->rti_Solids, "rtip->rti_Solids[]" );
		rtip->rti_Solids = (struct soltab **)0;
	}

	/*
	 *  Clean out every cpu's "struct resource".
	 *  These are provided by the caller's application (or are
	 *  defaulted to rt_uniresource) and can't themselves be freed.
	 *  rt_shootray() saved a table of them for us to use here.
	 *  rt_uniresource may or may not be in this table.
 	 */
	if( BU_LIST_MAGIC_OK(&rtip->rti_resources.l, BU_PTBL_MAGIC ) )  {
		struct resource	**rpp;
		BU_CK_PTBL( &rtip->rti_resources );
		for( BU_PTBL_FOR( rpp, (struct resource **), &rtip->rti_resources ) )  {
			/* After using a submodel, some entries may be NULL
			 * while others are not NULL
			 */
			if( *rpp == NULL )  continue;
			RT_CK_RESOURCE(*rpp);
			/* Clean but do not free the resource struct */
			rt_clean_resource(rtip, *rpp);
#if 0
/* XXX Can't do this, or 'clean' command in RT animation script will dump core. */
/* rt expects them to stay inited and remembered, forever. */
/* Submodels will clean up after themselves */
			/* Forget remembered ptr, but keep ptbl allocated */
			*rpp = NULL;
#endif
		}
	}

	if( rtip->Orca_hash_tbl ) {
		bu_free( (char *)rtip->Orca_hash_tbl, "rtip->Orca_hash_tbl" );
		rtip->Orca_hash_tbl = NULL;
	}
	if( rt_uniresource.re_magic )  {
		rt_clean_resource(rtip, &rt_uniresource );/* Used for rt_optim_tree() */
	}

	/*
	 *  Re-initialize everything important.
	 *  This duplicates the code in rt_new_rti().
	 */

	rtip->rti_inf_box.bn.bn_type = CUT_BOXNODE;
	VMOVE( rtip->rti_inf_box.bn.bn_min, rtip->mdl_min );
	VMOVE( rtip->rti_inf_box.bn.bn_max, rtip->mdl_max );
	VSETALL( rtip->mdl_min,  INFINITY );
	VSETALL( rtip->mdl_max, -INFINITY );

	bu_hist_free( &rtip->rti_hist_cellsize );
	bu_hist_free( &rtip->rti_hist_cutdepth );

	/*
	 *  Zero the solid instancing counters in dbip database instance.
	 *  Done here because the same dbip could be used by multiple
	 *  rti's, and rt_gettrees() can be called multiple times on
	 *  this one rtip.
	 *  There is a race (collision!) here on d_uses if rt_gettrees()
	 *  is called on another rtip of the same dbip
	 *  before this rtip is done
	 *  with all it's treewalking.
	 *
	 *  This must be done for each 'clean' to keep
	 *  rt_find_identical_solid() working properly as d_uses goes up.
	 */
	for( i=0; i < RT_DBNHASH; i++ )  {
		register struct directory	*dp;

		dp = rtip->rti_dbip->dbi_Head[i];
		for( ; dp != DIR_NULL; dp = dp->d_forw )
			dp->d_uses = 0;
	}

	bu_ptbl_reset( &rtip->delete_regs );

	rtip->rti_magic = RTI_MAGIC;
	rtip->needprep = 1;
}

/*
 *			R T _ D E L _ R E G T R E E
 *
 *  Remove a region from the linked list.  Used to remove a particular
 *  region from the active database, presumably after some useful
 *  information has been extracted (eg, a light being converted to
 *  implicit type), or for special effects.
 *
 *  Returns -
 *	 0	success
 */
int
rt_del_regtree( struct rt_i *rtip, register struct region *delregp, struct resource *resp )
{
	RT_CK_RESOURCE(resp);

	if( RT_G_DEBUG & DEBUG_REGIONS )
		bu_log("rt_del_regtree(%s): region deleted\n", delregp->reg_name);

	BU_LIST_DEQUEUE(&(delregp->l));

	db_free_tree( delregp->reg_treetop, resp );
	delregp->reg_treetop = TREE_NULL;
	bu_free( (char *)delregp->reg_name, "region name str");
	delregp->reg_name = (char *)0;
	if( delregp->attr_values ) {
		int i=0;
		while( delregp->attr_values[i] ) {
			bu_mro_free( delregp->attr_values[i] );
			i++;
		}
		bu_free( (char *)delregp->attr_values, "delregp->attr_values" );
	}
	bu_free( (char *)delregp, "struct region");
	return(0);
}

/*
 *  			S O L I D _ B I T F I N D E R
 *  
 *  Used to walk the boolean tree, setting bits for all the solids in the tree
 *  to the provided bit vector.  Should be called AFTER the region bits
 *  have been assigned.
 */
HIDDEN void
rt_solid_bitfinder(register union tree *treep, struct region *regp, struct resource *resp)
{
	register union tree	**sp;
	register struct soltab	*stp;
	register union tree	**stackend;

	RT_CK_REGION(regp);
	RT_CK_RESOURCE(resp);

	while( (sp = resp->re_boolstack) == (union tree **)0 )
		rt_grow_boolstack( resp );
	stackend = &(resp->re_boolstack[resp->re_boolslen-1]);

	*sp++ = TREE_NULL;
	*sp++ = treep;
	while( (treep = *--sp) != TREE_NULL ) {
		RT_CK_TREE(treep);
		switch( treep->tr_op )  {
		case OP_NOP:
			break;
		case OP_SOLID:
			stp = treep->tr_a.tu_stp;
			RT_CK_SOLTAB(stp);
			bu_ptbl_ins( &stp->st_regions, (long *)regp );
			break;
		case OP_UNION:
		case OP_INTERSECT:
		case OP_SUBTRACT:
			/* BINARY type */
			/* push both nodes - search left first */
			*sp++ = treep->tr_b.tb_right;
			*sp++ = treep->tr_b.tb_left;
			if( sp >= stackend )  {
				register int off = sp - resp->re_boolstack;
				rt_grow_boolstack( resp );
				sp = &(resp->re_boolstack[off]);
				stackend = &(resp->re_boolstack[resp->re_boolslen-1]);
			}
			break;
		default:
			bu_log("rt_solid_bitfinder:  op=x%x\n", treep->tr_op);
			break;
		}
	}
}

/*
 *			R T _ C K
 *
 *  Check as many of the in-memory data structures as is practical.
 *  Useful for detecting memory corruption, and inappropriate sharing
 *  between different LIBRT instances.
 */
void
rt_ck(register struct rt_i *rtip)
{
	struct region		*regp;
	struct soltab		*stp;

	RT_CK_RTI(rtip);
	RT_CK_DBI(rtip->rti_dbip);

	db_ck_directory(rtip->rti_dbip);

	RT_VISIT_ALL_SOLTABS_START( stp, rtip )  {
		RT_CK_SOLTAB(stp);
	} RT_VISIT_ALL_SOLTABS_END

	for( BU_LIST_FOR( regp, region, &(rtip->HeadRegion) ) )  {
		RT_CK_REGION(regp);
		db_ck_tree(regp->reg_treetop);
	}
	/* rti_CutHead */

}

/*
 *		R T _ L O A D _ A T T R S
 *
 *	Loads a new set of attribute values (corresponding to the provided list of attribute
 *	names) for each region structure in the provided rtip.
 *
 *	RETURNS
 *		The number of region structures affected
 */

int rt_load_attrs( struct rt_i *rtip, char **attrs )
{
	struct region *regp;
	struct bu_attribute_value_set avs;
	struct directory *dp;
	const char *reg_name;
	const char *attr;
	int attr_count=0;
	int mro_count;
	int did_set;
	int region_count=0;
	int i;

	RT_CHECK_RTI(rtip);
	RT_CK_DBI(rtip->rti_dbip);

	if( rtip->rti_dbip->dbi_version < 5 )
		return 0;

	while( attrs[attr_count] )
		attr_count++;

	for( BU_LIST_FOR( regp, region, &(rtip->HeadRegion) ) )  {
		RT_CK_REGION(regp);

		did_set = 0;
		mro_count = 0;
		while( regp->attr_values[mro_count] )
			mro_count++;

		if( mro_count < attr_count ) {
			/* don't have enough to store all the values */
			for( i=0 ; i<mro_count ; i++ ) {
				bu_mro_free( regp->attr_values[i] );
				bu_free( (char *)regp->attr_values[i], "regp->attr_values[i]" );
			}
			if( mro_count )
				bu_free( (char *)regp->attr_values, "regp->attr_values" );
			regp->attr_values = (struct bu_mro **)bu_calloc( attr_count + 1,
						 sizeof( struct bu_mro *), "regp->attr_values" );
			for( i=0 ; i<attr_count ; i++ ) {
				regp->attr_values[i] = bu_malloc( sizeof( struct bu_mro ),
							"regpp->attr_values[i]" );
				bu_mro_init( regp->attr_values[i] );
			}
		} else if ( mro_count > attr_count ) {
			/* just reuse what we have */
			for( i=attr_count ; i<mro_count ; i++ ) {
				bu_mro_free( regp->attr_values[i] );
				bu_free( (char *)regp->attr_values[i], "regp->attr_values[i]" );
			}
			regp->attr_values[attr_count] = (struct bu_mro *)NULL;
		}

		if( (reg_name=strrchr( regp->reg_name, '/' ) ) == NULL )
			reg_name = regp->reg_name;
		else
			reg_name++;

		if( (dp=db_lookup( rtip->rti_dbip, reg_name, LOOKUP_NOISY ) ) == DIR_NULL )
			continue;

		if( db5_get_attributes( rtip->rti_dbip, &avs, dp ) ) {
			bu_log( "rt_load_attrs: Failed to get attributes for region %s\n", reg_name );
			continue;
		}

		for( i=0 ; i<attr_count ; i++ ) {
			if( (attr = bu_avs_get( &avs, attrs[i] ) ) == NULL )
				continue;

			bu_mro_set( regp->attr_values[i], attr );
			did_set = 1;
		}

		if( did_set )
			region_count++;

		bu_avs_free( &avs );
	}

	return( region_count );
}

/*			R T _ F I N D _ P A T H
 *
 *	Routine called by "rt_find_paths". Used for recursing through a tree to find a path
 *	to the specified "end". The resulting path is returned in "curr_path".
 */
static void
rt_find_path( struct db_i *dbip,
	      union tree *tp,
	      struct directory *end,
	      struct bu_ptbl *paths,
	      struct db_full_path **curr_path,
	      struct resource *resp )
{
	int curr_path_index=(*curr_path)->fp_len;
	struct db_full_path *newpath;
	struct directory *dp;
	struct rt_db_internal intern;
	struct rt_comb_internal *comb;

	switch( tp->tr_op ) {
	case OP_DB_LEAF:
		dp = db_lookup( dbip, tp->tr_l.tl_name, 1 );
		if( dp == DIR_NULL ) {
			bu_bomb( "rt_find_path() failed!!\n" );
		}
		db_add_node_to_full_path( *curr_path, dp );
		if( dp == end ) {
			bu_ptbl_ins( paths, (long *)(*curr_path) );
			newpath = (struct db_full_path *)bu_malloc( sizeof( struct db_full_path ),
								    "newpath" );
			db_full_path_init( newpath );
			db_dup_full_path( newpath, (*curr_path) );
			(*curr_path) = newpath;
		} else if( (dp->d_flags & DIR_COMB) && !(dp->d_flags & DIR_REGION ) ) {
			if( rt_db_get_internal( &intern, dp, dbip, NULL, resp ) < 0 ) {
				bu_bomb( "db_get_internal() failed!!\n" );
			}
			comb = (struct rt_comb_internal *)intern.idb_ptr;
			rt_find_path( dbip, comb->tree, end, paths, curr_path, resp );
			rt_db_free_internal( &intern, resp );
		}
		break;
	case OP_UNION:
	case OP_SUBTRACT:
	case OP_INTERSECT:
	case OP_XOR:
		/* binary, process both subtrees */
		rt_find_path( dbip, tp->tr_b.tb_left, end, paths, curr_path, resp );
		(*curr_path)->fp_len = curr_path_index;
		rt_find_path( dbip, tp->tr_b.tb_right, end, paths, curr_path, resp );
		break;
	case OP_NOT:
	case OP_GUARD:
		rt_find_path( dbip, tp->tr_b.tb_left, end, paths, curr_path, resp );
		break;
	default:
		bu_log( "rt_find_path(): Unrecognized OP (%d)\n", tp->tr_op );
		bu_bomb( "rt_find_path(): Unrecognized OP\n" );
		break;
	}
}

/*			R T _ F I N D _ P A T H S
 *
 *	Routine to find all the paths from the "start" to the "end".
 *	The resulting paths are returned in "paths"
 */
int
rt_find_paths( struct db_i *dbip,
	       struct directory *start,
	       struct directory *end,
	       struct bu_ptbl *paths,
	       struct resource *resp )
{
	struct rt_db_internal intern;
	struct db_full_path *path;
	struct rt_comb_internal *comb;

	path = (struct db_full_path *)bu_malloc( sizeof( struct db_full_path ), "path" );
	db_full_path_init( path );
	db_add_node_to_full_path( path, start );

	if( start == end ) {
		bu_ptbl_ins( paths, (long *)path );
		return( 0 );
	}

	if( !(start->d_flags & DIR_COMB) || (start->d_flags & DIR_REGION) ) {
		bu_log( "Cannot find path from %s to %s\n",
			start->d_namep, end->d_namep );
		db_free_full_path( path );
		bu_free( (char *)path, "path" );
		return( 1 );
	}

	if( rt_db_get_internal( &intern, start, dbip, NULL, resp ) < 0 ) {
		db_free_full_path( path );
		bu_free( (char *)path, "path" );
		return( 1 );
	}

	comb = (struct rt_comb_internal *)intern.idb_ptr;
	rt_find_path( dbip, comb->tree, end, paths, &path, resp );
	rt_db_free_internal( &intern, resp );

	return( 0 );
}

/*			O B J _ I N _ P A T H
 *
 *	This routine searches the provided path (in the form of a string) for the specified object name.
 *	returns:
 *		1 - the specified object name is somewhere along the path
 *		0 - the specified object name does not appear in this path
 */
int
obj_in_path( const char *path, const char *obj )
{
	int obj_len=strlen( obj );
	char *ptr;

	ptr = strstr( path, obj );

	while( ptr ) {
		if( ptr == path ) {
			/* obj may be first element in path */
			ptr += obj_len;
			if( *ptr == '\0' || *ptr == '/' ) {
				/* found object in path */
				return( 1 );
			}
		} else if( *(ptr-1) == '/' ) {
			ptr += obj_len;
			if( *ptr == '\0' || *ptr == '/' ) {
				/* found object in path */
				return( 1 );
			}
		} else {
			ptr++;
		}

		ptr = strstr( ptr, obj );
	}

	return( 0 );
}

static int
unprep_reg_start( struct db_tree_state *tsp,
		  struct db_full_path *pathp,
		  const struct rt_comb_internal *comb,
		  genptr_t client_data )
{
	RT_CK_RTI(tsp->ts_rtip);
	RT_CK_RESOURCE(tsp->ts_resp);

	/* Ignore "air" regions unless wanted */
	if( tsp->ts_rtip->useair == 0 &&  tsp->ts_aircode != 0 )  {
		tsp->ts_rtip->rti_air_discards++;
		return(-1);	/* drop this region */
	}
	return(0);
}

static union tree *
unprep_reg_end( struct db_tree_state *tsp,
		  struct db_full_path *pathp,
		  union tree *tree,
		  genptr_t client_data )
{
	return( (union tree *)NULL );
}

static union tree *
unprep_leaf( struct db_tree_state *tsp,
	     struct db_full_path *pathp,
	     struct rt_db_internal *ip,
	     genptr_t client_data )
{
	register struct soltab	*stp;
	struct directory	*dp;
	register matp_t		mat;
	struct rt_i		*rtip;
	struct bu_list		*mid;
	struct rt_reprep_obj_list *objs=(struct rt_reprep_obj_list *)client_data;

	RT_CK_DBTS(tsp);
	RT_CK_DBI(tsp->ts_dbip);
	RT_CK_FULL_PATH(pathp);
	RT_CK_DB_INTERNAL(ip);
	rtip = tsp->ts_rtip;
	RT_CK_RTI(rtip);
	RT_CK_RESOURCE(tsp->ts_resp);
	dp = DB_FULL_PATH_CUR_DIR(pathp);

	/* Determine if this matrix is an identity matrix */

	if( !bn_mat_is_equal(tsp->ts_mat, bn_mat_identity, &rtip->rti_tol)) {
		/* Not identity matrix */
		mat = (matp_t)tsp->ts_mat;
	} else {
		/* Identity matrix */
		mat = (matp_t)0;
	}

	/* find corresponding soltab structure */
	mid = BU_LIST_FIRST( bu_list, &dp->d_use_hd );
	while( mid != &dp->d_use_hd ) {
		stp = BU_LIST_MAIN_PTR( soltab, mid, l2 );
		RT_CK_SOLTAB(stp);

		mid = BU_LIST_PNEXT( bu_list, mid );

		if( ((mat == (matp_t)0) && (stp->st_matp == (matp_t)0) ) ||
		    bn_mat_is_equal( mat, stp->st_matp, &rtip->rti_tol ) ) {
			if( stp->st_rtip == rtip ) {
				long bit=stp->st_bit;
				struct region *rp;
				int i,j;

				/* found soltab for this instance */

				/* check all regions using this soltab
				 * add any that are below an object to be unprepped
				 * to the "unprep_regions" list
				 */
				for( i=0 ; i<BU_PTBL_LEN( &stp->st_regions ) ; i++ ) {
					rp = (struct region *)BU_PTBL_GET( &stp->st_regions, i );
					for( j=0 ; j<objs->nunprepped ; j++ ) {
						if( obj_in_path( rp->reg_name, objs->unprepped[j] ) ) {
							/* this region has an unprep object
							 * in its path */
							bu_ptbl_ins_unique( &objs->unprep_regions, (long *)rp );
							bu_ptbl_rm( &stp->st_regions, (long *)rp );
							break;
						}
					}
				}
				if( stp->st_uses <= 1 ) {
					/* soltab structure will actually be freed */
					remove_from_bsp( stp, &rtip->rti_inf_box, &rtip->rti_tol );
					remove_from_bsp( stp, &rtip->rti_CutHead, &rtip->rti_tol );
					rtip->rti_Solids[bit] = (struct soltab *)NULL;
				}
				rt_free_soltab( stp );
				return( (union tree *)NULL );
			}
		}
	}

	bu_log( "rt_unprep(): Failed to find soltab structure for an instance of %s\n", dp->d_namep );
	bu_bomb( "rt_unprep(): Failed to find soltab structure for a solid instance\n");

	return( (union tree *)NULL );
}


/*			R T _ U N P R E P
 *
 *	This routine "unpreps" the list of object names that appears in the "unprepped" list
 *	of the "objs" structure.
 */
int
rt_unprep( struct rt_i *rtip, struct rt_reprep_obj_list *objs, struct resource *resp )
{
	struct bu_ptbl paths;
	struct bu_ptbl unprep_regions;
	struct db_full_path *path;
	int i,j,k;

	rt_res_pieces_clean( resp, rtip );

	/* find all paths from top objects to objects being unprepped */
	bu_ptbl_init( &objs->paths, 5, "paths" );
	for( i=0 ; i<objs->ntopobjs ; i++ ) {
		struct directory *start, *end;

		start = db_lookup( rtip->rti_dbip, objs->topobjs[i], 1 );
		if( start == DIR_NULL ) {
			for( k=0 ; k<BU_PTBL_END(&objs->paths) ; k++ ) {
				path = (struct db_full_path *)BU_PTBL_GET( &objs->paths, k );
				db_free_full_path( path );
			}
			bu_ptbl_free( &objs->paths );
			return( 1 );
		}
		for( j=0 ; j<objs->nunprepped ; j++ ) {
			end = db_lookup( rtip->rti_dbip, objs->unprepped[j], 1 );
			if( end == DIR_NULL ) {
				for( k=0 ; k<BU_PTBL_END(&objs->paths) ; k++ ) {
					path = (struct db_full_path *)BU_PTBL_GET( &objs->paths, k );
					db_free_full_path( path );
				}
				bu_ptbl_free( &objs->paths );
				return( 1 );
			}
			rt_find_paths( rtip->rti_dbip, start, end, &objs->paths, resp );
		}
	}

	if( BU_PTBL_LEN( &objs->paths ) < 1 ) {
		bu_log( "rt_unprep(): Failed to find any paths to objects to reprep!!\n" );
		bu_ptbl_free( &objs->paths );
	}

	/* accumulate state along each path */
	objs->tsp = (struct db_tree_state **)bu_calloc(
				  BU_PTBL_LEN( &objs->paths ),
				  sizeof( struct db_tree_state *),
				  "objs->tsp" );

	bu_ptbl_init( &objs->unprep_regions, 5, "unprep_regions" );

	for( i=0 ; i<BU_PTBL_LEN( &objs->paths ) ; i++ ) {
		struct db_full_path another_path;
		struct db_tree_state	*tree_state;
		char			*obj_name;

		tree_state = (struct db_tree_state *)bu_malloc( sizeof( struct db_tree_state ),
								"tree_state" );
		*tree_state = rt_initial_tree_state;	/* struct copy */
		tree_state->ts_dbip = rtip->rti_dbip;
		tree_state->ts_resp = resp;
		tree_state->ts_rtip = rtip;
		tree_state->ts_tol = &rtip->rti_tol;
		objs->tsp[i] = tree_state;

		db_full_path_init( &another_path );
		path = (struct db_full_path *)BU_PTBL_GET( &objs->paths, i );
		if( db_follow_path( tree_state, &another_path, path, 1, 0 ) ) {
			bu_log( "rt_unprep(): db_follow_path failed!!\n" );
			for( k=0 ; k<BU_PTBL_END(&paths) ; k++ ) {
				if( objs->tsp[k] ) {
					db_free_db_tree_state( objs->tsp[k] );
					bu_free( (char *)objs->tsp[k], "tree_state" );
				}
				path = (struct db_full_path *)BU_PTBL_GET( &objs->paths, k );
				db_free_full_path( path );
			}
			bu_ptbl_free( &paths );
			bu_ptbl_free( &unprep_regions );
			return( 1 );
		}
		db_free_full_path( &another_path );

		/* walk tree starting from "unprepped" object,
		 * using the appropriate tree_state.
		 * unprep solids and regions along the way
		 */
		obj_name = DB_FULL_PATH_CUR_DIR(path)->d_namep;
		if( db_walk_tree( rtip->rti_dbip, 1, (const char **)&obj_name, 1, tree_state,
				  unprep_reg_start, unprep_reg_end, unprep_leaf,
				  (genptr_t)objs ) ) {
			bu_log( "rt_unprep(): db_walk_tree failed!!!\n" );
			for( k=0 ; k<BU_PTBL_END(&paths) ; k++ ) {
				if( objs->tsp[k] ) {
					db_free_db_tree_state( objs->tsp[k] );
					bu_free( (char *)objs->tsp[k], "tree_state" );
				}
				path = (struct db_full_path *)BU_PTBL_GET( &objs->paths, k );
				db_free_full_path( path );
			}
			bu_ptbl_free( &paths );
			bu_ptbl_free( &unprep_regions );
			return( 1 );
		}

		db_free_db_tree_state( tree_state );
		bu_free( (char *)tree_state, "tree_state" );
	}

	/* eliminate regions to be unprepped */
	objs->nregions_unprepped = BU_PTBL_LEN( &objs->unprep_regions );
	for( i=0 ; i<BU_PTBL_LEN( &objs->unprep_regions ) ; i++ ) {
		struct region *rp;

		rp = (struct region *)BU_PTBL_GET( &objs->unprep_regions, i );
		BU_LIST_DEQUEUE( &rp->l );
		rtip->Regions[rp->reg_bit] = (struct region *)NULL;

		/* XXX
		   db_free_tree( rp->reg_treetop, resp ); */
		bu_free( (genptr_t)rp->reg_name, "region name str");
		rp->reg_name = (char *)0;
		if( rp->reg_mater.ma_shader )
		{
			bu_free( (genptr_t)rp->reg_mater.ma_shader, "ma_shader" );
			rp->reg_mater.ma_shader = (char *)NULL;
		}
		if( rp->attr_values ) {
			i = 0;
			while( rp->attr_values[i] ) {
				bu_mro_free( rp->attr_values[i] );
				i++;
			}
			bu_free( (char *)rp->attr_values, "rp->attr_values" );
		}
		bu_free( (genptr_t)rp, "struct region");
	}

	/* eliminate NULL region structures */
	objs->old_nregions = rtip->nregions;
	i = 0;
	while( i < rtip->nregions ) {
		int nulls=0;

		while( i < rtip->nregions && !rtip->Regions[i] ) {
			i++;
			nulls++;
		}

		if( nulls ) {
			rtip->nregions -= nulls;
			for( j=i-nulls ; j<rtip->nregions ; j++ ) {
				rtip->Regions[j] = rtip->Regions[j+nulls];
				if( rtip->Regions[j] ) {
					rtip->Regions[j]->reg_bit = j;
				}
			}
			nulls = 0;
		} else {
			i++;
		}
	}

	/* eliminate NULL soltabs */
	objs->old_nsolids = rtip->nsolids;
	objs->nsolids_unprepped = 0;
	i = 0;
	while( i < rtip->nsolids) {
		int nulls=0;

		while( i < rtip->nsolids && !rtip->rti_Solids[i] ) {
			objs->nsolids_unprepped++;
			i++;
			nulls++;
		}
		if( nulls ) {
			for( j=i-nulls ; j+nulls<rtip->nsolids ; j++ ) {
				rtip->rti_Solids[j] = rtip->rti_Solids[j+nulls];
				if( rtip->rti_Solids[j] ) {
					rtip->rti_Solids[j]->st_bit = j;
				}
			}
			rtip->nsolids -= nulls;
			i -= nulls;
		} else {
			i++;
		}
	}

	return( 0 );
}

/*			R T _ R E P R E P
 *	This routine "re-preps" the list of objects specified in the "unprepped" list of the
 *	"objs" structure. This structure must previously have been passed to "rt_unprep"
 */
int
rt_reprep( struct rt_i *rtip, struct rt_reprep_obj_list *objs, struct resource *resp )
{
	int i;
	char **argv;
	struct region *rp;
	struct soltab *stp;
	fastf_t old_min[3], old_max[3];
	int model_extremes_have_changed=0;
	long bitno;

	VMOVE( old_min, rtip->mdl_min );
	VMOVE( old_max, rtip->mdl_max );

	rtip->needprep = 1;

	argv = (char **)bu_calloc( BU_PTBL_LEN( &(objs->paths) ), sizeof( char *), "argv" );
	for( i=0 ; i<BU_PTBL_LEN( &(objs->paths) ) ; i++ ) {
		argv[i] = db_path_to_string( (const struct db_full_path *)BU_PTBL_GET( &(objs->paths), i ));
	}

	rtip->rti_add_to_new_solids_list = 1;
	bu_ptbl_init( &rtip->rti_new_solids, 128, "rti_new_solids" );
	if( rt_gettrees( rtip, BU_PTBL_LEN( &(objs->paths) ), (const char **)argv, 1 ) ) {
		return( 1 );
	}
	rtip->rti_add_to_new_solids_list = 0;

	for( i=0 ; i<BU_PTBL_LEN( &(objs->paths) ) ; i++ ) {
		bu_free( argv[i], "argv[i]" );
	}
	bu_free( (char *)argv, "argv" );

	rtip->needprep = 0;

	if( rtip->nregions > objs->old_nregions ) {
		rtip->Regions = (struct region **)bu_realloc( rtip->Regions,
				     rtip->nregions * sizeof( struct region *), "rtip->Regions" );
		memset( rtip->Regions, 0, rtip->nregions );
	}


	bitno = 0;
	for( BU_LIST_FOR( rp, region, &(rtip->HeadRegion) ) ) {
		rp->reg_bit = bitno;
		rtip->Regions[bitno] = rp;
		if( bitno >= objs->old_nregions - objs->nregions_unprepped ) {
			point_t region_min, region_max;

			if( rt_bound_tree( rp->reg_treetop, region_min, region_max ) ) {
				bu_log( "rt_reprep(): rt_bound_tree() FAILED for %s\n",
					rp->reg_name );
				bu_bomb( "rt_reprep(): rt_bound_tree() FAILED\n" );
			}
			if( region_max[X] < INFINITY )  {
				/* infinite regions are exempted from this */
				VMINMAX( rtip->mdl_min, rtip->mdl_max, region_min );
				VMINMAX( rtip->mdl_min, rtip->mdl_max, region_max );
			}
			rt_solid_bitfinder( rp->reg_treetop, rp, resp );
		}
		bitno++;
	}

	if( rtip->nsolids > objs->old_nsolids ) {
		rtip->rti_Solids = (struct soltab **)bu_realloc( rtip->rti_Solids,
								 rtip->nsolids * sizeof( struct soltab *),
								 "rtip->rti_Solids" );
		memset( rtip->rti_Solids, 0, rtip->nsolids );
	}

	bitno = 0;
	RT_VISIT_ALL_SOLTABS_START( stp, rtip )  {
		stp->st_bit = bitno;
		rtip->rti_Solids[bitno] = stp;
		bitno++;
		
	} RT_VISIT_ALL_SOLTABS_END

	for( i=0 ; i<BU_PTBL_LEN( &rtip->rti_new_solids ) ; i++ ) {
		stp = (struct soltab * )BU_PTBL_GET( &rtip->rti_new_solids, i );
		if( stp->st_aradius >= INFINITY ) {
			insert_in_bsp( stp, &rtip->rti_inf_box );
		} else {
			insert_in_bsp( stp, &rtip->rti_CutHead );
		}
	}

	bu_ptbl_free( &rtip->rti_new_solids );

	for( i=0 ; i<3 ; i++ ) {
		if( rtip->mdl_min[i] != old_min[i] ) {
			model_extremes_have_changed = 1;
			break;
		}
		if( rtip->mdl_max[i] != old_max[i] ) {
			model_extremes_have_changed = 1;
			break;
		}
	}

	if( model_extremes_have_changed ) {
		/* fill out BSP, it must completely fill the model BB */
		fastf_t bb[6];

		VSETALL( bb, INFINITY );
		VSETALL( &bb[3], -INFINITY );
		fill_out_bsp( rtip, &rtip->rti_CutHead, resp, bb );
	}

	if( BU_PTBL_LEN( &rtip->rti_resources ) ) {
		for( i=0 ; i<BU_PTBL_LEN( &rtip->rti_resources ) ; i++ ) {
			struct resource *re;

			re = (struct resource *)BU_PTBL_GET( &rtip->rti_resources, i );
			if( re && rtip->rti_nsolids_with_pieces )
				rt_res_pieces_init( re, rtip );
		}
	} else if( rtip->rti_nsolids_with_pieces ) {
		rt_res_pieces_init( &rt_uniresource, rtip );
	}

	return( 0 );
}
@


11.85
log
@change conf.h to a wrapped config.h
@
text
@d21 1
a21 1
static const char RCSprep[] = "@@(#)$Header: /cvs/brlcad/librt/prep.c,v 11.84 2004/04/05 08:48:58 morrison Exp $ (BRL)";
@


11.84
log
@merge of ansi-6-0-branch into HEAD
@
text
@d21 1
a21 1
static const char RCSprep[] = "@@(#)$Header$ (BRL)";
d24 5
a28 1
#include "conf.h"
@


11.83
log
@update copyright to include span through 2003
@
text
@d21 1
a21 1
static const char RCSprep[] = "@@(#)$Header: /c/CVS/brlcad/librt/prep.c,v 11.82 2003/10/29 17:55:28 jra Exp $ (BRL)";
d44 1
a44 1
HIDDEN void	rt_solid_bitfinder();
d58 1
a58 2
rt_new_rti( dbip )
struct db_i	*dbip;
d151 1
a151 2
rt_free_rti( rtip )
struct rt_i	*rtip;
d196 1
a196 3
rt_prep_parallel(rtip, ncpu)
register struct rt_i	*rtip;
int			ncpu;
d423 1
a423 2
rt_prep(rtip)
register struct rt_i *rtip;
d436 1
a436 3
rt_plot_all_bboxes( fp, rtip )
FILE		*fp;
struct rt_i	*rtip;
d678 1
a678 3
rt_clean_resource( rtip, resp )
struct rt_i	*rtip;
struct resource	*resp;
d811 1
a811 2
rt_clean( rtip )
register struct rt_i *rtip;
d1015 1
a1015 4
rt_solid_bitfinder( treep, regp, resp )
register union tree	*treep;
struct region		*regp;
struct resource		*resp;
d1069 1
a1069 2
rt_ck( rtip )
register struct rt_i	*rtip;
@


11.82
log
@Added get_solidbitv()
removed old re_prep_solids()
improvments to unprep_leaf() (compatibility with new remove_from_bsp())
mods to rt_unprep() (care not to reference NULL region or soltab structs)
mods tp rt_reprep() (now completely rebuilds rt_i structs arrays of region and soltab structs)
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1990 by the United States Army.
d21 1
a21 1
static const char RCSprep[] = "@@(#)$Header: /c/CVS/brlcad/librt/prep.c,v 11.81 2003/10/17 23:41:48 jra Exp $ (BRL)";
@


11.81
log
@mod to rt_init_resource(), assertion that cpu_num < MAX_PSW is incorrect for a submodel's sub_rti
@
text
@d21 1
a21 1
static const char RCSprep[] = "@@(#)$Header: /c/CVS/brlcad/librt/prep.c,v 11.80 2003/07/11 14:18:26 jra Exp $ (BRL)";
d780 29
a1198 92
/*
 *	R E _ P R E P _ S O L I D S
 *
 *	This routine finds all the soltab structures for the list of solids passed in,
 *	removes those soltabs from the space partitioning tree, repreps those solids,
 *	and inserts the updated soltab structures back into the space partitioning tree.
 *	Obviously, these solids must appear in an already prepped rt_i.
 *
 *	returns:
 *		0 - all is well
 *		>0 - serious problems
 */
int
re_prep_solids( struct rt_i *rtip, int num_solids, char **solid_names, struct resource *resp )
{
	int solnum;
	point_t old_min, old_max;
	fastf_t bb[6];		/* bounding box: 0-2 = min, 3-5 = max */
	int model_extremes_have_changed=0;
	int i;

	VMOVE( old_min, rtip->mdl_min );
	VMOVE( old_max, rtip->mdl_max );

	for( solnum=0 ; solnum < num_solids ; solnum++ ) {
		struct directory *dp;
		struct bu_list *mid;
		struct soltab *stp;
		struct rt_db_internal intern;

		if( (dp = db_lookup( rtip->rti_dbip, solid_names[solnum], LOOKUP_QUIET ) ) == DIR_NULL ) {
			bu_log( "Failed to find solid %s, ignoring\n", solid_names[solnum] );
			continue;
		}

		for( BU_LIST_FOR( mid, bu_list, &dp->d_use_hd ) ) {
			stp = BU_LIST_MAIN_PTR( soltab, mid, l2 );
			RT_CK_SOLTAB(stp);

			if( rt_db_get_internal( &intern, dp, rtip->rti_dbip, stp->st_matp, resp ) < 0 ) {
				bu_log( "re_prep_solids(): rt_db_get_internal() failed for solid %s\n",
					dp->d_namep );
				return( 1 );
			}


			remove_from_bsp( stp, &rtip->rti_inf_box );
			remove_from_bsp( stp, &rtip->rti_CutHead );

			stp->st_id = intern.idb_type;
			stp->st_meth = &rt_functab[intern.idb_type];
			VSETALL( stp->st_max, -INFINITY );
			VSETALL( stp->st_min,  INFINITY );
			stp->st_meth->ft_free( stp );
			stp->st_aradius = 0;
			stp->st_rtip = rtip;
			if( stp->st_meth->ft_prep( stp, &intern, rtip ) )  {
				bu_log( "re_pre_solids(): prep failed for solid %s\n",
					dp->d_namep );
				return( 2 );
			}

			if( stp->st_aradius >= INFINITY ) {
				insert_in_bsp( stp, &rtip->rti_inf_box, resp, bb );
			} else {
				VSETALL( bb, INFINITY );
				VSETALL( &bb[3], -INFINITY );
				insert_in_bsp( stp, &rtip->rti_CutHead, resp, bb );
			}
		}
	}

	for( i=0 ; i<3 ; i++ ) {
		if( rtip->mdl_min[i] != old_min[i] ) {
			model_extremes_have_changed = 1;
			break;
		}
		if( rtip->mdl_max[i] != old_max[i] ) {
			model_extremes_have_changed = 1;
			break;
		}
	}

	if( model_extremes_have_changed ) {
		/* fill out BSP, it must completely fill the model BB */
		VSETALL( bb, INFINITY );
		VSETALL( &bb[3], -INFINITY );
		fill_out_bsp( rtip, &rtip->rti_CutHead, resp, bb );
	}
	return( 0 );
}

d1405 2
a1406 1
	for( BU_LIST_FOR( mid, bu_list, &dp->d_use_hd ) )  {
d1410 2
d1439 2
a1440 2
					remove_from_bsp( stp, &rtip->rti_inf_box );
					remove_from_bsp( stp, &rtip->rti_CutHead );
d1523 1
d1614 3
a1616 1
				rtip->Regions[j]->reg_bit = j;
d1628 1
a1628 1
	while( i < rtip->nsolids ) {
d1637 1
a1637 2
			rtip->nsolids -= nulls;
			for( j=i-nulls ; j<rtip->nsolids ; j++ ) {
d1639 3
a1641 1
				rtip->rti_Solids[j]->st_bit = j;
d1643 2
d1649 1
a1664 1
	fastf_t bb[6];
d1666 1
a1666 4
	long old_region_count=0;
	long reg_count=0;
	long old_solid_count=0;
	long sol_count=0;
a1670 10
	/* count number of regions currently in rtip's list */
	for( BU_LIST_FOR( rp, region, &(rtip->HeadRegion) ) ) {
		old_region_count++;
	}

	/* count solids */
	RT_VISIT_ALL_SOLTABS_START( stp, rtip )  {
		old_solid_count++;
	}RT_VISIT_ALL_SOLTABS_END

d1678 2
d1683 1
d1695 1
a1695 1
		memset( &rtip->Regions[objs->old_nregions], 0, rtip->nregions - objs->old_nregions );
d1699 1
d1701 15
a1715 2
		if( reg_count >= old_region_count ) {
			rtip->Regions[rp->reg_bit] = rp;
d1718 1
a1718 1
		reg_count++;
d1725 1
a1725 1
		memset( &rtip->rti_Solids[objs->old_nsolids], 0, rtip->nsolids - objs->old_nsolids );
d1728 1
d1730 3
a1732 11
		sol_count++;
		if( sol_count >= old_solid_count ) {
			rtip->rti_Solids[stp->st_bit] = stp;
			if( stp->st_aradius >= INFINITY ) {
				insert_in_bsp( stp, &rtip->rti_inf_box, resp, bb );
			} else {
				VSETALL( bb, INFINITY );
				VSETALL( &bb[3], -INFINITY );
				insert_in_bsp( stp, &rtip->rti_CutHead, resp, bb );
			}
		}
d1736 11
d1760 2
d1772 1
a1772 1
			if( re )
d1775 1
a1775 1
	} else {
@


11.80
log
@Added a note in "rt_new_rti()". If the space partitioning is changed, "rt_find_backing_dist()" must be
updated to handle the different partitioning
@
text
@d21 1
a21 1
static const char RCSprep[] = "@@(#)$Header: /c/CVS/brlcad/librt/prep.c,v 11.79 2003/04/07 17:56:39 jra Exp $ (BRL)";
d606 6
a611 1
		BU_ASSERT_LONG( cpu_num, <, MAX_PSW );
@


11.80.4.1
log
@updates from HEAD, part 1
@
text
@d21 1
a21 1
static const char RCSprep[] = "@@(#)$Header: /c/CVS/brlcad/librt/prep.c,v 11.82 2003/10/29 17:55:28 jra Exp $ (BRL)";
d606 1
a606 6
		if( rtip->rti_treetop ) {
			/* this is a submodel */
			BU_ASSERT_LONG( cpu_num, <, rtip->rti_resources.blen );
		} else {
			BU_ASSERT_LONG( cpu_num, <, MAX_PSW );
		}
a774 29
struct bu_bitv *
get_solidbitv( long nbits, struct resource *resp )
{
	struct bu_bitv *solidbits;
	int counter=0;

	if( resp->re_solid_bitv.magic != BU_LIST_HEAD_MAGIC ) {
		bu_bomb( "Bad magic number in re_solid_btiv list\n" );
	}

	if( BU_LIST_IS_EMPTY( &resp->re_solid_bitv ) )  {
		solidbits = bu_bitv_new( nbits );
	} else {
		for( BU_LIST_FOR( solidbits, bu_bitv, &resp->re_solid_bitv ) ) {
			if( solidbits->nbits >= nbits ) {
				BU_LIST_DEQUEUE( &solidbits->l );
				BU_CK_BITV(solidbits);
				break;
			}
			counter++;
		}
		if( solidbits == (struct bu_bitv *)&resp->re_solid_bitv ) {
			solidbits = bu_bitv_new( nbits );
		}
	}

	return( solidbits );
}

d1165 92
d1463 1
a1463 2
	mid = BU_LIST_FIRST( bu_list, &dp->d_use_hd );
	while( mid != &dp->d_use_hd ) {
a1466 2
		mid = BU_LIST_PNEXT( bu_list, mid );

d1494 2
a1495 2
					remove_from_bsp( stp, &rtip->rti_inf_box, &rtip->rti_tol );
					remove_from_bsp( stp, &rtip->rti_CutHead, &rtip->rti_tol );
a1577 1
		tree_state->ts_tol = &rtip->rti_tol;
d1668 1
a1668 3
				if( rtip->Regions[j] ) {
					rtip->Regions[j]->reg_bit = j;
				}
d1680 1
a1680 1
	while( i < rtip->nsolids) {
d1689 2
a1690 1
			for( j=i-nulls ; j+nulls<rtip->nsolids ; j++ ) {
d1692 1
a1692 3
				if( rtip->rti_Solids[j] ) {
					rtip->rti_Solids[j]->st_bit = j;
				}
a1693 2
			rtip->nsolids -= nulls;
			i -= nulls;
a1697 1

d1713 1
d1715 4
a1718 1
	long bitno;
d1723 10
a1739 2
	rtip->rti_add_to_new_solids_list = 1;
	bu_ptbl_init( &rtip->rti_new_solids, 128, "rti_new_solids" );
a1742 1
	rtip->rti_add_to_new_solids_list = 0;
d1754 1
a1754 1
		memset( rtip->Regions, 0, rtip->nregions );
a1757 1
	bitno = 0;
d1759 2
a1760 15
		rp->reg_bit = bitno;
		rtip->Regions[bitno] = rp;
		if( bitno >= objs->old_nregions - objs->nregions_unprepped ) {
			point_t region_min, region_max;

			if( rt_bound_tree( rp->reg_treetop, region_min, region_max ) ) {
				bu_log( "rt_reprep(): rt_bound_tree() FAILED for %s\n",
					rp->reg_name );
				bu_bomb( "rt_reprep(): rt_bound_tree() FAILED\n" );
			}
			if( region_max[X] < INFINITY )  {
				/* infinite regions are exempted from this */
				VMINMAX( rtip->mdl_min, rtip->mdl_max, region_min );
				VMINMAX( rtip->mdl_min, rtip->mdl_max, region_max );
			}
d1763 1
a1763 1
		bitno++;
d1770 1
a1770 1
		memset( rtip->rti_Solids, 0, rtip->nsolids );
a1772 1
	bitno = 0;
d1774 11
a1784 3
		stp->st_bit = bitno;
		rtip->rti_Solids[bitno] = stp;
		bitno++;
a1787 11
	for( i=0 ; i<BU_PTBL_LEN( &rtip->rti_new_solids ) ; i++ ) {
		stp = (struct soltab * )BU_PTBL_GET( &rtip->rti_new_solids, i );
		if( stp->st_aradius >= INFINITY ) {
			insert_in_bsp( stp, &rtip->rti_inf_box );
		} else {
			insert_in_bsp( stp, &rtip->rti_CutHead );
		}
	}

	bu_ptbl_free( &rtip->rti_new_solids );

a1800 2
		fastf_t bb[6];

d1811 1
a1811 1
			if( re && rtip->rti_nsolids_with_pieces )
d1814 1
a1814 1
	} else if( rtip->rti_nsolids_with_pieces ) {
@


11.80.4.2
log
@merge from HEAD
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d21 1
a21 1
static const char RCSprep[] = "@@(#)$Header: /c/CVS/brlcad/librt/prep.c,v 11.83 2004/02/02 17:39:28 morrison Exp $ (BRL)";
@


11.80.4.3
log
@merge from head
@
text
@d21 1
a21 1
static const char RCSprep[] = "@@(#)$Header: /c/CVS/brlcad/librt/prep.c,v 11.80.4.2 2004/02/12 18:37:47 erikg Exp $ (BRL)";
@


11.79
log
@rt_i's new "delete_regs" bu_ptbl is now initialized in rt_new_rti() and reset
in rt_clean()
@
text
@d21 1
a21 1
static const char RCSprep[] = "@@(#)$Header: /c/CVS/brlcad/librt/prep.c,v 11.78 2002/09/30 14:02:27 jra Exp $ (BRL)";
d110 6
d117 1
@


11.79.2.1
log
@updated for merging
@
text
@d21 1
a21 1
static const char RCSprep[] = "@@(#)$Header: /c/CVS/brlcad/librt/prep.c,v 11.80 2003/07/11 14:18:26 jra Exp $ (BRL)";
a109 6
	/* This sets the space partitioning algorithm to Mike's original
	 * non-uniform binary space paritioning tree.
	 * If you change this to anything else, you must also modify
	 * "rt_find_backing_dist()" (in shoot.c), to handle the different
	 * alogorithm            -JRA
	 */
a110 1

@


11.78
log
@Added code to support dynamic geometry
@
text
@d21 1
a21 1
static const char RCSprep[] = "@@(#)$Header: /c/CVS/brlcad/librt/prep.c,v 11.77 2002/08/20 17:08:09 jra Exp $ (BRL)";
d87 3
d932 2
@


11.77
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d21 1
a21 1
static const char RCSprep[] = "@@(#)$Header: /c/CVS/brlcad/librt/prep.c,v 11.75 2002/08/02 17:49:58 jra Exp $ (BRL)";
d1151 656
@


11.77.4.1
log
@sync to HEAD...
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d21 1
a21 1
static const char RCSprep[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/prep.c,v 11.83 2004/02/02 17:39:28 morrison Exp $ (BRL)";
a86 3
	/* list of invisible light regions to be deleted after light_init() */
	bu_ptbl_init( &rtip->delete_regs, 8, "rt_i delete regions list" );

a106 6
	/* This sets the space partitioning algorithm to Mike's original
	 * non-uniform binary space paritioning tree.
	 * If you change this to anything else, you must also modify
	 * "rt_find_backing_dist()" (in shoot.c), to handle the different
	 * alogorithm            -JRA
	 */
a107 1

d596 1
a596 6
		if( rtip->rti_treetop ) {
			/* this is a submodel */
			BU_ASSERT_LONG( cpu_num, <, rtip->rti_resources.blen );
		} else {
			BU_ASSERT_LONG( cpu_num, <, MAX_PSW );
		}
a764 29
struct bu_bitv *
get_solidbitv( long nbits, struct resource *resp )
{
	struct bu_bitv *solidbits;
	int counter=0;

	if( resp->re_solid_bitv.magic != BU_LIST_HEAD_MAGIC ) {
		bu_bomb( "Bad magic number in re_solid_btiv list\n" );
	}

	if( BU_LIST_IS_EMPTY( &resp->re_solid_bitv ) )  {
		solidbits = bu_bitv_new( nbits );
	} else {
		for( BU_LIST_FOR( solidbits, bu_bitv, &resp->re_solid_bitv ) ) {
			if( solidbits->nbits >= nbits ) {
				BU_LIST_DEQUEUE( &solidbits->l );
				BU_CK_BITV(solidbits);
				break;
			}
			counter++;
		}
		if( solidbits == (struct bu_bitv *)&resp->re_solid_bitv ) {
			solidbits = bu_bitv_new( nbits );
		}
	}

	return( solidbits );
}

a929 2
	bu_ptbl_reset( &rtip->delete_regs );

a1150 583
}

/*			R T _ F I N D _ P A T H
 *
 *	Routine called by "rt_find_paths". Used for recursing through a tree to find a path
 *	to the specified "end". The resulting path is returned in "curr_path".
 */
static void
rt_find_path( struct db_i *dbip,
	      union tree *tp,
	      struct directory *end,
	      struct bu_ptbl *paths,
	      struct db_full_path **curr_path,
	      struct resource *resp )
{
	int curr_path_index=(*curr_path)->fp_len;
	struct db_full_path *newpath;
	struct directory *dp;
	struct rt_db_internal intern;
	struct rt_comb_internal *comb;

	switch( tp->tr_op ) {
	case OP_DB_LEAF:
		dp = db_lookup( dbip, tp->tr_l.tl_name, 1 );
		if( dp == DIR_NULL ) {
			bu_bomb( "rt_find_path() failed!!\n" );
		}
		db_add_node_to_full_path( *curr_path, dp );
		if( dp == end ) {
			bu_ptbl_ins( paths, (long *)(*curr_path) );
			newpath = (struct db_full_path *)bu_malloc( sizeof( struct db_full_path ),
								    "newpath" );
			db_full_path_init( newpath );
			db_dup_full_path( newpath, (*curr_path) );
			(*curr_path) = newpath;
		} else if( (dp->d_flags & DIR_COMB) && !(dp->d_flags & DIR_REGION ) ) {
			if( rt_db_get_internal( &intern, dp, dbip, NULL, resp ) < 0 ) {
				bu_bomb( "db_get_internal() failed!!\n" );
			}
			comb = (struct rt_comb_internal *)intern.idb_ptr;
			rt_find_path( dbip, comb->tree, end, paths, curr_path, resp );
			rt_db_free_internal( &intern, resp );
		}
		break;
	case OP_UNION:
	case OP_SUBTRACT:
	case OP_INTERSECT:
	case OP_XOR:
		/* binary, process both subtrees */
		rt_find_path( dbip, tp->tr_b.tb_left, end, paths, curr_path, resp );
		(*curr_path)->fp_len = curr_path_index;
		rt_find_path( dbip, tp->tr_b.tb_right, end, paths, curr_path, resp );
		break;
	case OP_NOT:
	case OP_GUARD:
		rt_find_path( dbip, tp->tr_b.tb_left, end, paths, curr_path, resp );
		break;
	default:
		bu_log( "rt_find_path(): Unrecognized OP (%d)\n", tp->tr_op );
		bu_bomb( "rt_find_path(): Unrecognized OP\n" );
		break;
	}
}

/*			R T _ F I N D _ P A T H S
 *
 *	Routine to find all the paths from the "start" to the "end".
 *	The resulting paths are returned in "paths"
 */
int
rt_find_paths( struct db_i *dbip,
	       struct directory *start,
	       struct directory *end,
	       struct bu_ptbl *paths,
	       struct resource *resp )
{
	struct rt_db_internal intern;
	struct db_full_path *path;
	struct rt_comb_internal *comb;

	path = (struct db_full_path *)bu_malloc( sizeof( struct db_full_path ), "path" );
	db_full_path_init( path );
	db_add_node_to_full_path( path, start );

	if( start == end ) {
		bu_ptbl_ins( paths, (long *)path );
		return( 0 );
	}

	if( !(start->d_flags & DIR_COMB) || (start->d_flags & DIR_REGION) ) {
		bu_log( "Cannot find path from %s to %s\n",
			start->d_namep, end->d_namep );
		db_free_full_path( path );
		bu_free( (char *)path, "path" );
		return( 1 );
	}

	if( rt_db_get_internal( &intern, start, dbip, NULL, resp ) < 0 ) {
		db_free_full_path( path );
		bu_free( (char *)path, "path" );
		return( 1 );
	}

	comb = (struct rt_comb_internal *)intern.idb_ptr;
	rt_find_path( dbip, comb->tree, end, paths, &path, resp );
	rt_db_free_internal( &intern, resp );

	return( 0 );
}

/*			O B J _ I N _ P A T H
 *
 *	This routine searches the provided path (in the form of a string) for the specified object name.
 *	returns:
 *		1 - the specified object name is somewhere along the path
 *		0 - the specified object name does not appear in this path
 */
int
obj_in_path( const char *path, const char *obj )
{
	int obj_len=strlen( obj );
	char *ptr;

	ptr = strstr( path, obj );

	while( ptr ) {
		if( ptr == path ) {
			/* obj may be first element in path */
			ptr += obj_len;
			if( *ptr == '\0' || *ptr == '/' ) {
				/* found object in path */
				return( 1 );
			}
		} else if( *(ptr-1) == '/' ) {
			ptr += obj_len;
			if( *ptr == '\0' || *ptr == '/' ) {
				/* found object in path */
				return( 1 );
			}
		} else {
			ptr++;
		}

		ptr = strstr( ptr, obj );
	}

	return( 0 );
}

static int
unprep_reg_start( struct db_tree_state *tsp,
		  struct db_full_path *pathp,
		  const struct rt_comb_internal *comb,
		  genptr_t client_data )
{
	RT_CK_RTI(tsp->ts_rtip);
	RT_CK_RESOURCE(tsp->ts_resp);

	/* Ignore "air" regions unless wanted */
	if( tsp->ts_rtip->useair == 0 &&  tsp->ts_aircode != 0 )  {
		tsp->ts_rtip->rti_air_discards++;
		return(-1);	/* drop this region */
	}
	return(0);
}

static union tree *
unprep_reg_end( struct db_tree_state *tsp,
		  struct db_full_path *pathp,
		  union tree *tree,
		  genptr_t client_data )
{
	return( (union tree *)NULL );
}

static union tree *
unprep_leaf( struct db_tree_state *tsp,
	     struct db_full_path *pathp,
	     struct rt_db_internal *ip,
	     genptr_t client_data )
{
	register struct soltab	*stp;
	struct directory	*dp;
	register matp_t		mat;
	struct rt_i		*rtip;
	struct bu_list		*mid;
	struct rt_reprep_obj_list *objs=(struct rt_reprep_obj_list *)client_data;

	RT_CK_DBTS(tsp);
	RT_CK_DBI(tsp->ts_dbip);
	RT_CK_FULL_PATH(pathp);
	RT_CK_DB_INTERNAL(ip);
	rtip = tsp->ts_rtip;
	RT_CK_RTI(rtip);
	RT_CK_RESOURCE(tsp->ts_resp);
	dp = DB_FULL_PATH_CUR_DIR(pathp);

	/* Determine if this matrix is an identity matrix */

	if( !bn_mat_is_equal(tsp->ts_mat, bn_mat_identity, &rtip->rti_tol)) {
		/* Not identity matrix */
		mat = (matp_t)tsp->ts_mat;
	} else {
		/* Identity matrix */
		mat = (matp_t)0;
	}

	/* find corresponding soltab structure */
	mid = BU_LIST_FIRST( bu_list, &dp->d_use_hd );
	while( mid != &dp->d_use_hd ) {
		stp = BU_LIST_MAIN_PTR( soltab, mid, l2 );
		RT_CK_SOLTAB(stp);

		mid = BU_LIST_PNEXT( bu_list, mid );

		if( ((mat == (matp_t)0) && (stp->st_matp == (matp_t)0) ) ||
		    bn_mat_is_equal( mat, stp->st_matp, &rtip->rti_tol ) ) {
			if( stp->st_rtip == rtip ) {
				long bit=stp->st_bit;
				struct region *rp;
				int i,j;

				/* found soltab for this instance */

				/* check all regions using this soltab
				 * add any that are below an object to be unprepped
				 * to the "unprep_regions" list
				 */
				for( i=0 ; i<BU_PTBL_LEN( &stp->st_regions ) ; i++ ) {
					rp = (struct region *)BU_PTBL_GET( &stp->st_regions, i );
					for( j=0 ; j<objs->nunprepped ; j++ ) {
						if( obj_in_path( rp->reg_name, objs->unprepped[j] ) ) {
							/* this region has an unprep object
							 * in its path */
							bu_ptbl_ins_unique( &objs->unprep_regions, (long *)rp );
							bu_ptbl_rm( &stp->st_regions, (long *)rp );
							break;
						}
					}
				}
				if( stp->st_uses <= 1 ) {
					/* soltab structure will actually be freed */
					remove_from_bsp( stp, &rtip->rti_inf_box, &rtip->rti_tol );
					remove_from_bsp( stp, &rtip->rti_CutHead, &rtip->rti_tol );
					rtip->rti_Solids[bit] = (struct soltab *)NULL;
				}
				rt_free_soltab( stp );
				return( (union tree *)NULL );
			}
		}
	}

	bu_log( "rt_unprep(): Failed to find soltab structure for an instance of %s\n", dp->d_namep );
	bu_bomb( "rt_unprep(): Failed to find soltab structure for a solid instance\n");

	return( (union tree *)NULL );
}


/*			R T _ U N P R E P
 *
 *	This routine "unpreps" the list of object names that appears in the "unprepped" list
 *	of the "objs" structure.
 */
int
rt_unprep( struct rt_i *rtip, struct rt_reprep_obj_list *objs, struct resource *resp )
{
	struct bu_ptbl paths;
	struct bu_ptbl unprep_regions;
	struct db_full_path *path;
	int i,j,k;

	rt_res_pieces_clean( resp, rtip );

	/* find all paths from top objects to objects being unprepped */
	bu_ptbl_init( &objs->paths, 5, "paths" );
	for( i=0 ; i<objs->ntopobjs ; i++ ) {
		struct directory *start, *end;

		start = db_lookup( rtip->rti_dbip, objs->topobjs[i], 1 );
		if( start == DIR_NULL ) {
			for( k=0 ; k<BU_PTBL_END(&objs->paths) ; k++ ) {
				path = (struct db_full_path *)BU_PTBL_GET( &objs->paths, k );
				db_free_full_path( path );
			}
			bu_ptbl_free( &objs->paths );
			return( 1 );
		}
		for( j=0 ; j<objs->nunprepped ; j++ ) {
			end = db_lookup( rtip->rti_dbip, objs->unprepped[j], 1 );
			if( end == DIR_NULL ) {
				for( k=0 ; k<BU_PTBL_END(&objs->paths) ; k++ ) {
					path = (struct db_full_path *)BU_PTBL_GET( &objs->paths, k );
					db_free_full_path( path );
				}
				bu_ptbl_free( &objs->paths );
				return( 1 );
			}
			rt_find_paths( rtip->rti_dbip, start, end, &objs->paths, resp );
		}
	}

	if( BU_PTBL_LEN( &objs->paths ) < 1 ) {
		bu_log( "rt_unprep(): Failed to find any paths to objects to reprep!!\n" );
		bu_ptbl_free( &objs->paths );
	}

	/* accumulate state along each path */
	objs->tsp = (struct db_tree_state **)bu_calloc(
				  BU_PTBL_LEN( &objs->paths ),
				  sizeof( struct db_tree_state *),
				  "objs->tsp" );

	bu_ptbl_init( &objs->unprep_regions, 5, "unprep_regions" );

	for( i=0 ; i<BU_PTBL_LEN( &objs->paths ) ; i++ ) {
		struct db_full_path another_path;
		struct db_tree_state	*tree_state;
		char			*obj_name;

		tree_state = (struct db_tree_state *)bu_malloc( sizeof( struct db_tree_state ),
								"tree_state" );
		*tree_state = rt_initial_tree_state;	/* struct copy */
		tree_state->ts_dbip = rtip->rti_dbip;
		tree_state->ts_resp = resp;
		tree_state->ts_rtip = rtip;
		tree_state->ts_tol = &rtip->rti_tol;
		objs->tsp[i] = tree_state;

		db_full_path_init( &another_path );
		path = (struct db_full_path *)BU_PTBL_GET( &objs->paths, i );
		if( db_follow_path( tree_state, &another_path, path, 1, 0 ) ) {
			bu_log( "rt_unprep(): db_follow_path failed!!\n" );
			for( k=0 ; k<BU_PTBL_END(&paths) ; k++ ) {
				if( objs->tsp[k] ) {
					db_free_db_tree_state( objs->tsp[k] );
					bu_free( (char *)objs->tsp[k], "tree_state" );
				}
				path = (struct db_full_path *)BU_PTBL_GET( &objs->paths, k );
				db_free_full_path( path );
			}
			bu_ptbl_free( &paths );
			bu_ptbl_free( &unprep_regions );
			return( 1 );
		}
		db_free_full_path( &another_path );

		/* walk tree starting from "unprepped" object,
		 * using the appropriate tree_state.
		 * unprep solids and regions along the way
		 */
		obj_name = DB_FULL_PATH_CUR_DIR(path)->d_namep;
		if( db_walk_tree( rtip->rti_dbip, 1, (const char **)&obj_name, 1, tree_state,
				  unprep_reg_start, unprep_reg_end, unprep_leaf,
				  (genptr_t)objs ) ) {
			bu_log( "rt_unprep(): db_walk_tree failed!!!\n" );
			for( k=0 ; k<BU_PTBL_END(&paths) ; k++ ) {
				if( objs->tsp[k] ) {
					db_free_db_tree_state( objs->tsp[k] );
					bu_free( (char *)objs->tsp[k], "tree_state" );
				}
				path = (struct db_full_path *)BU_PTBL_GET( &objs->paths, k );
				db_free_full_path( path );
			}
			bu_ptbl_free( &paths );
			bu_ptbl_free( &unprep_regions );
			return( 1 );
		}

		db_free_db_tree_state( tree_state );
		bu_free( (char *)tree_state, "tree_state" );
	}

	/* eliminate regions to be unprepped */
	objs->nregions_unprepped = BU_PTBL_LEN( &objs->unprep_regions );
	for( i=0 ; i<BU_PTBL_LEN( &objs->unprep_regions ) ; i++ ) {
		struct region *rp;

		rp = (struct region *)BU_PTBL_GET( &objs->unprep_regions, i );
		BU_LIST_DEQUEUE( &rp->l );
		rtip->Regions[rp->reg_bit] = (struct region *)NULL;

		/* XXX
		   db_free_tree( rp->reg_treetop, resp ); */
		bu_free( (genptr_t)rp->reg_name, "region name str");
		rp->reg_name = (char *)0;
		if( rp->reg_mater.ma_shader )
		{
			bu_free( (genptr_t)rp->reg_mater.ma_shader, "ma_shader" );
			rp->reg_mater.ma_shader = (char *)NULL;
		}
		if( rp->attr_values ) {
			i = 0;
			while( rp->attr_values[i] ) {
				bu_mro_free( rp->attr_values[i] );
				i++;
			}
			bu_free( (char *)rp->attr_values, "rp->attr_values" );
		}
		bu_free( (genptr_t)rp, "struct region");
	}

	/* eliminate NULL region structures */
	objs->old_nregions = rtip->nregions;
	i = 0;
	while( i < rtip->nregions ) {
		int nulls=0;

		while( i < rtip->nregions && !rtip->Regions[i] ) {
			i++;
			nulls++;
		}

		if( nulls ) {
			rtip->nregions -= nulls;
			for( j=i-nulls ; j<rtip->nregions ; j++ ) {
				rtip->Regions[j] = rtip->Regions[j+nulls];
				if( rtip->Regions[j] ) {
					rtip->Regions[j]->reg_bit = j;
				}
			}
			nulls = 0;
		} else {
			i++;
		}
	}

	/* eliminate NULL soltabs */
	objs->old_nsolids = rtip->nsolids;
	objs->nsolids_unprepped = 0;
	i = 0;
	while( i < rtip->nsolids) {
		int nulls=0;

		while( i < rtip->nsolids && !rtip->rti_Solids[i] ) {
			objs->nsolids_unprepped++;
			i++;
			nulls++;
		}
		if( nulls ) {
			for( j=i-nulls ; j+nulls<rtip->nsolids ; j++ ) {
				rtip->rti_Solids[j] = rtip->rti_Solids[j+nulls];
				if( rtip->rti_Solids[j] ) {
					rtip->rti_Solids[j]->st_bit = j;
				}
			}
			rtip->nsolids -= nulls;
			i -= nulls;
		} else {
			i++;
		}
	}

	return( 0 );
}

/*			R T _ R E P R E P
 *	This routine "re-preps" the list of objects specified in the "unprepped" list of the
 *	"objs" structure. This structure must previously have been passed to "rt_unprep"
 */
int
rt_reprep( struct rt_i *rtip, struct rt_reprep_obj_list *objs, struct resource *resp )
{
	int i;
	char **argv;
	struct region *rp;
	struct soltab *stp;
	fastf_t old_min[3], old_max[3];
	int model_extremes_have_changed=0;
	long bitno;

	VMOVE( old_min, rtip->mdl_min );
	VMOVE( old_max, rtip->mdl_max );

	rtip->needprep = 1;

	argv = (char **)bu_calloc( BU_PTBL_LEN( &(objs->paths) ), sizeof( char *), "argv" );
	for( i=0 ; i<BU_PTBL_LEN( &(objs->paths) ) ; i++ ) {
		argv[i] = db_path_to_string( (const struct db_full_path *)BU_PTBL_GET( &(objs->paths), i ));
	}

	rtip->rti_add_to_new_solids_list = 1;
	bu_ptbl_init( &rtip->rti_new_solids, 128, "rti_new_solids" );
	if( rt_gettrees( rtip, BU_PTBL_LEN( &(objs->paths) ), (const char **)argv, 1 ) ) {
		return( 1 );
	}
	rtip->rti_add_to_new_solids_list = 0;

	for( i=0 ; i<BU_PTBL_LEN( &(objs->paths) ) ; i++ ) {
		bu_free( argv[i], "argv[i]" );
	}
	bu_free( (char *)argv, "argv" );

	rtip->needprep = 0;

	if( rtip->nregions > objs->old_nregions ) {
		rtip->Regions = (struct region **)bu_realloc( rtip->Regions,
				     rtip->nregions * sizeof( struct region *), "rtip->Regions" );
		memset( rtip->Regions, 0, rtip->nregions );
	}


	bitno = 0;
	for( BU_LIST_FOR( rp, region, &(rtip->HeadRegion) ) ) {
		rp->reg_bit = bitno;
		rtip->Regions[bitno] = rp;
		if( bitno >= objs->old_nregions - objs->nregions_unprepped ) {
			point_t region_min, region_max;

			if( rt_bound_tree( rp->reg_treetop, region_min, region_max ) ) {
				bu_log( "rt_reprep(): rt_bound_tree() FAILED for %s\n",
					rp->reg_name );
				bu_bomb( "rt_reprep(): rt_bound_tree() FAILED\n" );
			}
			if( region_max[X] < INFINITY )  {
				/* infinite regions are exempted from this */
				VMINMAX( rtip->mdl_min, rtip->mdl_max, region_min );
				VMINMAX( rtip->mdl_min, rtip->mdl_max, region_max );
			}
			rt_solid_bitfinder( rp->reg_treetop, rp, resp );
		}
		bitno++;
	}

	if( rtip->nsolids > objs->old_nsolids ) {
		rtip->rti_Solids = (struct soltab **)bu_realloc( rtip->rti_Solids,
								 rtip->nsolids * sizeof( struct soltab *),
								 "rtip->rti_Solids" );
		memset( rtip->rti_Solids, 0, rtip->nsolids );
	}

	bitno = 0;
	RT_VISIT_ALL_SOLTABS_START( stp, rtip )  {
		stp->st_bit = bitno;
		rtip->rti_Solids[bitno] = stp;
		bitno++;
		
	} RT_VISIT_ALL_SOLTABS_END

	for( i=0 ; i<BU_PTBL_LEN( &rtip->rti_new_solids ) ; i++ ) {
		stp = (struct soltab * )BU_PTBL_GET( &rtip->rti_new_solids, i );
		if( stp->st_aradius >= INFINITY ) {
			insert_in_bsp( stp, &rtip->rti_inf_box );
		} else {
			insert_in_bsp( stp, &rtip->rti_CutHead );
		}
	}

	bu_ptbl_free( &rtip->rti_new_solids );

	for( i=0 ; i<3 ; i++ ) {
		if( rtip->mdl_min[i] != old_min[i] ) {
			model_extremes_have_changed = 1;
			break;
		}
		if( rtip->mdl_max[i] != old_max[i] ) {
			model_extremes_have_changed = 1;
			break;
		}
	}

	if( model_extremes_have_changed ) {
		/* fill out BSP, it must completely fill the model BB */
		fastf_t bb[6];

		VSETALL( bb, INFINITY );
		VSETALL( &bb[3], -INFINITY );
		fill_out_bsp( rtip, &rtip->rti_CutHead, resp, bb );
	}

	if( BU_PTBL_LEN( &rtip->rti_resources ) ) {
		for( i=0 ; i<BU_PTBL_LEN( &rtip->rti_resources ) ; i++ ) {
			struct resource *re;

			re = (struct resource *)BU_PTBL_GET( &rtip->rti_resources, i );
			if( re && rtip->rti_nsolids_with_pieces )
				rt_res_pieces_init( re, rtip );
		}
	} else if( rtip->rti_nsolids_with_pieces ) {
		rt_res_pieces_init( &rt_uniresource, rtip );
	}

	return( 0 );
@


11.77.2.1
log
@Initial ANSIfication
@
text
@d21 1
a21 1
static const char RCSprep[] = "@@(#)$Header: /c/CVS/brlcad/librt/prep.c,v 11.77 2002/08/20 17:08:09 jra Exp $ (BRL)";
d44 1
a44 1
HIDDEN void	rt_solid_bitfinder(register union tree *treep, struct region *regp, struct resource *resp);
d58 2
a59 1
rt_new_rti(struct db_i *dbip)
d142 2
a143 1
rt_free_rti(struct rt_i *rtip)
d188 3
a190 1
rt_prep_parallel(register struct rt_i *rtip, int ncpu)
d417 2
a418 1
rt_prep(register struct rt_i *rtip)
d431 3
a433 1
rt_plot_all_bboxes(FILE *fp, struct rt_i *rtip)
d670 3
a672 1
rt_clean_resource(struct rt_i *rtip, struct resource *resp)
d776 2
a777 1
rt_clean(register struct rt_i *rtip)
d979 4
a982 1
rt_solid_bitfinder(register union tree *treep, struct region *regp, struct resource *resp)
d1036 2
a1037 1
rt_ck(register struct rt_i *rtip)
@


11.77.2.2
log
@sync branch with HEAD
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d21 1
a21 1
static const char RCSprep[] = "@@(#)$Header$ (BRL)";
a85 3
	/* list of invisible light regions to be deleted after light_init() */
	bu_ptbl_init( &rtip->delete_regs, 8, "rt_i delete regions list" );

a105 6
	/* This sets the space partitioning algorithm to Mike's original
	 * non-uniform binary space paritioning tree.
	 * If you change this to anything else, you must also modify
	 * "rt_find_backing_dist()" (in shoot.c), to handle the different
	 * alogorithm            -JRA
	 */
a106 1

d589 1
a589 6
		if( rtip->rti_treetop ) {
			/* this is a submodel */
			BU_ASSERT_LONG( cpu_num, <, rtip->rti_resources.blen );
		} else {
			BU_ASSERT_LONG( cpu_num, <, MAX_PSW );
		}
a755 29
struct bu_bitv *
get_solidbitv( long nbits, struct resource *resp )
{
	struct bu_bitv *solidbits;
	int counter=0;

	if( resp->re_solid_bitv.magic != BU_LIST_HEAD_MAGIC ) {
		bu_bomb( "Bad magic number in re_solid_btiv list\n" );
	}

	if( BU_LIST_IS_EMPTY( &resp->re_solid_bitv ) )  {
		solidbits = bu_bitv_new( nbits );
	} else {
		for( BU_LIST_FOR( solidbits, bu_bitv, &resp->re_solid_bitv ) ) {
			if( solidbits->nbits >= nbits ) {
				BU_LIST_DEQUEUE( &solidbits->l );
				BU_CK_BITV(solidbits);
				break;
			}
			counter++;
		}
		if( solidbits == (struct bu_bitv *)&resp->re_solid_bitv ) {
			solidbits = bu_bitv_new( nbits );
		}
	}

	return( solidbits );
}

a919 2
	bu_ptbl_reset( &rtip->delete_regs );

a1136 583
}

/*			R T _ F I N D _ P A T H
 *
 *	Routine called by "rt_find_paths". Used for recursing through a tree to find a path
 *	to the specified "end". The resulting path is returned in "curr_path".
 */
static void
rt_find_path( struct db_i *dbip,
	      union tree *tp,
	      struct directory *end,
	      struct bu_ptbl *paths,
	      struct db_full_path **curr_path,
	      struct resource *resp )
{
	int curr_path_index=(*curr_path)->fp_len;
	struct db_full_path *newpath;
	struct directory *dp;
	struct rt_db_internal intern;
	struct rt_comb_internal *comb;

	switch( tp->tr_op ) {
	case OP_DB_LEAF:
		dp = db_lookup( dbip, tp->tr_l.tl_name, 1 );
		if( dp == DIR_NULL ) {
			bu_bomb( "rt_find_path() failed!!\n" );
		}
		db_add_node_to_full_path( *curr_path, dp );
		if( dp == end ) {
			bu_ptbl_ins( paths, (long *)(*curr_path) );
			newpath = (struct db_full_path *)bu_malloc( sizeof( struct db_full_path ),
								    "newpath" );
			db_full_path_init( newpath );
			db_dup_full_path( newpath, (*curr_path) );
			(*curr_path) = newpath;
		} else if( (dp->d_flags & DIR_COMB) && !(dp->d_flags & DIR_REGION ) ) {
			if( rt_db_get_internal( &intern, dp, dbip, NULL, resp ) < 0 ) {
				bu_bomb( "db_get_internal() failed!!\n" );
			}
			comb = (struct rt_comb_internal *)intern.idb_ptr;
			rt_find_path( dbip, comb->tree, end, paths, curr_path, resp );
			rt_db_free_internal( &intern, resp );
		}
		break;
	case OP_UNION:
	case OP_SUBTRACT:
	case OP_INTERSECT:
	case OP_XOR:
		/* binary, process both subtrees */
		rt_find_path( dbip, tp->tr_b.tb_left, end, paths, curr_path, resp );
		(*curr_path)->fp_len = curr_path_index;
		rt_find_path( dbip, tp->tr_b.tb_right, end, paths, curr_path, resp );
		break;
	case OP_NOT:
	case OP_GUARD:
		rt_find_path( dbip, tp->tr_b.tb_left, end, paths, curr_path, resp );
		break;
	default:
		bu_log( "rt_find_path(): Unrecognized OP (%d)\n", tp->tr_op );
		bu_bomb( "rt_find_path(): Unrecognized OP\n" );
		break;
	}
}

/*			R T _ F I N D _ P A T H S
 *
 *	Routine to find all the paths from the "start" to the "end".
 *	The resulting paths are returned in "paths"
 */
int
rt_find_paths( struct db_i *dbip,
	       struct directory *start,
	       struct directory *end,
	       struct bu_ptbl *paths,
	       struct resource *resp )
{
	struct rt_db_internal intern;
	struct db_full_path *path;
	struct rt_comb_internal *comb;

	path = (struct db_full_path *)bu_malloc( sizeof( struct db_full_path ), "path" );
	db_full_path_init( path );
	db_add_node_to_full_path( path, start );

	if( start == end ) {
		bu_ptbl_ins( paths, (long *)path );
		return( 0 );
	}

	if( !(start->d_flags & DIR_COMB) || (start->d_flags & DIR_REGION) ) {
		bu_log( "Cannot find path from %s to %s\n",
			start->d_namep, end->d_namep );
		db_free_full_path( path );
		bu_free( (char *)path, "path" );
		return( 1 );
	}

	if( rt_db_get_internal( &intern, start, dbip, NULL, resp ) < 0 ) {
		db_free_full_path( path );
		bu_free( (char *)path, "path" );
		return( 1 );
	}

	comb = (struct rt_comb_internal *)intern.idb_ptr;
	rt_find_path( dbip, comb->tree, end, paths, &path, resp );
	rt_db_free_internal( &intern, resp );

	return( 0 );
}

/*			O B J _ I N _ P A T H
 *
 *	This routine searches the provided path (in the form of a string) for the specified object name.
 *	returns:
 *		1 - the specified object name is somewhere along the path
 *		0 - the specified object name does not appear in this path
 */
int
obj_in_path( const char *path, const char *obj )
{
	int obj_len=strlen( obj );
	char *ptr;

	ptr = strstr( path, obj );

	while( ptr ) {
		if( ptr == path ) {
			/* obj may be first element in path */
			ptr += obj_len;
			if( *ptr == '\0' || *ptr == '/' ) {
				/* found object in path */
				return( 1 );
			}
		} else if( *(ptr-1) == '/' ) {
			ptr += obj_len;
			if( *ptr == '\0' || *ptr == '/' ) {
				/* found object in path */
				return( 1 );
			}
		} else {
			ptr++;
		}

		ptr = strstr( ptr, obj );
	}

	return( 0 );
}

static int
unprep_reg_start( struct db_tree_state *tsp,
		  struct db_full_path *pathp,
		  const struct rt_comb_internal *comb,
		  genptr_t client_data )
{
	RT_CK_RTI(tsp->ts_rtip);
	RT_CK_RESOURCE(tsp->ts_resp);

	/* Ignore "air" regions unless wanted */
	if( tsp->ts_rtip->useair == 0 &&  tsp->ts_aircode != 0 )  {
		tsp->ts_rtip->rti_air_discards++;
		return(-1);	/* drop this region */
	}
	return(0);
}

static union tree *
unprep_reg_end( struct db_tree_state *tsp,
		  struct db_full_path *pathp,
		  union tree *tree,
		  genptr_t client_data )
{
	return( (union tree *)NULL );
}

static union tree *
unprep_leaf( struct db_tree_state *tsp,
	     struct db_full_path *pathp,
	     struct rt_db_internal *ip,
	     genptr_t client_data )
{
	register struct soltab	*stp;
	struct directory	*dp;
	register matp_t		mat;
	struct rt_i		*rtip;
	struct bu_list		*mid;
	struct rt_reprep_obj_list *objs=(struct rt_reprep_obj_list *)client_data;

	RT_CK_DBTS(tsp);
	RT_CK_DBI(tsp->ts_dbip);
	RT_CK_FULL_PATH(pathp);
	RT_CK_DB_INTERNAL(ip);
	rtip = tsp->ts_rtip;
	RT_CK_RTI(rtip);
	RT_CK_RESOURCE(tsp->ts_resp);
	dp = DB_FULL_PATH_CUR_DIR(pathp);

	/* Determine if this matrix is an identity matrix */

	if( !bn_mat_is_equal(tsp->ts_mat, bn_mat_identity, &rtip->rti_tol)) {
		/* Not identity matrix */
		mat = (matp_t)tsp->ts_mat;
	} else {
		/* Identity matrix */
		mat = (matp_t)0;
	}

	/* find corresponding soltab structure */
	mid = BU_LIST_FIRST( bu_list, &dp->d_use_hd );
	while( mid != &dp->d_use_hd ) {
		stp = BU_LIST_MAIN_PTR( soltab, mid, l2 );
		RT_CK_SOLTAB(stp);

		mid = BU_LIST_PNEXT( bu_list, mid );

		if( ((mat == (matp_t)0) && (stp->st_matp == (matp_t)0) ) ||
		    bn_mat_is_equal( mat, stp->st_matp, &rtip->rti_tol ) ) {
			if( stp->st_rtip == rtip ) {
				long bit=stp->st_bit;
				struct region *rp;
				int i,j;

				/* found soltab for this instance */

				/* check all regions using this soltab
				 * add any that are below an object to be unprepped
				 * to the "unprep_regions" list
				 */
				for( i=0 ; i<BU_PTBL_LEN( &stp->st_regions ) ; i++ ) {
					rp = (struct region *)BU_PTBL_GET( &stp->st_regions, i );
					for( j=0 ; j<objs->nunprepped ; j++ ) {
						if( obj_in_path( rp->reg_name, objs->unprepped[j] ) ) {
							/* this region has an unprep object
							 * in its path */
							bu_ptbl_ins_unique( &objs->unprep_regions, (long *)rp );
							bu_ptbl_rm( &stp->st_regions, (long *)rp );
							break;
						}
					}
				}
				if( stp->st_uses <= 1 ) {
					/* soltab structure will actually be freed */
					remove_from_bsp( stp, &rtip->rti_inf_box, &rtip->rti_tol );
					remove_from_bsp( stp, &rtip->rti_CutHead, &rtip->rti_tol );
					rtip->rti_Solids[bit] = (struct soltab *)NULL;
				}
				rt_free_soltab( stp );
				return( (union tree *)NULL );
			}
		}
	}

	bu_log( "rt_unprep(): Failed to find soltab structure for an instance of %s\n", dp->d_namep );
	bu_bomb( "rt_unprep(): Failed to find soltab structure for a solid instance\n");

	return( (union tree *)NULL );
}


/*			R T _ U N P R E P
 *
 *	This routine "unpreps" the list of object names that appears in the "unprepped" list
 *	of the "objs" structure.
 */
int
rt_unprep( struct rt_i *rtip, struct rt_reprep_obj_list *objs, struct resource *resp )
{
	struct bu_ptbl paths;
	struct bu_ptbl unprep_regions;
	struct db_full_path *path;
	int i,j,k;

	rt_res_pieces_clean( resp, rtip );

	/* find all paths from top objects to objects being unprepped */
	bu_ptbl_init( &objs->paths, 5, "paths" );
	for( i=0 ; i<objs->ntopobjs ; i++ ) {
		struct directory *start, *end;

		start = db_lookup( rtip->rti_dbip, objs->topobjs[i], 1 );
		if( start == DIR_NULL ) {
			for( k=0 ; k<BU_PTBL_END(&objs->paths) ; k++ ) {
				path = (struct db_full_path *)BU_PTBL_GET( &objs->paths, k );
				db_free_full_path( path );
			}
			bu_ptbl_free( &objs->paths );
			return( 1 );
		}
		for( j=0 ; j<objs->nunprepped ; j++ ) {
			end = db_lookup( rtip->rti_dbip, objs->unprepped[j], 1 );
			if( end == DIR_NULL ) {
				for( k=0 ; k<BU_PTBL_END(&objs->paths) ; k++ ) {
					path = (struct db_full_path *)BU_PTBL_GET( &objs->paths, k );
					db_free_full_path( path );
				}
				bu_ptbl_free( &objs->paths );
				return( 1 );
			}
			rt_find_paths( rtip->rti_dbip, start, end, &objs->paths, resp );
		}
	}

	if( BU_PTBL_LEN( &objs->paths ) < 1 ) {
		bu_log( "rt_unprep(): Failed to find any paths to objects to reprep!!\n" );
		bu_ptbl_free( &objs->paths );
	}

	/* accumulate state along each path */
	objs->tsp = (struct db_tree_state **)bu_calloc(
				  BU_PTBL_LEN( &objs->paths ),
				  sizeof( struct db_tree_state *),
				  "objs->tsp" );

	bu_ptbl_init( &objs->unprep_regions, 5, "unprep_regions" );

	for( i=0 ; i<BU_PTBL_LEN( &objs->paths ) ; i++ ) {
		struct db_full_path another_path;
		struct db_tree_state	*tree_state;
		char			*obj_name;

		tree_state = (struct db_tree_state *)bu_malloc( sizeof( struct db_tree_state ),
								"tree_state" );
		*tree_state = rt_initial_tree_state;	/* struct copy */
		tree_state->ts_dbip = rtip->rti_dbip;
		tree_state->ts_resp = resp;
		tree_state->ts_rtip = rtip;
		tree_state->ts_tol = &rtip->rti_tol;
		objs->tsp[i] = tree_state;

		db_full_path_init( &another_path );
		path = (struct db_full_path *)BU_PTBL_GET( &objs->paths, i );
		if( db_follow_path( tree_state, &another_path, path, 1, 0 ) ) {
			bu_log( "rt_unprep(): db_follow_path failed!!\n" );
			for( k=0 ; k<BU_PTBL_END(&paths) ; k++ ) {
				if( objs->tsp[k] ) {
					db_free_db_tree_state( objs->tsp[k] );
					bu_free( (char *)objs->tsp[k], "tree_state" );
				}
				path = (struct db_full_path *)BU_PTBL_GET( &objs->paths, k );
				db_free_full_path( path );
			}
			bu_ptbl_free( &paths );
			bu_ptbl_free( &unprep_regions );
			return( 1 );
		}
		db_free_full_path( &another_path );

		/* walk tree starting from "unprepped" object,
		 * using the appropriate tree_state.
		 * unprep solids and regions along the way
		 */
		obj_name = DB_FULL_PATH_CUR_DIR(path)->d_namep;
		if( db_walk_tree( rtip->rti_dbip, 1, (const char **)&obj_name, 1, tree_state,
				  unprep_reg_start, unprep_reg_end, unprep_leaf,
				  (genptr_t)objs ) ) {
			bu_log( "rt_unprep(): db_walk_tree failed!!!\n" );
			for( k=0 ; k<BU_PTBL_END(&paths) ; k++ ) {
				if( objs->tsp[k] ) {
					db_free_db_tree_state( objs->tsp[k] );
					bu_free( (char *)objs->tsp[k], "tree_state" );
				}
				path = (struct db_full_path *)BU_PTBL_GET( &objs->paths, k );
				db_free_full_path( path );
			}
			bu_ptbl_free( &paths );
			bu_ptbl_free( &unprep_regions );
			return( 1 );
		}

		db_free_db_tree_state( tree_state );
		bu_free( (char *)tree_state, "tree_state" );
	}

	/* eliminate regions to be unprepped */
	objs->nregions_unprepped = BU_PTBL_LEN( &objs->unprep_regions );
	for( i=0 ; i<BU_PTBL_LEN( &objs->unprep_regions ) ; i++ ) {
		struct region *rp;

		rp = (struct region *)BU_PTBL_GET( &objs->unprep_regions, i );
		BU_LIST_DEQUEUE( &rp->l );
		rtip->Regions[rp->reg_bit] = (struct region *)NULL;

		/* XXX
		   db_free_tree( rp->reg_treetop, resp ); */
		bu_free( (genptr_t)rp->reg_name, "region name str");
		rp->reg_name = (char *)0;
		if( rp->reg_mater.ma_shader )
		{
			bu_free( (genptr_t)rp->reg_mater.ma_shader, "ma_shader" );
			rp->reg_mater.ma_shader = (char *)NULL;
		}
		if( rp->attr_values ) {
			i = 0;
			while( rp->attr_values[i] ) {
				bu_mro_free( rp->attr_values[i] );
				i++;
			}
			bu_free( (char *)rp->attr_values, "rp->attr_values" );
		}
		bu_free( (genptr_t)rp, "struct region");
	}

	/* eliminate NULL region structures */
	objs->old_nregions = rtip->nregions;
	i = 0;
	while( i < rtip->nregions ) {
		int nulls=0;

		while( i < rtip->nregions && !rtip->Regions[i] ) {
			i++;
			nulls++;
		}

		if( nulls ) {
			rtip->nregions -= nulls;
			for( j=i-nulls ; j<rtip->nregions ; j++ ) {
				rtip->Regions[j] = rtip->Regions[j+nulls];
				if( rtip->Regions[j] ) {
					rtip->Regions[j]->reg_bit = j;
				}
			}
			nulls = 0;
		} else {
			i++;
		}
	}

	/* eliminate NULL soltabs */
	objs->old_nsolids = rtip->nsolids;
	objs->nsolids_unprepped = 0;
	i = 0;
	while( i < rtip->nsolids) {
		int nulls=0;

		while( i < rtip->nsolids && !rtip->rti_Solids[i] ) {
			objs->nsolids_unprepped++;
			i++;
			nulls++;
		}
		if( nulls ) {
			for( j=i-nulls ; j+nulls<rtip->nsolids ; j++ ) {
				rtip->rti_Solids[j] = rtip->rti_Solids[j+nulls];
				if( rtip->rti_Solids[j] ) {
					rtip->rti_Solids[j]->st_bit = j;
				}
			}
			rtip->nsolids -= nulls;
			i -= nulls;
		} else {
			i++;
		}
	}

	return( 0 );
}

/*			R T _ R E P R E P
 *	This routine "re-preps" the list of objects specified in the "unprepped" list of the
 *	"objs" structure. This structure must previously have been passed to "rt_unprep"
 */
int
rt_reprep( struct rt_i *rtip, struct rt_reprep_obj_list *objs, struct resource *resp )
{
	int i;
	char **argv;
	struct region *rp;
	struct soltab *stp;
	fastf_t old_min[3], old_max[3];
	int model_extremes_have_changed=0;
	long bitno;

	VMOVE( old_min, rtip->mdl_min );
	VMOVE( old_max, rtip->mdl_max );

	rtip->needprep = 1;

	argv = (char **)bu_calloc( BU_PTBL_LEN( &(objs->paths) ), sizeof( char *), "argv" );
	for( i=0 ; i<BU_PTBL_LEN( &(objs->paths) ) ; i++ ) {
		argv[i] = db_path_to_string( (const struct db_full_path *)BU_PTBL_GET( &(objs->paths), i ));
	}

	rtip->rti_add_to_new_solids_list = 1;
	bu_ptbl_init( &rtip->rti_new_solids, 128, "rti_new_solids" );
	if( rt_gettrees( rtip, BU_PTBL_LEN( &(objs->paths) ), (const char **)argv, 1 ) ) {
		return( 1 );
	}
	rtip->rti_add_to_new_solids_list = 0;

	for( i=0 ; i<BU_PTBL_LEN( &(objs->paths) ) ; i++ ) {
		bu_free( argv[i], "argv[i]" );
	}
	bu_free( (char *)argv, "argv" );

	rtip->needprep = 0;

	if( rtip->nregions > objs->old_nregions ) {
		rtip->Regions = (struct region **)bu_realloc( rtip->Regions,
				     rtip->nregions * sizeof( struct region *), "rtip->Regions" );
		memset( rtip->Regions, 0, rtip->nregions );
	}


	bitno = 0;
	for( BU_LIST_FOR( rp, region, &(rtip->HeadRegion) ) ) {
		rp->reg_bit = bitno;
		rtip->Regions[bitno] = rp;
		if( bitno >= objs->old_nregions - objs->nregions_unprepped ) {
			point_t region_min, region_max;

			if( rt_bound_tree( rp->reg_treetop, region_min, region_max ) ) {
				bu_log( "rt_reprep(): rt_bound_tree() FAILED for %s\n",
					rp->reg_name );
				bu_bomb( "rt_reprep(): rt_bound_tree() FAILED\n" );
			}
			if( region_max[X] < INFINITY )  {
				/* infinite regions are exempted from this */
				VMINMAX( rtip->mdl_min, rtip->mdl_max, region_min );
				VMINMAX( rtip->mdl_min, rtip->mdl_max, region_max );
			}
			rt_solid_bitfinder( rp->reg_treetop, rp, resp );
		}
		bitno++;
	}

	if( rtip->nsolids > objs->old_nsolids ) {
		rtip->rti_Solids = (struct soltab **)bu_realloc( rtip->rti_Solids,
								 rtip->nsolids * sizeof( struct soltab *),
								 "rtip->rti_Solids" );
		memset( rtip->rti_Solids, 0, rtip->nsolids );
	}

	bitno = 0;
	RT_VISIT_ALL_SOLTABS_START( stp, rtip )  {
		stp->st_bit = bitno;
		rtip->rti_Solids[bitno] = stp;
		bitno++;
		
	} RT_VISIT_ALL_SOLTABS_END

	for( i=0 ; i<BU_PTBL_LEN( &rtip->rti_new_solids ) ; i++ ) {
		stp = (struct soltab * )BU_PTBL_GET( &rtip->rti_new_solids, i );
		if( stp->st_aradius >= INFINITY ) {
			insert_in_bsp( stp, &rtip->rti_inf_box );
		} else {
			insert_in_bsp( stp, &rtip->rti_CutHead );
		}
	}

	bu_ptbl_free( &rtip->rti_new_solids );

	for( i=0 ; i<3 ; i++ ) {
		if( rtip->mdl_min[i] != old_min[i] ) {
			model_extremes_have_changed = 1;
			break;
		}
		if( rtip->mdl_max[i] != old_max[i] ) {
			model_extremes_have_changed = 1;
			break;
		}
	}

	if( model_extremes_have_changed ) {
		/* fill out BSP, it must completely fill the model BB */
		fastf_t bb[6];

		VSETALL( bb, INFINITY );
		VSETALL( &bb[3], -INFINITY );
		fill_out_bsp( rtip, &rtip->rti_CutHead, resp, bb );
	}

	if( BU_PTBL_LEN( &rtip->rti_resources ) ) {
		for( i=0 ; i<BU_PTBL_LEN( &rtip->rti_resources ) ; i++ ) {
			struct resource *re;

			re = (struct resource *)BU_PTBL_GET( &rtip->rti_resources, i );
			if( re && rtip->rti_nsolids_with_pieces )
				rt_res_pieces_init( re, rtip );
		}
	} else if( rtip->rti_nsolids_with_pieces ) {
		rt_res_pieces_init( &rt_uniresource, rtip );
	}

	return( 0 );
@


11.76
log
@Converted from K&R to ANSI C - RFH
@
text
@d44 1
a44 1
HIDDEN void	rt_solid_bitfinder(register union tree *treep, struct region *regp, struct resource *resp);
d58 2
a59 1
rt_new_rti(struct db_i *dbip)
d142 2
a143 1
rt_free_rti(struct rt_i *rtip)
d188 3
a190 1
rt_prep_parallel(register struct rt_i *rtip, int ncpu)
d417 2
a418 1
rt_prep(register struct rt_i *rtip)
d431 3
a433 1
rt_plot_all_bboxes(FILE *fp, struct rt_i *rtip)
d670 3
a672 1
rt_clean_resource(struct rt_i *rtip, struct resource *resp)
d776 2
a777 1
rt_clean(register struct rt_i *rtip)
d979 4
a982 1
rt_solid_bitfinder(register union tree *treep, struct region *regp, struct resource *resp)
d1036 2
a1037 1
rt_ck(register struct rt_i *rtip)
@


11.75
log
@Eliminated space partitioning space used printout
@
text
@d21 1
a21 1
static const char RCSprep[] = "@@(#)$Header: /c/CVS/brlcad/librt/prep.c,v 11.74 2002/05/29 15:02:57 jra Exp $ (BRL)";
d44 1
a44 1
HIDDEN void	rt_solid_bitfinder();
d58 1
a58 2
rt_new_rti( dbip )
struct db_i	*dbip;
d141 1
a141 2
rt_free_rti( rtip )
struct rt_i	*rtip;
d186 1
a186 3
rt_prep_parallel(rtip, ncpu)
register struct rt_i	*rtip;
int			ncpu;
d413 1
a413 2
rt_prep(rtip)
register struct rt_i *rtip;
d426 1
a426 3
rt_plot_all_bboxes( fp, rtip )
FILE		*fp;
struct rt_i	*rtip;
d663 1
a663 3
rt_clean_resource( rtip, resp )
struct rt_i	*rtip;
struct resource	*resp;
d767 1
a767 2
rt_clean( rtip )
register struct rt_i *rtip;
d969 1
a969 4
rt_solid_bitfinder( treep, regp, resp )
register union tree	*treep;
struct region		*regp;
struct resource		*resp;
d1023 1
a1023 2
rt_ck( rtip )
register struct rt_i	*rtip;
@


11.74
log
@Added log message about memory used by space partitioning
@
text
@d21 1
a21 1
static const char RCSprep[] = "@@(#)$Header: /c/CVS/brlcad/librt/prep.c,v 11.73 2002/02/20 16:18:51 jra Exp $ (BRL)";
a196 1
	char *sbrk_start, *sbrk_end;
a365 1
	sbrk_start = sbrk( 0 );
a380 4

	sbrk_end = sbrk( 0 );

	bu_log( "space partition used %ld bytes\n", (long)(sbrk_end - sbrk_start) );
@


11.73
log
@rt_clean_resource() now frees its list of union tree structs
@
text
@d21 1
a21 1
static const char RCSprep[] = "@@(#)$Header: /c/CVS/brlcad/librt/prep.c,v 11.72 2002/02/20 16:02:22 jra Exp $ (BRL)";
d40 1
d197 1
d367 1
d383 4
@


11.72
log
@rt_clean() now frees the ORCA component hash table
@
text
@d21 1
a21 1
static const char RCSprep[] = "@@(#)$Header: /c/CVS/brlcad/librt/prep.c,v 11.71 2002/01/10 18:12:41 butler Exp $ (BRL)";
d735 12
@


11.71
log
@Changed word "solids" to indicate "prims" or primitives"
@
text
@d21 1
a21 1
static const char RCSprep[] = "@@(#)$Header: /c/CVS/brlcad/librt/prep.c,v 11.70 2001/05/17 20:05:25 morrison Exp $ (BRL)";
d872 5
@


11.70
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d21 1
a21 1
static const char RCSprep[] = "@@(#)$Header: /c/CVS/brlcad/librt/prep.c,v 11.69 2001/05/11 15:32:17 jra Exp $ (BRL)";
d214 1
a214 1
			bu_log("rt_prep_parallel(%s,%d): %d solids discarded due to air regions\n",
d218 1
a218 1
		rt_bomb("rt_prep_parallel:  no solids left to prep");
d223 1
a223 1
		bu_log("All solids are halfspaces, setting minimum\n");
d227 1
a227 1
		bu_log("All solids are halfspaces, setting maximum\n");
d274 1
a274 1
		bu_log("rt_prep_parallel() printing solids' region pointers\n");
d330 1
a330 1
		bu_log("rt_prep_parallel(%s,%d) printing number of solids by type\n",
@


11.69
log
@Added rt_load_attrs()
@
text
@d21 1
a21 1
static const char RCSprep[] = "@@(#)$Header: /c/CVS/brlcad/librt/prep.c,v 11.68 2001/05/08 20:12:21 jra Exp $ (BRL)";
d199 1
a199 1
	if(rt_g.debug&DEBUG_REGIONS)  bu_log("rt_prep_parallel(%s,%d,ncpu=%d) START\n",
d259 1
a259 1
	if(rt_g.debug&DEBUG_REGIONS)  bu_log("rt_prep_parallel(%s,%d) about to optimize regions\n",
d268 1
a268 1
		if(rt_g.debug&DEBUG_REGIONS)  {
d273 1
a273 1
	if(rt_g.debug&DEBUG_REGIONS)  {
d329 1
a329 1
	if( rt_g.debug & (DEBUG_DB|DEBUG_SOLIDS) )  {
d382 1
a382 1
	if( (rt_g.debug&DEBUG_PLOTBOX) )  {
d394 1
a394 1
	if( (rt_g.debug&DEBUG_PLOTSOLIDS) )  {
d405 1
a405 1
	if(rt_g.debug&DEBUG_REGIONS)  bu_log("rt_prep_parallel(%s,%d,ncpu=%d) FINISH\n",
d932 1
a932 1
	if( rt_g.debug & DEBUG_REGIONS )
@


11.68
log
@rt_clean() and rt_del_regtree() now free the regions MRO attributes
@
text
@d21 1
a21 1
static const char RCSprep[] = "@@(#)$Header: /c/CVS/brlcad/librt/prep.c,v 11.67 2001/03/19 22:19:58 butler Exp $ (BRL)";
d1039 94
@


11.67
log
@patches to merge 5.3 into 6.0
@
text
@d21 1
a21 1
static const char RCSprep[] = "@@(#)$Header: /d/CVS/brlcad/librt/prep.c,v 11.66 2001/02/23 20:21:23 jra Exp $ (BRL)";
d793 8
d941 8
@


11.66
log
@Default raytracing tolerance for librt is now 0.0005
@
text
@d21 1
a21 1
static const char RCSprep[] = "@@(#)$Header: /c/CVS/brlcad/librt/prep.c,v 11.65 2000/11/14 21:13:22 jra Exp $ (BRL)";
d745 1
a745 1
	/* Release the state variables for 'solid pieces' */
@


11.65
log
@Eliminated pmalloc (a failed experiment)
@
text
@d21 1
a21 1
static const char RCSprep[] = "@@(#)$Header: /c/CVS/brlcad/librt/prep.c,v 11.64 2000/09/21 04:49:25 mike Exp $ (BRL)";
d94 1
a94 1
	rtip->rti_tol.dist = 0.005;
@


11.64
log
@
Check for null resource pointer.
@
text
@d21 1
a21 1
static const char RCSprep[] = "@@(#)$Header: /c/CVS/brlcad/librt/prep.c,v 11.63 2000/09/20 03:10:32 mike Exp $ (BRL)";
a587 1
	int i;
a624 11
	if( !resp->re_pmem.buckets[0].q_forw )
	{
		for( i=0 ; i<RT_PM_NBUCKETS ; i++ )
		{
			resp->re_pmem.buckets[i].q_forw = &resp->re_pmem.buckets[i];
			resp->re_pmem.buckets[i].q_back = &resp->re_pmem.buckets[i];
		}
		resp->re_pmem.adjhead.q_forw = &resp->re_pmem.adjhead;
		resp->re_pmem.adjhead.q_back = &resp->re_pmem.adjhead;
	}

a742 4
	}

	if( !resp->re_pmem.buckets[0].q_forw )  {
		/* XXX How to release the pmalloc buckets? */
@


11.63
log
@
More complex handling of the rt_uniresource special case.
@
text
@d21 1
a21 1
static const char RCSprep[] = "@@(#)$Header: /c/CVS/brlcad/librt/prep.c,v 11.62 2000/09/08 05:54:42 mike Exp $ (BRL)";
d594 1
@


11.62
log
@
Modified tree routines to take resource pointer.
@
text
@d21 1
a21 1
static const char RCSprep[] = "@@(#)$Header: /c/CVS/brlcad/librt/prep.c,v 11.61 2000/09/07 01:06:43 mike Exp $ (BRL)";
d580 1
a580 1
 *  Special case, resp == rt_uniresource, no rtip is required.
d590 8
a597 1
	if( resp != &rt_uniresource )  RT_CK_RTI(rtip);
d639 1
a639 1
	if( resp == &rt_uniresource )  return;
@


11.61
log
@
resource handling
@
text
@d21 1
a21 1
static const char RCSprep[] = "@@(#)$Header: /c/CVS/brlcad/librt/prep.c,v 11.60 2000/09/01 22:16:14 mike Exp $ (BRL)";
d148 19
d398 1
a398 1
			rt_plot_all_solids( plotfp, rtip );
d452 4
a455 3
rt_plot_all_solids( fp, rtip )
FILE		*fp;
struct rt_i	*rtip;
d471 1
a471 1
		(void)rt_plot_solid( fp, rtip, stp );
d486 5
a490 4
rt_vlist_solid( vhead, rtip, stp )
struct rt_i		*rtip;
struct soltab		*stp;
struct bu_list		*vhead;
d494 1
a494 1
	if( rt_db_get_internal( &intern, stp->st_dp, rtip->rti_dbip, stp->st_matp ) < 0 )  {
d509 1
a509 1
		rt_db_free_internal( &intern );
d512 1
a512 1
	rt_db_free_internal( &intern );
d528 5
a532 4
rt_plot_solid( fp, rtip, stp )
register FILE		*fp;
struct rt_i		*rtip;
struct soltab		*stp;
d542 1
a542 1
	if( rt_vlist_solid( &vhead, rtip, stp ) < 0 )  {
d574 7
d583 4
a586 3
rt_init_resource( resp, cpu_num )
struct resource *resp;
int		cpu_num;
d590 2
d603 3
d631 17
d667 4
d689 1
a689 1
			bu_free( (genptr_t)(*spp), "struct seg" );
d694 5
d757 1
a757 1
	rt_init_resource( resp, resp->re_cpu );
d793 1
a793 1
		db_free_tree( regp->reg_treetop );
d864 4
d870 1
d928 1
a928 3
rt_del_regtree( rtip, delregp )
struct rt_i *rtip;
register struct region *delregp;
d930 2
d937 1
a937 1
	db_free_tree( delregp->reg_treetop );
d1018 2
@


11.60
log
@
Changed name prefix.
@
text
@d21 1
a21 1
static const char RCSprep[] = "@@(#)$Header: /c/CVS/brlcad/librt/prep.c,v 11.59 2000/07/13 02:36:27 cjohnson Exp $ (BRL)";
d81 2
a82 2
	bu_ptbl_init( &rtip->rti_resources, MAX_PSW, "rti_resources ptbl" );
	BU_PTBL_END(&rtip->rti_resources) = MAX_PSW;	/* Make 'em all available */
@


11.59
log
@LINT from gcc -Wall
@
text
@d21 1
a21 1
static const char RCSprep[] = "@@(#)$Header: /c/CVS/brlcad/librt/prep.c,v 11.58 2000/07/12 00:39:14 mike Exp $ (BRL)";
a463 2
 *
 *  XXX This shouldn't be bn_, but rt_!
d466 1
a466 1
bn_vlist_solid( vhead, rtip, stp )
d474 1
a474 1
		bu_log("bn_vlist_solid(%s): rt_db_get_internal() failed\n",
d486 1
a486 1
		bu_log("bn_vlist_solid(%s): ft_plot() failure\n",
d520 2
a521 2
	if( bn_vlist_solid( &vhead, rtip, stp ) < 0 )  {
		bu_log("rt_plot_solid(%s): bn_vlist_solid() failed\n",
@


11.58
log
@
No longer needs db.h
@
text
@d21 1
a21 1
static const char RCSprep[] = "@@(#)$Header: /c/CVS/brlcad/librt/prep.c,v 11.57 2000/07/10 23:01:47 mike Exp $ (BRL)";
d38 1
@


11.57
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d21 1
a21 1
static const char RCSprep[] = "@@(#)$Header: /c/CVS/brlcad/librt/prep.c,v 11.56 2000/06/30 15:27:09 pjt Exp $ (BRL)";
a36 1
#include "db.h"
@


11.56
log
@Changed ID_MAXIMUM to ID_MAX_SOLID
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /c/CVS/brlcad/librt/prep.c,v 11.55 2000/05/12 19:10:38 mike Exp $ (BRL)";
@


11.55
log
@
Moved bounding plot-box code from cut.c to prep.c
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /c/CVS/brlcad/librt/prep.c,v 11.54 2000/05/12 01:37:21 mike Exp $ (BRL)";
d291 1
a291 1
	for( i=0; i <= ID_MAXIMUM; i++ )  {
d296 1
a296 1
	for( i=0; i <= ID_MAXIMUM; i++ )  {
d314 1
a314 1
		for( i=1; i <= ID_MAXIMUM; i++ )  {
d777 1
a777 1
	for( i=0; i <= ID_MAXIMUM; i++ )  {
@


11.55.2.1
log
@Eliminated pmalloc (a failed experiment)
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /c/CVS/brlcad/librt/prep.c,v 11.55 2000/05/12 19:10:38 mike Exp $ (BRL)";
d585 11
d690 5
a694 1
/* Release the state variables for 'solid pieces' */
@


11.54
log
@
Release storage associated with solid pieces.
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /c/CVS/brlcad/librt/prep.c,v 11.53 2000/05/12 01:10:59 mike Exp $ (BRL)";
d324 21
@


11.53
log
@
Call rt_res_pieces_clean()
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /c/CVS/brlcad/librt/prep.c,v 11.52 2000/04/12 02:34:38 mike Exp $ (BRL)";
d325 5
a329 2
	/* Partition space */
	/* This is the only part which uses multiple CPUs */
d332 8
@


11.52
log
@NT port, non-compat4
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /c/CVS/brlcad/librt/prep.c,v 11.51 2000/02/29 20:34:37 mike Exp $ (BRL)";
d661 3
@


11.51
log
@
Initialized rti_max_beam_radius
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /c/CVS/brlcad/librt/prep.c,v 11.50 2000/01/29 04:23:38 mike Exp $ (BRL)";
d66 1
a66 1
	if( BU_LIST_FIRST( rt_list, &rt_g.rtg_vlfree ) == 0 )  {
@


11.50
log
@Fixed the 2 bugs that Lee detected while doing the Impact Flash
animation:

1)  Progressively fewer instanced solids were having their stp
re-referenced because d_uses was not being zeroed by the "clean" command
in the animation script at the start of each new frame.

2) rt_clean() wasn't calling rt_clean_resource() for the per-CPU
resource structures (including the list of bu_bitv structures used for
re_solid_bitv) because of using the wrong macro to see if there were any
to do.  While fixing it I changed tactics so that a semaphored critical
section is no longer needed for this.
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /c/CVS/brlcad/librt/prep.c,v 11.49 2000/01/14 22:30:39 mike Exp $ (BRL)";
d103 2
@


11.49
log
@
Added some extra debugging code for st_bit uniqueness.
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /c/CVS/brlcad/librt/prep.c,v 11.48 2000/01/12 01:41:15 mike Exp $ (BRL)";
d82 1
d149 1
d226 2
a227 4
	if( BU_PTBL_LEN( &rtip->rti_resources ) > 0 )
		resp = (struct resource *)BU_PTBL_GET(&rtip->rti_resources, 0);
	else
		resp = &rt_uniresource;
d633 1
d711 1
d757 1
a757 1
	if( BU_LIST_IS_INITIALIZED( &rtip->rti_resources.l ) )  {
d768 2
a770 2
		/* Forget the remembered pointers, but keep ptbl ready */
		bu_ptbl_trunc( &rtip->rti_resources, 0 );
d789 21
@


11.48
log
@
Major performance boost to the submodel, by using rti_resource to
hold an array of resource structures, one per cpu.
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /c/CVS/brlcad/librt/prep.c,v 11.47 2000/01/11 21:34:45 mike Exp $ (BRL)";
a48 1

d243 1
a243 1
		BU_ASSERT(rtip->Regions[regp->reg_bit] == REGION_NULL);
d275 8
a282 1
		BU_ASSERT(*ssp == SOLTAB_NULL);
@


11.47
log
@
Added DEBUG_PLOTSOLIDS
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /c/CVS/brlcad/librt/prep.c,v 11.46 1999/12/30 04:57:00 mike Exp $ (BRL)";
d753 4
@


11.46
log
@
Additional datastructures to support the submodel.
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /c/CVS/brlcad/librt/prep.c,v 11.45 1999/12/28 23:33:59 mike Exp $ (BRL)";
d335 1
a335 1
	if( (rt_g.debug&DEBUG_PLOTBOX) )  {
@


11.45
log
@
Additional debugging and logging
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /c/CVS/brlcad/librt/prep.c,v 11.44 1999/12/23 06:00:04 mike Exp $ (BRL)";
d54 2
d76 1
a76 1
	rtip->rti_dbip = dbip;
a77 1
	dbip->dbi_uses++;
d146 1
a146 1
	db_close( rtip->rti_dbip );
@


11.44
log
@
struct region is now a bu_list
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /c/CVS/brlcad/librt/prep.c,v 11.43 1999/11/26 20:49:33 mike Exp $ (BRL)";
d176 4
d182 3
a184 1
		bu_log("WARNING: rt_prep() invoked a second time, ignored");
d191 5
a195 2
			bu_log("rt_prep: %d solids discarded due to air regions\n", rtip->rti_air_discards );
		rt_bomb("rt_prep:  no solids left to prep");
d235 2
a236 2
	rtip->Regions = (struct region **)bu_malloc(
		rtip->nregions * sizeof(struct region *),
d238 3
d242 2
d253 1
d273 4
a276 1
		rtip->rti_Solids[stp->st_bit] = stp;
d301 4
a304 1
	if( rt_g.debug & DEBUG_DB )  {
d344 4
d798 1
a798 1
		bu_log("Del Region %s\n", delregp->reg_name);
@


11.43
log
@
Comment
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /c/CVS/brlcad/librt/prep.c,v 11.42 1999/11/12 20:54:17 mike Exp $ (BRL)";
d78 2
d229 1
a229 1
	for( regp=rtip->HeadRegion; regp != REGION_NULL; regp=regp->reg_forw )  {
d653 1
a653 1
	for( regp=rtip->HeadRegion; regp != REGION_NULL; regp=regp->reg_forw )  {
d661 1
a661 3
	for( regp=rtip->HeadRegion; regp != REGION_NULL; )  {
		register struct region *nextregp = regp->reg_forw;

d663 1
a671 1

a672 1
		regp = nextregp;
a673 1
	rtip->HeadRegion = REGION_NULL;
a764 1
 *	-1	if unable to find indicated region
a771 4
	register struct region *regp;
	register struct region *nextregp;

	regp = rtip->HeadRegion;
d775 1
a775 4
	if( regp == delregp )  {
		rtip->HeadRegion = regp->reg_forw;
		goto zot;
	}
a776 10
	for( ; regp != REGION_NULL; regp=nextregp )  {
		nextregp=regp->reg_forw;
		if( nextregp == delregp )  {
			regp->reg_forw = nextregp->reg_forw;	/* unlink */
			goto zot;
		}
	}
	bu_log("rt_del_region:  unable to find %s\n", delregp->reg_name);
	return(-1);
zot:
d863 1
a863 1
	for( regp=rtip->HeadRegion; regp != REGION_NULL; regp=regp->reg_forw )  {
@


11.42
log
@
Changed from pt_solids_hit to pt_seglist; more general.
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /c/CVS/brlcad/librt/prep.c,v 11.41 1999/06/03 01:57:01 mike Exp $ (BRL)";
d396 2
@


11.41
log
@
sed4 oops fixes
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /c/CVS/brlcad/librt/prep.c,v 11.40 1999/06/03 01:55:15 mike Exp $ (BRL)";
d586 1
a586 1
			bu_ptbl_free( &pp->pt_solids_hit );
@


11.40
log
@
Another sed4 oops
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /c/CVS/brlcad/librt/prep.c,v 11.39 1999/06/03 01:54:25 mike Exp $ (BRL)";
d472 1
a472 1
	bn_vlist_to_uplot( fp, &vhead );
@


11.39
log
@
sed4 oops fixed
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /c/CVS/brlcad/librt/prep.c,v 11.38 1999/06/03 01:39:15 mike Exp $ (BRL)";
d683 1
a683 1
			bu_free_soltab(stp);
@


11.38
log
@
sed4
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /c/CVS/brlcad/librt/prep.c,v 11.37 1998/03/26 08:15:32 mike Exp $ (BRL)";
d136 1
a136 1
bu_free_rti( rtip )
@


11.37
log
@Missing &
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /m/cad/librt/RCS/prep.c,v 11.36 1998/03/26 07:35:27 mike Exp mike $ (BRL)";
d136 1
a136 1
rt_free_rti( rtip )
d148 1
a148 1
	rt_free( (char *)rtip, "struct rt_i" );
d224 1
a224 1
	rtip->Regions = (struct region **)rt_malloc(
d247 1
a247 1
	rtip->rti_Solids = (struct soltab **)rt_calloc(
d269 1
a269 1
		rtip->rti_sol_by_type[i] = (struct soltab **)rt_calloc(
d398 1
a398 1
rt_vlist_solid( vhead, rtip, stp )
d406 1
a406 1
		bu_log("rt_vlist_solid(%s): rt_db_get_internal() failed\n",
d418 1
a418 1
		bu_log("rt_vlist_solid(%s): ft_plot() failure\n",
d452 2
a453 2
	if( rt_vlist_solid( &vhead, rtip, stp ) < 0 )  {
		bu_log("rt_plot_solid(%s): rt_vlist_solid() failed\n",
d472 1
a472 1
	rt_vlist_to_uplot( fp, &vhead );
d683 1
a683 1
			rt_free_soltab(stp);
d690 1
a690 1
		rt_free( (char *)rtip->Regions, "rtip->Regions[]" );
d708 1
a708 1
		rt_free( (char *)rtip->rti_sol_by_type[i], "sol_by_type" );
d712 1
a712 1
		rt_free( (char *)rtip->rti_Solids, "rtip->rti_Solids[]" );
d797 1
a797 1
	rt_free( (char *)delregp->reg_name, "region name str");
d799 1
a799 1
	rt_free( (char *)delregp, "struct region");
@


11.36
log
@Factored rt_vlist_solid out of rt_plot_solid
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /m/cad/librt/RCS/prep.c,v 11.35 1998/03/26 07:24:12 mike Exp mike $ (BRL)";
d452 1
a452 1
	if( rt_vlist_solid( vhead, rtip, stp ) < 0 )  {
@


11.35
log
@Updated rt_plot_solid() to use newer interfaces
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /m/cad/librt/RCS/prep.c,v 11.34 1998/03/26 07:17:59 mike Exp mike $ (BRL)";
d388 40
a445 2
	struct rt_db_internal		intern;
	int				rnum;
d452 2
a453 2
	if( rt_db_get_internal( &intern, stp->st_dp, rtip->rti_dbip, stp->st_matp ) < 0 )  {
		bu_log("rt_plot_solid(%s): rt_db_get_internal() failed\n",
a456 1
	RT_CK_DB_INTERNAL( &intern );
d458 2
a459 7
	if( rt_functab[intern.idb_type].ft_plot(
		&vhead,
		&intern,
		&rtip->rti_ttol,
		&rtip->rti_tol
	    ) < 0 )  {
		bu_log("rt_plot_solid(%s): ft_plot() failure\n",
d461 1
a461 2
		rt_db_free_internal( &intern );
	    	return(-2);
a462 1
	rt_db_free_internal( &intern );
d472 1
a472 5
	if( BU_LIST_IS_EMPTY( &vhead ) )  {
		bu_log("rt_plot_solid(%s): no vectors to plot?\n",
			stp->st_name);
		return(-3);		/* FAIL */
	}
a473 1
	rt_vlist_to_uplot( fp, &vhead );
@


11.34
log
@Made tessellation tolerance global, and user-setable.
Changed rt_plot_solid() to use rti_tol and rti_ttol rather than
hardwired values
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /m/cad/librt/RCS/prep.c,v 11.33 1998/03/26 07:09:09 mike Exp mike $ (BRL)";
a405 1
	struct bu_external		ext;
a406 1
	int				id = stp->st_id;
d408 3
a410 1
	matp_t				mat;
d414 2
a415 2
	if( db_get_external( &ext, stp->st_dp, rtip->rti_dbip ) < 0 )  {
		bu_log("rt_plot_solid(%s): db_get_external() failure\n",
a418 11

	if( !(mat = stp->st_matp) )
		mat = (matp_t)bn_mat_identity;
    	RT_INIT_DB_INTERNAL(&intern);
	if( rt_functab[id].ft_import( &intern, &ext, mat, rtip->rti_dbip ) < 0 )  {
		bu_log("rt_plot_solid(%s):  solid import failure\n",
			stp->st_name );
	    	if( intern.idb_ptr )  rt_functab[id].ft_ifree( &intern );
		db_free_external( &ext );
		return(-1);			/* FAIL */
	}
d421 1
a421 1
	if( rt_functab[id].ft_plot(
d429 1
a429 2
	    	if( intern.idb_ptr )  rt_functab[id].ft_ifree( &intern );
		db_free_external( &ext );
d432 1
a432 2
	rt_functab[id].ft_ifree( &intern );
	db_free_external( &ext );
@


11.33
log
@Moved rt_new_rti() and rt_free_rti() from dir.c to prep.c
to make it easier to parcel out who does what.
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /m/cad/librt/RCS/prep.c,v 11.32 1998/03/26 06:52:21 mike Exp mike $ (BRL)";
d89 1
a89 1
	/* XXX These need to be improved */
d96 5
a409 2
	struct rt_tess_tol		ttol;
	struct bn_tol			tol;
a431 12
	ttol.magic = RT_TESS_TOL_MAGIC;
	ttol.abs = 0.0;
	ttol.rel = 0.01;
	ttol.norm = 0;

	/* XXX These need to be improved */
	tol.magic = BN_TOL_MAGIC;
	tol.dist = 0.005;
	tol.dist_sq = tol.dist * tol.dist;
	tol.perp = 1e-6;
	tol.para = 1 - tol.perp;

d435 2
a436 2
		&ttol,
		&tol
@


11.32
log
@Took advantage of BU_LIST_IS_INITIALIZED macro.
In the process, discovered that half the old tests were backwards!!!
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /m/cad/librt/RCS/prep.c,v 11.31 1998/03/26 06:45:23 mike Exp mike $ (BRL)";
d46 99
@


11.31
log
@renamed rt_free_resource()
to be rt_clean_resource(), as that is all it does, and I've added some
clarifying comments.  Also, it makes more sense to truncate the
rti_resources ptbl than to free it as part of the cleanup operation.
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /m/cad/librt/RCS/prep.c,v 11.30 1998/03/24 08:30:24 mike Exp mike $ (BRL)";
d395 1
a395 1
	if( !BU_LIST_UNINITIALIZED( &resp->re_seg ) )
d398 1
a398 1
	if( !BU_PTBL_TEST( &resp->re_seg_blocks ) )
d401 1
a401 1
	if( !BU_LIST_UNINITIALIZED( &resp->re_parthead ) )
d404 1
a404 1
	if( !BU_LIST_UNINITIALIZED( &resp->re_solid_bitv ) )
d407 1
a407 1
	if( !BU_LIST_UNINITIALIZED( &resp->re_region_ptbl ) )
d410 1
a410 1
	if( !BU_LIST_UNINITIALIZED( &resp->re_nmgfree ) )
d458 1
a458 1
	if( !BU_LIST_UNINITIALIZED( &resp->re_seg_blocks.l ) )  {
d469 1
a469 1
	if( !BU_LIST_UNINITIALIZED( &resp->re_nmgfree ) )  {
d479 1
a479 1
	if( !BU_LIST_UNINITIALIZED( &resp->re_parthead ) )  {
d490 1
a490 1
	if( !BU_LIST_UNINITIALIZED( &resp->re_solid_bitv ) )  {
d500 1
a500 1
	if( !BU_LIST_UNINITIALIZED( &resp->re_region_ptbl ) )  {
d621 1
a621 1
	if( !BU_LIST_UNINITIALIZED( &rtip->rti_resources.l ) )  {
@


11.30
log
@Moved reset of d_uses field from rt_clean() to rt_new_rti().
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /m/cad/librt/RCS/prep.c,v 11.29 1998/03/24 08:22:03 mike Exp mike $ (BRL)";
d380 2
a381 1
 *	that rt_free_resource() deallocates.
d429 1
a429 1
 *			R T _ F R E E _ R E S O U R C E
d442 3
a444 2
 *  Note that the resource struct's storage is not freed (it may be static),
 *  but it is zeroed.
d447 1
a447 1
rt_free_resource( rtip, resp )
d454 3
a456 1
	/* The 'struct seg' guys are malloc()ed in blocks, not individually */
d458 1
a458 1
	if( !BU_LIST_UNINITIALIZED( &resp->re_solid_bitv ) )  {
d517 5
a521 1
	/* Reinitialize, to be ready for next frame */
d529 2
a530 1
 *  structure, except for the database instance information (dir, etc).
d619 1
d626 2
a627 1
			rt_free_resource(rtip, *rpp);
d629 2
a630 1
		bu_ptbl_free( &rtip->rti_resources );
d633 1
a633 1
		rt_free_resource(rtip, &rt_uniresource );/* Used for rt_optim_tree() */
d638 1
a638 1
	 *  This duplicates the code in rt_dirbuild().
a785 1

@


11.29
log
@If resource structs have been provided, use them.
Added handy memory-checker routine, rt_ck(rtip);
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /m/cad/librt/RCS/prep.c,v 11.28 1998/03/24 06:31:23 mike Exp mike $ (BRL)";
a588 10

	/* Reset instancing counters in database directory */
/* XXX move to dir.c */
	for( i=0; i < RT_DBNHASH; i++ )  {
		register struct directory	*dp;

		dp = rtip->rti_dbip->dbi_Head[i];
		for( ; dp != DIR_NULL; dp = dp->d_forw )
			dp->d_uses = 0;
	}
@


11.28
log
@Moved init of rti_resources ptbl into rt_new_rti().
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /m/cad/librt/RCS/prep.c,v 11.27 1998/03/24 04:47:33 mike Exp mike $ (BRL)";
d41 2
d65 1
d108 7
d125 2
a126 3
		rt_optim_tree( regp->reg_treetop, &rt_uniresource );
		rt_solid_bitfinder( regp->reg_treetop, regp,
			&rt_uniresource );
d128 1
d535 1
a535 1
	if( rtip->rti_magic != RTI_MAGIC )  rt_bomb("rt_clean:  bad rtip\n");
d591 1
d601 1
d717 2
d722 1
d726 1
d755 30
@


11.27
log
@Sanity check.
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /m/cad/librt/RCS/prep.c,v 11.26 1998/03/19 15:57:01 jra Exp mike $ (BRL)";
a72 5

	/* This table is used for discovering the per-cpu resource structures */
	bu_ptbl_init( &rtip->rti_resources, MAX_PSW, "rti_resources ptbl" );

	rt_uniresource.re_magic = RESOURCE_MAGIC;
@


11.26
log
@Cahnged to new calling sequence for ft_import and ft_export.
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /m/cad/librt/RCS/prep.c,v 11.25 1997/12/16 00:14:40 mike Exp jra $ (BRL)";
d721 1
@


11.25
log
@Converted to bu_semaphore_acquire()
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /m/cad/librt/RCS/prep.c,v 11.24 1997/10/06 15:34:13 mike Exp mike $ (BRL)";
d316 1
a316 1
	if( rt_functab[id].ft_import( &intern, &ext, mat ) < 0 )  {
@


11.24
log
@Name changed to prevent system conflict
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /m/cad/librt/RCS/prep.c,v 11.23 1997/09/18 20:32:45 jra Exp mike $ (BRL)";
d67 1
a67 1
	RES_ACQUIRE(&rt_g.res_results);	/* start critical section */
d70 1
a70 1
		RES_RELEASE(&rt_g.res_results);
d211 1
a211 1
	RES_RELEASE(&rt_g.res_results);	/* end critical section */
@


11.23
log
@Mods for use of pmalloc in TNURB raytracing.
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /m/cad/librt/RCS/prep.c,v 11.22 1997/09/02 13:59:11 gdurf Exp jra $ (BRL)";
d409 1
a409 1
		for( i=0 ; i<NBUCKETS ; i++ )
@


11.22
log
@zero counters for rt_i.rti_ncut_by_type
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /m/cad/librt/RCS/prep.c,v 11.21 1997/08/28 21:39:03 mike Exp gdurf $ (BRL)";
d382 2
d406 11
@


11.21
log
@When freeing up resources, don't leave structure unusable,
prepare it for next frame.
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /m/cad/librt/RCS/prep.c,v 11.20 1997/03/07 06:17:13 mike Exp mike $ (BRL)";
d87 1
a87 1
		bu_log("All solids are halspaces, setting minimum\n");
d91 1
a91 1
		bu_log("All solids are halspaces, setting maximum\n");
d186 1
@


11.20
log
@random number table init is an rt thing, not librt.
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /m/cad/librt/RCS/prep.c,v 11.19 1997/03/07 06:11:23 mike Exp mike $ (BRL)";
d494 2
a495 2
	/* Zero out storage.  Prevent any residue */
	bzero( (char *)resp, sizeof(*resp) );
@


11.19
log
@Improved rt_init_resource and rt_free_resource
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /m/cad/librt/RCS/prep.c,v 11.18 1997/01/30 19:58:35 jra Exp mike $ (BRL)";
d384 1
a384 1
	rand_init( resp->re_randptr, cpu_num );
@


11.18
log
@set shader pointer to NULL after freeing shader string in region struct.
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /m/cad/librt/RCS/prep.c,v 11.17 1997/01/10 15:31:01 jra Exp jra $ (BRL)";
d377 1
a377 1
rt_init_resource( resp )
d379 1
d381 2
a382 1
	RT_CK_RESOURCE(resp);
d384 2
d421 3
d493 3
@


11.17
log
@Added resource re_nmgfree for "hitmiss" structures.
Added  rt_init_resource() routine.
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /m/cad/librt/RCS/prep.c,v 11.16 1997/01/09 19:29:59 bparker Exp jra $ (BRL)";
d525 1
d527 2
@


11.16
log
@*** empty log message ***
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /m/cad/librt/RCS/prep.c,v 11.15 1996/12/04 02:50:27 mike Exp bparker $ (BRL)";
d370 34
d409 1
d436 10
@


11.15
log
@Combined ma_matname and ma_matparm into a single string, ma_shader.
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /m/cad/librt/RCS/prep.c,v 11.14 1996/10/19 06:17:45 mike Exp mike $ (BRL)";
d34 1
d36 1
d313 1
a313 1
		mat = (matp_t)rt_identity;
@


11.14
log
@Changed to reflect that ma_matparm is now a pointer, not an array.
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /m/cad/librt/RCS/prep.c,v 11.13 1996/09/27 08:27:30 mike Exp mike $ (BRL)";
d477 2
a478 4
		if( regp->reg_mater.ma_matname )
			bu_free( (genptr_t)regp->reg_mater.ma_matname, "ma_matname" );
		if( regp->reg_mater.ma_matparm )
			bu_free( (genptr_t)regp->reg_mater.ma_matparm, "ma_matparm" );
@


11.13
log
@Converted to using proper routine names for LIBBU and LIBBN routines.
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /m/cad/librt/RCS/prep.c,v 11.12 1996/09/24 05:15:13 mike Exp mike $ (BRL)";
d475 1
a475 1
		rt_free( (char *)regp->reg_name, "region name str");
d477 6
a482 1
		rt_free( (char *)regp, "struct region");
@


11.12
log
@"clean" command can be given before any frames are actually prepped.
More protection was required.
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /m/cad/librt/RCS/prep.c,v 11.11 1996/08/31 05:16:39 mike Exp $ (BRL)";
d67 1
a67 1
		rt_log("WARNING: rt_prep() invoked a second time, ignored");
d79 1
a79 1
			rt_log("rt_prep: %d solids discarded due to air regions\n", rtip->rti_air_discards );
d85 1
a85 1
		rt_log("All solids are halspaces, setting minimum\n");
d89 1
a89 1
		rt_log("All solids are halspaces, setting maximum\n");
d127 1
a127 1
			rt_log("solid %s ", stp->st_name);
d172 1
a172 1
			rt_log("%5d %s (%d)\n",
d292 1
a292 1
	struct rt_list			vhead;
d294 1
a294 1
	struct rt_external		ext;
d299 1
a299 1
	struct rt_tol			tol;
d302 1
a302 1
	RT_LIST_INIT( &vhead );
d305 1
a305 1
		rt_log("rt_plot_solid(%s): db_get_external() failure\n",
d314 1
a314 1
		rt_log("rt_plot_solid(%s):  solid import failure\n",
d328 1
a328 1
	tol.magic = RT_TOL_MAGIC;
d340 1
a340 1
		rt_log("rt_plot_solid(%s): ft_plot() failure\n",
d357 2
a358 2
	if( RT_LIST_IS_EMPTY( &vhead ) )  {
		rt_log("rt_plot_solid(%s): no vectors to plot?\n",
d390 2
a391 2
	RT_LIST_INIT( &resp->re_seg );	/* abandon the list of individuals */
	if( !RT_LIST_UNINITIALIZED( &resp->re_solid_bitv ) )  {
d402 1
a402 1
	if( !RT_LIST_UNINITIALIZED( &resp->re_parthead ) )  {
d404 1
a404 1
		while( RT_LIST_WHILE( pp, partition, &resp->re_parthead ) )  {
d406 1
a406 1
			RT_LIST_DEQUEUE( (struct rt_list *)pp );
d413 1
a413 1
	if( !RT_LIST_UNINITIALIZED( &resp->re_solid_bitv ) )  {
d415 1
a415 1
		while( RT_LIST_WHILE( bvp, bu_bitv, &resp->re_solid_bitv ) )  {
d417 1
a417 1
			RT_LIST_DEQUEUE( &bvp->l );
d423 1
a423 1
	if( !RT_LIST_UNINITIALIZED( &resp->re_region_ptbl ) )  {
d425 1
a425 1
		while( RT_LIST_WHILE( tabp, bu_ptbl, &resp->re_region_ptbl ) )  {
d427 1
a427 1
			RT_LIST_DEQUEUE( &tabp->l );
d455 1
a455 1
	register struct rt_list	*head;
d488 1
a488 1
		while( RT_LIST_WHILE( stp, soltab, head ) )  {
d561 2
a562 2
	rt_hist_free( &rtip->rti_hist_cellsize );
	rt_hist_free( &rtip->rti_hist_cutdepth );
d590 1
a590 1
		rt_log("Del Region %s\n", delregp->reg_name);
d604 1
a604 1
	rt_log("rt_del_region:  unable to find %s\n", delregp->reg_name);
d661 1
a661 1
			rt_log("rt_solid_bitfinder:  op=x%x\n", treep->tr_op);
@


11.11
log
@Got the last of the memory leaks.
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /m/cad/librt/RCS/prep.c,v 11.10 1996/08/31 04:27:05 mike Exp mike $ (BRL)";
d446 3
d537 1
a537 2
	BU_CK_PTBL( &rtip->rti_resources );
	{
d539 1
d544 1
d546 3
a548 2
	bu_ptbl_free( &rtip->rti_resources );
	rt_free_resource(rtip, &rt_uniresource );	/* Used for rt_optim_tree() */
@


11.10
log
@Free rti_resources ptbl too.
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /m/cad/librt/RCS/prep.c,v 11.9 1996/08/31 04:20:54 mike Exp mike $ (BRL)";
d75 2
d377 3
d391 1
a391 1
	{
d402 1
a402 1
	{
d413 1
a413 1
	{
d423 1
a423 1
	{
d543 1
@


11.9
log
@Changed calling sequence to bu_ptbl_init() to have reason string
for bu_malloc() tracking
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /m/cad/librt/RCS/prep.c,v 11.8 1996/08/31 04:03:14 mike Exp mike $ (BRL)";
d537 1
@


11.8
log
@Forgot re_boolstack
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /m/cad/librt/RCS/prep.c,v 11.7 1996/08/31 03:15:29 mike Exp mike $ (BRL)";
d73 1
a73 1
	bu_ptbl_init( &rtip->rti_resources, MAX_PSW );
d423 1
@


11.7
log
@Added rti_resources, and rt_free_resource(), to allow returning
all the per-CPU memory allocations.
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /m/cad/librt/RCS/prep.c,v 11.6 1996/08/31 02:19:01 mike Exp mike $ (BRL)";
d426 7
a652 1

@


11.6
log
@Moved CutFree into rt_i structure
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /m/cad/librt/RCS/prep.c,v 11.5 1996/08/29 06:06:14 mike Exp mike $ (BRL)";
d49 3
d65 1
d68 1
d71 4
a74 1
	rtip->needprep = 0;
d181 1
d205 2
d367 62
a478 5
	/**** The best thing to do would be to hunt down the
	 *  bitv and partition structs and release them, because
	 *  they depend on the number of solids & regions!  XXX
	 */

a490 1
	/* XXX struct seg is also bulk allocated, can't be freed. XXX */
a491 2
	/* Release partition structs.  XXX How to find them?  resource structs? */

d513 15
@


11.5
log
@struct partition is no longer variable length, allocation
is handled by macros in raytrace.h
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /m/cad/librt/RCS/prep.c,v 11.4 1996/08/28 10:03:46 mike Exp mike $ (BRL)";
d417 1
a417 1
		rt_fr_cut( &(rtip->rti_CutHead) );
d419 1
a419 1
		rt_fr_cut( &(rtip->rti_inf_box) );
d422 1
a422 1
	rt_cut_clean();
@


11.4
log
@st_regions is now a bu_ptbl, not a bitvector.
"regionbits" is also a bu_ptbl, not a bitvector.
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /m/cad/librt/RCS/prep.c,v 11.3 1995/10/31 21:52:39 mike Exp mike $ (BRL)";
a71 8

	/* Compute size of model-specific variable-length data structures */
	/* -sizeof(bitv_t) == sizeof(struct partition.pt_solhit) */
	rtip->rti_pt_bytes = sizeof(struct partition) - sizeof(bitv_t) + 1 +
		RT_BITV_BITS2WORDS(rtip->nsolids) * sizeof(bitv_t);
	rtip->rti_bv_bytes = sizeof(bitv_t) *
		( RT_BITV_BITS2WORDS(rtip->nsolids) +
		RT_BITV_BITS2WORDS(rtip->nregions) + 4 );
@


11.3
log
@Fixed memory leak reported by Chris Johnson.
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /m/cad/librt/RCS/prep.c,v 11.2 1995/03/18 04:18:08 mike Exp mike $ (BRL)";
a80 12
	/*
	 *  Allocate space for a per-solid bit of rtip->nregions length.
	 */
	RT_VISIT_ALL_SOLTABS_START( stp, rtip )  {
		RT_CK_SOLTAB(stp);
		stp->st_regions = (bitv_t *)rt_calloc(
			RT_BITV_BITS2WORDS(rtip->nregions),
			sizeof(bitv_t), "st_regions bitv" );
		stp->st_maxreg = 0;
	} RT_VISIT_ALL_SOLTABS_END


d117 1
a117 1
		rt_solid_bitfinder( regp->reg_treetop, regp->reg_bit,
d126 1
a126 2
			rt_pr_bitv( "regions ref", stp->st_regions,
				stp->st_maxreg);
d345 1
a345 2
	if( (rnum = stp->st_maxreg-1) < 0 ) rnum = 0;
	if( (regp = rtip->Regions[rnum]) != REGION_NULL )  {
d531 1
a531 1
rt_solid_bitfinder( treep, regbit, resp )
d533 1
a533 1
register int		regbit;
d540 1
d552 1
a552 8
			BITSET( stp->st_regions, regbit );
			if( !BITTEST( stp->st_regions, regbit ) )
				rt_bomb("BITSET failure\n");	/* sanity check */
			if( regbit+1 > stp->st_maxreg )  stp->st_maxreg = regbit+1;
			if( rt_g.debug&DEBUG_REGIONS )  {
				rt_pr_bitv( stp->st_name, stp->st_regions,
					stp->st_maxreg );
			}
@


11.2
log
@Added rt_prep_parallel().
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /m/cad/librt/RCS/prep.c,v 11.1 95/01/04 09:58:29 mike Rel4_4 Locker: mike $ (BRL)";
d444 1
a444 3
	/* rt_g.rtg_CutFree list could be freed, but is bulk allocated, XXX
	 * so cutter structures will hang around.  XXX
	 */
@


11.1
log
@Release_4.4
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /m/cad/librt/RCS/prep.c,v 10.6 94/12/09 01:21:33 mike Exp $ (BRL)";
d44 1
a44 1
 *  			R T _ P R E P
d51 3
a53 2
rt_prep(rtip)
register struct rt_i *rtip;
d194 1
a194 1
	rt_cut_it(rtip);
d217 13
@


10.6
log
@CLEAN command was initializing model RPP incorrectly.
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /m/cad/librt/RCS/prep.c,v 10.5 94/08/10 19:41:06 gdurf Exp Locker: mike $ (BRL)";
@


10.5
log
@Factored ifdefs
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /m/cad/librt/RCS/prep.c,v 10.4 1994/05/10 11:02:36 mike Exp gdurf $ (BRL)";
d94 1
d98 1
d468 2
a469 2
	VSETALL( rtip->mdl_min, -0.1 );
	VSETALL( rtip->mdl_max,  0.1 );
@


10.4
log
@Added magic numbers to union tree structures.
Added db_ck_tree() routine.
Added rt_free_soltab().
Rearranged rt_clean() to not trash soltab structures.
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /m/cad/librt/RCS/prep.c,v 10.3 94/03/18 01:10:37 mike Exp Locker: mike $ (BRL)";
d24 2
d28 3
a30 1
#ifdef BSD
a31 2
#else
#include <string.h>
@


10.3
log
@Moved rt_vlist_to_uplot() from prep.c to vlist.c
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /m/cad/librt/RCS/prep.c,v 10.2 92/05/04 15:59:53 mike Exp Locker: mike $ (BRL)";
d376 4
a379 18
	/*
	 *  Clear out the solid table
	 */
	head = &(rtip->rti_solidheads[0]);
	for( ; head < &(rtip->rti_solidheads[RT_DBNHASH]); head++ )  {
		while( RT_LIST_WHILE( stp, soltab, head ) )  {
			RT_CHECK_SOLTAB(stp);
			RT_LIST_DEQUEUE( &(stp->l) );
			if( stp->st_id < 0 || stp->st_id >= rt_nfunctab )
				rt_bomb("rt_clean:  bad st_id");
			rt_functab[stp->st_id].ft_free( stp );
			rt_free( (char *)stp->st_regions, "st_regions bitv" );
			if( stp->st_matp )  rt_free( (char *)stp->st_matp, "st_matp");
			stp->st_matp = (matp_t)0;
			stp->st_regions = (bitv_t *)0;
			stp->st_dp = DIR_NULL;		/* was ptr to directory */
			rt_free( (char *)stp, "struct soltab");
		}
a380 2
	rtip->nsolids = 0;

d383 1
d388 1
d397 12
@


10.2
log
@regionfix moved into librt from rt, called on rt_prep
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /m/cad/librt/RCS/prep.c,v 10.1 91/10/12 06:40:57 mike Rel4_0 Locker: mike $ (BRL)";
a262 40
}

/*
 *			R T _ V L I S T _ T O _ U P L O T
 *
 *  Output a vlist as an extended 3-D floating point UNIX-Plot file.
 *  You provide the file.
 */
void
rt_vlist_to_uplot( fp, vhead )
FILE		*fp;
struct rt_list	*vhead;
{
	register struct rt_vlist	*vp;

	for( RT_LIST_FOR( vp, rt_vlist, vhead ) )  {
		register int		i;
		register int		nused = vp->nused;
		register CONST int	*cmd = vp->cmd;
		register point_t	 *pt = vp->pt;

		for( i = 0; i < nused; i++,cmd++,pt++ )  {
			switch( *cmd )  {
			case RT_VLIST_POLY_START:
				break;
			case RT_VLIST_POLY_MOVE:
			case RT_VLIST_LINE_MOVE:
				pdv_3move( fp, *pt );
				break;
			case RT_VLIST_POLY_DRAW:
			case RT_VLIST_POLY_END:
			case RT_VLIST_LINE_DRAW:
				pdv_3cont( fp, *pt );
				break;
			default:
				rt_log("rt_vlist_to_uplot: unknown vlist cmd x%x\n",
					*cmd );
			}
		}
	}
@


10.1
log
@Release_4.0
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /m/cad/librt/RCS/prep.c,v 1.31 91/07/16 00:06:31 mike Exp $ (BRL)";
d184 3
@


1.31
log
@Conservative error check, useful for finding Butler's
invisible lights dumping core bug.
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /m/cad/librt/RCS/prep.c,v 1.30 91/07/10 00:37:43 mike Exp $ (BRL)";
@


1.30
log
@Changed from using private rt_fr_tree() to more full-functioned
db_free_tree().
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /m/cad/librt/RCS/prep.c,v 1.29 91/06/30 23:17:54 mike Exp $ (BRL)";
d82 1
@


1.29
log
@Changed from rti_headsolid list for all soltab structures,
to RT_DBNHASH different lists, rti_solidheads[].
This permits much faster searching in the parallel treewalking stage.
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /m/cad/librt/RCS/prep.c,v 1.28 91/06/30 22:24:23 mike Exp $ (BRL)";
a36 1
HIDDEN void	rt_fr_tree();
d57 1
a57 1
	if( rtip->rti_magic != RTI_MAGIC )  rt_bomb("rt_prep:  bad rtip\n");
d59 4
a62 2
	if(!rtip->needprep)
		rt_bomb("rt_prep: invoked a second time");
d439 1
a439 1
		rt_fr_tree( regp->reg_treetop );
d551 2
a552 1
	rt_fr_tree( delregp->reg_treetop );
a556 41
}

/*
 *			R T _ F R  _ T R E E
 *
 *  Free a boolean operation tree.
 *  Pointers to children are nulled out, to prevent any stray references
 *  to this tree node from being sucessful.
 *  XXX should iterate, rather than recurse.
 */
HIDDEN void
rt_fr_tree( tp )
register union tree *tp;
{

	switch( tp->tr_op )  {
	case OP_NOP:
		tp->tr_op = 0;
		rt_free( (char *)tp, "NOP union tree");
		return;
	case OP_SOLID:
		rt_free( tp->tr_a.tu_name, "leaf name" );
		tp->tr_a.tu_name = (char *)0;
		tp->tr_op = 0;
		rt_free( (char *)tp, "leaf tree union");
		return;
	case OP_SUBTRACT:
	case OP_UNION:
	case OP_INTERSECT:
	case OP_XOR:
		rt_fr_tree( tp->tr_b.tb_left );
		tp->tr_b.tb_left = TREE_NULL;
		rt_fr_tree( tp->tr_b.tb_right );
		tp->tr_b.tb_right = TREE_NULL;
		tp->tr_op = 0;
		rt_free( (char *)tp, "binary tree union");
		return;
	default:
		rt_log("rt_fr_tree: bad op x%x\n", tp->tr_op);
		return;
	}
@


1.28
log
@Split out several valuable routines, like rt_vlist_to_uplot
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /m/cad/librt/RCS/prep.c,v 1.27 91/06/30 19:08:15 mike Exp $ (BRL)";
d80 1
a80 1
	for( RT_LIST( stp, soltab, &(rtip->rti_headsolid) ) )  {
d85 1
a85 1
	}
d87 1
d129 1
a129 1
		for( RT_LIST( stp, soltab, &(rtip->rti_headsolid) ) )  {
d133 1
a133 1
		}
d148 1
a148 1
	for( RT_LIST( stp, soltab, &(rtip->rti_headsolid) ) )  {
d151 2
a152 1
	}
d169 1
a169 1
	for( RT_LIST( stp, soltab, &(rtip->rti_headsolid) ) )  {
d173 1
a173 1
	}
d224 1
a224 1
	for( RT_LIST_FOR( stp, soltab, &(rtip->rti_headsolid) ) )  {
d231 1
a231 1
	}
d248 1
a248 1
	for( RT_LIST_FOR( stp, soltab, &(rtip->rti_headsolid) ) )  {
d257 1
a257 1
	}
d405 1
d414 15
a428 12
	while( RT_LIST_WHILE( stp, soltab, &(rtip->rti_headsolid) ) )  {
		RT_CHECK_SOLTAB(stp);
		RT_LIST_DEQUEUE( &(stp->l) );
		if( stp->st_id < 0 || stp->st_id >= rt_nfunctab )
			rt_bomb("rt_clean:  bad st_id");
		rt_functab[stp->st_id].ft_free( stp );
		rt_free( (char *)stp->st_regions, "st_regions bitv" );
		if( stp->st_matp )  rt_free( (char *)stp->st_matp, "st_matp");
		stp->st_matp = (matp_t)0;
		stp->st_regions = (bitv_t *)0;
		stp->st_dp = DIR_NULL;		/* was ptr to directory */
		rt_free( (char *)stp, "struct soltab");
@


1.27
log
@As a result of changes needed for parallel prepping,
it is now possible to encounter "dead" solids (i.e., those that failed
prepping) in the rti_headsolid list.
They are marked by a negative st_aradius, and are easily skipped.
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /m/cad/librt/RCS/prep.c,v 1.26 91/06/29 22:14:07 mike Exp $ (BRL)";
a189 1
			pdv_3space( plotfp, rtip->rti_pmin, rtip->rti_pmax );
d191 1
a191 8
			for( RT_LIST( stp, soltab, &(rtip->rti_headsolid) ) )  {
				/* Ignore "dead" solids in the list.  (They failed prep) */
				if( stp->st_aradius <= 0 )  continue;
				/* Don't draw infinite solids */
				if( stp->st_aradius >= INFINITY )
					continue;
				pdv_3box( plotfp, stp->st_min, stp->st_max );
			}
a198 1
		register struct soltab	*stp;
d200 6
a205 1
		if( (plotfp=fopen("rtsolids.pl", "w")) == NULL)  return;
d207 12
a218 1
		pdv_3space( plotfp, rtip->rti_pmin, rtip->rti_pmax );
d220 11
a230 3
		for( RT_LIST( stp, soltab, &(rtip->rti_headsolid) ) )  {
			/* Ignore "dead" solids in the list.  (They failed prep) */
			if( stp->st_aradius <= 0 )  continue;
d232 9
a240 3
			/* Don't draw infinite solids */
			if( stp->st_aradius >= INFINITY )
				continue;
d242 52
a293 2
			if( rt_plot_solid( plotfp, rtip, stp ) < 0 )
				rt_log("unable to plot %s\n", stp->st_name);
a294 1
		(void)fclose(plotfp);
a314 1
	register struct rt_vlist	*vp;
a380 25
	for( RT_LIST_FOR( vp, rt_vlist, &vhead ) )  {
		register int	i;
		register int	nused = vp->nused;
		register int	*cmd = vp->cmd;
		register point_t *pt = vp->pt;
		for( i = 0; i < nused; i++,cmd++,pt++ )  {
			switch( *cmd )  {
			case RT_VLIST_POLY_START:
				break;
			case RT_VLIST_POLY_MOVE:
			case RT_VLIST_LINE_MOVE:
				pdv_3move( fp, *pt );
				break;
			case RT_VLIST_POLY_DRAW:
			case RT_VLIST_POLY_END:
			case RT_VLIST_LINE_DRAW:
				pdv_3cont( fp, *pt );
				break;
			default:
				rt_log("rt_plot_solid(%s): unknown vlist cmd x%x\n",
					stp->st_name, *cmd );
			}
		}
	}

d386 2
@


1.26
log
@ANSI lint
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /m/cad/librt/RCS/prep.c,v 1.25 91/06/25 04:43:34 mike Exp $ (BRL)";
d193 2
d214 3
@


1.25
log
@Added code to check for OP_NOP nodes
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /m/cad/librt/RCS/prep.c,v 1.24 91/06/14 06:52:26 mike Exp $ (BRL)";
d249 1
d259 2
d262 1
a262 1
	if( rt_functab[id].ft_import( &intern, &ext, stp->st_matp ? stp->st_matp : rt_identity ) < 0 )  {
d382 1
a382 1
		rt_free( regp->reg_name, "region name str");
d494 1
a494 1
	rt_free( delregp->reg_name, "region name str");
@


1.24
log
@st_pathmat changed to st_matp, which is a null pointer if an
identity matrix is in use.
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /m/cad/librt/RCS/prep.c,v 1.23 91/05/18 03:03:34 mike Exp $ (BRL)";
d511 4
d562 2
@


1.23
log
@Converted to new tolerance interface
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /m/cad/librt/RCS/prep.c,v 1.22 91/01/28 23:52:39 mike Exp $ (BRL)";
d259 1
a259 1
	if( rt_functab[id].ft_import( &intern, &ext, stp->st_pathmat ) < 0 )  {
d364 2
@


1.22
log
@Converted to new struct rt_vlist (''chunky vlist'')
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /m/cad/librt/RCS/prep.c,v 1.21 91/01/26 03:16:51 mike Exp $ (BRL)";
d247 2
d268 12
d283 2
a284 3
		0.0,		/* absolute tolerance */
		0.01,		/* relative tolerance */
		0.0		/* normal tolerance */
@


1.21
log
@Eliminated mat arg to ft_plot
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /m/cad/librt/RCS/prep.c,v 1.20 91/01/26 02:53:43 mike Exp $ (BRL)";
d216 2
a217 1
			(void)rt_plot_solid( plotfp, rtip, stp );
d238 1
a238 1
register struct soltab	*stp;
d240 7
a246 7
	struct vlhead	vhead;
	struct region	*regp;
	register struct vlist	*vp;
	int		rnum;
	struct rt_external	ext;
	struct rt_db_internal	intern;
	int		id = stp->st_id;
d248 1
a248 1
	vhead.vh_first = vhead.vh_last = VL_NULL;
d291 23
a313 5
	for( vp = vhead.vh_first; vp != VL_NULL; vp = vp->vl_forw )  {
		if( vp->vl_draw )
			pdv_3cont( fp, vp->vl_pnt );
		else
			pdv_3move( fp, vp->vl_pnt );
d315 4
a318 2
	if( vhead.vh_first == VL_NULL )  {
		rt_log("rt_plot_solid(%s): no vectors to plot?\n", stp->st_name);
a319 2
	} else {
		FREE_VL( vhead.vh_first );
d321 1
@


1.20
log
@Changed to always do ft_ifree
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /m/cad/librt/RCS/prep.c,v 1.19 91/01/25 21:19:41 mike Exp $ (BRL)";
a266 1
		stp->st_pathmat,
@


1.19
log
@Converted to new function switch table interface,
using separation between internal and external forms of geometry.
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /m/cad/librt/RCS/prep.c,v 1.18 90/12/18 00:18:50 mike Exp $ (BRL)";
d279 1
a279 1
    	if( intern.idb_ptr )  rt_functab[id].ft_ifree( &intern );
@


1.18
log
@Free up any histograms
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /n/wolf/m/cad/librt/RCS/prep.c,v 1.17 90/12/11 22:09:03 mike Exp $ (BRL)";
a238 1
	union record	*recp;
d243 3
d248 5
a252 3
	if( (recp = db_getmrec( rtip->rti_dbip, stp->st_dp )) == (union record *)0 )  {
		rt_log("rt_plot_solid(%s): db_getmrec() failure\n", stp->st_name);
		return(-1);		/* FAIL */
d254 15
a268 3
	if( rt_functab[stp->st_id].ft_plot(
		recp, stp->st_pathmat, &vhead,
		stp->st_dp,
d273 4
a276 2
		rt_log("rt_plot_solid(%s): ft_plot() failure\n", stp->st_name);
		rt_free( (char *)recp, "db record" );
d279 2
a280 1
	rt_free( (char *)recp, "db record" );
@


1.17
log
@db.h must come before raytrace.h
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /m/cad/librt/RCS/prep.c,v 1.16 90/11/02 03:11:20 mike Exp $ (BRL)";
d390 3
@


1.16
log
@A bit more tidy when freeing storage.
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /m/cad/librt/RCS/prep.c,v 1.15 90/11/02 02:10:34 mike Exp $ (BRL)";
d33 1
a34 1
#include "db.h"
@


1.15
log
@Note that a clean may be done without a prep, so don't
free pointers unless they are non-null.
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /m/cad/librt/RCS/prep.c,v 1.14 90/10/07 21:38:51 mike Exp $ (BRL)";
d306 1
a306 1
	while( RT_LIST_LOOP( stp, soltab, &(rtip->rti_headsolid) ) )  {
d313 1
d327 1
d436 1
d445 2
d457 2
d466 1
d468 2
@


1.14
log
@soltab structure changed to use struct rt_list.
HeadSolid became rti_headsolid.
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /m/cad/librt/RCS/prep.c,v 1.13 90/10/06 02:52:28 mike Exp $ (BRL)";
d373 4
a376 2
	rt_free( (char *)rtip->rti_Solids, "rtip->rti_Solids[]" );
	rtip->rti_Solids = (struct soltab **)0;
@


1.13
log
@Enlarged rti_Solids[] to have some pad area on the end.
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /n/wolf/m/cad/librt/RCS/prep.c,v 1.12 90/10/04 21:00:06 mike Exp $ (BRL)";
a37 1
HIDDEN void	rt_plot_solids();
d80 1
a80 1
	for( stp=rtip->HeadSolid; stp != SOLTAB_NULL; stp=stp->st_forw )  {
d128 1
a128 1
		for( stp=rtip->HeadSolid; stp != SOLTAB_NULL; stp=stp->st_forw )  {
d147 1
a147 1
	for( stp=rtip->HeadSolid; stp != SOLTAB_NULL; stp = stp->st_forw )  {
d167 1
a167 1
	for( stp=rtip->HeadSolid; stp != SOLTAB_NULL; stp = stp->st_forw )  {
d192 2
a193 1
			for(stp=rtip->HeadSolid; stp != SOLTAB_NULL; stp=stp->st_forw)  {
d204 15
a218 1
		rt_plot_solids( rtip );
d223 1
a223 1
 *			R T _ P L O T _ S O L I D S
d225 7
a231 2
 *  Plot all the solids, with the same kind of wireframes that MGED
 *  would display.  Another useful debugging tool.
d233 5
a237 3
HIDDEN void
rt_plot_solids( rtip )
struct rt_i	*rtip;
a238 1
	FILE		*plotfp;
a241 1
	register struct soltab	*stp;
d245 13
a257 19
	if( (plotfp=fopen("rtsolids.pl", "w")) == NULL)  return;

	pdv_3space( plotfp, rtip->rti_pmin, rtip->rti_pmax );

	for(stp=rtip->HeadSolid; stp != SOLTAB_NULL; stp=stp->st_forw)  {
		if( stp->st_aradius >= INFINITY )
			continue;

		vhead.vh_first = vhead.vh_last = VL_NULL;
		if( (recp = db_getmrec( rtip->rti_dbip, stp->st_dp )) == (union record *)0 )  {
			rt_log("NOTE: db_getmrec() failure on %s\n", stp->st_name);
			continue;
		}
		rt_functab[stp->st_id].ft_plot(
			recp, stp->st_pathmat, &vhead,
			stp->st_dp,
			0.0,		/* absolute tolerance */
			0.01		/* relative tolerance */
		);
d259 3
d263 8
a270 8
		/* Take color from one region */
		if( (rnum = stp->st_maxreg-1) < 0 ) rnum = 0;
		if( (regp = rtip->Regions[rnum]) != REGION_NULL )  {
			pl_color( plotfp,
				(int)(255*regp->reg_mater.ma_color[0]),
				(int)(255*regp->reg_mater.ma_color[1]),
				(int)(255*regp->reg_mater.ma_color[2]) );
		}
d272 5
a276 11
		for( vp = vhead.vh_first; vp != VL_NULL; vp = vp->vl_forw )  {
			if( vp->vl_draw )
				pdv_3cont( plotfp, vp->vl_pnt );
			else
				pdv_3move( plotfp, vp->vl_pnt );
		}
		if( vhead.vh_first == VL_NULL )  {
			rt_log("NOTE: unable to plot %s\n", stp->st_name );
		} else {
			FREE_VL( vhead.vh_first );
		}
d278 7
a284 1
	(void)fclose(plotfp);
d306 3
a308 4
	for( stp=rtip->HeadSolid; stp != SOLTAB_NULL; )  {
		register struct soltab *nextstp = stp->st_forw;

		rt_free( (char *)stp->st_regions, "st_regions bitv" );
d312 2
a313 1
		stp->st_name = (char *)0;	/* was ptr to directory */
a314 1
		stp = nextstp;			/* advance to next one */
a315 1
	rtip->HeadSolid = SOLTAB_NULL;
d449 1
a449 1
		rt_free( tp->tr_a.tu_name );
@


1.12
log
@Added rti_radius calculation.
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /m/cad/librt/RCS/prep.c,v 1.11 90/07/31 01:01:22 mike Exp $ (BRL)";
d136 6
a141 3
	/* Space for array of soltab pointers indexed by solid bit number */
	rtip->rti_Solids = (struct soltab **)rt_malloc(
		rtip->nsolids * sizeof(struct soltab *),
@


1.11
log
@Updated comment.
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /m/cad/librt/RCS/prep.c,v 1.10 90/07/31 00:42:04 mike Exp $ (BRL)";
d57 1
d106 4
@


1.10
log
@Don't free null pointers
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /m/cad/librt/RCS/prep.c,v 1.9 90/07/30 12:21:05 mike Exp $ (BRL)";
d329 3
a331 1
	/* XXX same thing is true for struct partition and struct seg XXX */
@


1.9
log
@Free some more stuff
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: /m/cad/librt/RCS/prep.c,v 1.8 90/04/26 02:10:53 mike Exp $ (BRL)";
d345 1
@


1.8
log
@Added tolerance args to ft_plot
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: prep.c,v 1.7 90/04/12 04:00:37 mike Locked $ (BRL)";
d326 4
d343 8
d424 1
d433 1
a433 1
		/*rt_free( (char *)tp, "binary tree union"); XXX*/
@


1.7
log
@rt_fr_anim is now db_free_anim
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: prep.c,v 1.6 90/04/12 03:03:20 mike Locked $ (BRL)";
d233 4
a236 1
			stp->st_dp );
@


1.6
log
@Incorporated rt_solid_bitfinder(*)
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: prep.c,v 1.5 90/01/06 04:52:37 mike Locked $ (BRL)";
d334 1
a334 1
	rt_fr_anim(rtip);
@


1.5
log
@Went back to having 4 words of padding;
2 after solid bit vector, 2 more after region bit vector.
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: prep.c,v 1.4 90/01/06 04:09:24 mike Locked $ (BRL)";
d39 1
d422 56
@


1.4
log
@Changed to RT_BITV_BITS2WORDS() and rt_calloc().
@
text
@d21 1
a21 1
static char RCSprep[] = "@@(#)$Header: prep.c,v 1.3 90/01/06 04:04:44 mike Exp $ (BRL)";
d74 1
a74 1
		RT_BITV_BITS2WORDS(rtip->nregions) + 2 );
@


1.3
log
@Added code to allocate and fill in rti_Solids[].
Changed to use RT_BITV_BITS2WORDS(), to prevent guesswork
in the rounding requirements.
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1985 by the United States Army.
d21 1
a21 1
static char RCStree[] = "@@(#)$Header: prep.c,v 1.2 89/12/30 05:23:59 mike Locked $ (BRL)";
d80 3
a82 4
		stp->st_regions = (bitv_t *)rt_malloc(
			BITS2BYTES(rtip->nregions)+sizeof(bitv_t),
			"st_regions bitv" );
		BITZERO( stp->st_regions, rtip->nregions );
@


1.2
log
@If all solids were discarded due to air regions, added
special error message to this effect.
@
text
@d21 1
a21 1
static char RCStree[] = "@@(#)$Header: prep.c,v 1.1 89/10/10 16:11:23 mike Locked $ (BRL)";
d70 5
a74 4
	rtip->rti_pt_bytes = sizeof(struct partition) + 
		BITS2BYTES(rtip->nsolids) - sizeof(bitv_t) + 1;
	rtip->rti_bv_bytes = BITS2BYTES(rtip->nsolids) +
		BITS2BYTES(rtip->nregions) + 4*sizeof(bitv_t);
d131 4
d141 1
@


1.1
log
@Initial revision
@
text
@d21 1
a21 1
static char RCStree[] = "@@(#)$Header: tree.c,v 9.1 89/05/19 05:57:35 mike Rel3_5 $ (BRL)";
d60 1
a60 1
		rt_bomb("rt_prep: re-invocation");
d62 5
a66 2
	if( rtip->nsolids <= 0 )
		rt_bomb("rt_prep:  no solids to prep");
@
