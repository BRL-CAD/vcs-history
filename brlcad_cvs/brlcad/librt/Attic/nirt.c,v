head	1.10;
access;
symbols
	ansi-20040405-merged:1.4.2.2
	postmerge-20040405-ansi:1.7
	premerge-20040404-ansi:1.6
	postmerge-autoconf:1.6
	autoconf-freeze:1.4.10.3
	premerge-autoconf:1.6
	ansi-20040316-freeze:1.4.2.1
	postmerge-20040315-windows:1.6
	premerge-20040315-windows:1.5
	windows-20040315-freeze:1.4.4.2
	autoconf-20031203:1.4
	autoconf-20031202:1.4
	autoconf-branch:1.4.0.10
	phong-branch:1.4.0.8
	photonmap-branch:1.4.0.6
	rel-6-1-DP:1.4
	windows-branch:1.4.0.4
	rel-6-0-2:1.2
	ansi-branch:1.4.0.2
	rel-6-0-1-branch:1.2.0.2
	hartley-6-0-post:1.3
	hartley-6-0-pre:1.2
	rel-6-0-1:1.2
	rel-6-0:1.2;
locks; strict;
comment	@ * @;


1.10
date	2004.05.21.18.07.32;	author morrison;	state dead;
branches;
next	1.9;

1.9
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	1.8;

1.8
date	2004.05.10.15.25.27;	author morrison;	state Exp;
branches;
next	1.7;

1.7
date	2004.04.05.08.48.57;	author morrison;	state Exp;
branches;
next	1.6;

1.6
date	2004.03.16.20.03.09;	author morrison;	state Exp;
branches;
next	1.5;

1.5
date	2004.02.02.17.39.22;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2002.08.20.17.08.03;	author jra;	state Exp;
branches
	1.4.2.1
	1.4.4.1
	1.4.10.1;
next	1.3;

1.3
date	2002.08.15.20.55.14;	author hartley;	state Exp;
branches;
next	1.2;

1.2
date	2001.11.29.17.14.21;	author bparker;	state Exp;
branches;
next	1.1;

1.1
date	2001.11.27.17.52.30;	author bparker;	state Exp;
branches;
next	;

1.4.2.1
date	2002.09.19.18.01.37;	author morrison;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2004.03.17.21.18.51;	author morrison;	state Exp;
branches;
next	;

1.4.4.1
date	2002.09.26.23.04.03;	author morrison;	state Exp;
branches;
next	1.4.4.2;

1.4.4.2
date	2004.03.11.23.43.40;	author morrison;	state Exp;
branches;
next	;

1.4.10.1
date	2004.02.12.18.37.43;	author erikg;	state Exp;
branches;
next	1.4.10.2;

1.4.10.2
date	2004.03.15.14.07.23;	author erikg;	state Exp;
branches;
next	1.4.10.3;

1.4.10.3
date	2004.03.18.18.10.29;	author erikg;	state Exp;
branches;
next	;


desc
@@


1.10
log
@moved to src/
@
text
@/*
 *			N I R T . C
 *
 *  Routines to interface to nirt.
 *
 *  Functions -
 *	dgo_nirt_cmd          trace a single ray from current view
 *
 *  Author -
 *	Michael John Muuss
 *	Robert G. Parker
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1988-2004 by the United States Army.
 *	All rights reserved.
 *
 *  Description -
 *	This code was imported from MGED's/rtif.c and modified to work as part
 * 	of the drawable geometry object.
 *
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/nirt.c,v 1.9 2004/05/10 15:30:46 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include <math.h>
#include <signal.h>
#ifndef WIN32
#include <sys/time.h>		/* For struct timeval */
#endif
#include <sys/stat.h>		/* for chmod() */

#include "tcl.h"

#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "raytrace.h"
#include "externs.h"
#include "solid.h"
#include "./qray.h"

#ifdef WIN32
#include <fcntl.h>
#endif

/* defined in qray.c */
extern void dgo_qray_data_to_vlist(struct dg_obj *dgop, struct bn_vlblock *vbp, struct dg_qray_dataList *headp, fastf_t *dir, int do_overlaps);

/* defined in dg_obj.c */
extern int dgo_build_tops(Tcl_Interp *interp, struct solid *hsp, char **start, register char **end);
extern void dgo_cvt_vlblock_to_solids(struct dg_obj *dgop, Tcl_Interp *interp, struct bn_vlblock *vbp, char *name, int copy);
extern void dgo_pr_wait_status(Tcl_Interp *interp, int status);

/*
 *			F _ N I R T
 *
 *  Invoke nirt with the current view & stuff
 */
int
dgo_nirt_cmd(struct dg_obj	*dgop,
	     struct view_obj	*vop,
	     Tcl_Interp		*interp,
	     int		argc,
	     char		**argv)
{
	register char **vp;
	FILE *fp_in;
	FILE *fp_out, *fp_err;
	int pid, rpid;
	int retcode;
#ifndef WIN32
	int pipe_in[2];
	int pipe_out[2];
	int pipe_err[2];
#else
	HANDLE pipe_in[2],hSaveStdin,pipe_inDup;
	HANDLE pipe_out[2],hSaveStdout,pipe_outDup;
	HANDLE pipe_err[2],hSaveStderr,pipe_errDup;
	STARTUPINFO si = {0};
   PROCESS_INFORMATION pi = {0};
   SECURITY_ATTRIBUTES sa          = {0};
   char name[1024];
   char line1[2048];
#endif
   int use_input_orig = 0;
	vect_t	center_model;
	vect_t dir;
	vect_t cml;
	register int i;
	register struct solid *sp;
	char line[RT_MAXLINE];
	char *val;
	struct bu_vls vls;
	struct bu_vls o_vls;
	struct bu_vls p_vls;
	struct bu_vls t_vls;
	struct bn_vlblock *vbp;
	struct dg_qray_dataList *ndlp;
	struct dg_qray_dataList HeadQRayData;

	vp = &dgop->dgo_rt_cmd[0];
	*vp++ = "nirt";

	/* swipe x, y, z off the end if present */
	if (argc > 3) {
		if (sscanf(argv[argc-3], "%lf", &center_model[X]) == 1 &&
		    sscanf(argv[argc-2], "%lf", &center_model[Y]) == 1 &&
		    sscanf(argv[argc-1], "%lf", &center_model[Z]) == 1){
			use_input_orig = 1;
			argc -= 3;
			VSCALE(center_model, center_model, dgop->dgo_wdbp->dbip->dbi_local2base);
		}
	}

	/* Calculate point from which to fire ray */
	if (!use_input_orig) {
		VSET(center_model, -vop->vo_center[MDX],
		     -vop->vo_center[MDY], -vop->vo_center[MDZ]);
	}

#if 0
	if (mged_variables->mv_perspective_mode) {
		point_t pt, eye;

		/* get eye point */
		VSET(pt, 0.0, 0.0, 1.0);
		MAT4X3PNT(eye, vop->vo_view2model, pt);
		VSCALE(eye, eye, base2local);

		/* point passed in is actually the aim point */
		VSCALE(cml, center_model, base2local);
		VSUB2(dir, cml, eye);
		VUNITIZE(dir);

		/* copy eye point to cml (cml is used for the "xyz" command to nirt */
		VMOVE(cml, eye);
	} else {
		VSCALE(cml, center_model, base2local);
		VMOVEN(dir, vop->vo_rotation + 8, 3);
		VSCALE(dir, dir, -1.0);
	}
#else
	VSCALE(cml, center_model, dgop->dgo_wdbp->dbip->dbi_base2local);
	VMOVEN(dir, vop->vo_rotation + 8, 3);
	VSCALE(dir, dir, -1.0);
#endif

	bu_vls_init(&p_vls);
	bu_vls_printf(&p_vls, "xyz %lf %lf %lf;",
		cml[X], cml[Y], cml[Z]);
	bu_vls_printf(&p_vls, "dir %lf %lf %lf; s",
		dir[X], dir[Y], dir[Z]);

	i = 0;
	if (DG_QRAY_GRAPHICS(dgop)) {

		*vp++ = "-e";
		*vp++ = DG_QRAY_FORMAT_NULL;

		/* first ray  ---- returns partitions */
		*vp++ = "-e";
		*vp++ = DG_QRAY_FORMAT_P;

		/* ray start, direction, and 's' command */
		*vp++ = "-e";
		*vp++ = bu_vls_addr(&p_vls);

		/* second ray  ---- returns overlaps */
		*vp++ = "-e";
		*vp++ = DG_QRAY_FORMAT_O;

		/* ray start, direction, and 's' command */
		*vp++ = "-e";
		*vp++ = bu_vls_addr(&p_vls);

		if (DG_QRAY_TEXT(dgop)) {
			char *cp;
			int count = 0;

			bu_vls_init(&o_vls);

			/* get 'r' format now; prepend its' format string with a newline */
			val = bu_vls_addr(&dgop->dgo_qray_fmts[0].fmt);

			/* find first '"' */
			while(*val != '"' && *val != '\0')
				++val;

			if(*val == '\0')
				goto done;
			else
				++val;	    /* skip first '"' */

			/* find last '"' */
			cp = (char *)strrchr(val, '"');

			if (cp != (char *)NULL) /* found it */
				count = cp - val;

done:
#ifndef WIN32
	    if(*val == '\0')
	      bu_vls_printf(&o_vls, " fmt r \"\\n\" ");
	    else{
	      bu_vls_printf(&o_vls, " fmt r \"\\n%*s\" ", count, val);
#else
		if(*val == '\0')
	      bu_vls_printf(&o_vls, " fmt r \\\"\\\\n\\\" ");
	    else{
	      bu_vls_printf(&o_vls, " fmt r \\\"\\\\n%*s\\\" ", count, val);
#endif
				if (count)
					val += count + 1;
				bu_vls_printf(&o_vls, "%s", val);
			}

			i = 1;

			*vp++ = "-e";
			*vp++ = bu_vls_addr(&o_vls);
		}
	}

	if (DG_QRAY_TEXT(dgop)) {

		bu_vls_init(&t_vls);

		/* load vp with formats for printing */
		for(; dgop->dgo_qray_fmts[i].type != (char)NULL; ++i)
			bu_vls_printf(&t_vls, "fmt %c %s; ",
				      dgop->dgo_qray_fmts[i].type,
				      bu_vls_addr(&dgop->dgo_qray_fmts[i].fmt));

		*vp++ = "-e";
		*vp++ = bu_vls_addr(&t_vls);

		/* nirt does not like the trailing ';' */
		bu_vls_trunc(&t_vls, -2);
	}

	/* include nirt script string */
	if (bu_vls_strlen(&dgop->dgo_qray_script)) {
		*vp++ = "-e";
		*vp++ = bu_vls_addr(&dgop->dgo_qray_script);
	}

        *vp++ = "-e";
        *vp++ = bu_vls_addr(&p_vls);

	for (i=1; i < argc; i++)
		*vp++ = argv[i];
	*vp++ = dgop->dgo_wdbp->dbip->dbi_filename;

	dgop->dgo_rt_cmd_len = vp - dgop->dgo_rt_cmd;

	/* Note - dgo_build_tops sets the last vp to (char *)0 */
	dgop->dgo_rt_cmd_len += dgo_build_tops(interp,
					       &dgop->dgo_headSolid,
					       vp,
					       &dgop->dgo_rt_cmd[RT_MAXARGS]);

	if (dgop->dgo_qray_cmd_echo) {
		/* Print out the command we are about to run */
		vp = &dgop->dgo_rt_cmd[0];
		while (*vp)
			Tcl_AppendResult(interp, *vp++, " ", (char *)NULL);

		Tcl_AppendResult(interp, "\n", (char *)NULL);
	}

	if (use_input_orig) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "\nFiring from (%lf, %lf, %lf)...\n",
			      center_model[X], center_model[Y], center_model[Z]);
		Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
		bu_vls_free(&vls);
	} else
		Tcl_AppendResult(interp, "\nFiring from view center...\n", (char *)NULL);

#ifndef WIN32
	(void)pipe(pipe_in);
	(void)pipe(pipe_out);
	(void)pipe(pipe_err);
	(void)signal(SIGINT, SIG_IGN);
	if ((pid = fork()) == 0) {
 	        /* Redirect stdin, stdout, stderr */
		(void)close(0);
		(void)dup( pipe_in[0] );
		(void)close(1);
		(void)dup( pipe_out[1] );
		(void)close(2);
		(void)dup ( pipe_err[1] );

		/* close pipes */
		(void)close(pipe_in[0]);
		(void)close(pipe_in[1]);
		(void)close(pipe_out[0]);
		(void)close(pipe_out[1]);
		(void)close(pipe_err[0]);
		(void)close(pipe_err[1]);
		for (i=3; i < 20; i++)
			(void)close(i);
		(void)signal(SIGINT, SIG_DFL);
		(void)execvp(dgop->dgo_rt_cmd[0], dgop->dgo_rt_cmd);
		perror (dgop->dgo_rt_cmd[0]);
		exit(16);
	}

	/* use fp_in to feed view info to nirt */
	(void)close(pipe_in[0]);
	fp_in = fdopen(pipe_in[1], "w");

	/* use fp_out to read back the result */
	(void)close(pipe_out[1]);
	fp_out = fdopen(pipe_out[0], "r");

	/* use fp_err to read any error messages */
	(void)close(pipe_err[1]);
	fp_err = fdopen(pipe_err[0], "r");

	/* send quit command to nirt */
	fwrite("q\n", 1, 2, fp_in);
	(void)fclose(fp_in);

#else
		sa.nLength = sizeof(sa);
    sa.bInheritHandle = TRUE;
    sa.lpSecurityDescriptor = NULL;

	// Save the handle to the current STDOUT.  
	hSaveStdout = GetStdHandle(STD_OUTPUT_HANDLE);  
	
	// Create a pipe for the child process's STDOUT.  
	CreatePipe( &pipe_out[0], &pipe_out[1], &sa, 0);

	// Set a write handle to the pipe to be STDOUT.  
	SetStdHandle(STD_OUTPUT_HANDLE, pipe_out[1]);  

	// Create noninheritable read handle and close the inheritable read handle. 
    DuplicateHandle( GetCurrentProcess(), pipe_out[0],
        GetCurrentProcess(),  &pipe_outDup , 
		0,  FALSE,
        DUPLICATE_SAME_ACCESS );
	CloseHandle( pipe_out[0] );

	// Save the handle to the current STDERR.  
	hSaveStderr = GetStdHandle(STD_ERROR_HANDLE);  
	
	// Create a pipe for the child process's STDERR.  
	CreatePipe( &pipe_err[0], &pipe_err[1], &sa, 0);

	// Set a write handle to the pipe to be STDERR.  
	SetStdHandle(STD_ERROR_HANDLE, pipe_err[1]);  

	// Create noninheritable read handle and close the inheritable read handle. 
    DuplicateHandle( GetCurrentProcess(), pipe_err[0],
        GetCurrentProcess(),  &pipe_errDup , 
		0,  FALSE,
        DUPLICATE_SAME_ACCESS );
	CloseHandle( pipe_err[0] );
	
	// The steps for redirecting child process's STDIN: 
	//     1.  Save current STDIN, to be restored later. 
	//     2.  Create anonymous pipe to be STDIN for child process. 
	//     3.  Set STDIN of the parent to be the read handle to the 
	//         pipe, so it is inherited by the child process. 
	//     4.  Create a noninheritable duplicate of the write handle, 
	//         and close the inheritable write handle.  

	// Save the handle to the current STDIN. 
	hSaveStdin = GetStdHandle(STD_INPUT_HANDLE);  

	// Create a pipe for the child process's STDIN.  
	CreatePipe(&pipe_in[0], &pipe_in[1], &sa, 0);
	// Set a read handle to the pipe to be STDIN.  
	SetStdHandle(STD_INPUT_HANDLE, pipe_in[0]);
	// Duplicate the write handle to the pipe so it is not inherited.  
	DuplicateHandle(GetCurrentProcess(), pipe_in[1], 
		GetCurrentProcess(), &pipe_inDup, 
		0, FALSE,                  // not inherited       
		DUPLICATE_SAME_ACCESS ); 
	CloseHandle(pipe_in[1]); 


   si.cb = sizeof(STARTUPINFO);
   si.lpReserved = NULL;
   si.lpReserved2 = NULL;
   si.cbReserved2 = 0;
   si.lpDesktop = NULL;
   si.dwFlags = 0;
   si.dwFlags = STARTF_USESTDHANDLES;
   si.hStdInput   = pipe_in[0];
   si.hStdOutput  = pipe_out[1];
   si.hStdError   = pipe_err[1];


   sprintf(line1,"%s ",dgop->dgo_rt_cmd[0]);
   for(i=1;i<dgop->dgo_rt_cmd_len;i++) {
	   sprintf(name,"%s ",dgop->dgo_rt_cmd[i]);
	   strcat(line1,name); 
	   if(strstr(name,"-e") != NULL) {
		   i++;
		   sprintf(name,"\"%s\" ",dgop->dgo_rt_cmd[i]);
			strcat(line1,name);} 
   }
   
   if(CreateProcess( NULL,
                     line1,
                     NULL,
                     NULL,
                     TRUE,
                     DETACHED_PROCESS,
                     NULL,
                     NULL,
                     &si,
                     &pi )) {

	SetStdHandle(STD_INPUT_HANDLE, hSaveStdin);
	SetStdHandle(STD_OUTPUT_HANDLE, hSaveStdout);
	SetStdHandle(STD_ERROR_HANDLE, hSaveStderr);
}
 
	/* use fp_in to feed view info to nirt */
	CloseHandle( pipe_in[0] );
	fp_in = _fdopen( _open_osfhandle((HFILE)pipe_inDup,_O_TEXT), "w" );
	//fp_in = fdopen( pipe_in[1], "w" );

	/* use fp_out to read back the result */
	CloseHandle( pipe_out[1] );
	//fp_out = fdopen( pipe_out[0], "r" );
	fp_out = _fdopen( _open_osfhandle((HFILE)pipe_outDup,_O_TEXT), "r" );

	/* use fp_err to read any error messages */
	CloseHandle(pipe_err[1]);
	//fp_err = fdopen( pipe_err[0], "r" );
	fp_err = _fdopen( _open_osfhandle((HFILE)pipe_errDup,_O_TEXT), "r" );

	/* send quit command to nirt */
	fwrite( "q\n", 1, 2, fp_in );
	(void)fclose( fp_in );

#endif

	bu_vls_free(&p_vls);   /* use to form "partition" part of nirt command above */
	if (DG_QRAY_GRAPHICS(dgop)) {

		if (DG_QRAY_TEXT(dgop))
			bu_vls_free(&o_vls); /* used to form "overlap" part of nirt command above */

		BU_LIST_INIT(&HeadQRayData.l);

		/* handle partitions */
		while (fgets(line, RT_MAXLINE, fp_out) != (char *)NULL) {
			if (line[0] == '\n') {
				Tcl_AppendResult(interp, line+1, (char *)NULL);
				break;
			}

			BU_GETSTRUCT(ndlp, dg_qray_dataList);
			BU_LIST_APPEND(HeadQRayData.l.back, &ndlp->l);

			if (sscanf(line, "%le %le %le %le",
				   &ndlp->x_in, &ndlp->y_in, &ndlp->z_in, &ndlp->los) != 4)
				break;
		}

		vbp = rt_vlblock_init();
		dgo_qray_data_to_vlist(dgop, vbp, &HeadQRayData, dir, 0);
		bu_list_free(&HeadQRayData.l);
		dgo_cvt_vlblock_to_solids(dgop, interp, vbp, bu_vls_addr(&dgop->dgo_qray_basename), 0);
		rt_vlblock_free(vbp);

		/* handle overlaps */
		while (fgets(line, RT_MAXLINE, fp_out) != (char *)NULL) {
			if (line[0] == '\n') {
				Tcl_AppendResult(interp, line+1, (char *)NULL);
				break;
			}

			BU_GETSTRUCT(ndlp, dg_qray_dataList);
			BU_LIST_APPEND(HeadQRayData.l.back, &ndlp->l);

			if (sscanf(line, "%le %le %le %le",
				   &ndlp->x_in, &ndlp->y_in, &ndlp->z_in, &ndlp->los) != 4)
				break;
		}
		vbp = rt_vlblock_init();
		dgo_qray_data_to_vlist(dgop, vbp, &HeadQRayData, dir, 1);
		bu_list_free(&HeadQRayData.l);
		dgo_cvt_vlblock_to_solids(dgop, interp, vbp, bu_vls_addr(&dgop->dgo_qray_basename), 0);
		rt_vlblock_free(vbp);
	}

	/*
	 * Notify observers, if any, before generating textual output since
	 * such an act (observer notification) wipes out whatever gets stuffed
	 * into interp->result.
	 */
	dgo_notify(dgop, interp);

	if (DG_QRAY_TEXT(dgop)) {
		bu_vls_free(&t_vls);

		while (fgets(line, RT_MAXLINE, fp_out) != (char *)NULL)
			Tcl_AppendResult(interp, line, (char *)NULL);
	}

	(void)fclose(fp_out);

	while (fgets(line, RT_MAXLINE, fp_err) != (char *)NULL)
		Tcl_AppendResult(interp, line, (char *)NULL);
	(void)fclose(fp_err);

	
#ifndef WIN32

	/* Wait for program to finish */
	while ((rpid = wait(&retcode)) != pid && rpid != -1)
		;	/* NULL */

	if( retcode != 0 )
		dgo_pr_wait_status(interp, retcode);
#else
	/* Wait for program to finish */
	WaitForSingleObject( pi.hProcess, INFINITE );

#endif

	FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid)
		sp->s_wflag = DOWN;

	return TCL_OK;
}

int
dgo_vnirt_cmd(struct dg_obj	*dgop,
	      struct view_obj	*vop,
	      Tcl_Interp	*interp,
	      int		argc,
	      char		**argv) {
    register int i;
    int status;
    fastf_t sf = 1.0 * DG_INV_GED;
    vect_t view_ray_orig;
    vect_t center_model;
    struct bu_vls x_vls;
    struct bu_vls y_vls;
    struct bu_vls z_vls;
    char **av;

    /*
     * The last two arguments are expected to be x,y in view coordinates.
     * It is also assumed that view z will be the front of the viewing cube.
     * These coordinates are converted to x,y,z in model coordinates and then
     * converted to local units before being handed to nirt. All other
     * arguments are passed straight through to nirt.
     */
    if(sscanf(argv[argc-2], "%lf", &view_ray_orig[X]) != 1 ||
       sscanf(argv[argc-1], "%lf", &view_ray_orig[Y]) != 1){
	return TCL_ERROR;
    }
    view_ray_orig[Z] = DG_GED_MAX;
    argc -= 2;

    av = (char **)bu_malloc(sizeof(char *) * (argc + 4), "dgo_vnirt_cmd: av");

    /* Calculate point from which to fire ray */
    VSCALE(view_ray_orig, view_ray_orig, sf);
    MAT4X3PNT(center_model, vop->vo_view2model, view_ray_orig);
    VSCALE(center_model, center_model, dgop->dgo_wdbp->dbip->dbi_base2local);

    bu_vls_init(&x_vls);
    bu_vls_init(&y_vls);
    bu_vls_init(&z_vls);
    bu_vls_printf(&x_vls, "%lf", center_model[X]);
    bu_vls_printf(&y_vls, "%lf", center_model[Y]);
    bu_vls_printf(&z_vls, "%lf", center_model[Z]);

    /* pass remaining arguments to nirt */
    av[0] = "nirt";
    for(i = 1; i < argc; ++i)
	av[i] = argv[i];

    /* pass modified coordinates to nirt */
    av[i++] = bu_vls_addr(&x_vls);
    av[i++] = bu_vls_addr(&y_vls);
    av[i++] = bu_vls_addr(&z_vls);
    av[i] = (char *)NULL;

    status = dgo_nirt_cmd(dgop, vop, interp, argc + 3, av);

    bu_vls_free(&x_vls);
    bu_vls_free(&y_vls);
    bu_vls_free(&z_vls);
    bu_free((genptr_t)av, "dgo_vnirt_cmd: av");

    return status;
}
@


1.9
log
@change conf.h to a wrapped config.h
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/librt/nirt.c,v 1.8 2004/05/10 15:25:27 morrison Exp $ (BRL)";
@


1.8
log
@Bob Parker's view modifications, png framebuffer support, shaded drawing mode
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nirt.c,v 1.7 2004/04/05 08:48:57 morrison Exp $ (BRL)";
d31 5
a35 1
#include "conf.h"
@


1.7
log
@merge of ansi-6-0-branch into HEAD
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
a114 9
	if (argc < 1 || RT_MAXARGS < argc) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib_alias dgo_nirt %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);

		return TCL_ERROR;
	}

d547 65
@


1.6
log
@merge of windows-6-0-branch into head
@
text
@d61 1
a61 1
extern void dgo_qray_data_to_vlist();
d64 3
a66 3
extern int dgo_build_tops();
extern void dgo_cvt_vlblock_to_solids();
extern void dgo_pr_wait_status();
@


1.5
log
@update copyright to include span through 2003
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nirt.c,v 1.4 2002/08/20 17:08:03 jra Exp $ (BRL)";
d41 1
d43 1
d56 4
d85 1
d89 11
a99 1
	int use_input_orig = 0;
d224 11
a234 4
			if (*val == '\0')
				bu_vls_printf(&o_vls, " fmt r \"\\n\" ");
			else {
				bu_vls_printf(&o_vls, " fmt r \"\\n%*s\" ", count, val);
d303 1
a303 1

d348 119
d537 3
d544 1
a544 1
	if (retcode != 0)
d546 5
@


1.4
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1988 by the United States Army.
d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nirt.c,v 1.2 2001/11/29 17:14:21 bparker Exp $ (BRL)";
@


1.4.10.1
log
@merge from HEAD
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1988-2004 by the United States Army.
d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nirt.c,v 1.5 2004/02/02 17:39:22 morrison Exp $ (BRL)";
@


1.4.10.2
log
@merge from head
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nirt.c,v 1.4.10.1 2004/02/12 18:37:43 erikg Exp $ (BRL)";
@


1.4.10.3
log
@merge from head
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
a40 1
#ifndef WIN32
a41 1
#endif
a53 4
#ifdef WIN32
#include <fcntl.h>
#endif

a78 1
#ifndef WIN32
d82 1
a82 11
#else
	HANDLE pipe_in[2],hSaveStdin,pipe_inDup;
	HANDLE pipe_out[2],hSaveStdout,pipe_outDup;
	HANDLE pipe_err[2],hSaveStderr,pipe_errDup;
	STARTUPINFO si = {0};
   PROCESS_INFORMATION pi = {0};
   SECURITY_ATTRIBUTES sa          = {0};
   char name[1024];
   char line1[2048];
#endif
   int use_input_orig = 0;
d207 4
a210 11
#ifndef WIN32
	    if(*val == '\0')
	      bu_vls_printf(&o_vls, " fmt r \"\\n\" ");
	    else{
	      bu_vls_printf(&o_vls, " fmt r \"\\n%*s\" ", count, val);
#else
		if(*val == '\0')
	      bu_vls_printf(&o_vls, " fmt r \\\"\\\\n\\\" ");
	    else{
	      bu_vls_printf(&o_vls, " fmt r \\\"\\\\n%*s\\\" ", count, val);
#endif
d279 1
a279 1
#ifndef WIN32
a323 119
#else
		sa.nLength = sizeof(sa);
    sa.bInheritHandle = TRUE;
    sa.lpSecurityDescriptor = NULL;

	// Save the handle to the current STDOUT.  
	hSaveStdout = GetStdHandle(STD_OUTPUT_HANDLE);  
	
	// Create a pipe for the child process's STDOUT.  
	CreatePipe( &pipe_out[0], &pipe_out[1], &sa, 0);

	// Set a write handle to the pipe to be STDOUT.  
	SetStdHandle(STD_OUTPUT_HANDLE, pipe_out[1]);  

	// Create noninheritable read handle and close the inheritable read handle. 
    DuplicateHandle( GetCurrentProcess(), pipe_out[0],
        GetCurrentProcess(),  &pipe_outDup , 
		0,  FALSE,
        DUPLICATE_SAME_ACCESS );
	CloseHandle( pipe_out[0] );

	// Save the handle to the current STDERR.  
	hSaveStderr = GetStdHandle(STD_ERROR_HANDLE);  
	
	// Create a pipe for the child process's STDERR.  
	CreatePipe( &pipe_err[0], &pipe_err[1], &sa, 0);

	// Set a write handle to the pipe to be STDERR.  
	SetStdHandle(STD_ERROR_HANDLE, pipe_err[1]);  

	// Create noninheritable read handle and close the inheritable read handle. 
    DuplicateHandle( GetCurrentProcess(), pipe_err[0],
        GetCurrentProcess(),  &pipe_errDup , 
		0,  FALSE,
        DUPLICATE_SAME_ACCESS );
	CloseHandle( pipe_err[0] );
	
	// The steps for redirecting child process's STDIN: 
	//     1.  Save current STDIN, to be restored later. 
	//     2.  Create anonymous pipe to be STDIN for child process. 
	//     3.  Set STDIN of the parent to be the read handle to the 
	//         pipe, so it is inherited by the child process. 
	//     4.  Create a noninheritable duplicate of the write handle, 
	//         and close the inheritable write handle.  

	// Save the handle to the current STDIN. 
	hSaveStdin = GetStdHandle(STD_INPUT_HANDLE);  

	// Create a pipe for the child process's STDIN.  
	CreatePipe(&pipe_in[0], &pipe_in[1], &sa, 0);
	// Set a read handle to the pipe to be STDIN.  
	SetStdHandle(STD_INPUT_HANDLE, pipe_in[0]);
	// Duplicate the write handle to the pipe so it is not inherited.  
	DuplicateHandle(GetCurrentProcess(), pipe_in[1], 
		GetCurrentProcess(), &pipe_inDup, 
		0, FALSE,                  // not inherited       
		DUPLICATE_SAME_ACCESS ); 
	CloseHandle(pipe_in[1]); 


   si.cb = sizeof(STARTUPINFO);
   si.lpReserved = NULL;
   si.lpReserved2 = NULL;
   si.cbReserved2 = 0;
   si.lpDesktop = NULL;
   si.dwFlags = 0;
   si.dwFlags = STARTF_USESTDHANDLES;
   si.hStdInput   = pipe_in[0];
   si.hStdOutput  = pipe_out[1];
   si.hStdError   = pipe_err[1];


   sprintf(line1,"%s ",dgop->dgo_rt_cmd[0]);
   for(i=1;i<dgop->dgo_rt_cmd_len;i++) {
	   sprintf(name,"%s ",dgop->dgo_rt_cmd[i]);
	   strcat(line1,name); 
	   if(strstr(name,"-e") != NULL) {
		   i++;
		   sprintf(name,"\"%s\" ",dgop->dgo_rt_cmd[i]);
			strcat(line1,name);} 
   }
   
   if(CreateProcess( NULL,
                     line1,
                     NULL,
                     NULL,
                     TRUE,
                     DETACHED_PROCESS,
                     NULL,
                     NULL,
                     &si,
                     &pi )) {

	SetStdHandle(STD_INPUT_HANDLE, hSaveStdin);
	SetStdHandle(STD_OUTPUT_HANDLE, hSaveStdout);
	SetStdHandle(STD_ERROR_HANDLE, hSaveStderr);
}
 
	/* use fp_in to feed view info to nirt */
	CloseHandle( pipe_in[0] );
	fp_in = _fdopen( _open_osfhandle((HFILE)pipe_inDup,_O_TEXT), "w" );
	//fp_in = fdopen( pipe_in[1], "w" );

	/* use fp_out to read back the result */
	CloseHandle( pipe_out[1] );
	//fp_out = fdopen( pipe_out[0], "r" );
	fp_out = _fdopen( _open_osfhandle((HFILE)pipe_outDup,_O_TEXT), "r" );

	/* use fp_err to read any error messages */
	CloseHandle(pipe_err[1]);
	//fp_err = fdopen( pipe_err[0], "r" );
	fp_err = _fdopen( _open_osfhandle((HFILE)pipe_errDup,_O_TEXT), "r" );

	/* send quit command to nirt */
	fwrite( "q\n", 1, 2, fp_in );
	(void)fclose( fp_in );

#endif

a393 3
	
#ifndef WIN32

d398 1
a398 1
	if( retcode != 0 )
a399 5
#else
	/* Wait for program to finish */
	WaitForSingleObject( pi.hProcess, INFINITE );

#endif
@


1.4.4.1
log
@Modifications (on a 6.0 source distribution) for initial port to windows (merged with sources close to 6.0.2)
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nirt.c,v 1.4 2002/08/20 17:08:03 jra Exp $ (BRL)";
a40 1
#ifndef WIN32
a41 1
#endif
a53 4
#ifdef WIN32
#include <fcntl.h>
#endif

a78 1
#ifndef WIN32
d82 1
a82 11
#else
	HANDLE pipe_in[2],hSaveStdin,pipe_inDup;
	HANDLE pipe_out[2],hSaveStdout,pipe_outDup;
	HANDLE pipe_err[2],hSaveStderr,pipe_errDup;
	STARTUPINFO si = {0};
   PROCESS_INFORMATION pi = {0};
   SECURITY_ATTRIBUTES sa          = {0};
   char name[1024];
   char line1[2048];
#endif
   int use_input_orig = 0;
d207 4
a210 11
#ifndef WIN32
	    if(*val == '\0')
	      bu_vls_printf(&o_vls, " fmt r \"\\n\" ");
	    else{
	      bu_vls_printf(&o_vls, " fmt r \"\\n%*s\" ", count, val);
#else
		if(*val == '\0')
	      bu_vls_printf(&o_vls, " fmt r \\\"\\\\n\\\" ");
	    else{
	      bu_vls_printf(&o_vls, " fmt r \\\"\\\\n%*s\\\" ", count, val);
#endif
d279 1
a279 1
#ifndef WIN32
a323 119
#else
		sa.nLength = sizeof(sa);
    sa.bInheritHandle = TRUE;
    sa.lpSecurityDescriptor = NULL;

	// Save the handle to the current STDOUT.  
	hSaveStdout = GetStdHandle(STD_OUTPUT_HANDLE);  
	
	// Create a pipe for the child process's STDOUT.  
	CreatePipe( &pipe_out[0], &pipe_out[1], &sa, 0);

	// Set a write handle to the pipe to be STDOUT.  
	SetStdHandle(STD_OUTPUT_HANDLE, pipe_out[1]);  

	// Create noninheritable read handle and close the inheritable read handle. 
    DuplicateHandle( GetCurrentProcess(), pipe_out[0],
        GetCurrentProcess(),  &pipe_outDup , 
		0,  FALSE,
        DUPLICATE_SAME_ACCESS );
	CloseHandle( pipe_out[0] );

	// Save the handle to the current STDERR.  
	hSaveStderr = GetStdHandle(STD_ERROR_HANDLE);  
	
	// Create a pipe for the child process's STDERR.  
	CreatePipe( &pipe_err[0], &pipe_err[1], &sa, 0);

	// Set a write handle to the pipe to be STDERR.  
	SetStdHandle(STD_ERROR_HANDLE, pipe_err[1]);  

	// Create noninheritable read handle and close the inheritable read handle. 
    DuplicateHandle( GetCurrentProcess(), pipe_err[0],
        GetCurrentProcess(),  &pipe_errDup , 
		0,  FALSE,
        DUPLICATE_SAME_ACCESS );
	CloseHandle( pipe_err[0] );
	
	// The steps for redirecting child process's STDIN: 
	//     1.  Save current STDIN, to be restored later. 
	//     2.  Create anonymous pipe to be STDIN for child process. 
	//     3.  Set STDIN of the parent to be the read handle to the 
	//         pipe, so it is inherited by the child process. 
	//     4.  Create a noninheritable duplicate of the write handle, 
	//         and close the inheritable write handle.  

	// Save the handle to the current STDIN. 
	hSaveStdin = GetStdHandle(STD_INPUT_HANDLE);  

	// Create a pipe for the child process's STDIN.  
	CreatePipe(&pipe_in[0], &pipe_in[1], &sa, 0);
	// Set a read handle to the pipe to be STDIN.  
	SetStdHandle(STD_INPUT_HANDLE, pipe_in[0]);
	// Duplicate the write handle to the pipe so it is not inherited.  
	DuplicateHandle(GetCurrentProcess(), pipe_in[1], 
		GetCurrentProcess(), &pipe_inDup, 
		0, FALSE,                  // not inherited       
		DUPLICATE_SAME_ACCESS ); 
	CloseHandle(pipe_in[1]); 


   si.cb = sizeof(STARTUPINFO);
   si.lpReserved = NULL;
   si.lpReserved2 = NULL;
   si.cbReserved2 = 0;
   si.lpDesktop = NULL;
   si.dwFlags = 0;
   si.dwFlags = STARTF_USESTDHANDLES;
   si.hStdInput   = pipe_in[0];
   si.hStdOutput  = pipe_out[1];
   si.hStdError   = pipe_err[1];


   sprintf(line1,"%s ",dgop->dgo_rt_cmd[0]);
   for(i=1;i<dgop->dgo_rt_cmd_len;i++) {
	   sprintf(name,"%s ",dgop->dgo_rt_cmd[i]);
	   strcat(line1,name); 
	   if(strstr(name,"-e") != NULL) {
		   i++;
		   sprintf(name,"\"%s\" ",dgop->dgo_rt_cmd[i]);
			strcat(line1,name);} 
   }
   
   if(CreateProcess( NULL,
                     line1,
                     NULL,
                     NULL,
                     TRUE,
                     DETACHED_PROCESS,
                     NULL,
                     NULL,
                     &si,
                     &pi )) {

	SetStdHandle(STD_INPUT_HANDLE, hSaveStdin);
	SetStdHandle(STD_OUTPUT_HANDLE, hSaveStdout);
	SetStdHandle(STD_ERROR_HANDLE, hSaveStderr);
}
 
	/* use fp_in to feed view info to nirt */
	CloseHandle( pipe_in[0] );
	fp_in = _fdopen( _open_osfhandle((HFILE)pipe_inDup,_O_TEXT), "w" );
	//fp_in = fdopen( pipe_in[1], "w" );

	/* use fp_out to read back the result */
	CloseHandle( pipe_out[1] );
	//fp_out = fdopen( pipe_out[0], "r" );
	fp_out = _fdopen( _open_osfhandle((HFILE)pipe_outDup,_O_TEXT), "r" );

	/* use fp_err to read any error messages */
	CloseHandle(pipe_err[1]);
	//fp_err = fdopen( pipe_err[0], "r" );
	fp_err = _fdopen( _open_osfhandle((HFILE)pipe_errDup,_O_TEXT), "r" );

	/* send quit command to nirt */
	fwrite( "q\n", 1, 2, fp_in );
	(void)fclose( fp_in );

#endif

a393 3
	
#ifndef WIN32

d398 1
a398 1
	if( retcode != 0 )
a399 5
#else
	/* Wait for program to finish */
	WaitForSingleObject( pi.hProcess, INFINITE );

#endif
@


1.4.4.2
log
@sync to HEAD...
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1988-2004 by the United States Army.
d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/nirt.c,v 1.4.4.1 2002/09/26 23:04:03 morrison Exp $ (BRL)";
@


1.4.2.1
log
@Initial ANSIfication
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nirt.c,v 1.4 2002/08/20 17:08:03 jra Exp $ (BRL)";
d55 1
a55 1
extern void dgo_qray_data_to_vlist(struct dg_obj *dgop, struct bn_vlblock *vbp, struct dg_qray_dataList *headp, fastf_t *dir, int do_overlaps);
d58 3
a60 3
extern int dgo_build_tops(Tcl_Interp *interp, struct solid *hsp, char **start, register char **end);
extern void dgo_cvt_vlblock_to_solids(struct dg_obj *dgop, Tcl_Interp *interp, struct bn_vlblock *vbp, char *name, int copy);
extern void dgo_pr_wait_status(Tcl_Interp *interp, int status);
@


1.4.2.2
log
@sync branch with HEAD
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1988-2004 by the United States Army.
d28 1
a28 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
a40 1
#ifndef WIN32
a41 1
#endif
a53 4
#ifdef WIN32
#include <fcntl.h>
#endif

a78 1
#ifndef WIN32
d82 1
a82 11
#else
	HANDLE pipe_in[2],hSaveStdin,pipe_inDup;
	HANDLE pipe_out[2],hSaveStdout,pipe_outDup;
	HANDLE pipe_err[2],hSaveStderr,pipe_errDup;
	STARTUPINFO si = {0};
   PROCESS_INFORMATION pi = {0};
   SECURITY_ATTRIBUTES sa          = {0};
   char name[1024];
   char line1[2048];
#endif
   int use_input_orig = 0;
d207 4
a210 11
#ifndef WIN32
	    if(*val == '\0')
	      bu_vls_printf(&o_vls, " fmt r \"\\n\" ");
	    else{
	      bu_vls_printf(&o_vls, " fmt r \"\\n%*s\" ", count, val);
#else
		if(*val == '\0')
	      bu_vls_printf(&o_vls, " fmt r \\\"\\\\n\\\" ");
	    else{
	      bu_vls_printf(&o_vls, " fmt r \\\"\\\\n%*s\\\" ", count, val);
#endif
d279 1
a279 1
#ifndef WIN32
a323 119
#else
		sa.nLength = sizeof(sa);
    sa.bInheritHandle = TRUE;
    sa.lpSecurityDescriptor = NULL;

	// Save the handle to the current STDOUT.  
	hSaveStdout = GetStdHandle(STD_OUTPUT_HANDLE);  
	
	// Create a pipe for the child process's STDOUT.  
	CreatePipe( &pipe_out[0], &pipe_out[1], &sa, 0);

	// Set a write handle to the pipe to be STDOUT.  
	SetStdHandle(STD_OUTPUT_HANDLE, pipe_out[1]);  

	// Create noninheritable read handle and close the inheritable read handle. 
    DuplicateHandle( GetCurrentProcess(), pipe_out[0],
        GetCurrentProcess(),  &pipe_outDup , 
		0,  FALSE,
        DUPLICATE_SAME_ACCESS );
	CloseHandle( pipe_out[0] );

	// Save the handle to the current STDERR.  
	hSaveStderr = GetStdHandle(STD_ERROR_HANDLE);  
	
	// Create a pipe for the child process's STDERR.  
	CreatePipe( &pipe_err[0], &pipe_err[1], &sa, 0);

	// Set a write handle to the pipe to be STDERR.  
	SetStdHandle(STD_ERROR_HANDLE, pipe_err[1]);  

	// Create noninheritable read handle and close the inheritable read handle. 
    DuplicateHandle( GetCurrentProcess(), pipe_err[0],
        GetCurrentProcess(),  &pipe_errDup , 
		0,  FALSE,
        DUPLICATE_SAME_ACCESS );
	CloseHandle( pipe_err[0] );
	
	// The steps for redirecting child process's STDIN: 
	//     1.  Save current STDIN, to be restored later. 
	//     2.  Create anonymous pipe to be STDIN for child process. 
	//     3.  Set STDIN of the parent to be the read handle to the 
	//         pipe, so it is inherited by the child process. 
	//     4.  Create a noninheritable duplicate of the write handle, 
	//         and close the inheritable write handle.  

	// Save the handle to the current STDIN. 
	hSaveStdin = GetStdHandle(STD_INPUT_HANDLE);  

	// Create a pipe for the child process's STDIN.  
	CreatePipe(&pipe_in[0], &pipe_in[1], &sa, 0);
	// Set a read handle to the pipe to be STDIN.  
	SetStdHandle(STD_INPUT_HANDLE, pipe_in[0]);
	// Duplicate the write handle to the pipe so it is not inherited.  
	DuplicateHandle(GetCurrentProcess(), pipe_in[1], 
		GetCurrentProcess(), &pipe_inDup, 
		0, FALSE,                  // not inherited       
		DUPLICATE_SAME_ACCESS ); 
	CloseHandle(pipe_in[1]); 


   si.cb = sizeof(STARTUPINFO);
   si.lpReserved = NULL;
   si.lpReserved2 = NULL;
   si.cbReserved2 = 0;
   si.lpDesktop = NULL;
   si.dwFlags = 0;
   si.dwFlags = STARTF_USESTDHANDLES;
   si.hStdInput   = pipe_in[0];
   si.hStdOutput  = pipe_out[1];
   si.hStdError   = pipe_err[1];


   sprintf(line1,"%s ",dgop->dgo_rt_cmd[0]);
   for(i=1;i<dgop->dgo_rt_cmd_len;i++) {
	   sprintf(name,"%s ",dgop->dgo_rt_cmd[i]);
	   strcat(line1,name); 
	   if(strstr(name,"-e") != NULL) {
		   i++;
		   sprintf(name,"\"%s\" ",dgop->dgo_rt_cmd[i]);
			strcat(line1,name);} 
   }
   
   if(CreateProcess( NULL,
                     line1,
                     NULL,
                     NULL,
                     TRUE,
                     DETACHED_PROCESS,
                     NULL,
                     NULL,
                     &si,
                     &pi )) {

	SetStdHandle(STD_INPUT_HANDLE, hSaveStdin);
	SetStdHandle(STD_OUTPUT_HANDLE, hSaveStdout);
	SetStdHandle(STD_ERROR_HANDLE, hSaveStderr);
}
 
	/* use fp_in to feed view info to nirt */
	CloseHandle( pipe_in[0] );
	fp_in = _fdopen( _open_osfhandle((HFILE)pipe_inDup,_O_TEXT), "w" );
	//fp_in = fdopen( pipe_in[1], "w" );

	/* use fp_out to read back the result */
	CloseHandle( pipe_out[1] );
	//fp_out = fdopen( pipe_out[0], "r" );
	fp_out = _fdopen( _open_osfhandle((HFILE)pipe_outDup,_O_TEXT), "r" );

	/* use fp_err to read any error messages */
	CloseHandle(pipe_err[1]);
	//fp_err = fdopen( pipe_err[0], "r" );
	fp_err = _fdopen( _open_osfhandle((HFILE)pipe_errDup,_O_TEXT), "r" );

	/* send quit command to nirt */
	fwrite( "q\n", 1, 2, fp_in );
	(void)fclose( fp_in );

#endif

a393 3
	
#ifndef WIN32

d398 1
a398 1
	if( retcode != 0 )
a399 5
#else
	/* Wait for program to finish */
	WaitForSingleObject( pi.hProcess, INFINITE );

#endif
@


1.3
log
@Converted from K&R to ANSI C - RFH
@
text
@d55 1
a55 1
extern void dgo_qray_data_to_vlist(struct dg_obj *dgop, struct bn_vlblock *vbp, struct dg_qray_dataList *headp, fastf_t *dir, int do_overlaps);
d58 3
a60 3
extern int dgo_build_tops(Tcl_Interp *interp, struct solid *hsp, char **start, register char **end);
extern void dgo_cvt_vlblock_to_solids(struct dg_obj *dgop, Tcl_Interp *interp, struct bn_vlblock *vbp, char *name, int copy);
extern void dgo_pr_wait_status(Tcl_Interp *interp, int status);
@


1.2
log
@*- call dgo_notify before attempting to
   generate any textual output
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nirt.c,v 1.1 2001/11/27 17:52:30 bparker Exp $ (BRL)";
d55 1
a55 1
extern void dgo_qray_data_to_vlist();
d58 3
a60 3
extern int dgo_build_tops();
extern void dgo_cvt_vlblock_to_solids();
extern void dgo_pr_wait_status();
@


1.1
log
@*- routines to interface with nirt
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/mged/rtif.c,v 11.98 2001/11/14 18:49:26 bparker Exp $ (BRL)";
d374 7
a402 2

	dgo_notify(dgop, interp);
@

