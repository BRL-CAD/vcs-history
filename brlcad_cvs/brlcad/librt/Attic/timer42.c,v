head	11.13;
access;
symbols
	ansi-20040405-merged:11.8.2.2
	postmerge-20040405-ansi:11.11
	premerge-20040404-ansi:11.10
	postmerge-autoconf:11.10
	autoconf-freeze:11.9.2.2
	premerge-autoconf:11.10
	ansi-20040316-freeze:11.8.2.1
	postmerge-20040315-windows:11.10
	premerge-20040315-windows:11.10
	windows-20040315-freeze:11.8.4.1
	autoconf-20031203:11.9
	autoconf-20031202:11.9
	autoconf-branch:11.9.0.2
	phong-branch:11.8.0.8
	photonmap-branch:11.8.0.6
	rel-6-1-DP:11.8
	windows-branch:11.8.0.4
	rel-6-0-2:11.6
	ansi-branch:11.8.0.2
	rel-6-0-1-branch:11.6.0.2
	hartley-6-0-post:11.7
	hartley-6-0-pre:11.6
	rel-6-0-1:11.6
	rel-6-0:11.6
	rel-5-4:11.3
	offsite-5-3-pre:11.5
	rel-5-3:11.3
	rel-5-2:11.3
	rel-5-1-branch:11.3.0.2
	rel-5-1:11.3
	rel-5-0:11.2
	rel-5-0-beta:11.2
	rel-4-5:11.2
	ctj-4-5-post:11.2
	ctj-4-5-pre:11.2
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.2
	rel-1-10:4.1
	rt-2:2.1;
locks; strict;
comment	@ * @;


11.13
date	2004.05.21.18.07.35;	author morrison;	state dead;
branches;
next	11.12;

11.12
date	2004.05.10.15.30.47;	author erikg;	state Exp;
branches;
next	11.11;

11.11
date	2004.04.05.08.48.58;	author morrison;	state Exp;
branches;
next	11.10;

11.10
date	2004.02.02.17.39.29;	author morrison;	state Exp;
branches;
next	11.9;

11.9
date	2003.10.07.01.24.41;	author morrison;	state Exp;
branches
	11.9.2.1;
next	11.8;

11.8
date	2002.08.20.17.08.10;	author jra;	state Exp;
branches
	11.8.2.1
	11.8.4.1;
next	11.7;

11.7
date	2002.08.15.20.55.22;	author hartley;	state Exp;
branches;
next	11.6;

11.6
date	2002.03.12.16.18.42;	author jra;	state Exp;
branches;
next	11.5;

11.5
date	2000.08.21.02.02.34;	author butler;	state Exp;
branches;
next	11.4;

11.4
date	2000.07.10.23.01.50;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	2000.03.29.17.46.30;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	96.08.27.02.30.49;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.58.45;	author mike;	state Rel4_4;
branches;
next	10.8;

10.8
date	94.11.04.05.59.56;	author mike;	state Exp;
branches;
next	10.7;

10.7
date	94.09.30.15.57.35;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	94.09.28.18.03.56;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	94.08.22.15.30.49;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	94.08.10.20.16.29;	author gdurf;	state Exp;
branches;
next	10.3;

10.3
date	93.10.01.21.41.15;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	92.04.04.00.09.53;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.41.05;	author mike;	state Rel4_0;
branches;
next	9.1;

9.1
date	89.05.19.05.57.21;	author mike;	state Rel3_5;
branches;
next	8.1;

8.1
date	88.10.05.00.31.54;	author mike;	state Rel3_0;
branches;
next	7.1;

7.1
date	87.11.02.23.34.37;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.07.56.54;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.12.53;	author mike;	state Rel;
branches;
next	4.3;

4.3
date	87.03.12.13.29.40;	author moss;	state Exp;
branches;
next	4.2;

4.2
date	87.02.12.22.12.13;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.46.18;	author mike;	state Rel1;
branches;
next	3.1;

3.1
date	86.07.11.01.33.12;	author mike;	state Exp;
branches;
next	3.0;

3.0
date	86.06.10.01.34.16;	author mike;	state Exp;
branches;
next	2.2;

2.2
date	85.09.11.19.56.01;	author mike;	state Exp;
branches;
next	2.1;

2.1
date	85.08.31.06.07.29;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	85.06.05.00.26.22;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	85.03.25.11.47.18;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	84.11.23.20.54.48;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	84.11.20.20.15.05;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	84.05.03.06.55.34;	author mike;	state Exp;
branches;
next	;

11.8.2.1
date	2002.09.19.18.01.47;	author morrison;	state Exp;
branches;
next	11.8.2.2;

11.8.2.2
date	2004.03.17.21.19.00;	author morrison;	state Exp;
branches;
next	;

11.8.4.1
date	2004.03.11.23.43.46;	author morrison;	state Exp;
branches;
next	;

11.9.2.1
date	2004.02.12.18.37.47;	author erikg;	state Exp;
branches;
next	11.9.2.2;

11.9.2.2
date	2004.03.15.14.07.30;	author erikg;	state Exp;
branches;
next	;


desc
@Time and resource consumption support for RT
@


11.13
log
@moved to src/
@
text
@/*
 *			T I M E R 4 2 . C
 *
 * Function -
 *	To provide timing information for RT when running on 4.2 BSD UNIX.
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1985-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCStimer[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/timer42.c,v 11.12 2004/05/10 15:30:47 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <string.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/resource.h>

#include "machine.h"
#include "externs.h"
#include "bu.h"
#include "vmath.h"
#include "raytrace.h"

static struct	timeval time0;	/* Time at which timeing started */
static struct	rusage ru0;	/* Resource utilization at the start */
static struct	rusage ru0c;	/* Resource utilization at the start */

static void prusage(register struct rusage *r0, register struct rusage *r1, struct timeval *e, struct timeval *b, struct bu_vls *vp);
#if 0
static void tvadd();
#endif
static void tvsub(struct timeval *tdiff, struct timeval *t1, struct timeval *t0);
static void psecs(long int l, struct bu_vls *vp);



/*
 *			R T _ P R E P _ T I M E R
 */
void
rt_prep_timer(void)
{
	gettimeofday(&time0, (struct timezone *)0);
	getrusage(RUSAGE_SELF, &ru0);
	getrusage(RUSAGE_CHILDREN, &ru0c);
}

/*
 *			R T _ G E T _ T I M E R
 *
 *  Reports on the passage of time, since rt_prep_timer() was called.
 *  Explicit return is number of CPU seconds.
 *  String return is descriptive.
 *  If "elapsed" pointer is non-null, number of elapsed seconds are returned.
 *  Times returned will never be zero.
 */
double
rt_get_timer(struct bu_vls *vp, double *elapsed)
{
	struct timeval timedol;
	struct rusage ru1;
	struct rusage ru1c;
	struct timeval td;
	double	user_cpu_secs;
	double	elapsed_secs;


	getrusage(RUSAGE_SELF, &ru1);
	getrusage(RUSAGE_CHILDREN, &ru1c);
	gettimeofday(&timedol, (struct timezone *)0);

	elapsed_secs = (timedol.tv_sec - time0.tv_sec) +
		(timedol.tv_usec - time0.tv_usec)/1000000.0;

	tvsub( &td, &ru1.ru_utime, &ru0.ru_utime );
	user_cpu_secs = td.tv_sec + ((double)td.tv_usec) / 1000000.0;

	tvsub( &td, &ru1c.ru_utime, &ru0c.ru_utime );
	user_cpu_secs += td.tv_sec + ((double)td.tv_usec) / 1000000.0;

	if( user_cpu_secs < 0.00001 )  user_cpu_secs = 0.00001;
	if( elapsed_secs < 0.00001 )  elapsed_secs = user_cpu_secs;	/* It can't be any less! */

	if( elapsed )  *elapsed = elapsed_secs;

	if( vp )  {
		bu_vls_printf( vp, "cpu = %g sec, elapsed = %g sec\n",
			user_cpu_secs, elapsed_secs );
		bu_vls_strcat( vp, "    parent: " );
		prusage(&ru0, &ru1, &timedol, &time0, vp);
		bu_vls_strcat( vp, "\n  children: ");
		prusage(&ru0c, &ru1c, &timedol, &time0, vp);
	}

	return( user_cpu_secs );
}

static void
prusage(register struct rusage *r0, register struct rusage *r1, struct timeval *e, struct timeval *b, struct bu_vls *vp)
{
	struct timeval tdiff;
	register time_t t;
	register char *cp;
	register int i;
	int ms;

	BU_CK_VLS(vp);

	t = (r1->ru_utime.tv_sec-r0->ru_utime.tv_sec)*100+
	    (r1->ru_utime.tv_usec-r0->ru_utime.tv_usec)/10000+
	    (r1->ru_stime.tv_sec-r0->ru_stime.tv_sec)*100+
	    (r1->ru_stime.tv_usec-r0->ru_stime.tv_usec)/10000;
	ms =  (e->tv_sec-b->tv_sec)*100 + (e->tv_usec-b->tv_usec)/10000;

	cp = "%Uuser %Ssys %Ereal %P %Xi+%Dd %Mmaxrss %F+%Rpf %Ccsw";
	for (; *cp; cp++)  {
		if (*cp != '%')
			bu_vls_putc( vp, *cp );
		else if (cp[1]) switch(*++cp) {

		case 'U':
			tvsub(&tdiff, &r1->ru_utime, &r0->ru_utime);
			bu_vls_printf(vp, "%d.%01d", tdiff.tv_sec, tdiff.tv_usec/100000);
			break;

		case 'S':
			tvsub(&tdiff, &r1->ru_stime, &r0->ru_stime);
			bu_vls_printf(vp, "%d.%01d", tdiff.tv_sec, tdiff.tv_usec/100000);
			break;

		case 'E':
			psecs(ms / 100, vp);
			break;

		case 'P':
			bu_vls_printf(vp, "%d%%", (int) (t*100 / ((ms ? ms : 1))));
			break;

		case 'W':
			i = r1->ru_nswap - r0->ru_nswap;
			bu_vls_printf(vp, "%d", i);
			break;

		case 'X':
			bu_vls_printf(vp, "%d", t == 0 ? 0 : (r1->ru_ixrss-r0->ru_ixrss)/t);
			break;

		case 'D':
			bu_vls_printf(vp, "%d", t == 0 ? 0 :
			    (r1->ru_idrss+r1->ru_isrss-(r0->ru_idrss+r0->ru_isrss))/t);
			break;

		case 'K':
			bu_vls_printf(vp, "%d", t == 0 ? 0 :
			    ((r1->ru_ixrss+r1->ru_isrss+r1->ru_idrss) -
			    (r0->ru_ixrss+r0->ru_idrss+r0->ru_isrss))/t);
			break;

		case 'M':
			bu_vls_printf(vp, "%d", r1->ru_maxrss/2);
			break;

		case 'F':
			bu_vls_printf(vp, "%d", r1->ru_majflt-r0->ru_majflt);
			break;

		case 'R':
			bu_vls_printf(vp, "%d", r1->ru_minflt-r0->ru_minflt);
			break;

		case 'I':
			bu_vls_printf(vp, "%d", r1->ru_inblock-r0->ru_inblock);
			break;

		case 'O':
			bu_vls_printf(vp, "%d", r1->ru_oublock-r0->ru_oublock);
			break;
		case 'C':
			bu_vls_printf(vp, "%d+%d", r1->ru_nvcsw-r0->ru_nvcsw,
				r1->ru_nivcsw-r0->ru_nivcsw );
			break;
		}
	}
}

#if 0
static void
tvadd(tsum, t0)
	struct timeval *tsum, *t0;
{

	tsum->tv_sec += t0->tv_sec;
	tsum->tv_usec += t0->tv_usec;
	if (tsum->tv_usec > 1000000)
		tsum->tv_sec++, tsum->tv_usec -= 1000000;
}
#endif

static void
tvsub(struct timeval *tdiff, struct timeval *t1, struct timeval *t0)
{

	tdiff->tv_sec = t1->tv_sec - t0->tv_sec;
	tdiff->tv_usec = t1->tv_usec - t0->tv_usec;
	if (tdiff->tv_usec < 0)
		tdiff->tv_sec--, tdiff->tv_usec += 1000000;
}

static void
psecs(long int l, struct bu_vls *vp)
{
	register int i;

	i = l / 3600;
	if (i) {
		register int	j;
		bu_vls_printf(vp, "%d:", i);
		i = l % 3600;
		j = i / 60;
		bu_vls_printf(vp, "%d%d", j / 10, j % 10);
	} else {
		i = l;
		bu_vls_printf(vp, "%d", i / 60);
	}
	i = i % 60; /* GSM: bug in Alliant CE optimization prohibits "%=" here */
	bu_vls_printf(vp, ":%d%d", i / 10, i % 10);
}

/*
 *			R T _ R E A D _ T I M E R
 * 
 *  Compatability routine
 */
double
rt_read_timer(char *str, int len)
{
	struct bu_vls	vls;
	double		cpu;
	int		todo;

	if( !str )  return  rt_get_timer( (struct bu_vls *)0, (double *)0 );

	bu_vls_init( &vls );
	cpu = rt_get_timer( &vls, (double *)0 );
	todo = bu_vls_strlen( &vls );
	if( todo > len )  todo = len-1;
	strncpy( str, bu_vls_addr(&vls), todo );
	str[todo] = '\0';
	return cpu;
}
@


11.12
log
@change conf.h to a wrapped config.h
@
text
@d17 1
a17 1
static const char RCStimer[] = "@@(#)$Header: /cvs/brlcad/librt/timer42.c,v 11.11 2004/04/05 08:48:58 morrison Exp $ (BRL)";
@


11.11
log
@merge of ansi-6-0-branch into HEAD
@
text
@d17 1
a17 1
static const char RCStimer[] = "@@(#)$Header$ (BRL)";
d20 5
a24 1
#include "conf.h"
@


11.10
log
@update copyright to include span through 2003
@
text
@d17 1
a17 1
static const char RCStimer[] = "@@(#)$Header: /c/CVS/brlcad/librt/timer42.c,v 11.9 2003/10/07 01:24:41 morrison Exp $ (BRL)";
d38 1
a38 1
static void prusage();
d42 3
a44 2
static void tvsub();
static void psecs();
d51 1
a51 1
rt_prep_timer()
d68 1
a68 3
rt_get_timer( vp, elapsed )
struct bu_vls	*vp;
double		*elapsed;
d109 1
a109 4
prusage(r0, r1, e, b, vp)
register struct rusage *r0, *r1;
struct timeval *e, *b;
struct bu_vls	*vp;	
d210 1
a210 2
tvsub(tdiff, t1, t0)
	struct timeval *tdiff, *t1, *t0;
d220 1
a220 3
psecs(l, vp)
long		l;
struct bu_vls	*vp;
d245 1
a245 2
rt_read_timer(str,len)
char *str;
@


11.9
log
@remove the linux warning about incorrect cpu utilization... shaweet.
@
text
@d13 1
a13 1
 *	This software is Copyright (C) 1985 by the United States Army.
d17 1
a17 1
static const char RCStimer[] = "@@(#)$Header: /c/CVS/brlcad/librt/timer42.c,v 11.8 2002/08/20 17:08:10 jra Exp $ (BRL)";
@


11.9.2.1
log
@merge from HEAD
@
text
@d13 1
a13 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d17 1
a17 1
static const char RCStimer[] = "@@(#)$Header: /c/CVS/brlcad/librt/timer42.c,v 11.10 2004/02/02 17:39:29 morrison Exp $ (BRL)";
@


11.9.2.2
log
@merge from head
@
text
@d17 1
a17 1
static const char RCStimer[] = "@@(#)$Header: /c/CVS/brlcad/librt/timer42.c,v 11.9.2.1 2004/02/12 18:37:47 erikg Exp $ (BRL)";
@


11.8
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d17 1
a17 1
static const char RCStimer[] = "@@(#)$Header: /c/CVS/brlcad/librt/timer42.c,v 11.6 2002/03/12 16:18:42 jra Exp $ (BRL)";
d45 1
d78 1
d87 1
a87 1
	user_cpu_secs = td.tv_sec + ((double)td.tv_usec) / 1000000;
d90 1
a90 1
	user_cpu_secs += td.tv_sec + ((double)td.tv_usec) / 1000000;
a97 7
#ifdef linux
		if( rt_g.rtg_parallel != 0 ) {
			bu_log( "\t\t\tLinux machines do not know how to correctly account for CPU time used\n\
			by threads.You are trying to use more than one CPU, so the\n\
			times you see here are likely to be meaningless.\n" );
		}
#endif /* linux */
@


11.8.4.1
log
@sync to HEAD...
@
text
@d13 1
a13 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d17 1
a17 1
static const char RCStimer[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/timer42.c,v 11.10 2004/02/02 17:39:29 morrison Exp $ (BRL)";
a44 1

a76 1

d85 1
a85 1
	user_cpu_secs = td.tv_sec + ((double)td.tv_usec) / 1000000.0;
d88 1
a88 1
	user_cpu_secs += td.tv_sec + ((double)td.tv_usec) / 1000000.0;
d96 7
@


11.8.2.1
log
@Initial ANSIfication
@
text
@d17 1
a17 1
static const char RCStimer[] = "@@(#)$Header: /c/CVS/brlcad/librt/timer42.c,v 11.8 2002/08/20 17:08:10 jra Exp $ (BRL)";
d38 1
a38 1
static void prusage(register struct rusage *r0, register struct rusage *r1, struct timeval *e, struct timeval *b, struct bu_vls *vp);
d42 2
a43 2
static void tvsub(struct timeval *tdiff, struct timeval *t1, struct timeval *t0);
static void psecs(long int l, struct bu_vls *vp);
d49 1
a49 1
rt_prep_timer(void)
d66 3
a68 1
rt_get_timer(struct bu_vls *vp, double *elapsed)
d115 4
a118 1
prusage(register struct rusage *r0, register struct rusage *r1, struct timeval *e, struct timeval *b, struct bu_vls *vp)
d219 2
a220 1
tvsub(struct timeval *tdiff, struct timeval *t1, struct timeval *t0)
d230 3
a232 1
psecs(long int l, struct bu_vls *vp)
d257 2
a258 1
rt_read_timer(char *str, int len)
@


11.8.2.2
log
@sync branch with HEAD
@
text
@d13 1
a13 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d17 1
a17 1
static const char RCStimer[] = "@@(#)$Header$ (BRL)";
a44 1

a74 1

d83 1
a83 1
	user_cpu_secs = td.tv_sec + ((double)td.tv_usec) / 1000000.0;
d86 1
a86 1
	user_cpu_secs += td.tv_sec + ((double)td.tv_usec) / 1000000.0;
d94 7
@


11.7
log
@Converted from K&R to ANSI C - RFH
@
text
@d38 1
a38 1
static void prusage(register struct rusage *r0, register struct rusage *r1, struct timeval *e, struct timeval *b, struct bu_vls *vp);
d42 2
a43 2
static void tvsub(struct timeval *tdiff, struct timeval *t1, struct timeval *t0);
static void psecs(long int l, struct bu_vls *vp);
d49 1
a49 1
rt_prep_timer(void)
d66 3
a68 1
rt_get_timer(struct bu_vls *vp, double *elapsed)
d115 4
a118 1
prusage(register struct rusage *r0, register struct rusage *r1, struct timeval *e, struct timeval *b, struct bu_vls *vp)
d219 2
a220 1
tvsub(struct timeval *tdiff, struct timeval *t1, struct timeval *t0)
d230 3
a232 1
psecs(long int l, struct bu_vls *vp)
d257 2
a258 1
rt_read_timer(char *str, int len)
@


11.6
log
@Added a disclaimer for Linux timings when more than one CPU is used
@
text
@d17 1
a17 1
static const char RCStimer[] = "@@(#)$Header: /c/CVS/brlcad/librt/timer42.c,v 11.5 2000/08/21 02:02:34 butler Exp $ (BRL)";
d38 1
a38 1
static void prusage();
d42 2
a43 2
static void tvsub();
static void psecs();
d49 1
a49 1
rt_prep_timer()
d66 1
a66 3
rt_get_timer( vp, elapsed )
struct bu_vls	*vp;
double		*elapsed;
d113 1
a113 4
prusage(r0, r1, e, b, vp)
register struct rusage *r0, *r1;
struct timeval *e, *b;
struct bu_vls	*vp;	
d214 1
a214 2
tvsub(tdiff, t1, t0)
	struct timeval *tdiff, *t1, *t0;
d224 1
a224 3
psecs(l, vp)
long		l;
struct bu_vls	*vp;
d249 1
a249 2
rt_read_timer(str,len)
char *str;
@


11.5
log
@Massive compilation warnings eliminated
@
text
@d17 1
a17 1
static const char RCStimer[] = "@@(#)$Header: /c/CVS/brlcad/librt/timer42.c,v 11.4 2000/07/10 23:01:50 mike Exp $ (BRL)";
d31 2
d96 7
@


11.4
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d17 1
a17 1
static const char RCStimer[] = "@@(#)$Header: /c/CVS/brlcad/librt/timer42.c,v 11.3 2000/03/29 17:46:30 mike Exp $ (BRL)";
d23 1
@


11.3
log
@
Changed RT_VLS_CHECK to BU_CK_VLS
@
text
@d17 1
a17 1
static char RCStimer[] = "@@(#)$Header: /c/CVS/brlcad/librt/timer42.c,v 11.2 1996/08/27 02:30:49 mike Exp $ (BRL)";
@


11.2
log
@bu.h
@
text
@d17 1
a17 1
static char RCStimer[] = "@@(#)$Header: /m/cad/librt/RCS/timer42.c,v 11.1 1995/01/04 09:58:45 mike Rel4_4 mike $ (BRL)";
d116 1
a116 1
	RT_VLS_CHECK(vp);
@


11.1
log
@Release_4.4
@
text
@d17 1
a17 1
static char RCStimer[] = "@@(#)$Header: /m/cad/librt/RCS/timer42.c,v 10.8 94/11/04 05:59:56 mike Exp $ (BRL)";
d28 2
a29 1
#include "rtstring.h"
d64 1
a64 1
struct rt_vls	*vp;
d93 1
a93 1
		rt_vls_printf( vp, "cpu = %g sec, elapsed = %g sec\n",
d95 1
a95 1
		rt_vls_strcat( vp, "    parent: " );
d97 1
a97 1
		rt_vls_strcat( vp, "\n  children: ");
d108 1
a108 1
struct rt_vls	*vp;	
d127 1
a127 1
			rt_vls_putc( vp, *cp );
d132 1
a132 1
			rt_vls_printf(vp, "%d.%01d", tdiff.tv_sec, tdiff.tv_usec/100000);
d137 1
a137 1
			rt_vls_printf(vp, "%d.%01d", tdiff.tv_sec, tdiff.tv_usec/100000);
d145 1
a145 1
			rt_vls_printf(vp, "%d%%", (int) (t*100 / ((ms ? ms : 1))));
d150 1
a150 1
			rt_vls_printf(vp, "%d", i);
d154 1
a154 1
			rt_vls_printf(vp, "%d", t == 0 ? 0 : (r1->ru_ixrss-r0->ru_ixrss)/t);
d158 1
a158 1
			rt_vls_printf(vp, "%d", t == 0 ? 0 :
d163 1
a163 1
			rt_vls_printf(vp, "%d", t == 0 ? 0 :
d169 1
a169 1
			rt_vls_printf(vp, "%d", r1->ru_maxrss/2);
d173 1
a173 1
			rt_vls_printf(vp, "%d", r1->ru_majflt-r0->ru_majflt);
d177 1
a177 1
			rt_vls_printf(vp, "%d", r1->ru_minflt-r0->ru_minflt);
d181 1
a181 1
			rt_vls_printf(vp, "%d", r1->ru_inblock-r0->ru_inblock);
d185 1
a185 1
			rt_vls_printf(vp, "%d", r1->ru_oublock-r0->ru_oublock);
d188 1
a188 1
			rt_vls_printf(vp, "%d+%d", r1->ru_nvcsw-r0->ru_nvcsw,
d222 1
a222 1
struct rt_vls	*vp;
d229 1
a229 1
		rt_vls_printf(vp, "%d:", i);
d232 1
a232 1
		rt_vls_printf(vp, "%d%d", j / 10, j % 10);
d235 1
a235 1
		rt_vls_printf(vp, "%d", i / 60);
d238 1
a238 1
	rt_vls_printf(vp, ":%d%d", i / 10, i % 10);
d250 1
a250 1
	struct rt_vls	vls;
d254 1
a254 1
	if( !str )  return  rt_get_timer( (struct rt_vls *)0, (double *)0 );
d256 1
a256 1
	rt_vls_init( &vls );
d258 1
a258 1
	todo = rt_vls_strlen( &vls );
d260 1
a260 1
	strncpy( str, rt_vls_addr(&vls), todo );
@


10.8
log
@Irix 6.  tvadd() not used.
@
text
@d17 1
a17 1
static char RCStimer[] = "@@(#)$Header: /m/cad/librt/RCS/timer42.c,v 10.7 94/09/30 15:57:35 mike Exp Locker: mike $ (BRL)";
@


10.7
log
@Make the returned values explicit.
@
text
@d17 1
a17 1
static char RCStimer[] = "@@(#)$Header: /m/cad/librt/RCS/timer42.c,v 10.6 94/09/28 18:03:56 mike Exp Locker: mike $ (BRL)";
d35 1
d37 1
d194 1
d205 1
@


10.6
log
@Removed stray debugging rt_log() statement.
@
text
@d17 1
a17 1
static char RCStimer[] = "@@(#)$Header: /m/cad/librt/RCS/timer42.c,v 10.5 94/08/22 15:30:49 mike Exp Locker: mike $ (BRL)";
d90 3
a92 1
		rt_vls_strcat( vp, "parent: " );
d94 1
a94 1
		rt_vls_strcat( vp, "\n\tchildren: ");
@


10.5
log
@Corrected serious bug:  CPU time of child processes was not being counted!
@
text
@d17 1
a17 1
static char RCStimer[] = "@@(#)$Header: /m/cad/librt/RCS/timer42.c,v 10.4 94/08/10 20:16:29 gdurf Exp Locker: mike $ (BRL)";
a250 1
rt_log("rt_read_timer:  %g\n", cpu);
@


10.4
log
@Added include of conf.h
@
text
@d17 1
a17 1
static char RCStimer[] = "@@(#)$Header: /m/cad/librt/RCS/timer42.c,v 10.3 1993/10/01 21:41:15 mike Exp gdurf $ (BRL)";
a22 1
#define _BSD_TYPES		/* Needed for IRIX 5.0.1 */
d32 1
d47 1
d66 1
d72 1
d80 4
d89 2
a90 1
	if( vp )
d92 3
d251 1
@


10.3
log
@Ported to IRIX 5.0.1.
@
text
@d17 1
a17 1
static char RCStimer[] = "@@(#)$Header: /m/cad/librt/RCS/timer42.c,v 10.2 92/04/04 00:09:53 mike Exp Locker: mike $ (BRL)";
d19 2
@


10.2
log
@Changed primary interface to rt_get_timer(), which gives
elapsed time, and an rt_vls description of resource use.
@
text
@d17 1
a17 1
static char RCStimer[] = "@@(#)$Header: /m/cad/librt/RCS/timer42.c,v 10.1 91/10/12 06:41:05 mike Rel4_0 Locker: mike $ (BRL)";
d21 1
@


10.1
log
@Release_4.0
@
text
@d17 1
a17 1
static char RCStimer[] = "@@(#)$Header: timer42.c,v 9.1 89/05/19 05:57:21 mike Rel3_5 $ (BRL)";
d25 3
d37 1
a37 1
 *			P R E P _ T I M E R
d47 7
a53 2
 *			R E A D _ T I M E R
 * 
d56 3
a58 2
rt_read_timer(str,len)
char *str;
d63 2
a64 2
	double usert;
	char line[132];
d68 4
a71 2
	prusage(&ru0, &ru1, &timedol, &time0, line);
	(void)strncpy( str, line, len );
d73 10
a82 3
	usert = td.tv_sec + ((double)td.tv_usec) / 1000000;
	if( usert < 0.00001 )  usert = 0.00001;
	return( usert );
d86 4
a89 4
prusage(r0, r1, e, b, outp)
	register struct rusage *r0, *r1;
	struct timeval *e, *b;
	char *outp;
d97 2
a104 1
#define END(x)	{while(*x) x++;}
d108 1
a108 1
			*outp++ = *cp;
d113 1
a113 2
			sprintf(outp,"%d.%01d", tdiff.tv_sec, tdiff.tv_usec/100000);
			END(outp);
d118 1
a118 2
			sprintf(outp,"%d.%01d", tdiff.tv_sec, tdiff.tv_usec/100000);
			END(outp);
d122 1
a122 2
			psecs(ms / 100, outp);
			END(outp);
d126 1
a126 2
			sprintf(outp,"%d%%", (int) (t*100 / ((ms ? ms : 1))));
			END(outp);
d131 1
a131 2
			sprintf(outp,"%d", i);
			END(outp);
d135 1
a135 2
			sprintf(outp,"%d", t == 0 ? 0 : (r1->ru_ixrss-r0->ru_ixrss)/t);
			END(outp);
d139 1
a139 1
			sprintf(outp,"%d", t == 0 ? 0 :
a140 1
			END(outp);
d144 1
a144 1
			sprintf(outp,"%d", t == 0 ? 0 :
a146 1
			END(outp);
d150 1
a150 2
			sprintf(outp,"%d", r1->ru_maxrss/2);
			END(outp);
d154 1
a154 2
			sprintf(outp,"%d", r1->ru_majflt-r0->ru_majflt);
			END(outp);
d158 1
a158 2
			sprintf(outp,"%d", r1->ru_minflt-r0->ru_minflt);
			END(outp);
d162 1
a162 2
			sprintf(outp,"%d", r1->ru_inblock-r0->ru_inblock);
			END(outp);
d166 1
a166 2
			sprintf(outp,"%d", r1->ru_oublock-r0->ru_oublock);
			END(outp);
d169 1
a169 1
			sprintf(outp,"%d+%d", r1->ru_nvcsw-r0->ru_nvcsw,
a170 1
			END(outp);
a173 1
	*outp = '\0';
d199 3
a201 3
psecs(l,cp)
long l;
register char *cp;
d207 2
a208 2
		sprintf(cp,"%d:", i);
		END(cp);
d210 2
a211 2
		sprintf(cp,"%d%d", (i/60) / 10, (i/60) % 10);
		END(cp);
d214 1
a214 2
		sprintf(cp,"%d", i / 60);
		END(cp);
d217 25
a241 2
	*cp++ = ':';
	sprintf(cp,"%d%d", i / 10, i % 10);
@


9.1
log
@Release_3.5
@
text
@d17 1
a17 1
static char RCStimer[] = "@@(#)$Header: timer42.c,v 8.1 88/10/05 00:31:54 mike Rel3_0 $ (BRL)";
@


8.1
log
@Release_3.0
@
text
@d17 1
a17 1
static char RCStimer[] = "@@(#)$Header: timer42.c,v 7.1 87/11/02 23:34:37 mike Rel $ (BRL)";
@


7.1
log
@Release 2.3
@
text
@d17 1
a17 1
static char RCStimer[] = "@@(#)$Header: timer42.c,v 6.1 87/07/11 07:56:54 mike Rel $ (BRL)";
@


6.1
log
@Release 2.0
@
text
@d17 1
a17 1
static char RCStimer[] = "@@(#)$Header: timer42.c,v 5.1 87/06/24 22:12:53 mike Rel $ (BRL)";
@


5.1
log
@Release 1.24
@
text
@d17 1
a17 1
static char RCStimer[] = "@@(#)$Header: timer42.c,v 4.3 87/03/12 13:29:40 moss Exp $ (BRL)";
@


4.3
log
@Added work-around for Alliant CE optimizer bug.
@
text
@d17 1
a17 1
static char RCStimer[] = "@@(#)$Header: timer42.c,v 4.2 87/02/12 22:12:13 moss Locked $ (BRL)";
@


4.2
log
@Release 1.20 -- First Formal Release
@
text
@d17 1
a17 1
static char RCStimer[] = "@@(#)$Header: timer42.c,v 4.1 86/12/29 03:46:18 mike Rel1 $ (BRL)";
d213 1
a213 1
	i %= 60;
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d17 1
a17 1
static char RCStimer[] = "@@(#)$Header: timer42.c,v 3.1 86/07/11 01:33:12 mike Exp $ (BRL)";
@


3.1
log
@Cleanups inspired by the crummy compiler on the Cray XMP
@
text
@d17 1
a17 1
static char RCStimer[] = "@@(#)$Header: timer42.c,v 3.0 86/06/10 01:34:16 mike Exp $ (BRL)";
@


3.0
log
@rt/ and librt/ separated,
global datastructures simplified.
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: timer42.c,v 2.2 85/09/11 19:56:01 mike Exp $ (BRL)";
@


2.2
log
@Changed pr_timer to read_timer, which formats into a user supplied buffer,
so that user handles I/O of string as desired.
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: timer42.c,v 2.1 85/08/31 06:07:29 mike Exp $ (BRL)";
d37 1
a37 1
prep_timer()
d48 1
a48 1
read_timer(str,len)
@


2.1
log
@Version 2 of RT
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: timer42.c,v 1.5 85/06/05 00:26:22 mike Exp $ (BRL)";
a28 1
static void pdeltat();
a31 1
static void p2dig();
d44 1
a44 1
 *			P R _ T I M E R
d48 1
a48 1
pr_timer(str)
d55 1
d59 2
a60 2
	fprintf(stderr,"%s: ", str);
	prusage(&ru0, &ru1, &timedol, &time0);
d63 1
d68 1
a68 1
prusage(r0, r1, e, b)
d71 1
d73 1
d85 2
a86 1
	cp = "%Uuser %Ssys %Ereal %P %Xi+%Dd[%M]rss %F+%Rpf %Ccsw %Wswap";
d89 1
a89 1
			putc(*cp, stderr);
d93 3
a95 1
			pdeltat(&r1->ru_utime, &r0->ru_utime);
d99 3
a101 1
			pdeltat(&r1->ru_stime, &r0->ru_stime);
d105 2
a106 1
			psecs(ms / 100);
d110 2
a111 1
			fprintf(stderr,"%d%%", (int) (t*100 / ((ms ? ms : 1))));
d116 2
a117 1
			fprintf(stderr,"%d", i);
d121 2
a122 1
			fprintf(stderr,"%d", t == 0 ? 0 : (r1->ru_ixrss-r0->ru_ixrss)/t);
d126 1
a126 1
			fprintf(stderr,"%d", t == 0 ? 0 :
d128 1
d132 1
a132 1
			fprintf(stderr,"%d", t == 0 ? 0 :
d135 1
d139 2
a140 1
			fprintf(stderr,"%d", r1->ru_maxrss/2);
d144 2
a145 1
			fprintf(stderr,"%d", r1->ru_majflt-r0->ru_majflt);
d149 2
a150 1
			fprintf(stderr,"%d", r1->ru_minflt-r0->ru_minflt);
d154 2
a155 1
			fprintf(stderr,"%d", r1->ru_inblock-r0->ru_inblock);
d159 2
a160 1
			fprintf(stderr,"%d", r1->ru_oublock-r0->ru_oublock);
d163 1
a163 1
			fprintf(stderr,"%d+%d", r1->ru_nvcsw-r0->ru_nvcsw,
d165 1
d169 1
a169 1
	putc('\n',stderr);
a172 10
pdeltat(t1, t0)
	struct timeval *t1, *t0;
{
	struct timeval td;

	tvsub(&td, t1, t0);
	fprintf(stderr,"%d.%01d", td.tv_sec, td.tv_usec/100000);
}

static void
d195 3
a197 2
psecs(l)
	long l;
d203 2
a204 1
		fprintf(stderr,"%d:", i);
d206 6
a211 2
		p2dig(i / 60);
		goto minsec;
a212 3
	i = l;
	fprintf(stderr,"%d", i / 60);
minsec:
d214 2
a215 10
	fprintf(stderr,":");
	p2dig(i);
}

static void
p2dig(i)
	register int i;
{

	fprintf(stderr,"%d%d", i / 10, i % 10);
@


1.5
log
@timer_print, timer_prep changed to prep_timer, pr_timer
to accomodate compilers that only look at the first 8 chars.
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: timer42.c,v 1.4 85/03/25 11:47:18 mike Exp $ (BRL)";
@


1.4
log
@Housekeeping
@
text
@d17 1
a17 1
static char RCSid[] = "@@(#)$Header: timer42.c,v 1.3 84/11/23 20:54:48 mike Exp $ (BRL)";
d36 1
a36 1
 *			T I M E R _ P R E P
d39 1
a39 1
timer_prep()
d46 1
a46 1
 *			T I M E R _ P R I N T
d50 1
a50 1
timer_print(str)
@


1.3
log
@Added LOCAL, fastf_t declarations.
Made shootray() recursive.
@
text
@d2 1
a2 1
 *			T I M E R . C
d5 1
a5 1
 *	To provide timing information for RT.
d7 8
a14 3
 * Based on CSH sh.time.c module.
 *
 * $Revision: 1.2 $
d17 1
a17 1
static char RCSid[] = "@@(#)$Header: timer.c,v 1.2 84/11/20 20:15:05 mike Exp $ (BRL)";
@


1.2
log
@General cleanup
@
text
@d9 1
a9 1
 * $Revision: 1.1 $
d12 1
a12 1
static char RCSid[] = "@@(#)$Header: timer.c,v 1.1 84/05/03 06:55:34 mike Exp $ (BRL)";
d67 6
a72 2
	register time_t t =
	    (r1->ru_utime.tv_sec-r0->ru_utime.tv_sec)*100+
d76 1
a76 4
	register char *cp;
	register int i;
	int ms =
	    (e->tv_sec-b->tv_sec)*100 + (e->tv_usec-b->tv_usec)/10000;
d79 4
a82 4
	for (; *cp; cp++)
	if (*cp != '%')
		putchar(*cp);
	else if (cp[1]) switch(*++cp) {
d84 3
a86 3
	case 'U':
		pdeltat(&r1->ru_utime, &r0->ru_utime);
		break;
d88 3
a90 3
	case 'S':
		pdeltat(&r1->ru_stime, &r0->ru_stime);
		break;
d92 3
a94 3
	case 'E':
		psecs(ms / 100);
		break;
d96 3
a98 3
	case 'P':
		fprintf(stderr,"%d%%", (int) (t*100 / ((ms ? ms : 1))));
		break;
d100 4
a103 4
	case 'W':
		i = r1->ru_nswap - r0->ru_nswap;
		fprintf(stderr,"%d", i);
		break;
d105 3
a107 3
	case 'X':
		fprintf(stderr,"%d", t == 0 ? 0 : (r1->ru_ixrss-r0->ru_ixrss)/t);
		break;
d109 4
a112 4
	case 'D':
		fprintf(stderr,"%d", t == 0 ? 0 :
		    (r1->ru_idrss+r1->ru_isrss-(r0->ru_idrss+r0->ru_isrss))/t);
		break;
d114 5
a118 5
	case 'K':
		fprintf(stderr,"%d", t == 0 ? 0 :
		    ((r1->ru_ixrss+r1->ru_isrss+r1->ru_idrss) -
		    (r0->ru_ixrss+r0->ru_idrss+r0->ru_isrss))/t);
		break;
d120 3
a122 3
	case 'M':
		fprintf(stderr,"%d", r1->ru_maxrss/2);
		break;
d124 3
a126 3
	case 'F':
		fprintf(stderr,"%d", r1->ru_majflt-r0->ru_majflt);
		break;
d128 3
a130 3
	case 'R':
		fprintf(stderr,"%d", r1->ru_minflt-r0->ru_minflt);
		break;
d132 3
a134 3
	case 'I':
		fprintf(stderr,"%d", r1->ru_inblock-r0->ru_inblock);
		break;
d136 8
a143 7
	case 'O':
		fprintf(stderr,"%d", r1->ru_oublock-r0->ru_oublock);
		break;
	case 'C':
		fprintf(stderr,"%d+%d", r1->ru_nvcsw-r0->ru_nvcsw,
			r1->ru_nivcsw-r0->ru_nivcsw );
		break;
d145 1
a145 1
	putchar('\n');
@


1.1
log
@Initial revision
@
text
@d9 1
a9 1
 * $Revision$
d12 1
a12 1
static char RCSid[] = "@@(#)$Header: rt.c,v 1.6 84/05/02 05:09:57 mike Exp $ (BRL)";
d15 1
d23 7
d33 1
d55 1
a55 1
	printf("%s: ", str);
d62 1
a62 17
ruadd(ru, ru2)
	register struct rusage *ru, *ru2;
{
	register long *lp, *lp2;
	register int cnt;

	tvadd(&ru->ru_utime, &ru2->ru_utime);
	tvadd(&ru->ru_stime, &ru2->ru_stime);
	if (ru2->ru_maxrss > ru->ru_maxrss)
		ru->ru_maxrss = ru2->ru_maxrss;
	cnt = &ru->ru_last - &ru->ru_first + 1;
	lp = &ru->ru_first; lp2 = &ru2->ru_first;
	do
		*lp++ += *lp2++;
	while (--cnt > 0);
}

d96 1
a96 1
		printf("%d%%", (int) (t*100 / ((ms ? ms : 1))));
d101 1
a101 1
		printf("%d", i);
d105 1
a105 1
		printf("%d", t == 0 ? 0 : (r1->ru_ixrss-r0->ru_ixrss)/t);
d109 1
a109 1
		printf("%d", t == 0 ? 0 :
d114 1
a114 1
		printf("%d", t == 0 ? 0 :
d120 1
a120 1
		printf("%d", r1->ru_maxrss/2);
d124 1
a124 1
		printf("%d", r1->ru_majflt-r0->ru_majflt);
d128 1
a128 1
		printf("%d", r1->ru_minflt-r0->ru_minflt);
d132 1
a132 1
		printf("%d", r1->ru_inblock-r0->ru_inblock);
d136 1
a136 1
		printf("%d", r1->ru_oublock-r0->ru_oublock);
d139 1
a139 1
		printf("%d+%d", r1->ru_nvcsw-r0->ru_nvcsw,
d146 1
d153 1
a153 1
	printf("%d.%01d", td.tv_sec, td.tv_usec/100000);
d156 1
d167 1
d178 1
d186 1
a186 1
		printf("%d:", i);
d192 1
a192 1
	printf("%d", i / 60);
d195 1
a195 1
	printf(":");
d199 1
d204 1
a204 1
	printf("%d%d", i / 10, i % 10);
@
