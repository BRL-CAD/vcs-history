head	11.29;
access;
symbols
	ansi-20040405-merged:11.25.2.2
	postmerge-20040405-ansi:11.27
	premerge-20040404-ansi:11.26
	postmerge-autoconf:11.26
	autoconf-freeze:11.25.10.2
	premerge-autoconf:11.26
	ansi-20040316-freeze:11.25.2.1
	postmerge-20040315-windows:11.26
	premerge-20040315-windows:11.26
	windows-20040315-freeze:11.25.4.1
	autoconf-20031203:11.25
	autoconf-20031202:11.25
	autoconf-branch:11.25.0.10
	phong-branch:11.25.0.8
	photonmap-branch:11.25.0.6
	rel-6-1-DP:11.25
	windows-branch:11.25.0.4
	rel-6-0-2:11.23
	ansi-branch:11.25.0.2
	rel-6-0-1-branch:11.23.0.2
	hartley-6-0-post:11.24
	hartley-6-0-pre:11.23
	rel-6-0-1:11.23
	rel-6-0:11.23
	rel-5-4:11.13
	offsite-5-3-pre:11.20
	rel-5-3:11.13
	rel-5-2:11.13
	rel-5-1-branch:11.13.0.2
	rel-5-1:11.13
	rel-5-0:11.5
	rel-5-0-beta:11.4
	rel-4-5:11.3
	ctj-4-5-post:11.3
	ctj-4-5-pre:11.3
	rel-4-4:11.1;
locks; strict;
comment	@ * @;


11.29
date	2004.05.21.18.07.31;	author morrison;	state dead;
branches;
next	11.28;

11.28
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.27;

11.27
date	2004.04.05.08.48.57;	author morrison;	state Exp;
branches;
next	11.26;

11.26
date	2004.02.02.17.39.21;	author morrison;	state Exp;
branches;
next	11.25;

11.25
date	2002.08.20.17.08.01;	author jra;	state Exp;
branches
	11.25.2.1
	11.25.4.1
	11.25.10.1;
next	11.24;

11.24
date	2002.08.15.20.55.13;	author hartley;	state Exp;
branches;
next	11.23;

11.23
date	2001.10.02.19.24.30;	author jra;	state Exp;
branches;
next	11.22;

11.22
date	2001.04.20.22.29.47;	author morrison;	state Exp;
branches;
next	11.21;

11.21
date	2001.03.31.01.57.09;	author morrison;	state Exp;
branches;
next	11.20;

11.20
date	2000.10.18.18.10.34;	author butler;	state Exp;
branches;
next	11.19;

11.19
date	2000.08.21.02.02.31;	author butler;	state Exp;
branches;
next	11.18;

11.18
date	2000.07.10.23.01.34;	author mike;	state Exp;
branches;
next	11.17;

11.17
date	2000.06.30.15.38.03;	author mike;	state Exp;
branches;
next	11.16;

11.16
date	2000.06.30.15.31.15;	author mike;	state Exp;
branches;
next	11.15;

11.15
date	2000.06.27.15.33.31;	author bparker;	state Exp;
branches;
next	11.14;

11.14
date	2000.06.26.21.02.19;	author bparker;	state Exp;
branches;
next	11.13;

11.13
date	2000.04.12.02.34.35;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	2000.03.29.02.43.10;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	2000.03.28.20.43.29;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	2000.02.02.20.35.08;	author bparker;	state Exp;
branches;
next	11.9;

11.9
date	99.11.26.21.46.48;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	99.11.24.23.12.08;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	99.11.17.02.42.01;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	99.10.30.03.53.27;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	99.07.02.22.19.24;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	99.05.27.19.10.41;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	97.06.17.19.31.25;	author gdurf;	state Exp;
branches;
next	11.2;

11.2
date	96.10.21.19.11.33;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.56.56;	author mike;	state Rel4_4;
branches;
next	1.13;

1.13
date	94.11.08.03.00.59;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	94.09.22.12.19.00;	author jra;	state Exp;
branches;
next	1.11;

1.11
date	94.09.22.11.32.04;	author jra;	state Exp;
branches;
next	1.10;

1.10
date	94.09.13.15.52.51;	author jra;	state Exp;
branches;
next	1.9;

1.9
date	94.09.02.16.03.34;	author jra;	state Exp;
branches;
next	1.8;

1.8
date	94.08.10.18.38.53;	author gdurf;	state Exp;
branches;
next	1.7;

1.7
date	93.11.18.01.44.08;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	93.07.20.22.46.09;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	93.07.20.16.10.58;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	92.03.27.12.59.17;	author mmark;	state Exp;
branches;
next	1.3;

1.3
date	92.03.25.15.52.47;	author mmark;	state Exp;
branches;
next	1.2;

1.2
date	92.03.24.14.36.06;	author mmark;	state Exp;
branches;
next	1.1;

1.1
date	92.02.14.15.31.47;	author mmark;	state Exp;
branches;
next	;

11.25.2.1
date	2002.09.19.18.01.35;	author morrison;	state Exp;
branches;
next	11.25.2.2;

11.25.2.2
date	2004.03.17.21.18.47;	author morrison;	state Exp;
branches;
next	;

11.25.4.1
date	2004.03.11.23.43.38;	author morrison;	state Exp;
branches;
next	;

11.25.10.1
date	2004.02.12.18.37.41;	author erikg;	state Exp;
branches;
next	11.25.10.2;

11.25.10.2
date	2004.03.15.14.07.20;	author erikg;	state Exp;
branches;
next	;


desc
@right hyperbolic cylinder
@


11.29
log
@moved to src/
@
text
@/*
 *			G _ R H C . C
 *
 *  Purpose -
 *	Intersect a ray with a Right Hyperbolic Cylinder.
 *
 *  Algorithm -
 *  
 *  Given V, H, R, and B, there is a set of points on this rhc
 *  
 *  { (x,y,z) | (x,y,z) is on rhc }
 *  
 *  Through a series of Affine Transformations, this set of points will be
 *  transformed into a set of points on an rhc located at the origin
 *  with a rectangular halfwidth R of 1 along the Y axis, a height H of +1
 *  along the -X axis, a distance B of 1 along the -Z axis between the
 *  vertex V and the tip of the hyperbola, and a distance c between the
 *  tip of the hyperbola and the vertex of the asymptotic cone.
 *  
 *  
 *  { (x',y',z') | (x',y',z') is on rhc at origin }
 *
 *  The transformation from X to X' is accomplished by:
 *  
 *  X' = S(R( X - V ))
 *  
 *  where R(X) =  ( H/(-|H|) )
 *  		 (  R/( |R|)  ) . X
 *  		  ( B/(-|B|) )
 *  
 *  and S(X) =	 (  1/|H|   0     0   )
 *  		(    0    1/|R|   0    ) . X
 *  		 (   0      0   1/|B| )
 *  
 *  To find the intersection of a line with the surface of the rhc,
 *  consider the parametric line L:
 *  
 *  	L : { P(n) | P + t(n) . D }
 *  
 *  Call W the actual point of intersection between L and the rhc.
 *  Let W' be the point of intersection between L' and the unit rhc.
 *  
 *  	L' : { P'(n) | P' + t(n) . D' }
 *  
 *  W = invR( invS( W' ) ) + V
 *  
 *  Where W' = k D' + P'.
 *  
 *  If Dy' and Dz' are both 0, then there is no hit on the rhc;
 *  but the end plates need checking.  If there is now only 1 hit
 *  point, the top plate needs to be checked as well.
 *
 *  Line L' hits the infinitely long canonical rhc at W' when
 *
 *	A * k**2 + B * k + C = 0
 *
 *  where
 *
 *  A = Dz'**2 - Dy'**2 * (1 + 2*c')
 *  B = 2 * ((1 + c' + Pz') * Dz' - (1 + 2*c') * Dy' * Py'
 *  C = (Pz' + c' + 1)**2 - (1 + 2*c') * Py'**2 - c'**2
 *  b = |Breadth| = 1.0
 *  h = |Height| = 1.0
 *  r = 1.0
 *  c' = c / |Breadth|
 *  
 *  The quadratic formula yields k (which is constant):
 *
 *  k = [ -B +/- sqrt( B**2 - 4 * A * C )] / (2 * A)
 *  
 *  Now, D' = S( R( D ) )
 *  and  P' = S( R( P - V ) )
 *  
 *  Substituting,
 *  
 *  W = V + invR( invS[ k *( S( R( D ) ) ) + S( R( P - V ) ) ] )
 *    = V + invR( ( k * R( D ) ) + R( P - V ) )
 *    = V + k * D + P - V
 *    = k * D + P
 *  
 *  Note that ``k'' is constant, and is the same in the formulations
 *  for both W and W'.
 *
 *  The hit at ``k'' is a hit on the canonical rhc IFF
 *  -1 <= Wx' <= 0 and -1 <= Wz' <= 0.
 *
 *  NORMALS.  Given the point W on the surface of the rhc,
 *  what is the vector normal to the tangent plane at that point?
 *  
 *  Map W onto the unit rhc, ie:  W' = S( R( W - V ) ).
 *  
 *  Plane on unit rhc at W' has a normal vector N' where
 *
 *  N' = <0, Wy'*(1 + 2*c), -z-c-1>.
 *  
 *  The plane transforms back to the tangent plane at W, and this
 *  new plane (on the original rhc) has a normal vector of N, viz:
 *  
 *  N = inverse[ transpose( inverse[ S o R ] ) ] ( N' )
 *
 *  because if H is perpendicular to plane Q, and matrix M maps from
 *  Q to Q', then inverse[ transpose(M) ] (H) is perpendicular to Q'.
 *  Here, H and Q are in "prime space" with the unit sphere.
 *  [Somehow, the notation here is backwards].
 *  So, the mapping matrix M = inverse( S o R ), because
 *  S o R maps from normal space to the unit sphere.
 *
 *  N = inverse[ transpose( inverse[ S o R ] ) ] ( N' )
 *    = inverse[ transpose(invR o invS) ] ( N' )
 *    = inverse[ transpose(invS) o transpose(invR) ] ( N' )
 *    = inverse[ inverse(S) o R ] ( N' )
 *    = invR o S ( N' )
 *
 *  because inverse(R) = transpose(R), so R = transpose( invR ),
 *  and S = transpose( S ).
 *
 *  Note that the normal vector produced above will not have unit length.
 *
 *  THE TOP AND END PLATES.
 *
 *  If Dz' == 0, line L' is parallel to the top plate, so there is no
 *  hit on the top plate.  Otherwise, rays intersect the top plate
 *  with k = (0 - Pz')/Dz'.  The solution is within the top plate
 *  IFF  -1 <= Wx' <= 0 and -1 <= Wy' <= 1.
 *
 *  If Dx' == 0, line L' is parallel to the end plates, so there is no
 *  hit on the end plates.  Otherwise, rays intersect the front plate
 *  line L' hits the front plate with k = (0 - Px') / Dx', and
 *  and hits the back plate with k = (-1 - Px') / Dx'.
 *
 *  The solution W' is within an end plate IFF
 *
 *	(Wz' + c + 1)**2 - (Wy'**2 * (2*c + 1) >= c**2  and  Wz' <= 1.0
 *
 *  The normal for a hit on the top plate is -Bunit.
 *  The normal for a hit on the front plate is -Hunit, and
 *  the normal for a hit on the back plate is +Hunit.
 *
 *  Authors -
 *	Michael J. Markowski
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1990-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSrhc[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/g_rhc.c,v 11.28 2004/05/10 15:30:46 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef HAVE_STRING_H
#include <string.h>
#endif
#include <math.h>
#include "machine.h"
#include "vmath.h"
#include "db.h"
#include "nmg.h"
#include "raytrace.h"
#include "rtgeom.h"
#include "./debug.h"

struct rhc_specific {
	point_t	rhc_V;		/* vector to rhc origin */
	vect_t	rhc_Bunit;	/* unit B vector */
	vect_t	rhc_Hunit;	/* unit H vector */
	vect_t	rhc_Runit;	/* unit vector, B x H */
	mat_t	rhc_SoR;	/* Scale(Rot(vect)) */
	mat_t	rhc_invRoS;	/* invRot(Scale(vect)) */
	fastf_t	rhc_b;		/* |B| */
	fastf_t	rhc_c;		/* c */
	fastf_t	rhc_cprime;	/* c / |B| */
	fastf_t	rhc_rsq;	/* r * r */
};

const struct bu_structparse rt_rhc_parse[] = {
    { "%f", 3, "V", offsetof(struct rt_rhc_internal, rhc_V[X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 3, "H", offsetof(struct rt_rhc_internal, rhc_H[X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 3, "B", offsetof(struct rt_rhc_internal, rhc_B[X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 1, "r", offsetof(struct rt_rhc_internal, rhc_r),    BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 1, "c", offsetof(struct rt_rhc_internal, rhc_c),    BU_STRUCTPARSE_FUNC_NULL },
    { {'\0','\0','\0','\0'}, 0, (char *)NULL, 0, BU_STRUCTPARSE_FUNC_NULL }
 };

/*
 *  			R T _ R H C _ P R E P
 *  
 *  Given a pointer to a GED database record, and a transformation matrix,
 *  determine if this is a valid RHC, and if so, precompute various
 *  terms of the formula.
 *  
 *  Returns -
 *  	0	RHC is OK
 *  	!0	Error in description
 *  
 *  Implicit return -
 *  	A struct rhc_specific is created, and it's address is stored in
 *  	stp->st_specific for use by rhc_shot().
 */
int
rt_rhc_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
{
	struct rt_rhc_internal		*xip;
	register struct rhc_specific	*rhc;
	LOCAL fastf_t	magsq_b, magsq_h, magsq_r;
	LOCAL fastf_t	mag_b, mag_h, mag_r;
	LOCAL fastf_t	f;
	LOCAL mat_t	R;
	LOCAL mat_t	Rinv;
	LOCAL mat_t	S;
	LOCAL vect_t	invsq;	/* [ 1/(|H|**2), 1/(|R|**2), 1/(|B|**2) ] */

	RT_CK_DB_INTERNAL(ip);
	RT_CK_RTI(rtip);
	xip = (struct rt_rhc_internal *)ip->idb_ptr;
	RT_RHC_CK_MAGIC(xip);

	/* compute |B| |H| */
	mag_b = sqrt( magsq_b = MAGSQ( xip->rhc_B ) );
	mag_h = sqrt( magsq_h = MAGSQ( xip->rhc_H ) );
	mag_r = xip->rhc_r;
	magsq_r = mag_r * mag_r;

	/* Check for |H| > 0, |B| > 0, |R| > 0 */
	if( NEAR_ZERO(mag_h, RT_LEN_TOL) || NEAR_ZERO(mag_b, RT_LEN_TOL)
	 || NEAR_ZERO(mag_r, RT_LEN_TOL) )  {
		return(1);		/* BAD, too small */
	}

	/* Check for B.H == 0 */
	f = VDOT( xip->rhc_B, xip->rhc_H ) / (mag_b * mag_h);
	if( ! NEAR_ZERO(f, RT_DOT_TOL) )  {
		return(1);		/* BAD */
	}

	/*
	 *  RHC is ok
	 */
	stp->st_id = ID_RHC;		/* set soltab ID */
	stp->st_meth = &rt_functab[ID_RHC];

	BU_GETSTRUCT( rhc, rhc_specific );
	stp->st_specific = (genptr_t)rhc;
	rhc->rhc_b = mag_b;
	rhc->rhc_rsq = magsq_r;
	rhc->rhc_c = xip->rhc_c;

	/* make unit vectors in B, H, and BxH directions */
	VMOVE(    rhc->rhc_Hunit, xip->rhc_H );
	VUNITIZE( rhc->rhc_Hunit );
	VMOVE(    rhc->rhc_Bunit, xip->rhc_B );
	VUNITIZE( rhc->rhc_Bunit );
	VCROSS(   rhc->rhc_Runit, rhc->rhc_Bunit, rhc->rhc_Hunit );

	VMOVE( rhc->rhc_V, xip->rhc_V );
	rhc->rhc_cprime = xip->rhc_c / mag_b;

	/* Compute R and Rinv matrices */
	MAT_IDN( R );
	VREVERSE( &R[0], rhc->rhc_Hunit );
	VMOVE(    &R[4], rhc->rhc_Runit );
	VREVERSE( &R[8], rhc->rhc_Bunit );
	bn_mat_trn( Rinv, R );			/* inv of rot mat is trn */

	/* Compute S */
	VSET( invsq, 1.0/magsq_h, 1.0/magsq_r, 1.0/magsq_b );
	MAT_IDN( S );
	S[ 0] = sqrt( invsq[0] );
	S[ 5] = sqrt( invsq[1] );
	S[10] = sqrt( invsq[2] );

	/* Compute SoR and invRoS */
	bn_mat_mul( rhc->rhc_SoR, S, R );
	bn_mat_mul( rhc->rhc_invRoS, Rinv, S );

	/* Compute bounding sphere and RPP */
	/* bounding sphere center */
	VJOIN2( stp->st_center,	rhc->rhc_V,
		mag_h / 2.0,	rhc->rhc_Hunit,
		mag_b / 2.0,	rhc->rhc_Bunit );
	/* bounding radius */
	stp->st_bradius = 0.5 * sqrt(magsq_h + 4.0*magsq_r + magsq_b);
	/* approximate bounding radius */
	stp->st_aradius = stp->st_bradius;
	
	/* cheat, make bounding RPP by enclosing bounding sphere */
	stp->st_min[X] = stp->st_center[X] - stp->st_bradius;
	stp->st_max[X] = stp->st_center[X] + stp->st_bradius;
	stp->st_min[Y] = stp->st_center[Y] - stp->st_bradius;
	stp->st_max[Y] = stp->st_center[Y] + stp->st_bradius;
	stp->st_min[Z] = stp->st_center[Z] - stp->st_bradius;
	stp->st_max[Z] = stp->st_center[Z] + stp->st_bradius;

	return(0);			/* OK */
}

/*
 *			R T _ R H C _ P R I N T
 */
void
rt_rhc_print(register const struct soltab *stp)
{
	register const struct rhc_specific *rhc =
		(struct rhc_specific *)stp->st_specific;

	VPRINT("V", rhc->rhc_V);
	VPRINT("Bunit", rhc->rhc_Bunit);
	VPRINT("Hunit", rhc->rhc_Hunit);
	VPRINT("Runit", rhc->rhc_Runit);
	bn_mat_print("S o R", rhc->rhc_SoR );
	bn_mat_print("invR o S", rhc->rhc_invRoS );
}

/* hit_surfno is set to one of these */
#define	RHC_NORM_BODY	(1)		/* compute normal */
#define	RHC_NORM_TOP	(2)		/* copy rhc_N */
#define	RHC_NORM_FRT	(3)		/* copy reverse rhc_N */
#define RHC_NORM_BACK	(4)

/*
 *  			R T _ R H C _ S H O T
 *  
 *  Intersect a ray with a rhc.
 *  If an intersection occurs, a struct seg will be acquired
 *  and filled in.
 *  
 *  Returns -
 *  	0	MISS
 *	>0	HIT
 */
int
rt_rhc_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
{
	register struct rhc_specific *rhc =
		(struct rhc_specific *)stp->st_specific;
	LOCAL vect_t	dprime;		/* D' */
	LOCAL vect_t	pprime;		/* P' */
	LOCAL fastf_t	k1, k2;		/* distance constants of solution */
	LOCAL fastf_t	x;
	LOCAL vect_t	xlated;		/* translated vector */
	LOCAL struct hit hits[3];	/* 2 potential hit points */
	register struct hit *hitp;	/* pointer to hit point */

	hitp = &hits[0];

	/* out, Mat, vect */
	MAT4X3VEC( dprime, rhc->rhc_SoR, rp->r_dir );
	VSUB2( xlated, rp->r_pt, rhc->rhc_V );
	MAT4X3VEC( pprime, rhc->rhc_SoR, xlated );
	
	x = rhc->rhc_cprime;

	if ( NEAR_ZERO(dprime[Y], SMALL) && NEAR_ZERO(dprime[Z], SMALL) )
		goto check_plates;

	/* Find roots of the equation, using formula for quadratic */
	{
		FAST fastf_t	a, b, c;	/* coeffs of polynomial */
		FAST fastf_t	disc;		/* disc of radical */

		a = dprime[Z] * dprime[Z] - dprime[Y] * dprime[Y] * (1 + 2*x);
		b = 2*((pprime[Z] + x + 1) * dprime[Z]
			- (2*x + 1) * dprime[Y] * pprime[Y]);
		c = (pprime[Z]+x+1)*(pprime[Z]+x+1)
			- (2*x + 1) * pprime[Y] * pprime[Y] - x*x;
		if ( !NEAR_ZERO(a, RT_PCOEF_TOL) ) {
			disc = b*b - 4 * a * c;
			if (disc <= 0)
				goto check_plates;
			disc = sqrt(disc);

			k1 = (-b + disc) / (2.0 * a);
			k2 = (-b - disc) / (2.0 * a);

			/*
			 *  k1 and k2 are potential solutions to intersection with side.
			 *  See if they fall in range.
			 */
			VJOIN1( hitp->hit_vpriv, pprime, k1, dprime );		/* hit' */
			if( hitp->hit_vpriv[X] >= -1.0
				&& hitp->hit_vpriv[X] <= 0.0
				&& hitp->hit_vpriv[Z] >= -1.0
				&& hitp->hit_vpriv[Z] <= 0.0 ) {
				hitp->hit_magic = RT_HIT_MAGIC;
				hitp->hit_dist = k1;
				hitp->hit_surfno = RHC_NORM_BODY;	/* compute N */
				hitp++;
			}

			VJOIN1( hitp->hit_vpriv, pprime, k2, dprime );		/* hit' */
			if( hitp->hit_vpriv[X] >= -1.0
				&& hitp->hit_vpriv[X] <= 0.0
				&& hitp->hit_vpriv[Z] >= -1.0
				&& hitp->hit_vpriv[Z] <= 0.0 ) {
				hitp->hit_magic = RT_HIT_MAGIC;
				hitp->hit_dist = k2;
				hitp->hit_surfno = RHC_NORM_BODY;	/* compute N */
				hitp++;
			}
		} else if ( !NEAR_ZERO(b, RT_PCOEF_TOL) ) {
			k1 = -c/b;
			VJOIN1( hitp->hit_vpriv, pprime, k1, dprime );		/* hit' */
			if( hitp->hit_vpriv[X] >= -1.0
				&& hitp->hit_vpriv[X] <= 0.0
				&& hitp->hit_vpriv[Z] >= -1.0
				&& hitp->hit_vpriv[Z] <= 0.0 ) {
				hitp->hit_magic = RT_HIT_MAGIC;
				hitp->hit_dist = k1;
				hitp->hit_surfno = RHC_NORM_BODY;	/* compute N */
				hitp++;
			}
		}
	}


	/*
	 * Check for hitting the top and end plates.
	 */
check_plates:
	/* check front and back plates */
	if( hitp < &hits[2]  &&  !NEAR_ZERO(dprime[X], SMALL) )  {
		/* 0 or 1 hits so far, this is worthwhile */
		k1 = -pprime[X] / dprime[X];		/* front plate */
		k2 = (-1.0 - pprime[X]) / dprime[X];	/* back plate */

		VJOIN1( hitp->hit_vpriv, pprime, k1, dprime );	/* hit' */
		if( (hitp->hit_vpriv[Z] + x + 1.0)
			* (hitp->hit_vpriv[Z] + x + 1.0)
			- hitp->hit_vpriv[Y] * hitp->hit_vpriv[Y]
			* (1.0 + 2*x) >= x*x
			&& hitp->hit_vpriv[Z] >= -1.0
			&& hitp->hit_vpriv[Z] <= 0.0)  {
			hitp->hit_magic = RT_HIT_MAGIC;
			hitp->hit_dist = k1;
			hitp->hit_surfno = RHC_NORM_FRT;	/* -H */
			hitp++;
		}

		VJOIN1( hitp->hit_vpriv, pprime, k2, dprime );	/* hit' */
		if( (hitp->hit_vpriv[Z] + x + 1.0)
			* (hitp->hit_vpriv[Z] + x + 1.0)
			- hitp->hit_vpriv[Y] * hitp->hit_vpriv[Y]
			* (1.0 + 2*x) >= x*x
			&& hitp->hit_vpriv[Z] >= -1.0
			&& hitp->hit_vpriv[Z] <= 0.0)  {
			hitp->hit_magic = RT_HIT_MAGIC;
			hitp->hit_dist = k2;
			hitp->hit_surfno = RHC_NORM_BACK;	/* +H */
			hitp++;
		}
	}
	
	/* check top plate */
	if( hitp == &hits[1]  &&  !NEAR_ZERO(dprime[Z], SMALL) )  {
		/* 0 or 1 hits so far, this is worthwhile */
		k1 = -pprime[Z] / dprime[Z];		/* top plate */

		VJOIN1( hitp->hit_vpriv, pprime, k1, dprime );	/* hit' */
		if( hitp->hit_vpriv[X] >= -1.0 &&  hitp->hit_vpriv[X] <= 0.0
			&& hitp->hit_vpriv[Y] >= -1.0
			&& hitp->hit_vpriv[Y] <= 1.0 ) {
			hitp->hit_magic = RT_HIT_MAGIC;
			hitp->hit_dist = k1;
			hitp->hit_surfno = RHC_NORM_TOP;	/* -B */
			hitp++;
		}
	}
	
	if( hitp != &hits[2] )
		return(0);	/* MISS */

	if( hits[0].hit_dist < hits[1].hit_dist )  {
		/* entry is [0], exit is [1] */
		register struct seg *segp;

		RT_GET_SEG(segp, ap->a_resource);
		segp->seg_stp = stp;
		segp->seg_in = hits[0];		/* struct copy */
		segp->seg_out = hits[1];	/* struct copy */
		BU_LIST_INSERT( &(seghead->l), &(segp->l) );
	} else {
		/* entry is [1], exit is [0] */
		register struct seg *segp;

		RT_GET_SEG(segp, ap->a_resource);
		segp->seg_stp = stp;
		segp->seg_in = hits[1];		/* struct copy */
		segp->seg_out = hits[0];	/* struct copy */
		BU_LIST_INSERT( &(seghead->l), &(segp->l) );
	}
	return(2);			/* HIT */
}

#define RT_RHC_SEG_MISS(SEG)	(SEG).seg_stp=RT_SOLTAB_NULL

/*
 *			R T _ R H C _ V S H O T
 *
 *  Vectorized version.
 */
void
rt_rhc_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		  	       /* Number of ray/object pairs */
                  	    
{
	rt_vstub( stp, rp, segp, n, ap );
}

/*
 *  			R T _ R H C _ N O R M
 *  
 *  Given ONE ray distance, return the normal and entry/exit point.
 */
void
rt_rhc_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
{
	fastf_t	c;
	vect_t	can_normal;	/* normal to canonical rhc */
	register struct rhc_specific *rhc =
		(struct rhc_specific *)stp->st_specific;

	VJOIN1( hitp->hit_point, rp->r_pt, hitp->hit_dist, rp->r_dir );
	switch( hitp->hit_surfno )  {
	case RHC_NORM_BODY:
		c = rhc->rhc_cprime;
		VSET( can_normal,
			0.0,
			hitp->hit_vpriv[Y] * (1.0 + 2.0*c),
			-hitp->hit_vpriv[Z] - c - 1.0 );
		MAT4X3VEC( hitp->hit_normal, rhc->rhc_invRoS, can_normal );
		VUNITIZE( hitp->hit_normal );
		break;
	case RHC_NORM_TOP:
		VREVERSE( hitp->hit_normal, rhc->rhc_Bunit );
		break;
	case RHC_NORM_FRT:
		VREVERSE( hitp->hit_normal, rhc->rhc_Hunit );
		break;
	case RHC_NORM_BACK:
		VMOVE( hitp->hit_normal, rhc->rhc_Hunit );
		break;
	default:
		bu_log("rt_rhc_norm: surfno=%d bad\n", hitp->hit_surfno);
		break;
	}
}

/*
 *			R T _ R H C _ C U R V E
 *
 *  Return the curvature of the rhc.
 */
void
rt_rhc_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
{
	fastf_t	b, c, rsq, y;
	fastf_t	zp1_sq, zp2;	/* 1st deriv sqr, 2nd deriv */
	register struct rhc_specific *rhc =
		(struct rhc_specific *)stp->st_specific;

	switch( hitp->hit_surfno )  {
	case RHC_NORM_BODY:
		/* most nearly flat direction */
		VMOVE( cvp->crv_pdir, rhc->rhc_Hunit );
		cvp->crv_c1 = 0;
		/* k = z'' / (1 + z'^2) ^ 3/2 */
		b = rhc->rhc_b;
		c = rhc->rhc_c;
		y = hitp->hit_point[Y];
		rsq = rhc->rhc_rsq;
		zp1_sq = y * (b*b + 2*b*c) / rsq;
		zp1_sq *= zp1_sq / (c*c + y*y*(b*b + 2*b*c)/rsq);
		zp2 = c*c / (rsq*c*c + y*y*(b*b + 2*b*c));
		cvp->crv_c2 = zp2 / pow( (1 + zp1_sq), 1.5);
		break;
	case RHC_NORM_BACK:
	case RHC_NORM_FRT:
	case RHC_NORM_TOP:
		/* any tangent direction */
	 	bn_vec_ortho( cvp->crv_pdir, hitp->hit_normal );
	 	cvp->crv_c1 = cvp->crv_c2 = 0;
		break;
	}
}

/*
 *  			R T _ R H C _ U V
 *  
 *  For a hit on the surface of an rhc, return the (u,v) coordinates
 *  of the hit point, 0 <= u,v <= 1.
 *  u = azimuth
 *  v = elevation
 */
void
rt_rhc_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
{
	register struct rhc_specific *rhc =
		(struct rhc_specific *)stp->st_specific;
	LOCAL vect_t work;
	LOCAL vect_t pprime;
	FAST fastf_t len;

	/*
	 * hit_point is on surface;  project back to unit rhc,
	 * creating a vector from vertex to hit point.
	 */
	VSUB2( work, hitp->hit_point, rhc->rhc_V );
	MAT4X3VEC( pprime, rhc->rhc_SoR, work );

	switch( hitp->hit_surfno )  {
	case RHC_NORM_BODY:
		/* Skin.  x,y coordinates define rotation.  radius = 1 */
		len = sqrt(pprime[Y]*pprime[Y] + pprime[Z]*pprime[Z]);
		uvp->uv_u = acos(pprime[Y]/len) * bn_invpi;
		uvp->uv_v = -pprime[X];		/* height */
		break;
	case RHC_NORM_FRT:
	case RHC_NORM_BACK:
		/* end plates - circular mapping, not seamless w/body, top */
		len = sqrt(pprime[Y]*pprime[Y] + pprime[Z]*pprime[Z]);
		uvp->uv_u = acos(pprime[Y]/len) * bn_invpi;
		uvp->uv_v = len;	/* rim v = 1 for both plates */
		break;
	case RHC_NORM_TOP:
		uvp->uv_u = 1.0 - (pprime[Y] + 1.0)/2.0;
		uvp->uv_v = -pprime[X];		/* height */
		break;
	}

	/* uv_du should be relative to rotation, uv_dv relative to height */
	uvp->uv_du = uvp->uv_dv = 0;
}

/*
 *		R T _ R H C _ F R E E
 */
void
rt_rhc_free(register struct soltab *stp)
{
	register struct rhc_specific *rhc =
		(struct rhc_specific *)stp->st_specific;

	bu_free( (char *)rhc, "rhc_specific" );
}

/*
 *			R T _ R H C _ C L A S S
 */
int
rt_rhc_class(void)
{
	return(0);
}


/*
 *			R T _ R H C _ P L O T
 */
int
rt_rhc_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
	int		i, n;
	fastf_t		b, c, *back, f, *front, h, rh;
	fastf_t		dtol, ntol;
	vect_t		Bu, Hu, Ru;
	LOCAL mat_t	R;
	LOCAL mat_t	invR;
	LOCAL struct rt_rhc_internal	*xip;
	struct rt_pt_node	*old, *pos, *pts, *rt_ptalloc(void);

	RT_CK_DB_INTERNAL(ip);
	xip = (struct rt_rhc_internal *)ip->idb_ptr;
	RT_RHC_CK_MAGIC(xip);

	/* compute |B| |H| */
	b = MAGNITUDE( xip->rhc_B );	/* breadth */
	rh = xip->rhc_r;		/* rectangular halfwidth */
	h = MAGNITUDE( xip->rhc_H );	/* height */
	c = xip->rhc_c;			/* dist to asympt origin */

	/* Check for |H| > 0, |B| > 0, rh > 0, c > 0 */
	if( NEAR_ZERO(h, RT_LEN_TOL) || NEAR_ZERO(b, RT_LEN_TOL)
	 || NEAR_ZERO(rh, RT_LEN_TOL) || NEAR_ZERO(c, RT_LEN_TOL))  {
		bu_log("rt_rhc_plot:  zero length H, B, c, or rh\n");
		return(-2);		/* BAD */
	}

	/* Check for B.H == 0 */
	f = VDOT( xip->rhc_B, xip->rhc_H ) / (b * h);
	if( ! NEAR_ZERO(f, RT_DOT_TOL) )  {
		bu_log("rt_rhc_plot: B not perpendicular to H, f=%f\n", f);
		return(-3);		/* BAD */
	}

	/* make unit vectors in B, H, and BxH directions */
	VMOVE(    Hu, xip->rhc_H );
	VUNITIZE( Hu );
	VMOVE(    Bu, xip->rhc_B );
	VUNITIZE( Bu );
	VCROSS(   Ru, Bu, Hu );

	/* Compute R and Rinv matrices */
	MAT_IDN( R );
	VREVERSE( &R[0], Hu );
	VMOVE(    &R[4], Ru );
	VREVERSE( &R[8], Bu );
	bn_mat_trn( invR, R );			/* inv of rot mat is trn */

	/*
	 *  Establish tolerances
	 */
	if( ttol->rel <= 0.0 || ttol->rel >= 1.0 )  {
		dtol = 0.0;		/* none */
	} else {
		/* Convert rel to absolute by scaling by smallest side */
		if (rh < b)
			dtol = ttol->rel * 2 * rh;
		else
			dtol = ttol->rel * 2 * b;
	}
	if( ttol->abs <= 0.0 )  {
		if( dtol <= 0.0 )  {
			/* No tolerance given, use a default */
			if (rh < b)
				dtol = 2 * 0.10 * rh;	/* 10% */
			else
				dtol = 2 * 0.10 * b;	/* 10% */
		} else {
			/* Use absolute-ized relative tolerance */
		}
	} else {
		/* Absolute tolerance was given, pick smaller */
		if( ttol->rel <= 0.0 || dtol > ttol->abs )
			dtol = ttol->abs;
	}

	/* To ensure normal tolerance, remain below this angle */
	if( ttol->norm > 0.0 )
		ntol = ttol->norm;
	else
		/* tolerate everything */
		ntol = bn_pi;

	/* initial hyperbola approximation is a single segment */
	pts = rt_ptalloc();
	pts->next = rt_ptalloc();
	pts->next->next = NULL;
	VSET( pts->p,       0, -rh, 0);
	VSET( pts->next->p, 0,  rh, 0);
	/* 2 endpoints in 1st approximation */
	n = 2;
	/* recursively break segment 'til within error tolerances */
	n += rt_mk_hyperbola( pts, rh, b, c, dtol, ntol );

	/* get mem for arrays */
	front = (fastf_t *)bu_malloc(3*n * sizeof(fastf_t), "fast_t");
	back  = (fastf_t *)bu_malloc(3*n * sizeof(fastf_t), "fast_t");
	
	/* generate front & back plates in world coordinates */
	pos = pts;
	i = 0;
	while (pos) {
		/* rotate back to original position */
		MAT4X3VEC( &front[i], invR, pos->p );
		/* move to origin vertex origin */
		VADD2( &front[i], &front[i], xip->rhc_V );
		/* extrude front to create back plate */
		VADD2( &back[i], &front[i], xip->rhc_H );
		i += 3;
		old = pos;
		pos = pos->next;
		bu_free ( (char *)old, "rt_pt_node" );
	}

	/* Draw the front */
	RT_ADD_VLIST( vhead, &front[(n-1)*ELEMENTS_PER_VECT],
		BN_VLIST_LINE_MOVE );
	for( i = 0; i < n; i++ )  {
		RT_ADD_VLIST( vhead, &front[i*ELEMENTS_PER_VECT], BN_VLIST_LINE_DRAW );
	}

	/* Draw the back */
	RT_ADD_VLIST( vhead, &back[(n-1)*ELEMENTS_PER_VECT], BN_VLIST_LINE_MOVE );
	for( i = 0; i < n; i++ )  {
		RT_ADD_VLIST( vhead, &back[i*ELEMENTS_PER_VECT], BN_VLIST_LINE_DRAW );
	}

	/* Draw connections */
	for( i = 0; i < n; i++ )  {
		RT_ADD_VLIST( vhead, &front[i*ELEMENTS_PER_VECT], BN_VLIST_LINE_MOVE );
		RT_ADD_VLIST( vhead, &back[i*ELEMENTS_PER_VECT], BN_VLIST_LINE_DRAW );
	}

	/* free mem */
	bu_free( (char *)front, "fastf_t");
	bu_free( (char *)back, "fastf_t");

	return(0);
}

/*
 *	R T _ M K _ H Y P E R B O L A
 *
 *
 */
int
rt_mk_hyperbola(struct rt_pt_node *pts, fastf_t r, fastf_t b, fastf_t c, fastf_t dtol, fastf_t ntol)
{
	fastf_t	A, B, C, discr, dist, intr, j, k, m, theta0, theta1, z0;
	int	n;
	point_t	mpt, p0, p1;
	vect_t	norm_line, norm_hyperb;
	struct rt_pt_node *new, *rt_ptalloc(void);
	
#define RHC_TOL .0001
	/* endpoints of segment approximating hyperbola */
	VMOVE( p0, pts->p );
	VMOVE( p1, pts->next->p );
	/* slope and intercept of segment */
	m = ( p1[Z] - p0[Z] ) / ( p1[Y] - p0[Y] );
	intr = p0[Z] - m * p0[Y];
	/* find point on hyperbola with max dist between hyperbola and line */
	j = b + c;
	k = 1 - m*m*r*r/(b*(b + 2*c));
	A = k;
	B = 2*j*k;
	C = j*j*k - c*c;
	discr = sqrt(B*B - 4*A*C);
	z0 = (-B + discr) / (2. * A);
	if ( z0+RHC_TOL >= -b )	/* use top sheet of hyperboloid */
		mpt[Z] = z0;
	else
		mpt[Z] = (-B - discr) / (2. * A);
	if (NEAR_ZERO( mpt[Z], RHC_TOL))
		mpt[Z] = 0.;
	mpt[X] = 0;
	mpt[Y] = ((mpt[Z] + b + c) * (mpt[Z] + b + c) - c*c) / (b*(b + 2*c));
	if (NEAR_ZERO( mpt[Y], RHC_TOL ))
		mpt[Y] = 0.;
	mpt[Y] = r * sqrt( mpt[Y] );
	if (p0[Y] < 0.)
		mpt[Y] = -mpt[Y];
	/* max distance between that point and line */
	dist = fabs( m * mpt[Y] - mpt[Z] + intr ) / sqrt( m * m + 1 );
	/* angles between normal of line and of hyperbola at line endpoints */
	VSET( norm_line, m, -1., 0.);
	VSET( norm_hyperb, 0., (2*c + 1) / (p0[Z] + c + 1), -1.);
	VUNITIZE( norm_line );
	VUNITIZE( norm_hyperb );
	theta0 = fabs( acos( VDOT( norm_line, norm_hyperb )));
	VSET( norm_hyperb, 0., (2*c + 1) / (p1[Z] + c + 1), -1.);
	VUNITIZE( norm_hyperb );
	theta1 = fabs( acos( VDOT( norm_line, norm_hyperb )));
	/* split segment at widest point if not within error tolerances */
	if ( dist > dtol || theta0 > ntol || theta1 > ntol ) {
		/* split segment */
		new = rt_ptalloc();
		VMOVE( new->p, mpt );
		new->next = pts->next;
		pts->next = new;
		/* keep track of number of pts added */
		n = 1;
		/* recurse on first new segment */
		n += rt_mk_hyperbola( pts, r, b, c, dtol, ntol );
		/* recurse on second new segment */
		n += rt_mk_hyperbola( new, r, b, c, dtol, ntol );
	} else
		n  = 0;
	return( n );
}

/*
 *			R T _ R H C _ T E S S
 *
 *  Returns -
 *	-1	failure
 *	 0	OK.  *r points to nmgregion that holds this tessellation.
 */
int
rt_rhc_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
	int		i, j, n;
	fastf_t		b, c, *back, f, *front, h, rh;
	fastf_t		dtol, ntol;
	vect_t		Bu, Hu, Ru;
	LOCAL mat_t	R;
	LOCAL mat_t	invR;
	LOCAL struct rt_rhc_internal	*xip;
	struct rt_pt_node	*old, *pos, *pts, *rt_ptalloc(void);
	struct shell	*s;
	struct faceuse	**outfaceuses;
	struct vertex	**vfront, **vback, **vtemp, *vertlist[4];
	vect_t		*norms;
	fastf_t		bb_plus_2bc,b_plus_c,r_sq;
	int		failure=0;

	NMG_CK_MODEL( m );
	BN_CK_TOL( tol );
	RT_CK_TESS_TOL( ttol );

	RT_CK_DB_INTERNAL(ip);
	xip = (struct rt_rhc_internal *)ip->idb_ptr;
	RT_RHC_CK_MAGIC(xip);

	/* compute |B| |H| */
	b = MAGNITUDE( xip->rhc_B );	/* breadth */
	rh = xip->rhc_r;		/* rectangular halfwidth */
	h = MAGNITUDE( xip->rhc_H );	/* height */
	c = xip->rhc_c;			/* dist to asympt origin */

	/* Check for |H| > 0, |B| > 0, rh > 0, c > 0 */
	if( NEAR_ZERO(h, RT_LEN_TOL) || NEAR_ZERO(b, RT_LEN_TOL)
	 || NEAR_ZERO(rh, RT_LEN_TOL) || NEAR_ZERO(c, RT_LEN_TOL))  {
		bu_log("rt_rhc_tess:  zero length H, B, c, or rh\n");
		return(-2);		/* BAD */
	}

	/* Check for B.H == 0 */
	f = VDOT( xip->rhc_B, xip->rhc_H ) / (b * h);
	if( ! NEAR_ZERO(f, RT_DOT_TOL) )  {
		bu_log("rt_rhc_tess: B not perpendicular to H, f=%f\n", f);
		return(-3);		/* BAD */
	}

	/* make unit vectors in B, H, and BxH directions */
	VMOVE(    Hu, xip->rhc_H );
	VUNITIZE( Hu );
	VMOVE(    Bu, xip->rhc_B );
	VUNITIZE( Bu );
	VCROSS(   Ru, Bu, Hu );

	/* Compute R and Rinv matrices */
	MAT_IDN( R );
	VREVERSE( &R[0], Hu );
	VMOVE(    &R[4], Ru );
	VREVERSE( &R[8], Bu );
	bn_mat_trn( invR, R );			/* inv of rot mat is trn */

	/*
	 *  Establish tolerances
	 */
	if( ttol->rel <= 0.0 || ttol->rel >= 1.0 )  {
		dtol = 0.0;		/* none */
	} else {
		/* Convert rel to absolute by scaling by smallest side */
		if (rh < b)
			dtol = ttol->rel * 2 * rh;
		else
			dtol = ttol->rel * 2 * b;
	}
	if( ttol->abs <= 0.0 )  {
		if( dtol <= 0.0 )  {
			/* No tolerance given, use a default */
			if (rh < b)
				dtol = 2 * 0.10 * rh;	/* 10% */
			else
				dtol = 2 * 0.10 * b;	/* 10% */
		} else {
			/* Use absolute-ized relative tolerance */
		}
	} else {
		/* Absolute tolerance was given, pick smaller */
		if( ttol->rel <= 0.0 || dtol > ttol->abs )
			dtol = ttol->abs;
	}

	/* To ensure normal tolerance, remain below this angle */
	if( ttol->norm > 0.0 )
		ntol = ttol->norm;
	else
		/* tolerate everything */
		ntol = bn_pi;

	/* initial hyperbola approximation is a single segment */
	pts = rt_ptalloc();
	pts->next = rt_ptalloc();
	pts->next->next = NULL;
	VSET( pts->p,       0, -rh, 0);
	VSET( pts->next->p, 0,  rh, 0);
	/* 2 endpoints in 1st approximation */
	n = 2;
	/* recursively break segment 'til within error tolerances */
	n += rt_mk_hyperbola( pts, rh, b, c, dtol, ntol );

	/* get mem for arrays */
	front = (fastf_t *)bu_malloc(3*n * sizeof(fastf_t), "fastf_t");
	back  = (fastf_t *)bu_malloc(3*n * sizeof(fastf_t), "fastf_t");
	norms = (vect_t *)bu_calloc( n , sizeof( vect_t ) , "rt_rhc_tess: norms" );
	vfront = (struct vertex **)bu_malloc((n+1) * sizeof(struct vertex *), "vertex *");
	vback = (struct vertex **)bu_malloc((n+1) * sizeof(struct vertex *), "vertex *");
	vtemp = (struct vertex **)bu_malloc((n+1) * sizeof(struct vertex *), "vertex *");
	outfaceuses =
		(struct faceuse **)bu_malloc((n+2) * sizeof(struct faceuse *), "faceuse *");
	if (!front || !back || !vfront || !vback || !vtemp || !outfaceuses) {
		fprintf(stderr, "rt_rhc_tess: no memory!\n");
		goto fail;
	}
	
	/* generate front & back plates in world coordinates */
	bb_plus_2bc = b*b + 2.0*b*c;
	b_plus_c = b + c;
	r_sq = rh*rh;
	pos = pts;
	i = 0;
	j = 0;
	while (pos) {
		vect_t tmp_norm;

		/* calculate normal for 2D hyperbola */
		VSET( tmp_norm , 0.0 , pos->p[Y]*bb_plus_2bc , (-r_sq*(pos->p[Z]+b_plus_c)) );
		MAT4X3VEC( norms[j] , invR , tmp_norm );
		VUNITIZE( norms[j] );
		/* rotate back to original position */
		MAT4X3VEC( &front[i], invR, pos->p );
		/* move to origin vertex origin */
		VADD2( &front[i], &front[i], xip->rhc_V );
		/* extrude front to create back plate */
		VADD2( &back[i], &front[i], xip->rhc_H );
		i += 3;
		j++;
		old = pos;
		pos = pos->next;
		bu_free ( (char *)old, "rt_pt_node" );
	}

	*r = nmg_mrsv( m );	/* Make region, empty shell, vertex */
	s = BU_LIST_FIRST(shell, &(*r)->s_hd);

	for( i=0; i<n; i++ )  {
		vfront[i] = vtemp[i] = (struct vertex *)0;
	}

	/* Front face topology.  Verts are considered to go CCW */
	outfaceuses[0] = nmg_cface(s, vfront, n);

	(void)nmg_mark_edges_real( &outfaceuses[0]->l.magic );

	/* Back face topology.  Verts must go in opposite dir (CW) */
	outfaceuses[1] = nmg_cface(s, vtemp, n);
	for( i=0; i<n; i++ )  vback[i] = vtemp[n-1-i];

	(void)nmg_mark_edges_real( &outfaceuses[1]->l.magic );

	/* Duplicate [0] as [n] to handle loop end condition, below */
	vfront[n] = vfront[0];
	vback[n] = vback[0];

	/* Build topology for all the rectangular side faces (n of them)
	 * connecting the front and back faces.
	 * increasing indices go towards counter-clockwise (CCW).
	 */
	for( i=0; i<n; i++ )  {
		vertlist[0] = vfront[i];	/* from top, */
		vertlist[1] = vback[i];		/* straight down, */
		vertlist[2] = vback[i+1];	/* to left, */
		vertlist[3] = vfront[i+1];	/* straight up. */
		outfaceuses[2+i] = nmg_cface(s, vertlist, 4);
	}

	(void)nmg_mark_edges_real( &outfaceuses[n+1]->l.magic );

	for( i=0; i<n; i++ )  {
		NMG_CK_VERTEX(vfront[i]);
		NMG_CK_VERTEX(vback[i]);
	}

	/* Associate the vertex geometry, CCW */
	for( i=0; i<n; i++ )  {
		nmg_vertex_gv( vfront[i], &front[3*(i)] );
	}
	for( i=0; i<n; i++ )  {
		nmg_vertex_gv( vback[i], &back[3*(i)] );
	}

	/* Associate the face geometry */
	for (i=0 ; i < n+2 ; i++) {
		if( nmg_fu_planeeqn( outfaceuses[i], tol ) < 0 )
		{
			failure = (-1);
			goto fail;
		}
	}

	/* Associate vertexuse normals */
	for( i=0 ; i<n ; i++ )
	{
		struct vertexuse *vu;
		struct faceuse *fu;
		vect_t rev_norm;

		VREVERSE( rev_norm , norms[i] );

		/* do "front" vertices */
		NMG_CK_VERTEX( vfront[i] );
		for( BU_LIST_FOR( vu , vertexuse , &vfront[i]->vu_hd ) )
		{
			NMG_CK_VERTEXUSE( vu );
			fu = nmg_find_fu_of_vu( vu );
			NMG_CK_FACEUSE( fu );
			if( fu->f_p == outfaceuses[0]->f_p ||
			    fu->f_p == outfaceuses[1]->f_p ||
			    fu->f_p == outfaceuses[n+1]->f_p )
					continue;	/* skip flat faces */

			if( fu->orientation == OT_SAME )
				nmg_vertexuse_nv( vu , norms[i] );
			else if( fu->orientation == OT_OPPOSITE )
				nmg_vertexuse_nv( vu , rev_norm );
		}

		/* and "back" vertices */
		NMG_CK_VERTEX( vback[i] );
		for( BU_LIST_FOR( vu , vertexuse , &vback[i]->vu_hd ) )
		{
			NMG_CK_VERTEXUSE( vu );
			fu = nmg_find_fu_of_vu( vu );
			NMG_CK_FACEUSE( fu );
			if( fu->f_p == outfaceuses[0]->f_p ||
			    fu->f_p == outfaceuses[1]->f_p ||
			    fu->f_p == outfaceuses[n+1]->f_p )
					continue;	/* skip flat faces */

			if( fu->orientation == OT_SAME )
				nmg_vertexuse_nv( vu , norms[i] );
			else if( fu->orientation == OT_OPPOSITE )
				nmg_vertexuse_nv( vu , rev_norm );
		}
	}

	/* Glue the edges of different outward pointing face uses together */
	nmg_gluefaces( outfaceuses, n+2, tol );

	/* Compute "geometry" for region and shell */
	nmg_region_a( *r, tol );

fail:
	/* free mem */
	bu_free( (char *)front, "fastf_t");
	bu_free( (char *)back, "fastf_t");
	bu_free( (char*)vfront, "vertex *");
	bu_free( (char*)vback, "vertex *");
	bu_free( (char*)vtemp, "vertex *");
	bu_free( (char *)norms , "rt_rhc_tess: norms" );
	bu_free( (char*)outfaceuses, "faceuse *");

	return( failure );
}

/*
 *			R T _ R H C _ I M P O R T
 *
 *  Import an RHC from the database format to the internal format.
 *  Apply modeling transformations as well.
 */
int
rt_rhc_import(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
{
	LOCAL struct rt_rhc_internal	*xip;
	union record			*rp;

	BU_CK_EXTERNAL( ep );
	rp = (union record *)ep->ext_buf;
	/* Check record type */
	if( rp->u_id != ID_SOLID )  {
		bu_log("rt_rhc_import: defective record\n");
		return(-1);
	}

	RT_CK_DB_INTERNAL( ip );
	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_RHC;
	ip->idb_meth = &rt_functab[ID_RHC];
	ip->idb_ptr = bu_malloc( sizeof(struct rt_rhc_internal), "rt_rhc_internal");
	xip = (struct rt_rhc_internal *)ip->idb_ptr;
	xip->rhc_magic = RT_RHC_INTERNAL_MAGIC;

	/* Warning:  type conversion */
	MAT4X3PNT( xip->rhc_V, mat, &rp->s.s_values[0*3] );
	MAT4X3VEC( xip->rhc_H, mat, &rp->s.s_values[1*3] );
	MAT4X3VEC( xip->rhc_B, mat, &rp->s.s_values[2*3] );
	xip->rhc_r = rp->s.s_values[3*3] / mat[15];
	xip->rhc_c = rp->s.s_values[3*3+1] / mat[15];

	if( xip->rhc_r < SMALL_FASTF || xip->rhc_c < SMALL_FASTF )
	{
		bu_log( "rt_rhc_import: r or c are zero\n" );
		bu_free( (char *)ip->idb_ptr , "rt_rhc_import: ip->idb_ptr" );
		return( -1 );
	}

	return(0);			/* OK */
}

/*
 *			R T _ R H C _ E X P O R T
 *
 *  The name is added by the caller, in the usual place.
 */
int
rt_rhc_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
{
	struct rt_rhc_internal	*xip;
	union record		*rhc;

	RT_CK_DB_INTERNAL(ip);
	if( ip->idb_type != ID_RHC )  return(-1);
	xip = (struct rt_rhc_internal *)ip->idb_ptr;
	RT_RHC_CK_MAGIC(xip);

	BU_CK_EXTERNAL(ep);
	ep->ext_nbytes = sizeof(union record);
	ep->ext_buf = (genptr_t)bu_calloc( 1, ep->ext_nbytes, "rhc external");
	rhc = (union record *)ep->ext_buf;

	rhc->s.s_id = ID_SOLID;
	rhc->s.s_type = RHC;

	if (MAGNITUDE(xip->rhc_B) < RT_LEN_TOL
		|| MAGNITUDE(xip->rhc_H) < RT_LEN_TOL
		|| xip->rhc_r < RT_LEN_TOL
		|| xip->rhc_c < RT_LEN_TOL) {
		bu_log("rt_rhc_export: not all dimensions positive!\n");
		return(-1);
	}

	{
		vect_t ub, uh;

		VMOVE(ub, xip->rhc_B);
		VUNITIZE(ub);
		VMOVE(uh, xip->rhc_H);
		VUNITIZE(uh);
		if ( !NEAR_ZERO( VDOT(ub, uh), RT_DOT_TOL) ) {
			bu_log("rt_rhc_export: B and H are not perpendicular!\n");
			return(-1);
		}
	}

	/* Warning:  type conversion */
	VSCALE( &rhc->s.s_values[0*3], xip->rhc_V, local2mm );
	VSCALE( &rhc->s.s_values[1*3], xip->rhc_H, local2mm );
	VSCALE( &rhc->s.s_values[2*3], xip->rhc_B, local2mm );
	rhc->s.s_values[3*3] = xip->rhc_r * local2mm;
	rhc->s.s_values[3*3+1] = xip->rhc_c * local2mm;

	return(0);
}

/*
 *			R T _ R H C _ I M P O R T 5
 *
 *  Import an RHC from the database format to the internal format.
 *  Apply modeling transformations as well.
 */
int
rt_rhc_import5(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
{
	LOCAL struct rt_rhc_internal	*xip;
	fastf_t			vec[11];

	BU_CK_EXTERNAL( ep );

	BU_ASSERT_LONG( ep->ext_nbytes, ==, SIZEOF_NETWORK_DOUBLE * 11 );

	RT_CK_DB_INTERNAL( ip );
	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_RHC;
	ip->idb_meth = &rt_functab[ID_RHC];
	ip->idb_ptr = bu_malloc( sizeof(struct rt_rhc_internal), "rt_rhc_internal");

	xip = (struct rt_rhc_internal *)ip->idb_ptr;
	xip->rhc_magic = RT_RHC_INTERNAL_MAGIC;

	/* Convert from database (network) to internal (host) format */
	ntohd( (unsigned char *)vec, ep->ext_buf, 11 );

	/* Apply modeling transformations */
	MAT4X3PNT( xip->rhc_V, mat, &vec[0*3] );
	MAT4X3VEC( xip->rhc_H, mat, &vec[1*3] );
	MAT4X3VEC( xip->rhc_B, mat, &vec[2*3] );
	xip->rhc_r = vec[3*3] / mat[15];
	xip->rhc_c = vec[3*3+1] / mat[15];

	if( xip->rhc_r < SMALL_FASTF || xip->rhc_c < SMALL_FASTF )
	{
		bu_log( "rt_rhc_import: r or c are zero\n" );
		bu_free( (char *)ip->idb_ptr , "rt_rhc_import: ip->idb_ptr" );
		return( -1 );
	}

	return(0);			/* OK */
}

/*
 *			R T _ R H C _ E X P O R T 5
 *
 *  The name is added by the caller, in the usual place.
 */
int
rt_rhc_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
{
	struct rt_rhc_internal	*xip;
	fastf_t			vec[11];

	RT_CK_DB_INTERNAL(ip);
	if( ip->idb_type != ID_RHC )  return(-1);
	xip = (struct rt_rhc_internal *)ip->idb_ptr;
	RT_RHC_CK_MAGIC(xip);

	BU_CK_EXTERNAL(ep);
	ep->ext_nbytes = SIZEOF_NETWORK_DOUBLE * 11;
	ep->ext_buf = (genptr_t)bu_malloc( ep->ext_nbytes, "rhc external");

	if (MAGNITUDE(xip->rhc_B) < RT_LEN_TOL
		|| MAGNITUDE(xip->rhc_H) < RT_LEN_TOL
		|| xip->rhc_r < RT_LEN_TOL
		|| xip->rhc_c < RT_LEN_TOL) {
		bu_log("rt_rhc_export: not all dimensions positive!\n");
		return(-1);
	}

	{
		vect_t ub, uh;

		VMOVE(ub, xip->rhc_B);
		VUNITIZE(ub);
		VMOVE(uh, xip->rhc_H);
		VUNITIZE(uh);
		if ( !NEAR_ZERO( VDOT(ub, uh), RT_DOT_TOL) ) {
			bu_log("rt_rhc_export: B and H are not perpendicular!\n");
			return(-1);
		}
	}

	/* scale 'em into local buffer */
	VSCALE( &vec[0*3], xip->rhc_V, local2mm );
	VSCALE( &vec[1*3], xip->rhc_H, local2mm );
	VSCALE( &vec[2*3], xip->rhc_B, local2mm );
	vec[3*3] = xip->rhc_r * local2mm;
	vec[3*3+1] = xip->rhc_c * local2mm;

	/* Convert from internal (host) to database (network) format */
	htond( ep->ext_buf, (unsigned char *)vec, 11 );

	return(0);
}

/*
 *			R T _ R H C _ D E S C R I B E
 *
 *  Make human-readable formatted presentation of this solid.
 *  First line describes type of solid.
 *  Additional lines are indented one tab, and give parameter values.
 */
int
rt_rhc_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
{
	register struct rt_rhc_internal	*xip =
		(struct rt_rhc_internal *)ip->idb_ptr;
	char	buf[256];

	RT_RHC_CK_MAGIC(xip);
	bu_vls_strcat( str, "Right Hyperbolic Cylinder (RHC)\n");

	sprintf(buf, "\tV (%g, %g, %g)\n",
		xip->rhc_V[X] * mm2local,
		xip->rhc_V[Y] * mm2local,
		xip->rhc_V[Z] * mm2local );
	bu_vls_strcat( str, buf );

	sprintf(buf, "\tB (%g, %g, %g) mag=%g\n",
		xip->rhc_B[X] * mm2local,
		xip->rhc_B[Y] * mm2local,
		xip->rhc_B[Z] * mm2local,
		MAGNITUDE(xip->rhc_B) * mm2local);
	bu_vls_strcat( str, buf );

	sprintf(buf, "\tH (%g, %g, %g) mag=%g\n",
		xip->rhc_H[X] * mm2local,
		xip->rhc_H[Y] * mm2local,
		xip->rhc_H[Z] * mm2local,
		MAGNITUDE(xip->rhc_H) * mm2local);
	bu_vls_strcat( str, buf );
	
	sprintf(buf, "\tr=%g\n", xip->rhc_r * mm2local);
	bu_vls_strcat( str, buf );
	
	sprintf(buf, "\tc=%g\n", xip->rhc_c * mm2local);
	bu_vls_strcat( str, buf );

	return(0);
}

/*
 *			R T _ R H C _ I F R E E
 *
 *  Free the storage associated with the rt_db_internal version of this solid.
 */
void
rt_rhc_ifree(struct rt_db_internal *ip)
{
	register struct rt_rhc_internal	*xip;

	RT_CK_DB_INTERNAL(ip);
	xip = (struct rt_rhc_internal *)ip->idb_ptr;
	RT_RHC_CK_MAGIC(xip);
	xip->rhc_magic = 0;		/* sanity */

	bu_free( (char *)xip, "rhc ifree" );
	ip->idb_ptr = GENPTR_NULL;	/* sanity */
}
@


11.28
log
@change conf.h to a wrapped config.h
@
text
@d152 1
a152 1
static const char RCSrhc[] = "@@(#)$Header: /cvs/brlcad/librt/g_rhc.c,v 11.27 2004/04/05 08:48:57 morrison Exp $ (BRL)";
@


11.27
log
@merge of ansi-6-0-branch into HEAD
@
text
@d152 1
a152 1
static const char RCSrhc[] = "@@(#)$Header$ (BRL)";
d155 5
a159 1
#include "conf.h"
@


11.26
log
@update copyright to include span through 2003
@
text
@d152 1
a152 1
static const char RCSrhc[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_rhc.c,v 11.25 2002/08/20 17:08:01 jra Exp $ (BRL)";
d208 1
a208 4
rt_rhc_prep( stp, ip, rtip )
struct soltab		*stp;
struct rt_db_internal	*ip;
struct rt_i		*rtip;
d308 1
a308 2
rt_rhc_print( stp )
register const struct soltab *stp;
d339 1
a339 5
rt_rhc_shot( stp, rp, ap, seghead )
struct soltab		*stp;
register struct xray	*rp;
struct application	*ap;
struct seg		*seghead;
d509 6
a514 6
rt_rhc_vshot( stp, rp, segp, n, ap )
struct soltab	       *stp[]; /* An array of solid pointers */
struct xray		*rp[]; /* An array of ray pointers */
struct  seg            segp[]; /* array of segs (results returned) */
int		  	    n; /* Number of ray/object pairs */
struct application	*ap;
d525 1
a525 4
rt_rhc_norm( hitp, stp, rp )
register struct hit	*hitp;
struct soltab		*stp;
register struct xray	*rp;
d564 1
a564 4
rt_rhc_curve( cvp, hitp, stp )
register struct curvature *cvp;
register struct hit	*hitp;
struct soltab		*stp;
d605 1
a605 5
rt_rhc_uv( ap, stp, hitp, uvp )
struct application	*ap;
struct soltab		*stp;
register struct hit	*hitp;
register struct uvcoord	*uvp;
d648 1
a648 2
rt_rhc_free( stp )
register struct soltab *stp;
d660 1
a660 1
rt_rhc_class()
d670 1
a670 5
rt_rhc_plot( vhead, ip, ttol, tol )
struct bu_list		*vhead;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol		*tol;
d679 1
a679 1
	struct rt_pt_node	*old, *pos, *pts, *rt_ptalloc();
d817 1
a817 3
rt_mk_hyperbola( pts, r, b, c, dtol, ntol )
fastf_t	r, b, c, dtol, ntol;
struct rt_pt_node *pts;
d823 1
a823 1
	struct rt_pt_node *new, *rt_ptalloc();
d890 1
a890 6
rt_rhc_tess( r, m, ip, ttol, tol )
struct nmgregion	**r;
struct model		*m;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol		*tol;
d899 1
a899 1
	struct rt_pt_node	*old, *pos, *pts, *rt_ptalloc();
d1166 1
a1166 5
rt_rhc_import( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
d1210 1
a1210 5
rt_rhc_export( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d1266 1
a1266 5
rt_rhc_import5( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
d1310 1
a1310 5
rt_rhc_export5( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d1366 1
a1366 5
rt_rhc_describe( str, ip, verbose, mm2local )
struct bu_vls		*str;
const struct rt_db_internal	*ip;
int			verbose;
double			mm2local;
d1410 1
a1410 2
rt_rhc_ifree( ip )
struct rt_db_internal	*ip;
@


11.25
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d148 1
a148 1
 *	This software is Copyright (C) 1990 by the United States Army.
d152 1
a152 1
static const char RCSrhc[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_rhc.c,v 11.23 2001/10/02 19:24:30 jra Exp $ (BRL)";
@


11.25.4.1
log
@sync to HEAD...
@
text
@d148 1
a148 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d152 1
a152 1
static const char RCSrhc[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/g_rhc.c,v 11.26 2004/02/02 17:39:21 morrison Exp $ (BRL)";
@


11.25.10.1
log
@merge from HEAD
@
text
@d148 1
a148 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d152 1
a152 1
static const char RCSrhc[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_rhc.c,v 11.26 2004/02/02 17:39:21 morrison Exp $ (BRL)";
@


11.25.10.2
log
@merge from head
@
text
@d152 1
a152 1
static const char RCSrhc[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_rhc.c,v 11.25.10.1 2004/02/12 18:37:41 erikg Exp $ (BRL)";
@


11.25.2.1
log
@Initial ANSIfication
@
text
@d152 1
a152 1
static const char RCSrhc[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_rhc.c,v 11.25 2002/08/20 17:08:01 jra Exp $ (BRL)";
d208 4
a211 1
rt_rhc_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
d311 2
a312 1
rt_rhc_print(register const struct soltab *stp)
d343 5
a347 1
rt_rhc_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
d517 6
a522 6
rt_rhc_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		  	       /* Number of ray/object pairs */
                  	    
d533 4
a536 1
rt_rhc_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
d575 4
a578 1
rt_rhc_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
d619 5
a623 1
rt_rhc_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
d666 2
a667 1
rt_rhc_free(register struct soltab *stp)
d679 1
a679 1
rt_rhc_class(void)
d689 5
a693 1
rt_rhc_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d702 1
a702 1
	struct rt_pt_node	*old, *pos, *pts, *rt_ptalloc(void);
d840 3
a842 1
rt_mk_hyperbola(struct rt_pt_node *pts, fastf_t r, fastf_t b, fastf_t c, fastf_t dtol, fastf_t ntol)
d848 1
a848 1
	struct rt_pt_node *new, *rt_ptalloc(void);
d915 6
a920 1
rt_rhc_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d929 1
a929 1
	struct rt_pt_node	*old, *pos, *pts, *rt_ptalloc(void);
d1196 5
a1200 1
rt_rhc_import(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d1244 5
a1248 1
rt_rhc_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d1304 5
a1308 1
rt_rhc_import5(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d1352 5
a1356 1
rt_rhc_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d1412 5
a1416 1
rt_rhc_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
d1460 2
a1461 1
rt_rhc_ifree(struct rt_db_internal *ip)
@


11.25.2.2
log
@sync branch with HEAD
@
text
@d148 1
a148 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d152 1
a152 1
static const char RCSrhc[] = "@@(#)$Header$ (BRL)";
@


11.24
log
@Converted from K&R to ANSI C - RFH
@
text
@d208 4
a211 1
rt_rhc_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
d311 2
a312 1
rt_rhc_print(register const struct soltab *stp)
d343 5
a347 1
rt_rhc_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
d517 6
a522 6
rt_rhc_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		  	       /* Number of ray/object pairs */
                  	    
d533 4
a536 1
rt_rhc_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
d575 4
a578 1
rt_rhc_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
d619 5
a623 1
rt_rhc_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
d666 2
a667 1
rt_rhc_free(register struct soltab *stp)
d679 1
a679 1
rt_rhc_class(void)
d689 5
a693 1
rt_rhc_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d702 1
a702 1
	struct rt_pt_node	*old, *pos, *pts, *rt_ptalloc(void);
d840 3
a842 1
rt_mk_hyperbola(struct rt_pt_node *pts, fastf_t r, fastf_t b, fastf_t c, fastf_t dtol, fastf_t ntol)
d848 1
a848 1
	struct rt_pt_node *new, *rt_ptalloc(void);
d915 6
a920 1
rt_rhc_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d929 1
a929 1
	struct rt_pt_node	*old, *pos, *pts, *rt_ptalloc(void);
d1196 5
a1200 1
rt_rhc_import(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d1244 5
a1248 1
rt_rhc_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d1304 5
a1308 1
rt_rhc_import5(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d1352 5
a1356 1
rt_rhc_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d1412 5
a1416 1
rt_rhc_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
d1460 2
a1461 1
rt_rhc_ifree(struct rt_db_internal *ip)
@


11.23
log
@Routines were not setting idb_major_type in the internal structure
@
text
@d152 1
a152 1
static const char RCSrhc[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_rhc.c,v 11.22 2001/04/20 22:29:47 morrison Exp $ (BRL)";
d208 1
a208 4
rt_rhc_prep( stp, ip, rtip )
struct soltab		*stp;
struct rt_db_internal	*ip;
struct rt_i		*rtip;
d308 1
a308 2
rt_rhc_print( stp )
register const struct soltab *stp;
d339 1
a339 5
rt_rhc_shot( stp, rp, ap, seghead )
struct soltab		*stp;
register struct xray	*rp;
struct application	*ap;
struct seg		*seghead;
d509 6
a514 6
rt_rhc_vshot( stp, rp, segp, n, ap )
struct soltab	       *stp[]; /* An array of solid pointers */
struct xray		*rp[]; /* An array of ray pointers */
struct  seg            segp[]; /* array of segs (results returned) */
int		  	    n; /* Number of ray/object pairs */
struct application	*ap;
d525 1
a525 4
rt_rhc_norm( hitp, stp, rp )
register struct hit	*hitp;
struct soltab		*stp;
register struct xray	*rp;
d564 1
a564 4
rt_rhc_curve( cvp, hitp, stp )
register struct curvature *cvp;
register struct hit	*hitp;
struct soltab		*stp;
d605 1
a605 5
rt_rhc_uv( ap, stp, hitp, uvp )
struct application	*ap;
struct soltab		*stp;
register struct hit	*hitp;
register struct uvcoord	*uvp;
d648 1
a648 2
rt_rhc_free( stp )
register struct soltab *stp;
d660 1
a660 1
rt_rhc_class()
d670 1
a670 5
rt_rhc_plot( vhead, ip, ttol, tol )
struct bu_list		*vhead;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol		*tol;
d679 1
a679 1
	struct rt_pt_node	*old, *pos, *pts, *rt_ptalloc();
d817 1
a817 3
rt_mk_hyperbola( pts, r, b, c, dtol, ntol )
fastf_t	r, b, c, dtol, ntol;
struct rt_pt_node *pts;
d823 1
a823 1
	struct rt_pt_node *new, *rt_ptalloc();
d890 1
a890 6
rt_rhc_tess( r, m, ip, ttol, tol )
struct nmgregion	**r;
struct model		*m;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol		*tol;
d899 1
a899 1
	struct rt_pt_node	*old, *pos, *pts, *rt_ptalloc();
d1166 1
a1166 5
rt_rhc_import( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
d1210 1
a1210 5
rt_rhc_export( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d1266 1
a1266 5
rt_rhc_import5( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
d1310 1
a1310 5
rt_rhc_export5( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d1366 1
a1366 5
rt_rhc_describe( str, ip, verbose, mm2local )
struct bu_vls		*str;
const struct rt_db_internal	*ip;
int			verbose;
double			mm2local;
d1410 1
a1410 2
rt_rhc_ifree( ip )
struct rt_db_internal	*ip;
@


11.22
log
@CONST to const
@
text
@d152 1
a152 1
static const char RCSrhc[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_rhc.c,v 11.21 2001/03/31 01:57:09 morrison Exp $ (BRL)";
d1214 1
d1318 1
@


11.21
log
@Deprecated bn_mat_idn() and bn_mat_zero(), updated calls to h/vmath.h's MAT_IDN() and MAT_ZERO() performance improved macros.
@
text
@d152 1
a152 1
static const char RCSrhc[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_rhc.c,v 11.20 2000/10/18 18:10:34 butler Exp $ (BRL)";
d183 1
a183 1
CONST struct bu_structparse rt_rhc_parse[] = {
d312 1
a312 1
register CONST struct soltab *stp;
d314 1
a314 1
	register CONST struct rhc_specific *rhc =
d692 2
a693 2
CONST struct rt_tess_tol *ttol;
CONST struct bn_tol		*tol;
d919 2
a920 2
CONST struct rt_tess_tol *ttol;
CONST struct bn_tol		*tol;
d1198 3
a1200 3
CONST struct bu_external	*ep;
register CONST mat_t		mat;
CONST struct db_i		*dbip;
d1245 1
a1245 1
CONST struct rt_db_internal	*ip;
d1247 1
a1247 1
CONST struct db_i		*dbip;
d1305 3
a1307 3
CONST struct bu_external	*ep;
register CONST mat_t		mat;
CONST struct db_i		*dbip;
d1352 1
a1352 1
CONST struct rt_db_internal	*ip;
d1354 1
a1354 1
CONST struct db_i		*dbip;
d1412 1
a1412 1
CONST struct rt_db_internal	*ip;
@


11.20
log
@Patches for compiling under RedHat 7.0
@
text
@d152 1
a152 1
static const char RCSrhc[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_rhc.c,v 11.19 2000/08/21 02:02:31 butler Exp $ (BRL)";
d269 1
a269 1
	bn_mat_idn( R );
d277 1
a277 1
	bn_mat_idn( S );
d736 1
a736 1
	bn_mat_idn( R );
d973 1
a973 1
	bn_mat_idn( R );
@


11.19
log
@Massive compilation warnings eliminated
@
text
@d152 1
a152 1
static const char RCSrhc[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_rhc.c,v 11.18 2000/07/10 23:01:34 mike Exp $ (BRL)";
d158 3
@


11.18
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d152 1
a152 1
static const char RCSrhc[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_rhc.c,v 11.17 2000/06/30 15:38:03 mike Exp $ (BRL)";
d186 2
a187 1
    {0} };
@


11.17
log
@
export methods should not init the external structure, just check them.
@
text
@d152 1
a152 1
static char RCSrhc[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_rhc.c,v 11.16 2000/06/30 15:31:15 mike Exp $ (BRL)";
@


11.16
log
@
The import/export and import5/export5 methods must NOT
re-initialize their rt_db_internal* pointer, they should just check it.
@
text
@d152 1
a152 1
static char RCSrhc[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_rhc.c,v 11.15 2000/06/27 15:33:31 bparker Exp $ (BRL)";
d1253 1
a1253 1
	BU_INIT_EXTERNAL(ep);
d1360 1
a1360 1
	BU_INIT_EXTERNAL(ep);
@


11.15
log
@Call BU_ASSERT_LONG.
@
text
@d152 1
a152 1
static char RCSrhc[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_rhc.c,v 11.14 2000/06/26 21:02:19 bparker Exp $ (BRL)";
d1209 1
a1209 1
	RT_INIT_DB_INTERNAL( ip );
d1312 1
a1312 1
	RT_INIT_DB_INTERNAL( ip );
@


11.14
log
@Add rt_rhc_import5 and rt_rhc_export5 routines.
@
text
@d152 1
a152 1
static char RCSrhc[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_rhc.c,v 11.13 2000/04/12 02:34:35 mike Exp $ (BRL)";
d1309 2
@


11.13
log
@
NT port, non-compat4
@
text
@d152 1
a152 1
static char RCSrhc[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_rhc.c,v 11.12 2000/03/29 02:43:10 mike Exp $ (BRL)";
d1288 104
@


11.12
log
@
Fixed invocation of nmg_mark_edges_real()
@
text
@d152 1
a152 1
static char RCSrhc[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_rhc.c,v 11.11 2000/03/28 20:43:29 mike Exp $ (BRL)";
d600 1
a600 1
	 	vec_ortho( cvp->crv_pdir, hitp->hit_normal );
@


11.11
log
@
Renamed conflicting defines
@
text
@d152 1
a152 1
static char RCSrhc[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_rhc.c,v 11.10 2000/02/02 20:35:08 bparker Exp $ (BRL)";
d1072 1
a1072 1
	(void)nmg_mark_edges_real( &outfaceuses[0]->l );
d1078 1
a1078 1
	(void)nmg_mark_edges_real( &outfaceuses[1]->l );
d1096 1
a1096 1
	(void)nmg_mark_edges_real( &outfaceuses[n+1]->l );
@


11.10
log
@*- unitize B and H before doing VDOT
@
text
@d152 1
a152 1
static char RCSrhc[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_rhc.c,v 11.9 1999/11/26 21:46:48 mike Exp $ (BRL)";
d846 1
a846 1
#define MIKE_TOL .0001
d861 1
a861 1
	if ( z0+MIKE_TOL >= -b )	/* use top sheet of hyperboloid */
d865 1
a865 1
	if (NEAR_ZERO( mpt[Z], MIKE_TOL))
d869 1
a869 1
	if (NEAR_ZERO( mpt[Y], MIKE_TOL ))
@


11.9
log
@
Lint cleanups
@
text
@d152 1
a152 1
static char RCSrhc[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_rhc.c,v 11.8 1999/11/24 23:12:08 mike Exp $ (BRL)";
d1268 12
a1279 4
	
	if ( !NEAR_ZERO( VDOT(xip->rhc_B, xip->rhc_H), RT_DOT_TOL) ) {
		bu_log("rt_rhc_export: B and H are not perpendicular!\n");
		return(-1);
@


11.8
log
@
Made structparse tables CONST
@
text
@d152 1
a152 1
static char RCSrhc[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_rhc.c,v 11.7 1999/11/17 02:42:01 mike Exp $ (BRL)";
a179 5
struct pt_node {
	point_t		p;	/* a point */
	struct pt_node	*next;	/* ptr to next pt */
};

d689 1
a689 1
struct bn_tol		*tol;
d698 1
a698 1
	struct pt_node	*old, *pos, *pts, *rt_ptalloc();
d801 1
a801 1
		bu_free ( (char *)old, "pt_node" );
d838 1
a838 1
struct pt_node *pts;
d844 1
a844 1
	struct pt_node *new, *rt_ptalloc();
d916 1
a916 1
struct bn_tol		*tol;
d925 1
a925 1
	struct pt_node	*old, *pos, *pts, *rt_ptalloc();
d1059 1
a1059 1
		bu_free ( (char *)old, "pt_node" );
d1192 1
a1192 1
rt_rhc_import( ip, ep, mat )
d1196 1
d1239 1
a1239 1
rt_rhc_export( ep, ip, local2mm )
d1243 1
d1294 1
a1294 1
struct rt_db_internal	*ip;
@


11.7
log
@
Added idb_meth and st_meth pointers to allow direct access to per-solid
methods, C++ style.
@
text
@d152 1
a152 1
static char RCSrhc[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_rhc.c,v 11.6 1999/10/30 03:53:27 mike Exp $ (BRL)";
d185 1
a185 1
struct bu_structparse rt_rhc_parse[] = {
@


11.6
log
@
Added magic numbers for ray, hit, and application structures.
@
text
@d152 1
a152 1
static char RCSrhc[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_rhc.c,v 11.5 1999/07/02 22:19:24 mike Exp $ (BRL)";
d251 1
d1215 1
@


11.5
log
@
Removed dependence on compat4.h
@
text
@d152 1
a152 1
static char RCSrhc[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_rhc.c,v 11.4 1999/05/27 19:10:41 mike Exp $ (BRL)";
d399 1
d410 1
d422 1
d448 1
d461 1
d477 1
@


11.4
log
@
sed4
@
text
@d152 1
a152 1
static char RCSrhc[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_rhc.c,v 11.3 1997/06/17 19:31:25 gdurf Exp $ (BRL)";
d804 1
a804 1
		RT_VLIST_LINE_MOVE );
d806 1
a806 1
		RT_ADD_VLIST( vhead, &front[i*ELEMENTS_PER_VECT], RT_VLIST_LINE_DRAW );
d810 1
a810 1
	RT_ADD_VLIST( vhead, &back[(n-1)*ELEMENTS_PER_VECT], RT_VLIST_LINE_MOVE );
d812 1
a812 1
		RT_ADD_VLIST( vhead, &back[i*ELEMENTS_PER_VECT], RT_VLIST_LINE_DRAW );
d817 2
a818 2
		RT_ADD_VLIST( vhead, &front[i*ELEMENTS_PER_VECT], RT_VLIST_LINE_MOVE );
		RT_ADD_VLIST( vhead, &back[i*ELEMENTS_PER_VECT], RT_VLIST_LINE_DRAW );
@


11.3
log
@Added bu_structparse (from tcl.c)
@
text
@d152 1
a152 1
static char RCSrhc[] = "@@(#)$Header: /m/cad/librt/RCS/g_rhc.c,v 11.2 1996/10/21 19:11:33 jra Exp gdurf $ (BRL)";
d252 1
a252 1
	GETSTRUCT( rhc, rhc_specific );
d269 1
a269 1
	mat_idn( R );
d273 1
a273 1
	mat_trn( Rinv, R );			/* inv of rot mat is trn */
d277 1
a277 1
	mat_idn( S );
d283 2
a284 2
	mat_mul( rhc->rhc_SoR, S, R );
	mat_mul( rhc->rhc_invRoS, Rinv, S );
d321 2
a322 2
	mat_print("S o R", rhc->rhc_SoR );
	mat_print("invR o S", rhc->rhc_invRoS );
d489 1
a489 1
		RT_LIST_INSERT( &(seghead->l), &(segp->l) );
d498 1
a498 1
		RT_LIST_INSERT( &(seghead->l), &(segp->l) );
d558 1
a558 1
		rt_log("rt_rhc_norm: surfno=%d bad\n", hitp->hit_surfno);
d636 1
a636 1
		uvp->uv_u = acos(pprime[Y]/len) * rt_invpi;
d643 1
a643 1
		uvp->uv_u = acos(pprime[Y]/len) * rt_invpi;
d666 1
a666 1
	rt_free( (char *)rhc, "rhc_specific" );
d684 1
a684 1
struct rt_list		*vhead;
d687 1
a687 1
struct rt_tol		*tol;
d711 1
a711 1
		rt_log("rt_rhc_plot:  zero length H, B, c, or rh\n");
d718 1
a718 1
		rt_log("rt_rhc_plot: B not perpendicular to H, f=%f\n", f);
d730 1
a730 1
	mat_idn( R );
d734 1
a734 1
	mat_trn( invR, R );			/* inv of rot mat is trn */
d769 1
a769 1
		ntol = rt_pi;
d783 2
a784 2
	front = (fastf_t *)rt_malloc(3*n * sizeof(fastf_t), "fast_t");
	back  = (fastf_t *)rt_malloc(3*n * sizeof(fastf_t), "fast_t");
d799 1
a799 1
		rt_free ( (char *)old, "pt_node" );
d822 2
a823 2
	rt_free( (char *)front, "fastf_t");
	rt_free( (char *)back, "fastf_t");
d914 1
a914 1
struct rt_tol		*tol;
d932 1
a932 1
	RT_CK_TOL( tol );
d948 1
a948 1
		rt_log("rt_rhc_tess:  zero length H, B, c, or rh\n");
d955 1
a955 1
		rt_log("rt_rhc_tess: B not perpendicular to H, f=%f\n", f);
d967 1
a967 1
	mat_idn( R );
d971 1
a971 1
	mat_trn( invR, R );			/* inv of rot mat is trn */
d1006 1
a1006 1
		ntol = rt_pi;
d1020 6
a1025 6
	front = (fastf_t *)rt_malloc(3*n * sizeof(fastf_t), "fastf_t");
	back  = (fastf_t *)rt_malloc(3*n * sizeof(fastf_t), "fastf_t");
	norms = (vect_t *)rt_calloc( n , sizeof( vect_t ) , "rt_rhc_tess: norms" );
	vfront = (struct vertex **)rt_malloc((n+1) * sizeof(struct vertex *), "vertex *");
	vback = (struct vertex **)rt_malloc((n+1) * sizeof(struct vertex *), "vertex *");
	vtemp = (struct vertex **)rt_malloc((n+1) * sizeof(struct vertex *), "vertex *");
d1027 1
a1027 1
		(struct faceuse **)rt_malloc((n+2) * sizeof(struct faceuse *), "faceuse *");
d1057 1
a1057 1
		rt_free ( (char *)old, "pt_node" );
d1061 1
a1061 1
	s = RT_LIST_FIRST(shell, &(*r)->s_hd);
d1129 1
a1129 1
		for( RT_LIST_FOR( vu , vertexuse , &vfront[i]->vu_hd ) )
d1147 1
a1147 1
		for( RT_LIST_FOR( vu , vertexuse , &vback[i]->vu_hd ) )
d1172 7
a1178 7
	rt_free( (char *)front, "fastf_t");
	rt_free( (char *)back, "fastf_t");
	rt_free( (char*)vfront, "vertex *");
	rt_free( (char*)vback, "vertex *");
	rt_free( (char*)vtemp, "vertex *");
	rt_free( (char *)norms , "rt_rhc_tess: norms" );
	rt_free( (char*)outfaceuses, "faceuse *");
d1192 1
a1192 1
CONST struct rt_external	*ep;
d1198 1
a1198 1
	RT_CK_EXTERNAL( ep );
d1202 1
a1202 1
		rt_log("rt_rhc_import: defective record\n");
d1208 1
a1208 1
	ip->idb_ptr = rt_malloc( sizeof(struct rt_rhc_internal), "rt_rhc_internal");
d1221 2
a1222 2
		rt_log( "rt_rhc_import: r or c are zero\n" );
		rt_free( (char *)ip->idb_ptr , "rt_rhc_import: ip->idb_ptr" );
d1236 1
a1236 1
struct rt_external		*ep;
d1248 1
a1248 1
	RT_INIT_EXTERNAL(ep);
d1250 1
a1250 1
	ep->ext_buf = (genptr_t)rt_calloc( 1, ep->ext_nbytes, "rhc external");
d1260 1
a1260 1
		rt_log("rt_rhc_export: not all dimensions positive!\n");
d1265 1
a1265 1
		rt_log("rt_rhc_export: B and H are not perpendicular!\n");
d1288 1
a1288 1
struct rt_vls		*str;
d1298 1
a1298 1
	rt_vls_strcat( str, "Right Hyperbolic Cylinder (RHC)\n");
d1304 1
a1304 1
	rt_vls_strcat( str, buf );
d1311 1
a1311 1
	rt_vls_strcat( str, buf );
d1318 1
a1318 1
	rt_vls_strcat( str, buf );
d1321 1
a1321 1
	rt_vls_strcat( str, buf );
d1324 1
a1324 1
	rt_vls_strcat( str, buf );
d1345 1
a1345 1
	rt_free( (char *)xip, "rhc ifree" );
@


11.2
log
@Mod to nmg_gluefaces() call.
@
text
@d152 1
a152 1
static char RCSrhc[] = "@@(#)$Header: /m/cad/librt/RCS/g_rhc.c,v 11.1 1995/01/04 09:56:56 mike Rel4_4 jra $ (BRL)";
d184 8
@


11.1
log
@Release_4.4
@
text
@d152 1
a152 1
static char RCSrhc[] = "@@(#)$Header: /m/cad/librt/RCS/g_rhc.c,v 1.13 94/11/08 03:00:59 mike Exp $ (BRL)";
d1157 1
a1157 1
	nmg_gluefaces( outfaceuses, n+2 );
@


1.13
log
@Irix 6
@
text
@d152 1
a152 1
static char RCSrhc[] = "@@(#)$Header: /m/cad/librt/RCS/g_rhc.c,v 1.12 94/09/22 12:19:00 jra Exp Locker: mike $ (BRL)";
@


1.12
log
@Removed some excess variables.
@
text
@d152 1
a152 1
static char RCSrhc[] = "@@(#)$Header: /m/cad/librt/RCS/g_rhc.c,v 1.11 94/09/22 11:32:04 jra Exp Locker: jra $ (BRL)";
a207 1
	CONST struct rt_tol		*tol = &rtip->rti_tol;
a210 1
	LOCAL mat_t	mtemp;
a213 1
	LOCAL mat_t	SS;
d217 1
a683 1
	point_t 	p1, p2;
a910 1
	point_t 	p1, p2;
a920 1
	struct edgeuse	*eu, *eu2;
@


1.11
log
@Added vertexuse normals to tessellator.
@
text
@d152 1
a152 1
static char RCSrhc[] = "@@(#)$Header: /m/cad/librt/RCS/g_rhc.c,v 1.10 94/09/13 15:52:51 jra Exp Locker: jra $ (BRL)";
a1037 1
		fastf_t y,z;
a1040 2
		y = pos->p[Y];
		z = pos->p[Z];
@


1.10
log
@Added calls to mark_edges_real.
@
text
@d152 1
a152 1
static char RCSrhc[] = "@@(#)$Header: /m/cad/librt/RCS/g_rhc.c,v 1.9 94/09/02 16:03:34 jra Exp Locker: jra $ (BRL)";
d911 1
a911 1
	int		i, n;
d923 2
d928 4
d1019 1
d1031 3
d1036 1
d1038 9
d1054 1
d1118 46
d1177 1
@


1.9
log
@Added scaling for scalar values on import where needed.
Added conversion to mm for scalar values where needed.
@
text
@d152 1
a152 1
static char RCSrhc[] = "@@(#)$Header: /m/cad/librt/RCS/g_rhc.c,v 1.8 94/08/10 18:38:53 gdurf Exp Locker: jra $ (BRL)";
d924 1
d1049 2
d1055 2
d1073 2
d1091 4
a1094 1
			return(-1);		/* FAIL */
d1112 1
a1112 1
	return(0);
@


1.8
log
@Added include of conf.h
@
text
@d152 1
a152 1
static char RCSrhc[] = "@@(#)$Header: /m/cad/librt/RCS/g_rhc.c,v 1.7 1993/11/18 01:44:08 mike Exp gdurf $ (BRL)";
d1138 2
a1139 2
	xip->rhc_r = rp->s.s_values[3*3];
	xip->rhc_c = rp->s.s_values[3*3+1];
d1141 7
d1195 2
a1196 2
	rhc->s.s_values[3*3] = xip->rhc_r;
	rhc->s.s_values[3*3+1] = xip->rhc_c;
@


1.7
log
@Added tol arg to bounding box routines
@
text
@d152 1
a152 1
static char RCSrhc[] = "@@(#)$Header: /m/cad/librt/RCS/g_rhc.c,v 1.6 93/07/20 22:46:09 mike Exp $ (BRL)";
d154 2
@


1.6
log
@Was using rhc-> before allocating storage.
@
text
@d152 1
a152 1
static char RCSrhc[] = "@@(#)$Header: /m/cad/librt/RCS/g_rhc.c,v 1.5 93/07/20 16:10:58 mike Exp Locker: mike $ (BRL)";
d1089 1
a1089 1
	nmg_region_a( *r );
@


1.5
log
@Pointer used before initialized.
@
text
@d152 1
a152 1
static char RCSrhc[] = "@@(#)$Header: /m/cad/librt/RCS/g_rhc.c,v 1.4 92/03/27 12:59:17 mmark Exp Locker: mike $ (BRL)";
d225 1
a225 2
	magsq_r = rhc->rhc_rsq = mag_r * mag_r;
	rhc->rhc_c = xip->rhc_c;
d247 2
d358 2
a362 1
	x = rhc->rhc_cprime;
d367 1
a367 1
		
@


1.4
log
@added matrix multiply to import()
@
text
@d152 1
a152 1
static char RCSrhc[] = "@@(#)$Header: /m/cad/librt/RCS/g_rhc.c,v 1.3 92/03/25 15:52:47 mmark Exp Locker: mmark $ (BRL)";
d222 1
a222 1
	mag_b = rhc->rhc_b = sqrt( magsq_b = MAGSQ( xip->rhc_B ) );
d247 1
@


1.3
log
@added error checking to import
@
text
@d152 1
a152 1
static char RCSrhc[] = "@@(#)$Header: /m/cad/librt/RCS/g_rhc.c,v 1.2 92/03/24 14:36:06 mmark Exp Locker: mmark $ (BRL)";
d1130 3
a1132 3
	VMOVE( xip->rhc_V, &rp->s.s_values[0*3] );
	VMOVE( xip->rhc_H, &rp->s.s_values[1*3] );
	VMOVE( xip->rhc_B, &rp->s.s_values[2*3] );
@


1.2
log
@fixed import bug
@
text
@d152 1
a152 1
static char RCSrhc[] = "@@(#)$Header: /m/cad/librt/RCS/g_rhc.c,v 1.1 92/02/14 15:31:47 mmark Exp $ (BRL)";
d1166 13
d1180 3
a1182 3
	VMOVE( &rhc->s.s_values[0*3], xip->rhc_V );
	VMOVE( &rhc->s.s_values[1*3], xip->rhc_H );
	VMOVE( &rhc->s.s_values[2*3], xip->rhc_B );
@


1.1
log
@Initial revision
@
text
@d152 1
a152 1
static char RCSrhc[] = "@@(#)$Header: /vld/mmark/cad/librt/RCS/g_rhc.c,v 1.1 92/02/10 15:02:20 mmark Exp $ (BRL)";
d678 7
d686 1
a686 5
        fastf_t front[9*3];
	fastf_t back[9*3];
	fastf_t b, c, rad, y, z;
	int	i, j;
	vect_t	Bunit, Hunit, Runit;
d691 84
d776 14
a789 23
	VMOVE(    Hunit, xip->rhc_H );
	VUNITIZE( Hunit );
	VREVERSE( Bunit, xip->rhc_B );		/* make B positive z axis */
	VUNITIZE( Bunit );
	VCROSS(   Runit, Bunit, Hunit );	/* make R positive y axis */
	b = sqrt(MAGSQ(xip->rhc_B));
	c = xip->rhc_c;
	for (i = 0; i < 4; i++) {
		z = -b * i * 0.25;
		rad = ( (z+b+c)*(z+b+c) - c*c ) / ( b*(b + 2*c) );
		rad = sqrt(rad);
		/* first point */
		y = xip->rhc_r * rad;
		j = (8 - i) * 3;
		VBLEND2(front+j, y, Runit, z, Bunit);
		VADD2(front+j, front+j, xip->rhc_V);
		VADD2(back+j,  front+j, xip->rhc_H);
		/* second point */
		y = -y;
		j = i * 3;
		VBLEND2(front+j, y, Runit, z, Bunit);
		VADD2(front+j, front+j, xip->rhc_V);
		VADD2(back+j,  front+j, xip->rhc_H);
a790 7
	/* tip of hyperbola */
	y = 0.0;
	z = -b;
	j = 4 * 3;
	VBLEND2(front+j, y, Runit, z, Bunit);
	VADD2(front+j, front+j, xip->rhc_V);
	VADD2(back+j,  front+j, xip->rhc_H);
d793 3
a795 2
	RT_ADD_VLIST( vhead, &front[8*ELEMENTS_PER_VECT], RT_VLIST_LINE_MOVE );
	for( i = 0; i < 9; i++ )  {
d800 2
a801 2
	RT_ADD_VLIST( vhead, &back[8*ELEMENTS_PER_VECT], RT_VLIST_LINE_MOVE );
	for( i = 0; i < 9; i++ )  {
d806 1
a806 1
	for( i = 0; i < 9; i += 4 )  {
d811 4
d834 1
d849 1
a849 1
	if ( z0 >= -b )		/* use top sheet of hyperboloid */
d853 2
d856 4
a859 2
	mpt[Y] = r * sqrt( ((mpt[Z] + b + c) * (mpt[Z] + b + c) - c*c)
		/ (b*(b + 2*c)) );
d991 1
a991 1
		ntol = 3.1416;
d1005 2
a1006 2
	front = (fastf_t *)rt_malloc(3*n * sizeof(fastf_t), "fast_f");
	back  = (fastf_t *)rt_malloc(3*n * sizeof(fastf_t), "fast_f");
d1134 1
a1134 1
	xip->rhc_c = rp->s.s_values[4*3];
d1171 1
a1171 1
	rhc->s.s_values[4*3] = xip->rhc_c;
d1217 1
a1217 1
	sprintf(buf, "\tr=%g\n", xip->rhc_r);
d1220 1
a1220 1
	sprintf(buf, "\tc=%g\n", xip->rhc_c);
@
