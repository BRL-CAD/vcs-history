head	11.13;
access;
symbols
	ansi-20040405-merged:11.8.2.2
	postmerge-20040405-ansi:11.11
	premerge-20040404-ansi:11.10
	postmerge-autoconf:11.10
	autoconf-freeze:11.8.10.3
	premerge-autoconf:11.10
	ansi-20040316-freeze:11.8.2.1
	postmerge-20040315-windows:11.10
	premerge-20040315-windows:11.10
	windows-20040315-freeze:11.8.4.1
	autoconf-20031203:11.8.10.1
	autoconf-20031202:11.8
	autoconf-branch:11.8.0.10
	phong-branch:11.8.0.8
	photonmap-branch:11.8.0.6
	rel-6-1-DP:11.8
	windows-branch:11.8.0.4
	rel-6-0-2:11.6
	ansi-branch:11.8.0.2
	rel-6-0-1-branch:11.6.0.2
	hartley-6-0-post:11.7
	hartley-6-0-pre:11.6
	rel-6-0-1:11.6
	rel-6-0:11.6
	rel-5-4:11.4
	offsite-5-3-pre:11.5
	rel-5-3:11.4
	rel-5-2:11.4
	rel-5-1-branch:11.4.0.2
	rel-5-1:11.4;
locks; strict;
comment	@ * @;


11.13
date	2004.05.21.18.07.32;	author morrison;	state dead;
branches;
next	11.12;

11.12
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.11;

11.11
date	2004.04.05.08.48.57;	author morrison;	state Exp;
branches;
next	11.10;

11.10
date	2004.02.02.17.39.22;	author morrison;	state Exp;
branches;
next	11.9;

11.9
date	2003.11.20.07.15.39;	author morrison;	state Exp;
branches;
next	11.8;

11.8
date	2002.08.20.17.08.02;	author jra;	state Exp;
branches
	11.8.2.1
	11.8.4.1
	11.8.10.1;
next	11.7;

11.7
date	2002.08.15.20.55.14;	author hartley;	state Exp;
branches;
next	11.6;

11.6
date	2001.04.20.22.29.48;	author morrison;	state Exp;
branches;
next	11.5;

11.5
date	2000.07.10.23.01.37;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	99.11.19.04.11.24;	author cjohnson;	state Exp;
branches;
next	11.3;

11.3
date	99.11.13.03.45.10;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	99.11.13.03.42.17;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	99.11.13.03.38.30;	author mike;	state Exp;
branches;
next	;

11.8.2.1
date	2002.09.19.18.01.37;	author morrison;	state Exp;
branches;
next	11.8.2.2;

11.8.2.2
date	2004.03.17.21.18.50;	author morrison;	state Exp;
branches;
next	;

11.8.4.1
date	2004.03.11.23.43.40;	author morrison;	state Exp;
branches;
next	;

11.8.10.1
date	2003.12.03.16.24.07;	author erikg;	state Exp;
branches;
next	11.8.10.2;

11.8.10.2
date	2004.02.12.18.37.42;	author erikg;	state Exp;
branches;
next	11.8.10.3;

11.8.10.3
date	2004.03.15.14.07.23;	author erikg;	state Exp;
branches;
next	;


desc
@@


11.13
log
@moved to src/
@
text
@/*
 *			M A N Y . C
 *
 *  Wrapper routines to help fire multiple rays in parallel,
 *  without exposing the caller to the details of running in parallel.
 *
 *  Authors -
 *	Michael John Muuss
 *	Christopher T. Johnson
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" license agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1999-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/many.c,v 11.12 2004/05/10 15:30:46 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "raytrace.h"

/* For communication between interface routine and each of the threads */
struct rt_many_internal  {
	long			magic;
	long			cur_index;		/* semaphored */
	long			max_index;
	const struct application *proto_ap;
	struct resource		*resources;
	int			(*callback) BU_ARGS((struct application *, int index));
	int			stop_worker;
	int			sem_chunk;
};
#define RT_MANY_INTERNAL_MAGIC	0x526d6970	/* Rmip */
#define RT_CK_RMI(_p)	BU_CKMAG(_p, RT_MANY_INTERNAL_MAGIC, "rt_many_internal")

/*
 *			R T _ S H O O T _ M A N Y _ R A Y S _ W O R K E R
 *
 *  Internal helper routine for rt_shoot_many_rays().
 *  Runs in PARALLEL, one instance per thread.
 *
 *  In order to reduce the traffic through the critical section,
 *  a multiple pixel block may be removed from the work queue at once.
 */
void
rt_shoot_many_rays_worker(int cpu, genptr_t arg)
{
	LOCAL struct application app;
	struct rt_many_internal *rmip = (struct rt_many_internal *)arg;

	if( cpu >= MAX_PSW )  {
		bu_log("rt_shoot_many_rays_worker() cpu %d > MAX_PSW %d, array overrun\n", cpu, MAX_PSW);
		rt_bomb("rt_shoot_many_rays_worker() cpu > MAX_PSW, array overrun\n");
	}

	RT_CK_RMI(rmip);
	RT_CK_RESOURCE( &rmip->resources[cpu] );
	RT_CK_APPLICATION( rmip->proto_ap );

	app = *rmip->proto_ap;			/* struct copy */
	app.a_resource = &rmip->resources[cpu];

	while(1)  {
		register long	index;
		register long	lim;

		if( rmip->stop_worker )  break;

		bu_semaphore_acquire( RT_SEM_WORKER );
		index = rmip->cur_index;
		rmip->cur_index += rmip->sem_chunk;
		bu_semaphore_release( RT_SEM_WORKER );

		lim = index + rmip->sem_chunk;
		for( ; index < lim; index++ )  {
			if( index >= rmip->max_index )  return;

			/*
			 * a_x is set here to get differentiated LIBRT
			 * debugging messages even from a trivial callback.
			 * The callback may, of course, override it.
			 */
			app.a_x = index;

			/* Allow our user to do per-ray init of application struct */
			if( (*rmip->callback)( &app, index ) < 0 )  {
				rmip->stop_worker = 1;
				break;
			}

			(void)rt_shootray( &app );
		}
	}
}

/*
 *			R T _ S H O O T _ M A N Y _ R A Y S
 *
 *  A convenience routine for application developers who wish to fire a
 *  large but fixed number of rays in parallel,
 *  without wanting to create a parallel "self dispatcher"
 *  routine of their own.
 *
 *  Basic setup of the application structure is done by the caller,
 *  and provided via the proto_ap pointer.
 *
 *  Per-ray setup of the application structure is done by the callback
 *  routine, which takes an index in the range 0..(nrays-1) and uses that
 *  to fill in each specific instance of application structure as required.
 *
 *  The a_hit() and a_miss() routines must save any results;
 *  their formal return codes, and the return code from rt_shootray(),
 *  are ignored.
 *
 *  a_x is changed by this wrapper, and may be overridden by the callback.
 *
 *  Note that the cost of spawning threads is sufficiently expensive
 *  that 'nrays' should be at least dozens or hundreds to get
 *  a real benefit from parallelism.
 *
 *  Return codes expected from the callback() -
 *	-1	End processing before all nrays have been fired.
 *	 0	Normal return, proceed with firing the ray.
 *
 *  Note that bu_parallel() is not re-entrant, so you can't have an
 *  a_hit() routine which is already running in parallel call into
 *  this routine and expect to get even more parallelism.
 *  This is not a limitation, as you usually can't construct more CPUs.
 */
void
rt_shoot_many_rays(const struct application *proto_ap, int (*callback) (struct application *, int), int ncpus, long int nrays, struct resource *resources)
                                   
   			                                                    
   			      
    			      
               		           	/* resources[ncpus] */
{
	struct rt_many_internal	rmi;
	int	i;

	RT_CK_APPLICATION(proto_ap);
	for( i=0; i < ncpus; i++ )  {
		RT_CK_RESOURCE( &resources[i] );
	}
	rmi.resources = resources;

	rmi.magic = RT_MANY_INTERNAL_MAGIC;
	rmi.stop_worker = 0;
	rmi.cur_index = 0;
	rmi.max_index = nrays;
	rmi.proto_ap = proto_ap;
	rmi.callback = callback;
	rmi.sem_chunk = ncpus;

	if( !rt_g.rtg_parallel || ncpus <= 1 )  {
		/* The 1-cpu case is supported for testing & generality. */
		rt_shoot_many_rays_worker( 0, (genptr_t)&rmi );
	} else {
		bu_parallel( rt_shoot_many_rays_worker, ncpus, (genptr_t)&rmi );
	}
}
@


11.12
log
@change conf.h to a wrapped config.h
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/librt/many.c,v 11.11 2004/04/05 08:48:57 morrison Exp $ (ARL)";
@


11.11
log
@merge of ansi-6-0-branch into HEAD
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d28 5
a32 1
#include "conf.h"
@


11.10
log
@update copyright to include span through 2003
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/many.c,v 11.9 2003/11/20 07:15:39 morrison Exp $ (ARL)";
d147 6
a152 6
rt_shoot_many_rays( proto_ap, callback, ncpus, nrays, resources )
const struct application *proto_ap;
int			callback BU_ARGS((struct application *, int index));
int			ncpus;
long			nrays;
struct resource		*resources;	/* resources[ncpus] */
@


11.9
log
@testing commit e-mails
@
text
@d21 1
a21 1
 *	This software is Copyright (C) 1999 by the United States Army
d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/many.c,v 11.8 2002/08/20 17:08:02 jra Exp $ (ARL)";
@


11.8
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/many.c,v 11.6 2001/04/20 22:29:48 morrison Exp $ (ARL)";
d62 1
a62 3
rt_shoot_many_rays_worker(cpu, arg)
int		cpu;
genptr_t	arg;
@


11.8.4.1
log
@sync to HEAD...
@
text
@d21 1
a21 1
 *	This software is Copyright (C) 1999-2004 by the United States Army
d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/many.c,v 11.10 2004/02/02 17:39:22 morrison Exp $ (ARL)";
d62 3
a64 1
rt_shoot_many_rays_worker(int cpu, genptr_t arg)
@


11.8.10.1
log
@updates from HEAD, part 1
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/many.c,v 11.9 2003/11/20 07:15:39 morrison Exp $ (ARL)";
d62 3
a64 1
rt_shoot_many_rays_worker(int cpu, genptr_t arg)
@


11.8.10.2
log
@merge from HEAD
@
text
@d21 1
a21 1
 *	This software is Copyright (C) 1999-2004 by the United States Army
d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/many.c,v 11.10 2004/02/02 17:39:22 morrison Exp $ (ARL)";
@


11.8.10.3
log
@merge from head
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/many.c,v 11.8.10.2 2004/02/12 18:37:42 erikg Exp $ (ARL)";
@


11.8.2.1
log
@Initial ANSIfication
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/many.c,v 11.8 2002/08/20 17:08:02 jra Exp $ (ARL)";
d62 3
a64 1
rt_shoot_many_rays_worker(int cpu, genptr_t arg)
d149 6
a154 6
rt_shoot_many_rays(const struct application *proto_ap, int (*callback) (struct application *, int), int ncpus, long int nrays, struct resource *resources)
                                   
   			                                                    
   			      
    			      
               		           	/* resources[ncpus] */
@


11.8.2.2
log
@sync branch with HEAD
@
text
@d21 1
a21 1
 *	This software is Copyright (C) 1999-2004 by the United States Army
d25 1
a25 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
@


11.7
log
@Converted from K&R to ANSI C - RFH
@
text
@d62 3
a64 1
rt_shoot_many_rays_worker(int cpu, genptr_t arg)
d149 6
a154 6
rt_shoot_many_rays(const struct application *proto_ap, int (*callback) (struct application *, int), int ncpus, long int nrays, struct resource *resources)
                                   
   			                                                    
   			      
    			      
               		           	/* resources[ncpus] */
@


11.6
log
@CONST to const
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/many.c,v 11.5 2000/07/10 23:01:37 mike Exp $ (ARL)";
d62 1
a62 3
rt_shoot_many_rays_worker(cpu, arg)
int		cpu;
genptr_t	arg;
d147 6
a152 6
rt_shoot_many_rays( proto_ap, callback, ncpus, nrays, resources )
const struct application *proto_ap;
int			callback BU_ARGS((struct application *, int index));
int			ncpus;
long			nrays;
struct resource		*resources;	/* resources[ncpus] */
@


11.5
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/many.c,v 11.4 1999/11/19 04:11:24 cjohnson Exp $ (ARL)";
d43 1
a43 1
	CONST struct application *proto_ap;
d150 1
a150 1
CONST struct application *proto_ap;
@


11.4
log
@add forgotten assign.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/many.c,v 11.3 1999/11/13 03:45:10 mike Exp $ (ARL)";
@


11.3
log
@
Improved preventive error checking on resource[] array.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/many.c,v 11.2 1999/11/13 03:42:17 mike Exp $ (ARL)";
d163 1
@


11.2
log
@
Clarified comment
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/many.c,v 11.1 1999/11/13 03:38:30 mike Exp $ (ARL)";
d157 1
d160 3
a162 1
	RT_CK_RESOURCE( resources );	/* check first one */
@


11.1
log
@
Added support for shooting many rays together, in parallel.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
d142 5
@

