head	11.23;
access;
symbols
	ansi-20040405-merged:11.19.2.2
	postmerge-20040405-ansi:11.21
	premerge-20040404-ansi:11.20
	postmerge-autoconf:11.20
	autoconf-freeze:11.19.10.2
	premerge-autoconf:11.20
	ansi-20040316-freeze:11.19.2.1
	postmerge-20040315-windows:11.20
	premerge-20040315-windows:11.20
	windows-20040315-freeze:11.19.4.1
	autoconf-20031203:11.19
	autoconf-20031202:11.19
	autoconf-branch:11.19.0.10
	phong-branch:11.19.0.8
	photonmap-branch:11.19.0.6
	rel-6-1-DP:11.19
	windows-branch:11.19.0.4
	rel-6-0-2:11.17
	ansi-branch:11.19.0.2
	rel-6-0-1-branch:11.17.0.2
	hartley-6-0-post:11.18
	hartley-6-0-pre:11.17
	rel-6-0-1:11.17
	rel-6-0:11.17
	rel-5-4:11.9
	offsite-5-3-pre:11.16
	rel-5-3:11.9
	rel-5-2:11.9
	rel-5-1-branch:11.9.0.2
	rel-5-1:11.9
	rel-5-0:11.8
	rel-5-0-beta:11.8
	rel-4-5:11.7
	ctj-4-5-post:11.6
	ctj-4-5-pre:11.6
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.23
date	2004.05.21.18.07.29;	author morrison;	state dead;
branches;
next	11.22;

11.22
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.21;

11.21
date	2004.04.05.08.48.56;	author morrison;	state Exp;
branches;
next	11.20;

11.20
date	2004.02.02.17.39.15;	author morrison;	state Exp;
branches;
next	11.19;

11.19
date	2002.08.20.17.07.57;	author jra;	state Exp;
branches
	11.19.2.1
	11.19.4.1
	11.19.10.1;
next	11.18;

11.18
date	2002.08.15.20.55.10;	author hartley;	state Exp;
branches;
next	11.17;

11.17
date	2001.04.20.22.29.41;	author morrison;	state Exp;
branches;
next	11.16;

11.16
date	2000.10.19.04.28.46;	author mike;	state Exp;
branches;
next	11.15;

11.15
date	2000.10.19.01.25.00;	author mike;	state Exp;
branches;
next	11.14;

11.14
date	2000.10.19.00.51.35;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	2000.09.09.01.02.45;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	2000.07.12.00.13.47;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	2000.07.11.23.16.47;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	2000.07.10.23.01.28;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	99.12.30.21.59.54;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	99.01.28.21.30.54;	author jra;	state Exp;
branches;
next	11.7;

11.7
date	97.12.16.06.09.51;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	96.09.27.08.27.30;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	95.11.07.18.29.57;	author adam;	state Exp;
branches;
next	11.4;

11.4
date	95.07.28.07.37.32;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	95.07.27.20.24.48;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	95.06.02.03.06.51;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.56.18;	author mike;	state Rel4_4;
branches;
next	10.3;

10.3
date	94.08.10.18.02.18;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	94.05.04.07.12.11;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.40.03;	author mike;	state Rel4_0;
branches;
next	1.2;

1.2
date	91.06.29.22.13.49;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	90.04.12.02.28.22;	author mike;	state Exp;
branches;
next	;

11.19.2.1
date	2002.09.19.18.01.31;	author morrison;	state Exp;
branches;
next	11.19.2.2;

11.19.2.2
date	2004.03.17.21.18.44;	author morrison;	state Exp;
branches;
next	;

11.19.4.1
date	2004.03.11.23.43.35;	author morrison;	state Exp;
branches;
next	;

11.19.10.1
date	2004.02.12.18.37.38;	author erikg;	state Exp;
branches;
next	11.19.10.2;

11.19.10.2
date	2004.03.15.14.07.17;	author erikg;	state Exp;
branches;
next	;


desc
@Routines for handling db_full_path structures
@


11.23
log
@moved to src/
@
text
@/*
 *			D B _ P A T H . C
 *
 *  Routines to manipulate "db_full_path" structures
 *
 * Functions -
 *
 *
 *  Authors -
 *	Michael John Muuss
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1990-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/db_path.c,v 11.22 2004/05/10 15:30:46 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"
#include "vmath.h"
#include "raytrace.h"

#include "./debug.h"

/*
 *			D B _ F U L L _ P A T H _ I N I T
 */
void
db_full_path_init( struct db_full_path *pathp )
{
	pathp->fp_len = 0;
	pathp->fp_maxlen = 0;
	pathp->fp_names = (struct directory **)NULL;
	pathp->magic = DB_FULL_PATH_MAGIC;
}

/*
 *			D B _ A D D _ N O D E _ T O _ F U L L _ P A T H
 */
void
db_add_node_to_full_path( struct db_full_path *pp, struct directory *dp )
{
	RT_CK_FULL_PATH( pp );

	if( pp->fp_maxlen <= 0 )  {
		pp->fp_maxlen = 32;
		pp->fp_names = (struct directory **)bu_malloc(
			pp->fp_maxlen * sizeof(struct directory *),
			"db_full_path array");
	} else if( pp->fp_len >= pp->fp_maxlen )  {
		pp->fp_maxlen *= 4;
		pp->fp_names = (struct directory **)rt_realloc(
			(char *)pp->fp_names,
			pp->fp_maxlen * sizeof(struct directory *),
			"enlarged db_full_path array");
	}
	pp->fp_names[pp->fp_len++] = dp;
}

/*
 *			D B _ D U P _ F U L L _ P A T H
 */
void
db_dup_full_path(register struct db_full_path *newp, register const struct db_full_path *oldp)
{
	RT_CK_FULL_PATH(newp);
	RT_CK_FULL_PATH(oldp);

	newp->fp_maxlen = oldp->fp_maxlen;
	newp->fp_len = oldp->fp_len;
	if( oldp->fp_len <= 0 )  {
		newp->fp_names = (struct directory **)0;
		return;
	}
	newp->fp_names = (struct directory **)bu_malloc(
		newp->fp_maxlen * sizeof(struct directory *),
		"db_full_path array (duplicate)" );
	bcopy( (char *)oldp->fp_names, (char *)newp->fp_names,
		newp->fp_len * sizeof(struct directory *) );
}

/*
 *			D B _ E X T E N D _ F U L L _ P A T H
 *
 *  Extend "pathp" so that it can grow from current fp_len by incr more names.
 *
 *  This is intended primarily as an internal method.
 */
void
db_extend_full_path( struct db_full_path *pathp, int incr )
{
	int		newlen;

	RT_CK_FULL_PATH(pathp);

	if( pathp->fp_maxlen <= 0 )  {
		pathp->fp_len = 0;
		pathp->fp_maxlen = incr;
		pathp->fp_names = (struct directory **)bu_malloc(
			pathp->fp_maxlen * sizeof(struct directory *),
			"empty fp_names extension" );
		return;
	}

	newlen = pathp->fp_len + incr;
	if( pathp->fp_maxlen < newlen )  {
		pathp->fp_maxlen = newlen+1;
		pathp->fp_names = (struct directory **)rt_realloc(
			(char *)pathp->fp_names,
			pathp->fp_maxlen * sizeof(struct directory *),
			"fp_names extension" );
	}
}

/*
 *			D B _ A P P E N D _ F U L L _ P A T H
 */
void
db_append_full_path( struct db_full_path *dest, const struct db_full_path *src )
{
	RT_CK_FULL_PATH(dest);
	RT_CK_FULL_PATH(src);

	db_extend_full_path( dest, src->fp_len );
	bcopy( (char *)&src->fp_names[0],
		(char *)&dest->fp_names[dest->fp_len],
		src->fp_len * sizeof(struct directory *) );
	dest->fp_len += src->fp_len;
}

/*
 *			D B _ D U P _ P A T H _ T A I L
 *
 *  Dup old path from starting index to end.
 */
void
db_dup_path_tail(register struct db_full_path *newp, register const struct db_full_path *oldp, int start)
{
	RT_CK_FULL_PATH(newp);
	RT_CK_FULL_PATH(oldp);

	if( start < 0 || start > oldp->fp_len-1 )  rt_bomb("db_dup_path_tail: start offset out of range\n");

	newp->fp_maxlen = newp->fp_len = oldp->fp_len - start;
	if( newp->fp_len <= 0 )  {
		newp->fp_names = (struct directory **)0;
		return;
	}
	newp->fp_names = (struct directory **)bu_malloc(
		newp->fp_maxlen * sizeof(struct directory *),
		"db_full_path array (duplicate)" );
	bcopy( (char *)&oldp->fp_names[start], (char *)newp->fp_names,
		newp->fp_len * sizeof(struct directory *) );
}

/*
 *			D B _ P A T H _ T O _ S T R I N G
 *
 *  Unlike rt_path_str(), this version can be used in parallel.
 *  Caller is responsible for freeing the returned buffer.
 */
char *
db_path_to_string( const struct db_full_path *pp )
{
	register char	*cp;
	char	*buf;
	int	len;
	int	i;

	RT_CK_FULL_PATH( pp );

	len = 3;	/* leading slash, trailing null, spare */
	for( i=pp->fp_len-1; i >= 0; i-- )  {
		if( pp->fp_names[i] )
			len += strlen( pp->fp_names[i]->d_namep ) + 1;
		else
			len += 16;
	}

	buf = bu_malloc( len, "pathname string" );
	cp = buf;

	for( i=0; i < pp->fp_len; i++ )  {
		*cp++ = '/';
		if( pp->fp_names[i] )
			strcpy( cp, pp->fp_names[i]->d_namep );
		else
			strcpy( cp, "**NULL**" );
		cp += strlen( cp );
	}
	*cp++ = '\0';
	return buf;
}

/*
 *			D B _ P A T H _ T O _ V L S
 *
 *  Append a string representation of the path onto the vls.
 *  Must have exactly the same formattting conventions as
 *  db_path_to_string().
 */
void
db_path_to_vls( struct bu_vls *str, const struct db_full_path *pp )
{
	register int i;

	BU_CK_VLS(str);
	RT_CK_FULL_PATH( pp );
	
	for( i=0; i < pp->fp_len; i++ )  {
		bu_vls_putc( str, '/' );
		if( pp->fp_names[i] )
			bu_vls_strcat( str, pp->fp_names[i]->d_namep );
		else
			bu_vls_strcat( str, "**NULL**" );
	}
}

/*
 *			D B _ P R _ F U L L _ P A T H
 */
void
db_pr_full_path( const char *msg, const struct db_full_path *pathp )
{
	char	*sofar = db_path_to_string(pathp);

	bu_log("%s %s\n", msg, sofar );
	bu_free(sofar, "path string");
}

/*
 *			D B _ S T R I N G _ T O _ P A T H
 *
 *  Reverse the effects of db_path_to_string().
 *
 *  The db_full_path structure will be initialized.  If it was already in use,
 *  user should call db_free_full_path() first.
 *
 *  Returns -
 *	-1	One or more components of path did not exist in the directory.
 *	 0	OK
 */
int
db_string_to_path(struct db_full_path *pp, const struct db_i *dbip, const char *str)
{
	register char		*cp;
	register char		*slashp;
	struct directory	*dp;
	char			*copy;
	int			nslash = 0;
	int			ret = 0;
	int			len;

	RT_CK_DBI(dbip);

	/* Count slashes */
	while( *str == '/' )  str++;	/* strip off leading slashes */
	if( *str == '\0' )  {
		/* Path of a lone slash */
		db_full_path_init( pp );
		return 0;
	}

	copy = bu_strdup( str );

	/* eliminate a a trailing slash */
	len = strlen( copy );
	if( copy[len-1] == '/' )
		copy[len-1] = '\0';

	cp = copy;
	while( *cp )  {
		if( (slashp = strchr( cp, '/' )) == NULL )  break;
		nslash++;
		cp = slashp+1;
	}

	/* Make a path structure just big enough */
	pp->magic = DB_FULL_PATH_MAGIC;
	pp->fp_maxlen = pp->fp_len = nslash+1;
	pp->fp_names = (struct directory **)bu_malloc(
		pp->fp_maxlen * sizeof(struct directory *),
		"db_string_to_path path array" );


	/* Build up path array */
	cp = copy;
	nslash = 0;
	while( *cp )  {
		if( (slashp = strchr( cp, '/' )) == NULL )  {
			/* Last element of string, has no trailing slash */
			slashp = cp + strlen(cp) - 1;
		} else {
			*slashp = '\0';
		}
		if( (dp = db_lookup( dbip, cp, LOOKUP_NOISY )) == DIR_NULL )  {
			bu_log("db_string_to_path() of '%s' failed on '%s'\n",
				str, cp );
			ret = -1;	/* FAILED */
			/* Fall through, storing null dp in this location */
		}
		pp->fp_names[nslash++] = dp;
		cp = slashp+1;
	}
	BU_ASSERT_LONG( nslash, ==, pp->fp_len );
	bu_free( copy, "db_string_to_path() duplicate string");
	return ret;
}

/*
 *			D B _ A R G V _ T O _ P A T H
 *
 *  Treat elements from argv[0] to argv[argc-1] as a path specification.
 *
 *  The path structure will be fully initialized.  If it was already in use,
 *  user should call db_free_full_path() first.
 *
 *  Returns -
 *	-1	One or more components of path did not exist in the directory.
 *	 0	OK
 */
int
db_argv_to_path(register struct db_full_path *pp, struct db_i *dbip, int argc, const char *const *argv)
{
	struct directory	*dp;
	int			ret = 0;
	int			i;

	RT_CK_DBI(dbip);

	/* Make a path structure just big enough */
	pp->magic = DB_FULL_PATH_MAGIC;
	pp->fp_maxlen = pp->fp_len = argc;
	pp->fp_names = (struct directory **)bu_malloc(
		pp->fp_maxlen * sizeof(struct directory *),
		"db_argv_to_path path array" );

	for( i=0; i<argc; i++ )  {
		if( (dp = db_lookup( dbip, argv[i], LOOKUP_NOISY )) == DIR_NULL )  {
			bu_log("db_argv_to_path() failed on element %d='%s'\n",
				i, argv[i] );
			ret = -1;	/* FAILED */
			/* Fall through, storing null dp in this location */
		}
		pp->fp_names[i] = dp;
	}
	return ret;
}

/*
 *			D B _ F R E E _ F U L L _ P A T H
 *
 *  Free the contents of the db_full_path structure, but not the structure
 *  itself, which might be automatic.
 */
void
db_free_full_path(register struct db_full_path *pp)
{
	RT_CK_FULL_PATH( pp );

	if( pp->fp_maxlen > 0 )  {
		bu_free( (char *)pp->fp_names, "db_full_path array" );
		pp->fp_maxlen = pp->fp_len = 0;
		pp->fp_names = (struct directory **)0;
	}
}

/*
 *			D B _ I D E N T I C A L _ F U L L _ P A T H S
 *
 *  Returns -
 *	1	match
 *	0	different
 */
int
db_identical_full_paths(
	const struct db_full_path *a,
	const struct db_full_path *b )
{
	register int i;

	RT_CK_FULL_PATH(a);
	RT_CK_FULL_PATH(b);

	if( a->fp_len != b->fp_len )  return 0;

	for( i = a->fp_len-1; i >= 0; i-- )  {
		if( a->fp_names[i] != b->fp_names[i] )  return 0;
	}
	return 1;
}

/*
 *			D B _ F U L L _ P A T H _ S U B S E T
 *
 *  Returns -
 *	1	if 'b' is a proper subset of 'a'
 *	0	if not.
 */
int
db_full_path_subset(
	const struct db_full_path *a,
	const struct db_full_path *b )
{
	register int i;

	RT_CK_FULL_PATH(a);
	RT_CK_FULL_PATH(b);

	if( b->fp_len > a->fp_len )  return 0;

	for( i=0; i < a->fp_len; i++ )  {
		register int j;

		if( a->fp_names[i] != b->fp_names[0] )  continue;

		/* First element matches, check remaining length */
		if( b->fp_len > a->fp_len - i )  return 0;

		/* Check remainder of 'b' */
		for( j=1; j < b->fp_len; j++ )  {
			if( a->fp_names[i+j] != b->fp_names[j] )  goto step;
		}
		/* 'b' is a proper subset */
		return 1;

step:		;
	}
	return 0;
}

/*
 *			D B _ F U L L _ P A T H _ S E A R C H
 *
 *  Returns -
 *	1	'dp' is found on this path
 *	0	not found
 */
int
db_full_path_search( const struct db_full_path *a, const struct directory *dp )
{
	register int i;

	RT_CK_FULL_PATH(a);
	RT_CK_DIR(dp);

	for( i = a->fp_len-1; i >= 0; i-- )  {
		if( a->fp_names[i] == dp )  return 1;
	}
	return 0;
}
@


11.22
log
@change conf.h to a wrapped config.h
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/librt/db_path.c,v 11.21 2004/04/05 08:48:56 morrison Exp $ (BRL)";
@


11.21
log
@merge of ansi-6-0-branch into HEAD
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d25 5
a29 1
#include "conf.h"
@


11.20
log
@update copyright to include span through 2003
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_path.c,v 11.19 2002/08/20 17:07:57 jra Exp $ (BRL)";
d80 1
a80 3
db_dup_full_path( newp, oldp )
register struct db_full_path		*newp;
register const struct db_full_path	*oldp;
d153 1
a153 4
db_dup_path_tail( newp, oldp, start )
register struct db_full_path		*newp;
register const struct db_full_path	*oldp;
int					start;
d339 1
a339 5
db_argv_to_path( pp, dbip, argc, argv )
register struct db_full_path	*pp;
struct db_i			*dbip;
int				argc;
const char			*const*argv;
d373 1
a373 2
db_free_full_path( pp )
register struct db_full_path	*pp;
@


11.19
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1990 by the United States Army.
d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_path.c,v 11.17 2001/04/20 22:29:41 morrison Exp $ (BRL)";
@


11.19.4.1
log
@sync to HEAD...
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/db_path.c,v 11.20 2004/02/02 17:39:15 morrison Exp $ (BRL)";
@


11.19.10.1
log
@merge from HEAD
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_path.c,v 11.20 2004/02/02 17:39:15 morrison Exp $ (BRL)";
@


11.19.10.2
log
@merge from head
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_path.c,v 11.19.10.1 2004/02/12 18:37:38 erikg Exp $ (BRL)";
@


11.19.2.1
log
@Initial ANSIfication
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_path.c,v 11.19 2002/08/20 17:07:57 jra Exp $ (BRL)";
d80 3
a82 1
db_dup_full_path(register struct db_full_path *newp, register const struct db_full_path *oldp)
d155 4
a158 1
db_dup_path_tail(register struct db_full_path *newp, register const struct db_full_path *oldp, int start)
d344 5
a348 1
db_argv_to_path(register struct db_full_path *pp, struct db_i *dbip, int argc, const char *const *argv)
d382 2
a383 1
db_free_full_path(register struct db_full_path *pp)
@


11.19.2.2
log
@sync branch with HEAD
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d22 1
a22 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.18
log
@Converted from K&R to ANSI C - RFH
@
text
@d80 3
a82 1
db_dup_full_path(register struct db_full_path *newp, register const struct db_full_path *oldp)
d155 4
a158 1
db_dup_path_tail(register struct db_full_path *newp, register const struct db_full_path *oldp, int start)
d344 5
a348 1
db_argv_to_path(register struct db_full_path *pp, struct db_i *dbip, int argc, const char *const *argv)
d382 2
a383 1
db_free_full_path(register struct db_full_path *pp)
@


11.17
log
@CONST to const
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_path.c,v 11.16 2000/10/19 04:28:46 mike Exp $ (BRL)";
d80 1
a80 3
db_dup_full_path( newp, oldp )
register struct db_full_path		*newp;
register const struct db_full_path	*oldp;
d153 1
a153 4
db_dup_path_tail( newp, oldp, start )
register struct db_full_path		*newp;
register const struct db_full_path	*oldp;
int					start;
d339 1
a339 5
db_argv_to_path( pp, dbip, argc, argv )
register struct db_full_path	*pp;
struct db_i			*dbip;
int				argc;
const char			*const*argv;
d373 1
a373 2
db_free_full_path( pp )
register struct db_full_path	*pp;
@


11.16
log
@
Changed indentation.
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_path.c,v 11.15 2000/10/19 01:25:00 mike Exp $ (BRL)";
d82 1
a82 1
register CONST struct db_full_path	*oldp;
d157 1
a157 1
register CONST struct db_full_path	*oldp;
d348 1
a348 1
CONST char			*CONST*argv;
@


11.15
log
@
Added an extra subroutine.
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_path.c,v 11.14 2000/10/19 00:51:35 mike Exp $ (BRL)";
d427 3
a429 1
db_full_path_subset( const struct db_full_path *a, const struct db_full_path *b )
@


11.14
log
@
Added some new helper routines for MGED.
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_path.c,v 11.13 2000/09/09 01:02:45 mike Exp $ (BRL)";
d452 21
@


11.13
log
@
Fixed spelling of log message, added assertion check.
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_path.c,v 11.12 2000/07/12 00:13:47 mike Exp $ (BRL)";
d57 1
a57 3
db_add_node_to_full_path( pp, dp )
register struct db_full_path	*pp;
register struct directory	*dp;
d104 2
d108 1
a108 3
db_extend_full_path( pathp, incr )
register struct db_full_path	*pathp;
int				incr;
d184 1
a184 2
db_path_to_string( pp )
register CONST struct db_full_path	*pp;
d217 24
d244 1
a244 3
db_pr_full_path( msg, pathp )
CONST char			*msg;
CONST struct db_full_path	*pathp;
d377 3
d392 62
@


11.12
log
@
Added externs for db_tree.c and db_path.c
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_path.c,v 11.11 2000/07/11 23:16:47 mike Exp $ (BRL)";
d307 2
a308 1
	bu_free( copy, "db_string_to_path() rt_strdip");
@


11.11
log
@
Added externs for new routines in librt/db_*.c
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_path.c,v 11.10 2000/07/10 23:01:28 mike Exp $ (BRL)";
d246 1
a246 1
db_string_to_path(struct db_full_path *pp, struct db_i *dbip, CONST char *str)
@


11.10
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_path.c,v 11.9 1999/12/30 21:59:54 mike Exp $ (BRL)";
d45 1
a45 2
db_full_path_init( pathp )
struct db_full_path	*pathp;
d139 1
a139 3
db_append_full_path( dest, src )
register struct db_full_path	*dest;
register struct db_full_path	*src;
d246 1
a246 4
db_string_to_path( pp, dbip, str )
register struct db_full_path	*pp;
struct db_i			*dbip;
CONST char			*str;
@


11.9
log
@
Added db_argv_to_path()
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_path.c,v 11.8 1999/01/28 21:30:54 jra Exp $ (BRL)";
@


11.8
log
@db_string_to_path() no longer dumps core if the last char is a '/'
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_path.c,v 11.7 1997/12/16 06:09:51 mike Exp $ (BRL)";
d245 1
a245 1
 *	-1	failure (shouldn't happen)
d304 1
a304 1
		if( (dp = db_lookup( dbip, cp, 1 )) == DIR_NULL )  {
d314 44
@


11.7
log
@Ran h/sed4
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_path.c,v 11.6 1996/09/27 08:27:30 mike Exp mike $ (BRL)";
d260 1
d273 6
@


11.6
log
@Converted to using proper routine names for LIBBU and LIBBN routines.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_path.c,v 11.5 1995/11/07 18:29:57 adam Exp mike $ (BRL)";
d66 1
a66 1
		pp->fp_names = (struct directory **)rt_malloc(
d96 1
a96 1
	newp->fp_names = (struct directory **)rt_malloc(
d120 1
a120 1
		pathp->fp_names = (struct directory **)rt_malloc(
d175 1
a175 1
	newp->fp_names = (struct directory **)rt_malloc(
d207 1
a207 1
	buf = rt_malloc( len, "pathname string" );
d233 1
a233 1
	rt_free(sofar, "path string");
d282 1
a282 1
	pp->fp_names = (struct directory **)rt_malloc(
d306 1
a306 1
	rt_free( copy, "db_string_to_path() rt_strdip");
d320 1
a320 1
		rt_free( (char *)pp->fp_names, "db_full_path array" );
@


11.5
log
@Matching malloc and free messages -- db_full_path array (duplicate)
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_path.c,v 11.4 1995/07/28 07:37:32 mike Exp adam $ (BRL)";
d232 1
a232 1
	rt_log("%s %s\n", msg, sofar );
d271 1
a271 1
	copy = rt_strdup( str );
d298 1
a298 1
			rt_log("db_string_to_path() of '%s' failed on '%s'\n",
@


11.4
log
@Added new functions, fixed a few old bugs.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/librt/RCS/db_path.c,v 11.3 1995/07/27 20:24:48 mike Exp mike $ (BRL)";
d98 1
a98 1
		"duplicate full path array" );
d177 1
a177 1
		"duplicate full path array" );
@


11.3
log
@Added db_dup_path_tail()
@
text
@d4 1
d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_path.c,v 11.2 1995/06/02 03:06:51 mike Exp $ (BRL)";
d42 13
d104 51
d223 14
d241 2
a242 2
 *  The db_full_path structure is initialized.  If it was already in use,
 *  call db_free_full_path() first.
d265 6
@


11.2
log
@Added db_string_to_path(), for Lee.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_path.c,v 11.1 1995/01/04 09:56:18 mike Rel4_4 mike $ (BRL)";
d48 2
d90 28
d132 2
d232 2
@


11.1
log
@Release_4.4
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_path.c,v 10.3 94/08/10 18:02:18 gdurf Exp $ (BRL)";
d122 69
a190 1
	return( buf );
@


10.3
log
@Factored ifdefs
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_path.c,v 10.2 1994/05/04 07:12:11 mike Exp gdurf $ (BRL)";
@


10.2
log
@Added error checking
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_path.c,v 10.1 91/10/12 06:40:03 mike Rel4_0 $ (BRL)";
d24 2
d28 3
a30 1
#ifdef BSD
a31 2
#else
#include <string.h>
@


10.1
log
@Release_4.0
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_path.c,v 1.2 91/06/29 22:13:49 mike Exp $ (BRL)";
d69 3
d73 2
a74 1
	if( (newp->fp_len = oldp->fp_len) <= 0 )  {
@


1.2
log
@ANSI lint
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_path.c,v 1.1 90/04/12 02:28:22 mike Exp $ (BRL)";
@


1.1
log
@Initial revision
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: db_path.c,v 1.9 90/04/12 02:23:25 mike Locked $ (BRL)";
d66 2
a67 2
register struct db_full_path	*newp;
register struct db_full_path	*oldp;
d89 1
a89 1
register struct db_full_path	*pp;
@
