head	11.18;
access;
symbols
	ansi-20040405-merged:11.14.2.2
	postmerge-20040405-ansi:11.16
	premerge-20040404-ansi:11.15
	postmerge-autoconf:11.15
	autoconf-freeze:11.14.10.2
	premerge-autoconf:11.15
	ansi-20040316-freeze:11.14.2.1
	postmerge-20040315-windows:11.15
	premerge-20040315-windows:11.15
	windows-20040315-freeze:11.14.4.1
	autoconf-20031203:11.14
	autoconf-20031202:11.14
	autoconf-branch:11.14.0.10
	phong-branch:11.14.0.8
	photonmap-branch:11.14.0.6
	rel-6-1-DP:11.14
	windows-branch:11.14.0.4
	rel-6-0-2:11.12
	ansi-branch:11.14.0.2
	rel-6-0-1-branch:11.12.0.2
	hartley-6-0-post:11.13
	hartley-6-0-pre:11.12
	rel-6-0-1:11.12
	rel-6-0:11.12
	rel-5-4:11.8
	offsite-5-3-pre:11.11
	rel-5-3:11.8
	rel-5-2:11.8
	rel-5-1-branch:11.8.0.2
	rel-5-1:11.8
	rel-5-0:11.7
	rel-5-0-beta:11.6
	rel-4-5:11.6
	ctj-4-5-post:11.6
	ctj-4-5-pre:11.6
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.18
date	2004.05.21.18.07.32;	author morrison;	state dead;
branches;
next	11.17;

11.17
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.16;

11.16
date	2004.04.05.08.48.57;	author morrison;	state Exp;
branches;
next	11.15;

11.15
date	2004.02.02.17.39.22;	author morrison;	state Exp;
branches;
next	11.14;

11.14
date	2002.08.20.17.08.03;	author jra;	state Exp;
branches
	11.14.2.1
	11.14.4.1
	11.14.10.1;
next	11.13;

11.13
date	2002.08.15.20.55.14;	author hartley;	state Exp;
branches;
next	11.12;

11.12
date	2001.04.20.22.29.49;	author morrison;	state Exp;
branches;
next	11.11;

11.11
date	2000.08.23.05.58.38;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	2000.08.21.02.02.32;	author butler;	state Exp;
branches;
next	11.9;

11.9
date	2000.07.10.23.01.39;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	99.11.24.21.44.30;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	99.07.02.22.19.24;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	96.09.27.08.27.30;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	96.05.16.21.54.45;	author jra;	state Exp;
branches;
next	11.4;

11.4
date	96.04.30.20.32.09;	author jra;	state Exp;
branches;
next	11.3;

11.3
date	96.03.05.21.26.15;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	95.06.17.01.17.36;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.57.27;	author mike;	state Rel4_4;
branches;
next	10.24;

10.24
date	94.11.04.06.41.06;	author mike;	state Exp;
branches;
next	10.23;

10.23
date	94.08.10.18.49.03;	author gdurf;	state Exp;
branches;
next	10.22;

10.22
date	94.08.09.19.37.27;	author mike;	state Exp;
branches;
next	10.21;

10.21
date	94.02.04.03.38.25;	author mike;	state Exp;
branches;
next	10.20;

10.20
date	94.02.04.03.02.54;	author mike;	state Exp;
branches;
next	10.19;

10.19
date	94.01.25.16.23.47;	author mike;	state Exp;
branches;
next	10.18;

10.18
date	94.01.14.02.46.14;	author mike;	state Exp;
branches;
next	10.17;

10.17
date	94.01.13.23.24.24;	author mike;	state Exp;
branches;
next	10.16;

10.16
date	93.12.22.06.16.54;	author mike;	state Exp;
branches;
next	10.15;

10.15
date	93.12.21.03.47.07;	author mike;	state Exp;
branches;
next	10.14;

10.14
date	93.12.17.02.06.25;	author mike;	state Exp;
branches;
next	10.13;

10.13
date	93.12.16.05.35.07;	author mike;	state Exp;
branches;
next	10.12;

10.12
date	93.07.20.22.48.49;	author mike;	state Exp;
branches;
next	10.11;

10.11
date	93.04.07.06.34.47;	author mike;	state Exp;
branches;
next	10.10;

10.10
date	93.04.07.05.54.01;	author mike;	state Exp;
branches;
next	10.9;

10.9
date	93.03.25.22.41.52;	author mike;	state Exp;
branches;
next	10.8;

10.8
date	93.03.23.22.12.26;	author mike;	state Exp;
branches;
next	10.7;

10.7
date	93.03.20.04.34.07;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	93.01.20.20.22.56;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	93.01.20.20.02.22;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	92.07.20.23.06.17;	author butler;	state Exp;
branches;
next	10.3;

10.3
date	92.06.05.14.52.20;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	92.03.06.05.47.41;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.40.43;	author mike;	state Rel4_0;
branches;
next	1.45;

1.45
date	91.06.29.22.14.01;	author mike;	state Exp;
branches;
next	1.44;

1.44
date	91.06.17.20.42.01;	author butler;	state Exp;
branches;
next	1.43;

1.43
date	91.05.25.03.31.15;	author mike;	state Exp;
branches;
next	1.42;

1.42
date	91.03.02.00.17.56;	author mike;	state Exp;
branches;
next	1.41;

1.41
date	91.03.01.22.40.52;	author mike;	state Exp;
branches;
next	1.40;

1.40
date	91.02.08.02.49.35;	author mike;	state Exp;
branches;
next	1.39;

1.39
date	91.02.07.20.32.34;	author mike;	state Exp;
branches;
next	1.38;

1.38
date	91.02.06.17.22.37;	author mike;	state Exp;
branches;
next	1.37;

1.37
date	91.01.28.23.52.59;	author mike;	state Exp;
branches;
next	1.36;

1.36
date	91.01.12.07.20.59;	author mike;	state Exp;
branches;
next	1.35;

1.35
date	90.12.08.02.55.04;	author mike;	state Exp;
branches;
next	1.34;

1.34
date	90.06.05.01.09.37;	author mike;	state Exp;
branches;
next	1.33;

1.33
date	90.06.05.01.02.09;	author mike;	state Exp;
branches;
next	1.32;

1.32
date	90.05.25.18.52.18;	author mike;	state Exp;
branches;
next	1.31;

1.31
date	90.05.24.23.23.37;	author mike;	state Exp;
branches;
next	1.30;

1.30
date	90.05.24.03.55.57;	author mike;	state Exp;
branches;
next	1.29;

1.29
date	90.05.23.18.47.45;	author mike;	state Exp;
branches;
next	1.28;

1.28
date	90.05.23.12.15.56;	author mike;	state Exp;
branches;
next	1.27;

1.27
date	90.05.23.00.48.28;	author mike;	state Exp;
branches;
next	1.26;

1.26
date	90.05.22.01.38.07;	author mike;	state Exp;
branches;
next	1.25;

1.25
date	90.05.22.01.32.46;	author mike;	state Exp;
branches;
next	1.24;

1.24
date	90.05.22.01.00.05;	author mike;	state Exp;
branches;
next	1.23;

1.23
date	90.05.22.00.55.25;	author mike;	state Exp;
branches;
next	1.22;

1.22
date	90.05.22.00.41.19;	author mike;	state Exp;
branches;
next	1.21;

1.21
date	90.05.21.19.18.07;	author mike;	state Exp;
branches;
next	1.20;

1.20
date	90.05.18.07.25.58;	author butler;	state Exp;
branches;
next	1.19;

1.19
date	90.05.13.21.01.12;	author mike;	state Exp;
branches;
next	1.18;

1.18
date	90.05.13.18.16.11;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	90.05.13.14.23.59;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	90.05.13.10.48.02;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	90.05.13.10.45.08;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	90.05.13.09.33.33;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	90.05.13.09.03.41;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	90.05.13.08.56.29;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	90.05.13.08.05.03;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	90.05.12.12.06.13;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	90.05.12.10.17.53;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	90.05.09.01.47.34;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	90.05.09.01.05.57;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	90.05.09.00.40.10;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	90.05.08.22.42.45;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	90.05.08.21.57.42;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	90.05.08.21.55.31;	author butler;	state Exp;
branches;
next	1.2;

1.2
date	90.05.08.02.10.21;	author butler;	state Exp;
branches;
next	1.1;

1.1
date	90.05.07.20.04.28;	author butler;	state Exp;
branches;
next	;

11.14.2.1
date	2002.09.19.18.01.38;	author morrison;	state Exp;
branches;
next	11.14.2.2;

11.14.2.2
date	2004.03.17.21.18.52;	author morrison;	state Exp;
branches;
next	;

11.14.4.1
date	2004.03.11.23.43.40;	author morrison;	state Exp;
branches;
next	;

11.14.10.1
date	2004.02.12.18.37.43;	author erikg;	state Exp;
branches;
next	11.14.10.2;

11.14.10.2
date	2004.03.15.14.07.24;	author erikg;	state Exp;
branches;
next	;


desc
@evaluate the boolean operations on lists of classified NMG faces,
resulting in an output shell.
@


11.18
log
@moved to src/
@
text
@/*
 *			N M G _ E V A L . C
 *
 *	Evaluate boolean operations on NMG objects
 *
 *  Authors -
 *	Michael John Muuss
 *	Lee A. Butler
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1990-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSnmg_eval[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/nmg_eval.c,v 11.17 2004/05/10 15:30:46 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif


#include <stdio.h>
#include <math.h>
#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "nmg.h"
#include "raytrace.h"

struct nmg_bool_state  {
	struct shell	*bs_dest;
	struct shell	*bs_src;
	int		bs_isA;		/* true if A, else doing B */
	long		**bs_classtab;
	const int	*bs_actions;
	const struct bn_tol	*bs_tol;
};

static void nmg_eval_shell RT_ARGS( (struct shell *s,
		struct nmg_bool_state *bs));
static void nmg_eval_plot RT_ARGS( (struct nmg_bool_state *bs,
		int num, int delay));


#define BACTION_KILL			1
#define BACTION_RETAIN			2
#define BACTION_RETAIN_AND_FLIP		3

static const char	*nmg_baction_names[] = {
	"*undefined 0*",
	"BACTION_KILL",
	"BACTION_RETAIN",
	"BACTION_RETAIN_AND_FLIP",
	"*undefined 4*"
};

#define NMG_CLASS_BAD		8
static const char	*nmg_class_names[] = {
	"onAinB",
	"onAonBshared",
	"onAonBanti",
	"onAoutB",
	"inAonB",
	"onAonBshared",
	"onAonBanti",
	"outAonB",
	"*BAD*CLASS*"
};

/*
 *			N M G _ C K _ L U _ O R I E N T A T I O N
 *
 *  Make sure that the lu and fu orientation flags are consistent with
 *  the geometric arrangement of the vertices and the faceuse normal.
 */
void
nmg_ck_lu_orientation(struct loopuse *lu, const struct bn_tol *tolp)
{
	struct faceuse	*fu;
	plane_t		fu_peqn;
	plane_t		lu_peqn;
	fastf_t		dot;

	NMG_CK_LOOPUSE(lu);
	fu = lu->up.fu_p;		/* parent had better be faceuse */
	NMG_CK_FACEUSE(fu);

	NMG_GET_FU_PLANE( fu_peqn, fu );
	nmg_loop_plane_newell( lu, lu_peqn );

	dot = VDOT( fu_peqn, lu_peqn );

	if( dot == 0.0 )
		return;		/* can't determine geometric orientation */


	if( dot < 0.0 )
	{
		bu_log("nmg_ck_lu_orientation() lu=x%x, dot=%g, fu_orient=%s, lu_orient=%s\n", lu,
			dot,
			nmg_orientation(fu->orientation),
			nmg_orientation(lu->orientation)
		);
	     	rt_bomb("nmg_ck_lu_orientation() loop orientation flags do not match geometry\n");
	}
}


/*
 *			N M G _ C L A S S _ N A M E
 *
 *  Convert an NMG_CLASS_xxx token into a string name.
 */
const char *
nmg_class_name(int class)
{
	if( class == NMG_CLASS_Unknown )  return "Unknown";
	if( class < 0 || class > NMG_CLASS_BAD )  class = NMG_CLASS_BAD;
	return nmg_class_names[class];
}

/*
 *		Action Table for Boolean Operations.
 *
 *  Each table lists what actions are to be taken for topological elements
 *  which have have each kind of classification.
 *
 *  Actions are listed in this order:
 *	(Aon)	onAinB, onAonBshared, onAonBanti-shared, onAoutB,
 *	(Bon)	inAonB, onAonBshared, onAonBanti-shared, outAonB
 */
static const int		subtraction_actions[8] = {
	BACTION_KILL,
	BACTION_KILL,		/* shared */
	BACTION_RETAIN,		/* anti-shared */
	BACTION_RETAIN,

	BACTION_RETAIN,		/* (formerly BACTION_RETAIN_AND_FLIP) */
	BACTION_KILL,
	BACTION_KILL,
	BACTION_KILL
};

static const int		union_actions[8] = {
	BACTION_KILL,
	BACTION_RETAIN,		/* shared */
	BACTION_KILL,		/* anti-shared */
	BACTION_RETAIN,

	BACTION_KILL,
	BACTION_KILL,
	BACTION_KILL,
	BACTION_RETAIN
};

static const int		intersect_actions[8] = {
	BACTION_RETAIN,
	BACTION_RETAIN,		/* shared */
	BACTION_KILL,		/* anti-shared ==> non-manifold result */
	BACTION_KILL,

	BACTION_RETAIN,
	BACTION_KILL,
	BACTION_KILL,
	BACTION_KILL
};

/*
 *			N M G _ E V A L U A T E _ B O O L E A N
 *
 *  Evaluate a boolean operation on the two shells "A" and "B",
 *  of the form "answer = A op B".
 *  As input, each element (loop-in-face, wire loop, wire edge, vertex)
 *  in both A and B has been classified as being
 *  "in", "on", or "out" of the other shell.
 *  Using these classifications, operate on the input shells.
 *  At the end, shell A contains the resultant object, and
 *  shell B is destroyed.
 *
 */
void
nmg_evaluate_boolean(struct shell *sA, struct shell *sB, int op, long int **classlist, const struct bn_tol *tol)
{
	int const	*actions;
	struct nmg_bool_state	bool_state;

	NMG_CK_SHELL(sA);
	NMG_CK_SHELL(sB);
	BN_CK_TOL(tol);

	if (rt_g.NMG_debug & DEBUG_BOOLEVAL) {
		bu_log("nmg_evaluate_boolean(sA=x%x, sB=x%x, op=%d) START\n",
			sA, sB, op );
	}

	switch( op )  {
	case NMG_BOOL_SUB:
		actions = subtraction_actions;
		nmg_invert_shell(sB, tol);	/* FLIP all faceuse normals */
		break;
	case NMG_BOOL_ADD:
		actions = union_actions;
		break;
	case NMG_BOOL_ISECT:
		actions = intersect_actions;
		break;
	default:
		actions = union_actions;	/* shut up lint */
		bu_log("ERROR nmg_evaluate_boolean() op=%d.\n", op);
		rt_bomb("bad boolean\n");
	}

	bool_state.bs_dest = sA;
	bool_state.bs_src = sB;
	bool_state.bs_classtab = classlist;
	bool_state.bs_actions = actions;
	bool_state.bs_tol = tol;

	bool_state.bs_isA = 1;
	nmg_eval_shell( sA, &bool_state );

	bool_state.bs_isA = 0;
	nmg_eval_shell( sB, &bool_state );

	if (rt_g.NMG_debug & DEBUG_BOOLEVAL) {
		bu_log("nmg_evaluate_boolean(sA=x%x, sB=x%x, op=%d), evaluations done\n",
			sA, sB, op );
	}
	/* Write sA and sB into separate files, if wanted? */

	/* Move everything left in sB into sA.  sB is killed. */
	nmg_js( sA, sB, tol );

	/* Plot the result */
	if (rt_g.NMG_debug & DEBUG_BOOLEVAL && rt_g.NMG_debug & DEBUG_PLOTEM) {
		FILE	*fp;

		if ((fp=fopen("bool_ans.pl", "w")) == (FILE *)NULL) {
			(void)perror("bool_ans.pl");
			exit(-1);
		}
    		bu_log("plotting bool_ans.pl\n");
		nmg_pl_s( fp, sA );
		(void)fclose(fp);
	}

	/* Remove loops/edges/vertices that appear more than once in result */
	nmg_rm_redundancies( sA, tol );

	if (rt_g.NMG_debug & DEBUG_BOOLEVAL) {
		bu_log("nmg_evaluate_boolean(sA=x%x, sB=x%x, op=%d) END\n",
			sA, sB, op );
	}
}

static int	nmg_eval_count = 0;	/* debug -- plot file numbering */

/*
 *			N M G _ E V A L _ A C T I O N
 *
 *  Given a pointer to some NMG data structure,
 *  search the 4 classification lists to determine it's classification.
 *  (XXX In the future, this should be done with one big array).
 *  Then, return the action code for an item of that classification.
 */
int
nmg_eval_action(long int *ptr, register struct nmg_bool_state *bs)
{
	register int	ret;
	register int	class;
	int		index;

	BN_CK_TOL(bs->bs_tol);

	index = nmg_index_of_struct(ptr);
	if( bs->bs_isA )  {
		if( NMG_INDEX_VALUE(bs->bs_classtab[NMG_CLASS_AinB], index) )  {
			class = NMG_CLASS_AinB;
			ret = bs->bs_actions[NMG_CLASS_AinB];
			goto out;
		}
		if( NMG_INDEX_VALUE(bs->bs_classtab[NMG_CLASS_AonBshared], index) )  {
			class = NMG_CLASS_AonBshared;
			ret = bs->bs_actions[NMG_CLASS_AonBshared];
			goto out;
		}
		if( NMG_INDEX_VALUE(bs->bs_classtab[NMG_CLASS_AonBanti], index) )  {
			class = NMG_CLASS_AonBanti;
			ret = bs->bs_actions[NMG_CLASS_AonBanti];
			goto out;
		}
		if( NMG_INDEX_VALUE(bs->bs_classtab[NMG_CLASS_AoutB], index) )  {
			class = NMG_CLASS_AoutB;
			ret = bs->bs_actions[NMG_CLASS_AoutB];
			goto out;
		}
		bu_log("nmg_eval_action(ptr=x%x) %s has no A classification, retaining\n",
			ptr, bu_identify_magic( *((long *)ptr) ) );
		class = NMG_CLASS_BAD;
		ret = BACTION_RETAIN;
		goto out;
	}

	/* is B */
	if( NMG_INDEX_VALUE(bs->bs_classtab[NMG_CLASS_BinA], index) )  {
		class = NMG_CLASS_BinA;
		ret = bs->bs_actions[NMG_CLASS_BinA];
		goto out;
	}
	if( NMG_INDEX_VALUE(bs->bs_classtab[NMG_CLASS_BonAshared], index) )  {
		class = NMG_CLASS_BonAshared;
		ret = bs->bs_actions[NMG_CLASS_BonAshared];
		goto out;
	}
	if( NMG_INDEX_VALUE(bs->bs_classtab[NMG_CLASS_BonAanti], index) )  {
		class = NMG_CLASS_BonAanti;
		ret = bs->bs_actions[NMG_CLASS_BonAanti];
		goto out;
	}
	if( NMG_INDEX_VALUE(bs->bs_classtab[NMG_CLASS_BoutA], index) )  {
		class = NMG_CLASS_BoutA;
		ret = bs->bs_actions[NMG_CLASS_BoutA];
		goto out;
	}
	bu_log("nmg_eval_action(ptr=x%x) %s has no B classification, retaining\n",
		ptr, bu_identify_magic( *((long *)ptr) ) );
	class = NMG_CLASS_BAD;
	ret = BACTION_RETAIN;
out:
	if (rt_g.NMG_debug & DEBUG_BOOLEVAL) {
		bu_log("nmg_eval_action(ptr=x%x) index=%d %s %s %s %s\n",
			ptr, index,
			bs->bs_isA ? "A" : "B",
			bu_identify_magic( *((long *)ptr) ),
			nmg_class_name(class),
			nmg_baction_names[ret] );
	}
	return(ret);
}

/*
 *			N M G _ E V A L _ S H E L L
 *
 *  Make a life-and-death decision on every element of a shell.
 *  Descend the "great chain of being" from the face to loop to edge
 *  to vertex, saving or demoting along the way.
 *
 *  Note that there is no moving of items from one shell to another.
 */
static void
nmg_eval_shell(register struct shell *s, struct nmg_bool_state *bs)
{
	struct faceuse	*fu;
	struct faceuse	*nextfu;
	struct loopuse	*lu;
	struct loopuse	*nextlu;
	struct edgeuse	*eu;
	struct edgeuse	*nexteu;
	struct vertexuse *vu;
	int		loops_retained;

	NMG_CK_SHELL(s);
	BN_CK_TOL(bs->bs_tol);

	if( rt_g.NMG_debug & DEBUG_VERIFY )
		nmg_vshell( &s->r_p->s_hd, s->r_p );

	/*
	 *  For each face in the shell, process all the loops in the face,
	 *  and then handle the face and all loops as a unit.
	 */
	nmg_eval_plot( bs, nmg_eval_count++, 1 );	/* debug */
	fu = BU_LIST_FIRST( faceuse, &s->fu_hd );
	while( BU_LIST_NOT_HEAD( fu, &s->fu_hd ) )  {
		NMG_CK_FACEUSE(fu);
		nextfu = BU_LIST_PNEXT( faceuse, fu );

		/* Faceuse mates will be handled at same time as OT_SAME fu */
		if( fu->orientation != OT_SAME )  {
			fu = nextfu;
			continue;
		}
		if( fu->fumate_p == nextfu )
			nextfu = BU_LIST_PNEXT( faceuse, nextfu );

		/* Consider this face */
		NMG_CK_FACE(fu->f_p);

		loops_retained = 0;
		lu = BU_LIST_FIRST( loopuse, &fu->lu_hd );
		while( BU_LIST_NOT_HEAD( lu, &fu->lu_hd ) )  {
			NMG_CK_LOOPUSE(lu);
			nextlu = BU_LIST_PNEXT( loopuse, lu );
			if( lu->lumate_p == nextlu )
				nextlu = BU_LIST_PNEXT( loopuse, nextlu );

			NMG_CK_LOOP( lu->l_p );
#if 0
			if (rt_g.NMG_debug & DEBUG_BOOLEVAL)
#endif
			{
				nmg_ck_lu_orientation( lu, bs->bs_tol );
			}
			switch( nmg_eval_action( &lu->l_p->magic, bs ) )  {
			case BACTION_KILL:
				/* Kill by demoting loop to edges */
				if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) == NMG_VERTEXUSE_MAGIC )  {
					/* loop of single vertex */
					(void)nmg_klu( lu );
				} else if( nmg_demote_lu( lu ) == 0 )  {
					nmg_eval_plot( bs, nmg_eval_count++, 1 );	/* debug */
				}
				lu = nextlu;
				continue;
			case BACTION_RETAIN:
				loops_retained++;
				break;
			default:
				rt_bomb("nmg_eval_shell() bad BACTION\n");
			}
			lu = nextlu;
		}

		if (rt_g.NMG_debug & DEBUG_BOOLEVAL)
			bu_log("faceuse x%x loops retained=%d\n",
				fu, loops_retained);
		if( rt_g.NMG_debug & DEBUG_VERIFY )
			nmg_vshell( &s->r_p->s_hd, s->r_p );

		/*
		 *  Here, faceuse will have 0 or more loopuses still in it.
		 *  Decide the fate of the face;  if the face dies,
		 *  then any remaining loops, edges, etc, will die too.
		 */
		if( BU_LIST_IS_EMPTY( &fu->lu_hd ) )  {
			if( loops_retained )  rt_bomb("nmg_eval_shell() empty faceuse with retained loops?\n");
			/* faceuse is empty, face & mate die */
			if (rt_g.NMG_debug & DEBUG_BOOLEVAL)
		    		bu_log("faceuse x%x empty, kill\n", fu);
			nmg_kfu( fu );	/* kill face & mate, dequeue from shell */
			if( rt_g.NMG_debug & DEBUG_VERIFY )
				nmg_vshell( &s->r_p->s_hd, s->r_p );
			nmg_eval_plot( bs, nmg_eval_count++, 1 );	/* debug */
			fu = nextfu;
			continue;
		}

		if( loops_retained <= 0 )  {
			nmg_pr_fu(fu, (char *)NULL);
			rt_bomb("nmg_eval_shell() non-empty faceuse, no loops retained?\n");
		}
		fu = nextfu;
	}
	if( rt_g.NMG_debug & DEBUG_VERIFY )
		nmg_vshell( &s->r_p->s_hd, s->r_p );

	/*
	 *  For each loop in the shell, process.
	 *  Each loop is either a wire-loop, or a vertex-with-self-loop.
	 *  Only consider wire loops here.
	 */
	nmg_eval_plot( bs, nmg_eval_count++, 1 );	/* debug */
	lu = BU_LIST_FIRST( loopuse, &s->lu_hd );
	while( BU_LIST_NOT_HEAD( lu, &s->lu_hd ) )  {
		NMG_CK_LOOPUSE(lu);
		nextlu = BU_LIST_PNEXT( loopuse, lu );
		if( lu->lumate_p == nextlu )
			nextlu = BU_LIST_PNEXT( loopuse, nextlu );

		if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) == NMG_VERTEXUSE_MAGIC )  {
			/* ignore vertex-with-self-loop */
			lu = nextlu;
			continue;
		}
		NMG_CK_LOOP( lu->l_p );
		switch( nmg_eval_action( &lu->l_p->magic, bs ) )  {
		case BACTION_KILL:
			/* Demote the loopuse into wire edges */
			/* kill loop & mate */
			if( nmg_demote_lu( lu ) == 0 )
				nmg_eval_plot( bs, nmg_eval_count++, 1 );	/* debug */
			lu = nextlu;
			continue;
		case BACTION_RETAIN:
			break;
		default:
			rt_bomb("nmg_eval_shell() bad BACTION\n");
		}
		lu = nextlu;
	}
	if( rt_g.NMG_debug & DEBUG_VERIFY )
		nmg_vshell( &s->r_p->s_hd, s->r_p );

	/*
	 *  For each wire-edge in the shell, ...
	 */
	nmg_eval_plot( bs, nmg_eval_count++, 1 );	/* debug */
	eu = BU_LIST_FIRST( edgeuse, &s->eu_hd );
	while( BU_LIST_NOT_HEAD( eu, &s->eu_hd ) )  {
		NMG_CK_EDGEUSE(eu);
		nexteu = BU_LIST_PNEXT( edgeuse, eu );	/* may be head */
		if( eu->eumate_p == nexteu )
			nexteu = BU_LIST_PNEXT( edgeuse, nexteu );

		/* Consider this edge */
		NMG_CK_EDGE( eu->e_p );
		switch( nmg_eval_action( &eu->e_p->magic, bs ) )  {
		case BACTION_KILL:
			/* Demote the edegeuse (and mate) into vertices */
			if( nmg_demote_eu( eu ) == 0 )
				nmg_eval_plot( bs, nmg_eval_count++, 1 );	/* debug */
			eu = nexteu;
			continue;
		case BACTION_RETAIN:
			break;
		default:
			rt_bomb("nmg_eval_shell() bad BACTION\n");
		}
		eu = nexteu;
	}

	/*
	 *  For each lone vertex-with-self-loop, process.
	 *  Note that these are intermixed in the loop list.
	 *  Each loop is either a wire-loop, or a vertex-with-self-loop.
	 *  Only consider cases of vertex-with-self-loop here.
	 *
	 *  This case has to be handled separately, because a wire-loop
	 *  may be demoted to a set of wire-edges above, some of which
	 *  may be retained.  The non-retained wire-edges may in turn
	 *  be demoted into vertex-with-self-loop objects above,
	 *  which will be processed here.
	 */
	nmg_eval_plot( bs, nmg_eval_count++, 1 );	/* debug */
	lu = BU_LIST_FIRST( loopuse, &s->lu_hd );
	while( BU_LIST_NOT_HEAD( lu, &s->lu_hd ) )  {
		NMG_CK_LOOPUSE(lu);
		nextlu = BU_LIST_PNEXT( loopuse, lu );

		if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_VERTEXUSE_MAGIC )  {
			/* ignore any remaining wire-loops */
			lu = nextlu;
			continue;
		}
		if( nextlu == lu->lumate_p )
			nextlu = BU_LIST_PNEXT(loopuse, nextlu);
		vu = BU_LIST_PNEXT( vertexuse, &lu->down_hd );
		NMG_CK_VERTEXUSE( vu );
		NMG_CK_VERTEX( vu->v_p );
		switch( nmg_eval_action( &vu->v_p->magic, bs ) )  {
		case BACTION_KILL:
			/* Eliminate the loopuse, and mate */
			nmg_klu( lu );
			lu = nextlu;
			continue;
		case BACTION_RETAIN:
			break;
		default:
			rt_bomb("nmg_eval_shell() bad BACTION\n");
		}
		lu = nextlu;
	}
	if( rt_g.NMG_debug & DEBUG_VERIFY )
		nmg_vshell( &s->r_p->s_hd, s->r_p );

	/*
	 * Final case:  shell of a single vertexuse
	 */
	if( (vu = s->vu_p) )  {
		NMG_CK_VERTEXUSE( vu );
		NMG_CK_VERTEX( vu->v_p );
		switch( nmg_eval_action( &vu->v_p->magic, bs ) )  {
		case BACTION_KILL:
			nmg_kvu( vu );
			nmg_eval_plot( bs, nmg_eval_count++, 0 );	/* debug */
			s->vu_p = (struct vertexuse *)0;	/* sanity */
			break;
		case BACTION_RETAIN:
			break;
		default:
			rt_bomb("nmg_eval_shell() bad BACTION\n");
		}
	}
	if( rt_g.NMG_debug & DEBUG_VERIFY )
		nmg_vshell( &s->r_p->s_hd, s->r_p );
	nmg_eval_plot( bs, nmg_eval_count++, 1 );	/* debug */
}


/*
 *			N M G _ E V A L _ P L O T
 *
 *  Called from nmg_eval_shell
 *
 *  Located here because definition of nmg_bool_state is local to this module.
 */
static void
nmg_eval_plot(struct nmg_bool_state *bs, int num, int delay)
{
	FILE	*fp;
	char	fname[128];
	int	do_plot = 0;
	int	do_anim = 0;

	if (rt_g.NMG_debug & DEBUG_BOOLEVAL && rt_g.NMG_debug & DEBUG_PLOTEM)
		do_plot = 1;
	if( rt_g.NMG_debug & DEBUG_PL_ANIM )  do_anim = 1;

	if( !do_plot && !do_anim )  return;

	BN_CK_TOL(bs->bs_tol);

	if( do_plot )  {
		sprintf(fname, "nmg_eval%d.pl", num);
		if( (fp = fopen(fname,"w")) == NULL )  {
			perror(fname);
			return;
		}
		bu_log("Plotting %s\n", fname);

		nmg_pl_s( fp, bs->bs_dest );
		nmg_pl_s( fp, bs->bs_src );

		fclose(fp);
	}

	if( do_anim )  {
		extern void (*nmg_vlblock_anim_upcall)();
		struct bn_vlblock	*vbp;

		vbp = rt_vlblock_init();

		nmg_vlblock_s( vbp, bs->bs_dest, 0 );
		nmg_vlblock_s( vbp, bs->bs_src, 0 );

		/* Cause animation of boolean operation as it proceeds! */
		if( nmg_vlblock_anim_upcall )  {
			/* if requested, delay 1/4 second */
			(*nmg_vlblock_anim_upcall)( vbp,
				(rt_g.NMG_debug&DEBUG_PL_SLOW) ? 250000 : 0,
				0 );
		} else {
			bu_log("null nmg_vlblock_anim_upcall, no animation\n");
		}
		rt_vlblock_free(vbp);
	}
}
@


11.17
log
@change conf.h to a wrapped config.h
@
text
@d20 1
a20 1
static const char RCSnmg_eval[] = "@@(#)$Header: /cvs/brlcad/librt/nmg_eval.c,v 11.16 2004/04/05 08:48:57 morrison Exp $ (BRL)";
@


11.16
log
@merge of ansi-6-0-branch into HEAD
@
text
@d20 1
a20 1
static const char RCSnmg_eval[] = "@@(#)$Header$ (BRL)";
d23 5
a27 1
#include "conf.h"
@


11.15
log
@update copyright to include span through 2003
@
text
@d20 1
a20 1
static const char RCSnmg_eval[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_eval.c,v 11.14 2002/08/20 17:08:03 jra Exp $ (BRL)";
d79 1
a79 3
nmg_ck_lu_orientation( lu, tolp )
struct loopuse		*lu;
const struct bn_tol	*tolp;
d117 1
a117 2
nmg_class_name(class)
int	class;
d184 1
a184 6
nmg_evaluate_boolean( sA, sB, op, classlist, tol )
struct shell	*sA;
struct shell	*sB;
int		op;
long		*classlist[8];
const struct bn_tol	*tol;
d269 1
a269 3
nmg_eval_action( ptr, bs )
long				*ptr;
register struct nmg_bool_state	*bs;
d353 1
a353 3
nmg_eval_shell( s, bs )
register struct shell	*s;
struct nmg_bool_state *bs;
d600 1
a600 4
nmg_eval_plot( bs, num, delay )
struct nmg_bool_state	*bs;
int		num;
int		delay;
@


11.14
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1990 by the United States Army.
d20 1
a20 1
static const char RCSnmg_eval[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_eval.c,v 11.12 2001/04/20 22:29:49 morrison Exp $ (BRL)";
@


11.14.4.1
log
@sync to HEAD...
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d20 1
a20 1
static const char RCSnmg_eval[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/nmg_eval.c,v 11.15 2004/02/02 17:39:22 morrison Exp $ (BRL)";
@


11.14.10.1
log
@merge from HEAD
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d20 1
a20 1
static const char RCSnmg_eval[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_eval.c,v 11.15 2004/02/02 17:39:22 morrison Exp $ (BRL)";
@


11.14.10.2
log
@merge from head
@
text
@d20 1
a20 1
static const char RCSnmg_eval[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_eval.c,v 11.14.10.1 2004/02/12 18:37:43 erikg Exp $ (BRL)";
@


11.14.2.1
log
@Initial ANSIfication
@
text
@d20 1
a20 1
static const char RCSnmg_eval[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_eval.c,v 11.14 2002/08/20 17:08:03 jra Exp $ (BRL)";
d79 3
a81 1
nmg_ck_lu_orientation(struct loopuse *lu, const struct bn_tol *tolp)
d119 2
a120 1
nmg_class_name(int class)
d187 6
a192 1
nmg_evaluate_boolean(struct shell *sA, struct shell *sB, int op, long int **classlist, const struct bn_tol *tol)
d277 3
a279 1
nmg_eval_action(long int *ptr, register struct nmg_bool_state *bs)
d363 3
a365 1
nmg_eval_shell(register struct shell *s, struct nmg_bool_state *bs)
d612 4
a615 1
nmg_eval_plot(struct nmg_bool_state *bs, int num, int delay)
@


11.14.2.2
log
@sync branch with HEAD
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d20 1
a20 1
static const char RCSnmg_eval[] = "@@(#)$Header$ (BRL)";
@


11.13
log
@Converted from K&R to ANSI C - RFH
@
text
@d79 3
a81 1
nmg_ck_lu_orientation(struct loopuse *lu, const struct bn_tol *tolp)
d119 2
a120 1
nmg_class_name(int class)
d187 6
a192 1
nmg_evaluate_boolean(struct shell *sA, struct shell *sB, int op, long int **classlist, const struct bn_tol *tol)
d277 3
a279 1
nmg_eval_action(long int *ptr, register struct nmg_bool_state *bs)
d363 3
a365 1
nmg_eval_shell(register struct shell *s, struct nmg_bool_state *bs)
d612 4
a615 1
nmg_eval_plot(struct nmg_bool_state *bs, int num, int delay)
@


11.12
log
@CONST to const
@
text
@d20 1
a20 1
static const char RCSnmg_eval[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_eval.c,v 11.11 2000/08/23 05:58:38 mike Exp $ (BRL)";
d79 1
a79 3
nmg_ck_lu_orientation( lu, tolp )
struct loopuse		*lu;
const struct bn_tol	*tolp;
d117 1
a117 2
nmg_class_name(class)
int	class;
d184 1
a184 6
nmg_evaluate_boolean( sA, sB, op, classlist, tol )
struct shell	*sA;
struct shell	*sB;
int		op;
long		*classlist[8];
const struct bn_tol	*tol;
d269 1
a269 3
nmg_eval_action( ptr, bs )
long				*ptr;
register struct nmg_bool_state	*bs;
d353 1
a353 3
nmg_eval_shell( s, bs )
register struct shell	*s;
struct nmg_bool_state *bs;
d600 1
a600 4
nmg_eval_plot( bs, num, delay )
struct nmg_bool_state	*bs;
int		num;
int		delay;
@


11.11
log
@
Fixed lint
@
text
@d20 1
a20 1
static const char RCSnmg_eval[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_eval.c,v 11.10 2000/08/21 02:02:32 butler Exp $ (BRL)";
d37 2
a38 2
	CONST int	*bs_actions;
	CONST struct bn_tol	*bs_tol;
d51 1
a51 1
static CONST char	*nmg_baction_names[] = {
d60 1
a60 1
static CONST char	*nmg_class_names[] = {
d81 1
a81 1
CONST struct bn_tol	*tolp;
d118 1
a118 1
CONST char *
d137 1
a137 1
static CONST int		subtraction_actions[8] = {
d149 1
a149 1
static CONST int		union_actions[8] = {
d161 1
a161 1
static CONST int		intersect_actions[8] = {
d192 1
a192 1
CONST struct bn_tol	*tol;
d194 1
a194 1
	int CONST	*actions;
@


11.10
log
@Massive compilation warnings eliminated
@
text
@d20 1
a20 1
static const char RCSnmg_eval[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_eval.c,v 11.9 2000/07/10 23:01:39 mike Exp $ (BRL)";
d418 1
a418 1
			switch( nmg_eval_action( (genptr_t)lu->l_p, bs ) )  {
d490 1
a490 1
		switch( nmg_eval_action( (genptr_t)lu->l_p, bs ) )  {
d521 1
a521 1
		switch( nmg_eval_action( (genptr_t)eu->e_p, bs ) )  {
d564 1
a564 1
		switch( nmg_eval_action( (genptr_t)vu->v_p, bs ) )  {
d586 1
a586 1
		switch( nmg_eval_action( (genptr_t)vu->v_p, bs ) )  {
@


11.9
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d20 1
a20 1
static const char RCSnmg_eval[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_eval.c,v 11.8 1999/11/24 21:44:30 mike Exp $ (BRL)";
d269 85
d583 1
a583 1
	if( vu = s->vu_p )  {
a602 84
/*
 *			N M G _ E V A L _ A C T I O N
 *
 *  Given a pointer to some NMG data structure,
 *  search the 4 classification lists to determine it's classification.
 *  (XXX In the future, this should be done with one big array).
 *  Then, return the action code for an item of that classification.
 */
int
nmg_eval_action( ptr, bs )
long				*ptr;
register struct nmg_bool_state	*bs;
{
	register int	ret;
	register int	class;
	int		index;

	BN_CK_TOL(bs->bs_tol);

	index = nmg_index_of_struct(ptr);
	if( bs->bs_isA )  {
		if( NMG_INDEX_VALUE(bs->bs_classtab[NMG_CLASS_AinB], index) )  {
			class = NMG_CLASS_AinB;
			ret = bs->bs_actions[NMG_CLASS_AinB];
			goto out;
		}
		if( NMG_INDEX_VALUE(bs->bs_classtab[NMG_CLASS_AonBshared], index) )  {
			class = NMG_CLASS_AonBshared;
			ret = bs->bs_actions[NMG_CLASS_AonBshared];
			goto out;
		}
		if( NMG_INDEX_VALUE(bs->bs_classtab[NMG_CLASS_AonBanti], index) )  {
			class = NMG_CLASS_AonBanti;
			ret = bs->bs_actions[NMG_CLASS_AonBanti];
			goto out;
		}
		if( NMG_INDEX_VALUE(bs->bs_classtab[NMG_CLASS_AoutB], index) )  {
			class = NMG_CLASS_AoutB;
			ret = bs->bs_actions[NMG_CLASS_AoutB];
			goto out;
		}
		bu_log("nmg_eval_action(ptr=x%x) %s has no A classification, retaining\n",
			ptr, bu_identify_magic( *((long *)ptr) ) );
		class = NMG_CLASS_BAD;
		ret = BACTION_RETAIN;
		goto out;
	}

	/* is B */
	if( NMG_INDEX_VALUE(bs->bs_classtab[NMG_CLASS_BinA], index) )  {
		class = NMG_CLASS_BinA;
		ret = bs->bs_actions[NMG_CLASS_BinA];
		goto out;
	}
	if( NMG_INDEX_VALUE(bs->bs_classtab[NMG_CLASS_BonAshared], index) )  {
		class = NMG_CLASS_BonAshared;
		ret = bs->bs_actions[NMG_CLASS_BonAshared];
		goto out;
	}
	if( NMG_INDEX_VALUE(bs->bs_classtab[NMG_CLASS_BonAanti], index) )  {
		class = NMG_CLASS_BonAanti;
		ret = bs->bs_actions[NMG_CLASS_BonAanti];
		goto out;
	}
	if( NMG_INDEX_VALUE(bs->bs_classtab[NMG_CLASS_BoutA], index) )  {
		class = NMG_CLASS_BoutA;
		ret = bs->bs_actions[NMG_CLASS_BoutA];
		goto out;
	}
	bu_log("nmg_eval_action(ptr=x%x) %s has no B classification, retaining\n",
		ptr, bu_identify_magic( *((long *)ptr) ) );
	class = NMG_CLASS_BAD;
	ret = BACTION_RETAIN;
out:
	if (rt_g.NMG_debug & DEBUG_BOOLEVAL) {
		bu_log("nmg_eval_action(ptr=x%x) index=%d %s %s %s %s\n",
			ptr, index,
			bs->bs_isA ? "A" : "B",
			bu_identify_magic( *((long *)ptr) ),
			nmg_class_name(class),
			nmg_baction_names[ret] );
	}
	return(ret);
}
@


11.8
log
@
Removed includes of compat header files rtstring.h and rtlist.h
@
text
@d20 1
a20 1
static char RCSnmg_eval[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_eval.c,v 11.7 1999/07/02 22:19:24 mike Exp $ (BRL)";
@


11.7
log
@
Removed dependence on compat4.h
@
text
@d20 1
a20 1
static char RCSnmg_eval[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_eval.c,v 11.6 1996/09/27 08:27:30 mike Exp $ (BRL)";
a28 1
#include "rtlist.h"
@


11.6
log
@Converted to using proper routine names for LIBBU and LIBBN routines.
@
text
@d20 1
a20 1
static char RCSnmg_eval[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 11.5 1996/05/16 21:54:45 jra Exp mike $ (BRL)";
d646 1
a646 1
		struct rt_vlblock	*vbp;
@


11.5
log
@Changed Boolean action for anti-shared faces in an intersection to BACTION_KILL to avoid
dangling faces.
@
text
@d20 1
a20 1
static char RCSnmg_eval[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 11.4 1996/04/30 20:32:09 jra Exp jra $ (BRL)";
d39 1
a39 1
	CONST struct rt_tol	*bs_tol;
d82 1
a82 1
CONST struct rt_tol	*tolp;
d104 1
a104 1
		rt_log("nmg_ck_lu_orientation() lu=x%x, dot=%g, fu_orient=%s, lu_orient=%s\n", lu,
d193 1
a193 1
CONST struct rt_tol	*tol;
d200 1
a200 1
	RT_CK_TOL(tol);
d203 1
a203 1
		rt_log("nmg_evaluate_boolean(sA=x%x, sB=x%x, op=%d) START\n",
d220 1
a220 1
		rt_log("ERROR nmg_evaluate_boolean() op=%d.\n", op);
d237 1
a237 1
		rt_log("nmg_evaluate_boolean(sA=x%x, sB=x%x, op=%d), evaluations done\n",
d253 1
a253 1
    		rt_log("plotting bool_ans.pl\n");
d262 1
a262 1
		rt_log("nmg_evaluate_boolean(sA=x%x, sB=x%x, op=%d) END\n",
d293 1
a293 1
	RT_CK_TOL(bs->bs_tol);
d303 2
a304 2
	fu = RT_LIST_FIRST( faceuse, &s->fu_hd );
	while( RT_LIST_NOT_HEAD( fu, &s->fu_hd ) )  {
d306 1
a306 1
		nextfu = RT_LIST_PNEXT( faceuse, fu );
d314 1
a314 1
			nextfu = RT_LIST_PNEXT( faceuse, nextfu );
d320 2
a321 2
		lu = RT_LIST_FIRST( loopuse, &fu->lu_hd );
		while( RT_LIST_NOT_HEAD( lu, &fu->lu_hd ) )  {
d323 1
a323 1
			nextlu = RT_LIST_PNEXT( loopuse, lu );
d325 1
a325 1
				nextlu = RT_LIST_PNEXT( loopuse, nextlu );
d337 1
a337 1
				if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) == NMG_VERTEXUSE_MAGIC )  {
d355 1
a355 1
			rt_log("faceuse x%x loops retained=%d\n",
d365 1
a365 1
		if( RT_LIST_IS_EMPTY( &fu->lu_hd ) )  {
d369 1
a369 1
		    		rt_log("faceuse x%x empty, kill\n", fu);
d393 2
a394 2
	lu = RT_LIST_FIRST( loopuse, &s->lu_hd );
	while( RT_LIST_NOT_HEAD( lu, &s->lu_hd ) )  {
d396 1
a396 1
		nextlu = RT_LIST_PNEXT( loopuse, lu );
d398 1
a398 1
			nextlu = RT_LIST_PNEXT( loopuse, nextlu );
d400 1
a400 1
		if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) == NMG_VERTEXUSE_MAGIC )  {
d428 2
a429 2
	eu = RT_LIST_FIRST( edgeuse, &s->eu_hd );
	while( RT_LIST_NOT_HEAD( eu, &s->eu_hd ) )  {
d431 1
a431 1
		nexteu = RT_LIST_PNEXT( edgeuse, eu );	/* may be head */
d433 1
a433 1
			nexteu = RT_LIST_PNEXT( edgeuse, nexteu );
d465 2
a466 2
	lu = RT_LIST_FIRST( loopuse, &s->lu_hd );
	while( RT_LIST_NOT_HEAD( lu, &s->lu_hd ) )  {
d468 1
a468 1
		nextlu = RT_LIST_PNEXT( loopuse, lu );
d470 1
a470 1
		if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_VERTEXUSE_MAGIC )  {
d476 2
a477 2
			nextlu = RT_LIST_PNEXT(loopuse, nextlu);
		vu = RT_LIST_PNEXT( vertexuse, &lu->down_hd );
d536 1
a536 1
	RT_CK_TOL(bs->bs_tol);
d560 2
a561 2
		rt_log("nmg_eval_action(ptr=x%x) %s has no A classification, retaining\n",
			ptr, rt_identify_magic( *((long *)ptr) ) );
d588 2
a589 2
	rt_log("nmg_eval_action(ptr=x%x) %s has no B classification, retaining\n",
		ptr, rt_identify_magic( *((long *)ptr) ) );
d594 1
a594 1
		rt_log("nmg_eval_action(ptr=x%x) index=%d %s %s %s %s\n",
d597 1
a597 1
			rt_identify_magic( *((long *)ptr) ),
d628 1
a628 1
	RT_CK_TOL(bs->bs_tol);
d636 1
a636 1
		rt_log("Plotting %s\n", fname);
d660 1
a660 1
			rt_log("null nmg_vlblock_anim_upcall, no animation\n");
@


11.4
log
@Modified nmg_ck_lu_orientation() to use nmg_loop_plane_newell().
@
text
@d20 1
a20 1
static char RCSnmg_eval[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 11.3 1996/03/05 21:26:15 jra Exp jra $ (BRL)";
d165 1
a165 1
	BACTION_RETAIN,		/* anti-shared ==> non-manifold result */
@


11.3
log
@Added tolerance arg to nmg_rm_redundancies() call.
@
text
@d20 1
a20 1
static char RCSnmg_eval[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 11.2 1995/06/17 01:17:36 mike Exp $ (BRL)";
a83 2
	struct rt_tol	tol;
	int		ccw;
d85 3
a87 1
	plane_t		peqn;
d93 2
a94 1
	NMG_GET_FU_PLANE( peqn, fu );
d96 3
a98 21
	if( tolp )  {
		RT_CK_TOL(tolp);
		tol = *tolp;		/* struct copy */
	} else {
		/* Build something suitable, when no user tol is handy */
		tol.magic = RT_TOL_MAGIC;
		tol.dist = 0.005;
		tol.dist_sq = tol.dist * tol.dist;
		tol.perp = 0;
		tol.para = 1;
	}
	ccw = nmg_loop_is_ccw(lu, peqn, &tol);
	if (rt_g.NMG_debug & DEBUG_BOOLEVAL)  {
		rt_log("nmg_ck_lu_orientation(x%x) ccw=%d, fu=%s, lu=%s\n",
			lu,
			ccw,
			nmg_orientation(fu->orientation),
			nmg_orientation(lu->orientation)
		);
	}
	if( ccw == 0 )
d102 4
a105 4
	if( ((fu->orientation == OT_SAME) == (lu->orientation == OT_SAME) ) &&
	     ccw != 1 )  {
		rt_log("nmg_ck_lu_orientation() lu=x%x, ccw=%d, fu_orient=%s, lu_orient=%s\n", lu,
			ccw,
@


11.2
log
@Added support for printing NMG_CLASS_Unknown
@
text
@d20 1
a20 1
static char RCSnmg_eval[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 11.1 1995/01/04 09:57:27 mike Rel4_4 mike $ (BRL)";
d276 1
a276 1
	nmg_rm_redundancies( sA );
@


11.1
log
@Release_4.4
@
text
@d20 1
a20 1
static char RCSnmg_eval[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 10.24 94/11/04 06:41:06 mike Exp $ (BRL)";
d140 1
d615 1
a615 1
			nmg_class_names[class],
@


10.24
log
@Irix 6
@
text
@d20 1
a20 1
static char RCSnmg_eval[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 10.23 94/08/10 18:49:03 gdurf Exp Locker: mike $ (BRL)";
@


10.23
log
@fix include ordering
@
text
@d20 1
a20 1
static char RCSnmg_eval[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 10.22 1994/08/09 19:37:27 mike Exp gdurf $ (BRL)";
a210 2
	struct loopuse	*lu;
	struct faceuse	*fu;
a211 1
	int		i;
a305 1
	struct vertex	*v;
a306 1
	plane_t		peqn;
a333 1
		NMG_GET_FU_PLANE( peqn, fu );
a634 1
	struct faceuse	*fu;
@


10.22
log
@Added GDurf's new "conf.h"
@
text
@d20 1
a20 1
static char RCSnmg_eval[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 10.21 94/02/04 03:38:25 mike Exp Locker: mike $ (BRL)";
d26 1
a27 1
#include "machine.h"
@


10.21
log
@BACTION_RETAIN_AND_FLIP is now handled by an initial call to
nmg_invert_shell(), and regular BACTION_RETAIN processing.
This simplified things slightly, but was mandatory so as
to reverse all the faces at once.
@
text
@d20 1
a20 1
static char RCSnmg_eval[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 10.20 94/02/04 03:02:54 mike Exp Locker: mike $ (BRL)";
d23 1
@


10.20
log
@nmg_js() now needs a tol arg, for printing
@
text
@d20 1
a20 1
static char RCSnmg_eval[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 10.19 94/01/25 16:23:47 mike Exp Locker: mike $ (BRL)";
d159 1
a159 1
	BACTION_RETAIN_AND_FLIP,
d228 1
a309 1
	int		loops_flipped;
d313 1
d340 1
a340 1
		loops_retained = loops_flipped = 0;
a368 3
			case BACTION_RETAIN_AND_FLIP:
				loops_flipped++;
				break;
d376 2
a377 2
			rt_log("faceuse x%x loops retained=%d, flipped=%d\n",
				fu, loops_retained, loops_flipped);
d387 1
d399 3
a401 18
		if( loops_flipped > 0 )  {
			if( loops_retained > 0 )  {
				rt_log("ERROR nmg_eval_shell() face both retained & flipped?\n");
				/* Just retain un-flipped, for now */
			} else {
				if (rt_g.NMG_debug & DEBUG_BOOLEVAL)
			    		rt_log("faceuse x%x flipped\n", fu);
				nmg_reverse_face( fu );
			}
		} else {
			/* loops_flipped <= 0 */
			if( loops_retained > 0 )  {
				if (rt_g.NMG_debug & DEBUG_BOOLEVAL)
			    		rt_log("faceuse x%x retained\n", fu);
			} else {
				nmg_pr_fu(fu, "  ");
				rt_bomb("nmg_eval_shell() retaining face with no loops?\n");
			}
a435 1
		case BACTION_RETAIN_AND_FLIP:
a465 1
		case BACTION_RETAIN_AND_FLIP:
a507 1
		case BACTION_RETAIN_AND_FLIP:
a529 1
		case BACTION_RETAIN_AND_FLIP:
d557 2
d649 2
@


10.19
log
@If next item is MATE of current item, make next be two ahead in list.
@
text
@d20 1
a20 1
static char RCSnmg_eval[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 10.18 94/01/14 02:46:14 mike Exp Locker: mike $ (BRL)";
d260 1
a260 1
	nmg_js( sA, sB );
@


10.18
log
@Modified to kill/demote everything first, then just nmg_js() to
merge the two shells.
@
text
@d20 1
a20 1
static char RCSnmg_eval[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 10.17 94/01/13 23:24:24 mike Exp Locker: mike $ (BRL)";
d324 1
d332 2
a335 1
		NMG_CK_FACEUSE(fu);
d342 1
d344 2
a346 1
			NMG_CK_LOOPUSE(lu);
a391 2
			if( nextfu == fu->fumate_p )
				nextfu = RT_LIST_PNEXT(faceuse, nextfu);
d432 1
d434 2
a436 1
		NMG_CK_LOOPUSE(lu);
d468 1
d470 2
a473 1
		NMG_CK_EDGEUSE(eu);
a477 2
			if( nexteu == eu->eumate_p )
				nexteu = RT_LIST_PNEXT(edgeuse, nexteu);
d506 1
a508 1
		NMG_CK_LOOPUSE(lu);
d514 2
a521 2
			if( nextlu == lu->lumate_p )
				nextlu = RT_LIST_PNEXT(loopuse, nextlu);
@


10.17
log
@Added 'tol' argument to nmg_evaluate_boolean().
@
text
@d20 1
a20 1
static char RCSnmg_eval[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 10.16 93/12/22 06:16:54 mike Exp Locker: mike $ (BRL)";
d257 1
d259 3
a274 16
	if( RT_LIST_NON_EMPTY( &sB->fu_hd ) )  {
		rt_log("WARNING:  nmg_evaluate_boolean():  shell B still has faces!\n");
	}
	if( RT_LIST_NON_EMPTY( &sB->lu_hd ) )  {
		rt_log("WARNING:  nmg_evaluate_boolean():  shell B still has wire loops!\n");
	}
	if( RT_LIST_NON_EMPTY( &sB->eu_hd ) )  {
		rt_log("WARNING:  nmg_evaluate_boolean():  shell B still has wire edges!\n");
	}
	if(sB->vu_p) {
		rt_log("WARNING:  nmg_evaluate_boolean():  shell B still has verts!\n");
	}

	/* Regardless of what is in it, kill shell B */
	nmg_ks( sB );

d292 2
d405 1
a405 10
				if( fu->s_p != bs->bs_dest )  {
#if 0
rt_log("nmg_reverse_face_and_radials(fu=x%x)\n", fu);
					nmg_reverse_face_and_radials( fu );
#else
					nmg_reverse_face( fu );
#endif
				} else {
					nmg_reverse_face( fu );
				}
a416 27

		if( fu->s_p != bs->bs_dest )  {
			struct faceuse	*fu2;

			if (rt_g.NMG_debug & DEBUG_BOOLEVAL)
		    		rt_log("faceuse x%x moved to A shell\n", fu);
			if( nextfu == fu->fumate_p )
				nextfu = RT_LIST_PNEXT(faceuse, nextfu);

			/* If there is a face in the destination shell that
			 * shares face geometry with this face, then
			 * move all the loops into the other face,
			 * and eliminate this redundant face.
			 */
			fu2 = nmg_find_fu_with_fg_in_s( bs->bs_dest, fu );
			if( fu2 )  {
rt_log("retaining face, doing nmg_jf()\n");
				nmg_jf( fu2, fu );
				/* fu pointer is invalid here */
				fu = fu2;
			} else {
				nmg_mv_fu_between_shells( bs->bs_dest, s, fu );
			}

			fu = nextfu;
			continue;
		}
d449 1
a449 4
			if( lu->up.s_p == bs->bs_dest )  break;
			nmg_mv_lu_between_shells( bs->bs_dest, s, lu );
			lu = nextlu;
			continue;
d480 1
a480 6
			if( eu->up.s_p == bs->bs_dest )  break;
			if( nexteu == eu->eumate_p )
				nexteu = RT_LIST_PNEXT(edgeuse, nexteu);
			nmg_mv_eu_between_shells( bs->bs_dest, s, eu );
			eu = nexteu;
			continue;
d516 1
a516 2
			if( RT_LIST_NOT_HEAD(lu, &lu->down_hd) &&
			    nextlu == lu->lumate_p )
d523 1
a523 7
			if( lu->up.s_p == bs->bs_dest )  break;
			if( RT_LIST_NOT_HEAD(lu, &lu->down_hd) &&
			    nextlu == lu->lumate_p )
				nextlu = RT_LIST_PNEXT(loopuse, nextlu);
			nmg_mv_lu_between_shells( bs->bs_dest, s, lu );
			lu = nextlu;
			continue;
a545 3
			if( vu->up.s_p == bs->bs_dest )  break;
			nmg_mv_vu_between_shells( bs->bs_dest, s, vu );
			s->vu_p = (struct vertexuse *)0;	/* sanity */
@


10.16
log
@Added nmg_ck_lu_orientation(), and called it.
@
text
@d20 1
a20 1
static char RCSnmg_eval[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 10.15 93/12/21 03:47:07 mike Exp Locker: mike $ (BRL)";
d38 1
d203 1
a203 1
nmg_evaluate_boolean( sA, sB, op, classlist )
d208 1
d216 4
d245 1
a353 1
			/* XXX It would be handy to have a user 'tol' here */
d358 1
a358 1
				nmg_ck_lu_orientation( lu, (struct rt_tol *)0 );
d416 1
a416 1
#if 1
d455 1
@


10.15
log
@Check to make sure that loop orientation flags match the geometric
orientation
@
text
@d20 1
a20 1
static char RCSnmg_eval[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 10.14 93/12/17 02:06:25 mike Exp Locker: mike $ (BRL)";
a31 4
/* XXX move to raytrace.h, for nmg_info.c entries */
RT_EXTERN(struct faceuse *nmg_find_fu_with_fg_in_s, (CONST struct shell *s1,
				CONST struct faceuse *fu2));

d72 58
d347 1
d352 1
a352 30
				/* XXX Needing a tol here is just for debugging */
				struct rt_tol	tol;
				int		ccw;

				tol.magic = RT_TOL_MAGIC;
				tol.dist = 0.005;
				tol.dist_sq = tol.dist * tol.dist;
				tol.perp = 0;
				tol.para = 1;
				ccw = nmg_loop_is_ccw(lu, peqn, &tol);
				if (rt_g.NMG_debug & DEBUG_BOOLEVAL)  {
					rt_log("lu=x%x, ccw=%d, fu_orient=%s, lu_orient=%s\n", lu,
						ccw,
						nmg_orientation(fu->orientation),
						nmg_orientation(lu->orientation)
					);
				}
				if( ccw != 0 )  {
					if( ((fu->orientation == OT_SAME) ==
					     (lu->orientation == OT_SAME) ) &&
					     ccw != 1 )  {
						rt_log("lu=x%x, ccw=%d, fu_orient=%s, lu_orient=%s\n", lu,
							ccw,
							nmg_orientation(fu->orientation),
							nmg_orientation(lu->orientation)
						);
					     	rt_bomb("loop orientation flags do not match geometry\n");
					}
					
				}
d410 2
d413 3
@


10.14
log
@Added debug code
@
text
@d20 1
a20 1
static char RCSnmg_eval[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 10.13 93/12/16 05:35:07 mike Exp Locker: mike $ (BRL)";
d293 4
a296 1
			if (rt_g.NMG_debug & DEBUG_BOOLEVAL)  {
d299 2
d306 21
a326 5
				rt_log("lu=x%x, ccw=%d, fu_orient=%s, lu_orient=%s\n", lu,
					nmg_loop_is_ccw(lu, peqn, &tol),
					nmg_orientation(fu->orientation),
					nmg_orientation(lu->orientation)
				);
@


10.13
log
@Started exploiting shared face geometry.
@
text
@d20 1
a20 1
static char RCSnmg_eval[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 10.12 93/07/20 22:48:49 mike Exp Locker: mike $ (BRL)";
d161 1
a161 1
		rt_log("nmg_evaluate_boolean(sA=x%x, sB=x%x, op=%d)\n",
d192 5
d228 5
d259 1
d275 6
d284 2
d293 14
d362 5
a366 5
				nmg_reverse_face( fu );
#if 0
				/* XXX why doesn't this work? */
				nmg_reverse_face_and_radials( fu );
#endif
@


10.12
log
@action tables are CONST
@
text
@d20 1
a20 1
static char RCSnmg_eval[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 10.11 93/04/07 06:34:47 mike Exp Locker: mike $ (BRL)";
d32 4
d312 1
a312 2
			if( RT_LIST_NOT_HEAD(fu, &s->fu_hd) &&
			    nextfu == fu->fumate_p )
d330 4
d345 1
d347 2
d351 1
a351 2
			if( RT_LIST_NOT_HEAD(fu, &s->fu_hd) &&
			    nextfu == fu->fumate_p )
d353 15
a367 1
			nmg_mv_fu_between_shells( bs->bs_dest, s, fu );
@


10.11
log
@Made DEBUG_VERIFY a runtime option
@
text
@d20 1
a20 1
static char RCSnmg_eval[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 10.10 93/04/07 05:54:01 mike Exp Locker: mike $ (BRL)";
d37 1
a37 1
	int		*bs_actions;
d152 1
a152 1
	int		*actions;
@


10.10
log
@Return code from demote_lu and demote_eu have changed,
they now mean that the parent has gone empty.
Same semantics as with the "kill" routines
@
text
@a0 1
#define PARANOID_VERIFY 0
d20 1
a20 1
static char RCSnmg_eval[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 10.9 93/03/25 22:41:52 mike Exp Locker: mike $ (BRL)";
d248 2
a249 3
#if PARANOID_VERIFY
	nmg_vshell( &s->r_p->s_hd, s->r_p );
#endif
d296 2
a297 3
#if PARANOID_VERIFY
		nmg_vshell( &s->r_p->s_hd, s->r_p );
#endif
d312 2
a313 3
#if PARANOID_VERIFY
			nmg_vshell( &s->r_p->s_hd, s->r_p );
#endif
d350 2
a351 3
#if PARANOID_VERIFY
	nmg_vshell( &s->r_p->s_hd, s->r_p );
#endif
d389 2
a390 3
#if PARANOID_VERIFY
	nmg_vshell( &s->r_p->s_hd, s->r_p );
#endif
d475 2
a476 3
#if PARANOID_VERIFY
	nmg_vshell( &s->r_p->s_hd, s->r_p );
#endif
d500 2
a501 3
#if PARANOID_VERIFY
	nmg_vshell( &s->r_p->s_hd, s->r_p );
#endif
@


10.9
log
@Moved these routines from nmg_eval.c to nmg_mod.c:
nmg_reverse_face
nmg_mv_fu_between_shells
nmg_mv_lu_between_shells
nmg_mv_eu_between_shells
nmg_mv_vu_between_shells
nmg_find_vertex_in_edgelist
nmg_find_vertex_in_looplist
nmg_find_vertex_in_facelist
nmg_find_edge_in_edgelist
nmg_find_edge_in_looplist
nmg_find_edge_in_facelist
nmg_find_loop_in_facelist
nmg_rm_redundancies
@
text
@d21 1
a21 1
static char RCSnmg_eval[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 10.8 93/03/23 22:12:26 mike Exp Locker: mike $ (BRL)";
d275 4
a278 1
				if( nmg_demote_lu( lu ) == 0 )  {
a279 3
				} else {
					/* loop of single vertex */
					nmg_klu( lu );	/* removes from fu list */
a280 3
#if PARANOID_VERIFY
				nmg_vshell( &s->r_p->s_hd, s->r_p );
#endif
d298 3
d414 2
a415 3
			if( nmg_demote_eu( eu ) )
				rt_log("nmg_eval_shell() nmg_demote_eu(x%x) fail\n", eu);
			nmg_eval_plot( bs, nmg_eval_count++, 1 );	/* debug */
@


10.8
log
@Added some #if PARANOID_VERIFY checks.
Fixed nmg_rm_redundancy() infinite loop.
Fixed two lumate_p pointer bugs
@
text
@d21 1
a21 1
static char RCSnmg_eval[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 10.7 93/03/20 04:34:07 mike Exp Locker: mike $ (BRL)";
a45 13
/* XXX Move these routines to nmg_mod.c */
/*
 *			N M G _ R E V E R S E _ F A C E
 *
 *  Reverse the orientation of a face.
 *  Manipulate both the topological and geometric aspects of the face.
 */
void
nmg_reverse_face( fu )
register struct faceuse	*fu;
{
	register struct faceuse	*fumate;
	register vectp_t	v;
a46 204
	NMG_CK_FACEUSE(fu);
	fumate = fu->fumate_p;
	NMG_CK_FACEUSE(fumate);
	NMG_CK_FACE(fu->f_p);
	NMG_CK_FACE_G(fu->f_p->fg_p);

	/* reverse face normal vector */
	v = fu->f_p->fg_p->N;
	VREVERSE(v, v);
	v[H] *= -1.0;

	/* switch which face is "outside" face */
	if (fu->orientation == OT_SAME)  {
		if (fumate->orientation != OT_OPPOSITE)  {
			rt_log("nmg_reverse_face(fu=x%x) fu:SAME, fumate:%d\n",
				fu, fumate->orientation);
			rt_bomb("nmg_reverse_face() orientation clash\n");
		} else {
			fu->orientation = OT_OPPOSITE;
			fumate->orientation = OT_SAME;
		}
	} else if (fu->orientation == OT_OPPOSITE) {
		if (fumate->orientation != OT_SAME)  {
			rt_log("nmg_reverse_face(fu=x%x) fu:OPPOSITE, fumate:%d\n",
				fu, fumate->orientation);
			rt_bomb("nmg_reverse_face() orientation clash\n");
		} else {
			fu->orientation = OT_SAME;
			fumate->orientation = OT_OPPOSITE;
		}
	} else {
		/* Unoriented face? */
		rt_log("ERROR nmg_reverse_face(fu=x%x), orientation=%d.\n",
			fu, fu->orientation );
	}
}

/*
 *			N M G _ M V _ F U _ B E T W E E N _ S H E L L S
 *
 *  Move faceuse from 'src' shell to 'dest' shell.
 */
void
nmg_mv_fu_between_shells( dest, src, fu )
struct shell		*dest;
register struct shell	*src;
register struct faceuse	*fu;
{
	register struct faceuse	*fumate;

	NMG_CK_FACEUSE(fu);
	fumate = fu->fumate_p;
	NMG_CK_FACEUSE(fumate);

	if (fu->s_p != src) {
		rt_log("nmg_mv_fu_between_shells(dest=x%x, src=x%x, fu=x%x), fu->s_p=x%x isnt src shell\n",
			dest, src, fu, fu->s_p );
		rt_bomb("fu->s_p isnt source shell\n");
	}
	if (fumate->s_p != src) {
		rt_log("nmg_mv_fu_between_shells(dest=x%x, src=x%x, fu=x%x), fumate->s_p=x%x isn't src shell\n",
			dest, src, fu, fumate->s_p );
		rt_bomb("fumate->s_p isnt source shell\n");
	}

	/* Remove fu from src shell */
	RT_LIST_DEQUEUE( &fu->l );
	if( RT_LIST_IS_EMPTY( &src->fu_hd ) )  {
		/* This was the last fu in the list, bad news */
		rt_log("nmg_mv_fu_between_shells(dest=x%x, src=x%x, fu=x%x), fumate=x%x not in src shell\n",
			dest, src, fu, fumate );
		rt_bomb("src shell emptied before finding fumate\n");
	}

	/* Remove fumate from src shell */
	RT_LIST_DEQUEUE( &fumate->l );

	/* Add fu and fumate to dest shell */
	RT_LIST_APPEND( &dest->fu_hd, &fu->l );
	RT_LIST_APPEND( &fu->l, &fumate->l );

	fu->s_p = dest;
	fumate->s_p = dest;
}

/*
 *			N M G _ M V _ L U _ B E T W E E N _ S H E L L S
 *
 *  Move a wire-loopuse from one shell to another.
 *  Note that this routine can not be used on loops in faces.
 */
void
nmg_mv_lu_between_shells( dest, src, lu )
struct shell		*dest;
register struct shell	*src;
register struct loopuse	*lu;
{
	register struct loopuse	*lumate;

	NMG_CK_LOOPUSE(lu);
	lumate = lu->lumate_p;
	NMG_CK_LOOPUSE(lumate);

	if( lu->up.s_p != src )  {
		rt_log("nmg_mv_lu_between_shells(dest=x%x, src=x%x, lu=x%x), lu->up.s_p=x%x isn't source shell\n",
			dest, src, lu, lu->up.s_p );
		rt_bomb("lu->up.s_p isn't source shell\n");
	}
	if( lumate->up.s_p != src )  {
		rt_log("nmg_mv_lu_between_shells(dest=x%x, src=x%x, lu=x%x), lumate->up.s_p=x%x isn't source shell\n",
			dest, src, lu, lumate->up.s_p );
		rt_bomb("lumate->up.s_p isn't source shell\n");
	}

	/* Remove lu from src shell */
	RT_LIST_DEQUEUE( &lu->l );
	if( RT_LIST_IS_EMPTY( &src->lu_hd ) )  {
		/* This was the last lu in the list */
		rt_log("nmg_mv_lu_between_shells(dest=x%x, src=x%x, lu=x%x), lumate=x%x not in src shell\n",
			dest, src, lu, lumate );
		rt_bomb("src shell emptied before finding lumate\n");
	}

	/* Remove lumate from src shell */
	RT_LIST_DEQUEUE( &lumate->l );

	/* Add lu and lumate to dest shell */
	RT_LIST_APPEND( &dest->lu_hd, &lu->l );
	RT_LIST_APPEND( &lu->l, &lumate->l );

	lu->up.s_p = dest;
	lumate->up.s_p = dest;
}

/*
 *			N M G _ M V _ E U _ B E T W E E N _ S H E L L S
 */
void
nmg_mv_eu_between_shells( dest, src, eu )
struct shell		*dest;
register struct shell	*src;
register struct edgeuse	*eu;
{
	register struct edgeuse	*eumate;

	NMG_CK_EDGEUSE(eu);
	eumate = eu->eumate_p;
	NMG_CK_EDGEUSE(eumate);

	if (eu->up.s_p != src) {
		rt_log("nmg_mv_eu_between_shells(dest=x%x, src=x%x, eu=x%x), eu->up.s_p=x%x isnt src shell\n",
			dest, src, eu, eu->up.s_p );
		rt_bomb("eu->up.s_p isnt source shell\n");
	}
	if (eumate->up.s_p != src) {
		rt_log("nmg_mv_eu_between_shells(dest=x%x, src=x%x, eu=x%x), eumate->up.s_p=x%x isn't src shell\n",
			dest, src, eu, eumate->up.s_p );
		rt_bomb("eumate->up.s_p isnt source shell\n");
	}

	/* Remove eu from src shell */
	RT_LIST_DEQUEUE( &eu->l );
	if( RT_LIST_IS_EMPTY( &src->eu_hd ) )  {
		/* This was the last eu in the list, bad news */
		rt_log("nmg_mv_eu_between_shells(dest=x%x, src=x%x, eu=x%x), eumate=x%x not in src shell\n",
			dest, src, eu, eumate );
		rt_bomb("src shell emptied before finding eumate\n");
	}

	/* Remove eumate from src shell */
	RT_LIST_DEQUEUE( &eumate->l );

	/* Add eu and eumate to dest shell */
	RT_LIST_APPEND( &dest->eu_hd, &eu->l );
	RT_LIST_APPEND( &eu->l, &eumate->l );

	eu->up.s_p = dest;
	eumate->up.s_p = dest;
}

/*
 *			N M G _ M V _ V U _ B E T W E E N _ S H E L L S
 *
 *  If this shell had a single vertexuse in it, move it to the other
 *  shell, but "promote" it to a vertex-with-self-loop along the way.
 */
void
nmg_mv_vu_between_shells( dest, src, vu )
struct shell		*dest;
register struct shell	*src;
register struct vertexuse	*vu;
{
	struct loopuse *lu;
	NMG_CK_VERTEXUSE( vu );
	NMG_CK_VERTEX( vu->v_p );

	lu = nmg_mlv( &(dest->l.magic), vu->v_p, OT_SAME );
	if (vu->v_p->vg_p) {
		NMG_CK_VERTEX_G(vu->v_p->vg_p);
		nmg_loop_g(lu->l_p);
	}
	nmg_kvu( vu );
}

a596 142
/****/

int
nmg_find_vertex_in_edgelist( v, hd )
register struct vertex	*v;
struct rt_list		*hd;
{
	register struct edgeuse	*eu;

	NMG_CK_VERTEX(v);
	for( RT_LIST_FOR( eu, edgeuse, hd ) )  {
		NMG_CK_EDGEUSE(eu);
		NMG_CK_VERTEXUSE(eu->vu_p);
		NMG_CK_VERTEX(eu->vu_p->v_p);
		if( eu->vu_p->v_p == v )  return(1);
	}
	return(0);
}

int
nmg_find_vertex_in_looplist( v, hd, singletons )
register struct vertex	*v;
struct rt_list		*hd;
int			singletons;
{
	register struct loopuse	*lu;
	long			magic1;

	NMG_CK_VERTEX(v);
	for( RT_LIST_FOR( lu, loopuse, hd ) )  {
		NMG_CK_LOOPUSE(lu);
		magic1 = RT_LIST_FIRST_MAGIC( &lu->down_hd );
		if( magic1 == NMG_VERTEXUSE_MAGIC )  {
			register struct vertexuse	*vu;
			if( !singletons )  continue;
			vu = RT_LIST_FIRST(vertexuse, &lu->down_hd );
			NMG_CK_VERTEXUSE(vu);
			NMG_CK_VERTEX(vu->v_p);
			if( vu->v_p == v )  return(1);
		} else if( magic1 == NMG_EDGEUSE_MAGIC )  {
			if( nmg_find_vertex_in_edgelist( v, &lu->down_hd ) )
				return(1);
		} else {
			rt_bomb("nmg_find_vertex_in_loopuse() bad magic\n");
		}
	}
	return(0);
}

int
nmg_find_vertex_in_facelist( v, hd )
register struct vertex	*v;
struct rt_list		*hd;
{
	register struct faceuse	*fu;

	NMG_CK_VERTEX(v);
	for( RT_LIST_FOR( fu, faceuse, hd ) )  {
		NMG_CK_FACEUSE(fu);
		if( nmg_find_vertex_in_looplist( v, &fu->lu_hd, 1 ) )
			return(1);
	}
	return(0);
}

int
nmg_find_edge_in_edgelist( e, hd )
struct edge	*e;
struct rt_list	*hd;
{
	register struct edgeuse	*eu;

	NMG_CK_EDGE(e);
	for( RT_LIST_FOR( eu, edgeuse, hd ) )  {
		NMG_CK_EDGEUSE(eu);
		NMG_CK_EDGE(eu->e_p);
		if( e == eu->e_p )  return(1);
	}
	return(0);
}

int
nmg_find_edge_in_looplist( e, hd )
struct edge	*e;
struct rt_list	*hd;
{
	register struct loopuse	*lu;
	long			magic1;

	NMG_CK_EDGE(e);
	for( RT_LIST_FOR( lu, loopuse, hd ) )  {
		NMG_CK_LOOPUSE(lu);
		magic1 = RT_LIST_FIRST_MAGIC( &lu->down_hd );
		if( magic1 == NMG_VERTEXUSE_MAGIC )  {
			/* Loop of a single vertex does not have an edge */
			continue;
		} else if( magic1 == NMG_EDGEUSE_MAGIC )  {
			if( nmg_find_edge_in_edgelist( e, &lu->down_hd ) )
				return(1);
		} else {
			rt_bomb("nmg_find_edge_in_loopuse() bad magic\n");
		}
	}
	return(0);
}

int
nmg_find_edge_in_facelist( e, hd )
struct edge	*e;
struct rt_list	*hd;
{
	register struct faceuse	*fu;

	NMG_CK_EDGE(e);
	for( RT_LIST_FOR( fu, faceuse, hd ) )  {
		NMG_CK_FACEUSE(fu);
		if( nmg_find_edge_in_looplist( e, &fu->lu_hd ) )
			return(1);
	}
	return(0);
}

int
nmg_find_loop_in_facelist( l, fu_hd )
struct loop	*l;
struct rt_list	*fu_hd;
{
	register struct faceuse	*fu;
	register struct loopuse	*lu;

	NMG_CK_LOOP(l);
	for( RT_LIST_FOR( fu, faceuse, fu_hd ) )  {
		NMG_CK_FACEUSE(fu);
		for( RT_LIST_FOR( lu, loopuse, &fu->lu_hd ) )  {
			NMG_CK_LOOPUSE(lu);
			NMG_CK_LOOP(lu->l_p);
			if( l == lu->l_p )  return(1);
		}
	}
	return(0);
}

a597 104
 *			N M G _ R M _ R E D U N D A N C I E S
 *
 *  Remove all redundant parts between the different "levels" of a shell.
 *  Remove wire loops that match face loops.
 *  Remove wire edges that match edges in wire loops or face loops.
 *  Remove lone vertices (stored as wire loops on a single vertex) that
 *  match vertices in a face loop, wire loop, or wire edge.
 */
void
nmg_rm_redundancies(s)
struct shell	*s;
{
	struct faceuse	*fu;
	struct loopuse	*lu;
	struct edgeuse	*eu;
	struct vertexuse	*vu;
	long		magic1;

	NMG_CK_SHELL(s);

	if( RT_LIST_NON_EMPTY( &s->fu_hd ) )  {
		/* Compare wire loops -vs- loops in faces */
		lu = RT_LIST_FIRST( loopuse, &s->lu_hd );
		while( RT_LIST_NOT_HEAD( lu, &s->lu_hd ) )  {
			register struct loopuse	*nextlu;
			NMG_CK_LOOPUSE(lu);
			NMG_CK_LOOP(lu->l_p);
			nextlu = RT_LIST_PNEXT( loopuse, lu );
			if( nmg_find_loop_in_facelist( lu->l_p, &s->fu_hd ) )  {
				/* Dispose of wire loop (and mate)
				 * which match face loop */
				if( nextlu == lu->lumate_p )
					nextlu = RT_LIST_PNEXT(loopuse, nextlu);
				nmg_klu( lu );
			}
			lu = nextlu;
		}

		/* Compare wire edges -vs- edges in loops in faces */
		eu = RT_LIST_FIRST( edgeuse, &s->eu_hd );
		while( RT_LIST_NOT_HEAD( eu, &s->eu_hd ) )  {
			register struct edgeuse *nexteu;
			NMG_CK_EDGEUSE(eu);
			NMG_CK_EDGE(eu->e_p);
			nexteu = RT_LIST_PNEXT( edgeuse, eu );
			if( nmg_find_edge_in_facelist( eu->e_p, &s->fu_hd ) )  {
				/* Dispose of wire edge (and mate) */
				if( nexteu == eu->eumate_p )
					nexteu = RT_LIST_PNEXT(edgeuse, nexteu);
				nmg_keu(eu);
			}
			eu = nexteu;
		}
	}

	/* Compare wire edges -vs- edges in wire loops */
	eu = RT_LIST_FIRST( edgeuse, &s->eu_hd );
	while( RT_LIST_NOT_HEAD( eu, &s->eu_hd ) )  {
		register struct edgeuse *nexteu;
		NMG_CK_EDGEUSE(eu);
		NMG_CK_EDGE(eu->e_p);
		nexteu = RT_LIST_PNEXT( edgeuse, eu );
		if( nmg_find_edge_in_looplist( eu->e_p, &s->lu_hd ) )  {
			/* Kill edge use and mate */
			if( nexteu == eu->eumate_p )
				nexteu = RT_LIST_PNEXT(edgeuse, nexteu);
			nmg_keu(eu);
		}
		eu = nexteu;
	}

	/* Compare lone vertices against everything else */
	/* Individual vertices are stored as wire loops on a single vertex */
	lu = RT_LIST_FIRST( loopuse, &s->lu_hd );
	while( RT_LIST_NOT_HEAD( lu, &s->lu_hd ) )  {
		register struct loopuse	*nextlu;
		NMG_CK_LOOPUSE(lu);
		nextlu = RT_LIST_PNEXT( loopuse, lu );
		magic1 = RT_LIST_FIRST_MAGIC( &lu->down_hd );
		if( magic1 != NMG_VERTEXUSE_MAGIC )  {
			lu = nextlu;
			continue;
		}
		vu = RT_LIST_PNEXT( vertexuse, &lu->down_hd );
		NMG_CK_VERTEXUSE(vu);
		NMG_CK_VERTEX(vu->v_p);
		if( nmg_find_vertex_in_facelist( vu->v_p, &s->fu_hd ) ||
		    nmg_find_vertex_in_looplist( vu->v_p, &s->lu_hd,0 ) ||
		    nmg_find_vertex_in_edgelist( vu->v_p, &s->eu_hd ) )  {
		    	/* Kill lu and mate */
			if( nextlu == lu->lumate_p )
				nextlu = RT_LIST_PNEXT(loopuse, nextlu);
			nmg_klu( lu );
			lu = nextlu;
			continue;
		}
		lu = nextlu;
	}

	/* There really shouldn't be a lone vertex by now */
	if( s->vu_p )  rt_log("nmg_rm_redundancies() lone vertex?\n");
}

/*
d623 1
a623 1
		sprintf(fname, "/tmp/nmg_eval%d.pl", num);
@


10.7
log
@Added nmg_class_name().
Made action tables & string tables CONST.
@
text
@d1 1
d21 1
a21 1
static char RCSnmg_eval[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 10.6 93/01/20 20:22:56 mike Exp Locker: mike $ (BRL)";
d466 4
d498 3
d532 3
d571 3
d611 3
d699 3
d725 3
d988 1
a988 2
				if( RT_LIST_NOT_HEAD(lu, &lu->down_hd) &&
				    nextlu == lu->lumate_p )
d1047 1
a1047 2
			if( RT_LIST_NOT_HEAD(lu, &lu->down_hd) &&
			    nextlu == lu->lumate_p )
d1053 1
d1064 2
@


10.6
log
@When demoting a lu, if demotion fails, just kill the single vu loop.
@
text
@d20 1
a20 1
static char RCSnmg_eval[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 10.5 93/01/20 20:02:22 mike Exp Locker: mike $ (BRL)";
d45 1
d267 1
a267 1
static char	*nmg_baction_names[] = {
d276 1
a276 1
static char	*nmg_class_names[] = {
d285 1
a285 1
	"*BAD*"
d289 19
a307 1
 * Actions are listed:
d311 1
a311 1
static int		subtraction_actions[8] = {
d323 1
a323 1
static int		union_actions[8] = {
d335 1
a335 1
static int		intersect_actions[8] = {
@


10.5
log
@nmg_demote_lu() returns 1 when it can't demote, because the lu
is a loop of a single vertex, not a loop of edges.
This is not an error.
Added checking for bad BACTION values, not that they are likely.
Fixed bug where a non-demoted lu was not counted towards retained loops.
@
text
@d20 1
a20 1
static char RCSnmg_eval[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 10.4 92/07/20 23:06:17 butler Exp Locker: mike $ (BRL)";
d468 1
a468 1
				if( nmg_demote_lu( lu ) == 0 )
d470 4
a473 2
				else
					loops_retained++; /* loop of single vertex */
@


10.4
log
@changed nmg_mv_vu_between_shells to create geometry for loop created
@
text
@d20 1
a20 1
static char RCSnmg_eval[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 10.3 92/06/05 14:52:20 mike Exp Locker: butler $ (BRL)";
d468 4
a471 3
				if( nmg_demote_lu( lu ) )
					rt_log("nmg_eval_shell() nmg_demote_lu(x%x) fail\n", lu);
				nmg_eval_plot( bs, nmg_eval_count++, 1 );	/* debug */
d480 2
d502 1
a502 1
			nmg_kfu( fu );		/* kill face & mate */
d518 1
d523 1
d561 2
a562 3
			if( nmg_demote_lu( lu ) )
				rt_log("nmg_eval_shell() nmg_demote_lu(x%x) fail\n", lu);
			nmg_eval_plot( bs, nmg_eval_count++, 1 );	/* debug */
d571 2
d606 2
d656 2
d671 1
a671 1
	nmg_eval_plot( bs, nmg_eval_count++, 0 );	/* debug */
d680 2
@


10.3
log
@Added parameter to nmg_vlblock_anim_upcall (mged_vlblock_anim_upcall_handler)
to indicate don't copy vlist, steal them, which matches current usage.
@
text
@d20 1
a20 1
static char RCSnmg_eval[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 10.2 92/03/06 05:47:41 mike Exp Locker: mike $ (BRL)";
d250 1
a250 1

d254 5
a258 1
	(void)nmg_mlv( &(dest->l.magic), vu->v_p, OT_SAME );
@


10.2
log
@More care was needed in computing "nexteu" when demoting edgeuses.
@
text
@d20 1
a20 1
static char RCSnmg_eval[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 10.1 91/10/12 06:40:43 mike Rel4_0 Locker: mike $ (BRL)";
d1051 2
a1052 1
				(rt_g.NMG_debug&DEBUG_PL_SLOW) ? 250000 : 0 );
@


10.1
log
@Release_4.0
@
text
@d20 1
a20 1
static char RCSnmg_eval[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 1.45 91/06/29 22:14:01 mike Exp $ (BRL)";
d466 1
a466 1
	nmg_eval_plot( bs, nmg_eval_count++, 1 );	/* debug */
d496 1
a496 1
	nmg_eval_plot( bs, nmg_eval_count++, 1 );	/* debug */
d554 1
a554 1
	nmg_eval_plot( bs, nmg_eval_count++, 1 );	/* debug */
d573 1
a573 1
		nexteu = RT_LIST_PNEXT( edgeuse, eu );
d576 1
d581 1
a581 2
			if( RT_LIST_NOT_HEAD(eu, &s->eu_hd) &&
			    nexteu == eu->eumate_p )
d585 1
a585 1
	nmg_eval_plot( bs, nmg_eval_count++, 1 );	/* debug */
d591 1
a591 2
			if( RT_LIST_NOT_HEAD(eu, &s->eu_hd) &&
			    nexteu == eu->eumate_p )
d945 1
a945 2
				if( RT_LIST_NOT_HEAD(eu, &s->eu_hd) &&
				    nexteu == eu->eumate_p )
d962 1
a962 2
			if( RT_LIST_NOT_HEAD(eu, &s->eu_hd) &&
			    nexteu == eu->eumate_p )
@


1.45
log
@ANSI lint
@
text
@d20 1
a20 1
static char RCSnmg_eval[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 1.44 91/06/17 20:42:01 butler Exp $ (BRL)";
@


1.44
log
@changed function declarations so that all global functions have their
"nmg_" at the begining of the line.  Static functions have their function
names on the same line as the "static" modifier.
@
text
@d20 1
a20 1
static char RCSnmg_eval[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 1.43 91/05/25 03:31:15 mike Exp $ (BRL)";
d32 13
a323 8
struct nmg_bool_state  {
	struct shell	*bs_dest;
	struct shell	*bs_src;
	int		bs_isA;		/* true if A, else doing B */
	long		**bs_classtab;
	int		*bs_actions;
};

d424 1
a424 1
void
d1009 1
a1009 1
void
@


1.43
log
@Added DEBUG_PL_SLOW bit
@
text
@d20 1
a20 1
static char RCSnmg_eval[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 1.42 91/03/02 00:17:56 mike Exp $ (BRL)";
d419 1
d799 1
d815 1
d831 1
d856 1
d872 1
d901 1
d1004 1
@


1.42
log
@All the plotting routines changed to using flags arrays
instead of nmg_ptbl structures.
@
text
@d20 1
a20 1
static char RCSnmg_eval[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 1.41 91/03/01 22:40:52 mike Exp $ (BRL)";
a1038 1
#if 0
d1041 1
a1041 5
				delay ? 250000 : 0 );
#else
			/* Go full speed */
			(*nmg_vlblock_anim_upcall)( vbp, 0 );
#endif
@


1.41
log
@Converted classification routines from nmg_ptbl to index array strategy.
@
text
@d20 1
a20 1
static char RCSnmg_eval[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 1.40 91/02/08 02:49:35 mike Exp $ (BRL)";
a1004 1
	struct nmg_ptbl b;
a1014 3
		/* get space for list of items processed */
		(void)nmg_tbl(&b, TBL_INIT, (long *)0);	

a1025 2

		(void)nmg_tbl(&b, TBL_FREE, (long *)NULL);
a1031 2
		/* get space for list of items processed */
		(void)nmg_tbl(&b, TBL_INIT, (long *)0);	
a1035 2

		(void)nmg_tbl(&b, TBL_FREE, (long *)NULL);
@


1.40
log
@nmg_identify_magic to rt_identify_magic
@
text
@d20 1
a20 1
static char RCSnmg_eval[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 1.39 91/02/07 20:32:34 mike Exp $ (BRL)";
d315 1
a315 1
	struct nmg_ptbl	*bs_classtab;
d333 1
a333 1
nmg_evaluate_boolean( sA, sB, op, class_table )
d337 1
a337 1
struct nmg_ptbl class_table[];
a347 5
		for( i=0; i<8; i++ )  {
			rt_log("	%6d %s\n",
				class_table[i].end,
				nmg_class_names[i] );
		}
a365 4
	/* Reindex structures before starting evaluation. */
	/* XXX this should be done before starting classification! */
	nmg_m_reindex( sA->r_p->m_p );

d368 1
a368 1
	bool_state.bs_classtab = class_table;
d681 1
d683 1
d685 1
a685 1
		if( nmg_tbl( &bs->bs_classtab[NMG_CLASS_AinB], TBL_LOC, ptr ) >= 0 )  {
d690 1
a690 1
		if( nmg_tbl( &bs->bs_classtab[NMG_CLASS_AonBshared], TBL_LOC, ptr ) >= 0 )  {
d695 1
a695 1
		if( nmg_tbl( &bs->bs_classtab[NMG_CLASS_AonBanti], TBL_LOC, ptr ) >= 0 )  {
d700 1
a700 1
		if( nmg_tbl( &bs->bs_classtab[NMG_CLASS_AoutB], TBL_LOC, ptr ) >= 0 )  {
d713 1
a713 1
	if( nmg_tbl( &bs->bs_classtab[NMG_CLASS_BinA], TBL_LOC, ptr ) >= 0 )  {
d718 1
a718 1
	if( nmg_tbl( &bs->bs_classtab[NMG_CLASS_BonAshared], TBL_LOC, ptr ) >= 0 )  {
d723 1
a723 1
	if( nmg_tbl( &bs->bs_classtab[NMG_CLASS_BonAanti], TBL_LOC, ptr ) >= 0 )  {
d728 1
a728 1
	if( nmg_tbl( &bs->bs_classtab[NMG_CLASS_BoutA], TBL_LOC, ptr ) >= 0 )  {
d739 3
a741 2
		rt_log("nmg_eval_action(ptr=x%x) %s %s %s %s\n",
			ptr, bs->bs_isA ? "A" : "B",
d751 1
d768 1
@


1.39
log
@Changed from NMG_LIST macros to RT_LIST macros, from rtlist.h
@
text
@d20 1
a20 1
static char RCSnmg_eval[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 1.38 91/02/06 17:22:37 mike Exp $ (BRL)";
d713 1
a713 1
			ptr, nmg_identify_magic( *((long *)ptr) ) );
d741 1
a741 1
		ptr, nmg_identify_magic( *((long *)ptr) ) );
d748 1
a748 1
			nmg_identify_magic( *((long *)ptr) ),
@


1.38
log
@Moved index routines to nmg_index.c
@
text
@d20 1
a20 1
static char RCSnmg_eval[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 1.37 91/01/28 23:52:59 mike Exp $ (BRL)";
d111 2
a112 2
	NMG_LIST_DEQUEUE( &fu->l );
	if( NMG_LIST_IS_EMPTY( &src->fu_hd ) )  {
d120 1
a120 1
	NMG_LIST_DEQUEUE( &fumate->l );
d123 2
a124 2
	NMG_LIST_APPEND( &dest->fu_hd, &fu->l );
	NMG_LIST_APPEND( &fu->l, &fumate->l );
d160 2
a161 2
	NMG_LIST_DEQUEUE( &lu->l );
	if( NMG_LIST_IS_EMPTY( &src->lu_hd ) )  {
d169 1
a169 1
	NMG_LIST_DEQUEUE( &lumate->l );
d172 2
a173 2
	NMG_LIST_APPEND( &dest->lu_hd, &lu->l );
	NMG_LIST_APPEND( &lu->l, &lumate->l );
d206 2
a207 2
	NMG_LIST_DEQUEUE( &eu->l );
	if( NMG_LIST_IS_EMPTY( &src->eu_hd ) )  {
d215 1
a215 1
	NMG_LIST_DEQUEUE( &eumate->l );
d218 2
a219 2
	NMG_LIST_APPEND( &dest->eu_hd, &eu->l );
	NMG_LIST_APPEND( &eu->l, &eumate->l );
d399 1
a399 1
	if( NMG_LIST_NON_EMPTY( &sB->fu_hd ) )  {
d402 1
a402 1
	if( NMG_LIST_NON_EMPTY( &sB->lu_hd ) )  {
d405 1
a405 1
	if( NMG_LIST_NON_EMPTY( &sB->eu_hd ) )  {
d450 3
a452 3
	fu = NMG_LIST_FIRST( faceuse, &s->fu_hd );
	while( NMG_LIST_MORE( fu, faceuse, &s->fu_hd ) )  {
		nextfu = NMG_LIST_PNEXT( faceuse, fu );
d458 3
a460 3
		lu = NMG_LIST_FIRST( loopuse, &fu->lu_hd );
		while( NMG_LIST_MORE( lu, loopuse, &fu->lu_hd ) )  {
			nextlu = NMG_LIST_PNEXT( loopuse, lu );
d491 1
a491 1
		if( NMG_LIST_IS_EMPTY( &fu->lu_hd ) )  {
d495 1
a495 1
			if( NMG_LIST_MORE(fu, faceuse, &s->fu_hd) &&
d497 1
a497 1
				nextfu = NMG_LIST_PNEXT(faceuse, nextfu);
d524 1
a524 1
			if( NMG_LIST_MORE(fu, faceuse, &s->fu_hd) &&
d526 1
a526 1
				nextfu = NMG_LIST_PNEXT(faceuse, nextfu);
d540 3
a542 3
	lu = NMG_LIST_FIRST( loopuse, &s->lu_hd );
	while( NMG_LIST_MORE( lu, loopuse, &s->lu_hd ) )  {
		nextlu = NMG_LIST_PNEXT( loopuse, lu );
d545 1
a545 1
		if( NMG_LIST_FIRST_MAGIC( &lu->down_hd ) == NMG_VERTEXUSE_MAGIC )  {
d574 3
a576 3
	eu = NMG_LIST_FIRST( edgeuse, &s->eu_hd );
	while( NMG_LIST_MORE( eu, edgeuse, &s->eu_hd ) )  {
		nexteu = NMG_LIST_PNEXT( edgeuse, eu );
d583 1
a583 1
			if( NMG_LIST_MORE(eu, edgeuse, &s->eu_hd) &&
d585 1
a585 1
				nexteu = NMG_LIST_PNEXT(edgeuse, nexteu);
d594 1
a594 1
			if( NMG_LIST_MORE(eu, edgeuse, &s->eu_hd) &&
d596 1
a596 1
				nexteu = NMG_LIST_PNEXT(edgeuse, nexteu);
d617 3
a619 3
	lu = NMG_LIST_FIRST( loopuse, &s->lu_hd );
	while( NMG_LIST_MORE( lu, loopuse, &s->lu_hd ) )  {
		nextlu = NMG_LIST_PNEXT( loopuse, lu );
d622 1
a622 1
		if( NMG_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_VERTEXUSE_MAGIC )  {
d627 1
a627 1
		vu = NMG_LIST_PNEXT( vertexuse, &lu->down_hd );
d633 1
a633 1
			if( NMG_LIST_MORE(lu, loopuse, &lu->down_hd) &&
d635 1
a635 1
				nextlu = NMG_LIST_PNEXT(loopuse, nextlu);
d642 1
a642 1
			if( NMG_LIST_MORE(lu, loopuse, &lu->down_hd) &&
d644 1
a644 1
				nextlu = NMG_LIST_PNEXT(loopuse, nextlu);
d759 1
a759 1
struct nmg_list		*hd;
d764 1
a764 1
	for( NMG_LIST( eu, edgeuse, hd ) )  {
d775 1
a775 1
struct nmg_list		*hd;
d782 1
a782 1
	for( NMG_LIST( lu, loopuse, hd ) )  {
d784 1
a784 1
		magic1 = NMG_LIST_FIRST_MAGIC( &lu->down_hd );
d788 1
a788 1
			vu = NMG_LIST_FIRST(vertexuse, &lu->down_hd );
d804 1
a804 1
struct nmg_list		*hd;
d809 1
a809 1
	for( NMG_LIST( fu, faceuse, hd ) )  {
d819 1
a819 1
struct nmg_list	*hd;
d824 1
a824 1
	for( NMG_LIST( eu, edgeuse, hd ) )  {
d834 1
a834 1
struct nmg_list	*hd;
d840 1
a840 1
	for( NMG_LIST( lu, loopuse, hd ) )  {
d842 1
a842 1
		magic1 = NMG_LIST_FIRST_MAGIC( &lu->down_hd );
d858 1
a858 1
struct nmg_list	*hd;
d863 1
a863 1
	for( NMG_LIST( fu, faceuse, hd ) )  {
d873 1
a873 1
struct nmg_list	*fu_hd;
d879 1
a879 1
	for( NMG_LIST( fu, faceuse, fu_hd ) )  {
d881 1
a881 1
		for( NMG_LIST( lu, loopuse, &fu->lu_hd ) )  {
d910 1
a910 1
	if( NMG_LIST_NON_EMPTY( &s->fu_hd ) )  {
d912 2
a913 2
		lu = NMG_LIST_FIRST( loopuse, &s->lu_hd );
		while( NMG_LIST_MORE( lu, loopuse, &s->lu_hd ) )  {
d917 1
a917 1
			nextlu = NMG_LIST_PNEXT( loopuse, lu );
d921 1
a921 1
				if( NMG_LIST_MORE(lu, loopuse, &lu->down_hd) &&
d923 1
a923 1
					nextlu = NMG_LIST_PNEXT(loopuse, nextlu);
d930 2
a931 2
		eu = NMG_LIST_FIRST( edgeuse, &s->eu_hd );
		while( NMG_LIST_MORE( eu, edgeuse, &s->eu_hd ) )  {
d935 1
a935 1
			nexteu = NMG_LIST_PNEXT( edgeuse, eu );
d938 1
a938 1
				if( NMG_LIST_MORE(eu, edgeuse, &s->eu_hd) &&
d940 1
a940 1
					nexteu = NMG_LIST_PNEXT(edgeuse, nexteu);
d948 2
a949 2
	eu = NMG_LIST_FIRST( edgeuse, &s->eu_hd );
	while( NMG_LIST_MORE( eu, edgeuse, &s->eu_hd ) )  {
d953 1
a953 1
		nexteu = NMG_LIST_PNEXT( edgeuse, eu );
d956 1
a956 1
			if( NMG_LIST_MORE(eu, edgeuse, &s->eu_hd) &&
d958 1
a958 1
				nexteu = NMG_LIST_PNEXT(edgeuse, nexteu);
d966 2
a967 2
	lu = NMG_LIST_FIRST( loopuse, &s->lu_hd );
	while( NMG_LIST_MORE( lu, loopuse, &s->lu_hd ) )  {
d970 2
a971 2
		nextlu = NMG_LIST_PNEXT( loopuse, lu );
		magic1 = NMG_LIST_FIRST_MAGIC( &lu->down_hd );
d976 1
a976 1
		vu = NMG_LIST_PNEXT( vertexuse, &lu->down_hd );
d983 1
a983 1
			if( NMG_LIST_MORE(lu, loopuse, &lu->down_hd) &&
d985 1
a985 1
				nextlu = NMG_LIST_PNEXT(loopuse, nextlu);
@


1.37
log
@Converted to new struct rt_vlist (''chunky vlist'')
@
text
@d1 2
a2 1
/*			N M G _ E V A L . C
d20 1
a20 1
static char RCSnmg_eval[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 1.36 91/01/12 07:20:59 mike Exp $ (BRL)";
d28 1
a31 16
extern void	nmg_m_reindex();

struct nmg_counter {
	long	max_structs;
	long	regions;
	long	shells;
	long	faces;
	long	face_loops;
	long	face_edges;
	long	face_lone_verts;
	long	wire_loops;
	long	wire_loop_edges;
	long	wire_edges;
	long	lone_verts;
};

a343 1
	struct nmg_counter	counter;
a416 6

#if 0
	bzero( (char *)&counter, sizeof(counter) );
	nmg_m_count( &counter, sA->r_p->m_p );
	nmg_pr_count( &counter, "after nmg_rm_redundancies()" );
#endif
a995 77
/*****/

nmg_pr_count( ctr, str )
struct nmg_counter	*ctr;
char			*str;
{
	rt_log("nmg_pr_count(%s)\n", str);
	rt_log("\t%6d max_structs\n", ctr->max_structs);
	rt_log("\t%6d regions\n", ctr->regions);
	rt_log("\t%6d shells\n", ctr->shells);
	rt_log("\t%6d faces\n", ctr->faces);
	rt_log("\t%6d face_loops\n", ctr->face_loops);
	rt_log("\t%6d face_edges\n", ctr->face_edges);
	rt_log("\t%6d face_lone_verts\n", ctr->face_lone_verts);
	rt_log("\t%6d wire_loops\n", ctr->wire_loops);
	rt_log("\t%6d wire_loop_edges\n", ctr->wire_loop_edges);
	rt_log("\t%6d wire_edges\n", ctr->wire_edges);
	rt_log("\t%6d lone_verts\n", ctr->lone_verts);
}

nmg_m_count( ctr, m )
struct model		*m;
struct nmg_counter	*ctr;
{
	struct nmgregion	*r;
	struct shell		*s;
	struct faceuse		*fu;
	struct loopuse		*lu;
	struct edgeuse		*eu;

	NMG_CK_MODEL(m);
	ctr->max_structs = m->maxindex;
	for( NMG_LIST( r, nmgregion, &m->r_hd ) )  {
		NMG_CK_REGION(r);
		ctr->regions++;
		for( NMG_LIST( s, shell, &r->s_hd ) )  {
			NMG_CK_SHELL(s);
			ctr->shells++;
			/* Faces in shell */
			for( NMG_LIST( fu, faceuse, &s->fu_hd ) )  {
				NMG_CK_FACEUSE(fu);
				ctr->faces++;
				for( NMG_LIST( lu, loopuse, &fu->lu_hd ) )  {
					NMG_CK_LOOPUSE(lu);
					if( NMG_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC )  {
						ctr->face_lone_verts++;
						continue;
					}
					ctr->face_loops++;
					for( NMG_LIST( eu, edgeuse, &lu->down_hd ) )  {
						NMG_CK_EDGEUSE(eu);
						ctr->face_edges++;
					}
				}
			}
			/* Wire loops in shell */
			for( NMG_LIST( lu, loopuse, &s->lu_hd ) )  {
				NMG_CK_LOOPUSE(lu);
				if( NMG_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC )  {
					ctr->lone_verts++;
					continue;
				}
				ctr->wire_loops++;
				for( NMG_LIST( eu, edgeuse, &lu->down_hd ) )  {
					NMG_CK_EDGEUSE(eu);
					ctr->wire_loop_edges++;
				}
			}
			/* Wire edges in shell */
			for( NMG_LIST( eu, edgeuse, &s->eu_hd ) )  {
				NMG_CK_EDGEUSE(eu);
				ctr->wire_edges++;
			}
		}
	}
}

a1065 190
}

#define NMG_HIGH_BIT	0x80000000

/*
 *			N M G _ M _ R E I N D E X
 *
 *  Reassign index numbers to all the data structures in a model.
 *  The model structure will get index 0, all others will be sequentially
 *  assigned after that.
 */
void
nmg_m_reindex( m )
struct model	*m;
{
	struct nmgregion	*r;
	struct shell		*s;
	struct faceuse		*fu;
	struct loopuse		*lu;
	register struct edgeuse		*eu;
	register struct vertexuse	*vu;
	register int		newindex;

	NMG_CK_MODEL(m);
	if( m->index != 0 )  rt_log("nmg_m_reindex() m->index=%d\n", m->index);

	/* First pass:  just set the high bit on all index words */
	for( NMG_LIST( r, nmgregion, &m->r_hd ) )  {
		NMG_CK_REGION(r);
		r->index |= NMG_HIGH_BIT;
		for( NMG_LIST( s, shell, &r->s_hd ) )  {
			NMG_CK_SHELL(s);
			s->index |= NMG_HIGH_BIT;
			/* Faces in shell */
			for( NMG_LIST( fu, faceuse, &s->fu_hd ) )  {
				NMG_CK_FACEUSE(fu);
				fu->index |= NMG_HIGH_BIT;
				fu->f_p->index |= NMG_HIGH_BIT;
				/* Loops in face */
				for( NMG_LIST( lu, loopuse, &fu->lu_hd ) )  {
					NMG_CK_LOOPUSE(lu);
					lu->index |= NMG_HIGH_BIT;
					lu->l_p->index |= NMG_HIGH_BIT;
					if( NMG_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC )  {
						/* Loop of Lone vertex */
						vu = NMG_LIST_FIRST( vertexuse, &lu->down_hd );
						NMG_CK_VERTEXUSE(vu);
						vu->index |= NMG_HIGH_BIT;
						vu->v_p->index |= NMG_HIGH_BIT;
						continue;
					}
					for( NMG_LIST( eu, edgeuse, &lu->down_hd ) )  {
						NMG_CK_EDGEUSE(eu);
						eu->index |= NMG_HIGH_BIT;
						eu->e_p->index |= NMG_HIGH_BIT;
						vu = eu->vu_p;
						NMG_CK_VERTEXUSE(vu);
						vu->index |= NMG_HIGH_BIT;
						vu->v_p->index |= NMG_HIGH_BIT;
					}
				}
			}
			/* Wire loops in shell */
			for( NMG_LIST( lu, loopuse, &s->lu_hd ) )  {
				NMG_CK_LOOPUSE(lu);
				lu->index |= NMG_HIGH_BIT;
				lu->l_p->index |= NMG_HIGH_BIT;
				if( NMG_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC )  {
					/* Wire loop of Lone vertex */
					vu = NMG_LIST_FIRST( vertexuse, &lu->down_hd );
					NMG_CK_VERTEXUSE(vu);
					vu->index |= NMG_HIGH_BIT;
					vu->v_p->index |= NMG_HIGH_BIT;
					continue;
				}
				for( NMG_LIST( eu, edgeuse, &lu->down_hd ) )  {
					NMG_CK_EDGEUSE(eu);
					eu->index |= NMG_HIGH_BIT;
					eu->e_p->index |= NMG_HIGH_BIT;
					vu = eu->vu_p;
					NMG_CK_VERTEXUSE(vu);
					vu->index |= NMG_HIGH_BIT;
					vu->v_p->index |= NMG_HIGH_BIT;
				}
			}
			/* Wire edges in shell */
			for( NMG_LIST( eu, edgeuse, &s->eu_hd ) )  {
				NMG_CK_EDGEUSE(eu);
				eu->index |= NMG_HIGH_BIT;
				eu->e_p->index |= NMG_HIGH_BIT;
				vu = eu->vu_p;
				NMG_CK_VERTEXUSE(vu);
				vu->index |= NMG_HIGH_BIT;
				vu->v_p->index |= NMG_HIGH_BIT;
			}
			/* Lone vertex in shell */
			if( vu = s->vu_p )  {
				NMG_CK_VERTEXUSE(vu);
				vu->index |= NMG_HIGH_BIT;
				vu->v_p->index |= NMG_HIGH_BIT;
			}
		}
	}

#define	NMG_ASSIGN_NEW_INDEX(_p)	\
	{ if( ((_p)->index & NMG_HIGH_BIT) != 0 ) \
		(_p)->index = newindex++; }

	/* Second pass:  assign new index number */
	newindex = 1;	/* model remains index 0 */
	for( NMG_LIST( r, nmgregion, &m->r_hd ) )  {
		NMG_CK_REGION(r);
		NMG_ASSIGN_NEW_INDEX(r);
		for( NMG_LIST( s, shell, &r->s_hd ) )  {
			NMG_CK_SHELL(s);
			NMG_ASSIGN_NEW_INDEX(s);
			/* Faces in shell */
			for( NMG_LIST( fu, faceuse, &s->fu_hd ) )  {
				NMG_CK_FACEUSE(fu);
				NMG_ASSIGN_NEW_INDEX(fu);
				NMG_ASSIGN_NEW_INDEX(fu->f_p);
				/* Loops in face */
				for( NMG_LIST( lu, loopuse, &fu->lu_hd ) )  {
					NMG_CK_LOOPUSE(lu);
					NMG_ASSIGN_NEW_INDEX(lu);
					NMG_ASSIGN_NEW_INDEX(lu->l_p);
					if( NMG_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC )  {
						/* Loop of Lone vertex */
						vu = NMG_LIST_FIRST( vertexuse, &lu->down_hd );
						NMG_CK_VERTEXUSE(vu);
						NMG_ASSIGN_NEW_INDEX(vu);
						NMG_ASSIGN_NEW_INDEX(vu->v_p);
						continue;
					}
					for( NMG_LIST( eu, edgeuse, &lu->down_hd ) )  {
						NMG_CK_EDGEUSE(eu);
						NMG_ASSIGN_NEW_INDEX(eu);
						NMG_ASSIGN_NEW_INDEX(eu->e_p);
						vu = eu->vu_p;
						NMG_CK_VERTEXUSE(vu);
						NMG_ASSIGN_NEW_INDEX(vu);
						NMG_ASSIGN_NEW_INDEX(vu->v_p);
					}
				}
			}
			/* Wire loops in shell */
			for( NMG_LIST( lu, loopuse, &s->lu_hd ) )  {
				NMG_CK_LOOPUSE(lu);
				NMG_ASSIGN_NEW_INDEX(lu);
				NMG_ASSIGN_NEW_INDEX(lu->l_p);
				if( NMG_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC )  {
					/* Wire loop of Lone vertex */
					vu = NMG_LIST_FIRST( vertexuse, &lu->down_hd );
					NMG_CK_VERTEXUSE(vu);
					NMG_ASSIGN_NEW_INDEX(vu);
					NMG_ASSIGN_NEW_INDEX(vu->v_p);
					continue;
				}
				for( NMG_LIST( eu, edgeuse, &lu->down_hd ) )  {
					NMG_CK_EDGEUSE(eu);
					NMG_ASSIGN_NEW_INDEX(eu);
					NMG_ASSIGN_NEW_INDEX(eu->e_p);
					vu = eu->vu_p;
					NMG_CK_VERTEXUSE(vu);
					NMG_ASSIGN_NEW_INDEX(vu);
					NMG_ASSIGN_NEW_INDEX(vu->v_p);
				}
			}
			/* Wire edges in shell */
			for( NMG_LIST( eu, edgeuse, &s->eu_hd ) )  {
				NMG_CK_EDGEUSE(eu);
				NMG_ASSIGN_NEW_INDEX(eu);
				NMG_ASSIGN_NEW_INDEX(eu->e_p);
				vu = eu->vu_p;
				NMG_CK_VERTEXUSE(vu);
				NMG_ASSIGN_NEW_INDEX(vu);
				NMG_ASSIGN_NEW_INDEX(vu->v_p);
			}
			/* Lone vertex in shell */
			if( vu = s->vu_p )  {
				NMG_CK_VERTEXUSE(vu);
				NMG_ASSIGN_NEW_INDEX(vu);
				NMG_ASSIGN_NEW_INDEX(vu->v_p);
			}
		}
	}
#if 0
rt_log("nmg_m_reindex() oldmax=%d, newmax=%d\n", m->maxindex, newindex );
#endif
	m->maxindex = newindex;
@


1.36
log
@lint
@
text
@d19 1
a19 1
static char RCSnmg_eval[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 1.35 90/12/08 02:55:04 mike Exp $ (BRL)";
d1121 1
a1121 1
		sprintf(fname, "/tmp/eval%d.pl", num);
d1138 1
a1138 1
		struct vlblock *vbp;
@


1.35
log
@lint
@
text
@d19 1
a19 1
static char RCSnmg_eval[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 1.34 90/06/05 01:09:37 mike Exp $ (BRL)";
d403 1
a403 1
		FILE *fp, *fopen();
d706 1
a706 1
genptr_t			ptr;
@


1.34
log
@Turned off diagnostic printing
@
text
@d19 1
a19 1
static char RCSnmg_eval[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 1.33 90/06/05 01:02:09 mike Exp $ (BRL)";
d381 1
@


1.33
log
@Added nmg_m_reindex()
@
text
@d19 1
a19 1
static char RCSnmg_eval[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 1.32 90/05/25 18:52:18 mike Exp $ (BRL)";
d432 1
a432 1
#if 1
d700 1
a700 2
 *  (XXX In the future, this should be done with 1 tagged list
 *   XXX which is sorted, for binary search).
d1349 1
d1351 1
@


1.32
log
@Added "fancy" flag to vlblock drawing routines.
When fancy is set, all the uses are drawn, as before.
When fancy is zero, only the edges and vertices are drawn;
this is *much* faster, and for the boolean evaluation stage,
easier to understand (although less pretty).
@
text
@d19 1
a19 1
static char RCSnmg_eval[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 1.31 90/05/24 23:23:37 mike Exp $ (BRL)";
d30 2
d385 4
a428 6
#if 0
	bzero( (char *)&counter, sizeof(counter) );
	nmg_m_count( &counter, sA->r_p->m_p );
	nmg_pr_count( &counter, "near end of nmg_evaluate_boolean()");
#endif

d439 1
a439 1
static int	nmg_eval_count = 0;
d1164 188
@


1.31
log
@GET_xxx() macros now require struct model pointers.
Added index numbers to all structs.
@
text
@d19 1
a19 1
static char RCSnmg_eval[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 1.30 90/05/24 03:55:57 mike Exp $ (BRL)";
d1144 2
a1145 2
		nmg_vlblock_s( vbp, bs->bs_dest );
		nmg_vlblock_s( vbp, bs->bs_src );
@


1.30
log
@Modified to produce plot animations using vlblock's,
rather than UNIX_plot files.
@
text
@d19 1
a19 1
static char RCSnmg_eval[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 1.29 90/05/23 18:47:45 mike Exp $ (BRL)";
d31 1
d1024 1
d1048 1
@


1.29
log
@nmg_rm_redundancies() now starting to work.
@
text
@d19 1
a19 1
static char RCSnmg_eval[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 1.28 90/05/23 12:15:56 mike Exp $ (BRL)";
a29 2
void		(*nmg_plot_anim_upcall)();	/* For I/F with MGED */

d1091 5
d1114 3
a1116 2
	/* get space for list of items processed */
	(void)nmg_tbl(&b, TBL_INIT, (long *)0);	
d1118 13
a1130 4
	sprintf(fname, "/tmp/eval%d.pl", num);
	if( (fp = fopen(fname,"w")) == NULL )  {
		perror(fname);
		return;
a1131 1
	rt_log("Plotting %s\n", fname);
d1133 3
a1135 2
	nmg_pl_s( fp, bs->bs_dest );
	nmg_pl_s( fp, bs->bs_src );
d1137 3
a1139 1
	fclose(fp);
d1141 2
a1142 1
	(void)nmg_tbl(&b, TBL_FREE, (long *)NULL);
d1144 2
a1145 1
	if( do_anim )  {
d1147 2
a1148 1
		if( nmg_plot_anim_upcall )  {
d1150 1
a1150 1
			(*nmg_plot_anim_upcall)( fname,
d1152 4
d1157 1
a1157 1
			rt_log("null nmg_plot_anim_upcall, no animation\n");
d1159 1
a1159 6
		if( !do_plot )  {
			/* Plot was just for animation, delete it to
			 * save on disk space
			 */
			(void)unlink(fname);
		}
@


1.28
log
@Revised to use more generall upcall interface to mged for plot animations.
@
text
@d19 1
a19 1
static char RCSnmg_eval[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 1.27 90/05/23 00:48:28 mike Exp $ (BRL)";
d424 1
d428 1
a429 1
#if 0
d432 5
d893 1
a893 1
nmg_find_loop_in_facelist( l, hd )
d895 1
a895 1
struct nmg_list	*hd;
d897 1
d901 7
a907 4
	for( NMG_LIST( lu, loopuse, hd ) )  {
		NMG_CK_LOOPUSE(lu);
		NMG_CK_LOOP(lu->l_p);
		if( l == lu->l_p )  return(1);
d937 2
d941 5
a945 1
				/* Dispose of wire loop which matches face loop */
d955 2
d959 4
a962 1
				/* Dispose of wire edge */
d973 2
a975 1

d977 4
d991 1
a992 2

		NMG_CK_LOOPUSE(lu);
d1004 4
@


1.27
log
@Added routine to count number of different things found in a model.
It's still tentative at this point.

Also added **really neat** ability to animate the boolean
evaluation operations within MGED!
@
text
@d19 1
a19 1
static char RCSnmg_eval[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 1.26 90/05/22 01:38:07 mike Exp $ (BRL)";
d30 2
a526 1
	nmg_eval_plot( bs, nmg_eval_count++, 1 );	/* debug */
a542 1
	nmg_eval_plot( bs, nmg_eval_count++, 1 );	/* debug */
a578 1
	nmg_eval_plot( bs, nmg_eval_count++, 1 );	/* debug */
a612 1
	nmg_eval_plot( bs, nmg_eval_count++, 1 );	/* debug */
a651 1
	nmg_eval_plot( bs, nmg_eval_count++, 0 );	/* debug */
a660 1
	nmg_eval_plot( bs, nmg_eval_count++, 0 );	/* debug */
a669 1
	nmg_eval_plot( bs, nmg_eval_count++, 0 );	/* debug */
a682 1
	nmg_eval_plot( bs, nmg_eval_count++, 0 );	/* debug */
d1073 2
d1076 3
a1078 1
	if( ! (rt_g.NMG_debug & DEBUG_PL_ANIM) )  return;
d1080 2
d1099 8
a1106 12
#if 1
	/* XXX MGED_only hack -- will not link with other applications */
	/* Cause animation of boolean operation as it proceeds! */
	{
		char	buf[128];
		sprintf( buf, "overlay %s\n", fname);
		cmdline( buf );
		event_check( 1 );	/* Take any device events */
		refresh();		/* Force screen update */
		if(delay)  {
			/* delay 1/4 second */
			(void)bsdselect( 0, 0, 250000 );
d1108 6
a1113 2
		/* Save on disk space */
		(void)unlink(fname);
a1114 1
#endif
@


1.26
log
@When moving loops and edges, reset up pointer.
@
text
@d19 1
a19 1
static char RCSnmg_eval[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 1.25 90/05/22 01:32:46 mike Exp $ (BRL)";
d30 13
d355 1
d422 4
d432 2
d462 1
d482 1
d512 1
d525 1
d542 1
d554 1
d572 1
d579 1
d589 1
d604 1
d614 1
d633 1
d654 1
d664 1
d674 1
d681 1
d688 1
d693 1
d993 123
@


1.25
log
@Moved faces need to point to new shell.
@
text
@d19 1
a19 1
static char RCSnmg_eval[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 1.24 90/05/22 01:00:05 mike Exp $ (BRL)";
d170 1
a170 1
	NMG_LIST_APPEND( &src->lu_hd, &lu->l );
d172 3
d218 3
@


1.24
log
@'nother bug
@
text
@d19 1
a19 1
static char RCSnmg_eval[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 1.23 90/05/22 00:55:25 mike Exp $ (BRL)";
d123 3
@


1.23
log
@another bug
@
text
@d19 1
a19 1
static char RCSnmg_eval[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 1.22 90/05/22 00:41:19 mike Exp $ (BRL)";
d474 1
a474 1
			/* faceuse is empty, it dies */
d477 3
d505 3
@


1.22
log
@Fixed problem with demoting loops
@
text
@d19 1
a19 1
static char RCSnmg_eval[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 1.21 90/05/21 19:18:07 mike Exp $ (BRL)";
d602 5
a606 2
			/* Simply eliminate the loopuse */
			nmg_klu( lu );	/* kill loop & mate */
d612 3
@


1.21
log
@Fleshed out nmg_rm_redundancies
@
text
@d19 1
a19 1
static char RCSnmg_eval[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 1.20 90/05/18 07:25:58 butler Exp $ (BRL)";
d450 2
a451 1
				(void)nmg_demote_lu( lu );
d528 3
a530 1
			(void)nmg_demote_lu( lu );/* kill loop & mate */
d554 6
a559 2
			/* Demote the edegeuse into vertices */
			(void)nmg_demote_eu( eu );	/* and mate */
d565 3
@


1.20
log
@Halfway converted to new double-linked-list structures ;-)
@
text
@d19 1
a19 1
static char RCSnmg_eval[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 1.19 90/05/13 21:01:12 mike Exp $ (BRL)";
d395 1
d398 5
d716 1
d719 2
d726 1
a726 1
nmg_find_vertex_in_looplist( v, hd )
d729 1
d734 1
d740 1
d743 1
d755 30
d789 17
d809 15
d828 8
d839 9
d854 2
d877 3
a879 6
			/* Walk all the faces */
			for( NMG_LIST( fu, faceuse, &s->fu_hd ) )  {
				if( nmg_find_edge_in_looplist( eu->e_p, &fu->lu_hd ) )  {
					nmg_keu(eu);
					break;
				}
d897 25
d923 1
a923 1

@


1.19
log
@For the "goto" style loop waling, do not use ->last stuff
@
text
@d19 1
a19 1
static char RCSnmg_eval[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 1.18 90/05/13 18:16:11 mike Exp $ (BRL)";
d109 2
a110 3
	src->fu_p = fu;
	DLLRM(src->fu_p, fu);
	if (src->fu_p == fu) {
d118 1
a118 6
	src->fu_p = fumate;
	DLLRM(src->fu_p, fumate);
	if (src->fu_p == fumate) {
		/* This was the last fu in the list, tidy up */
		src->fu_p = (struct faceuse *)NULL;
	}
d121 2
a122 4
	DLLINS(dest->fu_p, fu);
	fu->s_p = dest;
	DLLINS(dest->fu_p, fumate);
	fumate->s_p = dest;
d155 2
a156 3
	src->lu_p = lu;
	DLLRM( src->lu_p, lu );
	if( src->lu_p == lu )  {
d164 1
a164 6
	src->lu_p = lumate;
	DLLRM(src->lu_p, lumate);
	if (src->lu_p == lumate) {
		/* This was the last lu in the list, tidy up */
		src->lu_p = (struct loopuse *)NULL;
	}
d167 2
a168 5
	DLLINS(dest->lu_p, lu);
	lu->up.s_p = dest;
	DLLINS(dest->lu_p, lumate);
	lumate->up.s_p = dest;

d198 2
a199 3
	src->eu_p = eu;
	DLLRM(src->eu_p, eu);
	if (src->eu_p == eu) {
d207 1
a207 6
	src->eu_p = eumate;
	DLLRM(src->eu_p, eumate);
	if (src->eu_p == eumate) {
		/* This was the last eu in the list, tidy up */
		src->eu_p = (struct edgeuse *)NULL;
	}
d210 2
a211 4
	DLLINS(dest->eu_p, eu);
	eu->up.s_p = dest;
	DLLINS(dest->eu_p, eumate);
	eumate->up.s_p = dest;
d230 1
a230 1
	(void)nmg_mlv( &(dest->magic), vu->v_p, OT_SAME );
a259 190
 *			N M G _ A C T _ O N _ L O O P
 *
 *  Perform the given action on all the loops listed in the loopuse array.
 */
void
nmg_act_on_loop( ltbl, action, dest, src )
struct nmg_ptbl	*ltbl;
int		action;
struct shell	*dest;
struct shell	*src;
{
	register struct loopuse	**lup;
	register struct loopuse	*lu;
	register struct faceuse	*fu;
	register int		i;

	NMG_CK_SHELL( dest );
	NMG_CK_SHELL( src );

	switch( action )  {
	default:
		rt_bomb("nmg_act_on_loop: bad action\n");
		/* NOTREACHED */

	case BACTION_KILL:
		i = ltbl->end-1;
		lup = &((struct loopuse **)(ltbl->buffer))[i];
		for( ; i >= 0; i--, lup-- ) {
			lu = *lup;
			*lup = 0;			/* sanity */
			NMG_CK_LOOPUSE(lu);
			fu = lu->up.fu_p;
			NMG_CK_FACEUSE(fu);
			/* Kill this loop use */
			nmg_klu( lu );
			/* If no loops remain in this face use, kill face use */
			if( !fu->lu_p )  nmg_kfu( fu );
		}
		break;

	case BACTION_RETAIN:
		i = ltbl->end-1;
		lup = &((struct loopuse **)(ltbl->buffer))[i];
		for( ; i >= 0; i--, lup-- ) {
			lu = *lup;
			*lup = 0;			/* sanity */
			NMG_CK_LOOPUSE(lu);
			fu = lu->up.fu_p;
			NMG_CK_FACEUSE(fu);
			if( fu->s_p == dest )  continue;
			nmg_mv_fu_between_shells( dest, src, fu );
		}
		break;

	case BACTION_RETAIN_AND_FLIP:
		i = ltbl->end-1;
		lup = &((struct loopuse **)(ltbl->buffer))[i];
		for( ; i >= 0; i--, lup-- ) {
			lu = *lup;
			*lup = 0;			/* sanity */
			NMG_CK_LOOPUSE(lu);
			fu = lu->up.fu_p;
			NMG_CK_FACEUSE(fu);
			nmg_reverse_face( fu );		/* flip */
			if( fu->s_p == dest )  continue;
			nmg_mv_fu_between_shells( dest, src, fu );
		}
		break;
	}
}

#if 0
/* Old way */

/* Actions are listed: onAinB, onAonB, onAoutB, inAonB, onAonB, outAonB */
static int		subtraction_actions[6] = {
	BACTION_KILL,
	BACTION_RETAIN,		/* _IF_OPPOSITE */
	BACTION_RETAIN,
	BACTION_RETAIN_AND_FLIP,
	BACTION_KILL,
	BACTION_KILL
};

static int		union_actions[6] = {
	BACTION_KILL,
	BACTION_RETAIN,		/* _IF_SAME */
	BACTION_RETAIN,
	BACTION_KILL,
	BACTION_KILL,
	BACTION_RETAIN
};

static int		intersect_actions[6] = {
	BACTION_RETAIN,
	BACTION_RETAIN,		/* If opposite, ==> non-manifold */
	BACTION_KILL,
	BACTION_RETAIN,
	BACTION_KILL,
	BACTION_KILL
};

/*
 *			N M G _ E V A L U A T E _ B O O L E A N
 *
 *  Evaluate a boolean operation on the two shells "A" and "B",
 *  of the form "answer = A op B".
 *  As input, each loop in both A and B has been classified as being
 *  "in", "on", or "out" of the other shell.
 *  Using these classifications, operate on the faces.
 *  At the end, shell A contains the resultant object, and
 *  shell B is destroyed.
 *
 *  XXX need to ensure each face is treated only once, maybe.
 *  XXX really need onAonBsame and onAonBopposite lists, not AonB & BonA.
 */
void
nmg_evaluate_boolean( sA, sB, op, AinB, AonB, AoutB, BinA, BonA, BoutA)
struct shell	*sA;
struct shell	*sB;
int		op;
struct nmg_ptbl *AinB, *AonB, *AoutB, *BinA, *BonA, *BoutA;
{
	struct nmg_ptbl	*classified_shell_loops[6];
	struct nmg_ptbl faces;
	struct loopuse	*lu;
	struct faceuse	*fu;
	int		*actions;
	int		i;

	switch( op )  {
	case NMG_BOOL_SUB:
		actions = subtraction_actions;
		break;
	case NMG_BOOL_ADD:
		actions = union_actions;
		break;
	case NMG_BOOL_ISECT:
		actions = intersect_actions;
		break;
	default:
		rt_log("ERROR nmg_evaluate_boolean() op=%d.\n", op);
		rt_bomb("bad boolean\n");
	}

	/* XXX for the future, ensure each face is treated only once */
	(void)nmg_tbl(&faces, TBL_INIT, (long *)NULL);

	classified_shell_loops[0] = AinB;
	classified_shell_loops[1] = AonB;
	classified_shell_loops[2] = AoutB;
	classified_shell_loops[3] = BinA;
	classified_shell_loops[4] = BonA;
	classified_shell_loops[5] = BoutA;

	for( i=0; i<6; i++ )  {
		nmg_act_on_loop( classified_shell_loops[i],
			actions[i], sA, sB );
	}

	/* Plot the result */
	if (rt_g.NMG_debug & DEBUG_BOOLEVAL && rt_g.NMG_debug & DEBUG_PLOTEM) {
		FILE *fp, *fopen();

		if ((fp=fopen("bool_ans.pl", "w")) == (FILE *)NULL) {
			(void)perror("bool_ans.pl");
			exit(-1);
		}
    		rt_log("plotting bool_ans.pl\n");
		nmg_pl_s( fp, sA );
		(void)fclose(fp);
	}


	if (sB->fu_p) {
		rt_log("WARNING:  nmg_evaluate_boolean():  shell B still has faces!\n");
	}
	if (sB->lu_p || sB->eu_p || sB->vu_p) {
		rt_log("WARNING:  nmg_evaluate_boolean():  shell B still has loops/edges/verts!\n");
	}
	/* Regardless of what is in it, kill shell B */
	nmg_ks( sB );

	(void)nmg_tbl(&faces, TBL_FREE, (long *)NULL);
}
#else

/* XXX begin new way */

/*
d383 1
a383 1
	if (sB->fu_p) {
d386 2
a387 2
	if (sB->lu_p || sB->eu_p || sB->vu_p) {
		rt_log("WARNING:  nmg_evaluate_boolean():  shell B still has loops/edges/verts!\n");
d389 6
d411 1
a411 1
	struct faceuse	*fu_end;
d413 1
a413 1
	struct loopuse	*lu_end;
d415 1
a415 1
	struct edgeuse	*eu_end;
d427 4
a430 3
start_faces:
	fu = fu_end = s->fu_p;
	do  {
a431 1
		if( !s->fu_p )  break;		/* face list became empty */
a433 1
start_face_loops:
d435 4
a438 3
		lu = lu_end = fu->lu_p;
		do {
			if( !fu->lu_p ) break;	/* loop list became empty */
a439 1
			NMG_CK_EDGEUSE(lu->down.eu_p);	/* sanity */
d445 2
a446 1
				goto start_face_loops;	/* lost our place */
d454 2
a455 2
			lu = lu->next;
		}while (lu != lu_end);
d466 1
a466 1
		if( !fu->lu_p )  {
d471 2
a472 1
		    	goto start_faces;	/* lost our place */
d496 2
a497 1
			goto start_faces;	/* lost our place */
d499 2
a500 2
		fu = fu->next;
	} while (fu != fu_end);
d507 4
a510 4
start_wire_loop:
	lu = lu_end = s->lu_p;
	do  {
		if( !s->lu_p )  break;		/* loop list became empty */
d512 1
a512 1
		if( *(lu->down.magic_p) == NMG_VERTEXUSE_MAGIC )  {
d514 1
a514 1
			lu = lu->next;
d522 2
a523 1
			goto start_wire_loop;
d528 2
a529 1
			goto start_wire_loop;
d531 2
a532 2
		lu = lu->next;
	}  while( lu != lu_end );
d537 4
a540 3
start_wire_edge:
	eu = eu_end = s->eu_p;
	do  {
a541 1
		if( !s->eu_p )  break;		/* edge list became empty */
d547 2
a548 1
			goto start_wire_edge;
d553 2
a554 1
			goto start_wire_edge;
d556 2
a557 2
		eu = eu->next;
	} while( eu != eu_end );
d571 4
a574 4
start_vertex_loops:
	lu = lu_end = s->lu_p;
	do  {
		if( !s->lu_p )  break;		/* loop list became empty */
d576 1
a576 1
		if( *(lu->down.magic_p) != NMG_VERTEXUSE_MAGIC )  {
d578 1
a578 1
			lu = lu->next;
d581 1
a581 1
		vu = lu->down.vu_p;
d588 2
a589 1
			goto start_vertex_loops;
d594 2
a595 1
			goto start_vertex_loops;
d597 2
a598 2
		lu = lu->next;
	}  while( lu != lu_end );
d702 107
a808 1
#endif
@


1.18
log
@Moving an item from one shell to another will drag along the mate.
@
text
@d19 1
a19 1
static char RCSnmg_eval[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 1.17 90/05/13 14:23:59 mike Exp $ (BRL)";
d700 1
a700 1
		if( fu->last->s_p != bs->bs_dest )  {
d703 2
a704 2
			nmg_mv_fu_between_shells( bs->bs_dest, s, fu->last );
			goto start_face_loops;	/* lost our place */
d728 1
a728 1
			(void)nmg_demote_lu( lu->last );/* kill loop & mate */
d732 2
a733 2
			if( lu->last->up.s_p == bs->bs_dest )  break;
			nmg_mv_lu_between_shells( bs->bs_dest, s, lu->last );
d751 1
a751 1
			(void)nmg_demote_eu( eu->last );	/* and mate */
d755 2
a756 2
			if( eu->last->up.s_p == bs->bs_dest )  break;
			nmg_mv_eu_between_shells( bs->bs_dest, s, eu->last );
d790 1
a790 1
			nmg_klu( lu->last );	/* kill loop & mate */
d794 2
a795 2
			if( lu->last->up.s_p == bs->bs_dest )  break;
			nmg_mv_lu_between_shells( bs->bs_dest, s, lu->last );
@


1.17
log
@This version of linked-list walking *really* works.
The goto statements are ugly, but entirely necessary.
@
text
@d19 1
a19 1
static char RCSnmg_eval[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 1.16 90/05/13 10:48:02 mike Exp $ (BRL)";
d700 1
a700 1
		if( s != bs->bs_dest )  {
d732 1
a732 1
			if( s == bs->bs_dest )  break;
d755 1
a755 1
			if( s == bs->bs_dest )  break;
d794 1
a794 1
			if( s == bs->bs_dest )  break;
d814 1
a814 1
			if( s == bs->bs_dest )  break;
@


1.16
log
@Added debugging.
@
text
@d19 1
a19 1
static char RCSnmg_eval[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 1.15 90/05/13 10:45:08 mike Exp $ (BRL)";
d636 1
d643 1
d654 2
a655 3
			  	lu = lu->next;
				(void)nmg_demote_lu( lu->last );
				continue;
d679 2
a680 6
		    	if( fu->fumate_p == fu->next )
				fu = fu->next->next;	/* skip mate too */
			else
				fu = fu->next;
			nmg_kfu( fu->last );		/* kill face & mate */
		    	continue;
a702 4
		    	if( fu->fumate_p == fu->next )
				fu = fu->next->next;	/* skip mate too */
			else
				fu = fu->next;
d704 1
a704 1
			continue;
d714 1
a727 4
			if( lu->lumate_p == lu->next )
				lu = lu->next->next;	/* skip mate too */
			else
				lu = lu->next;
d729 1
a729 1
			continue;
a732 4
			if( lu->lumate_p == lu->next )
				lu = lu->next->next;	/* skip mate too */
			else
				lu = lu->next;
d734 1
a734 1
			continue;
d742 1
a750 4
			if( eu->eumate_p == eu->next )
				eu = eu->next->next;
			else
				eu = eu->next;
d752 1
a752 1
			continue;
a755 4
			if( eu->eumate_p == eu->next )
				eu = eu->next->next;
			else
				eu = eu->next;
d757 1
a757 1
			continue;
d774 1
a789 4
			if( lu->lumate_p == lu->next )
				lu = lu->next->next;	/* skip mate too */
			else
				lu = lu->next;
d791 1
a791 1
			continue;
a794 4
			if( lu->lumate_p == lu->next )
				lu = lu->next->next;	/* skip mate too */
			else
				lu = lu->next;
d796 1
a796 1
			continue;
@


1.15
log
@This version seems to work;  shell-walking loops are fixed now.
@
text
@d19 1
a19 1
static char RCSnmg_eval[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 1.14 90/05/13 09:33:33 mike Exp $ (BRL)";
d890 1
d918 1
@


1.14
log
@Check for face with both retain & flip loops
@
text
@d19 1
a19 1
static char RCSnmg_eval[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 1.13 90/05/13 09:03:41 mike Exp $ (BRL)";
d135 3
a628 1
	int		action;
a635 1
faces_again:
d639 1
a639 1
		if( !fu )  break;
a641 1
faceloop_again:
d645 1
a645 1
			if( !lu )  break;
d647 2
a648 2
			eu = lu->down.eu_p;
			NMG_CK_EDGEUSE(eu);		/* sanity */
a650 1
			  {
d652 2
a653 11
				register struct loopuse	*nextlu = lu->next;
				if( lu->lumate_p == nextlu )  rt_log("lumate?\n");
				NMG_CK_FACEUSE( lu->up.fu_p );
				NMG_CK_FACEUSE( nextlu->up.fu_p );

				NMG_CK_LOOPUSE(nextlu);
				(void)nmg_demote_lu( lu );
				if( lu == lu_end )  goto faceloop_again;
				if( lu == lu_end )  break;
				NMG_CK_LOOPUSE(nextlu);
				lu = nextlu;
a654 1
			  }
d674 1
a674 1
		if( ((lu = fu->lu_p) == (struct loopuse *)0) )  {
a675 1
			register struct faceuse	*nextfu = fu->next;
d678 5
a682 8
		    	NMG_CK_FACEUSE(nextfu);
		    	if( fu->fumate_p == nextfu ) nextfu = nextfu->next;
		    	NMG_CK_FACEUSE(nextfu);
			nmg_kfu( fu );
			goto faces_again;
		    	if( fu == fu_end )  break;
		    	NMG_CK_FACEUSE(nextfu);
			fu = nextfu;
a685 3
		if (rt_g.NMG_debug & DEBUG_BOOLEVAL)
	    		rt_log("faceuse x%x retained\n", fu);

d695 7
d706 6
a711 2
			nmg_mv_fu_between_shells( bs->bs_dest, s, fu );
			goto faces_again;
a720 1
wire_loops_again:
d723 1
a723 1
		if( !lu )  break;
d734 6
a739 12
			{
				register struct loopuse	*nextlu = lu->next;
				NMG_CK_LOOPUSE(nextlu);
				if( lu->lumate_p == nextlu )  nextlu=nextlu->next;
				NMG_CK_LOOPUSE(nextlu);
				(void)nmg_demote_lu( lu );
				goto wire_loops_again;
				if( lu == lu_end )  break;
				NMG_CK_LOOPUSE(nextlu);
				lu = nextlu;
				continue;
			}
d742 7
a748 4
			if( s != bs->bs_dest )  {
				nmg_mv_lu_between_shells( bs->bs_dest, s, lu );
			}
			break;
a755 1
wire_edge_again:
d759 1
a759 1
		if( !eu )  break;
d764 6
a769 10
			{
				register struct edgeuse	*nexteu = eu->next;
				NMG_CK_EDGEUSE(nexteu);
				nmg_demote_eu( eu );
				goto wire_edge_again;
				if( eu == eu_end )  break;
				NMG_CK_EDGEUSE(nexteu);
				eu = nexteu;
				continue;
			}
d772 7
a778 4
			if( s != bs->bs_dest )  {
				nmg_mv_eu_between_shells( bs->bs_dest, s, eu );
			}
			break;
a794 1
vertex_self_loop_again:
d797 1
a797 1
		if( !lu )  break;
d810 6
a815 12
			{
				register struct loopuse	*nextlu = lu->next;
				NMG_CK_LOOPUSE(nextlu);
				if( lu->lumate_p == nextlu )  nextlu=nextlu->next;
				NMG_CK_LOOPUSE(nextlu);
				nmg_klu( lu );
				goto vertex_self_loop_again;
				if( lu == lu_end )  break;
				NMG_CK_LOOPUSE(nextlu);
				lu = nextlu;
				continue;
			}
d818 7
a824 4
			if( s != bs->bs_dest )  {
				nmg_mv_lu_between_shells( bs->bs_dest, s, lu );
			}
			break;
d842 3
a844 4
			if( s != bs->bs_dest )  {
				nmg_mv_vu_between_shells( bs->bs_dest, s, vu );
				s->vu_p = (struct vertexuse *)0; /* sanity */
			}
@


1.13
log
@DEBUG_SUBTRACT -> DEBUG_BOOLEVAL
@
text
@d19 1
a19 1
static char RCSnmg_eval[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 1.12 90/05/13 08:56:29 mike Exp $ (BRL)";
d583 1
a583 1
	if (rt_g.NMG_debug & DEBUG_BOOLEVAL) {
d624 3
d642 1
d649 3
a651 1
			if( nmg_eval_action( (genptr_t)lu->l_p, bs ) == BACTION_KILL )  {
d665 7
a672 3
			/* Retain loop.  Any action will be done to the
			 * faceuse as a whole, not just to this loop.
			 */
d676 4
d704 10
a713 4
#if 0
		/* XXX decide how */
		nmg_reverse_face( fu );
#endif
d715 2
d938 1
a938 1
		rt_log("nmg_eval_action(ptr=x%x) %s %s %s action=%s\n",
@


1.12
log
@Basic shell traversal works, albeit via a hack.
@
text
@d19 1
a19 1
static char RCSnmg_eval[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 1.11 90/05/13 08:05:03 mike Exp $ (BRL)";
d443 1
a443 1
	if (rt_g.NMG_debug & DEBUG_SUBTRACT) {
d546 1
a546 1
	if (rt_g.NMG_debug & DEBUG_SUBTRACT) {
d583 1
a583 1
	if (rt_g.NMG_debug & DEBUG_SUBTRACT) {
d674 1
a674 1
			if (rt_g.NMG_debug & DEBUG_SUBTRACT)
d687 1
a687 1
		if (rt_g.NMG_debug & DEBUG_SUBTRACT)
d915 1
a915 1
	if (rt_g.NMG_debug & DEBUG_SUBTRACT) {
@


1.11
log
@More debugging
@
text
@d19 1
a19 1
static char RCSnmg_eval[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 1.10 90/05/12 12:06:13 mike Exp $ (BRL)";
d270 8
a277 8
	"AinB",
	"AonBshared",
	"AonBanti",
	"AoutB",
	"BinA",
	"BonAshared",
	"BonAanti",
	"BoutA",
d546 10
d577 1
a577 1
	nmg_eval_do( sA, &bool_state );
d580 1
a580 1
	nmg_eval_do( sB, &bool_state );
d606 2
d612 1
a612 1
nmg_eval_do( s, bs )
d631 1
d638 1
d644 1
a644 1
			NMG_CK_EDGEUSE(eu);
d654 1
d671 1
a671 2
		if( ((lu = fu->lu_p) == (struct loopuse *)0) ||
		    lu->next == fu->lu_p )  {
d674 2
d680 1
d687 3
d696 1
d706 1
d726 1
d745 1
d758 1
d786 1
d808 1
@


1.10
log
@Fixed problem with deleting/demoting last element on the list.
@
text
@d19 1
a19 1
static char RCSnmg_eval[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_eval.c,v 1.9 90/05/12 10:17:53 mike Exp $ (BRL)";
d260 21
a519 10
#define NMG_CLASS_AinB		0
#define NMG_CLASS_AonBshared	1
#define NMG_CLASS_AonBanti	2
#define NMG_CLASS_AoutB		3
#define NMG_CLASS_BinA		4
#define NMG_CLASS_BonAshared	5
#define NMG_CLASS_BonAanti	6
#define NMG_CLASS_BoutA		7


d631 1
a631 1
			if( nmg_action( (genptr_t)lu->l_p, bs ) == BACTION_KILL )  {
d695 1
a695 1
		switch( nmg_action( (genptr_t)lu->l_p, bs ) )  {
d727 1
a727 1
		switch( nmg_action( (genptr_t)eu->e_p, bs ) )  {
d773 1
a773 1
		switch( nmg_action( (genptr_t)vu->v_p, bs ) )  {
d803 1
a803 1
		switch( nmg_action( (genptr_t)vu->v_p, bs ) )  {
d820 2
d829 1
a829 1
nmg_action( ptr, bs )
d833 3
d837 21
a857 9
		if( nmg_tbl( &bs->bs_classtab[NMG_CLASS_AinB], TBL_LOC, ptr ) >= 0 )
			return( bs->bs_actions[NMG_CLASS_AinB] );
		if( nmg_tbl( &bs->bs_classtab[NMG_CLASS_AonBshared], TBL_LOC, ptr ) >= 0 )
			return( bs->bs_actions[NMG_CLASS_AonBshared] );
		if( nmg_tbl( &bs->bs_classtab[NMG_CLASS_AonBanti], TBL_LOC, ptr ) >= 0 )
			return( bs->bs_actions[NMG_CLASS_AonBanti] );
		if( nmg_tbl( &bs->bs_classtab[NMG_CLASS_AoutB], TBL_LOC, ptr ) >= 0 )
			return( bs->bs_actions[NMG_CLASS_AoutB] );
		rt_log("nmg_action(ptr=x%x) %s has no A classification, retaining\n",
d859 2
a860 1
		return( BACTION_RETAIN );
d864 21
a884 9
	if( nmg_tbl( &bs->bs_classtab[NMG_CLASS_BinA], TBL_LOC, ptr ) >= 0 )
		return( bs->bs_actions[NMG_CLASS_BinA] );
	if( nmg_tbl( &bs->bs_classtab[NMG_CLASS_BonAshared], TBL_LOC, ptr ) >= 0 )
		return( bs->bs_actions[NMG_CLASS_BonAshared] );
	if( nmg_tbl( &bs->bs_classtab[NMG_CLASS_BonAanti], TBL_LOC, ptr ) >= 0 )
		return( bs->bs_actions[NMG_CLASS_BonAanti] );
	if( nmg_tbl( &bs->bs_classtab[NMG_CLASS_BoutA], TBL_LOC, ptr ) >= 0 )
		return( bs->bs_actions[NMG_CLASS_BoutA] );
	rt_log("nmg_action(ptr=x%x) %s has no B classification, retaining\n",
d886 10
a895 1
	return( BACTION_RETAIN );
@


1.9
log
@Tentative, not working.
@
text
@d19 1
a19 1
static char RCSnmg_eval[] = "@@(#)$Header: nmg_eval.c,v 1.8 90/05/09 01:47:34 mike Exp $ (BRL)";
d629 1
d653 1
d693 1
d718 1
a718 1
			/* Demote the degeuse into vertices */
d723 1
d771 1
@


1.8
log
@New interface for booleans, called nmg_evaluate_boolean().
@
text
@d6 1
a7 1
 *	Michael John Muuss
d19 1
a19 1
static char RCSnmg_eval[] = "@@(#)$Header: nmg_eval.c,v 1.7 90/05/09 01:05:57 mike Locked $ (BRL)";
d133 10
a142 3
#define BACTION_KILL			1
#define BACTION_RETAIN			2
#define BACTION_RETAIN_AND_FLIP		3
d144 3
a146 9
/* Actions are listed: onAinB, onAonB, onAoutB, inAonB, onAonB, outAonB */
static int		subtraction_actions[6] = {
	BACTION_KILL,
	BACTION_RETAIN,		/* _IF_OPPOSITE */
	BACTION_RETAIN,
	BACTION_RETAIN_AND_FLIP,
	BACTION_KILL,
	BACTION_KILL
};
d148 10
a157 8
static int		union_actions[6] = {
	BACTION_KILL,
	BACTION_RETAIN,		/* _IF_SAME */
	BACTION_RETAIN,
	BACTION_KILL,
	BACTION_KILL,
	BACTION_RETAIN
};
d159 9
a167 8
static int		intersect_actions[6] = {
	BACTION_RETAIN,
	BACTION_RETAIN,		/* If opposite, ==> non-manifold */
	BACTION_KILL,
	BACTION_RETAIN,
	BACTION_KILL,
	BACTION_KILL
};
d169 16
d186 75
d332 31
d446 398
@


1.7
log
@This version works pretty well.
Onwards to interfacing issues.
@
text
@d19 1
a19 1
static char RCSnmg_eval[] = "@@(#)$Header: nmg_eval.c,v 1.4 90/05/08 21:57:42 mike Locked $ (BRL)";
a30 22
 *			N M G _ T O S S _ L O O P S
 *
 *	throw away all loops in the loopuse list "lu"
 */
static void nmg_toss_loops(lu, n)
struct loopuse **lu;
int n;
{
	int				i;
	struct faceuse			*fu;	

	for (i=0 ; i < n ; ++i) {
		fu = lu[i]->up.fu_p;
		nmg_klu(lu[i]);
		lu[i] = (struct loopuse *)NULL;	/* sanity */
		if (!fu->lu_p) {
			nmg_kfu(fu);
		}
	}
}

/*
a136 2
static struct nmg_ptbl	*classified_shell_loops[6];

d167 2
d177 4
a180 4
	struct loopuse	**lup;
	struct loopuse	*lu;
	struct faceuse	*fu;
	int		i;
d191 14
a204 2
		nmg_toss_loops( (struct loopuse **)(ltbl->buffer), ltbl->end );
		return;
d218 1
a218 1
		return;
d233 1
a233 1
		return;
d237 2
a238 1
/*	S U B T R A C T I O N
d240 10
a249 5
 *	reshuffle the faces of two shells to perform a subtraction of
 *	one shell from the other.  Shell "sB" disappears and shell "sA"
 *	contains:
 *		the faces that were in sA outside of sB
 *		the faces that were in sB inside of sA (normals flipped)
d251 5
a255 2
void subtraction(sA, AinB, AonB, AoutB, sB, BinA, BonA, BoutA)
struct shell *sA, *sB;
d258 1
d260 4
a263 7
	struct loopuse *lu;
	struct faceuse *fu;
	union {
		struct loopuse **lu;
		long **l;
	} p;
	int i;
d265 16
d292 1
a292 2
			subtraction_actions[i],
			sA, sB );
d299 2
a300 2
		if ((fp=fopen("sub.pl", "w")) == (FILE *)NULL) {
			(void)perror("sub.pl");
d303 1
a303 1
    		rt_log("plotting sub.pl\n");
d310 1
a310 7
		rt_log("Why does shell B still have faces?\n");
	} else if (!sB->lu_p && !sB->eu_p && !sB->vu_p) {
		struct nmgregion	*r;

		r = sB->r_p;
		nmg_ks(sB);
		if (!r->s_p && r->next != r) nmg_kr(r);
d312 2
a313 36


	(void)nmg_tbl(&faces, TBL_FREE, (long *)NULL);
}
/*	A D D I T I O N
 *
 *	add (union) two shells together
 *
 */
void addition(sA, AinB, AonB, AoutB, sB, BinA, BonA, BoutA)
struct shell *sA, *sB;
struct nmg_ptbl *AinB, *AonB, *AoutB, *BinA, *BonA, *BoutA;
{
	struct nmg_ptbl faces;
	struct loopuse *lu;
	struct faceuse *fu;
	union {
		struct loopuse **lu;
		long **l;
	} p;
	int i;


	(void)nmg_tbl(&faces, TBL_INIT, (long *)NULL);

	classified_shell_loops[0] = AinB;
	classified_shell_loops[1] = AonB;
	classified_shell_loops[2] = AoutB;
	classified_shell_loops[3] = BinA;
	classified_shell_loops[4] = BonA;
	classified_shell_loops[5] = BoutA;

	for( i=0; i<6; i++ )  {
		nmg_act_on_loop( classified_shell_loops[i],
			union_actions[i],
			sA, sB );
d315 2
a316 48

	if (sB->fu_p) {
		rt_log("Why does shell B still have faces?\n");
	} else if (!sB->lu_p && !sB->eu_p && !sB->vu_p) {
		nmg_ks(sB);
	}

	(void)nmg_tbl(&faces, TBL_FREE, (long *)NULL);
}

/*	I N T E R S E C T I O N
 *
 *	resulting shell is all faces of sA in sB and all faces of sB in sA
 */
void intersection(sA, AinB, AonB, AoutB, sB, BinA, BonA, BoutA)
struct shell *sA, *sB;
struct nmg_ptbl *AinB, *AonB, *AoutB, *BinA, *BonA, *BoutA;
{
	struct nmg_ptbl faces;
	struct loopuse *lu;
	struct faceuse *fu;
	union {
		struct loopuse **lu;
		long **l;
	} p;
	int i;


	(void)nmg_tbl(&faces, TBL_INIT, (long *)NULL);

	classified_shell_loops[0] = AinB;
	classified_shell_loops[1] = AonB;
	classified_shell_loops[2] = AoutB;
	classified_shell_loops[3] = BinA;
	classified_shell_loops[4] = BonA;
	classified_shell_loops[5] = BoutA;

	for( i=0; i<6; i++ )  {
		nmg_act_on_loop( classified_shell_loops[i],
			intersect_actions[i],
			sA, sB );
	}

	if (sB->fu_p) {
		rt_log("Why does shell B still have faces?\n");
	} else if (!sB->lu_p && !sB->eu_p && !sB->vu_p) {
		nmg_ks(sB);
	}
@


1.6
log
@More evolution.
@
text
@d268 2
a269 1
#if 0
a281 1
#endif
d283 1
a283 34
	(void)nmg_tbl(&faces, TBL_INIT, (long *)NULL);

#if 0
	/* first we toss out the unwanted faces from both shells */
	p.l = AinB->buffer;
	nmg_toss_loops(p.lu, AinB->end);

	p.l = BonA->buffer;
	nmg_toss_loops(p.lu, BonA->end);

	p.l = BoutA->buffer;
	nmg_toss_loops(p.lu, BoutA->end);

	p.l = BinA->buffer;
	for (i=0 ; i < BinA->end ; ++i) {
		lu = p.lu[i];
		NMG_CK_LOOPUSE(lu);
		fu = lu->up.fu_p;
		NMG_CK_FACEUSE(fu);
		if (nmg_tbl(&faces, TBL_LOC, &fu->magic) < 0) {
			/* Move fu from shell B to A, flip normal */
			nmg_mv_fu_between_shells( sA, sB, fu );
			nmg_reverse_face( fu );
		}
	}
#else
	nmg_act_on_loop( AinB, BACTION_KILL, sA, sB );
	nmg_act_on_loop( AonB, BACTION_RETAIN, sA, sB );	/* if opposite */
	nmg_act_on_loop( AoutB, BACTION_RETAIN, sA, sB );
	nmg_act_on_loop( BinA, BACTION_RETAIN_AND_FLIP, sA, sB );
	nmg_act_on_loop( BonA, BACTION_KILL, sA, sB );
	nmg_act_on_loop( BoutA, BACTION_KILL, sA, sB );
#endif

d285 1
a285 2
		FILE *fd, *fopen();
		struct nmg_ptbl junk;
d287 1
a287 3
		(void)nmg_tbl(&junk, TBL_INIT, (long *)NULL);

		if ((fd=fopen("sub.pl", "w")) == (FILE *)NULL) {
d292 2
a293 14

		for (i=0 ; i < AoutB->end ; ++i) {
			p.l = &	AoutB->buffer[i];
			nmg_pl_lu(fd, *p.lu, &junk, 200, 200, 200);
		}

		for (i=0 ; i < BinA->end ; ++i) {
			p.l = &	BinA->buffer[i];
			nmg_pl_lu(fd, *p.lu, &junk, 200, 200, 200);
		}


		(void)nmg_tbl(&junk, TBL_FREE, (long *)NULL);
		(void)fclose(fd);
d331 6
a336 3
	/* first we toss out the unwanted faces from both shells */
	p.l = AinB->buffer;
	nmg_toss_loops(p.lu, AinB->end);
d338 4
a341 21
	p.l = BinA->buffer;
	nmg_toss_loops(p.lu, BinA->end);

	/* Here we handle the delicat issue of combining faces of A and B
	 * which are "ON" each other
	 *
	 * Unimlpemented
	 */


	/* combine faces of B with A */
	p.l = BoutA->buffer;
	for (i=0 ; i < BoutA->end ; ++i) {
		lu = p.lu[i];
		NMG_CK_LOOPUSE(lu);
		fu = lu->up.fu_p;
		NMG_CK_FACEUSE(fu);
		if (nmg_tbl(&faces, TBL_LOC, &fu->magic) < 0) {
			/* Move fu from shell B to A */
			nmg_mv_fu_between_shells( sA, sB, fu );
		}
d373 6
a378 3
	/* first we toss out the unwanted faces from both shells */
	p.l = AoutB->buffer;
	nmg_toss_loops(p.lu, AoutB->end);
d380 4
a383 19
	p.l = BoutA->buffer;
	nmg_toss_loops(p.lu, BoutA->end);

	/* we need to handle the "ON" faces here
	 *
	 * unimplemented
	 */

	/* now we combine the faces of B with A */
	p.l = BinA->buffer;
	for (i=0 ; i < BinA->end ; ++i) {
		lu = p.lu[i];
		NMG_CK_LOOPUSE(lu);
		fu = lu->up.fu_p;
		NMG_CK_FACEUSE(fu);
		if (nmg_tbl(&faces, TBL_LOC, &fu->magic) < 0) {
			/* Move fu from shell B to A */
			nmg_mv_fu_between_shells( sA, sB, fu );
		}
@


1.5
log
@Split out nmg_reverse_face().
@
text
@a40 2
	register struct shell		*s;
	register struct nmgregion	*r;
a41 1

d45 1
a45 1
		lu[i] = (struct loopuse *)NULL;
a46 1
			s = fu->s_p;
a47 5
			if (!s->fu_p && !s->lu_p && !s->eu_p && !s->vu_p) {
				r = s->r_p;
				nmg_ks(s);
				if (!r->s_p && r->next != r) nmg_kr(r);
			}
d155 92
d268 15
d285 1
d308 8
a316 1

d348 3
d352 1
@


1.4
log
@Created subroutine nmg_mv_fu_between_shells().
Changed name of toss_loops to nmg_toss_loops.
@
text
@d19 1
a19 1
static char RCSnmg_eval[] = "@@(#)$Header$ (BRL)";
d62 50
a183 1
	vectp_t v;
d204 1
a204 1
			/* Move fu from shell B to A */
d206 1
a206 23

			/* reverse face normal vector */
			NMG_CK_FACE(fu->f_p);
			NMG_CK_FACE_G(fu->f_p->fg_p);
			v = fu->f_p->fg_p->N;
			VREVERSE(v, v);
			v[H] *= -1.0;

			/* switch which face is "outside" face */
			if (fu->orientation == OT_SAME)
				if (fu->fumate_p->orientation != OT_OPPOSITE)
					rt_bomb("NMG fumate has bad orientation\n");
				else {
					fu->orientation = OT_OPPOSITE;
					fu->fumate_p->orientation = OT_SAME;
				}
			else if (fu->orientation == OT_OPPOSITE)
				if (fu->fumate_p->orientation != OT_SAME)
					rt_bomb("NMG fumate has bad orientation\n");
				else {
					fu->orientation = OT_SAME;
					fu->fumate_p->orientation = OT_OPPOSITE;
				}
@


1.3
log
@unstatic'd routines and moved toss_loops.
@
text
@d3 14
a16 1
 *	evaluate the boolean operations on a set of faces in two shells
d18 3
d30 2
a31 1
/*	T O S S _ L O O P
d35 1
a35 1
static void toss_loops(lu, n)
d39 4
a42 4
	int i;
	struct faceuse *fu;	
	struct shell *s;
	struct nmgregion *r;
d61 53
d140 1
a140 1
	toss_loops(p.lu, AinB->end);
d143 1
a143 1
	toss_loops(p.lu, BonA->end);
d146 1
a146 1
	toss_loops(p.lu, BoutA->end);
d155 2
a156 4
			/* move faceuse to new shell */
			if (fu->s_p != sB) {
				rt_bomb("I'm NMG confused 1\n");
			}
a157 24
			sB->fu_p = fu;
			DLLRM(sB->fu_p, fu);
			if (sB->fu_p == fu) {
				rt_bomb("Hey, my NMG face mate isn't in this shell\n");
			}
			DLLINS(sA->fu_p, fu);
			fu->s_p = sA;

			/* move the fumate to new shell */
			fu = fu->fumate_p;
			NMG_CK_FACEUSE(fu);
			if (fu->s_p != sB) {
				rt_bomb("NMG shell ran out of faces!\n");
			}

			sB->fu_p = fu;
			DLLRM(sB->fu_p, fu);
			if (sB->fu_p == fu) {
				sB->fu_p = (struct faceuse *)NULL;
			}
			DLLINS(sA->fu_p, fu);
			fu->s_p = sA;


d244 1
a244 1
	toss_loops(p.lu, AinB->end);
d247 1
a247 1
	toss_loops(p.lu, BinA->end);
d264 2
a265 27
			/* move faceuse to new shell */
			if (fu->s_p != sB) {
				rt_bomb("I'm NMG confused 2\n");
			}

			sB->fu_p = fu;
			DLLRM(sB->fu_p, fu);
			if (sB->fu_p == fu) {
				rt_bomb("Hey, my NMG face mate isn't in this shell\n");
			}
			DLLINS(sA->fu_p, fu);
			fu->s_p = sA;

			/* move the fumate to new shell */
			fu = fu->fumate_p;
			NMG_CK_FACEUSE(fu);
			if (fu->s_p != sB) {
				rt_bomb("I'm NMG confused 3\n");
			}

			sB->fu_p = fu;
			DLLRM(sB->fu_p, fu);
			if (sB->fu_p == fu) {
				sB->fu_p = (struct faceuse *)NULL;
			}
			DLLINS(sA->fu_p, fu);
			fu->s_p = sA;
d300 1
a300 1
	toss_loops(p.lu, AoutB->end);
d303 1
a303 1
	toss_loops(p.lu, BoutA->end);
d318 2
a319 27
			/* move faceuse to new shell */
			if (fu->s_p != sB) {
				rt_bomb("I'm NMG confused 4\n");
			}

			sB->fu_p = fu;
			DLLRM(sB->fu_p, fu);
			if (sB->fu_p == fu) {
				rt_bomb("Hey, my NMG face mate isn't in this shell\n");
			}
			DLLINS(sA->fu_p, fu);
			fu->s_p = sA;

			/* move the fumate to new shell */
			fu = fu->fumate_p;
			NMG_CK_FACEUSE(fu);
			if (fu->s_p != sB) {
				rt_bomb("I'm NMG confused 5\n");
			}

			sB->fu_p = fu;
			DLLRM(sB->fu_p, fu);
			if (sB->fu_p == fu) {
				sB->fu_p = (struct faceuse *)NULL;
			}
			DLLINS(sA->fu_p, fu);
			fu->s_p = sA;
@


1.2
log
@make routines non-static
@
text
@d14 12
d27 17
d87 1
a87 1
				rt_bomb("I'm NMG confused\n");
d222 1
a222 1
				rt_bomb("I'm NMG confused\n");
d237 1
a237 1
				rt_bomb("I'm NMG confused\n");
d301 1
a301 1
				rt_bomb("I'm NMG confused\n");
d316 1
a316 1
				rt_bomb("I'm NMG confused\n");
@


1.1
log
@Initial revision
@
text
@d23 1
a23 1
static void subtraction(sA, AinB, AonB, AoutB, sB, BinA, BonA, BoutA)
d153 1
a153 1
static void addition(sA, AinB, AonB, AoutB, sB, BinA, BonA, BoutA)
d234 1
a234 1
static void intersection(sA, AinB, AonB, AoutB, sB, BinA, BonA, BoutA)
@
