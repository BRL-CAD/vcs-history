head	11.23;
access;
symbols
	ansi-20040405-merged:11.20.4.1
	postmerge-20040405-ansi:11.21
	premerge-20040404-ansi:11.21
	postmerge-autoconf:11.21
	autoconf-freeze:11.20.12.2
	premerge-autoconf:11.21
	ansi-20040316-freeze:11.20
	postmerge-20040315-windows:11.21
	premerge-20040315-windows:11.21
	windows-20040315-freeze:11.20.6.1
	autoconf-20031203:11.20
	autoconf-20031202:11.20
	autoconf-branch:11.20.0.12
	phong-branch:11.20.0.10
	photonmap-branch:11.20.0.8
	rel-6-1-DP:11.20
	windows-branch:11.20.0.6
	rel-6-0-2:11.20
	ansi-branch:11.20.0.4
	rel-6-0-1-branch:11.20.0.2
	hartley-6-0-post:11.20
	hartley-6-0-pre:11.20
	rel-6-0-1:11.20
	rel-6-0:11.20
	rel-5-4:11.13
	offsite-5-3-pre:11.18
	rel-5-3:11.13
	rel-5-2:11.13
	rel-5-1-branch:11.13.0.2
	rel-5-1:11.13
	rel-5-0:11.6
	rel-5-0-beta:11.6
	rel-4-5:11.2
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.23
date	2004.05.21.18.07.31;	author morrison;	state dead;
branches;
next	11.22;

11.22
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.21;

11.21
date	2004.02.02.17.39.22;	author morrison;	state Exp;
branches;
next	11.20;

11.20
date	2001.10.02.19.24.30;	author jra;	state Exp;
branches
	11.20.4.1
	11.20.6.1
	11.20.12.1;
next	11.19;

11.19
date	2001.04.20.22.29.48;	author morrison;	state Exp;
branches;
next	11.18;

11.18
date	2000.07.10.23.01.37;	author mike;	state Exp;
branches;
next	11.17;

11.17
date	2000.06.30.15.38.04;	author mike;	state Exp;
branches;
next	11.16;

11.16
date	2000.06.30.15.28.25;	author mike;	state Exp;
branches;
next	11.15;

11.15
date	2000.06.29.19.45.58;	author butler;	state Exp;
branches;
next	11.14;

11.14
date	2000.06.29.18.16.06;	author butler;	state Exp;
branches;
next	11.13;

11.13
date	2000.04.12.02.34.37;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	99.12.18.02.11.14;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	99.12.18.01.47.33;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	99.11.17.02.42.03;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	99.10.12.19.56.29;	author jra;	state Exp;
branches;
next	11.8;

11.8
date	99.10.12.19.50.01;	author jra;	state Exp;
branches;
next	11.7;

11.7
date	99.10.12.17.14.38;	author jra;	state Exp;
branches;
next	11.6;

11.6
date	99.05.27.19.10.44;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	98.03.26.07.55.57;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	98.03.26.07.52.34;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	98.03.19.16.04.57;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	97.09.22.05.16.19;	author butler;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.57.10;	author mike;	state Rel4_4;
branches;
next	10.3;

10.3
date	94.08.10.18.42.47;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	91.11.27.15.11.43;	author mmark;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.40.29;	author mike;	state Rel4_0;
branches;
next	1.9;

1.9
date	91.06.30.00.11.02;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	91.06.22.22.30.44;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	91.05.18.03.01.50;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	91.02.07.00.00.25;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	91.01.28.23.53.26;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	91.01.26.05.09.09;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	91.01.25.20.36.17;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	90.10.11.02.37.41;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	90.10.06.02.05.30;	author mike;	state Exp;
branches;
next	;

11.20.4.1
date	2004.03.17.21.18.48;	author morrison;	state Exp;
branches;
next	;

11.20.6.1
date	2004.03.11.23.43.39;	author morrison;	state Exp;
branches;
next	;

11.20.12.1
date	2004.02.12.18.37.42;	author erikg;	state Exp;
branches;
next	11.20.12.2;

11.20.12.2
date	2004.03.15.14.07.23;	author erikg;	state Exp;
branches;
next	;


desc
@Prototype geometry module
@


11.23
log
@moved to src/
@
text
@/*
 *			G _ X X X . C
 *
 *  Purpose -
 *	Intersect a ray with a 
 *
 * Adding a new solid type:
 *	Design disk record
 *
 *	define rt_xxx_internal --- parameters for solid
 *	define xxx_specific --- raytracing form, possibly w/precomuted terms
 *	define rt_xxx_parse --- struct bu_structparse for "db get", "db adjust", ...
 *
 *	code import/export/describe/print/ifree/plot/prep/shot/curve/uv/tess
 *
 *	edit db.h add solidrec s_type define
 *	edit rtgeom.h to add rt_xxx_internal
 *	edit table.c:
 *		RT_DECLARE_INTERFACE()
 *		struct rt_functab entry
 *		rt_id_solid()
 *	edit raytrace.h to make ID_XXX, increment ID_MAXIMUM
 *	edit db_scan.c to add the new solid to db_scan()
 *	edit Cakefile to add g_xxx.c to compile
 *
 *	Then:
 *	go to /cad/libwdb and create mk_xxx() routine
 *	go to /cad/conv and edit g2asc.c and asc2g.c to support the new solid
 *	go to /cad/librt and edit tcl.c to add the new solid to 
 *		rt_solid_type_lookup[]
 *		also add the interface table and to rt_id_solid() in table.c
 *	go to /cad/mged and create the edit support
 *
 *  Authors -
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1990-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSxxx[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/g_xxx.c,v 11.22 2004/05/10 15:30:46 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#include "machine.h"
#include "vmath.h"
#include "db.h"
#include "nmg.h"
#include "raytrace.h"
#include "rtgeom.h"
#include "./debug.h"

#if 0
/* parameters for solid, internal representation
 * This goes in rtgeom.h
 */
/* parameters for solid, internal representation */
struct rt_xxx_internal {
	long	magic;
	vect_t	v;
};
#define RT_XXX_INTERNAL_MAGIC	0xxx
#define RT_XXX_CK_MAGIC(_p)	BU_CKMAG(_p,RT_XXX_INTERNAL_MAGIC,"rt_xxx_internal")
#endif

/* ray tracing form of solid, including precomputed terms */
struct xxx_specific {
	vect_t	xxx_V;
};

/*
 *  			R T _ X X X _ P R E P
 *  
 *  Given a pointer to a GED database record, and a transformation matrix,
 *  determine if this is a valid XXX, and if so, precompute various
 *  terms of the formula.
 *  
 *  Returns -
 *  	0	XXX is OK
 *  	!0	Error in description
 *  
 *  Implicit return -
 *  	A struct xxx_specific is created, and it's address is stored in
 *  	stp->st_specific for use by xxx_shot().
 */
int
rt_xxx_prep( stp, ip, rtip )
struct soltab		*stp;
struct rt_db_internal	*ip;
struct rt_i		*rtip;
{
	struct rt_xxx_internal		*xxx_ip;
	register struct xxx_specific	*xxx;
	const struct bn_tol		*tol = &rtip->rti_tol;

	RT_CK_DB_INTERNAL(ip);
	xxx_ip = (struct rt_xxx_internal *)ip->idb_ptr;
	RT_XXX_CK_MAGIC(xxx_ip);
}

/*
 *			R T _ X X X _ P R I N T
 */
void
rt_xxx_print( stp )
register const struct soltab *stp;
{
	register const struct xxx_specific *xxx =
		(struct xxx_specific *)stp->st_specific;
}

/*
 *  			R T _ X X X _ S H O T
 *  
 *  Intersect a ray with a xxx.
 *  If an intersection occurs, a struct seg will be acquired
 *  and filled in.
 *  
 *  Returns -
 *  	0	MISS
 *	>0	HIT
 */
int
rt_xxx_shot( stp, rp, ap, seghead )
struct soltab		*stp;
register struct xray	*rp;
struct application	*ap;
struct seg		*seghead;
{
	register struct xxx_specific *xxx =
		(struct xxx_specific *)stp->st_specific;
	register struct seg *segp;
	const struct bn_tol	*tol = &ap->a_rt_i->rti_tol;

	return(0);			/* MISS */
}

#define RT_XXX_SEG_MISS(SEG)	(SEG).seg_stp=RT_SOLTAB_NULL

/*
 *			R T _ X X X _ V S H O T
 *
 *  Vectorized version.
 */
void
rt_xxx_vshot( stp, rp, segp, n, ap )
struct soltab	       *stp[]; /* An array of solid pointers */
struct xray		*rp[]; /* An array of ray pointers */
struct  seg            segp[]; /* array of segs (results returned) */
int		  	    n; /* Number of ray/object pairs */
struct application	*ap;
{
	rt_vstub( stp, rp, segp, n, ap );
}

/*
 *  			R T _ X X X _ N O R M
 *  
 *  Given ONE ray distance, return the normal and entry/exit point.
 */
void
rt_xxx_norm( hitp, stp, rp )
register struct hit	*hitp;
struct soltab		*stp;
register struct xray	*rp;
{
	register struct xxx_specific *xxx =
		(struct xxx_specific *)stp->st_specific;

	VJOIN1( hitp->hit_point, rp->r_pt, hitp->hit_dist, rp->r_dir );
}

/*
 *			R T _ X X X _ C U R V E
 *
 *  Return the curvature of the xxx.
 */
void
rt_xxx_curve( cvp, hitp, stp )
register struct curvature *cvp;
register struct hit	*hitp;
struct soltab		*stp;
{
	register struct xxx_specific *xxx =
		(struct xxx_specific *)stp->st_specific;

 	cvp->crv_c1 = cvp->crv_c2 = 0;

	/* any tangent direction */
 	bn_vec_ortho( cvp->crv_pdir, hitp->hit_normal );
}

/*
 *  			R T _ X X X _ U V
 *  
 *  For a hit on the surface of an xxx, return the (u,v) coordinates
 *  of the hit point, 0 <= u,v <= 1.
 *  u = azimuth
 *  v = elevation
 */
void
rt_xxx_uv( ap, stp, hitp, uvp )
struct application	*ap;
struct soltab		*stp;
register struct hit	*hitp;
register struct uvcoord	*uvp;
{
	register struct xxx_specific *xxx =
		(struct xxx_specific *)stp->st_specific;
}

/*
 *		R T _ X X X _ F R E E
 */
void
rt_xxx_free( stp )
register struct soltab *stp;
{
	register struct xxx_specific *xxx =
		(struct xxx_specific *)stp->st_specific;

	bu_free( (char *)xxx, "xxx_specific" );
}

/*
 *			R T _ X X X _ C L A S S
 */
int
rt_xxx_class( stp, min, max, tol )
const struct soltab    *stp;
const vect_t		min, max;
const struct bn_tol    *tol;
{
	return RT_CLASSIFY_UNIMPLEMENTED;
}

/*
 *			R T _ X X X _ P L O T
 */
int
rt_xxx_plot( vhead, ip, ttol, tol )
struct bu_list		*vhead;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol	*tol;
{
	LOCAL struct rt_xxx_internal	*xxx_ip;

	RT_CK_DB_INTERNAL(ip);
	xxx_ip = (struct rt_xxx_internal *)ip->idb_ptr;
	RT_XXX_CK_MAGIC(xxx_ip);

	return(-1);
}

/*
 *			R T _ X X X _ T E S S
 *
 *  Returns -
 *	-1	failure
 *	 0	OK.  *r points to nmgregion that holds this tessellation.
 */
int
rt_xxx_tess( r, m, ip, ttol, tol )
struct nmgregion	**r;
struct model		*m;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol	*tol;
{
	LOCAL struct rt_xxx_internal	*xxx_ip;

	RT_CK_DB_INTERNAL(ip);
	xxx_ip = (struct rt_xxx_internal *)ip->idb_ptr;
	RT_XXX_CK_MAGIC(xxx_ip);

	return(-1);
}

/*
 *			R T _ X X X _ I M P O R T
 *
 *  Import an XXX from the database format to the internal format.
 *  Apply modeling transformations as well.
 */
int
rt_xxx_import( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
{
	LOCAL struct rt_xxx_internal	*xxx_ip;
	union record			*rp;

	BU_CK_EXTERNAL( ep );
	rp = (union record *)ep->ext_buf;
	/* Check record type */
	if( rp->u_id != ID_SOLID )  {
		bu_log("rt_xxx_import: defective record\n");
		return(-1);
	}

	RT_CK_DB_INTERNAL( ip );
	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_XXX;
	ip->idb_meth = &rt_functab[ID_XXX];
	ip->idb_ptr = bu_malloc( sizeof(struct rt_xxx_internal), "rt_xxx_internal");
	xxx_ip = (struct rt_xxx_internal *)ip->idb_ptr;
	xxx_ip->magic = RT_XXX_INTERNAL_MAGIC;

	MAT4X3PNT( xxx_ip->xxx_V, mat, &rp->s.s_values[0] );

	return(0);			/* OK */
}

/*
 *			R T _ X X X _ E X P O R T
 *
 *  The name is added by the caller, in the usual place.
 */
int
rt_xxx_export( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
{
	struct rt_xxx_internal	*xxx_ip;
	union record		*rec;

	RT_CK_DB_INTERNAL(ip);
	if( ip->idb_type != ID_XXX )  return(-1);
	xxx_ip = (struct rt_xxx_internal *)ip->idb_ptr;
	RT_XXX_CK_MAGIC(xxx_ip);

	BU_CK_EXTERNAL(ep);
	ep->ext_nbytes = sizeof(union record);
	ep->ext_buf = (genptr_t)bu_calloc( 1, ep->ext_nbytes, "xxx external");
	rec = (union record *)ep->ext_buf;

	rec->s.s_id = ID_SOLID;
	rec->s.s_type = XXX;	/* GED primitive type from db.h */

	/* Since libwdb users may want to operate in units other
	 * than mm, we offer the opportunity to scale the solid
	 * (to get it into mm) on the way out.
	 */


	/* convert from local editing units to mm and export
	 * to database record format
	 *
	 * Warning: type conversion: double to float
	 */
	VSCALE( &rec->s.s_values[0], xxx_ip->xxx_V, local2mm );
	rec->s.s_values[3] = xxx_ip->xxx_radius * local2mm;

	return(0);
}



/*
 *			R T _ X X X _ I M P O R T 5
 *
 *  Import an XXX from the database format to the internal format.
 *  Note that the data read will be in network order.  This means
 *  Big-Endian integers and IEEE doubles for floating point.
 *
 *  Apply modeling transformations as well.
 *
 */
int
rt_xxx_import5( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
{
	LOCAL struct rt_xxx_internal	*xxx_ip;
	fastf_t				vv[ELEMENTS_PER_VECT*1];

	RT_CK_DB_INTERNAL(ip)
	BU_CK_EXTERNAL( ep );

	BU_ASSERT_LONG( ep->ext_nbytes, ==, SIZEOF_NETWORK_DOUBLE * 3*4 );

	/* set up the internal structure */
	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_XXX;
	ip->idb_meth = &rt_functab[ID_XXX];
	ip->idb_ptr = bu_malloc( sizeof(struct rt_xxx_internal), "rt_xxx_internal");
	xxx_ip = (struct rt_xxx_internal *)ip->idb_ptr;
	xxx_ip->magic = RT_XXX_INTERNAL_MAGIC;

	/* Convert the data in ep->ext_buf into internal format.
	 * Note the conversion from network data 
	 * (Big Endian ints, IEEE double floating point) to host local data
	 * representations.
	 */
	ntohd( (unsigned char *)&vv, (char *)ep->ext_buf, ELEMENTS_PER_VECT*1 );

	/* Apply the modeling transformation */
	MAT4X3PNT( xxx_ip->v, mat, vv );

	return(0);			/* OK */
}

/*
 *			R T _ X X X _ E X P O R T 5
 *
 *  Export an XXX from internal form to external format.
 *  Note that this means converting all integers to Big-Endian format
 *  and floating point data to IEEE double.
 *
 *  Apply the transformation to mm units as well.
 */
int
rt_xxx_export5( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
{
	struct rt_xxx_internal	*xxx_ip;
	fastf_t			vec[ELEMENTS_PER_VECT];

	RT_CK_DB_INTERNAL(ip);
	if( ip->idb_type != ID_XXX )  return(-1);
	xxx_ip = (struct rt_xxx_internal *)ip->idb_ptr;
	RT_XXX_CK_MAGIC(xxx_ip);

	BU_CK_EXTERNAL(ep);
	ep->ext_nbytes = SIZEOF_NETWORK_DOUBLE * ELEMENTS_PER_VECT;
	ep->ext_buf = (genptr_t)bu_calloc( 1, ep->ext_nbytes, "xxx external");


	/* Since libwdb users may want to operate in units other
	 * than mm, we offer the opportunity to scale the solid
	 * (to get it into mm) on the way out.
	 */
	VSCALE( vec, xxx_ip->v, local2mm );

	/* Convert from internal (host) to database (network) format */
	htond( ep->ext_buf, (unsigned char *)vec, ELEMENTS_PER_VECT*1 );

	return 0;
}

/*
 *			R T _ X X X _ D E S C R I B E
 *
 *  Make human-readable formatted presentation of this solid.
 *  First line describes type of solid.
 *  Additional lines are indented one tab, and give parameter values.
 */
int
rt_xxx_describe( str, ip, verbose, mm2local )
struct bu_vls		*str;
const struct rt_db_internal	*ip;
int			verbose;
double			mm2local;
{
	register struct rt_xxx_internal	*xxx_ip =
		(struct rt_xxx_internal *)ip->idb_ptr;
	char	buf[256];

	RT_XXX_CK_MAGIC(xxx_ip);
	bu_vls_strcat( str, "truncated general xxx (XXX)\n");

	sprintf(buf, "\tV (%g, %g, %g)\n",
		xxx_ip->v[X] * mm2local,
		xxx_ip->v[Y] * mm2local,
		xxx_ip->v[Z] * mm2local );
	bu_vls_strcat( str, buf );

	return(0);
}

/*
 *			R T _ X X X _ I F R E E
 *
 *  Free the storage associated with the rt_db_internal version of this solid.
 */
void
rt_xxx_ifree( ip )
struct rt_db_internal	*ip;
{
	register struct rt_xxx_internal	*xxx_ip;

	RT_CK_DB_INTERNAL(ip);
	xxx_ip = (struct rt_xxx_internal *)ip->idb_ptr;
	RT_XXX_CK_MAGIC(xxx_ip);
	xxx_ip->magic = 0;			/* sanity */

	bu_free( (char *)xxx_ip, "xxx ifree" );
	ip->idb_ptr = GENPTR_NULL;	/* sanity */
}

/*
 *			R T _ X X X _ X F O R M
 *
 *  Create transformed version of internal form.  Free *ip if requested.
 *  Implement this if it's faster than doing an export/import cycle.
 */
int
rt_xxx_xform( op, mat, ip, free )
struct rt_db_internal	*op;
const mat_t		mat;
struct rt_db_internal	*ip;
int			free;
{
}
@


11.22
log
@change conf.h to a wrapped config.h
@
text
@d46 1
a46 1
static const char RCSxxx[] = "@@(#)$Header: /cvs/brlcad/librt/g_xxx.c,v 11.21 2004/02/02 17:39:22 morrison Exp $ (BRL)";
@


11.21
log
@update copyright to include span through 2003
@
text
@d46 1
a46 1
static const char RCSxxx[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_xxx.c,v 11.20 2001/10/02 19:24:30 jra Exp $ (BRL)";
d49 5
a53 1
#include "conf.h"
@


11.20
log
@Routines were not setting idb_major_type in the internal structure
@
text
@d42 1
a42 1
 *	This software is Copyright (C) 1990 by the United States Army.
d46 1
a46 1
static const char RCSxxx[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_xxx.c,v 11.19 2001/04/20 22:29:48 morrison Exp $ (BRL)";
@


11.20.4.1
log
@sync branch with HEAD
@
text
@d42 1
a42 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d46 1
a46 1
static const char RCSxxx[] = "@@(#)$Header$ (BRL)";
@


11.20.6.1
log
@sync to HEAD...
@
text
@d42 1
a42 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d46 1
a46 1
static const char RCSxxx[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/g_xxx.c,v 11.21 2004/02/02 17:39:22 morrison Exp $ (BRL)";
@


11.20.12.1
log
@merge from HEAD
@
text
@d42 1
a42 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d46 1
a46 1
static const char RCSxxx[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_xxx.c,v 11.21 2004/02/02 17:39:22 morrison Exp $ (BRL)";
@


11.20.12.2
log
@merge from head
@
text
@d46 1
a46 1
static const char RCSxxx[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_xxx.c,v 11.20.12.1 2004/02/12 18:37:42 erikg Exp $ (BRL)";
@


11.19
log
@CONST to const
@
text
@d46 1
a46 1
static const char RCSxxx[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_xxx.c,v 11.18 2000/07/10 23:01:37 mike Exp $ (BRL)";
d313 1
d398 1
@


11.18
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d46 1
a46 1
static const char RCSxxx[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_xxx.c,v 11.17 2000/06/30 15:38:04 mike Exp $ (BRL)";
d102 1
a102 1
	CONST struct bn_tol		*tol = &rtip->rti_tol;
d114 1
a114 1
register CONST struct soltab *stp;
d116 1
a116 1
	register CONST struct xxx_specific *xxx =
d141 1
a141 1
	CONST struct bn_tol	*tol = &ap->a_rt_i->rti_tol;
d238 3
a240 3
CONST struct soltab    *stp;
CONST vect_t		min, max;
CONST struct bn_tol    *tol;
d252 2
a253 2
CONST struct rt_tess_tol *ttol;
CONST struct bn_tol	*tol;
d276 2
a277 2
CONST struct rt_tess_tol *ttol;
CONST struct bn_tol	*tol;
d297 3
a299 3
CONST struct bu_external	*ep;
register CONST mat_t		mat;
CONST struct db_i		*dbip;
d332 1
a332 1
CONST struct rt_db_internal	*ip;
d334 1
a334 1
CONST struct db_i		*dbip;
d384 3
a386 3
CONST struct bu_external	*ep;
register CONST mat_t		mat;
CONST struct db_i		*dbip;
d428 1
a428 1
CONST struct rt_db_internal	*ip;
d430 1
a430 1
CONST struct db_i		*dbip;
d467 1
a467 1
CONST struct rt_db_internal	*ip;
d516 1
a516 1
CONST mat_t		mat;
@


11.17
log
@
export methods should not init the external structure, just check them.
@
text
@d46 1
a46 1
static char RCSxxx[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_xxx.c,v 11.16 2000/06/30 15:28:25 mike Exp $ (BRL)";
@


11.16
log
@
I improved the template for import5/export5
@
text
@d46 1
a46 1
static char RCSxxx[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_xxx.c,v 11.15 2000/06/29 19:45:58 butler Exp $ (BRL)";
d344 1
a344 1
	BU_INIT_EXTERNAL(ep);
d440 1
a440 1
	BU_INIT_EXTERNAL(ep);
@


11.15
log
@Converted g_dsp and g_xxx.c to V5 database
@
text
@d46 1
a46 1
static char RCSxxx[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_xxx.c,v 11.14 2000/06/29 18:16:06 butler Exp $ (BRL)";
d312 1
a312 1
	RT_INIT_DB_INTERNAL( ip );
d389 1
a389 2
	union record			*rp;
	vect_t				vv;
d391 1
d393 2
a394 6
	rp = (union record *)ep->ext_buf;
	/* Check record type */
	if( rp->u_id != ID_SOLID )  {
		bu_log("rt_xxx_import: defective record\n");
		return(-1);
	}
a396 1
	RT_INIT_DB_INTERNAL( ip );
d408 1
a408 1
	ntohd( (unsigned char *)&vv, (char *)ep->ext_buf, 3);
d433 1
a433 1
	fastf_t			vec;
d441 1
a441 1
	ep->ext_nbytes = SIZEOF_NETWORK_DOUBLE * 3;
d451 2
a452 7
	/* convert from local editing units to mm and export
	 * to database record format
	 *
	 * Warning: type conversion: double to float
	 */
	VSCALE( vec, xxx_ip->v, local2mm );
	htond((char *)ep->ext_buf, (char *)vec, 3);
d454 1
a454 1
	return(0);
@


11.14
log
@added examle support for v5 database
@
text
@d29 2
a30 1
 *	go to /cad/librt and edit tcl.c to add the new solid to rt_solid_type_lookup[]
d46 1
a46 1
static char RCSxxx[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_xxx.c,v 11.13 2000/04/12 02:34:37 mike Exp $ (BRL)";
@


11.13
log
@
NT port, non-compat4
@
text
@d45 1
a45 1
static char RCSxxx[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_xxx.c,v 11.12 1999/12/18 02:11:14 mike Exp $ (BRL)";
d364 98
@


11.12
log
@
Fixed typo
@
text
@d45 1
a45 1
static char RCSxxx[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_xxx.c,v 11.11 1999/12/18 01:47:33 mike Exp $ (BRL)";
d197 1
a197 1
 	vec_ortho( cvp->crv_pdir, hitp->hit_normal );
@


11.11
log
@
Added rt_xxx_xform()
@
text
@d45 1
a45 1
static char RCSxxx[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_xxx.c,v 11.10 1999/11/17 02:42:03 mike Exp $ (BRL)";
d424 2
a425 1
int rt_xxx_xform( op, mat, ip, free )
d427 1
a427 1
CONT mat_t		mat;
@


11.10
log
@
Added idb_meth and st_meth pointers to allow direct access to per-solid
methods, C++ style.
@
text
@d45 1
a45 1
static char RCSxxx[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_xxx.c,v 11.9 1999/10/12 19:56:29 jra Exp $ (BRL)";
d416 14
@


11.9
log
@Added yet another task
@
text
@d45 1
a45 1
static char RCSxxx[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_xxx.c,v 11.8 1999/10/12 19:50:01 jra Exp $ (BRL)";
d313 1
@


11.8
log
@Added another task in the list of things to do
@
text
@d30 1
a30 1
 *		also add the interface in table.c
d45 1
a45 1
static char RCSxxx[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_xxx.c,v 11.7 1999/10/12 17:14:38 jra Exp $ (BRL)";
@


11.7
log
@Added a few missing steps
@
text
@d29 2
a30 1
 *	go to /cad/librt and edit tcl.c to add the new solid to  rt_solid_type_lookup[]
d45 1
a45 1
static char RCSxxx[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_xxx.c,v 11.6 1999/05/27 19:10:44 mike Exp $ (BRL)";
@


11.6
log
@
sed4
@
text
@d12 1
d23 1
d28 2
d44 1
a44 1
static char RCSxxx[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_xxx.c,v 11.5 1998/03/26 07:55:57 mike Exp $ (BRL)";
@


11.5
log
@Added some CONSTs.
@
text
@d40 1
a40 1
static char RCSxxx[] = "@@(#)$Header: /m/cad/librt/RCS/g_xxx.c,v 11.4 1998/03/26 07:52:34 mike Exp mike $ (BRL)";
d65 1
a65 1
#define RT_XXX_CK_MAGIC(_p)	RT_CKMAG(_p,RT_XXX_INTERNAL_MAGIC,"rt_xxx_internal")
d96 1
a96 1
	CONST struct rt_tol		*tol = &rtip->rti_tol;
d135 1
a135 1
	CONST struct rt_tol	*tol = &ap->a_rt_i->rti_tol;
d224 1
a224 1
	rt_free( (char *)xxx, "xxx_specific" );
d244 1
a244 1
struct rt_list		*vhead;
d247 1
a247 1
CONST struct rt_tol	*tol;
d271 1
a271 1
CONST struct rt_tol	*tol;
d291 1
a291 1
CONST struct rt_external	*ep;
d298 1
a298 1
	RT_CK_EXTERNAL( ep );
d302 1
a302 1
		rt_log("rt_xxx_import: defective record\n");
d308 1
a308 1
	ip->idb_ptr = rt_malloc( sizeof(struct rt_xxx_internal), "rt_xxx_internal");
d324 1
a324 1
struct rt_external		*ep;
d337 1
a337 1
	RT_INIT_EXTERNAL(ep);
d339 1
a339 1
	ep->ext_buf = (genptr_t)rt_calloc( 1, ep->ext_nbytes, "xxx external");
d371 1
a371 1
struct rt_vls		*str;
d381 1
a381 1
	rt_vls_strcat( str, "truncated general xxx (XXX)\n");
d387 1
a387 1
	rt_vls_strcat( str, buf );
d408 1
a408 1
	rt_free( (char *)xxx_ip, "xxx ifree" );
@


11.4
log
@CONST rt_tol
@
text
@d40 1
a40 1
static char RCSxxx[] = "@@(#)$Header: /m/cad/librt/RCS/g_xxx.c,v 11.3 1998/03/19 16:04:57 jra Exp mike $ (BRL)";
d231 4
a234 1
rt_xxx_class()
d236 1
a236 1
	return(0);
d271 1
a271 1
struct rt_tol		*tol;
d372 1
a372 1
struct rt_db_internal	*ip;
@


11.3
log
@Added dbip arg to import and export routines.
@
text
@d40 1
a40 1
static char RCSxxx[] = "@@(#)$Header: /m/cad/librt/RCS/g_xxx.c,v 11.2 1997/09/22 05:16:19 butler Exp jra $ (BRL)";
d244 1
a244 1
struct rt_tol		*tol;
@


11.2
log
@misc changes to genericize
@
text
@d40 1
a40 1
static char RCSxxx[] = "@@(#)$Header: /m/cad/librt/RCS/g_xxx.c,v 11.1 1995/01/04 09:57:10 mike Rel4_4 butler $ (BRL)";
d286 1
a286 1
rt_xxx_import( ip, ep, mat )
d290 1
d320 1
a320 1
rt_xxx_export( ep, ip, local2mm )
d324 1
@


11.1
log
@Release_4.4
@
text
@d7 21
d40 1
a40 1
static char RCSxxx[] = "@@(#)$Header: /m/cad/librt/RCS/g_xxx.c,v 10.3 94/08/10 18:42:47 gdurf Exp $ (BRL)";
d52 1
d55 5
d66 1
d68 1
d94 1
a94 1
	struct rt_xxx_internal		*xip;
d99 2
a100 2
	xip = (struct rt_xxx_internal *)ip->idb_ptr;
	RT_XXX_CK_MAGIC(xip);
d135 1
a135 1
	CONST struct rt_tol	*tol = &rtip->rti_tol;
d246 1
a246 1
	LOCAL struct rt_xxx_internal	*xip;
d249 2
a250 2
	xip = (struct rt_xxx_internal *)ip->idb_ptr;
	RT_XXX_CK_MAGIC(xip);
d270 1
a270 1
	LOCAL struct rt_xxx_internal	*xip;
d273 2
a274 2
	xip = (struct rt_xxx_internal *)ip->idb_ptr;
	RT_XXX_CK_MAGIC(xip);
d291 1
a291 1
	LOCAL struct rt_xxx_internal	*xip;
d305 4
a308 2
	xip = (struct rt_xxx_internal *)ip->idb_ptr;
	xip->magic = RT_XXX_INTERNAL_MAGIC;
d324 1
a324 1
	struct rt_xxx_internal	*xip;
d329 2
a330 2
	xip = (struct rt_xxx_internal *)ip->idb_ptr;
	RT_XXX_CK_MAGIC(xip);
d338 15
a352 1
	rec->s.s_type = XXX;
d371 1
a371 1
	register struct rt_xxx_internal	*xip =
d375 1
a375 1
	RT_XXX_CK_MAGIC(xip);
d379 3
a381 3
		xip->v[X] * mm2local,
		xip->v[Y] * mm2local,
		xip->v[Z] * mm2local );
d396 1
a396 1
	register struct rt_xxx_internal	*xip;
d399 3
a401 3
	xip = (struct rt_xxx_internal *)ip->idb_ptr;
	RT_XXX_CK_MAGIC(xip);
	xip->magic = 0;			/* sanity */
d403 1
a403 1
	rt_free( (char *)xip, "xxx ifree" );
@


10.3
log
@Added include of conf.h
@
text
@d19 1
a19 1
static char RCSxxx[] = "@@(#)$Header: /m/cad/librt/RCS/g_xxx.c,v 10.2 1991/11/27 15:11:43 mmark Exp gdurf $ (BRL)";
@


10.2
log
@checked magic # BEFORE setting it to 0 in ifree
@
text
@d19 1
a19 1
static char RCSxxx[] = "@@(#)$Header: /m/cad/librt/RCS/g_xxx.c,v 10.1 91/10/12 06:40:29 mike Rel4_0 Locker: mmark $ (BRL)";
d21 2
@


10.1
log
@Release_4.0
@
text
@d19 1
a19 1
static char RCSxxx[] = "@@(#)$Header: /m/cad/librt/RCS/g_xxx.c,v 1.9 91/06/30 00:11:02 mike Exp $ (BRL)";
d27 1
d353 1
a354 1
	RT_XXX_CK_MAGIC(xip);
@


1.9
log
@Some args to ft_print, ft_import, and ft_export became CONST
@
text
@d19 1
a19 1
static char RCSxxx[] = "@@(#)$Header: /m/cad/librt/RCS/g_xxx.c,v 1.8 91/06/22 22:30:44 mike Exp $ (BRL)";
@


1.8
log
@Tolerance can be had from ap->a_rt_i->rti_tol, so it is no longer
passed as a parameter on ft_prep, ft_shot, or ft_vshot.
ft_vshot calling sequence also changed to use application structure.
@
text
@d19 1
a19 1
static char RCSxxx[] = "@@(#)$Header: /m/cad/librt/RCS/g_xxx.c,v 1.7 91/05/18 03:01:50 mike Exp $ (BRL)";
d76 1
a76 1
register struct soltab *stp;
d78 1
a78 1
	register struct xxx_specific *xxx =
d255 3
a257 3
struct rt_db_internal	*ip;
struct rt_external	*ep;
register mat_t		mat;
d286 3
a288 3
struct rt_external	*ep;
struct rt_db_internal	*ip;
double			local2mm;
@


1.7
log
@Converted to new tolerance interface
@
text
@d19 1
a19 1
static char RCSxxx[] = "@@(#)$Header: /m/cad/librt/RCS/g_xxx.c,v 1.6 91/02/07 00:00:25 mike Exp $ (BRL)";
d57 1
a57 1
rt_xxx_prep( stp, ip, rtip, tol )
a60 1
CONST struct rt_tol	*tol;
d64 1
d94 1
a94 1
rt_xxx_shot( stp, rp, ap, seghead, tol )
a98 1
CONST struct rt_tol	*tol;
d103 1
d105 1
a105 1
	return(2);			/* HIT */
d116 1
a116 1
rt_xxx_vshot( stp, rp, segp, n, resp, tol )
d121 1
a121 2
struct resource         *resp; /* pointer to a list of free segs */
CONST struct rt_tol	*tol;
d123 1
a123 1
	rt_vstub( stp, rp, segp, n, resp );
@


1.6
log
@Changed some comments to XXX
@
text
@d19 1
a19 1
static char RCSxxx[] = "@@(#)$Header: /m/cad/librt/RCS/g_xxx.c,v 1.5 91/01/28 23:53:26 mike Exp $ (BRL)";
d57 1
a57 1
rt_xxx_prep( stp, ip, rtip )
d61 1
d94 1
a94 1
rt_xxx_shot( stp, rp, ap, seghead )
d99 1
d116 1
a116 1
rt_xxx_vshot( stp, rp, segp, n, resp)
d122 1
d209 1
a209 1
rt_xxx_plot( vhead, ip, abs_tol, rel_tol, norm_tol )
d212 2
a213 3
double			abs_tol;
double			rel_tol;
double			norm_tol;
d232 1
a232 1
rt_xxx_tess( r, m, ip, abs_tol, rel_tol, norm_tol )
d236 2
a237 3
double			abs_tol;
double			rel_tol;
double			norm_tol;
@


1.5
log
@Converted to new struct rt_vlist (''chunky vlist'')
@
text
@d19 1
a19 1
static char RCSxxx[] = "@@(#)$Header: /m/cad/librt/RCS/g_xxx.c,v 1.4 91/01/26 05:09:09 mike Exp $ (BRL)";
d280 1
a280 1
 *			R T _ T G C _ E X P O R T
d310 1
a310 1
 *			R T _ T G C _ D E S C R I B E
d340 1
a340 1
 *			R T _ T G C _ I F R E E
@


1.4
log
@Changed to new import/export style
@
text
@d19 1
a19 1
static char RCSxxx[] = "@@(#)$Header: /m/cad/librt/RCS/g_xxx.c,v 1.3 91/01/25 20:36:17 mike Exp $ (BRL)";
d207 1
a207 1
struct vlhead		*vhead;
@


1.3
log
@Added rt_ prefix to _internal structure
@
text
@d19 1
a19 1
static char RCSxxx[] = "@@(#)$Header: /m/cad/librt/RCS/g_xxx.c,v 1.2 90/10/11 02:37:41 mike Exp $ (BRL)";
d32 1
a32 1
	vect_t	xxx_V;
d57 1
a57 1
rt_xxx_prep( stp, rec, rtip )
d59 1
a59 1
union record		*rec;
d62 6
a67 1
	register struct xxx_specific *xxx;
d106 1
a106 1
#define SEG_MISS(SEG)		(SEG).seg_stp=(struct soltab *) 0;	
d206 6
a211 8
rt_xxx_plot( rp, mat, vhead, dp, abs_tol, rel_tol, norm_tol )
union record	*rp;
mat_t		mat;
struct vlhead	*vhead;
struct directory *dp;
double		abs_tol;
double		rel_tol;
double		norm_tol;
d213 6
d224 4
d230 1
a230 1
rt_xxx_tess( r, m, rp, mat, dp, abs_tol, rel_tol, norm_tol )
d233 1
a233 3
union record		*rp;
mat_t			mat;
struct directory	*dp;
d238 6
d249 3
d254 3
a256 3
rt_xxx_import( xxx, rp, mat )
struct xxx_internal	*xxx;
union record		*rp;
d259 17
d277 80
@


1.2
log
@Enhanced with more arg declarations,
neatened up some comments,
added vector stubs and error returns for a better "first-cut".
@
text
@d19 1
a19 1
static char RCSxxx[] = "@@(#)$Header: /m/cad/librt/RCS/g_xxx.c,v 1.1 90/10/06 02:05:30 mike Exp $ (BRL)";
d30 2
a31 1
struct xxx_internal {
d34 2
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 *			X X X . C
d12 1
a12 1
 *	Aberdeen Proving Ground, Maryland  21005
d15 1
a15 1
 *	This software is Copyright (C) 1989 by the United States Army.
d19 1
a19 1
static char RCSsph[] = "@@(#)$Header: g_xxx.c,v 9.1 89/05/19 05:56:26 mike Rel3_5 $ (BRL)";
d39 1
a39 1
 *  			X X X _ P R E P
d54 1
a54 1
xxx_prep( stp, rec, rtip )
d56 1
a57 1
union record		*rec;
d62 3
d66 1
a66 1
xxx_print( stp )
d74 1
a74 1
 *  			X X X _ S H O T
d85 1
a85 1
xxx_shot( stp, rp, ap, seghead )
d101 1
a101 1
 *			S P H _ V S H O T
d106 1
a106 1
xxx_vshot( stp, rp, segp, n, resp)
d113 1
a113 1
	register struct xxx_specific *xxx;
d117 1
a117 1
 *  			X X X _ N O R M
d122 4
a125 4
xxx_norm( hitp, stp, rp )
register struct hit *hitp;
struct soltab *stp;
register struct xray *rp;
d134 1
a134 1
 *			X X X _ C U R V E
d139 1
a139 1
xxx_curve( cvp, hitp, stp )
d141 2
a142 2
register struct hit *hitp;
struct soltab *stp;
d154 1
a154 1
 *  			X X X _ U V
d162 5
a166 5
xxx_uv( ap, stp, hitp, uvp )
struct application *ap;
struct soltab *stp;
register struct hit *hitp;
register struct uvcoord *uvp;
d173 1
a173 1
 *		X X X _ F R E E
d176 1
a176 1
xxx_free( stp )
d185 3
d189 1
a189 1
xxx_class()
d194 3
d198 8
a205 1
xxx_plot()
d207 1
d210 3
d214 9
a222 1
xxx_tess()
d224 1
d227 3
d231 1
a231 1
xxx_import( xxx, rp, matp )
d234 1
a234 1
register matp_t		matp;
@
