head	11.56;
access;
symbols
	ansi-20040405-merged:11.52.2.2
	postmerge-20040405-ansi:11.54
	premerge-20040404-ansi:11.53
	postmerge-autoconf:11.53
	autoconf-freeze:11.52.10.2
	premerge-autoconf:11.53
	ansi-20040316-freeze:11.52.2.1
	postmerge-20040315-windows:11.53
	premerge-20040315-windows:11.53
	windows-20040315-freeze:11.52.4.1
	autoconf-20031203:11.52
	autoconf-20031202:11.52
	autoconf-branch:11.52.0.10
	phong-branch:11.52.0.8
	photonmap-branch:11.52.0.6
	rel-6-1-DP:11.52
	windows-branch:11.52.0.4
	rel-6-0-2:11.50
	ansi-branch:11.52.0.2
	rel-6-0-1-branch:11.50.0.2
	hartley-6-0-post:11.51
	hartley-6-0-pre:11.50
	rel-6-0-1:11.50
	rel-6-0:11.49
	rel-5-4:11.43
	offsite-5-3-pre:11.47
	rel-5-3:11.43
	rel-5-2:11.43
	rel-5-1-branch:11.43.0.2
	rel-5-1:11.43
	rel-5-0:11.40
	rel-5-0-beta:11.39
	rel-4-5:11.38
	ctj-4-5-post:11.38
	ctj-4-5-pre:11.38
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.56
date	2004.05.21.18.07.32;	author morrison;	state dead;
branches;
next	11.55;

11.55
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.54;

11.54
date	2004.04.05.08.48.57;	author morrison;	state Exp;
branches;
next	11.53;

11.53
date	2004.02.02.17.39.22;	author morrison;	state Exp;
branches;
next	11.52;

11.52
date	2002.08.20.17.08.03;	author jra;	state Exp;
branches
	11.52.2.1
	11.52.4.1
	11.52.10.1;
next	11.51;

11.51
date	2002.08.15.20.55.14;	author hartley;	state Exp;
branches;
next	11.50;

11.50
date	2002.05.12.03.49.42;	author jra;	state Exp;
branches;
next	11.49;

11.49
date	2001.05.17.20.05.25;	author morrison;	state Exp;
branches;
next	11.48;

11.48
date	2001.04.05.19.35.34;	author morrison;	state Exp;
branches;
next	11.47;

11.47
date	2000.08.31.04.07.14;	author mike;	state Exp;
branches;
next	11.46;

11.46
date	2000.08.24.04.29.16;	author mike;	state Exp;
branches;
next	11.45;

11.45
date	2000.08.21.02.02.31;	author butler;	state Exp;
branches;
next	11.44;

11.44
date	2000.07.10.23.01.38;	author mike;	state Exp;
branches;
next	11.43;

11.43
date	2000.03.29.02.54.04;	author mike;	state Exp;
branches;
next	11.42;

11.42
date	99.12.30.15.36.02;	author jra;	state Exp;
branches;
next	11.41;

11.41
date	99.11.24.21.44.30;	author mike;	state Exp;
branches;
next	11.40;

11.40
date	99.06.03.01.43.36;	author mike;	state Exp;
branches;
next	11.39;

11.39
date	98.03.09.15.18.18;	author jra;	state Exp;
branches;
next	11.38;

11.38
date	97.03.21.14.22.21;	author jra;	state Exp;
branches;
next	11.37;

11.37
date	96.10.21.02.50.49;	author jra;	state Exp;
branches;
next	11.36;

11.36
date	96.10.11.17.57.30;	author jra;	state Exp;
branches;
next	11.35;

11.35
date	96.09.27.08.27.30;	author mike;	state Exp;
branches;
next	11.34;

11.34
date	96.09.14.03.42.36;	author butler;	state Exp;
branches;
next	11.33;

11.33
date	96.07.12.12.17.41;	author jra;	state Exp;
branches;
next	11.32;

11.32
date	96.07.02.14.24.16;	author jra;	state Exp;
branches;
next	11.31;

11.31
date	96.06.27.18.15.51;	author jra;	state Exp;
branches;
next	11.30;

11.30
date	96.05.16.21.57.51;	author jra;	state Exp;
branches;
next	11.29;

11.29
date	96.04.30.20.31.14;	author jra;	state Exp;
branches;
next	11.28;

11.28
date	96.04.26.15.07.59;	author jra;	state Exp;
branches;
next	11.27;

11.27
date	96.04.23.19.33.51;	author jra;	state Exp;
branches;
next	11.26;

11.26
date	96.04.23.18.51.51;	author jra;	state Exp;
branches;
next	11.25;

11.25
date	96.04.22.12.34.39;	author jra;	state Exp;
branches;
next	11.24;

11.24
date	96.03.28.14.27.59;	author jra;	state Exp;
branches;
next	11.23;

11.23
date	96.03.25.21.17.36;	author jra;	state Exp;
branches;
next	11.22;

11.22
date	96.03.18.00.01.19;	author jra;	state Exp;
branches;
next	11.21;

11.21
date	96.03.08.19.49.03;	author jra;	state Exp;
branches;
next	11.20;

11.20
date	96.03.07.15.18.52;	author jra;	state Exp;
branches;
next	11.19;

11.19
date	96.03.05.21.25.29;	author jra;	state Exp;
branches;
next	11.18;

11.18
date	95.06.17.02.43.49;	author mike;	state Exp;
branches;
next	11.17;

11.17
date	95.05.05.19.27.52;	author jra;	state Exp;
branches;
next	11.16;

11.16
date	95.02.28.00.40.36;	author mike;	state Exp;
branches;
next	11.15;

11.15
date	95.02.27.23.54.15;	author mike;	state Exp;
branches;
next	11.14;

11.14
date	95.02.21.14.23.02;	author jra;	state Exp;
branches;
next	11.13;

11.13
date	95.02.21.11.16.29;	author butler;	state Exp;
branches;
next	11.12;

11.12
date	95.02.21.10.57.47;	author butler;	state Exp;
branches;
next	11.11;

11.11
date	95.02.21.03.04.24;	author butler;	state Exp;
branches;
next	11.10;

11.10
date	95.02.17.19.35.33;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	95.02.17.09.14.19;	author butler;	state Exp;
branches;
next	11.8;

11.8
date	95.02.16.03.33.08;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	95.02.15.00.13.40;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	95.02.14.00.48.50;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	95.02.11.01.53.27;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	95.01.20.20.00.15;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	95.01.20.19.18.08;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	95.01.20.02.19.30;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.57.25;	author mike;	state Rel4_4;
branches;
next	10.65;

10.65
date	94.12.27.17.47.59;	author mike;	state Exp;
branches;
next	10.64;

10.64
date	94.12.22.00.58.01;	author mike;	state Exp;
branches;
next	10.63;

10.63
date	94.12.16.16.26.02;	author jra;	state Exp;
branches;
next	10.62;

10.62
date	94.11.30.03.58.12;	author butler;	state Exp;
branches;
next	10.61;

10.61
date	94.11.04.06.58.17;	author mike;	state Exp;
branches;
next	10.60;

10.60
date	94.09.21.03.37.22;	author mike;	state Exp;
branches;
next	10.59;

10.59
date	94.09.16.20.20.56;	author mike;	state Exp;
branches;
next	10.58;

10.58
date	94.09.02.01.14.48;	author mike;	state Exp;
branches;
next	10.57;

10.57
date	94.09.02.00.31.47;	author mike;	state Exp;
branches;
next	10.56;

10.56
date	94.08.10.18.48.22;	author gdurf;	state Exp;
branches;
next	10.55;

10.55
date	94.08.09.19.37.24;	author mike;	state Exp;
branches;
next	10.54;

10.54
date	94.07.12.18.27.30;	author mike;	state Exp;
branches;
next	10.53;

10.53
date	94.07.04.02.47.21;	author mike;	state Exp;
branches;
next	10.52;

10.52
date	94.07.03.23.23.46;	author mike;	state Exp;
branches;
next	10.51;

10.51
date	94.07.03.23.01.46;	author mike;	state Exp;
branches;
next	10.50;

10.50
date	94.07.03.22.34.12;	author mike;	state Exp;
branches;
next	10.49;

10.49
date	94.07.03.22.01.14;	author mike;	state Exp;
branches;
next	10.48;

10.48
date	94.04.14.07.30.31;	author mike;	state Exp;
branches;
next	10.47;

10.47
date	94.04.13.04.48.01;	author mike;	state Exp;
branches;
next	10.46;

10.46
date	94.04.13.04.29.28;	author mike;	state Exp;
branches;
next	10.45;

10.45
date	94.04.08.14.00.38;	author jra;	state Exp;
branches;
next	10.44;

10.44
date	94.04.06.16.10.09;	author jra;	state Exp;
branches;
next	10.43;

10.43
date	94.04.06.15.39.28;	author jra;	state Exp;
branches;
next	10.42;

10.42
date	94.03.11.13.52.33;	author jra;	state Exp;
branches;
next	10.41;

10.41
date	94.03.11.00.00.16;	author mike;	state Exp;
branches;
next	10.40;

10.40
date	94.03.09.19.22.01;	author mike;	state Exp;
branches;
next	10.39;

10.39
date	94.03.04.22.27.10;	author mike;	state Exp;
branches;
next	10.38;

10.38
date	94.03.04.22.07.49;	author mike;	state Exp;
branches;
next	10.37;

10.37
date	94.02.22.20.57.12;	author mike;	state Exp;
branches;
next	10.36;

10.36
date	94.02.22.20.43.00;	author mike;	state Exp;
branches;
next	10.35;

10.35
date	94.02.10.18.47.35;	author mike;	state Exp;
branches;
next	10.34;

10.34
date	94.02.04.03.45.01;	author mike;	state Exp;
branches;
next	10.33;

10.33
date	94.02.03.21.34.03;	author mike;	state Exp;
branches;
next	10.32;

10.32
date	94.02.01.23.41.00;	author mike;	state Exp;
branches;
next	10.31;

10.31
date	94.01.07.13.04.10;	author jra;	state Exp;
branches;
next	10.30;

10.30
date	94.01.04.09.54.01;	author jra;	state Exp;
branches;
next	10.29;

10.29
date	93.12.03.03.35.18;	author mike;	state Exp;
branches;
next	10.28;

10.28
date	93.10.22.22.27.43;	author mike;	state Exp;
branches;
next	10.27;

10.27
date	93.10.20.01.38.22;	author mike;	state Exp;
branches;
next	10.26;

10.26
date	93.05.20.17.13.25;	author mike;	state Exp;
branches;
next	10.25;

10.25
date	93.05.15.00.01.19;	author mike;	state Exp;
branches;
next	10.24;

10.24
date	93.04.07.05.54.49;	author mike;	state Exp;
branches;
next	10.23;

10.23
date	93.03.27.02.11.30;	author mike;	state Exp;
branches;
next	10.22;

10.22
date	93.03.25.04.44.52;	author mike;	state Exp;
branches;
next	10.21;

10.21
date	93.03.25.04.17.53;	author mike;	state Exp;
branches;
next	10.20;

10.20
date	93.03.25.04.04.49;	author mike;	state Exp;
branches;
next	10.19;

10.19
date	93.03.23.22.50.44;	author mike;	state Exp;
branches;
next	10.18;

10.18
date	93.03.22.23.06.51;	author mike;	state Exp;
branches;
next	10.17;

10.17
date	93.03.20.04.50.26;	author mike;	state Exp;
branches;
next	10.16;

10.16
date	93.03.19.05.23.03;	author mike;	state Exp;
branches;
next	10.15;

10.15
date	93.03.17.05.09.17;	author mike;	state Exp;
branches;
next	10.14;

10.14
date	93.03.17.03.18.32;	author mike;	state Exp;
branches;
next	10.13;

10.13
date	93.03.17.01.19.34;	author mike;	state Exp;
branches;
next	10.12;

10.12
date	93.03.17.00.49.19;	author mike;	state Exp;
branches;
next	10.11;

10.11
date	93.03.16.06.59.38;	author mike;	state Exp;
branches;
next	10.10;

10.10
date	93.03.16.02.41.52;	author mike;	state Exp;
branches;
next	10.9;

10.9
date	93.03.16.02.10.12;	author mike;	state Exp;
branches;
next	10.8;

10.8
date	93.03.03.01.50.50;	author mike;	state Exp;
branches;
next	10.7;

10.7
date	92.12.16.06.30.39;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	92.12.14.16.00.26;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	92.08.06.00.38.43;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	92.08.05.21.59.09;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	92.07.20.23.05.24;	author butler;	state Exp;
branches;
next	10.2;

10.2
date	92.02.25.00.07.43;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.40.41;	author mike;	state Rel4_0;
branches;
next	1.13;

1.13
date	91.06.29.22.13.57;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	91.06.17.20.41.58;	author butler;	state Exp;
branches;
next	1.11;

1.11
date	91.06.04.13.50.12;	author butler;	state Exp;
branches;
next	1.10;

1.10
date	91.05.25.01.32.14;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	91.05.23.00.20.04;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	91.05.18.03.02.06;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	91.05.17.20.33.24;	author butler;	state Exp;
branches;
next	1.6;

1.6
date	91.04.29.15.41.05;	author butler;	state Exp;
branches;
next	1.5;

1.5
date	91.04.01.20.02.00;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	91.03.01.22.40.50;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	91.03.01.20.06.29;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	91.02.07.20.32.32;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	90.12.08.03.47.48;	author mike;	state Exp;
branches;
next	;

11.52.2.1
date	2002.09.19.18.01.38;	author morrison;	state Exp;
branches;
next	11.52.2.2;

11.52.2.2
date	2004.03.17.21.18.51;	author morrison;	state Exp;
branches;
next	;

11.52.4.1
date	2004.03.11.23.43.40;	author morrison;	state Exp;
branches;
next	;

11.52.10.1
date	2004.02.12.18.37.43;	author erikg;	state Exp;
branches;
next	11.52.10.2;

11.52.10.2
date	2004.03.15.14.07.24;	author erikg;	state Exp;
branches;
next	;


desc
@NMG classifier code
@


11.56
log
@moved to src/
@
text
@/*
 *			N M G _ C L A S S . C
 *
 *  Subroutines to classify one object with respect to another.
 *  Possible classifications are AinB, AoutB, AinBshared, AinBanti.
 *
 *  The first set of routines (nmg_class_pt_xxx) are used to classify
 *  an arbitrary point specified by it's Cartesian coordinates,
 *  against various kinds of NMG elements.
 *  nmg_class_pt_f() and nmg_class_pt_s() are available to
 *  applications programmers for direct use, and have no side effects.
 *
 *  The second set of routines (class_xxx_vs_s) are used only to support
 *  the routine nmg_class_shells() mid-way through the NMG Boolean
 *  algorithm.  These routines operate with special knowledge about
 *  the state of the data structures after the intersector has been called,
 *  and depends on all geometric equivalences to have been converted into
 *  shared topology.
 *
 *  Authors -
 *	Lee A. Butler
 *	Michael John Muuss
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Pacakge" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1993-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/nmg_class.c,v 11.55 2004/05/10 15:30:46 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif


#include <stdio.h>
#include <math.h>
#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "nmg.h"
#include "raytrace.h"
#include "./debug.h"
#include "plot3.h"

extern int nmg_class_nothing_broken;

/* XXX These should go the way of the dodo bird. */
#define INSIDE	32
#define ON_SURF	64
#define OUTSIDE	128

/*	Structure for keeping track of how close a point/vertex is to
 *	its potential neighbors.
 */
struct neighbor {
	union {
		const struct vertexuse *vu;
		const struct edgeuse *eu;
	} p;
	/* XXX For efficiency, this should have been dist_sq */
	fastf_t	dist;	/* distance from point to neighbor */
	int	class;	/* Classification of this neighbor */
};

static void	joint_hitmiss2 RT_ARGS( (struct neighbor *closest,
			const struct edgeuse *eu, const point_t pt,
			int code) );
static void	nmg_class_pt_e RT_ARGS( (struct neighbor *closest,
			const point_t pt, const struct edgeuse *eu,
			const struct bn_tol *tol) );
static void	nmg_class_pt_l RT_ARGS( (struct neighbor *closest, 
			const point_t pt, const struct loopuse *lu,
			const struct bn_tol *tol) );
static int	class_vu_vs_s RT_ARGS( (struct vertexuse *vu, struct shell *sB,
			long *classlist[4], const struct bn_tol	*tol) );
static int	class_eu_vs_s RT_ARGS( (struct edgeuse *eu, struct shell *s,
			long *classlist[4], const struct bn_tol	*tol) );
static int	class_lu_vs_s RT_ARGS( (struct loopuse *lu, struct shell *s,
			long *classlist[4], const struct bn_tol	*tol) );
static void	class_fu_vs_s RT_ARGS( (struct faceuse *fu, struct shell *s,
			long *classlist[4], const struct bn_tol	*tol) );

/*
 *			N M G _ C L A S S _ S T A T U S
 *
 *  Convert classification status to string.
 */
const char *
nmg_class_status(int status)
{
	switch(status)  {
	case INSIDE:
		return "INSIDE";
	case OUTSIDE:
		return "OUTSIDE";
	case ON_SURF:
		return "ON_SURF";
	}
	return "BOGUS_CLASS_STATUS";
}

/*
 *			N M G _ P R _ C L A S S _ S T A T U S
 */
void
nmg_pr_class_status(char *prefix, int status)
{
	bu_log("%s has classification status %s\n",
		prefix, nmg_class_status(status) );
}

/*
 *			J O I N T _ H I T M I S S 2
 *
 *	The ray hit an edge.  We have to decide whether it hit the
 *	edge, or missed it.
 *
 *  XXX DANGER:  This routine does not work well.
 *
 *  Called by -
 *	nmg_class_pt_e
 */
static void 
joint_hitmiss2(struct neighbor *closest, const struct edgeuse *eu, const fastf_t *pt, int code)
{
	const struct edgeuse *eu_rinf;

	eu_rinf = nmg_faceradial(eu);

	if (rt_g.NMG_debug & DEBUG_CLASSIFY) {
		bu_log("joint_hitmiss2\n");
	}
	if( eu_rinf == eu )  {
		rt_bomb("joint_hitmiss2: radial eu is me?\n");
	}
	/* If eu_rinf == eu->eumate_p, thats OK, this is a dangling face,
	 * or a face that has not been fully hooked up yet.
	 * It's OK as long the the orientations both match.
	 */
	if( eu->up.lu_p->orientation == eu_rinf->up.lu_p->orientation ) {
		if (eu->up.lu_p->orientation == OT_SAME) {
			closest->class = NMG_CLASS_AonBshared;
		} else if (eu->up.lu_p->orientation == OT_OPPOSITE) {
			closest->class = NMG_CLASS_AoutB;
		} else {
			nmg_pr_lu_briefly(eu->up.lu_p, (char *)0);
			rt_bomb("joint_hitmiss2: bad loop orientation\n");
		}
		closest->dist = 0.0;
		switch(code)  {
		case 0:
			/* Hit the edge */
			closest->p.eu = eu;
			break;
		case 1:
			/* Hit first vertex */
			closest->p.vu = eu->vu_p;
			break;
		case 2:
			/* Hit second vertex */
			closest->p.vu = BU_LIST_PNEXT_CIRC(edgeuse,eu)->vu_p;
			break;
		}
		if (rt_g.NMG_debug & DEBUG_CLASSIFY) bu_log("\t\t%s\n", nmg_class_name(closest->class) );
	    	return;
	}

	/* XXX What goes here? */
	rt_bomb("nmg_class.c/joint_hitmiss2() unable to resolve ray/edge hit\n");
	bu_log("joint_hitmiss2: NO CODE HERE, assuming miss\n");

	if (rt_g.NMG_debug & (DEBUG_CLASSIFY|DEBUG_NMGRT) )  {
		nmg_euprint("Hard question time", eu);
		bu_log(" eu_rinf=x%x, eu->eumate_p=x%x, eu=x%x\n", eu_rinf, eu->eumate_p, eu);
		bu_log(" eu lu orient=%s, eu_rinf lu orient=%s\n",
			nmg_orientation(eu->up.lu_p->orientation),
			nmg_orientation(eu_rinf->up.lu_p->orientation) );
	}
}

/*
 *			N M G _ C L A S S _ P T _ E
 *
 *  XXX DANGER:  This routine does not work well.
 *
 *  Given the Cartesian coordinates of a point, determine if the point
 *  is closer to this edgeuse than the previous neighbor(s) as given
 *  in the "closest" structure.
 *  If it is, record how close the point is, and whether it is IN, ON, or OUT.
 *  The neighor's "p" element will indicate the edgeuse or vertexuse closest.
 *
 *  This routine should print everything indented two tab stops.
 *
 *  Implicit Return -
 *	Updated "closest" structure if appropriate.
 *
 *  Called by -
 *	nmg_class_pt_l
 */
static void
nmg_class_pt_e(struct neighbor *closest, const fastf_t *pt, const struct edgeuse *eu, const struct bn_tol *tol)
{
	vect_t	ptvec;	/* vector from lseg to pt */
	vect_t	left;	/* vector left of edge -- into inside of loop */
	const fastf_t	*eupt;
	const fastf_t	*matept;
	point_t pca;	/* point of closest approach from pt to edge lseg */
	fastf_t dist;	/* distance from pca to pt */
	fastf_t dot;
	int	code;

	NMG_CK_EDGEUSE(eu);
	NMG_CK_EDGEUSE(eu->eumate_p);
	NMG_CK_VERTEX_G(eu->vu_p->v_p->vg_p);
	NMG_CK_VERTEX_G(eu->eumate_p->vu_p->v_p->vg_p);
	BN_CK_TOL(tol);
	VSETALL(left, 0);

	eupt = eu->vu_p->v_p->vg_p->coord;
	matept = eu->eumate_p->vu_p->v_p->vg_p->coord;

	if (rt_g.NMG_debug & DEBUG_CLASSIFY) {
		VPRINT("nmg_class_pt_e\tPt", pt);
		nmg_euprint("          \tvs. eu", eu);
	}
	/*
	 * Note that "pca" can be one of the edge endpoints,
	 * even if "pt" is far, far away.  This can be confusing.
	 *
	 * Some compilers don't get that fastf_t * and point_t are related
	 * So we have to pass the whole bloody mess for the point arguments.
	 */
	code = bn_dist_pt3_lseg3( &dist, pca, eu->vu_p->v_p->vg_p->coord,
		eu->eumate_p->vu_p->v_p->vg_p->coord,
		pt, tol);
	if( code <= 0 )  dist = 0;
	if (rt_g.NMG_debug & DEBUG_CLASSIFY) {
		bu_log("          \tcode=%d, dist: %g\n", code, dist);
		VPRINT("          \tpca:", pca);
	}

	if (dist >= closest->dist + tol->dist ) {
 		if(rt_g.NMG_debug & DEBUG_CLASSIFY) {
 			bu_log("\t\tskipping, earlier eu is closer (%g)\n", closest->dist);
 		}
		return;
 	}
 	if( dist >= closest->dist - tol->dist )  {
 		/*
 		 *  Distances are very nearly the same.
		 *
 		 *  If closest eu and this eu are from the same lu,
 		 *  and the earlier result was OUT, that's all it takes
 		 *  to decide things.
 		 */
 		if( closest->p.eu && closest->p.eu->up.lu_p == eu->up.lu_p )  {
 			if( closest->class == NMG_CLASS_AoutB ||
			    closest->class == NMG_CLASS_AonBshared )  {
		 		if(rt_g.NMG_debug & DEBUG_CLASSIFY)
					bu_log("\t\tSkipping, earlier eu from same lu at same dist, is OUT or ON.\n");
	 			return;
 			}
	 		if(rt_g.NMG_debug & DEBUG_CLASSIFY)
				bu_log("\t\tEarlier eu from same lu at same dist, is IN, continue processing.\n");
		} else {
			/*
	 		 *  If this is now a new lu, it is more complicated.
	 		 *  If "closest" result so far was a NMG_CLASS_AinB or
			 *  or NMG_CLASS_AonB, then keep it,
	 		 *  otherwise, replace that result with whatever we find
	 		 *  here.  Logic:  Two touching loops, one concave ("A")
			 *  which wraps around part of the other ("B"), with the
	 		 *  point inside A near the contact with B.  If loop B is
			 *  processed first, the closest result will be NMG_CLASS_AoutB,
	 		 *  and when loop A is visited the distances will be exactly
	 		 *  equal, not giving A a chance to claim it's hit.
	 		 */
	 		if( closest->class == NMG_CLASS_AinB ||
			    closest->class == NMG_CLASS_AonBshared )  {
		 		if(rt_g.NMG_debug & DEBUG_CLASSIFY)
					bu_log("\t\tSkipping, earlier eu from other another lu at same dist, is IN or ON\n");
	 			return;
	 		}
	 		if(rt_g.NMG_debug & DEBUG_CLASSIFY)
				bu_log("\t\tEarlier eu from other lu at same dist, is OUT, continue processing.\n");
		}
	}

	/* Plane hit point is closer to this edgeuse than previous one(s) */
	if (rt_g.NMG_debug & DEBUG_CLASSIFY) {
		bu_log("\t\tCLOSER dist=%g (closest=%g), tol=%g\n",
			dist, closest->dist, tol->dist);
	}

	if (*eu->up.magic_p != NMG_LOOPUSE_MAGIC ||
	    *eu->up.lu_p->up.magic_p != NMG_FACEUSE_MAGIC) {
		bu_log("Trying to classify a pt (%g, %g, %g)\n\tvs a wire edge? (%g, %g, %g -> %g, %g, %g)\n",
	    		V3ARGS(pt),
	    		V3ARGS(eupt),
	    		V3ARGS(matept)
		);
	    	return;
	}

	if( code <= 2 )  {
		/* code==0:  The point is ON the edge! */
		/* code==1 or 2:  The point is ON a vertex! */
    		if (rt_g.NMG_debug & DEBUG_CLASSIFY) {
    			bu_log("\t\tThe point is ON the edge, calling joint_hitmiss2()\n");
    		}
   		joint_hitmiss2(closest, eu, pt, code);
		return;
    	} else {
    		if (rt_g.NMG_debug & DEBUG_CLASSIFY) {
			bu_log("\t\tThe point is not on the edge\n");
    		}
    	}

	/* The point did not lie exactly ON the edge, calculate in/out */

    	/* Get vector which lies on the plane, and points
    	 * left, towards the interior of the loop, regardless of
	 * whether it's an interior (OT_OPPOSITE) or exterior (OT_SAME) loop.
    	 */
	if( nmg_find_eu_leftvec( left, eu ) < 0 )  rt_bomb("nmg_class_pt_e() bad LEFT vector\n");

	VSUB2(ptvec, pt, pca);		/* pt - pca */
    	if (rt_g.NMG_debug & DEBUG_CLASSIFY)  {
		VPRINT("\t\tptvec unnorm", ptvec);
    		VPRINT("\t\tleft", left);
    	}
	VUNITIZE( ptvec );

	dot = VDOT(left, ptvec);
	if( NEAR_ZERO( dot, RT_DOT_TOL )  )  {
	    	if (rt_g.NMG_debug & DEBUG_CLASSIFY)
	    		bu_log("\t\tpt lies on line of edge, outside verts. Skipping this edge\n");
		goto out;
	}

	if (dot >= 0.0) {
		closest->dist = dist;
		closest->p.eu = eu;
		closest->class = NMG_CLASS_AinB;
	    	if (rt_g.NMG_debug & DEBUG_CLASSIFY)
	    		bu_log("\t\tpt is left of edge, INSIDE loop, dot=%g\n", dot);
	} else {
		closest->dist = dist;
		closest->p.eu = eu;
		closest->class = NMG_CLASS_AoutB;
	    	if (rt_g.NMG_debug & DEBUG_CLASSIFY)
	    		bu_log("\t\tpt is right of edge, OUTSIDE loop\n");
	}

out:
	/* XXX Temporary addition for chasing bug in Bradley r5 */
	/* XXX Should at least add DEBUG_PLOTEM check, later */
	if (rt_g.NMG_debug & DEBUG_CLASSIFY) {
		struct faceuse	*fu;
		char	buf[128];
		static int	num;
		FILE	*fp;
		long	*bits;
		point_t	mid_pt;
		point_t	left_pt;
		fu = eu->up.lu_p->up.fu_p;
		bits = (long *)bu_calloc( nmg_find_model(&fu->l.magic)->maxindex, sizeof(long), "bits[]");
		sprintf(buf,"faceclass%d.pl", num++);
		if( (fp = fopen(buf, "w")) == NULL) rt_bomb(buf);
		nmg_pl_fu( fp, fu, bits, 0, 0, 255 );	/* blue */
		pl_color( fp, 0, 255, 0 );	/* green */
		pdv_3line( fp, pca, pt );
		pl_color( fp, 255, 0, 0 );	/* red */
		VADD2SCALE( mid_pt, eupt, matept, 0.5 );
		VJOIN1( left_pt, mid_pt, 500, left);
		pdv_3line( fp, mid_pt, left_pt );
		fclose(fp);
		bu_free( (char *)bits, "bits[]");
		bu_log("wrote %s\n", buf);
	}
}


/*
 *			N M G _ C L A S S _ P T _ L
 *
 *  XXX DANGER:  This routine does not work well.
 *
 *  Given the coordinates of a point which lies on the plane of the face
 *  containing a loopuse, determine if the point is IN, ON, or OUT of the
 *  area enclosed by the loop.
 *
 *  Implicit Return -
 *	Updated "closest" structure if appropriate.
 *
 *  Called by -
 *	nmg_class_pt_loop()
 *		from: nmg_extrude.c / nmg_fix_overlapping_loops()
 *	nmg_classify_lu_lu()
 *		from: nmg_misc.c / nmg_split_loops_handler()
 */
static void
nmg_class_pt_l(struct neighbor *closest, const fastf_t *pt, const struct loopuse *lu, const struct bn_tol *tol)
{
	vect_t		delta;
	pointp_t	lu_pt;
	fastf_t		dist;
	struct edgeuse	*eu;
	struct loop_g	*lg;

	NMG_CK_LOOPUSE(lu);
	NMG_CK_LOOP(lu->l_p);
	lg = lu->l_p->lg_p;
	NMG_CK_LOOP_G(lg);

	if (rt_g.NMG_debug & DEBUG_CLASSIFY)  {
		VPRINT("nmg_class_pt_l\tPt:", pt);
	}

	if (*lu->up.magic_p != NMG_FACEUSE_MAGIC)
		return;

	if (rt_g.NMG_debug & DEBUG_CLASSIFY)  {
		plane_t		peqn;
		nmg_pr_lu_briefly(lu, 0);
		NMG_GET_FU_PLANE( peqn, lu->up.fu_p );
		HPRINT("\tplane eqn", peqn);
	}

	if( !V3PT_IN_RPP_TOL( pt, lg->min_pt, lg->max_pt, tol ) )  {
		if (rt_g.NMG_debug & DEBUG_CLASSIFY)
			bu_log("\tPoint is outside loop RPP\n");
		return;
	}
	if (BU_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_EDGEUSE_MAGIC) {
		for (BU_LIST_FOR(eu, edgeuse, &lu->down_hd)) {
			nmg_class_pt_e(closest, pt, eu, tol);
			/* If point lies ON edge, we are done */
			if( closest->class == NMG_CLASS_AonBshared )  break;
		}
	} else if (BU_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC) {
		register struct vertexuse *vu;
		vu = BU_LIST_FIRST(vertexuse, &lu->down_hd);
		lu_pt = vu->v_p->vg_p->coord;
		VSUB2(delta, pt, lu_pt);
		if ( (dist = MAGNITUDE(delta)) < closest->dist) {
			if (lu->orientation == OT_OPPOSITE) {
				closest->class = NMG_CLASS_AoutB;
			} else if (lu->orientation == OT_SAME) {
				closest->class = NMG_CLASS_AonBshared;
			} else {
				nmg_pr_orient(lu->orientation, "\t");
				rt_bomb("nmg_class_pt_l: bad orientation for face loopuse\n");
			}
			if (rt_g.NMG_debug & DEBUG_CLASSIFY)
				bu_log("\t\t closer to loop pt (%g, %g, %g)\n",
					V3ARGS(lu_pt) );

			closest->dist = dist;
			closest->p.vu = vu;
		}
	} else {
		rt_bomb("nmg_class_pt_l() bad child of loopuse\n");
	}
	if (rt_g.NMG_debug & DEBUG_CLASSIFY)
		bu_log("nmg_class_pt_l\treturning, closest=%g %s\n",
			closest->dist, nmg_class_name(closest->class) );
}

/*
 *			N M G _ C L A S S _ L U _ F U
 *
 *  This is intended as an internal routine to support nmg_lu_reorient().
 *
 *  Given a loopuse in a face, pick one of it's vertexuses, and classify
 *  that point with respect to all the rest of the loopuses in the face.
 *  The containment status of that point is the status of the loopuse.
 *
 *  If the first vertex chosen is "ON" another loop boundary,
 *  choose the next vertex and try again.  Only return an "ON"
 *  status if _all_ the vertices are ON.
 *
 *  The point is "A", and the face is "B".
 *
 *  Returns -
 *	NMG_CLASS_AinB		lu is INSIDE the area of the face.
 *	NMG_CLASS_AonBshared	ALL of lu is ON other loop boundaries.
 *	NMG_CLASS_AoutB		lu is OUTSIDE the area of the face.
 *
 *  Called by -
 *	nmg_mod.c, nmg_lu_reorient()
 */
int
nmg_class_lu_fu(const struct loopuse *lu, const struct bn_tol *tol)
{
	const struct faceuse	*fu;
	struct vertexuse	*vu;
	const struct vertex_g	*vg;
	struct edgeuse		*eu;
	struct edgeuse		*eu_first;
	fastf_t			dist;
	plane_t			n;
	int			class;

	NMG_CK_LOOPUSE(lu);
	BN_CK_TOL(tol);

	fu = lu->up.fu_p;
	NMG_CK_FACEUSE(fu);
	NMG_CK_FACE(fu->f_p);
	NMG_CK_FACE_G_PLANE(fu->f_p->g.plane_p);

	if (rt_g.NMG_debug & DEBUG_CLASSIFY)
		bu_log("nmg_class_lu_fu(lu=x%x) START\n", lu);

	/* Pick first vertex in loopuse, for point */
	if( BU_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC )  {
		vu = BU_LIST_FIRST(vertexuse, &lu->down_hd);
		eu = (struct edgeuse *)NULL;
	} else {
		eu = BU_LIST_FIRST(edgeuse, &lu->down_hd);
		NMG_CK_EDGEUSE(eu);
		vu = eu->vu_p;
	}
	eu_first = eu;
again:
	NMG_CK_VERTEXUSE(vu);
	NMG_CK_VERTEX(vu->v_p);
	vg = vu->v_p->vg_p;
	NMG_CK_VERTEX_G(vg);

	if (rt_g.NMG_debug & DEBUG_CLASSIFY) {
		VPRINT("nmg_class_lu_fu\tPt:", vg->coord);
	}

	/* Validate distance from point to plane */
	NMG_GET_FU_PLANE( n, fu );
	if( (dist=fabs(DIST_PT_PLANE( vg->coord, n ))) > tol->dist )  {
		bu_log("nmg_class_lu_fu() ERROR, point (%g,%g,%g) not on face, dist=%g\n",
			V3ARGS(vg->coord), dist );
	}

	/* find the closest approach in this face to the projected point */
	class = nmg_class_pt_fu_except( vg->coord, fu, lu,
		NULL, NULL, NULL, 0, 0, tol );

	/* If this vertex lies ON loop edge, must check all others. */
	if( class == NMG_CLASS_AonBshared )  {
		if( !eu_first )  {
			/* was self-loop, nothing more to test */
		} else {
			eu = BU_LIST_PNEXT_CIRC(edgeuse, &eu->l);
			if( eu != eu_first )  {
				vu = eu->vu_p;
				goto again;
			}
			/* all match, call it "ON" */
		}
	}

	if (rt_g.NMG_debug & DEBUG_CLASSIFY) {
		bu_log("nmg_class_lu_fu(lu=x%x) END, ret=%s\n",
			lu,
			nmg_class_name(class) );
	}
	return class;
}

/* Ray direction vectors for Jordan curve algorithm */
static const point_t nmg_good_dirs[10] = {
#if 1
	{3, 2, 1},	/* Normally the first dir */
#else
	{1, 0, 0},	/* Make this first dir to wring out ray-tracer XXX */
#endif
	{1, 0, 0},
	{0, 1, 0},
	{0, 0, 1},
	{1, 1, 1},
	{-3,-2,-1},
	{-1,0, 0},
	{0,-1, 0},
	{0, 0,-1},
	{-1,-1,-1}
};

/*
 *			N M G _ C L A S S _ P T _ S
 *
 *  This is intended as a general user interface routine.
 *  Given the Cartesian coordinates for a point in space,
 *  return the classification for that point with respect to a shell.
 *
 *  The algorithm used is to fire a ray from the point, and count
 *  the number of times it crosses a face.
 *
 *  The flag "in_or_out_only" specifies that the point is known to not
 *  be on the shell, therfore only returns of NMG_CLASS_AinB or
 *  NMG_CLASS_AoutB are acceptable.
 *
 *  The point is "A", and the face is "B".
 *
 *  Returns -
 *	NMG_CLASS_AinB		pt is INSIDE the volume of the shell.
 *	NMG_CLASS_AonBshared	pt is ON the shell boundary.
 *	NMG_CLASS_AoutB		pt is OUTSIDE the volume of the shell.
 */
int
nmg_class_pt_s(const fastf_t *pt, const struct shell *s, const int in_or_out_only, const struct bn_tol *tol)
{
	const struct faceuse	*fu;
	struct model	*m;
	long		*faces_seen = NULL;
	vect_t		region_diagonal;
	fastf_t		region_diameter;
	int		class;
	vect_t		projection_dir;
	int		try=0;
	struct xray	rp;

	NMG_CK_SHELL(s);
	BN_CK_TOL(tol);

	if (rt_g.NMG_debug & DEBUG_CLASSIFY)
		bu_log("nmg_class_pt_s:\tpt=(%g, %g, %g), s=x%x\n",
			V3ARGS(pt), s );

	if( !V3PT_IN_RPP_TOL(pt, s->sa_p->min_pt, s->sa_p->max_pt, tol) )  {
		if (rt_g.NMG_debug & DEBUG_CLASSIFY)
			bu_log("	OUT, point not in RPP\n");
		return NMG_CLASS_AoutB;
	}

	m = s->r_p->m_p;
	NMG_CK_MODEL(m);
	if( !in_or_out_only )
	{
		faces_seen = (long *)bu_calloc( m->maxindex, sizeof(long), "nmg_class_pt_s faces_seen[]" );

		/*
		 *  First pass:  Try hard to see if point is ON a face.
		 */
		for( BU_LIST_FOR(fu, faceuse, &s->fu_hd) )  {
			plane_t	n;

			/* If this face processed before, skip on */
			if( NMG_INDEX_TEST( faces_seen, fu->f_p ) )  continue;

			/* Only consider the outward pointing faceuses */
			if( fu->orientation != OT_SAME )  continue;

			/* See if this point lies on this face */
			NMG_GET_FU_PLANE( n, fu );
			if( (fabs(DIST_PT_PLANE(pt, n))) < tol->dist)  {
				/* Point lies on this plane, it may be possible to
				 * short circuit everything.
				 */
				class = nmg_class_pt_fu_except(pt, fu, (struct loopuse *)0,
					(void (*)())NULL, (void (*)())NULL, (char *)NULL, 0,
					0, tol);
				if( class == NMG_CLASS_AonBshared )  {
					/* Point is ON face, therefore it must be
					 * ON the shell also.
					 */
					class = NMG_CLASS_AonBshared;
					goto out;
				}
				if( class == NMG_CLASS_AinB )  {
					/* Point is IN face, therefor it must be
					 * ON the shell also.
					 */
					class = NMG_CLASS_AonBshared;
					goto out;
				}
				/* Point is OUTside face, its undecided. */
			}

			/* Mark this face as having been processed */
			NMG_INDEX_SET(faces_seen, fu->f_p);
		}
	}

	/* If we got here, the point isn't ON any of the faces.
	 * Time to do the Jordan Curve Theorem.  We fire an arbitrary
	 * ray and count the number of crossings (in the positive direction)
	 * If that number is even, we're outside the shell, otherwise we're
	 * inside the shell.
	 */
	NMG_CK_REGION_A(s->r_p->ra_p);
	VSUB2( region_diagonal, s->r_p->ra_p->max_pt, s->r_p->ra_p->min_pt );
	region_diameter = MAGNITUDE(region_diagonal);

	/* Choose an unlikely direction */
	try = 0;
retry:
	VMOVE( projection_dir, nmg_good_dirs[try] );
	if( ++try > 10 )  rt_bomb("nmg_class_pt_s() retry count exhausted\n");
	VUNITIZE(projection_dir);

	if (rt_g.NMG_debug & DEBUG_CLASSIFY )
		bu_log("\tPt=(%g, %g, %g) dir=(%g, %g, %g), reg_diam=%g\n",
			V3ARGS(pt), V3ARGS(projection_dir), region_diameter);
	
	VMOVE(rp.r_pt, pt);
	VMOVE(rp.r_dir, projection_dir);


	/* get NMG ray-tracer to tell us if start point is inside or outside */
	class = nmg_class_ray_vs_shell(&rp, s, in_or_out_only, tol);
	if( class == NMG_CLASS_Unknown )  goto retry;

out:
	if( !in_or_out_only )
		bu_free( (char *)faces_seen, "nmg_class_pt_s faces_seen[]" );

	if (rt_g.NMG_debug & DEBUG_CLASSIFY )
		bu_log("nmg_class_pt_s: returning %s, s=x%x, try=%d\n",
			nmg_class_name(class), s, try );
	return class;
}


/*
 *			C L A S S _ V U _ V S _ S
 *
 *	Classify a loopuse/vertexuse from shell A WRT shell B.
 */
static int 
class_vu_vs_s(struct vertexuse *vu, struct shell *sB, long int **classlist, const struct bn_tol *tol)
{
	struct vertexuse *vup;
	pointp_t pt;
	char	*reason;
	int	status = 0;
	int	class;

	NMG_CK_VERTEXUSE(vu);
	NMG_CK_SHELL(sB);
	BN_CK_TOL(tol);

	pt = vu->v_p->vg_p->coord;

	if (rt_g.NMG_debug & DEBUG_CLASSIFY)
		bu_log("class_vu_vs_s(vu=x%x, v=x%x) pt=(%g,%g,%g)\n", vu, vu->v_p, V3ARGS(pt) );

	/* As a mandatory consistency measure, check for cached classification */
	reason = "of cached classification";
	if( NMG_INDEX_TEST(classlist[NMG_CLASS_AinB], vu->v_p) )  {
		status = INSIDE;
		goto out;
	}
	if( NMG_INDEX_TEST(classlist[NMG_CLASS_AonBshared], vu->v_p) )  {
		status = ON_SURF;
		goto out;
	}
	if( NMG_INDEX_TEST(classlist[NMG_CLASS_AonBanti], vu->v_p) )  {
		status = ON_SURF;
		goto out;
	}
	if( NMG_INDEX_TEST(classlist[NMG_CLASS_AoutB], vu->v_p) )  {
		status = OUTSIDE;
		goto out;
	}

	/* we use topology to determing if the vertex is "ON" the
	 * other shell.
	 */
	for(BU_LIST_FOR(vup, vertexuse, &vu->v_p->vu_hd)) {

		if (*vup->up.magic_p == NMG_LOOPUSE_MAGIC )  {
			if( nmg_find_s_of_lu(vup->up.lu_p) != sB) continue;
		    	NMG_INDEX_SET(classlist[NMG_CLASS_AonBshared], 
		    		vu->v_p );
		    	reason = "a loopuse of vertex is on shell";
		    	status = ON_SURF;
			goto out;
		} else if (*vup->up.magic_p == NMG_EDGEUSE_MAGIC )  {
			if( nmg_find_s_of_eu(vup->up.eu_p) != sB) continue;
		    	NMG_INDEX_SET(classlist[NMG_CLASS_AonBshared],
		    		vu->v_p );
		    	reason = "an edgeuse of vertex is on shell";
		    	status = ON_SURF;
			goto out;
		} else if( *vup->up.magic_p == NMG_SHELL_MAGIC )  {
			if( vup->up.s_p != sB ) continue;
		    	NMG_INDEX_SET(classlist[NMG_CLASS_AonBshared],
		    		vu->v_p );
		    	reason = "vertex is shell's lone vertex";
		    	status = ON_SURF;
			goto out;
		} else {
			rt_bomb("class_vu_vs_s() bad vertex UP pointer\n");
		}
	}

	if (rt_g.NMG_debug & DEBUG_CLASSIFY)
		bu_log("\tCan't classify vertex via topology\n");

	/* The topology doesn't tell us about the vertex being "on" the shell
	 * so now it's time to look at the geometry to determine the vertex
	 * relationship to the shell.
	 *
	 * The vertex should *not* lie ON any of the faces or
	 * edges, since the intersection algorithm would have combined the
	 * topology if that had been the case.
	 */
	/* XXX eventually, make this conditional on DEBUG_CLASSIFY */
	{
		/* Verify this assertion */
		struct vertex	*sv;
		if( (sv = nmg_find_pt_in_shell( sB, pt, tol ) ) )  {
			bu_log("vu=x%x, v=x%x, sv=x%x, pt=(%g,%g,%g)\n",
				vu, vu->v_p, sv, V3ARGS(pt) );
			rt_bomb("nmg_class_pt_s() vertex topology not shared properly\n");
		}
	}

	reason = "of nmg_class_pt_s()";
	class = nmg_class_pt_s(pt, sB, 1, tol);
	
	if( class == NMG_CLASS_AoutB )  {
		NMG_INDEX_SET(classlist[NMG_CLASS_AoutB], vu->v_p);
		status = OUTSIDE;
	}  else if( class == NMG_CLASS_AinB )  {
		NMG_INDEX_SET(classlist[NMG_CLASS_AinB], vu->v_p);
		status = INSIDE;
	}  else if( class == NMG_CLASS_AonBshared )  {
		NMG_INDEX_SET(classlist[NMG_CLASS_AonBshared], vu->v_p);
		status = ON_SURF;
	}  else  {
		bu_log("class=%s\n", nmg_class_name(class) );
		VPRINT("pt", pt);
		rt_bomb("class_vu_vs_s: nmg_class_pt_s() failure\n");
	}

out:
	if (rt_g.NMG_debug & DEBUG_CLASSIFY) {
		bu_log("class_vu_vs_s(vu=x%x) return %s because %s\n",
			vu, nmg_class_status(status), reason );
	}
	return(status);
}

/*
 *			C L A S S _ E U _ V S _ S
 */
static int 
class_eu_vs_s(struct edgeuse *eu, struct shell *s, long int **classlist, const struct bn_tol *tol)
{
	int euv_cl, matev_cl;
	int	status = 0;
	struct edgeuse *eup;
	point_t pt;
	pointp_t eupt, matept;
	char	*reason = "Unknown";
	int	class;

	if (rt_g.NMG_debug & DEBUG_CLASSIFY)
	{
		bu_log( "class_eu_vs_s( eu=x%x (e_p=x%x, lu=x%x), s=x%x )\n", eu, eu->e_p, eu->up.lu_p, s );
		nmg_euprint("class_eu_vs_s\t", eu);
	}

	NMG_CK_EDGEUSE(eu);	
	NMG_CK_SHELL(s);	
	BN_CK_TOL(tol);
	
	/* As a mandatory consistency measure, check for cached classification */
	reason = "of cached classification";
	if( NMG_INDEX_TEST(classlist[NMG_CLASS_AinB], eu->e_p) )  {
		status = INSIDE;
		goto out;
	}
	if( NMG_INDEX_TEST(classlist[NMG_CLASS_AonBshared], eu->e_p) )  {
		status = ON_SURF;
		goto out;
	}
	if( NMG_INDEX_TEST(classlist[NMG_CLASS_AonBanti], eu->e_p) )  {
		status = ON_SURF;
		goto out;
	}
	if( NMG_INDEX_TEST(classlist[NMG_CLASS_AoutB], eu->e_p) )  {
		status = OUTSIDE;
		goto out;
	}

	euv_cl = class_vu_vs_s(eu->vu_p, s, classlist, tol);
	matev_cl = class_vu_vs_s(eu->eumate_p->vu_p, s, classlist, tol);
	
	/* sanity check */
	if ((euv_cl == INSIDE && matev_cl == OUTSIDE) ||
	    (euv_cl == OUTSIDE && matev_cl == INSIDE)) {
	    	static int	num=0;
	    	char	buf[128];
	    	FILE	*fp;

	    	sprintf(buf, "class%d.pl", num++ );
	    	if( (fp = fopen(buf, "w")) == NULL ) rt_bomb(buf);
	    	nmg_pl_s( fp, s );
		/* A yellow line for the angry edge */
		pl_color(fp, 255, 255, 0);
		pdv_3line(fp, eu->vu_p->v_p->vg_p->coord,
			eu->eumate_p->vu_p->v_p->vg_p->coord );
		fclose(fp);

	    	nmg_pr_class_status("eu vu", euv_cl);
	    	nmg_pr_class_status("eumate vu", matev_cl);
	    	if( RT_G_DEBUG || rt_g.NMG_debug )  {
		    	/* Do them over, so we can watch */
	    		bu_log("Edge not cut, doing it over\n");
	    		NMG_INDEX_CLEAR( classlist[NMG_CLASS_AinB], eu->vu_p);
	    		NMG_INDEX_CLEAR( classlist[NMG_CLASS_AoutB], eu->vu_p);
	    		NMG_INDEX_CLEAR( classlist[NMG_CLASS_AinB], eu->eumate_p->vu_p);
	    		NMG_INDEX_CLEAR( classlist[NMG_CLASS_AoutB], eu->eumate_p->vu_p);
/**	    		rt_g.debug |= DEBUG_MATH; **/
			rt_g.NMG_debug |= DEBUG_CLASSIFY;
			(void)class_vu_vs_s(eu->vu_p, s, classlist, tol);
			(void)class_vu_vs_s(eu->eumate_p->vu_p, s, classlist, tol);
		    	nmg_euprint("didn't this edge get cut?", eu);
		    	nmg_pr_eu(eu, "  ");
	    	}

		bu_log("wrote %s\n", buf);
		rt_bomb("class_eu_vs_s:  edge didn't get cut\n");
	}

	if (euv_cl == ON_SURF && matev_cl == ON_SURF) {
		vect_t eu_dir;
		int try;

		/* check for radial uses of this edge by the shell */
		eup = eu->radial_p->eumate_p;
		do {
			NMG_CK_EDGEUSE(eup);
			if (nmg_find_s_of_eu(eup) == s) {
				NMG_INDEX_SET(classlist[NMG_CLASS_AonBshared],
					eu->e_p );
				reason = "a radial edgeuse is on shell";
				status = ON_SURF;
				goto out;
			}
			eup = eup->radial_p->eumate_p;
		} while (eup != eu->radial_p->eumate_p);

		/* look for another eu between these two vertices */
		if( nmg_find_matching_eu_in_s( eu, s ) )
		{
			NMG_INDEX_SET(classlist[NMG_CLASS_AonBshared],
				eu->e_p );
			reason = "another eu between same vertices is on shell";
			status = ON_SURF;
			goto out;
		}

		/* although the two endpoints are "on" the shell,
		 * the edge would appear to be either "inside" or "outside",
		 * since there are no uses of this edge in the shell.
		 *
		 * So we classify the midpoint of the line WRT the shell.
		 *
		 *  Consider AE as being "eu", with M as the geometric midpoint.
		 *  Consider AD as being a side view of a perpendicular plane
		 *  in the other shell, which AE _almost_ lies in.
		 *  A problem occurs when the angle DAE is very small.
		 *  Point A is ON because of shared topology.
		 *  Point E is marked ON because it is within tolerance of
		 *  the face, even though there is no corresponding vertex.
		 *  Naturally, point M is also going to be found to be ON
		 *  because it is also within tolerance.
		 *
		 *         D
		 *        /|
		 *       / |
		 *      B  |
		 *     /   |
		 *    /    |
		 *   A--M--E
		 *   
		 *  This would seem to be an intersector problem.
		 */
		class = NMG_CLASS_Unknown;
		eupt = eu->vu_p->v_p->vg_p->coord;
		matept = eu->eumate_p->vu_p->v_p->vg_p->coord;
#if 0
		{
			/* XXXX This topological algorithm assumes that the intersector is perfect */

			int in=0,out=0,on=0,unk=0;
			struct edgeuse *eu_loop;
			struct edgeuse *eu_on=(struct edgeuse *)NULL;

			class_topo = NMG_CLASS_Unknown;

			if (rt_g.NMG_debug & DEBUG_CLASSIFY)
				bu_log( "\tclass_eu_vs_s: attempting topological classification\n" );

			/* look at other EU's in the loop
			 * counting in/on/out/unknown EU classes
			 * if we find an ON, keep it handy
			 */
			eu_loop = BU_LIST_PNEXT_CIRC( edgeuse, &eu->l );
			while( eu_loop != eu )
			{
				if( NMG_INDEX_TEST( classlist[NMG_CLASS_AinB], eu_loop->e_p ) )
					in++;
				else if( NMG_INDEX_TEST( classlist[NMG_CLASS_AoutB], eu_loop->e_p ) )
					out++;
				else if( NMG_INDEX_TEST( classlist[NMG_CLASS_AonBshared], eu_loop->e_p ) )
				{
					eu_on = eu_loop;
					on++;
				}
				else if( NMG_INDEX_TEST( classlist[NMG_CLASS_AonBanti], eu_loop->e_p ) )
				{
					eu_on = eu_loop;
					on++;
				}
				else
					unk++;

				eu_loop = BU_LIST_PNEXT_CIRC( edgeuse, &eu_loop->l );
			}

			if(in && out )
			{
				/* This is obviously a GOOF!!! */
				bu_log( "loop crosses shell boundary!!!\n" );
				nmg_pr_fu_briefly( nmg_find_fu_of_eu( eu ), "" );
				rt_bomb( "loop crosses shell boundary!!!" );
			}

			if( on )
			{
				struct edgeuse *eu_rad;
				struct edgeuse *eu_rad_too;
				struct faceuse *fu_rad;
				struct faceuse *fu_rad_too;
				struct faceuse *fu_eu;

				if (rt_g.NMG_debug & DEBUG_CLASSIFY)
					bu_log( "\tclass_eu_vs_s: found other eu (x%x) in loop on shell\n", eu_on );

				/* Look radially around this "ON" edgeuse.
				 * The first eu we encounter from the shell "s"
				 * tells us if we are in or out
				 */

				fu_eu = nmg_find_fu_of_eu( eu );
				eu_rad = eu_on->radial_p;
				while( nmg_find_s_of_eu( eu_rad ) != s &&
					eu_rad != eu_on &&
					eu_rad != eu_on->eumate_p &&
					( fu_rad = nmg_find_fu_of_eu( eu_rad )) != NULL )
						eu_rad = eu_rad->eumate_p->radial_p;

				/* find the nearest in the other direction also */
				eu_rad_too = eu_on->eumate_p->radial_p;
				while( nmg_find_s_of_eu( eu_rad_too ) != s &&
					eu_rad_too != eu_on &&
					eu_rad_too != eu_on->eumate_p &&
					( fu_rad_too = nmg_find_fu_of_eu( eu_rad_too )) != NULL )
						eu_rad_too = eu_rad_too->eumate_p->radial_p;

				fu_rad = nmg_find_fu_of_eu( eu_rad );

				if (rt_g.NMG_debug & DEBUG_CLASSIFY)
				{
					bu_log( "\tclass_eu_vs_s: eu_rad=x%x, eu_rad_too=x%x\n",
						eu_rad, eu_rad_too );
					bu_log( "\t\tfu_rad=x%x, fu_rad_too=x%x, fu_eu=x%x, fu_eu->fumate_p=x%x\n",
						fu_rad, fu_rad_too, fu_eu, fu_eu->fumate_p );
					bu_log( "\t\ts=x%x, fu_rad->s_p=x%x\n", s, fu_rad->s_p );
				}

				if( fu_rad && fu_rad->s_p == s && fu_rad != fu_eu &&
					fu_rad != fu_eu->fumate_p )
				{
					vect_t left_eu;
					vect_t left_rad;
					vect_t left_rad_too;
					double dot;
					double dot_too;

					nmg_find_eu_leftvec( left_eu, eu_on );
					nmg_find_eu_leftvec( left_rad, eu_rad );
					nmg_find_eu_leftvec( left_rad_too, eu_rad_too );

					dot = VDOT( left_eu, left_rad );
					dot_too = VDOT( left_eu, left_rad_too );

					if (rt_g.NMG_debug & DEBUG_CLASSIFY)
					{
						bu_log( "\tclass_eu_vs_s eu_rad=x%x, eu_rad_too=x%x, dot=%f, dot_too=%f\n",
						eu_rad, eu_rad_too, dot, dot_too );
					}

					/* if left vectors of left vectors are parallel,
					 * then we can't classify this way
					 */
					if( dot > tol->para )
						class_topo = NMG_CLASS_Unknown;
					else if( dot_too > tol->para )
						class_topo = NMG_CLASS_Unknown;
					else if( fu_rad->orientation == OT_SAME )
					{
						class_topo = NMG_CLASS_AoutB;
						reason = "nearest radial face is OT_SAME";
					}
					else if( fu_rad->orientation == OT_OPPOSITE )
					{
						class_topo = NMG_CLASS_AinB;
						reason = "nearest radial face is OT_OPPOSITE";
					}
					else
					{
						bu_log( "FU (x%x) has bad orientation (%s)\n", fu_rad, nmg_orientation( fu_rad->orientation ) );
						rt_bomb( "FU has bad orientation" );
					}
					if (rt_g.NMG_debug & DEBUG_CLASSIFY &&
						class_topo != NMG_CLASS_Unknown )
					{
						bu_log( "\tClassifiying EU using on eu (x%x) from fu (x%x)\n", eu_on, nmg_find_fu_of_eu( eu_on) );
						nmg_pr_fu_around_eu( eu_on, tol );
					}
				}
			}
		}

		class = class_topo;
#endif
		if( class == NMG_CLASS_Unknown )
		{
			VSUB2( eu_dir, matept, eupt );
			VUNITIZE( eu_dir );
		}

		try = 0;
		while( class == NMG_CLASS_Unknown && try < 3 )
		{
			/* Must resort to ray trace */
			switch( try )
			{
				case 0 :
					VADD2SCALE(pt, eupt, matept, 0.5);
					reason = "midpoint classification (both verts ON)";
					break;
				case 1:
					VJOIN1( pt, eupt, 1.05*tol->dist, eu_dir );
					reason = "point near EU start classification (both verts ON)";
					break;
				case 2:
					VJOIN1( pt, matept, -1.05*tol->dist, eu_dir );
					reason = "point near EU end classification (both verts ON)";
					break;
			}
			class = nmg_class_pt_s(pt, s, 1, tol);
			try++;
		}

		if( class == NMG_CLASS_AoutB )  {
			NMG_INDEX_SET(classlist[NMG_CLASS_AoutB], eu->e_p);
			status = OUTSIDE;
		}  else if( class == NMG_CLASS_AinB )  {
			NMG_INDEX_SET(classlist[NMG_CLASS_AinB], eu->e_p);
			status = INSIDE;
		} else if( class == NMG_CLASS_AonBshared )  {
			FILE	*fp;
#if 0
			/* XXX bug hunt helper */
			rt_g.NMG_debug |= DEBUG_FINDEU;
		/* 	rt_g.NMG_debug |= DEBUG_MESH;	 */
			rt_g.NMG_debug |= DEBUG_BASIC;
			eup = nmg_findeu( eu->vu_p->v_p, eu->eumate_p->vu_p->v_p, s, eu, 0 );
			if(!eup) bu_log("Unable to find it\n");
			nmg_model_fuse( nmg_find_model((long*)eu), tol );
#endif
			nmg_pr_fu_around_eu( eu, tol );
			VPRINT("class_eu_vs_s: midpoint of edge", pt);
			if( (fp = fopen("shell1.pl", "w")) )  {
				nmg_pl_s(fp, s);
				fclose(fp);
				bu_log("wrote shell1.pl\n");
			}
			if( (fp = fopen("shell2.pl", "w")) )  {
				nmg_pl_shell(fp, eu->up.lu_p->up.fu_p->s_p, 1 );
				fclose(fp);
				bu_log("wrote shell2.pl\n");
			}
#if 0
			/* Another bug hunt helper -- re-run face/face isect */
			rt_g.NMG_debug |= DEBUG_POLYSECT;
			rt_g.NMG_debug |= DEBUG_PLOTEM;
			rt_g.NMG_debug |= DEBUG_BASIC;
			bu_log("class_eu_vs_s:  classifier found edge midpoint ON, edge topology should have been shared\n\n################ re-run face/face isect ############\n\n");
		{
			struct faceuse	*fu1 = eu->up.lu_p->up.fu_p;
			struct faceuse	*fu2;

			NMG_CK_FACEUSE(fu1);
			for( BU_LIST_FOR( fu2, faceuse, &s->fu_hd ) )  {
				NMG_CK_FACEUSE(fu2);
				if( fu2->orientation != OT_SAME )  continue;
				nmg_isect_two_generic_faces( fu1, fu2, tol );
			}
			eup = nmg_findeu( eu->vu_p->v_p, eu->eumate_p->vu_p->v_p, s, eu, 0 );
			if(!eup) bu_log("Unable to find it\n");
		}
#endif
			rt_bomb("class_eu_vs_s:  classifier found edge midpoint ON, edge topology should have been shared\n");
		}  else  {
			bu_log("class=%s\n", nmg_class_name(class) );
			nmg_euprint("Why wasn't this edge in or out?", eu);
			rt_bomb("class_eu_vs_s: nmg_class_pt_s() midpoint failure\n");
		}
		goto out;
	}

	if (euv_cl == OUTSIDE || matev_cl == OUTSIDE) {
		NMG_INDEX_SET(classlist[NMG_CLASS_AoutB], eu->e_p);
		reason = "at least one vert OUT";
		status = OUTSIDE;
		goto out;
	}
	if( euv_cl == INSIDE && matev_cl == INSIDE )  {
		NMG_INDEX_SET(classlist[NMG_CLASS_AinB], eu->e_p);
		reason = "both verts IN";
		status = INSIDE;
		goto out;
	}
	if( (euv_cl == INSIDE && matev_cl == ON_SURF) ||
	    (euv_cl == ON_SURF && matev_cl == INSIDE) )  {
		NMG_INDEX_SET(classlist[NMG_CLASS_AinB], eu->e_p);
		reason = "one vert IN, one ON";
		status = INSIDE;
		goto out;
	}
	bu_log("eu's vert is %s, mate's vert is %s\n",
		nmg_class_status(euv_cl), nmg_class_status(matev_cl) );
	rt_bomb("class_eu_vs_s() inconsistent edgeuse\n");
out:
	if (rt_g.NMG_debug & DEBUG_GRAPHCL)
		nmg_show_broken_classifier_stuff((long *)eu, classlist, nmg_class_nothing_broken, 0, (char *)NULL);
	if (rt_g.NMG_debug & DEBUG_CLASSIFY) {
		bu_log("class_eu_vs_s(eu=x%x) return %s because %s\n",
			eu, nmg_class_status(status), reason );
	}
	return(status);
}

/* XXX move to nmg_info.c */
/*
 *			N M G _ 2 L U _ I D E N T I C A L
 *
 *  Given two edgeuses in different faces that share a common edge,
 *  determine if they are from identical loops or not.
 *
 *  Note that two identical loops in an anti-shared pair of faces
 *  (faces with opposite orientations) will also have opposite orientations.
 *
 *  Returns -
 *	0	Loops not identical
 *	1	Loops identical, faces are ON-shared
 *	2	Loops identical, faces are ON-anti-shared
 *	3	Loops identical, at least one is a wire loop.
 */
int
nmg_2lu_identical(const struct edgeuse *eu1, const struct edgeuse *eu2)
{
	const struct loopuse	*lu1;
	const struct loopuse	*lu2;
	const struct edgeuse	*eu1_first;
	const struct faceuse	*fu1;
	const struct faceuse	*fu2;
	int			ret;

	NMG_CK_EDGEUSE(eu1);
	NMG_CK_EDGEUSE(eu2);

	if( eu1->e_p != eu2->e_p )  rt_bomb("nmg_2lu_identical() differing edges?\n");

	/* get the starting vertex of each edgeuse to be the same. */
	if (eu2->vu_p->v_p != eu1->vu_p->v_p) {
		eu2 = eu2->eumate_p;
		if (eu2->vu_p->v_p != eu1->vu_p->v_p)
			rt_bomb("nmg_2lu_identical() radial edgeuse doesn't share verticies\n");
	}

	lu1 = eu1->up.lu_p;
	lu2 = eu2->up.lu_p;

	NMG_CK_LOOPUSE(lu1);
	NMG_CK_LOOPUSE(lu2);

    	/* march around the two loops to see if they 
    	 * are the same all the way around.
    	 */
	eu1_first = eu1;
	do {
		if( eu1->vu_p->v_p != eu2->vu_p->v_p )  {
			ret = 0;
			goto out;
		}
		eu1 = BU_LIST_PNEXT_CIRC(edgeuse, &eu1->l);
		eu2 = BU_LIST_PNEXT_CIRC(edgeuse, &eu2->l);
	} while ( eu1 != eu1_first );

	if( *lu1->up.magic_p != NMG_FACEUSE_MAGIC ||
	    *lu2->up.magic_p != NMG_FACEUSE_MAGIC )  {
		ret = 3;	/* one is a wire loop */
	    	goto out;
	    }

	fu1 = lu1->up.fu_p;
	fu2 = lu2->up.fu_p;

	if( fu1->f_p->g.plane_p != fu2->f_p->g.plane_p )  {
		vect_t fu1_norm,fu2_norm;
#if 0
		bu_log("nmg_2lu_identical() loops lu1=x%x lu2=x%x are shared, face geometry is not? fg1=x%x, fg2=x%x\n",
			lu1, lu2, fu1->f_p->g.plane_p, fu2->f_p->g.plane_p);
		bu_log("---- fu1, f=x%x, flip=%d\n", fu1->f_p, fu1->f_p->flip);
		nmg_pr_fg(fu1->f_p->g.magic_p, 0);
		nmg_pr_fu_briefly(fu1, 0);

		bu_log("---- fu2, f=x%x, flip=%d\n", fu2->f_p, fu2->f_p->flip);
		nmg_pr_fg(fu2->f_p->g.magic_p, 0);
		nmg_pr_fu_briefly(fu2, 0);
#endif

		/* Drop back to using a geometric calculation */
		if( fu1->orientation != fu2->orientation )
			NMG_GET_FU_NORMAL( fu2_norm, fu2->fumate_p )
		else
			NMG_GET_FU_NORMAL( fu2_norm, fu2 )

		NMG_GET_FU_NORMAL( fu1_norm, fu1 );
		if( VDOT( fu1_norm, fu2_norm ) < 0.0 )
			ret = 2;	/* ON anti-shared */
		else
			ret = 1;	/* ON shared */
		goto out;
	}

	if( rt_g.NMG_debug & DEBUG_BASIC )  {
		bu_log("---- fu1, f=x%x, flip=%d\n", fu1->f_p, fu1->f_p->flip);
		nmg_pr_fu_briefly(fu1, 0);
		bu_log("---- fu2, f=x%x, flip=%d\n", fu2->f_p, fu2->f_p->flip);
		nmg_pr_fu_briefly(fu2, 0);
	}

	/*
	 *  The two loops are identical, compare the two faces.
	 *  Only raw face orientations count here.
	 *  Loopuse and faceuse orientations do not matter.
	 */
	if( fu1->f_p->flip != fu2->f_p->flip )
		ret = 2;		/* ON anti-shared */
	else
		ret = 1;		/* ON shared */
out:
	if( rt_g.NMG_debug & DEBUG_BASIC )  {
		bu_log("nmg_2lu_identical(eu1=x%x, eu2=x%x) ret=%d\n",
			eu1, eu2, ret);
	}
	return ret;
}

/*
 *			N M G _ R E C L A S S I F Y _ L U _ E U
 *
 *  Make all the edges and vertices of a loop carry the same classification
 *  as the loop.
 *  There is no intrinsic way to tell if an edge is "shared" or
 *  "antishared", except by reference to it's loopuse, but the heritage
 *  of the edgeuse makes a difference to the boolean evaluator.
 *
 *  "newclass" should only be AonBshared or AonBanti.
 */
void
nmg_reclassify_lu_eu(struct loopuse *lu, long int **classlist, int newclass)
{
	struct vertexuse	*vu;
	struct edgeuse		*eu;
	struct vertex		*v;

	NMG_CK_LOOPUSE(lu);

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_reclassify_lu_eu(lu=x%x, classlist=x%x, newclass=%s)\n",
			lu, classlist, nmg_class_name(newclass) );
	}

	if( newclass != NMG_CLASS_AonBshared && newclass != NMG_CLASS_AonBanti )
		rt_bomb("nmg_reclassify_lu_eu() bad newclass\n");

	if (BU_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC)  {
		vu = BU_LIST_FIRST(vertexuse, &lu->down_hd);
		NMG_CK_VERTEXUSE(vu);
		v = vu->v_p;
		NMG_CK_VERTEX(v);

		if( NMG_INDEX_TEST(classlist[NMG_CLASS_AinB], v) ||
		    NMG_INDEX_TEST(classlist[NMG_CLASS_AoutB], v) )
			rt_bomb("nmg_reclassify_lu_eu() changing in/out vert of lone vu loop to ON?\n");

		/* Clear out other classifications */
		NMG_INDEX_CLEAR(classlist[NMG_CLASS_AonBshared], v);
		NMG_INDEX_CLEAR(classlist[NMG_CLASS_AonBanti], v);
		/* Establish new classification */
		NMG_INDEX_SET(classlist[newclass], v);
		return;
	}

	for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
		struct edge	*e;
		NMG_CK_EDGEUSE(eu);
		e = eu->e_p;
		NMG_CK_EDGE(e);

		if( NMG_INDEX_TEST(classlist[NMG_CLASS_AinB], e) ||
		    NMG_INDEX_TEST(classlist[NMG_CLASS_AoutB], e) )
			rt_bomb("nmg_reclassify_lu_eu() changing in/out edge to ON?\n");

		/* Clear out other edge classifications */
		NMG_INDEX_CLEAR(classlist[NMG_CLASS_AonBshared], e);
		NMG_INDEX_CLEAR(classlist[NMG_CLASS_AonBanti], e);
		/* Establish new edge classification */
		NMG_INDEX_SET(classlist[newclass], e);

		/* Same thing for the vertices.  Only need to do start vert here. */
		vu = eu->vu_p;
		NMG_CK_VERTEXUSE(vu);
		v = vu->v_p;
		NMG_CK_VERTEX(v);

		if( NMG_INDEX_TEST(classlist[NMG_CLASS_AinB], v) ||
		    NMG_INDEX_TEST(classlist[NMG_CLASS_AoutB], v) )
			rt_bomb("nmg_reclassify_lu_eu() changing in/out vert to ON?\n");

		/* Clear out other classifications */
		NMG_INDEX_CLEAR(classlist[NMG_CLASS_AonBshared], v);
		NMG_INDEX_CLEAR(classlist[NMG_CLASS_AonBanti], v);
		/* Establish new classification */
		NMG_INDEX_SET(classlist[newclass], v);
	}
}

/*			C L A S S _ S H A R E D _ L U
 *
 *	Classify LU w.r.t. LU_REF.
 *
 *	Pre-requisites, required (but not checked for here ):
 *		LU shares all its edges with LU_REF
 *		LU and LU_REF are loopuses from faceuses
 *		LU and LU_REF are from different shells
 *		LU and LU_REF must both be loops of edges
 *
 *	LU is classified w.r.t. LU_REF by the following algorithm:
 *		1. Select any EU from LU.
 *		2. Find EU_REF from LU_REF that is shared with EU.
 *		3. If left vector of EU is opposite left vector of EU_REF,
 *			then classification is either NMG_CLASS_AoutB or
 *			NMG_CLASS_AinB.
 *			(This is the case where one lu exactly fills a hole
 *			 that the other lu creates in a face).
 *		4. If the left vectors agree, then the loops are shared -
 *			If the direction of EU agrees with the direction
 *			of EU_REF, then classify as NMG_CLASS_AonBshared.
 *			Otherwise classify as NMG_CLASS_AonBanti.
 *
 *	returns:
 *		NMG_CLASS_AonBshared
 *		NMG_CLASS_AonBanti
 *		NMG_CLASS_AoutB
 */
static int
class_shared_lu(const struct loopuse *lu, const struct loopuse *lu_ref, const struct bn_tol *tol)
{
	struct shell *s_ref;
	struct edgeuse *eu;
	struct edgeuse *eu_ref;
	struct edgeuse *eu_start,*eu_tmp;
	struct faceuse *fu_of_lu;
	vect_t left;
	vect_t left_ref;

	if (rt_g.NMG_debug & DEBUG_CLASSIFY)
		bu_log( "class_shared_lu: classifying lu x%x w.r.t. lu_ref x%x\n",
				lu, lu_ref );

	NMG_CK_LOOPUSE( lu );
	NMG_CK_LOOPUSE( lu_ref );
	BN_CK_TOL( tol );

	eu = BU_LIST_FIRST( edgeuse, &lu->down_hd );
	for( BU_LIST_FOR( eu_ref, edgeuse, &lu_ref->down_hd ) )
	{
		if( eu_ref->e_p == eu->e_p )
			break;
	}

	if( eu_ref->e_p != eu->e_p )
	{
		bu_log( "class_shared_lu() couldn't find a shared EU between LU's x%x and x%x\n",
			lu, lu_ref );
		rt_bomb( "class_shared_lu() couldn't find a shared EU between LU's\n" );
	}

	if( nmg_find_eu_leftvec( left, eu ) )
	{
		bu_log( "class_shared_lu() couldn't get a left vector for EU x%x\n", eu );
		rt_bomb( "class_shared_lu() couldn't get a left vector for EU\n" );
	}
	if( nmg_find_eu_leftvec( left_ref, eu_ref ) )
	{
		bu_log( "class_shared_lu() couldn't get a left vector for EU x%x\n", eu_ref );
		rt_bomb( "class_shared_lu() couldn't get a left vector for EU\n" );
	}

	if( VDOT( left, left_ref ) > 0.0 )
	{
		if (rt_g.NMG_debug & DEBUG_CLASSIFY)
		{
			bu_log( "eu x%x goes form v x%x to v x%x\n", eu, eu->vu_p->v_p, eu->eumate_p->vu_p->v_p );
			bu_log( "eu_ref x%x goes form v x%x to v x%x\n", eu_ref, eu_ref->vu_p->v_p, eu_ref->eumate_p->vu_p->v_p );
		}

		/* loop is either shared or anti */
		if( eu->vu_p->v_p == eu_ref->vu_p->v_p ) 
		{
			if (rt_g.NMG_debug & DEBUG_CLASSIFY)
				bu_log( "class_shared_lu returning NMG_CLASS_AonBshared\n" );
			return( NMG_CLASS_AonBshared );
		}
		else
		{
			if (rt_g.NMG_debug & DEBUG_CLASSIFY)
				bu_log( "class_shared_lu returning NMG_CLASS_AonBanti\n" );
			return( NMG_CLASS_AonBanti );
		}
	}

	/* loop is either in or out
	 * look at next radial edge from lu_ref shell if that faceuse
	 * is OT_OPPOSITE, then we are "in", else "out"
	 */
	s_ref = nmg_find_s_of_eu( eu_ref );
	fu_of_lu = nmg_find_fu_of_lu( lu );

	for( BU_LIST_FOR( eu_start, edgeuse, &lu->down_hd ) )
	{
		int use_this_eu=1;

		eu_tmp = eu_start->eumate_p->radial_p;
		while( eu_tmp != eu_start )
		{
			struct faceuse *fu_tmp;
			struct loopuse *lu_tmp;
			int class;

			fu_tmp = nmg_find_fu_of_eu( eu_tmp );
			if( fu_tmp != fu_of_lu && fu_tmp->fumate_p != fu_of_lu )
			{
				eu_tmp = eu_tmp->eumate_p->radial_p;
				continue;
			}

			/* radial edge is part of same face
			 * make sure it is part of a loop */
			if( *eu_tmp->up.magic_p != NMG_LOOPUSE_MAGIC )
			{
				eu_tmp = eu_tmp->eumate_p->radial_p;
				continue;
			}
			lu_tmp = eu_tmp->up.lu_p;
			if( fu_tmp->fumate_p == fu_of_lu )
				lu_tmp = lu_tmp->lumate_p;

			if( lu_tmp == lu )
			{
				/* cannot classify based on this edgeuse */
				use_this_eu = 0;
				break;
			}

			class = nmg_classify_lu_lu( lu_tmp, lu, tol );
			if( lu->orientation == OT_OPPOSITE && class == NMG_CLASS_AoutB )
			{
				/* cannot classify based on this edgeuse */
				use_this_eu = 0;
				break;
			}
			else if( lu->orientation == OT_SAME && class == NMG_CLASS_AinB )
			{
				/* cannot classify based on this edgeuse */
				use_this_eu = 0;
				break;
			}

			eu_tmp = eu_tmp->eumate_p->radial_p;
		}
		if( !use_this_eu )
			continue;

		/* O.K. we can classify using this eu, look radially for a faceuse
		 * from the reference shell
		 */
		eu_tmp = eu_start->eumate_p->radial_p;
		while( eu_tmp != eu_start )
		{
			struct faceuse *fu_tmp;

			if( nmg_find_s_of_eu( eu_tmp ) == s_ref )
			{
				fu_tmp = nmg_find_fu_of_eu( eu_tmp );
				if( fu_tmp->orientation == OT_SAME )
					return( NMG_CLASS_AoutB );
				else
					return( NMG_CLASS_AinB );
			}

			eu_tmp = eu_tmp->eumate_p->radial_p;
		}
	}

	if (rt_g.NMG_debug & DEBUG_CLASSIFY)
		bu_log( "class_shared_lu returning NMG_CLASS_Unknown at end\n" );
	return( NMG_CLASS_Unknown );
}

/*
 *			C L A S S _ L U _ V S _ S
 *
 *  Called by -
 *	class_fu_vs_s
 */
static int 
class_lu_vs_s(struct loopuse *lu, struct shell *s, long int **classlist, const struct bn_tol *tol)
{
	int class;
	unsigned int	in, outside, on;
	struct edgeuse *eu, *p;
	struct loopuse *q_lu;
	struct vertexuse *vu;
	long		magic1;
	char		*reason = "Unknown";
	int		seen_error = 0;
	int		status = 0;

	if (rt_g.NMG_debug & DEBUG_CLASSIFY)
		bu_log( "class_lu_vs_s( lu=x%x, s=x%x )\n", lu, s );

	NMG_CK_LOOPUSE(lu);
	NMG_CK_SHELL(s);
	BN_CK_TOL(tol);

	if( nmg_find_s_of_lu( lu ) == s )
	{
		bu_log( "class_lu_vs_s() is trying to classify lu x%x vs its own shell (x%x)\n",
			lu, s );
		rt_bomb( "class_lu_vs_s() is trying to classify lu vs its own shell" );
	}

	/* check to see if loop is already in one of the lists */
	if( NMG_INDEX_TEST(classlist[NMG_CLASS_AinB], lu->l_p) )  {
		reason = "of classlist";
		class = NMG_CLASS_AinB;
		status = INSIDE;
		goto out;
	}

	if( NMG_INDEX_TEST(classlist[NMG_CLASS_AonBshared], lu->l_p) ) {
		reason = "of classlist";
		class = NMG_CLASS_AonBshared;
		status = ON_SURF;
		goto out;
	}
	if( NMG_INDEX_TEST(classlist[NMG_CLASS_AonBanti], lu->l_p) )  {
		reason = "of classlist";
		class = NMG_CLASS_AonBanti;
		status = ON_SURF;
		goto out;
	}

	if( NMG_INDEX_TEST(classlist[NMG_CLASS_AoutB], lu->l_p) )  {
		reason = "of classlist";
		class = NMG_CLASS_AoutB;
		status = OUTSIDE;
		goto out;
	}

	magic1 = BU_LIST_FIRST_MAGIC( &lu->down_hd );
	if (magic1 == NMG_VERTEXUSE_MAGIC) {
		/* Loop of a single vertex */
		reason = "of vertex classification";
		vu = BU_LIST_PNEXT( vertexuse, &lu->down_hd );
		NMG_CK_VERTEXUSE(vu);
		class = class_vu_vs_s(vu, s, classlist, tol);
		switch (class) {
		case INSIDE:
			NMG_INDEX_SET(classlist[NMG_CLASS_AinB], lu->l_p);
			break;
		case OUTSIDE:
			NMG_INDEX_SET(classlist[NMG_CLASS_AoutB], lu->l_p);
			 break;
		case ON_SURF:
			NMG_INDEX_SET(classlist[NMG_CLASS_AonBshared], lu->l_p);
			break;
		default:
			rt_bomb("class_lu_vs_s: bad vertexloop classification\n");
		}
		status = class;
		goto out;
	} else if (magic1 != NMG_EDGEUSE_MAGIC) {
		rt_bomb("class_lu_vs_s: bad child of loopuse\n");
	}

	/* loop is collection of edgeuses */
retry:
	in = outside = on = 0;
	for (BU_LIST_FOR(eu, edgeuse, &lu->down_hd)) {
		/* Classify each edgeuse */
		class = class_eu_vs_s(eu, s, classlist, tol);
		switch (class) {
		case INSIDE	: ++in; 
				break;
		case OUTSIDE	: ++outside;
				break;
		case ON_SURF	: ++on;
				break;
		default		: rt_bomb("class_lu_vs_s: bad class for edgeuse\n");
		}
	}

	if (rt_g.NMG_debug & DEBUG_CLASSIFY)
		bu_log("class_lu_vs_s: Loopuse edges in:%d on:%d out:%d\n", in, on, outside);

	if (in > 0 && outside > 0) {
		FILE *fp;

		if( rt_g.NMG_debug & DEBUG_CLASSIFY )  {
			char		buf[128];
			static int	num;
			long		*b;
			struct model	*m;

			m = nmg_find_model(lu->up.magic_p);
			b = (long *)bu_calloc(m->maxindex, sizeof(long), "nmg_pl_lu flag[]");

			for(BU_LIST_FOR(eu, edgeuse, &lu->down_hd)) {
				if (NMG_INDEX_TEST(classlist[NMG_CLASS_AinB], eu->e_p))
					nmg_euprint("In:  edgeuse", eu);
				else if (NMG_INDEX_TEST(classlist[NMG_CLASS_AoutB], eu->e_p))
					nmg_euprint("Out: edgeuse", eu);
				else if (NMG_INDEX_TEST(classlist[NMG_CLASS_AonBshared], eu->e_p))
					nmg_euprint("OnShare:  edgeuse", eu);
				else if (NMG_INDEX_TEST(classlist[NMG_CLASS_AonBanti], eu->e_p))
					nmg_euprint("OnAnti:  edgeuse", eu);
				else
					nmg_euprint("BAD: edgeuse", eu);
			}

			sprintf(buf, "badloop%d.pl", num++);
			if ((fp=fopen(buf, "w")) != NULL) {
				nmg_pl_lu(fp, lu, b, 255, 255, 255);
				nmg_pl_s(fp, s);
				fclose(fp);
				bu_log("wrote %s\n", buf);
			}
			nmg_pr_lu(lu, "");
			nmg_stash_model_to_file( "class.g", nmg_find_model((long *)lu), "class_ls_vs_s: loop transits plane of shell/face?");
			bu_free( (char *)b, "nmg_pl_lu flag[]" );
		}
		if(seen_error)
			rt_bomb("class_lu_vs_s: loop transits plane of shell/face?\n");
		seen_error = 1;
		goto retry;
	}
	if (outside > 0) {
		NMG_INDEX_SET(classlist[NMG_CLASS_AoutB], lu->l_p);
		reason = "edgeuses were OUT and ON";
		class = NMG_CLASS_AoutB;
		status = OUTSIDE;
		goto out;
	} else if (in > 0) {
		NMG_INDEX_SET(classlist[NMG_CLASS_AinB], lu->l_p);
		reason = "edgeuses were IN and ON";
		class = NMG_CLASS_AinB;
		status = INSIDE;
		goto out;
	} else if (on == 0)
		rt_bomb("class_lu_vs_s: alright, who's the wiseguy that stole my edgeuses?\n");


	if (rt_g.NMG_debug & DEBUG_CLASSIFY)
		bu_log("\tAll edgeuses of loop are ON\n");

	/* since all of the edgeuses of this loop are "on" the other shell,
	 * we need to see if this loop is "on" the other shell
	 *
	 * if we're a wire edge loop, simply having all edges "on" is
	 *	sufficient.
	 *
	 * foreach radial edgeuse
	 * 	if edgeuse vertex is same and edgeuse parent shell is the one
	 *	 	desired, then....
	 *
	 *		p = edgeuse, q = radial edgeuse
	 *		while p's vertex equals q's vertex and we
	 *			haven't come full circle
	 *			move p and q forward
	 *		if we made it full circle, loop is on
	 */

	if (*lu->up.magic_p == NMG_SHELL_MAGIC) {
		NMG_INDEX_SET(classlist[NMG_CLASS_AonBshared], lu->l_p);
		reason = "loop is a wire loop in the shell";
		class = NMG_CLASS_AonBshared;
		status = ON_SURF;
		goto out;
	}

	NMG_CK_FACEUSE(lu->up.fu_p);

#if 0
	eu = BU_LIST_FIRST(edgeuse, &lu->down_hd);
	for(
	    eu = eu->radial_p->eumate_p;
	    eu != BU_LIST_FIRST(edgeuse, &lu->down_hd);
	    eu = eu->radial_p->eumate_p
	)  {
		int	code;

		/* if the radial edge is a part of a loop which is part of
		 * a face, then it's one that we might be "on"
		 */
		if( *eu->up.magic_p != NMG_LOOPUSE_MAGIC ) continue;
	    	q_lu = eu->up.lu_p;
		if( *q_lu->up.magic_p != NMG_FACEUSE_MAGIC ) continue;

		if( q_lu == lu )  continue;

		/* Only consider faces from shell 's' */
		if( q_lu->up.fu_p->s_p != s )  continue;

		code = nmg_2lu_identical( eu,
			BU_LIST_FIRST(edgeuse, &lu->down_hd) );
	    	switch(code)  {
	    	default:
	    	case 0:
	    		/* Not identical */
	    		break;
	    	case 1:
	    		/* ON-shared */
	    		if( lu->orientation == OT_OPPOSITE )  {
			    	NMG_INDEX_SET(classlist[NMG_CLASS_AonBanti],
			    		lu->l_p );
				if (rt_g.NMG_debug & DEBUG_CLASSIFY)
					bu_log("Loop is on-antishared (lu orient is OT_OPPOSITE)\n");
				nmg_reclassify_lu_eu( lu, classlist, NMG_CLASS_AonBanti );
	    		}  else {
			    	NMG_INDEX_SET(classlist[NMG_CLASS_AonBshared],
			    		lu->l_p );
				if (rt_g.NMG_debug & DEBUG_CLASSIFY)
					bu_log("Loop is on-shared\n");
	    			/* no need to reclassify, edges were previously marked as AonBshared */
	    		}
			reason = "edges identical with radial face, normals colinear";
	    		status = ON_SURF;
	    		goto out;
	    	case 2:
	    		/* ON-antishared */
	    		if( lu->orientation == OT_OPPOSITE )  {
				NMG_INDEX_SET(classlist[NMG_CLASS_AonBshared],
					lu->l_p );
				if (rt_g.NMG_debug & DEBUG_CLASSIFY)
					bu_log("Loop is on-shared (lu orient is OT_OPPOSITE)\n");
	    			/* no need to reclassify, edges were previously marked as AonBshared */
	    		}  else  {
				NMG_INDEX_SET(classlist[NMG_CLASS_AonBanti],
					lu->l_p );
				if (rt_g.NMG_debug & DEBUG_CLASSIFY)
					bu_log("Loop is on-antishared\n");
				nmg_reclassify_lu_eu( lu, classlist, NMG_CLASS_AonBanti );
	    		}
			reason = "edges identical with radial face, normals opposite";
			status = ON_SURF;
			goto out;
	    	case 3:
	    		rt_bomb("class_lu_vs_s() unexpected wire ON\n");
		}
	}
#else
	class = NMG_CLASS_Unknown;
	eu = BU_LIST_FIRST(edgeuse, &lu->down_hd);
	for(
	    eu = eu->radial_p->eumate_p;
	    eu != BU_LIST_FIRST(edgeuse, &lu->down_hd) ;
	    eu = eu->radial_p->eumate_p )
	{
		struct faceuse *fu_qlu;
		struct edgeuse *eu1;
		struct edgeuse *eu2;
		int found_match;

		/* if the radial edge is a part of a loop which is part of
		 * a face, then it's one that we might be "on"
		 */
		if( *eu->up.magic_p != NMG_LOOPUSE_MAGIC ) continue;
	    	q_lu = eu->up.lu_p;
		if( *q_lu->up.magic_p != NMG_FACEUSE_MAGIC ) continue;
		fu_qlu = q_lu->up.fu_p;
		NMG_CK_FACEUSE( fu_qlu );

		if( q_lu == lu )  continue;

		/* Only consider faces from shell 's' */
		if( q_lu->up.fu_p->s_p != s )  continue;

		if (rt_g.NMG_debug & DEBUG_CLASSIFY)
			bu_log( "\tfound radial lu (x%x), check for match\n", q_lu );

		/* now check if eu's match in both LU's */
		eu1 = BU_LIST_FIRST(edgeuse, &lu->down_hd);
		if( eu1->vu_p->v_p == eu->vu_p->v_p )
			eu2 = eu;
		else if( eu1->vu_p->v_p == eu->eumate_p->vu_p->v_p )
			eu2 = BU_LIST_PNEXT_CIRC( edgeuse, &eu->l );
		else
			eu2 = BU_LIST_PPREV_CIRC( edgeuse, &eu->l );
		found_match = 1;
		do
		{
			if (rt_g.NMG_debug & DEBUG_CLASSIFY)
				bu_log( "\t\tcompare vertex x%x to vertex x%x\n", eu1->vu_p->v_p, eu2->vu_p->v_p );
			if( eu1->vu_p->v_p != eu2->vu_p->v_p )
			{
				if (rt_g.NMG_debug & DEBUG_CLASSIFY)
					bu_log( "\t\t\tnot a match\n" );
				found_match = 0;
				break;
			}
			eu1 = BU_LIST_PNEXT_CIRC( edgeuse, &eu1->l );
			eu2 = BU_LIST_PNEXT_CIRC( edgeuse, &eu2->l );
		} while( eu1 != BU_LIST_FIRST(edgeuse, &lu->down_hd));

		if( !found_match )
		{
			/* check opposite direction */
			if (rt_g.NMG_debug & DEBUG_CLASSIFY)
				bu_log( "\tChecking for match in opposite direction\n" );
			eu1 = BU_LIST_FIRST(edgeuse, &lu->down_hd);
			if( eu1->vu_p->v_p == eu->vu_p->v_p )
				eu2 = eu;
			else if( eu1->vu_p->v_p == eu->eumate_p->vu_p->v_p )
				eu2 = BU_LIST_PNEXT_CIRC( edgeuse, &eu->l );
			else
				eu2 = BU_LIST_PPREV_CIRC( edgeuse, &eu->l );
			found_match = 1;
			do
			{
				if (rt_g.NMG_debug & DEBUG_CLASSIFY)
					bu_log( "\t\tcompare vertex x%x to vertex x%x\n", eu1->vu_p->v_p, eu2->vu_p->v_p );
				if( eu1->vu_p->v_p != eu2->vu_p->v_p )
				{
					if (rt_g.NMG_debug & DEBUG_CLASSIFY)
						bu_log( "\t\t\tnot a match\n" );
					found_match = 0;
					break;
				}
				eu1 = BU_LIST_PNEXT_CIRC( edgeuse, &eu1->l );
				eu2 = BU_LIST_PPREV_CIRC( edgeuse, &eu2->l );
			} while( eu1 != BU_LIST_FIRST(edgeuse, &lu->down_hd));
		}

		if( found_match )
		{
			int test_class = NMG_CLASS_Unknown;

			if (rt_g.NMG_debug & DEBUG_CLASSIFY)
				bu_log( "\tFound a matching LU's x%x and x%x\n", lu, q_lu );

			if( fu_qlu->orientation == OT_SAME )
				test_class = class_shared_lu( lu, q_lu, tol );
			else if( fu_qlu->orientation == OT_OPPOSITE )
				test_class = class_shared_lu( lu, q_lu->lumate_p, tol );
			else
			{
				bu_log( "class_lu_vs_s: FU x%x for lu x%x matching lu x%x has bad orientation (%s)\n",
					fu_qlu, lu, q_lu, nmg_orientation( fu_qlu->orientation ) );
				rt_bomb( "class_lu_vs_s: FU has bad orientation\n" );
			}

			if (rt_g.NMG_debug & DEBUG_CLASSIFY)
				bu_log( "\tclass_shared_lu says %s\n", nmg_class_name( test_class ) );

			if( class == NMG_CLASS_Unknown )
				class = test_class;
			else if( test_class == NMG_CLASS_AonBshared || test_class == NMG_CLASS_AonBanti )
				class = test_class;

			if (rt_g.NMG_debug & DEBUG_CLASSIFY)
				bu_log( "\tclass set to %s\n",  nmg_class_name( class ) );

			if( class == NMG_CLASS_AonBshared )
				break;
		}

	}

	if( class != NMG_CLASS_Unknown )
	{
		if (rt_g.NMG_debug & DEBUG_CLASSIFY)
			bu_log( "Final class = %s\n", nmg_class_name( class ) );
		NMG_INDEX_SET( classlist[class],lu->l_p );
		if( class == NMG_CLASS_AonBanti )
			nmg_reclassify_lu_eu( lu, classlist, NMG_CLASS_AonBanti );

		reason = "edges identical with radial face";
		status = ON_SURF;
		goto out;
	}
#endif

	/* OK, the edgeuses are all "on", but the loop isn't.  Time to
	 * decide if the loop is "out" or "in".  To do this, we look for
	 * an edgeuse radial to one of the edgeuses in the loop which is
	 * a part of a face in the other shell.  If/when we find such a
	 * radial edge, we check the direction (in/out) of the faceuse normal.
	 * if the faceuse normal is pointing out of the shell, we are outside.
	 * if the faceuse normal is pointing into the shell, we are inside.
	 */

	if (rt_g.NMG_debug & DEBUG_CLASSIFY)
	{
		bu_log( "Checking radial faces:\n" );
		nmg_pr_fu_around_eu( eu, tol );
	}

	for (BU_LIST_FOR(eu, edgeuse, &lu->down_hd)) {

		p = eu->radial_p;
		do {
			if (*p->up.magic_p == NMG_LOOPUSE_MAGIC &&
			    *p->up.lu_p->up.magic_p == NMG_FACEUSE_MAGIC &&
			    p->up.lu_p->up.fu_p->s_p == s) {

			    	if (p->up.lu_p->up.fu_p->orientation == OT_OPPOSITE) {
			    		NMG_INDEX_SET(classlist[NMG_CLASS_AinB],
			    			lu->l_p );
					if (rt_g.NMG_debug & DEBUG_CLASSIFY)
						bu_log("Loop is INSIDE of fu x%x\n", p->up.lu_p->up.fu_p);
			    		reason = "radial faceuse is OT_OPPOSITE";
			    		class = NMG_CLASS_AinB;
			    		status = INSIDE;
			    		goto out;
			    	} else if (p->up.lu_p->up.fu_p->orientation == OT_SAME) {
			    		NMG_INDEX_SET(classlist[NMG_CLASS_AoutB],
			    			lu->l_p );
					if (rt_g.NMG_debug & DEBUG_CLASSIFY)
						bu_log("Loop is OUTSIDEof fu x%x\n", p->up.lu_p->up.fu_p);
			    		reason = "radial faceuse is OT_SAME";
			    		class = NMG_CLASS_AoutB;
			    		status = OUTSIDE;
					goto out;
			    	} else {
			    		rt_bomb("class_lu_vs_s() bad fu orientation\n");
			    	}
			}
			p = p->eumate_p->radial_p;
		} while (p != eu->eumate_p);

	}

	if (rt_g.NMG_debug & DEBUG_CLASSIFY)
		bu_log("Loop is OUTSIDE 'cause it isn't anything else\n");

	/* Since we didn't find any radial faces to classify ourselves against
	 * and we already know that the edges are all "on" that must mean that
	 * the loopuse is "on" a wireframe portion of the shell.
	 */
	NMG_INDEX_SET( classlist[NMG_CLASS_AoutB], lu->l_p );
	reason = "loopuse is ON a wire loop in the shell";
	class = NMG_CLASS_AoutB;
	status = OUTSIDE;
out:
	if (rt_g.NMG_debug & DEBUG_CLASSIFY) {
		bu_log("class_lu_vs_s(lu=x%x) return %s (%s) because %s\n",
			lu, nmg_class_status(status), nmg_class_name( class ), reason );
	}
	return status;
}

/*
 *			C L A S S _ F U _ V S _ S
 *
 *  Called by -
 *	nmg_class_shells()
 */
static void 
class_fu_vs_s(struct faceuse *fu, struct shell *s, long int **classlist, const struct bn_tol *tol)
{
	struct loopuse *lu;
	plane_t		n;
	
	NMG_CK_FACEUSE(fu);
	NMG_CK_SHELL(s);

	NMG_GET_FU_PLANE( n, fu );

	if (rt_g.NMG_debug & DEBUG_CLASSIFY)
        	PLPRINT("\nclass_fu_vs_s plane equation:", n);

	for (BU_LIST_FOR(lu, loopuse, &fu->lu_hd))
		(void)class_lu_vs_s(lu, s, classlist, tol);

	if (rt_g.NMG_debug & DEBUG_CLASSIFY)
		bu_log("class_fu_vs_s() END\n");
}

/*
 *			N M G _ C L A S S _ S H E L L S
 *
 *	Classify one shell WRT the other shell
 *
 *  Implicit return -
 *	Each element's classification will be represented by a
 *	SET entry in the appropriate classlist[] array.
 *
 *  Called by -
 *	nmg_bool.c
 */
void
nmg_class_shells(struct shell *sA, struct shell *sB, long int **classlist, const struct bn_tol *tol)
{
	struct faceuse *fu;
	struct loopuse *lu;
	struct edgeuse *eu;

	NMG_CK_SHELL(sA);
	NMG_CK_SHELL(sB);
	BN_CK_TOL(tol);

	if (rt_g.NMG_debug & DEBUG_CLASSIFY &&
	    BU_LIST_NON_EMPTY(&sA->fu_hd))
		bu_log("nmg_class_shells - doing faces\n");

	fu = BU_LIST_FIRST(faceuse, &sA->fu_hd);
	while (BU_LIST_NOT_HEAD(fu, &sA->fu_hd)) {

		class_fu_vs_s(fu, sB, classlist, tol);

		if (BU_LIST_PNEXT(faceuse, fu) == fu->fumate_p)
			fu = BU_LIST_PNEXT_PNEXT(faceuse, fu);
		else
			fu = BU_LIST_PNEXT(faceuse, fu);
	}
	
	if (rt_g.NMG_debug & DEBUG_CLASSIFY &&
	    BU_LIST_NON_EMPTY(&sA->lu_hd))
		bu_log("nmg_class_shells - doing loops\n");

	lu = BU_LIST_FIRST(loopuse, &sA->lu_hd);
	while (BU_LIST_NOT_HEAD(lu, &sA->lu_hd)) {

		(void)class_lu_vs_s(lu, sB, classlist, tol);

		if (BU_LIST_PNEXT(loopuse, lu) == lu->lumate_p)
			lu = BU_LIST_PNEXT_PNEXT(loopuse, lu);
		else
			lu = BU_LIST_PNEXT(loopuse, lu);
	}

	if (rt_g.NMG_debug & DEBUG_CLASSIFY &&
	    BU_LIST_NON_EMPTY(&sA->eu_hd))
		bu_log("nmg_class_shells - doing edges\n");

	eu = BU_LIST_FIRST(edgeuse, &sA->eu_hd);
	while (BU_LIST_NOT_HEAD(eu, &sA->eu_hd)) {

		(void)class_eu_vs_s(eu, sB, classlist, tol);

		if (BU_LIST_PNEXT(edgeuse, eu) == eu->eumate_p)
			eu = BU_LIST_PNEXT_PNEXT(edgeuse, eu);
		else
			eu = BU_LIST_PNEXT(edgeuse, eu);
	}

	if (sA->vu_p) {
		if (rt_g.NMG_debug)
			bu_log("nmg_class_shells - doing vertex\n");
		(void)class_vu_vs_s(sA->vu_p, sB, classlist, tol);
	}
}

/*	N M G _ C L A S S I F Y _ P T _ L O O P
 *
 *	A generally available interface to nmg_class_pt_l
 *
 *	returns the classification from nmg_class_pt_l
 *	or a (-1) on error
 *
 *  Called by -
 *	nmg_extrude.c / nmg_fix_overlapping_loops()
 *
 *  XXX DANGER:  Calls nmg_class_pt_l(), which does not work well.
 */
int
nmg_classify_pt_loop(const point_t pt,
		     const struct loopuse *lu,
		     const struct bn_tol *tol)
{
	struct neighbor	closest;
	struct faceuse *fu;
	plane_t n;
	fastf_t dist;

	NMG_CK_LOOPUSE( lu );
	BN_CK_TOL( tol );

bu_log("DANGER: nmg_classify_pt_loop() is calling nmg_class_pt_l(), which does not work well\n");
	if( *lu->up.magic_p != NMG_FACEUSE_MAGIC )
	{
		bu_log( "nmg_classify_pt_loop: lu not part of a faceuse!!\n" );
		return( -1 );
	}

	fu = lu->up.fu_p;

	/* Validate distance from point to plane */
	NMG_GET_FU_PLANE( n, fu );
	if( (dist=fabs(DIST_PT_PLANE( pt, n ))) > tol->dist )  {
		bu_log("nmg_classify_pt_l() ERROR, point (%g,%g,%g) not on face, dist=%g\n",
			V3ARGS(pt), dist );
		return( -1 );
	}


	/* find the closest approach in this face to the projected point */
	closest.dist = MAX_FASTF;
	closest.p.eu = (struct edgeuse *)NULL;
	closest.class = NMG_CLASS_AoutB;	/* default return */

	nmg_class_pt_l( &closest , pt , lu , tol );

	return( closest.class );
}

/*		N M G _ G E T _ I N T E R I O R _ P T
 *
 *	Find any point that is interior to LU
 *
 *	Returns:
 *		0 - All is well
 *		1 - Loop is not part of a faceuse
 *		2 - Loop is a single vertexuse
 *		3 - Loop is a crack
 *		4 - Just plain can't find an interior point
 */
int
nmg_get_interior_pt(fastf_t *pt, const struct loopuse *lu, const struct bn_tol *tol)
{
	struct edgeuse *eu;
	fastf_t point_count=0.0;
	double one_over_count;
	point_t test_pt;
	point_t average_pt;
	int i;

	NMG_CK_LOOPUSE( lu );
	BN_CK_TOL( tol );

	if( *lu->up.magic_p != NMG_FACEUSE_MAGIC )
		return( 1 );

	if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
		return( 2 );

	if( nmg_loop_is_a_crack( lu ) )
		return( 3 );

	/* first try just averaging all the vertices */
	VSETALL( average_pt, 0.0 );
	for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
	{
		struct vertex_g *vg;
		NMG_CK_EDGEUSE( eu );

		vg = eu->vu_p->v_p->vg_p;
		NMG_CK_VERTEX_G( vg );

		VADD2( average_pt, average_pt, vg->coord );
		point_count++;
	}

	one_over_count = 1.0/point_count;
	VSCALE( average_pt, average_pt, one_over_count );
	VMOVE( test_pt, average_pt );

	if (nmg_class_pt_lu_except( test_pt, lu, (struct edge *)NULL, tol ) == NMG_CLASS_AinB )
	{
		VMOVE( pt, test_pt );
		return( 0 );
	}

	for( i=0 ; i<3 ; i++ )
	{

		double tol_mult;

		/* Try moving just a little left of an edge */
		switch( i )
		{
			case 0:
				tol_mult = 5.0 * tol->dist;
				break;
			case 1:
				tol_mult = 1.5 * tol->dist;
				break;
			case 2:
				tol_mult = 1.005 * tol->dist;
				break;
			default:			/* sanity / lint */
				tol_mult = 1;
				break;
		}
		for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
		{
			vect_t left;
			struct vertex_g *vg1,*vg2;

			(void)nmg_find_eu_leftvec( left, eu );

			vg1 = eu->vu_p->v_p->vg_p;
			vg2 = eu->eumate_p->vu_p->v_p->vg_p;

			VADD2( test_pt, vg1->coord, vg2->coord );
			VSCALE( test_pt, test_pt, 0.5 );

			VJOIN1( test_pt, test_pt, tol_mult, left );
			if( nmg_class_pt_lu_except( test_pt, lu, (struct edge *)NULL, tol ) == NMG_CLASS_AinB )
			{
				VMOVE( pt, test_pt );
				return( 0 );
			}
		}
	}

	if( rt_g.NMG_debug & DEBUG_CLASSIFY )
	{
		bu_log( "nmg_get_interior_pt: Couldn't find interior point for lu x%x\n", lu );
		nmg_pr_lu_briefly( lu, "" );
	}

	VMOVE( pt, average_pt );
	return( 4 );
}

/*	N M G _ C L A S S I F Y _ L U _ L U
 *
 *	Generally available classifier for
 *	determining if one loop is within another
 *
 *	returns classification based on nmg_class_pt_l results
 *
 *  Called by -
 *	nmg_misc.c / nmg_split_loops_handler()
 *
 */
int
nmg_classify_lu_lu(const struct loopuse *lu1, const struct loopuse *lu2, const struct bn_tol *tol)
{
	struct faceuse *fu1,*fu2;
	struct edgeuse *eu;
	int share_edges;
	int lu1_eu_count=0;
	int lu2_eu_count=0;

	NMG_CK_LOOPUSE( lu1 );
	NMG_CK_LOOPUSE( lu2 );
	BN_CK_TOL( tol );

	if( rt_g.NMG_debug & DEBUG_CLASSIFY )
		bu_log( "nmg_classify_lu_lu( lu1=x%x , lu2=x%x )\n", lu1, lu2 );

	if( lu1 == lu2 || lu1 == lu2->lumate_p )
		return( NMG_CLASS_AonBshared );

	if( *lu1->up.magic_p != NMG_FACEUSE_MAGIC )
	{
		bu_log( "nmg_classify_lu_lu: lu1 not part of a faceuse\n" );
		return( -1 );
	}

	if( *lu2->up.magic_p != NMG_FACEUSE_MAGIC )
	{
		bu_log( "nmg_classify_lu_lu: lu2 not part of a faceuse\n" );
		return( -1 );
	}

	fu1 = lu1->up.fu_p;
	NMG_CK_FACEUSE( fu1 );
	fu2 = lu2->up.fu_p;
	NMG_CK_FACEUSE( fu2 );

	if( fu1->f_p != fu2->f_p )
	{
		bu_log( "nmg_classify_lu_lu: loops are not in same face\n" );
		return( -1 );
	}

	/* do simple check for two loops of the same vertices */
	if( BU_LIST_FIRST_MAGIC( &lu1->down_hd ) == NMG_EDGEUSE_MAGIC &&
	    BU_LIST_FIRST_MAGIC( &lu2->down_hd ) == NMG_EDGEUSE_MAGIC )
	{
		struct edgeuse *eu1_start,*eu2_start;
		struct edgeuse *eu1,*eu2;

		/* count EU's in lu1 */
		for( BU_LIST_FOR( eu, edgeuse, &lu1->down_hd ) )
			lu1_eu_count++;

		/* count EU's in lu2 */
		for( BU_LIST_FOR( eu, edgeuse, &lu2->down_hd ) )
			lu2_eu_count++;

		share_edges = 1;
		eu1_start = BU_LIST_FIRST( edgeuse , &lu1->down_hd );
		NMG_CK_EDGEUSE( eu1_start );
		eu2_start = BU_LIST_FIRST( edgeuse , &lu2->down_hd );
		NMG_CK_EDGEUSE( eu2_start );
		while( BU_LIST_NOT_HEAD( eu2_start , &lu2->down_hd ) &&
			eu2_start->e_p != eu1_start->e_p )
		{
			NMG_CK_EDGEUSE( eu2_start );
			eu2_start = BU_LIST_PNEXT( edgeuse , &eu2_start->l );
		}

		if( BU_LIST_NOT_HEAD( eu2_start , &lu2->down_hd ) &&
			eu1_start->e_p == eu2_start->e_p )
		{
			/* check the rest of the loop */
			share_edges = 1;
			eu1 = eu1_start;
			eu2 = eu2_start;
			do
			{
				if( eu1->e_p != eu2->e_p )
				{
					share_edges = 0;
					break;
				}
				eu1 = BU_LIST_PNEXT_CIRC( edgeuse , &eu1->l );
				eu2 = BU_LIST_PNEXT_CIRC( edgeuse , &eu2->l );
			} while( eu1 != eu1_start );

			if( !share_edges )
			{
				/* maybe the other way round */
				share_edges = 1;
				eu1 = eu1_start;
				eu2 = eu2_start;
				do
				{
					if( eu1->e_p != eu2->e_p )
					{
						share_edges = 0;
						break;
					}
					eu1 = BU_LIST_PNEXT_CIRC( edgeuse , &eu1->l );
					eu2 = BU_LIST_PPREV_CIRC( edgeuse , &eu2->l );
				} while( eu1 != eu1_start );
			}

			if( share_edges && lu1_eu_count == lu2_eu_count )
			{
				if( rt_g.NMG_debug & DEBUG_CLASSIFY )
					bu_log( "nmg_classify_lu_lu returning NMG_CLASS_AonBshared\n" );
				return( NMG_CLASS_AonBshared );
			}
			else
			{
				vect_t inward1,inward2;

				/* not all edges are shared,
				 * try to fnd a vertex in lu1
				 * that is not in lu2
				 */
				for( BU_LIST_FOR( eu , edgeuse , &lu1->down_hd ) )
				{
					struct vertex_g *vg;
					int class;

					NMG_CK_EDGEUSE( eu );

					vg = eu->vu_p->v_p->vg_p;
					NMG_CK_VERTEX_G( vg );

					if( nmg_find_vertex_in_lu( eu->vu_p->v_p, lu2 ) != NULL )
						continue;

					class = nmg_class_pt_lu_except( vg->coord, lu2, (struct edge *)NULL, tol);
					if( class != NMG_CLASS_AonBshared && class != NMG_CLASS_AonBanti )
					{
						if( lu2->orientation == OT_SAME )
						{
							if( rt_g.NMG_debug & DEBUG_CLASSIFY )
								bu_log( "nmg_classify_lu_lu returning %s\n", nmg_class_name( class ) );
							return( class );
						}
						else
						{
							if( class == NMG_CLASS_AinB )
							{
								if( rt_g.NMG_debug & DEBUG_CLASSIFY )
									bu_log( "nmg_classify_lu_lu returning NMG_CLASS_AoutB\n" );
								return( NMG_CLASS_AoutB );
							}
							if( class == NMG_CLASS_AoutB )
							{
								if( rt_g.NMG_debug & DEBUG_CLASSIFY )
									bu_log( "nmg_classify_lu_lu returning NMG_CLASS_AinB\n" );
								return( NMG_CLASS_AinB );
							}
						}
					}
				}

				/* Some of lu1 edges are on lu2, but loops are not shared.
				 * Compare inward vectors of a shared edge.
				 */

				nmg_find_eu_leftvec( inward1, eu1_start );
				if( lu1->orientation == OT_OPPOSITE )
					VREVERSE( inward1, inward1 );

				nmg_find_eu_leftvec( inward2, eu2_start );
				if( lu2->orientation == OT_OPPOSITE )
					VREVERSE( inward2, inward2 );

				if( VDOT( inward1, inward2 ) < 0.0 )
					return( NMG_CLASS_AoutB );
				else
					return( NMG_CLASS_AinB );
			}
		}
		else
		{
			/* no matching edges, classify by vertices */
			for( BU_LIST_FOR( eu , edgeuse , &lu1->down_hd ) )
			{
				struct vertex_g *vg;
				int class;

				NMG_CK_EDGEUSE( eu );

				vg = eu->vu_p->v_p->vg_p;
				NMG_CK_VERTEX_G( vg );

				if( nmg_find_vertex_in_lu( eu->vu_p->v_p, lu2 ) != NULL )
					continue;

				class = nmg_class_pt_lu_except( vg->coord, lu2, (struct edge *)NULL, tol);
				if( class != NMG_CLASS_AonBshared && class != NMG_CLASS_AonBanti )
				{
					if( lu2->orientation == OT_SAME )
					{
						if( rt_g.NMG_debug & DEBUG_CLASSIFY )
							bu_log( "nmg_classify_lu_lu returning %s\n", nmg_class_name( class ) );
						return( class );
					}
					else
					{
						if( class == NMG_CLASS_AinB )
						{
							if( rt_g.NMG_debug & DEBUG_CLASSIFY )
								bu_log( "nmg_classify_lu_lu returning NMG_CLASS_AoutB\n" );
							return( NMG_CLASS_AoutB );
						}
						if( class == NMG_CLASS_AoutB )
						{
							if( rt_g.NMG_debug & DEBUG_CLASSIFY )
								bu_log( "nmg_classify_lu_lu returning NMG_CLASS_AinB\n" );
							return( NMG_CLASS_AinB );
						}
					}
				}
			}

			/* if we get here, all vertices are shared,
			 * but no edges are!!!!! Check the midpoint of edges.
			 */
			for( BU_LIST_FOR( eu , edgeuse , &lu1->down_hd ) )
			{
				struct vertex_g *vg1,*vg2;
				int class;
				point_t mid_pt;

				vg1 = eu->vu_p->v_p->vg_p;
				vg2 = eu->eumate_p->vu_p->v_p->vg_p;

				VADD2( mid_pt, vg1->coord, vg2->coord );
				VSCALE( mid_pt, mid_pt, 0.5 );

				class = nmg_class_pt_lu_except( mid_pt, lu2, (struct edge *)NULL, tol);
				if( class != NMG_CLASS_AonBshared && class != NMG_CLASS_AonBanti )
				{
					if( lu2->orientation == OT_SAME )
					{
						if( rt_g.NMG_debug & DEBUG_CLASSIFY )
							bu_log( "nmg_classify_lu_lu returning %s\n", nmg_class_name( class ) );
						return( class );
					}
					else
					{
						if( class == NMG_CLASS_AinB )
						{
							if( rt_g.NMG_debug & DEBUG_CLASSIFY )
								bu_log( "nmg_classify_lu_lu returning NMG_CLASS_AoutB\n" );
							return( NMG_CLASS_AoutB );
						}
						if( class == NMG_CLASS_AoutB )
						{
							if( rt_g.NMG_debug & DEBUG_CLASSIFY )
								bu_log( "nmg_classify_lu_lu returning NMG_CLASS_AinB\n" );
							return( NMG_CLASS_AinB );
						}
					}
				}
			}

			/* Should never get here */
			bu_log( "nmg_classify_lu_lu: Cannot classify lu x%x w.r.t. lu x%x\n",
					lu1, lu2 );
			return( NMG_CLASS_Unknown );
		}
	}
	else if( BU_LIST_FIRST_MAGIC( &lu1->down_hd ) == NMG_VERTEXUSE_MAGIC &&
		 BU_LIST_FIRST_MAGIC( &lu2->down_hd ) == NMG_VERTEXUSE_MAGIC )
	{
		struct vertexuse *vu1,*vu2;

		vu1 = BU_LIST_FIRST( vertexuse , &lu1->down_hd );
		vu2 = BU_LIST_FIRST( vertexuse , &lu2->down_hd );

		if( vu1->v_p == vu2->v_p )
		{
			if( rt_g.NMG_debug & DEBUG_CLASSIFY )
				bu_log( "nmg_classify_lu_lu returning NMG_CLASS_AonBshared\n" );
			return( NMG_CLASS_AonBshared );
		}
		else
		{
			if( rt_g.NMG_debug & DEBUG_CLASSIFY )
				bu_log( "nmg_classify_lu_lu returning NMG_CLASS_AoutB\n" );
			return( NMG_CLASS_AoutB );
		}
	}

	if( BU_LIST_FIRST_MAGIC( &lu1->down_hd ) == NMG_VERTEXUSE_MAGIC )
	{
		struct vertexuse *vu;
		struct vertex_g *vg;
		int class;

		vu = BU_LIST_FIRST( vertexuse , &lu1->down_hd );
		NMG_CK_VERTEXUSE( vu );
		vg = vu->v_p->vg_p;
		NMG_CK_VERTEX_G( vg );

		class = nmg_class_pt_lu_except( vg->coord, lu2,
						(struct edge *)NULL, tol );

		if( lu2->orientation == OT_OPPOSITE )
		{
			if( class == NMG_CLASS_AoutB )
				class = NMG_CLASS_AinB;
			else if( class == NMG_CLASS_AinB )
				class = NMG_CLASS_AoutB;
		}
		if( rt_g.NMG_debug & DEBUG_CLASSIFY )
			bu_log( "nmg_classify_lu_lu returning %s\n", nmg_class_name( class ) );
		return( class );
	}
	else if( BU_LIST_FIRST_MAGIC( &lu2->down_hd ) == NMG_VERTEXUSE_MAGIC )
		return( NMG_CLASS_AoutB );

	bu_log( "nmg_classify_lu_lu: ERROR, Should not get here!!!\n" );
	rt_bomb(  "nmg_classify_lu_lu: ERROR, Should not get here!!!\n" );

	return( -1); /* to make the compilers happy */
}

/*		N M G _ C L A S S I F Y _ S _ V S _S
 *
 *	Classify one shell (s2) with respect to another (s).
 *
 *	returns:
 *		NMG_CLASS_AinB if s2 is inside s
 *		NMG_CLASS_AoutB is s2 is outside s
 *		NMG_CLASS_Unknown if we can't tell
 *
 *	Assumes (but does not verify) that these two shells do not
 *	overlap, but are either entirely separate or entirely within
 *	one or the other.
 */
int
nmg_classify_s_vs_s(struct shell *s2, struct shell *s, const struct bn_tol *tol)
{
	int i;
	int class;
	struct faceuse *fu;
	struct loopuse *lu;
	struct edgeuse *eu;
	point_t pt_in_s2;
	struct bu_ptbl verts;

	if( !V3RPP1_IN_RPP2( s2->sa_p->min_pt, s2->sa_p->max_pt, s->sa_p->min_pt, s->sa_p->max_pt ) )
		return( NMG_CLASS_AoutB );

	/* shell s2 may be inside shell s
	   Get a point from s2 to classify vs s */

	if( BU_LIST_NON_EMPTY( &s2->fu_hd ) )
	{
		fu = BU_LIST_FIRST( faceuse, &s2->fu_hd );
		lu = BU_LIST_FIRST( loopuse, &fu->lu_hd );
		eu = BU_LIST_FIRST( edgeuse, &lu->down_hd );
		VMOVE( pt_in_s2, eu->vu_p->v_p->vg_p->coord );
		class = nmg_class_pt_s(pt_in_s2, s, 0, tol);
		if( class == NMG_CLASS_AinB )
			return( NMG_CLASS_AinB );		/* shell s2 is inside shell s */
		else if( class == NMG_CLASS_AoutB )
			return( NMG_CLASS_AoutB );		/* shell s2 is not inside shell s */

		/* try other end of this EU */
		VMOVE( pt_in_s2, eu->eumate_p->vu_p->v_p->vg_p->coord );
		class = nmg_class_pt_s(pt_in_s2, s, 0, tol);
		if( class == NMG_CLASS_AinB )
			return( NMG_CLASS_AinB );		/* shell s2 is inside shell s */
		else if( class == NMG_CLASS_AoutB )
			return( NMG_CLASS_AoutB );		/* shell s2 is not inside shell s */
	}

	if( BU_LIST_NON_EMPTY( &s2->lu_hd ) )
	{
		lu = BU_LIST_FIRST( loopuse, &s2->lu_hd );
		eu = BU_LIST_FIRST( edgeuse, &lu->down_hd );
		VMOVE( pt_in_s2, eu->vu_p->v_p->vg_p->coord );
		class = nmg_class_pt_s(pt_in_s2, s, 0, tol);
		if( class == NMG_CLASS_AinB )
			return( NMG_CLASS_AinB );		/* shell s2 is inside shell s */
		else if( class == NMG_CLASS_AoutB )
			return( NMG_CLASS_AoutB );		/* shell s2 is not inside shell s */

		/* try other end of this EU */
		VMOVE( pt_in_s2, eu->eumate_p->vu_p->v_p->vg_p->coord );
		class = nmg_class_pt_s(pt_in_s2, s, 0, tol);
		if( class == NMG_CLASS_AinB )
			return( NMG_CLASS_AinB );		/* shell s2 is inside shell s */
		else if( class == NMG_CLASS_AoutB )
			return( NMG_CLASS_AoutB );		/* shell s2 is not inside shell s */
	}

	if( BU_LIST_NON_EMPTY( &s2->eu_hd ) )
	{
		eu = BU_LIST_FIRST( edgeuse, &s2->eu_hd );
		VMOVE( pt_in_s2, eu->vu_p->v_p->vg_p->coord );
		class = nmg_class_pt_s(pt_in_s2, s, 0, tol);
		if( class == NMG_CLASS_AinB )
			return( NMG_CLASS_AinB );		/* shell s2 is inside shell s */
		else if( class == NMG_CLASS_AoutB )
			return( NMG_CLASS_AoutB );		/* shell s2 is not inside shell s */

		/* try other end of this EU */
		VMOVE( pt_in_s2, eu->eumate_p->vu_p->v_p->vg_p->coord );
		class = nmg_class_pt_s(pt_in_s2, s, 0, tol);
		if( class == NMG_CLASS_AinB )
			return( NMG_CLASS_AinB );		/* shell s2 is inside shell s */
		else if( class == NMG_CLASS_AoutB )
			return( NMG_CLASS_AoutB );		/* shell s2 is not inside shell s */
	}

	if( s2->vu_p && s2->vu_p->v_p->vg_p )
	{
		VMOVE( pt_in_s2, s2->vu_p->v_p->vg_p->coord );
		class = nmg_class_pt_s(pt_in_s2, s, 0, tol);
		if( class == NMG_CLASS_AinB )
			return( NMG_CLASS_AinB );		/* shell s2 is inside shell s */
		else if( class == NMG_CLASS_AoutB )
			return( NMG_CLASS_AoutB );		/* shell s2 is not inside shell s */
	}

	/* classification returned NMG_CLASS_AonB, so need to try other points */
	nmg_vertex_tabulate( &verts, &s2->l.magic );
	for( i=0 ; i<BU_PTBL_END( &verts ) ; i++ )
	{
		struct vertex *v;

		v = (struct vertex *)BU_PTBL_GET( &verts, i );

		VMOVE( pt_in_s2, v->vg_p->coord );
		class = nmg_class_pt_s(pt_in_s2, s, 0, tol);
		if( class == NMG_CLASS_AinB )
		{
			bu_ptbl_free( &verts );
			return( NMG_CLASS_AinB );	/* shell s2 is inside shell s */
		}
		else if( class == NMG_CLASS_AoutB )
		{
			bu_ptbl_free( &verts );
			return( NMG_CLASS_AoutB );	/* shell s2 is not inside shell s */
		}
	}
	bu_ptbl_free( &verts );

	/* every point of s2 is on s !!!!!!! */
	return( NMG_CLASS_Unknown );
}
@


11.55
log
@change conf.h to a wrapped config.h
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/librt/nmg_class.c,v 11.54 2004/04/05 08:48:57 morrison Exp $ (ARL)";
@


11.54
log
@merge of ansi-6-0-branch into HEAD
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d41 5
a45 1
#include "conf.h"
@


11.53
log
@update copyright to include span through 2003
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_class.c,v 11.52 2002/08/20 17:08:03 jra Exp $ (ARL)";
d96 1
a96 2
nmg_class_status(status)
int	status;
d113 1
a113 3
nmg_pr_class_status( prefix, status )
char	*prefix;
int	status;
d131 1
a131 5
joint_hitmiss2(closest, eu, pt, code)
struct neighbor		*closest;
const struct edgeuse	*eu;
const point_t		pt;
int			code;
d208 1
a208 5
nmg_class_pt_e(closest, pt, eu, tol)
struct neighbor		*closest;
const point_t		pt;
const struct edgeuse	*eu;
const struct bn_tol	*tol;
d410 1
a410 5
nmg_class_pt_l(closest, pt, lu, tol)
struct neighbor		*closest;
const point_t		pt;
const struct loopuse	*lu;
const struct bn_tol	*tol;
d501 1
a501 3
nmg_class_lu_fu(lu, tol)
const struct loopuse	*lu;
const struct bn_tol	*tol;
d616 1
a616 5
nmg_class_pt_s(pt, s, in_or_out_only, tol)
const point_t		pt;
const struct shell	*s;
const int		in_or_out_only;
const struct bn_tol	*tol;
d736 1
a736 5
class_vu_vs_s(vu, sB, classlist, tol)
struct vertexuse	*vu;
struct shell		*sB;
long			*classlist[4];
const struct bn_tol	*tol;
d855 1
a855 5
class_eu_vs_s(eu, s, classlist, tol)
struct edgeuse	*eu;
struct shell	*s;
long		*classlist[4];
const struct bn_tol	*tol;
d1274 1
a1274 3
nmg_2lu_identical( eu1, eu2 )
const struct edgeuse	*eu1;
const struct edgeuse	*eu2;
d1387 1
a1387 4
nmg_reclassify_lu_eu( lu, classlist, newclass )
struct loopuse	*lu;
long		*classlist[4];
int		newclass;
d1484 1
a1484 4
class_shared_lu( lu, lu_ref, tol )
const struct loopuse *lu;
const struct loopuse *lu_ref;
const struct bn_tol *tol;
d1645 1
a1645 5
class_lu_vs_s(lu, s, classlist, tol)
struct loopuse		*lu;
struct shell		*s;
long			*classlist[4];
const struct bn_tol	*tol;
d2108 1
a2108 5
class_fu_vs_s(fu, s, classlist, tol)
struct faceuse		*fu;
struct shell		*s;
long			*classlist[4];
const struct bn_tol	*tol;
d2141 1
a2141 5
nmg_class_shells(sA, sB, classlist, tol)
struct shell	*sA;
struct shell	*sB;
long		*classlist[4];
const struct bn_tol	*tol;
d2268 1
a2268 4
nmg_get_interior_pt( pt, lu, tol )
point_t pt;
const struct loopuse *lu;
const struct bn_tol *tol;
d2378 1
a2378 3
nmg_classify_lu_lu( lu1 , lu2 , tol )
const struct loopuse *lu1,*lu2;
const struct bn_tol *tol;
d2715 1
a2715 4
nmg_classify_s_vs_s( s2, s, tol )
struct shell *s;
struct shell *s2;
const struct bn_tol *tol;
@


11.52
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d34 1
a34 1
 *	This software is Copyright (C) 1993 by the United States Army
d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_class.c,v 11.50 2002/05/12 03:49:42 jra Exp $ (ARL)";
@


11.52.4.1
log
@sync to HEAD...
@
text
@d34 1
a34 1
 *	This software is Copyright (C) 1993-2004 by the United States Army
d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/nmg_class.c,v 11.53 2004/02/02 17:39:22 morrison Exp $ (ARL)";
@


11.52.10.1
log
@merge from HEAD
@
text
@d34 1
a34 1
 *	This software is Copyright (C) 1993-2004 by the United States Army
d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_class.c,v 11.53 2004/02/02 17:39:22 morrison Exp $ (ARL)";
@


11.52.10.2
log
@merge from head
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_class.c,v 11.52.10.1 2004/02/12 18:37:43 erikg Exp $ (ARL)";
@


11.52.2.1
log
@Initial ANSIfication
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_class.c,v 11.52 2002/08/20 17:08:03 jra Exp $ (ARL)";
d96 2
a97 1
nmg_class_status(int status)
d114 3
a116 1
nmg_pr_class_status(char *prefix, int status)
d134 5
a138 1
joint_hitmiss2(struct neighbor *closest, const struct edgeuse *eu, const fastf_t *pt, int code)
d215 5
a219 1
nmg_class_pt_e(struct neighbor *closest, const fastf_t *pt, const struct edgeuse *eu, const struct bn_tol *tol)
d421 5
a425 1
nmg_class_pt_l(struct neighbor *closest, const fastf_t *pt, const struct loopuse *lu, const struct bn_tol *tol)
d516 3
a518 1
nmg_class_lu_fu(const struct loopuse *lu, const struct bn_tol *tol)
d633 5
a637 1
nmg_class_pt_s(const fastf_t *pt, const struct shell *s, const int in_or_out_only, const struct bn_tol *tol)
d757 5
a761 1
class_vu_vs_s(struct vertexuse *vu, struct shell *sB, long int **classlist, const struct bn_tol *tol)
d880 5
a884 1
class_eu_vs_s(struct edgeuse *eu, struct shell *s, long int **classlist, const struct bn_tol *tol)
d1303 3
a1305 1
nmg_2lu_identical(const struct edgeuse *eu1, const struct edgeuse *eu2)
d1418 4
a1421 1
nmg_reclassify_lu_eu(struct loopuse *lu, long int **classlist, int newclass)
d1518 4
a1521 1
class_shared_lu(const struct loopuse *lu, const struct loopuse *lu_ref, const struct bn_tol *tol)
d1682 5
a1686 1
class_lu_vs_s(struct loopuse *lu, struct shell *s, long int **classlist, const struct bn_tol *tol)
d2149 5
a2153 1
class_fu_vs_s(struct faceuse *fu, struct shell *s, long int **classlist, const struct bn_tol *tol)
d2186 5
a2190 1
nmg_class_shells(struct shell *sA, struct shell *sB, long int **classlist, const struct bn_tol *tol)
d2317 4
a2320 1
nmg_get_interior_pt(fastf_t *pt, const struct loopuse *lu, const struct bn_tol *tol)
d2430 3
a2432 1
nmg_classify_lu_lu(const struct loopuse *lu1, const struct loopuse *lu2, const struct bn_tol *tol)
d2769 4
a2772 1
nmg_classify_s_vs_s(struct shell *s2, struct shell *s, const struct bn_tol *tol)
@


11.52.2.2
log
@sync branch with HEAD
@
text
@d34 1
a34 1
 *	This software is Copyright (C) 1993-2004 by the United States Army
d38 1
a38 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
@


11.51
log
@Converted from K&R to ANSI C - RFH
@
text
@d96 2
a97 1
nmg_class_status(int status)
d114 3
a116 1
nmg_pr_class_status(char *prefix, int status)
d134 5
a138 1
joint_hitmiss2(struct neighbor *closest, const struct edgeuse *eu, const fastf_t *pt, int code)
d215 5
a219 1
nmg_class_pt_e(struct neighbor *closest, const fastf_t *pt, const struct edgeuse *eu, const struct bn_tol *tol)
d421 5
a425 1
nmg_class_pt_l(struct neighbor *closest, const fastf_t *pt, const struct loopuse *lu, const struct bn_tol *tol)
d516 3
a518 1
nmg_class_lu_fu(const struct loopuse *lu, const struct bn_tol *tol)
d633 5
a637 1
nmg_class_pt_s(const fastf_t *pt, const struct shell *s, const int in_or_out_only, const struct bn_tol *tol)
d757 5
a761 1
class_vu_vs_s(struct vertexuse *vu, struct shell *sB, long int **classlist, const struct bn_tol *tol)
d880 5
a884 1
class_eu_vs_s(struct edgeuse *eu, struct shell *s, long int **classlist, const struct bn_tol *tol)
d1303 3
a1305 1
nmg_2lu_identical(const struct edgeuse *eu1, const struct edgeuse *eu2)
d1418 4
a1421 1
nmg_reclassify_lu_eu(struct loopuse *lu, long int **classlist, int newclass)
d1518 4
a1521 1
class_shared_lu(const struct loopuse *lu, const struct loopuse *lu_ref, const struct bn_tol *tol)
d1682 5
a1686 1
class_lu_vs_s(struct loopuse *lu, struct shell *s, long int **classlist, const struct bn_tol *tol)
d2149 5
a2153 1
class_fu_vs_s(struct faceuse *fu, struct shell *s, long int **classlist, const struct bn_tol *tol)
d2186 5
a2190 1
nmg_class_shells(struct shell *sA, struct shell *sB, long int **classlist, const struct bn_tol *tol)
d2317 4
a2320 1
nmg_get_interior_pt(fastf_t *pt, const struct loopuse *lu, const struct bn_tol *tol)
d2430 3
a2432 1
nmg_classify_lu_lu(const struct loopuse *lu1, const struct loopuse *lu2, const struct bn_tol *tol)
d2769 4
a2772 1
nmg_classify_s_vs_s(struct shell *s2, struct shell *s, const struct bn_tol *tol)
@


11.50
log
@Turned off some old excessive debug logging
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_class.c,v 11.49 2001/05/17 20:05:25 morrison Exp $ (ARL)";
d96 1
a96 2
nmg_class_status(status)
int	status;
d113 1
a113 3
nmg_pr_class_status( prefix, status )
char	*prefix;
int	status;
d131 1
a131 5
joint_hitmiss2(closest, eu, pt, code)
struct neighbor		*closest;
const struct edgeuse	*eu;
const point_t		pt;
int			code;
d208 1
a208 5
nmg_class_pt_e(closest, pt, eu, tol)
struct neighbor		*closest;
const point_t		pt;
const struct edgeuse	*eu;
const struct bn_tol	*tol;
d410 1
a410 5
nmg_class_pt_l(closest, pt, lu, tol)
struct neighbor		*closest;
const point_t		pt;
const struct loopuse	*lu;
const struct bn_tol	*tol;
d501 1
a501 3
nmg_class_lu_fu(lu, tol)
const struct loopuse	*lu;
const struct bn_tol	*tol;
d616 1
a616 5
nmg_class_pt_s(pt, s, in_or_out_only, tol)
const point_t		pt;
const struct shell	*s;
const int		in_or_out_only;
const struct bn_tol	*tol;
d736 1
a736 5
class_vu_vs_s(vu, sB, classlist, tol)
struct vertexuse	*vu;
struct shell		*sB;
long			*classlist[4];
const struct bn_tol	*tol;
d855 1
a855 5
class_eu_vs_s(eu, s, classlist, tol)
struct edgeuse	*eu;
struct shell	*s;
long		*classlist[4];
const struct bn_tol	*tol;
d1274 1
a1274 3
nmg_2lu_identical( eu1, eu2 )
const struct edgeuse	*eu1;
const struct edgeuse	*eu2;
d1387 1
a1387 4
nmg_reclassify_lu_eu( lu, classlist, newclass )
struct loopuse	*lu;
long		*classlist[4];
int		newclass;
d1484 1
a1484 4
class_shared_lu( lu, lu_ref, tol )
const struct loopuse *lu;
const struct loopuse *lu_ref;
const struct bn_tol *tol;
d1645 1
a1645 5
class_lu_vs_s(lu, s, classlist, tol)
struct loopuse		*lu;
struct shell		*s;
long			*classlist[4];
const struct bn_tol	*tol;
d2108 1
a2108 5
class_fu_vs_s(fu, s, classlist, tol)
struct faceuse		*fu;
struct shell		*s;
long			*classlist[4];
const struct bn_tol	*tol;
d2141 1
a2141 5
nmg_class_shells(sA, sB, classlist, tol)
struct shell	*sA;
struct shell	*sB;
long		*classlist[4];
const struct bn_tol	*tol;
d2268 1
a2268 4
nmg_get_interior_pt( pt, lu, tol )
point_t pt;
const struct loopuse *lu;
const struct bn_tol *tol;
d2378 1
a2378 3
nmg_classify_lu_lu( lu1 , lu2 , tol )
const struct loopuse *lu1,*lu2;
const struct bn_tol *tol;
d2715 1
a2715 4
nmg_classify_s_vs_s( s2, s, tol )
struct shell *s;
struct shell *s2;
const struct bn_tol *tol;
@


11.49
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_class.c,v 11.48 2001/04/05 19:35:34 morrison Exp $ (ARL)";
d1788 1
a1788 1
		bu_log("Loopuse edges in:%d on:%d out:%d, turning on DEBUG_CLASSIFY\n", in, on, outside);
a1821 1
		rt_g.NMG_debug |= DEBUG_CLASSIFY;
@


11.48
log
@updated SIGNED to signed
updated CONST to const
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_class.c,v 11.47 2000/08/31 04:07:14 mike Exp $ (ARL)";
d944 1
a944 1
	    	if( rt_g.debug || rt_g.NMG_debug )  {
@


11.47
log
@
lint
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_class.c,v 11.46 2000/08/24 04:29:16 mike Exp $ (ARL)";
d64 2
a65 2
		CONST struct vertexuse *vu;
		CONST struct edgeuse *eu;
d73 1
a73 1
			CONST struct edgeuse *eu, CONST point_t pt,
d76 2
a77 2
			CONST point_t pt, CONST struct edgeuse *eu,
			CONST struct bn_tol *tol) );
d79 2
a80 2
			CONST point_t pt, CONST struct loopuse *lu,
			CONST struct bn_tol *tol) );
d82 1
a82 1
			long *classlist[4], CONST struct bn_tol	*tol) );
d84 1
a84 1
			long *classlist[4], CONST struct bn_tol	*tol) );
d86 1
a86 1
			long *classlist[4], CONST struct bn_tol	*tol) );
d88 1
a88 1
			long *classlist[4], CONST struct bn_tol	*tol) );
d95 1
a95 1
CONST char *
d136 2
a137 2
CONST struct edgeuse	*eu;
CONST point_t		pt;
d140 1
a140 1
	CONST struct edgeuse *eu_rinf;
d217 3
a219 3
CONST point_t		pt;
CONST struct edgeuse	*eu;
CONST struct bn_tol	*tol;
d223 2
a224 2
	CONST fastf_t	*eupt;
	CONST fastf_t	*matept;
d423 3
a425 3
CONST point_t		pt;
CONST struct loopuse	*lu;
CONST struct bn_tol	*tol;
d517 2
a518 2
CONST struct loopuse	*lu;
CONST struct bn_tol	*tol;
d520 1
a520 1
	CONST struct faceuse	*fu;
d522 1
a522 1
	CONST struct vertex_g	*vg;
d594 1
a594 1
static CONST point_t nmg_good_dirs[10] = {
d634 4
a637 4
CONST point_t		pt;
CONST struct shell	*s;
CONST int		in_or_out_only;
CONST struct bn_tol	*tol;
d639 1
a639 1
	CONST struct faceuse	*fu;
d761 1
a761 1
CONST struct bn_tol	*tol;
d884 1
a884 1
CONST struct bn_tol	*tol;
d1304 2
a1305 2
CONST struct edgeuse	*eu1;
CONST struct edgeuse	*eu2;
d1307 5
a1311 5
	CONST struct loopuse	*lu1;
	CONST struct loopuse	*lu2;
	CONST struct edgeuse	*eu1_first;
	CONST struct faceuse	*fu1;
	CONST struct faceuse	*fu2;
d1519 3
a1521 3
CONST struct loopuse *lu;
CONST struct loopuse *lu_ref;
CONST struct bn_tol *tol;
d1686 1
a1686 1
CONST struct bn_tol	*tol;
d2154 1
a2154 1
CONST struct bn_tol	*tol;
d2191 1
a2191 1
CONST struct bn_tol	*tol;
d2432 2
a2433 2
CONST struct loopuse *lu1,*lu2;
CONST struct bn_tol *tol;
@


11.46
log
@
lint
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_class.c,v 11.45 2000/08/21 02:02:31 butler Exp $ (ARL)";
d641 1
a641 1
	long		*faces_seen;
d766 1
a766 1
	int	status;
d887 1
a887 1
	int	status;
d2027 1
a2027 1
			int test_class;
d2382 3
@


11.45
log
@Massive compilation warnings eliminated
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_class.c,v 11.44 2000/07/10 23:01:38 mike Exp $ (ARL)";
d596 1
a596 1
	3, 2, 1,	/* Normally the first dir */
d598 1
a598 1
	1, 0, 0,	/* Make this first dir to wring out ray-tracer XXX */
d600 9
a608 9
	1, 0, 0,
	0, 1, 0,
	0, 0, 1,
	1, 1, 1,
	-3,-2,-1,
	-1,0, 0,
	0,-1, 0,
	0, 0,-1,
	-1,-1,-1
@


11.44
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_class.c,v 11.43 2000/03/29 02:54:04 mike Exp $ (ARL)";
d50 1
d2266 3
a2268 4
nmg_classify_pt_loop( pt , lu , tol )
CONST point_t pt;
CONST struct loopuse *lu;
CONST struct bn_tol *tol;
d2320 2
a2321 2
CONST struct loopuse *lu;
CONST struct bn_tol *tol;
d2360 1
a2360 1
	if( nmg_class_pt_lu_except( test_pt, lu, (struct edge *)NULL, tol ) == NMG_CLASS_AinB )
d2561 1
a2561 1
					class = nmg_class_pt_lu_except( vg->coord, lu2, (struct edgeuse *)NULL, tol);
d2622 1
a2622 1
				class = nmg_class_pt_lu_except( vg->coord, lu2, (struct edgeuse *)NULL, tol);
d2664 1
a2664 1
				class = nmg_class_pt_lu_except( mid_pt, lu2, (struct edgeuse *)NULL, tol);
d2730 2
a2731 1
		class = nmg_class_pt_lu_except( vg->coord, lu2, (struct edgeuse *)NULL, tol );
d2770 1
a2770 1
struct bn_tol *tol;
@


11.43
log
@
const and extern for nmg_extrude.c
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_class.c,v 11.42 1999/12/30 15:36:02 jra Exp $ (ARL)";
@


11.42
log
@Eliminated some unused variables
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_class.c,v 11.41 1999/11/24 21:44:30 mike Exp $ (ARL)";
a49 2

NMG_EXTERN( struct vertexuse *nmg_find_vertex_in_lu, (CONST struct vertex *vp, CONST struct loopuse *lu ) );
@


11.41
log
@
Removed includes of compat header files rtstring.h and rtlist.h
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_class.c,v 11.40 1999/06/03 01:43:36 mike Exp $ (ARL)";
a639 3
	int		hitcount = 0;
	int		stat;
	point_t 	plane_pt;
a966 1
		int class_topo;
a1693 2
	struct faceuse *fu_eu;
	vect_t norm1, norm2;
a1945 2
	fu_eu = nmg_find_fu_of_eu( eu );
	NMG_GET_FU_NORMAL( norm1, fu_eu );
a2435 1
	point_t pt;
a2438 1
	int ret;
@


11.40
log
@
sed4
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_class.c,v 11.39 1998/03/09 15:18:18 jra Exp $ (ARL)";
a47 1
#include "rtlist.h"
@


11.39
log
@Added another check to class_eu_vs_s() for another eu in shell 's'.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 11.38 1997/03/21 14:22:21 jra Exp jra $ (ARL)";
d387 1
a387 1
		bits = (long *)rt_calloc( nmg_find_model(&fu->l.magic)->maxindex, sizeof(long), "bits[]");
d398 1
a398 1
		rt_free( (char *)bits, "bits[]");
d671 1
a671 1
		faces_seen = (long *)rt_calloc( m->maxindex, sizeof(long), "nmg_class_pt_s faces_seen[]" );
d747 1
a747 1
		rt_free( (char *)faces_seen, "nmg_class_pt_s faces_seen[]" );
d1804 1
a1804 1
			b = (long *)rt_calloc(m->maxindex, sizeof(long), "nmg_pl_lu flag[]");
d1828 1
a1828 1
			rt_free( (char *)b, "nmg_pl_lu flag[]" );
d2798 1
a2798 1
	if( RT_LIST_NON_EMPTY( &s2->fu_hd ) )
d2800 3
a2802 3
		fu = RT_LIST_FIRST( faceuse, &s2->fu_hd );
		lu = RT_LIST_FIRST( loopuse, &fu->lu_hd );
		eu = RT_LIST_FIRST( edgeuse, &lu->down_hd );
d2819 1
a2819 1
	if( RT_LIST_NON_EMPTY( &s2->lu_hd ) )
d2821 2
a2822 2
		lu = RT_LIST_FIRST( loopuse, &s2->lu_hd );
		eu = RT_LIST_FIRST( edgeuse, &lu->down_hd );
d2839 1
a2839 1
	if( RT_LIST_NON_EMPTY( &s2->eu_hd ) )
d2841 1
a2841 1
		eu = RT_LIST_FIRST( edgeuse, &s2->eu_hd );
@


11.38
log
@Needed declaration of nmg_find_vertex_in_lu().
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 11.37 1996/10/21 02:50:49 jra Exp jra $ (ARL)";
d986 10
@


11.37
log
@Freed some memory on nmg_classify_s_vs_s().
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 11.36 1996/10/11 17:57:30 jra Exp jra $ (ARL)";
d51 2
@


11.36
log
@Added nmg_classify_s_vs_s().
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 11.35 1996/09/27 08:27:30 mike Exp jra $ (ARL)";
d2877 1
@


11.35
log
@Converted to using proper routine names for LIBBU and LIBBN routines.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 11.34 1996/09/14 03:42:36 butler Exp mike $ (ARL)";
d2751 129
@


11.34
log
@fixed parameter bug
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 11.33 1996/07/12 12:17:41 jra Exp butler $ (ARL)";
d77 1
a77 1
			CONST struct rt_tol *tol) );
d80 1
a80 1
			CONST struct rt_tol *tol) );
d82 1
a82 1
			long *classlist[4], CONST struct rt_tol	*tol) );
d84 1
a84 1
			long *classlist[4], CONST struct rt_tol	*tol) );
d86 1
a86 1
			long *classlist[4], CONST struct rt_tol	*tol) );
d88 1
a88 1
			long *classlist[4], CONST struct rt_tol	*tol) );
d118 1
a118 1
	rt_log("%s has classification status %s\n",
d145 1
a145 1
		rt_log("joint_hitmiss2\n");
d175 1
a175 1
			closest->p.vu = RT_LIST_PNEXT_CIRC(edgeuse,eu)->vu_p;
d178 1
a178 1
		if (rt_g.NMG_debug & DEBUG_CLASSIFY) rt_log("\t\t%s\n", nmg_class_name(closest->class) );
d184 1
a184 1
	rt_log("joint_hitmiss2: NO CODE HERE, assuming miss\n");
d188 2
a189 2
		rt_log(" eu_rinf=x%x, eu->eumate_p=x%x, eu=x%x\n", eu_rinf, eu->eumate_p, eu);
		rt_log(" eu lu orient=%s, eu_rinf lu orient=%s\n",
d219 1
a219 1
CONST struct rt_tol	*tol;
d234 1
a234 1
	RT_CK_TOL(tol);
d251 1
a251 1
	code = rt_dist_pt3_lseg3( &dist, pca, eu->vu_p->v_p->vg_p->coord,
d256 1
a256 1
		rt_log("          \tcode=%d, dist: %g\n", code, dist);
d262 1
a262 1
 			rt_log("\t\tskipping, earlier eu is closer (%g)\n", closest->dist);
d278 1
a278 1
					rt_log("\t\tSkipping, earlier eu from same lu at same dist, is OUT or ON.\n");
d282 1
a282 1
				rt_log("\t\tEarlier eu from same lu at same dist, is IN, continue processing.\n");
d299 1
a299 1
					rt_log("\t\tSkipping, earlier eu from other another lu at same dist, is IN or ON\n");
d303 1
a303 1
				rt_log("\t\tEarlier eu from other lu at same dist, is OUT, continue processing.\n");
d309 1
a309 1
		rt_log("\t\tCLOSER dist=%g (closest=%g), tol=%g\n",
d315 1
a315 1
		rt_log("Trying to classify a pt (%g, %g, %g)\n\tvs a wire edge? (%g, %g, %g -> %g, %g, %g)\n",
d327 1
a327 1
    			rt_log("\t\tThe point is ON the edge, calling joint_hitmiss2()\n");
d333 1
a333 1
			rt_log("\t\tThe point is not on the edge\n");
d355 1
a355 1
	    		rt_log("\t\tpt lies on line of edge, outside verts. Skipping this edge\n");
d364 1
a364 1
	    		rt_log("\t\tpt is left of edge, INSIDE loop, dot=%g\n", dot);
d370 1
a370 1
	    		rt_log("\t\tpt is right of edge, OUTSIDE loop\n");
d397 1
a397 1
		rt_log("wrote %s\n", buf);
d425 1
a425 1
CONST struct rt_tol	*tol;
d454 1
a454 1
			rt_log("\tPoint is outside loop RPP\n");
d457 2
a458 2
	if (RT_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_EDGEUSE_MAGIC) {
		for (RT_LIST_FOR(eu, edgeuse, &lu->down_hd)) {
d463 1
a463 1
	} else if (RT_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC) {
d465 1
a465 1
		vu = RT_LIST_FIRST(vertexuse, &lu->down_hd);
d478 1
a478 1
				rt_log("\t\t closer to loop pt (%g, %g, %g)\n",
d488 1
a488 1
		rt_log("nmg_class_pt_l\treturning, closest=%g %s\n",
d518 1
a518 1
CONST struct rt_tol	*tol;
d530 1
a530 1
	RT_CK_TOL(tol);
d538 1
a538 1
		rt_log("nmg_class_lu_fu(lu=x%x) START\n", lu);
d541 2
a542 2
	if( RT_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC )  {
		vu = RT_LIST_FIRST(vertexuse, &lu->down_hd);
d545 1
a545 1
		eu = RT_LIST_FIRST(edgeuse, &lu->down_hd);
d563 1
a563 1
		rt_log("nmg_class_lu_fu() ERROR, point (%g,%g,%g) not on face, dist=%g\n",
d576 1
a576 1
			eu = RT_LIST_PNEXT_CIRC(edgeuse, &eu->l);
d586 1
a586 1
		rt_log("nmg_class_lu_fu(lu=x%x) END, ret=%s\n",
d637 1
a637 1
CONST struct rt_tol	*tol;
d653 1
a653 1
	RT_CK_TOL(tol);
d656 1
a656 1
		rt_log("nmg_class_pt_s:\tpt=(%g, %g, %g), s=x%x\n",
d661 1
a661 1
			rt_log("	OUT, point not in RPP\n");
d674 1
a674 1
		for( RT_LIST_FOR(fu, faceuse, &s->fu_hd) )  {
d732 1
a732 1
		rt_log("\tPt=(%g, %g, %g) dir=(%g, %g, %g), reg_diam=%g\n",
d748 1
a748 1
		rt_log("nmg_class_pt_s: returning %s, s=x%x, try=%d\n",
d764 1
a764 1
CONST struct rt_tol	*tol;
d774 1
a774 1
	RT_CK_TOL(tol);
d779 1
a779 1
		rt_log("class_vu_vs_s(vu=x%x, v=x%x) pt=(%g,%g,%g)\n", vu, vu->v_p, V3ARGS(pt) );
d803 1
a803 1
	for(RT_LIST_FOR(vup, vertexuse, &vu->v_p->vu_hd)) {
d832 1
a832 1
		rt_log("\tCan't classify vertex via topology\n");
d847 1
a847 1
			rt_log("vu=x%x, v=x%x, sv=x%x, pt=(%g,%g,%g)\n",
d866 1
a866 1
		rt_log("class=%s\n", nmg_class_name(class) );
d873 1
a873 1
		rt_log("class_vu_vs_s(vu=x%x) return %s because %s\n",
d887 1
a887 1
CONST struct rt_tol	*tol;
d899 1
a899 1
		rt_log( "class_eu_vs_s( eu=x%x (e_p=x%x, lu=x%x), s=x%x )\n", eu, eu->e_p, eu->up.lu_p, s );
d905 1
a905 1
	RT_CK_TOL(tol);
d949 1
a949 1
	    		rt_log("Edge not cut, doing it over\n");
d962 1
a962 1
		rt_log("wrote %s\n", buf);
d1025 1
a1025 1
				rt_log( "\tclass_eu_vs_s: attempting topological classification\n" );
d1031 1
a1031 1
			eu_loop = RT_LIST_PNEXT_CIRC( edgeuse, &eu->l );
d1051 1
a1051 1
				eu_loop = RT_LIST_PNEXT_CIRC( edgeuse, &eu_loop->l );
d1057 1
a1057 1
				rt_log( "loop crosses shell boundary!!!\n" );
d1071 1
a1071 1
					rt_log( "\tclass_eu_vs_s: found other eu (x%x) in loop on shell\n", eu_on );
d1098 1
a1098 1
					rt_log( "\tclass_eu_vs_s: eu_rad=x%x, eu_rad_too=x%x\n",
d1100 1
a1100 1
					rt_log( "\t\tfu_rad=x%x, fu_rad_too=x%x, fu_eu=x%x, fu_eu->fumate_p=x%x\n",
d1102 1
a1102 1
					rt_log( "\t\ts=x%x, fu_rad->s_p=x%x\n", s, fu_rad->s_p );
d1123 1
a1123 1
						rt_log( "\tclass_eu_vs_s eu_rad=x%x, eu_rad_too=x%x, dot=%f, dot_too=%f\n",
d1146 1
a1146 1
						rt_log( "FU (x%x) has bad orientation (%s)\n", fu_rad, nmg_orientation( fu_rad->orientation ) );
d1152 1
a1152 1
						rt_log( "\tClassifiying EU using on eu (x%x) from fu (x%x)\n", eu_on, nmg_find_fu_of_eu( eu_on) );
d1204 1
a1204 1
			if(!eup) rt_log("Unable to find it\n");
d1212 1
a1212 1
				rt_log("wrote shell1.pl\n");
d1217 1
a1217 1
				rt_log("wrote shell2.pl\n");
d1224 1
a1224 1
			rt_log("class_eu_vs_s:  classifier found edge midpoint ON, edge topology should have been shared\n\n################ re-run face/face isect ############\n\n");
d1230 1
a1230 1
			for( RT_LIST_FOR( fu2, faceuse, &s->fu_hd ) )  {
d1236 1
a1236 1
			if(!eup) rt_log("Unable to find it\n");
d1241 1
a1241 1
			rt_log("class=%s\n", nmg_class_name(class) );
d1267 1
a1267 1
	rt_log("eu's vert is %s, mate's vert is %s\n",
d1274 1
a1274 1
		rt_log("class_eu_vs_s(eu=x%x) return %s because %s\n",
d1335 2
a1336 2
		eu1 = RT_LIST_PNEXT_CIRC(edgeuse, &eu1->l);
		eu2 = RT_LIST_PNEXT_CIRC(edgeuse, &eu2->l);
d1351 1
a1351 1
		rt_log("nmg_2lu_identical() loops lu1=x%x lu2=x%x are shared, face geometry is not? fg1=x%x, fg2=x%x\n",
d1353 1
a1353 1
		rt_log("---- fu1, f=x%x, flip=%d\n", fu1->f_p, fu1->f_p->flip);
d1357 1
a1357 1
		rt_log("---- fu2, f=x%x, flip=%d\n", fu2->f_p, fu2->f_p->flip);
d1377 1
a1377 1
		rt_log("---- fu1, f=x%x, flip=%d\n", fu1->f_p, fu1->f_p->flip);
d1379 1
a1379 1
		rt_log("---- fu2, f=x%x, flip=%d\n", fu2->f_p, fu2->f_p->flip);
d1394 1
a1394 1
		rt_log("nmg_2lu_identical(eu1=x%x, eu2=x%x) ret=%d\n",
d1424 1
a1424 1
		rt_log("nmg_reclassify_lu_eu(lu=x%x, classlist=x%x, newclass=%s)\n",
d1431 2
a1432 2
	if (RT_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC)  {
		vu = RT_LIST_FIRST(vertexuse, &lu->down_hd);
d1449 1
a1449 1
	for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )  {
d1515 1
a1515 1
CONST struct rt_tol *tol;
d1526 1
a1526 1
		rt_log( "class_shared_lu: classifying lu x%x w.r.t. lu_ref x%x\n",
d1531 1
a1531 1
	RT_CK_TOL( tol );
d1533 2
a1534 2
	eu = RT_LIST_FIRST( edgeuse, &lu->down_hd );
	for( RT_LIST_FOR( eu_ref, edgeuse, &lu_ref->down_hd ) )
d1542 1
a1542 1
		rt_log( "class_shared_lu() couldn't find a shared EU between LU's x%x and x%x\n",
d1549 1
a1549 1
		rt_log( "class_shared_lu() couldn't get a left vector for EU x%x\n", eu );
d1554 1
a1554 1
		rt_log( "class_shared_lu() couldn't get a left vector for EU x%x\n", eu_ref );
d1562 2
a1563 2
			rt_log( "eu x%x goes form v x%x to v x%x\n", eu, eu->vu_p->v_p, eu->eumate_p->vu_p->v_p );
			rt_log( "eu_ref x%x goes form v x%x to v x%x\n", eu_ref, eu_ref->vu_p->v_p, eu_ref->eumate_p->vu_p->v_p );
d1570 1
a1570 1
				rt_log( "class_shared_lu returning NMG_CLASS_AonBshared\n" );
d1576 1
a1576 1
				rt_log( "class_shared_lu returning NMG_CLASS_AonBanti\n" );
d1588 1
a1588 1
	for( RT_LIST_FOR( eu_start, edgeuse, &lu->down_hd ) )
d1665 1
a1665 1
		rt_log( "class_shared_lu returning NMG_CLASS_Unknown at end\n" );
d1680 1
a1680 1
CONST struct rt_tol	*tol;
d1695 1
a1695 1
		rt_log( "class_lu_vs_s( lu=x%x, s=x%x )\n", lu, s );
d1699 1
a1699 1
	RT_CK_TOL(tol);
d1703 1
a1703 1
		rt_log( "class_lu_vs_s() is trying to classify lu x%x vs its own shell (x%x)\n",
d1736 1
a1736 1
	magic1 = RT_LIST_FIRST_MAGIC( &lu->down_hd );
d1740 1
a1740 1
		vu = RT_LIST_PNEXT( vertexuse, &lu->down_hd );
d1765 1
a1765 1
	for (RT_LIST_FOR(eu, edgeuse, &lu->down_hd)) {
d1780 1
a1780 1
		rt_log("class_lu_vs_s: Loopuse edges in:%d on:%d out:%d\n", in, on, outside);
d1784 1
a1784 1
		rt_log("Loopuse edges in:%d on:%d out:%d, turning on DEBUG_CLASSIFY\n", in, on, outside);
d1794 1
a1794 1
			for(RT_LIST_FOR(eu, edgeuse, &lu->down_hd)) {
d1812 1
a1812 1
				rt_log("wrote %s\n", buf);
d1841 1
a1841 1
		rt_log("\tAll edgeuses of loop are ON\n");
d1871 1
a1871 1
	eu = RT_LIST_FIRST(edgeuse, &lu->down_hd);
d1874 1
a1874 1
	    eu != RT_LIST_FIRST(edgeuse, &lu->down_hd);
d1892 1
a1892 1
			RT_LIST_FIRST(edgeuse, &lu->down_hd) );
d1904 1
a1904 1
					rt_log("Loop is on-antishared (lu orient is OT_OPPOSITE)\n");
d1910 1
a1910 1
					rt_log("Loop is on-shared\n");
d1922 1
a1922 1
					rt_log("Loop is on-shared (lu orient is OT_OPPOSITE)\n");
d1928 1
a1928 1
					rt_log("Loop is on-antishared\n");
d1940 1
a1940 1
	eu = RT_LIST_FIRST(edgeuse, &lu->down_hd);
d1945 1
a1945 1
	    eu != RT_LIST_FIRST(edgeuse, &lu->down_hd) ;
d1968 1
a1968 1
			rt_log( "\tfound radial lu (x%x), check for match\n", q_lu );
d1971 1
a1971 1
		eu1 = RT_LIST_FIRST(edgeuse, &lu->down_hd);
d1975 1
a1975 1
			eu2 = RT_LIST_PNEXT_CIRC( edgeuse, &eu->l );
d1977 1
a1977 1
			eu2 = RT_LIST_PPREV_CIRC( edgeuse, &eu->l );
d1982 1
a1982 1
				rt_log( "\t\tcompare vertex x%x to vertex x%x\n", eu1->vu_p->v_p, eu2->vu_p->v_p );
d1986 1
a1986 1
					rt_log( "\t\t\tnot a match\n" );
d1990 3
a1992 3
			eu1 = RT_LIST_PNEXT_CIRC( edgeuse, &eu1->l );
			eu2 = RT_LIST_PNEXT_CIRC( edgeuse, &eu2->l );
		} while( eu1 != RT_LIST_FIRST(edgeuse, &lu->down_hd));
d1998 2
a1999 2
				rt_log( "\tChecking for match in opposite direction\n" );
			eu1 = RT_LIST_FIRST(edgeuse, &lu->down_hd);
d2003 1
a2003 1
				eu2 = RT_LIST_PNEXT_CIRC( edgeuse, &eu->l );
d2005 1
a2005 1
				eu2 = RT_LIST_PPREV_CIRC( edgeuse, &eu->l );
d2010 1
a2010 1
					rt_log( "\t\tcompare vertex x%x to vertex x%x\n", eu1->vu_p->v_p, eu2->vu_p->v_p );
d2014 1
a2014 1
						rt_log( "\t\t\tnot a match\n" );
d2018 3
a2020 3
				eu1 = RT_LIST_PNEXT_CIRC( edgeuse, &eu1->l );
				eu2 = RT_LIST_PPREV_CIRC( edgeuse, &eu2->l );
			} while( eu1 != RT_LIST_FIRST(edgeuse, &lu->down_hd));
d2028 1
a2028 1
				rt_log( "\tFound a matching LU's x%x and x%x\n", lu, q_lu );
d2036 1
a2036 1
				rt_log( "class_lu_vs_s: FU x%x for lu x%x matching lu x%x has bad orientation (%s)\n",
d2042 1
a2042 1
				rt_log( "\tclass_shared_lu says %s\n", nmg_class_name( test_class ) );
d2050 1
a2050 1
				rt_log( "\tclass set to %s\n",  nmg_class_name( class ) );
d2061 1
a2061 1
			rt_log( "Final class = %s\n", nmg_class_name( class ) );
d2083 1
a2083 1
		rt_log( "Checking radial faces:\n" );
d2087 1
a2087 1
	for (RT_LIST_FOR(eu, edgeuse, &lu->down_hd)) {
d2099 1
a2099 1
						rt_log("Loop is INSIDE of fu x%x\n", p->up.lu_p->up.fu_p);
d2108 1
a2108 1
						rt_log("Loop is OUTSIDEof fu x%x\n", p->up.lu_p->up.fu_p);
d2123 1
a2123 1
		rt_log("Loop is OUTSIDE 'cause it isn't anything else\n");
d2135 1
a2135 1
		rt_log("class_lu_vs_s(lu=x%x) return %s (%s) because %s\n",
d2152 1
a2152 1
CONST struct rt_tol	*tol;
d2165 1
a2165 1
	for (RT_LIST_FOR(lu, loopuse, &fu->lu_hd))
d2169 1
a2169 1
		rt_log("class_fu_vs_s() END\n");
d2189 1
a2189 1
CONST struct rt_tol	*tol;
d2197 1
a2197 1
	RT_CK_TOL(tol);
d2200 2
a2201 2
	    RT_LIST_NON_EMPTY(&sA->fu_hd))
		rt_log("nmg_class_shells - doing faces\n");
d2203 2
a2204 2
	fu = RT_LIST_FIRST(faceuse, &sA->fu_hd);
	while (RT_LIST_NOT_HEAD(fu, &sA->fu_hd)) {
d2208 2
a2209 2
		if (RT_LIST_PNEXT(faceuse, fu) == fu->fumate_p)
			fu = RT_LIST_PNEXT_PNEXT(faceuse, fu);
d2211 1
a2211 1
			fu = RT_LIST_PNEXT(faceuse, fu);
d2215 2
a2216 2
	    RT_LIST_NON_EMPTY(&sA->lu_hd))
		rt_log("nmg_class_shells - doing loops\n");
d2218 2
a2219 2
	lu = RT_LIST_FIRST(loopuse, &sA->lu_hd);
	while (RT_LIST_NOT_HEAD(lu, &sA->lu_hd)) {
d2223 2
a2224 2
		if (RT_LIST_PNEXT(loopuse, lu) == lu->lumate_p)
			lu = RT_LIST_PNEXT_PNEXT(loopuse, lu);
d2226 1
a2226 1
			lu = RT_LIST_PNEXT(loopuse, lu);
d2230 2
a2231 2
	    RT_LIST_NON_EMPTY(&sA->eu_hd))
		rt_log("nmg_class_shells - doing edges\n");
d2233 2
a2234 2
	eu = RT_LIST_FIRST(edgeuse, &sA->eu_hd);
	while (RT_LIST_NOT_HEAD(eu, &sA->eu_hd)) {
d2238 2
a2239 2
		if (RT_LIST_PNEXT(edgeuse, eu) == eu->eumate_p)
			eu = RT_LIST_PNEXT_PNEXT(edgeuse, eu);
d2241 1
a2241 1
			eu = RT_LIST_PNEXT(edgeuse, eu);
d2246 1
a2246 1
			rt_log("nmg_class_shells - doing vertex\n");
d2267 1
a2267 1
CONST struct rt_tol *tol;
d2275 1
a2275 1
	RT_CK_TOL( tol );
d2277 1
a2277 1
rt_log("DANGER: nmg_classify_pt_loop() is calling nmg_class_pt_l(), which does not work well\n");
d2280 1
a2280 1
		rt_log( "nmg_classify_pt_loop: lu not part of a faceuse!!\n" );
d2289 1
a2289 1
		rt_log("nmg_classify_pt_l() ERROR, point (%g,%g,%g) not on face, dist=%g\n",
d2320 1
a2320 1
CONST struct rt_tol *tol;
d2330 1
a2330 1
	RT_CK_TOL( tol );
d2335 1
a2335 1
	if( RT_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
d2343 1
a2343 1
	for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d2383 1
a2383 1
		for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d2407 1
a2407 1
		rt_log( "nmg_get_interior_pt: Couldn't find interior point for lu x%x\n", lu );
d2429 1
a2429 1
CONST struct rt_tol *tol;
d2441 1
a2441 1
	RT_CK_TOL( tol );
d2444 1
a2444 1
		rt_log( "nmg_classify_lu_lu( lu1=x%x , lu2=x%x )\n", lu1, lu2 );
d2451 1
a2451 1
		rt_log( "nmg_classify_lu_lu: lu1 not part of a faceuse\n" );
d2457 1
a2457 1
		rt_log( "nmg_classify_lu_lu: lu2 not part of a faceuse\n" );
d2468 1
a2468 1
		rt_log( "nmg_classify_lu_lu: loops are not in same face\n" );
d2473 2
a2474 2
	if( RT_LIST_FIRST_MAGIC( &lu1->down_hd ) == NMG_EDGEUSE_MAGIC &&
	    RT_LIST_FIRST_MAGIC( &lu2->down_hd ) == NMG_EDGEUSE_MAGIC )
d2480 1
a2480 1
		for( RT_LIST_FOR( eu, edgeuse, &lu1->down_hd ) )
d2484 1
a2484 1
		for( RT_LIST_FOR( eu, edgeuse, &lu2->down_hd ) )
d2488 1
a2488 1
		eu1_start = RT_LIST_FIRST( edgeuse , &lu1->down_hd );
d2490 1
a2490 1
		eu2_start = RT_LIST_FIRST( edgeuse , &lu2->down_hd );
d2492 1
a2492 1
		while( RT_LIST_NOT_HEAD( eu2_start , &lu2->down_hd ) &&
d2496 1
a2496 1
			eu2_start = RT_LIST_PNEXT( edgeuse , &eu2_start->l );
d2499 1
a2499 1
		if( RT_LIST_NOT_HEAD( eu2_start , &lu2->down_hd ) &&
d2513 2
a2514 2
				eu1 = RT_LIST_PNEXT_CIRC( edgeuse , &eu1->l );
				eu2 = RT_LIST_PNEXT_CIRC( edgeuse , &eu2->l );
d2530 2
a2531 2
					eu1 = RT_LIST_PNEXT_CIRC( edgeuse , &eu1->l );
					eu2 = RT_LIST_PPREV_CIRC( edgeuse , &eu2->l );
d2538 1
a2538 1
					rt_log( "nmg_classify_lu_lu returning NMG_CLASS_AonBshared\n" );
d2549 1
a2549 1
				for( RT_LIST_FOR( eu , edgeuse , &lu1->down_hd ) )
d2568 1
a2568 1
								rt_log( "nmg_classify_lu_lu returning %s\n", nmg_class_name( class ) );
d2576 1
a2576 1
									rt_log( "nmg_classify_lu_lu returning NMG_CLASS_AoutB\n" );
d2582 1
a2582 1
									rt_log( "nmg_classify_lu_lu returning NMG_CLASS_AinB\n" );
d2610 1
a2610 1
			for( RT_LIST_FOR( eu , edgeuse , &lu1->down_hd ) )
d2629 1
a2629 1
							rt_log( "nmg_classify_lu_lu returning %s\n", nmg_class_name( class ) );
d2637 1
a2637 1
								rt_log( "nmg_classify_lu_lu returning NMG_CLASS_AoutB\n" );
d2643 1
a2643 1
								rt_log( "nmg_classify_lu_lu returning NMG_CLASS_AinB\n" );
d2653 1
a2653 1
			for( RT_LIST_FOR( eu , edgeuse , &lu1->down_hd ) )
d2671 1
a2671 1
							rt_log( "nmg_classify_lu_lu returning %s\n", nmg_class_name( class ) );
d2679 1
a2679 1
								rt_log( "nmg_classify_lu_lu returning NMG_CLASS_AoutB\n" );
d2685 1
a2685 1
								rt_log( "nmg_classify_lu_lu returning NMG_CLASS_AinB\n" );
d2693 1
a2693 1
			rt_log( "nmg_classify_lu_lu: Cannot classify lu x%x w.r.t. lu x%x\n",
d2698 2
a2699 2
	else if( RT_LIST_FIRST_MAGIC( &lu1->down_hd ) == NMG_VERTEXUSE_MAGIC &&
		 RT_LIST_FIRST_MAGIC( &lu2->down_hd ) == NMG_VERTEXUSE_MAGIC )
d2703 2
a2704 2
		vu1 = RT_LIST_FIRST( vertexuse , &lu1->down_hd );
		vu2 = RT_LIST_FIRST( vertexuse , &lu2->down_hd );
d2709 1
a2709 1
				rt_log( "nmg_classify_lu_lu returning NMG_CLASS_AonBshared\n" );
d2715 1
a2715 1
				rt_log( "nmg_classify_lu_lu returning NMG_CLASS_AoutB\n" );
d2720 1
a2720 1
	if( RT_LIST_FIRST_MAGIC( &lu1->down_hd ) == NMG_VERTEXUSE_MAGIC )
d2726 1
a2726 1
		vu = RT_LIST_FIRST( vertexuse , &lu1->down_hd );
d2741 1
a2741 1
			rt_log( "nmg_classify_lu_lu returning %s\n", nmg_class_name( class ) );
d2744 1
a2744 1
	else if( RT_LIST_FIRST_MAGIC( &lu2->down_hd ) == NMG_VERTEXUSE_MAGIC )
d2747 1
a2747 1
	rt_log( "nmg_classify_lu_lu: ERROR, Should not get here!!!\n" );
@


11.33
log
@Minor Mods for IRIX 6.2
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 11.32 1996/07/02 14:24:16 jra Exp jra $ (ARL)";
d247 3
d251 3
a253 1
	code = rt_dist_pt3_lseg3( &dist, pca, eupt, matept, pt, tol);
@


11.32
log
@Improved class_shared_lu().
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 11.31 1996/06/27 18:15:51 jra Exp $ (ARL)";
d1610 1
a1610 1
				lu_tmp == lu_tmp->lumate_p;
d2739 7
@


11.31
log
@Mods to class_shared_lu() to allow NMG_CLASS_AinB classification.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 11.30 1996/05/16 21:57:51 jra Exp jra $ (ARL)";
d1516 1
d1520 4
d1555 6
d1563 3
d1567 1
d1569 3
d1573 1
d1580 2
d1583 1
a1583 4
	s_ref = nmg_find_s_of_eu( eu_ref );
	eu_start = eu;
	eu_tmp = eu_start->eumate_p->radial_p;
	while( eu_tmp != eu_start )
d1585 1
a1585 2
		vect_t left_tmp;
		struct faceuse *fu;
d1587 2
a1588 2
		fu = nmg_find_fu_of_eu( eu_tmp );
		if( fu->s_p == s_ref )
d1590 37
a1626 1
			if( nmg_find_eu_leftvec( left_tmp, eu_tmp ) )
d1628 3
a1630 2
				rt_log( "class_shared_lu() couldn't get a left vector for EU x%x\n", eu_tmp );
				rt_bomb( "class_shared_lu() couldn't get a left vector for EU\n" );
d1633 14
a1646 1
			if( VDOT( left, left_tmp ) < tol->para )
d1648 2
a1649 1
				if( fu->orientation == OT_SAME )
d1654 2
a1655 2
			else
				return( NMG_CLASS_Unknown );
a1656 1
		eu_tmp = eu_tmp->eumate_p->radial_p;
d1659 2
d1689 3
d1696 7
d2046 3
d2076 6
d2094 1
a2094 1
						rt_log("Loop is INSIDE\n");
d2103 1
a2103 1
						rt_log("Loop is OUTSIDE\n");
@


11.30
log
@Made class_vu_vs_s() return in or out only.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 11.29 1996/04/30 20:31:14 jra Exp jra $ (ARL)";
d1492 2
a1493 1
 *			then classification is NMG_CLASS_AoutB.
d1507 4
a1510 3
class_shared_lu( lu, lu_ref )
struct loopuse *lu;
struct loopuse *lu_ref;
d1512 1
d1515 1
d1521 1
d1548 43
a1590 2
	if( VDOT( left, left_ref ) < 0.0 )
		return( NMG_CLASS_AoutB );
d1592 1
a1592 4
	if( eu->vu_p->v_p == eu_ref->vu_p->v_p ) 
		return( NMG_CLASS_AonBshared );
	else
		return( NMG_CLASS_AonBanti );
d1947 1
a1947 1
				test_class = class_shared_lu( lu, q_lu );
d1949 1
a1949 1
				test_class = class_shared_lu( lu, q_lu->lumate_p );
@


11.29
log
@Improved nmg_classify_lu_lu().
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 11.28 1996/04/26 15:07:59 jra Exp $ (ARL)";
d849 1
a849 1
	class = nmg_class_pt_s(pt, sB, 0, tol);
@


11.28
log
@Mods to class_lu_vs_s() to correctly classify loops that match loops from other shell.
Also improved nmg_classify_lu_lu().
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 11.27 1996/04/23 19:33:51 jra Exp jra $ (ARL)";
d2190 2
d2206 1
a2206 1
	VSETALL( test_pt, 0.0 );
d2215 1
a2215 1
		VADD2( test_pt, test_pt, vg->coord );
d2220 2
a2221 1
	VSCALE( test_pt, test_pt, one_over_count );
d2229 1
a2229 2
	/* Try moving just a little left of an edge */
	for( RT_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
d2231 20
a2250 2
		vect_t left;
		struct vertex_g *vg1,*vg2;
d2252 1
a2252 1
		(void)nmg_find_eu_leftvec( left, eu );
d2254 2
a2255 2
		vg1 = eu->vu_p->v_p->vg_p;
		vg2 = eu->eumate_p->vu_p->v_p->vg_p;
d2257 2
a2258 2
		VADD2( test_pt, vg1->coord, vg2->coord );
		VSCALE( test_pt, test_pt, 0.5 );
d2260 6
a2265 5
		VJOIN1( test_pt, test_pt, 3.0*tol->dist, left );
		if( nmg_class_pt_lu_except( test_pt, lu, (struct edge *)NULL, tol ) == NMG_CLASS_AinB )
		{
			VMOVE( pt, test_pt );
			return( 0 );
d2275 1
d2357 1
a2357 1
			eu2_start->vu_p->v_p != eu1_start->vu_p->v_p )
d2364 1
a2364 1
			eu1_start->vu_p->v_p == eu2_start->vu_p->v_p )
d2372 1
a2372 1
				if( eu1->vu_p->v_p != eu2->vu_p->v_p )
d2389 1
a2389 1
					if( eu1->vu_p->v_p != eu2->vu_p->v_p )
d2399 7
a2405 1
			if( share_edges )
d2407 7
a2413 1
				if( lu1_eu_count == lu2_eu_count )
d2415 36
a2450 3
					if( rt_g.NMG_debug & DEBUG_CLASSIFY )
						rt_log( "nmg_classify_lu_lu returning NMG_CLASS_AonBshared\n" );
					return( NMG_CLASS_AonBshared );
d2453 2
a2454 3
				/* All of lu1 edges are on lu2, but lu2 must have more
				 * edges. Need to compare in interior point of lu1
				 * to lu2
d2457 32
a2488 2
				/* Get an interior point of lu1 */
				if( (ret=nmg_get_interior_pt( pt, lu1, tol )) )
d2490 21
a2510 2
					rt_log( "nmg_classify_lu_lu: Couldn't get an interior point for lu x%x, nmg_get_interior_pt() returns %d\n", lu1, ret );
					rt_bomb( "nmg_classify_lu_lu: Couldn't get an interior point\n" );
d2512 13
d2526 2
a2527 3
				if( rt_g.NMG_debug & DEBUG_CLASSIFY )
					rt_log( "Classifying lu x%x w.r.t. lu x%x using point (%f %f %f) (inside lu x%x)\n",
						lu1, lu2, V3ARGS( pt ), lu1 );
d2529 25
a2553 2
				/* classify this point w.r.t. lu2 */
				return( nmg_class_pt_lu_except( pt, lu2, (struct edge *)NULL, tol ) );
d2555 5
a2607 65

	for( RT_LIST_FOR( eu , edgeuse , &lu1->down_hd ) )
	{
		struct vertex_g *vg;
		int class;

		NMG_CK_EDGEUSE( eu );

		vg = eu->vu_p->v_p->vg_p;
		NMG_CK_VERTEX_G( vg );

		class = nmg_class_pt_lu_except( vg->coord, lu2, (struct edgeuse *)NULL, tol);
		if( class != NMG_CLASS_AonBshared && class != NMG_CLASS_AonBanti )
		{
			if( lu2->orientation == OT_SAME )
			{
				if( rt_g.NMG_debug & DEBUG_CLASSIFY )
					rt_log( "nmg_classify_lu_lu returning %s\n", nmg_class_name( class ) );
				return( class );
			}
			else
			{
				if( class == NMG_CLASS_AinB )
				{
					if( rt_g.NMG_debug & DEBUG_CLASSIFY )
						rt_log( "nmg_classify_lu_lu returning NMG_CLASS_AoutB\n" );
					return( NMG_CLASS_AoutB );
				}
				if( class == NMG_CLASS_AoutB )
				{
					if( rt_g.NMG_debug & DEBUG_CLASSIFY )
						rt_log( "nmg_classify_lu_lu returning NMG_CLASS_AinB\n" );
					return( NMG_CLASS_AinB );
				}
			}
		}
	}

	/* If we get here, all vertices are shared, but the loops are not
	 * And neither loop is a single vertexuse
	 * Get an interior point of lu1 */
	if( (ret=nmg_get_interior_pt( pt, lu1, tol )) )
	{
		if( ret == 3 )
		{
			/* lu1 is a crack that is entirely shared with some portion
			 * of lu2, but not all of it. Return Unknown?????
			 */
				return( NMG_CLASS_Unknown );
			 
		}
		else
		{
			rt_log( "nmg_classify_lu_lu: Couldn't get an interior point for lu x%x (last chance nmg_get_interior_pt() returned %d\n", lu1, ret );
			rt_bomb( "nmg_classify_lu_lu: Couldn't get an interior point\n" );
		}
	}

	if( rt_g.NMG_debug & DEBUG_CLASSIFY )
		rt_log( "Classifying lu x%x w.r.t. lu x%x using point (%f %f %f) (inside lu x%x)\n",
			lu1, lu2, V3ARGS( pt ), lu1 );

	/* classify this point w.r.t. lu2 */
	return( nmg_class_pt_lu_except( pt, lu2, (struct edge *)NULL, tol ) );

@


11.27
log
@Modified class_lu_vs_s() to look for multiple matching loops and prefer NMG_CLASS_AonBshared.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 11.26 1996/04/23 18:51:51 jra Exp jra $ (ARL)";
d1478 74
a1568 2
	struct loopuse *match_lu[2];
	int matches=0;
d1584 1
d1589 1
a1589 2
	if( NMG_INDEX_TEST(classlist[NMG_CLASS_AonBshared], lu->l_p) ||
	    NMG_INDEX_TEST(classlist[NMG_CLASS_AonBanti], lu->l_p) )  {
d1591 1
d1595 6
d1604 1
d1700 1
d1706 1
d1736 1
d1812 1
d1818 1
a1818 1
	    eu != RT_LIST_FIRST(edgeuse, &lu->down_hd);
d1832 2
d1840 2
a1841 8
		fu_qlu = q_lu->up.fu_p;

		/* Compare OT_SAME faceuses */
		if( fu_qlu->orientation != OT_SAME )
		{
			fu_qlu = fu_qlu->fumate_p;
			q_lu = q_lu->lumate_p;
		}
d1845 6
a1850 2
		eu2 = eu;

d1854 2
d1858 2
d1867 1
a1867 1
		if( found_match )
d1869 12
a1880 1
			if( matches == 2 )
d1882 12
a1893 5
				rt_log( "class_lu_vs_s: Too many matching loops\n" );
				rt_bomb( "class_lu_vs_s: Too many matching loops" );
			}
			match_lu[matches] = q_lu;
			matches++;
d1896 1
a1896 11
	}

	if( matches )
	{
		struct faceuse *fu_qlu;
		fastf_t dot;
		int class[2];
		int final_class;
		int i;

		for( i=0 ; i<matches ; i++ )
d1898 1
a1898 2
			fu_qlu = match_lu[i]->up.fu_p;
			NMG_GET_FU_NORMAL( norm2, fu_qlu );
a1899 2
			dot = VDOT( norm1, norm2 );

d1901 1
a1901 1
				rt_log( "match = %d, dot=%f\n", i, dot );
d1903 4
a1906 4
			if( match_lu[i]->orientation == lu->orientation && dot > 0.0 )
				class[i] = NMG_CLASS_AonBshared;
			else if( match_lu[i]->orientation != lu->orientation && dot < 0.0 )
				class[i] = NMG_CLASS_AonBshared;
a1907 7
				class[i] = NMG_CLASS_AonBanti;
		}

		final_class = NMG_CLASS_AonBanti;
		for( i=0 ; i<matches ; i++ )
		{
			if( class[i] == NMG_CLASS_AonBshared )
d1909 3
a1911 2
				final_class = NMG_CLASS_AonBshared;
				break;
d1913 11
d1926 8
a1933 2
		NMG_INDEX_SET( classlist[final_class],lu->l_p );
		if( final_class == NMG_CLASS_AonBanti )
d1965 1
d1974 1
d1995 1
d1999 2
a2000 2
		rt_log("class_lu_vs_s(lu=x%x) return %s because %s\n",
			lu, nmg_class_status(status), reason );
d2175 4
a2178 1
 *		1 - Couldn't find an interior point
d2198 1
a2198 1
		return( 1 );
d2201 1
a2201 1
		return( 1 );
d2204 1
a2204 1
	VSETALL( pt, 0.0 );
d2248 7
a2254 1
	return( 1 );
d2275 2
a2276 1
	int same_loop;
d2279 1
d2329 1
a2329 1
		same_loop = 1;
d2336 4
a2339 4
			{
				NMG_CK_EDGEUSE( eu2_start );
				eu2_start = RT_LIST_PNEXT( edgeuse , &eu2_start->l );
			}
d2345 1
d2348 1
a2348 1
			while( RT_LIST_NOT_HEAD( eu1 , &lu1->down_hd ) )
d2352 1
a2352 1
					same_loop = 0;
d2355 1
a2355 1
				eu1 = RT_LIST_PNEXT( edgeuse , &eu1->l );
d2357 1
a2357 1
			}
d2359 1
a2359 1
			if( !same_loop )
d2362 1
a2362 1
				same_loop = 1;
d2365 1
a2365 1
				while( RT_LIST_NOT_HEAD( eu1 , &lu1->down_hd ) )
d2369 1
a2369 1
						same_loop = 0;
d2372 1
a2372 1
					eu1 = RT_LIST_PNEXT( edgeuse , &eu1->l );
d2374 1
a2374 2
				}

d2377 1
a2377 1
			if( same_loop )
a2378 2
				point_t pt;

d2392 1
a2392 1
				if( nmg_get_interior_pt( pt, lu1, tol ) )
d2394 2
a2395 2
					rt_log( "nmg_classify_lu_lu: Couldn't get an interior point for lu x%x\n", lu1 );
					rt_bomb( "nmg_classify_lu_lu: Couldn't get an interior point" );
d2398 4
d2491 20
d2512 6
a2517 2
		rt_log( "nmg_classify_lu_lu returning NMG_CLASS_AonBshaed\n" );
	return( NMG_CLASS_AonBshared );
@


11.26
log
@Added  nmg_get_interior_pt() and modified class_lu_vs_s() to use it
in classifying a LU that shares all EU's with another, but may not be shared.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 11.25 1996/04/22 12:34:39 jra Exp jra $ (ARL)";
d1495 2
d1740 1
a1740 1
		int match;
a1754 1
		NMG_GET_FU_NORMAL( norm2, fu_qlu );
d1756 7
d1767 1
a1767 1
		match = 1;
d1772 1
a1772 1
				match = 0;
d1779 1
a1779 1
		if( !match )
d1781 1
a1781 6
			/* check for match with q_lu->lumate_p */
			eu1 = RT_LIST_FIRST(edgeuse, &lu->down_hd);
			eu2 = eu;

			match = 2;
			do
d1783 5
a1787 8
				if( eu1->vu_p->v_p != eu2->eumate_p->vu_p->v_p )
				{
					match = 0;
					break;
				}
				eu1 = RT_LIST_PNEXT_CIRC( edgeuse, &eu1->l );
				eu2 = RT_LIST_PPREV_CIRC( edgeuse, &eu2->l );
			} while( eu1 != RT_LIST_FIRST(edgeuse, &lu->down_hd));
d1790 11
a1800 1
		if( match )
d1802 2
a1803 1
			fastf_t dot;
d1808 1
a1808 1
				rt_log( "match = %d, dot=%f\n", match, dot );
d1810 4
a1813 21
			if( dot > 0.0 && fu_eu->orientation == fu_qlu->orientation ||
			    dot < 0.0 && fu_eu->orientation != fu_qlu->orientation )
			{
		    		/* ON-shared */
		    		if( lu->orientation == OT_OPPOSITE )  {
				    	NMG_INDEX_SET(classlist[NMG_CLASS_AonBanti],
				    		lu->l_p );
					if (rt_g.NMG_debug & DEBUG_CLASSIFY)
						rt_log("Loop is on-antishared (lu orient is OT_OPPOSITE)\n");
					nmg_reclassify_lu_eu( lu, classlist, NMG_CLASS_AonBanti );
		    		}  else {
				    	NMG_INDEX_SET(classlist[NMG_CLASS_AonBshared],
				    		lu->l_p );
					if (rt_g.NMG_debug & DEBUG_CLASSIFY)
						rt_log("Loop is on-shared\n");
		    			/* no need to reclassify, edges were previously marked as AonBshared */
		    		}
				reason = "edges identical with radial face, normals colinear";
		    		status = ON_SURF;
		    		goto out;
			}
d1815 7
d1823 2
a1824 17
		    		/* ON-antishared */
		    		if( lu->orientation == OT_OPPOSITE )  {
					NMG_INDEX_SET(classlist[NMG_CLASS_AonBshared],
						lu->l_p );
					if (rt_g.NMG_debug & DEBUG_CLASSIFY)
						rt_log("Loop is on-shared (lu orient is OT_OPPOSITE)\n");
		    			/* no need to reclassify, edges were previously marked as AonBshared */
		    		}  else  {
					NMG_INDEX_SET(classlist[NMG_CLASS_AonBanti],
						lu->l_p );
					if (rt_g.NMG_debug & DEBUG_CLASSIFY)
						rt_log("Loop is on-antishared\n");
					nmg_reclassify_lu_eu( lu, classlist, NMG_CLASS_AonBanti );
		    		}
				reason = "edges identical with radial face, normals opposite";
				status = ON_SURF;
				goto out;
d1827 8
@


11.25
log
@ifdef'd out topological attempt to classify eu_vs_shell.
Modified class_lu_vs_s() to not use nmg_2lu_identical().
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 11.24 1996/03/28 14:27:59 jra Exp $ (ARL)";
d2068 79
d2166 2
d2209 8
d2246 1
a2246 1
			if( same_loop )
d2248 15
a2262 3
				if( rt_g.NMG_debug & DEBUG_CLASSIFY )
					rt_log( "nmg_classify_lu_lu returning NMG_CLASS_AonBshared\n" );
				return( NMG_CLASS_AonBshared );
d2265 1
a2265 5
			/* maybe the other way round */
			same_loop = 1;
			eu1 = eu1_start;
			eu2 = eu2_start;
			while( RT_LIST_NOT_HEAD( eu1 , &lu1->down_hd ) )
d2267 16
a2282 1
				if( eu1->vu_p->v_p != eu2->vu_p->v_p )
d2284 2
a2285 2
					same_loop = 0;
					break;
a2286 3
				eu1 = RT_LIST_PNEXT( edgeuse , &eu1->l );
				eu2 = RT_LIST_PPREV_CIRC( edgeuse , &eu2->l );
			}
d2288 2
a2289 5
			if( same_loop )
			{
				if( rt_g.NMG_debug & DEBUG_CLASSIFY )
					rt_log( "nmg_classify_lu_lu returning NMG_CLASS_AonBshared\n" );
				return( NMG_CLASS_AonBshared );
@


11.24
log
@Mods to account ofr new arg for nmg_class_pt_fu_except().
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 11.23 1996/03/25 21:17:36 jra Exp jra $ (ARL)";
d1009 1
a1009 1

d1019 3
d1060 1
d1062 5
d1073 1
d1075 13
a1087 2
				while( nmg_find_s_of_eu( eu_rad ) != s && eu_rad != eu_on && eu_rad != eu_on->eumate_p )
					eu_rad = eu_rad->eumate_p->radial_p;
d1090 12
a1101 1
				if( fu_rad->s_p == s )
d1103 27
a1129 1
					if( fu_rad->orientation == OT_SAME )
d1144 6
d1155 1
d1496 2
d1658 1
d1726 20
d1747 46
d1794 49
@


11.23
log
@Modified new algorithm in class_eu_vs_s().
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 11.22 1996/03/18 00:01:19 jra Exp jra $ (ARL)";
d564 1
a564 1
		NULL, NULL, NULL, 0, tol );
d686 1
a686 1
					tol);
@


11.22
log
@Modified nmg_class_pt_s() to accept flag to ignore tolerance distance
in classifification. Also added algorithm in class_eu_vs_s() to handle
classifying EU with both vertices ON.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 11.21 1996/03/08 19:49:03 jra Exp jra $ (ARL)";
d849 1
a849 1
	class = nmg_class_pt_s(pt, sB, 1, tol);
d858 2
a859 3
		rt_pr_tol(tol);
		VPRINT("pt", pt);
		rt_bomb("class_vu_vs_s:  classifier found point ON, vertex topology should have been shared\n");
d894 1
a894 1
		rt_log( "class_eu_vs_s( eu=x%x, s=x%x )\n", eu, s );
d1021 1
a1021 1
			 * if we fins an ON, keep it handy
d1054 1
a1054 9
			if( in )
			{
				/* If intersector worked properly, then this entire
				 * loop must be in
				 */
				class_topo = NMG_CLASS_AinB;
				reason = "of other parts of loop are in";
			}
			else if( out )
a1055 8
				/* If intersector worked properly, then this entire
				 * loop must be out
				 */
				class_topo = NMG_CLASS_AoutB;
				reason = "of other parts of loop are out";
			}
			else if( on )
			{
d1065 1
a1065 1
				while( nmg_find_s_of_eu( eu_rad ) != s && eu_rad != eu_on )
d1069 1
a1069 17
				if( fu_rad->s_p != s )
				{
					rt_log( "eu (x%x) is classed on, but isn't!!\n", eu_on );
					rt_bomb( "eu is classed on, but isn't!!" );
				}

				if( fu_rad->orientation == OT_SAME )
				{
					class_topo = NMG_CLASS_AoutB;
					reason = "nearest radial face is OT_SAME";
				}
				else if( fu_rad->orientation == OT_OPPOSITE )
				{
					class_topo = NMG_CLASS_AinB;
					reason = "nearest radial face is OT_OPPOSITE";
				}
				else
d1071 15
a1085 2
					rt_log( "FU (x%x) has bad orientation (%s)\n", fu_rad, nmg_orientation( fu_rad->orientation ) );
					rt_bomb( "FU has bad orientation" );
d2038 8
@


11.21
log
@ removed some debug printing.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 11.20 1996/03/07 15:18:52 jra Exp $ (ARL)";
d616 4
d628 1
a628 1
nmg_class_pt_s(pt, s, tol)
d631 1
d662 3
a664 1
	faces_seen = (long *)rt_calloc( m->maxindex, sizeof(long), "nmg_class_pt_s faces_seen[]" );
d666 5
a670 5
	/*
	 *  First pass:  Try hard to see if point is ON a face.
	 */
	for( RT_LIST_FOR(fu, faceuse, &s->fu_hd) )  {
		plane_t	n;
d672 2
a673 2
		/* If this face processed before, skip on */
		if( NMG_INDEX_TEST( faces_seen, fu->f_p ) )  continue;
d675 2
a676 2
		/* Only consider the outward pointing faceuses */
		if( fu->orientation != OT_SAME )  continue;
d678 5
a682 12
		/* See if this point lies on this face */
		NMG_GET_FU_PLANE( n, fu );
		if( (fabs(DIST_PT_PLANE(pt, n))) < tol->dist)  {
			/* Point lies on this plane, it may be possible to
			 * short circuit everything.
			 */
			class = nmg_class_pt_fu_except(pt, fu, (struct loopuse *)0,
				(void (*)())NULL, (void (*)())NULL, (char *)NULL, 0,
				tol);
			if( class == NMG_CLASS_AonBshared )  {
				/* Point is ON face, therefore it must be
				 * ON the shell also.
d684 18
a701 2
				class = NMG_CLASS_AonBshared;
				goto out;
d703 3
a705 8
			if( class == NMG_CLASS_AinB )  {
				/* Point is IN face, therefor it must be
				 * ON the shell also.
				 */
				class = NMG_CLASS_AonBshared;
				goto out;
			}
			/* Point is OUTside face, its undecided. */
a706 3

		/* Mark this face as having been processed */
		NMG_INDEX_SET(faces_seen, fu->f_p);
a708 1

d735 1
a735 1
	class = nmg_class_ray_vs_shell(&rp, s, tol);
d739 3
a741 1
	rt_free( (char *)faces_seen, "nmg_class_pt_s faces_seen[]" );
d849 1
a849 1
	class = nmg_class_pt_s(pt, sB, tol);
d894 2
d897 1
d963 4
d1007 1
d1010 106
a1115 1
		VADD2SCALE(pt, eupt, matept, 0.5);
d1117 22
a1138 2
		if (rt_g.NMG_debug & DEBUG_CLASSIFY)
			VPRINT("class_eu_vs_s: midpoint of edge", pt);
a1139 2
		class = nmg_class_pt_s(pt, s, tol);
		reason = "midpoint classification (both verts ON)";
d1300 1
a1300 1

d1310 1
d1995 3
d1999 1
d2017 3
d2021 1
d2033 3
d2037 1
d2039 3
d2043 1
d2050 1
d2057 4
a2060 1
		return( nmg_class_pt_lu_except( vg->coord, lu2, (struct edgeuse *)NULL, tol ));
d2077 3
d2081 1
d2085 3
d2089 1
d2091 3
d2095 1
d2100 2
@


11.20
log
@Added a bit of info in a debug print.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 11.19 1996/03/05 21:25:29 jra Exp jra $ (ARL)";
d719 1
a719 1
	if (rt_g.NMG_debug & DEBUG_CLASSIFY || try > 1)
d733 1
a733 1
	if (rt_g.NMG_debug & DEBUG_CLASSIFY || try > 1)
@


11.19
log
@Fixed bug in nmg_2lu_identical().
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 11.18 1995/06/17 02:43:49 mike Exp $ (ARL)";
d765 1
a765 1
		rt_log("class_vu_vs_s(vu=x%x) pt=(%g,%g,%g)\n", vu, V3ARGS(pt) );
@


11.18
log
@Once again, expect NMG ray-tracer to return NMG_CLASS_Unknown,
and retry.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 11.17 1995/05/05 19:27:52 jra Exp mike $ (ARL)";
d639 1
a639 1
	int		try;
d1159 2
d1172 7
a1178 1
		if( VDOT( fu1->f_p->g.plane_p->N, fu2->f_p->g.plane_p->N ) < 0 )
d1913 12
a1924 2
		if( class != NMG_CLASS_AonBshared )
			return( class );
@


11.17
log
@Modified nmg_classify_lu_lu() to use nmg_class_pt_lu_except() instead of nmg_class_pt_l().
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 11.16 95/02/28 00:40:36 mike Exp $ (ARL)";
d590 5
a594 2
	3, 2, 1,
	-3,-2,-1,
d598 2
a602 1
	1, 1, 1,
a644 7
	/* Choose an unlikely direction */
	try = 0;
retry:
	VMOVE( projection_dir, nmg_good_dirs[try] );
	try++;
	VUNITIZE(projection_dir);

a657 3
	NMG_CK_REGION_A(s->r_p->ra_p);
	VSUB2( region_diagonal, s->r_p->ra_p->max_pt, s->r_p->ra_p->min_pt );
	region_diameter = MAGNITUDE(region_diagonal);
a658 4
	if (rt_g.NMG_debug & DEBUG_CLASSIFY)
		rt_log("\tPt=(%g, %g, %g) dir=(%g, %g, %g), reg_diam=%g\n",
			V3ARGS(pt), V3ARGS(projection_dir), region_diameter);

d708 14
d727 1
a727 1
	/* get the ray-tracer to tell us if we're inside or outside */
d729 1
d734 2
a735 2
		rt_log("nmg_class_pt_s: returning %s, s=x%x\n",
			nmg_class_name(class), s );
@


11.16
log
@Eliminated nmg_class_pt_f_except() and nmg_class_pt_f() in favor of
Lee's new nmg_class_pt_fu_except().
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 11.15 95/02/27 23:54:15 mike Exp Locker: mike $ (ARL)";
a1760 1
 *  XXX DANGER:  Calls nmg_class_pt_l(), which does not work well.
a1768 1
	struct neighbor	closest;
a1776 1
rt_log("DANGER: nmg_classify_lu_lu() is calling nmg_class_pt_l(), which does not work well\n");
a1875 5
	/* initialize the "closest" structure */
	closest.dist = MAX_FASTF;
	closest.p.eu = (struct edgeuse *)NULL;
	closest.class = NMG_CLASS_AoutB;	/* default return */

d1886 1
a1886 4
		nmg_class_pt_l( &closest , vg->coord , lu2 , tol );

		return( closest.class );
		
d1892 1
d1899 3
a1901 9
		/* reset the closest structure for each call */
		closest.dist = MAX_FASTF;
		closest.p.eu = (struct edgeuse *)NULL;
		closest.class = NMG_CLASS_AoutB;	/* default return */

		nmg_class_pt_l( &closest , vg->coord , lu2 , tol );

		if( closest.class != NMG_CLASS_AonBshared )
			return( closest.class );
@


11.15
log
@Changed nmg_class_lu_fu() to use new nmg_class_pt_fu_except() routine.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 11.14 95/02/21 14:23:02 jra Exp Locker: mike $ (ARL)";
d127 5
d198 2
d210 3
d400 2
d408 6
a487 100
 *			N M G _ C L A S S _ P T _ F _ E X C E P T
 *
 *  This is intended as a general user interface routine.
 *  Given the Cartesian coordinates for a point which is known to
 *  lie on a face, return the classification for that point
 *  with respect to all the loops on that face.
 *
 *  The algorithm used is to find the edge which the point is closest
 *  to, and classifiy with respect to that.
 *
 *  All loops have to be searched together, to account for holes inside
 *  exterior loops, potentially with solid parts inside those holes.
 *
 *  "ignore_lu" is optional.  When non-null, it points to a loopuse (and it's
 *  mate) which will not be considered in the assessment of this point.
 *  This is used by nmg_lu_reorient() to work on one lu in the face.
 *
 *  The point is "A", and the face is "B".
 *
 *  Returns -
 *	NMG_CLASS_AinB		pt is INSIDE the area of the face.
 *	NMG_CLASS_AonBshared	pt is ON a loop boundary.
 *	NMG_CLASS_AoutB		pt is OUTSIDE the area of the face.
 */
int
nmg_class_pt_f_except(pt, fu, ignore_lu, tol)
CONST point_t		pt;
CONST struct faceuse	*fu;
CONST struct loopuse	*ignore_lu;
CONST struct rt_tol	*tol;
{
	struct loopuse *lu;
	struct neighbor closest;
	fastf_t		dist;
	plane_t		n;

	if (rt_g.NMG_debug & DEBUG_CLASSIFY) {
		VPRINT("nmg_class_pt_f\tPt:", pt);
	}
	NMG_CK_FACEUSE(fu);
	NMG_CK_FACE(fu->f_p);
	NMG_CK_FACE_G_PLANE(fu->f_p->g.plane_p);
	if(ignore_lu) NMG_CK_LOOPUSE(ignore_lu);
	RT_CK_TOL(tol);

	/* Validate distance from point to plane */
	NMG_GET_FU_PLANE( n, fu );
	if( (dist=fabs(DIST_PT_PLANE( pt, n ))) > tol->dist )  {
		rt_log("nmg_class_pt_f() ERROR, point (%g,%g,%g) not on face, dist=%g\n",
			V3ARGS(pt), dist );
	}

	/* find the closest approach in this face to the projected point */
	closest.dist = MAX_FASTF;
	closest.p.eu = (struct edgeuse *)NULL;
	closest.class = NMG_CLASS_AoutB;	/* default return */

	for (RT_LIST_FOR(lu, loopuse, &fu->lu_hd)) {
		if( ignore_lu && (ignore_lu == lu || ignore_lu == lu->lumate_p) )
			continue;

		nmg_class_pt_l( &closest, pt, lu, tol );
		/* If point lies ON loop edge, we are done */
		if( closest.class == NMG_CLASS_AonBshared )  break;
	}

	if (rt_g.NMG_debug & DEBUG_CLASSIFY) {
		rt_log("nmg_class_pt_f\tdist=%g, return=%s\n",
			closest.dist,
			nmg_class_name(closest.class) );
	}
	return closest.class;
}

/*
 *			N M G _ C L A S S _ P T _ F
 *
 *  Compatability wrapper.
 */
int
nmg_class_pt_f(pt, fu, tol)
CONST point_t		pt;
CONST struct faceuse	*fu;
CONST struct rt_tol	*tol;
{
#if 0
	return nmg_class_pt_f_except(pt, fu, (struct loopuse *)0, tol);
#else

	point_t tmp_pt;

	VMOVE( tmp_pt, pt );
	return nmg_class_pt_fu_except(tmp_pt, fu, (struct loopuse *)0,
			(void (*)())NULL, (void (*)())NULL, (char *)NULL, 0,
			tol);
#endif                                                                        

}

/*
d506 3
d687 3
a689 1
			class = nmg_class_pt_f( pt, fu, tol );
d1281 3
d1589 3
d1626 3
d1703 5
d1723 1
d1757 5
d1779 1
@


11.14
log
@Quick hack to nmg_class_pt_f() to get it to compile.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 11.13 95/02/21 11:16:29 butler Exp Locker: jra $ (ARL)";
a577 3
 *  The algorithm used is to find the edge which the point is closest
 *  to, and classifiy with respect to that.
 *
d597 5
a601 6
	struct loopuse *lu2;
	struct neighbor closest;
	struct edgeuse	*eu;
	struct edgeuse	*eu_first;
	fastf_t		dist;
	plane_t		n;
d642 2
a643 3
	closest.dist = MAX_FASTF;
	closest.p.eu = (struct edgeuse *)NULL;
	closest.class = NMG_CLASS_AoutB;	/* default return */
d645 9
a653 10
	for (RT_LIST_FOR(lu2, loopuse, &fu->lu_hd)) {
		/* Do not use the supplied loopuse in the comparison! */
		if( lu2 == lu )  continue;
		if( lu2 == lu->lumate_p )  continue;

		/* Any other OT_UNSPEC or OT_BOOLPLACE lu's don't help either */
		if( lu2->orientation != OT_SAME && lu2->orientation != OT_OPPOSITE )  {
			if (rt_g.NMG_debug & DEBUG_CLASSIFY)  {
				rt_log("nmg_class_lu_fu(lu=x%x) WARNING:  skipping %s lu=x%x in fu=x%x!\n",
					lu, nmg_orientation(lu2->orientation), lu2, fu);
d655 1
a655 1
			continue;
a656 12

		/* XXX Any point to doing a topology search first? */
		nmg_class_pt_l( &closest, vg->coord, lu2, tol );

		/* If this vertex lies ON loop edge, must check all others. */
		if( closest.class == NMG_CLASS_AonBshared )  {
			if( !eu_first )  break;  /* was self-loop */
			eu = RT_LIST_PNEXT_CIRC(edgeuse, &eu->l);
			if( eu == eu_first )  break;	/* all match */
			vu = eu->vu_p;
			goto again;
		}
d660 1
a660 1
		rt_log("nmg_class_lu_fu(lu=x%x) END, dist=%g, ret=%s\n",
d662 1
a662 2
			closest.dist,
			nmg_class_name(closest.class) );
d664 1
a664 1
	return closest.class;
@


11.13
log
@forgot a comma
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 11.12 1995/02/21 10:57:47 butler Exp butler $ (ARL)";
d558 5
a562 1
	return nmg_class_pt_fu_except(pt, fu, (struct loopuse *)0,
@


11.12
log
@changed nmg_class_pt_f() to call nmg_class_pt_fu_except() from nmg_pt_fu.c
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 11.11 1995/02/21 03:04:24 butler Exp butler $ (ARL)";
d559 1
a559 1
			(void (*)())NULL, (void (*)())NULL (char *)NULL, 0,
@


11.11
log
@name change for nmg_ray_vs_shell -> nmg_class_ray_vs_shell()
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 11.10 1995/02/17 19:35:33 mike Exp butler $ (ARL)";
d555 1
d557 6
@


11.10
log
@Always use cached classifications.  And don't overlook the
anti-shared one either (which vu and eu were doing).
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 11.9 95/02/17 09:14:19 butler Exp Locker: mike $ (ARL)";
d809 1
a809 1
	class = nmg_ray_vs_shell(&rp, s, tol);
@


11.9
log
@nmg_ray_vs_shell() now returns the point class directly
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 11.8 1995/02/16 03:33:08 mike Exp butler $ (ARL)";
d847 5
a851 15
	if( !(rt_g.NMG_debug & DEBUG_CLASSIFY) )  {
		/* As an efficiency & consistency measure, check for vertex in class list */
		reason = "of classlist";
		if( NMG_INDEX_TEST(classlist[NMG_CLASS_AinB], vu->v_p) )  {
			status = INSIDE;
			goto out;
		}
		if( NMG_INDEX_TEST(classlist[NMG_CLASS_AonBshared], vu->v_p) )  {
			status = ON_SURF;
			goto out;
		}
		if( NMG_INDEX_TEST(classlist[NMG_CLASS_AoutB], vu->v_p) )  {
			status = OUTSIDE;
			goto out;
		}
d853 12
a921 3
	/* XXX For major efficiency, should store classification for
	 * XXX all other uses of this vertex in this shell (sA)!
	 */
d971 5
a975 15
	if( !(rt_g.NMG_debug & DEBUG_CLASSIFY) )  {
		/* check to see if edge is already in one of the lists */
		reason = "of classlist";
		if( NMG_INDEX_TEST(classlist[NMG_CLASS_AinB], eu->e_p) )  {
			status = INSIDE;
			goto out;
		}
		if( NMG_INDEX_TEST(classlist[NMG_CLASS_AonBshared], eu->e_p) )  {
			status = ON_SURF;
			goto out;
		}
		if( NMG_INDEX_TEST(classlist[NMG_CLASS_AoutB], eu->e_p) )  {
			status = OUTSIDE;
			goto out;
		}
d977 13
a1160 4
	/* XXX For major efficiency, should store classification for
	 * XXX all other edgeuses of this edge in this shell (sA)!
	 * Nope, edges get the classification, not edgeuses.
	 */
@


11.8
log
@Wrote nmg_reclassify_lu_eu(), and called it.
if it marks a loop
are onAonBantishared then it goes back and re-marks the edgeuses in that
loop as onAonBantishared as well.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 11.7 95/02/15 00:13:40 mike Exp Locker: mike $ (ARL)";
a805 1
	hitcount = nmg_ray_vs_shell(&rp, s, tol);
d808 3
a810 8
	/*  Using Jordan Curve Theorem, if hitcount is even, point is OUT.
	 *  If hiscount is odd, point is IN.
	 */
	if (hitcount & 1) {
		class = NMG_CLASS_AinB;
	} else {
		class = NMG_CLASS_AoutB;
	}
@


11.7
log
@Noted major efficiency opportunity.
Beyond that, the change would also ensure that questions are
only asked once!
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 11.6 95/02/14 00:48:50 mike Exp Locker: mike $ (ARL)";
d1167 1
d1290 83
d1403 2
a1404 1
	if( NMG_INDEX_TEST(classlist[NMG_CLASS_AonBshared], lu->l_p) )  {
d1480 3
a1482 1
					nmg_euprint("On:  edgeuse", eu);
d1576 1
a1576 2
	    		if( lu->orientation == OT_OPPOSITE )
	    		{
d1581 2
a1582 3
	    		}
	    		else
	    		{
d1587 1
d1594 1
a1594 2
	    		if( lu->orientation == OT_OPPOSITE )
	    		{
d1599 2
a1600 3
	    		}
	    		else
	    		{
d1605 1
@


11.6
log
@Added some code to track down intersector bugs.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 11.5 95/02/11 01:53:27 mike Exp Locker: mike $ (ARL)";
d926 3
d1165 3
@


11.5
log
@Added some debugging, the trail leads back to the intersector.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 11.4 95/01/20 20:00:15 mike Exp Locker: mike $ (ARL)";
d1110 20
@


11.4
log
@Fixed bug in point -vs- loop classifier.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 11.3 95/01/20 19:18:08 mike Exp Locker: mike $ (ARL)";
d1051 20
d1088 1
d1092 2
a1093 1
			rt_g.NMG_debug |= DEBUG_MESH;
d1096 1
a1096 1
			nmg_mesh_face_shell( eu->up.lu_p->up.fu_p, s );
d1098 12
@


11.3
log
@Removed XXX Hack of using 0.0005 distance tolerance.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 11.2 95/01/20 02:19:30 mike Exp Locker: mike $ (ARL)";
d254 4
a257 9
 		 *  If "closest" result so far was a NMG_CLASS_AinB or
		 *  or NMG_CLASS_AonB, then keep it,
 		 *  otherwise, replace that result with whatever we find
 		 *  here.  Logic:  Two touching loops, one concave ("A")
		 *  which wraps around part of the other ("B"), with the
 		 *  point inside A near the contact with B.  If loop B is
		 *  processed first, the closest result will be NMG_CLASS_AoutB,
 		 *  and when loop A is visited the distances will be exactly
 		 *  equal, not giving A a chance to claim it's hit.
d259 7
a265 2
 		if( closest->class == NMG_CLASS_AinB ||
		    closest->class == NMG_CLASS_AonBshared )  {
d267 24
a290 6
				rt_log("\t\tSkipping, earlier eu at same dist, is IN or ON\n");
 			return;
 		}
 		if(rt_g.NMG_debug & DEBUG_CLASSIFY)
			rt_log("\t\tEarlier eu at same dist, is OUT, continue processing.\n");
 	}
d479 3
@


11.2
log
@Improved debugging
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 11.1 95/01/04 09:57:25 mike Rel4_4 Locker: mike $ (ARL)";
d238 1
a238 9
	{
		struct rt_tol	xtol;
		/*XXXX HACK:  To keep from hitting vertices & edges,
		 *XXXX  use ultra-strict hard-coded tolerance here */
		xtol = *tol;	/* struct copy */
		xtol.dist = 0.0005;
		xtol.dist_sq = xtol.dist_sq * xtol.dist_sq;
		code = rt_dist_pt3_lseg3( &dist, pca, eupt, matept, pt, &xtol);
	}
@


11.1
log
@Release_4.4
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 10.65 94/12/27 17:47:59 mike Exp $ (ARL)";
d920 2
@


10.65
log
@Bug 247, changed show_broken_stuff to nmg_show_broken_classifier_stuff().
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 10.64 94/12/22 00:58:01 mike Exp Locker: mike $ (ARL)";
@


10.64
log
@Eliminated warning about unused variable.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 10.63 94/12/16 16:26:02 jra Exp Locker: mike $ (ARL)";
d1094 1
a1094 1
		show_broken_stuff((long *)eu, classlist, nmg_class_nothing_broken, 0, (char *)NULL);
@


10.63
log
@class_lu_vs_s now looks at the lu orientation.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 10.62 94/11/30 03:58:12 butler Exp Locker: jra $ (ARL)";
a700 1
	fastf_t 	dist;
d757 1
a757 1
		if( (dist = fabs(DIST_PT_PLANE(pt, n))) < tol->dist)  {
@


10.62
log
@checkpoint
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 10.61 94/11/04 06:58:17 mike Exp Locker: butler $ (ARL)";
d1415 14
a1428 4
		    	NMG_INDEX_SET(classlist[NMG_CLASS_AonBshared],
		    		lu->l_p );
			if (rt_g.NMG_debug & DEBUG_CLASSIFY)
				rt_log("Loop is on-shared\n");
d1434 14
a1447 4
			NMG_INDEX_SET(classlist[NMG_CLASS_AonBanti],
				lu->l_p );
			if (rt_g.NMG_debug & DEBUG_CLASSIFY)
				rt_log("Loop is on-antishared\n");
@


10.61
log
@Irix 6
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 10.60 94/09/21 03:37:22 mike Exp Locker: mike $ (ARL)";
d128 2
a129 1
static void joint_hitmiss2(closest, eu, pt, code)
d711 1
a755 3
		/* Mark this face as having been processed */
		NMG_INDEX_SET(faces_seen, fu->f_p);

a779 23
#if 0
/* XXX Need to get manifolds table from caller! */
/* For now, assume there aren't any.  Real ray-tracer knows how to do this better. */
		/* Dangling faces don't participate in Jordan Curve calc */
		if (nmg_dangling_face(fu,manifolds))  continue;
#endif

/* XXX Adding this code in breaks Test1.r! */
#if 0
		/* Un-mark this face, handle it in the second pass */
		NMG_INDEX_CLEAR(faces_seen, fu->f_p);
	}

	/*
	 *  Second pass:  Jordan Curve algorithm.
	 *  Fire a ray in "projection_dir", and count face crossings.
	 */
	for( RT_LIST_FOR(fu, faceuse, &s->fu_hd) )  {
		plane_t	n;

		/* If this face processed before, skip on */
		if( NMG_INDEX_TEST( faces_seen, fu->f_p ) )  continue;

d782 1
a782 1
#endif
a783 2
		/* Only consider the outward pointing faceuses */
		if( fu->orientation != OT_SAME )  continue;
d785 10
a794 4
		/* Find point where ray hits the plane. */
		NMG_GET_FU_PLANE( n, fu );
		stat = rt_isect_line3_plane(&dist, pt, projection_dir,
			n, tol);
a795 4
		if (rt_g.NMG_debug & DEBUG_CLASSIFY) {
			rt_log("\tray/plane: stat:%d dist:%g\n", stat, dist);
			PLPRINT("\tplane", n);
		}
a796 46
		if( stat < 0 )  continue;	/* Ray missed */
		if( dist < 0 )  continue;	/* Hit was behind start pt. */

		/* XXX This case needs special handling */
		if( stat == 0 )  rt_bomb("nmg_class_pt_s: ray is ON face!\n");

		/*
		 *  The ray hit the face.  Determine if this is a reasonable
		 *  hit distance by comparing with the region diameter.
		 */
		if( dist > region_diameter )  {
			if (rt_g.NMG_debug & DEBUG_CLASSIFY)
				rt_log("\tnmg_class_pt_s: hit plane outside region, skipping\n");
			continue;
		}

		/*
		 * Construct coordinates of hit point, and classify.
		 * XXX In the case of an ON result,
		 * XXX this really needs to be a ray/edge classification,
		 * XXX not a point/edge classification.
		 * XXX The ray can go in/in, out/out, in/out, out/in,
		 * XXX with different meanings.  Can't tell the difference here.
		 */
	    	VJOIN1(plane_pt, pt, dist, projection_dir);
		if (rt_g.NMG_debug & DEBUG_CLASSIFY)
			rt_log("\tClassify ray/face intercept point\n");
		class = nmg_class_pt_f( plane_pt, fu, tol );
		if( class == NMG_CLASS_AinB )  hitcount++;
		else if( class == NMG_CLASS_AonBshared )  {
			/* XXX Can't handle this case.
			 * XXX Keep picking different directions until
			 * XXX no "hard" cases come up.  (Limit 10 per customer).
			 */
			if( try < 10 )  {
				rt_log("nmg_class_pt_s(%g, %g, %g) try=%d, grazed edge\n", V3ARGS(pt), try);
				goto retry;
			}
			hitcount++;
			rt_bomb("nmg_class_pt_s: ray grazed an edge, could be 1 hit (in/out) or 2 hits (in/in, out/out), can't tell which!\n");
		}
		if (rt_g.NMG_debug & DEBUG_CLASSIFY)
			rt_log("nmg_class_pt_s:\t ray hitcount=%d\n", hitcount);
	}
	rt_free( (char *)faces_seen, "nmg_class_pt_s faces_seen[]" );

d806 1
d819 2
a820 1
static int class_vu_vs_s(vu, sB, classlist, tol)
d939 2
a940 1
static int class_eu_vs_s(eu, s, classlist, tol)
d1217 2
a1218 1
static int class_lu_vs_s(lu, s, classlist, tol)
d1501 2
a1502 1
static void class_fu_vs_s(fu, s, classlist, tol)
@


10.60
log
@deleted "manifolds" from struct model, and moved it to struct ray_data.
Added extra argument to nmg_dangling_face().
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 10.59 94/09/16 20:20:56 mike Exp Locker: mike $ (ARL)";
d216 1
a216 1
	fastf_t dot, mag;
d1292 1
a1292 1
	struct edgeuse *eu, *p, *q;
d1682 1
a1682 1
	vect_t n;
@


10.59
log
@Moved stuff to raytrace.h
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 10.58 94/09/02 01:14:48 mike Exp Locker: mike $ (ARL)";
d781 3
d785 2
a786 1
		if (nmg_dangling_face(fu))  continue;
@


10.58
log
@More fallout from face_g changes.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 10.57 94/09/02 00:31:47 mike Exp Locker: mike $ (ARL)";
a1164 4

/* XXX move to raytrace.h, in section for nmg_info.c */
RT_EXTERN(int		nmg_2lu_identical, (CONST struct edgeuse *eu1,
			CONST struct edgeuse *eu2));
@


10.57
log
@Changed to new face geometry pointers (g.plane_p)
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 10.56 94/08/10 18:48:22 gdurf Exp Locker: mike $ (ARL)";
d1242 1
a1242 1
		nmg_pr_fg(fu1->f_p->g.plane_p, 0);
d1246 1
a1246 1
		nmg_pr_fg(fu2->f_p->g.plane_p, 0);
@


10.56
log
@fix include ordering
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 10.55 1994/08/09 19:37:24 mike Exp gdurf $ (ARL)";
d497 1
a497 1
	NMG_CK_FACE_G(fu->f_p->fg_p);
d588 1
a588 1
	NMG_CK_FACE_G(fu->f_p->fg_p);
d1238 1
a1238 1
	if( fu1->f_p->fg_p != fu2->f_p->fg_p )  {
d1240 1
a1240 1
			lu1, lu2, fu1->f_p->fg_p, fu2->f_p->fg_p);
d1242 1
a1242 1
		nmg_pr_fg(fu1->f_p->fg_p, 0);
d1246 1
a1246 1
		nmg_pr_fg(fu2->f_p->fg_p, 0);
d1250 1
a1250 1
		if( VDOT( fu1->f_p->fg_p->N, fu2->f_p->fg_p->N ) < 0 )
@


10.55
log
@Added GDurf's new "conf.h"
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 10.54 94/07/12 18:27:30 mike Exp Locker: mike $ (ARL)";
d44 1
a45 1
#include "machine.h"
@


10.54
log
@Sun-4 didn't like having a variable and a label both called 'out'.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 10.53 94/07/04 02:47:21 mike Exp Locker: mike $ (ARL)";
d41 1
@


10.53
log
@Hack to keep from hitting vertices and edges as often.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 10.52 94/07/03 23:23:46 mike Exp Locker: mike $ (ARL)";
d1290 1
a1290 1
	unsigned in, out, on;
d1350 1
a1350 1
	in = out = on = 0;
d1357 1
a1357 1
		case OUTSIDE	: ++out;
d1366 1
a1366 1
		rt_log("class_lu_vs_s: Loopuse edges in:%d on:%d out:%d\n", in, on, out);
d1368 1
a1368 1
	if (in > 0 && out > 0) {
d1370 1
a1370 1
		rt_log("Loopuse edges in:%d on:%d out:%d, turning on DEBUG_CLASSIFY\n", in, on, out);
d1408 1
a1408 1
	if (out > 0) {
@


10.52
log
@This version works even when faces are not shared.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 10.51 94/07/03 23:01:46 mike Exp Locker: mike $ (ARL)";
d236 9
a244 1
	code = rt_dist_pt3_lseg3( &dist, pca, eupt, matept, pt, tol);
@


10.51
log
@This version classifies shared faces correctly.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 10.50 94/07/03 22:34:12 mike Exp Locker: mike $ (ARL)";
d1232 14
a1245 1
		rt_bomb("nmg_2lu_identical() faces should have been fused\n");
@


10.50
log
@Improved readability of loop
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 10.49 94/07/03 22:01:14 mike Exp Locker: mike $ (ARL)";
d1157 4
d1187 1
a1187 1
	int			anti;
d1212 4
a1215 2
		if( eu1->vu_p->v_p != eu2->vu_p->v_p )  return 0;

d1221 4
a1224 2
	    *lu2->up.magic_p != NMG_FACEUSE_MAGIC )
		return 3;	/* one is a wire loop */
d1235 6
a1240 4
	rt_log("---- fu1, f=x%x, flip=%d\n", fu1->f_p, fu1->f_p->flip);
	nmg_pr_fu_briefly(fu1, 0);
	rt_log("---- fu2, f=x%x, flip=%d\n", fu2->f_p, fu2->f_p->flip);
	nmg_pr_fu_briefly(fu2, 0);
d1242 15
a1256 10
	/* If loopuse and faceuse and face orientations match,
	 * this is ON-shared */
	anti = 0;
	if( lu1->orientation != lu2->orientation )  anti = !anti;
	if( fu1->orientation != fu2->orientation )  anti = !anti;
	if( fu1->f_p->flip != fu2->f_p->flip ) anti = !anti;

	if( anti )
		return 2;
	return 1;
@


10.49
log
@Pulled out nmg_2lu_identical()
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 10.48 94/04/14 07:30:31 mike Exp Locker: mike $ (ARL)";
d1227 5
d1374 1
a1374 1
		reason = "all edgeuses were OUT";
d1379 1
a1379 1
		reason = "all edgeuses were IN";
d1416 5
a1420 2
	eu = eu->radial_p->eumate_p;
	do {
d1426 3
a1428 3
		if (*eu->up.magic_p == NMG_LOOPUSE_MAGIC && 
		    *eu->up.lu_p->up.magic_p == NMG_FACEUSE_MAGIC && 
		    eu->up.lu_p->up.fu_p->s_p == s ) {
d1430 1
a1430 29
		    	q_lu = eu->up.lu_p;
			code = nmg_2lu_identical( eu,
				RT_LIST_FIRST(edgeuse, &lu->down_hd) );
		    	switch(code)  {
		    	default:
		    	case 0:
		    		/* Not identical */
		    		break;
		    	case 1:
		    		/* ON-shared */
			    	NMG_INDEX_SET(classlist[NMG_CLASS_AonBshared],
			    		lu->l_p );
				if (rt_g.NMG_debug & DEBUG_CLASSIFY)
					rt_log("Loop is on-shared\n");
				reason = "edges identical with radial face, normals colinear";
		    		status = ON_SURF;
		    		goto out;
		    	case 2:
		    		/* ON-antishared */
				NMG_INDEX_SET(classlist[NMG_CLASS_AonBanti],
					lu->l_p );
				if (rt_g.NMG_debug & DEBUG_CLASSIFY)
					rt_log("Loop is on-antishared\n");
				reason = "edges identical with radial face, normals opposite";
				status = ON_SURF;
				goto out;
		    	case 3:
		    		rt_bomb("class_lu_vs_s() unexpected wire ON\n");
			}
d1432 30
d1463 1
a1463 2
		eu = eu->radial_p->eumate_p;
	} while (eu != RT_LIST_FIRST(edgeuse, &lu->down_hd) );
d1550 2
@


10.48
log
@Minor improvement in debug prints.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 10.47 94/04/13 04:48:01 mike Exp Locker: mike $ (ARL)";
d1157 1
d1159 81
d1254 1
d1256 1
d1263 5
a1267 2
	if( NMG_INDEX_TEST(classlist[NMG_CLASS_AinB], lu->l_p) )
		return(INSIDE);
d1269 5
a1273 2
	if( NMG_INDEX_TEST(classlist[NMG_CLASS_AonBshared], lu->l_p) )
		return(ON_SURF);
d1275 5
a1279 2
	if( NMG_INDEX_TEST(classlist[NMG_CLASS_AoutB], lu->l_p) )
		return(OUTSIDE);
d1284 1
d1301 2
a1302 1
		return(class);
d1369 3
a1371 1
		return(OUTSIDE);
d1374 3
a1376 1
		return(INSIDE);
d1382 1
a1382 1
		rt_log("\tAll edgeuses of loop are ON");
d1403 3
a1405 1
		return(ON_SURF);
d1413 2
d1422 28
a1449 12
			p = RT_LIST_FIRST(edgeuse, &lu->down_hd);
			q = eu;
			q_lu = q->up.lu_p;

			/* get the starting vertex of each edgeuse to be the
			 * same.
			 */
			if (q->vu_p->v_p != p->vu_p->v_p) {
				q = eu->eumate_p;
				if (q->vu_p->v_p != p->vu_p->v_p)
					rt_bomb("class_lu_vu_s: radial edgeuse doesn't share verticies\n");
			
a1451 38
		    	/* march around the two loops to see if they 
		    	 * are the same all the way around.
		    	 */
		/* XXX why isn't "p" also traversed circularly? */
		    	while (
		    	    RT_LIST_NOT_HEAD(p, &lu->down_hd) &&
			    p->vu_p->v_p == q->vu_p->v_p &&
			    q->up.lu_p == q_lu
			) {
				q = RT_LIST_PNEXT_CIRC(edgeuse, &q->l);
				p = RT_LIST_PNEXT(edgeuse, p);
			}

			if (!RT_LIST_NOT_HEAD(p, &lu->down_hd)) {
				vect_t	n, qn;

				/* the two loops are "on" each other.  All
				 * that remains is to determine
				 * shared/anti-shared status.
				 */
				NMG_CK_FACE_G(q_lu->up.fu_p->f_p->fg_p);
				NMG_GET_FU_NORMAL( qn, q_lu->up.fu_p );
				NMG_GET_FU_NORMAL( n, lu->up.fu_p );
				if (VDOT(qn, n) >= 0) {
				    	NMG_INDEX_SET(classlist[NMG_CLASS_AonBshared],
				    		lu->l_p );
					if (rt_g.NMG_debug & DEBUG_CLASSIFY)
						rt_log("Loop is on-shared\n");
				} else {
					NMG_INDEX_SET(classlist[NMG_CLASS_AonBanti],
						lu->l_p );
					if (rt_g.NMG_debug & DEBUG_CLASSIFY)
						rt_log("Loop is on-antishared\n");
				}

				return(ON_SURF);
			}

d1480 3
a1482 1
					return(INSIDE);
d1488 3
a1490 1
					return(OUTSIDE);
a1501 1
	
d1508 8
a1515 1
	return(OUTSIDE);
@


10.47
log
@Revised to use nmg_find_eu_leftvec()
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 10.46 94/04/13 04:29:28 mike Exp Locker: mike $ (ARL)";
d581 3
d644 2
a645 1
		rt_log("nmg_class_lu_fu\tdist=%g, return=%s\n",
@


10.46
log
@Fixed bug that John was trying for, but didn't quite get.
Made Test6.r work.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 10.45 94/04/08 14:00:38 jra Exp Locker: mike $ (ARL)";
d209 1
a209 3
	vect_t	norm,	/* plane normal */
		euvect,	/* vector of edgeuse */
		ptvec;	/* vector from lseg to pt */
d302 1
a302 3
	/* The point did not lie exactly ON the edge */
	/* calculate in/out */
	NMG_GET_FU_NORMAL(norm, eu->up.lu_p->up.fu_p);
a303 4
	VSUB2(euvect, matept, eupt);
    	if (rt_g.NMG_debug & DEBUG_CLASSIFY) VPRINT("\t\teuvect unnorm", euvect);
	VUNITIZE(euvect);

d308 1
a308 1
    	VCROSS( left, norm, euvect );	/* left vector */
@


10.45
log
@Fixed bug in nmg_classify_lu_lu
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 10.44 94/04/06 16:10:09 jra Exp Locker: jra $ (ARL)";
d276 1
a276 1
		rt_log("\t\tCloser. dist=%g (closest=%g), tol=%g\n",
a306 6
    	if (eu->up.lu_p->orientation == OT_OPPOSITE) {
    		if (rt_g.NMG_debug & DEBUG_CLASSIFY) rt_log("\t\tReversing normal\n");
		VREVERSE(norm,norm);
    	} else if (eu->up.lu_p->orientation != OT_SAME) {
    		rt_bomb("nmg_class_pt_e() bad lu orientation\n");
    	}
d403 1
a403 1
	if (rt_g.NMG_debug & DEBUG_CLASSIFY)
d405 1
d410 7
d1058 5
@


10.44
log
@FIxed bug in nmg_class_pt_e
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 10.43 94/04/06 15:39:28 jra Exp Locker: jra $ (ARL)";
d1613 1
d1615 1
d1632 1
d1634 5
a1638 2
		while( eu2_start->vu_p->v_p != eu1_start->vu_p->v_p &&
			RT_LIST_NOT_HEAD( eu2_start , &lu2->down_hd ) )
d1640 1
d1642 2
a1643 1
		if( eu1_start->vu_p->v_p == eu2_start->vu_p->v_p )
@


10.43
log
@Added code to nmg_classify_lu_lu to identify loops of same vertices.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 10.42 94/03/11 13:52:33 jra Exp Locker: jra $ (ARL)";
d307 1
a307 1
    	if (eu->up.lu_p->up.fu_p->orientation == OT_OPPOSITE) {
d310 2
a311 2
    	} else if (eu->up.lu_p->up.fu_p->orientation != OT_SAME) {
    		rt_bomb("nmg_class_pt_e() bad fu orientation\n");
@


10.42
log
@Fixed bug in nmg_classify_lu_lu.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 10.41 94/03/11 00:00:16 mike Exp Locker: jra $ (ARL)";
d1588 1
d1594 4
a1597 1
	if( lu1 == lu2 )
d1621 67
a1687 1
	/* find the closest approach in this face to the projected point */
@


10.41
log
@Fixed uninitialized "reason" string.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 10.40 94/03/09 19:22:01 mike Exp Locker: mike $ (ARL)";
d1631 1
d1646 6
@


10.40
log
@it's a nuissance to make a pointer to a typedef.
Got rid of "pt", and just use "vg->coord".
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 10.39 94/03/04 22:27:10 mike Exp Locker: mike $ (ARL)";
d1007 1
a1007 1
	char	*reason;
d1128 16
a1143 2
	NMG_INDEX_SET(classlist[NMG_CLASS_AinB], eu->e_p);
	status = INSIDE;
@


10.39
log
@Took out unnecessary warning message.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 10.38 94/03/04 22:07:49 mike Exp Locker: mike $ (ARL)";
d571 1
a571 1
	CONST fastf_t	*pt;
d600 2
a601 2
	NMG_CK_VERTEX_G(vu->v_p->vg_p);
	pt = vu->v_p->vg_p->coord;
d604 1
a604 1
		VPRINT("nmg_class_lu_fu\tPt:", pt);
d609 1
a609 1
	if( (dist=fabs(DIST_PT_PLANE( pt, n ))) > tol->dist )  {
d611 1
a611 1
			V3ARGS(pt), dist );
d634 1
a634 1
		nmg_class_pt_l( &closest, pt, lu2, tol );
@


10.38
log
@Fixed  problem in nmg_class_pt_e()'s handling of OT_OPPOSITE loops.  It
was incorrectly flipping the "left" vector.  Left vectors (normal cross
edge dir) always point towards the interior of a loop, for both
orientations.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 10.37 94/02/22 20:57:12 mike Exp Locker: mike $ (ARL)";
a418 4
	}
	if( lu->orientation != OT_SAME )  {
		/* Now what? */
		rt_log("nmg_class_pt_l(lu=x%x) WARNING orientation=%s\n", lu, nmg_orientation(lu->orientation) );
@


10.37
log
@Added nmg_class_pt_f_except().
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 10.36 94/02/22 20:43:00 mike Exp Locker: mike $ (ARL)";
d297 1
a297 1
    		goto out;
d319 2
a320 1
    	 * left, towards the interior of the CCW loop.
a322 6
	if(eu->up.lu_p->orientation == OT_OPPOSITE )  {
		if (rt_g.NMG_debug & DEBUG_CLASSIFY) rt_log("\t\tReversing left vec\n");
		VREVERSE(left, left);
	} else if(eu->up.lu_p->orientation != OT_SAME )  {
		rt_bomb("nmg_class_pt_e() bad lu orientation\n");
	}
d325 4
a328 1
    	if (rt_g.NMG_debug & DEBUG_CLASSIFY) VPRINT("\t\tptvec unnorm", ptvec);
d420 4
d924 2
a925 2
		if (*vup->up.magic_p == NMG_LOOPUSE_MAGIC &&
		    nmg_find_s_of_lu(vup->up.lu_p) == sB) {
d928 1
a928 1
		    	reason = "other loopuse of vertex is on shell";
d931 2
a932 3
		}
		else if (*vup->up.magic_p == NMG_EDGEUSE_MAGIC &&
		    nmg_find_s_of_eu(vup->up.eu_p) == sB) {
d935 1
a935 1
		    	reason = "other edgeuse of vertex is on shell";
d938 9
a981 1
		/* XXX what about corner of a cube touching inside the face of another cube? */
@


10.36
log
@Added debugging.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 10.35 94/02/10 18:47:35 mike Exp Locker: mike $ (ARL)";
d458 1
a458 1
 *			N M G _ C L A S S _ P T _ F
d468 4
d480 1
a480 1
nmg_class_pt_f(pt, fu, tol)
d483 1
d497 1
d513 3
d527 14
@


10.35
log
@Changed from EUPRINT to nmg_euprint() call.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 10.34 94/02/04 03:45:01 mike Exp Locker: mike $ (ARL)";
d152 4
a155 1
		} else rt_bomb("joint_hitmiss2: bad loop orientation\n");
@


10.34
log
@Only print warning message when debugging is on.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 10.33 94/02/03 21:34:03 mike Exp Locker: mike $ (ARL)";
d177 1
a177 1
		EUPRINT("Hard question time", eu);
d229 1
a229 1
		EUPRINT("          \tvs. eu", eu);
d980 1
a980 1
		EUPRINT("class_eu_vs_s\t", eu);
d1029 1
a1029 1
		    	EUPRINT("didn't this edge get cut?", eu);
d1085 1
a1085 1
			EUPRINT("Why wasn't this edge in or out?", eu);
d1198 1
a1198 1
					EUPRINT("In:  edgeuse", eu);
d1200 1
a1200 1
					EUPRINT("Out: edgeuse", eu);
d1202 1
a1202 1
					EUPRINT("On:  edgeuse", eu);
d1204 1
a1204 1
					EUPRINT("BAD: edgeuse", eu);
@


10.33
log
@Added checks for bad orientations.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 10.32 94/02/01 23:41:00 mike Exp Locker: mike $ (ARL)";
d602 4
a605 2
			rt_log("nmg_class_lu_fu(lu=x%x) WARNING:  skipping %s lu=x%x in fu=x%x!\n",
				lu, nmg_orientation(lu2->orientation), lu2, fu);
@


10.32
log
@Added nmg_class_lu_fu().
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
d304 1
a304 1
    	if (eu->up.lu_p->up.fu_p->orientation != OT_SAME) {
d307 2
d319 1
a319 1
	if(eu->up.lu_p->orientation != OT_SAME )  {
d322 2
d598 1
d602 2
a603 2
			rt_log("nmg_class_lu_fu() WARNING:  skipping %s lu=x%x in fu=x%x!\n",
				nmg_orientation(lu2->orientation), lu2, fu);
d1356 2
a1358 1

@


10.31
log
@Added nmg_classify_lu_lu and nmg_classify_pt_loop
@
text
@d25 2
a26 3
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
d28 5
d34 2
a35 2
 *	This software is Copyright (C) 1993 by the United States Army.
 *	All rights reserved.
d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 10.30 94/01/04 09:54:01 jra Exp Locker: jra $ (BRL)";
d507 110
@


10.30
log
@Fixed bug in nmg_class_pt_s (was marking face as seen too early).
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 10.29 93/12/03 03:35:18 mike Exp Locker: jra $ (BRL)";
d1356 129
@


10.29
log
@Access to plane equation / surface normal in face_geometry structure
is now done through macros NMG_GET_FU_PLANE() NMG_GET_FU_NORMAL(),
which honor the f->flip flag.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 10.28 93/10/22 22:27:43 mike Exp Locker: mike $ (BRL)";
d599 3
a603 3

		/* Only consider the outward pointing faceuses */
		if( fu->orientation != OT_SAME )  continue;
@


10.28
log
@nmg_eups() and nmg_lups() eliminated, in favor of
nmg_find_s_of_lu() and nmg_find_s_of_eu().

@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 10.27 93/10/20 01:38:22 mike Exp Locker: mike $ (BRL)";
d202 1
a202 1
	vect_t	N,	/* plane normal */
d299 1
a299 1
	VMOVE(N, eu->up.lu_p->up.fu_p->f_p->fg_p->N);
d302 1
a302 1
		VREVERSE(N,N);
d312 1
a312 1
    	VCROSS( left, N, euvect );	/* left vector */
d473 1
d484 2
a485 1
	if( (dist=fabs(DIST_PT_PLANE( pt, fu->f_p->fg_p->N ))) > tol->dist )  {
d594 2
d606 2
a607 1
		if( (dist = fabs(DIST_PT_PLANE(pt, fu->f_p->fg_p->N))) < tol->dist)  {
d643 2
d656 1
d658 1
a658 1
			fu->f_p->fg_p->N, tol);
d662 1
a662 1
			PLPRINT("\tplane", fu->f_p->fg_p->N);
d1178 1
d1185 3
a1187 2
				if (VDOT(q_lu->up.fu_p->f_p->fg_p->N,
				    lu->up.fu_p->f_p->fg_p->N) >= 0) {
d1267 1
d1272 2
d1275 1
a1275 1
        	PLPRINT("\nclass_fu_vs_s plane equation:", fu->f_p->fg_p->N);
@


10.27
log
@Changed nmg_class_pt_s() to try up to 10 different direction vectors before
declaring the case hopeless.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 10.26 93/05/20 17:13:25 mike Exp Locker: mike $ (BRL)";
d768 1
a768 1
		    nmg_lups(vup->up.lu_p) == sB) {
d776 1
a776 1
		    nmg_eups(vup->up.eu_p) == sB) {
d913 1
a913 1
			if (nmg_eups(eup) == s) {
@


10.26
log
@Changed rt_isect_ray_plane() to rt_isect_line3_plane().
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 10.25 93/05/15 00:01:19 mike Exp Locker: mike $ (BRL)";
a84 2
static CONST vect_t projection_dir = { 1.0, 0.0, 0.0 };

d507 13
d554 2
d560 7
a679 2
		 * XXX One strategy:  keep picking different directions until
		 * XXX no "hard" cases come up.  (Limit 10 per customer).
d687 8
d712 1
a712 1
	if (rt_g.NMG_debug & DEBUG_CLASSIFY)
d796 11
d1053 1
a1053 1
		rt_log("Loopuse edges in:%d on:%d out:%d\n", in, on, out);
d1057 1
a1057 1
		rt_log("Loopuse edges in:%d on:%d out:%d\n", in, on, out);
@


10.25
log
@Moved NMG_INDEX_CLEAR to nmg.h
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 10.24 93/04/07 05:54:49 mike Exp Locker: mike $ (BRL)";
d629 2
a630 2
		stat = rt_isect_ray_plane(&dist, pt, projection_dir,
			fu->f_p->fg_p->N);
d639 3
@


10.24
log
@#if'ed out the broken code.
The "hard" (i.e. no code implemented) joint_hitmiss2() stuff
has become an rt_bomb.
@
text
@a0 2
/* XXX Move to nmg.h */
#define NMG_INDEX_CLEAR(_tab,_p)		{(_tab)[(_p)->index] = 0;}
d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 10.23 93/03/27 02:11:30 mike Exp Locker: mike $ (BRL)";
@


10.23
log
@*** WARNING:  Revision 10.21 hosed something up, still not fixed.
@
text
@d36 1
a36 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 10.22 93/03/25 04:44:52 mike Exp Locker: mike $ (BRL)";
d173 1
d609 2
d625 1
@


10.22
log
@Eliminated stray continue;
@
text
@d36 1
a36 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 10.21 93/03/25 04:17:53 mike Exp Locker: mike $ (BRL)";
d619 3
@


10.21
log
@Changed nmg_class_pt_s() so that it searches all faces for an ON
condition before dropping into the ray tracing (Jordan Curve Theorem)
strategy, since (a) this is a more accurate way to answer the question,
and (b) the ray tracing isn't sophisticated enough to handle the
ray/edge classification question that can come up when the projected
(intersection) point is ON an edge.
@
text
@d36 1
a36 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 10.20 93/03/25 04:04:49 mike Exp Locker: mike $ (BRL)";
d602 1
a602 2
			/* Point is OUTside face, skip on. */
			continue;
@


10.20
log
@Efficiency measures.
Improved diagnostic printing.
Added warning about ray grazing an edge.
@
text
@d1 2
d36 1
a36 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 10.19 93/03/23 22:50:44 mike Exp Locker: mike $ (BRL)";
d569 3
d579 1
a579 1
		/* Only consider the outward pointing faces */
d609 16
a624 3
		/*
		 * Find point where ray hits the plane.
		 */
d648 7
a654 3
		 * XXX This really needs to be a ray/face classification
		 * XXX The ray can start outside, graze across an edge,
		 * XXX and keep going.
a661 1
			rt_log("nmg_class_pt_s: WARNING: ray grazed an edge, could be 1 hit (in/out) or 2 hits (in/in, out/out), can't tell which!\n");
d663 1
@


10.19
log
@Added extra arg to nmg_findeu()
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 10.18 93/03/22 23:06:51 mike Exp Locker: mike $ (BRL)";
d229 2
a230 3
	 * XXX Note here that "pca" will be one of the endpoints,
	 * except in the case of a near miss.
	 * Even if "pt" is far, far away.  This can be confusing.
d415 2
d496 2
d604 3
a606 1
		/* Find point where ray hits the plane */
d628 6
a633 1
		/* Construct coordinates of hit point, and classify. */
d635 2
d638 7
a644 1
		if( class != NMG_CLASS_AoutB )  hitcount++;
a650 2
	if (rt_g.NMG_debug & DEBUG_CLASSIFY)
		rt_log("nmg_class_pt_s:\t hitcount=%d\n", hitcount);
d658 2
a659 2
		rt_log("nmg_class_pt_s: returning %s\n",
			nmg_class_name(class) );
@


10.18
log
@Added some bug-hunt helper code.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 10.17 93/03/20 04:50:26 mike Exp Locker: mike $ (BRL)";
d867 1
a867 1
			eup = nmg_findeu( eu->vu_p->v_p, eu->eumate_p->vu_p->v_p, s, eu );
@


10.17
log
@Major overhaul of classifier.
nmg_class_pt_s() and nmg_class_pt_f() are now available for
general application programs to use.
class_eu_vs_s() now check for inconsistencies between topology and
geometry, rather than just making wrong decisions.
@
text
@d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 10.16 93/03/19 05:23:03 mike Exp Locker: mike $ (BRL)";
d863 8
@


10.16
log
@More debugging in pursuit of Bradley r5 "loop transits plane of face"
bug
@
text
@d4 2
a5 1
 *	NMG classifier code
d7 5
d13 8
a20 1
 *  Author -
d22 1
d30 1
a30 1
 *	This software is Copyright (C) 1989 by the United States Army.
d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 10.15 93/03/17 05:09:17 mike Exp Locker: mike $ (BRL)";
a46 6
/* XXX Move to vmath.h */
#define V3PT_IN_RPP(_pt, _lo, _hi)	( \
	(_pt)[X] >= (_lo)[X] && (_pt)[X] <= (_hi)[X] && \
	(_pt)[Y] >= (_lo)[Y] && (_pt)[Y] <= (_hi)[Y] && \
	(_pt)[Z] >= (_lo)[Z] && (_pt)[Z] <= (_hi)[Z]  )

d49 1
d59 2
a60 2
		struct vertexuse *vu;
		struct edgeuse *eu;
d62 3
a64 2
	fastf_t dist;	/* distance from point to neighbor */
	int inout;	/* what the neighbor thought about the point */
d67 5
a71 11
static void	joint_hitmiss2 RT_ARGS( (struct edgeuse	*eu, point_t pt,
			struct neighbor *closest, long *novote) );
static void	pt_hitmis_e RT_ARGS( (point_t pt, struct edgeuse *eu,
			struct neighbor	*closest, CONST struct rt_tol *tol,
			long *novote) );
static void	pt_hitmis_l RT_ARGS( (point_t pt, struct loopuse *lu,
			struct neighbor	*closest, CONST struct rt_tol *tol,
			long *novote) );
RT_EXTERN(int		nmg_pt_hitmis_f, (point_t pt, struct faceuse *fu,
			CONST struct rt_tol *tol, long *novote) );
static int	pt_inout_s RT_ARGS( (point_t pt, struct shell *s,
d73 3
d85 1
a85 1
static vect_t projection_dir = { 1.0, 0.0, 0.0 };
a86 3
#define FACE_HIT 256
#define FACE_MISS 512

d125 5
a129 5
static void joint_hitmiss2(eu, pt, closest, novote)
struct edgeuse	*eu;
point_t		pt;
struct neighbor *closest;
long		*novote;
d131 1
a131 4
	struct edgeuse *eu_rinf, *eu_r, *mate_r;
	struct edgeuse	*p;
	fastf_t	*N1, *N2;
	fastf_t PdotN1, PdotN2;
d136 1
a136 2
		EUPRINT("Easy question time", eu);
		VPRINT("Point", pt);
d147 1
a147 4
			closest->dist = 0.0;
			closest->p.eu = eu;
			closest->inout = FACE_HIT;
			if (rt_g.NMG_debug & DEBUG_CLASSIFY) rt_log("FACE_HIT\n");
d149 6
a154 1
			closest->dist = 0.0;
d156 11
a166 3
			closest->inout = FACE_MISS;
			if (rt_g.NMG_debug & DEBUG_CLASSIFY) rt_log("FACE_MISS\n");
		} else rt_bomb("joint_hitmiss2: bad loop orientation\n");
d170 4
a173 1
	if (rt_g.NMG_debug & (DEBUG_CLASSIFY|DEBUG_NMGRT) )
d175 5
a179 6

	rt_log("joint_hitmiss2: NO CODE HERE, assuming miss\n");
	rt_log(" eu_rinf=x%x, eu->eumate_p=x%x, eu=x%x\n", eu_rinf, eu->eumate_p, eu);
	rt_log(" eu lu orient=%s, eu_rinf lu orient=%s\n",
		nmg_orientation(eu->up.lu_p->orientation),
		nmg_orientation(eu_rinf->up.lu_p->orientation) );
d183 1
a183 1
 *			P T _ H I T M I S _ E
d185 5
a189 5
 *	Given a point and an edgeuse, determine if the point is
 *	closer to this edgeuse than anything it's been compared with
 *	before.  If it is, record how close the point is to the edgeuse
 *	and whether it is on the inside of the face area bounded by the
 *	edgeuse or on the outside of the face area.
d192 3
d196 5
a200 4
static void pt_hitmis_e(pt, eu, closest, tol, novote)
point_t		pt;
struct edgeuse	*eu;
struct neighbor	*closest;
a201 1
long		*novote;
d207 2
a208 1
	pointp_t eupt, matept;
d225 2
a226 2
		VPRINT("pt_hitmis_e\tProjected pt", pt);
		EUPRINT("          \tVS. eu", eu);
a239 6
	/* XXX Double check on dist to pca */
	VSUB2( ptvec, pt, pca );
	mag = MAGNITUDE(ptvec);
	if( fabs(dist - mag) > tol->dist )
		rt_log("ERROR! dist=%e |pt-pca|=%e, tol=%g, tol_sq=%g\n", dist, mag, tol->dist, tol->dist_sq);

d242 1
a242 1
			EUPRINT("\t\tskipping, earlier eu is closer", eu);
d249 2
a250 1
 		 *  If "closest" result so far was a FACE_HIT, then keep it,
d255 1
a255 1
		 *  processed first, the closest result will be FACE_MISS,
d259 2
a260 1
 		if( closest->inout == FACE_HIT )  {
d262 1
a262 1
				rt_log("\t\tSkipping, earlier eu at same dist, has HIT\n");
d266 1
a266 1
			rt_log("\t\tEarlier eu at same dist, had MISS, continue processing.\n");
d271 2
a272 2
		EUPRINT("\t\tcloser to edgeuse", eu);
		rt_log("\t\tdistance: %g (closest=%g)\n", dist, closest->dist);
d286 2
a287 2
		/* code==0:  The ray has hit the edge! */
		/* code==1 or 2:  The ray has hit a vertex! */
d289 1
a289 2
	    		rt_log("\t\tdistance: %e   tol: %g\n", dist, tol->dist);
    			rt_log("\t\tThe ray has hit the edge, calling joint_hitmiss2()\n");
d291 1
a291 1
    		joint_hitmiss2(eu, pt, closest, novote);
d295 1
a295 2
	    		rt_log("\t\tdistance: %g   tol: %g\n", dist, tol->dist);
    			rt_log("\t\tThe ray has missed the edge\n");
d299 1
d334 1
a334 1
		closest->inout = FACE_HIT;
d337 1
a337 1
	} else if (dot < 0.0) {
d340 1
a340 1
		closest->inout = FACE_MISS;
d375 1
a375 1
 *			P T _ H I T M I S _ L
d377 6
a382 2
 *	Given a point on the plane of the loopuse, determine if the point
 *	is in, or out of the area of the loop
d384 5
a388 4
static void pt_hitmis_l(pt, lu, closest, tol, novote)
point_t		pt;
struct loopuse	*lu;
struct neighbor	*closest;
a389 1
long		*novote;
d391 4
a394 4
	vect_t	delta;
	pointp_t lu_pt;
	fastf_t dist;
	struct edgeuse *eu;
a395 1
	char *name;
d403 1
a403 1
		VPRINT("pt_hitmis_l\tProjected Pt:", pt);
d408 1
a408 1
	if( !V3PT_IN_RPP( pt, lg->min_pt, lg->max_pt ) )  {
d415 1
a415 1
			pt_hitmis_e(pt, eu, closest, tol, novote);
a416 1

a419 1

d422 1
a422 4
		dist = MAGNITUDE(delta);

		if (dist < closest->dist) {

d424 1
a424 1
				closest->inout = FACE_HIT; name = "HIT";
d426 1
a426 1
				closest->inout = FACE_MISS; name = "MISS";
a427 1
				rt_log("bad orientation for face loopuse\n");
d429 1
a429 1
				rt_bomb("pt_hitmis_l: BAD NMG\n");
a430 1

d432 2
a433 4
				rt_log("point (%g, %g, %g) closer to lupt (%g, %g, %g)\n\tdist %g %s\n",
					pt[0], pt[1], pt[2],
					lu_pt[0], lu_pt[1], lu_pt[2],
					dist, name);
d439 1
a439 3
		rt_log("%s at %d bad child of loopuse\n", __FILE__,
			__LINE__);
		rt_bomb("pt_hitmis_l\n");
d442 2
a443 1
		rt_log("pt_hitmis_l	returning, closest=%g\n", closest->dist);
d447 1
a447 1
 *			P T _ H I T M I S _ F
d449 4
a452 2
 *	Given a face and a point on the plane of the face, determine if
 *	the point is in or out of the area bounded by the face.
d454 9
a462 3
 *	Explicit Return
 *		1	point is ON or IN the area of the face
 *		0	point is outside the area of the face
d465 3
a467 3
nmg_pt_hitmis_f(pt, fu, tol, novote)
point_t		pt;
struct faceuse	*fu;
a468 1
long		*novote;
d472 1
d475 1
a475 1
		VPRINT("nmg_pt_hitmis_f\tProjected Pt:", pt);
d477 4
a480 1
	/* XXX Should validate distance from point to plane */
d482 6
d491 1
a491 1
	closest.inout = 0;
d494 1
a494 1
		pt_hitmis_l(pt, lu, &closest, tol, novote);
d498 3
a500 2
		rt_log("nmg_pt_hitmis_f\tReturn=%s\n",
			closest.inout == FACE_HIT ? "HIT" : "MISS" );
d502 1
a502 6
	if (closest.inout == FACE_HIT) return(1);
	if( closest.inout == FACE_MISS ) return(0);
	/* No explicit results implies a miss */
	if (rt_g.NMG_debug & DEBUG_CLASSIFY)
		rt_log("nmg_pt_hitmis_f: no results.  Implies MISS\n");
	return 0;
d507 1
a507 1
 *			P T _ H I T M I S _ S
d509 13
a521 1
 *	returns status (inside/outside/on_surface) of pt WRT shell.
d523 4
a526 3
static pt_inout_s(pt, s, tol)
point_t pt;
struct shell *s;
d533 1
a533 1
	struct faceuse	*fu;
d535 1
a535 1
	long		*novote; /* faces that can't vote in a hit list */
d538 1
d540 1
d544 2
a545 1
		VPRINT("pt_inout_s: ", pt);
d547 1
a547 1
	if (! V3RPP_OVERLAP(s->sa_p->min_pt,s->sa_p->max_pt,pt,pt) )  {
d549 2
a550 3
			rt_log("	OUTSIDE, extents don't overlap\n");

		return(OUTSIDE);
d555 1
a555 1
	novote = (long *)rt_calloc( m->maxindex, sizeof(long), "pt_inout_s novote[]" );
d561 2
a562 1
		rt_log("\tPt=(%g, %g, %g) dir=(%g, %g, %g), reg_diam=%g\n", V3ARGS(pt), V3ARGS(projection_dir), region_diameter);
d564 3
a566 2
	fu = RT_LIST_FIRST(faceuse, &s->fu_hd);
	while (RT_LIST_NOT_HEAD(fu, &s->fu_hd)) {
d568 2
a569 6
		/* catch some (but not all) non-voters before they reach
		 * the polling booth
		 */
		if (nmg_dangling_face(fu)) {
			NMG_INDEX_SET(novote, fu->f_p);
/***			(void)nmg_tbl(&novote, TBL_INS, &fu->f_p->magic);**/
d571 2
a572 4
			if (RT_LIST_PNEXT(faceuse, fu) == fu->fumate_p)
				fu = RT_LIST_PNEXT_PNEXT(faceuse, fu);
			else
				fu = RT_LIST_PNEXT(faceuse, fu);
d574 21
d598 2
a599 9
		/* since the above block of code isn't the only place that
		 * faces get put in the list, we need this here too
		 */
/***		if (nmg_tbl(&novote, TBL_LOC, &fu->f_p->magic) >= 0)  ***/
		if( NMG_INDEX_TEST( novote, fu->f_p ) )  {
			if (RT_LIST_PNEXT(faceuse, fu) == fu->fumate_p)
				fu = RT_LIST_PNEXT_PNEXT(faceuse, fu);
			else
				fu = RT_LIST_PNEXT(faceuse, fu);
d601 1
a601 3
			continue;
		}

d610 2
a611 16
		if (stat >= 0 && dist >= 0) {
			/* compare extent of face to projection of pt on plane */
			if( dist > region_diameter )  {
				if (rt_g.NMG_debug & DEBUG_CLASSIFY)
					rt_log("\tpt_inout_s: hit plane outside region, skipping\n");
			} else if(
			    pt[Y] >= fu->f_p->fg_p->min_pt[Y] &&
			    pt[Y] <= fu->f_p->fg_p->max_pt[Y] &&
			    pt[Z] >= fu->f_p->fg_p->min_pt[Z] &&
			    pt[Z] <= fu->f_p->fg_p->max_pt[Z]) {
			    	/*
			    	 * XXX Above test assumes dir=1,0,0; omit X.
				 * translate point into plane of face and
			    	 * determine hit.
			    	 */
			    	VJOIN1(plane_pt, pt, dist,projection_dir);
d613 8
a620 9
				if (!nmg_dangling_face(fu)) {
					hitcount += nmg_pt_hitmis_f(plane_pt,
						fu, tol, novote);
				} else {
					if (rt_g.NMG_debug & DEBUG_CLASSIFY)
						rt_log("\tnon-manifold face\n");
					return(0);
				}
			}
d623 4
a626 4
		if (RT_LIST_PNEXT(faceuse, fu) == fu->fumate_p)
			fu = RT_LIST_PNEXT_PNEXT(faceuse, fu);
		else
			fu = RT_LIST_PNEXT(faceuse, fu);
d628 1
d630 2
a631 3
	rt_free( (char *)novote, "pt_inout_s novote[]" );

	/* if the hitcount is even, we're outside.  if it's odd, we're inside
d633 2
d636 3
a638 5
		if (rt_g.NMG_debug & DEBUG_CLASSIFY)
			rt_log("pt_inout_s: INSIDE. pt=(%g, %g, %g) hitcount: %d\n",
			pt[0], pt[1], pt[2], hitcount);

		return(INSIDE);
d640 1
a640 1

d642 3
a644 4
		rt_log("pt_inout_s: OUTSIDE. pt=(%g, %g, %g) hitcount: %d\n",
			pt[0], pt[1], pt[2], hitcount);

	return(OUTSIDE);
d663 1
d721 1
a721 1
	 *  We know that the vertex doesn't lie ON any of the faces or
d725 2
a726 2
	reason = "of pt_inout_s()";
	status = pt_inout_s(pt, sB, tol);
d728 1
a728 1
	if (status == OUTSIDE)  {
d730 2
a731 1
	}  else if (status == INSIDE)  {
d733 4
d738 1
a738 1
		rt_log("status=%d\n", status);
d740 1
a740 1
		rt_bomb("class_vu_vs_s: pt_inout_s() failure. Point neither IN or OUT?\n");
d766 1
d854 1
a854 1
		status = pt_inout_s(pt, s, tol);
d856 1
a856 1
		if (status == OUTSIDE)  {
d858 2
a859 1
		}  else if (status == INSIDE)  {
d861 3
d865 1
d867 1
a867 1
			rt_bomb("class_eu_vs_s\n");
d1183 4
d1199 2
d1205 1
a1205 1
		rt_log("class_shells - doing faces\n");
d1220 1
a1220 1
		rt_log("class_shells - doing loops\n");
d1235 1
a1235 1
		rt_log("class_shells - doing edges\n");
d1250 1
a1250 1
			rt_log("class_shells - doing vertex\n");
@


10.15
log
@Clarified message
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 10.14 93/03/17 03:18:32 mike Exp Locker: mike $ (BRL)";
d465 1
d649 15
a663 6
    if( !(rt_g.NMG_debug & DEBUG_CLASSIFY) )  {
	/* As an efficiency & consistency measure, check for vertex in class list */
	reason = "of classlist";
	if( NMG_INDEX_TEST(classlist[NMG_CLASS_AinB], vu->v_p) )  {
		status = INSIDE;
		goto out;
a665 11
	if( NMG_INDEX_TEST(classlist[NMG_CLASS_AonBshared], vu->v_p) )  {
		status = ON_SURF;
		goto out;
	}

	if( NMG_INDEX_TEST(classlist[NMG_CLASS_AoutB], vu->v_p) )  {
		status = OUTSIDE;
		goto out;
	}
    }

d730 2
a731 1
	int euv_cl, matev_cl, status;
d735 1
d738 1
a738 1
		EUPRINT("class_eu_vs_s\t\t", eu);
d742 1
d744 16
a759 10
	/* check to see if edge is already in one of the lists */
	if( NMG_INDEX_TEST(classlist[NMG_CLASS_AinB], eu->e_p) )
		return(INSIDE);

	if( NMG_INDEX_TEST(classlist[NMG_CLASS_AonBshared], eu->e_p) )
		return(ON_SURF);

	if( NMG_INDEX_TEST(classlist[NMG_CLASS_AoutB], eu->e_p) )
		return(OUTSIDE);

a796 1

d803 3
a805 3
				if (rt_g.NMG_debug & DEBUG_GRAPHCL)
					show_broken_stuff((long *)eu, classlist, nmg_class_nothing_broken, 0, (char *)NULL);
				return(ON_SURF);
a806 1

a815 1
		
a817 1

d821 1
a821 1
			VPRINT("Classifying midpoint of edge", pt);
d824 1
a824 1
	
d831 1
a831 1
			rt_bomb("class_eu_vs_s");
d833 1
a833 4

		if (rt_g.NMG_debug & DEBUG_GRAPHCL)
			show_broken_stuff((long *)eu, classlist, nmg_class_nothing_broken, 0, (char *)NULL);
		return(status);
d838 3
a840 3
		if (rt_g.NMG_debug & DEBUG_GRAPHCL)
			show_broken_stuff((long *)eu, classlist, nmg_class_nothing_broken, 0, (char *)NULL);
		return(OUTSIDE);
d843 2
d847 5
a851 1
	return(INSIDE);
d869 1
d873 1
d887 1
d910 1
d913 1
a913 1

a916 2
				if (rt_g.NMG_debug & DEBUG_CLASSIFY)
					EUPRINT("Edge is INSIDE", eu);
a918 2
				if (rt_g.NMG_debug & DEBUG_CLASSIFY)
					EUPRINT("Edge is OUTSIDE", eu);
a920 2
				if (rt_g.NMG_debug & DEBUG_CLASSIFY)
					EUPRINT("Edge is ON_SURF", eu);
d930 1
a930 1
		FILE *fd;
d932 9
a940 1
		if( rt_g.NMG_debug )  {
d943 1
a943 1
					fprintf(stderr, "In:  ");
d945 1
a945 1
					fprintf(stderr, "Out: ");
d947 1
a947 1
					fprintf(stderr, "On:  ");
d949 1
a949 2
					fprintf(stderr, "Unknown edge class? ");
				EUPRINT("edgeuse", eu);
d952 6
a957 10
			if ((fd=fopen("badloop.pl", "w")) != NULL) {
				long *b;
				struct model *m;

				m = nmg_find_model(lu->up.magic_p);
			
				b = (long *)rt_calloc(m->maxindex, sizeof(long), "nmg_pl_lu flag[]");

				nmg_pl_lu(fd, lu, b, 255, 255, 255);
				fclose(fd);
d961 1
d963 5
a967 1
		rt_bomb("class_lu_vs_s: loop transits plane of shell/face?\n");
@


10.14
log
@Added logic in pt_hitmiss_e() so that if a second distance was almost
exactly the same as the first, if the first one was a MISS,
try the second one, because it might be a HIT.
This fixed the problem with Test3.r
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 10.13 93/03/17 01:19:34 mike Exp Locker: mike $ (BRL)";
d163 1
a163 1
	rt_log("nmg intersection: assuming miss\n");
@


10.13
log
@Changed rt_dist_pt_lseg() to rt_dist_pt3_lseg3().
Return code is now a flag to indicate which of 6 cases have happened.
Distance is returned via a pointer instead.
Changed calling sequence, so name was changed.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 10.12 93/03/17 00:49:19 mike Exp Locker: mike $ (BRL)";
d230 2
a231 2
	if (dist >= closest->dist) {
		if (rt_g.NMG_debug & DEBUG_CLASSIFY) {
d233 1
a233 1
		}
d235 21
a255 1
	}
d273 3
a275 2
    	if (NEAR_ZERO(dist, tol->dist)) {
    		/* The ray has hit the edge! */
d349 2
a350 2
		nmg_pl_fu( fp, fu, bits, 0, 255, 0 );
		pl_color( fp, 255, 255, 0 );	/* yellow */
d389 1
a389 1
		VPRINT("pt_hitmis_loop\tProjected Pt:", pt);
d438 2
d775 1
a775 1
	    		rt_g.debug |= DEBUG_MATH;
@


10.12
log
@Added better debugging
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 10.11 93/03/16 06:59:38 mike Exp Locker: mike $ (BRL)";
d196 1
d217 2
a218 3
	dist = rt_dist_pt_lseg(pca, eupt, matept, pt, tol);
	if( dist < 0.0 )  rt_log("pt_hitmis_e: neg dist=%g?\n", dist);

d220 1
a220 1
		rt_log("          \tdist: %g\n", dist);
@


10.11
log
@Reworked pt_hitmiss_e() to be easier to read, have more
debugging, error checking, and plotting of each test.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 10.10 93/03/16 02:41:52 mike Exp Locker: mike $ (BRL)";
d31 1
d586 1
a586 1
			rt_log("	INSIDE face / pt (%g, %g, %g) hitcount: %d\n",
d593 1
a593 1
		rt_log("	OUTSIDE face / pt (%g, %g, %g) hitcount: %d\n",
d693 2
a694 2
		rt_log("  vertex class=%s because '%s'\n",
			nmg_class_status(status), reason );
d752 1
@


10.10
log
@Modified pt_inout_s() to ignore absurd hit points, i.e.
those where the hit distance is greater than the region diameter.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 10.9 93/03/16 02:10:12 mike Exp Locker: mike $ (BRL)";
d32 6
d149 1
d154 1
d178 1
a188 1
		plvec,	/* vector into face from edge */
d190 1
d200 2
d223 5
a227 1
	if (dist < closest->dist) {
d229 1
d231 1
a231 2
				EUPRINT("\t\tcloser to edgeuse", eu);
				rt_log("\t\tdistance: %g (closest=%g)\n", dist, closest->dist);
d233 2
d236 5
a240 2
		if (*eu->up.magic_p == NMG_LOOPUSE_MAGIC &&
		    *eu->up.lu_p->up.magic_p == NMG_FACEUSE_MAGIC) {
d242 9
a250 7
		    	if (NEAR_ZERO(dist, tol->dist)) {
		    		/* The ray has hit the edge! */
		    		if (rt_g.NMG_debug & DEBUG_CLASSIFY) {
			    		VPRINT("Vertex", pt);
			    		EUPRINT("hits edge, calling Joint_HitMiss", eu);
			    		rt_log("distance: %g   tol: %g\n", dist, tol->dist);
		    		}
d252 14
a265 9
		    		joint_hitmiss2(eu, pt, closest, novote);
		    		return;
		    	} else {
		    		if (rt_g.NMG_debug & DEBUG_CLASSIFY) {
			    		VPRINT("Vertex", pt);
			    		EUPRINT("Misses edge", eu);
			    		rt_log("distance: %g   tol: %g\n", dist, tol->dist);
		    		}
		    	}
d267 6
a272 6
			/* calculate in/out */
			VMOVE(N, eu->up.lu_p->up.fu_p->f_p->fg_p->N);
		    	if (eu->up.lu_p->up.fu_p->orientation != OT_SAME) {
				VREVERSE(N,N);
		    	}
			VSUB2(euvect, matept, eupt);
d274 3
a276 5
			mag = MAGSQ(euvect);
			while (mag < 1.0 && mag > 0.0) {
				VSCALE(euvect, euvect, 10.0);
				mag = MAGSQ(euvect);
			}
d278 8
a285 5
		    	/* Get vector which lies on the plane, and points
		    	 * left, towards the interior of the CCW loop.
		    	 */
		    	VCROSS( plvec, N, euvect );
			VSUB2(ptvec, pt, pca);
d287 3
a289 5
			mag = MAGSQ(ptvec);
			while (mag < 1.0 && mag > 0.0) {
				VSCALE(ptvec, ptvec, 10.0);
				mag = MAGSQ(ptvec);
			}
d291 6
a296 26
			dot = VDOT(plvec, ptvec);
			if (dot >= 0.0) {
				closest->dist = dist;
				closest->p.eu = eu;
				closest->inout = FACE_HIT;
			    	if (rt_g.NMG_debug & DEBUG_CLASSIFY)
			    		rt_log("\tHIT\n");
			} else if (dot < 0.0) {
				closest->dist = dist;
				closest->p.eu = eu;
				closest->inout = FACE_MISS;
			    	if (rt_g.NMG_debug & DEBUG_CLASSIFY)
			    		rt_log("\tMISS\n");
			}
		} else {
			if (rt_g.NMG_debug & DEBUG_CLASSIFY)
				rt_log("Trying to classify a pt (%g, %g, %g)\n\tvs a wire edge? (%g, %g, %g -> %g, %g, %g)\n",
					pt[0], pt[1], pt[2],
					eu->vu_p->v_p->vg_p->coord[0],
					eu->vu_p->v_p->vg_p->coord[1],
					eu->vu_p->v_p->vg_p->coord[2],
					eu->eumate_p->vu_p->v_p->vg_p->coord[0],
					eu->eumate_p->vu_p->v_p->vg_p->coord[1],
					eu->eumate_p->vu_p->v_p->vg_p->coord[2]
				);
		}
d298 12
d311 27
d358 1
d362 3
d372 5
a376 1
	
a437 4
	/* if this is a non-manifold (dangling) face of the shell, don't
	 * count any potential hit
	 */

d442 1
a442 2

	/* find the closest approach in this face to the point */
d445 1
d451 4
d456 5
a460 1
	return(0);
d555 3
a557 1
			    	/* translate point into plane of face and
@


10.9
log
@class_vu_vs_s() had a classlist[] cache check error.
Added more debugging
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 10.8 93/03/03 01:50:50 mike Exp Locker: mike $ (BRL)";
d199 5
d216 1
a216 1
				rt_log("\t\tdistance: %g\n", dist);
d424 2
d442 3
d447 1
a447 1
		VPRINT("\tFiring vector:", projection_dir);
d489 6
a494 3
			/* compare extent of face to projection of pt on plane
			*/
			if (pt[Y] >= fu->f_p->fg_p->min_pt[Y] &&
a510 2


a511 1

@


10.8
log
@Changed to V3RPP_OVERLAP, DIST_PT_PLANE
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 10.7 92/12/16 06:30:39 mike Exp Locker: mike $ (BRL)";
d76 7
a82 3
void
nmg_pr_class_status( prefix, status )
char	*prefix;
a84 2
	char	*str;

d87 1
a87 2
		str = "INSIDE";
		break;
d89 1
a89 2
		str = "OUTSIDE";
		break;
d91 1
a91 5
		str = "ON_SURF";
		break;
	default:
		str = "??unknown_code??";
		break;
d93 1
a93 1
	rt_log("%s has classification status %s\n", prefix, str);
d97 12
d543 2
a544 1
	int status;
d553 1
a553 1
		VPRINT("class_vu_vs_s ", pt);
d555 7
a561 3
	/* check for vertex presence in class list */
	if( NMG_INDEX_TEST(classlist[NMG_CLASS_AinB], vu->v_p) )
		return(INSIDE);
d563 4
a566 2
	if( NMG_INDEX_TEST(classlist[NMG_CLASS_AonBshared], vu->v_p) )
		return(ON_SURF);
d568 5
a572 2
	if( NMG_INDEX_TEST(classlist[NMG_CLASS_AinB], vu->v_p) )
		return(OUTSIDE);
a580 2

		    	/* it's ON_SURF */
d583 3
a585 4
			if (rt_g.NMG_debug & DEBUG_CLASSIFY)
		    		VPRINT("\tVertex is ON_SURF", pt);

			return(ON_SURF);
a588 1

d591 3
a593 4
			if (rt_g.NMG_debug & DEBUG_CLASSIFY)
		    		VPRINT("\tVertex is ON_SURF", pt);

			return(ON_SURF);
d602 1
a602 1
	 * relationsship to the shell.
d608 1
a608 1

d618 1
a618 1
		rt_bomb("class_vu_vs_s: Why wasn't this point in or out?\n");
d621 1
d623 2
a624 4
		if (status == OUTSIDE)
			VPRINT("Vertex is OUTSIDE ", pt);
		else if (status == INSIDE)
			VPRINT("Vertex is INSIDE ", pt);
a625 1

d665 13
d689 1
@


10.7
log
@Debug
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 10.6 1992/12/14 16:00:26 mike Exp mike $ (BRL)";
d417 1
a417 1
	if (! NMG_EXTENT_OVERLAP(s->sa_p->min_pt,s->sa_p->max_pt,pt,pt) )  {
@


10.6
log
@Reorganized sanity check to be more effictive.
XXX The code needs more scrutiny.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 10.5 92/08/06 00:38:43 mike Exp Locker: mike $ (BRL)";
d656 8
a663 9
	    	/* Do them over, so we can watch */
		rt_g.NMG_debug |= DEBUG_CLASSIFY;
		(void)class_vu_vs_s(eu->vu_p, s, classlist, tol);
		(void)class_vu_vs_s(eu->eumate_p->vu_p, s, classlist, tol);

	    	EUPRINT("didn't this edge get cut?", eu);
	    	nmg_pr_eu(eu, "  ");
		rt_bomb("class_eu_vs_s\n");
	    }
d665 3
d808 12
a819 11
		for(RT_LIST_FOR(eu, edgeuse, &lu->down_hd)) {
			if (NMG_INDEX_TEST(classlist[NMG_CLASS_AinB], eu->e_p))
				fprintf(stderr, "In:  ");
			else if (NMG_INDEX_TEST(classlist[NMG_CLASS_AoutB], eu->e_p))
				fprintf(stderr, "Out: ");
			else if (NMG_INDEX_TEST(classlist[NMG_CLASS_AonBshared], eu->e_p))
				fprintf(stderr, "On:  ");
			else
				fprintf(stderr, "Unknown edge class? ");
			EUPRINT("edgeuse", eu);
		}
d821 3
a823 3
		if ((fd=fopen("badloop.pl", "w")) != NULL) {
			long *b;
			struct model *m;
d825 1
a825 1
			m = nmg_find_model(lu->up.magic_p);
d827 1
a827 1
			b = (long *)rt_calloc(m->maxindex, sizeof(long), "nmg_pl_lu flag[]");
d829 5
a833 2
			nmg_pl_lu(fd, lu, b, 255, 255, 255);
			fclose(fd);
a834 2
		nmg_pr_lu(lu, "");
		nmg_stash_model_to_file( "class.g", nmg_find_model((long *)lu), "class_ls_vs_s: loop transits plane of shell/face?");
@


10.5
log
@When classifier makes error, dump current NMG into an outboard database
for examination.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 10.4 92/08/05 21:59:09 mike Exp Locker: mike $ (BRL)";
d897 6
a902 3
		    	while (p->vu_p->v_p == q->vu_p->v_p &&
			    q->up.lu_p == q_lu && /* sanity check */
		    	    RT_LIST_NOT_HEAD(p, &lu->down_hd) ) {
d911 1
a911 1
				 * shared/anit-shared status.
@


10.4
log
@Added more debugging when error is detected.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 10.3 92/07/20 23:05:24 butler Exp Locker: mike $ (BRL)";
d830 1
@


10.3
log
@fixed a bug in edgeuse classification.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 10.2 92/02/25 00:07:43 mike Exp Locker: butler $ (BRL)";
d829 1
a829 1

@


10.2
log
@Added nmg_pr_class_status(), and used it.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 10.1 91/10/12 06:40:41 mike Rel4_0 Locker: mike $ (BRL)";
d32 2
d645 1
a645 1
	if( NMG_INDEX_TEST(classlist[NMG_CLASS_AinB], eu->e_p) )
d675 2
d709 2
d716 2
d721 2
d752 1
a752 1
	if( NMG_INDEX_TEST(classlist[NMG_CLASS_AinB], lu->l_p) )
d804 1
d807 8
d818 13
a830 1
		rt_bomb("class_lu_vs_s: loop crosses face?\n");
@


10.1
log
@Release_4.0
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 1.13 91/06/29 22:13:57 mike Exp $ (BRL)";
d74 24
d652 7
d660 1
@


1.13
log
@ANSI lint
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 1.12 91/06/17 20:41:58 butler Exp $ (BRL)";
@


1.12
log
@changed function declarations so that all global functions have their
"nmg_" at the begining of the line.  Static functions have their function
names on the same line as the "static" modifier.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 1.11 91/06/04 13:50:12 butler Exp $ (BRL)";
a31 21
NMG_EXTERN(void		joint_hitmiss2, (struct edgeuse	*eu, point_t pt,
			struct neighbor *closest, long *novote) );
NMG_EXTERN(void		pt_hitmis_e, (point_t pt, struct edgeuse *eu,
			struct neighbor	*closest, CONST struct rt_tol *tol,
			long *novote) );
NMG_EXTERN(void		pt_hitmis_l, (point_t pt, struct loopuse *lu,
			struct neighbor	*closest, CONST struct rt_tol *tol,
			long *novote) );
NMG_EXTERN(int		nmg_pt_hitmis_f, (point_t pt, struct faceuse *fu,
			CONST struct rt_tol *tol, long *novote) );
NMG_EXTERN(int		pt_inout_s, (point_t pt, struct shell *s,
			CONST struct rt_tol *tol) );
NMG_EXTERN(int		class_vu_vs_s, (struct vertexuse *vu, struct shell *sB,
			long *classlist[4], CONST struct rt_tol	*tol) );
NMG_EXTERN(int		class_eu_vs_s, (struct edgeuse *eu, struct shell *s,
			long *classlist[4], CONST struct rt_tol	*tol) );
NMG_EXTERN(int		class_lu_vs_s, (struct loopuse *lu, struct shell *s,
			long *classlist[4], CONST struct rt_tol	*tol) );
NMG_EXTERN(void		class_fu_vs_s, (struct faceuse *fu, struct shell *s,
			long *classlist[4], CONST struct rt_tol	*tol) );

d48 21
d70 1
@


1.11
log
@changed calls to nmg_manifold_face to nmg_dangling_face
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 1.10 91/05/25 01:32:14 mike Exp $ (BRL)";
d944 2
a945 1
void nmg_class_shells(sA, sB, classlist, tol)
@


1.10
log
@Improved joint_hitmiss2().
In practice, this has eliminated "nmg intersection: assuming miss"
blowouts.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 1.9 91/05/23 00:20:04 mike Exp $ (BRL)";
d410 1
a410 1
		if (!nmg_manifold_face(fu)) {
d455 1
a455 1
				if (nmg_manifold_face(fu)) {
@


1.9
log
@Added tolerance parameters up and down the stack.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 1.8 91/05/18 03:02:06 mike Exp $ (BRL)";
d96 8
a103 2
	if (eu_rinf != eu->eumate_p && eu_rinf != eu &&
	    eu->up.lu_p->orientation == eu_rinf->up.lu_p->orientation ) {
a118 1

d120 4
a123 1
	return;
d165 1
d172 1
a172 1
	if (dist < closest->dist && dist >= 0.0) {
d183 1
@


1.8
log
@Converted to new tolerance interface
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 1.6 91/04/29 15:41:05 butler Exp $ (BRL)";
d32 21
d118 2
a119 1
/*	P T _ H I T M I S _ E
d246 2
a247 1
/*	P T _ H I T M I S _ L
d315 2
a316 1
/*	P T _ H I T M I S _ F
d357 2
a358 1
/*	P T _ H I T M I S _ S
d375 2
a379 1

d485 3
a487 1
/*	C L A S S _ V U _ V S _ S
d490 1
a490 1
static int class_vu_vs_s(vu, sB, classlist)
d494 1
d502 1
d559 1
a559 1
	status = pt_inout_s(pt, sB, 0.005);
d581 2
a582 1
/*	C L A S S _ E U _ V S _ S
d584 1
a584 1
static int class_eu_vs_s(eu, s, classlist)
d588 1
d611 2
a612 2
	euv_cl = class_vu_vs_s(eu->vu_p, s, classlist);
	matev_cl = class_vu_vs_s(eu->eumate_p->vu_p, s, classlist);
d651 1
a651 1
		status = pt_inout_s(pt, s, 0.005);
a664 1
	
d676 5
a680 4
static int class_lu_vs_s(lu, s, classlist)
struct loopuse	*lu;
struct shell	*s;
long		*classlist[4];
d706 1
a706 1
		class = class_vu_vs_s(vu, s, classlist);
d729 1
a729 1
		class = class_eu_vs_s(eu, s, classlist);
d910 5
a914 4
static void class_fu_vs_s(fu, s, classlist)
struct faceuse	*fu;
struct shell	*s;
long		*classlist[4];
d925 1
a925 1
		(void)class_lu_vs_s(lu, s, classlist);
d934 1
a934 1
void nmg_class_shells(sA, sB, classlist)
d938 1
d944 2
d953 1
a953 1
		class_fu_vs_s(fu, sB, classlist);
d968 1
a968 1
		(void)class_lu_vs_s(lu, sB, classlist);
d983 1
a983 1
		(void)class_eu_vs_s(eu, sB, classlist);
d994 1
a994 1
		(void)class_vu_vs_s(sA->vu_p, sB, classlist);
@


1.7
log
@Additions
@
text
@a88 3
	rt_log("nmg intersection: assuming miss\n");
	return;

d93 2
a94 11











d110 1
a110 1
fastf_t		tol;
d134 1
a134 1
	dist = rt_dist_pt_lseg(pca, eupt, matept, pt);
d151 1
a151 1
		    	if (NEAR_ZERO(dist, tol)) {
d155 1
a155 1
			    		rt_log("distance: %g   tol: %g\n", dist, tol);
d164 1
a164 1
			    		rt_log("distance: %g   tol: %g\n", dist, tol);
d233 1
a233 1
fastf_t		tol;
d305 1
a305 1
fastf_t		tol;
d340 1
a340 1
fastf_t tol;
a960 4




@


1.6
log
@can now ray-trace faces (but not edges)
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 1.5 91/04/01 20:02:00 mike Exp $ (BRL)";
d91 2
a92 2
/*	rt_bomb("joint_hitmiss2:  Dangerous stuff\n"); */
	if (rt_g.NMG_debug & DEBUG_CLASSIFY)
a94 14
	/*
	 *  For each pair of radially adjacent interior faceloops in this
	 * shell, compute a hit/miss
	 */
	if (eu->up.lu_p->up.fu_p->orientation == OT_SAME)
		eu = eu->eumate_p;
	p = eu;
/*	do { */
		/* get a pair of edges whose face enclose space */
		eu_r = p->radial_p;
		while ((*eu_r->up.magic_p != NMG_LOOPUSE_MAGIC ||
		   *eu_r->up.lu_p->up.magic_p != NMG_FACEUSE_MAGIC ||
		   eu_r->up.lu_p->up.fu_p->orientation != OT_OPPOSITE ||
		   eu_r->up.lu_p->up.fu_p->s_p != eu->up.lu_p->up.fu_p->s_p ||
a95 2
/* XXX this was		nmg_tbl(novote, TBL_LOC, (long *)&eu_r) >= 0 ***/
/* XXX was this right, or should it have been  eu_r->up.lu_p->up.fu_p->f_p ***/
a96 3
		   NMG_INDEX_TEST(novote, eu_r)
		   ) && eu_r != eu->eumate_p)
			eu_r = eu_r->eumate_p->radial_p;
a97 4
		if (eu_r == eu->eumate_p) {
			/* only radial edge/face is planar with projection vector */
			rt_bomb("joint_hitmiss2: bogus Dewd, Non-Manifold on the radial edge!\n");
		}
a98 2
		N1 = eu->up.lu_p->up.fu_p->f_p->fg_p->N;
		N2 = eu_r->up.lu_p->up.fu_p->f_p->fg_p->N;
a99 2
		PdotN1 = VDOT(N1, projection_dir);
		PdotN2 = VDOT(N2, projection_dir);
d101 6
a106 14
		if ( ((PdotN1 > 0) && (PdotN2 > 0)) ||
		     ((PdotN1 < 0) && (PdotN2 < 0)) ) {
				closest->dist = 0.0;
				closest->p.eu = eu;
				closest->inout = FACE_HIT;
	     		/* record both faces as prev intersected with ray */
		} else if ( ((PdotN1 > 0) && (PdotN2 < 0)) ||
		     ((PdotN1 < 0) && (PdotN2 > 0)) ) {
				closest->dist = 0.0;
				closest->p.eu = eu;
				closest->inout = FACE_MISS;
		     	/* record both faces as prev intersected with ray */
		}
/*	} while (0);*/
@


1.5
log
@Edges of loops now travel in a counter-clockwise (CCW) direction
around the face normal.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 1.4 91/03/01 22:40:50 mike Exp $ (BRL)";
d89 3
a91 1
	rt_bomb("joint_hitmiss2:  Dangerous stuff\n");
d106 4
a109 3
		    *eu_r->up.lu_p->up.magic_p != NMG_FACEUSE_MAGIC ||
		    eu_r->up.lu_p->up.fu_p->orientation != OT_OPPOSITE ||
		    eu_r->up.lu_p->up.fu_p->s_p != eu->up.lu_p->up.fu_p->s_p ||
d112 3
a114 2
		    NMG_INDEX_TEST(novote, eu_r)
		    ) && eu_r != eu->eumate_p)
d144 1
a144 1
/*	P T _ I N O U T _ E
d216 4
a219 1
			VMOVE(N, eu->up.lu_p->up.fu_p->f_p->fg_p->N);	
d271 1
a271 1
/*	P T _ I N O U T _ L
d339 1
a339 1
/*	P T _ I N O U T _ F
d348 2
a349 1
static int pt_hitmis_f(pt, fu, tol, novote)
d363 1
a363 1
		VPRINT("pt_hitmis_f\tProjected Pt:", pt);
a364 5
	if (!nmg_manifold_face(fu)) {
		if (rt_g.NMG_debug & DEBUG_CLASSIFY)
			rt_log("\tnon-manifold face\n");
		return(0);
	}
d380 1
a380 1
/*	P T _ I N O U T _ S
d465 11
a475 2
				hitcount += pt_hitmis_f(plane_pt, fu, tol,
						novote);
d1008 4
@


1.4
log
@Converted classification routines from nmg_ptbl to index array strategy.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 1.3 91/03/01 20:06:29 mike Exp $ (BRL)";
d221 4
a224 3
			/* get vector in the plane */
			VCROSS(plvec, euvect, N);
		
@


1.3
log
@Converted "novote" stuff from a ptbl to an array of flags.
This code seems to have always been in error, because SET operations
are done on faces, and TEST operations are done on edgeuses.  ???
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 1.2 91/02/07 20:32:32 mike Exp $ (BRL)";
d497 3
a499 3
struct vertexuse *vu;
struct shell *sB;
struct nmg_ptbl classlist[4];
d514 1
a514 1
	if (nmg_tbl(&classlist[NMG_CLASS_AinB], TBL_LOC, &vu->v_p->magic) >= 0)
d517 1
a517 1
	if (nmg_tbl(&classlist[NMG_CLASS_AonBshared], TBL_LOC, &vu->v_p->magic) >= 0)
d520 1
a520 1
	if (nmg_tbl(&classlist[NMG_CLASS_AinB], TBL_LOC, &vu->v_p->magic) >= 0)
d532 2
a533 1
		    	(void)nmg_tbl(&classlist[NMG_CLASS_AonBshared], TBL_INS, &vu->v_p->magic);
d542 2
a543 1
		    	(void)nmg_tbl(&classlist[NMG_CLASS_AonBshared], TBL_INS, &vu->v_p->magic);
d565 5
a569 5
	if (status == OUTSIDE)
		(void)nmg_tbl(&classlist[NMG_CLASS_AoutB], TBL_INS, &vu->v_p->magic);
	else if (status == INSIDE)
		(void)nmg_tbl(&classlist[NMG_CLASS_AinB], TBL_INS, &vu->v_p->magic);
	else  {
d588 3
a590 3
struct edgeuse *eu;
struct shell *s;
struct nmg_ptbl classlist[4];
d604 1
a604 1
	if (nmg_tbl(&classlist[NMG_CLASS_AinB], TBL_LOC, &eu->e_p->magic) >= 0)
d607 1
a607 1
	if (nmg_tbl(&classlist[NMG_CLASS_AonBshared], TBL_LOC, &eu->e_p->magic) >= 0)
d610 1
a610 1
	if (nmg_tbl(&classlist[NMG_CLASS_AinB], TBL_LOC, &eu->e_p->magic) >= 0)
d630 2
a631 1
			    	(void)nmg_tbl(&classlist[NMG_CLASS_AonBshared], TBL_INS, &eu->e_p->magic);
d655 5
a659 5
		if (status == OUTSIDE)
			(void)nmg_tbl(&classlist[NMG_CLASS_AoutB], TBL_INS, &eu->e_p->magic);
		else if (status == INSIDE)
			(void)nmg_tbl(&classlist[NMG_CLASS_AinB], TBL_INS, &eu->e_p->magic);
		else {
d669 1
a669 1
	    	(void)nmg_tbl(&classlist[NMG_CLASS_AoutB], TBL_INS, &eu->e_p->magic);
d672 1
a672 1
    	(void)nmg_tbl(&classlist[NMG_CLASS_AinB], TBL_INS, &eu->e_p->magic);
d676 3
a678 1

d680 3
a682 3
struct loopuse *lu;
struct shell *s;
struct nmg_ptbl classlist[4];
d695 1
a695 1
	if (nmg_tbl(&classlist[NMG_CLASS_AinB], TBL_LOC, &lu->l_p->magic) >= 0)
d698 1
a698 1
	if (nmg_tbl(&classlist[NMG_CLASS_AonBshared], TBL_LOC, &lu->l_p->magic) >= 0)
d701 1
a701 1
	if (nmg_tbl(&classlist[NMG_CLASS_AinB], TBL_LOC, &lu->l_p->magic) >= 0)
d710 11
a720 7
		case INSIDE	: (void)nmg_tbl(&classlist[NMG_CLASS_AinB], TBL_INS, &lu->l_p->magic);
				  break;
		case OUTSIDE	: (void)nmg_tbl(&classlist[NMG_CLASS_AoutB], TBL_INS, &lu->l_p->magic);
				  break;
		case ON_SURF	: (void)nmg_tbl(&classlist[NMG_CLASS_AonBshared], TBL_INS, &lu->l_p->magic);
				  break;
		default		: rt_bomb("class_lu_vs_s: bad vertexloop classification\n");
d761 1
a761 1
		(void)nmg_tbl(&classlist[NMG_CLASS_AoutB], TBL_INS, &lu->l_p->magic);
d764 1
a764 1
		(void)nmg_tbl(&classlist[NMG_CLASS_AinB], TBL_INS, &lu->l_p->magic);
d771 1
a771 1
		rt_log("\tAll edgeuses of loop are on");
d791 1
a791 1
		(void)nmg_tbl(&classlist[NMG_CLASS_AonBshared], TBL_INS, &lu->l_p->magic);
d840 2
a841 2
					(void)nmg_tbl(&classlist[NMG_CLASS_AonBshared],
						TBL_INS, &lu->l_p->magic);
d845 2
a846 2
					(void)nmg_tbl(&classlist[NMG_CLASS_AonBanti],
						TBL_INS, &lu->l_p->magic);
d878 2
a879 1
					(void)nmg_tbl(&classlist[NMG_CLASS_AinB], TBL_INS, &lu->l_p->magic);
d884 2
a885 1
					(void)nmg_tbl(&classlist[NMG_CLASS_AoutB], TBL_INS, &lu->l_p->magic);
d905 1
a905 1
	(void)nmg_tbl(&classlist[NMG_CLASS_AoutB], TBL_INS, &lu->l_p->magic);
d913 3
a915 3
struct faceuse *fu;
struct shell *s;
struct nmg_ptbl classlist[4];
d936 3
a938 2
struct shell *sA, *sB;
struct nmg_ptbl classlist[4];
a942 2


@


1.2
log
@Changed from NMG_LIST macros to RT_LIST macros, from rtlist.h
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_class.c,v 1.1 90/12/08 03:47:48 mike Exp $ (BRL)";
d59 2
a60 2
struct edgeuse *eu;
point_t pt;
d62 1
a62 1
struct nmg_ptbl *novote;
d85 1
a85 1
		} else rt_bomb("bad loop orientation\n");
d89 1
a89 1
	rt_bomb("Dangerous stuff\n");
d107 4
a110 2
		    nmg_tbl(novote, TBL_LOC, (long *)&eu_r) >= 0) &&
		    eu_r != eu->eumate_p)
d115 1
a115 1
			rt_bomb("bogus Dewd, Non-Manifold on the radial edge!\n");
d150 5
a154 5
point_t pt;
struct edgeuse *eu;
struct neighbor *closest;
fastf_t tol;
struct nmg_ptbl *novote;
d269 5
a273 5
point_t pt;
struct loopuse *lu;
struct neighbor *closest;
fastf_t tol;
struct nmg_ptbl *novote;
d312 1
a312 1
				rt_bomb("BAD NMG\n");
d341 4
a344 4
point_t pt;
struct faceuse *fu;
fastf_t tol;
struct nmg_ptbl *novote;
d385 7
a391 6
	int hitcount = 0;
	int stat;
	fastf_t dist;
	point_t plane_pt;
	struct faceuse *fu;
	struct nmg_ptbl novote;	/* list of faces that can't vote in a hit list */
d404 4
a407 1
	(void)nmg_tbl(&novote, TBL_INIT, (long *)NULL);
d418 2
a419 1
			(void)nmg_tbl(&novote, TBL_INS, &fu->f_p->magic);
d432 2
a433 1
		if (nmg_tbl(&novote, TBL_LOC, &fu->f_p->magic) >= 0) {
d462 1
a462 1
						&novote);
d473 1
a473 1
	(void)nmg_tbl(&novote, TBL_FREE, (long *)NULL);
d570 1
a570 1
		rt_bomb("Why wasn't this point in or out?\n");
d711 1
a711 1
		default		: rt_bomb("bad vertexloop classification\n");
d715 1
a715 1
		rt_bomb("bad child of loopuse\n");
d736 1
a736 1
		default		: rt_bomb("bad class for edgeuse\n");
d749 1
a749 1
		rt_bomb("loop crosses face?\n");
d758 1
a758 1
		rt_bomb("alright, who's the wiseguy that stole my edgeuses?\n");
d808 1
a808 1
					rt_bomb("radial edgeuse doesn't share verticies\n");
@


1.1
log
@Initial revision
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_bool.c,v 1.28 90/12/08 03:26:12 mike Exp $ (BRL)";
d288 2
a289 2
	if (NMG_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_EDGEUSE_MAGIC) {
		for (NMG_LIST(eu, edgeuse, &lu->down_hd)) {
d293 1
a293 1
	} else if (NMG_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC) {
d295 1
a295 1
		vu = NMG_LIST_FIRST(vertexuse, &lu->down_hd);
d365 1
a365 1
	for (NMG_LIST(lu, loopuse, &fu->lu_hd)) {
d405 2
a406 2
	fu = NMG_LIST_FIRST(faceuse, &s->fu_hd);
	while (NMG_LIST_MORE(fu, faceuse, &s->fu_hd)) {
d414 2
a415 2
			if (NMG_LIST_PNEXT(faceuse, fu) == fu->fumate_p)
				fu = NMG_LIST_PNEXT_PNEXT(faceuse, fu);
d417 1
a417 1
				fu = NMG_LIST_PNEXT(faceuse, fu);
d426 2
a427 2
			if (NMG_LIST_PNEXT(faceuse, fu) == fu->fumate_p)
				fu = NMG_LIST_PNEXT_PNEXT(faceuse, fu);
d429 1
a429 1
				fu = NMG_LIST_PNEXT(faceuse, fu);
d459 2
a460 2
		if (NMG_LIST_PNEXT(faceuse, fu) == fu->fumate_p)
			fu = NMG_LIST_PNEXT_PNEXT(faceuse, fu);
d462 1
a462 1
			fu = NMG_LIST_PNEXT(faceuse, fu);
d518 1
a518 1
	for(NMG_LIST(vup, vertexuse, &vu->v_p->vu_hd)) {
d691 1
a691 1
	magic1 = NMG_LIST_FIRST_MAGIC( &lu->down_hd );
d693 1
a693 1
		vu = NMG_LIST_PNEXT( vertexuse, &lu->down_hd );
d712 1
a712 1
	for (NMG_LIST(eu, edgeuse, &lu->down_hd)) {
d737 1
a737 1
		for(NMG_LIST(eu, edgeuse, &lu->down_hd)) {
d780 1
a780 1
	eu = NMG_LIST_FIRST(edgeuse, &lu->down_hd);
d790 1
a790 1
			p = NMG_LIST_FIRST(edgeuse, &lu->down_hd);
d809 3
a811 3
		    	    NMG_LIST_MORE(p, edgeuse, &lu->down_hd) ) {
				q = NMG_LIST_PNEXT_CIRC(edgeuse, &q->l);
				p = NMG_LIST_PNEXT(edgeuse, p);
d814 1
a814 1
			if (!NMG_LIST_MORE(p, edgeuse, &lu->down_hd)) {
d839 1
a839 1
	} while (eu != NMG_LIST_FIRST(edgeuse, &lu->down_hd) );
d852 1
a852 1
	for (NMG_LIST(eu, edgeuse, &lu->down_hd)) {
d906 1
a906 1
	for (NMG_LIST(lu, loopuse, &fu->lu_hd))
d927 1
a927 1
	    NMG_LIST_NON_EMPTY(&sA->fu_hd))
d930 2
a931 2
	fu = NMG_LIST_FIRST(faceuse, &sA->fu_hd);
	while (NMG_LIST_MORE(fu, faceuse, &sA->fu_hd)) {
d935 2
a936 2
		if (NMG_LIST_PNEXT(faceuse, fu) == fu->fumate_p)
			fu = NMG_LIST_PNEXT_PNEXT(faceuse, fu);
d938 1
a938 1
			fu = NMG_LIST_PNEXT(faceuse, fu);
d942 1
a942 1
	    NMG_LIST_NON_EMPTY(&sA->lu_hd))
d945 2
a946 2
	lu = NMG_LIST_FIRST(loopuse, &sA->lu_hd);
	while (NMG_LIST_MORE(lu, loopuse, &sA->lu_hd)) {
d950 2
a951 2
		if (NMG_LIST_PNEXT(loopuse, lu) == lu->lumate_p)
			lu = NMG_LIST_PNEXT_PNEXT(loopuse, lu);
d953 1
a953 1
			lu = NMG_LIST_PNEXT(loopuse, lu);
d957 1
a957 1
	    NMG_LIST_NON_EMPTY(&sA->eu_hd))
d960 2
a961 2
	eu = NMG_LIST_FIRST(edgeuse, &sA->eu_hd);
	while (NMG_LIST_MORE(eu, edgeuse, &sA->eu_hd)) {
d965 2
a966 2
		if (NMG_LIST_PNEXT(edgeuse, eu) == eu->eumate_p)
			eu = NMG_LIST_PNEXT_PNEXT(edgeuse, eu);
d968 1
a968 1
			eu = NMG_LIST_PNEXT(edgeuse, eu);
@
