head	11.26;
access;
symbols
	ansi-20040405-merged:11.22.2.2
	postmerge-20040405-ansi:11.24
	premerge-20040404-ansi:11.23
	postmerge-autoconf:11.23
	autoconf-freeze:11.22.10.2
	premerge-autoconf:11.23
	ansi-20040316-freeze:11.22.2.1
	postmerge-20040315-windows:11.23
	premerge-20040315-windows:11.23
	windows-20040315-freeze:11.22.4.1
	autoconf-20031203:11.22
	autoconf-20031202:11.22
	autoconf-branch:11.22.0.10
	phong-branch:11.22.0.8
	photonmap-branch:11.22.0.6
	rel-6-1-DP:11.22
	windows-branch:11.22.0.4
	rel-6-0-2:11.20
	ansi-branch:11.22.0.2
	rel-6-0-1-branch:11.20.0.2
	hartley-6-0-post:11.21
	hartley-6-0-pre:11.20
	rel-6-0-1:11.20
	rel-6-0:11.20
	rel-5-4:11.17
	offsite-5-3-pre:11.19
	rel-5-3:11.17
	rel-5-2:11.17
	rel-5-1-branch:11.17.0.2
	rel-5-1:11.17
	rel-5-0:11.15
	rel-5-0-beta:11.14
	rel-4-5:11.13
	ctj-4-5-post:11.13
	ctj-4-5-pre:11.13
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.26
date	2004.05.21.18.07.33;	author morrison;	state dead;
branches;
next	11.25;

11.25
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.24;

11.24
date	2004.04.05.08.48.57;	author morrison;	state Exp;
branches;
next	11.23;

11.23
date	2004.02.02.17.39.24;	author morrison;	state Exp;
branches;
next	11.22;

11.22
date	2002.08.20.17.08.04;	author jra;	state Exp;
branches
	11.22.2.1
	11.22.4.1
	11.22.10.1;
next	11.21;

11.21
date	2002.08.15.20.55.15;	author hartley;	state Exp;
branches;
next	11.20;

11.20
date	2001.04.20.22.29.51;	author morrison;	state Exp;
branches;
next	11.19;

11.19
date	2000.08.21.02.02.32;	author butler;	state Exp;
branches;
next	11.18;

11.18
date	2000.07.10.23.01.42;	author mike;	state Exp;
branches;
next	11.17;

11.17
date	99.12.30.15.31.36;	author jra;	state Exp;
branches;
next	11.16;

11.16
date	99.11.24.21.44.30;	author mike;	state Exp;
branches;
next	11.15;

11.15
date	99.06.03.01.01.26;	author mike;	state Exp;
branches;
next	11.14;

11.14
date	99.05.11.19.08.25;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	96.10.21.19.10.42;	author jra;	state Exp;
branches;
next	11.12;

11.12
date	96.09.27.08.27.30;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	96.07.12.12.17.41;	author jra;	state Exp;
branches;
next	11.10;

11.10
date	95.12.02.03.09.46;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	95.03.02.14.30.16;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	95.02.28.04.17.12;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	95.02.26.06.25.43;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	95.02.25.02.54.38;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	95.02.25.02.27.21;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	95.02.07.03.58.07;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	95.02.06.23.02.36;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	95.01.25.15.25.46;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.57.51;	author mike;	state Rel4_4;
branches;
next	10.36;

10.36
date	94.09.16.23.36.58;	author mike;	state Exp;
branches;
next	10.35;

10.35
date	94.09.02.00.32.10;	author mike;	state Exp;
branches;
next	10.34;

10.34
date	94.08.10.18.53.40;	author gdurf;	state Exp;
branches;
next	10.33;

10.33
date	94.08.09.19.38.06;	author mike;	state Exp;
branches;
next	10.32;

10.32
date	94.07.06.16.24.32;	author jra;	state Exp;
branches;
next	10.31;

10.31
date	94.04.20.20.48.36;	author mike;	state Exp;
branches;
next	10.30;

10.30
date	94.04.20.20.13.19;	author mike;	state Exp;
branches;
next	10.29;

10.29
date	94.04.13.04.31.01;	author mike;	state Exp;
branches;
next	10.28;

10.28
date	94.03.17.23.38.49;	author mike;	state Exp;
branches;
next	10.27;

10.27
date	94.03.02.18.59.07;	author mike;	state Exp;
branches;
next	10.26;

10.26
date	94.02.10.18.47.45;	author mike;	state Exp;
branches;
next	10.25;

10.25
date	94.02.01.23.22.31;	author mike;	state Exp;
branches;
next	10.24;

10.24
date	94.01.27.05.25.29;	author mike;	state Exp;
branches;
next	10.23;

10.23
date	94.01.25.06.59.53;	author mike;	state Exp;
branches;
next	10.22;

10.22
date	94.01.25.06.13.06;	author mike;	state Exp;
branches;
next	10.21;

10.21
date	94.01.13.20.20.47;	author mike;	state Exp;
branches;
next	10.20;

10.20
date	93.12.16.05.34.32;	author mike;	state Exp;
branches;
next	10.19;

10.19
date	93.12.03.03.35.32;	author mike;	state Exp;
branches;
next	10.18;

10.18
date	93.09.15.02.35.18;	author mike;	state Exp;
branches;
next	10.17;

10.17
date	93.08.19.00.07.28;	author mike;	state Exp;
branches;
next	10.16;

10.16
date	93.08.18.21.29.19;	author mike;	state Exp;
branches;
next	10.15;

10.15
date	93.08.13.15.23.59;	author mike;	state Exp;
branches;
next	10.14;

10.14
date	93.08.13.14.39.29;	author mike;	state Exp;
branches;
next	10.13;

10.13
date	93.08.12.22.58.01;	author mike;	state Exp;
branches;
next	10.12;

10.12
date	93.08.12.21.44.03;	author mike;	state Exp;
branches;
next	10.11;

10.11
date	93.07.24.02.16.31;	author mike;	state Exp;
branches;
next	10.10;

10.10
date	93.07.24.00.57.58;	author mike;	state Exp;
branches;
next	10.9;

10.9
date	93.07.23.20.30.51;	author mike;	state Exp;
branches;
next	10.8;

10.8
date	93.03.24.02.25.53;	author mike;	state Exp;
branches;
next	10.7;

10.7
date	93.03.22.23.10.59;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	93.03.12.20.32.21;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	93.03.11.06.20.15;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	93.03.03.01.51.07;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	93.02.09.00.39.02;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	92.12.14.15.34.28;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.40.46;	author mike;	state Rel4_0;
branches;
next	1.4;

1.4
date	91.06.17.20.42.07;	author butler;	state Exp;
branches;
next	1.3;

1.3
date	91.04.03.02.30.10;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	91.02.07.20.32.38;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	90.12.08.03.08.51;	author mike;	state Exp;
branches;
next	;

11.22.2.1
date	2002.09.19.18.01.40;	author morrison;	state Exp;
branches;
next	11.22.2.2;

11.22.2.2
date	2004.03.17.21.18.53;	author morrison;	state Exp;
branches;
next	;

11.22.4.1
date	2004.03.11.23.43.42;	author morrison;	state Exp;
branches;
next	;

11.22.10.1
date	2004.02.12.18.37.44;	author erikg;	state Exp;
branches;
next	11.22.10.2;

11.22.10.2
date	2004.03.15.14.07.26;	author erikg;	state Exp;
branches;
next	;


desc
@NMG meshing routines
@


11.26
log
@moved to src/
@
text
@/*
 *			N M G _ M E S H . C
 *
 *	Meshing routines for n-Manifold Geometry
 *  This stuff is destined to be absorbed into nmg_fuse.c.
 *  "meshing" here refers to the sorting of faceuses around an edge
 *  as two edges sharing the same end points (vertex structs) are fused.
 *
 *  Authors -
 *	Lee A. Butler
 *	Michael John Muuss
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1989-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/nmg_mesh.c,v 11.25 2004/05/10 15:30:46 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif


#include <stdio.h>
#include <math.h>
#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "nmg.h"
#include "raytrace.h"


/*
 *			N M G _ I S _ A N G L E _ I N _ W E D G E
 *
 *  Determine if T lies within angle AB, such that A < T < B.
 *  The angle B is expected to be "more ccw" than A.
 *  Because of the wrap from 2pi to 0, B may have a smaller numeric value.
 *
 *  Returns -
 *	-2	t is equal to a
 *	-1	t is equal to b
 *	 0	t is outside angle ab
 *	 1	t is inside angle ab
 */
int
nmg_is_angle_in_wedge(double a, double b, double t)
{
	/* XXX What tolerance to use here (in radians)? */
	if( NEAR_ZERO( a-t, 1.0e-8 ) )  return -2;
	if( NEAR_ZERO( b-t, 1.0e-8 ) )  return -1;

	/* If A==B, if T is not also equal, it's outside the wedge */
	if( NEAR_ZERO( a-b, 1.0e-8 ) )  return 0;

	if( b < a )  {
		/* B angle has wrapped past zero, add on 2pi */
		if( t <= b )  {
			/* Range is A..0, 0..B, and 0<t<B; so T is in wedge */
			return 1;
		}
		b += bn_twopi;
	}
	if( NEAR_ZERO( b-t, 1.0e-8 ) )  return -1;

	if( t < a )  return 0;
	if( t > b )  return 0;
	return 1;
}

/*
 *			N M G _ P I C K _ B E S T _ E D G E _ G
 *
 *  Given two edgeuses with different edge geometry but
 *  running between the same two vertices,
 *  select the proper edge geometry to associate with.
 *
 *  Really, there are 3 geometries to be compared here:
 *  the vector between the two endpoints of this edge,
 *  and the two edge_g structures.
 *  Rather than always taking eu2 or eu1,
 *  select the one that best fits this one edge.
 *
 *  Consider fu1:
 *		         B
 *		         *
 *		        /|
 *		    eg2/ |
 *		      /  |
 *		    D/   |
 *		    *    |
 *		   /     |
 *		A *-*----* C
 *		    E eg1
 *
 *  At the start of a face/face intersection, eg1 runs from A to C,
 *  and eg2 runs ADB.  The line of intersection with the other face
 *  (fu2, not drawn) lies along eg1.
 *  Assume that edge AC needs to be broken at E,
 *  where E is just a little more than tol->dist away from A.
 *  Existing point D is found because it *is* within tol->dist of E,
 *  thanks to the cosine of angle BAC.
 *  So, edge AC is broken on vertex D, and the intersection list
 *  contains vertexuses A, E, and C.
 *
 *  Because D and E are the same point, fu1 has become a triangle with
 *  a little "spike" on the end.  If this is handled simply by re-homing
 *  edge AE to eg2, it may cause trouble, because eg1 now runs EC,
 *  but the geometry for eg1 runs AC.  If there are other vertices on
 *  edge eg1, the problem can not be resolved simply by recomputing the
 *  geometry of eg1.
 *  Since E (D) is within tolerance of eg1, it is not unreasonable
 *  just to leave eg1 alone.
 *
 *  The issue boils down to selecting whether the existing eg1 or eg2
 *  best represents the direction of the little stub edge AD (shared with AE).
 *  In this case, eg2 is the correct choice, as AD (and AE) lie on line AB.
 *
 *  It would be disasterous to force *all* of eg1 to use the edge geometry
 *  of eg2, as the two lines are very different.
 */
struct edge_g_lseg *
nmg_pick_best_edge_g(struct edgeuse *eu1, struct edgeuse *eu2, const struct bn_tol *tol)
{
	NMG_CK_EDGEUSE(eu1);
	NMG_CK_EDGEUSE(eu2);
	BN_CK_TOL(tol);

	NMG_CK_EDGE_G_LSEG(eu1->g.lseg_p);
	NMG_CK_EDGE_G_LSEG(eu2->g.lseg_p);
	if( eu2->g.lseg_p != eu1->g.lseg_p )  {
		vect_t		dir;
		vect_t		dir_2;
		vect_t		dir_1;
		fastf_t		dot_2;
		fastf_t		dot_1;

		VSUB2( dir, eu1->vu_p->v_p->vg_p->coord, eu1->eumate_p->vu_p->v_p->vg_p->coord );
		VUNITIZE(dir);
		VMOVE( dir_2, eu2->g.lseg_p->e_dir );
		VUNITIZE( dir_2 );
		VMOVE( dir_1, eu1->g.lseg_p->e_dir );
		VUNITIZE( dir_1 );

		dot_2 = fabs(VDOT( dir, dir_2 ));
		dot_1 = fabs(VDOT( dir, dir_1 ));

		/* Dot product of 1 means colinear.  Take largest dot. */
		if( dot_2 > dot_1 )  {
			if (rt_g.NMG_debug & DEBUG_BASIC)  {
				bu_log("nmg_pick_best_edge_g() Make eu1 use geometry of eu2, s.d=%g, d.d=%g\n",
					acos(dot_2)*bn_radtodeg,
					acos(dot_1)*bn_radtodeg );
			}
			return eu2->g.lseg_p;
		} else {
			if (rt_g.NMG_debug & DEBUG_BASIC)  {
				bu_log("nmg_pick_best_edge_g() Make eu2 use geometry of eu1, s.d=%g, d.d=%g\n",
					acos(dot_2)*bn_radtodeg,
					acos(dot_1)*bn_radtodeg );
			}
			return eu1->g.lseg_p;
		}
	}
	return eu1->g.lseg_p;	/* both the same */
}

/*
 *			N M G _ R A D I A L _ J O I N _ E U
 *
 *	Make all the edgeuses around eu2's edge to refer to eu1's edge,
 *	taking care to organize them into the proper angular orientation,
 *	so that the attached faces are correctly arranged radially
 *	around the edge.
 *
 *	This depends on both edges being part of face loops,
 *	with vertex and face geometry already associated.
 *
 *  The two edgeuses being joined might well be from separate shells,
 *  so the issue of preserving (simple) faceuse orientation parity
 *  (SAME, OPPOSITE, OPPOSITE, SAME, ...)
 *  can't be used here -- that only applies to faceuses from the same shell.
 *
 *  Some of the edgeuses around both edges may be wires.
 *
 *	Call to nmg_check_radial at end has been deleted.
 *	Note that after two radial EU's have been joined
 *	a third cannot be joined to them without creating
 *	unclosed space that nmg_check_radial will find.
 */
void
nmg_radial_join_eu(struct edgeuse *eu1, struct edgeuse *eu2, const struct bn_tol *tol)
{

	NMG_CK_EDGEUSE(eu1);
	NMG_CK_EDGEUSE(eu1->radial_p);
	NMG_CK_EDGEUSE(eu1->eumate_p);
	NMG_CK_EDGEUSE(eu2);
	NMG_CK_EDGEUSE(eu2->radial_p);
	NMG_CK_EDGEUSE(eu2->eumate_p);
	BN_CK_TOL(tol);

	if( eu1->e_p == eu2->e_p )  return;

	if( !NMG_ARE_EUS_ADJACENT(eu1, eu2) )
		rt_bomb("nmg_radial_join_eu() edgeuses don't share vertices.\n");

	if( eu1->vu_p->v_p == eu1->eumate_p->vu_p->v_p )  rt_bomb("nmg_radial_join_eu(): 0 length edge (topology)\n");

	if( bn_pt3_pt3_equal( eu1->vu_p->v_p->vg_p->coord,
	    eu1->eumate_p->vu_p->v_p->vg_p->coord, tol ) )
	{
		bu_log( "vertices should have been fused:\n" );
		bu_log( "\tvertex x%x ( %.12f %.12f %.12f )\n",
			eu1->vu_p->v_p,
			V3ARGS( eu1->vu_p->v_p->vg_p->coord ) );
		bu_log( "\tvertex x%x ( %.12f %.12f %.12f )\n",
			eu1->eumate_p->vu_p->v_p,
			V3ARGS( eu1->eumate_p->vu_p->v_p->vg_p->coord ) );
		rt_bomb("nmg_radial_join_eu(): 0 length edge (geometry)\n");
	}

#if 1
nmg_radial_join_eu_NEW(eu1, eu2, tol);
return;
#else

	/* Ensure faces are of same orientation, if both eu's have faces */
	fu1 = nmg_find_fu_of_eu(eu1);
	fu2 = nmg_find_fu_of_eu(eu2);
	if( fu1 && fu2 )  {
		if( fu1->orientation != fu2->orientation ){
			eu2 = eu2->eumate_p;
			fu2 = nmg_find_fu_of_eu(eu2);
			if( fu1->orientation != fu2->orientation )
				rt_bomb( "nmg_radial_join_eu(): Cannot find matching orientations for faceuses\n" );
		}
	}

	/* XXX This angle-based algorithm can't handle snurb faces! */
	if( fu1 && fu1->f_p->g.magic_p && *fu1->f_p->g.magic_p == NMG_FACE_G_SNURB_MAGIC )  return;
	if( fu2 && fu2->f_p->g.magic_p && *fu2->f_p->g.magic_p == NMG_FACE_G_SNURB_MAGIC )  return;

	/*  Construct local coordinate system for this edge,
	 *  so all angles can be measured relative to a common reference.
	 */
	nmg_eu_2vecs_perp( xvec, yvec, zvec, original_eu1, tol );

	if (rt_g.NMG_debug & DEBUG_MESH_EU ) {
		bu_log("nmg_radial_join_eu(eu1=x%x, eu2=x%x) e1=x%x, e2=x%x\n",
			eu1, eu2,
			eu1->e_p, eu2->e_p);
		nmg_euprint("\tJoining", eu1);
		nmg_euprint("\t     to", eu2);
		bu_log( "Faces around eu1:\n" );
		nmg_pr_fu_around_eu_vecs( eu1, xvec, yvec, zvec, tol );
		bu_log( "Faces around eu2:\n" );
		nmg_pr_fu_around_eu_vecs( eu2, xvec, yvec, zvec, tol );
	}

	best_eg = nmg_pick_best_edge_g( eu1, eu2, tol );

	for ( iteration1=0; eu2 && iteration1 < 10000; iteration1++ ) {
		int	code = 0;
		struct edgeuse	*first_eu1 = eu1;
		int	wire_skip = 0;
		/* Resume where we left off from last eu2 insertion */

		/* find a place to insert eu2 around eu1's edge */
		for ( iteration2=0; iteration2 < 10000; iteration2++ ) {
			struct faceuse	*fur;

			abs1 = abs2 = absr = -bn_twopi;

			eur = eu1->radial_p;
			NMG_CK_EDGEUSE(eur);

			fu2 = nmg_find_fu_of_eu(eu2);
			if( fu2 == (struct faceuse *)NULL )  {
				/* eu2 is a wire, it can go anywhere */
bu_log("eu2=x%x is a wire, insert after eu1=x%x\n", eu2, eu1);
				goto insert;
			}
			fu1 = nmg_find_fu_of_eu(eu1);
			if( fu1 == (struct faceuse *)NULL )  {
				/* eu1 is a wire, skip on to real face eu */
bu_log("eu1=x%x is a wire, skipping on\n", eu1);
				wire_skip++;
				goto cont;
			}
			fur = nmg_find_fu_of_eu(eur);
			while( fur == (struct faceuse *)NULL )  {
				/* eur is wire, advance eur */
bu_log("eur=x%x is a wire, advancing to non-wire eur\n", eur);
				eur = eur->eumate_p->radial_p;
				wire_skip++;
				if( eur == eu1->eumate_p )  {
bu_log("went all the way around\n");
					/* Went all the way around */
					goto insert;
				}
				fur = nmg_find_fu_of_eu(eur);
			}
			NMG_CK_FACEUSE(fu1);
			NMG_CK_FACEUSE(fu2);
			NMG_CK_FACEUSE(fur);

			/*
			 *  Can't just check for shared fg here,
			 *  the angle changes by +/- 180 degrees,
			 *  depending on which side of the eu the loop is on
			 *  along this edge.
			 */
			abs1 = nmg_measure_fu_angle( eu1, xvec, yvec, zvec );
			abs2 = nmg_measure_fu_angle( eu2, xvec, yvec, zvec );
			absr = nmg_measure_fu_angle( eur, xvec, yvec, zvec );

			if (rt_g.NMG_debug & DEBUG_MESH_EU )  {
				bu_log("  abs1=%g, abs2=%g, absr=%g\n",
					abs1*bn_radtodeg,
					abs2*bn_radtodeg,
					absr*bn_radtodeg );
			}

			/* If abs1 == absr, warn about unfused faces, and skip. */
			if( NEAR_ZERO( abs1-absr, 1.0e-8 ) )  {
				if( fu1->f_p->g.plane_p == fur->f_p->g.plane_p )  {
					/* abs1 == absr, faces are fused, don't insert here. */
					if (rt_g.NMG_debug & DEBUG_MESH_EU )  {
						bu_log("fu1 and fur share face geometry x%x (flip1=%d, flip2=%d), skip\n",
							fu1->f_p->g.plane_p, fu1->f_p->flip, fur->f_p->flip );
					}
					goto cont;
				}

				bu_log("nmg_radial_join_eu: WARNING 2 faces should have been fused, may be ambiguous.\n  abs1=%e, absr=%e, asb2=%e\n",
					abs1*bn_radtodeg, absr*bn_radtodeg, abs2*bn_radtodeg);
				bu_log("  fu1=x%x, f1=x%x, f1->flip=%d, fg1=x%x\n",
					fu1, fu1->f_p, fu1->f_p->flip, fu1->f_p->g.plane_p );
				bu_log("  fu2=x%x, f2=x%x, f2->flip=%d, fg2=x%x\n",
					fu2, fu2->f_p, fu2->f_p->flip, fu2->f_p->g.plane_p );
				bu_log("  fur=x%x, fr=x%x, fr->flip=%d, fgr=x%x\n",
					fur, fur->f_p, fur->f_p->flip, fur->f_p->g.plane_p );
				PLPRINT("  fu1", fu1->f_p->g.plane_p->N );
				PLPRINT("  fu2", fu2->f_p->g.plane_p->N );
				PLPRINT("  fur", fur->f_p->g.plane_p->N );
				{
					int debug = rt_g.NMG_debug;
#if 0
					rt_g.NMG_debug |= DEBUG_MESH;
#endif
					if( nmg_two_face_fuse(fu1->f_p, fur->f_p, tol) == 0 )
						rt_bomb("faces didn't fuse?\n");
					rt_g.NMG_debug = debug;
				}
				bu_log("  nmg_radial_join_eu() skipping this eu\n");
				goto cont;
			}

			/*
			 *  If abs1 < abs2 < absr
			 *  (taking into account 360 wrap),
			 *  then insert face here.
			 *  Special handling if abs1==abs2 or abs2==absr.
			 */
			code = nmg_is_angle_in_wedge( abs1, absr, abs2 );
			if (rt_g.NMG_debug & DEBUG_MESH_EU )
				bu_log("    code=%d %s\n", code, (code!=0)?"INSERT_HERE":"skip");
			if( code > 0 )  break;
			if( code == -1 )  {
				/* absr == abs2 */
				break;
			}
			if( code <= -2 )  {
				/* abs1 == abs2 */
				break;
			}

cont:
#if 0
			if( iteration2 > 9997 )  rt_g.NMG_debug |= DEBUG_MESH_EU;
#endif
			/* If eu1 is only one pair of edgeuses, done */
			if( eu1 == eur->eumate_p )  break;
			eu1 = eur->eumate_p;
			if( eu1 == first_eu1 )  {
				/* If all eu's were wires, here is fine */
				if( wire_skip >= iteration2 )  break;
				/* Nope, something bad happened */
				rt_bomb("nmg_radial_join_eu():  went full circle, no face insertion point.\n");
				break;
			}
		}
		if(iteration2 >= 10000)  {
			rt_bomb("nmg_radial_join_eu: infinite loop (2)\n");
		}

		/* find the next use of the edge eu2 is on.  If eu2 and it's
		 * mate are the last uses of the edge, there will be no next
		 * edgeuse to move. (Loop termination condition).
		 */
insert:
		nexteu = eu2->radial_p;
		if (nexteu == eu2->eumate_p)
			nexteu = (struct edgeuse *)NULL;

		/* because faces are always created with counter-clockwise
		 * exterior loops and clockwise interior loops,
		 * radial edgeuses IN THE SAME SHELL will never point in
		 * the same direction or share the same vertex.  We thus make
		 * sure that eu2 is an edgeuse which might be radial to eu1
		 * XXX Need to look back for last eu IN THE SHELL OF eu2.
		 * XXX Even this isn't good enough, as we may be inserting
		 * XXX something new _after_ that last starting point.
		 */
		eus = eu1;
		while( nmg_find_s_of_eu(eus) != nmg_find_s_of_eu(eu2) )  {
			eus = eus->eumate_p->radial_p;
			if( eus == eu1 )  break;	/* full circle */
		}

		if (eu2->vu_p->v_p == eus->vu_p->v_p)
			eu2 = eu2->eumate_p;

		if (rt_g.NMG_debug & DEBUG_MESH_EU)  {
			bu_log("  Inserting.  code=%d\n", code);
			bu_log("joining eu1=x%x eu2=x%x with abs1=%g, absr=%g\n",
				eu1, eu2,
				abs1*bn_radtodeg, absr*bn_radtodeg);
		}

		/*
		 *  Make eu2 radial to eu1.
		 *  This should insert eu2 between eu1 and eu1->radial_p
		 *  (which may be less far around than eur, but thats OK).
		 *  This does NOT change the edge geometry pointer.
		 */
		nmg_je(eu1, eu2);

		if (rt_g.NMG_debug & DEBUG_MESH_EU)  {
			bu_log("After nmg_je(), faces around original_eu1 are:\n");
			nmg_pr_fu_around_eu_vecs( original_eu1, xvec, yvec, zvec, tol );
		}

		/* Proceed to the next source edgeuse */
		eu2 = nexteu;
	}
	if( iteration1 >= 10000 )  rt_bomb("nmg_radial_join_eu:  infinite loop (1)\n");

	NMG_CK_EDGEUSE(original_eu1);

	/*
	 *  Make another pass, ensuring that all edgeuses are using the
	 *  "best_eg" line.
	 */
	eu1 = original_eu1;
	for(;;)  {
		if( eu1->g.lseg_p != best_eg )  {
			nmg_use_edge_g( eu1, &best_eg->l.magic );
		}

		eu1 = eu1->eumate_p->radial_p;
		if( eu1 == original_eu1 )  break;
	}

	if (rt_g.NMG_debug & DEBUG_MESH_EU)  bu_log("nmg_radial_join_eu: END\n");
#endif
}

/*
 *			N M G _ M E S H _ T W O _ F A C E S
 *
 *  Actuall do the work of meshing two faces.
 *  The two fu arguments may be the same, which causes the face to be
 *  meshed against itself.
 *
 *  The return is the number of edges meshed.
 */
int
nmg_mesh_two_faces(register struct faceuse *fu1, register struct faceuse *fu2, const struct bn_tol *tol)
{
	struct loopuse	*lu1;
	struct loopuse	*lu2;
	struct edgeuse	*eu1;
	struct edgeuse	*eu2;
	struct vertex	*v1a, *v1b;
	struct edge	*e1;
	pointp_t	pt1, pt2;
	int		count = 0;

	NMG_CK_FACEUSE(fu1);
	NMG_CK_FACEUSE(fu2);
	BN_CK_TOL(tol);

	/* Visit all the loopuses in faceuse 1 */
	for (BU_LIST_FOR(lu1, loopuse, &fu1->lu_hd)) {
		NMG_CK_LOOPUSE(lu1);
		/* Ignore self-loops */
		if (BU_LIST_FIRST_MAGIC(&lu1->down_hd) != NMG_EDGEUSE_MAGIC)
			continue;

		/* Visit all the edgeuses in loopuse1 */
		for(BU_LIST_FOR(eu1, edgeuse, &lu1->down_hd)) {
			NMG_CK_EDGEUSE(eu1);

			v1a = eu1->vu_p->v_p;
			v1b = eu1->eumate_p->vu_p->v_p;
			NMG_CK_VERTEX(v1a);
			NMG_CK_VERTEX(v1b);
			e1 = eu1->e_p;
			NMG_CK_EDGE(e1);
			if (rt_g.NMG_debug & DEBUG_MESH)  {
				pt1 = v1a->vg_p->coord;
				pt2 = v1b->vg_p->coord;
				bu_log("ref_e=%8x v:%8x--%8x (%g, %g, %g)->(%g, %g, %g)\n",
					e1, v1a, v1b,
					V3ARGS(pt1), V3ARGS(pt2) );
			}

			/* Visit all the loopuses in faceuse2 */
			for (BU_LIST_FOR(lu2, loopuse, &fu2->lu_hd)) {
				/* Ignore self-loops */
				if(BU_LIST_FIRST_MAGIC(&lu2->down_hd) != NMG_EDGEUSE_MAGIC)
					continue;
				/* Visit all the edgeuses in loopuse2 */
				for( BU_LIST_FOR(eu2, edgeuse, &lu2->down_hd) )  {
					NMG_CK_EDGEUSE(eu2);
					if (rt_g.NMG_debug & DEBUG_MESH) {
						pt1 = eu2->vu_p->v_p->vg_p->coord;
						pt2 = eu2->eumate_p->vu_p->v_p->vg_p->coord;
						bu_log("\te:%8x v:%8x--%8x (%g, %g, %g)->(%g, %g, %g)\n",
							eu2->e_p,
							eu2->vu_p->v_p,
							eu2->eumate_p->vu_p->v_p,
							V3ARGS(pt1), V3ARGS(pt2) );
					}

					/* See if already shared */
					if( eu2->e_p == e1 ) continue;
					if( (eu2->vu_p->v_p == v1a &&
					     eu2->eumate_p->vu_p->v_p == v1b) ||
					    (eu2->eumate_p->vu_p->v_p == v1a &&
					     eu2->vu_p->v_p == v1b) )  {
						nmg_radial_join_eu(eu1, eu2, tol);
					     	count++;
					 }
				}
			}
		}
	}
	return count;
}

/*
 *			N M G _ M E S H _ F A C E S
 *
 *  Scan through all the edges of fu1 and fu2, ensuring that all
 *  edges involving the same vertex pair are indeed shared.
 *  This means worrying about merging ("meshing") all the faces in the
 *  proper radial orientation around the edge.
 *  XXX probably should return(count);
 */
void
nmg_mesh_faces(struct faceuse *fu1, struct faceuse *fu2, const struct bn_tol *tol)
{
	int	count = 0;

	NMG_CK_FACEUSE(fu1);
	NMG_CK_FACEUSE(fu2);
	BN_CK_TOL(tol);

    	if (rt_g.NMG_debug & DEBUG_MESH_EU && rt_g.NMG_debug & DEBUG_PLOTEM) {
    		static int fnum=1;
    	    	nmg_pl_2fu( "Before_mesh%d.pl", fnum++, fu1, fu2, 1 );
    	}

	if (rt_g.NMG_debug & DEBUG_MESH_EU)
		bu_log("meshing self (fu1 %8x)\n", fu1);
	count += nmg_mesh_two_faces( fu1, fu1, tol );

	if (rt_g.NMG_debug & DEBUG_MESH_EU)
		bu_log("meshing self (fu2 %8x)\n", fu2);
	count += nmg_mesh_two_faces( fu2, fu2, tol );

	if (rt_g.NMG_debug & DEBUG_MESH_EU)
		bu_log("meshing to other (fu1:%8x fu2:%8x)\n", fu1, fu2);
	count += nmg_mesh_two_faces( fu1, fu2, tol );

    	if (rt_g.NMG_debug & DEBUG_MESH_EU && rt_g.NMG_debug & DEBUG_PLOTEM) {
    		static int fno=1;
    	    	nmg_pl_2fu( "After_mesh%d.pl", fno++, fu1, fu2, 1 );
    	}
}

/*
 *			N M G _ M E S H _ F A C E _ S H E L L
 *
 *  The return is the number of edges meshed.
 */
int
nmg_mesh_face_shell(struct faceuse *fu1, struct shell *s, const struct bn_tol *tol)
{
	register struct faceuse	*fu2;
	int		count = 0;

	NMG_CK_FACEUSE(fu1);
	NMG_CK_SHELL(s);
	BN_CK_TOL(tol);

	count += nmg_mesh_two_faces( fu1, fu1, tol );
	for( BU_LIST_FOR( fu2, faceuse, &s->fu_hd ) )  {
		NMG_CK_FACEUSE(fu2);
		count += nmg_mesh_two_faces( fu2, fu2, tol );
		count += nmg_mesh_two_faces( fu1, fu2, tol );
	}
	/* XXX What about wire edges in the shell? */
	return count;
}

/*
 *			N M G _ M E S H _ S H E L L _ S H E L L
 *
 *  Mesh every edge in shell 1 with every edge in shell 2.
 *  The return is the number of edges meshed.
 *
 *  Does not use nmg_mesh_face_shell() to keep face/self meshing
 *  to the absolute minimum necessary.
 */
int
nmg_mesh_shell_shell(struct shell *s1, struct shell *s2, const struct bn_tol *tol)
{
	struct faceuse	*fu1;
	struct faceuse	*fu2;
	int		count = 0;

	NMG_CK_SHELL(s1);
	NMG_CK_SHELL(s2);
	BN_CK_TOL(tol);

nmg_region_v_unique( s1->r_p, tol );
nmg_region_v_unique( s2->r_p, tol );

	/* First, mesh all faces of shell 2 with themselves */
	for( BU_LIST_FOR( fu2, faceuse, &s2->fu_hd ) )  {
		NMG_CK_FACEUSE(fu2);
		count += nmg_mesh_two_faces( fu2, fu2, tol );
	}

	/* Visit every face in shell 1 */
	for( BU_LIST_FOR( fu1, faceuse, &s1->fu_hd ) )  {
		NMG_CK_FACEUSE(fu1);

		/* First, mesh each face in shell 1 with itself */
		count += nmg_mesh_two_faces( fu1, fu1, tol );

		/* Visit every face in shell 2 */
		for( BU_LIST_FOR( fu2, faceuse, &s2->fu_hd ) )  {
			NMG_CK_FACEUSE(fu2);
			count += nmg_mesh_two_faces( fu1, fu2, tol );
		}
	}

	/* XXX What about wire edges in the shell? */

	/* Visit every wire loop in shell 1 */

	/* Visit every wire edge in shell 1 */

	return count;
}
@


11.25
log
@change conf.h to a wrapped config.h
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/librt/nmg_mesh.c,v 11.24 2004/04/05 08:48:57 morrison Exp $ (BRL)";
@


11.24
log
@merge of ansi-6-0-branch into HEAD
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d26 5
a30 1
#include "conf.h"
@


11.23
log
@update copyright to include span through 2003
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_mesh.c,v 11.22 2002/08/20 17:08:04 jra Exp $ (BRL)";
d50 1
a50 4
nmg_is_angle_in_wedge( a, b, t )
double	a;
double	b;
double	t;
d126 1
a126 4
nmg_pick_best_edge_g(eu1, eu2, tol)
struct edgeuse		*eu1;
struct edgeuse		*eu2;
const struct bn_tol	*tol;
d195 1
a195 4
nmg_radial_join_eu(eu1, eu2, tol)
struct edgeuse		*eu1;
struct edgeuse		*eu2;
const struct bn_tol	*tol;
d483 1
a483 3
nmg_mesh_two_faces(fu1, fu2, tol)
register struct faceuse *fu1, *fu2;
const struct bn_tol	*tol;
d567 1
a567 4
nmg_mesh_faces(fu1, fu2, tol)
struct faceuse		*fu1;
struct faceuse		*fu2;
const struct bn_tol	*tol;
d604 1
a604 4
nmg_mesh_face_shell( fu1, s, tol )
struct faceuse	*fu1;
struct shell	*s;
const struct bn_tol	*tol;
d633 1
a633 4
nmg_mesh_shell_shell( s1, s2, tol )
struct shell	*s1;
struct shell	*s2;
const struct bn_tol	*tol;
@


11.22
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1989 by the United States Army.
d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_mesh.c,v 11.20 2001/04/20 22:29:51 morrison Exp $ (BRL)";
@


11.22.4.1
log
@sync to HEAD...
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1989-2004 by the United States Army.
d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/nmg_mesh.c,v 11.23 2004/02/02 17:39:24 morrison Exp $ (BRL)";
@


11.22.10.1
log
@merge from HEAD
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1989-2004 by the United States Army.
d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_mesh.c,v 11.23 2004/02/02 17:39:24 morrison Exp $ (BRL)";
@


11.22.10.2
log
@merge from head
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_mesh.c,v 11.22.10.1 2004/02/12 18:37:44 erikg Exp $ (BRL)";
@


11.22.2.1
log
@Initial ANSIfication
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_mesh.c,v 11.22 2002/08/20 17:08:04 jra Exp $ (BRL)";
d50 4
a53 1
nmg_is_angle_in_wedge(double a, double b, double t)
d129 4
a132 1
nmg_pick_best_edge_g(struct edgeuse *eu1, struct edgeuse *eu2, const struct bn_tol *tol)
d201 4
a204 1
nmg_radial_join_eu(struct edgeuse *eu1, struct edgeuse *eu2, const struct bn_tol *tol)
d492 3
a494 1
nmg_mesh_two_faces(register struct faceuse *fu1, register struct faceuse *fu2, const struct bn_tol *tol)
d578 4
a581 1
nmg_mesh_faces(struct faceuse *fu1, struct faceuse *fu2, const struct bn_tol *tol)
d618 4
a621 1
nmg_mesh_face_shell(struct faceuse *fu1, struct shell *s, const struct bn_tol *tol)
d650 4
a653 1
nmg_mesh_shell_shell(struct shell *s1, struct shell *s2, const struct bn_tol *tol)
@


11.22.2.2
log
@sync branch with HEAD
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1989-2004 by the United States Army.
d23 1
a23 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.21
log
@Converted from K&R to ANSI C - RFH
@
text
@d50 4
a53 1
nmg_is_angle_in_wedge(double a, double b, double t)
d129 4
a132 1
nmg_pick_best_edge_g(struct edgeuse *eu1, struct edgeuse *eu2, const struct bn_tol *tol)
d201 4
a204 1
nmg_radial_join_eu(struct edgeuse *eu1, struct edgeuse *eu2, const struct bn_tol *tol)
d492 3
a494 1
nmg_mesh_two_faces(register struct faceuse *fu1, register struct faceuse *fu2, const struct bn_tol *tol)
d578 4
a581 1
nmg_mesh_faces(struct faceuse *fu1, struct faceuse *fu2, const struct bn_tol *tol)
d618 4
a621 1
nmg_mesh_face_shell(struct faceuse *fu1, struct shell *s, const struct bn_tol *tol)
d650 4
a653 1
nmg_mesh_shell_shell(struct shell *s1, struct shell *s2, const struct bn_tol *tol)
@


11.20
log
@CONST to const
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_mesh.c,v 11.19 2000/08/21 02:02:32 butler Exp $ (BRL)";
d50 1
a50 4
nmg_is_angle_in_wedge( a, b, t )
double	a;
double	b;
double	t;
d126 1
a126 4
nmg_pick_best_edge_g(eu1, eu2, tol)
struct edgeuse		*eu1;
struct edgeuse		*eu2;
const struct bn_tol	*tol;
d195 1
a195 4
nmg_radial_join_eu(eu1, eu2, tol)
struct edgeuse		*eu1;
struct edgeuse		*eu2;
const struct bn_tol	*tol;
d483 1
a483 3
nmg_mesh_two_faces(fu1, fu2, tol)
register struct faceuse *fu1, *fu2;
const struct bn_tol	*tol;
d567 1
a567 4
nmg_mesh_faces(fu1, fu2, tol)
struct faceuse		*fu1;
struct faceuse		*fu2;
const struct bn_tol	*tol;
d604 1
a604 4
nmg_mesh_face_shell( fu1, s, tol )
struct faceuse	*fu1;
struct shell	*s;
const struct bn_tol	*tol;
d633 1
a633 4
nmg_mesh_shell_shell( s1, s2, tol )
struct shell	*s1;
struct shell	*s2;
const struct bn_tol	*tol;
@


11.19
log
@Massive compilation warnings eliminated
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_mesh.c,v 11.18 2000/07/10 23:01:42 mike Exp $ (BRL)";
d132 1
a132 1
CONST struct bn_tol	*tol;
d204 1
a204 1
CONST struct bn_tol	*tol;
d494 1
a494 1
CONST struct bn_tol	*tol;
d581 1
a581 1
CONST struct bn_tol	*tol;
d653 1
a653 1
CONST struct bn_tol	*tol;
@


11.18
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_mesh.c,v 11.17 1999/12/30 15:31:36 jra Exp $ (BRL)";
d621 1
a621 1
CONST struct bn_tol	*tol;
d630 1
a630 1
	count += nmg_mesh_two_faces( fu1, fu1 );
@


11.17
log
@Eliminated some unused variables
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_mesh.c,v 11.16 1999/11/24 21:44:30 mike Exp $ (BRL)";
@


11.16
log
@
Removed includes of compat header files rtstring.h and rtlist.h
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_mesh.c,v 11.15 1999/06/03 01:01:26 mike Exp $ (BRL)";
a205 12
	struct edgeuse	*original_eu1 = eu1;
	struct edgeuse	*nexteu;
	struct edgeuse	*eus;
	struct edgeuse	*eur;
	struct faceuse	*fu1;
	struct faceuse	*fu2;
	struct edge_g_lseg	*best_eg;
	int		iteration1, iteration2;
	vect_t		xvec, yvec, zvec;
	fastf_t		abs1;
	fastf_t		abs2;
	fastf_t		absr;
@


11.15
log
@
sed4
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_mesh.c,v 11.14 1999/05/11 19:08:25 mike Exp $ (BRL)";
a31 1
#include "rtlist.h"
@


11.14
log
@Reduced amount of stray debug printing,
to provide a better image of the released version.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_mesh.c,v 11.13 1996/10/21 19:10:42 jra Exp $ (BRL)";
d238 2
a239 2
		rt_log( "vertices should have been fused:\n" );
		rt_log( "\tvertex x%x ( %.12f %.12f %.12f )\n",
d242 1
a242 1
		rt_log( "\tvertex x%x ( %.12f %.12f %.12f )\n",
@


11.13
log
@Added some debug messages to nmg_radial_join_eu().
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mesh.c,v 11.12 1996/09/27 08:27:30 mike Exp jra $ (BRL)";
d374 1
d376 1
d405 1
d407 1
@


11.12
log
@Converted to using proper routine names for LIBBU and LIBBN routines.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mesh.c,v 11.11 1996/07/12 12:17:41 jra Exp mike $ (BRL)";
d237 8
d246 1
@


11.11
log
@Minor Mods for IRIX 6.2
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mesh.c,v 11.10 1995/12/02 03:09:46 mike Exp jra $ (BRL)";
d69 1
a69 1
		b += rt_twopi;
d133 1
a133 1
CONST struct rt_tol	*tol;
d137 1
a137 1
	RT_CK_TOL(tol);
d161 3
a163 3
				rt_log("nmg_pick_best_edge_g() Make eu1 use geometry of eu2, s.d=%g, d.d=%g\n",
					acos(dot_2)*rt_radtodeg,
					acos(dot_1)*rt_radtodeg );
d168 3
a170 3
				rt_log("nmg_pick_best_edge_g() Make eu2 use geometry of eu1, s.d=%g, d.d=%g\n",
					acos(dot_2)*rt_radtodeg,
					acos(dot_1)*rt_radtodeg );
d205 1
a205 1
CONST struct rt_tol	*tol;
d226 1
a226 1
	RT_CK_TOL(tol);
d235 1
a235 1
	if( rt_pt3_pt3_equal( eu1->vu_p->v_p->vg_p->coord,
d266 1
a266 1
		rt_log("nmg_radial_join_eu(eu1=x%x, eu2=x%x) e1=x%x, e2=x%x\n",
d271 1
a271 1
		rt_log( "Faces around eu1:\n" );
d273 1
a273 1
		rt_log( "Faces around eu2:\n" );
d289 1
a289 1
			abs1 = abs2 = absr = -rt_twopi;
d297 1
a297 1
rt_log("eu2=x%x is a wire, insert after eu1=x%x\n", eu2, eu1);
d303 1
a303 1
rt_log("eu1=x%x is a wire, skipping on\n", eu1);
d310 1
a310 1
rt_log("eur=x%x is a wire, advancing to non-wire eur\n", eur);
d314 1
a314 1
rt_log("went all the way around\n");
d335 4
a338 4
				rt_log("  abs1=%g, abs2=%g, absr=%g\n",
					abs1*rt_radtodeg,
					abs2*rt_radtodeg,
					absr*rt_radtodeg );
d346 1
a346 1
						rt_log("fu1 and fur share face geometry x%x (flip1=%d, flip2=%d), skip\n",
d352 3
a354 3
				rt_log("nmg_radial_join_eu: WARNING 2 faces should have been fused, may be ambiguous.\n  abs1=%e, absr=%e, asb2=%e\n",
					abs1*rt_radtodeg, absr*rt_radtodeg, abs2*rt_radtodeg);
				rt_log("  fu1=x%x, f1=x%x, f1->flip=%d, fg1=x%x\n",
d356 1
a356 1
				rt_log("  fu2=x%x, f2=x%x, f2->flip=%d, fg2=x%x\n",
d358 1
a358 1
				rt_log("  fur=x%x, fr=x%x, fr->flip=%d, fgr=x%x\n",
d370 1
a370 1
				rt_log("  nmg_radial_join_eu() skipping this eu\n");
d382 1
a382 1
				rt_log("    code=%d %s\n", code, (code!=0)?"INSERT_HERE":"skip");
d438 2
a439 2
			rt_log("  Inserting.  code=%d\n", code);
			rt_log("joining eu1=x%x eu2=x%x with abs1=%g, absr=%g\n",
d441 1
a441 1
				abs1*rt_radtodeg, absr*rt_radtodeg);
d453 1
a453 1
			rt_log("After nmg_je(), faces around original_eu1 are:\n");
d478 1
a478 1
	if (rt_g.NMG_debug & DEBUG_MESH_EU)  rt_log("nmg_radial_join_eu: END\n");
d494 1
a494 1
CONST struct rt_tol	*tol;
d507 1
a507 1
	RT_CK_TOL(tol);
d510 1
a510 1
	for (RT_LIST_FOR(lu1, loopuse, &fu1->lu_hd)) {
d513 1
a513 1
		if (RT_LIST_FIRST_MAGIC(&lu1->down_hd) != NMG_EDGEUSE_MAGIC)
d517 1
a517 1
		for(RT_LIST_FOR(eu1, edgeuse, &lu1->down_hd)) {
d529 1
a529 1
				rt_log("ref_e=%8x v:%8x--%8x (%g, %g, %g)->(%g, %g, %g)\n",
d535 1
a535 1
			for (RT_LIST_FOR(lu2, loopuse, &fu2->lu_hd)) {
d537 1
a537 1
				if(RT_LIST_FIRST_MAGIC(&lu2->down_hd) != NMG_EDGEUSE_MAGIC)
d540 1
a540 1
				for( RT_LIST_FOR(eu2, edgeuse, &lu2->down_hd) )  {
d545 1
a545 1
						rt_log("\te:%8x v:%8x--%8x (%g, %g, %g)->(%g, %g, %g)\n",
d581 1
a581 1
CONST struct rt_tol	*tol;
d587 1
a587 1
	RT_CK_TOL(tol);
d595 1
a595 1
		rt_log("meshing self (fu1 %8x)\n", fu1);
d599 1
a599 1
		rt_log("meshing self (fu2 %8x)\n", fu2);
d603 1
a603 1
		rt_log("meshing to other (fu1:%8x fu2:%8x)\n", fu1, fu2);
d621 1
a621 1
CONST struct rt_tol	*tol;
d628 1
a628 1
	RT_CK_TOL(tol);
d631 1
a631 1
	for( RT_LIST_FOR( fu2, faceuse, &s->fu_hd ) )  {
d653 1
a653 1
CONST struct rt_tol	*tol;
d661 1
a661 1
	RT_CK_TOL(tol);
d667 1
a667 1
	for( RT_LIST_FOR( fu2, faceuse, &s2->fu_hd ) )  {
d673 1
a673 1
	for( RT_LIST_FOR( fu1, faceuse, &s1->fu_hd ) )  {
d680 1
a680 1
		for( RT_LIST_FOR( fu2, faceuse, &s2->fu_hd ) )  {
@


11.10
log
@edge_g_lseg got an rt_list structure, for symmetry with edge_g_cnurb.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mesh.c,v 11.9 95/03/02 14:30:16 mike Exp $ (BRL)";
d242 1
a242 1
#endif
d479 1
@


11.9
log
@Switched over to new routine.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mesh.c,v 11.8 95/02/28 04:17:12 mike Exp Locker: mike $ (BRL)";
d471 1
a471 1
			nmg_use_edge_g( eu1, &best_eg->magic );
@


11.8
log
@Put in hooks for trying out new routine.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mesh.c,v 11.7 95/02/26 06:25:43 mike Exp Locker: mike $ (BRL)";
d239 1
a239 1
#if 0
@


11.7
log
@Broke out nmg_pick_best_edge_g()
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mesh.c,v 11.6 95/02/25 02:54:38 mike Exp Locker: mike $ (BRL)";
d238 5
@


11.6
log
@First attempt at fixing the problem.
It's wrong, but at least hints at the right direction to go next.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mesh.c,v 11.5 95/02/25 02:27:21 mike Exp Locker: mike $ (BRL)";
d79 100
d272 1
a272 83
	/*
	 *  Select the proper edge geometry to associate with.
	 *
	 *  Really, there are 3 geometries to be compared here:
	 *  the vector between the two endpoints of this edge,
	 *  and the two edge_g structures.
	 *  Rather than always taking eu2 or eu1,
	 *  select the one that best fits this one edge.
	 *
	 *  Consider fu1:
	 *		         B
	 *		         *
	 *		        /|
	 *		    eg2/ |
	 *		      /  |
	 *		    D/   |
	 *		    *    |
	 *		   /     |
	 *		A *-*----* C
	 *		    E eg1
	 *
	 *  At the start of a face/face intersection, eg1 runs from A to C,
	 *  and eg2 runs ADB.  The line of intersection with the other face
	 *  (fu2, not drawn) lies along eg1.
	 *  Assume that edge AC needs to be broken at E,
	 *  where E is just a little more than tol->dist away from A.
	 *  Existing point D is found because it *is* within tol->dist of E,
	 *  thanks to the cosine of angle BAC.
	 *  So, edge AC is broken on vertex D, and the intersection list
	 *  contains vertexuses A, E, and C.
	 *
	 *  Because D and E are the same point, fu1 has become a triangle with
	 *  a little "spike" on the end.  If this is handled simply by re-homing
	 *  edge AE to eg2, it may cause trouble, because eg1 now runs EC,
	 *  but the geometry for eg1 runs AC.  If there are other vertices on
	 *  edge eg1, the problem can not be resolved simply by recomputing the
	 *  geometry of eg1.
	 *  Since E (D) is within tolerance of eg1, it is not unreasonable
	 *  just to leave eg1 alone.
	 *
	 *  The issue boils down to selecting whether the existing eg1 or eg2
	 *  best represents the direction of the little stub edge AD (shared with AE).
	 *  In this case, eg2 is the correct choice, as AD (and AE) lie on line AB.
	 *
	 *  It would be disasterous to force *all* of eg1 to use the edge geometry
	 *  of eg2, as the two lines are very different.
	 */
	NMG_CK_EDGE_G_LSEG(eu1->g.lseg_p);
	NMG_CK_EDGE_G_LSEG(eu2->g.lseg_p);
	if( eu2->g.lseg_p != eu1->g.lseg_p )  {
		vect_t		dir;
		vect_t		dir_2;
		vect_t		dir_1;
		fastf_t		dot_2;
		fastf_t		dot_1;

		VSUB2( dir, eu1->vu_p->v_p->vg_p->coord, eu1->eumate_p->vu_p->v_p->vg_p->coord );
		VUNITIZE(dir);
		VMOVE( dir_2, eu2->g.lseg_p->e_dir );
		VUNITIZE( dir_2 );
		VMOVE( dir_1, eu1->g.lseg_p->e_dir );
		VUNITIZE( dir_1 );

		dot_2 = fabs(VDOT( dir, dir_2 ));
		dot_1 = fabs(VDOT( dir, dir_1 ));

		/* Dot product of 1 means colinear.  Take largest dot. */
		if( dot_2 > dot_1 )  {
			if (rt_g.NMG_debug & DEBUG_BASIC)
				rt_log("nmg_radial_join_eu() Make eu1 use geometry of eu2, s.d=%g, d.d=%g\n",
					acos(dot_2)*rt_radtodeg,
					acos(dot_1)*rt_radtodeg );
			best_eg = eu2->g.lseg_p;
		} else {
			if (rt_g.NMG_debug & DEBUG_BASIC)
				rt_log("nmg_radial_join_eu() Make eu2 use geometry of eu1, s.d=%g, d.d=%g\n",
					acos(dot_2)*rt_radtodeg,
					acos(dot_1)*rt_radtodeg );
			best_eg = eu1->g.lseg_p;
		}
	} else {
		best_eg = eu1->g.lseg_p;	/* both the same */
	}
@


11.5
log
@The comparison between eu1 and eu2 was being done in the wrong place,
before the final selection of eu1 had been made.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mesh.c,v 11.4 95/02/07 03:58:07 mike Exp Locker: mike $ (BRL)";
d109 1
d401 3
a403 1
		 * XXX Need to look back for last eu IN THIS SHELL.
d405 7
a411 1
		if (eu2->vu_p->v_p == eu1->vu_p->v_p)
@


11.4
log
@When joining two edges, it is necessary to decide which of the two
edge geometry structures most closely fits the actual geometry of
this particular edge.
This fixes the "m14.r" problem in the BIG WEDGE.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mesh.c,v 11.3 95/02/06 23:02:36 mike Exp Locker: mike $ (BRL)";
a260 8
		/* because faces are always created with counter-clockwise
		 * exterior loops and clockwise interior loops, radial
		 * edgeuses will never share the same vertex.  We thus make
		 * sure that eu2 is an edgeuse which might be radial to eu1
		 */
		if (eu2->vu_p->v_p == eu1->vu_p->v_p)
			eu2 = eu2->eumate_p;

d394 10
@


11.3
log
@Changed calls to nmg_moveeu() to nmg_je(), which is the real name
of that routine.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mesh.c,v 11.2 95/01/25 15:25:46 jra Exp Locker: mike $ (BRL)";
d112 1
d171 84
d414 1
d429 14
@


11.2
log
@Removed call to nmg_check_radial at end of nmg_radial_join_eu.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mesh.c,v 11.1 95/01/04 09:57:51 mike Rel4_4 Locker: jra $ (BRL)";
d330 1
a330 1
		nmg_moveeu(eu1, eu2);
d333 1
a333 1
			rt_log("After nmg_moveeu(), faces around original_eu1 are:\n");
@


11.1
log
@Release_4.4
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mesh.c,v 10.36 94/09/16 23:36:58 mike Exp $ (BRL)";
d95 5
a341 1
	/* This should catch errors, anyway */
a342 4
	if( nmg_check_radial(original_eu1, tol) )  {
		nmg_plot_lu_around_eu( "around", original_eu1, tol );
		rt_bomb("nmg_radial_join_eu(): radial orientation ERROR\n");
	}
@


10.36
log
@Added checks for edge_g_cnurb edge geometry showing up.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mesh.c,v 10.35 94/09/02 00:32:10 mike Exp Locker: mike $ (BRL)";
@


10.35
log
@Changed to new face geometry pointers (g.plane_p)
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mesh.c,v 10.34 94/08/10 18:53:40 gdurf Exp Locker: mike $ (BRL)";
d143 4
@


10.34
log
@fix include order
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mesh.c,v 10.33 1994/08/09 19:38:06 mike Exp gdurf $ (BRL)";
d233 1
a233 1
				if( fu1->f_p->fg_p == fur->f_p->fg_p )  {
d237 1
a237 1
							fu1->f_p->fg_p, fu1->f_p->flip, fur->f_p->flip );
d245 1
a245 1
					fu1, fu1->f_p, fu1->f_p->flip, fu1->f_p->fg_p );
d247 1
a247 1
					fu2, fu2->f_p, fu2->f_p->flip, fu2->f_p->fg_p );
d249 4
a252 4
					fur, fur->f_p, fur->f_p->flip, fur->f_p->fg_p );
				PLPRINT("  fu1", fu1->f_p->fg_p->N );
				PLPRINT("  fu2", fu2->f_p->fg_p->N );
				PLPRINT("  fur", fur->f_p->fg_p->N );
@


10.33
log
@Added GDurf's new "conf.h"
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mesh.c,v 10.32 94/07/06 16:24:32 jra Exp Locker: mike $ (BRL)";
d29 1
a30 1
#include "machine.h"
@


10.32
log
@Modified nmg_radial_join_eu to look for eu's from faceuses with same orientation.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mesh.c,v 10.31 94/04/20 20:48:36 mike Exp Locker: jra $ (BRL)";
d26 1
@


10.31
log
@Changed to using NMG_ARE_EUS_ADJACENT() macro.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mesh.c,v 10.30 94/04/20 20:13:19 mike Exp Locker: mike $ (BRL)";
d135 6
a140 2
		if( fu1->orientation != fu2->orientation )
			rt_bomb("nmg_radial_join_eu(): faceuse orientations don't match\n");
@


10.30
log
@Moved support routines out to nmg_info.c
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mesh.c,v 10.29 94/04/13 04:31:01 mike Exp Locker: mike $ (BRL)";
d122 2
a123 20
	if( eu1->vu_p->v_p == eu2->vu_p->v_p && 
	    eu1->eumate_p->vu_p->v_p == eu2->eumate_p->vu_p->v_p )  {
	    	/* Both edgeuses are oriented in the same direction */
	} else if( eu1->vu_p->v_p == eu2->eumate_p->vu_p->v_p &&
	    eu1->eumate_p->vu_p->v_p == eu2->vu_p->v_p )  {
		/*
		 *  Edgeuses are oriented in opposite directions.  This is OK.
	    	 *  Taking edgeuse mate here would be disasterous, because
	    	 *  that would switch over to the opposite faceuse!
	    	 */
	} else {
		/*
		 *  For coding convenience, let caller try to join any two edges.
		 *  If this is not a valid configuration, just ignore the request.
		 */
		if (rt_g.NMG_debug & DEBUG_MESH_EU ) {
			rt_log("nmg_radial_join_eu(eu1=x%x, eu2=x%x) edgeuses don't share both vertices, ignoring.\n", eu1, eu2);
		}
		return;
	}
@


10.29
log
@Added nmg_find_eu_leftvec(), made things use it.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mesh.c,v 10.28 94/03/17 23:38:49 mike Exp Locker: mike $ (BRL)";
a35 2

/* XXX move to nmg_info.c */
a36 131
 *			N M G _ E U _ 2 V E C S _ P E R P
 *
 *  Given an edgeuse, return two arbitrary unit-length vectors which
 *  are perpendicular to each other and to the edgeuse, such that
 *  they can be considered the +X and +Y axis, and the edgeuse is +Z.
 *  That is, X cross Y = Z.
 *
 *  Useful for erecting a coordinate system around an edge suitable
 *  for measuring the angles of other edges and faces with.
 */
void
nmg_eu_2vecs_perp( xvec, yvec, zvec, eu, tol )
vect_t		xvec;
vect_t		yvec;
vect_t		zvec;
CONST struct edgeuse	*eu;
CONST struct rt_tol	*tol;
{
	CONST struct vertex	*v1, *v2;
	fastf_t			len;

	NMG_CK_EDGEUSE(eu);
	v1 = eu->vu_p->v_p;
	NMG_CK_VERTEX(v1);
	v2 = eu->eumate_p->vu_p->v_p;
	NMG_CK_VERTEX(v2);
	if( v1 == v2 )  rt_bomb("nmg_eu_2vecs_perp() start&end vertex of edge are the same!\n");
	RT_CK_TOL(tol);

	NMG_CK_VERTEX_G(v1->vg_p);
	NMG_CK_VERTEX_G(v2->vg_p);
	VSUB2( zvec, v2->vg_p->coord, v1->vg_p->coord );
	len = MAGNITUDE(zvec);
	/* See if v1 == v2, within tol */
	if( len < tol->dist )  rt_bomb("nmg_eu_2vecs_perp(): 0-length edge (geometry)\n");
	len = 1 / len;
	VSCALE( zvec, zvec, len );

	mat_vec_perp( xvec, zvec );
	VCROSS( yvec, zvec, xvec );
}

/* XXX move to nmg_info.c */
/*
 *			N M G _ F I N D _ E U _ L E F T V E C
 *
 *  Given an edgeuse, if it is part of a faceuse, return the inward pointing
 *  "left" vector which points into the interior of this loop, and
 *  lies in the plane of the face.
 *
 *  This routine depends on the vertex ordering in an OT_SAME loopuse being
 *  properly CCW for exterior loops, and CW for interior (hole) loops.
 *
 *  Returns -
 *	-1	if edgeuse is not part of a faceuse.
 *	 0	if left vector successfully computed into caller's array.
 */
int
nmg_find_eu_leftvec( left, eu )
vect_t			left;
CONST struct edgeuse	*eu;
{
	CONST struct loopuse	*lu;
	CONST struct faceuse	*fu;
	vect_t			Norm;
	vect_t			edgevect;

	NMG_CK_EDGEUSE(eu);
	if( *eu->up.magic_p != NMG_LOOPUSE_MAGIC )  return -1;
	lu = eu->up.lu_p;
	NMG_CK_LOOPUSE(lu);
	if( *lu->up.magic_p != NMG_FACEUSE_MAGIC )  return -1;
	fu = lu->up.fu_p;
	NMG_CK_FACEUSE(fu);
	NMG_CK_FACE(fu->f_p);
	NMG_CK_FACE_G(fu->f_p->fg_p);

	/* Get unit length Normal vector for edgeuse's faceuse */
	NMG_GET_FU_NORMAL( Norm, fu );

	VSUB2( edgevect, eu->eumate_p->vu_p->v_p->vg_p->coord,
		eu->vu_p->v_p->vg_p->coord );
	VUNITIZE( edgevect );

	VCROSS( left, Norm, edgevect );
	return 0;
}

/* XXX move to nmg_info.c */
/*
 *			N M G _ M E A S U R E _ F U _ A N G L E
 *
 *  Return the angle in radians from the interior portion of the faceuse
 *  associated with edgeuse 'eu', measured in the coordinate system
 *  defined by xvec and yvec, which are known to be perpendicular to
 *  each other, and to the edge vector.
 *
 *  This is done by finding the "left-ward" vector for the edge in the
 *  face, which points into the interior of the face, and measuring
 *  the angle it forms relative to xvec and yvec.
 *
 *  Wire edges are indicated by always returning angle of -pi.
 *  That will be the only case for negative returns.
 */
double
nmg_measure_fu_angle( eu, xvec, yvec, zvec )
CONST struct edgeuse	*eu;
CONST vect_t		xvec;
CONST vect_t		yvec;
CONST vect_t		zvec;
{
	vect_t			left;
	double			ret;

	NMG_CK_EDGEUSE(eu);
	if( *eu->up.magic_p != NMG_LOOPUSE_MAGIC )  return -rt_pi;

	if( nmg_find_eu_leftvec( left, eu ) < 0 )  return -rt_pi;

	ret = rt_angle_measure( left, xvec, yvec );

#if 0
	if (rt_g.NMG_debug & DEBUG_MESH)  {
		rt_log("\tnmg_measure_fu_angle(x%x) = %g radians (%g deg)\n",
			eu, ret, ret * rt_radtodeg);
	}
#endif
	return ret;
}

/*
d133 8
a140 1
		rt_bomb("nmg_radial_join_eu(): edgeuses don't share both vertices\n");
@


10.28
log
@The FLIP eu2 code was not helping.
But Test17 still bombs here.
@
text
@d5 3
d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mesh.c,v 10.27 94/03/02 18:59:07 mike Exp Locker: mike $ (BRL)";
d35 3
d81 1
d83 46
a149 4
	CONST struct loopuse	*lu;
	CONST struct faceuse	*fu;
	vect_t			Norm;
	vect_t			edgevect;
a154 7
	lu = eu->up.lu_p;
	NMG_CK_LOOPUSE(lu);
	if( *lu->up.magic_p != NMG_FACEUSE_MAGIC )  return -rt_pi;
	fu = lu->up.fu_p;
	NMG_CK_FACEUSE(fu);
	NMG_CK_FACE(fu->f_p);
	NMG_CK_FACE_G(fu->f_p->fg_p);
d156 1
a156 2
	/* get Normal vectors for edgeuse faceUSEs */
	NMG_GET_FU_NORMAL( Norm, fu );
a157 10
	VSUB2( edgevect, eu->eumate_p->vu_p->v_p->vg_p->coord, eu->vu_p->v_p->vg_p->coord );
	VUNITIZE( edgevect );

	/* Make sure the edge is aligned with +Z or -Z */
	ret = fabs(VDOT(edgevect, zvec)) - 1;
	if( !NEAR_ZERO(ret, 1.0e-6) )
		rt_log("nmg_measure_fu_angle() WARNING: bad edge/zvec dot=%g\n", ret);

	VCROSS( left, Norm, edgevect );

d473 3
a475 1
	if( nmg_check_radial(original_eu1, tol) )
d477 1
@


10.27
log
@If faces are not fused and WARNING is issued, try to fuse now.
If it fails, bomb.
Very good for debugging.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mesh.c,v 10.26 94/02/10 18:47:45 mike Exp Locker: mike $ (BRL)";
d191 1
a191 1
 *  so the issue of preserving faceuse orientation parity
d206 2
d229 5
a233 4
	    	/* Edgeuses are oriented in opposite directions */
		if (rt_g.NMG_debug & DEBUG_MESH_EU)
			rt_log("nmg_radial_join_eu() FLIP eu2\n");
	    	eu2 = eu2->eumate_p;
d244 8
d285 1
a285 1
			struct faceuse	*fu1, *fu2, *fur;
@


10.26
log
@Changed from EUPRINT to nmg_euprint() call.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mesh.c,v 10.25 94/02/01 23:22:31 mike Exp Locker: mike $ (BRL)";
d350 8
a357 1
				rt_log("  skipping\n");
@


10.25
log
@Made nmg_mesh_two_faces() a non-static.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mesh.c,v 10.24 94/01/27 05:25:29 mike Exp Locker: mike $ (BRL)";
d250 2
a251 2
		EUPRINT("\tJoining", eu1);
		EUPRINT("\t     to", eu2);
@


10.24
log
@Wireproofing.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mesh.c,v 10.23 94/01/25 06:59:53 mike Exp Locker: mike $ (BRL)";
d439 1
a439 1
static int
@


10.23
log
@Improved checking for, and messages about, unfused faces.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mesh.c,v 10.20 93/12/16 05:34:32 mike Exp Locker: mike $ (BRL)";
d194 2
d205 1
d261 1
d278 9
d288 19
a306 2
			fu2 = nmg_find_fu_of_eu(eu2);
			fur = nmg_find-fu_of_eu(eu1->radial_p);
d311 6
a316 2
			/* Can't check shared fg here, need to check sides */

d319 1
a319 1
			absr = nmg_measure_fu_angle( eu1->radial_p, xvec, yvec, zvec );
d376 2
a377 2
			if( eu1 == eu1->radial_p->eumate_p )  break;
			eu1 = eu1->radial_p->eumate_p;
d379 3
d394 1
d408 2
a409 1
		 *  This should insert eu2 between eu1 and eu1->radial_p.
d633 1
d635 5
@


10.22
log
@Wire edge check
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mesh.c,v 10.21 94/01/13 20:20:47 mike Exp Locker: mike $ (BRL)";
a237 6
	/* XXX It would be nice if there was a convention for where to include these guys, but... */
	if( *eu1->up.magic_p != NMG_LOOPUSE_MAGIC )
		rt_bomb("nmg_radial_join_eu() eu1 not part of a loopuse\n");
	if( *eu2->up.magic_p != NMG_LOOPUSE_MAGIC )
		rt_bomb("nmg_radial_join_eu() eu2 not part of a loopuse\n");

d274 3
a276 3
			fu1 = eu1->up.lu_p->up.fu_p;
			fu2 = eu2->up.lu_p->up.fu_p;
			fur = eu1->radial_p->up.lu_p->up.fu_p;
d294 26
d329 9
a337 1
			if( code != 0 )  break;
a350 20
		}
		/*
		 *  XXX If abs1 == absr within a very tight tolerance,
		 *  then it's necessary to be sure that the face gets
		 *  interted on the proper side of eu1.
		 *  Really, these two faces should be fused together here
		 *  (or somewhere).
		 */
		if( code < 0 ) {
			struct faceuse	*fu1, *fu2;
			fu1 = eu1->up.lu_p->up.fu_p;
			fu2 = eu2->up.lu_p->up.fu_p;
			NMG_CK_FACEUSE(fu1);
			NMG_CK_FACEUSE(fu2);
/* XXX This check should be done before nmg_angle_in_wedge() call above. */
			if( fu1->f_p->fg_p == fu2->f_p->fg_p )  {
				rt_log("nmg_radial_join_eu: NOTICE: 2 faces already share geometry,  horay!\n");
			} else {
				rt_log("nmg_radial_join_eu: WARNING 2 faces should have been fused, may be ambiguous. abs1=%e, absr=%e, asb2=%e\n", abs1*rt_radtodeg, absr*rt_radtodeg, abs2*rt_radtodeg);
			}
@


10.21
log
@Improved debugging potential slightly.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mesh.c,v 10.20 93/12/16 05:34:32 mike Exp Locker: mike $ (BRL)";
d86 3
d105 1
d108 1
@


10.20
log
@Added more descriptive messages, on the way to doing something smarter.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mesh.c,v 10.19 93/12/03 03:35:32 mike Exp Locker: mike $ (BRL)";
a31 3
/* XXX move to raytrace.h */
RT_EXTERN(double nmg_measure_fu_angle, (CONST struct edgeuse *eu, CONST vect_t xvec, CONST vect_t yvec, CONST vect_t zvec));

d269 1
a269 1
		/* find a place to insert eu2 on eu1's edge */
d271 1
a271 1
			/* XXX If 2 faces share face geom, this is the place */
d273 11
d306 1
d348 2
a349 1
		if (rt_g.NMG_debug & DEBUG_MESH_EU)
d353 1
@


10.19
log
@Access to plane equation / surface normal in face_geometry structure
is now done through macros NMG_GET_FU_PLANE() NMG_GET_FU_NORMAL(),
which honor the f->flip flag.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mesh.c,v 10.18 93/09/15 02:35:18 mike Exp Locker: mike $ (BRL)";
d274 2
d318 11
a328 1
			rt_log("nmg_radial_join_eu: WARNING 2 faces should have been fused, may be ambiguous.\n");
@


10.18
log
@Added extra checking.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mesh.c,v 10.17 93/08/19 00:07:28 mike Exp Locker: mike $ (BRL)";
d113 1
a113 5
	if (fu->orientation == OT_SAME) {
		VMOVE(Norm, fu->f_p->fg_p->N);
	} else if (fu->orientation == OT_OPPOSITE){
		VREVERSE(Norm, fu->f_p->fg_p->N);
	} else rt_bomb("bad fu orientation\n");
@


10.17
log
@Added tol arg to some routines, fiddled with debug bits.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mesh.c,v 10.16 93/08/18 21:29:19 mike Exp Locker: mike $ (BRL)";
d239 6
@


10.16
log
@Added 'tol' parameter to face meshing (sorting) routines.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mesh.c,v 10.15 93/08/13 15:23:59 mike Exp Locker: mike $ (BRL)";
d132 1
a132 1
	if (rt_g.NMG_debug & DEBUG_MESH_EU)  {
d227 2
a228 1
		rt_log("nmg_radial_join_eu() FLIP eu2\n");
d236 2
a237 1
	if( rt_pt3_pt3_equal( eu1->vu_p->v_p->coord, eu1->eumate_p->vu_p->v_p->coord, tol ) )
d245 1
a245 1
	if (rt_g.NMG_debug & (DEBUG_MESH_EU|DEBUG_MESH) ) {
d252 1
a252 1
		nmg_pr_fu_around_eu_vecs( eu1, xvec, yvec, zvec );
d254 1
a254 1
		nmg_pr_fu_around_eu_vecs( eu2, xvec, yvec, zvec );
d276 1
a276 1
			if (rt_g.NMG_debug & (DEBUG_MESH_EU|DEBUG_MESH) )  {
d290 1
a290 1
			if (rt_g.NMG_debug & (DEBUG_MESH_EU|DEBUG_MESH) )
d338 1
a338 1
			nmg_pr_fu_around_eu_vecs( original_eu1, xvec, yvec, zvec );
a339 5
		/* This will catch the errors, anyway */
		if( nmg_check_radial(eu1) )
			rt_bomb("nmg_radial_join_eu(): radial orientation ERROR 1\n");
		if( nmg_check_radial(eu2) )
			rt_bomb("nmg_radial_join_eu(): radial orientation ERROR 2\n");
d345 5
d460 1
a460 1
    	if (rt_g.NMG_debug & DEBUG_MESH && rt_g.NMG_debug & DEBUG_PLOTEM) {
d465 1
a465 1
	if (rt_g.NMG_debug & DEBUG_MESH)
d469 1
a469 1
	if (rt_g.NMG_debug & DEBUG_MESH)
d473 1
a473 1
	if (rt_g.NMG_debug & DEBUG_MESH)
d477 1
a477 1
    	if (rt_g.NMG_debug & DEBUG_MESH && rt_g.NMG_debug & DEBUG_PLOTEM) {
d533 3
@


10.15
log
@Changed over to new way of deciding things, eliminated nmg_measure_2fu_angle().
This seems to work, although the co-planar face handling needs to be
improved.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mesh.c,v 10.14 93/08/13 14:39:29 mike Exp Locker: mike $ (BRL)";
d47 1
a47 1
nmg_eu_2vecs_perp( xvec, yvec, zvec, eu )
d52 1
d55 1
d63 1
a64 2
	/* XXX Could really use 'tol' arg here, to see if v1~=v2, within tol */

d68 5
a72 1
	VUNITIZE( zvec );
d198 4
a201 2
nmg_radial_join_eu(eu1, eu2)
struct edgeuse *eu1, *eu2;
d217 1
d233 1
a233 1
	if( eu1->vu_p->v_p == eu1->eumate_p->vu_p->v_p )  rt_bomb("nmg_radial_join_eu(): 0 length edge\n");
d235 3
d241 1
a241 1
	nmg_eu_2vecs_perp( xvec, yvec, zvec, original_eu1 );
d361 1
a361 1
nmg_mesh_two_faces(fu1, fu2)
d363 1
d376 1
d427 1
a427 1
						nmg_radial_join_eu(eu1, eu2);
d447 4
a450 2
nmg_mesh_faces(fu1, fu2)
struct faceuse *fu1, *fu2;
d456 1
d465 1
a465 1
	count += nmg_mesh_two_faces( fu1, fu1 );
d469 1
a469 1
	count += nmg_mesh_two_faces( fu2, fu2 );
d473 1
a473 1
	count += nmg_mesh_two_faces( fu1, fu2 );
d487 1
a487 1
nmg_mesh_face_shell( fu1, s )
d490 1
d497 1
d502 2
a503 2
		count += nmg_mesh_two_faces( fu2, fu2 );
		count += nmg_mesh_two_faces( fu1, fu2 );
d519 1
a519 1
nmg_mesh_shell_shell( s1, s2 )
d522 1
d530 1
d535 1
a535 1
		count += nmg_mesh_two_faces( fu2, fu2 );
d543 1
a543 1
		count += nmg_mesh_two_faces( fu1, fu1 );
d548 1
a548 1
			count += nmg_mesh_two_faces( fu1, fu2 );
@


10.14
log
@This version seems to put the faces in the right place, at least!
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mesh.c,v 10.13 93/08/12 22:58:01 mike Exp Locker: mike $ (BRL)";
a32 1
RT_EXTERN(double nmg_measure_2fu_angle, (CONST struct edgeuse *eu1, CONST struct edgeuse *eu2));
a34 1

d36 1
a36 1
 *			N M G _ M E A S U R E _ 2 F U _ A N G L E
a37 178
 *  Return the angle (in radians) from the interior portion of the
 *  faceuse associated with eu1, to the interior portion of the faceuse
 *  associated with eu2, around the common (geometric) edge
 *  shared by eu1 and eu2.
 *
 *  This is done by finding a "left"ward (into-the-face-ward) pointing
 *  vector for each faceuse, and measuring the angle between them.
 *
 *  Calling this routine with two common edgeuses of one face
 *  (different faceuses) should always return PI (180 degrees).
 *
 *  The return will be the same, regardless of whether eu2 or eu2->eumate_p
 *  is passed, because the interior of that face(use) is the same.
 */
double nmg_measure_2fu_angle(eu1, eu2)
CONST struct edgeuse *eu1, *eu2;
{
 	vect_t		Norm1, Norm2;
 	CONST fastf_t	*pt, *ptmate;
 	point_t		test_pt;
 	vect_t		edgevect1;
 	vect_t		edgevect2;
 	vect_t		left1;
	vect_t		left2;
	vect_t		right1;
 	vect_t		right2;
 	CONST struct loopuse	*lu1, *lu2;
 	CONST struct faceuse	*fu1, *fu2;
 	register CONST struct edgeuse *eutmp;
 	CONST struct vertex	*v1a, *v1b;
	CONST struct vertex	*v2a, *v2b;
 	double		ret;

	NMG_CK_EDGEUSE(eu1);
	lu1 = eu1->up.lu_p;
	NMG_CK_LOOPUSE(lu1);
	fu1 = lu1->up.fu_p;
	NMG_CK_FACEUSE(fu1);
	NMG_CK_FACE(fu1->f_p);
	NMG_CK_FACE_G(fu1->f_p->fg_p);

	NMG_CK_EDGEUSE(eu2);
	lu2 = eu2->up.lu_p;
	NMG_CK_LOOPUSE(lu2);
	fu2 = lu2->up.fu_p;
	NMG_CK_FACEUSE(fu2);
	NMG_CK_FACE(fu2->f_p);
	NMG_CK_FACE_G(fu2->f_p->fg_p);

	NMG_CK_VERTEXUSE(eu1->vu_p);
	v1a = eu1->vu_p->v_p;
	NMG_CK_VERTEX(v1a);

	NMG_CK_VERTEXUSE(eu1->eumate_p->vu_p);
	v1b = eu1->eumate_p->vu_p->v_p;
	NMG_CK_VERTEX(v1b);

	NMG_CK_VERTEXUSE(eu2->vu_p);
	v2a = eu2->vu_p->v_p;
	NMG_CK_VERTEX(v2a);

	NMG_CK_VERTEXUSE(eu2->eumate_p->vu_p);
	v2b = eu2->eumate_p->vu_p->v_p;
	NMG_CK_VERTEX(v2b);

#if 0
	if (rt_g.NMG_debug & DEBUG_MESH_EU) {
		NMG_CK_VERTEX_G(v1a->vg_p);
		pt = v1a->vg_p->coord;

		NMG_CK_VERTEX_G(v1b->vg_p);
		ptmate = v1b->vg_p->coord;

		eutmp = RT_LIST_PLAST_CIRC(edgeuse, eu1);
		NMG_CK_EDGEUSE(eutmp);
		NMG_CK_VERTEXUSE(eutmp->vu_p);
		NMG_CK_VERTEX(eutmp->vu_p->v_p);
		NMG_CK_VERTEX_G(eutmp->vu_p->v_p->vg_p);

		VMOVE(test_pt, eutmp->vu_p->v_p->vg_p->coord);

		rt_log("Angle\t(%g, %g, %g ->) %g, %g, %g -> %g, %g, %g\n",
			test_pt[0], test_pt[1], test_pt[2],
			pt[0], pt[1], pt[2],
			ptmate[0], ptmate[1], ptmate[2]);

		NMG_CK_VERTEX_G(v2a->vg_p);
		pt = v2a->vg_p->coord;
		NMG_CK_VERTEX_G(v2b->vg_p);
		ptmate = v2b->vg_p->coord;

		eutmp = RT_LIST_PLAST_CIRC(edgeuse, eu2);
		NMG_CK_EDGEUSE(eutmp);
		NMG_CK_VERTEXUSE(eutmp->vu_p);
		NMG_CK_VERTEX(eutmp->vu_p->v_p);
		NMG_CK_VERTEX_G(eutmp->vu_p->v_p->vg_p);

		VMOVE(test_pt, eutmp->vu_p->v_p->vg_p->coord);

		rt_log("\t(%g, %g, %g ->) %g, %g, %g -> %g, %g, %g\n",
			test_pt[0], test_pt[1], test_pt[2],
			pt[0], pt[1], pt[2],
			ptmate[0], ptmate[1], ptmate[2]);

		nmg_pr_orient(fu1->orientation, "\teu1");
		nmg_pr_orient(fu2->orientation, "\teu2");
	}
#endif

	/* get Normal vectors for edgeuse faceUSEs */
	if (fu1->orientation == OT_SAME) {
		VMOVE(Norm1, fu1->f_p->fg_p->N);
	} else if (fu1->orientation == OT_OPPOSITE){
		VREVERSE(Norm1, fu1->f_p->fg_p->N);
	} else rt_bomb("bad fu1 orientation\n");

	if (fu2->orientation == OT_SAME) {
		VMOVE(Norm2, fu2->f_p->fg_p->N);
	} else if (fu2->orientation == OT_OPPOSITE){
		VREVERSE(Norm2, fu2->f_p->fg_p->N);
	} else rt_bomb("bad fu2 orientation\n");

	/*
	 *  Get direction vector for each edgeuse.
	 *  These may happen to be pointed in same or opposite direction.
	 *  Regardless, their only purpose is to get the 'left' vectors.
	 */
	pt = v2a->vg_p->coord;
	ptmate = v2b->vg_p->coord;
	VSUB2(edgevect2, ptmate, pt);
	VUNITIZE(edgevect2);

	pt = v1a->vg_p->coord;
	ptmate = v1b->vg_p->coord;
	VSUB2(edgevect1, ptmate, pt);
	VUNITIZE(edgevect1);

	/* XXX It would be a good double-check here to make sure that
	 * XXX edgevect1 and edgevect2 dot to either 1 or -1.  What dot tol to use?
	 */
	ret = fabs(VDOT(edgevect1, edgevect2)) - 1;
	if( !NEAR_ZERO(ret, 1.0e-6) )
		rt_log("nmg_measure_2fu_angle() WARNING: bad edge dot=%g\n", ret);

	/*
	 * Because edgeuses are oriented, and run CCW for an exterior
	 * face loop, crossing the face normal with the edge vector will
	 * give a vector which lies in the plane of the face and
	 * points "left", towards the interior of the faceloop.
	 */
	VCROSS(left1, Norm1, edgevect1);
	VCROSS(left2, Norm2, edgevect2);

	VREVERSE( right1, left1 );
	VREVERSE( right2, left2 );

	/*
	 *  Define the plane of rotation about the edge.
	 *    +X = right1
	 *    +Y = face1 normal
	 *   (+Z = edge1 vector)
	 *
	 *  The angle to the other face is the angle from right1 to right2,
	 *  lieing in the plane defined by right1 and the normal.
	 */
	ret = rt_angle_measure( right2, right1, fu1->f_p->fg_p->N );

#if 0
/* Put this one back in */
	if (rt_g.NMG_debug & DEBUG_MESH_EU)  {
		rt_log("\tnmg_measure_2fu_angle(x%x, x%x) = %g radians (%g deg)\n",
			eu1, eu2, ret, ret * rt_radtodeg);
	}
#endif
	return ret;
}

/*
a70 3
VPRINT("xvec", xvec);
VPRINT("yvec", yvec);
VPRINT("zvec", zvec);
d198 1
a198 4
	fastf_t		angle12;	/* Angle from eu1 to eu2 */
	fastf_t		angle1r;	/* Angle from eu1 to eu1's radial */
	fastf_t		angler2;	/* Angle from eu1's radial to eu2 */
	int	iteration1, iteration2;
d227 3
a258 4
			angle12 = nmg_measure_2fu_angle(eu1, eu2);
			angle1r = nmg_measure_2fu_angle(eu1, eu1->radial_p);
			angler2 = nmg_measure_2fu_angle(eu1->radial_p->eumate_p, eu2);

a263 2
				rt_log("  angle12=%g, angle1r=%g, angler2=%g\n",
					angle12*rt_radtodeg, angle1r*rt_radtodeg, angler2*rt_radtodeg );
a290 1
			rt_log("angle12=%e, angle1r=%e\n", angle12, angle1r);
d294 1
a294 2
		 *  Here, angle12 > angle1r.
		 *  XXX If angle12 == angle1r within a very tight tolerance,
a298 1
		 *  XXX What tolerance to use here?  (radians)
d301 1
a301 1
			rt_log("nmg_radial_join_eu: WARNING 2 faces should have been fused.\n");
d313 1
a313 1
			rt_log("joining eu1=x%x eu2=x%x with angle12=%g, angle1r=%g\n",
d315 1
a315 1
				angle12*rt_radtodeg, angle1r*rt_radtodeg);
d324 1
a324 1
			rt_log("Now, faces around original_eu1:\n");
@


10.13
log
@Can now see the problem, anyway.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mesh.c,v 10.12 93/08/12 21:44:03 mike Exp Locker: mike $ (BRL)";
d309 1
d314 1
d319 41
d424 1
a424 1
		nmg_pr_fu_around_eu( eu2, xvec, yvec, zvec );
d428 1
d465 4
a469 7
			/* XXX I believe the problem here is with this (non-circular)
			 * relation ('if' test).
			 * How about (angle12>angle1r) && (angle12<angle1r+2pi)
			 */
			/* Search termination condition */
			if( angle12 > angle1r )  break;

d492 1
a492 1
		if( NEAR_ZERO( angle12-angle1r, 1.0e-6 ) ) {
d509 4
a512 1
		/* make eu2 radial to eu1 */
@


10.12
log
@Added more debugging, still not working well.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mesh.c,v 10.11 93/07/24 02:16:31 mike Exp Locker: mike $ (BRL)";
d34 1
d218 99
d342 4
d370 2
d379 1
a379 1
		nmg_pr_fu_around_eu( eu1 );
d381 1
a381 1
		nmg_pr_fu_around_eu( eu2 );
d383 1
a386 8
#if 0
		/* For early debugging only, reset position to original.
		 * Not only inefficient, but can give different results,
		 * but it makes examining the printouts easier.
		 */
		first_eu1 = eu1 = original_eu1;
		rt_log("Reset eu1 to x%x\n", original_eu1);
#endif
d402 4
d409 4
d415 7
d473 1
a473 1
			nmg_pr_fu_around_eu( original_eu1 );
@


10.11
log
@Added debugging, made angle measurement be right.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mesh.c,v 10.10 93/07/24 00:57:58 mike Exp Locker: mike $ (BRL)";
d238 3
a240 1
	fastf_t angle1, angle2;
d264 2
d280 8
d298 4
d303 4
a306 2
		angle1 = nmg_measure_2fu_angle(eu1, eu2);
		angle2 = nmg_measure_2fu_angle(eu1, eu1->radial_p);
d308 6
a313 2
		if (rt_g.NMG_debug & (DEBUG_MESH_EU|DEBUG_MESH) )
			rt_log("  angle1=%g, angle2=%g\n" , angle1 , angle2 );
a314 6

		/* XXX I believe the problem here is with this (non-circular)
		 * relation ('if' test).
		 * How about (angle1>angle2) && (angle1<angle2+2pi)
		 */
		for ( iteration2=0; (angle1 > angle2) && iteration2 < 10000; iteration2++ ) {
a322 6
			angle1 = nmg_measure_2fu_angle(eu1, eu2);
			angle2 = nmg_measure_2fu_angle(eu1, eu1->radial_p);
			if (rt_g.NMG_debug & (DEBUG_MESH_EU|DEBUG_MESH) ) {
				rt_log("  angle1=%g, angle2=%g\n",
					angle1*rt_radtodeg , angle2*rt_radtodeg );
			}
d325 1
a325 1
			rt_log("angle1=%e, angle2=%e\n", angle1, angle2);
d329 2
a330 2
		 *  Here, angle1 <= angle2.
		 *  XXX If angle1 == angle2 within a very tight tolerance,
d337 1
a337 1
		if( NEAR_ZERO( angle1-angle2, 1.0e-6 ) ) {
d350 3
a352 2
			rt_log("joining edgeuses with angle1(to eu2):%g angle2(to eu1->radial):%g\n",
				angle1, angle2);
@


10.10
log
@Changed get_angle() to nmg_measure_2fu_angle().
Now returns angle in radians, rather than Butlerians.
Added some error checking to nmg_radial_join_eu()
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mesh.c,v 10.9 93/07/23 20:30:51 mike Exp Locker: mike $ (BRL)";
d32 4
d49 3
d56 1
a56 1
 	plane_t Norm1, Norm2;
d104 2
a105 1
	if (rt_g.NMG_debug & DEBUG_MESH) {
d146 1
d148 1
a148 1
	/* get Normal vectors for edgeuse faces */
d150 1
a150 1
		VMOVEN(Norm1, fu1->f_p->fg_p->N, 4);
a152 1
		Norm1[3] = -fu1->f_p->fg_p->N[3];
d156 1
a156 1
		VMOVEN(Norm2, fu2->f_p->fg_p->N, 4);
a158 1
		Norm2[3] = -fu2->f_p->fg_p->N[3];
d180 1
a180 1
	if( !NEAR_ZERO(ret, 1.0e-8) )
a191 1
	/* Use right as +X, Norm as +Y, to ensure angle is measured CCW */
d195 10
a204 3
	/* Calculate the angle between the two faces */
	/* Use normal as +X, left as +Y to ensure angle is CCW, from 0 */
	ret = rt_angle_measure( right2, Norm1, left1 );
d206 3
a208 1
	if (rt_g.NMG_debug & DEBUG_MESH)  {
d212 1
d236 2
a237 1
	struct edgeuse *nexteu;
a239 1
	int	flip = 0;
a252 1
	    	flip = 0;
d256 1
a256 2
rt_log("nmg_radial_join_eu() FLIP eu2\n");
	    	flip = 1;
d275 1
d294 4
d299 1
a299 1
			if( iteration2 > 9997 )  rt_g.NMG_debug |= DEBUG_MESH;
d309 4
a312 2
			if (rt_g.NMG_debug & (DEBUG_MESH_EU|DEBUG_MESH) )
				rt_log("  angle1=%g, angle2=%g\n" , angle1 , angle2 );
d339 1
a339 1
		if (rt_g.NMG_debug & DEBUG_MESH)
d346 3
a348 3
		if (rt_g.NMG_debug & DEBUG_MESH)  {
			rt_log("Now, faces around eu1:\n");
			nmg_pr_fu_around_eu( eu1 );
d360 1
d405 1
a405 1
			if (rt_g.NMG_debug & DEBUG_MESH_EU)  {
d421 1
a421 1
					if (rt_g.NMG_debug & DEBUG_MESH_EU) {
@


10.9
log
@JRA modification to use rt_angle_measure() to compute actual angle.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mesh.c,v 10.8 93/03/24 02:25:53 mike Exp $ (BRL)";
d32 2
a33 1
/*			G E T _ A N G L E
d35 4
a38 2
 *	find the angle between the planes of two edgeuses.
 *	The angle is expressed as a number between 0 and 4 (Butlerians ;-).
d40 5
a44 5
 *			       1.0
 *				|
 *			2.0 ----+--- 0.0 or 4.0
 *				|
 *			       3.0
d46 2
a47 2
static double get_angle(eu1, eu2)
struct edgeuse *eu1, *eu2;
d49 15
a63 8
	double cosangle, dist;
	plane_t Norm1, Norm2;
	pointp_t pt, ptmate;
	point_t test_pt;
	vect_t veu1, veu2, plvec1, plvec2;
	vect_t ydir;
	struct faceuse	*fu1, *fu2;
	register struct edgeuse *eutmp;
d66 3
a68 2
	NMG_CK_LOOPUSE(eu1->up.lu_p);
	fu1 = eu1->up.lu_p->up.fu_p;
d74 3
a76 2
	NMG_CK_LOOPUSE(eu2->up.lu_p);
	fu2 = eu2->up.lu_p->up.fu_p;
d81 16
d98 2
a99 4
		NMG_CK_VERTEXUSE(eu1->vu_p);
		NMG_CK_VERTEX(eu1->vu_p->v_p);
		NMG_CK_VERTEX_G(eu1->vu_p->v_p->vg_p);
		pt = eu1->vu_p->v_p->vg_p->coord;
d101 2
a102 4
		NMG_CK_VERTEXUSE(eu1->eumate_p->vu_p);
		NMG_CK_VERTEX(eu1->eumate_p->vu_p->v_p);
		NMG_CK_VERTEX_G(eu1->eumate_p->vu_p->v_p->vg_p);
		ptmate = eu1->eumate_p->vu_p->v_p->vg_p->coord;
d117 4
a120 1
		pt = eu2->vu_p->v_p->vg_p->coord;
a121 6
		NMG_CK_EDGEUSE(eu2);
		NMG_CK_VERTEXUSE(eu2->vu_p);
		NMG_CK_VERTEX(eu2->vu_p->v_p);
		NMG_CK_VERTEX_G(eu2->vu_p->v_p->vg_p);
		ptmate = eu2->eumate_p->vu_p->v_p->vg_p->coord;

d154 4
a157 2
	/* get vectors for edgeuses (edgeuse mates should point
	 * in opposite directions)
d159 4
a162 3
	pt = eu2->vu_p->v_p->vg_p->coord;
	ptmate = eu2->eumate_p->vu_p->v_p->vg_p->coord;
	VSUB2(veu2, ptmate, pt); VUNITIZE(veu2);
d164 4
a167 3
	pt = eu1->vu_p->v_p->vg_p->coord;
	ptmate = eu1->eumate_p->vu_p->v_p->vg_p->coord;
	VSUB2(veu1, ptmate, pt); VUNITIZE(veu1);
d169 2
a170 2
	/* Get vectors which lie in the plane of each face,
	 * and point left, towards the interior of the CCW loop.
d172 3
a174 3
	VCROSS(plvec1, Norm1, veu1);
	VCROSS(plvec2, Norm2, veu2);
	VCROSS(ydir, plvec1 , veu1 );
d176 8
a183 3
	VUNITIZE(plvec1);
	VUNITIZE(plvec2);
	VUNITIZE(ydir);
d185 3
a187 2
	/* calculate the angle between the two faces */
	return( rt_angle_measure( plvec2 , plvec1 , ydir ) );
d189 3
a191 1
	cosangle = VDOT(plvec1, plvec2);
d193 3
a195 7
	VADD2(test_pt, pt, plvec2);
	dist = DIST_PT_PLANE(test_pt, Norm1);

	if (rt_g.NMG_debug & DEBUG_MESH) {
		VPRINT("\tplvec1", plvec1);
		VPRINT("\tplvec2", plvec2);
		rt_log("\tCosangle:%g", cosangle);
d197 1
a197 26

	if (dist > 0.0) {
		/* the point is in the direction of the normal vector
		 * from the face of eu1.  Hence the angle between the faces
		 * is between 0 and 180 degrees
		 */
		cosangle = 1.0 - cosangle;
	} else if (dist < 0.0) {
		/* the point is in the opposite direction from the normal
		 * vector of the face of eu1.  Hence the angle between the
		 * faces is between 180 and 360 degrees.
		 */
		cosangle = 3.0 + cosangle;
	} else if (cosangle < 0.0) {
		/* the angle is 180 degrees, or 2 butlerians */
		cosangle = 2.0;
	} else {
		/* the angle is 0 degrees, or 0 butlerians */
		cosangle = 0.0;
	}

	if (rt_g.NMG_debug & DEBUG_MESH)
	rt_log("\tdist:%g\n\tAngle between faces is %g butlerians (0<=X<=4)\n", 
		dist, cosangle);

	return(cosangle);
d210 5
d223 1
d233 12
a244 2
	if( (eu1->vu_p->v_p != eu2->vu_p->v_p && eu1->vu_p->v_p != eu2->eumate_p->vu_p->v_p) ||
	    (eu1->eumate_p->vu_p->v_p != eu2->vu_p->v_p && eu1->eumate_p->vu_p->v_p != eu2->eumate_p->vu_p->v_p) )
d246 1
d272 2
a273 2
		angle1 = get_angle(eu1, eu2);
		angle2 = get_angle(eu1, eu1->radial_p);
d288 2
a289 2
			angle1 = get_angle(eu1, eu2);
			angle2 = get_angle(eu1, eu1->radial_p);
d297 12
d312 1
a312 1
		 * edgeuse to move.
a317 1

d325 11
a335 1
		/* get ready to move the next edgeuse */
@


10.8
log
@Tidy up code.
Changed name to nmg_radial_join_eu()
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mesh.c,v 10.7 93/03/22 23:10:59 mike Exp Locker: mike $ (BRL)";
d43 1
a43 1
static fastf_t get_angle(eu1, eu2)
d51 1
d149 1
d153 1
d155 3
d233 4
d254 4
d269 2
@


10.7
log
@Added nmg_mesh_shell_shell() and nmg_mesh_face_shell(), both of which
return the number of edges meshed.
cmp_mesh_eu() was replaced with nmg_mesh_two_faces().
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mesh.c,v 10.6 93/03/12 20:32:21 mike Exp Locker: mike $ (BRL)";
d51 1
d56 5
a60 1
	NMG_CK_FACEUSE(eu1->up.lu_p->up.fu_p);
d63 4
a66 1
	NMG_CK_FACEUSE(eu2->up.lu_p->up.fu_p);
a67 1

d113 2
a114 2
		nmg_pr_orient(eu1->up.lu_p->up.fu_p->orientation, "\teu1");
		nmg_pr_orient(eu2->up.lu_p->up.fu_p->orientation, "\teu2");
a116 1

d118 5
a122 5
	if (eu1->up.lu_p->up.fu_p->orientation == OT_SAME) {
		VMOVEN(Norm1, eu1->up.lu_p->up.fu_p->f_p->fg_p->N, 4);
	} else if (eu1->up.lu_p->up.fu_p->orientation == OT_OPPOSITE){
		VREVERSE(Norm1, eu1->up.lu_p->up.fu_p->f_p->fg_p->N);
		Norm1[3] = -eu1->up.lu_p->up.fu_p->f_p->fg_p->N[3];
d125 5
a129 5
	if (eu2->up.lu_p->up.fu_p->orientation == OT_SAME) {
		VMOVEN(Norm2, eu2->up.lu_p->up.fu_p->f_p->fg_p->N, 4);
	} else if (eu2->up.lu_p->up.fu_p->orientation == OT_OPPOSITE){
		VREVERSE(Norm2, eu2->up.lu_p->up.fu_p->f_p->fg_p->N);
		Norm2[3] = -eu2->up.lu_p->up.fu_p->f_p->fg_p->N[3];
a182 2


d191 1
a191 1
 *			N M G _ J O I N _ E U
d193 1
a193 1
 *	Join two edgeuses that share the same vertices to same edge,
d197 3
d201 2
a202 1
static void nmg_join_eu(eu1, eu2)
d219 1
a219 1
		rt_bomb("nmg_join_eu(): edgeuses don't share both vertices\n");
d222 3
d250 1
a250 1
				rt_bomb("nmg_join_eu():  went full circle, no face insertion point.\n");
d258 1
a258 1
			rt_bomb("nmg_join_eu: infinite loop (2)\n");
d280 1
a280 1
	if( iteration1 >= 10000 )  rt_bomb("nmg_join_eu:  infinite loop (1)\n");
d357 1
a357 1
						nmg_join_eu(eu1, eu2);
@


10.6
log
@Changed to rt_bomb.
@
text
@d6 1
a6 1
 *  Author -
d8 1
d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mesh.c,v 10.5 93/03/11 06:20:15 mike Exp Locker: mike $ (BRL)";
d213 1
a213 1
	if (rt_g.NMG_debug & DEBUG_MESH_EU) {
d273 1
a273 1
 *			C M P _ M E S H _ E U
d275 5
a279 3
 *	compare the edgeuses in the edgeuse list "eu2" with the edgeuse "eu1"
 *	Any edgeuses which share the same vertices as "eu1" should also be
 *	made to share the same edge.
d281 3
a283 3
static cmp_mesh_eu(eu1, hd)
struct edgeuse *eu1;
struct rt_list *hd;
d285 8
a292 1
	struct edgeuse *eu;
d294 2
a295 4
	pointp_t pt1, pt2;
	
	NMG_CK_EDGEUSE(eu1);
	NMG_CK_LIST(hd);
d297 6
a302 5
	pt1 = eu1->vu_p->v_p->vg_p->coord;
	pt2 = eu1->eumate_p->vu_p->v_p->vg_p->coord;
	if (rt_g.NMG_debug & DEBUG_MESH_EU)
		rt_log("meshing against %g, %g, %g -> %g, %g, %g (edge %8x)\n",
		pt1[X], pt1[Y], pt1[Z], pt2[X], pt2[Y], pt2[Z], eu1->e_p);
d304 47
a350 7
	for (RT_LIST_FOR(eu, edgeuse, hd)) {
		NMG_CK_EDGEUSE(eu);
		if (rt_g.NMG_debug & DEBUG_MESH_EU) {
			pt1 = eu->vu_p->v_p->vg_p->coord;
			pt2 = eu->eumate_p->vu_p->v_p->vg_p->coord;
			rt_log("\tcomparing %g, %g, %g -> %g, %g, %g (edge %8x)\n",
			    pt1[X], pt1[Y], pt1[Z], pt2[X], pt2[Y], pt2[Z], eu->e_p);
a351 10

		/* if vertices are the same but edges aren't shared, make
		 * them shared
		 */
		if (eu->e_p != eu1->e_p &&
		    (eu->vu_p->v_p == eu1->vu_p->v_p &&
		    eu->eumate_p->vu_p->v_p == eu1->eumate_p->vu_p->v_p ||
		    eu->eumate_p->vu_p->v_p == eu1->vu_p->v_p &&
		    eu->vu_p->v_p == eu1->eumate_p->vu_p->v_p))
			nmg_join_eu(eu1, eu);
d353 1
a353 1

d359 5
a363 1
 *	Make sure that all shareable edges of fu1/fu2 are indeed shared
d369 1
a369 2
	struct loopuse *lu1, *lu2;
	struct edgeuse *eu;
d379 3
a381 3
	/* Make sure all edges within fu1 that can be shared
	 * with other edges in fu1 are in fact shared.
	 */
d384 2
a385 1
		rt_log("meshing self (fu %8x)\n", fu1);
d387 3
a389 1
	for (RT_LIST_FOR(lu1, loopuse, &fu1->lu_hd)) {
d391 5
a395 3
		NMG_CK_LOOPUSE(lu1);
		if (RT_LIST_FIRST_MAGIC(&lu1->down_hd) == NMG_EDGEUSE_MAGIC){
			for(RT_LIST_FOR(eu, edgeuse, &lu1->down_hd)) {
d397 12
a408 4
				NMG_CK_EDGEUSE(eu);
				for (lu2 = RT_LIST_PNEXT(loopuse, lu1);
				    RT_LIST_NOT_HEAD(lu2, &fu1->lu_hd) ;
				    lu2 = RT_LIST_PNEXT(loopuse, lu2) ) {
d410 8
a417 6
				    	if (RT_LIST_FIRST_MAGIC(&lu2->down_hd)
				    	    == NMG_EDGEUSE_MAGIC)
				    	        cmp_mesh_eu(eu, &lu2->down_hd);
				}
			}
		}
d419 3
d423 17
a439 2
	if (rt_g.NMG_debug & DEBUG_MESH)
		rt_log("meshing to other (fu1:%8x fu2:%8x)\n", fu1, fu2);
d441 2
d444 5
a448 4
	/* now make sure that all edges of fu2 that could be shared with
	 * an edge of fu1 are indeed shared
	 */
	for (RT_LIST_FOR(lu1, loopuse, &fu1->lu_hd)) {
d450 3
a452 3
		NMG_CK_LOOPUSE(lu1);
		if (RT_LIST_FIRST_MAGIC(&lu1->down_hd) == NMG_EDGEUSE_MAGIC){
			for(RT_LIST_FOR(eu, edgeuse, &lu1->down_hd)) {
d454 2
a455 2
				NMG_CK_EDGEUSE(eu);
				for (RT_LIST_FOR(lu2, loopuse, &fu2->lu_hd)) {
d457 4
a460 5
				    	if(RT_LIST_FIRST_MAGIC(&lu2->down_hd)
				    	    == NMG_EDGEUSE_MAGIC)
						cmp_mesh_eu(eu, &lu2->down_hd);
				}
			}
d463 2
a464 5

    	if (rt_g.NMG_debug & DEBUG_MESH && rt_g.NMG_debug & DEBUG_PLOTEM) {
    		static int fno=1;
    	    	nmg_pl_2fu( "After_mesh%d.pl", fno++, fu1, fu2, 1 );
    	}
@


10.5
log
@Trying to pin down the infinite loop (2).
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mesh.c,v 10.4 93/03/03 01:51:07 mike Exp Locker: mike $ (BRL)";
d238 1
a238 1
				rt_log("XXX nmg_join_eu():  went full circle, no luck.  Guessing at face insertion point.\n");
@


10.4
log
@Changed to V3RPP_OVERLAP, DIST_PT_PLANE
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mesh.c,v 10.3 93/02/09 00:39:02 mike Exp Locker: mike $ (BRL)";
d185 2
a186 1
/*			J O I N _ E U
d188 4
a191 1
 *	Join edgeuses to same edge
d193 1
a193 1
static void join_eu(eu1, eu2)
d207 5
d217 1
d233 3
d237 4
d244 4
a247 1
		if(iteration2 >= 10000) rt_bomb("join_eu: infinite loop (2)\n");
d268 1
a268 1
	if( iteration1 >= 10000 )  rt_bomb("join_eu:  infinite loop (1)\n");
d312 1
a312 1
			join_eu(eu1, eu);
@


10.3
log
@Moved nmg_mesh_faces() debug messages into nmg_mesh.c
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mesh.c,v 10.2 92/12/14 15:34:28 mike Exp Locker: mike $ (BRL)";
d148 1
a148 1
	dist = NMG_DIST_PT_PLANE(test_pt, Norm1);
@


10.2
log
@Added infinite loop protection
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mesh.c,v 10.1 91/10/12 06:40:46 mike Rel4_0 Locker: mike $ (BRL)";
d300 1
a300 1
 *	make sure that all shareable edges of fu1/fu2 are indeed shared
d312 7
a318 2
	/* first make sure all edges withing fu1 that can be shared
	 * are shared
d366 5
@


10.1
log
@Release_4.0
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mesh.c,v 1.4 91/06/17 20:42:07 butler Exp $ (BRL)";
d194 1
d207 1
a207 1
	while (eu2) {
d219 5
a223 1
		if (rt_g.NMG_debug & DEBUG_MESH) {
d226 2
a228 10
			while (angle1 > angle2 ) {
				eu1 = eu1->radial_p->eumate_p;
				angle1 = get_angle(eu1, eu2);
				angle2 = get_angle(eu1, eu1->radial_p);
			}
		} else
			while (get_angle(eu1, eu2) >
			       get_angle(eu1, eu1->radial_p))
				eu1 = eu1->radial_p->eumate_p;

d248 1
@


1.4
log
@changed function declarations so that all global functions have their
"nmg_" at the begining of the line.  Static functions have their function
names on the same line as the "static" modifier.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mesh.c,v 1.3 91/04/03 02:30:10 mike Exp $ (BRL)";
@


1.3
log
@Changed for new, counter-clockwise exterior loops in the face.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mesh.c,v 1.2 91/02/07 20:32:38 mike Exp $ (BRL)";
d304 2
a305 1
void nmg_mesh_faces(fu1, fu2)
@


1.2
log
@Changed from NMG_LIST macros to RT_LIST macros, from rtlist.h
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mesh.c,v 1.1 90/12/08 03:08:51 mike Exp $ (BRL)";
d116 1
a116 1
	}
d123 1
a123 1
	}
d125 3
a127 1
	/* get vectors for edgeuses (should be opposite) */
d136 5
a140 3
	/* get vectors in the plane of each face */
	VCROSS(plvec1, veu1, Norm1);	VUNITIZE(plvec1);
	VCROSS(plvec2, veu2, Norm2);	VUNITIZE(plvec2);
d142 3
d208 2
a209 2
		/* because faces are always created with clockwise exterior
		 * loops and counter-clockwise interior loops, radial
@


1.1
log
@Initial revision
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_mk.c,v 1.32 90/12/08 02:53:43 mike Exp $ (BRL)";
d71 1
a71 1
		eutmp = NMG_LIST_PLAST_CIRC(edgeuse, eu1);
d92 1
a92 1
		eutmp = NMG_LIST_PLAST_CIRC(edgeuse, eu2);
d255 1
a255 1
struct nmg_list *hd;
d270 1
a270 1
	for (NMG_LIST(eu, edgeuse, hd)) {
d313 1
a313 1
	for (NMG_LIST(lu1, loopuse, &fu1->lu_hd)) {
d316 2
a317 2
		if (NMG_LIST_FIRST_MAGIC(&lu1->down_hd) == NMG_EDGEUSE_MAGIC){
			for(NMG_LIST(eu, edgeuse, &lu1->down_hd)) {
d320 3
a322 3
				for (lu2 = NMG_LIST_PNEXT(loopuse, lu1);
				    NMG_LIST_MORE(lu2, loopuse, &fu1->lu_hd) ;
				    lu2 = NMG_LIST_PNEXT(loopuse, lu2) ) {
d324 1
a324 1
				    	if (NMG_LIST_FIRST_MAGIC(&lu2->down_hd)
d339 1
a339 1
	for (NMG_LIST(lu1, loopuse, &fu1->lu_hd)) {
d342 2
a343 2
		if (NMG_LIST_FIRST_MAGIC(&lu1->down_hd) == NMG_EDGEUSE_MAGIC){
			for(NMG_LIST(eu, edgeuse, &lu1->down_hd)) {
d346 1
a346 1
				for (NMG_LIST(lu2, loopuse, &fu2->lu_hd)) {
d348 1
a348 1
				    	if(NMG_LIST_FIRST_MAGIC(&lu2->down_hd)
@
