head	11.57;
access;
symbols
	ansi-20040405-merged:11.52.2.2
	postmerge-20040405-ansi:11.55
	premerge-20040404-ansi:11.54
	postmerge-autoconf:11.54
	autoconf-freeze:11.52.10.3
	premerge-autoconf:11.54
	ansi-20040316-freeze:11.52.2.1
	postmerge-20040315-windows:11.54
	premerge-20040315-windows:11.54
	windows-20040315-freeze:11.52.4.1
	autoconf-20031203:11.52
	autoconf-20031202:11.52
	autoconf-branch:11.52.0.10
	phong-branch:11.52.0.8
	photonmap-branch:11.52.0.6
	rel-6-1-DP:11.52
	windows-branch:11.52.0.4
	rel-6-0-2:11.50
	ansi-branch:11.52.0.2
	rel-6-0-1-branch:11.50.0.2
	hartley-6-0-post:11.51
	hartley-6-0-pre:11.50
	rel-6-0-1:11.50
	rel-6-0:11.50
	rel-5-4:11.29
	offsite-5-3-pre:11.41
	rel-5-3:11.29
	rel-5-2:11.29
	rel-5-1-branch:11.29.0.2
	rel-5-1:11.29
	rel-5-0:11.17
	rel-5-0-beta:11.16
	rel-4-5:11.14
	ctj-4-5-post:11.13
	ctj-4-5-pre:11.13
	rel-4-4:11.1;
locks; strict;
comment	@ * @;


11.57
date	2004.05.21.18.07.31;	author morrison;	state dead;
branches;
next	11.56;

11.56
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.55;

11.55
date	2004.04.05.08.48.56;	author morrison;	state Exp;
branches;
next	11.54;

11.54
date	2004.03.03.21.24.05;	author morrison;	state Exp;
branches;
next	11.53;

11.53
date	2004.02.02.17.39.20;	author morrison;	state Exp;
branches;
next	11.52;

11.52
date	2002.08.20.17.08.00;	author jra;	state Exp;
branches
	11.52.2.1
	11.52.4.1
	11.52.10.1;
next	11.51;

11.51
date	2002.08.15.20.55.12;	author hartley;	state Exp;
branches;
next	11.50;

11.50
date	2001.10.05.00.45.30;	author butler;	state Exp;
branches;
next	11.49;

11.49
date	2001.10.04.18.37.25;	author tranese;	state Exp;
branches;
next	11.48;

11.48
date	2001.10.02.19.24.29;	author jra;	state Exp;
branches;
next	11.47;

11.47
date	2001.05.17.20.05.24;	author morrison;	state Exp;
branches;
next	11.46;

11.46
date	2001.05.16.21.38.04;	author morrison;	state Exp;
branches;
next	11.45;

11.45
date	2001.04.20.22.29.45;	author morrison;	state Exp;
branches;
next	11.44;

11.44
date	2001.03.31.01.57.08;	author morrison;	state Exp;
branches;
next	11.43;

11.43
date	2001.03.23.22.34.31;	author butler;	state Exp;
branches;
next	11.42;

11.42
date	2001.03.21.20.03.09;	author jra;	state Exp;
branches;
next	11.41;

11.41
date	2000.10.24.00.02.25;	author butler;	state Exp;
branches;
next	11.40;

11.40
date	2000.09.08.05.54.42;	author mike;	state Exp;
branches;
next	11.39;

11.39
date	2000.09.01.02.18.03;	author mike;	state Exp;
branches;
next	11.38;

11.38
date	2000.08.21.02.02.30;	author butler;	state Exp;
branches;
next	11.37;

11.37
date	2000.07.08.02.19.35;	author mike;	state Exp;
branches;
next	11.36;

11.36
date	2000.07.08.01.28.33;	author mike;	state Exp;
branches;
next	11.35;

11.35
date	2000.07.06.22.44.52;	author mike;	state Exp;
branches;
next	11.34;

11.34
date	2000.06.30.20.10.32;	author butler;	state Exp;
branches;
next	11.33;

11.33
date	2000.06.30.15.38.03;	author mike;	state Exp;
branches;
next	11.32;

11.32
date	2000.06.30.15.31.15;	author mike;	state Exp;
branches;
next	11.31;

11.31
date	2000.06.29.20.59.51;	author butler;	state Exp;
branches;
next	11.30;

11.30
date	2000.06.29.20.53.01;	author butler;	state Exp;
branches;
next	11.29;

11.29
date	2000.04.12.02.34.34;	author mike;	state Exp;
branches;
next	11.28;

11.28
date	2000.03.28.21.59.05;	author mike;	state Exp;
branches;
next	11.27;

11.27
date	2000.01.14.23.00.29;	author mike;	state Exp;
branches;
next	11.26;

11.26
date	99.12.29.21.03.33;	author jra;	state Exp;
branches;
next	11.25;

11.25
date	99.12.17.04.51.55;	author cjohnson;	state Exp;
branches;
next	11.24;

11.24
date	99.12.16.22.46.38;	author cjohnson;	state Exp;
branches;
next	11.23;

11.23
date	99.12.06.23.16.16;	author cjohnson;	state Exp;
branches;
next	11.22;

11.22
date	99.12.01.23.39.26;	author cjohnson;	state Exp;
branches;
next	11.21;

11.21
date	99.12.01.14.29.54;	author cjohnson;	state Exp;
branches;
next	11.20;

11.20
date	99.11.26.21.46.47;	author mike;	state Exp;
branches;
next	11.19;

11.19
date	99.11.17.02.41.59;	author mike;	state Exp;
branches;
next	11.18;

11.18
date	99.10.30.03.53.27;	author mike;	state Exp;
branches;
next	11.17;

11.17
date	99.07.02.22.19.23;	author mike;	state Exp;
branches;
next	11.16;

11.16
date	99.05.27.19.10.39;	author mike;	state Exp;
branches;
next	11.15;

11.15
date	99.01.15.05.49.26;	author mike;	state Exp;
branches;
next	11.14;

11.14
date	97.12.16.00.15.10;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	97.07.02.21.04.12;	author butler;	state Exp;
branches;
next	11.12;

11.12
date	97.04.28.04.24.45;	author butler;	state Exp;
branches;
next	11.11;

11.11
date	97.03.04.19.09.24;	author jra;	state Exp;
branches;
next	11.10;

11.10
date	97.02.28.18.29.20;	author jra;	state Exp;
branches;
next	11.9;

11.9
date	96.12.31.16.51.19;	author jra;	state Exp;
branches;
next	11.8;

11.8
date	96.08.31.11.04.24;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	96.08.29.22.50.48;	author butler;	state Exp;
branches;
next	11.6;

11.6
date	96.07.12.12.10.21;	author jra;	state Exp;
branches;
next	11.5;

11.5
date	95.10.05.13.48.53;	author cjohnson;	state Exp;
branches;
next	11.4;

11.4
date	95.09.15.21.09.50;	author cjohnson;	state Exp;
branches;
next	11.3;

11.3
date	95.09.15.21.09.13;	author cjohnson;	state Exp;
branches;
next	11.2;

11.2
date	95.06.13.14.39.17;	author cjohnson;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.56.43;	author mike;	state Rel4_4;
branches;
next	1.13;

1.13
date	94.11.30.01.49.49;	author cjohnson;	state Exp;
branches;
next	1.12;

1.12
date	94.11.29.18.18.48;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	94.11.08.03.10.17;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	94.10.29.01.37.18;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	94.10.29.00.57.37;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	94.10.28.22.14.39;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	94.10.28.21.09.38;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	94.10.28.20.52.06;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	94.10.28.19.46.33;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	94.10.28.16.44.29;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	94.10.25.23.21.45;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	94.10.25.18.48.30;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	94.10.24.23.59.22;	author mike;	state Exp;
branches;
next	;

11.52.2.1
date	2002.09.19.18.01.34;	author morrison;	state Exp;
branches;
next	11.52.2.2;

11.52.2.2
date	2004.03.17.21.18.46;	author morrison;	state Exp;
branches;
next	;

11.52.4.1
date	2004.03.11.23.43.38;	author morrison;	state Exp;
branches;
next	;

11.52.10.1
date	2004.02.12.18.37.41;	author erikg;	state Exp;
branches;
next	11.52.10.2;

11.52.10.2
date	2004.03.10.13.17.54;	author erikg;	state Exp;
branches;
next	11.52.10.3;

11.52.10.3
date	2004.03.15.14.07.19;	author erikg;	state Exp;
branches;
next	;


desc
@Height Field Solid
@


11.57
log
@moved to src/
@
text
@/*
 *			G _ H F . C
 *
 *  Purpose -
 *	Intersect a ray with a height field,
 *	where the heights are imported from an external data file,
 *	and where some (or all) of the parameters of that data file
 *	may be read in from an external control file.
 *
 *  Authors -
 *	Michael John Muuss
 *	(Christopher T. Johnson, GSI)
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1994-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */
#ifndef lint
static char rt_hf_RcSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/g_hf.c,v 11.56 2004/05/10 15:30:46 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#include <fcntl.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"

#include "vmath.h"
#include "db.h"
#include "nmg.h"
#include "raytrace.h"
#include "rtgeom.h"
#include "./debug.h"

/*
 *  Description of the external string description of the HF.
 *
 *  There are two versions of this parse table.
 *  The string solid in the .g file can set any parameter.
 *  The indirect control file (cfile) can only set parameters
 *  relating to dfile parameters, and not to the geometric
 *  position, orientation, and scale of the HF's bounding RPP.
 *
 *  In general, the cfile should be thought of as describing
 *  the data arrangement of the dfile, and the string solid should
 *  be thought of as describing the "geometry" of the height
 *  field's bounding RPP.
 *
 *  The string solid is parsed first.  If a cfile is present, it is
 *  parsed second, and any parameters specified in the cfile override
 *  the values taken from the string solid.
 */
#define HF_O(m)			offsetof(struct rt_hf_internal, m)

/* All fields valid in string solid */
const struct bu_structparse rt_hf_parse[] = {
	{"%s",	128,	"cfile",	bu_offsetofarray(struct rt_hf_internal, cfile), BU_STRUCTPARSE_FUNC_NULL},
	{"%s",	128,	"dfile",	bu_offsetofarray(struct rt_hf_internal, dfile), BU_STRUCTPARSE_FUNC_NULL},
	{"%s",	8,	"fmt",		bu_offsetofarray(struct rt_hf_internal, fmt), BU_STRUCTPARSE_FUNC_NULL},
	{"%d",	1,	"w",		HF_O(w),		BU_STRUCTPARSE_FUNC_NULL },
	{"%d",	1,	"n",		HF_O(n),		BU_STRUCTPARSE_FUNC_NULL },
	{"%d",	1,	"shorts",	HF_O(shorts),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1,	"file2mm",	HF_O(file2mm),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	3,	"v",		HF_O(v[0]),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	3,	"x",		HF_O(x[0]),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	3,	"y",		HF_O(y[0]),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1,	"xlen",		HF_O(xlen),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1,	"ylen",		HF_O(ylen),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1,	"zscale",	HF_O(zscale),		BU_STRUCTPARSE_FUNC_NULL },
	{"",	0,	(char *)0,	0,			BU_STRUCTPARSE_FUNC_NULL }
};
/* Subset of fields found in cfile */
const struct bu_structparse rt_hf_cparse[] = {
	{"%s",	128,	"dfile",	bu_offsetofarray(struct rt_hf_internal, dfile), BU_STRUCTPARSE_FUNC_NULL},
	{"%s",	8,	"fmt",		bu_offsetofarray(struct rt_hf_internal, fmt), BU_STRUCTPARSE_FUNC_NULL},
	{"%d",	1,	"w",		HF_O(w),		BU_STRUCTPARSE_FUNC_NULL },
	{"%d",	1,	"n",		HF_O(n),		BU_STRUCTPARSE_FUNC_NULL },
	{"%d",	1,	"shorts",	HF_O(shorts),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1,	"file2mm",	HF_O(file2mm),		BU_STRUCTPARSE_FUNC_NULL },
	{"",	0,	(char *)0,	0,			BU_STRUCTPARSE_FUNC_NULL }
};

struct hf_specific {
	vect_t	hf_V;		/* min vertex/origin of HF */
	vect_t	hf_VO;		/* max vertex of HF */
	vect_t	hf_X;		/* X direction vector */
	fastf_t	hf_Xlen;	/* magnitude of HF in X direction */
	vect_t	hf_Y;		/* Y Direction vector */
	fastf_t	hf_Ylen;	/* magnitude of HF in Y direction */
	vect_t	hf_N;		/* dir of elevation */
	fastf_t	hf_min;		/* bounding box of hf solid */
	fastf_t	hf_max;
	fastf_t	hf_file2mm;	/* scale file elevation units to mm */
	int	hf_w;		/* X dimension of file */
	int	hf_n;		/* Y dimension of file */
	int	hf_shorts;	/* Boolean: use shorts instead of double */
	struct bu_mapped_file *hf_mp;
};

/*
 *			R T _ H F _ T O _ D S P
 *
 *	Convert in-memory form of a height-field (HF) to a displacement-map
 *	solid (DSP) in internal representation.
 *	There is no record in the V5 database for an HF.
 */
int
rt_hf_to_dsp(struct rt_db_internal *db_intern, struct resource *resp)
{
	struct rt_hf_internal	*hip = (struct rt_hf_internal *)db_intern->idb_ptr;
	struct rt_dsp_internal	*dsp;
	vect_t			tmp;

	RT_CK_DB_INTERNAL(db_intern);
	RT_CK_RESOURCE(resp);
	RT_HF_CK_MAGIC( hip );

	if (! hip->shorts) {
		bu_log("cannot convert float HF to DSP\n");
		return -1;
	}

	BU_GETSTRUCT( dsp, rt_dsp_internal );
	bu_vls_init( &dsp->dsp_name );
	bu_vls_strcat( &dsp->dsp_name, hip->dfile );
	dsp->dsp_xcnt = hip->w;
	dsp->dsp_ycnt = hip->n;
	dsp->dsp_smooth = 0;
	dsp->dsp_cuttype = DSP_CUT_DIR_ADAPT;
	if (RT_G_DEBUG & DEBUG_HF) {
	    bu_log("Converting from cut-style lower-left/upper-right to adaptive\n");
	}
	dsp->dsp_datasrc = RT_DSP_SRC_FILE;


	MAT_IDN(dsp->dsp_stom);
	MAT_DELTAS_VEC(dsp->dsp_stom, hip->v);	/* translate */

	/* Apply modeling transformations */
	VUNITIZE( hip->x );
	VSCALE( tmp, hip->x, hip->xlen/(fastf_t)(hip->w - 1) );
	dsp->dsp_stom[0] = tmp[0];
	dsp->dsp_stom[4] = tmp[1];
	dsp->dsp_stom[8] = tmp[2];
	VUNITIZE( hip->y );
	VSCALE( tmp, hip->y, hip->ylen/(fastf_t)(hip->n - 1) );
	dsp->dsp_stom[1] = tmp[0];
	dsp->dsp_stom[5] = tmp[1];
	dsp->dsp_stom[9] = tmp[2];
	VCROSS( tmp, hip->x, hip->y );
	VUNITIZE( tmp );

	/* The next line should be:
	 * VSCALE( tmp, tmp, hip->zscale * hip->file2mm );
	 * This will make the converted DSP plot in MGED agree with what he HF looks like,
	 * but the HF ignores 'zscale' in the shot routine.
	 * So we choose to duplicate the raytrace behavior (ignore zscale)
	 */
	VSCALE( tmp, tmp, hip->file2mm );

	dsp->dsp_stom[2] = tmp[0];
	dsp->dsp_stom[6] = tmp[1];
	dsp->dsp_stom[10] = tmp[2];

	bn_mat_inv( dsp->dsp_mtos, dsp->dsp_stom );

	dsp->magic = RT_DSP_INTERNAL_MAGIC;

	rt_db_free_internal( db_intern, resp );

	db_intern->idb_ptr = (genptr_t)dsp;
	db_intern->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	db_intern->idb_type = ID_DSP;
	db_intern->idb_meth = &rt_functab[ID_DSP];

	return 0;

}


/*
 *  			R T _ H F _ P R E P
 *  
 *  Given a pointer to a GED database record, and a transformation matrix,
 *  determine if this is a valid HF, and if so, precompute various
 *  terms of the formula.
 *  
 *  Returns -
 *  	0	HF is OK
 *  	!0	Error in description
 *  
 *  Implicit return -
 *  	A struct hf_specific is created, and it's address is stored in
 *  	stp->st_specific for use by hf_shot().
 */
int
rt_hf_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
{
	struct rt_hf_internal *hip;
	register struct hf_specific	*hf;
	const struct bn_tol		*tol = &rtip->rti_tol;
	double	dot;
	vect_t	height, work;
	static int first_time=1;

	if (first_time) {
#ifndef lint
		bu_log("%s\n",rt_hf_RcSid);
#endif
		first_time=0;
	}
	RT_CK_DB_INTERNAL(ip);
	hip = (struct rt_hf_internal *)ip->idb_ptr;
	RT_HF_CK_MAGIC(hip);

	BU_GETSTRUCT(hf, hf_specific);
	stp->st_specific = (genptr_t) hf;
	/*
	 * The stuff that is given to us.
	 */
	VMOVE(hf->hf_V, hip->v);
	VMOVE(hf->hf_X, hip->x);
	VUNITIZE(hf->hf_X);
	hf->hf_Xlen = hip->xlen;
	VMOVE(hf->hf_Y, hip->y);
	VUNITIZE(hf->hf_Y);
	hf->hf_Ylen = hip->ylen;
	hf->hf_file2mm = hip->file2mm;
	hf->hf_w = hip->w;
	hf->hf_n = hip->n;
	hf->hf_mp = hip->mp;
	bu_semaphore_acquire( RT_SEM_MODEL);
	++hf->hf_mp->uses;
	bu_semaphore_release( RT_SEM_MODEL);
	hf->hf_shorts = hip->shorts;
	/*
	 * From here down, we are calculating new values on a one time
	 * basis.
	 */

	/*
	 * Start finding the location of the oposite vertex to V
	 */
	VJOIN2(hf->hf_VO, hip->v, hip->xlen, hip->x, hip->ylen, hip->y);

	/*
	 * get the normal.
	 */
	dot = VDOT(hf->hf_X, hf->hf_Y);
	if (fabs(dot) >tol->perp) {	/* not perpendicular, bad hf */
		bu_log("Hf(%s): X not perpendicular to Y.\n", stp->st_name);
		bu_free((genptr_t)hf, "struct hf");
		stp->st_specific = (genptr_t) 0;
		return 1;	/* BAD */
	}
	VCROSS(hf->hf_N, hf->hf_X, hf->hf_Y);
	VUNITIZE(hf->hf_N);		/* Not needed (?) */

	/*
	 * Locate the min-max of the HF for use in determining VO and
	 * bounding boxes et so forth.
	 */
	if (hf->hf_shorts) {
		register int max, min;
		register int len;
		register unsigned short *sp;
		register int i;

		sp = (unsigned short *)hf->hf_mp->apbuf;
		min = max = *sp++;
		len = hf->hf_w * hf->hf_n;
		for (i=1; i< len; i++, sp++) {
			if ((int)*sp > max) max=*sp;
			if ((int)*sp < min) min=*sp;
		}
		hf->hf_min = min * hf->hf_file2mm;
		hf->hf_max = max * hf->hf_file2mm;
	} else {
		fastf_t max, min;
		register int len;
		register int i;
		fastf_t *fp;

		fp = (fastf_t *) hf->hf_mp->apbuf;
		min = max = *fp++;
		len = hf->hf_w * hf->hf_n;
		for (i=1; i < len; i++, fp++) {
			if (*fp > max) max = *fp;
			if (*fp < min) min = *fp;
		}
		hf->hf_min = min * hf->hf_file2mm;
		hf->hf_max = max * hf->hf_file2mm;
	}

	VSCALE(height, hf->hf_N, hf->hf_max);
	VADD2(hf->hf_VO, hf->hf_VO, height);

	/*
	 * Now we compute the bounding box and sphere.
	 */
	VMOVE(stp->st_min, hf->hf_V);
	VMOVE(stp->st_max, hf->hf_V);
	VADD2(work, hf->hf_V, height);
	VMINMAX(stp->st_min, stp->st_max, work);
	VJOIN1(work, hf->hf_V, hf->hf_Xlen, hf->hf_X);
	VMINMAX(stp->st_min, stp->st_max, work);
	VADD2(work, work, height);
	VMINMAX(stp->st_min, stp->st_max, work);
	VJOIN1(work, hf->hf_V, hf->hf_Ylen, hf->hf_Y);
	VMINMAX(stp->st_min, stp->st_max, work);
	VADD2(work, work, height);
	VMINMAX(stp->st_min, stp->st_max, work);
	VJOIN2(work, hf->hf_V, hf->hf_Xlen, hf->hf_X, hf->hf_Ylen, hf->hf_Y);
	VMINMAX(stp->st_min, stp->st_max, work);
	VADD2(work, work, height);
	VMINMAX(stp->st_min, stp->st_max, work);
	/* Now find the center and radius for a bounding sphere. */
	{
		LOCAL fastf_t	dx,dy,dz;
		LOCAL fastf_t	f;

		VADD2SCALE( stp->st_center, stp->st_max, stp->st_min, 0.5);

		dx = (stp->st_max[X] - stp->st_min[X])/2;
		dy = (stp->st_max[Y] - stp->st_min[Y])/2;
		dz = (stp->st_max[Z] - stp->st_min[Z])/2;
		f = dx;
		if (dy > f) f = dy;
		if (dz > f) f = dz;
		stp->st_aradius = f;
		stp->st_bradius = sqrt(dx*dx + dy*dy + dz*dz);
	}
	return 0;
}

/*
 *			R T _ H F _ P R I N T
 */
void
rt_hf_print(register const struct soltab *stp)
{
	register const struct hf_specific *hf =
		(struct hf_specific *)stp->st_specific;
	VPRINT("V", hf->hf_V);
	VPRINT("X", hf->hf_X);
	VPRINT("Y", hf->hf_Y);
	VPRINT("N", hf->hf_N);
	bu_log("XL %g\n", hf->hf_Xlen);
	bu_log("YL %g\n", hf->hf_Ylen);
}

static int
rt_hf_cell_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct hit *hitp, int xCell, int yCell)
{
	register struct hf_specific *hfp =
		(struct hf_specific *)stp->st_specific;

	fastf_t dn, abs_dn, k1st=0, k2nd=0, alpha, beta;
	int dir1st, dir2nd;
	vect_t wxb, xp;
	vect_t tri_wn1st, tri_wn2nd, tri_BA1st, tri_BA2nd;
	vect_t tri_CA1st, tri_CA2nd;
	vect_t xvect, yvect, tri_A, tri_B, tri_C;
	int fnd1, fnd2;
	register double hf2mm = hfp->hf_file2mm;

	if (RT_G_DEBUG & DEBUG_HF) {
		bu_log("rt_hf_cell_shot(%s): %d, %d\n", stp->st_name,
		    xCell, yCell);
	}
	{
		register fastf_t scale;
		scale = hfp->hf_Xlen/((double)hfp->hf_w-1);
		VSCALE(xvect, hfp->hf_X, scale);
		scale = hfp->hf_Ylen/((double)hfp->hf_n-1);
		VSCALE(yvect, hfp->hf_Y, scale);
	}
	if (hfp->hf_shorts) {
		register unsigned short *sp;
		sp = (unsigned short *)hfp->hf_mp->apbuf +
			 yCell * hfp->hf_w + xCell;

		/* Get the points of one of the triangles */

		/* 0,0 -> tri_A */
		VJOIN3(tri_A, hfp->hf_V, *sp*hf2mm, hfp->hf_N, xCell+0, xvect,
		    yCell+0, yvect);
		sp++;
		/* 1, 0 -> tri_B */
		VJOIN3(tri_B, hfp->hf_V, *sp*hf2mm, hfp->hf_N, xCell+1, xvect,
		    yCell+0, yvect);
		sp += hfp->hf_w;
		/* 1, 1 -> tri_C */
		VJOIN3(tri_C, hfp->hf_V, *sp*hf2mm, hfp->hf_N, xCell+1, xvect,
		    yCell+1, yvect);

		VSUB2(tri_CA1st, tri_C, tri_A);
		VSUB2(tri_BA1st, tri_B, tri_A);
		VCROSS(tri_wn1st, tri_BA1st, tri_CA1st);
		VMOVE(tri_B, tri_C);		/* This can optimize down. */
		--sp;

		/* 0, 1 */
		VJOIN3(tri_C, hfp->hf_V, *sp*hf2mm, hfp->hf_N, xCell+0, xvect,
		    yCell+1, yvect);
		VSUB2(tri_CA2nd, tri_C, tri_A);	

/*		VMOVE(tri_BA2nd, tri_CA1st); */

		VSUB2(tri_BA2nd, tri_B, tri_A);
		VCROSS(tri_wn2nd, tri_BA2nd, tri_CA2nd);
	} else {
		register double *fp;
		fp = (double *)hfp->hf_mp->apbuf + 
			yCell * hfp->hf_w + xCell;
		/* 0,0 -> A */
		VJOIN3(tri_A, hfp->hf_V, *fp*hf2mm, hfp->hf_N, xCell+0, xvect,
		    yCell+0, yvect);
		fp++;
		/* 1, 0 */
		VJOIN3(tri_B, hfp->hf_V, *fp*hf2mm, hfp->hf_N, xCell+1, xvect,
		    yCell+0, yvect);
		fp += hfp->hf_w;
		/* 1, 1 */
		VJOIN3(tri_C, hfp->hf_V, *fp*hf2mm, hfp->hf_N, xCell+1, xvect,
		    yCell+1, yvect);
		VSUB2(tri_CA1st, tri_C, tri_A);
		VSUB2(tri_BA1st, tri_B, tri_A);
		VCROSS(tri_wn1st, tri_BA1st, tri_CA1st);
		VMOVE(tri_B, tri_C);		/* This can optimize down. */
		--fp;
		/* 0, 1 */
		VJOIN3(tri_C, hfp->hf_V, *fp*hf2mm, hfp->hf_N, xCell+0, xvect,
		    yCell+1, yvect);
		VSUB2(tri_CA2nd, tri_C, tri_A);	
/*		VMOVE(tri_BA2nd, tri_CA1st); */
		VSUB2(tri_BA2nd, tri_B, tri_A);
		VCROSS(tri_wn2nd, tri_BA2nd, tri_CA2nd);
	}

	/*	0,1		1,1
	 *	  o		o
	 *	  	    _
	 *	  ^          //|
	 *   CA2nd|         //
	 *	  |        //
	 *	  |  BA2nd//
	 *	  |      //
	 *	  |     // CA1st
	 *	  |    //
	 *	  |   //
	 *	  |  //
	 *	  | //
	 *	   
	 *	  o  -------->  o
	 *	0,0	BA1st	1,0
	 *
	 * wn1st and wn2nd are non-unit normal vectors pointing out of screen
	 */

	fnd1 = fnd2 = 0;

#if 0
	dn = VDOT(tri_wn1st, rp->r_dir); /* wn1st points out */
	abs_dn = (dn >= 0.0) ? dn : (-dn);
	if (abs_dn <SQRT_SMALL_FASTF)
		goto other_half; /* ray parellel to plane */

	VSUB2( wxb, tri_A, rp->r_pt);
	VCROSS( xp, wxb, rp->r_dir);
	alpha = VDOT(tri_CA1st, xp);	/* alpha = dist along CA1 to isect pt */
	if (dn < 0.0) alpha = -alpha;
	if (alpha < 0.0 || alpha > abs_dn) goto other_half;
	beta = VDOT(tri_BA1st, xp);	/* beta = dist along BA1 to isect pt */
	if (dn > 0.0) beta = -beta;
	if (beta < 0.0 || beta > abs_dn) goto other_half;
	if (alpha + beta > abs_dn) goto other_half;
	k1st = VDOT(wxb, tri_wn1st) / dn;
	fnd1 = 1;
#else
	/* Ray triangle intersection.  
	 * See: "Graphics Gems" An Efficient Ray-Polygon Intersection P:390
	 */

	dn = VDOT(tri_wn1st, rp->r_dir); /* wn1st points out */
	if (dn >= 0.0) {
		dir1st = 1;
		abs_dn=dn;
	} else {
		dir1st = 0;
		abs_dn = -dn;
	}

	/* make sure ray not parallel to plane of triangle */
	if (abs_dn >= SQRT_SMALL_FASTF) {
		VSUB2( wxb, tri_A, rp->r_pt);
		VCROSS( xp, wxb, rp->r_dir);

		/* alpha = dist along CA1 to isect pt */
		alpha = VDOT(tri_CA1st, xp);
		if (dn < 0.0) alpha = -alpha;

		/* if pt before CA1st or beyond end of CA1st pt is
		 * outside triangle.
		 *
		 * XXX Can someone explain the "alpha <= abs_dn" part? -- Lee
		 *  I know it's supposed to be determining if the point
		 * is beyond the end of CA1st, but I don't see how the math
		 * here does that.
		 */
		if (alpha >= 0.0 && alpha <= abs_dn) {

			/* beta = dist along BA1 to isect pt */
			beta = VDOT(tri_BA1st, xp);
			if (dn > 0.0) beta = -beta;

			if (beta >= 0.0 && beta <= abs_dn) {
				if (alpha + beta <= abs_dn) {
					k1st = VDOT(wxb, tri_wn1st) / dn;
					fnd1 = 1;
				}
			}
		}
	}
#endif






	/* XXX This is really hard to read.  Need to fix this like above */
	dn = VDOT(tri_wn2nd, rp->r_dir);
	if (dn >= 0.0) {
		dir2nd = 1;
		abs_dn = dn;
	} else {
		dir2nd = 0;
		abs_dn = -dn;
	}
	if (abs_dn < SQRT_SMALL_FASTF) goto leave;
	VSUB2(wxb, tri_A, rp->r_pt);
	VCROSS(xp, wxb, rp->r_dir);
	alpha = VDOT(tri_CA2nd, xp);
	if (dn <0.0) alpha = -alpha;
	if (alpha < 0.0 || alpha > abs_dn) goto leave;
	beta = VDOT(tri_BA2nd, xp);
	if (dn > 0.0) beta = -beta;
	if (beta < 0.0 || beta > abs_dn) goto leave;
	if (alpha+beta > abs_dn) goto leave;
	k2nd = VDOT(wxb, tri_wn2nd)/ dn;
	fnd2 = 1;
leave:
	if (!fnd1 && !fnd2) return 0;

	if (RT_G_DEBUG & DEBUG_HF) {
		bu_log("rt_hf_cell_shot: hit(%d).\n",fnd1+fnd2);
	}

	/*
	 * XXX - This is now wrong.
	 *
	 * We have now done the ray-triangle intersection.  dn1st
	 * and dn tell us the direction of the normal, <0 is in
	 * and >0 is out.  k1st and k2nd tell us the distance from
	 * the start point.
	 *
	 * We are only interested in the closest hit. and that will
	 * replace the out if dn>0 or the in if dn<0.
	 */

/* bu_log("cell: k1st=%g, k2nd=%g\n", k1st,k2nd); */

	if (!fnd2 ) {
		hitp->hit_magic = RT_HIT_MAGIC;
		hitp->hit_dist = k1st;
		VMOVE(hitp->hit_normal, tri_wn1st);
		VUNITIZE(hitp->hit_normal);
		hitp->hit_surfno = yCell*hfp->hf_w+xCell;
		return 1;
	}
	if (!fnd1) {
		hitp->hit_magic = RT_HIT_MAGIC;
		hitp->hit_dist = k2nd;
		VMOVE(hitp->hit_normal, tri_wn2nd);
		VUNITIZE(hitp->hit_normal);
		hitp->hit_surfno = yCell*hfp->hf_w+xCell;
		return 1;
	}
#if 0
	if (fabs(k1st) < fabs(k2nd)) {
		hitp->hit_magic = RT_HIT_MAGIC;
		hitp->hit_dist = k1st;
		VMOVE(hitp->hit_normal, tri_wn1st);
		VUNITIZE(hitp->hit_normal);
		hitp->hit_surfno = yCell*hfp->hf_w+xCell;
		return 1;
	} else {
		hitp->hit_magic = RT_HIT_MAGIC;
		hitp->hit_dist = k2nd;
		VMOVE(hitp->hit_normal, tri_wn2nd);
		VUNITIZE(hitp->hit_normal);
		hitp->hit_surfno = yCell*hfp->hf_w+xCell;
		return 1;
	}
#else
	/*
	 * This is the two hit situation which can cause interesting
	 * problems.  Three are basicly five different cases that must
	 * be dealt with and each one requires that the ray be classified
	 *
	 * 1) The ray has hit two different planes at two different
	 *    locations (k1st != k2nd).  Return both hit points.
	 * 2) The ray is going from inside to outside, return one hit point.
	 * 3) The ray is going from outside to inside, return one hit point.
	 * 4) The ray is going from inside to inside, return two hit points.
	 * 5) The ray is going from outside to outside, return two hit points.
	 */
	hitp->hit_magic = RT_HIT_MAGIC;
	hitp->hit_dist = k1st;
	VMOVE(hitp->hit_normal, tri_wn1st);
	VUNITIZE(hitp->hit_normal);
	hitp->hit_surfno = yCell*hfp->hf_w+xCell;
	hitp++;

	if ((fabs(k1st-k2nd) < SMALL_FASTF) &&
	    (dir1st + dir2nd != 1)) return 1;

	hitp->hit_magic = RT_HIT_MAGIC;
	hitp->hit_dist = k2nd;
	VMOVE(hitp->hit_normal, tri_wn2nd);
	VUNITIZE(hitp->hit_normal);
	hitp->hit_surfno = yCell*hfp->hf_w+xCell;
	return 2;
#endif
}

#define	MAXHITS	128		/* # of surfaces hit, must be even */

/*
 *	For the given plane of the bounding box of the hf solid, compute the
 *	hit distance and add it to the list of hits.  If the plane happens 
 *	to be the "Zmax" face, then the hit is really in the elevation data,
 *	and we skip it.  That will be handled elsewhere.
 */
static void
axis_plane_isect(int plane, fastf_t inout, struct xray *rp, struct hf_specific *hf, double xWidth, double yWidth, struct hit **hp, int *nhits)
{
	double left, right, xx=0, xright=0, answer;
	vect_t loc;
	int CellX=0, CellY=0;

	if (plane == -6) return;

	if (plane == -3) { 
		(*hp)->hit_magic = RT_HIT_MAGIC;
		(*hp)->hit_dist = inout;
		(*hp)->hit_surfno = plane;
		(*hp)++;
		if ((*nhits)++>=MAXHITS) rt_bomb("g_hf.c: too many hits.\n");
		return;
	}

	VJOIN1(loc, rp->r_pt, inout, rp->r_dir);
	VSUB2(loc,loc,hf->hf_V);

	/* find the left, right and xx */
	switch (plane) {
	case -1:
		CellY = loc[Y]/ yWidth;
		CellX = 0;
		xright = yWidth;
		xx = loc[Y] - (CellY* yWidth);
		break;
	case -2:
		CellY = 0;
		CellX = loc[X]/ xWidth;
		xright = xWidth;
		xx = loc[X] - CellX * xWidth;
		break;
	case -4:
		CellY = loc[Y]/ yWidth;
		CellX = hf->hf_n-1;
		xright = yWidth;
		xx = loc[Y] - (CellY* yWidth);
		break;
	case -5:
		CellY = hf->hf_w-1;
		CellX = loc[X]/ xWidth;
		xright = xWidth;
		xx = loc[X] - CellX* xWidth;
		break;
	}
#if 1 /* What does this indicate that it generates so much noise? */
	if (xx < 0) {
		bu_log("hf: xx < 0, plane = %d\n", plane);
	}
#endif

	if (hf->hf_shorts) {
		register unsigned short *sp;
		sp = (unsigned short *)hf->hf_mp->apbuf +
		    CellY * hf->hf_w + CellX;
		left = *sp;
		if (plane == -2 || plane == -5) {
			sp++;
		} else {
			sp += hf->hf_w;
		}
		right = *sp;
	} else {
		register double *fp;
		fp = (double *) hf->hf_mp->apbuf +
		    CellY * hf->hf_w + CellX;
		left = *fp;
		if (plane == -2 || plane == -5) {
			fp++;
		} else {
			fp += hf->hf_w;
		}
		right = *fp;
	}
	left *= hf->hf_file2mm;
	right *= hf->hf_file2mm;
	answer = (right-left)/xright*xx+left;
#if 0
bu_log("inout: loc[Z]=%g, answer=%g, left=%g, right=%g, xright=%g, xx=%g\n",
    loc[Z], answer, left, right, xright, xx);
#endif

	if (loc[Z]-SQRT_SMALL_FASTF < answer) {
		(*hp)->hit_magic = RT_HIT_MAGIC;
		(*hp)->hit_dist = inout;
		(*hp)->hit_surfno = plane;
		VJOIN1((*hp)->hit_point, rp->r_pt, inout, rp->r_dir);
		(*hp)++;
		if ((*nhits)++>=MAXHITS) rt_bomb("g_hf.c: too many hits.\n");
	}
}



/*
 *  			R T _ H T F _ S H O T
 *  
 *  Intersect a ray with a height field.
 *  If an intersection occurs, a struct seg will be acquired
 *  and filled in.
 *  
 *  Returns -
 *  	0	MISS
 *	>0	HIT
 */
int
rt_hf_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
{
	register struct hf_specific *hf =
		(struct hf_specific *)stp->st_specific;

	LOCAL	struct hit	hits[MAXHITS];
	struct hit *hp;
	LOCAL	int		nhits;
	double	xWidth, yWidth;

	vect_t  peqn;
	fastf_t pdist=0;
	fastf_t allDist[6];	/* The hit point for all rays. */
	fastf_t cosine;

	LOCAL int	iplane, oplane, j;
	LOCAL fastf_t	in, out;
	vect_t aray, curloc;

bzero(hits,sizeof(hits));

	in = -INFINITY;
	out = INFINITY;
	iplane = oplane = 0;

	nhits=0;
	hp = &hits[0];


	/*
	 * First step in raytracing the HF is to find the intersection
	 * of the ray with the bounding box.  Since the ray might not
	 * even hit the box.
	 *
	 * The results of this intercept can be used to find which
	 * cell of the dda is the start cell.
	 */
	for (j=-1; j>-7; j--) {
		FAST fastf_t	dn;	/* Direction dot Normal */
		FAST fastf_t	dxbdn;	/* distence beteen d and b * dn */
		FAST fastf_t	s;	/* actual distence in mm */
		int allIndex;

		switch (j) {
		case -1:
			/* Xmin plane */
			VREVERSE(peqn, hf->hf_X);
			pdist = VDOT(peqn, hf->hf_V);
			break;
		case -2:
			/* Ymin plane */
			VREVERSE(peqn, hf->hf_Y);
			pdist = VDOT(peqn, hf->hf_V);
			break;
		case -3:
			/* Zmin plane */
			VREVERSE(peqn, hf->hf_N);
			pdist = VDOT(peqn, hf->hf_V);
			break;
		case -4:
			/* Xmax plane */
			VMOVE(peqn, hf->hf_X);
			pdist = VDOT(peqn, hf->hf_VO);
			break;
		case -5:
			/* Ymax plane */
			VMOVE(peqn, hf->hf_Y);
			pdist = VDOT(peqn, hf->hf_VO);
			break;
		case -6:
			/* Zmax plane */
			VMOVE(peqn, hf->hf_N);
			pdist = VDOT(peqn, hf->hf_VO);
			break;
		}
		allIndex = abs(j)-1;

		dxbdn = VDOT( peqn, rp->r_pt) - pdist;
		dn = -VDOT( peqn, rp->r_dir);
/*		allDist[allIndex] = s = dxbdn/dn; */
		if (RT_G_DEBUG & DEBUG_HF) {
			VPRINT("hf: Plane Equation", peqn);
			bu_log("hf: dn=%g, dxbdn=%g, ", dn, dxbdn);
		}

		if (dn < -SQRT_SMALL_FASTF) {		/* Leaving */
			allDist[allIndex] = s = dxbdn/dn;
			if ( out > s ) {
				out = s;
				oplane = j;
			}
			if (RT_G_DEBUG & DEBUG_HF) {
				bu_log("s=%g out=%g\n", s, out);
			}
		} else if (dn > SQRT_SMALL_FASTF) {	/* entering */
			allDist[allIndex] = s = dxbdn/dn;
			if ( in < s ) {
				in = s;
				iplane = j;
			}
			if (RT_G_DEBUG & DEBUG_HF) {
				bu_log("s=%g in=%g\n", s, in);
			}
		} else {
			/*
			 * if the ray is outside the solid, then this
			 * is a miss.
			 */
			if (RT_G_DEBUG & DEBUG_HF) {
				bu_log("s=DIVIDE_BY_ZERO\n");
			}
			if ( dxbdn > SQRT_SMALL_FASTF) {
				return 0; /* MISS */
			}
			allDist[allIndex] = INFINITY;
		}
		if ( in > out) {
			if (RT_G_DEBUG & DEBUG_HF) {
				bu_log("rt_hf_shoot(%s): in(%g) > out(%g)\n",
				    stp->st_name, in, out);
			}
			return 0;	/* MISS */
		}
	}

	if ( iplane >= 0 || oplane >= 0 ) {
		bu_log("rt_hf_shoot(%s): 1 hit => MISS\n",
		    stp->st_name);
		return 0;	/* MISS */
	}

	if ( fabs(in-out) < SMALL_FASTF  || out >= INFINITY ) {
		if (RT_G_DEBUG & DEBUG_HF) {
			bu_log("rt_hf_shoot(%s): in(%g) >= out(%g) || out >= INFINITY\n",
			    stp->st_name, in, out);
		}
		return 0;
	}

	/*
	 * Once that translation is done, we start a DDA to walk across
	 * the field.  Checking each "cell" and when changing cells in
	 * the off direction, the 2 cells filling the corner are also
	 * checked.
	 */

	xWidth = hf->hf_Xlen/((double)(hf->hf_w-1));
	yWidth = hf->hf_Ylen/((double)(hf->hf_n-1));

	if (RT_G_DEBUG & DEBUG_HF) {
		bu_log("hf: xWidth=%g, yWidth=%g, in=%g, out=%g\n", xWidth,
		       yWidth, in, out);
	}


	/*
	 * add the sides, and bottom to the hit list.
	 */
	axis_plane_isect(iplane,  in, rp, hf, xWidth, yWidth, &hp, &nhits);
	axis_plane_isect(oplane, out, rp, hf, xWidth, yWidth, &hp, &nhits);

	/*
	 * Gee, we've gotten much closer, we know that we hit the
	 * the solid. Now it's time to see which cell we hit.  The
	 * Key here is to use a fast DDA to check ONLY the cells we
	 * are interested in.  The basic idea and some of the pseudo
	 * code comes from:
	 *	Grid Tracing: Fast Ray Tracing for Height Fields
	 *	By: F. Kenton Musgrave.
	 */

	/*
	 * Now we figure out which direction we are going to be moving,
	 * X, Y or Z.
	 */
	{
		vect_t tmp;
		VMOVE(tmp,rp->r_dir);
		tmp[Z] = 0.0;	/* XXX Bogus?  Assumes X,Y in XY plane */
		VUNITIZE(tmp);
		cosine = VDOT(tmp, hf->hf_X);
	}
	if (fabs(cosine) < SMALL_FASTF) {	/* near enough to Z */
		vect_t tmp;
		int xCell, yCell, r;
		if (RT_G_DEBUG & DEBUG_HF) {
			bu_log("hf: Vertical shoot\n");
		}
		VSUB2(tmp, rp->r_pt, hf->hf_V);
		xCell = tmp[X]/hf->hf_Xlen*hf->hf_w;
		yCell = tmp[Y]/hf->hf_Ylen*hf->hf_n;
		if (  (r=rt_hf_cell_shot(stp, rp, ap, hp, xCell, yCell)) ) {
			if ((nhits+=r)>MAXHITS) rt_bomb("g_hf.c: too many hits.\n");
			hp+=r;
		}
	} else if (cosine*cosine > 0.5) {
		double tmp;
		register double farZ, minZ, maxZ;
		int	xCell, yCell, signX, signY;
		double	highest,lowest, error,delta;
		double	deltaZ;

		vect_t	goesIN, goesOUT;

		VJOIN1(goesIN, rp->r_pt, allDist[3], rp->r_dir); /* Xmax plane */
		VJOIN1(goesOUT,rp->r_pt, allDist[0], rp->r_dir); /* Xmin plane */
		VSUB2(aray, goesOUT, goesIN);
		VSUB2(curloc, goesIN, hf->hf_V);


		/*
		 * We will be stepping one "cell width" in the X direction
		 * each time through the loop.  In simple case we have???
		 * cell_width = htfp->htf_Xlen/(htfp->htf_i-1);
		 * deltaX = (Xdist*cell_width)/Xdist
		 * deltaY = (Ydist*cell_width)/Xdist;
		 */
		tmp = xWidth/fabs(aray[X]);

#if 0
bu_log("hf: tmp=%g\n", tmp);
bu_log("hf: before VSCALE... aray=(%g,%g,%g)\n",
		aray[X], aray[Y], aray[Z]);
#endif

		VSCALE(aray, aray, tmp);

		/*
		 * Some fudges here.  First, the size of the array of
		 * samples is iXj, but the size of the array of CELLS
		 * is (i-1)X(j-1), therefore number of CELLS is one less
		 * than number of samples and the scaling factor is used.
		 * Second, the math is nice to us.  IF we are entering at
		 * the far end (curloc[X] == Xlen || curloc[Y] == Ylen)
		 * then the result we will get back is of the cell
		 * following this (out of bounds)  So we add a check for
		 * that problem.
		 */
		xCell = curloc[X]/xWidth;
		tmp = curloc[Y];
		if (tmp < 0) {
			yCell = tmp/yWidth - 1;
		} else {
			yCell = tmp/yWidth;
		}

		signX = (aray[X] < 0.0) ? -1 : 1;
		signY = (aray[Y] < 0.0) ? -1 : 1;

		if (RT_G_DEBUG & DEBUG_HF ) {
			bu_log("hf: curloc=(%g, %g, %g) aray=(%g,%g,%g)\n", curloc[X], curloc[Y],
			    curloc[Z], aray[X], aray[Y], aray[Z]);
			bu_log("hf: from=(%g, %g) to=(%g, %g)\n",
			    goesIN[X]/xWidth,
			    goesIN[Y]/yWidth,
			    goesOUT[X]/xWidth,
			    goesOUT[Y]/yWidth);
		}
		error = curloc[Y]-yCell*yWidth;
		error /= yWidth;

/*		delta = aray[Y]/yWidth; */
		delta = aray[Y]/fabs(aray[X]);

#if 0
bu_log("aray[Y]/aray[X]=%g\n", delta);
#endif

		if (delta < 0.0) {
			delta = -delta;
			error = -error;
		} else {
			error -= 1.0;
		}

		/*
		 * if at the far end (Xlen) then we need to move one
		 * step forward along aray.
		 */
		if (xCell >= hf->hf_w-1) {
			xCell+=signX;
			error += delta;
		}
		if (RT_G_DEBUG & DEBUG_HF) {
			bu_log("hf: delta=%g, error=%g, %d, %d\n", 
			   delta, error, xCell, yCell);
		}


		deltaZ = (aray[Z] < 0) ? -aray[Z] : aray[Z];
		do {
			farZ = curloc[Z] + aray[Z];
			maxZ = (curloc[Z] > farZ) ? curloc[Z] : farZ;
			minZ = (curloc[Z] < farZ) ? curloc[Z] : farZ;
			if (RT_G_DEBUG & DEBUG_HF) {
				bu_log("hf: cell %d,%d [%g -- %g]",
				xCell, yCell, minZ, maxZ);
			}
			/*
			 * Are we on the grid yet?  If not, then
			 * we will check for a side step and inc.
			 */
/* CTJ - Or maxZ < hf->hf_min  then no chance to hit */
			if (yCell < 0 || yCell > hf->hf_n-2) {
				if (error > -SQRT_SMALL_FASTF) {
					if (yCell >= -1) goto skip_first;
					yCell += signY;
					error -= 1.0;
				}
				xCell += signX;
				error += delta;
				VADD2(curloc, curloc, aray);
				continue;
			}
					
			/*
			 * Get the min/max of the four corners of
			 * a given cell.  Since the data in memory
			 * can be in one of two forms, unsigned short
			 * and double, we have this simple if statement
			 * around the find min/max to reference the data
			 * correctly.
			 */
			if (hf->hf_shorts) {
				register unsigned short *sp;
				sp = (unsigned short *)hf->hf_mp->apbuf +
				    yCell * hf->hf_w + xCell;
				/* 0,0 */
				highest = lowest = *sp++;
				/* 1,0 */
				if (lowest > (double)*sp) lowest=*sp;
				if (highest < (double)*sp) highest=*sp;
				sp+=hf->hf_w;
				/* 1,1 */
				if (lowest > (double)*sp) lowest=*sp;
				if (highest < (double)*sp) highest=*sp;
				sp--;
				/* 0,1 */
				if (lowest > (double)*sp) lowest = *sp;
				if (highest < (double)*sp) highest = *sp;
				lowest *= hf->hf_file2mm;
				highest *= hf->hf_file2mm;
			} else {
				register double *fp;
				fp = (double *)hf->hf_mp->apbuf +
				    yCell * hf->hf_w + xCell;
				/* 0,0 */
				highest = lowest = *fp++;
				/* 1,0 */
				if (lowest > *fp) lowest=*fp;
				if (highest < *fp) highest=*fp;
				fp+=hf->hf_w;
				/* 1,1 */
				if (lowest > *fp) lowest=*fp;
				if (highest < *fp) highest=*fp;
				fp--;
				/* 0,1 */
				if (lowest > *fp) lowest = *fp;
				if (highest < *fp) highest = *fp;
				lowest *= hf->hf_file2mm;
				highest *= hf->hf_file2mm;
			}

			if (RT_G_DEBUG & DEBUG_HF) {
				bu_log("lowest=%g, highest=%g\n", 
				    lowest, highest);
			}

/*
 * This is the primary test.  It is designed to get all cells that the
 * ray passes through.
 */
#if 1
			if (maxZ+deltaZ > lowest &&
			    minZ-deltaZ < highest ) {
#else
			{
#endif
				int r;
				if ( (r=rt_hf_cell_shot(stp, rp, ap, hp, xCell, yCell)) ) {
					if ((nhits+=r)>=MAXHITS) rt_bomb("g_hf.c: too many hits.\n");
					hp+=r;
				}
			}
/*
 * This is the DDA trying to fill in the corners as it walks the
 * path.
 */
skip_first:
			if (error > SQRT_SMALL_FASTF) {
				yCell += signY;
				if (RT_G_DEBUG & DEBUG_HF) {
					bu_log("hf: cell %d,%d ", xCell, yCell);
				}
				if ((yCell < 0) || yCell > hf->hf_n-2) {
					error -= 1.0;
					xCell += signX;
					error += delta;
					VADD2(curloc, curloc, aray);
					continue;
				}
				if (hf->hf_shorts) {
					register unsigned short *sp;
					sp = (unsigned short *)hf->hf_mp->apbuf +
					    yCell * hf->hf_w + xCell;
					/* 0,0 */
					highest = lowest = *sp++;
					/* 1,0 */
					if (lowest > (double)*sp) lowest=*sp;
					if (highest < (double)*sp) highest=*sp;
					sp+=hf->hf_w;
					/* 1,1 */
					if (lowest > (double)*sp) lowest=*sp;
					if (highest < (double)*sp) highest=*sp;
					sp--;
					/* 0,1 */
					if (lowest > (double)*sp) lowest = *sp;
					if (highest < (double)*sp) highest = *sp;
					lowest *= hf->hf_file2mm;
					highest *= hf->hf_file2mm;
				} else {
					register double *fp;
					fp = (double *)hf->hf_mp->apbuf +
					    yCell * hf->hf_w + xCell;
					/* 0,0 */
					highest = lowest = *fp++;
					/* 1,0 */
					if (lowest > *fp) lowest=*fp;
					if (highest < *fp) highest=*fp;
					fp+=hf->hf_w;
					/* 1,1 */
					if (lowest > *fp) lowest=*fp;
					if (highest < *fp) highest=*fp;
					fp--;
					/* 0,1 */
					if (lowest > *fp) lowest = *fp;
					if (highest < *fp) highest = *fp;
					lowest *= hf->hf_file2mm;
					highest *= hf->hf_file2mm;
				}
#if 1
				if (maxZ+deltaZ > lowest &&
				    minZ-deltaZ < highest) {
#else
				{
#endif /* 0 */
					int r;
					/* DO HIT */
					if ( (r=rt_hf_cell_shot(stp, rp, ap, hp, xCell, yCell)) ) {
						if ((nhits+=r)>=MAXHITS) rt_bomb("g_hf.c: too many hits.\n");
						hp+=r;
					}
				}
				error -= 1.0;
			} else if (error > -SQRT_SMALL_FASTF) {
				yCell += signY;
				error -= 1.0;
			}
			xCell += signX;
			error += delta;
			VADD2(curloc, curloc, aray);
		} while (xCell >= 0 && xCell < hf->hf_w-1 );
		if (RT_G_DEBUG & DEBUG_HF) {
			bu_log("htf: leaving loop, %d, %d, %g vs. 0--%d, 0--%d, 0.0--%g\n",
			   xCell, yCell, curloc[Z], hf->hf_w-1, hf->hf_n-1, hf->hf_max);
		}
/* OTHER HALF */
	} else {
		double tmp;
		register double farZ, minZ, maxZ;
		double	deltaZ;
		int	xCell, yCell, signX, signY;
		double	highest,lowest, error,delta;

		vect_t	goesIN, goesOUT;

		VJOIN1(goesIN, rp->r_pt, allDist[4], rp->r_dir);
		VJOIN1(goesOUT,rp->r_pt, allDist[1], rp->r_dir);
		VSUB2(aray, goesOUT, goesIN);
		VSUB2(curloc, goesIN, hf->hf_V);


		/*
		 * We will be stepping one "cell width" in the X direction
		 * each time through the loop.  In simple case we have???
		 * cell_width = htfp->htf_Xlen/(htfp->htf_i-1);
		 * deltaX = (Xdist*cell_width)/Xdist
		 * deltaY = (Ydist*cell_width)/Xdist;
		 */
		tmp = yWidth/fabs(aray[Y]);

#if 0
bu_log("hf: tmp=%g\n", tmp);
bu_log("hf: before VSCALE... aray=(%g,%g,%g)\n",
		aray[X], aray[Y], aray[Z]);
#endif

		VSCALE(aray, aray, tmp);

		/*
		 * Some fudges here.  First, the size of the array of
		 * samples is iXj, but the size of the array of CELLS
		 * is (i-1)X(j-1), therefore number of CELLS is one less
		 * than number of samples and the scaling factor is used.
		 * Second, the math is nice to us.  IF we are entering at
		 * the far end (curloc[X] == Xlen || curloc[Y] == Ylen)
		 * then the result we will get back is of the cell
		 * following this (out of bounds)  So we add a check for
		 * that problem.
		 */
		yCell = curloc[Y]/yWidth;
		tmp = curloc[X];
		if (tmp < 0) {
			xCell = tmp/xWidth - 1;
		} else {
			xCell = tmp/xWidth;
		}

		signX = (aray[X] < 0.0) ? -1 : 1;
		signY = (aray[Y] < 0.0) ? -1 : 1;

		if (RT_G_DEBUG & DEBUG_HF ) {
			bu_log("hf: curloc=(%g, %g, %g) aray=(%g,%g,%g)\n", curloc[X], curloc[Y],
			    curloc[Z], aray[X], aray[Y], aray[Z]);
			bu_log("hf: from=(%g, %g) to=(%g, %g)\n",
			    goesIN[X]/xWidth,
			    goesIN[Y]/yWidth,
			    goesOUT[X]/xWidth,
			    goesOUT[Y]/yWidth);
		}
		error = curloc[X]-xCell*xWidth;
		error /= xWidth;

/*		delta = aray[X]/xWidth; */
		delta = aray[X]/fabs(aray[Y]);

#if 0
bu_log("aray[X]/aray[Y]=%g\n", delta);
#endif

		if (delta < 0.0) {
			delta = -delta;
			error = -error;
		} else {
			error -= 1.0;
		}

		/*
		 * if at the far end (Ylen) then we need to move one
		 * step forward along aray.
		 */
		if (yCell >= hf->hf_n-1) {
			yCell+=signY;
			error += delta;
		}
		if (RT_G_DEBUG & DEBUG_HF) {
			bu_log("hf: delta=%g, error=%g, %d, %d\n", 
			   delta, error, xCell, yCell);
		}

		deltaZ = (aray[Z] < 0) ? -aray[Z] : aray[Z];
		do {
			farZ = curloc[Z] + aray[Z];
			maxZ = (curloc[Z] > farZ) ? curloc[Z] : farZ;
			minZ = (curloc[Z] < farZ) ? curloc[Z] : farZ;
			if (RT_G_DEBUG & DEBUG_HF) {
				bu_log("hf: cell %d,%d [%g -- %g] ",
				xCell, yCell, minZ, maxZ);
			}
/* CTJ - Or maxZ < hf->hf_min */
			if (xCell < 0 || xCell > hf->hf_w-2) {
				if (error > -SQRT_SMALL_FASTF) {
					if (xCell >= -1) goto skip_2nd;
					xCell += signX;
					error -= 1.0;
				}
				yCell += signY;
				error += delta;
				VADD2(curloc, curloc, aray);
				continue;
			}
					
			if (hf->hf_shorts) {
				register unsigned short *sp;
				sp = (unsigned short *)hf->hf_mp->apbuf +
				    yCell * hf->hf_w + xCell;
				/* 0,0 */
				highest = lowest = *sp++;
				/* 1,0 */
				if (lowest > (double)*sp) lowest=*sp;
				if (highest < (double)*sp) highest=*sp;
				sp+=hf->hf_w;
				/* 1,1 */
				if (lowest > (double)*sp) lowest=*sp;
				if (highest < (double)*sp) highest=*sp;
				sp--;
				/* 0,1 */
				if (lowest > (double)*sp) lowest = *sp;
				if (highest < (double)*sp) highest = *sp;
				lowest *= hf->hf_file2mm;
				highest *= hf->hf_file2mm;
			} else {
				register double *fp;
				fp = (double *)hf->hf_mp->apbuf +
				    yCell * hf->hf_w + xCell;
				/* 0,0 */
				highest = lowest = *fp++;
				/* 1,0 */
				if (lowest > *fp) lowest=*fp;
				if (highest < *fp) highest=*fp;
				fp+=hf->hf_w;
				/* 1,1 */
				if (lowest > *fp) lowest=*fp;
				if (highest < *fp) highest=*fp;
				fp--;
				/* 0,1 */
				if (lowest > *fp) lowest = *fp;
				if (highest < *fp) highest = *fp;
				lowest *= hf->hf_file2mm;
				highest *= hf->hf_file2mm;
			}


			if (RT_G_DEBUG & DEBUG_HF) {
				bu_log("lowest=%g, highest=%g\n", 
				    lowest, highest);
			}

/*
 * This is the primary test.  It is designed to get all cells that the
 * ray passes through.
 */
#if 1
			if (maxZ+deltaZ > lowest &&
			    minZ-deltaZ < highest ) {
#else
			{
#endif
				int r;
				if ( (r=rt_hf_cell_shot(stp, rp, ap, hp, xCell, yCell)) ) {
					if ((nhits+=r)>=MAXHITS) rt_bomb("g_hf.c: too many hits.\n");
					hp+=r;
				}
			}
/*
 * This is the DDA trying to fill in the corners as it walks the
 * path.
 */
skip_2nd:
			if (error > SQRT_SMALL_FASTF) {
				xCell += signX;
				if (RT_G_DEBUG & DEBUG_HF) {
					bu_log("hf: cell %d,%d\n", xCell, yCell);
				}
				if ((xCell < 0) || xCell > hf->hf_w-2) {
					error -= 1.0;
					yCell += signY;
					error += delta;
					VADD2(curloc, curloc, aray);
					continue;
				}
				if (hf->hf_shorts) {
					register unsigned short *sp;
					sp = (unsigned short *)hf->hf_mp->apbuf +
					    yCell * hf->hf_w + xCell;
					/* 0,0 */
					highest = lowest = *sp++;
					/* 1,0 */
					if (lowest > (double)*sp) lowest=*sp;
					if (highest < (double)*sp) highest=*sp;
					sp+=hf->hf_w;
					/* 1,1 */
					if (lowest > (double)*sp) lowest=*sp;
					if (highest < (double)*sp) highest=*sp;
					sp--;
					/* 0,1 */
					if (lowest > (double)*sp) lowest = *sp;
					if (highest < (double)*sp) highest = *sp;
					lowest *= hf->hf_file2mm;
					highest *= hf->hf_file2mm;
				} else {
					register double *fp;
					fp = (double *)hf->hf_mp->apbuf +
					    yCell * hf->hf_w + xCell;
					/* 0,0 */
					highest = lowest = *fp++;
					/* 1,0 */
					if (lowest > *fp) lowest=*fp;
					if (highest < *fp) highest=*fp;
					fp+=hf->hf_w;
					/* 1,1 */
					if (lowest > *fp) lowest=*fp;
					if (highest < *fp) highest=*fp;
					fp--;
					/* 0,1 */
					if (lowest > *fp) lowest = *fp;
					if (highest < *fp) highest = *fp;
					lowest *= hf->hf_file2mm;
					highest *= hf->hf_file2mm;
				}
#if 1
				if (maxZ+deltaZ > lowest &&
				    minZ-deltaZ < highest) {
#else
				{
#endif
					int r;
					/* DO HIT */
					if ( (r=rt_hf_cell_shot(stp, rp, ap, hp, xCell, yCell)) ) {
						if ((nhits+=r)>=MAXHITS) rt_bomb("g_hf.c: too many hits.\n");
						hp+=r;
					}
				}
				error -= 1.0;
			} else if (error > -SQRT_SMALL_FASTF) {
				xCell += signX;
				error -= 1.0;
			}
			yCell += signY;
			error += delta;
			VADD2(curloc, curloc, aray);
		} while (yCell >= 0 && yCell < hf->hf_n-1 );
		if (RT_G_DEBUG & DEBUG_HF) {
			bu_log("htf: leaving loop, %d, %d, %g vs. 0--%d, 0--%d, 0.0--%g\n",
			   xCell, yCell, curloc[Z], hf->hf_w-1, hf->hf_n-1, hf->hf_max);
		}
	}
	/* Sort hits, near to Far */
	{
		register int i,j;
		LOCAL struct hit tmp;
		for ( i=0; i< nhits-1; i++) {
			for (j=i+1; j<nhits; j++) {
				if (hits[i].hit_dist <= hits[j].hit_dist) continue;
				tmp = hits[j];
				hits[j]=hits[i];
				hits[i]=tmp;
			}
		}
	}
	if ( nhits & 1) {
		register int i;
		static int nerrors = 0;
		hits[nhits] = hits[nhits-1];	/* struct copy*/
		VREVERSE(hits[nhits].hit_normal, hits[nhits-1].hit_normal);
		nhits++;
		if (nerrors++ < 300 ) {
			bu_log("rt_hf_shot(%s): %d hit(s)@@ %d %d: ", stp->st_name, nhits-1,ap->a_x, ap->a_y);
			for(i=0; i< nhits; i++) {
				bu_log("%f(%d), ",hits[i].hit_dist,hits[i].hit_surfno);
			}
			bu_log("\n");
		}
#if 0
rt_g.debug |= DEBUG_HF;
rt_bomb("Odd number of hits.");
#endif
	}
	/* nhits is even, build segments */
	{
		register struct seg *segp;
		register int i;
		for (i=0; i< nhits; i+=2) {
			RT_GET_SEG(segp, ap->a_resource);
			segp->seg_stp = stp;
			segp->seg_in = hits[i];
			segp->seg_out= hits[i+1];
			BU_LIST_INSERT( &(seghead->l), &(segp->l));
		}
	}
	return nhits;	/* hits or misses */
}
/*
 *  			R T _ H F _ N O R M
 *  
 *  Given ONE ray distance, return the normal and entry/exit point.
 */
void
rt_hf_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
{
	register struct hf_specific *hf =
		(struct hf_specific *)stp->st_specific;
	register int j;

	j = hitp->hit_surfno;

	VJOIN1( hitp->hit_point, rp->r_pt, hitp->hit_dist, rp->r_dir );
	if (j >= 0) {
		/* Normals computed in rt_htf_shot, nothing to do here. */
		return;
	}

	switch (j) {
	case -1:
		VREVERSE(hitp->hit_normal, hf->hf_X);
		break;
	case -2:
		VREVERSE(hitp->hit_normal, hf->hf_Y);
		break;
	case -3:
		VREVERSE(hitp->hit_normal, hf->hf_N);
		break;
	case -4:
		VMOVE(hitp->hit_normal, hf->hf_X);
		break;
	case -5:
		VMOVE(hitp->hit_normal, hf->hf_Y);
		break;
	case -6:
		VMOVE(hitp->hit_normal, hf->hf_N);
		break;
	}
	VUNITIZE(hitp->hit_normal);

}

/*
 *			R T _ H F _ C U R V E
 *
 *  Return the curvature of the hf.
 */
void
rt_hf_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
{
 	cvp->crv_c1 = cvp->crv_c2 = 0;

	/* any tangent direction */
 	bn_vec_ortho( cvp->crv_pdir, hitp->hit_normal );
}

/*
 *  			R T _ H F _ U V
 *  
 *  For a hit on the surface of an hf, return the (u,v) coordinates
 *  of the hit point, 0 <= u,v <= 1.
 *  u = azimuth
 *  v = elevation
 */
void
rt_hf_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
{
	register struct hf_specific *hf =
		(struct hf_specific *)stp->st_specific;
	vect_t delta;
	fastf_t r = 0;

	VSUB2(delta, hitp->hit_point, hf->hf_V);
#if 0
	VUNITIZE(delta);
	uvp->uv_u = VDOT(delta, hf->hf_X);
	uvp->uv_v = VDOT(delta, hf->hf_Y);
	r = ap->a_rbeam + ap->a_diverge * hitp->hit_dist;
#else
	uvp->uv_u = delta[X] / hf->hf_Xlen;
	uvp->uv_v = delta[Y] / hf->hf_Ylen;
	r = 0.0;
#endif
	if (uvp->uv_u < 0.0) uvp->uv_u=0.0;
	if (uvp->uv_u > 1.0) uvp->uv_u=1.0;
	if (uvp->uv_v < 0.0) uvp->uv_v=0.0;
	if (uvp->uv_v > 1.0) uvp->uv_v=1.0;

	uvp->uv_du = r;
	uvp->uv_dv = r;
}

/*
 *		R T _ H F _ F R E E
 */
void
rt_hf_free(register struct soltab *stp)
{
	register struct hf_specific *hf =
		(struct hf_specific *)stp->st_specific;

	if (hf->hf_mp) {
		bu_close_mapped_file(hf->hf_mp);
		hf->hf_mp = (struct bu_mapped_file *)0;
	}
	bu_free( (char *)hf, "hf_specific" );
}

/*
 *			R T _ H F _ C L A S S
 */
int
rt_hf_class(void)
{
	return(0);
}

/*
 *			R T _ H F _ P L O T
 */
int
rt_hf_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
	LOCAL struct rt_hf_internal	*xip;
	register unsigned short		*sp = (unsigned short *)NULL;
	register double *dp;
	vect_t		xbasis;
	vect_t		ybasis;
	vect_t		zbasis;
	point_t		start;
	point_t		cur;
	int		x;
	int		y;
	int		cmd;
	int		step;
	int		half_step;
	int		goal;

	RT_CK_DB_INTERNAL(ip);
	xip = (struct rt_hf_internal *)ip->idb_ptr;
	RT_HF_CK_MAGIC(xip);

	VSCALE( xbasis, xip->x, xip->xlen / (xip->w - 1) );
	VSCALE( ybasis, xip->y, xip->ylen / (xip->n - 1) );
	VCROSS( zbasis, xip->x, xip->y );
	VSCALE( zbasis, zbasis, xip->zscale * xip->file2mm );

	/* XXX This should be set from the tessellation tolerance */
	goal = 20000;

	/* Draw the 4 corners of the base plate */
	RT_ADD_VLIST( vhead, xip->v, BN_VLIST_LINE_MOVE );

	VJOIN1( start, xip->v, xip->xlen, xip->x );
	RT_ADD_VLIST( vhead, start, BN_VLIST_LINE_DRAW );

	VJOIN2( start, xip->v, xip->xlen, xip->x, xip->ylen, xip->y );
	RT_ADD_VLIST( vhead, start, BN_VLIST_LINE_DRAW );

	VJOIN1( start, xip->v, xip->ylen, xip->y );
	RT_ADD_VLIST( vhead, start, BN_VLIST_LINE_DRAW );

	RT_ADD_VLIST( vhead, xip->v, BN_VLIST_LINE_DRAW );
	goal -= 5;

#define HF_GET(_p,_x,_y)	((_p)[(_y)*xip->w+(_x)])
	/*
	 *  Draw the four "ridge lines" at full resolution, for edge matching.
	 */
	if (xip->shorts) {
		/* X direction, Y=0, with edges down to base */
		RT_ADD_VLIST( vhead, xip->v, BN_VLIST_LINE_MOVE );
		sp = &HF_GET((unsigned short *)xip->mp->apbuf, 0, 0 );
		for( x = 0; x < xip->w; x++ )  {
			VJOIN2( cur, xip->v, x, xbasis, *sp, zbasis );
			RT_ADD_VLIST(vhead, cur, BN_VLIST_LINE_DRAW );
			sp++;
		}
		VJOIN1( cur, xip->v, xip->xlen, xip->x );
		RT_ADD_VLIST( vhead, cur, BN_VLIST_LINE_DRAW );

		/* X direction, Y=n-1, with edges down to base */
		VJOIN1( start, xip->v, xip->ylen, xip->y );
		RT_ADD_VLIST( vhead, start, BN_VLIST_LINE_MOVE );
		sp = &HF_GET((unsigned short *)xip->mp->apbuf, 0, xip->n - 1 );
		VJOIN1( start, xip->v, xip->ylen, xip->y );
		for( x = 0; x < xip->w; x++ )  {
			VJOIN2( cur, start, x, xbasis, *sp, zbasis );
			RT_ADD_VLIST(vhead, cur, BN_VLIST_LINE_DRAW );
			sp++;
		}
		VJOIN2( cur, xip->v, xip->xlen, xip->x, xip->ylen, xip->y );
		RT_ADD_VLIST( vhead, cur, BN_VLIST_LINE_DRAW );

		/* Y direction, X=0 */
		cmd = BN_VLIST_LINE_MOVE;
		sp = &HF_GET((unsigned short *)xip->mp->apbuf, 0, 0 );
		for( y = 0; y < xip->n; y++ )  {
			VJOIN2( cur, xip->v, y, ybasis, *sp, zbasis );
			RT_ADD_VLIST(vhead, cur, cmd );
			cmd = BN_VLIST_LINE_DRAW;
			sp += xip->w;
		}

		/* Y direction, X=w-1 */
		cmd = BN_VLIST_LINE_MOVE;
		sp = &HF_GET((unsigned short *)xip->mp->apbuf, xip->w - 1, 0 );
		VJOIN1( start, xip->v, xip->xlen, xip->x );
		for( y = 0; y < xip->n; y++ )  {
			VJOIN2( cur, start, y, ybasis, *sp, zbasis );
			RT_ADD_VLIST(vhead, cur, cmd );
			cmd = BN_VLIST_LINE_DRAW;
			sp += xip->w;
		}
	} else {
		/* X direction, Y=0, with edges down to base */
		RT_ADD_VLIST( vhead, xip->v, BN_VLIST_LINE_MOVE );
		dp = &HF_GET((double *)xip->mp->apbuf, 0, 0 );
		for( x = 0; x < xip->w; x++ )  {
			VJOIN2( cur, xip->v, x, xbasis, *dp, zbasis );
			RT_ADD_VLIST(vhead, cur, BN_VLIST_LINE_DRAW );
			dp++;
		}
		VJOIN1( cur, xip->v, xip->xlen, xip->x );
		RT_ADD_VLIST( vhead, cur, BN_VLIST_LINE_DRAW );

		/* X direction, Y=n-1, with edges down to base */
		VJOIN1( start, xip->v, xip->ylen, xip->y );
		RT_ADD_VLIST( vhead, start, BN_VLIST_LINE_MOVE );
		dp = &HF_GET((double *)xip->mp->apbuf, 0, xip->n - 1 );
		VJOIN1( start, xip->v, xip->ylen, xip->y );
		for( x = 0; x < xip->w; x++ )  {
			VJOIN2( cur, start, x, xbasis, *dp, zbasis );
			RT_ADD_VLIST(vhead, cur, BN_VLIST_LINE_DRAW );
			dp++;
		}
		VJOIN2( cur, xip->v, xip->xlen, xip->x, xip->ylen, xip->y );
		RT_ADD_VLIST( vhead, cur, BN_VLIST_LINE_DRAW );

		/* Y direction, X=0 */
		cmd = BN_VLIST_LINE_MOVE;
		dp = &HF_GET((double *)xip->mp->apbuf, 0, 0 );
		for( y = 0; y < xip->n; y++ )  {
			VJOIN2( cur, xip->v, y, ybasis, *dp, zbasis );
			RT_ADD_VLIST(vhead, cur, cmd );
			cmd = BN_VLIST_LINE_DRAW;
			sp += xip->w;
		}

		/* Y direction, X=w-1 */
		cmd = BN_VLIST_LINE_MOVE;
		dp = &HF_GET((double *)xip->mp->apbuf, xip->w - 1, 0 );
		VJOIN1( start, xip->v, xip->xlen, xip->x );
		for( y = 0; y < xip->n; y++ )  {
			VJOIN2( cur, start, y, ybasis, *dp, zbasis );
			RT_ADD_VLIST(vhead, cur, cmd );
			cmd = BN_VLIST_LINE_DRAW;
			dp += xip->w;
		}
	}
	goal -= 4 + 2 * (xip->w + xip->n);

	/* Apply relative tolerance, if specified */
	if( ttol->rel )  {
		int	rstep;
		rstep = xip->w;
		V_MAX( rstep, xip->n );
		step = (int)(ttol->rel * rstep);
	} else {
		/* No relative tol specified, limit drawing to 'goal' # of vectors */
		if( goal <= 0 )  return 0;		/* no vectors for interior */

		/* Compute data stride based upon producing no more than 'goal' vectors */
		step = ceil(sqrt( 2*(xip->w-1)*(xip->n-1) / (double)goal ));
	}
	if( step < 1 )  step = 1;
	if( (half_step = step/2) < 1 )  half_step = 1;

	/* Draw the contour lines in W (x) direction.  Don't redo ridges. */
	for( y = half_step; y < xip->n-half_step; y += step )  {
		VJOIN1( start, xip->v, y, ybasis );
		x = 0;
		if (xip->shorts) {
			sp = &HF_GET((unsigned short *)xip->mp->apbuf, x, y );
			VJOIN2( cur, start, x, xbasis, *sp, zbasis );
			RT_ADD_VLIST(vhead, cur, BN_VLIST_LINE_MOVE );
			x += half_step;
			sp = &HF_GET((unsigned short *)xip->mp->apbuf, x, y );
			for( ; x < xip->w; x += step )  {
				VJOIN2( cur, start, x, xbasis, *sp, zbasis );
				RT_ADD_VLIST(vhead, cur, BN_VLIST_LINE_DRAW );
				sp += step;
			}
			if( x != step+xip->w-1+step )  {
				x = xip->w - 1;
				sp = &HF_GET((unsigned short *)xip->mp->apbuf, x, y );
				VJOIN2( cur, start, x, xbasis, *sp, zbasis );
				RT_ADD_VLIST(vhead, cur, BN_VLIST_LINE_DRAW );
			}
		} else { /* doubles */
			dp = &HF_GET((double *)xip->mp->apbuf, x, y );
			VJOIN2( cur, start, x, xbasis, *dp, zbasis );
			RT_ADD_VLIST(vhead, cur, BN_VLIST_LINE_MOVE );
			x += half_step;
			dp = &HF_GET((double *)xip->mp->apbuf, x, y);
			for (; x < xip->w; x+=step) {
				VJOIN2( cur, start, x, xbasis, *dp, zbasis);
				RT_ADD_VLIST(vhead, cur, BN_VLIST_LINE_DRAW);
				dp += step;
			}
			if (x != step+xip->w-1+step) {
				x = xip->w - 1;
				dp = &HF_GET((double *)xip->mp->apbuf, x, y);
				VJOIN2( cur, start, x, xbasis, *dp, zbasis );
				RT_ADD_VLIST(vhead, cur, BN_VLIST_LINE_DRAW);
			}
		}
	}

	/* Draw the contour lines in the N (y) direction */
	if (xip->shorts) {
		for( x = half_step; x < xip->w-half_step; x += step )  {
			VJOIN1( start, xip->v, x, xbasis );
			y = 0;
			sp = &HF_GET((unsigned short *)xip->mp->apbuf, x, y );
			VJOIN2( cur, start, y, ybasis, *sp, zbasis );
			RT_ADD_VLIST(vhead, cur, BN_VLIST_LINE_MOVE );
			y += half_step;
			for( ; y < xip->n; y += step )  {
				sp = &HF_GET((unsigned short *)xip->mp->apbuf, x, y );
				VJOIN2( cur, start, y, ybasis, *sp, zbasis );
				RT_ADD_VLIST(vhead, cur, BN_VLIST_LINE_DRAW );
			}
			if( y != step+xip->n-1+step )  {
				y = xip->n - 1;
				sp = &HF_GET((unsigned short *)xip->mp->apbuf, x, y );
				VJOIN2( cur, start, y, ybasis, *sp, zbasis );
				RT_ADD_VLIST(vhead, cur, BN_VLIST_LINE_DRAW );
			}
		}
	} else { /* doubles */
		for( x = half_step; x < xip->w-half_step; x += step )  {
			VJOIN1( start, xip->v, x, xbasis );
			y = 0;
			dp = &HF_GET((double *)xip->mp->apbuf, x, y );
			VJOIN2( cur, start, y, ybasis, *dp, zbasis );
			RT_ADD_VLIST(vhead, cur, BN_VLIST_LINE_MOVE );
			y += half_step;
			for( ; y < xip->n; y += step )  {
				dp = &HF_GET((double *)xip->mp->apbuf, x, y );
				VJOIN2( cur, start, y, ybasis, *dp, zbasis );
				RT_ADD_VLIST(vhead, cur, BN_VLIST_LINE_DRAW );
			}
			if( y != step+xip->n-1+step )  {
				y = xip->n - 1;
				dp = &HF_GET((double *)xip->mp->apbuf, x, y );
				VJOIN2( cur, start, y, ybasis, *dp, zbasis );
				RT_ADD_VLIST(vhead, cur, BN_VLIST_LINE_DRAW );
			}
		}
	}
	return 0;
}

/*
 *			R T _ H F _ T E S S
 *
 *  Returns -
 *	-1	failure
 *	 0	OK.  *r points to nmgregion that holds this tessellation.
 */
int
rt_hf_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
	LOCAL struct rt_hf_internal	*xip;

	RT_CK_DB_INTERNAL(ip);
	xip = (struct rt_hf_internal *)ip->idb_ptr;
	RT_HF_CK_MAGIC(xip);

	return(-1);
}

/*
 *			R T _ H F _ I M P O R T
 *
 *  Import an HF from the database format to the internal format.
 *  Apply modeling transformations as well.
 */
int
rt_hf_import(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
{
	LOCAL struct rt_hf_internal	*xip;
	union record			*rp;
	struct bu_vls			str;
	struct bu_mapped_file		*mp;
	vect_t				tmp;
	int				in_cookie;	/* format cookie */
	int				in_len;
	int				out_cookie;
	int				count;
	int				got;

	BU_CK_EXTERNAL( ep );
	rp = (union record *)ep->ext_buf;
	/* Check record type */
	if( rp->u_id != DBID_STRSOL )  {
		bu_log("rt_hf_import: defective record\n");
		return(-1);
	}

	RT_CK_DB_INTERNAL( ip );
	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_HF;
	ip->idb_meth = &rt_functab[ID_HF];
	ip->idb_ptr = bu_calloc( 1, sizeof(struct rt_hf_internal), "rt_hf_internal");
	xip = (struct rt_hf_internal *)ip->idb_ptr;
	xip->magic = RT_HF_INTERNAL_MAGIC;

	/* Provide defaults.  Only non-defaulted fields are dfile, w, n */
	xip->shorts = 1;		/* for now */
	xip->file2mm = 1.0;
	VSETALL( xip->v, 0 );
	VSET( xip->x, 1, 0, 0 );
	VSET( xip->y, 0, 1, 0 );
	xip->xlen = 1000;
	xip->ylen = 1000;
	xip->zscale = 1;
	strcpy( xip->fmt, "nd" );

	/* Process parameters found in .g file */
	bu_vls_init( &str );
	bu_vls_strcpy( &str, rp->ss.ss_args );
	if( bu_struct_parse( &str, rt_hf_parse, (char *)xip ) < 0 )  {
		bu_vls_free( &str );
err1:
		bu_free( (char *)xip , "rt_hf_import: xip" );
		ip->idb_type = ID_NULL;
		ip->idb_ptr = (genptr_t)NULL;
		return -2;
	}
	bu_vls_free( &str );

	/* If "cfile" was specified, process parameters from there */
	if( xip->cfile[0] )  {
		FILE	*fp;

		bu_semaphore_acquire( BU_SEM_SYSCALL );
		fp = fopen( xip->cfile, "r" );
		bu_semaphore_release( BU_SEM_SYSCALL );
		if( !fp )  {
			perror(xip->cfile);
			bu_log("rt_hf_import() unable to open cfile=%s\n", xip->cfile);
			goto err1;
		}
		bu_vls_init( &str );
		while( bu_vls_gets( &str, fp ) >= 0 )
			bu_vls_strcat( &str, " " );
		bu_semaphore_acquire( BU_SEM_SYSCALL );
		fclose(fp);
		bu_semaphore_release( BU_SEM_SYSCALL );
		if( bu_struct_parse( &str, rt_hf_cparse, (char *)xip ) < 0 )  {
			bu_log("rt_hf_import() parse error in cfile input '%s'\n",
				bu_vls_addr(&str) );
			bu_vls_free( &str );
			goto err1;
		}
	}

	/* Check for reasonable values */
	if( !xip->dfile[0] )  {
		/* XXX Should create 2x2 data file instead, for positioning use (FPO) */
		bu_log("rt_hf_import() no dfile specified\n");
		goto err1;
	}
	if( xip->w < 2 || xip->n < 2 )  {
		bu_log("rt_hf_import() w=%d, n=%d too small\n");
		goto err1;
	}
	if( xip->xlen <= 0 || xip->ylen <= 0 )  {
		bu_log("rt_hf_import() xlen=%g, ylen=%g too small\n", xip->xlen, xip->ylen);
		goto err1;
	}

	/* Apply modeling transformations */
	MAT4X3PNT( tmp, mat, xip->v );
	VMOVE( xip->v, tmp );
	MAT4X3VEC( tmp, mat, xip->x );
	VMOVE( xip->x, tmp );
	MAT4X3VEC( tmp, mat, xip->y );
	VMOVE( xip->y, tmp );
	xip->xlen /= mat[15];
	xip->ylen /= mat[15];
	xip->zscale /= mat[15];

	VUNITIZE(xip->x);
	VUNITIZE(xip->y);

	/* Prepare for cracking input file format */
	if( (in_cookie = bu_cv_cookie( xip->fmt )) == 0 )  {
		bu_log("rt_hf_import() fmt='%s' unknown\n", xip->fmt);
		goto err1;
	}
	in_len = bu_cv_itemlen( in_cookie );

	/*
	 *  Load data file, and transform to internal format
	 */
	if( !(mp = bu_open_mapped_file( xip->dfile, "hf" )) )  {
		bu_log("rt_hf_import() unable to open '%s'\n", xip->dfile);
		goto err1;
	}
	xip->mp = mp;
	count = mp->buflen / in_len;

	/* If this data has already been mapped, all done */
	if( mp->apbuf )  return 0;		/* OK */

	/* Transform external data to internal format -- short or double */
	if( xip->shorts )  {
		mp->apbuflen = sizeof(unsigned short) * count;
		out_cookie = bu_cv_cookie("hus");
	} else {
		mp->apbuflen = sizeof(double) * count;
		out_cookie = bu_cv_cookie("hd");
	}

	if( bu_cv_optimize(in_cookie) == bu_cv_optimize(out_cookie) )  {
		/* Don't replicate the data, just re-use the pointer */
		mp->apbuf = mp->buf;
		return 0;		/* OK */
	}

	mp->apbuf = (genptr_t)bu_malloc( mp->apbuflen, "rt_hf_import apbuf[]" );
	got = bu_cv_w_cookie( mp->apbuf, out_cookie, mp->apbuflen,
		mp->buf, in_cookie, count );
	if( got != count )  {
		bu_log("rt_hf_import(%s) bu_cv_w_cookie count=%d, got=%d\n",
			xip->dfile, count, got );
	}

	return(0);			/* OK */
}

/*
 *			R T _ H F _ E X P O R T
 *
 *  The name is added by the caller, in the usual place.
 *
 *  The meaning of the export here is slightly different than that of
 *  most other solids.  The cfile and dfile are not modified, only
 *  changes to the string solid parameters are placed back into the .g file.
 *  Note that any parameters taken from a cfile are included in the new
 *  string solid.  This isn't a problem, because if the cfile is changed
 *  (perhaps to substitute a different resolution height field of the same
 *  location in space), it's new parameters will override those stored
 *  in the string solid (including the dfile name).
 */
int
rt_hf_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
{
	struct rt_hf_internal	*xip;
	union record		*rec;
	struct bu_vls		str;

	RT_CK_DB_INTERNAL(ip);
	if( ip->idb_type != ID_HF )  return(-1);
	xip = (struct rt_hf_internal *)ip->idb_ptr;
	RT_HF_CK_MAGIC(xip);

	/* Apply any scale transformation */
	xip->xlen /= local2mm;
	xip->ylen /= local2mm;
	xip->zscale /= local2mm;

	BU_CK_EXTERNAL(ep);
	ep->ext_nbytes = sizeof(union record) * DB_SS_NGRAN;
	ep->ext_buf = (genptr_t)bu_calloc( 1, ep->ext_nbytes, "hf external");
	rec = (union record *)ep->ext_buf;

	bu_vls_init( &str );
	bu_vls_struct_print( &str, rt_hf_parse, (char *)xip );

	/* Any changes made by solid editing affect .g file only,
	 * and not the cfile, if specified.
	 */

	rec->s.s_id = DBID_STRSOL;
	strncpy( rec->ss.ss_keyword, "hf", NAMESIZE-1 );
	strncpy( rec->ss.ss_args, bu_vls_addr(&str), DB_SS_LEN-1 );
	bu_vls_free( &str );

	return(0);
}

int
rt_hf_import5(struct rt_db_internal *ip, const struct bu_external *ep, const fastf_t *mat, const struct db_i *dbip)
{
	bu_log( "As of release 6.0 the HF primitive is superceded by the DSP primitive.\n" );
	bu_log( "\tTo convert HF primitives to DSP, use 'dbupgrade'.\n");
	/* The rt_hf_to_dsp() routine can also be used */
	return -1;
}

int
rt_hf_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
{
	bu_log( "As of release 6.0 the HF primitive is superceded by the DSP primitive.\n" );
	bu_log( "\tTo convert HF primitives to DSP, use 'dbupgrade'.\n" );
	/* The rt_hf_to_dsp() routine can also be used */
	return -1;
}

/*
 *			R T _ H F _ D E S C R I B E
 *
 *  Make human-readable formatted presentation of this solid.
 *  First line describes type of solid.
 *  Additional lines are indented one tab, and give parameter values.
 */
int
rt_hf_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
{
#ifndef NO_MAGIC_CHECKING
	register struct rt_hf_internal	*xip =
		(struct rt_hf_internal *)ip->idb_ptr;

	BU_CK_VLS(str);
	RT_HF_CK_MAGIC(xip);
#endif
	bu_vls_printf( str, "Height Field (HF)  mm2local=%g\n", mm2local);
	bu_vls_struct_print( str, rt_hf_parse, ip->idb_ptr );
	bu_vls_strcat( str, "\n" );

	return(0);
}

/*
 *			R T _ H F _ I F R E E
 *
 *  Free the storage associated with the rt_db_internal version of this solid.
 */
void
rt_hf_ifree(struct rt_db_internal *ip)
{
	register struct rt_hf_internal	*xip;

	RT_CK_DB_INTERNAL(ip);
	xip = (struct rt_hf_internal *)ip->idb_ptr;
	RT_HF_CK_MAGIC(xip);
	xip->magic = 0;			/* sanity */

	if( xip->mp )
	{
		BU_CK_MAPPED_FILE(xip->mp);
		bu_close_mapped_file(xip->mp);
	}

	bu_free( (char *)xip, "hf ifree" );
	ip->idb_ptr = GENPTR_NULL;	/* sanity */
}
@


11.56
log
@change conf.h to a wrapped config.h
@
text
@d28 1
a28 1
static char rt_hf_RcSid[] = "@@(#)$Header: /cvs/brlcad/librt/g_hf.c,v 11.55 2004/04/05 08:48:56 morrison Exp $ (ARL)";
@


11.55
log
@merge of ansi-6-0-branch into HEAD
@
text
@d28 1
a28 1
static char rt_hf_RcSid[] = "@@(#)$Header$ (ARL)";
d31 5
a35 1
#include "conf.h"
@


11.54
log
@put lint var in lint section
@
text
@d28 1
a28 1
static char rt_hf_RcSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_hf.c,v 11.53 2004/02/02 17:39:20 morrison Exp $ (ARL)";
d213 1
a213 4
rt_hf_prep( stp, ip, rtip )
struct soltab		*stp;
struct rt_db_internal	*ip;
struct rt_i		*rtip;
d356 1
a356 2
rt_hf_print( stp )
register const struct soltab *stp;
d369 1
a369 6
rt_hf_cell_shot(stp, rp, ap, hitp, xCell, yCell)
struct soltab		*stp;
register struct xray	*rp;
struct application	*ap;
struct hit		*hitp;
int			xCell, yCell;
d663 1
a663 9
axis_plane_isect(plane, inout, rp, hf, xWidth, yWidth, hp, nhits)
int plane;
fastf_t inout;
struct xray	*rp;
struct hf_specific *hf;
double xWidth, yWidth;
struct hit **hp;
int *nhits;

d771 1
a771 5
rt_hf_shot( stp, rp, ap, seghead )
struct soltab		*stp;
register struct xray	*rp;
struct application	*ap;
struct seg		*seghead;
d1549 1
a1549 4
rt_hf_norm( hitp, stp, rp )
register struct hit	*hitp;
struct soltab		*stp;
register struct xray	*rp;
d1593 1
a1593 4
rt_hf_curve( cvp, hitp, stp )
register struct curvature *cvp;
register struct hit	*hitp;
struct soltab		*stp;
d1610 1
a1610 5
rt_hf_uv( ap, stp, hitp, uvp )
struct application	*ap;
struct soltab		*stp;
register struct hit	*hitp;
register struct uvcoord	*uvp;
d1641 1
a1641 2
rt_hf_free( stp )
register struct soltab *stp;
d1657 1
a1657 1
rt_hf_class()
d1666 1
a1666 5
rt_hf_plot( vhead, ip, ttol, tol )
struct bu_list		*vhead;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol		*tol;
d1917 1
a1917 6
rt_hf_tess( r, m, ip, ttol, tol )
struct nmgregion	**r;
struct model		*m;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol		*tol;
d1935 1
a1935 5
rt_hf_import( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
d2104 1
a2104 5
rt_hf_export( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d2141 1
a2141 5
rt_hf_import5( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
const mat_t			mat;
const struct db_i		*dbip;
d2150 1
a2150 5
rt_hf_export5( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d2166 1
a2166 5
rt_hf_describe( str, ip, verbose, mm2local )
struct bu_vls		*str;
const struct rt_db_internal	*ip;
int			verbose;
double			mm2local;
d2188 1
a2188 2
rt_hf_ifree( ip )
struct rt_db_internal	*ip;
@


11.53
log
@update copyright to include span through 2003
@
text
@d28 1
a28 1
static char rt_hf_RcSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_hf.c,v 11.52 2002/08/20 17:08:00 jra Exp $ (ARL)";
d226 1
d228 1
@


11.52
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d24 1
a24 1
 *	This software is Copyright (C) 1994 by the United States Army
d28 1
a28 1
static char rt_hf_RcSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_hf.c,v 11.50 2001/10/05 00:45:30 butler Exp $ (ARL)";
@


11.52.4.1
log
@sync to HEAD...
@
text
@d24 1
a24 1
 *	This software is Copyright (C) 1994-2004 by the United States Army
d28 1
a28 1
static char rt_hf_RcSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/g_hf.c,v 11.54 2004/03/03 21:24:05 morrison Exp $ (ARL)";
a225 1
#ifndef lint
a226 1
#endif
@


11.52.10.1
log
@merge from HEAD
@
text
@d24 1
a24 1
 *	This software is Copyright (C) 1994-2004 by the United States Army
d28 1
a28 1
static char rt_hf_RcSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_hf.c,v 11.53 2004/02/02 17:39:20 morrison Exp $ (ARL)";
@


11.52.10.2
log
@merge from head
@
text
@d28 1
a28 1
static char rt_hf_RcSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_hf.c,v 11.54 2004/03/03 21:24:05 morrison Exp $ (ARL)";
a225 1
#ifndef lint
a226 1
#endif
@


11.52.10.3
log
@merge from head
@
text
@d28 1
a28 1
static char rt_hf_RcSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_hf.c,v 11.52.10.2 2004/03/10 13:17:54 erikg Exp $ (ARL)";
@


11.52.2.1
log
@Initial ANSIfication
@
text
@d28 1
a28 1
static char rt_hf_RcSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_hf.c,v 11.52 2002/08/20 17:08:00 jra Exp $ (ARL)";
d213 4
a216 1
rt_hf_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
d357 2
a358 1
rt_hf_print(register const struct soltab *stp)
d371 6
a376 1
rt_hf_cell_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct hit *hitp, int xCell, int yCell)
d670 9
a678 1
axis_plane_isect(int plane, fastf_t inout, struct xray *rp, struct hf_specific *hf, double xWidth, double yWidth, struct hit **hp, int *nhits)
d786 5
a790 1
rt_hf_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
d1568 4
a1571 1
rt_hf_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
d1615 4
a1618 1
rt_hf_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
d1635 5
a1639 1
rt_hf_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
d1670 2
a1671 1
rt_hf_free(register struct soltab *stp)
d1687 1
a1687 1
rt_hf_class(void)
d1696 5
a1700 1
rt_hf_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d1951 6
a1956 1
rt_hf_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d1974 5
a1978 1
rt_hf_import(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d2147 5
a2151 1
rt_hf_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d2188 5
a2192 1
rt_hf_import5(struct rt_db_internal *ip, const struct bu_external *ep, const fastf_t *mat, const struct db_i *dbip)
d2201 5
a2205 1
rt_hf_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d2221 5
a2225 1
rt_hf_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
d2247 2
a2248 1
rt_hf_ifree(struct rt_db_internal *ip)
@


11.52.2.2
log
@sync branch with HEAD
@
text
@d24 1
a24 1
 *	This software is Copyright (C) 1994-2004 by the United States Army
d28 1
a28 1
static char rt_hf_RcSid[] = "@@(#)$Header$ (ARL)";
a222 1
#ifndef lint
a223 1
#endif
@


11.51
log
@Converted from K&R to ANSI C - RFH
@
text
@d213 4
a216 1
rt_hf_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
d357 2
a358 1
rt_hf_print(register const struct soltab *stp)
d371 6
a376 1
rt_hf_cell_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct hit *hitp, int xCell, int yCell)
d670 9
a678 1
axis_plane_isect(int plane, fastf_t inout, struct xray *rp, struct hf_specific *hf, double xWidth, double yWidth, struct hit **hp, int *nhits)
d786 5
a790 1
rt_hf_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
d1568 4
a1571 1
rt_hf_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
d1615 4
a1618 1
rt_hf_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
d1635 5
a1639 1
rt_hf_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
d1670 2
a1671 1
rt_hf_free(register struct soltab *stp)
d1687 1
a1687 1
rt_hf_class(void)
d1696 5
a1700 1
rt_hf_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d1951 6
a1956 1
rt_hf_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
d1974 5
a1978 1
rt_hf_import(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
d2147 5
a2151 1
rt_hf_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d2188 5
a2192 1
rt_hf_import5(struct rt_db_internal *ip, const struct bu_external *ep, const fastf_t *mat, const struct db_i *dbip)
d2201 5
a2205 1
rt_hf_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
d2221 5
a2225 1
rt_hf_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
d2247 2
a2248 1
rt_hf_ifree(struct rt_db_internal *ip)
@


11.50
log
@added support for dsp_cuttype in hf-dsp conversion process
@
text
@d28 1
a28 1
static char rt_hf_RcSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_hf.c,v 11.49 2001/10/04 18:37:25 tranese Exp $ (ARL)";
d213 1
a213 4
rt_hf_prep( stp, ip, rtip )
struct soltab		*stp;
struct rt_db_internal	*ip;
struct rt_i		*rtip;
d354 1
a354 2
rt_hf_print( stp )
register const struct soltab *stp;
d367 1
a367 6
rt_hf_cell_shot(stp, rp, ap, hitp, xCell, yCell)
struct soltab		*stp;
register struct xray	*rp;
struct application	*ap;
struct hit		*hitp;
int			xCell, yCell;
d661 1
a661 9
axis_plane_isect(plane, inout, rp, hf, xWidth, yWidth, hp, nhits)
int plane;
fastf_t inout;
struct xray	*rp;
struct hf_specific *hf;
double xWidth, yWidth;
struct hit **hp;
int *nhits;

d769 1
a769 5
rt_hf_shot( stp, rp, ap, seghead )
struct soltab		*stp;
register struct xray	*rp;
struct application	*ap;
struct seg		*seghead;
d1547 1
a1547 4
rt_hf_norm( hitp, stp, rp )
register struct hit	*hitp;
struct soltab		*stp;
register struct xray	*rp;
d1591 1
a1591 4
rt_hf_curve( cvp, hitp, stp )
register struct curvature *cvp;
register struct hit	*hitp;
struct soltab		*stp;
d1608 1
a1608 5
rt_hf_uv( ap, stp, hitp, uvp )
struct application	*ap;
struct soltab		*stp;
register struct hit	*hitp;
register struct uvcoord	*uvp;
d1639 1
a1639 2
rt_hf_free( stp )
register struct soltab *stp;
d1655 1
a1655 1
rt_hf_class()
d1664 1
a1664 5
rt_hf_plot( vhead, ip, ttol, tol )
struct bu_list		*vhead;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol		*tol;
d1915 1
a1915 6
rt_hf_tess( r, m, ip, ttol, tol )
struct nmgregion	**r;
struct model		*m;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol		*tol;
d1933 1
a1933 5
rt_hf_import( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
d2102 1
a2102 5
rt_hf_export( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d2139 1
a2139 5
rt_hf_import5( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
const mat_t			mat;
const struct db_i		*dbip;
d2148 1
a2148 5
rt_hf_export5( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d2164 1
a2164 5
rt_hf_describe( str, ip, verbose, mm2local )
struct bu_vls		*str;
const struct rt_db_internal	*ip;
int			verbose;
double			mm2local;
d2186 1
a2186 2
rt_hf_ifree( ip )
struct rt_db_internal	*ip;
@


11.49
log
@Changed log messages in rt_hf_import5 and rt_hf_export5 to reflect release number and not the database version. Also refers to dbupgrade not g4-g5.
@
text
@d28 1
a28 1
static char rt_hf_RcSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_hf.c,v 11.48 2001/10/02 19:24:29 jra Exp $ (ARL)";
d145 6
@


11.48
log
@Routines were not setting idb_major_type in the internal structure
@
text
@d28 1
a28 1
static char rt_hf_RcSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_hf.c,v 11.47 2001/05/17 20:05:24 morrison Exp $ (ARL)";
d2188 3
a2190 2
	bu_log( "Import of HF solids from a version 5 database is not allowed.\n" );
	bu_log( "\tHF solids should be converted to DSP solids using the rt_hf_to_dsp() routine or g4-g5 utility.\n" );
d2201 3
a2203 2
	bu_log( "Export of HF solids from a version 5 database is not allowed.\n" );
	bu_log( "\tHF solids should be converted to DSP solids using the rt_hf_to_dsp() routine or g4-g5 utility.\n" );
@


11.47
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d28 1
a28 1
static char rt_hf_RcSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_hf.c,v 11.46 2001/05/16 21:38:04 morrison Exp $ (ARL)";
d182 1
d1994 1
@


11.46
log
@PRODUCTION optimizations
@
text
@d28 1
a28 1
static char rt_hf_RcSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_hf.c,v 11.45 2001/04/20 22:29:45 morrison Exp $ (ARL)";
d383 1
a383 1
	if (rt_g.debug & DEBUG_HF) {
d572 1
a572 1
	if (rt_g.debug & DEBUG_HF) {
d863 1
a863 1
		if (rt_g.debug & DEBUG_HF) {
d874 1
a874 1
			if (rt_g.debug & DEBUG_HF) {
d883 1
a883 1
			if (rt_g.debug & DEBUG_HF) {
d891 1
a891 1
			if (rt_g.debug & DEBUG_HF) {
d900 1
a900 1
			if (rt_g.debug & DEBUG_HF) {
d915 1
a915 1
		if (rt_g.debug & DEBUG_HF) {
d932 1
a932 1
	if (rt_g.debug & DEBUG_HF) {
d968 1
a968 1
		if (rt_g.debug & DEBUG_HF) {
d1032 1
a1032 1
		if (rt_g.debug & DEBUG_HF ) {
d1066 1
a1066 1
		if (rt_g.debug & DEBUG_HF) {
d1077 1
a1077 1
			if (rt_g.debug & DEBUG_HF) {
d1146 1
a1146 1
			if (rt_g.debug & DEBUG_HF) {
d1174 1
a1174 1
				if (rt_g.debug & DEBUG_HF) {
d1245 1
a1245 1
		if (rt_g.debug & DEBUG_HF) {
d1304 1
a1304 1
		if (rt_g.debug & DEBUG_HF ) {
d1338 1
a1338 1
		if (rt_g.debug & DEBUG_HF) {
d1348 1
a1348 1
			if (rt_g.debug & DEBUG_HF) {
d1406 1
a1406 1
			if (rt_g.debug & DEBUG_HF) {
d1434 1
a1434 1
				if (rt_g.debug & DEBUG_HF) {
d1505 1
a1505 1
		if (rt_g.debug & DEBUG_HF) {
@


11.45
log
@CONST to const
@
text
@d28 1
a28 1
static char rt_hf_RcSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_hf.c,v 11.44 2001/03/31 01:57:08 morrison Exp $ (ARL)";
d2217 1
d2223 1
@


11.44
log
@Deprecated bn_mat_idn() and bn_mat_zero(), updated calls to h/vmath.h's MAT_IDN() and MAT_ZERO() performance improved macros.
@
text
@d28 1
a28 1
static char rt_hf_RcSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_hf.c,v 11.43 2001/03/23 22:34:31 butler Exp $ (ARL)";
d72 1
a72 1
CONST struct bu_structparse rt_hf_parse[] = {
d89 1
a89 1
CONST struct bu_structparse rt_hf_cparse[] = {
d213 1
a213 1
	CONST struct bn_tol		*tol = &rtip->rti_tol;
d351 1
a351 1
register CONST struct soltab *stp;
d353 1
a353 1
	register CONST struct hf_specific *hf =
d1692 2
a1693 2
CONST struct rt_tess_tol *ttol;
CONST struct bn_tol		*tol;
d1948 2
a1949 2
CONST struct rt_tess_tol *ttol;
CONST struct bn_tol		*tol;
d1969 3
a1971 3
CONST struct bu_external	*ep;
register CONST mat_t		mat;
CONST struct db_i		*dbip;
d2141 1
a2141 1
CONST struct rt_db_internal	*ip;
d2143 1
a2143 1
CONST struct db_i		*dbip;
d2182 3
a2184 3
CONST struct bu_external	*ep;
CONST mat_t			mat;
CONST struct db_i		*dbip;
d2194 1
a2194 1
CONST struct rt_db_internal	*ip;
d2196 1
a2196 1
CONST struct db_i		*dbip;
d2213 1
a2213 1
CONST struct rt_db_internal	*ip;
@


11.43
log
@Changes to support new DSP primitive representation
@
text
@d28 1
a28 1
static char rt_hf_RcSid[] = "@@(#)$Header: /n/tgm/d/CVS/brlcad/librt/g_hf.c,v 11.42 2001/03/21 20:03:09 jra Exp $ (ARL)";
d146 1
a146 1
	bn_mat_idn(dsp->dsp_stom);
@


11.42
log
@Completed rt_hf_to_dsp()
@
text
@d28 1
a28 1
static char rt_hf_RcSid[] = "@@(#)$Header: /d/CVS/brlcad/librt/g_hf.c,v 11.41 2000/10/24 00:02:25 butler Exp $ (ARL)";
d140 2
a141 2
	bu_vls_init( &dsp->dsp_file );
	bu_vls_strcat( &dsp->dsp_file, hip->dfile );
@


11.41
log
@Initializations to eliminate compiler warnings
@
text
@d28 1
a28 1
static char rt_hf_RcSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_hf.c,v 11.40 2000/09/08 05:54:42 mike Exp $ (ARL)";
d126 1
a126 1
	struct rt_hf_internal	*hip = (struct rt_hf_internal *)db_intern;
d128 1
a128 1
	mat_t 			tmp, mat;
d132 6
d140 2
d144 1
d146 2
a147 6
	if (! hip->shorts) {
		bu_log("cannot convert float HF to DSP\n");
		return -1;
	}
	bn_mat_idn(mat);
	MAT_DELTAS_VEC(mat,  hip->v);	/* translate */
d150 26
a175 9
	MAT4X3PNT( tmp, mat, hip->v );
	VMOVE( hip->v, tmp );
	MAT4X3VEC( tmp, mat, hip->x );
	VMOVE( hip->x, tmp );
	MAT4X3VEC( tmp, mat, hip->y );
	VMOVE( hip->y, tmp );
	hip->xlen /= mat[15];
	hip->ylen /= mat[15];
	hip->zscale /= mat[15];
d177 1
a177 1
	/* XXX There is more logic needed here */
d179 1
d185 1
a185 3
	rt_db_free_internal( db_intern, resp );

	return -1;
@


11.40
log
@
Modified tree routines to take resource pointer.
@
text
@d28 1
a28 1
static char rt_hf_RcSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_hf.c,v 11.39 2000/09/01 02:18:03 mike Exp $ (ARL)";
d1675 1
a1675 1
	register unsigned short		*sp;
@


11.39
log
@
lint
@
text
@d28 1
a28 1
static char rt_hf_RcSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_hf.c,v 11.38 2000/08/21 02:02:30 butler Exp $ (ARL)";
d124 1
a124 1
rt_hf_to_dsp(struct rt_db_internal *db_intern)
d130 3
d157 1
a157 1
	rt_db_free_internal( db_intern );
d161 2
@


11.38
log
@Massive compilation warnings eliminated
@
text
@d28 1
a28 1
static char rt_hf_RcSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_hf.c,v 11.37 2000/07/08 02:19:35 mike Exp $ (ARL)";
d348 1
a348 1
	fastf_t dn, abs_dn, k1st, k2nd , alpha, beta;
d647 1
a647 1
	double left, right, xx, xright, answer;
d649 1
a649 1
	int CellX, CellY;
d768 1
a768 1
	fastf_t pdist;
@


11.37
log
@
Used formal name.
@
text
@d28 1
a28 1
static char rt_hf_RcSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_hf.c,v 11.36 2000/07/08 01:28:33 mike Exp $ (ARL)";
d128 1
a128 1
	mat_t 			tmp, mat, matA, matB, matC;
d520 1
a520 1
other_half:
d948 1
a948 1
		if (r=rt_hf_cell_shot(stp, rp, ap, hp, xCell, yCell)) {
d1136 1
a1136 1
				if (r=rt_hf_cell_shot(stp, rp, ap, hp, xCell, yCell)) {
d1205 1
a1205 1
					if (r=rt_hf_cell_shot(stp, rp, ap, hp, xCell, yCell)) {
d1396 1
a1396 1
				if (r=rt_hf_cell_shot(stp, rp, ap, hp, xCell, yCell)) {
d1465 1
a1465 1
					if (r=rt_hf_cell_shot(stp, rp, ap, hp, xCell, yCell)) {
@


11.36
log
@
Fixed lint
@
text
@d28 1
a28 1
static char rt_hf_RcSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_hf.c,v 11.35 2000/07/06 22:44:52 mike Exp $ (ARL)";
d130 1
a130 1
	GETSTRUCT( dsp, rt_dsp_internal );
@


11.35
log
@*** empty log message ***
@
text
@d28 1
a28 1
static char rt_hf_RcSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_hf.c,v 11.34 2000/06/30 20:10:32 butler Exp $ (ARL)";
a126 1
	struct rt_db_internal	intern;
d130 1
a130 4

	return -1;

	dsp = (struct rt_dsp_internal *)&intern;
d138 2
a139 2
	bn_mat_idn(matA);
	MAT_DELTAS_VEC(matA,  hip->v);	/* translate */
d152 8
@


11.34
log
@Steps closer to V5 database conversion of HF's
@
text
@d28 1
a28 1
static char rt_hf_RcSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_hf.c,v 11.33 2000/06/30 15:38:03 mike Exp $ (ARL)";
d117 5
a121 1
 *	Convert a HF internal to a DSP internal representation
d124 1
a124 1
hf_to_dsp(struct rt_db_internal *db_intern)
d2147 24
@


11.33
log
@
export methods should not init the external structure, just check them.
@
text
@d28 1
a28 1
static char rt_hf_RcSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_hf.c,v 11.32 2000/06/30 15:31:15 mike Exp $ (ARL)";
d122 5
a126 2
	struct rt_hf_internal *hip = (struct rt_hf_internal *)db_intern;
	struct rt_dsp_internal *dsp;
d129 24
@


11.32
log
@
The import/export and import5/export5 methods must NOT
re-initialize their rt_db_internal* pointer, they should just check it.
@
text
@d28 1
a28 1
static char rt_hf_RcSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_hf.c,v 11.31 2000/06/29 20:59:51 butler Exp $ (ARL)";
d2098 1
a2098 1
	BU_INIT_EXTERNAL(ep);
@


11.31
log
@Stubbed out routine for converting to DSP
@
text
@d28 1
a28 1
static char rt_hf_RcSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_hf.c,v 11.30 2000/06/29 20:53:01 butler Exp $ (ARL)";
d1931 1
a1931 1
	RT_INIT_DB_INTERNAL( ip );
@


11.30
log
@Added stub routine to convert HF into DSP
@
text
@d28 1
a28 1
static char rt_hf_RcSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_hf.c,v 11.29 2000/04/12 02:34:34 mike Exp $ (ARL)";
d150 1
a150 1

@


11.29
log
@
NT port, non-compat4
@
text
@d28 1
a28 1
static char rt_hf_RcSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_hf.c,v 11.28 2000/03/28 21:59:05 mike Exp $ (ARL)";
d117 13
d150 1
a150 1
	struct rt_hf_internal		*hip;
@


11.28
log
@
Fixed arguments
@
text
@d28 1
a28 1
static char rt_hf_RcSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_hf.c,v 11.27 2000/01/14 23:00:29 mike Exp $ (ARL)";
d1542 1
a1542 1
 	vec_ortho( cvp->crv_pdir, hitp->hit_normal );
@


11.27
log
@
Lint
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_hf.c,v 11.26 1999/12/29 21:03:33 jra Exp $ (ARL)";
d145 1
a145 1
		bu_log("%s\n",RCSid);
@


11.26
log
@Eliminated some unused variables
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_hf.c,v 11.25 1999/12/17 04:51:55 cjohnson Exp $ (ARL)";
d1563 1
a1563 1
	fastf_t r;
d1580 1
a1580 1
#if 0
a1582 1
#endif /* 0 */
@


11.25
log
@There is no float convert so switch to using doubles.
Add double plotting so that mged can display double HFs.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_hf.c,v 11.24 1999/12/16 22:46:38 cjohnson Exp $ (ARL)";
a712 1
	register struct seg *segp;
a718 2
	CONST struct bn_tol	*tol = &ap->a_rt_i->rti_tol;

a1538 3
	register struct hf_specific *hf =
		(struct hf_specific *)stp->st_specific;

@


11.24
log
@Some loging changes.  Tests to make sure that hits through edges get processed
correctly: in-in = 2, out-out=2, in-out=1, out-in=1
and use the cv routines correctly.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_hf.c,v 11.23 1999/12/06 23:16:16 cjohnson Exp $ (ARL)";
d355 2
a356 2
		register float *fp;
		fp = (float *)hfp->hf_mp->apbuf + 
d662 2
a663 2
		register float *fp;
		fp = (float *) hf->hf_mp->apbuf +
d1031 1
a1031 1
			 * and float, we have this simple if statement
d1055 2
a1056 2
				register float *fp;
				fp = (float *)hf->hf_mp->apbuf +
d1133 2
a1134 2
					register float *fp;
					fp = (float *)hf->hf_mp->apbuf +
d1314 2
a1315 2
				register float *fp;
				fp = (float *)hf->hf_mp->apbuf +
d1393 2
a1394 2
					register float *fp;
					fp = (float *)hf->hf_mp->apbuf +
d1630 1
a1646 2
	if( !xip->shorts )  rt_bomb("rt_hf_plot() does shorts only, for now\n");

d1674 56
a1729 10
	/* X direction, Y=0, with edges down to base */
	RT_ADD_VLIST( vhead, xip->v, BN_VLIST_LINE_MOVE );
	sp = &HF_GET((unsigned short *)xip->mp->apbuf, 0, 0 );
	for( x = 0; x < xip->w; x++ )  {
		VJOIN2( cur, xip->v, x, xbasis, *sp, zbasis );
		RT_ADD_VLIST(vhead, cur, BN_VLIST_LINE_DRAW );
		sp++;
	}
	VJOIN1( cur, xip->v, xip->xlen, xip->x );
	RT_ADD_VLIST( vhead, cur, BN_VLIST_LINE_DRAW );
d1731 12
a1742 12
	/* X direction, Y=n-1, with edges down to base */
	VJOIN1( start, xip->v, xip->ylen, xip->y );
	RT_ADD_VLIST( vhead, start, BN_VLIST_LINE_MOVE );
	sp = &HF_GET((unsigned short *)xip->mp->apbuf, 0, xip->n - 1 );
	VJOIN1( start, xip->v, xip->ylen, xip->y );
	for( x = 0; x < xip->w; x++ )  {
		VJOIN2( cur, start, x, xbasis, *sp, zbasis );
		RT_ADD_VLIST(vhead, cur, BN_VLIST_LINE_DRAW );
		sp++;
	}
	VJOIN2( cur, xip->v, xip->xlen, xip->x, xip->ylen, xip->y );
	RT_ADD_VLIST( vhead, cur, BN_VLIST_LINE_DRAW );
d1744 20
a1763 19
	/* Y direction, X=0 */
	cmd = BN_VLIST_LINE_MOVE;
	sp = &HF_GET((unsigned short *)xip->mp->apbuf, 0, 0 );
	for( y = 0; y < xip->n; y++ )  {
		VJOIN2( cur, xip->v, y, ybasis, *sp, zbasis );
		RT_ADD_VLIST(vhead, cur, cmd );
		cmd = BN_VLIST_LINE_DRAW;
		sp += xip->w;
	}

	/* Y direction, X=w-1 */
	cmd = BN_VLIST_LINE_MOVE;
	sp = &HF_GET((unsigned short *)xip->mp->apbuf, xip->w - 1, 0 );
	VJOIN1( start, xip->v, xip->xlen, xip->x );
	for( y = 0; y < xip->n; y++ )  {
		VJOIN2( cur, start, y, ybasis, *sp, zbasis );
		RT_ADD_VLIST(vhead, cur, cmd );
		cmd = BN_VLIST_LINE_DRAW;
		sp += xip->w;
d1787 2
a1788 6
		sp = &HF_GET((unsigned short *)xip->mp->apbuf, x, y );
		VJOIN2( cur, start, x, xbasis, *sp, zbasis );
		RT_ADD_VLIST(vhead, cur, BN_VLIST_LINE_MOVE );
		x += half_step;
		sp = &HF_GET((unsigned short *)xip->mp->apbuf, x, y );
		for( ; x < xip->w; x += step )  {
d1790 2
a1791 5
			RT_ADD_VLIST(vhead, cur, BN_VLIST_LINE_DRAW );
			sp += step;
		}
		if( x != step+xip->w-1+step )  {
			x = xip->w - 1;
d1793 28
a1820 2
			VJOIN2( cur, start, x, xbasis, *sp, zbasis );
			RT_ADD_VLIST(vhead, cur, BN_VLIST_LINE_DRAW );
d1825 4
a1828 8
	for( x = half_step; x < xip->w-half_step; x += step )  {
		VJOIN1( start, xip->v, x, xbasis );
		y = 0;
		sp = &HF_GET((unsigned short *)xip->mp->apbuf, x, y );
		VJOIN2( cur, start, y, ybasis, *sp, zbasis );
		RT_ADD_VLIST(vhead, cur, BN_VLIST_LINE_MOVE );
		y += half_step;
		for( ; y < xip->n; y += step )  {
d1831 33
a1863 7
			RT_ADD_VLIST(vhead, cur, BN_VLIST_LINE_DRAW );
		}
		if( y != step+xip->n-1+step )  {
			y = xip->n - 1;
			sp = &HF_GET((unsigned short *)xip->mp->apbuf, x, y );
			VJOIN2( cur, start, y, ybasis, *sp, zbasis );
			RT_ADD_VLIST(vhead, cur, BN_VLIST_LINE_DRAW );
d2031 1
a2031 1
	/* Transform external data to internal format -- short or float */
d2036 1
a2036 1
		mp->apbuflen = sizeof(float) * count;
@


11.23
log
@Some fixes to handle verticals correctly as well as parallel to
bounding box planes.  There is still some problems with one hit
situations.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_hf.c,v 11.22 1999/12/01 23:39:26 cjohnson Exp $ (ARL)";
d300 2
a301 1
	fastf_t dn, abs_dn, k1st, k2nd , alpha, beta, dn1st;
a420 1
	dn1st = dn;
d428 7
a434 1
	abs_dn = (dn >= 0.0) ? dn : (-dn);
a461 1
					dn1st = dn;
d476 7
a482 1
	abs_dn = ( dn >= 0.0) ? dn : (-dn);
d503 2
d549 12
d568 2
a569 1
	if (fabs(k1st-k2nd) < SMALL_FASTF) return 1;
d644 1
a644 1
#if 0 /* What does this indicate that it generates so much noise? */
a692 13













a798 3
			if (rt_g.debug & DEBUG_HF) {
				bu_log("s=%g\n", s);
			}
d803 3
a807 3
			if (rt_g.debug & DEBUG_HF) {
				bu_log("s=%g\n", s);
			}
d812 3
d1007 1
a1007 1
				bu_log("hf: cell %d,%d [%g -- %g] ",
d1014 1
d1104 1
a1104 1
					bu_log("hf: cell %d,%d \n", xCell, yCell);
d1272 1
a1272 1

d1281 1
d1950 1
a1950 1
		out_cookie = bu_cv_cookie("hf");
@


11.22
log
@You actually have to compute the value before you use it.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_hf.c,v 11.21 1999/12/01 14:29:54 cjohnson Exp $ (ARL)";
d520 1
a520 1
	if (abs(k1st) < abs(k2nd)) {
d543 2
d781 1
a781 1
			bu_log("hf: dn=%g, dxbdn=%g, s=%g\n", dn, dxbdn, dxbdn/dn);
d785 4
a788 1
			s = dxbdn/dn;
d790 1
a790 1
				allDist[allIndex] = out = s;
d794 4
a797 1
			s = dxbdn/dn;
d799 1
a799 1
				allDist[allIndex] = in = s;
d802 1
a802 1
		} else {				/* Parallel */
d807 3
d813 1
d815 1
a815 1
		if ( in > out ) {
d830 1
a830 1
	if ( in >= out || out >= INFINITY ) {
d849 2
a850 1
		bu_log("hf: xWidth=%g, yWidth=%g\n", xWidth, yWidth);
d881 1
a881 1
	if (abs(cosine) < SMALL_FASTF) {	/* near enough to Z */
d884 3
d1443 2
a1444 2
		if (nerrors++ < 6 ) {
			bu_log("rt_hf_shot(%s): %d hits: ", stp->st_name, nhits-1);
@


11.21
log
@Take out a noisy log message
Add support for vertical rays (Rays that do not move across the grid)
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_hf.c,v 11.20 1999/11/26 21:46:47 mike Exp $ (ARL)";
d783 1
d785 1
a785 1
				allDist[allIndex] = out = s = dxbdn/dn;
d789 1
d791 1
a791 1
				allDist[allIndex] = in = s = dxbdn/dn; 
@


11.20
log
@
Lint cleanups
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_hf.c,v 11.19 1999/11/17 02:41:59 mike Exp $ (ARL)";
d616 1
d620 1
d776 1
a776 1
		allDist[allIndex] = s = dxbdn/dn;
d784 1
a784 1
				out = s;
d789 1
a789 1
				in = s; 
d857 1
a857 1
	 * X or Y.
d866 11
a876 1
	if (cosine*cosine > 0.5) {
@


11.19
log
@
Added idb_meth and st_meth pointers to allow direct access to per-solid
methods, C++ style.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_hf.c,v 11.18 1999/10/30 03:53:27 mike Exp $ (ARL)";
d1581 1
a1581 1
struct bn_tol		*tol;
d1750 1
a1750 1
struct bn_tol		*tol;
d1768 1
a1768 1
rt_hf_import( ip, ep, mat )
d1772 1
d1940 1
a1940 1
rt_hf_export( ep, ip, local2mm )
d1944 1
d1990 1
a1990 1
struct rt_db_internal	*ip;
@


11.18
log
@
Added magic numbers for ray, hit, and application structures.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_hf.c,v 11.17 1999/07/02 22:19:23 mike Exp $ (ARL)";
d1794 1
@


11.17
log
@
Removed dependence on compat4.h
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_hf.c,v 11.16 1999/05/27 19:10:39 mike Exp $ (ARL)";
d504 1
d512 1
d521 1
d528 1
d536 1
d542 2
d578 1
d652 1
@


11.16
log
@
sed4
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_hf.c,v 11.15 1999/01/15 05:49:26 mike Exp $ (ARL)";
d76 11
a86 11
	{"%d",	1,	"w",		HF_O(w),		FUNC_NULL },
	{"%d",	1,	"n",		HF_O(n),		FUNC_NULL },
	{"%d",	1,	"shorts",	HF_O(shorts),		FUNC_NULL },
	{"%f",	1,	"file2mm",	HF_O(file2mm),		FUNC_NULL },
	{"%f",	3,	"v",		HF_O(v[0]),		FUNC_NULL },
	{"%f",	3,	"x",		HF_O(x[0]),		FUNC_NULL },
	{"%f",	3,	"y",		HF_O(y[0]),		FUNC_NULL },
	{"%f",	1,	"xlen",		HF_O(xlen),		FUNC_NULL },
	{"%f",	1,	"ylen",		HF_O(ylen),		FUNC_NULL },
	{"%f",	1,	"zscale",	HF_O(zscale),		FUNC_NULL },
	{"",	0,	(char *)0,	0,			FUNC_NULL }
d92 5
a96 5
	{"%d",	1,	"w",		HF_O(w),		FUNC_NULL },
	{"%d",	1,	"n",		HF_O(n),		FUNC_NULL },
	{"%d",	1,	"shorts",	HF_O(shorts),		FUNC_NULL },
	{"%f",	1,	"file2mm",	HF_O(file2mm),		FUNC_NULL },
	{"",	0,	(char *)0,	0,			FUNC_NULL }
d1603 1
a1603 1
	RT_ADD_VLIST( vhead, xip->v, RT_VLIST_LINE_MOVE );
d1606 1
a1606 1
	RT_ADD_VLIST( vhead, start, RT_VLIST_LINE_DRAW );
d1609 1
a1609 1
	RT_ADD_VLIST( vhead, start, RT_VLIST_LINE_DRAW );
d1612 1
a1612 1
	RT_ADD_VLIST( vhead, start, RT_VLIST_LINE_DRAW );
d1614 1
a1614 1
	RT_ADD_VLIST( vhead, xip->v, RT_VLIST_LINE_DRAW );
d1622 1
a1622 1
	RT_ADD_VLIST( vhead, xip->v, RT_VLIST_LINE_MOVE );
d1626 1
a1626 1
		RT_ADD_VLIST(vhead, cur, RT_VLIST_LINE_DRAW );
d1630 1
a1630 1
	RT_ADD_VLIST( vhead, cur, RT_VLIST_LINE_DRAW );
d1634 1
a1634 1
	RT_ADD_VLIST( vhead, start, RT_VLIST_LINE_MOVE );
d1639 1
a1639 1
		RT_ADD_VLIST(vhead, cur, RT_VLIST_LINE_DRAW );
d1643 1
a1643 1
	RT_ADD_VLIST( vhead, cur, RT_VLIST_LINE_DRAW );
d1646 1
a1646 1
	cmd = RT_VLIST_LINE_MOVE;
d1651 1
a1651 1
		cmd = RT_VLIST_LINE_DRAW;
d1656 1
a1656 1
	cmd = RT_VLIST_LINE_MOVE;
d1662 1
a1662 1
		cmd = RT_VLIST_LINE_DRAW;
d1689 1
a1689 1
		RT_ADD_VLIST(vhead, cur, RT_VLIST_LINE_MOVE );
d1694 1
a1694 1
			RT_ADD_VLIST(vhead, cur, RT_VLIST_LINE_DRAW );
d1701 1
a1701 1
			RT_ADD_VLIST(vhead, cur, RT_VLIST_LINE_DRAW );
d1711 1
a1711 1
		RT_ADD_VLIST(vhead, cur, RT_VLIST_LINE_MOVE );
d1716 1
a1716 1
			RT_ADD_VLIST(vhead, cur, RT_VLIST_LINE_DRAW );
d1722 1
a1722 1
			RT_ADD_VLIST(vhead, cur, RT_VLIST_LINE_DRAW );
@


11.15
log
@Moved librt/vert.c to libbu/convert.c
Moved librt/vert.c to libbu/convert.c
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_hf.c,v 11.14 1997/12/16 00:15:10 mike Exp $ (ARL)";
d73 3
a75 3
	{"%s",	128,	"cfile",	offsetofarray(struct rt_hf_internal, cfile), FUNC_NULL},
	{"%s",	128,	"dfile",	offsetofarray(struct rt_hf_internal, dfile), FUNC_NULL},
	{"%s",	8,	"fmt",		offsetofarray(struct rt_hf_internal, fmt), FUNC_NULL},
d90 2
a91 2
	{"%s",	128,	"dfile",	offsetofarray(struct rt_hf_internal, dfile), FUNC_NULL},
	{"%s",	8,	"fmt",		offsetofarray(struct rt_hf_internal, fmt), FUNC_NULL},
d113 1
a113 1
	struct rt_mapped_file *hf_mp;
d139 1
a139 1
	CONST struct rt_tol		*tol = &rtip->rti_tol;
d145 1
a145 1
		rt_log("%s\n",RCSid);
d152 1
a152 1
	GETSTRUCT(hf, hf_specific);
d187 2
a188 2
		rt_log("Hf(%s): X not perpendicular to Y.\n", stp->st_name);
		rt_free((genptr_t)hf, "struct hf");
d285 2
a286 2
	rt_log("XL %g\n", hf->hf_Xlen);
	rt_log("YL %g\n", hf->hf_Ylen);
d309 1
a309 1
		rt_log("rt_hf_cell_shot(%s): %d, %d\n", stp->st_name,
d488 1
a488 1
		rt_log("rt_hf_cell_shot: hit(%d).\n",fnd1+fnd2);
d501 1
a501 1
/* rt_log("cell: k1st=%g, k2nd=%g\n", k1st,k2nd); */
d609 1
a609 1
		rt_log("hf: xx < 0, plane = %d\n", plane);
d639 1
a639 1
rt_log("inout: loc[Z]=%g, answer=%g, left=%g, right=%g, xright=%g, xx=%g\n",
d694 1
a694 1
	CONST struct rt_tol	*tol = &ap->a_rt_i->rti_tol;
d768 1
a768 1
			rt_log("hf: dn=%g, dxbdn=%g, s=%g\n", dn, dxbdn, dxbdn/dn);
d792 1
a792 1
				rt_log("rt_hf_shoot(%s): in(%g) > out(%g)\n",
d800 1
a800 1
		rt_log("rt_hf_shoot(%s): 1 hit => MISS\n",
d807 1
a807 1
			rt_log("rt_hf_shoot(%s): in(%g) >= out(%g) || out >= INFINITY\n",
d824 1
a824 1
		rt_log("hf: xWidth=%g, yWidth=%g\n", xWidth, yWidth);
d880 2
a881 2
rt_log("hf: tmp=%g\n", tmp);
rt_log("hf: before VSCALE... aray=(%g,%g,%g)\n",
d910 1
a910 1
			rt_log("hf: curloc=(%g, %g, %g) aray=(%g,%g,%g)\n", curloc[X], curloc[Y],
d912 1
a912 1
			rt_log("hf: from=(%g, %g) to=(%g, %g)\n",
d925 1
a925 1
rt_log("aray[Y]/aray[X]=%g\n", delta);
d944 1
a944 1
			rt_log("hf: delta=%g, error=%g, %d, %d\n", 
d955 1
a955 1
				rt_log("hf: cell %d,%d [%g -- %g] ",
d1023 1
a1023 1
				rt_log("lowest=%g, highest=%g\n", 
d1051 1
a1051 1
					rt_log("hf: cell %d,%d \n", xCell, yCell);
d1122 1
a1122 1
			rt_log("htf: leaving loop, %d, %d, %g vs. 0--%d, 0--%d, 0.0--%g\n",
d1151 2
a1152 2
rt_log("hf: tmp=%g\n", tmp);
rt_log("hf: before VSCALE... aray=(%g,%g,%g)\n",
d1181 1
a1181 1
			rt_log("hf: curloc=(%g, %g, %g) aray=(%g,%g,%g)\n", curloc[X], curloc[Y],
d1183 1
a1183 1
			rt_log("hf: from=(%g, %g) to=(%g, %g)\n",
d1196 1
a1196 1
rt_log("aray[X]/aray[Y]=%g\n", delta);
d1215 1
a1215 1
			rt_log("hf: delta=%g, error=%g, %d, %d\n", 
d1225 1
a1225 1
				rt_log("hf: cell %d,%d [%g -- %g] ",
d1282 1
a1282 1
				rt_log("lowest=%g, highest=%g\n", 
d1310 1
a1310 1
					rt_log("hf: cell %d,%d\n", xCell, yCell);
d1381 1
a1381 1
			rt_log("htf: leaving loop, %d, %d, %g vs. 0--%d, 0--%d, 0.0--%g\n",
d1405 1
a1405 1
			rt_log("rt_hf_shot(%s): %d hits: ", stp->st_name, nhits-1);
d1407 1
a1407 1
				rt_log("%f(%d), ",hits[i].hit_dist,hits[i].hit_surfno);
d1409 1
a1409 1
			rt_log("\n");
d1425 1
a1425 1
			RT_LIST_INSERT( &(seghead->l), &(segp->l));
d1549 2
a1550 2
		rt_close_mapped_file(hf->hf_mp);
		hf->hf_mp = (struct rt_mapped_file *)0;
d1552 1
a1552 1
	rt_free( (char *)hf, "hf_specific" );
d1569 1
a1569 1
struct rt_list		*vhead;
d1572 1
a1572 1
struct rt_tol		*tol;
d1741 1
a1741 1
struct rt_tol		*tol;
d1761 1
a1761 1
CONST struct rt_external	*ep;
d1767 1
a1767 1
	struct rt_mapped_file		*mp;
d1775 1
a1775 1
	RT_CK_EXTERNAL( ep );
d1779 1
a1779 1
		rt_log("rt_hf_import: defective record\n");
d1785 1
a1785 1
	ip->idb_ptr = rt_calloc( 1, sizeof(struct rt_hf_internal), "rt_hf_internal");
d1806 1
a1806 1
		rt_free( (char *)xip , "rt_hf_import: xip" );
d1822 1
a1822 1
			rt_log("rt_hf_import() unable to open cfile=%s\n", xip->cfile);
d1832 1
a1832 1
			rt_log("rt_hf_import() parse error in cfile input '%s'\n",
d1842 1
a1842 1
		rt_log("rt_hf_import() no dfile specified\n");
d1846 1
a1846 1
		rt_log("rt_hf_import() w=%d, n=%d too small\n");
d1850 1
a1850 1
		rt_log("rt_hf_import() xlen=%g, ylen=%g too small\n", xip->xlen, xip->ylen);
d1870 1
a1870 1
		rt_log("rt_hf_import() fmt='%s' unknown\n", xip->fmt);
d1878 2
a1879 2
	if( !(mp = rt_open_mapped_file( xip->dfile, "hf" )) )  {
		rt_log("rt_hf_import() unable to open '%s'\n", xip->dfile);
d1903 1
a1903 1
	mp->apbuf = (genptr_t)rt_malloc( mp->apbuflen, "rt_hf_import apbuf[]" );
d1907 1
a1907 1
		rt_log("rt_hf_import(%s) bu_cv_w_cookie count=%d, got=%d\n",
d1930 1
a1930 1
struct rt_external		*ep;
d1948 1
a1948 1
	RT_INIT_EXTERNAL(ep);
d1950 1
a1950 1
	ep->ext_buf = (genptr_t)rt_calloc( 1, ep->ext_nbytes, "hf external");
d1985 1
a1985 1
	RT_VLS_CHECK(str);
d2012 2
a2013 2
		RT_CK_MAPPED_FILE(xip->mp);
		rt_close_mapped_file(xip->mp);
d2016 1
a2016 1
	rt_free( (char *)xip, "hf ifree" );
@


11.14
log
@Converted to bu_semaphore_acquire()
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/g_hf.c,v 11.13 1997/07/02 21:04:12 butler Exp mike $ (ARL)";
d1869 1
a1869 1
	if( (in_cookie = cv_cookie( xip->fmt )) == 0 )  {
d1873 1
a1873 1
	in_len = cv_itemlen( in_cookie );
d1891 1
a1891 1
		out_cookie = cv_cookie("hus");
d1894 1
a1894 1
		out_cookie = cv_cookie("hf");
d1897 1
a1897 1
	if( cv_optimize(in_cookie) == cv_optimize(out_cookie) )  {
d1904 1
a1904 1
	got = cv_w_cookie( mp->apbuf, out_cookie, mp->apbuflen,
d1907 1
a1907 1
		rt_log("rt_hf_import(%s) cv_w_cookie count=%d, got=%d\n",
@


11.13
log
@checkpoint
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/g_hf.c,v 11.12 1997/04/28 04:24:45 butler Exp $ (ARL)";
d168 1
a168 1
	RES_ACQUIRE( &rt_g.res_model);
d170 1
a170 1
	RES_RELEASE( &rt_g.res_model);
d1817 1
a1817 1
		RES_ACQUIRE( &rt_g.res_syscall );
d1819 1
a1819 1
		RES_RELEASE( &rt_g.res_syscall );
d1828 1
a1828 1
		RES_ACQUIRE( &rt_g.res_syscall );
d1830 1
a1830 1
		RES_RELEASE( &rt_g.res_syscall );
@


11.12
log
@Lee's investigations.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/g_hf.c,v 11.11 1997/03/04 19:09:24 jra Exp butler $ (ARL)";
d440 6
a445 1
		 * outside triangle
d468 2
@


11.11
log
@Fixed a bug in rt_hf_ifree().
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/g_hf.c,v 11.10 1997/02/28 18:29:20 jra Exp jra $ (ARL)";
d100 8
a107 8
	vect_t	hf_V;
	vect_t	hf_VO;
	vect_t	hf_X;
	fastf_t	hf_Xlen;
	vect_t	hf_Y;
	fastf_t	hf_Ylen;
	vect_t	hf_N;
	fastf_t	hf_min;
d109 4
a112 4
	fastf_t	hf_file2mm;
	int	hf_w;
	int	hf_n;
	int	hf_shorts;
d321 6
a326 2
		sp = (unsigned short *)hfp->hf_mp->apbuf + yCell*hfp->hf_w+xCell;
		/* 0,0 -> A */
d330 1
a330 1
		/* 1, 0 */
d334 1
a334 1
		/* 1, 1 */
d337 1
d343 1
d348 3
a350 1
/*		VMOVE(tri_CA2nd, tri_BA1st); */
d355 2
a356 1
		fp = (float *)hfp->hf_mp->apbuf + yCell*hfp->hf_w+xCell;
d377 1
a377 1
/*		VMOVE(tri_CA2nd, tri_BA1st); */
d382 18
a399 3
	/*
	 * Ray Direction dot N of this triangle.  N is outward pointing.
	 * wn points inwards and is not unit length.
d401 1
d404 2
a405 1
	dn = VDOT(tri_wn1st, rp->r_dir);
d407 3
a409 1
	if (abs_dn <SQRT_SMALL_FASTF) goto other_half;
d412 1
a412 1
	alpha = VDOT(tri_CA1st, xp);
d415 1
a415 1
	beta = VDOT(tri_BA1st, xp);
d422 40
d487 1
a487 1
	 * and >0 is out.  k1st and k2nd tell us the distence from
d538 122
d681 1
a681 1
#define	MAXHITS	128		/* # of surfaces hit, must be even */
d683 1
a683 1
	register struct hit *hp;
d724 1
d729 1
d734 1
d739 1
d744 1
d749 1
d819 2
d824 2
a825 123
	if (iplane == -3) { 
		hp->hit_dist = in;
		hp->hit_surfno = iplane;
		hp++;
		if (nhits++>=MAXHITS) rt_bomb("g_hf.c: too many hits.\n");
	} else if (iplane != -6) {
		double left, right, xx, xright,answer;
		vect_t loc;
		int CellX, CellY;
		VJOIN1(loc, rp->r_pt, in, rp->r_dir);
		VSUB2(loc,loc,hf->hf_V);

		/* find the left, right and xx */
		switch (iplane) {
		case -1:
			CellY = loc[Y]/yWidth;
			CellX = 0;
			xright = yWidth;
			xx = loc[Y] - (CellY*yWidth);
			break;
		case -2:
			CellY = 0;
			CellX = loc[X]/xWidth;
			xright = xWidth;
			xx = loc[X] - CellX*xWidth;
			break;
		case -4:
			CellY = loc[Y]/yWidth;
			CellX = hf->hf_n-1;
			xright = yWidth;
			xx = loc[Y] - (CellY*yWidth);
			break;
		case -5:
			CellY = hf->hf_w-1;
			CellX = loc[X]/xWidth;
			xright = xWidth;
			xx = loc[X] - CellX*xWidth;
			break;
		}
		if (xx < 0) {
			rt_log("hf: xx < 0, iplane = %d\n", iplane);
		}

		if (hf->hf_shorts) {
			register unsigned short *sp;
			sp = (unsigned short *)hf->hf_mp->apbuf +
			    CellY * hf->hf_w + CellX;
			left = *sp;
			if (iplane == -2 || iplane == -5) {
				sp++;
			} else {
				sp += hf->hf_w;
			}
			right = *sp;
		} else {
			register float *fp;
			fp = (float *) hf->hf_mp->apbuf +
			    CellY * hf->hf_w + CellX;
			left = *fp;
			if (iplane == -2 || iplane == -5) {
				fp++;
			} else {
				fp += hf->hf_w;
			}
			right = *fp;
		}
		left *= hf->hf_file2mm;
		right *= hf->hf_file2mm;
		answer = (right-left)/xright*xx+left;
#if 0
rt_log("in: loc[Z]=%g, answer=%g, left=%g, right=%g, xright=%g, xx=%g\n",
    loc[Z], answer, left, right, xright, xx);
#endif
		if (loc[Z]-SQRT_SMALL_FASTF < answer) {
			hp->hit_dist = in;
			hp->hit_surfno = iplane;
			VJOIN1(hp->hit_point, rp->r_pt, in, rp->r_dir);
			hp++;
			if (nhits++>=MAXHITS) rt_bomb("g_hf.c: too many hits.\n");
		}
	}
	if (oplane == -3) { 
		hp->hit_dist = out;
		hp->hit_surfno = oplane;
		hp++;
		if (nhits++>=MAXHITS) rt_bomb("g_hf.c: too many hits.\n");
	} else if (oplane != -6) {
		double left, right, xx, xright, answer;
		vect_t loc;
		int CellX, CellY;
		VJOIN1(loc, rp->r_pt, out, rp->r_dir);
		VSUB2(loc,loc,hf->hf_V);

		/* find the left, right and xx */
		switch (oplane) {
		case -1:
			CellY = loc[Y]/yWidth;
			CellX = 0;
			xright = yWidth;
			xx = loc[Y] - (CellY*yWidth);
			break;
		case -2:
			CellY = 0;
			CellX = loc[X]/xWidth;
			xright = xWidth;
			xx = loc[X] - CellX*xWidth;
			break;
		case -4:
			CellY = loc[Y]/yWidth;
			CellX = hf->hf_n-1;
			xright = yWidth;
			xx = loc[Y] - (CellY*yWidth);
			break;
		case -5:
			CellY = hf->hf_w-1;
			CellX = loc[X]/xWidth;
			xright = xWidth;
			xx = loc[X] - CellX*xWidth;
			break;
		}
		if (xx < 0) {
			rt_log("hf: xx < 0, oplane = %d\n", iplane);
		}
a826 38
		if (hf->hf_shorts) {
			register unsigned short *sp;
			sp = (unsigned short *)hf->hf_mp->apbuf +
			    CellY * hf->hf_w + CellX;
			left = *sp;
			if (oplane == -2 || oplane == -5) {
				sp++;
			} else {
				sp += hf->hf_w;
			}
			right = *sp;
		} else {
			register float *fp;
			fp = (float *) hf->hf_mp->apbuf +
			    CellY * hf->hf_w + CellX;
			left = *fp;
			if (oplane == -2 || oplane == -5) {
				fp++;
			} else {
				fp += hf->hf_w;
			}
			right = *fp;
		}
		left *= hf->hf_file2mm;
		right *= hf->hf_file2mm;
		answer = (right-left)/xright*xx+left;
#if 0
rt_log("out: loc[Z]=%g, answer=%g, left=%g, right=%g, xright=%g, xx=%g\n",
    loc[Z], answer, left, right, xright, xx);
#endif
		if (loc[Z]-SQRT_SMALL_FASTF < answer) {
			hp->hit_dist = out;
			hp->hit_surfno = oplane;
			VJOIN1(hp->hit_point, rp->r_pt, out, rp->r_dir);
			hp++;
			if (nhits++>=MAXHITS) rt_bomb("g_hf.c: too many hits.\n");
		}
	}
d844 1
a844 1
		tmp[Z] = 0.0;
d857 2
a858 2
		VJOIN1(goesIN, rp->r_pt, allDist[3], rp->r_dir);
		VJOIN1(goesOUT,rp->r_pt, allDist[0], rp->r_dir);
d879 1
a879 1
		farZ = curloc[Z]+aray[Z];
d1150 1
a1150 1
		farZ = curloc[Z]+aray[Z];
@


11.10
log
@Fixed bug in export routine.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/g_hf.c,v 11.9 1996/12/31 16:51:19 jra Exp jra $ (ARL)";
d1964 5
a1968 2
	RT_CK_MAPPED_FILE(xip->mp);
	rt_close_mapped_file(xip->mp);
@


11.9
log
@Minor Mods for Solaris.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/g_hf.c,v 11.8 1996/08/31 11:04:24 mike Exp jra $ (ARL)";
d1908 1
a1908 1
	bu_vls_struct_print( &str, rt_hf_parse, (char *)&xip );
@


11.8
log
@bn.h
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/g_hf.c,v 11.7 1996/08/29 22:50:48 butler Exp mike $ (ARL)";
d209 2
a210 2
			if (*sp > max) max=*sp;
			if (*sp < min) min=*sp;
d943 2
a944 2
				if (lowest > *sp) lowest=*sp;
				if (highest < *sp) highest=*sp;
d947 2
a948 2
				if (lowest > *sp) lowest=*sp;
				if (highest < *sp) highest=*sp;
d951 2
a952 2
				if (lowest > *sp) lowest = *sp;
				if (highest < *sp) highest = *sp;
d1021 2
a1022 2
					if (lowest > *sp) lowest=*sp;
					if (highest < *sp) highest=*sp;
d1025 2
a1026 2
					if (lowest > *sp) lowest=*sp;
					if (highest < *sp) highest=*sp;
d1029 2
a1030 2
					if (lowest > *sp) lowest = *sp;
					if (highest < *sp) highest = *sp;
d1201 2
a1202 2
				if (lowest > *sp) lowest=*sp;
				if (highest < *sp) highest=*sp;
d1205 2
a1206 2
				if (lowest > *sp) lowest=*sp;
				if (highest < *sp) highest=*sp;
d1209 2
a1210 2
				if (lowest > *sp) lowest = *sp;
				if (highest < *sp) highest = *sp;
d1280 2
a1281 2
					if (lowest > *sp) lowest=*sp;
					if (highest < *sp) highest=*sp;
d1284 2
a1285 2
					if (lowest > *sp) lowest=*sp;
					if (highest < *sp) highest=*sp;
d1288 2
a1289 2
					if (lowest > *sp) lowest = *sp;
					if (highest < *sp) highest = *sp;
@


11.7
log
@structparse moved to libbu
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/g_hf.c,v 11.6 1996/07/12 12:10:21 jra Exp butler $ (ARL)";
d1720 1
a1720 1
	struct rt_vls			str;
d1755 4
a1758 4
	rt_vls_init( &str );
	rt_vls_strcpy( &str, rp->ss.ss_args );
	if( bu_structparse( &str, rt_hf_parse, (char *)xip ) < 0 )  {
		rt_vls_free( &str );
d1765 1
a1765 1
	rt_vls_free( &str );
d1779 3
a1781 3
		rt_vls_init( &str );
		while( rt_vls_gets( &str, fp ) >= 0 )
			rt_vls_strcat( &str, " " );
d1785 1
a1785 1
		if( bu_structparse( &str, rt_hf_cparse, (char *)xip ) < 0 )  {
d1787 2
a1788 2
				rt_vls_addr(&str) );
			rt_vls_free( &str );
d1890 1
a1890 1
	struct rt_vls		str;
d1907 2
a1908 2
	RT_VLS_INIT( &str );
	bu_vls_structprint( &str, rt_hf_parse, (char *)&xip );
d1916 2
a1917 2
	strncpy( rec->ss.ss_args, rt_vls_addr(&str), DB_SS_LEN-1 );
	rt_vls_free( &str );
d1931 1
a1931 1
struct rt_vls		*str;
d1941 3
a1943 3
	rt_vls_printf( str, "Height Field (HF)  mm2local=%g\n", mm2local);
	bu_vls_structprint( str, rt_hf_parse, ip->idb_ptr );
	rt_vls_strcat( str, "\n" );
@


11.6
log
@Minor Mods for IRIX 6.2
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/g_hf.c,v 11.5 1995/10/05 13:48:53 cjohnson Exp jra $ (ARL)";
d72 1
a72 1
CONST struct structparse rt_hf_parse[] = {
d89 1
a89 1
CONST struct structparse rt_hf_cparse[] = {
d1757 1
a1757 1
	if( rt_structparse( &str, rt_hf_parse, (char *)xip ) < 0 )  {
d1785 1
a1785 1
		if( rt_structparse( &str, rt_hf_cparse, (char *)xip ) < 0 )  {
d1908 1
a1908 1
	rt_vls_structprint( &str, rt_hf_parse, (char *)&xip );
d1942 1
a1942 1
	rt_vls_structprint( str, rt_hf_parse, ip->idb_ptr );
@


11.5
log
@Deer kill, gills removed, odd hits deleted.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/g_hf.c,v 11.4 1995/09/12 13:46:31 adam Exp adam $ (ARL)";
d142 1
a142 1
	static first_time=1;
@


11.4
log
@Delivery of code to Max Lorenzo at NVESD.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad4.3/librt/RCS/g_hf.c,v 1.12 1995/01/20 06:24:28 cjohnson Exp cjohnson $ (ARL)";
d142 1
d144 4
a307 1
#if 1
a308 3
#else
	{
#endif
d411 5
d442 1
d456 12
d491 1
a491 1
#define	MAXHITS	64		/* # of surfaces hit, must be even */
d508 2
d620 3
a622 1

d630 1
a630 1
		nhits++;
d665 4
d702 1
d704 1
a704 1
			nhits++;
d711 1
a711 1
		nhits++;
d746 4
d783 1
d785 1
a785 1
			nhits++;
d814 1
d831 8
a838 1
		tmp = xWidth/abs(aray[X]);
d875 7
a881 1
		delta = aray[Y]/yWidth;
d903 1
d909 1
a909 1
				rt_log("hf: cell %d,%d [%g -- %g]\n",
d912 4
d928 8
d976 5
d985 6
a990 2
			if (maxZ+SQRT_SMALL_FASTF > lowest &&
			    minZ-SQRT_SMALL_FASTF < highest ) {
d993 2
a994 2
					++nhits;
					++hp;
d1005 1
a1005 1
					rt_log("hf: cell %d,%d\n", xCell, yCell);
d1053 6
a1058 2
				if (maxZ+SQRT_SMALL_FASTF > lowest &&
				    minZ-SQRT_SMALL_FASTF < highest) {
d1062 2
a1063 2
						++nhits;
						++hp;
d1079 1
d1083 1
d1102 8
a1109 1
		tmp = yWidth/abs(aray[Y]);
d1146 7
a1152 1
		delta = aray[X]/xWidth;
d1179 1
a1179 1
				rt_log("hf: cell %d,%d [%g -- %g]\n",
d1234 6
d1244 6
a1249 2
			if (maxZ+SQRT_SMALL_FASTF > lowest &&
			    minZ-SQRT_SMALL_FASTF < highest ) {
d1252 2
a1253 2
					nhits++;
					hp++;
d1312 6
a1317 2
				if (maxZ+SQRT_SMALL_FASTF > lowest &&
				    minZ-SQRT_SMALL_FASTF < highest) {
d1321 2
a1322 2
						nhits++;
						hp++;
d1365 4
d1486 1
d1489 1
@


11.3
log
@Intermediate version
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/g_hf.c,v 11.4 1995/09/12 13:46:31 adam Exp adam $ (ARL)";
a141 1
	static first_time=1;
a142 4
	if (first_time) {
		rt_log("%s\n",RCSid);
		first_time=0;
	}
d303 1
d305 3
a409 5

	if (rt_g.debug & DEBUG_HF) {
		rt_log("rt_hf_cell_shot: hit.\n");
	}

d472 1
a472 1
#define	MAXHITS	128		/* # of surfaces hit, must be even */
d599 1
a599 3
	if (rt_g.debug & DEBUG_HF) {
		rt_log("hf: xWidth=%g, yWidth=%g\n", xWidth, yWidth);
	}
d607 1
a607 1
		if (nhits++>=MAXHITS) rt_bomb("g_hf.c: too many hits.\n");
a641 4
		if (xx < 0) {
			rt_log("hf: xx < 0, iplane = %d\n", iplane);
		}

d676 1
a676 1
			if (nhits++>=MAXHITS) rt_bomb("g_hf.c: too many hits.\n");
d683 1
a683 1
		if (nhits++>=MAXHITS) rt_bomb("g_hf.c: too many hits.\n");
a717 4
		if (xx < 0) {
			rt_log("hf: xx < 0, iplane = %d\n", iplane);
		}

d748 1
a748 1
		if (loc[Z]-SQRT_SMALL_FASTF < (right-left)/xright*xx+left) {
d752 1
a752 1
			if (nhits++>=MAXHITS) rt_bomb("g_hf.c: too many hits.\n");
d797 1
a797 8
		tmp = xWidth/fabs(aray[X]);

#if 0
rt_log("hf: tmp=%g\n", tmp);
rt_log("hf: before VSCALE... aray=(%g,%g,%g)\n",
		aray[X], aray[Y], aray[Z]);
#endif

d834 1
a834 7
/*		delta = aray[Y]/yWidth; */
		delta = aray[Y]/fabs(aray[X]);

#if 0
rt_log("aray[Y]/aray[X]=%g\n", delta);
#endif

d861 1
a861 1
				rt_log("hf: cell %d,%d [%g -- %g] ",
a863 4
			/*
			 * Are we on the grid yet?  If not, then
			 * we will check for a side step and inc.
			 */
a875 8
			/*
			 * Get the min/max of the four corners of
			 * a given cell.  Since the data in memory
			 * can be in one of two forms, unsigned short
			 * and float, we have this simple if statement
			 * around the find min/max to reference the data
			 * correctly.
			 */
a915 5
			if (rt_g.debug & DEBUG_HF) {
				rt_log("lowest=%g, highest=%g\n", 
				    lowest, highest);
			}

a919 1
#if 1
a921 3
#else
			{
#endif
d924 1
a924 1
					if (nhits++>=MAXHITS) rt_bomb("g_hf.c: too many hits.\n");
d936 1
a936 1
					rt_log("hf: cell %d,%d \n", xCell, yCell);
a983 1
#if 1
a985 3
#else
				{
#endif /* 0 */
d989 1
a989 1
						if (nhits++>=MAXHITS) rt_bomb("g_hf.c: too many hits.\n");
a1005 1
/* OTHER HALF */
d1027 1
a1027 8
		tmp = yWidth/fabs(aray[Y]);

#if 0
rt_log("hf: tmp=%g\n", tmp);
rt_log("hf: before VSCALE... aray=(%g,%g,%g)\n",
		aray[X], aray[Y], aray[Z]);
#endif

d1064 1
a1064 7
/*		delta = aray[X]/xWidth; */
		delta = aray[X]/fabs(aray[Y]);

#if 0
rt_log("aray[X]/aray[Y]=%g\n", delta);
#endif

d1091 1
a1091 1
				rt_log("hf: cell %d,%d [%g -- %g] ",
a1145 6

			if (rt_g.debug & DEBUG_HF) {
				rt_log("lowest=%g, highest=%g\n", 
				    lowest, highest);
			}

a1149 1
#if 1
a1151 3
#else
			{
#endif
d1154 1
a1154 1
					if (nhits++>=MAXHITS) rt_bomb("g_hf.c: too many hits.\n");
a1213 1
#if 1
a1215 3
#else
				{
#endif
d1219 1
a1219 1
						if (nhits++>=MAXHITS) rt_bomb("g_hf.c: too many hits.\n");
a1379 1
#if 0
a1381 1
#endif /* 0 */
@


11.2
log
@Add the raytracing parts of the height field.  This is part one
of a NVL delivery.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad4.3/librt/RCS/g_hf.c,v 1.12 1995/03/14 06:24:28 cjohnson Exp cjohnson $ (ARL)";
a307 1
#if 1
a308 3
#else
	{
#endif
d411 5
d605 3
a607 1

d650 4
d730 4
d813 8
a820 1
		tmp = xWidth/abs(aray[X]);
d857 7
a863 1
		delta = aray[Y]/yWidth;
d890 1
a890 1
				rt_log("hf: cell %d,%d [%g -- %g]\n",
d893 4
d909 8
d957 5
d966 1
d969 3
d986 1
a986 1
					rt_log("hf: cell %d,%d\n", xCell, yCell);
d1034 1
d1037 3
d1060 1
d1082 8
a1089 1
		tmp = yWidth/abs(aray[Y]);
d1126 7
a1132 1
		delta = aray[X]/xWidth;
d1159 1
a1159 1
				rt_log("hf: cell %d,%d [%g -- %g]\n",
d1214 6
d1224 1
d1227 3
d1292 1
d1295 3
d1462 1
d1465 1
@


11.1
log
@Release_4.4
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/g_hf.c,v 1.13 94/11/30 01:49:49 cjohnson Exp $ (ARL)";
d101 13
d137 1
a137 1
	struct rt_hf_internal		*xip;
d140 8
a147 1

d149 2
a150 2
	xip = (struct rt_hf_internal *)ip->idb_ptr;
	RT_HF_CK_MAGIC(xip);
d152 118
a269 1
	return -1;	/* FAIL */
d281 173
d457 1
a457 1
 *  			R T _ H F _ S H O T
d459 1
a459 1
 *  Intersect a ray with a hf.
d477 6
d485 665
a1149 2
	RT_CK_RTI(ap->a_rt_i);
	RT_CK_TOL(tol);
d1151 131
a1281 1
	return(0);			/* MISS */
a1282 1

d1296 1
d1298 2
d1301 27
d1367 20
d1399 4
@


1.13
log
@We need to optimize the cookies before comparing.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/g_hf.c,v 1.12 1994/11/29 18:18:48 mike Exp cjohnson $ (ARL)";
@


1.12
log
@If file format matches input format, don't convert it into an internal
copy, just point mp->apbuf at mp->buf.
librt/file.c revision 1.4 has support to survive this.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/g_hf.c,v 1.11 94/11/08 03:10:17 mike Exp Locker: mike $ (ARL)";
d586 1
a586 1
	if( in_cookie == out_cookie )  {
@


1.11
log
@Irix 6
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/g_hf.c,v 1.10 94/10/29 01:37:18 mike Exp Locker: mike $ (ARL)";
d585 7
@


1.10
log
@Now has grid lines matching up in both directions.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/g_hf.c,v 1.9 94/10/29 00:57:37 mike Exp Locker: mike $ (ARL)";
d131 2
d168 3
@


1.9
log
@Tagged mapped file apbuf use as "hf".
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/g_hf.c,v 1.8 94/10/28 22:14:39 mike Exp Locker: mike $ (ARL)";
d60 5
d370 7
a376 3
		cmd = RT_VLIST_LINE_MOVE;
		sp = &HF_GET((unsigned short *)xip->mp->apbuf, 0, y );
		for( x = 0; x < xip->w; x += step )  {
d378 1
a378 2
			RT_ADD_VLIST(vhead, cur, cmd );
			cmd = RT_VLIST_LINE_DRAW;
a379 1
			goal--;
d381 1
a381 1
		if( x != step+xip->w-1 )  {
a385 1
			goal--;
d392 6
a397 2
		cmd = RT_VLIST_LINE_MOVE;
		for( y = 0; y < xip->n; y += step )  {
d400 1
a400 3
			RT_ADD_VLIST(vhead, cur, cmd );
			cmd = RT_VLIST_LINE_DRAW;
			goal--;
d402 1
a402 1
		if( y != step+xip->n-1 )  {
a406 1
			goal--;
@


1.8
log
@Stripped out unneeded header includes
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/g_hf.c,v 1.7 94/10/28 21:09:38 mike Exp $ (ARL)";
d555 1
a555 1
	if( !(mp = rt_open_mapped_file( xip->dfile, NULL )) )  {
@


1.7
log
@Moved mapped files into file.c
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/g_hf.c,v 1.6 94/10/28 20:52:06 mike Exp Locker: mike $ (ARL)";
a43 9
#ifdef HAVE_UNIX_IO
# include <sys/types.h>
# include <sys/stat.h>
#endif

#ifdef HAVE_SYS_MMAN_H
# include <sys/mman.h>
#endif

d48 1
@


1.6
log
@Moved rt_hf_internal up into h/rtgeom.h
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/g_hf.c,v 1.5 94/10/28 19:46:33 mike Exp Locker: mike $ (ARL)";
a58 18
/* ====================================================================== */
/* XXX Move to raytrace.h */
struct rt_list		rt_mapped_file_head;	/* XXX move to rt_g */
struct rt_mapped_file {
	struct rt_list	l;
	char		name[512];	/* Copy of file name */
	genptr_t	buf;		/* In-memory copy of file (may be mmapped) */
	long		buflen;		/* # bytes in 'buf' */
	int		is_mapped;	/* 1=mmap() used, 0=rt_malloc/fread */
	char		appl[32];	/* Tag for application using 'apbuf' */
	genptr_t	apbuf;		/* opt: application-specific buffer */
	long		apbuflen;	/* opt: application-specific buflen */
	/* XXX Needs date stamp, in case file is modified */
	int		uses;		/* # ptrs to this struct handed out */
};
#define RT_MAPPED_FILE_MAGIC	0x4d617066	/* Mapf */
#define RT_CK_MAPPED_FILE(_p)	RT_CKMAG(_p, RT_MAPPED_FILE_MAGIC, "rt_mapped_file")

a59 183
 *			R T _ O P E N _ M A P P E D _ F I L E
 *
 *  If the file can not be opened, as descriptive an error message as
 *  possible will be printed, to simplify code handling in the caller.
 */
struct rt_mapped_file *
rt_open_mapped_file( name, appl )
CONST char	*name;		/* file name */
CONST char	*appl;		/* non-null only when app. will use 'apbuf' */
{
	struct rt_mapped_file	*mp;
#ifdef HAVE_UNIX_IO
	struct stat		sb;
#endif
	int			ret;
	int			fd;	/* unix file descriptor */
	FILE			*fp;	/* stdio file pointer */

	RES_ACQUIRE( &rt_g.res_model );
	if( RT_LIST_UNINITIALIZED( &rt_mapped_file_head ) )  {
		RT_LIST_INIT( &rt_mapped_file_head );
	}
	for( RT_LIST_FOR( mp, rt_mapped_file, &rt_mapped_file_head ) )  {
		RT_CK_MAPPED_FILE(mp);
		if( strncmp( name, mp->name, sizeof(mp->name) ) )  continue;
		if( appl && strncmp( appl, mp->appl, sizeof(mp->appl) ) )
			continue;
		/* File is already mapped */
		RES_RELEASE( &rt_g.res_model );
		return mp;
	}
	RES_RELEASE( &rt_g.res_model );
	/* File is not yet mapped, open file read only. */
#ifdef HAVE_UNIX_IO
	RES_ACQUIRE( &rt_g.res_syscall );
	ret = stat( name, &sb );
	RES_RELEASE( &rt_g.res_syscall );
	if( ret < 0 )  {
		perror(name);
		goto fail;
	}
	if( sb.st_size == 0 )  {
		rt_log("rt_open_mapped_file(%s) 0-length file\n", name);
		goto fail;
	}
	RES_ACQUIRE( &rt_g.res_syscall );
	fd = open( name, O_RDONLY );
	RES_RELEASE( &rt_g.res_syscall );
	if( fd < 0 )  {
		perror(name);
		goto fail;
	}
#endif /* HAVE_UNIX_IO */

	/* Optimisticly assume that things will proceed OK */
	GETSTRUCT( mp, rt_mapped_file );
	strncpy( mp->name, name, sizeof(mp->name) );
	if( appl ) strncpy( mp->appl, appl, sizeof(mp->appl) );

#ifdef HAVE_UNIX_IO
	mp->buflen = sb.st_size;
#  ifdef HAVE_SYS_MMAN_H
	/* Attempt to access as memory-mapped file */
	RES_ACQUIRE( &rt_g.res_syscall );
	mp->buf = mmap(
		(caddr_t)0, sb.st_size, PROT_READ, MAP_PRIVATE,
		fd, (off_t)0 );
	RES_RELEASE( &rt_g.res_syscall );
	if( mp->buf != (caddr_t)-1 )  {
	    	/* OK, it's memory mapped in! */
	    	mp->is_mapped = 1;
	    	/* It's safe to close the fd now, the manuals say */
	} else
#  endif /* HAVE_SYS_MMAN_H */
	{
		/* Allocate a local buffer, and slurp it in */
		mp->buf = rt_malloc( sb.st_size, mp->name );
		RES_ACQUIRE( &rt_g.res_syscall );
		ret = read( fd, mp->buf, sb.st_size );
		RES_RELEASE( &rt_g.res_syscall );
		if( ret != sb.st_size )  {
			perror("read");
			rt_free( (char *)mp->buf, mp->name );
			goto fail;
		}
	}
	RES_ACQUIRE( &rt_g.res_syscall );
	close(fd);
	RES_RELEASE( &rt_g.res_syscall );
#else /* !HAVE_UNIX_IO */
	/* Read it in with stdio, with no clue how big it is */
	RES_ACQUIRE( &rt_g.res_syscall );
	fp = fopen( name, "r");
	RES_RELEASE( &rt_g.res_syscall );
	if( fp == NULL )  {
		perror(name);
		goto fail;
	}
	/* Read it once to see how large it is */
	{
		char	buf[10240];
		int	got;
		mp->buflen = 0;
		RES_ACQUIRE( &rt_g.res_syscall );
		while( (got = fread( buf, 1, sizeof(buf), fp )) > 0 )
			mp->buflen += got;
		rewind(fp);
		RES_RELEASE( &rt_g.res_syscall );
	}
	/* Malloc the necessary buffer */
	mp->buf = rt_malloc( mp->buflen, mp->name );

	/* Read it again into the buffer */
	RES_ACQUIRE( &rt_g.res_syscall );
	ret = fread( mp->buf, mp->buflen, 1, fp );
	RES_RELEASE( &rt_g.res_syscall );
	if( ret != 1 )  {
		RES_ACQUIRE( &rt_g.res_syscall );
		perror("fread");
		fclose(fp);
		RES_RELEASE( &rt_g.res_syscall );
		rt_log("rt_open_mapped_file() 2nd fread failed? len=%d\n", mp->buflen);
		rt_free( (char *)mp->buf, "non-unix fread buf" );
		goto fail;
	}
	RES_ACQUIRE( &rt_g.res_syscall );
	fclose(fp);
	RES_RELEASE( &rt_g.res_syscall );
#endif

	mp->uses = 1;
	mp->l.magic = RT_MAPPED_FILE_MAGIC;
	RES_ACQUIRE( &rt_g.res_model );
	RT_LIST_APPEND( &rt_mapped_file_head, &mp->l );
	RES_RELEASE( &rt_g.res_model );
	return mp;

fail:
	if( mp )  rt_free( (char *)mp, "rt_open_mapped_file failed");
	rt_log("rt_open_mapped_file(%s) can't open file\n", name);
	return (struct rt_mapped_file *)NULL;
}
/*
 *			R T _ C L O S E _ M A P P E D _ F I L E
 */
void
rt_close_mapped_file( mp )
struct rt_mapped_file	*mp;
{
	int	ret;

	RT_CK_MAPPED_FILE(mp);
	RES_ACQUIRE( &rt_g.res_model );
	if( --mp->uses > 0 )  {
		RES_RELEASE( &rt_g.res_model );
		return;
	}
	RT_LIST_DEQUEUE( &mp->l );
	RES_RELEASE( &rt_g.res_model );
#ifdef HAVE_SYS_MMAN_H
	if( mp->is_mapped )  {
		RES_ACQUIRE( &rt_g.res_syscall );
		ret = munmap( mp->buf, mp->buflen );
		RES_RELEASE( &rt_g.res_syscall );
		if( ret < 0 )  perror("munmap");
	} else
#endif
	{
		rt_free( (char *)mp->buf, mp->name );
	}
	mp->buf = (genptr_t)NULL;		/* sanity */
	if( mp->apbuf )  {
		rt_free( (char *)mp->apbuf, "rt_close_mapped_file() apbuf[]" );
		mp->apbuf = (genptr_t)NULL;	/* sanity */
	}
	rt_free( (char *)mp, "struct rt_mapped_file" );
}

/* ====================================================================== */

#define HF_O(m)			offsetof(struct rt_hf_internal, m)

/*
d72 3
d91 1
@


1.5
log
@This version plots nicely.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/g_hf.c,v 1.4 94/10/28 16:44:29 mike Exp Locker: mike $ (ARL)";
a257 21
struct rt_hf_internal {
	long	magic;
	/* BEGIN USER SETABLE VARIABLES */
	char	cfile[128];		/* name of control file (optional) */
	char	dfile[128];		/* name of data file */
	char	fmt[8];			/* CV style file format descriptor */
	int	w;			/* # samples wide of data file.  ("i", "x") */
	int	n;			/* nlines of data file.  ("j", "y") */
	int	shorts;			/* !0 --> memory array is short, not float */
	fastf_t	file2mm;		/* scale factor to cvt file units to mm */
	vect_t	v;			/* origin of HT in model space */
	vect_t	x;			/* model vect corresponding to "w" dir (will be unitized) */
	vect_t	y;			/* model vect corresponding to "n" dir (will be unitized) */
	fastf_t	xlen;			/* model len of HT rpp in "w" dir */
	fastf_t	ylen;			/* model len of HT rpp in "n" dir */
	fastf_t	zscale;			/* scale of data in ''up'' dir (after file2mm is applied) */
	/* END USER SETABLE VARIABLES, BEGIN INTERNAL STUFF */
	struct rt_mapped_file	*mp;	/* actual data */
};
#define RT_HF_INTERNAL_MAGIC	0x4846494d
#define RT_HF_CK_MAGIC(_p)	RT_CKMAG(_p,RT_HF_INTERNAL_MAGIC,"rt_hf_internal")
@


1.4
log
@Checkpoint.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/g_hf.c,v 1.3 94/10/25 23:21:45 mike Exp Locker: mike $ (ARL)";
d273 1
a273 1
	fastf_t	zlen;			/* model len of HT rpp in ''up'' dir */
d307 1
a307 1
	{"%f",	1,	"zlen",		HF_O(zlen),		FUNC_NULL },
d490 1
d502 1
a502 1
	VSCALE( zbasis, zbasis, xip->zlen * xip->file2mm );
d505 1
a505 1
	goal = 50000;
d523 3
a525 1
	/* Draw the four "ridge lines" at full resolution, for edge matching */
d540 1
a540 1
	sp = &HF_GET((unsigned short *)xip->mp->apbuf, xip->n - 1, 0 );
d562 1
a562 1
	sp = &HF_GET((unsigned short *)xip->mp->apbuf, 0, xip->w - 1 );
a570 1
	if( goal <= 0 )  return 0;		/* no vectors for interior */
d572 13
a584 2
	/* Compute data stride based upon producing no more than 'goal' vectors */
	step = ceil(sqrt( 2*(xip->w-1)*(xip->n-1) / (double)goal ));
d586 1
d588 2
a589 6
	/* Draw the contour lines in W direction only */
	for( y = 0; y < xip->n; y += step )  {
		register int	x;
		point_t		cur;
		int		cmd;

d592 1
a592 1
		sp = &HF_GET((unsigned short *)xip->mp->apbuf, y, 0 );
d597 1
a597 1
			sp++;
d600 4
a603 3
		if( x < xip->w-1 )  {
			sp = &HF_GET((unsigned short *)xip->mp->apbuf, y, xip->w-1 );
			VJOIN2( cur, cur, x, xbasis, *sp, zbasis );
d609 19
a627 2

rt_log("vector count overshoot = %d, negative is good\n", goal);
d700 1
a700 1
	xip->zlen = 1000;
d734 1
a734 1
		if( rt_structparse( &str, rt_hf_parse, (char *)xip ) < 0 )  {
d766 1
a766 1
	xip->zlen /= mat[15];
d814 9
d842 1
a842 1
	xip->zlen /= local2mm;
@


1.3
log
@Initial version works.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/g_hf.c,v 1.2 94/10/25 18:48:30 mike Exp Locker: mike $ (ARL)";
d60 2
a61 2
/* XXX Move this to some other file */
struct rt_list		rt_mapped_file_head;
d92 1
d96 1
d106 1
d109 1
d112 4
a115 1
	if( stat( name, &sb ) < 0 )  {
d123 4
a126 1
	if( (fd = open( name, O_RDONLY )) < 0 )  {
d141 6
a146 3
	if( (mp->buf = mmap(
	    (caddr_t)0, sb.st_size, PROT_READ, MAP_PRIVATE,
	    fd, (off_t)0 )) != (caddr_t)-1 )  {
d155 4
a158 1
		if( read( fd, mp->buf, sb.st_size ) != sb.st_size )  {
d164 1
d166 1
d169 4
a172 1
	if( (fp = fopen( name, "r")) == NULL )  {
d181 1
d185 1
d191 5
a195 1
	if( fread( mp->buf, mp->buflen, 1, fp ) != 1 )  {
d197 2
a200 1
		fclose(fp);
d203 1
d205 1
d210 3
d227 2
d230 7
a236 1
	if( --mp->uses > 0 )  return;
d239 4
a242 1
		if( munmap( mp->buf, mp->buflen ) < 0 )  perror("munmap");
d248 1
d251 1
a251 1
		mp->apbuf = (genptr_t)NULL;
d266 1
a266 1
	int	shorts;			/* !0 --> memory array is short, not double */
d271 3
a273 2
	fastf_t	xlen;			/* model len of HT in "w" dir */
	fastf_t	ylen;			/* model len of HT in "n" dir */
d283 10
d307 1
d310 9
d485 2
d488 3
a490 1
	int		stride;
a497 1
	sp = (unsigned short *)xip->mp->apbuf;
d501 1
a501 1
	VSCALE( zbasis, zbasis, xip->file2mm );
d503 3
d508 1
d511 1
d514 1
d517 1
d519 1
d521 53
d575 1
a575 1
	for( y = 0; y < xip->n; y++ )  {
d582 2
a583 1
		for( x = 0; x < xip->w; x++ )  {
d588 1
d590 6
d598 2
d672 1
d716 1
d736 3
a738 1
	xip->file2mm /= mat[15];
d763 1
a763 1
	/* Transform external data to internal format */
d768 2
a769 2
		mp->apbuflen = sizeof(double) * count;
		out_cookie = cv_cookie("hd");
a778 2
	/* Find min and max? */

d803 3
a805 1
	xip->file2mm /= local2mm;		/* xform */
@


1.2
log
@Began work on mapped file manager.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/g_hf.c,v 1.1 94/10/24 23:59:22 mike Exp Locker: mike $ (ARL)";
d66 1
a66 1
	int		buflen;		/* # bytes in 'buf' */
d70 2
a71 1
	char		apbuflen;	/* opt: application-specific buflen */
d128 1
d156 8
d165 2
d168 7
a174 1
	XXX_no_UNIX_io;
a177 3



d195 14
d210 1
d215 1
d228 2
d249 3
a324 2
#define RT_HF_SEG_MISS(SEG)	(SEG).seg_stp=RT_SOLTAB_NULL

a325 16
 *			R T _ H F _ V S H O T
 *
 *  Vectorized version.
 */
void
rt_hf_vshot( stp, rp, segp, n, ap )
struct soltab	       *stp[]; /* An array of solid pointers */
struct xray		*rp[]; /* An array of ray pointers */
struct  seg            segp[]; /* array of segs (results returned) */
int		  	    n; /* Number of ray/object pairs */
struct application	*ap;
{
	rt_vstub( stp, rp, segp, n, ap );
}

/*
d414 7
d426 35
a460 1
	return(-1);
d502 1
d504 1
a504 1
	int				fmt;	/* format cookie */
d506 3
d596 3
d600 1
a600 1
	if( (fmt = cv_cookie( xip->fmt )) == 0 )  {
d604 1
a604 1
	in_len = cv_itemlen( fmt );
d606 6
a611 3
	/* Load data file, and transform to internal format */
	if( !(mf = rt_open_mapped_file( xif->dfile, NULL )) )  {
		/* fail */
d613 2
d616 21
d660 1
a698 1
	char	buf[256];
d700 1
d702 3
a704 1
	rt_vls_strcat( str, "Height Field (HF)\n");
a705 6
	sprintf(buf, "\tV (%g, %g, %g)\n",
		xip->v[X] * mm2local,
		xip->v[Y] * mm2local,
		xip->v[Z] * mm2local );
	rt_vls_strcat( str, buf );

d724 3
@


1.1
log
@Initial revision
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
d35 7
d43 10
d59 124
d443 3
d519 4
d525 7
d533 7
d541 3
@
