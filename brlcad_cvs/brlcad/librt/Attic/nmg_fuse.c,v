head	11.74;
access;
symbols
	ansi-20040405-merged:11.69.2.2
	postmerge-20040405-ansi:11.72
	premerge-20040404-ansi:11.71
	postmerge-autoconf:11.71
	autoconf-freeze:11.69.10.3
	premerge-autoconf:11.71
	ansi-20040316-freeze:11.69.2.1
	postmerge-20040315-windows:11.71
	premerge-20040315-windows:11.70
	windows-20040315-freeze:11.69.4.2
	autoconf-20031203:11.69
	autoconf-20031202:11.69
	autoconf-branch:11.69.0.10
	phong-branch:11.69.0.8
	photonmap-branch:11.69.0.6
	rel-6-1-DP:11.69
	windows-branch:11.69.0.4
	rel-6-0-2:11.67
	ansi-branch:11.69.0.2
	rel-6-0-1-branch:11.67.0.2
	hartley-6-0-post:11.68
	hartley-6-0-pre:11.67
	rel-6-0-1:11.67
	rel-6-0:11.67
	rel-5-4:11.61
	offsite-5-3-pre:11.65
	rel-5-3:11.61
	rel-5-2:11.61
	rel-5-1-branch:11.61.0.2
	rel-5-1:11.61
	rel-5-0:11.53
	rel-5-0-beta:11.52
	rel-4-5:11.47
	ctj-4-5-post:11.47
	ctj-4-5-pre:11.46
	rel-4-4:11.1;
locks; strict;
comment	@ * @;


11.74
date	2004.05.21.18.07.32;	author morrison;	state dead;
branches;
next	11.73;

11.73
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.72;

11.72
date	2004.04.05.08.48.57;	author morrison;	state Exp;
branches;
next	11.71;

11.71
date	2004.03.16.20.03.09;	author morrison;	state Exp;
branches;
next	11.70;

11.70
date	2004.02.02.17.39.23;	author morrison;	state Exp;
branches;
next	11.69;

11.69
date	2002.08.20.17.08.03;	author jra;	state Exp;
branches
	11.69.2.1
	11.69.4.1
	11.69.10.1;
next	11.68;

11.68
date	2002.08.15.20.55.15;	author hartley;	state Exp;
branches;
next	11.67;

11.67
date	2001.04.05.19.35.34;	author morrison;	state Exp;
branches;
next	11.66;

11.66
date	2001.03.31.01.57.10;	author morrison;	state Exp;
branches;
next	11.65;

11.65
date	2000.10.18.18.10.35;	author butler;	state Exp;
branches;
next	11.64;

11.64
date	2000.08.23.00.35.53;	author mike;	state Exp;
branches;
next	11.63;

11.63
date	2000.08.21.02.02.32;	author butler;	state Exp;
branches;
next	11.62;

11.62
date	2000.07.10.23.01.40;	author mike;	state Exp;
branches;
next	11.61;

11.61
date	2000.05.02.01.46.03;	author mike;	state Exp;
branches;
next	11.60;

11.60
date	2000.04.01.01.34.21;	author mike;	state Exp;
branches;
next	11.59;

11.59
date	2000.03.29.01.36.59;	author mike;	state Exp;
branches;
next	11.58;

11.58
date	2000.03.28.22.39.59;	author mike;	state Exp;
branches;
next	11.57;

11.57
date	2000.03.28.22.11.15;	author mike;	state Exp;
branches;
next	11.56;

11.56
date	2000.03.28.22.06.13;	author mike;	state Exp;
branches;
next	11.55;

11.55
date	2000.03.28.22.00.10;	author mike;	state Exp;
branches;
next	11.54;

11.54
date	99.12.30.15.54.29;	author jra;	state Exp;
branches;
next	11.53;

11.53
date	99.06.03.01.39.14;	author mike;	state Exp;
branches;
next	11.52;

11.52
date	99.05.11.19.08.24;	author mike;	state Exp;
branches;
next	11.51;

11.51
date	98.07.30.19.50.29;	author jra;	state Exp;
branches;
next	11.50;

11.50
date	98.07.09.14.21.25;	author jra;	state Exp;
branches;
next	11.49;

11.49
date	98.03.12.20.55.05;	author jra;	state Exp;
branches;
next	11.48;

11.48
date	98.03.03.20.48.26;	author jra;	state Exp;
branches;
next	11.47;

11.47
date	97.08.15.19.23.47;	author jra;	state Exp;
branches;
next	11.46;

11.46
date	97.06.13.21.35.22;	author mike;	state Exp;
branches;
next	11.45;

11.45
date	97.06.13.21.30.57;	author mike;	state Exp;
branches;
next	11.44;

11.44
date	97.04.10.19.52.34;	author jra;	state Exp;
branches;
next	11.43;

11.43
date	96.09.27.08.27.30;	author mike;	state Exp;
branches;
next	11.42;

11.42
date	96.08.27.03.05.29;	author mike;	state Exp;
branches;
next	11.41;

11.41
date	96.07.12.12.17.41;	author jra;	state Exp;
branches;
next	11.40;

11.40
date	96.05.16.22.08.35;	author jra;	state Exp;
branches;
next	11.39;

11.39
date	96.05.07.14.10.10;	author jra;	state Exp;
branches;
next	11.38;

11.38
date	96.05.01.13.24.31;	author jra;	state Exp;
branches;
next	11.37;

11.37
date	96.04.22.12.46.33;	author jra;	state Exp;
branches;
next	11.36;

11.36
date	96.04.22.12.40.11;	author jra;	state Exp;
branches;
next	11.35;

11.35
date	96.03.25.21.11.16;	author jra;	state Exp;
branches;
next	11.34;

11.34
date	96.03.18.00.08.55;	author jra;	state Exp;
branches;
next	11.33;

11.33
date	96.03.05.21.30.20;	author jra;	state Exp;
branches;
next	11.32;

11.32
date	96.02.16.15.22.01;	author jra;	state Exp;
branches;
next	11.31;

11.31
date	96.01.17.18.15.18;	author jra;	state Exp;
branches;
next	11.30;

11.30
date	95.12.02.03.09.46;	author mike;	state Exp;
branches;
next	11.29;

11.29
date	95.11.30.16.08.08;	author mike;	state Exp;
branches;
next	11.28;

11.28
date	95.05.05.21.00.26;	author jra;	state Exp;
branches;
next	11.27;

11.27
date	95.05.04.23.02.19;	author jra;	state Exp;
branches;
next	11.26;

11.26
date	95.04.04.13.23.46;	author jra;	state Exp;
branches;
next	11.25;

11.25
date	95.03.29.20.39.34;	author jra;	state Exp;
branches;
next	11.24;

11.24
date	95.03.22.20.39.29;	author jra;	state Exp;
branches;
next	11.23;

11.23
date	95.03.17.14.58.16;	author jra;	state Exp;
branches;
next	11.22;

11.22
date	95.03.08.13.07.39;	author jra;	state Exp;
branches;
next	11.21;

11.21
date	95.03.05.17.28.11;	author mike;	state Exp;
branches;
next	11.20;

11.20
date	95.03.03.23.46.11;	author mike;	state Exp;
branches;
next	11.19;

11.19
date	95.03.03.23.27.08;	author mike;	state Exp;
branches;
next	11.18;

11.18
date	95.03.03.22.37.43;	author mike;	state Exp;
branches;
next	11.17;

11.17
date	95.03.03.14.47.36;	author jra;	state Exp;
branches;
next	11.16;

11.16
date	95.03.02.19.43.22;	author jra;	state Exp;
branches;
next	11.15;

11.15
date	95.03.02.14.34.15;	author mike;	state Exp;
branches;
next	11.14;

11.14
date	95.03.02.13.04.39;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	95.03.02.12.41.42;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	95.03.02.10.10.50;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	95.03.02.04.19.44;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	95.03.01.06.20.27;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	95.03.01.04.28.42;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	95.02.28.04.15.44;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	95.02.27.16.28.09;	author jra;	state Exp;
branches;
next	11.6;

11.6
date	95.02.26.10.13.02;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	95.02.25.00.11.21;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	95.02.24.23.56.17;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	95.02.21.03.29.32;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	95.01.19.23.39.32;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.57.35;	author mike;	state Rel4_4;
branches;
next	1.35;

1.35
date	95.01.04.08.07.33;	author mike;	state Exp;
branches;
next	1.34;

1.34
date	94.11.05.01.44.35;	author mike;	state Exp;
branches;
next	1.33;

1.33
date	94.11.04.12.16.53;	author jra;	state Exp;
branches;
next	1.32;

1.32
date	94.09.16.23.36.34;	author mike;	state Exp;
branches;
next	1.31;

1.31
date	94.09.16.20.45.42;	author mike;	state Exp;
branches;
next	1.30;

1.30
date	94.09.13.20.53.43;	author mike;	state Exp;
branches;
next	1.29;

1.29
date	94.09.12.21.34.25;	author mike;	state Exp;
branches;
next	1.28;

1.28
date	94.09.12.13.55.45;	author mike;	state Exp;
branches;
next	1.27;

1.27
date	94.09.10.04.36.45;	author mike;	state Exp;
branches;
next	1.26;

1.26
date	94.09.03.03.01.12;	author mike;	state Exp;
branches;
next	1.25;

1.25
date	94.09.02.00.31.55;	author mike;	state Exp;
branches;
next	1.24;

1.24
date	94.08.10.18.51.40;	author gdurf;	state Exp;
branches;
next	1.23;

1.23
date	94.08.09.19.37.36;	author mike;	state Exp;
branches;
next	1.22;

1.22
date	94.07.11.16.16.27;	author jra;	state Exp;
branches;
next	1.21;

1.21
date	94.07.11.16.02.18;	author jra;	state Exp;
branches;
next	1.20;

1.20
date	94.07.04.02.47.41;	author mike;	state Exp;
branches;
next	1.19;

1.19
date	94.07.04.01.31.36;	author mike;	state Exp;
branches;
next	1.18;

1.18
date	94.07.04.01.04.37;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	94.07.04.00.03.57;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	94.07.03.23.32.05;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	94.07.02.02.50.51;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	94.07.01.23.42.37;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	94.06.30.22.15.01;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	94.06.29.00.22.35;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	94.03.09.22.26.00;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	94.03.09.13.00.28;	author jra;	state Exp;
branches;
next	1.9;

1.9
date	94.03.02.18.59.55;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	94.03.02.18.57.45;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	94.03.02.18.18.45;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	94.02.22.20.37.41;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	94.01.25.09.43.59;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	93.12.17.02.05.22;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	93.12.16.05.35.53;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	93.12.11.12.09.23;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	93.12.02.20.11.38;	author mike;	state Exp;
branches;
next	;

11.69.2.1
date	2002.09.19.18.01.38;	author morrison;	state Exp;
branches;
next	11.69.2.2;

11.69.2.2
date	2004.03.17.21.18.52;	author morrison;	state Exp;
branches;
next	;

11.69.4.1
date	2002.09.26.23.04.03;	author morrison;	state Exp;
branches;
next	11.69.4.2;

11.69.4.2
date	2004.03.11.23.43.41;	author morrison;	state Exp;
branches;
next	;

11.69.10.1
date	2004.02.12.18.37.43;	author erikg;	state Exp;
branches;
next	11.69.10.2;

11.69.10.2
date	2004.03.15.14.07.24;	author erikg;	state Exp;
branches;
next	11.69.10.3;

11.69.10.3
date	2004.03.18.18.10.29;	author erikg;	state Exp;
branches;
next	;


desc
@Routines to fuse entities that are geometrically the same, within
tolerance.
@


11.74
log
@moved to src/
@
text
@/*
 *			N M G _ F U S E . C
 *
 *  Routines to "fuse" entities together that are geometrically identical
 *  (within tolerance) into entities that share underlying geometry
 *  structures, so that the relationship is explicit.
 *
 *  Authors -
 *	Michael John Muuss
 *	John R Anderson
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Pacakge" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1993-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/nmg_fuse.c,v 11.73 2004/05/10 15:30:46 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif


#include <stdio.h>
#ifdef HAVE_STRING_H
#include <string.h>
#endif
#include <math.h>
#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "nmg.h"
#include "raytrace.h"
#include "nurb.h"
#include "./debug.h"

extern int debug_file_count;


struct pt_list
{
	struct bu_list l;
	point_t xyz;
	fastf_t t;
};

BU_EXTERN(void			nmg_split_trim,
				(const struct edge_g_cnurb *cnrb,
				const struct face_g_snurb *snrb,
				fastf_t t,
				struct pt_list *pt0, struct pt_list *pt1,
				const struct bn_tol *tol));

/*
 *			N M G _ I S _ C O M M O N _ B I G L O O P
 *
 *  Do two faces share by topology at least one loop of 3 or more vertices?
 *
 *  Require that at least three distinct edge geometries be involved.
 *
 * XXX Won't catch sharing of faces with only self-loops and no edge loops.
 */
int
nmg_is_common_bigloop(const struct face *f1, const struct face *f2)
{
	const struct faceuse	*fu1;
	const struct loopuse	*lu1;
	const struct edgeuse	*eu1;
	const long		*magic1 = (long *)NULL;
	const long		*magic2 = (long *)NULL;
	int	nverts;
	int	nbadv;
	int	got_three;

	NMG_CK_FACE(f1);
	NMG_CK_FACE(f2);

	fu1 = f1->fu_p;
	NMG_CK_FACEUSE(fu1);

	/* For all loopuses in fu1 */
	for( BU_LIST_FOR( lu1, loopuse, &fu1->lu_hd ) )  {
		if( BU_LIST_FIRST_MAGIC(&lu1->down_hd) == NMG_VERTEXUSE_MAGIC )
			continue;
		nverts = 0;
		nbadv = 0;
		magic1 = (long *)NULL;
		magic2 = (long *)NULL;
		got_three = 0;
		for( BU_LIST_FOR( eu1, edgeuse, &lu1->down_hd ) )  {
			nverts++;
			NMG_CK_EDGE_G_LSEG(eu1->g.lseg_p);
			if( !magic1 )  {
				magic1 = eu1->g.magic_p;
			} else if( !magic2 )  {
				if( eu1->g.magic_p != magic1 )  {
					magic2 = eu1->g.magic_p;
				}
			} else {
				if( eu1->g.magic_p != magic1 &&
				    eu1->g.magic_p != magic2 )  {
					got_three = 1;
				}
			}
			if( nmg_is_vertex_in_face( eu1->vu_p->v_p, f2 ) )
				continue;
			nbadv++;
			break;
		}
		if( nbadv <= 0 && nverts >= 3 && got_three )  return 1;
	}
	return 0;
}

/*
 *			N M G _ R E G I O N _ V _ U N I Q U E
 *
 *  Ensure that all the vertices in r1 are still geometricaly unique.
 *  This will be true after nmg_region_both_vfuse() has been called,
 *  and should remain true throughout the intersection process.
 */
void
nmg_region_v_unique(struct nmgregion *r1, const struct bn_tol *tol)
{
	int	i;
	int	j;
	struct bu_ptbl	t;

	NMG_CK_REGION(r1);
	BN_CK_TOL(tol);

	nmg_vertex_tabulate( &t, &r1->l.magic );

	for( i = BU_PTBL_END(&t)-1; i >= 0; i-- )  {
		register struct vertex	*vi;
		vi = (struct vertex *)BU_PTBL_GET(&t, i);
		NMG_CK_VERTEX(vi);
		if( !vi->vg_p )  continue;

		for( j = i-1; j >= 0; j-- )  {
			register struct vertex	*vj;
			vj = (struct vertex *)BU_PTBL_GET(&t, j);
			NMG_CK_VERTEX(vj);
			if( !vj->vg_p )  continue;
			if( !bn_pt3_pt3_equal( vi->vg_p->coord, vj->vg_p->coord, tol ) )
				continue;
			/* They are the same */
			bu_log("nmg_region_v_unique():  2 verts are the same, within tolerance\n");
			nmg_pr_v( vi, 0 );
			nmg_pr_v( vj, 0 );
			rt_bomb("nmg_region_v_unique()\n");
		}
	}
	bu_ptbl_free( &t);
}

/*
 *			N M G _ P T B L _ V F U S E
 *
 *  Working from the end to the front, scan for geometric duplications
 *  within a single list of vertex structures.
 *
 *  Exists primarily as a support routine for nmg_model_vertex_fuse().
 */
int
nmg_ptbl_vfuse(struct bu_ptbl *t, const struct bn_tol *tol)
{
	int	count = 0;
	int	i;
	int	j;

	for( i = BU_PTBL_END(t)-1; i >= 0; i-- )  {
		register struct vertex	*vi;
		vi = (struct vertex *)BU_PTBL_GET(t, i);
		NMG_CK_VERTEX(vi);
		if( !vi->vg_p )  continue;

		for( j = i-1; j >= 0; j-- )  {
			register struct vertex	*vj;
			vj = (struct vertex *)BU_PTBL_GET(t, j);
			NMG_CK_VERTEX(vj);
			if( !vj->vg_p )  continue;
			if( !bn_pt3_pt3_equal( vi->vg_p->coord, vj->vg_p->coord, tol ) )
				continue;
			/* They are the same, fuse vi into vj */
			nmg_jv( vj, vi );
			bu_ptbl_rm( t, (long *)vi );
			count++;
			break;
		}
	}
	return count;
}

/*
 *			N M G _ R E G I O N _ B O T H _ V F U S E
 *
 *  For every element in t1, scan t2 for geometric duplications.
 *
 *  Deleted elements in t2 are marked by a null vertex pointer,
 *  rather than bothering to do a BU_PTBL_RM, which will re-copy the
 *  list to compress it.
 *
 *  Exists as a support routine for nmg_two_region_vertex_fuse()
 */
int
nmg_region_both_vfuse(struct bu_ptbl *t1, struct bu_ptbl *t2, const struct bn_tol *tol)
{
	int	count = 0;
	int	i;
	int	j;

	/* Verify t2 is good to start with */
	for( j = BU_PTBL_END(t2)-1; j >= 0; j-- )  {
		register struct vertex	*vj;
		vj = (struct vertex *)BU_PTBL_GET(t2, j);
		NMG_CK_VERTEX(vj);
	}

	for( i = BU_PTBL_END(t1)-1; i >= 0; i-- )  {
		register struct vertex	*vi;
		vi = (struct vertex *)BU_PTBL_GET(t1, i);
		NMG_CK_VERTEX(vi);
		if( !vi->vg_p )  continue;

		for( j = BU_PTBL_END(t2)-1; j >= 0; j-- )  {
			register struct vertex	*vj;
			vj = (struct vertex *)BU_PTBL_GET(t2, j);
			if(!vj) continue;
			NMG_CK_VERTEX(vj);
			if( !vj->vg_p )  continue;
			if( !bn_pt3_pt3_equal( vi->vg_p->coord, vj->vg_p->coord, tol ) )
				continue;
			/* They are the same, fuse vj into vi */
			nmg_jv( vi, vj );
			BU_PTBL_GET(t2, j) = 0;
			count++;
		}
	}
	return count;
}

#if 0
/*
 *			N M G _ T W O _ R E G I O N _ V E R T E X _ F U S E
 *
 *  This routine should not be used.  Instead, call nmg_model_vertex_fuse().
 */
int
nmg_two_region_vertex_fuse( r1, r2, tol )
struct nmgregion	*r1;
struct nmgregion	*r2;
const struct bn_tol	*tol;
{
	struct bu_ptbl	t1;
	struct bu_ptbl	t2;
	int		total = 0;

	NMG_CK_REGION(r1);
	NMG_CK_REGION(r2);
	BN_CK_TOL(tol);

	if( r1->m_p != r2->m_p )  rt_bomb("nmg_two_region_vertex_fuse:  regions not in same model\n");

	nmg_vertex_tabulate( &t1, &r1->l.magic );
	nmg_vertex_tabulate( &t2, &r2->l.magic );

	total = nmg_ptbl_vfuse( &t1, tol );
	total += nmg_region_both_vfuse( &t1, &t2, tol );

	bu_ptbl_free( &t1);
	bu_ptbl_free( &t2);

	return total;
}
#endif

/*
 *			N M G _ M O D E L _ V E R T E X _ F U S E
 *
 *  Fuse together any vertices in the nmgmodel that are geometricly
 *  identical, within the tolerance.
 */
int
nmg_model_vertex_fuse(struct model *m, const struct bn_tol *tol)
{
	struct bu_ptbl	t1;
	int		total = 0;

	NMG_CK_MODEL(m);
	BN_CK_TOL(tol);

	nmg_vertex_tabulate( &t1, &m->magic );

	total = nmg_ptbl_vfuse( &t1, tol );

	bu_ptbl_free( &t1);

	if( rt_g.NMG_debug & DEBUG_BASIC && total > 0 )
		bu_log("nmg_model_vertex_fuse() %d\n", total);
	return total;
}

/*
 *		N M G _ C N U R B _ I S _ L I N E A R
 *
 *	Checks if cnurb is linear
 *
 *	Returns:
 *		1 - cnurb is linear
 *		0 - either cnurb is not linear, or it's not obvious
 */

int
nmg_cnurb_is_linear(const struct edge_g_cnurb *cnrb)
{
	int i;
	int coords;
	int last_index;
	int linear=0;

	NMG_CK_EDGE_G_CNURB( cnrb );

	if( rt_g.NMG_debug & DEBUG_MESH )
	{
		bu_log( "nmg_cnurb_is_linear( x%x )\n", cnrb );
		rt_nurb_c_print( cnrb );
	}

	if( cnrb->order <= 0 )
	{
		linear = 1;
		goto out;
	}

	if( cnrb->order == 2 )
	{
		if( cnrb->c_size == 2 )
		{
			linear = 1;
			goto out;
		}
	}

	coords = RT_NURB_EXTRACT_COORDS( cnrb->pt_type );
	last_index = (cnrb->c_size - 1)*coords;

	/* Check if all control points are either the start point or end point */
	for( i=1 ; i<cnrb->c_size-2 ; i++ )
	{
		if( VEQUAL( &cnrb->ctl_points[0], &cnrb->ctl_points[i] ) )
			continue;
		if( VEQUAL( &cnrb->ctl_points[last_index], &cnrb->ctl_points[i] ) )
			continue;

		goto out;
	}

	linear = 1;

out:
	if( rt_g.NMG_debug & DEBUG_MESH )
		bu_log( "nmg_cnurb_is_linear( x%x ) returning %d\n", cnrb, linear );

	return( linear );
}

/*
 *			N M G _ S N U R B _ I S _ P L A N A R
 *
 *	Checks if snurb surface is planar
 *
 *	Returns:
 *		0 - surface is not planar
 *		1 - surface is planar (within tolerance)
 */

int
nmg_snurb_is_planar(const struct face_g_snurb *srf, const struct bn_tol *tol)
{
	plane_t pl;
	int i;
	int coords;
	mat_t matrix;
	mat_t inverse;
	vect_t vsum;
	double det;
	double one_over_vertex_count;
	int planar=0;

	NMG_CK_FACE_G_SNURB( srf );
	BN_CK_TOL( tol );

	if( rt_g.NMG_debug & DEBUG_MESH )
	{
		bu_log( "nmg_snurb_is_planar( x%x )\n", srf );
#if 1
		rt_nurb_s_print( "", srf );
#endif
	}

	if( srf->order[0] == 2 && srf->order[1] == 2 )
	{
		if( srf->s_size[0] == 2 && srf->s_size[1] == 2 )
		{
			planar = 1;
			goto out;
		}
	}

	/* build matrix */
	MAT_ZERO( matrix );
	VSET( vsum , 0.0 , 0.0 , 0.0 );

	one_over_vertex_count = 1.0/(double)(srf->s_size[0]*srf->s_size[1]);
	coords = RT_NURB_EXTRACT_COORDS( srf->pt_type );

	/* calculate an average plane for all control points */
	for( i=0 ; i<srf->s_size[0]*srf->s_size[1] ; i++ )
	{
		fastf_t *pt;

		pt = &srf->ctl_points[ i*coords ];

		matrix[0] += pt[X] * pt[X];
		matrix[1] += pt[X] * pt[Y];
		matrix[2] += pt[X] * pt[Z];
		matrix[5] += pt[Y] * pt[Y];
		matrix[6] += pt[Y] * pt[Z];
		matrix[10] += pt[Z] * pt[Z];

		vsum[X] += pt[X];
		vsum[Y] += pt[Y];
		vsum[Z] += pt[Z];
	}
	matrix[4] = matrix[1];
	matrix[8] = matrix[2];
	matrix[9] = matrix[6];
	matrix[15] = 1.0;
		
	/* Check that we don't have a singular matrix */
	det = bn_mat_determinant( matrix );

	if( !NEAR_ZERO( det , SMALL_FASTF ) )
	{
		fastf_t inv_len_pl;

		/* invert matrix */
		bn_mat_inv( inverse , matrix );

		/* get normal vector */
		MAT4X3PNT( pl , inverse , vsum );

		/* unitize direction vector */
		inv_len_pl = 1.0/(MAGNITUDE( pl ));
		HSCALE( pl , pl , inv_len_pl );

		/* get average vertex coordinates */
		VSCALE( vsum, vsum, one_over_vertex_count );

		/* get distance from plane to orgin */
		pl[H] = VDOT( pl , vsum );

	}
	else
	{
		int x_same=1;
		int y_same=1;
		int z_same=1;

		/* singular matrix, may occur if all vertices have the same zero
		 * component.
		 */
		for( i=1 ; i<srf->s_size[0]*srf->s_size[1] ; i++ )
		{
			if( srf->ctl_points[i*coords+X] != srf->ctl_points[X] )
				x_same = 0;
			if( srf->ctl_points[i*coords+Y] != srf->ctl_points[Y] )
				y_same = 0;
			if( srf->ctl_points[i*coords+Z] != srf->ctl_points[Z] )
				z_same = 0;

			if( !x_same && !y_same && !z_same )
				break;
		}

		if( x_same )
		{
			VSET( pl , 1.0 , 0.0 , 0.0 );
		}
		else if( y_same )
		{
			VSET( pl , 0.0 , 1.0 , 0.0 );
		}
		else if( z_same )
		{
			VSET( pl , 0.0 , 0.0 , 1.0 );
		}

		if( x_same || y_same || z_same )
		{
			/* get average vertex coordinates */
			VSCALE( vsum, vsum, one_over_vertex_count );

			/* get distance from plane to orgin */
			pl[H] = VDOT( pl , vsum );

		}
		else
		{
			bu_log( "nmg_snurb_is_plana: Cannot calculate plane for snurb x%x\n" , srf );
			rt_nurb_s_print( "", srf );
			rt_bomb( "nmg_snurb_is_plana: Cannot calculate plane for snurb\n" );
		}
	}

	/* Now verify that every control point is on this plane */
	for( i=0 ; i<srf->s_size[0]*srf->s_size[1] ; i++ )
	{
		fastf_t *pt;
		fastf_t dist;

		pt = &srf->ctl_points[ i*coords ];

		dist = DIST_PT_PLANE( pt, pl );
		if( dist > tol->dist )
			goto out;
	}

	planar = 1;
out:
	if( rt_g.NMG_debug & DEBUG_MESH )
		bu_log( "nmg_snurb_is_planar( x%x ) returning %d\n", srf, planar );

	return( planar );

}

void
nmg_eval_linear_trim_curve(const struct face_g_snurb *snrb, const fastf_t *uvw, fastf_t *xyz)
{
	int coords;
	hpoint_t xyz1;

	if( snrb )
	{
		NMG_CK_FACE_G_SNURB( snrb );
		rt_nurb_s_eval( snrb, uvw[0], uvw[1], xyz1 );
		if( RT_NURB_IS_PT_RATIONAL( snrb->pt_type ) )
		{
			fastf_t inverse_weight;

			coords = RT_NURB_EXTRACT_COORDS( snrb->pt_type );
			inverse_weight = 1.0/xyz1[coords-1];

			VSCALE( xyz, xyz1, inverse_weight );
		}
		else
			VMOVE( xyz, xyz1 )
	}
	else
		VMOVE( xyz, uvw )

}

void
nmg_eval_trim_curve(const struct edge_g_cnurb *cnrb, const struct face_g_snurb *snrb, const fastf_t t, fastf_t *xyz)
{
	hpoint_t uvw;
	hpoint_t xyz1;
	int coords;

	NMG_CK_EDGE_G_CNURB( cnrb );
	if( snrb )
	{
		NMG_CK_FACE_G_SNURB( snrb )
	}

	rt_nurb_c_eval( cnrb, t, uvw );

	if( RT_NURB_IS_PT_RATIONAL( cnrb->pt_type ) )
	{
		fastf_t inverse_weight;

		coords = RT_NURB_EXTRACT_COORDS( cnrb->pt_type );
		inverse_weight = 1.0/uvw[coords-1];

		VSCALE( uvw, uvw, inverse_weight );
	}

	if( snrb )
	{
		rt_nurb_s_eval( snrb, uvw[0], uvw[1], xyz1 );
		if( RT_NURB_IS_PT_RATIONAL( snrb->pt_type ) )
		{
			fastf_t inverse_weight;

			coords = RT_NURB_EXTRACT_COORDS( snrb->pt_type );
			inverse_weight = 1.0/xyz1[coords-1];

			VSCALE( xyz, xyz1, inverse_weight );
		}
		else
			VMOVE( xyz, xyz1 )
	}
	else
		VMOVE( xyz, uvw )

#if 0
	if( rt_g.NMG_debug & DEBUG_MESH )
		bu_log( "nmg_eval_trim_curve returning (%g %g %g )\n", V3ARGS( xyz ) );
#endif

}

void
nmg_split_trim(const struct edge_g_cnurb *cnrb, const struct face_g_snurb *snrb, fastf_t t, struct pt_list *pt0, struct pt_list *pt1, const struct bn_tol *tol)
{
	struct pt_list *pt_new;
	fastf_t t_sub;
	vect_t seg;

	NMG_CK_EDGE_G_CNURB( cnrb );
	NMG_CK_FACE_G_SNURB( snrb );
	BN_CK_TOL( tol );
#if 0
	if( rt_g.NMG_debug & DEBUG_MESH )
		bu_log( "nmg_split_trim( cnrb=x%x, snrb=x%x, t=%g, pt0=x%x, pt1=x%x )START\n",
			cnrb, snrb, t, pt0, pt1 );
#endif
	pt_new = (struct pt_list *)bu_malloc( sizeof( struct pt_list ), "g_split_trim: pt_new" );
	pt_new->t = t;

	if( pt_new->t < pt0->t || pt_new->t > pt1->t )
	{
		bu_log( "nmg_split_trim: split parameter (%g) is not between ends (%g and %g)\n",
			t, pt0->t, pt1->t );
		rt_bomb( "nmg_split_trim: split parameteris not between ends\n" );
	}

	nmg_eval_trim_curve( cnrb, snrb, pt_new->t, pt_new->xyz );

	BU_LIST_INSERT( &pt1->l, &pt_new->l );

	VSUB2( seg, pt0->xyz, pt_new->xyz );
	if( MAGSQ( seg ) > tol->dist_sq )
	{
		t_sub = (pt0->t + pt_new->t)/2.0;
#if 0
		if( rt_g.NMG_debug & DEBUG_MESH )
			bu_log( "nmg_split_trim: recursing at t=%g (%g,%g)\n",
					t_sub, pt0->t, pt_new->t );
#endif
		nmg_split_trim( cnrb, snrb, t_sub, pt0, pt_new, tol );
	}

	VSUB2( seg, pt_new->xyz, pt1->xyz );
	if( MAGSQ( seg ) > tol->dist_sq )
	{
		t_sub = (pt_new->t + pt1->t)/2.0;
#if 0
		if( rt_g.NMG_debug & DEBUG_MESH )
			bu_log( "nmg_split_trim: recursing at t=%g (%g,%g)\n",
					t_sub, pt_new->t, pt1->t );
#endif
		nmg_split_trim( cnrb, snrb, t_sub, pt_new, pt1, tol );
	}
#if 0
	if( rt_g.NMG_debug & DEBUG_MESH )
		bu_log( "nmg_split_trim( cnrb=x%x, snrb=x%x, t=%g, pt0=x%x, pt1=x%x ) END\n",
			cnrb, snrb, t, pt0, pt1 );
#endif

}

void
nmg_eval_trim_to_tol(const struct edge_g_cnurb *cnrb, const struct face_g_snurb *snrb, const fastf_t t0, const fastf_t t1, struct bu_list *head, const struct bn_tol *tol)
{
	fastf_t t;
	struct pt_list *pt0,*pt1;

	NMG_CK_EDGE_G_CNURB( cnrb );
	NMG_CK_FACE_G_SNURB( snrb );
	BN_CK_TOL( tol );

	if( rt_g.NMG_debug & DEBUG_MESH )
		bu_log( "nmg_eval_trim_to_tol( cnrb=x%x, snrb=x%x, t0=%g, t1=%g ) START\n",
				cnrb, snrb, t0, t1 );

	pt0 = (struct pt_list *)bu_malloc( sizeof( struct pt_list ), "nmg_eval_trim_to_tol: pt0 " );
	pt0->t = t0;
	nmg_eval_trim_curve( cnrb, snrb, pt0->t, pt0->xyz );
	BU_LIST_INSERT( head, &pt0->l );

	pt1 = (struct pt_list *)bu_malloc( sizeof( struct pt_list ), "nmg_eval_trim_to_tol: pt1 " );
	pt1->t = t1;
	nmg_eval_trim_curve( cnrb, snrb, pt1->t, pt1->xyz );
	BU_LIST_INSERT( head, &pt1->l );

	t = (t0 + t1)/2.0;
	nmg_split_trim( cnrb, snrb, t, pt0, pt1, tol );

	if( rt_g.NMG_debug & DEBUG_MESH )
		bu_log( "nmg_eval_trim_to_tol( cnrb=x%x, snrb=x%x, t0=%g, t1=%g ) END\n",
				cnrb, snrb, t0, t1 );
}

void
nmg_split_linear_trim(const struct face_g_snurb *snrb, const fastf_t *uvw1, const fastf_t *uvw, const fastf_t *uvw2, struct pt_list *pt0, struct pt_list *pt1, const struct bn_tol *tol)
{
	struct pt_list *pt_new;
	fastf_t t_sub;
	fastf_t uvw_sub[3];
	vect_t seg;

	if( snrb )
		NMG_CK_FACE_G_SNURB( snrb );
	BN_CK_TOL( tol );
#if 0
	if( rt_g.NMG_debug & DEBUG_MESH )
		bu_log( "nmg_split_linear_trim( snrb=x%x, pt0=x%x, pt1=x%x )START\n",
			snrb, pt0, pt1 );
#endif
	pt_new = (struct pt_list *)bu_malloc( sizeof( struct pt_list ), "g_split_trim: pt_new" );
	pt_new->t = 0.5*(pt0->t + pt1->t);

	VBLEND2( uvw_sub, 1.0 - pt_new->t, uvw1, pt_new->t, uvw2 );
	nmg_eval_linear_trim_curve( snrb, uvw_sub, pt_new->xyz );

	BU_LIST_INSERT( &pt1->l, &pt_new->l );

#if 0
	if( rt_g.NMG_debug & DEBUG_MESH )
		bu_log( "nmg_split_linear_trim: new segments (%g %g %g) <-> (%g %g %g) <-> (%g %g %g)\n",
			V3ARGS( pt0->xyz ), V3ARGS( pt_new->xyz ), V3ARGS( pt1->xyz ) );
#endif

	VSUB2( seg, pt0->xyz, pt_new->xyz );
	if( MAGSQ( seg ) > tol->dist_sq )
	{
		t_sub = (pt0->t + pt_new->t)/2.0;
		VBLEND2( uvw_sub, 1.0 - t_sub, uvw1, t_sub, uvw2 );
#if 0
		if( rt_g.NMG_debug & DEBUG_MESH )
			bu_log( "nmg_split_linear_trim: recursing at t=%g (%g,%g)\n",
					t_sub, pt0->t, pt_new->t );
#endif
		nmg_split_linear_trim( snrb, uvw1, uvw_sub, uvw2, pt0, pt_new, tol );
	}

	VSUB2( seg, pt_new->xyz, pt1->xyz );
	if( MAGSQ( seg ) > tol->dist_sq )
	{
		t_sub = (pt_new->t + pt1->t)/2.0;
		VBLEND2( uvw_sub, 1.0 - t_sub, uvw1, t_sub, uvw2 );
#if 0
		if( rt_g.NMG_debug & DEBUG_MESH )
			bu_log( "nmg_split_linear_trim: recursing at t=%g (%g,%g)\n",
					t_sub, pt_new->t, pt1->t );
#endif
		nmg_split_linear_trim( snrb, uvw1, uvw_sub, uvw2, pt0, pt_new, tol );
	}
#if 0
	if( rt_g.NMG_debug & DEBUG_MESH )
		bu_log( "nmg_split_linear_trim( snrb=x%x, pt0=x%x, pt1=x%x ) END\n",
			snrb, pt0, pt1 );
#endif

}

void
nmg_eval_linear_trim_to_tol(const struct edge_g_cnurb *cnrb, const struct face_g_snurb *snrb, const fastf_t *uvw1, const fastf_t *uvw2, struct bu_list *head, const struct bn_tol *tol)
{
	fastf_t uvw[3];
	struct pt_list *pt0,*pt1;

	NMG_CK_EDGE_G_CNURB( cnrb );
	NMG_CK_FACE_G_SNURB( snrb );
	BN_CK_TOL( tol );

	NMG_CK_EDGE_G_CNURB( cnrb );
	NMG_CK_FACE_G_SNURB( snrb );
	BN_CK_TOL( tol );

	if( rt_g.NMG_debug & DEBUG_MESH )
		bu_log( "nmg_eval_linear_trim_to_tol( cnrb=x%x, snrb=x%x, uvw1=( %g %g %g), uvw2=( %g %g %g ) ) START\n",
				cnrb, snrb, V3ARGS( uvw1 ), V3ARGS( uvw2 ) );

	pt0 = (struct pt_list *)bu_malloc( sizeof( struct pt_list ), "nmg_eval_linear_trim_to_tol: pt0 " );
	pt0->t = 0.0;
	nmg_eval_linear_trim_curve( snrb, uvw1, pt0->xyz );
	BU_LIST_INSERT( head, &pt0->l );

	pt1 = (struct pt_list *)bu_malloc( sizeof( struct pt_list ), "nmg_eval_linear_trim_to_tol: pt1 " );
	pt1->t = 1.0;
	nmg_eval_linear_trim_curve( snrb, uvw2, pt1->xyz );
	BU_LIST_INSERT( head, &pt1->l );


	VBLEND2( uvw, 0.5, uvw1, 0.5, uvw2 )
	nmg_split_linear_trim( snrb, uvw1, uvw, uvw2, pt0, pt1, tol );

	if( rt_g.NMG_debug & DEBUG_MESH )
		bu_log( "nmg_eval_linear_trim_to_tol( cnrb=x%x, snrb=x%x ) END\n",
				cnrb, snrb );
}

/* check for coincidence at twenty interior points along a cnurb */
#define		CHECK_NUMBER	20

/*		N M G _ C N U R B _ L S E G _ C O I N C I D E N T
 *
 *	Checks if CNURB is coincident with line segment from pt1 to pt2
 *	by calculating a number of points along the CNURB and checking
 *	if they lie on the line between pt1 and pt2 (within tolerance).
 *		NOTE: eu1 must be the EU referencing cnrb!!!!
 *
 *	Returns:
 *		0 - not coincident
 *		1 - coincident
 */
int
nmg_cnurb_lseg_coincident(const struct edgeuse *eu1, const struct edge_g_cnurb *cnrb, const struct face_g_snurb *snrb, const fastf_t *pt1, const fastf_t *pt2, const struct bn_tol *tol)
{
	fastf_t t0,t1,t;
	fastf_t delt;
	int coincident=0;
	int i;


	NMG_CK_EDGEUSE( eu1 );
	NMG_CK_EDGE_G_CNURB( cnrb );

	if( rt_g.NMG_debug & DEBUG_MESH )
		bu_log( "nmg_cnurb_lseg_coincident( eu1=x%x, cnrb=x%x, snrb=x%x, pt1=(%g %g %g), pt2=(%g %g %g)\n",
			eu1, cnrb, snrb, V3ARGS( pt1 ), V3ARGS( pt2 ) );

	if( eu1->g.cnurb_p != cnrb )
	{
		bu_log( "nmg_cnurb_lseg_coincident: cnrb x%x isn't from eu x%x\n",
			cnrb, eu1 );
		rt_bomb( "nmg_cnurb_lseg_coincident: cnrb and eu1 disagree\n" );
	}

	if( snrb )
		NMG_CK_FACE_G_SNURB( snrb );

	BN_CK_TOL( tol );

	if( cnrb->order <= 0 )
	{
		/* cnrb is linear in parameter space */
		struct vertexuse *vu1;
		struct vertexuse *vu2;
		struct vertexuse_a_cnurb *vua1;
		struct vertexuse_a_cnurb *vua2;

		if( !snrb )
			rt_bomb( "nmg_cnurb_lseg_coincident: No CNURB nor SNURB!!\n" );

		vu1 = eu1->vu_p;
		NMG_CK_VERTEXUSE( vu1 );
		if( !vu1->a.magic_p )
		{
			bu_log( "nmg_cnurb_lseg_coincident: vu (x%x) has no attributes\n",
				vu1 );
			rt_bomb( "nmg_cnurb_lseg_coincident: vu has no attributes\n" );
		}

		if( *vu1->a.magic_p != NMG_VERTEXUSE_A_CNURB_MAGIC )
		{
			bu_log( "nmg_cnurb_lseg_coincident: vu (x%x) from CNURB EU (x%x) is not CNURB\n", 
				vu1, eu1 );
			rt_bomb( "nmg_cnurb_lseg_coincident: vu from CNURB EU is not CNURB\n" );
		}

		vua1 = vu1->a.cnurb_p;
		NMG_CK_VERTEXUSE_A_CNURB( vua1 );

		vu2 = eu1->eumate_p->vu_p;
		NMG_CK_VERTEXUSE( vu2 );
		if( !vu2->a.magic_p )
		{
			bu_log( "nmg_cnurb_lseg_coincident: vu (x%x) has no attributes\n",
				vu2 );
			rt_bomb( "nmg_cnurb_lseg_coincident: vu has no attributes\n" );
		}

		if( *vu2->a.magic_p != NMG_VERTEXUSE_A_CNURB_MAGIC )
		{
			bu_log( "nmg_cnurb_lseg_coincident: vu (x%x) from CNURB EU (x%x) is not CNURB\n", 
				vu2, eu1 );
			rt_bomb( "nmg_cnurb_lseg_coincident: vu from CNURB EU is not CNURB\n" );
		}

		vua2 = vu2->a.cnurb_p;
		NMG_CK_VERTEXUSE_A_CNURB( vua2 );

		coincident = 1;
		for( i=0 ; i<CHECK_NUMBER ; i++ )
		{
			point_t uvw;
			point_t xyz;
			fastf_t blend;
			fastf_t dist;
			point_t pca;

			blend = (double)(i+1)/(double)(CHECK_NUMBER+1);
			VBLEND2( uvw, blend, vua1->param, (1.0-blend), vua2->param );

			nmg_eval_linear_trim_curve( snrb, uvw, xyz );

			if( bn_dist_pt3_lseg3( &dist, pca, pt1, pt2, xyz, tol ) > 2 )
			{
				coincident = 0;
				break;
			}
		}
		if( rt_g.NMG_debug & DEBUG_MESH )
			bu_log( "nmg_cnurb_lseg_coincident returning %d\n", coincident );
		return( coincident );
	}

	t0 = cnrb->k.knots[0];
	t1 = cnrb->k.knots[cnrb->k.k_size-1];
	delt = (t1 - t0)/(double)(CHECK_NUMBER+1);

	coincident = 1;
	for( i=0 ; i<CHECK_NUMBER ; i++ )
	{
		point_t xyz;
		fastf_t dist;
		point_t pca;

		t = t0 + (double)(i+1)*delt;

		nmg_eval_trim_curve( cnrb, snrb, t, xyz );

		if( bn_dist_pt3_lseg3( &dist, pca, pt1, pt2, xyz, tol ) > 2 )
		{
			coincident = 0;
			break;
		}
	}
	if( rt_g.NMG_debug & DEBUG_MESH )
		bu_log( "nmg_cnurb_lseg_coincident returning %d\n", coincident );
	return( coincident );
}

/*		N M G _ C N U R B _ I S _ O N _ C R V
 *
 *	Checks if CNURB eu lies on curve contained in list headed at "head"
 *	"Head" must contain a list of points (struct pt_list) each within
 *	tolerance of the next. (Just checks at "CHECK_NUMBER" points for now).
 *
 *	Returns:
 *		 0 - cnurb is not on curve;
 *		 1 - cnurb is on curve
 */
int
nmg_cnurb_is_on_crv(const struct edgeuse *eu, const struct edge_g_cnurb *cnrb, const struct face_g_snurb *snrb, const struct bu_list *head, const struct bn_tol *tol)
{
	int i;
	int coincident;
	fastf_t t, t0, t1;
	fastf_t delt;

	NMG_CK_EDGEUSE( eu );
	NMG_CK_EDGE_G_CNURB( cnrb );
	if( snrb )
		NMG_CK_FACE_G_SNURB( snrb );
	BU_CK_LIST_HEAD( head );
	BN_CK_TOL( tol );

	if( rt_g.NMG_debug & DEBUG_MESH )
		bu_log( "nmg_cnurb_is_on_crv( eu=x%x, cnrb=x%x, snrb=x%x, head=x%x )\n",
			eu, cnrb, snrb, head );
	if( cnrb->order <= 0 )
	{
		struct vertexuse *vu1,*vu2;
		struct vertexuse_a_cnurb *vu1a,*vu2a;
		fastf_t blend;
		point_t uvw;
		point_t xyz;

		/* cnurb is linear in parameter space */

		vu1 = eu->vu_p;
		NMG_CK_VERTEXUSE( vu1 );
		vu2 = eu->eumate_p->vu_p;
		NMG_CK_VERTEXUSE( vu2 );

		if( !vu1->a.magic_p )
		{
			bu_log( "nmg_cnurb_is_on_crv(): vu (x%x) on CNURB EU (x%x) has no attributes\n",
				vu1, eu );
			rt_bomb( "nmg_cnurb_is_on_crv(): vu on CNURB EU has no attributes\n" );
		}
		if( *vu1->a.magic_p != NMG_VERTEXUSE_A_CNURB_MAGIC )
		{
			bu_log( "nmg_cnurb_is_on_crv(): vu (x%x) on CNURB EU (x%x) is not CNURB\n",
				vu1, eu );
			rt_bomb( "nmg_cnurb_is_on_crv(): vu on CNURB EU is not CNURB\n" );
		}
		vu1a = vu1->a.cnurb_p;
		NMG_CK_VERTEXUSE_A_CNURB( vu1a );

		if( !vu2->a.magic_p )
		{
			bu_log( "nmg_cnurb_is_on_crv(): vu (x%x) on CNURB EU (x%x) has no attributes\n",
				vu2, eu->eumate_p );
			rt_bomb( "nmg_cnurb_is_on_crv(): vu on CNURB EU has no attributes\n" );
		}
		if( *vu2->a.magic_p != NMG_VERTEXUSE_A_CNURB_MAGIC )
		{
			bu_log( "nmg_cnurb_is_on_crv(): vu (x%x) on CNURB EU (x%x) is not CNURB\n",
				vu2, eu->eumate_p );
			rt_bomb( "nmg_cnurb_is_on_crv(): vu on CNURB EU is not CNURB\n" );
		}
		vu2a = vu2->a.cnurb_p;
		NMG_CK_VERTEXUSE_A_CNURB( vu2a );

		coincident = 1;
		for( i=0 ; i<CHECK_NUMBER ; i++ )
		{
			struct pt_list *pt;
			int found=0;

			blend = (double)(i+1)/(double)(CHECK_NUMBER+1);

			VBLEND2( uvw, blend, vu1a->param, (1.0-blend), vu2a->param );

			nmg_eval_linear_trim_curve( snrb, uvw, xyz );

			for( BU_LIST_FOR( pt, pt_list, head ) )
			{
				vect_t diff;

				VSUB2( diff, xyz, pt->xyz );
				if( MAGSQ( diff ) <= tol->dist_sq )
				{
					found = 1;
					break;
				}
			}
			if( !found )
			{
				coincident = 0;
				break;
			}
		}
		if( rt_g.NMG_debug & DEBUG_MESH )
			bu_log( "nmg_cnurb_is_on_crv() returning %d\n", coincident );
		return( coincident );
	}

	coincident = 1;
	t0 = cnrb->k.knots[0];
	t1 = cnrb->k.knots[cnrb->k.k_size-1];
	delt = (t1 - t0)/(double)(CHECK_NUMBER+1);
	for( i=0 ; i<CHECK_NUMBER ; i++ )
	{
		point_t xyz;
		struct pt_list *pt;
		int found;

		t = t0 + (double)(i+1)*delt;

		nmg_eval_trim_curve( cnrb, snrb, t, xyz );

		found = 0;
		for( BU_LIST_FOR( pt, pt_list, head ) )
		{
			vect_t diff;

			VSUB2( diff, xyz, pt->xyz );
			if( MAGSQ( diff ) <= tol->dist_sq )
			{
				found = 1;
				break;
			}
		}
		if( !found )
		{
			coincident = 0;
			break;
		}
	}

	if( rt_g.NMG_debug & DEBUG_MESH )
		bu_log( "nmg_cnurb_is_on_crv returning %d\n", coincident );
	return( coincident );
}

/*
 *			N M G _ M O D E L _ E D G E _ F U S E
 */
#if 0
int
nmg_model_edge_fuse( m, tol )
struct model		*m;
const struct bn_tol	*tol;
{
	struct bu_ptbl	eutab;
	int		total = 0;
	int		non_lseg=0;
	register int	i,j;

	NMG_CK_MODEL(m);
	BN_CK_TOL(tol);

	/* Make a list of all the edgeuse structs in the model */
again:
	total = 0;
	nmg_edgeuse_tabulate( &eutab, &m->magic );

	for( i = BU_PTBL_END(&eutab)-1; i >= 0; i-- )  {
		struct edgeuse		*eu1;
		struct edge		*e1;
		register struct vertex	*v1a, *v1b;
		int			lseg1=0;
		int lseg2;

		eu1 = (struct edgeuse *)BU_PTBL_GET(&eutab, i);
		NMG_CK_EDGEUSE(eu1);
		e1 = eu1->e_p;
		NMG_CK_EDGE(e1);
		NMG_CK_EDGE_G_EITHER(eu1->g.magic_p);

		v1a = eu1->vu_p->v_p;
		v1b = eu1->eumate_p->vu_p->v_p;
		NMG_CK_VERTEX(v1a);
		NMG_CK_VERTEX(v1b);

		if( v1a == v1b )  {
			if( *eu1->g.magic_p == NMG_EDGE_G_LSEG_MAGIC )  {
				/* 0-length lseg edge.  Eliminate. */
				/* These should't happen, but need fixing. */
				if( nmg_keu( eu1 ) )  {
					bu_log("nmg_model_edge_fuse() WARNING:  deletion of 0-length edgeuse=x%x caused parent to go empty.\n", eu1);
				}
				bu_log("nmg_model_edge_fuse() 0-length edgeuse=x%x deleted\n", eu1);
				/* XXX no way to know where edgeuse mate will be */
				bu_ptbl_free( &eutab);
				goto again;
			}
			/* For g_cnurb edges, could check for distinct param values on either end of edge */
		}

		if( !eu1->g.magic_p )
		{
			bu_log( "nmg_model_edge_fuse() WARNING: eu (x%x) has no geometry\n" , eu1 );
			continue;
		}

		/* Check if eu1 is a line segment */
		if( *eu1->g.magic_p == NMG_EDGE_G_LSEG_MAGIC )
			lseg1 = 1;
		else if( *eu1->g.magic_p == NMG_EDGE_G_CNURB_MAGIC )
		{
			non_lseg++;
			continue;
		}
		else

		{
			bu_log( "nmg_model_edge_fuse() WARNING: eu (x%x) has unknown geometry\n" , eu1 );
			continue;
		}

		/* For performance, don't recheck pointers here */
		for( j = i-1; j >= 0; j-- )  {
			register struct edgeuse	*eu2;
			register struct vertex	*v2a, *v2b;
			int eus_are_coincident=0;


			eu2 = (struct edgeuse *)BU_PTBL_GET(&eutab,j);

			if( rt_g.NMG_debug & DEBUG_MESH )
				bu_log( "nmg_mode_edge_fuse: checking eus x%x and x%x\n", eu1, eu2 );

			/* Do this vertex test first, to reduce memory loads */
			v2a = eu2->vu_p->v_p;
			if( v2a != v1a && v2a != v1b )  continue;

			if( e1 == eu2->e_p )  continue;	/* Already shared */

			v2b = eu2->eumate_p->vu_p->v_p;
			if( (v2a != v1a || v2b != v1b) &&
			    (v2b != v1a || v2a != v1b) )
				continue;

			if( !eu2->g.magic_p )
			{
				bu_log( "nmg_model_edge_fuse() WARNING: eu (x%x) has no geometry\n" , eu2 );
				continue;
			}

			/* check if eu2 is a line segment */
			lseg2 = 0;
			if( *eu2->g.magic_p == NMG_EDGE_G_LSEG_MAGIC )
				lseg2 = 1;
			else if( *eu2->g.magic_p == NMG_EDGE_G_CNURB_MAGIC )
				continue;
			else
			{
				bu_log( "nmg_model_edge_fuse() WARNING: eu (x%x) has unknown geometry\n" , eu2 );
				continue;
			}

			/* EU's share endpoints */
			if( lseg1 && lseg2 )
			{
				/* both are line segments */
				nmg_radial_join_eu(eu1, eu2, tol);
			     	total++;
			}
		}

	}
	if( rt_g.NMG_debug & DEBUG_BASIC && total > 0 )
		bu_log("nmg_model_edge_fuse(): %d edges fused\n", total);
	bu_ptbl_free( &eutab);

	if( non_lseg )
		bu_log( "Warning: CNURB edges not fused!!!\n" );

	return total;
}
#else
int
nmg_model_edge_fuse(struct model *m, const struct bn_tol *tol)
{
	struct bu_ptbl edges;
	int i, j;
	int count=0;

	NMG_CK_MODEL( m );
	BN_CK_TOL( tol );

	nmg_edge_tabulate( &edges, &m->magic );

	for( i=0 ; i<BU_PTBL_END( &edges )-1 ; i++ )
	{
		struct edge *e1;
		struct edgeuse *eu1;

		e1 = (struct edge *)BU_PTBL_GET( &edges, i );
		if(!e1 || !e1->index || e1->magic != NMG_EDGE_MAGIC )
			continue;
		eu1 = e1->eu_p;
		if( !eu1 )
			continue;
		if( *eu1->g.magic_p != NMG_EDGE_G_LSEG_MAGIC )
			continue;

		for( j=i+1 ; j<BU_PTBL_END( &edges ) ; j++ )
		{
			struct edge *e2;
			struct edgeuse *eu2;

			e2 = (struct edge *)BU_PTBL_GET( &edges, j );
			if( !e2 || !e2->index || e2->magic != NMG_EDGE_MAGIC )
				continue;
			eu2 = e2->eu_p;
			if( !eu2 )
				continue;
			if( *eu2->g.magic_p != NMG_EDGE_G_LSEG_MAGIC )
				continue;

			if( NMG_ARE_EUS_ADJACENT( eu1, eu2 ) )
			{
				count++;
				nmg_radial_join_eu(eu1, eu2, tol);
				if(!e2->magic)
					bu_ptbl_zero( &edges, (long *)e2 );
			}
		}
	}

	bu_ptbl_free( &edges );

	return( count );
}
#endif


/*
 *			N M G _ M O D E L _ E D G E _ G _ F U S E
 *
 *  The present algorithm is a consequence of the old edge geom ptr structure.
 *  XXX This might be better formulated by generating a list of all
 *  edge_g structs in the model, and comparing *them* pairwise.
 */
int
nmg_model_edge_g_fuse(struct model *m, const struct bn_tol *tol)
{
	struct bu_ptbl	etab;
	int		total = 0;
	register int	i,j;

	NMG_CK_MODEL(m);
	BN_CK_TOL(tol);

	/* Make a list of all the edge geometry structs in the model */
	nmg_edge_g_tabulate( &etab, &m->magic );

	for( i = BU_PTBL_END(&etab)-1; i >= 0; i-- )  {
		struct edge_g_lseg		*eg1;
		struct edgeuse			*eu1;

		eg1 = (struct edge_g_lseg *)BU_PTBL_GET(&etab, i);
		NMG_CK_EDGE_G_EITHER(eg1);

		/* XXX Need routine to compare two cnurbs geometricly */
		if( eg1->l.magic == NMG_EDGE_G_CNURB_MAGIC )  {
			continue;
		}

		NMG_CK_EDGE_G_LSEG(eg1);
		eu1 = BU_LIST_MAIN_PTR( edgeuse, BU_LIST_FIRST( bu_list, &eg1->eu_hd2 ), l2 );
		NMG_CK_EDGEUSE(eu1);

		for( j = i-1; j >= 0; j-- )  {
			struct edge_g_lseg	*eg2;
			struct edgeuse		*eu2;

			eg2 = (struct edge_g_lseg *)BU_PTBL_GET(&etab,j);
			NMG_CK_EDGE_G_EITHER(eg2);
			if( eg2->l.magic == NMG_EDGE_G_CNURB_MAGIC )  continue;
			NMG_CK_EDGE_G_LSEG(eg2);
			eu2 = BU_LIST_MAIN_PTR( edgeuse, BU_LIST_FIRST( bu_list, &eg2->eu_hd2 ), l2 );
			NMG_CK_EDGEUSE(eu2);

			if( eg1 == eg2 )  rt_bomb("nmg_model_edge_g_fuse() edge_g listed twice in ptbl?\n");

			if( !nmg_2edgeuse_g_coincident( eu1, eu2, tol ) )  continue;

			/* Comitted to fusing two edge_g_lseg's.
			 * Make all instances of eg1 become eg2.
			 * XXX really should check ALL edges using eg1
			 * XXX against ALL edges using eg2 for coincidence.
			 */
		     	total++;
			nmg_jeg( eg2, eg1 );
			BU_PTBL_GET(&etab,i) = (long *)NULL;
			break;
		}
	}
	bu_ptbl_free( &etab);
	if( rt_g.NMG_debug & DEBUG_BASIC && total > 0 )
		bu_log("nmg_model_edge_g_fuse(): %d edge_g_lseg's fused\n", total);
	return total;
}

#define TOL_MULTIPLES	1.0
/*
 *			N M G _ C K _ F U _ V E R T S
 *
 *  Check that all the vertices in fu1 are within tol->dist of fu2's surface.
 *  fu1 and fu2 may be the same face, or different.
 *
 *  This is intended to be a geometric check only, not a topology check.
 *  Topology may have become inappropriately shared.
 *
 *  Returns -
 *	0	All is well, or all verts are within TOL_MULTIPLES*tol->dist of fu2
 *	count	Number of verts *not* on fu2's surface when at least one is
 *		more than TOL_MULTIPLES*tol->dist from fu2.
 *
 *  XXX It would be more efficient to use nmg_vist() for this.
 */
int
nmg_ck_fu_verts(struct faceuse *fu1, struct face *f2, const struct bn_tol *tol)
{
	const struct face_g_plane	*fg2;
	struct bu_ptbl		vtab;
	FAST fastf_t		dist;
	fastf_t			worst = 0;
	int			k;
	int			count = 0;

	NMG_CK_FACEUSE( fu1 );
	NMG_CK_FACE( f2 );
	BN_CK_TOL(tol);

	fg2 = f2->g.plane_p;
	NMG_CK_FACE_G_PLANE(fg2);

	nmg_vertex_tabulate( &vtab, &fu1->l.magic );

	for( k = BU_PTBL_END(&vtab)-1; k >= 0; k-- )  {
		register struct vertex		*v;
		register struct vertex_g	*vg;

		v = (struct vertex *)BU_PTBL_GET(&vtab, k);
		NMG_CK_VERTEX(v);
		vg = v->vg_p;
		if( !vg )  rt_bomb("nmg_ck_fu_verts(): vertex with no geometry?\n");
		NMG_CK_VERTEX_G(vg);

		/* Geometry check */
		dist = DIST_PT_PLANE(vg->coord, fg2->N);
		if( dist > tol->dist || dist < (-tol->dist) )  {
			if (rt_g.NMG_debug & DEBUG_MESH)  {
				bu_log("nmg_ck_fu_verts(x%x, x%x) v x%x off face by %e\n",
					fu1, f2,
					v, dist );
				VPRINT(" pt", vg->coord);
				PLPRINT(" fg2", fg2->N);
			}
			count++;
			if( dist < 0.0 )
				dist = (-dist);
			if( dist > worst )  worst = dist;
		}
	}
	bu_ptbl_free( &vtab);

	if ( count && (rt_g.NMG_debug & DEBUG_BASIC))  {
		bu_log("nmg_ck_fu_verts(fu1=x%x, f2=x%x, tol=%g) f1=x%x, ret=%d, worst=%gmm (%e)\n",
			fu1, f2, tol->dist, fu1->f_p,
			count, worst, worst );
	}

	if( worst > TOL_MULTIPLES*tol->dist )
		return count;
	else
		return( 0 );
}

/*			N M G _ C K _ F G _ V E R T S
 *
 * Similar to nmg_ck_fu_verts, but checks all vertices that use the same
 * face geometry as fu1
 *  fu1 and f2 may be the same face, or different.
 *
 *  This is intended to be a geometric check only, not a topology check.
 *  Topology may have become inappropriately shared.
 *
 *  Returns -
 *	0	All is well.
 *	count	Number of verts *not* on fu2's surface.
 *
 */
int
nmg_ck_fg_verts(struct faceuse *fu1, struct face *f2, const struct bn_tol *tol)
{
	struct face_g_plane *fg1;
	struct faceuse *fu;
	struct face *f;
	int count=0;

	NMG_CK_FACEUSE( fu1 );
	NMG_CK_FACE( f2 );
	BN_CK_TOL( tol );

	NMG_CK_FACE( fu1->f_p );
	fg1 = fu1->f_p->g.plane_p;
	NMG_CK_FACE_G_PLANE( fg1 );

	for( BU_LIST_FOR( f , face , &fg1->f_hd ) )
	{
		NMG_CK_FACE( f );

		fu = f->fu_p;
		NMG_CK_FACEUSE( fu );

		count += nmg_ck_fu_verts( fu , f2 , tol );
	}

	return( count );
}

/*
 *			N M G _ T W O _ F A C E _ F U S E
 *
 *  XXX A better algorithm would be to compare loop by loop.
 *  If the two faces share all the verts of at least one loop of 3 or more
 *  vertices, then they should be shared.  Otherwise it will be awkward
 *  having shared loop(s) on non-shared faces!!
 *
 *  Compare the geometry of two faces, and fuse them if they are the
 *  same within tolerance.
 *  First compare the plane equations.  If they are "similar" (within tol),
 *  then check all verts in f2 to make sure that they are within tol->dist
 *  of f1's geometry.  If they are, then fuse the face geometry.
 *
 *  Returns -
 *	0	Faces were not fused.
 *	>0	Faces were successfully fused.
 */
int
nmg_two_face_fuse(struct face *f1, struct face *f2, const struct bn_tol *tol)
{
	register struct face_g_plane	*fg1;
	register struct face_g_plane	*fg2;
	int			flip2 = 0;

	NMG_CK_FACE(f1);
	NMG_CK_FACE(f2);
	BN_CK_TOL(tol);

	fg1 = f1->g.plane_p;
	fg2 = f2->g.plane_p;

	if( !fg1 || !fg2 )  {
		if (rt_g.NMG_debug & DEBUG_MESH)  {
			bu_log("nmg_two_face_fuse(x%x, x%x) null fg fg1=x%x, fg2=x%x\n",
				f1, f2, fg1, fg2);
		}
		return 0;
	}

	NMG_CK_FACE_G_PLANE(fg1);
	NMG_CK_FACE_G_PLANE(fg2);

	if( fg1 == fg2 )  {
		if (rt_g.NMG_debug & DEBUG_MESH)  {
			bu_log("nmg_two_face_fuse(x%x, x%x) fg already shared\n",
				f1, f2);
		}
		return 0;	/* Already shared */
	}
#ifdef TOPOLOGY_CHECK
	/*
	 *  First, a topology check.
	 *  If the two faces share one entire loop (of at least 3 verts)
	 *  according to topology, then by all rights the faces MUST be
	 *  shared.
	 */

	if( fabs(VDOT(fg1->N, fg2->N)) >= 0.99  &&
	    fabs(fg1->N[3]) - fabs(fg2->N[3]) < 100 * tol->dist  &&
	    nmg_is_common_bigloop( f1, f2 ) )  {
		if( VDOT( fg1->N, fg2->N ) < 0 )  flip2 = 1;
		if (rt_g.NMG_debug & DEBUG_MESH)  {
			bu_log("nmg_two_face_fuse(x%x, x%x) faces have a common loop, they MUST be fused.  flip2=%d\n",
				f1, f2, flip2);
		}
		goto must_fuse;
	}

	/* See if faces are coplanar */
	code = bn_coplanar( fg1->N, fg2->N, tol );
	if( code <= 0 )  {
		if (rt_g.NMG_debug & DEBUG_MESH)  {
			bu_log("nmg_two_face_fuse(x%x, x%x) faces non-coplanar\n",
				f1, f2);
		}
		return 0;
	}
	if( code == 1 )
		flip2 = 0;
	else
		flip2 = 1;

	if (rt_g.NMG_debug & DEBUG_MESH)  {
		bu_log("nmg_two_face_fuse(x%x, x%x) coplanar faces, bn_coplanar code=%d, flip2=%d\n",
			f1, f2, code, flip2);
	}
#else
	if( VDOT( fg1->N, fg2->N ) > 0.0 )
		flip2 = 0;
	else
		flip2 = 1;

	if( nmg_ck_fg_verts( f1->fu_p, f2, tol ) != 0 )  {
		if (rt_g.NMG_debug & DEBUG_MESH)  {
			bu_log("nmg_two_face_fuse: f1 verts not within tol of f2's surface, can't fuse\n");
		}
		return 0;
	}
#endif

	/*
	 *  Plane equations match, within tol.
	 *  Before conducting a merge, verify that
	 *  all the verts in f2 are within tol->dist
	 *  of f1's surface.
	 */
	if( nmg_ck_fg_verts( f2->fu_p, f1, tol ) != 0 )  {
		if (rt_g.NMG_debug & DEBUG_MESH)  {
			bu_log("nmg_two_face_fuse: f2 verts not within tol of f1's surface, can't fuse\n");
		}
		return 0;
	}

#ifdef TOPPLOGY_CHECK
must_fuse:
#endif
	/* All points are on the plane, it's OK to fuse */
	if( flip2 == 0 )  {
		if (rt_g.NMG_debug & DEBUG_MESH)  {
			bu_log("joining face geometry (same dir) f1=x%x, f2=x%x\n", f1, f2);
			PLPRINT(" fg1", fg1->N);
			PLPRINT(" fg2", fg2->N);
		}
		nmg_jfg( f1, f2 );
	} else {
		register struct face	*fn;
		if (rt_g.NMG_debug & DEBUG_MESH)  {
			bu_log("joining face geometry (opposite dirs)\n");

			bu_log(" f1=x%x, flip=%d", f1, f1->flip);
			PLPRINT(" fg1", fg1->N);

			bu_log(" f2=x%x, flip=%d", f2, f2->flip);
			PLPRINT(" fg2", fg2->N);
		}
		/* Flip flags of faces using fg2, first! */
		for( BU_LIST_FOR( fn, face, &fg2->f_hd ) )  {
			NMG_CK_FACE(fn);
			fn->flip = !fn->flip;
			if (rt_g.NMG_debug & DEBUG_MESH)  {
				bu_log("f=x%x, new flip=%d\n", fn, fn->flip);
			}
		}
		nmg_jfg( f1, f2 );
	}
	return 1;
}

/*
 *			N M G _ M O D E L _ F A C E _ F U S E
 *
 *  A routine to find all face geometry structures in an nmg model that
 *  have the same plane equation, and have them share face geometry.
 *  (See also nmg_shell_coplanar_face_merge(), which actually moves
 *  the loops into one face).
 *
 *  The criteria for two face geometry structs being the "same" are:
 *	1) The plane equations must be the same, within tolerance.
 *	2) All the vertices on the 2nd face must lie within the
 *	   distance tolerance of the 1st face's plane equation.
 */
int
nmg_model_face_fuse(struct model *m, const struct bn_tol *tol)
{
	struct bu_ptbl	ftab;
	int		total = 0;
	register int	i,j;

	NMG_CK_MODEL(m);
	BN_CK_TOL(tol);

	/* Make a list of all the face structs in the model */
	nmg_face_tabulate( &ftab, &m->magic );

	for( i = BU_PTBL_END(&ftab)-1; i >= 0; i-- )  {
		register struct face	*f1;
		register struct face_g_plane	*fg1;
		f1 = (struct face *)BU_PTBL_GET(&ftab, i);
		NMG_CK_FACE(f1);
		NMG_CK_FACE_G_EITHER(f1->g.magic_p);

		if( *f1->g.magic_p == NMG_FACE_G_SNURB_MAGIC )  {
			/* XXX Need routine to compare 2 snurbs for equality here */
			continue;
		}

		fg1 = f1->g.plane_p;
		NMG_CK_FACE_G_PLANE(fg1);

		/* Check that all the verts of f1 are within tol of face */
		if( nmg_ck_fu_verts( f1->fu_p, f1, tol ) != 0 )  {
			if( rt_g.NMG_debug )  {
				PLPRINT(" f1", f1->g.plane_p->N);
				nmg_pr_fu_briefly(f1->fu_p, 0);
			}
			rt_bomb("nmg_model_face_fuse(): verts not within tol of containing face\n");
		}

		for( j = i-1; j >= 0; j-- )  {
			register struct face	*f2;
			register struct face_g_plane	*fg2;

			f2 = (struct face *)BU_PTBL_GET(&ftab, j);
			NMG_CK_FACE(f2);
			fg2 = f2->g.plane_p;
			if( !fg2 )  continue;
			NMG_CK_FACE_G_PLANE(fg2);

			if( fg1 == fg2 )  continue;	/* Already shared */

			if( nmg_two_face_fuse( f1, f2, tol ) > 0 )
				total++;
		}
	}
	bu_ptbl_free( &ftab);
	if( rt_g.NMG_debug & DEBUG_BASIC && total > 0 )
		bu_log("nmg_model_face_fuse: %d faces fused\n", total);
	return total;
}

int
nmg_break_all_es_on_v(long int *magic_p, struct vertex *v, const struct bn_tol *tol)
{
	struct bu_ptbl eus;
	int i;
	int count=0;
	const char *magic_type;

	if( rt_g.NMG_debug & DEBUG_BOOL )
		bu_log( "nmg_break_all_es_on_v( magic=x%x, v=x%x )\n", magic_p, v );

	NMG_CK_VERTEX( v );	
	BN_CK_TOL( tol );

	magic_type = bu_identify_magic( *magic_p );
	if ( !strcmp( magic_type, "NULL" ) || 
	     !strcmp( magic_type, "Unknown_Magic" )  )
	{
		bu_log( "Bad magic pointer passed to nmg_break_all_es_on_v (%s)\n", magic_type );
		rt_bomb( "Bad magic pointer passed to nmg_break_all_es_on_v()\n" );
	}

	nmg_edgeuse_tabulate( &eus, magic_p );

	for( i=0 ; i<BU_PTBL_END( &eus ) ; i++ )
	{
		struct edgeuse *eu;
		struct edgeuse *eu_next, *eu_prev;
		struct vertex *va;
		struct vertex *vb;
		fastf_t dist;
		int code;

		eu = (struct edgeuse *)BU_PTBL_GET( &eus, i );
		NMG_CK_EDGEUSE( eu );

		if( eu->g.magic_p && *eu->g.magic_p == NMG_EDGE_G_CNURB_MAGIC )
			continue;
		va = eu->vu_p->v_p;
		vb = eu->eumate_p->vu_p->v_p;
		NMG_CK_VERTEX(va);
		NMG_CK_VERTEX(vb);

		if( va == v ) continue;
		if( vb == v ) continue;

		eu_next = BU_LIST_PNEXT_CIRC( edgeuse, &eu->l );
		eu_prev = BU_LIST_PPREV_CIRC( edgeuse, &eu->l );

		if( eu_prev->vu_p->v_p == v )
			continue;

		if( eu_next->eumate_p->vu_p->v_p == v )
			continue;

		code = bn_isect_pt_lseg( &dist, va->vg_p->coord, vb->vg_p->coord,
			v->vg_p->coord, tol );
		if( code < 1 )  continue;	/* missed */
		if( code == 1 || code == 2 )  {
			bu_log("nmg_break_all_es_on_v() code=%d, why wasn't this vertex fused?\n", code);
			bu_log( "\teu=x%x, v=x%x\n", eu, v );
			continue;
		}
		/* Break edge on vertex, but don't fuse yet. */

		if( rt_g.NMG_debug & DEBUG_BOOL )
			bu_log( "\tnmg_break_all_es_on_v: breaking eu x%x on v x%x\n", eu, v );

		(void)nmg_ebreak( v, eu );
		count++;
	}
	bu_ptbl_free( &eus);
	return( count );
}

/*
 *			N M G _ M O D E L _ B R E A K _ E _ O N _ V
 *
 *  As the first step in evaluating a boolean formula,
 *  before starting to do face/face intersections, compare every
 *  edge in the model with every vertex in the model.
 *  If the vertex is within tolerance of the edge, break the edge,
 *  and enrole the new edge on a list of edges still to be processed.
 *
 *  A list of edges and a list of vertices are built, and then processed.
 *
 *  Space partitioning could improve the performance of this algorithm.
 *  For the moment, a brute-force approach is used.
 *
 *  Returns -
 *	Number of edges broken.
 */
int
nmg_model_break_e_on_v(struct model *m, const struct bn_tol *tol)
{
	int		count = 0;
	struct bu_ptbl	verts;
	struct bu_ptbl	edgeuses;
	struct bu_ptbl	new_edgeuses;
	register struct edgeuse	**eup;

	NMG_CK_MODEL(m);
	BN_CK_TOL(tol);

	nmg_e_and_v_tabulate( &edgeuses, &verts, &m->magic );

	/* Repeat the process until no new edgeuses are created */
	while( BU_PTBL_LEN( &edgeuses ) > 0 )  {
		(void)bu_ptbl_init( &new_edgeuses, 64, " &new_edgeuses");

		for( eup = (struct edgeuse **)BU_PTBL_LASTADDR(&edgeuses);
		     eup >= (struct edgeuse **)BU_PTBL_BASEADDR(&edgeuses);
		     eup--
		)  {
			register struct edgeuse	*eu;
			register struct vertex	*va;
			register struct vertex	*vb;
			register struct vertex	**vp;

			eu = *eup;
			NMG_CK_EDGEUSE(eu);
			if( eu->g.magic_p && *eu->g.magic_p == NMG_EDGE_G_CNURB_MAGIC )
				continue;
			va = eu->vu_p->v_p;
			vb = eu->eumate_p->vu_p->v_p;
			NMG_CK_VERTEX(va);
			NMG_CK_VERTEX(vb);
			for( vp = (struct vertex **)BU_PTBL_LASTADDR(&verts);
			     vp >= (struct vertex **)BU_PTBL_BASEADDR(&verts);
			     vp--
			)  {
				register struct vertex	*v;
				fastf_t			dist;
				int			code;
				struct edgeuse		*new_eu;

				v = *vp;
				NMG_CK_VERTEX(v);
				if( va == v )  continue;
				if( vb == v )  continue;

				/* A good candidate for inline expansion */
				code = bn_isect_pt_lseg( &dist,
					va->vg_p->coord,
					vb->vg_p->coord,
					v->vg_p->coord, tol );
				if( code < 1 )  continue;	/* missed */
				if( code == 1 || code == 2 )  {
					bu_log("nmg_model_break_e_on_v() code=%d, why wasn't this vertex fused?\n", code);
					continue;
				}

				if (rt_g.NMG_debug & (DEBUG_BOOL|DEBUG_BASIC) )
					bu_log( "nmg_model_break_e_on_v(): breaking eu x%x (e=x%x) at vertex x%x\n", eu,eu->e_p, v );

				/* Break edge on vertex, but don't fuse yet. */
				new_eu = nmg_ebreak( v, eu );
				/* Put new edges into follow-on list */
				bu_ptbl_ins( &new_edgeuses, &new_eu->l.magic );

				/* reset vertex vb */
				vb = eu->eumate_p->vu_p->v_p;
				count++;
			}
		}
		bu_ptbl_free( &edgeuses);
		edgeuses = new_edgeuses;		/* struct copy */
	}
	bu_ptbl_free( &edgeuses);
	bu_ptbl_free( &verts);
	if (rt_g.NMG_debug & (DEBUG_BOOL|DEBUG_BASIC) )
		bu_log("nmg_model_break_e_on_v() broke %d edges\n", count);
	return count;
}

/*
 *			N M G _ M O D E L _ F U S E
 *
 *  This is the primary application interface to the geometry fusing support.
 *  Fuse together all data structures that are equal to each other,
 *  within tolerance.
 *
 *  The algorithm is three part:
 *	1)  Fuse together all vertices.
 *	2)  Fuse together all face geometry, where appropriate.
 *	3)  Fuse together all edges.
 *
 *  Edge fusing is handled last, because the difficult part there is
 *  sorting faces radially around the edge.
 *  It is important to know whether faces are shared or not
 *  at that point.
 *
 *  XXX It would be more efficient to build all the ptbl's at once,
 *  XXX with a single traversal of the model.
 */
int
nmg_model_fuse(struct model *m, const struct bn_tol *tol)
{
	int	total = 0;

	NMG_CK_MODEL(m);
	BN_CK_TOL(tol);

	/* XXXX vertex fusing and edge breaking can produce vertices that are
	 * not within tolerance of their face. Edge breaking needs to be moved
	 * to step 1.5, then a routine to make sure all vertices are within
	 * tolerance of owning face must be called if "total" is greater than zero.
	 * This routine may have to triangulate the face if an appropriate plane
	 * cannot be calculated.
	 */

	/* Step 1 -- the vertices. */
	if( rt_g.NMG_debug & DEBUG_BASIC )
		bu_log( "nmg_model_fuse: vertices\n" );
	total += nmg_model_vertex_fuse( m, tol );

	/* Step 1.5 -- break edges on vertices, before fusing edges */
	if( rt_g.NMG_debug & DEBUG_BASIC )
		bu_log( "nmg_model_fuse: break edges\n" );
	total += nmg_model_break_e_on_v( m, tol );

	if( total )
	{
		struct nmgregion *r;
		struct shell *s;

		/* vertices and/or edges have been moved,
		 * may have created out-of-tolerance faces
		 */

		for( BU_LIST_FOR( r, nmgregion, &m->r_hd ) )
		{
			for( BU_LIST_FOR( s, shell, &r->s_hd ) )
				nmg_make_faces_within_tol( s, tol );
		}
	}

	/* Step 2 -- the face geometry */
	if( rt_g.NMG_debug & DEBUG_BASIC )
		bu_log( "nmg_model_fuse: faces\n" );
	total += nmg_model_face_fuse( m, tol );

	/* Step 3 -- edges */
	if( rt_g.NMG_debug & DEBUG_BASIC )
		bu_log( "nmg_model_fuse: edges\n" );
	total += nmg_model_edge_fuse( m, tol );

	/* Step 4 -- edge geometry */
	if( rt_g.NMG_debug & DEBUG_BASIC )
		bu_log( "nmg_model_fuse: edge geometries\n" );
	total += nmg_model_edge_g_fuse( m, tol );

	if( rt_g.NMG_debug & DEBUG_BASIC && total > 0 )
		bu_log("nmg_model_fuse(): %d entities fused\n", total);
	return total;
}


/* -------------------- RADIAL -------------------- */

/*
 *			N M G _ R A D I A L _ S O R T E D _ L I S T _ I N S E R T
 *
 *  Build sorted list, with 'ang' running from zero to 2*pi.
 *  New edgeuses with same angle as an edgeuse already on the list
 *  are added AFTER the last existing one, for lack of any better way
 *  to break the tie.
 */
void
nmg_radial_sorted_list_insert(struct bu_list *hd, struct nmg_radial *rad)
{
	struct nmg_radial	*cur;
	register fastf_t	rad_ang;

	BU_CK_LIST_HEAD(hd);
	NMG_CK_RADIAL(rad);

	if(BU_LIST_IS_EMPTY(hd))  {
		BU_LIST_APPEND( hd, &rad->l );
		return;
	}

	/* Put wires at the front */
	if( rad->fu == (struct faceuse *)NULL )  {
		/* Add before first element */
		BU_LIST_APPEND( hd, &rad->l );
		return;
	}

	rad_ang = rad->ang;

	/*  Check for trivial append at end of list.
	 *  This is a very common case, when input list is sorted.
	 */
	cur = BU_LIST_PREV(nmg_radial, hd);
	if( cur->fu && rad_ang >= cur->ang )  {
		BU_LIST_INSERT( hd, &rad->l );
		return;
	}

	/* Brute force search through hd's list, going backwards */
	for( BU_LIST_FOR_BACKWARDS( cur, nmg_radial, hd ) )  {
		if( cur->fu == (struct faceuse *)NULL )  continue;
		if( rad_ang >= cur->ang )  {
			BU_LIST_APPEND( &cur->l, &rad->l );
			return;
		}
	}

	/* Add before first element */
	BU_LIST_APPEND( hd, &rad->l );
}

/*
 *  Not only verity that list is monotone increasing, but that
 *  pointer integrity still exists.
 */
void
nmg_radial_verify_pointers(const struct bu_list *hd, const struct bn_tol *tol)
{
	register struct nmg_radial	*rad;
	register fastf_t		amin = -64;
	register struct nmg_radial	*prev;
	register struct nmg_radial	*next;

	BU_CK_LIST_HEAD(hd);
	BN_CK_TOL(tol);

	/* Verify pointers increasing */
	for( BU_LIST_FOR( rad, nmg_radial, hd ) )  {
		/* Verify pointer integrity */
		prev = BU_LIST_PPREV_CIRC(nmg_radial, rad);
		next = BU_LIST_PNEXT_CIRC(nmg_radial, rad);
		if( rad->eu != prev->eu->radial_p->eumate_p )
			rt_bomb("nmg_radial_verify_pointers() eu not radial+mate forw from prev\n");
		if( rad->eu->eumate_p != prev->eu->radial_p )
			rt_bomb("nmg_radial_verify_pointers() eumate not radial from prev\n");
		if( rad->eu != next->eu->eumate_p->radial_p )
			rt_bomb("nmg_radial_verify_pointers() eu not mate+radial back from next\n");
		if( rad->eu->eumate_p != next->eu->eumate_p->radial_p->eumate_p )
			rt_bomb("nmg_radial_verify_pointers() eumate not mate+radial+mate back from next\n");

		if( rad->fu == (struct faceuse *)NULL )  continue;
		if( rad->ang < amin )  {
			nmg_pr_radial_list( hd, tol );
			bu_log(" previous angle=%g > current=%g\n",
				amin*bn_radtodeg, rad->ang*bn_radtodeg);
			rt_bomb("nmg_radial_verify_pointers() not monotone increasing\n");
		}
		amin = rad->ang;
	}
}

/*
 *
 *  Verify that the angles are monotone increasing.
 *  Wire edgeuses are ignored.
 */
void
nmg_radial_verify_monotone(const struct bu_list *hd, const struct bn_tol *tol)
{
	register struct nmg_radial	*rad;
	register fastf_t		amin = -64;

	BU_CK_LIST_HEAD(hd);
	BN_CK_TOL(tol);

	/* Verify monotone increasing */
	for( BU_LIST_FOR( rad, nmg_radial, hd ) )  {
		if( rad->fu == (struct faceuse *)NULL )  continue;
		if( rad->ang < amin )  {
			nmg_pr_radial_list( hd, tol );
			bu_log(" previous angle=%g > current=%g\n",
				amin*bn_radtodeg, rad->ang*bn_radtodeg);
			rt_bomb("nmg_radial_verify_monotone() not monotone increasing\n");
		}
		amin = rad->ang;
	}
}

/*		N M G _ I N S U R E _ L I S T _ I S _ I N C R E A S I N G
 *
 *	Check if the passed bu_list is in increasing order. If not,
 *	reverse the order of the list.
 * XXX Isn't the word "ensure"?
 */
void
nmg_insure_radial_list_is_increasing(struct bu_list *hd, fastf_t amin, fastf_t amax)
{
	struct nmg_radial *rad;
	fastf_t cur_value=(-MAX_FASTF);
	int increasing=1;

	BU_CK_LIST_HEAD( hd );

	/* if we don't have more than 3 entries, it doesn't matter */

	if( bu_list_len( hd ) < 3 )
		return;

	for( BU_LIST_FOR( rad, nmg_radial, hd ) )
	{
		/* skip wire edges */
		if( rad->fu == (struct faceuse *)NULL )
			continue;

		/* if increasing, just keep checking */
		if( rad->ang >= cur_value )
		{
			cur_value = rad->ang;
			continue;
		}

		/* angle decreases, is it going from max to min?? */
		if( rad->ang == amin && cur_value == amax )
		{
			/* O.K., just went from max to min */
			cur_value = rad->ang;
			continue;
		}

		/* if we get here, this list is not increasing!!! */
		increasing = 0;
		break;
	}

	if( increasing )	/* all is well */
		return;

	/* reverse order of the list */
	bu_list_reverse( hd );

	/* Need to exchange eu with eu->eumate_p for each eu on the list */
	for( BU_LIST_FOR( rad, nmg_radial, hd ) )
	{
		rad->eu = rad->eu->eumate_p;
		rad->fu = nmg_find_fu_of_eu( rad->eu );
	}
}

/*
 *			N M G _ R A D I A L _ B U I L D _ L I S T
 *
 *  The coordinate system is expected to have been chosen in such a
 *  way that the radial list of faces around this edge are circularly
 *  increasing (CCW) in their angle.  Put them in the list in exactly
 *  the order they occur around the edge.  Then, at the end, move the
 *  list head to lie between the maximum and minimum angles, so that the
 *  list head is crossed as the angle goes around through zero.
 *  Now the list is monotone increasing.
 *
 *  The edgeuse's radial pointer takes us in the CCW direction.
 *
 *  If the list contains nmg_radial structures r1, r2, r3, r4,
 *  then going CCW around the edge we will encounter:
 *
 *			(from i-1)			(from i+1)
 *  r1->eu->eumate_p	r4->eu->radial_p		r2->eu->eumate_p->radial_p->eumate_p
 *  r1->eu		r4->eu->radial_p->eumate_p	r2->eu->eumate_p->radial_p
 *  r2->eu->eumate_p	r1->eu->radial_p		r3->eu->eumate_p->radial_p->eumate_p
 *  r2->eu		r1->eu->radial_p->eumate_p	r3->eu->eumate_p->radial_p
 *  r3->eu->eumate_p	r2->eu->radial_p		r4->eu->eumate_p->radial_p->eumate_p
 *  r3->eu		r2->eu->radial_p->eumate_p	r4->eu->eumate_p->radial_p
 *  r4->eu->eumate_p	r3->eu->radial_p		r1->eu->eumate_p->radial_p->eumate_p
 *  r4->eu		r3->eu->radial_p->eumate_p	r1->eu->eumate_p->radial_p
 */
void
nmg_radial_build_list(struct bu_list *hd, struct bu_ptbl *shell_tbl, int existing, struct edgeuse *eu, const fastf_t *xvec, const fastf_t *yvec, const fastf_t *zvec, const struct bn_tol *tol)
              		    
              		           	/* may be null */
   			         
              		    
            		     
            		     
            		     
                   	     		/* for printing */
{
	struct edgeuse		*teu;
	struct nmg_radial	*rad;
	fastf_t			amin;
	fastf_t			amax;
	int			non_wire_edges=0;
	struct nmg_radial	*rmin = (struct nmg_radial *)NULL;
	struct nmg_radial	*rmax = (struct nmg_radial *)NULL;
	struct nmg_radial	*first;

	BU_CK_LIST_HEAD(hd);
	if(shell_tbl) BU_CK_PTBL(shell_tbl);
	NMG_CK_EDGEUSE(eu);
	BN_CK_TOL(tol);

	if( rt_g.NMG_debug & DEBUG_BASIC || rt_g.NMG_debug & DEBUG_MESH_EU )
		bu_log("nmg_radial_build_list( existing=%d, eu=x%x )\n", existing, eu );

	amin = 64;
	amax = -64;

	teu = eu;
	for(;;)  {
		BU_GETSTRUCT( rad, nmg_radial );
		rad->l.magic = NMG_RADIAL_MAGIC;
		rad->eu = teu;
		rad->fu = nmg_find_fu_of_eu( teu );
		if( rad->fu )  {
			/* We depend on ang being strictly in the range 0..2pi */
			rad->ang = nmg_measure_fu_angle( teu, xvec, yvec, zvec );
			non_wire_edges++;

			if( rad->ang < amin )  {
				amin = rad->ang;
				rmin = rad;
			}
			if( rad->ang > amax )  {
				amax = rad->ang;
				rmax = rad;
			}
		} else {
			/* Wire edge.  Set a preposterous angle */
			rad->ang = -bn_pi;	/* -180 */
		}
		rad->s = nmg_find_s_of_eu( teu );
		rad->existing_flag = existing;
		rad->needs_flip = 0;	/* not yet determined */
		rad->is_crack = 0;	/* not yet determined */
		rad->is_outie = 0;	/* not yet determined */

		if( rt_g.NMG_debug & DEBUG_MESH_EU )
			bu_log( "\trad->eu = %x, rad->ang = %g\n", rad->eu, rad->ang );

		/* Just append.  Should already be properly sorted. */
		BU_LIST_INSERT( hd, &(rad->l) );

		/* Add to list of all shells involved at this edge */
		if(shell_tbl) bu_ptbl_ins_unique( shell_tbl, &(rad->s->l.magic) );

		/* Advance to next edgeuse pair */
		teu = teu->radial_p->eumate_p;
		if( teu == eu )  break;
	}

	nmg_insure_radial_list_is_increasing( hd, amin, amax );

	/* Increasing, with min or max value possibly repeated */
	if( !rmin )  {
		/* Nothing but wire edgeuses, done. */
		return;
	}

	/* At least one non-wire edgeuse was found */
	if( non_wire_edges < 2 )
	{
		/* only one non wire entry in list */
		return;
	}

	if( rt_g.NMG_debug & DEBUG_MESH_EU )
	{
		struct nmg_radial *next;

		bu_log("amin=%g min_eu=x%x, amax=%g max_eu=x%x\n",
		rmin->ang * bn_radtodeg, rmin->eu,
		rmax->ang * bn_radtodeg, rmax->eu );

		for( BU_LIST_FOR( next, nmg_radial, hd ) )
			bu_log( "%x: eu=%x, fu=%x, ang=%g\n" , next, next->eu, next->fu, next->ang );
	}

	/* Skip to extremal repeated max&min.  Ignore wires */
	first = rmax;
	for(;;)  {
		struct nmg_radial	*next;
		next = rmax;
		do {
			next = BU_LIST_PNEXT_CIRC(nmg_radial, next);
		} while( next->fu == (struct faceuse *)NULL );
		if( next->ang >= amax )
		{
			rmax = next;		/* a repeated max */
			if( rmax == first )	/* we have gone all the way around (All angles are same ) */
				break;
		}
		else
			break;
	}
	/* wires before min establish new rmin */
	first = rmin;
	for(;;)  {
		struct nmg_radial	*next;

		while( (next = BU_LIST_PPREV_CIRC(nmg_radial, rmin))->fu == (struct faceuse *)NULL )
			rmin = next;
		next = BU_LIST_PPREV_CIRC(nmg_radial, rmin);
		if( next->ang <= amin )
		{
			rmin = next;		/* a repeated min */
			if( rmin == first )	/* all the way round again (All angles are same ) */
			{
				/* set rmin to next entry after rmax */
				rmin = BU_LIST_PNEXT_CIRC( nmg_radial, rmax );
				break;
			}
		}
		else
			break;
	}

	/* Move list head so that it is inbetween min and max entries. */
	if( BU_LIST_PNEXT_CIRC(nmg_radial, rmax) == rmin )  {
		/* Maximum entry is followed by minimum.  Ascending --> CCW */
		BU_LIST_DEQUEUE( hd );
		/* Append head after maximum, before minimum */
		BU_LIST_APPEND( &(rmax->l), hd );
		nmg_radial_verify_pointers( hd, tol );
	} else {
		bu_log("  %f %f %f --- %f %f %f\n",
			V3ARGS(eu->vu_p->v_p->vg_p->coord),
			V3ARGS(eu->eumate_p->vu_p->v_p->vg_p->coord) );
		bu_log("amin=%g min_eu=x%x, amax=%g max_eu=x%x B\n",
			rmin->ang * bn_radtodeg, rmin->eu,
			rmax->ang * bn_radtodeg, rmax->eu );
		nmg_pr_radial_list( hd, tol );
		nmg_pr_fu_around_eu_vecs( eu, xvec, yvec, zvec, tol );
		rt_bomb("nmg_radial_build_list() min and max angle not adjacent in list (or list not monotone increasing)\n");
	}
}

/*
 *			N M G _ R A D I A L _ M E R G E _ L I S T S
 *
 *  Merge all of the src list into the dest list, sorting by angles.
 */
void
nmg_radial_merge_lists(struct bu_list *dest, struct bu_list *src, const struct bn_tol *tol)
{
	struct nmg_radial	*rad;

	BU_CK_LIST_HEAD(dest);
	BU_CK_LIST_HEAD(src);
	BN_CK_TOL(tol);

	while( BU_LIST_WHILE( rad, nmg_radial, src ) )  {
		BU_LIST_DEQUEUE( &rad->l );
		nmg_radial_sorted_list_insert( dest, rad );
	}
}

/*
 *			N M G _ I S _ C R A C K _ O U T I E
 *
 *  If there is more than one edgeuse of a loopuse along an edge, then
 *  it is a "topological crack".  There are two kinds, an "innie",
 *  where the crack is a null-area incursion into the interior of the loop,
 *  and an "outie", where the crack is a null-area protrusion outside
 *  of the interior of the loop.
 *
 *			 "Outie"		 "Innie"
 *			*-------*		*-------*
 *			|       ^		|       ^
 *			v       |		v       |
 *		*<------*       |		*--->*  |
 *		*---M-->*       |		*<-M-*  |
 *			|       |		|       |
 *			v       |		v       |
 *			*------>*		*------>*
 *
 *  The algorithm used is to compute the geometric midpoint of the crack
 *  edge, "delete" that edge from the loop, and then classify the midpoint
 *  ("M") against the remainder of the loop.  If the edge midpoint
 *  is inside the remains of the loop, then the crack is an "innie",
 *  otherwise it is an "outie".
 *
 *  When there are an odd number of edgeuses along the crack, then the
 *  situation is "nasty":
 *
 *			 "Nasty"
 *			*-------*
 *			|       ^
 *			v       |
 *		*<------*       |
 *		*------>*       |
 *		*<------*       |
 *		*------>*       |
 *		*<------*       |
 *		|		|
 *		|		|
 *		v		|
 *		*------------->*
 *
 *  The caller is responsible for making sure that the edgeuse is not
 *  a wire edgeuse (i.e. that the edgeuse is part of a loop).
 *
 *  In the "Nasty" case, all the edgeuse pairs are "outies" except for
 *  the last lone edgeuse, which should be handled as a "non-crack".
 *  Walk the loopuse's edgeuses list in edgeuse order to see which one
 *  is the last (non-crack) repeated edgeuse.
 *  For efficiency, detecting and dealing with this condition is left
 *  up to the caller, and is not checked for here.
 */
int
nmg_is_crack_outie(const struct edgeuse *eu, const struct bn_tol *tol)
{
	const struct loopuse	*lu;
	const struct edge	*e;
	point_t			midpt;
	const fastf_t		*a, *b;
	int			class;

	NMG_CK_EDGEUSE(eu);
	BN_CK_TOL(tol);

	lu = eu->up.lu_p;
	NMG_CK_LOOPUSE(lu);
	e = eu->e_p;
	NMG_CK_EDGE(e);

	/* If ENTIRE loop is a crack, there is no surface area, it's an outie */
	if( nmg_loop_is_a_crack( lu ) )  return 1;

	a = eu->vu_p->v_p->vg_p->coord;
	b = eu->eumate_p->vu_p->v_p->vg_p->coord;
	VADD2SCALE( midpt, a, b, 0.5 );

	/* Ensure edge is long enough so midpoint is not within tol of verts */
	{
#if 1
		/* all we want here is a classification of the midpoint,
		 * so let's create a temporary tolerance that will work!!! */

		struct bn_tol tmp_tol;
		struct faceuse		*fu;
		plane_t			pl;
		fastf_t			dist;

		tmp_tol = (*tol);
		if( *lu->up.magic_p != NMG_FACEUSE_MAGIC )
			rt_bomb( "Nmg_is_crack_outie called with non-face loop" );

		fu = lu->up.fu_p;
		NMG_CK_FACEUSE( fu );
		NMG_GET_FU_PLANE( pl, fu );
		dist = DIST_PT_PLANE( midpt, pl );
		VJOIN1( midpt, midpt , -dist, pl )
		dist = fabs( DIST_PT_PLANE( midpt, pl ) );
		if( dist > SQRT_SMALL_FASTF )
		{
			tmp_tol.dist = dist*2.0;
			tmp_tol.dist_sq = tmp_tol.dist * tmp_tol.dist;
		}
		else
		{
			tmp_tol.dist = SQRT_SMALL_FASTF;
			tmp_tol.dist_sq = SMALL_FASTF;
		}
		class = nmg_class_pt_lu_except( midpt, lu, e, &tmp_tol );
#else
		rt_pr_tol(tol);
		bu_log(" eu=x%x, len=%g\n", eu, MAGNITUDE(diff) );
		rt_bomb("nmg_is_crack_outie() edge is too short to bisect.  Increase tolerance and re-run.\n");
#endif
	}
	if( rt_g.NMG_debug & DEBUG_BASIC )  {
		bu_log("nmg_is_crack_outie(eu=x%x) lu=x%x, e=x%x, class=%s\n",
			eu, lu, e, nmg_class_name(class) );
	}

	if( lu->orientation == OT_SAME )  {
		if( class == NMG_CLASS_AinB || class == NMG_CLASS_AonBshared )
			return 0;		/* an "innie" */
		if( class == NMG_CLASS_AoutB )
			return 1;		/* an "outie" */
	} else {
		/* It's a hole loop, things work backwards. */
		if( class == NMG_CLASS_AinB || class == NMG_CLASS_AonBshared )
			return 1;		/* an "outie" */
		if( class == NMG_CLASS_AoutB )
			return 0;		/* an "innie" */
	}

	/* Other classifications "shouldn't happen". */
	bu_log("nmg_is_crack_outie(eu=x%x), lu=x%x(%s)\n  midpt_class=%s, midpt=(%g, %g, %g)\n",
		eu,
		lu, nmg_orientation(lu->orientation),
		nmg_class_name(class),
		V3ARGS(midpt) );
	nmg_pr_lu_briefly( lu, 0 );
	rt_bomb("nmg_is_crack_outie() got unexpected midpt classification from nmg_class_pt_lu_except()\n");

	return( -1 ); /* make the compiler happy */
}

/*
 *			N M G _ F I N D _ R A D I A L _ E U
 */
struct nmg_radial *
nmg_find_radial_eu(const struct bu_list *hd, const struct edgeuse *eu)
{
	register struct nmg_radial	*rad;

	BU_CK_LIST_HEAD(hd);
	NMG_CK_EDGEUSE(eu);

	for( BU_LIST_FOR( rad, nmg_radial, hd ) )  {
		if( rad->eu == eu )  return rad;
		if( rad->eu->eumate_p == eu )  return rad;
	}
	bu_log("nmg_find_radial_eu() eu=x%x\n", eu);
	rt_bomb("nmg_find_radial_eu() given edgeuse not found on list\n");

	return( (struct nmg_radial *)NULL );
}

/*
 *			N M G _ F I N D _ N E X T _ U S E _ O F _ 2 E _ I N _ L U
 *
 *  Find the next use of either of two edges in the loopuse.
 *  The second edge pointer may be NULL.
 */
const struct edgeuse *
nmg_find_next_use_of_2e_in_lu(const struct edgeuse *eu, const struct edge *e1, const struct edge *e2)
                    	    
                 	    
                 	    		/* may be NULL */
{
	register const struct edgeuse	*neu;

	NMG_CK_EDGEUSE(eu);
	NMG_CK_LOOPUSE(eu->up.lu_p);	/* sanity */
	NMG_CK_EDGE(e1);
	if(e2) NMG_CK_EDGE(e2);

	neu = eu;
	do  {
		neu = BU_LIST_PNEXT_CIRC( edgeuse, &neu->l );
	} while( neu->e_p != e1 && neu->e_p != e2 );
	return neu;

}

/*
 *			N M G _ R A D I A L _ M A R K _ C R A C K S
 *
 *  For every edgeuse, if there are other edgeuses around this edge
 *  from the same face, then mark them all as part of a "crack".
 *
 *  To be a crack the two edgeuses must be from the same loopuse.
 *
 *  If the count of repeated ("crack") edgeuses is even, then
 *  classify the entire crack as an "innie" or an "outie".
 *  If the count is odd, this is a "Nasty" --
 *  all but one edgeuse are marked as "outies",
 *  and the remaining one is marked as a non-crack.
 *  The "outie" edgeuses are marked off in pairs,
 *  in the loopuses's edgeuse order.
 */
void
nmg_radial_mark_cracks(struct bu_list *hd, const struct edge *e1, const struct edge *e2, const struct bn_tol *tol)
              		    
                 	    
                 	    		/* may be NULL */
                   	     
{
	struct nmg_radial	*rad;
	struct nmg_radial	*other;
	const struct loopuse	*lu;
	const struct edgeuse	*eu;
	register int		uses;
	int			outie = -1;

	BU_CK_LIST_HEAD(hd);
	NMG_CK_EDGE(e1);
	if(e2) NMG_CK_EDGE(e2);
	BN_CK_TOL(tol);

	for( BU_LIST_FOR( rad, nmg_radial, hd ) )  {
		NMG_CK_RADIAL(rad);
		if( rad->is_crack )  continue;
		if( !rad->fu ) continue;		/* skip wire edges */
		lu = rad->eu->up.lu_p;
		uses = 0;

		/* Search the remainder of the list for other uses */
		for( other = BU_LIST_PNEXT( nmg_radial, rad );
		     BU_LIST_NOT_HEAD( other, hd );
		     other = BU_LIST_PNEXT( nmg_radial, other )
		)  {
			if( !other->fu ) continue;	/* skip wire edges */
			/* Only consider edgeuses from the same loopuse */
			if( other->eu->up.lu_p != lu &&
			    other->eu->eumate_p->up.lu_p != lu )
				continue;
			uses++;
		}
		if( uses <= 0 )  {
			/* The main search continues to end of list */
			continue;		/* not a crack */
		}
		uses++;		/* account for first use too */

		/* OK, we have a crack. Which kind? */
		if( (uses & 1) == 0 )  {
			/* Even number of edgeuses. */
			outie = nmg_is_crack_outie( rad->eu, tol );
			rad->is_crack = 1;
			rad->is_outie = outie;
			if (rt_g.NMG_debug & DEBUG_MESH_EU )  {
				bu_log( "nmg_radial_mark_cracks() EVEN crack eu=x%x, uses=%d, outie=%d\n",
					rad->eu, uses, outie );
			}
			/* Mark all the rest of them the same way */
			for( other = BU_LIST_PNEXT( nmg_radial, rad );
			     BU_LIST_NOT_HEAD( other, hd );
			     other = BU_LIST_PNEXT( nmg_radial, other )
			)  {
				if( !other->fu ) continue;	/* skip wire edges */
				/* Only consider edgeuses from the same loopuse */
				if( other->eu->up.lu_p != lu &&
				    other->eu->eumate_p->up.lu_p != lu )
					continue;
				other->is_crack = 1;
				other->is_outie = outie;
			}
			if (rt_g.NMG_debug & DEBUG_MESH_EU )  {
				bu_log("Printing loopuse and resulting radial list:\n");
				nmg_pr_lu_briefly( lu, 0 );
				nmg_pr_radial_list( hd, tol );
			}
			continue;
		}
		/*
		 *  Odd number of edgeuses.  Traverse in loopuse order.
		 *  All but the last one are "outies", last one is "innie"
		 */
		if (rt_g.NMG_debug & DEBUG_MESH_EU )  {
			bu_log( "nmg_radial_mark_cracks() ODD crack eu=x%x, uses=%d, outie=%d\n",
				rad->eu, uses, outie );
		}
		/* Mark off pairs of edgeuses, one per trip through loop. */
		eu = rad->eu;
		for( ; uses >= 2; uses-- )  {
			eu = nmg_find_next_use_of_2e_in_lu( eu, e1, e2 );
			if (rt_g.NMG_debug & DEBUG_MESH_EU )  {
				bu_log("rad->eu=x%x, eu=x%x, uses=%d\n",
					rad->eu, eu, uses);
			}
			if( eu == rad->eu )  {
				nmg_pr_lu_briefly( lu, 0 );
				nmg_pr_radial_list( hd, tol );
				rt_bomb("nmg_radial_mark_cracks() loop too short!\n");
			}

			other = nmg_find_radial_eu( hd, eu );
			/* Mark 'em as "outies" */
			other->is_crack = 1;
			other->is_outie = 1;
		}

		/* Should only be one left, this one is an "innie":  it borders surface area */
		eu = nmg_find_next_use_of_2e_in_lu( eu, e1, e2 );
		if( eu != rad->eu )  {
			nmg_pr_lu_briefly( lu, 0 );
			nmg_pr_radial_list( hd, tol );
			rt_bomb("nmg_radial_mark_cracks() loop didn't return to start\n");
		}

		rad->is_crack = 1;
		rad->is_outie = 0;		/* "innie" */
	}
}

/*
 *			N M G _ R A D I A L _ F I N D _ A N _ O R I G I N A L
 *
 *  Returns -
 *	NULL		No edgeuses from indicated shell on this list
 *	nmg_radial*	An original, else first newbie, else a newbie crack.
 */
struct nmg_radial *
nmg_radial_find_an_original(const struct bu_list *hd, const struct shell *s, const struct bn_tol *tol)
{
	register struct nmg_radial	*rad;
	struct nmg_radial	*fallback = (struct nmg_radial *)NULL;
	int			seen_shell = 0;

	BU_CK_LIST_HEAD(hd);
	NMG_CK_SHELL(s);

	/* First choice:  find an original, non-crack, non-wire */
	for( BU_LIST_FOR( rad, nmg_radial, hd ) )  {
		NMG_CK_RADIAL(rad);
		if( rad->s != s )  continue;
		seen_shell++;
		if( rad->is_outie )  {
			fallback = rad;
			continue;	/* skip "outie" cracks */
		}
		if( !rad->fu )  continue;	/* skip wires */
		if( rad->existing_flag )  return rad;
	}
	if( !seen_shell )  return (struct nmg_radial *)NULL;	/* No edgeuses from that shell, at all! */

	/* Next, an original crack would be OK */
	if(fallback) return fallback;

	/* If there were no originals, find first newbie */
	for( BU_LIST_FOR( rad, nmg_radial, hd ) )  {
		if( rad->s != s )  continue;
		if( rad->is_outie )  {
			fallback = rad;
			continue;	/* skip "outie" cracks */
		}
		if( !rad->fu )  {
			continue;	/* skip wires */
		}
		return rad;
	}
	/* If no ordinary newbies, provide a newbie crack */
	if(fallback) return fallback;

	/* No ordinary newbiew or newbie cracks, any wires? */
	for( BU_LIST_FOR( rad, nmg_radial, hd ) )  {
		if( rad->s != s )  continue;
		if( rad->is_outie )  {
			continue;	/* skip "outie" cracks */
		}
		if( !rad->fu )  {
			fallback = rad;
			continue;	/* skip wires */
		}
		return rad;
	}
	if(fallback) return fallback;

	bu_log("nmg_radial_find_an_original() shell=x%x\n", s);
	nmg_pr_radial_list( hd, tol );
	rt_bomb("nmg_radial_find_an_original() No entries from indicated shell\n");

	return( (struct nmg_radial *)NULL );
}

/*
 *			N M G _ R A D I A L _ M A R K _ F L I P S
 *
 *  For a given shell, find an original edgeuse from that shell,
 *  and then mark parity violators with a "flip" flag.
 */
int
nmg_radial_mark_flips(struct bu_list *hd, const struct shell *s, const struct bn_tol *tol)
{
	struct nmg_radial	*rad;
	struct nmg_radial	*orig;
	register int		expected_ot;
	int			count = 0;
	int			nflip = 0;

	BU_CK_LIST_HEAD(hd);
	NMG_CK_SHELL(s);
	BN_CK_TOL(tol);

	orig = nmg_radial_find_an_original( hd, s, tol );
	NMG_CK_RADIAL(orig);
	if( orig->is_outie )  {
		/* Only originals were "outie" cracks.  No flipping */
		return 0;
	}

	if( !orig->fu )
	{
		/* nothing but wires */
		return( 0 );
	}
	if( !orig->existing_flag )  {
		/* There were no originals.  Do something sensible to check the newbies */
		if( !orig->fu )  {
			/* Nothing but wires */
			return 0;
		}
#if 0
		/*  Given that there were no existing edgeuses
		 *  from this shell, make our first addition
		 *  oppose the previous radial faceuse, just to be nice.
		 */
		rad = BU_LIST_PPREV_CIRC( nmg_radial, orig );
		/* Hopefully it isn't a wire */
		if( rad->eu->vu_p->v_p == orig->eu->vu_p->v_p )  {
			/* Flip everything, for general compatibility */
			for( BU_LIST_FOR( rad, nmg_radial, hd ) )  {
				if( rad->s != s )  continue;
				if( !rad->fu )  continue;	/* skip wires */
				rad->needs_flip = !rad->needs_flip;
			}
		}
#endif
	}

	expected_ot = !(orig->fu->orientation == OT_SAME);
	if( !orig->is_outie ) count++;	/* Don't count orig if "outie" crack */

	for( BU_LIST_FOR_CIRC( rad, nmg_radial, orig ) )  {
		if( rad->s != s )  continue;
		if( !rad->fu )  continue;	/* skip wires */
		if( rad->is_outie ) continue;	/* skip "outie" cracks */
		count++;
		if( expected_ot == (rad->fu->orientation == OT_SAME) )  {
			expected_ot = !expected_ot;
			continue;
		}
		/* Mis-match detected */
		if (rt_g.NMG_debug & DEBUG_MESH_EU ) {
			bu_log("nmg_radial_mark_flips() Mis-match detected, setting flip flag eu=x%x\n", rad->eu);
		}
		rad->needs_flip = !rad->needs_flip;
		nflip++;
		/* With this one flipped, set expectation for next */
		expected_ot = !expected_ot;
	}

	if( count & 1 )  {
#if 0
		bu_log("nmg_radial_mark_flips() NOTICE dangling fu=x%x detected at eu=x%x in shell=x%x, proceeding.\n  %g %g %g --- %g %g %g\n",
			orig->fu, orig->eu, s,
			V3ARGS(orig->eu->vu_p->v_p->vg_p->coord),
			V3ARGS(orig->eu->eumate_p->vu_p->v_p->vg_p->coord)
		);
		nmg_pr_radial_list( hd, tol );
#endif
		return count;
	}

	if( expected_ot == (orig->fu->orientation == OT_SAME) )
		return nflip;

	bu_log("nmg_radial_mark_flips() unable to establish proper orientation parity.\n  eu count=%d, shell=x%x, expectation=%d\n",
		count, s, expected_ot);
	nmg_pr_radial_list( hd, tol );
	rt_bomb("nmg_radial_mark_flips() unable to establish proper orientation parity.\n");

	return( 0 ); /* for compiler */
}

/*
 *			N M G _ R A D I A L _ C H E C K _ P A R I T Y
 *
 *  For each shell, check orientation parity of edgeuses within that shell.
 */
int
nmg_radial_check_parity(const struct bu_list *hd, const struct bu_ptbl *shells, const struct bn_tol *tol)
{
	struct nmg_radial	*rad;
	struct shell		**sp;
	struct nmg_radial	*orig;
	register int		expected_ot;
	int			count = 0;

	BU_CK_LIST_HEAD(hd);
	BU_CK_PTBL(shells);
	BN_CK_TOL(tol);

	for( sp = (struct shell **)BU_PTBL_LASTADDR(shells);
 	     sp >= (struct shell **)BU_PTBL_BASEADDR(shells); sp-- 
	)  {

		NMG_CK_SHELL(*sp);
		orig = nmg_radial_find_an_original( hd, *sp, tol );
		if( !orig )  continue;
		NMG_CK_RADIAL(orig);
		if( !orig->existing_flag )  {
			/* There were no originals.  Do something sensible to check the newbies */
			if( !orig->fu )  continue;	/* Nothing but wires */
		}
		if( orig->is_outie )  continue;	/* Loop was nothing but outies */
		expected_ot = !(orig->fu->orientation == OT_SAME);

		for( BU_LIST_FOR_CIRC( rad, nmg_radial, orig ) )  {
			if( rad->s != *sp )  continue;
			if( !rad->fu )  continue;	/* skip wires */
			if( rad->is_outie ) continue;	/* skip "outie" cracks */
			if( expected_ot == (rad->fu->orientation == OT_SAME) )  {
				expected_ot = !expected_ot;
				continue;
			}
			/* Mis-match detected */
			bu_log("nmg_radial_check_parity() bad parity eu=x%x, s=x%x\n",
				rad->eu, *sp);
			count++;
			/* Set expectation for next */
			expected_ot = !expected_ot;
		}
		if( expected_ot == (orig->fu->orientation == OT_SAME) )
			continue;
		bu_log("nmg_radial_check_parity() bad parity at END eu=x%x, s=x%x\n",
			rad->eu, *sp);
		count++;
 	}
	return count;
}

/*
 *			N M G _ R A D I A L _ I M P L E M E N T _ D E C I S I O N S
 *
 *  For all non-original edgeuses in the list, place them in the proper
 *  place around the destination edge.
 */
void
nmg_radial_implement_decisions(struct bu_list *hd, const struct bn_tol *tol, struct edgeuse *eu1, fastf_t *xvec, fastf_t *yvec, fastf_t *zvec)
              		    
                   	     		/* for printing */
              		     	/* temp */
      			                 	/*** temp ***/
{
	struct nmg_radial	*rad;
	struct nmg_radial	*prev;
	int			skipped;

	BU_CK_LIST_HEAD(hd);
	BN_CK_TOL(tol);

	if( rt_g.NMG_debug & DEBUG_BASIC )
		bu_log("nmg_radial_implement_decisions() BEGIN\n");

again:
	skipped = 0;
	for( BU_LIST_FOR( rad, nmg_radial, hd ) )  {
		struct edgeuse	*dest;

		if( rad->existing_flag )  continue;
		prev = BU_LIST_PPREV_CIRC( nmg_radial, rad );
		if( !prev->existing_flag )  {
			/* Previous eu isn't in place yet, can't do this one until next pass. */
			skipped++;
			continue;
		}

		/*
		 *  Insert "rad" CCW radial from "prev".
		 *
		 */
		if (rt_g.NMG_debug & DEBUG_MESH_EU ) {
			bu_log("Before -- ");
			nmg_pr_fu_around_eu_vecs( eu1, xvec, yvec, zvec, tol );
			nmg_pr_radial("prev:", (const struct nmg_radial *)prev);
			nmg_pr_radial(" rad:", (const struct nmg_radial *)rad);
		}
		dest = prev->eu;
		if( rad->needs_flip )  {
			struct edgeuse	*other_eu = rad->eu->eumate_p;

			nmg_je( dest, rad->eu );
			rad->eu = other_eu;
			rad->fu = nmg_find_fu_of_eu( other_eu );
			rad->needs_flip = 0;
		} else {
			nmg_je( dest, rad->eu->eumate_p );
		}
		rad->existing_flag = 1;
		if (rt_g.NMG_debug & DEBUG_MESH_EU ) {
			bu_log("After -- ");
			nmg_pr_fu_around_eu_vecs( eu1, xvec, yvec, zvec, tol );
		}
	}
	if( skipped )  {
		if( rt_g.NMG_debug & DEBUG_BASIC )
			bu_log("nmg_radial_implement_decisions() %d remaining, go again\n", skipped);
		goto again;
	}

	if( rt_g.NMG_debug & DEBUG_BASIC )
		bu_log("nmg_radial_implement_decisions() END\n");
}

/*
 *			N M G _ P R _ R A D I A L
 */
void
nmg_pr_radial(const char *title, const struct nmg_radial *rad)
{
	struct face		*f;
	int			orient;

	NMG_CK_RADIAL(rad);
	if( !rad->fu )  {
		f = (struct face *)NULL;
		orient = 'W';
	} else {
		f = rad->fu->f_p;
		orient = nmg_orientation(rad->fu->orientation)[3];
	}
	bu_log("%s%8.8x, mate of \\/\n",
		title,
		rad->eu->eumate_p
	);
	bu_log("%s%8.8x, f=%8.8x, fu=%8.8x=%c, s=%8.8x %s %c%c%c %g deg\n",
		title,
		rad->eu,
		f, rad->fu, orient,
		rad->s,
		rad->existing_flag ? "old" : "new",
		rad->needs_flip ? 'F' : '/',
		rad->is_crack ? 'C' : '/',
		rad->is_outie ? 'O' : (rad->is_crack ? 'I' : '/'),
		rad->ang * bn_radtodeg
	);
}

/*
 *			N M G _ P R _ R A D I A L _ L I S T
 *
 *  Patterned after nmg_pr_fu_around_eu_vecs(), with similar format.
 */
void
nmg_pr_radial_list(const struct bu_list *hd, const struct bn_tol *tol)
                    	    
                   	     		/* for printing */
{
	struct nmg_radial	*rad;

	BU_CK_LIST_HEAD(hd);
	BN_CK_TOL(tol);

	bu_log("nmg_pr_radial_list( hd=x%x )\n", hd);

	for( BU_LIST_FOR( rad, nmg_radial, hd ) )  {
		NMG_CK_RADIAL(rad);
		nmg_pr_radial(" ", rad);
	}
}


/*		N M G _ D O _ R A D I A L _ F L I P S
 *
 *	This routine looks for nmg_radial structures with the same angle,
 *	and sorts them to match the order of nmg_radial structures that
 *	are not at that same angle
 */
void
nmg_do_radial_flips(struct bu_list *hd)
{
	struct nmg_radial	*start_same;
	struct bn_tol	tol;

		tol.magic = BN_TOL_MAGIC;
		tol.dist = 0.005;
		tol.dist_sq = tol.dist * tol.dist;
		tol.perp = 1e-6;
		tol.para = 1 - tol.perp;

	BU_CK_LIST_HEAD( hd );

	start_same = BU_LIST_FIRST( nmg_radial, hd );
	while( BU_LIST_NOT_HEAD( &start_same->l, hd ) )
	{
		struct nmg_radial	*next_after_same;
		struct nmg_radial	*end_same;
		struct nmg_radial	*same;
		struct nmg_radial	*check;

		if( !start_same->fu )
		{
			start_same = BU_LIST_PNEXT( nmg_radial, &start_same->l );
			continue;
		}

		end_same = BU_LIST_PNEXT_CIRC( nmg_radial, &start_same->l );
		while( (end_same->ang == start_same->ang && end_same != start_same)
			|| !end_same->fu )
			end_same = BU_LIST_PNEXT_CIRC( nmg_radial, &end_same->l );
		end_same = BU_LIST_PPREV_CIRC( nmg_radial, &end_same->l );

		if( start_same == end_same )
		{
			start_same = BU_LIST_PNEXT( nmg_radial, &start_same->l );
			continue;
		}

		/* more than one eu at same angle, sort them according to shell */
		next_after_same = BU_LIST_PNEXT_CIRC( nmg_radial, &end_same->l );
		while( !next_after_same->fu && next_after_same != start_same )
			next_after_same = BU_LIST_PNEXT_CIRC( nmg_radial, &next_after_same->l );

		if( next_after_same == start_same )
		{
			/* no other radials with faces */
			return;
		}

		check = next_after_same;
		while( start_same != end_same && check != start_same )
		{
			same = end_same;
			while( same->s != check->s && same != start_same )
				same = BU_LIST_PPREV_CIRC( nmg_radial, &same->l );

			if( same->s != check->s )
			{
				/* couldn't find any other radial from shell "same->s"
				 * so put look at next radial
				 */

				check = BU_LIST_PNEXT_CIRC( nmg_radial, &check->l );
				continue;
			}

			/* same->s matches check->s, so move "same" to right after end_same */
			if( same == start_same )
			{
				/* starting radial matches, need to move it and
				 * set pointer to new start_same
				 */
				start_same = BU_LIST_PNEXT_CIRC( nmg_radial, &start_same->l );
				BU_LIST_DEQUEUE( &same->l );
				BU_LIST_APPEND( &end_same->l, &same->l );
			}
			else if( same == end_same )
			{
				/* already in correct place, just move end_same */
				end_same = BU_LIST_PPREV_CIRC( nmg_radial, &end_same->l );
			}
			else
			{
				BU_LIST_DEQUEUE( &same->l );
				BU_LIST_APPEND( &end_same->l, &same->l );
			}

			check = BU_LIST_PNEXT_CIRC( nmg_radial, &check->l );
		}

		start_same = BU_LIST_PNEXT( nmg_radial, &end_same->l );
	}
}

/*              N M G _ D O _ R A D I A L _ J O I N
 *
 *      Perform radial join of edges in list "hd" based on direction with respect
 *      to "eu1ref"
 */

void
nmg_do_radial_join(struct bu_list *hd, struct edgeuse *eu1ref, fastf_t *xvec, fastf_t *yvec, fastf_t *zvec, const struct bn_tol *tol)
{
	struct nmg_radial	*rad;
	struct nmg_radial	*prev;
	vect_t			ref_dir;
	int			skipped;

	BU_CK_LIST_HEAD( hd );
	NMG_CK_EDGEUSE( eu1ref );
	BN_CK_TOL( tol );

	if (rt_g.NMG_debug & DEBUG_MESH_EU )
		bu_log( "nmg_do_radial_join() START\n" );

	nmg_do_radial_flips( hd );

	VSUB2( ref_dir, eu1ref->eumate_p->vu_p->v_p->vg_p->coord, eu1ref->vu_p->v_p->vg_p->coord );

	if (rt_g.NMG_debug & DEBUG_MESH_EU )
		bu_log( "ref_dir = ( %g %g %g )\n", V3ARGS( ref_dir ) );

top:

	if (rt_g.NMG_debug & DEBUG_MESH_EU )
	{
		bu_log( "At top of nmg_do_radial_join:\n" );
		nmg_pr_radial_list( hd, tol );
	}

	skipped = 0;
	for( BU_LIST_FOR( rad, nmg_radial, hd ) )
	{
		struct edgeuse *dest;
		struct edgeuse *src;
		vect_t src_dir;
		vect_t dest_dir;

		if( rad->existing_flag )
			continue;

		prev = BU_LIST_PPREV_CIRC( nmg_radial, rad );
		if( !prev->existing_flag )
		{
			skipped++;
			continue;
		}

		VSUB2( dest_dir, prev->eu->eumate_p->vu_p->v_p->vg_p->coord, prev->eu->vu_p->v_p->vg_p->coord );
		VSUB2( src_dir, rad->eu->eumate_p->vu_p->v_p->vg_p->coord, rad->eu->vu_p->v_p->vg_p->coord );

		if( !prev->fu || !rad->fu )
		{
			nmg_je( prev->eu, rad->eu );
			continue;
		}

		if( VDOT( dest_dir, ref_dir ) < 0.0 )
			dest = prev->eu->eumate_p;
		else
			dest = prev->eu;

		if( VDOT( src_dir, ref_dir ) > 0.0 )
			src = rad->eu->eumate_p;
		else
			src = rad->eu;

		if (rt_g.NMG_debug & DEBUG_MESH_EU )
		{
			bu_log("Before -- ");
			nmg_pr_fu_around_eu_vecs( eu1ref, xvec, yvec, zvec, tol );
			nmg_pr_radial("prev:", prev);
			nmg_pr_radial(" rad:", rad);

			if( VDOT( dest_dir, ref_dir ) < 0.0 )
				bu_log( "dest_dir disagrees with eu1ref\n" );
			else
				bu_log( "dest_dir agrees with eu1ref\n" );
			
			if( VDOT( src_dir, ref_dir ) < 0.0 )
				bu_log( "src_dir disagrees with eu1ref\n" );
			else
				bu_log( "src_dir agrees with eu1ref\n" );

			bu_log( "Joining dest_eu=x%x to src_eu=x%x\n", dest, src );
		}

		nmg_je( dest, src );
		rad->existing_flag = 1;
		if (rt_g.NMG_debug & DEBUG_MESH_EU )
		{
			bu_log("After -- ");
			nmg_pr_fu_around_eu_vecs( eu1ref, xvec, yvec, zvec, tol );
		}
	}

	if( skipped )
		goto top;

	if (rt_g.NMG_debug & DEBUG_MESH_EU )
		bu_log( "nmg_do_radial_join() DONE\n\n" );
}

/*
 *			N M G _ R A D I A L _ J O I N _ E U _ N E W
 *
 *  A new routine, that uses "global information" about the edge
 *  to plan the operations to be performed.
 */
void
nmg_radial_join_eu_NEW(struct edgeuse *eu1, struct edgeuse *eu2, const struct bn_tol *tol)
{
	struct edgeuse		*eu1ref;		/* reference eu for eu1 */
	struct edgeuse		*eu2ref;
	struct faceuse		*fu1;
	struct faceuse		*fu2;
	struct nmg_radial	*rad;
	vect_t			xvec, yvec, zvec;
	struct bu_list		list1;
	struct bu_list		list2;
	struct bu_ptbl		shell_tbl;

	NMG_CK_EDGEUSE(eu1);
	NMG_CK_EDGEUSE(eu2);
	BN_CK_TOL(tol);

	if( eu1->e_p == eu2->e_p )  return;

	if( !NMG_ARE_EUS_ADJACENT(eu1, eu2) )
		rt_bomb("nmg_radial_join_eu_NEW() edgeuses don't share vertices.\n");

	if( eu1->vu_p->v_p == eu1->eumate_p->vu_p->v_p )  rt_bomb("nmg_radial_join_eu_NEW(): 0 length edge (topology)\n");

	if( bn_pt3_pt3_equal( eu1->vu_p->v_p->vg_p->coord,
	    eu1->eumate_p->vu_p->v_p->vg_p->coord, tol ) )
		rt_bomb("nmg_radial_join_eu_NEW(): 0 length edge (geometry)\n");

	/* Ensure faces are of same orientation, if both eu's have faces */
	fu1 = nmg_find_fu_of_eu(eu1);
	fu2 = nmg_find_fu_of_eu(eu2);
	if( fu1 && fu2 )  {
		if( fu1->orientation != fu2->orientation ){
			eu2 = eu2->eumate_p;
			fu2 = nmg_find_fu_of_eu(eu2);
			if( fu1->orientation != fu2->orientation )
				rt_bomb( "nmg_radial_join_eu_NEW(): Cannot find matching orientations for faceuses\n" );
		}
	}

	if( eu1->eumate_p->radial_p == eu1 && eu2->eumate_p->radial_p == eu2 &&
		nmg_find_s_of_eu( eu1 ) == nmg_find_s_of_eu( eu2 ) )
	{
		/* Only joining two edges, let's keep it simple */
		nmg_je( eu1, eu2 );
		if( eu1->g.magic_p && eu2->g.magic_p )
		{
			if( eu1->g.magic_p != eu2->g.magic_p )
				nmg_jeg( eu1->g.lseg_p, eu2->g.lseg_p );
		}
		else if( eu1->g.magic_p && !eu2->g.magic_p )
			(void)nmg_use_edge_g( eu2, eu1->g.magic_p );
		else if( !eu1->g.magic_p && eu2->g.magic_p )
			(void)nmg_use_edge_g( eu1, eu2->g.magic_p );
		else
		{
			nmg_edge_g( eu1 );
			nmg_use_edge_g( eu2, eu1->g.magic_p );
		}
		return;
	}

	/* XXX This angle-based algorithm can't yet handle snurb faces! */
	if( fu1 && fu1->f_p->g.magic_p && *fu1->f_p->g.magic_p == NMG_FACE_G_SNURB_MAGIC )  return;
	if( fu2 && fu2->f_p->g.magic_p && *fu2->f_p->g.magic_p == NMG_FACE_G_SNURB_MAGIC )  return;

	/*  Construct local coordinate system for this edge,
	 *  so all angles can be measured relative to a common reference.
	 */
	if( fu1 )  {
		if( fu1->orientation == OT_SAME )
			eu1ref = eu1;
		else
			eu1ref = eu1->eumate_p;
	} else {
		/* eu1 is a wire, find a non-wire, if there are any */
		eu1ref = nmg_find_ot_same_eu_of_e(eu1->e_p);
	}
	if( eu1ref->vu_p->v_p == eu2->vu_p->v_p )  {
		eu2ref = eu2;
	} else {
		eu2ref = eu2->eumate_p;
	}
	nmg_eu_2vecs_perp( xvec, yvec, zvec, eu1ref, tol );

	/* Build the primary lists that describe the situation */
	BU_LIST_INIT( &list1 );
	BU_LIST_INIT( &list2 );
	bu_ptbl_init( &shell_tbl, 64, " &shell_tbl");

	nmg_radial_build_list( &list1, &shell_tbl, 1, eu1ref, xvec, yvec, zvec, tol );
	nmg_radial_build_list( &list2, &shell_tbl, 0, eu2ref, xvec, yvec, zvec, tol );

#if 0
	/* OK so far? */
	nmg_pr_radial_list( &list1, tol );
	nmg_pr_radial_list( &list2, tol );
	nmg_pr_ptbl( "Participating shells", &shell_tbl, 1 );
#endif

	if (rt_g.NMG_debug & DEBUG_MESH_EU ) {
		bu_log("nmg_radial_join_eu_NEW(eu1=x%x, eu2=x%x) e1=x%x, e2=x%x\n",
			eu1, eu2,
			eu1->e_p, eu2->e_p);
		nmg_euprint("\tJoining", eu1);
		bu_log( "Faces around eu1:\n" );
		nmg_pr_fu_around_eu_vecs( eu1ref, xvec, yvec, zvec, tol );
		nmg_pr_radial_list( &list1, tol );

		bu_log( "Faces around eu2:\n" );
		nmg_pr_fu_around_eu_vecs( eu2ref, xvec, yvec, zvec, tol );
		nmg_pr_radial_list( &list2, tol );
		nmg_pr_ptbl( "Participating shells", &shell_tbl, 1 );
	}

#if 0
	count1 = nmg_radial_check_parity( &list1, &shell_tbl, tol );
	count2 = nmg_radial_check_parity( &list2, &shell_tbl, tol );
	if( count1 || count2 ) bu_log("nmg_radial_join_eu_NEW() bad parity at the outset, %d, %d\n", count1, count2);
#endif

	/* Merge the two lists, sorting by angles */
	nmg_radial_merge_lists( &list1, &list2, tol );
	nmg_radial_verify_monotone( &list1, tol );

#if 1
	if (rt_g.NMG_debug & DEBUG_MESH_EU )
	{
		bu_log( "Before nmg_do_radial_join():\n" );
		bu_log( "xvec=(%g %g %g), yvec=(%g %g %g), zvec=(%g %g %g)\n" , V3ARGS( xvec ), V3ARGS( yvec ), V3ARGS( zvec ) );
		nmg_pr_fu_around_eu_vecs( eu2ref, xvec, yvec, zvec, tol );
	}
	nmg_do_radial_join( &list1, eu1ref, xvec, yvec, zvec, tol );

	/* Clean up */
	bu_ptbl_free( &shell_tbl);
	while( BU_LIST_WHILE( rad, nmg_radial, &list1 ) )  {
		BU_LIST_DEQUEUE( &rad->l );
		bu_free( (char *)rad, "nmg_radial" );
	}
	return;
#else

	nmg_radial_mark_cracks( &list1, eu1->e_p, eu2->e_p, tol );

	for( sp = (struct shell **)BU_PTBL_LASTADDR(&shell_tbl);
 	     sp >= (struct shell **)BU_PTBL_BASEADDR(&shell_tbl); sp-- 
	)  {
		nmg_radial_mark_flips( &list1, *sp, tol );
	}

	if (rt_g.NMG_debug & DEBUG_MESH_EU ) {
		bu_log("marked list:\n");
		bu_log("  edge: %g %g %g -> %g %g %g\n",
			V3ARGS(eu1ref->vu_p->v_p->vg_p->coord),
			V3ARGS(eu1ref->eumate_p->vu_p->v_p->vg_p->coord) );
		nmg_pr_radial_list( &list1, tol );
	}

	nmg_radial_implement_decisions( &list1, tol, eu1ref, xvec, yvec, zvec );

	if (rt_g.NMG_debug & DEBUG_MESH_EU ) {
		/* How did it come out? */
		nmg_pr_radial_list( &list1, tol );
		nmg_pr_fu_around_eu_vecs( eu1ref, xvec, yvec, zvec, tol );
	}
	count1 = nmg_radial_check_parity( &list1, &shell_tbl, tol );
	if( count1 )  bu_log("nmg_radial_join_eu_NEW() bad parity at completion, %d\n", count1);
	nmg_radial_verify_pointers( &list1, tol );

	nmg_eu_radial_check( eu1ref, nmg_find_s_of_eu(eu1), tol );	/* expensive */
#endif
}

/*
 *			N M G _ R A D I A L _ E X C H A N G E _ M A R K E D
 *
 *  Exchange eu and eu->eumate_p on the radial list, where marked.
 */
void
nmg_radial_exchange_marked(struct bu_list *hd, const struct bn_tol *tol)
              		    
                   	     		/* for printing */
{
	struct nmg_radial	*rad;

	BU_CK_LIST_HEAD(hd);
	BN_CK_TOL(tol);

	for( BU_LIST_FOR( rad, nmg_radial, hd ) )  {
		struct edgeuse	*eu;
		struct edgeuse	*eumate;
		struct edgeuse	*before;
		struct edgeuse	*after;

		if( !rad->needs_flip )  continue;

		/*
		 *  Initial sequencing is:
		 *    before(radial), eu, eumate, after(radial)
		 */
		eu = rad->eu;
		eumate = eu->eumate_p;
		before = eu->radial_p;
		after = eumate->radial_p;

		/*
		 *  Rearrange order to be:
		 *	before, eumate, eu, after.
		 */
		before->radial_p = eumate;
		eumate->radial_p = before;

		after->radial_p = eu;
		eu->radial_p = after;

		rad->eu = eumate;
		rad->fu = nmg_find_fu_of_eu( rad->eu );
		rad->needs_flip = 0;
	}
}

/*
 *			N M G _ S _ R A D I A L _ H A R M O N I Z E
 *
 *  Visit each edge in this shell exactly once.
 *  Where the radial edgeuse parity has become disrupted
 *  due to a boolean operation or whatever, fix it.
 */
void
nmg_s_radial_harmonize(struct shell *s, const struct bn_tol *tol)
{
	struct bu_ptbl	edges;
	struct edgeuse	*eu;
	struct bu_list	list;
	vect_t		xvec, yvec, zvec;
	struct edge	**ep;

	NMG_CK_SHELL(s);
	BN_CK_TOL(tol);

	if( rt_g.NMG_debug & DEBUG_BASIC )
		bu_log("nmg_s_radial_harmonize( s=x%x ) BEGIN\n", s);

	nmg_edge_tabulate( &edges, &s->l.magic );
	for( ep = (struct edge **)BU_PTBL_LASTADDR(&edges);
	     ep >= (struct edge **)BU_PTBL_BASEADDR(&edges); ep--
	)  {
		struct nmg_radial	*rad;
		int	nflip;

		NMG_CK_EDGE(*ep);
		eu = nmg_find_ot_same_eu_of_e( *ep );
		nmg_eu_2vecs_perp( xvec, yvec, zvec, eu, tol );

		BU_LIST_INIT( &list );

		nmg_radial_build_list( &list, (struct bu_ptbl *)NULL, 1, eu, xvec, yvec, zvec, tol );
		nflip = nmg_radial_mark_flips( &list, s, tol );
		if( nflip )  {
			if (rt_g.NMG_debug & DEBUG_MESH_EU ) {
				bu_log("Flips needed:\n");
				nmg_pr_radial_list( &list, tol );
			}
			/* Now, do the flips */
			nmg_radial_exchange_marked( &list, tol );
			if (rt_g.NMG_debug & DEBUG_MESH_EU ) {
				nmg_pr_fu_around_eu_vecs( eu, xvec, yvec, zvec, tol );
			}
		}
		/* Release the storage */
		while( BU_LIST_WHILE( rad, nmg_radial, &list ) )  {
			BU_LIST_DEQUEUE( &rad->l );
			bu_free( (char *)rad, "nmg_radial" );
		}
	}

	bu_ptbl_free( &edges);

	if( rt_g.NMG_debug & DEBUG_BASIC )
		bu_log("nmg_s_radial_harmonize( s=x%x ) END\n", s);
}

/*
 *			N M G  _ E U _ R A D I A L _ C H E C K
 *
 *  Where the radial edgeuse parity has become disrupted, note it.
 *
 *  Returns -
 *	0	OK
 *	!0	Radial parity problem detected
 */
int
nmg_eu_radial_check(const struct edgeuse *eu, const struct shell *s, const struct bn_tol *tol)
{
#if 1
	return( 0 );
#else
	struct bu_list	list;
	vect_t		xvec, yvec, zvec;
	struct nmg_radial	*rad;
	int	nflip;

	NMG_CK_EDGEUSE(eu);
	BN_CK_TOL(tol);

	if (rt_g.NMG_debug & DEBUG_BASIC)  {
		bu_log("nmg_eu_radial_check(eu=x%x, s=x%x)\n", eu, s);
	}

	fu = nmg_find_fu_of_eu(eu);
	if( fu && fu->orientation != OT_SAME )  eu = eu->eumate_p;
	nmg_eu_2vecs_perp( xvec, yvec, zvec, eu, tol );

	BU_LIST_INIT( &list );

	/* In bad cases, this routine may rt_bomb() */
	nmg_radial_build_list( &list, NULL, 1, eu, xvec, yvec, zvec, tol );

	nmg_radial_mark_cracks( &list, eu->e_p, NULL, tol );

	nflip = nmg_radial_mark_flips( &list, s, tol );
	if( nflip )  {
		struct nmg_radial *rad;
		bu_log("nmg_eu_radial_check(x%x) %d flips needed\n  %g %g %g --- %g %g %g\n",
			s, nflip,
			V3ARGS(eu->vu_p->v_p->vg_p->coord),
			V3ARGS(eu->eumate_p->vu_p->v_p->vg_p->coord) );
		nmg_pr_radial_list( &list, tol );
		if (rt_g.NMG_debug & DEBUG_MESH_EU ) {
			nmg_pr_fu_around_eu_vecs( eu, xvec, yvec, zvec, tol );
		}

		if (rt_g.NMG_debug)
		{
			char tmp_name[256];

			sprintf( tmp_name, "radial_check_%d.g", debug_file_count );
			nmg_stash_model_to_file( tmp_name, nmg_find_model( &eu->l.magic ), "error" );
			for( BU_LIST_FOR( rad, nmg_radial, &list ) )
				nmg_pr_fu_briefly( rad->fu, "" );
		}
	}

	/* Release the storage */
	while( BU_LIST_WHILE( rad, nmg_radial, &list ) )  {
		BU_LIST_DEQUEUE( &rad->l );
		bu_free( (char *)rad, "nmg_radial" );
	}
	return nflip;
#endif
}

/*
 *			N M G _ S _ R A D I A L _ C H E C K
 *
 *  Visit each edge in this shell exactly once, and check it.
 */
void
nmg_s_radial_check(struct shell *s, const struct bn_tol *tol)
{
	struct bu_ptbl	edges;
	struct edgeuse	*eu;
	struct edge	**ep;

	NMG_CK_SHELL(s);
	BN_CK_TOL(tol);

	if( rt_g.NMG_debug & DEBUG_BASIC )
		bu_log("nmg_s_radial_check( s=x%x ) BEGIN\n", s);

	nmg_edge_tabulate( &edges, &s->l.magic );
	for( ep = (struct edge **)BU_PTBL_LASTADDR(&edges);
	     ep >= (struct edge **)BU_PTBL_BASEADDR(&edges); ep--
	)  {
		NMG_CK_EDGE(*ep);
		eu = nmg_find_ot_same_eu_of_e( *ep );
		nmg_eu_radial_check( eu, s, tol );
	}

	bu_ptbl_free( &edges);

	if( rt_g.NMG_debug & DEBUG_BASIC )
		bu_log("nmg_s_radial_check( s=x%x ) END\n", s);
}

/*
 *			N M G _ R _ R A D I A L _ C H E C K
 */
void
nmg_r_radial_check(const struct nmgregion *r, const struct bn_tol *tol)
{
	struct shell	*s;

	NMG_CK_REGION(r);
	BN_CK_TOL(tol);

	if( rt_g.NMG_debug & DEBUG_BASIC )
		bu_log("nmg_r_radial_check( r=x%x )\n", r);

	for( BU_LIST_FOR( s, shell, &r->s_hd ) )  {
		NMG_CK_SHELL(s);
		nmg_s_radial_check( s, tol );
	}
}
@


11.73
log
@change conf.h to a wrapped config.h
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/librt/nmg_fuse.c,v 11.72 2004/04/05 08:48:57 morrison Exp $ (ARL)";
@


11.72
log
@merge of ansi-6-0-branch into HEAD
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d29 5
a33 1
#include "conf.h"
@


11.71
log
@merge of windows-6-0-branch into head
@
text
@d70 1
a70 3
nmg_is_common_bigloop( f1, f2 )
const struct face	*f1;
const struct face	*f2;
d129 1
a129 3
nmg_region_v_unique( r1, tol )
struct nmgregion	*r1;
const struct bn_tol	*tol;
d172 1
a172 3
nmg_ptbl_vfuse( t, tol )
struct bu_ptbl		*t;
const struct bn_tol	*tol;
d213 1
a213 4
nmg_region_both_vfuse( t1, t2, tol )
struct bu_ptbl		*t1;
struct bu_ptbl		*t2;
const struct bn_tol	*tol;
d291 1
a291 3
nmg_model_vertex_fuse( m, tol )
struct model		*m;
const struct bn_tol	*tol;
d321 1
a321 2
nmg_cnurb_is_linear( cnrb )
const struct edge_g_cnurb *cnrb;
d385 1
a385 3
nmg_snurb_is_planar( srf, tol )
const struct face_g_snurb *srf;
const struct bn_tol *tol;
d546 1
a546 4
nmg_eval_linear_trim_curve( snrb, uvw, xyz )
const struct face_g_snurb *snrb;
const fastf_t uvw[3];
point_t xyz;
d573 1
a573 5
nmg_eval_trim_curve( cnrb, snrb, t, xyz )
const struct edge_g_cnurb *cnrb;
const struct face_g_snurb *snrb;
const fastf_t t;
point_t xyz;
d623 1
a623 6
nmg_split_trim( cnrb, snrb, t, pt0, pt1, tol )
const struct edge_g_cnurb *cnrb;
const struct face_g_snurb *snrb;
fastf_t t;
struct pt_list *pt0,*pt1;
const struct bn_tol *tol;
d683 1
a683 6
nmg_eval_trim_to_tol( cnrb, snrb, t0, t1, head, tol )
const struct edge_g_cnurb *cnrb;
const struct face_g_snurb *snrb;
const fastf_t t0,t1;
struct bu_list *head;
const struct bn_tol *tol;
d715 1
a715 8
nmg_split_linear_trim( snrb, uvw1, uvw, uvw2, pt0, pt1, tol )
const struct face_g_snurb *snrb;
const fastf_t uvw1[3];
const fastf_t uvw[3];
const fastf_t uvw2[3];
struct pt_list *pt0;
struct pt_list *pt1;
const struct bn_tol *tol;
d778 1
a778 7
nmg_eval_linear_trim_to_tol( cnrb, snrb, uvw1, uvw2, head, tol )
const struct edge_g_cnurb *cnrb;
const struct face_g_snurb *snrb;
const fastf_t uvw1[3];
const fastf_t uvw2[3];
struct bu_list *head;
const struct bn_tol *tol;
d829 1
a829 7
nmg_cnurb_lseg_coincident( eu1, cnrb, snrb, pt1, pt2, tol )
const struct edgeuse *eu1;
const struct edge_g_cnurb *cnrb;
const struct face_g_snurb *snrb;
const point_t pt1;
const point_t pt2;
const struct bn_tol *tol;
d967 1
a967 6
nmg_cnurb_is_on_crv( eu, cnrb, snrb, head, tol )
const struct edgeuse *eu;
const struct edge_g_cnurb *cnrb;
const struct face_g_snurb *snrb;
const struct bu_list *head;
const struct bn_tol *tol;
d1239 1
a1239 3
nmg_model_edge_fuse( m, tol )
struct model *m;
const struct bn_tol *tol;
d1303 1
a1303 3
nmg_model_edge_g_fuse( m, tol )
struct model		*m;
const struct bn_tol	*tol;
d1381 1
a1381 4
nmg_ck_fu_verts( fu1, f2, tol )
struct faceuse	*fu1;
struct face	*f2;
const struct bn_tol	*tol;
d1454 1
a1454 4
nmg_ck_fg_verts( fu1 , f2 , tol )
struct faceuse *fu1;
struct face *f2;
const struct bn_tol *tol;
d1501 1
a1501 4
nmg_two_face_fuse( f1, f2, tol )
struct face	*f1;
struct face	*f2;
const struct bn_tol	*tol;
d1645 1
a1645 3
nmg_model_face_fuse( m, tol )
struct model		*m;
const struct bn_tol	*tol;
d1704 1
a1704 4
nmg_break_all_es_on_v( magic_p, v, tol )
long *magic_p;
struct vertex *v;
const struct bn_tol *tol;
d1796 1
a1796 3
nmg_model_break_e_on_v( m, tol )
struct model			*m;
const struct bn_tol		*tol;
d1899 1
a1899 3
nmg_model_fuse( m, tol )
struct model		*m;
const struct bn_tol	*tol;
d1972 1
a1972 3
nmg_radial_sorted_list_insert( hd, rad )
struct bu_list		*hd;
struct nmg_radial	*rad;
d2021 1
a2021 3
nmg_radial_verify_pointers( hd, tol )
const struct bu_list	*hd;
const struct bn_tol	*tol;
d2062 1
a2062 3
nmg_radial_verify_monotone( hd, tol )
const struct bu_list	*hd;
const struct bn_tol	*tol;
d2090 1
a2090 4
nmg_insure_radial_list_is_increasing( hd, amin, amax )
struct bu_list	*hd;
fastf_t amin;
fastf_t amax;
d2170 9
a2178 9
nmg_radial_build_list( hd, shell_tbl, existing, eu, xvec, yvec, zvec, tol )
struct bu_list		*hd;
struct bu_ptbl		*shell_tbl;	/* may be null */
int			existing;
struct edgeuse		*eu;
const vect_t		xvec;
const vect_t		yvec;
const vect_t		zvec;
const struct bn_tol	*tol;		/* for printing */
d2335 1
a2335 4
nmg_radial_merge_lists( dest, src, tol )
struct bu_list		*dest;
struct bu_list		*src;
const struct bn_tol	*tol;
d2402 1
a2402 3
nmg_is_crack_outie( eu, tol )
const struct edgeuse	*eu;
const struct bn_tol	*tol;
d2497 1
a2497 3
nmg_find_radial_eu( hd, eu )
const struct bu_list	*hd;
const struct edgeuse	*eu;
d2521 4
a2524 4
nmg_find_next_use_of_2e_in_lu( eu, e1, e2 )
const struct edgeuse	*eu;
const struct edge	*e1;
const struct edge	*e2;		/* may be NULL */
d2558 5
a2562 5
nmg_radial_mark_cracks( hd, e1, e2, tol )
struct bu_list		*hd;
const struct edge	*e1;
const struct edge	*e2;		/* may be NULL */
const struct bn_tol	*tol;
d2680 1
a2680 4
nmg_radial_find_an_original( hd, s, tol )
const struct bu_list	*hd;
const struct shell	*s;
const struct bn_tol	*tol;
d2749 1
a2749 4
nmg_radial_mark_flips( hd, s, tol )
struct bu_list		*hd;
const struct shell	*s;
const struct bn_tol	*tol;
d2848 1
a2848 4
nmg_radial_check_parity( hd, shells, tol )
const struct bu_list	*hd;
const struct bu_ptbl	*shells;
const struct bn_tol	*tol;
d2906 5
a2910 5
nmg_radial_implement_decisions( hd, tol, eu1, xvec, yvec, zvec )
struct bu_list		*hd;
const struct bn_tol	*tol;		/* for printing */
struct edgeuse		*eu1;	/* temp */
vect_t			xvec, yvec, zvec;	/*** temp ***/
d2976 1
a2976 3
nmg_pr_radial( title, rad )
const char		*title;
const struct nmg_radial	*rad;
d3012 3
a3014 3
nmg_pr_radial_list( hd, tol )
const struct bu_list	*hd;
const struct bn_tol	*tol;		/* for printing */
d3037 1
a3037 2
nmg_do_radial_flips( hd )
struct bu_list *hd;
d3139 1
a3139 5
nmg_do_radial_join( hd, eu1ref, xvec, yvec, zvec, tol )
struct bu_list *hd;
struct edgeuse *eu1ref;
vect_t xvec, yvec, zvec;
const struct bn_tol *tol;
d3248 1
a3248 4
nmg_radial_join_eu_NEW(eu1, eu2, tol)
struct edgeuse		*eu1;
struct edgeuse		*eu2;
const struct bn_tol	*tol;
d3427 3
a3429 3
nmg_radial_exchange_marked( hd, tol )
struct bu_list		*hd;
const struct bn_tol	*tol;		/* for printing */
d3477 1
a3477 3
nmg_s_radial_harmonize( s, tol )
struct shell		*s;
const struct bn_tol	*tol;
d3540 1
a3540 4
nmg_eu_radial_check( eu, s, tol )
const struct edgeuse	*eu;
const struct shell	*s;
const struct bn_tol	*tol;
d3606 1
a3606 3
nmg_s_radial_check( s, tol )
struct shell		*s;
const struct bn_tol	*tol;
d3637 1
a3637 3
nmg_r_radial_check( r, tol )
const struct nmgregion	*r;
const struct bn_tol	*tol;
@


11.70
log
@update copyright to include span through 2003
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_fuse.c,v 11.69 2002/08/20 17:08:03 jra Exp $ (ARL)";
d1339 1
a1339 1
				if( !e2->magic )
@


11.69
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d22 1
a22 1
 *	This software is Copyright (C) 1993 by the United States Army
d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_fuse.c,v 11.67 2001/04/05 19:35:34 morrison Exp $ (ARL)";
@


11.69.10.1
log
@merge from HEAD
@
text
@d22 1
a22 1
 *	This software is Copyright (C) 1993-2004 by the United States Army
d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_fuse.c,v 11.70 2004/02/02 17:39:23 morrison Exp $ (ARL)";
@


11.69.10.2
log
@merge from head
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_fuse.c,v 11.69.10.1 2004/02/12 18:37:43 erikg Exp $ (ARL)";
@


11.69.10.3
log
@merge from head
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d1339 1
a1339 1
				if(!e2->magic)
@


11.69.4.1
log
@Modifications (on a 6.0 source distribution) for initial port to windows (merged with sources close to 6.0.2)
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_fuse.c,v 11.69 2002/08/20 17:08:03 jra Exp $ (ARL)";
d1339 1
a1339 1
				if(!e2->magic)
@


11.69.4.2
log
@sync to HEAD...
@
text
@d22 1
a22 1
 *	This software is Copyright (C) 1993-2004 by the United States Army
d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/nmg_fuse.c,v 11.69.4.1 2002/09/26 23:04:03 morrison Exp $ (ARL)";
@


11.69.2.1
log
@Initial ANSIfication
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_fuse.c,v 11.69 2002/08/20 17:08:03 jra Exp $ (ARL)";
d70 3
a72 1
nmg_is_common_bigloop(const struct face *f1, const struct face *f2)
d131 3
a133 1
nmg_region_v_unique(struct nmgregion *r1, const struct bn_tol *tol)
d176 3
a178 1
nmg_ptbl_vfuse(struct bu_ptbl *t, const struct bn_tol *tol)
d219 4
a222 1
nmg_region_both_vfuse(struct bu_ptbl *t1, struct bu_ptbl *t2, const struct bn_tol *tol)
d300 3
a302 1
nmg_model_vertex_fuse(struct model *m, const struct bn_tol *tol)
d332 2
a333 1
nmg_cnurb_is_linear(const struct edge_g_cnurb *cnrb)
d397 3
a399 1
nmg_snurb_is_planar(const struct face_g_snurb *srf, const struct bn_tol *tol)
d560 4
a563 1
nmg_eval_linear_trim_curve(const struct face_g_snurb *snrb, const fastf_t *uvw, fastf_t *xyz)
d590 5
a594 1
nmg_eval_trim_curve(const struct edge_g_cnurb *cnrb, const struct face_g_snurb *snrb, const fastf_t t, fastf_t *xyz)
d644 6
a649 1
nmg_split_trim(const struct edge_g_cnurb *cnrb, const struct face_g_snurb *snrb, fastf_t t, struct pt_list *pt0, struct pt_list *pt1, const struct bn_tol *tol)
d709 6
a714 1
nmg_eval_trim_to_tol(const struct edge_g_cnurb *cnrb, const struct face_g_snurb *snrb, const fastf_t t0, const fastf_t t1, struct bu_list *head, const struct bn_tol *tol)
d746 8
a753 1
nmg_split_linear_trim(const struct face_g_snurb *snrb, const fastf_t *uvw1, const fastf_t *uvw, const fastf_t *uvw2, struct pt_list *pt0, struct pt_list *pt1, const struct bn_tol *tol)
d816 7
a822 1
nmg_eval_linear_trim_to_tol(const struct edge_g_cnurb *cnrb, const struct face_g_snurb *snrb, const fastf_t *uvw1, const fastf_t *uvw2, struct bu_list *head, const struct bn_tol *tol)
d873 7
a879 1
nmg_cnurb_lseg_coincident(const struct edgeuse *eu1, const struct edge_g_cnurb *cnrb, const struct face_g_snurb *snrb, const fastf_t *pt1, const fastf_t *pt2, const struct bn_tol *tol)
d1017 6
a1022 1
nmg_cnurb_is_on_crv(const struct edgeuse *eu, const struct edge_g_cnurb *cnrb, const struct face_g_snurb *snrb, const struct bu_list *head, const struct bn_tol *tol)
d1294 3
a1296 1
nmg_model_edge_fuse(struct model *m, const struct bn_tol *tol)
d1360 3
a1362 1
nmg_model_edge_g_fuse(struct model *m, const struct bn_tol *tol)
d1440 4
a1443 1
nmg_ck_fu_verts(struct faceuse *fu1, struct face *f2, const struct bn_tol *tol)
d1516 4
a1519 1
nmg_ck_fg_verts(struct faceuse *fu1, struct face *f2, const struct bn_tol *tol)
d1566 4
a1569 1
nmg_two_face_fuse(struct face *f1, struct face *f2, const struct bn_tol *tol)
d1713 3
a1715 1
nmg_model_face_fuse(struct model *m, const struct bn_tol *tol)
d1774 4
a1777 1
nmg_break_all_es_on_v(long int *magic_p, struct vertex *v, const struct bn_tol *tol)
d1869 3
a1871 1
nmg_model_break_e_on_v(struct model *m, const struct bn_tol *tol)
d1974 3
a1976 1
nmg_model_fuse(struct model *m, const struct bn_tol *tol)
d2049 3
a2051 1
nmg_radial_sorted_list_insert(struct bu_list *hd, struct nmg_radial *rad)
d2100 3
a2102 1
nmg_radial_verify_pointers(const struct bu_list *hd, const struct bn_tol *tol)
d2143 3
a2145 1
nmg_radial_verify_monotone(const struct bu_list *hd, const struct bn_tol *tol)
d2173 4
a2176 1
nmg_insure_radial_list_is_increasing(struct bu_list *hd, fastf_t amin, fastf_t amax)
d2256 9
a2264 9
nmg_radial_build_list(struct bu_list *hd, struct bu_ptbl *shell_tbl, int existing, struct edgeuse *eu, const fastf_t *xvec, const fastf_t *yvec, const fastf_t *zvec, const struct bn_tol *tol)
              		    
              		           	/* may be null */
   			         
              		    
            		     
            		     
            		     
                   	     		/* for printing */
d2421 4
a2424 1
nmg_radial_merge_lists(struct bu_list *dest, struct bu_list *src, const struct bn_tol *tol)
d2491 3
a2493 1
nmg_is_crack_outie(const struct edgeuse *eu, const struct bn_tol *tol)
d2588 3
a2590 1
nmg_find_radial_eu(const struct bu_list *hd, const struct edgeuse *eu)
d2614 4
a2617 4
nmg_find_next_use_of_2e_in_lu(const struct edgeuse *eu, const struct edge *e1, const struct edge *e2)
                    	    
                 	    
                 	    		/* may be NULL */
d2651 5
a2655 5
nmg_radial_mark_cracks(struct bu_list *hd, const struct edge *e1, const struct edge *e2, const struct bn_tol *tol)
              		    
                 	    
                 	    		/* may be NULL */
                   	     
d2773 4
a2776 1
nmg_radial_find_an_original(const struct bu_list *hd, const struct shell *s, const struct bn_tol *tol)
d2845 4
a2848 1
nmg_radial_mark_flips(struct bu_list *hd, const struct shell *s, const struct bn_tol *tol)
d2947 4
a2950 1
nmg_radial_check_parity(const struct bu_list *hd, const struct bu_ptbl *shells, const struct bn_tol *tol)
d3008 5
a3012 5
nmg_radial_implement_decisions(struct bu_list *hd, const struct bn_tol *tol, struct edgeuse *eu1, fastf_t *xvec, fastf_t *yvec, fastf_t *zvec)
              		    
                   	     		/* for printing */
              		     	/* temp */
      			                 	/*** temp ***/
d3078 3
a3080 1
nmg_pr_radial(const char *title, const struct nmg_radial *rad)
d3116 3
a3118 3
nmg_pr_radial_list(const struct bu_list *hd, const struct bn_tol *tol)
                    	    
                   	     		/* for printing */
d3141 2
a3142 1
nmg_do_radial_flips(struct bu_list *hd)
d3244 5
a3248 1
nmg_do_radial_join(struct bu_list *hd, struct edgeuse *eu1ref, fastf_t *xvec, fastf_t *yvec, fastf_t *zvec, const struct bn_tol *tol)
d3357 4
a3360 1
nmg_radial_join_eu_NEW(struct edgeuse *eu1, struct edgeuse *eu2, const struct bn_tol *tol)
d3539 3
a3541 3
nmg_radial_exchange_marked(struct bu_list *hd, const struct bn_tol *tol)
              		    
                   	     		/* for printing */
d3589 3
a3591 1
nmg_s_radial_harmonize(struct shell *s, const struct bn_tol *tol)
d3654 4
a3657 1
nmg_eu_radial_check(const struct edgeuse *eu, const struct shell *s, const struct bn_tol *tol)
d3723 3
a3725 1
nmg_s_radial_check(struct shell *s, const struct bn_tol *tol)
d3756 3
a3758 1
nmg_r_radial_check(const struct nmgregion *r, const struct bn_tol *tol)
@


11.69.2.2
log
@sync branch with HEAD
@
text
@d22 1
a22 1
 *	This software is Copyright (C) 1993-2004 by the United States Army
d26 1
a26 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d1282 1
a1282 1
				if(!e2->magic)
@


11.68
log
@Converted from K&R to ANSI C - RFH
@
text
@d70 3
a72 1
nmg_is_common_bigloop(const struct face *f1, const struct face *f2)
d131 3
a133 1
nmg_region_v_unique(struct nmgregion *r1, const struct bn_tol *tol)
d176 3
a178 1
nmg_ptbl_vfuse(struct bu_ptbl *t, const struct bn_tol *tol)
d219 4
a222 1
nmg_region_both_vfuse(struct bu_ptbl *t1, struct bu_ptbl *t2, const struct bn_tol *tol)
d300 3
a302 1
nmg_model_vertex_fuse(struct model *m, const struct bn_tol *tol)
d332 2
a333 1
nmg_cnurb_is_linear(const struct edge_g_cnurb *cnrb)
d397 3
a399 1
nmg_snurb_is_planar(const struct face_g_snurb *srf, const struct bn_tol *tol)
d560 4
a563 1
nmg_eval_linear_trim_curve(const struct face_g_snurb *snrb, const fastf_t *uvw, fastf_t *xyz)
d590 5
a594 1
nmg_eval_trim_curve(const struct edge_g_cnurb *cnrb, const struct face_g_snurb *snrb, const fastf_t t, fastf_t *xyz)
d644 6
a649 1
nmg_split_trim(const struct edge_g_cnurb *cnrb, const struct face_g_snurb *snrb, fastf_t t, struct pt_list *pt0, struct pt_list *pt1, const struct bn_tol *tol)
d709 6
a714 1
nmg_eval_trim_to_tol(const struct edge_g_cnurb *cnrb, const struct face_g_snurb *snrb, const fastf_t t0, const fastf_t t1, struct bu_list *head, const struct bn_tol *tol)
d746 8
a753 1
nmg_split_linear_trim(const struct face_g_snurb *snrb, const fastf_t *uvw1, const fastf_t *uvw, const fastf_t *uvw2, struct pt_list *pt0, struct pt_list *pt1, const struct bn_tol *tol)
d816 7
a822 1
nmg_eval_linear_trim_to_tol(const struct edge_g_cnurb *cnrb, const struct face_g_snurb *snrb, const fastf_t *uvw1, const fastf_t *uvw2, struct bu_list *head, const struct bn_tol *tol)
d873 7
a879 1
nmg_cnurb_lseg_coincident(const struct edgeuse *eu1, const struct edge_g_cnurb *cnrb, const struct face_g_snurb *snrb, const fastf_t *pt1, const fastf_t *pt2, const struct bn_tol *tol)
d1017 6
a1022 1
nmg_cnurb_is_on_crv(const struct edgeuse *eu, const struct edge_g_cnurb *cnrb, const struct face_g_snurb *snrb, const struct bu_list *head, const struct bn_tol *tol)
d1294 3
a1296 1
nmg_model_edge_fuse(struct model *m, const struct bn_tol *tol)
d1360 3
a1362 1
nmg_model_edge_g_fuse(struct model *m, const struct bn_tol *tol)
d1440 4
a1443 1
nmg_ck_fu_verts(struct faceuse *fu1, struct face *f2, const struct bn_tol *tol)
d1516 4
a1519 1
nmg_ck_fg_verts(struct faceuse *fu1, struct face *f2, const struct bn_tol *tol)
d1566 4
a1569 1
nmg_two_face_fuse(struct face *f1, struct face *f2, const struct bn_tol *tol)
d1713 3
a1715 1
nmg_model_face_fuse(struct model *m, const struct bn_tol *tol)
d1774 4
a1777 1
nmg_break_all_es_on_v(long int *magic_p, struct vertex *v, const struct bn_tol *tol)
d1869 3
a1871 1
nmg_model_break_e_on_v(struct model *m, const struct bn_tol *tol)
d1974 3
a1976 1
nmg_model_fuse(struct model *m, const struct bn_tol *tol)
d2049 3
a2051 1
nmg_radial_sorted_list_insert(struct bu_list *hd, struct nmg_radial *rad)
d2100 3
a2102 1
nmg_radial_verify_pointers(const struct bu_list *hd, const struct bn_tol *tol)
d2143 3
a2145 1
nmg_radial_verify_monotone(const struct bu_list *hd, const struct bn_tol *tol)
d2173 4
a2176 1
nmg_insure_radial_list_is_increasing(struct bu_list *hd, fastf_t amin, fastf_t amax)
d2256 9
a2264 9
nmg_radial_build_list(struct bu_list *hd, struct bu_ptbl *shell_tbl, int existing, struct edgeuse *eu, const fastf_t *xvec, const fastf_t *yvec, const fastf_t *zvec, const struct bn_tol *tol)
              		    
              		           	/* may be null */
   			         
              		    
            		     
            		     
            		     
                   	     		/* for printing */
d2421 4
a2424 1
nmg_radial_merge_lists(struct bu_list *dest, struct bu_list *src, const struct bn_tol *tol)
d2491 3
a2493 1
nmg_is_crack_outie(const struct edgeuse *eu, const struct bn_tol *tol)
d2588 3
a2590 1
nmg_find_radial_eu(const struct bu_list *hd, const struct edgeuse *eu)
d2614 4
a2617 4
nmg_find_next_use_of_2e_in_lu(const struct edgeuse *eu, const struct edge *e1, const struct edge *e2)
                    	    
                 	    
                 	    		/* may be NULL */
d2651 5
a2655 5
nmg_radial_mark_cracks(struct bu_list *hd, const struct edge *e1, const struct edge *e2, const struct bn_tol *tol)
              		    
                 	    
                 	    		/* may be NULL */
                   	     
d2773 4
a2776 1
nmg_radial_find_an_original(const struct bu_list *hd, const struct shell *s, const struct bn_tol *tol)
d2845 4
a2848 1
nmg_radial_mark_flips(struct bu_list *hd, const struct shell *s, const struct bn_tol *tol)
d2947 4
a2950 1
nmg_radial_check_parity(const struct bu_list *hd, const struct bu_ptbl *shells, const struct bn_tol *tol)
d3008 5
a3012 5
nmg_radial_implement_decisions(struct bu_list *hd, const struct bn_tol *tol, struct edgeuse *eu1, fastf_t *xvec, fastf_t *yvec, fastf_t *zvec)
              		    
                   	     		/* for printing */
              		     	/* temp */
      			                 	/*** temp ***/
d3078 3
a3080 1
nmg_pr_radial(const char *title, const struct nmg_radial *rad)
d3116 3
a3118 3
nmg_pr_radial_list(const struct bu_list *hd, const struct bn_tol *tol)
                    	    
                   	     		/* for printing */
d3141 2
a3142 1
nmg_do_radial_flips(struct bu_list *hd)
d3244 5
a3248 1
nmg_do_radial_join(struct bu_list *hd, struct edgeuse *eu1ref, fastf_t *xvec, fastf_t *yvec, fastf_t *zvec, const struct bn_tol *tol)
d3357 4
a3360 1
nmg_radial_join_eu_NEW(struct edgeuse *eu1, struct edgeuse *eu2, const struct bn_tol *tol)
d3539 3
a3541 3
nmg_radial_exchange_marked(struct bu_list *hd, const struct bn_tol *tol)
              		    
                   	     		/* for printing */
d3589 3
a3591 1
nmg_s_radial_harmonize(struct shell *s, const struct bn_tol *tol)
d3654 4
a3657 1
nmg_eu_radial_check(const struct edgeuse *eu, const struct shell *s, const struct bn_tol *tol)
d3723 3
a3725 1
nmg_s_radial_check(struct shell *s, const struct bn_tol *tol)
d3756 3
a3758 1
nmg_r_radial_check(const struct nmgregion *r, const struct bn_tol *tol)
@


11.67
log
@updated SIGNED to signed
updated CONST to const
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_fuse.c,v 11.66 2001/03/31 01:57:10 morrison Exp $ (ARL)";
d70 1
a70 3
nmg_is_common_bigloop( f1, f2 )
const struct face	*f1;
const struct face	*f2;
d129 1
a129 3
nmg_region_v_unique( r1, tol )
struct nmgregion	*r1;
const struct bn_tol	*tol;
d172 1
a172 3
nmg_ptbl_vfuse( t, tol )
struct bu_ptbl		*t;
const struct bn_tol	*tol;
d213 1
a213 4
nmg_region_both_vfuse( t1, t2, tol )
struct bu_ptbl		*t1;
struct bu_ptbl		*t2;
const struct bn_tol	*tol;
d291 1
a291 3
nmg_model_vertex_fuse( m, tol )
struct model		*m;
const struct bn_tol	*tol;
d321 1
a321 2
nmg_cnurb_is_linear( cnrb )
const struct edge_g_cnurb *cnrb;
d385 1
a385 3
nmg_snurb_is_planar( srf, tol )
const struct face_g_snurb *srf;
const struct bn_tol *tol;
d546 1
a546 4
nmg_eval_linear_trim_curve( snrb, uvw, xyz )
const struct face_g_snurb *snrb;
const fastf_t uvw[3];
point_t xyz;
d573 1
a573 5
nmg_eval_trim_curve( cnrb, snrb, t, xyz )
const struct edge_g_cnurb *cnrb;
const struct face_g_snurb *snrb;
const fastf_t t;
point_t xyz;
d623 1
a623 6
nmg_split_trim( cnrb, snrb, t, pt0, pt1, tol )
const struct edge_g_cnurb *cnrb;
const struct face_g_snurb *snrb;
fastf_t t;
struct pt_list *pt0,*pt1;
const struct bn_tol *tol;
d683 1
a683 6
nmg_eval_trim_to_tol( cnrb, snrb, t0, t1, head, tol )
const struct edge_g_cnurb *cnrb;
const struct face_g_snurb *snrb;
const fastf_t t0,t1;
struct bu_list *head;
const struct bn_tol *tol;
d715 1
a715 8
nmg_split_linear_trim( snrb, uvw1, uvw, uvw2, pt0, pt1, tol )
const struct face_g_snurb *snrb;
const fastf_t uvw1[3];
const fastf_t uvw[3];
const fastf_t uvw2[3];
struct pt_list *pt0;
struct pt_list *pt1;
const struct bn_tol *tol;
d778 1
a778 7
nmg_eval_linear_trim_to_tol( cnrb, snrb, uvw1, uvw2, head, tol )
const struct edge_g_cnurb *cnrb;
const struct face_g_snurb *snrb;
const fastf_t uvw1[3];
const fastf_t uvw2[3];
struct bu_list *head;
const struct bn_tol *tol;
d829 1
a829 7
nmg_cnurb_lseg_coincident( eu1, cnrb, snrb, pt1, pt2, tol )
const struct edgeuse *eu1;
const struct edge_g_cnurb *cnrb;
const struct face_g_snurb *snrb;
const point_t pt1;
const point_t pt2;
const struct bn_tol *tol;
d967 1
a967 6
nmg_cnurb_is_on_crv( eu, cnrb, snrb, head, tol )
const struct edgeuse *eu;
const struct edge_g_cnurb *cnrb;
const struct face_g_snurb *snrb;
const struct bu_list *head;
const struct bn_tol *tol;
d1239 1
a1239 3
nmg_model_edge_fuse( m, tol )
struct model *m;
const struct bn_tol *tol;
d1303 1
a1303 3
nmg_model_edge_g_fuse( m, tol )
struct model		*m;
const struct bn_tol	*tol;
d1381 1
a1381 4
nmg_ck_fu_verts( fu1, f2, tol )
struct faceuse	*fu1;
struct face	*f2;
const struct bn_tol	*tol;
d1454 1
a1454 4
nmg_ck_fg_verts( fu1 , f2 , tol )
struct faceuse *fu1;
struct face *f2;
const struct bn_tol *tol;
d1501 1
a1501 4
nmg_two_face_fuse( f1, f2, tol )
struct face	*f1;
struct face	*f2;
const struct bn_tol	*tol;
d1645 1
a1645 3
nmg_model_face_fuse( m, tol )
struct model		*m;
const struct bn_tol	*tol;
d1704 1
a1704 4
nmg_break_all_es_on_v( magic_p, v, tol )
long *magic_p;
struct vertex *v;
const struct bn_tol *tol;
d1796 1
a1796 3
nmg_model_break_e_on_v( m, tol )
struct model			*m;
const struct bn_tol		*tol;
d1899 1
a1899 3
nmg_model_fuse( m, tol )
struct model		*m;
const struct bn_tol	*tol;
d1972 1
a1972 3
nmg_radial_sorted_list_insert( hd, rad )
struct bu_list		*hd;
struct nmg_radial	*rad;
d2021 1
a2021 3
nmg_radial_verify_pointers( hd, tol )
const struct bu_list	*hd;
const struct bn_tol	*tol;
d2062 1
a2062 3
nmg_radial_verify_monotone( hd, tol )
const struct bu_list	*hd;
const struct bn_tol	*tol;
d2090 1
a2090 4
nmg_insure_radial_list_is_increasing( hd, amin, amax )
struct bu_list	*hd;
fastf_t amin;
fastf_t amax;
d2170 9
a2178 9
nmg_radial_build_list( hd, shell_tbl, existing, eu, xvec, yvec, zvec, tol )
struct bu_list		*hd;
struct bu_ptbl		*shell_tbl;	/* may be null */
int			existing;
struct edgeuse		*eu;
const vect_t		xvec;
const vect_t		yvec;
const vect_t		zvec;
const struct bn_tol	*tol;		/* for printing */
d2335 1
a2335 4
nmg_radial_merge_lists( dest, src, tol )
struct bu_list		*dest;
struct bu_list		*src;
const struct bn_tol	*tol;
d2402 1
a2402 3
nmg_is_crack_outie( eu, tol )
const struct edgeuse	*eu;
const struct bn_tol	*tol;
d2497 1
a2497 3
nmg_find_radial_eu( hd, eu )
const struct bu_list	*hd;
const struct edgeuse	*eu;
d2521 4
a2524 4
nmg_find_next_use_of_2e_in_lu( eu, e1, e2 )
const struct edgeuse	*eu;
const struct edge	*e1;
const struct edge	*e2;		/* may be NULL */
d2558 5
a2562 5
nmg_radial_mark_cracks( hd, e1, e2, tol )
struct bu_list		*hd;
const struct edge	*e1;
const struct edge	*e2;		/* may be NULL */
const struct bn_tol	*tol;
d2680 1
a2680 4
nmg_radial_find_an_original( hd, s, tol )
const struct bu_list	*hd;
const struct shell	*s;
const struct bn_tol	*tol;
d2749 1
a2749 4
nmg_radial_mark_flips( hd, s, tol )
struct bu_list		*hd;
const struct shell	*s;
const struct bn_tol	*tol;
d2848 1
a2848 4
nmg_radial_check_parity( hd, shells, tol )
const struct bu_list	*hd;
const struct bu_ptbl	*shells;
const struct bn_tol	*tol;
d2906 5
a2910 5
nmg_radial_implement_decisions( hd, tol, eu1, xvec, yvec, zvec )
struct bu_list		*hd;
const struct bn_tol	*tol;		/* for printing */
struct edgeuse		*eu1;	/* temp */
vect_t			xvec, yvec, zvec;	/*** temp ***/
d2976 1
a2976 3
nmg_pr_radial( title, rad )
const char		*title;
const struct nmg_radial	*rad;
d3012 3
a3014 3
nmg_pr_radial_list( hd, tol )
const struct bu_list	*hd;
const struct bn_tol	*tol;		/* for printing */
d3037 1
a3037 2
nmg_do_radial_flips( hd )
struct bu_list *hd;
d3139 1
a3139 5
nmg_do_radial_join( hd, eu1ref, xvec, yvec, zvec, tol )
struct bu_list *hd;
struct edgeuse *eu1ref;
vect_t xvec, yvec, zvec;
const struct bn_tol *tol;
d3248 1
a3248 4
nmg_radial_join_eu_NEW(eu1, eu2, tol)
struct edgeuse		*eu1;
struct edgeuse		*eu2;
const struct bn_tol	*tol;
d3427 3
a3429 3
nmg_radial_exchange_marked( hd, tol )
struct bu_list		*hd;
const struct bn_tol	*tol;		/* for printing */
d3477 1
a3477 3
nmg_s_radial_harmonize( s, tol )
struct shell		*s;
const struct bn_tol	*tol;
d3540 1
a3540 4
nmg_eu_radial_check( eu, s, tol )
const struct edgeuse	*eu;
const struct shell	*s;
const struct bn_tol	*tol;
d3606 1
a3606 3
nmg_s_radial_check( s, tol )
struct shell		*s;
const struct bn_tol	*tol;
d3637 1
a3637 3
nmg_r_radial_check( r, tol )
const struct nmgregion	*r;
const struct bn_tol	*tol;
@


11.66
log
@Deprecated bn_mat_idn() and bn_mat_zero(), updated calls to h/vmath.h's MAT_IDN() and MAT_ZERO() performance improved macros.
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_fuse.c,v 11.65 2000/10/18 18:10:35 butler Exp $ (ARL)";
d54 2
a55 2
				(CONST struct edge_g_cnurb *cnrb,
				CONST struct face_g_snurb *snrb,
d58 1
a58 1
				CONST struct bn_tol *tol));
d71 2
a72 2
CONST struct face	*f1;
CONST struct face	*f2;
d74 5
a78 5
	CONST struct faceuse	*fu1;
	CONST struct loopuse	*lu1;
	CONST struct edgeuse	*eu1;
	CONST long		*magic1 = (long *)NULL;
	CONST long		*magic2 = (long *)NULL;
d133 1
a133 1
CONST struct bn_tol	*tol;
d178 1
a178 1
CONST struct bn_tol	*tol;
d222 1
a222 1
CONST struct bn_tol	*tol;
d268 1
a268 1
CONST struct bn_tol	*tol;
d302 1
a302 1
CONST struct bn_tol	*tol;
d333 1
a333 1
CONST struct edge_g_cnurb *cnrb;
d398 2
a399 2
CONST struct face_g_snurb *srf;
CONST struct bn_tol *tol;
d561 2
a562 2
CONST struct face_g_snurb *snrb;
CONST fastf_t uvw[3];
d591 3
a593 3
CONST struct edge_g_cnurb *cnrb;
CONST struct face_g_snurb *snrb;
CONST fastf_t t;
d645 2
a646 2
CONST struct edge_g_cnurb *cnrb;
CONST struct face_g_snurb *snrb;
d649 1
a649 1
CONST struct bn_tol *tol;
d710 3
a712 3
CONST struct edge_g_cnurb *cnrb;
CONST struct face_g_snurb *snrb;
CONST fastf_t t0,t1;
d714 1
a714 1
CONST struct bn_tol *tol;
d747 4
a750 4
CONST struct face_g_snurb *snrb;
CONST fastf_t uvw1[3];
CONST fastf_t uvw[3];
CONST fastf_t uvw2[3];
d753 1
a753 1
CONST struct bn_tol *tol;
d817 4
a820 4
CONST struct edge_g_cnurb *cnrb;
CONST struct face_g_snurb *snrb;
CONST fastf_t uvw1[3];
CONST fastf_t uvw2[3];
d822 1
a822 1
CONST struct bn_tol *tol;
d874 6
a879 6
CONST struct edgeuse *eu1;
CONST struct edge_g_cnurb *cnrb;
CONST struct face_g_snurb *snrb;
CONST point_t pt1;
CONST point_t pt2;
CONST struct bn_tol *tol;
d1018 5
a1022 5
CONST struct edgeuse *eu;
CONST struct edge_g_cnurb *cnrb;
CONST struct face_g_snurb *snrb;
CONST struct bu_list *head;
CONST struct bn_tol *tol;
d1163 1
a1163 1
CONST struct bn_tol	*tol;
d1296 1
a1296 1
CONST struct bn_tol *tol;
d1362 1
a1362 1
CONST struct bn_tol	*tol;
d1443 1
a1443 1
CONST struct bn_tol	*tol;
d1445 1
a1445 1
	CONST struct face_g_plane	*fg2;
d1519 1
a1519 1
CONST struct bn_tol *tol;
d1569 1
a1569 1
CONST struct bn_tol	*tol;
d1715 1
a1715 1
CONST struct bn_tol	*tol;
d1777 1
a1777 1
CONST struct bn_tol *tol;
d1782 1
a1782 1
	CONST char *magic_type;
d1871 1
a1871 1
CONST struct bn_tol		*tol;
d1976 1
a1976 1
CONST struct bn_tol	*tol;
d2101 2
a2102 2
CONST struct bu_list	*hd;
CONST struct bn_tol	*tol;
d2144 2
a2145 2
CONST struct bu_list	*hd;
CONST struct bn_tol	*tol;
d2261 4
a2264 4
CONST vect_t		xvec;
CONST vect_t		yvec;
CONST vect_t		zvec;
CONST struct bn_tol	*tol;		/* for printing */
d2424 1
a2424 1
CONST struct bn_tol	*tol;
d2492 2
a2493 2
CONST struct edgeuse	*eu;
CONST struct bn_tol	*tol;
d2495 2
a2496 2
	CONST struct loopuse	*lu;
	CONST struct edge	*e;
d2498 1
a2498 1
	CONST fastf_t		*a, *b;
d2589 2
a2590 2
CONST struct bu_list	*hd;
CONST struct edgeuse	*eu;
d2613 1
a2613 1
CONST struct edgeuse *
d2615 3
a2617 3
CONST struct edgeuse	*eu;
CONST struct edge	*e1;
CONST struct edge	*e2;		/* may be NULL */
d2619 1
a2619 1
	register CONST struct edgeuse	*neu;
d2653 3
a2655 3
CONST struct edge	*e1;
CONST struct edge	*e2;		/* may be NULL */
CONST struct bn_tol	*tol;
d2659 2
a2660 2
	CONST struct loopuse	*lu;
	CONST struct edgeuse	*eu;
d2774 3
a2776 3
CONST struct bu_list	*hd;
CONST struct shell	*s;
CONST struct bn_tol	*tol;
d2847 2
a2848 2
CONST struct shell	*s;
CONST struct bn_tol	*tol;
d2948 3
a2950 3
CONST struct bu_list	*hd;
CONST struct bu_ptbl	*shells;
CONST struct bn_tol	*tol;
d3010 1
a3010 1
CONST struct bn_tol	*tol;		/* for printing */
d3044 2
a3045 2
			nmg_pr_radial("prev:", (CONST struct nmg_radial *)prev);
			nmg_pr_radial(" rad:", (CONST struct nmg_radial *)rad);
d3079 2
a3080 2
CONST char		*title;
CONST struct nmg_radial	*rad;
d3117 2
a3118 2
CONST struct bu_list	*hd;
CONST struct bn_tol	*tol;		/* for printing */
d3248 1
a3248 1
CONST struct bn_tol *tol;
d3360 1
a3360 1
CONST struct bn_tol	*tol;
d3541 1
a3541 1
CONST struct bn_tol	*tol;		/* for printing */
d3591 1
a3591 1
CONST struct bn_tol	*tol;
d3655 3
a3657 3
CONST struct edgeuse	*eu;
CONST struct shell	*s;
CONST struct bn_tol	*tol;
d3725 1
a3725 1
CONST struct bn_tol	*tol;
d3757 2
a3758 2
CONST struct nmgregion	*r;
CONST struct bn_tol	*tol;
@


11.65
log
@Patches for compiling under RedHat 7.0
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_fuse.c,v 11.64 2000/08/23 00:35:53 mike Exp $ (ARL)";
d432 1
a432 1
	bn_mat_zero( matrix );
@


11.64
log
@
lint
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_fuse.c,v 11.63 2000/08/21 02:02:32 butler Exp $ (ARL)";
d31 3
@


11.63
log
@Massive compilation warnings eliminated
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_fuse.c,v 11.62 2000/07/10 23:01:40 mike Exp $ (ARL)";
d2659 1
a2659 1
	int			outie;
@


11.62
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_fuse.c,v 11.61 2000/05/02 01:46:03 mike Exp $ (ARL)";
d1597 1
a1597 1
#if 0
d1661 1
d1663 1
d1788 2
a1789 1
	if( !strcmp( magic_type, "NULL" ), !strcmp( magic_type, "Unknown_Magic" ) )
@


11.61
log
@
Changed from rt_list to bu_list
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_fuse.c,v 11.60 2000/04/01 01:34:21 mike Exp $ (ARL)";
@


11.60
log
@
externs for nmg_fuse.c into raytrace.h
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_fuse.c,v 11.59 2000/03/29 01:36:59 mike Exp $ (ARL)";
d1384 1
a1384 1
		eu1 = BU_LIST_MAIN_PTR( edgeuse, BU_LIST_FIRST( rt_list, &eg1->eu_hd2 ), l2 );
d1395 1
a1395 1
			eu2 = BU_LIST_MAIN_PTR( edgeuse, BU_LIST_FIRST( rt_list, &eg2->eu_hd2 ), l2 );
d2162 1
a2162 1
 *	Check if the passed rt_list is in increasing order. If not,
@


11.59
log
@
Added externs, tidied up CONST args
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_fuse.c,v 11.58 2000/03/28 22:39:59 mike Exp $ (ARL)";
d2768 1
a2768 1
struct bu_list		*hd;
d3345 1
a3345 1
 *			N M G _ R A D I A L _ J O I N _ E U
@


11.58
log
@
Cleanup, shuffle.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_fuse.c,v 11.57 2000/03/28 22:11:15 mike Exp $ (ARL)";
d3649 2
a3650 2
struct edgeuse		*eu;
struct shell		*s;
@


11.57
log
@
Moved routines from nmg_fuse.c to nmg_info.c
@
text
@d8 1
a8 1
 *  Author -
d10 1
d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_fuse.c,v 11.56 2000/03/28 22:06:13 mike Exp $ (ARL)";
d43 14
d173 1
a173 1
bu_ptbl_vfuse( t, tol )
d280 1
a280 1
	total = bu_ptbl_vfuse( &t1, tol );
d309 1
a309 1
	total = bu_ptbl_vfuse( &t1, tol );
a555 7
struct pt_list
{
	struct bu_list l;
	point_t xyz;
	fastf_t t;
};

d1293 1
a1293 1
struct bn_tol *tol;
a1347 66
/* XXX move to nmg_info.c */
/*
 *			N M G _ 2 E D G E U S E _ G _ C O I N C I D E N T
 *
 *  Given two edgeuses, determine if they share the same edge geometry,
 *  either topologically, or within tolerance.
 *
 *  Returns -
 *	0	two edge geometries are not coincident
 *	1	edges geometries are everywhere coincident.
 *		(For linear edge_g_lseg, the 2 are the same line, within tol.)
 */
int
nmg_2edgeuse_g_coincident( eu1, eu2, tol )
CONST struct edgeuse	*eu1;
CONST struct edgeuse	*eu2;
CONST struct bn_tol	*tol;
{
	struct edge_g_lseg	*eg1;
	struct edge_g_lseg	*eg2;

	NMG_CK_EDGEUSE(eu1);
	NMG_CK_EDGEUSE(eu2);
	BN_CK_TOL(tol);

	eg1 = eu1->g.lseg_p;
	eg2 = eu2->g.lseg_p;
	NMG_CK_EDGE_G_LSEG(eg1);
	NMG_CK_EDGE_G_LSEG(eg2);

	if( eg1 == eg2 )  return 1;

	/* Ensure direction vectors are generally parallel */
	/* These are not unit vectors */
	/* tol->para and RT_DOT_TOL are too tight a tolerance.  0.1 is 5 degrees */
	if( fabs(VDOT(eg1->e_dir, eg2->e_dir)) <
	    0.9 * MAGNITUDE(eg1->e_dir) * MAGNITUDE(eg2->e_dir)  )  return 0;

	/* Ensure that vertices on edge 2 are within tol of e1 */
	if( bn_distsq_line3_pt3( eg1->e_pt, eg1->e_dir,
	    eu2->vu_p->v_p->vg_p->coord ) > tol->dist_sq )  goto trouble;
	if( bn_distsq_line3_pt3( eg1->e_pt, eg1->e_dir,
	    eu2->eumate_p->vu_p->v_p->vg_p->coord ) > tol->dist_sq )  goto trouble;

	/* Ensure that vertices of both edges are within tol of other eg */
	if( bn_distsq_line3_pt3( eg2->e_pt, eg2->e_dir,
	    eu1->vu_p->v_p->vg_p->coord ) > tol->dist_sq )  goto trouble;
	if( bn_distsq_line3_pt3( eg2->e_pt, eg2->e_dir,
	    eu1->eumate_p->vu_p->v_p->vg_p->coord ) > tol->dist_sq )  goto trouble;

	/* Perhaps check for ultra-short edges (< 10*tol->dist)? */

	/* Do not use bn_isect_line3_line3() -- it's MUCH too strict */

	return 1;
trouble:
	if( !bn_2line3_colinear( eg1->e_pt, eg1->e_dir, eg2->e_pt, eg2->e_dir,
	     1e5, tol ) )
		return 0;

	/* XXX debug */
	nmg_pr_eg( &eg1->l.magic, 0 );
	nmg_pr_eg( &eg2->l.magic, 0 );
	bu_log("nmg_2edgeuse_g_coincident() lines colinear, vertex check fails, calling colinear anyway.\n");
	return 1;
}
@


11.56
log
@
moved nmg_radial structure to raytrace.h
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_fuse.c,v 11.55 2000/03/28 22:00:10 mike Exp $ (ARL)";
a40 62
/* XXX move to nmg_info.c */
/*
 *			N M G _ F I N D _ O T _ S A M E _ E U _ O F _ E
 *
 *  If there is an edgeuse of an OT_SAME faceuse on this edge, return it.
 *  Only return a wire edgeuse if that is all there is.
 *  Useful for selecting a "good" edgeuse to pass to nmg_eu_2vecs_perp().
 */
struct edgeuse *
nmg_find_ot_same_eu_of_e( e )
CONST struct edge	*e;
{
	register struct edgeuse	*eu1;
	register struct edgeuse	*eu;
	struct faceuse		*fu;

	NMG_CK_EDGE(e);
	eu = eu1 = e->eu_p;
	do  {
		fu = nmg_find_fu_of_eu(eu);
		if( fu && fu->orientation == OT_SAME )  return eu;

		fu = nmg_find_fu_of_eu(eu->eumate_p);
		if( fu && fu->orientation == OT_SAME )  return eu->eumate_p;
		eu = eu->radial_p->eumate_p;
	} while( eu != eu1 );
	return eu1;		/* All wire */
}

/* XXX Move to nmg_info.c */
/*
 *			N M G _ I S _ V E R T E X _ I N _ F A C E
 *
 *  Returns -
 *	vu	One use of vertex 'v' in face 'f'.
 *	NULL	If there are no uses of 'v' in 'f'.
 */
struct vertexuse *
nmg_is_vertex_in_face( v, f )
CONST struct vertex	*v;
CONST struct face	*f;
{
	struct vertexuse	*vu;

	NMG_CK_VERTEX(v);
	NMG_CK_FACE(f);

	for( BU_LIST_FOR( vu, vertexuse, &v->vu_hd ) )  {
		register CONST struct edgeuse	*eu;
		register CONST struct loopuse	*lu;
		register CONST struct faceuse	*fu;

		if( *vu->up.magic_p != NMG_EDGEUSE_MAGIC )  continue;
		if( *(eu = vu->up.eu_p)->up.magic_p != NMG_LOOPUSE_MAGIC )  continue;
		lu = eu->up.lu_p;
		if( *lu->up.magic_p != NMG_FACEUSE_MAGIC )  continue;
		fu = lu->up.fu_p;
		if( fu->f_p != f )  continue;
		return vu;
	}
	return (struct vertexuse *)NULL;
}
@


11.55
log
@
moved mat_determinant to libbn
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_fuse.c,v 11.54 1999/12/30 15:54:29 jra Exp $ (ARL)";
a2152 14

struct nmg_radial {
	struct bu_list	l;
	struct edgeuse	*eu;
	struct faceuse	*fu;		/* Derrived from eu */
	struct shell	*s;		/* Derrived from eu */
	int		existing_flag;	/* !0 if this eu exists on dest edge */
	int		is_crack;	/* This eu is part of a crack. */
	int		is_outie;	/* This crack is an "outie" */
	int		needs_flip;	/* Insert eumate, not eu */
	fastf_t		ang;		/* angle, in radians.  0 to 2pi */
};
#define NMG_RADIAL_MAGIC	0x52614421	/* RaD! */
#define NMG_CK_RADIAL(_p)	NMG_CKMAG(_p, NMG_RADIAL_MAGIC, "nmg_radial")
@


11.54
log
@Eliminated some unused variables
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_fuse.c,v 11.53 1999/06/03 01:39:14 mike Exp $ (ARL)";
a40 11
/* XXX Move to raytrace.h */
RT_EXTERN(struct vertexuse 	*nmg_is_vertex_in_face, (CONST struct vertex *v,
				CONST struct face *f));
RT_EXTERN(struct edge_g_lseg	*nmg_pick_best_edge_g, (struct edgeuse *eu1,
				struct edgeuse *eu2, CONST struct bn_tol *tol));
RT_EXTERN(void			nmg_pr_radial_list, (CONST struct bu_list *hd,
				CONST struct bn_tol *tol));
void nmg_pr_radial();

RT_EXTERN( fastf_t mat_determinant, ( mat_t matrix ) );

d506 1
a506 1
	det = mat_determinant( matrix );
@


11.53
log
@
sed4
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_fuse.c,v 11.52 1999/05/11 19:08:24 mike Exp $ (ARL)";
a423 4
		int index;

		index = i*coords;

a778 2
	int done=0;
	point_t xyz;
a885 2
	int done=0;
	point_t xyz;
a1701 1
	int			code;
a2362 2
		struct faceuse *fu;

a2404 1
	fastf_t			angle;
a2409 1
	int			edge_count;
a2636 2
	vect_t			diff;
	fastf_t			diff_len;
a2655 2
	VSUB2( diff, a, b );
	diff_len = MAGNITUDE(diff);
a2758 1
	register CONST struct edge	*e;
a2918 1
	struct nmg_radial	*wire = (struct nmg_radial *)NULL;
a3091 1
	struct nmg_radial	*other;
a3166 1
		struct edgeuse	*src;
a3502 1
	struct edge_g_lseg	*best_eg;
a3509 2
	struct shell		**sp;
	int			count1, count2;
a3616 4

	best_eg = nmg_pick_best_edge_g( eu1, eu2, tol );
#else
	best_eg = eu1->g.lseg_p;
a3682 2
	struct nmg_radial	*prev;
	int			skipped;
d3798 3
a3804 4
	struct faceuse	*fu;
#if 1
	return( 0 );
#else
a3867 2
	struct bu_list	list;
	vect_t		xvec, yvec, zvec;
@


11.52
log
@Reduced amount of stray debug printing,
to provide a better image of the released version.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_fuse.c,v 11.51 1998/07/30 19:50:29 jra Exp $ (ARL)";
d491 1
a491 1
	mat_zero( matrix );
d528 1
a528 1
		mat_inv( inverse , matrix );
d729 1
a729 1
	pt_new = (struct pt_list *)rt_malloc( sizeof( struct pt_list ), "g_split_trim: pt_new" );
d795 1
a795 1
	pt0 = (struct pt_list *)rt_malloc( sizeof( struct pt_list ), "nmg_eval_trim_to_tol: pt0 " );
d800 1
a800 1
	pt1 = (struct pt_list *)rt_malloc( sizeof( struct pt_list ), "nmg_eval_trim_to_tol: pt1 " );
d836 1
a836 1
	pt_new = (struct pt_list *)rt_malloc( sizeof( struct pt_list ), "g_split_trim: pt_new" );
d909 1
a909 1
	pt0 = (struct pt_list *)rt_malloc( sizeof( struct pt_list ), "nmg_eval_linear_trim_to_tol: pt0 " );
d914 1
a914 1
	pt1 = (struct pt_list *)rt_malloc( sizeof( struct pt_list ), "nmg_eval_linear_trim_to_tol: pt1 " );
d3664 1
a3664 1
		rt_free( (char *)rad, "nmg_radial" );
d3803 1
a3803 1
			rt_free( (char *)rad, "nmg_radial" );
d3881 1
a3881 1
		rt_free( (char *)rad, "nmg_radial" );
@


11.51
log
@Added some checks to nmg_edge_fuse().
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_fuse.c,v 11.50 1998/07/09 14:21:25 jra Exp $ (ARL)";
d1879 4
a1882 2
			PLPRINT(" f1", f1->g.plane_p->N);
			nmg_pr_fu_briefly(f1->fu_p, 0);
@


11.50
log
@Mod to nmg_model_edge_fuse() to insure killed edges are ignored.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/nmg_fuse.c,v 11.49 1998/03/12 20:55:05 jra Exp $ (ARL)";
d1383 1
a1383 1
		if( !e1->index )
d1397 1
a1397 1
			if( !e2->index )
@


11.49
log
@Fixed nmg_break_all_es_on_v() to not make jaunts, and added a new version of nmg_model_edge_fuse().
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 11.48 1998/03/03 20:48:26 jra Exp jra $ (ARL)";
d1383 2
d1397 2
d1409 2
@


11.48
log
@Eliminated some unused code.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 11.47 1997/08/15 19:23:47 jra Exp jra $ (ARL)";
d1229 1
d1362 52
d1929 1
d1947 9
@


11.47
log
@Added code to nmg_eu_radial_join_NEW() to to nmg_jeg() when only two faces are involved.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 11.46 1997/06/13 21:35:22 mike Exp jra $ (ARL)";
d1236 1
a1250 3
		struct pt_list		pt_head;
		struct face_g_snurb	*snrb1;
		struct edge_g_cnurb	*cnrb1;
a1264 2
		BU_LIST_INIT( &pt_head.l );

d1291 2
a1292 42
			struct faceuse *fu1;
			struct face *f1;
			int planar1=0;
			int linear1=0;

			cnrb1 = eu1->g.cnurb_p;
			NMG_CK_EDGE_G_CNURB( cnrb1 );

			if( cnrb1->order <= 0 )
				linear1 = 1;
			else
				linear1 = nmg_cnurb_is_linear( cnrb1 );

			fu1 = nmg_find_fu_of_eu( eu1 );
			if( !fu1 )
			{
				bu_log( "nmg_model_edge_fuse() WARNING: CNURB eu (x%x) is not in a FU\n", eu1 );
				continue;
			}

			f1 = fu1->f_p;
			NMG_CK_FACE( f1 );

			if( !f1->g.magic_p )
			{
				bu_log( "nmg_model_edge_fuse() WARNING: FU (x%x) of CNURB EU (x%x) has no geometry\n",
						fu1, eu1 );
				continue;
			}

			if( *f1->g.magic_p == NMG_FACE_G_PLANE_MAGIC )
				planar1 = 1;
			else if( *f1->g.magic_p == NMG_FACE_G_SNURB_MAGIC )
			{
				snrb1 = f1->g.snurb_p;
				NMG_CK_FACE_G_SNURB( snrb1 );

				planar1 = nmg_snurb_is_planar( snrb1, tol );
			}

			if( linear1 && planar1 )
				lseg1 = 1;
d1295 1
a1304 2
			struct face_g_snurb *snrb2;
			struct edge_g_cnurb *cnrb2;
d1335 1
a1335 44
			{
				struct faceuse *fu2;
				struct face *f2;
				int planar2=0;
				int linear2=0;

				cnrb2 = eu2->g.cnurb_p;
				NMG_CK_EDGE_G_CNURB( cnrb2 );

				if( cnrb2->order <= 0 )
					linear2 = 1;
				else
					linear2 = nmg_cnurb_is_linear( cnrb2 );

				fu2 = nmg_find_fu_of_eu( eu2 );
				if( !fu2 )
				{
					bu_log( "nmg_model_edge_fuse() WARNING: CNURB eu (x%x) is not in a FU\n", eu2 );
					continue;
				}

				f2 = fu2->f_p;
				NMG_CK_FACE( f2 );

				if( !f2->g.magic_p )
				{
					bu_log( "nmg_model_edge_fuse() WARNING: FU (x%x) of CNURB EU (x%x) has no geometry\n",
							fu2, eu2 );
					continue;
				}

				if( *f2->g.magic_p == NMG_FACE_G_PLANE_MAGIC )
					planar2 = 1;
				else if( *f2->g.magic_p == NMG_FACE_G_SNURB_MAGIC )
				{
					snrb2 = f2->g.snurb_p;
					NMG_CK_FACE_G_SNURB( snrb2 );

					planar2 = nmg_snurb_is_planar( snrb2, tol );
				}

				if( linear2 && planar2 )
					lseg2 = 1;
			}
a1348 103
			else
			{
				struct face *f2;
				struct faceuse *fu2;
				point_t pt1;
				point_t pt2;

				/* at least one EU is cnurb */
				if( lseg1 )
				{
					NMG_CK_VERTEX_G( v1a->vg_p );
					NMG_CK_VERTEX_G( v1b->vg_p );

					VMOVE( pt1 , v1a->vg_p->coord );
					VMOVE( pt2 , v1b->vg_p->coord );

					/* Evaluate eu2 at some points and compare with linear eu1 */
					eus_are_coincident = nmg_cnurb_lseg_coincident(
						eu2, cnrb2, snrb2, pt1, pt2, tol );
				}
				else if( lseg2 )
				{
					NMG_CK_VERTEX_G( v2a->vg_p );
					NMG_CK_VERTEX_G( v2b->vg_p );

					VMOVE( pt1 , v2a->vg_p->coord );
					VMOVE( pt2 , v2b->vg_p->coord );
					/* Evaluate eu1 at some points and compare with linear eu2 */
					eus_are_coincident = nmg_cnurb_lseg_coincident(
						eu1, cnrb1, snrb1, pt1, pt2, tol );
				}
				else
				{
					/* neither EU is a line segment */
					if( BU_LIST_IS_EMPTY( &pt_head.l ) )
					{
						if( cnrb1->order > 0 )
						{
							fastf_t t0, t1;

							t0 = cnrb1->k.knots[0];
							t1 = cnrb1->k.knots[cnrb1->k.k_size-1];

							nmg_eval_trim_to_tol( cnrb1, snrb1,
								t0, t1, &pt_head.l, tol );
						}
						else
						{
							point_t uvw1,uvw2;
							struct vertexuse *vu1a,*vu1b;
							struct vertexuse_a_cnurb *vu1a_a,*vu1b_a;

							vu1a = eu1->vu_p;
							NMG_CK_VERTEXUSE( vu1a );
							if( !vu1a->a.magic_p )
							{
								bu_log( "nmg_model_edge_fuse: VU (x%x) of CNURB EU (x%x) has no attributes\n",
									vu1a, eu1 );
								rt_bomb( "nmg_model_edge_fuse: VU of CNURB EU has no attributes\n" );
							}
							if( *vu1a->a.magic_p != NMG_VERTEXUSE_A_CNURB_MAGIC )
							{
								bu_log( "nmg_model_edge_fuse: VU (x%x) of CNURB EU (x%x) is not CNURB\n",
									vu1a, eu1 );
								rt_bomb( "nmg_model_edge_fuse: VU of CNURB EU is not CNURB\n" );
							}
							vu1a_a = vu1a->a.cnurb_p;
							NMG_CK_VERTEXUSE_A_CNURB( vu1a_a );

							vu1b = eu1->eumate_p->vu_p;
							NMG_CK_VERTEXUSE( vu1b );
							if( !vu1b->a.magic_p )
							{
								bu_log( "nmg_model_edge_fuse: VU (x%x) of CNURB EU (x%x) has no attributes\n",
									vu1b, eu1->eumate_p );
								rt_bomb( "nmg_model_edge_fuse: VU of CNURB EU has no attributes\n" );
							}
							if( *vu1b->a.magic_p != NMG_VERTEXUSE_A_CNURB_MAGIC )
							{
								bu_log( "nmg_model_edge_fuse: VU (x%x) of CNURB EU (x%x) is not CNURB\n",
									vu1b, eu1->eumate_p );
								rt_bomb( "nmg_model_edge_fuse: VU of CNURB EU is not CNURB\n" );
							}
							vu1b_a = vu1b->a.cnurb_p;
							NMG_CK_VERTEXUSE_A_CNURB( vu1b_a );

							nmg_eval_linear_trim_to_tol( cnrb1, snrb1,
								 vu1a_a->param, vu1b_a->param,
								 &pt_head.l, tol );
						}
					}

					/* Evaluate some points on eu2 and compare to evaluated eu1 */
					eus_are_coincident = nmg_cnurb_is_on_crv( eu2,
						cnrb2, snrb2, &pt_head.l, tol );
				}

				if( eus_are_coincident )
				{
					nmg_radial_join_eu(eu1, eu2, tol);
				     	total++;
				}
			}
a1350 8
		while( BU_LIST_NON_EMPTY( &pt_head.l ) )
		{
			struct pt_list *pt;

			pt = BU_LIST_FIRST( pt_list, &pt_head.l );
			BU_LIST_DEQUEUE( &pt->l );
			rt_free( (char *)pt, "nmg_model_edge_fuse: pt" );
		}
d1355 4
@


11.46
log
@Moved defines to h/bu.h
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 11.45 1997/06/13 21:30:57 mike Exp mike $ (ARL)";
d3691 14
@


11.45
log
@rt_list_len to bu_list_len
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 11.44 1997/04/10 19:52:34 jra Exp mike $ (ARL)";
a51 17
/* XXX Move to nmg.h */

#define NMG_TBL_LEN(p)	((p)->end)

/* XXX move to rtlist.h */
#define BU_LIST_FOR_BACKWARDS(p,structure,hp)	\
	(p)=BU_LIST_LAST(structure,hp); \
	BU_LIST_NOT_HEAD(p,hp); \
	(p)=BU_LIST_PLAST(structure,p)

/* Process all the list members except hp and the actual head */
#define BU_LIST_FOR_CIRC(p,structure,hp)	\
	(p)=BU_LIST_PNEXT_CIRC(structure,hp); \
	(p) != (hp); \
	(p)=BU_LIST_PNEXT_CIRC(structure,p)


d2143 1
a2143 1
	while( NMG_TBL_LEN( &edgeuses ) > 0 )  {
@


11.44
log
@ifdef'd out an annoying debug print.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 11.43 1996/09/27 08:27:30 mike Exp jra $ (ARL)";
d2475 1
a2475 1
	if( rt_list_len( hd ) < 3 )
d2508 1
a2508 1
	rt_list_reverse( hd );
@


11.43
log
@Converted to using proper routine names for LIBBU and LIBBN routines.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 11.42 1996/08/27 03:05:29 mike Exp mike $ (ARL)";
d3218 1
d3225 1
@


11.42
log
@bu.h type change.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 11.41 1996/07/12 12:17:41 jra Exp mike $ (ARL)";
d45 3
a47 3
				struct edgeuse *eu2, CONST struct rt_tol *tol));
RT_EXTERN(void			nmg_pr_radial_list, (CONST struct rt_list *hd,
				CONST struct rt_tol *tol));
d57 4
a60 4
#define RT_LIST_FOR_BACKWARDS(p,structure,hp)	\
	(p)=RT_LIST_LAST(structure,hp); \
	RT_LIST_NOT_HEAD(p,hp); \
	(p)=RT_LIST_PLAST(structure,p)
d63 2
a64 2
#define RT_LIST_FOR_CIRC(p,structure,hp)	\
	(p)=RT_LIST_PNEXT_CIRC(structure,hp); \
d66 1
a66 1
	(p)=RT_LIST_PNEXT_CIRC(structure,p)
d116 1
a116 1
	for( RT_LIST_FOR( vu, vertexuse, &v->vu_hd ) )  {
d162 2
a163 2
	for( RT_LIST_FOR( lu1, loopuse, &fu1->lu_hd ) )  {
		if( RT_LIST_FIRST_MAGIC(&lu1->down_hd) == NMG_VERTEXUSE_MAGIC )
d170 1
a170 1
		for( RT_LIST_FOR( eu1, edgeuse, &lu1->down_hd ) )  {
d205 1
a205 1
CONST struct rt_tol	*tol;
d209 1
a209 1
	struct nmg_ptbl	t;
d212 1
a212 1
	RT_CK_TOL(tol);
d216 1
a216 1
	for( i = NMG_TBL_END(&t)-1; i >= 0; i-- )  {
d218 1
a218 1
		vi = (struct vertex *)NMG_TBL_GET(&t, i);
d224 1
a224 1
			vj = (struct vertex *)NMG_TBL_GET(&t, j);
d227 1
a227 1
			if( !rt_pt3_pt3_equal( vi->vg_p->coord, vj->vg_p->coord, tol ) )
d230 1
a230 1
			rt_log("nmg_region_v_unique():  2 verts are the same, within tolerance\n");
d236 1
a236 1
	nmg_tbl( &t, TBL_FREE, 0 );
d248 3
a250 3
nmg_ptbl_vfuse( t, tol )
struct nmg_ptbl		*t;
CONST struct rt_tol	*tol;
d256 1
a256 1
	for( i = NMG_TBL_END(t)-1; i >= 0; i-- )  {
d258 1
a258 1
		vi = (struct vertex *)NMG_TBL_GET(t, i);
d264 1
a264 1
			vj = (struct vertex *)NMG_TBL_GET(t, j);
d267 1
a267 1
			if( !rt_pt3_pt3_equal( vi->vg_p->coord, vj->vg_p->coord, tol ) )
d271 1
a271 1
			nmg_tbl( t, TBL_RM, (long *)vi );
d285 1
a285 1
 *  rather than bothering to do a TBL_RM, which will re-copy the
d292 3
a294 3
struct nmg_ptbl		*t1;
struct nmg_ptbl		*t2;
CONST struct rt_tol	*tol;
d301 1
a301 1
	for( j = NMG_TBL_END(t2)-1; j >= 0; j-- )  {
d303 1
a303 1
		vj = (struct vertex *)NMG_TBL_GET(t2, j);
d307 1
a307 1
	for( i = NMG_TBL_END(t1)-1; i >= 0; i-- )  {
d309 1
a309 1
		vi = (struct vertex *)NMG_TBL_GET(t1, i);
d313 1
a313 1
		for( j = NMG_TBL_END(t2)-1; j >= 0; j-- )  {
d315 1
a315 1
			vj = (struct vertex *)NMG_TBL_GET(t2, j);
d319 1
a319 1
			if( !rt_pt3_pt3_equal( vi->vg_p->coord, vj->vg_p->coord, tol ) )
d323 1
a323 1
			NMG_TBL_GET(t2, j) = 0;
d340 1
a340 1
CONST struct rt_tol	*tol;
d342 2
a343 2
	struct nmg_ptbl	t1;
	struct nmg_ptbl	t2;
d348 1
a348 1
	RT_CK_TOL(tol);
d355 1
a355 1
	total = nmg_ptbl_vfuse( &t1, tol );
d358 2
a359 2
	nmg_tbl( &t1, TBL_FREE, 0 );
	nmg_tbl( &t2, TBL_FREE, 0 );
d374 1
a374 1
CONST struct rt_tol	*tol;
d376 1
a376 1
	struct nmg_ptbl	t1;
d380 1
a380 1
	RT_CK_TOL(tol);
d384 1
a384 1
	total = nmg_ptbl_vfuse( &t1, tol );
d386 1
a386 1
	nmg_tbl( &t1, TBL_FREE, 0 );
d389 1
a389 1
		rt_log("nmg_model_vertex_fuse() %d\n", total);
d416 1
a416 1
		rt_log( "nmg_cnurb_is_linear( x%x )\n", cnrb );
d457 1
a457 1
		rt_log( "nmg_cnurb_is_linear( x%x ) returning %d\n", cnrb, linear );
d475 1
a475 1
CONST struct rt_tol *tol;
d488 1
a488 1
	RT_CK_TOL( tol );
d492 1
a492 1
		rt_log( "nmg_snurb_is_planar( x%x )\n", srf );
d607 1
a607 1
			rt_log( "nmg_snurb_is_plana: Cannot calculate plane for snurb x%x\n" , srf );
d629 1
a629 1
		rt_log( "nmg_snurb_is_planar( x%x ) returning %d\n", srf, planar );
d637 1
a637 1
	struct rt_list l;
d721 1
a721 1
		rt_log( "nmg_eval_trim_curve returning (%g %g %g )\n", V3ARGS( xyz ) );
d732 1
a732 1
CONST struct rt_tol *tol;
d740 1
a740 1
	RT_CK_TOL( tol );
d743 1
a743 1
		rt_log( "nmg_split_trim( cnrb=x%x, snrb=x%x, t=%g, pt0=x%x, pt1=x%x )START\n",
d751 1
a751 1
		rt_log( "nmg_split_trim: split parameter (%g) is not between ends (%g and %g)\n",
d758 1
a758 1
	RT_LIST_INSERT( &pt1->l, &pt_new->l );
d766 1
a766 1
			rt_log( "nmg_split_trim: recursing at t=%g (%g,%g)\n",
d778 1
a778 1
			rt_log( "nmg_split_trim: recursing at t=%g (%g,%g)\n",
d785 1
a785 1
		rt_log( "nmg_split_trim( cnrb=x%x, snrb=x%x, t=%g, pt0=x%x, pt1=x%x ) END\n",
d796 2
a797 2
struct rt_list *head;
CONST struct rt_tol *tol;
d806 1
a806 1
	RT_CK_TOL( tol );
d809 1
a809 1
		rt_log( "nmg_eval_trim_to_tol( cnrb=x%x, snrb=x%x, t0=%g, t1=%g ) START\n",
d815 1
a815 1
	RT_LIST_INSERT( head, &pt0->l );
d820 1
a820 1
	RT_LIST_INSERT( head, &pt1->l );
d826 1
a826 1
		rt_log( "nmg_eval_trim_to_tol( cnrb=x%x, snrb=x%x, t0=%g, t1=%g ) END\n",
d838 1
a838 1
CONST struct rt_tol *tol;
d847 1
a847 1
	RT_CK_TOL( tol );
d850 1
a850 1
		rt_log( "nmg_split_linear_trim( snrb=x%x, pt0=x%x, pt1=x%x )START\n",
d859 1
a859 1
	RT_LIST_INSERT( &pt1->l, &pt_new->l );
d863 1
a863 1
		rt_log( "nmg_split_linear_trim: new segments (%g %g %g) <-> (%g %g %g) <-> (%g %g %g)\n",
d874 1
a874 1
			rt_log( "nmg_split_linear_trim: recursing at t=%g (%g,%g)\n",
d887 1
a887 1
			rt_log( "nmg_split_linear_trim: recursing at t=%g (%g,%g)\n",
d894 1
a894 1
		rt_log( "nmg_split_linear_trim( snrb=x%x, pt0=x%x, pt1=x%x ) END\n",
d906 2
a907 2
struct rt_list *head;
CONST struct rt_tol *tol;
d916 1
a916 1
	RT_CK_TOL( tol );
d920 1
a920 1
	RT_CK_TOL( tol );
d923 1
a923 1
		rt_log( "nmg_eval_linear_trim_to_tol( cnrb=x%x, snrb=x%x, uvw1=( %g %g %g), uvw2=( %g %g %g ) ) START\n",
d929 1
a929 1
	RT_LIST_INSERT( head, &pt0->l );
d934 1
a934 1
	RT_LIST_INSERT( head, &pt1->l );
d941 1
a941 1
		rt_log( "nmg_eval_linear_trim_to_tol( cnrb=x%x, snrb=x%x ) END\n",
d966 1
a966 1
CONST struct rt_tol *tol;
d978 1
a978 1
		rt_log( "nmg_cnurb_lseg_coincident( eu1=x%x, cnrb=x%x, snrb=x%x, pt1=(%g %g %g), pt2=(%g %g %g)\n",
d983 1
a983 1
		rt_log( "nmg_cnurb_lseg_coincident: cnrb x%x isn't from eu x%x\n",
d991 1
a991 1
	RT_CK_TOL( tol );
d1008 1
a1008 1
			rt_log( "nmg_cnurb_lseg_coincident: vu (x%x) has no attributes\n",
d1015 1
a1015 1
			rt_log( "nmg_cnurb_lseg_coincident: vu (x%x) from CNURB EU (x%x) is not CNURB\n", 
d1027 1
a1027 1
			rt_log( "nmg_cnurb_lseg_coincident: vu (x%x) has no attributes\n",
d1034 1
a1034 1
			rt_log( "nmg_cnurb_lseg_coincident: vu (x%x) from CNURB EU (x%x) is not CNURB\n", 
d1056 1
a1056 1
			if( rt_dist_pt3_lseg3( &dist, pca, pt1, pt2, xyz, tol ) > 2 )
d1063 1
a1063 1
			rt_log( "nmg_cnurb_lseg_coincident returning %d\n", coincident );
d1082 1
a1082 1
		if( rt_dist_pt3_lseg3( &dist, pca, pt1, pt2, xyz, tol ) > 2 )
d1089 1
a1089 1
		rt_log( "nmg_cnurb_lseg_coincident returning %d\n", coincident );
d1108 2
a1109 2
CONST struct rt_list *head;
CONST struct rt_tol *tol;
d1120 2
a1121 2
	RT_CK_LIST_HEAD( head );
	RT_CK_TOL( tol );
d1124 1
a1124 1
		rt_log( "nmg_cnurb_is_on_crv( eu=x%x, cnrb=x%x, snrb=x%x, head=x%x )\n",
d1143 1
a1143 1
			rt_log( "nmg_cnurb_is_on_crv(): vu (x%x) on CNURB EU (x%x) has no attributes\n",
d1149 1
a1149 1
			rt_log( "nmg_cnurb_is_on_crv(): vu (x%x) on CNURB EU (x%x) is not CNURB\n",
d1158 1
a1158 1
			rt_log( "nmg_cnurb_is_on_crv(): vu (x%x) on CNURB EU (x%x) has no attributes\n",
d1164 1
a1164 1
			rt_log( "nmg_cnurb_is_on_crv(): vu (x%x) on CNURB EU (x%x) is not CNURB\n",
d1183 1
a1183 1
			for( RT_LIST_FOR( pt, pt_list, head ) )
d1201 1
a1201 1
			rt_log( "nmg_cnurb_is_on_crv() returning %d\n", coincident );
d1220 1
a1220 1
		for( RT_LIST_FOR( pt, pt_list, head ) )
d1239 1
a1239 1
		rt_log( "nmg_cnurb_is_on_crv returning %d\n", coincident );
d1249 1
a1249 1
CONST struct rt_tol	*tol;
d1251 1
a1251 1
	struct nmg_ptbl	eutab;
d1256 1
a1256 1
	RT_CK_TOL(tol);
d1263 1
a1263 1
	for( i = NMG_TBL_END(&eutab)-1; i >= 0; i-- )  {
d1273 1
a1273 1
		eu1 = (struct edgeuse *)NMG_TBL_GET(&eutab, i);
d1284 1
a1284 1
		RT_LIST_INIT( &pt_head.l );
d1291 1
a1291 1
					rt_log("nmg_model_edge_fuse() WARNING:  deletion of 0-length edgeuse=x%x caused parent to go empty.\n", eu1);
d1293 1
a1293 1
				rt_log("nmg_model_edge_fuse() 0-length edgeuse=x%x deleted\n", eu1);
d1295 1
a1295 1
				nmg_tbl( &eutab, TBL_FREE, 0 );
d1303 1
a1303 1
			rt_log( "nmg_model_edge_fuse() WARNING: eu (x%x) has no geometry\n" , eu1 );
d1328 1
a1328 1
				rt_log( "nmg_model_edge_fuse() WARNING: CNURB eu (x%x) is not in a FU\n", eu1 );
d1337 1
a1337 1
				rt_log( "nmg_model_edge_fuse() WARNING: FU (x%x) of CNURB EU (x%x) has no geometry\n",
d1357 1
a1357 1
			rt_log( "nmg_model_edge_fuse() WARNING: eu (x%x) has unknown geometry\n" , eu1 );
d1370 1
a1370 1
			eu2 = (struct edgeuse *)NMG_TBL_GET(&eutab,j);
d1373 1
a1373 1
				rt_log( "nmg_mode_edge_fuse: checking eus x%x and x%x\n", eu1, eu2 );
d1388 1
a1388 1
				rt_log( "nmg_model_edge_fuse() WARNING: eu (x%x) has no geometry\n" , eu2 );
d1414 1
a1414 1
					rt_log( "nmg_model_edge_fuse() WARNING: CNURB eu (x%x) is not in a FU\n", eu2 );
d1423 1
a1423 1
					rt_log( "nmg_model_edge_fuse() WARNING: FU (x%x) of CNURB EU (x%x) has no geometry\n",
d1443 1
a1443 1
				rt_log( "nmg_model_edge_fuse() WARNING: eu (x%x) has unknown geometry\n" , eu2 );
d1488 1
a1488 1
					if( RT_LIST_IS_EMPTY( &pt_head.l ) )
d1510 1
a1510 1
								rt_log( "nmg_model_edge_fuse: VU (x%x) of CNURB EU (x%x) has no attributes\n",
d1516 1
a1516 1
								rt_log( "nmg_model_edge_fuse: VU (x%x) of CNURB EU (x%x) is not CNURB\n",
d1527 1
a1527 1
								rt_log( "nmg_model_edge_fuse: VU (x%x) of CNURB EU (x%x) has no attributes\n",
d1533 1
a1533 1
								rt_log( "nmg_model_edge_fuse: VU (x%x) of CNURB EU (x%x) is not CNURB\n",
d1559 1
a1559 1
		while( RT_LIST_NON_EMPTY( &pt_head.l ) )
d1563 2
a1564 2
			pt = RT_LIST_FIRST( pt_list, &pt_head.l );
			RT_LIST_DEQUEUE( &pt->l );
d1569 2
a1570 2
		rt_log("nmg_model_edge_fuse(): %d edges fused\n", total);
	nmg_tbl( &eutab, TBL_FREE, 0 );
d1590 1
a1590 1
CONST struct rt_tol	*tol;
d1597 1
a1597 1
	RT_CK_TOL(tol);
d1613 1
a1613 1
	if( rt_distsq_line3_pt3( eg1->e_pt, eg1->e_dir,
d1615 1
a1615 1
	if( rt_distsq_line3_pt3( eg1->e_pt, eg1->e_dir,
d1619 1
a1619 1
	if( rt_distsq_line3_pt3( eg2->e_pt, eg2->e_dir,
d1621 1
a1621 1
	if( rt_distsq_line3_pt3( eg2->e_pt, eg2->e_dir,
d1626 1
a1626 1
	/* Do not use rt_isect_line3_line3() -- it's MUCH too strict */
d1630 1
a1630 1
	if( !rt_2line3_colinear( eg1->e_pt, eg1->e_dir, eg2->e_pt, eg2->e_dir,
d1637 1
a1637 1
	rt_log("nmg_2edgeuse_g_coincident() lines colinear, vertex check fails, calling colinear anyway.\n");
d1651 1
a1651 1
CONST struct rt_tol	*tol;
d1653 1
a1653 1
	struct nmg_ptbl	etab;
d1658 1
a1658 1
	RT_CK_TOL(tol);
d1663 1
a1663 1
	for( i = NMG_TBL_END(&etab)-1; i >= 0; i-- )  {
d1667 1
a1667 1
		eg1 = (struct edge_g_lseg *)NMG_TBL_GET(&etab, i);
d1676 1
a1676 1
		eu1 = RT_LIST_MAIN_PTR( edgeuse, RT_LIST_FIRST( rt_list, &eg1->eu_hd2 ), l2 );
d1683 1
a1683 1
			eg2 = (struct edge_g_lseg *)NMG_TBL_GET(&etab,j);
d1687 1
a1687 1
			eu2 = RT_LIST_MAIN_PTR( edgeuse, RT_LIST_FIRST( rt_list, &eg2->eu_hd2 ), l2 );
d1701 1
a1701 1
			NMG_TBL_GET(&etab,i) = (long *)NULL;
d1705 1
a1705 1
	nmg_tbl( &etab, TBL_FREE, (long *)0 );
d1707 1
a1707 1
		rt_log("nmg_model_edge_g_fuse(): %d edge_g_lseg's fused\n", total);
d1732 1
a1732 1
CONST struct rt_tol	*tol;
d1735 1
a1735 1
	struct nmg_ptbl		vtab;
d1743 1
a1743 1
	RT_CK_TOL(tol);
d1750 1
a1750 1
	for( k = NMG_TBL_END(&vtab)-1; k >= 0; k-- )  {
d1754 1
a1754 1
		v = (struct vertex *)NMG_TBL_GET(&vtab, k);
d1764 1
a1764 1
				rt_log("nmg_ck_fu_verts(x%x, x%x) v x%x off face by %e\n",
d1776 1
a1776 1
	nmg_tbl( &vtab, TBL_FREE, 0 );
d1779 1
a1779 1
		rt_log("nmg_ck_fu_verts(fu1=x%x, f2=x%x, tol=%g) f1=x%x, ret=%d, worst=%gmm (%e)\n",
d1808 1
a1808 1
CONST struct rt_tol *tol;
d1817 1
a1817 1
	RT_CK_TOL( tol );
d1823 1
a1823 1
	for( RT_LIST_FOR( f , face , &fg1->f_hd ) )
d1858 1
a1858 1
CONST struct rt_tol	*tol;
d1867 1
a1867 1
	RT_CK_TOL(tol);
d1874 1
a1874 1
			rt_log("nmg_two_face_fuse(x%x, x%x) null fg fg1=x%x, fg2=x%x\n",
d1885 1
a1885 1
			rt_log("nmg_two_face_fuse(x%x, x%x) fg already shared\n",
d1903 1
a1903 1
			rt_log("nmg_two_face_fuse(x%x, x%x) faces have a common loop, they MUST be fused.  flip2=%d\n",
d1910 1
a1910 1
	code = rt_coplanar( fg1->N, fg2->N, tol );
d1913 1
a1913 1
			rt_log("nmg_two_face_fuse(x%x, x%x) faces non-coplanar\n",
d1924 1
a1924 1
		rt_log("nmg_two_face_fuse(x%x, x%x) coplanar faces, rt_coplanar code=%d, flip2=%d\n",
d1935 1
a1935 1
			rt_log("nmg_two_face_fuse: f1 verts not within tol of f2's surface, can't fuse\n");
d1949 1
a1949 1
			rt_log("nmg_two_face_fuse: f2 verts not within tol of f1's surface, can't fuse\n");
d1958 1
a1958 1
			rt_log("joining face geometry (same dir) f1=x%x, f2=x%x\n", f1, f2);
d1966 1
a1966 1
			rt_log("joining face geometry (opposite dirs)\n");
d1968 1
a1968 1
			rt_log(" f1=x%x, flip=%d", f1, f1->flip);
d1971 1
a1971 1
			rt_log(" f2=x%x, flip=%d", f2, f2->flip);
d1975 1
a1975 1
		for( RT_LIST_FOR( fn, face, &fg2->f_hd ) )  {
d1979 1
a1979 1
				rt_log("f=x%x, new flip=%d\n", fn, fn->flip);
d2003 1
a2003 1
CONST struct rt_tol	*tol;
d2005 1
a2005 1
	struct nmg_ptbl	ftab;
d2010 1
a2010 1
	RT_CK_TOL(tol);
d2015 1
a2015 1
	for( i = NMG_TBL_END(&ftab)-1; i >= 0; i-- )  {
d2018 1
a2018 1
		f1 = (struct face *)NMG_TBL_GET(&ftab, i);
d2041 1
a2041 1
			f2 = (struct face *)NMG_TBL_GET(&ftab, j);
d2053 1
a2053 1
	nmg_tbl( &ftab, TBL_FREE, 0 );
d2055 1
a2055 1
		rt_log("nmg_model_face_fuse: %d faces fused\n", total);
d2063 1
a2063 1
CONST struct rt_tol *tol;
d2065 1
a2065 1
	struct nmg_ptbl eus;
d2071 1
a2071 1
		rt_log( "nmg_break_all_es_on_v( magic=x%x, v=x%x )\n", magic_p, v );
d2074 1
a2074 1
	RT_CK_TOL( tol );
d2079 1
a2079 1
		rt_log( "Bad magic pointer passed to nmg_break_all_es_on_v (%s)\n", magic_type );
d2085 1
a2085 1
	for( i=0 ; i<NMG_TBL_END( &eus ) ; i++ )
d2093 1
a2093 1
		eu = (struct edgeuse *)NMG_TBL_GET( &eus, i );
d2106 1
a2106 1
		code = rt_isect_pt_lseg( &dist, va->vg_p->coord, vb->vg_p->coord,
d2110 2
a2111 2
			rt_log("nmg_break_all_es_on_v() code=%d, why wasn't this vertex fused?\n", code);
			rt_log( "\teu=x%x, v=x%x\n", eu, v );
d2117 1
a2117 1
			rt_log( "\tnmg_break_all_es_on_v: breaking eu x%x on v x%x\n", eu, v );
d2122 1
a2122 1
	nmg_tbl( &eus, TBL_FREE, (long *)NULL );
d2146 1
a2146 1
CONST struct rt_tol		*tol;
d2149 3
a2151 3
	struct nmg_ptbl	verts;
	struct nmg_ptbl	edgeuses;
	struct nmg_ptbl	new_edgeuses;
d2155 1
a2155 1
	RT_CK_TOL(tol);
d2161 1
a2161 1
		(void)nmg_tbl( &new_edgeuses, TBL_INIT, 0 );
d2163 2
a2164 2
		for( eup = (struct edgeuse **)NMG_TBL_LASTADDR(&edgeuses);
		     eup >= (struct edgeuse **)NMG_TBL_BASEADDR(&edgeuses);
d2180 2
a2181 2
			for( vp = (struct vertex **)NMG_TBL_LASTADDR(&verts);
			     vp >= (struct vertex **)NMG_TBL_BASEADDR(&verts);
d2195 1
a2195 1
				code = rt_isect_pt_lseg( &dist,
d2201 1
a2201 1
					rt_log("nmg_model_break_e_on_v() code=%d, why wasn't this vertex fused?\n", code);
d2206 1
a2206 1
					rt_log( "nmg_model_break_e_on_v(): breaking eu x%x (e=x%x) at vertex x%x\n", eu,eu->e_p, v );
d2211 1
a2211 1
				nmg_tbl( &new_edgeuses, TBL_INS, &new_eu->l.magic );
d2218 1
a2218 1
		nmg_tbl( &edgeuses, TBL_FREE, 0 );
d2221 2
a2222 2
	nmg_tbl( &edgeuses, TBL_FREE, 0 );
	nmg_tbl( &verts, TBL_FREE, 0 );
d2224 1
a2224 1
		rt_log("nmg_model_break_e_on_v() broke %d edges\n", count);
d2251 1
a2251 1
CONST struct rt_tol	*tol;
d2256 1
a2256 1
	RT_CK_TOL(tol);
d2268 1
a2268 1
		rt_log( "nmg_model_fuse: vertices\n" );
d2273 1
a2273 1
		rt_log( "nmg_model_fuse: break edges\n" );
d2285 1
a2285 1
		for( RT_LIST_FOR( r, nmgregion, &m->r_hd ) )
d2287 1
a2287 1
			for( RT_LIST_FOR( s, shell, &r->s_hd ) )
d2294 1
a2294 1
		rt_log( "nmg_model_fuse: faces\n" );
d2299 1
a2299 1
		rt_log( "nmg_model_fuse: edges\n" );
d2304 1
a2304 1
		rt_log( "nmg_model_fuse: edge geometries\n" );
d2308 1
a2308 1
		rt_log("nmg_model_fuse(): %d entities fused\n", total);
d2316 1
a2316 1
	struct rt_list	l;
d2339 1
a2339 1
struct rt_list		*hd;
d2345 1
a2345 1
	RT_CK_LIST_HEAD(hd);
d2348 2
a2349 2
	if(RT_LIST_IS_EMPTY(hd))  {
		RT_LIST_APPEND( hd, &rad->l );
d2356 1
a2356 1
		RT_LIST_APPEND( hd, &rad->l );
d2365 1
a2365 1
	cur = RT_LIST_PREV(nmg_radial, hd);
d2367 1
a2367 1
		RT_LIST_INSERT( hd, &rad->l );
d2372 1
a2372 1
	for( RT_LIST_FOR_BACKWARDS( cur, nmg_radial, hd ) )  {
d2375 1
a2375 1
			RT_LIST_APPEND( &cur->l, &rad->l );
d2381 1
a2381 1
	RT_LIST_APPEND( hd, &rad->l );
d2390 2
a2391 2
CONST struct rt_list	*hd;
CONST struct rt_tol	*tol;
d2398 2
a2399 2
	RT_CK_LIST_HEAD(hd);
	RT_CK_TOL(tol);
d2402 1
a2402 1
	for( RT_LIST_FOR( rad, nmg_radial, hd ) )  {
d2404 2
a2405 2
		prev = RT_LIST_PPREV_CIRC(nmg_radial, rad);
		next = RT_LIST_PNEXT_CIRC(nmg_radial, rad);
d2418 2
a2419 2
			rt_log(" previous angle=%g > current=%g\n",
				amin*rt_radtodeg, rad->ang*rt_radtodeg);
d2433 2
a2434 2
CONST struct rt_list	*hd;
CONST struct rt_tol	*tol;
d2439 2
a2440 2
	RT_CK_LIST_HEAD(hd);
	RT_CK_TOL(tol);
d2443 1
a2443 1
	for( RT_LIST_FOR( rad, nmg_radial, hd ) )  {
d2447 2
a2448 2
			rt_log(" previous angle=%g > current=%g\n",
				amin*rt_radtodeg, rad->ang*rt_radtodeg);
d2463 1
a2463 1
struct rt_list	*hd;
d2471 1
a2471 1
	RT_CK_LIST_HEAD( hd );
d2478 1
a2478 1
	for( RT_LIST_FOR( rad, nmg_radial, hd ) )
d2511 1
a2511 1
	for( RT_LIST_FOR( rad, nmg_radial, hd ) )
d2548 2
a2549 2
struct rt_list		*hd;
struct nmg_ptbl		*shell_tbl;	/* may be null */
d2555 1
a2555 1
CONST struct rt_tol	*tol;		/* for printing */
d2568 2
a2569 2
	RT_CK_LIST_HEAD(hd);
	if(shell_tbl) NMG_CK_PTBL(shell_tbl);
d2571 1
a2571 1
	RT_CK_TOL(tol);
d2574 1
a2574 1
		rt_log("nmg_radial_build_list( existing=%d, eu=x%x )\n", existing, eu );
d2581 1
a2581 1
		GETSTRUCT( rad, nmg_radial );
d2600 1
a2600 1
			rad->ang = -rt_pi;	/* -180 */
d2609 1
a2609 1
			rt_log( "\trad->eu = %x, rad->ang = %g\n", rad->eu, rad->ang );
d2612 1
a2612 1
		RT_LIST_INSERT( hd, &(rad->l) );
d2615 1
a2615 1
		if(shell_tbl) nmg_tbl( shell_tbl, TBL_INS_UNIQUE, &(rad->s->l.magic) );
d2641 3
a2643 3
		rt_log("amin=%g min_eu=x%x, amax=%g max_eu=x%x\n",
		rmin->ang * rt_radtodeg, rmin->eu,
		rmax->ang * rt_radtodeg, rmax->eu );
d2645 2
a2646 2
		for( RT_LIST_FOR( next, nmg_radial, hd ) )
			rt_log( "%x: eu=%x, fu=%x, ang=%g\n" , next, next->eu, next->fu, next->ang );
d2655 1
a2655 1
			next = RT_LIST_PNEXT_CIRC(nmg_radial, next);
d2671 1
a2671 1
		while( (next = RT_LIST_PPREV_CIRC(nmg_radial, rmin))->fu == (struct faceuse *)NULL )
d2673 1
a2673 1
		next = RT_LIST_PPREV_CIRC(nmg_radial, rmin);
d2680 1
a2680 1
				rmin = RT_LIST_PNEXT_CIRC( nmg_radial, rmax );
d2689 1
a2689 1
	if( RT_LIST_PNEXT_CIRC(nmg_radial, rmax) == rmin )  {
d2691 1
a2691 1
		RT_LIST_DEQUEUE( hd );
d2693 1
a2693 1
		RT_LIST_APPEND( &(rmax->l), hd );
d2696 1
a2696 1
		rt_log("  %f %f %f --- %f %f %f\n",
d2699 3
a2701 3
		rt_log("amin=%g min_eu=x%x, amax=%g max_eu=x%x B\n",
			rmin->ang * rt_radtodeg, rmin->eu,
			rmax->ang * rt_radtodeg, rmax->eu );
d2715 3
a2717 3
struct rt_list		*dest;
struct rt_list		*src;
CONST struct rt_tol	*tol;
d2721 3
a2723 3
	RT_CK_LIST_HEAD(dest);
	RT_CK_LIST_HEAD(src);
	RT_CK_TOL(tol);
d2725 2
a2726 2
	while( RT_LIST_WHILE( rad, nmg_radial, src ) )  {
		RT_LIST_DEQUEUE( &rad->l );
d2786 1
a2786 1
CONST struct rt_tol	*tol;
d2797 1
a2797 1
	RT_CK_TOL(tol);
d2819 1
a2819 1
		struct rt_tol tmp_tol;
d2847 1
a2847 1
		rt_log(" eu=x%x, len=%g\n", eu, MAGNITUDE(diff) );
d2852 1
a2852 1
		rt_log("nmg_is_crack_outie(eu=x%x) lu=x%x, e=x%x, class=%s\n",
d2870 1
a2870 1
	rt_log("nmg_is_crack_outie(eu=x%x), lu=x%x(%s)\n  midpt_class=%s, midpt=(%g, %g, %g)\n",
d2886 1
a2886 1
CONST struct rt_list	*hd;
d2891 1
a2891 1
	RT_CK_LIST_HEAD(hd);
d2894 1
a2894 1
	for( RT_LIST_FOR( rad, nmg_radial, hd ) )  {
d2898 1
a2898 1
	rt_log("nmg_find_radial_eu() eu=x%x\n", eu);
d2926 1
a2926 1
		neu = RT_LIST_PNEXT_CIRC( edgeuse, &neu->l );
d2950 1
a2950 1
struct rt_list		*hd;
d2953 1
a2953 1
CONST struct rt_tol	*tol;
d2962 1
a2962 1
	RT_CK_LIST_HEAD(hd);
d2965 1
a2965 1
	RT_CK_TOL(tol);
d2967 1
a2967 1
	for( RT_LIST_FOR( rad, nmg_radial, hd ) )  {
d2975 3
a2977 3
		for( other = RT_LIST_PNEXT( nmg_radial, rad );
		     RT_LIST_NOT_HEAD( other, hd );
		     other = RT_LIST_PNEXT( nmg_radial, other )
d2999 1
a2999 1
				rt_log( "nmg_radial_mark_cracks() EVEN crack eu=x%x, uses=%d, outie=%d\n",
d3003 3
a3005 3
			for( other = RT_LIST_PNEXT( nmg_radial, rad );
			     RT_LIST_NOT_HEAD( other, hd );
			     other = RT_LIST_PNEXT( nmg_radial, other )
d3016 1
a3016 1
				rt_log("Printing loopuse and resulting radial list:\n");
d3027 1
a3027 1
			rt_log( "nmg_radial_mark_cracks() ODD crack eu=x%x, uses=%d, outie=%d\n",
d3035 1
a3035 1
				rt_log("rad->eu=x%x, eu=x%x, uses=%d\n",
d3072 1
a3072 1
struct rt_list		*hd;
d3074 1
a3074 1
CONST struct rt_tol	*tol;
d3081 1
a3081 1
	RT_CK_LIST_HEAD(hd);
d3085 1
a3085 1
	for( RT_LIST_FOR( rad, nmg_radial, hd ) )  {
d3102 1
a3102 1
	for( RT_LIST_FOR( rad, nmg_radial, hd ) )  {
d3117 1
a3117 1
	for( RT_LIST_FOR( rad, nmg_radial, hd ) )  {
d3130 1
a3130 1
	rt_log("nmg_radial_find_an_original() shell=x%x\n", s);
d3145 1
a3145 1
struct rt_list		*hd;
d3147 1
a3147 1
CONST struct rt_tol	*tol;
d3155 1
a3155 1
	RT_CK_LIST_HEAD(hd);
d3157 1
a3157 1
	RT_CK_TOL(tol);
d3182 1
a3182 1
		rad = RT_LIST_PPREV_CIRC( nmg_radial, orig );
d3186 1
a3186 1
			for( RT_LIST_FOR( rad, nmg_radial, hd ) )  {
d3198 1
a3198 1
	for( RT_LIST_FOR_CIRC( rad, nmg_radial, orig ) )  {
d3209 1
a3209 1
			rt_log("nmg_radial_mark_flips() Mis-match detected, setting flip flag eu=x%x\n", rad->eu);
d3218 1
a3218 1
		rt_log("nmg_radial_mark_flips() NOTICE dangling fu=x%x detected at eu=x%x in shell=x%x, proceeding.\n  %g %g %g --- %g %g %g\n",
d3230 1
a3230 1
	rt_log("nmg_radial_mark_flips() unable to establish proper orientation parity.\n  eu count=%d, shell=x%x, expectation=%d\n",
d3245 3
a3247 3
CONST struct rt_list	*hd;
CONST struct nmg_ptbl	*shells;
CONST struct rt_tol	*tol;
d3256 3
a3258 3
	RT_CK_LIST_HEAD(hd);
	NMG_CK_PTBL(shells);
	RT_CK_TOL(tol);
d3260 2
a3261 2
	for( sp = (struct shell **)NMG_TBL_LASTADDR(shells);
 	     sp >= (struct shell **)NMG_TBL_BASEADDR(shells); sp-- 
d3275 1
a3275 1
		for( RT_LIST_FOR_CIRC( rad, nmg_radial, orig ) )  {
d3284 1
a3284 1
			rt_log("nmg_radial_check_parity() bad parity eu=x%x, s=x%x\n",
d3292 1
a3292 1
		rt_log("nmg_radial_check_parity() bad parity at END eu=x%x, s=x%x\n",
d3307 2
a3308 2
struct rt_list		*hd;
CONST struct rt_tol	*tol;		/* for printing */
d3316 2
a3317 2
	RT_CK_LIST_HEAD(hd);
	RT_CK_TOL(tol);
d3320 1
a3320 1
		rt_log("nmg_radial_implement_decisions() BEGIN\n");
d3324 1
a3324 1
	for( RT_LIST_FOR( rad, nmg_radial, hd ) )  {
d3329 1
a3329 1
		prev = RT_LIST_PPREV_CIRC( nmg_radial, rad );
d3341 1
a3341 1
			rt_log("Before -- ");
d3359 1
a3359 1
			rt_log("After -- ");
d3365 1
a3365 1
			rt_log("nmg_radial_implement_decisions() %d remaining, go again\n", skipped);
d3370 1
a3370 1
		rt_log("nmg_radial_implement_decisions() END\n");
d3392 1
a3392 1
	rt_log("%s%8.8x, mate of \\/\n",
d3396 1
a3396 1
	rt_log("%s%8.8x, f=%8.8x, fu=%8.8x=%c, s=%8.8x %s %c%c%c %g deg\n",
d3405 1
a3405 1
		rad->ang * rt_radtodeg
d3416 2
a3417 2
CONST struct rt_list	*hd;
CONST struct rt_tol	*tol;		/* for printing */
d3421 2
a3422 2
	RT_CK_LIST_HEAD(hd);
	RT_CK_TOL(tol);
d3424 1
a3424 1
	rt_log("nmg_pr_radial_list( hd=x%x )\n", hd);
d3426 1
a3426 1
	for( RT_LIST_FOR( rad, nmg_radial, hd ) )  {
d3441 1
a3441 1
struct rt_list *hd;
d3444 1
a3444 1
	struct rt_tol	tol;
d3446 1
a3446 1
		tol.magic = RT_TOL_MAGIC;
d3452 1
a3452 1
	RT_CK_LIST_HEAD( hd );
d3454 2
a3455 2
	start_same = RT_LIST_FIRST( nmg_radial, hd );
	while( RT_LIST_NOT_HEAD( &start_same->l, hd ) )
d3464 1
a3464 1
			start_same = RT_LIST_PNEXT( nmg_radial, &start_same->l );
d3468 1
a3468 1
		end_same = RT_LIST_PNEXT_CIRC( nmg_radial, &start_same->l );
d3471 2
a3472 2
			end_same = RT_LIST_PNEXT_CIRC( nmg_radial, &end_same->l );
		end_same = RT_LIST_PPREV_CIRC( nmg_radial, &end_same->l );
d3476 1
a3476 1
			start_same = RT_LIST_PNEXT( nmg_radial, &start_same->l );
d3481 1
a3481 1
		next_after_same = RT_LIST_PNEXT_CIRC( nmg_radial, &end_same->l );
d3483 1
a3483 1
			next_after_same = RT_LIST_PNEXT_CIRC( nmg_radial, &next_after_same->l );
d3496 1
a3496 1
				same = RT_LIST_PPREV_CIRC( nmg_radial, &same->l );
d3504 1
a3504 1
				check = RT_LIST_PNEXT_CIRC( nmg_radial, &check->l );
d3514 3
a3516 3
				start_same = RT_LIST_PNEXT_CIRC( nmg_radial, &start_same->l );
				RT_LIST_DEQUEUE( &same->l );
				RT_LIST_APPEND( &end_same->l, &same->l );
d3521 1
a3521 1
				end_same = RT_LIST_PPREV_CIRC( nmg_radial, &end_same->l );
d3525 2
a3526 2
				RT_LIST_DEQUEUE( &same->l );
				RT_LIST_APPEND( &end_same->l, &same->l );
d3529 1
a3529 1
			check = RT_LIST_PNEXT_CIRC( nmg_radial, &check->l );
d3532 1
a3532 1
		start_same = RT_LIST_PNEXT( nmg_radial, &end_same->l );
d3544 1
a3544 1
struct rt_list *hd;
d3547 1
a3547 1
CONST struct rt_tol *tol;
d3554 1
a3554 1
	RT_CK_LIST_HEAD( hd );
d3556 1
a3556 1
	RT_CK_TOL( tol );
d3559 1
a3559 1
		rt_log( "nmg_do_radial_join() START\n" );
d3566 1
a3566 1
		rt_log( "ref_dir = ( %g %g %g )\n", V3ARGS( ref_dir ) );
d3572 1
a3572 1
		rt_log( "At top of nmg_do_radial_join:\n" );
d3577 1
a3577 1
	for( RT_LIST_FOR( rad, nmg_radial, hd ) )
d3587 1
a3587 1
		prev = RT_LIST_PPREV_CIRC( nmg_radial, rad );
d3615 1
a3615 1
			rt_log("Before -- ");
d3621 1
a3621 1
				rt_log( "dest_dir disagrees with eu1ref\n" );
d3623 1
a3623 1
				rt_log( "dest_dir agrees with eu1ref\n" );
d3626 1
a3626 1
				rt_log( "src_dir disagrees with eu1ref\n" );
d3628 1
a3628 1
				rt_log( "src_dir agrees with eu1ref\n" );
d3630 1
a3630 1
			rt_log( "Joining dest_eu=x%x to src_eu=x%x\n", dest, src );
d3637 1
a3637 1
			rt_log("After -- ");
d3646 1
a3646 1
		rt_log( "nmg_do_radial_join() DONE\n\n" );
d3659 1
a3659 1
CONST struct rt_tol	*tol;
d3668 3
a3670 3
	struct rt_list		list1;
	struct rt_list		list2;
	struct nmg_ptbl		shell_tbl;
d3676 1
a3676 1
	RT_CK_TOL(tol);
d3685 1
a3685 1
	if( rt_pt3_pt3_equal( eu1->vu_p->v_p->vg_p->coord,
d3733 3
a3735 3
	RT_LIST_INIT( &list1 );
	RT_LIST_INIT( &list2 );
	nmg_tbl( &shell_tbl, TBL_INIT, 0 );
d3748 1
a3748 1
		rt_log("nmg_radial_join_eu_NEW(eu1=x%x, eu2=x%x) e1=x%x, e2=x%x\n",
d3752 1
a3752 1
		rt_log( "Faces around eu1:\n" );
d3756 1
a3756 1
		rt_log( "Faces around eu2:\n" );
d3765 1
a3765 1
	if( count1 || count2 ) rt_log("nmg_radial_join_eu_NEW() bad parity at the outset, %d, %d\n", count1, count2);
d3779 2
a3780 2
		rt_log( "Before nmg_do_radial_join():\n" );
		rt_log( "xvec=(%g %g %g), yvec=(%g %g %g), zvec=(%g %g %g)\n" , V3ARGS( xvec ), V3ARGS( yvec ), V3ARGS( zvec ) );
d3786 3
a3788 3
	nmg_tbl( &shell_tbl, TBL_FREE, 0 );
	while( RT_LIST_WHILE( rad, nmg_radial, &list1 ) )  {
		RT_LIST_DEQUEUE( &rad->l );
d3796 2
a3797 2
	for( sp = (struct shell **)NMG_TBL_LASTADDR(&shell_tbl);
 	     sp >= (struct shell **)NMG_TBL_BASEADDR(&shell_tbl); sp-- 
d3803 2
a3804 2
		rt_log("marked list:\n");
		rt_log("  edge: %g %g %g -> %g %g %g\n",
d3818 1
a3818 1
	if( count1 )  rt_log("nmg_radial_join_eu_NEW() bad parity at completion, %d\n", count1);
d3832 2
a3833 2
struct rt_list		*hd;
CONST struct rt_tol	*tol;		/* for printing */
d3839 2
a3840 2
	RT_CK_LIST_HEAD(hd);
	RT_CK_TOL(tol);
d3842 1
a3842 1
	for( RT_LIST_FOR( rad, nmg_radial, hd ) )  {
d3885 1
a3885 1
CONST struct rt_tol	*tol;
d3887 1
a3887 1
	struct nmg_ptbl	edges;
d3889 1
a3889 1
	struct rt_list	list;
d3894 1
a3894 1
	RT_CK_TOL(tol);
d3897 1
a3897 1
		rt_log("nmg_s_radial_harmonize( s=x%x ) BEGIN\n", s);
d3900 2
a3901 2
	for( ep = (struct edge **)NMG_TBL_LASTADDR(&edges);
	     ep >= (struct edge **)NMG_TBL_BASEADDR(&edges); ep--
d3910 1
a3910 1
		RT_LIST_INIT( &list );
d3912 1
a3912 1
		nmg_radial_build_list( &list, (struct nmg_ptbl *)NULL, 1, eu, xvec, yvec, zvec, tol );
d3916 1
a3916 1
				rt_log("Flips needed:\n");
d3926 2
a3927 2
		while( RT_LIST_WHILE( rad, nmg_radial, &list ) )  {
			RT_LIST_DEQUEUE( &rad->l );
d3932 1
a3932 1
	nmg_tbl( &edges, TBL_FREE, 0 );
d3935 1
a3935 1
		rt_log("nmg_s_radial_harmonize( s=x%x ) END\n", s);
d3951 1
a3951 1
CONST struct rt_tol	*tol;
d3953 1
a3953 1
	struct rt_list	list;
d3963 1
a3963 1
	RT_CK_TOL(tol);
d3966 1
a3966 1
		rt_log("nmg_eu_radial_check(eu=x%x, s=x%x)\n", eu, s);
d3973 1
a3973 1
	RT_LIST_INIT( &list );
d3983 1
a3983 1
		rt_log("nmg_eu_radial_check(x%x) %d flips needed\n  %g %g %g --- %g %g %g\n",
d3998 1
a3998 1
			for( RT_LIST_FOR( rad, nmg_radial, &list ) )
d4004 2
a4005 2
	while( RT_LIST_WHILE( rad, nmg_radial, &list ) )  {
		RT_LIST_DEQUEUE( &rad->l );
d4020 1
a4020 1
CONST struct rt_tol	*tol;
d4022 1
a4022 1
	struct nmg_ptbl	edges;
d4024 1
a4024 1
	struct rt_list	list;
d4029 1
a4029 1
	RT_CK_TOL(tol);
d4032 1
a4032 1
		rt_log("nmg_s_radial_check( s=x%x ) BEGIN\n", s);
d4035 2
a4036 2
	for( ep = (struct edge **)NMG_TBL_LASTADDR(&edges);
	     ep >= (struct edge **)NMG_TBL_BASEADDR(&edges); ep--
d4043 1
a4043 1
	nmg_tbl( &edges, TBL_FREE, 0 );
d4046 1
a4046 1
		rt_log("nmg_s_radial_check( s=x%x ) END\n", s);
d4055 1
a4055 1
CONST struct rt_tol	*tol;
d4060 1
a4060 1
	RT_CK_TOL(tol);
d4063 1
a4063 1
		rt_log("nmg_r_radial_check( r=x%x )\n", r);
d4065 1
a4065 1
	for( RT_LIST_FOR( s, shell, &r->s_hd ) )  {
@


11.41
log
@Minor Mods for IRIX 6.2
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 11.40 1996/05/16 22:08:35 jra Exp jra $ (ARL)";
d2068 1
a2068 1
	char *magic_type;
d2076 1
a2076 1
	magic_type = rt_identify_magic( *magic_p );
@


11.40
log
@Added nmg_do_radial_flips() to sort egdes at same radial angle.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 11.39 1996/05/07 14:10:10 jra Exp jra $ (ARL)";
d48 1
d117 3
a119 3
		CONST register struct edgeuse	*eu;
		CONST register struct loopuse	*lu;
		CONST register struct faceuse	*fu;
d793 1
a793 1
CONST struct egde_g_cnurb *cnrb;
d2877 2
d2900 2
d2916 2
a2917 2
	CONST register struct edgeuse	*neu;
	CONST register struct edge	*e;
d3133 2
d3234 2
d3343 2
a3344 2
			nmg_pr_radial("prev:", prev);
			nmg_pr_radial(" rad:", rad);
d3376 1
a3376 1
int		/* XXX should be void */
d3521 1
a3521 1
				end_same == RT_LIST_PPREV_CIRC( nmg_radial, &end_same->l );
d3762 1
a3766 1
#if 0
d3792 1
a3792 1
#endif
d3820 1
a3820 1
#if 0
a3822 13
	/* Ensure that all edgeuses are using the "best_eg" line */
	for( RT_LIST_FOR( rad, nmg_radial, &list1 ) )  {
		if( rad->eu->g.lseg_p != best_eg )  {
			nmg_use_edge_g( rad->eu, &best_eg->l.magic );
		}
	}

	/* Clean up */
	nmg_tbl( &shell_tbl, TBL_FREE, 0 );
	while( RT_LIST_WHILE( rad, nmg_radial, &list1 ) )  {
		RT_LIST_DEQUEUE( &rad->l );
		rt_free( (char *)rad, "nmg_radial" );
	}
d3912 1
a3912 1
		nmg_radial_build_list( &list, NULL, 1, eu, xvec, yvec, zvec, tol );
d3958 3
d4009 1
@


11.39
log
@Changed nmg_model_break_all_es_on_v() to nmg_break_all_es_on_v() (pass pointer to magic
rather than model pointer).
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 11.38 1996/05/01 13:24:31 jra Exp jra $ (ARL)";
d2695 1
a2695 1
		rt_log("  %g %g %g --- %g %g %g\n",
d3423 104
d3552 2
a3571 2
		struct faceuse *fu_src;
		struct faceuse *fu_dest;
d3588 1
a3588 4
		fu_dest = nmg_find_fu_of_eu( prev->eu );
		fu_src = nmg_find_fu_of_eu( rad->eu );

		if( !fu_dest || !fu_src )
a3593 3
		NMG_CK_FACEUSE( fu_dest );
		NMG_CK_FACEUSE( fu_src );

a3614 1
			rt_log( "dest_fu is %s\n", nmg_orientation( fu_dest->orientation ) );
a3619 1
			rt_log( "src_fu is %s\n", nmg_orientation( fu_src->orientation ) );
@


11.38
log
@Fixed memory leak in nmg_radial_join_eu_NEW().
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 11.37 1996/04/22 12:46:33 jra Exp jra $ (ARL)";
d2059 2
a2060 2
nmg_model_break_all_es_on_v( m, v, tol )
struct model *m;
d2067 1
d2070 1
a2070 1
		rt_log( "nmg_model_break_all_es_on_v( m=x%x, v=x%x )\n", m, v );
a2071 1
	NMG_CK_MODEL( m );
d2075 8
a2082 1
	nmg_edgeuse_tabulate( &eus, &m->magic );
d2109 1
a2109 1
			rt_log("nmg_model_break_all_es_on_v() code=%d, why wasn't this vertex fused?\n", code);
d2116 1
a2116 1
			rt_log( "\tnmg_model_break_all_es_on_v: breaking eu x%x on v x%x\n", eu, v );
@


11.37
log
@Mods I forgot to mention in previous checkin:
   Added nmg_do_radial_join() and modified nmg_radial_join_eu() to use it.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 11.36 1996/04/22 12:40:11 jra Exp jra $ (ARL)";
d2213 1
d3672 7
@


11.36
log
@modified nmg_two_face_fuse() to not force fuse because of shared loop.
modified nmg_model_fuse() to do edge break before face fuse and
call make_faces_within_tol() before face fuse.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 11.35 1996/03/25 21:11:16 jra Exp jra $ (ARL)";
d3414 6
@


11.35
log
@fixed bug in nmg_radial_mark_flips() and added some debugging logs.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 11.34 1996/03/18 00:08:55 jra Exp $ (ARL)";
d1777 1
a1777 1
	if ( count != 0 || rt_g.NMG_debug & DEBUG_BASIC)  {
d1889 1
a1889 1

d1926 13
d2103 1
d2196 4
d2249 8
d2258 2
d2262 21
d2284 2
a2287 3
	/* Step 2.5 -- break edges on vertices, before fusing edges */
	total += nmg_model_break_e_on_v( m, tol );

d2289 2
d2294 2
d3415 115
d3582 2
a3583 1
	if( eu1->eumate_p->radial_p == eu1 && eu2->eumate_p->radial_p == eu2 )
d3656 11
@


11.34
log
@Mods to nmg_is_crack_outie() to avoid tolerancing problems.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 11.33 1996/03/05 21:30:20 jra Exp $ (ARL)";
d39 2
d2055 3
d2093 4
a2096 1
rt_log( "nmg_model_break_all_es_on_v(): breaking eu x%x(mate=x%x, e=x%x) at vertex x%x\n", eu, eu->eumate_p, eu->e_p, v );
d3098 6
d3127 1
d3696 10
a3705 6
if (rt_g.NMG_debug)
{
	nmg_stash_model_to_file( "radial_check.g", nmg_find_model( &eu->l.magic ), "error" );
	for( RT_LIST_FOR( rad, nmg_radial, &list ) )
		nmg_pr_fu_briefly( rad->fu, "" );
}
@


11.33
log
@Added nmg_model_break_all_es_on_v().
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 11.31 1996/01/17 18:15:18 jra Exp $ (ARL)";
d2088 1
d2745 1
a2745 1
	if( diff_len < 3 * tol->dist )  {
a2755 1
		tmp_tol.dist = diff_len/3.0;
d2763 8
a2770 1
		if( !NEAR_ZERO( dist, tmp_tol.dist ) )
d2772 2
a2773 3
			/* our midpt is not within tolerance of face */
			/* Let's move it */
			VJOIN1( midpt, midpt , -dist, pl )
a2781 3
	else
		class = nmg_class_pt_lu_except( midpt, lu, e, tol );

d3464 1
d3466 3
a3685 1
	rt_bomb("nmg_eu_radial_check\n");
@


11.32
log
@Removed excessive logging from nmg_ck_fu_verts().
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 11.31 1996/01/17 18:15:18 jra Exp jra $ (ARL)";
d1775 1
a1775 1
	if (rt_g.NMG_debug & DEBUG_BASIC)  {
d2043 52
d2750 3
d2756 13
d2785 1
a2785 1
		if( class == NMG_CLASS_AinB )
d2791 1
a2791 1
		if( class == NMG_CLASS_AinB )
d3493 1
a3493 1

d3495 1
a3495 1

d3665 1
d3677 2
@


11.31
log
@A feeble attempt at fusing TNURB edges.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 11.30 1995/12/02 03:09:46 mike Exp jra $ (ARL)";
d1775 1
a1775 1
	if ( count != 0 || rt_g.NMG_debug & DEBUG_BASIC)  {
@


11.30
log
@edge_g_lseg got an rt_list structure, for symmetry with edge_g_cnurb.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 11.28 1995/05/05 21:00:26 jra Exp $ (ARL)";
d36 1
d47 1
d50 1
d391 850
d1264 5
d1281 2
d1298 60
d1362 4
d1369 3
d1377 1
d1379 69
a1447 2
			if( (v2a == v1a && v2b == v1b) ||
			    (v2b == v1a && v2a == v1b) )  {
d1450 113
a1562 1
			 }
d2091 2
d3327 7
@


11.29
log
@cnurb edges can start and end on same vertex, after having taken a long trip
through parameter space.
@
text
@d525 2
a526 2
	nmg_pr_eg( &eg1->magic, 0 );
	nmg_pr_eg( &eg2->magic, 0 );
d561 1
a561 1
		if( eg1->magic == NMG_EDGE_G_CNURB_MAGIC )  {
d575 1
a575 1
			if( eg2->magic == NMG_EDGE_G_CNURB_MAGIC )  continue;
d2315 1
a2315 1
			nmg_use_edge_g( rad->eu, &best_eg->magic );
@


11.28
log
@Modified nmg_is_crack_outie() to use a temporary tolerance structure
when the crack is less than 3*tol->dist long.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 11.27 1995/05/04 23:02:19 jra Exp jra $ (ARL)";
d416 1
d424 10
a433 4
			/* 0-length edge.  Eliminate. */
			/* These should't happen, but need fixing. */
			if( nmg_keu( eu1 ) )  {
				rt_log("nmg_model_edge_fuse() WARNING:  deletion of 0-length edgeuse=x%x caused parent to go empty.\n", eu1);
d435 1
a435 4
			rt_log("nmg_model_edge_fuse() 0-length edgeuse=x%x deleted\n", eu1);
			/* XXX no way to know where edgeuse mate will be */
			nmg_tbl( &eutab, TBL_FREE, 0 );
			goto again;
@


11.27
log
@Removed unecessary nmg_tbl( &new_edgeuses, TBL_INS, &eu->l.magic ) from nmg_model_break_e_on_v()
and reset vertex vb after edge break.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 11.26 1995/04/04 13:23:46 jra Exp jra $ (ARL)";
d1557 1
d1578 12
a1589 1
	if( MAGNITUDE(diff) < 3 * tol->dist )  {
d1593 1
d1595 2
a1596 2
	
	class = nmg_class_pt_lu_except( midpt, lu, e, tol );
@


11.26
log
@Added some missing nmg_tbl( XXX, TBL_FREE, 0 ) class.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 11.25 1995/03/29 20:39:34 jra Exp jra $ (ARL)";
d1012 3
a1014 1
				nmg_tbl( &new_edgeuses, TBL_INS, &eu->l.magic );
@


11.25
log
@Fixed another possible infinite loop in nmg_radial_build_list().
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 11.24 1995/03/22 20:39:29 jra Exp jra $ (ARL)";
d1019 1
@


11.24
log
@nmg_model_break_e_on_v Needed to look at both edgeuses resulting from an nmg_ebreak().
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 11.23 1995/03/17 14:58:16 jra Exp jra $ (ARL)";
d1328 1
d1335 1
a1335 1
	if( rt_g.NMG_debug & DEBUG_BASIC )
d1370 3
d1399 11
a1409 6
#if 0
rt_log("amin=%g min_eu=x%x, amax=%g max_eu=x%x\n",
rmin->ang * rt_radtodeg, rmin->eu,
rmax->ang * rt_radtodeg, rmax->eu );
{
	struct nmg_radial *next;
a1410 4
	for( RT_LIST_FOR( next, nmg_radial, hd ) )
		rt_log( "%x: eu=%x, fu=%x, ang=%g\n" , next, next->eu, next->fu, next->ang );
}
#endif
d1412 1
a1414 1
		struct nmg_radial	*first;
a1415 1
		first = rmax;
d1429 1
a1431 1
		struct nmg_radial	*first;
a1432 1
		first = rmin;
@


11.23
log
@Changed nmg_ck_fu_verts() to complain if vertices are more than 1.0*tol->dist off plane.
Changed nmg_radial_build_list() to avoid infinite loops
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 11.22 95/03/08 13:07:39 jra Exp Locker: jra $ (ARL)";
d1010 1
a1010 1
				/* Put new edge into follow-on list */
d1012 1
@


11.22
log
@nmg_radial_build_list(): fixed to avoid infinite loop on list with only one entry.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 11.21 95/03/05 17:28:11 mike Exp Locker: jra $ (ARL)";
d597 1
d608 1
a608 1
 *	0	All is well, or all verts are within 10*tol->dist of fu2
d610 1
a610 1
 *		more than 10*tol->dist from fu2.
d670 1
a670 1
	if( worst > 10.0*tol->dist )
d1323 2
d1348 1
d1388 1
a1388 1
	if( hd->forw == hd->back )
d1390 1
a1390 1
		/* only one entry in list */
d1393 1
a1393 1
	
d1398 6
d1408 1
d1410 1
d1415 1
d1417 3
d1426 3
d1433 1
d1435 7
d2465 5
a2469 1
if (rt_g.NMG_debug)  rt_bomb("nmg_eu_radial_check\n");
@


11.21
log
@Minor improvements
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 11.20 95/03/03 23:46:11 mike Exp Locker: mike $ (ARL)";
d1382 1
d1384 6
@


11.20
log
@Changed nmg_eu_radial_check() to return exit code compatible
with nmg_check_radial(), so it could be substituted for it.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 11.19 95/03/03 23:27:08 mike Exp $ (ARL)";
d1723 4
a1726 1
rt_log("rad->eu=x%x, eu=x%x, uses=%d\n", rad->eu, eu, uses);
a1895 2
	if( expected_ot == (orig->fu->orientation == OT_SAME) )
		return nflip;
d1904 1
a1904 1
		return 0;
d1906 3
@


11.19
log
@A few final bugs fixed.
It seems to be basically working now.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 11.18 95/03/03 22:37:43 mike Exp Locker: mike $ (ARL)";
d1537 1
d1539 1
a1539 1
		rt_bomb("nmg_is_crack_outie() edge is too short to bisect\n");
d2382 4
d2387 1
a2387 1
int		/* XXX should be void */
d2402 4
d2435 1
@


11.18
log
@Added nmg_is_crack_outie(), and all the support for distinguishing
"innie" from "outie" cracks.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 11.17 95/03/03 14:47:36 jra Exp Locker: mike $ (ARL)";
a1016 1
#if 0
a1017 1
#endif
d1593 4
a1596 1
 *			N M G _ F I N D _ N E X T _ U S E _ O F _ E _ I N _ L U
d1599 1
a1599 1
nmg_find_next_use_of_e_in_lu( eu )
d1601 2
d1609 2
a1610 2
	e = eu->e_p;
	NMG_CK_EDGE(e);
d1615 1
a1615 1
	} while( neu->e_p != e );
d1637 1
a1637 1
nmg_radial_mark_cracks( hd, tol )
d1639 2
d1651 2
d1721 5
a1725 2
			eu = nmg_find_next_use_of_e_in_lu( eu );
			if( eu == rad->eu )
d1727 1
d1734 1
d1736 4
a1739 2
		eu = nmg_find_next_use_of_e_in_lu( eu );
		if( eu != rad->eu )
d1741 1
d2220 1
a2220 1
	nmg_radial_mark_cracks( &list1, tol );
d2406 1
a2406 1
	nmg_radial_mark_cracks( &list, tol );
@


11.17
log
@nmg_radial_mark_cracks() now looks at lumates also.
nmg_radial_mark_flips() skips cracks.
nmg_eu_radial_check() skips cracks.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 11.16 95/03/02 19:43:22 jra Exp Locker: jra $ (ARL)";
d1084 1
d1221 1
d1364 1
d1458 160
d1623 1
a1623 1
 *  XXX - To be a crack the two edgeuses must be from the same loopuse!!!!!!
d1625 7
a1631 8
 *  XXX This approach is overly simplistic, as a legal face can have
 *  an even number of crack-pairs, and 0 to 2 non-crack edges, i.e.
 *  edges which border actual surface area.
 *  Telling the difference takes real work.
 *
 *  XXX Worse still, this approach does not distinguish between
 *  an edge cutting across a face, -vs- a pair of crack edges. :-(
 *  Good thing this flag bit isn't used for anything yet!
d1640 4
d1652 2
d1655 5
a1659 2
		other = RT_LIST_PNEXT( nmg_radial, rad );
		while( RT_LIST_NOT_HEAD( other, hd ) )  {
d1661 32
a1692 7
#if 0
			if( other->fu->f_p == rad->fu->f_p )  {
#else /* just get edgeuses from the same loopuse */
			if( other->eu->up.lu_p == rad->eu->up.lu_p || other->eu->up.lu_p->lumate_p == rad->eu->up.lu_p )
			{
#endif
				rad->is_crack = 1;
d1694 1
a1694 4
				if (rt_g.NMG_debug & DEBUG_MESH_EU )
					rt_log( "nmg_radial_mark_cracks() Crack discovered at eu's x%x and x%x\n",
						rad->eu, other->eu );
				/* And the search continues to end of list */
d1696 6
a1701 1
			other = RT_LIST_PNEXT( nmg_radial, other );
d1703 27
a1730 2

	/* XXX Go back and un-mark any edgeuses which acutally border surface area */
d1754 1
d1759 4
a1762 1
		if( rad->is_crack )  continue;	/* skip cracks */
d1768 3
d1774 1
a1774 1
		if( rad->is_crack )  {
d1776 1
a1776 1
			continue;	/* skip cracks */
d1789 2
a1790 2
		if( rad->is_crack )  {
			continue;	/* skip cracks */
d1820 1
a1820 1
	int			count = 1;
d1829 4
d1857 1
d1862 1
a1862 1
		if( rad->is_crack ) continue;	/* skip cracks */
d1880 1
a1880 1
	if( count == 1 )  {
d1886 1
d1930 1
d1936 1
a1936 1
			if( rad->is_crack ) continue;	/* skip cracks */
d2054 1
a2054 1
	rt_log("%s%8.8x, f=%8.8x, fu=%8.8x=%c, s=%8.8x %s %c%c %g deg\n",
d2060 1
d2062 1
a2062 1
		rad->needs_flip ? 'F' : '/',
@


11.16
log
@Added nmg_insure_radial_list_is_increasing() and modified nmg_radial_mark_cracks().
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 11.15 95/03/02 14:34:15 mike Exp Locker: jra $ (ARL)";
d1493 1
a1493 1
			if( other->eu->up.lu_p == rad->eu->up.lu_p )
d1627 1
d1699 1
d1966 1
a1966 1
#if 1
a1967 1
#endif
d2152 2
@


11.15
log
@Added nmg_r_radial_check().
Made more of the printing relative to the reference edgeuse.
Made the checker use the OT_SAME edgeuse as it's reference.
I'm not sure if either of these measures are necessary, but...
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 11.14 95/03/02 13:04:39 mike Exp Locker: mike $ (ARL)";
d1216 64
d1374 2
d1460 2
d1485 1
d1489 2
d1492 4
d1498 3
d1964 1
a1964 1
#if 0
@


11.14
log
@Made printing conditional on DEBUG_MESH_EU
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 11.13 95/03/02 12:41:42 mike Exp $ (ARL)";
d1360 1
a1360 1
		nmg_pr_fu_around_eu_vecs( rmin->eu, xvec, yvec, zvec, tol );
a1866 1
		nmg_euprint("\t     to", eu2);
d1868 1
a1868 1
		nmg_pr_fu_around_eu_vecs( eu1, xvec, yvec, zvec, tol );
d1872 1
a1872 1
		nmg_pr_fu_around_eu_vecs( eu2, xvec, yvec, zvec, tol );
d2060 1
d2065 2
d2129 22
@


11.13
log
@Changed to use eu1ref and eu2ref, anchored to xvec yvec zvec coordinate
system, for angle calcuations.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 11.12 95/03/02 10:10:50 mike Exp Locker: mike $ (ARL)";
d1266 2
a1267 1
rt_log("nmg_radial_build_list( existing=%d, eu=x%x )\n", existing, eu );
d1681 6
a1686 6
#if 1
rt_log("Before -- ");
nmg_pr_fu_around_eu_vecs( eu1, xvec, yvec, zvec, tol );
nmg_pr_radial("prev:", prev);
nmg_pr_radial(" rad:", rad);
#endif
d1699 4
a1702 4
#if 1
rt_log("After -- ");
nmg_pr_fu_around_eu_vecs( eu1, xvec, yvec, zvec, tol );
#endif
a1706 1
rt_log("nmg_radial_implement_decisions() %d remaining, go again\n", skipped);
a1895 6
#if 1
rt_log("marked list:\n");
rt_log("  edge: %g %g %g -> %g %g %g\n",
	V3ARGS(eu1ref->vu_p->v_p->vg_p->coord), V3ARGS(eu1ref->eumate_p->vu_p->v_p->vg_p->coord) );
nmg_pr_radial_list( &list1, tol );
#endif
d1897 8
a1906 5
#if 0
	/* How did it come out? */
	nmg_pr_radial_list( &list1, tol );
	nmg_pr_fu_around_eu_vecs( eu1ref, xvec, yvec, zvec, tol );
#endif
d1908 2
d2074 1
a2074 1
		rt_log("nmg_eu_radial_check(x%s) %d flips needed\n  %g %g %g --- %g %g %g\n",
@


11.12
log
@Various extra checking routines, etc.
Snapshot, in case I botch something.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 11.11 95/03/02 04:19:44 mike Exp Locker: mike $ (ARL)";
d1266 2
d1683 2
d1715 35
a1759 2
	struct face		*f;
	int			orient;
d1768 1
a1768 16
		if( !rad->fu )  {
			f = (struct face *)NULL;
			orient = 'W';
		} else {
			f = rad->fu->f_p;
			orient = nmg_orientation(rad->fu->orientation)[3];
		}
		rt_log(" %8.8x, f=%8.8x, fu=%8.8x=%c, s=%8.8x %s %c%c %g deg\n",
			rad->eu,
			f, rad->fu, orient,
			rad->s,
			rad->existing_flag ? "old" : "new",
			rad->is_crack ? 'C' : '/',
			rad->needs_flip ? 'F' : '/',
			rad->ang * rt_radtodeg
		);
d1784 2
a1785 1
	struct edgeuse		*euref;		/* reference eu for eu1 */
d1833 1
a1833 1
			euref = eu1;
d1835 1
a1835 1
			euref = eu1->eumate_p;
d1838 1
a1838 1
		euref = nmg_find_ot_same_eu_of_e(eu1->e_p);
d1840 6
a1845 1
	nmg_eu_2vecs_perp( xvec, yvec, zvec, euref, tol );
d1852 2
a1853 2
	nmg_radial_build_list( &list1, &shell_tbl, 1, eu1, xvec, yvec, zvec, tol );
	nmg_radial_build_list( &list2, &shell_tbl, 0, eu2, xvec, yvec, zvec, tol );
d1899 1
a1899 1
	V3ARGS(euref->vu_p->v_p->vg_p->coord), V3ARGS(euref->eumate_p->vu_p->v_p->vg_p->coord) );
d1903 1
a1903 1
	nmg_radial_implement_decisions( &list1, tol, euref, xvec, yvec, zvec );
d1908 1
a1908 1
	nmg_pr_fu_around_eu_vecs( euref, xvec, yvec, zvec, tol );
d1911 1
a1911 1
		nmg_pr_fu_around_eu_vecs( euref, xvec, yvec, zvec, tol );
d1917 1
a1917 1
	nmg_eu_radial_check( euref, nmg_find_s_of_eu(eu1), tol );	/* expensive */
@


11.11
log
@nmg_radial_build_list() now preserves original eu ordering exactly.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 11.10 95/03/01 06:20:27 mike Exp Locker: mike $ (ARL)";
d63 29
d1095 2
a1096 4
 *  are added AFTER the existing one.
 *
 *  ??? Should this perhaps build the list in descending order, so
 *  ??? as to match the way that nmg_pr_fu_around_eu_vecs() works?
a1099 1

d1113 8
d1127 1
a1127 1
	if( rad_ang >= cur->ang )  {
d1134 1
d1146 71
d1226 15
d1245 1
a1245 1
struct nmg_ptbl		*shell_tbl;
d1262 1
a1262 1
	NMG_CK_PTBL(shell_tbl);
a1273 2
		/* We depend on ang being strictly in the range 0..2pi */
		rad->ang = nmg_measure_fu_angle( teu, xvec, yvec, zvec );
d1275 16
a1295 9
		if( rad->ang < amin )  {
			amin = rad->ang;
			rmin = rad;
		}
		if( rad->ang > amax )  {
			amax = rad->ang;
			rmax = rad;
		}

d1300 1
a1300 1
		nmg_tbl( shell_tbl, TBL_INS_UNIQUE, &(rad->s->l.magic) );
d1307 6
a1312 1
	/* Increasing, with min or max value repeated */
d1318 23
a1340 4
	while( RT_LIST_PNEXT_CIRC(nmg_radial, rmax)->ang >= amax )
		rmax = RT_LIST_PNEXT_CIRC(nmg_radial, rmax);
	while( RT_LIST_PPREV_CIRC(nmg_radial, rmin)->ang <= amin )
		rmin = RT_LIST_PPREV_CIRC(nmg_radial, rmin);
d1348 1
a1348 8
		/* Verify monotone increasing */
		for( RT_LIST_FOR( rad, nmg_radial, hd ) )  {
			if( rad->ang < amin )  {
				nmg_pr_radial_list( hd, tol );
				rt_bomb("nmg_radial_build_list() not monotone increasing\n");
			}
			amin = rad->ang;
		}
d1350 3
d1357 2
a1358 1
		rt_bomb("nmg_radial_build_list() min and max angle not adjacent in list\n");
d1644 1
a1644 1
nmg_radial_implement_decisions( hd, tol )
d1647 2
d1657 3
d1663 3
d1673 1
d1675 2
a1676 2
		 *  Make rad radial to prev, inserting between
		 *  prev->eu->eumate_p and prev->eu->eumate_p->radial_p.
d1678 5
d1684 5
a1688 3
			nmg_je( prev->eu->eumate_p, rad->eu->eumate_p );
			rad->eu = rad->eu->eumate_p;
			rad->fu = nmg_find_fu_of_eu( rad->eu );
d1691 1
a1691 1
			nmg_je( prev->eu->eumate_p, rad->eu );
d1694 4
d1699 9
a1707 1
	if( skipped )  goto again;
d1721 2
d1731 7
d1739 2
a1740 2
			rad->eu, rad->fu->f_p, rad->fu,
			nmg_orientation(rad->fu->orientation)[3],
d1762 1
d1808 10
a1817 1
	nmg_eu_2vecs_perp( xvec, yvec, zvec, eu1, tol );
d1858 2
d1861 1
d1868 1
a1868 1
#if 0
d1871 1
a1871 1
	V3ARGS(eu1->vu_p->v_p->vg_p->coord), V3ARGS(eu1->eumate_p->vu_p->v_p->vg_p->coord) );
d1875 1
a1875 1
	nmg_radial_implement_decisions( &list1, tol );
d1880 1
a1880 1
	nmg_pr_fu_around_eu_vecs( eu1, xvec, yvec, zvec, tol );
d1883 1
a1883 1
		nmg_pr_fu_around_eu_vecs( eu1, xvec, yvec, zvec, tol );
d1887 1
d1889 2
a1969 1
	struct nmg_ptbl	shell_tbl;
d1988 1
a1988 2
		eu = (*ep)->eu_p;

a1991 1
		nmg_tbl( &shell_tbl, TBL_INIT, 0 );
d1993 1
a1993 1
		nmg_radial_build_list( &list, &shell_tbl, 1, eu, xvec, yvec, zvec, tol );
a2006 1
		nmg_tbl( &shell_tbl, TBL_FREE, 0 );
d2017 83
@


11.10
log
@Changed over to use nmg_s_radial_harmonize()
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 11.9 95/03/01 04:28:42 mike Exp Locker: mike $ (ARL)";
d1112 8
d1135 4
d1145 3
a1159 1
		nmg_radial_sorted_list_insert( hd, rad );
d1161 13
a1173 1
		/* Build list of all shells involved at this edge */
d1179 33
@


11.9
log
@Fixed problem in nmg_radial_sorted_list_insert()
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 11.8 95/02/28 04:15:44 mike Exp Locker: mike $ (ARL)";
d1291 1
a1291 1
 *  For each shell, find an original edgeuse from that shell,
d1294 2
a1295 2
void
nmg_radial_mark_flips( hd, shells, tol )
d1297 1
a1297 1
CONST struct nmg_ptbl	*shells;
a1300 1
	struct shell		**sp;
d1303 2
d1307 1
a1307 1
	NMG_CK_PTBL(shells);
d1310 8
a1317 11
	for( sp = (struct shell **)NMG_TBL_LASTADDR(shells);
 	     sp >= (struct shell **)NMG_TBL_BASEADDR(shells); sp-- 
	)  {
		int	count = 1;

		NMG_CK_SHELL(*sp);
		orig = nmg_radial_find_an_original( hd, *sp, tol );
		NMG_CK_RADIAL(orig);
		if( !orig->existing_flag )  {
			/* There were no originals.  Do something sensible to check the newbies */
			if( !orig->fu )  continue;	/* Nothing but wires */
d1319 12
a1330 13
			/*  Given that there were no existing edgeuses
			 *  from this shell, make our first addition
			 *  oppose the previous radial faceuse, just to be nice.
			 */
			rad = RT_LIST_PPREV_CIRC( nmg_radial, orig );
			/* Hopefully it isn't a wire */
			if( rad->eu->vu_p->v_p == orig->eu->vu_p->v_p )  {
				/* Flip everything, for general compatibility */
				for( RT_LIST_FOR( rad, nmg_radial, hd ) )  {
					if( rad->s != *sp )  continue;
					if( !rad->fu )  continue;	/* skip wires */
					rad->needs_flip = !rad->needs_flip;
				}
d1332 1
d1334 2
a1335 2
		}
		expected_ot = !(orig->fu->orientation == OT_SAME);
d1337 5
a1341 12
		for( RT_LIST_FOR_CIRC( rad, nmg_radial, orig ) )  {
			if( rad->s != *sp )  continue;
			if( !rad->fu )  continue;	/* skip wires */
			count++;
			if( expected_ot == (rad->fu->orientation == OT_SAME) )  {
				expected_ot = !expected_ot;
				continue;
			}
			/* Mis-match detected */
			rt_log("nmg_radial_mark_flips() Mis-match detected, setting flip flag eu=x%x\n", rad->eu);
			rad->needs_flip = !rad->needs_flip;
			/* With this one flipped, set expectation for next */
d1343 1
d1345 25
a1369 6
		if( expected_ot == (orig->fu->orientation == OT_SAME) )
			continue;
		rt_log("nmg_radial_mark_flips() unable to establish proper orientation parity.\n  eu count=%d, shell=x%x, expectation=%d\n",
			count, *sp, expected_ot);
		rt_bomb("nmg_radial_mark_flips() unable to establish proper orientation parity.\n");
 	}
d1527 1
d1607 5
a1611 1
	nmg_radial_mark_flips( &list1, &shell_tbl, tol );
d1626 3
d1645 117
@


11.8
log
@Fixed a few bugs with the new code, still note quite ready yet.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 11.7 95/02/27 16:28:09 jra Exp Locker: mike $ (ARL)";
d1067 3
d1073 1
d1094 1
a1094 1
		RT_LIST_APPEND( hd, &rad->l );
d1100 4
a1103 4
		if( rad_ang < cur->ang )  continue;
		/* rad_ang >= cur */
		RT_LIST_APPEND( &cur->l, &rad->l );
		return;
d1320 16
d1349 1
a1349 2
			/* XXX Should it be flipped, rather than set? */
			rad->needs_flip = 1;
d1454 2
d1598 2
@


11.7
log
@Changed !RT_LIST_EMPTY( &list1 ) to RT_LIST_NON_EMPTY( &list1 ).
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 11.6 95/02/26 10:13:02 mike Exp Locker: jra $ (ARL)";
d43 2
d46 1
d56 5
d62 1
d1103 1
a1103 1
	RT_LIST_INSERT( hd, &rad->l );
d1153 2
d1169 1
a1169 1
	for( RT_LIST_FOR( rad, nmg_radial, src ) )  {
d1185 4
d1216 1
a1216 1
	/* XXX Go back and un-mark cracks which border surface area */
d1220 5
d1227 1
a1227 1
nmg_radial_find_an_original( hd, s )
d1230 1
d1233 1
a1233 1
	struct nmg_radial	*fallback;
d1235 1
d1241 1
d1243 1
d1248 1
d1278 3
d1293 1
a1293 1
struct nmg_ptbl		*shells;
a1296 1
	struct nmg_radial	*other;
a1304 7
/* Process all the list members except hp and the actual head */
#define RT_LIST_FOR_CIRC(p,structure,hp)	\
	(p)=RT_LIST_PNEXT(structure,hp); \
	(p) != (hp) && \
	  (RT_LIST_FIRST_MAGIC((struct rt_list *)(p)) != RT_LIST_HEAD_MAGIC); \
	(p)=RT_LIST_PNEXT(structure,p)

d1311 2
a1312 1
		orig = nmg_radial_find_an_original( hd, *sp );
d1328 1
a1328 1
			rt_log("Mis-match detected, setting flip flag eu=x%x\n", rad->eu);
d1334 41
a1374 5
		rad = RT_LIST_PPREV_CIRC( nmg_radial, orig );
		if( expected_ot != (rad->fu->orientation == OT_SAME) )  {
			rt_log("nmg_radial_mark_flips() unable to establish proper orientation parity.  eu count=%d, shell=x%x\n",
				count, *sp);
			rt_bomb("nmg_radial_mark_flips() unable to establish proper orientation parity.\n");
d1376 21
d1398 1
d1451 1
a1451 1
struct rt_list		*hd;
d1456 3
d1463 1
a1463 1
		rt_log(" %8.8x, f=%8.8x, fu=%8.8x=%s, s=%8.8x %g deg %s %c%c\n",
d1465 6
a1470 5
			nmg_orientation(rad->fu->orientation)+3,
			rad->s, rad->ang,
			rad->existing_flag ? 'old' : 'new',
			rad->is_crack ? 'C' : '-',
			rad->needs_flip ? 'F' : '-'
d1495 1
d1541 7
d1561 1
d1564 4
a1572 1
	nmg_radial_mark_flips( &list1, tol );
d1574 5
a1578 1
	nmg_pr_radial_list( &list1, tol );
d1582 1
d1586 3
a1602 1
	if( RT_LIST_NON_EMPTY( &list1 ) )  rt_bomb("nmg_radial_join_eu_NEW() list2 non-empty\n");
@


11.6
log
@nmg_radial_join_eu_NEW() and it's supporting routines.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 11.5 95/02/25 00:11:21 mike Exp Locker: mike $ (ARL)";
d1500 1
a1500 1
	if( !RT_LIST_EMPTY( &list1 ) )  rt_bomb("nmg_radial_join_eu_NEW() list2 non-empty\n");
@


11.5
log
@Incorporated nmg_model_break_e_on_v()
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 11.4 95/02/24 23:56:17 mike Exp Locker: mike $ (ARL)";
d41 13
a925 2
/* XXX Move to nmg.h */
#define NMG_TBL_LEN(p)	((p)->end)
d1034 467
@


11.4
log
@Random improvement to nmg_is_vertex_in_face()
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 11.3 95/02/21 03:29:32 mike Exp Locker: mike $ (ARL)";
d881 95
d1010 3
@


11.3
log
@Hopefully improved performance, by sharply reducing memory traffic
in the innermost loop.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 11.2 95/01/19 23:39:32 mike Exp Locker: mike $ (ARL)";
d39 2
a40 2
RT_EXTERN(int	 	nmg_is_vertex_in_face, (CONST struct vertex *v,
			CONST struct face *f));
d46 2
a47 2
 *	!0	If there is at least one use of vertex 'v' in face 'f'.
 *	0	If there are no uses of 'v' in 'f'.
d49 1
a49 1
int
d54 1
a54 3
	CONST struct vertexuse	*vu;
	CONST struct loopuse	*lu;
	CONST struct faceuse	*fu;
d60 4
d65 2
a66 2
		if( *vu->up.eu_p->up.magic_p != NMG_LOOPUSE_MAGIC )  continue;
		lu = vu->up.eu_p->up.lu_p;
a68 1
		NMG_CK_FACEUSE(fu);
d70 1
a70 1
		return 1;
d72 1
a72 1
	return 0;
@


11.2
log
@Took out stray rt_log()
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 11.1 95/01/04 09:57:35 mike Rel4_4 Locker: mike $ (ARL)";
d356 3
a358 3
		register struct edgeuse	*eu1;
		register struct edge	*e1;
		struct vertex		*v1a, *v1b;
d382 1
d385 1
a385 1
			register struct edge	*e2;
a387 3
			NMG_CK_EDGEUSE(eu2);
			e2 = eu2->e_p;
			NMG_CK_EDGE(e2);
d389 8
a396 5
			if( e1 == e2 )  continue;	/* Already shared */
			if( (eu2->vu_p->v_p == v1a &&
			     eu2->eumate_p->vu_p->v_p == v1b) ||
			    (eu2->eumate_p->vu_p->v_p == v1a &&
			     eu2->vu_p->v_p == v1b) )  {
@


11.1
log
@Release_4.4
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 1.35 95/01/04 08:07:33 mike Exp $ (ARL)";
a737 1
rt_log("common_bigloop says 'fuse'.\n");
@


1.35
log
@Made chatter conditional on DEBUG_BASIC
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 1.34 94/11/05 01:44:35 mike Exp Locker: mike $ (ARL)";
@


1.34
log
@Irix 6
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 1.33 94/11/04 12:16:53 jra Exp Locker: mike $ (ARL)";
d330 2
a331 1
if(total)rt_log("nmg_model_vertex_fuse() %d\n", total);
d401 2
a402 1
if(total>0)rt_log("nmg_model_edge_fuse(): %d edges fused\n", total);
d539 2
a540 1
if(total>0)rt_log("nmg_model_edge_g_fuse(): %d edge_g_lseg's fused\n", total);
d874 2
a875 1
if(total>0)rt_log("nmg_model_face_fuse: %d faces fused\n", total);
d921 2
a922 1
if(total>0)rt_log("nmg_model_fuse(): %d entities fused\n", total);
@


1.33
log
@Modified calls to nmg_pr_eg to agree with new declaration.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 1.32 94/09/16 23:36:34 mike Exp Locker: jra $ (ARL)";
a148 1
	int	count = 0;
a424 1
	fastf_t		t, u;
a512 1
			register struct edge	**ep;
@


1.32
log
@Added checks for edge_g_cnurb edge geometry showing up.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 1.31 94/09/16 20:45:42 mike Exp Locker: mike $ (ARL)";
d468 2
a469 2
	nmg_pr_eg( eg1, 0 );
	nmg_pr_eg( eg2, 0 );
@


1.31
log
@nmg_move_eg() became nmg_jeg().
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 1.30 94/09/13 20:53:43 mike Exp Locker: mike $ (ARL)";
d38 1
a38 1
/* XXX Move to nmg_info.c */
d41 1
d351 2
d370 12
d402 1
d501 7
d518 2
d840 7
a847 1
		if( !fg1 )  continue;
@


1.30
log
@Fixed bug in nmg_model_edge_g_fuse() seen in Test23.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 1.29 94/09/12 21:34:25 mike Exp $ (ARL)";
d509 1
a509 1
			nmg_move_eg( eg1, eg2 );
@


1.29
log
@Changed to call rt_coplanar(), rather than doing it inline.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 1.28 94/09/12 13:55:45 mike Exp Locker: mike $ (ARL)";
d504 1
a504 1
			 * Make all instances of eg2 become eg1.
d509 3
a511 1
			nmg_move_eg( eg2, eg1 );
@


1.28
log
@Changed common_bigloop to require three different edge geometries.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 1.27 94/09/10 04:36:45 mike Exp Locker: mike $ (ARL)";
d113 1
d121 2
a122 1
				if( eu1->g.magic_p != magic1 && eu1->g.magic_p != magic2 )  {
a666 1
	FAST fastf_t		dist;
d668 1
d711 1
d715 6
a720 13
	/* Compare distances from origin */
	dist = fg1->N[3] - fg2->N[3];
	if( !NEAR_ZERO(dist, tol->dist) )  {
		/* How about with reversed normal? */
		dist = fg1->N[3] + fg2->N[3];
		if( !NEAR_ZERO(dist, tol->dist) )  {
			if (rt_g.NMG_debug & DEBUG_MESH)  {
				rt_log("nmg_two_face_fuse(x%x, x%x) delta dist from origin=%g \n",
					f1, f2, dist);
				PLPRINT(" fg1", fg1->N);
				PLPRINT(" fg2", fg2->N);
			}
			return 0;
d722 6
a727 13
		/* Dist matches, how about direction?
		 * Dot will be -1 if dirs are opposite.
		 */
		dist = -VDOT( fg1->N, fg2->N );
		if( !(dist >= tol->para) )  {
			if (rt_g.NMG_debug & DEBUG_MESH)  {
				rt_log("nmg_two_face_fuse(x%x, x%x) A vdot=%g, tol=%g \n",
					f1, f2, dist, tol->para);
				PLPRINT(" fg1", fg1->N);
				PLPRINT(" fg2", fg2->N);
			}
			return 0;
		}
a728 34
		/* Geometric match, with flipped signs */
		flip2 = 1;
	} else {
		/* Dist matches, how about direction?
		 * Dot will be +1 if dirs are the same.
		 */
		dist = VDOT( fg1->N, fg2->N );
		if( !(dist >= tol->para) )  {
			if( NEAR_ZERO( fg1->N[3], tol->dist ) )  {
				/* Plane runs through origin, need to check both signs */
				if( !(-dist >= tol->para) )  {
					if (rt_g.NMG_debug & DEBUG_MESH)  {
						rt_log("nmg_two_face_fuse(x%x, x%x) B vdot=%g, tol=%g \n",
							f1, f2, dist, tol->para);
						PLPRINT(" fg1", fg1->N);
						PLPRINT(" fg2", fg2->N);
					}
					return 0;
				}
				/* Geometric match, with flipped signs */
				flip2 = 1;
			} else {
				if (rt_g.NMG_debug & DEBUG_MESH)  {
					rt_log("nmg_two_face_fuse(x%x, x%x) C vdot=%g, tol=%g \n",
						f1, f2, dist, tol->para);
					PLPRINT(" fg1", fg1->N);
					PLPRINT(" fg2", fg2->N);
				}
				return 0;
			}
		} else {
			/* Geometric match, same sign */
		}
	}
d730 2
a731 1
		rt_log("nmg_two_face_fuse: plane eqns match, flip2=%d\n", flip2);
@


1.27
log
@Converted NMG data structures to have edge_g pointer in edgeuse, not edge.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 1.26 94/09/03 03:01:12 mike Exp $ (ARL)";
d78 2
d90 2
d94 1
d108 3
d113 11
d129 1
a129 1
		if( nbadv <= 0 && nverts >= 3 )  return 1;
@


1.26
log
@Snapshot of non-working intermediate stage in edge_g evolution.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 1.25 94/09/02 00:31:55 mike Exp Locker: mike $ (ARL)";
d371 1
a371 1
 *			N M G _ 2 E D G E _ G _ C O I N C I D E N T
d373 1
a373 1
 *  Given two edges, determine if they share the same edge geometry,
d382 3
a384 3
nmg_2edge_g_coincident( e1, e2, tol )
CONST struct edge	*e1;
CONST struct edge	*e2;
d391 2
a392 2
	NMG_CK_EDGE(e1);
	NMG_CK_EDGE(e2);
d394 3
a396 2
	eg1 = e1->eg_p;
	eg2 = e2->eg_p;
d410 1
a410 1
	    e2->eu_p->vu_p->v_p->vg_p->coord ) > tol->dist_sq )  goto trouble;
d412 1
a412 1
	    e2->eu_p->eumate_p->vu_p->v_p->vg_p->coord ) > tol->dist_sq )  goto trouble;
d416 1
a416 1
	    e1->eu_p->vu_p->v_p->vg_p->coord ) > tol->dist_sq )  goto trouble;
d418 1
a418 1
	    e1->eu_p->eumate_p->vu_p->v_p->vg_p->coord ) > tol->dist_sq )  goto trouble;
d433 1
a433 1
	rt_log("nmg_2edge_g_coincident() lines colinear, vertex check fails, calling colinear anyway.\n");
d439 4
d456 2
a457 2
	/* Make a list of all the edge structs in the model */
	nmg_edge_tabulate( &etab, &m->magic );
a459 1
		register struct edge	*e1;
d461 1
d463 1
a463 3
		e1 = (struct edge *)NMG_TBL_GET(&etab, i);
		NMG_CK_EDGE(e1);
		eg1 = e1->eg_p;
d465 2
d469 2
a470 2
			register struct edge	*e2;
			struct edge_g_lseg		*eg2;
d473 1
a473 3
			e2 = (struct edge *)NMG_TBL_GET(&etab,j);
			NMG_CK_EDGE(e2);
			eg2 = e2->eg_p;
d475 2
d478 1
a478 2
			if( e1 == e2 )  rt_bomb("nmg_model_edge_g_fuse() two incidences of edge?\n");
			if( eg1 == eg2 )  continue;
d480 1
a480 1
			if( !nmg_2edge_g_coincident( e1, e2, tol ) )  continue;
d488 1
a488 8
			for( ep = (struct edge **)NMG_TBL_LASTADDR(&etab);
			     ep >= (struct edge **)NMG_TBL_BASEADDR(&etab);
			     ep--
			)  {
				if( (*ep)->eg_p != eg2 )  continue;
				/* Change every edge using eg2 to use eg1 */
				nmg_use_edge_g( *ep, eg1 );
			}
@


1.25
log
@Changed to new face geometry pointers (g.plane_p)
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 1.24 94/08/10 18:51:40 gdurf Exp Locker: mike $ (ARL)";
d379 1
a379 1
 *		(For linear edge_g, the 2 are the same line, within tol.)
d387 2
a388 2
	struct edge_g	*eg1;
	struct edge_g	*eg2;
d396 2
a397 2
	NMG_CK_EDGE_G(eg1);
	NMG_CK_EDGE_G(eg2);
d456 1
a456 1
		struct edge_g		*eg1;
d461 1
a461 1
		NMG_CK_EDGE_G(eg1);
d465 1
a465 1
			struct edge_g		*eg2;
d471 1
a471 1
			NMG_CK_EDGE_G(eg2);
d478 1
a478 1
			/* Comitted to fusing two edge_g's.
d495 1
a495 1
if(total>0)rt_log("nmg_model_edge_g_fuse(): %d edge_g's fused\n", total);
@


1.24
log
@fix include order
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 1.23 1994/08/09 19:37:36 mike Exp gdurf $ (ARL)";
d521 1
a521 1
	CONST struct face_g	*fg2;
d532 2
a533 2
	fg2 = f2->fg_p;
	NMG_CK_FACE_G(fg2);
d597 1
a597 1
	struct face_g *fg1;
d607 2
a608 2
	fg1 = fu1->f_p->fg_p;
	NMG_CK_FACE_G( fg1 );
d647 2
a648 2
	register struct face_g	*fg1;
	register struct face_g	*fg2;
d656 2
a657 2
	fg1 = f1->fg_p;
	fg2 = f2->fg_p;
d667 2
a668 2
	NMG_CK_FACE_G(fg1);
	NMG_CK_FACE_G(fg2);
d838 1
a838 1
		register struct face_g	*fg1;
d841 1
a841 1
		fg1 = f1->fg_p;
d843 1
a843 1
		NMG_CK_FACE_G(fg1);
d847 1
a847 1
			PLPRINT(" f1", f1->fg_p->N);
d854 1
a854 1
			register struct face_g	*fg2;
d858 1
a858 1
			fg2 = f2->fg_p;
d860 1
a860 1
			NMG_CK_FACE_G(fg2);
@


1.23
log
@Added GDurf's new "conf.h"
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 1.22 94/07/11 16:16:27 jra Exp Locker: mike $ (ARL)";
d31 1
a32 1
#include "machine.h"
@


1.22
log
@Modified nmg_ck_fu_verts to return 0 unless at least one vert is more than 10*tol->dist from face.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 1.21 94/07/11 16:02:18 jra Exp Locker: jra $ (ARL)";
d28 1
@


1.21
log
@Added nmg_ck_fg_verts and used it to replace a call to nmg_ck_fu_verts in nmg_two_face_fuse.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 1.20 94/07/04 02:47:41 mike Exp Locker: jra $ (ARL)";
d508 3
a510 2
 *	0	All is well.
 *	count	Number of verts *not* on fu2's surface.
d569 5
a573 1
	return count;
@


1.20
log
@Check to make sure that faces being fused are not *too* far apart.
Even if their topology *is* shared.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 1.19 94/07/04 01:31:36 mike Exp Locker: mike $ (ARL)";
d571 46
d678 1
d762 1
a762 1
	if( nmg_ck_fu_verts( f2->fu_p, f1, tol ) != 0 )  {
@


1.19
log
@Added surface normal check before call to nmg_is_common_bigloop().
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 1.18 94/07/04 01:04:37 mike Exp Locker: mike $ (ARL)";
d633 1
@


1.18
log
@Added nmg_is_common_bigloop().
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 1.17 94/07/04 00:03:57 mike Exp Locker: mike $ (ARL)";
d632 2
a633 1
	if( nmg_is_common_bigloop( f1, f2 ) )  {
@


1.17
log
@Added topology check.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 1.16 94/07/03 23:32:05 mike Exp Locker: mike $ (ARL)";
d53 1
d60 5
a64 1
		if( !(fu = nmg_find_fu_of_vu(vu)) )  continue;
d73 42
d504 3
a544 5
		/* Topology check */
		if( nmg_is_vertex_in_face( v, f2 ) )  {
			continue;
		}

d626 15
d720 1
@


1.16
log
@Added debug printing.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 1.15 94/07/02 02:50:51 mike Exp Locker: mike $ (ARL)";
d37 3
d41 27
d495 6
d528 5
@


1.15
log
@Added debugging to nmg_2edge_g_coincident()
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 1.14 94/07/01 23:42:37 mike Exp Locker: mike $ (ARL)";
d631 2
d634 2
d642 3
@


1.14
log
@Released dynamic storage.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 1.13 94/06/30 22:15:01 mike Exp Locker: mike $ (ARL)";
d331 1
a331 1
	    e2->eu_p->vu_p->v_p->vg_p->coord ) > tol->dist_sq )  return 0;
d333 1
a333 1
	    e2->eu_p->eumate_p->vu_p->v_p->vg_p->coord ) > tol->dist_sq )  return 0;
d337 1
a337 1
	    e1->eu_p->vu_p->v_p->vg_p->coord ) > tol->dist_sq )  return 0;
d339 1
a339 1
	    e1->eu_p->eumate_p->vu_p->v_p->vg_p->coord ) > tol->dist_sq )  return 0;
d345 10
@


1.13
log
@improved the colinearity test in nmg_2edge_g_coincident() slightly.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 1.12 94/06/29 00:22:35 mike Exp Locker: mike $ (ARL)";
d329 1
a329 1
	/* Ensure that vertices of both edges are within tol of other eg */
d335 1
d363 1
a363 1
	/* Make a list of all the edgeuse structs in the model */
d406 1
@


1.12
log
@Added nmg_model_edge_g_fuse()
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 1.11 94/03/09 22:26:00 mike Exp Locker: mike $ (ARL)";
a322 1
#if 0
a327 1
#endif
d340 3
a342 12
	/* Ensure that lines are colinear */
	if( rt_isect_line3_line3( &t, &u, eg1->e_pt, eg1->e_dir,
	    eg2->e_pt, eg2->e_dir, tol) != 0 )  {
#if 0
	    	VPRINT("eg1->e_pt ", eg1->e_pt);
	    	VPRINT("eg1->e_dir", eg1->e_dir);
	    	VPRINT("eg2->e_pt ", eg2->e_pt);
	    	VPRINT("eg2->e_dir", eg2->e_dir);
rt_log("nmg_2edge_g_coincident() rejecting on rt_isect_line3_line3()\n");
#endif
		return 0;
	}
@


1.11
log
@Made slightly less noisy.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 1.10 94/03/09 13:00:28 jra Exp Locker: mike $ (ARL)";
d291 1
d293 128
d746 3
@


1.10
log
@Fixed nmg_ck_fu_verts to look for DIST_PT_PLANE < (-tol->dist).
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 1.9 94/03/02 18:59:55 mike Exp Locker: jra $ (ARL)";
d287 1
a287 1
rt_log("nmg_model_edge_fuse(): %d edges fused\n", total);
d575 1
a575 1
rt_log("nmg_model_face_fuse: %d faces fused\n", total);
d618 1
a618 1
rt_log("nmg_model_fuse(): %d entities fused\n", total);
@


1.9
log
@Made debug printing again conditional.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 1.8 94/03/02 18:57:45 mike Exp Locker: mike $ (ARL)";
d336 1
a336 1
		if( dist > tol->dist )  {
d345 2
@


1.8
log
@Added special case for fusing planes that contain the origin.
Changed nmg_region_self_vfuse() to nmg_ptbl_vfuse().
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 1.7 94/03/02 18:18:45 mike Exp Locker: mike $ (ARL)";
d337 1
a337 4
#if 0
			if (rt_g.NMG_debug & DEBUG_MESH)
#endif
			{
@


1.7
log
@split out nmg_two_face_fuse() and nmg_ck_fu_verts().
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 1.6 94/02/22 20:37:41 mike Exp Locker: mike $ (ARL)";
d83 1
a83 1
 *			N M G _ R E G I O N _ S E L F _ V F U S E
d88 1
a88 1
 *  Exists primarily as a support routine for nmg_two_region_vertex_fuse().
d91 1
a91 1
nmg_region_self_vfuse( t, tol )
a118 1
if(count)rt_log("nmg_region_self_vfuse() %d\n", count);
a169 1
if(count)rt_log("nmg_region_both_vfuse() %d\n", count);
d198 1
a198 1
	total = nmg_region_self_vfuse( &t1, tol );
d227 1
a227 1
	total = nmg_region_self_vfuse( &t1, tol );
d231 1
d420 2
d433 2
d447 21
a467 3
			if (rt_g.NMG_debug & DEBUG_MESH)  {
				rt_log("nmg_two_face_fuse(x%x, x%x) B vdot=%g, tol=%g \n",
					f1, f2, dist, tol->para);
d469 2
a470 1
			return 0;
a471 2

		/* Geometric match, same sign */
@


1.6
log
@Made various debug prints conditional on DEBUG_MESH
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 1.5 94/01/25 09:43:59 mike Exp Locker: mike $ (ARL)";
d293 203
d532 7
a541 4
			FAST fastf_t		dist;
			struct nmg_ptbl		vtab;
			int			flip2 = 0;
			int			k;
d551 1
a551 60
			/* Compare distances from origin */
			dist = fg1->N[3] - fg2->N[3];
			if( !NEAR_ZERO(dist, tol->dist) )  {
				/* How about with reversed normal? */
				dist = fg1->N[3] + fg2->N[3];
				if( !NEAR_ZERO(dist, tol->dist) )
					continue;
				/* Dist matches, how about direction?
				 * Dot will be -1 if dirs are opposite.
				 */
				dist = -VDOT( fg1->N, fg2->N );
				if( !(dist >= tol->para) )  continue;

				/* Geometric match, with flipped signs */
				flip2 = 1;
			} else {
				/* Dist matches, how about direction?
				 * Dot will be +1 if dirs are the same.
				 */
				dist = VDOT( fg1->N, fg2->N );
				if( !(dist >= tol->para) )  continue;

				/* Geometric match, same sign */
			}

			/*
			 *  Plane equations match, within tol.
			 *  Before conducting a merge, verify that
			 *  all the verts in f2 are within tol->dist
			 *  of fg1's plane equation.
			 */
			nmg_vertex_tabulate( &vtab, &f2->fu_p->l.magic );

			for( k = NMG_TBL_END(&vtab)-1; k >= 0; k-- )  {
				register struct vertex		*v;
				register struct vertex_g	*vg;
				v = (struct vertex *)NMG_TBL_GET(&vtab, k);
				NMG_CK_VERTEX(v);
				vg = v->vg_p;
				if( !vg )  rt_bomb("nmg_model_face_fuse: vertex with no geometry?\n");

				dist = DIST_PT_PLANE(vg->coord, fg1->N);
				if( dist > tol->dist )  {
					if (rt_g.NMG_debug & DEBUG_MESH)  {
						rt_log("nmg_model_face_fuse: plane eqns equal, v x%x off plane by %e, skipping (f1=x%x, f2=x%x)\n", v, dist, f1, f2);
						VPRINT(" pt", vg->coord);
						PLPRINT(" fg1", fg1->N);
						PLPRINT(" fg2", fg2->N);
					}
					goto next_face;
				}
			}
			/* All points are on the plane, it's OK to fuse */
			if( flip2 == 0 )  {
				if (rt_g.NMG_debug & DEBUG_MESH)  {
					rt_log("joining face geometry (same dir) f1=x%x, f2=x%x\n", f1, f2);
					PLPRINT(" fg1", fg1->N);
					PLPRINT(" fg2", fg2->N);
				}
				nmg_jfg( f1, f2 );
a552 17
			} else {
				register struct face	*fn;

				if (rt_g.NMG_debug & DEBUG_MESH)  {
					rt_log("joining face geometry (opposite dirs)\n");
				}
				/* Flip flags of faces using fg2, first! */
				for( RT_LIST_FOR( fn, face, &fg2->f_hd ) )  {
					NMG_CK_FACE(fn);
					fn->flip = !fn->flip;
				}
				nmg_jfg( f1, f2 );
				total++;
			}

next_face:		
			nmg_tbl( &vtab, TBL_FREE, 0 );
@


1.5
log
@Proper arg types.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 1.4 93/12/17 02:05:22 mike Exp Locker: mike $ (ARL)";
d388 6
a393 4
					rt_log("nmg_model_face_fuse: plane eqns equal, v x%x off plane by %e, skipping (f1=x%x, f2=x%x)\n", v, dist, f1, f2);
					VPRINT(" pt", vg->coord);
					PLPRINT(" fg1", fg1->N);
					PLPRINT(" fg2", fg2->N);
d399 5
a403 3
				rt_log("joining face geometry (same dir) f1=x%x, f2=x%x\n", f1, f2);
				PLPRINT(" fg1", fg1->N);
				PLPRINT(" fg2", fg2->N);
d408 4
a411 1
				rt_log("joining face geometry (opposite dirs)\n");
@


1.4
log
@Added printing of plane equations, for quick visual double-check.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 1.3 93/12/16 05:35:53 mike Exp Locker: mike $ (ARL)";
d252 1
a252 1
	nmg_edgeuse_tabulate( &eutab, m );
d318 1
a318 1
	nmg_face_tabulate( &ftab, m );
@


1.3
log
@Changed to use nmg_vertex_tabulate().
Added nmg_model_face_fuse().
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 1.2 93/12/11 12:09:23 mike Exp Locker: mike $ (ARL)";
d389 3
a391 3
					VPRINT("pt", vg->coord);
					PLPRINT("fg1", fg1->N);
					PLPRINT("fg2", fg2->N);
d397 3
a399 1
				rt_log("joining face geometry (same dir)\n");
@


1.2
log
@First draft at a face fuser
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/nmg_fuse.c,v 1.1 93/12/02 20:11:38 mike Exp Locker: mike $ (ARL)";
d57 1
a57 1
	nmg_region_vertex_list( &t, r1 );
d197 2
a198 2
	nmg_region_vertex_list( &t1, r1 );
	nmg_region_vertex_list( &t2, r2 );
a226 1
/* XXX Change this to nmg_vertex_tabulate( &t1, &m->magic ); */
a227 3
#if 0
	nmg_model_vertex_list( &t1, m );
#endif
d237 57
a293 1
 *		N M G _ M O D E L _ F A C E _ F U S E
d318 1
a318 1
	nmg_model_face_list( &ftab, m );
d387 7
a393 1
				if( dist > tol->dist )  goto next_face;
d412 2
a413 1
next_face:		;
d416 3
d437 3
d458 1
d460 1
@


1.1
log
@Initial revision
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
d227 3
d231 1
d236 157
@
