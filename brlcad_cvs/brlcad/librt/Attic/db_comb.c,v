head	1.64;
access;
symbols
	ansi-20040405-merged:1.60.2.2
	postmerge-20040405-ansi:1.62
	premerge-20040404-ansi:1.61
	postmerge-autoconf:1.61
	autoconf-freeze:1.60.10.2
	premerge-autoconf:1.61
	ansi-20040316-freeze:1.60.2.1
	postmerge-20040315-windows:1.61
	premerge-20040315-windows:1.61
	windows-20040315-freeze:1.60.4.1
	autoconf-20031203:1.60
	autoconf-20031202:1.60
	autoconf-branch:1.60.0.10
	phong-branch:1.60.0.8
	photonmap-branch:1.60.0.6
	rel-6-1-DP:1.60
	windows-branch:1.60.0.4
	rel-6-0-2:1.58
	ansi-branch:1.60.0.2
	rel-6-0-1-branch:1.58.0.2
	hartley-6-0-post:1.59
	hartley-6-0-pre:1.58
	rel-6-0-1:1.58
	rel-6-0:1.58
	rel-5-4:1.35.2.2
	offsite-5-3-pre:1.52
	rel-5-3:1.35.2.2
	rel-5-2:1.35.2.1
	rel-5-1-branch:1.35.0.2
	rel-5-1:1.35
	rel-5-0:1.28
	rel-5-0-beta:1.28
	rel-4-5:1.21
	ctj-4-5-post:1.20
	ctj-4-5-pre:1.20;
locks; strict;
comment	@ * @;


1.64
date	2004.05.21.18.07.29;	author morrison;	state dead;
branches;
next	1.63;

1.63
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	1.62;

1.62
date	2004.04.05.08.48.56;	author morrison;	state Exp;
branches;
next	1.61;

1.61
date	2004.02.02.17.39.15;	author morrison;	state Exp;
branches;
next	1.60;

1.60
date	2002.08.20.17.07.57;	author jra;	state Exp;
branches
	1.60.2.1
	1.60.4.1
	1.60.10.1;
next	1.59;

1.59
date	2002.08.15.20.55.08;	author hartley;	state Exp;
branches;
next	1.58;

1.58
date	2001.11.02.01.51.35;	author butler;	state Exp;
branches;
next	1.57;

1.57
date	2001.10.04.19.36.09;	author rbowers;	state Exp;
branches;
next	1.56;

1.56
date	2001.10.02.19.24.28;	author jra;	state Exp;
branches;
next	1.55;

1.55
date	2001.05.17.20.05.23;	author morrison;	state Exp;
branches;
next	1.54;

1.54
date	2001.04.20.22.29.41;	author morrison;	state Exp;
branches;
next	1.53;

1.53
date	2001.03.19.22.19.57;	author butler;	state Exp;
branches;
next	1.52;

1.52
date	2000.10.18.00.03.25;	author mike;	state Exp;
branches;
next	1.51;

1.51
date	2000.10.16.22.00.13;	author mike;	state Exp;
branches;
next	1.50;

1.50
date	2000.09.09.04.43.03;	author mike;	state Exp;
branches;
next	1.49;

1.49
date	2000.09.08.05.54.40;	author mike;	state Exp;
branches;
next	1.48;

1.48
date	2000.08.31.02.22.32;	author mike;	state Exp;
branches;
next	1.47;

1.47
date	2000.08.31.01.33.39;	author mike;	state Exp;
branches;
next	1.46;

1.46
date	2000.08.24.01.50.04;	author mike;	state Exp;
branches;
next	1.45;

1.45
date	2000.08.22.20.35.52;	author mike;	state Exp;
branches;
next	1.44;

1.44
date	2000.08.22.06.49.24;	author mike;	state Exp;
branches;
next	1.43;

1.43
date	2000.08.21.02.02.29;	author butler;	state Exp;
branches;
next	1.42;

1.42
date	2000.07.31.20.46.35;	author jra;	state Exp;
branches;
next	1.41;

1.41
date	2000.07.12.02.10.15;	author mike;	state Exp;
branches;
next	1.40;

1.40
date	2000.07.12.01.43.00;	author mike;	state Exp;
branches;
next	1.39;

1.39
date	2000.07.10.23.01.27;	author mike;	state Exp;
branches;
next	1.38;

1.38
date	2000.06.30.18.15.19;	author mike;	state Exp;
branches;
next	1.37;

1.37
date	2000.06.30.18.04.14;	author mike;	state Exp;
branches;
next	1.36;

1.36
date	2000.06.29.18.20.55;	author mike;	state Exp;
branches;
next	1.35;

1.35
date	2000.03.17.16.08.36;	author jra;	state Exp;
branches
	1.35.2.1;
next	1.34;

1.34
date	2000.03.04.05.53.45;	author mike;	state Exp;
branches;
next	1.33;

1.33
date	2000.02.08.07.42.01;	author mike;	state Exp;
branches;
next	1.32;

1.32
date	99.12.29.20.59.45;	author jra;	state Exp;
branches;
next	1.31;

1.31
date	99.12.22.02.07.37;	author mike;	state Exp;
branches;
next	1.30;

1.30
date	99.11.26.21.46.44;	author mike;	state Exp;
branches;
next	1.29;

1.29
date	99.11.24.14.39.51;	author jra;	state Exp;
branches;
next	1.28;

1.28
date	99.02.01.20.19.30;	author jra;	state Exp;
branches;
next	1.27;

1.27
date	99.01.28.14.48.29;	author jra;	state Exp;
branches;
next	1.26;

1.26
date	99.01.27.20.40.06;	author jra;	state Exp;
branches;
next	1.25;

1.25
date	99.01.21.16.33.00;	author jra;	state Exp;
branches;
next	1.24;

1.24
date	98.12.17.04.19.09;	author mike;	state Exp;
branches;
next	1.23;

1.23
date	98.06.22.19.48.33;	author jra;	state Exp;
branches;
next	1.22;

1.22
date	98.03.19.15.57.01;	author jra;	state Exp;
branches;
next	1.21;

1.21
date	97.12.16.06.09.51;	author mike;	state Exp;
branches;
next	1.20;

1.20
date	97.06.25.04.23.40;	author mike;	state Exp;
branches;
next	1.19;

1.19
date	97.06.20.03.49.18;	author gdurf;	state Exp;
branches;
next	1.18;

1.18
date	97.06.17.20.40.10;	author gdurf;	state Exp;
branches;
next	1.17;

1.17
date	97.05.22.02.11.17;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	97.02.27.15.33.21;	author jra;	state Exp;
branches;
next	1.15;

1.15
date	97.02.20.21.19.17;	author jra;	state Exp;
branches;
next	1.14;

1.14
date	97.02.05.03.09.13;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	97.01.30.02.35.26;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	97.01.30.02.29.34;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	97.01.30.01.47.03;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	97.01.29.06.30.10;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	97.01.29.00.59.34;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	97.01.29.00.34.21;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	97.01.02.13.42.06;	author jra;	state Exp;
branches;
next	1.6;

1.6
date	97.01.02.13.32.04;	author jra;	state Exp;
branches;
next	1.5;

1.5
date	96.12.04.02.50.27;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	96.10.25.06.58.58;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	96.10.25.02.12.47;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	96.10.23.05.30.26;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	96.10.19.05.38.42;	author mike;	state Exp;
branches;
next	;

1.35.2.1
date	2000.08.15.14.22.28;	author jra;	state Exp;
branches;
next	1.35.2.2;

1.35.2.2
date	2000.10.25.19.00.37;	author jra;	state Exp;
branches;
next	;

1.60.2.1
date	2002.09.19.18.01.31;	author morrison;	state Exp;
branches;
next	1.60.2.2;

1.60.2.2
date	2004.03.17.21.18.43;	author morrison;	state Exp;
branches;
next	;

1.60.4.1
date	2004.03.11.23.43.35;	author morrison;	state Exp;
branches;
next	;

1.60.10.1
date	2004.02.12.18.37.38;	author erikg;	state Exp;
branches;
next	1.60.10.2;

1.60.10.2
date	2004.03.15.14.07.17;	author erikg;	state Exp;
branches;
next	;


desc
@Combination import routines
@


1.64
log
@moved to src/
@
text
@/*
 *			D B _ C O M B . C
 *
 *  This module contains the import/export routines for "Combinations",
 *  the non-leaf nodes in the directed acyclic graphs (DAGs) in the
 *  BRL-CAD ".g" database.
 *
 *  This parallels the function of the geometry (leaf-node) import/export
 *  routines found in the g_xxx.c routines.
 *
 *  As a reminder, some combinations are special, when marked with
 *  the "Region" flag, everything from that node down is considered to
 *  be made of uniform material.
 *
 *  Authors -
 *	Michael John Muuss
 *	John R. Anderson
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1996-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/db_comb.c,v 1.63 2004/05/10 15:30:46 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "db.h"
#include "raytrace.h"

#include "./debug.h"

#define STAT_ROT	1
#define STAT_XLATE	2
#define STAT_PERSP	4
#define STAT_SCALE	8

/*
 *			M A T _ C A T E G O R I Z E
 *
 *  Describe with a bit vector the effects this matrix will have.
XXX Should have different name prefix.
 */
static int
mat_categorize(const fastf_t *matp)
{
	int	status = 0;

	if( !matp )  return 0;

	if( matp[0] != 1.0 || matp[5] != 1.0 || matp[10] != 1.0 )
		status |= STAT_ROT;

	if( matp[MDX] != 0.0 ||
	    matp[MDY] != 0.0 ||
	    matp[MDZ] != 0.0 )
		status |= STAT_XLATE;

	if( matp[12] != 0.0 ||
	    matp[13] != 0.0 ||
	    matp[14] != 0.0 )
		status |= STAT_PERSP;

	if( matp[15] != 1.0 )  status |= STAT_SCALE;

	return status;
}

/*
 *			D B _ T R E E _ N L E A V E S
 *
 *  Return count of number of leaf nodes in this tree.
 */
int
db_tree_nleaves( const union tree *tp )
{
	if( tp == TREE_NULL )  return 0;

	RT_CK_TREE(tp);

	switch( tp->tr_op )  {
	case OP_NOP:
		return 0;
	case OP_DB_LEAF:
		return 1;
	case OP_SOLID:
		return 1;
	case OP_REGION:
		return 1;

	case OP_NOT:
	case OP_GUARD:
	case OP_XNOP:
		/* Unary ops */
		return db_tree_nleaves( tp->tr_b.tb_left );

	case OP_UNION:
	case OP_INTERSECT:
	case OP_SUBTRACT:
	case OP_XOR:
		/* This node is known to be a binary op */
		return	db_tree_nleaves( tp->tr_b.tb_left ) +
			db_tree_nleaves( tp->tr_b.tb_right );

	default:
		bu_log("db_tree_nleaves: bad op %d\n", tp->tr_op);
		rt_bomb("db_tree_nleaves\n");
	}
	return( -1 );	/* for the compiler */
}

/*
 *			D B _ F L A T T E N _ T R E E
 *
 *  Take a binary tree in "V4-ready" layout (non-unions pushed below unions,
 *  left-heavy), and flatten it into an array layout, ready for conversion
 *  back to the GIFT-inspired V4 database format.
 *
 *  This is done using the db_non_union_push() routine.
 *
 *  If argument 'free' is non-zero, then
 *  the non-leaf nodes are freed along the way, to prevent memory leaks.
 *  In this case, the caller's copy of 'tp' will be invalid upon return.
 *
 *  When invoked at the very top of the tree, the op argument must be OP_UNION.
 */
struct rt_tree_array *
db_flatten_tree(
	struct rt_tree_array	*rt_tree_array,
	union tree		*tp,
	int			op,
	int			free,
	struct resource		*resp)
{

	RT_CK_TREE(tp);
	RT_CK_RESOURCE(resp);

	switch( tp->tr_op )  {
	case OP_DB_LEAF:
		rt_tree_array->tl_op = op;
		rt_tree_array->tl_tree = tp;
		return rt_tree_array+1;

	case OP_UNION:
	case OP_INTERSECT:
	case OP_SUBTRACT:
		/* This node is known to be a binary op */
		rt_tree_array = db_flatten_tree( rt_tree_array, tp->tr_b.tb_left, op, free, resp );
		rt_tree_array = db_flatten_tree( rt_tree_array, tp->tr_b.tb_right, tp->tr_op, free, resp );
		if(free)  {
			/* The leaves have been stolen, free the binary op */
			tp->tr_b.tb_left = TREE_NULL;
			tp->tr_b.tb_right = TREE_NULL;
			RT_FREE_TREE( tp, resp )
		}
		return rt_tree_array;

	default:
		bu_log("db_flatten_tree: bad op %d\n", tp->tr_op);
		bu_bomb("db_flatten_tree\n");
	}

	return( (struct rt_tree_array *)NULL ); /* for the compiler */
}

/*
 *			R T _ C O M B _ I M P O R T 4
 *
 *  Import a combination record from a V4 database into internal form.
 */
int
rt_comb_import4(
	struct rt_db_internal		*ip,
	const struct bu_external	*ep,
	const mat_t			matrix,		/* NULL if identity */
	const struct db_i		*dbip,
	struct resource			*resp)
{
	union record		*rp;
	struct rt_tree_array	*rt_tree_array;
	union tree		*tree;
	struct rt_comb_internal	*comb;
	int			j;
	int			node_count;

	BU_CK_EXTERNAL( ep );
	rp = (union record *)ep->ext_buf;

	if( rp[0].u_id != ID_COMB )
	{
		bu_log( "rt_comb_import4: Attempt to import a non-combination\n" );
		return( -1 );
	}

	/* Compute how many granules of MEMBER records follow */
	node_count = ep->ext_nbytes/sizeof( union record ) - 1;

	if( node_count )
		rt_tree_array = (struct rt_tree_array *)bu_calloc( node_count , sizeof( struct rt_tree_array ) , "rt_tree_array" );
	else
		rt_tree_array = (struct rt_tree_array *)NULL;

	for( j=0 ; j<node_count ; j++ )
	{
		if( rp[j+1].u_id != ID_MEMB )
		{
			bu_free( (genptr_t)rt_tree_array , "rt_comb_import4: rt_tree_array" );
			bu_log( "rt_comb_import4(): granule in external buffer is not ID_MEMB, id=%d\n", rp[j+1].u_id );
			return( -1 );
		}

		switch( rp[j+1].M.m_relation )
		{
			case '+':
				rt_tree_array[j].tl_op = OP_INTERSECT;
				break;
			case '-':
				rt_tree_array[j].tl_op = OP_SUBTRACT;
				break;
			default:
				bu_log("rt_comb_import4() unknown op=x%x, assuming UNION\n", rp[j+1].M.m_relation );
				/* Fall through */
			case 'u':
				rt_tree_array[j].tl_op = OP_UNION;
				break;
		}
		/* Build leaf node for in-memory tree */
		{
			union tree		*tp;
			mat_t			diskmat;
			char			namebuf[NAMESIZE+2];

			RT_GET_TREE( tp, resp );
			rt_tree_array[j].tl_tree = tp;
			tp->tr_l.magic = RT_TREE_MAGIC;
			tp->tr_l.tl_op = OP_DB_LEAF;
			strncpy( namebuf, rp[j+1].M.m_instname, NAMESIZE );
			namebuf[NAMESIZE] = '\0';	/* ensure null term */
			tp->tr_l.tl_name = bu_strdup( namebuf );

			rt_mat_dbmat( diskmat, rp[j+1].M.m_mat );

			/* Verify that rotation part is pure rotation */
			if( fabs(diskmat[0]) > 1 || fabs(diskmat[1]) > 1 ||
			    fabs(diskmat[2]) > 1 ||
			    fabs(diskmat[4]) > 1 || fabs(diskmat[5]) > 1 ||
			    fabs(diskmat[6]) > 1 ||
			    fabs(diskmat[8]) > 1 || fabs(diskmat[9]) > 1 ||
			    fabs(diskmat[10]) > 1 )  {
				bu_log("ERROR: %s/%s improper scaling, rotation matrix elements > 1\n",
					rp[0].c.c_name, namebuf );
			}

			/* Verify that perspective isn't used as a modeling transform */
			if( diskmat[12] != 0 || diskmat[13] != 0 || diskmat[14] != 0 )  {
				bu_log("ERROR: %s/%s has perspective transform\n",
					rp[0].c.c_name, namebuf );
			}

			/* See if disk record is identity matrix */
			if( bn_mat_is_identity( diskmat ) )  {
				if( matrix == NULL )  {
					tp->tr_l.tl_mat = NULL;	/* identity */
				} else {
					tp->tr_l.tl_mat = bn_mat_dup( matrix );
				}
			} else {
				if( matrix == NULL )  {
					tp->tr_l.tl_mat = bn_mat_dup( diskmat );
				} else {
					mat_t	prod;
					bn_mat_mul( prod, matrix, diskmat );
					tp->tr_l.tl_mat = bn_mat_dup( prod );
				}
			}
/* bu_log("M_name=%s, matp=x%x\n", tp->tr_l.tl_name, tp->tr_l.tl_mat ); */
		}
	}
	if( node_count )
		tree = db_mkgift_tree( rt_tree_array, node_count, &rt_uniresource );
	else
		tree = (union tree *)NULL;

	RT_INIT_DB_INTERNAL( ip );
	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_COMBINATION;
	ip->idb_meth = &rt_functab[ID_COMBINATION];
	comb = (struct rt_comb_internal *)bu_malloc( sizeof( struct rt_comb_internal ) , "rt_comb_import4: rt_comb_internal" );
	ip->idb_ptr = (genptr_t)comb;
	comb->magic = RT_COMB_MAGIC;
	bu_vls_init( &comb->shader );
	bu_vls_init( &comb->material );
	comb->tree = tree;
	comb->temperature = -1;
	switch( rp[0].c.c_flags )  {
	case DBV4_NON_REGION_NULL:
	case DBV4_NON_REGION:
		comb->region_flag = 0;
		break;
	case DBV4_REGION:
		comb->region_flag = 1;
		comb->is_fastgen = REGION_NON_FASTGEN;
		break;
	case DBV4_REGION_FASTGEN_PLATE:
		comb->region_flag = 1;
		comb->is_fastgen = REGION_FASTGEN_PLATE;
		break;
	case DBV4_REGION_FASTGEN_VOLUME:
		comb->region_flag = 1;
		comb->is_fastgen = REGION_FASTGEN_VOLUME;
		break;
	default:
		bu_log("WARNING: combination %s has illegal c_flag=x%x\n",
			rp[0].c.c_name, rp[0].c.c_flags );
		break;
	}

	if( comb->region_flag )  {
		comb->region_id = rp[0].c.c_regionid;
		comb->aircode = rp[0].c.c_aircode;
		comb->GIFTmater = rp[0].c.c_material;
		comb->los = rp[0].c.c_los;
#if 0
		if( comb->region_id && comb->aircode )
		{
			bu_log( "NOTICE: region %s has both id=%d and aircode=%d, ignoring aircode!!!\n",
				rp[0].c.c_name, comb->region_id, comb->aircode );
			comb->aircode = 0;
		}
#endif
	}
	else {	/* set some reasonable defaults */
		comb->region_id = 0;
		comb->aircode = 0;
		comb->GIFTmater = 0;
		comb->los = 0;
	}

	comb->rgb_valid = rp[0].c.c_override;
	if ( comb->rgb_valid )  {
		comb->rgb[0] = rp[0].c.c_rgb[0];
		comb->rgb[1] = rp[0].c.c_rgb[1];
		comb->rgb[2] = rp[0].c.c_rgb[2];
	}
	if( rp[0].c.c_matname[0] != '\0' )
	{
		char shader_str[94];

		/* copy shader info to a static string */
		strncpy( shader_str,  rp[0].c.c_matname, 32 );
		shader_str[33] = '\0';
		strcat( shader_str, " " );
		strncat( shader_str, rp[0].c.c_matparm, 60 );
		shader_str[93] = '\0';

		/* convert to TCL format and place into comb->shader */
		if( bu_shader_to_tcl_list( shader_str, &comb->shader ) )
		{
			bu_log( "rt_comb_import4: Error: Cannot convert following shader to TCL format:\n" );
			bu_log( "\t%s\n", shader_str );
			bu_vls_free( &comb->shader );
			return -1;
		}
	}
	/* XXX Separate flags for color inherit, shader inherit, (new) material inherit? */
	/* XXX cf: ma_cinherit, ma_minherit */
	/* This ? is necessary to clean up old databases with grunge here */
	comb->inherit = (rp[0].c.c_inherit == DB_INH_HIGHER) ? 1 : 0;
	/* Automatic material table lookup here? */
	if( comb->region_flag )
		bu_vls_printf( &comb->material, "gift%d", comb->GIFTmater );

	if( rt_tree_array )  bu_free( (genptr_t)rt_tree_array, "rt_tree_array" );

	return( 0 );
}

/*
 *			R T _ C O M B _ E X P O R T 4
 */
int
rt_comb_export4(
	struct bu_external		*ep,
	const struct rt_db_internal	*ip,
	double				local2mm,
	const struct db_i		*dbip,
	struct resource			*resp)
{
	struct rt_comb_internal	*comb;
	int			node_count;
	int			actual_count;
	struct rt_tree_array	*rt_tree_array;
	union tree		*tp;
	union record		*rp;
	int			j;
	char			*endp;
	struct bu_vls		tmp_vls;

	RT_CK_DB_INTERNAL( ip );
	RT_CK_RESOURCE(resp);
	if( ip->idb_type != ID_COMBINATION ) bu_bomb("rt_comb_export4() type not ID_COMBINATION");
	comb = (struct rt_comb_internal *)ip->idb_ptr;
	RT_CK_COMB(comb);

	if( comb->tree && db_ck_v4gift_tree( comb->tree ) < 0 )  {
		db_non_union_push( comb->tree, resp );
		if( db_ck_v4gift_tree( comb->tree ) < 0 )  {
			/* Need to further modify tree */
			bu_log("rt_comb_export4() Unable to V4-ify tree, aborting.\n");
			rt_pr_tree( comb->tree, 0 );
			return -1;
		}
	}

	/* Count # leaves in tree -- that's how many Member records needed. */
	node_count = db_tree_nleaves( comb->tree );
	if( node_count > 0 )  {
		rt_tree_array = (struct rt_tree_array *)bu_calloc( node_count , sizeof( struct rt_tree_array ) , "rt_tree_array" );

		/* Convert tree into array form */
		actual_count = db_flatten_tree( rt_tree_array, comb->tree,
			OP_UNION, 1, resp ) - rt_tree_array;
		BU_ASSERT_LONG( actual_count, ==, node_count );
		comb->tree = TREE_NULL;
	} else {
		rt_tree_array = (struct rt_tree_array *)NULL;
		actual_count = 0;
	}

	/* Reformat the data into the necessary V4 granules */
	BU_INIT_EXTERNAL(ep);
	ep->ext_nbytes = sizeof(union record) * ( 1 + node_count );
	ep->ext_buf = bu_calloc( 1, ep->ext_nbytes, "v4 comb external" );
	rp = (union record *)ep->ext_buf;

	/* Convert the member records */
	for( j = 0; j < node_count; j++ )  {
		tp = rt_tree_array[j].tl_tree;
		RT_CK_TREE(tp);
		if( tp->tr_op != OP_DB_LEAF )  bu_bomb("rt_comb_export4() tree not OP_DB_LEAF");

		rp[j+1].u_id = ID_MEMB;
		switch( rt_tree_array[j].tl_op )  {
		case OP_INTERSECT:
			rp[j+1].M.m_relation = '+';
			break;
		case OP_SUBTRACT:
			rp[j+1].M.m_relation = '-';
			break;
		case OP_UNION:
			rp[j+1].M.m_relation = 'u';
			break;
		default:
			bu_bomb("rt_comb_export4() corrupt rt_tree_array");
		}
		strncpy( rp[j+1].M.m_instname, tp->tr_l.tl_name, NAMESIZE );
		if( tp->tr_l.tl_mat )  {
			rt_dbmat_mat( rp[j+1].M.m_mat, tp->tr_l.tl_mat );
		} else {
			rt_dbmat_mat( rp[j+1].M.m_mat, bn_mat_identity );
		}
		db_free_tree( tp, resp );
	}

	/* Build the Combination record, on the front */
	rp[0].u_id = ID_COMB;
	/* c_name[] filled in by db_wrap_v4_external() */
	if( comb->region_flag )  {
		rp[0].c.c_regionid = comb->region_id;
		rp[0].c.c_aircode = comb->aircode;
		rp[0].c.c_material = comb->GIFTmater;
		rp[0].c.c_los = comb->los;
		switch( comb->is_fastgen )  {
		case REGION_FASTGEN_PLATE:
			rp[0].c.c_flags = DBV4_REGION_FASTGEN_PLATE;
			break;
		case REGION_FASTGEN_VOLUME:
			rp[0].c.c_flags = DBV4_REGION_FASTGEN_VOLUME;
			break;
		default:
		case REGION_NON_FASTGEN:
			rp[0].c.c_flags = DBV4_REGION;
			break;
		}
	} else {
		rp[0].c.c_flags = DBV4_NON_REGION;
	}
	if( comb->rgb_valid )  {
		rp[0].c.c_override = 1;
		rp[0].c.c_rgb[0] = comb->rgb[0];
		rp[0].c.c_rgb[1] = comb->rgb[1];
		rp[0].c.c_rgb[2] = comb->rgb[2];
	}

	bu_vls_init( &tmp_vls );

	/* convert TCL list format shader to keyword=value format */
	if( bu_shader_to_key_eq( bu_vls_addr(&comb->shader), &tmp_vls ) )
	{

		bu_log( "rt_comb_export4: Cannot convert following shader string to keyword=value format:\n" );
		bu_log( "\t%s\n", bu_vls_addr(&comb->shader) );
		rp[0].c.c_matparm[0] = '\0';
		rp[0].c.c_matname[0] = '\0';
		return -1;
	}
	else
	{
		endp = strchr( bu_vls_addr(&tmp_vls), ' ' );
		if( endp )  {
			int	len;
			len = endp - bu_vls_addr(&tmp_vls);
			if( len <= 0 && bu_vls_strlen(&tmp_vls) > 0 )  {
				bu_log("WARNING: leading spaces on shader '%s' implies NULL shader\n",
					bu_vls_addr(&tmp_vls) );
			}

			if( len >= sizeof(rp[0].c.c_matname) )  {
				bu_log("ERROR:  Shader name '%s' exceeds v4 database field, aborting.\n",
					bu_vls_addr(&tmp_vls) );
				return -1;
			}
			if( strlen(endp+1) >= sizeof(rp[0].c.c_matparm) )  {
				bu_log("ERROR:  Shader parameters '%s' exceed database field, aborting.\nUse \"dbupgrade\" to enable unlimited length strings.\n",
					endp+1);
				return -1;
			}
			strncpy( rp[0].c.c_matname, bu_vls_addr(&tmp_vls), len );
			strncpy( rp[0].c.c_matparm, endp+1, sizeof(rp[0].c.c_matparm) );
		} else {
			if( bu_vls_strlen(&tmp_vls) >= sizeof(rp[0].c.c_matname) )  {
				bu_log("ERROR:  Shader name '%s' exceeds v4 database field, aborting.\n",
					bu_vls_addr(&tmp_vls) );
				return -1;
			}
			strncpy( rp[0].c.c_matname, bu_vls_addr(&tmp_vls), sizeof(rp[0].c.c_matname) );
			rp[0].c.c_matparm[0] = '\0';
		}
	}
	bu_vls_free( &tmp_vls );

	rp[0].c.c_inherit = comb->inherit;

	if( rt_tree_array )  bu_free( (char *)rt_tree_array, "rt_tree_array" );

	return 0;		/* OK */
}

/*
 *			D B _ T R E E _ F L A T T E N _ D E S C R I B E
 *
 *  Produce a GIFT-compatible listing, one "member" per line,
 *  regardless of the structure of the tree we've been given.
 */
void
db_tree_flatten_describe(
	struct bu_vls		*vls,
	const union tree	*tp,
	int			indented,
	int			lvl,
	double			mm2local,
	struct resource		*resp)
{
	int node_count;
	struct rt_tree_array	*rt_tree_array;
	int i;
	char op = OP_NOP;
	int status;
	union tree *ntp;

	BU_CK_VLS(vls);
	RT_CK_RESOURCE(resp);

	if( !tp )
	{
		/* no tree, probably an empty combination */
		bu_vls_strcat( vls, "-empty-\n" );
		return;
	}
	RT_CK_TREE(tp);

	node_count = db_tree_nleaves( tp );
	if( node_count <= 0 )  {
		if( !indented )  bu_vls_spaces( vls, 2*lvl );
		bu_vls_strcat( vls, "-empty-\n" );
		return;
	}

	/*
	 *  We're going to whack the heck out of the tree, but our
	 *  argument is 'const'.  Before getting started, make a
	 *  private copy just for us.
	 */
	ntp = db_dup_subtree( tp, resp );
	RT_CK_TREE(ntp);

	/* Convert to "v4 / GIFT style", so that the flatten makes sense. */
	if( db_ck_v4gift_tree( ntp ) < 0 )
		db_non_union_push( ntp, resp );
	RT_CK_TREE(ntp);

	node_count = db_tree_nleaves( ntp );
	rt_tree_array = (struct rt_tree_array *)bu_calloc( node_count , sizeof( struct rt_tree_array ) , "rt_tree_array" );

	/*
	 * free=0 means that the tree won't have any leaf nodes freed.
	 */
	(void)db_flatten_tree( rt_tree_array, ntp, OP_UNION, 0, resp );

	for( i=0 ; i<node_count ; i++ )
	{
		union tree	*itp = rt_tree_array[i].tl_tree;

		RT_CK_TREE(itp);
		BU_ASSERT_LONG( itp->tr_op, ==, OP_DB_LEAF );
		BU_ASSERT_PTR( itp->tr_l.tl_name, !=, NULL );

		switch (rt_tree_array[i].tl_op)
		{
			case OP_INTERSECT:
				op = '+';
				break;
			case OP_SUBTRACT:
				op = '-';
				break;
			case OP_UNION:
				op = 'u';
				break;
			default:
				bu_bomb("db_tree_flatten_describe() corrupt rt_tree_array");
		}

		status = mat_categorize( itp->tr_l.tl_mat );
		if( !indented )  bu_vls_spaces( vls, 2*lvl );
		bu_vls_printf( vls, " %c %s", op, itp->tr_l.tl_name );
		if( status & STAT_ROT ) {
			fastf_t	az, el;
			bn_ae_vec( &az, &el, itp->tr_l.tl_mat ?
				itp->tr_l.tl_mat : bn_mat_identity );
			bu_vls_printf( vls, 
				" az=%g, el=%g, ",
				az, el );
		}
		if( status & STAT_XLATE ) {
			bu_vls_printf( vls, " [%g,%g,%g]",
				itp->tr_l.tl_mat[MDX]*mm2local,
				itp->tr_l.tl_mat[MDY]*mm2local,
				itp->tr_l.tl_mat[MDZ]*mm2local);
		}
		if( status & STAT_SCALE ) {
			bu_vls_printf( vls, " scale %g",
				1.0/itp->tr_l.tl_mat[15] );
		}
		if( status & STAT_PERSP ) {
			bu_vls_printf( vls, 
				" Perspective=[%g,%g,%g]??",
				itp->tr_l.tl_mat[12],
				itp->tr_l.tl_mat[13],
				itp->tr_l.tl_mat[14] );
		}
		bu_vls_printf( vls, "\n" );
	}

	if( rt_tree_array ) bu_free( (genptr_t)rt_tree_array, "rt_tree_array" );
	db_free_tree( ntp, resp );
}

/*
 *			D B _ T R E E _ D E S C R I B E
 */
void
db_tree_describe( 
	struct bu_vls		*vls,
	const union tree	*tp,
	int			indented,
	int			lvl,
	double			mm2local)
{
	int	status;

	BU_CK_VLS(vls);

	if( !tp )
	{
		/* no tree, probably an empty combination */
		bu_vls_strcat( vls, "-empty-\n" );
		return;
	}
	RT_CK_TREE(tp);
	switch( tp->tr_op )  {

	case OP_DB_LEAF:
		status = mat_categorize( tp->tr_l.tl_mat );

		/* One per line, out onto the vls */
		if( !indented )  bu_vls_spaces( vls, 2*lvl );
		bu_vls_strcat( vls, tp->tr_l.tl_name );
		if( status & STAT_ROT ) {
			fastf_t	az, el;
			bn_ae_vec( &az, &el, tp->tr_l.tl_mat ?
				tp->tr_l.tl_mat : bn_mat_identity );
			bu_vls_printf( vls, 
				" az=%g, el=%g, ",
				az, el );
		}
		if( status & STAT_XLATE ) {
			bu_vls_printf( vls, " [%g,%g,%g]",
				tp->tr_l.tl_mat[MDX]*mm2local,
				tp->tr_l.tl_mat[MDY]*mm2local,
				tp->tr_l.tl_mat[MDZ]*mm2local);
		}
		if( status & STAT_SCALE ) {
			bu_vls_printf( vls, " scale %g",
				1.0/tp->tr_l.tl_mat[15] );
		}
		if( status & STAT_PERSP ) {
			bu_vls_printf( vls, 
				" Perspective=[%g,%g,%g]??",
				tp->tr_l.tl_mat[12],
				tp->tr_l.tl_mat[13],
				tp->tr_l.tl_mat[14] );
		}
		bu_vls_printf( vls, "\n" );
		return;

		/* This node is known to be a binary op */
	case OP_UNION:
		if(!indented) bu_vls_spaces( vls, 2*lvl );
		bu_vls_strcat( vls, "u " );
		goto bin;
	case OP_INTERSECT:
		if(!indented) bu_vls_spaces( vls, 2*lvl );
		bu_vls_strcat( vls, "+ " );
		goto bin;
	case OP_SUBTRACT:
		if(!indented) bu_vls_spaces( vls, 2*lvl );
		bu_vls_strcat( vls, "- " );
		goto bin;
	case OP_XOR:
		if(!indented) bu_vls_spaces( vls, 2*lvl );
		bu_vls_strcat( vls, "^ " );
bin:
		db_tree_describe( vls, tp->tr_b.tb_left, 1, lvl+1, mm2local );
		db_tree_describe( vls, tp->tr_b.tb_right, 0, lvl+1, mm2local );
		return;

		/* This node is known to be a unary op */
	case OP_NOT:
		if(!indented) bu_vls_spaces( vls, 2*lvl );
		bu_vls_strcat( vls, "! " );
		goto unary;
	case OP_GUARD:
		if(!indented) bu_vls_spaces( vls, 2*lvl );
		bu_vls_strcat( vls, "G " );
		goto unary;
	case OP_XNOP:
		if(!indented) bu_vls_spaces( vls, 2*lvl );
		bu_vls_strcat( vls, "X " );
unary:
		db_tree_describe( vls, tp->tr_b.tb_left, 1, lvl+1, mm2local );
		return;

	case OP_NOP:
		if(!indented) bu_vls_spaces( vls, 2*lvl );
		bu_vls_strcat( vls, "NOP\n" );
		return;

	default:
		bu_log("db_tree_describe: bad op %d\n", tp->tr_op);
		bu_bomb("db_tree_describe\n");
	}
}

/*
 *			D B _ C O M B _ D E S C R I B E
 */
void
db_comb_describe(
	struct bu_vls	*str,
	const struct rt_comb_internal	*comb,
	int		verbose,
	double		mm2local,
	struct resource	*resp)
{
	RT_CK_COMB(comb);
	RT_CK_RESOURCE(resp);

	if( comb->region_flag ) {
		bu_vls_printf( str,
		       "REGION id=%d  (air=%d, los=%d, GIFTmater=%d) ",
			comb->region_id,
			comb->aircode,
			comb->los,
			comb->GIFTmater );

		if( comb->is_fastgen == REGION_FASTGEN_PLATE )
			bu_vls_printf( str, "(FASTGEN plate mode) " );
		else if( comb->is_fastgen == REGION_FASTGEN_VOLUME )
			bu_vls_printf( str, "(FASTGEN volume mode) " );
	}


	bu_vls_strcat( str, "--\n" );
	if( bu_vls_strlen(&comb->shader) > 0 ) {
		bu_vls_printf( str,
			"Shader '%s'\n",
			bu_vls_addr(&comb->shader) );
	}

	if( comb->rgb_valid ) {
		bu_vls_printf( str,
			"Color %d %d %d\n",
			comb->rgb[0],
			comb->rgb[1],
			comb->rgb[2]);
	}

	if( bu_vls_strlen(&comb->shader) > 0 || comb->rgb_valid )  {
		if( comb->inherit ) {
			bu_vls_strcat( str, 
	"(These material properties override all lower ones in the tree)\n");
		}
	}

	if( comb->tree )  {
		if( verbose )  {
			db_tree_flatten_describe( str, comb->tree, 0, 1, mm2local, resp );
		} else {
			rt_pr_tree_vls( str, comb->tree );
		}
	} else {
		bu_vls_strcat( str, "(empty tree)\n");
	}
}

/*
 *			R T _ C O M B _ I F R E E
 *
 *  Free the storage associated with the rt_db_internal version of this combination.
 */
void
rt_comb_ifree( struct rt_db_internal *ip, struct resource *resp )
{
	register struct rt_comb_internal	*comb;

	RT_CK_DB_INTERNAL(ip);
	RT_CK_RESOURCE(resp);
	comb = (struct rt_comb_internal *)ip->idb_ptr;
	RT_CK_COMB(comb);

	/* If tree hasn't been stolen, release it */
	if(comb->tree) db_free_tree( comb->tree, resp );
	comb->tree = NULL;

	bu_vls_free( &comb->shader );
	bu_vls_free( &comb->material );

	comb->magic = 0;			/* sanity */
	bu_free( (genptr_t)comb, "comb ifree" );
	ip->idb_ptr = GENPTR_NULL;	/* sanity */
}

/*
 *			R T _ C O M B _ D E S C R I B E
 *
 *  rt_functab[ID_COMBINATION].ft_describe() method
 */
int
rt_comb_describe(
	struct bu_vls	*str,
	const struct rt_db_internal *ip,
	int		verbose,
	double		mm2local,
	struct resource	*resp,
	struct db_i *db_i)
{
	const struct rt_comb_internal	*comb;

	RT_CK_DB_INTERNAL(ip);
	RT_CK_RESOURCE(resp);

	comb = (struct rt_comb_internal *)ip->idb_ptr;
	RT_CK_COMB(comb);

	db_comb_describe( str, comb, verbose, mm2local, resp );
	return 0;
}

/*==================== END g_comb.c / table.c interface ========== */

/*
 *			D B _ W R A P _ V 4 _ E X T E R N A L
 *
 *  As the v4 database does not really have the notion of "wrapping",
 *  this function writes the object name into the
 *  proper place (a standard location in all granules).
 */
void
db_wrap_v4_external( struct bu_external *op, const char *name )
{
	union record	*rec;

	BU_CK_EXTERNAL(op);

	rec = (union record *)op->ext_buf;
	NAMEMOVE( name, rec->s.s_name );
}

/* Some export support routines */

/*
 *			D B _ C K _ L E F T _ H E A V Y _ T R E E
 *
 *  Support routine for db_ck_v4gift_tree().
 *  Ensure that the tree below 'tp' is left-heavy, i.e. that there are
 *  nothing but solids on the right side of any binary operations.
 *
 *  Returns -
 *	-1	ERROR
 *	 0	OK
 */
int
db_ck_left_heavy_tree(
	const union tree	*tp,
	int			no_unions)
{
	RT_CK_TREE(tp);
	switch( tp->tr_op )  {

	case OP_DB_LEAF:
		break;

	case OP_UNION:
		if( no_unions )  return -1;
		/* else fall through */
	case OP_INTERSECT:
	case OP_SUBTRACT:
	case OP_XOR:
		if( db_ck_left_heavy_tree( tp->tr_b.tb_right, no_unions ) < 0 )
			return -1;
		return db_ck_left_heavy_tree( tp->tr_b.tb_left, no_unions );

	default:
		bu_log("db_ck_left_heavy_tree: bad op %d\n", tp->tr_op);
		bu_bomb("db_ck_left_heavy_tree\n");
	}
	return 0;
}


/*
 *			D B _ C K _ V 4 G I F T _ T R E E
 *
 *  Look a gift-tree in the mouth.
 *  Ensure that this boolean tree conforms to the GIFT convention that
 *  union operations must bind the loosest.
 *  There are two stages to this check:
 *  1)  Ensure that if unions are present they are all at the root of tree,
 *  2)  Ensure non-union children of union nodes are all left-heavy
 *      (nothing but solid nodes permitted on rhs of binary operators).
 *
 *  Returns -
 *	-1	ERROR
 *	 0	OK
 */
int
db_ck_v4gift_tree( const union tree *tp )
{
	RT_CK_TREE(tp);
	switch( tp->tr_op )  {

	case OP_DB_LEAF:
		break;

	case OP_UNION:
		if( db_ck_v4gift_tree( tp->tr_b.tb_left ) < 0 )
			return -1;
		return db_ck_v4gift_tree( tp->tr_b.tb_right );

	case OP_INTERSECT:
	case OP_SUBTRACT:
	case OP_XOR:
		return db_ck_left_heavy_tree( tp, 1 );

	default:
		bu_log("db_ck_v4gift_tree: bad op %d\n", tp->tr_op);
		bu_bomb("db_ck_v4gift_tree\n");
	}
	return 0;
}


/*
 *			D B _ M K B O O L _ T R E E
 *
 *  Given a rt_tree_array array, build a tree of "union tree" nodes
 *  appropriately connected together.  Every element of the
 *  rt_tree_array array used is replaced with a TREE_NULL.
 *  Elements which are already TREE_NULL are ignored.
 *  Returns a pointer to the top of the tree.
 */
union tree *
db_mkbool_tree( 
	struct rt_tree_array *rt_tree_array,
	int		howfar,
	struct resource	*resp)
{
	register struct rt_tree_array *tlp;
	register int		i;
	register struct rt_tree_array *first_tlp = (struct rt_tree_array *)0;
	register union tree	*xtp;
	register union tree	*curtree;
	register int		inuse;

	RT_CK_RESOURCE(resp);

	if( howfar <= 0 )
		return(TREE_NULL);

	/* Count number of non-null sub-trees to do */
	for( i=howfar, inuse=0, tlp=rt_tree_array; i>0; i--, tlp++ )  {
		if( tlp->tl_tree == TREE_NULL )
			continue;
		if( inuse++ == 0 )
			first_tlp = tlp;
	}

	/* Handle trivial cases */
	if( inuse <= 0 )
		return(TREE_NULL);
	if( inuse == 1 )  {
		curtree = first_tlp->tl_tree;
		first_tlp->tl_tree = TREE_NULL;
		return( curtree );
	}

	if( first_tlp->tl_op != OP_UNION )  {
		first_tlp->tl_op = OP_UNION;	/* Fix it */
		if( RT_G_DEBUG & DEBUG_TREEWALK )  {
			bu_log("db_mkbool_tree() WARNING: non-union (%c) first operation ignored\n",
				first_tlp->tl_op );
		}
	}

	curtree = first_tlp->tl_tree;
	first_tlp->tl_tree = TREE_NULL;
	tlp=first_tlp+1;
	for( i=howfar-(tlp-rt_tree_array); i>0; i--, tlp++ )  {
		if( tlp->tl_tree == TREE_NULL )
			continue;

		RT_GET_TREE( xtp, resp );
		xtp->magic = RT_TREE_MAGIC;
		xtp->tr_b.tb_left = curtree;
		xtp->tr_b.tb_right = tlp->tl_tree;
		xtp->tr_b.tb_regionp = (struct region *)0;
		xtp->tr_op = tlp->tl_op;
		curtree = xtp;
		tlp->tl_tree = TREE_NULL;	/* empty the input slot */
	}
	return(curtree);
}

/*
 *			D B _ M K G I F T _ T R E E
 */
union tree *
db_mkgift_tree(
	struct rt_tree_array	*trees,
	int			subtreecount,
	struct resource		*resp)
{
	register struct rt_tree_array *tstart;
	register struct rt_tree_array *tnext;
	union tree		*curtree;
	int	i;
	int	j;

	RT_CK_RESOURCE(resp);

	/*
	 * This is how GIFT interpreted equations, so it is duplicated here.
	 * Any expressions between UNIONs are evaluated first.  For example:
	 *		A - B - C u D - E - F
	 * becomes	(A - B - C) u (D - E - F)
	 * so first do the parenthesised parts, and then go
	 * back and glue the unions together.
	 * As always, unions are the downfall of free enterprise!
	 */
	tstart = trees;
	tnext = trees+1;
	for( i=subtreecount-1; i>=0; i--, tnext++ )  {
		/* If we went off end, or hit a union, do it */
		if( i>0 && tnext->tl_op != OP_UNION )
			continue;
		if( (j = tnext-tstart) <= 0 )
			continue;
		curtree = db_mkbool_tree( tstart, j, resp );
		/* db_mkbool_tree() has side effect of zapping tree array,
		 * so build new first node in array.
		 */
		tstart->tl_op = OP_UNION;
		tstart->tl_tree = curtree;

		if(RT_G_DEBUG&DEBUG_TREEWALK)  {
			bu_log("db_mkgift_tree() intermediate term:\n");
			rt_pr_tree(tstart->tl_tree, 0);
		}

		/* tstart here at union */
		tstart = tnext;
	}

	curtree = db_mkbool_tree( trees, subtreecount, resp );
	if(RT_G_DEBUG&DEBUG_TREEWALK)  {
		bu_log("db_mkgift_tree() returns:\n");
		rt_pr_tree(curtree, 0);
	}
	return( curtree );
}
@


1.63
log
@change conf.h to a wrapped config.h
@
text
@d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/librt/db_comb.c,v 1.62 2004/04/05 08:48:56 morrison Exp $ (ARL)";
@


1.62
log
@merge of ansi-6-0-branch into HEAD
@
text
@d33 1
a33 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d36 5
a40 1
#include "conf.h"
@


1.61
log
@update copyright to include span through 2003
@
text
@d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_comb.c,v 1.60 2002/08/20 17:07:57 jra Exp $ (ARL)";
d67 1
a67 2
mat_categorize( matp )
const mat_t	matp;
@


1.60
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d29 1
a29 1
 *	This software is Copyright (C) 1996 by the United States Army
d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_comb.c,v 1.58 2001/11/02 01:51:35 butler Exp $ (ARL)";
@


1.60.4.1
log
@sync to HEAD...
@
text
@d29 1
a29 1
 *	This software is Copyright (C) 1996-2004 by the United States Army
d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/db_comb.c,v 1.61 2004/02/02 17:39:15 morrison Exp $ (ARL)";
@


1.60.10.1
log
@merge from HEAD
@
text
@d29 1
a29 1
 *	This software is Copyright (C) 1996-2004 by the United States Army
d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_comb.c,v 1.61 2004/02/02 17:39:15 morrison Exp $ (ARL)";
@


1.60.10.2
log
@merge from head
@
text
@d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_comb.c,v 1.60.10.1 2004/02/12 18:37:38 erikg Exp $ (ARL)";
@


1.60.2.1
log
@Initial ANSIfication
@
text
@d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_comb.c,v 1.60 2002/08/20 17:07:57 jra Exp $ (ARL)";
d67 2
a68 1
mat_categorize(const fastf_t *matp)
@


1.60.2.2
log
@sync branch with HEAD
@
text
@d29 1
a29 1
 *	This software is Copyright (C) 1996-2004 by the United States Army
d33 1
a33 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
@


1.59
log
@Converted from K&R to ANSI C - RFH
@
text
@d67 2
a68 1
mat_categorize(const fastf_t *matp)
@


1.58
log
@the _describe functions now have an additional parameter: db_i
@
text
@d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_comb.c,v 1.57 2001/10/04 19:36:09 rbowers Exp $ (ARL)";
d67 1
a67 2
mat_categorize( matp )
const mat_t	matp;
@


1.57
log
@-* modified to eliminate user-visible v4 references.
@
text
@d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_comb.c,v 1.56 2001/10/02 19:24:28 jra Exp $ (ARL)";
d898 2
a899 1
	struct resource	*resp)
@


1.56
log
@Routines were not setting idb_major_type in the internal structure
@
text
@d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_comb.c,v 1.55 2001/05/17 20:05:23 morrison Exp $ (ARL)";
d548 1
a548 1
				bu_log("ERROR:  Shader parameters '%s' exceed v4 database field, aborting.\nUpgrade to v5 database to store unlimited length strings.\n",
@


1.55
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_comb.c,v 1.54 2001/04/20 22:29:41 morrison Exp $ (ARL)";
d309 1
@


1.54
log
@CONST to const
@
text
@d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_comb.c,v 1.53 2001/03/19 22:19:57 butler Exp $ (ARL)";
d1061 1
a1061 1
		if( rt_g.debug & DEBUG_TREEWALK )  {
d1127 1
a1127 1
		if(rt_g.debug&DEBUG_TREEWALK)  {
d1137 1
a1137 1
	if(rt_g.debug&DEBUG_TREEWALK)  {
@


1.53
log
@patches to merge 5.3 into 6.0
@
text
@d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /d/CVS/brlcad/librt/db_comb.c,v 1.52 2000/10/18 00:03:25 mike Exp $ (ARL)";
d68 1
a68 1
CONST mat_t	matp;
d899 1
a899 1
	CONST struct rt_comb_internal	*comb;
d989 1
a989 1
db_ck_v4gift_tree( CONST union tree *tp )
@


1.52
log
@
Oops, matparm string was getting duplicated into matname.
@
text
@d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_comb.c,v 1.51 2000/10/16 22:00:13 mike Exp $ (ARL)";
d523 1
d540 1
@


1.51
log
@
Refuses to export combinations which have shader straings that
don't fit into v4 databases.
@
text
@d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_comb.c,v 1.50 2000/09/09 04:43:03 mike Exp $ (ARL)";
d385 1
d539 1
a539 1
			if( bu_vls_strlen(&tmp_vls) >= sizeof(rp[0].c.c_matname) )  {
d549 1
a549 1
			strncpy( rp[0].c.c_matname, bu_vls_addr(&tmp_vls), sizeof(rp[0].c.c_matname) );
@


1.50
log
@
fixed arg type
a
@
text
@d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_comb.c,v 1.49 2000/09/08 05:54:40 mike Exp $ (ARL)";
d431 1
a431 1
			bu_log("rt_comb_export4() Unfinished: need to V4-ify tree\n");
d522 1
a522 2
		bu_log( "rt_comb_export4: Error in combination!\n" );
		bu_log( "\tCannot convert following shader string to keyword=value format:\n" );
d526 1
d538 12
a549 3
			if( len > 32 ) len = 32;
			strncpy( rp[0].c.c_matname, bu_vls_addr(&tmp_vls), len );
			strncpy( rp[0].c.c_matparm, endp+1, 60 );
d551 6
a556 1
			strncpy( rp[0].c.c_matname, bu_vls_addr(&tmp_vls), 32 );
@


1.49
log
@
Modified tree routines to take resource pointer.
@
text
@d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_comb.c,v 1.48 2000/08/31 02:22:32 mike Exp $ (ARL)";
d199 1
a199 1
	const matp_t			matrix,		/* NULL if identity */
@


1.48
log
@
Modified combination 'describe' routine
to actually provide a GIFT-style description as advertised.
@
text
@d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_comb.c,v 1.47 2000/08/31 01:33:39 mike Exp $ (ARL)";
d155 2
a156 1
	int			free)
d160 1
d172 2
a173 2
		rt_tree_array = db_flatten_tree( rt_tree_array, tp->tr_b.tb_left, op, free );
		rt_tree_array = db_flatten_tree( rt_tree_array, tp->tr_b.tb_right, tp->tr_op, free );
d178 1
a178 1
			bu_free( (char *)tp, "union tree (db_flatten_tree");
d200 2
a201 1
	const struct db_i		*dbip)
d257 1
a257 1
			BU_GETUNION( tp, tree );
d304 1
a304 1
		tree = db_mkgift_tree( rt_tree_array, node_count, (struct db_tree_state *)NULL );
d408 2
a409 1
	const struct db_i		*dbip)
d422 1
d428 1
a428 1
		db_non_union_push( comb->tree );
d443 2
a444 1
		actual_count = db_flatten_tree( rt_tree_array, comb->tree, OP_UNION, 1 ) - rt_tree_array;
d484 1
a484 1
		db_free_tree( tp );
d567 2
a568 1
	double			mm2local)
d578 1
d600 1
a600 1
	ntp = db_dup_subtree( tp );
d605 1
a605 1
		db_non_union_push( ntp );
d614 1
a614 1
	(void)db_flatten_tree( rt_tree_array, ntp, OP_UNION, 0 );
d671 1
a671 1
	db_free_tree( ntp );
d788 2
a789 1
	double		mm2local)
d792 1
d833 1
a833 1
			db_tree_flatten_describe( str, comb->tree, 0, 1, mm2local );
d848 1
a848 1
rt_comb_ifree( struct rt_db_internal *ip )
d853 1
d858 1
a858 1
	if(comb->tree) db_free_tree( comb->tree );
d871 2
d879 2
a880 1
	double		mm2local)
d885 2
d890 1
a890 1
	db_comb_describe( str, comb, verbose, mm2local );
d1010 2
a1011 1
	int		howfar)
d1020 2
d1057 1
a1057 1
		BU_GETUNION( xtp, tree );
d1076 1
a1076 1
	struct db_tree_state	*tsp)
d1084 2
d1103 1
a1103 1
		curtree = db_mkbool_tree( tstart, j );
d1119 1
a1119 1
	curtree = db_mkbool_tree( trees, subtreecount );
@


1.47
log
@
Reformatted for narrower screen.
@
text
@d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_comb.c,v 1.46 2000/08/24 01:50:04 mike Exp $ (ARL)";
d142 2
d147 2
d568 1
d587 12
d600 1
d603 2
a604 2
	/* We cast away the const here, knowing that the arg
	 * free=0 means that it won't actually be modified.
d606 1
a606 1
	(void)db_flatten_tree( rt_tree_array, (union tree *)tp, OP_UNION, 0 );
d610 6
d631 1
a631 1
		status = mat_categorize( rt_tree_array[i].tl_tree->tr_l.tl_mat );
d633 1
a633 1
		bu_vls_printf( vls, " %c %s", op, rt_tree_array[i].tl_tree->tr_l.tl_name );
d636 2
a637 2
			bn_ae_vec( &az, &el, rt_tree_array[i].tl_tree->tr_l.tl_mat ?
				rt_tree_array[i].tl_tree->tr_l.tl_mat : bn_mat_identity );
d644 3
a646 3
				rt_tree_array[i].tl_tree->tr_l.tl_mat[MDX]*mm2local,
				rt_tree_array[i].tl_tree->tr_l.tl_mat[MDY]*mm2local,
				rt_tree_array[i].tl_tree->tr_l.tl_mat[MDZ]*mm2local);
d650 1
a650 1
				1.0/rt_tree_array[i].tl_tree->tr_l.tl_mat[15] );
d655 3
a657 3
				rt_tree_array[i].tl_tree->tr_l.tl_mat[12],
				rt_tree_array[i].tl_tree->tr_l.tl_mat[13],
				rt_tree_array[i].tl_tree->tr_l.tl_mat[14] );
d663 1
@


1.46
log
@
externs for db_comb.c
@
text
@d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_comb.c,v 1.45 2000/08/22 20:35:52 mike Exp $ (ARL)";
d547 3
d561 3
a563 1
	
d576 15
a590 1
	if( node_count > 0 )
d592 1
a592 10
		int i;
		char op = OP_NOP;
		int status;

		rt_tree_array = (struct rt_tree_array *)bu_calloc( node_count , sizeof( struct rt_tree_array ) , "rt_tree_array" );
		/* We cast away the const here, knowing that the arg
		 * free=0 means that it won't actually be modified.
		 */
		(void)db_flatten_tree( rt_tree_array, (union tree *)tp, OP_UNION, 0 );
		for( i=0 ; i<node_count ; i++ )
d594 11
a604 44
			switch (rt_tree_array[i].tl_op)
			{
				case OP_INTERSECT:
					op = '+';
					break;
				case OP_SUBTRACT:
					op = '-';
					break;
				case OP_UNION:
					op = 'u';
					break;
				default:
					bu_bomb("db_tree_flatten_describe() corrupt rt_tree_array");
			}

			status = mat_categorize( rt_tree_array[i].tl_tree->tr_l.tl_mat );
			if( !indented )  bu_vls_spaces( vls, 2*lvl );
			bu_vls_printf( vls, " %c %s", op, rt_tree_array[i].tl_tree->tr_l.tl_name );
			if( status & STAT_ROT ) {
				fastf_t	az, el;
				bn_ae_vec( &az, &el, rt_tree_array[i].tl_tree->tr_l.tl_mat ?
					rt_tree_array[i].tl_tree->tr_l.tl_mat : bn_mat_identity );
				bu_vls_printf( vls, 
					" az=%g, el=%g, ",
					az, el );
			}
			if( status & STAT_XLATE ) {
				bu_vls_printf( vls, " [%g,%g,%g]",
					rt_tree_array[i].tl_tree->tr_l.tl_mat[MDX]*mm2local,
					rt_tree_array[i].tl_tree->tr_l.tl_mat[MDY]*mm2local,
					rt_tree_array[i].tl_tree->tr_l.tl_mat[MDZ]*mm2local);
			}
			if( status & STAT_SCALE ) {
				bu_vls_printf( vls, " scale %g",
					1.0/rt_tree_array[i].tl_tree->tr_l.tl_mat[15] );
			}
			if( status & STAT_PERSP ) {
				bu_vls_printf( vls, 
					" Perspective=[%g,%g,%g]??",
					rt_tree_array[i].tl_tree->tr_l.tl_mat[12],
					rt_tree_array[i].tl_tree->tr_l.tl_mat[13],
					rt_tree_array[i].tl_tree->tr_l.tl_mat[14] );
			}
			bu_vls_printf( vls, "\n" );
d607 1
a607 4
		if( rt_tree_array ) bu_free( (genptr_t)rt_tree_array, "rt_tree_array" );
	}
	else
	{
d609 27
a635 1
		bu_vls_strcat( vls, "-empty-\n" );
d637 2
@


1.45
log
@
Fixed lint
@
text
@d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_comb.c,v 1.44 2000/08/22 06:49:24 mike Exp $ (ARL)";
a54 3
RT_EXTERN( union tree *db_mkbool_tree , (struct rt_tree_array *rt_tree_array , int howfar ) );
RT_EXTERN( union tree *db_mkgift_tree , (struct rt_tree_array *rt_tree_array , int howfar , struct db_tree_state *tsp ) );

d59 1
d64 1
d66 1
a66 1
int
d98 1
a98 2
db_tree_nleaves( tp )
CONST union tree	*tp;
d147 5
a151 5
db_flatten_tree( rt_tree_array, tp, op, free )
struct rt_tree_array	*rt_tree_array;
union tree		*tp;
int			op;
int			free;
d190 5
a194 5
rt_comb_import4( ip, ep, matrix, dbip )
struct rt_db_internal		*ip;
CONST struct bu_external	*ep;
CONST matp_t			matrix;		/* NULL if identity */
CONST struct db_i		*dbip;
d397 5
a401 5
rt_comb_export4( ep, ip, local2mm, dbip )
struct bu_external		*ep;
CONST struct rt_db_internal	*ip;
double				local2mm;
CONST struct db_i		*dbip;
d549 6
a554 6
db_tree_flatten_describe( vls, tp, indented, lvl, mm2local )
struct bu_vls		*vls;
CONST union tree	*tp;
int			indented;
int			lvl;
double			mm2local;
d643 6
a648 6
db_tree_describe( vls, tp, indented, lvl, mm2local )
struct bu_vls		*vls;
CONST union tree	*tp;
int			indented;
int			lvl;
double			mm2local;
d749 5
a753 5
db_comb_describe(str, comb, verbose, mm2local)
struct bu_vls	*str;
CONST struct rt_comb_internal	*comb;
int		verbose;
double		mm2local;
d811 1
a811 2
rt_comb_ifree( ip )
struct rt_db_internal	*ip;
d835 5
a839 5
rt_comb_describe(str, ip, verbose, mm2local)
struct bu_vls	*str;
CONST struct rt_db_internal *ip;
int		verbose;
double		mm2local;
d861 1
a861 1
db_wrap_v4_external( struct bu_external	*op, const char *name )
d885 3
a887 3
db_ck_left_heavy_tree( tp, no_unions )
CONST union tree	*tp;
int			no_unions;
d929 1
a929 1
db_ck_v4gift_tree( CONST union tree	*tp)
d964 4
a967 4
HIDDEN union tree *
db_mkbool_tree( rt_tree_array, howfar )
struct rt_tree_array *rt_tree_array;
int		howfar;
d1026 5
a1030 5
HIDDEN union tree *
db_mkgift_tree( trees, subtreecount, tsp )
struct rt_tree_array	*trees;
int			subtreecount;
struct db_tree_state	*tsp;
@


1.44
log
@
db_flatten_tree() got an additional argument, to prevent memory leaks.
@
text
@d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_comb.c,v 1.43 2000/08/21 02:02:29 butler Exp $ (ARL)";
d576 1
a576 1
		char op;
@


1.43
log
@Massive compilation warnings eliminated
@
text
@d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_comb.c,v 1.42 2000/07/31 20:46:35 jra Exp $ (ARL)";
d143 4
d149 1
a149 1
db_flatten_tree( rt_tree_array, tp, op )
d153 1
d168 8
a175 2
		rt_tree_array = db_flatten_tree( rt_tree_array, tp->tr_b.tb_left, op );
		rt_tree_array = db_flatten_tree( rt_tree_array, tp->tr_b.tb_right, tp->tr_op );
d180 1
a180 1
		rt_bomb("db_flatten_tree\n");
d436 3
a438 3
		actual_count = db_flatten_tree( rt_tree_array, comb->tree, OP_UNION ) - rt_tree_array;
		if( actual_count > node_count )  bu_bomb("rt_comb_export4() array overflow!");
		if( actual_count < node_count )  bu_log("WARNING rt_comb_export4() array underflow! %d < %d", actual_count, node_count);
d476 1
d542 2
d580 4
a583 5
#if 0
		actual_count = db_flatten_tree( rt_tree_array, tp, OP_UNION ) - rt_tree_array;
#else
		(void)db_flatten_tree( rt_tree_array, tp, OP_UNION );
#endif
a798 1
/*			db_tree_describe( str, comb->tree, 0, 1, mm2local ); */
@


1.42
log
@Added case for DBV4_NON_REGION_NULL c_flag in import4 routine
@
text
@d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_comb.c,v 1.41 2000/07/12 02:10:15 mike Exp $ (ARL)";
d346 2
a347 1
	if( comb->rgb_valid = rp[0].c.c_override )  {
d920 1
a920 2
db_ck_v4gift_tree( tp )
CONST union tree	*tp;
a1061 1
final:
@


1.41
log
@
Changed calling sequence to db_wrap_v4_external()
@
text
@d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_comb.c,v 1.40 2000/07/12 01:43:00 mike Exp $ (ARL)";
d303 1
@


1.40
log
@
Eliminated bogus old v5 wrapping stuff.
@
text
@d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_comb.c,v 1.39 2000/07/10 23:01:27 mike Exp $ (ARL)";
a844 2
 *  Wraps the v4 object body in "ip" into a v4 wrapper in "op".
 *
d846 2
a847 3
 *  this function primarily writes the object name into the
 *  proper place (a standard location in all granules),
 *  and (maybe) checks/sets the u_id field.
d849 6
a854 16
int
db_wrap_v4_external( op, ip, dp )
struct bu_external	*op;
struct bu_external	*ip;
CONST struct directory	*dp;
{
	union record *rec;

	BU_CK_EXTERNAL(ip);
	RT_CK_DIR(dp);

	if( op != ip )  {
		*op = *ip;		/* struct copy */
		ip->ext_buf = NULL;
		ip->ext_nbytes = 0;
	}
d857 1
a857 3
	NAMEMOVE( dp->d_namep, rec->s.s_name );

	return 0;
@


1.39
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_comb.c,v 1.38 2000/06/30 18:15:19 mike Exp $ (ARL)";
a845 2
 *  bu_free_external(ip) will be performed.
 *  op and ip must not point at the same bu_external structure.
a1082 31
}

/* ------------------------------------------------------------ */
/* Preliminary V5 wrap/unwrap support */
/* in-memory form of the standardized object 'wrapper' */
/* Object's name is stashed in directory, not in internal wrapper */
struct db_wrapper {
	long	magic;
	
};

/*
 *			D B _ W R A P _ V 5 _ E X T E R N A L
 */
int
db_wrap_v5_external( op, ip, dp, wp )
struct bu_external		*op;
struct bu_external		*ip;
CONST struct directory		*dp;
CONST struct db_wrapper		*wp;
{

	/* First, build up compressible portion of wrapper (header),
	 * if more than just object body
	 */

	/* Second, compress compressible portion */

	/* Third, add non-compressible portion of wrapper (header) */

	return( 0 );
@


1.38
log
@
changed v4 comb import/export to rt_comb_import4/rt_comb_export4
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_comb.c,v 1.37 2000/06/30 18:04:14 mike Exp $ (ARL)";
@


1.37
log
@
Removed stray function
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_comb.c,v 1.36 2000/06/29 18:20:55 mike Exp $ (ARL)";
d176 1
a176 1
 *			R T _ C O M B _ V 4 _ I M P O R T
d181 1
a181 1
rt_comb_v4_import( ip, ep, matrix, dbip )
d199 1
a199 1
		bu_log( "rt_comb_v4_import: Attempt to import a non-combination\n" );
d215 2
a216 2
			bu_free( (genptr_t)rt_tree_array , "rt_comb_v4_import: rt_tree_array" );
			bu_log( "rt_comb_v4_import(): granule in external buffer is not ID_MEMB, id=%d\n", rp[j+1].u_id );
d229 1
a229 1
				bu_log("rt_comb_v4_import() unknown op=x%x, assuming UNION\n", rp[j+1].M.m_relation );
d295 1
a295 1
	comb = (struct rt_comb_internal *)bu_malloc( sizeof( struct rt_comb_internal ) , "rt_comb_v4_import: rt_comb_internal" );
d364 1
a364 1
			bu_log( "rt_comb_v4_import: Error: Cannot convert following shader to TCL format:\n" );
d383 1
a383 1
 *			R T _ C O M B _ V 4 _ E X P O R T
d386 1
a386 1
rt_comb_v4_export( ep, ip, local2mm, dbip )
d403 1
a403 1
	if( ip->idb_type != ID_COMBINATION ) bu_bomb("rt_comb_v4_export() type not ID_COMBINATION");
d411 1
a411 1
			bu_log("rt_comb_v4_export() Unfinished: need to V4-ify tree\n");
d424 2
a425 2
		if( actual_count > node_count )  bu_bomb("rt_comb_v4_export() array overflow!");
		if( actual_count < node_count )  bu_log("WARNING rt_comb_v4_export() array underflow! %d < %d", actual_count, node_count);
d441 1
a441 1
		if( tp->tr_op != OP_DB_LEAF )  bu_bomb("rt_comb_v4_export() tree not OP_DB_LEAF");
d455 1
a455 1
			bu_bomb("rt_comb_v4_export() corrupt rt_tree_array");
d500 1
a500 1
		bu_log( "rt_comb_v4_export: Error in combination!\n" );
a790 30
}

/*==================== BEGIN table.c rt_functab interface ========== */

/*
 *			R T _ C O M B _ I M P O R T
 */
int
rt_comb_import(ip, ep, mat, dbip)
struct rt_db_internal	*ip;
CONST struct bu_external *ep;
CONST mat_t		mat;
CONST struct db_i	*dbip;
{
	/* XXX Switch out to right routine, based on database version */
	return rt_comb_v4_import( ip, ep, mat, dbip );
}

/*
 *			R T _ C O M B _ E X P O R T
 */
int
rt_comb_export(ep, ip, local2mm, dbip)
struct bu_external	*ep;
CONST struct rt_db_internal *ip;
double			local2mm;
CONST struct db_i	*dbip;
{
	/* XXX Switch out to right routine, based on database version */
	return rt_comb_v4_export( ep, ip, local2mm, dbip );
@


1.36
log
@
Changed from db_free_external() to bu_free_external()
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_comb.c,v 1.35 2000/03/17 16:08:36 jra Exp $ (ARL)";
a1145 42
}

/*
 *			R T _ V 5 _ E X P O R T
 */
int
rt_v5_export( ep, ip, local2mm, dp, wp, dbip )
struct bu_external		*ep;
CONST struct rt_db_internal	*ip;
double				local2mm;
CONST struct directory		*dp;
CONST struct db_wrapper		*wp;
CONST struct db_i		*dbip;
{
	struct bu_external	temp;
	int			ret;

	RT_CK_DB_INTERNAL(ip);
	RT_CK_DIR(dp);

	/* XXX need v5 versions.  For testing, use v4 in object body. */

	/* Convert Object Body to external form */
	if( ip->idb_type == ID_COMBINATION )  {
		ret = rt_comb_v4_export( &temp, ip, local2mm, dbip );
	} else {
		ret = rt_functab[ip->idb_type].ft_export( &temp, ip, local2mm, dbip );
	}
	if( ret < 0 )  {
		bu_log("rt_v5_export(%s): ft_export error %d\n",
			dp->d_namep, ret );
		return ret;
	}

	if( (ret = db_wrap_v5_external( ep, &temp, dp, wp )) < 0 )  {
		bu_log("rt_v5_export(%s): db_wrap_v5_external error %d\n",
			dp->d_namep, ret );
		return ret;
	}
	/* "temp" has been freed by db_wrap_v4_external() */
	return 0;

@


1.35
log
@Modified db_comb_describe() to handle FASTGEN regions
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_comb.c,v 1.34 2000/03/04 05:53:45 mike Exp $ (ARL)";
d876 1
a876 1
 *  db_free_external(ip) will be performed.
@


1.35.2.1
log
@Added cas for DBV4_NON_REGION_NULL in rt_comb_import()
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_comb.c,v 1.35 2000/03/17 16:08:36 jra Exp $ (ARL)";
a302 1
	case DBV4_NON_REGION_NULL:
@


1.35.2.2
log
@Added Mike's check for long shader names and/or parameter strings
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_comb.c,v 1.35.2.1 2000/08/15 14:22:28 jra Exp $ (ARL)";
a367 1
			return -1;
d501 2
a502 1
		bu_log( "rt_comb_v4_export: Cannot convert following shader string to keyword=value format:\n" );
a505 1
		return -1;
d517 1
a517 10
                        if( len >= sizeof(rp[0].c.c_matname) )  {
                                bu_log("ERROR:  Shader name '%s' exceeds v4 database field, aborting.\n",
                                        bu_vls_addr(&tmp_vls) );
                                return -1;
                        }
                        if( strlen(endp+1) >= sizeof(rp[0].c.c_matparm) )  {
                                bu_log("ERROR:  Shader parameters '%s' exceed v4 database field, aborting.\n",
                                        endp+1);
                                return -1;
                        }
d521 1
a521 6
                        if( bu_vls_strlen(&tmp_vls) >= sizeof(rp[0].c.c_matname) )  {
                                bu_log("ERROR:  Shader name '%s' exceeds v4 database field, aborting.\n",
                                        bu_vls_addr(&tmp_vls) );
                                return -1;
                        }
			strncpy( rp[0].c.c_matname, bu_vls_addr(&tmp_vls), sizeof(rp[0].c.c_matname) );
a527 2

	if( rt_tree_array )  bu_free( (char *)rt_tree_array, "rt_tree_array" );
@


1.34
log
@
Added support for FASTGEN PLATE and VOLUME mode regions,
which are special cases of the orginary BRL-CAD region.
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_comb.c,v 1.33 2000/02/08 07:42:01 mike Exp $ (ARL)";
d751 5
d757 1
@


1.33
log
@
Added checking for problem matricies inside combinations.

It isn't good to have the rotation part of the matrix not be three
unit-length vectors forming an orthonormal basis. Modelers need to put
the (reciprocal of the) scale factor in the matrix[15] element, rather
than multiplying it along the primary diagonal in the rotation area.
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_comb.c,v 1.32 1999/12/29 20:59:45 jra Exp $ (ARL)";
d302 21
a322 1
	comb->region_flag = (rp[0].c.c_flags == 'R');
a468 1
		rp[0].c.c_flags = 'R';
d473 12
d486 1
a486 1
		rp[0].c.c_flags = ' ';
@


1.32
log
@Eliminated an unused variable
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_comb.c,v 1.31 1999/12/22 02:07:37 mike Exp $ (ARL)";
d249 19
a268 1
			rt_mat_dbmat( diskmat, rp[j+1].M.m_mat );
@


1.31
log
@
Removed dead vars
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_comb.c,v 1.30 1999/11/26 21:46:44 mike Exp $ (ARL)";
d191 1
a191 1
	int			i,j;
d291 1
a291 1

d298 1
@


1.30
log
@
Lint cleanups
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_comb.c,v 1.29 1999/11/24 14:39:51 jra Exp $ (ARL)";
a237 1
			struct tree_db_leaf	*mi;
d492 1
a492 2
	int	status;
	int node_count, actual_count;
d514 1
d516 3
@


1.29
log
@Was missing some idb_meth settings for the rt_db_internal structs
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_comb.c,v 1.28 1999/02/01 20:19:30 jra Exp $ (ARL)";
d686 1
a686 1
struct rt_comb_internal	*comb;
d798 1
a798 1
struct rt_db_internal *ip;
d802 1
a802 1
	struct rt_comb_internal	*comb;
@


1.28
log
@rt_comb_v4_import() now complains if a region has both ident and aircode, then ignores aircode.
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_comb.c,v 1.27 1999/01/28 14:48:29 jra Exp $ (ARL)";
d277 1
@


1.27
log
@Fixed a memory leak.
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_comb.c,v 1.26 1999/01/27 20:40:06 jra Exp $ (ARL)";
d291 7
@


1.26
log
@db_comb_describe() now calls db_tree_flatten_describe() for old style listing.
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_comb.c,v 1.25 1999/01/21 16:33:00 jra Exp $ (ARL)";
d554 1
a554 1
		bu_vls_printf( vls, "\n" );
d556 2
@


1.25
log
@rt_comb_v4_import() was not setting region id aircode ... for non-regions resulting in garbage.
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_comb.c,v 1.24 1998/12/17 04:19:09 mike Exp $ (ARL)";
d475 90
d715 2
a716 1
			db_tree_describe( str, comb->tree, 0, 1, mm2local );
@


1.24
log
@Regions now have an associated temperature
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_comb.c,v 1.23 1998/06/22 19:48:33 jra Exp $ (ARL)";
d292 6
d328 2
a329 1
	bu_vls_printf( &comb->material, "gift%d", comb->GIFTmater );
@


1.23
log
@Added code to import and export routines to convet to/from TCL format for shader info.
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/librt/db_comb.c,v 1.22 1998/03/19 15:57:01 jra Exp $ (ARL)";
d283 1
@


1.22
log
@Cahnged to new calling sequence for ft_import and ft_export.
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_comb.c,v 1.21 1997/12/16 06:09:51 mike Exp jra $ (ARL)";
d299 15
a313 4
		bu_vls_strncpy( &comb->shader , rp[0].c.c_matname, 32 );
		if( rp[0].c.c_matparm[0] != '\0' )  {
			bu_vls_putc( &comb->shader, ' ' );
			bu_vls_strncat( &comb->shader , rp[0].c.c_matparm, 60 );
d346 1
d429 28
a456 7
	endp = strchr( bu_vls_addr(&comb->shader), ' ' );
	if( endp )  {
		int	len;
		len = endp - bu_vls_addr(&comb->shader);
		if( len <= 0 && bu_vls_strlen(&comb->shader) > 0 )  {
			bu_log("WARNING: leading spaces on shader '%s' implies NULL shader\n",
				bu_vls_addr(&comb->shader) );
a457 6
		if( len > 32 ) len = 32;
		strncpy( rp[0].c.c_matname, bu_vls_addr(&comb->shader), len );
		strncpy( rp[0].c.c_matparm, endp+1, 60 );
	} else {
		strncpy( rp[0].c.c_matname, bu_vls_addr(&comb->shader), 32 );
		rp[0].c.c_matparm[0] = '\0';
d459 2
@


1.21
log
@Ran h/sed4
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_comb.c,v 1.20 1997/06/25 04:23:40 mike Exp mike $ (ARL)";
d181 1
a181 1
rt_comb_v4_import( ip, ep, matrix )
d185 1
d321 1
a321 1
rt_comb_v4_export( ep, ip, local2mm )
d325 1
d603 1
a603 1
rt_comb_import(ip, ep, mat)
d607 1
d610 1
a610 1
	return rt_comb_v4_import( ip, ep, mat );
d617 1
a617 1
rt_comb_export(ep, ip, local2mm)
d621 1
d624 1
a624 1
	return rt_comb_v4_export( ep, ip, local2mm );
d956 1
a956 1
rt_v5_export( ep, ip, local2mm, dp, wp )
d962 1
d974 1
a974 1
		ret = rt_comb_v4_export( &temp, ip, local2mm );
d976 1
a976 1
		ret = rt_functab[ip->idb_type].ft_export( &temp, ip, local2mm );
@


1.20
log
@Added warning message
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_comb.c,v 1.19 1997/06/20 03:49:18 gdurf Exp mike $ (ARL)";
d251 1
a251 1
			if( mat_is_identity( diskmat ) )  {
d255 1
a255 1
					tp->tr_l.tl_mat = mat_dup( matrix );
d259 1
a259 1
					tp->tr_l.tl_mat = mat_dup( diskmat );
d263 1
a263 1
					tp->tr_l.tl_mat = mat_dup( prod );
d364 1
a364 1
	RT_INIT_EXTERNAL(ep);
d546 1
a546 1
struct rt_vls	*str;
d603 1
a603 1
CONST struct rt_external *ep;
d615 1
a615 1
struct rt_external	*ep;
d655 1
a655 1
struct rt_vls	*str;
@


1.19
log
@Moved db_tcl_{comb,tree}_describe back to tcl.c.
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_comb.c,v 1.18 1997/06/17 20:40:10 gdurf Exp gdurf $ (ARL)";
d419 4
@


1.18
log
@moved db_tcl_{comb,tree}_describe into this file (and out of tcl.c)
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_comb.c,v 1.17 1997/05/22 02:11:17 mike Exp gdurf $ (ARL)";
a45 2
#include "tcl.h"

a983 221



/*
 *		D B _ T C L _ T R E E _ D E S C R I B E
 *
 * Fills a Tcl_DString with a representation of the given tree appropriate
 * for processing by Tcl scripts.  The reason we use Tcl_DStrings instead
 * of bu_vlses is that Tcl_DStrings provide "start/end sublist" commands
 * and automatic escaping of Tcl-special characters.
 *
 * A tree 't' is represented in the following manner:
 *
 *	t := { l dbobjname mat }
 *	   | { u t1 t2 }
 * 	   | { n t1 t2 }
 *	   | { - t1 t2 }
 *	   | { ^ t1 t2 }
 *         | { ! t1 }
 *	   | { G t1 }
 *	   | { X t1 }
 *	   | { N }
 *	   | {}
 *
 * where 'dbobjname' is a string containing the name of a database object,
 *       'mat'       is the matrix preceeding a leaf,
 *       't1', 't2'  are trees (recursively defined).
 *
 * Notice that in most cases, this tree will be grossly unbalanced.
 */

void
db_tcl_tree_describe( dsp, tp )
Tcl_DString		*dsp;
union tree		*tp;
{
	Tcl_DStringStartSublist( dsp );
	
	if( !tp ) goto done; /* empty list */

	RT_CK_TREE(tp);
	switch( tp->tr_op ) {
	case OP_DB_LEAF: {
		struct bu_vls vls;
		Tcl_DStringAppendElement( dsp, "l" );
		Tcl_DStringAppendElement( dsp, tp->tr_l.tl_name );
		bu_vls_init( &vls );
		bn_encode_mat( &vls, tp->tr_l.tl_mat );
		Tcl_DStringAppendElement( dsp, bu_vls_addr(&vls) );
		bu_vls_free( &vls );
		goto done; }

		/* This node is known to be a binary op */
	case OP_UNION:
		Tcl_DStringAppendElement( dsp, "u" );
		goto bin;
	case OP_INTERSECT:
		Tcl_DStringAppendElement( dsp, "n" );
		goto bin;
	case OP_SUBTRACT:
		Tcl_DStringAppendElement( dsp, "-" );
		goto bin;
	case OP_XOR:
		Tcl_DStringAppendElement( dsp, "^" );
	bin:
		db_tcl_tree_describe( dsp, tp->tr_b.tb_left );
		db_tcl_tree_describe( dsp, tp->tr_b.tb_right );
		goto done;

		/* This node is known to be a unary op */
	case OP_NOT:
		Tcl_DStringAppendElement( dsp, "!" );
		goto unary;
	case OP_GUARD:
		Tcl_DStringAppendElement( dsp, "G" );
		goto unary;
	case OP_XNOP:
		Tcl_DStringAppendElement( dsp, "X" );
	unary:
		db_tcl_tree_describe( dsp, tp->tr_b.tb_left );
		goto done;
			
	case OP_NOP:
		Tcl_DStringAppendElement( dsp, "N" );
		goto done;

	default:
		bu_log("db_tcl_tree_describe: bad op %d\n", tp->tr_op);
		bu_bomb("db_tcl_tree_describe\n");
	}

 done:
	Tcl_DStringEndSublist( dsp );

}

/*
 *		D B _ T C L _ C O M B _ D E S C R I B E
 *
 * Sets the interp->result string to a description of the given combination.
 * If the combination is a region, the result is of the form
 *   region id %d air %d los %d GIFTmater %d rgb invalid|{%d %d %d} \
 *          shader %s material %s inherit yes|no tree %t
 * where %t is of the form produced by db_tcl_tree_describe.
 * If the combination is not a region, the result is of the form
 *   comb rgb invalid|{%d %d %d} shader %s material %s inherit yes|no tree %t
 */

int
db_tcl_comb_describe( interp, comb, item )
Tcl_Interp		*interp;
struct rt_comb_internal *comb;
CONST char		*item;
{
	Tcl_DString	ds;
	char		buf[128];

	if( !comb ) {
		Tcl_AppendResult( interp, "error: null combination",
				  (char *)NULL );
		return TCL_ERROR;
	}

	if( item==0 ) {
		Tcl_DStringInit( &ds );
		
		if( !comb->region_flag )
			Tcl_DStringAppendElement( &ds, "comb" );
		else {
			Tcl_DStringAppendElement( &ds, "region" );
			Tcl_DStringAppendElement( &ds, "id" );
			sprintf( buf, "%d", comb->region_id );
			Tcl_DStringAppendElement( &ds, buf );
			Tcl_DStringAppendElement( &ds, "air" );
			sprintf( buf, "%d", comb->aircode );
			Tcl_DStringAppendElement( &ds, buf );
			Tcl_DStringAppendElement( &ds, "los" );
			sprintf( buf, "%d", comb->los );
			Tcl_DStringAppendElement( &ds, buf );
			Tcl_DStringAppendElement( &ds, "GIFTmater" );
			sprintf( buf, "%d", comb->GIFTmater );
			Tcl_DStringAppendElement( &ds, buf );
		}

		Tcl_DStringAppendElement( &ds, "rgb" );
		if( comb->rgb_valid ) {
			sprintf( buf, "%d %d %d", V3ARGS(comb->rgb) );
			Tcl_DStringAppendElement( &ds, buf );
		} else
			Tcl_DStringAppendElement( &ds, "invalid" );

		Tcl_DStringAppendElement( &ds, "shader" );
		Tcl_DStringAppendElement( &ds, rt_vls_addr(&comb->shader) );
		Tcl_DStringAppendElement( &ds, "material" );
		Tcl_DStringAppendElement( &ds, rt_vls_addr(&comb->material) );

		Tcl_DStringAppendElement( &ds, "inherit" );
		Tcl_DStringAppendElement( &ds, comb->inherit ? "yes" : "no" );

		Tcl_DStringAppendElement( &ds, "tree" );
		db_tcl_tree_describe( &ds, comb->tree );

		Tcl_DStringResult( interp, &ds );
		Tcl_DStringFree( &ds );
	} else {
		register int i;
		char itemlwr[16];
		char buf[128];

		for( i = 0; i < 16 && item[i]; i++ ) {
			itemlwr[i] = (isupper(item[i]) ? tolower(item[i]) :
				      item[i]);
		}

		if( strcmp(itemlwr, "id")==0 ) {
			if( !comb->region_flag ) goto not_region;
			sprintf( buf, "%d", comb->region_id );
		} else if( strcmp(itemlwr, "air")==0 ) {
			if( !comb->region_flag ) goto not_region;
			sprintf( buf, "%d", comb->aircode );
		} else if( strcmp(itemlwr, "los")==0 ) {
			if( !comb->region_flag ) goto not_region;
			sprintf( buf, "%d", comb->los );
		} else if( strcmp(itemlwr, "GIFTmater")==0 ) {
			if( !comb->region_flag ) goto not_region;
			sprintf( buf, "%d", comb->GIFTmater );
		} else if( strcmp(itemlwr, "rgb")==0 ) {
			if( comb->rgb_valid )
				sprintf( buf, "%d %d %d", V3ARGS(comb->rgb) );
			else
				strcpy( buf, "invalid" );
		} else if( strcmp(itemlwr, "shader")==0 ) {
			Tcl_AppendResult( interp, rt_vls_addr(&comb->shader),
					  (char *)NULL );
			return TCL_OK;
		} else if( strcmp(itemlwr, "material")==0 ) {
			Tcl_AppendResult( interp, rt_vls_addr(&comb->material),
					  (char *)NULL );
			return TCL_OK;
		} else if( strcmp(itemlwr, "inherit")==0 ) {
			strcpy( buf, comb->inherit ? "yes" : "no" );
		} else if( strcmp(itemlwr, "tree")==0 ) {
			Tcl_DStringInit( &ds );
			db_tcl_tree_describe( &ds, comb->tree );
			Tcl_DStringResult( interp, &ds );
			Tcl_DStringFree( &ds );
			return TCL_OK;
		}

		Tcl_AppendResult( interp, buf, (char *)NULL );
		return TCL_OK;

	not_region:
		Tcl_AppendResult( interp, "item not valid for non-region",
				  (char *)NULL );
		return TCL_ERROR;
	}
}



@


1.17
log
@Declaration
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_comb.c,v 1.16 1997/02/27 15:33:21 jra Exp mike $ (ARL)";
d46 2
d986 221
@


1.16
log
@Lessened restrictions imposed by db_ck_left_heavy_tree().
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_comb.c,v 1.15 1997/02/20 21:19:17 jra Exp jra $ (ARL)";
d540 1
@


1.15
log
@switched to use rt_tree_array instead of tree_list.
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_comb.c,v 1.14 1997/02/05 03:09:13 mike Exp jra $ (ARL)";
d732 1
a732 1
		if( tp->tr_b.tb_right->tr_op != OP_DB_LEAF )
@


1.14
log
@Wrapping improvement.
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /n/vapor/m/cad/librt/RCS/db_comb.c,v 1.13 1997/01/30 02:35:26 mike Exp mike $ (ARL)";
d55 2
a56 5
struct tree_list {
	union tree *tl_tree;
	int	tl_op;
};
#define TREE_LIST_NULL	((struct tree_list *)0)
a57 3
RT_EXTERN( union tree *db_mkbool_tree , (struct tree_list *tree_list , int howfar ) );
RT_EXTERN( union tree *db_mkgift_tree , (struct tree_list *tree_list , int howfar , struct db_tree_state *tsp ) );

d144 3
a146 3
struct tree_list *
db_flatten_tree( tree_list, tp, op )
struct tree_list	*tree_list;
d155 3
a157 3
		tree_list->tl_op = op;
		tree_list->tl_tree = tp;
		return tree_list+1;
d163 3
a165 3
		tree_list = db_flatten_tree( tree_list, tp->tr_b.tb_left, op );
		tree_list = db_flatten_tree( tree_list, tp->tr_b.tb_right, tp->tr_op );
		return tree_list;
d172 1
a172 1
	return( (struct tree_list *)NULL ); /* for the compiler */
d187 1
a187 1
	struct tree_list	*tree_list;
d206 1
a206 1
		tree_list = (struct tree_list *)bu_calloc( node_count , sizeof( struct tree_list ) , "tree_list" );
d208 1
a208 1
		tree_list = (struct tree_list *)NULL;
d214 1
a214 1
			bu_free( (genptr_t)tree_list , "rt_comb_v4_import: tree_list" );
d222 1
a222 1
				tree_list[j].tl_op = OP_INTERSECT;
d225 1
a225 1
				tree_list[j].tl_op = OP_SUBTRACT;
d231 1
a231 1
				tree_list[j].tl_op = OP_UNION;
d242 1
a242 1
			tree_list[j].tl_tree = tp;
d270 1
a270 1
		tree = db_mkgift_tree( tree_list, node_count, (struct db_tree_state *)NULL );
d311 1
a311 1
	if( tree_list )  bu_free( (genptr_t)tree_list, "tree_list" );
d328 1
a328 1
	struct tree_list	*tree_list;
d352 1
a352 1
		tree_list = (struct tree_list *)bu_calloc( node_count , sizeof( struct tree_list ) , "tree_list" );
d355 1
a355 1
		actual_count = db_flatten_tree( tree_list, comb->tree, OP_UNION ) - tree_list;
d359 1
a359 1
		tree_list = (struct tree_list *)NULL;
d371 1
a371 1
		tp = tree_list[j].tl_tree;
d376 1
a376 1
		switch( tree_list[j].tl_op )  {
d387 1
a387 1
			bu_bomb("rt_comb_v4_export() corrupt tree_list");
d790 1
a790 1
 *  Given a tree_list array, build a tree of "union tree" nodes
d792 1
a792 1
 *  tree_list array used is replaced with a TREE_NULL.
d797 2
a798 2
db_mkbool_tree( tree_list, howfar )
struct tree_list *tree_list;
d801 1
a801 1
	register struct tree_list *tlp;
d803 1
a803 1
	register struct tree_list *first_tlp = (struct tree_list *)0;
d812 1
a812 1
	for( i=howfar, inuse=0, tlp=tree_list; i>0; i--, tlp++ )  {
d839 1
a839 1
	for( i=howfar-(tlp-tree_list); i>0; i--, tlp++ )  {
d860 1
a860 1
struct tree_list	*trees;
d864 2
a865 2
	register struct tree_list *tstart;
	register struct tree_list *tnext;
@


1.13
log
@Deleted rt_v4_export() in favor of rt_db_put_internal()
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_comb.c,v 1.12 1997/01/30 02:29:34 mike Exp mike $ (ARL)";
d696 5
a700 3
	*op = *ip;		/* struct copy */
	ip->ext_buf = NULL;
	ip->ext_nbytes = 0;
@


1.12
log
@Deleted rt_get_comb().  Use rt_db_get_internal() instead.
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_comb.c,v 1.11 1997/01/30 01:47:03 mike Exp mike $ (ARL)";
a702 41
	return 0;
}

/*
 *			R T _ V 4 _ E X P O R T
 *
 *  Soup-to-nuts v4 export, for combinations and geometry.
 *  XXX should be phased out in favor of rt_db_put_internal().
 *  The next step after this is probably to call db_put_external().
 *  (which needs to be changed to not do the NAMEMOVE.)
 */
int
rt_v4_export( ep, ip, local2mm, dp )
struct bu_external		*ep;
CONST struct rt_db_internal	*ip;
double				local2mm;
CONST struct directory		*dp;
{
	struct bu_external	temp;
	int			ret;

	RT_CK_DB_INTERNAL(ip);
	RT_CK_DIR(dp);

	if( ip->idb_type == ID_COMBINATION )  {
		ret = rt_comb_v4_export( &temp, ip, local2mm );
	} else {
		ret = rt_functab[ip->idb_type].ft_export( &temp, ip, local2mm );
	}
	if( ret < 0 )  {
		bu_log("rt_v4_export(%s): ft_export error %d\n",
			dp->d_namep, ret );
		return ret;
	}

	if( (ret = db_wrap_v4_external( ep, &temp, dp )) < 0 )  {
		bu_log("rt_v4_export(%s): db_wrap_v4_external error %d\n",
			dp->d_namep, ret );
		return ret;
	}
	/* "temp" has been freed by db_wrap_v4_external() */
@


1.11
log
@Added support for combinations to be full members of the function table.
Now import/export operations on them work just like on any solid.
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_comb.c,v 1.10 1997/01/29 06:30:10 mike Exp mike $ (ARL)";
a434 37
}

/*
 *			R T _ G E T _ C O M B
 *
 *  A convenience wrapper to retrive a combination from the database
 *  into internal form.
 *
 *  Returns -
 *	-1	FAIL
 *	 0	OK
 *
 *  This should be eliminated in favor of rt_db_get_internal().
 */
int
rt_get_comb( ip, dp, matp, dbip )
struct rt_db_internal	*ip;
CONST struct directory	*dp;
CONST matp_t		matp;
CONST struct db_i	*dbip;
{
	struct bu_external	ext;

	RT_CK_DIR(dp);
	RT_CHECK_DBI( dbip );

	/* Load the entire combination into contiguous memory */
	BU_INIT_EXTERNAL( &ext );
	if( db_get_external( &ext, dp, dbip ) < 0 )
		return -1;

	/* Switch out to right routine, based on database version */
	if( rt_comb_v4_import( ip, &ext, matp ) < 0 )
		return -1;

	db_free_external( &ext );
	return 0;
@


1.10
log
@Added safety check.
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_comb.c,v 1.9 1997/01/29 00:59:34 mike Exp mike $ (ARL)";
d64 4
d69 31
d438 224
d689 1
a689 8
 *			R T _ G E T _ C O M B
 *
 *  A convenience wrapper to retrive a combination from the database
 *  into internal form.
 *
 *  Returns -
 *	-1	FAIL
 *	 0	OK
d692 5
a696 5
rt_get_comb( ip, dp, matp, dbip )
struct rt_db_internal	*ip;
CONST struct directory	*dp;
CONST matp_t		matp;
CONST struct db_i	*dbip;
d698 1
a698 1
	struct bu_external	ext;
d700 3
a702 2
	RT_CK_DIR(dp);
	RT_CHECK_DBI( dbip );
d704 1
a704 10
	/* Load the entire combination into contiguous memory */
	BU_INIT_EXTERNAL( &ext );
	if( db_get_external( &ext, dp, dbip ) < 0 )
		return -1;

	/* Switch out to right routine, based on database version */
	if( rt_comb_v4_import( ip, &ext, matp ) < 0 )
		return -1;

	db_free_external( &ext );
d708 2
d747 1
a747 1
 *  (See also rt_db_put_internal() ).
@


1.9
log
@Now can export combinations with null trees.
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_comb.c,v 1.8 1997/01/29 00:34:21 mike Exp mike $ (ARL)";
d277 2
a278 1
	comb->inherit = rp[0].c.c_inherit;
@


1.8
log
@JRA mod.
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_comb.c,v 1.7 1997/01/02 13:42:06 jra Exp jra $ (ARL)";
d73 1
d309 1
a309 1
	if( db_ck_v4gift_tree( comb->tree ) < 0 )  {
d321 1
a321 1
	if( node_count )
d323 6
a328 1
	else
d330 2
a331 5

	/* Convert tree into array form */
	actual_count = db_flatten_tree( tree_list, comb->tree, OP_UNION ) - tree_list;
	if( actual_count > node_count )  bu_bomb("rt_comb_v4_export() array overflow!");
	if( actual_count < node_count )  bu_log("WARNING rt_comb_v4_export() array underflow! %d < %d", actual_count, node_count);
@


1.7
log
@Some minor mods in routines under construction (just for a clean compile).
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_comb.c,v 1.6 1997/01/02 13:32:04 jra Exp jra $ (ARL)";
d266 7
a272 4
	bu_vls_strncpy( &comb->shader , rp[0].c.c_matname, 32 );
	if( rp[0].c.c_matparm[0] != '\0' )  {
		bu_vls_putc( &comb->shader, ' ' );
		bu_vls_strncat( &comb->shader , rp[0].c.c_matparm, 60 );
@


1.6
log
@bparker's changes to using bn_* routines.
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_comb.c,v 1.5 1996/12/04 02:50:27 mike Exp bparker $ (ARL)";
d104 1
d141 2
d436 1
a436 1
CONST mat_t		*matp;
d768 2
@


1.5
log
@Combined ma_matname and ma_matparm into a single string, ma_shader.
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_comb.c,v 1.4 1996/10/25 06:58:58 mike Exp mike $ (ARL)";
d229 1
a229 1
					mat_mul( prod, matrix, diskmat );
d354 1
a354 1
			rt_dbmat_mat( rp[j+1].M.m_mat, mat_identity );
@


1.4
log
@Bare skeleton of V5 export
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_comb.c,v 1.3 1996/10/25 02:12:47 mike Exp mike $ (ARL)";
d246 1
a246 2
	bu_vls_init( &comb->shader_name );
	bu_vls_init( &comb->shader_param );
d263 5
a267 2
	bu_vls_strncpy( &comb->shader_name , rp[0].c.c_matname, 32 );
	bu_vls_strncpy( &comb->shader_param , rp[0].c.c_matparm, 60 );
d295 1
d376 11
a386 2
	strncpy( rp[0].c.c_matname, bu_vls_addr(&comb->shader_name), 32 );
	strncpy( rp[0].c.c_matparm, bu_vls_addr(&comb->shader_param), 60 );
d411 1
a411 2
	bu_vls_free( &comb->shader_name );
	bu_vls_free( &comb->shader_param );
@


1.3
log
@Added rt_v4_export(), db_wrap_v4_external()
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_comb.c,v 1.2 1996/10/23 05:30:26 mike Exp mike $ (ARL)";
d500 1
a500 1
		ret = rt_functab[ip->idb_type].ft_export( &temp, ip, 1.0 );
d725 70
@


1.2
log
@Added rt_comb_v4_export()
@
text
@d4 11
d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/librt/RCS/db_comb.c,v 1.1 1996/10/19 05:38:42 mike Exp mike $ (ARL)";
a278 3
 *
 *  XXX Note:  all export routines need to know name of object,
 *  XXX compression flags, other header-common fields.  Via directory pointer??
d282 1
a282 1
struct rt_external		*ep;
d357 1
a357 1
	/* XXX c_name[] filled in by caller? */
d364 2
d442 75
@


1.1
log
@Initial revision
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
d54 78
d241 6
a246 4
	comb->region_id = rp[0].c.c_regionid;
	comb->aircode = rp[0].c.c_aircode;
	comb->GIFTmater = rp[0].c.c_material;
	comb->los = rp[0].c.c_los;
d248 5
a252 4
	comb->rgb_valid = rp[0].c.c_override;
	comb->rgb[0] = rp[0].c.c_rgb[0];
	comb->rgb[1] = rp[0].c.c_rgb[1];
	comb->rgb[2] = rp[0].c.c_rgb[2];
d264 104
@
