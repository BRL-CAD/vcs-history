head	11.18;
access;
symbols
	ansi-20040405-merged:11.14.2.3
	postmerge-20040405-ansi:11.16
	premerge-20040404-ansi:11.15
	postmerge-autoconf:11.15
	autoconf-freeze:11.14.10.2
	premerge-autoconf:11.15
	ansi-20040316-freeze:11.14.2.2
	postmerge-20040315-windows:11.15
	premerge-20040315-windows:11.15
	windows-20040315-freeze:11.14.4.1
	autoconf-20031203:11.14
	autoconf-20031202:11.14
	autoconf-branch:11.14.0.10
	phong-branch:11.14.0.8
	photonmap-branch:11.14.0.6
	rel-6-1-DP:11.14
	windows-branch:11.14.0.4
	rel-6-0-2:11.12
	ansi-branch:11.14.0.2
	rel-6-0-1-branch:11.12.0.2
	hartley-6-0-post:11.13
	hartley-6-0-pre:11.12
	rel-6-0-1:11.12
	rel-6-0:11.12
	rel-5-4:11.4
	offsite-5-3-pre:11.9
	rel-5-3:11.4
	rel-5-2:11.4
	rel-5-1-branch:11.4.0.2
	rel-5-1:11.4
	rel-5-0:11.2
	rel-5-0-beta:11.2
	rel-4-5:11.1
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1;
locks; strict;
comment	@ * @;


11.18
date	2004.05.21.18.07.31;	author morrison;	state dead;
branches;
next	11.17;

11.17
date	2004.05.10.15.30.46;	author erikg;	state Exp;
branches;
next	11.16;

11.16
date	2004.04.05.08.48.57;	author morrison;	state Exp;
branches;
next	11.15;

11.15
date	2004.02.02.17.39.21;	author morrison;	state Exp;
branches;
next	11.14;

11.14
date	2002.08.20.17.08.01;	author jra;	state Exp;
branches
	11.14.2.1
	11.14.4.1
	11.14.10.1;
next	11.13;

11.13
date	2002.08.15.20.55.13;	author hartley;	state Exp;
branches;
next	11.12;

11.12
date	2001.10.02.19.24.30;	author jra;	state Exp;
branches;
next	11.11;

11.11
date	2001.04.20.22.29.47;	author morrison;	state Exp;
branches;
next	11.10;

11.10
date	2001.03.31.01.57.09;	author morrison;	state Exp;
branches;
next	11.9;

11.9
date	2000.10.18.18.10.35;	author butler;	state Exp;
branches;
next	11.8;

11.8
date	2000.07.10.23.01.35;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	2000.06.30.15.38.03;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	2000.06.30.15.31.15;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	2000.06.27.17.37.31;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	2000.04.12.02.34.36;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	99.11.17.02.42.02;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	99.05.27.19.10.42;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.57.00;	author mike;	state Rel4_4;
branches;
next	10.3;

10.3
date	94.08.10.18.39.15;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	94.06.22.03.10.23;	author butler;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.40.24;	author mike;	state Rel4_0;
branches;
next	9.12;

9.12
date	91.09.20.23.26.07;	author butler;	state Exp;
branches;
next	9.11;

9.11
date	91.06.30.00.10.58;	author mike;	state Exp;
branches;
next	9.10;

9.10
date	91.06.22.22.30.33;	author mike;	state Exp;
branches;
next	9.9;

9.9
date	91.05.18.03.01.30;	author mike;	state Exp;
branches;
next	9.8;

9.8
date	91.01.25.21.19.16;	author mike;	state Exp;
branches;
next	9.7;

9.7
date	91.01.25.20.36.07;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	91.01.15.23.46.05;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	90.10.06.02.05.21;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	90.05.01.05.14.43;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	90.03.14.15.05.58;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	90.03.03.04.54.15;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.56.26;	author mike;	state Rel3_5;
branches;
next	8.9;

8.9
date	89.04.27.23.10.15;	author phil;	state Exp;
branches;
next	8.8;

8.8
date	89.04.17.17.19.49;	author mike;	state Exp;
branches;
next	8.7;

8.7
date	89.04.11.12.09.21;	author phil;	state Exp;
branches;
next	8.6;

8.6
date	89.04.08.02.47.58;	author mike;	state Exp;
branches;
next	8.5;

8.5
date	89.03.14.01.50.07;	author phil;	state Exp;
branches;
next	8.4;

8.4
date	89.02.17.11.01.46;	author mike;	state Exp;
branches;
next	8.3;

8.3
date	89.01.09.04.54.25;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	88.12.13.03.25.36;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.31.41;	author mike;	state Rel3_0;
branches;
next	7.3;

7.3
date	88.05.14.00.01.16;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	88.02.06.05.36.52;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.34.13;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.07.56.30;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.12.22;	author mike;	state Rel;
branches;
next	1.4;

1.4
date	87.05.28.20.26.28;	author phil;	state Exp;
branches;
next	1.3;

1.3
date	87.04.28.00.27.55;	author phil;	state Exp;
branches;
next	1.2;

1.2
date	87.03.28.02.37.24;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	87.03.24.01.06.13;	author phil;	state Exp;
branches;
next	;

11.14.2.1
date	2002.09.19.18.01.36;	author morrison;	state Exp;
branches;
next	11.14.2.2;

11.14.2.2
date	2003.02.11.00.06.56;	author morrison;	state Exp;
branches;
next	11.14.2.3;

11.14.2.3
date	2004.03.17.21.18.48;	author morrison;	state Exp;
branches;
next	;

11.14.4.1
date	2004.03.11.23.43.39;	author morrison;	state Exp;
branches;
next	;

11.14.10.1
date	2004.02.12.18.37.42;	author erikg;	state Exp;
branches;
next	11.14.10.2;

11.14.10.2
date	2004.03.15.14.07.20;	author erikg;	state Exp;
branches;
next	;


desc
@Intersect RAY with SPH
@


11.18
log
@moved to src/
@
text
@/*
 *			G _ S P H . C
 *
 *  Purpose -
 *	Intersect a ray with a Sphere
 *	Special case of the Generalized Ellipsoid
 *
 *  Authors -
 *	Phillip Dykstra
 *	Dave Becker		(Vectorization)
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1985-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSsph[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/g_sph.c,v 11.17 2004/05/10 15:30:46 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef HAVE_STRING_H
#include <string.h>
#endif
#include <math.h>
#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "rtgeom.h"
#include "./debug.h"

/*
 *  Algorithm:
 *  
 *  Given V, A, where |A| = Radius, there is a set of points on this sphere
 *  
 *  { (x,y,z) | (x,y,z) is on sphere defined by V, A }
 *  
 *  To find the intersection of a line with the sphere, consider
 *  the parametric line L:
 *  
 *  	L : { P(n) | P + t(n) . D }
 *  
 *  Call W the actual point of intersection between L and the sphere.
 *
 *  NORMALS.  Given the point W on the sphere, what is the vector
 *  normal to the tangent plane at that point?
 *  
 *  N = (W - V) / |A|
 */

struct sph_specific {
	vect_t	sph_V;		/* Vector to center of sphere */
	fastf_t	sph_radsq;	/* Radius squared */
	fastf_t	sph_invrad;	/* Inverse radius (for normal) */
	fastf_t	sph_rad;	/* Radius */
	mat_t	sph_SoR;	/* Rotate and scale for UV mapping */
};

/*
 *  			R T _ S P H _ P R E P
 *  
 *  Given a pointer to a GED database record, and a transformation matrix,
 *  determine if this is a valid sphere, and if so, precompute various
 *  terms of the formula.
 *  
 *  Returns -
 *  	0	SPH is OK
 *  	!0	Error in description
 *  
 *  Implicit return -
 *  	A struct sph_specific is created, and it's address is stored in
 *  	stp->st_specific for use by rt_sph_shot().
 *	If the ELL is really a SPH, stp->st_id is modified to ID_SPH.
 */
int
rt_sph_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
{
	register struct sph_specific *sph;
	LOCAL fastf_t	magsq_a, magsq_b, magsq_c;
	LOCAL vect_t	Au, Bu, Cu;	/* A,B,C with unit length */
	LOCAL fastf_t	f;
	struct rt_ell_internal	*eip;

	eip = (struct rt_ell_internal *)ip->idb_ptr;
	RT_ELL_CK_MAGIC(eip);

	/* Validate that |A| > 0, |B| > 0, |C| > 0 */
	magsq_a = MAGSQ( eip->a );
	magsq_b = MAGSQ( eip->b );
	magsq_c = MAGSQ( eip->c );
	if( magsq_a < rtip->rti_tol.dist || magsq_b < rtip->rti_tol.dist || magsq_c < rtip->rti_tol.dist ) {
		bu_log("sph(%s):  zero length A(%g), B(%g), or C(%g) vector\n",
			stp->st_name, magsq_a, magsq_b, magsq_c );
		return(1);		/* BAD */
	}

	/* Validate that |A|, |B|, and |C| are nearly equal */
	if( fabs(magsq_a - magsq_b) > 0.0001
	    || fabs(magsq_a - magsq_c) > 0.0001 ) {
#if 0	    	
	    	/* Ordinarily, don't say anything here, will handle as ELL */
		bu_log("sph(%s):  non-equal length A, B, C vectors\n",
			stp->st_name );
#endif
		return(1);		/* ELL, not SPH */
	}

	/* Create unit length versions of A,B,C */
	f = 1.0/sqrt(magsq_a);
	VSCALE( Au, eip->a, f );
	f = 1.0/sqrt(magsq_b);
	VSCALE( Bu, eip->b, f );
	f = 1.0/sqrt(magsq_c);
	VSCALE( Cu, eip->c, f );

	/* Validate that A.B == 0, B.C == 0, A.C == 0 (check dir only) */
	f = VDOT( Au, Bu );
	if( ! NEAR_ZERO(f, rtip->rti_tol.dist) )  {
		bu_log("sph(%s):  A not perpendicular to B, f=%f\n",stp->st_name, f);
		return(1);		/* BAD */
	}
	f = VDOT( Bu, Cu );
	if( ! NEAR_ZERO(f, rtip->rti_tol.dist) )  {
		bu_log("sph(%s):  B not perpendicular to C, f=%f\n",stp->st_name, f);
		return(1);		/* BAD */
	}
	f = VDOT( Au, Cu );
	if( ! NEAR_ZERO(f, rtip->rti_tol.dist) )  {
		bu_log("sph(%s):  A not perpendicular to C, f=%f\n",stp->st_name, f);
		return(1);		/* BAD */
	}

	/*
	 *  This ELL is really an SPH
	 */
	stp->st_id = ID_SPH;		/* "fix" soltab ID */
	stp->st_meth = &rt_functab[ID_SPH];

	/* Solid is OK, compute constant terms now */
	BU_GETSTRUCT( sph, sph_specific );
	stp->st_specific = (genptr_t)sph;

	VMOVE( sph->sph_V, eip->v );

	sph->sph_radsq = magsq_a;
	sph->sph_rad = sqrt(sph->sph_radsq);
	sph->sph_invrad = 1.0 / sph->sph_rad;

	/*
	 * Save the matrix which rotates our ABC to world
	 * XYZ respectively, and scales points on surface
	 * to unit length.  Used here in UV mapping.
	 * See ell.c for details.
	 */
	MAT_IDN( sph->sph_SoR );
	VSCALE( &sph->sph_SoR[0], eip->a, 1.0/magsq_a );
	VSCALE( &sph->sph_SoR[4], eip->b, 1.0/magsq_b );
	VSCALE( &sph->sph_SoR[8], eip->c, 1.0/magsq_c );

	/* Compute bounding sphere */
	VMOVE( stp->st_center, sph->sph_V );
	stp->st_aradius = stp->st_bradius = sph->sph_rad;

	/* Compute bounding RPP */
	stp->st_min[X] = sph->sph_V[X] - sph->sph_rad;
	stp->st_max[X] = sph->sph_V[X] + sph->sph_rad;
	stp->st_min[Y] = sph->sph_V[Y] - sph->sph_rad;
	stp->st_max[Y] = sph->sph_V[Y] + sph->sph_rad;
	stp->st_min[Z] = sph->sph_V[Z] - sph->sph_rad;
	stp->st_max[Z] = sph->sph_V[Z] + sph->sph_rad;

	return(0);			/* OK */
}

/*
 *			R T _ S P H _ P R I N T
 */
void
rt_sph_print(register const struct soltab *stp)
{
	register const struct sph_specific *sph =
		(struct sph_specific *)stp->st_specific;

	VPRINT("V", sph->sph_V);
	bu_log("Rad %g\n", sph->sph_rad);
	bu_log("Radsq %g\n", sph->sph_radsq);
	bu_log("Invrad %g\n", sph->sph_invrad);
	bn_mat_print("S o R", sph->sph_SoR );
}

/*
 *  			R T _ S P H _ S H O T
 *  
 *  Intersect a ray with a sphere.
 *  If an intersection occurs, a struct seg will be acquired
 *  and filled in.
 *  Notes: In the quadratic equation,
 *   A is MAGSQ(r_dir) which is always equal to 1, so it does not appear.
 *   The sign of B is reversed (vector is reversed) to save negation.
 *   We have factored out the 2 and 4 constants.
 *  Claim: The straight quadratic formula leads to precision problems
 *   if either A or C are small.  In our case A is always 1.  C is a
 *   radial distance of the ray origin from the sphere surface.  Thus
 *   if we are shooting from near the surface we may have problems.
 *   XXX - investigate this.
 *  
 *  Returns -
 *  	0	MISS
 *	>0	HIT
 */
int
rt_sph_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
{
	register struct sph_specific *sph =
		(struct sph_specific *)stp->st_specific;
	register struct seg *segp;
	LOCAL vect_t	ov;		/* ray orgin to center (V - P) */
	FAST fastf_t	magsq_ov;	/* length squared of ov */
	FAST fastf_t	b;		/* second term of quadratic eqn */
	FAST fastf_t	root;		/* root of radical */

	VSUB2( ov, sph->sph_V, rp->r_pt );
	b = VDOT( rp->r_dir, ov );
	magsq_ov = MAGSQ(ov);

	if( magsq_ov >= sph->sph_radsq ) {
		/* ray origin is outside of sphere */
		if( b < 0 ) {
			/* ray direction is away from sphere */
			return(0);		/* No hit */
		}
		root = b*b - magsq_ov + sph->sph_radsq;
		if( root <= 0 ) {
			/* no real roots */
			return(0);		/* No hit */
		}
	} else {
		root = b*b - magsq_ov + sph->sph_radsq;
	}
	root = sqrt(root);

	RT_GET_SEG(segp, ap->a_resource);
	segp->seg_stp = stp;

	/* we know root is positive, so we know the smaller t */
	segp->seg_in.hit_dist = b - root;
	segp->seg_out.hit_dist = b + root;
	BU_LIST_INSERT( &(seghead->l), &(segp->l) );
	return(2);			/* HIT */
}

#define SEG_MISS(SEG)		(SEG).seg_stp=(struct soltab *) 0;	
/*
 *			R T _ S P H _ V S H O T
 *
 *  This is the Becker vectorized version
 */
void
rt_sph_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		  	       /* Number of ray/object pairs */
                  	    
{
	register struct sph_specific *sph;
	LOCAL vect_t	ov;		/* ray orgin to center (V - P) */
	FAST fastf_t	magsq_ov;	/* length squared of ov */
	FAST fastf_t	b;		/* second term of quadratic eqn */
	FAST fastf_t	root;		/* root of radical */
	register int    i;

	/* for each ray/sphere pair */
#	include "noalias.h"
	for(i = 0; i < n; i++){
#if !CRAY	/* XXX currently prevents vectorization on cray */
	 	if (stp[i] == 0) continue; /* stp[i] == 0 signals skip ray */
#endif

		sph = (struct sph_specific *)stp[i]->st_specific;
		VSUB2( ov, sph->sph_V, rp[i]->r_pt );
		b = VDOT( rp[i]->r_dir, ov );
	        magsq_ov = MAGSQ(ov);

		if( magsq_ov >= sph->sph_radsq ) {
			/* ray origin is outside of sphere */
			if( b < 0 ) {
				/* ray direction is away from sphere */
				SEG_MISS(segp[i]);		/* No hit */
				continue;
			}
			root = b*b - magsq_ov + sph->sph_radsq;
			if( root <= 0 ) {
				/* no real roots */
				SEG_MISS(segp[i]);		/* No hit */
				continue;
			}
		} else {
			root = b*b - magsq_ov + sph->sph_radsq;
		}
		root = sqrt(root);

		segp[i].seg_stp = stp[i];

		/* we know root is positive, so we know the smaller t */
		segp[i].seg_in.hit_dist = b - root;
		segp[i].seg_out.hit_dist = b + root;
	}
}

/*
 *  			R T _ S P H _ N O R M
 *  
 *  Given ONE ray distance, return the normal and entry/exit point.
 */
void
rt_sph_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
{
	register struct sph_specific *sph =
		(struct sph_specific *)stp->st_specific;

	VJOIN1( hitp->hit_point, rp->r_pt, hitp->hit_dist, rp->r_dir );
	VSUB2( hitp->hit_normal, hitp->hit_point, sph->sph_V );
	VSCALE( hitp->hit_normal, hitp->hit_normal, sph->sph_invrad );
}

/*
 *			R T _ S P H _ C U R V E
 *
 *  Return the curvature of the sphere.
 */
void
rt_sph_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
{
	register struct sph_specific *sph =
		(struct sph_specific *)stp->st_specific;

 	cvp->crv_c1 = cvp->crv_c2 = - sph->sph_invrad;

	/* any tangent direction */
	bn_vec_ortho( cvp->crv_pdir, hitp->hit_normal );
}

/*
 *  			R T _ S P H _ U V
 *  
 *  For a hit on the surface of an SPH, return the (u,v) coordinates
 *  of the hit point, 0 <= u,v <= 1.
 *  u = azimuth
 *  v = elevation
 */
void
rt_sph_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
{
	register struct sph_specific *sph =
		(struct sph_specific *)stp->st_specific;
	LOCAL fastf_t r;
	LOCAL vect_t work;
	LOCAL vect_t pprime;

	/* hit_point is on surface;  project back to unit sphere,
	 * creating a vector from vertex to hit point which always
	 * has length=1.0
	 */
	VSUB2( work, hitp->hit_point, sph->sph_V );
	MAT4X3VEC( pprime, sph->sph_SoR, work );
	/* Assert that pprime has unit length */

	/* U is azimuth, atan() range: -pi to +pi */
	uvp->uv_u = bn_atan2( pprime[Y], pprime[X] ) * bn_inv2pi;
	if( uvp->uv_u < 0 )
		uvp->uv_u += 1.0;
	/*
	 *  V is elevation, atan() range: -pi/2 to +pi/2,
	 *  because sqrt() ensures that X parameter is always >0
	 */
	uvp->uv_v = bn_atan2( pprime[Z],
		sqrt( pprime[X] * pprime[X] + pprime[Y] * pprime[Y]) ) *
		bn_invpi + 0.5;

	/* approximation: r / (circumference, 2 * pi * aradius) */
	r = ap->a_rbeam + ap->a_diverge * hitp->hit_dist;
	uvp->uv_du = uvp->uv_dv =
		bn_inv2pi * r / stp->st_aradius;
}

/*
 *		R T _ S P H _ F R E E
 */
void
rt_sph_free(register struct soltab *stp)
{
	register struct sph_specific *sph =
		(struct sph_specific *)stp->st_specific;

	bu_free( (char *)sph, "sph_specific" );
}

int
rt_sph_class(void)
{
	return(0);
}

/* ELL versions of the plot and tess functions are used */


#if 0
/*
 *			R T _ S P H _ I M P O R T 5
 *
 *  Import a sphere from the v5 database format to
 *  the internal structure.
 *  Apply modeling transformations as well.
 */
int
rt_sph_import5( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
{
	struct rt_sph_internal	*sip;
	LOCAL fastf_t		vec[3+1];

	BU_CK_EXTERNAL( ep );

	RT_CK_DB_INTERNAL( ip );
	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_SPH;
	ip->idb_meth = &rt_functab[ID_SPH];
	ip->idb_ptr = bu_malloc( sizeof(struct rt_sph_internal), "rt_sph_internal");

	sip = (struct rt_sph_internal *)ip->idb_ptr;
	sip->magic = RT_SPH_INTERNAL_MAGIC;

	/* Convert from database to internal format */
	htond( vec, ep->ext_buf, 3+1 );

	/* Apply modeling transformations */
	MAT4X3PNT( sip->v, mat, &vec[0*3] );
	MAT4XSCALOR( sip->r, mat, vec[1*3] );

	return(0);		/* OK */
}

/*
 *			R T _ S P H _ E X P O R T 5
 */
int
rt_sph_export5( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
{
	struct rt_sph_internal	*tip;
	union record		*rec;

	RT_CK_DB_INTERNAL(ip);
	if( ip->idb_type != ID_ELL )  return(-1);
	tip = (struct rt_sph_internal *)ip->idb_ptr;
	RT_ELL_CK_MAGIC(tip);

	BU_CK_EXTERNAL(ep);
	ep->ext_nbytes = sizeof(union record);
	ep->ext_buf = (genptr_t)bu_calloc( 1, ep->ext_nbytes, "sph external");
	rec = (union record *)ep->ext_buf;

	rec->s.s_id = ID_SOLID;
	rec->s.s_type = GENELL;

	/* NOTE: This also converts to dbfloat_t */
	VSCALE( &rec->s.s_values[0], tip->v, local2mm );
	VSCALE( &rec->s.s_values[3], tip->a, local2mm );
	VSCALE( &rec->s.s_values[6], tip->b, local2mm );
	VSCALE( &rec->s.s_values[9], tip->c, local2mm );

	return(0);
}
#endif
@


11.17
log
@change conf.h to a wrapped config.h
@
text
@d22 1
a22 1
static const char RCSsph[] = "@@(#)$Header: /cvs/brlcad/librt/g_sph.c,v 11.16 2004/04/05 08:48:57 morrison Exp $ (BRL)";
@


11.16
log
@merge of ansi-6-0-branch into HEAD
@
text
@d22 1
a22 1
static const char RCSsph[] = "@@(#)$Header$ (BRL)";
d25 5
a29 1
#include "conf.h"
@


11.15
log
@update copyright to include span through 2003
@
text
@d22 1
a22 1
static const char RCSsph[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_sph.c,v 11.14 2002/08/20 17:08:01 jra Exp $ (BRL)";
d83 1
a83 4
rt_sph_prep( stp, ip, rtip )
struct soltab		*stp;
struct rt_db_internal	*ip;
struct rt_i		*rtip;
d98 1
a98 1
	if( magsq_a < 0.005 || magsq_b < 0.005 || magsq_c < 0.005 ) {
d125 1
a125 1
	if( ! NEAR_ZERO(f, 0.005) )  {
d130 1
a130 1
	if( ! NEAR_ZERO(f, 0.005) )  {
d135 1
a135 1
	if( ! NEAR_ZERO(f, 0.005) )  {
d186 1
a186 2
rt_sph_print( stp )
register const struct soltab *stp;
d219 1
a219 5
rt_sph_shot( stp, rp, ap, seghead )
struct soltab		*stp;
register struct xray	*rp;
struct application	*ap;
struct seg		*seghead;
d266 6
a271 6
rt_sph_vshot( stp, rp, segp, n, ap )
struct soltab	       *stp[]; /* An array of solid pointers */
struct xray		*rp[]; /* An array of ray pointers */
struct  seg            segp[]; /* array of segs (results returned) */
int		  	    n; /* Number of ray/object pairs */
struct application	*ap;
d324 1
a324 4
rt_sph_norm( hitp, stp, rp )
register struct hit *hitp;
struct soltab *stp;
register struct xray *rp;
d340 1
a340 4
rt_sph_curve( cvp, hitp, stp )
register struct curvature *cvp;
register struct hit *hitp;
struct soltab *stp;
d360 1
a360 5
rt_sph_uv( ap, stp, hitp, uvp )
struct application *ap;
struct soltab *stp;
register struct hit *hitp;
register struct uvcoord *uvp;
d398 1
a398 2
rt_sph_free( stp )
register struct soltab *stp;
d407 1
a407 1
rt_sph_class()
@


11.14
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1985 by the United States Army.
d22 1
a22 1
static const char RCSsph[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_sph.c,v 11.12 2001/10/02 19:24:30 jra Exp $ (BRL)";
@


11.14.4.1
log
@sync to HEAD...
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d22 1
a22 1
static const char RCSsph[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/g_sph.c,v 11.15 2004/02/02 17:39:21 morrison Exp $ (BRL)";
@


11.14.10.1
log
@merge from HEAD
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d22 1
a22 1
static const char RCSsph[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_sph.c,v 11.15 2004/02/02 17:39:21 morrison Exp $ (BRL)";
@


11.14.10.2
log
@merge from head
@
text
@d22 1
a22 1
static const char RCSsph[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_sph.c,v 11.14.10.1 2004/02/12 18:37:42 erikg Exp $ (BRL)";
@


11.14.2.1
log
@Initial ANSIfication
@
text
@d22 1
a22 1
static const char RCSsph[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_sph.c,v 11.14 2002/08/20 17:08:01 jra Exp $ (BRL)";
d83 4
a86 1
rt_sph_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
d189 2
a190 1
rt_sph_print(register const struct soltab *stp)
d223 5
a227 1
rt_sph_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
d274 6
a279 6
rt_sph_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		  	       /* Number of ray/object pairs */
                  	    
d332 4
a335 1
rt_sph_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
d351 4
a354 1
rt_sph_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
d374 5
a378 1
rt_sph_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
d416 2
a417 1
rt_sph_free(register struct soltab *stp)
d426 1
a426 1
rt_sph_class(void)
@


11.14.2.2
log
@updated hard-coded tolerances to use the run-time ray-trace instance pointer tolerance
@
text
@d22 1
a22 1
static const char RCSsph[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_sph.c,v 11.14.2.1 2002/09/19 18:01:36 morrison Exp $ (BRL)";
d98 1
a98 1
	if( magsq_a < rtip->rti_tol.dist || magsq_b < rtip->rti_tol.dist || magsq_c < rtip->rti_tol.dist ) {
d125 1
a125 1
	if( ! NEAR_ZERO(f, rtip->rti_tol.dist) )  {
d130 1
a130 1
	if( ! NEAR_ZERO(f, rtip->rti_tol.dist) )  {
d135 1
a135 1
	if( ! NEAR_ZERO(f, rtip->rti_tol.dist) )  {
@


11.14.2.3
log
@sync branch with HEAD
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d22 1
a22 1
static const char RCSsph[] = "@@(#)$Header$ (BRL)";
@


11.13
log
@Converted from K&R to ANSI C - RFH
@
text
@d83 4
a86 1
rt_sph_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
d189 2
a190 1
rt_sph_print(register const struct soltab *stp)
d223 5
a227 1
rt_sph_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
d274 6
a279 6
rt_sph_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		  	       /* Number of ray/object pairs */
                  	    
d332 4
a335 1
rt_sph_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
d351 4
a354 1
rt_sph_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
d374 5
a378 1
rt_sph_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
d416 2
a417 1
rt_sph_free(register struct soltab *stp)
d426 1
a426 1
rt_sph_class(void)
@


11.12
log
@Routines were not setting idb_major_type in the internal structure
@
text
@d22 1
a22 1
static const char RCSsph[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_sph.c,v 11.11 2001/04/20 22:29:47 morrison Exp $ (BRL)";
d83 1
a83 4
rt_sph_prep( stp, ip, rtip )
struct soltab		*stp;
struct rt_db_internal	*ip;
struct rt_i		*rtip;
d186 1
a186 2
rt_sph_print( stp )
register const struct soltab *stp;
d219 1
a219 5
rt_sph_shot( stp, rp, ap, seghead )
struct soltab		*stp;
register struct xray	*rp;
struct application	*ap;
struct seg		*seghead;
d266 6
a271 6
rt_sph_vshot( stp, rp, segp, n, ap )
struct soltab	       *stp[]; /* An array of solid pointers */
struct xray		*rp[]; /* An array of ray pointers */
struct  seg            segp[]; /* array of segs (results returned) */
int		  	    n; /* Number of ray/object pairs */
struct application	*ap;
d324 1
a324 4
rt_sph_norm( hitp, stp, rp )
register struct hit *hitp;
struct soltab *stp;
register struct xray *rp;
d340 1
a340 4
rt_sph_curve( cvp, hitp, stp )
register struct curvature *cvp;
register struct hit *hitp;
struct soltab *stp;
d360 1
a360 5
rt_sph_uv( ap, stp, hitp, uvp )
struct application *ap;
struct soltab *stp;
register struct hit *hitp;
register struct uvcoord *uvp;
d398 1
a398 2
rt_sph_free( stp )
register struct soltab *stp;
d407 1
a407 1
rt_sph_class()
@


11.11
log
@CONST to const
@
text
@d22 1
a22 1
static const char RCSsph[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_sph.c,v 11.10 2001/03/31 01:57:09 morrison Exp $ (BRL)";
d455 1
@


11.10
log
@Deprecated bn_mat_idn() and bn_mat_zero(), updated calls to h/vmath.h's MAT_IDN() and MAT_ZERO() performance improved macros.
@
text
@d22 1
a22 1
static const char RCSsph[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_sph.c,v 11.9 2000/10/18 18:10:35 butler Exp $ (BRL)";
d190 1
a190 1
register CONST struct soltab *stp;
d192 1
a192 1
	register CONST struct sph_specific *sph =
d445 3
a447 3
CONST struct bu_external	*ep;
register CONST mat_t		mat;
CONST struct db_i		*dbip;
d478 1
a478 1
CONST struct rt_db_internal	*ip;
d480 1
a480 1
CONST struct db_i		*dbip;
@


11.9
log
@Patches for compiling under RedHat 7.0
@
text
@d22 1
a22 1
static const char RCSsph[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_sph.c,v 11.8 2000/07/10 23:01:35 mike Exp $ (BRL)";
d165 1
a165 1
	bn_mat_idn( sph->sph_SoR );
@


11.8
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d22 1
a22 1
static const char RCSsph[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_sph.c,v 11.7 2000/06/30 15:38:03 mike Exp $ (BRL)";
d28 3
@


11.7
log
@
export methods should not init the external structure, just check them.
@
text
@d22 1
a22 1
static char RCSsph[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_sph.c,v 11.6 2000/06/30 15:31:15 mike Exp $ (BRL)";
@


11.6
log
@
The import/export and import5/export5 methods must NOT
re-initialize their rt_db_internal* pointer, they should just check it.
@
text
@d22 1
a22 1
static char RCSsph[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_sph.c,v 11.5 2000/06/27 17:37:31 mike Exp $ (BRL)";
d487 1
a487 1
	BU_INIT_EXTERNAL(ep);
@


11.5
log
@
Started writing import5/export5
@
text
@d22 1
a22 1
static char RCSsph[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_sph.c,v 11.4 2000/04/12 02:34:36 mike Exp $ (BRL)";
d451 1
a451 1
	RT_INIT_DB_INTERNAL( ip );
@


11.4
log
@
NT port, non-compat4
@
text
@d22 1
a22 1
static char RCSsph[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_sph.c,v 11.3 1999/11/17 02:42:02 mike Exp $ (BRL)";
d429 75
@


11.3
log
@
Added idb_meth and st_meth pointers to allow direct access to per-solid
methods, C++ style.
@
text
@d22 1
a22 1
static char RCSsph[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_sph.c,v 11.2 1999/05/27 19:10:42 mike Exp $ (BRL)";
d359 1
a359 1
 	vec_ortho( cvp->crv_pdir, hitp->hit_normal );
@


11.2
log
@
sed4
@
text
@d22 1
a22 1
static char RCSsph[] = "@@(#)$Header: /c/CVS/brlcad/librt/g_sph.c,v 11.1 1995/01/04 09:57:00 mike Rel4_4 $ (BRL)";
d144 1
@


11.1
log
@Release_4.4
@
text
@d22 1
a22 1
static char RCSsph[] = "@@(#)$Header: /m/cad/librt/RCS/g_sph.c,v 10.3 94/08/10 18:39:15 gdurf Exp $ (BRL)";
d99 1
a99 1
		rt_log("sph(%s):  zero length A(%g), B(%g), or C(%g) vector\n",
d109 1
a109 1
		rt_log("sph(%s):  non-equal length A, B, C vectors\n",
d126 1
a126 1
		rt_log("sph(%s):  A not perpendicular to B, f=%f\n",stp->st_name, f);
d131 1
a131 1
		rt_log("sph(%s):  B not perpendicular to C, f=%f\n",stp->st_name, f);
d136 1
a136 1
		rt_log("sph(%s):  A not perpendicular to C, f=%f\n",stp->st_name, f);
d146 1
a146 1
	GETSTRUCT( sph, sph_specific );
d161 1
a161 1
	mat_idn( sph->sph_SoR );
d192 4
a195 4
	rt_log("Rad %g\n", sph->sph_rad);
	rt_log("Radsq %g\n", sph->sph_radsq);
	rt_log("Invrad %g\n", sph->sph_invrad);
	mat_print("S o R", sph->sph_SoR );
d259 1
a259 1
	RT_LIST_INSERT( &(seghead->l), &(segp->l) );
d391 1
a391 1
	uvp->uv_u = mat_atan2( pprime[Y], pprime[X] ) * rt_inv2pi;
d398 1
a398 1
	uvp->uv_v = mat_atan2( pprime[Z],
d400 1
a400 1
		rt_invpi + 0.5;
d405 1
a405 1
		rt_inv2pi * r / stp->st_aradius;
d418 1
a418 1
	rt_free( (char *)sph, "sph_specific" );
@


10.3
log
@Added include of conf.h
@
text
@d22 1
a22 1
static char RCSsph[] = "@@(#)$Header: /m/cad/librt/RCS/g_sph.c,v 10.2 1994/06/22 03:10:23 butler Exp gdurf $ (BRL)";
@


10.2
log
@more detailed error message
@
text
@d22 1
a22 1
static char RCSsph[] = "@@(#)$Header: /m/cad/librt/RCS/g_sph.c,v 10.1 91/10/12 06:40:24 mike Rel4_0 Locker: butler $ (BRL)";
d24 2
@


10.1
log
@Release_4.0
@
text
@d22 1
a22 1
static char RCSsph[] = "@@(#)$Header: /m/cad/librt/RCS/g_sph.c,v 9.12 91/09/20 23:26:07 butler Exp $ (BRL)";
d97 2
a98 2
		rt_log("sph(%s):  zero length A, B, or C vector\n",
			stp->st_name );
@


9.12
log
@removing fuzz with lint
@
text
@d22 1
a22 1
static char RCSsph[] = "@@(#)$Header: /m/cad/librt/RCS/g_sph.c,v 9.11 91/06/30 00:10:58 mike Exp $ (BRL)";
@


9.11
log
@Some args to ft_print, ft_import, and ft_export became CONST
@
text
@d22 1
a22 1
static char RCSsph[] = "@@(#)$Header: /m/cad/librt/RCS/g_sph.c,v 9.10 91/06/22 22:30:33 mike Exp $ (BRL)";
a87 1
	int		i;
@


9.10
log
@Tolerance can be had from ap->a_rt_i->rti_tol, so it is no longer
passed as a parameter on ft_prep, ft_shot, or ft_vshot.
ft_vshot calling sequence also changed to use application structure.
@
text
@d22 1
a22 1
static char RCSsph[] = "@@(#)$Header: /m/cad/librt/RCS/g_sph.c,v 9.9 91/05/18 03:01:30 mike Exp $ (BRL)";
d185 1
a185 1
register struct soltab *stp;
d187 1
a187 1
	register struct sph_specific *sph =
@


9.9
log
@Converted to new tolerance interface
@
text
@d22 1
a22 1
static char RCSsph[] = "@@(#)$Header: /m/cad/librt/RCS/g_sph.c,v 9.8 91/01/25 21:19:16 mike Exp $ (BRL)";
d78 1
a78 1
rt_sph_prep( stp, ip, rtip, tol )
a81 1
CONST struct rt_tol	*tol;
d218 1
a218 1
rt_sph_shot( stp, rp, ap, seghead, tol )
a222 1
CONST struct rt_tol	*tol;
d269 1
a269 1
rt_sph_vshot( stp, rp, segp, n, resp, tol )
d274 1
a274 2
struct resource         *resp; /* pointer to a list of free segs */
CONST struct rt_tol	*tol;
@


9.8
log
@Converted to new function switch table interface,
using separation between internal and external forms of geometry.
@
text
@d22 1
a22 1
static char RCSsph[] = "@@(#)$Header: /m/cad/librt/RCS/g_sph.c,v 9.7 91/01/25 20:36:07 mike Exp $ (BRL)";
d78 1
a78 1
rt_sph_prep( stp, ip, rtip )
d82 1
d219 1
a219 1
rt_sph_shot( stp, rp, ap, seghead )
d224 1
d271 1
a271 1
rt_sph_vshot( stp, rp, segp, n, resp)
d277 1
@


9.7
log
@Added rt_ prefix to _internal structure
@
text
@d22 1
a22 1
static char RCSsph[] = "@@(#)$Header: /m/cad/librt/RCS/g_sph.c,v 9.6 91/01/15 23:46:05 mike Exp $ (BRL)";
a76 1
/* NEW_IF already */
@


9.6
log
@Changed to new import/export interface.
Mostly handled by g_ell.c
@
text
@d22 1
a22 1
static char RCSsph[] = "@@(#)$Header: /m/cad/librt/RCS/g_sph.c,v 9.5 90/10/06 02:05:21 mike Exp $ (BRL)";
d88 1
a88 1
	struct ell_internal	*eip;
d91 1
a91 1
	eip = (struct ell_internal *)ip->idb_ptr;
@


9.5
log
@Converted seg structures to use doubly linked lists.
@
text
@d22 1
a22 1
static char RCSsph[] = "@@(#)$Header: /m/cad/librt/RCS/g_sph.c,v 9.4 90/05/01 05:14:43 mike Exp $ (BRL)";
a28 1
#include "db.h"
d30 1
a60 8
/* Should be in a header file to share betwee g_ell.c and g_sph.c */
struct ell_internal  {
	point_t	v;
	vect_t	a;
	vect_t	b;
	vect_t	c;
};

d77 1
d79 1
a79 1
rt_sph_prep( stp, rec, rtip )
d81 1
a82 1
union record		*rec;
d88 1
a88 1
	struct ell_internal ei;
d91 2
a92 11
	if( rec == (union record *)0 )  {
		rec = db_getmrec( rtip->rti_dbip, stp->st_dp );
		i = rt_ell_import( &ei, rec, stp->st_pathmat );
		rt_free( (char *)rec, "ell record" );
	} else {
		i = rt_ell_import( &ei, rec, stp->st_pathmat );
	}
	if( i < 0 )  {
		rt_log("rt_sph_setup(%s): db import failure\n", stp->st_name);
		return(-1);		/* BAD */
	}
d95 3
a97 3
	magsq_a = MAGSQ( ei.a );
	magsq_b = MAGSQ( ei.b );
	magsq_c = MAGSQ( ei.c );
d117 1
a117 1
	VSCALE( Au, ei.a, f );
d119 1
a119 1
	VSCALE( Bu, ei.b, f );
d121 1
a121 1
	VSCALE( Cu, ei.c, f );
d149 1
a149 1
	VMOVE( sph->sph_V, ei.v );
d162 3
a164 3
	VSCALE( &sph->sph_SoR[0], ei.a, 1.0/magsq_a );
	VSCALE( &sph->sph_SoR[4], ei.b, 1.0/magsq_b );
	VSCALE( &sph->sph_SoR[8], ei.c, 1.0/magsq_c );
@


9.4
log
@Routines got rt_ prefix
@
text
@d22 1
a22 1
static char RCSsph[] = "@@(#)$Header: g_sph.c,v 9.3 90/03/14 15:05:58 mike Locked $ (BRL)";
d232 1
a232 1
 *  	segp	HIT
d234 2
a235 2
struct seg *
rt_sph_shot( stp, rp, ap )
d239 1
d257 1
a257 1
			return(SEG_NULL);		/* No hit */
d262 1
a262 1
			return(SEG_NULL);		/* No hit */
d269 1
a269 1
	GET_SEG(segp, ap->a_resource);
d275 2
a276 1
	return(segp);			/* HIT */
a330 1
		segp[i].seg_next = SEG_NULL;
@


9.3
log
@Changed type of st_specific to genptr_t
@
text
@d2 1
a2 1
 *			S P H . C
d22 1
a22 1
static char RCSsph[] = "@@(#)$Header: g_sph.c,v 9.2 90/03/03 04:54:15 mike Locked $ (BRL)";
d70 1
a70 1
 *  			S P H _ P R E P
d82 1
a82 1
 *  	stp->st_specific for use by sph_shot().
d86 1
a86 1
sph_prep( stp, rec, rtip )
d100 1
a100 1
		i = ell_import( &ei, rec, stp->st_pathmat );
d103 1
a103 1
		i = ell_import( &ei, rec, stp->st_pathmat );
d106 1
a106 1
		rt_log("sph_setup(%s): db import failure\n", stp->st_name);
d197 3
d201 1
a201 1
sph_print( stp )
d215 1
a215 1
 *  			S P H _ S H O T
d235 1
a235 1
sph_shot( stp, rp, ap )
d279 1
a279 1
 *			S P H _ V S H O T
d284 1
a284 1
sph_vshot( stp, rp, segp, n, resp)
d338 1
a338 1
 *  			S P H _ N O R M
d343 1
a343 1
sph_norm( hitp, stp, rp )
a352 1
	/* XXX is /= more efficient? */
d357 1
a357 1
 *			S P H _ C U R V E
d362 1
a362 1
sph_curve( cvp, hitp, stp )
d377 1
a377 1
 *  			S P H _ U V
d385 1
a385 1
sph_uv( ap, stp, hitp, uvp )
d424 1
a424 1
 *		S P H _ F R E E
d427 1
a427 1
sph_free( stp )
d437 1
a437 1
sph_class()
d442 1
a442 11
/* This routine is not used;  ell_plot() is used instead */
void
sph_plot()
{
}

/* This routine is not used;  ell_tess() is used instead */
int
sph_tess()
{
}
@


9.2
log
@Modified to use ell_import().
@
text
@d22 1
a22 1
static char RCSsph[] = "@@(#)$Header: g_sph.c,v 9.1 89/05/19 05:56:26 mike Locked $ (BRL)";
d163 1
a163 1
	stp->st_specific = (int *)sph;
@


9.1
log
@Release_3.5
@
text
@d22 1
a22 1
static char RCSsph[] = "@@(#)$Header: g_sph.c,v 8.9 89/04/27 23:10:15 phil Exp $ (BRL)";
d61 8
a92 1
	LOCAL vect_t	A, B, C;
d95 2
a96 1
	fastf_t		vec[3*4];
d98 11
a108 1
	rt_fastf_float( vec, rec->s.s_values, 4 );
a109 12
#define ELL_V	&vec[0*ELEMENTS_PER_VECT]
#define ELL_A	&vec[1*ELEMENTS_PER_VECT]
#define ELL_B	&vec[2*ELEMENTS_PER_VECT]
#define ELL_C	&vec[3*ELEMENTS_PER_VECT]

	/*
	 * Apply rotation only to A,B,C
	 */
	MAT4X3VEC( A, stp->st_pathmat, ELL_A );
	MAT4X3VEC( B, stp->st_pathmat, ELL_B );
	MAT4X3VEC( C, stp->st_pathmat, ELL_C );

d111 4
a114 6
	magsq_a = MAGSQ( A );
	magsq_b = MAGSQ( B );
	magsq_c = MAGSQ( C );
	if( NEAR_ZERO(magsq_a, 0.005) ||
	     NEAR_ZERO(magsq_b, 0.005) ||
	     NEAR_ZERO(magsq_c, 0.005) ) {
d123 5
a127 2
		/*rt_log("sph(%s):  non-equal length A, B, C vectors\n",
			stp->st_name );*/
d133 1
a133 1
	VSCALE( Au, A, f );
d135 1
a135 1
	VSCALE( Bu, B, f );
d137 1
a137 1
	VSCALE( Cu, C, f );
d165 1
a165 2
	/* Apply full 4x4mat to V */
	MAT4X3PNT( sph->sph_V, stp->st_pathmat, ELL_V );
d178 3
a180 3
	VSCALE( &sph->sph_SoR[0], A, 1.0/magsq_a );
	VSCALE( &sph->sph_SoR[4], B, 1.0/magsq_b );
	VSCALE( &sph->sph_SoR[8], C, 1.0/magsq_c );
d440 1
d443 6
@


8.9
log
@changed UV mapping (U==0 now on X axis)
@
text
@d22 1
a22 1
static char RCSsph[] = "@@(#)$Header: g_sph.c,v 8.8 89/04/17 17:19:49 phil Locked $ (BRL)";
@


8.8
log
@Calling sequence to xxx_prep() shortened from 6 to 3 args.
Database conversion moved into prep routines.
@
text
@d22 1
a22 1
static char RCSsph[] = "@@(#)$Header: g_sph.c,v 8.7 89/04/11 12:09:21 mike Locked $ (BRL)";
d398 3
a400 1
	uvp->uv_u = mat_atan2( pprime[Y], pprime[X] ) * rt_inv2pi + 0.5;
@


8.7
log
@removed some unused flotsam
@
text
@d22 1
a22 1
static char RCSsph[] = "@@(#)$Header: sph.c,v 8.6 89/04/08 02:47:58 phil Locked $ (BRL)";
d78 1
a78 2
sph_prep( vec, stp, mat, rtip )
register fastf_t	*vec;
a79 1
matp_t			mat;
d81 1
d88 1
d90 2
d100 3
a102 3
	MAT4X3VEC( A, mat, ELL_A );
	MAT4X3VEC( B, mat, ELL_B );
	MAT4X3VEC( C, mat, ELL_C );
d159 1
a159 1
	MAT4X3PNT( sph->sph_V, mat, ELL_V );
@


8.6
log
@Includes Dave Becker's vectorized version
@
text
@d22 1
a22 1
static char RCSsph[] = "@@(#)$Header: sph.c,v 8.5 89/03/14 01:50:07 mike Locked $ (BRL)";
a87 2
	LOCAL vect_t	work;
	LOCAL vect_t	vbc;	/* used for bounding RPP */
a373 3
/*double rt_inv2pi =  0.15915494309189533619;	/* 1/(pi*2) */
/*double rt_invpi = 0.31830988618379067153;	/* 1/pi */

@


8.5
log
@Improvements to the intersection algorithm.
@
text
@d10 1
d22 1
a22 1
static char RCSsph[] = "@@(#)$Header: sph.c,v 8.4 89/02/17 11:01:46 mike Exp $ (BRL)";
d266 60
@


8.4
log
@Phil noted that the uv_v calculation using atan2() was not right.
@
text
@d21 1
a21 1
static char RCSsph[] = "@@(#)$Header: sph.c,v 8.3 89/01/09 04:54:25 mike Locked $ (BRL)";
d210 9
d233 3
a235 3
	LOCAL vect_t	delta;		/* P - V */
	LOCAL fastf_t	t1, t2;		/* distances in solution */
	FAST fastf_t	a, b;		/* two terms of radical */
d238 3
a240 3
	VSUB2( delta, rp->r_pt, sph->sph_V );
	a = MAGSQ( rp->r_dir );
	b = VDOT( rp->r_dir, delta );
d242 14
a255 2
	if( (root = b*b - a * (MAGSQ(delta)-sph->sph_radsq)) < 0 )
		return(SEG_NULL);		/* No hit */
d260 4
a263 9
	if( (t1=(-b+root)/a) <= (t2=(-b-root)/a) )  {
		/* t1 is entry, t2 is exit */
		segp->seg_in.hit_dist = t1;
		segp->seg_out.hit_dist = t2;
	} else {
		/* t2 is entry, t1 is exit */
		segp->seg_in.hit_dist = t2;
		segp->seg_out.hit_dist = t1;
	}
@


8.3
log
@Replaced asin() calls with atan2(), which is more robust.
@
text
@d21 1
a21 1
static char RCSsph[] = "@@(#)$Header: sph.c,v 8.3 89/01/08 23:10:23 mike Exp $ (BRL)";
d323 1
d325 4
d331 1
a331 1
		rt_inv2pi + 0.5;
@


8.2
log
@Changed from atan2 to mat_atan2
@
text
@d21 1
a21 1
static char RCSsph[] = "@@(#)$Header: sph.c,v 8.1 88/10/05 00:31:41 mike Locked $ (BRL)";
d324 3
a326 1
	uvp->uv_v = asin( pprime[Z] ) * rt_invpi + 0.5;
@


8.1
log
@Release_3.0
@
text
@d21 1
a21 1
static char RCSsph[] = "@@(#)$Header: sph.c,v 7.3 88/05/14 00:01:16 mike Exp $ (BRL)";
d323 1
a323 1
	uvp->uv_u = atan2( pprime[Y], pprime[X] ) * rt_inv2pi + 0.5;
@


7.3
log
@lint fixes
added zero _uv() routines to some modules
@
text
@d21 1
a21 1
static char RCSsph[] = "@@(#)$Header: sph.c,v 7.2 88/02/06 05:36:52 mike Locked $ (BRL)";
@


7.2
log
@rt_orthovec to vec_ortho
@
text
@d21 1
a21 1
static char RCSsph[] = "@@(#)$Header: sph.c,v 7.1 87/11/02 23:34:13 mike Locked $ (BRL)";
d76 1
d190 1
d256 1
d276 1
d302 1
d335 1
d345 1
d348 1
d351 1
@


7.1
log
@Release 2.3
@
text
@d21 1
a21 1
static char RCSsph[] = "@@(#)$Header: sph.c,v 6.1 87/07/11 07:56:30 mike Rel $ (BRL)";
d284 1
a284 1
 	rt_orthovec( cvp->crv_pdir, hitp->hit_normal );
@


6.1
log
@Release 2.0
@
text
@d21 1
a21 1
static char RCSsph[] = "@@(#)$Header: sph.c,v 5.1 87/06/24 22:12:22 mike Rel $ (BRL)";
@


5.1
log
@Release 1.24
@
text
@d21 1
a21 1
static char RCSsph[] = "@@(#)$Header: sph.c,v 1.4 87/05/28 20:26:28 phil Exp $ (BRL)";
@


1.4
log
@fixed curvature to be *inverse* radii
@
text
@d21 1
a21 1
static char RCSsph[] = "@@(#)$Header: sph.c,v 1.3 87/04/28 00:27:55 phil Locked $ (BRL)";
@


1.3
log
@changed curve convention
@
text
@d21 1
a21 1
static char RCSsph[] = "@@(#)$Header: sph.c,v 1.2 87/03/28 02:37:24 phil Locked $ (BRL)";
d281 1
a281 2
 	cvp->crv_c1 = - sph->sph_rad;
 	cvp->crv_c2 = cvp->crv_c1;
@


1.2
log
@Fixed minor nits in computation of SoR matrix.
@
text
@d21 1
a21 1
static char RCSsph[] = "@@(#)$Header: sph.c,v 1.1 87/03/24 01:06:13 phil Exp $ (BRL)";
d273 1
a273 1
sph_curve( cvp, hitp, stp, rp )
a276 1
struct xray *rp;
d281 1
a281 1
 	cvp->crv_c1 = sph->sph_rad;
d283 1
a285 7

	if( VDOT( hitp->hit_normal, rp->r_dir ) > 0 )  {
		/* ray strikes surface from inside; make curv negative */
		cvp->crv_c1 = - cvp->crv_c1;
		cvp->crv_c2 = - cvp->crv_c2;
	}
 	return;
@


1.1
log
@Initial revision
@
text
@d21 1
a21 1
static char RCSsph[] = "@@(#)$Header: ell.c,v 4.3 87/02/12 22:11:12 mike Exp $ (BRL)";
d169 4
a172 3
	VSCALE( &sph->sph_SoR[0], A, magsq_a );
	VSCALE( &sph->sph_SoR[4], B, magsq_b );
	VSCALE( &sph->sph_SoR[8], C, magsq_c );
@
