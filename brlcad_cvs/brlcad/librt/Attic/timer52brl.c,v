head	11.4;
access;
symbols
	ansi-20040405-merged:11.2.4.1
	postmerge-20040405-ansi:11.3
	premerge-20040404-ansi:11.3
	postmerge-autoconf:11.3
	autoconf-freeze:11.2.12.2
	premerge-autoconf:11.3
	ansi-20040316-freeze:11.2
	postmerge-20040315-windows:11.3
	premerge-20040315-windows:11.3
	windows-20040315-freeze:11.2.6.1
	autoconf-20031203:11.2
	autoconf-20031202:11.2
	autoconf-branch:11.2.0.12
	phong-branch:11.2.0.10
	photonmap-branch:11.2.0.8
	rel-6-1-DP:11.2
	windows-branch:11.2.0.6
	rel-6-0-2:11.2
	ansi-branch:11.2.0.4
	rel-6-0-1-branch:11.2.0.2
	hartley-6-0-post:11.2
	hartley-6-0-pre:11.2
	rel-6-0-1:11.2
	rel-6-0:11.2
	rel-5-4:11.1
	offsite-5-3-pre:11.2
	rel-5-3:11.1
	rel-5-2:11.1
	rel-5-1-branch:11.1.0.2
	rel-5-1:11.1
	rel-5-0:11.1
	rel-5-0-beta:11.1
	rel-4-5:11.1
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.2
	rel-1-10:4.1
	rt-2:2.1;
locks; strict;
comment	@ * @;


11.4
date	2004.05.21.18.07.35;	author morrison;	state dead;
branches;
next	11.3;

11.3
date	2004.02.02.17.39.29;	author morrison;	state Exp;
branches;
next	11.2;

11.2
date	2000.07.10.23.01.50;	author mike;	state Exp;
branches
	11.2.4.1
	11.2.6.1
	11.2.12.1;
next	11.1;

11.1
date	95.01.04.09.58.46;	author mike;	state Rel4_4;
branches;
next	10.1;

10.1
date	91.10.12.06.41.06;	author mike;	state Rel4_0;
branches;
next	9.1;

9.1
date	89.05.19.05.57.23;	author mike;	state Rel3_5;
branches;
next	8.1;

8.1
date	88.10.05.00.31.55;	author mike;	state Rel3_0;
branches;
next	7.2;

7.2
date	88.09.09.21.19.29;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.34.40;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.07.56.57;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.12.56;	author mike;	state Rel;
branches;
next	4.2;

4.2
date	87.02.12.22.12.15;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.46.21;	author mike;	state Rel1;
branches;
next	3.1;

3.1
date	86.07.11.01.33.18;	author mike;	state Exp;
branches;
next	3.0;

3.0
date	86.06.10.01.34.22;	author mike;	state Exp;
branches;
next	2.2;

2.2
date	85.09.11.19.56.51;	author mike;	state Exp;
branches;
next	2.1;

2.1
date	85.08.31.06.07.38;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	85.06.05.00.26.28;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	85.03.25.11.47.29;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	84.11.29.07.32.24;	author mike;	state Exp;
branches;
next	;

11.2.4.1
date	2004.03.17.21.19.00;	author morrison;	state Exp;
branches;
next	;

11.2.6.1
date	2004.03.11.23.43.46;	author morrison;	state Exp;
branches;
next	;

11.2.12.1
date	2004.02.12.18.37.47;	author erikg;	state Exp;
branches;
next	11.2.12.2;

11.2.12.2
date	2004.03.15.14.07.30;	author erikg;	state Exp;
branches;
next	;


desc
@System 5 Release 2 under BRL 4.2 BSD package.
Gives system 5 users access to 4.2 BSD timing precision.
@


11.4
log
@moved to src/
@
text
@/*
 *			T I M E R 5 2 B R L . C
 *
 * Function -
 *	To provide timing information for RT.
 *	This version for System V, Release TWO, under 4.2 BSD,
 *	using Doug Gwyn's System-V-under-4.2 emulation.
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1985-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCStimer[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/timer52brl.c,v 11.3 2004/02/02 17:39:29 morrison Exp $ (BRL)";
#endif

#include <stdio.h>
#include <memory.h>

/* BRL's System V - under 4.2 BSD version */

#include "/sys/h/types.h"
#include "/sys/h/time.h"
#include "/sys/h/resource.h"

static struct	timeval time0;	/* Time at which timeing started */
static struct	rusage ru0;	/* Resource utilization at the start */

static void prusage();
static void tvadd();
static void tvsub();
static void psecs();

/*
 *			P R E P _ T I M E R
 */
void
rt_prep_timer()
{
	_gettimeofday(&time0, (struct timezone *)0);
	_getrusage(RUSAGE_SELF, &ru0);
}

/*
 *			R E A D _ T I M E R
 * 
 */
double
rt_read_timer(str,len)
char *str;
{
	struct timeval timedol;
	struct rusage ru1;
	struct timeval td;
	double usert;
	char line[132];

	_getrusage(RUSAGE_SELF, &ru1);
	_gettimeofday(&timedol, (struct timezone *)0);
	prusage(&ru0, &ru1, &timedol, &time0, line);
	(void)strncpy( str, line, len );
	tvsub( &td, &ru1.ru_utime, &ru0.ru_utime );
	usert = td.tv_sec + ((double)td.tv_usec) / 1000000;
	if( usert < 0.00001 )  usert = 0.00001;
	return( usert );
}

static void
prusage(r0, r1, e, b, outp)
	register struct rusage *r0, *r1;
	struct timeval *e, *b;
	char *outp;
{
	struct timeval tdiff;
	register time_t t;
	register char *cp;
	register int i;
	int ms;

	t = (r1->ru_utime.tv_sec-r0->ru_utime.tv_sec)*100+
	    (r1->ru_utime.tv_usec-r0->ru_utime.tv_usec)/10000+
	    (r1->ru_stime.tv_sec-r0->ru_stime.tv_sec)*100+
	    (r1->ru_stime.tv_usec-r0->ru_stime.tv_usec)/10000;
	ms =  (e->tv_sec-b->tv_sec)*100 + (e->tv_usec-b->tv_usec)/10000;

#define END(x)	{while(*x) x++;}
	cp = "%Uuser %Ssys %Ereal %P %Xi+%Dd %Mmaxrss %F+%Rpf %Ccsw";
	for (; *cp; cp++)  {
		if (*cp != '%')
			*outp++ = *cp;
		else if (cp[1]) switch(*++cp) {

		case 'U':
			tvsub(&tdiff, &r1->ru_utime, &r0->ru_utime);
			sprintf(outp,"%d.%01d", tdiff.tv_sec, tdiff.tv_usec/100000);
			END(outp);
			break;

		case 'S':
			tvsub(&tdiff, &r1->ru_stime, &r0->ru_stime);
			sprintf(outp,"%d.%01d", tdiff.tv_sec, tdiff.tv_usec/100000);
			END(outp);
			break;

		case 'E':
			psecs(ms / 100, outp);
			END(outp);
			break;

		case 'P':
			sprintf(outp,"%d%%", (int) (t*100 / ((ms ? ms : 1))));
			END(outp);
			break;

		case 'W':
			i = r1->ru_nswap - r0->ru_nswap;
			sprintf(outp,"%d", i);
			END(outp);
			break;

		case 'X':
			sprintf(outp,"%d", t == 0 ? 0 : (r1->ru_ixrss-r0->ru_ixrss)/t);
			END(outp);
			break;

		case 'D':
			sprintf(outp,"%d", t == 0 ? 0 :
			    (r1->ru_idrss+r1->ru_isrss-(r0->ru_idrss+r0->ru_isrss))/t);
			END(outp);
			break;

		case 'K':
			sprintf(outp,"%d", t == 0 ? 0 :
			    ((r1->ru_ixrss+r1->ru_isrss+r1->ru_idrss) -
			    (r0->ru_ixrss+r0->ru_idrss+r0->ru_isrss))/t);
			END(outp);
			break;

		case 'M':
			sprintf(outp,"%d", r1->ru_maxrss/2);
			END(outp);
			break;

		case 'F':
			sprintf(outp,"%d", r1->ru_majflt-r0->ru_majflt);
			END(outp);
			break;

		case 'R':
			sprintf(outp,"%d", r1->ru_minflt-r0->ru_minflt);
			END(outp);
			break;

		case 'I':
			sprintf(outp,"%d", r1->ru_inblock-r0->ru_inblock);
			END(outp);
			break;

		case 'O':
			sprintf(outp,"%d", r1->ru_oublock-r0->ru_oublock);
			END(outp);
			break;
		case 'C':
			sprintf(outp,"%d+%d", r1->ru_nvcsw-r0->ru_nvcsw,
				r1->ru_nivcsw-r0->ru_nivcsw );
			END(outp);
			break;
		}
	}
	*outp = '\0';
}

static void
tvadd(tsum, t0)
	struct timeval *tsum, *t0;
{

	tsum->tv_sec += t0->tv_sec;
	tsum->tv_usec += t0->tv_usec;
	if (tsum->tv_usec > 1000000)
		tsum->tv_sec++, tsum->tv_usec -= 1000000;
}

static void
tvsub(tdiff, t1, t0)
	struct timeval *tdiff, *t1, *t0;
{

	tdiff->tv_sec = t1->tv_sec - t0->tv_sec;
	tdiff->tv_usec = t1->tv_usec - t0->tv_usec;
	if (tdiff->tv_usec < 0)
		tdiff->tv_sec--, tdiff->tv_usec += 1000000;
}

static void
psecs(l,cp)
long l;
register char *cp;
{
	register int i;

	i = l / 3600;
	if (i) {
		sprintf(cp,"%d:", i);
		END(cp);
		i = l % 3600;
		sprintf(cp,"%d%d", (i/60) / 10, (i/60) % 10);
		END(cp);
	} else {
		i = l;
		sprintf(cp,"%d", i / 60);
		END(cp);
	}
	i %= 60;
	*cp++ = ':';
	sprintf(cp,"%d%d", i / 10, i % 10);
}
@


11.3
log
@update copyright to include span through 2003
@
text
@d19 1
a19 1
static const char RCStimer[] = "@@(#)$Header: /c/CVS/brlcad/librt/timer52brl.c,v 11.2 2000/07/10 23:01:50 mike Exp $ (BRL)";
@


11.2
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d15 1
a15 1
 *	This software is Copyright (C) 1985 by the United States Army.
d19 1
a19 1
static const char RCStimer[] = "@@(#)$Header: /c/CVS/brlcad/librt/timer52brl.c,v 11.1 1995/01/04 09:58:46 mike Rel4_4 $ (BRL)";
@


11.2.4.1
log
@sync branch with HEAD
@
text
@d15 1
a15 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d19 1
a19 1
static const char RCStimer[] = "@@(#)$Header$ (BRL)";
@


11.2.6.1
log
@sync to HEAD...
@
text
@d15 1
a15 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d19 1
a19 1
static const char RCStimer[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/timer52brl.c,v 11.3 2004/02/02 17:39:29 morrison Exp $ (BRL)";
@


11.2.12.1
log
@merge from HEAD
@
text
@d15 1
a15 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d19 1
a19 1
static const char RCStimer[] = "@@(#)$Header: /c/CVS/brlcad/librt/timer52brl.c,v 11.3 2004/02/02 17:39:29 morrison Exp $ (BRL)";
@


11.2.12.2
log
@merge from head
@
text
@d19 1
a19 1
static const char RCStimer[] = "@@(#)$Header: /c/CVS/brlcad/librt/timer52brl.c,v 11.2.12.1 2004/02/12 18:37:47 erikg Exp $ (BRL)";
@


11.1
log
@Release_4.4
@
text
@d19 1
a19 1
static char RCStimer[] = "@@(#)$Header: /m/cad/librt/RCS/timer52brl.c,v 10.1 91/10/12 06:41:06 mike Rel4_0 $ (BRL)";
@


10.1
log
@Release_4.0
@
text
@d19 1
a19 1
static char RCStimer[] = "@@(#)$Header: timer52brl.c,v 9.1 89/05/19 05:57:23 mike Rel3_5 $ (BRL)";
@


9.1
log
@Release_3.5
@
text
@d19 1
a19 1
static char RCStimer[] = "@@(#)$Header: timer52brl.c,v 8.1 88/10/05 00:31:55 mike Rel3_0 $ (BRL)";
@


8.1
log
@Release_3.0
@
text
@d19 1
a19 1
static char RCStimer[] = "@@(#)$Header: timer52brl.c,v 7.2 88/09/09 21:19:29 mike Exp $ (BRL)";
@


7.2
log
@Eliminated bzero() and bcopy() definitions
@
text
@d19 1
a19 1
static char RCStimer[] = "@@(#)$Header: timer52brl.c,v 7.1 87/11/02 23:34:40 mike Locked $ (BRL)";
@


7.1
log
@Release 2.3
@
text
@d19 1
a19 1
static char RCStimer[] = "@@(#)$Header: timer52brl.c,v 6.1 87/07/11 07:56:57 mike Rel $ (BRL)";
a221 5
}

bzero( str, n )
{
	memset( str, '\0', n );
@


6.1
log
@Release 2.0
@
text
@d19 1
a19 1
static char RCStimer[] = "@@(#)$Header: timer52brl.c,v 5.1 87/06/24 22:12:56 mike Rel $ (BRL)";
@


5.1
log
@Release 1.24
@
text
@d19 1
a19 1
static char RCStimer[] = "@@(#)$Header: timer52brl.c,v 4.2 87/02/12 22:12:15 mike Exp $ (BRL)";
@


4.2
log
@Release 1.20 -- First Formal Release
@
text
@d19 1
a19 1
static char RCStimer[] = "@@(#)$Header: timer52brl.c,v 4.1 86/12/29 03:46:21 mike Rel1 $ (BRL)";
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d19 1
a19 1
static char RCStimer[] = "@@(#)$Header: timer52brl.c,v 3.1 86/07/11 01:33:18 mike Exp $ (BRL)";
@


3.1
log
@Cleanups inspired by the crummy compiler on the Cray XMP
@
text
@d19 1
a19 1
static char RCStimer[] = "@@(#)$Header: timer52brl.c,v 3.0 86/06/10 01:34:22 mike Exp $ (BRL)";
@


3.0
log
@rt/ and librt/ separated,
global datastructures simplified.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: timer52brl.c,v 2.2 85/09/11 19:56:51 mike Exp $ (BRL)";
@


2.2
log
@Changed pr_timer to read_timer, which formats into a user supplied buffer,
so that user handles I/O of string as desired.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: timer42.c,v 2.1 85/08/31 06:07:29 mike Exp $ (BRL)";
d43 1
a43 1
prep_timer()
d54 1
a54 1
read_timer(str,len)
@


2.1
log
@Version 2 of RT
@
text
@d2 1
a2 1
 *			T I M E R 5 2 B R L. C
d19 1
a19 1
static char RCSid[] = "@@(#)$Header: timer52brl.c,v 1.3 85/06/05 00:26:28 mike Exp $ (BRL)";
a24 5
bzero( str, n )
{
	memset( str, '\0', n );
}

a34 1
static void pdeltat();
a37 1
static void p2dig();
d50 1
a50 1
 *			P R _ T I M E R
d54 1
a54 1
pr_timer(str)
d61 1
d65 2
a66 2
	fprintf(stderr,"%s: ", str);
	prusage(&ru0, &ru1, &timedol, &time0);
d69 1
d74 1
a74 1
prusage(r0, r1, e, b)
d77 1
d79 1
d91 2
a92 1
	cp = "%Uuser %Ssys %Ereal %P %Xi+%Dd[%M]rss %F+%Rpf %Ccsw %Wswap";
d95 1
a95 1
			putc(*cp, stderr);
d99 3
a101 1
			pdeltat(&r1->ru_utime, &r0->ru_utime);
d105 3
a107 1
			pdeltat(&r1->ru_stime, &r0->ru_stime);
d111 2
a112 1
			psecs(ms / 100);
d116 2
a117 1
			fprintf(stderr,"%d%%", (int) (t*100 / ((ms ? ms : 1))));
d122 2
a123 1
			fprintf(stderr,"%d", i);
d127 2
a128 1
			fprintf(stderr,"%d", t == 0 ? 0 : (r1->ru_ixrss-r0->ru_ixrss)/t);
d132 1
a132 1
			fprintf(stderr,"%d", t == 0 ? 0 :
d134 1
d138 1
a138 1
			fprintf(stderr,"%d", t == 0 ? 0 :
d141 1
d145 2
a146 1
			fprintf(stderr,"%d", r1->ru_maxrss/2);
d150 2
a151 1
			fprintf(stderr,"%d", r1->ru_majflt-r0->ru_majflt);
d155 2
a156 1
			fprintf(stderr,"%d", r1->ru_minflt-r0->ru_minflt);
d160 2
a161 1
			fprintf(stderr,"%d", r1->ru_inblock-r0->ru_inblock);
d165 2
a166 1
			fprintf(stderr,"%d", r1->ru_oublock-r0->ru_oublock);
d169 1
a169 1
			fprintf(stderr,"%d+%d", r1->ru_nvcsw-r0->ru_nvcsw,
d171 1
d175 1
a175 1
	putc('\n',stderr);
a178 10
pdeltat(t1, t0)
	struct timeval *t1, *t0;
{
	struct timeval td;

	tvsub(&td, t1, t0);
	fprintf(stderr,"%d.%01d", td.tv_sec, td.tv_usec/100000);
}

static void
d201 3
a203 2
psecs(l)
	long l;
d209 2
a210 1
		fprintf(stderr,"%d:", i);
d212 6
a217 2
		p2dig(i / 60);
		goto minsec;
a218 3
	i = l;
	fprintf(stderr,"%d", i / 60);
minsec:
d220 2
a221 2
	fprintf(stderr,":");
	p2dig(i);
d224 1
a224 3
static void
p2dig(i)
	register int i;
d226 1
a226 6

	fprintf(stderr,"%d%d", i / 10, i % 10);
}

bcopy(from, to, count)  {
	memcpy( to, from, count );
@


1.3
log
@timer_print, timer_prep changed to prep_timer, pr_timer
to accomodate compilers that only look at the first 8 chars.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: timer52brl.c,v 1.2 85/03/25 11:47:29 mike Exp $ (BRL)";
d223 4
@


1.2
log
@Housekeeping
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: timer52brl.c,v 1.1 84/11/29 07:32:24 mike Exp $ (BRL)";
d47 1
a47 1
 *			T I M E R _ P R E P
d50 1
a50 1
timer_prep()
d57 1
a57 1
 *			T I M E R _ P R I N T
d61 1
a61 1
timer_print(str)
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 *			T I M E R 5 2 . C
d6 2
a7 1
 *	THIS VERSION FOR System FIVE, Release TWO, under 4.2 BSD.
d9 8
a16 1
 * $Revision: 1.1 $
d19 1
a19 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
@
