head	11.14;
access;
symbols
	ansi-20040405-merged:11.9.2.2
	postmerge-20040405-ansi:11.12
	premerge-20040404-ansi:11.11
	postmerge-autoconf:11.11
	autoconf-freeze:11.10.6.2
	premerge-autoconf:11.11
	ansi-20040316-freeze:11.9.2.1
	postmerge-20040315-windows:11.11
	premerge-20040315-windows:11.11
	windows-20040315-freeze:11.9.4.1
	autoconf-20031203:11.10
	autoconf-20031202:11.10
	autoconf-branch:11.10.0.6
	phong-branch:11.10.0.4
	photonmap-branch:11.10.0.2
	rel-6-1-DP:11.9
	windows-branch:11.9.0.4
	rel-6-0-2:11.7
	ansi-branch:11.9.0.2
	rel-6-0-1-branch:11.7.0.2
	hartley-6-0-post:11.8
	hartley-6-0-pre:11.7
	rel-6-0-1:11.7
	rel-6-0:11.7
	rel-5-4:11.5
	offsite-5-3-pre:11.7
	rel-5-3:11.5
	rel-5-2:11.5
	rel-5-1-branch:11.5.0.2
	rel-5-1:11.5
	rel-5-0:11.5
	rel-5-0-beta:11.4
	rel-4-5:11.4
	ctj-4-5-post:11.4
	ctj-4-5-pre:11.4
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.2
	rel-1-10:4.1
	rt-2:2.1;
locks; strict;
comment	@ * @;


11.14
date	2004.05.21.18.07.35;	author morrison;	state dead;
branches;
next	11.13;

11.13
date	2004.05.10.15.30.47;	author erikg;	state Exp;
branches;
next	11.12;

11.12
date	2004.04.05.08.48.58;	author morrison;	state Exp;
branches;
next	11.11;

11.11
date	2004.02.02.17.39.28;	author morrison;	state Exp;
branches;
next	11.10;

11.10
date	2003.04.02.16.48.51;	author jra;	state Exp;
branches
	11.10.6.1;
next	11.9;

11.9
date	2002.08.20.17.08.09;	author jra;	state Exp;
branches
	11.9.2.1
	11.9.4.1;
next	11.8;

11.8
date	2002.08.15.20.55.21;	author hartley;	state Exp;
branches;
next	11.7;

11.7
date	2000.08.21.02.02.34;	author butler;	state Exp;
branches;
next	11.6;

11.6
date	2000.07.10.23.01.48;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	99.07.02.22.19.25;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	96.09.27.08.27.30;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	96.09.27.07.18.40;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	96.08.31.10.57.57;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.58.33;	author mike;	state Rel4_4;
branches;
next	10.4;

10.4
date	94.12.27.17.14.13;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	94.11.05.01.46.26;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	94.08.10.19.43.14;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.40.58;	author mike;	state Rel4_0;
branches;
next	9.3;

9.3
date	91.03.13.20.59.34;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	91.03.13.16.36.43;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.57.03;	author mike;	state Rel3_5;
branches;
next	8.1;

8.1
date	88.10.05.00.31.37;	author mike;	state Rel3_0;
branches;
next	7.2;

7.2
date	88.01.23.05.20.14;	author moss;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.34.02;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.07.56.20;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.12.09;	author mike;	state Rel;
branches;
next	4.2;

4.2
date	87.02.12.22.11.45;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.45.47;	author mike;	state Rel1;
branches;
next	3.4;

3.4
date	86.12.13.07.13.48;	author mike;	state Exp;
branches;
next	3.3;

3.3
date	86.12.13.05.42.39;	author mike;	state Exp;
branches;
next	3.2;

3.2
date	86.08.12.04.16.16;	author mike;	state Exp;
branches;
next	3.1;

3.1
date	86.07.11.01.32.30;	author mike;	state Exp;
branches;
next	3.0;

3.0
date	86.06.10.01.33.34;	author mike;	state Exp;
branches;
next	2.1;

2.1
date	85.08.31.06.06.00;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	85.07.30.05.54.57;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	85.03.25.11.55.22;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	85.03.25.11.34.38;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	85.02.08.02.01.05;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	85.02.08.00.23.29;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	85.02.07.20.31.47;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	85.01.28.15.50.51;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	85.01.28.14.00.30;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	84.11.26.21.43.13;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	84.11.23.20.54.23;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	84.10.16.20.43.48;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	84.09.06.03.58.53;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	84.08.22.03.18.04;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	84.08.21.01.18.51;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	84.08.20.22.16.01;	author mike;	state Exp;
branches;
next	;

11.9.2.1
date	2002.09.19.18.01.46;	author morrison;	state Exp;
branches;
next	11.9.2.2;

11.9.2.2
date	2004.03.17.21.18.58;	author morrison;	state Exp;
branches;
next	;

11.9.4.1
date	2004.03.11.23.43.46;	author morrison;	state Exp;
branches;
next	;

11.10.6.1
date	2004.02.12.18.37.47;	author erikg;	state Exp;
branches;
next	11.10.6.2;

11.10.6.2
date	2004.03.15.14.07.29;	author erikg;	state Exp;
branches;
next	;


desc
@General Root finding package, by Jeff Haynes
@


11.14
log
@moved to src/
@
text
@/*
 *  			R O O T S . C
 *
 *  Functions -
 *	rt_poly_roots		Find the roots of a polynomial
 *
 *  Author -
 *	Jeff Hanes
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1985-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSroots[] = "@@(#)$Header: /n/xoff/cvs/brlcad/librt/roots.c,v 11.13 2004/05/10 15:30:47 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "raytrace.h"

int		rt_poly_roots(register bn_poly_t *eqn, register bn_complex_t *roots);
void	rt_poly_eval_w_2derivatives(register bn_complex_t *cZ, register bn_poly_t *eqn, register bn_complex_t *b, register bn_complex_t *c, register bn_complex_t *d), rt_poly_deflate(register bn_poly_t *oldP, register bn_complex_t *root);
int	rt_poly_findroot(register bn_poly_t *eqn, register bn_complex_t *nxZ), rt_poly_checkroots(register bn_poly_t *eqn, bn_complex_t *roots, register int nroots);

/*
 *			R T _ P O L Y _ R O O T S
 *	
 *	WARNING:  The polynomial given as input is destroyed by this
 *		routine.  The caller must save it if it is important!
 *
 *	NOTE :  This routine is written for polynomials with real coef-
 *		ficients ONLY.  To use with complex coefficients, the
 *		Complex Math library should be used throughout.
 *		Some changes in the algorithm will also be required.
 */
int
rt_poly_roots(register bn_poly_t	*eqn,	/* equation to be solved */
	      register bn_complex_t	roots[])/* space to put roots found */
{
	register int	n;		/* number of roots found	*/
	LOCAL fastf_t	factor;		/* scaling factor for copy	*/

	/* Remove leading coefficients which are too close to zero,
	 * to prevent the polynomial factoring from blowing up, below.
	 */
	while( NEAR_ZERO( eqn->cf[0], SMALL ) )  {
		for ( n=0; n <= eqn->dgr; n++ ){
			eqn->cf[n] = eqn->cf[n+1];
		}
		if ( --eqn->dgr <= 0 )
			return 0;
	}

	/* Factor the polynomial so the first coefficient is one
	 * for ease of handling.
	 */
	factor = 1.0 / eqn->cf[0];
	(void) bn_poly_scale( eqn, factor );
	n = 0;		/* Number of roots found */

	/* A trailing coefficient of zero indicates that zero
	 * is a root of the equation.
	 */
	while( NEAR_ZERO( eqn->cf[eqn->dgr], SMALL ) )  {
		roots[n].re = roots[n].im = 0.0;
		--eqn->dgr;
		++n;
	}

	while ( eqn->dgr > 2 ){
		if ( eqn->dgr == 4 )  {
			if( rt_poly_quartic_roots( eqn, &roots[n] ) )  {
				if( rt_poly_checkroots( eqn, &roots[n], 4 ) == 0 )  {
					return( n+4 );
				}
			}
		} else if ( eqn->dgr == 3 )  {
			if( rt_poly_cubic_roots( eqn, &roots[n] ) )  {
				if ( rt_poly_checkroots( eqn, &roots[n], 3 ) == 0 )  {
					return ( n+3 );
				}
			}
		}

		/*
		 *  Set initial guess for root to almost zero.
		 *  This method requires a small nudge off the real axis.
		 */
		bn_cx_cons( &roots[n], 0.0, SMALL );
		if ( (rt_poly_findroot( eqn, &roots[n] )) < 0 )
			return(n);	/* return those we found, anyways */

		if ( fabs(roots[n].im) > 1.0e-5* fabs(roots[n].re) ){
			/* If root is complex, its complex conjugate is
			 * also a root since complex roots come in con-
			 * jugate pairs when all coefficients are real.
			 */
			++n;
			roots[n] = roots[n-1];
			bn_cx_conj(&roots[n]);
		} else {
			/* Change 'practically real' to real		*/
			roots[n].im = 0.0;
		}

		rt_poly_deflate( eqn, &roots[n] );
		++n;
	}

	/* For polynomials of lower degree, iterative techniques
	 * are an inefficient way to find the roots.
	 */
	if ( eqn->dgr == 1 ){
		roots[n].re = -(eqn->cf[1]);
		roots[n].im = 0.0;
		++n;
	} else if ( eqn->dgr == 2 ){
		rt_poly_quadratic_roots( eqn, &roots[n] );
		n += 2;
	}
	return n;
}

/*
 *			R T _ P O L Y _ F I N D R O O T
 *
 *	Calculates one root of a polynomial ( p(Z) ) using Laguerre's
 *	method.  This is an iterative technique which has very good
 *	global convergence properties.  The formulas for this method
 *	are
 *
 *					n * p(Z)
 *		newZ  =  Z  -  -----------------------  ,
 *				p'(Z) +- sqrt( H(Z) )
 *
 *	where
 *		H(Z) = (n-1) [ (n-1)(p'(Z))^2 - n p(Z)p''(Z) ],
 *
 *	where n is the degree of the polynomial.  The sign in the 
 *	denominator is chosen so that  |newZ - Z|  is as small as
 *	possible.
 *
 */
int
rt_poly_findroot(register bn_poly_t *eqn, register bn_complex_t *nxZ)
                  	     	/* polynomial			*/
                     	     	/* initial guess for root	*/
{
	LOCAL bn_complex_t  p0, p1, p2;	/* evaluated polynomial+derivatives */
	LOCAL bn_complex_t  p1_H;		/* p1 - H, temporary */
	LOCAL bn_complex_t  cZ, cH;		/* 'Z' and H(Z) in comment	*/
	LOCAL bn_complex_t  T;		/* temporary for making H */
	FAST fastf_t	diff=0.0;		/* test values for convergence	*/
	FAST fastf_t	b=0.0;		/* floating temps */
	LOCAL int	n;
	register int	i;		/* iteration counter		*/

	for( i=0; i < 20; i++ ) {
		cZ = *nxZ;
		rt_poly_eval_w_2derivatives( &cZ, eqn, &p0, &p1, &p2 );

		/* Compute H for Laguerre's method. */
		n = eqn->dgr-1;
		bn_cx_mul2( &cH, &p1, &p1 );
		bn_cx_scal( &cH, (double)(n*n) );
		bn_cx_mul2( &T, &p2, &p0 );
		bn_cx_scal( &T, (double)(eqn->dgr*n) );
		bn_cx_sub( &cH, &T );

		/* Calculate the next iteration for Laguerre's method.
		 * Test to see whether addition or subtraction gives the
		 * larger denominator for the next 'Z' , and use the
		 * appropriate value in the formula.
		 */
		bn_cx_sqrt( &cH, &cH );
		p1_H = p1;
		bn_cx_sub( &p1_H, &cH );
		bn_cx_add( &p1, &cH );		/* p1 <== p1+H */
		bn_cx_scal( &p0, (double)(eqn->dgr) );
		if ( bn_cx_amplsq( &p1_H ) > bn_cx_amplsq( &p1 ) ){
			bn_cx_div( &p0, &p1_H);
			bn_cx_sub( nxZ, &p0 );
		} else {
			bn_cx_div( &p0, &p1 );
			bn_cx_sub( nxZ, &p0 );
		}

		/* Use proportional convergence test to allow very small
		 * roots and avoid wasting time on large roots.
		 * The original version used bn_cx_ampl(), which requires
		 * a square root.  Using bn_cx_amplsq() saves lots of cycles,
		 * but changes loop termination conditions somewhat.
		 *
		 * diff is |p0|**2.  nxZ = Z - p0.
		 *
		 * SGI XNS IRIS 3.5 compiler fails if following 2 assignments
		 * are imbedded in the IF statement, as before.
		 */
		b = bn_cx_amplsq( nxZ );
		diff = bn_cx_amplsq( &p0 );
		if( b < diff )
			continue;
		if( (b-diff) == b )
			return(i);		/* OK -- can't do better */
		if( diff > (b - diff)*1.0e-5 ) 
			continue;
		return(i);			/* OK */
	}

	/* If the thing hasn't converged yet, it probably won't. */
	bu_log("rt_poly_findroot:  didn't converge in %d iterations, b=%g, diff=%g\n",
		i, b, diff);
	bu_log("nxZ=%gR+%gI, p0=%gR+%gI\n", nxZ->re, nxZ->im, p0.re, p0.im);
	return(-1);		/* ERROR */
}


/*
 *			R T _ P O L Y _ E V A L _ W _ 2 D E R I V A T I V E S
 *
 *	Evaluates p(Z), p'(Z), and p''(Z) for any Z (real or complex).
 *	Given an equation of the form
 *
 *		p(Z) = a0*Z^n + a1*Z^(n-1) +... an != 0,
 *
 *	the function value and derivatives needed for the iterations
 *	can be computed by synthetic division using the formulas
 *
 *		p(Z) = bn,    p'(Z) = c(n-1),    p''(Z) = d(n-2),
 *
 *	where
 *
 *		b0 = a0,	bi = b(i-1)*Z + ai,	i = 1,2,...n
 *		c0 = b0,	ci = c(i-1)*Z + bi,	i = 1,2,...n-1
 *		d0 = c0,	di = d(i-1)*Z + ci,	i = 1,2,...n-2
 *
 */
void
rt_poly_eval_w_2derivatives(register bn_complex_t *cZ, register bn_poly_t *eqn, register bn_complex_t *b, register bn_complex_t *c, register bn_complex_t *d)
                     	    		/* input */
                  	     		/* input */
                     	           	/* outputs */
{
	register int	n;
	register int	m;

	bn_cx_cons(b,eqn->cf[0],0.0);
	*c = *b;
	*d = *c;

	for ( n=1; ( m = eqn->dgr - n ) >= 0; ++n){
		bn_cx_mul( b, cZ );
		b->re += eqn->cf[n];
		if ( m > 0 ){
			bn_cx_mul( c, cZ );
			bn_cx_add( c, b );
		}
		if ( m > 1 ){
			bn_cx_mul( d, cZ );
			bn_cx_add( d, c );
		}
	}
}


/*
 *			R T _ P O L Y _ C H E C K R O O T S
 *
 *	Evaluates p(Z) for any Z (real or complex).
 *	In this case, test all "nroots" entries of roots[] to ensure
 *	that they are roots (zeros) of this polynomial.
 *
 * Returns -
 *	0	all roots are true zeros
 *	1	at least one "root[]" entry is not a true zero
 *
 *	Given an equation of the form
 *
 *		p(Z) = a0*Z^n + a1*Z^(n-1) +... an != 0,
 *
 *	the function value can be computed using the formula
 *
 *		p(Z) = bn,	where
 *
 *		b0 = a0,	bi = b(i-1)*Z + ai,	i = 1,2,...n
 *
 */
int
rt_poly_checkroots(register bn_poly_t *eqn, bn_complex_t *roots, register int nroots)
{
	register fastf_t	er, ei;		/* "epoly" */
	register fastf_t	zr, zi;		/* Z value to evaluate at */
	register int	n;
	int		m;

	for ( m=0; m < nroots; ++m ){
		/* Select value of Z to evaluate at */
		zr = bn_cx_real( &roots[m] );
		zi = bn_cx_imag( &roots[m] );

		/* Initialize */
		er = eqn->cf[0];
		/* ei = 0.0; */

		/* n=1 step.  Broken out because ei = 0.0 */
		ei = er*zi;		/* must come before er= */
		er = er*zr + eqn->cf[1];

		/* Remaining steps */
		for ( n=2; n <= eqn->dgr; ++n)  {
			register fastf_t	tr, ti;	/* temps */
			tr = er*zr - ei*zi + eqn->cf[n];
			ti = er*zi + ei*zr;
			er = tr;
			ei = ti;
		}
		if ( fabs( er ) > 1.0e-5 || fabs( ei ) > 1.0e-5 )
			return 1;	/* FAIL */
	}
	/* Evaluating polynomial for all Z values gives zero */
	return 0;			/* OK */
}


/*
 *			R T _ P O L Y _ D E F L A T E
 *
 *
 *	Deflates a polynomial by a given root.
 */
void
rt_poly_deflate(register bn_poly_t *oldP, register bn_complex_t *root)
{
	LOCAL bn_poly_t	div, rem;

	/* Make a polynomial out of the given root:  Linear for a real
	 * root, Quadratic for a complex root (since they come in con-
	 * jugate pairs).
	 */
	if ( NEAR_ZERO( root->im, SMALL) ) {
		/*  root is real		*/
		div.dgr = 1;
		div.cf[0] = 1;
		div.cf[1] = - root->re;
	} else {
		/*  root is complex		*/
		div.dgr = 2;
		div.cf[0] = 1;
		div.cf[1] = -2 * root->re;
		div.cf[2] = bn_cx_amplsq( root );
	}

	/* Use synthetic division to find the quotient (new polynomial)
	 * and the remainder (should be zero if the root was really a
	 * root).
	 */
	rt_poly_synthetic_division( oldP, &div, oldP, &rem );
}
@


11.13
log
@change conf.h to a wrapped config.h
@
text
@d20 1
a20 1
static const char RCSroots[] = "@@(#)$Header: /cvs/brlcad/librt/roots.c,v 11.12 2004/04/05 08:48:58 morrison Exp $ (BRL)";
@


11.12
log
@merge of ansi-6-0-branch into HEAD
@
text
@d20 1
a20 1
static const char RCSroots[] = "@@(#)$Header$ (BRL)";
d23 5
a27 1
#include "conf.h"
@


11.11
log
@update copyright to include span through 2003
@
text
@d20 1
a20 1
static const char RCSroots[] = "@@(#)$Header: /c/CVS/brlcad/librt/roots.c,v 11.10 2003/04/02 16:48:51 jra Exp $ (BRL)";
d33 3
a35 3
int		rt_poly_roots();
void	rt_poly_eval_w_2derivatives(), rt_poly_deflate();
int	rt_poly_findroot(), rt_poly_checkroots();
d157 3
a159 3
rt_poly_findroot( eqn, nxZ )
register bn_poly_t	*eqn;	/* polynomial			*/
register bn_complex_t	*nxZ;	/* initial guess for root	*/
d251 4
a254 4
rt_poly_eval_w_2derivatives( cZ, eqn, b, c, d )
register bn_complex_t	*cZ;		/* input */
register bn_poly_t	*eqn;		/* input */
register bn_complex_t	*b, *c, *d;	/* outputs */
d301 1
a301 4
rt_poly_checkroots( eqn, roots, nroots )
register bn_poly_t		*eqn;
bn_complex_t			roots[];
register int		nroots;
d344 1
a344 3
rt_poly_deflate( oldP, root )
register bn_poly_t	*oldP;
register bn_complex_t	*root;
@


11.10
log
@Initialized two variables to quiet the compiler
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1985 by the United States Army.
d20 1
a20 1
static const char RCSroots[] = "@@(#)$Header: /c/CVS/brlcad/librt/roots.c,v 11.9 2002/08/20 17:08:09 jra Exp $ (BRL)";
@


11.10.6.1
log
@merge from HEAD
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d20 1
a20 1
static const char RCSroots[] = "@@(#)$Header: /c/CVS/brlcad/librt/roots.c,v 11.11 2004/02/02 17:39:28 morrison Exp $ (BRL)";
@


11.10.6.2
log
@merge from head
@
text
@d20 1
a20 1
static const char RCSroots[] = "@@(#)$Header: /c/CVS/brlcad/librt/roots.c,v 11.10.6.1 2004/02/12 18:37:47 erikg Exp $ (BRL)";
@


11.9
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d20 1
a20 1
static const char RCSroots[] = "@@(#)$Header: /c/CVS/brlcad/librt/roots.c,v 11.7 2000/08/21 02:02:34 butler Exp $ (BRL)";
d165 2
a166 2
	FAST fastf_t	diff;		/* test values for convergence	*/
	FAST fastf_t	b;		/* floating temps */
@


11.9.4.1
log
@sync to HEAD...
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d20 1
a20 1
static const char RCSroots[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/librt/roots.c,v 11.11 2004/02/02 17:39:28 morrison Exp $ (BRL)";
d165 2
a166 2
	FAST fastf_t	diff=0.0;		/* test values for convergence	*/
	FAST fastf_t	b=0.0;		/* floating temps */
@


11.9.2.1
log
@Initial ANSIfication
@
text
@d20 1
a20 1
static const char RCSroots[] = "@@(#)$Header: /c/CVS/brlcad/librt/roots.c,v 11.9 2002/08/20 17:08:09 jra Exp $ (BRL)";
d33 3
a35 3
int		rt_poly_roots(register bn_poly_t *eqn, register bn_complex_t *roots);
void	rt_poly_eval_w_2derivatives(register bn_complex_t *cZ, register bn_poly_t *eqn, register bn_complex_t *b, register bn_complex_t *c, register bn_complex_t *d), rt_poly_deflate(register bn_poly_t *oldP, register bn_complex_t *root);
int	rt_poly_findroot(register bn_poly_t *eqn, register bn_complex_t *nxZ), rt_poly_checkroots(register bn_poly_t *eqn, bn_complex_t *roots, register int nroots);
d157 3
a159 3
rt_poly_findroot(register bn_poly_t *eqn, register bn_complex_t *nxZ)
                  	     	/* polynomial			*/
                     	     	/* initial guess for root	*/
d251 4
a254 4
rt_poly_eval_w_2derivatives(register bn_complex_t *cZ, register bn_poly_t *eqn, register bn_complex_t *b, register bn_complex_t *c, register bn_complex_t *d)
                     	    		/* input */
                  	     		/* input */
                     	           	/* outputs */
d301 4
a304 1
rt_poly_checkroots(register bn_poly_t *eqn, bn_complex_t *roots, register int nroots)
d347 3
a349 1
rt_poly_deflate(register bn_poly_t *oldP, register bn_complex_t *root)
@


11.9.2.2
log
@sync branch with HEAD
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d20 1
a20 1
static const char RCSroots[] = "@@(#)$Header$ (BRL)";
d165 2
a166 2
	FAST fastf_t	diff=0.0;		/* test values for convergence	*/
	FAST fastf_t	b=0.0;		/* floating temps */
@


11.8
log
@Converted from K&R to ANSI C - RFH
@
text
@d33 3
a35 3
int		rt_poly_roots(register bn_poly_t *eqn, register bn_complex_t *roots);
void	rt_poly_eval_w_2derivatives(register bn_complex_t *cZ, register bn_poly_t *eqn, register bn_complex_t *b, register bn_complex_t *c, register bn_complex_t *d), rt_poly_deflate(register bn_poly_t *oldP, register bn_complex_t *root);
int	rt_poly_findroot(register bn_poly_t *eqn, register bn_complex_t *nxZ), rt_poly_checkroots(register bn_poly_t *eqn, bn_complex_t *roots, register int nroots);
d157 3
a159 3
rt_poly_findroot(register bn_poly_t *eqn, register bn_complex_t *nxZ)
                  	     	/* polynomial			*/
                     	     	/* initial guess for root	*/
d251 4
a254 4
rt_poly_eval_w_2derivatives(register bn_complex_t *cZ, register bn_poly_t *eqn, register bn_complex_t *b, register bn_complex_t *c, register bn_complex_t *d)
                     	    		/* input */
                  	     		/* input */
                     	           	/* outputs */
d301 4
a304 1
rt_poly_checkroots(register bn_poly_t *eqn, bn_complex_t *roots, register int nroots)
d347 3
a349 1
rt_poly_deflate(register bn_poly_t *oldP, register bn_complex_t *root)
@


11.7
log
@Massive compilation warnings eliminated
@
text
@d20 1
a20 1
static const char RCSroots[] = "@@(#)$Header: /c/CVS/brlcad/librt/roots.c,v 11.6 2000/07/10 23:01:48 mike Exp $ (BRL)";
d33 3
a35 3
int		rt_poly_roots();
void	rt_poly_eval_w_2derivatives(), rt_poly_deflate();
int	rt_poly_findroot(), rt_poly_checkroots();
d157 3
a159 3
rt_poly_findroot( eqn, nxZ )
register bn_poly_t	*eqn;	/* polynomial			*/
register bn_complex_t	*nxZ;	/* initial guess for root	*/
d251 4
a254 4
rt_poly_eval_w_2derivatives( cZ, eqn, b, c, d )
register bn_complex_t	*cZ;		/* input */
register bn_poly_t	*eqn;		/* input */
register bn_complex_t	*b, *c, *d;	/* outputs */
d301 1
a301 4
rt_poly_checkroots( eqn, roots, nroots )
register bn_poly_t		*eqn;
bn_complex_t			roots[];
register int		nroots;
d344 1
a344 3
rt_poly_deflate( oldP, root )
register bn_poly_t	*oldP;
register bn_complex_t	*root;
@


11.6
log
@
Added "const" to RCSid string, to silence warnings of unused variable
on GCC compilers
@
text
@d20 1
a20 1
static const char RCSroots[] = "@@(#)$Header: /c/CVS/brlcad/librt/roots.c,v 11.5 1999/07/02 22:19:25 mike Exp $ (BRL)";
d49 2
a50 3
rt_poly_roots( eqn, roots )
register bn_poly_t	*eqn;		/* equation to be solved	*/
register bn_complex_t	roots[];	/* space to put roots found	*/
@


11.5
log
@
Removed dependence on compat4.h
@
text
@d20 1
a20 1
static char RCSroots[] = "@@(#)$Header: /c/CVS/brlcad/librt/roots.c,v 11.4 1996/09/27 08:27:30 mike Exp $ (BRL)";
@


11.4
log
@Converted to using proper routine names for LIBBU and LIBBN routines.
@
text
@d20 1
a20 1
static char RCSroots[] = "@@(#)$Header: /m/cad/librt/RCS/roots.c,v 11.3 1996/09/27 07:18:40 mike Exp mike $ (BRL)";
d162 4
a165 4
	LOCAL complex  p0, p1, p2;	/* evaluated polynomial+derivatives */
	LOCAL bn_complex_t	p1_H;		/* p1 - H, temporary */
	LOCAL complex  cZ, cH;		/* 'Z' and H(Z) in comment	*/
	LOCAL complex  T;		/* temporary for making H */
d364 1
a364 1
		/*  root is bn_complex_t		*/
@


11.3
log
@sed4
@
text
@d20 1
a20 1
static char RCSroots[] = "@@(#)$Header: /m/cad/librt/RCS/roots.c,v 11.2 1996/08/31 10:57:57 mike Exp mike $ (BRL)";
d37 2
a38 1
/*	>>>  p o l y R o o t s ( )  <<<
d50 1
a50 1
register poly		*eqn;		/* equation to be solved	*/
d159 1
a159 1
register poly		*eqn;	/* polynomial			*/
d193 1
a193 1
		if ( bn_cx_amplSq( &p1_H ) > bn_cx_amplSq( &p1 ) ){
d204 1
a204 1
		 * a square root.  Using bn_cx_amplSq() saves lots of cycles,
d212 2
a213 2
		b = bn_cx_amplSq( nxZ );
		diff = bn_cx_amplSq( &p0 );
d254 1
a254 1
register poly		*eqn;		/* input */
d303 1
a303 1
register poly		*eqn;
d349 1
a349 1
register poly		*oldP;
d352 1
a352 1
	LOCAL poly	div, rem;
d368 1
a368 1
		div.cf[2] = bn_cx_amplSq( root );
@


11.2
log
@bn.h
@
text
@d20 1
a20 1
static char RCSroots[] = "@@(#)$Header: /m/cad/librt/RCS/roots.c,v 11.1 1995/01/04 09:58:33 mike Rel4_4 mike $ (BRL)";
d50 1
a50 1
register complex	roots[];	/* space to put roots found	*/
d70 1
a70 1
	(void) rt_poly_scale( eqn, factor );
d101 1
a101 1
		CxCons( &roots[n], 0.0, SMALL );
d112 1
a112 1
			CxConj(&roots[n]);
d159 1
a159 1
register complex	*nxZ;	/* initial guess for root	*/
d162 1
a162 1
	LOCAL complex	p1_H;		/* p1 - H, temporary */
d176 5
a180 5
		CxMul2( &cH, &p1, &p1 );
		CxScal( &cH, (double)(n*n) );
		CxMul2( &T, &p2, &p0 );
		CxScal( &T, (double)(eqn->dgr*n) );
		CxSub( &cH, &T );
d187 1
a187 1
		CxSqrt( &cH );
d189 6
a194 6
		CxSub( &p1_H, &cH );
		CxAdd( &p1, &cH );		/* p1 <== p1+H */
		CxScal( &p0, (double)(eqn->dgr) );
		if ( CxAmplSq( &p1_H ) > CxAmplSq( &p1 ) ){
			CxDiv( &p0, &p1_H);
			CxSub( nxZ, &p0 );
d196 2
a197 2
			CxDiv( &p0, &p1 );
			CxSub( nxZ, &p0 );
d202 2
a203 2
		 * The original version used CxAmpl(), which requires
		 * a square root.  Using CxAmplSq() saves lots of cycles,
d211 2
a212 2
		b = CxAmplSq( nxZ );
		diff = CxAmplSq( &p0 );
d223 1
a223 1
	rt_log("rt_poly_findroot:  didn't converge in %d iterations, b=%g, diff=%g\n",
d225 1
a225 1
	rt_log("nxZ=%gR+%gI, p0=%gR+%gI\n", nxZ->re, nxZ->im, p0.re, p0.im);
d252 1
a252 1
register complex	*cZ;		/* input */
d254 1
a254 1
register complex	*b, *c, *d;	/* outputs */
d259 1
a259 1
	CxCons(b,eqn->cf[0],0.0);
d264 1
a264 1
		CxMul( b, cZ );
d267 2
a268 2
			CxMul( c, cZ );
			CxAdd( c, b );
d271 2
a272 2
			CxMul( d, cZ );
			CxAdd( d, c );
d303 1
a303 1
complex			roots[];
d313 2
a314 2
		zr = CxReal( &roots[m] );
		zi = CxImag( &roots[m] );
d349 1
a349 1
register complex	*root;
d363 1
a363 1
		/*  root is complex		*/
d367 1
a367 1
		div.cf[2] = CxAmplSq( root );
@


11.1
log
@Release_4.4
@
text
@d20 1
a20 1
static char RCSroots[] = "@@(#)$Header: /m/cad/librt/RCS/roots.c,v 10.4 94/12/27 17:14:13 mike Exp $ (BRL)";
d28 1
d30 1
a31 2
#include "./polyno.h"
#include "./complex.h"
d105 1
a105 1
		if ( Abs(roots[n].im) > 1.0e-5* Abs(roots[n].re) ){
d332 1
a332 1
		if ( Abs( er ) > 1.0e-5 || Abs( ei ) > 1.0e-5 )
@


10.4
log
@Fix to bug #247
Added rt_prefix and regularized names like polyRoots into rt_poly_roots.
@
text
@d20 1
a20 1
static char RCSroots[] = "@@(#)$Header: /m/cad/librt/RCS/roots.c,v 10.3 94/11/05 01:46:26 mike Exp Locker: mike $ (BRL)";
@


10.3
log
@Irix 6
@
text
@d5 1
a5 1
 *	polyRoots		Find the roots of a polynomial
d20 1
a20 1
static char RCSroots[] = "@@(#)$Header: /m/cad/librt/RCS/roots.c,v 10.2 94/08/10 19:43:14 gdurf Exp Locker: mike $ (BRL)";
d33 1
a33 1
int		polyRoots();
d48 1
a48 1
polyRoots( eqn, roots )
d70 1
a70 1
	(void) polyScal( eqn, factor );
d84 1
a84 1
			if( quartic( eqn, &roots[n] ) )  {
d90 1
a90 1
			if( cubic( eqn, &roots[n] ) )  {
d130 1
a130 1
		quadratic( eqn, &roots[n] );
d374 1
a374 1
	synDiv( oldP, &div, oldP, &rem );
@


10.2
log
@Added include of conf.h
@
text
@d20 1
a20 1
static char RCSroots[] = "@@(#)$Header: /m/cad/librt/RCS/roots.c,v 10.1 1991/10/12 06:40:58 mike Rel4_0 gdurf $ (BRL)";
d29 1
@


10.1
log
@Release_4.0
@
text
@d20 1
a20 1
static char RCSroots[] = "@@(#)$Header: /m/cad/librt/RCS/roots.c,v 9.3 91/03/13 20:59:34 mike Exp $ (BRL)";
d23 3
a26 1
#include <stdio.h>
@


9.3
log
@Major optimization
@
text
@d20 1
a20 1
static char RCSroots[] = "@@(#)$Header: /m/cad/librt/RCS/roots.c,v 9.2 91/03/13 16:36:43 mike Exp $ (BRL)";
@


9.2
log
@Modified polyRoots to check found roots before claiming that they
were OK.
Changed some routine names.
@
text
@d20 1
a20 1
static char RCSroots[] = "@@(#)$Header: /m/cad/librt/RCS/roots.c,v 9.1 89/05/19 05:57:03 mike Rel3_5 $ (BRL)";
d173 1
a173 2
		cH = p1;
		CxMul( &cH, &p1 );
d175 1
a175 2
		T = p0;
		CxMul( &T, &p2 );
d300 1
a300 1
register complex	roots[];
d303 4
a306 2
	LOCAL complex	epoly;
	register int	n, m;
d309 3
a311 1
		CxCons( &epoly, eqn->cf[0], 0.0 );
d313 15
a327 3
		for ( n=1; n <= eqn->dgr; ++n)  {
			CxMul( &epoly, &roots[m] );
			epoly.re += eqn->cf[n];
d329 1
a329 1
		if ( Abs( epoly.re ) > 1.0e-5 || Abs( epoly.im ) > 1.0e-5 )
d332 1
a332 1
	/* Both real & imaginary are "zero" */
@


9.1
log
@Release_3.5
@
text
@d20 1
a20 1
static char RCSroots[] = "@@(#)$Header: roots.c,v 8.1 88/10/05 00:31:37 mike Rel3_0 $ (BRL)";
d31 2
a32 2
HIDDEN void	synthetic(), deflate();
HIDDEN int	findRoot(), evalpoly();
a51 10
	/* Allocate space for the roots and set the first guess to
	 * (almost) zero.
	 *
	 * This method seems to require a small nudge off the real axis
	 * despite documentation to the contrary.
	 */
	for ( n=0; n < MAXP; n++ ){
		CxCons( &roots[n], 0.0, SMALL );
	}

d55 1
a55 1
	while( eqn->cf[0] > -SMALL && eqn->cf[0] < SMALL )  {
d73 1
a73 1
	while ( eqn->cf[eqn->dgr] == 0.0 ){
a79 1

d81 11
a91 4
			if( quartic( eqn, &roots[n] ) )
				return( n+4 );
			if( evalpoly( eqn, &roots[n], 4 ) == 0 )
				return ( n+4 );
d94 6
a99 8
		if ( eqn->dgr == 3 )  {
			if( cubic( eqn, &roots[n] ) )
				return( n+3 );
			if ( evalpoly( eqn, &roots[n], 3 ) == 0 )
				return ( n+3 );
		}

		if ( (findRoot( eqn, &roots[n] )) < 0 )
d115 1
a115 1
		deflate( eqn, &roots[n] );
d133 2
a134 1
/*	>>>  f i n d R o o t ( )  <<<
d153 2
a154 2
HIDDEN int
findRoot( eqn, nxZ )
d169 1
a169 1
		synthetic( &cZ, eqn, &p0, &p1, &p2 );
d222 1
a222 1
	rt_log("findRoot:  didn't converge in %d iterations, b=%g, diff=%g\n",
d229 2
a230 1
/*	>>>  s y n t h e t i c ( )  <<<
d249 2
a250 2
HIDDEN void
synthetic( cZ, eqn, b, c, d )
d277 2
a278 1
/*	>>>  e v a l p o l y ( )  <<<
d281 7
d299 2
a300 2
HIDDEN int
evalpoly( eqn, roots, nroots )
d311 1
a311 1
		for ( n=1; n <= eqn->dgr; ++n){
d314 1
a314 1
			}
d316 1
a316 1
			return 1;
d318 2
a319 1
	return 0;
d323 2
a324 1
/*	>>>  d e f l a t e ( )  <<<
d326 1
d329 2
a330 2
HIDDEN void
deflate( oldP, root )
d332 1
a332 1
register complex		*root;
d340 1
a340 1
	if ( root->im == 0 ) {
@


8.1
log
@Release_3.0
@
text
@d20 1
a20 1
static char RCSroots[] = "@@(#)$Header: roots.c,v 7.2 88/01/23 05:20:14 moss Exp $ (BRL)";
@


7.2
log
@Relaxed code to avoid SGI XNS IRIS 3.5 compiler bug
@
text
@d20 1
a20 1
static char RCSroots[] = "@@(#)$Header: roots.c,v 7.1 87/11/02 23:34:02 moss Locked $ (BRL)";
@


7.1
log
@Release 2.3
@
text
@d20 1
a20 1
static char RCSroots[] = "@@(#)$Header: roots.c,v 6.1 87/07/11 07:56:20 mike Rel $ (BRL)";
d211 3
d215 3
a217 1
		if( (b = CxAmplSq( nxZ )) < (diff = CxAmplSq( &p0 )) )
@


6.1
log
@Release 2.0
@
text
@d20 1
a20 1
static char RCSroots[] = "@@(#)$Header: roots.c,v 5.1 87/06/24 22:12:09 mike Rel $ (BRL)";
@


5.1
log
@Release 1.24
@
text
@d20 1
a20 1
static char RCSroots[] = "@@(#)$Header: roots.c,v 4.2 87/02/12 22:11:45 mike Exp $ (BRL)";
@


4.2
log
@Release 1.20 -- First Formal Release
@
text
@d20 1
a20 1
static char RCSroots[] = "@@(#)$Header: roots.c,v 4.1 86/12/29 03:45:47 mike Rel1 $ (BRL)";
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d20 1
a20 1
static char RCSroots[] = "@@(#)$Header: roots.c,v 3.4 86/12/13 07:13:48 mike Exp $ (BRL)";
@


3.4
log
@Changed several SMALLs to 1.0e-5 for SGI.
Only 1 of the 3 places is probably necessary, and
should be investigated when it isn't 7 AM.
@
text
@d20 1
a20 1
static char RCSroots[] = "@@(#)$Header: roots.c,v 3.3 86/12/13 05:42:39 mike Locked $ (BRL)";
@


3.3
log
@Improved handling of machine epsilon with some new defines.
@
text
@d20 1
a20 1
static char RCSroots[] = "@@(#)$Header: roots.c,v 3.2 86/08/12 04:16:16 mike Exp $ (BRL)";
d108 1
a108 1
		if ( Abs(roots[n].im) > SMALL* Abs(roots[n].re) ){
d216 1
a216 1
		if( diff > (b - diff)*SMALL ) 
d306 1
a306 1
		if ( Abs( epoly.re ) > SMALL || Abs( epoly.im ) > SMALL )
@


3.2
log
@Changed #include directives for use with CC -I convention
@
text
@d20 1
a20 1
static char RCSroots[] = "@@(#)$Header: roots.c,v 3.1 86/07/11 01:32:30 mike Exp $ (BRL)";
d65 1
a65 2
#define ALMOST_ZERO	(1.0e-16)
	while( eqn->cf[0] > -ALMOST_ZERO && eqn->cf[0] < ALMOST_ZERO )  {
a138 1

d167 2
a168 2
	LOCAL fastf_t	diff;		/* test values for convergence	*/
	LOCAL fastf_t	b;		/* floating temps */
d206 5
a210 4
		 * THIS IS WIERD, AND COSTLY, using CxAmpl().
		 * Using CxAmplSq() saves lots of cycles;  the loop
		 * termination induced by SMALL will change, but probably
		 * not by vast amounts.
d212 1
a212 4
		b = CxAmplSq( nxZ );		/* Was CxAmpl() */
		diff = CxAmplSq( &p0 );		/* nxZ - Z = -p0 */

		if ( b < diff )
d214 3
a216 1
		else if ( diff > (b - diff)*SMALL ) 
d218 1
a218 1
		return(i);	/* OK */
d222 3
a224 1
	rt_log("findRoot:  didn't converge in 20 iterations\n");
d250 3
a252 2
register poly		*eqn;
register complex	*cZ, *b, *c, *d;
d255 1
a255 1
	LOCAL int	m;
@


3.1
log
@Cleanups inspired by the crummy compiler on the Cray XMP
@
text
@d20 1
a20 1
static char RCSroots[] = "@@(#)$Header: roots.c,v 3.0 86/06/10 01:33:34 mike Exp $ (BRL)";
d25 4
a28 4
#include "../h/machine.h"
#include "../h/vmath.h"
#include "polyno.h"
#include "complex.h"
@


3.0
log
@rt/ and librt/ separated,
global datastructures simplified.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: roots.c,v 2.1 85/08/31 06:06:00 mike Exp $ (BRL)";
@


2.1
log
@Version 2 of RT
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: roots.c,v 1.15 85/07/30 05:54:57 mike Exp $ (BRL)";
a28 1
#include "debug.h"
a66 4
		if( debug & DEBUG_ROOTS )  {
			rtlog("polyRoots:  Leading coeff too small, discarding.");
			pr_poly(eqn);
		}
d224 1
a224 1
	rtlog("findRoot:  didn't converge in 20 iterations\n");
@


1.15
log
@Changes for merged GED & RT vmath.h
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: roots.c,v 1.14 85/03/25 11:55:22 mike Exp $ (BRL)";
d69 1
a69 1
			fprintf(stderr,"polyRoots:  Leading coeff too small, discarding.");
d229 1
a229 1
	fprintf(stderr,"findRoot:  didn't converge in 20 iterations\n");
@


1.14
log
@Added include for debug.h
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: roots.c,v 1.13 85/03/25 11:34:38 mike Exp $ (BRL)";
d25 2
a26 1
#include "vmath.h"
@


1.13
log
@Changed almost-zero definition.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d28 1
@


1.12
log
@minor neatness
@
text
@d3 15
d19 4
d64 1
a64 1
#define ALMOST_ZERO	(1.0e-12)
d66 4
a69 1
		fprintf(stderr,"polyRoots:  Leading coeff too small:"); pr_poly(eqn);
a74 1
		fprintf(stderr,"polyRoots:  After discarding coeff..."); pr_poly(eqn);
@


1.11
log
@New polyRoots which makes lots of noise before discarding
a leading coefficient too close to zero.
@
text
@d45 1
a45 1
#ifdef ALMOST_ZERO	(1.0e-12)
d47 1
a47 1
fprintf(stderr,"polyRoots:  Leading coeff too small:"); pr_poly(eqn);
d53 1
a53 1
fprintf(stderr,"polyRoots:  After discarding coeff..."); pr_poly(eqn);
@


1.10
log
@Moved HIDDEN definition to vmath.h, made more functions HIDDEN
to aid debugging.
@
text
@d42 2
a43 1
	/* Remove leading coefficients which are too close to zero.
d45 3
a47 1
	while ( Abs(eqn->cf[0]) <= SMALL ){
d53 1
@


1.9
log
@Added error returns from cubic() and quartic(),
tried to add SIGFPE catching within cubic().
@
text
@d11 2
a12 2
static void	synthetic(), deflate();
static int	findRoot(), evalpoly();
d138 1
a138 1
static int
d226 1
a226 1
static void
d267 1
a267 1
static int
d294 1
a294 1
static void
@


1.8
log
@GSM fix:  if quartic fails, use evalpoly.
@
text
@d70 5
a74 7
		if ( eqn->dgr == 4 ){
			if(   ! quartic( eqn, &roots[n] )
			   &&	evalpoly( eqn, &roots[n], 4 ) == 0
				)
				{
				return ( n+=4 );
				}
d77 5
a81 5
		if ( eqn->dgr == 3 ){
			cubic( eqn, &roots[n] );
			if ( evalpoly( eqn, &roots[n], 3 ) == 0 ){
				return ( n+=3 );
			}
@


1.7
log
@Fixed small bug with roots of zero, slight code rearrangement.
@
text
@d71 4
a74 2
			quartic( eqn, &roots[n] );
			if ( evalpoly( eqn, &roots[n], 4 ) == 0 ){
d76 1
a76 1
			}
@


1.6
log
@Added LOCAL, fastf_t declarations.
Made shootray() recursive.
@
text
@d63 1
a63 1
		roots[n].im = 0.0;
d85 1
a85 1
			return -1;
d152 1
a152 10
	i = 0;
	for(;;) {
		/* If the thing hasn't converged after 20 iterations,
		 * it probably won't.
		 */
		if (++i > 20)  {
			printf("findRoot:  didn't converge in 20 iterations\n");
			return -1;
		}

d198 1
a198 1
		return i;
d200 4
@


1.5
log
@More bug fixes from Jeff Hanes
@
text
@d1 8
a8 4
#include  "./polyno.h"
#include  "./complex.h"
#include  <math.h>
#include  <stdio.h>
d30 1
a30 1
	static double	factor;		/* scaling factor for copy	*/
d143 7
a149 7
	static complex  p0, p1, p2;	/* evaluated polynomial+derivatives */
	static complex	p1_H;		/* p1 - H, temporary */
	static complex  Z, H;		/* 'Z' and H(Z) in comment	*/
	static complex  T;		/* temporary for making H */
	static double	diff;		/* test values for convergence	*/
	static double	b;		/* floating temps */
	static int	n;
d162 2
a163 2
		Z = *nxZ;
		synthetic( &Z, eqn, &p0, &p1, &p2 );
d167 3
a169 3
		H = p1;
		CxMul( &H, &p1 );
		CxScal( &H, (double)(n*n) );
d173 1
a173 1
		CxSub( &H, &T );
d180 1
a180 1
		CxSqrt( &H );
d182 2
a183 2
		CxSub( &p1_H, &H );
		CxAdd( &p1, &H );		/* p1 <== p1+H */
d232 1
a232 1
synthetic( Z, eqn, b, c, d )
d234 1
a234 1
register complex	*Z, *b, *c, *d;
d237 1
a237 1
	static int	m;
d244 1
a244 1
		CxMul( b, Z );
d247 1
a247 1
			CxMul( c, Z );
d251 1
a251 1
			CxMul( d, Z );
d278 1
a278 1
	static complex	epoly;
d304 1
a304 1
	static poly	div, rem;
@


1.4
log
@New version from Jeff Haynes
@
text
@d44 2
a45 1
		--eqn->dgr;
d107 1
a107 1
	} else {
d277 1
a277 1
	for ( m=0; m < nroots; m+=2 ){
@


1.3
log
@Efficiency fixes, including expanding code inline into findRoot,
and improving the performance of the convergence test in findRoot.
@
text
@a5 3
#define	SMALL		0.000001
#define	Abs( a )	((a) >= 0 ? (a) : -(a))

d7 2
a8 1
static void	findRoot(), synthetic(), deflate();
a9 1

d22 2
a23 2
register  poly	*eqn;		/* equation to be solved	*/
register complex roots[];	/* space to put roots found	*/
d52 1
d54 9
a62 1
	n = 0;		/* Number of roots found */
d64 6
a69 8
		/* A trailing coefficient of zero indicates that zero
		 * is a root of the equation.
		 */
		if ( eqn->cf[eqn->dgr] == 0.0 ){
			roots[n].im = 0.0;
			--eqn->dgr;
			++n;
			continue;	/* go to next loop		*/
d72 6
a77 1
		findRoot( eqn, &(roots[n]) );
d79 3
d107 1
a107 1
		quadratic( eqn, &roots[n], &roots[n+1] );
d133 1
a133 1
static void
d142 2
a143 2
	static double	diff, dist;	/* test values for convergence	*/
	static double	a,b;		/* floating temps */
d154 1
a154 1
			return;
d196 3
a198 9
		a = CxAmplSq( &Z );		/* Was CxAmpl() */
		diff = a - b;
		diff = Abs( diff );
		if ( b < diff ){
			dist = 0;
		} else {
			dist = (b - diff) * SMALL;
		}
		if( diff > dist )
d200 3
a202 1
		return;
d251 38
@


1.2
log
@Efficiency modifications.
@
text
@d10 1
a10 1
static void	findRoot(), synthetic(), compH(), nextZ(), deflate();
d127 1
d129 1
d131 2
a132 1
	static double	f;		/* floating temp */
d136 9
a144 1
	do {
a146 2
		compH( &H, &p0, &p1, &p2, eqn->dgr );
		nextZ( nxZ, &p0, &p1, &H, eqn->dgr );
d148 14
a161 2
		/* If the thing hasn't converged after 20 iterations,
		 * it probably won't.
d163 12
a174 2
		if (++i > 20)
			break;
d178 4
d183 3
a185 2
		f = CxAmpl( nxZ );
		diff = CxAmpl( &Z ) - f;
d187 1
a187 1
		if ( ( dist = f - diff ) < 0 ){
d190 1
a190 1
			dist = SMALL* Abs(dist);
d192 4
a195 1
	} while ( diff > dist );
a243 58

/*	>>>  c o m p H ( )  <<<
 *
 *	Computes H for Laguerre's method.
 *	See note under 'findRoot' for explicit formula.
 */
static void
compH( H, p0, p1, p2, degr )
register complex   *H, *p0, *p1, *p2;
int       degr;
{
	static complex   T;
	register int       n=degr-1;

	T = *p0;
	*H = *p1;

	CxMul( H, p1 );
	CxScal( H, (double)(n*n) );
	CxMul( &T, p2 );
	CxScal( &T, (double)(degr*n) );

	CxSub( H, &T );
}


/*	>>>  n e x t Z ( )  <<<
 *
 *	Calculates the next iteration for Laguerre's method.
 *	See note under 'findRoot' for explicit formula.
 */
static void
nextZ( nxZ, p0, p1, H, degr )
register complex   *nxZ, *p0, *p1, *H;
int       degr;
{
	static complex   p1A, p1S;

	p1A = *p1;
	p1S = *p1;
	CxSqrt(H);
	/* Test to see whether addition or subtraction gives the larger
	 * denominator for the next 'Z' , and use the appropriate value
	 * in the formula.
	 */
	CxSub( &p1S, H );
	CxAdd( &p1A, H );
	CxScal( p0, (double)(degr) );
	if ( CxAmpl( &p1S ) > CxAmpl( &p1A ) ){
		CxDiv( p0, &p1S);
		CxSub( nxZ, p0 );
	} else {
		CxDiv( p0, &p1A );
		CxSub( nxZ, p0 );
	}
}


d269 1
a269 1
		div.cf[2] = root->re * root->re + root->im * root->im;
@


1.1
log
@Initial revision
@
text
@d6 1
a6 1
#define   SMALL                 .000001
d15 3
a20 7
 *
 *			e.g.	typedef  struct
 *					{
 *					int		dgr;
 *					complex		cf[MAXP];
 *					}  cx_poly;
 *
d24 3
a26 4
polyRoots(orig,roots)
poly		*orig;		/* equation to be solved	*/
complex		*roots[];	/* space to put roots found	*/

d28 2
a29 4
  	int	n=0;		/* number of roots found	*/
	int	init, slp;	/* loop counters		*/
	poly	*copy;		/* abusable copy of equation	*/
	double	factor;		/* scaling factor for copy	*/
a30 3
	copy = polyAllo();
	*copy = *orig;

d37 2
a38 2
	for ( init=0; init < MAXP; ++init ){
		roots[init] = CxCons( CxAllo(),0.0,SMALL);
d43 3
a45 3
	while ( Abs(copy->cf[0]) <= SMALL ){
		for ( slp=0; slp <= copy->dgr; ++slp){
			copy->cf[slp] = copy->cf[slp+1];
d47 1
a47 1
		--copy->dgr;
d53 2
a54 2
	factor = 1.0 / copy->cf[0];
	(void) polyScal(copy,factor);
d56 2
a57 1
	while ( copy->dgr > 2 ){
d61 3
a63 3
		if ( copy->cf[copy->dgr] == 0.0 ){
			roots[n]->im = 0.0;
			--copy->dgr;
d68 1
a68 1
		findRoot(copy,roots[n]);
d70 1
a70 1
		if ( Abs(roots[n]->im) > SMALL* Abs(roots[n]->re) ){
d76 2
a77 2
			*roots[n] = *roots[n-1];
			(void) CxConj(roots[n]);
d80 1
a80 1
			roots[n]->im = 0.0;
d83 1
a83 1
		deflate(copy,roots[n]);
d90 3
a92 3
	if ( copy->dgr == 1 ){
		roots[n]->re = -copy->cf[1];
		roots[n]->im = 0.0;
d95 1
a95 1
		quadratic(copy,roots[n],roots[n+1]);
d103 1
d122 3
a124 4
findRoot(eqn,nxZ)
poly		*eqn;	/* polynomial			*/
complex		*nxZ;	/* initial guess for root	*/

d126 5
a130 5
	complex		p0, p1, p2;	/* evaluated polynomial
						and derivatives		*/
	complex		*Z, *H;		/* 'Z' and H(Z) in comment	*/
	int		i=0;		/* iteration counter		*/
	double		diff, dist;	/* test values for convergence	*/
d132 1
a132 3
	H = CxAllo();
	Z = CxAllo();

d134 4
a137 4
		*Z = *nxZ;
		synthetic(Z,eqn,&p0,&p1,&p2);
		compH(H,&p0,&p1,&p2,eqn->dgr);
		nextZ(nxZ,&p0,&p1,H,eqn->dgr);
d148 4
a151 2
		diff = Abs(CxAmpl(Z) - CxAmpl(nxZ));
		if ( ( dist = CxAmpl(nxZ) - diff ) < 0 ){
a156 2

	return;
d161 1
d180 3
a182 4
synthetic(Z,eqn,b,c,d)
poly		*eqn;
complex		*Z, *b, *c, *d;

d184 2
a185 1
	int	n, m;
d187 1
a187 1
	(void) CxCons(b,eqn->cf[0],0.0);
a190 1

d192 1
a192 1
		(void) CxMul(b,Z);
d195 2
a196 1
			(void) CxAdd( CxMul(c,Z), b);
d199 2
a200 1
			(void) CxAdd( CxMul(d,Z), c);
a202 1
	return;
d207 1
d212 2
a213 2
compH(H,p0,p1,p2,degr)
complex   *H, *p0, *p1, *p2;
a214 1

d216 2
a217 2
	complex   *T;
	int       n=degr-1;
d219 1
a219 2
	T = CxAllo();
	*T = *p0;
d222 4
a225 2
	(void) CxScal( CxMul(H,p1), (double)(n*n) );
	(void) CxScal( CxMul(T,p2), (double)(degr*n) );
d227 1
a227 2
	(void) CxSub(H,T);
	return;
d232 1
d237 2
a238 2
nextZ(nxZ,p0,p1,H,degr)
complex   *nxZ, *p0, *p1, *H;
a239 1

d241 1
a241 1
	complex   *p1A, *p1S;
d243 3
a245 6
	p1A = CxAllo();
	p1S = CxAllo();
	*p1A = *p1;
	*p1S = *p1;
	(void) CxSqrt(H);

d250 6
a255 2
	if ( CxAmpl( CxSub(p1S,H) ) > CxAmpl( CxAdd(p1A,H) ) ){
		(void) CxSub(nxZ, CxDiv( CxScal(p0,(double)(degr)), p1S) );
d257 2
a258 1
		(void) CxSub(nxZ, CxDiv( CxScal(p0,(double)(degr)), p1A) );
a259 1
	return;
d264 1
d268 3
a270 4
deflate(oldP,root)
poly		*oldP;
complex		*root;

d272 1
a272 1
	poly		*div, *rem;
a273 3
	div = polyAllo();
	rem = polyAllo();

d278 11
a288 9
	if ( root->im == 0 ) {		/*  root is real		*/
		div->dgr = 1;
		div->cf[0] = 1;
		div->cf[1] = - root->re;
	} else {			/*  root is complex		*/
		div->dgr = 2;
		div->cf[0] = 1;
		div->cf[1] = -2 * root->re;
		div->cf[2] = CxAmpl(root) * CxAmpl(root);
d295 1
a295 2
	synDiv(oldP,div,oldP,rem);
	return;
@
