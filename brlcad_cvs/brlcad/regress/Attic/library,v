head	1.13;
access;
symbols
	ansi-20040405-merged:1.12
	postmerge-20040405-ansi:1.12
	premerge-20040404-ansi:1.12
	postmerge-autoconf:1.12
	autoconf-freeze:1.12
	premerge-autoconf:1.12
	postmerge-20040315-windows:1.12
	premerge-20040315-windows:1.12
	windows-20040315-freeze:1.12
	autoconf-20031203:1.12
	autoconf-20031202:1.12
	autoconf-branch:1.12.0.12
	phong-branch:1.12.0.10
	photonmap-branch:1.12.0.8
	rel-6-1-DP:1.12
	windows-branch:1.12.0.6
	rel-6-0-2:1.12
	ansi-branch:1.12.0.4
	rel-6-0-1-branch:1.12.0.2
	hartley-6-0-post:1.12
	hartley-6-0-pre:1.12
	rel-6-0-1:1.12
	rel-6-0:1.12;
locks; strict;
comment	@# @;


1.13
date	2004.05.19.19.18.25;	author morrison;	state dead;
branches;
next	1.12;

1.12
date	2001.10.17.07.45.11;	author morrison;	state Exp;
branches;
next	1.11;

1.11
date	2001.10.04.18.13.46;	author morrison;	state Exp;
branches;
next	1.10;

1.10
date	2001.09.24.22.06.51;	author morrison;	state Exp;
branches;
next	1.9;

1.9
date	2001.09.19.08.24.17;	author morrison;	state Exp;
branches;
next	1.8;

1.8
date	2001.09.10.17.53.27;	author morrison;	state Exp;
branches;
next	1.7;

1.7
date	2001.09.06.00.27.38;	author morrison;	state Exp;
branches;
next	1.6;

1.6
date	2001.09.05.23.08.27;	author morrison;	state Exp;
branches;
next	1.5;

1.5
date	2001.08.31.19.31.06;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2001.08.28.18.43.12;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2001.08.27.17.52.37;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2001.07.31.17.01.32;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2001.07.23.19.43.39;	author morrison;	state Exp;
branches;
next	;


desc
@@


1.13
log
@The old regression test scripts are being replaced by something else.  Likely it'll be Corredor with some unit test framework.  The old scripts are so far out of sync and so inadequate that it's simply not worth it any more.
@
text
@#!/bin/sh
#
# l i b r a r y
#
###
#   this is a general purpose sh utility library providing a set of environment
#   variables and function calls.  the primary intended usage is to aid the
#   brlcad regression testing suite.
#
#   do not copy the routines found here.  instead, include this library into
#   scripts as such:
#
#     . ./library
#
#   listed below are the functions and variables that are provided by sourcing
#   this script.  see the respective function for more details on what 
#   arguments it takes and how the function behaves.
#
###
#
# FUNCTIONS
#
#   log
#       writes output to a given log file
#   plog
#       writes "pretty" output to a given log file in column format
#   bomb
#       writes an error message to the log
#   warn
#       writes a warning message to the log, optionally bombing
#
#   initializeVariable
#       initializes a given variable to a defaultValue if it is not already set
#   setHostName
#       sets a var to the HOSTNAME from a variety of potential methods
#   hostIsAlive
#       returns a boolean whether the given host/ip is alive (answers ping)
#   loadSourceFile
#       loads the requested file and evaluates the contents as script source
#
#   acquireLock
#       creates a cooperative lock file ("blocks" when one already exists)
#   releaseLock
#       releases and/or removes a cooperative lock file (rm's the lock)
#   releaseAllLocks
#       releases all locally acquired locks (via internal _ACQUIRED_LOCKS)
#
#   acquireSemaphore
#       gets a cooperative file semaphore ("blocks" when one does not exist)
#   releaseSemaphore
#       releases and/or creates a cooperative file semaphore (touch's the 
#       semaphore)
#   releaseAllSemaphores
#       releases all locally acquired semaphores (via internal 
#       _ACQUIRED_SEMAPHORES)
#
#   mail
#       mail a file with optional attachments to a user
#   cvsExport
#       perform a cvs export for given source tag
#   unpackArchive
#       unpack an archive in a variety of formats (tar files, tgz, zip, etc)
#
###
#
# GLOBALS
# 
#   LOG
#       output is sent to $LOG, and is /dev/tty by default
#   DEBUG  
#       when non-null defined, extra call details will be sent to $LOG.
#       that means define DEBUG if you're modifying scripts for extra info
#   HOSTNAME
#       the host name derifed from 1) hostname command, 2) HOST env var,
#       3) HOSTNAME env var, 4) default "unknown" value
#   ARCH
#       the complete architecture definition of this client as given by uname
#   LPWD
#       current working directory path where library is included
#
#   STYLE
#       set to color to take advantage of a terminal that supports
#       color output (though ansi escape sequences)
#   SETCOLOR_SUCCESS
#       set output color for a success statement
#   SETCOLOR_FAILURE
#       set output color for a failure statement
#   SETCOLOR_WARNING
#       set output color for a warning statement
#   SETCOLOR_NORMAL
#       set output color for a normal statement
#
#   LIBRARY_VERSION
#       version of this library file being used (majorRelease.minorRelease)
#   
#
# INTERNAL  (do not use)
#
#   _ACQUIRED_LOCKS
#   _ACQUIRED_SEMAPHORES
#   _TEMP_DEBUG_OFF
#
###############################################################################

# version of this library script file
LIBRARY_VERSION=1.0 ; export LIBRARY_VERSION

# have to init LOG here so functions will output properly
# common log defaults include /dev/tty, stdout, or stderr
if [ x$LOG = x ] ; then 
    LOG="stdout" ; export LOG
fi
#
# log [messageToWrite] [fileToWriteTo]
#
# log writes a given message out to a file name
# log should *never* call the inherited warn() or bomb() calls
#
log ( ) {
    __MESSAGE="\$1"
    if [ "x$2" = "x" ] ; then __FILE="$LOG" ; else __FILE="$2" ; fi

    # convert stdout and stderr to the proper redirect
    if [ "x$__FILE" = "xstdout" ] ; then 
	__FILE=""
    elif [ "x$__FILE" = "xstderr" ] ; then 
	__FILE="1>&2"
    else
	__FILE=">> $__FILE"
    fi

    # this is the only call that sends debug after initialization since we want
    # to properly handle a "std???" set LOG var
    if [ x$_TEMP_DEBUG_OFF = x ] ; then
	# for gratuitous logging...
	if [ ! "x$DEBUG" = x ] ; then echo "log( \$1=[$1] \$2=[$2] )" $__FILE ; fi
    fi


    # check for explicit escape option support
    # try to find a decent echo with -e support
    __LOGTEST=`echo -e "\t\ntest"`
    if [ `echo $__LOGTEST | awk '{print $1}'` = "test" ] ; then
	__ECHO="echo -e"
    # no -e support
    else
	# need to do some extra checking since the sun5 /bin/echo sucks
	# see if default echo supports special chars
	__LOGTEST=`echo "\t\ntest"`
	if [ "x`echo $__LOGTEST | awk '{print $1}'`" = "xtest" ] ; then 
	    __ECHO="echo"
	else
	    # for sun5 (built-in echo is poor)
	    __LOGTEST=`/usr/bin/echo "\t\ntest"`
	    if [ "x`echo $__LOGTEST | awk '{print $1}'`" = "xtest" ] ; then
		__ECHO="/usr/bin/echo"
	    else
		echo "WARNING: cannot find decent echo"
		__ECHO="echo"
	    fi
	fi
    fi

# for gratuitous logging...
#    if [ ! x$DEBUG = x ] ; then echo "log: __ECHO=[${__ECHO}] __MESSAGE=[${__MESSAGE}] __FILE=[${__FILE}]" >> $LOG ; fi

    eval "$__ECHO \"$__MESSAGE\" $__FILE"
}
# log the LOG var
if [ ! "x$DEBUG" = "x" ]  ; then log "LOG=$LOG" ; fi

#
# plog [messageToWrite] [fileToWriteTo] [columnWidth] [leadingEdge]
#
# plog "pretty writes" a given message out to a file name
# the columnWidth is the maximum length of a given column, while the
# leading edge is what kind of padding (if any) needs to go on the left
# of each line.
# plog, like log, should *never* call the inherited warn() or bomb() calls
#
plog ( ) {
    if [ "x$2" = "x" ] ; then __FILE="$LOG" ; else __FILE="$2" ; fi
    if [ "x$3" = "x" ] ; then __COLUMN="32000" ; else __COLUMN="$3" ; fi
    __LEAD="$4"

    # this is the only call that sends debug after initialization since we want
    # to properly handle a "std???" set LOG var
    if [ x$_TEMP_DEBUG_OFF = x ] ; then
	# for gratuitous logging...
	if [ ! "x$DEBUG" = x ] ; then echo "plog( \$1=[$1] \$2=[$2] \$3=[$3] \$4=[$4] )" $__FILE ; fi
    fi

    # turn off log debugging
    if [ ! "x$DEBUG" = x ] ; then export _TEMP_DEBUG_OFF=1 ; fi

    __LINE=""
    __POS=0
# !!! some shells will have already expanded $1 -- need better method for handling newlines and the sort
    for __WORD in $1 ; do

# !!! see if all our systems support the -c option to wc since obviating awk will speed this up a little 
# (faster)        __SIZE="`echo $__WORD | wc -c`"

        __NEWLINE=`echo $__WORD | grep '\\\n'`
        if [ ! "x$__NEWLINE" = "x" ] ; then
            __SIZE=`expr -$__POS + -$__COLUMN`
        else
            __SIZE="`echo $__WORD | wc | awk '{print $3}'`"
            # add extra padding for a tab (!!! should convert to spaces)
            if [ ! "x`echo $__WORD | grep '\\\t'`" = "x" ] ; then
                __SIZE=`expr $__SIZE + 7`
            # add an extra space at the end of a sentance
            elif [ ! "x`echo $__WORD | grep '\\.$'`" = "x" ] ; then
                __SIZE=`expr $__SIZE + 1`
                __WORD="$__WORD "
            fi
        fi

        __NEWSIZE=`expr $__POS + $__SIZE + 1`

        if [ $__NEWSIZE -gt $__COLUMN ] ; then
            log "${__LEAD}${__LINE}" "$__FILE"
            __LINE="$__WORD"
            __POS="$__SIZE"
        elif [ $__NEWSIZE -lt 0 ] ; then
            log "${__LEAD}${__LINE} $__WORD" "$__FILE"
            __LINE=""
            __POS=0
        else
            __POS=$__NEWSIZE
            if [ "x$__LINE" = "x" ] ; then
                __LINE="$__WORD"
            else
                __LINE="${__LINE} $__WORD"
            fi
        fi
    done
    log "${__LEAD}${__LINE}" "$__FILE"

    # turn log debugging back on if it was
    if [ ! "x$DEBUG" = x ] ; then unset _TEMP_DEBUG_OFF ; fi

}


#
# bomb [messageToWrite] [fileToWriteTo] [returnCode]
#
# writes a message out via the log facility and then exits returning a given 
# value. if the global _ACQUIRED_LOCKS or _ACQUIRED_SEMAPHORES variables are
# set (done by acquireLock() and acquireSemaphore()), then they are released
# prior to exiting.
#
# by default we write bomb output to stderr instead of stdout
# 
bomb ( ) {
    if [ x$_TEMP_DEBUG_OFF = x ] ; then
        if [ ! "x$DEBUG" = x ] ; then log "bomb( \$1=[$1] \$2=[$2] \$3=[$3] )" ; fi
    fi

    if [ "x$2" = "x" ] ; then __BOMBLOG="$2" ; else __BOMBLOG="$2" ; fi

    # need a check if dollar three is a number...
    if [ "x$3" = "x" ] ; then __CODE=1 ; else __CODE="$3" ; fi

    # turn off log debugging
    if [ ! "x$DEBUG" = x ] ; then export _TEMP_DEBUG_OFF=1 ; fi

    log "ERROR: $1" "$__BOMBLOG"
    # explicitly display the error message to terminal if logging elsewhere
    # !!! may consider switching default behaviour to be stdout instead of terminal
    if [ ! "x$__BOMBLOG" = "x/dev/tty" ] ; then 
	if [ "x$__BOMBLOG" = "x" ] ; then
	    if [ ! "x$LOG" = "x/def/tty" ] ; then
		if [ -w /dev/tty ] ; then
		    log "ERROR: $1" "/dev/tty"
		fi
	    fi
	fi
    fi

    # turn log debugging back on if it was
    if [ ! "x$DEBUG" = x ] ; then unset _TEMP_DEBUG_OFF ; fi

    releaseAllLocks
    releaseAllSemaphores
    
    exit $__CODE
}


#
# warn [messageToWrite] [fileToWriteTo] [noWarnings]
#
# writes a message out via the log facility and optionally will bomb instead of
# simply warn if NO_WARNINGS is set or specified, noWarnings arg overrides 
# (any non-zero value is true)
# 
# by default we write warn output to stderr instead of stdout
#
warn ( ) {
    if [ x$_TEMP_DEBUG_OFF = x ] ; then
        if [ ! "x$DEBUG" = x ] ; then log "warn( \$1=[$1] \$2=[$2] \$3=[$3] )" ; fi
    fi

    if [ "x$2" = "x" ] ; then __WARNLOG="$2" ; else __WARNLOG="$2" ; fi

    # should check if dollar three is a number...
    __BOMB=0
    if [ ! x$NO_WARNINGS = x ] ; then __BOMB=$NO_WARNINGS ; fi
    if [ ! "x$3" = "x" ] ; then __BOMB=1 ; fi

    # turn off log debugging
    if [ ! "x$DEBUG" = x ] ; then export _TEMP_DEBUG_OFF=1 ; fi

    log "WARNING: $1" "$__WARN"
    if [ ! "x$__BOMB" = "x0" ] ; then
	bomb "fail on warnings is set so exiting now"
    fi

    # turn log debugging back on if it was
    if [ ! "x$DEBUG" = x ] ; then unset _TEMP_DEBUG_OFF ; fi
}


#
# initializeVariable variableName [defaultValue]
#
# initializes a variable to a given value unless that variable
# is already defined (e.g. already initialized).  this allows
# script variables to also be overridden by environment variables
#
initializeVariable ( ) {
    if [ ! "x$DEBUG" = "x" ] ; then log "initializeVariable( \$1=[$1] \$2=[$2] )" ; fi

    if [ "x$1" = "x" ] ; then 
	bomb "initializeVariable() arg1 mismatch"
    else 
	__VAR="$1"
    fi
    # do not need to check since may be empty anyways
    __DEF="$2"

    # stupid name to variable translation is a bitch..especially on sun5

    # make sure a value is not already set for the variable being initialized
    __PVAR="echo \$$__VAR"
    if [ x`eval $__PVAR` = x ] ; then
	__CMD="$__VAR=\"$__DEF\""
	eval $__CMD
	export $__VAR
    fi

    if [ ! x$DEBUG = x ] ; then log "initializeVariable: $__VAR=[`eval $__PVAR`]" ; fi
}


#
# setHostName [variable] [defaultValue]
#
# attempts to derive the host name of the running machine.
# precedence is given to the HOSTNAME and HOST environment
# variables, then we try uname.  by default we set to
# the HOSTNAME environment variable
#
setHostName ( ) {
    if [ ! "x$DEBUG" = x ] ; then log "setHostName( \$1=[${1}] \$2=[${2}] )" ; fi

    if [ "x$1" = x ] ; then 
	__VAR="HOSTNAME"
    else 
	__VAR="$1"
	# do not forget to check system
	initializeVariable $__VAR "$HOST"
	if [ x$__VAR = x ] ; then $__VAR=$HOSTNAME ; export $__VAR ; fi
    fi
    if [ "x$2" = x ] ; then __DEFVAL="unknown" ; else __DEFVAL=$2 ; fi

    __VARVAL="echo \$$__VAR"
    if [ ! "x$DEBUG" = x ] ; then log "setHostName: ${__VAR}=[`eval $__VARVAL`]" ; fi

    # multiple inits work (without the ifthen mess) since the set should
    # not clobber a variable that already has a non-empty value set
    if [ x`eval $__VARVAL` = x ] ; then initializeVariable $__VAR `hostname` ; fi
    if [ x`eval $__VARVAL` = x ] ; then initializeVariable $__VAR $HOST ; fi
    if [ x`eval $__VARVAL` = x ] ; then initializeVariable $__VAR `uname -n` ; fi
    if [ x`eval $__VARVAL` = x ] ; then initializeVariable $__VAR $__DEFVAL ; fi
}

#
# hostIsAlive hostOrIP
#
# returns a boolean whether the given host or ip address is "valid" or not.
# a host is considered valid if it is responding to ping requests
#
hostIsAlive ( )  {
    if [ ! "x$DEBUG" = x ] ; then log "hostIsAlive( \$1=[${1} ) " ; fi

    if [ ! "x$1" = "x" ] ; then
        __HOST="$1"
    else 
        bomb "hostIsAlive() arg1 mismatch -- no host was given"
    fi

    if ping -c 2 $__HOST > /dev/null 2>&1 ; then
        return 0
    # handle cads odd location of ping
    elif /usr/etc/ping -c 2 $__HOST > /dev/null 2>&1 ; then
        return 0
    elif `which ping` -c 2 $__HOST > /dev/null 2>&1 ; then
        return 0
    fi

    # fail if we couldn't get a successful ping (after two tries)
    return 1
}


#
# loadResourceFile fileName
#
loadResourceFile ( ) {
    if [ ! "x$DEBUG" = x ] ; then log "loadResourceFile( \$1=[${1} ) " ; fi

    if [ ! "x$1" = "x" ] ; then
        __FILE="$1"
    else 
        bomb "loadResourceFile() arg1 mismatch -- no file was given"
    fi

    if [ ! -f "$__FILE" ] ; then
        warn "Resource file [$__FILE] does not exist"
        return 1
    elif [ ! -r "$__FILE" ] ; then
        warn "Unable to read resource file [$__FILE]"
        return 1
    fi
    
    __RCSRC="`cat $__FILE`"
    eval $__RCSRC

    if [ $? != 0 ] ; then
        warn "Unable to properly load resource file"
        return 1
    fi

    return 0
}


#
# acquireLock [lockName] [retryCount] [waitLength] [location]
#
# will create a file that will block subsequent calls to acquireLock until the 
# file lock is released.  a ".lock" extension is appended automatically to 
# distinguish between file locks and file semaphores.
# locks acquired are listed in the ACQUIRED_LOCKS global var
#
# if file exists then wait/fail
# else create lock file and log
#
acquireLock ( ) {
    if [ ! "x$DEBUG" = x ] ; then log "acquireLock( \$1=[$1] \$2=[$2] \$3=[$3] \$4=[$4] )" ; fi

    if [ "x$1" = x ] ; then __NAME="local" ; else __NAME="${1}" ; fi
    if [ "x$2" = x ] ; then __RETRY=1 ; else __RETRY=$2 ; fi
    if [ "x$3" = x ] ; then __WAIT=0 ; else __WAIT=$3 ; fi
    if [ "x$4" = x ] ; then 
	# if we start with a slash, prefix is nothing (rooted name), otherwise use a relative path
	__SWS=`echo $__NAME | sed 's/^\/.*/___ROOTED_NAME___/'`
	if [ "x$__SWS" = "x___ROOTED_NAME___" ] ; then __PREFIX="" ; else __PREFIX="./" ; fi
    else 
	# if we end with a slash, no worries, otherwise, append one
	__SWS=`echo $__NAME | sed 's/.*\/$/___END_SLASH___/'`
	if [ "x$__SWS" = "x___END_SLASH___" ] ; then __PREFIX="$4" ; else __PREFIX="${4}/" ; fi
    fi
    __LOCK="${__NAME}.lock"

    while [ -f ${__PREFIX}$__LOCK ] ; do
	__RETRY=`expr $__RETRY - 1`
	if [ $__RETRY -lt 1 ] ; then
	    warn "Unable to obtain $__LOCK in $__PREFIX"
            
            if [ ! "x$USER" = "x" ] ; then __USER="$USER" ; unset USER ; fi
            if [ ! "x$PID" = "x" ] ; then __PID="$USER" ; unset PID ; fi
            if [ ! "x$DATE" = "x" ] ; then __DATE="$USER" ; unset DATE ; fi
            loadResourceFile "${__PREFIX}$__LOCK"
            if [ ! "x$USER" = "x" ] ; then
                log "Timed out waiting for ${USER}'s lock held since ${DATE} (pid: $PID)"
            fi
            if [ ! "x$__USER" = "x" ] ; then USER="$__USER" ; unset __USER ; fi
            if [ ! "x$__PID" = "x" ] ; then PID="$__USER" ; unset __PID ; fi
            if [ ! "x$__DATE" = "x" ] ; then DATE="$__USER" ; unset __DATE ; fi
            
	    return 1
	fi
	log "Waiting for $__LOCK ($__WAIT seconds)... $__RETRY attempts remain"
	sleep $__WAIT
    done
    touch ${__PREFIX}$__LOCK
    if [ ! -w ${__PREFIX}$__LOCK ] ; then
        warn "Unable to write to lock file $__LOCK in ${__PREFIX}?"
    fi
    # save details about the acquiring process to the lock file
    if [ ! "x$USER" = "x" ] ; then log "USER=\"$USER\"" "${__PREFIX}$__LOCK" ; else log "USER=\"unknown\"" "${__PREFIX}$__LOCK" ; fi
    log "PID=\"$$\"" "${__PREFIX}$__LOCK"
    log "DATE=\"`date`\"" "${__PREFIX}$__LOCK"
    # keep a list of the acquired locks up to date
    _ACQUIRED_LOCKS="$_ACQUIRED_LOCKS ${__PREFIX}$__NAME" ; export _ACQUIRED_LOCKS
    log "Acquired $__LOCK"

    return 0
}


#
# releaseLock [lockName] [location]
#
# if file exists then remove and try unlog
# else warn and try unlog
#
releaseLock ( ) {
    if [ ! "x$DEBUG" = x ] ; then log "releaseLock( \$1=[$1] \$2=[$2] )" ; fi

    if [ "x$1" = x ] ; then __NAME="local" ; else __NAME="${1}" ; fi
    if [ "x$2" = x ] ; then 
	# if we start with a slash, prefix is nothing (rooted name), otherwise use a relative path
	__SWS=`echo $__NAME | sed 's/^\/.*/___ROOTED_NAME___/'`
	if [ ! "x$DEBUG" = x ] ; then log "releaseLock: __SWS=[$__SWS]" ; fi
	if [ "x$__SWS" = "x___ROOTED_NAME___" ] ; then __PREFIX="" ; else __PREFIX="./" ; fi
    else 
	# if we end with a slash, no worries, otherwise, append one
	__SWS=`echo $__NAME | sed 's/.*\/$/___END_SLASH___/'`
	if [ "x$__SWS" = "x___END_SLASH___" ] ; then __PREFIX="$2" ; else __PREFIX="${2}/" ; fi
    fi
    __LOCK="${__NAME}.lock"

    if [ ! "x$DEBUG" = x ] ; then log "releaseLock: __PREFIX=[$__PREFIX] __LOCK=[$__LOCK]" ; fi

    if [ ! -f "${__PREFIX}$__LOCK" ] ; then
	warn "Lock [$__LOCK] is already released"
	# make sure the lock is not registered 
	if [ ! "x$_ACQUIRED_LOCKS" = "x" ] ; then
	    __NEW_AL=""
	    for __CL in $_ACQUIRED_LOCKS ; do
		if [ ! "x$__CL" = "x${__PREFIX}$__NAME" ] ; then
		    __NEW_AL="$__NEW_AL $__CL"
		fi
	    done
	    _ACQUIRED_LOCKS="$__NEW_AL" ; export _ACQUIRED_LOCKS
	fi
	return 1
    fi
    rm ${__PREFIX}$__LOCK
    # unregister the lock with the _ACQUIRED_LOCKS var
    if [ ! "x$_ACQUIRED_LOCKS" = "x" ] ; then
	__NEW_AL=""
	__FOUND_LOCK=0
	for __CL in $_ACQUIRED_LOCKS ; do
	    if [ "x$__CL" = "x${__PREFIX}$__NAME" ] ; then
		__FOUND_LOCK=1
	    else
		__NEW_AL="$__NEW_AL $__CL"
	    fi
	done
	if [ x$__FOUND_LOCK = x0 ] ; then
	    warn "bad bookkeeping -- _ACQUIRED_LOCKS is missing entry $__NAME"
	fi
	_ACQUIRED_LOCKS="$__NEW_AL" ; export _ACQUIRED_LOCKS
    else
	warn "bad bookkeeping -- _ACQUIRED_LOCKS is empty prior to a release of $__NAME"
    fi
    log "Released $__LOCK"
    return 0
}

#
# releaseAllLocks
#
releaseAllLocks ( ) {
    if [ ! "x$DEBUG" = x ] ; then log "releaseAllLocks() _ACQUIRED_LOCKS=[$_ACQUIRED_LOCKS]" ; fi

    if [ ! "x$_ACQUIRED_LOCKS" = x ] ; then
	for __LOCK in $_ACQUIRED_LOCKS ; do
	    releaseLock $__LOCK
	done
    fi
}

#
# acquireSemaphore [semaphoreName] [retryCount] [waitLength] [location]
#
# if file exists then remove file and log
# else wait/fail
#
acquireSemaphore ( ) {
    if [ ! "x$DEBUG" = x ] ; then log "acquireSemaphore( \$1=[$1] \$2=[$2] \$3=[$3] \$4=[$4] )" ; fi

    if [ "x$1" = x ] ; then __NAME="local" ; else __NAME="${1}" ; fi
    if [ "x$2" = x ] ; then __RETRY=1 ; else __RETRY=$2 ; fi
    if [ "x$3" = x ] ; then __WAIT=0 ; else __WAIT=$3 ; fi
    if [ "x$4" = x ] ; then 
	# if we start with a slash, prefix is nothing (rooted name), otherwise use a relative path
	__SWS=`echo $__NAME | sed 's/^\/.*/___ROOTED_NAME___/'`
	if [ "x$__SWS" = "x___ROOTED_NAME___" ] ; then __PREFIX="" ; else __PREFIX="./" ; fi
    else 
	# if we end with a slash, no worries, otherwise, append one
	__SWS=`echo $__NAME | sed 's/.*\/$/___END_SLASH___/'`
	if [ "x$__SWS" = "x___END_SLASH___" ] ; then __PREFIX="$4" ; else __PREFIX="${4}/" ; fi
    fi
    __SEMAPHORE="${__NAME}.semaphore"

    while [ ! -f ${__PREFIX}$__SEMAPHORE ] ; do
	__RETRY=`expr $__RETRY - 1`
	if [ $__RETRY -lt 1 ] ; then
	    warn "Unable to obtain $__SEMAPHORE in $__PREFIX"
	    return 1
	fi
	log "Waiting for $__SEMAPHORE ($__WAIT seconds)... $__RETRY attempts remain"
	sleep $__WAIT
    done
    # we move instead of delete so that we can tell who has acquired the semaphore
    mv -f "${__PREFIX}${__SEMAPHORE}" "${__PREFIX}${__SEMAPHORE}.acquired"
    if [ ! -w "${__PREFIX}${__SEMAPHORE}.acquired" ] ; then
        warn "Unable to write to acquired semaphore file ${__SEMAPHORE}.acquired in ${__PREFIX}"
    fi    
    # sanity check - make sure file is gone
    if [ -f "${__PREFIX}${__SEMAPHORE}" ] ; then
	warn "Unable to properly remove/acquire semaphore file ${__SEMAPHORE} in ${__PREFIX}"
	return 1
    fi

    if [ ! "x$USER" = "x" ] ; then log "USER=$USER" "${__PREFIX}${__SEMAPHORE}.acquired" ; else log "USER=unknown" "${__PREFIX}${__SEMAPHORE}.acquired" ; fi
    log "PID=$$" "${__PREFIX}${__SEMAPHORE}.acquired"
    log "DATE=`date`" "${__PREFIX}${__SEMAPHORE}.acquired"

    _ACQUIRED_SEMAPHORES="$_ACQUIRED_SEMAPHORES ${__PREFIX}$__NAME" ; export _ACQUIRED_SEMAPHORES
    log "Acquired $__SEMAPHORE"

    return 0
}


#
# releaseSemaphore [semaphoreName]
#
# if file exists then warn and try unlog
# else create file and try unlog
#
releaseSemaphore ( ) {
    if [ ! "x$DEBUG" = x ] ; then log "releaseSemaphore( \$1=[$1] \$2=[$2] )" ; fi

    if [ "x$1" = x ] ; then __NAME="local" ; else __NAME="${1}" ; fi
    if [ "x$2" = x ] ; then 
	# if we start with a slash, prefix is nothing (rooted name), otherwise use a relative path
	__SWS=`echo $__NAME | sed 's/^\/.*/___ROOTED_NAME___/'`
	if [ "x$__SWS" = "x___ROOTED_NAME___" ] ; then __PREFIX="" ; else __PREFIX="./" ; fi
    else 
	# if we end with a slash, no worries, otherwise, append one
	__SWS=`echo $__NAME | sed 's/.*\/$/___END_SLASH___/'`
	if [ "x$__SWS" = "x___END_SLASH___" ] ; then __PREFIX="$2" ; else __PREFIX="${2}/" ; fi
    fi
    __SEMAPHORE="${__NAME}.semaphore"

    if [ -f ${__PREFIX}$__SEMAPHORE ] ; then
	warn "Semaphore [$__SEMAPHORE] is already released"
    fi

    # recreate the semaphore
    touch ${__PREFIX}$__SEMAPHORE

    # get rid of the stale semaphore acquired file.
    # if the file was properly registered, it should have a backup copy
    if [ -f ${__PREFIX}${__SEMAPHORE}.acquired ] ; then
	rm -f ${__PREFIX}${__SEMAPHORE}.acquired
    else
	warn "Acquired semaphore ${__SEMAPHORE}'s backup copy disappeared in $__PREFIX"
    fi

    if [ ! -w ${__PREFIX}$__SEMAPHORE ] ; then
        warn "Unable to write to semaphore file $__SEMAPHORE in ${__PREFIX}?"
    fi
    # save the PID of the process that last released this semaphore
    if [ ! "x$USER" = "x" ] ; then log "USER=$USER" "${__PREFIX}${__SEMAPHORE}" ; else log "USER=unknown" "${__PREFIX}${__SEMAPHORE}" ; fi
    log "PID=$$" "${__PREFIX}${__SEMAPHORE}"
    log "DATE=`date`" "${__PREFIX}${__SEMAPHORE}"

    # unregister the semaphore with the _ACQUIRED_SEMAPHORES var
    if [ ! "x$_ACQUIRED_SEMAPHORES" = "x" ] ; then
	__NEW_AS=""
	__FOUND_SEM=0
	for __SEM in $_ACQUIRED_SEMAPHORES ; do
	    if [ "x$__SEM" = "x${__PREFIX}$__NAME" ] ; then
		__FOUND_SEM=1
	    else
		__NEW_AS="$__NEW_AS $__SEM"
	    fi
	done
	_ACQUIRED_SEMAPHORES="$__NEW_AS" ; export _ACQUIRED_SEMAPHORES

	if [ x$__FOUND_SEM = x0 ] ; then
	    warn "bad bookkeeping -- _ACQUIRED_SEMAPHORES is missing entry $__NAME"
	    log "Created ${__SEMAPHORE}??"
        else
	    log "Released $__SEMAPHORE"
	fi
    else
	log "Created $__SEMAPHORE"
    fi
    return 0
}

#
# releaseAllSemaphores
#
releaseAllSemaphores ( ) {
    if [ ! "x$DEBUG" = x ] ; then log "releaseAllSemaphores() _ACQUIRED_SEMAPHORES=[$_ACQUIRED_SEMAPHORES]" ; fi

    if [ ! "x$_ACQUIRED_SEMAPHORES" = x ] ; then
	for __SEM in $_ACQUIRED_SEMAPHORES ; do
	    releaseSemaphore $__SEM
	done
    fi
}


#
# mail {addressList} [subject] [body] [{attachmentTupleList}]
#
# mailer sends out a mail message with a given subject and given body to an address list
# addressList is required only if USER is not set
# attachmentTupleList is a 2-tuple pair of 'filename' and 'label' that will be attached
#   as a mime text attachment, single quote wrapping and label are both required
#   e.g. $4="'file1' 'label1' 'file2' 'label2' 'file3' 'label3' "
###
mail ( ) {
    if [ ! "x$DEBUG" = "x" ] ; then log "mail( \$1=[$1] \$2=[$2] \$3=[$3] \$4=[$4])" ; fi

    if [ "x$1" = x ] ; then 
	if [ ! "x$USER" = x ] ; then
	    __ADDRESS="$USER"
	else
	    bomb "mail() arg1 mismatch -- no e-mail address given, no USER set"
	fi
    else
	__ADDRESS="$1"
    fi
    if [ "x$2" = x ] ; then __SUBJECT="" ; else __SUBJECT="$2" ; fi
    if [ "x$3" = x ] ; then __BODY="" ; else __BODY="$3" ; fi
    if [ ! "x$4" = x ] ; then __MULTI="yes"; __FILES="$4" ; else __MULTI="no"; __FILES="" ; fi
    # need sendmail to properly give mime types
    for __MAILER in /bin/sendmail /usr/lib/sendmail /usr/bin/sendmail /usr/sbin/sendmail ; do
	if [ -f "$__MAILER" ] && [ -x "$__MAILER" ] ; then
	    break
	fi
    done
    if [ ! -x "${__MAILER}" ] ; then
	warn "Unable to find sendmail -- hoping it is in path"
	__MAILER="sendmail"
    fi
    BOUNDARY="xxxxqwertyxxxx.${HOSTNAME}.$$"

    # find a decent echo (!!! may want to consolidate later with log)
    __LOGTEST=`echo -e "\t\ntest"`
    if [ `echo $__LOGTEST | awk '{print $1}'` = "test" ] ; then
	__ECHO="echo -e"
    # no -e support
    else
	# need to do some extra checking since the sun5 /bin/echo sucks
	# see if default echo supports special chars
	__LOGTEST=`echo "\t\ntest"`
	if [ "x`echo $__LOGTEST | awk '{print $1}'`" = "xtest" ] ; then 
	    __ECHO="echo"
	else
	    # for sun5 (built-in echo is poor)
	    __LOGTEST=`/usr/bin/echo "\t\ntest"`
	    if [ "x`echo $__LOGTEST | awk '{print $1}'`" = "xtest" ] ; then
		__ECHO="/usr/bin/echo"
	    else
		echo "WARNING: cannot find decent echo"
		__ECHO="echo"
	    fi
	fi
    fi
    __BODY=`$__ECHO $__BODY`

    # weed off files that are not readable
    __NEWFILES=""
    __FILEORLABEL="file"
    # set the field separator to a single quote
    __PIFS="$IFS"
    IFS="'"
    for __FILELABEL in $__FILES ; do
	IFS="$__PIFS"  # restore briefly so sed/awk do not screw up
	if [ "x`echo $__FILELABEL | awk '{print $1}'`" = "x" ] ; then continue ; fi

        if [ "x$__FILEORLABEL" = "xfile" ] ; then 
	    __FILE="$__FILELABEL"
	    __FILEORLABEL="label"
	else 
	    __LABEL=$__FILELABEL
	    if [ ! -f "$__FILE" ] ; then
		warn "Unable to read attachment file [$__FILE]"
	    else
		__NEWFILES="$__NEWFILES '$__FILE' '$__LABEL'"
	    fi
	    __FILEORLABEL="file"
	fi
	IFS="'"
    done
    IFS="$__PIFS"  # restore so sed/awk do not screw up
    if [ ! "x$__FILEORLABEL" = "xfile" ] ; then
	warn "Missing attachment file label, using null"
	__NEWFILES="$__NEWFILES ''"
    fi
    __FILES="$__NEWFILES"
    
    # !!! should test validity of mail program existance
    if [ ! "x$DEBUG" = "x" ] ; then log "mail: __MAILER=[$__MAILER] __ADDRESS=[$__ADDRESS] __SUBJECT=[$__SUBJECT] __ATTACHMENTS=[$__MUTLI]\nmail: __FILES=[$__FILES]" ; fi

    # if we weeded off all attachments, then turn off multi
    if [ "x$__FILES" = "x" ] ; then __MULTI="no" ; fi
    # if we have attachments, we need to loop over them and add them properly
    if [ "x$__MULTI" = "xyes" ] ; then
	__ATTACH=""

	__FILEORLABEL="file"
	# set the field separator to a single quote
	__PIFS="$IFS"
	IFS="'"
	for __FILELABEL in $__FILES ; do
	    IFS="$__PIFS"  # restore briefly so sed/awk do not screw up
	    if [ "x`echo $__FILELABEL | awk '{print $1}'`" = "x" ] ; then continue ; fi
	    
	    if [ "x$__FILEORLABEL" = "xfile" ] ; then 
		__FILE="$__FILELABEL"
		__FILEORLABEL="label"
	    else 
		__LABEL=$__FILELABEL
		__FILEORLABEL="file"
		
		# process the file/label pair now
		if [ ! "x$DEBUG" = "x" ] ; then log "Processing attachment: [${__FILE}]" ; fi
		__FILEBASE=`basename "$__FILE"`
		__ATTACH="${__ATTACH}
--${BOUNDARY}
Content-Type: text/plain; charset=US-ASCII; name=\"$__FILEBASE\"
Content-Description: ${__LABEL}
Content-Disposition: attachment; filename=\"$__FILEBASE\"
Content-Transfer-Encoding: 7bit

`cat \"$__FILE\"`
"

	    fi
	    IFS="'"
	done
	IFS="$__PIFS"  # restore field separator (awk chokes otherwise)

	# loop over outgoing address list
	for __ADDR in $__ADDRESS ; do
	    $__MAILER $__ADDR <<EOF
Subject: ${__SUBJECT}
MIME-Version: 1.0
Content-type: multipart/mixed; boundary="${BOUNDARY}"
Content-Transfer-Encoding: 7bit

This message is in MIME format.  The first part should be readable text,
while the remaining parts are likely unreadable without MIME-aware tools.
Send mail to lamas@@arl.army.mil for more info.

--${BOUNDARY}
Content-Type: text/plain; charset=US-ASCII; name="e-mail.body"
Content-Description: ${__SUBJECT}
Content-Disposition: inline; filename="e-mail.body"
Content-Transfer-Encoding: 7bit
${__BODY}


${__ATTACH}

--${BOUNDARY}--
EOF
        done

    # otherwise we are not sending attachments
    else
	# loop over outgoing address list
	for __ADDR in $__ADDRESS ; do
	    $__MAILER $__ADDR <<EOF
Subject: ${__SUBJECT}
MIME-Version: 1.0
Content-Type: text/plain; charset=US-ASCII; name="e-mail.body"
Content-Disposition: inline; filename="e-mail.body"
Content-Transfer-Encoding: 7bit

${__BODY}

EOF
	done
    fi

    # check for failure and log if so
    if [ $? != 0 ] ; then
	log "ERROR: mail failed"
	return 1
    fi
    return 0
}


#
# cvsExport cvsTag cvsRoot [exportDir] [cvsBinary] [cvsLogfile]
#
cvsExport ( ) {
    if [ ! "x$DEBUG" = "x" ] ; then log "cvsExport( \$1=[$1] \$2=[$2] \$3=[$3] \$4=[$4])" ; fi

    if [ "x$1" = x ] ; then 
	if [ ! "x$CVS_TAG" = "x" ] ; then
	    __TAG="$CVS_TAG"
	else
	    bomb "cvsExport() arg1 mismatch -- no cvs tag given, no CVS_TAG set"
	fi
    else
	__TAG="$1"
    fi
    if [ "x$2" = x ] ; then 
	if [ ! "x$CVS_ROOT" = "x" ] ; then
	    __ROOT="$CVS_ROOT"
	else
	    bomb "cvsExport() arg2 mismatch -- no cvs root given, no CVS_ROOT set"
	fi
    else
	__ROOT="$2"
    fi
    if [ "x$3" = "x" ] ; then __DIR="." ; else __DIR="$3" ; fi
    if [ "x$4" = "x" ] ; then __BIN="cvs" ; else __BIN="$4" ; fi
    if [ "x$5" = "x" ] ; then __LOG="/dev/null" ; else __LOG="$5" ; fi

    if [ ! -d "$__DIR" ] ; then 
        warn "cvs export directory [$__DIR] does not exist" "$__LOG"
        log "Creating directory [$__DIR]" "$__LOG"
        mkdir -p "$__DIR"
    fi
    if [ ! -w "${__DIR}/." ] ; then
        log "ERROR: Unable to write to cvs export directory [$__DIR]" "$__LOG"
        return 1
    fi

    $__BIN -v > /dev/null 2>&1
    if [ $? != 0 ] ; then
	log "ERROR: cvs export failed (unable to run cvs [$__CVS])" "$__LOG"
	return 1
    fi

    log "Starting cvs export..." "$__LOG"
    log "Running [$__BIN -q -d $__ROOT export -D today -d $__DIR -N $__TAG >> ${__LOG} 2>&1]" "$__LOG"
    $CVS -q -d $__ROOT export -D today -d $__DIR -N $__TAG >> "$__LOG" 2>&1
    # make sure cvs export exited nicely
    if [ $? != 0 ] ; then 
        log "ERROR: cvs export failed" "${__LOG}"
        return 1
    fi

    log "OK: cvs export completed" "${__LOG}"
    return 0
}


#
# unpackArchive archive [extractDir]
#
# as it is, this function merely bombs on error, but it should return a
# truthvalue as to whether the unpacking succeeded or not and let the
# application handle the result.
unpackArchive ( ) {
    if [ ! "x$DEBUG" = "x" ] ; then log "cvsExport( \$1=[$1] \$2=[$2] )" ; fi

    if [ "x$1" = x ] ; then 
        bomb "unpackArchive() arg1 mismatch -- no archive given"
    else
        __ARCHIVE="$1"
    fi
    if [ "x$2" = "x" ] ; then 
        __SWS=`echo $__ARCHIVE | sed 's/^\/.*/___ROOTED_NAME___/'`
        if [ "x$__SWS" = "x___ROOTED_NAME___" ] ; then __DIR=`dirname $__ARCHIVE` ; else __DIR="./"; fi
    else 
        __DIR="$2"
    fi

    if [ ! -f "$__ARCHIVE" ] ; then
        bomb "Unable to find archive [$__ARCHIVE] for unpacking"
    elif [ ! -r "$__ARCHIVE" ] ; then
        bomb "Unable to read archive [$__ARCHIVE] for unpacking"
    fi

    # !!! this is minimal checking and support for right now
    #  we assume that the uncompressor is available and options are supported
    case "$__ARCHIVE" in
        *.tar )
            tar -C "$__DIR" -xf "$__ARCHIVE" ;;
        *.zip )
            unzip "$__ARCHIVE" ;;
        *.tar.Z )
            uncompress -c "$__ARCHIVE" | tar -C "$__DIR" -x ;;
        *.tar.gz | *.tgz )
            gzip -c -d "$__ARCHIVE" | tar -x -C "$__DIR" ;;
        *.tar.bz2 )
            bunzip2 -c "$__ARCHIVE" | tar -C "$__DIR" -x ;;
        * )
            bomb "Unsupported archive format" ;;
    esac

    if [ $? != 0 ] ; then 
        bomb "Archive unpacking failed"
    fi
}


# INTERNAL STUFF
###
# vars used to manage locks and semaphores
initializeVariable _ACQUIRED_LOCKS 
initializeVariable _ACQUIRED_SEMAPHORES

# GLOBAL STUFF
# set a hostname and pwd to play with -- exports HOSTNAME and LPWD accordingly
setHostName

initializeVariable ARCH "`uname -s`"

case $0 in
    # hard path to sourcing script
    /* )
        initializeVariable LPWD "`dirname $0`" ;;
    # relative path to sourcing script
    */* )
        initializeVariable LPWD "`pwd`/`dirname $0`" ;;
    # sourcing script is in the path
    * )
        initializeVariable LPWD "`pwd`" ;;
esac
if [ ! -f "$LPWD/library" ] ; then
    warn "Unable to properly initialize path to library source varaible [LPWD]"
fi

# set STYLE value to 'color' to invoke color logging output, set to anything
# else to get plain text output
initializeVariable STYLE "color"

# terminal sequence to move to that column. You could change this
# to something like "tput hpa ${RES_COL}" if your terminal supports it
MOVE_TO_COLUMN="echo -en \\033[60G"
# terminal sequence to set color to a 'success' color (currently: green)
SETCOLOR_SUCCESS="echo -en \\033[1;32m"
# terminal sequence to set color to a 'failure' color (currently: red)
SETCOLOR_FAILURE="echo -en \\033[1;31m"
# terminal sequence to set color to a 'warning' color (currently: yellow)
SETCOLOR_WARNING="echo -en \\033[1;33m"
# terminal sequence to reset to the default color.
SETCOLOR_NORMAL="echo -en \\033[0;39m"
@


1.12
log
@*** empty log message ***
@
text
@@


1.11
log
@*** empty log message ***
@
text
@d761 1
d846 1
a846 1
--xxxxqwertyxxxx
d865 1
a865 1
Content-type: multipart/mixed; boundary="xxxxqwertyxxxx"
d872 1
a872 1
--xxxxqwertyxxxx
d882 1
a882 1
--xxxxqwertyxxxx--
@


1.10
log
@Added hostIsAlive() and loadResourceFile() along with proper LPWD searching
LPWD is set up based on whether it was called with hard path, relative path, or from path
@
text
@d46 1
a46 1
#       releases all acquired locks (via internal _ACQUIRED_LOCKS)
d54 9
a62 1
#       releases all acquired semaphores (via internal _ACQUIRED_SEMAPHORES)
d76 2
d92 3
d105 3
d483 12
d504 4
a507 2
    # save the PID of the acquiring process to the lock file
    log "PID: $$" "${__PREFIX}$__LOCK"
d632 5
a636 1
    log "HOLDING PID: $$" "${__PREFIX}${__SEMAPHORE}.acquired"
d672 3
a674 2
    # get rid of the stale semaphore acquired file
    if [ ! -f ${__PREFIX}${__SEMAPHORE}.acquired ] ; then
d676 2
a678 4
	    # if the file was properly registered, it should have a backup copy
	    if [ ! -f ${__PREFIX}${__SEMAPHORE}.acquired ] ; then
		warn "Acquired semaphore ${__SEMAPHORE}'s backup copy disappeared in $__PREFIX"
	    fi
d684 3
a686 1
    log "RELEASEOR PID: $$" "${__PREFIX}${__SEMAPHORE}"
d910 109
d1028 2
@


1.9
log
@added attachment capability to mail function and added ansi sequences for initial color output
also added pretty logger for formatted logging (columnular left-justified)
@
text
@a22 5
#   initializeVariable
#       initializes a given variable to a defaultValue if it is not already set
#   setHostName
#       sets a var to the HOSTNAME from a variety of potential methods
#
d32 9
d321 1
a321 1
	bomb "initializeVariable arg1 mismatch"
d375 61
d708 1
a708 1
	    bomb "mail: arg1 mismatch -- no e-mail address given, no USER set"
d841 1
a842 1
${__BODY}
d884 15
a898 1
initializeVariable LPWD `pwd`
@


1.8
log
@broke up export lines so sun bin/sh would stop bitching
@
text
@d30 2
d59 1
a59 1
#       when defined, extra call details will be sent to $LOG.
d67 13
d100 2
a101 2
    MESSAGE="\$1"
    if [ "x$2" = "x" ] ; then FILE="$LOG" ; else FILE="$2" ; fi
d104 4
a107 4
    if [ "x$FILE" = "xstdout" ] ; then 
	FILE=""
    elif [ "x$FILE" = "xstderr" ] ; then 
	FILE="1>&2"
d109 1
a109 1
	FILE=">> $FILE"
d116 1
a116 1
	if [ ! "x$DEBUG" = x ] ; then echo "log( \$1=[$1] \$2=[$2] )" $FILE ; fi
d122 3
a124 4
    LOGTEST=`echo -e "\t\ntest"`
    if [ `echo $LOGTEST | awk '{print $1}'` = "test" ] ; then
	ECHO="echo -e"

d129 3
a131 3
	LOGTEST=`echo "\t\ntest"`
	if [ "x`echo $LOGTEST | awk '{print $1}'`" = "xtest" ] ; then 
	    ECHO="echo"
d134 3
a136 3
	    LOGTEST=`/usr/bin/echo "\t\ntest"`
	    if [ "x`echo $LOGTEST | awk '{print $1}'`" = "xtest" ] ; then
		ECHO="/usr/bin/echo"
d139 1
a139 1
		ECHO="echo"
d145 1
a145 1
#    if [ ! x$DEBUG = x ] ; then echo "log: ECHO=[${ECHO}] MESSAGE=[${MESSAGE}] FILE=[${FILE}]" >> $LOG ; fi
d147 1
a147 4
#    OUTPUT="$ECHO \"$MESSAGE\""
#    eval "$OUTPUT >> $FILE"
#    eval "$ECHO \"$MESSAGE\" >> $FILE"
    eval "$ECHO \"$MESSAGE\" $FILE"
d152 73
d241 1
a241 1
    if [ "x$2" = "x" ] ; then BOMBLOG="$2" ; else BOMBLOG="$2" ; fi
d244 1
a244 1
    if [ "x$3" = "x" ] ; then CODE=1 ; else CODE="$3" ; fi
d249 1
a249 1
    log "ERROR: $1" "$BOMBLOG"
d252 2
a253 2
    if [ ! "x$BOMBLOG" = "x/dev/tty" ] ; then 
	if [ "x$BOMBLOG" = "x" ] ; then
d268 1
a268 1
    exit $CODE
d286 1
a286 1
    if [ "x$2" = "x" ] ; then WARNLOG="$2" ; else WARNLOG="$2" ; fi
d289 3
a291 3
    BOMB=0
    if [ ! x$NO_WARNINGS = x ] ; then BOMB=$NO_WARNINGS ; fi
    if [ ! "x$3" = "x" ] ; then BOMB=1 ; fi
d296 2
a297 2
    log "WARNING: $1" "$WARN"
    if [ ! "x$BOMB" = "x0" ] ; then
d319 1
a319 1
	VAR="$1"
d322 1
a322 1
    DEF="$2"
d327 5
a331 5
    PVAR="echo \$$VAR"
    if [ x`eval $PVAR` = x ] ; then
	CMD="$VAR=\"$DEF\""
	eval $CMD
	export $VAR
d334 1
a334 1
    if [ ! x$DEBUG = x ] ; then log "initializeVariable: $VAR=[`eval $PVAR`]" ; fi
d350 1
a350 1
	VAR="HOSTNAME"
d352 1
a352 1
	VAR="$1"
d354 2
a355 2
	initializeVariable $VAR "$HOST"
	if [ x$VAR = x ] ; then $VAR=$HOSTNAME ; export $VAR ; fi
d357 1
a357 1
    if [ "x$2" = x ] ; then DEFVAL="unknown" ; else DEFVAL=$2 ; fi
d359 2
a360 2
    VARVAL="echo \$$VAR"
    if [ ! "x$DEBUG" = x ] ; then log "setHostName: ${VAR}=[`eval $VARVAL`]" ; fi
d364 4
a367 4
    if [ x`eval $VARVAL` = x ] ; then initializeVariable $VAR `hostname` ; fi
    if [ x`eval $VARVAL` = x ] ; then initializeVariable $VAR $HOST ; fi
    if [ x`eval $VARVAL` = x ] ; then initializeVariable $VAR `uname -n` ; fi
    if [ x`eval $VARVAL` = x ] ; then initializeVariable $VAR $DEFVAL ; fi
d384 3
a386 3
    if [ "x$1" = x ] ; then NAME="local" ; else NAME="${1}" ; fi
    if [ "x$2" = x ] ; then RETRY=1 ; else RETRY=$2 ; fi
    if [ "x$3" = x ] ; then WAIT=0 ; else WAIT=$3 ; fi
d389 2
a390 2
	SWS=`echo $NAME | sed 's/^\/.*/___ROOTED_NAME___/'`
	if [ "x$SWS" = "x___ROOTED_NAME___" ] ; then PREFIX="" ; else PREFIX="./" ; fi
d393 2
a394 2
	SWS=`echo $NAME | sed 's/.*\/$/___END_SLASH___/'`
	if [ "x$SWS" = "x___END_SLASH___" ] ; then PREFIX="$4" ; else PREFIX="${4}/" ; fi
d396 1
a396 1
    LOCK="${NAME}.lock"
d398 4
a401 4
    while [ -f ${PREFIX}$LOCK ] ; do
	RETRY=`expr $RETRY - 1`
	if [ $RETRY -lt 1 ] ; then
	    warn "Unable to obtain $LOCK in $PREFIX"
d404 2
a405 2
	log "Waiting for $LOCK ($WAIT seconds)... $RETRY attempts remain"
	sleep $WAIT
d407 3
a409 3
    touch ${PREFIX}$LOCK
    if [ ! -w ${PREFIX}$LOCK ] ; then
        warn "Unable to write to lock file $LOCK in ${PREFIX}?"
d412 1
a412 1
    log "PID: $$" "${PREFIX}$LOCK"
d414 2
a415 2
    _ACQUIRED_LOCKS="$_ACQUIRED_LOCKS ${PREFIX}$NAME" ; export _ACQUIRED_LOCKS
    log "Acquired $LOCK"
d430 1
a430 1
    if [ "x$1" = x ] ; then NAME="local" ; else NAME="${1}" ; fi
d433 3
a435 3
	SWS=`echo $NAME | sed 's/^\/.*/___ROOTED_NAME___/'`
	if [ ! "x$DEBUG" = x ] ; then log "releaseLock: SWS=[$SWS]" ; fi
	if [ "x$SWS" = "x___ROOTED_NAME___" ] ; then PREFIX="" ; else PREFIX="./" ; fi
d438 2
a439 2
	SWS=`echo $NAME | sed 's/.*\/$/___END_SLASH___/'`
	if [ "x$SWS" = "x___END_SLASH___" ] ; then PREFIX="$2" ; else PREFIX="${2}/" ; fi
d441 1
a441 1
    LOCK="${NAME}.lock"
d443 1
a443 1
    if [ ! "x$DEBUG" = x ] ; then log "releaseLock: PREFIX=[$PREFIX] LOCK=[$LOCK]" ; fi
d445 2
a446 2
    if [ ! -f "${PREFIX}$LOCK" ] ; then
	warn "Lock [$LOCK] is already released"
d449 4
a452 4
	    NEW_AL=""
	    for CL in $_ACQUIRED_LOCKS ; do
		if [ ! "x$CL" = "x${PREFIX}$NAME" ] ; then
		    NEW_AL="$NEW_AL $CL"
d455 1
a455 1
	    _ACQUIRED_LOCKS="$NEW_AL" ; export _ACQUIRED_LOCKS
d459 1
a459 1
    rm ${PREFIX}$LOCK
d462 5
a466 5
	NEW_AL=""
	FOUND_LOCK=0
	for CL in $_ACQUIRED_LOCKS ; do
	    if [ "x$CL" = "x${PREFIX}$NAME" ] ; then
		FOUND_LOCK=1
d468 1
a468 1
		NEW_AL="$NEW_AL $CL"
d471 2
a472 2
	if [ x$FOUND_LOCK = x0 ] ; then
	    warn "bad bookkeeping -- _ACQUIRED_LOCKS is missing entry $NAME"
d474 1
a474 1
	_ACQUIRED_LOCKS="$NEW_AL" ; export _ACQUIRED_LOCKS
d476 1
a476 1
	warn "bad bookkeeping -- _ACQUIRED_LOCKS is empty prior to a release of $NAME"
d478 1
a478 1
    log "Released $LOCK"
d489 2
a490 2
	for LOCK in $_ACQUIRED_LOCKS ; do
	    releaseLock $LOCK
d504 3
a506 3
    if [ "x$1" = x ] ; then NAME="local" ; else NAME="${1}" ; fi
    if [ "x$2" = x ] ; then RETRY=1 ; else RETRY=$2 ; fi
    if [ "x$3" = x ] ; then WAIT=0 ; else WAIT=$3 ; fi
d509 2
a510 2
	SWS=`echo $NAME | sed 's/^\/.*/___ROOTED_NAME___/'`
	if [ "x$SWS" = "x___ROOTED_NAME___" ] ; then PREFIX="" ; else PREFIX="./" ; fi
d513 2
a514 2
	SWS=`echo $NAME | sed 's/.*\/$/___END_SLASH___/'`
	if [ "x$SWS" = "x___END_SLASH___" ] ; then PREFIX="$4" ; else PREFIX="${4}/" ; fi
d516 1
a516 1
    SEMAPHORE="${NAME}.semaphore"
d518 4
a521 4
    while [ ! -f ${PREFIX}$SEMAPHORE ] ; do
	RETRY=`expr $RETRY - 1`
	if [ $RETRY -lt 1 ] ; then
	    warn "Unable to obtain $SEMAPHORE in $PREFIX"
d524 2
a525 2
	log "Waiting for $SEMAPHORE ($WAIT seconds)... $RETRY attempts remain"
	sleep $WAIT
d528 3
a530 3
    cp -f "${PREFIX}${SEMAPHORE}" "${PREFIX}${SEMAPHORE}.acquired"
    if [ ! -w ${PREFIX}${SEMAPHORE} ] ; then
        warn "Unable to write to semaphore file $SEMAPHORE in ${PREFIX}?"
d532 8
a539 3
    log "HOLDING PID: $$" "${PREFIX}${SEMAPHORE}.acquired"
    _ACQUIRED_SEMAPHORES="$_ACQUIRED_SEMAPHORES ${PREFIX}$NAME" ; export _ACQUIRED_SEMAPHORES
    log "Acquired $SEMAPHORE"
d554 1
a554 1
    if [ "x$1" = x ] ; then NAME="local" ; else NAME="${1}" ; fi
d557 2
a558 2
	SWS=`echo $NAME | sed 's/^\/.*/___ROOTED_NAME___/'`
	if [ "x$SWS" = "x___ROOTED_NAME___" ] ; then PREFIX="" ; else PREFIX="./" ; fi
d561 2
a562 2
	SWS=`echo $NAME | sed 's/.*\/$/___END_SLASH___/'`
	if [ "x$SWS" = "x___END_SLASH___" ] ; then PREFIX="$2" ; else PREFIX="${2}/" ; fi
d564 1
a564 1
    SEMAPHORE="${NAME}.semaphore"
d566 2
a567 2
    if [ -f ${PREFIX}$SEMAPHORE ] ; then
	warn "Semaphore [$SEMAPHORE] is already released"
d570 11
a580 2
    # recreate the semaphore and remove the .acquired copy
    touch ${PREFIX}$SEMAPHORE
d582 2
a583 2
    if [ ! -w ${PREFIX}$SEMAPHORE ] ; then
        warn "Unable to write to semaphore file $SEMAPHORE in ${PREFIX}?"
d586 2
a587 1
    log "RELEASEOR PID: $$" "${PREFIX}${SEMAPHORE}"
d590 5
a594 5
	NEW_AS=""
	FOUND_SEM=0
	for SEM in $_ACQUIRED_SEMAPHORES ; do
	    if [ "x$SEM" = "x${PREFIX}$NAME" ] ; then
		FOUND_SEM=1
d596 1
a596 1
		NEW_AS="$NEW_AS $SEM"
d599 1
a599 1
	_ACQUIRED_SEMAPHORES="$NEW_AS" ; export _ACQUIRED_SEMAPHORES
d601 5
a605 10
	if [ x$FOUND_SEM = x0 ] ; then
	    warn "bad bookkeeping -- _ACQUIRED_SEMAPHORES is missing entry $NAME"
	else
	    # if the file was properly registered, it should have a backup copy
	    if [ ! -f ${PREFIX}${SEMAPHORE}.acquired ] ; then
		warn "Acquired semaphore ${SEMAPHORE}'s backup copy disappeared in $PREFIX"
	    fi
	fi
	if [ ! -f ${PREFIX}${SEMAPHORE}.acquired ] ; then
	    rm ${PREFIX}${SEMAPHORE}.acquired
a606 1
	log "Released $SEMAPHORE"
d608 1
a608 1
	log "Created $SEMAPHORE"
d620 2
a621 2
	for SEM in $_ACQUIRED_SEMAPHORES ; do
	    releaseSemaphore $SEM
d628 1
a628 1
# mail {addressList} [subject] [body] [{attachmentList}]
d632 3
d641 1
a641 1
	    ADDRESS="$USER"
d643 1
a643 2
	    log "mail: arg1 mismatch -- no e-mail address given, no USER set"
	    exit
d646 1
a646 1
	ADDRESS="$1"
d648 33
a680 8
    if [ "x$2" = x ] ; then SUBJECT="" ; else SUBJECT="$2" ; fi
    if [ "x$3" = x ] ; then BODY="" ; else BODY=`echo $3` ; fi
    if [ ! "x$4" = x ] ; then MULTI="yes"; FILES="$4" ; else MULTI="no"; FILES="" ; fi
    if [ "x$MAILER" = x ] ; then 
	MAILER=""
	for MAILER in /bin/sendmail /usr/bin/sendmail /usr/lib/sendmail /bin/mail /usr/bin/mail ; do
	    if [ -f $MAILER ] && [ -x $MAILER ] ; then
		break
d682 1
a682 1
	done
d684 1
d686 31
a716 2
    if [ ! "x$DEBUG" = "x" ] ; then log "mail: MAILER=[$MAILER] ADDRESS=[$ADDRESS] SUBJECT=[$SUBJECT] ATTACHMENTS=[$MUTLI]" ; fi

d718 1
d720 5
a724 1
    MAILRUN="$MAILER -s \"$SUBJECT\" $ADDRESS"
d726 23
a748 10
    # if we have attachments, we need to loop over them and add them properly
    if [ "x$MULTI" = "xyes" ] ; then
	ATTACH=""
        for FILE in $FILES ; do
echo "Processing: $FILE"
	    if [ -f $FILE ] ; then
		ATTACH="$ATTACH
--xxxx
Content-Type: text/plain; charset=US-ASCII; name=\"`basename $FILE`\"
Content-Disposition: attachment; filename=\"`basename $FILE`\"
d751 1
a751 1
`cat $FILE`
d753 1
d755 1
d757 1
d759 4
a762 3

	$MAILER $ADDRESS <<EOF
Subject: $SUBJECT
d764 1
a764 1
Content-type: multipart/mixed; boundary=\"xxxx\"
d767 8
a774 3
--xxxx
Content-Type: text/plain; charset=US-ASCII; name=\"main_body\"
Content-Disposition: inline; filename=\"main_body\"
d777 1
a777 1
$BODY
d779 1
a779 1
$ATTACH
d781 1
d783 1
a783 2

echo "[[$MAILER $ADDRESS]]"
d787 7
a793 4
	$MAILER $ADDRESS <<EOF
Subject: ${SUBJECT}
Content-Type: text/plain; charset=US-ASCII; name="body"
Content-Disposition: inline; filename="body"
d796 1
a796 1
${BODY}
d799 1
d802 1
d805 1
d807 1
d820 16
@


1.7
log
@updated client_wait to use new lib
@
text
@d271 1
a271 1
	if [ x$VAR = x ] ; then export $VAR=$HOSTNAME ; fi
d330 1
a330 1
    export _ACQUIRED_LOCKS="$_ACQUIRED_LOCKS ${PREFIX}$NAME"
d371 1
a371 1
	    export _ACQUIRED_LOCKS="$NEW_AL"
d390 1
a390 1
	export _ACQUIRED_LOCKS="$NEW_AL"
d449 1
a449 1
    export _ACQUIRED_SEMAPHORES="$_ACQUIRED_SEMAPHORES ${PREFIX}$NAME"
d500 1
a500 1
	export _ACQUIRED_SEMAPHORES="$NEW_AS"
d535 1
a535 1
# mail {addressList} [subject] [body]
d541 1
a541 1
    if [ ! "x$DEBUG" = "x" ] ; then log "mail( \$1=[$1] \$2=[$2] \$3=[$3] )" ; fi
d555 1
d558 1
a558 1
	for MAILER in /bin/mail /usr/bin/mail ; do
d565 1
a565 1
    if [ ! "x$DEBUG" = "x" ] ; then log "mail: MAILER=[$MAILER] ADDRESS=[$ADDRESS] SUBJECT=[$SUBJECT]" ; fi
d570 48
a617 3
    
    $MAILER -s "$SUBJECT" $ADDRESS <<EOF
$BODY 
d619 1
@


1.6
log
@finished merging the "new" library (with proper file locks and semaphores, stdout/stderr logging facilities, etc)
updated master.sh to use the new lib
@
text
@a261 2
# returns the host name set
#
a283 3

    # return value is only useful if DEBUG is off (since echo'd values are return values)
    if [ "x$DEBUG" = "x" ] ; then return "$VARVAL" ; fi
@


1.5
log
@removed "local" references since trad. bourne shell doesn't support scoping
@
text
@d74 1
d76 1
a76 1
    LOG="/dev/tty" ; export LOG
a77 1
if [ ! "x$DEBUG" = "x" ]  ; then echo "LOG=$LOG" ; fi
d101 1
a101 1
	if [ ! "x$DEBUG" = x ] ; then echo "log( \$1=[$1] \$2=[$2] )" ; fi
d138 2
d149 2
d157 2
d165 1
a165 1
    log "ERROR: $1" "$2"
d167 7
a173 4
    if [ ! "x$2" = "x/dev/tty" ] ; then 
	if [ "x$2" = "x" ] ; then 
	    if [ ! "x$LOG" = "x/dev/tty" ] ; then
		log "ERROR: $1" "/dev/tty"
d195 2
d202 2
d212 1
a212 1
    log "WARNING: $1" "$2"
d214 1
a214 1
	bomb "fail on warnings is set"
d270 1
a270 1
	VAR=$1
d277 3
d282 4
a285 7
    if [ x$VAR = x ] ; then initializeVariable $VAR `hostname` ; fi
    if [ x$VAR = x ] ; then initializeVariable $VAR $HOST ; fi
    if [ x$VAR = x ] ; then initializeVariable $VAR `uname -n` ; fi
    if [ x$VAR = x ] ; then initializeVariable $VAR $DEFVAL ; fi

    VARVAL="echo \$$VAR"
    if [ ! "x$DEBUG" = x ] ; then log "setHostName: ${VAR}=[`eval $VARVAL`]" ; fi
d288 1
a288 1
    # return `eval $VARVAL`
d299 3
d322 1
a322 1
	    log "ERROR: Unable to obtain $LOCK in $PREFIX"
d325 1
a325 1
	log "Waiting for $LOCK... $RETRY attempts remain"
d329 3
d345 3
d393 1
a393 1
	    bomb "bad bookkeeping -- _ACQUIRED_LOCKS is missing entry $NAME"
d397 1
a397 1
	bomb "bad bookkeeping -- _ACQUIRED_LOCKS is empty prior to a release"
d419 3
d442 1
a442 1
	    log "Unable to obtain $SEMAPHORE in $PREFIX"
d445 1
a445 1
	log "Waiting for $SEMAPHORE... $RETRY attempts remain"
d450 3
d464 3
a483 11
	# make sure the semaphore is not registered 
	if [ ! "x$_ACQUIRED_SEMAPHORES" = "x" ] ; then
	    NEW_AS=""
	    for SEM in $_ACQUIRED_SEMAPHORES ; do
		if [ ! "x$SEM" = "x${PREFIX}$NAME" ] ; then
		    NEW_AS="$NEW_AS $SEM"
		fi
	    done
	    export _ACQUIRED_SEMAPHORES="$NEW_AS"
	fi
	return 1
d485 2
d488 4
d493 1
a493 1
    log "CREATOR PID: $$" "${PREFIX}${SEMAPHORE}"
d505 2
d508 9
a516 1
	    bomb "bad bookkeeping -- _ACQUIRED_SEMAPHORES is missing entry $NAME"
d518 1
a518 1
	export _ACQUIRED_SEMAPHORES="$NEW_AS"
d520 1
a520 1
	bomb "bad bookkeeping -- _ACQUIRED_SEMAPHORES is empty prior to release"
a521 1
    log "Released $SEMAPHORE"
@


1.4
log
@new and improved library with bombing, warnings, better locking, and improved semaphores (including mechanisms to remove all semaphores/locks).
@
text
@d154 1
a154 1
    if [ "x$3" = "x" ] ; then local CODE=1 ; else local CODE="$3" ; fi
d192 1
a192 1
    local BOMB=0
d255 1
a255 1
	local VAR="HOSTNAME"
d257 1
a257 1
	local VAR=$1
d262 1
a262 1
    if [ "x$2" = x ] ; then local DEFVAL="unknown" ; else local DEFVAL=$2 ; fi
d271 1
a271 1
    local VARVAL="echo \$$VAR"
d289 3
a291 3
    if [ "x$1" = x ] ; then local NAME="local" ; else local NAME="${1}" ; fi
    if [ "x$2" = x ] ; then local RETRY=1 ; else local RETRY=$2 ; fi
    if [ "x$3" = x ] ; then local WAIT=0 ; else local WAIT=$3 ; fi
d294 2
a295 2
	local SWS=`echo $NAME | sed 's/^\/.*/___ROOTED_NAME___/'`
	if [ "x$SWS" = "x___ROOTED_NAME___" ] ; then local PREFIX="" ; else local PREFIX="./" ; fi
d298 2
a299 2
	local SWS=`echo $NAME | sed 's/.*\/$/___END_SLASH___/'`
	if [ "x$SWS" = "x___END_SLASH___" ] ; then local PREFIX="$4" ; else local PREFIX="${4}/" ; fi
d301 1
a301 1
    local LOCK="${NAME}.lock"
d329 1
a329 1
    if [ "x$1" = x ] ; then local NAME="local" ; else local NAME="${1}" ; fi
d332 1
a332 1
	local SWS=`echo $NAME | sed 's/^\/.*/___ROOTED_NAME___/'`
d334 1
a334 1
	if [ "x$SWS" = "x___ROOTED_NAME___" ] ; then local PREFIX="" ; else local PREFIX="./" ; fi
d337 2
a338 2
	local SWS=`echo $NAME | sed 's/.*\/$/___END_SLASH___/'`
	if [ "x$SWS" = "x___END_SLASH___" ] ; then local PREFIX="$2" ; else local PREFIX="${2}/" ; fi
d340 1
a340 1
    local LOCK="${NAME}.lock"
d348 1
a348 1
	    local NEW_AL
d361 2
a362 2
	local NEW_AL
	local FOUND_LOCK=0
d400 3
a402 3
    if [ "x$1" = x ] ; then local NAME="local" ; else local NAME="${1}" ; fi
    if [ "x$2" = x ] ; then local RETRY=1 ; else local RETRY=$2 ; fi
    if [ "x$3" = x ] ; then local WAIT=0 ; else local WAIT=$3 ; fi
d405 2
a406 2
	local SWS=`echo $NAME | sed 's/^\/.*/___ROOTED_NAME___/'`
	if [ "x$SWS" = "x___ROOTED_NAME___" ] ; then local PREFIX="" ; else local PREFIX="./" ; fi
d409 2
a410 2
	local SWS=`echo $NAME | sed 's/.*\/$/___END_SLASH___/'`
	if [ "x$SWS" = "x___END_SLASH___" ] ; then local PREFIX="$4" ; else local PREFIX="${4}/" ; fi
d412 1
a412 1
    local SEMAPHORE="${NAME}.semaphore"
d439 1
a439 1
    if [ "x$1" = x ] ; then local NAME="local" ; else local NAME="${1}" ; fi
d442 2
a443 2
	local SWS=`echo $NAME | sed 's/^\/.*/___ROOTED_NAME___/'`
	if [ "x$SWS" = "x___ROOTED_NAME___" ] ; then local PREFIX="" ; else local PREFIX="./" ; fi
d446 2
a447 2
	local SWS=`echo $NAME | sed 's/.*\/$/___END_SLASH___/'`
	if [ "x$SWS" = "x___END_SLASH___" ] ; then local PREFIX="$2" ; else local PREFIX="${2}/" ; fi
d449 1
a449 1
    local SEMAPHORE="${NAME}.semaphore"
d455 1
a455 1
	    local NEW_AS
d470 2
a471 2
	local NEW_AS
	local FOUND_SEM=0
@


1.3
log
@*** empty log message ***
@
text
@d3 4
a6 2
# library
#   is a general purpose sh utility library providing a set of environment
d10 9
d25 1
a25 1
#   getHostName
d27 1
d30 5
d36 1
a36 1
#       gets a file semaphore (!!! needs to be changed)
d38 4
a41 1
#       releases and creates a file semaphore that may be acquired
d43 1
a43 1
#       !!!
d45 4
a48 1
#       !!!
d62 1
a62 1
#   PWD
d65 6
d77 1
a77 1
if [ ! x$DEBUG = x ]  ; then echo "LOG=$LOG" ; fi
d82 1
a84 3
# for gratuitous logging...
#    if [ ! x$DEBUG = x ] ; then echo "log( \$1=[$1] \$2=[$2] )" >> $LOG ; fi

d88 17
d112 1
a112 1
    else 
d135 71
a205 1
    eval "$ECHO \"$MESSAGE\" >> $FILE"
d217 1
a217 1
    if [ ! x$DEBUG = x ] ; then log "initializeVariable( \$1=[$1] \$2=[$2] )" ; fi
d219 2
a220 3
    if [ x$1 = x ] ; then 
	log "initializeVariable: arg1 mismatch -- no variable name given"
	exit 
d242 1
a242 1
# getHostName [variable] [defaultValue]
d251 2
a252 2
getHostName ( ) {
    if [ ! x$DEBUG = x ] ; then log "getHostName( \$1=[${1}] \$2=[${2}] )" ; fi
d254 2
a255 2
    if [ x$1 = x ] ; then 
	VAR="HOSTNAME"
d257 1
a257 1
	VAR="$1"
d260 1
a260 1
	if [ x$VAR = x ] ; then export $VAR="$HOSTNAME" ; fi
d262 1
a262 1
    if [ x$2 = x ] ; then DEFVAL="unknown" ; else DEFVAL="$2" ; fi
d266 4
a269 4
    if [ ! x$VAR = x ] ; then initializeVariable $VAR `hostname` ; fi
    if [ ! x$VAR = x ] ; then initializeVariable $VAR $HOST ; fi
    if [ ! x$VAR = x ] ; then initializeVariable $VAR `uname -n` ; fi
    if [ ! x$VAR = x ] ; then initializeVariable $VAR $DEFVAL ; fi
d271 2
a272 2
    VARVAL="echo \$$VAR"
    if [ ! x$DEBUG = x ] ; then log "getHostName: ${VAR}=[`eval $VARVAL`]" ; fi
a277 1

d279 6
a284 1
# acquireLock [lockFile] [retryCount] [waitLength]
d287 1
a287 1
    if [ ! x$DEBUG = x ] ; then log "acquireLock( \$1=[$1] \$2=[$2] \$3=[$3] )" ; fi
d289 13
a301 3
    if [ x$1 = x ] ; then LOCK="local.lock" ; else LOCK="$1" ; fi
    if [ x$2 = x ] ; then RETRY="1" ; else RETRY="$2" ; fi
    if [ x$3 = x ] ; then WAIT="0" ; else WAIT="$3" ; fi
d303 1
a303 1
    while [ ! -f $LOCK ] ; do
d306 1
a306 1
	    log "ERROR: Unable to obtain $LOCK"
d312 5
a316 1
    rm $LOCK
d324 1
a324 1
# releaseLock [lockFile]
d327 14
a340 1
    if [ ! x$DEBUG = x ] ; then log "releaseLock( \$1=[$1] )" ; fi
d342 14
a355 3
    if [ x$1 = x ] ; then LOCK="local.lock" ; else LOCK="$1" ; fi
    if [ -f $LOCK ] ; then
	log "WARNING: Lock [$LOCK] is already released"
d358 19
a376 1
    touch $LOCK
d382 123
d511 1
a511 1
    if [ ! x$DEBUG = x ] ; then log "mail( \$1=[$1] \$2=[$2] \$3=[$3] )" ; fi
d534 1
a534 1
    if [ ! x$DEBUG = x ] ; then log "mail: MAILER=[$MAILER] ADDRESS=[$ADDRESS] SUBJECT=[$SUBJECT]" ; fi
d549 6
d556 3
a558 3
# get a hostname and pwd to play with -- exports HOSTNAME and PWD accordingly
getHostName
initializeVariable PWD `pwd`
@


1.2
log
@updates to client scripts so sun5 will work properly
added status.sh to verify builds and e-mail results of tests available
@
text
@d228 1
a228 1
    if [ "x$3" = x ] ; then BODY="" ; else BODY=`echo -e $3` ; fi
@


1.1
log
@rebuild of the regression test suite

master.sh now uses a new utility library
client.sh was broken into different stage files with inidividual post-build tests in the tests.d directory
client scripts will be updated again later to conform more robustly with new testing architecture
@
text
@d46 1
a46 1
    export LOG=/dev/tty
d54 1
a54 1
function log {
d56 1
a56 1
    if [ ! x$DEBUG = x ] ; then echo "log( \$1=[$1] \$2=[$2] )" >> $LOG ; fi
d58 2
a59 2
    local MESSAGE="\$1"
    if [ "x$2" = "x" ] ; then local FILE=$LOG ; else local FILE="$2" ; fi
d62 24
a85 2
    local LOGTEST=`echo "\t\ntest"`
    if [ "x$LOGTEST" = "x\\t\\ntest" ] ; then local ECHO="echo -e" ; else local ECHO="echo" ; fi
d102 1
a102 1
function initializeVariable {
d106 1
a106 1
	log "initializeVariable arg1 mismatch"
d109 1
a109 1
	local VAR=$1 
d112 1
a112 1
    local DEF=$2
d114 4
a117 2
    # stupid name to variable translation was a bitch..
    local PVAR="echo \$$VAR"
d119 3
a121 1
	export $VAR=$DEF
d138 1
a138 1
function getHostName {
d142 1
a142 1
	local VAR="HOSTNAME"
d144 1
a144 1
	local VAR=$1
d147 1
a147 1
	if [ x$VAR = x ] ; then export $VAR=$HOSTNAME ; fi
d149 1
a149 1
    if [ x$2 = x ] ; then local DEFVAL="unknown" ; else local DEFVAL=$2 ; fi
d153 4
a156 4
    if [ x$VAR = x ] ; then initializeVariable $VAR `hostname` ; fi
    if [ x$VAR = x ] ; then initializeVariable $VAR $HOST ; fi
    if [ x$VAR = x ] ; then initializeVariable $VAR `uname -n` ; fi
    if [ x$VAR = x ] ; then initializeVariable $VAR $DEFVAL ; fi
d158 1
a158 1
    local VARVAL="echo \$$VAR"
d169 1
a169 1
function acquireLock {
d172 3
a174 3
    if [ x$1 = x ] ; then local LOCK="local.lock" ; else local LOCK=$1 ; fi
    if [ x$2 = x ] ; then local RETRY=1 ; else local RETRY=$2 ; fi
    if [ x$3 = x ] ; then local WAIT=0 ; else local WAIT=$3 ; fi
d193 1
a193 1
# releaseLock lockFile
d195 1
a195 1
function releaseLock {
d198 1
a198 1
    if [ x$1 = x ] ; then local LOCK="local.lock" ; else local LOCK=$1 ; fi
d208 44
@

