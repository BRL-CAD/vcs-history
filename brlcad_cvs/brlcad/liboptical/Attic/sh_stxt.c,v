head	11.21;
access;
symbols
	ansi-20040405-merged:11.17.2.2
	postmerge-20040405-ansi:11.19
	premerge-20040404-ansi:11.18
	postmerge-autoconf:11.18
	autoconf-freeze:11.17.10.2
	premerge-autoconf:11.18
	ansi-20040316-freeze:11.17.2.1
	postmerge-20040315-windows:11.18
	premerge-20040315-windows:11.18
	windows-20040315-freeze:11.17.4.1
	autoconf-20031203:11.17
	autoconf-20031202:11.17
	autoconf-branch:11.17.0.10
	phong-branch:11.17.0.8
	photonmap-branch:11.17.0.6
	rel-6-1-DP:11.17
	windows-branch:11.17.0.4
	rel-6-0-2:11.15
	ansi-branch:11.17.0.2
	rel-6-0-1-branch:11.15.0.2
	hartley-6-0-post:11.16
	hartley-6-0-pre:11.15
	rel-6-0-1:11.15
	rel-6-0:11.15
	rel-5-4:11.13
	offsite-5-3-pre:11.15
	rel-5-3:11.13
	rel-5-2:11.13
	rel-5-1-branch:11.13.0.2
	rel-5-1:11.13
	rel-5-0:11.11
	rel-5-0-beta:11.9
	rel-4-5:11.7
	ctj-4-5-post:11.5
	ctj-4-5-pre:11.5
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1;
locks; strict;
comment	@ * @;


11.21
date	2004.05.21.18.07.28;	author morrison;	state dead;
branches;
next	11.20;

11.20
date	2004.05.10.15.30.45;	author erikg;	state Exp;
branches;
next	11.19;

11.19
date	2004.04.05.07.43.37;	author morrison;	state Exp;
branches;
next	11.18;

11.18
date	2004.02.02.17.39.14;	author morrison;	state Exp;
branches;
next	11.17;

11.17
date	2002.08.20.17.07.52;	author jra;	state Exp;
branches
	11.17.2.1
	11.17.4.1
	11.17.10.1;
next	11.16;

11.16
date	2002.08.15.20.55.05;	author hartley;	state Exp;
branches;
next	11.15;

11.15
date	2000.08.20.01.27.48;	author butler;	state Exp;
branches;
next	11.14;

11.14
date	2000.07.25.16.40.38;	author butler;	state Exp;
branches;
next	11.13;

11.13
date	2000.02.19.21.05.02;	author butler;	state Exp;
branches;
next	11.12;

11.12
date	99.10.30.03.06.25;	author butler;	state Exp;
branches;
next	11.11;

11.11
date	99.07.02.22.20.42;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	99.07.01.20.08.48;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	98.09.22.01.29.56;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	98.06.30.22.54.19;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	97.12.31.09.01.40;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	97.11.25.22.16.43;	author butler;	state Exp;
branches;
next	11.5;

11.5
date	96.08.31.08.46.01;	author butler;	state Exp;
branches;
next	11.4;

11.4
date	96.08.31.08.29.28;	author butler;	state Exp;
branches;
next	11.3;

11.3
date	96.08.30.00.08.21;	author butler;	state Exp;
branches;
next	11.2;

11.2
date	95.10.20.04.43.53;	author butler;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.01.12;	author mike;	state Rel4_4;
branches;
next	10.3;

10.3
date	94.11.05.03.02.54;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	94.08.11.02.40.08;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.42.13;	author mike;	state Rel4_0;
branches;
next	9.12;

9.12
date	91.07.06.00.35.23;	author mike;	state Exp;
branches;
next	9.11;

9.11
date	91.02.17.20.15.55;	author mike;	state Exp;
branches;
next	9.10;

9.10
date	91.01.05.03.09.17;	author mike;	state Exp;
branches;
next	9.9;

9.9
date	91.01.03.22.57.38;	author butler;	state Exp;
branches;
next	9.8;

9.8
date	90.12.12.16.35.11;	author butler;	state Exp;
branches;
next	9.7;

9.7
date	90.12.08.08.30.45;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	90.12.08.08.11.54;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	90.11.04.10.13.50;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	90.11.02.02.04.33;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	90.11.01.11.19.01;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	90.04.27.02.19.23;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.59.44;	author mike;	state Rel3_5;
branches;
next	8.7;

8.7
date	89.04.30.21.19.00;	author mike;	state Exp;
branches;
next	8.6;

8.6
date	89.04.28.06.17.30;	author phil;	state Exp;
branches;
next	8.5;

8.5
date	89.04.05.01.51.51;	author mike;	state Exp;
branches;
next	8.4;

8.4
date	89.04.04.05.02.09;	author mike;	state Exp;
branches;
next	8.3;

8.3
date	89.01.07.02.00.10;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	88.12.27.16.35.15;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.33.29;	author mike;	state Rel3_0;
branches;
next	1.5;

1.5
date	88.09.17.07.21.21;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	88.09.09.01.56.04;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	88.06.21.02.53.41;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	88.06.21.00.59.13;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	88.06.16.03.47.48;	author mike;	state Exp;
branches;
next	;

11.17.2.1
date	2002.09.19.18.01.26;	author morrison;	state Exp;
branches;
next	11.17.2.2;

11.17.2.2
date	2004.03.17.21.18.33;	author morrison;	state Exp;
branches;
next	;

11.17.4.1
date	2004.03.11.23.43.03;	author morrison;	state Exp;
branches;
next	;

11.17.10.1
date	2004.02.12.18.38.49;	author erikg;	state Exp;
branches;
next	11.17.10.2;

11.17.10.2
date	2004.03.15.14.07.13;	author erikg;	state Exp;
branches;
next	;


desc
@Solid (3-D) Texture
@


11.21
log
@moved to src/
@
text
@/*
 *			S T X T . C
 *
 *  Routines to implement solid (ie, 3-D) texture maps.
 *
 *  XXX Solid texturing is still preliminary.
 *
 *  Author -
 *	Tom DiGiacinto
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1986-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/liboptical/sh_stxt.c,v 11.20 2004/05/10 15:30:45 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <string.h>
#include <math.h>
#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "raytrace.h"
#include "shadefuncs.h"
#include "shadework.h"
#include "rtprivate.h"

HIDDEN int  stxt_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip), brick_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp), mbound_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp), rbound_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
HIDDEN void	stxt_print(register struct region *rp, char *dp), stxt_free(char *cp);
HIDDEN void	stxt_transp_hook(struct bu_structparse *ptab, char *name, char *cp, char *value);

#define STX_NAME_LEN 128
struct	stxt_specific  {
	int	stx_transp[3];	/* RGB for transparency */
	char	stx_file[STX_NAME_LEN];	/* Filename */
	int	stx_magic;
	int	stx_w;		/* Width of texture in pixels */
	int	stx_fw;		/* File width of texture in pixels */
	int	stx_n;		/* Number of scanlines */
	int	stx_d;		/* Depth of texture (Num pix files)*/
	vect_t	stx_min;
	vect_t	stx_max;
	char	*stx_pixels;	/* Pixel holding area */
	int	trans_valid;	/* boolean: has stx_transp been set? */
};
#define STXT_MAGIC	0xfeedbaad
#define SOL_NULL	((struct stxt_specific *)0)
#define SOL_O(m)	offsetof(struct stxt_specific, m)

struct	bu_structparse stxt_parse[] = {
#if CRAY && !__STDC__
	/* Hack for Cray compiler */
	{"%d",	1, "transp",		0,		stxt_transp_hook },
	{"%s",	STX_NAME_LEN, "file",	1,			BU_STRUCTPARSE_FUNC_NULL },
#else
	{"%d",	1, "transp",	bu_offsetofarray(struct stxt_specific, stx_transp),	stxt_transp_hook },
	{"%s",	STX_NAME_LEN, "file",	bu_offsetofarray(struct stxt_specific, stx_file),	BU_STRUCTPARSE_FUNC_NULL },
#endif
	{"%d",	1, "w",			SOL_O(stx_w),		BU_STRUCTPARSE_FUNC_NULL },
	{"%d",	1, "n",			SOL_O(stx_n),		BU_STRUCTPARSE_FUNC_NULL },
	{"%d",	1, "d",			SOL_O(stx_d),		BU_STRUCTPARSE_FUNC_NULL },
	{"%d",	1, "fw",		SOL_O(stx_fw),		BU_STRUCTPARSE_FUNC_NULL },
	{"%d",	1, "trans_valid",	SOL_O(trans_valid),	BU_STRUCTPARSE_FUNC_NULL },
	{"",	0, (char *)0,		0,			BU_STRUCTPARSE_FUNC_NULL }
};

struct	mfuncs stxt_mfuncs[] = {
	{MF_MAGIC,	"brick",	0,		MFI_HIT,	0,
	stxt_setup,	brick_render,	stxt_print,	stxt_free },

	{MF_MAGIC,	"mbound",	0,		MFI_HIT,	0,
	stxt_setup,	mbound_render,	stxt_print,	stxt_free },

	{MF_MAGIC,	"rbound",	0,		MFI_HIT,	0,
	stxt_setup,	rbound_render,	stxt_print,	stxt_free },

	{0,		(char *)0,	0,		0,		0,
	0,		0,		0,		0 }
};

/*
 *			S T X T _ T R A N S P _ H O O K
 *
 *  Hooked function, called by bu_structparse.
 */
HIDDEN void
stxt_transp_hook(struct bu_structparse *ptab, char *name, char *cp, char *value)
{
	register struct stxt_specific *stp =
		(struct stxt_specific *)cp;

	if (!strcmp(name, stxt_parse[0].sp_name) && ptab == stxt_parse) {
		stp->trans_valid = 1;
	} else {
		bu_log("file:%s, line:%d stxt_transp_hook name:(%s) instead of (%s)\n",
			__FILE__, __LINE__, name, stxt_parse[0].sp_name);
	}
}

/*
 *			S T X T _ R E A D
 *
 *  Load the texture into memory.
 *  Returns 0 on failure, 1 on success.
 */
HIDDEN int
stxt_read(register struct stxt_specific *stp)
{
	char *linebuf;
	register FILE *fp;
	register int i;
	char name[256];
	int frame, ln;
	int rd, rdd;

	/*** MEMORY HOG ***/
	stp->stx_pixels = bu_malloc(
		stp->stx_w * stp->stx_n * stp->stx_d * 3,
		stp->stx_file );

	ln = 0;
	rdd = 0;
	rd = 0;

	/**  LOOP: through list of basename.n files **/
	for( frame=0; frame <= stp->stx_d-1; frame++ )  {

		sprintf(name, "%s.%d", stp->stx_file, frame);

		if ((fp = fopen(name, "r")) == NULL )  {
			bu_log("stxt_read(%s):  can't open\n", name);
			stp->stx_file[0] = '\0';
			return(0);
		}
		linebuf = bu_malloc(stp->stx_fw*3,"texture file line");

		for( i = 0; i < stp->stx_n; i++ )  {
			if ((rd = fread(linebuf,1,stp->stx_fw*3,fp)) != stp->stx_fw*3 ) {
				bu_log("stxt_read: read error on %s\n", name);
				stp->stx_file[0] = '\0';
				(void)fclose(fp);
				bu_free(linebuf,"file line, error");
				return(0);
			}
			bcopy( linebuf, stp->stx_pixels + ln*stp->stx_w*3, stp->stx_w*3 );
			ln++;
			rdd += rd;
		}
		(void)fclose(fp);
		bu_free(linebuf,"texture file line");
	}
	return(1);	/* OK */
}


/*
 *			S T X T _ S E T U P
 */
HIDDEN int
stxt_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip)
                      	    
             		         
    			      
                             
                                /* New since 4.4 release */
{
	register struct stxt_specific *stp;

	BU_GETSTRUCT( stp, stxt_specific );
	*dpp = (char *)stp;

	/**  Set up defaults  **/
	stp->stx_magic = STXT_MAGIC;
	stp->stx_file[0] = '\0';
	stp->stx_w = stp->stx_fw = stp->stx_n = stp->stx_d = -1;

	if (rt_bound_tree(rp->reg_treetop, stp->stx_min, stp->stx_max) < 0 )
		return(-1);

	/**	Get input values  **/
	if (bu_struct_parse( matparm, stxt_parse, (char *)stp ) < 0 )  {
		bu_free( (char *)stp, "stxt_specific" );
		return(-1);
	}
	/*** DEFAULT SIZE OF STXT FILES ***/
	if (stp->stx_w < 0 )  stp->stx_w = 512;
	if (stp->stx_n < 0 )  stp->stx_n = stp->stx_w;

	/**  Defaults to an orthogonal projection??  **/
	if (stp->stx_d < 0 )  stp->stx_d = 1;

	if (stp->stx_fw < 0 )  stp->stx_fw = stp->stx_w;
	stp->stx_pixels = (char *)0;
	if (stp->trans_valid )
		rp->reg_transmit = 1;

	/**	Read in texture file/s  **/
	return( stxt_read(stp) );
}

/*
 *			S T X T _ F R E E
 */
HIDDEN void
stxt_free(char *cp)
{
	register struct stxt_specific *stp =
		(struct stxt_specific *)cp;

	if (stp->stx_magic != STXT_MAGIC )  bu_log("stxt_free(): bad magic\n");

	if (stp->stx_pixels )
		bu_free( stp->stx_pixels, "solid texture pixel array" );
	bu_free( cp, "stx_specific" );
}

/*
 *			S T X T _ P R I N T
 */
HIDDEN void
stxt_print(register struct region *rp, char *dp)
{
	bu_struct_print(rp->reg_name, stxt_parse, (char *)dp);
}


HIDDEN int
brick_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
{
	register struct stxt_specific *stp =
		(struct stxt_specific *)dp;
	vect_t  lx, ly, lz;	/* local coordinate axis */
	fastf_t f;
	double iptr;
	fastf_t sx, sy, sz;
	int	tx, ty, tz;
	register long r,g,b;
	int u1, u2, u3;
	register unsigned char *cp;

	if (stp->stx_magic != STXT_MAGIC )  bu_log("brick_render(): bad magic\n");

	/*
	 * If no texture file present, or if
	 * texture isn't and can't be read, give debug colors
	 */
	if (stp->stx_file[0] == '\0'  ||
	    ( stp->stx_pixels == (char *)0 && stxt_read(stp) == 0 ) )  {
		VSET( swp->sw_color, 1, 0, 1 );
		return(1);
	}

	/** Local Coordinate Axis **/
	VSET( lx, 1, 0, 0 );
	VSET( ly, 0, 1, 0 );
	VSET( lz, 0, 0, 1 );

	f = VDOT( swp->sw_hit.hit_point, lx ) / (float)stp->stx_w;
	if (f < 0 ) f = -f;
	f = modf( f, &iptr );
	sx=f;
/********************************
*	if (f < 0.5 )
*		sx = 2 * f;
*	else
*		sx = 2 * ( 1 - f );
*********************************/

	f = VDOT( swp->sw_hit.hit_point, ly ) / (float)stp->stx_n;
	if (f < 0 ) f = -f;
	f = modf( f, &iptr );
	sy=f;
/*********************************
*	if (f < 0.5 )
*		sy = 2 * f;
*	else
*		sy = 2 * ( 1 - f );
**********************************/

	f = VDOT( swp->sw_hit.hit_point, lz ) / (float)stp->stx_d;
	if (f < 0 ) f = -f;
	f = modf( f, &iptr );
	sz=f;
/*********************************
*	if (f < 0.5 )
*		sz = 2 * f;
*	else
*		sz = 2 * ( 1 - f );
**********************************/

/*bu_log("sx = %f\tsy = %f\tsz = %f\n",sx,sy,sz);*/

	/* Index into TEXTURE SPACE */
	tx = sx * (stp->stx_w-1);
	ty = sy * (stp->stx_n-1);
	tz = sz * (stp->stx_d-1);

	u1 = (int)tz * stp->stx_n * stp->stx_w *  3.0;
	u2 = (int)ty * stp->stx_w * 3.0;
	u3 = (int)tx * 3.0;

	cp = (unsigned char *)(stp->stx_pixels + u1 + u2 + u3 );

	r = *cp++;
	g = *cp++;
	b = *cp++;

	VSET( swp->sw_color,
		(r+0.5) * bn_inv255,
		(g+0.5) * bn_inv255,
		(b+0.5) * bn_inv255 );

	return(1);
}

/*
 *			R B O U N D _ R E N D E R
 *
 *  Use region RPP to bound solid texture (rbound).
 */
HIDDEN int
rbound_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
{
	register struct stxt_specific *stp =
		(struct stxt_specific *)dp;
	fastf_t sx, sy, sz;
	int	tx, ty, tz;
	register long r,g,b;

	int u1, u2, u3;
	register unsigned char *cp;

	if (stp->stx_magic != STXT_MAGIC )  bu_log("rbound_render(): bad magic\n");

	/*
	 * If no texture file present, or if
	 * texture isn't and can't be read, give debug colors
	 */
	if (stp->stx_file[0] == '\0'  ||
	    ( stp->stx_pixels == (char *)0 && stxt_read(stp) == 0 ) )  {
		VSET( swp->sw_color, 1, 0, 1 );
		return(1);
	}

	/* NORMALIZE x,y,z to [0..1) */
#if 1
	/* XXX hack hack, permute axes, for vertical letters.  -M */
	sz = (swp->sw_hit.hit_point[0] - stp->stx_min[0]) /
		(stp->stx_max[0] - stp->stx_min[0] + 1.0);
	sx = (swp->sw_hit.hit_point[1] - stp->stx_min[1]) /
		(stp->stx_max[1] - stp->stx_min[1] + 1.0);
	sy = (swp->sw_hit.hit_point[2] - stp->stx_min[2]) /
		(stp->stx_max[2] - stp->stx_min[2] + 1.0);
#else
	sx = (swp->sw_hit.hit_point[0] - stp->stx_min[0]) /
		(stp->stx_max[0] - stp->stx_min[0] + 1.0);
	sy = (swp->sw_hit.hit_point[1] - stp->stx_min[1]) /
		(stp->stx_max[1] - stp->stx_min[1] + 1.0);
	sz = (swp->sw_hit.hit_point[2] - stp->stx_min[2]) /
		(stp->stx_max[2] - stp->stx_min[2] + 1.0);
#endif

	/* Index into TEXTURE SPACE */
	tx = sx * (stp->stx_w-1);
	ty = sy * (stp->stx_n-1);
	tz = sz * (stp->stx_d-1);

	u1 = (int)tz * stp->stx_n * stp->stx_w *  3.0;
	u2 = (int)ty * stp->stx_w * 3.0;
	u3 = (int)tx * 3.0;

	cp = (unsigned char *)(stp->stx_pixels + u1 + u2 + u3 );

	r = *cp++;
	g = *cp++;
	b = *cp++;

	VSET( swp->sw_color,
		(r+0.5) * bn_inv255,
		(g+0.5) * bn_inv255,
		(b+0.5) * bn_inv255 );

	return(1);
}


/*
 *			M B O U N D _ R E N D E R
 *
 *  Use model RPP as solid texture bounds.  (mbound).
 */
HIDDEN int
mbound_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
{
	register struct stxt_specific *stp =
		(struct stxt_specific *)dp;
	fastf_t sx, sy, sz;
	int	tx, ty, tz;
	register long r,g,b;
	int u1, u2, u3;
	register unsigned char *cp;

	if (stp->stx_magic != STXT_MAGIC )  bu_log("mbound_render(): bad magic\n");

	/*
	 * If no texture file present, or if
	 * texture isn't and can't be read, give debug colors
	 */
	if (stp->stx_file[0] == '\0'  ||
	    ( stp->stx_pixels == (char *)0 && stxt_read(stp) == 0 ) )  {
		VSET( swp->sw_color, 1, 0, 1 );
		return(1);
	}

	/* NORMALIZE x,y,z to [0..1) */
	sx = (swp->sw_hit.hit_point[0] - ap->a_rt_i->mdl_min[0]) /
		(ap->a_rt_i->mdl_max[0] - ap->a_rt_i->mdl_min[0] + 1.0);
	sy = (swp->sw_hit.hit_point[1] - ap->a_rt_i->mdl_min[1]) /
		(ap->a_rt_i->mdl_max[1] - ap->a_rt_i->mdl_min[1] + 1.0);
	sz = (swp->sw_hit.hit_point[2] - ap->a_rt_i->mdl_min[2]) /
		(ap->a_rt_i->mdl_max[2] - ap->a_rt_i->mdl_min[2] + 1.0);

	/* Index into TEXTURE SPACE */
	tx = sx * (stp->stx_w-1);
	ty = sy * (stp->stx_n-1);
	tz = sz * (stp->stx_d-1);

	u1 = (int)tz * stp->stx_n * stp->stx_w *  3;
	u2 = (int)ty * stp->stx_w * 3;
	u3 = (int)tx * 3;

	cp = (unsigned char *)(stp->stx_pixels + u1 + u2 + u3 );

	r = *cp++;
	g = *cp++;
	b = *cp++;

	VSET( swp->sw_color,
		(r+0.5) * bn_inv255,
		(g+0.5) * bn_inv255,
		(b+0.5) * bn_inv255 );

	return(1);
}
@


11.20
log
@change conf.h to a wrapped config.h
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/liboptical/sh_stxt.c,v 11.19 2004/04/05 07:43:37 morrison Exp $ (BRL)";
@


11.19
log
@merge of ansi-6-0-branch into HEAD
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d24 5
a28 1
#include "conf.h"
@


11.18
log
@update copyright to include span through 2003
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_stxt.c,v 11.17 2002/08/20 17:07:52 jra Exp $ (BRL)";
d37 3
a39 3
HIDDEN int  stxt_setup(), brick_render(), mbound_render(), rbound_render();
HIDDEN void	stxt_print(), stxt_free();
HIDDEN void	stxt_transp_hook();
d96 1
a96 5
stxt_transp_hook( ptab, name, cp, value)
struct bu_structparse *ptab;
char	*name;
char	*cp;
char	*value;
d116 1
a116 2
stxt_read( stp )
register struct stxt_specific *stp;
d169 6
a174 6
stxt_setup( rp, matparm, dpp, mfp, rtip )
register struct region	*rp;
struct bu_vls		*matparm;
char			**dpp;
struct mfuncs           *mfp;
struct rt_i             *rtip;  /* New since 4.4 release */
d214 1
a214 2
stxt_free( cp )
char	*cp;
d230 1
a230 3
stxt_print( rp, dp )
register struct region *rp;
char	*dp;
d237 1
a237 5
brick_render( ap, pp, swp, dp )
struct application	*ap;
struct partition	*pp;
struct shadework	*swp;
char	*dp;
d331 1
a331 5
rbound_render( ap, pp, swp, dp )
struct application	*ap;
struct partition	*pp;
struct shadework	*swp;
char	*dp;
d402 1
a402 5
mbound_render( ap, pp, swp, dp )
struct application	*ap;
struct partition	*pp;
struct shadework	*swp;
char	*dp;
@


11.17
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1986 by the United States Army.
d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_stxt.c,v 11.15 2000/08/20 01:27:48 butler Exp $ (BRL)";
@


11.17.4.1
log
@sync to HEAD...
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/liboptical/sh_stxt.c,v 11.18 2004/02/02 17:39:14 morrison Exp $ (BRL)";
@


11.17.10.1
log
@merge from HEAD
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_stxt.c,v 11.18 2004/02/02 17:39:14 morrison Exp $ (BRL)";
@


11.17.10.2
log
@merge from head
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_stxt.c,v 11.17.10.1 2004/02/12 18:38:49 erikg Exp $ (BRL)";
@


11.17.2.1
log
@Initial ANSIfication
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_stxt.c,v 11.17 2002/08/20 17:07:52 jra Exp $ (BRL)";
d37 3
a39 3
HIDDEN int  stxt_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip), brick_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp), mbound_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp), rbound_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
HIDDEN void	stxt_print(register struct region *rp, char *dp), stxt_free(char *cp);
HIDDEN void	stxt_transp_hook(struct bu_structparse *ptab, char *name, char *cp, char *value);
d96 5
a100 1
stxt_transp_hook(struct bu_structparse *ptab, char *name, char *cp, char *value)
d120 2
a121 1
stxt_read(register struct stxt_specific *stp)
d174 6
a179 6
stxt_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip)
                      	    
             		         
    			      
                             
                                /* New since 4.4 release */
d219 2
a220 1
stxt_free(char *cp)
d236 3
a238 1
stxt_print(register struct region *rp, char *dp)
d245 5
a249 1
brick_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
d343 5
a347 1
rbound_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
d418 5
a422 1
mbound_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
@


11.17.2.2
log
@sync branch with HEAD
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d21 1
a21 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.16
log
@Converted from K&R to ANSI C - RFH
@
text
@d37 3
a39 3
HIDDEN int  stxt_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip), brick_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp), mbound_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp), rbound_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
HIDDEN void	stxt_print(register struct region *rp, char *dp), stxt_free(char *cp);
HIDDEN void	stxt_transp_hook(struct bu_structparse *ptab, char *name, char *cp, char *value);
d96 5
a100 1
stxt_transp_hook(struct bu_structparse *ptab, char *name, char *cp, char *value)
d120 2
a121 1
stxt_read(register struct stxt_specific *stp)
d174 6
a179 6
stxt_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip)
                      	    
             		         
    			      
                             
                                /* New since 4.4 release */
d219 2
a220 1
stxt_free(char *cp)
d236 3
a238 1
stxt_print(register struct region *rp, char *dp)
d245 5
a249 1
brick_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
d343 5
a347 1
rbound_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
d418 5
a422 1
mbound_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
@


11.15
log
@Eliminate compilation warnings, enhancements to sh_light.c
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_stxt.c,v 11.14 2000/07/25 16:40:38 butler Exp $ (BRL)";
d37 3
a39 3
HIDDEN int  stxt_setup(), brick_render(), mbound_render(), rbound_render();
HIDDEN void	stxt_print(), stxt_free();
HIDDEN void	stxt_transp_hook();
d96 1
a96 5
stxt_transp_hook( ptab, name, cp, value)
struct bu_structparse *ptab;
char	*name;
char	*cp;
char	*value;
d116 1
a116 2
stxt_read( stp )
register struct stxt_specific *stp;
d169 6
a174 6
stxt_setup( rp, matparm, dpp, mfp, rtip )
register struct region	*rp;
struct bu_vls		*matparm;
char			**dpp;
struct mfuncs           *mfp;
struct rt_i             *rtip;  /* New since 4.4 release */
d214 1
a214 2
stxt_free( cp )
char	*cp;
d230 1
a230 3
stxt_print( rp, dp )
register struct region *rp;
char	*dp;
d237 1
a237 5
brick_render( ap, pp, swp, dp )
struct application	*ap;
struct partition	*pp;
struct shadework	*swp;
char	*dp;
d331 1
a331 5
rbound_render( ap, pp, swp, dp )
struct application	*ap;
struct partition	*pp;
struct shadework	*swp;
char	*dp;
d402 1
a402 5
mbound_render( ap, pp, swp, dp )
struct application	*ap;
struct partition	*pp;
struct shadework	*swp;
char	*dp;
@


11.14
log
@Changes to use rtprivate.h instead of ../rt/rdebug.h
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_stxt.c,v 11.13 2000/02/19 21:05:02 butler Exp $ (BRL)";
@


11.13
log
@Changes to support movement of CLAMP() macro into vmath.h
Altered "if( " statements to "if (" for readability.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_stxt.c,v 11.12 1999/10/30 03:06:25 butler Exp $ (BRL)";
d27 1
d35 1
a35 1
#include "../rt/rdebug.h"
d244 1
a244 1
HIDDEN
d342 1
a342 1
HIDDEN
d417 1
a417 1
HIDDEN
@


11.12
log
@Moved mathtab/rand_half from rt into libbn
Expanded structparse to include description and default
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_stxt.c,v 11.11 1999/07/02 22:20:42 mike Exp $ (BRL)";
d143 1
a143 1
		if( (fp = fopen(name, "r")) == NULL )  {
d151 1
a151 1
			if( (rd = fread(linebuf,1,stp->stx_fw*3,fp)) != stp->stx_fw*3 ) {
d190 1
a190 1
	if( rt_bound_tree(rp->reg_treetop, stp->stx_min, stp->stx_max) < 0 )
d194 1
a194 1
	if( bu_struct_parse( matparm, stxt_parse, (char *)stp ) < 0 )  {
d199 2
a200 2
	if( stp->stx_w < 0 )  stp->stx_w = 512;
	if( stp->stx_n < 0 )  stp->stx_n = stp->stx_w;
d203 1
a203 1
	if( stp->stx_d < 0 )  stp->stx_d = 1;
d205 1
a205 1
	if( stp->stx_fw < 0 )  stp->stx_fw = stp->stx_w;
d207 1
a207 1
	if( stp->trans_valid )
d224 1
a224 1
	if( stp->stx_magic != STXT_MAGIC )  bu_log("stxt_free(): bad magic\n");
d226 1
a226 1
	if( stp->stx_pixels )
d261 1
a261 1
	if( stp->stx_magic != STXT_MAGIC )  bu_log("brick_render(): bad magic\n");
d267 1
a267 1
	if( stp->stx_file[0] == '\0'  ||
d279 1
a279 1
	if( f < 0 ) f = -f;
d283 1
a283 1
*	if( f < 0.5 )
d290 1
a290 1
	if( f < 0 ) f = -f;
d294 1
a294 1
*	if( f < 0.5 )
d301 1
a301 1
	if( f < 0 ) f = -f;
d305 1
a305 1
*	if( f < 0.5 )
d357 1
a357 1
	if( stp->stx_magic != STXT_MAGIC )  bu_log("rbound_render(): bad magic\n");
d363 1
a363 1
	if( stp->stx_file[0] == '\0'  ||
d431 1
a431 1
	if( stp->stx_magic != STXT_MAGIC )  bu_log("mbound_render(): bad magic\n");
d437 1
a437 1
	if( stp->stx_file[0] == '\0'  ||
@


11.11
log
@
Removed dependence on compat4.h
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_stxt.c,v 11.10 1999/07/01 20:08:48 mike Exp $ (BRL)";
a33 1
#include "../rt/mathtab.h"
@


11.10
log
@
compat4
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_stxt.c,v 11.9 1998/09/22 01:29:56 mike Exp $ (BRL)";
d63 1
a63 1
	{"%s",	STX_NAME_LEN, "file",	1,			FUNC_NULL },
d66 1
a66 1
	{"%s",	STX_NAME_LEN, "file",	bu_offsetofarray(struct stxt_specific, stx_file),	FUNC_NULL },
d68 6
a73 6
	{"%d",	1, "w",			SOL_O(stx_w),		FUNC_NULL },
	{"%d",	1, "n",			SOL_O(stx_n),		FUNC_NULL },
	{"%d",	1, "d",			SOL_O(stx_d),		FUNC_NULL },
	{"%d",	1, "fw",		SOL_O(stx_fw),		FUNC_NULL },
	{"%d",	1, "trans_valid",	SOL_O(trans_valid),	FUNC_NULL },
	{"",	0, (char *)0,		0,			FUNC_NULL }
@


11.9
log
@Moved optical shaders from rt/ to liboptical/
The only modifications involved moving and splitting
rt/material.h into h/shadefuncs.h and h/shadework.h,
and in changing the calling sequence to mlib_setup() in rt/material.c

Now the only shader function called directly by RT is
in liboptical/init.c: optical_shader_init().
It adds all the individual shaders to the "mfuncs" shader list.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rt/sh_stxt.c,v 11.8 1998/06/30 22:54:19 mike Exp $ (BRL)";
d65 2
a66 2
	{"%d",	1, "transp",	offsetofarray(struct stxt_specific, stx_transp),	stxt_transp_hook },
	{"%s",	STX_NAME_LEN, "file",	offsetofarray(struct stxt_specific, stx_file),	FUNC_NULL },
d108 1
a108 1
		rt_log("file:%s, line:%d stxt_transp_hook name:(%s) instead of (%s)\n",
d131 1
a131 1
	stp->stx_pixels = rt_malloc(
d145 1
a145 1
			rt_log("stxt_read(%s):  can't open\n", name);
d149 1
a149 1
		linebuf = rt_malloc(stp->stx_fw*3,"texture file line");
d153 1
a153 1
				rt_log("stxt_read: read error on %s\n", name);
d156 1
a156 1
				rt_free(linebuf,"file line, error");
d164 1
a164 1
		rt_free(linebuf,"texture file line");
d176 1
a176 1
struct rt_vls		*matparm;
d183 1
a183 1
	GETSTRUCT( stp, stxt_specific );
d196 1
a196 1
		rt_free( (char *)stp, "stxt_specific" );
d225 1
a225 1
	if( stp->stx_magic != STXT_MAGIC )  rt_log("stxt_free(): bad magic\n");
d228 2
a229 2
		rt_free( stp->stx_pixels, "solid texture pixel array" );
	rt_free( cp, "stx_specific" );
d262 1
a262 1
	if( stp->stx_magic != STXT_MAGIC )  rt_log("brick_render(): bad magic\n");
d312 1
a312 1
/*rt_log("sx = %f\tsy = %f\tsz = %f\n",sx,sy,sz);*/
d330 3
a332 3
		(r+0.5) * rt_inv255,
		(g+0.5) * rt_inv255,
		(b+0.5) * rt_inv255 );
d358 1
a358 1
	if( stp->stx_magic != STXT_MAGIC )  rt_log("rbound_render(): bad magic\n");
d404 3
a406 3
		(r+0.5) * rt_inv255,
		(g+0.5) * rt_inv255,
		(b+0.5) * rt_inv255 );
d432 1
a432 1
	if( stp->stx_magic != STXT_MAGIC )  rt_log("mbound_render(): bad magic\n");
d468 3
a470 3
		(r+0.5) * rt_inv255,
		(g+0.5) * rt_inv255,
		(b+0.5) * rt_inv255 );
@


11.8
log
@Can't make "struct mfuncs" a CONST, because the forward link needs
to be filled in at runtime, and some compilers put CONST data into
read-only pages (like FreeBSD).
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rt/sh_stxt.c,v 11.7 1997/12/31 09:01:40 mike Exp $ (BRL)";
d32 4
a35 2
#include "./material.h"
#include "./rdebug.h"
@


11.7
log
@Required magic number to be first in mfunc table,
consistent with all other BRL-CAD magic numbers.
Required magic number to be initialized at compile time.
Added code to check the magic numbers.
Made the xxx_mfunc arrays CONST, so they can't get trashed by
runtime runaway pointer problems.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_stxt.c,v 11.6 1997/11/25 22:16:43 butler Exp mike $ (BRL)";
d74 1
a74 1
CONST struct	mfuncs stxt_mfuncs[] = {
@


11.6
log
@updated all shaders so that _setup had mfp and rtip parameters
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_stxt.c,v 11.5 1996/08/31 08:46:01 butler Exp butler $ (BRL)";
d74 2
a75 2
struct	mfuncs stxt_mfuncs[] = {
	{"brick",	0,		0,		MFI_HIT,	0,
d78 1
a78 1
	{"mbound",	0,		0,		MFI_HIT,	0,
d81 1
a81 1
	{"rbound",	0,		0,		MFI_HIT,	0,
d84 1
a84 1
	{ (char *)0,	0,		0,		0,		0,
@


11.5
log
@bu_struct_print
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_stxt.c,v 11.4 1996/08/31 08:29:28 butler Exp butler $ (BRL)";
d172 1
a172 1
stxt_setup( rp, matparm, dpp )
d176 2
@


11.4
log
@bu_struct_parse
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_stxt.c,v 11.3 1996/08/30 00:08:21 butler Exp butler $ (BRL)";
d236 1
a236 1
	bu_structprint(rp->reg_name, stxt_parse, (char *)dp);
@


11.3
log
@structparse moved to libbu
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_stxt.c,v 11.2 1995/10/20 04:43:53 butler Exp butler $ (BRL)";
d191 1
a191 1
	if( bu_structparse( matparm, stxt_parse, (char *)stp ) < 0 )  {
@


11.2
log
@edited mfuncs table to account for new "mf_flags" element in struct mfuncs.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_stxt.c,v 11.1 1995/01/04 10:01:12 mike Rel4_4 butler $ (BRL)";
d57 1
a57 1
struct	structparse stxt_parse[] = {
d91 1
a91 1
 *  Hooked function, called by rt_structparse.
d95 1
a95 1
struct structparse *ptab;
d191 1
a191 1
	if( rt_structparse( matparm, stxt_parse, (char *)stp ) < 0 )  {
d236 1
a236 1
	rt_structprint(rp->reg_name, stxt_parse, (char *)dp);
@


11.1
log
@Release_4.4
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_stxt.c,v 10.3 94/11/05 03:02:54 mike Exp $ (BRL)";
d75 1
a75 1
	{"brick",	0,		0,		MFI_HIT,
d78 1
a78 1
	{"mbound",	0,		0,		MFI_HIT,
d81 1
a81 1
	{"rbound",	0,		0,		MFI_HIT,
d84 1
a84 1
	{ (char *)0,	0,		0,		0,
@


10.3
log
@Irix 6
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_stxt.c,v 10.2 94/08/11 02:40:08 gdurf Exp Locker: mike $ (BRL)";
@


10.2
log
@Added include of conf.h
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_stxt.c,v 10.1 1991/10/12 06:42:13 mike Rel4_0 gdurf $ (BRL)";
a248 1
	register struct soltab *sp;
a253 3
	int line;
	int dx, dy;
	int x,y;
a346 2
	register struct soltab *sp;
	fastf_t xmin, xmax, ymin, ymax;
a348 3
	int line;
	int dx, dy;
	int x,y;
a421 2
	register struct soltab *sp;
	fastf_t xmin, xmax, ymin, ymax;
a423 3
	int line;
	int dx, dy;
	int x,y;
@


10.1
log
@Release_4.0
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_stxt.c,v 9.12 91/07/06 00:35:23 mike Exp $ (BRL)";
d24 2
d29 1
a33 4

#if defined(alliant) && !__STDC__
extern double	modf();
#endif
@


9.12
log
@ANSI structure initialization
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_stxt.c,v 9.11 91/02/17 20:15:55 mike Exp $ (BRL)";
@


9.11
log
@Check return code from rt_structparse()
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_stxt.c,v 9.10 91/01/05 03:09:17 mike Exp $ (BRL)";
d61 2
a62 2
	"%d",	1, "transp",		0,		stxt_transp_hook,
	"%s",	STX_NAME_LEN, "file",	1,			FUNC_NULL,
d64 2
a65 2
	"%d",	1, "transp",	offsetofarray(struct stxt_specific, stx_transp),	stxt_transp_hook,
	"%s",	STX_NAME_LEN, "file",	offsetofarray(struct stxt_specific, stx_file),	FUNC_NULL,
d67 6
a72 6
	"%d",	1, "w",			SOL_O(stx_w),		FUNC_NULL,
	"%d",	1, "n",			SOL_O(stx_n),		FUNC_NULL,
	"%d",	1, "d",			SOL_O(stx_d),		FUNC_NULL,
	"%d",	1, "fw",		SOL_O(stx_fw),		FUNC_NULL,
	"%d",	1, "trans_valid",	SOL_O(trans_valid),	FUNC_NULL,
	"",	0, (char *)0,		0,			FUNC_NULL
d76 2
a77 2
	"brick",	0,		0,		MFI_HIT,
	stxt_setup,	brick_render,	stxt_print,	stxt_free,
d79 2
a80 2
	"mbound",	0,		0,		MFI_HIT,
	stxt_setup,	mbound_render,	stxt_print,	stxt_free,
d82 2
a83 2
	"rbound",	0,		0,		MFI_HIT,
	stxt_setup,	rbound_render,	stxt_print,	stxt_free,
d85 2
a86 2
	(char *)0,	0,		0,		0,
	0,		0,		0,		0
@


9.10
log
@Converted to new format for fmt entry in structparse
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_stxt.c,v 9.9 91/01/03 22:57:38 butler Exp $ (BRL)";
d192 4
a195 1
	rt_structparse( matparm, stxt_parse, (char *)stp );
@


9.9
log
@took out %C entries in structparse table
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_stxt.c,v 9.8 90/12/12 16:35:11 butler Exp $ (BRL)";
d72 1
a72 1
	(char *)0, 0, (char *)0,	0,			FUNC_NULL
@


9.8
log
@modified to reflect changes in structparse format
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_stxt.c,v 9.7 90/12/08 08:30:45 mike Exp $ (BRL)";
d42 1
a42 1
	unsigned char stx_transp[8];	/* RGB for transparency */
d61 1
a61 1
	"%C",	1, "transp",		0,		stxt_transp_hook,
d64 1
a64 1
	"%C",	1, "transp",	offsetofarray(struct stxt_specific, stx_transp),	stxt_transp_hook,
@


9.7
log
@fixed bugs
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_stxt.c,v 9.6 90/12/08 08:11:54 mike Exp $ (BRL)";
d40 1
d43 1
a43 1
	char	stx_file[128];	/* Filename */
d61 2
a62 2
	"%C",	"transp",	0,			stxt_transp_hook,
	"%s",	"file",		1,			FUNC_NULL,
d64 2
a65 2
	"%C",	"transp",	offsetofarray(struct stxt_specific, stx_transp),	stxt_transp_hook,
	"%s",	"file",		offsetofarray(struct stxt_specific, stx_file),	FUNC_NULL,
d67 6
a72 6
	"%d",	"w",		SOL_O(stx_w),		FUNC_NULL,
	"%d",	"n",		SOL_O(stx_n),		FUNC_NULL,
	"%d",	"d",		SOL_O(stx_d),		FUNC_NULL,
	"%d",	"fw",		SOL_O(stx_fw),		FUNC_NULL,
	"%d",	"trans_valid",	SOL_O(trans_valid),	FUNC_NULL,
	(char *)0,(char *)0,	0,			FUNC_NULL
@


9.6
log
@Changed to using structparse's hooked function stuff,
rather than the magic fourth element of rgb.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_stxt.c,v 9.5 90/11/04 10:13:50 mike Exp $ (BRL)";
d173 3
a175 3
register struct region *rp;
char	*matparm;
char	**dpp;
@


9.5
log
@Contains a hack.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_stxt.c,v 9.4 90/11/02 02:04:33 mike Exp $ (BRL)";
d36 4
d51 1
d60 1
a60 1
	"%C",	"transp",	0,			FUNC_NULL,
d63 1
a63 1
	"%C",	"transp",	offsetofarray(struct stxt_specific, stx_transp),	FUNC_NULL,
d70 1
a73 3
HIDDEN int  stxt_setup(), brick_render(), mbound_render(), rbound_render();
HIDDEN void	stxt_print(), stxt_free();

d89 23
d201 1
a201 1
	if( stp->stx_transp[3] != 0 )
@


9.4
log
@Added an stxt_free() handler.
Should save memory on animations with solid textures!
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_stxt.c,v 9.3 90/11/01 11:19:01 mike Exp $ (BRL)";
d347 9
d362 1
@


9.3
log
@Minor cleanups.
Added magic number protection
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_stxt.c,v 9.2 90/04/27 02:19:23 mike Exp $ (BRL)";
d69 1
a69 1
HIDDEN void	stxt_print();
d73 1
a73 1
	stxt_setup,	brick_render,	stxt_print,	0,
d76 1
a76 1
	stxt_setup,	mbound_render,	stxt_print,	0,
d79 1
a79 1
	stxt_setup,	rbound_render,	stxt_print,	0,
d182 20
@


9.2
log
@Changed from using rt_rpp_tree to rt_bound_tree().
@
text
@d6 2
d21 1
a21 1
static char RCSid[] = "@@(#)$Header: sh_stxt.c,v 9.1 89/05/19 05:59:44 mike Locked $ (BRL)";
d39 1
a43 1
	int	stx_norm;
d48 1
d69 1
d73 1
a73 1
	stxt_setup,	brick_render,	0,		0,
d76 1
a76 1
	stxt_setup,	mbound_render,	0,		0,
d79 1
a79 1
	stxt_setup,	rbound_render,	0,		0,
d157 1
a159 1
	stp->stx_norm = 0;
d182 7
a200 1

a203 1

d205 1
a205 1
	fastf_t tx, ty, tz;
a209 1

d213 2
d266 3
a268 3
	tx = sx * stp->stx_w;
	ty = sy * stp->stx_n;
	tz = sz * stp->stx_d;
d288 5
a292 1

d305 1
a305 1
	fastf_t tx, ty, tz;
d314 2
d327 6
a332 3
	sx = (swp->sw_hit.hit_point[0] - stp->stx_min[0]) / (stp->stx_max[0] - stp->stx_min[0] + 1.0);
	sy = (swp->sw_hit.hit_point[1] - stp->stx_min[1]) / (stp->stx_max[1] - stp->stx_min[1] + 1.0);
	sz = (swp->sw_hit.hit_point[2] - stp->stx_min[2]) / (stp->stx_max[2] - stp->stx_min[2] + 1.0);
d335 3
a337 3
	tx = sx * stp->stx_w;
	ty = sy * stp->stx_n;
	tz = sz * stp->stx_d;
d358 5
d375 1
a375 1
	fastf_t tx, ty, tz;
a379 1

d383 2
a394 7
   /**  Using Model-RPP as Texture Bounds **/
	if( stp->stx_norm <= 0 )  {
		VMOVE(stp->stx_min,ap->a_rt_i->mdl_min);
		VMOVE(stp->stx_max,ap->a_rt_i->mdl_max);
		stp->stx_norm++;
	}

d396 6
a401 3
	sx = (swp->sw_hit.hit_point[0] - stp->stx_min[0]) / (stp->stx_max[0] - stp->stx_min[0] + 1.0);
	sy = (swp->sw_hit.hit_point[1] - stp->stx_min[1]) / (stp->stx_max[1] - stp->stx_min[1] + 1.0);
	sz = (swp->sw_hit.hit_point[2] - stp->stx_min[2]) / (stp->stx_max[2] - stp->stx_min[2] + 1.0);
d404 3
a406 3
	tx = sx * stp->stx_w;
	ty = sy * stp->stx_n;
	tz = sz * stp->stx_d;
d408 3
a410 3
	u1 = (int)tz * stp->stx_n * stp->stx_w *  3.0;
	u2 = (int)ty * stp->stx_w * 3.0;
	u3 = (int)tx * 3.0;
@


9.1
log
@Release_3.5
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: sh_stxt.c,v 8.7 89/04/30 21:19:00 mike Exp $ (BRL)";
d156 3
a158 3
	VSETALL(stp->stx_min,  INFINITY);
	VSETALL(stp->stx_max, -INFINITY);
	rt_rpp_tree(rp->reg_treetop,stp->stx_min,stp->stx_max);
@


8.7
log
@No longer requires mathtab.h
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: sh_stxt.c,v 8.6 89/04/28 06:17:30 mike Locked $ (BRL)";
@


8.6
log
@Fixed upgraded Cray hack
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: sh_stxt.c,v 8.5 89/04/05 01:51:51 mike Exp $ (BRL)";
a27 1
#include "./mathtab.h"
@


8.5
log
@Upgraded Cray hack
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: stxt.c,v 8.4 89/04/04 05:02:09 mike Locked $ (BRL)";
d54 1
a54 1
	"%s",	"file",		8,			FUNC_NULL,
@


8.4
log
@Converted to new way of representing structure offsets.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: stxt.c,v 8.3 89/01/07 02:00:10 mike Locked $ (BRL)";
d51 5
a55 1
#ifndef CRAY
a57 3
#else
	"%C",	"transp",	0,			FUNC_NULL,
	"%s",	"file",		1,			FUNC_NULL,
@


8.3
log
@Alliant fix
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: stxt.c,v 8.2 88/12/27 16:35:15 mike Locked $ (BRL)";
d31 1
a31 1
#if defined(alliant) && !defined(__STDC__)
d47 2
a48 1
#define SOL_NULL ((struct stxt_specific *)0)
d52 2
a53 2
	"%C",	"transp",	(stroff_t)(SOL_NULL->stx_transp),	FUNC_NULL,
	"%s",	"file",		(stroff_t)(SOL_NULL->stx_file),		FUNC_NULL,
d55 2
a56 2
	"%C",	"transp",	(stroff_t)0,				FUNC_NULL,
	"%s",	"file",		(stroff_t)1,				FUNC_NULL,
d58 5
a62 5
	"%d",	"w",		(stroff_t)&(SOL_NULL->stx_w),		FUNC_NULL,
	"%d",	"n",		(stroff_t)&(SOL_NULL->stx_n),		FUNC_NULL,
	"%d",	"d",		(stroff_t)&(SOL_NULL->stx_d),		FUNC_NULL,
	"%d",	"fw",		(stroff_t)&(SOL_NULL->stx_fw),		FUNC_NULL,
	(char *)0,(char *)0,	(stroff_t)0,				FUNC_NULL
d161 1
a161 1
	rt_structparse( matparm, stxt_parse, (stroff_t)stp );
@


8.2
log
@Converted matparse --> structparse
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: stxt.c,v 8.1 88/10/05 00:33:29 mike Locked $ (BRL)";
d30 4
@


8.1
log
@Release_3.0
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: stxt.c,v 1.5 88/09/17 07:21:21 mike Exp $ (BRL)";
d45 1
a45 1
struct	matparse stxt_parse[] = {
d47 2
a48 2
	"transp",	(mp_off_ty)(SOL_NULL->stx_transp),"%C",
	"file",		(mp_off_ty)(SOL_NULL->stx_file),	"%s",
d50 2
a51 2
	"transp",	(mp_off_ty)0,			"%C",
	"file",		(mp_off_ty)1,			"%s",
d53 5
a57 5
	"w",		(mp_off_ty)&(SOL_NULL->stx_w),	"%d",
	"n",		(mp_off_ty)&(SOL_NULL->stx_n),	"%d",
	"d",		(mp_off_ty)&(SOL_NULL->stx_d),	"%d",
	"fw",		(mp_off_ty)&(SOL_NULL->stx_fw),	"%d",
	(char *)0,	(mp_off_ty)0,		(char *)0
d156 1
a156 1
	mlib_parse( matparm, stxt_parse, (mp_off_ty)stp );
@


1.5
log
@cray-->CRAY.  The C compiler bug still remains.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: stxt.c,v 1.4 88/09/09 01:56:04 mike Locked $ (BRL)";
@


1.4
log
@Changed iptr to proper type
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: stxt.c,v 1.3 88/06/21 02:53:41 mike Exp $ (BRL)";
d46 1
a46 1
#ifndef cray
@


1.3
log
@Made number of scanlines (height) parameter be "n",
and width be "w", to be consistent with the BRLCAD convention,
as exhibited by pix-fb and many others.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: stxt.c,v 1.2 88/06/21 00:59:13 mike Locked $ (BRL)";
d188 1
a188 1
	int iptr;
@


1.2
log
@Removed local routine "rpp_tree" and changed to using library
routine "rt_rpp_tree".
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: stxt.c,v 1.1 88/06/16 03:47:48 mike Exp $ (BRL)";
d36 2
a37 2
	int	stx_l;		/* Length of pixels in lines */
	int	stx_h;		/* Depth of texture in pixels (Numfiles)*/
d54 2
a55 2
	"l",		(mp_off_ty)&(SOL_NULL->stx_l),	"%d",
	"h",		(mp_off_ty)&(SOL_NULL->stx_h),	"%d",
d95 1
a95 1
		stp->stx_w * stp->stx_l * stp->stx_h * 3,
d103 1
a103 1
	for( frame=0; frame <= stp->stx_h-1; frame++ )  {
d114 1
a114 1
		for( i = 0; i < stp->stx_l; i++ )  {
d149 1
a149 1
	stp->stx_w = stp->stx_fw = stp->stx_l = stp->stx_h = -1;
d159 1
a159 1
	if( stp->stx_l < 0 )  stp->stx_l = stp->stx_w;
d162 1
a162 1
	if( stp->stx_h < 0 )  stp->stx_h = 1;
d226 1
a226 1
	f = VDOT( swp->sw_hit.hit_point, ly ) / (float)stp->stx_l;
d237 1
a237 1
	f = VDOT( swp->sw_hit.hit_point, lz ) / (float)stp->stx_h;
d252 2
a253 2
	ty = sy * stp->stx_l;
	tz = sz * stp->stx_h;
d255 1
a255 1
	u1 = (int)tz * stp->stx_l * stp->stx_w *  3.0;
d312 2
a313 2
	ty = sy * stp->stx_l;
	tz = sz * stp->stx_h;
d315 1
a315 1
	u1 = (int)tz * stp->stx_l * stp->stx_w *  3.0;
d379 2
a380 2
	ty = sy * stp->stx_l;
	tz = sz * stp->stx_h;
d382 1
a382 1
	u1 = (int)tz * stp->stx_l * stp->stx_w *  3.0;
@


1.1
log
@Initial revision
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
a75 1

a76 53
 *			R P P _ T R E E
 *
 *	NOTE: Modified slightly from librt/tree.c:rt_rpp_tree()
 *
 *	Calculate the bounding RPP of the region whose boolean tree is 'tp'.
 *	Depends on caller having initialized min_rpp and max_rpp.
 *	Returns 0 for failure (and prints a diagnostic), or 1 for success.
 */
HIDDEN int
rpp_tree( tp, min_rpp, max_rpp )
register union tree *tp;
register fastf_t *min_rpp, *max_rpp;
{	
	register int i;

	if( tp == TREE_NULL )  {
		rt_log( "styx:rpp_tree: NULL tree pointer.\n" );
		return(0);
	}

	switch( tp->tr_op )  {

	case OP_SOLID:
		VMIN( min_rpp, tp->tr_a.tu_stp->st_min );
		VMAX( max_rpp, tp->tr_a.tu_stp->st_max );
		return(1);

	default:
		rt_log( "styx:rpp_tree: unknown op=x%x\n", tp->tr_op );
		return(0);

	case OP_UNION:
	case OP_INTERSECT:
	case OP_SUBTRACT:
	case OP_XOR:
		/* BINARY type */
		if( !rpp_tree( tp->tr_b.tb_left, min_rpp, max_rpp )  ||
		    !rpp_tree( tp->tr_b.tb_right, min_rpp, max_rpp )  )
			return	0;
		break;
	case OP_NOT:
	case OP_GUARD:
		/* UNARY tree */
		if( !rpp_tree( tp->tr_b.tb_left, min_rpp, max_rpp ) )
			return	0;
		break;
	}
	return	1;
}



/*
d153 1
a153 1
	rpp_tree(rp->reg_treetop,stp->stx_min,stp->stx_max);
@
