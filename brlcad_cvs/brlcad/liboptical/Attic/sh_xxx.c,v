head	1.37;
access;
symbols
	ansi-20040405-merged:1.33.2.2
	postmerge-20040405-ansi:1.35
	premerge-20040404-ansi:1.34
	postmerge-autoconf:1.34
	autoconf-freeze:1.34
	premerge-autoconf:1.34
	ansi-20040316-freeze:1.33.2.1
	postmerge-20040315-windows:1.34
	premerge-20040315-windows:1.34
	windows-20040315-freeze:1.33.4.1
	autoconf-20031203:1.34
	autoconf-20031202:1.34
	autoconf-branch:1.34.0.4
	phong-branch:1.34.0.2
	photonmap-branch:1.33.0.6
	rel-6-1-DP:1.33
	windows-branch:1.33.0.4
	rel-6-0-2:1.31
	ansi-branch:1.33.0.2
	rel-6-0-1-branch:1.31.0.2
	hartley-6-0-post:1.32
	hartley-6-0-pre:1.31
	rel-6-0-1:1.31
	rel-6-0:1.31
	rel-5-4:1.24
	offsite-5-3-pre:1.29
	rel-5-3:1.24
	rel-5-2:1.24
	rel-5-1-branch:1.24.0.2
	rel-5-1:1.24
	rel-5-0:1.21
	rel-5-0-beta:1.19
	rel-4-5:1.15
	ctj-4-5-post:1.14
	ctj-4-5-pre:1.14;
locks; strict;
comment	@ * @;


1.37
date	2004.05.21.18.07.28;	author morrison;	state dead;
branches;
next	1.36;

1.36
date	2004.05.10.15.30.45;	author erikg;	state Exp;
branches;
next	1.35;

1.35
date	2004.04.05.07.43.37;	author morrison;	state Exp;
branches;
next	1.34;

1.34
date	2003.07.28.20.33.23;	author butler;	state Exp;
branches;
next	1.33;

1.33
date	2002.08.20.17.07.52;	author jra;	state Exp;
branches
	1.33.2.1
	1.33.4.1
	1.33.6.1;
next	1.32;

1.32
date	2002.08.15.20.55.05;	author hartley;	state Exp;
branches;
next	1.31;

1.31
date	2001.10.17.07.40.03;	author morrison;	state Exp;
branches;
next	1.30;

1.30
date	2001.04.20.22.29.33;	author morrison;	state Exp;
branches;
next	1.29;

1.29
date	2000.11.19.16.44.05;	author butler;	state Exp;
branches;
next	1.28;

1.28
date	2000.09.09.04.30.52;	author mike;	state Exp;
branches;
next	1.27;

1.27
date	2000.08.24.19.07.46;	author butler;	state Exp;
branches;
next	1.26;

1.26
date	2000.08.24.18.19.43;	author butler;	state Exp;
branches;
next	1.25;

1.25
date	2000.07.25.16.40.39;	author butler;	state Exp;
branches;
next	1.24;

1.24
date	2000.06.21.21.37.26;	author butler;	state Exp;
branches;
next	1.23;

1.23
date	2000.02.19.21.05.02;	author butler;	state Exp;
branches;
next	1.22;

1.22
date	99.10.30.03.06.25;	author butler;	state Exp;
branches;
next	1.21;

1.21
date	99.07.02.22.20.42;	author mike;	state Exp;
branches;
next	1.20;

1.20
date	99.07.01.20.08.50;	author mike;	state Exp;
branches;
next	1.19;

1.19
date	99.05.05.20.14.16;	author jra;	state Exp;
branches;
next	1.18;

1.18
date	99.02.22.18.14.04;	author butler;	state Exp;
branches;
next	1.17;

1.17
date	98.09.22.01.29.56;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	98.06.30.22.54.19;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	97.12.31.09.01.40;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	97.01.31.02.19.10;	author butler;	state Exp;
branches;
next	1.13;

1.13
date	97.01.07.23.47.29;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	97.01.07.23.47.03;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	96.09.27.04.30.27;	author butler;	state Exp;
branches;
next	1.10;

1.10
date	96.08.31.08.46.01;	author butler;	state Exp;
branches;
next	1.9;

1.9
date	96.08.31.08.29.28;	author butler;	state Exp;
branches;
next	1.8;

1.8
date	96.08.30.00.08.21;	author butler;	state Exp;
branches;
next	1.7;

1.7
date	96.05.22.18.08.10;	author jra;	state Exp;
branches;
next	1.6;

1.6
date	96.01.06.03.51.25;	author butler;	state Exp;
branches;
next	1.5;

1.5
date	96.01.05.23.54.32;	author butler;	state Exp;
branches;
next	1.4;

1.4
date	96.01.04.23.57.59;	author butler;	state Exp;
branches;
next	1.3;

1.3
date	95.10.20.04.43.53;	author butler;	state Exp;
branches;
next	1.2;

1.2
date	95.10.20.04.29.25;	author butler;	state Exp;
branches;
next	1.1;

1.1
date	95.08.19.05.07.33;	author butler;	state Exp;
branches;
next	;

1.33.2.1
date	2002.09.19.18.01.27;	author morrison;	state Exp;
branches;
next	1.33.2.2;

1.33.2.2
date	2004.03.17.21.18.33;	author morrison;	state Exp;
branches;
next	;

1.33.4.1
date	2004.03.11.23.43.03;	author morrison;	state Exp;
branches;
next	;

1.33.6.1
date	2003.08.26.13.53.45;	author justin;	state Exp;
branches;
next	;


desc
@shader prototype
@


1.37
log
@moved to src/
@
text
@/*
 *	S H _ X X X . C
 *
 *  To add a new shader to the "rt" program's LIBOPTICAL library:
 *
 *	1) Copy this file to sh_shadername.c
 *	2) edit sh_shadername.c:
 *		change "X X X" to "S H A D E R N A M E"
 *		change "xxx"   to "shadername"
 *		Set a new number for the xxx_MAGIC define
 *		define shader specific structure and defaults
 *		edit/build parse table for bu_structparse from xxx_parse
 *		edit/build shader_mfuncs tables from xxx_mfuncs for
 *			each shader name being built.
 *		edit the xxx_setup function to do shader-specific setup
 *		edit the xxx_render function to do the actual rendering
 *
 *  If you are building a dynamically loaded shader, compile this into a
 *  shared library called "shadername.so".  If you have a number of shaders
 *  for you are adding, you can create a single library called "shaders.so"
 *  which contains all of your DSO shaders.
 *
 *  RT will look in the following locations for DSO shaders:
 *		./
 *		BRLCAD_ROOT/lib/
 *		$LD_LIBRARY_PATH
 *
 *  If you are adding the shader to "rt" as a permanent shader, then the
 *  following steps are necessary:
 *
 *	3) Edit init.c to add extern for xxx_mfuncs and 
 *		a call to mlib_add_shader().
 *	4) Edit Cakefile to add shader file to "FILES" macro (without the .o)
 *	5) replace this list with a description of the shader, its parameters
 *		and use.
 *	6) Edit shaders.tcl and comb.tcl in the ../tclscripts/mged directory to
 *		add a new gui for this shader.
 *
 *
 */
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "shadefuncs.h"
#include "shadework.h"
#include "rtprivate.h"

extern int rr_render(struct application	*ap,
		     struct partition	*pp,
		     struct shadework   *swp);
#define xxx_MAGIC 0x1834    /* make this a unique number for each shader */
#define CK_xxx_SP(_p) BU_CKMAG(_p, xxx_MAGIC, "xxx_specific")

/*
 * the shader specific structure contains all variables which are unique
 * to any particular use of the shader.
 */
struct xxx_specific {
	long	magic;	/* magic # for memory validity check, must come 1st */
	double	xxx_val;	/* variables for shader ... */
	double	xxx_dist;
	vect_t	xxx_delta;
	point_t xxx_min;
	point_t xxx_max;
	mat_t	xxx_m_to_sh;	/* model to shader space matrix */
	mat_t	xxx_m_to_r;	/* model to shader space matrix */
};

/* The default values for the variables in the shader specific structure */
const static
struct xxx_specific xxx_defaults = {
	xxx_MAGIC,
	1.0,				/* xxx_val */
	0.0,				/* xxx_dist */
	{ 1.0, 1.0, 1.0 },		/* xxx_delta */
	{ 0.0, 0.0, 0.0 },		/* xxx_min */
	{ 0.0, 0.0, 0.0 },		/* xxx_max */
	{	0.0, 0.0, 0.0, 0.0,	/* xxx_m_to_sh */
		0.0, 0.0, 0.0, 0.0,
		0.0, 0.0, 0.0, 0.0,
		0.0, 0.0, 0.0, 0.0 },
	{	0.0, 0.0, 0.0, 0.0,	/* xxx_m_to_r */
		0.0, 0.0, 0.0, 0.0,
		0.0, 0.0, 0.0, 0.0,
		0.0, 0.0, 0.0, 0.0 }
	};

#define SHDR_NULL	((struct xxx_specific *)0)
#define SHDR_O(m)	offsetof(struct xxx_specific, m)
#define SHDR_AO(m)	bu_offsetofarray(struct xxx_specific, m)


/* description of how to parse/print the arguments to the shader
 * There is at least one line here for each variable in the shader specific
 * structure above
 */
struct bu_structparse xxx_print_tab[] = {
	{"%f",  1, "val",		SHDR_O(xxx_val),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",  1, "dist",		SHDR_O(xxx_dist),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",  3, "delta",		SHDR_AO(xxx_delta),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",  3, "max",		SHDR_AO(xxx_max),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",  3, "min",		SHDR_AO(xxx_min),	BU_STRUCTPARSE_FUNC_NULL },
	{"",	0, (char *)0,		0,			BU_STRUCTPARSE_FUNC_NULL }

};
struct bu_structparse xxx_parse_tab[] = {
	{"i",	bu_byteoffset(xxx_print_tab[0]), "xxx_print_tab", 0, BU_STRUCTPARSE_FUNC_NULL },
	{"%f",  1, "v",		SHDR_O(xxx_val),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",  1, "dist",	SHDR_O(xxx_dist),	bu_mm_cvt },
	{"%f",  3, "d",		SHDR_AO(xxx_delta),	BU_STRUCTPARSE_FUNC_NULL },
	{"",	0, (char *)0,	0,			BU_STRUCTPARSE_FUNC_NULL }
};

HIDDEN int	xxx_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip), xxx_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
HIDDEN void	xxx_print(register struct region *rp, char *dp), xxx_free(char *cp);

/* The "mfuncs" structure defines the external interface to the shader.
 * Note that more than one shader "name" can be associated with a given
 * shader by defining more than one mfuncs struct in this array.
 * See sh_phong.c for an example of building more than one shader "name"
 * from a set of source functions.  There you will find that "glass" "mirror"
 * and "plastic" are all names for the same shader with different default
 * values for the parameters.
 */
struct mfuncs xxx_mfuncs[] = {
	{MF_MAGIC,	"xxx",	0,	MFI_NORMAL|MFI_HIT|MFI_UV,	0,
	xxx_setup,	xxx_render,	xxx_print,	xxx_free },

	{0,		(char *)0,	0,		0,		0,
	0,		0,		0,		0 }
};


/*	X X X _ S E T U P
 *
 *	This routine is called (at prep time)
 *	once for each region which uses this shader.
 *	Any shader-specific initialization should be done here.
 * 
 * 	Returns:
 *	1	success
 *	0	success, but delete region
 *	-1	failure
 */
HIDDEN int
xxx_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip)
                      	    
             		         
    			      	/* pointer to reg_udata in *rp */
             		     
           		      	/* New since 4.4 release */
{
	register struct xxx_specific	*xxx_sp;
	mat_t	tmp;
	vect_t	bb_min, bb_max, v_tmp;

	/* check the arguments */
	RT_CHECK_RTI(rtip);
	BU_CK_VLS( matparm );
	RT_CK_REGION(rp);


	if (rdebug&RDEBUG_SHADE)
		bu_log("xxx_setup(%s)\n", rp->reg_name);

	/* Get memory for the shader parameters and shader-specific data */
	BU_GETSTRUCT( xxx_sp, xxx_specific );
	*dpp = (char *)xxx_sp;

	/* initialize the default values for the shader */
	memcpy(xxx_sp, &xxx_defaults, sizeof(struct xxx_specific) );

	/* parse the user's arguments for this use of the shader. */
	if (bu_struct_parse( matparm, xxx_parse_tab, (char *)xxx_sp ) < 0 )
		return(-1);

	/* Optional:
	 *
	 * If the shader needs to operate in a coordinate system which stays
	 * fixed on the region when the region is moved (as in animation)
	 * we need to get a matrix to perform the appropriate transform(s).
	 *
	 * db_shader_mat returns a matrix which maps points on/in the region
	 * into the unit cube.  This unit cube is formed by first mapping from
	 * world coordinates into "region coordinates" (the coordinate system
	 * in which the region is defined).  Then the bounding box of the 
	 * region is used to establish a mapping to the unit cube
	 *
*	db_shader_mat(xxx_sp->xxx_m_to_sh, rtip, rp, xxx_sp->xxx_min,
*		xxx_sp->xxx_max);
	 *
	 * Alternatively, shading may be done in "region coordinates"
	 * if desired:
	 *
*	db_region_mat(xxx_sp->xxx_m_to_r, rtip->rti_dbip, rp->reg_name, &rt_uniresource);
	 *
	 */

	if (rdebug&RDEBUG_SHADE) {
		bu_struct_print( " Parameters:", xxx_print_tab, (char *)xxx_sp );
		bn_mat_print( "m_to_sh", xxx_sp->xxx_m_to_sh );
	}

	return(1);
}

/*
 *	X X X _ P R I N T
 */
HIDDEN void
xxx_print(register struct region *rp, char *dp)
{
	bu_struct_print( rp->reg_name, xxx_print_tab, (char *)dp );
}

/*
 *	X X X _ F R E E
 */
HIDDEN void
xxx_free(char *cp)
{
	bu_free( cp, "xxx_specific" );
}

/*
 *	X X X _ R E N D E R
 *
 *	This is called (from viewshade() in shade.c) once for each hit point
 *	to be shaded.  The purpose here is to fill in values in the shadework
 *	structure.
 */
int
xxx_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
                  	    
                	    
                	     	/* defined in ../h/shadework.h */
    			    	/* ptr to the shader-specific struct */
{
	register struct xxx_specific *xxx_sp =
		(struct xxx_specific *)dp;
	point_t pt;

	/* check the validity of the arguments we got */
	RT_AP_CHECK(ap);
	RT_CHECK_PT(pp);
	CK_xxx_SP(xxx_sp);

	if (rdebug&RDEBUG_SHADE)
		bu_struct_print( "xxx_render Parameters:", xxx_print_tab, (char *)xxx_sp );

	/* If we are performing the shading in "region" space, we must 
	 * transform the hit point from "model" space to "region" space.
	 * See the call to db_region_mat in xxx_setup().
	MAT4X3PNT(pt, xxx_sp->xxx_m_to_sh, swp->sw_hit.hit_point);
	MAT4X3PNT(pt, xxx_sp->xxx_m_to_r, swp->sw_hit.hit_point);

	if (rdebug&RDEBUG_SHADE) {
		bu_log("xxx_render()  model:(%g %g %g) shader:(%g %g %g)\n", 
			V3ARGS(swp->sw_hit.hit_point),
			V3ARGS(pt) );
	}
	 */

	/* XXX perform shading operations here */
	VMOVE(swp->sw_color, pt);

	/* shader must perform transmission/reflection calculations
	 *
	 * 0 < swp->sw_transmit <= 1 causes transmission computations
	 * 0 < swp->sw_reflect <= 1 causes reflection computations
	 */
	if (swp->sw_reflect > 0 || swp->sw_transmit > 0 )
		(void)rr_render( ap, pp, swp );

	return(1);
}
@


1.36
log
@change conf.h to a wrapped config.h
@
text
@@


1.35
log
@merge of ansi-6-0-branch into HEAD
@
text
@d41 5
a45 1
#include "conf.h"
@


1.34
log
@Minor formatting change.
@
text
@d118 2
a119 2
HIDDEN int	xxx_setup(), xxx_render();
HIDDEN void	xxx_print(), xxx_free();
d150 6
a155 6
xxx_setup( rp, matparm, dpp, mfp, rtip)
register struct region	*rp;
struct bu_vls		*matparm;
char			**dpp;	/* pointer to reg_udata in *rp */
struct mfuncs		*mfp;
struct rt_i		*rtip;	/* New since 4.4 release */
d215 1
a215 3
xxx_print( rp, dp )
register struct region *rp;
char	*dp;
d224 1
a224 2
xxx_free( cp )
char *cp;
d237 5
a241 5
xxx_render( ap, pp, swp, dp )
struct application	*ap;
struct partition	*pp;
struct shadework	*swp;	/* defined in ../h/shadework.h */
char			*dp;	/* ptr to the shader-specific struct */
@


1.33
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d130 1
a130 1
	{MF_MAGIC,	"xxx",		0,		MFI_NORMAL|MFI_HIT|MFI_UV,	0,
@


1.33.4.1
log
@sync to HEAD...
@
text
@d130 1
a130 1
	{MF_MAGIC,	"xxx",	0,	MFI_NORMAL|MFI_HIT|MFI_UV,	0,
@


1.33.6.1
log
@merging for photonmap branch
@
text
@d130 1
a130 1
	{MF_MAGIC,	"xxx",	0,	MFI_NORMAL|MFI_HIT|MFI_UV,	0,
@


1.33.2.1
log
@Initial ANSIfication
@
text
@d118 2
a119 2
HIDDEN int	xxx_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip), xxx_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
HIDDEN void	xxx_print(register struct region *rp, char *dp), xxx_free(char *cp);
d150 6
a155 6
xxx_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip)
                      	    
             		         
    			      	/* pointer to reg_udata in *rp */
             		     
           		      	/* New since 4.4 release */
d215 3
a217 1
xxx_print(register struct region *rp, char *dp)
d226 2
a227 1
xxx_free(char *cp)
d240 5
a244 5
xxx_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
                  	    
                	    
                	     	/* defined in ../h/shadework.h */
    			    	/* ptr to the shader-specific struct */
@


1.33.2.2
log
@sync branch with HEAD
@
text
@d130 1
a130 1
	{MF_MAGIC,	"xxx",	0,	MFI_NORMAL|MFI_HIT|MFI_UV,	0,
@


1.32
log
@Converted from K&R to ANSI C - RFH
@
text
@d118 2
a119 2
HIDDEN int	xxx_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip), xxx_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
HIDDEN void	xxx_print(register struct region *rp, char *dp), xxx_free(char *cp);
d150 6
a155 6
xxx_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip)
                      	    
             		         
    			      	/* pointer to reg_udata in *rp */
             		     
           		      	/* New since 4.4 release */
d215 3
a217 1
xxx_print(register struct region *rp, char *dp)
d226 2
a227 1
xxx_free(char *cp)
d240 5
a244 5
xxx_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
                  	    
                	    
                	     	/* defined in ../h/shadework.h */
    			    	/* ptr to the shader-specific struct */
@


1.31
log
@Mac OS X warning and error fixes for non-production build
@
text
@d118 2
a119 2
HIDDEN int	xxx_setup(), xxx_render();
HIDDEN void	xxx_print(), xxx_free();
d150 6
a155 6
xxx_setup( rp, matparm, dpp, mfp, rtip)
register struct region	*rp;
struct bu_vls		*matparm;
char			**dpp;	/* pointer to reg_udata in *rp */
struct mfuncs		*mfp;
struct rt_i		*rtip;	/* New since 4.4 release */
d215 1
a215 3
xxx_print( rp, dp )
register struct region *rp;
char	*dp;
d224 1
a224 2
xxx_free( cp )
char *cp;
d237 5
a241 5
xxx_render( ap, pp, swp, dp )
struct application	*ap;
struct partition	*pp;
struct shadework	*swp;	/* defined in ../h/shadework.h */
char			*dp;	/* ptr to the shader-specific struct */
@


1.30
log
@CONST to const
@
text
@d138 1
a138 1
/*	X X X _ S E T U P
d211 1
a211 1
/*
d232 1
a232 1
/*
@


1.29
log
@Changed comment to reflect return code behaviour
@
text
@d74 1
a74 1
CONST static
@


1.28
log
@
Struct db_tree_state finally got a magic number. Added resource argument
to ft_describe(), db_region_mat(), db_shader_mat(),
db_init_db_tree_state(), and db_path_to_mat().
@
text
@d143 5
@


1.27
log
@Extra shader comments about how to build DSO shaders
@
text
@d194 1
a194 1
*	db_region_mat(xxx_sp->xxx_m_to_r, rtip->rti_dbip, rp->reg_name);
@


1.26
log
@Fixed a comilation error
@
text
@d17 14
d38 2
@


1.25
log
@Changes to use rtprivate.h instead of ../rt/rdebug.h
@
text
@d69 1
a69 1
		0.0, 0.0, 0.0, 0.0 }
a241 1
	 */
d245 2
a246 2
		V3ARGS(swp->sw_hit.hit_point),
		V3ARGS(pt) );
d248 1
@


1.24
log
@Definition of shadework struct now in shadework.h not material.h
@
text
@d34 1
a34 1
#include "../rt/rdebug.h"
d36 3
@


1.23
log
@Changes to support movement of CLAMP() macro into vmath.h
Altered "if( " statements to "if (" for readability.
@
text
@d219 1
a219 1
struct shadework	*swp;	/* defined in material.h */
@


1.22
log
@Moved mathtab/rand_half from rt into libbn
Expanded structparse to include description and default
@
text
@d143 1
a143 1
	if( rdebug&RDEBUG_SHADE)
d154 1
a154 1
	if( bu_struct_parse( matparm, xxx_parse_tab, (char *)xxx_sp ) < 0 )
d179 1
a179 1
	if( rdebug&RDEBUG_SHADE) {
d231 1
a231 1
	if( rdebug&RDEBUG_SHADE)
d241 1
a241 1
	if( rdebug&RDEBUG_SHADE) {
d255 1
a255 1
	if( swp->sw_reflect > 0 || swp->sw_transmit > 0 )
@


1.21
log
@
Removed dependence on compat4.h
@
text
@a33 1
#include "../rt/mathtab.h"
@


1.20
log
@
compat4
@
text
@d84 6
a89 6
	{"%f",  1, "val",		SHDR_O(xxx_val),	FUNC_NULL },
	{"%f",  1, "dist",		SHDR_O(xxx_dist),	FUNC_NULL },
	{"%f",  3, "delta",		SHDR_AO(xxx_delta),	FUNC_NULL },
	{"%f",  3, "max",		SHDR_AO(xxx_max),	FUNC_NULL },
	{"%f",  3, "min",		SHDR_AO(xxx_min),	FUNC_NULL },
	{"",	0, (char *)0,		0,			FUNC_NULL }
d94 1
a94 1
	{"%f",  1, "v",		SHDR_O(xxx_val),	FUNC_NULL },
d96 2
a97 2
	{"%f",  3, "d",		SHDR_AO(xxx_delta),	FUNC_NULL },
	{"",	0, (char *)0,	0,			FUNC_NULL }
@


1.19
log
@Added comment about adding a gui for the shader.
@
text
@d38 1
a38 1
#define CK_xxx_SP(_p) RT_CKMAG(_p, xxx_MAGIC, "xxx_specific")
d76 1
a76 1
#define SHDR_AO(m)	offsetofarray(struct xxx_specific, m)
d93 1
a93 1
	{"i",	bu_byteoffset(xxx_print_tab[0]), "xxx_print_tab", 0, FUNC_NULL },
d129 1
a129 1
struct rt_vls		*matparm;
d140 1
a140 1
	RT_VLS_CHECK( matparm );
d145 1
a145 1
		rt_log("xxx_setup(%s)\n", rp->reg_name);
d148 1
a148 1
	GETSTRUCT( xxx_sp, xxx_specific );
d182 1
a182 1
		mat_print( "m_to_sh", xxx_sp->xxx_m_to_sh );
d206 1
a206 1
	rt_free( cp, "xxx_specific" );
d243 1
a243 1
		rt_log("xxx_render()  model:(%g %g %g) shader:(%g %g %g)\n", 
@


1.18
log
@Added example for "xxx_dist" and "xxx_m_to_r" usage.
@
text
@d22 2
@


1.17
log
@Moved optical shaders from rt/ to liboptical/
The only modifications involved moving and splitting
rt/material.h into h/shadefuncs.h and h/shadework.h,
and in changing the calling sequence to mlib_setup() in rt/material.c

Now the only shader function called directly by RT is
in liboptical/init.c: optical_shader_init().
It adds all the individual shaders to the "mfuncs" shader list.
@
text
@d45 1
d50 1
d58 1
d66 4
d83 1
d92 4
a95 3
	{"%f",  1, "v",			SHDR_O(xxx_val),	FUNC_NULL },
	{"%f",  3, "d",			SHDR_AO(xxx_delta),	FUNC_NULL },
	{"",	0, (char *)0,		0,			FUNC_NULL }
d174 1
a174 1
*	db_region_mat(model_to_region, rtip->rti_dbip, rp->reg_name);	 
d236 2
a238 1
	MAT4X3PNT(pt, xxx_sp->xxx_m_to_sh, swp->sw_hit.hit_point);
@


1.16
log
@Can't make "struct mfuncs" a CONST, because the forward link needs
to be filled in at runtime, and some compilers put CONST data into
read-only pages (like FreeBSD).
@
text
@d4 1
a4 1
 *  To add a new shader to the "rt" program:
d17 3
a19 3
 *	3) Edit view.c to add extern for xxx_mfuncs and call to mlib_add
 *		to function view_init()
 *	4) Edit Cakefile to add shader file to "FILES" and "RT_OBJ" macros.
d30 4
a33 3
#include "./material.h"
#include "./mathtab.h"
#include "./rdebug.h"
@


1.15
log
@Required magic number to be first in mfunc table,
consistent with all other BRL-CAD magic numbers.
Required magic number to be initialized at compile time.
Added code to check the magic numbers.
Made the xxx_mfunc arrays CONST, so they can't get trashed by
runtime runaway pointer problems.
@
text
@d99 1
a99 1
CONST struct mfuncs xxx_mfuncs[] = {
@


1.14
log
@misc cleanup
@
text
@d99 2
a100 2
struct mfuncs xxx_mfuncs[] = {
	{"xxx",	0,	0,		MFI_NORMAL|MFI_HIT|MFI_UV,	0,
d103 1
a103 1
	{(char *)0,	0,		0,		0,		0,
@


1.13
log
@Changed to bu_byteoffset
@
text
@d54 5
a58 3
	1.0,
	{ 1.0, 1.0, 1.0 },
	{	0.0, 0.0, 0.0, 0.0,
d157 9
a166 4

	db_shader_mat(xxx_sp->xxx_m_to_sh, rtip, rp, xxx_sp->xxx_min,
		xxx_sp->xxx_max);

@


1.12
log
@Butler mods
@
text
@a33 29
/*
 *  Generic settable parameters.
 *  By setting the "base address" to zero in the bu_structparse call,
 *  the actual memory address is given here as the structure offset.
 *
 *  Strictly speaking, the C language only permits initializers of the
 *  form: address +- constant, where here the intent is to measure the
 *  byte address of the indicated variable.
 *  Matching compensation code for the CRAY is located in librt/parse.c
 */
#if CRAY
#	define byteoffset(_i)	(((int)&(_i)))	/* actually a word offset */
#else
#  if IRIX > 5
#	define byteoffset(_i)	((long)((char *)&(_i)))
#  else
#    if sgi || __convexc__ || ultrix || _HPUX_SOURCE
	/* "Lazy" way.  Works on reasonable machines with byte addressing */
#	define byteoffset(_i)	((int)((char *)&(_i)))
#    else
	/* "Conservative" way of finding # bytes as diff of 2 char ptrs */
#	define byteoffset(_i)	((int)(((char *)&(_i))-((char *)0)))
#    endif
#  endif
#endif




d80 1
a80 1
	{"i",	byteoffset(xxx_print_tab[0]), "xxx_print_tab", 0, FUNC_NULL },
@


1.11
log
@db_shader_mat() parameter change
@
text
@d74 2
d103 2
d186 2
a187 1
	db_shader_mat(xxx_sp->xxx_m_to_sh, rtip, rp);
@


1.10
log
@bu_struct_print
@
text
@d174 6
d182 1
a182 1
	db_shader_mat(xxx_sp->xxx_m_to_sh, rtip->rti_dbip, rp);
@


1.9
log
@bu_struct_parse
@
text
@d180 1
a180 1
		bu_structprint( " Parameters:", xxx_print_tab, (char *)xxx_sp );
d195 1
a195 1
	bu_structprint( rp->reg_name, xxx_print_tab, (char *)dp );
d232 1
a232 1
		bu_structprint( "xxx_render Parameters:", xxx_print_tab, (char *)xxx_sp );
@


1.8
log
@structparse moved to libbu
@
text
@d166 1
a166 1
	if( bu_structparse( matparm, xxx_parse_tab, (char *)xxx_sp ) < 0 )
@


1.7
log
@Added call to rr_render().
@
text
@d12 1
a12 1
 *		edit/build parse table for structparse from xxx_parse
d36 1
a36 1
 *  By setting the "base address" to zero in the rt_structparse call,
d98 1
a98 1
struct structparse xxx_print_tab[] = {
d104 1
a104 1
struct structparse xxx_parse_tab[] = {
d166 1
a166 1
	if( rt_structparse( matparm, xxx_parse_tab, (char *)xxx_sp ) < 0 )
d180 1
a180 1
		rt_structprint( " Parameters:", xxx_print_tab, (char *)xxx_sp );
d195 1
a195 1
	rt_structprint( rp->reg_name, xxx_print_tab, (char *)dp );
d232 1
a232 1
		rt_structprint( "xxx_render Parameters:", xxx_print_tab, (char *)xxx_sp );
@


1.6
log
@fixed structparse include by adding byteoffset() macro from do.c
@
text
@d249 1
a249 2
	/* caller will perform transmission/reflection calculations
	 * based upon the values of swp->sw_transmit and swp->sw_reflect
d254 2
@


1.5
log
@misc polishing and syntax fixes
@
text
@d34 26
d61 2
d93 1
d105 1
a105 1
	{"i",	(long)(xxx_print_tab), (char *)0, 0,		FUNC_NULL },
@


1.4
log
@added model to shader matrix calculations
@
text
@d17 2
a18 2
 *	3) Edit view.c to add extern for shader_mfuncs and call to mlib_add
 *	   to function view_init()
d20 2
a45 1
	char	*xxx_reg_name;
a54 1
	(char *) NULL,
d70 2
a71 2
	{"%f",  1, "val",		SHDR_O(val),		FUNC_NULL },
	{"%f",  3, "delta",		SHDR_AO(delta),		FUNC_NULL },
d77 2
a78 2
	{"%f",  1, "v",			SHDR_O(val),		FUNC_NULL },
	{"%f",  3, "d",			SHDR_AO(delta),		FUNC_NULL },
d94 1
a94 1
	{"cs",	0,	0,		MFI_NORMAL|MFI_HIT|MFI_UV,	0,
d147 1
a147 1
	db_shader_mat(xxx_sp->m_to_sh, rtip->rti_dbip, rp);
a148 1
	xxx_sp->xxx_reg_name = rt_strdup(rp->reg_name);
d152 1
a152 1
		mat_print( "m_to_sh", xxx_sp->m_to_sh );
d203 1
a203 1
		rt_structprint( "cs", xxx_print_tab, (char *)xxx_sp );
d209 1
a209 1
	MAT4X3PNT(pt, xxx_sp->m_to_sh, swp->sw_hit.hit_point);
d211 2
a212 4

	if( rdebug&RDEBUG_SHADE)
		rt_log("xxx_render(%s)  model:(%g %g %g)\nxxx_render(%s) region:(%g %g %g)\n", 
		xxx_sp->xxx_reg_name,
a213 1
		xxx_sp->xxx_reg_name,
d215 1
@


1.3
log
@edited mfuncs table to account for new "mf_flags" element in struct mfuncs.
@
text
@d8 3
d19 1
d33 1
a33 1
#define xxx_MAGIC 0x18364    /* make this a unique number for each shader */
d37 2
a38 2
 * the shader specific structure contains all variables which unique to any
 * particular use of the shader.
d42 4
a45 3
	double	val;	/* variables for shader ... */
	vect_t	delta;
	mat_t	xform;
d54 5
a58 4
	{	1.0, 0.0, 0.0, 0.0,
		0.0, 1.0, 0.0, 0.0,
		0.0, 0.0, 1.0, 0.0,
		0.0, 0.0, 0.0, 1.0 }
d65 5
a69 2
/* description of how to parse/print the arguments to the shader */
struct structparse xxx_parse[] = {
d71 6
a77 1
	{"%f",  3, "delta",		SHDR_AO(delta),		FUNC_NULL },
d88 4
d94 1
a94 1
	{"xxx",	0,	0,		MFI_NORMAL|MFI_HIT|MFI_UV,	0,
d118 1
d120 1
d124 6
d137 1
a137 1
	if( rt_structparse( matparm, xxx_parse, (char *)xxx_sp ) < 0 )
d140 1
a140 2
	/* Optional:  get the matrix which maps model space into
	 *  "region" or "shader" space.
a145 1
	db_region_mat(xxx_sp->xform, rtip->rti_dbip, rp->reg_name);
d147 1
a147 8
	/* Example:  append parameter translations to transformation
	 * 	from "model" to "region" space.
	 */
	mat_idn(tmp);
	tmp[MDX] = xxx_sp->delta[0];
	tmp[MDY] = xxx_sp->delta[1];
	tmp[MDZ] = xxx_sp->delta[2];
	mat_mul2(tmp, xxx_sp->xform);
d149 1
d152 2
a153 2
		rt_structprint( rp->reg_name, xxx_parse, (char *)xxx_sp );
		mat_print( "xform", xxx->xform );
d167 1
a167 1
	rt_structprint( rp->reg_name, xxx_parse, (char *)dp );
d183 3
a185 2
 *	This is called (from viewshade() in shade.c)
 *	once for each hit point to be shaded.
d191 2
a192 2
struct shadework	*swp;
char	*dp;
d198 1
d204 1
a204 1
		rt_structprint( "xxx", xxx_parse, (char *)xxx_sp );
d210 1
a210 1
	MAT4X3PNT(pt, xxx_sp->xform, swp->sw_hit.hit_point);
d213 6
d221 1
a221 3



@


1.2
log
@massive more comments to help first-time shader writers
@
text
@d76 1
a76 1
	{"xxx",	0,	0,		MFI_NORMAL|MFI_HIT|MFI_UV,
d79 1
a79 1
	{(char *)0,	0,		0,		0,
@


1.1
log
@Initial revision
@
text
@d4 12
d29 7
a35 1
#define xxx_MAGIC 0x18364	/* XXX change this number for each shader */
d37 2
a38 2
	long	magic;
	double	val;
a41 1
#define CK_xxx_SP(_p) RT_CKMAG(_p, xxx_MAGIC, "xxx_specific")
d43 3
a45 1
static struct xxx_specific xxx_defaults = {
d49 4
d59 1
d63 2
a64 2
	{"%f",  3, "scale",		SHDR_AO(scale),		FUNC_NULL },
	{"%f",  3, "s",			SHDR_AO(scale),		FUNC_NULL },
d71 4
d107 1
d110 1
d115 5
a119 1
	 *  "region" or "shader" space
d123 3
a125 1
	/* Add any translation within shader/region space */
d184 1
a184 1
		rt_structprint( "foo", xxx_parse, (char *)xxx_sp );
d186 4
a189 1
	/* Optional: transform hit point into "shader-space coordinates" */
d195 3
@
