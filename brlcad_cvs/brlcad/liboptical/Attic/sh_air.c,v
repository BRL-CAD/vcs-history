head	1.39;
access;
symbols
	ansi-20040405-merged:1.35.2.2
	postmerge-20040405-ansi:1.37
	premerge-20040404-ansi:1.36
	postmerge-autoconf:1.36
	autoconf-freeze:1.35.10.1
	premerge-autoconf:1.36
	ansi-20040316-freeze:1.35.2.1
	postmerge-20040315-windows:1.36
	premerge-20040315-windows:1.35
	windows-20040315-freeze:1.35.4.1
	autoconf-20031203:1.35
	autoconf-20031202:1.35
	autoconf-branch:1.35.0.10
	phong-branch:1.35.0.8
	photonmap-branch:1.35.0.6
	rel-6-1-DP:1.35
	windows-branch:1.35.0.4
	rel-6-0-2:1.33
	ansi-branch:1.35.0.2
	rel-6-0-1-branch:1.33.0.2
	hartley-6-0-post:1.34
	hartley-6-0-pre:1.33
	rel-6-0-1:1.33
	rel-6-0:1.33
	rel-5-4:1.29
	offsite-5-3-pre:1.31
	rel-5-3:1.29
	rel-5-2:1.29
	rel-5-1-branch:1.29.0.2
	rel-5-1:1.29
	rel-5-0:1.25
	rel-5-0-beta:1.23
	rel-4-5:1.18
	ctj-4-5-post:1.16
	ctj-4-5-pre:1.16;
locks; strict;
comment	@ * @;


1.39
date	2004.05.21.18.07.27;	author morrison;	state dead;
branches;
next	1.38;

1.38
date	2004.05.10.15.30.45;	author erikg;	state Exp;
branches;
next	1.37;

1.37
date	2004.04.05.07.43.37;	author morrison;	state Exp;
branches;
next	1.36;

1.36
date	2004.03.16.20.01.22;	author morrison;	state Exp;
branches;
next	1.35;

1.35
date	2002.08.20.17.07.50;	author jra;	state Exp;
branches
	1.35.2.1
	1.35.4.1
	1.35.10.1;
next	1.34;

1.34
date	2002.08.15.20.55.03;	author hartley;	state Exp;
branches;
next	1.33;

1.33
date	2001.05.16.21.37.56;	author morrison;	state Exp;
branches;
next	1.32;

1.32
date	2001.04.20.22.29.31;	author morrison;	state Exp;
branches;
next	1.31;

1.31
date	2000.10.19.19.19.45;	author butler;	state Exp;
branches;
next	1.30;

1.30
date	2000.07.25.16.40.37;	author butler;	state Exp;
branches;
next	1.29;

1.29
date	2000.02.19.21.05.01;	author butler;	state Exp;
branches;
next	1.28;

1.28
date	2000.02.17.21.03.44;	author butler;	state Exp;
branches;
next	1.27;

1.27
date	99.12.30.16.13.02;	author jra;	state Exp;
branches;
next	1.26;

1.26
date	99.10.30.03.06.24;	author butler;	state Exp;
branches;
next	1.25;

1.25
date	99.07.02.22.20.40;	author mike;	state Exp;
branches;
next	1.24;

1.24
date	99.07.01.20.08.44;	author mike;	state Exp;
branches;
next	1.23;

1.23
date	99.02.04.02.24.59;	author butler;	state Exp;
branches;
next	1.22;

1.22
date	98.09.22.01.29.53;	author mike;	state Exp;
branches;
next	1.21;

1.21
date	98.06.30.22.54.16;	author mike;	state Exp;
branches;
next	1.20;

1.20
date	98.06.25.07.40.56;	author mike;	state Exp;
branches;
next	1.19;

1.19
date	98.03.19.03.59.19;	author mike;	state Exp;
branches;
next	1.18;

1.18
date	97.12.31.09.01.40;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	97.12.16.04.14.27;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	97.05.21.01.29.02;	author butler;	state Exp;
branches;
next	1.15;

1.15
date	97.03.12.18.14.46;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	97.01.31.04.05.19;	author butler;	state Exp;
branches;
next	1.13;

1.13
date	97.01.14.05.42.08;	author butler;	state Exp;
branches;
next	1.12;

1.12
date	97.01.08.00.00.03;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	96.08.31.08.47.53;	author butler;	state Exp;
branches;
next	1.10;

1.10
date	96.08.31.08.22.45;	author butler;	state Exp;
branches;
next	1.9;

1.9
date	96.08.30.00.08.21;	author butler;	state Exp;
branches;
next	1.8;

1.8
date	96.06.26.01.33.09;	author butler;	state Exp;
branches;
next	1.7;

1.7
date	96.04.26.19.28.49;	author butler;	state Exp;
branches;
next	1.6;

1.6
date	95.12.21.22.29.29;	author butler;	state Exp;
branches;
next	1.5;

1.5
date	95.10.20.04.43.53;	author butler;	state Exp;
branches;
next	1.4;

1.4
date	95.08.25.18.17.41;	author butler;	state Exp;
branches;
next	1.3;

1.3
date	95.08.25.17.38.50;	author butler;	state Exp;
branches;
next	1.2;

1.2
date	95.08.23.05.46.32;	author butler;	state Exp;
branches;
next	1.1;

1.1
date	95.08.19.05.05.18;	author butler;	state Exp;
branches;
next	;

1.35.2.1
date	2002.09.19.18.01.24;	author morrison;	state Exp;
branches;
next	1.35.2.2;

1.35.2.2
date	2004.03.17.21.18.31;	author morrison;	state Exp;
branches;
next	;

1.35.4.1
date	2002.09.26.23.03.58;	author morrison;	state Exp;
branches;
next	;

1.35.10.1
date	2004.03.18.18.10.28;	author erikg;	state Exp;
branches;
next	;


desc
@Various atmospheric effects shaders
@


1.39
log
@moved to src/
@
text
@/*
 *	S H _ A I R . C
 *
 */
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef HAVE_STRING_H
#include <string.h>
#endif
#include <math.h>
#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "shadefuncs.h"
#include "shadework.h"
#include "rtprivate.h"

extern int rr_render(struct application	*ap,
		     struct partition	*pp,
		     struct shadework   *swp);

#define AIR_MAGIC 0x41697200	/* "Air" */
struct air_specific {
	long	magic;
	double	d_p_mm;	/* density per unit millimeter (specified in m)*/
	double	scale;	/* only used in emist */
	double	delta;	/* only used in emist */
	char	*name;	/* name of "ground" object for emist_terrain_render */
};
#define CK_AIR_SP(_p) BU_CKMAG(_p, AIR_MAGIC, "air_specific")

static struct air_specific air_defaults = {
	AIR_MAGIC,
	.1,		/* d_p_mm */	
	.01,		/* scale */
	0.0,		/* delta */
	};

#define SHDR_NULL	((struct air_specific *)0)
#define SHDR_O(m)	offsetof(struct air_specific, m)
#define SHDR_AO(m)	bu_offsetofarray(struct air_specific, m)

static void dpm_hook(register const struct bu_structparse *sdp, register const char *name, char *base, const char *value);

struct bu_structparse air_parse[] = {
	{"%f",  1, "dpm",		SHDR_O(d_p_mm),		dpm_hook },
	{"%f",  1, "scale",		SHDR_O(scale),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",  1, "s",			SHDR_O(scale),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",  1, "delta",		SHDR_O(delta),		bu_mm_cvt },
	{"%f",  1, "d",			SHDR_O(delta),		bu_mm_cvt },
	{"",	0, (char *)0,		0,			BU_STRUCTPARSE_FUNC_NULL }
};

HIDDEN int	air_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip), airtest_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp), air_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp), emist_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp), tmist_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
HIDDEN void	air_print(register struct region *rp, char *dp), air_free(char *cp);

struct mfuncs air_mfuncs[] = {
	{MF_MAGIC,	"airtest",	0,		MFI_HIT, MFF_PROC,
	air_setup,	airtest_render,	air_print,	air_free },

	{MF_MAGIC,	"air",		0,		MFI_HIT, MFF_PROC,
	air_setup,	air_render,	air_print,	air_free },

	{MF_MAGIC,	"fog",		0,		MFI_HIT, MFF_PROC,
	air_setup,	air_render,	air_print,	air_free },

	{MF_MAGIC,	"emist",	0,		MFI_HIT, MFF_PROC,
	air_setup,	emist_render,	air_print,	air_free },

	{MF_MAGIC,	"tmist",	0,		MFI_HIT, MFF_PROC,
	air_setup,	tmist_render,	air_print,	air_free },

	{0,		(char *)0,	0,		0,	0,
	0,		0,		0,		0 }
};
static void 
dpm_hook(register const struct bu_structparse *sdp, register const char *name, char *base, const char *value)
                                    	     	/* structure description */
                   			      	/* struct member name */
    					      	/* begining of structure */
          				       	/* string containing value */
{
#define meters_to_millimeters 0.001
	struct air_specific *air_sp = (struct air_specific *)base;
	
	air_sp->d_p_mm *= meters_to_millimeters;
}
/*	A I R _ S E T U P
 *
 *	This routine is called (at prep time)
 *	once for each region which uses this shader.
 *	Any shader-specific initialization should be done here.
 */
HIDDEN int
air_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip)
                      	    
             		         
    			      	/* pointer to reg_udata in *rp */
             		     
           		      	/* New since 4.4 release */
{
	register struct air_specific	*air_sp;

	if (rdebug&RDEBUG_SHADE) bu_log("air_setup\n");

	RT_CHECK_RTI(rtip);
	BU_CK_VLS( matparm );
	RT_CK_REGION(rp);
	BU_GETSTRUCT( air_sp, air_specific );
	*dpp = (char *)air_sp;

	memcpy(air_sp, &air_defaults, sizeof(struct air_specific) );

	if (rp->reg_aircode == 0) {
		bu_log("WARNING(%s): air shader '%s' applied to non-air region.\n%s\n",
			rp->reg_name,
			mfp->mf_name,
			"  Set air flag with \"edcodes\" in mged");
		bu_bomb("");
	}

	if (rdebug&RDEBUG_SHADE) bu_log("\"%s\"\n", bu_vls_addr(matparm) );
	if (bu_struct_parse( matparm, air_parse, (char *)air_sp ) < 0 )
		return(-1);

	if (rdebug&RDEBUG_SHADE) air_print(rp, air_sp);

	return(1);
}

/*
 *	A I R _ P R I N T
 */
HIDDEN void
air_print(register struct region *rp, char *dp)
{
	bu_struct_print( rp->reg_name, air_parse, (char *)dp );
}

/*
 *	A I R _ F R E E
 */
HIDDEN void
air_free(char *cp)
{
	if (rdebug&RDEBUG_SHADE)
		bu_log("air_free(%s:%d)\n", __FILE__, __LINE__);
	bu_free( cp, "air_specific" );
}

/*
 *	A I R T E S T _ R E N D E R
 *
 *	This is called (from viewshade() in shade.c)
 *	once for each hit point to be shaded.
 *
 *
 */
int
airtest_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
{
	register struct air_specific *air_sp =
		(struct air_specific *)dp;

	RT_AP_CHECK(ap);
	RT_CHECK_PT(pp);
	CK_AIR_SP(air_sp);

	if (rdebug&RDEBUG_SHADE) {
		bu_struct_print( "air_specific", air_parse, (char *)air_sp );

		bu_log("air in(%g) out%g)\n",
			pp->pt_inhit->hit_dist,
			pp->pt_outhit->hit_dist);
	}

	return(1);
}
/*
 *	A I R _ R E N D E R
 *
 *	This is called (from viewshade() in shade.c)
 *	once for each hit point to be shaded.
 *
 *
 *	This implements Beer's law homogeneous Fog/haze
 *
 *	Tau = optical path depth = density_per_unit_distance * distance
 *
 *	transmission = e^(-Tau)
 */
int
air_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
{
	register struct air_specific *air_sp =
		(struct air_specific *)dp;
	double tau;
	double dist;

	RT_AP_CHECK(ap);
	RT_CHECK_PT(pp);
	CK_AIR_SP(air_sp);

	if (rdebug&RDEBUG_SHADE) {
		bu_struct_print( "air_specific", air_parse, (char *)air_sp );
		bu_log("air in(%g) out(%g) r_pt(%g %g %g)\n",
			pp->pt_inhit->hit_dist,
			pp->pt_outhit->hit_dist,
			V3ARGS(ap->a_ray.r_pt));
	}

	/* Beer's Law Homogeneous Fog */

	/* get the path length right */
	if (pp->pt_inhit->hit_dist < 0.0)
		dist = pp->pt_outhit->hit_dist;
	else
		dist = (pp->pt_outhit->hit_dist - pp->pt_inhit->hit_dist);

	/* tau = optical path depth = density per mm * distance in mm */
	tau = air_sp->d_p_mm * dist;

	/* transmission = e^(-tau) */
	swp->sw_transmit = exp(-tau);

	if ( swp->sw_transmit > 1.0) swp->sw_transmit = 1.0;
	else if ( swp->sw_transmit < 0.0 ) swp->sw_transmit = 0.0;

	/* extinction = 1. - transmission.  Extinguished part replaced by
	 * the "color of the air".
	 */

	if (swp->sw_reflect > 0 || swp->sw_transmit > 0 )
		(void)rr_render( ap, pp, swp );

	if (rdebug&RDEBUG_SHADE)
		bu_log("air o dist:%gmm tau:%g transmit:%g\n",
			dist, tau, swp->sw_transmit);

	return(1);
}

int
tmist_hit(register struct application *ap, struct partition *PartHeadp, struct seg *segHeadp)
{
	/* go looking for the object named in
	 * ((struct air_specific *)ap->a_uptr)->name
	 * in the partition list,
	 * set ap->a_dist to distance to that object
	 */
	return 0;
}
int
tmist_miss(register struct application *ap)
{
	/* we missed?!  This is bogus!
	 * but set ap->a_dist to something big
	 */
	return 0;
}

/*
 *	T M I S T _ R E N D E R
 *
 * Use height above named terrain object
 *
 *
 *	This is called (from viewshade() in shade.c)
 *	once for each hit point to be shaded.
 */
int
tmist_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
{
	register struct air_specific *air_sp =
		(struct air_specific *)dp;
	point_t in_pt, out_pt;
	vect_t vapor_path;
	fastf_t dist;
	fastf_t step_dist;
	fastf_t tau;
	fastf_t dt;
	struct application my_ap;
	long meters;

	RT_AP_CHECK(ap);
	RT_CHECK_PT(pp);
	CK_AIR_SP(air_sp);

	/* Get entry point */
	if (pp->pt_inhit->hit_dist < 0.0) {
		VMOVE(in_pt, ap->a_ray.r_pt);
	} else {
		VJOIN1(in_pt, ap->a_ray.r_pt,
			pp->pt_inhit->hit_dist, ap->a_ray.r_dir);
	}

	/* Get exit point */
	VJOIN1(out_pt,
		ap->a_ray.r_pt, pp->pt_outhit->hit_dist, ap->a_ray.r_dir);

	VSUB2(vapor_path, out_pt, in_pt);

	dist = MAGNITUDE(vapor_path);
	meters = (long)dist;
	meters = meters >> 3;

	if (meters < 1) step_dist = dist;
	else step_dist = dist / (fastf_t)meters;

	for (dt=0.0 ; dt <= dist ; dt += step_dist) {
		memcpy((char *)&my_ap, (char *)ap, sizeof(struct application));
		VJOIN1(my_ap.a_ray.r_pt, in_pt, dt, my_ap.a_ray.r_dir);
		VSET(my_ap.a_ray.r_dir, 0.0, 0.0, -1.0);
		my_ap.a_hit = tmist_hit;
		my_ap.a_miss = tmist_miss;
		my_ap.a_onehit = 0;
		my_ap.a_uptr = (genptr_t)air_sp;
		rt_shootray( &my_ap );

		/* XXX check my_ap.a_dist for distance to ground */

		/* XXX compute optical density at this altitude */

		/* XXX integrate in the effects of this meter of air */

	}
	tau = 42;


	swp->sw_transmit = exp(-tau);

	if (swp->sw_transmit > 1.0) swp->sw_transmit = 1.0;
	else if (swp->sw_transmit < 0.0) swp->sw_transmit = 0.0;

	if (rdebug&RDEBUG_SHADE)
		bu_log("tmist transmit = %g\n", swp->sw_transmit);

	return(1);
}
/*
 *	E M I S T _ R E N D E R
 *
 *
 *
 *
 * te = dist from pt to end of ray (out hit point)
 * Zo = elevation at ray start
 * Ze = elevation at ray end
 * Zd = Z component of normalized ray vector 
 * d_p_mm = overall fog density
 * B = density falloff with altitude
 *
 *
 *	delta = height at which fog starts
 *	scale = stretches exponential decay zone
 *	d_p_mm = maximum density @@ ground
 *
 *	This is called (from viewshade() in shade.c)
 *	once for each hit point to be shaded.
 */
int
emist_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
{
	register struct air_specific *air_sp =
		(struct air_specific *)dp;
	point_t in_pt, out_pt;
	double tau;
	double Zo, Ze, Zd, te;

	RT_AP_CHECK(ap);
	RT_CHECK_PT(pp);
	CK_AIR_SP(air_sp);

	/* compute hit point & length of ray */
	if (pp->pt_inhit->hit_dist < 0.0) {
		VMOVE(in_pt, ap->a_ray.r_pt);
		te = pp->pt_outhit->hit_dist;
	} else {
		VJOIN1(in_pt, ap->a_ray.r_pt,
			pp->pt_inhit->hit_dist, ap->a_ray.r_dir);
		te = pp->pt_outhit->hit_dist - pp->pt_inhit->hit_dist;
	}

	/* get exit point */
	VJOIN1(out_pt,
		ap->a_ray.r_pt, pp->pt_outhit->hit_dist, ap->a_ray.r_dir);

	Zo = (air_sp->delta + in_pt[Z]) * air_sp->scale;
	Ze = (air_sp->delta + out_pt[Z]) * air_sp->scale;
	Zd = ap->a_ray.r_dir[Z];

	if ( NEAR_ZERO( Zd, SQRT_SMALL_FASTF ) )
		tau = air_sp->d_p_mm * te * exp( -Zo);
	else
		tau = (( air_sp->d_p_mm * te) /  Zd) * ( exp(-Zo) - exp(-Ze) );

/*	XXX future
	tau *= bn_noise_fbm(pt);
*/

	swp->sw_transmit = exp(-tau);

	if (swp->sw_transmit > 1.0) swp->sw_transmit = 1.0;
	else if (swp->sw_transmit < 0.0) swp->sw_transmit = 0.0;

	if (rdebug&RDEBUG_SHADE)
		bu_log("emist transmit = %g\n", swp->sw_transmit);

	return(1);
}
/*
 *	F B M _ E M I S T _ R E N D E R
 *
 *
 *
 *
 * te = dist from pt to end of ray (out hit point)
 * Zo = elevation at ray start
 * Ze = elevation at ray end
 * Zd = Z component of normalized ray vector 
 * d_p_mm = overall fog density
 * B = density falloff with altitude
 *
 *
 *	delta = height at which fog starts
 *	scale = stretches exponential decay zone
 *	d_p_mm = maximum density @@ ground
 *
 *	This is called (from viewshade() in shade.c)
 *	once for each hit point to be shaded.
 */
int
emist_fbm_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
{
#ifndef NO_MAGIC_CHECKING
	register struct air_specific *air_sp =
	   (struct air_specific *)dp;
#endif
	point_t in_pt, out_pt;
	vect_t dist_v;
	double dist, delta;

#ifndef NO_MAGIC_CHECKING
	RT_AP_CHECK(ap);
	RT_CHECK_PT(pp);
	CK_AIR_SP(air_sp);
#endif

	/* compute hit point & length of ray */
	if (pp->pt_inhit->hit_dist < 0.0) {
		VMOVE(in_pt, ap->a_ray.r_pt);
	} else {
		VJOIN1(in_pt, ap->a_ray.r_pt,
			pp->pt_inhit->hit_dist, ap->a_ray.r_dir);
	}

	/* get exit point */
	VJOIN1(out_pt,
		ap->a_ray.r_pt, pp->pt_outhit->hit_dist, ap->a_ray.r_dir);


	/* we march along the ray, evaluating the atmospheric function
	 * at each step.
	 */

	VSUB2(dist_v, out_pt, in_pt);
	dist = MAGNITUDE(dist_v);

	for (delta=0 ; delta < dist ; delta += 1.0 ) {
		/* compute the current point in space */

		/* Shoot a ray down the -Z axis to find our current height 
		 * above the local terrain.
		 */

	}



	return(1);
}
@


1.38
log
@change conf.h to a wrapped config.h
@
text
@@


1.37
log
@merge of ansi-6-0-branch into HEAD
@
text
@d5 5
a9 1
#include "conf.h"
@


1.36
log
@merge of windows-6-0-branch into head
@
text
@d44 1
a44 1
static void dpm_hook();
d55 2
a56 2
HIDDEN int	air_setup(), airtest_render(), air_render(), emist_render(), tmist_render();
HIDDEN void	air_print(), air_free();
d78 5
a82 5
dpm_hook(sdp, name, base, value)
register const struct bu_structparse	*sdp;	/* structure description */
register const char			*name;	/* struct member name */
char					*base;	/* begining of structure */
const char				*value;	/* string containing value */
d96 6
a101 6
air_setup( rp, matparm, dpp, mfp, rtip)
register struct region	*rp;
struct bu_vls		*matparm;
char			**dpp;	/* pointer to reg_udata in *rp */
struct mfuncs		*mfp;
struct rt_i		*rtip;	/* New since 4.4 release */
d136 1
a136 3
air_print( rp, dp )
register struct region *rp;
char	*dp;
d145 1
a145 2
air_free( cp )
char *cp;
d161 1
a161 5
airtest_render( ap, pp, swp, dp )
struct application	*ap;
struct partition	*pp;
struct shadework	*swp;
char	*dp;
d194 1
a194 5
air_render( ap, pp, swp, dp )
struct application	*ap;
struct partition	*pp;
struct shadework	*swp;
char	*dp;
a243 1
#ifndef WIN32
d245 1
a245 10
tmist_hit(ap, PartHeadp, segHeadp)
register struct application *ap;
struct partition *PartHeadp;
struct seg *segHeadp;
#else
int tmist_hit(
register struct application *ap,
struct partition *PartHeadp,
struct seg *segHeadp)
#endif
a253 6

#ifndef WIN32
int
tmist_miss( ap )
register struct application *ap;
#else
d255 1
a255 2
tmist_miss( register struct application *ap )
#endif
d273 1
a273 5
tmist_render( ap, pp, swp, dp )
struct application	*ap;
struct partition	*pp;
struct shadework	*swp;
char	*dp;
d363 1
a363 5
emist_render( ap, pp, swp, dp )
struct application	*ap;
struct partition	*pp;
struct shadework	*swp;
char	*dp;
d434 1
a434 5
emist_fbm_render( ap, pp, swp, dp )
struct application	*ap;
struct partition	*pp;
struct shadework	*swp;
char	*dp;
@


1.35
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d255 1
d261 6
d275 2
d280 4
@


1.35.10.1
log
@merge from head
@
text
@a254 1
#ifndef WIN32
a259 6
#else
int tmist_hit(
register struct application *ap,
struct partition *PartHeadp,
struct seg *segHeadp)
#endif
a267 2

#ifndef WIN32
a270 4
#else
int
tmist_miss( register struct application *ap )
#endif
@


1.35.4.1
log
@Modifications (on a 6.0 source distribution) for initial port to windows (merged with sources close to 6.0.2)
@
text
@a254 1
#ifndef WIN32
a259 6
#else
int tmist_hit(
register struct application *ap,
struct partition *PartHeadp,
struct seg *segHeadp)
#endif
a267 2

#ifndef WIN32
a270 4
#else
int
tmist_miss( register struct application *ap )
#endif
@


1.35.2.1
log
@Initial ANSIfication
@
text
@d44 1
a44 1
static void dpm_hook(register const struct bu_structparse *sdp, register const char *name, char *base, const char *value);
d55 2
a56 2
HIDDEN int	air_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip), airtest_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp), air_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp), emist_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp), tmist_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
HIDDEN void	air_print(register struct region *rp, char *dp), air_free(char *cp);
d78 5
a82 5
dpm_hook(register const struct bu_structparse *sdp, register const char *name, char *base, const char *value)
                                    	     	/* structure description */
                   			      	/* struct member name */
    					      	/* begining of structure */
          				       	/* string containing value */
d96 6
a101 6
air_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip)
                      	    
             		         
    			      	/* pointer to reg_udata in *rp */
             		     
           		      	/* New since 4.4 release */
d136 3
a138 1
air_print(register struct region *rp, char *dp)
d147 2
a148 1
air_free(char *cp)
d164 5
a168 1
airtest_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
d201 5
a205 1
air_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
d256 4
a259 1
tmist_hit(register struct application *ap, struct partition *PartHeadp, struct seg *segHeadp)
d269 2
a270 1
tmist_miss(register struct application *ap)
d288 5
a292 1
tmist_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
d382 5
a386 1
emist_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
d457 5
a461 1
emist_fbm_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
@


1.35.2.2
log
@sync branch with HEAD
@
text
@a253 1

@


1.34
log
@Converted from K&R to ANSI C - RFH
@
text
@d44 1
a44 1
static void dpm_hook(register const struct bu_structparse *sdp, register const char *name, char *base, const char *value);
d55 2
a56 2
HIDDEN int	air_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip), airtest_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp), air_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp), emist_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp), tmist_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
HIDDEN void	air_print(register struct region *rp, char *dp), air_free(char *cp);
d78 5
a82 5
dpm_hook(register const struct bu_structparse *sdp, register const char *name, char *base, const char *value)
                                    	     	/* structure description */
                   			      	/* struct member name */
    					      	/* begining of structure */
          				       	/* string containing value */
d96 6
a101 6
air_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip)
                      	    
             		         
    			      	/* pointer to reg_udata in *rp */
             		     
           		      	/* New since 4.4 release */
d136 3
a138 1
air_print(register struct region *rp, char *dp)
d147 2
a148 1
air_free(char *cp)
d164 5
a168 1
airtest_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
d201 5
a205 1
air_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
d256 4
a259 1
tmist_hit(register struct application *ap, struct partition *PartHeadp, struct seg *segHeadp)
d269 2
a270 1
tmist_miss(register struct application *ap)
d288 5
a292 1
tmist_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
d382 5
a386 1
emist_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
d457 5
a461 1
emist_fbm_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
@


1.33
log
@PRODUCTION optimizations
@
text
@d44 1
a44 1
static void dpm_hook();
d55 2
a56 2
HIDDEN int	air_setup(), airtest_render(), air_render(), emist_render(), tmist_render();
HIDDEN void	air_print(), air_free();
d78 5
a82 5
dpm_hook(sdp, name, base, value)
register const struct bu_structparse	*sdp;	/* structure description */
register const char			*name;	/* struct member name */
char					*base;	/* begining of structure */
const char				*value;	/* string containing value */
d96 6
a101 6
air_setup( rp, matparm, dpp, mfp, rtip)
register struct region	*rp;
struct bu_vls		*matparm;
char			**dpp;	/* pointer to reg_udata in *rp */
struct mfuncs		*mfp;
struct rt_i		*rtip;	/* New since 4.4 release */
d136 1
a136 3
air_print( rp, dp )
register struct region *rp;
char	*dp;
d145 1
a145 2
air_free( cp )
char *cp;
d161 1
a161 5
airtest_render( ap, pp, swp, dp )
struct application	*ap;
struct partition	*pp;
struct shadework	*swp;
char	*dp;
d194 1
a194 5
air_render( ap, pp, swp, dp )
struct application	*ap;
struct partition	*pp;
struct shadework	*swp;
char	*dp;
d245 1
a245 4
tmist_hit(ap, PartHeadp, segHeadp)
register struct application *ap;
struct partition *PartHeadp;
struct seg *segHeadp;
d255 1
a255 2
tmist_miss( ap )
register struct application *ap;
d273 1
a273 5
tmist_render( ap, pp, swp, dp )
struct application	*ap;
struct partition	*pp;
struct shadework	*swp;
char	*dp;
d363 1
a363 5
emist_render( ap, pp, swp, dp )
struct application	*ap;
struct partition	*pp;
struct shadework	*swp;
char	*dp;
d434 1
a434 5
emist_fbm_render( ap, pp, swp, dp )
struct application	*ap;
struct partition	*pp;
struct shadework	*swp;
char	*dp;
@


1.32
log
@CONST to const
@
text
@d23 1
a23 1
#define air_MAGIC 0x41697200	/* "Air" */
d31 1
a31 1
#define CK_air_SP(_p) BU_CKMAG(_p, air_MAGIC, "air_specific")
d34 1
a34 1
	air_MAGIC,
d89 1
a89 1
/*	A I R _ S E T U P
d132 1
a132 1
/*
d155 1
a155 1
/*
d175 1
a175 1
	CK_air_SP(air_sp);
d187 1
a187 1
/*
d214 1
a214 1
	CK_air_SP(air_sp);
d278 1
a278 1
/*
d307 1
a307 1
	CK_air_SP(air_sp);
d360 1
a360 1
/*
d396 1
a396 1
	CK_air_SP(air_sp);
d435 1
a435 1
/*
d463 1
d465 2
a466 1
		(struct air_specific *)dp;
d471 1
d474 2
a475 1
	CK_air_SP(air_sp);
@


1.31
log
@Changes to compile under RedHat 7.0
@
text
@d79 2
a80 2
register CONST struct bu_structparse	*sdp;	/* structure description */
register CONST char			*name;	/* struct member name */
d82 1
a82 1
CONST char				*value;	/* string containing value */
@


1.30
log
@Changes to use rtprivate.h instead of ../rt/rdebug.h
@
text
@d8 3
@


1.29
log
@Changes to support movement of CLAMP() macro into vmath.h
Altered "if( " statements to "if (" for readability.
@
text
@d14 1
a14 1
#include "../rt/rdebug.h"
d16 3
@


1.28
log
@misc minor patches
@
text
@d99 1
a99 1
	if( rdebug&RDEBUG_SHADE) bu_log("air_setup\n");
d118 1
a118 1
	if( bu_struct_parse( matparm, air_parse, (char *)air_sp ) < 0 )
d144 1
a144 1
	if( rdebug&RDEBUG_SHADE)
d171 1
a171 1
	if( rdebug&RDEBUG_SHADE) {
d210 1
a210 1
	if( rdebug&RDEBUG_SHADE) {
d239 1
a239 1
	if( swp->sw_reflect > 0 || swp->sw_transmit > 0 )
d242 1
a242 1
	if( rdebug&RDEBUG_SHADE)
d349 1
a349 1
	if( rdebug&RDEBUG_SHADE)
d424 1
a424 1
	if( rdebug&RDEBUG_SHADE)
@


1.27
log
@Eliminated some unused variables
@
text
@d21 2
a22 2
	double	scale;
	double	delta;
d120 2
@


1.26
log
@Moved mathtab/rand_half from rt into libbn
Expanded structparse to include description and default
@
text
@a97 1
	mat_t	tmp;
a163 1
	point_t pt;
a200 1
	point_t pt;
a289 2
	fastf_t in_altitude;
	fastf_t out_altitude;
d457 1
a457 1
	point_t in_pt, out_pt, curr_pt;
a459 3
	double tau;
	double Zo, Ze, Zd, te;
	struct application my_ap;
a467 1
		te = pp->pt_outhit->hit_dist;
a470 1
		te = pp->pt_outhit->hit_dist - pp->pt_inhit->hit_dist;
a486 1
		VJOIN1(curr_pt, in_pt, delta, ap->a_ray.r_dir);
@


1.25
log
@
Removed dependence on compat4.h
@
text
@a13 1
#include "../rt/mathtab.h"
@


1.24
log
@
compat4
@
text
@d43 2
a44 2
	{"%f",  1, "scale",		SHDR_O(scale),		FUNC_NULL },
	{"%f",  1, "s",			SHDR_O(scale),		FUNC_NULL },
d47 1
a47 1
	{"",	0, (char *)0,		0,			FUNC_NULL }
@


1.23
log
@Since we're enforcing an obscure RegionID and aircode scheme, it no longer
makes sense to render a scene if the air can't be shaded properly.  The
user no longer has a hope of noticing or understanding what went wrong.
@
text
@d26 1
a26 1
#define CK_air_SP(_p) RT_CKMAG(_p, air_MAGIC, "air_specific")
d37 1
a37 1
#define SHDR_AO(m)	offsetofarray(struct air_specific, m)
d93 1
a93 1
struct rt_vls		*matparm;
d101 1
a101 1
	if( rdebug&RDEBUG_SHADE) rt_log("air_setup\n");
d104 1
a104 1
	RT_VLS_CHECK( matparm );
d106 1
a106 1
	GETSTRUCT( air_sp, air_specific );
d119 1
a119 1
	if (rdebug&RDEBUG_SHADE) rt_log("\"%s\"\n", RT_VLS_ADDR(matparm) );
d145 2
a146 2
		rt_log("air_free(%s:%d)\n", __FILE__, __LINE__);
	rt_free( cp, "air_specific" );
d245 1
a245 1
		rt_log("air o dist:%gmm tau:%g transmit:%g\n",
d354 1
a354 1
		rt_log("tmist transmit = %g\n", swp->sw_transmit);
d420 1
a420 1
	tau *= noise_fbm(pt);
d429 1
a429 1
		rt_log("emist transmit = %g\n", swp->sw_transmit);
@


1.22
log
@Moved optical shaders from rt/ to liboptical/
The only modifications involved moving and splitting
rt/material.h into h/shadefuncs.h and h/shadework.h,
and in changing the calling sequence to mlib_setup() in rt/material.c

Now the only shader function called directly by RT is
in liboptical/init.c: optical_shader_init().
It adds all the individual shaders to the "mfuncs" shader list.
@
text
@d116 1
@


1.21
log
@Can't make "struct mfuncs" a CONST, because the forward link needs
to be filled in at runtime, and some compilers put CONST data into
read-only pages (like FreeBSD).
@
text
@d12 4
a15 3
#include "./material.h"
#include "./mathtab.h"
#include "./rdebug.h"
@


1.20
log
@Port to sun4
@
text
@d52 1
a52 1
CONST struct mfuncs air_mfuncs[] = {
@


1.19
log
@Fixed args to tmist_hit()
@
text
@d333 1
a333 1
		my_ap.a_uptr = air_sp;
@


1.18
log
@Required magic number to be first in mfunc table,
consistent with all other BRL-CAD magic numbers.
Required magic number to be initialized at compile time.
Added code to check the magic numbers.
Made the xxx_mfunc arrays CONST, so they can't get trashed by
runtime runaway pointer problems.
@
text
@d250 1
a250 1
tmist_hit(ap, PartHeadp)
d253 1
@


1.17
log
@Changed warning message to actually be useful and tell you
what region and what shader are involved.
@
text
@d52 2
a53 2
struct mfuncs air_mfuncs[] = {
	{"airtest",	0,		0,		MFI_HIT, MFF_PROC,
d56 1
a56 1
	{"air",		0,		0,		MFI_HIT, MFF_PROC,
d59 1
a59 1
	{"fog",		0,		0,		MFI_HIT, MFF_PROC,
d62 1
a62 1
	{"emist",	0,		0,		MFI_HIT, MFF_PROC,
d65 1
a65 1
	{"tmist",	0,		0,		MFI_HIT, MFF_PROC,
d68 1
a68 1
	{(char *)0,	0,		0,		0,	0,
@


1.16
log
@modified to use bu_mm_cvt()
@
text
@d111 4
a114 3
		rt_log("%s\n%s\n",
		"*** WARNING: air shader applied to non-air region!!! ***",
		"Set air flag with \"edcodes\" in mged");
@


1.15
log
@Got it to compile.
@
text
@d44 2
a45 2
	{"%f",  1, "delta",		SHDR_O(delta),		FUNC_NULL },
	{"%f",  1, "d",			SHDR_O(delta),		FUNC_NULL },
@


1.14
log
@added message to tell user to set air code if not set
@
text
@d258 1
d267 1
d325 1
a325 1
		memcpy(my_ap, ap, sizeof(struct application));
d341 1
@


1.13
log
@started working on mist-above-terrain function tmist_render()
@
text
@d110 5
a114 4
#if 0
	rp->reg_regionid = -1;
	rp->reg_aircode = 1;
#endif
@


1.12
log
@Butler October mod, being checked in.
@
text
@d20 1
a20 1
	double	d_p_m;	/* density per unit meter */
d23 1
a23 4
	double	color[3];
	int	noise_type;
	double	octaves;
	double	lacunarity;
d29 1
a29 1
	.1,		/* d_p_m */	
a31 1
	{ .5, .5, .625 }/* color */
d38 2
d41 1
a41 1
	{"%f",  1, "dpm",		SHDR_O(d_p_m),		FUNC_NULL },
d49 1
a49 1
HIDDEN int	air_setup(), airtest_render(), air_render(), emist_render();
d65 3
d71 12
a82 2


a215 6
	/* XXX
	 * We can't trust the reflect/refract support in rt to do the right
	 * thing so we have to take over here.
	 */


d224 2
a225 2
	/* tau = optical path depth = density per m * distance */
	tau = (air_sp->d_p_m*0.001 ) * dist;
a236 5
#if 0
	VMOVE(swp->sw_color, air_sp->color);
	VMOVE(swp->sw_basecolor, air_sp->color);
#endif

d241 2
a242 2
		rt_log("air o dist:%gmm tau:%g transmit:%g color(%g %g %g)\n",
			dist, tau, swp->sw_transmit, V3ARGS(swp->sw_color) );
d247 92
d340 4
d345 5
d360 1
a360 1
 * d_p_m = overall fog density
d366 1
a366 1
 *	d_p_m = maximum density @@ ground
d407 1
a407 1
		tau = (air_sp->d_p_m*0.001) * te * exp( -Zo);
d409 1
a409 1
		tau = (( (air_sp->d_p_m*0.001) * te) /  Zd) * ( exp(-Zo) - exp(-Ze) );
d435 1
a435 1
 * d_p_m = overall fog density
d441 1
a441 1
 *	d_p_m = maximum density @@ ground
d460 1
@


1.11
log
@bu_struct_print
@
text
@d237 3
@


1.10
log
@bu_struct_parse
@
text
@d119 1
a119 1
	bu_structprint( rp->reg_name, air_parse, (char *)dp );
d158 1
a158 1
		bu_structprint( "air_specific", air_parse, (char *)air_sp );
d198 1
a198 1
		bu_structprint( "air_specific", air_parse, (char *)air_sp );
@


1.9
log
@structparse moved to libbu
@
text
@d105 1
a105 1
	if( bu_structparse( matparm, air_parse, (char *)air_sp ) < 0 )
@


1.8
log
@fixed comment to reflect d_p_m is in meters, not mm
@
text
@d42 1
a42 1
struct structparse air_parse[] = {
d105 1
a105 1
	if( rt_structparse( matparm, air_parse, (char *)air_sp ) < 0 )
d119 1
a119 1
	rt_structprint( rp->reg_name, air_parse, (char *)dp );
d158 1
a158 1
		rt_structprint( "air_specific", air_parse, (char *)air_sp );
d160 1
a160 1
		rt_log("air in(%g) out%g)\n",
d198 2
a199 2
		rt_structprint( "air_specific", air_parse, (char *)air_sp );
		rt_log("air in(%g) out(%g) r_pt(%g %g %g)\n",
@


1.7
log
@checkpoint
@
text
@d219 1
a219 1
	/* tau = optical path depth = density per mm * distance */
@


1.6
log
@misc readability fixes.
@
text
@d55 1
a55 1
	{"airtest",	0,		0,		MFI_HIT,	0,
d67 1
a67 1
	{(char *)0,	0,		0,		0,		0,
d231 1
d236 1
@


1.5
log
@edited mfuncs table to account for new "mf_flags" element in struct mfuncs.
@
text
@d20 1
a20 1
	double	d_p_mm;	/* density per unit mm */
d32 1
a32 1
	.001,		/* d_p_mm */	
d43 1
a43 1
	{"%f",  1, "dpmm",		SHDR_O(d_p_mm),		FUNC_NULL },
d51 1
a51 1
HIDDEN int	air_setup(), air_render(), fog_render(), emist_render();
d55 4
a58 1
	{"air",		0,		0,		MFI_HIT,	0,
d61 2
a62 2
	{"fog",		0,		0,		MFI_HIT,	0,
	air_setup,	fog_render,	air_print,	air_free },
d64 1
a64 1
	{"emist",	0,		0,		MFI_HIT,	0,
d104 1
a104 1
	rt_log("\"%s\"\n", RT_VLS_ADDR(matparm) );
d135 1
a135 1
 *	A I R _ R E N D E R
d139 2
d143 1
a143 1
air_render( ap, pp, swp, dp )
d168 1
a168 1
 *	F O G _ R E N D E R
d172 7
d181 1
a181 1
fog_render( ap, pp, swp, dp )
d198 2
a199 2
		rt_structprint( "fog_specific", air_parse, (char *)air_sp );
		rt_log("fog in(%g) out(%g) r_pt(%g %g %g)\n",
d205 2
a206 1
	/* We can't trust the reflect/refract support in rt to do the right
d209 1
a209 4
#if 0
	swp->sw_transmit = 1.0;
	return(1);
#endif	
d213 6
d220 1
a220 4
	if (pp->pt_inhit->hit_dist < 0.0) dist = pp->pt_outhit->hit_dist;
	else dist = (pp->pt_outhit->hit_dist - pp->pt_inhit->hit_dist);

	tau = air_sp->d_p_mm * dist;
d229 1
a229 1
	 * color of the air
d236 1
a236 1
		rt_log("fog o dist:%gmm tau:%g transmit:%g color(%g %g %g)\n",
d254 1
a254 1
 * d_p_mm = overall fog density
d260 1
a260 1
 *	d_p_mm = maximum density @@ ground
d301 1
a301 1
		tau = air_sp->d_p_mm * te * exp( -Zo);
d303 1
a303 1
		tau = ((air_sp->d_p_mm * te) /  Zd) * ( exp(-Zo) - exp(-Ze) );
d329 1
a329 1
 * d_p_mm = overall fog density
d335 1
a335 1
 *	d_p_mm = maximum density @@ ground
@


1.4
log
@exponential density fog as a function of height
@
text
@d24 3
d55 1
a55 1
	{"air",	0,	0,		MFI_HIT,
d58 1
a58 1
	{"fog",	0,	0,		MFI_HIT,
d61 1
a61 1
	{"emist",0,	0,		MFI_HIT,
d64 1
a64 1
	{(char *)0,	0,		0,		0,
d269 1
a269 1
	/* comput hit point & length of ray */
d292 4
d303 76
@


1.3
log
@checkpoint
@
text
@a20 1
	double	B;
d29 4
a32 5
	1e-7,		/* d_p_pp */	
	1.0,
	.01,
	0.0,
	{ .5, .5, .625 }
a40 1
	{"%f",  1, "B",			SHDR_O(B),		FUNC_NULL },
d43 2
d231 15
d266 1
a266 9
	/*
	 * te = dist from pt to end of ray (out hit point)
	 * Zo = elevation at ray start
	 * Ze = elevation at ray end
	 * Zd = Z component of normalized ray vector 
	 * d_p_mm = overall fog density
	 * B = density falloff with altitude
	 */

d276 1
d284 4
a287 17
	if( rdebug&RDEBUG_SHADE) {
		rt_structprint( "emist_specific", air_parse, (char *)air_sp );	

		rt_log("emist in pt (%g %g %g) out pt (%g %g %g)\n",
			V3ARGS(in_pt), V3ARGS(out_pt));
	}

	if ( NEAR_ZERO( Zd, SQRT_SMALL_FASTF ) ) {
		tau = air_sp->d_p_mm * te * exp( -air_sp->B * Zo);
		if( rdebug&RDEBUG_SHADE)
			rt_log("emist tau = %g * %g * exp( %g * %g )\n",
				air_sp->d_p_mm, te, air_sp->B, Zo);
	} else {
		tau = ((air_sp->d_p_mm * te) / (air_sp->B * Zd)) * 
			( exp( -Zo ) - exp( -Ze ) );

		if( rdebug&RDEBUG_SHADE) {
a288 18
			rt_log("emist       %7g * %7g\n",
air_sp->d_p_mm, te);
			rt_log("emist tau = ----------------- * ( %g - %g )\n",
exp( -Zo ),  exp( -Ze ) );
			rt_log("emist       %7g * %7g\n",
air_sp->B, Zd);

			rt_log(" emist tau = %g * %g * %g = %g\n",
				air_sp->d_p_mm / air_sp->d_p_mm,
				te / Zd,
				exp( -Zo ) - exp( -Ze ),
				tau );
		}
	}
	/* extinction = 1. - transmission.  Extinguished part replaced by
	 * color of the air
	 */
	/* transmission = e^(-tau) */
d291 2
a292 5
	if (swp->sw_transmit > 1.0) {
		swp->sw_transmit = 1.0;
	} else if (swp->sw_transmit < 0.0) {
		swp->sw_transmit = 0.0;
	}
d294 1
a294 1
	if( rdebug&RDEBUG_SHADE) {
a295 3


	}
@


1.2
log
@first use of fog
@
text
@d22 2
d32 3
a34 1
	{ .25, .25, .8 }
d44 2
d53 1
a53 1
	{"air",	0,	0,		MFI_NORMAL|MFI_HIT|MFI_UV,
d56 1
a56 1
	{"fog",	0,	0,		MFI_NORMAL|MFI_HIT|MFI_UV,
d59 1
a59 1
	{"emist",0,	0,		MFI_NORMAL|MFI_HIT|MFI_UV,
d216 1
d219 1
a219 1

d244 1
a244 1
	point_t pt;
d252 8
a259 2
	if( rdebug&RDEBUG_SHADE) {
		rt_structprint( "emist_specific", air_parse, (char *)air_sp );
d261 7
a267 3
		rt_log("air in(%g) out%g)\n",
			pp->pt_inhit->hit_dist,
			pp->pt_outhit->hit_dist);
d270 2
a271 1
	/* Exponential Mist */
d273 2
a274 7
	/* d_p_mm = overall fog density
	 * B = density falloff with altitude
	 * Zo = elevation at ray start
	 * Ze = elevation at ray end
	 * Zd = Z component of normalized ray vector 
	 * te = dist from pt to end of ray (out hit point)
	 */
d276 3
a278 3
	Zo = pp->pt_inhit->hit_point[Z];
	Ze = pp->pt_outhit->hit_point[Z];
	te = pp->pt_outhit->hit_dist;
d280 5
a284 1
	if (Zd < SQRT_SMALL_FASTF)
d286 4
a289 1
	else
d291 1
a291 1
			(exp( -(Zo+Zd*te) ) - exp(-Zo) );
d293 16
d312 8
a319 1
	 VMOVE(swp->sw_color, air_sp->color);
d321 5
@


1.1
log
@Initial revision
@
text
@d88 1
d91 1
d93 1
d185 8
d214 1
a214 1
		rt_log("fog o dist:%gm tau:%g transmit:%g color(%g %g %g)\n",
@
