head	1.40;
access;
symbols
	ansi-20040405-merged:1.37.2.1
	postmerge-20040405-ansi:1.38
	premerge-20040404-ansi:1.37
	postmerge-autoconf:1.37
	autoconf-freeze:1.37
	premerge-autoconf:1.37
	ansi-20040316-freeze:1.37.2.1
	postmerge-20040315-windows:1.37
	premerge-20040315-windows:1.37
	windows-20040315-freeze:1.37
	autoconf-20031203:1.37
	autoconf-20031202:1.37
	autoconf-branch:1.37.0.10
	phong-branch:1.37.0.8
	photonmap-branch:1.37.0.6
	rel-6-1-DP:1.37
	windows-branch:1.37.0.4
	rel-6-0-2:1.35
	ansi-branch:1.37.0.2
	rel-6-0-1-branch:1.35.0.2
	hartley-6-0-post:1.36
	hartley-6-0-pre:1.35
	rel-6-0-1:1.35
	rel-6-0:1.35
	rel-5-4:1.29
	offsite-5-3-pre:1.32
	rel-5-3:1.29
	rel-5-2:1.29
	rel-5-1-branch:1.29.0.2
	rel-5-1:1.29
	rel-5-0:1.24
	rel-5-0-beta:1.22
	rel-4-5:1.17
	ctj-4-5-post:1.15
	ctj-4-5-pre:1.15;
locks; strict;
comment	@ * @;


1.40
date	2004.05.21.18.07.27;	author morrison;	state dead;
branches;
next	1.39;

1.39
date	2004.05.10.15.30.45;	author erikg;	state Exp;
branches;
next	1.38;

1.38
date	2004.04.05.07.43.37;	author morrison;	state Exp;
branches;
next	1.37;

1.37
date	2002.08.20.17.07.50;	author jra;	state Exp;
branches
	1.37.2.1;
next	1.36;

1.36
date	2002.08.15.20.55.03;	author hartley;	state Exp;
branches;
next	1.35;

1.35
date	2001.10.17.07.40.02;	author morrison;	state Exp;
branches;
next	1.34;

1.34
date	2001.04.20.22.29.31;	author morrison;	state Exp;
branches;
next	1.33;

1.33
date	2001.03.31.01.57.02;	author morrison;	state Exp;
branches;
next	1.32;

1.32
date	2000.10.19.19.19.45;	author butler;	state Exp;
branches;
next	1.31;

1.31
date	2000.09.09.04.30.50;	author mike;	state Exp;
branches;
next	1.30;

1.30
date	2000.07.25.16.40.37;	author butler;	state Exp;
branches;
next	1.29;

1.29
date	2000.02.19.21.05.01;	author butler;	state Exp;
branches;
next	1.28;

1.28
date	2000.02.18.04.39.06;	author butler;	state Exp;
branches;
next	1.27;

1.27
date	2000.02.03.23.28.26;	author mike;	state Exp;
branches;
next	1.26;

1.26
date	99.12.30.16.08.25;	author jra;	state Exp;
branches;
next	1.25;

1.25
date	99.10.30.03.06.24;	author butler;	state Exp;
branches;
next	1.24;

1.24
date	99.07.02.22.20.40;	author mike;	state Exp;
branches;
next	1.23;

1.23
date	99.07.01.20.08.45;	author mike;	state Exp;
branches;
next	1.22;

1.22
date	99.05.13.20.25.00;	author mike;	state Exp;
branches;
next	1.21;

1.21
date	99.02.19.03.38.10;	author butler;	state Exp;
branches;
next	1.20;

1.20
date	99.02.04.02.20.30;	author butler;	state Exp;
branches;
next	1.19;

1.19
date	98.09.22.01.29.53;	author mike;	state Exp;
branches;
next	1.18;

1.18
date	98.06.30.22.54.17;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	97.12.31.09.01.40;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	97.12.09.04.44.44;	author butler;	state Exp;
branches;
next	1.15;

1.15
date	97.07.02.21.13.25;	author butler;	state Exp;
branches;
next	1.14;

1.14
date	97.05.21.01.29.02;	author butler;	state Exp;
branches;
next	1.13;

1.13
date	97.02.09.01.46.06;	author jra;	state Exp;
branches;
next	1.12;

1.12
date	97.01.24.19.31.32;	author pjt;	state Exp;
branches;
next	1.11;

1.11
date	96.08.31.08.46.01;	author butler;	state Exp;
branches;
next	1.10;

1.10
date	96.08.31.08.29.28;	author butler;	state Exp;
branches;
next	1.9;

1.9
date	96.08.30.00.08.21;	author butler;	state Exp;
branches;
next	1.8;

1.8
date	96.08.21.13.48.41;	author jra;	state Exp;
branches;
next	1.7;

1.7
date	96.07.30.20.35.55;	author butler;	state Exp;
branches;
next	1.6;

1.6
date	95.12.27.17.29.41;	author butler;	state Exp;
branches;
next	1.5;

1.5
date	95.10.20.04.43.53;	author butler;	state Exp;
branches;
next	1.4;

1.4
date	95.08.19.05.06.10;	author butler;	state Exp;
branches;
next	1.3;

1.3
date	95.06.03.00.44.53;	author butler;	state Exp;
branches;
next	1.2;

1.2
date	95.06.02.04.55.27;	author butler;	state Exp;
branches;
next	1.1;

1.1
date	95.06.02.04.29.10;	author butler;	state Exp;
branches;
next	;

1.37.2.1
date	2002.09.19.18.01.24;	author morrison;	state Exp;
branches;
next	;


desc
@Camoflage shader
@


1.40
log
@moved to src/
@
text
@/*
 *	S H _ C A M O . C
 *
 *	A shader to apply a crude camoflage color pattern to an object
 *	using a fractional Brownian motion of 3 colors
 *
 *	At each hit point, the shader evaluate the fbm to obtain a "Noise"
 *	value between -1 and 1.  The color produced is:
 *
 *	Noise value		Color
 *	-1 <= N < t1		 c1
 *	t1 <= N < t2		 c2
 *	t2 <= N <= 1		 c3
 */
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef HAVE_STRING_H
#include <string.h>
#endif
#include <math.h>
#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "shadefuncs.h"
#include "shadework.h"
#include "rtprivate.h"

#if !defined(M_PI)
#define M_PI            3.14159265358979323846
#endif

#define SMOOTHSTEP(x)  ((x)*(x)*(3 - 2*(x)))

#if RT_MULTISPECTRAL
#include "spectrum.h"
extern const struct bn_table	*spectrum;	/* from rttherm/viewtherm.c */
#endif

#define camo_MAGIC 0x18364	/* XXX change this number for each shader */
struct camo_specific {
	long	magic;
	double	noise_lacunarity;
	double	noise_h_val;
	double	noise_octaves;
	double	noise_size;
	point_t	noise_vscale;	/* size of noise coordinate space */
	vect_t	noise_delta;	/* a delta in noise space to be applied to pts */

	double	t1;	/* noise threshold for color1 */
	double	t2;	/* noise threshold for color2 */
	point_t c1;	/* color 1 */
	point_t c2;	/* color 2 */
	point_t c3;	/* color 3 */
	mat_t	xform;	/* model->region coord sys matrix */
};
#define CK_camo_SP(_p) BU_CKMAG(_p, camo_MAGIC, "camo_specific")

/* This allows us to specify the "size" parameter as values like ".5m"
 * or "27in" rather than using mm all the time.
 */
void
camo_cvt_parse(register const struct bu_structparse *sdp, register const char *name, char *base, const char *value)
                                    	     	/* structure description */
                   			      	/* struct member name */
    					      	/* begining of structure */
          				       	/* string containing value */
{
	double *p = (double *)(base+sdp->sp_offset);

	/* reconvert with optional units */
	*p = rt_mm_value(value);
}


static struct camo_specific camo_defaults = {
	camo_MAGIC,
	2.1753974,		/* noise_lacunarity */
	1.0,			/* noise_h_val */
	4.0,			/* noise_octaves */
	1.0,			/* noise_size */
	{ 0.0125, 0.0125, 0.0125 },	/* noise_vscale */
	{ 1000.0, 1000.0, 1000.0 },	/* delta into noise space */
	-0.25,			/* t1 */
	0.25,			/* t2 */
	{ .38, .29, .16 },	/* darker color c1 (97/74/41) */
	{ .1, .30, .04 },	/* basic color c2 (26/77/10) */
	{ .15, .15, .15 }	/* dark black (38/38/38) */
	};

static struct camo_specific marble_defaults = {
	camo_MAGIC,
	2.1753974,		/* noise_lacunarity */
	1.0,			/* noise_h_val */
	4.0,			/* noise_octaves */
	1.0,			/* noise_size */
	{ 1.0, 1.0, 1.0 },	/* noise_vscale */
	{ 1000.0, 1000.0, 1000.0 },	/* delta into noise space */
	0.25,			/* t1 */
	0.5,			/* t2 */
	{ .8, .2, .16 },	/* darker color c1 (97/74/41) */
	{ .9, .9, .8 },	/* basic color c2 (26/77/10) */
	{ .15, .15, .15 }	/* dark black (38/38/38) */
	};

#define SHDR_NULL	((struct camo_specific *)0)
#define SHDR_O(m)	offsetof(struct camo_specific, m)
#define SHDR_AO(m)	bu_offsetofarray(struct camo_specific, m)

void color_fix(register const struct bu_structparse *sdp, register const char *name, char *base, const char *value);

struct bu_structparse camo_print_tab[] = {
	{"%f",	1, "lacunarity",	SHDR_O(noise_lacunarity),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "H", 		SHDR_O(noise_h_val),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "octaves", 		SHDR_O(noise_octaves),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",  1, "size",		SHDR_O(noise_size),		bu_mm_cvt },
	{"%f",  3, "vscale",		SHDR_AO(noise_vscale),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "thresh1",		SHDR_O(t1),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "thresh2",		SHDR_O(t2),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",  3, "color1",		SHDR_AO(c1),		color_fix },
	{"%f",  3, "color2",		SHDR_AO(c2),		color_fix },
	{"%f",  3, "color3",		SHDR_AO(c3),		color_fix },
	{"%f",  3, "delta",		SHDR_AO(noise_delta),	BU_STRUCTPARSE_FUNC_NULL },
	{"",	0, (char *)0,		0,			BU_STRUCTPARSE_FUNC_NULL }
};

struct bu_structparse camo_parse[] = {
	{"%f",	1, "lacunarity",	SHDR_O(noise_lacunarity),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "l",			SHDR_O(noise_lacunarity),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "H", 		SHDR_O(noise_h_val),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "octaves", 		SHDR_O(noise_octaves),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "o", 		SHDR_O(noise_octaves),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "t1",		SHDR_O(t1),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "t2",		SHDR_O(t2),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",  1, "size",		SHDR_O(noise_size),		bu_mm_cvt },
	{"%f",  1, "s",			SHDR_O(noise_size),		bu_mm_cvt },
	{"%f",  3, "vscale",		SHDR_AO(noise_vscale),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",  3, "vs",		SHDR_AO(noise_vscale),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",  3, "v",			SHDR_AO(noise_vscale),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",  3, "c1",		SHDR_AO(c1),		color_fix },
	{"%f",  3, "c2",		SHDR_AO(c2),		color_fix },
	{"%f",  3, "c3",		SHDR_AO(c3),		color_fix },
	{"%f",  3, "delta",		SHDR_AO(noise_delta),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",  3, "d",			SHDR_AO(noise_delta),		BU_STRUCTPARSE_FUNC_NULL },
	{"",	0, (char *)0,		0,			BU_STRUCTPARSE_FUNC_NULL }
};

HIDDEN int	marble_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip), marble_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
HIDDEN int	camo_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip), camo_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
HIDDEN void	camo_print(register struct region *rp, char *dp), camo_free(char *cp);

struct mfuncs camo_mfuncs[] = {
	{MF_MAGIC,	"camo",		0,		MFI_HIT,	0,
	camo_setup,	camo_render,	camo_print,	camo_free },

	{MF_MAGIC,	"marble",		0,		MFI_HIT,	0,
	marble_setup,	marble_render,	camo_print,	camo_free },

	{0,		(char *)0,	0,		0,		0,
	0,		0,		0,		0 }
};

/*  color_fix
 *
 *  Used as a hooked function for input of color values
 */
void
color_fix(register const struct bu_structparse *sdp, register const char *name, char *base, const char *value)
                                    	     	/* structure description */
                   			      	/* struct member name */
    					      	/* begining of structure */
          				       	/* string containing value */
{
	register double *p = (double *)(base+sdp->sp_offset);
	register int i;
	int ok;

	/* if all the values are in the range [0..1] there's nothing to do */
	for (ok=1, i=0 ; i < sdp->sp_count ; i++, p++) {
		if (*p > 1.0) ok = 0;
	}
	if (ok) return;

	/* user specified colors in the range [0..255] so we need to
	 * map those into [0..1]
	 */
	p = (double *)(base+sdp->sp_offset);
	for (i=0 ; i < sdp->sp_count ; i++, p++) {
		*p /= 255.0;
	}
}




/*	C A M O _ S E T U P
 *
 *	This routine is called (at prep time)
 *	once for each region which uses this shader.
 *	Any shader-specific initialization should be done here.
 */
HIDDEN int
camo_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip)
                      	    
             		         
    			      	/* pointer to reg_udata in *rp */
             		     
           		      	/* New since 4.4 release */
{
	register struct camo_specific	*camo_sp;
	mat_t	model_to_region;
	mat_t	tmp;

	RT_CHECK_RTI(rtip);
	BU_CK_VLS( matparm );
	RT_CK_REGION(rp);
	BU_GETSTRUCT( camo_sp, camo_specific );
	*dpp = (char *)camo_sp;

	if (rdebug&RDEBUG_SHADE) {
		bu_log("camouflage parameters = '%s'\n", bu_vls_addr(matparm));
	}
	memcpy(camo_sp, &camo_defaults, sizeof(struct camo_specific) );

	if (bu_struct_parse( matparm, camo_parse, (char *)camo_sp ) < 0 )
		return(-1);

	/* Optional:  get the matrix which maps model space into
	 *  "region" or "shader" space
	 */
	db_region_mat(model_to_region, rtip->rti_dbip, rp->reg_name, &rt_uniresource);

	/* add the noise-space scaling */
	MAT_IDN(tmp);
	if (camo_sp->noise_size != 1.0) {
		/* the user sets "noise_size" to the size of the biggest
		 * noise-space blob in model coordinates
		 */
		tmp[0] = tmp[5] = tmp[10] = 1.0/camo_sp->noise_size;
	} else {
		tmp[0] = 1.0/camo_sp->noise_vscale[0];
		tmp[5] = 1.0/camo_sp->noise_vscale[1];
		tmp[10] = 1.0/camo_sp->noise_vscale[2];
	}

	bn_mat_mul(camo_sp->xform, tmp, model_to_region);

	/* Add any translation within shader/region space */
	MAT_IDN(tmp);
	tmp[MDX] = camo_sp->noise_delta[0];
	tmp[MDY] = camo_sp->noise_delta[1];
	tmp[MDZ] = camo_sp->noise_delta[2];
	bn_mat_mul2(tmp, camo_sp->xform);

	if (rdebug&RDEBUG_SHADE) {
		bu_struct_print( rp->reg_name, camo_print_tab,
			(char *)camo_sp );
		bn_mat_print( "xform", camo_sp->xform );
	}

	return(1);
}

/*
 *	C A M O _ P R I N T
 */
HIDDEN void
camo_print(register struct region *rp, char *dp)
{
	bu_struct_print( rp->reg_name, camo_print_tab, (char *)dp );
}

/*
 *	C A M O _ F R E E
 */
HIDDEN void
camo_free(char *cp)
{
	bu_free( cp, "camo_specific" );
}

/*
 *	C A M O _ R E N D E R
 *
 *	This is called (from viewshade() in shade.c)
 *	once for each hit point to be shaded.
 */
int
camo_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
{
	register struct camo_specific *camo_sp =
		(struct camo_specific *)dp;
	point_t pt;
	double val;
#if RT_MULTISPECTRAL
	float fcolor[3];
#endif

	RT_AP_CHECK(ap);
	RT_CHECK_PT(pp);
	CK_camo_SP(camo_sp);

	if (rdebug&RDEBUG_SHADE)
		bu_struct_print( "foo", camo_parse, (char *)camo_sp );

	/* Optional: transform hit point into "shader-space coordinates" */
	MAT4X3PNT(pt, camo_sp->xform, swp->sw_hit.hit_point);


	/* bn_noise_fbm returns a value in the approximate range of
	 *	-1.0 ~<= bn_noise_fbm() ~<= 1.0
	 */
	val = bn_noise_fbm(pt, camo_sp->noise_h_val,
		camo_sp->noise_lacunarity, camo_sp->noise_octaves );

#if RT_MULTISPECTRAL
	BN_CK_TABDATA(swp->msw_color);
	if (val < camo_sp->t1) {
		VMOVE(fcolor, camo_sp->c1 );
		rt_spect_reflectance_rgb( swp->msw_color, fcolor);
	} else if (val < camo_sp->t2 ) {
		VMOVE(fcolor, camo_sp->c2 );
		rt_spect_reflectance_rgb( swp->msw_color, fcolor);
	} else {
		VMOVE(fcolor, camo_sp->c3 );
		rt_spect_reflectance_rgb( swp->msw_color, fcolor);
	}
#else
	if (val < camo_sp->t1) {
		VMOVE(swp->sw_color, camo_sp->c1);
	} else if (val < camo_sp->t2 ) {
		VMOVE(swp->sw_color, camo_sp->c2);
	} else {
		VMOVE(swp->sw_color, camo_sp->c3);
	}
#endif

	return(1);
}
/*	M A R B L E 2 _ S E T U P
 *
 *	This routine is called (at prep time)
 *	once for each region which uses this shader.
 *	Any shader-specific initialization should be done here.
 */
HIDDEN int
marble_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip)
                      	    
             		         
    			      	/* pointer to reg_udata in *rp */
             		     
           		      	/* New since 4.4 release */
{
	register struct camo_specific	*camo_sp;
	mat_t	model_to_region;
	mat_t	tmp;

	RT_CHECK_RTI(rtip);
	BU_CK_VLS( matparm );
	RT_CK_REGION(rp);
	BU_GETSTRUCT( camo_sp, camo_specific );
	*dpp = (char *)camo_sp;

	if (rdebug&RDEBUG_SHADE) {
		bu_log("marble parameters = '%s'\n", bu_vls_addr(matparm));
	}
	memcpy(camo_sp, &marble_defaults, sizeof(struct camo_specific) );

	if (bu_struct_parse( matparm, camo_parse, (char *)camo_sp ) < 0 )
		return(-1);

	/* Optional:  get the matrix which maps model space into
	 *  "region" or "shader" space
	 */
	db_region_mat(model_to_region, rtip->rti_dbip, rp->reg_name, &rt_uniresource);

	/* add the noise-space scaling */
	MAT_IDN(tmp);
	if (camo_sp->noise_size != 1.0) {
		/* the user sets "noise_size" to the size of the biggest
		 * noise-space blob in model coordinates
		 */
		tmp[0] = tmp[5] = tmp[10] = 1.0/camo_sp->noise_size;
	} else {
		tmp[0] = 1.0/camo_sp->noise_vscale[0];
		tmp[5] = 1.0/camo_sp->noise_vscale[1];
		tmp[10] = 1.0/camo_sp->noise_vscale[2];
	}

	bn_mat_mul(camo_sp->xform, tmp, model_to_region);

	/* Add any translation within shader/region space */
	MAT_IDN(tmp);
	tmp[MDX] = camo_sp->noise_delta[0];
	tmp[MDY] = camo_sp->noise_delta[1];
	tmp[MDZ] = camo_sp->noise_delta[2];
	bn_mat_mul2(tmp, camo_sp->xform);

	if (rdebug&RDEBUG_SHADE) {
		bu_struct_print( rp->reg_name, camo_print_tab,
			(char *)camo_sp );
		bn_mat_print( "xform", camo_sp->xform );
	}

	return(1);
}



/*
 *	M A R B L E 2 _ R E N D E R
 *
 *	This is called (from viewshade() in shade.c)
 *	once for each hit point to be shaded.
 */
int
marble_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
{
	register struct camo_specific *camo_sp =
		(struct camo_specific *)dp;
	point_t pt;
	double val, inv_val;
#ifdef RT_MULTISPECTRAL
	float fcolor[3];
#endif

	RT_AP_CHECK(ap);
	RT_CHECK_PT(pp);
	CK_camo_SP(camo_sp);

	if (rdebug&RDEBUG_SHADE)
		bu_struct_print( "foo", camo_parse, (char *)camo_sp );

	/* Optional: transform hit point into "shader-space coordinates" */
	MAT4X3PNT(pt, camo_sp->xform, swp->sw_hit.hit_point);


	/* bn_noise_turb returns a value in the approximate range of
	 *	0.0 ~<= bn_noise_turb() ~<= 1.0
	 */
	val = bn_noise_turb(pt, camo_sp->noise_h_val,
		camo_sp->noise_lacunarity, camo_sp->noise_octaves );

#if 0
	val *= 2.0;
	CLAMP(val, 0.0, 1.0);
#else
	val = sin(val*M_PI);
	
#endif
	inv_val = 1.0 - val;

#if RT_MULTISPECTRAL
	{
		struct bn_tabdata *tcolor;

		BN_CK_TABDATA(swp->msw_color);
		BN_GET_TABDATA( tcolor, spectrum );

		VMOVE(fcolor, camo_sp->c2 );

		rt_spect_reflectance_rgb( tcolor, fcolor );
		bn_tabdata_blend2( swp->msw_color, val, swp->msw_color,
			inv_val, tcolor );
		bn_tabdata_free( tcolor );
	}
#else
	VCOMB2(swp->sw_color, val, swp->sw_color, inv_val, camo_sp->c2);
#endif

	return(1);
}
@


1.39
log
@change conf.h to a wrapped config.h
@
text
@@


1.38
log
@merge of ansi-6-0-branch into HEAD
@
text
@d15 5
a19 1
#include "conf.h"
@


1.37
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d63 5
a67 5
camo_cvt_parse( sdp, name, base, value )
register const struct bu_structparse	*sdp;	/* structure description */
register const char			*name;	/* struct member name */
char					*base;	/* begining of structure */
const char				*value;	/* string containing value */
d110 1
a110 1
void color_fix();
d148 3
a150 3
HIDDEN int	marble_setup(), marble_render();
HIDDEN int	camo_setup(), camo_render();
HIDDEN void	camo_print(), camo_free();
d168 5
a172 5
color_fix( sdp, name, base, value )
register const struct bu_structparse	*sdp;	/* structure description */
register const char			*name;	/* struct member name */
char					*base;	/* begining of structure */
const char				*value;	/* string containing value */
d203 6
a208 6
camo_setup( rp, matparm, dpp, mfp, rtip)
register struct region	*rp;
struct bu_vls		*matparm;
char			**dpp;	/* pointer to reg_udata in *rp */
struct mfuncs		*mfp;
struct rt_i		*rtip;	/* New since 4.4 release */
d268 1
a268 3
camo_print( rp, dp )
register struct region *rp;
char	*dp;
d277 1
a277 2
camo_free( cp )
char *cp;
d289 1
a289 5
camo_render( ap, pp, swp, dp )
struct application	*ap;
struct partition	*pp;
struct shadework	*swp;
char	*dp;
d347 6
a352 6
marble_setup( rp, matparm, dpp, mfp, rtip)
register struct region	*rp;
struct bu_vls		*matparm;
char			**dpp;	/* pointer to reg_udata in *rp */
struct mfuncs		*mfp;
struct rt_i		*rtip;	/* New since 4.4 release */
d417 1
a417 5
marble_render( ap, pp, swp, dp )
struct application	*ap;
struct partition	*pp;
struct shadework	*swp;
char	*dp;
@


1.37.2.1
log
@Initial ANSIfication
@
text
@d63 5
a67 5
camo_cvt_parse(register const struct bu_structparse *sdp, register const char *name, char *base, const char *value)
                                    	     	/* structure description */
                   			      	/* struct member name */
    					      	/* begining of structure */
          				       	/* string containing value */
d110 1
a110 1
void color_fix(register const struct bu_structparse *sdp, register const char *name, char *base, const char *value);
d148 3
a150 3
HIDDEN int	marble_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip), marble_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
HIDDEN int	camo_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip), camo_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
HIDDEN void	camo_print(register struct region *rp, char *dp), camo_free(char *cp);
d168 5
a172 5
color_fix(register const struct bu_structparse *sdp, register const char *name, char *base, const char *value)
                                    	     	/* structure description */
                   			      	/* struct member name */
    					      	/* begining of structure */
          				       	/* string containing value */
d203 6
a208 6
camo_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip)
                      	    
             		         
    			      	/* pointer to reg_udata in *rp */
             		     
           		      	/* New since 4.4 release */
d268 3
a270 1
camo_print(register struct region *rp, char *dp)
d279 2
a280 1
camo_free(char *cp)
d292 5
a296 1
camo_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
d354 6
a359 6
marble_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip)
                      	    
             		         
    			      	/* pointer to reg_udata in *rp */
             		     
           		      	/* New since 4.4 release */
d424 5
a428 1
marble_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
@


1.36
log
@Converted from K&R to ANSI C - RFH
@
text
@d63 5
a67 5
camo_cvt_parse(register const struct bu_structparse *sdp, register const char *name, char *base, const char *value)
                                    	     	/* structure description */
                   			      	/* struct member name */
    					      	/* begining of structure */
          				       	/* string containing value */
d110 1
a110 1
void color_fix(register const struct bu_structparse *sdp, register const char *name, char *base, const char *value);
d148 3
a150 3
HIDDEN int	marble_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip), marble_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
HIDDEN int	camo_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip), camo_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
HIDDEN void	camo_print(register struct region *rp, char *dp), camo_free(char *cp);
d168 5
a172 5
color_fix(register const struct bu_structparse *sdp, register const char *name, char *base, const char *value)
                                    	     	/* structure description */
                   			      	/* struct member name */
    					      	/* begining of structure */
          				       	/* string containing value */
d203 6
a208 6
camo_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip)
                      	    
             		         
    			      	/* pointer to reg_udata in *rp */
             		     
           		      	/* New since 4.4 release */
d268 3
a270 1
camo_print(register struct region *rp, char *dp)
d279 2
a280 1
camo_free(char *cp)
d292 5
a296 1
camo_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
d354 6
a359 6
marble_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip)
                      	    
             		         
    			      	/* pointer to reg_udata in *rp */
             		     
           		      	/* New since 4.4 release */
d424 5
a428 1
marble_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
@


1.35
log
@Mac OS X warning and error fixes for non-production build
@
text
@d63 5
a67 5
camo_cvt_parse( sdp, name, base, value )
register const struct bu_structparse	*sdp;	/* structure description */
register const char			*name;	/* struct member name */
char					*base;	/* begining of structure */
const char				*value;	/* string containing value */
d110 1
a110 1
void color_fix();
d148 3
a150 3
HIDDEN int	marble_setup(), marble_render();
HIDDEN int	camo_setup(), camo_render();
HIDDEN void	camo_print(), camo_free();
d168 5
a172 5
color_fix( sdp, name, base, value )
register const struct bu_structparse	*sdp;	/* structure description */
register const char			*name;	/* struct member name */
char					*base;	/* begining of structure */
const char				*value;	/* string containing value */
d203 6
a208 6
camo_setup( rp, matparm, dpp, mfp, rtip)
register struct region	*rp;
struct bu_vls		*matparm;
char			**dpp;	/* pointer to reg_udata in *rp */
struct mfuncs		*mfp;
struct rt_i		*rtip;	/* New since 4.4 release */
d268 1
a268 3
camo_print( rp, dp )
register struct region *rp;
char	*dp;
d277 1
a277 2
camo_free( cp )
char *cp;
d289 1
a289 5
camo_render( ap, pp, swp, dp )
struct application	*ap;
struct partition	*pp;
struct shadework	*swp;
char	*dp;
d347 6
a352 6
marble_setup( rp, matparm, dpp, mfp, rtip)
register struct region	*rp;
struct bu_vls		*matparm;
char			**dpp;	/* pointer to reg_udata in *rp */
struct mfuncs		*mfp;
struct rt_i		*rtip;	/* New since 4.4 release */
d417 1
a417 5
marble_render( ap, pp, swp, dp )
struct application	*ap;
struct partition	*pp;
struct shadework	*swp;
char	*dp;
@


1.34
log
@CONST to const
@
text
@d196 1
a196 1
/*	C A M O _ S E T U P
d285 1
a285 1
/*
d347 1
a347 1
/*	M A R B L E 2 _ S E T U P
d417 1
a417 1
/*
@


1.33
log
@Deprecated bn_mat_idn() and bn_mat_zero(), updated calls to h/vmath.h's MAT_IDN() and MAT_ZERO() performance improved macros.
@
text
@d37 1
a37 1
extern CONST struct bn_table	*spectrum;	/* from rttherm/viewtherm.c */
d64 2
a65 2
register CONST struct bu_structparse	*sdp;	/* structure description */
register CONST char			*name;	/* struct member name */
d67 1
a67 1
CONST char				*value;	/* string containing value */
d169 2
a170 2
register CONST struct bu_structparse	*sdp;	/* structure description */
register CONST char			*name;	/* struct member name */
d172 1
a172 1
CONST char				*value;	/* string containing value */
@


1.32
log
@Changes to compile under RedHat 7.0
@
text
@d234 1
a234 1
	bn_mat_idn(tmp);
d249 1
a249 1
	bn_mat_idn(tmp);
d385 1
a385 1
	bn_mat_idn(tmp);
d400 1
a400 1
	bn_mat_idn(tmp);
@


1.31
log
@
Struct db_tree_state finally got a magic number. Added resource argument
to ft_describe(), db_region_mat(), db_shader_mat(),
db_init_db_tree_state(), and db_path_to_mat().
@
text
@d18 3
d36 1
d302 3
d326 2
a327 1
		rt_spect_reflectance_rgb( swp->msw_color, camo_sp->c1 );
d329 2
a330 1
		rt_spect_reflectance_rgb( swp->msw_color, camo_sp->c2 );
d332 2
a333 1
		rt_spect_reflectance_rgb( swp->msw_color, camo_sp->c3 );
d434 3
d470 4
a473 1
		rt_spect_reflectance_rgb( tcolor, camo_sp->c2 );
@


1.30
log
@Changes to use rtprivate.h instead of ../rt/rdebug.h
@
text
@d227 1
a227 1
	db_region_mat(model_to_region, rtip->rti_dbip, rp->reg_name);
d372 1
a372 1
	db_region_mat(model_to_region, rtip->rti_dbip, rp->reg_name);
@


1.29
log
@Changes to support movement of CLAMP() macro into vmath.h
Altered "if( " statements to "if (" for readability.
@
text
@d24 1
a24 1
#include "../rt/rdebug.h"
@


1.28
log
@Light now keeps both the visible and invisible flags.
camo now has different defaults for the noise scale.
@
text
@a30 1
#define CLAMP(v, l, h)  if (v < l) v = l; if (v > h) v = h
d216 1
a216 1
	if( rdebug&RDEBUG_SHADE) {
d221 1
a221 1
	if( bu_struct_parse( matparm, camo_parse, (char *)camo_sp ) < 0 )
d251 1
a251 1
	if( rdebug&RDEBUG_SHADE) {
d303 1
a303 1
	if( rdebug&RDEBUG_SHADE)
d361 1
a361 1
	if( rdebug&RDEBUG_SHADE) {
d366 1
a366 1
	if( bu_struct_parse( matparm, camo_parse, (char *)camo_sp ) < 0 )
d396 1
a396 1
	if( rdebug&RDEBUG_SHADE) {
d429 1
a429 1
	if( rdebug&RDEBUG_SHADE)
@


1.27
log
@
Multi-spectral camo
@
text
@d79 1
a79 1
	{ 1.0, 1.0, 1.0 },	/* noise_vscale */
@


1.26
log
@Eliminated an unused variable
@
text
@d33 3
d317 10
d334 1
d452 12
d465 1
@


1.25
log
@Moved mathtab/rand_half from rt into libbn
Expanded structparse to include description and default
@
text
@a62 1
	double v;
@


1.24
log
@
Removed dependence on compat4.h
@
text
@a23 1
#include "../rt/mathtab.h"
@


1.23
log
@
compat4
@
text
@d109 3
a111 3
	{"%f",	1, "lacunarity",	SHDR_O(noise_lacunarity),	FUNC_NULL },
	{"%f",	1, "H", 		SHDR_O(noise_h_val),		FUNC_NULL },
	{"%f",	1, "octaves", 		SHDR_O(noise_octaves),	FUNC_NULL },
d113 3
a115 3
	{"%f",  3, "vscale",		SHDR_AO(noise_vscale),	FUNC_NULL },
	{"%f",	1, "thresh1",		SHDR_O(t1),		FUNC_NULL },
	{"%f",	1, "thresh2",		SHDR_O(t2),		FUNC_NULL },
d119 2
a120 2
	{"%f",  3, "delta",		SHDR_AO(noise_delta),	FUNC_NULL },
	{"",	0, (char *)0,		0,			FUNC_NULL }
d124 7
a130 7
	{"%f",	1, "lacunarity",	SHDR_O(noise_lacunarity),	FUNC_NULL },
	{"%f",	1, "l",			SHDR_O(noise_lacunarity),	FUNC_NULL },
	{"%f",	1, "H", 		SHDR_O(noise_h_val),		FUNC_NULL },
	{"%f",	1, "octaves", 		SHDR_O(noise_octaves),	FUNC_NULL },
	{"%f",	1, "o", 		SHDR_O(noise_octaves),	FUNC_NULL },
	{"%f",	1, "t1",		SHDR_O(t1),		FUNC_NULL },
	{"%f",	1, "t2",		SHDR_O(t2),		FUNC_NULL },
d133 3
a135 3
	{"%f",  3, "vscale",		SHDR_AO(noise_vscale),	FUNC_NULL },
	{"%f",  3, "vs",		SHDR_AO(noise_vscale),	FUNC_NULL },
	{"%f",  3, "v",			SHDR_AO(noise_vscale),	FUNC_NULL },
d139 3
a141 3
	{"%f",  3, "delta",		SHDR_AO(noise_delta),		FUNC_NULL },
	{"%f",  3, "d",			SHDR_AO(noise_delta),		FUNC_NULL },
	{"",	0, (char *)0,		0,			FUNC_NULL }
@


1.22
log
@M_PI wasn't properly defined.
@
text
@d52 1
a52 1
#define CK_camo_SP(_p) RT_CKMAG(_p, camo_MAGIC, "camo_specific")
d104 1
a104 1
#define SHDR_AO(m)	offsetofarray(struct camo_specific, m)
d201 1
a201 1
struct rt_vls		*matparm;
d211 1
a211 1
	RT_VLS_CHECK( matparm );
d213 1
a213 1
	GETSTRUCT( camo_sp, camo_specific );
d217 1
a217 1
		rt_log("camouflage parameters = '%s'\n", bu_vls_addr(matparm));
d230 1
a230 1
	mat_idn(tmp);
d242 1
a242 1
	mat_mul(camo_sp->xform, tmp, model_to_region);
d245 1
a245 1
	mat_idn(tmp);
d249 1
a249 1
	mat_mul2(tmp, camo_sp->xform);
d254 1
a254 1
		mat_print( "xform", camo_sp->xform );
d278 1
a278 1
	rt_free( cp, "camo_specific" );
d310 2
a311 2
	/* noise_fbm returns a value in the approximate range of
	 *	-1.0 ~<= noise_fbm() ~<= 1.0
d313 1
a313 1
	val = noise_fbm(pt, camo_sp->noise_h_val,
d335 1
a335 1
struct rt_vls		*matparm;
d345 1
a345 1
	RT_VLS_CHECK( matparm );
d347 1
a347 1
	GETSTRUCT( camo_sp, camo_specific );
d351 1
a351 1
		rt_log("marble parameters = '%s'\n", bu_vls_addr(matparm));
d364 1
a364 1
	mat_idn(tmp);
d376 1
a376 1
	mat_mul(camo_sp->xform, tmp, model_to_region);
d379 1
a379 1
	mat_idn(tmp);
d383 1
a383 1
	mat_mul2(tmp, camo_sp->xform);
d388 1
a388 1
		mat_print( "xform", camo_sp->xform );
d425 2
a426 2
	/* noise_turb returns a value in the approximate range of
	 *	0.0 ~<= noise_turb() ~<= 1.0
d428 1
a428 1
	val = noise_turb(pt, camo_sp->noise_h_val,
@


1.21
log
@Added treetherm shader
@
text
@d27 4
@


1.20
log
@Added a quick "marble" shader that actually WORKS ( *gasp* )
@
text
@d427 1
d430 4
@


1.19
log
@Moved optical shaders from rt/ to liboptical/
The only modifications involved moving and splitting
rt/material.h into h/shadefuncs.h and h/shadework.h,
and in changing the calling sequence to mlib_setup() in rt/material.c

Now the only shader function called directly by RT is
in liboptical/init.c: optical_shader_init().
It adds all the individual shaders to the "mfuncs" shader list.
@
text
@d27 4
d83 15
d115 2
a116 1
	{"%f",  3, "delta",		SHDR_AO(noise_delta),		FUNC_NULL },
d140 1
d148 3
d213 1
a213 1
		rt_log("camouflage parameters = '%s'", bu_vls_addr(matparm));
d248 2
a249 1
		bu_struct_print( rp->reg_name, camo_print_tab, (char *)camo_sp );
d319 113
@


1.18
log
@Can't make "struct mfuncs" a CONST, because the forward link needs
to be filled in at runtime, and some compilers put CONST data into
read-only pages (like FreeBSD).
@
text
@d22 4
a25 3
#include "./material.h"
#include "./mathtab.h"
#include "./rdebug.h"
@


1.17
log
@Required magic number to be first in mfunc table,
consistent with all other BRL-CAD magic numbers.
Required magic number to be initialized at compile time.
Added code to check the magic numbers.
Made the xxx_mfunc arrays CONST, so they can't get trashed by
runtime runaway pointer problems.
@
text
@d122 1
a122 1
CONST struct mfuncs camo_mfuncs[] = {
@


1.16
log
@hacked to allow color specification in the 0..1 or 0..255 ranges
@
text
@d122 2
a123 2
struct mfuncs camo_mfuncs[] = {
	{"camo",	0,		0,		MFI_HIT,	0,
d126 1
a126 1
	{(char *)0,	0,		0,		0,		0,
@


1.15
log
@checkpoint
@
text
@d36 2
a37 2
	double	t1;	/* color threshold 1 */
	double	t2;	/* color threshold 2 */
d82 2
d92 3
a94 3
	{"%f",  3, "color1",		SHDR_AO(c1),		FUNC_NULL },
	{"%f",  3, "color2",		SHDR_AO(c2),		FUNC_NULL },
	{"%f",  3, "color3",		SHDR_AO(c3),		FUNC_NULL },
d111 3
a113 3
	{"%f",  3, "c1",		SHDR_AO(c1),		FUNC_NULL },
	{"%f",  3, "c2",		SHDR_AO(c2),		FUNC_NULL },
	{"%f",  3, "c3",		SHDR_AO(c3),		FUNC_NULL },
d129 33
@


1.14
log
@modified to use bu_mm_cvt()
@
text
@d29 7
a35 3
	double	lacunarity;
	double	h_val;
	double	octaves;
a37 2
	double	size;
	point_t	vscale;	/* size of noise coordinate space */
a40 1
	vect_t	delta;	/* a delta in noise space to be applied to pts */
d65 8
a72 7
	2.1753974,	/* lacunarity */
	1.0,		/* h_val */
	4.0,		/* octaves */
	-0.25,		/* t1 */
	0.25,		/* t2 */
	1.0,		/* size */
	{ 1.0, 1.0, 1.0 },	/* vscale */
d75 1
a75 3
/*	{ .815, .635, .35 },	brighter color c3 */
	{ .15, .15, .15 },	/* dark black (38/38/38) */
	{ 1000.0, 1000.0, 1000.0 }	/* delta into noise space */
d83 5
a87 5
	{"%f",	1, "lacunarity",	SHDR_O(lacunarity),	FUNC_NULL },
	{"%f",	1, "H", 		SHDR_O(h_val),		FUNC_NULL },
	{"%f",	1, "octaves", 		SHDR_O(octaves),	FUNC_NULL },
	{"%f",  1, "size",		SHDR_O(size),		bu_mm_cvt },
	{"%f",  3, "vscale",		SHDR_AO(vscale),	FUNC_NULL },
d93 1
a93 1
	{"%f",  3, "delta",		SHDR_AO(delta),		FUNC_NULL },
d97 5
a101 5
	{"%f",	1, "lacunarity",	SHDR_O(lacunarity),	FUNC_NULL },
	{"%f",	1, "l",			SHDR_O(lacunarity),	FUNC_NULL },
	{"%f",	1, "H", 		SHDR_O(h_val),		FUNC_NULL },
	{"%f",	1, "octaves", 		SHDR_O(octaves),	FUNC_NULL },
	{"%f",	1, "o", 		SHDR_O(octaves),	FUNC_NULL },
d104 5
a108 5
	{"%f",  1, "size",		SHDR_O(size),		bu_mm_cvt },
	{"%f",  1, "s",			SHDR_O(size),		bu_mm_cvt },
	{"%f",  3, "vscale",		SHDR_AO(vscale),	FUNC_NULL },
	{"%f",  3, "vs",		SHDR_AO(vscale),	FUNC_NULL },
	{"%f",  3, "v",			SHDR_AO(vscale),	FUNC_NULL },
d112 2
a113 2
	{"%f",  3, "delta",		SHDR_AO(delta),		FUNC_NULL },
	{"%f",  3, "d",			SHDR_AO(delta),		FUNC_NULL },
d167 2
a168 2
	if (camo_sp->size != 1.0) {
		/* the user sets "size" to the size of the biggest
d171 1
a171 1
		tmp[0] = tmp[5] = tmp[10] = 1.0/camo_sp->size;
d173 3
a175 3
		tmp[0] = 1.0/camo_sp->vscale[0];
		tmp[5] = 1.0/camo_sp->vscale[1];
		tmp[10] = 1.0/camo_sp->vscale[2];
d182 3
a184 3
	tmp[MDX] = camo_sp->delta[0];
	tmp[MDY] = camo_sp->delta[1];
	tmp[MDZ] = camo_sp->delta[2];
d248 2
a249 2
	val = noise_fbm(pt, camo_sp->h_val,
		camo_sp->lacunarity, camo_sp->octaves );
@


1.13
log
@Lee added camo_print_tab.
@
text
@d86 1
a86 1
	{"%f",  1, "size",		SHDR_O(size),		camo_cvt_parse },
d104 2
a105 2
	{"%f",  1, "size",		SHDR_O(size),		camo_cvt_parse },
	{"%f",  1, "s",			SHDR_O(size),		camo_cvt_parse },
@


1.12
log
@Added one diagnostic statement and commented the default colors
@
text
@d82 14
d188 1
a188 1
		bu_struct_print( rp->reg_name, camo_parse, (char *)camo_sp );
d203 1
a203 1
	bu_struct_print( rp->reg_name, camo_parse, (char *)dp );
@


1.11
log
@bu_struct_print
@
text
@d71 2
a72 2
	{ .38, .29, .16 },	/* darker color c1 */
	{ .1, .30, .04 },	/* basic color c2 */
d74 1
a74 1
	{ .15, .15, .15 },	/* dark black */
d138 3
@


1.10
log
@bu_struct_parse
@
text
@d171 1
a171 1
		bu_structprint( rp->reg_name, camo_parse, (char *)camo_sp );
d186 1
a186 1
	bu_structprint( rp->reg_name, camo_parse, (char *)dp );
d222 1
a222 1
		bu_structprint( "foo", camo_parse, (char *)camo_sp );
@


1.9
log
@structparse moved to libbu
@
text
@d140 1
a140 1
	if( bu_structparse( matparm, camo_parse, (char *)camo_sp ) < 0 )
@


1.8
log
@Minor mods for IRIX 6.2.
@
text
@d49 1
a49 1
register CONST struct structparse	*sdp;	/* structure description */
d82 1
a82 1
struct structparse camo_parse[] = {
d140 1
a140 1
	if( rt_structparse( matparm, camo_parse, (char *)camo_sp ) < 0 )
d171 1
a171 1
		rt_structprint( rp->reg_name, camo_parse, (char *)camo_sp );
d186 1
a186 1
	rt_structprint( rp->reg_name, camo_parse, (char *)dp );
d222 1
a222 1
		rt_structprint( "foo", camo_parse, (char *)camo_sp );
@


1.7
log
@revamped shader inputs
@
text
@d73 1
a73 1
/*	{ .815, .635, .35 },	/* brighter color c3 */
@


1.6
log
@added comments to variables
@
text
@d6 8
d34 2
a35 1
	point_t	scale;	/* scale of noise coordinate space */
d44 18
d67 4
a70 3
	-0.5,		/* t1 */
	0.5,		/* t2 */
	{ 1.0, 1.0, 1.0 },	/* scale */
d72 3
a74 2
	{ .125, .35, .04 },	/* basic color c2 */
	{ .815, .635, .35 },	/* brighter color c3 */
d90 5
a94 2
	{"%f",  3, "scale",		SHDR_AO(scale),		FUNC_NULL },
	{"%f",  3, "s",			SHDR_AO(scale),		FUNC_NULL },
a113 1

d150 10
a159 3
	tmp[0] = camo_sp->scale[0];
	tmp[5] = camo_sp->scale[1];
	tmp[10] = camo_sp->scale[2];
@


1.5
log
@edited mfuncs table to account for new "mf_flags" element in struct mfuncs.
@
text
@d24 8
a31 8
	double	t1;
	double	t2;
	point_t	scale;	/* scale coordinate space */
	point_t c1;
	point_t c2;
	point_t c3;
	vect_t	delta;
	mat_t	xform;
@


1.4
log
@rewrite from sh_xxx.c
@
text
@d75 1
a75 1
	{"camo",	0,	0,		MFI_HIT,
d78 1
a78 1
	{(char *)0,	0,		0,		0,
@


1.3
log
@changed so that model_to_region matrix is computed only at setup time.
@
text
@d4 2
a5 1
 *	A camoflage shader
a16 1
#define M_PI            3.14159265358979323846
d18 1
a18 4
#define CLAMP(_x,_a,_b)	(_x < _a ? _a : (_x > _b ? _b : _x))
#define FLOOR(x)	(  (int)(x) - (  (x) < 0 && (x) != (int)(x)  )  )
#define CEIL(x)		(  (int)(x) + (  (x) > 0 && (x) != (int)(x)  )  )

d20 1
d33 1
d36 1
d49 3
a51 3
#define CAMO_NULL	((struct camo_specific *)0)
#define CAMO_O(m)	offsetof(struct camo_specific, m)
#define CAMO_AO(m)	offsetofarray(struct camo_specific, m)
d54 14
a67 15
	{"%f",	1, "lacunarity",	CAMO_O(lacunarity),	FUNC_NULL },
	{"%f",	1, "H", 		CAMO_O(h_val),		FUNC_NULL },
	{"%f",	1, "octaves", 		CAMO_O(octaves),		FUNC_NULL },
	{"%f",	1, "t1",		CAMO_O(t1),		FUNC_NULL },
	{"%f",	1, "t2",		CAMO_O(t2),		FUNC_NULL },
	{"%f",  3, "scale",		CAMO_AO(scale),		FUNC_NULL },
	{"%f",  3, "c1",		CAMO_AO(c1),		FUNC_NULL },
	{"%f",  3, "c2",		CAMO_AO(c2),		FUNC_NULL },
	{"%f",  3, "c3",		CAMO_AO(c3),		FUNC_NULL },
	{"%f",  3, "delta",		CAMO_AO(delta),		FUNC_NULL },
	{"%f",	1, "l",			CAMO_O(lacunarity),	FUNC_NULL },
	{"%d",	1, "o", 		CAMO_O(octaves),		FUNC_NULL },
	{"%f",  3, "s",			CAMO_AO(scale),		FUNC_NULL },
	{"%f",  3, "d",			CAMO_AO(delta),		FUNC_NULL },

d75 1
a75 1
	{"camo",	0,		0,		MFI_NORMAL|MFI_HIT|MFI_UV,
d83 5
a87 3

/*
 *	C A M O _ S E T U P
d95 1
a95 1
struct rt_i		*rtip;
d97 1
a97 3
	register struct camo_specific *camo;
	struct db_full_path full_path;
	mat_t	region_to_model;
d104 2
a105 2
	GETSTRUCT( camo, camo_specific );
	*dpp = (char *)camo;
d107 1
a107 3
	memcpy(camo, &camo_defaults, sizeof(struct camo_specific) );
	if( rdebug&RDEBUG_SHADE)
		rt_log("camo_setup\n");
d109 1
a109 1
	if( rt_structparse( matparm, camo_parse, (char *)camo ) < 0 )
d112 2
a113 15
	if( rdebug&RDEBUG_SHADE)
		rt_structprint( rp->reg_name, camo_parse, (char *)camo );

	/* get transformation between world and "region" coordinates */
	if (db_string_to_path( &full_path, rtip->rti_dbip, rp->reg_name) ) {
		/* bad thing */
		rt_bomb("db_string_to_path() error");
	}
	if(! db_path_to_mat(rtip->rti_dbip, &full_path, region_to_model, 0)) {
		/* bad thing */
		rt_bomb("db_path_to_mat() error");
	}

	/* get matrix to map points from model (world) space
	 * to "region" space
d115 1
a115 2
	mat_inv(model_to_region, region_to_model);

d119 3
a121 3
	tmp[0] = camo->scale[0];
	tmp[5] = camo->scale[1];
	tmp[10] = camo->scale[2];
d123 1
a123 1
	mat_mul(camo->xform, tmp2, model_to_region);
d125 1
a125 1
	/* add the translation within noise space */
d127 9
a135 4
	tmp[MDX] = camo->delta[0];
	tmp[MDY] = camo->delta[1];
	tmp[MDZ] = camo->delta[2];
	mat_mul2(tmp, camo->xform);
d161 1
a161 1
/*
d163 3
a175 1
	vect_t v_noise;
d177 1
a177 4
	double  val;

/*	pp->pt_inseg->seg_stp	/* struct soltab */
/*	pp->pt_regionp		/* region */
d179 3
a181 4
/*
 *	region rpp in ray-trace coordinates (changes as solid moves)
 *  rt_bound_tree(pp->pt_regionp->reg_treetop, reg_rpp_min, reg_rpp_max)
 */
d186 1
a186 1
	/* transform point into "noise-space coordinates" */
a188 1
	val = noise_fbm(pt, camo_sp->h_val, camo_sp->lacunarity, camo_sp->octaves );
d190 5
a194 4
	if( rdebug&RDEBUG_SHADE)
		rt_log("camo_render: point (%g %g %g) %g\n\tRGB(%g %g %g) -> ",
			V3ARGS(swp->sw_hit.hit_point), val,
			V3ARGS(swp->sw_color));
a202 6

/*	swp->sw_color[1] += val * camo_sp->distortion;
	swp->sw_basecolor[1] += val * camo_sp->distortion; */

	if( rdebug&RDEBUG_SHADE)
		rt_log("RGB(%g %g %g)\n", V3ARGS(swp->sw_color));
@


1.2
log
@added delta option to position object in shader space
@
text
@d33 1
d89 6
a94 4
camo_setup( rp, matparm, dpp )
register struct region *rp;
struct rt_vls	*matparm;
char	**dpp;	/* pointer to reg_udata in *rp */
d97 4
d102 1
d104 1
d118 15
d134 15
a188 5
	struct db_full_path full_path;
	mat_t	region_to_model;
	mat_t	model_to_region;


a198 29
#if 1

	/* get transformation between world and "region" coordinates */
	if (db_string_to_path( &full_path, ap->a_rt_i->rti_dbip, pp->pt_regionp->reg_name) ) {
		/* bad thing */
		rt_bomb("db_string_to_path() error");
	}
	if(! db_path_to_mat(ap->a_rt_i->rti_dbip, &full_path, region_to_model, 0) ) {
		/* bad thing */
		rt_bomb("db_path_to_mat() error");
	}

	/* map point from model (world) space to "region" space */
	mat_inv(model_to_region, region_to_model);

	/* transform point into "region coordinates" */
	MAT4X3PNT(pt, model_to_region, swp->sw_hit.hit_point);

	VADD2(pt, pt, camo_sp->delta);

	/* apply noise-field scaling */
	VELMUL(pt, pt, camo_sp->scale);

#else

	/* apply noise-field scaling */
	VELMUL(pt, swp->sw_hit.hit_point, camo_sp->scale);
#endif

d200 2
@


1.1
log
@Initial revision
@
text
@a25 3
	double	offset;
	double	gain;
	double	distortion;
d32 1
a32 1
	mat_t	model_to_region;
d39 2
a40 5
	0.0,		/* offset */
	0.0,		/* gain */
	1.0,		/* distortion */
	-0.5,
	0.5,
d44 2
a45 1
	{ .815, .635, .35 }	/* brighter color c3 */
d56 2
a57 2
	{"%f",	1, "gain",		CAMO_O(gain),		FUNC_NULL },
	{"%f",	1, "distortion",	CAMO_O(distortion),	FUNC_NULL },
a58 5
	{"%f",  3, "s",			CAMO_AO(scale),		FUNC_NULL },
	{"%f",	1, "l",			CAMO_O(lacunarity),	FUNC_NULL },
	{"%d",	1, "o", 		CAMO_O(octaves),		FUNC_NULL },
	{"%f",	1, "g",			CAMO_O(gain),		FUNC_NULL },
	{"%f",	1, "d",			CAMO_O(distortion),	FUNC_NULL },
d62 6
a67 2
	{"%f",	1, "t1",		CAMO_O(t1),		FUNC_NULL },
	{"%f",	1, "t2",		CAMO_O(t2),		FUNC_NULL },
d166 2
a167 4
	/* get transformation between world coordinates and 
	 * un-transformed region coordinates 
	 */
	/* map point from model (world) space to "region" space */
a171 1

d177 1
d183 2
d193 3
@
