head	1.36;
access;
symbols
	ansi-20040405-merged:1.32.2.2
	postmerge-20040405-ansi:1.34
	premerge-20040404-ansi:1.33
	postmerge-autoconf:1.33
	autoconf-freeze:1.32.10.2
	premerge-autoconf:1.33
	ansi-20040316-freeze:1.32.2.1
	postmerge-20040315-windows:1.33
	premerge-20040315-windows:1.33
	windows-20040315-freeze:1.32.4.1
	autoconf-20031203:1.32
	autoconf-20031202:1.32
	autoconf-branch:1.32.0.10
	phong-branch:1.32.0.8
	photonmap-branch:1.32.0.6
	rel-6-1-DP:1.32
	windows-branch:1.32.0.4
	rel-6-0-2:1.30
	ansi-branch:1.32.0.2
	rel-6-0-1-branch:1.30.0.2
	hartley-6-0-post:1.31
	hartley-6-0-pre:1.30
	rel-6-0-1:1.30
	rel-6-0:1.30
	rel-5-4:1.23
	offsite-5-3-pre:1.27
	rel-5-3:1.23
	rel-5-2:1.23
	rel-5-1-branch:1.23.0.2
	rel-5-1:1.23
	rel-5-0:1.15
	rel-5-0-beta:1.12
	rel-4-5:1.8
	ctj-4-5-post:1.6
	ctj-4-5-pre:1.6;
locks; strict;
comment	@ * @;


1.36
date	2004.05.21.18.07.27;	author morrison;	state dead;
branches;
next	1.35;

1.35
date	2004.05.10.15.30.45;	author erikg;	state Exp;
branches;
next	1.34;

1.34
date	2004.04.05.07.43.37;	author morrison;	state Exp;
branches;
next	1.33;

1.33
date	2004.02.02.17.39.14;	author morrison;	state Exp;
branches;
next	1.32;

1.32
date	2002.08.20.17.07.51;	author jra;	state Exp;
branches
	1.32.2.1
	1.32.4.1
	1.32.10.1;
next	1.31;

1.31
date	2002.08.15.20.55.04;	author hartley;	state Exp;
branches;
next	1.30;

1.30
date	2001.10.17.07.40.03;	author morrison;	state Exp;
branches;
next	1.29;

1.29
date	2001.04.20.22.29.32;	author morrison;	state Exp;
branches;
next	1.28;

1.28
date	2001.03.31.01.57.02;	author morrison;	state Exp;
branches;
next	1.27;

1.27
date	2000.10.19.19.19.45;	author butler;	state Exp;
branches;
next	1.26;

1.26
date	2000.09.09.04.30.51;	author mike;	state Exp;
branches;
next	1.25;

1.25
date	2000.08.20.01.27.48;	author butler;	state Exp;
branches;
next	1.24;

1.24
date	2000.07.25.16.40.38;	author butler;	state Exp;
branches;
next	1.23;

1.23
date	2000.02.19.21.05.02;	author butler;	state Exp;
branches;
next	1.22;

1.22
date	2000.02.17.21.03.44;	author butler;	state Exp;
branches;
next	1.21;

1.21
date	2000.02.03.06.34.45;	author butler;	state Exp;
branches;
next	1.20;

1.20
date	2000.01.20.22.44.59;	author butler;	state Exp;
branches;
next	1.19;

1.19
date	99.12.30.16.19.50;	author jra;	state Exp;
branches;
next	1.18;

1.18
date	99.12.29.21.51.29;	author butler;	state Exp;
branches;
next	1.17;

1.17
date	99.10.30.03.06.24;	author butler;	state Exp;
branches;
next	1.16;

1.16
date	99.10.08.19.45.06;	author butler;	state Exp;
branches;
next	1.15;

1.15
date	99.07.22.03.09.41;	author butler;	state Exp;
branches;
next	1.14;

1.14
date	99.07.02.22.20.41;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	99.07.01.20.08.47;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	99.02.04.02.23.10;	author butler;	state Exp;
branches;
next	1.11;

1.11
date	99.01.29.05.53.31;	author butler;	state Exp;
branches;
next	1.10;

1.10
date	98.09.22.01.29.55;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	98.06.30.22.54.18;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	97.12.31.09.01.40;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	97.12.04.10.22.28;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	97.07.02.21.15.18;	author butler;	state Exp;
branches;
next	1.5;

1.5
date	97.05.19.17.12.30;	author butler;	state Exp;
branches;
next	1.4;

1.4
date	97.04.27.08.39.05;	author butler;	state Exp;
branches;
next	1.3;

1.3
date	97.03.12.18.31.24;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	97.03.12.18.17.02;	author butler;	state Exp;
branches;
next	1.1;

1.1
date	97.01.31.04.04.21;	author butler;	state Exp;
branches;
next	;

1.32.2.1
date	2002.09.19.18.01.25;	author morrison;	state Exp;
branches;
next	1.32.2.2;

1.32.2.2
date	2004.03.17.21.18.32;	author morrison;	state Exp;
branches;
next	;

1.32.4.1
date	2004.03.11.23.43.02;	author morrison;	state Exp;
branches;
next	;

1.32.10.1
date	2004.02.12.18.38.49;	author erikg;	state Exp;
branches;
next	1.32.10.2;

1.32.10.2
date	2004.03.15.14.07.13;	author erikg;	state Exp;
branches;
next	;


desc
@Shaders using FBM/turbulence for color/normal alterations.
@


1.36
log
@moved to src/
@
text
@/*
 *	S H _ N O I S E . C
 *
 *	Shaders:
 *	gravel		turbulence noise applied to color and surface normal
 *	turbump		turbulence noise applied to surface normal
 *	turcolor	turbulence noise applied to color
 *	fbmbump		fbm noise applied to surface normal
 *	fbmcolor	fbm noise applied to color
 *
 *  Author -
 *	Lee A. Butler
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" license agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1998-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/liboptical/sh_noise.c,v 1.35 2004/05/10 15:30:45 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef HAVE_STRING_H
#include <string.h>
#endif
#include <math.h>
#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "raytrace.h"
#include "shadefuncs.h"
#include "shadework.h"
#include "rtprivate.h"

extern int rr_render(struct application	*ap,
		     struct partition	*pp,
		     struct shadework   *swp);
#define noise_MAGIC 0x1847
#define CK_noise_SP(_p) BU_CKMAG(_p, noise_MAGIC, "noise_specific")

/* This allows us to specify the "size" parameter as values like ".5m"
 * or "27in" rather than using mm all the time.
 */
void
noise_cvt_parse(register const struct bu_structparse *sdp, register const char *name, char *base, const char *value)
                                    	     	/* structure description */
                   			      	/* struct member name */
    					      	/* begining of structure */
          				       	/* string containing value */
{
	double *p = (double *)(base+sdp->sp_offset);

	if (rdebug&RDEBUG_SHADE)
		bu_log("%s value %s ", name, value);
	/* reconvert with optional units */
	*p = rt_mm_value(value);

	if (rdebug&RDEBUG_SHADE)
		bu_log(" %g\n", *p);

}

void
noise_deg_to_rad(register const struct bu_structparse *sdp, register const char *name, char *base, const char *value)
                                    	     	/* structure description */
                   			      	/* struct member name */
    					      	/* begining of structure */
          				       	/* string containing value */
{
	double *p = (double *)(base+sdp->sp_offset);

	/* reconvert with optional units */
	*p = *p * (bn_pi / 180.0);
}

/*
 * the shader specific structure contains all variables which are unique
 * to any particular use of the shader.
 */
struct noise_specific {
	long	magic;	/* magic # for memory validity check, must come 1st */
	double	lacunarity;
	double	h_val;
	double	octaves;
	double	size;
	double	max_angle;
	point_t	vscale;	/* size of noise coordinate space */
	vect_t	delta;
	mat_t	m_to_sh;	/* model to shader space matrix */
	mat_t	sh_to_m;	/* shader to model space matrix */
	double	max_delta;
	double	nsd;
	double	minval;		/* don't use noise value less than this */
	int	shader_number;
};

/* The default values for the variables in the shader specific structure */
static const
struct noise_specific noise_defaults = {
	noise_MAGIC,
	2.1753974,	/* lacunarity */
	1.0,		/* h_val */
	4.0,		/* octaves */
	1.0,		/* size */
	1.57079632679489661923,		/* max_angle M_PI_2 */
	{ 1.0, 1.0, 1.0 },		/* vscale */
	{ 1000.0, 1000.0, 1000.0 },	/* delta into noise space */
	{	0.0, 0.0, 0.0, 0.0,	/* m_to_sh */
		0.0, 0.0, 0.0, 0.0,
		0.0, 0.0, 0.0, 0.0,
		0.0, 0.0, 0.0, 0.0 },
	{	0.0, 0.0, 0.0, 0.0,	/* sh_to_m */
		0.0, 0.0, 0.0, 0.0,
		0.0, 0.0, 0.0, 0.0,
		0.0, 0.0, 0.0, 0.0 },
	0.0,				/* max_delta */
	0.0,				/* nsd */
	0.0,				/* minval */
	0				/* shader_number */
	};

#define SHDR_NULL	((struct noise_specific *)0)
#define SHDR_O(m)	offsetof(struct noise_specific, m)
#define SHDR_AO(m)	bu_offsetofarray(struct noise_specific, m)


/* description of how to parse/print the arguments to the shader
 * There is at least one line here for each variable in the shader specific
 * structure above
 */
struct bu_structparse noise_print_tab[] = {
	{"%f",	1, "lacunarity",	SHDR_O(lacunarity),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "H", 		SHDR_O(h_val),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "octaves", 		SHDR_O(octaves),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",  3, "delta",		SHDR_AO(delta),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",  1, "size",		SHDR_O(size),		bu_mm_cvt },
	{"%f",  1, "angle",		SHDR_O(max_angle),	noise_deg_to_rad },
	{"%f",  3, "vscale",		SHDR_AO(vscale),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",  1, "min",		SHDR_O(minval),		BU_STRUCTPARSE_FUNC_NULL },
	{"",	0, (char *)0,		0,			BU_STRUCTPARSE_FUNC_NULL }
};

struct bu_structparse noise_parse_tab[] = {
	{"i",	bu_byteoffset(noise_print_tab[0]), "noise_print_tab", 0, BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "lacunarity",	SHDR_O(lacunarity),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "l",			SHDR_O(lacunarity),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "H", 		SHDR_O(h_val),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "octaves", 		SHDR_O(octaves),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "o", 		SHDR_O(octaves),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",  3, "delta",		SHDR_AO(delta),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",  3, "d",			SHDR_AO(delta),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",  1, "size",		SHDR_O(size),		bu_mm_cvt },
	{"%f",  1, "s",			SHDR_O(size),		bu_mm_cvt },
	{"%f",  1, "angle",		SHDR_O(max_angle),	noise_deg_to_rad },
	{"%f",  1, "ang",		SHDR_O(max_angle),	noise_deg_to_rad },
	{"%f",  1, "a",			SHDR_O(max_angle),	noise_deg_to_rad },
	{"%f",  3, "vscale",		SHDR_AO(vscale),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",  3, "vs",		SHDR_AO(vscale),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",  3, "v",			SHDR_AO(vscale),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",  1, "min",		SHDR_O(minval),		BU_STRUCTPARSE_FUNC_NULL },
	{"",	0, (char *)0,		0,			BU_STRUCTPARSE_FUNC_NULL }
};

HIDDEN int	noise_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip), noise_render(),
		fbmbump_render(), turbump_render(),
		fbmcolor_render(), turcolor_render(),
		fractal_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
HIDDEN void	noise_print(register struct region *rp, char *dp), noise_free(char *cp);

/* The "mfuncs" structure defines the external interface to the shader.
 * Note that more than one shader "name" can be associated with a given
 * shader by defining more than one mfuncs struct in this array.
 * See sh_phong.c for an example of building more than one shader "name"
 * from a set of source functions.  There you will find that "glass" "mirror"
 * and "plastic" are all names for the same shader with different default
 * values for the parameters.
 *
 * WARNING:  The order of this table is critical for these shaders.
 */
struct mfuncs noise_mfuncs[] = {
	{MF_MAGIC,	"gravel",	0,	MFI_NORMAL|MFI_HIT|MFI_UV, 0,
	noise_setup,	fractal_render,	noise_print,	noise_free },

	{MF_MAGIC,	"fbmbump",	0,	MFI_NORMAL|MFI_HIT|MFI_UV, 0,
	noise_setup,	fractal_render,	noise_print,	noise_free },

	{MF_MAGIC,	"turbump",	0,	MFI_NORMAL|MFI_HIT|MFI_UV, 0,
	noise_setup,	fractal_render, noise_print,	noise_free },

	{MF_MAGIC,	"fbmcolor",	0,	MFI_NORMAL|MFI_HIT|MFI_UV, 0,
	noise_setup,	fractal_render, noise_print,	noise_free },

	{MF_MAGIC,	"turcolor",	0,	MFI_NORMAL|MFI_HIT|MFI_UV, 0,
	noise_setup,	fractal_render, noise_print,	noise_free },

	{MF_MAGIC,	"grunge",	0,	MFI_NORMAL|MFI_HIT|MFI_UV, 0,
	noise_setup,	fractal_render, noise_print,	noise_free },

	{MF_MAGIC,	"turcombo",	0,	MFI_NORMAL|MFI_HIT|MFI_UV, 0,
	noise_setup,	fractal_render, noise_print,	noise_free },

	{MF_MAGIC,	"fbmcombo",	0,	MFI_NORMAL|MFI_HIT|MFI_UV, 0,
	noise_setup,	fractal_render,	noise_print,	noise_free },

	{MF_MAGIC,	"flash",	0,	MFI_NORMAL|MFI_HIT|MFI_UV, 0,
	noise_setup,	fractal_render, noise_print,	noise_free },

	{0,		(char *)0,	0,	0,		0,
	0,		0,		0,		0 }
};


/*	G R A V E L _ S E T U P
 *
 *	This routine is called (at prep time)
 *	once for each region which uses this shader.
 *	Any shader-specific initialization should be done here.
 */
HIDDEN int
noise_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip)
                      	    
             		         
    			      	/* pointer to reg_udata in *rp */
             		     
           		      	/* New since 4.4 release */
{
	register struct noise_specific	*noise_sp;
	mat_t	tmp;
	mat_t model_to_region;
	int i;

	/* check the arguments */
	RT_CHECK_RTI(rtip);
	BU_CK_VLS( matparm );
	RT_CK_REGION(rp);


	if (rdebug&RDEBUG_SHADE)
		bu_log("noise_setup(%s, %s) (%s)\n",
			rp->reg_name, bu_vls_addr(matparm),
			rp->reg_mater.ma_shader);

	/* Get memory for the shader parameters and shader-specific data */
	BU_GETSTRUCT( noise_sp, noise_specific );
	*dpp = (char *)noise_sp;

	/* initialize the default values for the shader */
	memcpy(noise_sp, &noise_defaults, sizeof(struct noise_specific) );

	/* parse the user's arguments for this use of the shader. */
	if (bu_struct_parse( matparm, noise_parse_tab, (char *)noise_sp ) < 0 )
		return(-1);

	/* figure out which shader is really being called */
	for (i = 0 ; noise_mfuncs[i].mf_name ; i++ ) {
		if (!strcmp(noise_mfuncs[i].mf_name, mfp->mf_name))
			goto found;
	}
	bu_log("shader name \"%s\" not recognized, assuming \"%s\"\n",
		mfp->mf_name, noise_mfuncs[0].mf_name);
	i = 0;
found:
	noise_sp->shader_number = i;

	db_region_mat(model_to_region, rtip->rti_dbip, rp->reg_name, &rt_uniresource);

	MAT_IDN(tmp);
	if (noise_sp->size != 1.0) {
		/* the user sets "size" to the size of the biggest
		 * noise-space blob in model coordinates
		 */
		tmp[0] = tmp[5] = tmp[10] = 1.0/noise_sp->size;
	} else {
		tmp[0] = 1.0/noise_sp->vscale[0];
		tmp[5] = 1.0/noise_sp->vscale[1];
		tmp[10] = 1.0/noise_sp->vscale[2];
	}

	bn_mat_mul(noise_sp->m_to_sh, tmp, model_to_region);

	/* Add any translation within shader/region space */
	MAT_IDN(tmp);
	tmp[MDX] = noise_sp->delta[0];
	tmp[MDY] = noise_sp->delta[1];
	tmp[MDZ] = noise_sp->delta[2];
	bn_mat_mul2(tmp, noise_sp->m_to_sh);

	bn_mat_inv(noise_sp->sh_to_m, noise_sp->m_to_sh);

	noise_sp->nsd = 1.0 / 
		pow(noise_sp->lacunarity, noise_sp->octaves);

	if (rdebug&RDEBUG_SHADE) {
		bu_struct_print( " Parameters:", noise_print_tab, (char *)noise_sp );
		bn_mat_print( "m_to_sh", noise_sp->m_to_sh );
	}

	return(1);
}

/*
 *	G R A V E L _ P R I N T
 */
HIDDEN void
noise_print(register struct region *rp, char *dp)
{
	bu_struct_print( rp->reg_name, noise_print_tab, (char *)dp );
}

/*
 *	G R A V E L _ F R E E
 */
HIDDEN void
noise_free(char *cp)
{
	bu_free( cp, "noise_specific" );
}
#define RESCALE_NOISE(n) n += 1.0

/*
 *	N O R M _ N O I S E
 *
 *	Apply a noise function to the surface normal
 */
static void
norm_noise(fastf_t *pt, double val, struct noise_specific *noise_sp, double (*func) (/* ??? */), struct shadework *swp, int rescale)
           
           
                                
                 
                	     	/* defined in material.h */
            
{
	vect_t N, tmp;
	point_t u_pt, v_pt;
	vect_t u_vec, v_vec;
	double u_val, v_val;
	mat_t u_mat, v_mat;

	/* dork the normal around
	 * Convert the normal to shader space, get u,v coordinate system
	 */

	if (rdebug&RDEBUG_SHADE) {
		VPRINT("Model space Normal", swp->sw_hit.hit_normal);
	}
	MAT4X3VEC(N, noise_sp->m_to_sh, swp->sw_hit.hit_normal);
	VUNITIZE(N);
	if (rdebug&RDEBUG_SHADE) {
		VPRINT("Shader space Normal", N);
	}

	/* construct coordinate system from vectors perpendicular to normal */
	bn_vec_perp(u_vec, N);
	VCROSS(v_vec, N, u_vec);

	/* compute noise function at position slightly off pt in both
	 * U and V directions to get change in values
	 */
	VJOIN1(u_pt, pt, noise_sp->nsd, u_vec);
	u_val = func(u_pt, noise_sp->h_val, noise_sp->lacunarity,
		noise_sp->octaves);

	if (rescale) RESCALE_NOISE(u_val);

	VJOIN1(v_pt, pt, noise_sp->nsd, v_vec);
	v_val = func(v_pt, noise_sp->h_val, noise_sp->lacunarity,
		noise_sp->octaves);

	if (rescale) RESCALE_NOISE(v_val);

	/* construct normal rotation about U and V vectors based upon 
	 * variation in surface in each direction.  Apply the result to
	 * the surface normal.
	 */
	bn_mat_arb_rot(u_mat, pt, u_vec, (val - v_val) * noise_sp->max_angle);
	MAT4X3VEC(tmp, u_mat, N);

	bn_mat_arb_rot(v_mat, pt, v_vec, (val - u_val) * noise_sp->max_angle);

	MAT4X3VEC(N, v_mat, tmp);

	if (rdebug&RDEBUG_SHADE) {
		VPRINT("old normal", swp->sw_hit.hit_normal);
	}

	MAT4X3VEC(swp->sw_hit.hit_normal, noise_sp->sh_to_m, N);
	VUNITIZE(swp->sw_hit.hit_normal);
	if (rdebug&RDEBUG_SHADE) {
		VPRINT("new normal", swp->sw_hit.hit_normal);
	}
}

/*
 *	F R A C T A L _ R E N D E R
 *
 *	This is called (from viewshade() in shade.c) once for each hit point
 *	to be shaded.  The purpose here is to fill in values in the shadework
 *	structure.
 */
int
fractal_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
                  	    
                	    
                	     	/* defined in material.h */
    			    	/* ptr to the shader-specific struct */
{
	register struct noise_specific *noise_sp =
		(struct noise_specific *)dp;
	point_t pt;
	double val;

	/* check the validity of the arguments we got */
	RT_AP_CHECK(ap);
	RT_CHECK_PT(pp);
	CK_noise_SP(noise_sp);

	if (rdebug&RDEBUG_SHADE)
		bu_struct_print( "noise_render Parameters:", noise_print_tab, (char *)noise_sp );

	/* If we are performing the shading in "region" space, we must 
	 * transform the hit point from "model" space to "region" space.
	 * See the call to db_region_mat in noise_setup().
	 */
	MAT4X3PNT(pt, noise_sp->m_to_sh, swp->sw_hit.hit_point);

	if (rdebug&RDEBUG_SHADE) {
		bu_log("%s:%d noise_render(%s)  model:(%g %g %g) shader:(%g %g %g)\n", 
		__FILE__, __LINE__,
		noise_mfuncs[noise_sp->shader_number].mf_name,
		V3ARGS(swp->sw_hit.hit_point),
		V3ARGS(pt) );
	}

	switch (noise_sp->shader_number) {
	case 0:	/* gravel */
	case 6: /* turcombo */
		val = bn_noise_turb(pt, noise_sp->h_val,
			noise_sp->lacunarity, noise_sp->octaves);
		if (val < noise_sp->minval )  val = noise_sp->minval;
#if RT_MULTISPECTRAL
		swp->sw_temperature *= val;
#else
		VSCALE(swp->sw_color, swp->sw_color, val);
#endif
		norm_noise(pt, val, noise_sp, bn_noise_turb, swp, 0);
		break;
	case 1:	/* fbmbump */
		val = bn_noise_fbm(pt, noise_sp->h_val,
			noise_sp->lacunarity, noise_sp->octaves);
		RESCALE_NOISE(val);
		norm_noise(pt, val, noise_sp, bn_noise_fbm, swp, 1);
		break;
	case 2:	/* turbump */
		val = bn_noise_turb(pt, noise_sp->h_val,
			noise_sp->lacunarity, noise_sp->octaves);

		norm_noise(pt, val, noise_sp, bn_noise_turb, swp, 0);
		break;
	case 3:	/* fbmcolor */
		val = bn_noise_fbm(pt, noise_sp->h_val,
			noise_sp->lacunarity, noise_sp->octaves);
		RESCALE_NOISE(val);
		if (val < noise_sp->minval )  val = noise_sp->minval;
#if RT_MULTISPECTRAL
		swp->sw_temperature *= val;
#else
		VSCALE(swp->sw_color, swp->sw_color, val);
#endif
		break;
	case 4:	/* turcolor */
		val = bn_noise_turb(pt, noise_sp->h_val,
			noise_sp->lacunarity, noise_sp->octaves);
		if (val < noise_sp->minval )  val = noise_sp->minval;
#if RT_MULTISPECTRAL
		swp->sw_temperature *= val;
#else
		VSCALE(swp->sw_color, swp->sw_color, val);
#endif
		break;
	case 5: /* grunge */
	case 7: /* fbmcombo */
		val = bn_noise_fbm(pt, noise_sp->h_val,
			noise_sp->lacunarity, noise_sp->octaves);
		RESCALE_NOISE(val);
		if (val < noise_sp->minval )  val = noise_sp->minval;
#if RT_MULTISPECTRAL
		swp->sw_temperature *= val;
#else
		VSCALE(swp->sw_color, swp->sw_color, val);
#endif
		norm_noise(pt, val, noise_sp, bn_noise_fbm, swp, 1);
		break;

	case 8: /* flash */
		val = bn_noise_fbm(pt, noise_sp->h_val,
			noise_sp->lacunarity, noise_sp->octaves);

		val = 1.0 - val;
		if (val < noise_sp->minval )  val = noise_sp->minval;

#if RT_MULTISPECTRAL
		swp->sw_temperature *= val;
#else
		VSCALE(swp->sw_color, swp->sw_color, val);
#endif
		swp->sw_temperature = val * 2000.0;
		break;
	}


	/* shader must perform transmission/reflection calculations
	 *
	 * 0 < swp->sw_transmit <= 1 causes transmission computations
	 * 0 < swp->sw_reflect <= 1 causes reflection computations
	 */
	if (swp->sw_reflect > 0 || swp->sw_transmit > 0 )
		(void)rr_render( ap, pp, swp );

	return(1);
}
@


1.35
log
@change conf.h to a wrapped config.h
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/liboptical/sh_noise.c,v 1.34 2004/04/05 07:43:37 morrison Exp $ (ARL)";
@


1.34
log
@merge of ansi-6-0-branch into HEAD
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d31 5
a35 1
#include "conf.h"
@


1.33
log
@update copyright to include span through 2003
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_noise.c,v 1.32 2002/08/20 17:07:51 jra Exp $ (ARL)";
d57 5
a61 5
noise_cvt_parse( sdp, name, base, value )
register const struct bu_structparse	*sdp;	/* structure description */
register const char			*name;	/* struct member name */
char					*base;	/* begining of structure */
const char				*value;	/* string containing value */
d76 5
a80 5
noise_deg_to_rad( sdp, name, base, value )
register const struct bu_structparse	*sdp;	/* structure description */
register const char			*name;	/* struct member name */
char					*base;	/* begining of structure */
const char				*value;	/* string containing value */
d176 1
a176 1
HIDDEN int	noise_setup(), noise_render(),
d179 2
a180 2
		fractal_render();
HIDDEN void	noise_print(), noise_free();
d232 6
a237 6
noise_setup( rp, matparm, dpp, mfp, rtip)
register struct region	*rp;
struct bu_vls		*matparm;
char			**dpp;	/* pointer to reg_udata in *rp */
struct mfuncs		*mfp;
struct rt_i		*rtip;	/* New since 4.4 release */
d317 1
a317 3
noise_print( rp, dp )
register struct region *rp;
char	*dp;
d326 1
a326 2
noise_free( cp )
char *cp;
d338 7
a344 7
norm_noise(pt, val, noise_sp, func, swp, rescale)
point_t pt;
double val;
struct noise_specific *noise_sp;
double (*func)();
struct shadework	*swp;	/* defined in material.h */
int rescale;
d414 5
a418 5
fractal_render( ap, pp, swp, dp )
struct application	*ap;
struct partition	*pp;
struct shadework	*swp;	/* defined in material.h */
char			*dp;	/* ptr to the shader-specific struct */
@


1.32
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d24 1
a24 1
 *	This software is Copyright (C) 1998 by the United States Army
d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_noise.c,v 1.30 2001/10/17 07:40:03 morrison Exp $ (ARL)";
@


1.32.4.1
log
@sync to HEAD...
@
text
@d24 1
a24 1
 *	This software is Copyright (C) 1998-2004 by the United States Army
d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/liboptical/sh_noise.c,v 1.33 2004/02/02 17:39:14 morrison Exp $ (ARL)";
@


1.32.10.1
log
@merge from HEAD
@
text
@d24 1
a24 1
 *	This software is Copyright (C) 1998-2004 by the United States Army
d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_noise.c,v 1.33 2004/02/02 17:39:14 morrison Exp $ (ARL)";
@


1.32.10.2
log
@merge from head
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_noise.c,v 1.32.10.1 2004/02/12 18:38:49 erikg Exp $ (ARL)";
@


1.32.2.1
log
@Initial ANSIfication
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_noise.c,v 1.32 2002/08/20 17:07:51 jra Exp $ (ARL)";
d57 5
a61 5
noise_cvt_parse(register const struct bu_structparse *sdp, register const char *name, char *base, const char *value)
                                    	     	/* structure description */
                   			      	/* struct member name */
    					      	/* begining of structure */
          				       	/* string containing value */
d76 5
a80 5
noise_deg_to_rad(register const struct bu_structparse *sdp, register const char *name, char *base, const char *value)
                                    	     	/* structure description */
                   			      	/* struct member name */
    					      	/* begining of structure */
          				       	/* string containing value */
d176 1
a176 1
HIDDEN int	noise_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip), noise_render(),
d179 2
a180 2
		fractal_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
HIDDEN void	noise_print(register struct region *rp, char *dp), noise_free(char *cp);
d232 6
a237 6
noise_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip)
                      	    
             		         
    			      	/* pointer to reg_udata in *rp */
             		     
           		      	/* New since 4.4 release */
d317 3
a319 1
noise_print(register struct region *rp, char *dp)
d328 2
a329 1
noise_free(char *cp)
d341 7
a347 7
norm_noise(fastf_t *pt, double val, struct noise_specific *noise_sp, double (*func) (/* ??? */), struct shadework *swp, int rescale)
           
           
                                
                 
                	     	/* defined in material.h */
            
d417 5
a421 5
fractal_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
                  	    
                	    
                	     	/* defined in material.h */
    			    	/* ptr to the shader-specific struct */
@


1.32.2.2
log
@sync branch with HEAD
@
text
@d24 1
a24 1
 *	This software is Copyright (C) 1998-2004 by the United States Army
d28 1
a28 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
@


1.31
log
@Converted from K&R to ANSI C - RFH
@
text
@d57 5
a61 5
noise_cvt_parse(register const struct bu_structparse *sdp, register const char *name, char *base, const char *value)
                                    	     	/* structure description */
                   			      	/* struct member name */
    					      	/* begining of structure */
          				       	/* string containing value */
d76 5
a80 5
noise_deg_to_rad(register const struct bu_structparse *sdp, register const char *name, char *base, const char *value)
                                    	     	/* structure description */
                   			      	/* struct member name */
    					      	/* begining of structure */
          				       	/* string containing value */
d176 1
a176 1
HIDDEN int	noise_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip), noise_render(),
d179 2
a180 2
		fractal_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
HIDDEN void	noise_print(register struct region *rp, char *dp), noise_free(char *cp);
d232 6
a237 6
noise_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip)
                      	    
             		         
    			      	/* pointer to reg_udata in *rp */
             		     
           		      	/* New since 4.4 release */
d317 3
a319 1
noise_print(register struct region *rp, char *dp)
d328 2
a329 1
noise_free(char *cp)
d341 7
a347 7
norm_noise(fastf_t *pt, double val, struct noise_specific *noise_sp, double (*func) (/* ??? */), struct shadework *swp, int rescale)
           
           
                                
                 
                	     	/* defined in material.h */
            
d417 5
a421 5
fractal_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
                  	    
                	    
                	     	/* defined in material.h */
    			    	/* ptr to the shader-specific struct */
@


1.30
log
@Mac OS X warning and error fixes for non-production build
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_noise.c,v 1.29 2001/04/20 22:29:32 morrison Exp $ (ARL)";
d57 5
a61 5
noise_cvt_parse( sdp, name, base, value )
register const struct bu_structparse	*sdp;	/* structure description */
register const char			*name;	/* struct member name */
char					*base;	/* begining of structure */
const char				*value;	/* string containing value */
d76 5
a80 5
noise_deg_to_rad( sdp, name, base, value )
register const struct bu_structparse	*sdp;	/* structure description */
register const char			*name;	/* struct member name */
char					*base;	/* begining of structure */
const char				*value;	/* string containing value */
d176 1
a176 1
HIDDEN int	noise_setup(), noise_render(),
d179 2
a180 2
		fractal_render();
HIDDEN void	noise_print(), noise_free();
d232 6
a237 6
noise_setup( rp, matparm, dpp, mfp, rtip)
register struct region	*rp;
struct bu_vls		*matparm;
char			**dpp;	/* pointer to reg_udata in *rp */
struct mfuncs		*mfp;
struct rt_i		*rtip;	/* New since 4.4 release */
d317 1
a317 3
noise_print( rp, dp )
register struct region *rp;
char	*dp;
d326 1
a326 2
noise_free( cp )
char *cp;
d338 7
a344 7
norm_noise(pt, val, noise_sp, func, swp, rescale)
point_t pt;
double val;
struct noise_specific *noise_sp;
double (*func)();
struct shadework	*swp;	/* defined in material.h */
int rescale;
d414 5
a418 5
fractal_render( ap, pp, swp, dp )
struct application	*ap;
struct partition	*pp;
struct shadework	*swp;	/* defined in material.h */
char			*dp;	/* ptr to the shader-specific struct */
@


1.29
log
@CONST to const
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_noise.c,v 1.28 2001/03/31 01:57:02 morrison Exp $ (ARL)";
d225 1
a225 1
/*	G R A V E L _ S E T U P
d313 1
a313 1
/*
d334 1
a334 1

@


1.28
log
@Deprecated bn_mat_idn() and bn_mat_zero(), updated calls to h/vmath.h's MAT_IDN() and MAT_ZERO() performance improved macros.
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_noise.c,v 1.27 2000/10/19 19:19:45 butler Exp $ (ARL)";
d58 2
a59 2
register CONST struct bu_structparse	*sdp;	/* structure description */
register CONST char			*name;	/* struct member name */
d61 1
a61 1
CONST char				*value;	/* string containing value */
d77 2
a78 2
register CONST struct bu_structparse	*sdp;	/* structure description */
register CONST char			*name;	/* struct member name */
d80 1
a80 1
CONST char				*value;	/* string containing value */
d110 1
a110 1
static CONST
@


1.27
log
@Changes to compile under RedHat 7.0
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_noise.c,v 1.26 2000/09/09 04:30:51 mike Exp $ (ARL)";
d279 1
a279 1
	bn_mat_idn(tmp);
d294 1
a294 1
	bn_mat_idn(tmp);
@


1.26
log
@
Struct db_tree_state finally got a magic number. Added resource argument
to ft_describe(), db_region_mat(), db_shader_mat(),
db_init_db_tree_state(), and db_path_to_mat().
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_noise.c,v 1.25 2000/08/20 01:27:48 butler Exp $ (ARL)";
d34 3
@


1.25
log
@Eliminate compilation warnings, enhancements to sh_light.c
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_noise.c,v 1.24 2000/07/25 16:40:38 butler Exp $ (ARL)";
d274 1
a274 1
	db_region_mat(model_to_region, rtip->rti_dbip, rp->reg_name);
@


1.24
log
@Changes to use rtprivate.h instead of ../rt/rdebug.h
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_noise.c,v 1.23 2000/02/19 21:05:02 butler Exp $ (ARL)";
@


1.23
log
@Changes to support movement of CLAMP() macro into vmath.h
Altered "if( " statements to "if (" for readability.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_noise.c,v 1.22 2000/02/17 21:03:44 butler Exp $ (ARL)";
d42 1
a42 1
#include "../rt/rdebug.h"
d44 3
@


1.22
log
@misc minor patches
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_noise.c,v 1.21 2000/02/03 06:34:45 butler Exp $ (ARL)";
d59 1
a59 1
	if( rdebug&RDEBUG_SHADE)
d64 1
a64 1
	if( rdebug&RDEBUG_SHADE)
d244 1
a244 1
	if( rdebug&RDEBUG_SHADE)
d257 1
a257 1
	if( bu_struct_parse( matparm, noise_parse_tab, (char *)noise_sp ) < 0 )
d299 1
a299 1
	if( rdebug&RDEBUG_SHADE) {
d353 1
a353 1
	if( rdebug&RDEBUG_SHADE) {
d358 1
a358 1
	if( rdebug&RDEBUG_SHADE) {
d392 1
a392 1
	if( rdebug&RDEBUG_SHADE) {
d398 1
a398 1
	if( rdebug&RDEBUG_SHADE) {
d427 1
a427 1
	if( rdebug&RDEBUG_SHADE)
d436 1
a436 1
	if( rdebug&RDEBUG_SHADE) {
d526 1
a526 1
	if( swp->sw_reflect > 0 || swp->sw_transmit > 0 )
@


1.21
log
@Changes to the light visibility computation.  Now we allow multiple
light sample rays for each hit point.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_noise.c,v 1.20 2000/01/20 22:44:59 butler Exp $ (ARL)";
d327 1
a327 1
#define RESCALE_NOISE(n) n = n+1.0
@


1.20
log
@Added support for multispectral temperature noise
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_noise.c,v 1.19 1999/12/30 16:19:50 jra Exp $ (ARL)";
d97 3
a99 3
	double max_delta;
	double nsd;
	double minval;		/* don't use noise value less than this */
@


1.19
log
@Eliminated some unused variables
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_noise.c,v 1.18 1999/12/29 21:51:29 butler Exp $ (ARL)";
d450 3
d454 1
a454 1

d474 3
d478 1
d484 3
d488 1
d496 3
d500 1
d511 3
d515 2
@


1.18
log
@double break statement cleaned up
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_noise.c,v 1.17 1999/10/30 03:06:24 butler Exp $ (ARL)";
a235 1
	vect_t	bb_min, bb_max, v_tmp;
a324 3
	register struct noise_specific *noise_sp =
		(struct noise_specific *)cp;

@


1.17
log
@Moved mathtab/rand_half from rt into libbn
Expanded structparse to include description and default
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_noise.c,v 1.16 1999/10/08 19:45:06 butler Exp $ (ARL)";
a500 1
		break;
@


1.16
log
@
Extra comments
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_noise.c,v 1.15 1999/07/22 03:09:41 butler Exp $ (ARL)";
a41 1
#include "../rt/mathtab.h"
@


1.15
log
@Impact flash shader "flash"
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_noise.c,v 1.14 1999/07/02 22:20:41 mike Exp $ (ARL)";
d113 1
a113 1
	{ 1.0, 1.0, 1.0 },	/* vscale */
d115 1
a115 1
	{	0.0, 0.0, 0.0, 0.0,
d119 1
a119 1
	{	0.0, 0.0, 0.0, 0.0,
d123 4
a126 4
	0.0,
	0.0,
	0.0,
	0
d148 1
a149 1
};
d157 2
a158 2
	{"%f",  3, "delta",		SHDR_AO(delta),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",  3, "d",			SHDR_AO(delta),	BU_STRUCTPARSE_FUNC_NULL },
@


1.14
log
@
Removed dependence on compat4.h
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_noise.c,v 1.13 1999/07/01 20:08:47 mike Exp $ (ARL)";
d212 3
d492 11
@


1.13
log
@
compat4
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_noise.c,v 1.12 1999/02/04 02:23:10 butler Exp $ (ARL)";
d139 4
a142 4
	{"%f",	1, "lacunarity",	SHDR_O(lacunarity),	FUNC_NULL },
	{"%f",	1, "H", 		SHDR_O(h_val),		FUNC_NULL },
	{"%f",	1, "octaves", 		SHDR_O(octaves),	FUNC_NULL },
	{"%f",  3, "delta",		SHDR_AO(delta),	FUNC_NULL },
d145 3
a147 3
	{"%f",  3, "vscale",		SHDR_AO(vscale),	FUNC_NULL },
	{"%f",  1, "min",		SHDR_O(minval),		FUNC_NULL },
	{"",	0, (char *)0,		0,			FUNC_NULL }
d152 7
a158 7
	{"%f",	1, "lacunarity",	SHDR_O(lacunarity),	FUNC_NULL },
	{"%f",	1, "l",			SHDR_O(lacunarity),	FUNC_NULL },
	{"%f",	1, "H", 		SHDR_O(h_val),		FUNC_NULL },
	{"%f",	1, "octaves", 		SHDR_O(octaves),	FUNC_NULL },
	{"%f",	1, "o", 		SHDR_O(octaves),	FUNC_NULL },
	{"%f",  3, "delta",		SHDR_AO(delta),	FUNC_NULL },
	{"%f",  3, "d",			SHDR_AO(delta),	FUNC_NULL },
d164 5
a168 5
	{"%f",  3, "vscale",		SHDR_AO(vscale),	FUNC_NULL },
	{"%f",  3, "vs",		SHDR_AO(vscale),	FUNC_NULL },
	{"%f",  3, "v",			SHDR_AO(vscale),	FUNC_NULL },
	{"%f",  1, "min",		SHDR_O(minval),		FUNC_NULL },
	{"",	0, (char *)0,		0,			FUNC_NULL }
@


1.12
log
@Added two aliases for grunge and gravel (turcombo and fbmcombo) in a vain
attempt to make the names of the Normal+Color noise shaders easier to keep
straight.

Deleted the (no longer used) shader-individual *_render routines now that the
combined "noise_render" is in use.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_noise.c,v 1.11 1999/01/29 05:53:31 butler Exp $ (ARL)";
d46 1
a46 1
#define CK_noise_SP(_p) RT_CKMAG(_p, noise_MAGIC, "noise_specific")
d61 1
a61 1
		rt_log("%s value %s ", name, value);
d66 1
a66 1
		rt_log(" %g\n", *p);
d131 1
a131 1
#define SHDR_AO(m)	offsetofarray(struct noise_specific, m)
d151 1
a151 1
	{"i",	bu_byteoffset(noise_print_tab[0]), "noise_print_tab", 0, FUNC_NULL },
d226 1
a226 1
struct rt_vls		*matparm;
d239 1
a239 1
	RT_VLS_CHECK( matparm );
d244 1
a244 1
		rt_log("noise_setup(%s, %s) (%s)\n",
d249 1
a249 1
	GETSTRUCT( noise_sp, noise_specific );
d264 1
a264 1
	rt_log("shader name \"%s\" not recognized, assuming \"%s\"\n",
d272 1
a272 1
	mat_idn(tmp);
d284 1
a284 1
	mat_mul(noise_sp->m_to_sh, tmp, model_to_region);
d287 1
a287 1
	mat_idn(tmp);
d291 1
a291 1
	mat_mul2(tmp, noise_sp->m_to_sh);
d293 1
a293 1
	mat_inv(noise_sp->sh_to_m, noise_sp->m_to_sh);
d300 1
a300 1
		mat_print( "m_to_sh", noise_sp->m_to_sh );
d327 1
a327 1
	rt_free( cp, "noise_specific" );
d439 1
a439 1
		rt_log("%s:%d noise_render(%s)  model:(%g %g %g) shader:(%g %g %g)\n", 
@


1.11
log
@Changed name of shader in sh_noise from 'gravel' to 'noise'.
fixed pointer bug in sh_stack.c
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_noise.c,v 1.10 1998/09/22 01:29:55 mike Exp $ (ARL)";
d188 1
a188 1
	{MF_MAGIC,	"gravel",	0,	MFI_NORMAL|MFI_HIT|MFI_UV,	0,
d191 1
a191 1
	{MF_MAGIC,	"fbmbump",	0,	MFI_NORMAL|MFI_HIT|MFI_UV,	0,
d194 1
a194 1
	{MF_MAGIC,	"turbump",	0,	MFI_NORMAL|MFI_HIT|MFI_UV,	0,
d197 1
a197 1
	{MF_MAGIC,	"fbmcolor",	0,	MFI_NORMAL|MFI_HIT|MFI_UV,	0,
d200 1
a200 1
	{MF_MAGIC,	"turcolor",	0,	MFI_NORMAL|MFI_HIT|MFI_UV,	0,
d203 1
a203 1
	{MF_MAGIC,	"grunge",	0,	MFI_NORMAL|MFI_HIT|MFI_UV,	0,
d206 6
d448 1
d482 1
a502 485
#if 0
/*
 *	G R A V E L _ R E N D E R
 *
 *	This is called (from viewshade() in shade.c) once for each hit point
 *	to be shaded.  The purpose here is to fill in values in the shadework
 *	structure.
 */
int
noise_render( ap, pp, swp, dp )
struct application	*ap;
struct partition	*pp;
struct shadework	*swp;	/* defined in material.h */
char			*dp;	/* ptr to the shader-specific struct */
{
	register struct noise_specific *noise_sp =
		(struct noise_specific *)dp;
	point_t pt;
	point_t u_pt, v_pt;
	vect_t u_vec, v_vec;
	double u_val, v_val;
	mat_t u_mat, v_mat;
	vect_t N, tmp;
	double val;

	/* check the validity of the arguments we got */
	RT_AP_CHECK(ap);
	RT_CHECK_PT(pp);
	CK_noise_SP(noise_sp);

	if( rdebug&RDEBUG_SHADE)
		bu_struct_print( "noise_render Parameters:", noise_print_tab, (char *)noise_sp );

	/* If we are performing the shading in "region" space, we must 
	 * transform the hit point from "model" space to "region" space.
	 * See the call to db_region_mat in noise_setup().
	 */
	MAT4X3PNT(pt, noise_sp->m_to_sh, swp->sw_hit.hit_point);

	if( rdebug&RDEBUG_SHADE) {
		rt_log("%s:%d noise_render(%s)  model:(%g %g %g) shader:(%g %g %g)\n", 
		__FILE__, __LINE__,
		noise_mfuncs[noise_sp->shader_number].mf_name,
		V3ARGS(swp->sw_hit.hit_point),
		V3ARGS(pt) );
	}

	val = bn_noise_turb(pt, noise_sp->h_val, noise_sp->lacunarity,
			noise_sp->octaves);

	VSCALE(swp->sw_color, swp->sw_color, val);


	/* dork the normal around
	 * Convert the normal to shader space, get u,v coordinate system
	 */

	if( rdebug&RDEBUG_SHADE) {
		VPRINT("Model space Normal", swp->sw_hit.hit_normal);
	}
	MAT4X3VEC(N, noise_sp->m_to_sh, swp->sw_hit.hit_normal);
	VUNITIZE(N);
	if( rdebug&RDEBUG_SHADE) {
		VPRINT("Shader space Normal", N);
	}

	bn_vec_perp(u_vec, N);
	VCROSS(v_vec, N, u_vec);

	VJOIN1(u_pt, pt, noise_sp->nsd, u_vec);
	u_val = bn_noise_turb(u_pt, noise_sp->h_val, noise_sp->lacunarity,
		noise_sp->octaves);

	VJOIN1(v_pt, pt, noise_sp->nsd, v_vec);
	v_val = bn_noise_turb(v_pt, noise_sp->h_val, noise_sp->lacunarity,
		noise_sp->octaves);

	if( rdebug&RDEBUG_SHADE) {
		VPRINT("pt", pt);
		VPRINT("u_vec", u_vec);
		VPRINT("u_pt", u_pt);
		VPRINT("v_vec", v_vec);
		VPRINT("v_pt", v_pt);
		
		rt_log("u_val:%g  v_val:%g  nsd:%g\n",
			u_val, v_val, noise_sp->nsd);
	}

	bn_mat_arb_rot(u_mat, pt, u_vec, (val - v_val) * noise_sp->max_angle);
	MAT4X3VEC(tmp, u_mat, N);

	bn_mat_arb_rot(v_mat, pt, v_vec, (val - u_val) * noise_sp->max_angle);
	MAT4X3VEC(N, v_mat, tmp);

	if( rdebug&RDEBUG_SHADE) {
		VPRINT("old normal", swp->sw_hit.hit_normal);
	}

	MAT4X3VEC(swp->sw_hit.hit_normal, noise_sp->sh_to_m, N);
	VUNITIZE(swp->sw_hit.hit_normal);
	if( rdebug&RDEBUG_SHADE) {
		VPRINT("new normal", swp->sw_hit.hit_normal);
	}

	/* shader must perform transmission/reflection calculations
	 *
	 * 0 < swp->sw_transmit <= 1 causes transmission computations
	 * 0 < swp->sw_reflect <= 1 causes reflection computations
	 */
	if( swp->sw_reflect > 0 || swp->sw_transmit > 0 )
		(void)rr_render( ap, pp, swp );

	return(1);
}
/*
 *	T U R C O L O R _ R E N D E R
 *
 *	This is called (from viewshade() in shade.c) once for each hit point
 *	to be shaded.  The purpose here is to fill in values in the shadework
 *	structure.
 */
int
turcolor_render( ap, pp, swp, dp )
struct application	*ap;
struct partition	*pp;
struct shadework	*swp;	/* defined in material.h */
char			*dp;	/* ptr to the shader-specific struct */
{
	register struct noise_specific *noise_sp =
		(struct noise_specific *)dp;
	point_t pt;
	point_t u_pt, v_pt;
	vect_t u_vec, v_vec;
	double u_val, v_val;
	mat_t u_mat, v_mat;
	vect_t N, tmp;
	double val;

	/* check the validity of the arguments we got */
	RT_AP_CHECK(ap);
	RT_CHECK_PT(pp);
	CK_noise_SP(noise_sp);

	if( rdebug&RDEBUG_SHADE)
		bu_struct_print( "turcolor_render Parameters:", noise_print_tab, (char *)noise_sp );

	/* If we are performing the shading in "region" space, we must 
	 * transform the hit point from "model" space to "region" space.
	 * See the call to db_region_mat in noise_setup().
	 */
	MAT4X3PNT(pt, noise_sp->m_to_sh, swp->sw_hit.hit_point);

	if( rdebug&RDEBUG_SHADE) {
		rt_log("%s:%d noise_render(%s)  model:(%g %g %g) shader:(%g %g %g)\n", 
		__FILE__, __LINE__,
		noise_mfuncs[noise_sp->shader_number].mf_name,
		V3ARGS(swp->sw_hit.hit_point),
		V3ARGS(pt) );
	}

	val = bn_noise_turb(pt, noise_sp->h_val, noise_sp->lacunarity,
			noise_sp->octaves);

	VSCALE(swp->sw_color, swp->sw_color, val);

	/* shader must perform transmission/reflection calculations
	 *
	 * 0 < swp->sw_transmit <= 1 causes transmission computations
	 * 0 < swp->sw_reflect <= 1 causes reflection computations
	 */
	if( swp->sw_reflect > 0 || swp->sw_transmit > 0 )
		(void)rr_render( ap, pp, swp );

	return(1);
}


/*
 *	F B M C O L O R _ R E N D E R
 *
 *	This is called (from viewshade() in shade.c) once for each hit point
 *	to be shaded.  The purpose here is to fill in values in the shadework
 *	structure.
 */
int
fbmcolor_render( ap, pp, swp, dp )
struct application	*ap;
struct partition	*pp;
struct shadework	*swp;	/* defined in material.h */
char			*dp;	/* ptr to the shader-specific struct */
{
	register struct noise_specific *noise_sp =
		(struct noise_specific *)dp;
	point_t pt;
	point_t u_pt, v_pt;
	vect_t u_vec, v_vec;
	double u_val, v_val;
	mat_t u_mat, v_mat;
	vect_t N, tmp;
	double val;

	/* check the validity of the arguments we got */
	RT_AP_CHECK(ap);
	RT_CHECK_PT(pp);
	CK_noise_SP(noise_sp);

	if( rdebug&RDEBUG_SHADE)
		bu_struct_print( "fbmcolor_render Parameters:", noise_print_tab, (char *)noise_sp );

	/* If we are performing the shading in "region" space, we must 
	 * transform the hit point from "model" space to "region" space.
	 * See the call to db_region_mat in noise_setup().
	 */
	MAT4X3PNT(pt, noise_sp->m_to_sh, swp->sw_hit.hit_point);

	if( rdebug&RDEBUG_SHADE) {
		rt_log("%s:%d noise_render(%s)  model:(%g %g %g) shader:(%g %g %g)\n", 
		__FILE__, __LINE__,
		noise_mfuncs[noise_sp->shader_number].mf_name,
		V3ARGS(swp->sw_hit.hit_point),
		V3ARGS(pt) );
	}

	val = bn_noise_fbm(pt, noise_sp->h_val, noise_sp->lacunarity,
			noise_sp->octaves);

	val = (val+1.0)*0.5;
	VSCALE(swp->sw_color, swp->sw_color, val);

	/* shader must perform transmission/reflection calculations
	 *
	 * 0 < swp->sw_transmit <= 1 causes transmission computations
	 * 0 < swp->sw_reflect <= 1 causes reflection computations
	 */
	if( swp->sw_reflect > 0 || swp->sw_transmit > 0 )
		(void)rr_render( ap, pp, swp );

	return(1);
}





/*
 *	T U R B U M P _ R E N D E R
 *
 *	"turbulence" noise bumps
 */
int
turbump_render( ap, pp, swp, dp )
struct application	*ap;
struct partition	*pp;
struct shadework	*swp;	/* defined in material.h */
char			*dp;	/* ptr to the shader-specific struct */
{
	register struct noise_specific *noise_sp =
		(struct noise_specific *)dp;
	point_t pt;
	point_t u_pt, v_pt;
	vect_t u_vec, v_vec;
	double u_val, v_val;
	mat_t u_mat, v_mat;
	vect_t N, tmp;
	double val;

	/* check the validity of the arguments we got */
	RT_AP_CHECK(ap);
	RT_CHECK_PT(pp);
	CK_noise_SP(noise_sp);

	if( rdebug&RDEBUG_SHADE)
		bu_struct_print( "turbump_render Parameters:", noise_print_tab, (char *)noise_sp );

	/* If we are performing the shading in "region" space, we must 
	 * transform the hit point from "model" space to "region" space.
	 * See the call to db_region_mat in noise_setup().
	 */
	MAT4X3PNT(pt, noise_sp->m_to_sh, swp->sw_hit.hit_point);

	if( rdebug&RDEBUG_SHADE) {
		rt_log("%s:%d noise_render(%s)  model:(%g %g %g) shader:(%g %g %g)\n", 
		__FILE__, __LINE__,
		noise_mfuncs[noise_sp->shader_number].mf_name,
		V3ARGS(swp->sw_hit.hit_point),
		V3ARGS(pt) );
	}

	val = bn_noise_turb(pt, noise_sp->h_val, noise_sp->lacunarity,
			noise_sp->octaves);

	/* dork the normal around
	 * Convert the normal to shader space, get u,v coordinate system
	 */

	if( rdebug&RDEBUG_SHADE) {
		VPRINT("Model space Normal", swp->sw_hit.hit_normal);
	}
	MAT4X3VEC(N, noise_sp->m_to_sh, swp->sw_hit.hit_normal);
	VUNITIZE(N);
	if( rdebug&RDEBUG_SHADE) {
		VPRINT("Shader space Normal", N);
	}

	bn_vec_perp(u_vec, N);
	VCROSS(v_vec, N, u_vec);

	VJOIN1(u_pt, pt, noise_sp->nsd, u_vec);
	u_val = bn_noise_turb(u_pt, noise_sp->h_val, noise_sp->lacunarity,
		noise_sp->octaves);

	VJOIN1(v_pt, pt, noise_sp->nsd, v_vec);
	v_val = bn_noise_turb(v_pt, noise_sp->h_val, noise_sp->lacunarity,
		noise_sp->octaves);

	if( rdebug&RDEBUG_SHADE) {
		VPRINT("pt", pt);
		VPRINT("u_vec", u_vec);
		VPRINT("u_pt", u_pt);
		VPRINT("v_vec", v_vec);
		VPRINT("v_pt", v_pt);
		
		rt_log("u_val:%g  v_val:%g  nsd:%g\n",
			u_val, v_val, noise_sp->nsd);
	}

	bn_mat_arb_rot(u_mat, pt, u_vec, (val-v_val) * noise_sp->max_angle);
	MAT4X3VEC(tmp, u_mat, N);

	bn_mat_arb_rot(v_mat, pt, v_vec, (val-u_val) * noise_sp->max_angle);
	MAT4X3VEC(N, v_mat, tmp);

	if( rdebug&RDEBUG_SHADE) {
		VPRINT("old normal", swp->sw_hit.hit_normal);
	}

	MAT4X3VEC(swp->sw_hit.hit_normal, noise_sp->sh_to_m, N);
	VUNITIZE(swp->sw_hit.hit_normal);
	if( rdebug&RDEBUG_SHADE) {
		VPRINT("new normal", swp->sw_hit.hit_normal);
	}

	/* shader must perform transmission/reflection calculations
	 *
	 * 0 < swp->sw_transmit <= 1 causes transmission computations
	 * 0 < swp->sw_reflect <= 1 causes reflection computations
	 */
	if( swp->sw_reflect > 0 || swp->sw_transmit > 0 )
		(void)rr_render( ap, pp, swp );

	return(1);
}






/*
 *	F B M B U M P _ R E N D E R
 *
 *	This is called (from viewshade() in shade.c) once for each hit point
 *	to be shaded.  The purpose here is to fill in values in the shadework
 *	structure.
 */
int
fbmbump_render( ap, pp, swp, dp )
struct application	*ap;
struct partition	*pp;
struct shadework	*swp;	/* defined in material.h */
char			*dp;	/* ptr to the shader-specific struct */
{
	register struct noise_specific *noise_sp =
		(struct noise_specific *)dp;
	point_t pt;
	point_t u_pt, v_pt;
	vect_t u_vec, v_vec;
	double u_val, v_val;
	mat_t u_mat, v_mat;
	vect_t N, tmp;
	double val;
	double delta_val;

	/* check the validity of the arguments we got */
	RT_AP_CHECK(ap);
	RT_CHECK_PT(pp);
	CK_noise_SP(noise_sp);

	if( rdebug&RDEBUG_SHADE)
		bu_struct_print( "fbmbump_render Parameters:", noise_print_tab, (char *)noise_sp );

	/* If we are performing the shading in "region" space, we must 
	 * transform the hit point from "model" space to "region" space.
	 * See the call to db_region_mat in noise_setup().
	 */
	MAT4X3PNT(pt, noise_sp->m_to_sh, swp->sw_hit.hit_point);

	if( rdebug&RDEBUG_SHADE) {
		rt_log("%s:%d noise_render(%s)  model:(%g %g %g) shader:(%g %g %g)\n", 
		__FILE__, __LINE__,
		noise_mfuncs[noise_sp->shader_number].mf_name,
		V3ARGS(swp->sw_hit.hit_point),
		V3ARGS(pt) );
	}

	val = bn_noise_fbm(pt, noise_sp->h_val, noise_sp->lacunarity,
			noise_sp->octaves);

	/* dork the normal around
	 * Convert the normal to shader space, get u,v coordinate system
	 */

	if( rdebug&RDEBUG_SHADE) {
		VPRINT("Model space Normal", swp->sw_hit.hit_normal);
	}
	MAT4X3VEC(N, noise_sp->m_to_sh, swp->sw_hit.hit_normal);
	VUNITIZE(N);
	if( rdebug&RDEBUG_SHADE) {
		VPRINT("Shader space Normal", N);
	}

	bn_vec_perp(u_vec, N);
	VCROSS(v_vec, N, u_vec);

	VJOIN1(u_pt, pt, noise_sp->nsd, u_vec);
	u_val = bn_noise_turb(u_pt, noise_sp->h_val, noise_sp->lacunarity,
		noise_sp->octaves);

	VJOIN1(v_pt, pt, noise_sp->nsd, v_vec);
	v_val = bn_noise_turb(v_pt, noise_sp->h_val, noise_sp->lacunarity,
		noise_sp->octaves);

	if( rdebug&RDEBUG_SHADE) {
		VPRINT("pt", pt);
		VPRINT("u_vec", u_vec);
		VPRINT("u_pt", u_pt);
		VPRINT("v_vec", v_vec);
		VPRINT("v_pt", v_pt);
		
		rt_log("u_val:%g  v_val:%g  nsd:%g\n",
			u_val, v_val, noise_sp->nsd);
	}


	delta_val = val-v_val;
	if (fabs(delta_val) > noise_sp->max_delta) {
		noise_sp->max_delta = fabs(delta_val);
		rt_log("max delta %g\n", noise_sp->max_delta);
	}
	delta_val *= 0.125;

	bn_mat_arb_rot(u_mat, pt, u_vec, delta_val * noise_sp->max_angle);
	MAT4X3VEC(tmp, u_mat, N);

	delta_val = val-u_val;
	if (fabs(delta_val) > noise_sp->max_delta) {
		noise_sp->max_delta = fabs(delta_val);
		rt_log("max delta %g\n", noise_sp->max_delta);
	}
	delta_val *= 0.125;

	bn_mat_arb_rot(v_mat, pt, v_vec, delta_val * noise_sp->max_angle);
	MAT4X3VEC(N, v_mat, tmp);

	if( rdebug&RDEBUG_SHADE) {
		VPRINT("old normal", swp->sw_hit.hit_normal);
	}

	MAT4X3VEC(swp->sw_hit.hit_normal, noise_sp->sh_to_m, N);
	VUNITIZE(swp->sw_hit.hit_normal);
	if( rdebug&RDEBUG_SHADE) {
		VPRINT("new normal", swp->sw_hit.hit_normal);
	}

	/* shader must perform transmission/reflection calculations
	 *
	 * 0 < swp->sw_transmit <= 1 causes transmission computations
	 * 0 < swp->sw_reflect <= 1 causes reflection computations
	 */
	if( swp->sw_reflect > 0 || swp->sw_transmit > 0 )
		(void)rr_render( ap, pp, swp );

	return(1);
}
#endif
@


1.10
log
@Moved optical shaders from rt/ to liboptical/
The only modifications involved moving and splitting
rt/material.h into h/shadefuncs.h and h/shadework.h,
and in changing the calling sequence to mlib_setup() in rt/material.c

Now the only shader function called directly by RT is
in liboptical/init.c: optical_shader_init().
It adds all the individual shaders to the "mfuncs" shader list.
@
text
@d2 1
a2 1
 *	S H _ G R A V E L . C
d28 1
a28 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
d45 2
a46 2
#define gravel_MAGIC 0x1847
#define CK_gravel_SP(_p) RT_CKMAG(_p, gravel_MAGIC, "gravel_specific")
d52 1
a52 1
gravel_cvt_parse( sdp, name, base, value )
d71 1
a71 1
gravel_deg_to_rad( sdp, name, base, value )
d87 1
a87 1
struct gravel_specific {
d106 2
a107 2
struct gravel_specific gravel_defaults = {
	gravel_MAGIC,
d129 3
a131 3
#define SHDR_NULL	((struct gravel_specific *)0)
#define SHDR_O(m)	offsetof(struct gravel_specific, m)
#define SHDR_AO(m)	offsetofarray(struct gravel_specific, m)
d138 1
a138 1
struct bu_structparse gravel_print_tab[] = {
d144 1
a144 1
	{"%f",  1, "angle",		SHDR_O(max_angle),	gravel_deg_to_rad },
d150 2
a151 2
struct bu_structparse gravel_parse_tab[] = {
	{"i",	bu_byteoffset(gravel_print_tab[0]), "gravel_print_tab", 0, FUNC_NULL },
d161 3
a163 3
	{"%f",  1, "angle",		SHDR_O(max_angle),	gravel_deg_to_rad },
	{"%f",  1, "ang",		SHDR_O(max_angle),	gravel_deg_to_rad },
	{"%f",  1, "a",			SHDR_O(max_angle),	gravel_deg_to_rad },
d171 1
a171 1
HIDDEN int	gravel_setup(), gravel_render(),
d175 1
a175 1
HIDDEN void	gravel_print(), gravel_free();
d187 1
a187 1
struct mfuncs gravel_mfuncs[] = {
d189 1
a189 1
	gravel_setup,	fractal_render,	gravel_print,	gravel_free },
d192 1
a192 1
	gravel_setup,	fractal_render,	gravel_print,	gravel_free },
d195 1
a195 1
	gravel_setup,	fractal_render, gravel_print,	gravel_free },
d198 1
a198 1
	gravel_setup,	fractal_render, gravel_print,	gravel_free },
d201 1
a201 1
	gravel_setup,	fractal_render, gravel_print,	gravel_free },
d204 1
a204 1
	gravel_setup,	fractal_render, gravel_print,	gravel_free },
d218 1
a218 1
gravel_setup( rp, matparm, dpp, mfp, rtip)
d225 1
a225 1
	register struct gravel_specific	*gravel_sp;
d238 3
a240 2
		rt_log("gravel_setup(%s, %s)\n",
			rp->reg_name, rp->reg_mater.ma_shader);
d243 2
a244 2
	GETSTRUCT( gravel_sp, gravel_specific );
	*dpp = (char *)gravel_sp;
d247 1
a247 1
	memcpy(gravel_sp, &gravel_defaults, sizeof(struct gravel_specific) );
d250 1
a250 1
	if( bu_struct_parse( matparm, gravel_parse_tab, (char *)gravel_sp ) < 0 )
d254 2
a255 2
	for (i = 0 ; gravel_mfuncs[i].mf_name ; i++ ) {
		if (!strcmp(gravel_mfuncs[i].mf_name, mfp->mf_name))
d259 1
a259 1
		mfp->mf_name, gravel_mfuncs[0].mf_name);
d262 1
a262 1
	gravel_sp->shader_number = i;
d267 1
a267 1
	if (gravel_sp->size != 1.0) {
d271 1
a271 1
		tmp[0] = tmp[5] = tmp[10] = 1.0/gravel_sp->size;
d273 3
a275 3
		tmp[0] = 1.0/gravel_sp->vscale[0];
		tmp[5] = 1.0/gravel_sp->vscale[1];
		tmp[10] = 1.0/gravel_sp->vscale[2];
d278 1
a278 1
	mat_mul(gravel_sp->m_to_sh, tmp, model_to_region);
d282 4
a285 4
	tmp[MDX] = gravel_sp->delta[0];
	tmp[MDY] = gravel_sp->delta[1];
	tmp[MDZ] = gravel_sp->delta[2];
	mat_mul2(tmp, gravel_sp->m_to_sh);
d287 1
a287 1
	mat_inv(gravel_sp->sh_to_m, gravel_sp->m_to_sh);
d289 2
a290 2
	gravel_sp->nsd = 1.0 / 
		pow(gravel_sp->lacunarity, gravel_sp->octaves);
d293 2
a294 2
		bu_struct_print( " Parameters:", gravel_print_tab, (char *)gravel_sp );
		mat_print( "m_to_sh", gravel_sp->m_to_sh );
d304 1
a304 1
gravel_print( rp, dp )
d308 1
a308 1
	bu_struct_print( rp->reg_name, gravel_print_tab, (char *)dp );
d315 1
a315 1
gravel_free( cp )
d318 2
a319 2
	register struct gravel_specific *gravel_sp =
		(struct gravel_specific *)cp;
d321 1
a321 1
	rt_free( cp, "gravel_specific" );
d331 1
a331 1
norm_noise(pt, val, gravel_sp, func, swp, rescale)
d334 1
a334 1
struct gravel_specific *gravel_sp;
d352 1
a352 1
	MAT4X3VEC(N, gravel_sp->m_to_sh, swp->sw_hit.hit_normal);
d365 3
a367 3
	VJOIN1(u_pt, pt, gravel_sp->nsd, u_vec);
	u_val = func(u_pt, gravel_sp->h_val, gravel_sp->lacunarity,
		gravel_sp->octaves);
d371 3
a373 3
	VJOIN1(v_pt, pt, gravel_sp->nsd, v_vec);
	v_val = func(v_pt, gravel_sp->h_val, gravel_sp->lacunarity,
		gravel_sp->octaves);
d381 1
a381 1
	bn_mat_arb_rot(u_mat, pt, u_vec, (val - v_val) * gravel_sp->max_angle);
d384 1
a384 1
	bn_mat_arb_rot(v_mat, pt, v_vec, (val - u_val) * gravel_sp->max_angle);
d392 1
a392 1
	MAT4X3VEC(swp->sw_hit.hit_normal, gravel_sp->sh_to_m, N);
d413 2
a414 2
	register struct gravel_specific *gravel_sp =
		(struct gravel_specific *)dp;
d421 1
a421 1
	CK_gravel_SP(gravel_sp);
d424 1
a424 1
		bu_struct_print( "gravel_render Parameters:", gravel_print_tab, (char *)gravel_sp );
d428 1
a428 1
	 * See the call to db_region_mat in gravel_setup().
d430 1
a430 1
	MAT4X3PNT(pt, gravel_sp->m_to_sh, swp->sw_hit.hit_point);
d433 1
a433 1
		rt_log("%s:%d gravel_render(%s)  model:(%g %g %g) shader:(%g %g %g)\n", 
d435 1
a435 1
		gravel_mfuncs[gravel_sp->shader_number].mf_name,
d440 1
a440 1
	switch (gravel_sp->shader_number) {
d442 3
a444 3
		val = bn_noise_turb(pt, gravel_sp->h_val,
			gravel_sp->lacunarity, gravel_sp->octaves);
		if (val < gravel_sp->minval )  val = gravel_sp->minval;
d447 1
a447 1
		norm_noise(pt, val, gravel_sp, bn_noise_turb, swp, 0);
d450 2
a451 2
		val = bn_noise_fbm(pt, gravel_sp->h_val,
			gravel_sp->lacunarity, gravel_sp->octaves);
d453 1
a453 1
		norm_noise(pt, val, gravel_sp, bn_noise_fbm, swp, 1);
d456 2
a457 2
		val = bn_noise_turb(pt, gravel_sp->h_val,
			gravel_sp->lacunarity, gravel_sp->octaves);
d459 1
a459 1
		norm_noise(pt, val, gravel_sp, bn_noise_turb, swp, 0);
d462 2
a463 2
		val = bn_noise_fbm(pt, gravel_sp->h_val,
			gravel_sp->lacunarity, gravel_sp->octaves);
d465 1
a465 1
		if (val < gravel_sp->minval )  val = gravel_sp->minval;
d469 3
a471 3
		val = bn_noise_turb(pt, gravel_sp->h_val,
			gravel_sp->lacunarity, gravel_sp->octaves);
		if (val < gravel_sp->minval )  val = gravel_sp->minval;
d475 2
a476 2
		val = bn_noise_fbm(pt, gravel_sp->h_val,
			gravel_sp->lacunarity, gravel_sp->octaves);
d478 1
a478 1
		if (val < gravel_sp->minval )  val = gravel_sp->minval;
d480 1
a480 1
		norm_noise(pt, val, gravel_sp, bn_noise_fbm, swp, 1);
d504 1
a504 1
gravel_render( ap, pp, swp, dp )
d510 2
a511 2
	register struct gravel_specific *gravel_sp =
		(struct gravel_specific *)dp;
d523 1
a523 1
	CK_gravel_SP(gravel_sp);
d526 1
a526 1
		bu_struct_print( "gravel_render Parameters:", gravel_print_tab, (char *)gravel_sp );
d530 1
a530 1
	 * See the call to db_region_mat in gravel_setup().
d532 1
a532 1
	MAT4X3PNT(pt, gravel_sp->m_to_sh, swp->sw_hit.hit_point);
d535 1
a535 1
		rt_log("%s:%d gravel_render(%s)  model:(%g %g %g) shader:(%g %g %g)\n", 
d537 1
a537 1
		gravel_mfuncs[gravel_sp->shader_number].mf_name,
d542 2
a543 2
	val = bn_noise_turb(pt, gravel_sp->h_val, gravel_sp->lacunarity,
			gravel_sp->octaves);
d555 1
a555 1
	MAT4X3VEC(N, gravel_sp->m_to_sh, swp->sw_hit.hit_normal);
d564 7
a570 7
	VJOIN1(u_pt, pt, gravel_sp->nsd, u_vec);
	u_val = bn_noise_turb(u_pt, gravel_sp->h_val, gravel_sp->lacunarity,
		gravel_sp->octaves);

	VJOIN1(v_pt, pt, gravel_sp->nsd, v_vec);
	v_val = bn_noise_turb(v_pt, gravel_sp->h_val, gravel_sp->lacunarity,
		gravel_sp->octaves);
d580 1
a580 1
			u_val, v_val, gravel_sp->nsd);
d583 1
a583 1
	bn_mat_arb_rot(u_mat, pt, u_vec, (val - v_val) * gravel_sp->max_angle);
d586 1
a586 1
	bn_mat_arb_rot(v_mat, pt, v_vec, (val - u_val) * gravel_sp->max_angle);
d593 1
a593 1
	MAT4X3VEC(swp->sw_hit.hit_normal, gravel_sp->sh_to_m, N);
d623 2
a624 2
	register struct gravel_specific *gravel_sp =
		(struct gravel_specific *)dp;
d636 1
a636 1
	CK_gravel_SP(gravel_sp);
d639 1
a639 1
		bu_struct_print( "turcolor_render Parameters:", gravel_print_tab, (char *)gravel_sp );
d643 1
a643 1
	 * See the call to db_region_mat in gravel_setup().
d645 1
a645 1
	MAT4X3PNT(pt, gravel_sp->m_to_sh, swp->sw_hit.hit_point);
d648 1
a648 1
		rt_log("%s:%d gravel_render(%s)  model:(%g %g %g) shader:(%g %g %g)\n", 
d650 1
a650 1
		gravel_mfuncs[gravel_sp->shader_number].mf_name,
d655 2
a656 2
	val = bn_noise_turb(pt, gravel_sp->h_val, gravel_sp->lacunarity,
			gravel_sp->octaves);
d686 2
a687 2
	register struct gravel_specific *gravel_sp =
		(struct gravel_specific *)dp;
d699 1
a699 1
	CK_gravel_SP(gravel_sp);
d702 1
a702 1
		bu_struct_print( "fbmcolor_render Parameters:", gravel_print_tab, (char *)gravel_sp );
d706 1
a706 1
	 * See the call to db_region_mat in gravel_setup().
d708 1
a708 1
	MAT4X3PNT(pt, gravel_sp->m_to_sh, swp->sw_hit.hit_point);
d711 1
a711 1
		rt_log("%s:%d gravel_render(%s)  model:(%g %g %g) shader:(%g %g %g)\n", 
d713 1
a713 1
		gravel_mfuncs[gravel_sp->shader_number].mf_name,
d718 2
a719 2
	val = bn_noise_fbm(pt, gravel_sp->h_val, gravel_sp->lacunarity,
			gravel_sp->octaves);
d751 2
a752 2
	register struct gravel_specific *gravel_sp =
		(struct gravel_specific *)dp;
d764 1
a764 1
	CK_gravel_SP(gravel_sp);
d767 1
a767 1
		bu_struct_print( "turbump_render Parameters:", gravel_print_tab, (char *)gravel_sp );
d771 1
a771 1
	 * See the call to db_region_mat in gravel_setup().
d773 1
a773 1
	MAT4X3PNT(pt, gravel_sp->m_to_sh, swp->sw_hit.hit_point);
d776 1
a776 1
		rt_log("%s:%d gravel_render(%s)  model:(%g %g %g) shader:(%g %g %g)\n", 
d778 1
a778 1
		gravel_mfuncs[gravel_sp->shader_number].mf_name,
d783 2
a784 2
	val = bn_noise_turb(pt, gravel_sp->h_val, gravel_sp->lacunarity,
			gravel_sp->octaves);
d793 1
a793 1
	MAT4X3VEC(N, gravel_sp->m_to_sh, swp->sw_hit.hit_normal);
d802 7
a808 7
	VJOIN1(u_pt, pt, gravel_sp->nsd, u_vec);
	u_val = bn_noise_turb(u_pt, gravel_sp->h_val, gravel_sp->lacunarity,
		gravel_sp->octaves);

	VJOIN1(v_pt, pt, gravel_sp->nsd, v_vec);
	v_val = bn_noise_turb(v_pt, gravel_sp->h_val, gravel_sp->lacunarity,
		gravel_sp->octaves);
d818 1
a818 1
			u_val, v_val, gravel_sp->nsd);
d821 1
a821 1
	bn_mat_arb_rot(u_mat, pt, u_vec, (val-v_val) * gravel_sp->max_angle);
d824 1
a824 1
	bn_mat_arb_rot(v_mat, pt, v_vec, (val-u_val) * gravel_sp->max_angle);
d831 1
a831 1
	MAT4X3VEC(swp->sw_hit.hit_normal, gravel_sp->sh_to_m, N);
d867 2
a868 2
	register struct gravel_specific *gravel_sp =
		(struct gravel_specific *)dp;
d881 1
a881 1
	CK_gravel_SP(gravel_sp);
d884 1
a884 1
		bu_struct_print( "fbmbump_render Parameters:", gravel_print_tab, (char *)gravel_sp );
d888 1
a888 1
	 * See the call to db_region_mat in gravel_setup().
d890 1
a890 1
	MAT4X3PNT(pt, gravel_sp->m_to_sh, swp->sw_hit.hit_point);
d893 1
a893 1
		rt_log("%s:%d gravel_render(%s)  model:(%g %g %g) shader:(%g %g %g)\n", 
d895 1
a895 1
		gravel_mfuncs[gravel_sp->shader_number].mf_name,
d900 2
a901 2
	val = bn_noise_fbm(pt, gravel_sp->h_val, gravel_sp->lacunarity,
			gravel_sp->octaves);
d910 1
a910 1
	MAT4X3VEC(N, gravel_sp->m_to_sh, swp->sw_hit.hit_normal);
d919 7
a925 7
	VJOIN1(u_pt, pt, gravel_sp->nsd, u_vec);
	u_val = bn_noise_turb(u_pt, gravel_sp->h_val, gravel_sp->lacunarity,
		gravel_sp->octaves);

	VJOIN1(v_pt, pt, gravel_sp->nsd, v_vec);
	v_val = bn_noise_turb(v_pt, gravel_sp->h_val, gravel_sp->lacunarity,
		gravel_sp->octaves);
d935 1
a935 1
			u_val, v_val, gravel_sp->nsd);
d940 3
a942 3
	if (fabs(delta_val) > gravel_sp->max_delta) {
		gravel_sp->max_delta = fabs(delta_val);
		rt_log("max delta %g\n", gravel_sp->max_delta);
d946 1
a946 1
	bn_mat_arb_rot(u_mat, pt, u_vec, delta_val * gravel_sp->max_angle);
d950 3
a952 3
	if (fabs(delta_val) > gravel_sp->max_delta) {
		gravel_sp->max_delta = fabs(delta_val);
		rt_log("max delta %g\n", gravel_sp->max_delta);
d956 1
a956 1
	bn_mat_arb_rot(v_mat, pt, v_vec, delta_val * gravel_sp->max_angle);
d963 1
a963 1
	MAT4X3VEC(swp->sw_hit.hit_normal, gravel_sp->sh_to_m, N);
@


1.9
log
@Can't make "struct mfuncs" a CONST, because the forward link needs
to be filled in at runtime, and some compilers put CONST data into
read-only pages (like FreeBSD).
@
text
@d11 11
d23 3
d27 4
d40 4
a43 3
#include "./material.h"
#include "./mathtab.h"
#include "./rdebug.h"
@


1.8
log
@Required magic number to be first in mfunc table,
consistent with all other BRL-CAD magic numbers.
Required magic number to be initialized at compile time.
Added code to check the magic numbers.
Made the xxx_mfunc arrays CONST, so they can't get trashed by
runtime runaway pointer problems.
@
text
@d168 1
a168 1
CONST struct mfuncs gravel_mfuncs[] = {
@


1.7
log
@Added 'minval' parameter which puts lower bound on noise value.
This is useful on 'turcolor' to keep color from going to hard black.
@
text
@d168 2
a169 2
struct mfuncs gravel_mfuncs[] = {
	{"gravel",	0,	0,	MFI_NORMAL|MFI_HIT|MFI_UV,	0,
d172 1
a172 1
	{"fbmbump",	0,	0,	MFI_NORMAL|MFI_HIT|MFI_UV,	0,
d175 1
a175 1
	{"turbump",	0,	0,	MFI_NORMAL|MFI_HIT|MFI_UV,	0,
d178 1
a178 1
	{"fbmcolor",	0,	0,	MFI_NORMAL|MFI_HIT|MFI_UV,	0,
d181 1
a181 1
	{"turcolor",	0,	0,	MFI_NORMAL|MFI_HIT|MFI_UV,	0,
d184 1
a184 1
	{"grunge",	0,	0,	MFI_NORMAL|MFI_HIT|MFI_UV,	0,
d187 1
a187 1
	{(char *)0,	0,	0,		0,		0,
@


1.6
log
@checkpoint
@
text
@d81 1
d106 1
d127 1
d148 1
d424 1
d445 1
d451 1
d458 1
@


1.5
log
@adjusted debug statments
@
text
@d122 1
a122 1
	{"%f",  1, "size",		SHDR_O(size),		gravel_cvt_parse },
d137 5
a141 5
	{"%f",  1, "size",		SHDR_O(size),		gravel_cvt_parse },
	{"%f",  1, "s",			SHDR_O(size),		gravel_cvt_parse },
	{"%f",  1, "angle",		SHDR_O(max_angle),		gravel_deg_to_rad },
	{"%f",  1, "ang",		SHDR_O(max_angle),		gravel_deg_to_rad },
	{"%f",  1, "a",			SHDR_O(max_angle),		gravel_deg_to_rad },
@


1.4
log
@changed filename, fixed units stuff
@
text
@d41 2
a42 1
	rt_log("%s value %s ", name, value);
d46 2
a47 1
	rt_log(" %g\n", *p);
@


1.3
log
@Compile on Irix6
@
text
@d41 1
d44 3
@


1.2
log
@unified noise render
@
text
@d18 1
d20 1
d55 1
a55 1
	*p = *p * (M_PI / 180.0);
d79 1
a79 1
CONST static
d86 1
a86 1
	M_PI_2,		/* max_angle */
@


1.1
log
@Initial revision
@
text
@d71 3
a73 1
	struct rt_vls	shader;
d95 3
a97 1
	{ 0, (char *)0, 0, 0, 0 }
d142 2
a143 1
		fbmcolor_render(), turcolor_render();
d153 2
d158 1
a158 1
	gravel_setup,	gravel_render,	gravel_print,	gravel_free },
d161 1
a161 1
	gravel_setup,	fbmbump_render,	gravel_print,	gravel_free },
d164 1
a164 1
	gravel_setup,	turbump_render, gravel_print,	gravel_free },
d167 1
a167 1
	gravel_setup,	fbmcolor_render, gravel_print,	gravel_free },
d170 4
a173 1
	gravel_setup,	turcolor_render, gravel_print,	gravel_free },
d198 1
d221 10
a230 18
	bu_vls_init(&gravel_sp->shader);
	bu_vls_strcpy(&gravel_sp->shader, rp->reg_mater.ma_shader);

	/* Optional:
	 *
	 * If the shader needs to operate in a coordinate system which stays
	 * fixed on the region when the region is moved (as in animation)
	 * we need to get a matrix to perform the appropriate transform(s).
	 *
	 * db_shader_mat returns a matrix which maps points on/in the region
	 * into the unit cube.  This unit cube is formed by first mapping from
	 * world coordinates into "region coordinates" (the coordinate system
	 * in which the region is defined).  Then the bounding box of the 
	 * region is used to establish a mapping to the unit cube
	 *
*	db_shader_mat(xxx_sp->xxx_m_to_sh, rtip, rp, xxx_sp->xxx_min,
*		xxx_sp->xxx_max);
	 */
d257 3
d286 3
d291 156
d448 13
a460 1
/*
d479 1
a479 1
	double u_val, v_val, noise_space_delta;
d501 1
a501 1
		bu_vls_addr(&gravel_sp->shader),
d528 1
a528 5
	noise_space_delta = 1.0 / 
		pow(gravel_sp->lacunarity, gravel_sp->octaves);


	VJOIN1(u_pt, pt, noise_space_delta, u_vec);
d532 1
a532 1
	VJOIN1(v_pt, pt, noise_space_delta, v_vec);
d544 1
a544 1
			u_val, v_val, noise_space_delta);
d592 1
a592 1
	double u_val, v_val, noise_space_delta;
d603 1
a603 1
		bu_struct_print( "gravel_render Parameters:", gravel_print_tab, (char *)gravel_sp );
d614 1
a614 1
		bu_vls_addr(&gravel_sp->shader),
d655 1
a655 1
	double u_val, v_val, noise_space_delta;
d677 1
a677 1
		bu_vls_addr(&gravel_sp->shader),
d720 1
a720 1
	double u_val, v_val, noise_space_delta;
d731 1
a731 1
		bu_struct_print( "gravel_render Parameters:", gravel_print_tab, (char *)gravel_sp );
d742 1
a742 1
		bu_vls_addr(&gravel_sp->shader),
d766 1
a766 5
	noise_space_delta = 1.0 / 
		pow(gravel_sp->lacunarity, gravel_sp->octaves);


	VJOIN1(u_pt, pt, noise_space_delta, u_vec);
d770 1
a770 1
	VJOIN1(v_pt, pt, noise_space_delta, v_vec);
d782 1
a782 1
			u_val, v_val, noise_space_delta);
d785 1
a785 1
	bn_mat_arb_rot(u_mat, pt, u_vec, (val - v_val) * gravel_sp->max_angle);
d788 1
a788 1
	bn_mat_arb_rot(v_mat, pt, v_vec, (val - u_val) * gravel_sp->max_angle);
d836 1
a836 1
	double u_val, v_val, noise_space_delta;
d840 1
d848 1
a848 1
		bu_struct_print( "gravel_render Parameters:", gravel_print_tab, (char *)gravel_sp );
d859 1
a859 1
		bu_vls_addr(&gravel_sp->shader),
d883 1
a883 5
	noise_space_delta = 1.0 / 
		pow(gravel_sp->lacunarity, gravel_sp->octaves);


	VJOIN1(u_pt, pt, noise_space_delta, u_vec);
d887 1
a887 1
	VJOIN1(v_pt, pt, noise_space_delta, v_vec);
d899 8
a906 1
			u_val, v_val, noise_space_delta);
d908 1
d910 1
a910 1
	bn_mat_arb_rot(u_mat, pt, u_vec, (val - v_val) * gravel_sp->max_angle);
d913 8
a920 1
	bn_mat_arb_rot(v_mat, pt, v_vec, (val - u_val) * gravel_sp->max_angle);
d943 1
@
