head	11.22;
access;
symbols
	ansi-20040405-merged:11.19.2.1
	postmerge-20040405-ansi:11.20
	premerge-20040404-ansi:11.19
	postmerge-autoconf:11.19
	autoconf-freeze:11.19
	premerge-autoconf:11.19
	ansi-20040316-freeze:11.19.2.1
	postmerge-20040315-windows:11.19
	premerge-20040315-windows:11.19
	windows-20040315-freeze:11.19
	autoconf-20031203:11.19
	autoconf-20031202:11.19
	autoconf-branch:11.19.0.10
	phong-branch:11.19.0.8
	photonmap-branch:11.19.0.6
	rel-6-1-DP:11.19
	windows-branch:11.19.0.4
	rel-6-0-2:11.17
	ansi-branch:11.19.0.2
	rel-6-0-1-branch:11.17.0.2
	hartley-6-0-post:11.18
	hartley-6-0-pre:11.17
	rel-6-0-1:11.17
	rel-6-0:11.17
	rel-5-4:11.14
	offsite-5-3-pre:11.16
	rel-5-3:11.14
	rel-5-2:11.14
	rel-5-1-branch:11.14.0.2
	rel-5-1:11.14
	rel-5-0:11.12
	rel-5-0-beta:11.10
	rel-4-5:11.7
	ctj-4-5-post:11.5
	ctj-4-5-pre:11.5
	rel-4-4:11.1;
locks; strict;
comment	@ * @;


11.22
date	2004.05.21.18.07.28;	author morrison;	state dead;
branches;
next	11.21;

11.21
date	2004.05.10.15.30.45;	author erikg;	state Exp;
branches;
next	11.20;

11.20
date	2004.04.05.07.43.37;	author morrison;	state Exp;
branches;
next	11.19;

11.19
date	2002.08.20.17.07.52;	author jra;	state Exp;
branches
	11.19.2.1;
next	11.18;

11.18
date	2002.08.15.20.55.05;	author hartley;	state Exp;
branches;
next	11.17;

11.17
date	2001.04.20.22.29.33;	author morrison;	state Exp;
branches;
next	11.16;

11.16
date	2000.08.20.01.27.48;	author butler;	state Exp;
branches;
next	11.15;

11.15
date	2000.07.25.16.40.39;	author butler;	state Exp;
branches;
next	11.14;

11.14
date	2000.02.19.21.05.02;	author butler;	state Exp;
branches;
next	11.13;

11.13
date	99.10.30.03.06.25;	author butler;	state Exp;
branches;
next	11.12;

11.12
date	99.07.02.22.20.42;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	99.07.01.20.08.49;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	99.05.10.21.40.13;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	98.09.22.01.29.56;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	98.06.30.22.54.19;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	97.12.31.09.01.40;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	97.11.25.22.16.43;	author butler;	state Exp;
branches;
next	11.5;

11.5
date	96.08.31.08.46.01;	author butler;	state Exp;
branches;
next	11.4;

11.4
date	96.08.31.08.29.28;	author butler;	state Exp;
branches;
next	11.3;

11.3
date	96.08.30.00.08.21;	author butler;	state Exp;
branches;
next	11.2;

11.2
date	95.10.20.04.43.53;	author butler;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.01.16;	author mike;	state Rel4_4;
branches;
next	1.6;

1.6
date	94.11.21.19.11.41;	author stay;	state Exp;
branches;
next	1.5;

1.5
date	94.11.05.03.00.44;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	94.11.01.07.17.12;	author butler;	state Exp;
branches;
next	1.3;

1.3
date	94.10.31.22.46.05;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	94.10.31.22.18.20;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	94.10.31.22.15.16;	author mike;	state Exp;
branches;
next	;

11.19.2.1
date	2002.09.19.18.01.27;	author morrison;	state Exp;
branches;
next	;


desc
@Bill Laut's wood shader.
@


11.22
log
@moved to src/
@
text
@/*
 *  			W O O D . C
 * 
 *	Simple wood-grain texture 
 *
 *  Author -
 *	Bill Laut, Gull Island Consultants, Inc.
 *
 *  "Where Credit is Due" Authors -
 *	Tom DiGiacinto - For his linearly-interpolated noise function as
 *			 found in the "sh_marble.c" routine.
 *
 *  Description -
 *	This module implements a simple concentric ring abstraction that
 *	fairly simulates the ring pattern of wood.  The placement of the
 *	rings within the combination is controlled through two MATPARM
 *	entries which centers the rings and specifies their direction.
 *	The actual rings themselves are formed on a plane perpendicular to
 *	the direction cosines, from the sine of the product of the outward
 *	distance and a MATPARM coefficient.
 *
 *	The dithering mechanism is a slight enhancement upon the 3-D noise
 *	table which Tom DiGiacinto used in "sh_marble."  In my case, the
 *	access is still limited to 10x10x10, but the table itself is expanded
 *	to 20x20x20.  There is a MATPARM "dither" field which is used to
 *	"dither the dither."  IE, the "dither" parameter is a coefficient which
 *	is summed into Tom's interpolation routine, thereby allowing each
 *	wood-shaded combination to have a different noise pattern, and prevents
 *	all similar combinations from looking alike.  The "dither" field is
 *	initialized with the "bn_rand0to1" routine before calling the parser, so
 *	default values can be used.  However, (obviously) the user can override
 *	the defaults if desired.
 *
 *	The MATPARM fields for this shader are:
 *
 *	    id = n		Multi-region identification number
 *	    o{verlay} = n	# of dithered overlay rings to circumscribe
 *	    lt{_rgb} = R/G/B	The RGB color for the wood between the rings.
 *	    dk{_rgb} = R/G/B	The RGB color of the rings.
 *	    s{pacing} = n	Space in mm between rings
 *	    p{hase} = n		Controls thickness of the rings
 *	    qd = n		Degree of dithered "bleed" on edges of rings
 *	    qp = n		Degree of undithered "bleed" on ring edges
 *	    dd = n		Amount of 3-D dither applied to vertex
 *	    dz = n		Amount of Z-axis vertex dither
 *	    di{ther} = a/b/c	Starting point of dither within noise table
 *	    de{pth} = f		Amount of dither to add to sine
 *	    r{otation} = a/b/c	3-D rotation of rings' vertex
 *	    V = X/Y/Z		Vertex of rings' center
 *	    D = X/Y/Z		XYZ of where rings's center is aimed at
 *
 *  Source -
 *	Gull Island Consultants, Inc.
 *	P.O. Box 627
 *	Muskegon, MI  49440
 *
 *  Copyright Notice -
 *	This Software is Copyright (c) 1994, Gull Island Consultants, Inc.
 *	All rights reserved.
 *
 *  Distribution Notice -
 *	Permission is granted to freely distribute this software as part of
 *	the BRL-CAD package.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/liboptical/sh_wood.c,v 11.21 2004/05/10 15:30:45 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <ctype.h>
#include <math.h>
#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "raytrace.h"
#include "shadefuncs.h"
#include "shadework.h"
/*#include "../rt/mathtab.h"*/
#include "rtprivate.h"

/*
 *	Sundry external references
 */
extern	fastf_t	turb_table[20][20][20];

/*
 *	Sundry routine declarations
 */

HIDDEN int	wood_init(void), wood_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip), wood_render(struct application *ap, struct partition *partp, struct shadework *swp, char *dp);
HIDDEN void	wood_print(register struct region *rp);
HIDDEN void	wood_free RT_ARGS(( char * ));

HIDDEN void	wood_V_set RT_ARGS((const struct bu_structparse *, const char *, const char *, char *));
HIDDEN void	wood_D_set RT_ARGS((const struct bu_structparse *, const char *, const char *, char *));

/*
 *	functions block for the shader
 */

#ifdef eRT
struct mfuncs wood_mfuncs[] = {
	{MF_MAGIC,	"wood",	0,		MFI_HIT|MFI_UV|MFI_NORMAL,	0,
	wood_init,	wood_setup,	wood_render,	wood_print,	wood_free},

	{MF_MAGIC,	"w",		0,		MFI_HIT|MFI_UV|MFI_NORMAL,	0,
	wood_init,	wood_setup,	wood_render,	wood_print,	wood_free},

	{0,		(char *)0,	0,		0,	0,
	0,		0,		0,		0,		0}
};
#else
struct mfuncs wood_mfuncs[] = {
	{MF_MAGIC,	"wood",	0, 		MFI_HIT|MFI_UV|MFI_NORMAL,	0,
	wood_setup,	wood_render,	wood_print,	wood_free},

	{MF_MAGIC,	"w",		0,		MFI_HIT|MFI_UV|MFI_NORMAL,	0,
	wood_setup,	wood_render,	wood_print,	wood_free},

	{0,		(char *)0,	0,		0,	0,
	0,		0,		0,		0}
};
#endif

/*
 *	Impure storage area for shader
 */

struct wood_specific {
	struct	wood_specific	*forw;
	struct	region		*rp;
	int			ident;
	int			flags;
	int			overlay;
	int			ns;
	fastf_t			jitter;
	fastf_t			lt_rgb[3];
	fastf_t			dk_rgb[3];
	fastf_t			depth;
	fastf_t			spacing;
	fastf_t			phase;
	fastf_t			dd;
	fastf_t			qd;
	fastf_t			dz;
	fastf_t			qp;
	fastf_t			scale;
	fastf_t			dither[3];
	vect_t			vertex;
	vect_t			dir;
	vect_t			rot;
	vect_t			b_min;
	vect_t			b_max;
	vect_t			c_min;
	vect_t			c_max;
	vect_t			D;
	vect_t			V;
};

HIDDEN void	wood_setup_2 RT_ARGS((struct wood_specific *));

/*
 *	Flags and useful offset declarations
 */

#define WOOD_NULL	((struct wood_specific *)0)
#define WOOD_O(m)	offsetof(struct wood_specific, m)
#define WOOD_OA(m)	bu_offsetofarray(struct wood_specific, m)

#define	EXPLICIT_VERTEX		1
#define EXPLICIT_DIRECTION	2

/*
 *	Listhead for multi-region wood combinations
 */

static struct wood_specific	*Wood_Chain;

/*
 *	MATPARM parsing structure
 */

struct bu_structparse wood_parse[] = {
	{"%d",	1, "ident",		WOOD_O(ident),		BU_STRUCTPARSE_FUNC_NULL },
	{"%d",	1, "id",		WOOD_O(ident),		BU_STRUCTPARSE_FUNC_NULL },
	{"%d",	1, "overlay",		WOOD_O(overlay),	BU_STRUCTPARSE_FUNC_NULL },
	{"%d",	1, "o",			WOOD_O(overlay),	BU_STRUCTPARSE_FUNC_NULL },
	{"%d",	1, "ns",		WOOD_O(ns),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "jitter",		WOOD_O(jitter),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "j",			WOOD_O(jitter),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	3, "lt_rgb",		WOOD_OA(lt_rgb),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	3, "lt",		WOOD_OA(lt_rgb),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	3, "dk_rgb",		WOOD_OA(dk_rgb),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	3, "dk",		WOOD_OA(dk_rgb),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "spacing",		WOOD_O(spacing),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "s",			WOOD_O(spacing),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "scale",		WOOD_O(scale),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "sc",		WOOD_O(scale),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "phase",		WOOD_O(phase),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "p",			WOOD_O(phase),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "qd",		WOOD_O(qd),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "qp",		WOOD_O(qp),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	3, "dither",		WOOD_OA(dither),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	3, "di",		WOOD_OA(dither),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "depth",		WOOD_O(depth),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "de",		WOOD_O(depth),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "dd",		WOOD_O(dd),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "dz",		WOOD_O(dz),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	3, "rotation",		WOOD_OA(rot),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	3, "r",			WOOD_OA(rot),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	3, "D",			WOOD_OA(D),		wood_D_set },
	{"%f",	3, "V",			WOOD_OA(V),		wood_V_set },
	{"",	0, (char *)0,		0,			BU_STRUCTPARSE_FUNC_NULL }
};

/*
 *	Noise Table.  Based upon work by Tom DiGiacinto.  This table gives us
 *	a linearly-interpolated noise function for dithering location of rings
 *	within the wood surface.  It is approximately four times bigger than is
 *	actually needed, so that we can dither the starting position on a 
 *	per-region basis, and thus make each region look unique.
 */

#define IPOINTS 10			/* undithered number of points */
#define TPOINTS 20			/* Dithering space */

static	int	wood_done = 0;

/*
 *			W O O D _ I N I T
 *
 *	This routine is called at the beginning of RT's cycle to initialize
 *	the noise table. 
 */

HIDDEN int wood_init (void)
{

	/*
	 *	Initialize the wood chain
	 */

	Wood_Chain = WOOD_NULL;

	/*
	 *	Return to caller
	 */

	return (1);
}

/*
 *		M I S C _ S E T U P _ F U N C T I O N S
 *
 *	The following are miscellaneous routines which are invoked by the parser
 *	to set flag bits, indicating the presence of actual parsed values.
 */

HIDDEN void wood_V_set (const struct bu_structparse *sdp, const char *name, const char *base, char *value)
{
	register struct wood_specific *wd =
		(struct wood_specific *)base;

	wd->flags |= EXPLICIT_VERTEX;
}

HIDDEN void wood_D_set (const struct bu_structparse *sdp, const char *name, const char *base, char *value)
{
	register struct wood_specific *wd =
		(struct wood_specific *)base;

	wd->flags |= EXPLICIT_DIRECTION;
}

/*
 *			W O O D _ S E T U P
 */
HIDDEN int wood_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip)
                      	    
             		         
    			      
                             
                                /* New since 4.4 release */
{
	register int i;
	register struct wood_specific *wd;

	extern struct resource		rt_uniresource;
	register struct resource	*resp = &rt_uniresource;

#ifndef eRT
	/*
	 *	If this isn't the customized RT, then call "wood_init"
	 *	here to prep the noise tables.
	 */

	if (!wood_done) {
		wood_init();
		wood_done = 1;
		}
#endif

	/*
	 *	Get the impure storage for the control block
	 */

	BU_CK_VLS( matparm );
	BU_GETSTRUCT( wd, wood_specific );
	*dpp = (char *)wd;

	/*
	 *	Load the default values
	 */

	if (rp->reg_mater.ma_color_valid) {
		VSCALE (wd->lt_rgb, rp->reg_mater.ma_color, 255);
		}
	   else {
		wd->lt_rgb[0] = 255;	/* Light yellow */
		wd->lt_rgb[1] = 255;
		wd->lt_rgb[2] = 224;
		}

	wd->dk_rgb[0] = 191;		/* Brownish-red */
	wd->dk_rgb[1] =  97;
	wd->dk_rgb[2] =   0;

	wd->ident     = 0;
	wd->forw      = WOOD_NULL;
	wd->rp	      = rp;
	wd->flags     = 0;
	wd->overlay   = 0;		/* Draw only one ring */
	wd->ns	      = 10;
	wd->jitter    = 0.0;
	wd->scale     = 1.0;
	wd->spacing   = 5;		/* 5mm space between rings */
	wd->dd        = 0.0;		/* no dither of vertex */
	wd->dz        = 0.0;		/* nor of Z-axis */
	wd->qd        = 0;
	wd->qp        = 0;
	wd->phase     = 5;
	wd->depth     = 0;

	wd->dither[0] = bn_rand0to1 (resp->re_randptr);
	wd->dither[1] = bn_rand0to1 (resp->re_randptr);
	wd->dither[2] = bn_rand0to1 (resp->re_randptr);

	VSETALL (wd->rot, 0);
	VSETALL (wd->vertex, 0);
	VSETALL (wd->D, 0);
	VSETALL (wd->V, 0);

	/*
	 *	Parse the MATPARM field
	 */

	if (bu_struct_parse( matparm, wood_parse, (char *)wd ) < 0 )  {
		bu_free( (char *)wd, "wood_specific" );
		return(-1);
		}

	/*
	 *	Do some sundry range and misc. checking
	 */

	for (i=0; i<3; i++) {
		if (wd->dither[i] < 0 || wd->dither[i] > 1.0) {
			bu_log ("wood_setup(%s):  dither is out of range.\n",
				rp->reg_name);
			return (-1);
			}
		}

	if (wd->flags == EXPLICIT_VERTEX) {
		bu_log ("wood_setup(%s):  Explicit vertex specfied without direction\n", rp->reg_name);
		return (-1);
		}

	if (wd->flags == EXPLICIT_DIRECTION) {
		bu_log ("wood_setup(%s):  Explicit direction specfied without vertex\n", rp->reg_name);
		return (-1);
		}

	/*
	 *	Get the bounding RPP
	 */

	if (rt_bound_tree (rp->reg_treetop, wd->b_min, wd->b_max) < 0) return (-1);

	/*
	 *	Add it to the wood chain
	 */

	wd->forw   = Wood_Chain;
	Wood_Chain = wd;

	/*
	 *	See if the user has flagged this region as a member of a larger
	 *	combination.  If so, go ahead and process it
	 */

	if (wd->ident == 0)
		wood_setup_2 (wd);

	   else {
		register struct wood_specific	*wc;
		vect_t			c_min, c_max;

		/*
		 *	First, process the accumulated chain of wood regions and
		 *	process all regions which have the specified ident field.
		 */

		VSETALL (c_min, 0);
		VSETALL (c_max, 0);

		for (wc = Wood_Chain; wc != WOOD_NULL; wc = wc->forw) {
			if (wc->ident == wd->ident) {
				VMIN (c_min, wc->b_min);
				VMAX (c_max, wc->b_max);
				}
			}

		/*
		 *	Now, loop through the chain again this time updating the
		 *	regions' min/max fields with the new values
		 */

		for (wc = Wood_Chain; wc != WOOD_NULL; wc = wc->forw) {
			if (wc->ident == wd->ident) {
				VMOVE (wc->b_min, c_min);
				VMOVE (wc->b_max, c_max);
				wood_setup_2 (wc);
				}
			}

		/*
		 *	End of multi-region processing loop
		 */

		}

	/*
	 *	Normalize the RGB colors
	 */

	for (i = 0; i < 3; i++) {
		wd->lt_rgb[i] *= bn_inv255;
		wd->dk_rgb[i] *= bn_inv255;
		}

	/*
	 *	Return to the caller
	 */

	return (1);
}

/*
 *	Phase 2 setup routine
 */

HIDDEN void wood_setup_2 (struct wood_specific *wd)
{
	mat_t	xlate;
	int	i;
	vect_t	a_vertex, a_dir;

	extern struct resource		rt_uniresource;
	register struct resource	*resp = &rt_uniresource;

	/*
	 *	See if the user specified absolute coordinates for the vertex and 
	 *	direction.  If so, use those instead of the RPP.
	 */

	bn_mat_angles (xlate, V3ARGS (wd->rot));

	if (wd->flags & EXPLICIT_VERTEX) {
		MAT4X3PNT (wd->vertex, xlate, wd->V);
		MAT4X3PNT (wd->dir, xlate, wd->D);
		}
	   else {
		if (wd->dz > 0.0) {
			for (i=0; i<2; i++) {
				a_vertex[i] = wd->b_min[i];
				a_dir[i] = wd->b_max[i];
				}
			/* Z component is [2] */
			a_vertex[2] = ((wd->b_max[2] - wd->b_min[2]) * 
					(bn_rand0to1(resp->re_randptr) * wd->dz)) + wd->b_min[2];
			a_dir[2]    = ((wd->b_max[2] - wd->b_min[2]) * 
					(bn_rand0to1(resp->re_randptr) * wd->dz)) + wd->b_min[2];
			}
		   else {
			for (i=0; i<3; i++) {
				a_vertex[i] = ((wd->b_max[i] - wd->b_min[i]) * 
						(bn_rand0to1(resp->re_randptr) * wd->dd)) + wd->b_min[i];
				a_dir[i]    = ((wd->b_max[i] - wd->b_min[i]) * 
						(bn_rand0to1(resp->re_randptr) * wd->dd)) + wd->b_max[i];
				}
			}
		MAT4X3PNT (wd->vertex, xlate, a_vertex);
		MAT4X3PNT (wd->dir, xlate, a_dir);
		}

	VSUB2 (wd->dir, wd->dir, wd->vertex);
	VUNITIZE (wd->dir);
}

/*
 *			W O O D _ P R I N T
 */
HIDDEN void wood_print(register struct region *rp)
{
	bu_struct_print(rp->reg_name, wood_parse, (char *)rp->reg_udata);
}

/*
 *			W O O D _ F R E E
 *
 *	This routine is called to free up the user block at the end
 *	of a frame, as well as clean up any references to objects on
 *	the Wood_Chain list.
 */
HIDDEN void wood_free (char *cp)
{
	register struct wood_specific *wd =
		(struct wood_specific *)cp;

	register struct wood_specific *wc;

	if (Wood_Chain == wd) {
/*		bu_log ("wood_free(%s):  Releasing region (at head).\n", wd->rp->reg_name); */
		Wood_Chain = wd->forw;
		bu_free ((char *)wd, "wood_specific");
		return;
		}

	for (wc = Wood_Chain; wc != WOOD_NULL; wc = wc->forw) {
		if (wc->forw == wd) {
/*			bu_log ("wood_free(%s):  Releasing region.\n", wd->rp->reg_name); */
			wc->forw = wd->forw;
			bu_free ((char *)wd, "wood_specific");
			return;
			}
		}

	bu_free ((char *)wd, "wood_specific");
}

/*
 *		N O I S E  &  T U R B U L E N C E
 *
 *  These are the noise and turbulence routines which the rendering routine
 *  uses to perturb the rings.  They are lifted directly from the "sh_marble"
 *  routine.  Eventually, they will be moved into a separate library for
 *  dealing with noise and turbulence.
 */

HIDDEN double wood_noise (double x, double y, double z, struct wood_specific *wd)
{
	int	xi, yi, zi;
	double	xr, yr, zr;
	double	n1, n2, noise1, noise2, noise3, noise;

	xi = x * IPOINTS;
	xr = (x * IPOINTS) - xi;
	yi = y * IPOINTS;
	yr = (y * IPOINTS) - yi;
	zi = z * IPOINTS;
	zr = (z * IPOINTS) - zi;

	n1     = (1 - xr) * turb_table[xi][yi][zi] + 
		       xr * turb_table[xi + 1][yi][zi];
	n2     = (1 - xr) * turb_table[xi][yi + 1][zi] +
		       xr * turb_table[xi + 1][yi + 1][zi];
	noise1 = (1 - yr) * n1 + yr * n2;

	n1     = (1 - xr) * turb_table[xi][yi][zi + 1] +
		       xr * turb_table[xi + 1][yi][zi + 1];
	n2     = (1 - xr) * turb_table[xi][yi + 1][zi + 1] +
		       xr * turb_table[xi + 1][yi + 1][zi + 1];
	noise2 = (1 - yr) * n1 + yr * n2;

	noise3 = (1 - zr) * noise1 + zr * noise2;
	noise  = pow (noise3, wd->scale);

	return (noise);
}

HIDDEN double wood_turb (double x, double y, double z, struct wood_specific *wd)
{
	extern struct resource		rt_uniresource;
	register struct resource	*resp = &rt_uniresource;

	int	i;
	fastf_t	a, b, c, turb = 0.0, scale;

	for (i=0; i<wd->ns; i++) {
		scale = (double)i / (double)wd->ns;

		a = (x * scale) +
		    (bn_rand_half (resp->re_randptr) * wd->jitter) +
		    wd->dither[X];

		b = (y * scale) +
		    (bn_rand_half (resp->re_randptr) * wd->jitter) +
		    wd->dither[Y];

		c = (z * scale) +
		    (bn_rand_half (resp->re_randptr) * wd->jitter) +
		    wd->dither[Z];

		turb += wood_noise (a, b, c, wd);
		}

	return (turb);
}

/*
 *  			W O O D _ R E N D E R
 *  
 *  Given an XYZ hit point, compute the concentric ring structure.  We do
 *  this by computing the dot-product of the hit point vs the ring vertex,
 *  which is then used to compute the distance from the ring center.  This
 *  distance is then multiplied by a velocity coefficient that is sined.
 */
HIDDEN int wood_render(struct application *ap, struct partition *partp, struct shadework *swp, char *dp)
{
	register struct wood_specific *wd =
		(struct wood_specific *)dp;

	vect_t	g, h;
	point_t	dprod, lprod;
	double	c, A, B, C;
	double	x, y, z, xd, yd, zd;
	double	mixture, pp, pq, wt;

	/*
	 *	Compute the normalized hit point
	 */

	xd = wd->b_max[0] - wd->b_min[0] + 1.0;
	yd = wd->b_max[1] - wd->b_min[1] + 1.0;
	zd = wd->b_max[2] - wd->b_min[2] + 1.0;

	x = wd->dither[X] + ((swp->sw_hit.hit_point[0] - wd->b_min[0]) / xd);
	y = wd->dither[Y] + ((swp->sw_hit.hit_point[1] - wd->b_min[1]) / yd);
	z = wd->dither[Z] + ((swp->sw_hit.hit_point[2] - wd->b_min[2]) / zd);

	/*
	 *	Compute the distance from the ring center to the hit
	 *	point by formulating a triangle between the hit point,
	 *	the ring vertex, and ring's local X-axis.
	 */

	VSUB2 (h, swp->sw_hit.hit_point, wd->vertex);
	VMOVE (g, h);
	VUNITIZE (g);				/* xlate to ray */

	wt = wood_turb (x,y,z,wd) * wd->depth;	/* used in two places */

	c = fabs (VDOT (g, wd->dir));
	A = MAGNITUDE (h) + wt;
	B = c * A;				/* abscissa */
	C = sqrt (pow (A, 2.0) - pow (B, 2.0));	/* ordinate */ 

	/*
	 *	Divide the ordinate by the spacing coefficient, and
	 *	compute the sine from that product.
	 */

	c = fabs (sin ((C / wd->spacing) * bn_pi));

	/*
	 *	Dither the "q" control
	 */

	pq = cos (((wd->qd * wt) + wd->qp + wd->phase) * bn_degtorad);
	pp = cos (wd->phase * bn_degtorad);

	/*
	 *	Color the hit point based on the phase of the ring
	 */

	if (c < pq) {
		VMOVE (swp->sw_color, wd->lt_rgb);
		}
	   else if (c >= pp) {
			VMOVE (swp->sw_color, wd->dk_rgb);
			}
		   else {
			mixture = (c - pq) / (pp - pq);
			VSCALE (lprod, wd->lt_rgb, (1.0 - mixture));
			VSCALE (dprod, wd->dk_rgb, mixture);
			VADD2 (swp->sw_color, lprod, dprod);
			}

	/*
	 *	All done.  Return to the caller
	 */

	return(1);
}
@


11.21
log
@change conf.h to a wrapped config.h
@
text
@d66 1
a66 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/liboptical/sh_wood.c,v 11.20 2004/04/05 07:43:37 morrison Exp $ (ARL)";
@


11.20
log
@merge of ansi-6-0-branch into HEAD
@
text
@d66 1
a66 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d69 5
a73 1
#include "conf.h"
@


11.19
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d66 1
a66 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_wood.c,v 11.17 2001/04/20 22:29:33 morrison Exp $ (ARL)";
d92 2
a93 2
HIDDEN int	wood_init(), wood_setup(), wood_render();
HIDDEN void	wood_print();
d237 1
a237 1
HIDDEN int wood_init ()
d260 1
a260 5
HIDDEN void wood_V_set (sdp, name, base, value)
const struct bu_structparse *sdp;
const char *name;
const char *base;
char *value;
d268 1
a268 5
HIDDEN void wood_D_set (sdp, name, base, value)
const struct bu_structparse *sdp;
const char *name;
const char *base;
char *value;
d279 6
a284 6
HIDDEN int wood_setup( rp, matparm, dpp, mfp, rtip )
register struct region	*rp;
struct bu_vls		*matparm;
char			**dpp;
struct mfuncs           *mfp;
struct rt_i             *rtip;  /* New since 4.4 release */
d464 1
a464 2
HIDDEN void wood_setup_2 (wd)
struct wood_specific *wd;
d515 1
a515 2
HIDDEN void wood_print( rp )
register struct region *rp;
d527 1
a527 2
HIDDEN void wood_free (cp)
char *cp;
d562 1
a562 3
HIDDEN double wood_noise (x, y, z, wd)
double x, y, z;
struct wood_specific	*wd;
d593 1
a593 3
HIDDEN double wood_turb (x, y, z, wd)
double x, y, z;
struct wood_specific *wd;
d630 1
a630 5
HIDDEN int wood_render( ap, partp, swp, dp )
struct application	*ap;
struct partition	*partp;
struct shadework	*swp;
char			*dp;
@


11.19.2.1
log
@Initial ANSIfication
@
text
@d66 1
a66 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_wood.c,v 11.19 2002/08/20 17:07:52 jra Exp $ (ARL)";
d92 2
a93 2
HIDDEN int	wood_init(void), wood_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip), wood_render(struct application *ap, struct partition *partp, struct shadework *swp, char *dp);
HIDDEN void	wood_print(register struct region *rp);
d237 1
a237 1
HIDDEN int wood_init (void)
d260 5
a264 1
HIDDEN void wood_V_set (const struct bu_structparse *sdp, const char *name, const char *base, char *value)
d272 5
a276 1
HIDDEN void wood_D_set (const struct bu_structparse *sdp, const char *name, const char *base, char *value)
d287 6
a292 6
HIDDEN int wood_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip)
                      	    
             		         
    			      
                             
                                /* New since 4.4 release */
d472 2
a473 1
HIDDEN void wood_setup_2 (struct wood_specific *wd)
d524 2
a525 1
HIDDEN void wood_print(register struct region *rp)
d537 2
a538 1
HIDDEN void wood_free (char *cp)
d573 3
a575 1
HIDDEN double wood_noise (double x, double y, double z, struct wood_specific *wd)
d606 3
a608 1
HIDDEN double wood_turb (double x, double y, double z, struct wood_specific *wd)
d645 5
a649 1
HIDDEN int wood_render(struct application *ap, struct partition *partp, struct shadework *swp, char *dp)
@


11.18
log
@Converted from K&R to ANSI C - RFH
@
text
@d92 2
a93 2
HIDDEN int	wood_init(void), wood_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip), wood_render(struct application *ap, struct partition *partp, struct shadework *swp, char *dp);
HIDDEN void	wood_print(register struct region *rp);
d237 1
a237 1
HIDDEN int wood_init (void)
d260 5
a264 1
HIDDEN void wood_V_set (const struct bu_structparse *sdp, const char *name, const char *base, char *value)
d272 5
a276 1
HIDDEN void wood_D_set (const struct bu_structparse *sdp, const char *name, const char *base, char *value)
d287 6
a292 6
HIDDEN int wood_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip)
                      	    
             		         
    			      
                             
                                /* New since 4.4 release */
d472 2
a473 1
HIDDEN void wood_setup_2 (struct wood_specific *wd)
d524 2
a525 1
HIDDEN void wood_print(register struct region *rp)
d537 2
a538 1
HIDDEN void wood_free (char *cp)
d573 3
a575 1
HIDDEN double wood_noise (double x, double y, double z, struct wood_specific *wd)
d606 3
a608 1
HIDDEN double wood_turb (double x, double y, double z, struct wood_specific *wd)
d645 5
a649 1
HIDDEN int wood_render(struct application *ap, struct partition *partp, struct shadework *swp, char *dp)
@


11.17
log
@CONST to const
@
text
@d66 1
a66 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_wood.c,v 11.16 2000/08/20 01:27:48 butler Exp $ (ARL)";
d92 2
a93 2
HIDDEN int	wood_init(), wood_setup(), wood_render();
HIDDEN void	wood_print();
d237 1
a237 1
HIDDEN int wood_init ()
d260 1
a260 5
HIDDEN void wood_V_set (sdp, name, base, value)
const struct bu_structparse *sdp;
const char *name;
const char *base;
char *value;
d268 1
a268 5
HIDDEN void wood_D_set (sdp, name, base, value)
const struct bu_structparse *sdp;
const char *name;
const char *base;
char *value;
d279 6
a284 6
HIDDEN int wood_setup( rp, matparm, dpp, mfp, rtip )
register struct region	*rp;
struct bu_vls		*matparm;
char			**dpp;
struct mfuncs           *mfp;
struct rt_i             *rtip;  /* New since 4.4 release */
d464 1
a464 2
HIDDEN void wood_setup_2 (wd)
struct wood_specific *wd;
d515 1
a515 2
HIDDEN void wood_print( rp )
register struct region *rp;
d527 1
a527 2
HIDDEN void wood_free (cp)
char *cp;
d562 1
a562 3
HIDDEN double wood_noise (x, y, z, wd)
double x, y, z;
struct wood_specific	*wd;
d593 1
a593 3
HIDDEN double wood_turb (x, y, z, wd)
double x, y, z;
struct wood_specific *wd;
d630 1
a630 5
HIDDEN int wood_render( ap, partp, swp, dp )
struct application	*ap;
struct partition	*partp;
struct shadework	*swp;
char			*dp;
@


11.16
log
@Eliminate compilation warnings, enhancements to sh_light.c
@
text
@d66 1
a66 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_wood.c,v 11.15 2000/07/25 16:40:39 butler Exp $ (ARL)";
d96 2
a97 2
HIDDEN void	wood_V_set RT_ARGS((CONST struct bu_structparse *, CONST char *, CONST char *, char *));
HIDDEN void	wood_D_set RT_ARGS((CONST struct bu_structparse *, CONST char *, CONST char *, char *));
d261 3
a263 3
CONST struct bu_structparse *sdp;
CONST char *name;
CONST char *base;
d273 3
a275 3
CONST struct bu_structparse *sdp;
CONST char *name;
CONST char *base;
@


11.15
log
@Changes to use rtprivate.h instead of ../rt/rdebug.h
@
text
@d66 1
a66 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_wood.c,v 11.14 2000/02/19 21:05:02 butler Exp $ (ARL)";
@


11.14
log
@Changes to support movement of CLAMP() macro into vmath.h
Altered "if( " statements to "if (" for readability.
@
text
@d66 1
a66 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_wood.c,v 11.13 1999/10/30 03:06:25 butler Exp $ (ARL)";
d81 1
a81 1
#include "../rt/rdebug.h"
@


11.13
log
@Moved mathtab/rand_half from rt into libbn
Expanded structparse to include description and default
@
text
@d66 1
a66 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_wood.c,v 11.12 1999/07/02 22:20:42 mike Exp $ (ARL)";
d366 1
a366 1
	if( bu_struct_parse( matparm, wood_parse, (char *)wd ) < 0 )  {
@


11.12
log
@
Removed dependence on compat4.h
@
text
@d30 1
a30 1
 *	initialized with the "rand0to1" routine before calling the parser, so
d66 1
a66 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_wood.c,v 11.11 1999/07/01 20:08:49 mike Exp $ (ARL)";
d80 1
a80 1
#include "../rt/mathtab.h"
d353 3
a355 3
	wd->dither[0] = rand0to1 (resp->re_randptr);
	wd->dither[1] = rand0to1 (resp->re_randptr);
	wd->dither[2] = rand0to1 (resp->re_randptr);
d501 1
a501 1
					(rand0to1(resp->re_randptr) * wd->dz)) + wd->b_min[2];
d503 1
a503 1
					(rand0to1(resp->re_randptr) * wd->dz)) + wd->b_min[2];
d508 1
a508 1
						(rand0to1(resp->re_randptr) * wd->dd)) + wd->b_min[i];
d510 1
a510 1
						(rand0to1(resp->re_randptr) * wd->dd)) + wd->b_max[i];
d620 1
a620 1
		    (rand_half (resp->re_randptr) * wd->jitter) +
d624 1
a624 1
		    (rand_half (resp->re_randptr) * wd->jitter) +
d628 1
a628 1
		    (rand_half (resp->re_randptr) * wd->jitter) +
@


11.11
log
@
compat4
@
text
@d66 1
a66 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_wood.c,v 11.10 1999/05/10 21:40:13 mike Exp $ (ARL)";
d185 27
a211 27
	{"%d",	1, "ident",		WOOD_O(ident),		FUNC_NULL },
	{"%d",	1, "id",		WOOD_O(ident),		FUNC_NULL },
	{"%d",	1, "overlay",		WOOD_O(overlay),	FUNC_NULL },
	{"%d",	1, "o",			WOOD_O(overlay),	FUNC_NULL },
	{"%d",	1, "ns",		WOOD_O(ns),		FUNC_NULL },
	{"%f",	1, "jitter",		WOOD_O(jitter),		FUNC_NULL },
	{"%f",	1, "j",			WOOD_O(jitter),		FUNC_NULL },
	{"%f",	3, "lt_rgb",		WOOD_OA(lt_rgb),	FUNC_NULL },
	{"%f",	3, "lt",		WOOD_OA(lt_rgb),	FUNC_NULL },
	{"%f",	3, "dk_rgb",		WOOD_OA(dk_rgb),	FUNC_NULL },
	{"%f",	3, "dk",		WOOD_OA(dk_rgb),	FUNC_NULL },
	{"%f",	1, "spacing",		WOOD_O(spacing),	FUNC_NULL },
	{"%f",	1, "s",			WOOD_O(spacing),	FUNC_NULL },
	{"%f",	1, "scale",		WOOD_O(scale),		FUNC_NULL },
	{"%f",	1, "sc",		WOOD_O(scale),		FUNC_NULL },
	{"%f",	1, "phase",		WOOD_O(phase),		FUNC_NULL },
	{"%f",	1, "p",			WOOD_O(phase),		FUNC_NULL },
	{"%f",	1, "qd",		WOOD_O(qd),		FUNC_NULL },
	{"%f",	1, "qp",		WOOD_O(qp),		FUNC_NULL },
	{"%f",	3, "dither",		WOOD_OA(dither),	FUNC_NULL },
	{"%f",	3, "di",		WOOD_OA(dither),	FUNC_NULL },
	{"%f",	1, "depth",		WOOD_O(depth),		FUNC_NULL },
	{"%f",	1, "de",		WOOD_O(depth),		FUNC_NULL },
	{"%f",	1, "dd",		WOOD_O(dd),		FUNC_NULL },
	{"%f",	1, "dz",		WOOD_O(dz),		FUNC_NULL },
	{"%f",	3, "rotation",		WOOD_OA(rot),		FUNC_NULL },
	{"%f",	3, "r",			WOOD_OA(rot),		FUNC_NULL },
d214 1
a214 1
	{"",	0, (char *)0,		0,			FUNC_NULL }
@


11.10
log
@ma_override to ma_color_valid
@
text
@d66 1
a66 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_wood.c,v 11.9 1998/09/22 01:29:56 mike Exp $ (ARL)";
d169 1
a169 1
#define WOOD_OA(m)	offsetofarray(struct wood_specific, m)
d289 1
a289 1
struct rt_vls		*matparm;
d316 2
a317 2
	RT_VLS_CHECK( matparm );
	GETSTRUCT( wd, wood_specific );
d367 1
a367 1
		rt_free( (char *)wd, "wood_specific" );
d377 1
a377 1
			rt_log ("wood_setup(%s):  dither is out of range.\n",
d384 1
a384 1
		rt_log ("wood_setup(%s):  Explicit vertex specfied without direction\n", rp->reg_name);
d389 1
a389 1
		rt_log ("wood_setup(%s):  Explicit direction specfied without vertex\n", rp->reg_name);
d457 2
a458 2
		wd->lt_rgb[i] *= rt_inv255;
		wd->dk_rgb[i] *= rt_inv255;
d487 1
a487 1
	mat_angles (xlate, V3ARGS (wd->rot));
d546 1
a546 1
/*		rt_log ("wood_free(%s):  Releasing region (at head).\n", wd->rp->reg_name); */
d548 1
a548 1
		rt_free ((char *)wd, "wood_specific");
d554 1
a554 1
/*			rt_log ("wood_free(%s):  Releasing region.\n", wd->rp->reg_name); */
d556 1
a556 1
			rt_free ((char *)wd, "wood_specific");
d561 1
a561 1
	rt_free ((char *)wd, "wood_specific");
d694 1
a694 1
	c = fabs (sin ((C / wd->spacing) * rt_pi));
d700 2
a701 2
	pq = cos (((wd->qd * wt) + wd->qp + wd->phase) * rt_degtorad);
	pp = cos (wd->phase * rt_degtorad);
@


11.9
log
@Moved optical shaders from rt/ to liboptical/
The only modifications involved moving and splitting
rt/material.h into h/shadefuncs.h and h/shadework.h,
and in changing the calling sequence to mlib_setup() in rt/material.c

Now the only shader function called directly by RT is
in liboptical/init.c: optical_shader_init().
It adds all the individual shaders to the "mfuncs" shader list.
@
text
@d66 1
a66 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rt/sh_wood.c,v 11.8 1998/06/30 22:54:19 mike Exp $ (ARL)";
d324 1
a324 1
	if (rp->reg_mater.ma_override) {
@


11.8
log
@Can't make "struct mfuncs" a CONST, because the forward link needs
to be filled in at runtime, and some compilers put CONST data into
read-only pages (like FreeBSD).
@
text
@d66 1
a66 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rt/sh_wood.c,v 11.7 1997/12/31 09:01:40 mike Exp $ (ARL)";
d78 4
a81 3
#include "./material.h"
#include "./mathtab.h"
#include "./rdebug.h"
@


11.7
log
@Required magic number to be first in mfunc table,
consistent with all other BRL-CAD magic numbers.
Required magic number to be initialized at compile time.
Added code to check the magic numbers.
Made the xxx_mfunc arrays CONST, so they can't get trashed by
runtime runaway pointer problems.
@
text
@d66 1
a66 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_wood.c,v 11.6 1997/11/25 22:16:43 butler Exp mike $ (ARL)";
d103 1
a103 1
CONST struct mfuncs wood_mfuncs[] = {
d114 1
a114 1
CONST struct mfuncs wood_mfuncs[] = {
@


11.6
log
@updated all shaders so that _setup had mfp and rtip parameters
@
text
@d66 1
a66 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_wood.c,v 11.5 1996/08/31 08:46:01 butler Exp butler $ (ARL)";
d103 2
a104 2
struct mfuncs wood_mfuncs[] = {
	{"wood",	0,		0,		MFI_HIT|MFI_UV|MFI_NORMAL,	0,
d107 1
a107 1
	{"w",		0,		0,		MFI_HIT|MFI_UV|MFI_NORMAL,	0,
d110 1
a110 1
	{(char *)0,	0,		0,		0,	0,
d114 2
a115 2
struct mfuncs wood_mfuncs[] = {
	{"wood",	0,		0, 		MFI_HIT|MFI_UV|MFI_NORMAL,	0,
d118 1
a118 1
	{"w",		0,		0,		MFI_HIT|MFI_UV|MFI_NORMAL,	0,
d121 1
a121 1
	{(char *)0,	0,		0,		0,	0,
@


11.5
log
@bu_struct_print
@
text
@d66 1
a66 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_wood.c,v 11.4 1996/08/31 08:29:28 butler Exp butler $ (ARL)";
d286 1
a286 1
HIDDEN int wood_setup( rp, matparm, dpp )
d290 2
@


11.4
log
@bu_struct_parse
@
text
@d66 1
a66 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_wood.c,v 11.3 1996/08/30 00:08:21 butler Exp butler $ (ARL)";
d524 1
a524 1
	bu_structprint(rp->reg_name, wood_parse, (char *)rp->reg_udata);
@


11.3
log
@structparse moved to libbu
@
text
@d66 1
a66 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_wood.c,v 11.2 1995/10/20 04:43:53 butler Exp butler $ (ARL)";
d363 1
a363 1
	if( bu_structparse( matparm, wood_parse, (char *)wd ) < 0 )  {
@


11.2
log
@edited mfuncs table to account for new "mf_flags" element in struct mfuncs.
@
text
@d66 1
a66 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_wood.c,v 11.1 1995/01/04 10:01:16 mike Rel4_4 butler $ (ARL)";
d95 2
a96 2
HIDDEN void	wood_V_set RT_ARGS((CONST struct structparse *, CONST char *, CONST char *, char *));
HIDDEN void	wood_D_set RT_ARGS((CONST struct structparse *, CONST char *, CONST char *, char *));
d183 1
a183 1
struct structparse wood_parse[] = {
d260 1
a260 1
CONST struct structparse *sdp;
d272 1
a272 1
CONST struct structparse *sdp;
d363 1
a363 1
	if( rt_structparse( matparm, wood_parse, (char *)wd ) < 0 )  {
d524 1
a524 1
	rt_structprint(rp->reg_name, wood_parse, (char *)rp->reg_udata);
@


11.1
log
@Release_4.4
@
text
@d66 1
a66 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_wood.c,v 1.6 94/11/21 19:11:41 stay Exp $ (ARL)";
d104 1
a104 1
	{"wood",	0,		0,		MFI_HIT|MFI_UV|MFI_NORMAL,
d107 1
a107 1
	{"w",		0,		0,		MFI_HIT|MFI_UV|MFI_NORMAL,
d110 1
a110 1
	{(char *)0,	0,		0,		0,
d115 1
a115 1
	{"wood",	0,		0, 		MFI_HIT|MFI_UV|MFI_NORMAL,
d118 1
a118 1
	{"w",		0,		0,		MFI_HIT|MFI_UV|MFI_NORMAL,
d121 1
a121 1
	{(char *)0,	0,		0,		0,
@


1.6
log
@fixed decleration by using RT_ARGS
.,
@
text
@d66 1
a66 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_wood.c,v 1.5 1994/11/05 03:00:44 mike Exp stay $ (ARL)";
@


1.5
log
@Irix 6
@
text
@d66 1
a66 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_wood.c,v 1.4 94/11/01 07:17:12 butler Exp Locker: mike $ (ARL)";
d93 1
a93 1
HIDDEN void	wood_free( char * );
d95 2
a96 2
HIDDEN void	wood_V_set (CONST struct structparse *, CONST char *, CONST char *, char *);
HIDDEN void	wood_D_set (CONST struct structparse *, CONST char *, CONST char *, char *);
d160 1
a160 1
HIDDEN void	wood_setup_2 (struct wood_specific *);
@


1.4
log
@fixed function prototypes
@
text
@d66 1
a66 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_wood.c,v 1.3 1994/10/31 22:46:05 mike Exp butler $ (ARL)";
a237 1
	register int	i,j,k;
a292 4
	register double c,A,B,C;
	mat_t	xlate;
	vect_t	g, h, a_vertex, a_dir, corner, max_V;
	double	rt_45 = 45 * rt_degtorad;
d413 1
a413 1
		register vect_t			c_min, c_max;
d496 5
a500 4
			a_vertex[3] = ((wd->b_max[3] - wd->b_min[3]) * 
					(rand0to1(resp->re_randptr) * wd->dz)) + wd->b_min[3];
			a_dir[3]    = ((wd->b_max[3] - wd->b_min[3]) * 
					(rand0to1(resp->re_randptr) * wd->dz)) + wd->b_min[3];
d653 1
a653 1
	double	a, c, A, B, C;
@


1.3
log
@V2 from Bill Laut.
@
text
@d66 1
a66 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_wood.c,v 1.2 94/10/31 22:18:20 mike Exp Locker: mike $ (ARL)";
d95 2
a96 2
HIDDEN void	wood_V_set (struct structparse *, char *, char *, char *);
HIDDEN void	wood_D_set (struct structparse *, char *, char *, char *);
@


1.2
log
@Minor compilation nits.
@
text
@d66 1
a66 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
d83 5
d92 2
a93 1
HIDDEN void	wood_print(), wood_free();
d104 2
a105 2
	"wood",		0,		0,		MFI_HIT|MFI_UV|MFI_NORMAL,
	wood_init,	wood_setup,	wood_render,	wood_print,	wood_free,
d107 2
a108 2
	"w",		0,		0,		MFI_HIT|MFI_UV|MFI_NORMAL,
	wood_init,	wood_setup,	wood_render,	wood_print,	wood_free,
d110 2
a111 2
	(char *)0,	0,		0,		0,
	0,		0,		0,		0,		0
d115 2
a116 2
	"wood",		0,		0, 		MFI_HIT|MFI_UV|MFI_NORMAL,
	wood_setup,	wood_render,	wood_print,	wood_free,
d118 2
a119 2
	"w",		0,		0,		MFI_HIT|MFI_UV|MFI_NORMAL,
	wood_setup,	wood_render,	wood_print,	wood_free,
d121 2
a122 2
	(char *)0,	0,		0,		0,
	0,		0,		0,		0
d132 1
d136 13
a148 10
	double			lt_rgb[3];
	double			dk_rgb[3];
	double			depth;
	double			spacing;
	double			phase;
	double			dd;
	double			qd;
	double			dz;
	double			qp;
	double			dither[3];
d188 3
d197 2
a227 1
static	double	wood_n[TPOINTS+1][TPOINTS+1][TPOINTS+1];
a238 2
	extern struct resource	rt_uniresource;
	register struct resource	*resp = &rt_uniresource;
a240 12
	 *	Initialize the noise table
	 */

	for (i=0; i<TPOINTS+1; i++) {
		for (j=0; j<TPOINTS+1; j++) {
			for (k=0; k<TPOINTS+1; k++) {
				wood_n[i][j][k] = rand0to1 (resp->re_randptr);
				}
			}
		}

	/*
d341 1
d344 3
d402 7
d425 2
a426 2
		VMOVE (c_min, wd->b_min);
		VMOVE (c_max, wd->b_max);
d428 4
a431 13
		if ((wc = Wood_Chain) == WOOD_NULL)
			Wood_Chain = wd;
		   else {
			while (wc != WOOD_NULL) {
				if (wc->ident == wd->ident) {
					VMIN (c_min, wc->b_min);
					VMAX (c_max, wc->b_max);
					}
				if (wc->forw == WOOD_NULL) {
					wc->forw = wd;
					wc       = WOOD_NULL;
					}
				   else wc = wc->forw;
d533 4
d541 22
a562 1
	rt_free( cp, "wood_specific" );
d574 1
a574 1
HIDDEN double wood_noise (x, y, z, mp)
d576 1
a576 1
struct wood_specific *mp;
d580 1
a580 1
	double	n1, n2, noise1, noise2, noise;
d589 4
a592 2
	n1     = (1 - xr) * wood_n[xi][yi][zi] + xr * wood_n[xi + 1][yi][zi];
	n2     = (1 - xr) * wood_n[xi][yi + 1][zi] + xr * wood_n[xi + 1][yi + 1][zi];
d595 4
a598 2
	n1     = (1 - xr) * wood_n[xi][yi][zi + 1] + xr * wood_n[xi + 1][yi][zi + 1];
	n2     = (1 - xr) * wood_n[xi][yi + 1][zi + 1] + xr * wood_n[xi + 1][yi + 1][zi + 1];
d601 2
a602 1
	noise  = (1 - zr) * noise1 + zr * noise2;
d607 1
a607 1
HIDDEN double wood_turb (x, y, z, mp)
d609 1
a609 1
struct wood_specific *mp;
d611 2
a612 2
	double	turb, temp;
	double	scale;
d614 2
a615 3
	turb = 0;
	scale = 1.0;
	temp = 0.0;
d617 16
a632 4
	while (scale > 0.005 ) {
		temp = ( ( wood_noise( x * scale, y * scale, z * scale, mp ) - 0.5 ) * scale );
		turb += ( temp > 0 ) ? temp : - temp;
		scale /= 2.0;
@


1.1
log
@Initial revision
@
text
@d65 3
d69 2
d75 1
a82 8
 *	Sundry external references
 */

extern	double	rt_inv255;
extern	double	mat_degtorad;
extern	double	mat_pi;

/*
d297 1
a297 1
	double	rt_45 = 45 * mat_degtorad;
d603 1
a603 1
HIDDEN int wood_render( ap, pp, swp, dp )
d605 1
a605 1
struct partition	*pp;
d658 2
a659 2
	pq = cos (((wd->qd * wt) + wd->qp + wd->phase) * mat_degtorad);
	pp = cos (wd->phase * mat_degtorad);
@
