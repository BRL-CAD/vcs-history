head	11.45;
access;
symbols
	ansi-20040405-merged:11.40.2.2
	postmerge-20040405-ansi:11.43
	premerge-20040404-ansi:11.42
	postmerge-autoconf:11.42
	autoconf-freeze:11.41.4.2
	premerge-autoconf:11.42
	ansi-20040316-freeze:11.40.2.1
	postmerge-20040315-windows:11.42
	premerge-20040315-windows:11.42
	windows-20040315-freeze:11.40.4.1
	autoconf-20031203:11.41
	autoconf-20031202:11.41
	autoconf-branch:11.41.0.4
	phong-branch:11.41.0.2
	photonmap-branch:11.40.0.6
	rel-6-1-DP:11.40
	windows-branch:11.40.0.4
	rel-6-0-2:11.38
	ansi-branch:11.40.0.2
	rel-6-0-1-branch:11.38.0.2
	hartley-6-0-post:11.39
	hartley-6-0-pre:11.38
	rel-6-0-1:11.38
	rel-6-0:11.37
	rel-5-4:11.30
	offsite-5-3-pre:11.36
	rel-5-3:11.30
	rel-5-2:11.30
	rel-5-1-branch:11.30.0.2
	rel-5-1:11.30
	rel-5-0:11.21
	rel-5-0-beta:11.19
	rel-4-5:11.15
	ctj-4-5-post:11.9
	ctj-4-5-pre:11.9
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.2
	rel-1-10:4.1;
locks; strict;
comment	@ * @;


11.45
date	2004.05.21.18.07.27;	author morrison;	state dead;
branches;
next	11.44;

11.44
date	2004.05.10.15.30.45;	author erikg;	state Exp;
branches;
next	11.43;

11.43
date	2004.04.05.07.43.37;	author morrison;	state Exp;
branches;
next	11.42;

11.42
date	2004.02.02.17.39.14;	author morrison;	state Exp;
branches;
next	11.41;

11.41
date	2003.08.27.19.17.51;	author justin;	state Exp;
branches
	11.41.2.1
	11.41.4.1;
next	11.40;

11.40
date	2002.08.20.17.07.51;	author jra;	state Exp;
branches
	11.40.2.1
	11.40.4.1
	11.40.6.1;
next	11.39;

11.39
date	2002.08.15.20.55.04;	author hartley;	state Exp;
branches;
next	11.38;

11.38
date	2002.07.16.19.38.38;	author morrison;	state Exp;
branches;
next	11.37;

11.37
date	2001.04.20.22.29.33;	author morrison;	state Exp;
branches;
next	11.36;

11.36
date	2000.10.19.19.19.45;	author butler;	state Exp;
branches;
next	11.35;

11.35
date	2000.09.11.06.38.01;	author cjohnson;	state Exp;
branches;
next	11.34;

11.34
date	2000.09.11.05.56.12;	author cjohnson;	state Exp;
branches;
next	11.33;

11.33
date	2000.09.06.00.23.55;	author mike;	state Exp;
branches;
next	11.32;

11.32
date	2000.08.17.03.11.59;	author mike;	state Exp;
branches;
next	11.31;

11.31
date	2000.07.25.16.40.38;	author butler;	state Exp;
branches;
next	11.30;

11.30
date	2000.03.03.21.23.28;	author mike;	state Exp;
branches;
next	11.29;

11.29
date	2000.03.03.03.29.06;	author mike;	state Exp;
branches;
next	11.28;

11.28
date	2000.03.03.03.04.02;	author mike;	state Exp;
branches;
next	11.27;

11.27
date	2000.02.19.21.05.02;	author butler;	state Exp;
branches;
next	11.26;

11.26
date	2000.02.03.06.34.45;	author butler;	state Exp;
branches;
next	11.25;

11.25
date	2000.01.21.21.43.34;	author butler;	state Exp;
branches;
next	11.24;

11.24
date	99.12.30.16.07.16;	author jra;	state Exp;
branches;
next	11.23;

11.23
date	99.12.04.00.17.25;	author mike;	state Exp;
branches;
next	11.22;

11.22
date	99.10.30.03.06.24;	author butler;	state Exp;
branches;
next	11.21;

11.21
date	99.07.02.22.20.41;	author mike;	state Exp;
branches;
next	11.20;

11.20
date	99.07.01.20.08.47;	author mike;	state Exp;
branches;
next	11.19;

11.19
date	98.12.12.07.23.05;	author mike;	state Exp;
branches;
next	11.18;

11.18
date	98.12.11.06.00.33;	author mike;	state Exp;
branches;
next	11.17;

11.17
date	98.09.22.01.29.55;	author mike;	state Exp;
branches;
next	11.16;

11.16
date	98.06.30.22.54.18;	author mike;	state Exp;
branches;
next	11.15;

11.15
date	97.12.31.09.01.40;	author mike;	state Exp;
branches;
next	11.14;

11.14
date	97.12.31.08.15.45;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	97.12.16.06.25.54;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	97.12.09.04.45.30;	author butler;	state Exp;
branches;
next	11.11;

11.11
date	97.11.25.22.18.44;	author butler;	state Exp;
branches;
next	11.10;

11.10
date	97.11.25.22.16.43;	author butler;	state Exp;
branches;
next	11.9;

11.9
date	97.06.05.05.05.04;	author butler;	state Exp;
branches;
next	11.8;

11.8
date	96.08.31.08.46.01;	author butler;	state Exp;
branches;
next	11.7;

11.7
date	96.08.31.08.29.28;	author butler;	state Exp;
branches;
next	11.6;

11.6
date	96.08.30.00.08.21;	author butler;	state Exp;
branches;
next	11.5;

11.5
date	96.05.09.03.25.47;	author butler;	state Exp;
branches;
next	11.4;

11.4
date	96.05.07.19.26.36;	author jra;	state Exp;
branches;
next	11.3;

11.3
date	95.12.11.20.22.45;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	95.10.20.04.43.53;	author butler;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.01.08;	author mike;	state Rel4_4;
branches;
next	10.2;

10.2
date	94.08.11.02.25.41;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.42.10;	author mike;	state Rel4_0;
branches;
next	9.8;

9.8
date	91.09.27.16.02.20;	author mike;	state Exp;
branches;
next	9.7;

9.7
date	91.07.06.00.35.20;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	91.02.17.20.15.53;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	91.01.05.03.09.13;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	90.12.12.16.35.07;	author butler;	state Exp;
branches;
next	9.3;

9.3
date	90.12.08.08.58.11;	author butler;	state Exp;
branches;
next	9.2;

9.2
date	90.11.01.11.18.10;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.59.36;	author mike;	state Rel3_5;
branches;
next	8.4;

8.4
date	89.04.30.20.40.06;	author mike;	state Exp;
branches;
next	8.3;

8.3
date	89.04.04.05.02.02;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	88.12.27.16.35.03;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.32.57;	author mike;	state Rel3_0;
branches;
next	7.5;

7.5
date	88.08.20.05.07.54;	author mike;	state Exp;
branches;
next	7.4;

7.4
date	88.05.14.02.28.18;	author mike;	state Exp;
branches;
next	7.3;

7.3
date	88.03.19.02.33.28;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	88.01.26.05.30.03;	author phil;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.54.18;	author mike;	state Rel;
branches;
next	6.2;

6.2
date	87.09.10.07.14.36;	author mike;	state Exp;
branches;
next	6.1;

6.1
date	87.07.11.07.58.48;	author mike;	state Rel;
branches;
next	5.6;

5.6
date	87.07.06.15.26.37;	author mike;	state Exp;
branches;
next	5.5;

5.5
date	87.07.02.02.53.47;	author mike;	state Exp;
branches;
next	5.4;

5.4
date	87.06.27.06.46.08;	author phil;	state Exp;
branches;
next	5.3;

5.3
date	87.06.27.03.45.57;	author mike;	state Exp;
branches;
next	5.2;

5.2
date	87.06.26.05.57.56;	author mike;	state Exp;
branches;
next	5.1;

5.1
date	87.06.24.22.14.50;	author mike;	state Rel;
branches;
next	4.8;

4.8
date	87.06.13.03.19.45;	author mike;	state Exp;
branches;
next	4.7;

4.7
date	87.06.13.01.38.51;	author mike;	state Exp;
branches;
next	4.6;

4.6
date	87.04.10.22.49.26;	author mike;	state Exp;
branches;
next	4.5;

4.5
date	87.04.01.04.51.36;	author mike;	state Exp;
branches;
next	4.4;

4.4
date	87.03.23.23.48.18;	author mike;	state Exp;
branches;
next	4.3;

4.3
date	87.03.17.20.19.00;	author mike;	state Exp;
branches;
next	4.2;

4.2
date	87.02.13.00.01.38;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.48.29;	author mike;	state Rel1;
branches;
next	1.19;

1.19
date	86.12.24.08.23.29;	author mike;	state Exp;
branches;
next	1.18;

1.18
date	86.12.18.16.01.46;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	86.12.14.17.54.26;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	86.12.10.03.26.08;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	86.11.10.21.56.50;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	86.11.07.02.46.11;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	86.11.07.01.46.23;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	86.10.26.17.07.02;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	86.08.13.11.00.45;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	86.08.12.05.50.45;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	86.08.06.19.59.58;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	86.07.31.08.28.16;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	86.07.30.03.56.17;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	86.07.29.20.22.07;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	86.07.24.06.05.05;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	86.07.22.03.53.29;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	86.07.19.04.38.49;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	86.07.17.18.33.01;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	86.06.11.00.13.54;	author mike;	state Exp;
branches;
next	;

11.40.2.1
date	2002.09.19.18.01.25;	author morrison;	state Exp;
branches;
next	11.40.2.2;

11.40.2.2
date	2004.03.17.21.18.32;	author morrison;	state Exp;
branches;
next	;

11.40.4.1
date	2004.03.11.23.43.02;	author morrison;	state Exp;
branches;
next	;

11.40.6.1
date	2003.08.07.22.15.32;	author justin;	state Exp;
branches;
next	11.40.6.2;

11.40.6.2
date	2003.08.12.00.47.44;	author justin;	state Exp;
branches;
next	11.40.6.3;

11.40.6.3
date	2003.08.12.03.43.36;	author justin;	state Exp;
branches;
next	11.40.6.4;

11.40.6.4
date	2003.08.12.22.48.00;	author justin;	state Exp;
branches;
next	11.40.6.5;

11.40.6.5
date	2003.08.12.23.34.57;	author justin;	state Exp;
branches;
next	11.40.6.6;

11.40.6.6
date	2003.08.13.22.09.23;	author justin;	state Exp;
branches;
next	11.40.6.7;

11.40.6.7
date	2003.08.24.23.30.25;	author justin;	state Exp;
branches;
next	;

11.41.2.1
date	2003.09.10.22.08.27;	author butler;	state Exp;
branches;
next	11.41.2.2;

11.41.2.2
date	2003.09.13.14.40.33;	author butler;	state Exp;
branches;
next	11.41.2.3;

11.41.2.3
date	2003.09.13.17.51.26;	author butler;	state Exp;
branches;
next	11.41.2.4;

11.41.2.4
date	2003.09.13.20.19.02;	author butler;	state Exp;
branches;
next	;

11.41.4.1
date	2004.02.12.18.38.49;	author erikg;	state Exp;
branches;
next	11.41.4.2;

11.41.4.2
date	2004.03.15.14.07.13;	author erikg;	state Exp;
branches;
next	;


desc
@Routines to implement Phong shading, yielding plastic-looking
objects.  Also handles reflection and refraction.
@


11.45
log
@moved to src/
@
text
@/*
 *			P L A S T I C
 *
 *  Notes -
 *	The normals on all surfaces point OUT of the solid.
 *	The incomming light rays point IN.  Thus the sign change.
 *
 *  Authors -
 *	Michael John Muuss
 *	Gary S. Moss
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" license agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1998-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/liboptical/sh_plastic.c,v 11.44 2004/05/10 15:30:45 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#include "machine.h"
#include "vmath.h"
#include "mater.h"
#include "raytrace.h"
#include "shadefuncs.h"
#include "shadework.h"
#include "rtprivate.h"
#include "light.h"
#if RT_MULTISPECTRAL
#include "spectrum.h"
#endif
#include "plastic.h"
#include "photonmap.h"

extern int rr_render(struct application	*ap,
		     struct partition	*pp,
		     struct shadework   *swp);
/* Fast approximation to specular term */
#define PHAST_PHONG 1	/* See Graphics Gems IV pg 387 */

/* from view.c */
extern double AmbientIntensity;

#if RT_MULTISPECTRAL
extern const struct bn_table	*spectrum;	/* from rttherm/viewtherm.c */
#endif

struct bu_structparse phong_parse[] = {
	{"%d",	1, "shine",		PL_O(shine),		BU_STRUCTPARSE_FUNC_NULL },
	{"%d",	1, "sh",		PL_O(shine),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "specular",		PL_O(wgt_specular),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "sp",		PL_O(wgt_specular),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "diffuse",		PL_O(wgt_diffuse),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "di",		PL_O(wgt_diffuse),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "transmit",		PL_O(transmit),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "tr",		PL_O(transmit),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "reflect",		PL_O(reflect),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "re",		PL_O(reflect),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "ri",		PL_O(refrac_index),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "extinction_per_meter", PL_O(extinction),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "extinction",	PL_O(extinction),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "ex",		PL_O(extinction),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	3, "emission",		PL_O(emission),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	3, "em",		PL_O(emission),		BU_STRUCTPARSE_FUNC_NULL },
	{"",	0, (char *)0,		0,			BU_STRUCTPARSE_FUNC_NULL }
};

HIDDEN int phong_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip), mirror_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip), glass_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip);
HIDDEN int phong_render(register struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
HIDDEN void	phong_print(register struct region *rp, char *dp);
HIDDEN void	phong_free(char *cp);

/* This can't be const, so the forward link can be written later */
struct mfuncs phg_mfuncs[] = {
	{MF_MAGIC,	"default",	0,		MFI_NORMAL,	0,
	phong_setup,	phong_render,	phong_print,	phong_free },

	{MF_MAGIC,	"phong",	0,		MFI_NORMAL,	0,
	phong_setup,	phong_render,	phong_print,	phong_free },

	{MF_MAGIC,	"plastic",	0,		MFI_NORMAL,	0,
	phong_setup,	phong_render,	phong_print,	phong_free },

	{MF_MAGIC,	"mirror",	0,		MFI_NORMAL,	0,
	mirror_setup,	phong_render,	phong_print,	phong_free },

	{MF_MAGIC,	"glass",	0,		MFI_NORMAL,	0,
	glass_setup,	phong_render,	phong_print,	phong_free },

	{0,		(char *)0,	0,		0,	0,
	0,		0,		0,		0 }
};

#ifndef PHAST_PHONG
extern double phg_ipow();
#endif

#define RI_AIR		1.0    /* Refractive index of air.		*/

/*
 *			P H O N G _ S E T U P
 */
HIDDEN int
phong_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip)
                           
             	         
    	      
                             
                                /* New since 4.4 release */
{
	register struct phong_specific *pp;

	BU_CK_VLS( matparm );
	BU_GETSTRUCT( pp, phong_specific );
	*dpp = (char *)pp;

	pp->magic = PL_MAGIC;
	pp->shine = 10;
	pp->wgt_specular = 0.7;
	pp->wgt_diffuse = 0.3;
	pp->transmit = 0.0;
	pp->reflect = 0.0;
	pp->refrac_index = RI_AIR;
	pp->extinction = 0.0;
	pp->mfp = mfp;

	if (bu_struct_parse( matparm, phong_parse, (char *)pp ) < 0 )  {
		bu_free( (char *)pp, "phong_specific" );
		return(-1);
	}

	if (pp->transmit > 0 )
		rp->reg_transmit = 1;
	return(1);
}

/*
 *			M I R R O R _ S E T U P
 */
HIDDEN int
mirror_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip)
                           
             	         
    	      
                             
                                /* New since 4.4 release */
{
	register struct phong_specific *pp;

	BU_CK_VLS( matparm );
	BU_GETSTRUCT( pp, phong_specific );
	*dpp = (char *)pp;

	pp->magic = PL_MAGIC;
	pp->shine = 4;
	pp->wgt_specular = 0.6;
	pp->wgt_diffuse = 0.4;
	pp->transmit = 0.0;
	pp->reflect = 0.75;
	pp->refrac_index = 1.65;
	pp->extinction = 0.0;
	pp->mfp = mfp;

	if (bu_struct_parse( matparm, phong_parse, (char *)pp ) < 0 )  {
		bu_free( (char *)pp, "phong_specific" );
		return(-1);
	}

	if (pp->transmit > 0 )
		rp->reg_transmit = 1;
	return(1);
}

/*
 *			G L A S S _ S E T U P
 */
HIDDEN int
glass_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip)
                           
             	         
    	      
                             
                                /* New since 4.4 release */
{
	register struct phong_specific *pp;

	BU_CK_VLS( matparm );
	BU_GETSTRUCT( pp, phong_specific );
	*dpp = (char *)pp;

	pp->magic = PL_MAGIC;
	pp->shine = 4;
	pp->wgt_specular = 0.7;
	pp->wgt_diffuse = 0.3;
	pp->transmit = 0.8;
	pp->reflect = 0.1;
	/* leaving 0.1 for diffuse/specular */
	pp->refrac_index = 1.65;
	pp->extinction = 0.0;
	pp->mfp = mfp;

	if (bu_struct_parse( matparm, phong_parse, (char *)pp ) < 0 )  {
		bu_free( (char *)pp, "phong_specific" );
		return(-1);
	}

	if (pp->transmit > 0 )
		rp->reg_transmit = 1;
	return(1);
}

/*
 *			P H O N G _ P R I N T
 */
HIDDEN void
phong_print(register struct region *rp, char *dp)
{
	bu_struct_print(rp->reg_name, phong_parse, (char *)dp);
}

/*
 *			P H O N G _ F R E E
 */
HIDDEN void
phong_free(char *cp)
{
	bu_free( cp, "phong_specific" );
}


/*
 *			P H O N G _ R E N D E R
 *
	Color pixel based on the energy of a point light source (Eps)
	plus some diffuse illumination (Epd) reflected from the point
	<x,y> :

				E = Epd + Eps		(1)

	The energy reflected from diffuse illumination is the product
	of the reflectance coefficient at point P (Rp) and the diffuse
	illumination (Id) :

				Epd = Rp * Id		(2)

	The energy reflected from the point light source is calculated
	by the sum of the diffuse reflectance (Rd) and the specular
	reflectance (Rs), multiplied by the intensity of the light
	source (Ips) :

				Eps = (Rd + Rs) * Ips	(3)

	The diffuse reflectance is calculated by the product of the
	reflectance coefficient (Rp) and the cosine of the angle of
	incidence (I) :

				Rd = Rp * cos(I)	(4)

	The specular reflectance is calculated by the product of the
	specular reflectance coeffient and (the cosine of the angle (S)
	raised to the nth power) :

				Rs = W(I) * cos(S)**n	(5)

	Where,
		I is the angle of incidence.
		S is the angle between the reflected ray and the observer.
		W returns the specular reflection coefficient as a function
	of the angle of incidence.
		n (roughly 1 to 10) represents the shininess of the surface.
 *
	This is the heart of the lighting model which is based on a model
	developed by Bui-Tuong Phong, [see Wm M. Newman and R. F. Sproull,
	"Principles of Interactive Computer Graphics", 	McGraw-Hill, 1979]

	Er = Ra(m)*cos(Ia) + Rd(m)*cos(I1) + W(I1,m)*cos(s)^^n
	where,
 
	Er	is the energy reflected in the observer's direction.
	Ra	is the diffuse reflectance coefficient at the point
		of intersection due to ambient lighting.
	Ia	is the angle of incidence associated with the ambient
		light source (angle between ray direction (negated) and
		surface normal).
	Rd	is the diffuse reflectance coefficient at the point
		of intersection due to primary lighting.
	I1	is the angle of incidence associated with the primary
		light source (angle between light source direction and
		surface normal).
	m	is the material identification code.
	W	is the specular reflectance coefficient,
		a function of the angle of incidence, range 0.0 to 1.0,
		for the material.
	s	is the angle between the reflected ray and the observer.
`	n	'Shininess' of the material,  range 1 to 10.
 */
HIDDEN int
phong_render(register struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
{
	register struct light_specific *lp;
#if !RT_MULTISPECTRAL
	register	fastf_t	*intensity;
#endif
	register	fastf_t	refl;
	register	fastf_t	*to_light;
	register	int	i;
	register	fastf_t	cosine;
	vect_t			work,color;
	vect_t			reflected;
	point_t			pt;
	fastf_t			dist;

#if RT_MULTISPECTRAL
	struct bn_tabdata	*ms_matcolor = BN_TABDATA_NULL;
#else
	point_t	matcolor;		/* Material color */
#endif
	struct phong_specific *ps =
		(struct phong_specific *)dp;

	if (ps->magic != PL_MAGIC )  bu_log("phong_render: bad magic\n");

	if (rdebug&RDEBUG_SHADE)
		bu_struct_print( "phong_render", phong_parse, (char *)ps );

	swp->sw_transmit = ps->transmit;
	swp->sw_reflect = ps->reflect;
	swp->sw_refrac_index = ps->refrac_index;
	swp->sw_extinction = ps->extinction;
#if SW_SET_TRANSMIT
	if (swp->sw_phong_set_vector & SW_SET_TRANSMIT) swp->sw_transmit = swp->sw_phong_transmit;
	if (swp->sw_phong_set_vector & SW_SET_REFLECT) swp->sw_reflect = swp->sw_phong_reflect;
	if (swp->sw_phong_set_vector & SW_SET_REFRAC_INDEX) swp->sw_refrac_index = swp->sw_phong_ri;
	if (swp->sw_phong_set_vector & SW_SET_EXTINCTION) swp->sw_extinction = swp->sw_phong_extinction;
#endif /* SW_SET_TRANSMIT */
	if (swp->sw_xmitonly ) {
		if (swp->sw_xmitonly > 1 )
			return(1);	/* done -- wanted parameters only */
		if (swp->sw_reflect > 0 || swp->sw_transmit > 0 ) {
			if (rdebug&RDEBUG_SHADE)
				bu_log("calling rr_render from phong, sw_xmitonly\n");
			(void)rr_render( ap, pp, swp );
		}
		return(1);	/* done */
	}


#if RT_MULTISPECTRAL
	ms_matcolor = bn_tabdata_dup( swp->msw_color );
#else
	VMOVE( matcolor, swp->sw_color );
#endif

/* Photon Mapping */
#ifndef RT_MULTISPECTRAL
color[0]= swp -> sw_color[0];
color[1]= swp -> sw_color[1];
color[2]= swp -> sw_color[2];
#endif

if (!PM_Visualize) {
	/* Diffuse reflectance from "Ambient" light source (at eye) */
	if ((cosine = -VDOT( swp->sw_hit.hit_normal, ap->a_ray.r_dir )) > 0.0 )  {
		if (cosine > 1.00001 )  {
			bu_log("cosAmb=1+%g %s surfno=%d (x%d,y%d,lvl%d)\n",
				cosine-1,
				pp->pt_inseg->seg_stp->st_dp->d_namep,
				swp->sw_hit.hit_surfno,
				ap->a_x, ap->a_y, ap->a_level);
			VPRINT(" normal", swp->sw_hit.hit_normal);
			VPRINT(" r_dir ", ap->a_ray.r_dir);
			cosine = 1;
		}
#if SW_SET_TRANSMIT
		if (swp->sw_phong_set_vector & SW_SET_AMBIENT) {
			cosine *= swp->sw_phong_ambient;
		} else {
			cosine *= AmbientIntensity;
		}
#else
		cosine *= AmbientIntensity;
#endif
#if RT_MULTISPECTRAL
		bn_tabdata_scale( swp->msw_color, ms_matcolor, cosine );
#else
		VSCALE( swp->sw_color, matcolor, cosine );
#endif
	} else {
#if RT_MULTISPECTRAL
		bn_tabdata_constval( swp->msw_color, 0.0 );
#else
		VSETALL( swp->sw_color, 0 );
#endif
	}

	/* Emission.  0..1 is normal range, -1..0 sucks light out, like OpenGL */
#if RT_MULTISPECTRAL
	{
		float emission[3];
		struct bn_tabdata	*ms_emission = BN_TABDATA_NULL;
		VMOVE(emission,ps->emission);
#if SW_SET_TRANSMIT
		if (swp->sw_phong_set_vector & SW_SET_EMISSION) {
			VSETALL(emission, swp->sw_phong_emission);
		}
#endif
		/* XXX Really should get a curve at prep, not expand RGB samples */
		BN_GET_TABDATA( ms_emission, spectrum );
		rt_spect_reflectance_rgb( ms_emission, emission );
		bn_tabdata_add( swp->msw_color, swp->msw_color, ms_emission );
		bn_tabdata_free( ms_emission );
	}
#else
#if SW_SET_TRANSMIT
	if (swp->sw_phong_set_vector & SW_SET_EMISSION) {
		vect_t tmp;
		VSETALL(tmp,swp->sw_phong_emission);
		VADD2( swp->sw_color, swp->sw_color, tmp);
	} else {
		VADD2( swp->sw_color, swp->sw_color, ps->emission );
	}
#else
	VADD2( swp->sw_color, swp->sw_color, ps->emission );
#endif /* SW_SET_TRANSMIT */
#endif

	/* With the advent of procedural shaders, the caller can no longer
	 * provide us reliable light visibility information.  The hit point
	 * may have been changed by another shader in a stack.  There is no
	 * way that anyone else can tell us whether lights are visible.
	 */
	light_obs(ap, swp, ps->mfp->mf_inputs);

	/* Consider effects of each light source */
	for( i=ap->a_rt_i->rti_nlights-1; i>=0; i-- )  {

		if ((lp = (struct light_specific *)swp->sw_visible[i]) == LIGHT_NULL )
			continue;

		if( rdebug & RDEBUG_LIGHT )  {
			bu_log("phong_render light=%s lightfract=%g\n",
				lp->lt_name, swp->sw_lightfract[i] );
		}
	
		/* Light is not shadowed -- add this contribution */
#if !RT_MULTISPECTRAL
		intensity = swp->sw_intensity+3*i;
#endif
		to_light = swp->sw_tolight+3*i;

		/* Diffuse reflectance from this light source. */
		if ((cosine=VDOT(swp->sw_hit.hit_normal, to_light)) > 0.0 )  {
			if (cosine > 1.00001 )  {
				bu_log("cosI=1+%g (x%d,y%d,lvl%d)\n", cosine-1,
					ap->a_x, ap->a_y, ap->a_level);
				cosine = 1;
			}
			/* Get Obj Hit Point For Attenuation */
                        if (pp && PM_Activated) {
				VJOIN1(pt, ap -> a_ray.r_pt, pp -> pt_inhit -> hit_dist, ap -> a_ray.r_dir)
				dist= sqrt((pt[0]-lp -> lt_pos[0])*(pt[0]-lp -> lt_pos[0]) + (pt[1]-lp -> lt_pos[1])*(pt[1]-lp -> lt_pos[1]) + (pt[2]-lp -> lt_pos[2])*(pt[2]-lp -> lt_pos[2]))/1000.0;
				dist= (1.0/(0.1 + 1.0*dist + 0.01*dist*dist));
				refl= dist * ps -> wgt_diffuse * cosine * swp -> sw_lightfract[i] * lp -> lt_intensity;
/*				bu_log("pt: [%.3f][%.3f,%.3f,%.3f]\n",dist,pt[0],pt[1],pt[2]);*/
                        } else {
				refl= ps -> wgt_diffuse * swp -> sw_lightfract[i] * cosine * lp -> lt_fraction;
			}

#if RT_MULTISPECTRAL
			bn_tabdata_incr_mul3_scale( swp->msw_color,
				lp->lt_spectrum,
				swp->msw_intensity[i],
				ms_matcolor,
				refl );
#else
			VELMUL3( work, matcolor, lp->lt_color, intensity );
			VJOIN1( swp->sw_color, swp->sw_color, refl, work );
#endif
		}

		/* Calculate specular reflectance.
		 *	Reflected ray = (2 * cos(i) * Normal) - Incident ray.
		 * 	Cos(s) = Reflected ray DOT Incident ray.
		 */
		cosine *= 2;
		VSCALE( work, swp->sw_hit.hit_normal, cosine );
		VSUB2( reflected, work, to_light );
		if ((cosine = -VDOT( reflected, ap->a_ray.r_dir )) > 0 )  {
			if (cosine > 1.00001 )  {
				bu_log("cosS=1+%g (x%d,y%d,lvl%d)\n", cosine-1,
					ap->a_x, ap->a_y, ap->a_level);
				cosine = 1;
			}
			refl = ps->wgt_specular * swp->sw_lightfract[i] *
				lp->lt_fraction *
#ifdef PHAST_PHONG
				/* It is unnecessary to compute the actual
				 * exponential here since phong is just a
				 * gross hack.  We approximate re:
				 *  Graphics Gems IV "A Fast Alternative to
				 *  Phong's Specular Model" Pg 385
				 */
				cosine /
				(ps->shine - ps->shine*cosine + cosine);
#else
				phg_ipow(cosine, ps->shine);
#endif /* PHAST_PHONG */
#if RT_MULTISPECTRAL
			bn_tabdata_incr_mul2_scale( swp->msw_color,
				lp->lt_spectrum,
				swp->msw_intensity[i],
				refl );
#else
			VELMUL( work, lp->lt_color, intensity );
			VJOIN1( swp->sw_color, swp->sw_color, refl, work );
#endif
		}
	}

#ifndef RT_MULTISPECTRAL
  if (PM_Activated) {
    IrradianceEstimate(ap, work, swp -> sw_hit.hit_point, swp -> sw_hit.hit_normal, 100, 100);
    VELMUL(work, work, color);
    VADD2(swp -> sw_color, work, swp -> sw_color);
    if (swp -> sw_color[0] > 1.0) swp -> sw_color[0]= 1.0;
    if (swp -> sw_color[1] > 1.0) swp -> sw_color[1]= 1.0;
    if (swp -> sw_color[2] > 1.0) swp -> sw_color[2]= 1.0;
  }
#endif

} else {

#ifndef RT_MULTISPECTRAL
  if (PM_Activated) {
/*  IrradianceEstimate(work, swp -> sw_hit.hit_point, swp -> sw_hit.hit_normal, 100, 100);
  VELMUL(swp -> sw_color, work, color);*/
    IrradianceEstimate(ap, swp -> sw_color, swp -> sw_hit.hit_point, swp -> sw_hit.hit_normal, 100, 100);
    if (swp -> sw_color[0] > 1.0) swp -> sw_color[0]= 1.0;
    if (swp -> sw_color[1] > 1.0) swp -> sw_color[1]= 1.0;
    if (swp -> sw_color[2] > 1.0) swp -> sw_color[2]= 1.0;
  }
#endif
}


	if (swp->sw_reflect > 0 || swp->sw_transmit > 0 )
		(void)rr_render( ap, pp, swp );

#if RT_MULTISPECTRAL
	bn_tabdata_free(ms_matcolor);
#endif
	return(1);
}



#ifndef PHAST_PHONG
/*
 *  			I P O W
 *  
 *  Raise a floating point number to an integer power
 */
double
phg_ipow( d, cnt )
double d;
register int cnt;
{
	FAST fastf_t input, result;

	if ((input=d) < 1e-8 )  return(0.0);
	if (cnt < 0 || cnt > 200 )  {
		bu_log("phg_ipow(%g,%d) bad\n", d, cnt);
		return(d);
	}
	result = 1;
	while( cnt-- > 0 )
		result *= input;
	return( result );
}
#endif
@


11.44
log
@change conf.h to a wrapped config.h
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/liboptical/sh_plastic.c,v 11.43 2004/04/05 07:43:37 morrison Exp $ (ARL)";
@


11.43
log
@merge of ansi-6-0-branch into HEAD
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d29 5
a33 1
#include "conf.h"
@


11.42
log
@update copyright to include span through 2003
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_plastic.c,v 11.41 2003/08/27 19:17:51 justin Exp $ (ARL)";
d80 4
a83 4
HIDDEN int phong_setup(), mirror_setup(), glass_setup();
HIDDEN int phong_render();
HIDDEN void	phong_print();
HIDDEN void	phong_free();
d116 6
a121 6
phong_setup( rp, matparm, dpp, mfp, rtip )
register struct region *rp;
struct bu_vls	*matparm;
char	**dpp;
struct mfuncs           *mfp;
struct rt_i             *rtip;  /* New since 4.4 release */
d153 6
a158 6
mirror_setup( rp, matparm, dpp, mfp, rtip )
register struct region *rp;
struct bu_vls	*matparm;
char	**dpp;
struct mfuncs           *mfp;
struct rt_i             *rtip;  /* New since 4.4 release */
d190 6
a195 6
glass_setup( rp, matparm, dpp, mfp, rtip )
register struct region *rp;
struct bu_vls	*matparm;
char	**dpp;
struct mfuncs           *mfp;
struct rt_i             *rtip;  /* New since 4.4 release */
d228 1
a228 3
phong_print( rp, dp )
register struct region *rp;
char	*dp;
d237 1
a237 2
phong_free( cp )
char *cp;
d310 1
a310 5
phong_render( ap, pp, swp, dp )
register struct application *ap;
struct partition	*pp;
struct shadework	*swp;
char	*dp;
@


11.41
log
@The nuts and bolts of photon mapping.
@
text
@d22 1
a22 1
 *	This software is Copyright (C) 1998 by the United States Army
d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_plastic.c,v 11.40.6.7 2003/08/24 23:30:25 justin Exp $ (ARL)";
@


11.41.4.1
log
@merge from HEAD
@
text
@d22 1
a22 1
 *	This software is Copyright (C) 1998-2004 by the United States Army
d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_plastic.c,v 11.42 2004/02/02 17:39:14 morrison Exp $ (ARL)";
@


11.41.4.2
log
@merge from head
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_plastic.c,v 11.41.4.1 2004/02/12 18:38:49 erikg Exp $ (ARL)";
@


11.41.2.1
log
@enhancements to photon mapping for sphere invalidation, enhanced phong model
with better ambient light handling, added attenuation to light sources.
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_plastic.c,v 11.41 2003/08/27 19:17:51 justin Exp $ (ARL)";
a44 1
#include "plot3.h"
d81 1
a81 6

HIDDEN int phong_render(register struct application *ap,
		 struct partition	*pp,
		 struct shadework	*swp,
		 char	*dp);

a311 9


#if RT_MULTISPECTRAL

/* XXX This is the old code.  
 * We should look at ways of bringing the multispectral 
 * code up to the new approach
 */

d314 4
a317 4
     register struct application *ap;
     struct partition	*pp;
     struct shadework	*swp;
     char	*dp;
d319 12
a330 9
    register struct light_specific *lp;
    register	fastf_t	refl;
    register	fastf_t	*to_light;
    register	int	i;
    register	fastf_t	cosine;
    vect_t			work;
    vect_t			reflected;
    point_t			pt;
    fastf_t			dist;
d332 7
a338 1
    struct bn_tabdata	*ms_matcolor = BN_TABDATA_NULL;
d340 1
d342 2
d345 4
a348 17
    struct phong_specific *ps =
	(struct phong_specific *)dp;

    if (ps->magic != PL_MAGIC )  bu_log("phong_render: bad magic\n");

    if (rdebug&RDEBUG_SHADE)
	bu_log("phong %s/%s\n",
	       pp->pt_regionp->reg_name, 
	       pp->pt_inseg->seg_stp->st_dp->d_namep);

    if (rdebug&RDEBUG_SHADE)
	bu_struct_print( "phong_render", phong_parse, (char *)ps );

    swp->sw_transmit = ps->transmit;
    swp->sw_reflect = ps->reflect;
    swp->sw_refrac_index = ps->refrac_index;
    swp->sw_extinction = ps->extinction;
d350 4
a353 4
    if (swp->sw_phong_set_vector & SW_SET_TRANSMIT) swp->sw_transmit = swp->sw_phong_transmit;
    if (swp->sw_phong_set_vector & SW_SET_REFLECT) swp->sw_reflect = swp->sw_phong_reflect;
    if (swp->sw_phong_set_vector & SW_SET_REFRAC_INDEX) swp->sw_refrac_index = swp->sw_phong_ri;
    if (swp->sw_phong_set_vector & SW_SET_EXTINCTION) swp->sw_extinction = swp->sw_phong_extinction;
d355 9
a363 7
    if (swp->sw_xmitonly ) {
	if (swp->sw_xmitonly > 1 )
	    return(1);	/* done -- wanted parameters only */
	if (swp->sw_reflect > 0 || swp->sw_transmit > 0 ) {
	    if (rdebug&RDEBUG_SHADE)
		bu_log("calling rr_render from phong, sw_xmitonly\n");
	    (void)rr_render( ap, pp, swp );
a364 2
	return(1);	/* done */
    }
d367 5
d373 6
a378 2
    ms_matcolor = bn_tabdata_dup( swp->msw_color );

d380 1
a380 1
    if (!PM_Visualize) {
d383 10
a392 10
	    if (cosine > 1.00001 )  {
		bu_log("cosAmb=1+%g %s surfno=%d (x%d,y%d,lvl%d)\n",
		       cosine-1,
		       pp->pt_inseg->seg_stp->st_dp->d_namep,
		       swp->sw_hit.hit_surfno,
		       ap->a_x, ap->a_y, ap->a_level);
		VPRINT(" normal", swp->sw_hit.hit_normal);
		VPRINT(" r_dir ", ap->a_ray.r_dir);
		cosine = 1;
	    }
d394 6
a399 3
	    if (swp->sw_phong_set_vector & SW_SET_AMBIENT) {
		cosine *= swp->sw_phong_ambient;
	    } else {
d401 3
a403 1
	    }
d405 1
a405 1
	    cosine *= AmbientIntensity;
a406 2

	    bn_tabdata_scale( swp->msw_color, ms_matcolor, cosine );
d408 5
a412 1
	    bn_tabdata_constval( swp->msw_color, 0.0 );
d416 1
d418 3
a420 3
	    float emission[3];
	    struct bn_tabdata	*ms_emission = BN_TABDATA_NULL;
	    VMOVE(emission,ps->emission);
d422 21
a442 3
	    if (swp->sw_phong_set_vector & SW_SET_EMISSION) {
		VSETALL(emission, swp->sw_phong_emission);
	    }
d444 1
a444 6
	    /* XXX Really should get a curve at prep, not expand RGB samples */
	    BN_GET_TABDATA( ms_emission, spectrum );
	    rt_spect_reflectance_rgb( ms_emission, emission );
	    bn_tabdata_add( swp->msw_color, swp->msw_color, ms_emission );
	    bn_tabdata_free( ms_emission );
	}
d456 2
a457 2
	    if ((lp = (struct light_specific *)swp->sw_visible[i]) == LIGHT_NULL )
		continue;
d459 4
a462 4
	    if( rdebug & RDEBUG_LIGHT )  {
		bu_log("phong_render %d light=%s lightfract=%g  lt_fraction=%g\n",
		       i, lp->lt_name, swp->sw_lightfract[i], lp->lt_fraction );
	    }
d464 5
a468 2
	    /* Light is not shadowed -- add this contribution */
	    to_light = swp->sw_tolight+3*i;
d470 17
a486 1
	    /* Diffuse reflectance from this light source. */
d488 10
a497 21
	    cosine=VDOT(swp->sw_hit.hit_normal, to_light);
	    if (rdebug&RDEBUG_SHADE) {
		bu_log("light %d\n    diffuse\n\tto_light:%g %g %g\n\tnormal:%g %g %g\n\tcosine:%g\n",
		       i, V3ARGS(to_light), V3ARGS(swp->sw_hit.hit_normal), cosine);
	    }

	    if (cosine > 0.0 )  {
		if (cosine > 1.00001 )  {
		    bu_log("cosI=1+%g (x%d,y%d,lvl%d)\n", cosine-1,
			   ap->a_x, ap->a_y, ap->a_level);
		    cosine = 1;
		}
		/* Get Obj Hit Point For Attenuation */
		if (pp && PM_Activated) {
		    VJOIN1(pt, ap -> a_ray.r_pt, pp -> pt_inhit -> hit_dist, ap -> a_ray.r_dir)
			dist= sqrt((pt[0]-lp -> lt_pos[0])*(pt[0]-lp -> lt_pos[0]) + (pt[1]-lp -> lt_pos[1])*(pt[1]-lp -> lt_pos[1]) + (pt[2]-lp -> lt_pos[2])*(pt[2]-lp -> lt_pos[2]))/1000.0;
		    dist= (1.0/(0.1 + 1.0*dist + 0.01*dist*dist));
		    refl= dist * ps -> wgt_diffuse * cosine * swp -> sw_lightfract[i] * lp -> lt_intensity;
		    /*				bu_log("pt: [%.3f][%.3f,%.3f,%.3f]\n",dist,pt[0],pt[1],pt[2]);*/
		} else {
		    refl= ps -> wgt_diffuse * swp -> sw_lightfract[i] * cosine * lp -> lt_fraction;
d500 15
a514 30
		bn_tabdata_incr_mul3_scale( swp->msw_color,
					    lp->lt_spectrum,
					    swp->msw_intensity[i],
					    ms_matcolor,
					    refl );
	    }

	    /* Calculate specular reflectance.
	     *	Reflected ray = (2 * cos(i) * Normal) - Incident ray.
	     * 	Cos(s) = Reflected ray DOT Incident ray.
	     */
	    cosine *= 2;
	    VSCALE( work, swp->sw_hit.hit_normal, cosine );
	    VSUB2( reflected, work, to_light );

	    cosine = -VDOT( reflected, ap->a_ray.r_dir );
	    if (rdebug&RDEBUG_SHADE) {
		bu_log("    specular\n\tcosine:%g\n", cosine);
		VPRINT("\treflected", reflected);
	    }


	    if ((cosine) > 0 )  {
		if (cosine > 1.00001 )  {
		    bu_log("cosS=1+%g (x%d,y%d,lvl%d)\n", cosine-1,
			   ap->a_x, ap->a_y, ap->a_level);
		    cosine = 1;
		}
		refl = ps->wgt_specular * swp->sw_lightfract[i] *
		    lp->lt_fraction *
d516 8
a523 7
		    /* It is unnecessary to compute the actual
		     * exponential here since phong is just a
		     * gross hack.  We approximate re:
		     *  Graphics Gems IV "A Fast Alternative to
		     *  Phong's Specular Model" Pg 385
		     */
		    cosine / (ps->shine - ps->shine*cosine + cosine);
d525 1
a525 1
		phg_ipow(cosine, ps->shine);
d527 9
a535 3

		if (rdebug&RDEBUG_SHADE) {
		    bu_log("refl:%g\n", refl);
a536 8

		bn_tabdata_incr_mul2_scale( swp->msw_color,
					    lp->lt_spectrum,
					    swp->msw_intensity[i],
					    refl );


	    }
d539 10
d550 1
a550 1
    } else {
d552 10
a561 10
    }


    if (swp->sw_reflect > 0 || swp->sw_transmit > 0 )
	(void)rr_render( ap, pp, swp );


    bn_tabdata_free(ms_matcolor);

    return(1);
d565 2
a566 1
#else /* MULTISPECTRAL */
d568 4
a571 109
/*
 *
 *
 */
HIDDEN int
phong_render(register struct application *ap,
		 struct partition	*pp,
		 struct shadework	*swp,
		 char	*dp)
{
    register struct light_specific *lp;
    struct phong_specific *ps =
	(struct phong_specific *)dp;
    vect_t specular, diffuse, ambient, to_eye, diff, spec;
    fastf_t *intensity;
    fastf_t *to_light;
    double cosine;
    register double value;
    register double ltfrac;
    int i;
    vect_t work;
    vect_t Hvec;

    if (rdebug&RDEBUG_SHADE)
	bu_log("phong %s/%s\n",
	       pp->pt_regionp->reg_name, 
	       pp->pt_inseg->seg_stp->st_dp->d_namep);


    if (PM_Visualize) { /* photon mapping */
	IrradianceEstimate(ap, swp->sw_color, swp->sw_hit.hit_point,
			   swp->sw_hit.hit_normal, 100, 100);
	return 1;
    }


    VSETALL(specular, 0.0);
    VSETALL(diffuse, 0.0);

    VREVERSE(to_eye, ap->a_ray.r_dir);
    
    light_obs(ap, swp, ps->mfp->mf_inputs);

    for( i=ap->a_rt_i->rti_nlights-1; i>=0; i-- )  {

	if ((lp = (struct light_specific *)swp->sw_visible[i]) == LIGHT_NULL )
	    continue;

	to_light = swp->sw_tolight+3*i;
	intensity = swp->sw_intensity+3*i;

	/* diffuse term */
	cosine = VDOT(to_light, swp->sw_hit.hit_normal);
	ltfrac = swp->sw_lightfract[i] * lp->lt_fraction;
	if (cosine > 0) {
	    if (cosine > 1.0) cosine = 1.0;
	    value = cosine * ltfrac;

	    VSCALE(diff, swp->sw_color, value);
	    if (lp->lt_attenuation) {
		/* take into account the light distance and intensity */
		VSUB2(work, swp->sw_hit.hit_point, lp->lt_pos);
#define light_dist cosine /* re-use variable storage */
		light_dist = MAGNITUDE(work) / 1000.0;
		light_dist = lp->lt_intensity / 
		    (0.0001 + light_dist*light_dist);

		VJOIN1(diffuse, diffuse, light_dist, diff);
#undef light_dist
	    } else {
		VADD2(diffuse, diffuse, diff);
	    }
	}
	/* specular term */
	VADD2(Hvec, to_eye, to_light);
	VSCALE(Hvec, Hvec, 0.5);
	cosine = VDOT(Hvec, swp->sw_hit.hit_normal);
	if (cosine > 0) {
	    if (cosine > 1.0) cosine = 1.0;

	    VELMUL( work, lp->lt_color, intensity );

	    value = ltfrac * cosine / (ps->shine - ps->shine*cosine + cosine);

	    VSCALE(spec, work, value);

	    VADD2(specular, specular, spec);
	}
    }


    VSCALE(ambient, swp->sw_color, AmbientIntensity);
    VSCALE(diffuse, diffuse, ps->wgt_diffuse);
    VSCALE(specular, specular, ps->wgt_specular);


    if (PM_Activated) { /* photon mapping */
	IrradianceEstimate(ap, work, swp->sw_hit.hit_point,
			   swp->sw_hit.hit_normal, 100, 100);

	VELMUL(work, work, swp->sw_color);

	VADD3(swp->sw_color, work, diffuse, specular);

    } else {
	VADD3(swp->sw_color, ambient, diffuse, specular);
    }

    return 1;
d576 1
a576 3

#endif

d599 1
a599 1

@


11.41.2.2
log
@Previously forgot transmission and reflection in new implementation.  Fixed that.
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_plastic.c,v 11.41.2.1 2003/09/10 22:08:27 butler Exp $ (ARL)";
d575 1
a575 1
	bu_log("phong_render (new) %s/%s\n",
a585 14
    swp->sw_transmit = ps->transmit;
    swp->sw_reflect = ps->reflect;
    swp->sw_refrac_index = ps->refrac_index;
    swp->sw_extinction = ps->extinction;
    if (swp->sw_xmitonly ) {
	if (swp->sw_xmitonly > 1 )
	    return(1);	/* done -- wanted parameters only */
	if (swp->sw_reflect > 0 || swp->sw_transmit > 0 ) {
	    if (rdebug&RDEBUG_SHADE)
		bu_log("calling rr_render from phong, sw_xmitonly\n");
	    (void)rr_render( ap, pp, swp );
	}
	return(1);	/* done */
    }
a657 4

    if (swp->sw_reflect > 0 || swp->sw_transmit > 0 )
	(void)rr_render( ap, pp, swp );

@


11.41.2.3
log
@Fixed attenuation for light sources
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_plastic.c,v 11.41.2.2 2003/09/13 14:40:33 butler Exp $ (ARL)";
d610 1
a610 1
	if ((lp = (struct light_specific *)swp->sw_visible[i]) == LIGHT_NULL){
d612 1
a612 1
	}
d627 4
d632 4
a635 4
		value = MAGNITUDE(work) / 1000.0; /* distance to light in m */
		value = lp->lt_intensity / (0.0001 + value*value);

		VSCALE(diff, diff, value);
a636 1
	    VADD2(diffuse, diffuse, diff);
a637 1

d675 1
@


11.41.2.4
log
@Fixed problem with #@@%^*^ non-unit length H vector
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_plastic.c,v 11.41.2.3 2003/09/13 17:51:26 butler Exp $ (ARL)";
d575 1
a575 1
	bu_log("%s:%d phong_render (new) %s/%s\n", __FILE__, __LINE__,
a578 1
    if (ps->magic != PL_MAGIC )  bu_log("phong_render: bad magic\n");
d585 1
a590 4

	if (rdebug&RDEBUG_SHADE)
	    bu_log("%s:%d xmitonly\n", __FILE__, __LINE__);

a610 3
	    if (rdebug&RDEBUG_SHADE) 
		bu_log("%s:%d light %d not visible\n", __FILE__, __LINE__, i);

a611 4
	} else {
	    if (rdebug&RDEBUG_SHADE) 
		bu_log("%s:%d light %d visible\n", __FILE__, __LINE__, i);

a631 2
	    } else {

a633 1

a638 1
	VUNITIZE(Hvec);
d642 1
a649 2

	    
a650 5

	if (rdebug&RDEBUG_SHADE) 
	    bu_log("  diffuse %g %g %g   specular %g %g %g\n",
		   V3ARGS(diff), V3ARGS(spec));

@


11.40
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_plastic.c,v 11.38 2002/07/16 19:38:38 morrison Exp $ (ARL)";
d44 2
a59 17
/* Local information */
struct phong_specific {
	int	magic;
	int	shine;
	double	wgt_specular;
	double	wgt_diffuse;
	double	transmit;	/* Moss "transparency" */
	double	reflect;	/* Moss "transmission" */
	double	refrac_index;
	double	extinction;
	double	emission[3];
	struct mfuncs *mfp;
};
#define PL_MAGIC	0xbeef00d
#define PL_NULL	((struct phong_specific *)0)
#define PL_O(m)	offsetof(struct phong_specific, m)

d321 1
a321 1
	register fastf_t *intensity;
d323 9
a331 6
	register fastf_t refl;
	register fastf_t *to_light;
	register int	i;
	register fastf_t cosine;
	vect_t	work;
	vect_t	reflected;
d366 1
d373 8
d477 11
a487 2
			refl = ps->wgt_diffuse * swp->sw_lightfract[i] *
					cosine * lp->lt_fraction;
d538 27
d573 2
@


11.40.4.1
log
@sync to HEAD...
@
text
@d22 1
a22 1
 *	This software is Copyright (C) 1998-2004 by the United States Army
d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/liboptical/sh_plastic.c,v 11.42 2004/02/02 17:39:14 morrison Exp $ (ARL)";
a43 2
#include "plastic.h"
#include "photonmap.h"
d58 17
d336 1
a336 1
	register	fastf_t	*intensity;
d338 6
a343 9
	register	fastf_t	refl;
	register	fastf_t	*to_light;
	register	int	i;
	register	fastf_t	cosine;
	vect_t			work,color;
	vect_t			reflected;
	point_t			pt;
	fastf_t			dist;

a377 1

a383 8
/* Photon Mapping */
#ifndef RT_MULTISPECTRAL
color[0]= swp -> sw_color[0];
color[1]= swp -> sw_color[1];
color[2]= swp -> sw_color[2];
#endif

if (!PM_Visualize) {
d480 2
a481 11
			/* Get Obj Hit Point For Attenuation */
                        if (pp && PM_Activated) {
				VJOIN1(pt, ap -> a_ray.r_pt, pp -> pt_inhit -> hit_dist, ap -> a_ray.r_dir)
				dist= sqrt((pt[0]-lp -> lt_pos[0])*(pt[0]-lp -> lt_pos[0]) + (pt[1]-lp -> lt_pos[1])*(pt[1]-lp -> lt_pos[1]) + (pt[2]-lp -> lt_pos[2])*(pt[2]-lp -> lt_pos[2]))/1000.0;
				dist= (1.0/(0.1 + 1.0*dist + 0.01*dist*dist));
				refl= dist * ps -> wgt_diffuse * cosine * swp -> sw_lightfract[i] * lp -> lt_intensity;
/*				bu_log("pt: [%.3f][%.3f,%.3f,%.3f]\n",dist,pt[0],pt[1],pt[2]);*/
                        } else {
				refl= ps -> wgt_diffuse * swp -> sw_lightfract[i] * cosine * lp -> lt_fraction;
			}

a531 27

#ifndef RT_MULTISPECTRAL
  if (PM_Activated) {
    IrradianceEstimate(ap, work, swp -> sw_hit.hit_point, swp -> sw_hit.hit_normal, 100, 100);
    VELMUL(work, work, color);
    VADD2(swp -> sw_color, work, swp -> sw_color);
    if (swp -> sw_color[0] > 1.0) swp -> sw_color[0]= 1.0;
    if (swp -> sw_color[1] > 1.0) swp -> sw_color[1]= 1.0;
    if (swp -> sw_color[2] > 1.0) swp -> sw_color[2]= 1.0;
  }
#endif

} else {

#ifndef RT_MULTISPECTRAL
  if (PM_Activated) {
/*  IrradianceEstimate(work, swp -> sw_hit.hit_point, swp -> sw_hit.hit_normal, 100, 100);
  VELMUL(swp -> sw_color, work, color);*/
    IrradianceEstimate(ap, swp -> sw_color, swp -> sw_hit.hit_point, swp -> sw_hit.hit_normal, 100, 100);
    if (swp -> sw_color[0] > 1.0) swp -> sw_color[0]= 1.0;
    if (swp -> sw_color[1] > 1.0) swp -> sw_color[1]= 1.0;
    if (swp -> sw_color[2] > 1.0) swp -> sw_color[2]= 1.0;
  }
#endif
}


a539 2


@


11.40.6.1
log
@sh_plastic for photonmapping
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_plastic.c,v 11.40 2002/08/20 17:07:51 jra Exp $ (ARL)";
a43 2
#include "plastic.h"
#include "photonmap.h"
d58 17
d342 1
a342 1
	vect_t	work,color;
a377 1

a383 14
/* Photon Mapping */
#if RT_MULTISPECTRAL
/*
color[0]= swp -> msw_color[0];
color[1]= swp -> msw_color[1];
color[2]= swp -> msw_color[2];
*/
#else
color[0]= swp -> sw_color[0];
color[1]= swp -> sw_color[1];
color[2]= swp -> sw_color[2];
#endif

#if 1
a531 30

#ifndef RT_MULTISPECTRAL
#if 1
  if (PM_Activated) {
    IrradianceEstimate(ap, work, swp -> sw_hit.hit_point, swp -> sw_hit.hit_normal, 100, 100);
    VELMUL(work, work, color);
    VADD2(swp -> sw_color, work, swp -> sw_color);
    if (swp -> sw_color[0] > 1.0) swp -> sw_color[0]= 1.0;
    if (swp -> sw_color[1] > 1.0) swp -> sw_color[1]= 1.0;
    if (swp -> sw_color[2] > 1.0) swp -> sw_color[2]= 1.0;
  }
#endif
#endif

#else

#ifndef RT_MULTISPECTRAL
  if (PM_Activated) {
/*  IrradianceEstimate(work, swp -> sw_hit.hit_point, swp -> sw_hit.hit_normal, 100, 100);
  VELMUL(swp -> sw_color, work, color);*/
    IrradianceEstimate(ap, swp -> sw_color, swp -> sw_hit.hit_point, swp -> sw_hit.hit_normal, 100, 100);
    if (swp -> sw_color[0] > 1.0) swp -> sw_color[0]= 1.0;
    if (swp -> sw_color[1] > 1.0) swp -> sw_color[1]= 1.0;
    if (swp -> sw_color[2] > 1.0) swp -> sw_color[2]= 1.0;
  }
#endif

#endif


@


11.40.6.2
log
@*** empty log message ***
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_plastic.c,v 11.40.6.1 2003/08/07 22:15:32 justin Exp $ (ARL)";
d321 1
a321 1
	register	fastf_t	*intensity;
d323 6
a328 9
	register	fastf_t	refl;
	register	fastf_t	*to_light;
	register	int	i;
	register	fastf_t	cosine;
	vect_t			work,color;
	vect_t			reflected;
	point_t			pt;
	fastf_t			dist;

d480 1
a480 11
			/* Get Obj Hit Point For Attenuation */
                        if (pp || PM_Activated) {
				VJOIN1(pt, ap -> a_ray.r_pt, pp -> pt_inhit -> hit_dist, ap -> a_ray.r_dir)
				dist= sqrt((pt[0]-lp -> lt_pos[0])*(pt[0]-lp -> lt_pos[0]) + (pt[1]-lp -> lt_pos[1])*(pt[1]-lp -> lt_pos[1]) + (pt[2]-lp -> lt_pos[2])*(pt[2]-lp -> lt_pos[2]))/1000.0;
				dist= (1.0/(0.1 + 1.3*dist + 0.7*dist*dist));
/*			bu_log("pt: [%.3f][%.3f,%.3f,%.3f]\n",dist,pt[0],pt[1],pt[2]);*/
                        } else {
				dist= 1.0;
			}

			refl = dist * ps->wgt_diffuse * swp->sw_lightfract[i] *
@


11.40.6.3
log
@more attenuation stuf
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_plastic.c,v 11.40.6.2 2003/08/12 00:47:44 justin Exp $ (ARL)";
a482 1

a483 1
PM_Intensity= 1.0;
d487 1
a487 1
				dist= PM_Intensity * (1.0/(0.1 + 1.3*dist + 0.7*dist*dist));
@


11.40.6.4
log
@attenuation update
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_plastic.c,v 11.40.6.3 2003/08/12 03:43:36 justin Exp $ (ARL)";
d483 2
a485 1
			/* Get Obj Hit Point For Attenuation */
d490 1
a490 2
				refl= dist * ps->wgt_diffuse * swp->sw_lightfract[i] * cosine * lp -> lt_intensity;
/*				bu_log("pt: [%.3f][%.3f,%.3f,%.3f]\n",dist,pt[0],pt[1],pt[2]);*/
d492 1
a492 1
				refl= ps->wgt_diffuse * swp->sw_lightfract[i] * cosine * lp-> lt_fraction;
d495 2
@


11.40.6.5
log
@Visualization of Irradiance
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_plastic.c,v 11.40.6.4 2003/08/12 22:48:00 justin Exp $ (ARL)";
d386 1
a386 1
if (!PM_Visualize) {
d559 1
a559 1
} else {
d570 1
a570 1
}
@


11.40.6.6
log
@more updates
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_plastic.c,v 11.40.6.5 2003/08/12 23:34:57 justin Exp $ (ARL)";
d485 1
a485 1
                        if (pp && PM_Activated) {
d488 1
a488 1
				dist= PM_Intensity * (1.0/(0.1 + 0.5*dist + 3.0*dist*dist));
@


11.40.6.7
log
@updated
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_plastic.c,v 11.40.6.6 2003/08/13 22:09:23 justin Exp $ (ARL)";
d483 1
d488 2
a489 2
				dist= (1.0/(0.1 + 1.0*dist + 0.01*dist*dist));
				refl= dist * ps -> wgt_diffuse * cosine * swp -> sw_lightfract[i] * lp -> lt_intensity;
d492 1
a492 1
				refl= ps -> wgt_diffuse * swp -> sw_lightfract[i] * cosine * lp -> lt_fraction;
@


11.40.2.1
log
@Initial ANSIfication
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_plastic.c,v 11.40 2002/08/20 17:07:51 jra Exp $ (ARL)";
d95 4
a98 4
HIDDEN int phong_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip), mirror_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip), glass_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip);
HIDDEN int phong_render(register struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
HIDDEN void	phong_print(register struct region *rp, char *dp);
HIDDEN void	phong_free(char *cp);
d131 6
a136 6
phong_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip)
                           
             	         
    	      
                             
                                /* New since 4.4 release */
d168 6
a173 6
mirror_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip)
                           
             	         
    	      
                             
                                /* New since 4.4 release */
d205 6
a210 6
glass_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip)
                           
             	         
    	      
                             
                                /* New since 4.4 release */
d243 3
a245 1
phong_print(register struct region *rp, char *dp)
d254 2
a255 1
phong_free(char *cp)
d328 5
a332 1
phong_render(register struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
@


11.40.2.2
log
@sync branch with HEAD
@
text
@d22 1
a22 1
 *	This software is Copyright (C) 1998-2004 by the United States Army
d26 1
a26 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
a43 2
#include "plastic.h"
#include "photonmap.h"
d58 17
d329 1
a329 1
	register	fastf_t	*intensity;
d331 6
a336 9
	register	fastf_t	refl;
	register	fastf_t	*to_light;
	register	int	i;
	register	fastf_t	cosine;
	vect_t			work,color;
	vect_t			reflected;
	point_t			pt;
	fastf_t			dist;

a370 1

a376 8
/* Photon Mapping */
#ifndef RT_MULTISPECTRAL
color[0]= swp -> sw_color[0];
color[1]= swp -> sw_color[1];
color[2]= swp -> sw_color[2];
#endif

if (!PM_Visualize) {
d473 2
a474 11
			/* Get Obj Hit Point For Attenuation */
                        if (pp && PM_Activated) {
				VJOIN1(pt, ap -> a_ray.r_pt, pp -> pt_inhit -> hit_dist, ap -> a_ray.r_dir)
				dist= sqrt((pt[0]-lp -> lt_pos[0])*(pt[0]-lp -> lt_pos[0]) + (pt[1]-lp -> lt_pos[1])*(pt[1]-lp -> lt_pos[1]) + (pt[2]-lp -> lt_pos[2])*(pt[2]-lp -> lt_pos[2]))/1000.0;
				dist= (1.0/(0.1 + 1.0*dist + 0.01*dist*dist));
				refl= dist * ps -> wgt_diffuse * cosine * swp -> sw_lightfract[i] * lp -> lt_intensity;
/*				bu_log("pt: [%.3f][%.3f,%.3f,%.3f]\n",dist,pt[0],pt[1],pt[2]);*/
                        } else {
				refl= ps -> wgt_diffuse * swp -> sw_lightfract[i] * cosine * lp -> lt_fraction;
			}

a524 27

#ifndef RT_MULTISPECTRAL
  if (PM_Activated) {
    IrradianceEstimate(ap, work, swp -> sw_hit.hit_point, swp -> sw_hit.hit_normal, 100, 100);
    VELMUL(work, work, color);
    VADD2(swp -> sw_color, work, swp -> sw_color);
    if (swp -> sw_color[0] > 1.0) swp -> sw_color[0]= 1.0;
    if (swp -> sw_color[1] > 1.0) swp -> sw_color[1]= 1.0;
    if (swp -> sw_color[2] > 1.0) swp -> sw_color[2]= 1.0;
  }
#endif

} else {

#ifndef RT_MULTISPECTRAL
  if (PM_Activated) {
/*  IrradianceEstimate(work, swp -> sw_hit.hit_point, swp -> sw_hit.hit_normal, 100, 100);
  VELMUL(swp -> sw_color, work, color);*/
    IrradianceEstimate(ap, swp -> sw_color, swp -> sw_hit.hit_point, swp -> sw_hit.hit_normal, 100, 100);
    if (swp -> sw_color[0] > 1.0) swp -> sw_color[0]= 1.0;
    if (swp -> sw_color[1] > 1.0) swp -> sw_color[1]= 1.0;
    if (swp -> sw_color[2] > 1.0) swp -> sw_color[2]= 1.0;
  }
#endif
}


a532 2


@


11.39
log
@Converted from K&R to ANSI C - RFH
@
text
@d95 4
a98 4
HIDDEN int phong_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip), mirror_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip), glass_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip);
HIDDEN int phong_render(register struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
HIDDEN void	phong_print(register struct region *rp, char *dp);
HIDDEN void	phong_free(char *cp);
d131 6
a136 6
phong_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip)
                           
             	         
    	      
                             
                                /* New since 4.4 release */
d168 6
a173 6
mirror_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip)
                           
             	         
    	      
                             
                                /* New since 4.4 release */
d205 6
a210 6
glass_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip)
                           
             	         
    	      
                             
                                /* New since 4.4 release */
d243 3
a245 1
phong_print(register struct region *rp, char *dp)
d254 2
a255 1
phong_free(char *cp)
d328 5
a332 1
phong_render(register struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
@


11.38
log
@Moved the non-local-only header file (light.h) from rt/ into the header directory since it is used by multiple targets (liboptical, rt, etc)
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_plastic.c,v 11.37 2001/04/20 22:29:33 morrison Exp $ (ARL)";
d95 4
a98 4
HIDDEN int phong_setup(), mirror_setup(), glass_setup();
HIDDEN int phong_render();
HIDDEN void	phong_print();
HIDDEN void	phong_free();
d131 6
a136 6
phong_setup( rp, matparm, dpp, mfp, rtip )
register struct region *rp;
struct bu_vls	*matparm;
char	**dpp;
struct mfuncs           *mfp;
struct rt_i             *rtip;  /* New since 4.4 release */
d168 6
a173 6
mirror_setup( rp, matparm, dpp, mfp, rtip )
register struct region *rp;
struct bu_vls	*matparm;
char	**dpp;
struct mfuncs           *mfp;
struct rt_i             *rtip;  /* New since 4.4 release */
d205 6
a210 6
glass_setup( rp, matparm, dpp, mfp, rtip )
register struct region *rp;
struct bu_vls	*matparm;
char	**dpp;
struct mfuncs           *mfp;
struct rt_i             *rtip;  /* New since 4.4 release */
d243 1
a243 3
phong_print( rp, dp )
register struct region *rp;
char	*dp;
d252 1
a252 2
phong_free( cp )
char *cp;
d325 1
a325 5
phong_render( ap, pp, swp, dp )
register struct application *ap;
struct partition	*pp;
struct shadework	*swp;
char	*dp;
@


11.37
log
@CONST to const
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_plastic.c,v 11.36 2000/10/19 19:19:45 butler Exp $ (ARL)";
d40 1
a40 1
#include "../rt/light.h"
@


11.36
log
@Changes to compile under RedHat 7.0
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_plastic.c,v 11.35 2000/09/11 06:38:01 cjohnson Exp $ (ARL)";
d55 1
a55 1
extern CONST struct bn_table	*spectrum;	/* from rttherm/viewtherm.c */
d100 1
a100 1
/* This can't be CONST, so the forward link can be written later */
@


11.35
log
@Fix a typo, mind burb.
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_plastic.c,v 11.34 2000/09/11 05:56:12 cjohnson Exp $ (ARL)";
d41 3
d421 1
a421 1
		fastf_t emission[3];
@


11.34
log
@Added support for experamental message passing between shaders.
Phong shader catches many parameters.
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_plastic.c,v 11.33 2000/09/06 00:23:55 mike Exp $ (ARL)";
d418 1
a418 1
		fastf_t emission = ps->emission;
d420 1
d423 1
a423 1
			emission = swp->sw_phong_emission;
@


11.33
log
@
Improved cosAmb error message
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_plastic.c,v 11.32 2000/08/17 03:11:59 mike Exp $ (ARL)";
d358 6
d393 7
d401 1
d418 1
d420 5
d427 1
a427 1
		rt_spect_reflectance_rgb( ms_emission, ps->emission );
d432 9
d442 1
@


11.32
log
@
Added "emission" term to Phong shader.
I followed the guidelines of
the OpenGL glMaterialfv(GL_FRONT, GL_EMISSION, ...) call; it's an rgb
tripple in the range of -1 to +1 (not 255), where negative values
cause energy suckout.

mater ellipse.r {phong emission .3/.3/.3} 100 210 100 0
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_plastic.c,v 11.31 2000/07/25 16:40:38 butler Exp $ (ARL)";
d378 4
a381 1
			bu_log("cosAmb=1+%g (x%d,y%d,lvl%d)\n", cosine-1,
d383 2
@


11.31
log
@Changes to use rtprivate.h instead of ../rt/rdebug.h
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_plastic.c,v 11.30 2000/03/03 21:23:28 mike Exp $ (ARL)";
d65 1
d87 2
d102 3
d322 1
a322 1
	n	'Shininess' of the material,  range 1 to 10.
d395 14
@


11.30
log
@
libmultispectral version needs refl variable too!
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_plastic.c,v 11.29 2000/03/03 03:29:06 mike Exp $ (ARL)";
d39 1
a39 1
#include "../rt/rdebug.h"
d42 3
@


11.29
log
@
Added debugging for sw_lightfract
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_plastic.c,v 11.28 2000/03/03 03:04:02 mike Exp $ (ARL)";
d325 1
a326 1
#endif
@


11.28
log
@
sh_light.c/light_obs() applied the sw_lightfract scaling for the
multispectral case, but in the optical case it was applied in
sh_plastic.c/phong_render().  I made the multi-spectral code track the
optical code, and it's now consistent and much clearer.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_plastic.c,v 11.27 2000/02/19 21:05:02 butler Exp $ (ARL)";
d399 5
@


11.27
log
@Changes to support movement of CLAMP() macro into vmath.h
Altered "if( " statements to "if (" for readability.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_plastic.c,v 11.26 2000/02/03 06:34:45 butler Exp $ (ARL)";
a324 1
	vect_t  inten;
a402 2
		/* Scale for the amount of the light we could actually see */
		VSCALE(inten, intensity, swp->sw_lightfract[i]);
d413 2
d420 1
a420 1
				cosine * ps->wgt_diffuse );
d422 2
a423 4
			refl = cosine * lp->lt_fraction * ps->wgt_diffuse;
			VELMUL3( work, matcolor, lp->lt_color, inten );
			VJOIN1( swp->sw_color, swp->sw_color,
				refl, work );
d440 2
a441 8
#if RT_MULTISPECTRAL
			bn_tabdata_incr_mul2_scale( swp->msw_color,
				lp->lt_spectrum,
				swp->msw_intensity[i],
				ps->wgt_specular * cosine /
				(ps->shine - ps->shine*cosine + cosine) );
#else
			refl = ps->wgt_specular * lp->lt_fraction *
d454 7
a460 1
			VELMUL( work, lp->lt_color, inten );
@


11.26
log
@Changes to the light visibility computation.  Now we allow multiple
light sample rays for each hit point.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_plastic.c,v 11.25 2000/01/21 21:43:34 butler Exp $ (ARL)";
d142 1
a142 1
	if( bu_struct_parse( matparm, phong_parse, (char *)pp ) < 0 )  {
d147 1
a147 1
	if( pp->transmit > 0 )
d179 1
a179 1
	if( bu_struct_parse( matparm, phong_parse, (char *)pp ) < 0 )  {
d184 1
a184 1
	if( pp->transmit > 0 )
d217 1
a217 1
	if( bu_struct_parse( matparm, phong_parse, (char *)pp ) < 0 )  {
d222 1
a222 1
	if( pp->transmit > 0 )
d341 1
a341 1
	if( ps->magic != PL_MAGIC )  bu_log("phong_render: bad magic\n");
d343 1
a343 1
	if( rdebug&RDEBUG_SHADE)
d350 2
a351 2
	if( swp->sw_xmitonly ) {
		if( swp->sw_xmitonly > 1 )
d353 2
a354 2
		if( swp->sw_reflect > 0 || swp->sw_transmit > 0 ) {
			if( rdebug&RDEBUG_SHADE)
d368 2
a369 2
	if( (cosine = -VDOT( swp->sw_hit.hit_normal, ap->a_ray.r_dir )) > 0.0 )  {
		if( cosine > 1.00001 )  {
d398 1
a398 1
		if( (lp = (struct light_specific *)swp->sw_visible[i]) == LIGHT_NULL )
d410 2
a411 2
		if( (cosine=VDOT(swp->sw_hit.hit_normal, to_light)) > 0.0 )  {
			if( cosine > 1.00001 )  {
d437 2
a438 2
		if( (cosine = -VDOT( reflected, ap->a_ray.r_dir )) > 0 )  {
			if( cosine > 1.00001 )  {
d468 1
a468 1
	if( swp->sw_reflect > 0 || swp->sw_transmit > 0 )
d490 2
a491 2
	if( (input=d) < 1e-8 )  return(0.0);
	if( cnt < 0 || cnt > 200 )  {
@


11.25
log
@Deleted unused variable declarations
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_plastic.c,v 11.24 1999/12/30 16:07:16 jra Exp $ (ARL)";
d325 1
d393 1
a393 1
	light_visibility(ap, swp, ps->mfp->mf_inputs);
d404 2
d410 1
a410 1
		if( (cosine = VDOT( swp->sw_hit.hit_normal, to_light )) > 0.0 )  {
d424 1
a424 1
			VELMUL3( work, matcolor, lp->lt_color, intensity );
d463 2
a464 4
			VELMUL( work, lp->lt_color,
				intensity );
			VJOIN1( swp->sw_color, swp->sw_color,
				refl, work );
@


11.24
log
@Eliminated an unused variable
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_plastic.c,v 11.23 1999/12/04 00:17:25 mike Exp $ (ARL)";
d325 1
a329 1
	register fastf_t refl;
@


11.23
log
@
If caller only wants material properties,
no need to spend time computing transmission.
(sw_xmitonly == 2 case)
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_plastic.c,v 11.22 1999/10/30 03:06:24 butler Exp $ (ARL)";
a334 1
	vect_t	cprod;			/* color product */
@


11.22
log
@Moved mathtab/rand_half from rt into libbn
Expanded structparse to include description and default
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_plastic.c,v 11.21 1999/07/02 22:20:41 mike Exp $ (ARL)";
d351 2
@


11.21
log
@
Removed dependence on compat4.h
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_plastic.c,v 11.20 1999/07/01 20:08:47 mike Exp $ (ARL)";
a38 1
#include "../rt/mathtab.h"
@


11.20
log
@
compat4
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_plastic.c,v 11.19 1998/12/12 07:23:05 mike Exp $ (ARL)";
d70 15
a84 15
	{"%d",	1, "shine",		PL_O(shine),		FUNC_NULL },
	{"%d",	1, "sh",		PL_O(shine),		FUNC_NULL },
	{"%f",	1, "specular",		PL_O(wgt_specular),	FUNC_NULL },
	{"%f",	1, "sp",		PL_O(wgt_specular),	FUNC_NULL },
	{"%f",	1, "diffuse",		PL_O(wgt_diffuse),	FUNC_NULL },
	{"%f",	1, "di",		PL_O(wgt_diffuse),	FUNC_NULL },
	{"%f",	1, "transmit",		PL_O(transmit),		FUNC_NULL },
	{"%f",	1, "tr",		PL_O(transmit),		FUNC_NULL },
	{"%f",	1, "reflect",		PL_O(reflect),		FUNC_NULL },
	{"%f",	1, "re",		PL_O(reflect),		FUNC_NULL },
	{"%f",	1, "ri",		PL_O(refrac_index),	FUNC_NULL },
	{"%f",	1, "extinction_per_meter", PL_O(extinction),	FUNC_NULL },
	{"%f",	1, "extinction",	PL_O(extinction),	FUNC_NULL },
	{"%f",	1, "ex",		PL_O(extinction),	FUNC_NULL },
	{"",	0, (char *)0,		0,			FUNC_NULL }
@


11.19
log
@Converted from rt_tabdata to bn_tabdata
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_plastic.c,v 11.18 1998/12/11 06:00:33 mike Exp $ (ARL)";
d122 1
a122 1
struct rt_vls	*matparm;
d129 2
a130 2
	RT_VLS_CHECK( matparm );
	GETSTRUCT( pp, phong_specific );
d144 1
a144 1
		rt_free( (char *)pp, "phong_specific" );
d159 1
a159 1
struct rt_vls	*matparm;
d166 2
a167 2
	RT_VLS_CHECK( matparm );
	GETSTRUCT( pp, phong_specific );
d181 1
a181 1
		rt_free( (char *)pp, "phong_specific" );
d196 1
a196 1
struct rt_vls	*matparm;
d203 2
a204 2
	RT_VLS_CHECK( matparm );
	GETSTRUCT( pp, phong_specific );
d219 1
a219 1
		rt_free( (char *)pp, "phong_specific" );
d246 1
a246 1
	rt_free( cp, "phong_specific" );
d342 1
a342 1
	if( ps->magic != PL_MAGIC )  rt_log("phong_render: bad magic\n");
d369 1
a369 1
			rt_log("cosAmb=1+%g (x%d,y%d,lvl%d)\n", cosine-1,
d409 1
a409 1
				rt_log("cosI=1+%g (x%d,y%d,lvl%d)\n", cosine-1,
d436 1
a436 1
				rt_log("cosS=1+%g (x%d,y%d,lvl%d)\n", cosine-1,
d491 1
a491 1
		rt_log("phg_ipow(%g,%d) bad\n", d, cnt);
@


11.18
log
@Added preliminary multispectral support.
Improved some of the RGB code to take advantage of newer vmath.h macros.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_plastic.c,v 11.17 1998/09/22 01:29:55 mike Exp $ (ARL)";
a38 3
#if RT_MULTISPECTRAL
# include "tabdata.h"
#endif
d50 1
a50 1
extern CONST struct rt_table	*spectrum;	/* from rttherm/viewtherm.c */
d334 1
a334 1
	struct rt_tabdata	*ms_matcolor = RT_TABDATA_NULL;
d361 1
a361 1
	ms_matcolor = rt_tabdata_dup( swp->msw_color );
d375 1
a375 1
		rt_tabdata_scale( swp->msw_color, ms_matcolor, cosine );
d381 1
a381 1
		rt_tabdata_constval( swp->msw_color, 0.0 );
d414 1
a414 1
			rt_tabdata_incr_mul3_scale( swp->msw_color,
d441 1
a441 1
			rt_tabdata_incr_mul2_scale( swp->msw_color,
d471 1
a471 1
	rt_tabdata_free(ms_matcolor);
@


11.17
log
@Moved optical shaders from rt/ to liboptical/
The only modifications involved moving and splitting
rt/material.h into h/shadefuncs.h and h/shadework.h,
and in changing the calling sequence to mlib_setup() in rt/material.c

Now the only shader function called directly by RT is
in liboptical/init.c: optical_shader_init().
It adds all the individual shaders to the "mfuncs" shader list.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
d39 3
d52 4
d327 4
a330 1
	register fastf_t *intensity, *to_light;
d336 3
d341 1
d363 3
d367 1
d377 3
d381 1
d383 3
d387 1
d404 1
d406 1
d416 7
d424 1
a424 3
			VELMUL( work, lp->lt_color,
				intensity );
			VELMUL( cprod, matcolor, work );
d426 2
a427 1
				refl, cprod );
d443 7
d462 1
a462 1
#endif
d467 1
d472 4
@


11.16
log
@Can't make "struct mfuncs" a CONST, because the forward link needs
to be filled in at runtime, and some compilers put CONST data into
read-only pages (like FreeBSD).
@
text
@d13 2
a14 3
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
d16 5
d22 2
a23 2
 *	This software is Copyright (C) 1985 by the United States Army.
 *	All rights reserved.
d26 1
a26 1
static char RCSplastic[] = "@@(#)$Header: /c/CVS/brlcad/rt/sh_plastic.c,v 11.15 1997/12/31 09:01:40 mike Exp $ (BRL)";
d37 5
a41 3
#include "./rdebug.h"
#include "./material.h"
#include "./light.h"
@


11.15
log
@Required magic number to be first in mfunc table,
consistent with all other BRL-CAD magic numbers.
Required magic number to be initialized at compile time.
Added code to check the magic numbers.
Made the xxx_mfunc arrays CONST, so they can't get trashed by
runtime runaway pointer problems.
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: /m/cad/rt/RCS/sh_plastic.c,v 11.14 1997/12/31 08:15:45 mike Exp mike $ (BRL)";
d82 2
a83 1
CONST struct mfuncs phg_mfuncs[] = {
@


11.14
log
@Initialized magic numbers
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: /m/cad/rt/RCS/sh_plastic.c,v 11.13 1997/12/16 06:25:54 mike Exp mike $ (BRL)";
d82 2
a83 2
struct mfuncs phg_mfuncs[] = {
	{"default",	MF_MAGIC,	0,		MFI_NORMAL,	0,
d86 1
a86 1
	{"plastic",	MF_MAGIC,	0,		MFI_NORMAL,	0,
d89 1
a89 1
	{"mirror",	MF_MAGIC,	0,		MFI_NORMAL,	0,
d92 1
a92 1
	{"glass",	MF_MAGIC,	0,		MFI_NORMAL,	0,
d95 1
a95 1
	{(char *)0,	0,		0,		0,	0,
@


11.13
log
@Made debugging message conditional on RDEBUG_SHADE
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: /m/cad/rt/RCS/sh_plastic.c,v 11.12 1997/12/09 04:45:30 butler Exp mike $ (BRL)";
d83 1
a83 1
	{"default",	0,		0,		MFI_NORMAL,	0,
d86 1
a86 1
	{"plastic",	0,		0,		MFI_NORMAL,	0,
d89 1
a89 1
	{"mirror",	0,		0,		MFI_NORMAL,	0,
d92 1
a92 1
	{"glass",	0,		0,		MFI_NORMAL,	0,
@


11.12
log
@has to do it's own light visibility calculations now.
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: /m/cad/rt/RCS/sh_plastic.c,v 11.11 1997/11/25 22:18:44 butler Exp butler $ (BRL)";
d335 2
a336 1
			bu_log("calling rr_render from phong\n");
@


11.11
log
@fixed typo
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: /m/cad/rt/RCS/sh_plastic.c,v 11.10 1997/11/25 22:16:43 butler Exp butler $ (BRL)";
d53 1
d83 1
a83 1
	{"default",	0,		0,		MFI_NORMAL|MFI_LIGHT,	0,
d86 1
a86 1
	{"plastic",	0,		0,		MFI_NORMAL|MFI_LIGHT,	0,
d89 1
a89 1
	{"mirror",	0,		0,		MFI_NORMAL|MFI_LIGHT,	0,
d92 1
a92 1
	{"glass",	0,		0,		MFI_NORMAL|MFI_LIGHT,	0,
d130 1
d167 1
d205 1
d334 2
a335 1
		if( swp->sw_reflect > 0 || swp->sw_transmit > 0 )
d337 1
d355 7
@


11.10
log
@updated all shaders so that _setup had mfp and rtip parameters
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: /m/cad/rt/RCS/sh_plastic.c,v 11.9 1997/06/05 05:05:04 butler Exp butler $ (BRL)";
a183 1
{
d186 1
@


11.9
log
@Christophe Shlick's fast approximation to phong specular term
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: /m/cad/rt/RCS/sh_plastic.c,v 11.8 1996/08/31 08:46:01 butler Exp butler $ (BRL)";
d108 1
a108 1
phong_setup( rp, matparm, dpp )
d112 2
d144 1
a144 1
mirror_setup( rp, matparm, dpp )
d148 2
d180 1
a180 1
glass_setup( rp, matparm, dpp )
d185 2
@


11.8
log
@bu_struct_print
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: /m/cad/rt/RCS/sh_plastic.c,v 11.7 1996/08/31 08:29:28 butler Exp butler $ (BRL)";
d37 3
d98 1
d100 1
d383 10
d394 1
d406 1
d429 1
@


11.7
log
@bu_struct_parse
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: /m/cad/rt/RCS/sh_plastic.c,v 11.6 1996/08/30 00:08:21 butler Exp butler $ (BRL)";
d210 1
a210 1
	bu_structprint(rp->reg_name, phong_parse, (char *)dp);
d312 1
a312 1
		bu_structprint( "phong_render", phong_parse, (char *)ps );
@


11.6
log
@structparse moved to libbu
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: /m/cad/rt/RCS/sh_plastic.c,v 11.5 1996/05/09 03:25:47 butler Exp butler $ (BRL)";
d123 1
a123 1
	if( bu_structparse( matparm, phong_parse, (char *)pp ) < 0 )  {
d157 1
a157 1
	if( bu_structparse( matparm, phong_parse, (char *)pp ) < 0 )  {
d192 1
a192 1
	if( bu_structparse( matparm, phong_parse, (char *)pp ) < 0 )  {
@


11.5
log
@nit picking.
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: /m/cad/rt/RCS/sh_plastic.c,v 11.4 1996/05/07 19:26:36 jra Exp butler $ (BRL)";
d55 1
a55 1
struct structparse phong_parse[] = {
d123 1
a123 1
	if( rt_structparse( matparm, phong_parse, (char *)pp ) < 0 )  {
d157 1
a157 1
	if( rt_structparse( matparm, phong_parse, (char *)pp ) < 0 )  {
d192 1
a192 1
	if( rt_structparse( matparm, phong_parse, (char *)pp ) < 0 )  {
d210 1
a210 1
	rt_structprint(rp->reg_name, phong_parse, (char *)dp);
d312 1
a312 1
		rt_structprint( "phong_render", phong_parse, (char *)ps );
@


11.4
log
@Individual shaders now call rr_render() directly.
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: /m/cad/rt/RCS/sh_plastic.c,v 11.3 1995/12/11 20:22:45 jra Exp jra $ (BRL)";
d318 1
a318 2
	if( swp->sw_xmitonly )
	{
@


11.3
log
@Added a debug message.
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: /m/cad/rt/RCS/sh_plastic.c,v 11.2 1995/10/20 04:43:53 butler Exp jra $ (BRL)";
d318 6
a323 1
	if( swp->sw_xmitonly )  return(1);	/* done */
d386 2
@


11.2
log
@edited mfuncs table to account for new "mf_flags" element in struct mfuncs.
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: /m/cad/rt/RCS/sh_plastic.c,v 11.1 1995/01/04 10:01:08 mike Rel4_4 butler $ (BRL)";
d310 3
@


11.1
log
@Release_4.4
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: /m/cad/rt/RCS/sh_plastic.c,v 10.2 94/08/11 02:25:41 gdurf Exp $ (BRL)";
d79 1
a79 1
	{"default",	0,		0,		MFI_NORMAL|MFI_LIGHT,
d82 1
a82 1
	{"plastic",	0,		0,		MFI_NORMAL|MFI_LIGHT,
d85 1
a85 1
	{"mirror",	0,		0,		MFI_NORMAL|MFI_LIGHT,
d88 1
a88 1
	{"glass",	0,		0,		MFI_NORMAL|MFI_LIGHT,
d91 1
a91 1
	{(char *)0,	0,		0,		0,
@


10.2
log
@Added include of conf.h
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: /m/cad/rt/RCS/sh_plastic.c,v 10.1 1991/10/12 06:42:10 mike Rel4_0 gdurf $ (BRL)";
@


10.1
log
@Release_4.0
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: /m/cad/rt/RCS/sh_plastic.c,v 9.8 91/09/27 16:02:20 mike Exp $ (BRL)";
d24 2
@


9.8
log
@Made extintion more specific
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: /m/cad/rt/RCS/sh_plastic.c,v 9.7 91/07/06 00:35:20 mike Exp Locker: mike $ (BRL)";
@


9.7
log
@ANSI structure initialization
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: /m/cad/rt/RCS/sh_plastic.c,v 9.6 91/02/17 20:15:53 mike Exp $ (BRL)";
d65 1
@


9.6
log
@Check return code from rt_structparse()
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: /m/cad/rt/RCS/sh_plastic.c,v 9.5 91/01/05 03:09:13 mike Exp $ (BRL)";
d54 14
a67 14
	"%d",	1, "shine",		PL_O(shine),		FUNC_NULL,
	"%d",	1, "sh",		PL_O(shine),		FUNC_NULL,
	"%f",	1, "specular",		PL_O(wgt_specular),	FUNC_NULL,
	"%f",	1, "sp",		PL_O(wgt_specular),	FUNC_NULL,
	"%f",	1, "diffuse",		PL_O(wgt_diffuse),	FUNC_NULL,
	"%f",	1, "di",		PL_O(wgt_diffuse),	FUNC_NULL,
	"%f",	1, "transmit",		PL_O(transmit),		FUNC_NULL,
	"%f",	1, "tr",		PL_O(transmit),		FUNC_NULL,
	"%f",	1, "reflect",		PL_O(reflect),		FUNC_NULL,
	"%f",	1, "re",		PL_O(reflect),		FUNC_NULL,
	"%f",	1, "ri",		PL_O(refrac_index),	FUNC_NULL,
	"%f",	1, "extinction",	PL_O(extinction),	FUNC_NULL,
	"%f",	1, "ex",		PL_O(extinction),	FUNC_NULL,
	"",	0, (char *)0,		0,			FUNC_NULL
d76 2
a77 2
	"default",	0,		0,		MFI_NORMAL|MFI_LIGHT,
	phong_setup,	phong_render,	phong_print,	phong_free,
d79 2
a80 2
	"plastic",	0,		0,		MFI_NORMAL|MFI_LIGHT,
	phong_setup,	phong_render,	phong_print,	phong_free,
d82 2
a83 2
	"mirror",	0,		0,		MFI_NORMAL|MFI_LIGHT,
	mirror_setup,	phong_render,	phong_print,	phong_free,
d85 2
a86 2
	"glass",	0,		0,		MFI_NORMAL|MFI_LIGHT,
	glass_setup,	phong_render,	phong_print,	phong_free,
d88 2
a89 2
	(char *)0,	0,		0,		0,
	0,		0,		0,		0
@


9.5
log
@Converted to new format for fmt entry in structparse
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: /m/cad/rt/RCS/sh_plastic.c,v 9.4 90/12/12 16:35:07 butler Exp $ (BRL)";
d120 4
a123 1
	rt_structparse( matparm, phong_parse, (char *)pp );
d154 4
a157 1
	rt_structparse( matparm, phong_parse, (char *)pp );
d189 4
a192 1
	rt_structparse( matparm, phong_parse, (char *)pp );
@


9.4
log
@modified to reflect changes in structparse format
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: /m/cad/rt/RCS/sh_plastic.c,v 9.3 90/12/08 08:58:11 butler Exp $ (BRL)";
d67 1
a67 1
	(char *)0, 0, (char *)0,	0,			FUNC_NULL
@


9.3
log
@changed material property parameter to be struct rt_vls
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: /m/cad/rt/RCS/sh_plastic.c,v 9.2 90/11/01 11:18:10 mike Exp $ (BRL)";
d54 14
a67 14
	"%d",	"shine",	PL_O(shine),		FUNC_NULL,
	"%d",	"sh",		PL_O(shine),		FUNC_NULL,
	"%f",	"specular",	PL_O(wgt_specular),	FUNC_NULL,
	"%f",	"sp",		PL_O(wgt_specular),	FUNC_NULL,
	"%f",	"diffuse",	PL_O(wgt_diffuse),	FUNC_NULL,
	"%f",	"di",		PL_O(wgt_diffuse),	FUNC_NULL,
	"%f",	"transmit",	PL_O(transmit),		FUNC_NULL,
	"%f",	"tr",		PL_O(transmit),		FUNC_NULL,
	"%f",	"reflect",	PL_O(reflect),		FUNC_NULL,
	"%f",	"re",		PL_O(reflect),		FUNC_NULL,
	"%f",	"ri",		PL_O(refrac_index),	FUNC_NULL,
	"%f",	"extinction",	PL_O(extinction),	FUNC_NULL,
	"%f",	"ex",		PL_O(extinction),	FUNC_NULL,
	(char *)0,(char *)0,	0,			FUNC_NULL
@


9.2
log
@Added magic number protection
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: /m/cad/rt/RCS/sh_plastic.c,v 9.1 89/05/19 05:59:36 mike Rel3_5 $ (BRL)";
d102 1
a102 1
char	*matparm;
d107 1
d133 1
a133 1
char	*matparm;
d138 1
d164 1
a164 1
char	*matparm;
d169 1
@


9.1
log
@Release_3.5
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: sh_plastic.c,v 8.4 89/04/30 20:40:06 mike Exp $ (BRL)";
d40 1
d49 1
d110 1
d140 1
d170 1
d293 2
@


8.4
log
@No longer depends on mathatb.h
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: sh_plastic.c,v 8.3 89/04/04 05:02:02 mike Locked $ (BRL)";
@


8.3
log
@Converted to new way of representing structure offsets.
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 8.2 88/12/27 16:35:03 mike Locked $ (BRL)";
a32 1
#include "./mathtab.h"
@


8.2
log
@Converted matparse --> structparse
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 8.1 88/10/05 00:32:57 mike Locked $ (BRL)";
d50 1
d53 14
a66 14
	"%d",	"shine",	(stroff_t)&(PL_NULL->shine),		FUNC_NULL,
	"%d",	"sh",		(stroff_t)&(PL_NULL->shine),		FUNC_NULL,
	"%f",	"specular",	(stroff_t)&(PL_NULL->wgt_specular),	FUNC_NULL,
	"%f",	"sp",		(stroff_t)&(PL_NULL->wgt_specular),	FUNC_NULL,
	"%f",	"diffuse",	(stroff_t)&(PL_NULL->wgt_diffuse),	FUNC_NULL,
	"%f",	"di",		(stroff_t)&(PL_NULL->wgt_diffuse),	FUNC_NULL,
	"%f",	"transmit",	(stroff_t)&(PL_NULL->transmit),		FUNC_NULL,
	"%f",	"tr",		(stroff_t)&(PL_NULL->transmit),		FUNC_NULL,
	"%f",	"reflect",	(stroff_t)&(PL_NULL->reflect),		FUNC_NULL,
	"%f",	"re",		(stroff_t)&(PL_NULL->reflect),		FUNC_NULL,
	"%f",	"ri",		(stroff_t)&(PL_NULL->refrac_index),	FUNC_NULL,
	"%f",	"extinction",	(stroff_t)&(PL_NULL->extinction),	FUNC_NULL,
	"%f",	"ex",		(stroff_t)&(PL_NULL->extinction),	FUNC_NULL,
	(char *)0,(char *)0,	(stroff_t)0,				FUNC_NULL
d117 1
a117 1
	rt_structparse( matparm, phong_parse, (stroff_t)pp );
d146 1
a146 1
	rt_structparse( matparm, phong_parse, (stroff_t)pp );
d176 1
a176 1
	rt_structparse( matparm, phong_parse, (stroff_t)pp );
d191 1
a191 1
	rt_structprint(rp->reg_name, phong_parse, (stroff_t)dp);
@


8.1
log
@Release_3.0
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 7.5 88/08/20 05:07:54 mike Exp $ (BRL)";
d51 15
a65 15
struct matparse phong_parse[] = {
	"shine",	(mp_off_ty)&(PL_NULL->shine),		"%d",
	"sh",		(mp_off_ty)&(PL_NULL->shine),		"%d",
	"specular",	(mp_off_ty)&(PL_NULL->wgt_specular),	"%f",
	"sp",		(mp_off_ty)&(PL_NULL->wgt_specular),	"%f",
	"diffuse",	(mp_off_ty)&(PL_NULL->wgt_diffuse),	"%f",
	"di",		(mp_off_ty)&(PL_NULL->wgt_diffuse),	"%f",
	"transmit",	(mp_off_ty)&(PL_NULL->transmit),	"%f",
	"tr",		(mp_off_ty)&(PL_NULL->transmit),	"%f",
	"reflect",	(mp_off_ty)&(PL_NULL->reflect),		"%f",
	"re",		(mp_off_ty)&(PL_NULL->reflect),		"%f",
	"ri",		(mp_off_ty)&(PL_NULL->refrac_index),	"%f",
	"extinction",	(mp_off_ty)&(PL_NULL->extinction),	"%f",
	"ex",		(mp_off_ty)&(PL_NULL->extinction),	"%f",
	(char *)0,	(mp_off_ty)0,				(char *)0
d116 1
a116 1
	mlib_parse( matparm, phong_parse, (mp_off_ty)pp );
d145 1
a145 1
	mlib_parse( matparm, phong_parse, (mp_off_ty)pp );
d175 1
a175 1
	mlib_parse( matparm, phong_parse, (mp_off_ty)pp );
d190 1
a190 1
	mlib_print(rp->reg_name, phong_parse, (mp_off_ty)dp);
@


7.5
log
@Added "default" entry to be "plastic".
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 7.4 88/05/14 02:28:18 mike Locked $ (BRL)";
@


7.4
log
@lint fixes
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 7.3 88/03/19 02:33:28 mike Locked $ (BRL)";
d74 3
@


7.3
log
@changed ipow() to phg_ipow()
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 7.2 88/01/26 05:30:03 mike Locked $ (BRL)";
d70 2
a71 2
HIDDEN int phong_print();
HIDDEN int phong_free();
d182 1
a182 1
HIDDEN int
d193 1
a193 1
HIDDEN int
@


7.2
log
@extinction coeff, tolight vectors
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 7.1 87/11/02 23:54:18 mike Rel $ (BRL)";
d87 1
a87 1
extern double ipow();
d346 1
a346 1
				ipow(cosine, ps->shine);
d362 1
a362 1
ipow( d, cnt )
d370 1
a370 1
		rt_log("ipow(%g,%d) bad\n", d, cnt);
@


7.1
log
@Release 2.3
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 6.2 87/09/10 07:14:36 mike Exp $ (BRL)";
d47 1
d63 2
d111 1
d140 1
d170 1
d275 1
a275 1
	register fastf_t *intensity;
a280 1
	vect_t	to_light;
d289 1
d315 1
a317 2
		VSUB2( to_light, lp->lt_pos, swp->sw_hit.hit_point );
		VUNITIZE( to_light );
@


6.2
log
@Light visibility is now determined in viewshade();
supporting light hit&miss routines moved to light.c
plastic.c now merely implements Phong shading.
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 6.1 87/07/11 07:58:48 mike Locked $ (BRL)";
@


6.1
log
@Release 2.0
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 5.6 87/07/06 15:26:37 mike Exp $ (BRL)";
a35 2
extern struct light_specific *LightHeadp;

a36 1
extern int lightmodel;		/* lighting model # to use */
d71 1
a71 1
	"plastic",	0,		0,		MFI_NORMAL,
d74 1
a74 1
	"mirror",	0,		0,		MFI_NORMAL,
d77 1
a77 1
	"glass",	0,		0,		MFI_NORMAL,
a83 1
extern int light_hit(), light_miss();
a260 1
static char *phong_hack = "light visibility?";
d269 9
a277 10
	auto struct application sub_ap;
	auto int light_visible;
	auto fastf_t	d_a;		/* ambient diffuse */
	auto fastf_t	cosAmb;
	auto fastf_t	f;
	auto vect_t	work;
	auto vect_t	reflected;
	auto vect_t	to_eye;
	auto vect_t	to_light;
	auto point_t	matcolor;		/* Material color */
d284 1
d286 1
a286 4
	/**** DO NOT RECURSE on light rays XXX hack XXX ****/
	if( ap->a_purpose == phong_hack )  {
		return(1);
	}
a287 7
	VREVERSE( to_eye, ap->a_ray.r_dir );

	/* Diminish intensity of reflected light as a function of
	 * the distance from your eye.
	 */
/**	dist_gradient = kCons / (swp->sw_hit.hit_dist + cCons);  */

d289 3
a291 4
	d_a = 0;
	if( (cosAmb = VDOT( swp->sw_hit.hit_normal, to_eye )) > 0.0 )  {
		if( cosAmb > 1.00001 )  {
			rt_log("cosAmb=1+%g (x%d,y%d,lvl%d)\n", cosAmb-1,
d293 1
a293 1
			cosAmb = 1;
d295 4
a298 1
		d_a = cosAmb * AmbientIntensity;
a299 2
	VMOVE( matcolor, swp->sw_color );
	VSCALE( swp->sw_color, matcolor, d_a );
d302 1
a302 2
	for( lp=LightHeadp; lp; lp = lp->lt_forw )  {
		FAST fastf_t f;
d304 2
a305 25
		if( lp->lt_explicit )  {
			/* Fire ray at light source to check for shadowing */
			/* This SHOULD actually return an energy value */
			sub_ap = *ap;		/* struct copy */
			sub_ap.a_hit = light_hit;
			sub_ap.a_miss = light_miss;
			sub_ap.a_level = 0;
			VMOVE( sub_ap.a_ray.r_pt, swp->sw_hit.hit_point );
			
			/* Dither light pos for penumbra by +/- 0.5 light radius */
			/* This presently makes a cubical light source distribution */
			f = lp->lt_radius * 0.9;
			sub_ap.a_ray.r_dir[X] =  lp->lt_pos[X] + rand_half()*f - swp->sw_hit.hit_point[X];
			sub_ap.a_ray.r_dir[Y] =  lp->lt_pos[Y] + rand_half()*f - swp->sw_hit.hit_point[Y];
			sub_ap.a_ray.r_dir[Z] =  lp->lt_pos[Z] + rand_half()*f - swp->sw_hit.hit_point[Z];
			VUNITIZE( sub_ap.a_ray.r_dir );
			VSETALL( sub_ap.a_color, 1 );	/* vis intens so far */
			sub_ap.a_purpose = "light visibility?";
			sub_ap.a_purpose = phong_hack;
			light_visible = rt_shootray( &sub_ap );
			/* sub_ap.a_color now contains visible fraction */
		} else {
			light_visible = 1;
			VSETALL( sub_ap.a_color, 1 );
		}
d307 2
a308 5
		/* If not shadowed add this light contribution */
		if( light_visible )  {
			auto fastf_t cosI;
			auto fastf_t cosS;
			vect_t light_intensity;
d310 8
a317 17
			/* Diffuse reflectance from this light source. */
			VSUB2( to_light, lp->lt_pos, swp->sw_hit.hit_point );
			VUNITIZE( to_light );
			if( (cosI = VDOT( swp->sw_hit.hit_normal, to_light )) > 0.0 )  {
				fastf_t	Rd;
				vect_t	cprod;	/* color product */
				if( cosI > 1.00001 )  {
					rt_log("cosI=1+%g (x%d,y%d,lvl%d)\n", cosI-1,
						ap->a_x, ap->a_y, ap->a_level);
					cosI = 1;
				}
				Rd = cosI * lp->lt_fraction * ps->wgt_diffuse;
				VELMUL( light_intensity, lp->lt_color,
					sub_ap.a_color );
				VELMUL( cprod, matcolor, light_intensity );
				VJOIN1( swp->sw_color, swp->sw_color,
					Rd, cprod );
d319 7
d327 12
a338 20
			/* Calculate specular reflectance.
			 *	Reflected ray = (2 * cos(i) * Normal) - Incident ray.
			 * 	Cos(s) = Reflected ray DOT Incident ray.
			 */
			cosI *= 2;
			VSCALE( work, swp->sw_hit.hit_normal, cosI );
			VSUB2( reflected, work, to_light );
			if( (cosS = VDOT( reflected, to_eye )) > 0 )  {
				fastf_t Rs;
				if( cosS > 1.00001 )  {
					rt_log("cosS=1+%g (x%d,y%d,lvl%d)\n", cosS-1,
						ap->a_x, ap->a_y, ap->a_level);
					cosS = 1;
				}
				Rs = ps->wgt_specular * lp->lt_fraction *
					ipow(cosS, ps->shine);
				VELMUL( light_intensity, lp->lt_color,
					sub_ap.a_color );
				VJOIN1( swp->sw_color, swp->sw_color,
					Rs, light_intensity );
d340 6
a372 132

static struct shadework light_default = {
	0.0,				/* xmit */
	0.0,				/* reflect */
	1.0,				/* refractive index */
	1.0, 1.0, 1.0,			/* color: white */
	/* rest are zeros */
};

/* 
 *			L I G H T _ H I T
 *
 *  Input -
 *	a_color[] contains the fraction of a the light that will be
 *	propagated back along the ray, so far.  If this gets too small,
 *	recursion through lots of glass ought to stop.
 *  Output -
 *	a_color[] contains the fraction of light that can be seen.
 *	RGB transmissions are separately indicated, to allow simplistic
 *	colored glass (with apologies to Roy Hall).
 *
 *  These shadow functions return a boolean "light_visible".
 * 
 *  This is a simplified algorithm, and could be improved.
 *  Reflected light can't be dealt with at all.
 *
 *  Would also be nice to return an actual energy level, rather than
 *  a boolean, which could account for distance, etc.
 */
light_hit(ap, PartHeadp)
struct application *ap;
struct partition *PartHeadp;
{
	register struct partition *pp;
	register struct region	*regp;
	struct application	sub_ap;
	struct shadework	sw;
	extern int	light_render();
	vect_t	filter_color;
	int	light_visible;

	for( pp=PartHeadp->pt_forw; pp != PartHeadp; pp = pp->pt_forw )
		if( pp->pt_outhit->hit_dist >= 0.0 )  break;
	if( pp == PartHeadp )  {
		rt_log("light_hit:  no hit out front?\n");
		light_visible = 0;
		goto out;
	}
	regp = pp->pt_regionp;

	/* Check to see if we hit a light source */
	if( ((struct mfuncs *)(regp->reg_mfuncs))->mf_render == light_render )  {
		VSETALL( ap->a_color, 1 );
		light_visible = 1;
		goto out;
	}

	/* If we hit an entirely opaque object, this light is invisible */
	if( pp->pt_outhit->hit_dist >= INFINITY ||
	    regp->reg_transmit == 0 )  {
		VSETALL( ap->a_color, 0 );
		light_visible = 0;
		goto out;
	}

	/*  See if any further contributions will mater */
	if( ap->a_color[0] + ap->a_color[1] + ap->a_color[2] < 0.01 )  {
	    	/* Any light energy is "fully" attenuated by here */
		VSETALL( ap->a_color, 0 );
		light_visible = 0;
		goto out;
	}

	/*
	 *  Determine transparency parameters of this object.
	 */
	sw = light_default;		/* struct copy */
	viewshade( ap, pp, &sw );
	VSCALE( filter_color, sw.sw_color, sw.sw_transmit );
	if( filter_color[0] + filter_color[1] + filter_color[2] < 0.01 )  {
	    	/* Any recursion won't be significant */
		VSETALL( ap->a_color, 0 );
		light_visible = 0;
		goto out;
	}

	/*
	 * Push on to exit point, and trace on from there.
	 * Transmission so far is passed along in sub_ap.a_color[];
	 * Don't even think of trying to refract, or we will miss the light!
	 */
	sub_ap = *ap;			/* struct copy */
	sub_ap.a_level = ap->a_level+1;
	{
		FAST fastf_t f;
		f = pp->pt_outhit->hit_dist+0.0001;
		VJOIN1(sub_ap.a_ray.r_pt, ap->a_ray.r_pt, f, ap->a_ray.r_dir);
	}
	sub_ap.a_purpose = "light transmission after filtering";
	light_visible = rt_shootray( &sub_ap );

	VELMUL( ap->a_color, sub_ap.a_color, filter_color );
out:
	if( rdebug & RDEBUG_LIGHT ) rt_log("light %s vis=%d\n", regp->reg_name, light_visible);
	return(light_visible);
}

/*
 *  			L I G H T _ M I S S
 *  
 *  If there is no explicit light solid in the model, we will always "miss"
 *  the light, so return light_visible = TRUE.
 */
/* ARGSUSED */
light_miss(ap, PartHeadp)
register struct application *ap;
struct partition *PartHeadp;
{
	extern struct light_specific *LightHeadp;

	if( LightHeadp )  {
		/* Explicit lights exist, somehow we missed (dither?) */
		VSETALL( ap->a_color, 0 );
		return(0);		/* light_visible = 0 */
	}
	/* No explicit light -- it's hard to hit */
	VSETALL( ap->a_color, 1 );
	return(1);			/* light_visible = 1 */
}

/* Null function */
nullf() { return(0); }
@


5.6
log
@Added reg_transmit flag handling, converted to viewshade() processing.
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 5.5 87/07/02 02:53:47 mike Locked $ (BRL)";
@


5.5
log
@Modified cos() > 1 tests for Cray's incredible number of digits.
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 5.4 87/06/27 06:46:08 mike Locked $ (BRL)";
d115 2
a116 2
	VSCALE( rp->reg_mater.ma_transmit, 
		rp->reg_mater.ma_color, pp->transmit );
a141 2
	if(rdebug&RDEBUG_MATERIAL)
		mlib_print(rp->reg_name, phong_parse, (mp_off_ty)pp);
d143 2
a144 2
	VSCALE( rp->reg_mater.ma_transmit, 
		rp->reg_mater.ma_color, pp->transmit );
d165 2
a166 2
	pp->transmit = 0.6;
	pp->reflect = 0.3;
a170 2
	if(rdebug&RDEBUG_MATERIAL)
		mlib_print(rp->reg_name, phong_parse, (mp_off_ty)pp);
d172 2
a173 2
	VSCALE( rp->reg_mater.ma_transmit, 
		rp->reg_mater.ma_color, pp->transmit );
d265 1
d291 5
d326 1
a326 1
			sub_ap.a_level++;
d337 2
d420 8
d453 6
a458 4
	register struct region *regp;
	struct application sub_ap;
	extern int light_render();
	int ret;
d464 2
a465 1
		return(0);
d472 2
a473 1
		return(1);		/* light_visible = 1 */
d477 2
a478 4
	if( pp->pt_outhit->hit_dist >= INFINITY || (
	    regp->reg_mater.ma_transmit[0] +
	    regp->reg_mater.ma_transmit[1] +
	    regp->reg_mater.ma_transmit[2] <= 0 ) )  {
d480 2
a481 1
		return(0);			/* light_visible = 0 */
d484 1
a484 3
	/*
	 * We hit a transparant object.  Continue on.
	 */
d488 2
a489 1
		return(0);		/* light_visible = 0 */
d492 15
a506 1
	/* Push on to exit point, and trace on from there.
d508 1
d517 7
a523 4
	ret = rt_shootray( &sub_ap );
	VELMUL( ap->a_color, sub_ap.a_color,
		regp->reg_mater.ma_transmit );
	return(ret);			/* light_visible = ret */
@


5.4
log
@rendering parameter changes
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 5.3 87/06/27 03:45:57 phil Locked $ (BRL)";
d305 1
a305 1
			rt_log("cosAmb=%g (x%d,y%d,lvl%d)\n", cosAmb,
d354 2
a355 2
				if( cosI > 1 )  {
					rt_log("cosI=%g (x%d,y%d,lvl%d)\n", cosI,
d376 2
a377 2
				if( cosS > 1 )  {
					rt_log("cosS=%g (x%d,y%d,lvl%d)\n", cosS,
@


5.3
log
@Added support for colored transparant objects
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 5.2 87/06/26 05:57:56 mike Exp $ (BRL)";
d96 1
a96 1
phong_setup( rp )
d98 2
d104 1
a104 1
	rp->reg_udata = (char *)pp;
d113 1
a113 1
	mlib_parse( rp->reg_mater.ma_matparm, phong_parse, (mp_off_ty)pp );
d124 1
a124 1
mirror_setup( rp )
d126 2
d132 1
a132 1
	rp->reg_udata = (char *)pp;
d141 1
a141 1
	mlib_parse( rp->reg_mater.ma_matparm, phong_parse, (mp_off_ty)pp );
d154 1
a154 1
glass_setup( rp )
d156 2
d162 1
a162 1
	rp->reg_udata = (char *)pp;
d172 1
a172 1
	mlib_parse( rp->reg_mater.ma_matparm, phong_parse, (mp_off_ty)pp );
d185 1
a185 1
phong_print( rp )
d187 1
d189 1
a189 1
	mlib_print(rp->reg_name, phong_parse, (mp_off_ty)rp->reg_udata);
d270 1
a270 1
phong_render( ap, pp, swp )
d274 1
d288 1
a288 1
		(struct phong_specific *)pp->pt_regionp->reg_udata;
@


5.2
log
@Added struct shadework support, separated shaders from
reflect/refract code, allowed stacking of shaders.
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 5.1 87/06/24 22:14:50 mike Locked $ (BRL)";
d112 3
d140 3
d161 1
a161 1
	pp->transmit = 0.7;
d163 1
d169 3
d326 1
d328 1
d331 1
d338 1
d352 5
a356 2
				VELMUL( cprod, matcolor, lp->lt_color );
				VJOIN1( swp->sw_color, swp->sw_color, Rd, cprod );
d375 4
a378 1
				VJOIN1( swp->sw_color, swp->sw_color, Rs, lp->lt_color );
d411 9
d422 1
a422 2
 *  This is an incredibly simplistic algorithm, in need of improvement.
 *  If glass is hit, we need to keep going.
d424 3
a426 2
 *  Would also be nice to return an energy level, rather than
 *  a boolean, which could account for lots of interesting effects.
d433 2
d436 1
d444 1
d447 2
a448 1
	if( ((struct mfuncs *)(pp->pt_regionp->reg_mfuncs))->mf_render == light_render )
d450 34
a483 1
	return(0);			/* light_visible = 0 */
d497 9
@


5.1
log
@Release 1.24
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 4.8 87/06/13 03:19:45 mike Exp $ (BRL)";
a40 2
#define MAX_IREFLECT	9	/* Maximum internal reflection level */
#define MAX_BOUNCE	4	/* Maximum recursion level */
d74 1
a74 1
	"plastic",	0,		0,
d77 1
a77 1
	"mirror",	0,		0,
d80 1
a80 1
	"glass",	0,		0,
d83 1
a83 1
	(char *)0,	0,		0,
a86 4
HIDDEN int phg_rmiss();
HIDDEN int phg_rhit();
HIDDEN int phg_refract();

d253 1
a253 1
phong_render( ap, pp )
d255 2
a256 1
register struct partition *pp;
a257 1
	register struct hit *hitp= pp->pt_inhit;
d272 3
a275 35
	/* Get default color-by-ident for region.			*/
	{
		register struct region *rp;
		if( (rp=pp->pt_regionp) == REGION_NULL )  {
			rt_log("bad region pointer\n");
			VSET( ap->a_color, 0.7, 0.7, 0.7 );
			goto finish;
		}
		if( rp->reg_mater.ma_override )  {
			VSET( matcolor,
				rp->reg_mater.ma_rgb[0]/255.,
				rp->reg_mater.ma_rgb[1]/255.,
				rp->reg_mater.ma_rgb[2]/255. );
		} else {
			/* Default color is white (uncolored) */
			VSETALL( matcolor, 1.0 );
		}
	}

	/* Get surface normal for hit point */
	RT_HIT_NORM( hitp, pp->pt_inseg->seg_stp, &(ap->a_ray) );

	/* Temporary check to make sure normals are OK */
	if( hitp->hit_normal[X] < -1.01 || hitp->hit_normal[X] > 1.01 ||
	    hitp->hit_normal[Y] < -1.01 || hitp->hit_normal[Y] > 1.01 ||
	    hitp->hit_normal[Z] < -1.01 || hitp->hit_normal[Z] > 1.01 )  {
	    	VPRINT("phong_render: N", hitp->hit_normal);
		VSET( ap->a_color, 9, 9, 0 );	/* Yellow */
		return(1);
	}
	if( pp->pt_inflip )  {
		VREVERSE( hitp->hit_normal, hitp->hit_normal );
		pp->pt_inflip = 0;
	}

d278 1
a278 1
	/* Diminish intensity of reflected light the as a function of
d281 1
a281 1
/**	dist_gradient = kCons / (hitp->hit_dist + cCons);  */
d285 1
a285 1
	if( (cosAmb = VDOT( hitp->hit_normal, to_eye )) > 0.0 )  {
d293 2
a294 1
	VSCALE( ap->a_color, matcolor, d_a );
d307 1
a307 1
			VMOVE( sub_ap.a_ray.r_pt, hitp->hit_point );
d310 1
d312 3
a314 3
			sub_ap.a_ray.r_dir[X] =  lp->lt_pos[X] + rand_half()*f - hitp->hit_point[X];
			sub_ap.a_ray.r_dir[Y] =  lp->lt_pos[Y] + rand_half()*f - hitp->hit_point[Y];
			sub_ap.a_ray.r_dir[Z] =  lp->lt_pos[Z] + rand_half()*f - hitp->hit_point[Z];
d327 1
a327 1
			VSUB2( to_light, lp->lt_pos, hitp->hit_point );
d329 1
a329 1
			if( (cosI = VDOT( hitp->hit_normal, to_light )) > 0.0 )  {
d339 1
a339 1
				VJOIN1( ap->a_color, ap->a_color, Rd, cprod );
d347 1
a347 1
			VSCALE( work, hitp->hit_normal, cosI );
d358 1
a358 1
				VJOIN1( ap->a_color, ap->a_color, Rs, lp->lt_color );
a361 113

	if( (ps->reflect <= 0 && ps->transmit <= 0) ||
	    ap->a_level > MAX_BOUNCE )  {
		/* Nothing more to do for this ray */
		goto finish;
	}

	/*
	 *  Diminish base color appropriately, and add in
	 *  contributions from mirror reflection & transparency
	 */
	f = 1 - (ps->reflect + ps->transmit);
	if( f > 0 )  {
		VSCALE( ap->a_color, ap->a_color, f );
	}
	if( ps->reflect > 0 )  {
		/* Mirror reflection */
		sub_ap = *ap;		/* struct copy */
		sub_ap.a_level = ap->a_level+1;
		sub_ap.a_onehit = 1;
		VMOVE( sub_ap.a_ray.r_pt, hitp->hit_point );
		f = 2 * VDOT( to_eye, hitp->hit_normal );
		VSCALE( work, hitp->hit_normal, f );
		/* I have been told this has unit length */
		VSUB2( sub_ap.a_ray.r_dir, work, to_eye );
		(void)rt_shootray( &sub_ap );
		VJOIN1(ap->a_color, ap->a_color, ps->reflect, sub_ap.a_color);
	}
	if( ps->transmit > 0 )  {
		LOCAL vect_t incident_dir;

		/* Calculate refraction at entrance. */
		sub_ap = *ap;		/* struct copy */
		sub_ap.a_level = (ap->a_level+1) * 100;	/* flag */
		sub_ap.a_onehit = 1;
		sub_ap.a_user = (int)(pp->pt_regionp);
		VMOVE( sub_ap.a_ray.r_pt, hitp->hit_point );
		VMOVE( incident_dir, ap->a_ray.r_dir );
		if( !phg_refract(incident_dir, /* Incident ray (IN) */
			hitp->hit_normal,
			RI_AIR, ps->refrac_index,
			sub_ap.a_ray.r_dir	/* Refracted ray (OUT) */
		) )  {
			/* Reflected back outside solid */
			goto do_exit;
		}
		/* Find new exit point from the inside. */
do_inside:
		sub_ap.a_hit =  phg_rhit;
		sub_ap.a_miss = phg_rmiss;
		if( rt_shootray( &sub_ap ) == 0 )  {
			if(rdebug&RDEBUG_HITS)rt_log("phong: Refracted ray missed '%s' -- RETRYING, lvl=%d\n",
				pp->pt_inseg->seg_stp->st_name,
				sub_ap.a_level );
			/* Back off just a little bit, and try again */
			/* Useful when striking exactly in corners */
			VJOIN1( sub_ap.a_ray.r_pt, sub_ap.a_ray.r_pt,
				-3.0, incident_dir );
			if( rt_shootray( &sub_ap ) == 0 )  {
				rt_log("phong: Refracted ray missed 2x '%s', lvl=%d\n",
					pp->pt_inseg->seg_stp->st_name,
					sub_ap.a_level );
				VPRINT("pt", sub_ap.a_ray.r_pt );
				VPRINT("dir", sub_ap.a_ray.r_dir );
				VSET( ap->a_color, 0, 99, 0 );	/* green */
				goto finish;		/* abandon hope */
			}
		}
		/* NOTE: phg_rhit returns EXIT Point in sub_ap.a_uvec,
		 *  and returns EXIT Normal in sub_ap.a_vvec.
		 */
		if( rdebug&RDEBUG_RAYWRITE )  {
			wraypts( sub_ap.a_ray.r_pt, sub_ap.a_uvec,
				ap, stdout );
		}
		if( rdebug&RDEBUG_RAYPLOT )  {
			pl_color( stdout, 0, 255, 0 );
			rt_drawvec( stdout, ap->a_rt_i,
				sub_ap.a_ray.r_pt,
				sub_ap.a_uvec );
		}
		VMOVE( sub_ap.a_ray.r_pt, sub_ap.a_uvec );

		/* Calculate refraction at exit. */
		VMOVE( incident_dir, sub_ap.a_ray.r_dir );
		if( !phg_refract( incident_dir,		/* input direction */
			sub_ap.a_vvec,			/* exit normal */
			ps->refrac_index, RI_AIR,
			sub_ap.a_ray.r_dir		/* output direction */
		) )  {
			/* Reflected internally -- keep going */
			if( (++sub_ap.a_level)%100 > MAX_IREFLECT )  {
				rt_log("phong: %s Excessive internal reflection (x%d, y%d, lvl=%d)\n",
					pp->pt_inseg->seg_stp->st_name,
					sub_ap.a_x, sub_ap.a_y, sub_ap.a_level );
				if(rdebug&RDEBUG_SHOWERR) {
					VSET( ap->a_color, 0, 9, 0 );	/* green */
				} else {
					VSETALL( ap->a_color, .18 ); /* 18% grey */
				}
				goto finish;
			}
			goto do_inside;
		}
do_exit:
		sub_ap.a_hit =  ap->a_hit;
		sub_ap.a_miss = ap->a_miss;
		sub_ap.a_level++;
		(void) rt_shootray( &sub_ap );
		VJOIN1( ap->a_color, ap->a_color,
			ps->transmit, sub_ap.a_color );
	}
finish:
a365 159
 *			R F R _ M I S S
 */
HIDDEN int
/*ARGSUSED*/
phg_rmiss( ap, PartHeadp )
register struct application *ap;
struct partition *PartHeadp;
{
	return(0);
}

/*
 *			R F R _ H I T
 *
 *  Implicit Returns -
 *	a_uvec	exit Point
 *	a_vvec	exit Normal
 */
HIDDEN int
phg_rhit( ap, PartHeadp )
register struct application *ap;
struct partition *PartHeadp;
{
	register struct hit	*hitp;
	register struct soltab *stp;
	register struct partition *pp;

	for( pp=PartHeadp->pt_forw; pp != PartHeadp; pp = pp->pt_forw )
		if( pp->pt_outhit->hit_dist > 0.0 )  break;
	if( pp == PartHeadp )  {
		if(rdebug&RDEBUG_SHOWERR)
			rt_log("phg_rhit:  no hit out front?\n");
		goto bad;
	}
	if( pp->pt_regionp != (struct region *)(ap->a_user) )  {
		if(rdebug&RDEBUG_HITS)
			rt_log("phg_rhit:  Ray reflected within %s now in %s!\n",
				((struct region *)(ap->a_user))->reg_name,
				pp->pt_regionp->reg_name );
		goto bad;
	}

	hitp = pp->pt_inhit;
	if( !NEAR_ZERO(hitp->hit_dist, 10) )  {
/**		if(rdebug&RDEBUG_HITS) **/
		{
			stp = pp->pt_inseg->seg_stp;
			RT_HIT_NORM( hitp, stp, &(ap->a_ray) );
			rt_log("phg_rhit:  '%s' inhit %g not near zero!\n",
				stp->st_name, hitp->hit_dist);
			rt_pr_hit("inhit", hitp);
			rt_pr_hit("outhit", pp->pt_outhit);
		}
		goto bad;
	}

	hitp = pp->pt_outhit;
	stp = pp->pt_outseg->seg_stp;
	RT_HIT_NORM( hitp, stp, &(ap->a_ray) );
	if( hitp->hit_dist >= INFINITY )  {
		if(rdebug&RDEBUG_SHOWERR)
			rt_log("phg_rhit:  (%g,%g) bad!\n",
				pp->pt_inhit->hit_dist, hitp->hit_dist);
		goto bad;
	}

	VMOVE( ap->a_uvec, hitp->hit_point );
	/* Safety check */
	if( (rdebug&RDEBUG_SHOWERR) && (
	    !NEAR_ZERO(hitp->hit_normal[X], 1.001) ||
	    !NEAR_ZERO(hitp->hit_normal[Y], 1.001) ||
	    !NEAR_ZERO(hitp->hit_normal[Z], 1.001) ) )  {
	    	rt_log("phg_rhit: defective normal hitting %s\n", stp->st_name);
	    	VPRINT("hit_normal", hitp->hit_normal);
	    	goto bad;
	}
	/* For refraction, want exit normal to point inward. */
	VREVERSE( ap->a_vvec, hitp->hit_normal );
	return(1);

	/* Give serious information when problems are encountered */
bad:
	if(rdebug&RDEBUG_HITS) rt_pr_partitions( ap->a_rt_i, PartHeadp, "phg_rhit" );
	return(0);
}

/*
 *			R E F R A C T
 *
 *	Compute the refracted ray 'v_2' from the incident ray 'v_1' with
 *	the refractive indices 'ri_2' and 'ri_1' respectively.
 *	Using Schnell's Law:
 *
 *		theta_1 = angle of v_1 with surface normal
 *		theta_2 = angle of v_2 with reversed surface normal
 *		ri_1 * sin( theta_1 ) = ri_2 * sin( theta_2 )
 *
 *		sin( theta_2 ) = ri_1/ri_2 * sin( theta_1 )
 *		
 *	The above condition is undefined for ri_1/ri_2 * sin( theta_1 )
 *	being greater than 1, and this represents the condition for total
 *	reflection, the 'critical angle' is the angle theta_1 for which
 *	ri_1/ri_2 * sin( theta_1 ) equals 1.
 *
 *  Returns TRUE if refracted, FALSE if reflected.
 *
 *  Note:  output (v_2) can be same storage as an input.
 */
HIDDEN int
phg_refract( v_1, norml, ri_1, ri_2, v_2 )
register vect_t	v_1;
register vect_t	norml;
double	ri_1, ri_2;
register vect_t	v_2;
{
	LOCAL vect_t	w, u;
	FAST fastf_t	beta;

	if( NEAR_ZERO(ri_1, 0.0001) || NEAR_ZERO( ri_2, 0.0001 ) )  {
		rt_log("phg_refract:ri1=%g, ri2=%g\n", ri_1, ri_2 );
		beta = 1;
	} else {
		beta = ri_1/ri_2;		/* temp */
		if( beta > 10000 )  {
			rt_log("phg_refract:  beta=%g\n", beta);
			beta = 1000;
		}
	}
	VSCALE( w, v_1, beta );
	VCROSS( u, w, norml );
	    	
	/*
	 *	|w X norml| = |w||norml| * sin( theta_1 )
	 *	        |u| = ri_1/ri_2 * sin( theta_1 ) = sin( theta_2 )
	 */
	if( (beta = VDOT( u, u )) > 1.0 )  {
		/*  Past critical angle, total reflection.
		 *  Calculate reflected (bounced) incident ray.
		 */
		VREVERSE( u, v_1 );
		beta = 2 * VDOT( u, norml );
		VSCALE( w, norml, beta );
		VSUB2( v_2, w, u );
		return(0);		/* reflected */
	} else {
		/*
		 * 1 - beta = 1 - sin( theta_2 )^^2
		 *	    = cos( theta_2 )^^2.
		 *     beta = -1.0 * cos( theta_2 ) - Dot( w, norml ).
		 */
		beta = -sqrt( 1.0 - beta) - VDOT( w, norml );
		VSCALE( u, norml, beta );
		VADD2( v_2, w, u );
		return(1);		/* refracted */
	}
	/* NOTREACHED */
}

/*
d414 1
a414 1
	if( pp->pt_regionp->reg_mfuncs->mf_render == light_render )
@


4.8
log
@Changed default refrac_index to non-zero values, so if user overrides
transmit or reflect on plastic or mirror, the RI is sensible.
Probably should test RI for >= 0.01 or something.
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 4.7 87/06/13 01:38:51 mike Locked $ (BRL)";
@


4.7
log
@Moved hit_nothing() into view.c,
fixed potential minor bug in refraction;  more certainly remain.
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 4.6 87/04/10 22:49:26 mike Locked $ (BRL)";
d115 1
a115 1
	pp->refrac_index = 0.0;
d138 1
a138 1
	pp->refrac_index = 0.0;
@


4.6
log
@Adjusted calling sequence of rt_pr_partitions
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 4.5 87/04/01 04:51:36 mike Locked $ (BRL)";
a35 2
extern int colorview();		/* from view.c */

a93 1
extern int hit_nothing();
d503 2
a504 2
		sub_ap.a_hit =  colorview;
		sub_ap.a_miss = hit_nothing;
a742 19

/*
 *			H I T _ N O T H I N G
 *
 *  a_miss() routine called when no part of the model is hit.
 *  Background texture mapping could be done here.
 *  For now, return a pleasant dark blue.
 */
hit_nothing( ap, PartHeadp )
register struct application *ap;
struct partition *PartHeadp;
{
	if( lightmodel == 2 )  {
		VSET( ap->a_color, 0, 0, 0 );
	}  else  {
		VSET( ap->a_color, .25, 0, .5 );	/* Background */
	}
	return(0);
}
@


4.5
log
@Added RDEBUG_PLOTRAY flag, and code to support it.
Gives direct UNIX-plot output of ray paths, clipped to model RPP.
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 4.4 87/03/23 23:48:18 mike Exp $ (BRL)";
d600 1
a600 1
	if(rdebug&RDEBUG_HITS) rt_pr_partitions( PartHeadp, "phg_rhit" );
@


4.4
log
@Revised for new material property interface.
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 4.3 87/03/17 20:19:00 mike Exp $ (BRL)";
a403 7
		if( rdebug&RDEBUG_RAYWRITE )  {
			register struct soltab *stp;
			/* Record passing through the solid */
			stp = pp->pt_outseg->seg_stp;
			RT_HIT_NORM( pp->pt_outhit, stp, &(ap->a_ray) );
			wray( pp, ap, stdout );
		}
d470 1
a470 1
		 *  and returns EXIT Normal in sub_ap.a_color.
d476 6
d487 1
a487 1
			sub_ap.a_color,			/* exit normal */
d534 1
a534 1
 *	a_color	exit Normal
d595 1
a595 1
	VREVERSE( ap->a_color, hitp->hit_normal );
@


4.3
log
@Added multiple lights, added beginnings of command-driven
input capability.
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 4.1 86/12/29 03:48:29 mike Rel1 $ (BRL)";
d72 19
a90 1
extern int phong_render();
d104 1
a104 1
int
a110 1
	rp->reg_ufunc = phong_render;
a120 2
	if(rdebug&RDEBUG_MATERIAL)
		mlib_print(rp->reg_name, phong_parse, (mp_off_ty)pp);
d127 1
a127 1
int
a133 1
	rp->reg_ufunc = phong_render;
d152 1
a152 1
int
a158 1
	rp->reg_ufunc = phong_render;
d174 9
d185 11
d261 1
d726 1
a726 1
	if( pp->pt_regionp->reg_ufunc == light_render )
d746 1
a746 1
nullf() { ; }
@


4.2
log
@Release 1.20 -- First Formal Release
@
text
@d34 1
d38 3
a40 1
/* HACKS from view.c */
a41 3
extern struct soltab *l0stp;
extern vect_t l0color;
extern vect_t l0pos;
d233 1
a235 1
	auto fastf_t	Rd1;
d237 1
a237 1
	auto double	cosI1, cosI2;
d243 1
a243 1
	auto point_t	mcolor;		/* Material color */
d257 1
a257 1
			VSET( mcolor,
d263 1
a263 1
			VSETALL( mcolor, 1.0 );
d290 1
a290 14
	/* Diffuse reflectance from primary light source. */
	VSUB2( to_light, l0pos, hitp->hit_point );
	VUNITIZE( to_light );
	Rd1 = 0;
	if( (cosI1 = VDOT( hitp->hit_normal, to_light )) > 0.0 )  {
		if( cosI1 > 1 )  {
			rt_log("cosI1=%g (x%d,y%d,lvl%d)\n", cosI1,
				ap->a_x, ap->a_y, ap->a_level);
			cosI1 = 1;
		}
		Rd1 = cosI1 * (1 - AmbientIntensity);
	}

	/* Diffuse reflectance from secondary light source (at eye) */
d292 3
a294 3
	if( (cosI2 = VDOT( hitp->hit_normal, to_eye )) > 0.0 )  {
		if( cosI2 > 1.00001 )  {
			rt_log("cosI2=%g (x%d,y%d,lvl%d)\n", cosI2,
d296 1
a296 1
			cosI2 = 1;
d298 1
a298 1
		d_a = cosI2 * AmbientIntensity;
d300 1
d302 2
a303 4
	/* Apply secondary (ambient) (white) lighting. */
	VSCALE( ap->a_color, mcolor, d_a );
	if( l0stp )  {
		/* An actual light solid exists */
d306 19
a324 18
		/* Fire ray at light source to check for shadowing */
		/* This SHOULD actually return an energy value */
		sub_ap = *ap;		/* struct copy */
		sub_ap.a_hit = light_hit;
		sub_ap.a_miss = light_miss;
		sub_ap.a_level++;
		VMOVE( sub_ap.a_ray.r_pt, hitp->hit_point );

		/* Dither light pos for penumbra by +/- 0.5 light radius */
		f = l0stp->st_aradius * 0.9;
		sub_ap.a_ray.r_dir[X] =  l0pos[X] + rand_half()*f - hitp->hit_point[X];
		sub_ap.a_ray.r_dir[Y] =  l0pos[Y] + rand_half()*f - hitp->hit_point[Y];
		sub_ap.a_ray.r_dir[Z] =  l0pos[Z] + rand_half()*f - hitp->hit_point[Z];
		VUNITIZE( sub_ap.a_ray.r_dir );
		light_visible = rt_shootray( &sub_ap );
	} else {
		light_visible = 1;
	}
d326 4
a329 4
	/* If not shadowed add primary lighting. */
	if( light_visible )  {
		auto fastf_t specular;
		auto fastf_t cosS;
d331 15
a345 2
		/* Diffuse */
		VJOIN1( ap->a_color, ap->a_color, Rd1, mcolor );
d347 17
a363 12
		/* Calculate specular reflectance.
		 *	Reflected ray = (2 * cos(i) * Normal) - Incident ray.
		 * 	Cos(s) = Reflected ray DOT Incident ray.
		 */
		cosI1 *= 2;
		VSCALE( work, hitp->hit_normal, cosI1 );
		VSUB2( reflected, work, to_light );
		if( (cosS = VDOT( reflected, to_eye )) > 0 )  {
			if( cosS > 1 )  {
				rt_log("cosS=%g (x%d,y%d,lvl%d)\n", cosS,
					ap->a_x, ap->a_y, ap->a_level);
				cosS = 1;
a364 3
			specular = ps->wgt_specular *
				ipow(cosS, ps->shine);
			VJOIN1( ap->a_color, ap->a_color, specular, l0color );
d682 1
d691 2
a692 2
	/* Check to see if we hit the light source */
	if( pp->pt_inseg->seg_stp == l0stp )
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 1.19 86/12/24 08:23:29 mike Locked $ (BRL)";
@


1.19
log
@Updated for resource struct
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 1.18 86/12/18 16:01:46 mike Locked $ (BRL)";
@


1.18
log
@rdebug.h separated from librt/debug.h
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 1.17 86/12/14 17:54:26 mike Exp $ (BRL)";
d322 1
d325 1
a325 7
		sub_ap.a_onehit = 1;
		sub_ap.a_level = ap->a_level + 1;
		sub_ap.a_x = ap->a_x;
		sub_ap.a_y = ap->a_y;
		sub_ap.a_rt_i = ap->a_rt_i;
		sub_ap.a_rbeam = ap->a_rbeam;
		sub_ap.a_diverge = ap->a_diverge;
a472 3
		sub_ap.a_rt_i = ap->a_rt_i;
		sub_ap.a_rbeam = ap->a_rbeam;
		sub_ap.a_diverge = ap->a_diverge;
@


1.17
log
@Improved ipow().
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 1.16 86/12/10 03:26:08 mike Locked $ (BRL)";
d31 1
a31 1
#include "../librt/debug.h"
d58 12
a69 12
	"shine",	(int)&(PL_NULL->shine),		"%d",
	"sh",		(int)&(PL_NULL->shine),		"%d",
	"specular",	(int)&(PL_NULL->wgt_specular),	"%f",
	"sp",		(int)&(PL_NULL->wgt_specular),	"%f",
	"diffuse",	(int)&(PL_NULL->wgt_diffuse),	"%f",
	"di",		(int)&(PL_NULL->wgt_diffuse),	"%f",
	"transmit",	(int)&(PL_NULL->transmit),	"%f",
	"tr",		(int)&(PL_NULL->transmit),	"%f",
	"reflect",	(int)&(PL_NULL->reflect),	"%f",
	"re",		(int)&(PL_NULL->reflect),	"%f",
	"ri",		(int)&(PL_NULL->refrac_index),	"%f",
	(char *)0,	0,				(char *)0
d103 3
a105 1
	mlib_parse( rp->reg_mater.ma_matparm, phong_parse, (char *)pp );
d129 3
a131 1
	mlib_parse( rp->reg_mater.ma_matparm, phong_parse, (char *)pp );
d155 3
a157 1
	mlib_parse( rp->reg_mater.ma_matparm, phong_parse, (char *)pp );
d366 1
a366 1
				ipow(cosS,(int)ps->shine);
d373 1
a373 1
		if( rt_g.debug&DEBUG_RAYWRITE )  {
d428 1
a428 1
			if(rt_g.debug&DEBUG_HITS)rt_log("phong: Refracted ray missed '%s' -- RETRYING, lvl=%d\n",
d441 1
a441 7
				VSET( ap->a_color, 0, 1, 0 );	/* green */
#ifdef never
odebug= rt_g.debug;
rt_g.debug = DEBUG_ALLRAYS|DEBUG_BOXING|DEBUG_SHOOT;
rt_shootray( &sub_ap );
rt_g.debug = odebug;
#endif
d448 1
a448 1
		if( rt_g.debug&DEBUG_RAYWRITE )  {
d466 1
a466 1
				if(rt_g.debug) {
d521 2
a522 1
		if(rt_g.debug&DEBUG_HITS)rt_log("phg_rhit:  no hit out front?\n");
d526 4
a529 3
		if(rt_g.debug&DEBUG_HITS)rt_log("phg_rhit:  Ray reflected within %s now in %s!\n",
			((struct region *)(ap->a_user))->reg_name,
			pp->pt_regionp->reg_name );
d535 1
a535 1
/**		if(rt_g.debug&DEBUG_HITS) **/
d551 1
a551 1
		if(rt_g.debug&DEBUG_HITS)
d559 2
a560 1
	if( rt_g.debug && (!NEAR_ZERO(hitp->hit_normal[X], 1.001) ||
d573 1
a573 1
	if(rt_g.debug&DEBUG_HITS) rt_pr_partitions( PartHeadp, "phg_rhit" );
@


1.16
log
@Added 2-character abbreviations
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 1.15 86/11/10 21:56:50 mike Locked $ (BRL)";
d656 1
a656 1
	FAST fastf_t result;
d658 5
a662 1
	if( d < 1e-8 )  return(0.0);
d665 1
a665 1
		result *= d;
@


1.15
log
@Made default color be white, not red.
Prevents non-color-override objects (esp. glass)
from turning red!
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 1.14 86/11/07 02:46:11 mike Locked $ (BRL)";
d59 1
d61 1
d63 1
d65 1
d67 1
@


1.14
log
@Changed so that computation of hit_point and hit_norm is done
in the individual material routines, and only as much as needed.
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 1.13 86/11/07 01:46:23 mike Locked $ (BRL)";
d251 2
a252 1
			VSET( mcolor, 1.0, 0.0, 0.0 );	/* default: red */
@


1.13
log
@Changed to perform RT_HIT_NORM() macros where hit_point and hit_norm
are needed.
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 1.12 86/10/26 17:07:02 mike Locked $ (BRL)";
d255 16
d284 1
a284 1
			rt_log("cosI1=%f (x%d,y%d,lvl%d)\n", cosI1,
d295 1
a295 1
			rt_log("cosI2=%f (x%d,y%d,lvl%d)\n", cosI2,
d349 1
a349 1
				rt_log("cosS=%f (x%d,y%d,lvl%d)\n", cosS,
@


1.12
log
@Minor improvements to error colors
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 1.11 86/08/13 11:00:45 mike Exp $ (BRL)";
d349 1
a349 2
			rt_functab[stp->st_id].ft_norm(
				pp->pt_outhit, stp, &(ap->a_ray) );
d511 4
a514 1
		if(rt_g.debug&DEBUG_HITS)  {
d516 1
a516 1
				pp->pt_inseg->seg_stp->st_name, hitp->hit_dist);
d524 2
a532 3
	stp = pp->pt_outseg->seg_stp;
	rt_functab[stp->st_id].ft_norm(
		hitp, stp, &(ap->a_ray) );
d643 11
a653 1
/* These shadow functions return a boolean "light_visible" */
@


1.11
log
@Made cosI2 more tolerant
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 1.10 86/08/12 05:50:45 mike Exp $ (BRL)";
d446 1
a446 1
					VSET( ap->a_color, 0, 1, 0 );	/* green */
d448 1
a448 1
					VSET( ap->a_color, .16, .16, .16 );	/* grey */
@


1.10
log
@Changed to find #include files with CC -I../h
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 1.9 86/08/06 19:59:58 mike Exp $ (BRL)";
d278 1
a278 1
		if( cosI2 > 1 )  {
@


1.9
log
@Print first refraction miss only if debugging is on.
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 1.8 86/07/31 08:28:16 mike Exp $ (BRL)";
d27 4
a30 4
#include "../h/machine.h"
#include "../h/vmath.h"
#include "../h/mater.h"
#include "../h/raytrace.h"
d32 2
a33 2
#include "material.h"
#include "mathtab.h"
@


1.8
log
@Added code to handle case where ray hits internal edge of box
while doing refraction code, and reflected ray leaves the
box "unexpectedly".
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 1.7 86/07/30 03:56:17 mike Exp $ (BRL)";
d401 1
a401 1
			rt_log("phong: Refracted ray missed '%s', lvl=%d\n",
@


1.7
log
@Improved diagnostics
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 1.6 86/07/29 20:22:07 mike Exp $ (BRL)";
d379 2
d382 7
a388 5
		sub_ap.a_level = ap->a_level * 100;	/* flag */
		sub_ap.a_x = ap->a_x;
		sub_ap.a_y = ap->a_y;
		sub_ap.a_rt_i = ap->a_rt_i;
		if( !phg_refract(ap->a_ray.r_dir, /* Incident ray (IN) */
a393 1
			VMOVE( sub_ap.a_ray.r_pt, hitp->hit_point );
a396 1
		VMOVE( sub_ap.a_ray.r_pt, hitp->hit_point );
d401 1
a401 1
			rt_log("phong: Refracted ray missed %s, lvl=%d\n",
d404 19
a422 1
			goto finish;		/* abandon hope */
d434 2
a435 1
		if( !phg_refract( sub_ap.a_ray.r_dir,	/* input direction */
d498 1
a498 1
		if( pp->pt_outhit->hit_dist > 0.01 )  break;
d500 2
a501 2
		rt_log("phg_rhit:  no hit out front?\n");
		return(0);
d503 6
d512 7
a518 4
		rt_log("phg_rhit:   inhit %g not near zero!\n", hitp->hit_dist);
		rt_pr_hit("inhit", hitp);
		rt_pr_hit("outhit", pp->pt_outhit);
		return(0);
d523 4
a526 2
		rt_log("phg_rhit:  (%g,%g) bad!\n", pp->pt_inhit->hit_dist, hitp->hit_dist);
		return(0);
d534 4
a537 4
	if( rt_g.debug && (!NEAR_ZERO(hitp->hit_normal[X], 1) ||
	    !NEAR_ZERO(hitp->hit_normal[Y], 1) ||
	    !NEAR_ZERO(hitp->hit_normal[Z], 1) ) )  {
	    	rt_log("phg_rhit: TROUBLE refracting in %s\n", stp->st_name);
d539 1
a539 1
	    	return(0);
d544 5
@


1.6
log
@Moved initialization of materials to rt.c
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 1.5 86/07/24 06:05:05 mike Exp $ (BRL)";
d367 1
a368 3
		sub_ap.a_hit = colorview;
		sub_ap.a_miss = hit_nothing;
		sub_ap.a_rt_i = ap->a_rt_i;
a369 2
		sub_ap.a_rbeam = ap->a_rbeam;
		sub_ap.a_diverge = ap->a_diverge;
d399 3
a401 1
			rt_log("phong: Refracted ray missed, lvl=%d\n",sub_ap.a_level );
d421 2
a422 1
				rt_log("Excessive internal reflection (x%d,y%d, lvl%d)\n",
d477 1
a477 1
		if( pp->pt_outhit->hit_dist >= 0.0 )  break;
d485 1
a485 1
		rt_log("phg_rhit:   inhit not near zero!\n");
d487 1
@


1.5
log
@Added uvcoord code, conical ray divergance.
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 1.4 86/07/22 03:53:29 mike Exp $ (BRL)";
d33 1
a76 32

#ifdef BENCHMARK
#define rand0to1()	(0.5)
#define rand_half()	(0)
#else BENCHMARK
/*
 *  			R A N D 0 T O 1
 *
 *  Returns a random number in the range 0 to 1
 */
double rand0to1()
{
	FAST fastf_t f;
	/* On BSD, might want to use random() */
	/* / (double)0x7FFFFFFFL */
	f = ((double)rand()) *
		0.00000000046566128752457969241057508271679984532147;
	if( f > 1.0 || f < 0 )  {
		rt_log("rand0to1 out of range\n");
		return(0.42);
	}
	return(f);
}

/*
 *  			R A N D _ H A L F
 *
 *  Returns a random number in the range -0.5 to +0.5
 */
#define rand_half()	(rand0to1()-0.5)

#endif BENCHMARK
@


1.4
log
@Added some safety checks.
Added ability to handle partitions that start behind the eye.
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 1.3 86/07/19 04:38:49 mike Exp $ (BRL)";
d332 2
d403 2
d469 2
d514 8
@


1.3
log
@Added more stuff
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 1.2 86/07/17 18:33:01 mike Exp $ (BRL)";
a75 1
#define RI_GLASS	1.3    /* Refractive index of glass.		*/
d122 2
a123 2
	pp->shine = 7;
	pp->wgt_specular = 0.6;
d173 2
a174 2
	pp->transmit = 0.8;
	pp->reflect = 0.4;
d386 4
a389 1
	/* Add in contributions from mirror reflection & transparency */
d407 1
a407 2
		VJOIN1( ap->a_color, ap->a_color,
			ps->reflect, sub_ap.a_color );
d429 6
a434 3
		(void) rt_shootray( &sub_ap );
		/* NOTE: phg_rhit returns EXIT point in sub_ap.a_uvec,
		 *  and returns EXIT normal in sub_ap.a_color.
d449 1
a449 1
			if( ++sub_ap.a_level > 100+MAX_IREFLECT )  {
a482 4
	rt_log("phg_rmiss: Refracted ray missed!\n" );
	/* Return entry point as exit point */
	VREVERSE( ap->a_color, ap->a_ray.r_dir );	/* inward pointing */
	VMOVE( ap->a_uvec, ap->a_ray.r_pt );
d488 4
d498 1
a498 1
	register struct hit	*hitp = PartHeadp->pt_forw->pt_outhit;
d500 1
d502 13
a514 1
	stp = PartHeadp->pt_forw->pt_outseg->seg_stp;
d518 8
d564 1
a564 1
		rt_log("phg_refract:ri1=%f, ri2=%f\n", ri_1, ri_2 );
d568 4
d575 1
d627 9
d637 1
a637 1
	if( PartHeadp->pt_forw->pt_inseg->seg_stp == l0stp )
d666 1
a666 1
hit_nothing( ap )
d668 1
@


1.2
log
@Names shortened for non-FLEXNAMES systems (cray),
and converted to using stdio for all I/O.
@
text
@d22 1
a22 1
static char RCSplastic[] = "@@(#)$Header: plastic.c,v 1.1 86/06/11 00:13:54 mike Exp $ (BRL)";
d111 1
a111 1
 *			P L A S T I C _ S E T U P
d134 8
d143 15
d159 26
a184 1
 *			P L A S T I C _ R E N D E R
d332 1
d397 1
d413 1
d460 1
@


1.1
log
@Initial revision
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: view.c,v 3.0 86/06/10 01:32:32 mike Exp $ (BRL)";
d46 1
a46 1
struct plastic_specific {
d54 1
a54 1
#define PL_NULL	((struct plastic_specific *)0)
d56 1
a56 1
struct matparse plastic_parse[] = {
d66 4
a69 4
extern int plastic_render();
HIDDEN int plastic_rfr_miss();
HIDDEN int plastic_rfr_hit();
HIDDEN int plastic_refract();
d114 1
a114 1
plastic_setup( rp )
d117 1
a117 1
	register struct plastic_specific *pp;
d119 2
a120 2
	GETSTRUCT( pp, plastic_specific );
	rp->reg_ufunc = plastic_render;
d130 1
a130 2
	matlib_parse( rp->reg_mater.ma_matparm, plastic_parse, (char *)pp );
	matlib_print( "plastic", plastic_parse, (char *)pp );
d201 1
a201 1
plastic_render( ap, pp )
d217 2
a218 2
	struct plastic_specific *ps =
		(struct plastic_specific *)pp->pt_regionp->reg_udata;
d363 1
a363 1
		if( !plastic_refract(ap->a_ray.r_dir, /* Incident ray (IN) */
d375 2
a376 2
		sub_ap.a_hit =  plastic_rfr_hit;
		sub_ap.a_miss = plastic_rfr_miss;
d378 1
a378 1
		/* NOTE: plastic_rfr_hit returns EXIT point in sub_ap.a_uvec,
d388 1
a388 1
		if( !plastic_refract( sub_ap.a_ray.r_dir,	/* input direction */
d423 1
a423 1
plastic_rfr_miss( ap, PartHeadp )
d427 1
a427 1
	rt_log("plastic_rfr_miss: Refracted ray missed!\n" );
d438 1
a438 1
plastic_rfr_hit( ap, PartHeadp )
d477 1
a477 1
plastic_refract( v_1, norml, ri_1, ri_2, v_2 )
d486 2
a487 2
	if( NEAR_ZERO(ri_1) || NEAR_ZERO( ri_2 ) )  {
		rt_log("plastic_refract:ri1=%f, ri2=%f\n", ri_1, ri_2 );
@
