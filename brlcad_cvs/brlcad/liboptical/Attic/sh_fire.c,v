head	1.35;
access;
symbols
	ansi-20040405-merged:1.31.2.2
	postmerge-20040405-ansi:1.33
	premerge-20040404-ansi:1.32
	postmerge-autoconf:1.32
	autoconf-freeze:1.31.10.2
	premerge-autoconf:1.32
	ansi-20040316-freeze:1.31.2.1
	postmerge-20040315-windows:1.32
	premerge-20040315-windows:1.32
	windows-20040315-freeze:1.31.4.1
	autoconf-20031203:1.31
	autoconf-20031202:1.31
	autoconf-branch:1.31.0.10
	phong-branch:1.31.0.8
	photonmap-branch:1.31.0.6
	rel-6-1-DP:1.31
	windows-branch:1.31.0.4
	rel-6-0-2:1.29
	ansi-branch:1.31.0.2
	rel-6-0-1-branch:1.29.0.2
	hartley-6-0-post:1.30
	hartley-6-0-pre:1.29
	rel-6-0-1:1.29
	rel-6-0:1.29
	rel-5-4:1.21
	offsite-5-3-pre:1.25
	rel-5-3:1.21
	rel-5-2:1.21
	rel-5-1-branch:1.21.0.2
	rel-5-1:1.21
	rel-5-0:1.18
	rel-5-0-beta:1.16
	rel-4-5:1.13
	ctj-4-5-post:1.12
	ctj-4-5-pre:1.12;
locks; strict;
comment	@ * @;


1.35
date	2004.05.21.18.07.27;	author morrison;	state dead;
branches;
next	1.34;

1.34
date	2004.05.10.15.30.45;	author erikg;	state Exp;
branches;
next	1.33;

1.33
date	2004.04.05.07.43.37;	author morrison;	state Exp;
branches;
next	1.32;

1.32
date	2004.02.02.17.39.13;	author morrison;	state Exp;
branches;
next	1.31;

1.31
date	2002.08.20.17.07.50;	author jra;	state Exp;
branches
	1.31.2.1
	1.31.4.1
	1.31.10.1;
next	1.30;

1.30
date	2002.08.15.20.55.03;	author hartley;	state Exp;
branches;
next	1.29;

1.29
date	2001.10.17.07.40.02;	author morrison;	state Exp;
branches;
next	1.28;

1.28
date	2001.10.05.14.04.58;	author butler;	state Exp;
branches;
next	1.27;

1.27
date	2001.04.20.22.29.31;	author morrison;	state Exp;
branches;
next	1.26;

1.26
date	2001.03.31.01.57.02;	author morrison;	state Exp;
branches;
next	1.25;

1.25
date	2000.10.19.19.19.45;	author butler;	state Exp;
branches;
next	1.24;

1.24
date	2000.09.09.04.30.51;	author mike;	state Exp;
branches;
next	1.23;

1.23
date	2000.08.20.01.27.47;	author butler;	state Exp;
branches;
next	1.22;

1.22
date	2000.07.25.16.40.38;	author butler;	state Exp;
branches;
next	1.21;

1.21
date	2000.02.19.21.05.01;	author butler;	state Exp;
branches;
next	1.20;

1.20
date	99.12.30.16.14.11;	author jra;	state Exp;
branches;
next	1.19;

1.19
date	99.10.30.03.06.24;	author butler;	state Exp;
branches;
next	1.18;

1.18
date	99.07.02.22.20.40;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	99.07.01.20.08.45;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	98.09.22.01.29.54;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	98.06.30.22.54.17;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	98.03.16.20.25.49;	author jra;	state Exp;
branches;
next	1.13;

1.13
date	97.12.31.09.01.40;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	97.07.02.21.15.11;	author butler;	state Exp;
branches;
next	1.11;

1.11
date	97.01.07.23.59.19;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	96.09.27.04.30.27;	author butler;	state Exp;
branches;
next	1.9;

1.9
date	96.08.31.08.46.01;	author butler;	state Exp;
branches;
next	1.8;

1.8
date	96.08.31.08.29.28;	author butler;	state Exp;
branches;
next	1.7;

1.7
date	96.08.30.00.08.21;	author butler;	state Exp;
branches;
next	1.6;

1.6
date	96.08.27.07.32.43;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	96.07.22.20.34.18;	author jra;	state Exp;
branches;
next	1.4;

1.4
date	96.07.12.14.57.17;	author jra;	state Exp;
branches;
next	1.3;

1.3
date	96.05.08.21.27.32;	author butler;	state Exp;
branches;
next	1.2;

1.2
date	96.04.26.20.47.00;	author butler;	state Exp;
branches;
next	1.1;

1.1
date	95.10.20.04.43.53;	author butler;	state Exp;
branches;
next	;

1.31.2.1
date	2002.09.19.18.01.24;	author morrison;	state Exp;
branches;
next	1.31.2.2;

1.31.2.2
date	2004.03.17.21.18.32;	author morrison;	state Exp;
branches;
next	;

1.31.4.1
date	2004.03.11.23.43.02;	author morrison;	state Exp;
branches;
next	;

1.31.10.1
date	2004.02.12.18.38.49;	author erikg;	state Exp;
branches;
next	1.31.10.2;

1.31.10.2
date	2004.03.15.14.07.13;	author erikg;	state Exp;
branches;
next	;


desc
@fire prototype shader
@


1.35
log
@moved to src/
@
text
@/*
 *	S H _ F I R E . C
 *
 *  Fire shader
 *
 *  Parameters:
 *
 *	flicker=rate	Specifies rate of translation through noise space
 *			for animation.  swp->frametime * flicker gives a delta
 *			in Z of noise space for animation.  Useful values
 *			probably in range 0 > flicker > 10
 *
 *	stretch=dist	Specifies a scaling of the exponential stretch of the
 *			flames.  flame stretch = e^(pos[Z] * -stretch)
 *
 *
 *  Standard fbm parameters:
 *
 *	lacunarity	Scale between different levels of noise detail
 *
 *	octaves		Number of different levels of noise to add to get
 *				structure of the flames.
 *
 *	h_val		power for frequency (usually 1)
 *
 *	scale		3-tuple which scales noise WRT shader space:
 *			"how big is the largest noise frequency on object"
 *
 *	delta		3-tuple specifying origin delta in noise space:
 *			"what piece of noise space maps to shader origin"
 *
 *  Usage:
 *	mged> shader flame.r {fire {st 1.25}}
 *
 *	Note:  The fire shader provides its own color.  It does not read any
 *		color information from the region definition.
 *
 *  Author -
 *	Lee A. Butler
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" license agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1997-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/liboptical/sh_fire.c,v 1.34 2004/05/10 15:30:45 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef HAVE_STRING_H
#include <string.h>
#endif
#include <math.h>
#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "shadefuncs.h"
#include "shadework.h"
#include "rtprivate.h"

extern int rr_render(struct application	*ap,
		     struct partition	*pp,
		     struct shadework   *swp);
#define fire_MAGIC 0x46697265   /* ``Fire'' */
#define CK_fire_SP(_p) BU_CKMAG(_p, fire_MAGIC, "fire_specific")

/*
 * the shader specific structure contains all variables which are unique
 * to any particular use of the shader.
 */
struct fire_specific {
	long	magic;	/* magic # for memory validity check, must come 1st */
	int	fire_debug;
	double	fire_flicker;		/* flicker rate */
	double	fire_stretch;
	double	noise_lacunarity;
	double	noise_h_val;
	double	noise_octaves;
	double	noise_size;
	vect_t	noise_vscale;
	vect_t	noise_delta;
				/* the following values are computed */
	point_t fire_min;
	point_t fire_max;
	mat_t	fire_m_to_sh;		/* model to shader space matrix */
	mat_t	fire_sh_to_noise;	/* shader to noise space matrix */
	mat_t	fire_colorspline_mat;
};

/* The default values for the variables in the shader specific structure */
static const
struct fire_specific fire_defaults = {
	fire_MAGIC,
	0,			/* fire_debug */
	1.0,			/* fire flicker rate */
	0.0,			/* fire_stretch */
	2.1753974,		/* noise_lacunarity */
	1.0,			/* noise_h_val */
	2.0,			/* noise_octaves */
	-1.0,			/* noise_size */
	{ 10.0, 10.0, 10.0 },	/* noise_vscale */
	{ 0.0, 0.0, 0.0 },	/* noise_delta */
	{ 0.0, 0.0, 0.0 },	/* fire_min */
	{ 0.0, 0.0, 0.0 },	/* fire_max */

	{	/* fire_m_to_sh */
		1.0, 0.0, 0.0, 0.0,
		0.0, 1.0, 0.0, 0.0,
		0.0, 0.0, 1.0, 0.0,
		0.0, 0.0, 0.0, 1.0 },
	{	/* fire_sh_to_noise */
		1.0, 0.0, 0.0, 0.0,
		0.0, 1.0, 0.0, 0.0,
		0.0, 0.0, 1.0, 0.0,
		0.0, 0.0, 0.0, 1.0 },
	{	/* fire_colorspline_mat */
		0.0, 0.0, 0.0, 0.0,
		0.0, 0.0, 0.0, 0.0,
		0.0, 0.0, 0.0, 0.0,
		0.0, 0.0, 0.0, 0.0 }
	};

#define SHDR_NULL	((struct fire_specific *)0)
#define SHDR_O(m)	offsetof(struct fire_specific, m)
#define SHDR_AO(m)	bu_offsetofarray(struct fire_specific, m)



/* description of how to parse/print the arguments to the shader
 * There is at least one line here for each variable in the shader specific
 * structure above
 */
struct bu_structparse fire_print_tab[] = {
	{"%d",  1, "debug",	SHDR_O(fire_debug),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",  1, "flicker",	SHDR_O(fire_flicker),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",  1, "stretch",	SHDR_O(fire_stretch),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "lacunarity", SHDR_O(noise_lacunarity),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "H", 	SHDR_O(noise_h_val),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "octaves", 	SHDR_O(noise_octaves),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",  3, "scale",	SHDR_O(noise_size),		bu_mm_cvt },
	{"%f",  3, "vscale",	SHDR_AO(noise_vscale),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",  3, "delta",	SHDR_AO(noise_delta),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	3,  "max",	SHDR_AO(fire_max),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	3,  "min",	SHDR_AO(fire_min),		BU_STRUCTPARSE_FUNC_NULL },
	{"",	0, (char *)0,		0,			BU_STRUCTPARSE_FUNC_NULL }

};
struct bu_structparse fire_parse_tab[] = {
	{"i",	bu_byteoffset(fire_print_tab[0]), "fire_print_tab", 0, BU_STRUCTPARSE_FUNC_NULL },
	{"%f",  1, "f",		SHDR_O(fire_flicker),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",  1, "st",	SHDR_O(fire_stretch),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "l",		SHDR_O(noise_lacunarity),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "H", 	SHDR_O(noise_h_val),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "o", 	SHDR_O(noise_octaves),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",  1, "s",		SHDR_O(noise_size),		bu_mm_cvt },
	{"%f",  3, "v",		SHDR_AO(noise_vscale),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",  3, "vs",	SHDR_AO(noise_vscale),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",  3, "d",		SHDR_AO(noise_delta),		BU_STRUCTPARSE_FUNC_NULL },
	{"",	0, (char *)0,		0,			BU_STRUCTPARSE_FUNC_NULL }
};

HIDDEN int	fire_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip), fire_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
HIDDEN void	fire_print(register struct region *rp, char *dp), fire_free(char *cp);

/* The "mfuncs" structure defines the external interface to the shader.
 * Note that more than one shader "name" can be associated with a given
 * shader by defining more than one mfuncs struct in this array.
 * See sh_phong.c for an example of building more than one shader "name"
 * from a set of source functions.  There you will find that "glass" "mirror"
 * and "plastic" are all names for the same shader with different default
 * values for the parameters.
 */
struct mfuncs fire_mfuncs[] = {
	{MF_MAGIC,	"fire",		0,		MFI_HIT,	0,
	fire_setup,	fire_render,	fire_print,	fire_free },

	{0,		(char *)0,	0,		0,		0,
	0,		0,		0,		0 }
};

const double flame_colors[18][3] = {
	{0.0, 0.0, 0.0},
	{0.0, 0.0, 0.0},
	{0.106, 0.0, 0.0},
	{0.212, 0.0, 0.0},
	{0.318, 0.0, 0.0},
	{0.427, 0.0, 0.0},
	{0.533, 0.0, 0.0},
	{0.651, 0.02, 0.0},
	{0.741, 0.118, 0.0},
	{0.827, 0.235, 0.0},
	{0.906, 0.353, 0.0},
	{0.933, 0.500, 0.0},
	{0.957, 0.635, 0.047},
	{0.973, 0.733, 0.227},
	{0.984, 0.820, 0.451},
	{0.990, 0.925, 0.824},
	{1.0, 0.945, 0.902},
	{1.0, 0.945, 0.902}
};

/*	F I R E _ S E T U P
 *
 *	This routine is called (at prep time)
 *	once for each region which uses this shader.
 *	Any shader-specific initialization should be done here.
 */
HIDDEN int
fire_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip)
                      	    
             		         
    			      	/* pointer to reg_udata in *rp */
             		     
           		      	/* New since 4.4 release */
{
	register struct fire_specific	*fire_sp;

	/* check the arguments */
	RT_CHECK_RTI(rtip);
	BU_CK_VLS( matparm );
	RT_CK_REGION(rp);


	if (rdebug&RDEBUG_SHADE)
		bu_log("fire_setup(%s)\n", rp->reg_name);

	/* Get memory for the shader parameters and shader-specific data */
	BU_GETSTRUCT( fire_sp, fire_specific );
	*dpp = (char *)fire_sp;

	/* initialize the default values for the shader */
	memcpy(fire_sp, &fire_defaults, sizeof(struct fire_specific) );

	/* parse the user's arguments for this use of the shader. */
	if (bu_struct_parse( matparm, fire_parse_tab, (char *)fire_sp ) < 0 )
		return(-1);

	if (fire_sp->noise_size != -1.0) {
		VSETALL(fire_sp->noise_vscale, fire_sp->noise_size);
	}

	/*
	 * The shader needs to operate in a coordinate system which stays
	 * fixed on the region when the region is moved (as in animation).
	 * We need to get a matrix to perform the appropriate transform(s).
	 */

	db_shader_mat(fire_sp->fire_m_to_sh, rtip, rp, fire_sp->fire_min,
		fire_sp->fire_max, &rt_uniresource);

	/* Build matrix to map shader space to noise space.
	 * XXX If only we could get the frametime at this point
	 * we could factor the flicker of flames into this matrix 
	 * rather than having to recompute it on a pixel-by-pixel basis.
	 */
	MAT_IDN(fire_sp->fire_sh_to_noise);
	MAT_DELTAS_VEC(fire_sp->fire_sh_to_noise, fire_sp->noise_delta);
	MAT_SCALE_VEC(fire_sp->fire_sh_to_noise, fire_sp->noise_vscale);

	/* get matrix for performing spline of fire colors */
	rt_dspline_matrix(fire_sp->fire_colorspline_mat, "Catmull", 0.5, 0.0);



	if (rdebug&RDEBUG_SHADE || fire_sp->fire_debug ) {
		bu_struct_print( " FIRE Parameters:", fire_print_tab, (char *)fire_sp );
		bn_mat_print( "m_to_sh", fire_sp->fire_m_to_sh );
		bn_mat_print( "sh_to_noise", fire_sp->fire_sh_to_noise );
		bn_mat_print( "colorspline", fire_sp->fire_colorspline_mat );
	}

	return(1);
}

/*
 *	F I R E _ P R I N T
 */
HIDDEN void
fire_print(register struct region *rp, char *dp)
{
	bu_struct_print( rp->reg_name, fire_print_tab, (char *)dp );
}

/*
 *	F I R E _ F R E E
 */
HIDDEN void
fire_free(char *cp)
{
	bu_free( cp, "fire_specific" );
}

/*
 *	F I R E _ R E N D E R
 *
 *	This is called (from viewshade() in shade.c) once for each hit point
 *	to be shaded.  The purpose here is to fill in values in the shadework
 *	structure.
 */
int
fire_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
                  	    
                	    
                	     	/* defined in material.h */
    			    	/* ptr to the shader-specific struct */
{
#define DEBUG_SPACE_PRINT(str, i_pt, o_pt) \
	if (rdebug&RDEBUG_SHADE || fire_sp->fire_debug ) { \
		bu_log("fire_render() %s space \n", str); \
		bu_log("fire_render() i_pt(%g %g %g)\n", V3ARGS(i_pt) ); \
		bu_log("fire_render() o_pt(%g %g %g)\n", V3ARGS(o_pt) ); \
	}

#define	SHADER_TO_NOISE(n_pt, sh_pt, fire_sp, zdelta) { \
	point_t tmp_pt; \
	tmp_pt[X] = sh_pt[X]; \
	tmp_pt[Y] = sh_pt[Y]; \
	if ( ! NEAR_ZERO(fire_sp->fire_stretch, SQRT_SMALL_FASTF) ) \
		tmp_pt[Z] = exp( (sh_pt[Z]+0.125) * -fire_sp->fire_stretch ); \
	else \
		tmp_pt[Z] = sh_pt[Z]; \
	MAT4X3PNT(n_pt, fire_sp->fire_sh_to_noise, tmp_pt); \
	n_pt[Z] += zdelta; \
}

	register struct fire_specific *fire_sp =
		(struct fire_specific *)dp;
	point_t	m_i_pt, m_o_pt;	/* model space in/out points */
	point_t sh_i_pt, sh_o_pt;	/* shader space in/out points */
	point_t noise_i_pt, noise_o_pt;	/* shader space in/out points */
	point_t noise_pt;
	point_t	color;
	vect_t	noise_r_dir;
	double	noise_r_thick;
	int	i;
	double	samples_per_unit_noise;
	double	noise_dist_per_sample;
	point_t	shader_pt;
	vect_t	shader_r_dir;
	double	shader_r_thick;
	double	shader_dist_per_sample;
	double	noise_zdelta;

	int	samples;
	double	dist;
	double	noise_val;
	double	lumens;

	/* check the validity of the arguments we got */
	RT_AP_CHECK(ap);
	RT_CHECK_PT(pp);
	CK_fire_SP(fire_sp);

	if (rdebug&RDEBUG_SHADE || fire_sp->fire_debug ) {
/*		bu_struct_print( "fire_render Parameters:", fire_print_tab, (char *)fire_sp ); */
		bu_log("fire_render()\n");
	}
	/* If we are performing the shading in "region" space, we must 
	 * transform the hit point from "model" space to "region" space.
	 * See the call to db_region_mat in fire_setup().
	 */

	/*
	 * Compute the ray/solid in and out points,
	 */
	VMOVE(m_i_pt, swp->sw_hit.hit_point);
	VJOIN1(m_o_pt, ap->a_ray.r_pt, pp->pt_outhit->hit_dist, ap->a_ray.r_dir);
	DEBUG_SPACE_PRINT("model", m_i_pt, m_o_pt);

	/* map points into shader space */
	MAT4X3PNT(sh_i_pt, fire_sp->fire_m_to_sh, m_i_pt);
	MAT4X3PNT(sh_o_pt, fire_sp->fire_m_to_sh, m_o_pt);
	DEBUG_SPACE_PRINT("shader", sh_i_pt, sh_o_pt);

	noise_zdelta = fire_sp->fire_flicker * swp->sw_frametime;

	SHADER_TO_NOISE(noise_i_pt, sh_i_pt, fire_sp, noise_zdelta);
	SHADER_TO_NOISE(noise_o_pt, sh_o_pt, fire_sp, noise_zdelta);

	VSUB2(noise_r_dir, noise_o_pt, noise_i_pt);

	noise_r_thick = MAGNITUDE(noise_r_dir);

	if (rdebug&RDEBUG_SHADE || fire_sp->fire_debug ) {
		bu_log("fire_render() noise_r_dir (%g %g %g)\n",
			V3ARGS(noise_r_dir) );
		bu_log("fire_render() noise_r_thick %g\n", noise_r_thick);
	}


	/* compute number of samples per unit length in noise space.
	 *
	 * The noise field used by the bn_noise_turb and bn_noise_fbm routines
	 * has a maximum frequency of about 1 cycle per integer step in
	 * noise space.  Each octave increases this frequency by the
	 * "lacunarity" factor.  To sample this space adequately, nyquist
	 * tells us we need at least 4 samples/cycle at the highest octave
	 * rate.
	 */

	samples_per_unit_noise =
		pow(fire_sp->noise_lacunarity, fire_sp->noise_octaves-1) * 4.0;

	noise_dist_per_sample = 1.0 / samples_per_unit_noise;

	samples = samples_per_unit_noise * noise_r_thick;

	if (samples < 1) samples = 1;

	if (rdebug&RDEBUG_SHADE || fire_sp->fire_debug ) {
		bu_log("samples:%d\n", samples);
		bu_log("samples_per_unit_noise %g\n", samples_per_unit_noise);
		bu_log("noise_dist_per_sample %g\n", noise_dist_per_sample);
	}

	/* To do the exponential stretch and decay properly we need to 
	 * do the computations in shader space, and convert the points
	 * to noise space.  Performance pig.
	 */

	VSUB2(shader_r_dir, sh_o_pt, sh_i_pt);
	shader_r_thick = MAGNITUDE(shader_r_dir);
	VUNITIZE(shader_r_dir);

	shader_dist_per_sample = shader_r_thick / samples;

	lumens = 0.0;
	for (i = 0 ; i < samples ; i++) {
		dist = (double)i * shader_dist_per_sample;
		VJOIN1(shader_pt, sh_i_pt, dist, shader_r_dir);

		SHADER_TO_NOISE(noise_pt, shader_pt, fire_sp, noise_zdelta);

		noise_val = bn_noise_turb(noise_pt, fire_sp->noise_h_val,
			fire_sp->noise_lacunarity, fire_sp->noise_octaves);

		if (rdebug&RDEBUG_SHADE || fire_sp->fire_debug )
			bu_log("bn_noise_turb(%g %g %g) = %g\n",
				V3ARGS(noise_pt),
				noise_val);

		/* XXX
		 * When doing the exponential stretch, we scale the noise
		 * value by the height in shader space
		 */

		if ( NEAR_ZERO(fire_sp->fire_stretch, SQRT_SMALL_FASTF) )
			lumens += noise_val * 0.025;
		else {
			register double t;
			t = lumens;
			lumens += noise_val * 0.025 *  (1.0 -shader_pt[Z]);
			if (rdebug&RDEBUG_SHADE || fire_sp->fire_debug )
				bu_log("lumens:%g = %g + %g * %g\n",
					lumens, t, noise_val,
					0.025 * (1.0 - shader_pt[Z]) );

		}
		if (lumens >= 1.0) {
			lumens = 1.0;
			if (rdebug&RDEBUG_SHADE || fire_sp->fire_debug )
				bu_log("early exit from lumens loop\n");
			break;
		}

	}
	
	if (rdebug&RDEBUG_SHADE || fire_sp->fire_debug )
		bu_log("lumens = %g\n", lumens);

	if (lumens < 0.0) lumens = 0.0;
	else if (lumens > 1.0) lumens = 1.0;


	rt_dspline_n(color, fire_sp->fire_colorspline_mat, (double *)flame_colors,
		18, 3, lumens);

	VMOVE(swp->sw_color, color);
/*	VSETALL(swp->sw_basecolor, 1.0);*/

	swp->sw_transmit = 1.0 - (lumens * 4.);
	if (swp->sw_reflect > 0 || swp->sw_transmit > 0 )
		(void)rr_render( ap, pp, swp );

	return(1);
}
@


1.34
log
@change conf.h to a wrapped config.h
@
text
@d55 1
a55 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/liboptical/sh_fire.c,v 1.33 2004/04/05 07:43:37 morrison Exp $ (ARL)";
@


1.33
log
@merge of ansi-6-0-branch into HEAD
@
text
@d55 1
a55 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d58 5
a62 1
#include "conf.h"
@


1.32
log
@update copyright to include span through 2003
@
text
@d55 1
a55 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_fire.c,v 1.31 2002/08/20 17:07:50 jra Exp $ (ARL)";
d173 2
a174 2
HIDDEN int	fire_setup(), fire_render();
HIDDEN void	fire_print(), fire_free();
d220 6
a225 6
fire_setup( rp, matparm, dpp, mfp, rtip)
register struct region	*rp;
struct bu_vls		*matparm;
char			**dpp;	/* pointer to reg_udata in *rp */
struct mfuncs		*mfp;
struct rt_i		*rtip;	/* New since 4.4 release */
d290 1
a290 3
fire_print( rp, dp )
register struct region *rp;
char	*dp;
d299 1
a299 2
fire_free( cp )
char *cp;
d312 5
a316 5
fire_render( ap, pp, swp, dp )
struct application	*ap;
struct partition	*pp;
struct shadework	*swp;	/* defined in material.h */
char			*dp;	/* ptr to the shader-specific struct */
@


1.31
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d51 1
a51 1
 *	This software is Copyright (C) 1997 by the United States Army
d55 1
a55 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_fire.c,v 1.29 2001/10/17 07:40:02 morrison Exp $ (ARL)";
@


1.31.4.1
log
@sync to HEAD...
@
text
@d51 1
a51 1
 *	This software is Copyright (C) 1997-2004 by the United States Army
d55 1
a55 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/liboptical/sh_fire.c,v 1.32 2004/02/02 17:39:13 morrison Exp $ (ARL)";
@


1.31.10.1
log
@merge from HEAD
@
text
@d51 1
a51 1
 *	This software is Copyright (C) 1997-2004 by the United States Army
d55 1
a55 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_fire.c,v 1.32 2004/02/02 17:39:13 morrison Exp $ (ARL)";
@


1.31.10.2
log
@merge from head
@
text
@d55 1
a55 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_fire.c,v 1.31.10.1 2004/02/12 18:38:49 erikg Exp $ (ARL)";
@


1.31.2.1
log
@Initial ANSIfication
@
text
@d55 1
a55 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_fire.c,v 1.31 2002/08/20 17:07:50 jra Exp $ (ARL)";
d173 2
a174 2
HIDDEN int	fire_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip), fire_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
HIDDEN void	fire_print(register struct region *rp, char *dp), fire_free(char *cp);
d220 6
a225 6
fire_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip)
                      	    
             		         
    			      	/* pointer to reg_udata in *rp */
             		     
           		      	/* New since 4.4 release */
d290 3
a292 1
fire_print(register struct region *rp, char *dp)
d301 2
a302 1
fire_free(char *cp)
d315 5
a319 5
fire_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
                  	    
                	    
                	     	/* defined in material.h */
    			    	/* ptr to the shader-specific struct */
@


1.31.2.2
log
@sync branch with HEAD
@
text
@d51 1
a51 1
 *	This software is Copyright (C) 1997-2004 by the United States Army
d55 1
a55 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
@


1.30
log
@Converted from K&R to ANSI C - RFH
@
text
@d173 2
a174 2
HIDDEN int	fire_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip), fire_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
HIDDEN void	fire_print(register struct region *rp, char *dp), fire_free(char *cp);
d220 6
a225 6
fire_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip)
                      	    
             		         
    			      	/* pointer to reg_udata in *rp */
             		     
           		      	/* New since 4.4 release */
d290 3
a292 1
fire_print(register struct region *rp, char *dp)
d301 2
a302 1
fire_free(char *cp)
d315 5
a319 5
fire_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
                  	    
                	    
                	     	/* defined in material.h */
    			    	/* ptr to the shader-specific struct */
@


1.29
log
@Mac OS X warning and error fixes for non-production build
@
text
@d55 1
a55 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_fire.c,v 1.28 2001/10/05 14:04:58 butler Exp $ (ARL)";
d173 2
a174 2
HIDDEN int	fire_setup(), fire_render();
HIDDEN void	fire_print(), fire_free();
d220 6
a225 6
fire_setup( rp, matparm, dpp, mfp, rtip)
register struct region	*rp;
struct bu_vls		*matparm;
char			**dpp;	/* pointer to reg_udata in *rp */
struct mfuncs		*mfp;
struct rt_i		*rtip;	/* New since 4.4 release */
d290 1
a290 3
fire_print( rp, dp )
register struct region *rp;
char	*dp;
d299 1
a299 2
fire_free( cp )
char *cp;
d312 5
a316 5
fire_render( ap, pp, swp, dp )
struct application	*ap;
struct partition	*pp;
struct shadework	*swp;	/* defined in material.h */
char			*dp;	/* ptr to the shader-specific struct */
@


1.28
log
@Changed comments to use "shader" command in the example usage
@
text
@d55 1
a55 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_fire.c,v 1.27 2001/04/20 22:29:31 morrison Exp $ (ARL)";
d213 1
a213 1
/*	F I R E _ S E T U P
d286 1
a286 1
/*
d307 1
a307 1
/*
@


1.27
log
@CONST to const
@
text
@d14 1
a14 1
 *			flames.  flame stretch = e^(pos[Z} * -stretch)
d33 1
a33 5
 *	mged> mater fire.r
 * 	Material?  ('del' to delete, CR to skip) fire
 * 	Parameter string? ('del' to delete, CR to skip) st=3 f=2.173
 * 	Color R G B (0..255)? ('del' to delete, CR to skip)
 *	Inheritance (0|1)? (CR to skip)
d55 1
a55 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_fire.c,v 1.26 2001/03/31 01:57:02 morrison Exp $ (ARL)";
@


1.26
log
@Deprecated bn_mat_idn() and bn_mat_zero(), updated calls to h/vmath.h's MAT_IDN() and MAT_ZERO() performance improved macros.
@
text
@d59 1
a59 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_fire.c,v 1.25 2000/10/19 19:19:45 butler Exp $ (ARL)";
d106 1
a106 1
static CONST
d196 1
a196 1
CONST double flame_colors[18][3] = {
@


1.25
log
@Changes to compile under RedHat 7.0
@
text
@d59 1
a59 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_fire.c,v 1.24 2000/09/09 04:30:51 mike Exp $ (ARL)";
d271 1
a271 1
	bn_mat_idn(fire_sp->fire_sh_to_noise);
@


1.24
log
@
Struct db_tree_state finally got a magic number. Added resource argument
to ft_describe(), db_region_mat(), db_shader_mat(),
db_init_db_tree_state(), and db_path_to_mat().
@
text
@d59 1
a59 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_fire.c,v 1.23 2000/08/20 01:27:47 butler Exp $ (ARL)";
d65 3
@


1.23
log
@Eliminate compilation warnings, enhancements to sh_light.c
@
text
@d59 1
a59 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_fire.c,v 1.22 2000/07/25 16:40:38 butler Exp $ (ARL)";
d261 1
a261 1
		fire_sp->fire_max);
@


1.22
log
@Changes to use rtprivate.h instead of ../rt/rdebug.h
@
text
@d59 1
a59 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_fire.c,v 1.21 2000/02/19 21:05:01 butler Exp $ (ARL)";
@


1.21
log
@Changes to support movement of CLAMP() macro into vmath.h
Altered "if( " statements to "if (" for readability.
@
text
@d59 1
a59 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_fire.c,v 1.20 1999/12/30 16:14:11 jra Exp $ (ARL)";
d71 1
a71 1
#include "../rt/rdebug.h"
d73 3
d194 18
a211 18
	0.0, 0.0, 0.0,
	0.0, 0.0, 0.0,
	0.106, 0.0, 0.0,
	0.212, 0.0, 0.0,
	0.318, 0.0, 0.0,
	0.427, 0.0, 0.0,
	0.533, 0.0, 0.0,
	0.651, 0.02, 0.0,
	0.741, 0.118, 0.0,
	0.827, 0.235, 0.0,
	0.906, 0.353, 0.0,
	0.933, 0.500, 0.0,
	0.957, 0.635, 0.047,
	0.973, 0.733, 0.227,
	0.984, 0.820, 0.451,
	0.990, 0.925, 0.824,
	1.0, 0.945, 0.902,
	1.0, 0.945, 0.902
@


1.20
log
@Eliminated some unused variables
@
text
@d59 1
a59 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_fire.c,v 1.19 1999/10/30 03:06:24 butler Exp $ (ARL)";
d233 1
a233 1
	if( rdebug&RDEBUG_SHADE)
d244 1
a244 1
	if( bu_struct_parse( matparm, fire_parse_tab, (char *)fire_sp ) < 0 )
d274 1
a274 1
	if( rdebug&RDEBUG_SHADE || fire_sp->fire_debug ) {
d320 1
a320 1
	if( rdebug&RDEBUG_SHADE || fire_sp->fire_debug ) { \
d366 1
a366 1
	if( rdebug&RDEBUG_SHADE || fire_sp->fire_debug ) {
d396 1
a396 1
	if( rdebug&RDEBUG_SHADE || fire_sp->fire_debug ) {
d422 1
a422 1
	if( rdebug&RDEBUG_SHADE || fire_sp->fire_debug ) {
d449 1
a449 1
		if( rdebug&RDEBUG_SHADE || fire_sp->fire_debug )
d465 1
a465 1
			if( rdebug&RDEBUG_SHADE || fire_sp->fire_debug )
d473 1
a473 1
			if( rdebug&RDEBUG_SHADE || fire_sp->fire_debug )
d480 1
a480 1
	if( rdebug&RDEBUG_SHADE || fire_sp->fire_debug )
d494 1
a494 1
	if( swp->sw_reflect > 0 || swp->sw_transmit > 0 )
@


1.19
log
@Moved mathtab/rand_half from rt into libbn
Expanded structparse to include description and default
@
text
@d59 1
a59 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_fire.c,v 1.18 1999/07/02 22:20:40 mike Exp $ (ARL)";
a225 2
	mat_t	tmp;
	vect_t	bb_min, bb_max, v_tmp;
a339 2
	point_t t_i_pt;
	point_t t_o_pt;
@


1.18
log
@
Removed dependence on compat4.h
@
text
@d59 1
a59 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_fire.c,v 1.17 1999/07/01 20:08:45 mike Exp $ (ARL)";
a70 1
#include "../rt/mathtab.h"
@


1.17
log
@
compat4
@
text
@d59 1
a59 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_fire.c,v 1.16 1998/09/22 01:29:54 mike Exp $ (ARL)";
d144 6
a149 6
	{"%d",  1, "debug",	SHDR_O(fire_debug),		FUNC_NULL },
	{"%f",  1, "flicker",	SHDR_O(fire_flicker),		FUNC_NULL },
	{"%f",  1, "stretch",	SHDR_O(fire_stretch),		FUNC_NULL },
	{"%f",	1, "lacunarity", SHDR_O(noise_lacunarity),	FUNC_NULL },
	{"%f",	1, "H", 	SHDR_O(noise_h_val),		FUNC_NULL },
	{"%f",	1, "octaves", 	SHDR_O(noise_octaves),		FUNC_NULL },
d151 5
a155 5
	{"%f",  3, "vscale",	SHDR_AO(noise_vscale),		FUNC_NULL },
	{"%f",  3, "delta",	SHDR_AO(noise_delta),		FUNC_NULL },
	{"%f",	3,  "max",	SHDR_AO(fire_max),		FUNC_NULL },
	{"%f",	3,  "min",	SHDR_AO(fire_min),		FUNC_NULL },
	{"",	0, (char *)0,		0,			FUNC_NULL }
d160 5
a164 5
	{"%f",  1, "f",		SHDR_O(fire_flicker),		FUNC_NULL },
	{"%f",  1, "st",	SHDR_O(fire_stretch),		FUNC_NULL },
	{"%f",	1, "l",		SHDR_O(noise_lacunarity),	FUNC_NULL },
	{"%f",	1, "H", 	SHDR_O(noise_h_val),		FUNC_NULL },
	{"%f",	1, "o", 	SHDR_O(noise_octaves),		FUNC_NULL },
d166 4
a169 4
	{"%f",  3, "v",		SHDR_AO(noise_vscale),		FUNC_NULL },
	{"%f",  3, "vs",	SHDR_AO(noise_vscale),		FUNC_NULL },
	{"%f",  3, "d",		SHDR_AO(noise_delta),		FUNC_NULL },
	{"",	0, (char *)0,		0,			FUNC_NULL }
@


1.16
log
@Moved optical shaders from rt/ to liboptical/
The only modifications involved moving and splitting
rt/material.h into h/shadefuncs.h and h/shadework.h,
and in changing the calling sequence to mlib_setup() in rt/material.c

Now the only shader function called directly by RT is
in liboptical/init.c: optical_shader_init().
It adds all the individual shaders to the "mfuncs" shader list.
@
text
@d59 1
a59 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
d75 1
a75 1
#define CK_fire_SP(_p) RT_CKMAG(_p, fire_MAGIC, "fire_specific")
d135 1
a135 1
#define SHDR_AO(m)	offsetofarray(struct fire_specific, m)
d159 1
a159 1
	{"i",	bu_byteoffset(fire_print_tab[0]), "fire_print_tab", 0, FUNC_NULL },
d221 1
a221 1
struct rt_vls		*matparm;
d232 1
a232 1
	RT_VLS_CHECK( matparm );
d237 1
a237 1
		rt_log("fire_setup(%s)\n", rp->reg_name);
d240 1
a240 1
	GETSTRUCT( fire_sp, fire_specific );
d268 1
a268 1
	mat_idn(fire_sp->fire_sh_to_noise);
d279 3
a281 3
		mat_print( "m_to_sh", fire_sp->fire_m_to_sh );
		mat_print( "sh_to_noise", fire_sp->fire_sh_to_noise );
		mat_print( "colorspline", fire_sp->fire_colorspline_mat );
d305 1
a305 1
	rt_free( cp, "fire_specific" );
d324 3
a326 3
		rt_log("fire_render() %s space \n", str); \
		rt_log("fire_render() i_pt(%g %g %g)\n", V3ARGS(i_pt) ); \
		rt_log("fire_render() o_pt(%g %g %g)\n", V3ARGS(o_pt) ); \
d402 1
a402 1
		rt_log("fire_render() noise_r_dir (%g %g %g)\n",
d404 1
a404 1
		rt_log("fire_render() noise_r_thick %g\n", noise_r_thick);
d410 1
a410 1
	 * The noise field used by the noise_turb and noise_fbm routines
d428 3
a430 3
		rt_log("samples:%d\n", samples);
		rt_log("samples_per_unit_noise %g\n", samples_per_unit_noise);
		rt_log("noise_dist_per_sample %g\n", noise_dist_per_sample);
d451 1
a451 1
		noise_val = noise_turb(noise_pt, fire_sp->noise_h_val,
d455 1
a455 1
			rt_log("noise_turb(%g %g %g) = %g\n",
d471 1
a471 1
				rt_log("lumens:%g = %g + %g * %g\n",
d479 1
a479 1
				rt_log("early exit from lumens loop\n");
d486 1
a486 1
		rt_log("lumens = %g\n", lumens);
@


1.15
log
@Can't make "struct mfuncs" a CONST, because the forward link needs
to be filled in at runtime, and some compilers put CONST data into
read-only pages (like FreeBSD).
@
text
@d41 16
d58 4
d69 4
a72 3
#include "./material.h"
#include "./mathtab.h"
#include "./rdebug.h"
@


1.14
log
@Minor mods to get it to compile.
@
text
@d162 1
a162 1
CONST struct mfuncs fire_mfuncs[] = {
@


1.13
log
@Required magic number to be first in mfunc table,
consistent with all other BRL-CAD magic numbers.
Required magic number to be initialized at compile time.
Added code to check the magic numbers.
Made the xxx_mfunc arrays CONST, so they can't get trashed by
runtime runaway pointer problems.
@
text
@d252 1
a252 1
	rt_dspline_matrix(fire_sp->fire_colorspline_mat, "Catmull", 0.5);
d471 1
a471 1
	rt_dspline_n(color, fire_sp->fire_colorspline_mat, flame_colors,
@


1.12
log
@checkpoint
@
text
@d162 2
a163 2
struct mfuncs fire_mfuncs[] = {
	{"fire",	0,	0,		MFI_HIT,	0,
d166 1
a166 1
	{(char *)0,	0,		0,		0,		0,
@


1.11
log
@Changed to bu_byteoffset
@
text
@d68 2
a69 1
	vect_t	noise_scale;
d71 1
a71 1

d89 2
a90 1
	{ 10.0, 10.0, 10.0 },	/* noise_scale */
d129 2
a130 1
	{"%f",  3, "scale",	SHDR_AO(noise_scale),		FUNC_NULL },
d144 3
a146 1
	{"%f",  3, "sc",	SHDR_AO(noise_scale),		FUNC_NULL },
d229 8
a236 5
	/* Optional:
	 *
	 * If the shader needs to operate in a coordinate system which stays
	 * fixed on the region when the region is moved (as in animation)
	 * we need to get a matrix to perform the appropriate transform(s).
d249 1
a249 1
	MAT_SCALE_VEC(fire_sp->fire_sh_to_noise, fire_sp->noise_scale);
@


1.10
log
@db_shader_mat() parameter change
@
text
@a52 29
/*
 *  Generic settable parameters.
 *  By setting the "base address" to zero in the bu_structparse call,
 *  the actual memory address is given here as the structure offset.
 *
 *  Strictly speaking, the C language only permits initializers of the
 *  form: address +- constant, where here the intent is to measure the
 *  byte address of the indicated variable.
 *  Matching compensation code for the CRAY is located in librt/parse.c
 */
#if CRAY
#	define byteoffset(_i)	(((int)&(_i)))	/* actually a word offset */
#else
#  if IRIX > 5
#	define byteoffset(_i)	((size_t)__INTADDR__(&(_i)))
#  else
#    if sgi || __convexc__ || ultrix || _HPUX_SOURCE
	/* "Lazy" way.  Works on reasonable machines with byte addressing */
#	define byteoffset(_i)	((int)((char *)&(_i)))
#    else
	/* "Conservative" way of finding # bytes as diff of 2 char ptrs */
#	define byteoffset(_i)	((int)(((char *)&(_i))-((char *)0)))
#    endif
#  endif
#endif




d71 2
d90 2
d127 1
a127 1
	{"%f",  1, "scale",	SHDR_AO(noise_scale),		FUNC_NULL },
d129 2
d135 1
a135 1
	{"i",	byteoffset(fire_print_tab[0]), "fire_print_tab", 0, FUNC_NULL },
d141 1
a141 1
	{"%f",  1, "sc",	SHDR_AO(noise_scale),		FUNC_NULL },
d231 2
a232 1
	db_shader_mat(fire_sp->fire_m_to_sh, rtip, rp);
a461 3
	swp->sw_transmit = 1.0 - lumens;
	if( swp->sw_reflect > 0 || swp->sw_transmit > 0 )
		(void)rr_render( ap, pp, swp );
d467 1
a467 1
	VSETALL(swp->sw_basecolor, 1.0);
d469 3
@


1.9
log
@bu_struct_print
@
text
@d254 1
a254 1
	db_shader_mat(fire_sp->fire_m_to_sh, rtip->rti_dbip, rp);
@


1.8
log
@bu_struct_parse
@
text
@d271 1
a271 1
		bu_structprint( " FIRE Parameters:", fire_print_tab, (char *)fire_sp );
d288 1
a288 1
	bu_structprint( rp->reg_name, fire_print_tab, (char *)dp );
d365 1
a365 1
/*		bu_structprint( "fire_render Parameters:", fire_print_tab, (char *)fire_sp ); */
@


1.7
log
@structparse moved to libbu
@
text
@d244 1
a244 1
	if( bu_structparse( matparm, fire_parse_tab, (char *)fire_sp ) < 0 )
@


1.6
log
@Removed stray &
@
text
@d55 1
a55 1
 *  By setting the "base address" to zero in the rt_structparse call,
d145 1
a145 1
struct structparse fire_print_tab[] = {
d157 1
a157 1
struct structparse fire_parse_tab[] = {
d244 1
a244 1
	if( rt_structparse( matparm, fire_parse_tab, (char *)fire_sp ) < 0 )
d271 1
a271 1
		rt_structprint( " FIRE Parameters:", fire_print_tab, (char *)fire_sp );
d288 1
a288 1
	rt_structprint( rp->reg_name, fire_print_tab, (char *)dp );
d365 2
a366 2
/*		rt_structprint( "fire_render Parameters:", fire_print_tab, (char *)fire_sp ); */
		rt_log("fire_render()\n");
@


1.5
log
@Minor Mods for IRIX 6.2
@
text
@d152 1
a152 1
	{"%f",  1, "scale",	SHDR_O(noise_scale),		FUNC_NULL },
@


1.4
log
@Minor mod for IRIX 6.2
@
text
@d67 1
a67 1
#	define byteoffset(_i)	((long)((char *)&(_i)))
@


1.3
log
@macros to clean up the code, and direct calling of rr_render() for
transmission/reflection calculations.
@
text
@d106 1
a106 1
CONST static
@


1.2
log
@got it.
@
text
@d4 1
a4 1
 *  To add a new shader to the "rt" program:
d6 35
a40 16
 *	1) Copy this file to sh_shadername.c
 *	2) edit sh_shadername.c:
 *		change "F I R E" to "S H A D E R N A M E"
 *		change "fire"   to "shadername"
 *		Set a new number for the fire_MAGIC define
 *		define shader specific structure and defaults
 *		edit/build parse table for structparse from fire_parse
 *		edit/build shader_mfuncs tables from fire_mfuncs for
 *			each shader name being built.
 *		edit the fire_setup function to do shader-specific setup
 *		edit the fire_render function to do the actual rendering
 *	3) Edit view.c to add extern for fire_mfuncs and call to mlib_add
 *		to function view_init()
 *	4) Edit Cakefile to add shader file to "FILES" and "RT_OBJ" macros.
 *	5) replace this list with a description of the shader, its parameters
 *		and use.
d92 1
d110 1
d147 1
d159 1
d256 5
a260 1
	/* XXX build matrix to map shader space to noise space */
d315 19
d352 1
d378 1
a378 6

	if( rdebug&RDEBUG_SHADE || fire_sp->fire_debug ) {
		rt_log("fire_render() model space \n");
		rt_log("fire_render() m_i_pt(%g %g %g)\n", V3ARGS(m_i_pt) );
		rt_log("fire_render() m_o_pt(%g %g %g)\n", V3ARGS(m_o_pt) );
	}
d383 1
a383 6

	if( rdebug&RDEBUG_SHADE || fire_sp->fire_debug ) {
		rt_log("fire_render() shader space \n");
		rt_log("fire_render() sh_i_pt(%g %g %g)\n", V3ARGS(sh_i_pt) );
		rt_log("fire_render() sh_o_pt(%g %g %g)\n", V3ARGS(sh_o_pt) );
	}
d385 1
a385 17
	/* apply exponential stretch to shader space */
	VMOVE(t_i_pt, sh_i_pt);
	VMOVE(t_o_pt, sh_o_pt);
	if ( ! NEAR_ZERO(fire_sp->fire_stretch, SQRT_SMALL_FASTF) ) {
		t_i_pt[Z] = exp( (sh_i_pt[Z]+0.125) * -fire_sp->fire_stretch );
		t_o_pt[Z] = exp( (sh_o_pt[Z]+0.125) * -fire_sp->fire_stretch );
	}

	/* map shader space into noise space */
	MAT4X3PNT(noise_i_pt, fire_sp->fire_sh_to_noise, sh_i_pt);
	MAT4X3PNT(noise_o_pt, fire_sp->fire_sh_to_noise, sh_o_pt);

	if( rdebug&RDEBUG_SHADE || fire_sp->fire_debug ) {
		rt_log("fire_render() noise space \n");
		rt_log("fire_render() noise_i_pt(%g %g %g)\n", V3ARGS(noise_i_pt) );
		rt_log("fire_render() noise_o_pt(%g %g %g)\n", V3ARGS(noise_o_pt) );
	}
d387 2
a388 3
	/* map points into shader space (again)*/
	MAT4X3PNT(sh_i_pt, fire_sp->fire_m_to_sh, m_i_pt);
	MAT4X3PNT(sh_o_pt, fire_sp->fire_m_to_sh, m_o_pt);
a428 1
	 *
d441 2
a442 8
		
		VMOVE(t_i_pt, shader_pt);
		if ( ! NEAR_ZERO(fire_sp->fire_stretch, SQRT_SMALL_FASTF) ) {
			t_i_pt[Z] = exp( (t_i_pt[Z]+0.125) * -fire_sp->fire_stretch );
		}
		
		/* map shader space into noise space */
		MAT4X3PNT(noise_pt, fire_sp->fire_sh_to_noise, t_i_pt);
d485 2
a493 6
	/* caller will perform transmission/reflection calculations
	 * based upon the values of swp->sw_transmit and swp->sw_reflect
	 *
	 * 0 < swp->sw_transmit <= 1 causes transmission computations
	 * 0 < swp->sw_reflect <= 1 causes reflection computations
	 */
@


1.1
log
@Initial revision
@
text
@d4 18
a21 1
 *	A 3D "solid" cloud shader
a32 1
#define M_PI            3.14159265358979323846
d34 27
a60 4
#define CLAMP(_x,_a,_b)	(_x < _a ? _a : (_x > _b ? _b : _x))
#define FLOOR(x)	(  (int)(x) - (  (x) < 0 && (x) != (int)(x)  )  )
#define CEIL(x)		(  (int)(x) + (  (x) > 0 && (x) != (int)(x)  )  )
#define SMOOTHSTEP(x)   (  (x) * (x) * (3 - 2*(x))  )
d62 8
d71 12
a82 8
	double	lacunarity;
	double	h_val;
	double	octaves;
	double	scale;	/* scale coordinate space */
	vect_t	delta;	/* xlatd in noise space (where interesting noise is)*/
	int	exp_use;
	double	flame_height;
	mat_t	xform;
d85 27
a111 8
static struct fire_specific fire_defaults = {
	2.1753974,	/* lacunarity */
	1.0,		/* h_val */
	4.0,		/* octaves */
	1.0,		/* scale */
	{ 0.0, 0.0, 0.0 },	/* delta */
	0.0,			/* exp_use */
	500.0		/* flame height */
d118 14
a131 8
struct structparse fire_pr[] = {
	{"%f",	1, "lacunarity",	SHDR_O(lacunarity),	FUNC_NULL },
	{"%f",	1, "H", 		SHDR_O(h_val),	FUNC_NULL },
	{"%f",	1, "octaves", 		SHDR_O(octaves),	FUNC_NULL },
	{"%f",  1, "scale",		SHDR_O(scale),	FUNC_NULL },
	{"%f",  1, "height",		SHDR_O(flame_height),	FUNC_NULL },
	{"%f",  3, "delta",		SHDR_AO(delta),	FUNC_NULL },
	{"%d",  1, "exp_use",		SHDR_O(exp_use),	FUNC_NULL },
d133 1
d135 8
a142 14
struct structparse fire_parse[] = {
	{"%f",	1, "lacunarity",	SHDR_O(lacunarity),	FUNC_NULL },
	{"%f",	1, "H", 		SHDR_O(h_val),	FUNC_NULL },
	{"%f",	1, "octaves", 		SHDR_O(octaves),	FUNC_NULL },
	{"%f",  1, "scale",		SHDR_O(scale),	FUNC_NULL },
	{"%f",  3, "delta",		SHDR_AO(delta),	FUNC_NULL },
	{"%d",  1, "exp_use",		SHDR_O(exp_use),	FUNC_NULL },
	{"%f",  1, "height",		SHDR_O(flame_height),	FUNC_NULL },
	{"%f",	1, "l",			SHDR_O(lacunarity),	FUNC_NULL },
	{"%f",	1, "o", 		SHDR_O(octaves),	FUNC_NULL },
	{"%f",  1, "s",			SHDR_O(scale),	FUNC_NULL },
	{"%f",  3, "d",			SHDR_AO(delta),	FUNC_NULL },
	{"%d",  1, "e",			SHDR_O(exp_use),	FUNC_NULL },
	{"%f",  1, "h",			SHDR_O(flame_height),	FUNC_NULL },
d149 8
d158 1
a158 1
	{"fire",	0,		0,	MFI_NORMAL|MFI_HIT|MFI_UV, 0,
d161 1
a161 1
	{(char *)0,	0,		0,		0,
d165 20
d186 5
a190 3

/*
 *	F I R E _ S E T U P
d193 4
a196 4
fire_setup( rp, matparm, dpp, mfp, rtip )
register struct region *rp;
struct rt_vls	*matparm;
char	**dpp;	/* pointer to reg_udata in *rp */
d198 1
a198 1
struct rt_i		*rtip;
d200 1
a200 4
	register struct fire_specific *fire;
	struct db_full_path full_path;
	mat_t	region_to_model;
	mat_t	model_to_region;
d202 1
d204 2
d207 2
a208 2
	GETSTRUCT( fire, fire_specific );
	*dpp = (char *)fire;
a209 1
	memcpy(fire, &fire_defaults, sizeof(struct fire_specific) );
d211 8
a218 1
		rt_log("fire_setup\n");
d220 2
a221 1
	if( rt_structparse( matparm, fire_parse, (char *)fire ) < 0 )
d224 13
a236 2
	if( rdebug&RDEBUG_SHADE)
		rt_structprint( rp->reg_name, fire_parse, (char *)fire );
d238 2
a239 9
	/* get transformation between world and "region" coordinates */
	if (db_string_to_path( &full_path, rtip->rti_dbip, rp->reg_name) ) {
		/* bad thing */
		rt_bomb("db_string_to_path() error");
	}
	if(! db_path_to_mat(rtip->rti_dbip, &full_path, region_to_model, 0)) {
		/* bad thing */
		rt_bomb("db_path_to_mat() error");
	}
a240 4
	/* get matrix to map points from model (world) space
	 * to "region" space
	 */
	mat_inv(model_to_region, region_to_model);
d243 6
a248 14
	/* add the noise-space scaling */
	mat_idn(tmp);
	tmp[0] = 1. / fire->scale;
	tmp[5] = 1. / fire->scale;
	tmp[10] =  1. / fire->scale;

	mat_mul(fire->xform, tmp, model_to_region);

	/* add the translation within noise space */
	mat_idn(tmp);
	tmp[MDX] = fire->delta[0];
	tmp[MDY] = fire->delta[1];
	tmp[MDZ] = fire->delta[2];
	mat_mul2(tmp, fire->xform);
d253 1
a253 1
/*
d261 1
a261 1
	rt_structprint( rp->reg_name, fire_pr, (char *)dp );
d274 1
a274 1
/*
d276 4
d285 2
a286 2
struct shadework	*swp;
char	*dp;
d290 9
a298 7
	point_t in_pt;	/* point where ray enters fire solid */
	point_t out_pt; /* point where ray leaves fire solid */
	point_t pt;
	vect_t	v_cloud;/* vector representing ray/solid intersection */
	double	thickness; /* magnitude of v_cloud (distance through solid) */
	int	steps;	   /* # of samples along ray/solid intersection */
	double	step_delta;/* distance between sample points */
d300 11
a310 3
	double  val;
	double	trans;
	double	density;
d312 2
d315 10
a324 2
	RT_AP_CHECK(ap);
	RT_CK_REGION(pp->pt_regionp);
d326 2
a327 2
	/* compute the ray/solid in and out points,
	 * and transform them into "shader space" coordinates 
d329 18
a346 2
	VJOIN1(pt, ap->a_ray.r_pt, pp->pt_inhit->hit_dist, ap->a_ray.r_dir);
	MAT4X3PNT(in_pt, fire_sp->xform, pt);
d348 7
a354 2
	VJOIN1(pt, ap->a_ray.r_pt, pp->pt_outhit->hit_dist, ap->a_ray.r_dir);
	MAT4X3PNT(out_pt, fire_sp->xform, pt);
d356 8
a363 6
	if (fire_sp->exp_use) {
		/* map flame height into the range 0 <= fh <= 10
		 * map that exponentially into range 0 < fh < 1
		 */
		in_pt[Z] =  1 - exp( - in_pt[Z] / fire_sp->flame_height);
		out_pt[Z] = 1 - exp( -out_pt[Z] / fire_sp->flame_height);
d366 13
a378 5
	/* get ray/solid intersection vector (in noise space)
	 * and compute thickness of solid (in noise space) along ray path
	 */
	VSUB2(v_cloud, out_pt, in_pt);
	thickness = MAGNITUDE(v_cloud);
d381 3
a383 1
	/* The noise field used by the noise_turb and noise_fbm routines
d386 23
a408 1
	 * "lacunarity" factor.  To sample this space adequately we need 
a409 7
	 *	4 samples per integer step for the first octave,
	 *	lacunarity * 4 samples/step for the second octave,
	 * 	lacunarity^2 * 4 samples/step for the third octave,
	 * 	lacunarity^3 * 4 samples/step for the forth octave,
	 *
	 * so for a computation with 4 octaves we need something on the
	 * order of lacunarity^3 * 4 samples per integer step in noise space.
d412 30
a441 22
	steps = pow(fire_sp->lacunarity, fire_sp->octaves-1) * 4;
	step_delta = thickness / (double)steps;

	VUNITIZE(v_cloud);
	VMOVE(pt, in_pt);
	trans = 1.0;
	for (i=0 ; i < steps ; i++ ) {
		/* compute the next point in the cloud space */
		VJOIN1(pt, in_pt, i*step_delta, v_cloud);

		val = noise_turb(pt, fire_sp->h_val,
			fire_sp->lacunarity, fire_sp->octaves );

		val *= 2.;
		val = CLAMP(val, 0.0, 1.0);
		val = 1 - val;

		/* trans *= exp( - density_per_mm * dist )
		 *
		 * density_per_mm
		 *	near zero when Z close to 1
		 *	near total opacity when Z = 0
d444 18
a461 1
		density = val * (1 - SMOOTHSTEP(pt[Z])) * 5.0;
a462 1
		trans *=  exp( - density * step_delta);
d465 20
a484 3
	swp->sw_transmit = trans;
/*	VSET(swp->sw_color, 0.0, 0.0, 0.0); */
	VSET(swp->sw_basecolor, 1.0, 1.0, 1.0);
@
