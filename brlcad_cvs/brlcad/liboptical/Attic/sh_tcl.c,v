head	1.12;
access;
symbols
	ansi-20040405-merged:1.9.2.1
	postmerge-20040405-ansi:1.10
	premerge-20040404-ansi:1.9
	postmerge-autoconf:1.9
	autoconf-freeze:1.9
	premerge-autoconf:1.9
	ansi-20040316-freeze:1.9.2.1
	postmerge-20040315-windows:1.9
	premerge-20040315-windows:1.9
	windows-20040315-freeze:1.9
	autoconf-20031203:1.9
	autoconf-20031202:1.9
	autoconf-branch:1.9.0.10
	phong-branch:1.9.0.8
	photonmap-branch:1.9.0.6
	rel-6-1-DP:1.9
	windows-branch:1.9.0.4
	rel-6-0-2:1.7
	ansi-branch:1.9.0.2
	rel-6-0-1-branch:1.7.0.2
	hartley-6-0-post:1.8
	hartley-6-0-pre:1.7
	rel-6-0-1:1.7
	rel-6-0:1.7
	rel-5-4:1.1
	offsite-5-3-pre:1.5
	rel-5-3:1.1
	rel-5-2:1.1
	rel-5-1-branch:1.1.0.2
	rel-5-1:1.1;
locks; strict;
comment	@ * @;


1.12
date	2004.05.21.18.07.28;	author morrison;	state dead;
branches;
next	1.11;

1.11
date	2004.05.10.15.30.45;	author erikg;	state Exp;
branches;
next	1.10;

1.10
date	2004.04.05.07.43.37;	author morrison;	state Exp;
branches;
next	1.9;

1.9
date	2002.08.20.17.07.52;	author jra;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2002.08.15.20.55.05;	author hartley;	state Exp;
branches;
next	1.7;

1.7
date	2001.10.17.07.40.03;	author morrison;	state Exp;
branches;
next	1.6;

1.6
date	2001.04.20.22.29.33;	author morrison;	state Exp;
branches;
next	1.5;

1.5
date	2000.10.19.19.19.46;	author butler;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.09.04.30.52;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	2000.08.20.01.27.48;	author butler;	state Exp;
branches;
next	1.2;

1.2
date	2000.07.25.16.40.38;	author butler;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.22.09.26.07;	author butler;	state Exp;
branches;
next	;

1.9.2.1
date	2002.09.19.18.01.26;	author morrison;	state Exp;
branches;
next	;


desc
@@


1.12
log
@moved to src/
@
text
@/*
 *	S H _ T C L . C
 *
 *  To add a new shader to the "rt" program's LIBOPTICAL library:
 *
 *	6) Edit shaders.tcl and comb.tcl in the ../tclscripts/mged directory to
 *		add a new gui for this shader.
 */
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef HAVE_STRING_H
#include <string.h>
#endif
#include <math.h>
#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "shadefuncs.h"
#include "shadework.h"
#include "rtprivate.h"
#include <tcl.h>

extern int rr_render(struct application	*ap,
		     struct partition	*pp,
		     struct shadework   *swp);
#define tcl_MAGIC 0x54434C00    /* "TCL" */
#define CK_tcl_SP(_p) BU_CKMAG(_p, tcl_MAGIC, "tcl_specific")

/*
 * the shader specific structure contains all variables which are unique
 * to any particular use of the shader.
 */
struct tcl_specific {
	long	magic;	/* magic # for memory validity check, must come 1st */
	mat_t			tcl_m_to_r; /* model to shader space matrix */
	Tcl_Interp	       *tcl_interp[MAX_PSW];
	Tcl_Obj		       *tcl_objPtr;
	struct bu_vls		tcl_file;   /* name of script to run */
	struct bu_mapped_file  *tcl_mp;	    /* actual script */
};

/* The default values for the variables in the shader specific structure */
const static
struct tcl_specific tcl_defaults = {
	tcl_MAGIC,
	{	0.0, 0.0, 0.0, 0.0,	/* tcl_m_to_r */
		0.0, 0.0, 0.0, 0.0,
		0.0, 0.0, 0.0, 0.0,
		0.0, 0.0, 0.0, 0.0 }
	};

#define SHDR_NULL	((struct tcl_specific *)0)
#define SHDR_O(m)	offsetof(struct tcl_specific, m)
#define SHDR_AO(m)	bu_offsetofarray(struct tcl_specific, m)


/* description of how to parse/print the arguments to the shader
 * There is at least one line here for each variable in the shader specific
 * structure above
 */
struct bu_structparse tcl_print_tab[] = {
	{"%S",  1, "file", SHDR_O(tcl_file),	BU_STRUCTPARSE_FUNC_NULL },
	{"",	0, (char *)0,	0,		BU_STRUCTPARSE_FUNC_NULL }

};
struct bu_structparse tcl_parse_tab[] = {
	{"i",	bu_byteoffset(tcl_print_tab[0]), "tcl_print_tab", 0, BU_STRUCTPARSE_FUNC_NULL },
	{"%S",  1, "f", SHDR_O(tcl_file),	BU_STRUCTPARSE_FUNC_NULL },
	{"",	0, (char *)0,	0,		BU_STRUCTPARSE_FUNC_NULL }
};

HIDDEN int	tcl_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip), tcl_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
HIDDEN void	tcl_print(register struct region *rp, char *dp), tcl_free(char *cp);

/* The "mfuncs" structure defines the external interface to the shader.
 * Note that more than one shader "name" can be associated with a given
 * shader by defining more than one mfuncs struct in this array.
 * See sh_phong.c for an example of building more than one shader "name"
 * from a set of source functions.  There you will find that "glass" "mirror"
 * and "plastic" are all names for the same shader with different default
 * values for the parameters.
 */
struct mfuncs tcl_mfuncs[] = {
	{MF_MAGIC,	"tcl",		0,		MFI_NORMAL|MFI_HIT|MFI_UV,	0,
	tcl_setup,	tcl_render,	tcl_print,	tcl_free },

	{0,		(char *)0,	0,		0,		0,
	0,		0,		0,		0 }
};


/*	T C L _ S E T U P
 *
 *	This routine is called (at prep time)
 *	once for each region which uses this shader.
 *	Any shader-specific initialization should be done here.
 */
HIDDEN int
tcl_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip)
                      	    
             		         
    			      	/* pointer to reg_udata in *rp */
             		     
           		      	/* New since 4.4 release */
{
	register struct tcl_specific	*tcl_sp;
	int cpu;

	/* check the arguments */
	RT_CHECK_RTI(rtip);
	BU_CK_VLS( matparm );
	RT_CK_REGION(rp);


	if (rdebug&RDEBUG_SHADE)
		bu_log("tcl_setup(%s)\n", rp->reg_name);

	/* Get memory for the shader parameters and shader-specific data */
	BU_GETSTRUCT( tcl_sp, tcl_specific );
	*dpp = (char *)tcl_sp;

	/* initialize the default values for the shader */
	memcpy(tcl_sp, &tcl_defaults, sizeof(struct tcl_specific) );

	/* parse the user's arguments for this use of the shader. */
	if (bu_struct_parse( matparm, tcl_parse_tab, (char *)tcl_sp ) < 0 )
		return(-1);

#if 0
	tcl_sp->tcl_mp = bu_open_mapped_file(bu_vls_addr(tcl_sp->tcl_file),
					     "tclShader");
	if (!tcl_sp->tcl_mp) {
		bu_log("Error opening Tcl shader file \"%s\"\n", 
		       bu_vls_addr(tcl_sp->tcl_file));
		bu_bomb("");
	}
#endif

	for (cpu=0 ; cpu < MAX_PSW ; cpu++) {
		tcl_sp->tcl_interp[cpu] = Tcl_CreateInterp();
		Tcl_Init(tcl_sp->tcl_interp[cpu]);
	}

	/* the shader needs to operate in a coordinate system which stays
	 * fixed on the region when the region is moved (as in animation)
	 * we need to get a matrix to perform the appropriate transform(s).
	 *
	 * Shading is be done in "region coordinates":
	 */
	db_region_mat(tcl_sp->tcl_m_to_r, rtip->rti_dbip, rp->reg_name, &rt_uniresource);


	if (rdebug&RDEBUG_SHADE) {
		bu_struct_print( " Parameters:", tcl_print_tab,
				 (char *)tcl_sp );
		bn_mat_print( "m_to_sh", tcl_sp->tcl_m_to_r );
	}

	return(1);
}

/*
 *	T C L _ P R I N T
 */
HIDDEN void
tcl_print(register struct region *rp, char *dp)
{
	bu_struct_print( rp->reg_name, tcl_print_tab, (char *)dp );
}

/*
 *	T C L _ F R E E
 */
HIDDEN void
tcl_free(char *cp)
{
	bu_free( cp, "tcl_specific" );
}

/*
 *	T C L _ R E N D E R
 *
 *	This is called (from viewshade() in shade.c) once for each hit point
 *	to be shaded.  The purpose here is to fill in values in the shadework
 *	structure.
 */
int
tcl_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
                  	    
                	    
                	     	/* defined in material.h */
    			    	/* ptr to the shader-specific struct */
{
	register struct tcl_specific *tcl_sp =
		(struct tcl_specific *)dp;
	point_t pt;
	int tcl_status;
	register int cpu = ap->a_resource->re_cpu;

	/* check the validity of the arguments we got */
	RT_AP_CHECK(ap);
	RT_CHECK_PT(pp);
	CK_tcl_SP(tcl_sp);

	if (rdebug&RDEBUG_SHADE)
		bu_struct_print( "tcl_render Parameters:",
				 tcl_print_tab, (char *)tcl_sp );

	/* we are performing the shading in "region" space, so we must 
	 * transform the hit point from "model" space to "region" space.
	 */
	MAT4X3PNT(pt, tcl_sp->tcl_m_to_r, swp->sw_hit.hit_point);

	if (rdebug&RDEBUG_SHADE) {
		bu_log("tcl_render()  model:(%g %g %g) shader:(%g %g %g)\n", 
		V3ARGS(swp->sw_hit.hit_point),
		V3ARGS(pt) );
	}

	/* set some Tcl variables to the shadework structure values */
	
#define rt_Tcl_LV(_s, _v) Tcl_LinkVar(tcl_sp->tcl_interp[cpu], _s, (char *)_v, \
				TCL_LINK_DOUBLE)

	rt_Tcl_LV("sw_transmit",	&swp->sw_transmit);
	rt_Tcl_LV("sw_reflect",		&swp->sw_reflect);
	rt_Tcl_LV("sw_refrac_index",	&swp->sw_refrac_index);
	rt_Tcl_LV("sw_temperature",	&swp->sw_temperature);
	rt_Tcl_LV("reflect",		&swp->sw_reflect);
	rt_Tcl_LV("sw_red",		&swp->sw_color[0]);
	rt_Tcl_LV("sw_grn",		&swp->sw_color[1]);
	rt_Tcl_LV("sw_blu",		&swp->sw_color[2]);
	rt_Tcl_LV("sw_base_red",	&swp->sw_basecolor[0]);
	rt_Tcl_LV("sw_base_grn",	&swp->sw_basecolor[1]);
	rt_Tcl_LV("sw_base_blu",	&swp->sw_basecolor[2]);
	rt_Tcl_LV("sw_dist",		&swp->sw_hit.hit_dist);
	rt_Tcl_LV("sw_hitpt_x",		&swp->sw_hit.hit_point[X]);
	rt_Tcl_LV("sw_hitpt_y",		&swp->sw_hit.hit_point[Y]);
	rt_Tcl_LV("sw_hitpt_z",		&swp->sw_hit.hit_point[Z]);
	rt_Tcl_LV("sw_normal_x",	&swp->sw_hit.hit_normal[X]);
	rt_Tcl_LV("sw_normal_y",	&swp->sw_hit.hit_normal[Y]);
	rt_Tcl_LV("sw_normal_z",	&swp->sw_hit.hit_normal[Z]);
	rt_Tcl_LV("sw_uv_u",		&swp->sw_uv.uv_u);
	rt_Tcl_LV("sw_uv_v",		&swp->sw_uv.uv_v);
	rt_Tcl_LV("sw_x",		&pt[X]);
	rt_Tcl_LV("sw_y",		&pt[Y]);
	rt_Tcl_LV("sw_z",		&pt[Z]);
	Tcl_LinkVar(tcl_sp->tcl_interp[cpu], "ap_x", (char *)&ap->a_x,
		    TCL_LINK_INT);
	Tcl_LinkVar(tcl_sp->tcl_interp[cpu], "ap_y", (char *)&ap->a_y,
		    TCL_LINK_INT);

	/* XXX run the script (should be Tcl_EvalObj) */
	tcl_status = Tcl_EvalFile(tcl_sp->tcl_interp[cpu],
				  bu_vls_addr(&tcl_sp->tcl_file));

	if (tcl_status != TCL_OK) {
		bu_log("%s\n", Tcl_GetStringResult(tcl_sp->tcl_interp[cpu]));
	}

	/* break the links to these stack variables */
	Tcl_UnlinkVar(tcl_sp->tcl_interp[cpu], "sw_transmit");
	Tcl_UnlinkVar(tcl_sp->tcl_interp[cpu], "sw_reflect");
	Tcl_UnlinkVar(tcl_sp->tcl_interp[cpu], "sw_refrac_index");
	Tcl_UnlinkVar(tcl_sp->tcl_interp[cpu], "sw_temperature");
	Tcl_UnlinkVar(tcl_sp->tcl_interp[cpu], "reflect");
	Tcl_UnlinkVar(tcl_sp->tcl_interp[cpu], "sw_red");
	Tcl_UnlinkVar(tcl_sp->tcl_interp[cpu], "sw_grn");
	Tcl_UnlinkVar(tcl_sp->tcl_interp[cpu], "sw_blu");
	Tcl_UnlinkVar(tcl_sp->tcl_interp[cpu], "sw_base_red");
	Tcl_UnlinkVar(tcl_sp->tcl_interp[cpu], "sw_base_grn");
	Tcl_UnlinkVar(tcl_sp->tcl_interp[cpu], "sw_base_blu");
	Tcl_UnlinkVar(tcl_sp->tcl_interp[cpu], "sw_dist");
	Tcl_UnlinkVar(tcl_sp->tcl_interp[cpu], "sw_hitpt_x");
	Tcl_UnlinkVar(tcl_sp->tcl_interp[cpu], "sw_hitpt_y");
	Tcl_UnlinkVar(tcl_sp->tcl_interp[cpu], "sw_hitpt_z");
	Tcl_UnlinkVar(tcl_sp->tcl_interp[cpu], "sw_normal_x");
	Tcl_UnlinkVar(tcl_sp->tcl_interp[cpu], "sw_normal_y");
	Tcl_UnlinkVar(tcl_sp->tcl_interp[cpu], "sw_normal_z");
	Tcl_UnlinkVar(tcl_sp->tcl_interp[cpu], "sw_uv_u");
	Tcl_UnlinkVar(tcl_sp->tcl_interp[cpu], "sw_uv_v");
	Tcl_UnlinkVar(tcl_sp->tcl_interp[cpu], "sw_x");
	Tcl_UnlinkVar(tcl_sp->tcl_interp[cpu], "sw_y");
	Tcl_UnlinkVar(tcl_sp->tcl_interp[cpu], "sw_z");
	Tcl_UnlinkVar(tcl_sp->tcl_interp[cpu], "ap_x");
	Tcl_UnlinkVar(tcl_sp->tcl_interp[cpu], "ap_y");


	/* shader must perform transmission/reflection calculations
	 *
	 * 0 < swp->sw_transmit <= 1 causes transmission computations
	 * 0 < swp->sw_reflect <= 1 causes reflection computations
	 */
	if (swp->sw_reflect > 0 || swp->sw_transmit > 0 )
		(void)rr_render( ap, pp, swp );

	return(1);
}
@


1.11
log
@change conf.h to a wrapped config.h
@
text
@@


1.10
log
@merge of ansi-6-0-branch into HEAD
@
text
@d9 5
a13 1
#include "conf.h"
@


1.9
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d73 2
a74 2
HIDDEN int	tcl_setup(), tcl_render();
HIDDEN void	tcl_print(), tcl_free();
d100 6
a105 6
tcl_setup( rp, matparm, dpp, mfp, rtip)
register struct region	*rp;
struct bu_vls		*matparm;
char			**dpp;	/* pointer to reg_udata in *rp */
struct mfuncs		*mfp;
struct rt_i		*rtip;	/* New since 4.4 release */
d167 1
a167 3
tcl_print( rp, dp )
register struct region *rp;
char	*dp;
d176 1
a176 2
tcl_free( cp )
char *cp;
d189 5
a193 5
tcl_render( ap, pp, swp, dp )
struct application	*ap;
struct partition	*pp;
struct shadework	*swp;	/* defined in material.h */
char			*dp;	/* ptr to the shader-specific struct */
@


1.9.2.1
log
@Initial ANSIfication
@
text
@d73 2
a74 2
HIDDEN int	tcl_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip), tcl_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
HIDDEN void	tcl_print(register struct region *rp, char *dp), tcl_free(char *cp);
d100 6
a105 6
tcl_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip)
                      	    
             		         
    			      	/* pointer to reg_udata in *rp */
             		     
           		      	/* New since 4.4 release */
d167 3
a169 1
tcl_print(register struct region *rp, char *dp)
d178 2
a179 1
tcl_free(char *cp)
d192 5
a196 5
tcl_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
                  	    
                	    
                	     	/* defined in material.h */
    			    	/* ptr to the shader-specific struct */
@


1.8
log
@Converted from K&R to ANSI C - RFH
@
text
@d73 2
a74 2
HIDDEN int	tcl_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip), tcl_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
HIDDEN void	tcl_print(register struct region *rp, char *dp), tcl_free(char *cp);
d100 6
a105 6
tcl_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip)
                      	    
             		         
    			      	/* pointer to reg_udata in *rp */
             		     
           		      	/* New since 4.4 release */
d167 3
a169 1
tcl_print(register struct region *rp, char *dp)
d178 2
a179 1
tcl_free(char *cp)
d192 5
a196 5
tcl_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
                  	    
                	    
                	     	/* defined in material.h */
    			    	/* ptr to the shader-specific struct */
@


1.7
log
@Mac OS X warning and error fixes for non-production build
@
text
@d73 2
a74 2
HIDDEN int	tcl_setup(), tcl_render();
HIDDEN void	tcl_print(), tcl_free();
d100 6
a105 6
tcl_setup( rp, matparm, dpp, mfp, rtip)
register struct region	*rp;
struct bu_vls		*matparm;
char			**dpp;	/* pointer to reg_udata in *rp */
struct mfuncs		*mfp;
struct rt_i		*rtip;	/* New since 4.4 release */
d167 1
a167 3
tcl_print( rp, dp )
register struct region *rp;
char	*dp;
d176 1
a176 2
tcl_free( cp )
char *cp;
d189 5
a193 5
tcl_render( ap, pp, swp, dp )
struct application	*ap;
struct partition	*pp;
struct shadework	*swp;	/* defined in material.h */
char			*dp;	/* ptr to the shader-specific struct */
@


1.6
log
@CONST to const
@
text
@d93 1
a93 1
/*	T C L _ S E T U P
d163 1
a163 1
/*
d184 1
a184 1
/*
@


1.5
log
@Changes to compile under RedHat 7.0
@
text
@d44 1
a44 1
CONST static
@


1.4
log
@
Struct db_tree_state finally got a magic number. Added resource argument
to ft_describe(), db_region_mat(), db_shader_mat(),
db_init_db_tree_state(), and db_path_to_mat().
@
text
@d12 3
@


1.3
log
@Eliminate compilation warnings, enhancements to sh_light.c
@
text
@d148 1
a148 1
	db_region_mat(tcl_sp->tcl_m_to_r, rtip->rti_dbip, rp->reg_name);
@


1.2
log
@Changes to use rtprivate.h instead of ../rt/rdebug.h
@
text
@d47 1
a47 2
		0.0, 0.0, 0.0, 0.0 },
	(Tcl_Interp *)NULL
@


1.1
log
@Added a shader which evaluates a Tcl script to determine the shading results.
@
text
@d18 1
a18 1
#include "../rt/rdebug.h"
d21 3
a105 2
	mat_t	tmp;
	vect_t	bb_min, bb_max, v_tmp;
a199 1
	char newVal[64];
@

