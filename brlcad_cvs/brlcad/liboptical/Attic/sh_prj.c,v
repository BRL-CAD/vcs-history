head	1.45;
access;
symbols
	ansi-20040405-merged:1.38.2.3
	postmerge-20040405-ansi:1.43
	premerge-20040404-ansi:1.42
	postmerge-autoconf:1.42
	autoconf-freeze:1.42
	premerge-autoconf:1.42
	ansi-20040316-freeze:1.38.2.1
	postmerge-20040315-windows:1.42
	premerge-20040315-windows:1.42
	windows-20040315-freeze:1.38.4.1
	autoconf-20031203:1.42
	autoconf-20031202:1.42
	autoconf-branch:1.42.0.4
	phong-branch:1.42.0.2
	photonmap-branch:1.41.0.2
	rel-6-1-DP:1.38
	windows-branch:1.38.0.4
	rel-6-0-2:1.36
	ansi-branch:1.38.0.2
	rel-6-0-1-branch:1.36.0.2
	hartley-6-0-post:1.37
	hartley-6-0-pre:1.36
	rel-6-0-1:1.36
	rel-6-0:1.36
	rel-5-4:1.27.2.2
	offsite-5-3-pre:1.32
	rel-5-3:1.27.2.2
	rel-5-2:1.27
	rel-5-1-branch:1.27.0.2
	rel-5-1:1.27
	rel-5-0:1.24
	rel-5-0-beta:1.22
	rel-4-5:1.4
	ctj-4-5-post:1.3
	ctj-4-5-pre:1.3;
locks; strict;
comment	@ * @;


1.45
date	2004.05.21.18.07.27;	author morrison;	state dead;
branches;
next	1.44;

1.44
date	2004.05.10.15.30.45;	author erikg;	state Exp;
branches;
next	1.43;

1.43
date	2004.04.05.07.43.37;	author morrison;	state Exp;
branches;
next	1.42;

1.42
date	2003.09.10.19.06.11;	author butler;	state Exp;
branches;
next	1.41;

1.41
date	2002.12.04.03.01.15;	author morrison;	state Exp;
branches;
next	1.40;

1.40
date	2002.12.04.01.16.38;	author morrison;	state Exp;
branches;
next	1.39;

1.39
date	2002.11.06.23.29.15;	author morrison;	state Exp;
branches;
next	1.38;

1.38
date	2002.08.20.17.07.51;	author jra;	state Exp;
branches
	1.38.2.1
	1.38.4.1;
next	1.37;

1.37
date	2002.08.15.20.55.04;	author hartley;	state Exp;
branches;
next	1.36;

1.36
date	2002.01.08.21.59.21;	author jra;	state Exp;
branches;
next	1.35;

1.35
date	2001.10.17.07.40.03;	author morrison;	state Exp;
branches;
next	1.34;

1.34
date	2001.04.20.22.29.33;	author morrison;	state Exp;
branches;
next	1.33;

1.33
date	2001.03.31.01.57.02;	author morrison;	state Exp;
branches;
next	1.32;

1.32
date	2000.11.20.13.50.02;	author jra;	state Exp;
branches;
next	1.31;

1.31
date	2000.09.09.04.30.51;	author mike;	state Exp;
branches;
next	1.30;

1.30
date	2000.09.09.03.46.13;	author mike;	state Exp;
branches;
next	1.29;

1.29
date	2000.08.20.01.27.48;	author butler;	state Exp;
branches;
next	1.28;

1.28
date	2000.07.25.16.40.38;	author butler;	state Exp;
branches;
next	1.27;

1.27
date	2000.02.19.21.05.02;	author butler;	state Exp;
branches
	1.27.2.1;
next	1.26;

1.26
date	99.12.30.16.22.04;	author jra;	state Exp;
branches;
next	1.25;

1.25
date	99.10.30.03.06.24;	author butler;	state Exp;
branches;
next	1.24;

1.24
date	99.07.02.22.20.41;	author mike;	state Exp;
branches;
next	1.23;

1.23
date	99.07.01.20.08.47;	author mike;	state Exp;
branches;
next	1.22;

1.22
date	99.04.08.21.01.46;	author jra;	state Exp;
branches;
next	1.21;

1.21
date	99.04.08.19.41.16;	author jra;	state Exp;
branches;
next	1.20;

1.20
date	99.04.07.17.55.47;	author jra;	state Exp;
branches;
next	1.19;

1.19
date	99.02.04.00.06.38;	author butler;	state Exp;
branches;
next	1.18;

1.18
date	99.01.25.05.29.56;	author butler;	state Exp;
branches;
next	1.17;

1.17
date	99.01.22.21.56.57;	author butler;	state Exp;
branches;
next	1.16;

1.16
date	99.01.20.03.18.07;	author butler;	state Exp;
branches;
next	1.15;

1.15
date	99.01.20.03.15.37;	author butler;	state Exp;
branches;
next	1.14;

1.14
date	98.09.22.01.29.55;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	98.06.30.22.54.18;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	98.06.25.08.28.45;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	98.06.25.07.40.56;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	98.04.06.19.53.47;	author butler;	state Exp;
branches;
next	1.9;

1.9
date	98.04.06.19.51.42;	author butler;	state Exp;
branches;
next	1.8;

1.8
date	98.04.06.19.50.24;	author butler;	state Exp;
branches;
next	1.7;

1.7
date	98.03.20.23.09.23;	author butler;	state Exp;
branches;
next	1.6;

1.6
date	98.03.08.19.53.15;	author butler;	state Exp;
branches;
next	1.5;

1.5
date	98.03.04.18.25.13;	author butler;	state Exp;
branches;
next	1.4;

1.4
date	97.12.31.09.01.40;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	97.05.21.21.16.04;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	97.05.21.21.15.04;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	97.03.28.22.24.06;	author butler;	state Exp;
branches;
next	;

1.27.2.1
date	2000.11.19.16.59.01;	author jra;	state Exp;
branches;
next	1.27.2.2;

1.27.2.2
date	2000.11.20.00.08.13;	author jra;	state Exp;
branches;
next	;

1.38.2.1
date	2002.09.19.18.01.26;	author morrison;	state Exp;
branches;
next	1.38.2.2;

1.38.2.2
date	2004.03.17.21.18.32;	author morrison;	state Exp;
branches;
next	1.38.2.3;

1.38.2.3
date	2004.04.02.16.06.57;	author morrison;	state Exp;
branches;
next	;

1.38.4.1
date	2004.03.11.23.43.02;	author morrison;	state Exp;
branches;
next	;


desc
@slide projector texture shader
@


1.45
log
@moved to src/
@
text
@/*
 *	S H _ P R J . C
 *
 *	Projection shader
 *
 *	The one parameter to this shader is a filename.  The named file
 *	contains the REAL parameters to the shader.  The v4 database format
 *	is far too anemic to support this sort of shader.
 *
 */
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <fcntl.h>
#include <string.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <math.h>
#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "raytrace.h"
#include "shadefuncs.h"
#include "shadework.h"
#include "../rt/ext.h"
#include "rtprivate.h"
#include "plot3.h"

/* not in a header, but provided by librt */
HIDDEN void rt_binunif_free();

#define prj_MAGIC 0x70726a00	/* "prj" */
#define CK_prj_SP(_p) BU_CKMAG(_p, prj_MAGIC, "prj_specific")

struct img_specific {
  struct bu_list	l;
  unsigned long	junk;
  struct bu_vls i_name; /* name of object or file (depending on i_datasrc flag) */
#define IMG_SRC_FILE 'f'
#define IMG_SRC_OBJECT  'o'
#define IMG_SRC_AUTO 0
  char i_datasrc; /* is the datasource a file/object or automatic */
  struct bu_mapped_file *i_data; /* mapped file when IMG_SRC_FILE */
  struct rt_binunif_internal *i_binunifp;  /* db internal object when IMG_SRC_OBJECT */
  unsigned char *i_img;
  int		i_width;
  int		i_height;
  fastf_t	i_viewsize;
  point_t	i_eye_pt;
  quat_t	i_orient;
  mat_t		i_mat;		/* computed from i_orient */
  mat_t		i_bn_mat_inv;	/* computed (for debug) */
  plane_t	i_plane;	/* dir/plane of projection */
  mat_t		i_sh_to_img;	/* transform used in prj_render() */
  char		i_through;	/* ignore surface normal */
  char		i_antialias;	/* anti-alias texture */
  char		i_behind;	/* shade points behind img plane */
  fastf_t	i_perspective;	/* perspective angle 0=ortho */
};
#define img_MAGIC	0x696d6700	/* "img" */

/*
 * the shader specific structure contains all variables which are unique
 * to any particular use of the shader.
 */
struct prj_specific {
	unsigned long		magic;
	struct img_specific	prj_images;
	mat_t			prj_m_to_sh;
	FILE			*prj_plfd;
};

/*
 *  img_source_hook() is used to record where the image datasource is coming from
 *  so that the image may be loaded automatically as needed from either a file or
 *  from a database-embedded binary object.
 */
HIDDEN void img_source_hook(const struct bu_structparse *ip, const char *sp_name, genptr_t base, char *p) {
  struct img_specific *imageSpecific = (struct img_specific *)base;
  if (strncmp(sp_name, "file", 4) == 0) {
    imageSpecific->i_datasrc=IMG_SRC_FILE;
  } else if (strncmp(sp_name, "obj", 3) == 0) {
    imageSpecific->i_datasrc=IMG_SRC_OBJECT;
  } else {
    imageSpecific->i_datasrc=IMG_SRC_AUTO;
  }
}


/*
 *	i m g _ l o a d _ d a t a s o u r c e
 *
 * This is a helper routine used in prj_setup() to load a projection image
 * either from a file or from a db object.
 */
HIDDEN int img_load_datasource(struct img_specific *image, struct db_i *dbInstance, const unsigned long int size) {
	struct directory *dirEntry;

	RT_CK_DBI(dbInstance);

	if (image == (struct img_specific *)NULL) {
		bu_bomb("ERROR: img_load_datasource() received NULL arg (struct img_specific *)\n");
	}

	bu_log("Loading image %s [%S]...", image->i_datasrc==IMG_SRC_AUTO?"from auto-determined datasource":image->i_datasrc==IMG_SRC_OBJECT?"from a database object":image->i_datasrc==IMG_SRC_FILE?"from a file":"from an unknown source (ERROR)", &image->i_name);

	/* if the source is auto or object, we try to load the object */
	if ((image->i_datasrc==IMG_SRC_AUTO) || (image->i_datasrc==IMG_SRC_OBJECT)) {

		/* see if the object exists */
		if ( (dirEntry=db_lookup(dbInstance, bu_vls_addr(&image->i_name), LOOKUP_QUIET)) == DIR_NULL) {

			/* unable to find the image object */
			if (image->i_datasrc!=IMG_SRC_AUTO) {
				return -1;
			}
		}
		else {
			struct rt_db_internal *dbip=(struct rt_db_internal *)bu_malloc(sizeof(struct rt_db_internal), "img_load_datasource");

			RT_INIT_DB_INTERNAL(dbip);
			RT_CK_DB_INTERNAL(dbip);
			RT_CK_DIR(dirEntry);

			/* the object was in the directory, so go get it */
			if (rt_db_get_internal(dbip, dirEntry, dbInstance, NULL, NULL) <= 0) {
				/* unable to load/create the image database record object */
				return -1;
			}

			RT_CK_DB_INTERNAL(dbip);
			RT_CK_BINUNIF(dbip->idb_ptr);

			/* keep the binary object pointer */
			image->i_binunifp=(struct rt_binunif_internal *)dbip->idb_ptr; /* make it so */
			
			/* release the database struct we created */
			RT_INIT_DB_INTERNAL(dbip);
			bu_free(dbip, "img_load_datasource");

			/* check size of object */
			if (image->i_binunifp->count < size) {
				bu_log("\nWARNING: %S needs %d bytes, binary object only has %d\n", &image->i_name, size, image->i_binunifp->count);
			} else if (image->i_binunifp->count > size) {
				bu_log("\nWARNING: Binary object is larger than specified image size\n\tBinary Object: %d pixels\n\tSpecified Image Size: %d pixels\n...continuing to load using image subsection...", image->i_binunifp->count);
			}
			image->i_img = (unsigned char *) image->i_binunifp->u.uint8;

		}
	}

	/* if we are auto and we couldn't find a database object match, or if source
	 * is explicitly a file then we load the file.
	 */
	if ( ( (image->i_datasrc==IMG_SRC_AUTO) && (image->i_binunifp==NULL) ) || (image->i_datasrc==IMG_SRC_FILE) ) {


		image->i_data = bu_open_mapped_file_with_path(dbInstance->dbi_filepath,	bu_vls_addr(&image->i_name), NULL);
		
		if ( image->i_data==NULL )
			return -1;				/* FAIL */

		if (image->i_data->buflen < size) {
			bu_log("\nWARNING: %S needs %d bytes, file only has %d\n", &image->i_name, size, image->i_data->buflen);
		} else if (image->i_data->buflen > size) {
			bu_log("\nWARNING: Image file size is larger than specified image size\n\tInput File: %d pixels\n\tSpecified Image Size: %d pixels\n...continuing to load using image subsection...", image->i_data->buflen, size);
		}

		image->i_img = (unsigned char *) image->i_data->buf;		
	}

	bu_log("done.\n");

	return 0;
}


/*
 *
 *  Bounds checking on perspective angle
 *
 */
HIDDEN void 
persp_hook(register const struct bu_structparse *sdp, register const char *name, char *base, const char *value)
                                    	     	/* structure description */
                   			      	/* struct member name */
    					      	/* begining of structure */
          				       	/* string containing value */
{
	struct img_specific *img_sp = (struct img_specific *)base;

	if (img_sp->i_perspective < 0.0) {
		bu_log("perspecitve %s < 0.0\n", value);
		bu_bomb("");
	}

 	if (img_sp->i_perspective > 180.0) {
		bu_log("perspective %s > 180.\n", value);
		bu_bomb("");
	}

	if (img_sp->i_perspective != 0.0)
		bu_bomb("non-ortho perspective not yet implemented!\n");
}


/*
 * Check for value < 0.0
 *
 */
HIDDEN void 
dimen_hook(register const struct bu_structparse *sdp, register const char *name, char *base, const char *value)
                                    	     	/* structure description */
                   			      	/* struct member name */
    					      	/* begining of structure */
          				       	/* string containing value */
{
	if (! strcmp("%f", sdp->sp_fmt)) {
		fastf_t *f;
		f = (fastf_t *)(base + sdp->sp_offset);
		if (*f < 0.0) {
			bu_log("%s value %g(%s) < 0.0\n",
				sdp->sp_name, *f, value);
			bu_bomb("");
		}
	} else if (! strcmp("%d", sdp->sp_fmt)) {
		int *i;
		i = (int *)(base + sdp->sp_offset);
		if (*i < 0) {
			bu_log("%s value %d(%s) < 0.0\n",
				sdp->sp_name, *i, value);
			bu_bomb("");
		}
	}
}


#if 0
HIDDEN void 
noop_hook( sdp, name, base, value )
register const struct bu_structparse	*sdp;	/* structure description */
register const char			*name;	/* struct member name */
char					*base;	/* begining of structure */
const char				*value;	/* string containing value */
{
	struct img_specific *img_sp = (struct img_specific *)base;

	BU_CK_LIST_HEAD(&img_sp->l);

	bu_log("%s \"%s\"\n", sdp->sp_name, value);

	BU_CK_VLS(&img_sp->i_name);
}
#endif
/* 
 * This routine is responsible for duplicating the image list head to make
 * a new list element.  It used to read in pixel data for an image (this is
 * now done in the prj_setup() routine), and computes the matrix from the view 
 * quaternion.  
 *
 * XXX "orient" MUST ALWAYS BE THE LAST PARAMETER SPECIFIED FOR EACH IMAGE.
 */
static void 
orient_hook(register const struct bu_structparse *sdp, register const char *name, char *base, const char *value)
                                    	     	/* structure description */
                   			      	/* struct member name */
    					      	/* begining of structure */
          				       	/* string containing value */
{
	struct prj_specific	*prj_sp;
	struct img_specific	*img_sp = (struct img_specific *)base;
	struct img_specific	*img_new;
	mat_t			trans, scale, tmp, xform;
	vect_t			v_tmp;
	point_t			p_tmp;

	BU_CK_LIST_HEAD(&img_sp->l);

	/* create a new img_specific struct,
	 * copy the parameters from the "head" into the new
	 * img_specific struct
	 */
	BU_GETSTRUCT(img_new, img_specific);
	memcpy(img_new, img_sp, sizeof(struct img_specific));
	BU_CK_VLS(&img_sp->i_name);


	/* zero the filename for the next iteration */
	bu_vls_init(&img_sp->i_name);

	/* Generate matrix from the quaternion */
	quat_quat2mat(img_new->i_mat, img_new->i_orient);


	/* compute matrix to transform region coordinates into 
	 * shader projection coordinates:
	 *
	 *	prj_coord = scale * rot * translate * region_coord
	 */
	MAT_IDN(trans);
	MAT_DELTAS_VEC_NEG(trans, img_new->i_eye_pt);

	MAT_IDN(scale);
	MAT_SCALE_ALL(scale, img_new->i_viewsize);

	bn_mat_mul(tmp, img_new->i_mat, trans);
	bn_mat_mul(img_new->i_sh_to_img, scale, tmp);


	VSET(v_tmp, 0.0, 0.0, 1.0);

	/* compute inverse */
	bn_mat_inv(img_new->i_bn_mat_inv, img_new->i_mat);
	bn_mat_inv(xform, img_new->i_sh_to_img);

	MAT4X3VEC(img_new->i_plane, xform, v_tmp);
	VUNITIZE(img_new->i_plane);

	if (rdebug&RDEBUG_SHADE) {
		point_t pt;		

#if 0
		img_new->i_plane[H] = 
			VDOT(img_new->i_plane, img_new->i_eye_pt);
#endif
		prj_sp = (struct prj_specific *)
			(base - (offsetof(struct prj_specific, prj_images)));
		CK_prj_SP(prj_sp);

		if (!prj_sp->prj_plfd)
			bu_bomb("prj shader prj_plfd should be open\n");

		/* plot out the extent of the image frame */
		pl_color(prj_sp->prj_plfd, 255, 0, 0);

		VSET(v_tmp, -0.5, -0.5, 0.0);
		MAT4X3PNT(pt, xform, v_tmp);
		pdv_3move(prj_sp->prj_plfd, pt);

		VSET(v_tmp, 0.5, -0.5, 0.0);
		MAT4X3PNT(p_tmp, xform, v_tmp);
		pdv_3cont(prj_sp->prj_plfd, p_tmp);

		VSET(v_tmp, 0.5, 0.5, 0.0);
		MAT4X3PNT(p_tmp, xform, v_tmp);
		pdv_3cont(prj_sp->prj_plfd, p_tmp);

		VSET(v_tmp, -0.5, 0.5, 0.0);
		MAT4X3PNT(p_tmp, xform, v_tmp);
		pdv_3cont(prj_sp->prj_plfd, p_tmp);

		pdv_3cont(prj_sp->prj_plfd, pt);

		VSET(v_tmp, 0.0, 0.0, 0.0);
		MAT4X3PNT(p_tmp, xform, v_tmp);
		pdv_3move(prj_sp->prj_plfd, p_tmp);
		VREVERSE(pt, img_new->i_plane);
		VADD2(p_tmp, p_tmp, pt);
		pdv_3cont(prj_sp->prj_plfd, p_tmp);

	}

	/* read in the pixel data now happens in prj_setup() */
	/* we add an image to the list of images regardless of whether the data is valid or not */
	BU_LIST_MAGIC_SET(&img_new->l, img_MAGIC);
	BU_LIST_APPEND(&img_sp->l, &img_new->l);
}

#define IMG_O(m)	offsetof(struct img_specific, m)
#define IMG_AO(m)	bu_offsetofarray(struct img_specific, m)


/* description of how to parse/print the arguments to the shader
 * There is at least one line here for each variable in the shader specific
 * structure above
 */
struct bu_structparse img_parse_tab[] = {
	{"%S",	1, "image",		IMG_O(i_name),		BU_STRUCTPARSE_FUNC_NULL},
	{"%S",  1, "file",		IMG_O(i_name),		img_source_hook},
	{"%S",	1, "obj",		IMG_O(i_name),		img_source_hook},
	{"%S",	1, "object",		IMG_O(i_name),		img_source_hook},
	{"%d",	1, "w",			IMG_O(i_width),		dimen_hook},
	{"%d",	1, "n",			IMG_O(i_height),	dimen_hook},
	{"%f",	1, "viewsize",		IMG_O(i_viewsize),	dimen_hook},
	{"%f",	3, "eye_pt",		IMG_AO(i_eye_pt),	BU_STRUCTPARSE_FUNC_NULL},
	{"%f",	4, "orientation",	IMG_AO(i_orient),	orient_hook},
	{"%c",	1, "through",		IMG_O(i_through),	BU_STRUCTPARSE_FUNC_NULL},
	{"%c",	1, "antialias",		IMG_O(i_antialias),	BU_STRUCTPARSE_FUNC_NULL},
	{"%c",	1, "behind",		IMG_O(i_behind),	BU_STRUCTPARSE_FUNC_NULL},
	{"%c",	1, "perspective",	IMG_O(i_perspective),	persp_hook},
	{"",	0, (char *)0,		0,			BU_STRUCTPARSE_FUNC_NULL}
};
struct bu_structparse img_print_tab[] = {
	{"i",	bu_byteoffset(img_parse_tab[0]), "img_parse_tab", 0, BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	4, "i_plane",		IMG_AO(i_plane),	BU_STRUCTPARSE_FUNC_NULL},
	{"",	0, (char *)0,		0,			BU_STRUCTPARSE_FUNC_NULL}
};



HIDDEN int	prj_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip), prj_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
HIDDEN void	prj_print(register struct region *rp, char *dp), prj_free(char *cp);

/* The "mfuncs" structure defines the external interface to the shader.
 * Note that more than one shader "name" can be associated with a given
 * shader by defining more than one mfuncs struct in this array.
 * See sh_phong.c for an example of building more than one shader "name"
 * from a set of source functions.  There you will find that "glass" "mirror"
 * and "plastic" are all names for the same shader with different default
 * values for the parameters.
 */
struct mfuncs prj_mfuncs[] = {
	{MF_MAGIC,	"prj",		0,		MFI_NORMAL|MFI_HIT|MFI_UV,	0,
	prj_setup,	prj_render,	prj_print,	prj_free },

	{0,		(char *)0,	0,		0,		0,
	0,		0,		0,		0 }
};


/*	P R J _ S E T U P
 *
 *	This routine is called (at prep time)
 *	once for each region which uses this shader.
 *	Any shader-specific initialization should be done here.
 */
HIDDEN int
prj_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip)
                      	    
             		         
    			      	/* pointer to reg_udata in *rp */
             		     
           		      	/* New since 4.4 release */
{
	struct prj_specific		*prj_sp;
	struct img_specific		*img_sp;
#if 0
	char * fname;
#endif
	struct bu_vls 			parameter_data;
	struct bu_mapped_file		*parameter_file;

	/* check the arguments */
	RT_CHECK_RTI(rtip);
	BU_CK_VLS( matparm );
	RT_CK_REGION(rp);

	if (rdebug&RDEBUG_SHADE)
		bu_log("prj_setup(%s) matparm:\"%s\"\n",
			rp->reg_name, bu_vls_addr(matparm));

	/* Get memory for the shader parameters and shader-specific data */
	BU_GETSTRUCT( prj_sp, prj_specific );
	*dpp = (char *)prj_sp;

	prj_sp->magic = prj_MAGIC;
	BU_LIST_INIT(&prj_sp->prj_images.l);


	if (rdebug&RDEBUG_SHADE) {
	  if ((prj_sp->prj_plfd=fopen("prj.pl", "w")) == (FILE *)NULL) {
	    bu_log("ERROR creating plot file prj.pl");
	  }
	} else {
	  prj_sp->prj_plfd = (FILE *)NULL;
	}
	
#if 0
	fname = bu_vls_addr(matparm);
	if (! isspace(*fname) )
	  bu_log("------ Stack shader fixed?  Remove hack from prj shader ----\n");
	while (isspace(*fname)) fname++; /* XXX Hack till stack shader fixed */
	
#endif
	if (! *(bu_vls_addr(matparm))) {
	  bu_log("ERROR: Null projection shader file or options?\n");
	  return -1;
	}
	
	/* first we try to open the specified argument as a file, as previously implemented.  
	 * if it succeeds, then the file contents become the parameter data.  Otherwise, the
	 * argument string considered the parameter data.
	 */
	
	bu_vls_init(&parameter_data);
	parameter_file = bu_open_mapped_file( bu_vls_addr(matparm), (char *)NULL );

	if (parameter_file) {
	  /* the file loaded, so the contents become the parameter string */
	  bu_log("Filename: %s\n", bu_vls_addr(matparm));
	  
	  bu_vls_strncpy( &parameter_data, (char *)parameter_file->buf,
			  parameter_file->buflen );
	  
	  if (rdebug&RDEBUG_SHADE ) {
	    bu_log("parsing: %s\n", bu_vls_addr(&parameter_data));
	  }

	  bu_close_mapped_file( parameter_file );
	} else {
	  /* the file did not load, so the shader args become the param string */
	  bu_log("Parameters: %s\n", bu_vls_addr(matparm));

	  bu_vls_strncpy ( &parameter_data, bu_vls_addr(matparm), bu_vls_strlen(matparm) );
	}

	/* set defaults on img_specific struct */
	prj_sp->prj_images.i_width = prj_sp->prj_images.i_height = 512;
	prj_sp->prj_images.i_antialias = '1';
	prj_sp->prj_images.i_through = '0';
	prj_sp->prj_images.i_behind = '0';
	prj_sp->prj_images.i_datasrc = IMG_SRC_AUTO;

	/* sanity */
	prj_sp->prj_images.i_data = GENPTR_NULL;
	prj_sp->prj_images.i_binunifp = GENPTR_NULL;
	prj_sp->prj_images.i_img = GENPTR_NULL;

	if(bu_struct_parse( &parameter_data, img_parse_tab, 
			    (char *)&prj_sp->prj_images) < 0) {
	  bu_log("ERROR: Unable to properly parse projection shader parameters\n");
	  return -1;
	}

	bu_vls_free( &parameter_data );

        /* load the image data for any specified images */
        for (BU_LIST_FOR(img_sp, img_specific, &prj_sp->prj_images.l)) {
	  if (img_load_datasource(img_sp, rtip->rti_dbip, img_sp->i_width * img_sp->i_height * 3) < 0) {
	    bu_log("\nERROR: prj_setup() %s %s could not be loaded [source was %s]\n", rp->reg_name, bu_vls_addr(&img_sp->i_name), img_sp->i_datasrc==IMG_SRC_OBJECT?"object":img_sp->i_datasrc==IMG_SRC_FILE?"file":"auto");

	    /* skip this one */
	    img_sp->i_through=0;
	    HREVERSE(img_sp->i_plane,img_sp->i_plane);

	    return -1;
	  }
        }

	/* if even one of the images is to be anti-aliased, then we need
	 * to set the rti_prismtrace flag so that we can compute the exact
	 * extent of the pixel.
	 */
	for (BU_LIST_FOR(img_sp, img_specific, &prj_sp->prj_images.l)) {
		if (img_sp->i_antialias != '0') {
			if (rdebug&RDEBUG_SHADE)
				bu_log("prj_setup(%s) setting prismtrace 1\n", rp->reg_name);
			rtip->rti_prismtrace = 1;
			break;
		}
	}

	/* The shader needs to operate in a coordinate system which stays
	 * fixed on the region when the region is moved (as in animation)
	 * we need to get a matrix to perform the appropriate transform(s).
	 *
	 * db_region_mat returns a matrix which maps points on/in the region
	 * as it exists where the region is defined (as opposed to the 
	 * (possibly transformed) one we are rendering.
	 *
	 *  Non-PARALLEL, which is OK, because shaders are prepped serially.
	 */
	db_region_mat(prj_sp->prj_m_to_sh, rtip->rti_dbip, rp->reg_name, &rt_uniresource);


	if (rdebug&RDEBUG_SHADE) {

		prj_print(rp, (char *)prj_sp );
	}

	return(1);
}

/*
 *	P R J _ P R I N T
 */
HIDDEN void
prj_print(register struct region *rp, char *dp)
{
	struct prj_specific *prj_sp = (struct prj_specific *)dp;
	struct img_specific *img_sp;

	for (BU_LIST_FOR(img_sp, img_specific, &prj_sp->prj_images.l)) {
		bu_struct_print( rp->reg_name, img_print_tab, (char *)img_sp );
	}
}

/*
 *	P R J _ F R E E
 */
HIDDEN void
prj_free(char *cp)
{
	struct prj_specific *prj_sp = (struct prj_specific *)cp;

	struct img_specific *img_sp;

	while (BU_LIST_WHILE(img_sp, img_specific, &prj_sp->prj_images.l)) {

		img_sp->i_img = (unsigned char *)0;
		if (img_sp->i_data) bu_close_mapped_file( img_sp->i_data );
		img_sp->i_data = GENPTR_NULL; /* sanity */
		if (img_sp->i_binunifp) rt_binunif_free( img_sp->i_binunifp );
		img_sp->i_binunifp = GENPTR_NULL; /* sanity */
		bu_vls_vlsfree(&img_sp->i_name);

		BU_LIST_DEQUEUE( &img_sp->l );
		bu_free( (char *)img_sp, "img_specific");
	}

	if ( prj_sp->prj_plfd ) {
		bu_semaphore_acquire( BU_SEM_SYSCALL );
		fclose( prj_sp->prj_plfd );
		bu_semaphore_release( BU_SEM_SYSCALL );
	}

	bu_free( cp, "prj_specific" );
}
HIDDEN const double	cs = (1.0/255.0);
HIDDEN const point_t delta = {0.5, 0.5, 0.0};

#if 0
HIDDEN int
project_antialiased(sh_color, img_sp, prj_sp, ap, r_pe, r_N, r_pt)
point_t sh_color;
const struct img_specific *img_sp;
const struct prj_specific *prj_sp;
const struct application *ap;
const struct pixel_ext *r_pe;	/* pts on plane of hit */
const plane_t r_N;
const point_t r_pt;
{
	int i, x, y;
	point_t sh_pts[CORNER_PTS];
	struct pixel_ext	pe;

	/* project hit plane corner points into image space */
	for (i=0 ; i < CORNER_PTS ; i++) {
		MAT4X3PNT(sh_pts[i], img_sp->i_sh_to_img, 
			pe.corner[i].r_pt);
		/* compute image coordinates */

		sh_pts[i][Z] = 0.0;
		VADD2(sh_pts[i], sh_pts[i], delta);


		sh_pts[i][X] *= img_sp->i_width - 1;
		sh_pts[i][Y] *= img_sp->i_height - 1;
		x = sh_pts[i][X];
		y = sh_pts[i][Y];
		sh_pts[i][X] = x;
		sh_pts[i][y] = y;
	}
	return 0;
}
#endif
HIDDEN int
project_point(point_t sh_color, struct img_specific *img_sp, struct prj_specific *prj_sp, point_t r_pt)
{
	int x, y;
	point_t sh_pt;
	point_t tmp_pt;
	unsigned char *pixel;

	MAT4X3PNT(sh_pt, img_sp->i_sh_to_img, r_pt);
	VADD2(sh_pt, sh_pt, delta);

	if (rdebug&RDEBUG_SHADE) {
		VPRINT("sh_pt", sh_pt);
	}
	x = sh_pt[X] * (img_sp->i_width-1);
	y = sh_pt[Y] * (img_sp->i_height-1);
	pixel = &img_sp->i_img[x*3 + y*img_sp->i_width*3];


	if (x >= img_sp->i_width || x < 0 ||
	    y >= img_sp->i_height || y < 0 ||
	    ((img_sp->i_behind == '0' && sh_pt[Z] > 0.0)) ) {
	    	/* we're out of bounds,
	    	 * leave the color alone
	    	 */
		return 1;
	}

	if (rdebug&RDEBUG_SHADE && prj_sp->prj_plfd) {
		/* plot projection direction */
		pl_color(prj_sp->prj_plfd, V3ARGS(pixel));
		pdv_3move(prj_sp->prj_plfd, r_pt);
		VMOVE(tmp_pt, r_pt);

		VSCALE(tmp_pt, img_sp->i_plane, -sh_pt[Z]);
		VADD2(tmp_pt, r_pt, tmp_pt);
		pdv_3cont(prj_sp->prj_plfd, tmp_pt);
	}
	VMOVE(sh_color, pixel);	/* int/float conversion */
	return 0;
}


/*
 *	P R J _ R E N D E R
 *
 *	This is called (from viewshade() in shade.c) once for each hit point
 *	to be shaded.  The purpose here is to fill in values in the shadework
 *	structure.
 */
int
prj_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
                  	    
                	    
                	     	/* defined in material.h */
    			    	/* ptr to the shader-specific struct */
{
	register struct prj_specific *prj_sp =
		(struct prj_specific *)dp;
	point_t r_pt;
	plane_t	r_N;
	int i, status;
	struct img_specific *img_sp;
	point_t	sh_color;
	point_t	final_color;
	point_t tmp_pt;
	fastf_t	divisor;
	struct pixel_ext r_pe;	/* region coord version of ap->a_pixelext */
	fastf_t dist;
	fastf_t weight;


	/* check the validity of the arguments we got */
	RT_AP_CHECK(ap);
	RT_CHECK_PT(pp);
	CK_prj_SP(prj_sp);

	if (rdebug&RDEBUG_SHADE) {
		bu_log("shading with prj\n");
		prj_print(pp->pt_regionp, dp);
	}
	/* If we are performing the shading in "region" space, we must 
	 * transform the hit point from "model" space to "region" space.
	 * See the call to db_region_mat in prj_setup().
	 */
	MAT4X3PNT(r_pt, prj_sp->prj_m_to_sh, swp->sw_hit.hit_point);
	MAT4X3VEC(r_N, prj_sp->prj_m_to_sh, swp->sw_hit.hit_normal);

	


	if (rdebug&RDEBUG_SHADE) {
		bu_log("prj_render()  model:(%g %g %g) shader:(%g %g %g)\n", 
		V3ARGS(swp->sw_hit.hit_point),
		V3ARGS(r_pt) );
	}


	VSET(final_color, 0.0, 0.0, 0.0);
	divisor = 0.0;

	if (ap->a_pixelext) {

		BU_CK_PIXEL_EXT(ap->a_pixelext);

		/* We need to compute the extent of the pixel on an
		 * imaginary plane through the hit point with the same
		 * normal as the surface normal at the hit point.  Later
		 * this quadrilateral will be projected onto the image
		 * plane(s) to facilitate anti-aliasing.
		 */

		/* compute region coordinates for pixel extent */
		for ( i=0 ; i < CORNER_PTS ; i++) {
			MAT4X3PNT(r_pe.corner[i].r_pt,
				prj_sp->prj_m_to_sh, 
				ap->a_pixelext->corner[i].r_pt);
			MAT4X3VEC(r_pe.corner[i].r_dir, 
				prj_sp->prj_m_to_sh, 
				ap->a_pixelext->corner[i].r_dir);
		}

		/* compute plane of hit point */
		VUNITIZE(r_N);
		r_N[H] = VDOT(r_N, r_pt);

		/* project corner points into plane of hit point */
		for (i=0 ; i < CORNER_PTS ; i++) {
			dist = 0.0;
			status = bn_isect_line3_plane(
				&dist,
				r_pe.corner[i].r_pt,
				r_pe.corner[i].r_dir,
				r_N,
				&(ap->a_rt_i->rti_tol));

			if (rdebug&RDEBUG_SHADE) {
			  /* status will be <= 0 when the image was not loaded */
			  if (status <= 0) {
			    /* XXX What to do if we don't
			     * hit plane?
			     */
			    bu_log("%s:%d The unthinkable has happened\n",
				   __FILE__, __LINE__);
			  }
			}

			VJOIN1(r_pe.corner[i].r_pt,
				r_pe.corner[i].r_pt,
				dist,
				r_pe.corner[i].r_dir);
		}
	}


	for (BU_LIST_FOR(img_sp, img_specific, &prj_sp->prj_images.l)) {
		if ( img_sp->i_through == '0' && VDOT(r_N, img_sp->i_plane) < 0.0) {
			/* normal and projection dir don't match, skip on */

			if (rdebug&RDEBUG_SHADE && prj_sp->prj_plfd) {
				/* plot hit normal */
				pl_color(prj_sp->prj_plfd, 255, 255, 255);
				pdv_3move(prj_sp->prj_plfd, r_pt);
				VADD2(tmp_pt, r_pt, r_N);
				pdv_3cont(prj_sp->prj_plfd, tmp_pt);

				/* plot projection direction */
				pl_color(prj_sp->prj_plfd, 255, 255, 0);
				pdv_3move(prj_sp->prj_plfd, r_pt);
				VADD2(tmp_pt, r_pt, img_sp->i_plane);
				pdv_3cont(prj_sp->prj_plfd, tmp_pt);
			}
			continue;
		}
		
#if 0
		if (img_sp->i_antialias == '1') {
			if (ap->a_pixelext)
				bu_bomb("pixel corners structure not set\n");

			if (project_antialiased(sh_color, img_sp, prj_sp, 
				ap, &r_pe, r_N, r_pt))
				continue;

		} else { 
			if (project_point(sh_color, img_sp, prj_sp, r_pt))
					continue;
		}
#else
		if (project_point(sh_color, img_sp, prj_sp, r_pt))
		  continue;
#endif
		VSCALE(sh_color, sh_color, cs);
		weight = VDOT( r_N, img_sp->i_plane );
		if (img_sp->i_through != '0' )
			weight = (weight < 0.0 ? -weight : weight );
		if (weight > 0.0 )
		{
			VJOIN1(final_color, final_color, weight, sh_color);
			divisor += weight;
		}
	}

	if (divisor > 0.0) {
		divisor = 1.0 / divisor;
		VSCALE(swp->sw_color, final_color, divisor);
	} 
	return 1;
}
@


1.44
log
@change conf.h to a wrapped config.h
@
text
@@


1.43
log
@merge of ansi-6-0-branch into HEAD
@
text
@d11 5
a15 1
#include "conf.h"
@


1.42
log
@fixed return type on structparse function
@
text
@d37 2
a38 2
	struct bu_list	l;
	unsigned long	junk;
d46 14
a59 14
	unsigned char 	*i_img;
	int		i_width;
	int		i_height;
	fastf_t		i_viewsize;
	point_t		i_eye_pt;
	quat_t		i_orient;
	mat_t		i_mat;		/* computed from i_orient */
	mat_t		i_bn_mat_inv;	/* computed (for debug) */
	plane_t		i_plane;	/* dir/plane of projection */
	mat_t		i_sh_to_img;	/* transform used in prj_render() */
	char		i_through;	/* ignore surface normal */
	char		i_antialias;	/* anti-alias texture */
	char		i_behind;	/* shade points behind img plane */
	fastf_t		i_perspective;	/* perspective angle 0=ortho */
d185 5
a189 5
persp_hook( sdp, name, base, value )
register const struct bu_structparse	*sdp;	/* structure description */
register const char			*name;	/* struct member name */
char					*base;	/* begining of structure */
const char				*value;	/* string containing value */
d213 5
a217 5
dimen_hook( sdp, name, base, value )
register const struct bu_structparse	*sdp;	/* structure description */
register const char			*name;	/* struct member name */
char					*base;	/* begining of structure */
const char				*value;	/* string containing value */
d264 6
a269 6
static void
orient_hook( sdp, name, base, value )
register const struct bu_structparse	*sdp;	/* structure description */
register const char			*name;	/* struct member name */
char					*base;	/* begining of structure */
const char				*value;	/* string containing value */
d402 2
a403 2
HIDDEN int	prj_setup(), prj_render();
HIDDEN void	prj_print(), prj_free();
d429 6
a434 6
prj_setup( rp, matparm, dpp, mfp, rtip)
register struct region	*rp;
struct bu_vls		*matparm;
char			**dpp;	/* pointer to reg_udata in *rp */
struct mfuncs		*mfp;
struct rt_i		*rtip;	/* New since 4.4 release */
d579 1
a579 3
prj_print( rp, dp )
register struct region *rp;
char	*dp;
d593 1
a593 2
prj_free( cp )
char *cp;
d659 1
a659 5
project_point(sh_color, img_sp, prj_sp, r_pt)
point_t sh_color;
struct img_specific *img_sp;
struct prj_specific *prj_sp;
point_t r_pt;
d709 5
a713 5
prj_render( ap, pp, swp, dp )
struct application	*ap;
struct partition	*pp;
struct shadework	*swp;	/* defined in material.h */
char			*dp;	/* ptr to the shader-specific struct */
@


1.41
log
@Added support to embed projection shader file details into the shader parameter string.  first the parameter is attempted as a file, as before.  if that fails, then it is treated as a parameter string.  actual data is parsed identically regardless of source.  this is a "really good thing" since it is one less external file that needs to be carried around with a database\!
@
text
@d264 1
a264 1
HIDDEN int
a367 2

	return 0;
@


1.40
log
@Added binary object support to the projection shader.  Now shader parameter for image data may either be a binunif database object or a file.  The default datasource is auto-determined, looking for binary object first and file second.  Otherwise either file or object may be explicitly requested.  Functionality is very similar to the texture shader.
@
text
@d258 3
a260 2
 * a new list element.  It also reads in the pixel data for the image, and
 * computes the matrix from the view quaternion.  
d440 3
a442 1
	char 				*fname;
d464 4
a467 4
		if ((prj_sp->prj_plfd=fopen("prj.pl", "w")) == (FILE *)NULL) {
			bu_log("ERROR creating plot file prj.pl");
		}
	} else
d469 1
d471 1
a471 4
	
	/* !!! need to handle a parse_tab for prj_specific so that the arg does not *have* to be just a file name. */
	/* perhaps, if only one arge, it's a filename. if more, load through parse table with options for all of the identifiers you might find (perhaps just img_parse_tab, still) */

a472 1
#if 0
d474 1
a474 1
		bu_log("------ Stack shader fixed?  Remove hack from prj shader ----\n");
d476 1
a476 1

d478 2
a479 2
	if (! *fname) {
	  bu_log("ERROR: Null projection shader file?\n");
d482 8
d491 10
a500 5
	parameter_file = bu_open_mapped_file( fname, (char *)NULL );
	if (! parameter_file) {
		bu_log( "ERROR: Projection shader can't find shaderfile (%s)\n", fname );
		return -1;
	}
d502 4
a505 3
	bu_vls_init(&parameter_data);
	bu_vls_strncpy( &parameter_data, (char *)parameter_file->buf,
		parameter_file->buflen );
d507 1
a507 2
	if (rdebug&RDEBUG_SHADE ) {
		bu_log("parsing: %s\n", bu_vls_addr(&parameter_data));
a509 2
	bu_close_mapped_file( parameter_file );

d523 6
a528 2
	    (char *)&prj_sp->prj_images) < 0)
		return -1;
a554 5

	


	bu_vls_free( &parameter_data );
@


1.39
log
@fixed projection shader setup so it returns error properly instead of bombing so raytraces will continue as expected; also updated statics to HIDDENs
@
text
@d30 3
d73 106
a276 1

a294 1

d363 2
a364 10
	/* read in the pixel data */
	img_new->i_data = bu_open_mapped_file(bu_vls_addr(&img_new->i_name),
				(char *)NULL);
	if ( ! img_new->i_data) {
	  return -1;
	  bu_log("WARNING: sh_prj.c: orient_hook() can't get pixel data...skipping\n");
	}

	img_new->i_img = (unsigned char *)img_new->i_data->buf;

d367 2
d381 3
d465 5
a469 2
		prj_sp->prj_plfd = (FILE *)NULL;

d504 6
d515 13
d597 4
a600 1
		bu_close_mapped_file( img_sp->i_data );
d793 9
a801 6
			if (status <= 0) {
				/* XXX What to do if we don't
				 * hit plane?
				 */
				bu_log("%s:%d The unthinkable has happened\n",
					__FILE__, __LINE__);
d846 2
a847 2
			if (project_point(sh_color, img_sp, prj_sp, r_pt))
					continue;
@


1.38
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d36 7
a42 2
	struct bu_vls	i_file;
	struct bu_mapped_file *i_data;
d75 1
a75 1
static void 
d103 1
a103 1
static void 
d131 1
a131 1
static void 
d144 1
a144 1
	BU_CK_VLS(&img_sp->i_file);
d154 1
a154 1
static void 
d177 1
a177 1
	BU_CK_VLS(&img_sp->i_file);
d181 1
a181 1
	bu_vls_init(&img_sp->i_file);
d257 1
a257 1
	img_new->i_data = bu_open_mapped_file(bu_vls_addr(&img_new->i_file),
d259 4
a262 2
	if ( ! img_new->i_data)
		bu_bomb("shader prj: orient_hook() can't get pixel data... bombing\n");
d279 1
a279 1
	{"%S",	1, "image",		IMG_O(i_file),		BU_STRUCTPARSE_FUNC_NULL},
d371 4
a374 2
	if (! *fname)
		bu_bomb("Null prj shaderfile?\n");
d378 2
a379 2
		bu_log( "prj_setup can't get shaderfile (%s)\n", fname );
		bu_bomb("prj_setup can't get shaderfile... bombing\n");
d472 1
a472 1
		bu_vls_vlsfree(&img_sp->i_file);
d486 2
a487 2
static const double	cs = (1.0/255.0);
static const point_t delta = {0.5, 0.5, 0.0};
d490 1
a490 1
static int
d524 1
a524 1
static int
@


1.38.4.1
log
@sync to HEAD...
@
text
@a29 3
/* not in a header, but provided by librt */
HIDDEN void rt_binunif_free();

d36 2
a37 7
  struct bu_vls i_name; /* name of object or file (depending on i_datasrc flag) */
#define IMG_SRC_FILE 'f'
#define IMG_SRC_OBJECT  'o'
#define IMG_SRC_AUTO 0
  char i_datasrc; /* is the datasource a file/object or automatic */
  struct bu_mapped_file *i_data; /* mapped file when IMG_SRC_FILE */
  struct rt_binunif_internal *i_binunifp;  /* db internal object when IMG_SRC_OBJECT */
a64 106

/*
 *  img_source_hook() is used to record where the image datasource is coming from
 *  so that the image may be loaded automatically as needed from either a file or
 *  from a database-embedded binary object.
 */
HIDDEN void img_source_hook(const struct bu_structparse *ip, const char *sp_name, genptr_t base, char *p) {
  struct img_specific *imageSpecific = (struct img_specific *)base;
  if (strncmp(sp_name, "file", 4) == 0) {
    imageSpecific->i_datasrc=IMG_SRC_FILE;
  } else if (strncmp(sp_name, "obj", 3) == 0) {
    imageSpecific->i_datasrc=IMG_SRC_OBJECT;
  } else {
    imageSpecific->i_datasrc=IMG_SRC_AUTO;
  }
}


/*
 *	i m g _ l o a d _ d a t a s o u r c e
 *
 * This is a helper routine used in prj_setup() to load a projection image
 * either from a file or from a db object.
 */
HIDDEN int img_load_datasource(struct img_specific *image, struct db_i *dbInstance, const unsigned long int size) {
	struct directory *dirEntry;

	RT_CK_DBI(dbInstance);

	if (image == (struct img_specific *)NULL) {
		bu_bomb("ERROR: img_load_datasource() received NULL arg (struct img_specific *)\n");
	}

	bu_log("Loading image %s [%S]...", image->i_datasrc==IMG_SRC_AUTO?"from auto-determined datasource":image->i_datasrc==IMG_SRC_OBJECT?"from a database object":image->i_datasrc==IMG_SRC_FILE?"from a file":"from an unknown source (ERROR)", &image->i_name);

	/* if the source is auto or object, we try to load the object */
	if ((image->i_datasrc==IMG_SRC_AUTO) || (image->i_datasrc==IMG_SRC_OBJECT)) {

		/* see if the object exists */
		if ( (dirEntry=db_lookup(dbInstance, bu_vls_addr(&image->i_name), LOOKUP_QUIET)) == DIR_NULL) {

			/* unable to find the image object */
			if (image->i_datasrc!=IMG_SRC_AUTO) {
				return -1;
			}
		}
		else {
			struct rt_db_internal *dbip=(struct rt_db_internal *)bu_malloc(sizeof(struct rt_db_internal), "img_load_datasource");

			RT_INIT_DB_INTERNAL(dbip);
			RT_CK_DB_INTERNAL(dbip);
			RT_CK_DIR(dirEntry);

			/* the object was in the directory, so go get it */
			if (rt_db_get_internal(dbip, dirEntry, dbInstance, NULL, NULL) <= 0) {
				/* unable to load/create the image database record object */
				return -1;
			}

			RT_CK_DB_INTERNAL(dbip);
			RT_CK_BINUNIF(dbip->idb_ptr);

			/* keep the binary object pointer */
			image->i_binunifp=(struct rt_binunif_internal *)dbip->idb_ptr; /* make it so */
			
			/* release the database struct we created */
			RT_INIT_DB_INTERNAL(dbip);
			bu_free(dbip, "img_load_datasource");

			/* check size of object */
			if (image->i_binunifp->count < size) {
				bu_log("\nWARNING: %S needs %d bytes, binary object only has %d\n", &image->i_name, size, image->i_binunifp->count);
			} else if (image->i_binunifp->count > size) {
				bu_log("\nWARNING: Binary object is larger than specified image size\n\tBinary Object: %d pixels\n\tSpecified Image Size: %d pixels\n...continuing to load using image subsection...", image->i_binunifp->count);
			}
			image->i_img = (unsigned char *) image->i_binunifp->u.uint8;

		}
	}

	/* if we are auto and we couldn't find a database object match, or if source
	 * is explicitly a file then we load the file.
	 */
	if ( ( (image->i_datasrc==IMG_SRC_AUTO) && (image->i_binunifp==NULL) ) || (image->i_datasrc==IMG_SRC_FILE) ) {


		image->i_data = bu_open_mapped_file_with_path(dbInstance->dbi_filepath,	bu_vls_addr(&image->i_name), NULL);
		
		if ( image->i_data==NULL )
			return -1;				/* FAIL */

		if (image->i_data->buflen < size) {
			bu_log("\nWARNING: %S needs %d bytes, file only has %d\n", &image->i_name, size, image->i_data->buflen);
		} else if (image->i_data->buflen > size) {
			bu_log("\nWARNING: Image file size is larger than specified image size\n\tInput File: %d pixels\n\tSpecified Image Size: %d pixels\n...continuing to load using image subsection...", image->i_data->buflen, size);
		}

		image->i_img = (unsigned char *) image->i_data->buf;		
	}

	bu_log("done.\n");

	return 0;
}


d70 1
a70 1
HIDDEN void 
d98 1
a98 1
HIDDEN void 
d126 1
a126 1
HIDDEN void 
d139 1
a139 1
	BU_CK_VLS(&img_sp->i_name);
d144 2
a145 3
 * a new list element.  It used to read in pixel data for an image (this is
 * now done in the prj_setup() routine), and computes the matrix from the view 
 * quaternion.  
d149 1
a149 1
static void
d163 1
d172 1
a172 1
	BU_CK_VLS(&img_sp->i_name);
d176 1
a176 1
	bu_vls_init(&img_sp->i_name);
d182 1
d251 8
a258 2
	/* read in the pixel data now happens in prj_setup() */
	/* we add an image to the list of images regardless of whether the data is valid or not */
d272 1
a272 4
	{"%S",	1, "image",		IMG_O(i_name),		BU_STRUCTPARSE_FUNC_NULL},
	{"%S",  1, "file",		IMG_O(i_name),		img_source_hook},
	{"%S",	1, "obj",		IMG_O(i_name),		img_source_hook},
	{"%S",	1, "object",		IMG_O(i_name),		img_source_hook},
d328 1
a328 3
#if 0
	char * fname;
#endif
d350 8
a357 7
	  if ((prj_sp->prj_plfd=fopen("prj.pl", "w")) == (FILE *)NULL) {
	    bu_log("ERROR creating plot file prj.pl");
	  }
	} else {
	  prj_sp->prj_plfd = (FILE *)NULL;
	}
	
a358 1
	fname = bu_vls_addr(matparm);
d360 1
a360 1
	  bu_log("------ Stack shader fixed?  Remove hack from prj shader ----\n");
d362 1
a362 1
	
d364 7
a370 3
	if (! *(bu_vls_addr(matparm))) {
	  bu_log("ERROR: Null projection shader file or options?\n");
	  return -1;
d372 1
a372 6
	
	/* first we try to open the specified argument as a file, as previously implemented.  
	 * if it succeeds, then the file contents become the parameter data.  Otherwise, the
	 * argument string considered the parameter data.
	 */
	
d374 2
a375 1
	parameter_file = bu_open_mapped_file( bu_vls_addr(matparm), (char *)NULL );
d377 3
a379 15
	if (parameter_file) {
	  /* the file loaded, so the contents become the parameter string */
	  bu_log("Filename: %s\n", bu_vls_addr(matparm));
	  
	  bu_vls_strncpy( &parameter_data, (char *)parameter_file->buf,
			  parameter_file->buflen );
	  
	  if (rdebug&RDEBUG_SHADE ) {
	    bu_log("parsing: %s\n", bu_vls_addr(&parameter_data));
	  }

	  bu_close_mapped_file( parameter_file );
	} else {
	  /* the file did not load, so the shader args become the param string */
	  bu_log("Parameters: %s\n", bu_vls_addr(matparm));
d381 1
a381 2
	  bu_vls_strncpy ( &parameter_data, bu_vls_addr(matparm), bu_vls_strlen(matparm) );
	}
a387 6
	prj_sp->prj_images.i_datasrc = IMG_SRC_AUTO;

	/* sanity */
	prj_sp->prj_images.i_data = GENPTR_NULL;
	prj_sp->prj_images.i_binunifp = GENPTR_NULL;
	prj_sp->prj_images.i_img = GENPTR_NULL;
d390 2
a391 19
			    (char *)&prj_sp->prj_images) < 0) {
	  bu_log("ERROR: Unable to properly parse projection shader parameters\n");
	  return -1;
	}

	bu_vls_free( &parameter_data );

        /* load the image data for any specified images */
        for (BU_LIST_FOR(img_sp, img_specific, &prj_sp->prj_images.l)) {
	  if (img_load_datasource(img_sp, rtip->rti_dbip, img_sp->i_width * img_sp->i_height * 3) < 0) {
	    bu_log("\nERROR: prj_setup() %s %s could not be loaded [source was %s]\n", rp->reg_name, bu_vls_addr(&img_sp->i_name), img_sp->i_datasrc==IMG_SRC_OBJECT?"object":img_sp->i_datasrc==IMG_SRC_FILE?"file":"auto");

	    /* skip this one */
	    img_sp->i_through=0;
	    HREVERSE(img_sp->i_plane,img_sp->i_plane);

	    return -1;
	  }
        }
d406 5
d462 2
a463 5
		if (img_sp->i_data) bu_close_mapped_file( img_sp->i_data );
		img_sp->i_data = GENPTR_NULL; /* sanity */
		if (img_sp->i_binunifp) rt_binunif_free( img_sp->i_binunifp );
		img_sp->i_binunifp = GENPTR_NULL; /* sanity */
		bu_vls_vlsfree(&img_sp->i_name);
d477 2
a478 2
HIDDEN const double	cs = (1.0/255.0);
HIDDEN const point_t delta = {0.5, 0.5, 0.0};
d481 1
a481 1
HIDDEN int
d515 1
a515 1
HIDDEN int
d655 6
a660 9
			if (rdebug&RDEBUG_SHADE) {
			  /* status will be <= 0 when the image was not loaded */
			  if (status <= 0) {
			    /* XXX What to do if we don't
			     * hit plane?
			     */
			    bu_log("%s:%d The unthinkable has happened\n",
				   __FILE__, __LINE__);
			  }
d705 2
a706 2
		if (project_point(sh_color, img_sp, prj_sp, r_pt))
		  continue;
@


1.38.2.1
log
@Initial ANSIfication
@
text
@d71 5
a75 5
persp_hook(register const struct bu_structparse *sdp, register const char *name, char *base, const char *value)
                                    	     	/* structure description */
                   			      	/* struct member name */
    					      	/* begining of structure */
          				       	/* string containing value */
d99 5
a103 5
dimen_hook(register const struct bu_structparse *sdp, register const char *name, char *base, const char *value)
                                    	     	/* structure description */
                   			      	/* struct member name */
    					      	/* begining of structure */
          				       	/* string containing value */
d150 5
a154 5
orient_hook(register const struct bu_structparse *sdp, register const char *name, char *base, const char *value)
                                    	     	/* structure description */
                   			      	/* struct member name */
    					      	/* begining of structure */
          				       	/* string containing value */
d292 2
a293 2
HIDDEN int	prj_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip), prj_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
HIDDEN void	prj_print(register struct region *rp, char *dp), prj_free(char *cp);
d319 6
a324 6
prj_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip)
                      	    
             		         
    			      	/* pointer to reg_udata in *rp */
             		     
           		      	/* New since 4.4 release */
d436 3
a438 1
prj_print(register struct region *rp, char *dp)
d452 2
a453 1
prj_free(char *cp)
d516 5
a520 1
project_point(fastf_t *sh_color, struct img_specific *img_sp, struct prj_specific *prj_sp, fastf_t *r_pt)
d570 5
a574 5
prj_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
                  	    
                	    
                	     	/* defined in material.h */
    			    	/* ptr to the shader-specific struct */
@


1.38.2.2
log
@sync branch with HEAD
@
text
@a29 3
/* not in a header, but provided by librt */
HIDDEN void rt_binunif_free();

d36 2
a37 7
  struct bu_vls i_name; /* name of object or file (depending on i_datasrc flag) */
#define IMG_SRC_FILE 'f'
#define IMG_SRC_OBJECT  'o'
#define IMG_SRC_AUTO 0
  char i_datasrc; /* is the datasource a file/object or automatic */
  struct bu_mapped_file *i_data; /* mapped file when IMG_SRC_FILE */
  struct rt_binunif_internal *i_binunifp;  /* db internal object when IMG_SRC_OBJECT */
a64 106

/*
 *  img_source_hook() is used to record where the image datasource is coming from
 *  so that the image may be loaded automatically as needed from either a file or
 *  from a database-embedded binary object.
 */
HIDDEN void img_source_hook(const struct bu_structparse *ip, const char *sp_name, genptr_t base, char *p) {
  struct img_specific *imageSpecific = (struct img_specific *)base;
  if (strncmp(sp_name, "file", 4) == 0) {
    imageSpecific->i_datasrc=IMG_SRC_FILE;
  } else if (strncmp(sp_name, "obj", 3) == 0) {
    imageSpecific->i_datasrc=IMG_SRC_OBJECT;
  } else {
    imageSpecific->i_datasrc=IMG_SRC_AUTO;
  }
}


/*
 *	i m g _ l o a d _ d a t a s o u r c e
 *
 * This is a helper routine used in prj_setup() to load a projection image
 * either from a file or from a db object.
 */
HIDDEN int img_load_datasource(struct img_specific *image, struct db_i *dbInstance, const unsigned long int size) {
	struct directory *dirEntry;

	RT_CK_DBI(dbInstance);

	if (image == (struct img_specific *)NULL) {
		bu_bomb("ERROR: img_load_datasource() received NULL arg (struct img_specific *)\n");
	}

	bu_log("Loading image %s [%S]...", image->i_datasrc==IMG_SRC_AUTO?"from auto-determined datasource":image->i_datasrc==IMG_SRC_OBJECT?"from a database object":image->i_datasrc==IMG_SRC_FILE?"from a file":"from an unknown source (ERROR)", &image->i_name);

	/* if the source is auto or object, we try to load the object */
	if ((image->i_datasrc==IMG_SRC_AUTO) || (image->i_datasrc==IMG_SRC_OBJECT)) {

		/* see if the object exists */
		if ( (dirEntry=db_lookup(dbInstance, bu_vls_addr(&image->i_name), LOOKUP_QUIET)) == DIR_NULL) {

			/* unable to find the image object */
			if (image->i_datasrc!=IMG_SRC_AUTO) {
				return -1;
			}
		}
		else {
			struct rt_db_internal *dbip=(struct rt_db_internal *)bu_malloc(sizeof(struct rt_db_internal), "img_load_datasource");

			RT_INIT_DB_INTERNAL(dbip);
			RT_CK_DB_INTERNAL(dbip);
			RT_CK_DIR(dirEntry);

			/* the object was in the directory, so go get it */
			if (rt_db_get_internal(dbip, dirEntry, dbInstance, NULL, NULL) <= 0) {
				/* unable to load/create the image database record object */
				return -1;
			}

			RT_CK_DB_INTERNAL(dbip);
			RT_CK_BINUNIF(dbip->idb_ptr);

			/* keep the binary object pointer */
			image->i_binunifp=(struct rt_binunif_internal *)dbip->idb_ptr; /* make it so */
			
			/* release the database struct we created */
			RT_INIT_DB_INTERNAL(dbip);
			bu_free(dbip, "img_load_datasource");

			/* check size of object */
			if (image->i_binunifp->count < size) {
				bu_log("\nWARNING: %S needs %d bytes, binary object only has %d\n", &image->i_name, size, image->i_binunifp->count);
			} else if (image->i_binunifp->count > size) {
				bu_log("\nWARNING: Binary object is larger than specified image size\n\tBinary Object: %d pixels\n\tSpecified Image Size: %d pixels\n...continuing to load using image subsection...", image->i_binunifp->count);
			}
			image->i_img = (unsigned char *) image->i_binunifp->u.uint8;

		}
	}

	/* if we are auto and we couldn't find a database object match, or if source
	 * is explicitly a file then we load the file.
	 */
	if ( ( (image->i_datasrc==IMG_SRC_AUTO) && (image->i_binunifp==NULL) ) || (image->i_datasrc==IMG_SRC_FILE) ) {


		image->i_data = bu_open_mapped_file_with_path(dbInstance->dbi_filepath,	bu_vls_addr(&image->i_name), NULL);
		
		if ( image->i_data==NULL )
			return -1;				/* FAIL */

		if (image->i_data->buflen < size) {
			bu_log("\nWARNING: %S needs %d bytes, file only has %d\n", &image->i_name, size, image->i_data->buflen);
		} else if (image->i_data->buflen > size) {
			bu_log("\nWARNING: Image file size is larger than specified image size\n\tInput File: %d pixels\n\tSpecified Image Size: %d pixels\n...continuing to load using image subsection...", image->i_data->buflen, size);
		}

		image->i_img = (unsigned char *) image->i_data->buf;		
	}

	bu_log("done.\n");

	return 0;
}


d126 1
a126 1
HIDDEN void 
d139 1
a139 1
	BU_CK_VLS(&img_sp->i_name);
d144 2
a145 3
 * a new list element.  It used to read in pixel data for an image (this is
 * now done in the prj_setup() routine), and computes the matrix from the view 
 * quaternion.  
d163 1
d172 1
a172 1
	BU_CK_VLS(&img_sp->i_name);
d176 1
a176 1
	bu_vls_init(&img_sp->i_name);
d182 1
a258 2
	/* read in the pixel data now happens in prj_setup() */
	/* we add an image to the list of images regardless of whether the data is valid or not */
d272 1
a272 4
	{"%S",	1, "image",		IMG_O(i_name),		BU_STRUCTPARSE_FUNC_NULL},
	{"%S",  1, "file",		IMG_O(i_name),		img_source_hook},
	{"%S",	1, "obj",		IMG_O(i_name),		img_source_hook},
	{"%S",	1, "object",		IMG_O(i_name),		img_source_hook},
d328 1
a328 3
#if 0
	char * fname;
#endif
d350 8
a357 7
	  if ((prj_sp->prj_plfd=fopen("prj.pl", "w")) == (FILE *)NULL) {
	    bu_log("ERROR creating plot file prj.pl");
	  }
	} else {
	  prj_sp->prj_plfd = (FILE *)NULL;
	}
	
a358 1
	fname = bu_vls_addr(matparm);
d360 1
a360 1
	  bu_log("------ Stack shader fixed?  Remove hack from prj shader ----\n");
d362 1
a362 1
	
d364 7
a370 3
	if (! *(bu_vls_addr(matparm))) {
	  bu_log("ERROR: Null projection shader file or options?\n");
	  return -1;
d372 1
a372 6
	
	/* first we try to open the specified argument as a file, as previously implemented.  
	 * if it succeeds, then the file contents become the parameter data.  Otherwise, the
	 * argument string considered the parameter data.
	 */
	
d374 2
a375 1
	parameter_file = bu_open_mapped_file( bu_vls_addr(matparm), (char *)NULL );
d377 3
a379 15
	if (parameter_file) {
	  /* the file loaded, so the contents become the parameter string */
	  bu_log("Filename: %s\n", bu_vls_addr(matparm));
	  
	  bu_vls_strncpy( &parameter_data, (char *)parameter_file->buf,
			  parameter_file->buflen );
	  
	  if (rdebug&RDEBUG_SHADE ) {
	    bu_log("parsing: %s\n", bu_vls_addr(&parameter_data));
	  }

	  bu_close_mapped_file( parameter_file );
	} else {
	  /* the file did not load, so the shader args become the param string */
	  bu_log("Parameters: %s\n", bu_vls_addr(matparm));
d381 1
a381 2
	  bu_vls_strncpy ( &parameter_data, bu_vls_addr(matparm), bu_vls_strlen(matparm) );
	}
a387 6
	prj_sp->prj_images.i_datasrc = IMG_SRC_AUTO;

	/* sanity */
	prj_sp->prj_images.i_data = GENPTR_NULL;
	prj_sp->prj_images.i_binunifp = GENPTR_NULL;
	prj_sp->prj_images.i_img = GENPTR_NULL;
d390 2
a391 19
			    (char *)&prj_sp->prj_images) < 0) {
	  bu_log("ERROR: Unable to properly parse projection shader parameters\n");
	  return -1;
	}

	bu_vls_free( &parameter_data );

        /* load the image data for any specified images */
        for (BU_LIST_FOR(img_sp, img_specific, &prj_sp->prj_images.l)) {
	  if (img_load_datasource(img_sp, rtip->rti_dbip, img_sp->i_width * img_sp->i_height * 3) < 0) {
	    bu_log("\nERROR: prj_setup() %s %s could not be loaded [source was %s]\n", rp->reg_name, bu_vls_addr(&img_sp->i_name), img_sp->i_datasrc==IMG_SRC_OBJECT?"object":img_sp->i_datasrc==IMG_SRC_FILE?"file":"auto");

	    /* skip this one */
	    img_sp->i_through=0;
	    HREVERSE(img_sp->i_plane,img_sp->i_plane);

	    return -1;
	  }
        }
d406 5
d459 2
a460 5
		if (img_sp->i_data) bu_close_mapped_file( img_sp->i_data );
		img_sp->i_data = GENPTR_NULL; /* sanity */
		if (img_sp->i_binunifp) rt_binunif_free( img_sp->i_binunifp );
		img_sp->i_binunifp = GENPTR_NULL; /* sanity */
		bu_vls_vlsfree(&img_sp->i_name);
d474 2
a475 2
HIDDEN const double	cs = (1.0/255.0);
HIDDEN const point_t delta = {0.5, 0.5, 0.0};
d478 1
a478 1
HIDDEN int
d513 1
a513 1
project_point(point_t *sh_color, struct img_specific *img_sp, struct prj_specific *prj_sp, point_t *r_pt)
d648 6
a653 9
			if (rdebug&RDEBUG_SHADE) {
			  /* status will be <= 0 when the image was not loaded */
			  if (status <= 0) {
			    /* XXX What to do if we don't
			     * hit plane?
			     */
			    bu_log("%s:%d The unthinkable has happened\n",
				   __FILE__, __LINE__);
			  }
d698 2
a699 2
		if (project_point(sh_color, img_sp, prj_sp, r_pt))
		  continue;
@


1.38.2.3
log
@fix cvs messup on join, ws, and remove moved section
@
text
@d37 2
a38 2
  struct bu_list	l;
  unsigned long	junk;
d46 14
a59 14
  unsigned char *i_img;
  int		i_width;
  int		i_height;
  fastf_t	i_viewsize;
  point_t	i_eye_pt;
  quat_t	i_orient;
  mat_t		i_mat;		/* computed from i_orient */
  mat_t		i_bn_mat_inv;	/* computed (for debug) */
  plane_t	i_plane;	/* dir/plane of projection */
  mat_t		i_sh_to_img;	/* transform used in prj_render() */
  char		i_through;	/* ignore surface normal */
  char		i_antialias;	/* anti-alias texture */
  char		i_behind;	/* shade points behind img plane */
  fastf_t	i_perspective;	/* perspective angle 0=ortho */
d364 8
d667 1
a667 1
project_point(point_t sh_color, struct img_specific *img_sp, struct prj_specific *prj_sp, point_t r_pt)
@


1.37
log
@Converted from K&R to ANSI C - RFH
@
text
@d71 5
a75 5
persp_hook(register const struct bu_structparse *sdp, register const char *name, char *base, const char *value)
                                    	     	/* structure description */
                   			      	/* struct member name */
    					      	/* begining of structure */
          				       	/* string containing value */
d99 5
a103 5
dimen_hook(register const struct bu_structparse *sdp, register const char *name, char *base, const char *value)
                                    	     	/* structure description */
                   			      	/* struct member name */
    					      	/* begining of structure */
          				       	/* string containing value */
d150 5
a154 5
orient_hook(register const struct bu_structparse *sdp, register const char *name, char *base, const char *value)
                                    	     	/* structure description */
                   			      	/* struct member name */
    					      	/* begining of structure */
          				       	/* string containing value */
d292 2
a293 2
HIDDEN int	prj_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip), prj_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
HIDDEN void	prj_print(register struct region *rp, char *dp), prj_free(char *cp);
d319 6
a324 6
prj_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip)
                      	    
             		         
    			      	/* pointer to reg_udata in *rp */
             		     
           		      	/* New since 4.4 release */
d436 3
a438 1
prj_print(register struct region *rp, char *dp)
d452 2
a453 1
prj_free(char *cp)
d516 5
a520 1
project_point(fastf_t *sh_color, struct img_specific *img_sp, struct prj_specific *prj_sp, fastf_t *r_pt)
d570 5
a574 5
prj_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
                  	    
                	    
                	     	/* defined in material.h */
    			    	/* ptr to the shader-specific struct */
@


1.36
log
@Added some info to an error message
@
text
@d71 5
a75 5
persp_hook( sdp, name, base, value )
register const struct bu_structparse	*sdp;	/* structure description */
register const char			*name;	/* struct member name */
char					*base;	/* begining of structure */
const char				*value;	/* string containing value */
d99 5
a103 5
dimen_hook( sdp, name, base, value )
register const struct bu_structparse	*sdp;	/* structure description */
register const char			*name;	/* struct member name */
char					*base;	/* begining of structure */
const char				*value;	/* string containing value */
d150 5
a154 5
orient_hook( sdp, name, base, value )
register const struct bu_structparse	*sdp;	/* structure description */
register const char			*name;	/* struct member name */
char					*base;	/* begining of structure */
const char				*value;	/* string containing value */
d292 2
a293 2
HIDDEN int	prj_setup(), prj_render();
HIDDEN void	prj_print(), prj_free();
d319 6
a324 6
prj_setup( rp, matparm, dpp, mfp, rtip)
register struct region	*rp;
struct bu_vls		*matparm;
char			**dpp;	/* pointer to reg_udata in *rp */
struct mfuncs		*mfp;
struct rt_i		*rtip;	/* New since 4.4 release */
d436 1
a436 3
prj_print( rp, dp )
register struct region *rp;
char	*dp;
d450 1
a450 2
prj_free( cp )
char *cp;
d513 1
a513 5
project_point(sh_color, img_sp, prj_sp, r_pt)
point_t sh_color;
struct img_specific *img_sp;
struct prj_specific *prj_sp;
point_t r_pt;
d563 5
a567 5
prj_render( ap, pp, swp, dp )
struct application	*ap;
struct partition	*pp;
struct shadework	*swp;	/* defined in material.h */
char			*dp;	/* ptr to the shader-specific struct */
@


1.35
log
@Mac OS X warning and error fixes for non-production build
@
text
@d368 2
a369 1
	if (! parameter_file)
d371 1
@


1.34
log
@CONST to const
@
text
@d312 1
a312 1
/*	P R J _ S E T U P
d430 1
a430 1
/*
d560 1
a560 1
/*
@


1.33
log
@Deprecated bn_mat_idn() and bn_mat_zero(), updated calls to h/vmath.h's MAT_IDN() and MAT_ZERO() performance improved macros.
@
text
@d72 2
a73 2
register CONST struct bu_structparse	*sdp;	/* structure description */
register CONST char			*name;	/* struct member name */
d75 1
a75 1
CONST char				*value;	/* string containing value */
d100 2
a101 2
register CONST struct bu_structparse	*sdp;	/* structure description */
register CONST char			*name;	/* struct member name */
d103 1
a103 1
CONST char				*value;	/* string containing value */
d128 2
a129 2
register CONST struct bu_structparse	*sdp;	/* structure description */
register CONST char			*name;	/* struct member name */
d131 1
a131 1
CONST char				*value;	/* string containing value */
d151 2
a152 2
register CONST struct bu_structparse	*sdp;	/* structure description */
register CONST char			*name;	/* struct member name */
d154 1
a154 1
CONST char				*value;	/* string containing value */
d475 2
a476 2
static CONST double	cs = (1.0/255.0);
static CONST point_t delta = {0.5, 0.5, 0.0};
d482 6
a487 6
CONST struct img_specific *img_sp;
CONST struct prj_specific *prj_sp;
CONST struct application *ap;
CONST struct pixel_ext *r_pe;	/* pts on plane of hit */
CONST plane_t r_N;
CONST point_t r_pt;
@


1.32
log
@Corrected handling of "char" fields (i_antialias, i_behind, and i_through),
and added default values for i_through and i_behind.
@
text
@d188 1
a188 1
	bn_mat_idn(trans);
d191 1
a191 1
	bn_mat_idn(scale);
@


1.31
log
@
Struct db_tree_state finally got a magic number. Added resource argument
to ft_describe(), db_region_mat(), db_shader_mat(),
db_init_db_tree_state(), and db_path_to_mat().
@
text
@d384 2
a385 1

d396 1
a396 1
		if (img_sp->i_antialias) {
d538 1
a538 1
	    ((!img_sp->i_behind && sh_pt[Z] > 0.0)) ) {
d670 1
a670 1
		if ( ! img_sp->i_through && VDOT(r_N, img_sp->i_plane) < 0.0) {
d708 1
a708 1
		if (img_sp->i_through )
@


1.30
log
@
expanded logging
@
text
@d415 2
d418 1
a418 1
	db_region_mat(prj_sp->prj_m_to_sh, rtip->rti_dbip, rp->reg_name);
@


1.29
log
@Eliminate compilation warnings, enhancements to sh_light.c
@
text
@d397 1
a397 1
				bu_log("setting prismtrace 1");
@


1.28
log
@Changes to use rtprivate.h instead of ../rt/rdebug.h
@
text
@d475 1
d509 1
a509 1

@


1.27
log
@Changes to support movement of CLAMP() macro into vmath.h
Altered "if( " statements to "if (" for readability.
@
text
@d27 2
a28 1
#include "../rt/rdebug.h"
@


1.27.2.1
log
@chars being treated as ints doesn't work (as in "if( !through)" )
@
text
@d394 1
a394 1
		if (img_sp->i_antialias != '0') {
d533 1
a533 1
	    ((img_sp->i_behind == '0' && sh_pt[Z] > 0.0)) ) {
d665 1
a665 1
		if ( img_sp->i_through == '0' && VDOT(r_N, img_sp->i_plane) < 0.0) {
d703 1
a703 1
		if (img_sp->i_through != '0' )
@


1.27.2.2
log
@Added defaults for "through" and "behind"
@
text
@a382 2
	prj_sp->prj_images.i_through = '0';
	prj_sp->prj_images.i_behind = '0';
@


1.26
log
@Eliminated some unused variables
@
text
@d206 1
a206 1
	if( rdebug&RDEBUG_SHADE) {
d336 1
a336 1
	if( rdebug&RDEBUG_SHADE)
d348 1
a348 1
	if( rdebug&RDEBUG_SHADE) {
d374 1
a374 1
	if( rdebug&RDEBUG_SHADE ) {
d395 1
a395 1
			if( rdebug&RDEBUG_SHADE)
d418 1
a418 1
	if( rdebug&RDEBUG_SHADE) {
d523 1
a523 1
	if( rdebug&RDEBUG_SHADE) {
d540 1
a540 1
	if( rdebug&RDEBUG_SHADE && prj_sp->prj_plfd) {
d589 1
a589 1
	if( rdebug&RDEBUG_SHADE) {
d603 1
a603 1
	if( rdebug&RDEBUG_SHADE) {
d668 1
a668 1
			if( rdebug&RDEBUG_SHADE && prj_sp->prj_plfd) {
d703 1
a703 1
		if( img_sp->i_through )
d705 1
a705 1
		if( weight > 0.0 )
@


1.25
log
@Moved mathtab/rand_half from rt into libbn
Expanded structparse to include description and default
@
text
@a157 4
	FILE			*fd;
	char			*img_file;
	unsigned		buf_size;
	size_t			n;
a160 1
	unsigned long		*ulp;
a486 1
	unsigned char *pixel[CORNER_PTS];
a501 1
		pixel[i] = &img_sp->i_img[x*3 + y*img_sp->i_width*3 ];
d573 1
a573 1
	int x, y, i, status;
@


1.24
log
@
Removed dependence on compat4.h
@
text
@a26 1
#include "../rt/mathtab.h"
@


1.23
log
@
compat4
@
text
@d277 1
a277 1
	{"%S",	1, "image",		IMG_O(i_file),		FUNC_NULL},
d281 1
a281 1
	{"%f",	3, "eye_pt",		IMG_AO(i_eye_pt),	FUNC_NULL},
d283 3
a285 3
	{"%c",	1, "through",		IMG_O(i_through),	FUNC_NULL},
	{"%c",	1, "antialias",		IMG_O(i_antialias),	FUNC_NULL},
	{"%c",	1, "behind",		IMG_O(i_behind),	FUNC_NULL},
d287 1
a287 1
	{"",	0, (char *)0,		0,			FUNC_NULL}
d291 2
a292 2
	{"%f",	4, "i_plane",		IMG_AO(i_plane),	FUNC_NULL},
	{"",	0, (char *)0,		0,			FUNC_NULL}
@


1.22
log
@Rendering with "through" non-zero uses absolute values of dot products for weights.
@
text
@d31 1
a31 1
#define CK_prj_SP(_p) RT_CKMAG(_p, prj_MAGIC, "prj_specific")
d45 1
a45 1
	mat_t		i_mat_inv;	/* computed (for debug) */
d175 1
a175 1
	GETSTRUCT(img_new, img_specific);
d199 2
a200 2
	mat_mul(tmp, img_new->i_mat, trans);
	mat_mul(img_new->i_sh_to_img, scale, tmp);
d206 2
a207 2
	mat_inv(img_new->i_mat_inv, img_new->i_mat);
	mat_inv(xform, img_new->i_sh_to_img);
d269 1
a269 1
#define IMG_AO(m)	offsetofarray(struct img_specific, m)
d290 1
a290 1
	{"i",	bu_byteoffset(img_parse_tab[0]), "img_parse_tab", 0, FUNC_NULL },
d326 1
a326 1
struct rt_vls		*matparm;
d339 1
a339 1
	RT_VLS_CHECK( matparm );
d343 1
a343 1
		rt_log("prj_setup(%s) matparm:\"%s\"\n",
d347 1
a347 1
	GETSTRUCT( prj_sp, prj_specific );
d612 1
a612 1
		rt_log("prj_render()  model:(%g %g %g) shader:(%g %g %g)\n", 
@


1.21
log
@Render nows weights according to image plane normal.
@
text
@d711 2
@


1.20
log
@Moved calculation of i_plane outside of debug block in orient_hook().
@
text
@d210 1
a215 1
		VUNITIZE(img_new->i_plane);
d589 1
a591 1

d710 6
a715 2
		VADD2(final_color, final_color, sh_color);
		divisor++;
@


1.19
log
@Giving up on implementing anti-aliased textures for now.  Should return
to this after Release 5.0 is made.
@
text
@d203 1
d205 6
a213 7
		VSET(v_tmp, 0.0, 0.0, 1.0);

		/* compute inverse */
		mat_inv(img_new->i_mat_inv, img_new->i_mat);
		mat_inv(xform, img_new->i_sh_to_img);

		MAT4X3VEC(img_new->i_plane, xform, v_tmp);
@


1.18
log
@Changes for prism tracing.
@
text
@d26 1
d51 1
d65 60
d271 1
d278 3
a280 3
	{"%d",	1, "w",			IMG_O(i_width),		FUNC_NULL},
	{"%d",	1, "n",			IMG_O(i_height),	FUNC_NULL},
	{"%f",	1, "viewsize",		IMG_O(i_viewsize),	FUNC_NULL},
d286 1
d363 1
a363 1
#if 1
d388 1
a388 1
	prj_sp->prj_images.i_antialias = 1;
d401 2
d408 1
d477 85
a578 1
	const static point_t delta = {0.5, 0.5, 0.0};
d581 1
a581 5
	point_t sh_pt;
	static CONST double	cs = (1.0/255.0);
	point_t	img_v;
	int x, y, i;
	unsigned char *pixel;
d587 3
d620 52
d692 3
a694 4
		if (img_sp->i_antialias) {
			point_t	img_pt[4];

			if (!ap->a_pixelext)
a695 1
			BU_CK_PIXEL_EXT(ap->a_pixelext);
d697 3
a699 9
			/* compute plane of hit point */
			VUNITIZE(r_N);
			r_N[H] = VDOT(r_N, r_pt);

			/* project corner points into hit plane */
			for (i=0 ; i < CORNER_PTS ; i++) {
				
			}
			/* project hit plane corner points into image plane */
d702 2
a703 35
			MAT4X3PNT(sh_pt, img_sp->i_sh_to_img, r_pt);
			VADD2(img_v, sh_pt, delta);
			if( rdebug&RDEBUG_SHADE) {
				VPRINT("sh_pt", sh_pt);
				VPRINT("img_v", img_v);
			}
			x = img_v[X] * (img_sp->i_width-1);
			y = img_v[Y] * (img_sp->i_height-1);
			pixel = &img_sp->i_img[x*3 + y*img_sp->i_width*3];


			if (x >= img_sp->i_width || x < 0 ||
			    y >= img_sp->i_height || y < 0 ||
			    ((!img_sp->i_behind && sh_pt[Z] > 0.0)) ) {
			    	/* we're out of bounds,
			    	 * leave the color alone
			    	 */
				continue;
			}


			if( rdebug&RDEBUG_SHADE && prj_sp->prj_plfd) {
				/* plot projection direction */
				pl_color(prj_sp->prj_plfd, V3ARGS(pixel));
				pdv_3move(prj_sp->prj_plfd, r_pt);
				VMOVE(tmp_pt, r_pt);

				VSCALE(tmp_pt, img_sp->i_plane, -sh_pt[Z]);
				VADD2(tmp_pt, r_pt, tmp_pt);
				pdv_3cont(prj_sp->prj_plfd, tmp_pt);
			}
			VMOVE(sh_color, pixel);	/* int/float conversion */
			VSCALE(sh_color, sh_color, cs);
			VADD2(final_color, final_color, sh_color);
			divisor++;
d705 7
@


1.17
log
@Added features so that only one version of the texture is pulled into memory.
Arbitrary numbers for projections, projection abort when surface point
is "behind" image plane.
@
text
@d47 3
a193 7







a214 1
	{"%S",	1, "end",		IMG_O(i_file),		FUNC_NULL},
d220 3
d267 2
a268 1
	register struct prj_specific	*prj_sp;
d322 5
d331 13
d429 1
a429 1
	vect_t	r_N;
d433 1
a433 1
	int x, y;
d471 1
a471 1
		if (VDOT(r_N, img_sp->i_plane) < 0.0) {
d490 37
a526 9
		MAT4X3PNT(sh_pt, img_sp->i_sh_to_img, r_pt);
		VADD2(img_v, sh_pt, delta);
		if( rdebug&RDEBUG_SHADE) {
			VPRINT("sh_pt", sh_pt);
			VPRINT("img_v", img_v);
		}
		x = img_v[X] * (img_sp->i_width-1);
		y = img_v[Y] * (img_sp->i_height-1);
		pixel = &img_sp->i_img[x*3 + y*img_sp->i_width*3];
a528 5
		if (x >= img_sp->i_width || x < 0 ||
		    y >= img_sp->i_height || y < 0 ||
		    sh_pt[Z] > 0.0) {
		    	/* for some reason we're out of bounds */
#if 0
d531 3
a533 2
				int colour[3];
				VSCALE(colour, swp->sw_color, 255.0);
a534 3
				pl_color(prj_sp->prj_plfd, V3ARGS(colour));

				pdv_3move(prj_sp->prj_plfd, r_pt);
d539 4
a542 2
#endif
			continue;
d544 1
a544 11

		if( rdebug&RDEBUG_SHADE && prj_sp->prj_plfd) {
			/* plot projection direction */
			pl_color(prj_sp->prj_plfd, V3ARGS(pixel));
			pdv_3move(prj_sp->prj_plfd, r_pt);
			VMOVE(tmp_pt, r_pt);

			VSCALE(tmp_pt, img_sp->i_plane, -sh_pt[Z]);
			VADD2(tmp_pt, r_pt, tmp_pt);
			pdv_3cont(prj_sp->prj_plfd, tmp_pt);
		}
a545 5
		VMOVE(sh_color, pixel);	/* int/float conversion */
		VSCALE(sh_color, sh_color, cs);
		VADD2(final_color, final_color, sh_color);
		divisor++;
	}
@


1.16
log
@Bogus checkin fix
@
text
@d21 1
d29 1
a29 1
#define prj_MAGIC 0x1834    /* make this a unique number for each shader */
d32 17
a48 1

d55 4
a58 15
	long	magic;	/* magic # for memory validity check, must come 1st */
	struct bu_vls	*prj_img_filename;
	unsigned char	*prj_image;
	int		prj_img_width;
	int		prj_img_height;
	fastf_t		prj_viewsize;
	point_t		prj_eye;
	mat_t		prj_sh_to_v;
	mat_t		prj_m;
	mat_t		prj_m_inv;
	vect_t		prj_dir;	/* direction of projection */
	point_t		prj_min;	/* bounding box min */
	point_t		prj_max;	/* bounding box max */
	mat_t		prj_m_to_sh;	/* region space xform */
	FILE 		*prj_plfd;
d60 9
d70 1
a70 35
/* The default values for the variables in the shader specific structure */
CONST static
struct prj_specific prj_defaults = {
	prj_MAGIC,
	(struct bu_vls *)0,
	(unsigned char *)0,
	512,
	512,
	1.0,
	{ 1.0, 1.0, 1.0 },		/* prj_eye */
	{	0.0, 0.0, 0.0, 0.0,	/* prj_sh_to_v */
		0.0, 0.0, 0.0, 0.0,
		0.0, 0.0, 0.0, 0.0,
		0.0, 0.0, 0.0, 0.0 },
	{	0.0, 0.0, 0.0, 0.0,	/* prj_m */
		0.0, 0.0, 0.0, 0.0,
		0.0, 0.0, 0.0, 0.0,
		0.0, 0.0, 0.0, 0.0 },
	{	0.0, 0.0, 0.0, 0.0,	/* prj_m_inv */
		0.0, 0.0, 0.0, 0.0,
		0.0, 0.0, 0.0, 0.0,
		0.0, 0.0, 0.0, 0.0 },
	{ 0.0, 0.0, 0.0 },		/* prj_dir */
	{ 0.0, 0.0, 0.0 },		/* prj_min */
	{ 0.0, 0.0, 0.0 },		/* prj_max */
	{	0.0, 0.0, 0.0, 0.0,	/* prj_m_to_sh */
		0.0, 0.0, 0.0, 0.0,
		0.0, 0.0, 0.0, 0.0,
		0.0, 0.0, 0.0, 0.0 },
	(FILE *)0			/* prj_plfd */
	};

#define SHDR_NULL	((struct prj_specific *)0)
#define SHDR_O(m)	offsetof(struct prj_specific, m)
#define SHDR_AO(m)	offsetofarray(struct prj_specific, m)
d72 1
d74 9
a82 3
/* description of how to parse/print the arguments to the shader
 * There is at least one line here for each variable in the shader specific
 * structure above
d84 29
a112 12
struct bu_structparse prj_print_tab[] = {
	{"%d",  1, "img_width",		SHDR_O(prj_img_width),	FUNC_NULL },
	{"%d",  1, "img_height",	SHDR_O(prj_img_height),	FUNC_NULL },
	{"%f",  1, "view_size",		SHDR_O(prj_viewsize),	FUNC_NULL },
	{"%f",  3, "view_eye",		SHDR_AO(prj_eye),	FUNC_NULL },
	{"%f",  3, "view_dir",		SHDR_AO(prj_dir),	FUNC_NULL },
	{"%f",  16,"view_sh_to_v",	SHDR_AO(prj_sh_to_v),	FUNC_NULL },
	{"%f",  16,"view_m",		SHDR_AO(prj_m),	FUNC_NULL },
	{"%f",  3, "shader_max",	SHDR_AO(prj_min),	FUNC_NULL },
	{"%f",  3, "shader_min",	SHDR_AO(prj_max),	FUNC_NULL },
	{"%f",  16,"shader_mat",	SHDR_AO(prj_m_to_sh),	FUNC_NULL },
	{"",	0, (char *)0,		0,			FUNC_NULL }
d114 16
a129 11
};
struct bu_structparse prj_parse_tab[] = {
	{"i",	bu_byteoffset(prj_print_tab[0]), "prj_print_tab", 0, FUNC_NULL },
	{"%d",  1, "w",			SHDR_O(prj_img_width),	FUNC_NULL },
	{"%d",  1, "n",			SHDR_O(prj_img_height),	FUNC_NULL },
	{"%f",  1, "vs",		SHDR_O(prj_viewsize),	FUNC_NULL },
	{"%f",  3, "ve",		SHDR_AO(prj_eye),	FUNC_NULL },
	{"%f",  16, "vm",		SHDR_AO(prj_sh_to_v),	FUNC_NULL },
	{"%f",  16, "sm",		SHDR_AO(prj_m_to_sh),	FUNC_NULL },
	{"",	0, (char *)0,		0,			FUNC_NULL }
};
d131 2
a132 2
HIDDEN int	prj_setup(), prj_render();
HIDDEN void	prj_print(), prj_free();
d134 2
a135 11
/* The "mfuncs" structure defines the external interface to the shader.
 * Note that more than one shader "name" can be associated with a given
 * shader by defining more than one mfuncs struct in this array.
 * See sh_phong.c for an example of building more than one shader "name"
 * from a set of source functions.  There you will find that "glass" "mirror"
 * and "plastic" are all names for the same shader with different default
 * values for the parameters.
 */
struct mfuncs prj_mfuncs[] = {
	{MF_MAGIC,	"prj",		0,		MFI_NORMAL|MFI_HIT|MFI_UV,	0,
	prj_setup,	prj_render,	prj_print,	prj_free },
a136 3
	{0,		(char *)0,	0,		0,		0,
	0,		0,		0,		0 }
};
a137 21
static void
mp(s, m)
char *s;
mat_t m;
{
	int i;
	fprintf(stderr, "Matrix %s:\n", s);
	fprintf(stderr, "%lg %lg %lg %lg\n", m[0], m[1], m[2], m[3]);
	fprintf(stderr, "%lg %lg %lg %lg\n", m[4], m[5], m[6], m[7]);
	fprintf(stderr, "%lg %lg %lg %lg\n", m[8], m[9], m[10], m[11]);
	fprintf(stderr, "%lg %lg %lg %lg\n", m[12], m[13], m[14], m[15]);
}
static int
get_actual_parameters(prj_sp, matparm)
struct prj_specific *prj_sp;
struct rt_vls		*matparm;
{
	FILE *fd;
	char *fname = "prj.txt";
	char *img_file = "../pix/m35.pix";
	int i, n;
a138 1
	
d140 17
a156 2
		bu_log("debug matparm:%s\n", bu_vls_addr(matparm));
	}
d158 2
d161 2
a162 1
	bu_log("setting image file %s\n", img_file);
d164 3
d168 3
a170 1
	prj_sp->prj_img_filename = bu_vls_vlsinit();
d172 3
a174 2
	bu_vls_strcpy(prj_sp->prj_img_filename, img_file);
	bu_log("set image file %s\n", bu_vls_addr(prj_sp->prj_img_filename));
d176 3
d180 1
a180 7
	bu_semaphore_acquire( BU_SEM_SYSCALL );
	if ((fd=fopen(fname, "r")) == NULL) {
		fprintf(stderr, "Error opening parameter file \"%s\": %s\n",
			fname, strerror(errno));
		bu_semaphore_release( BU_SEM_SYSCALL );
		return(-1);
	}
d182 6
a187 11
	if (fscanf(fd, "%lg", &prj_sp->prj_viewsize) != 1) {
		fprintf(stderr, "error scanning viewsize\n");
		bu_semaphore_release( BU_SEM_SYSCALL );
		bu_bomb("prj shader error");
	}
	if (fscanf(fd, "%lg %lg %lg", &prj_sp->prj_eye[0], 
		&prj_sp->prj_eye[1], &prj_sp->prj_eye[2]) != 3) {
		fprintf(stderr, "error scanning eye point\n");
		bu_semaphore_release( BU_SEM_SYSCALL );
		bu_bomb("prj shader error");
	}
a188 6
	for (i=0 ; i < ELEMENTS_PER_MAT ; i++) {
		if (fscanf(fd, "%lg", &prj_sp->prj_m[i]) != 1) {
			fprintf(stderr, "error scanning matrix element %d\n", i);
			bu_semaphore_release( BU_SEM_SYSCALL );
			bu_bomb("prj shader error");
		}
a190 1
	fclose(fd);
a191 13
	fprintf(stderr, "opening %dx%dimage file %s\n",
		prj_sp->prj_img_width,
		prj_sp->prj_img_height,
		bu_vls_addr(prj_sp->prj_img_filename));

	if ( (fd=fopen(bu_vls_addr(prj_sp->prj_img_filename), "r")) == NULL) {
		fprintf(stderr, "Error opening image file \"%s\": %s\n",
			fname, strerror(errno));
		bu_semaphore_release( BU_SEM_SYSCALL );
		return(-1);
	}
	
	n = prj_sp->prj_img_width * prj_sp->prj_img_height;
a192 17
	bu_semaphore_release( BU_SEM_SYSCALL );
	prj_sp->prj_image = (unsigned char *)bu_malloc(n * 3, "prj image");
	bu_semaphore_acquire( BU_SEM_SYSCALL );

	fprintf(stderr, "reading %dx%dimage file %s\n",
		prj_sp->prj_img_width,
		prj_sp->prj_img_height,
		bu_vls_addr(prj_sp->prj_img_filename));

	i = fread(prj_sp->prj_image, 3, n, fd);

	if (i != n) {
		fprintf(stderr, "Error reading %dx%d image file\n\t(got %d pixels, not %d)\n",
			 prj_sp->prj_img_width, prj_sp->prj_img_height, i, n);
		bu_semaphore_release( BU_SEM_SYSCALL );
		return(-1);
	}
a193 1
	fclose(fd);
a195 9
	if( rdebug&RDEBUG_SHADE) {
		prj_sp->prj_plfd = fopen("prj.pl", "w");
		if ( ! prj_sp->prj_plfd ) {
			fprintf(stderr, "Error opening plot file \"%s\": %s\n",
				"prj.pl", strerror(errno));
			bu_semaphore_release( BU_SEM_SYSCALL );
			return(-1);
		}
	}
d198 5
a202 1
	bu_semaphore_release( BU_SEM_SYSCALL );
d204 1
d206 2
a207 1
	return 0;
d210 45
d270 3
a272 5
	mat_t	trans, rot, scale, tmp;
	vect_t	bb_min, bb_max, v_tmp;
	struct stat sb;
	int i;
	struct bu_vls	param_buf;
d280 2
a281 1
		rt_log("prj_setup(%s)\n", rp->reg_name);
d287 25
a311 2
	/* initialize the default values for the shader */
	memcpy(prj_sp, &prj_defaults, sizeof(struct prj_specific) );
d313 3
a315 1
	if (get_actual_parameters(prj_sp, matparm)) return -1;
d317 9
d327 2
d340 1
a340 13
	/* compute a direction vector indicating the direction toward
	 * the plane of projection.
	 */
	VSET(v_tmp, 0.0, 0.0, 1.0);
	mat_inv(prj_sp->prj_m_inv, prj_sp->prj_m);	
	MAT4X3VEC(prj_sp->prj_dir, prj_sp->prj_m_inv, v_tmp);


	/* compute matrix to transform shader coordinates into projection 
	 * coordinates
	 */
	bn_mat_idn(trans);
	MAT_DELTAS_VEC_NEG(trans, prj_sp->prj_eye);
d342 1
a342 10
	bn_mat_idn(scale);
	MAT_SCALE_ALL(scale, prj_sp->prj_viewsize);

	mat_mul(tmp, prj_sp->prj_m, trans);
	mat_mul(prj_sp->prj_sh_to_v, scale, tmp);


	if( rdebug&RDEBUG_SHADE) {
		bu_struct_print( " Parameters:", prj_print_tab, (char *)prj_sp );
		mat_print( "m_to_sh", prj_sp->prj_m_to_sh );
d356 6
a361 1
	bu_struct_print( rp->reg_name, prj_print_tab, (char *)dp );
d373 12
d391 1
a391 1
	rt_free( cp, "prj_specific" );
d410 1
a412 1
	point_t	dir_pt;	/* for plotting prj_dir */
d414 1
a414 7
	vect_t	sh_N;
	vect_t	sh_color;
	static const double	cs = (1.0/255.0);
	char buf[32];
	static int fileno = 0;
	FILE *fd;
	mat_t	trans_o, trans_p, rot, scale, tmp, xform;
a415 1
	const static point_t delta = {0.5, 0.5, 0.0};
d418 5
d424 1
d430 4
a433 3
	if( rdebug&RDEBUG_SHADE)
		bu_struct_print( "prj_render Parameters:", prj_print_tab, (char *)prj_sp );

d451 20
a470 21
	/* If the normal is not even vaguely in the direction of the 
	 * projection plane, do nothing.
	 */
	if (VDOT(r_N, prj_sp->prj_dir) < 0.0) {
		if( rdebug&RDEBUG_SHADE)
			bu_log("vectors oppose, shader abort\n");
		VSET(swp->sw_color, 1.0, 1.0, 0.0);


		if (prj_sp->prj_plfd) {
			/* plot hit normal */
			pl_color(prj_sp->prj_plfd, 255, 255, 255);
			pdv_3move(prj_sp->prj_plfd, r_pt);
			VADD2(dir_pt, r_pt, r_N);
			pdv_3cont(prj_sp->prj_plfd, dir_pt);

			/* plot projection direction */
			pl_color(prj_sp->prj_plfd, 255, 255, 0);
			pdv_3move(prj_sp->prj_plfd, r_pt);
			VADD2(dir_pt, r_pt, prj_sp->prj_dir);
			pdv_3cont(prj_sp->prj_plfd, dir_pt);
a471 22
		return 1;
	}

	MAT4X3PNT(sh_pt, prj_sp->prj_sh_to_v, r_pt);

	if( rdebug&RDEBUG_SHADE) {
		VPRINT("sh_pt", sh_pt);
	}

	VADD2(img_v, sh_pt, delta);

	x = img_v[X] * (prj_sp->prj_img_width-1);
	y = img_v[Y] * (prj_sp->prj_img_height-1);

	pixel = &prj_sp->prj_image[x*3 + y*prj_sp->prj_img_width*3];

	if (x >= prj_sp->prj_img_width || x < 0) {
		VSET(swp->sw_color, 1.0, .0, .0);

		if( rdebug&RDEBUG_SHADE)
			bu_log("x coord test failed 0 > %d <= %u, shader abort\n",
				x, prj_sp->prj_img_width);
d473 30
a502 6
		if (prj_sp->prj_plfd) {
			/* plot projection direction */
			pl_color(prj_sp->prj_plfd, 255, 0, 0);
			pdv_3move(prj_sp->prj_plfd, r_pt);
			VADD2(dir_pt, r_pt, prj_sp->prj_dir);
			pdv_3cont(prj_sp->prj_plfd, dir_pt);
a503 7
		return 1;
	}
	if (y >= prj_sp->prj_img_height || y < 0) {
		VSET(swp->sw_color, 1.0, 0.0, 1.0);
		if( rdebug&RDEBUG_SHADE)
			bu_log("y coord test failed 0 > %d <= %u, shader abort\n",
				y, prj_sp->prj_img_height);
d505 1
a505 1
		if (prj_sp->prj_plfd) {
d507 1
a507 1
			pl_color(prj_sp->prj_plfd, 255, 0, 255);
d509 5
a513 2
			VADD2(dir_pt, r_pt, prj_sp->prj_dir);
			pdv_3cont(prj_sp->prj_plfd, dir_pt);
a514 15
		return 1;
	}


	if( rdebug&RDEBUG_SHADE) {
		bu_log("pixel (%g,%g) %d,%d  (%u %u %u)\n",
			 img_v[X], img_v[Y], x, y, 
			 (unsigned)pixel[0],
			 (unsigned)pixel[1],
			 (unsigned)pixel[2]);

	}

	VMOVE(sh_color, pixel);	/* int/float conversion */
	VSCALE(swp->sw_color, sh_color, cs);
d516 9
@


1.15
log
@Total revamp.  Currently handles 1 image
@
text
@d31 1
a31 11
struct image {
	bu_list	l;
	struct bu_vls	i_filename;
	unsigned char	*i_image;
	unsigned	i_width;
	unsigned	i_height;
	fastf_t		i_viewsize;
	point_t		i_eye;
	quat_t		i_orient;
	mat_t		i_m;
}
@


1.14
log
@Moved optical shaders from rt/ to liboptical/
The only modifications involved moving and splitting
rt/material.h into h/shadefuncs.h and h/shadework.h,
and in changing the calling sequence to mlib_setup() in rt/material.c

Now the only shader function called directly by RT is
in liboptical/init.c: optical_shader_init().
It adds all the individual shaders to the "mfuncs" shader list.
@
text
@d2 1
a2 1
 *  S H _ P R J . C
d4 1
a4 1
 *  Projection shader
d6 3
a8 4
 *  Usage:
 *	shader prj file="foo.pix" w=256 n=512 N=x/y/z/w \
 *		   file="foo.pix" w=256 n=512 N=x/y/z/w \
 *		   file="foo.pix" w=256 n=512 N=x/y/z/w
a9 19
 *	For each image the "file" directive must come first.  This signals
 *	the shader to produce a new image structure.  All other options
 *	following "file" apply to that image until the next "file" directive.
 *
 *  Author -
 *	Lee A. Butler
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" license agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1998 by the United States Army
 *	in all countries except the USA.  All rights reserved.
a10 4
#ifndef lint
static char RCSid[] = "@@(#)$Header$ (ARL)";
#endif

d14 3
d28 1
a28 1
#define prj_MAGIC 0x1998    /* make this a unique number for each shader */
d31 8
a38 12
#define NAME_LEN	128
#define IMAGE_MAGIC 0x1a
struct prj_image {
	struct bu_list	l;
	struct bu_mapped_file	*i_mp;		/* image data */
	unsigned 	i_width;		/* image description */
	unsigned 	i_height;
	unsigned 	i_depth;

	double		i_persp;		/* projection description */
	double		i_viewsize;
	point_t		i_eyept;
d40 2
a42 8
#if 0
	plane_t		i_plane;		/* computed */
#endif
	mat_t		i_mat;			/* view rot/scale matrix */
	char		i_fname[NAME_LEN];	/* file with the pixels */
	char		i_cfile[NAME_LEN];	/* where we got all this */
};

d48 15
a62 5
	long		magic;	/* for memory validity check, must come 1st */
	char		prj_name[NAME_LEN];/* temp variable for filenames */
	mat_t		prj_m_to_sh;	/* model to shader space matrix */
	unsigned	prj_count;	/* Number of images in list prj_img */
	struct bu_list	prj_img;	/* list of images to map on object */
d65 31
a96 4

/* description of how to parse/print the arguments to the shader.  Not much
 * here as it is all done in the image-specific parsing 
 */
d100 1
a100 6
static void image_hook();
struct bu_structparse prj_parse_tab[] = {
	{"%s",	NAME_LEN, "pfile", SHDR_AO(prj_name), image_hook },
	{"%s",	NAME_LEN, "p",	   SHDR_AO(prj_name), image_hook },
	{"",	0, (char *)0,	0,		      FUNC_NULL  }
};
d102 16
a118 13
#define IMG_NULL	((struct prj_image *)0)
#define IMG_O(m)	offsetof(struct prj_image, m)
#define IMG_AO(m)	offsetofarray(struct prj_image, m)
struct bu_structparse image_print_tab[] = {
	{"%s",	NAME_LEN,"file",IMG_AO(i_fname),	FUNC_NULL },
	{"%d",  1, "depth",	IMG_O(i_depth),		FUNC_NULL },
	{"%d",  1, "width",	IMG_O(i_width),		FUNC_NULL },
	{"%d",  1, "numscan",	IMG_O(i_height),	FUNC_NULL },
	{"%d",	1, "perpective",IMG_O(i_persp),		FUNC_NULL },
	{"%d",	1, "viewsize",	IMG_O(i_viewsize),	FUNC_NULL },
	{"%d",	3, "orientation",IMG_AO(i_orient),	FUNC_NULL },
	{"%d",	3, "eye_pt",	IMG_AO(i_eyept),	FUNC_NULL },
	{"",	0, (char *)0,	0,			FUNC_NULL }
d120 9
a128 12

struct bu_structparse image_parse_tab[] = {
	{"i",bu_byteoffset(image_print_tab[0]), "image_print_tab", 0, FUNC_NULL },
	{"%s",	NAME_LEN,"f",	IMG_AO(i_fname),	FUNC_NULL },
	{"%d",  1,	 "d",	IMG_O(i_depth),		FUNC_NULL },
	{"%d",  1,	 "w",	IMG_O(i_width),		FUNC_NULL },
	{"%d",  1,	 "n",	IMG_O(i_height),	FUNC_NULL },
	{"%d",	1,	 "p",	IMG_O(i_persp),		FUNC_NULL },
	{"%d",	1,	 "v",	IMG_O(i_viewsize),	FUNC_NULL },
	{"%d",	3,	 "o",	IMG_AO(i_orient),	FUNC_NULL },
	{"%d",	3, 	 "e",	IMG_AO(i_eyept),	FUNC_NULL },
	{"",	0, (char *)0,	0,			FUNC_NULL }
a130 84
/*
 * Process a parameter file describing an image and how it is projected onto
 * the object.
 *
 */
static void
image_hook(sdp, name, base, value)
struct bu_structparse			*sdp;	/* structure description */
register CONST char			*name;	/* struct member name */
char					*base;	/* begining of structure */
CONST char				*value;	/* string containing value */
{
	struct prj_specific *prj_sp = (struct prj_specific *)sdp;
	struct prj_image *img;
	FILE *fd;
	int i;
	struct stat s;
	struct bu_vls img_params;

	i = stat(prj_sp->prj_name, &s);
	if ((fd=fopen(prj_sp->prj_name, "r")) == (FILE *)NULL) {
		return;
	}

	/* read in the parameters */
	bu_vls_init(&img_params);
	bu_vls_extend(&img_params, i);
	fread(bu_vls_addr(&img_params), 1, i, fd);
	(void)fclose(fd);

	/* set default values */
	BU_GETSTRUCT(img, prj_image);
	strncpy(img->i_cfile, prj_sp->prj_name, sizeof(img->i_cfile));
	img->i_width = img->i_height = 512;
	img->i_depth = 3;
	img->i_persp = 0.0;
	VSET(img->i_eyept, 0.0, 0.0, 1.0);
	QSET(img->i_orient, 0.0, 0.0, 0.0, 1.0 );
	img->i_viewsize = 1.0;

	/* parse specific values */
	i = bu_struct_parse( &img_params, image_parse_tab, (char *)img);
	bu_vls_free(&img_params);

	if (i < 0) {
		bu_log("Error parsing image parameter file %s\n",
			prj_sp->prj_name);
		bu_free(img, "prj_image");
		return;
	}

	/* map the pixel data */
	img->i_mp = bu_open_mapped_file(img->i_fname, NULL);
	if ( ! img->i_mp) {
		/* File couldn't be mapped */
		bu_log("Error mapping image file %s\n", img->i_fname);
		bu_free(img, "prj_image");
		return;
	}

	/* add to list */
	BU_LIST_APPEND(&prj_sp->prj_img, &(img->l));
	prj_sp->prj_count++;
}



/*	P R J _ P R I N T _ S P
 *
 *  Print prj_specific by printing each prj_image struct
 */
static void
prj_print_sp(prj_sp)
CONST struct prj_specific *prj_sp;
{
	struct prj_image *img;
	
	for(BU_LIST_FOR(img, prj_image, &(prj_sp->prj_img))) {
		bu_struct_print(img->i_cfile, image_print_tab, (char *)img);
		mat_print("mat", img->i_mat);
	}
}


d150 118
d284 1
a284 1
	mat_t	tmp;
d286 3
a294 1

d303 3
a305 5
	prj_sp->magic = prj_MAGIC;
	*prj_sp->prj_name = '\0';
	bn_mat_idn(prj_sp->prj_m_to_sh);
	prj_sp->prj_count = 0;
	BU_LIST_INIT(&prj_sp->prj_img);
d307 1
d311 4
d318 21
a338 3
	/* get the name of the parameter file(s) and parse them (via hook) */
	if( bu_struct_parse( matparm, prj_parse_tab, (char *)prj_sp ) < 0 )
		return(-1);
d340 3
a342 2
	if (! prj_sp->prj_count) {
		bu_bomb("No images specified for prj shader\n");
a344 3
	if( rdebug&RDEBUG_SHADE)
		prj_print_sp(prj_sp);

d356 1
a356 1
	prj_print_sp((struct prj_specific *)dp);
a366 1
	struct prj_image *img;
d368 4
a371 4
	while (BU_LIST_WHILE( img, prj_image, &(prj_sp->prj_img) )) {
		BU_LIST_DEQUEUE( &(img->l) );
		bu_close_mapped_file( img->i_mp );
		bu_free( (char *)img, "prj_image" );
d393 15
a407 7
	point_t pt;
	struct prj_image *i;
	struct prj_image *best;	/* image that best suits this hit point */
	double best_angle = 8.0;
	struct application my_ap;
	static plane_t pl = { 0.0, 0.0, 1.0, -1.0 };
	vect_t N;
d415 1
a415 1
		prj_print_sp(prj_sp);
a416 1

d421 5
a425 2
	MAT4X3PNT(pt, prj_sp->prj_m_to_sh, swp->sw_hit.hit_point);
	MAT4X3VEC(N, prj_sp->prj_m_to_sh, swp->sw_hit.hit_normal);
d430 1
a430 1
		V3ARGS(pt) );
a432 6
	/* Find the image with the closest projection angle to the normal */
	best = (struct prj_image *)NULL;
	for (BU_LIST_FOR(i, prj_image, &prj_sp->prj_img)) {
		double dist;
		vect_t dir;
		point_t pl_pt;
d434 24
a457 2
/* XXX removed to make compilation work, fix and reinstate */
/*		if (VDOT(i->i_plane, N) >= 0.0) continue; */
d459 1
a459 2
		/* convert hit point into view coordinates of image */
		MAT4X3PNT(pl_pt, i->i_mat, pt);
d461 3
d465 1
a465 6
		/* compute plane point */
		if (i->i_persp) {
			VSUB2(dir, pt, i->i_eyept);
		} else {
			VREVERSE(dir, pl);
		}
d467 2
a468 16
#if 0
/* XXX removed to make compilation work, fix and reinstate */
		switch (bn_isect_line3_plane(&dist, pt, dir, i->i_plane, &ap->a_rt_i->rti_tol)) {
		case 0: /* line lies on plane */
			break;
		case 1: /* hit entering */
			break;
		default:
			continue;
			break;
		}
#else
		dist = 42;
#endif
		/* get point on image plane */
		VJOIN1(pl_pt, pt, dist, dir);
d470 1
a470 1
		/* XXX fire ray to check self-occlusion */
d472 31
a503 1
		/* transform model space to image space */
d505 6
a511 1

d514 2
a515 9
	VMOVE(swp->sw_color, pt);

	/* shader must perform transmission/reflection calculations
	 *
	 * 0 < swp->sw_transmit <= 1 causes transmission computations
	 * 0 < swp->sw_reflect <= 1 causes reflection computations
	 */
	if( swp->sw_reflect > 0 || swp->sw_transmit > 0 )
		(void)rr_render( ap, pp, swp );
d517 1
a517 1
	return(1);
@


1.13
log
@Can't make "struct mfuncs" a CONST, because the forward link needs
to be filled in at runtime, and some compilers put CONST data into
read-only pages (like FreeBSD).
@
text
@d15 15
d31 4
d44 4
a47 3
#include "./material.h"
#include "./mathtab.h"
#include "./rdebug.h"
@


1.12
log
@Null statement to quench compiler warnings while porting.
@
text
@d205 1
a205 1
CONST struct mfuncs prj_mfuncs[] = {
@


1.11
log
@Port to sun4
@
text
@d380 2
@


1.10
log
@One more time, for John.
@
text
@d92 2
a93 2
	{"%d",	3, "orientation",IMG_O(i_orient),	FUNC_NULL },
	{"%d",	3, "eye_pt",	IMG_O(i_eyept),		FUNC_NULL },
d105 2
a106 2
	{"%d",	3,	 "o",	IMG_O(i_orient),	FUNC_NULL },
	{"%d",	3, 	 "e",	IMG_O(i_eyept),		FUNC_NULL },
@


1.9
log
@Another CVS chekin test
@
text
@a17 2
/* XXX CVS checked this in */

@


1.8
log
@Testing CVS
@
text
@d18 1
a18 1

@


1.7
log
@reworked to use external parameter file for each and every image.
@
text
@d18 2
@


1.6
log
@checkpoint
@
text
@d19 2
d36 2
a37 1
	unsigned 	i_width;
a39 1
	struct bu_mapped_file	*i_mp;
d41 1
a41 3
	double		i_persp;
	point_t		i_eye;
	quat_t		i_quat;
d43 2
d46 6
a51 3
	plane_t		i_plane;	/* computed */

	mat_t		i_mat;	/* view rot/scale matrix */
a53 1

d62 2
a63 2
	unsigned	prj_count;
	struct prj_image prj_images;	/* list of images to map on object */
d68 3
d74 6
a80 7
static void
image_dup(prj_sp)
struct prj_specific *prj_sp;
{
	struct prj_image *i;
	mat_t xlate, rotscale;
	quat_t newquat;
d82 14
a95 2
	/* dup off to new list element */
	GETSTRUCT( i, prj_image );
d97 12
a108 1
	memmove( i, &prj_sp->prj_images, sizeof(*i));
d110 5
a114 13
	BU_LIST_APPEND( &(prj_sp->prj_images.l), &(i->l) );
	BU_LIST_MAGIC_SET( &(i->l), IMAGE_MAGIC );

	/* According to rt/do.c this reconstructs the matrix from the
	 * three parameters "eye_pt" "orientation" and "viewsize"
	 */
	quat_quat2mat( rotscale, i->i_quat);
	rotscale[15] = 0.5 * i->i_viewsize;
	mat_idn( xlate );
	MAT_DELTAS_VEC_NEG(xlate, i->i_eye);
	mat_mul(i->i_mat, rotscale, xlate);
}

d123 10
d134 26
a159 5
	/* we just parsed a new filename.  If the prj_images struct has
	 * any values set, that means we have finished parsing the previous
	 * image's specification.  It is thus time to copy it off and zero the
	 * parameters for the next image
	 */
d161 8
a168 2
	if (prj_sp->prj_count)
		image_dup(prj_sp);
d170 2
a171 2
	/* initialize new image */
	prj_sp->prj_images.i_mp = bu_open_mapped_file( prj_sp->prj_name, NULL );
d173 1
a174 11
	prj_sp->prj_images.i_width = prj_sp->prj_images.i_height = 512;
	prj_sp->prj_images.i_depth = 3;
}
void
dimen_hook(sdp, name, base, value)
register CONST struct bu_structparse	*sdp;	/* structure description */
register CONST char			*name;	/* struct member name */
char					*base;	/* begining of structure */
CONST char				*value;	/* string containing value */
{
	struct prj_specific *prj_sp = (struct prj_specific *)sdp;
a175 2
	prj_sp->prj_images.i_height = prj_sp->prj_images.i_width;
}
d177 7
a183 6
void
plane_cond(sdp, name, base, value)
register CONST struct bu_structparse	*sdp;	/* structure description */
register CONST char			*name;	/* struct member name */
char					*base;	/* begining of structure */
CONST char				*value;	/* string containing value */
d185 6
a192 28
/* description of how to parse/print the arguments to the shader
 * There is at least one line here for each variable in the shader specific
 * structure above
 */
struct bu_structparse prj_print_tab[] = {
	{"%s", NAME_LEN, "file",SHDR_AO(prj_name),		image_hook },
	{"%d",  1, "depth",	SHDR_O(prj_images.i_depth),	FUNC_NULL },
	{"%d",  1, "width",	SHDR_O(prj_images.i_width),	FUNC_NULL },
	{"%d",  1, "numscan",	SHDR_O(prj_images.i_height),	FUNC_NULL },
	{"%d",  1, "squaresize",SHDR_O(prj_images.i_width),	dimen_hook },

	{"",	0, (char *)0,	0,				FUNC_NULL }
};

struct bu_structparse prj_parse_tab[] = {
	{"i",bu_byteoffset(prj_print_tab[0]), "prj_print_tab", 0, FUNC_NULL },
	{"%s",	NAME_LEN, "f",	SHDR_AO(prj_name),		image_hook },
	{"%d",  1, "d",		SHDR_O(prj_images.i_depth),	FUNC_NULL },
	{"%d",  1, "w",		SHDR_O(prj_images.i_width),	FUNC_NULL },
	{"%d",  1, "n",		SHDR_O(prj_images.i_height),	FUNC_NULL },
	{"%d",  1, "s",		SHDR_O(prj_images.i_width),	dimen_hook },

	{"%f",  1, "p",		SHDR_O(prj_images.i_persp),	plane_cond },
	{"%f",  1, "v",		SHDR_O(prj_images.i_viewsize),	plane_cond },
	{"%f",  4, "q",		SHDR_AO(prj_images.i_quat),	plane_cond },
	{"%f",  3, "e",		SHDR_AO(prj_images.i_eye),	plane_cond },
	{"",	0, (char *)0,	0,				FUNC_NULL }
};
a245 1

d247 1
a248 2
	BU_LIST_INIT(&prj_sp->prj_images.l);
	*prj_sp->prj_name = '\0';
d250 1
a250 1
	memset(&prj_sp->prj_images, 0, sizeof(prj_sp->prj_images));
d258 1
a258 1
	/* parse the user's arguments for this use of the shader. */
d262 1
a262 3
	if (prj_sp->prj_count) {
		image_dup(prj_sp);
	} else {
d266 2
a268 5
	if( rdebug&RDEBUG_SHADE) {
		bu_struct_print( " Parameters:", prj_print_tab, (char *)prj_sp );
		mat_print( "m_to_sh", prj_sp->prj_m_to_sh );
	}

d280 1
a280 1
	bu_struct_print( rp->reg_name, prj_print_tab, (char *)dp );
d291 1
a291 1
	struct prj_image *i;
d293 4
a296 3
	while (BU_LIST_WHILE( i, prj_image, &(prj_sp->prj_images.l) )) {
		BU_LIST_DEQUEUE( &(i->l) );
		bu_free( (char *)i, "prj_image" );
d332 2
a333 1
		bu_struct_print( "prj_render Parameters:", prj_print_tab, (char *)prj_sp );
d350 1
a350 1
	for (BU_LIST_FOR(i, prj_image, &prj_sp->prj_images.l)) {
d355 2
a356 1
		if (VDOT(i->i_plane, N) >= 0.0) continue;
d364 1
a364 1
			VSUB2(dir, pt, i->i_eye);
d369 2
d380 1
a380 1

@


1.5
log
@checkpoint
@
text
@d110 1
a110 1
		prj_dup(prj_sp);
d223 1
a223 1
	bu_mat_idn(prj_sp->prj_m_to_sh);
d345 1
a345 1
			VERVERSE(dir, pl);
@


1.4
log
@Required magic number to be first in mfunc table,
consistent with all other BRL-CAD magic numbers.
Required magic number to be initialized at compile time.
Added code to check the magic numbers.
Made the xxx_mfunc arrays CONST, so they can't get trashed by
runtime runaway pointer problems.
@
text
@d2 1
a2 1
 *	S H _ P R J . C
d4 1
a4 2
 *	A "slide projector" shader that projects multiple images
 *	onto an object.
d6 4
a9 6
 *	The parameter "cfile" to the shader is the name of a control file that
 *	contains the real parameters.  This file contains a set of
 *	image and projection descriptions.  Comments in this file are
 *	denoted by a "#" character in column 1.  The "file" item
 *	must be the first for each new image projection described.
 *	The other items may be in any order.
d11 3
a13 1
 *	# pt,x,y are in region coordinate system
a14 31
 *	# The view from the top, a 640x480 pix file
 *	#
 *	# The name of the image file
 *	file=top_view.pix
 *	# Dimensions of image (X, Y, depth)
 *	dim=640,480,3
 *	# Region space location of lower left corner
 *	pt=0,0,100
 *	# Vector defining region-space X axis of image
 *	x=640,0,0
 *	# Vector defining region-space Y axis of image
 *	y=0,480,0
 *	#
 *	# The view from the right, a 1024x768 bw file
 *	file=right_view.pix
 *	dim=1024,768,1
 *	pt=-20,-40,-20
 *	x=1024,0,0
 *	y=0,0,768
 *
 *	The parameter "method" is an integer indicating which method
 *	is used to choose the image which shades a hit-point.
 *
 *	Method	
 *	   1	choose image whose surface normal is closest to that of
 *			hit point normal.
 *	   
 *	Suggested Other methods:
 *	   
 *	   2	closest plane to pt
 *	   3	Average of visible plane pixels.
d27 1
a27 1
#define prj_MAGIC 0x8194    /* make this a unique number for each shader */
d30 3
a32 5
/* Description of a single "slide" or image to project */
#define SLIDE_MAGIC 0x9d8e
#define CK_SLIDE(_p) RT_CKMAG(_p, SLIDE_MAGIC, "slide")

struct slide {
d34 9
a42 12
	int		sl_dim[3];	/* x,y,depth dimensions of image */
	struct bu_vls	sl_file;	/* name of file with image */
	unsigned char	*sl_img;	/* actual image data */
	point_t		sl_pt;		/* x,y,z of LL corner of image */
	vect_t		sl_x;		/* direction of image X in plane */
	double		sl_xlen;	/* Length of image in X direction */
	double		sl_xpixel_len;	/* Length of image in X direction */
	vect_t		sl_y;		/* direction of image Y in plane */
	double		sl_ylen;	/* Length of image in Y direction */
	double		sl_ypixel_len;	/* Length of image in Y direction */
	plane_t		sl_plane;	/* eqn of plane of image, computed */
};
d44 1
a44 8
struct bu_structparse prj_file_parse_tab[] = {
	{"%S",	1, "file", offsetof(struct slide, sl_file),	FUNC_NULL },
	{"%d",	3, "dim",  offsetofarray(struct slide, sl_dim),	FUNC_NULL },
	{"%f",	3, "x",    offsetofarray(struct slide, sl_x),	FUNC_NULL },
	{"%f",	1, "xlen", offsetof(struct slide, sl_xlen),	FUNC_NULL },
	{"%f",	3, "y",    offsetofarray(struct slide, sl_y),	FUNC_NULL },
	{"%f",	1, "ylen", offsetof(struct slide, sl_ylen),	FUNC_NULL },
	{"%f",	3, "pt",  offsetofarray(struct slide, sl_pt),	FUNC_NULL },
d46 1
a46 3

	{"%f",	4, "plane", offsetofarray(struct slide, sl_plane),FUNC_NULL },
	{"",	0, (char *)0,		0,			FUNC_NULL }
d55 5
a59 5
	long		magic;		/* magic # for memory validity check, must come 1st */
	int		prj_method;	/* image selection method */
	mat_t		prj_m_to_r;	/* model to region space matrix */
	struct bu_vls	prj_cfile;	/* name of control file */
	struct bu_list	prj_slides;		/* linked list of images */
a63 11
/* The default values for the variables in the shader specific structure */
static CONST 
struct prj_specific prj_defaults = {
	prj_MAGIC,
	1,				/* prj_method */
	{	1.0, 0.0, 0.0, 0.0,	/* prj_m_to_r */
		0.0, 1.0, 0.0, 0.0,
		0.0, 0.0, 1.0, 0.0,
		0.0, 0.0, 0.0, 1.0 }
	};

d68 71
d144 10
d155 12
a166 3
	{"%S",  1, "cfile",		SHDR_O(prj_cfile),	FUNC_NULL },
	{"%d",	1, "method",		SHDR_O(prj_method),	FUNC_NULL },
	{"",	0, (char *)0,		0,			FUNC_NULL }
a168 1

a187 10
/* Once user has specified all parameters, compute some useful 
 * traits of the "slide"
 */
static void
finish_slide_setup(slide)
register struct slide *slide;
{

	if (!slide) return;

a188 14
	VUNITIZE(slide->sl_x);
	VUNITIZE(slide->sl_y);

	slide->sl_xpixel_len = slide->sl_xlen / (double)slide->sl_dim[0];
	slide->sl_ypixel_len = slide->sl_ylen / (double)slide->sl_dim[1];

	VCROSS(slide->sl_plane, slide->sl_x, slide->sl_y);
	slide->sl_plane[W] = 0;
	slide->sl_plane[W] = DIST_PT_PLANE(slide->sl_pt, slide->sl_plane);



}

d204 2
a205 7
	char	*cfile;
	char	*dfile;
	FILE	*cfd;
	struct bu_vls	line;
	struct slide	*slide;
	int	size, n;

d214 1
a214 1
		bu_log("prj_setup(%s)\n", rp->reg_name);
a220 1
	memcpy(prj_sp, &prj_defaults, sizeof(struct prj_specific) );
d222 10
a231 7
	bu_vls_init(&prj_sp->prj_cfile);
	BU_LIST_INIT(&prj_sp->prj_slides);

	/* Unlike most shaders, prj only gets the name of a file from the
	 * database.  The real parameters for the shader are stored in the
	 * file.  So we have to open the file and parse the contents.
	 * Unlike most shaders, we can't very well provide defaults.
d233 1
a233 5
	if( bu_struct_parse( matparm, prj_parse_tab, (char *)prj_sp ) < 0 ||
	  ! bu_vls_strlen(&prj_sp->prj_cfile) ) {
		bu_free((char *)prj_sp, "prj_specific");
		return -1;
	}
d235 8
a242 5
	cfile = bu_vls_addr(&prj_sp->prj_cfile);
	if ((cfd = fopen(cfile, "r")) == (FILE *)NULL) {
		bu_log("%s: can't open\n", cfile);
		bu_free((char *)prj_sp, "prj_specific");
		return -1;
d246 3
a248 81
	slide = (struct slide *)NULL;

	/* get each line from the control file, and fill in the slide
	 * descriptions
	 */
for (bu_vls_init(&line) ; bu_vls_gets(&line, cfd) >= 0 ;
bu_vls_trunc2(&line, 0) ) {
		register char *p = bu_vls_addr(&line);

		if (!p || !*p || *p == '#') {
			if( rdebug&RDEBUG_SHADE)
				bu_log("skipping cfile line \"%s\"\n", p);
			continue;
		}

		if (! strncmp(p, "file=", 5) ) {
			/* starting a new "slide"
			 *
			 * Before we forget the old slide, compute some
			 * important values: Unitize vectors, compute plane
			 */
			if (slide)
				finish_slide_setup(slide);

			/* get the new slide and put it in place */
			GETSTRUCT(slide, slide);
			BU_LIST_MAGIC_SET(&slide->l, SLIDE_MAGIC);
			BU_LIST_APPEND(&prj_sp->prj_slides, &(slide->l) );
		}

		if (!slide) {
			bu_log("Error: file= directive must come first in control file\n");
			return -1;
		}

		bu_struct_parse(&line, prj_file_parse_tab,
			(char *)BU_LIST_FIRST(slide, &prj_sp->prj_slides) );
	}

	finish_slide_setup(slide);

	fclose(cfd);

	/* load the images */
	for (BU_LIST_FOR(slide, slide, &prj_sp->prj_slides)) {

		CK_SLIDE(slide);

		/* open the image file */
		dfile = bu_vls_addr(&slide->sl_file);
		if ((cfd=fopen( dfile, "r")) == (FILE*)NULL) {
			struct slide *badslide = slide;

			bu_log("%s: can't open\n", dfile);

			/* open failed, remove this slide */
			slide = BU_LIST_PREV(slide, &badslide->l);
			BU_LIST_DEQUEUE( &badslide->l );
			bu_free((char *)badslide, "slide");
			continue;
		}

		/* malloc storage for the image data */
		size = slide->sl_dim[0] * slide->sl_dim[1]; 
		slide->sl_img = (unsigned char *)
			bu_malloc(size*slide->sl_dim[2], "image data");

		/* read in the data */
		n = fread(slide->sl_img, slide->sl_dim[2], size, cfd);
		if (n != size) {
			struct slide *badslide = slide;

			bu_log("read error %s: %d != %d\n", slide->sl_file,
				n, size);

			/* read failed, remove this slide */
			slide = BU_LIST_PREV(slide, &badslide->l);
			BU_LIST_DEQUEUE( &badslide->l );
			bu_free((char *)badslide, "slide");
		}
		(void)fclose(cfd);
a250 14
	/*
	 * The shader needs to operate in a coordinate system which stays
	 * fixed on the region when the region is moved (as in animation).
	 * We need to get a matrix to perform the appropriate transform(s).
	 *
	 * Shading is done in "region coordinates"
	 */
	db_region_mat(prj_sp->prj_m_to_r, rtip->rti_dbip, rp->reg_name);


	if( rdebug&RDEBUG_SHADE) {
		prj_print(rp, (char *)prj_sp);
		mat_print( "m_to_r", prj_sp->prj_m_to_r );	}

d262 1
a262 8
	struct slide *slide;
	struct prj_specific *prj_sp = (struct prj_specific *)dp;

	bu_struct_print( rp->reg_name, prj_parse_tab, (char *)dp );

	for (BU_LIST_FOR(slide, slide, &prj_sp->prj_slides )) {
		bu_struct_print("", prj_file_parse_tab, (char *)slide);
	}
a271 1
	struct slide *slide;
d273 1
d275 3
a277 3
	while (BU_LIST_WHILE(slide, slide, &prj_sp->prj_slides)) {
		BU_LIST_DEQUEUE( &(slide->l) );
		bu_free((char *)slide, "slide");
a279 1

d283 1
a283 114


/* Shader method 1
 *
 */
void
method1(swp, prj_sp, pt, N)
struct shadework	*swp;	/* defined in material.h */
register struct prj_specific *prj_sp;
point_t			pt;
plane_t			N;
{
	struct slide *slide;
	struct slide *prj_slide = (struct slide *)NULL;
	int i;
	double max_cos_angle = -2.0;
	double cos_angle;
	int img_xpixel;
	int img_ypixel;
	double img_dx;
	double img_dy;
	unsigned char *pixel;
	fastf_t dist;
	vect_t OP;	/* img origin->pt vector */
	point_t pl_pt;

	if( rdebug&RDEBUG_SHADE)
		bu_log("Method 1\n");


	/* find the "slide" with the closest surface normal */
	for (BU_LIST_FOR(slide, slide, &prj_sp->prj_slides)) {

		CK_SLIDE(slide);

		cos_angle = VDOT(N, slide->sl_plane);
		if (cos_angle > max_cos_angle) {
			max_cos_angle = cos_angle;
			prj_slide = slide;
		}
	}
	if (! prj_slide ) {
		/* What?  No slides? */
		VSETALL(swp->sw_color, 1.0);
		if( rdebug&RDEBUG_SHADE)
			bu_log("no slides\n");
	    	return;
	}

	if( rdebug&RDEBUG_SHADE) {
		bu_struct_print("Selected Slide", prj_file_parse_tab,
			(char *)prj_slide);
		bu_log("  pt (%g %g %g)  N (%g %g %g)\n",
			V3ARGS(pt),
			V3ARGS(N));
	}

	/* compute point in image plane */
	dist = prj_slide->sl_plane[W] - VDOT(prj_slide->sl_plane, pt);
	VJOIN1(pl_pt, pt, dist, prj_slide->sl_plane);

	/* compute image pixel */
	VSUB2(OP, pl_pt, prj_slide->sl_pt);
	img_dx = VDOT(OP, prj_slide->sl_x);
	img_dy = VDOT(OP, prj_slide->sl_y);
	img_xpixel = img_dx / prj_slide->sl_xpixel_len;
	img_ypixel = img_dy / prj_slide->sl_ypixel_len;

	if (img_xpixel < 0 || img_ypixel < 0 || 
	    img_xpixel >= prj_slide->sl_dim[X] ||
	    img_ypixel >= prj_slide->sl_dim[Y] ) {
		/* hit point outside image */
	    	VSETALL(swp->sw_color, 0.0);
	}
		
	if( rdebug&RDEBUG_SHADE) {
		VPRINT("Plane Point", pl_pt);
		bu_log("img_d(xy) (%g,%g)\n", img_dx, img_dy);
		bu_log("img_pixel(xy) (%d,%d)\n", img_xpixel, img_ypixel);
	}

	pixel = &prj_slide->sl_img[
		img_ypixel * prj_slide->sl_dim[X] * prj_slide->sl_dim[Z] +
		img_xpixel * prj_slide->sl_dim[Z] ];


	switch (prj_slide->sl_dim[Z]) {
	case 3:	
		for (i=0 ; i < 3 ; i++)
			swp->sw_color[i] = (double)(pixel[i]) / 255.0;
		break;
	default:
		bu_log("bad image depth %d, assuming 1\n", prj_slide->sl_dim[Z]);
		/* Fallthrough */
	case 1:
		for (i=0 ; i < 3 ; i++)
			swp->sw_color[i] = (double)(*pixel) / 255.0;

		break;
	}

bailout:
	if( rdebug&RDEBUG_SHADE) {
		bu_log("image %s[%d,%d] = %d %d %d\n", 
			bu_vls_addr(&prj_slide->sl_file),
			img_xpixel, img_ypixel,
			(int)(swp->sw_color[0] * 255),
			(int)(swp->sw_color[1] * 255),
			(int)(swp->sw_color[2] * 255) );
	}

}

/*
d300 6
a305 2
	vect_t	N;

d313 1
a313 1
		bu_struct_print( "prj_render Parameters:", prj_parse_tab, (char *)prj_sp );
d319 2
a320 2
	MAT4X3PNT(pt, prj_sp->prj_m_to_r, swp->sw_hit.hit_point);
	MAT4X3VEC(N, prj_sp->prj_m_to_r, swp->sw_hit.hit_normal);
d323 1
a323 1
		bu_log("prj_render()  model:(%g %g %g) shader:(%g %g %g)\n", 
d328 37
d366 2
a367 3
	switch (prj_sp->prj_method) {
	default:
	case	1: method1(swp, prj_sp, pt, N);
d370 1
a375 3
	 *
	 *if( swp->sw_reflect > 0 || swp->sw_transmit > 0 )
	 *	(void)rr_render( ap, pp, swp );
d377 2
@


1.3
log
@"errno" isn't defined on R10k.
@
text
@d148 2
a149 2
struct mfuncs prj_mfuncs[] = {
	{"prj",	0,	0,		MFI_NORMAL|MFI_HIT|MFI_UV,	0,
d152 1
a152 1
	{(char *)0,	0,		0,		0,		0,
@


1.2
log
@Butler mods
@
text
@d236 1
a236 1
		bu_log("%s %s\n", strerror(errno), cfile);
d295 1
a295 1
			bu_log("%s %s\n", strerror(errno), dfile);
@


1.1
log
@Initial revision
@
text
@d16 3
a18 1
 *	# the view from the top, a 640x480 pix file
d20 1
d22 1
d24 1
d26 1
d29 1
a29 1
 *	# The view from the right a 1024x768 bw file
d63 3
d67 2
a68 1
	struct rt_list	l;
d71 1
a71 2
	int		sl_dim[3];	/* x,y,depth dimensions of image */
	point_t		sl_pt;
d73 6
a78 4
	double		sl_xdist;
	vect_t		sl_y;		/* direction of image X in plane */
	double		sl_ydist;
	plane_t		sl_plane;	/* eqn of plane of image */
d85 1
d87 1
d111 1
a111 1
CONST static
d114 1
a114 1
	1,
d130 1
a130 1
struct bu_structparse prj_print_tab[] = {
d132 1
a132 5
	{"",	0, (char *)0,		0,			FUNC_NULL }

};
struct bu_structparse prj_parse_tab[] = {
	{"i",	bu_byteoffset(prj_print_tab[0]), "prj_print_tab", 0, FUNC_NULL },
a162 1
	plane_t pl;
d164 3
a166 1
	slide->sl_xdist = MAGNITUDE(slide->sl_x);
d168 1
d170 2
a171 2
	slide->sl_ydist = MAGNITUDE(slide->sl_y);
	VUNITIZE(slide->sl_y);
d176 3
a195 2
	mat_t	tmp;
	vect_t	bb_min, bb_max, v_tmp;
a201 1
	point_t	xpt, ypt;
d211 1
a211 1
		rt_log("prj_setup(%s)\n", rp->reg_name);
d230 1
a230 1
		bu_free(prj_sp, "prj_specific");
d236 2
a237 2
		rt_log("%s %s\n", strerror(errno), cfile);
		bu_free(prj_sp, "prj_specific");
d242 1
a242 2
	GETSTRUCT(slide, slide);
	BU_LIST_APPEND(&prj_sp->prj_slides, &(slide->l) );
d247 2
a248 1
	for (bu_vls_init(&line) ; bu_vls_gets(&line, cfd) ; bu_vls_trunc2(&line, 0) ) {
d251 5
a255 1
		if (*p && *p != '#') continue;
d257 1
a257 1
		if (! strncmp(p, "file=", 5)) {
d263 2
a264 1
			finish_slide_setup(slide);
d268 1
d272 5
d288 2
d295 1
a295 1
			rt_log("%s %s\n", strerror(errno), dfile);
d300 1
a300 1
			bu_free(badslide, "slide");
d306 2
a307 1
		slide->sl_img = bu_malloc(size*slide->sl_dim[2], "image data");
d314 1
a314 1
			rt_log("read error %s: %d != %d\n", slide->sl_file,
d320 1
a320 1
			bu_free(badslide, "slide");
d326 3
a328 3
	 * If the shader needs to operate in a coordinate system which stays
	 * fixed on the region when the region is moved (as in animation)
	 * we need to get a matrix to perform the appropriate transform(s).
d336 2
a337 3
		bu_struct_print( " Parameters:", prj_print_tab, (char *)prj_sp );
		mat_print( "m_to_r", prj_sp->prj_m_to_r );
	}
d353 1
a353 1
	bu_struct_print( rp->reg_name, prj_print_tab, (char *)dp );
d379 114
a492 1
/*
a507 1
	struct slide *prj_slide = (struct slide *)NULL;
d518 1
a518 1
		bu_struct_print( "prj_render Parameters:", prj_print_tab, (char *)prj_sp );
d528 1
a528 1
		rt_log("prj_render()  model:(%g %g %g) shader:(%g %g %g)\n", 
d536 1
a536 35
	case	1:
		{
			struct slide *slide;
			double max_cos_angle = -2.0;
			double cos_angle;
			fastf_t dist;
			int error;

			for (BU_LIST_FOR(slide, slide, &prj_sp->prj_slides)) {
				cos_angle = VDOT(N, slide->sl_plane);
				if (cos_angle > max_cos_angle) {
					max_cos_angle = cos_angle;
					prj_slide = slide;
				}
			}
			if (! prj_slide ) {
				/* What?  No slides? */
				VSETALL(swp->sw_color, 1.0);
				goto reflect;
			}

			error = bn_isect_line3_plane(&dist, pt, N,
				slide->sl_plane, &ap->a_rt_i->rti_tol);

			if (error) {
				VSETALL(swp->sw_color, 1.0);
				goto reflect;
			}

			/* compute point in image plane */
			VJOIN1(pt, pt, dist, N);

			/* */

		}
a538 1
	
a539 2

reflect:
d544 3
a547 2
	if( swp->sw_reflect > 0 || swp->sw_transmit > 0 )
		(void)rr_render( ap, pp, swp );
@
