head	1.35;
access;
symbols
	ansi-20040405-merged:1.31.2.2
	postmerge-20040405-ansi:1.33
	premerge-20040404-ansi:1.32
	postmerge-autoconf:1.32
	autoconf-freeze:1.31.10.2
	premerge-autoconf:1.32
	ansi-20040316-freeze:1.31.2.1
	postmerge-20040315-windows:1.32
	premerge-20040315-windows:1.32
	windows-20040315-freeze:1.31.4.1
	autoconf-20031203:1.31
	autoconf-20031202:1.31
	autoconf-branch:1.31.0.10
	phong-branch:1.31.0.8
	photonmap-branch:1.31.0.6
	rel-6-1-DP:1.31
	windows-branch:1.31.0.4
	rel-6-0-2:1.29
	ansi-branch:1.31.0.2
	rel-6-0-1-branch:1.29.0.2
	hartley-6-0-post:1.30
	hartley-6-0-pre:1.29
	rel-6-0-1:1.29
	rel-6-0:1.28
	rel-5-4:1.22
	offsite-5-3-pre:1.27
	rel-5-3:1.22
	rel-5-2:1.22
	rel-5-1-branch:1.22.0.2
	rel-5-1:1.22
	rel-5-0:1.18
	rel-5-0-beta:1.16
	rel-4-5:1.12
	ctj-4-5-post:1.11
	ctj-4-5-pre:1.11;
locks; strict;
comment	@ * @;


1.35
date	2004.05.21.18.07.27;	author morrison;	state dead;
branches;
next	1.34;

1.34
date	2004.05.10.15.30.45;	author erikg;	state Exp;
branches;
next	1.33;

1.33
date	2004.04.05.07.43.37;	author morrison;	state Exp;
branches;
next	1.32;

1.32
date	2004.02.02.17.39.14;	author morrison;	state Exp;
branches;
next	1.31;

1.31
date	2002.08.20.17.07.52;	author jra;	state Exp;
branches
	1.31.2.1
	1.31.4.1
	1.31.10.1;
next	1.30;

1.30
date	2002.08.15.20.55.04;	author hartley;	state Exp;
branches;
next	1.29;

1.29
date	2002.07.16.19.38.39;	author morrison;	state Exp;
branches;
next	1.28;

1.28
date	2001.03.31.01.57.03;	author morrison;	state Exp;
branches;
next	1.27;

1.27
date	2000.10.19.19.19.45;	author butler;	state Exp;
branches;
next	1.26;

1.26
date	2000.09.09.04.30.52;	author mike;	state Exp;
branches;
next	1.25;

1.25
date	2000.08.23.05.09.07;	author butler;	state Exp;
branches;
next	1.24;

1.24
date	2000.08.20.01.27.48;	author butler;	state Exp;
branches;
next	1.23;

1.23
date	2000.07.25.16.40.38;	author butler;	state Exp;
branches;
next	1.22;

1.22
date	2000.04.15.02.20.42;	author mike;	state Exp;
branches;
next	1.21;

1.21
date	2000.02.19.21.05.02;	author butler;	state Exp;
branches;
next	1.20;

1.20
date	99.12.30.16.10.05;	author jra;	state Exp;
branches;
next	1.19;

1.19
date	99.10.30.03.06.24;	author butler;	state Exp;
branches;
next	1.18;

1.18
date	99.07.02.22.20.41;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	99.07.01.20.08.48;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	99.02.04.06.45.02;	author butler;	state Exp;
branches;
next	1.15;

1.15
date	99.02.04.02.19.46;	author butler;	state Exp;
branches;
next	1.14;

1.14
date	98.09.22.01.29.55;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	98.06.30.22.54.19;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	97.12.31.09.01.40;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	97.07.02.21.15.29;	author butler;	state Exp;
branches;
next	1.10;

1.10
date	97.04.22.23.58.26;	author butler;	state Exp;
branches;
next	1.9;

1.9
date	97.03.04.08.20.30;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	96.08.31.08.46.01;	author butler;	state Exp;
branches;
next	1.7;

1.7
date	96.08.31.08.29.28;	author butler;	state Exp;
branches;
next	1.6;

1.6
date	96.08.30.00.08.21;	author butler;	state Exp;
branches;
next	1.5;

1.5
date	96.05.07.19.26.36;	author jra;	state Exp;
branches;
next	1.4;

1.4
date	95.12.27.17.31.49;	author butler;	state Exp;
branches;
next	1.3;

1.3
date	95.10.20.04.43.53;	author butler;	state Exp;
branches;
next	1.2;

1.2
date	95.09.21.00.34.40;	author butler;	state Exp;
branches;
next	1.1;

1.1
date	95.09.20.16.39.37;	author butler;	state Exp;
branches;
next	;

1.31.2.1
date	2002.09.19.18.01.26;	author morrison;	state Exp;
branches;
next	1.31.2.2;

1.31.2.2
date	2004.03.17.21.18.32;	author morrison;	state Exp;
branches;
next	;

1.31.4.1
date	2004.03.11.23.43.02;	author morrison;	state Exp;
branches;
next	;

1.31.10.1
date	2004.02.12.18.38.49;	author erikg;	state Exp;
branches;
next	1.31.10.2;

1.31.10.2
date	2004.03.15.14.07.13;	author erikg;	state Exp;
branches;
next	;


desc
@solid clouds from noise
@


1.35
log
@moved to src/
@
text
@/*
 *	S H _ S C L O U D . C
 *
 *	A 3D "solid" cloud shader
 *
 *  Author -
 *	Lee A. Butler
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" license agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1998-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/liboptical/sh_scloud.c,v 1.34 2004/05/10 15:30:45 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef HAVE_STRING_H
#include <string.h>
#endif
#include <math.h>
#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "shadefuncs.h"
#include "shadework.h"
#include "rtprivate.h"
#include "light.h"

extern int rr_render(struct application	*ap,
		     struct partition	*pp,
		     struct shadework   *swp);
#if !defined(M_PI)
#define M_PI            3.14159265358979323846
#endif

#define FLOOR(x)	(  (int)(x) - (  (x) < 0 && (x) != (int)(x)  )  )
#define CEIL(x)		(  (int)(x) + (  (x) > 0 && (x) != (int)(x)  )  )

struct scloud_specific {
	double	lacunarity;
	double	h_val;
	double	octaves;
	double	scale;	/* scale coordinate space */
	point_t	vscale;
	vect_t	delta;	/* xlatd in noise space (where interesting noise is)*/
	double	max_d_p_mm;	/* maximum density per millimeter */
	double	min_d_p_mm;	/* background density per millimeter */
	mat_t	mtos;		/* model to shader */
	mat_t	stom;		/* shader to model */
};

static struct scloud_specific scloud_defaults = {
	2.1753974,	/* lacunarity */
	1.0,		/* h_val */
	4.0,		/* octaves */
	1.0,		/* scale */
	{ 1.0, 1.0, 1.0 },	/* vscale */
	{ 1000.0, 1200.0, 2100.0 },	/* delta */
	0.01,			/* max_d_p_mm */
	0.0
	};

#define SHDR_NULL	((struct scloud_specific *)0)
#define SHDR_O(m)	offsetof(struct scloud_specific, m)
#define SHDR_AO(m)	bu_offsetofarray(struct scloud_specific, m)

struct bu_structparse scloud_pr[] = {
	{"%f",	1, "lacunarity",	SHDR_O(lacunarity),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "H", 		SHDR_O(h_val),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "octaves", 		SHDR_O(octaves),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",  1, "scale",		SHDR_O(scale),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",  3, "vscale",		SHDR_AO(vscale),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",  3, "delta",		SHDR_AO(delta),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "Max", 		SHDR_O(max_d_p_mm),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "min", 		SHDR_O(min_d_p_mm),	BU_STRUCTPARSE_FUNC_NULL },
	{"",	0, (char *)0,		0,			BU_STRUCTPARSE_FUNC_NULL }
};
struct bu_structparse scloud_parse[] = {
	{"%f",	1, "lacunarity",	SHDR_O(lacunarity),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "H", 		SHDR_O(h_val),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "octaves", 		SHDR_O(octaves),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",  1, "scale",		SHDR_O(scale),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",  3, "delta",		SHDR_AO(delta),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "l",			SHDR_O(lacunarity),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "M", 		SHDR_O(max_d_p_mm),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "Max", 		SHDR_O(max_d_p_mm),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "m", 		SHDR_O(min_d_p_mm),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "min", 		SHDR_O(min_d_p_mm),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "o", 		SHDR_O(octaves),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",  1, "s",			SHDR_O(scale),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",  3, "vs",		SHDR_AO(vscale),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",  3, "d",			SHDR_AO(delta),		BU_STRUCTPARSE_FUNC_NULL },
	{"",	0, (char *)0,		0,			BU_STRUCTPARSE_FUNC_NULL }
};

HIDDEN int	scloud_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip), scloud_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp), tsplat_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
HIDDEN void	scloud_print(register struct region *rp, char *dp), scloud_free(char *cp);

struct mfuncs scloud_mfuncs[] = {
	{MF_MAGIC,	"scloud",	0,	MFI_HIT, MFF_PROC,
	scloud_setup,	scloud_render,	scloud_print,	scloud_free },

	{MF_MAGIC,	"tsplat",	0,	MFI_HIT, MFF_PROC,
	scloud_setup,	tsplat_render,	scloud_print,	scloud_free },

	{0,		(char *)0,	0,		0, 0,
	0,		0,		0,		0 }
};



/*
 *	S C L O U D _ S E T U P
 */
HIDDEN int
scloud_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip)
                           
             	         
    	      	/* pointer to reg_udata in *rp */
             		     
           		      
{
	register struct scloud_specific *scloud;
	struct db_full_path full_path;
	mat_t	region_to_model;
	mat_t	model_to_region;
	mat_t	tmp;

	BU_CK_VLS( matparm );
	BU_GETSTRUCT( scloud, scloud_specific );
	*dpp = (char *)scloud;

	if (rp->reg_aircode == 0) {
		bu_log("WARNING(%s): air shader '%s' applied to non-air region.\n%s\n",
			rp->reg_name,
			mfp->mf_name,
			"  Set air flag with \"edcodes\" in mged");
		bu_bomb("");
	}

	memcpy(scloud, &scloud_defaults, sizeof(struct scloud_specific) );
	if (rdebug&RDEBUG_SHADE)
		bu_log("scloud_setup\n");

	if (bu_struct_parse( matparm, scloud_parse, (char *)scloud ) < 0 )
		return(-1);

	if (rdebug&RDEBUG_SHADE)
		(void)bu_struct_print( rp->reg_name, scloud_parse, (char *)scloud );

	/* get transformation between world and "region" coordinates */
	if (db_string_to_path( &full_path, rtip->rti_dbip, rp->reg_name) ) {
		/* bad thing */
		rt_bomb("db_string_to_path() error");
	}
	if(! db_path_to_mat(rtip->rti_dbip, &full_path, region_to_model, 0, &rt_uniresource)) {
		/* bad thing */
		rt_bomb("db_path_to_mat() error");
	}

	/* get matrix to map points from model space to "region" space */
	bn_mat_inv(model_to_region, region_to_model);

	/* add the noise-space scaling */
	MAT_IDN(tmp);
	if (scloud->scale != 1.0) {
		tmp[0] = tmp[5] = tmp[10] = 1.0 / scloud->scale;
	} else {
		tmp[0] = 1.0 / (scloud->vscale[0]);
		tmp[5] = 1.0 / (scloud->vscale[1]);
		tmp[10] = 1.0 / (scloud->vscale[2]);
	}

	bn_mat_mul(scloud->mtos, tmp, model_to_region);

	/* add the translation within noise space */
	MAT_IDN(tmp);
	tmp[MDX] = scloud->delta[0];
	tmp[MDY] = scloud->delta[1];
	tmp[MDZ] = scloud->delta[2];
	bn_mat_mul2(tmp, scloud->mtos);
	bn_mat_inv(scloud->stom, scloud->mtos);

	return(1);
}

/*
 *	S C L O U D _ P R I N T
 */
HIDDEN void
scloud_print(register struct region *rp, char *dp)
{
	(void)bu_struct_print( rp->reg_name, scloud_pr, (char *)dp );
}

/*
 *	S C L O U D _ F R E E
 */
HIDDEN void
scloud_free(char *cp)
{
	bu_free( cp, "scloud_specific" );
}



/*
 *	T S P L A T _ R E N D E R
 *
 *	Sort of a surface spot transparency shader.  Picks transparency
 *	based upon noise value of surface spot.
 */
int
tsplat_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
{
	register struct scloud_specific *scloud_sp =
		(struct scloud_specific *)dp;
	point_t in_pt;	/* point where ray enters scloud solid */
	double  val;

	RT_CHECK_PT(pp);
	RT_AP_CHECK(ap);
	RT_CK_REGION(pp->pt_regionp);


	/* just shade the surface with a transparency */
	MAT4X3PNT(in_pt, scloud_sp->mtos, swp->sw_hit.hit_point);
	val = bn_noise_fbm(in_pt, scloud_sp->h_val,
			scloud_sp->lacunarity, scloud_sp->octaves );
	CLAMP(val, 0.0, 1.0);
	swp->sw_transmit = 1.0 - val;


	if (swp->sw_reflect > 0 || swp->sw_transmit > 0 )
		(void)rr_render( ap, pp, swp );

	return 1;
}



/*
 *	S C L O U D _ R E N D E R
 */
int
scloud_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
{
	register struct scloud_specific *scloud_sp =
		(struct scloud_specific *)dp;
	point_t in_pt;	/* point where ray enters scloud solid */
	point_t out_pt; /* point where ray leaves scloud solid */
	point_t pt;
	vect_t	v_cloud;/* vector representing ray/solid intersection */
	double	thickness; /* magnitude of v_cloud (distance through solid) */
	int	steps;	   /* # of samples along ray/solid intersection */
	double	step_delta;/* distance between sample points, texture space */
	int	i;
	double  val;
	double	trans;
	point_t	incident_light;
	double	delta_dpmm;
	double density;
	struct shadework sub_sw;
	struct light_specific *lp;

	RT_CHECK_PT(pp);
	RT_AP_CHECK(ap);
	RT_CK_REGION(pp->pt_regionp);

	/* compute the ray/solid in and out points,
	 * and transform them into "shader space" coordinates 
	 */
	VJOIN1(pt, ap->a_ray.r_pt, pp->pt_inhit->hit_dist, ap->a_ray.r_dir);
	MAT4X3PNT(in_pt, scloud_sp->mtos, pt);

	VJOIN1(pt, ap->a_ray.r_pt, pp->pt_outhit->hit_dist, ap->a_ray.r_dir);
	MAT4X3PNT(out_pt, scloud_sp->mtos, pt);


	/* get ray/solid intersection vector (in noise space)
	 * and compute thickness of solid (in noise space) along ray path
	 */
	VSUB2(v_cloud, out_pt, in_pt);
	thickness = MAGNITUDE(v_cloud);

	/* The noise field used by the bn_noise_turb and bn_noise_fbm routines
	 * has a maximum frequency of about 1 cycle per integer step in
	 * noise space.  Each octave increases this frequency by the
	 * "lacunarity" factor.  To sample this space adequately we need 
	 *
	 *	4 samples per integer step for the first octave,
	 *	lacunarity * 4 samples/step for the second octave,
	 * 	lacunarity^2 * 4 samples/step for the third octave,
	 * 	lacunarity^3 * 4 samples/step for the forth octave,
	 *
	 * so for a computation with 4 octaves we need something on the
	 * order of lacunarity^3 * 4 samples per integer step in noise space.
	 */

	steps = pow(scloud_sp->lacunarity, scloud_sp->octaves-1) * 4;
	step_delta = thickness / (double)steps;

	if (rdebug&RDEBUG_SHADE)
		bu_log("steps=%d  delta=%g  thickness=%g\n",
			steps, step_delta, thickness);

	VUNITIZE(v_cloud);
	VMOVE(pt, in_pt);
	trans = 1.0;

	delta_dpmm = scloud_sp->max_d_p_mm - scloud_sp->min_d_p_mm;

	sub_sw = *swp; /* struct copy */
	sub_sw.sw_inputs = MFI_HIT;

	for (i=0 ; i < steps ; i++ ) {
		/* compute the next point in the cloud space */
		VJOIN1(pt, in_pt, i*step_delta, v_cloud);

		/* get turbulence value (0 .. 1) */
		val = bn_noise_turb(pt, scloud_sp->h_val, 
			scloud_sp->lacunarity, scloud_sp->octaves );

		density = scloud_sp->min_d_p_mm + val * delta_dpmm;

		val = exp( - density * step_delta);
		trans *= val;

		if (swp->sw_xmitonly) continue;

		/* need to set the hit in our fake shadework structure */
		MAT4X3PNT(sub_sw.sw_hit.hit_point, scloud_sp->stom, pt);
		sub_sw.sw_transmit = trans;

		sub_sw.sw_inputs = MFI_HIT;

		light_obs( ap, &sub_sw, swp->sw_inputs );
		/* now we know how much light has arrived from each
		 * light source to this point
		 */
		for (i=ap->a_rt_i->rti_nlights-1  ; i >= 0 ; i--) {
			lp = (struct light_specific *)swp->sw_visible[i];
			if (lp == LIGHT_NULL ) continue;

			/* compute how much light has arrived at 
			 * this location
			 */
			incident_light[0] += sub_sw.sw_intensity[3*i+0] *
				lp->lt_color[0] * sub_sw.sw_lightfract[i];
			incident_light[1] += sub_sw.sw_intensity[3*i+1] *
				lp->lt_color[1] * sub_sw.sw_lightfract[i];
			incident_light[2] += sub_sw.sw_intensity[3*i+2] *
				lp->lt_color[2] * sub_sw.sw_lightfract[i];
		}

		VSCALE(incident_light, incident_light, trans);


	}

	/* scloud is basically a white object with partial transparency */
	swp->sw_transmit = trans;
	if (swp->sw_xmitonly )  return 1;


	/*
	 *  At the point of maximum opacity, check light visibility
	 *  for light color and cloud shadowing.
	 *  OOPS:  Don't use an interior point, or light_visibility()
	 *  will see an attenuated light source.
	 */
	swp->sw_hit.hit_dist = pp->pt_inhit->hit_dist;
	VJOIN1(swp->sw_hit.hit_point, ap->a_ray.r_pt, swp->sw_hit.hit_dist,
 		ap->a_ray.r_dir);
	VREVERSE( swp->sw_hit.hit_normal, ap->a_ray.r_dir );
	swp->sw_inputs |= MFI_HIT | MFI_NORMAL;
	light_obs( ap, swp, swp->sw_inputs );
	VSETALL(incident_light, 0 );
	for( i=ap->a_rt_i->rti_nlights-1; i>=0; i-- )  {
		struct light_specific	*lp;
		if ((lp = (struct light_specific *)swp->sw_visible[i]) == LIGHT_NULL )
			continue;
		/* XXX don't have a macro for this */
		incident_light[0] += swp->sw_intensity[3*i+0] * lp->lt_color[0];
		incident_light[1] += swp->sw_intensity[3*i+1] * lp->lt_color[1];
		incident_light[2] += swp->sw_intensity[3*i+2] * lp->lt_color[2];
	}
	VELMUL( swp->sw_color, swp->sw_color, incident_light );


	if (rdebug&RDEBUG_SHADE ) {
		pr_shadework( "scloud: after light vis, before rr_render", swp);
	}

	if (swp->sw_reflect > 0 || swp->sw_transmit > 0 )
		(void)rr_render( ap, pp, swp );

	return(1);
}




@


1.34
log
@change conf.h to a wrapped config.h
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/liboptical/sh_scloud.c,v 1.33 2004/04/05 07:43:37 morrison Exp $ (ARL)";
@


1.33
log
@merge of ansi-6-0-branch into HEAD
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d26 5
a30 1
#include "conf.h"
@


1.32
log
@update copyright to include span through 2003
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_scloud.c,v 1.31 2002/08/20 17:07:52 jra Exp $ (ARL)";
d108 2
a109 2
HIDDEN int	scloud_setup(), scloud_render(), tsplat_render();
HIDDEN void	scloud_print(), scloud_free();
d128 6
a133 6
scloud_setup( rp, matparm, dpp, mfp, rtip )
register struct region *rp;
struct bu_vls	*matparm;
char	**dpp;	/* pointer to reg_udata in *rp */
struct mfuncs		*mfp;
struct rt_i		*rtip;
d203 1
a203 3
scloud_print( rp, dp )
register struct region *rp;
char	*dp;
d212 1
a212 2
scloud_free( cp )
char *cp;
d226 1
a226 5
tsplat_render( ap, pp, swp, dp )
struct application	*ap;
struct partition	*pp;
struct shadework	*swp;
char	*dp;
d258 1
a258 5
scloud_render( ap, pp, swp, dp )
struct application	*ap;
struct partition	*pp;
struct shadework	*swp;
char	*dp;
@


1.31
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1998 by the United States Army
d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_scloud.c,v 1.29 2002/07/16 19:38:39 morrison Exp $ (ARL)";
@


1.31.4.1
log
@sync to HEAD...
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1998-2004 by the United States Army
d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/liboptical/sh_scloud.c,v 1.32 2004/02/02 17:39:14 morrison Exp $ (ARL)";
@


1.31.10.1
log
@merge from HEAD
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1998-2004 by the United States Army
d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_scloud.c,v 1.32 2004/02/02 17:39:14 morrison Exp $ (ARL)";
@


1.31.10.2
log
@merge from head
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_scloud.c,v 1.31.10.1 2004/02/12 18:38:49 erikg Exp $ (ARL)";
@


1.31.2.1
log
@Initial ANSIfication
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_scloud.c,v 1.31 2002/08/20 17:07:52 jra Exp $ (ARL)";
d108 2
a109 2
HIDDEN int	scloud_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip), scloud_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp), tsplat_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
HIDDEN void	scloud_print(register struct region *rp, char *dp), scloud_free(char *cp);
d128 6
a133 6
scloud_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip)
                           
             	         
    	      	/* pointer to reg_udata in *rp */
             		     
           		      
d203 3
a205 1
scloud_print(register struct region *rp, char *dp)
d214 2
a215 1
scloud_free(char *cp)
d229 5
a233 1
tsplat_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
d265 5
a269 1
scloud_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
@


1.31.2.2
log
@sync branch with HEAD
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1998-2004 by the United States Army
d23 1
a23 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
@


1.30
log
@Converted from K&R to ANSI C - RFH
@
text
@d108 2
a109 2
HIDDEN int	scloud_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip), scloud_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp), tsplat_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
HIDDEN void	scloud_print(register struct region *rp, char *dp), scloud_free(char *cp);
d128 6
a133 6
scloud_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip)
                           
             	         
    	      	/* pointer to reg_udata in *rp */
             		     
           		      
d203 3
a205 1
scloud_print(register struct region *rp, char *dp)
d214 2
a215 1
scloud_free(char *cp)
d229 5
a233 1
tsplat_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
d265 5
a269 1
scloud_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
@


1.29
log
@Moved the non-local-only header file (light.h) from rt/ into the header directory since it is used by multiple targets (liboptical, rt, etc)
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_scloud.c,v 1.28 2001/03/31 01:57:03 morrison Exp $ (ARL)";
d108 2
a109 2
HIDDEN int	scloud_setup(), scloud_render(), tsplat_render();
HIDDEN void	scloud_print(), scloud_free();
d128 6
a133 6
scloud_setup( rp, matparm, dpp, mfp, rtip )
register struct region *rp;
struct bu_vls	*matparm;
char	**dpp;	/* pointer to reg_udata in *rp */
struct mfuncs		*mfp;
struct rt_i		*rtip;
d203 1
a203 3
scloud_print( rp, dp )
register struct region *rp;
char	*dp;
d212 1
a212 2
scloud_free( cp )
char *cp;
d226 1
a226 5
tsplat_render( ap, pp, swp, dp )
struct application	*ap;
struct partition	*pp;
struct shadework	*swp;
char	*dp;
d258 1
a258 5
scloud_render( ap, pp, swp, dp )
struct application	*ap;
struct partition	*pp;
struct shadework	*swp;
char	*dp;
@


1.28
log
@Deprecated bn_mat_idn() and bn_mat_zero(), updated calls to h/vmath.h's MAT_IDN() and MAT_ZERO() performance improved macros.
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_scloud.c,v 1.27 2000/10/19 19:19:45 butler Exp $ (ARL)";
d39 1
a39 1
#include "../rt/light.h"
@


1.27
log
@Changes to compile under RedHat 7.0
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_scloud.c,v 1.26 2000/09/09 04:30:52 mike Exp $ (ARL)";
d177 1
a177 1
	bn_mat_idn(tmp);
d189 1
a189 1
	bn_mat_idn(tmp);
@


1.26
log
@
Struct db_tree_state finally got a magic number. Added resource argument
to ft_describe(), db_region_mat(), db_shader_mat(),
db_init_db_tree_state(), and db_path_to_mat().
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_scloud.c,v 1.25 2000/08/23 05:09:07 butler Exp $ (ARL)";
d29 3
@


1.25
log
@Compilation warning messages eliminated
Light sample point parsing added
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_scloud.c,v 1.24 2000/08/20 01:27:48 butler Exp $ (ARL)";
d165 1
a165 1
	if(! db_path_to_mat(rtip->rti_dbip, &full_path, region_to_model, 0)) {
@


1.24
log
@Eliminate compilation warnings, enhancements to sh_light.c
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_scloud.c,v 1.23 2000/07/25 16:40:38 butler Exp $ (ARL)";
a343 2
		if (rdebug&RDEBUG_SHADE)
			
@


1.23
log
@Changes to use rtprivate.h instead of ../rt/rdebug.h
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_scloud.c,v 1.22 2000/04/15 02:20:42 mike Exp $ (ARL)";
@


1.22
log
@
Removed dead variable
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_scloud.c,v 1.21 2000/02/19 21:05:02 butler Exp $ (ARL)";
d35 1
a35 1
#include "../rt/rdebug.h"
d38 3
@


1.21
log
@Changes to support movement of CLAMP() macro into vmath.h
Altered "if( " statements to "if (" for readability.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_scloud.c,v 1.20 1999/12/30 16:10:05 jra Exp $ (ARL)";
a280 1
	struct application sub_ap;
a331 3

	sub_ap = *ap; /* struct copy */
	sub_ap.a_diverge = 0.0; /* light rays shouldn't diverge */
@


1.20
log
@Eliniated some unused variables
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_scloud.c,v 1.19 1999/10/30 03:06:24 butler Exp $ (ARL)";
a41 1
#define CLAMP(_x,_a,_b)	(_x < _a ? _a : (_x > _b ? _b : _x))
d53 3
a55 1
	mat_t	xform;
d65 2
a66 1
	0.01			/* max_d_p_mm */
d80 2
d91 4
a94 1
	{"%f",	1, "m", 		SHDR_O(max_d_p_mm),	BU_STRUCTPARSE_FUNC_NULL },
d148 1
a148 1
	if( rdebug&RDEBUG_SHADE)
d151 1
a151 1
	if( bu_struct_parse( matparm, scloud_parse, (char *)scloud ) < 0 )
d154 1
a154 1
	if( rdebug&RDEBUG_SHADE)
d167 1
a167 3
	/* get matrix to map points from model (world) space
	 * to "region" space
	 */
a169 1

d180 1
a180 1
	bn_mat_mul(scloud->xform, tmp, model_to_region);
d187 2
a188 1
	bn_mat_mul2(tmp, scloud->xform);
d240 1
a240 1
	MAT4X3PNT(in_pt, scloud_sp->xform, swp->sw_hit.hit_point);
d243 2
a244 1
	swp->sw_transmit = 1.0 - CLAMP(val, 0.0, 1.0);
d247 1
a247 1
	if( swp->sw_reflect > 0 || swp->sw_transmit > 0 )
d278 5
d292 1
a292 1
	MAT4X3PNT(in_pt, scloud_sp->xform, pt);
d295 1
a295 1
	MAT4X3PNT(out_pt, scloud_sp->xform, pt);
d321 1
a321 1
	if( rdebug&RDEBUG_SHADE)
d328 9
d341 1
d345 3
a347 3
		val -= .5;
		val = CLAMP(val, 0.0, 1.0);
		val *= 2.0;
d349 1
a349 1
		val = exp( - val * scloud_sp->max_d_p_mm * step_delta);
d351 31
d386 1
a386 1
	if( swp->sw_xmitonly )  return 1;
d400 1
a400 1
	light_visibility( ap, swp, swp->sw_inputs );
d404 1
a404 1
		if( (lp = (struct light_specific *)swp->sw_visible[i]) == LIGHT_NULL )
d414 1
a414 1
	if( rdebug&RDEBUG_SHADE ) {
d418 1
a418 1
	if( swp->sw_reflect > 0 || swp->sw_transmit > 0 )
@


1.19
log
@Moved mathtab/rand_half from rt into libbn
Expanded structparse to include description and default
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_scloud.c,v 1.18 1999/07/02 22:20:41 mike Exp $ (ARL)";
a267 1
	fastf_t	model_step; /* distance between sample points, model space */
a270 1
	double	sum;
a308 2
	model_step = (pp->pt_outhit->hit_dist - pp->pt_inhit->hit_dist) /
		(double)steps;
@


1.18
log
@
Removed dependence on compat4.h
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_scloud.c,v 1.17 1999/07/01 20:08:48 mike Exp $ (ARL)";
a34 1
#include "../rt/mathtab.h"
@


1.17
log
@
compat4
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_scloud.c,v 1.16 1999/02/04 06:45:02 butler Exp $ (ARL)";
d73 7
a79 7
	{"%f",	1, "lacunarity",	SHDR_O(lacunarity),	FUNC_NULL },
	{"%f",	1, "H", 		SHDR_O(h_val),		FUNC_NULL },
	{"%f",	1, "octaves", 		SHDR_O(octaves),	FUNC_NULL },
	{"%f",  1, "scale",		SHDR_O(scale),		FUNC_NULL },
	{"%f",  3, "vscale",		SHDR_AO(vscale),	FUNC_NULL },
	{"%f",  3, "delta",		SHDR_AO(delta),		FUNC_NULL },
	{"",	0, (char *)0,		0,			FUNC_NULL }
d82 12
a93 12
	{"%f",	1, "lacunarity",	SHDR_O(lacunarity),	FUNC_NULL },
	{"%f",	1, "H", 		SHDR_O(h_val),		FUNC_NULL },
	{"%f",	1, "octaves", 		SHDR_O(octaves),	FUNC_NULL },
	{"%f",  1, "scale",		SHDR_O(scale),		FUNC_NULL },
	{"%f",  3, "delta",		SHDR_AO(delta),		FUNC_NULL },
	{"%f",	1, "l",			SHDR_O(lacunarity),	FUNC_NULL },
	{"%f",	1, "m", 		SHDR_O(max_d_p_mm),	FUNC_NULL },
	{"%f",	1, "o", 		SHDR_O(octaves),	FUNC_NULL },
	{"%f",  1, "s",			SHDR_O(scale),		FUNC_NULL },
	{"%f",  3, "vs",		SHDR_AO(vscale),	FUNC_NULL },
	{"%f",  3, "d",			SHDR_AO(delta),		FUNC_NULL },
	{"",	0, (char *)0,		0,			FUNC_NULL }
@


1.16
log
@matched comment to code
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_scloud.c,v 1.15 1999/02/04 02:19:46 butler Exp $ (ARL)";
d70 1
a70 1
#define SHDR_AO(m)	offsetofarray(struct scloud_specific, m)
d118 1
a118 1
struct rt_vls	*matparm;
d129 2
a130 2
	RT_VLS_CHECK( matparm );
	GETSTRUCT( scloud, scloud_specific );
d143 1
a143 1
		rt_log("scloud_setup\n");
d164 1
a164 1
	mat_inv(model_to_region, region_to_model);
d168 1
a168 1
	mat_idn(tmp);
d177 1
a177 1
	mat_mul(scloud->xform, tmp, model_to_region);
d180 1
a180 1
	mat_idn(tmp);
d184 1
a184 1
	mat_mul2(tmp, scloud->xform);
d207 1
a207 1
	rt_free( cp, "scloud_specific" );
d237 1
a237 1
	val = noise_fbm(in_pt, scloud_sp->h_val,
d296 1
a296 1
	/* The noise field used by the noise_turb and noise_fbm routines
d316 1
a316 1
		rt_log("steps=%d  delta=%g  thickness=%g\n",
d326 1
a326 1
		val = noise_turb(pt, scloud_sp->h_val, 
@


1.15
log
@Added vector scale parameter argument
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_scloud.c,v 1.14 1998/09/22 01:29:55 mike Exp $ (ARL)";
d213 1
a213 1
 *	T C L O U D _ R E N D E R
@


1.14
log
@Moved optical shaders from rt/ to liboptical/
The only modifications involved moving and splitting
rt/material.h into h/shadefuncs.h and h/shadework.h,
and in changing the calling sequence to mlib_setup() in rt/material.c

Now the only shader function called directly by RT is
in liboptical/init.c: optical_shader_init().
It adds all the individual shaders to the "mfuncs" shader list.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
d52 1
d63 2
a64 1
	{ 0.0, 0.0, 0.0 },	/* delta */
d74 1
a74 1
	{"%f",	1, "H", 		SHDR_O(h_val),	FUNC_NULL },
d76 3
a78 2
	{"%f",  1, "scale",		SHDR_O(scale),	FUNC_NULL },
	{"%f",  3, "delta",		SHDR_AO(delta),	FUNC_NULL },
d83 1
a83 1
	{"%f",	1, "H", 		SHDR_O(h_val),	FUNC_NULL },
d85 2
a86 2
	{"%f",  1, "scale",		SHDR_O(scale),	FUNC_NULL },
	{"%f",  3, "delta",		SHDR_AO(delta),	FUNC_NULL },
d90 3
a92 2
	{"%f",  1, "s",			SHDR_O(scale),	FUNC_NULL },
	{"%f",  3, "d",			SHDR_AO(delta),	FUNC_NULL },
d133 8
d169 7
a175 3
	tmp[0] = 1. / scloud->scale;
	tmp[5] = 1. / scloud->scale;
	tmp[10] =  1. / scloud->scale;
@


1.13
log
@Can't make "struct mfuncs" a CONST, because the forward link needs
to be filled in at runtime, and some compilers put CONST data into
read-only pages (like FreeBSD).
@
text
@d5 16
d22 4
d33 7
a39 4
#include "./material.h"
#include "./light.h"
#include "./mathtab.h"
#include "./rdebug.h"
d41 1
@


1.12
log
@Required magic number to be first in mfunc table,
consistent with all other BRL-CAD magic numbers.
Required magic number to be initialized at compile time.
Added code to check the magic numbers.
Made the xxx_mfunc arrays CONST, so they can't get trashed by
runtime runaway pointer problems.
@
text
@d71 1
a71 1
CONST struct mfuncs scloud_mfuncs[] = {
@


1.11
log
@checkpoint
@
text
@d71 2
a72 2
struct mfuncs scloud_mfuncs[] = {
	{"scloud",	0,		0,	MFI_HIT, MFF_PROC,
d75 1
a75 1
	{"tsplat",	0,		0,	MFI_HIT, MFF_PROC,
d78 1
a78 1
	{(char *)0,	0,		0,		0, 0,
@


1.10
log
@made tsplat shader
@
text
@d68 1
a68 1
HIDDEN int	scloud_setup(), scloud_render();
d76 1
a76 1
	scloud_setup,	tcloud_render,	scloud_print,	scloud_free },
d179 1
a179 1
tcloud_render( ap, pp, swp, dp )
a234 4
#if SEEK_MINVAL
	double	minval = 1;
	int	min_i;
#endif
a281 4
#if SEEK_MINVAL
	minval = 1;
	min_i = 0;
#endif
a294 6
#if SEEK_MINVAL
		if( val < minval )  {
			minval = val;
			min_i = i;
		}
#endif
d301 1
a301 1
#if 1
a307 3
# if SEEK_MINVAL
	swp->sw_hit.hit_dist = pp->pt_inhit->hit_dist + min_i * model_step;
# else
a308 1
# endif
d325 2
a326 12
#else
	/*  Rather than assume the cloud is white, use the color of
	 *  the first light source.  This is a hack.
	 */
	{
		struct light_specific	*lp;
		if( BU_LIST_NON_EMPTY(&LightHead.l) )  {
			lp = BU_LIST_FIRST(light_specific, &LightHead.l);
			VELMUL( swp->sw_color, swp->sw_color, lp->lt_color );
		}
	}
#endif
@


1.9
log
@Added code to check clouds for light visibility & light color.
@
text
@d75 3
a111 2
	(void)bu_struct_print( rp->reg_name, scloud_pr, (char *)scloud );

d170 40
a243 14
#if 0
	/* just shade the surface with a transparency */
	MAT4X3PNT(in_pt, scloud_sp->xform, swp->sw_hit.hit_point);
	val = noise_fbm(in_pt, scloud_sp->h_val,
			scloud_sp->lacunarity, scloud_sp->octaves );
	swp->sw_transmit = 1.0 - CLAMP(val, 0.0, 1.0);

/* 	VSET(swp->sw_color, val, val, val); */

	if( swp->sw_reflect > 0 || swp->sw_transmit > 0 )
		(void)rr_render( ap, pp, swp );

	return 1;
#endif
a259 9
#if 0
	/* shade with a transparency proportional to the thickness */
	swp->sw_transmit = exp( - scloud_sp->max_d_p_mm * thickness );
	swp->sw_transmit = CLAMP(swp->sw_transmit, 0.0, 1.0);
	if( swp->sw_reflect > 0 || swp->sw_transmit > 0 )
		(void)rr_render( ap, pp, swp );
	return 1;
#endif

d279 4
a282 4
#ifdef LEELOG
	rt_log("steps=%d  delta=%g  thickness=%g\n",
		steps, step_delta, thickness);
#endif
d364 4
@


1.8
log
@bu_struct_print
@
text
@d14 1
d187 2
a188 1
	double	step_delta;/* distance between sample points */
d193 5
d258 2
d268 4
d283 8
a290 1
		trans *=  exp( - val * scloud_sp->max_d_p_mm * step_delta);
d292 2
a293 1
	
d295 45
@


1.7
log
@bu_struct_parse
@
text
@d108 1
a108 1
	(void)bu_structprint( rp->reg_name, scloud_pr, (char *)scloud );
d111 1
a111 1
		(void)bu_structprint( rp->reg_name, scloud_parse, (char *)scloud );
d155 1
a155 1
	(void)bu_structprint( rp->reg_name, scloud_pr, (char *)dp );
@


1.6
log
@structparse moved to libbu
@
text
@d105 1
a105 1
	if( bu_structparse( matparm, scloud_parse, (char *)scloud ) < 0 )
@


1.5
log
@Individual shaders now call rr_render() directly.
@
text
@d45 1
a45 1
struct structparse scloud_pr[] = {
d53 1
a53 1
struct structparse scloud_parse[] = {
d105 1
a105 1
	if( rt_structparse( matparm, scloud_parse, (char *)scloud ) < 0 )
d108 1
a108 1
	rt_structprint( rp->reg_name, scloud_pr, (char *)scloud );
d111 1
a111 1
		rt_structprint( rp->reg_name, scloud_parse, (char *)scloud );
d155 1
a155 1
	rt_structprint( rp->reg_name, scloud_pr, (char *)dp );
@


1.4
log
@restricted inputs to just "HIT", and added "MFF_PROC" to mfuncs declaration
@
text
@d204 4
d230 2
d274 3
@


1.3
log
@edited mfuncs table to account for new "mf_flags" element in struct mfuncs.
@
text
@d71 1
a71 1
	{"scloud",	0,		0,	MFI_NORMAL|MFI_HIT|MFI_UV, 0,
@


1.2
log
@first passable "solid clouds"
@
text
@d26 1
a27 1
	point_t	scale;	/* scale coordinate space */
d36 1
a37 1
	{ 1.0, 1.0, 1.0 },	/* scale */
d49 1
a49 1
	{"%f",  3, "scale",		SHDR_AO(scale),	FUNC_NULL },
d57 1
a57 1
	{"%f",  3, "scale",		SHDR_AO(scale),	FUNC_NULL },
d62 1
a62 1
	{"%f",  3, "s",			SHDR_AO(scale),	FUNC_NULL },
d71 1
a71 1
	{"scloud",	0,		0,		MFI_NORMAL|MFI_HIT|MFI_UV,
d74 1
a74 1
	{(char *)0,	0,		0,		0,
d108 2
d131 3
a133 3
	tmp[0] = 1. / scloud->scale[0];
	tmp[5] = 1. / scloud->scale[1];
	tmp[10] =  1. / scloud->scale[2];
d206 5
a210 2
	VJOIN1(in_pt, ap->a_ray.r_pt, pp->pt_inhit->hit_dist, ap->a_ray.r_dir);
	VJOIN1(out_pt, ap->a_ray.r_pt, pp->pt_outhit->hit_dist, ap->a_ray.r_dir);
d212 2
a213 3
	/* transform points into "noise-space coordinates" */
	MAT4X3PNT(in_pt, scloud_sp->xform, in_pt);
	MAT4X3PNT(out_pt, scloud_sp->xform, out_pt);
d215 3
a217 2
	/* get ray/solid intersection vector and compute thickness of
	 * solid along ray path
d229 13
a241 2
	if (thickness < 3.0) steps = 3;
	else steps = (int)thickness;
d243 1
d246 4
@


1.1
log
@Initial revision
@
text
@d26 1
a26 2
	double	thresh;
	vect_t	delta;
d28 1
a35 1
	1.0,		/* threshold for opacity */
d38 1
a48 1
	{"%f",	1, "thresh",		SHDR_O(thresh),	FUNC_NULL },
a56 1
	{"%f",	1, "thresh",		SHDR_O(thresh),	FUNC_NULL },
d60 1
a61 1
	{"%f",	1, "t",			SHDR_O(thresh),	FUNC_NULL },
d178 7
a184 5
	point_t in_pt, out_pt, pt;
	vect_t	v_cloud;
	double	thickness;
	int	steps;
	double	step_delta;
d187 2
a188 1
	double	transmission;
d195 1
d197 1
a197 1
		val = noise_fbm(in_pt, scloud_sp->h_val, 
d199 3
a201 1
 	VSET(swp->sw_color, val, val, val);
d207 1
a207 1
	/* transform point into "noise-space coordinates" */
d211 3
d216 7
a222 1
	steps = (int)(thickness * 3.0);
d224 3
a229 1

d231 1
a231 1
	transmission = 1.0;
d236 1
a236 1
		val = noise_fbm(pt, scloud_sp->h_val, 
d239 3
a241 3
		val = (val+1.) * .5;

		if (val > scloud_sp->thresh) {
d243 1
a243 6
			transmission -= 1-val;
			if (transmission < 0.000001) {
				transmission = 0.;
				break;
			}
		}
d245 2
a246 6

	transmission = CLAMP(transmission, 0.0, 1.0);

	swp->sw_transmit = transmission;

/* 	VSET(swp->sw_color, transmission, transmission, transmission); */
@
