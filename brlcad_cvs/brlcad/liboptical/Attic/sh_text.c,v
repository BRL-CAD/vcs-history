head	11.53;
access;
symbols
	ansi-20040405-merged:11.46.2.2
	postmerge-20040405-ansi:11.51
	premerge-20040404-ansi:11.50
	postmerge-autoconf:11.50
	autoconf-freeze:11.49.2.2
	premerge-autoconf:11.50
	ansi-20040316-freeze:11.46.2.1
	postmerge-20040315-windows:11.50
	premerge-20040315-windows:11.50
	windows-20040315-freeze:11.46.4.1
	autoconf-20031203:11.49
	autoconf-20031202:11.49
	autoconf-branch:11.49.0.2
	phong-branch:11.48.0.4
	photonmap-branch:11.48.0.2
	rel-6-1-DP:11.46
	windows-branch:11.46.0.4
	rel-6-0-2:11.43
	ansi-branch:11.46.0.2
	rel-6-0-1-branch:11.43.0.2
	hartley-6-0-post:11.44
	hartley-6-0-pre:11.43
	rel-6-0-1:11.43
	rel-6-0:11.42
	rel-5-4:11.31
	offsite-5-3-pre:11.38
	rel-5-3:11.31
	rel-5-2:11.31
	rel-5-1-branch:11.31.0.2
	rel-5-1:11.31
	rel-5-0:11.24
	rel-5-0-beta:11.22
	rel-4-5:11.17
	ctj-4-5-post:11.13
	ctj-4-5-pre:11.13
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.2
	rel-1-10:4.1
	rt-2:2.1;
locks; strict;
comment	@ * @;


11.53
date	2004.05.21.18.07.28;	author morrison;	state dead;
branches;
next	11.52;

11.52
date	2004.05.10.15.30.45;	author erikg;	state Exp;
branches;
next	11.51;

11.51
date	2004.04.05.07.43.37;	author morrison;	state Exp;
branches;
next	11.50;

11.50
date	2004.02.02.17.39.14;	author morrison;	state Exp;
branches;
next	11.49;

11.49
date	2003.09.27.01.05.10;	author morrison;	state Exp;
branches
	11.49.2.1;
next	11.48;

11.48
date	2002.12.04.01.14.37;	author morrison;	state Exp;
branches;
next	11.47;

11.47
date	2002.12.03.20.01.08;	author morrison;	state Exp;
branches;
next	11.46;

11.46
date	2002.08.22.20.30.48;	author morrison;	state Exp;
branches
	11.46.2.1
	11.46.4.1;
next	11.45;

11.45
date	2002.08.20.17.07.52;	author jra;	state Exp;
branches;
next	11.44;

11.44
date	2002.08.15.20.55.05;	author hartley;	state Exp;
branches;
next	11.43;

11.43
date	2002.05.17.12.52.40;	author morrison;	state Exp;
branches;
next	11.42;

11.42
date	2002.02.26.22.12.45;	author morrison;	state Exp;
branches;
next	11.41;

11.41
date	2002.02.25.21.40.42;	author morrison;	state Exp;
branches;
next	11.40;

11.40
date	2002.02.22.02.30.04;	author morrison;	state Exp;
branches;
next	11.39;

11.39
date	2001.04.20.22.29.33;	author morrison;	state Exp;
branches;
next	11.38;

11.38
date	2000.10.19.19.19.46;	author butler;	state Exp;
branches;
next	11.37;

11.37
date	2000.08.31.20.29.26;	author mike;	state Exp;
branches;
next	11.36;

11.36
date	2000.08.20.01.27.48;	author butler;	state Exp;
branches;
next	11.35;

11.35
date	2000.08.20.00.44.47;	author butler;	state Exp;
branches;
next	11.34;

11.34
date	2000.08.16.21.21.05;	author mike;	state Exp;
branches;
next	11.33;

11.33
date	2000.07.25.16.40.38;	author butler;	state Exp;
branches;
next	11.32;

11.32
date	2000.07.14.19.38.28;	author butler;	state Exp;
branches;
next	11.31;

11.31
date	2000.02.20.06.52.55;	author butler;	state Exp;
branches;
next	11.30;

11.30
date	2000.02.20.06.41.56;	author butler;	state Exp;
branches;
next	11.29;

11.29
date	2000.02.18.20.49.14;	author butler;	state Exp;
branches;
next	11.28;

11.28
date	2000.01.13.22.19.21;	author butler;	state Exp;
branches;
next	11.27;

11.27
date	99.12.30.16.05.58;	author jra;	state Exp;
branches;
next	11.26;

11.26
date	99.12.23.05.59.24;	author mike;	state Exp;
branches;
next	11.25;

11.25
date	99.10.30.03.06.25;	author butler;	state Exp;
branches;
next	11.24;

11.24
date	99.07.02.22.20.42;	author mike;	state Exp;
branches;
next	11.23;

11.23
date	99.07.01.20.08.49;	author mike;	state Exp;
branches;
next	11.22;

11.22
date	99.02.04.03.57.12;	author butler;	state Exp;
branches;
next	11.21;

11.21
date	98.12.10.03.35.15;	author mike;	state Exp;
branches;
next	11.20;

11.20
date	98.09.22.01.29.56;	author mike;	state Exp;
branches;
next	11.19;

11.19
date	98.07.13.19.12.16;	author jra;	state Exp;
branches;
next	11.18;

11.18
date	98.06.30.22.54.19;	author mike;	state Exp;
branches;
next	11.17;

11.17
date	97.12.31.09.01.40;	author mike;	state Exp;
branches;
next	11.16;

11.16
date	97.11.25.22.16.43;	author butler;	state Exp;
branches;
next	11.15;

11.15
date	97.11.21.20.59.34;	author jra;	state Exp;
branches;
next	11.14;

11.14
date	97.08.01.18.01.15;	author jra;	state Exp;
branches;
next	11.13;

11.13
date	97.07.02.21.15.37;	author butler;	state Exp;
branches;
next	11.12;

11.12
date	96.12.04.02.55.51;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	96.10.19.06.17.00;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	96.08.31.08.46.01;	author butler;	state Exp;
branches;
next	11.9;

11.9
date	96.08.31.08.29.28;	author butler;	state Exp;
branches;
next	11.8;

11.8
date	96.08.30.00.08.21;	author butler;	state Exp;
branches;
next	11.7;

11.7
date	96.07.22.20.34.18;	author jra;	state Exp;
branches;
next	11.6;

11.6
date	96.05.07.19.26.36;	author jra;	state Exp;
branches;
next	11.5;

11.5
date	95.10.20.04.43.53;	author butler;	state Exp;
branches;
next	11.4;

11.4
date	95.09.16.00.28.34;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	95.06.02.23.34.05;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	95.03.11.02.24.14;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.01.13;	author mike;	state Rel4_4;
branches;
next	10.8;

10.8
date	94.12.19.19.54.28;	author mike;	state Exp;
branches;
next	10.7;

10.7
date	94.11.30.19.23.24;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	94.11.15.21.57.51;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	94.11.05.02.53.18;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	94.10.29.02.38.11;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	94.08.11.02.29.04;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	94.03.09.17.57.53;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.42.13;	author mike;	state Rel4_0;
branches;
next	9.12;

9.12
date	91.07.06.00.35.24;	author mike;	state Exp;
branches;
next	9.11;

9.11
date	91.02.20.01.16.58;	author mike;	state Exp;
branches;
next	9.10;

9.10
date	91.02.17.20.15.56;	author mike;	state Exp;
branches;
next	9.9;

9.9
date	91.02.17.18.50.56;	author mike;	state Exp;
branches;
next	9.8;

9.8
date	91.01.05.03.09.18;	author mike;	state Exp;
branches;
next	9.7;

9.7
date	91.01.03.22.58.23;	author butler;	state Exp;
branches;
next	9.6;

9.6
date	90.12.12.16.35.12;	author butler;	state Exp;
branches;
next	9.5;

9.5
date	90.12.10.21.14.44;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	90.12.08.08.58.13;	author butler;	state Exp;
branches;
next	9.3;

9.3
date	90.12.08.08.30.46;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	90.12.08.08.20.14;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.59.46;	author mike;	state Rel3_5;
branches;
next	8.10;

8.10
date	89.04.30.21.26.16;	author mike;	state Exp;
branches;
next	8.9;

8.9
date	89.04.28.06.16.04;	author phil;	state Exp;
branches;
next	8.8;

8.8
date	89.04.05.01.47.01;	author mike;	state Exp;
branches;
next	8.7;

8.7
date	89.04.04.05.02.11;	author mike;	state Exp;
branches;
next	8.6;

8.6
date	89.03.29.15.32.34;	author phil;	state Exp;
branches;
next	8.5;

8.5
date	89.03.11.05.27.17;	author phil;	state Exp;
branches;
next	8.4;

8.4
date	89.01.09.06.07.25;	author mike;	state Exp;
branches;
next	8.3;

8.3
date	88.12.27.16.35.17;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	88.12.13.03.16.57;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.33.31;	author mike;	state Rel3_0;
branches;
next	7.7;

7.7
date	88.09.17.07.20.58;	author mike;	state Exp;
branches;
next	7.6;

7.6
date	88.06.21.02.53.43;	author mike;	state Exp;
branches;
next	7.5;

7.5
date	88.06.19.05.43.22;	author mike;	state Exp;
branches;
next	7.4;

7.4
date	88.05.14.02.28.28;	author mike;	state Exp;
branches;
next	7.3;

7.3
date	88.02.27.07.47.10;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	88.01.26.05.55.04;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.56.39;	author mike;	state Rel;
branches;
next	6.3;

6.3
date	87.09.16.04.33.56;	author mike;	state Exp;
branches;
next	6.2;

6.2
date	87.09.03.01.30.37;	author mike;	state Exp;
branches;
next	6.1;

6.1
date	87.07.11.07.59.26;	author mike;	state Rel;
branches;
next	5.6;

5.6
date	87.07.10.05.06.07;	author mike;	state Exp;
branches;
next	5.5;

5.5
date	87.07.06.15.09.30;	author mike;	state Exp;
branches;
next	5.4;

5.4
date	87.06.27.06.46.23;	author phil;	state Exp;
branches;
next	5.3;

5.3
date	87.06.27.03.58.31;	author phil;	state Exp;
branches;
next	5.2;

5.2
date	87.06.26.05.55.17;	author mike;	state Exp;
branches;
next	5.1;

5.1
date	87.06.24.22.15.31;	author mike;	state Rel;
branches;
next	4.3;

4.3
date	87.03.23.23.48.04;	author mike;	state Exp;
branches;
next	4.2;

4.2
date	87.02.13.00.02.54;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.48.51;	author mike;	state Rel1;
branches;
next	3.15;

3.15
date	86.12.24.04.27.12;	author mike;	state Exp;
branches;
next	3.14;

3.14
date	86.12.18.16.02.09;	author mike;	state Exp;
branches;
next	3.13;

3.13
date	86.11.07.02.46.25;	author mike;	state Exp;
branches;
next	3.12;

3.12
date	86.11.04.21.05.57;	author mike;	state Exp;
branches;
next	3.11;

3.11
date	86.10.29.04.51.18;	author mike;	state Exp;
branches;
next	3.10;

3.10
date	86.09.23.17.12.41;	author mike;	state Exp;
branches;
next	3.9;

3.9
date	86.08.12.05.50.59;	author mike;	state Exp;
branches;
next	3.8;

3.8
date	86.07.31.08.29.37;	author mike;	state Exp;
branches;
next	3.7;

3.7
date	86.07.30.03.56.40;	author mike;	state Exp;
branches;
next	3.6;

3.6
date	86.07.28.22.52.56;	author mike;	state Exp;
branches;
next	3.5;

3.5
date	86.07.24.06.05.39;	author mike;	state Exp;
branches;
next	3.4;

3.4
date	86.07.24.03.58.22;	author mike;	state Exp;
branches;
next	3.3;

3.3
date	86.07.19.04.40.07;	author mike;	state Exp;
branches;
next	3.2;

3.2
date	86.07.17.18.33.10;	author mike;	state Exp;
branches;
next	3.1;

3.1
date	86.06.11.00.14.40;	author mike;	state Exp;
branches;
next	3.0;

3.0
date	86.06.10.01.32.29;	author mike;	state Exp;
branches;
next	2.2;

2.2
date	86.06.09.21.49.44;	author mike;	state Exp;
branches;
next	2.1;

2.1
date	85.08.31.06.06.54;	author mike;	state Exp;
branches;
next	;

11.46.2.1
date	2002.09.19.18.01.26;	author morrison;	state Exp;
branches;
next	11.46.2.2;

11.46.2.2
date	2004.03.17.21.18.33;	author morrison;	state Exp;
branches;
next	;

11.46.4.1
date	2004.03.11.23.43.03;	author morrison;	state Exp;
branches;
next	;

11.49.2.1
date	2004.02.12.18.38.49;	author erikg;	state Exp;
branches;
next	11.49.2.2;

11.49.2.2
date	2004.03.15.14.07.13;	author erikg;	state Exp;
branches;
next	;


desc
@Apply a texture map from a file.
@


11.53
log
@moved to src/
@
text
@/*
 *  			S H _ T E X T . C
 *  
 *  Texture map lookup
 *
 *  Author -
 *	Michael John Muuss
 *
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" license agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1998-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/liboptical/sh_text.c,v 11.52 2004/05/10 15:30:45 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef HAVE_STRING_H
#include <string.h>
#endif
#include <ctype.h>
#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "shadefuncs.h"
#include "shadework.h"
/*#include "../rt/mathtab.h"*/
#include "rtprivate.h"

#define TXT_NAME_LEN 128
struct txt_specific {
	int	tx_transp[3];	/* RGB for transparency */
	/*	char	tx_file[TXT_NAME_LEN];	 Filename */
	struct bu_vls tx_name;  /* name of object or file (depending on tx_datasrc flag) */
	int	tx_w;		/* Width of texture in pixels */
	int	tx_n;		/* Number of scanlines */
	int	tx_trans_valid;	/* boolean: is tx_transp valid ? */
	fastf_t	tx_scale[2];	/* replication factors in U, V */
	int	tx_mirror;	/* flag: repetitions are mirrored */
#define TXT_SRC_FILE 'f'
#define TXT_SRC_OBJECT  'o'
#define TXT_SRC_AUTO 0
	char tx_datasrc; /* which type of datasource */
	struct rt_binunif_internal *tx_binunifp;  /* db internal object when TXT_SRC_OBJECT */
	struct bu_mapped_file	*tx_mp;    /* mapped file when TXT_SRC_FILE */
};
#define TX_NULL	((struct txt_specific *)0)
#define TX_O(m)	offsetof(struct txt_specific, m)
#define TX_AO(m)	bu_offsetofarray(struct txt_specific, m)

struct region	env_region;  /* initialized in the app code view handler */

extern int rr_render(struct application	*ap,
		     struct partition	*pp,
		     struct shadework   *swp);

HIDDEN void rt_binunif_free();
HIDDEN void txt_transp_hook(struct bu_structparse *ptab, char *name, char *cp, char *value);
HIDDEN void txt_source_hook(const struct bu_structparse *ip, const char *sp_name, genptr_t base, char *p);
HIDDEN int txt_load_datasource(struct txt_specific *texture, struct db_i *dbInstance, const long unsigned int size);
HIDDEN int bwtxt_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
HIDDEN int txt_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, const struct mfuncs *mfp, struct rt_i *rtip), txt_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
HIDDEN int ckr_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip), ckr_render(struct application *ap, struct partition *pp, register struct shadework *swp, char *dp);
HIDDEN int bmp_setup(), bmp_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
HIDDEN void bwtxtprint(), bwtxtfree();
HIDDEN void txt_print(register struct region *rp), txt_free(char *cp);
HIDDEN void ckr_print(register struct region *rp), ckr_free(char *cp);
HIDDEN void bmp_print(), bmp_free();
HIDDEN int tstm_render(struct application *ap, struct partition *pp, register struct shadework *swp, char *dp);
HIDDEN int star_render(register struct application *ap, register struct partition *pp, struct shadework *swp, char *dp);
HIDDEN int envmap_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, const struct mfuncs *mfp, struct rt_i *rtip, struct mfuncs **headp);
extern int mlib_zero(), mlib_one();
extern void mlib_void();


struct mfuncs txt_mfuncs[] = {
	{MF_MAGIC,	"texture",	0,		MFI_UV,		0,
	txt_setup,	txt_render,	txt_print,	txt_free },

	{MF_MAGIC,	"bwtexture",	0,		MFI_UV,		0,
	txt_setup,	bwtxt_render,	txt_print,	txt_free },

	{MF_MAGIC,	"checker",	0,		MFI_UV,		0,
	ckr_setup,	ckr_render,	ckr_print,	ckr_free },

	{MF_MAGIC,	"testmap",	0,		MFI_UV,		0,
	mlib_one,	tstm_render,	mlib_void,	mlib_void },

	{MF_MAGIC,	"fakestar",	0,		0,		0,
	mlib_one,	star_render,	mlib_void,	mlib_void },

	{MF_MAGIC,	"bump",		0,		MFI_UV|MFI_NORMAL, 0,
	txt_setup,	bmp_render,	txt_print,	txt_free },

	{MF_MAGIC,	"envmap",	0,		0,		0,
	envmap_setup,	mlib_zero,	mlib_void,	mlib_void },

	{0,		(char *)0,	0,		0,		0,
	0,		0,		0,		0 }
};

struct bu_structparse txt_parse[] = {
	{"%d",	1, "transp",	bu_offsetofarray(struct txt_specific, tx_transp),	txt_transp_hook },
	{"%S",	1, "file", TX_O(tx_name),		txt_source_hook },
	{"%S",	1, "obj", TX_O(tx_name),		txt_source_hook },
	{"%S",	1, "object", TX_O(tx_name),		txt_source_hook },
	{"%S",	1, "texture", TX_O(tx_name),	 BU_STRUCTPARSE_FUNC_NULL },
	{"%d",	1, "w",		TX_O(tx_w),		BU_STRUCTPARSE_FUNC_NULL },
	{"%d",	1, "n",		TX_O(tx_n),		BU_STRUCTPARSE_FUNC_NULL },
	{"%d",	1, "l",		TX_O(tx_n),		BU_STRUCTPARSE_FUNC_NULL }, /*compat*/
	{"%d",	1, "trans_valid",TX_O(tx_trans_valid),	BU_STRUCTPARSE_FUNC_NULL },
	{"%d",	1, "t",		TX_O(tx_trans_valid),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",  2, "uv",	TX_AO(tx_scale), 	BU_STRUCTPARSE_FUNC_NULL },
	{"%d",	1, "m",		TX_O(tx_mirror),	BU_STRUCTPARSE_FUNC_NULL },
	{"",	0, (char *)0,	0,			BU_STRUCTPARSE_FUNC_NULL }
};


/* txt_datasource_hook() is used to automatically try to load a default texture
 * datasource.  The type gets set to auto and the datasource is detected.  First
 * the database is searched for a matching object, then a file on disk is
 * looked up.  If neither is found, object name is left null so txt_setup() will
 * fail.
 */
HIDDEN void txt_source_hook(const struct bu_structparse *ip, const char *sp_name, genptr_t base, char *p) {
	struct txt_specific *textureSpecific = (struct txt_specific *)base;
	if (strncmp(sp_name, "file", 4)==0) {
		textureSpecific->tx_datasrc=TXT_SRC_FILE;
	}
	else if (strncmp(sp_name, "obj", 3)==0) {
		textureSpecific->tx_datasrc=TXT_SRC_OBJECT;
	}
	else {
		textureSpecific->tx_datasrc=TXT_SRC_AUTO;
	}
}


/*
 *			T X T _ T R A N S P _ H O O K
 *
 *  Hooked function, called by bu_structparse
 */
HIDDEN void
txt_transp_hook(struct bu_structparse *ptab, char *name, char *cp, char *value)
{
	register struct txt_specific *tp =
		(struct txt_specific *)cp;

	if (!strcmp(name, txt_parse[0].sp_name) && ptab == txt_parse) {
		tp->tx_trans_valid = 1;
	} else {
		bu_log("file:%s, line:%d txt_transp_hook name:(%s) instead of (%s)\n",
			__FILE__, __LINE__, name, txt_parse[0].sp_name);
	}
}


/*
 *	t x t _ l o a d _ d a t a s o u r c e
 *
 * This is a helper routine used in txt_setup() to load a texture either from
 * a file or from a db object.  The resources are released in txt_free() 
 * (there is no specific unload_datasource function).
 */
HIDDEN int txt_load_datasource(struct txt_specific *texture, struct db_i *dbInstance, const unsigned long int size) {
	struct directory *dirEntry;

	RT_CK_DBI(dbInstance);

	if (texture == (struct txt_specific *)NULL) {
		bu_bomb("ERROR: txt_load_datasource() received NULL arg (struct txt_specific *)\n");
	}

	bu_log("Loading texture %s [%S]...", texture->tx_datasrc==TXT_SRC_AUTO?"from auto-determined datasource":texture->tx_datasrc==TXT_SRC_OBJECT?"from a database object":texture->tx_datasrc==TXT_SRC_FILE?"from a file":"from an unknown source (ERROR)", &texture->tx_name);

	/* if the source is auto or object, we try to load the object */
	if ((texture->tx_datasrc==TXT_SRC_AUTO) || (texture->tx_datasrc==TXT_SRC_OBJECT)) {

		/* see if the object exists */
		if ( (dirEntry=db_lookup(dbInstance, bu_vls_addr(&texture->tx_name), LOOKUP_QUIET)) == DIR_NULL) {

			/* unable to find the texture object */
			if (texture->tx_datasrc!=TXT_SRC_AUTO) {
				return -1;
			}
		}
		else {
			struct rt_db_internal *dbip=(struct rt_db_internal *)bu_malloc(sizeof(struct rt_db_internal), "txt_load_datasource");

			RT_INIT_DB_INTERNAL(dbip);
			RT_CK_DB_INTERNAL(dbip);
			RT_CK_DIR(dirEntry);

			/* the object was in the directory, so go get it */
			if (rt_db_get_internal(dbip, dirEntry, dbInstance, NULL, NULL) <= 0) {
				/* unable to load/create the texture database record object */
				return -1;
			}

			RT_CK_DB_INTERNAL(dbip);
			RT_CK_BINUNIF(dbip->idb_ptr);

			/* keep the binary object pointer */
			texture->tx_binunifp=(struct rt_binunif_internal *)dbip->idb_ptr; /* make it so */

			/* release the database instance pointer struct we created */
			RT_INIT_DB_INTERNAL(dbip);
			bu_free(dbip, "txt_load_datasource");

			/* check size of object */
			if (texture->tx_binunifp->count < size) {
				bu_log("\nWARNING: %S needs %d bytes, binary object only has %d\n", texture->tx_name, size, texture->tx_binunifp->count);
			} else if (texture->tx_binunifp->count > size) {
				bu_log("\nWARNING: Binary object is larger than specified texture size\n\tBinary Object: %d pixels\n\tSpecified Texture Size: %d pixels\n...continuing to load using image subsection...", texture->tx_binunifp->count);
			}
		}
	}

	/* if we are auto and we couldn't find a database object match, or if source
	 * is explicitly a file then we load the file.
	 */
	if ( ( (texture->tx_datasrc==TXT_SRC_AUTO) && (texture->tx_binunifp==NULL) ) || (texture->tx_datasrc==TXT_SRC_FILE) ) {

		texture->tx_mp = bu_open_mapped_file_with_path(dbInstance->dbi_filepath,	bu_vls_addr(&texture->tx_name), NULL);
		
		if ( texture->tx_mp==NULL )
			return -1;				/* FAIL */

		if (texture->tx_mp->buflen < size) {
			bu_log("\nWARNING: %S needs %d bytes, file only has %d\n", &texture->tx_name, size, texture->tx_mp->buflen);
		} else if (texture->tx_mp->buflen > size) {
			bu_log("\nWARNING: Texture file size is larger than specified texture size\n\tInput File: %d pixels\n\tSpecified Texture Size: %d pixels\n...continuing to load using image subsection...", texture->tx_mp->buflen, size);
		}
		
	}

	bu_log("done.\n");

	return 0;
}


/*
 *  			T X T _ R E N D E R
 *  
 *  Given a u,v coordinate within the texture ( 0 <= u,v <= 1.0 ),
 *  return a pointer to the relevant pixel.
 *
 *  Note that .pix files are stored left-to-right, bottom-to-top,
 *  which works out very naturally for the indexing scheme.
 */
HIDDEN int
txt_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
{
	register struct txt_specific *tp =
		(struct txt_specific *)dp;
	fastf_t xmin, xmax, ymin, ymax;
	int dx, dy;
	register fastf_t r,g,b;
	struct uvcoord uvc;
	long tmp;

	RT_CK_AP(ap);
	RT_CHECK_PT(pp);

	uvc = swp->sw_uv;

	if (rdebug & RDEBUG_SHADE )
		bu_log( "in txt_render(): du=%g, dv=%g\n", 
			uvc.uv_du, uvc.uv_dv );

	/* take care of scaling U,V coordinates to get the desired amount
	 * of replication of the texture
	 */
	uvc.uv_u *= tp->tx_scale[X];
	tmp = uvc.uv_u;
	uvc.uv_u -= tmp;
	if (tp->tx_mirror && (tmp & 1) )
		uvc.uv_u = 1.0 - uvc.uv_u;

	uvc.uv_v *= tp->tx_scale[Y];
	tmp = uvc.uv_v;
	uvc.uv_v -= tmp;
	if (tp->tx_mirror && (tmp & 1) )
		uvc.uv_v = 1.0 - uvc.uv_v;

	uvc.uv_du /= tp->tx_scale[X];
	uvc.uv_dv /= tp->tx_scale[Y];

	/*
	 * If no texture file present, or if
	 * texture isn't and can't be read, give debug colors
	 */

	if ((bu_vls_strlen(&tp->tx_name)<=0) || (!tp->tx_mp && !tp->tx_binunifp)) {
		bu_log("WARNING: texture [%S] could not be read\n", &tp->tx_name);
		VSET( swp->sw_color, uvc.uv_u, 0, uvc.uv_v );
		if (swp->sw_reflect > 0 || swp->sw_transmit > 0 )
			(void)rr_render( ap, pp, swp );
		return(1);
	}

	/* u is left->right index, v is line number bottom->top */
	/* Don't filter more than 1/8 of the texture for 1 pixel! */
	if (uvc.uv_du > 0.125 )  uvc.uv_du = 0.125;
	if (uvc.uv_dv > 0.125 )  uvc.uv_dv = 0.125;

	if (uvc.uv_du < 0 || uvc.uv_dv < 0 )  {
		bu_log("txt_render uv=%g,%g, du dv=%g %g seg=%s\n",
			uvc.uv_u, uvc.uv_v, uvc.uv_du, uvc.uv_dv,
			pp->pt_inseg->seg_stp->st_name );
		uvc.uv_du = uvc.uv_dv = 0;
	}

	xmin = uvc.uv_u - uvc.uv_du;
	xmax = uvc.uv_u + uvc.uv_du;
	ymin = uvc.uv_v - uvc.uv_dv;
	ymax = uvc.uv_v + uvc.uv_dv;
	if (xmin < 0 )  xmin = 0;
	if (ymin < 0 )  ymin = 0;
	if (xmax > 1 )  xmax = 1;
	if (ymax > 1 )  ymax = 1;

	if (rdebug & RDEBUG_SHADE )
		bu_log( "footprint in texture space is (%g %g) <-> (%g %g)\n",
			xmin * (tp->tx_w-1), ymin * (tp->tx_n-1),
			xmax * (tp->tx_w-1), ymax * (tp->tx_n-1) );
			
#if 1
	dx = (int)(xmax * (tp->tx_w-1)) - (int)(xmin * (tp->tx_w-1));
	dy = (int)(ymax * (tp->tx_n-1)) - (int)(ymin * (tp->tx_n-1));

	if (rdebug & RDEBUG_SHADE )
		bu_log( "\tdx = %d, dy = %d\n", dx, dy );

	if (dx == 0 && dy == 0 )
	{
		/* No averaging necessary */

		register unsigned char *cp=NULL;

		if (tp->tx_mp) {
			cp = ((unsigned char *)(tp->tx_mp->buf)) +
				(int)(ymin * (tp->tx_n-1)) * tp->tx_w * 3 +
				(int)(xmin * (tp->tx_w-1)) * 3;
		}
		else if (tp->tx_binunifp) {
			cp = ((unsigned char *)(tp->tx_binunifp->u.uint8)) +
				(int)(ymin * (tp->tx_n-1)) * tp->tx_w * 3 +
				(int)(xmin * (tp->tx_w-1)) * 3;
		}
		else {
			bu_bomb("sh_text.c -- No texture data found\n");
		}
		r = *cp++;
		g = *cp++;
		b = *cp;
	}
	else
	{
		/* Calculate weighted average of cells in footprint */

		fastf_t tot_area=0.0;
		fastf_t cell_area;
		int start_line, stop_line, line;
		int start_col, stop_col, col;
		fastf_t xstart, xstop, ystart, ystop;

		xstart = xmin * (tp->tx_w-1);
		xstop = xmax * (tp->tx_w-1);
		ystart = ymin * (tp->tx_n-1);
		ystop = ymax * (tp->tx_n-1);

		start_line = ystart;
		stop_line = ystop;
		start_col = xstart;
		stop_col = xstop;

		r = g = b = 0.0;

		if (rdebug & RDEBUG_SHADE ) {
			bu_log( "\thit in texture space = (%g %g)\n", uvc.uv_u * (tp->tx_w-1), uvc.uv_v * (tp->tx_n-1) );
			bu_log( "\t averaging from  (%g %g) to (%g %g)\n", xstart, ystart, xstop, ystop );
			bu_log( "\tcontributions to average:\n" );
		}

		for( line = start_line ; line <= stop_line ; line++ ) {
			register unsigned char *cp=NULL;
			fastf_t line_factor;
			fastf_t line_upper, line_lower;

			line_upper = line + 1.0;
			if (line_upper > ystop )
				line_upper = ystop;
			line_lower = line;
			if (line_lower < ystart )
				line_lower = ystart;
			line_factor = line_upper - line_lower;

			if (tp->tx_mp) {
				cp = ((unsigned char *)(tp->tx_mp->buf)) +
					line * tp->tx_w * 3 + (int)(xstart) * 3;
			}
			else if (tp->tx_binunifp) {
				cp = ((unsigned char *)(tp->tx_binunifp->u.uint8)) +
					line * tp->tx_w * 3 + (int)(xstart) * 3;
			}
			else {
				/* not reachable */
				bu_bomb("sh_text.c -- Unable to read datasource\n");
			}

			for( col = start_col ; col <= stop_col ; col++ ) {
				fastf_t col_upper, col_lower;

				col_upper = col + 1.0;
				if (col_upper > xstop )	col_upper = xstop;
				col_lower = col;
				if (col_lower < xstart ) col_lower = xstart;

				cell_area = line_factor * (col_upper - col_lower);
				tot_area += cell_area;

				if (rdebug & RDEBUG_SHADE )
					bu_log( "\t %d %d %d weight=%g (from col=%d line=%d)\n", *cp, *(cp+1), *(cp+2), cell_area, col, line );

				r += (*cp++) * cell_area;
				g += (*cp++) * cell_area;
				b += (*cp++) * cell_area;
			}

		}
		r /= tot_area;
		g /= tot_area;
		b /= tot_area;
	}
	
	if (rdebug & RDEBUG_SHADE )
		bu_log( " average: %g %g %g\n", r, g, b );
#else

	x = xmin * (tp->tx_w-1);
	y = ymin * (tp->tx_n-1);
	dx = (xmax - xmin) * (tp->tx_w-1);
	dy = (ymax - ymin) * (tp->tx_n-1);
	if (dx < 1 )  dx = 1;
	if (dy < 1 )  dy = 1;

	if (rdebug & RDEBUG_SHADE )
		bu_log(" in txt_render(): x=%d y=%d, dx=%d, dy=%d\n", x, y, dx, dy);

	r = g = b = 0;
	for( line=0; line<dy; line++ )  {
		register unsigned char *cp;
		register unsigned char *ep;

		if (tp->tx_mp) {
			cp = ((unsigned char *)(tp->tx_mp->buf)) +
				(y+line) * tp->tx_w * 3  +  x * 3;
		}
		else if (tp->tx_binunifp) {
			cp = ((unsigned char *)(tp->tx_binunifp->u.unit8)) +
				(y+line) * tp->tx_w * 3  +  x * 3;
		}
		else {
			/* not reachable */
			bu_bomb("sh_text.c -- Unable to read datasource\n");
		}
		
		ep = cp + 3*dx;
		while( cp < ep )  {
			if (rdebug & RDEBUG_SHADE )
				bu_log( "\tAdding %d %d %d\n", *cp, *(cp+1), *(cp+2) );
			r += *cp++;
			g += *cp++;
			b += *cp++;
		}
	}
	if (rdebug & RDEBUG_SHADE )
		bu_log( "Totals: %d %d %d,", r, g, b );
	r /= (dx*dy);
	g /= (dx*dy);
	b /= (dx*dy);
	if (rdebug & RDEBUG_SHADE )
		bu_log( " average: %d %d %d\n", r, g, b );
#endif

	if (!tp->tx_trans_valid) {
opaque:
		VSET( swp->sw_color,
			r * bn_inv255,
			g * bn_inv255,
			b * bn_inv255 );

		if (swp->sw_reflect > 0 || swp->sw_transmit > 0 )
			(void)rr_render( ap, pp, swp );
		return(1);
	}
	/* This circumlocution needed to keep expression simple for Cray,
	 * and others
	 */
	if (r != ((long)tp->tx_transp[0]) )  goto opaque;
	if (g != ((long)tp->tx_transp[1]) )  goto opaque;
	if (b != ((long)tp->tx_transp[2]) )  goto opaque;

	/*
	 *  Transparency mapping is enabled, and we hit a transparent spot.
	 *  Let higher level handle it in reflect/refract code.
	 */
	swp->sw_transmit = 1.0;
	swp->sw_reflect = 0.0;

	bu_log("leaving txt_render()\n");

	if (swp->sw_reflect > 0 || swp->sw_transmit > 0 )
		(void)rr_render( ap, pp, swp );
	return(1);
}

/*
 *  			B W T X T _ R E N D E R
 *  
 *  Given a u,v coordinate within the texture ( 0 <= u,v <= 1.0 ),
 *  return the filtered intensity.
 *
 *  Note that .bw files are stored left-to-right, bottom-to-top,
 *  which works out very naturally for the indexing scheme.
 */
HIDDEN int
bwtxt_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
{
	register struct txt_specific *tp =
		(struct txt_specific *)dp;
	fastf_t xmin, xmax, ymin, ymax;
	int line;
	int dx, dy;
	int x,y;
	register long bw;
	struct uvcoord uvc;
	long tmp;

	uvc = swp->sw_uv;
 
	/*
	 * If no texture file present, or if
	 * texture isn't and can't be read, give debug colors
	 */
	if ((bu_vls_strlen(&tp->tx_name)<=0) || (!tp->tx_mp && !tp->tx_binunifp) )  {
		VSET( swp->sw_color, uvc.uv_u, 0, uvc.uv_v );
		if (swp->sw_reflect > 0 || swp->sw_transmit > 0 )
			(void)rr_render( ap, pp, swp );
		return(1);
	}

	/* take care of scaling U,V coordinates to get the desired amount
	 * of replication of the texture
	 */
	uvc.uv_u *= tp->tx_scale[X];
	tmp = uvc.uv_u;
	uvc.uv_u -= tmp;
	if (tp->tx_mirror && (tmp & 1) )
		uvc.uv_u = 1.0 - uvc.uv_u;

	uvc.uv_v *= tp->tx_scale[Y];
	tmp = uvc.uv_v;
	uvc.uv_v -= tmp;
	if (tp->tx_mirror && (tmp & 1) )
		uvc.uv_v = 1.0 - uvc.uv_v;

	uvc.uv_du /= tp->tx_scale[X];
	uvc.uv_dv /= tp->tx_scale[Y];


	/* u is left->right index, v is line number bottom->top */
	/* Don't filter more than 1/8 of the texture for 1 pixel! */
	if (uvc.uv_du > 0.125 )  uvc.uv_du = 0.125;
	if (uvc.uv_dv > 0.125 )  uvc.uv_dv = 0.125;

	if (uvc.uv_du < 0 || uvc.uv_dv < 0 )  {
		bu_log("bwtxt_render uv=%g,%g, du dv=%g %g seg=%s\n",
			uvc.uv_u, uvc.uv_v, uvc.uv_du, uvc.uv_dv,
			pp->pt_inseg->seg_stp->st_name );
		uvc.uv_du = uvc.uv_dv = 0;
	}
	xmin = uvc.uv_u - uvc.uv_du;
	xmax = uvc.uv_u + uvc.uv_du;
	ymin = uvc.uv_v - uvc.uv_dv;
	ymax = uvc.uv_v + uvc.uv_dv;
	if (xmin < 0 )  xmin = 0;
	if (ymin < 0 )  ymin = 0;
	if (xmax > 1 )  xmax = 1;
	if (ymax > 1 )  ymax = 1;
	x = xmin * (tp->tx_w-1);
	y = ymin * (tp->tx_n-1);
	dx = (xmax - xmin) * (tp->tx_w-1);
	dy = (ymax - ymin) * (tp->tx_n-1);
	if (dx < 1 )  dx = 1;
	if (dy < 1 )  dy = 1;
	bw = 0;
	for( line=0; line<dy; line++ )  {
		register unsigned char *cp=NULL;
		register unsigned char *ep;
		
		if (tp->tx_mp) {
			cp = ((unsigned char *)(tp->tx_mp->buf)) +
				(y+line) * tp->tx_w  +  x;
		}
		else if (tp->tx_binunifp) {
			cp = ((unsigned char *)(tp->tx_binunifp->u.uint8)) +
				(y+line) * tp->tx_w  +  x;
		}
		else {
			/* not reachable */
			bu_bomb("sh_text.c -- Unable to read datasource\n");
		}

		ep = cp + dx;
		while( cp < ep )  {
			bw += *cp++;
		}
	}

	if (!tp->tx_trans_valid) {
opaque:
		VSETALL( swp->sw_color,
			bw * bn_inv255 / (dx*dy) );
		if (swp->sw_reflect > 0 || swp->sw_transmit > 0 )
			(void)rr_render( ap, pp, swp );
		return(1);
	}
	/* This circumlocution needed to keep expression simple for Cray,
	 * and others
	 */
	if (bw / (dx*dy) != ((long)tp->tx_transp[0]) )  goto opaque;

	/*
	 *  Transparency mapping is enabled, and we hit a transparent spot.
	 *  Let higher level handle it in reflect/refract code.
	 */
	swp->sw_transmit = 1.0;
	swp->sw_reflect = 0.0;
	if (swp->sw_reflect > 0 || swp->sw_transmit > 0 )
		(void)rr_render( ap, pp, swp );
	return(1);
}

/*
 *			T X T _ S E T U P
 */
HIDDEN int 
txt_setup( register struct region *rp, struct bu_vls *matparm, char **dpp, const struct mfuncs *mfp, struct rt_i *rtip ) {
	register struct txt_specific *tp;
	int		pixelbytes = 3;

	BU_CK_VLS( matparm );
	BU_GETSTRUCT( tp, txt_specific );
	*dpp = (char *)tp;

	bu_vls_init(&tp->tx_name);
	/* !?!	tp->tx_name[0] = '\0';*/

	/* defaults */
	tp->tx_w = tp->tx_n = -1;
	tp->tx_trans_valid = 0;
	tp->tx_scale[X] = 1.0;
	tp->tx_scale[Y] = 1.0;
	tp->tx_mirror = 0;
	tp->tx_datasrc = 0; /* source is auto-located by default */
	tp->tx_binunifp = NULL;
	tp->tx_mp = NULL;

	/* load given values */
	if (bu_struct_parse( matparm, txt_parse, (char *)tp ) < 0 )  {
		bu_free( (char *)tp, "txt_specific" );
		return(-1);
	}

	/* validate values */
	if (tp->tx_w < 0 ) tp->tx_w = 512;
	if (tp->tx_n < 0 ) tp->tx_n = tp->tx_w;
	if (tp->tx_trans_valid ) rp->reg_transmit = 1;
	BU_CK_VLS(&tp->tx_name);
	if (bu_vls_strlen(&tp->tx_name)<=0) return -1; 
	/*	!?! if (tp->tx_name[0] == '\0' )  return -1;	*//* FAIL, no file */

	if (strcmp( mfp->mf_name, "bwtexture" ) == 0 ) pixelbytes = 1;

	/* load the texture from its datasource */
	if (txt_load_datasource(tp, rtip->rti_dbip, tp->tx_w * tp->tx_n * pixelbytes)<0) {
		bu_log("\nERROR: txt_setup() %s %s could not be loaded [source was %s]\n", rp->reg_name, bu_vls_addr(&tp->tx_name), tp->tx_datasrc==TXT_SRC_OBJECT?"object":tp->tx_datasrc==TXT_SRC_FILE?"file":"auto");
		return -1;
	}


	if (rdebug & RDEBUG_SHADE ) {
		bu_log("txt_setup: texture loaded!  type=%s name=%s\n", tp->tx_datasrc==TXT_SRC_AUTO?"auto":tp->tx_datasrc==TXT_SRC_OBJECT?"object":tp->tx_datasrc==TXT_SRC_FILE?"file":"unknown", bu_vls_addr(&tp->tx_name));
		bu_struct_print("texture", txt_parse, (char *)tp);
	}

	return 1;				/* OK */
}

/*
 *			T X T _ P R I N T
 */
HIDDEN void
txt_print(register struct region *rp)
{
	bu_struct_print(rp->reg_name, txt_parse, (char *)rp->reg_udata);
}

/*
 *			T X T _ F R E E
 */
HIDDEN void
txt_free(char *cp)
{
	struct txt_specific *tp =	(struct txt_specific *)cp;

	bu_vls_free(&tp->tx_name);
	if (tp->tx_binunifp) rt_binunif_free( tp->tx_binunifp );
	if (tp->tx_mp) bu_close_mapped_file( tp->tx_mp );
	tp->tx_binunifp = GENPTR_NULL; /* sanity */
	tp->tx_mp = GENPTR_NULL; /* sanity */
	bu_free( cp, "txt_specific" );
}

struct ckr_specific  {
	int	ckr_a[3];	/* first RGB */
	int	ckr_b[3];	/* second RGB */
	double	ckr_scale;
};
#define CKR_NULL	((struct ckr_specific *)0)
#define CKR_O(m)	offsetof(struct ckr_specific, m)

struct bu_structparse ckr_parse[] = {
	{"%d",	3, "a",	bu_offsetofarray(struct ckr_specific, ckr_a), BU_STRUCTPARSE_FUNC_NULL },
	{"%d",	3, "b",	bu_offsetofarray(struct ckr_specific, ckr_b), BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "s", offsetof(struct ckr_specific, ckr_scale), BU_STRUCTPARSE_FUNC_NULL },
	{"",	0, (char *)0,	0,			BU_STRUCTPARSE_FUNC_NULL }
};

/*
 *			C K R _ R E N D E R
 */
HIDDEN int
ckr_render(struct application *ap, struct partition *pp, register struct shadework *swp, char *dp)
{
	register struct ckr_specific *ckp =
		(struct ckr_specific *)dp;
	register int *cp;
	int u, v;

	u = swp->sw_uv.uv_u * ckp->ckr_scale;
	v = swp->sw_uv.uv_v * ckp->ckr_scale;

	if ( ((u&1) && (v&1)) || (!(u&1) && !(v&1)) ) {
		cp = ckp->ckr_a;
	} else {
		cp = ckp->ckr_b;
	}

#if 0
	if ((swp->sw_uv.uv_u < 0.5 && swp->sw_uv.uv_v < 0.5) ||
	    (swp->sw_uv.uv_u >=0.5 && swp->sw_uv.uv_v >=0.5) )  {
		cp = ckp->ckr_a;
	} else {
		cp = ckp->ckr_b;
	}
#endif

	VSET( swp->sw_color,
		(unsigned char)cp[0] * bn_inv255,
		(unsigned char)cp[1] * bn_inv255,
		(unsigned char)cp[2] * bn_inv255 );

	if (swp->sw_reflect > 0 || swp->sw_transmit > 0 )
		(void)rr_render( ap, pp, swp );

	return(1);
}

/*
 *			C K R _ S E T U P
 */
HIDDEN int
ckr_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip)
                      	     
             		         
    			      
                             
                                /* New since 4.4 release */
{
	register struct ckr_specific *ckp;

	/* Default will be white and black checkers */
	BU_GETSTRUCT( ckp, ckr_specific );
	*dpp = (char *)ckp;
	ckp->ckr_a[0] = ckp->ckr_a[1] = ckp->ckr_a[2] = 255;
	ckp->ckr_b[0] = ckp->ckr_b[1] = ckp->ckr_b[2] = 0;
	ckp->ckr_scale = 2.0;
	if (bu_struct_parse( matparm, ckr_parse, (char *)ckp ) < 0 )  {
		bu_free( (char *)ckp, "ckr_specific" );
		return(-1);
	}
	ckp->ckr_a[0] &= 0x0ff;
	ckp->ckr_a[1] &= 0x0ff;
	ckp->ckr_a[2] &= 0x0ff;
	ckp->ckr_b[0] &= 0x0ff;
	ckp->ckr_b[1] &= 0x0ff;
	ckp->ckr_b[2] &= 0x0ff;
	return(1);
}

/*
 *			C K R _ P R I N T
 */
HIDDEN void
ckr_print(register struct region *rp)
{
	bu_struct_print(rp->reg_name, ckr_parse, rp->reg_udata);
}

/*
 *			C K R _ F R E E
 */
HIDDEN void
ckr_free(char *cp)
{
	bu_free( cp, "ckr_specific" );
}

/*
 *			T S T M _ R E N D E R
 *
 *  Render a map which varries red with U and blue with V values.
 *  Mostly useful for debugging ft_uv() routines.
 */
HIDDEN int
tstm_render(struct application *ap, struct partition *pp, register struct shadework *swp, char *dp)
{
	VSET( swp->sw_color, swp->sw_uv.uv_u, 0, swp->sw_uv.uv_v );

	if (swp->sw_reflect > 0 || swp->sw_transmit > 0 )
		(void)rr_render( ap, pp, swp );

	return(1);
}

static vect_t star_colors[] = {
	{ 0.825769, 0.415579, 0.125303 },	/* 3000 */
	{ 0.671567, 0.460987, 0.258868 },
	{ 0.587580, 0.480149, 0.376395 },
	{ 0.535104, 0.488881, 0.475879 },
	{ 0.497639, 0.493881, 0.556825 },
	{ 0.474349, 0.494836, 0.624460 },
	{ 0.456978, 0.495116, 0.678378 },
	{ 0.446728, 0.493157, 0.727269 },	/* 10000 */
	{ 0.446728, 0.493157, 0.727269 },	/* fake 11000 */
#if 0
	{ 0.446728, 0.493157, 0.727269 },	/* fake 12000 */
	{ 0.446728, 0.493157, 0.727269 },	/* fake 13000 */
	{ 0.446728, 0.493157, 0.727269 },	/* fake 14000 */
	{ 0.446728, 0.493157, 0.727269 },	/* fake 15000 */
	{ 0.393433 0.488079 0.940423 }		/* 20000 */
#endif
};

/*
 *			S T A R _ R E N D E R
 */
HIDDEN int
star_render(register struct application *ap, register struct partition *pp, struct shadework *swp, char *dp)
{
	/* Probably want to diddle parameters based on what part of sky */
	if (bn_rand0to1(ap->a_resource->re_randptr) >= 0.98 )  {
		register int i;
		FAST fastf_t f;
		i = (sizeof(star_colors)-1) / sizeof(star_colors[0]);

		/* "f" used for intermediate result to avoid an SGI compiler error */
		f = bn_rand0to1(ap->a_resource->re_randptr);
		i = ((double)i) * f;

		f = bn_rand0to1(ap->a_resource->re_randptr);
		VSCALE( swp->sw_color, star_colors[i], f );
	} else {
		VSETALL( swp->sw_color, 0 );
	}

	if (swp->sw_reflect > 0 || swp->sw_transmit > 0 )
		(void)rr_render( ap, pp, swp );

	return(1);
}

/*
 *  			B M P _ R E N D E R
 *  
 *  Given a u,v coordinate within the texture ( 0 <= u,v <= 1.0 ),
 *  compute a new surface normal.
 *  For now we come up with a local coordinate system, and
 *  make bump perturbations from the red and blue channels of
 *  an RGB image.
 *
 *  Note that .pix files are stored left-to-right, bottom-to-top,
 *  which works out very naturally for the indexing scheme.
 */
HIDDEN int
bmp_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
{
	register struct txt_specific *tp =
		(struct txt_specific *)dp;
	unsigned char *cp=NULL;
	fastf_t	pertU, pertV;
	vect_t	y;		/* world coordinate axis vectors */
	vect_t	u, v;		/* surface coord system vectors */
	int	i, j;		/* bump map pixel indicies */

	/*
	 * If no texture file present, or if
	 * texture isn't and can't be read, give debug color.
	 */
	if ( (bu_vls_strlen(&tp->tx_name)<=0) || (!tp->tx_mp && !tp->tx_binunifp) )  {
		VSET( swp->sw_color, swp->sw_uv.uv_u, 0, swp->sw_uv.uv_v );
		if (swp->sw_reflect > 0 || swp->sw_transmit > 0 )
			(void)rr_render( ap, pp, swp );
		return(1);
	}
	/* u is left->right index, v is line number bottom->top */
	if (swp->sw_uv.uv_u < 0 || swp->sw_uv.uv_u > 1 || swp->sw_uv.uv_v < 0 || swp->sw_uv.uv_v > 1 )  {
		bu_log("bmp_render:  bad u,v=%g,%g du,dv=%g,%g seg=%s\n",
			swp->sw_uv.uv_u, swp->sw_uv.uv_v,
			swp->sw_uv.uv_du, swp->sw_uv.uv_dv,
			pp->pt_inseg->seg_stp->st_name );
		VSET( swp->sw_color, 0, 1, 0 );
		if (swp->sw_reflect > 0 || swp->sw_transmit > 0 )
			(void)rr_render( ap, pp, swp );
		return(1);
	}

	/* Find a local coordinate system */
	VSET( y, 0, 1, 0 );
	VCROSS( u, y, swp->sw_hit.hit_normal );
	VUNITIZE( u );
	VCROSS( v, swp->sw_hit.hit_normal, u );

	/* Find our RGB value */
	i = swp->sw_uv.uv_u * (tp->tx_w-1);
	j = swp->sw_uv.uv_v * (tp->tx_n-1);

	if (tp->tx_mp) {
		cp = ((unsigned char *)(tp->tx_mp->buf)) +
			(j) * tp->tx_w * 3  +  i * 3;
	}
	else if (tp->tx_binunifp) {
		cp = ((unsigned char *)(tp->tx_binunifp->u.uint8)) +
			(j) * tp->tx_w * 3  +  i * 3;
	}
	else {
		/* not reachable */
		bu_bomb("sh_text.c -- Unreachable code reached while reading datasource\n");
	}
	pertU = ((fastf_t)(*cp) - 128.0) / 128.0;
	pertV = ((fastf_t)(*(cp+2)) - 128.0) / 128.0;

	if (rdebug&RDEBUG_LIGHT ) {
		VPRINT("normal", swp->sw_hit.hit_normal);
		VPRINT("u", u );
		VPRINT("v", v );
		bu_log("cu = %d, cv = %d\n", *cp, *(cp+2));
		bu_log("pertU = %g, pertV = %g\n", pertU, pertV);
	}
	VJOIN2( swp->sw_hit.hit_normal, swp->sw_hit.hit_normal, pertU, u, pertV, v );
	VUNITIZE( swp->sw_hit.hit_normal );
	if (rdebug&RDEBUG_LIGHT ) {
		VPRINT("after", swp->sw_hit.hit_normal);
	}

	if (swp->sw_reflect > 0 || swp->sw_transmit > 0 )
		(void)rr_render( ap, pp, swp );

	return(1);
}

/*
 *			E N V M A P _ S E T U P
 */
HIDDEN int
envmap_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, const struct mfuncs *mfp, struct rt_i *rtip, struct mfuncs **headp)
{

	BU_CK_VLS( matparm );
	RT_CK_RTI(rtip);
	if (env_region.reg_mfuncs )  {
		bu_log("envmap_setup:  second environment map ignored\n");
		return(0);		/* drop region */
	}
	env_region = *rp;		/* struct copy */
	/* Get copies of, or eliminate, references to dynamic structures */
	env_region.reg_name = bu_strdup( rp->reg_name );
	env_region.reg_treetop = TREE_NULL;
	env_region.l.forw = BU_LIST_NULL;
	env_region.l.back = BU_LIST_NULL;
	env_region.reg_mfuncs = (char *)0;

	env_region.reg_mater.ma_shader = bu_vls_strdup( matparm );

	if (mlib_setup( headp, &env_region, rtip ) < 0 )
		bu_log("envmap_setup() material '%s' failed\n", env_region.reg_mater );

	return(0);		/* This region should be dropped */
}



/*
 *			M L I B _ Z E R O
 *
 *  Regardless of arguments, always return zero.
 *  Useful mostly as a stub print, and/or free routine.
 */
/* VARARGS */
int
mlib_zero()
{
	return(0);
}

/*
 *			M L I B _ O N E
 *
 *  Regardless of arguments, always return one.
 *  Useful mostly as a stub setup routine.
 */
/* VARARGS */
int
mlib_one()
{
	return(1);
}

/*
 *			M L I B _ V O I D
 */
/* VARARGS */
void
mlib_void()
{
}
@


11.52
log
@change conf.h to a wrapped config.h
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/liboptical/sh_text.c,v 11.51 2004/04/05 07:43:37 morrison Exp $ (ARL)";
@


11.51
log
@merge of ansi-6-0-branch into HEAD
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d26 5
a30 1
#include "conf.h"
@


11.50
log
@update copyright to include span through 2003
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_text.c,v 11.49 2003/09/27 01:05:10 morrison Exp $ (ARL)";
d41 21
d69 17
a85 14
HIDDEN void	txt_transp_hook();
HIDDEN void txt_source_hook();
HIDDEN int txt_load_datasource();
HIDDEN int	bwtxt_render();
HIDDEN int	txt_setup(), txt_render();
HIDDEN int	ckr_setup(), ckr_render();
HIDDEN int	bmp_setup(), bmp_render();
HIDDEN void	bwtxtprint(), bwtxtfree();
HIDDEN void	txt_print(), txt_free();
HIDDEN void	ckr_print(), ckr_free();
HIDDEN void	bmp_print(), bmp_free();
HIDDEN int tstm_render();
HIDDEN int star_render();
HIDDEN int envmap_setup();
a112 22
#define TXT_NAME_LEN 128
struct txt_specific {
	int	tx_transp[3];	/* RGB for transparency */
	/*	char	tx_file[TXT_NAME_LEN];	 Filename */
	struct bu_vls tx_name;  /* name of object or file (depending on tx_datasrc flag) */
	int	tx_w;		/* Width of texture in pixels */
	int	tx_n;		/* Number of scanlines */
	int	tx_trans_valid;	/* boolean: is tx_transp valid ? */
	fastf_t	tx_scale[2];	/* replication factors in U, V */
	int	tx_mirror;	/* flag: repetitions are mirrored */
#define TXT_SRC_FILE 'f'
#define TXT_SRC_OBJECT  'o'
#define TXT_SRC_AUTO 0
	char tx_datasrc; /* which type of datasource */
	struct rt_binunif_internal *tx_binunifp;  /* db internal object when TXT_SRC_OBJECT */
	struct bu_mapped_file	*tx_mp;    /* mapped file when TXT_SRC_FILE */
};
#define TX_NULL	((struct txt_specific *)0)
#define TX_O(m)	offsetof(struct txt_specific, m)
#define TX_AO(m)	bu_offsetofarray(struct txt_specific, m)


d156 1
a156 5
txt_transp_hook( ptab, name, cp, value )
struct bu_structparse *ptab;
char	*name;
char	*cp;
char	*value;
d265 1
a265 5
txt_render( ap, pp, swp, dp )
struct application	*ap;
struct partition	*pp;
struct shadework	*swp;
char	*dp;
d542 1
a542 5
bwtxt_render( ap, pp, swp, dp )
struct application	*ap;
struct partition	*pp;
struct shadework	*swp;
char	*dp;
d719 1
a719 2
txt_print( rp )
register struct region *rp;
d728 1
a728 2
txt_free( cp )
char *cp;
d759 1
a759 5
ckr_render( ap, pp, swp, dp )
struct application	*ap;
struct partition	*pp;
register struct shadework	*swp;
char	*dp;
d799 6
a804 6
ckr_setup( rp, matparm, dpp, mfp, rtip )
register struct region	 *rp;
struct bu_vls		*matparm;
char			**dpp;
struct mfuncs           *mfp;
struct rt_i             *rtip;  /* New since 4.4 release */
d831 1
a831 2
ckr_print( rp )
register struct region *rp;
d840 1
a840 2
ckr_free( cp )
char *cp;
d852 1
a852 5
tstm_render( ap, pp, swp, dp )
struct application	*ap;
struct partition	*pp;
register struct shadework	*swp;
char	*dp;
d885 1
a885 5
star_render( ap, pp, swp, dp )
register struct application *ap;
register struct partition *pp;
struct shadework	*swp;
char	*dp;
d922 1
a922 5
bmp_render( ap, pp, swp, dp )
struct application	*ap;
struct partition	*pp;
struct shadework	*swp;
char	*dp;
d1002 1
a1002 7
envmap_setup( rp, matparm, dpp, mfp, rtip, headp )
register struct region *rp;
struct bu_vls *matparm;
char	**dpp;
const struct mfuncs	*mfp;
struct rt_i	*rtip;
struct mfuncs	**headp;
@


11.49
log
@mlib stub functions moved from rt back-end and are no longer extern; use the r_debug define
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1998 by the United States Army
d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_text.c,v 11.48 2002/12/04 01:14:37 morrison Exp $ (ARL)";
@


11.49.2.1
log
@merge from HEAD
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1998-2004 by the United States Army
d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_text.c,v 11.50 2004/02/02 17:39:14 morrison Exp $ (ARL)";
@


11.49.2.2
log
@merge from head
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_text.c,v 11.49.2.1 2004/02/12 18:38:49 erikg Exp $ (ARL)";
@


11.48
log
@cleaned up warning messages and error conditions
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_text.c,v 11.47 2002/12/03 20:01:08 morrison Exp $ (ARL)";
d41 2
a45 1
extern struct region	env_region;		/* import from view.c */
a61 2
extern int mlib_zero(), mlib_one();
extern void	mlib_void();
d1061 37
@


11.47
log
@fixed invalid pointer reference in log message
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_text.c,v 11.46 2002/08/22 20:30:48 morrison Exp $ (ARL)";
d116 1
d218 1
d221 3
a223 2
			/* !!! need to release the "struct rt_db_internal" but NOT free the binunif */
			rt_db_free_internal( dbip, (struct resource *)NULL );
d227 1
a227 1
				bu_log("\nWARNING: %S needs %d bytes, '%s' only has %d\n", texture->tx_name, size, texture->tx_binunifp->count);
d713 1
a713 1
		bu_log("\ntxt_setup() ERROR %s %s could not be loaded [source was %s]\n", rp->reg_name, bu_vls_addr(&tp->tx_name), tp->tx_datasrc==TXT_SRC_OBJECT?"object":tp->tx_datasrc==TXT_SRC_FILE?"file":"auto");
@


11.46
log
@fixed bug in an error handler that caused a crash due to trying to %s print a vls string when a texture could not be loaded properly
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_text.c,v 11.45 2002/08/20 17:07:52 jra Exp $ (ARL)";
d224 1
a224 1
				bu_log("\ntxt_load_datasource() WARNING %S needs %d bytes, '%s' only has %d\n", texture->tx_name, size, texture->tx_binunifp->count);
d242 1
a242 2
			bu_log("\ntxt_load_datasource() ERROR %S needs %d bytes, file only has %d\n", texture->tx_name, size, texture->tx_mp->buflen);
			return -1;
@


11.46.4.1
log
@sync to HEAD...
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1998-2004 by the United States Army
d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/liboptical/sh_text.c,v 11.50 2004/02/02 17:39:14 morrison Exp $ (ARL)";
a40 2
struct region	env_region;  /* initialized in the app code view handler */

d44 1
d61 2
a115 1
	{"%S",	1, "object", TX_O(tx_name),		txt_source_hook },
a216 1
			/* keep the binary object pointer */
d219 2
a220 3
			/* release the database instance pointer struct we created */
			RT_INIT_DB_INTERNAL(dbip);
			bu_free(dbip, "txt_load_datasource");
d224 1
a224 1
				bu_log("\nWARNING: %S needs %d bytes, binary object only has %d\n", texture->tx_name, size, texture->tx_binunifp->count);
d242 2
a243 1
			bu_log("\nWARNING: %S needs %d bytes, file only has %d\n", &texture->tx_name, size, texture->tx_mp->buflen);
d711 1
a711 1
		bu_log("\nERROR: txt_setup() %s %s could not be loaded [source was %s]\n", rp->reg_name, bu_vls_addr(&tp->tx_name), tp->tx_datasrc==TXT_SRC_OBJECT?"object":tp->tx_datasrc==TXT_SRC_FILE?"file":"auto");
a1059 37
}



/*
 *			M L I B _ Z E R O
 *
 *  Regardless of arguments, always return zero.
 *  Useful mostly as a stub print, and/or free routine.
 */
/* VARARGS */
int
mlib_zero()
{
	return(0);
}

/*
 *			M L I B _ O N E
 *
 *  Regardless of arguments, always return one.
 *  Useful mostly as a stub setup routine.
 */
/* VARARGS */
int
mlib_one()
{
	return(1);
}

/*
 *			M L I B _ V O I D
 */
/* VARARGS */
void
mlib_void()
{
@


11.46.2.1
log
@Initial ANSIfication
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_text.c,v 11.46 2002/08/22 20:30:48 morrison Exp $ (ARL)";
a40 24
#define TXT_NAME_LEN 128
struct txt_specific {
	int	tx_transp[3];	/* RGB for transparency */
	/*	char	tx_file[TXT_NAME_LEN];	 Filename */
	struct bu_vls tx_name;  /* name of object or file (depending on tx_datasrc flag) */
	int	tx_w;		/* Width of texture in pixels */
	int	tx_n;		/* Number of scanlines */
	int	tx_trans_valid;	/* boolean: is tx_transp valid ? */
	fastf_t	tx_scale[2];	/* replication factors in U, V */
	int	tx_mirror;	/* flag: repetitions are mirrored */
#define TXT_SRC_FILE 'f'
#define TXT_SRC_OBJECT  'o'
#define TXT_SRC_AUTO 0
	char tx_datasrc; /* which type of datasource */
	struct rt_binunif_internal *tx_binunifp;  /* db internal object when TXT_SRC_OBJECT */
	struct bu_mapped_file	*tx_mp;    /* mapped file when TXT_SRC_FILE */
};
#define TX_NULL	((struct txt_specific *)0)
#define TX_O(m)	offsetof(struct txt_specific, m)
#define TX_AO(m)	bu_offsetofarray(struct txt_specific, m)




d47 7
a53 7
HIDDEN void	txt_transp_hook(struct bu_structparse *ptab, char *name, char *cp, char *value);
HIDDEN void txt_source_hook(const struct bu_structparse *ip, const char *sp_name, genptr_t base, char *p);
HIDDEN int txt_load_datasource(struct txt_specific *texture, struct db_i *dbInstance, const long unsigned int size);
HIDDEN int	bwtxt_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
HIDDEN int	txt_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, const struct mfuncs *mfp, struct rt_i *rtip), txt_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
HIDDEN int	ckr_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip), ckr_render(struct application *ap, struct partition *pp, register struct shadework *swp, char *dp);
HIDDEN int	bmp_setup(), bmp_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
d55 2
a56 2
HIDDEN void	txt_print(register struct region *rp), txt_free(char *cp);
HIDDEN void	ckr_print(register struct region *rp), ckr_free(char *cp);
d58 3
a60 3
HIDDEN int tstm_render(struct application *ap, struct partition *pp, register struct shadework *swp, char *dp);
HIDDEN int star_render(register struct application *ap, register struct partition *pp, struct shadework *swp, char *dp);
HIDDEN int envmap_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, const struct mfuncs *mfp, struct rt_i *rtip, struct mfuncs **headp);
d90 22
d154 5
a158 1
txt_transp_hook(struct bu_structparse *ptab, char *name, char *cp, char *value)
d266 5
a270 1
txt_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
d547 5
a551 1
bwtxt_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
d728 2
a729 1
txt_print(register struct region *rp)
d738 2
a739 1
txt_free(char *cp)
d770 5
a774 1
ckr_render(struct application *ap, struct partition *pp, register struct shadework *swp, char *dp)
d814 6
a819 6
ckr_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip)
                      	     
             		         
    			      
                             
                                /* New since 4.4 release */
d846 2
a847 1
ckr_print(register struct region *rp)
d856 2
a857 1
ckr_free(char *cp)
d869 5
a873 1
tstm_render(struct application *ap, struct partition *pp, register struct shadework *swp, char *dp)
d906 5
a910 1
star_render(register struct application *ap, register struct partition *pp, struct shadework *swp, char *dp)
d947 5
a951 1
bmp_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
d1031 7
a1037 1
envmap_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, const struct mfuncs *mfp, struct rt_i *rtip, struct mfuncs **headp)
@


11.46.2.2
log
@sync branch with HEAD
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1998-2004 by the United States Army
d23 1
a23 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d62 2
a63 1
struct region	env_region;  /* initialized in the app code view handler */
d68 1
d71 1
a71 1
HIDDEN void txt_transp_hook(struct bu_structparse *ptab, char *name, char *cp, char *value);
d74 8
a81 8
HIDDEN int bwtxt_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
HIDDEN int txt_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, const struct mfuncs *mfp, struct rt_i *rtip), txt_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
HIDDEN int ckr_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip), ckr_render(struct application *ap, struct partition *pp, register struct shadework *swp, char *dp);
HIDDEN int bmp_setup(), bmp_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
HIDDEN void bwtxtprint(), bwtxtfree();
HIDDEN void txt_print(register struct region *rp), txt_free(char *cp);
HIDDEN void ckr_print(register struct region *rp), ckr_free(char *cp);
HIDDEN void bmp_print(), bmp_free();
d86 1
a86 2
extern void mlib_void();

a117 1
	{"%S",	1, "object", TX_O(tx_name),		txt_source_hook },
a214 1
			/* keep the binary object pointer */
d217 2
a218 3
			/* release the database instance pointer struct we created */
			RT_INIT_DB_INTERNAL(dbip);
			bu_free(dbip, "txt_load_datasource");
d222 1
a222 1
				bu_log("\nWARNING: %S needs %d bytes, binary object only has %d\n", texture->tx_name, size, texture->tx_binunifp->count);
d240 2
a241 1
			bu_log("\nWARNING: %S needs %d bytes, file only has %d\n", &texture->tx_name, size, texture->tx_mp->buflen);
d701 1
a701 1
		bu_log("\nERROR: txt_setup() %s %s could not be loaded [source was %s]\n", rp->reg_name, bu_vls_addr(&tp->tx_name), tp->tx_datasrc==TXT_SRC_OBJECT?"object":tp->tx_datasrc==TXT_SRC_FILE?"file":"auto");
a1023 37
}



/*
 *			M L I B _ Z E R O
 *
 *  Regardless of arguments, always return zero.
 *  Useful mostly as a stub print, and/or free routine.
 */
/* VARARGS */
int
mlib_zero()
{
	return(0);
}

/*
 *			M L I B _ O N E
 *
 *  Regardless of arguments, always return one.
 *  Useful mostly as a stub setup routine.
 */
/* VARARGS */
int
mlib_one()
{
	return(1);
}

/*
 *			M L I B _ V O I D
 */
/* VARARGS */
void
mlib_void()
{
@


11.45
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_text.c,v 11.43 2002/05/17 12:52:40 morrison Exp $ (ARL)";
d184 1
a184 1
	if (texture==NULL) {
d231 2
a232 2
	/* if we are auto and we couldn't find a database object match, or if source is explicitly a file 
	 * then we load the file.
d711 1
a711 1
		bu_log("\ntxt_setup() ERROR %s %s could not be loaded [source was %s]\n", rp->reg_name, tp->tx_name, tp->tx_datasrc==TXT_SRC_OBJECT?"object":tp->tx_datasrc==TXT_SRC_FILE?"file":"auto");
@


11.44
log
@Converted from K&R to ANSI C - RFH
@
text
@a40 24
#define TXT_NAME_LEN 128
struct txt_specific {
	int	tx_transp[3];	/* RGB for transparency */
	/*	char	tx_file[TXT_NAME_LEN];	 Filename */
	struct bu_vls tx_name;  /* name of object or file (depending on tx_datasrc flag) */
	int	tx_w;		/* Width of texture in pixels */
	int	tx_n;		/* Number of scanlines */
	int	tx_trans_valid;	/* boolean: is tx_transp valid ? */
	fastf_t	tx_scale[2];	/* replication factors in U, V */
	int	tx_mirror;	/* flag: repetitions are mirrored */
#define TXT_SRC_FILE 'f'
#define TXT_SRC_OBJECT  'o'
#define TXT_SRC_AUTO 0
	char tx_datasrc; /* which type of datasource */
	struct rt_binunif_internal *tx_binunifp;  /* db internal object when TXT_SRC_OBJECT */
	struct bu_mapped_file	*tx_mp;    /* mapped file when TXT_SRC_FILE */
};
#define TX_NULL	((struct txt_specific *)0)
#define TX_O(m)	offsetof(struct txt_specific, m)
#define TX_AO(m)	bu_offsetofarray(struct txt_specific, m)




d47 7
a53 7
HIDDEN void	txt_transp_hook(struct bu_structparse *ptab, char *name, char *cp, char *value);
HIDDEN void txt_source_hook(const struct bu_structparse *ip, const char *sp_name, genptr_t base, char *p);
HIDDEN int txt_load_datasource(struct txt_specific *texture, struct db_i *dbInstance, const long unsigned int size);
HIDDEN int	bwtxt_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
HIDDEN int	txt_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, const struct mfuncs *mfp, struct rt_i *rtip), txt_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
HIDDEN int	ckr_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip), ckr_render(struct application *ap, struct partition *pp, register struct shadework *swp, char *dp);
HIDDEN int	bmp_setup(), bmp_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
d55 2
a56 2
HIDDEN void	txt_print(register struct region *rp), txt_free(char *cp);
HIDDEN void	ckr_print(register struct region *rp), ckr_free(char *cp);
d58 3
a60 3
HIDDEN int tstm_render(struct application *ap, struct partition *pp, register struct shadework *swp, char *dp);
HIDDEN int star_render(register struct application *ap, register struct partition *pp, struct shadework *swp, char *dp);
HIDDEN int envmap_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, const struct mfuncs *mfp, struct rt_i *rtip, struct mfuncs **headp);
d90 22
d154 5
a158 1
txt_transp_hook(struct bu_structparse *ptab, char *name, char *cp, char *value)
d266 5
a270 1
txt_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
d547 5
a551 1
bwtxt_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
d728 2
a729 1
txt_print(register struct region *rp)
d738 2
a739 1
txt_free(char *cp)
d770 5
a774 1
ckr_render(struct application *ap, struct partition *pp, register struct shadework *swp, char *dp)
d814 6
a819 6
ckr_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip)
                      	     
             		         
    			      
                             
                                /* New since 4.4 release */
d846 2
a847 1
ckr_print(register struct region *rp)
d856 2
a857 1
ckr_free(char *cp)
d869 5
a873 1
tstm_render(struct application *ap, struct partition *pp, register struct shadework *swp, char *dp)
d906 5
a910 1
star_render(register struct application *ap, register struct partition *pp, struct shadework *swp, char *dp)
d947 5
a951 1
bmp_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
d1031 7
a1037 1
envmap_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, const struct mfuncs *mfp, struct rt_i *rtip, struct mfuncs **headp)
@


11.43
log
@improved output readability on texture load, added missing param
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_text.c,v 11.42 2002/02/26 22:12:45 morrison Exp $ (ARL)";
d41 24
d71 7
a77 7
HIDDEN void	txt_transp_hook();
HIDDEN void txt_source_hook();
HIDDEN int txt_load_datasource();
HIDDEN int	bwtxt_render();
HIDDEN int	txt_setup(), txt_render();
HIDDEN int	ckr_setup(), ckr_render();
HIDDEN int	bmp_setup(), bmp_render();
d79 2
a80 2
HIDDEN void	txt_print(), txt_free();
HIDDEN void	ckr_print(), ckr_free();
d82 3
a84 3
HIDDEN int tstm_render();
HIDDEN int star_render();
HIDDEN int envmap_setup();
a113 22
#define TXT_NAME_LEN 128
struct txt_specific {
	int	tx_transp[3];	/* RGB for transparency */
	/*	char	tx_file[TXT_NAME_LEN];	 Filename */
	struct bu_vls tx_name;  /* name of object or file (depending on tx_datasrc flag) */
	int	tx_w;		/* Width of texture in pixels */
	int	tx_n;		/* Number of scanlines */
	int	tx_trans_valid;	/* boolean: is tx_transp valid ? */
	fastf_t	tx_scale[2];	/* replication factors in U, V */
	int	tx_mirror;	/* flag: repetitions are mirrored */
#define TXT_SRC_FILE 'f'
#define TXT_SRC_OBJECT  'o'
#define TXT_SRC_AUTO 0
	char tx_datasrc; /* which type of datasource */
	struct rt_binunif_internal *tx_binunifp;  /* db internal object when TXT_SRC_OBJECT */
	struct bu_mapped_file	*tx_mp;    /* mapped file when TXT_SRC_FILE */
};
#define TX_NULL	((struct txt_specific *)0)
#define TX_O(m)	offsetof(struct txt_specific, m)
#define TX_AO(m)	bu_offsetofarray(struct txt_specific, m)


d156 1
a156 5
txt_transp_hook( ptab, name, cp, value )
struct bu_structparse *ptab;
char	*name;
char	*cp;
char	*value;
d264 1
a264 5
txt_render( ap, pp, swp, dp )
struct application	*ap;
struct partition	*pp;
struct shadework	*swp;
char	*dp;
d541 1
a541 5
bwtxt_render( ap, pp, swp, dp )
struct application	*ap;
struct partition	*pp;
struct shadework	*swp;
char	*dp;
d718 1
a718 2
txt_print( rp )
register struct region *rp;
d727 1
a727 2
txt_free( cp )
char *cp;
d758 1
a758 5
ckr_render( ap, pp, swp, dp )
struct application	*ap;
struct partition	*pp;
register struct shadework	*swp;
char	*dp;
d798 6
a803 6
ckr_setup( rp, matparm, dpp, mfp, rtip )
register struct region	 *rp;
struct bu_vls		*matparm;
char			**dpp;
struct mfuncs           *mfp;
struct rt_i             *rtip;  /* New since 4.4 release */
d830 1
a830 2
ckr_print( rp )
register struct region *rp;
d839 1
a839 2
ckr_free( cp )
char *cp;
d851 1
a851 5
tstm_render( ap, pp, swp, dp )
struct application	*ap;
struct partition	*pp;
register struct shadework	*swp;
char	*dp;
d884 1
a884 5
star_render( ap, pp, swp, dp )
register struct application *ap;
register struct partition *pp;
struct shadework	*swp;
char	*dp;
d921 1
a921 5
bmp_render( ap, pp, swp, dp )
struct application	*ap;
struct partition	*pp;
struct shadework	*swp;
char	*dp;
d1001 1
a1001 7
envmap_setup( rp, matparm, dpp, mfp, rtip, headp )
register struct region *rp;
struct bu_vls *matparm;
char	**dpp;
const struct mfuncs	*mfp;
struct rt_i	*rtip;
struct mfuncs	**headp;
@


11.42
log
@added hidden define for rt_binunif_free() to quell warning
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_text.c,v 11.41 2002/02/25 21:40:42 morrison Exp $ (ARL)";
d242 1
a242 1
			bu_log("\ntxt_load_datasource() ERROR %S needs %d bytes, '%s' only has %d\n", texture->tx_name, size, texture->tx_mp->buflen);
d245 1
a245 1
			bu_log("\nWARNING: Texture file size is larger than specified texture size\n\tInput File: %d pixels\n\tSpecified Texture Size: %d pixels\n...continuing to load using image subsection...", texture->tx_binunifp->count);
@


11.41
log
@removed // comments to quell dated C compiler on cad
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_text.c,v 11.40 2002/02/22 02:30:04 morrison Exp $ (ARL)";
d46 1
@


11.40
log
@Added binary object support to the texture shader!  The texture shader can now import data from either an external file (that gets mmap'd) or an internal binary object (binunif).  The data source may be explicitly specified (file or obj) or automatically inferred (texture).  Auto inferred types try objects first, then files for source data.  Implementation follows the "general" idea/logic of the similar support in librt/g_dsp.c.

Also modified name attribute to be a vls.
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_text.c,v 11.39 2001/04/20 22:29:33 morrison Exp $ (ARL)";
a219 1
			// bu_free(dbip, "txt_load_datasource");
a442 2
				//				bu_log("before increment cp=%d *cp=%d RGB (%d, %d, %d)\n", cp, *cp, r,g,b);

a445 2

				//				bu_log("after increment\n");
@


11.39
log
@CONST to const
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_text.c,v 11.38 2000/10/19 19:19:46 butler Exp $ (ARL)";
d46 3
a56 1
HIDDEN void	txt_transp_hook();
d92 2
a93 1
	char	tx_file[TXT_NAME_LEN];	/* Filename */
d99 6
a104 1
	struct bu_mapped_file	*mp;
d110 1
d113 3
a115 1
	{"%s",	TXT_NAME_LEN, "file", bu_offsetofarray(struct txt_specific, tx_file),		BU_STRUCTPARSE_FUNC_NULL },
d126 21
d170 86
d311 3
a313 1
	if (tp->tx_file[0] == '\0' || !tp->mp )  {
d352 1
d357 1
a357 1
		register unsigned char *cp;
d359 13
a371 3
		cp = ((unsigned char *)(tp->mp->buf)) +
			(int)(ymin * (tp->tx_n-1)) * tp->tx_w * 3 +
			(int)(xmin * (tp->tx_w-1)) * 3;
d398 1
a398 2
		if (rdebug & RDEBUG_SHADE )
		{
d404 2
a405 3
		for( line = start_line ; line <= stop_line ; line++ )
		{
			register unsigned char *cp;
a415 2
			cp = ((unsigned char *)(tp->mp->buf)) +
				line * tp->tx_w * 3 + (int)(xstart) * 3;
d417 14
a430 2
			for( col = start_col ; col <= stop_col ; col++ )
			{
d434 1
a434 2
				if (col_upper > xstop )
					col_upper = xstop;
d436 2
a437 2
				if (col_lower < xstart )
					col_lower = xstart;
d444 2
d449 2
d452 1
d462 1
d477 14
a490 2
		cp = ((unsigned char *)(tp->mp->buf)) +
		     (y+line) * tp->tx_w * 3  +  x * 3;
d515 1
d533 3
d573 1
a573 1
	if (tp->tx_file[0] == '\0' || !tp->mp )  {
d626 1
a626 1
		register unsigned char *cp;
d628 14
a641 2
		cp = ((unsigned char *)(tp->mp->buf)) +
		     (y+line) * tp->tx_w  +  x;
d675 2
a676 8
HIDDEN int
txt_setup( rp, matparm, dpp, mfp, rtip )
register struct region	*rp;
struct bu_vls		*matparm;
char			**dpp;
const struct mfuncs	*mfp;
struct rt_i             *rtip;  /* New since 4.4 release */
{
d684 4
a687 1
	tp->tx_file[0] = '\0';
d693 5
a701 2
	if (tp->tx_w < 0 )  tp->tx_w = 512;
	if (tp->tx_n < 0 )  tp->tx_n = tp->tx_w;
d703 7
a709 2
	if (tp->tx_trans_valid )
		rp->reg_transmit = 1;
d711 1
a711 1
	if (tp->tx_file[0] == '\0' )  return -1;	/* FAIL, no file */
d713 4
a716 18
	tp->mp = bu_open_mapped_file_with_path(
		rtip->rti_dbip->dbi_filepath,
		tp->tx_file, NULL);

	if (!(tp->mp) )
		return -1;				/* FAIL */

	/* Ensure file is large enough */
	if (strcmp( mfp->mf_name, "bwtexture" ) == 0 )
		pixelbytes = 1;
	if (tp->mp->buflen < tp->tx_w * tp->tx_n * pixelbytes )  {
		bu_log("\ntxt_setup() ERROR %s %s needs %d bytes, '%s' only has %d\n",
			rp->reg_name,
			mfp->mf_name,
			tp->tx_w * tp->tx_n * pixelbytes,
			tp->mp->name,
			tp->mp->buflen );
		return -1;				/* FAIL */
d718 4
a721 1
	if (rdebug & RDEBUG_SHADE )
d723 1
d745 1
a745 2
	struct txt_specific *tp =
		(struct txt_specific *)cp;
d747 5
a751 1
	if (tp->mp )  bu_close_mapped_file( tp->mp );
d959 1
a959 1
	unsigned char *cp;
d969 1
a969 1
	if (tp->tx_file[0] == '\0' || !tp->mp )  {
d996 13
a1008 2
	cp = ((unsigned char *)(tp->mp->buf)) +
	     (j) * tp->tx_w * 3  +  i * 3;
@


11.38
log
@Changes to compile under RedHat 7.0
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_text.c,v 11.37 2000/08/31 20:29:26 mike Exp $ (ARL)";
d508 1
a508 1
CONST struct mfuncs	*mfp;
d858 1
a858 1
CONST struct mfuncs	*mfp;
@


11.37
log
@
Calculation of uv_dv was being scaled by X, not Y, scale factor.
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_text.c,v 11.36 2000/08/20 01:27:48 butler Exp $ (ARL)";
d29 3
@


11.36
log
@Eliminate compilation warnings, enhancements to sh_light.c
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_text.c,v 11.35 2000/08/20 00:44:47 butler Exp $ (ARL)";
d184 1
a184 1
	uvc.uv_dv /= tp->tx_scale[X];
d433 1
a433 1
	uvc.uv_dv /= tp->tx_scale[X];
@


11.35
log
@Misc commpilation changes and enhancements to light shader
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_text.c,v 11.34 2000/08/16 21:21:05 mike Exp $ (ARL)";
@


11.34
log
@
Changed to pass arguments to bu_open_mapped_file_with_path() in
correct order.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_text.c,v 11.33 2000/07/25 16:40:38 butler Exp $ (ARL)";
d615 1
a615 1
	if ( (u&1) && (v&1) || !(u&1) && !(v&1) ) {
@


11.33
log
@Changes to use rtprivate.h instead of ../rt/rdebug.h
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_text.c,v 11.32 2000/07/14 19:38:28 butler Exp $ (ARL)";
d534 2
a535 2
		(char *const *)tp->tx_file, NULL, 
		(const char *)rtip->rti_dbip->dbi_filepath);
@


11.32
log
@Added casts to make Irix compiler happy
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_text.c,v 11.31 2000/02/20 06:52:55 butler Exp $ (ARL)";
d36 1
a36 1
#include "../rt/rdebug.h"
d38 3
d615 1
a615 1
	if ( (u&1) && (v&1) || !(u&1) && !(v&1)) {
d699 1
a699 1
HIDDEN
d736 1
a736 1
HIDDEN
d777 1
a777 1
HIDDEN
@


11.31
log
@Added texture mirroring when using replication
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_text.c,v 11.30 2000/02/20 06:41:56 butler Exp $ (ARL)";
d529 6
a534 1
	if (!(tp->mp = bu_open_mapped_file( tp->tx_file, NULL )) )
@


11.30
log
@Both "texture" and "bwtexture" shaders now support replication of the image.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_text.c,v 11.29 2000/02/18 20:49:14 butler Exp $ (ARL)";
d89 1
d105 1
d171 2
d177 2
d420 2
d426 2
d517 1
@


11.29
log
@support for repitition of the uv coordinate space to allow textures to repeat.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_text.c,v 11.28 2000/01/13 22:19:21 butler Exp $ (ARL)";
d174 2
a175 8
	uvc.uv_du *= tp->tx_scale[X];
	tmp = uvc.uv_du;
	uvc.uv_du -= tmp;

	uvc.uv_dv *= tp->tx_scale[X];
	tmp = uvc.uv_dv;
	uvc.uv_dv -= tmp;

d392 2
d395 2
d402 1
a402 1
		VSET( swp->sw_color, swp->sw_uv.uv_u, 0, swp->sw_uv.uv_v );
d408 15
d425 2
a426 2
	if (swp->sw_uv.uv_du > 0.125 )  swp->sw_uv.uv_du = 0.125;
	if (swp->sw_uv.uv_dv > 0.125 )  swp->sw_uv.uv_dv = 0.125;
d428 1
a428 1
	if (swp->sw_uv.uv_du < 0 || swp->sw_uv.uv_dv < 0 )  {
d430 1
a430 1
			swp->sw_uv.uv_u, swp->sw_uv.uv_v, swp->sw_uv.uv_du, swp->sw_uv.uv_dv,
d432 1
a432 1
		swp->sw_uv.uv_du = swp->sw_uv.uv_dv = 0;
d434 4
a437 4
	xmin = swp->sw_uv.uv_u - swp->sw_uv.uv_du;
	xmax = swp->sw_uv.uv_u + swp->sw_uv.uv_du;
	ymin = swp->sw_uv.uv_v - swp->sw_uv.uv_dv;
	ymax = swp->sw_uv.uv_v + swp->sw_uv.uv_dv;
@


11.28
log
@A little run-time error checking, and optional debugging output
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_text.c,v 11.27 1999/12/30 16:05:58 jra Exp $ (ARL)";
d88 1
d93 1
d101 3
a103 1
	{"%d",	1, "trans_valid",	TX_O(tx_trans_valid),	BU_STRUCTPARSE_FUNC_NULL },
d151 2
d157 3
a159 1
	if( rdebug & RDEBUG_SHADE )
d161 22
a182 1
			swp->sw_uv.uv_du, swp->sw_uv.uv_dv );
d187 3
a189 3
	if( tp->tx_file[0] == '\0' || !tp->mp )  {
		VSET( swp->sw_color, swp->sw_uv.uv_u, 0, swp->sw_uv.uv_v );
		if( swp->sw_reflect > 0 || swp->sw_transmit > 0 )
d196 2
a197 2
	if( swp->sw_uv.uv_du > 0.125 )  swp->sw_uv.uv_du = 0.125;
	if( swp->sw_uv.uv_dv > 0.125 )  swp->sw_uv.uv_dv = 0.125;
d199 1
a199 1
	if( swp->sw_uv.uv_du < 0 || swp->sw_uv.uv_dv < 0 )  {
d201 1
a201 1
			swp->sw_uv.uv_u, swp->sw_uv.uv_v, swp->sw_uv.uv_du, swp->sw_uv.uv_dv,
d203 1
a203 1
		swp->sw_uv.uv_du = swp->sw_uv.uv_dv = 0;
d206 8
a213 8
	xmin = swp->sw_uv.uv_u - swp->sw_uv.uv_du;
	xmax = swp->sw_uv.uv_u + swp->sw_uv.uv_du;
	ymin = swp->sw_uv.uv_v - swp->sw_uv.uv_dv;
	ymax = swp->sw_uv.uv_v + swp->sw_uv.uv_dv;
	if( xmin < 0 )  xmin = 0;
	if( ymin < 0 )  ymin = 0;
	if( xmax > 1 )  xmax = 1;
	if( ymax > 1 )  ymax = 1;
d215 1
a215 1
	if( rdebug & RDEBUG_SHADE )
d224 1
a224 1
	if( rdebug & RDEBUG_SHADE )
d226 1
a226 1
	if( dx == 0 && dy == 0 )
d261 1
a261 1
		if( rdebug & RDEBUG_SHADE )
d263 1
a263 1
			bu_log( "\thit in texture space = (%g %g)\n", swp->sw_uv.uv_u * (tp->tx_w-1), swp->sw_uv.uv_v * (tp->tx_n-1) );
d275 1
a275 1
			if( line_upper > ystop )
d278 1
a278 1
			if( line_lower < ystart )
d289 1
a289 1
				if( col_upper > xstop )
d292 1
a292 1
				if( col_lower < xstart )
d297 1
a297 1
				if( rdebug & RDEBUG_SHADE )
d310 1
a310 1
	if( rdebug & RDEBUG_SHADE )
d317 2
a318 2
	if( dx < 1 )  dx = 1;
	if( dy < 1 )  dy = 1;
d320 1
a320 1
	if( rdebug & RDEBUG_SHADE )
d331 1
a331 1
			if( rdebug & RDEBUG_SHADE )
d338 1
a338 1
	if( rdebug & RDEBUG_SHADE )
d343 1
a343 1
	if( rdebug & RDEBUG_SHADE )
d353 1
a353 1
		if( swp->sw_reflect > 0 || swp->sw_transmit > 0 )
d360 3
a362 3
	if( r != ((long)tp->tx_transp[0]) )  goto opaque;
	if( g != ((long)tp->tx_transp[1]) )  goto opaque;
	if( b != ((long)tp->tx_transp[2]) )  goto opaque;
d370 1
a370 1
	if( swp->sw_reflect > 0 || swp->sw_transmit > 0 )
d403 1
a403 1
	if( tp->tx_file[0] == '\0' || !tp->mp )  {
d405 1
a405 1
		if( swp->sw_reflect > 0 || swp->sw_transmit > 0 )
d412 2
a413 2
	if( swp->sw_uv.uv_du > 0.125 )  swp->sw_uv.uv_du = 0.125;
	if( swp->sw_uv.uv_dv > 0.125 )  swp->sw_uv.uv_dv = 0.125;
d415 1
a415 1
	if( swp->sw_uv.uv_du < 0 || swp->sw_uv.uv_dv < 0 )  {
d425 4
a428 4
	if( xmin < 0 )  xmin = 0;
	if( ymin < 0 )  ymin = 0;
	if( xmax > 1 )  xmax = 1;
	if( ymax > 1 )  ymax = 1;
d433 2
a434 2
	if( dx < 1 )  dx = 1;
	if( dy < 1 )  dy = 1;
d451 1
a451 1
		if( swp->sw_reflect > 0 || swp->sw_transmit > 0 )
d458 1
a458 1
	if( bw / (dx*dy) != ((long)tp->tx_transp[0]) )  goto opaque;
d466 1
a466 1
	if( swp->sw_reflect > 0 || swp->sw_transmit > 0 )
d492 3
a494 1
	if( bu_struct_parse( matparm, txt_parse, (char *)tp ) < 0 )  {
d498 2
a499 2
	if( tp->tx_w < 0 )  tp->tx_w = 512;
	if( tp->tx_n < 0 )  tp->tx_n = tp->tx_w;
d501 1
a501 1
	if( tp->tx_trans_valid )
d504 2
a505 2
	if( tp->tx_file[0] == '\0' )  return -1;	/* FAIL, no file */
	if( !(tp->mp = bu_open_mapped_file( tp->tx_file, NULL )) )
d509 1
a509 1
	if( strcmp( mfp->mf_name, "bwtexture" ) == 0 )
d511 1
a511 1
	if( tp->mp->buflen < tp->tx_w * tp->tx_n * pixelbytes )  {
d520 1
a520 1
	if( rdebug & RDEBUG_SHADE )
d546 1
a546 1
	if( tp->mp )  bu_close_mapped_file( tp->mp );
d590 1
a590 1
	if( (swp->sw_uv.uv_u < 0.5 && swp->sw_uv.uv_v < 0.5) ||
d603 1
a603 1
	if( swp->sw_reflect > 0 || swp->sw_transmit > 0 )
d628 1
a628 1
	if( bu_struct_parse( matparm, ckr_parse, (char *)ckp ) < 0 )  {
d676 1
a676 1
	if( swp->sw_reflect > 0 || swp->sw_transmit > 0 )
d712 1
a712 1
	if( bn_rand0to1(ap->a_resource->re_randptr) >= 0.98 )  {
d727 1
a727 1
	if( swp->sw_reflect > 0 || swp->sw_transmit > 0 )
d764 1
a764 1
	if( tp->tx_file[0] == '\0' || !tp->mp )  {
d766 1
a766 1
		if( swp->sw_reflect > 0 || swp->sw_transmit > 0 )
d771 1
a771 1
	if( swp->sw_uv.uv_u < 0 || swp->sw_uv.uv_u > 1 || swp->sw_uv.uv_v < 0 || swp->sw_uv.uv_v > 1 )  {
d777 1
a777 1
		if( swp->sw_reflect > 0 || swp->sw_transmit > 0 )
d796 1
a796 1
	if( rdebug&RDEBUG_LIGHT ) {
d805 1
a805 1
	if( rdebug&RDEBUG_LIGHT ) {
d809 1
a809 1
	if( swp->sw_reflect > 0 || swp->sw_transmit > 0 )
d830 1
a830 1
	if( env_region.reg_mfuncs )  {
d844 1
a844 1
	if( mlib_setup( headp, &env_region, rtip ) < 0 )
@


11.27
log
@Eliminated some unused variables
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_text.c,v 11.26 1999/12/23 05:59:24 mike Exp $ (ARL)";
d148 3
d152 2
a153 1
		bu_log( "in txt_render(): du=%g, dv=%g\n", swp->sw_uv.uv_du, swp->sw_uv.uv_dv );
d489 2
@


11.26
log
@
struct region is now a bu_list
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_text.c,v 11.25 1999/10/30 03:06:25 butler Exp $ (ARL)";
a144 1
	int line;
a145 1
	int x,y;
a214 1
		fastf_t u, v;
a237 1
			register unsigned char *ep;
a789 2
	register char	*cp;
	struct bu_vls	material;
@


11.25
log
@Moved mathtab/rand_half from rt into libbn
Expanded structparse to include description and default
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_text.c,v 11.24 1999/07/02 22:20:42 mike Exp $ (ARL)";
d807 2
a808 1
	env_region.reg_forw = REGION_NULL;
@


11.24
log
@
Removed dependence on compat4.h
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_text.c,v 11.23 1999/07/01 20:08:49 mike Exp $ (ARL)";
d35 1
a35 1
#include "../rt/mathtab.h"
d679 1
a679 1
	if( rand0to1(ap->a_resource->re_randptr) >= 0.98 )  {
d685 1
a685 1
		f = rand0to1(ap->a_resource->re_randptr);
d688 1
a688 1
		f = rand0to1(ap->a_resource->re_randptr);
@


11.23
log
@
compat4
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_text.c,v 11.22 1999/02/04 03:57:12 butler Exp $ (ARL)";
d95 6
a100 6
	{"%s",	TXT_NAME_LEN, "file", bu_offsetofarray(struct txt_specific, tx_file),		FUNC_NULL },
	{"%d",	1, "w",		TX_O(tx_w),		FUNC_NULL },
	{"%d",	1, "n",		TX_O(tx_n),		FUNC_NULL },
	{"%d",	1, "l",		TX_O(tx_n),		FUNC_NULL }, /*compat*/
	{"%d",	1, "trans_valid",	TX_O(tx_trans_valid),	FUNC_NULL },
	{"",	0, (char *)0,	0,			FUNC_NULL }
d529 1
a529 1
	{"",	0, (char *)0,	0,			FUNC_NULL }
@


11.22
log
@checker got a parameter "s" to indicate how many times the pattern changes
over the u,v range.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_text.c,v 11.21 1998/12/10 03:35:15 mike Exp $ (ARL)";
d88 1
a88 1
	struct rt_mapped_file	*mp;
d94 2
a95 2
	{"%d",	1, "transp",	offsetofarray(struct txt_specific, tx_transp),	txt_transp_hook },
	{"%s",	TXT_NAME_LEN, "file", offsetofarray(struct txt_specific, tx_file),		FUNC_NULL },
d121 1
a121 1
		rt_log("file:%s, line:%d txt_transp_hook name:(%s) instead of (%s)\n",
d169 1
a169 1
		rt_log("txt_render uv=%g,%g, du dv=%g %g seg=%s\n",
d321 3
a323 3
			r * rt_inv255,
			g * rt_inv255,
			b * rt_inv255 );
d387 1
a387 1
		rt_log("bwtxt_render uv=%g,%g, du dv=%g %g seg=%s\n",
d421 1
a421 1
			bw * rt_inv255 / (dx*dy) );
d448 1
a448 1
struct rt_vls		*matparm;
d456 2
a457 2
	RT_VLS_CHECK( matparm );
	GETSTRUCT( tp, txt_specific );
d464 1
a464 1
		rt_free( (char *)tp, "txt_specific" );
d474 1
a474 1
	if( !(tp->mp = rt_open_mapped_file( tp->tx_file, NULL )) )
d481 1
a481 1
		rt_log("\ntxt_setup() ERROR %s %s needs %d bytes, '%s' only has %d\n",
d513 2
a514 2
	if( tp->mp )  rt_close_mapped_file( tp->mp );
	rt_free( cp, "txt_specific" );
d526 3
a528 3
	{"%d",	3, "a",	offsetofarray(struct ckr_specific, ckr_a), FUNC_NULL },
	{"%d",	3, "b",	offsetofarray(struct ckr_specific, ckr_b), FUNC_NULL },
	{"%f",	1, "s", offsetof(struct ckr_specific, ckr_scale), FUNC_NULL },
d566 3
a568 3
		(unsigned char)cp[0] * rt_inv255,
		(unsigned char)cp[1] * rt_inv255,
		(unsigned char)cp[2] * rt_inv255 );
d582 1
a582 1
struct rt_vls		*matparm;
d590 1
a590 1
	GETSTRUCT( ckp, ckr_specific );
d596 1
a596 1
		rt_free( (char *)ckp, "ckr_specific" );
d625 1
a625 1
	rt_free( cp, "ckr_specific" );
d739 1
a739 1
		rt_log("bmp_render:  bad u,v=%g,%g du,dv=%g,%g seg=%s\n",
d767 2
a768 2
		rt_log("cu = %d, cv = %d\n", *cp, *(cp+2));
		rt_log("pertU = %g, pertV = %g\n", pertU, pertV);
d788 1
a788 1
struct rt_vls *matparm;
d795 1
a795 1
	struct rt_vls	material;
d797 1
a797 1
	RT_VLS_CHECK( matparm );
d800 1
a800 1
		rt_log("envmap_setup:  second environment map ignored\n");
d805 1
a805 1
	env_region.reg_name = rt_strdup( rp->reg_name );
d813 1
a813 1
		rt_log("envmap_setup() material '%s' failed\n", env_region.reg_mater );
@


11.21
log
@env_region is imported from rt/view.c, not the other way around.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_text.c,v 11.20 1998/09/22 01:29:56 mike Exp $ (ARL)";
d520 1
d528 1
d545 1
d547 10
d563 2
d593 2
@


11.20
log
@Moved optical shaders from rt/ to liboptical/
The only modifications involved moving and splitting
rt/material.h into h/shadefuncs.h and h/shadework.h,
and in changing the calling sequence to mlib_setup() in rt/material.c

Now the only shader function called directly by RT is
in liboptical/init.c: optical_shader_init().
It adds all the individual shaders to the "mfuncs" shader list.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
d38 1
a38 1
struct region	env_region;			/* share with view.c */
@


11.19
log
@envmap_setup() was ignoring parameters for passed shader.
@
text
@d2 1
a2 1
 *  			T E X T . C
d10 2
a11 3
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
d13 5
d19 2
a20 2
 *	This software is Copyright (C) 1985 by the United States Army.
 *	All rights reserved.
d23 1
a23 1
static char RCStext[] = "@@(#)$Header: /c/CVS/brlcad/rt/sh_text.c,v 11.18 1998/06/30 22:54:19 mike Exp $ (BRL)";
d33 4
a36 3
#include "./material.h"
#include "./mathtab.h"
#include "./rdebug.h"
d769 1
a769 1
envmap_setup( rp, matparm, dpp, mfp, rtip )
d775 1
d795 1
a795 1
	if( mlib_setup( &env_region, rtip ) < 0 )
@


11.18
log
@Can't make "struct mfuncs" a CONST, because the forward link needs
to be filled in at runtime, and some compilers put CONST data into
read-only pages (like FreeBSD).
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /c/CVS/brlcad/rt/sh_text.c,v 11.17 1997/12/31 09:01:40 mike Exp $ (BRL)";
d787 1
a787 16
	rt_vls_init( &material );
	rt_vls_vlscat( &material, matparm );
	/* Expect "material SPACE args", find space */
	cp = RT_VLS_ADDR( &material );
	while( *cp != '\0' )  {
		if( !isascii(*cp) || isspace(*cp) )  break;
		cp++;
	}
	if( *cp == '\0' )  {
		/*  Null was encountered while searching for space,
		 *  leave "cp" pointing at null, e.g., no parameter string.
		 */
	} else {
		/* Replace space with null, advance "cp" to parameter */
		*cp++ = '\0';
	}
a788 2
	env_region.reg_mater.ma_shader = bu_vls_strdup( &material );

d791 1
a791 1
	rt_vls_free( &material );
@


11.17
log
@Required magic number to be first in mfunc table,
consistent with all other BRL-CAD magic numbers.
Required magic number to be initialized at compile time.
Added code to check the magic numbers.
Made the xxx_mfunc arrays CONST, so they can't get trashed by
runtime runaway pointer problems.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 11.16 1997/11/25 22:16:43 butler Exp mike $ (BRL)";
d50 1
a50 1
CONST struct mfuncs txt_mfuncs[] = {
@


11.16
log
@updated all shaders so that _setup had mfp and rtip parameters
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 11.15 1997/11/21 20:59:34 jra Exp butler $ (BRL)";
d50 3
a52 3
struct mfuncs txt_mfuncs[] = {
	"texture",	0,		0,		MFI_UV,		0,
	txt_setup,	txt_render,	txt_print,	txt_free,
d54 2
a55 2
	"bwtexture",	0,		0,		MFI_UV,		0,
	txt_setup,	bwtxt_render,	txt_print,	txt_free,
d57 2
a58 2
	"checker",	0,		0,		MFI_UV,		0,
	ckr_setup,	ckr_render,	ckr_print,	ckr_free,
d60 2
a61 2
	"testmap",	0,		0,		MFI_UV,		0,
	mlib_one,	tstm_render,	mlib_void,	mlib_void,
d63 2
a64 2
	"fakestar",	0,		0,		0,		0,
	mlib_one,	star_render,	mlib_void,	mlib_void,
d66 2
a67 2
	"bump",		0,		0,		MFI_UV|MFI_NORMAL, 0,
	txt_setup,	bmp_render,	txt_print,	txt_free,
d69 2
a70 2
	"envmap",	0,		0,		0,		0,
	envmap_setup,	mlib_zero,	mlib_void,	mlib_void,
d72 2
a73 2
	(char *)0,	0,		0,		0,		0,
	0,		0,		0,		0
@


11.15
log
@Added a debug print.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 11.14 1997/08/01 18:01:15 jra Exp jra $ (BRL)";
d441 1
a441 1
txt_setup( rp, matparm, dpp, mfp )
d446 1
d560 1
a560 1
ckr_setup( rp, matparm, dpp )
d564 2
@


11.14
log
@Modified txt_render to compute weighted average of texture pixels within hit footprint.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 11.13 1997/07/02 21:15:37 butler Exp jra $ (BRL)";
d178 6
@


11.13
log
@checkpoint
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 11.12 1996/12/04 02:55:51 mike Exp butler $ (BRL)";
d143 1
a143 1
	register long r,g,b;
d145 2
d169 1
d178 95
d279 4
a282 1
/** rt_log("x=%d y=%d, dx=%d, dy=%d\n", x, y, dx, dy); **/
d291 2
d298 2
d303 3
@


11.12
log
@Combined ma_matname and ma_matparm into a single string, ma_shader.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 11.11 1996/10/19 06:17:00 mike Exp mike $ (BRL)";
d405 2
a406 8
#if CRAY && !__STDC__
	/* Hack for old Cray compilers */
	{"%d",	1, "a",		0,			FUNC_NULL },
	{"%d",	1, "b",		1,			FUNC_NULL },
#else
	{"%d",	1, "a",	offsetofarray(struct ckr_specific, ckr_a), FUNC_NULL },
	{"%d",	1, "b",	offsetofarray(struct ckr_specific, ckr_b), FUNC_NULL },
#endif
@


11.11
log
@Changed to reflect that ma_matparm is now a pointer, not an array.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 11.10 1996/08/31 08:46:01 butler Exp mike $ (BRL)";
d693 1
a693 2
	env_region.reg_mater.ma_matname = bu_vls_strdup( &material );
	env_region.reg_mater.ma_matparm = bu_strdup( cp );
@


11.10
log
@bu_struct_print
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 11.9 1996/08/31 08:29:28 butler Exp butler $ (BRL)";
d693 2
a694 4
	strncpy( env_region.reg_mater.ma_matname, RT_VLS_ADDR(&material),
		sizeof(rp->reg_mater.ma_matname) );
	strncpy( env_region.reg_mater.ma_matparm, cp,
		sizeof(rp->reg_mater.ma_matparm) );
@


11.9
log
@bu_struct_parse
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 11.8 1996/08/30 00:08:21 butler Exp butler $ (BRL)";
d380 1
a380 1
	bu_structprint(rp->reg_name, txt_parse, (char *)rp->reg_udata);
d482 1
a482 1
	bu_structprint(rp->reg_name, ckr_parse, rp->reg_udata);
@


11.8
log
@structparse moved to libbu
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 11.7 1996/07/22 20:34:18 jra Exp butler $ (BRL)";
d343 1
a343 1
	if( bu_structparse( matparm, txt_parse, (char *)tp ) < 0 )  {
d462 1
a462 1
	if( bu_structparse( matparm, ckr_parse, (char *)ckp ) < 0 )  {
@


11.7
log
@Minor Mods for IRIX 6.2
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 11.6 1996/05/07 19:26:36 jra Exp jra $ (BRL)";
d88 1
a88 1
struct structparse txt_parse[] = {
d101 1
a101 1
 *  Hooked function, called by rt_structparse
d105 1
a105 1
struct structparse *ptab;
d343 1
a343 1
	if( rt_structparse( matparm, txt_parse, (char *)tp ) < 0 )  {
d380 1
a380 1
	rt_structprint(rp->reg_name, txt_parse, (char *)rp->reg_udata);
d404 1
a404 1
struct structparse ckr_parse[] = {
d462 1
a462 1
	if( rt_structparse( matparm, ckr_parse, (char *)ckp ) < 0 )  {
d482 1
a482 1
	rt_structprint(rp->reg_name, ckr_parse, rp->reg_udata);
@


11.6
log
@Individual shaders now call rr_render() directly.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 11.5 1995/10/20 04:43:53 butler Exp jra $ (BRL)";
d550 5
a554 1
		i = ((double)i) * rand0to1(ap->a_resource->re_randptr);
@


11.5
log
@edited mfuncs table to account for new "mf_flags" element in struct mfuncs.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 11.4 1995/09/16 00:28:34 mike Exp butler $ (BRL)";
d151 2
d205 2
d222 2
d257 2
d303 2
d318 2
d440 4
d509 4
d556 4
d596 2
d607 2
d638 3
@


11.4
log
@Oops, envmap_setup() was missing an argument.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /n/wolf/m/cad/rt/RCS/sh_text.c,v 11.3 1995/06/02 23:34:05 mike Exp mike $ (BRL)";
d51 1
a51 1
	"texture",	0,		0,		MFI_UV,
d54 1
a54 1
	"bwtexture",	0,		0,		MFI_UV,
d57 1
a57 1
	"checker",	0,		0,		MFI_UV,
d60 1
a60 1
	"testmap",	0,		0,		MFI_UV,
d63 1
a63 1
	"fakestar",	0,		0,		0,
d66 1
a66 1
	"bump",		0,		0,		MFI_UV|MFI_NORMAL,
d69 1
a69 1
	"envmap",	0,		0,		0,
d72 1
a72 1
	(char *)0,	0,		0,		0,
@


11.3
log
@mlib_setup() and the XXX->mf_setup() routines now take rtip as final arg.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 11.2 1995/03/11 02:24:14 mike Exp mike $ (BRL)";
d618 1
a618 1
envmap_setup( rp, matparm, dpp, rtip )
d622 1
@


11.2
log
@Added mfp parameter to mf_setup() call.
This allows the shader setup routine to know what name it was invoked by.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 11.1 95/01/04 10:01:13 mike Rel4_4 Locker: mike $ (BRL)";
d618 1
a618 1
envmap_setup( rp, matparm, dpp )
d622 1
d628 1
d662 1
a662 1
	if( mlib_setup( &env_region ) < 0 )
@


11.1
log
@Release_4.4
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 10.8 94/12/19 19:54:28 mike Exp $ (BRL)";
d315 1
a315 1
txt_setup( rp, matparm, dpp )
d319 1
d346 1
a346 1
	if( strcmp( rp->reg_mater.ma_matname, "bwtexture" ) == 0 )
d349 1
a349 1
		rt_log("\nERROR %s %s needs %d bytes, '%s' only has %d\n",
d351 1
a351 1
			rp->reg_mater.ma_matname,
@


10.8
log
@Bug 237 -- check size of texture file.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 10.7 94/11/30 19:23:24 mike Exp Locker: mike $ (BRL)";
@


10.7
log
@Added error message
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 10.6 94/11/15 21:57:51 mike Exp Locker: mike $ (BRL)";
a80 1
	int	tx_fw;		/* File width of texture in pixels */
a93 1
	{"%d",	1, "fw",	TX_O(tx_fw),		FUNC_NULL },
d321 1
d328 1
a328 1
	tp->tx_w = tp->tx_fw = tp->tx_n = -1;
a335 1
	if( tp->tx_fw < 0 )  tp->tx_fw = tp->tx_w;
d341 17
a357 3
	if( tp->mp = rt_open_mapped_file( tp->tx_file, NULL ) )
		return 1;				/* OK */
	return -1;					/* FAIL */
@


10.6
log
@Added "bwtexture" shader.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 10.5 94/11/05 02:53:18 mike Exp Locker: mike $ (BRL)";
d647 2
a648 1
	(void)mlib_setup( &env_region );
@


10.5
log
@Irix 6
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 10.4 94/10/29 02:38:11 mike Exp Locker: mike $ (BRL)";
d35 1
d39 1
d54 3
a89 5
#if CRAY && !__STDC__
	/* Hack for old Cray compilers */
	{"%d",	1, "transp",	0,			txt_transp_hook },
	{"%s",	TXT_NAME_LEN, "file",	3,		FUNC_NULL },
#else
a91 1
#endif
d213 90
@


10.4
log
@Converted over to using rt_open_mapped_file().
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 10.3 94/08/11 02:29:04 gdurf Exp Locker: mike $ (BRL)";
d404 7
a410 5
/***	{ 0.446728, 0.493157, 0.727269 },	/* fake 12000 */
/***	{ 0.446728, 0.493157, 0.727269 },	/* fake 13000 */
/***	{ 0.446728, 0.493157, 0.727269 },	/* fake 14000 */
/***	{ 0.446728, 0.493157, 0.727269 }	/* fake 15000 */
/***	{ 0.393433 0.488079 0.940423 },	/* 20000 */
d460 1
a460 1
	vect_t	x, y;		/* world coordinate axis vectors */
a462 1
	char *save;
a482 1
	VSET( x, 1, 0, 0 );
@


10.3
log
@Added include of conf.h
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 10.2 1994/03/09 17:57:53 mike Exp gdurf $ (BRL)";
a77 1
	char	*tx_pixels;	/* Pixel holding area */
d79 1
a123 1

a124 43
 *			T X T _ R E A D
 *
 *  Load the texture into memory.
 *  Returns 0 on failure, 1 on success.
 */
HIDDEN int
txt_read( tp )
register struct txt_specific *tp;
{
	char *linebuf;
	register FILE *fp;
	register int	i;
	register int	got;

	if( (fp = fopen(tp->tx_file, "r")) == NULL )  {
		rt_log("txt_read(%s):  can't open\n", tp->tx_file);
		tp->tx_file[0] = '\0';
		return(0);
	}
	linebuf = rt_malloc(tp->tx_fw*3,"texture file line");
	tp->tx_pixels = rt_malloc(
		tp->tx_w * tp->tx_n * 3,
		tp->tx_file );
	for( i=0; i<tp->tx_n; i++ )  {
		got = fread(linebuf, 1, tp->tx_fw*3, fp);
		if( got != tp->tx_fw*3 ) {
			rt_log("txt_read: read error on %s\n", tp->tx_file);
			rt_log("txt_read: wanted %d, got %d on line %d\n", tp->tx_fw*3, got, i);
			(void)fclose(fp);
			rt_free( tp->tx_pixels, tp->tx_file );
			rt_free(linebuf,"file line, error");
			tp->tx_file[0] = '\0';
			tp->tx_n = -1;
			return(0);
		}
		bcopy( linebuf, tp->tx_pixels + i*tp->tx_w*3, tp->tx_w*3 );
	}
	(void)fclose(fp);
	rt_free(linebuf,"texture file line");
	return(1);	/* OK */
}

/*
d152 1
a152 2
	if( tp->tx_file[0] == '\0'  ||
	    ( tp->tx_pixels == (char *)0 && txt_read(tp) == 0 ) )  {
d187 2
a188 2
		cp = (unsigned char *)(tp->tx_pixels +
		     (y+line) * tp->tx_w * 3  +  x * 3);
a248 1
	tp->tx_pixels = (char *)0;
d253 4
a256 4
	if( txt_read(tp) == 0 )
		return(-1);
	else
		return(1);
d276 4
a279 3
	if( ((struct txt_specific *)cp)->tx_pixels )
		rt_free( ((struct txt_specific *)cp)->tx_pixels,
			((struct txt_specific *)cp)->tx_file );
d467 1
a467 2
	if( tp->tx_file[0] == '\0'  ||
	    ( tp->tx_pixels == (char *)0 && txt_read(tp) == 0 ) )  {
d491 2
a492 2
	cp = (unsigned char *)(tp->tx_pixels +
	     (j) * tp->tx_w * 3  +  i * 3);
@


10.2
log
@Eliminiated dead code.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 10.1 91/10/12 06:42:13 mike Rel4_0 Locker: mike $ (BRL)";
d21 2
@


10.1
log
@Release_4.0
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 9.12 91/07/06 00:35:24 mike Exp $ (BRL)";
a477 11
struct phong_specific {
	int	shine;
	double	wgt_specular;
	double	wgt_diffuse;
	double	transmit;	/* Moss "transparency" */
	double	reflect;	/* Moss "transmission" */
	double	refrac_index;
} junk = {
	10, 0.7, 0.3, 0, 0, 1.0
};

a552 1
	/*phong_render( ap, pp, swp, &junk );*/
@


9.12
log
@ANSI structure initialization
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 9.11 91/02/20 01:16:58 mike Exp $ (BRL)";
@


9.11
log
@Changed handling of env_region to be sensitive to the fact that
reg_name, reg_treetop, etc, pointers will go away,
and thus need to be explicitly duplicated if needed.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 9.10 91/02/17 20:15:56 mike Exp $ (BRL)";
d85 2
a86 2
	"%d",	1, "transp",	0,			txt_transp_hook,
	"%s",	TXT_NAME_LEN, "file",	3,		FUNC_NULL,
d88 2
a89 2
	"%d",	1, "transp",	offsetofarray(struct txt_specific, tx_transp),	txt_transp_hook,
	"%s",	TXT_NAME_LEN, "file", offsetofarray(struct txt_specific, tx_file),		FUNC_NULL,
d91 6
a96 6
	"%d",	1, "w",		TX_O(tx_w),		FUNC_NULL,
	"%d",	1, "n",		TX_O(tx_n),		FUNC_NULL,
	"%d",	1, "l",		TX_O(tx_n),		FUNC_NULL, /*compat*/
	"%d",	1, "fw",	TX_O(tx_fw),		FUNC_NULL,
	"%d",	1, "trans_valid",	TX_O(tx_trans_valid),	FUNC_NULL,
	"",	0, (char *)0,	0,			FUNC_NULL
d336 2
a337 2
	"%d",	1, "a",		0,			FUNC_NULL,
	"%d",	1, "b",		1,			FUNC_NULL,
d339 2
a340 2
	"%d",	1, "a",	offsetofarray(struct ckr_specific, ckr_a), FUNC_NULL,
	"%d",	1, "b",	offsetofarray(struct ckr_specific, ckr_b), FUNC_NULL,
d342 1
a342 1
	"",	0, (char *)0,	0,			FUNC_NULL
@


9.10
log
@Check return code from rt_structparse()
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 9.9 91/02/17 18:50:56 mike Exp $ (BRL)";
d31 1
a31 1
extern struct region	env_region;		/* in do.c */
d586 4
d596 2
a597 1
	while( *cp != '\0' && isascii(*cp) && !isspace(*cp) )
d599 9
a607 1
	*cp++ = '\0';
@


9.9
log
@Added extra vls check
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 9.8 91/01/05 03:09:18 mike Exp $ (BRL)";
d285 4
a288 1
	rt_structparse( matparm, txt_parse, (char *)tp );
d387 4
a390 1
	rt_structparse( matparm, ckr_parse, (char *)ckp );
@


9.8
log
@Converted to new format for fmt entry in structparse
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 9.7 91/01/03 22:58:23 butler Exp $ (BRL)";
d278 1
@


9.7
log
@updates to work with new structparse routines
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 9.6 90/12/12 16:35:12 butler Exp $ (BRL)";
d94 1
a94 1
	"%d",	1, "fw",		TX_O(tx_fw),	FUNC_NULL,
d96 1
a96 1
	(char *)0, 0,(char *)0,	0,			FUNC_NULL
d338 1
a338 1
	(char *)0, 0, (char *)0,	0,		FUNC_NULL
@


9.6
log
@modified to reflect changes in structparse format
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 9.5 90/12/10 21:14:44 mike Exp $ (BRL)";
d71 1
a71 1
	unsigned char tx_transp[8];	/* RGB for transparency */
d77 1
a77 1
	int	trans_valid;	/* boolean: is tx_transp valid ? */
d85 2
a86 2
	"%C",	1, "transp",	0,			txt_transp_hook,
	"%s",	TXT_NAME_LEN, "file",	1,			FUNC_NULL,
d88 1
a88 1
	"%C",	1, "transp",	offsetofarray(struct txt_specific, tx_transp),	txt_transp_hook,
d94 2
a95 2
	"%d",	1, "fw",		TX_O(tx_fw),		FUNC_NULL,
	"%d",	1, "trans_valid",	TX_O(trans_valid),	FUNC_NULL,
d115 1
a115 1
		tp->trans_valid = 1;
d243 1
a243 1
	if( tp->tx_transp[3] == 0 )  {
d251 6
a256 4
	/* This circumlocution needed to keep expression simple for Cray, others */
	if( r != (tp->tx_transp[0]) )  goto opaque;
	if( g != (tp->tx_transp[1]) )  goto opaque;
	if( b != (tp->tx_transp[2]) )  goto opaque;
d283 1
d290 1
a290 1
	if( tp->trans_valid )
d323 2
a324 2
	unsigned char	ckr_a[8];	/* first RGB */
	unsigned char	ckr_b[8];	/* second RGB */
d332 2
a333 2
	"%C",	1, "a",		0,			FUNC_NULL,
	"%C",	1, "b",		1,			FUNC_NULL,
d335 2
a336 2
	"%C",	1, "a",	offsetofarray(struct ckr_specific, ckr_a), FUNC_NULL,
	"%C",	1, "b",	offsetofarray(struct ckr_specific, ckr_b), FUNC_NULL,
d353 1
a353 1
	register unsigned char *cp;
d362 3
a364 3
		cp[0] * rt_inv255,
		cp[1] * rt_inv255,
		cp[2] * rt_inv255 );
d384 6
@


9.5
log
@Improved handling of environment maps.
Copy the string before banging nulls into it.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 9.4 90/12/08 08:58:13 butler Exp $ (BRL)";
d69 1
d72 1
a72 1
	char	tx_file[128];	/* Filename */
d85 2
a86 2
	"%C",	"transp",	0,			txt_transp_hook,
	"%s",	"file",		1,			FUNC_NULL,
d88 2
a89 2
	"%C",	"transp",	offsetofarray(struct txt_specific, tx_transp),	txt_transp_hook,
	"%s",	"file",		offsetofarray(struct txt_specific, tx_file),		FUNC_NULL,
d91 6
a96 6
	"%d",	"w",		TX_O(tx_w),		FUNC_NULL,
	"%d",	"n",		TX_O(tx_n),		FUNC_NULL,
	"%d",	"l",		TX_O(tx_n),		FUNC_NULL, /*compat*/
	"%d",	"fw",		TX_O(tx_fw),		FUNC_NULL,
	"%d",	"trans_valid",	TX_O(trans_valid),	FUNC_NULL,
	(char *)0,(char *)0,	0,			FUNC_NULL
d329 2
a330 2
	"%C",	"a",		0,			FUNC_NULL,
	"%C",	"b",		1,			FUNC_NULL,
d332 2
a333 2
	"%C",	"a",		offsetofarray(struct ckr_specific, ckr_a),		FUNC_NULL,
	"%C",	"b",		offsetofarray(struct ckr_specific, ckr_b),		FUNC_NULL,
d335 1
a335 1
	(char *)0,(char *)0,	0,			FUNC_NULL
@


9.4
log
@changed material property parameter to be struct rt_vls
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 9.3 90/12/08 08:30:46 mike Exp $ (BRL)";
d23 1
d561 1
d571 2
d574 2
a575 2
	cp = RT_VLS_ADDR( matparm );
	while( *cp != '\0' && *cp != ' ' )
d579 3
a581 1
	strncpy( env_region.reg_mater.ma_matparm, cp++,
a583 7
	/* truncate the string to just the material name */
	rt_vls_trunc( matparm, (int)(--cpp - RT_VLS_ADDR(matparm)) );

	strncpy( env_region.reg_mater.ma_matname, RT_VLS_ADDR(matparm),
		sizeof(rp->reg_mater.ma_matname) );


d585 1
@


9.3
log
@fixed bugs
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 9.2 90/12/08 08:20:14 mike Exp $ (BRL)";
d556 1
a556 1
char	*matparm;
d561 1
d570 1
a570 1
	cp = matparm;
d574 8
a581 1
	strncpy( env_region.reg_mater.ma_matname, matparm,
d583 2
a584 2
	strncpy( env_region.reg_mater.ma_matparm, cp,
		sizeof(rp->reg_mater.ma_matparm) );
@


9.2
log
@Changed to using rt_structparse's hooked function feature,
rather than the magic [3] element of RGB arrays.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: /m/cad/rt/RCS/sh_text.c,v 9.1 89/05/19 05:59:46 mike Rel3_5 $ (BRL)";
d268 3
a270 3
register struct region *rp;
char	*matparm;
char	**dpp;
d368 3
a370 3
register struct region *rp;
char	*matparm;
char	**dpp;
@


9.1
log
@Release_3.5
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: sh_text.c,v 8.10 89/04/30 21:26:16 mike Exp $ (BRL)";
d38 1
d75 1
d83 1
a83 1
	"%C",	"transp",	0,			FUNC_NULL,
d86 1
a86 1
	"%C",	"transp",	offsetofarray(struct txt_specific, tx_transp),	FUNC_NULL,
d91 1
a91 1
	"%d",	"l",		TX_O(tx_n),		FUNC_NULL,	/*compat*/
d93 1
d98 24
d284 2
a285 1
	if( tp->tx_transp[3] != 0 )
d287 1
@


8.10
log
@The rand() macros now require a parameter which is the random number
table pointer to be used.  This provides perfectly "safe" access to
the random number tables in a parallel processing environment.
Each processor is seeded differently in worker.c
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: sh_text.c,v 8.9 89/04/28 06:16:04 mike Locked $ (BRL)";
@


8.9
log
@Fixed fixed Cray hack
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: sh_text.c,v 8.8 89/04/05 01:47:01 phil Locked $ (BRL)";
d418 1
a418 1
	if( rand0to1() >= 0.98 )  {
d422 2
a423 2
		i = ((double)i) * rand0to1();
		f = rand0to1();
@


8.8
log
@Fixed up Cray hack
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 8.7 89/04/04 05:02:11 mike Locked $ (BRL)";
d82 1
a82 1
	"%s",	"file",		8,			FUNC_NULL,
d299 1
a299 1
	"%C",	"b",		8,			FUNC_NULL,
@


8.7
log
@Converted to new way of representing structure offsets.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 8.6 89/03/29 15:32:34 mike Locked $ (BRL)";
d79 5
a83 1
#ifndef CRAY
a85 3
#else
	"%C",	"transp",	0,			FUNC_NULL,
	"%s",	"file",		1,			FUNC_NULL,
d296 5
a300 1
#ifndef CRAY
a302 3
#else
	"%C",	"a",		0,			FUNC_NULL,
	"%C",	"b",		1,			FUNC_NULL,
@


8.6
log
@removed color bias in texture and checker
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 8.5 89/03/11 05:27:17 phil Locked $ (BRL)";
d76 1
d80 2
a81 2
	"%C",	"transp",	(stroff_t)(TX_NULL->tx_transp),		FUNC_NULL,
	"%s",	"file",		(stroff_t)(TX_NULL->tx_file),		FUNC_NULL,
d83 2
a84 2
	"%C",	"transp",	(stroff_t)0,				FUNC_NULL,
	"%s",	"file",		(stroff_t)1,				FUNC_NULL,
d86 5
a90 5
	"%d",	"w",		(stroff_t)&(TX_NULL->tx_w),		FUNC_NULL,
	"%d",	"n",		(stroff_t)&(TX_NULL->tx_n),		FUNC_NULL,
	"%d",	"l",		(stroff_t)&(TX_NULL->tx_n),		FUNC_NULL,	/*compat*/
	"%d",	"fw",		(stroff_t)&(TX_NULL->tx_fw),		FUNC_NULL,
	(char *)0,(char *)0,	(stroff_t)0,				FUNC_NULL
d251 1
a251 1
	rt_structparse( matparm, txt_parse, (stroff_t)tp );
d271 1
a271 1
	rt_structprint(rp->reg_name, txt_parse, (stroff_t)rp->reg_udata);
d291 2
a292 1
#define CKR_NULL ((struct ckr_specific *)0)
d296 2
a297 2
	"%C",	"a",		(stroff_t)(CKR_NULL->ckr_a),		FUNC_NULL,
	"%C",	"b",		(stroff_t)(CKR_NULL->ckr_b),		FUNC_NULL,
d299 2
a300 2
	"%C",	"a",		(stroff_t)0,				FUNC_NULL,
	"%C",	"b",		(stroff_t)1,				FUNC_NULL,
d302 1
a302 1
	(char *)0,(char *)0,	(stroff_t)0,				FUNC_NULL
d347 1
a347 1
	rt_structparse( matparm, ckr_parse, (stroff_t)ckp );
d358 1
a358 1
	rt_structprint(rp->reg_name, ckr_parse, (stroff_t)rp->reg_udata);
@


8.5
log
@Type conversion problem in the bump mapping routine.  Added some
debugging in the process.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 8.4 89/01/09 06:07:25 phil Locked $ (BRL)";
d215 3
a217 3
			(r+0.5) * rt_inv255,
			(g+0.5) * rt_inv255,
			(b+0.5) * rt_inv255 );
d324 3
a326 3
		(cp[0]+0.5) * rt_inv255,
		(cp[1]+0.5) * rt_inv255,
		(cp[2]+0.5) * rt_inv255 );
@


8.4
log
@Moved env_region into do.c, sigh.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 8.3 88/12/27 16:35:17 mike Locked $ (BRL)";
d497 2
a498 2
	pertU = (*cp - 128) / 128.0;
	pertV = (*(cp+2) - 128) / 128.0;
d500 7
d509 3
@


8.3
log
@Converted matparse --> structparse
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 8.2 88/12/13 03:16:57 mike Locked $ (BRL)";
d30 1
a30 1
struct region	env_region;
@


8.2
log
@Improved complaints on error in texture file.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 8.1 88/10/05 00:33:31 mike Locked $ (BRL)";
d77 1
a77 1
struct matparse txt_parse[] = {
d79 2
a80 2
	"transp",	(mp_off_ty)(TX_NULL->tx_transp),"%C",
	"file",		(mp_off_ty)(TX_NULL->tx_file),	"%s",
d82 2
a83 2
	"transp",	(mp_off_ty)0,			"%C",
	"file",		(mp_off_ty)1,			"%s",
d85 5
a89 5
	"w",		(mp_off_ty)&(TX_NULL->tx_w),	"%d",
	"n",		(mp_off_ty)&(TX_NULL->tx_n),	"%d",
	"l",		(mp_off_ty)&(TX_NULL->tx_n),	"%d",	/*compat*/
	"fw",		(mp_off_ty)&(TX_NULL->tx_fw),	"%d",
	(char *)0,	(mp_off_ty)0,			(char *)0
d250 1
a250 1
	mlib_parse( matparm, txt_parse, (mp_off_ty)tp );
d270 1
a270 1
	mlib_print(rp->reg_name, txt_parse, (mp_off_ty)rp->reg_udata);
d292 1
a292 1
struct matparse ckr_parse[] = {
d294 2
a295 2
	"a",		(mp_off_ty)(CKR_NULL->ckr_a),	"%C",
	"b",		(mp_off_ty)(CKR_NULL->ckr_b),	"%C",
d297 2
a298 2
	"a",		(mp_off_ty)0,			"%C",
	"b",		(mp_off_ty)1,			"%C",
d300 1
a300 1
	(char *)0,	(mp_off_ty)0,			(char *)0
d345 1
a345 1
	mlib_parse( matparm, ckr_parse, (mp_off_ty)ckp );
d356 1
a356 1
	mlib_print(rp->reg_name, ckr_parse, (mp_off_ty)rp->reg_udata);
@


8.1
log
@Release_3.0
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 7.7 88/09/17 07:20:58 mike Exp $ (BRL)";
d104 2
a105 1
	register int i;
d117 2
a118 1
		if( fread(linebuf,1,tp->tx_fw*3,fp) != tp->tx_fw*3 ) {
d120 1
a120 1
			tp->tx_file[0] = '\0';
d122 1
d124 2
@


7.7
log
@cray-->CRAY.  The C compiler bug still remains.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 7.6 88/06/21 02:53:43 mike Locked $ (BRL)";
@


7.6
log
@Made number of scanlines (height) parameter be "n",
and width be "w", to be consistent with the BRLCAD convention,
as exhibited by pix-fb and many others.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 7.5 88/06/19 05:43:22 mike Locked $ (BRL)";
d78 1
a78 1
#ifndef cray
d288 1
a288 1
#ifndef cray
@


7.5
log
@Changed maximum bump map perturbation from 45 degrees to 90 degrees.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 7.4 88/05/14 02:28:28 mike Locked $ (BRL)";
d72 1
a72 1
	int	tx_l;		/* Length of pixels in lines */
d86 2
a87 1
	"l",		(mp_off_ty)&(TX_NULL->tx_l),	"%d",
d113 1
a113 1
		tp->tx_w * tp->tx_l * 3,
d115 1
a115 1
	for( i=0; i<tp->tx_l; i++ )  {
d184 1
a184 1
	y = ymin * (tp->tx_l-1);
d186 1
a186 1
	dy = (ymax - ymin) * (tp->tx_l-1);
d244 1
a244 1
	tp->tx_w = tp->tx_fw = tp->tx_l = -1;
d247 1
a247 1
	if( tp->tx_l < 0 )  tp->tx_l = tp->tx_w;
d489 1
a489 1
	j = swp->sw_uv.uv_v * (tp->tx_l-1);
@


7.4
log
@lint fixes
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 7.3 88/02/27 07:47:10 mike Locked $ (BRL)";
d491 2
a492 2
	pertU = (*cp - 128) / 256.0;
	pertV = (*(cp+2) - 128) / 256.0;
@


7.3
log
@Added support for material "envmap" -- an environment map,
with an arbitrary shader attached.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 7.2 88/01/26 05:55:04 mike Locked $ (BRL)";
d32 6
a37 3
HIDDEN int txt_setup(), txt_render(), txt_print(), txt_free();
HIDDEN int ckr_setup(), ckr_render(), ckr_print(), ckr_free();
HIDDEN int bmp_setup(), bmp_render(), bmp_print(), bmp_free();
d42 1
d52 1
a52 1
	mlib_one,	tstm_render,	mlib_zero,	mlib_zero,
d55 1
a55 1
	mlib_one,	star_render,	mlib_zero,	mlib_zero,
d61 1
a61 1
	envmap_setup,	mlib_zero,	mlib_zero,	mlib_zero,
d138 1
a138 1
HIDDEN
d260 1
a260 1
HIDDEN int
d270 1
a270 1
HIDDEN int
d321 1
d346 1
a346 1
HIDDEN int
d356 1
a356 1
HIDDEN int
d418 1
@


7.2
log
@Changed return codes from setup routines to 1, to honor new
return code convention for mlib_setup().
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 7.1 87/11/02 23:56:39 mike Locked $ (BRL)";
d30 2
d37 1
d56 3
d493 31
@


7.1
log
@Release 2.3
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 6.3 87/09/16 04:33:56 mike Exp $ (BRL)";
d35 1
a35 1
extern int mlib_zero();
d45 1
a45 1
	mlib_zero,	tstm_render,	mlib_zero,	mlib_zero,
d48 1
a48 1
	mlib_zero,	star_render,	mlib_zero,	mlib_zero,
d241 4
a244 1
	return( txt_read(tp) );
@


6.3
log
@Default checker pattern is now white and black, rather than all black.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 6.2 87/09/03 01:30:37 mike Locked $ (BRL)";
@


6.2
log
@Added incremental resolution capability.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 6.1 87/07/11 07:59:26 mike Rel $ (BRL)";
d321 1
d324 1
@


6.1
log
@Release 2.0
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 5.6 87/07/10 05:06:07 mike Exp $ (BRL)";
d196 2
a197 4
	if( tp->tx_transp[3] == 0 ||
	    r != (tp->tx_transp[0]) ||
	    g != (tp->tx_transp[1]) ||
	    b != (tp->tx_transp[2]) )  {
d204 4
@


5.6
log
@When converting integer RGB to 0..1 floats, changed to
add 0.5 and multiply by rt_inv255.
Also changed to handle transparency in the reflect/refract routines
at a higher level.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 5.5 87/07/06 15:09:30 mike Locked $ (BRL)";
@


5.5
log
@First stages of support for reg_transmit
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 5.4 87/06/27 06:46:23 mike Locked $ (BRL)";
d195 1
a195 6
	/*
	 * Transparency mapping is enabled, and we hit a transparent spot.
	 * Fire another ray to determine the actual color
	 */
#ifndef crayXX
/* UNICOS 2.0 BUG */
d200 4
a203 3
		FAST fastf_t f;
		f = 1.0 / 255.0;
		VSET( swp->sw_color, r * f, g * f, b * f );
d206 7
a212 19
#endif
	if( pp->pt_outhit->hit_dist >= INFINITY )  {
		rt_log("txt_render:  transparency on infinite object?\n");
		VSET( swp->sw_color, 0, 1, 0 );
		return(1);
	}
	if( (ap->a_level%100) > 5 )  {
		VSET( swp->sw_color, .1, .1, .1);
		return(1);
	}
	{
		auto struct application sub_ap;
		sub_ap = *ap;		/* struct copy */
		sub_ap.a_level = ap->a_level+1;
		VJOIN1( sub_ap.a_ray.r_pt, ap->a_ray.r_pt,
			pp->pt_outhit->hit_dist, ap->a_ray.r_dir );
		(void)rt_shootray( &sub_ap );
		VMOVE( swp->sw_color, sub_ap.a_color );
	}
a293 1
	auto struct uvcoord uv;
a294 1
	FAST fastf_t f;
d302 4
a305 2
	f = 1.0/255.;
	VSET( swp->sw_color, cp[0]*f, cp[1]*f, cp[2]*f );
@


5.4
log
@rendering parameter changes
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 5.3 87/06/27 03:58:31 phil Locked $ (BRL)";
d253 2
@


5.3
log
@added crude bump mapping
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 5.2 87/06/26 05:55:17 phil Locked $ (BRL)";
d129 1
a129 1
txt_render( ap, pp, swp )
d133 1
d136 1
a136 1
		(struct txt_specific *)pp->pt_regionp->reg_udata;
d236 1
a236 1
txt_setup( rp )
d238 2
d244 1
a244 1
	rp->reg_udata = (char *)tp;
d248 1
a248 1
	mlib_parse( rp->reg_mater.ma_matparm, txt_parse, (mp_off_ty)tp );
d300 1
a300 1
ckr_render( ap, pp, swp )
d304 1
d307 1
a307 1
		(struct ckr_specific *)pp->pt_regionp->reg_udata;
d326 1
a326 1
ckr_setup( rp )
d328 2
d334 2
a335 2
	rp->reg_udata = (char *)ckp;
	mlib_parse( rp->reg_mater.ma_matparm, ckr_parse, (mp_off_ty)ckp );
d366 1
a366 1
tstm_render( ap, pp, swp )
d370 1
d397 1
a397 1
star_render( ap, pp, swp )
d401 1
d440 1
a440 1
bmp_render( ap, pp, swp )
d444 1
d447 1
a447 1
		(struct txt_specific *)pp->pt_regionp->reg_udata;
d492 1
a492 4
	save = pp->pt_regionp->reg_udata;
	pp->pt_regionp->reg_udata = (char *)&junk;
	phong_render( ap, pp, swp );
	pp->pt_regionp->reg_udata = save;
@


5.2
log
@Added struct shadework support, separated shaders from
reflect/refract code, allowed stacking of shaders.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 5.1 87/06/24 22:15:31 mike Locked $ (BRL)";
d32 1
d50 3
d151 1
a152 8
	if( swp->sw_uv.uv_u < 0 || swp->sw_uv.uv_u > 1 || swp->sw_uv.uv_v < 0 || swp->sw_uv.uv_v > 1 )  {
		rt_log("txt_render:  bad u,v=%g,%g du,dv=%g,%g seg=%s\n",
			swp->sw_uv.uv_u, swp->sw_uv.uv_v,
			swp->sw_uv.uv_du, swp->sw_uv.uv_dv,
			pp->pt_inseg->seg_stp->st_name );
		VSET( swp->sw_color, 0, 1, 0 );
		return(1);
	}
d406 82
@


5.1
log
@Release 1.24
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 4.3 87/03/23 23:48:04 mike Exp $ (BRL)";
d37 1
a37 1
	"texture",	0,		0,
d40 1
a40 1
	"checker",	0,		0,
d43 1
a43 1
	"testmap",	0,		0,
d46 1
a46 1
	"fakestar",	0,		0,
d49 1
a49 1
	(char *)0,	0,		0,
d92 1
a92 1
		rt_log("txt_render(%s):  can't open\n", tp->tx_file);
d125 4
a128 3
txt_render( ap, pp )
struct application *ap;
struct partition *pp;
a131 1
	auto struct uvcoord uv;
a137 5
	VJOIN1( pp->pt_inhit->hit_point, ap->a_ray.r_pt,
		pp->pt_inhit->hit_dist, ap->a_ray.r_dir );
	rt_functab[pp->pt_inseg->seg_stp->st_id].ft_uv(
		ap, pp->pt_inseg->seg_stp, pp->pt_inhit, &uv );

d144 1
a144 1
		VSET( ap->a_color, uv.uv_u, 0, uv.uv_v );
d148 1
a148 1
	if( uv.uv_u < 0 || uv.uv_u > 1 || uv.uv_v < 0 || uv.uv_v > 1 )  {
d150 2
a151 2
			uv.uv_u, uv.uv_v,
			uv.uv_du, uv.uv_dv,
d153 1
a153 1
		VSET( ap->a_color, 0, 1, 0 );
d157 2
a158 2
	if( uv.uv_du > 0.125 )  uv.uv_du = 0.125;
	if( uv.uv_dv > 0.125 )  uv.uv_dv = 0.125;
d160 1
a160 1
	if( uv.uv_du < 0 || uv.uv_dv < 0 )  {
d162 1
a162 1
			uv.uv_u, uv.uv_v, uv.uv_du, uv.uv_dv,
d164 1
a164 1
		uv.uv_du = uv.uv_dv = 0;
d166 4
a169 4
	xmin = uv.uv_u - uv.uv_du;
	xmax = uv.uv_u + uv.uv_du;
	ymin = uv.uv_v - uv.uv_dv;
	ymax = uv.uv_v + uv.uv_dv;
d209 1
a209 1
		VSET( ap->a_color, r * f, g * f, b * f );
d215 1
a215 1
		VSET( ap->a_color, 0, 1, 0 );
d219 1
a219 1
		VSET( ap->a_color, .1, .1, .1);
d229 1
a229 1
		VMOVE( ap->a_color, sub_ap.a_color );
d300 4
a303 3
ckr_render( ap, pp )
register struct application *ap;
register struct partition *pp;
d311 2
a312 7
	VJOIN1( pp->pt_inhit->hit_point, ap->a_ray.r_pt,
		pp->pt_inhit->hit_dist, ap->a_ray.r_dir );
	rt_functab[pp->pt_inseg->seg_stp->st_id].ft_uv(
		ap, pp->pt_inseg->seg_stp, pp->pt_inhit, &uv );

	if( (uv.uv_u < 0.5 && uv.uv_v < 0.5) ||
	    (uv.uv_u >=0.5 && uv.uv_v >=0.5) )  {
d318 1
a318 1
	VSET( ap->a_color, cp[0]*f, cp[1]*f, cp[2]*f );
d363 4
a366 3
tstm_render( ap, pp )
register struct application *ap;
register struct partition *pp;
d368 1
a368 7
	auto struct uvcoord uv;

	VJOIN1( pp->pt_inhit->hit_point, ap->a_ray.r_pt,
		pp->pt_inhit->hit_dist, ap->a_ray.r_dir );
	rt_functab[pp->pt_inseg->seg_stp->st_id].ft_uv(
		ap, pp->pt_inseg->seg_stp, pp->pt_inhit, &uv );
	VSET( ap->a_color, uv.uv_u, 0, uv.uv_v );
d393 1
a393 1
star_render( ap, pp )
d396 1
d405 1
a405 1
		VSCALE( ap->a_color, star_colors[i], f );
d407 1
a407 1
		VSETALL( ap->a_color, 0 );
@


4.3
log
@Revised for new material property interface.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 4.2 87/02/13 00:02:54 mike Exp $ (BRL)";
@


4.2
log
@Release 1.20 -- First Formal Release
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 4.1 86/12/29 03:48:51 mike Rel1 $ (BRL)";
d30 23
d242 1
a242 1
int
a248 1
	rp->reg_ufunc = txt_render;
a257 2
	if(rdebug&RDEBUG_MATERIAL)
		mlib_print(rp->reg_name, txt_parse, (mp_off_ty)tp);
d261 23
d304 1
a304 1
HIDDEN
d333 1
a333 1
int
a339 2
	bzero( (char *)ckp, sizeof(struct ckr_specific) );
	rp->reg_ufunc = ckr_render;
a341 2
	if(rdebug&RDEBUG_MATERIAL)
		mlib_print(rp->reg_name, ckr_parse, (mp_off_ty)ckp);
d346 21
a366 1
 *			T E S T M A P _ R E N D E R
d372 1
a372 1
testmap_render( ap, pp )
a385 12
/*
 *			T M A P _ S E T U P
 */
tmap_setup( rp )
register struct region *rp;
{
	rp->reg_ufunc = testmap_render;
	rp->reg_udata = (char *)0;
	return(1);
}


a421 12
}

/*
 *			S T A R _ S E T U P
 */
int
star_setup( rp )
register struct region *rp;
{
	rp->reg_ufunc = star_render;
	rp->reg_udata = (char *)0;
	return(1);
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 3.15 86/12/24 04:27:12 mike Locked $ (BRL)";
@


3.15
log
@Made checker patterns work right.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 3.14 86/12/18 16:02:09 mike Locked $ (BRL)";
@


3.14
log
@rdebug.h separated from librt/debug.h
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 3.13 86/11/07 02:46:25 mike Locked $ (BRL)";
a113 1
	fastf_t f;
d126 1
a126 1
		VSET( ap->a_color, uv.uv_u*255, 0, uv.uv_v*255 );
d189 1
d242 2
a243 2
	char	ckr_a[8];	/* first RGB */
	char	ckr_b[8];	/* second RGB */
d269 2
a270 1
	register char *cp;
d283 2
a284 1
	VSET( ap->a_color, cp[0]*255, cp[1]*255, cp[2]*255 );
@


3.13
log
@Changed so that computation of hit_point and hit_norm is done
in the individual material routines, and only as much as needed.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 3.12 86/11/04 21:05:57 mike Locked $ (BRL)";
d28 1
d31 1
a31 1
	char	tx_transp[4];	/* RGB for transparency */
d42 5
a46 2
	"transp",	(int)(TX_NULL->tx_transp),	"%C",
	"file",		(int)(TX_NULL->tx_file),	"%s",
d48 4
a51 4
	"w",		(int)&(TX_NULL->tx_w),		"%d",
	"l",		(int)&(TX_NULL->tx_l),		"%d",
	"fw",		(int)&(TX_NULL->tx_fw),		"%d",
	(char *)0,	0,				(char *)0
d184 1
a184 1
#ifndef cray
d187 3
a189 3
	    r != (tp->tx_transp[0]&0xFF) ||
	    g != (tp->tx_transp[1]&0xFF) ||
	    b != (tp->tx_transp[2]&0xFF) )  {
d231 1
a231 1
	mlib_parse( rp->reg_mater.ma_matparm, txt_parse, (char *)tp );
d236 2
a237 1
mlib_print("txt_setup", txt_parse, (char *)tp);
d242 2
a243 3
	int	ckr_r[2];
	int	ckr_g[2];
	int	ckr_b[2];
d248 8
a255 6
	"r",		(int)&(CKR_NULL->ckr_r[0]),	"%d",
	"g",		(int)&(CKR_NULL->ckr_g[0]),	"%d",
	"b",		(int)&(CKR_NULL->ckr_b[0]),	"%d",
	"R",		(int)&(CKR_NULL->ckr_r[1]),	"%d",
	"G",		(int)&(CKR_NULL->ckr_g[1]),	"%d",
	"B",		(int)&(CKR_NULL->ckr_b[1]),	"%d"
d269 1
d278 1
a278 1
		VSET( ap->a_color, ckp->ckr_r[0], ckp->ckr_g[0], ckp->ckr_b[0] );
d280 1
a280 1
		VSET( ap->a_color, ckp->ckr_r[1], ckp->ckr_g[1], ckp->ckr_b[1] );
d282 1
d298 3
a300 1
	mlib_parse( rp->reg_mater.ma_matparm, ckr_parse, (char *)ckp );
d383 1
@


3.12
log
@Improved fake stars

@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 3.11 86/10/29 04:51:18 mike Locked $ (BRL)";
d112 2
d264 2
d307 2
@


3.11
log
@Added fakestar function
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 3.10 86/09/23 17:12:41 mike Locked $ (BRL)";
d320 18
d347 7
a353 6
	if( rand0to1() > 0.95 )  {
		/* Stars have color.  may overflow 1.0 */
		VSET( ap->a_color,
			rand0to1()+0.5,
			rand0to1()+0.5,
			rand0to1()+0.5 );
@


3.10
log
@Minor cray nits.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 3.9 86/08/12 05:50:59 mike Exp $ (BRL)";
d27 1
d317 31
@


3.9
log
@Changed to find #include files with CC -I../h
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 3.8 86/07/31 08:29:37 mike Exp $ (BRL)";
d29 1
a34 1
	char	tx_transp[4];	/* RGB for transparency */
d39 2
d42 1
a45 3
#ifndef cray
	"transp",	(int)(TX_NULL->tx_transp),	"%C",
#endif
d101 1
a101 1
	struct txt_specific *tp =
d177 2
d187 1
@


3.8
log
@Cray braindamage
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 3.7 86/07/30 03:56:40 mike Exp $ (BRL)";
d23 4
a26 4
#include "../h/machine.h"
#include "../h/vmath.h"
#include "../h/raytrace.h"
#include "material.h"
@


3.7
log
@Preload texture maps at prep time.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 3.6 86/07/28 22:52:56 mike Exp $ (BRL)";
d29 1
a29 1
	char	*tx_file[128];	/* Filename */
d34 1
a34 1
	unsigned char tx_transp[4];	/* RGB for transparency */
d39 1
a39 1
	"file",		(int)&(TX_NULL->tx_file[0]),	"%s",
d43 3
a45 1
	"transp",	(int)&(TX_NULL->tx_transp[0]),	"%C",
d178 3
a180 3
	    r != tp->tx_transp[0] ||
	    g != tp->tx_transp[1] ||
	    b != tp->tx_transp[2] )  {
@


3.6
log
@Added support for transparent textures.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 3.5 86/07/24 06:05:39 mike Exp $ (BRL)";
d225 1
a225 1
	return(1);
@


3.5
log
@Added uvcoord code, conical ray divergance.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 3.4 86/07/24 03:58:22 mike Exp $ (BRL)";
d34 1
d39 1
a39 1
	"file",		(int)(TX_NULL->tx_file),	"%s",
d43 1
d158 1
a158 1
		register int i;
d161 2
a162 1
		for( i=0; i<dx; i++ )  {
d168 33
a200 2
	f = 1.0 / ( 255 * dx * dy );
	VSET( ap->a_color, r * f, g * f, b * f );
d224 1
@


3.4
log
@Conversion to uvcoord, general cleanup.
@
text
@d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 3.3 86/07/19 04:40:07 mike Exp $ (BRL)";
d94 2
a95 2
register struct application *ap;
register struct partition *pp;
d97 1
a97 1
	register struct txt_specific *tp =
d100 6
a105 1
	register unsigned char *cp;
d119 48
a166 5
	/* u is left->right index, v is line number */
	cp = (unsigned char *)tp->tx_pixels +
	     ((int) (uv.uv_v*(tp->tx_l-1))) * tp->tx_w * 3 +	/* v */
	     ((int) (uv.uv_u*(tp->tx_w-1))) * 3;
	VSET( ap->a_color, *cp++/255., *cp++/255., *cp++/255.);
@


3.3
log
@Added checker texture
@
text
@d10 1
a10 1
v *	SECAD/VLD Computing Consortium, Bldg 394
d19 1
a19 1
static char RCStext[] = "@@(#)$Header: text.c,v 3.2 86/07/17 18:33:10 mike Exp $ (BRL)";
d45 13
d59 24
d99 1
a99 1
	auto fastf_t uv[2];
d103 1
a103 1
		pp->pt_inseg->seg_stp, pp->pt_inhit, uv );
d105 7
a111 4
	/* If File could not be opened -- give debug colors */
top:
	if( tp->tx_file[0] == '\0' )  {
		VSET( ap->a_color, uv[0]*255, 0, uv[1]*255 );
a113 28
	/* Dynamic load of file -- don't read until first pixel needed */
	if( tp->tx_pixels == (char *)0 )  {
		char *linebuf;
		register FILE *fp;
		register int i;

		if( (fp = fopen(tp->tx_file, "r")) == NULL )  {
			rt_log("txt_render(%s):  can't open\n", tp->tx_file);
			tp->tx_file[0] = '\0';
			goto top;
		}
		linebuf = rt_malloc(tp->tx_fw*3,"texture file line");
		tp->tx_pixels = rt_malloc(
			tp->tx_w * tp->tx_l * 3,
			tp->tx_file );
		for( i=0; i<tp->tx_l; i++ )  {
			if( fread(linebuf,1,tp->tx_fw*3,fp) != tp->tx_fw*3 ) {
				rt_log("text_uvget: read error on %s\n", tp->tx_file);
				tp->tx_file[0] = '\0';
				(void)fclose(fp);
				rt_free(linebuf,"file line, error");
				goto top;
			}
			bcopy( linebuf, tp->tx_pixels + i*tp->tx_w*3, tp->tx_w*3 );
		}
		(void)fclose(fp);
		rt_free(linebuf,"texture file line");
	}
d116 2
a117 2
	     ((int) (uv[1]*(tp->tx_l-1))) * tp->tx_w * 3 +	/* v */
	     ((int) (uv[0]*(tp->tx_w-1))) * 3;
d171 1
a171 1
	auto fastf_t uv[2];
d174 1
a174 1
		pp->pt_inseg->seg_stp, pp->pt_inhit, uv );
d176 2
a177 2
	if( (uv[0] < 0.5 && uv[1] < 0.5) ||
	    (uv[0] >=0.5 && uv[1] >=0.5) )  {
d205 1
a205 1
 *  Mostly useful for debugging ft_fv() routines.
d212 1
a212 1
	auto fastf_t uv[2];
d215 2
a216 2
		pp->pt_inseg->seg_stp, pp->pt_inhit, uv );
	VSET( ap->a_color, uv[0], 0, uv[1] );
@


3.2
log
@Names shortened for non-FLEXNAMES systems (cray),
and converted to using stdio for all I/O.
@
text
@d10 1
a10 1
 *	SECAD/VLD Computing Consortium, Bldg 394
d19 1
a19 1
static char RCStext[] = "@@(#)$Header: rt.c,v 3.1 86/06/17 21:13:54 mike Exp $ (BRL)";
a44 1
extern txt_render();
a45 21
int
txt_setup( rp )
register struct region *rp;
{
	register struct txt_specific *tp;

	GETSTRUCT( tp, txt_specific );
	rp->reg_ufunc = txt_render;
	rp->reg_udata = (char *)tp;

	tp->tx_file[0] = '\0';
	tp->tx_w = tp->tx_fw = tp->tx_l = -1;
	mlib_parse( rp->reg_mater.ma_matparm, txt_parse, (char *)tp );
	if( tp->tx_w < 0 )  tp->tx_w = 512;
	if( tp->tx_l < 0 )  tp->tx_l = tp->tx_w;
	if( tp->tx_fw < 0 )  tp->tx_fw = tp->tx_w;
	tp->tx_pixels = (char *)0;
	return(1);
}


d55 1
d111 79
d195 1
@


3.1
log
@New somewhat object-oriented material-property version
@
text
@d5 12
d18 4
d28 1
a28 1
struct texture_specific {
d35 1
a35 1
#define TX_NULL	((struct texture_specific *)0)
d37 1
a37 1
struct matparse texture_parse[] = {
d45 1
a45 1
extern texture_render();
d48 1
a48 1
texture_setup( rp )
d51 1
a51 1
	register struct texture_specific *tp;
d53 2
a54 2
	GETSTRUCT( tp, texture_specific );
	rp->reg_ufunc = texture_render;
d59 1
a59 1
	matlib_parse( rp->reg_mater.ma_matparm, texture_parse, (char *)tp );
a63 1
	matlib_print( "texture", texture_parse, (char *)tp );
d69 1
a69 1
 *  			T E X T U R E _ R E N D E R
d77 1
a77 1
texture_render( ap, pp )
d81 2
a82 2
	register struct texture_specific *tp =
		(struct texture_specific *)pp->pt_regionp->reg_udata;
d98 1
a98 1
		register int fd;
d101 2
a102 2
		if( (fd = open(tp->tx_file, 0)) < 0 )  {
			rt_log("texture_render(%s):  can't open\n", tp->tx_file);
d111 1
a111 1
			if( read(fd,linebuf,tp->tx_fw*3) != tp->tx_fw*3 )  {
d114 1
a114 1
				(void)close(fd);
d120 1
a120 1
		(void)close(fd);
d150 1
a150 1
 *			T E S T M A P _ S E T U P
d152 1
a152 1
testmap_setup( rp )
@


3.0
log
@rt/ and librt/ separated,
global datastructures simplified.
@
text
@d8 3
a10 1
#include "text.h"
d12 8
a19 1
extern char *rt_malloc();
d21 6
a26 6
struct texture txt = {
	"./text.pix",
	512,
	512,
	512,
	0
d28 25
d54 1
a54 1
 *  			T E X T _ U V G E T
d62 3
a64 4
unsigned char *
text_uvget( tp, uvp )
register struct texture *tp;
fastf_t *uvp;
d66 9
a74 2
tp = &txt;	/* HACK */
	/* If File could not be opened -- give rt_g.debug colors */
d76 3
a78 6
	if( tp->tx_file == (char *)0 )  {
		static char ret[3];
		ret[0] = uvp[0]*255;
		ret[1] = 0;
		ret[2] = uvp[1]*255;
		return((unsigned char *)ret);
d87 2
a88 2
			perror(tp->tx_file);
			tp->tx_file = (char *)0;
d98 1
a98 1
				tp->tx_file = (char *)0;
d109 34
a142 3
	return( (unsigned char *)tp->tx_pixels +
		((int) (uvp[1]*(tp->tx_l-1))) * tp->tx_w * 3 +	/* v */
		((int) (uvp[0]*(tp->tx_w-1))) * 3 );
@


2.2
log
@rt and librt separated
@
text
@d10 1
a10 1
extern char *vmalloc();
d34 1
a34 1
	/* If File could not be opened -- give debug colors */
d54 2
a55 2
		linebuf = vmalloc(tp->tx_fw*3,"texture file line");
		tp->tx_pixels = vmalloc(
d60 1
a60 1
				rtlog("text_uvget: read error on %s\n", tp->tx_file);
d63 1
a63 1
				vfree(linebuf,"file line, error");
d69 1
a69 1
		vfree(linebuf,"texture file line");
@


2.1
log
@Version 2 of RT
@
text
@a13 1
	64,
d15 2
a16 1
	64,
@
