head	1.38;
access;
symbols
	ansi-20040405-merged:1.34.2.2
	postmerge-20040405-ansi:1.36
	premerge-20040404-ansi:1.35
	postmerge-autoconf:1.35
	autoconf-freeze:1.34.10.2
	premerge-autoconf:1.35
	ansi-20040316-freeze:1.34.2.1
	postmerge-20040315-windows:1.35
	premerge-20040315-windows:1.35
	windows-20040315-freeze:1.34.4.1
	autoconf-20031203:1.34
	autoconf-20031202:1.34
	autoconf-branch:1.34.0.10
	phong-branch:1.34.0.8
	photonmap-branch:1.34.0.6
	rel-6-1-DP:1.34
	windows-branch:1.34.0.4
	rel-6-0-2:1.32
	ansi-branch:1.34.0.2
	rel-6-0-1-branch:1.32.0.2
	hartley-6-0-post:1.33
	hartley-6-0-pre:1.32
	rel-6-0-1:1.32
	rel-6-0:1.32
	rel-5-4:1.23
	offsite-5-3-pre:1.27
	rel-5-3:1.23
	rel-5-2:1.23
	rel-5-1-branch:1.23.0.2
	rel-5-1:1.23
	rel-5-0:1.19
	rel-5-0-beta:1.17
	rel-4-5:1.15
	ctj-4-5-post:1.14
	ctj-4-5-pre:1.14;
locks; strict;
comment	@ * @;


1.38
date	2004.05.21.18.07.27;	author morrison;	state dead;
branches;
next	1.37;

1.37
date	2004.05.10.15.30.45;	author erikg;	state Exp;
branches;
next	1.36;

1.36
date	2004.04.05.07.43.37;	author morrison;	state Exp;
branches;
next	1.35;

1.35
date	2004.02.02.17.39.13;	author morrison;	state Exp;
branches;
next	1.34;

1.34
date	2002.08.20.17.07.51;	author jra;	state Exp;
branches
	1.34.2.1
	1.34.4.1
	1.34.10.1;
next	1.33;

1.33
date	2002.08.15.20.55.03;	author hartley;	state Exp;
branches;
next	1.32;

1.32
date	2001.11.05.21.20.06;	author morrison;	state Exp;
branches;
next	1.31;

1.31
date	2001.10.17.07.40.02;	author morrison;	state Exp;
branches;
next	1.30;

1.30
date	2001.04.20.22.29.31;	author morrison;	state Exp;
branches;
next	1.29;

1.29
date	2001.04.02.21.38.04;	author morrison;	state Exp;
branches;
next	1.28;

1.28
date	2001.03.31.01.57.02;	author morrison;	state Exp;
branches;
next	1.27;

1.27
date	2000.10.19.19.19.45;	author butler;	state Exp;
branches;
next	1.26;

1.26
date	2000.09.08.05.56.50;	author mike;	state Exp;
branches;
next	1.25;

1.25
date	2000.08.20.01.27.47;	author butler;	state Exp;
branches;
next	1.24;

1.24
date	2000.07.25.16.40.38;	author butler;	state Exp;
branches;
next	1.23;

1.23
date	2000.02.19.21.05.02;	author butler;	state Exp;
branches;
next	1.22;

1.22
date	99.12.30.16.18.39;	author jra;	state Exp;
branches;
next	1.21;

1.21
date	99.11.12.20.55.00;	author mike;	state Exp;
branches;
next	1.20;

1.20
date	99.10.30.03.06.24;	author butler;	state Exp;
branches;
next	1.19;

1.19
date	99.07.02.22.20.40;	author mike;	state Exp;
branches;
next	1.18;

1.18
date	99.07.01.20.08.46;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	98.09.22.01.29.54;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	98.06.30.22.54.17;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	97.12.31.09.01.40;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	97.01.07.23.59.19;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	96.09.27.04.30.27;	author butler;	state Exp;
branches;
next	1.12;

1.12
date	96.08.31.08.46.01;	author butler;	state Exp;
branches;
next	1.11;

1.11
date	96.08.31.08.29.28;	author butler;	state Exp;
branches;
next	1.10;

1.10
date	96.08.30.00.08.21;	author butler;	state Exp;
branches;
next	1.9;

1.9
date	96.08.29.06.43.04;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	96.08.27.07.33.51;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	96.08.16.22.13.16;	author butler;	state Exp;
branches;
next	1.6;

1.6
date	96.08.14.03.46.31;	author butler;	state Exp;
branches;
next	1.5;

1.5
date	96.07.22.20.34.18;	author jra;	state Exp;
branches;
next	1.4;

1.4
date	96.07.12.15.02.06;	author jra;	state Exp;
branches;
next	1.3;

1.3
date	96.06.26.04.31.35;	author butler;	state Exp;
branches;
next	1.2;

1.2
date	96.06.21.05.37.28;	author butler;	state Exp;
branches;
next	1.1;

1.1
date	95.10.20.04.43.53;	author butler;	state Exp;
branches;
next	;

1.34.2.1
date	2002.09.19.18.01.25;	author morrison;	state Exp;
branches;
next	1.34.2.2;

1.34.2.2
date	2004.03.17.21.18.32;	author morrison;	state Exp;
branches;
next	;

1.34.4.1
date	2004.03.11.23.43.02;	author morrison;	state Exp;
branches;
next	;

1.34.10.1
date	2004.02.12.18.38.49;	author erikg;	state Exp;
branches;
next	1.34.10.2;

1.34.10.2
date	2004.03.15.14.07.13;	author erikg;	state Exp;
branches;
next	;


desc
@gaussian plume prototype shader
@


1.38
log
@moved to src/
@
text
@/*
 *	S H _ G A U S S . C
 *
 *  To add a new shader to the "rt" program:
 *
 *	1) Copy this file to sh_shadername.c
 *	2) edit sh_shadername.c:
 *		change "G A U S S" to "S H A D E R N A M E"
 *		change "gauss"   to "shadername"
 *		Set a new number for the gauss_MAGIC define
 *		define shader specific structure and defaults
 *		edit/build parse table for bu_structparse from gauss_parse
 *		edit/build shader_mfuncs tables from gauss_mfuncs for
 *			each shader name being built.
 *		edit the gauss_setup function to do shader-specific setup
 *		edit the gauss_render function to do the actual rendering
 *	3) Edit view.c to add extern for gauss_mfuncs and call to mlib_add
 *		to function view_init()
 *	4) Edit Cakefile to add shader file to "FILES" and "RT_OBJ" macros.
 *	5) replace this list with a description of the shader, its parameters
 *		and use.
 *
 *  Author -
 *	Lee A. Butler
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" license agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1998-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/liboptical/sh_gauss.c,v 1.37 2004/05/10 15:30:45 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef HAVE_STRING_H
#include <string.h>
#endif
#include <math.h>
#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "rtgeom.h"
#include "shadefuncs.h"
#include "shadework.h"
#include "rtprivate.h"

extern int rr_render(struct application	*ap,
		     struct partition	*pp,
		     struct shadework   *swp);

/* The internal representation of the solids must be stored so that we
 * can access their parameters at shading time.  This is done with
 * a list of "struct reg_db_internals".  Each struct holds the
 * representation of one of the solids which make up the region.
 */
#define DBINT_MAGIC 0xDECCA
struct reg_db_internals {
	struct bu_list	l;
	struct rt_db_internal ip;	/* internal rep from rtgeom.h */
	struct soltab	*st_p;
	vect_t one_sigma;
	mat_t	ell2model;	/* maps ellipse coord to model coord */
	mat_t	model2ell;	/* maps model coord to ellipse coord */
};
#define DBINT_MAGIC 0xDECCA
#define CK_DBINT(_p) BU_CKMAG( _p, DBINT_MAGIC, "struct reg_db_internals" )

struct tree_bark {
	struct db_i	*dbip;
	struct bu_list	*l;	/* lists solids in region (built in setup) */
	const char	*name;
	struct gauss_specific *gs;
};


#define gauss_MAGIC 0x6a05    /* make this a unique number for each shader */
#define CK_gauss_SP(_p) BU_CKMAG(_p, gauss_MAGIC, "gauss_specific")

/*
 * the shader specific structure contains all variables which are unique
 * to any particular use of the shader.
 */
struct gauss_specific {
	long	magic;	/* magic # for memory validity check, must come 1st */
	double	gauss_sigma;	/* # std dev represented by ell bounds */
	point_t	gauss_min;
	point_t gauss_max;
	mat_t	gauss_m_to_sh;	/* model to shader space matrix */
	struct	bu_list	dbil;
};


/* The default values for the variables in the shader specific structure */
static const
struct gauss_specific gauss_defaults = {
	gauss_MAGIC,
	4.0,
	{0.0, 0.0, 0.0}, /* min */
	{0.0, 0.0, 0.0}, /* max */
	{	0.0, 0.0, 0.0, 0.0,
		0.0, 0.0, 0.0, 0.0,
		0.0, 0.0, 0.0, 0.0,
		0.0, 0.0, 0.0, 0.0 }
	};

#define SHDR_NULL	((struct gauss_specific *)0)
#define SHDR_O(m)	offsetof(struct gauss_specific, m)
#define SHDR_AO(m)	bu_offsetofarray(struct gauss_specific, m)


/* description of how to parse/print the arguments to the shader
 * There is at least one line here for each variable in the shader specific
 * structure above
 */
struct bu_structparse gauss_print_tab[] = {
	{"%f",  1, "sigma",		SHDR_O(gauss_sigma),	BU_STRUCTPARSE_FUNC_NULL },
	{"",	0, (char *)0,		0,			BU_STRUCTPARSE_FUNC_NULL }

};
struct bu_structparse gauss_parse_tab[] = {
	{"i",	bu_byteoffset(gauss_print_tab[0]), "gauss_print_tab", 0, BU_STRUCTPARSE_FUNC_NULL },
	{"%f",  1, "s",			SHDR_O(gauss_sigma),	BU_STRUCTPARSE_FUNC_NULL },
	{"",	0, (char *)0,		0,			BU_STRUCTPARSE_FUNC_NULL }
};

HIDDEN int	gauss_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip), gauss_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
HIDDEN void	gauss_print(register struct region *rp, char *dp), gauss_free(char *cp);

/* The "mfuncs" structure defines the external interface to the shader.
 * Note that more than one shader "name" can be associated with a given
 * shader by defining more than one mfuncs struct in this array.
 * See sh_phong.c for an example of building more than one shader "name"
 * from a set of source functions.  There you will find that "glass" "mirror"
 * and "plastic" are all names for the same shader with different default
 * values for the parameters.
 */
struct mfuncs gauss_mfuncs[] = {
	{MF_MAGIC,	"gauss",	0,		MFI_NORMAL|MFI_HIT|MFI_UV,	0,
	gauss_setup,	gauss_render,	gauss_print,	gauss_free },

	{0,		(char *)0,	0,		0,		0,
	0,		0,		0,		0 }
};


static void
tree_solids(union tree *tp, struct tree_bark *tb, int op, struct resource *resp)
{
	RT_CK_TREE(tp);

	switch( tp->tr_op )  {
	case OP_NOP:
		return;

	case OP_SOLID: {
		struct reg_db_internals *dbint;
		matp_t mp;
		long sol_id;
		struct rt_ell_internal *ell_p;
		vect_t v;

		BU_GETSTRUCT( dbint, reg_db_internals );
		BU_LIST_MAGIC_SET( &(dbint->l), DBINT_MAGIC);

		if (tp->tr_a.tu_stp->st_matp)
			mp = tp->tr_a.tu_stp->st_matp;
		else
			mp = (matp_t)bn_mat_identity;

		/* Get the internal form of this solid & add it to the list */
		rt_db_get_internal(&dbint->ip, tp->tr_a.tu_stp->st_dp,
			tb->dbip, mp, resp);

		RT_CK_DB_INTERNAL(&dbint->ip);
		dbint->st_p = tp->tr_a.tu_stp;

		sol_id = dbint->ip.idb_type;

		if (sol_id < 0 || sol_id > rt_nfunctab ) {
			bu_log("Primitive ID %ld out of bounds\n", sol_id);
			rt_bomb("");
		}


		if (sol_id != ID_ELL) {

			if (op == OP_UNION)
				bu_log( "Non-ellipse \"union\" primitive of \"%s\" being ignored\n",
					tb->name);

			if (rdebug&RDEBUG_SHADE)
				bu_log(" got a primitive type %d \"%s\".  This primitive ain't no ellipse bucko!\n",
					sol_id, rt_functab[sol_id].ft_name);

			break;
		}


		ell_p = (struct rt_ell_internal *)dbint->ip.idb_ptr;

		if (rdebug&RDEBUG_SHADE)
			bu_log(" got a primitive type %d \"%s\"\n",
				sol_id,
				rt_functab[sol_id].ft_name);

		RT_ELL_CK_MAGIC(ell_p);

		if (rdebug&RDEBUG_SHADE) {
			VPRINT("point", ell_p->v); 
			VPRINT("a", ell_p->a); 
			VPRINT("b", ell_p->b); 
			VPRINT("c", ell_p->c); 
		}

		/* create the matrix that maps the coordinate system defined
		 * by the ellipse into model space, and get inverse for use
		 * in the _render() proc
		 */
		MAT_IDN(mp);
		VMOVE(v, ell_p->a);	VUNITIZE(v);
		mp[0] = v[0];	mp[4] = v[1];	mp[8] = v[2];

		VMOVE(v, ell_p->b);	VUNITIZE(v);
		mp[1] = v[0];	mp[5] = v[1];	mp[9] = v[2];		

		VMOVE(v, ell_p->c);	VUNITIZE(v);
		mp[2] = v[0];	mp[6] = v[1];	mp[10] = v[2];		

		MAT_DELTAS_VEC(mp, ell_p->v);

		MAT_COPY(dbint->ell2model, mp);
		bn_mat_inv(dbint->model2ell, mp);


		/* find scaling of gaussian puff in ellipsoid space */
		VSET(dbint->one_sigma,
			MAGNITUDE(ell_p->a) / tb->gs->gauss_sigma,
			MAGNITUDE(ell_p->b) / tb->gs->gauss_sigma,
			MAGNITUDE(ell_p->c) / tb->gs->gauss_sigma);


		if (rdebug&RDEBUG_SHADE) {
			VPRINT("sigma", dbint->one_sigma);
		}
		BU_LIST_APPEND(tb->l, &(dbint->l) );

		break;
	}
	case OP_UNION:
		tree_solids(tp->tr_b.tb_left, tb, tp->tr_op, resp);
		tree_solids(tp->tr_b.tb_right, tb, tp->tr_op, resp);
		break;

	case OP_NOT: bu_log("Warning: 'Not' region operator in %s\n",tb->name);
		tree_solids(tp->tr_b.tb_left, tb, tp->tr_op, resp);
		break;
	case OP_GUARD:bu_log("Warning: 'Guard' region operator in %s\n",tb->name);
		tree_solids(tp->tr_b.tb_left, tb, tp->tr_op, resp);
		break;
	case OP_XNOP:bu_log("Warning: 'XNOP' region operator in %s\n",tb->name);
		tree_solids(tp->tr_b.tb_left, tb, tp->tr_op, resp);
		break;

	case OP_INTERSECT:
	case OP_SUBTRACT:
	case OP_XOR:
		/* XXX this can get us in trouble if 1 solid is subtracted
		 * from less than all the "union" solids of the region.
		 */
		tree_solids(tp->tr_b.tb_left, tb, tp->tr_op, resp);
		tree_solids(tp->tr_b.tb_right, tb, tp->tr_op, resp);
		return;

	default:
		rt_bomb("rt_tree_region_assign: bad op\n");
	}
}

/*	G A U S S _ S E T U P
 *
 *	This routine is called (at prep time)
 *	once for each region which uses this shader.
 *	Any shader-specific initialization should be done here.
 */
HIDDEN int
gauss_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip)
                      	    
             		         
    			      	/* pointer to reg_udata in *rp */
             		     
           		      	/* New since 4.4 release */
{
	register struct gauss_specific	*gauss_sp;
	struct tree_bark tb;

	/* check the arguments */
	RT_CHECK_RTI(rtip);
	BU_CK_VLS( matparm );
	RT_CK_REGION(rp);


	if (rdebug&RDEBUG_SHADE)
		bu_log("gauss_setup(%s)\n", rp->reg_name);

	if (! rtip->useair)
		rt_bomb("gauss shader used and useair not set\n");


	/* Get memory for the shader parameters and shader-specific data */
	BU_GETSTRUCT( gauss_sp, gauss_specific );
	*dpp = (char *)gauss_sp;

	/* initialize the default values for the shader */
	memcpy(gauss_sp, &gauss_defaults, sizeof(struct gauss_specific) );

	/* parse the user's arguments for this use of the shader. */
	if (bu_struct_parse( matparm, gauss_parse_tab, (char *)gauss_sp ) < 0 )
		return(-1);

	/* We have to pick up the parameters for the gaussian puff now.
	 * They won't be available later.  So what we do is sneak a peak
	 * inside the region, make sure the first item in it is an ellipsoid
	 * solid, and if it is go steal a peek at its balls ... er ... make
	 * that definition/parameters.
	 */

	BU_LIST_INIT( &gauss_sp->dbil );
	tb.l = &gauss_sp->dbil;

	tb.dbip = rtip->rti_dbip;
	tb.name = rp->reg_name;
	tb.gs = gauss_sp;

	tree_solids ( rp->reg_treetop, &tb, OP_UNION, &rt_uniresource );


	/* XXX If this puppy isn't axis-aligned, we should come up with a
	 * matrix to rotate it into alignment.  We're going to have to do
	 * computation in the space defined by this ellipsoid.
	 */
/*	db_shader_mat(gauss_sp->gauss_m_to_sh, rtip, rp, gauss_sp->gauss_min,
		gauss_sp->gauss_max);
 */


	if (rdebug&RDEBUG_SHADE) {
		bu_struct_print( " Parameters:", gauss_print_tab, (char *)gauss_sp );
		bn_mat_print( "m_to_sh", gauss_sp->gauss_m_to_sh );
	}

	return(1);
}

/*
 *	G A U S S _ P R I N T
 */
HIDDEN void
gauss_print(register struct region *rp, char *dp)
{
	bu_struct_print( rp->reg_name, gauss_print_tab, (char *)dp );
}

/*
 *	G A U S S _ F R E E
 */
HIDDEN void
gauss_free(char *cp)
{
	register struct gauss_specific *gauss_sp =
		(struct gauss_specific *)cp;
	struct reg_db_internals *p;

	while (BU_LIST_WHILE(p, reg_db_internals, &gauss_sp->dbil) ) {
		BU_LIST_DEQUEUE( &(p->l) );
		bu_free( p->ip.idb_ptr, "internal ptr" );
		bu_free( (char *)p, "gauss reg_db_internals" );
	}

	bu_free( cp, "gauss_specific" );
}


/*
 *
 * Evaluate the 3-D gaussian "puff" function:
 *
 * 1.0 / ( (2*PI)^(3/2) * sigmaX*sigmaY*sigmaZ )) * 
 *      exp( -0.5 * ( (x-ux)^2/sigmaX + (y-uy)^2/sigmaY + (z-uz)^2/sigmaZ ) )
 *
 * for a given point "pt" where the center of the puff is at {ux,uy,uz} and
 * the size of 1 standard deviation is {sigmaX,sigmaY,sigmaZ}
 */
static double
gauss_eval(fastf_t *pt, fastf_t *ell_center, fastf_t *sigma)
{
	double term2;
	point_t p;
	double val;

	VSUB2(p, pt, ell_center);
	p[X] *= p[X];
	p[Y] *= p[Y];
	p[Z] *= p[Z];

	term2 = (p[X]/sigma[X]) + (p[Y]/sigma[Y]) + (p[Z]/sigma[Z]);
	term2 *= term2;

	val = exp( -0.5 * term2 );

	if (rdebug&RDEBUG_SHADE)
		bu_log("pt(%g %g %g) term2:%g val:%g\n",
			V3ARGS(pt), term2, val);

	return val;
}

/*
 * Given a seg which participates in the partition we are shading evaluate
 * the transmission on the path
 */
static double
eval_seg(struct application *ap, struct reg_db_internals *dbint, struct seg *seg_p)
{
	double span;
	point_t pt;
	struct rt_ell_internal *ell_p = (struct rt_ell_internal *)dbint->ip.idb_ptr;
	double optical_density = 0.0;
	double step_dist;
	double dist;
	int steps;


	/* XXX Should map the ray into the coordinate system of the ellipsoid
	 * here, so that all computations are done in an axis-aligned system
	 * with the axes being the gaussian dimensions
	 */



	span = seg_p->seg_out.hit_dist - seg_p->seg_in.hit_dist;
	steps = (int)(span / 100.0 + 0.5);
	if ( steps < 2 ) steps = 2;

	step_dist = span / (double)steps;


	if (rdebug&RDEBUG_SHADE) {
		bu_log("Evaluating Segment:\n");
		bu_log("dist_in:%g dist_out:%g span:%g step_dist:%g steps:%d\n",
			seg_p->seg_in.hit_dist,
			seg_p->seg_out.hit_dist,
			span, step_dist, steps);

	}
#if 1
	for (dist=seg_p->seg_in.hit_dist ; dist < seg_p->seg_out.hit_dist ; dist += step_dist ) {
		VJOIN1(pt, ap->a_ray.r_pt, dist, ap->a_ray.r_dir);
		optical_density += gauss_eval(pt, ell_p->v, dbint->one_sigma);
	}


	return optical_density;
#else
	return gauss_eval(ell_p->v, ell_p->v, dbint->one_sigma);
#endif
}

/*
 *	G A U S S _ R E N D E R
 *
 *	This is called (from viewshade() in shade.c) once for each hit point
 *	to be shaded.  The purpose here is to fill in values in the shadework
 *	structure.
 */
int
gauss_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
                  	    
                	    
                	     	/* defined in material.h */
    			    	/* ptr to the shader-specific struct */
{
	register struct gauss_specific *gauss_sp =
		(struct gauss_specific *)dp;
	struct seg *seg_p;
	struct reg_db_internals *dbint_p;
	double optical_density = 0.0;

	/* check the validity of the arguments we got */
	RT_AP_CHECK(ap);
	RT_CHECK_PT(pp);
	CK_gauss_SP(gauss_sp);

	if (rdebug&RDEBUG_SHADE) {
		bu_struct_print( "gauss_render Parameters:", gauss_print_tab, (char *)gauss_sp );

		bu_log("r_pt(%g %g %g)  r_dir(%g %g %g)\n",
			V3ARGS(ap->a_ray.r_pt),
			V3ARGS(ap->a_ray.r_dir) );
	}

	BU_CK_LIST_HEAD(&swp->sw_segs->l);
	BU_CK_LIST_HEAD(&gauss_sp->dbil);


	/* look at each segment that participated in the ray partition(s) */
	for (BU_LIST_FOR(seg_p, seg, &swp->sw_segs->l) ) {

		if (rdebug&RDEBUG_SHADE) {
			bu_log("seg %g -> %g\n",
				seg_p->seg_in.hit_dist,
				seg_p->seg_out.hit_dist);
		}
		RT_CK_SEG(seg_p);
		RT_CK_SOLTAB(seg_p->seg_stp);

		/* check to see if the seg/solid is in this partition */
		if (bu_ptbl_locate( &pp->pt_seglist, (long *)seg_p ) != -1 )  {

			/* XXX You might use a bu_ptbl list of the solid pointers... */
			/* check to see if the solid is from this region */
			for (BU_LIST_FOR(dbint_p, reg_db_internals,
			    &gauss_sp->dbil)){

				CK_DBINT(dbint_p);

				if (dbint_p->st_p == seg_p->seg_stp) {
					/* The solid from the region is
					 * the solid from the segment
					 * from the partition
					 */
					optical_density +=
						eval_seg(ap, dbint_p, seg_p);
					break;
				}
			}
		} else {
				if (rdebug&RDEBUG_SHADE)
					bu_log("gauss_render() bittest failed\n");
		}
	}


	if (rdebug&RDEBUG_SHADE)
		bu_log("Optical Density %g\n", optical_density);

	/* get the path length right */
/*	if (pp->pt_inhit->hit_dist < 0.0)
		partition_dist = pp->pt_outhit->hit_dist;
	else
		partition_dist = (pp->pt_outhit->hit_dist - pp->pt_inhit->hit_dist);

	tau = optical_density * partition_dist;
 	swp->sw_transmit = exp(-tau); */

 	swp->sw_transmit = 1.0 - optical_density;

/*	VMOVE(swp->sw_color, pt);*/

	/* shader must perform transmission/reflection calculations
	 *
	 * 0 < swp->sw_transmit <= 1 causes transmission computations
	 * 0 < swp->sw_reflect <= 1 causes reflection computations
	 */
	if (swp->sw_reflect > 0 || swp->sw_transmit > 0 )
		(void)rr_render( ap, pp, swp );

	return(1);
}
@


1.37
log
@change conf.h to a wrapped config.h
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/liboptical/sh_gauss.c,v 1.36 2004/04/05 07:43:37 morrison Exp $ (ARL)";
@


1.36
log
@merge of ansi-6-0-branch into HEAD
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d43 5
a47 1
#include "conf.h"
@


1.35
log
@update copyright to include span through 2003
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_gauss.c,v 1.34 2002/08/20 17:07:51 jra Exp $ (ARL)";
d137 2
a138 2
HIDDEN int	gauss_setup(), gauss_render();
HIDDEN void	gauss_print(), gauss_free();
d158 1
a158 5
tree_solids(tp, tb, op, resp)
union tree *tp;
struct tree_bark *tb;
int op;
struct resource *resp;
d297 6
a302 6
gauss_setup( rp, matparm, dpp, mfp, rtip)
register struct region	*rp;
struct bu_vls		*matparm;
char			**dpp;	/* pointer to reg_udata in *rp */
struct mfuncs		*mfp;
struct rt_i		*rtip;	/* New since 4.4 release */
d369 1
a369 3
gauss_print( rp, dp )
register struct region *rp;
char	*dp;
d378 1
a378 2
gauss_free( cp )
char *cp;
d405 1
a405 4
gauss_eval(pt, ell_center, sigma)
point_t pt;
point_t ell_center;
vect_t sigma;
d433 1
a433 4
eval_seg(ap, dbint, seg_p)
struct application	*ap;
struct reg_db_internals *dbint;
struct seg *seg_p;
d487 5
a491 5
gauss_render( ap, pp, swp, dp )
struct application	*ap;
struct partition	*pp;
struct shadework	*swp;	/* defined in material.h */
char			*dp;	/* ptr to the shader-specific struct */
@


1.34
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d36 1
a36 1
 *	This software is Copyright (C) 1998 by the United States Army
d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_gauss.c,v 1.32 2001/11/05 21:20:06 morrison Exp $ (ARL)";
@


1.34.4.1
log
@sync to HEAD...
@
text
@d36 1
a36 1
 *	This software is Copyright (C) 1998-2004 by the United States Army
d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/liboptical/sh_gauss.c,v 1.35 2004/02/02 17:39:13 morrison Exp $ (ARL)";
@


1.34.10.1
log
@merge from HEAD
@
text
@d36 1
a36 1
 *	This software is Copyright (C) 1998-2004 by the United States Army
d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_gauss.c,v 1.35 2004/02/02 17:39:13 morrison Exp $ (ARL)";
@


1.34.10.2
log
@merge from head
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_gauss.c,v 1.34.10.1 2004/02/12 18:38:49 erikg Exp $ (ARL)";
@


1.34.2.1
log
@Initial ANSIfication
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_gauss.c,v 1.34 2002/08/20 17:07:51 jra Exp $ (ARL)";
d137 2
a138 2
HIDDEN int	gauss_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip), gauss_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
HIDDEN void	gauss_print(register struct region *rp, char *dp), gauss_free(char *cp);
d158 5
a162 1
tree_solids(union tree *tp, struct tree_bark *tb, int op, struct resource *resp)
d301 6
a306 6
gauss_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip)
                      	    
             		         
    			      	/* pointer to reg_udata in *rp */
             		     
           		      	/* New since 4.4 release */
d373 3
a375 1
gauss_print(register struct region *rp, char *dp)
d384 2
a385 1
gauss_free(char *cp)
d412 4
a415 1
gauss_eval(fastf_t *pt, fastf_t *ell_center, fastf_t *sigma)
d443 4
a446 1
eval_seg(struct application *ap, struct reg_db_internals *dbint, struct seg *seg_p)
d500 5
a504 5
gauss_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
                  	    
                	    
                	     	/* defined in material.h */
    			    	/* ptr to the shader-specific struct */
@


1.34.2.2
log
@sync branch with HEAD
@
text
@d36 1
a36 1
 *	This software is Copyright (C) 1998-2004 by the United States Army
d40 1
a40 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
@


1.33
log
@Converted from K&R to ANSI C - RFH
@
text
@d137 2
a138 2
HIDDEN int	gauss_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip), gauss_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
HIDDEN void	gauss_print(register struct region *rp, char *dp), gauss_free(char *cp);
d158 5
a162 1
tree_solids(union tree *tp, struct tree_bark *tb, int op, struct resource *resp)
d301 6
a306 6
gauss_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip)
                      	    
             		         
    			      	/* pointer to reg_udata in *rp */
             		     
           		      	/* New since 4.4 release */
d373 3
a375 1
gauss_print(register struct region *rp, char *dp)
d384 2
a385 1
gauss_free(char *cp)
d412 4
a415 1
gauss_eval(fastf_t *pt, fastf_t *ell_center, fastf_t *sigma)
d443 4
a446 1
eval_seg(struct application *ap, struct reg_db_internals *dbint, struct seg *seg_p)
d500 5
a504 5
gauss_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
                  	    
                	    
                	     	/* defined in material.h */
    			    	/* ptr to the shader-specific struct */
@


1.32
log
@Solid to Primitive naming convention conversions
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_gauss.c,v 1.31 2001/10/17 07:40:02 morrison Exp $ (ARL)";
d137 2
a138 2
HIDDEN int	gauss_setup(), gauss_render();
HIDDEN void	gauss_print(), gauss_free();
d158 1
a158 5
tree_solids(tp, tb, op, resp)
union tree *tp;
struct tree_bark *tb;
int op;
struct resource *resp;
d297 6
a302 6
gauss_setup( rp, matparm, dpp, mfp, rtip)
register struct region	*rp;
struct bu_vls		*matparm;
char			**dpp;	/* pointer to reg_udata in *rp */
struct mfuncs		*mfp;
struct rt_i		*rtip;	/* New since 4.4 release */
d369 1
a369 3
gauss_print( rp, dp )
register struct region *rp;
char	*dp;
d378 1
a378 2
gauss_free( cp )
char *cp;
d405 1
a405 4
gauss_eval(pt, ell_center, sigma)
point_t pt;
point_t ell_center;
vect_t sigma;
d433 1
a433 4
eval_seg(ap, dbint, seg_p)
struct application	*ap;
struct reg_db_internals *dbint;
struct seg *seg_p;
d487 5
a491 5
gauss_render( ap, pp, swp, dp )
struct application	*ap;
struct partition	*pp;
struct shadework	*swp;	/* defined in material.h */
char			*dp;	/* ptr to the shader-specific struct */
@


1.31
log
@Mac OS X warning and error fixes for non-production build
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_gauss.c,v 1.30 2001/04/20 22:29:31 morrison Exp $ (ARL)";
d195 1
a195 1
			bu_log("Solid ID %ld out of bounds\n", sol_id);
d203 1
a203 1
				bu_log( "Non-ellipse \"union\" solid of \"%s\" being ignored\n",
d207 1
a207 1
				bu_log(" got a solid type %d \"%s\".  This solid ain't no ellipse bucko!\n",
d217 1
a217 1
			bu_log(" got a solid type %d \"%s\"\n",
@


1.30
log
@CONST to const
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_gauss.c,v 1.29 2001/04/02 21:38:04 morrison Exp $ (ARL)";
d294 1
a294 1
/*	G A U S S _ S E T U P
@


1.29
log
@Deprecated bn_mat_copy() for new performance version of MAT_COPY() macro in h/vmath.h.
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_gauss.c,v 1.28 2001/03/31 01:57:02 morrison Exp $ (ARL)";
d82 1
a82 1
	CONST char	*name;
d105 1
a105 1
static CONST
@


1.28
log
@Deprecated bn_mat_idn() and bn_mat_zero(), updated calls to h/vmath.h's MAT_IDN() and MAT_ZERO() performance improved macros.
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_gauss.c,v 1.27 2000/10/19 19:19:45 butler Exp $ (ARL)";
d246 1
a246 1
		bn_mat_copy(dbint->ell2model, mp);
@


1.27
log
@Changes to compile under RedHat 7.0
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_gauss.c,v 1.26 2000/09/08 05:56:50 mike Exp $ (ARL)";
d234 1
a234 1
		bn_mat_idn(mp);
@


1.26
log
@
Tree routines need resource pointer.
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_gauss.c,v 1.25 2000/08/20 01:27:47 butler Exp $ (ARL)";
d46 3
@


1.25
log
@Eliminate compilation warnings, enhancements to sh_light.c
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_gauss.c,v 1.24 2000/07/25 16:40:38 butler Exp $ (ARL)";
d155 1
a155 1
tree_solids(tp, tb, op)
d159 1
d184 1
a184 1
			tb->dbip, mp);
d262 2
a263 2
		tree_solids(tp->tr_b.tb_left, tb, tp->tr_op);
		tree_solids(tp->tr_b.tb_right, tb, tp->tr_op);
d267 1
a267 1
		tree_solids(tp->tr_b.tb_left, tb, tp->tr_op);
d270 1
a270 1
		tree_solids(tp->tr_b.tb_left, tb, tp->tr_op);
d273 1
a273 1
		tree_solids(tp->tr_b.tb_left, tb, tp->tr_op);
d282 2
a283 2
		tree_solids(tp->tr_b.tb_left, tb, tp->tr_op);
		tree_solids(tp->tr_b.tb_right, tb, tp->tr_op);
d346 1
a346 1
	tree_solids ( rp->reg_treetop, &tb );
@


1.24
log
@Changes to use rtprivate.h instead of ../rt/rdebug.h
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_gauss.c,v 1.23 2000/02/19 21:05:02 butler Exp $ (ARL)";
@


1.23
log
@Changes to support movement of CLAMP() macro into vmath.h
Altered "if( " statements to "if (" for readability.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_gauss.c,v 1.22 1999/12/30 16:18:39 jra Exp $ (ARL)";
d53 1
a53 1
#include "../rt/rdebug.h"
d55 3
@


1.22
log
@Eliminated some unused variables
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_gauss.c,v 1.21 1999/11/12 20:55:00 mike Exp $ (ARL)";
d199 1
a199 1
			if( rdebug&RDEBUG_SHADE)
d209 1
a209 1
		if( rdebug&RDEBUG_SHADE)
d216 1
a216 1
		if( rdebug&RDEBUG_SHADE) {
d250 1
a250 1
		if( rdebug&RDEBUG_SHADE) {
d310 1
a310 1
	if( rdebug&RDEBUG_SHADE)
d325 1
a325 1
	if( bu_struct_parse( matparm, gauss_parse_tab, (char *)gauss_sp ) < 0 )
d354 1
a354 1
	if( rdebug&RDEBUG_SHADE) {
d424 1
a424 1
	if( rdebug&RDEBUG_SHADE)
d464 1
a464 1
	if( rdebug&RDEBUG_SHADE) {
d510 1
a510 1
	if( rdebug&RDEBUG_SHADE) {
d525 1
a525 1
		if( rdebug&RDEBUG_SHADE) {
d534 1
a534 1
		if( bu_ptbl_locate( &pp->pt_seglist, (long *)seg_p ) != -1 )  {
d554 1
a554 1
				if( rdebug&RDEBUG_SHADE)
d560 1
a560 1
	if( rdebug&RDEBUG_SHADE)
d581 1
a581 1
	if( swp->sw_reflect > 0 || swp->sw_transmit > 0 )
@


1.21
log
@
Changed from pt_solids_hit to pt_seglist; more general.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_gauss.c,v 1.20 1999/10/30 03:06:24 butler Exp $ (ARL)";
a500 1
	point_t pt;
a503 2
	double partition_dist;
	double tau;
d564 1
a564 1
	if (pp->pt_inhit->hit_dist < 0.0)
d570 1
a571 1
/* 	swp->sw_transmit = exp(-tau); */
@


1.20
log
@Moved mathtab/rand_half from rt into libbn
Expanded structparse to include description and default
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_gauss.c,v 1.19 1999/07/02 22:20:40 mike Exp $ (ARL)";
d537 1
a537 1
		if( bu_ptbl_locate( &pp->pt_solids_hit, (long *)seg_p->seg_stp ) != -1 )  {
@


1.19
log
@
Removed dependence on compat4.h
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_gauss.c,v 1.18 1999/07/01 20:08:46 mike Exp $ (ARL)";
a52 1
#include "../rt/mathtab.h"
@


1.18
log
@
compat4
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_gauss.c,v 1.17 1998/09/22 01:29:54 mike Exp $ (ARL)";
d95 1
a95 1
	struct	rt_list	dbil;
d122 2
a123 2
	{"%f",  1, "sigma",		SHDR_O(gauss_sigma),	FUNC_NULL },
	{"",	0, (char *)0,		0,			FUNC_NULL }
d128 2
a129 2
	{"%f",  1, "s",			SHDR_O(gauss_sigma),	FUNC_NULL },
	{"",	0, (char *)0,		0,			FUNC_NULL }
@


1.17
log
@Moved optical shaders from rt/ to liboptical/
The only modifications involved moving and splitting
rt/material.h into h/shadefuncs.h and h/shadework.h,
and in changing the calling sequence to mlib_setup() in rt/material.c

Now the only shader function called directly by RT is
in liboptical/init.c: optical_shader_init().
It adds all the individual shaders to the "mfuncs" shader list.
@
text
@d40 1
a40 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
d64 1
a64 1
	struct rt_list	l;
d72 1
a72 1
#define CK_DBINT(_p) RT_CKMAG( _p, DBINT_MAGIC, "struct reg_db_internals" )
d76 1
a76 1
	struct rt_list	*l;	/* lists solids in region (built in setup) */
d83 1
a83 1
#define CK_gauss_SP(_p) RT_CKMAG(_p, gauss_MAGIC, "gauss_specific")
d114 1
a114 1
#define SHDR_AO(m)	offsetofarray(struct gauss_specific, m)
d127 1
a127 1
	{"i",	bu_byteoffset(gauss_print_tab[0]), "gauss_print_tab", 0, FUNC_NULL },
d171 2
a172 2
		GETSTRUCT( dbint, reg_db_internals );
		RT_LIST_MAGIC_SET( &(dbint->l), DBINT_MAGIC);
d177 1
a177 1
			mp = (matp_t)rt_identity;
d189 1
a189 1
			rt_log("Solid ID %ld out of bounds\n", sol_id);
d197 1
a197 1
				rt_log( "Non-ellipse \"union\" solid of \"%s\" being ignored\n",
d201 1
a201 1
				rt_log(" got a solid type %d \"%s\".  This solid ain't no ellipse bucko!\n",
d211 1
a211 1
			rt_log(" got a solid type %d \"%s\"\n",
d228 1
a228 1
		mat_idn(mp);
d240 2
a241 2
		mat_copy(dbint->ell2model, mp);
		mat_inv(dbint->model2ell, mp);
d254 1
a254 1
		RT_LIST_APPEND(tb->l, &(dbint->l) );
d263 1
a263 1
	case OP_NOT: rt_log("Warning: 'Not' region operator in %s\n",tb->name);
d266 1
a266 1
	case OP_GUARD:rt_log("Warning: 'Guard' region operator in %s\n",tb->name);
d269 1
a269 1
	case OP_XNOP:rt_log("Warning: 'XNOP' region operator in %s\n",tb->name);
d297 1
a297 1
struct rt_vls		*matparm;
d307 1
a307 1
	RT_VLS_CHECK( matparm );
d312 1
a312 1
		rt_log("gauss_setup(%s)\n", rp->reg_name);
d319 1
a319 1
	GETSTRUCT( gauss_sp, gauss_specific );
d336 1
a336 1
	RT_LIST_INIT( &gauss_sp->dbil );
d357 1
a357 1
		mat_print( "m_to_sh", gauss_sp->gauss_m_to_sh );
d385 4
a388 4
	while (RT_LIST_WHILE(p, reg_db_internals, &gauss_sp->dbil) ) {
		RT_LIST_DEQUEUE( &(p->l) );
		rt_free( p->ip.idb_ptr, "internal ptr" );
		rt_free( (char *)p, "gauss reg_db_internals" );
d391 1
a391 1
	rt_free( cp, "gauss_specific" );
d426 1
a426 1
		rt_log("pt(%g %g %g) term2:%g val:%g\n",
d466 2
a467 2
		rt_log("Evaluating Segment:\n");
		rt_log("dist_in:%g dist_out:%g span:%g step_dist:%g steps:%d\n",
d522 2
a523 2
	RT_CK_LIST_HEAD(&swp->sw_segs->l);
	RT_CK_LIST_HEAD(&gauss_sp->dbil);
d527 1
a527 1
	for (RT_LIST_FOR(seg_p, seg, &swp->sw_segs->l) ) {
d530 1
a530 1
			rt_log("seg %g -> %g\n",
d542 1
a542 1
			for (RT_LIST_FOR(dbint_p, reg_db_internals,
d559 1
a559 1
					rt_log("gauss_render() bittest failed\n");
d565 1
a565 1
		rt_log("Optical Density %g\n", optical_density);
@


1.16
log
@Can't make "struct mfuncs" a CONST, because the forward link needs
to be filled in at runtime, and some compilers put CONST data into
read-only pages (like FreeBSD).
@
text
@d22 16
d39 4
d51 5
a55 3
#include "./material.h"
#include "./mathtab.h"
#include "./rdebug.h"
@


1.15
log
@Required magic number to be first in mfunc table,
consistent with all other BRL-CAD magic numbers.
Required magic number to be initialized at compile time.
Added code to check the magic numbers.
Made the xxx_mfunc arrays CONST, so they can't get trashed by
runtime runaway pointer problems.
@
text
@d121 1
a121 1
CONST struct mfuncs gauss_mfuncs[] = {
@


1.14
log
@Changed to bu_byteoffset
@
text
@d121 2
a122 2
struct mfuncs gauss_mfuncs[] = {
	{"gauss",	0,	0,		MFI_NORMAL|MFI_HIT|MFI_UV,	0,
d125 1
a125 1
	{(char *)0,	0,		0,		0,		0,
@


1.13
log
@db_shader_mat() parameter change
@
text
@a34 27
/*
 *  Generic settable parameters.
 *  By setting the "base address" to zero in the bu_structparse call,
 *  the actual memory address is given here as the structure offset.
 *
 *  Strictly speaking, the C language only permits initializers of the
 *  form: address +- constant, where here the intent is to measure the
 *  byte address of the indicated variable.
 *  Matching compensation code for the CRAY is located in librt/parse.c
 */
#if CRAY
#	define byteoffset(_i)	(((int)&(_i)))	/* actually a word offset */
#else
#  if IRIX > 5
#	define byteoffset(_i)	((size_t)__INTADDR__(&(_i)))
#  else
#    if sgi || __convexc__ || ultrix || _HPUX_SOURCE
	/* "Lazy" way.  Works on reasonable machines with byte addressing */
#	define byteoffset(_i)	((int)((char *)&(_i)))
#    else
	/* "Conservative" way of finding # bytes as diff of 2 char ptrs */
#	define byteoffset(_i)	((int)(((char *)&(_i))-((char *)0)))
#    endif
#  endif
#endif


d70 2
d82 2
d105 1
a105 1
	{"i",	byteoffset(gauss_print_tab[0]), "gauss_print_tab", 0, FUNC_NULL },
d328 3
a330 1
/*	db_shader_mat(gauss_sp->gauss_m_to_sh, rtip, rp); */
a567 3



@


1.12
log
@bu_struct_print
@
text
@d351 1
a351 1
/*	db_shader_mat(gauss_sp->gauss_m_to_sh, rtip->rti_dbip, rp); */
@


1.11
log
@bu_struct_parse
@
text
@d355 1
a355 1
		bu_structprint( " Parameters:", gauss_print_tab, (char *)gauss_sp );
d370 1
a370 1
	bu_structprint( rp->reg_name, gauss_print_tab, (char *)dp );
d514 1
a514 1
		bu_structprint( "gauss_render Parameters:", gauss_print_tab, (char *)gauss_sp );
@


1.10
log
@structparse moved to libbu
@
text
@d327 1
a327 1
	if( bu_structparse( matparm, gauss_parse_tab, (char *)gauss_sp ) < 0 )
@


1.9
log
@pt_solhit bit vector became pt_solids_hit bu_ptbl array
@
text
@d12 1
a12 1
 *		edit/build parse table for structparse from gauss_parse
d37 1
a37 1
 *  By setting the "base address" to zero in the rt_structparse call,
d122 1
a122 1
struct structparse gauss_print_tab[] = {
d127 1
a127 1
struct structparse gauss_parse_tab[] = {
d327 1
a327 1
	if( rt_structparse( matparm, gauss_parse_tab, (char *)gauss_sp ) < 0 )
d355 1
a355 1
		rt_structprint( " Parameters:", gauss_print_tab, (char *)gauss_sp );
d370 1
a370 1
	rt_structprint( rp->reg_name, gauss_print_tab, (char *)dp );
d514 1
a514 1
		rt_structprint( "gauss_render Parameters:", gauss_print_tab, (char *)gauss_sp );
d516 1
a516 1
		rt_log("r_pt(%g %g %g)  r_dir(%g %g %g)\n",
@


1.8
log
@Added missing cast.
@
text
@d537 1
a537 1
		if (BITTEST(pp->pt_solhit, seg_p->seg_stp->st_bit) ) {
d539 1
a539 1

d558 1
a558 1
					rt_log("bittest failed\n");
@


1.7
log
@checkpoint
@
text
@d209 1
a209 1
		ell_p = dbint->ip.idb_ptr;
d443 1
a443 1
	struct rt_ell_internal *ell_p = dbint->ip.idb_ptr;
@


1.6
log
@checkpoint
@
text
@d62 5
d73 2
d81 1
a81 1
	struct rt_list	*l;
d154 1
a154 1
tree_solids(tp, tb)
d157 1
d170 1
d196 4
a199 4
			rt_log(" got a solid type %d \"%s\".  This solid ain't no ellipse bucko!\n",
				sol_id, rt_functab[sol_id].ft_name);
		} else {
			ell_p = dbint->ip.idb_ptr;
d202 4
a205 12
				rt_log(" got a solid type %d \"%s\"\n",
					sol_id,
					rt_functab[sol_id].ft_name);

			RT_ELL_CK_MAGIC(ell_p);

			if( rdebug&RDEBUG_SHADE) {
				VPRINT("point", ell_p->v); 
				VPRINT("a", ell_p->a); 
				VPRINT("b", ell_p->b); 
				VPRINT("c", ell_p->c); 
			}
d208 7
a214 1
		/* XXX Only works for axis aligned solids */
d216 1
d218 5
a222 8
		if ((! NEAR_ZERO(ell_p->a[0], VDIVIDE_TOL) && ! NEAR_ZERO(ell_p->a[0] - MAGNITUDE(ell_p->a), VDIVIDE_TOL)) ||
		    (! NEAR_ZERO(ell_p->a[1], VDIVIDE_TOL) && ! NEAR_ZERO(ell_p->a[1] - MAGNITUDE(ell_p->a), VDIVIDE_TOL)) ||
		    (! NEAR_ZERO(ell_p->a[2], VDIVIDE_TOL) && ! NEAR_ZERO(ell_p->a[2] - MAGNITUDE(ell_p->a), VDIVIDE_TOL)) ||
		    (! NEAR_ZERO(ell_p->b[0], VDIVIDE_TOL) && ! NEAR_ZERO(ell_p->b[0] - MAGNITUDE(ell_p->a), VDIVIDE_TOL)) ||
		    (! NEAR_ZERO(ell_p->b[1], VDIVIDE_TOL) && ! NEAR_ZERO(ell_p->b[1] - MAGNITUDE(ell_p->a), VDIVIDE_TOL)) ||
		    (! NEAR_ZERO(ell_p->b[2], VDIVIDE_TOL) && ! NEAR_ZERO(ell_p->b[2] - MAGNITUDE(ell_p->a), VDIVIDE_TOL)) ||
		    (! NEAR_ZERO(ell_p->c[2], VDIVIDE_TOL) && ! NEAR_ZERO(ell_p->c[2] - MAGNITUDE(ell_p->a), VDIVIDE_TOL)) ) {
			rt_log("Warning: gauss ellipse not axis aligned\n");
d225 21
d260 2
a261 2
		tree_solids(tp->tr_b.tb_left, tb);
		tree_solids(tp->tr_b.tb_right, tb);
d264 5
a268 5
	case OP_NOT:
	case OP_GUARD:
	case OP_XNOP:
		rt_log("Warning: Non-union region op in %s!\n", tb->name);
		tree_solids(tp->tr_b.tb_left, tb);
d270 3
d277 5
a281 3
		rt_log("Warning: Non-union region op in %s!\n", tb->name);
		tree_solids(tp->tr_b.tb_left, tb);
		tree_solids(tp->tr_b.tb_right, tb);
d449 8
d525 1
a525 1
	/* look at each segment that participated in the ray */
d540 1
a540 1
			/* check to see if the solid is in this region */
@


1.5
log
@Minor Mods for IRIX 6.2
@
text
@d192 4
a195 2
			rt_log(" got a solid type %d \"%s\"\n", sol_id,
				rt_functab[sol_id].ft_name);
d199 6
a204 4
			VPRINT("point", ell_p->v); 
			VPRINT("a", ell_p->a); 
			VPRINT("b", ell_p->b); 
			VPRINT("c", ell_p->c); 
d208 12
d226 3
a228 1
		VPRINT("sigma", dbint->one_sigma);
d393 3
a395 2
	rt_log("pt(%g %g %g) term2:%g val:%g\n",
		V3ARGS(pt), term2, val);
a423 2
	rt_log("r_pt(%g %g %g)  r_dir(%g %g %g)\n", V3ARGS(ap->a_ray.r_pt),
		V3ARGS(ap->a_ray.r_dir) );
d425 6
a430 4
	rt_log("dist_in:%g dist_out:%g span:%g step_dist:%g steps:%d\n",
		seg_p->seg_in.hit_dist,
		seg_p->seg_out.hit_dist,
		span, step_dist, steps);
d432 1
d474 1
a474 1
	if( rdebug&RDEBUG_SHADE)
d477 3
a479 10
	/* If we are performing the shading in "region" space, we must 
	 * transform the hit point from "model" space to "region" space.
	 * See the call to db_region_mat in gauss_setup().
	 */
	MAT4X3PNT(pt, gauss_sp->gauss_m_to_sh, swp->sw_hit.hit_point);

	if( rdebug&RDEBUG_SHADE) {
		rt_log("gauss_render()  model:(%g %g %g) shader:(%g %g %g)\n", 
		V3ARGS(swp->sw_hit.hit_point),
		V3ARGS(pt) );
a481 7
	/* perform shading operations here */

	/* XXX First of all, we need to rotate the ray and ellipse into an
	 * axis-aligned state
	 */


d489 5
a499 2
			/* check to see if the solid is in the region */
			for (RT_LIST_FOR(dbint_p, reg_db_internals, &gauss_sp->dbil)){
d501 4
d508 4
d517 3
d524 2
a525 1
	rt_log("Optical Density %g\n", optical_density);
@


1.4
log
@Minor MOds for IRIX 6.2
@
text
@d49 1
a49 1
#	define byteoffset(_i)	((long)((char *)&(_i)))
@


1.3
log
@checkpoint.  First gaussian puff
@
text
@d96 1
a96 1
CONST static
d169 1
a169 1
			mp = rt_identity;
@


1.2
log
@checkpoint
@
text
@d30 1
d62 15
a76 12
/* XXX God this is a hack, we should have some way of asking this of the
 * solid rather than pirating it's private parts.  Talk about castrating
 * the packaging....
 */
struct ell_specific {
	vect_t	ell_V;		/* Vector to center of ellipsoid */
	vect_t	ell_Au;		/* unit-length A vector */
	vect_t	ell_Bu;
	vect_t	ell_Cu;
	vect_t	ell_invsq;	/* [ 1/(|A|**2), 1/(|B|**2), 1/(|C|**2) ] */
	mat_t	ell_SoR;	/* Scale(Rot(vect)) */
	mat_t	ell_invRSSR;	/* invRot(Scale(Scale(Rot(vect)))) */
d79 2
a80 1
#define gauss_MAGIC 0x6ao5    /* make this a unique number for each shader */
d89 1
a89 2
	double	gauss_val;	/* variables for shader ... */
	vect_t	gauss_delta;
d91 1
a91 1
	struct ell_specific ell_sp;
d94 1
d99 1
a99 2
	1.0,
	{ 1.0, 1.0, 1.0 },
d116 1
a116 2
	{"%f",  1, "val",		SHDR_O(gauss_val),	FUNC_NULL },
	{"%f",  3, "delta",		SHDR_AO(gauss_delta),	FUNC_NULL },
d122 1
a122 2
	{"%f",  1, "v",			SHDR_O(gauss_val),	FUNC_NULL },
	{"%f",  3, "d",			SHDR_AO(gauss_delta),	FUNC_NULL },
d146 94
d255 1
a255 6
	struct directory *dp;
	struct rt_db_internal ip;
	union tree *tree_p;
	mat_t	reg_mat;
	mat_t	tmp;
	vect_t	bb_min, bb_max, v_tmp;
d266 4
d288 6
a293 6
	if (rp->reg_treetop->tr_op != OP_SOLID)
		/* bitch and moan about non-solid and abort */
		rt_log("%s: non-solid first region element op(%d) s/b (%d)",
			rp->reg_name, rp->reg_treetop->tr_op, OP_SOLID);
		rt_bomb("gauss-shaded region needs ellipsoid as first element").
	}
d295 1
a295 8
	if (rp->reg_treetop->tree_leaf.tu_stp->st_id != ID_ELL) {
		/* bitch and moan, bitch and moan */
		rt_log("%s: non-ellipsoid first solid in region id(%d) s/b (%d)",
			rp->reg_name,
			rp->reg_treetop->tree_leaf.tu_stp->st_id,
			ID_ELL);
		rt_bomb("gauss-shaded region needs ellipsoid as first element").
	}
a296 3
	memcpy(	gauss_sp->ell_sp,
		rp->reg_treetop->tree_leaf.tu_stp->st_specific,
		sizeof(struct ell_specific));
a301 1

d331 10
d344 83
a426 1
/*
d443 5
d471 1
a471 1
	/* First of all, we need to rotate the ray and ellipse into an
d475 10
a484 8
	/* Now we need to evaluate the following function at various points
	 * along the solid/ray intersection partition:
							      2		2	 2
						      / (x-Ux)	  (y-Uy)   (z-Uz)  \
		   1.0				  -.5|   ----   + ------ + ------   |
---------------------------------------------- * e    \ sigma_x   sigma_y  sigma_z /
        (3/2)
   (2*PI)       * sigma_x * sigma_y * sigma_z)
d486 2
d489 2
a490 1
	*/
d492 1
d494 19
d514 2
a515 1
	VMOVE(swp->sw_color, pt);
d517 2
d529 3
@


1.1
log
@Initial revision
@
text
@d4 18
d34 43
d78 4
a81 1
#define gauss_MAGIC 0x1864	/* GAUSS change this number for each shader */
d83 5
a87 4
	long	magic;
	vect_t	stddev;
	vect_t	delta;
	mat_t	xform;
a88 1
#define CK_gauss_SP(_p) RT_CKMAG(_p, gauss_MAGIC, "gauss_specific")
d90 3
a92 1
static struct gauss_specific gauss_defaults = {
d94 1
a94 1
	{ 1.0, 1.0, 1.0 },
d96 4
d106 15
a120 5
struct structparse gauss_parse[] = {
	{"%f",  3, "delta",		SHDR_AO(delta),		FUNC_NULL },
	{"%f",  3, "d",			SHDR_AO(delta),		FUNC_NULL },
	{"%f",  3, "stddev",		SHDR_AO(stddev),	FUNC_NULL },
	{"%f",  3, "s",			SHDR_AO(stddev),	FUNC_NULL },
d127 8
d136 1
a136 1
	{"gauss",	0,	0,		MFI_NORMAL|MFI_HIT,	0,
d159 4
d164 1
d166 1
d170 6
d179 1
d182 2
a183 1
	if( rt_structparse( matparm, gauss_parse, (char *)gauss_sp ) < 0 )
d186 30
a215 2
	/* get the matrix which maps model space into
	 *  "region" or "shader" space
a216 1
	db_region_mat(gauss_sp->xform, rtip->rti_dbip, rp->reg_name);
d218 1
a218 6
	/* Add any translation within shader/region space */
	mat_idn(tmp);
	tmp[MDX] = gauss_sp->delta[0];
	tmp[MDY] = gauss_sp->delta[1];
	tmp[MDZ] = gauss_sp->delta[2];
	mat_mul2(tmp, gauss_sp->xform);
d222 2
a223 2
		rt_structprint( rp->reg_name, gauss_parse, (char *)gauss_sp );
		mat_print( "xform", gauss->xform );
d237 1
a237 1
	rt_structprint( rp->reg_name, gauss_parse, (char *)dp );
d253 3
a255 2
 *	This is called (from viewshade() in shade.c)
 *	once for each hit point to be shaded.
d261 2
a262 2
struct shadework	*swp;
char	*dp;
d268 1
d274 1
a274 1
		rt_structprint( "foo", gauss_parse, (char *)gauss_sp );
d276 5
d282 5
a286 5
	/* compute the ray/solid in and out points,
	 * and transform them into "shader space" coordinates 
	 */
	VJOIN1(pt, ap->a_ray.r_pt, pp->pt_inhit->hit_dist, ap->a_ray.r_dir);
	MAT4X3PNT(in_pt, sgauss_sp->xform, pt);
d288 1
a288 2
	VJOIN1(pt, ap->a_ray.r_pt, pp->pt_outhit->hit_dist, ap->a_ray.r_dir);
	MAT4X3PNT(out_pt, sgauss_sp->xform, pt);
d290 2
a291 2
	/* get ray/solid intersection vector (in noise space)
	 * and compute thickness of solid (in noise space) along ray path
a292 2
	VSUB2(v_cloud, out_pt, in_pt);
	thickness = MAGNITUDE(v_cloud);
d294 8
a301 2
	steps = pow(gauss_sp->lacunarity, gauss_sp->octaves-1) * 4;
	step_delta = thickness / (double)steps;
d304 1
a304 19
	VUNITIZE(v_cloud);
	VMOVE(pt, in_pt);
	trans = 1.0;
	for (i=0 ; i < steps ; i++ ) {
		/* compute the next point in the gaus space */
		VJOIN1(pt, in_pt, i*step_delta, v_cloud);

		pt[X] /= gauss_sp->stddev[X];
		pt[Y] /= gauss_sp->stddev[Y];
		pt[Z] /= gauss_sp->stddev[Z];

		/* density has normal distribution
		 *	1 / sqrt(2 * PI) * pow (- n*n/ 2.0)
		 */
		den  = 0.39894228 * pow( - pt[X] * pt[X] * .5 );
		den *= 0.39894228 * pow( - pt[Y] * pt[Y] * .5 );
		den *= 0.39894228 * pow( - pt[Z] * pt[Z] * .5 );

	}
d308 1
d310 1
a310 2
	/* caller will perform transmission/reflection calculations
	 * based upon the values of swp->sw_transmit and swp->sw_reflect
d315 2
@
