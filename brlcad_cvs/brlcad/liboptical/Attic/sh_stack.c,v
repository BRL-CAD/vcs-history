head	11.33;
access;
symbols
	ansi-20040405-merged:11.28.2.2
	postmerge-20040405-ansi:11.31
	premerge-20040404-ansi:11.30
	postmerge-autoconf:11.30
	autoconf-freeze:11.29.6.2
	premerge-autoconf:11.30
	ansi-20040316-freeze:11.28.2.1
	postmerge-20040315-windows:11.30
	premerge-20040315-windows:11.30
	windows-20040315-freeze:11.28.4.1
	autoconf-20031203:11.29
	autoconf-20031202:11.29
	autoconf-branch:11.29.0.6
	phong-branch:11.29.0.4
	photonmap-branch:11.29.0.2
	rel-6-1-DP:11.28
	windows-branch:11.28.0.4
	rel-6-0-2:11.26
	ansi-branch:11.28.0.2
	rel-6-0-1-branch:11.26.0.2
	hartley-6-0-post:11.27
	hartley-6-0-pre:11.26
	rel-6-0-1:11.26
	rel-6-0:11.26
	rel-5-4:11.21
	offsite-5-3-pre:11.26
	rel-5-3:11.21
	rel-5-2:11.21
	rel-5-1-branch:11.21.0.2
	rel-5-1:11.21
	rel-5-0:11.18
	rel-5-0-beta:11.16
	rel-4-5:11.11
	ctj-4-5-post:11.7
	ctj-4-5-pre:11.7
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1;
locks; strict;
comment	@ * @;


11.33
date	2004.05.21.18.07.28;	author morrison;	state dead;
branches;
next	11.32;

11.32
date	2004.05.10.15.30.45;	author erikg;	state Exp;
branches;
next	11.31;

11.31
date	2004.04.05.07.43.37;	author morrison;	state Exp;
branches;
next	11.30;

11.30
date	2004.02.02.17.39.14;	author morrison;	state Exp;
branches;
next	11.29;

11.29
date	2002.11.06.23.28.17;	author morrison;	state Exp;
branches
	11.29.6.1;
next	11.28;

11.28
date	2002.08.20.17.07.52;	author jra;	state Exp;
branches
	11.28.2.1
	11.28.4.1;
next	11.27;

11.27
date	2002.08.15.20.55.05;	author hartley;	state Exp;
branches;
next	11.26;

11.26
date	2000.09.09.01.19.22;	author mike;	state Exp;
branches;
next	11.25;

11.25
date	2000.09.09.01.08.48;	author mike;	state Exp;
branches;
next	11.24;

11.24
date	2000.08.15.02.04.56;	author mike;	state Exp;
branches;
next	11.23;

11.23
date	2000.08.10.19.11.16;	author butler;	state Exp;
branches;
next	11.22;

11.22
date	2000.07.25.16.40.38;	author butler;	state Exp;
branches;
next	11.21;

11.21
date	2000.02.19.21.05.02;	author butler;	state Exp;
branches;
next	11.20;

11.20
date	99.12.09.00.36.00;	author mike;	state Exp;
branches;
next	11.19;

11.19
date	99.10.30.03.06.25;	author butler;	state Exp;
branches;
next	11.18;

11.18
date	99.07.02.22.20.42;	author mike;	state Exp;
branches;
next	11.17;

11.17
date	99.07.01.20.08.48;	author mike;	state Exp;
branches;
next	11.16;

11.16
date	99.01.29.05.53.32;	author butler;	state Exp;
branches;
next	11.15;

11.15
date	99.01.25.18.22.22;	author butler;	state Exp;
branches;
next	11.14;

11.14
date	99.01.22.22.25.31;	author jra;	state Exp;
branches;
next	11.13;

11.13
date	98.09.22.01.29.55;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	98.06.30.22.54.19;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	97.12.31.09.01.40;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	97.12.31.06.30.48;	author butler;	state Exp;
branches;
next	11.9;

11.9
date	97.12.09.04.46.14;	author butler;	state Exp;
branches;
next	11.8;

11.8
date	97.11.25.22.16.43;	author butler;	state Exp;
branches;
next	11.7;

11.7
date	96.08.31.08.29.28;	author butler;	state Exp;
branches;
next	11.6;

11.6
date	96.08.30.00.08.21;	author butler;	state Exp;
branches;
next	11.5;

11.5
date	95.10.20.04.43.53;	author butler;	state Exp;
branches;
next	11.4;

11.4
date	95.09.16.00.13.47;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	95.06.03.00.44.31;	author butler;	state Exp;
branches;
next	11.2;

11.2
date	95.03.11.02.24.12;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.01.11;	author mike;	state Rel4_4;
branches;
next	10.2;

10.2
date	94.08.11.02.27.43;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.42.12;	author mike;	state Rel4_0;
branches;
next	9.8;

9.8
date	91.07.06.00.35.23;	author mike;	state Exp;
branches;
next	9.7;

9.7
date	91.02.17.18.50.32;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	91.01.05.03.09.16;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	90.12.12.16.35.10;	author butler;	state Exp;
branches;
next	9.4;

9.4
date	90.12.10.21.16.21;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	90.12.08.08.58.16;	author butler;	state Exp;
branches;
next	9.2;

9.2
date	90.11.01.11.18.32;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.59.42;	author mike;	state Rel3_5;
branches;
next	8.3;

8.3
date	89.04.04.05.02.08;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	88.12.27.16.35.12;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.33.28;	author mike;	state Rel3_0;
branches;
next	7.3;

7.3
date	88.09.17.07.20.50;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	88.05.14.02.28.26;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.56.37;	author mike;	state Rel;
branches;
next	6.2;

6.2
date	87.09.16.04.29.00;	author mike;	state Exp;
branches;
next	6.1;

6.1
date	87.07.11.07.59.24;	author mike;	state Rel;
branches;
next	1.2;

1.2
date	87.07.02.04.14.56;	author phil;	state Exp;
branches;
next	1.1;

1.1
date	87.07.01.03.20.44;	author mike;	state Exp;
branches;
next	;

11.28.2.1
date	2002.09.19.18.01.26;	author morrison;	state Exp;
branches;
next	11.28.2.2;

11.28.2.2
date	2004.03.17.21.18.32;	author morrison;	state Exp;
branches;
next	;

11.28.4.1
date	2004.03.11.23.43.03;	author morrison;	state Exp;
branches;
next	;

11.29.6.1
date	2004.02.12.18.38.49;	author erikg;	state Exp;
branches;
next	11.29.6.2;

11.29.6.2
date	2004.03.15.14.07.13;	author erikg;	state Exp;
branches;
next	;


desc
@Routines for stacking material properties.
@


11.33
log
@moved to src/
@
text
@/*
 *			S T A C K . C
 *
 *  Stack multiple material modules together
 *
 *  Author -
 *	Phillip Dykstra
 *  	Lee A. Butler
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1986-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/liboptical/sh_stack.c,v 11.32 2004/05/10 15:30:45 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <string.h>
#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "shadefuncs.h"
#include "shadework.h"
#include "rtprivate.h"

HIDDEN int	stk_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mf_p, struct rt_i *rtip, struct mfuncs **headp), stk_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
HIDDEN void	stk_print(register struct region *rp, char *dp), stk_free(char *cp);
HIDDEN int	ext_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mf_p, struct rt_i *rtip, struct mfuncs **headp);

struct mfuncs stk_mfuncs[] = {
	{MF_MAGIC,	"stack",	0,		0,	0,
	stk_setup,	stk_render,	stk_print,	stk_free},

	{MF_MAGIC,	"extern",	0,		0,	0,
	ext_setup,	stk_render,	stk_print,	stk_free},

	{0,		(char *)0,	0,		0,	0,
	0,		0,		0,		0}
};

struct stk_specific {
	struct	mfuncs	*mfuncs[16];
	char	*udata[16];
};
#define STK_NULL	((struct stk_specific *)0)
#define STK_O(m)	offsetof(struct stk_specific, m)

struct bu_structparse stk_parse[] = {
	{"",	0,	(char *)0,	0,			BU_STRUCTPARSE_FUNC_NULL }
};

/*
 *			E X T _ S E T U P
 *
 *  Returns 0 on failure, 1 on success.
 */
HIDDEN int
ext_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mf_p, struct rt_i *rtip, struct mfuncs **headp)
                           
             	         	/* parameter string */
    		      		/* pointer to user data pointer */
             	      
           	      
             	        
{
	struct bu_mapped_file	*parameter_file;
	struct bu_vls		parameter_data;
	char			*filename;
	int			status;

	RT_CHECK_RTI(rtip);
	BU_CK_VLS( matparm );
	RT_CK_REGION(rp);
	
	filename = bu_vls_addr(matparm);
	parameter_file = bu_open_mapped_file( filename, (char *)NULL );
	if (!parameter_file) {
		bu_log("cannot open external shader file \"%s\"\n", filename);
		bu_bomb("ext_setup()\n");
	}

	bu_vls_init(&parameter_data);
	bu_vls_strncpy( &parameter_data, (char *)parameter_file->buf,
		parameter_file->buflen );

	if (rdebug&RDEBUG_SHADE ) {
		bu_log("ext_setup(%s): {%s}\n",
			filename, bu_vls_addr(&parameter_data));
	}

	bu_close_mapped_file( parameter_file );

	status = stk_setup(rp, &parameter_data, dpp, mf_p, rtip, headp);

	bu_vls_free( &parameter_data );

	return status;
}

/*
 *			S T K _ D O S E T U P
 */
static int stk_dosetup(char *cp, struct region *rp, char **dpp, char **mpp, struct rt_i *rtip, struct mfuncs **headp)
    	    
             	    
    	      		/* udata pointer address */
    	      		/* mfuncs pointer address */
           	      
             	        
{
	register struct mfuncs *mfp;
#ifdef HAVE_DLOPEN
	register struct mfuncs *mfp_new;
#endif
	struct bu_vls	arg;
	char	matname[32];
	int	ret;
	int	i;

	RT_CK_RTI(rtip);

	if(rdebug&RDEBUG_MATERIAL)
		bu_log( "...starting \"%s\"\n", cp );

	/* skip leading white space */
	while( *cp == ' ' || *cp == '\t' )
		cp++;

	for( i = 0; i < 31 && *cp != '\0'; i++, cp++ ) {
		if (*cp == ' ' || *cp == '\t' ) {
			matname[i++] = '\0';
			break;
		} else
			matname[i] = *cp;
	}
	matname[i] = '\0';	/* ensure null termination */

#ifdef HAVE_DLOPEN
retry:
#endif
	for( mfp = *headp; mfp != MF_NULL; mfp = mfp->mf_forw )  {
		if (matname[0] != mfp->mf_name[0]  ||
		    strcmp( matname, mfp->mf_name ) != 0 )
			continue;
		goto found;
	}
#ifdef HAVE_DLOPEN
	/* If we get here, then the shader wasn't found in the list of 
	 * compiled-in (or previously loaded) shaders.  See if we can
	 * dynamically load it.
	 */

	bu_log("Shader \"%s\"... ", matname);

	if ((mfp_new = load_dynamic_shader(matname, strlen(matname)))) {
		mlib_add_shader(headp, mfp_new);
		goto retry;
	}
#else
	bu_log("****** dynamic shader loading not available ******\n");
#endif



	bu_log("stack_setup(%s):  material not known\n",
		matname );
	ret = -1;
	goto out;

found:
	*mpp = (char *)mfp;
	*dpp = (char *)0;
	bu_vls_init( &arg );
	if (*cp != '\0' )
		bu_vls_strcat( &arg, ++cp );
	if (rdebug&RDEBUG_MATERIAL)
		bu_log("calling %s with %s\n", mfp->mf_name, bu_vls_addr(&arg));
	if (mfp->mf_setup( rp, &arg, dpp, mfp, rtip, headp ) < 0 )  {
		/* Setup has failed */
		bu_vls_free( &arg );
		ret = -1;		/* BAD */
		goto out;
	}
	bu_vls_free( &arg );
	ret = 0;			/* OK */
out:
	if (rdebug&RDEBUG_MATERIAL)
		bu_log( "...finished \"%s\", ret=%d\n", matname, ret );
	return ret;
}

/*
 *			S T K _ S E T U P
 *
 *  Returns 0 on failure, 1 on success.
 */
HIDDEN int
stk_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mf_p, struct rt_i *rtip, struct mfuncs **headp)
                           
             	         	/* parameter string */
    		      		/* pointer to user data pointer */
             	      
           	      
             	        
{
	register struct stk_specific *sp;
	char	*cp, *start;
	int	i;
	int	inputs = 0;
	struct mfuncs *mfp;

	BU_CK_VLS( matparm );
	RT_CK_RTI(rtip);

	BU_GETSTRUCT( sp, stk_specific );
	*dpp = (char *)sp;

	/*bu_struct_parse( matparm, stk_parse, (char *)sp );*/

	if(rdebug&RDEBUG_MATERIAL || rdebug&RDEBUG_SHADE)
		bu_log( "stk_setup called with \"%s\"\n", bu_vls_addr(matparm) );

	i = 0;
	start = cp = bu_vls_addr(matparm);
	while( *cp != '\0' ) {
		if (*cp == ';' ) {
			*cp = '\0';
			if (i >= 16 ) {
				bu_log( "stk_setup: max levels exceeded\n" );
				return( 0 );
			}
			/* add one */
			if (stk_dosetup(start, rp, &sp->udata[i],
				(char **)&sp->mfuncs[i], rtip, headp) == 0 )  {
					inputs |= sp->mfuncs[i]->mf_inputs;
					i++;
			} else {
				/* XXX else clear entry? */
				bu_log("Problem in stack shader setup\n");
			}
			start = ++cp;
		} else {
			cp++;
		}
	}
	if (start != cp ) {
		if (i >= 16 ) {
			bu_log( "stk_setup: max levels exceeded\n" );
			return( 0 );
		}
		/* add one */
		if (stk_dosetup(start, rp, &sp->udata[i], (char **)&sp->mfuncs[i],
		    rtip, headp ) == 0 )  {
			inputs |= sp->mfuncs[i]->mf_inputs;
			i++;
		} else {
			/* XXX else clear entry? */
		}
	}

	/* Request only those input bits needed by subordinate shaders */
	BU_GETSTRUCT( mfp, mfuncs );
	bcopy( (char *)rp->reg_mfuncs, (char *)mfp, sizeof(*mfp) );
	mfp->mf_inputs = inputs;
	rp->reg_mfuncs = (genptr_t)mfp;
	return( 1 );
}

/*
 *  			S T K _ R E N D E R
 *  
 *  Evaluate all of the rendering functions in the stack.
 *
 *  Returns:
 *	0	stack processing aborted
 *	1	stack processed to completion
 */
HIDDEN int
stk_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
{
	register struct stk_specific *sp =
		(struct stk_specific *)dp;
	int	i;
	int	ret_status;
	char	tmp[128];

	for( i = 0; i < 16 && sp->mfuncs[i] != NULL; i++ ) {
		if (rdebug&RDEBUG_SHADE)  {
			sprintf(tmp, "before stacked \"%s\" shader", sp->mfuncs[i]->mf_name);

			pr_shadework( tmp, swp );
		}

		/*
		 *  Every shader takes the shadework structure as its
		 *  input and updates it as the "output".
		 */
		ret_status = sp->mfuncs[i]->mf_render( ap, pp, swp,
			sp->udata[i] );

		if ( ! ret_status ) return ret_status;

	}
	return(1);
}

/*
 *			S T K _ P R I N T
 */
HIDDEN void
stk_print(register struct region *rp, char *dp)
{
	register struct stk_specific *sp =
		(struct stk_specific *)dp;
	int	i;

	bu_log("~~~~starting stack print\n");

	for( i = 0; i < 16 && sp->mfuncs[i] != NULL; i++ ) {
		bu_log("~~~~stack entry %d:\n", i);
		sp->mfuncs[i]->mf_print( rp, sp->udata[i] );
	}

	bu_log("~~~~ending stack print\n");
}

/*
 *			S T K _ F R E E
 */
HIDDEN void
stk_free(char *cp)
{
	register struct stk_specific *sp =
		(struct stk_specific *)cp;
	int	i;

	for( i = 0; i < 16 && sp->mfuncs[i] != NULL; i++ ) {
		sp->mfuncs[i]->mf_free( sp->udata[i] );
	}

	bu_free( cp, "stk_specific" );
}

@


11.32
log
@change conf.h to a wrapped config.h
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/liboptical/sh_stack.c,v 11.31 2004/04/05 07:43:37 morrison Exp $ (BRL)";
@


11.31
log
@merge of ansi-6-0-branch into HEAD
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d23 5
a27 1
#include "conf.h"
@


11.30
log
@update copyright to include span through 2003
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_stack.c,v 11.29 2002/11/06 23:28:17 morrison Exp $ (BRL)";
d34 3
a36 3
HIDDEN int	stk_setup(), stk_render();
HIDDEN void	stk_print(), stk_free();
HIDDEN int	ext_setup();
d66 7
a72 7
ext_setup( rp, matparm, dpp, mf_p, rtip, headp )
register struct region *rp;
struct bu_vls	*matparm;	/* parameter string */
char		**dpp;		/* pointer to user data pointer */
struct mfuncs	*mf_p;
struct rt_i	*rtip;
struct mfuncs	**headp;
d111 7
a117 7
static int stk_dosetup( cp, rp, dpp, mpp, rtip, headp )
char	*cp;
struct region	*rp;
char	**dpp;		/* udata pointer address */
char	**mpp;		/* mfuncs pointer address */
struct rt_i	*rtip;
struct mfuncs	**headp;
d206 7
a212 7
stk_setup( rp, matparm, dpp, mf_p, rtip, headp )
register struct region *rp;
struct bu_vls	*matparm;	/* parameter string */
char		**dpp;		/* pointer to user data pointer */
struct mfuncs	*mf_p;
struct rt_i	*rtip;
struct mfuncs	**headp;
d287 1
a287 5
stk_render( ap, pp, swp, dp )
struct application	*ap;
struct partition	*pp;
struct shadework	*swp;
char	*dp;
d319 1
a319 3
stk_print( rp, dp )
register struct region *rp;
char	*dp;
d339 1
a339 2
stk_free( cp )
char *cp;
@


11.29
log
@made logged error message more readable
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1986 by the United States Army.
d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_stack.c,v 11.28 2002/08/20 17:07:52 jra Exp $ (BRL)";
@


11.29.6.1
log
@merge from HEAD
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_stack.c,v 11.30 2004/02/02 17:39:14 morrison Exp $ (BRL)";
@


11.29.6.2
log
@merge from head
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_stack.c,v 11.29.6.1 2004/02/12 18:38:49 erikg Exp $ (BRL)";
@


11.28
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_stack.c,v 11.26 2000/09/09 01:19:22 mike Exp $ (BRL)";
d247 1
a247 1
				bu_log("stk_setup problem\n");
@


11.28.4.1
log
@sync to HEAD...
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/liboptical/sh_stack.c,v 11.30 2004/02/02 17:39:14 morrison Exp $ (BRL)";
d247 1
a247 1
				bu_log("Problem in stack shader setup\n");
@


11.28.2.1
log
@Initial ANSIfication
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_stack.c,v 11.28 2002/08/20 17:07:52 jra Exp $ (BRL)";
d34 3
a36 3
HIDDEN int	stk_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mf_p, struct rt_i *rtip, struct mfuncs **headp), stk_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
HIDDEN void	stk_print(register struct region *rp, char *dp), stk_free(char *cp);
HIDDEN int	ext_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mf_p, struct rt_i *rtip, struct mfuncs **headp);
d66 7
a72 7
ext_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mf_p, struct rt_i *rtip, struct mfuncs **headp)
                           
             	         	/* parameter string */
    		      		/* pointer to user data pointer */
             	      
           	      
             	        
d111 7
a117 7
static int stk_dosetup(char *cp, struct region *rp, char **dpp, char **mpp, struct rt_i *rtip, struct mfuncs **headp)
    	    
             	    
    	      		/* udata pointer address */
    	      		/* mfuncs pointer address */
           	      
             	        
d206 7
a212 7
stk_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mf_p, struct rt_i *rtip, struct mfuncs **headp)
                           
             	         	/* parameter string */
    		      		/* pointer to user data pointer */
             	      
           	      
             	        
d287 5
a291 1
stk_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
d323 3
a325 1
stk_print(register struct region *rp, char *dp)
d345 2
a346 1
stk_free(char *cp)
@


11.28.2.2
log
@sync branch with HEAD
@
text
@d16 1
a16 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d20 1
a20 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d247 1
a247 1
				bu_log("Problem in stack shader setup\n");
@


11.27
log
@Converted from K&R to ANSI C - RFH
@
text
@d34 3
a36 3
HIDDEN int	stk_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mf_p, struct rt_i *rtip, struct mfuncs **headp), stk_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
HIDDEN void	stk_print(register struct region *rp, char *dp), stk_free(char *cp);
HIDDEN int	ext_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mf_p, struct rt_i *rtip, struct mfuncs **headp);
d66 7
a72 7
ext_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mf_p, struct rt_i *rtip, struct mfuncs **headp)
                           
             	         	/* parameter string */
    		      		/* pointer to user data pointer */
             	      
           	      
             	        
d111 7
a117 7
static int stk_dosetup(char *cp, struct region *rp, char **dpp, char **mpp, struct rt_i *rtip, struct mfuncs **headp)
    	    
             	    
    	      		/* udata pointer address */
    	      		/* mfuncs pointer address */
           	      
             	        
d206 7
a212 7
stk_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mf_p, struct rt_i *rtip, struct mfuncs **headp)
                           
             	         	/* parameter string */
    		      		/* pointer to user data pointer */
             	      
           	      
             	        
d287 5
a291 1
stk_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
d323 3
a325 1
stk_print(register struct region *rp, char *dp)
d345 2
a346 1
stk_free(char *cp)
@


11.26
log
@
Added additional debug at end of function.
Helps catch the case where a stacked shader has problems, vs. the
stacker itself having a problem.
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_stack.c,v 11.25 2000/09/09 01:08:48 mike Exp $ (BRL)";
d34 3
a36 3
HIDDEN int	stk_setup(), stk_render();
HIDDEN void	stk_print(), stk_free();
HIDDEN int	ext_setup();
d66 7
a72 7
ext_setup( rp, matparm, dpp, mf_p, rtip, headp )
register struct region *rp;
struct bu_vls	*matparm;	/* parameter string */
char		**dpp;		/* pointer to user data pointer */
struct mfuncs	*mf_p;
struct rt_i	*rtip;
struct mfuncs	**headp;
d111 7
a117 7
static int stk_dosetup( cp, rp, dpp, mpp, rtip, headp )
char	*cp;
struct region	*rp;
char	**dpp;		/* udata pointer address */
char	**mpp;		/* mfuncs pointer address */
struct rt_i	*rtip;
struct mfuncs	**headp;
d206 7
a212 7
stk_setup( rp, matparm, dpp, mf_p, rtip, headp )
register struct region *rp;
struct bu_vls	*matparm;	/* parameter string */
char		**dpp;		/* pointer to user data pointer */
struct mfuncs	*mf_p;
struct rt_i	*rtip;
struct mfuncs	**headp;
d287 1
a287 5
stk_render( ap, pp, swp, dp )
struct application	*ap;
struct partition	*pp;
struct shadework	*swp;
char	*dp;
d319 1
a319 3
stk_print( rp, dp )
register struct region *rp;
char	*dp;
d339 1
a339 2
stk_free( cp )
char *cp;
@


11.25
log
@
Added a bit more debugging.  Corrected inconsistent debug bit usage.
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_stack.c,v 11.24 2000/08/15 02:04:56 mike Exp $ (BRL)";
d190 1
d196 1
a196 1
		bu_log( "...finished \"%s\"\n", matname );
@


11.24
log
@
Fixed lint
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_stack.c,v 11.23 2000/08/10 19:11:16 butler Exp $ (BRL)";
d125 1
d175 2
a176 1
	return(-1);
d184 1
a184 1
	if (rdebug&RDEBUG_SHADE)
d187 3
a189 2
		/* What to do if setup fails? */
		return(-1);		/* BAD */
d192 5
a196 1
	return(0);			/* OK */
@


11.23
log
@Additions for dyamic shader loading
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_stack.c,v 11.22 2000/07/25 16:40:38 butler Exp $ (BRL)";
d120 1
d122 1
d145 1
d147 1
d234 1
a234 1
				&sp->mfuncs[i], rtip, headp) == 0 )  {
d252 1
a252 1
		if (stk_dosetup(start, rp, &sp->udata[i], &sp->mfuncs[i],
@


11.22
log
@Changes to use rtprivate.h instead of ../rt/rdebug.h
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_stack.c,v 11.21 2000/02/19 21:05:02 butler Exp $ (BRL)";
d120 1
d143 1
d150 18
@


11.21
log
@Changes to support movement of CLAMP() macro into vmath.h
Altered "if( " statements to "if (" for readability.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_stack.c,v 11.20 1999/12/09 00:36:00 mike Exp $ (BRL)";
d26 1
d32 1
a32 1
#include "../rt/rdebug.h"
d108 59
d254 1
a254 1
HIDDEN
a326 59
/*
 *			S T K _ D O S E T U P
 */
stk_dosetup( cp, rp, dpp, mpp, rtip, headp )
char	*cp;
struct region	*rp;
char	**dpp;		/* udata pointer address */
char	**mpp;		/* mfuncs pointer address */
struct rt_i	*rtip;
struct mfuncs	**headp;
{
	register struct mfuncs *mfp;
	struct bu_vls	arg;
	char	matname[32];
	int	i;

	RT_CK_RTI(rtip);

	if(rdebug&RDEBUG_MATERIAL)
		bu_log( "...starting \"%s\"\n", cp );

	/* skip leading white space */
	while( *cp == ' ' || *cp == '\t' )
		cp++;

	for( i = 0; i < 31 && *cp != '\0'; i++, cp++ ) {
		if (*cp == ' ' || *cp == '\t' ) {
			matname[i++] = '\0';
			break;
		} else
			matname[i] = *cp;
	}
	matname[i] = '\0';	/* ensure null termination */

	for( mfp = *headp; mfp != MF_NULL; mfp = mfp->mf_forw )  {
		if (matname[0] != mfp->mf_name[0]  ||
		    strcmp( matname, mfp->mf_name ) != 0 )
			continue;
		goto found;
	}
	bu_log("stack_setup(%s):  material not known\n",
		matname );
	return(-1);

found:
	*mpp = (char *)mfp;
	*dpp = (char *)0;
	bu_vls_init( &arg );
	if (*cp != '\0' )
		bu_vls_strcat( &arg, ++cp );
	if (rdebug&RDEBUG_SHADE)
		bu_log("calling %s with %s\n", mfp->mf_name, bu_vls_addr(&arg));
	if (mfp->mf_setup( rp, &arg, dpp, mfp, rtip, headp ) < 0 )  {
		/* What to do if setup fails? */
		return(-1);		/* BAD */
	}
	bu_vls_free( &arg );
	return(0);			/* OK */
}
@


11.20
log
@
Added comment.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_stack.c,v 11.19 1999/10/30 03:06:25 butler Exp $ (BRL)";
d93 1
a93 1
	if( rdebug&RDEBUG_SHADE ) {
d142 1
a142 1
		if( *cp == ';' ) {
d144 1
a144 1
			if( i >= 16 ) {
d149 1
a149 1
			if( stk_dosetup(start, rp, &sp->udata[i],
d162 2
a163 2
	if( start != cp ) {
		if( i >= 16 ) {
d168 1
a168 1
		if( stk_dosetup(start, rp, &sp->udata[i], &sp->mfuncs[i],
d208 1
a208 1
		if( rdebug&RDEBUG_SHADE)  {
d293 1
a293 1
		if( *cp == ' ' || *cp == '\t' ) {
d302 1
a302 1
		if( matname[0] != mfp->mf_name[0]  ||
d317 1
a317 1
	if( rdebug&RDEBUG_SHADE)
d319 1
a319 1
	if( mfp->mf_setup( rp, &arg, dpp, mfp, rtip, headp ) < 0 )  {
@


11.19
log
@Moved mathtab/rand_half from rt into libbn
Expanded structparse to include description and default
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_stack.c,v 11.18 1999/07/02 22:20:42 mike Exp $ (BRL)";
d214 4
@


11.18
log
@
Removed dependence on compat4.h
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_stack.c,v 11.17 1999/07/01 20:08:48 mike Exp $ (BRL)";
a30 1
#include "../rt/mathtab.h"
@


11.17
log
@
compat4
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_stack.c,v 11.16 1999/01/29 05:53:32 butler Exp $ (BRL)";
d57 1
a57 1
	{"",	0,	(char *)0,	0,			FUNC_NULL }
@


11.16
log
@Changed name of shader in sh_noise from 'gravel' to 'noise'.
fixed pointer bug in sh_stack.c
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_stack.c,v 11.15 1999/01/25 18:22:22 butler Exp $ (BRL)";
d68 1
a68 1
struct rt_vls	*matparm;	/* parameter string */
d80 1
a80 1
	RT_VLS_CHECK( matparm );
d117 1
a117 1
struct rt_vls	*matparm;	/* parameter string */
d129 1
a129 1
	RT_VLS_CHECK( matparm );
d132 1
a132 1
	GETSTRUCT( sp, stk_specific );
d138 1
a138 1
		rt_log( "stk_setup called with \"%s\"\n", RT_VLS_ADDR(matparm) );
d141 1
a141 1
	start = cp = RT_VLS_ADDR(matparm);
d146 1
a146 1
				rt_log( "stk_setup: max levels exceeded\n" );
d156 1
a156 1
				rt_log("stk_setup problem\n");
d165 1
a165 1
			rt_log( "stk_setup: max levels exceeded\n" );
d179 1
a179 1
	GETSTRUCT( mfp, mfuncs );
d236 1
a236 1
	rt_log("~~~~starting stack print\n");
d239 1
a239 1
		rt_log("~~~~stack entry %d:\n", i);
d243 1
a243 1
	rt_log("~~~~ending stack print\n");
d261 1
a261 1
	rt_free( cp, "stk_specific" );
d276 1
a276 1
	struct rt_vls	arg;
d283 1
a283 1
		rt_log( "...starting \"%s\"\n", cp );
d304 1
a304 1
	rt_log("stack_setup(%s):  material not known\n",
d311 1
a311 1
	RT_VLS_INIT( &arg );
d313 1
a313 1
		rt_vls_strcat( &arg, ++cp );
d320 1
a320 1
	rt_vls_free( &arg );
@


11.15
log
@Added "ext" shader which is the same as "stack" takes but takes parameters
from and external file.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_stack.c,v 11.14 1999/01/22 22:25:31 jra Exp $ (BRL)";
d150 4
a153 4
			if( stk_dosetup(start, rp, &sp->udata[i], &sp->mfuncs[i],
				rtip, headp) == 0 )  {
				inputs |= sp->mfuncs[i]->mf_inputs;
				i++;
d312 4
a315 1
	rt_vls_strcat( &arg, ++cp );
@


11.14
log
@stk_dosetup() now calls mfunc setups with parameters not having a leading blank.
@
text
@d8 2
a9 1
 *  
d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_stack.c,v 11.13 1998/09/22 01:29:55 mike Exp $ (BRL)";
d36 1
d42 3
d61 49
d137 1
a137 1
	if(rdebug&RDEBUG_MATERIAL)
d139 1
@


11.13
log
@Moved optical shaders from rt/ to liboptical/
The only modifications involved moving and splitting
rt/material.h into h/shadefuncs.h and h/shadework.h,
and in changing the calling sequence to mlib_setup() in rt/material.c

Now the only shader function called directly by RT is
in liboptical/init.c: optical_shader_init().
It adds all the individual shaders to the "mfuncs" shader list.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rt/sh_stack.c,v 11.12 1998/06/30 22:54:19 mike Exp $ (BRL)";
d257 1
a257 1
	rt_vls_strcat( &arg, cp );
@


11.12
log
@Can't make "struct mfuncs" a CONST, because the forward link needs
to be filled in at runtime, and some compilers put CONST data into
read-only pages (like FreeBSD).
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rt/sh_stack.c,v 11.11 1997/12/31 09:01:40 mike Exp $ (BRL)";
d28 4
a31 2
#include "./material.h"
#include "./rdebug.h"
d61 1
a61 1
stk_setup( rp, matparm, dpp, mf_p, rtip )
d67 1
d95 2
a96 2
			if( dosetup(start, rp, &sp->udata[i], &sp->mfuncs[i],
				rtip) == 0 )  {
d114 2
a115 2
		if( dosetup(start, rp, &sp->udata[i], &sp->mfuncs[i],
		    rtip ) == 0 )  {
d209 4
a212 3
extern struct mfuncs *mfHead;	/* Head of list of materials */

dosetup( cp, rp, dpp, mpp, rtip )
d218 1
d243 1
a243 1
	for( mfp=mfHead; mfp != MF_NULL; mfp = mfp->mf_forw )  {
d258 1
a258 1
	if( mfp->mf_setup( rp, &arg, dpp, mfp, rtip ) < 0 )  {
@


11.11
log
@Required magic number to be first in mfunc table,
consistent with all other BRL-CAD magic numbers.
Required magic number to be initialized at compile time.
Added code to check the magic numbers.
Made the xxx_mfunc arrays CONST, so they can't get trashed by
runtime runaway pointer problems.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_stack.c,v 11.10 1997/12/31 06:30:48 butler Exp mike $ (BRL)";
d34 1
a34 1
CONST struct mfuncs stk_mfuncs[] = {
@


11.10
log
@enhanced debugging message
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_stack.c,v 11.9 1997/12/09 04:46:14 butler Exp butler $ (BRL)";
d34 3
a36 3
struct mfuncs stk_mfuncs[] = {
	"stack",	0,		0,		0,	0,
	stk_setup,	stk_render,	stk_print,	stk_free,
d38 2
a39 2
	(char *)0,	0,		0,		0,	0,
	0,		0,		0,		0
@


11.9
log
@zero return status causes stack to terminate early
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_stack.c,v 11.8 1997/11/25 22:16:43 butler Exp butler $ (BRL)";
d148 1
d151 4
a154 2
		if( rdebug&RDEBUG_SHADE && i > 0 )  {
			pr_shadework( "before next stacked mf_render", swp );
@


11.8
log
@updated all shaders so that _setup had mfp and rtip parameters
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_stack.c,v 11.7 1996/08/31 08:29:28 butler Exp butler $ (BRL)";
d132 4
d147 1
d153 6
a158 2
		if (!(sp->mfuncs[i]->mf_render( ap, pp, swp, sp->udata[i] )))
			break; 
@


11.7
log
@bu_struct_parse
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_stack.c,v 11.6 1996/08/30 00:08:21 butler Exp butler $ (BRL)";
d148 2
a149 1
		(void)(sp->mfuncs[i]->mf_render( ap, pp, swp, sp->udata[i] ));
@


11.6
log
@structparse moved to libbu
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_stack.c,v 11.5 1995/10/20 04:43:53 butler Exp butler $ (BRL)";
d78 1
a78 1
	/*bu_structparse( matparm, stk_parse, (char *)sp );*/
@


11.5
log
@edited mfuncs table to account for new "mf_flags" element in struct mfuncs.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_stack.c,v 11.4 1995/09/16 00:13:47 mike Exp butler $ (BRL)";
d49 1
a49 1
struct structparse stk_parse[] = {
d78 1
a78 1
	/*rt_structparse( matparm, stk_parse, (char *)sp );*/
@


11.4
log
@Added more goodies.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/rt/RCS/sh_stack.c,v 11.3 1995/06/03 00:44:31 butler Exp mike $ (BRL)";
d35 1
a35 1
	"stack",	0,		0,		0,
d38 1
a38 1
	(char *)0,	0,		0,		0,
@


11.3
log
@added new parameter to stk_setup
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_stack.c,v 11.2 1995/03/11 02:24:12 mike Exp butler $ (BRL)";
d73 2
d206 2
@


11.2
log
@Added mfp parameter to mf_setup() call.
This allows the shader setup routine to know what name it was invoked by.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_stack.c,v 11.1 95/01/04 10:01:11 mike Rel4_4 Locker: mike $ (BRL)";
d59 1
a59 1
stk_setup( rp, matparm, dpp )
d62 3
a64 1
char	**dpp;		/* pointer to user data pointer */
d90 2
a91 1
			if( dosetup(start, rp, &sp->udata[i], &sp->mfuncs[i]) == 0 )  {
d109 2
a110 1
		if( dosetup(start, rp, &sp->udata[i], &sp->mfuncs[i]) == 0 )  {
d193 1
a193 1
dosetup( cp, rp, dpp, mpp )
d198 1
d236 1
a236 1
	if( mfp->mf_setup( rp, &arg, dpp, mfp ) < 0 )  {
@


11.1
log
@Release_4.4
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_stack.c,v 10.2 94/08/11 02:27:43 gdurf Exp $ (BRL)";
d231 1
a231 1
	if( mfp->mf_setup( rp, &arg, dpp ) < 0 )  {
@


10.2
log
@Added include of conf.h
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_stack.c,v 10.1 1991/10/12 06:42:12 mike Rel4_0 gdurf $ (BRL)";
@


10.1
log
@Release_4.0
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_stack.c,v 9.8 91/07/06 00:35:23 mike Exp $ (BRL)";
d21 2
@


9.8
log
@ANSI structure initialization
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_stack.c,v 9.7 91/02/17 18:50:32 mike Exp $ (BRL)";
@


9.7
log
@(Belatedly) changed to call mlib_setup with VLS args
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_stack.c,v 9.6 91/01/05 03:09:16 mike Exp $ (BRL)";
d48 1
a48 1
	"",	0,	(char *)0,	0,			FUNC_NULL
@


9.6
log
@Converted to new format for fmt entry in structparse
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_stack.c,v 9.5 90/12/12 16:35:10 butler Exp $ (BRL)";
d194 1
d227 3
a229 1
	if( mfp->mf_setup( rp, cp, dpp ) < 0 )  {
d233 1
@


9.5
log
@modified to reflect changes in structparse format
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_stack.c,v 9.4 90/12/10 21:16:21 mike Exp $ (BRL)";
d48 1
a48 1
	(char *)0, 0,(char *)0,	0,			FUNC_NULL
@


9.4
log
@'\0', not NULL, for characters.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_stack.c,v 9.3 90/12/08 08:58:16 butler Exp $ (BRL)";
d48 1
a48 1
	(char *)0,(char *)0,	0,			FUNC_NULL
@


9.3
log
@changed material property parameter to be struct rt_vls
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_stack.c,v 9.2 90/11/01 11:18:32 mike Exp $ (BRL)";
d78 1
a78 1
	while( *cp != NULL ) {
d80 1
a80 1
			*cp = NULL;
d204 1
a204 1
	for( i = 0; i < 31 && *cp != NULL; i++, cp++ ) {
@


9.2
log
@Improved printing and debugging.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_stack.c,v 9.1 89/05/19 05:59:42 mike Rel3_5 $ (BRL)";
d59 1
a59 1
char	*matparm;	/* parameter string */
d68 1
d75 1
a75 1
		rt_log( "stk_setup called with \"%s\"\n", matparm );
d77 1
a77 1
	start = cp = matparm;
@


9.1
log
@Release_3.5
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: sh_stack.c,v 8.3 89/04/04 05:02:08 mike Exp $ (BRL)";
a40 1
	char	st_file[128];	/* Filename */
a47 1
	"%s",	"file",		offsetofarray(struct stk_specific, st_file),		FUNC_NULL,
a70 1
	sp->st_file[0] = '\0';
d113 1
a113 1
	bcopy( rp->reg_mfuncs, (char *)mfp, sizeof(*mfp) );
d115 1
a115 1
	rp->reg_mfuncs = (char *)mfp;
d136 3
d152 12
a163 1
	rt_structprint(rp->reg_name, stk_parse, (char *)dp);
d188 1
a188 1
char	*rp;
@


8.3
log
@Converted to new way of representing structure offsets.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: stack.c,v 8.2 88/12/27 16:35:12 mike Locked $ (BRL)";
@


8.2
log
@Converted matparse --> structparse
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: stack.c,v 8.1 88/10/05 00:33:28 mike Locked $ (BRL)";
d46 1
d49 2
a50 2
	"%s",	"file",		(stroff_t)(STK_NULL->st_file),		FUNC_NULL,
	(char *)0,(char *)0,	(stroff_t)0,				FUNC_NULL
d74 1
a74 1
	/*rt_structparse( matparm, stk_parse, (stroff_t)sp );*/
d152 1
a152 1
	rt_structprint(rp->reg_name, stk_parse, (stroff_t)dp);
@


8.1
log
@Release_3.0
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: stack.c,v 7.3 88/09/17 07:20:50 mike Exp $ (BRL)";
d47 3
a49 3
struct matparse stk_parse[] = {
	"file",		(mp_off_ty)(STK_NULL->st_file),	"%s",
	(char *)0,	(mp_off_ty)0,			(char *)0
d73 1
a73 1
	/*mlib_parse( matparm, stk_parse, (mp_off_ty)sp );*/
d92 1
d151 1
a151 1
	mlib_print(rp->reg_name, stk_parse, (mp_off_ty)dp);
@


7.3
log
@The Cray C compilers are now better, so the #ifdef cray code
has been removed.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: stack.c,v 7.2 88/05/14 02:28:26 mike Locked $ (BRL)";
@


7.2
log
@lint fixes
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: stack.c,v 7.1 87/11/02 23:56:37 mike Locked $ (BRL)";
a47 1
#ifndef cray
a48 3
#else
	"file",		(mp_off_ty)1,			"%s",
#endif
@


7.1
log
@Release 2.3
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: stack.c,v 6.2 87/09/16 04:29:00 mike Exp $ (BRL)";
d29 2
a30 1
HIDDEN int stk_setup(), stk_render(), stk_print(), stk_free();
d141 1
a141 1
		sp->mfuncs[i]->mf_render( ap, pp, swp, sp->udata[i] );
d143 1
d149 1
a149 1
HIDDEN int
d160 1
a160 1
HIDDEN int
@


6.2
log
@Stacker allocates a new struct mfuncs for each stack,
with individually OR'ed together input bit-vectors.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: stack.c,v 6.1 87/07/11 07:59:24 mike Locked $ (BRL)";
@


6.1
log
@Release 2.0
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: stack.c,v 1.2 87/07/02 04:14:56 phil Exp $ (BRL)";
d32 1
a32 1
	"stack",	0,		0,		MFI_UV|MFI_NORMAL,
d69 2
d90 6
a95 2
			if( dosetup(start, rp, &sp->udata[i], &sp->mfuncs[i]) == 0 )
				i++;	/* XXX else clear entry? */
d107 6
a112 2
		if( dosetup(start, rp, &sp->udata[i], &sp->mfuncs[i]) == 0 )
			i++;	/* XXX else clear entry? */
d115 5
@


1.2
log
@cleaned up a bit
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
@


1.1
log
@Initial revision
@
text
@d1 21
d76 2
a77 1
fprintf( stderr, "stk_setup called with \"%s\"\n", matparm );
d84 2
a85 2
				fprintf( stderr, "stk_setup: max levels exceeded\n" );
				break;
d88 1
a88 1
			if( dosetup(start, sp, i, rp, &sp->udata[i]) == 0 )
d95 9
d160 2
a161 4
dosetup( string, sp, n, rp, dpp )
char	*string;
register struct stk_specific *sp;
int	n;
d163 2
a164 1
char	**dpp;
d170 9
a178 3
fprintf( stderr, "...starting \"%s\"\n", string );
	for( i = 0; i < 31 && string[i] != NULL; i++ ) {
		if( string[i] == ' ' ) {
d182 1
a182 1
			matname[i] = string[i];
d197 3
a199 3
	sp->mfuncs[n] = mfp;
	sp->udata[n] = (char *)0;
	if( mfp->mf_setup( rp, &string[i], &sp->udata[n] ) < 0 )  {
@
