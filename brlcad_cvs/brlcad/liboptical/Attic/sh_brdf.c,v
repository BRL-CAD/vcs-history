head	1.25;
access;
symbols
	ansi-20040405-merged:1.21.2.2
	postmerge-20040405-ansi:1.23
	premerge-20040404-ansi:1.22
	postmerge-autoconf:1.22
	autoconf-freeze:1.21.10.2
	premerge-autoconf:1.22
	ansi-20040316-freeze:1.21.2.1
	postmerge-20040315-windows:1.22
	premerge-20040315-windows:1.22
	windows-20040315-freeze:1.21.4.1
	autoconf-20031203:1.21
	autoconf-20031202:1.21
	autoconf-branch:1.21.0.10
	phong-branch:1.21.0.8
	photonmap-branch:1.21.0.6
	rel-6-1-DP:1.21
	windows-branch:1.21.0.4
	rel-6-0-2:1.19
	ansi-branch:1.21.0.2
	rel-6-0-1-branch:1.19.0.2
	hartley-6-0-post:1.20
	hartley-6-0-pre:1.19
	rel-6-0-1:1.19
	rel-6-0:1.18
	rel-5-4:1.16
	offsite-5-3-pre:1.18
	rel-5-3:1.16
	rel-5-2:1.16
	rel-5-1-branch:1.16.0.2
	rel-5-1:1.16
	rel-5-0:1.13
	rel-5-0-beta:1.11
	rel-4-5:1.9
	ctj-4-5-post:1.6
	ctj-4-5-pre:1.6;
locks; strict;
comment	@ * @;


1.25
date	2004.05.21.18.07.27;	author morrison;	state dead;
branches;
next	1.24;

1.24
date	2004.05.10.15.30.45;	author erikg;	state Exp;
branches;
next	1.23;

1.23
date	2004.04.05.07.43.37;	author morrison;	state Exp;
branches;
next	1.22;

1.22
date	2004.02.02.17.39.13;	author morrison;	state Exp;
branches;
next	1.21;

1.21
date	2002.08.20.17.07.50;	author jra;	state Exp;
branches
	1.21.2.1
	1.21.4.1
	1.21.10.1;
next	1.20;

1.20
date	2002.08.15.20.55.03;	author hartley;	state Exp;
branches;
next	1.19;

1.19
date	2002.07.16.19.38.38;	author morrison;	state Exp;
branches;
next	1.18;

1.18
date	2000.08.20.01.27.47;	author butler;	state Exp;
branches;
next	1.17;

1.17
date	2000.07.25.16.40.37;	author butler;	state Exp;
branches;
next	1.16;

1.16
date	2000.02.19.21.05.01;	author butler;	state Exp;
branches;
next	1.15;

1.15
date	99.12.30.16.16.20;	author jra;	state Exp;
branches;
next	1.14;

1.14
date	99.10.30.03.06.24;	author butler;	state Exp;
branches;
next	1.13;

1.13
date	99.07.02.22.20.40;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	99.07.01.20.08.44;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	98.09.22.01.29.53;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	98.06.30.22.54.17;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	97.12.31.09.01.40;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	97.11.25.22.18.44;	author butler;	state Exp;
branches;
next	1.7;

1.7
date	97.11.25.22.16.43;	author butler;	state Exp;
branches;
next	1.6;

1.6
date	96.08.31.08.46.01;	author butler;	state Exp;
branches;
next	1.5;

1.5
date	96.08.31.08.29.28;	author butler;	state Exp;
branches;
next	1.4;

1.4
date	96.08.30.00.08.21;	author butler;	state Exp;
branches;
next	1.3;

1.3
date	96.07.12.14.59.48;	author jra;	state Exp;
branches;
next	1.2;

1.2
date	96.06.25.20.43.46;	author jra;	state Exp;
branches;
next	1.1;

1.1
date	96.05.22.17.34.07;	author jra;	state Exp;
branches;
next	;

1.21.2.1
date	2002.09.19.18.01.24;	author morrison;	state Exp;
branches;
next	1.21.2.2;

1.21.2.2
date	2004.03.17.21.18.31;	author morrison;	state Exp;
branches;
next	;

1.21.4.1
date	2004.03.11.23.43.02;	author morrison;	state Exp;
branches;
next	;

1.21.10.1
date	2004.02.12.18.38.49;	author erikg;	state Exp;
branches;
next	1.21.10.2;

1.21.10.2
date	2004.03.15.14.07.12;	author erikg;	state Exp;
branches;
next	;


desc
@Simple Isotropic Gaussian model with just one parameter (RMS slope).
@


1.25
log
@moved to src/
@
text
@/*
 *			B R D F
 *
 *  Simple Isotropic Gaussian model with just one parameter (RMS slope).
 *
 *  Notes -
 *	The normals on all surfaces point OUT of the solid.
 *	The incoming light rays point IN.
 *
 *  Authors -
 *	John R. Anderson
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Pacakge" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1996-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 *
 *	Based on the simple Isotropic Gaussian Model presented by Gregory Ward
 *	in "Measuring and Modeling Anisotropic Reflection" (Which also references
 *	earlier work by Beckmann, Torrance, and Cook).
 */
#ifndef lint
static const char RCSbrdf[] = "@@(#)$Header: /n/xoff/cvs/brlcad/liboptical/sh_brdf.c,v 1.24 2004/05/10 15:30:45 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#include "machine.h"
#include "vmath.h"
#include "mater.h"
#include "raytrace.h"
#include "shadefuncs.h"
#include "shadework.h"
#include "rtprivate.h"
#include "light.h"

extern int rr_render(struct application	*ap,
		     struct partition	*pp,
		     struct shadework   *swp);
/* from view.c */
extern double AmbientIntensity;

/* Local information */
struct brdf_specific {
	int	magic;
	double	specular_refl;	/* specular reflectance */
	double	diffuse_refl;	/* diffuse reflectnace */
	double	rms_slope;	/* Standard deviation (RMS) of surface slope (roughness) */
	double	rms_sq;		/* square of above */
	double	denom;		/* denominator for specular term */
	double	transmit;	/* Moss "transparency" */
	double	reflect;	/* Moss "transmission" */
	double	refrac_index;
	double	extinction;
};
#define BRDF_MAGIC	0xbeef00d
#define BRDF_NULL	((struct brdf_specific *)0)
#define BRDF_O(m)	offsetof(struct brdf_specific, m)

struct bu_structparse brdf_parse[] = {
	{"%f",	1, "specular",		BRDF_O(specular_refl),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "sp",		BRDF_O(specular_refl),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "diffuse",		BRDF_O(diffuse_refl),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "di",		BRDF_O(diffuse_refl),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "rough",		BRDF_O(rms_slope),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "rms",		BRDF_O(rms_slope),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "transmit",		BRDF_O(transmit),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "tr",		BRDF_O(transmit),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "reflect",		BRDF_O(reflect),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "re",		BRDF_O(reflect),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "ri",		BRDF_O(refrac_index),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "extinction_per_meter", BRDF_O(extinction),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "extinction",	BRDF_O(extinction),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "ex",		BRDF_O(extinction),	BU_STRUCTPARSE_FUNC_NULL },
	{"",	0, (char *)0,		0,			BU_STRUCTPARSE_FUNC_NULL }
};

HIDDEN int brdf_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip);
HIDDEN int brdf_render(register struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
HIDDEN void	brdf_print(register struct region *rp, char *dp);
HIDDEN void	brdf_free(char *cp);

struct mfuncs brdf_mfuncs[] = {
	{MF_MAGIC,	"brdf",		0,		MFI_NORMAL|MFI_LIGHT,	0,
	brdf_setup,	brdf_render,	brdf_print,	brdf_free },

	{0,		(char *)0,	0,		0,	0,
	0,		0,		0,		0 }
};

#define RI_AIR		1.0    /* Refractive index of air.		*/

/*
 *			B R D F _ S E T U P
 */
HIDDEN int
brdf_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip)
{
	register struct brdf_specific *pp;

	BU_CK_VLS( matparm );
	BU_GETSTRUCT( pp, brdf_specific );
	*dpp = (char *)pp;

	pp->magic = BRDF_MAGIC;
	pp->specular_refl = 0.7;
	pp->diffuse_refl = 0.3;
	pp->transmit = 0.0;
	pp->reflect = 0.0;
	pp->refrac_index = RI_AIR;
	pp->extinction = 0.0;
	pp->rms_slope = 0.05;

	if (bu_struct_parse( matparm, brdf_parse, (char *)pp ) < 0 )  {
		bu_free( (char *)pp, "brdf_specific" );
		return(-1);
	}

	pp->rms_sq = pp->rms_slope * pp->rms_slope;
	pp->denom = 4.0 * bn_pi * pp->rms_sq;

	return(1);
}
/*
 *			B R D F _ P R I N T
 */
HIDDEN void
brdf_print(register struct region *rp, char *dp)
{
	bu_struct_print(rp->reg_name, brdf_parse, (char *)dp);
}

/*
 *			B R D F _ F R E E
 */
HIDDEN void
brdf_free(char *cp)
{
	bu_free( cp, "brdf_specific" );
}


/*
 *			B R D F _ R E N D E R
 *
	Color pixel based on the energy of a point light source (Eps)
	plus some diffuse illumination (Epd) reflected from the point
	<x,y> :

				E = Epd + Eps		(1)

	The energy reflected from diffuse illumination is the product
	of the reflectance coefficient at point P (Rp) and the diffuse
	illumination (Id) :

				Epd = Rp * Id		(2)

	The energy reflected from the point light source is calculated
	by the sum of the diffuse reflectance (Rd) and the specular
	reflectance (Rs), multiplied by the intensity of the light
	source (Ips) :

				Eps = (Rd + Rs) * Ips	(3)

	The diffuse reflectance is calculated by the product of the
	reflectance coefficient (Rp) and the cosine of the angle of
	incidence (I) and normalized by PI :

				Rd = Rp * cos(I) / PI	(4)

	The specular reflectance is calculated by the product of the
	specular reflectance coeffient and a term dependent on the
	surface roughness :

				Rs = W(I,O) * R(I,O,r)	(5)

	Where,
		I is the angle of incidence.
		O is the angle to the observer.
		r is the standard deviation (RMS) of the surface slope.
		W returns the specular reflection coefficient as a function
	of the angle of incidence, and the viewer angle.
		R is a surface roughness term.

 */
HIDDEN int
brdf_render(register struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
{
	register struct light_specific *lp;
	register fastf_t *intensity, *to_light;
	register int	i;
	register fastf_t cosi,cosr;
	register fastf_t refl;
	vect_t h_dir;
	vect_t to_eye;
	vect_t	work;
	vect_t	cprod;			/* color product */
	point_t	matcolor;		/* Material color */
	struct brdf_specific *ps =
		(struct brdf_specific *)dp;

	if (ps->magic != BRDF_MAGIC )  bu_log("brdf_render: bad magic\n");

	if (rdebug&RDEBUG_SHADE)
		bu_struct_print( "brdf_render", brdf_parse, (char *)ps );

	swp->sw_transmit = ps->transmit;
	swp->sw_reflect = ps->reflect;
	swp->sw_refrac_index = ps->refrac_index;
	swp->sw_extinction = ps->extinction;
	if (swp->sw_xmitonly ) {
		if (swp->sw_reflect > 0 || swp->sw_transmit > 0 )
			(void)rr_render( ap, pp, swp );
		return(1);	/* done */
	}

	VMOVE( matcolor, swp->sw_color );

	/* Diffuse reflectance from "Ambient" light source (at eye) */
	if ((cosr = -VDOT( swp->sw_hit.hit_normal, ap->a_ray.r_dir )) > 0.0 )  {
		if (cosr > 1.00001 )  {
			bu_log("cosAmb=1+%g (x%d,y%d,lvl%d)\n", cosr-1,
				ap->a_x, ap->a_y, ap->a_level);
			cosr = 1;
		}
		refl = cosr * AmbientIntensity;
		VSCALE( swp->sw_color, matcolor, refl );
	} else {
		VSETALL( swp->sw_color, 0 );
	}

	VREVERSE( to_eye, ap->a_ray.r_dir );

	/* Consider effects of each light source */
	for( i=ap->a_rt_i->rti_nlights-1; i>=0; i-- )  {
		fastf_t cos_tmp;
		fastf_t tan_sq;
		double exponent;

		if ((lp = (struct light_specific *)swp->sw_visible[i]) == LIGHT_NULL )
			continue;
	
		/* Light is not shadowed -- add this contribution */
		intensity = swp->sw_intensity+3*i;
		to_light = swp->sw_tolight+3*i;

		if ((cosi = VDOT( swp->sw_hit.hit_normal, to_light )) > 0.0 )  {
			if (cosi > 1.00001 )  {
				bu_log("cosI=1+%g (x%d,y%d,lvl%d)\n", cosi-1,
					ap->a_x, ap->a_y, ap->a_level);
				cosi = 1;
			}

			/* Diffuse reflectance from this light source. */
			refl = cosi * lp->lt_fraction * ps->diffuse_refl;
			VELMUL( work, lp->lt_color,
				intensity );
			VELMUL( cprod, matcolor, work );
			VJOIN1( swp->sw_color, swp->sw_color,
				refl, cprod );

			/* Calculate specular reflectance. */
			if (NEAR_ZERO( ps->rms_sq, SMALL_FASTF ) )
				continue;
			VADD2( h_dir, to_eye, to_light )
			VUNITIZE( h_dir );
			cos_tmp = VDOT( h_dir, swp->sw_hit.hit_normal );
			if (cos_tmp <= 0.0 )
				continue;
			cos_tmp *= cos_tmp;
			if (NEAR_ZERO( cos_tmp, SMALL_FASTF ) )
				continue;

			tan_sq = (1.0-cos_tmp)/cos_tmp;
			exponent = (-tan_sq/ps->rms_sq );
			refl = ps->specular_refl * lp->lt_fraction * exp( exponent ) /
				sqrt( cosi * cosr ) / ps->denom;
			if (refl > 1.0 )
				refl = 1.0;

			VELMUL( work, lp->lt_color, intensity );
			VJOIN1( swp->sw_color, swp->sw_color, refl, work );

		}
	}

	if (swp->sw_reflect > 0 || swp->sw_transmit > 0 )
		(void)rr_render( ap, pp, swp );
	return(1);
}

@


1.24
log
@change conf.h to a wrapped config.h
@
text
@d31 1
a31 1
static const char RCSbrdf[] = "@@(#)$Header: /cvs/brlcad/liboptical/sh_brdf.c,v 1.23 2004/04/05 07:43:37 morrison Exp $ (BRL)";
@


1.23
log
@merge of ansi-6-0-branch into HEAD
@
text
@d31 1
a31 1
static const char RCSbrdf[] = "@@(#)$Header$ (BRL)";
d34 5
a38 1
#include "conf.h"
@


1.22
log
@update copyright to include span through 2003
@
text
@d31 1
a31 1
static const char RCSbrdf[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_brdf.c,v 1.21 2002/08/20 17:07:50 jra Exp $ (BRL)";
d88 4
a91 4
HIDDEN int brdf_setup();
HIDDEN int brdf_render();
HIDDEN void	brdf_print();
HIDDEN void	brdf_free();
d107 1
a107 6
brdf_setup( rp, matparm, dpp, mfp, rtip )
register struct region *rp;
struct bu_vls	*matparm;
char	**dpp;
struct mfuncs	*mfp;
struct rt_i	*rtip;
d138 1
a138 3
brdf_print( rp, dp )
register struct region *rp;
char	*dp;
d147 1
a147 2
brdf_free( cp )
char *cp;
d197 1
a197 5
brdf_render( ap, pp, swp, dp )
register struct application *ap;
struct partition	*pp;
struct shadework	*swp;
char	*dp;
@


1.21
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d23 1
a23 1
 *	This software is Copyright (C) 1996 by the United States Army
d31 1
a31 1
static const char RCSbrdf[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_brdf.c,v 1.19 2002/07/16 19:38:38 morrison Exp $ (BRL)";
@


1.21.4.1
log
@sync to HEAD...
@
text
@d23 1
a23 1
 *	This software is Copyright (C) 1996-2004 by the United States Army
d31 1
a31 1
static const char RCSbrdf[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/liboptical/sh_brdf.c,v 1.22 2004/02/02 17:39:13 morrison Exp $ (BRL)";
@


1.21.10.1
log
@merge from HEAD
@
text
@d23 1
a23 1
 *	This software is Copyright (C) 1996-2004 by the United States Army
d31 1
a31 1
static const char RCSbrdf[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_brdf.c,v 1.22 2004/02/02 17:39:13 morrison Exp $ (BRL)";
@


1.21.10.2
log
@merge from head
@
text
@d31 1
a31 1
static const char RCSbrdf[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_brdf.c,v 1.21.10.1 2004/02/12 18:38:49 erikg Exp $ (BRL)";
@


1.21.2.1
log
@Initial ANSIfication
@
text
@d31 1
a31 1
static const char RCSbrdf[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_brdf.c,v 1.21 2002/08/20 17:07:50 jra Exp $ (BRL)";
d88 4
a91 4
HIDDEN int brdf_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip);
HIDDEN int brdf_render(register struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
HIDDEN void	brdf_print(register struct region *rp, char *dp);
HIDDEN void	brdf_free(char *cp);
d107 6
a112 1
brdf_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip)
d143 3
a145 1
brdf_print(register struct region *rp, char *dp)
d154 2
a155 1
brdf_free(char *cp)
d205 5
a209 1
brdf_render(register struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
@


1.21.2.2
log
@sync branch with HEAD
@
text
@d23 1
a23 1
 *	This software is Copyright (C) 1996-2004 by the United States Army
d31 1
a31 1
static const char RCSbrdf[] = "@@(#)$Header$ (BRL)";
@


1.20
log
@Converted from K&R to ANSI C - RFH
@
text
@d88 4
a91 4
HIDDEN int brdf_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip);
HIDDEN int brdf_render(register struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
HIDDEN void	brdf_print(register struct region *rp, char *dp);
HIDDEN void	brdf_free(char *cp);
d107 6
a112 1
brdf_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip)
d143 3
a145 1
brdf_print(register struct region *rp, char *dp)
d154 2
a155 1
brdf_free(char *cp)
d205 5
a209 1
brdf_render(register struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
@


1.19
log
@Moved the non-local-only header file (light.h) from rt/ into the header directory since it is used by multiple targets (liboptical, rt, etc)
@
text
@d31 1
a31 1
static const char RCSbrdf[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_brdf.c,v 1.18 2000/08/20 01:27:47 butler Exp $ (BRL)";
d88 4
a91 4
HIDDEN int brdf_setup();
HIDDEN int brdf_render();
HIDDEN void	brdf_print();
HIDDEN void	brdf_free();
d107 1
a107 6
brdf_setup( rp, matparm, dpp, mfp, rtip )
register struct region *rp;
struct bu_vls	*matparm;
char	**dpp;
struct mfuncs	*mfp;
struct rt_i	*rtip;
d138 1
a138 3
brdf_print( rp, dp )
register struct region *rp;
char	*dp;
d147 1
a147 2
brdf_free( cp )
char *cp;
d197 1
a197 5
brdf_render( ap, pp, swp, dp )
register struct application *ap;
struct partition	*pp;
struct shadework	*swp;
char	*dp;
@


1.18
log
@Eliminate compilation warnings, enhancements to sh_light.c
@
text
@d31 1
a31 1
static const char RCSbrdf[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_brdf.c,v 1.17 2000/07/25 16:40:37 butler Exp $ (BRL)";
d45 1
a45 1
#include "../rt/light.h"
@


1.17
log
@Changes to use rtprivate.h instead of ../rt/rdebug.h
@
text
@d31 1
a31 1
static char RCSbrdf[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_brdf.c,v 1.16 2000/02/19 21:05:01 butler Exp $ (BRL)";
@


1.16
log
@Changes to support movement of CLAMP() macro into vmath.h
Altered "if( " statements to "if (" for readability.
@
text
@d31 1
a31 1
static char RCSbrdf[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_brdf.c,v 1.15 1999/12/30 16:16:20 jra Exp $ (BRL)";
d44 1
a44 1
#include "../rt/rdebug.h"
d47 3
@


1.15
log
@Eliminated an unused variable
@
text
@d31 1
a31 1
static char RCSbrdf[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_brdf.c,v 1.14 1999/10/30 03:06:24 butler Exp $ (BRL)";
d126 1
a126 1
	if( bu_struct_parse( matparm, brdf_parse, (char *)pp ) < 0 )  {
d221 1
a221 1
	if( ps->magic != BRDF_MAGIC )  bu_log("brdf_render: bad magic\n");
d223 1
a223 1
	if( rdebug&RDEBUG_SHADE)
d230 2
a231 2
	if( swp->sw_xmitonly ) {
		if( swp->sw_reflect > 0 || swp->sw_transmit > 0 )
d239 2
a240 2
	if( (cosr = -VDOT( swp->sw_hit.hit_normal, ap->a_ray.r_dir )) > 0.0 )  {
		if( cosr > 1.00001 )  {
d259 1
a259 1
		if( (lp = (struct light_specific *)swp->sw_visible[i]) == LIGHT_NULL )
d266 2
a267 2
		if( (cosi = VDOT( swp->sw_hit.hit_normal, to_light )) > 0.0 )  {
			if( cosi > 1.00001 )  {
d282 1
a282 1
			if( NEAR_ZERO( ps->rms_sq, SMALL_FASTF ) )
d287 1
a287 1
			if( cos_tmp <= 0.0 )
d290 1
a290 1
			if( NEAR_ZERO( cos_tmp, SMALL_FASTF ) )
d297 1
a297 1
			if( refl > 1.0 )
d306 1
a306 1
	if( swp->sw_reflect > 0 || swp->sw_transmit > 0 )
@


1.14
log
@Moved mathtab/rand_half from rt into libbn
Expanded structparse to include description and default
@
text
@d31 1
a31 1
static char RCSbrdf[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_brdf.c,v 1.13 1999/07/02 22:20:40 mike Exp $ (BRL)";
a215 1
	vect_t	reflected;
@


1.13
log
@
Removed dependence on compat4.h
@
text
@d31 1
a31 1
static char RCSbrdf[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_brdf.c,v 1.12 1999/07/01 20:08:44 mike Exp $ (BRL)";
a43 1
#include "../rt/mathtab.h"
@


1.12
log
@
compat4
@
text
@d31 1
a31 1
static char RCSbrdf[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_brdf.c,v 1.11 1998/09/22 01:29:53 mike Exp $ (BRL)";
d69 15
a83 15
	{"%f",	1, "specular",		BRDF_O(specular_refl),	FUNC_NULL },
	{"%f",	1, "sp",		BRDF_O(specular_refl),	FUNC_NULL },
	{"%f",	1, "diffuse",		BRDF_O(diffuse_refl),	FUNC_NULL },
	{"%f",	1, "di",		BRDF_O(diffuse_refl),	FUNC_NULL },
	{"%f",	1, "rough",		BRDF_O(rms_slope),	FUNC_NULL },
	{"%f",	1, "rms",		BRDF_O(rms_slope),	FUNC_NULL },
	{"%f",	1, "transmit",		BRDF_O(transmit),	FUNC_NULL },
	{"%f",	1, "tr",		BRDF_O(transmit),	FUNC_NULL },
	{"%f",	1, "reflect",		BRDF_O(reflect),	FUNC_NULL },
	{"%f",	1, "re",		BRDF_O(reflect),	FUNC_NULL },
	{"%f",	1, "ri",		BRDF_O(refrac_index),	FUNC_NULL },
	{"%f",	1, "extinction_per_meter", BRDF_O(extinction),	FUNC_NULL },
	{"%f",	1, "extinction",	BRDF_O(extinction),	FUNC_NULL },
	{"%f",	1, "ex",		BRDF_O(extinction),	FUNC_NULL },
	{"",	0, (char *)0,		0,			FUNC_NULL }
@


1.11
log
@Moved optical shaders from rt/ to liboptical/
The only modifications involved moving and splitting
rt/material.h into h/shadefuncs.h and h/shadework.h,
and in changing the calling sequence to mlib_setup() in rt/material.c

Now the only shader function called directly by RT is
in liboptical/init.c: optical_shader_init().
It adds all the individual shaders to the "mfuncs" shader list.
@
text
@d31 1
a31 1
static char RCSbrdf[] = "@@(#)$Header: /c/CVS/brlcad/rt/sh_brdf.c,v 1.10 1998/06/30 22:54:17 mike Exp $ (BRL)";
d107 1
a107 1
struct rt_vls	*matparm;
d114 2
a115 2
	RT_VLS_CHECK( matparm );
	GETSTRUCT( pp, brdf_specific );
d128 1
a128 1
		rt_free( (char *)pp, "brdf_specific" );
d133 1
a133 1
	pp->denom = 4.0 * rt_pi * pp->rms_sq;
d155 1
a155 1
	rt_free( cp, "brdf_specific" );
d223 1
a223 1
	if( ps->magic != BRDF_MAGIC )  rt_log("brdf_render: bad magic\n");
d243 1
a243 1
			rt_log("cosAmb=1+%g (x%d,y%d,lvl%d)\n", cosr-1,
d270 1
a270 1
				rt_log("cosI=1+%g (x%d,y%d,lvl%d)\n", cosi-1,
@


1.10
log
@Can't make "struct mfuncs" a CONST, because the forward link needs
to be filled in at runtime, and some compilers put CONST data into
read-only pages (like FreeBSD).
@
text
@d31 1
a31 1
static char RCSbrdf[] = "@@(#)$Header: /c/CVS/brlcad/rt/sh_brdf.c,v 1.9 1997/12/31 09:01:40 mike Exp $ (BRL)";
d42 5
a46 3
#include "./rdebug.h"
#include "./material.h"
#include "./light.h"
@


1.9
log
@Required magic number to be first in mfunc table,
consistent with all other BRL-CAD magic numbers.
Required magic number to be initialized at compile time.
Added code to check the magic numbers.
Made the xxx_mfunc arrays CONST, so they can't get trashed by
runtime runaway pointer problems.
@
text
@d31 1
a31 1
static char RCSbrdf[] = "@@(#)$Header: /m/cad/rt/RCS/sh_brdf.c,v 1.8 1997/11/25 22:18:44 butler Exp mike $ (BRL)";
d89 1
a89 1
CONST struct mfuncs brdf_mfuncs[] = {
@


1.8
log
@fixed typo
@
text
@d31 1
a31 1
static char RCSbrdf[] = "@@(#)$Header: /m/cad/rt/RCS/sh_brdf.c,v 1.7 1997/11/25 22:16:43 butler Exp butler $ (BRL)";
d89 2
a90 2
struct mfuncs brdf_mfuncs[] = {
	{"brdf",	0,		0,		MFI_NORMAL|MFI_LIGHT,	0,
d93 1
a93 1
	{(char *)0,	0,		0,		0,	0,
@


1.7
log
@updated all shaders so that _setup had mfp and rtip parameters
@
text
@d31 1
a31 1
static char RCSbrdf[] = "@@(#)$Header: /m/cad/rt/RCS/sh_brdf.c,v 1.6 1996/08/31 08:46:01 butler Exp butler $ (BRL)";
d103 1
a103 1
brdf_setup( rp, matparm, dpp, mpf, rtip )
@


1.6
log
@bu_struct_print
@
text
@d31 1
a31 1
static char RCSbrdf[] = "@@(#)$Header: /m/cad/rt/RCS/sh_brdf.c,v 1.5 1996/08/31 08:29:28 butler Exp butler $ (BRL)";
d103 1
a103 1
brdf_setup( rp, matparm, dpp )
d107 2
@


1.5
log
@bu_struct_parse
@
text
@d31 1
a31 1
static char RCSbrdf[] = "@@(#)$Header: /m/cad/rt/RCS/sh_brdf.c,v 1.4 1996/08/30 00:08:21 butler Exp butler $ (BRL)";
d141 1
a141 1
	bu_structprint(rp->reg_name, brdf_parse, (char *)dp);
d222 1
a222 1
		bu_structprint( "brdf_render", brdf_parse, (char *)ps );
@


1.4
log
@structparse moved to libbu
@
text
@d31 1
a31 1
static char RCSbrdf[] = "@@(#)$Header: /m/cad/rt/RCS/sh_brdf.c,v 1.3 1996/07/12 14:59:48 jra Exp butler $ (BRL)";
d123 1
a123 1
	if( bu_structparse( matparm, brdf_parse, (char *)pp ) < 0 )  {
@


1.3
log
@Minor mod for IRIX 6.2
@
text
@d31 1
a31 1
static char RCSbrdf[] = "@@(#)$Header: /m/cad/rt/RCS/sh_brdf.c,v 1.2 1996/06/25 20:43:46 jra Exp jra $ (BRL)";
d66 1
a66 1
struct structparse brdf_parse[] = {
d123 1
a123 1
	if( rt_structparse( matparm, brdf_parse, (char *)pp ) < 0 )  {
d141 1
a141 1
	rt_structprint(rp->reg_name, brdf_parse, (char *)dp);
d222 1
a222 1
		rt_structprint( "brdf_render", brdf_parse, (char *)ps );
@


1.2
log
@A few minor mods.
@
text
@d31 1
a31 1
static char RCSbrdf[] = "@@(#)$Header: /m/cad/rt/RCS/sh_brdf.c,v 1.1 1996/05/22 17:34:07 jra Exp jra $ (BRL)";
d129 1
a129 1
	pp->denom = 4.0 * M_PI * pp->rms_sq;
@


1.1
log
@Initial revision
@
text
@d31 1
a31 1
static char RCSplastic[] = "@@(#)$Header: /m/cad/rt/RCS/sh_plastic.c,v 11.5 1996/05/09 03:25:47 butler Exp $ (BRL)";
d97 2
d117 4
d129 1
a129 1
	pp->denom = 4.0 * pp->rms_sq;
d243 2
a244 2
		cosr *= AmbientIntensity;
		VSCALE( swp->sw_color, matcolor, cosr );
a263 1
		/* Diffuse reflectance from this light source. */
d270 2
a277 1
		}
d279 18
a296 9
		/* Calculate specular reflectance. */
		if( NEAR_ZERO( ps->rms_sq, SMALL_FASTF ) )
			continue;
		VADD2( h_dir, to_eye, to_light )
		VUNITIZE( h_dir );
		cos_tmp = VDOT( h_dir, swp->sw_hit.hit_normal );
		cos_tmp *= cos_tmp;
		if( NEAR_ZERO( cos_tmp, SMALL_FASTF ) )
			continue;
d298 2
a299 5
		tan_sq = (1.0-cos_tmp)/cos_tmp;
		exponent = (-tan_sq/ps->rms_sq );
		refl = ps->specular_refl * lp->lt_fraction * exp( exponent ) /
			sqrt( VDOT( to_light, swp->sw_hit.hit_normal ) *
			      VDOT( to_eye, swp->sw_hit.hit_normal ) ) / ps->denom;
d301 1
a301 2
		VELMUL( work, lp->lt_color, intensity );
		VJOIN1( swp->sw_color, swp->sw_color, refl, work );
d303 1
@
