head	11.21;
access;
symbols
	ansi-20040405-merged:11.17.2.2
	postmerge-20040405-ansi:11.19
	premerge-20040404-ansi:11.18
	postmerge-autoconf:11.18
	autoconf-freeze:11.17.10.2
	premerge-autoconf:11.18
	ansi-20040316-freeze:11.17.2.1
	postmerge-20040315-windows:11.18
	premerge-20040315-windows:11.18
	windows-20040315-freeze:11.17.4.1
	autoconf-20031203:11.17
	autoconf-20031202:11.17
	autoconf-branch:11.17.0.10
	phong-branch:11.17.0.8
	photonmap-branch:11.17.0.6
	rel-6-1-DP:11.17
	windows-branch:11.17.0.4
	rel-6-0-2:11.15
	ansi-branch:11.17.0.2
	rel-6-0-1-branch:11.15.0.2
	hartley-6-0-post:11.16
	hartley-6-0-pre:11.15
	rel-6-0-1:11.15
	rel-6-0:11.15
	rel-5-4:11.13
	offsite-5-3-pre:11.15
	rel-5-3:11.13
	rel-5-2:11.13
	rel-5-1-branch:11.13.0.2
	rel-5-1:11.13
	rel-5-0:11.11
	rel-5-0-beta:11.9
	rel-4-5:11.7
	ctj-4-5-post:11.5
	ctj-4-5-pre:11.5
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.2
	rel-1-10:4.1;
locks; strict;
comment	@ * @;


11.21
date	2004.05.21.18.07.28;	author morrison;	state dead;
branches;
next	11.20;

11.20
date	2004.05.10.15.30.45;	author erikg;	state Exp;
branches;
next	11.19;

11.19
date	2004.04.05.07.43.37;	author morrison;	state Exp;
branches;
next	11.18;

11.18
date	2004.02.02.17.39.14;	author morrison;	state Exp;
branches;
next	11.17;

11.17
date	2002.08.20.17.07.52;	author jra;	state Exp;
branches
	11.17.2.1
	11.17.4.1
	11.17.10.1;
next	11.16;

11.16
date	2002.08.15.20.55.04;	author hartley;	state Exp;
branches;
next	11.15;

11.15
date	2000.08.20.01.27.48;	author butler;	state Exp;
branches;
next	11.14;

11.14
date	2000.07.25.16.40.38;	author butler;	state Exp;
branches;
next	11.13;

11.13
date	2000.02.19.21.05.02;	author butler;	state Exp;
branches;
next	11.12;

11.12
date	99.10.30.03.06.25;	author butler;	state Exp;
branches;
next	11.11;

11.11
date	99.07.02.22.20.41;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	99.07.01.20.08.48;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	98.09.22.01.29.55;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	98.06.30.22.54.19;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	97.12.31.09.01.40;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	97.11.25.22.16.43;	author butler;	state Exp;
branches;
next	11.5;

11.5
date	96.08.31.08.46.01;	author butler;	state Exp;
branches;
next	11.4;

11.4
date	96.08.31.08.29.28;	author butler;	state Exp;
branches;
next	11.3;

11.3
date	96.08.30.00.08.21;	author butler;	state Exp;
branches;
next	11.2;

11.2
date	95.10.20.04.43.53;	author butler;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.01.10;	author mike;	state Rel4_4;
branches;
next	10.3;

10.3
date	94.08.11.02.26.16;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	92.08.27.19.54.56;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.42.11;	author mike;	state Rel4_0;
branches;
next	9.7;

9.7
date	91.08.29.22.39.26;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	91.07.06.00.35.22;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	91.02.17.20.15.54;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	91.01.05.03.09.15;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	90.12.12.16.35.09;	author butler;	state Exp;
branches;
next	9.2;

9.2
date	90.12.08.08.58.15;	author butler;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.59.41;	author mike;	state Rel3_5;
branches;
next	8.4;

8.4
date	89.04.30.20.46.21;	author mike;	state Exp;
branches;
next	8.3;

8.3
date	89.04.04.05.02.06;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	88.12.27.16.35.08;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.33.26;	author mike;	state Rel3_0;
branches;
next	7.5;

7.5
date	88.09.17.07.20.30;	author mike;	state Exp;
branches;
next	7.4;

7.4
date	88.06.21.02.48.39;	author mike;	state Exp;
branches;
next	7.3;

7.3
date	88.05.14.02.28.24;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	88.01.29.22.43.48;	author phil;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.56.31;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.07.59.18;	author mike;	state Rel;
branches;
next	5.3;

5.3
date	87.06.27.06.46.18;	author phil;	state Exp;
branches;
next	5.2;

5.2
date	87.06.26.05.57.38;	author mike;	state Exp;
branches;
next	5.1;

5.1
date	87.06.24.22.15.23;	author mike;	state Rel;
branches;
next	4.4;

4.4
date	87.03.24.00.50.45;	author phil;	state Exp;
branches;
next	4.3;

4.3
date	87.03.23.23.48.11;	author mike;	state Exp;
branches;
next	4.2;

4.2
date	87.02.13.00.02.49;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.48.44;	author mike;	state Rel1;
branches;
next	1.4;

1.4
date	86.12.18.16.02.04;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	86.11.25.03.35.18;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	86.11.07.02.46.20;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	89.10.31.08.15.12;	author mike;	state Exp;
branches;
next	;

11.17.2.1
date	2002.09.19.18.01.26;	author morrison;	state Exp;
branches;
next	11.17.2.2;

11.17.2.2
date	2004.03.17.21.18.32;	author morrison;	state Exp;
branches;
next	;

11.17.4.1
date	2004.03.11.23.43.03;	author morrison;	state Exp;
branches;
next	;

11.17.10.1
date	2004.02.12.18.38.49;	author erikg;	state Exp;
branches;
next	11.17.10.2;

11.17.10.2
date	2004.03.15.14.07.13;	author erikg;	state Exp;
branches;
next	;


desc
@Generate texture maps from spherical data structures
@


11.21
log
@moved to src/
@
text
@/*
 *			S P M . C
 *
 *  Spherical Data Structures/Texture Maps
 *
 *  Author -
 *	Phillip Dykstra
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1986-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/liboptical/sh_spm.c,v 11.20 2004/05/10 15:30:45 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "fb.h"
#include "spm.h"
#include "shadefuncs.h"
#include "shadework.h"
#include "rtprivate.h"

#define SPM_NAME_LEN 128
struct spm_specific {
	char	sp_file[SPM_NAME_LEN];	/* Filename */
	int	sp_w;		/* Width: number of pixels around equator */
	spm_map_t *sp_map;	/* stuff */
};
#define SP_NULL	((struct spm_specific *)0)
#define SP_O(m)	offsetof(struct spm_specific, m)

struct bu_structparse spm_parse[] = {
	{"%s",	SPM_NAME_LEN, "file",		bu_offsetofarray(struct spm_specific, sp_file),	BU_STRUCTPARSE_FUNC_NULL },
	{"%d",	1, "w",		SP_O(sp_w),	BU_STRUCTPARSE_FUNC_NULL },
	{"%d",	1, "n",		SP_O(sp_w),	BU_STRUCTPARSE_FUNC_NULL },	/*compat*/
	{"",	0, (char *)0,	0,		BU_STRUCTPARSE_FUNC_NULL }
};

HIDDEN int	spm_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip), spm_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
HIDDEN void	spm_print(register struct region *rp, char *dp), spm_mfree(char *cp);

struct mfuncs spm_mfuncs[] = {
	{MF_MAGIC,	"spm",		0,		MFI_UV,		0,
	spm_setup,	spm_render,	spm_print,	spm_mfree },

	{0,		(char *)0,	0,		0,		0,
	0,		0,		0,		0 }
};

/*
 *  			S P M _ R E N D E R
 *  
 *  Given a u,v coordinate within the texture ( 0 <= u,v <= 1.0 ),
 *  return a pointer to the relevant pixel.
 */
HIDDEN int
spm_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
{
	register struct spm_specific *spp =
		(struct spm_specific *)dp;
	int	x, y;
	register unsigned char *cp;

	/** spm_read( spp->sp_map, xxx ); **/
	/* Limits checking? */
	y = swp->sw_uv.uv_v * spp->sp_map->ny;
	x = swp->sw_uv.uv_u * spp->sp_map->nx[y];
	cp = &(spp->sp_map->xbin[y][x*3]);
	VSET( swp->sw_color,
		((double)cp[RED])/256.,
		((double)cp[GRN])/256.,
		((double)cp[BLU])/256. );
	return(1);
}

/*
 *			S P M _ S E T U P
 *
 *  Returns -
 *	<0	failed
 *	>0	success
 */
HIDDEN int
spm_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip)
                           
             	         
    	      
                             
                                /* New since 4.4 release */
{
	register struct spm_specific *spp;

	BU_CK_VLS( matparm );
	BU_GETSTRUCT( spp, spm_specific );
	*dpp = (char *)spp;

	spp->sp_file[0] = '\0';
	spp->sp_w = -1;
	if (bu_struct_parse( matparm, spm_parse, (char *)spp ) < 0 )  {
		bu_free( (char *)spp, "spm_specific" );
		return(-1);
	}
	if (spp->sp_w < 0 )  spp->sp_w = 512;
	if (spp->sp_file[0] == '\0' )
		goto fail;
	if ((spp->sp_map = spm_init( spp->sp_w, sizeof(RGBpixel) )) == SPM_NULL )
		goto fail;
	if (spm_load( spp->sp_map, spp->sp_file ) < 0 )
		goto fail;
	return(1);
fail:
	spm_mfree( (char *)spp);
	return(-1);
}

/*
 *			S P M _ P R I N T
 */
HIDDEN void
spm_print(register struct region *rp, char *dp)
{
	struct spm_specific	*spm;

	spm = (struct spm_specific *)dp;

	bu_log("spm_print(rp=x%x, dp=x%x)\n", rp, dp);
	(void)bu_struct_print("spm_print", spm_parse, (char *)dp);
	if (spm->sp_map )  spm_dump( spm->sp_map, 0 );
}

HIDDEN void
spm_mfree(char *cp)
{
	struct spm_specific	*spm;

	spm = (struct spm_specific *)cp;

	if (spm->sp_map )  spm_free( spm->sp_map );
	spm->sp_map = NULL;
	bu_free( cp, "spm_specific" );
}
@


11.20
log
@change conf.h to a wrapped config.h
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/liboptical/sh_spm.c,v 11.19 2004/04/05 07:43:37 morrison Exp $ (BRL)";
@


11.19
log
@merge of ansi-6-0-branch into HEAD
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d22 5
a26 1
#include "conf.h"
@


11.18
log
@update copyright to include span through 2003
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_spm.c,v 11.17 2002/08/20 17:07:52 jra Exp $ (BRL)";
d51 2
a52 2
HIDDEN int	spm_setup(), spm_render();
HIDDEN void	spm_print(), spm_mfree();
d69 1
a69 5
spm_render( ap, pp, swp, dp )
struct application *ap;
struct partition *pp;
struct shadework	*swp;
char	*dp;
d96 6
a101 6
spm_setup( rp, matparm, dpp, mfp, rtip )
register struct region *rp;
struct bu_vls	*matparm;
char	**dpp;
struct mfuncs           *mfp;
struct rt_i             *rtip;  /* New since 4.4 release */
d132 1
a132 3
spm_print( rp, dp )
register struct region *rp;
char	*dp;
d144 1
a144 2
spm_mfree( cp )
char *cp;
@


11.17
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d15 1
a15 1
 *	This software is Copyright (C) 1986 by the United States Army.
d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_spm.c,v 11.15 2000/08/20 01:27:48 butler Exp $ (BRL)";
@


11.17.4.1
log
@sync to HEAD...
@
text
@d15 1
a15 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/liboptical/sh_spm.c,v 11.18 2004/02/02 17:39:14 morrison Exp $ (BRL)";
@


11.17.10.1
log
@merge from HEAD
@
text
@d15 1
a15 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_spm.c,v 11.18 2004/02/02 17:39:14 morrison Exp $ (BRL)";
@


11.17.10.2
log
@merge from head
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_spm.c,v 11.17.10.1 2004/02/12 18:38:49 erikg Exp $ (BRL)";
@


11.17.2.1
log
@Initial ANSIfication
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_spm.c,v 11.17 2002/08/20 17:07:52 jra Exp $ (BRL)";
d51 2
a52 2
HIDDEN int	spm_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip), spm_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
HIDDEN void	spm_print(register struct region *rp, char *dp), spm_mfree(char *cp);
d69 5
a73 1
spm_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
d100 6
a105 6
spm_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip)
                           
             	         
    	      
                             
                                /* New since 4.4 release */
d136 3
a138 1
spm_print(register struct region *rp, char *dp)
d150 2
a151 1
spm_mfree(char *cp)
@


11.17.2.2
log
@sync branch with HEAD
@
text
@d15 1
a15 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d19 1
a19 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.16
log
@Converted from K&R to ANSI C - RFH
@
text
@d51 2
a52 2
HIDDEN int	spm_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip), spm_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
HIDDEN void	spm_print(register struct region *rp, char *dp), spm_mfree(char *cp);
d69 5
a73 1
spm_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
d100 6
a105 6
spm_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip)
                           
             	         
    	      
                             
                                /* New since 4.4 release */
d136 3
a138 1
spm_print(register struct region *rp, char *dp)
d150 2
a151 1
spm_mfree(char *cp)
@


11.15
log
@Eliminate compilation warnings, enhancements to sh_light.c
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_spm.c,v 11.14 2000/07/25 16:40:38 butler Exp $ (BRL)";
d51 2
a52 2
HIDDEN int	spm_setup(), spm_render();
HIDDEN void	spm_print(), spm_mfree();
d69 1
a69 5
spm_render( ap, pp, swp, dp )
struct application *ap;
struct partition *pp;
struct shadework	*swp;
char	*dp;
d96 6
a101 6
spm_setup( rp, matparm, dpp, mfp, rtip )
register struct region *rp;
struct bu_vls	*matparm;
char	**dpp;
struct mfuncs           *mfp;
struct rt_i             *rtip;  /* New since 4.4 release */
d132 1
a132 3
spm_print( rp, dp )
register struct region *rp;
char	*dp;
d144 1
a144 2
spm_mfree( cp )
char *cp;
@


11.14
log
@Changes to use rtprivate.h instead of ../rt/rdebug.h
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_spm.c,v 11.13 2000/02/19 21:05:02 butler Exp $ (BRL)";
@


11.13
log
@Changes to support movement of CLAMP() macro into vmath.h
Altered "if( " statements to "if (" for readability.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_spm.c,v 11.12 1999/10/30 03:06:25 butler Exp $ (BRL)";
d33 1
a33 1
#include "../rt/rdebug.h"
@


11.12
log
@Moved mathtab/rand_half from rt into libbn
Expanded structparse to include description and default
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_spm.c,v 11.11 1999/07/02 22:20:41 mike Exp $ (BRL)";
d115 1
a115 1
	if( bu_struct_parse( matparm, spm_parse, (char *)spp ) < 0 )  {
d119 2
a120 2
	if( spp->sp_w < 0 )  spp->sp_w = 512;
	if( spp->sp_file[0] == '\0' )
d122 1
a122 1
	if( (spp->sp_map = spm_init( spp->sp_w, sizeof(RGBpixel) )) == SPM_NULL )
d124 1
a124 1
	if( spm_load( spp->sp_map, spp->sp_file ) < 0 )
d146 1
a146 1
	if( spm->sp_map )  spm_dump( spm->sp_map, 0 );
d157 1
a157 1
	if( spm->sp_map )  spm_free( spm->sp_map );
@


11.11
log
@
Removed dependence on compat4.h
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_spm.c,v 11.10 1999/07/01 20:08:48 mike Exp $ (BRL)";
a32 1
#include "../rt/mathtab.h"
@


11.10
log
@
compat4
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_spm.c,v 11.9 1998/09/22 01:29:55 mike Exp $ (BRL)";
d46 4
a49 4
	{"%s",	SPM_NAME_LEN, "file",		bu_offsetofarray(struct spm_specific, sp_file),	FUNC_NULL },
	{"%d",	1, "w",		SP_O(sp_w),	FUNC_NULL },
	{"%d",	1, "n",		SP_O(sp_w),	FUNC_NULL },	/*compat*/
	{"",	0, (char *)0,	0,		FUNC_NULL }
@


11.9
log
@Moved optical shaders from rt/ to liboptical/
The only modifications involved moving and splitting
rt/material.h into h/shadefuncs.h and h/shadework.h,
and in changing the calling sequence to mlib_setup() in rt/material.c

Now the only shader function called directly by RT is
in liboptical/init.c: optical_shader_init().
It adds all the individual shaders to the "mfuncs" shader list.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rt/sh_spm.c,v 11.8 1998/06/30 22:54:19 mike Exp $ (BRL)";
d46 1
a46 1
	{"%s",	SPM_NAME_LEN, "file",		offsetofarray(struct spm_specific, sp_file),	FUNC_NULL },
d103 1
a103 1
struct rt_vls	*matparm;
d110 2
a111 2
	RT_VLS_CHECK( matparm );
	GETSTRUCT( spp, spm_specific );
d117 1
a117 1
		rt_free( (char *)spp, "spm_specific" );
d145 1
a145 1
	rt_log("spm_print(rp=x%x, dp=x%x)\n", rp, dp);
d160 1
a160 1
	rt_free( cp, "spm_specific" );
@


11.8
log
@Can't make "struct mfuncs" a CONST, because the forward link needs
to be filled in at runtime, and some compilers put CONST data into
read-only pages (like FreeBSD).
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rt/sh_spm.c,v 11.7 1997/12/31 09:01:40 mike Exp $ (BRL)";
d31 4
a34 2
#include "./material.h"
#include "./rdebug.h"
@


11.7
log
@Required magic number to be first in mfunc table,
consistent with all other BRL-CAD magic numbers.
Required magic number to be initialized at compile time.
Added code to check the magic numbers.
Made the xxx_mfunc arrays CONST, so they can't get trashed by
runtime runaway pointer problems.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_spm.c,v 11.6 1997/11/25 22:16:43 butler Exp mike $ (BRL)";
d53 1
a53 1
CONST struct mfuncs spm_mfuncs[] = {
@


11.6
log
@updated all shaders so that _setup had mfp and rtip parameters
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_spm.c,v 11.5 1996/08/31 08:46:01 butler Exp butler $ (BRL)";
d53 2
a54 2
struct mfuncs spm_mfuncs[] = {
	{"spm",		0,		0,		MFI_UV,		0,
d57 1
a57 1
	{(char *)0,	0,		0,		0,		0,
@


11.5
log
@bu_struct_print
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_spm.c,v 11.4 1996/08/31 08:29:28 butler Exp butler $ (BRL)";
d99 1
a99 1
spm_setup( rp, matparm, dpp )
d103 2
@


11.4
log
@bu_struct_parse
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_spm.c,v 11.3 1996/08/30 00:08:21 butler Exp butler $ (BRL)";
d142 1
a142 1
	(void)bu_structprint("spm_print", spm_parse, (char *)dp);
@


11.3
log
@structparse moved to libbu
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_spm.c,v 11.2 1995/10/20 04:43:53 butler Exp butler $ (BRL)";
d112 1
a112 1
	if( bu_structparse( matparm, spm_parse, (char *)spp ) < 0 )  {
@


11.2
log
@edited mfuncs table to account for new "mf_flags" element in struct mfuncs.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_spm.c,v 11.1 1995/01/04 10:01:10 mike Rel4_4 butler $ (BRL)";
d43 1
a43 1
struct structparse spm_parse[] = {
d112 1
a112 1
	if( rt_structparse( matparm, spm_parse, (char *)spp ) < 0 )  {
d142 1
a142 1
	rt_structprint("spm_print", spm_parse, (char *)dp);
@


11.1
log
@Release_4.4
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_spm.c,v 10.3 94/08/11 02:26:16 gdurf Exp $ (BRL)";
d54 1
a54 1
	{"spm",		0,		0,		MFI_UV,
d57 1
a57 1
	{(char *)0,	0,		0,
@


10.3
log
@Added include of conf.h
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_spm.c,v 10.2 1992/08/27 19:54:56 mike Exp gdurf $ (BRL)";
@


10.2
log
@Fixed bug in spm_free(), which was freeing the wrong pointer.
Expanded debugging.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_spm.c,v 10.2 92/08/27 19:53:57 mike Exp $ (BRL)";
d21 2
@


10.1
log
@Release_4.0
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_spm.c,v 9.7 91/08/29 22:39:26 mike Exp $ (BRL)";
d123 1
a123 1
	rt_free( (char *)spp, "spm_specific" );
d135 7
a141 2
	rt_structprint("spm_setup", spm_parse, (char *)dp);
	/* Should be more here */
d148 7
a154 1
	spm_free( (spm_map_t *)cp );
@


9.7
log
@ANSI lint
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_spm.c,v 9.6 91/07/06 00:35:22 mike Exp $ (BRL)";
@


9.6
log
@ANSI structure initialization
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_spm.c,v 9.5 91/02/17 20:15:54 mike Exp $ (BRL)";
d82 4
a85 1
	VSET( swp->sw_color, cp[RED]/256., cp[GRN]/256., cp[BLU]/256. );
@


9.5
log
@Check return code from rt_structparse()
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_spm.c,v 9.4 91/01/05 03:09:15 mike Exp $ (BRL)";
d42 4
a45 4
	"%s",	SPM_NAME_LEN, "file",		offsetofarray(struct spm_specific, sp_file),	FUNC_NULL,
	"%d",	1, "w",		SP_O(sp_w),	FUNC_NULL,
	"%d",	1, "n",		SP_O(sp_w),	FUNC_NULL,	/*compat*/
	"",	0, (char *)0,	0,		FUNC_NULL
d52 2
a53 2
	"spm",		0,		0,		MFI_UV,
	spm_setup,	spm_render,	spm_print,	spm_mfree,
d55 2
a56 2
	(char *)0,	0,		0,
	0,		0,		0,		0
@


9.4
log
@Converted to new format for fmt entry in structparse
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_spm.c,v 9.3 90/12/12 16:35:09 butler Exp $ (BRL)";
d107 4
a110 1
	rt_structparse( matparm, spm_parse, (char *)spp );
@


9.3
log
@modified to reflect changes in structparse format
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_spm.c,v 9.2 90/12/08 08:58:15 butler Exp $ (BRL)";
d45 1
a45 1
	(char *)0, 0,(char *)0,	0,		FUNC_NULL
@


9.2
log
@changed material property parameter to be struct rt_vls
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_spm.c,v 9.1 89/05/19 05:59:41 mike Rel3_5 $ (BRL)";
d32 1
d34 1
a34 1
	char	sp_file[128];	/* Filename */
d42 4
a45 4
	"%s",	"file",		offsetofarray(struct spm_specific, sp_file),	FUNC_NULL,
	"%d",	"w",		SP_O(sp_w),	FUNC_NULL,
	"%d",	"n",		SP_O(sp_w),	FUNC_NULL,	/*compat*/
	(char *)0,(char *)0,	0,		FUNC_NULL
@


9.1
log
@Release_3.5
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: sh_spm.c,v 8.4 89/04/30 20:46:21 mike Exp $ (BRL)";
d95 1
a95 1
char	*matparm;
d100 1
@


8.4
log
@No longer needs mathtab.h
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: sh_spm.c,v 8.3 89/04/04 05:02:06 mike Locked $ (BRL)";
@


8.3
log
@Converted to new way of representing structure offsets.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: spm.c,v 8.2 88/12/27 16:35:08 mike Locked $ (BRL)";
a29 1
#include "./mathtab.h"
@


8.2
log
@Converted matparse --> structparse
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: spm.c,v 8.1 88/10/05 00:33:26 mike Locked $ (BRL)";
d39 1
d42 4
a45 4
	"%s",	"file",		(stroff_t)(SP_NULL->sp_file),	FUNC_NULL,
	"%d",	"w",		(stroff_t)&(SP_NULL->sp_w),	FUNC_NULL,
	"%d",	"n",		(stroff_t)&(SP_NULL->sp_w),	FUNC_NULL,	/*compat*/
	(char *)0,(char *)0,	(stroff_t)0,				FUNC_NULL
d106 1
a106 1
	rt_structparse( matparm, spm_parse, (stroff_t)spp );
d128 1
a128 1
	rt_structprint("spm_setup", spm_parse, (stroff_t)dp);
@


8.1
log
@Release_3.0
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: spm.c,v 7.5 88/09/17 07:20:30 mike Exp $ (BRL)";
d40 5
a44 5
struct matparse spm_parse[] = {
	"file",		(mp_off_ty)(SP_NULL->sp_file),	"%s",
	"w",		(mp_off_ty)&(SP_NULL->sp_w),	"%d",
	"n",		(mp_off_ty)&(SP_NULL->sp_w),	"%d",	/*compat*/
	(char *)0,	(mp_off_ty)0,			(char *)0
d105 1
a105 1
	mlib_parse( matparm, spm_parse, (mp_off_ty)spp );
d127 1
a127 1
	mlib_print("spm_setup", spm_parse, (mp_off_ty)dp);
@


7.5
log
@The Cray C compilers are now better, so the #ifdef cray code
has been removed.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: spm.c,v 7.4 88/06/21 02:48:39 mike Locked $ (BRL)";
@


7.4
log
@Made number of scanlines (height) parameter be "n",
and width be "w", to be consistent with the BRLCAD convention,
as exhibited by pix-fb and many others.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: spm.c,v 7.3 88/05/14 02:28:24 mike Locked $ (BRL)";
a40 1
#ifndef cray
a41 3
#else
	"file",		(mp_off_ty)0,			"%s",
#endif
@


7.3
log
@lint fixes
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: spm.c,v 7.2 88/01/29 22:43:48 mike Locked $ (BRL)";
d35 1
a35 1
	int	sp_n;		/* number of pixels around equator */
d46 2
a47 1
	"n",		(mp_off_ty)&(SP_NULL->sp_n),	"%d",
d108 1
a108 1
	spp->sp_n = -1;
d110 1
a110 1
	if( spp->sp_n < 0 )  spp->sp_n = 512;
d113 1
a113 1
	if( (spp->sp_map = spm_init( spp->sp_n, sizeof(RGBpixel) )) == SPM_NULL )
@


7.2
log
@moved generic sphere map routines to librt
finished name change sph to spm
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: sph.c,v 7.1 87/11/02 23:56:31 mike Rel $ (BRL)";
d50 2
a51 1
HIDDEN int spm_setup(), spm_render(), spm_print(), spm_mfree();
d85 1
d125 1
a125 1
HIDDEN int
d134 1
a134 1
HIDDEN int
@


7.1
log
@Release 2.3
@
text
@d2 1
a2 1
 *			S P H . C
d19 1
a19 1
static char RCSid[] = "@@(#)$Header: sph.c,v 6.1 87/07/11 07:59:18 mike Rel $ (BRL)";
d28 1
a28 1
#include "./sph.h"
a32 323
char	*malloc();
char	*calloc();

/*
 *		S P H _ I N I T
 *
 *  Return a sphere map structure initialized for N points around
 *  the equator.  Malloc the storage and fill in the pointers.
 *  This code leaves a ring of "triangular" pixels at the poles.
 *  An alternative would be to have the pole region map to a
 *  single pixel.
 *  Returns SPH_NULL on error.
 */
spm_map_t *
spm_init( N )
int	N;
{
	int	i, nx, total, index;
	register spm_map_t *mapp;

	mapp = (spm_map_t *)rt_malloc( sizeof(spm_map_t), "spm_map_t");
	if( mapp == SPH_NULL )
		return( SPH_NULL );
	bzero( (char *)mapp, sizeof(spm_map_t) );

	mapp->ny = N/2;
	mapp->nx = (int *) rt_malloc( (unsigned)(N/2 * sizeof(*(mapp->nx))), "sph nx" );
	if( mapp->nx == NULL ) {
		spm_free( mapp );
		return( SPH_NULL );
	}
	mapp->xbin = (unsigned char **) rt_malloc( (unsigned)(N/2 * sizeof(char *)), "sph xbin" );
	if( mapp->xbin == NULL ) {
		spm_free( mapp );
		return( SPH_NULL );
	}

	total = 0;
	for( i = 0; i < N/4; i++ ) {
		nx = ceil( N*cos( i*twopi/N ) );
		if( nx > N ) nx = N;
		mapp->nx[ N/4 + i ] = nx;
		mapp->nx[ N/4 - i -1 ] = nx;

		total += 2*nx;
	}

	mapp->_data = (unsigned char *) calloc( (unsigned)total, sizeof(RGBpixel) );
	if( mapp->_data == NULL ) {
		spm_free( mapp );
		return( SPH_NULL );
	}

	index = 0;
	for( i = 0; i < N/2; i++ ) {
		mapp->xbin[i] = &((mapp->_data)[index]);
		index += 3 * mapp->nx[i];
	}

	return( mapp );
}

/*
 *		S P H _ F R E E
 *
 *  Free the storage associated with a sphere structure.
 */
void
spm_free( mp )
spm_map_t *mp;
{
	if( mp == SPH_NULL )
		return;

	if( mp->_data != NULL )
		(void) rt_free( (char *)mp->_data, "sph _data" );

	if( mp->nx != NULL )
		(void) rt_free( (char *)mp->nx, "sph nx" );

	if( mp->xbin != NULL )
		(void) rt_free( (char *)mp->xbin, "sph xbin" );

	(void) rt_free( (char *)mp, "spm_map_t" );
}

/*
 *		S P H _ R E A D
 *
 *  Read the value of the pixel at the given normalized (u,v)
 *  coordinates.  It does NOT check the sanity of the coords.
 *
 *  0.0 <= u < 1.0	Left to Right
 *  0.0 <= v < 1.0	Bottom to Top
 */
void
spm_read( mapp, valp, u, v )
register spm_map_t	*mapp;
register unsigned char	*valp;
double	u, v;
{
	int	x, y;
	register unsigned char *cp;

	y = v * mapp->ny;
	x = u * mapp->nx[y];
	cp = &(mapp->xbin[y][x*3]);

	*valp++ = *cp++;
	*valp++ = *cp++;
	*valp++ = *cp++;
}

/*
 *		S P H _ W R I T E
 *
 *  Write the value of the pixel at the given normalized (u,v)
 *  coordinates.  It does NOT check the sanity of the coords.
 *
 *  0.0 <= u < 1.0	Left to Right
 *  0.0 <= v < 1.0	Bottom to Top
 */
void
spm_write( mapp, valp, u, v )
register spm_map_t	*mapp;
register unsigned char	*valp;
double	u, v;
{
	int	x, y;
	register unsigned char *cp;

	y = v * mapp->ny;
	x = u * mapp->nx[y];
	cp = &(mapp->xbin[y][x*3]);

	*cp++ = *valp++;
	*cp++ = *valp++;
	*cp++ = *valp++;
}

/*
 *		S P H _ L O A D
 *
 *  Read a saved sphere map from a file ("-" for stdin) into
 *  the given map structure.
 *  This does not check for conformity of size, etc.
 *  Returns -1 on error, else 0.
 */
int
spm_load( mapp, filename )
spm_map_t *mapp;
char	*filename;
{
	int	y, total;
	FILE	*fp;

	if( strcmp( filename, "-" ) == 0 )
		fp = stdin;
	else if( (fp = fopen( filename, "r" )) == NULL )
		return( -1 );

	total = 0;
	for( y = 0; y < mapp->ny; y++ )
		total += mapp->nx[y];

	y = fread( (char *)mapp->_data, sizeof(RGBpixel), total, fp );
	(void) fclose( fp );

	if( y != total )
		return( -1 );

	return( 0 );
}

/*
 *		S P H _ S A V E
 *
 *  Write a loaded sphere map to the given file ("-" for stdout).
 *  Returns -1 on error, else 0.
 */
int
spm_save( mapp, filename )
spm_map_t *mapp;
char	*filename;
{
	int	i;
	FILE	*fp;

	if( strcmp( filename, "-" ) == 0 )
		fp = stdout;
	else if( (fp = fopen( filename, "w" )) == NULL )
		return( -1 );

	for( i = 0; i < mapp->ny; i++ ) {
		if( fwrite( (char *)mapp->xbin[i], sizeof(RGBpixel),
		    mapp->nx[i], fp ) != mapp->nx[i] ) {
		    	(void) fclose( fp );
		    	return( -1 );
		}
	}

	(void) fclose( fp );

	return( 0 );
}

/*
 *		S P H _ P I X _ L O A D
 *
 *  Load an 'nx' by 'ny' pix file and filter it into the
 *  given sphere structure.
 *  Returns -1 on error, else 0.
 */
int
spm_px_load( mapp, filename, nx, ny )
spm_map_t *mapp;
char	*filename;
int	nx, ny;
{
	int	i, j;			/* index input file */
	int	x, y;			/* index texture map */
	double	j_per_y, i_per_x;	/* ratios */
	int	nj, ni;			/* ints of ratios */
	unsigned char *cp;
	unsigned char *buffer;
	unsigned long	red, green, blue;
	long	count;
	FILE	*fp;

	if( strcmp( filename, "-" ) == 0 )
		fp = stdin;
	else if( (fp = fopen( filename, "r" )) == NULL )
		return( -1 );

	/* Shamelessly suck it all in */
	buffer = (unsigned char *)malloc( (unsigned)(nx*nx*sizeof(RGBpixel)) );
	/* XXX */
	(void) fread( (char *)buffer, sizeof(RGBpixel), nx*ny, fp );
	(void) fclose( fp );

	j_per_y = (double)ny / (double)mapp->ny;
	nj = (int)j_per_y;
	/* for each bin */
	for( y = 0; y < mapp->ny; y++ ) {
		i_per_x = (double)nx / (double)mapp->nx[y];
		ni = (int)i_per_x;
		/* for each cell in bin */
		for( x = 0; x < mapp->nx[y]; x++ ) {
			/* Average pixels from the input file */
			red = green = blue = 0;
			count = 0;
			for( j = y*j_per_y; j < y*j_per_y+nj; j++ ) {
				for( i = x*i_per_x; i < x*i_per_x+ni; i++ ) {
					red = red + (unsigned long)buffer[ 3*(j*nx+i) ];
					green = green + (unsigned long)buffer[ 3*(j*nx+i)+1 ];
					blue = blue + (unsigned long)buffer[ 3*(j*nx+i)+2 ];
					count++;
				}
			}
			/* Save the color */
			cp = &(mapp->xbin[y][x*3]);
			*cp++ = (unsigned char)(red/count);
			*cp++ = (unsigned char)(green/count);
			*cp++ = (unsigned char)(blue/count);
		}
	}
	(void) free( (char *)buffer );

	return( 0 );
}

/*
 *		S P H _ P I X _ S A V E
 *
 *  Save a sphere structure as an 'nx' by 'ny' pix file.
 *  Returns -1 on error, else 0.
 */
int
spm_px_save( mapp, filename, nx, ny )
spm_map_t *mapp;
char	*filename;
int	nx, ny;
{
	int	x, y;
	FILE	*fp;
	unsigned char pixel[3];

	if( strcmp( filename, "-" ) == 0 )
		fp = stdout;
	else if( (fp = fopen( filename, "w" )) == NULL )
		return( -1 );

	for( y = 0; y < ny; y++ ) {
		for( x = 0; x < nx; x++ ) {
			spm_read( mapp, pixel, (double)x/(double)nx, (double)y/(double)ny );
			(void) fwrite( (char *)pixel, sizeof(pixel), 1, fp );
		}
	}

	return( 0 );
}

/*
 * 		S P H _ D U M P
 *
 *  Display a sphere structure on stderr.
 *  Used for debugging.
 */
void
spm_dump( mp )
spm_map_t *mp;
{
	int	i;

	fprintf( stderr, "ny = %d\n", mp->ny );
	fprintf( stderr, "_data = 0x%x\n", mp->_data );
	for( i = 0; i < mp->ny; i++ ) {
		fprintf( stderr, "  nx[%d] = %3d, xbin[%d] = 0x%x\n",
			i, mp->nx[i], i, mp->xbin[i] );
	}
}

/*****/
d53 1
a53 1
	"sph",		0,		0,		MFI_UV,
d61 1
a61 1
 *  			S P H _ R E N D E R
d87 1
a87 1
 *			S P H _ S E T U P
d110 1
a110 1
	if( (spp->sp_map = spm_init( spp->sp_n )) == SPH_NULL )
d121 1
a121 1
 *			S P H _ P R I N T
@


6.1
log
@Release 2.0
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: sph.c,v 5.3 87/06/27 06:46:18 phil Exp $ (BRL)";
@


5.3
log
@rendering parameter changes
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: sph.c,v 5.2 87/06/26 05:57:38 phil Locked $ (BRL)";
@


5.2
log
@Added struct shadework support, separated shaders from
reflect/refract code, allowed stacking of shaders.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: sph.c,v 5.1 87/06/24 22:15:23 mike Locked $ (BRL)";
d390 1
a390 1
spm_render( ap, pp, swp )
d394 1
d397 1
a397 1
		(struct spm_specific *)pp->pt_regionp->reg_udata;
d417 1
a417 1
spm_setup( rp )
d419 2
d425 1
a425 1
	rp->reg_udata = (char *)spp;
d429 1
a429 1
	mlib_parse( rp->reg_mater.ma_matparm, spm_parse, (mp_off_ty)spp );
d447 1
a447 1
spm_print( rp )
d449 1
d451 1
a451 1
	mlib_print("spm_setup", spm_parse, (mp_off_ty)rp->reg_udata);
@


5.1
log
@Release 1.24
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: sph.c,v 4.4 87/03/24 00:50:45 phil Exp $ (BRL)";
d376 1
a376 1
	"sph",		0,		0,
d390 1
a390 1
spm_render( ap, pp )
d393 1
a396 1
	auto struct uvcoord uv;
a399 5
	VJOIN1( pp->pt_inhit->hit_point, ap->a_ray.r_pt,
		pp->pt_inhit->hit_dist, ap->a_ray.r_dir );
	rt_functab[pp->pt_inseg->seg_stp->st_id].ft_uv(
		ap, pp->pt_inseg->seg_stp, pp->pt_inhit, &uv );

d402 2
a403 2
	y = uv.uv_v * spp->sp_map->ny;
	x = uv.uv_u * spp->sp_map->nx[y];
d405 1
a405 1
	VSET( ap->a_color, cp[RED]/256., cp[GRN]/256., cp[BLU]/256. );
@


4.4
log
@changed sph_ to spm_ due to librt/sph.c
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: sph.c,v 4.3 87/03/23 23:48:11 phil Locked $ (BRL)";
@


4.3
log
@Revised for new material property interface.
@
text
@d7 1
a7 1
 *	Phil Dykstra
d19 1
a19 1
static char RCSid[] = "@@(#)$Header: sph.c,v 4.2 87/02/13 00:02:49 mike Exp $ (BRL)";
d46 2
a47 2
sph_map_t *
sph_init( N )
d51 1
a51 1
	register sph_map_t *mapp;
d53 1
a53 1
	mapp = (sph_map_t *)rt_malloc( sizeof(sph_map_t), "sph_map_t");
d56 1
a56 1
	bzero( (char *)mapp, sizeof(sph_map_t) );
d61 1
a61 1
		sph_free( mapp );
d66 1
a66 1
		sph_free( mapp );
d82 1
a82 1
		sph_free( mapp );
d101 2
a102 2
sph_free( mp )
sph_map_t *mp;
d116 1
a116 1
	(void) rt_free( (char *)mp, "sph_map_t" );
d129 2
a130 2
sph_read( mapp, valp, u, v )
register sph_map_t	*mapp;
d156 2
a157 2
sph_write( mapp, valp, u, v )
register sph_map_t	*mapp;
d182 2
a183 2
sph_load( mapp, filename )
sph_map_t *mapp;
d214 2
a215 2
sph_save( mapp, filename )
sph_map_t *mapp;
d247 2
a248 2
sph_px_load( mapp, filename, nx, ny )
sph_map_t *mapp;
d311 2
a312 2
sph_px_save( mapp, filename, nx, ny )
sph_map_t *mapp;
d327 1
a327 1
			sph_read( mapp, pixel, (double)x/(double)nx, (double)y/(double)ny );
d342 2
a343 2
sph_dump( mp )
sph_map_t *mp;
d356 1
a356 1
struct sph_specific {
d359 1
a359 1
	sph_map_t *sp_map;	/* stuff */
d361 1
a361 1
#define SP_NULL	((struct sph_specific *)0)
d363 1
a363 1
struct matparse sph_parse[] = {
d373 1
a373 1
HIDDEN int sph_setup(), sph_render(), sph_print(), sph_mfree();
d375 1
a375 1
struct mfuncs sph_mfuncs[] = {
d377 1
a377 1
	sph_setup,	sph_render,	sph_print,	sph_mfree,
d390 1
a390 1
sph_render( ap, pp )
d394 2
a395 2
	register struct sph_specific *spp =
		(struct sph_specific *)pp->pt_regionp->reg_udata;
d405 1
a405 1
	/** sph_read( spp->sp_map, xxx ); **/
d421 1
a421 1
sph_setup( rp )
d424 1
a424 1
	register struct sph_specific *spp;
d426 1
a426 1
	GETSTRUCT( spp, sph_specific );
d431 1
a431 1
	mlib_parse( rp->reg_mater.ma_matparm, sph_parse, (mp_off_ty)spp );
d435 1
a435 1
	if( (spp->sp_map = sph_init( spp->sp_n )) == SPH_NULL )
d437 1
a437 1
	if( sph_load( spp->sp_map, spp->sp_file ) < 0 )
d441 1
a441 1
	rt_free( (char *)spp, "sph_specific" );
d449 1
a449 1
sph_print( rp )
d452 1
a452 1
	mlib_print("sph_setup", sph_parse, (mp_off_ty)rp->reg_udata);
d457 1
a457 1
sph_mfree( cp )
d460 1
a460 1
	sph_free( (sph_map_t *)cp );
@


4.2
log
@Release 1.20 -- First Formal Release
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: sph.c,v 4.1 86/12/29 03:48:44 mike Rel1 $ (BRL)";
d53 2
a54 2
	mapp = (sph_map_t *) calloc( 1, (unsigned)sizeof(sph_map_t) );
	if( mapp == NULL )
d56 1
d59 1
a59 1
	mapp->nx = (int *) malloc( (unsigned)(N/2 * sizeof(*(mapp->nx))) );
d64 1
a64 1
	mapp->xbin = (unsigned char **) malloc( (unsigned)(N/2 * sizeof(char *)) );
d108 1
a108 1
		(void) free( (char *)mp->_data );
d111 1
a111 1
		(void) free( (char *)mp->nx );
d114 1
a114 1
		(void) free( (char *)mp->xbin );
d116 1
a116 1
	(void) free( (char *)mp );
d373 1
d375 8
d389 1
a389 1
HIDDEN
d417 2
a418 2
 *	0	failed
 *	!0	success
d420 1
a420 1
int
a426 1
	rp->reg_ufunc = sph_render;
a434 2
	if(rdebug&RDEBUG_MATERIAL)
		mlib_print("sph_setup", sph_parse, (mp_off_ty)spp);
d442 19
a460 1
	return(0);
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: sph.c,v 1.4 86/12/18 16:02:04 mike Locked $ (BRL)";
@


1.4
log
@rdebug.h separated from librt/debug.h
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: sph.c,v 1.3 86/11/25 03:35:18 mike Locked $ (BRL)";
@


1.3
log
@Changed to use twopi, shortened sph_px_load and sph_px_save for Cray.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: sph.c,v 1.2 86/11/07 02:46:20 mike Locked $ (BRL)";
d31 1
d33 2
a34 2
char *malloc();
char *calloc();
d364 3
a366 1
	"file",		(int)(SP_NULL->sp_file),	"%s",
d368 2
a369 2
	"n",		(int)&(SP_NULL->sp_n),		"%d",
	(char *)0,	0,				(char *)0
d422 1
a422 1
	mlib_parse( rp->reg_mater.ma_matparm, sph_parse, (char *)spp );
d426 2
a427 1
mlib_print("sph_setup", sph_parse, (char *)spp);
@


1.2
log
@Changed so that computation of hit_point and hit_norm is done
in the individual material routines, and only as much as needed.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: sph.c,v 1.1 89/10/31 08:15:12 mike Locked $ (BRL)";
a31 3
#define PI	3.1415926535
#define	TWOPI	(2.0*PI)

d70 1
a70 1
		nx = ceil( N*cos( i*TWOPI/N ) );
d245 1
a245 1
sph_pix_load( mapp, filename, nx, ny )
d309 1
a309 1
sph_pix_save( mapp, filename, nx, ny )
@


1.1
log
@Initial revision
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d390 2
@
