head	11.87;
access;
symbols
	ansi-20040405-merged:11.74.2.2
	postmerge-20040405-ansi:11.85
	premerge-20040404-ansi:11.84
	postmerge-autoconf:11.84
	autoconf-freeze:11.81.2.4
	premerge-autoconf:11.84
	ansi-20040316-freeze:11.74.2.1
	postmerge-20040315-windows:11.84
	premerge-20040315-windows:11.83
	windows-20040315-freeze:11.74.4.2
	autoconf-20031203:11.81
	autoconf-20031202:11.81
	autoconf-branch:11.81.0.2
	phong-branch:11.80.0.2
	photonmap-branch:11.77.0.2
	rel-6-1-DP:11.74
	windows-branch:11.74.0.4
	rel-6-0-2:11.72
	ansi-branch:11.74.0.2
	rel-6-0-1-branch:11.72.0.2
	hartley-6-0-post:11.73
	hartley-6-0-pre:11.72
	rel-6-0-1:11.72
	rel-6-0:11.69
	rel-5-4:11.49.2.2
	offsite-5-3-pre:11.66
	rel-5-3:11.49.2.2
	rel-5-2:11.49
	rel-5-1-branch:11.49.0.2
	rel-5-1:11.49
	rel-5-0:11.31
	rel-5-0-beta:11.27
	rel-4-5:11.19
	ctj-4-5-post:11.14
	ctj-4-5-pre:11.14
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1;
locks; strict;
comment	@ * @;


11.87
date	2004.05.21.18.07.27;	author morrison;	state dead;
branches;
next	11.86;

11.86
date	2004.05.10.15.30.45;	author erikg;	state Exp;
branches;
next	11.85;

11.85
date	2004.04.05.07.43.37;	author morrison;	state Exp;
branches;
next	11.84;

11.84
date	2004.03.16.20.01.23;	author morrison;	state Exp;
branches;
next	11.83;

11.83
date	2004.03.03.21.33.53;	author morrison;	state Exp;
branches;
next	11.82;

11.82
date	2004.02.02.17.39.14;	author morrison;	state Exp;
branches;
next	11.81;

11.81
date	2003.09.27.01.05.10;	author morrison;	state Exp;
branches
	11.81.2.1;
next	11.80;

11.80
date	2003.08.27.19.29.40;	author justin;	state Exp;
branches
	11.80.2.1;
next	11.79;

11.79
date	2003.08.27.19.17.51;	author justin;	state Exp;
branches;
next	11.78;

11.78
date	2003.07.18.00.34.01;	author butler;	state Exp;
branches;
next	11.77;

11.77
date	2003.04.16.13.35.17;	author jra;	state Exp;
branches
	11.77.2.1;
next	11.76;

11.76
date	2003.04.07.17.54.08;	author jra;	state Exp;
branches;
next	11.75;

11.75
date	2003.01.31.21.45.37;	author jra;	state Exp;
branches;
next	11.74;

11.74
date	2002.08.20.17.07.51;	author jra;	state Exp;
branches
	11.74.2.1
	11.74.4.1;
next	11.73;

11.73
date	2002.08.15.20.55.04;	author hartley;	state Exp;
branches;
next	11.72;

11.72
date	2002.07.16.19.38.38;	author morrison;	state Exp;
branches;
next	11.71;

11.71
date	2002.07.02.18.46.35;	author jra;	state Exp;
branches;
next	11.70;

11.70
date	2002.06.11.19.48.14;	author butler;	state Exp;
branches;
next	11.69;

11.69
date	2001.05.16.21.37.56;	author morrison;	state Exp;
branches;
next	11.68;

11.68
date	2001.04.20.22.29.32;	author morrison;	state Exp;
branches;
next	11.67;

11.67
date	2001.03.19.22.19.52;	author butler;	state Exp;
branches;
next	11.66;

11.66
date	2000.10.24.00.03.44;	author butler;	state Exp;
branches;
next	11.65;

11.65
date	2000.10.20.18.51.58;	author mike;	state Exp;
branches;
next	11.64;

11.64
date	2000.10.19.19.19.45;	author butler;	state Exp;
branches;
next	11.63;

11.63
date	2000.10.19.03.04.11;	author cjohnson;	state Exp;
branches;
next	11.62;

11.62
date	2000.10.17.23.46.10;	author butler;	state Exp;
branches;
next	11.61;

11.61
date	2000.08.31.01.03.43;	author mike;	state Exp;
branches;
next	11.60;

11.60
date	2000.08.29.00.20.40;	author butler;	state Exp;
branches;
next	11.59;

11.59
date	2000.08.23.05.09.07;	author butler;	state Exp;
branches;
next	11.58;

11.58
date	2000.08.20.01.33.44;	author butler;	state Exp;
branches;
next	11.57;

11.57
date	2000.08.20.01.27.48;	author butler;	state Exp;
branches;
next	11.56;

11.56
date	2000.08.20.00.44.47;	author butler;	state Exp;
branches;
next	11.55;

11.55
date	2000.08.16.01.26.54;	author mike;	state Exp;
branches;
next	11.54;

11.54
date	2000.08.16.01.06.30;	author mike;	state Exp;
branches;
next	11.53;

11.53
date	2000.08.16.00.55.37;	author mike;	state Exp;
branches;
next	11.52;

11.52
date	2000.08.15.02.06.38;	author mike;	state Exp;
branches;
next	11.51;

11.51
date	2000.07.31.02.02.42;	author butler;	state Exp;
branches;
next	11.50;

11.50
date	2000.07.25.16.40.38;	author butler;	state Exp;
branches;
next	11.49;

11.49
date	2000.04.13.13.34.38;	author mike;	state Exp;
branches
	11.49.2.1;
next	11.48;

11.48
date	2000.04.12.18.08.10;	author mike;	state Exp;
branches;
next	11.47;

11.47
date	2000.03.16.04.51.53;	author mike;	state Exp;
branches;
next	11.46;

11.46
date	2000.03.03.03.27.07;	author mike;	state Exp;
branches;
next	11.45;

11.45
date	2000.03.03.03.04.01;	author mike;	state Exp;
branches;
next	11.44;

11.44
date	2000.02.23.03.34.47;	author butler;	state Exp;
branches;
next	11.43;

11.43
date	2000.02.19.21.05.02;	author butler;	state Exp;
branches;
next	11.42;

11.42
date	2000.02.18.04.39.05;	author butler;	state Exp;
branches;
next	11.41;

11.41
date	2000.02.17.21.03.44;	author butler;	state Exp;
branches;
next	11.40;

11.40
date	2000.02.09.22.36.30;	author butler;	state Exp;
branches;
next	11.39;

11.39
date	2000.02.07.18.04.17;	author butler;	state Exp;
branches;
next	11.38;

11.38
date	2000.02.03.06.34.45;	author butler;	state Exp;
branches;
next	11.37;

11.37
date	2000.01.22.01.39.56;	author mike;	state Exp;
branches;
next	11.36;

11.36
date	2000.01.20.22.51.53;	author butler;	state Exp;
branches;
next	11.35;

11.35
date	99.12.30.05.49.27;	author butler;	state Exp;
branches;
next	11.34;

11.34
date	99.12.04.01.22.39;	author mike;	state Exp;
branches;
next	11.33;

11.33
date	99.11.24.22.18.52;	author mike;	state Exp;
branches;
next	11.32;

11.32
date	99.10.30.03.06.24;	author butler;	state Exp;
branches;
next	11.31;

11.31
date	99.07.22.21.27.36;	author butler;	state Exp;
branches;
next	11.30;

11.30
date	99.07.07.00.41.37;	author mike;	state Exp;
branches;
next	11.29;

11.29
date	99.07.02.22.20.41;	author mike;	state Exp;
branches;
next	11.28;

11.28
date	99.07.01.20.08.46;	author mike;	state Exp;
branches;
next	11.27;

11.27
date	99.05.10.21.40.12;	author mike;	state Exp;
branches;
next	11.26;

11.26
date	98.12.16.03.51.03;	author mike;	state Exp;
branches;
next	11.25;

11.25
date	98.12.12.07.23.05;	author mike;	state Exp;
branches;
next	11.24;

11.24
date	98.12.10.08.27.29;	author mike;	state Exp;
branches;
next	11.23;

11.23
date	98.12.10.08.23.21;	author mike;	state Exp;
branches;
next	11.22;

11.22
date	98.09.22.01.29.54;	author mike;	state Exp;
branches;
next	11.21;

11.21
date	98.06.30.22.54.18;	author mike;	state Exp;
branches;
next	11.20;

11.20
date	98.03.26.08.06.43;	author mike;	state Exp;
branches;
next	11.19;

11.19
date	98.01.13.11.45.36;	author mike;	state Exp;
branches;
next	11.18;

11.18
date	98.01.13.10.42.10;	author mike;	state Exp;
branches;
next	11.17;

11.17
date	97.12.31.09.01.40;	author mike;	state Exp;
branches;
next	11.16;

11.16
date	97.12.09.04.46.58;	author butler;	state Exp;
branches;
next	11.15;

11.15
date	97.11.25.22.16.43;	author butler;	state Exp;
branches;
next	11.14;

11.14
date	97.03.04.05.46.36;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	97.02.27.04.38.09;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	97.02.14.09.22.36;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	97.02.14.09.07.06;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	96.08.31.08.46.01;	author butler;	state Exp;
branches;
next	11.9;

11.9
date	96.08.31.08.29.28;	author butler;	state Exp;
branches;
next	11.8;

11.8
date	96.08.30.00.08.21;	author butler;	state Exp;
branches;
next	11.7;

11.7
date	96.08.14.03.45.51;	author butler;	state Exp;
branches;
next	11.6;

11.6
date	96.07.24.17.07.38;	author jra;	state Exp;
branches;
next	11.5;

11.5
date	96.07.22.20.34.18;	author jra;	state Exp;
branches;
next	11.4;

11.4
date	96.05.09.03.24.58;	author butler;	state Exp;
branches;
next	11.3;

11.3
date	95.10.20.04.43.53;	author butler;	state Exp;
branches;
next	11.2;

11.2
date	95.08.19.05.07.15;	author butler;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.01.06;	author mike;	state Rel4_4;
branches;
next	10.8;

10.8
date	94.11.05.02.51.28;	author mike;	state Exp;
branches;
next	10.7;

10.7
date	94.10.31.23.15.16;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	94.10.31.23.11.26;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	94.08.11.02.22.48;	author gdurf;	state Exp;
branches;
next	10.4;

10.4
date	94.05.06.03.27.40;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	94.05.06.01.17.38;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	94.05.05.23.00.41;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.42.08;	author mike;	state Rel4_0;
branches;
next	9.21;

9.21
date	91.09.18.14.01.22;	author butler;	state Exp;
branches;
next	9.20;

9.20
date	91.08.30.03.49.53;	author mike;	state Exp;
branches;
next	9.19;

9.19
date	91.08.16.16.23.15;	author mike;	state Exp;
branches;
next	9.18;

9.18
date	91.08.16.15.15.48;	author mike;	state Exp;
branches;
next	9.17;

9.17
date	91.08.16.14.18.56;	author mike;	state Exp;
branches;
next	9.16;

9.16
date	91.07.16.00.05.10;	author mike;	state Exp;
branches;
next	9.15;

9.15
date	91.07.06.00.35.19;	author mike;	state Exp;
branches;
next	9.14;

9.14
date	91.06.30.03.02.49;	author mike;	state Exp;
branches;
next	9.13;

9.13
date	91.06.14.08.25.32;	author mike;	state Exp;
branches;
next	9.12;

9.12
date	91.02.17.20.15.52;	author mike;	state Exp;
branches;
next	9.11;

9.11
date	91.01.05.03.09.11;	author mike;	state Exp;
branches;
next	9.10;

9.10
date	90.12.12.16.35.05;	author butler;	state Exp;
branches;
next	9.9;

9.9
date	90.12.08.08.58.08;	author butler;	state Exp;
branches;
next	9.8;

9.8
date	90.12.05.06.13.56;	author mike;	state Exp;
branches;
next	9.7;

9.7
date	90.11.14.14.46.06;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	90.11.11.04.52.54;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	90.11.10.19.36.29;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	90.11.02.03.16.40;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	90.07.31.00.50.23;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	90.04.27.02.19.10;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.59.33;	author mike;	state Rel3_5;
branches;
next	8.5;

8.5
date	89.04.30.20.38.37;	author mike;	state Exp;
branches;
next	8.4;

8.4
date	89.04.04.05.01.58;	author mike;	state Exp;
branches;
next	8.3;

8.3
date	88.12.27.16.34.11;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	88.10.06.03.19.08;	author mike;	state Rel3_0;
branches;
next	8.1;

8.1
date	88.10.05.00.32.44;	author mike;	state Rel3_0;
branches;
next	7.6;

7.6
date	88.08.19.04.02.07;	author phil;	state Exp;
branches;
next	7.5;

7.5
date	88.06.21.00.56.01;	author mike;	state Exp;
branches;
next	7.4;

7.4
date	88.05.14.02.28.11;	author mike;	state Exp;
branches;
next	7.3;

7.3
date	88.02.27.02.31.28;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	88.01.26.05.39.53;	author phil;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.53.53;	author mike;	state Rel;
branches;
next	6.8;

6.8
date	87.10.22.18.37.05;	author mike;	state Exp;
branches;
next	6.7;

6.7
date	87.10.16.00.48.40;	author mike;	state Exp;
branches;
next	6.6;

6.6
date	87.09.21.21.24.44;	author mike;	state Exp;
branches;
next	6.5;

6.5
date	87.09.16.04.27.59;	author mike;	state Exp;
branches;
next	6.4;

6.4
date	87.09.11.02.52.20;	author mike;	state Exp;
branches;
next	6.3;

6.3
date	87.09.11.02.05.31;	author mike;	state Exp;
branches;
next	6.2;

6.2
date	87.09.10.07.14.32;	author mike;	state Exp;
branches;
next	6.1;

6.1
date	87.07.11.07.58.23;	author mike;	state Rel;
branches;
next	5.4;

5.4
date	87.06.27.06.46.04;	author phil;	state Exp;
branches;
next	5.3;

5.3
date	87.06.27.03.52.39;	author mike;	state Exp;
branches;
next	5.2;

5.2
date	87.06.26.05.57.45;	author mike;	state Exp;
branches;
next	5.1;

5.1
date	87.06.24.22.14.22;	author mike;	state Rel;
branches;
next	1.4;

1.4
date	87.05.31.04.35.16;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	87.05.30.04.20.27;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	87.03.23.23.48.33;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	87.03.17.20.21.12;	author mike;	state Exp;
branches;
next	;

11.49.2.1
date	2000.10.17.16.56.40;	author jra;	state Exp;
branches;
next	11.49.2.2;

11.49.2.2
date	2000.11.30.02.58.15;	author jra;	state Exp;
branches;
next	;

11.74.2.1
date	2002.09.19.18.01.25;	author morrison;	state Exp;
branches;
next	11.74.2.2;

11.74.2.2
date	2004.03.17.21.18.32;	author morrison;	state Exp;
branches;
next	;

11.74.4.1
date	2002.09.26.23.03.59;	author morrison;	state Exp;
branches;
next	11.74.4.2;

11.74.4.2
date	2004.03.11.23.43.02;	author morrison;	state Exp;
branches;
next	;

11.77.2.1
date	2003.08.12.22.53.40;	author justin;	state Exp;
branches;
next	11.77.2.2;

11.77.2.2
date	2003.08.15.04.19.01;	author justin;	state Exp;
branches;
next	11.77.2.3;

11.77.2.3
date	2003.08.26.14.03.31;	author justin;	state Exp;
branches;
next	;

11.80.2.1
date	2003.09.10.22.08.27;	author butler;	state Exp;
branches;
next	11.80.2.2;

11.80.2.2
date	2003.09.13.17.51.26;	author butler;	state Exp;
branches;
next	;

11.81.2.1
date	2004.02.12.18.38.49;	author erikg;	state Exp;
branches;
next	11.81.2.2;

11.81.2.2
date	2004.03.10.13.20.29;	author erikg;	state Exp;
branches;
next	11.81.2.3;

11.81.2.3
date	2004.03.15.14.07.13;	author erikg;	state Exp;
branches;
next	11.81.2.4;

11.81.2.4
date	2004.03.18.18.10.28;	author erikg;	state Exp;
branches;
next	;


desc
@Material property module for handling light sources.
@


11.87
log
@moved to src/
@
text
@/*
 *			L I G H T . C
 *
 *  Implement simple isotropic light sources as a material property.
 *
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" license agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1998-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */
#ifndef lint
static const char RCSsh_light[] = "@@(#)$Header: /n/xoff/cvs/brlcad/liboptical/sh_light.c,v 11.86 2004/05/10 15:30:45 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef HAVE_STRING_H
# include <string.h>
#endif
#include <math.h>
#include "machine.h"
#include "vmath.h"
#include "bu.h"
#include "raytrace.h"
#include "shadefuncs.h"
#include "shadework.h"
#include "plot3.h"
#include "rtprivate.h"
#include "light.h"
#include "photonmap.h"

#if RT_MULTISPECTRAL
#include "spectrum.h"
#endif

extern int
viewshade(struct application *ap,
	  register const struct partition *pp,
	  register struct shadework *swp);


#if !defined(M_PI)
#define M_PI            3.14159265358979323846
#define	M_PI_2		1.57079632679489661923
#endif


#define LIGHT_O(m)	offsetof(struct light_specific, m)
#define LIGHT_OA(m)	bu_offsetofarray(struct light_specific, m)

RT_EXTERN(void	aim_set, (const struct bu_structparse *sdp, const char *name,
const char *base, char *value));

/***********************************************************************
 *
 *  light_cvt_visible()
 *
 *  Convert "visible" flag to "invisible" variable 
 */
void
light_cvt_visible(register const struct bu_structparse *sdp, register const char *name, char *base, const char *value)
                                    	     	/* structure description */
                   			      	/* struct member name */
    					      	/* begining of structure */
          				       	/* string containing value */
{
	struct light_specific *lsp = (struct light_specific *)base;

	if (rdebug & RDEBUG_LIGHT) {
		bu_log("light_cvt_visible(%s, %d)\n", name, sdp->sp_offset);
		bu_log("visible: %d invisible: %d\n", 
		       LIGHT_O(lt_visible),
		       LIGHT_O(lt_invisible));
	}
	switch (sdp->sp_offset) {
	case LIGHT_O(lt_invisible):
		lsp->lt_visible = !lsp->lt_invisible;
		break;
	case LIGHT_O(lt_visible):
		lsp->lt_invisible = !lsp->lt_visible;
		break;
	}
}

/*
 *
 */
static void
light_pt_set(register const struct bu_structparse *sdp, register const char *name, char *base, const char *value)
                                    	     	/* structure description */
                   			      	/* struct member name */
    					      	/* begining of structure */
          				       	/* string containing value */
{
	struct light_specific *lsp = (struct light_specific *)base;
	fastf_t *p = (fastf_t *)(base+sdp->sp_offset);

	if ( lsp->lt_pt_count >= MAX_LIGHT_SAMPLES ) return;

	if (! strcmp("pt", name) ) {
		/* user just specified point, set normal to zeros */
		p[3] = p[4] = p[5] = 0.0;
	} else if ( strcmp("pn", name) ) {
		bu_log("*********** unknown option in light_pt_set %s:%d\n",
		       __FILE__, __LINE__);
		return;
	}

	memcpy( &lsp->lt_sample_pts[ lsp->lt_pt_count++ ], p,
		sizeof( struct light_pt ) );
}

struct bu_structparse light_print_tab[] = {
{"%f",	1, "bright",	LIGHT_O(lt_intensity),	BU_STRUCTPARSE_FUNC_NULL },
{"%f",	1, "angle",	LIGHT_O(lt_angle),	BU_STRUCTPARSE_FUNC_NULL },
{"%f",	1, "fract",	LIGHT_O(lt_fraction),	BU_STRUCTPARSE_FUNC_NULL },
{"%f",	3, "target",	LIGHT_OA(lt_target),	aim_set },
{"%d",	1, "shadows",	LIGHT_O(lt_shadows),	BU_STRUCTPARSE_FUNC_NULL },
{"%d",	1, "infinite",	LIGHT_O(lt_infinite),	BU_STRUCTPARSE_FUNC_NULL },
{"%d",	1, "visible",	LIGHT_O(lt_visible),	BU_STRUCTPARSE_FUNC_NULL },
{"%d",	1, "invisible",	LIGHT_O(lt_invisible),	BU_STRUCTPARSE_FUNC_NULL },
{"",	0, (char *)0,	0,			BU_STRUCTPARSE_FUNC_NULL }
};
struct bu_structparse light_parse[] = {

{"%f",	1, "bright",	LIGHT_O(lt_intensity),	BU_STRUCTPARSE_FUNC_NULL },
{"%f",	1, "b",		LIGHT_O(lt_intensity),	BU_STRUCTPARSE_FUNC_NULL },
{"%f",	1, "inten",	LIGHT_O(lt_intensity),	BU_STRUCTPARSE_FUNC_NULL },

{"%f",	1, "angle",	LIGHT_O(lt_angle),	BU_STRUCTPARSE_FUNC_NULL },
{"%f",	1, "a",		LIGHT_O(lt_angle),	BU_STRUCTPARSE_FUNC_NULL },

{"%f",	1, "fract",	LIGHT_O(lt_fraction),	BU_STRUCTPARSE_FUNC_NULL },
{"%f",	1, "f",		LIGHT_O(lt_fraction),	BU_STRUCTPARSE_FUNC_NULL },

{"%f",	3, "target",	LIGHT_OA(lt_target),	aim_set },
{"%f",	3, "t",		LIGHT_OA(lt_target),	aim_set },
{"%f",	3, "aim",	LIGHT_OA(lt_target),	aim_set },

{"%d",	1, "shadows",	LIGHT_O(lt_shadows),	BU_STRUCTPARSE_FUNC_NULL },
{"%d",	1, "s",		LIGHT_O(lt_shadows),	BU_STRUCTPARSE_FUNC_NULL },

{"%d",	1, "infinite",	LIGHT_O(lt_infinite),	BU_STRUCTPARSE_FUNC_NULL },
{"%d",	1, "i",		LIGHT_O(lt_infinite),	BU_STRUCTPARSE_FUNC_NULL },

{"%d",	1, "visible",	LIGHT_O(lt_visible),	light_cvt_visible },
{"%d",  1, "invisible",	LIGHT_O(lt_invisible),	light_cvt_visible },
{"%d",	1, "v",		LIGHT_O(lt_visible),	light_cvt_visible },

{"%f",	3, "pt",	LIGHT_OA(lt_parse_pt), light_pt_set },
{"%f",	6, "pn",	LIGHT_OA(lt_parse_pt), light_pt_set },

{"",	0, (char *)0,	0,			BU_STRUCTPARSE_FUNC_NULL }
};


struct light_specific	LightHead;	/* Heads linked list of lights */

extern double AmbientIntensity;

#if RT_MULTISPECTRAL
extern const struct bn_table	*spectrum;	/* from rttherm/viewtherm.c */
#endif

HIDDEN int	light_setup(register struct region *rp, struct bu_vls *matparm, genptr_t *dpp, struct mfuncs *mfp, struct rt_i *rtip), light_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
HIDDEN void	light_print(register struct region *rp, char *dp);
void		light_free(char *cp);

struct mfuncs light_mfuncs[] = {
	{MF_MAGIC,	"light",	0,		MFI_NORMAL,	0,
	light_setup,	light_render,	light_print,	light_free },
	{0,		(char *)0,	0,		0,		0,
	0,		0,		0,		0 }
};


/*
 * This is a container for all the stuff that must be carried around when
 * doing the light obscuration/visibility calculations.
 */
struct light_obs_stuff {
	struct application *ap;
	struct shadework *swp;
	struct light_specific *lsp;
	int *rand_idx;

#if RT_MULTISPECTRAL
	struct bn_tabdata **inten;
#else
	fastf_t *inten;
#endif
	int iter;
	vect_t to_light_center;	/* coordinate system on light */
	vect_t light_x;
	vect_t light_y;
};


/*
 *			A I M _ S E T
 *
 *  This routine is called by bu_struct_parse() if the "aim"
 *  qualifier is encountered, and causes lt_exaim to be set.
 */

HIDDEN void aim_set (const struct bu_structparse *sdp, const char *name, const char *base, char *value)
{
	register struct light_specific *lsp = (struct light_specific *)base;
	if (rdebug & RDEBUG_LIGHT )  {
		VPRINT("lt_target: ", lsp->lt_target);
	}
	lsp->lt_exaim = 1;
}

/*
 *			L I G H T _ R E N D E R
 *
 *  If we have a direct view of the light, return it's color.
 *  A cosine term is needed in the shading of the light source,
 *  to make it have dimension and shape.  However, just a simple
 *  cosine of the angle between the normal and the direction vector
 *  leads to a pretty dim looking light.  Therefore, a cos/2 + 0.5
 *  term is used when the viewer is within the beam, and a cos/2 term
 *  when the beam points away.
 */
HIDDEN int
light_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
{
	register struct light_specific *lsp = (struct light_specific *)dp;
	register fastf_t f;

	RT_CK_LIGHT(lsp);

	/* Provide cosine/2 shading, to make light look round */
	if ((f = -VDOT( swp->sw_hit.hit_normal, ap->a_ray.r_dir )*0.5) < 0 )
		f = 0;

	/* See if surface normal falls in light beam direction */
	if (VDOT( lsp->lt_aim, swp->sw_hit.hit_normal) < lsp->lt_cosangle )  {
		/* dark, outside of light beam area */
		f *= lsp->lt_fraction;
	} else {
		/* within beam area */
		f = (f+0.5) * lsp->lt_fraction;
	}
#if RT_MULTISPECTRAL
	/* Support a shader having modified the temperature of the source */
	if (swp->sw_temperature > 0 )  {
		rt_spect_black_body( swp->msw_color, swp->sw_temperature, 5 );
		bn_tabdata_scale( swp->msw_color, swp->msw_color, f );
		if (rdebug & RDEBUG_LIGHT )  {
			bu_log("light %s xy=%d,%d temp=%g\n",
			pp->pt_regionp->reg_name, ap->a_x, ap->a_y,
			swp->sw_temperature );
		}
	} else {
		bn_tabdata_scale( swp->msw_color, lsp->lt_spectrum, f );
	}
#else
	if (!PM_Activated) {
	  VSCALE( swp->sw_color, lsp->lt_color, f );
	}
#endif
	return(1);
}

/*
 * When shooting grids of rays to generate the points on the light, we
 * add the hit point(s) to the list of points on the light.
 *
 */
static int
gen_hit(register struct application *ap,
	struct partition	    *PartHeadp,
	struct seg		    *sp)
{
	struct light_specific *lsp = (struct light_specific *)ap->a_uptr;
	struct soltab *stp;
	struct light_pt *lpt;
	struct partition *pp, *prev, *next;

	if ((pp=PartHeadp->pt_forw) == PartHeadp) return 0;

	for( ; pp != PartHeadp; pp = pp->pt_forw )  {

		if (pp->pt_regionp != lsp->lt_rp) continue;

		prev = pp->pt_back;
		/* check to make sure the light hit point isn't against some
		 * other object
		 */
		if (prev != PartHeadp) {
			double delta;
			delta = prev->pt_outhit->hit_dist - 
				pp->pt_inhit->hit_dist;

			/* XXX This really should compare to see if adj
			 * object is air
			 */
			if (delta < 5.0 && delta > -5.0) {
				continue;
			}
		}

		/* The inbound point is not against another object, so 
		 * light will be emitted in this direction
		 */
		lpt = &lsp->lt_sample_pts[lsp->lt_pt_count++];

		stp = pp->pt_inseg->seg_stp;

		VJOIN1( lpt->lp_pt, ap->a_ray.r_pt, 
			pp->pt_inhit->hit_dist, ap->a_ray.r_dir );

		RT_HIT_NORMAL( lpt->lp_norm, pp->pt_inhit, stp, 
			       &(ap->a_ray), pp->pt_inflip );

		if (lsp->lt_pt_count >= MAX_LIGHT_SAMPLES) return 1;

		/* check to make sure the light out hit point isn't against
		 * some other object
		 */
		next = pp->pt_forw;
		if (next != PartHeadp) {
			double delta;
			delta = next->pt_inhit->hit_dist - 
				pp->pt_outhit->hit_dist;

			/* XXX This really should compare to see if adj
			 * object is air
			 */
			if (delta < 5.0 && delta > -5.0) {
				continue;
			}
		}
		/* The out point isn't against another object, so light
		 * will be emitted in this direction
		 */
		lpt = &lsp->lt_sample_pts[lsp->lt_pt_count++];

		stp = pp->pt_outseg->seg_stp;

		VJOIN1( lpt->lp_pt, ap->a_ray.r_pt, 
			pp->pt_outhit->hit_dist, ap->a_ray.r_dir );

		RT_HIT_NORMAL( lpt->lp_norm, pp->pt_outhit, stp, 
			       &(ap->a_ray), pp->pt_outflip );

		if (lsp->lt_pt_count >= MAX_LIGHT_SAMPLES) return 1;
 
	}
	return 1;
}

/*
 * When shooting the grids for building light pts, if we miss the light just
 * return;
 */
static int
gen_miss(register struct application *ap)
{
	return 0;
}

#if 0
/*
 *
 *  Shoot rays in each of the axis directions looking for hit points
 *  on a light.
 */
static void
shoot_grids(struct application *ap,
	    vect_t step,
	    point_t tree_min,
	    point_t tree_max)
{
	double x, y, z;
	struct light_specific *lsp = (struct light_specific *)ap->a_uptr;

	if (rdebug & RDEBUG_LIGHT )
		bu_log("shoot_grids Z, step=(%g, %g, %g)\n", V3ARGS(step) );

	/* shoot through the X,Y plane */
#define MIN_GRID_STEP_MM	0.1		/* had been 10.0 */

	if (step[Y] > MIN_GRID_STEP_MM && step[X] > MIN_GRID_STEP_MM) {
		z = tree_min[Z];

		VSET(ap->a_ray.r_dir, 0.0, 0.0, 1.0);
		z = tree_min[Z];

		for (y = tree_min[Y] + step[Y] * 0.5;
		     y < tree_max[Y] ; y += step[Y])

			for (x = tree_min[X] + step[X] * 0.5;
			     x < tree_max[X] ; x += step[X]) {
				VSET(ap->a_ray.r_pt, x, y, z);
				(void)rt_shootray( ap );
				if (lsp->lt_pt_count >= MAX_LIGHT_SAMPLES)
					return;
			}
	}

	if (rdebug & RDEBUG_LIGHT )
		bu_log("shoot_grids Y\n");

	/* shoot through the X, Z plane */
	if (step[Z] > MIN_GRID_STEP_MM && step[X] > MIN_GRID_STEP_MM) {
		y = tree_min[Y];

		VSET(ap->a_ray.r_dir, 0.0, 1.0, 0.0);
		z = tree_min[Z];

		for (z = tree_min[Z] + step[Z] * 0.5;
		     z < tree_max[Z] ; z += step[Z])

			for (x = tree_min[X] + step[X] * 0.5;
			     x < tree_max[X] ; x += step[X]) {
				VSET(ap->a_ray.r_pt, x, y, z);
				(void)rt_shootray( ap );
				if (lsp->lt_pt_count >= MAX_LIGHT_SAMPLES)
					return;
			}
	}

	/* shoot through the Y, Z plane */
	if (rdebug & RDEBUG_LIGHT )
		bu_log("shoot_grids X\n");
	if (step[Z] > MIN_GRID_STEP_MM && step[Y] > MIN_GRID_STEP_MM) {
		VSET(ap->a_ray.r_dir, 1.0, 0.0, 0.0);
		x = tree_min[X];

		for (z = tree_min[Z] + step[Z] * 0.5;
		     z < tree_max[Z] ; z += step[Z])

			for (y = tree_min[Y] + step[Y] * 0.5;
			     y < tree_max[Y] ; y += step[Y]) {
				VSET(ap->a_ray.r_pt, x, y, z);
				(void)rt_shootray( ap );
				if (lsp->lt_pt_count >= MAX_LIGHT_SAMPLES)
					return;
			}
	}

}
#endif
static void 
ray_setup(struct application *ap,
		      point_t tree_min,
		      point_t tree_max,
		      point_t span)
{
	int face;
	point_t pt;
	static int idx = 0;

	/* pick a face of the bounding RPP at which we will start the ray */
	face = BN_RANDOM(idx) * 2.9999;

	switch (face) {
	case 0: /* XMIN */
		VSET(ap->a_ray.r_pt,
		     tree_min[X] - 10.0, 
		     tree_min[Y] + BN_RANDOM(idx) * span[Y],
		     tree_min[Z] + BN_RANDOM(idx) * span[Z]);
		VSET(pt,
		     tree_max[X], 
		     tree_min[Y] + BN_RANDOM(idx) * span[Y],
		     tree_min[Z] + BN_RANDOM(idx) * span[Z]);
		break;

	case 1: /* YMIN */
		VSET(ap->a_ray.r_pt,
		     tree_min[X] + BN_RANDOM(idx) * span[X],
		     tree_min[Y] - 10.0,
		     tree_min[Z] + BN_RANDOM(idx) * span[Z]);
		VSET(pt,
		     tree_min[X] + BN_RANDOM(idx) * span[X],
		     tree_max[Y],
		     tree_min[Z] + BN_RANDOM(idx) * span[Z]);
		break;

	case 2: /* ZMIN */
		VSET(ap->a_ray.r_pt,
		     tree_min[X] + 
		     BN_RANDOM(idx) * span[X],

		     tree_min[Y] + 
		     BN_RANDOM(idx) * span[Y],

		     tree_min[Z] - 10.0);
		VSET(pt,
		     tree_min[X] + 
		     BN_RANDOM(idx) * span[X],

		     tree_min[Y] + 
		     BN_RANDOM(idx) * span[Y],

		     tree_max[Z]);
		break;
	}
	VSUB2(ap->a_ray.r_dir, pt, ap->a_ray.r_pt);
	VUNITIZE(ap->a_ray.r_dir);

}


/*	L I G H T _ G E N _ S A M P L E _ P T S
 *
 *  Generate a set of sample points on the surface of the light with surface
 *  normals.
 */
void
light_gen_sample_pts(struct application    *upap,
		     struct light_specific  *lsp)
{
	struct application ap;
	point_t tree_min;
	point_t tree_max;
	vect_t  span;

	RT_CK_LIGHT(lsp);

	if (rdebug & RDEBUG_LIGHT )
		bu_log("light_gen_sample_pts(%s)\n", lsp->lt_name);


	memset(&ap, 0, sizeof(ap));
	ap.a_rt_i = upap->a_rt_i;
	ap.a_onehit = 0;
	ap.a_hit = gen_hit;
	ap.a_miss = gen_miss;
	ap.a_uptr = (genptr_t)lsp;

	/* get the bounding box of the light source */
	rt_bound_tree(lsp->lt_rp->reg_treetop, tree_min, tree_max);


	if (rdebug & RDEBUG_LIGHT ) {
		bu_log("light bb (%g %g %g), (%g %g %g)\n", 
		       V3ARGS(tree_min), V3ARGS(tree_max) );
	}


	/* if there is no space occupied by the light source, then
	 * just give up
	 */
	VSUB2(span, tree_max, tree_min);
	if (rdebug & RDEBUG_LIGHT ) {
		bu_log("span %g %g %g\n", V3ARGS(span));
	}
	if (span[X] <= 0.0 && span[Y] <= 0.0 && span[Z] <= 0.0) {
		bu_log("Small light. (treating as point source)\n");
		return;
	}

	while ( lsp->lt_pt_count < MAX_LIGHT_SAMPLES ) {

		ray_setup(&ap, tree_min, tree_max, span);
		(void)rt_shootray( &ap );
	}

	if (rdebug & RDEBUG_LIGHT ) {
		int l;
		point_t p;
		struct light_pt *lpt = &lsp->lt_sample_pts[0];

		bu_log("%d light sample points\n", lsp->lt_pt_count);

		for (l=0 ; l < lsp->lt_pt_count ; l++, lpt++) {

			VJOIN1(p, lpt->lp_pt, 100.0, lpt->lp_norm);

			bu_log("V %g %g %g  %g %g %g\n",
			       V3ARGS(lpt->lp_pt), V3ARGS(p));
		}
	}
}

/*
 *			L I G H T _ S E T U P
 *
 *  Called once for each light-emitting region.
 */
HIDDEN int
light_setup(register struct region *rp,
	    struct bu_vls	   *matparm,
	    genptr_t		   *dpp,
	    struct mfuncs          *mfp,
	    struct rt_i            *rtip)  /* New since 4.4 release */
{
	register struct light_specific *lsp;
	register struct soltab *stp;
	vect_t	work;
	fastf_t	f;

	BU_CK_VLS( matparm );
	BU_GETSTRUCT( lsp, light_specific );

	BU_LIST_MAGIC_SET( &(lsp->l), LIGHT_MAGIC );
	lsp->lt_intensity = 1.0;	/* Lumens */
	lsp->lt_fraction = -1.0;		/* Recomputed later */
	lsp->lt_visible = 1;		/* explicitly modeled */
	lsp->lt_invisible = 0;		/* explicitly modeled */
	lsp->lt_shadows = 1;		/* by default, casts shadows */
	lsp->lt_angle = 180;		/* spherical emission by default */
	lsp->lt_exaim = 0;		/* use default aiming mechanism */
	lsp->lt_infinite = 0;
	lsp->lt_rp = rp;
	lsp->lt_pt_count = 0;
	memset(lsp->lt_sample_pts, 0, sizeof(lsp->lt_sample_pts));
	lsp->lt_name = bu_strdup( rp->reg_name );
	if (bu_struct_parse( matparm, light_parse, (char *)lsp ) < 0 )  {
		bu_free( (char *)lsp, "light_specific" );
		return(-1);
	}

	if (lsp->lt_angle > 180 )  lsp->lt_angle = 180;
	lsp->lt_cosangle = cos( (double) lsp->lt_angle * 0.0174532925199433 );

	/* Determine position and size */
	if (rp->reg_treetop->tr_op == OP_SOLID )  {

		stp = rp->reg_treetop->tr_a.tu_stp;
		VMOVE( lsp->lt_pos, stp->st_center );
		lsp->lt_radius = stp->st_aradius;
	} else {
		vect_t	min_rpp, max_rpp;
		vect_t	rad;
		register union tree *tp;

		if (rt_bound_tree( rp->reg_treetop, min_rpp, max_rpp ) < 0 )
			return(-1);

		if (max_rpp[X] >= INFINITY )  {
			bu_log("light_setup(%s) Infinitely large light sources not supported\n",
			    lsp->lt_name );
			return(-1);
		}
		VADD2SCALE( lsp->lt_pos, min_rpp, max_rpp, 0.5 );
		VSUB2( rad, max_rpp, lsp->lt_pos );
		/* Use smallest radius from center to max as light radius */
		/* Having the radius too large can give very poor lighting */
		if (rad[X] < rad[Y] )
			lsp->lt_radius = rad[X];
		else
			lsp->lt_radius = rad[Y];
		if (rad[Z] < lsp->lt_radius )
			lsp->lt_radius = rad[Z];

		/* Find first leaf node on left of tree */
		tp = rp->reg_treetop;
		while( tp->tr_op != OP_SOLID )
			tp = tp->tr_b.tb_left;
		stp = tp->tr_a.tu_stp;
	}

	/* Light is aimed down -Z in it's local coordinate system */
	{
		register matp_t	matp;
		if ((matp = stp->st_matp) == (matp_t)0 )
			matp = (matp_t)bn_mat_identity;
		if (lsp->lt_exaim) {
			VSUB2 (work, lsp->lt_target, lsp->lt_pos);
			VUNITIZE (work);
		}
		else VSET( work, 0, 0, -1 );
		MAT4X3VEC( lsp->lt_aim, matp, work );
		VUNITIZE( lsp->lt_aim );
	}

#if RT_MULTISPECTRAL
	BN_GET_TABDATA(lsp->lt_spectrum, spectrum);
	if (rp->reg_mater.ma_temperature > 0 )  {
		rt_spect_black_body( lsp->lt_spectrum,
			rp->reg_mater.ma_temperature, 5 );
		if (rdebug & RDEBUG_LIGHT )  {
			bu_log("Light %s temp is %g degK, emission is pure black-body\n",
				rp->reg_name, rp->reg_mater.ma_temperature);
		}
	} else if (rp->reg_mater.ma_color_valid )  {
		rt_spect_reflectance_rgb( lsp->lt_spectrum,
					  rp->reg_mater.ma_color );
		/* XXX Need to convert units of lumens (candela-sr) to ?? 
		 * mw/sr?  Use any old numbers to get started.
		 */
		bn_tabdata_scale( lsp->lt_spectrum, lsp->lt_spectrum,
			lsp->lt_intensity * 0.001 ); /* XXX */
	} else {
		/* Default: Perfectly even emission across whole spectrum */
		bn_tabdata_constval( lsp->lt_spectrum, 0.001 );
	}
#else
	if (rp->reg_mater.ma_color_valid )  {
		VMOVE( lsp->lt_color, rp->reg_mater.ma_color );
	} else {
		VSETALL( lsp->lt_color, 1 );
	}
#endif

	VMOVE( lsp->lt_vec, lsp->lt_pos );
	f = MAGNITUDE( lsp->lt_vec );
	if (f < SQRT_SMALL_FASTF ) {
		/* light at the origin, make its direction vector up */
		VSET( lsp->lt_vec, 0, 0, 1 );
	} else {
		VSCALE( lsp->lt_vec, lsp->lt_vec, f );
	}

	/* Add to linked list of lights */
	if (BU_LIST_UNINITIALIZED( &(LightHead.l ) ) )  {
		BU_LIST_INIT( &(LightHead.l) );
	}
	BU_LIST_INSERT( &(LightHead.l), &(lsp->l) );

	if (rdebug&RDEBUG_LIGHT)
		light_print(rp, lsp);

	if (lsp->lt_invisible )  {
		return(2);	/* don't show light, destroy it later */
	}

	*dpp = (genptr_t)lsp;	/* Associate lsp with reg_udata */
	return(1);
}

/*
 *			L I G H T _ P R I N T
 */
HIDDEN void
light_print(register struct region *rp, char *dp)
{
	bu_struct_print(rp->reg_name, light_print_tab, (char *)dp);
}

/*
 *			L I G H T _ F R E E
 */
void
light_free(char *cp)
{
	register struct light_specific *lsp = (struct light_specific *)cp;

	RT_CK_LIGHT(lsp);
	BU_LIST_DEQUEUE( &(lsp->l) );
	if (lsp->lt_name )  {
		bu_free( lsp->lt_name, "light name" );
		lsp->lt_name = (char *)0;
	}
	lsp->l.magic = 0;	/* sanity */
	bu_free( (char *)lsp, "light_specific" );
}

/*
 *			L I G H T _ M A K E R
 *
 *  Special hook called by view_2init to build 1 or 3 debugging lights.
 */
void
light_maker(int num, mat_t v2m)
{
	register struct light_specific *lsp;
	register int i;
	vect_t	temp;
	vect_t	color;
	char	name[64];
#if RT_MULTISPECTRAL
	float	fcolor[3];
#endif
	/* Determine the Light location(s) in view space */
	for( i=0; i<num; i++ )  {
		switch(i)  {
		case 0:
			/* 0:  At left edge, 1/2 high */
			VSET( color, 1,  1,  1 );	/* White */
			VSET( temp, -1, 0, 1 );
			break;

		case 1:
			/* 1: At right edge, 1/2 high */
			VSET( color,  1, 1, 1 );
			VSET( temp, 1, 0, 1 );
			break;

		case 2:
			/* 2:  Behind, and overhead */
			VSET( color, 1, 1,  1 );
			VSET( temp, 0, 1, -0.5 );
			break;

		default:
			return;
		}
		BU_GETSTRUCT( lsp, light_specific );
		lsp->l.magic = LIGHT_MAGIC;
#if RT_MULTISPECTRAL

		BN_GET_TABDATA(lsp->lt_spectrum, spectrum);
		VMOVE(fcolor, color);
		rt_spect_reflectance_rgb( lsp->lt_spectrum, fcolor );
		bn_tabdata_scale( lsp->lt_spectrum, lsp->lt_spectrum, 1000.0 );

#else
		VMOVE( lsp->lt_color, color );
#endif
		MAT4X3VEC( lsp->lt_pos, v2m, temp );
		VMOVE( lsp->lt_vec, lsp->lt_pos );
		VUNITIZE( lsp->lt_vec );

		sprintf(name, "Implicit light %d", i);
		lsp->lt_name = bu_strdup(name);

		/* XXX Is it bogus to set lt_aim? */
		VSET( lsp->lt_aim, 0, 0, -1 );	/* any direction: spherical */
		lsp->lt_intensity = 1.0;
		lsp->lt_radius = 0.1;		/* mm, "point" source */
		lsp->lt_visible = 0;		/* NOT explicitly modeled */
		lsp->lt_invisible = 1;		/* NOT explicitly modeled */
		lsp->lt_shadows = 0;		/* no shadows for speed */
		lsp->lt_angle = 180;		/* spherical emission */
		lsp->lt_cosangle = -1;		/* cos(180) */
		lsp->lt_infinite = 0;
		lsp->lt_rp = REGION_NULL;
		if (BU_LIST_UNINITIALIZED( &(LightHead.l ) ) )  {
			BU_LIST_INIT( &(LightHead.l) );
		}
		BU_LIST_INSERT( &(LightHead.l), &(lsp->l) );
	}
}

/*
 *			L I G H T _ I N I T
 *
 *  Special routine called by view_2init() to determine the relative
 *  intensities of each light source.
 *
 *  Because of the limited dynamic range of RGB space (0..255),
 *  the strategy used here is a bit risky.  We find the brightest
 *  single light source in the model, and assume that the energy from
 *  multiple lights will not shine on a single location in such a way
 *  as to add up to an overload condition.
 *  We then account for the effect of ambient light, because it always
 *  adds it's contribution.  Even here we only expect 50% of the ambient
 *  intensity, to keep the pictures reasonably bright.
 */
int
light_init(struct application *ap)
{
	register struct light_specific *lsp;
	register int		nlights = 0;
	register fastf_t	inten = 0.0;

	if (BU_LIST_UNINITIALIZED( &(LightHead.l ) ) )  {
		BU_LIST_INIT( &(LightHead.l) );
	}


	for( BU_LIST_FOR( lsp, light_specific, &(LightHead.l) ) )  {
		nlights++;
		if (lsp->lt_fraction > 0 )  continue;	/* overridden */
		if (lsp->lt_intensity <= 0 )
			lsp->lt_intensity = 1;		/* keep non-neg */
		if (lsp->lt_intensity > inten )
			inten = lsp->lt_intensity;
	}

	/* Compute total emitted energy, including ambient */
	/**	inten *= (1 + AmbientIntensity); **/
	/* This is non-physical and risky, but gives nicer pictures for now */
	inten *= (1 + AmbientIntensity*0.5);

	for( BU_LIST_FOR( lsp, light_specific, &(LightHead.l) ) )  {
		RT_CK_LIGHT(lsp);
		if (lsp->lt_fraction > 0 )  continue;	/* overridden */
#if RT_MULTISPECTRAL
		lsp->lt_fraction = 1.0;	/* always use honest intensity values */
#else
		lsp->lt_fraction = lsp->lt_intensity / inten;
#endif
	}

	/* 
	 * Make sure we have sample points for all light sources in the scene
	 */
	for( BU_LIST_FOR( lsp, light_specific, &(LightHead.l) ) )  {
		RT_CK_LIGHT(lsp);
		if (lsp->lt_shadows > 1 && 
		    lsp->lt_pt_count < 1)
			light_gen_sample_pts(ap, lsp);
	}


	if (R_DEBUG) {
		bu_log("Lighting: Ambient = %d%%\n",
		       (int)(AmbientIntensity*100));

		for( BU_LIST_FOR( lsp, light_specific, &(LightHead.l) ) )  {
			RT_CK_LIGHT(lsp);
			bu_log( "  %s: (%g, %g, %g), aimed at (%g, %g, %g)\n",
			    lsp->lt_name,
			    lsp->lt_pos[X], lsp->lt_pos[Y], lsp->lt_pos[Z],
			    lsp->lt_aim[X], lsp->lt_aim[Y], lsp->lt_aim[Z] );
			bu_log( "  %s: %s, %s, %g lumens (%d%%), halfang=%g\n",
			    lsp->lt_name,
			    lsp->lt_visible ? "visible":"invisible",
			    lsp->lt_shadows ? "casts shadows":"no shadows",
			    lsp->lt_intensity,
			    (int)(lsp->lt_fraction*100),
			    lsp->lt_angle );
		}
	}
	if (nlights > SW_NLIGHTS )  {
		bu_log("Number of lights limited to %d\n", SW_NLIGHTS);
		nlights = SW_NLIGHTS;
	}
	return(nlights);
}


/*
 *			L I G H T _ C L E A N U P
 *
 *  Called from view_end().
 *  Take care of releasing storage for any lights which will not
 *  be cleaned up by mlib_free():
 *	implicitly created lights, because they have no associated region, and
 *	invisible lights, because their region was destroyed.
 */
void
light_cleanup(void)
{
	register struct light_specific *lsp, *zaplsp;

	if (BU_LIST_UNINITIALIZED( &(LightHead.l ) ) )  {
		BU_LIST_INIT( &(LightHead.l) );
		return;
	}
	for( BU_LIST_FOR( lsp, light_specific, &(LightHead.l) ) )  {
		RT_CK_LIGHT(lsp);
		if (lsp->lt_rp != REGION_NULL && lsp->lt_visible )  {
			/* Will be cleaned up by mlib_free() */
			continue;
		}
		zaplsp = lsp;
		lsp = BU_LIST_PREV( light_specific, &(lsp->l) );
		light_free( (genptr_t)zaplsp );
	}
}
/**********************************************************************/
/* 
 *			L I G H T _ H I T
 *
 *  A light visibility test ray hit something.  Determine what this means.
 *
 *  Input -
 *	a_color[] contains the fraction of a the light that will be
 *	propagated back along the ray, so far.  If this gets too small,
 *	recursion through lots of glass ought to stop.
 *  Output -
 *	a_color[] contains the fraction of light that can be seen.
 *	RGB transmissions are separately indicated, to allow simplistic
 *	colored glass (with apologies to Roy Hall).
 *
 *  a_spectrum is used in place of a_color for multispectral renderings.
 *
 *  These shadow functions return a boolean "light_visible".
 * 
 *  This is a simplified algorithm, and could be improved.
 *  Reflected light can't be dealt with at all.
 *
 *  Would also be nice to return an actual energy level, rather than
 *  a boolean, which could account for distance, etc.
 */

int
light_hit(struct application *ap, struct partition *PartHeadp, struct seg *finished_segs)
{
	register struct partition *pp;
	register struct region	*regp = NULL;
	struct application	sub_ap;
	struct shadework	sw;
	const struct light_specific	*lsp;
	extern int	light_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
#if RT_MULTISPECTRAL
	struct bn_tabdata	*ms_filter_color = BN_TABDATA_NULL;
#else
	vect_t	filter_color;
#endif
	int	light_visible;
	int	air_sols_seen = 0;
	int 	is_proc;
	char	*reason = "???";

	memset(&sw, 0, sizeof(sw));		/* make sure nothing nasty on the stack */
	if (rdebug&RDEBUG_LIGHT)
		bu_log("light_hit level %d %d\n", ap->a_level, __LINE__);

#if RT_MULTISPECTRAL
	sub_ap.a_spectrum = BN_TABDATA_NULL;	/* sanity */
	BN_CK_TABDATA(ap->a_spectrum);
#endif

	BU_CK_LIST_HEAD(&finished_segs->l);

	lsp = (struct light_specific *)(ap->a_uptr);
	RT_CK_LIGHT(lsp);

#if RT_MULTISPECTRAL
	ms_filter_color = bn_tabdata_get_constval( 1.0, spectrum );
	BN_GET_TABDATA( sw.msw_color, spectrum );
	BN_GET_TABDATA( sw.msw_basecolor, spectrum );
#else
	VSETALL( filter_color, 1 );
#endif
	/*XXX Bogus with Air.  We should check to see if it is the same 
	 * surface.
	 *
	 *  Since the light visibility ray started at the surface of a solid,
	 *  it is likely that the solid will be the first partition on
	 *  the list, with pt_outhit->hit_dist being roughly zero.
	 *  Don't start using partitions until pt_inhit->hit_dist is
	 *  slightly larger than zero, i.e., that the partition is not
	 *  including the start point.
	 *  The outhit distance needs to be checked too, so that if the
	 *  partition is heading through the solid toward the light
	 *  e.g. (-1,+50), then the fact that the light is obscured will
	 *  not be missed.
	 */
	for( pp=PartHeadp->pt_forw; pp != PartHeadp; pp = pp->pt_forw )  {
		if (pp->pt_regionp->reg_aircode != 0 )  {
			/* Accumulate transmission through each air lump */
			air_sols_seen++;

			/* Obtain opacity of this region, multiply */
			sw.sw_inputs = 0;
			sw.sw_transmit = sw.sw_reflect = 0.0;
			sw.sw_refrac_index = 1.0;
			sw.sw_xmitonly = 1;	/* only want sw_transmit */
			sw.sw_segs = finished_segs;
#if RT_MULTISPECTRAL
			bn_tabdata_constval( sw.msw_color, 1.0 );
			bn_tabdata_constval( sw.msw_basecolor, 1.0 );
#else
			VSETALL( sw.sw_color, 1 );
			VSETALL( sw.sw_basecolor, 1 );
#endif
			if (rdebug&RDEBUG_LIGHT) bu_log("calling viewshade\n");
			(void)viewshade( ap, pp, &sw );
			if (rdebug&RDEBUG_LIGHT) bu_log("viewshade returns\n");
			/* sw_transmit is only return */

			/* XXX Clouds don't yet attenuate differently based on freq */
#if RT_MULTISPECTRAL
			bn_tabdata_scale( ms_filter_color, ms_filter_color,
			    sw.sw_transmit );
#else
			VSCALE( filter_color, filter_color, sw.sw_transmit );
#endif
			continue;
		}
		if (pp->pt_inhit->hit_dist >= ap->a_rt_i->rti_tol.dist )
			break;
		if (pp->pt_outhit->hit_dist >= ap->a_rt_i->rti_tol.dist*10 )
			break;
	}



	if (pp == PartHeadp )  {
		if (rdebug&RDEBUG_LIGHT) bu_log("pp == PartHeadp\n");

		pp=PartHeadp->pt_forw;
		RT_CK_PT(pp);

		if (lsp->lt_invisible || lsp->lt_infinite )  {
			light_visible = 1;
#if RT_MULTISPECTRAL
			bn_tabdata_copy( ap->a_spectrum, ms_filter_color );
#else
			VMOVE( ap->a_color, filter_color );
#endif
			reason = "Unobstructed invisible/infinite light";
			goto out;
		}

		if (air_sols_seen > 0 )  {
			light_visible = 1;
#if RT_MULTISPECTRAL
			bn_tabdata_copy( ap->a_spectrum, ms_filter_color );
#else
			VMOVE( ap->a_color, filter_color );
#endif
			/* XXXXXXX This seems to happen with *every* 
			 * light vis ray through air
			 */
			reason = "Off end of partition list, air was seen";
			goto out;
		}

		if (pp->pt_inhit->hit_dist <= ap->a_rt_i->rti_tol.dist) {
			int retval;
			/* XXX This is bogus if air is being used */
			/* What has probably happened is that the shadow ray
			 * has produced an Out-hit from the current solid
			 * which looks valid, but is in fact an intersection
			 * with the current hit point.
			 */

			sub_ap = *ap;	/* struct copy */
			sub_ap.a_level++;
#if RT_MULTISPECTRAL
			sub_ap.a_spectrum = bn_tabdata_dup( ap->a_spectrum );
#endif
			/* pt_outhit->hit_point has not been calculated */
			VJOIN1(sub_ap.a_ray.r_pt, ap->a_ray.r_pt,
			    pp->pt_outhit->hit_dist, ap->a_ray.r_dir);

			if (rdebug&RDEBUG_LIGHT) bu_log("hit_dist < tol\n");
			retval = rt_shootray( &sub_ap );

			ap->a_user = sub_ap.a_user;
			ap->a_uptr = sub_ap.a_uptr;
#if RT_MULTISPECTRAL
			bn_tabdata_copy( ap->a_spectrum, sub_ap.a_spectrum );
#else
			ap->a_color[0] = sub_ap.a_color[0];
			ap->a_color[1] = sub_ap.a_color[1];
			ap->a_color[2] = sub_ap.a_color[2];
#endif
			VMOVE(ap->a_uvec, sub_ap.a_uvec);
			VMOVE(ap->a_vvec, sub_ap.a_vvec);
			ap->a_refrac_index = sub_ap.a_refrac_index;
			ap->a_cumlen = sub_ap.a_cumlen;
			ap->a_return = sub_ap.a_return;

			light_visible = retval;
			reason = "pressed on past start point";
			goto out;
		}


		bu_log("light_hit:  ERROR, nothing hit, sxy=%d,%d, dtol=%e\n",
		    ap->a_x, ap->a_y,
		    ap->a_rt_i->rti_tol.dist);
		rt_pr_partitions(ap->a_rt_i, PartHeadp, "light_hit pt list");
		light_visible = 0;
		reason = "error, nothing hit";
		goto out;
	}

	regp = pp->pt_regionp;

	/* Check to see if we hit the light source */
	if (lsp->lt_rp == regp )  {
#if RT_MULTISPECTRAL
		bn_tabdata_copy( ap->a_spectrum, ms_filter_color );
#else
		VMOVE( ap->a_color, filter_color );
#endif
		light_visible = 1;
		reason = "hit light";
		goto out;
	}

	/* if the region we hit is a light source be generous */
#if 1
	{
		struct light_specific *lsp;
		for( BU_LIST_FOR( lsp, light_specific, &(LightHead.l) ) )  {
			if (lsp->lt_rp == regp) {
#if RT_MULTISPECTRAL
		bn_tabdata_copy( ap->a_spectrum, ms_filter_color );
#else
		VMOVE( ap->a_color, filter_color );
#endif
		light_visible = 1;
		reason = "hit light";
		goto out;

			}
		}
	}
#endif
	/* or something futher away than a finite invisible light */
	if (lsp->lt_invisible && !(lsp->lt_infinite) ) {
		vect_t	tolight;
		VSUB2( tolight, lsp->lt_pos, ap->a_ray.r_pt );
		if (pp->pt_inhit->hit_dist >= MAGNITUDE(tolight) ) {
#if RT_MULTISPECTRAL
			bn_tabdata_copy( ap->a_spectrum, ms_filter_color );
#else
			VMOVE( ap->a_color, filter_color );
#endif
			light_visible = 1;
			reason = "hit behind invisible light ==> hit light";
			goto out;
		}
	}

	/* If we hit an entirely opaque object, this light is invisible */
	is_proc = ((struct mfuncs *)regp->reg_mfuncs)->mf_flags|MFF_PROC;


	if (pp->pt_outhit->hit_dist >= INFINITY ||
	    (regp->reg_transmit == 0 &&
	     ! is_proc /* procedural shader */) ) {

#if RT_MULTISPECTRAL
		bn_tabdata_constval( ap->a_spectrum, 0.0 );
#else
		VSETALL( ap->a_color, 0 );
#endif
		light_visible = 0;
		reason = "hit opaque object";
		goto out;
	}

#if RT_MULTISPECTRAL
	/* XXX Check area under spectral curve?  What power level for thresh? */
#else
	/*  See if any further contributions will mater */
	if (ap->a_color[0] + ap->a_color[1] + ap->a_color[2] < 0.01 )  {
		/* Any light energy is "fully" attenuated by here */
		VSETALL( ap->a_color, 0 );
		light_visible = 0;
		reason = "light fully attenuated before shading";
		goto out;
	}
#endif

	/*
	 *  Determine transparency parameters of this object.
	 *  All we really need here is the opacity information;
	 *  full shading is not required.
	 */
	sw.sw_inputs = 0;
	sw.sw_transmit = sw.sw_reflect = 0.0;
	sw.sw_refrac_index = 1.0;
	sw.sw_xmitonly = 1;		/* only want sw_transmit */
	sw.sw_segs = finished_segs;
#if RT_MULTISPECTRAL
	bn_tabdata_constval( sw.msw_color, 1.0 );
	bn_tabdata_constval( sw.msw_basecolor, 1.0 );
#else
	VSETALL( sw.sw_color, 1 );
	VSETALL( sw.sw_basecolor, 1 );
#endif

	if (rdebug&RDEBUG_LIGHT) bu_log("calling viewshade\n");
	(void)viewshade( ap, pp, &sw );
	if (rdebug&RDEBUG_LIGHT) bu_log("viewshade back\n");
	/* sw_transmit is output */

#if RT_MULTISPECTRAL
	bn_tabdata_scale( ms_filter_color, ms_filter_color, sw.sw_transmit );
	/* XXX Power level check again? */
#else
	VSCALE( filter_color, filter_color, sw.sw_transmit );
	if (filter_color[0] + filter_color[1] + filter_color[2] < 0.01 )  {
		/* Any recursion won't be significant */
		VSETALL( ap->a_color, 0 );
		light_visible = 0;
		reason = "light fully attenuated after shading";
		goto out;
	}
#endif
	/*
	 * Push on to exit point, and trace on from there.
	 * Transmission so far is passed along in sub_ap.a_color[];
	 * Don't even think of trying to refract, or we will miss the light!
	 */
	sub_ap = *ap;			/* struct copy */
	sub_ap.a_level = ap->a_level+1;
#if RT_MULTISPECTRAL
	sub_ap.a_spectrum = bn_tabdata_dup( ap->a_spectrum );
#endif
	{
		register fastf_t f;
		f = pp->pt_outhit->hit_dist + ap->a_rt_i->rti_tol.dist;
		VJOIN1(sub_ap.a_ray.r_pt, ap->a_ray.r_pt, f, ap->a_ray.r_dir);
	}
	sub_ap.a_purpose = "light transmission after filtering";
	if (rdebug&RDEBUG_LIGHT) 
		bu_log("shooting level %d from %d\n",
		       sub_ap.a_level, __LINE__);
	light_visible = rt_shootray( &sub_ap );
	if (rdebug&RDEBUG_LIGHT) 
		if (light_visible < 0)
			bu_log("%s:%d\n", __FILE__, __LINE__);

#if RT_MULTISPECTRAL
	bn_tabdata_mul( ap->a_spectrum, sub_ap.a_spectrum, ms_filter_color );
#else
	VELMUL( ap->a_color, sub_ap.a_color, filter_color );
#endif
	reason = "after filtering";
out:

#if RT_MULTISPECTRAL
	if (ms_filter_color ) bn_tabdata_free( ms_filter_color );
	if (sw.msw_color )  bn_tabdata_free( sw.msw_color );
	if (sw.msw_basecolor ) bn_tabdata_free( sw.msw_basecolor );
	if (sub_ap.a_spectrum )  bn_tabdata_free( sub_ap.a_spectrum );
	if (rdebug & RDEBUG_LIGHT )  {
		bu_log("light vis=%d %s %s %s  ",
		    light_visible,
		    lsp->lt_name,
		    reason,
		    regp ? regp->reg_name : "" );
		bn_pr_tabdata("light spectrum", ap->a_spectrum);
	}
#else
	if (rdebug & RDEBUG_LIGHT ) bu_log("light vis=%d %s (%4.2f, %4.2f, %4.2f) %s %s\n",
	    light_visible,
	    lsp->lt_name,
	    V3ARGS(ap->a_color), reason,
	    regp ? regp->reg_name : "" );
#endif
	return(light_visible);
}

/*
 *  			L I G H T _ M I S S
 *  
 *  If there is no explicit light solid in the model, we will always "miss"
 *  the light, so return light_visible = TRUE.
 */
/* ARGSUSED */
int
light_miss(register struct application *ap)
{
	struct light_specific *lsp = (struct light_specific *)(ap->a_uptr);

	RT_CK_LIGHT(lsp);
	if (lsp->lt_invisible || lsp->lt_infinite ) {
		VSETALL( ap->a_color, 1 );
		if (rdebug & RDEBUG_LIGHT ) bu_log("light_miss vis=1\n");
		return(1);		/* light_visible = 1 */
	}

	if (rdebug & RDEBUG_LIGHT) {
		bu_log("light ray missed non-infinite, visible light source\n");
		bu_log("on pixel: %d %d\n", ap->a_x, ap->a_y);
		bu_log("ray: (%g %g %g) -> %g %g %g\n", V3ARGS(ap->a_ray.r_pt), V3ARGS(ap->a_ray.r_dir) );
		bu_log("a_level: %d\n", ap->a_level);
	}

	/* Missed light, either via blockage or dither.  Return black */
	VSETALL( ap->a_color, 0 );
	if (rdebug & RDEBUG_LIGHT ) bu_log("light_miss vis=0\n");
	return(-1);			/* light_visible = 0 */
}

#define VF_SEEN 1
#define VF_BACKFACE 2
/***********************************************************************
 *
 *	light_vis
 *
 *	Compute 1 light visibility ray from a hit point to the light.
 *
 */
static int 
light_vis(struct light_obs_stuff *los, char *flags)
{
	struct application sub_ap;
	double radius = 0.0;
	double angle = 0.0;
	double cos_angle, x, y; 
	point_t shoot_pt;
	vect_t shoot_dir;
	int shot_status;
	vect_t dir, rdir;
	int idx;
	int k = 0;
	struct light_pt *lpt;
	int tryagain = 0;
	double VisRayvsLightN;
	double VisRayvsSurfN;

	if (rdebug & RDEBUG_LIGHT ) bu_log("light_vis\n");

retry:

	/* compute the light direction */
	if (los->lsp->lt_infinite ) {
		/* Infinite lights are point sources, no fuzzy penumbra */
		VMOVE( shoot_dir, los->lsp->lt_vec );

	} else if (los->lsp->lt_pt_count > 0) {
		static const vect_t zero = { 0.0, 0.0, 0.0 };

		/* pick a point at random from the list of points on
		 * the surface of the light.  If the normals indicate
		 * inter-visibility, then shoot at that point 
		 */

		idx = los->lsp->lt_pt_count * 
			fabs(bn_rand_half(los->ap->a_resource->re_randptr)) *
			2.0;
		if (idx == los->lsp->lt_pt_count) idx--;

	reusept:

		for (k=idx ; ((k+1) % los->lsp->lt_pt_count) != idx ; 
		     k = (k+1) % los->lsp->lt_pt_count) {
			if (rdebug & RDEBUG_LIGHT )
				bu_log("checking sample pt %d\n", k);

			if (flags[k] & VF_SEEN ) continue;
			if (flags[k] & VF_BACKFACE ) continue;

			/* we've got a candidate, check for backfacing */
			if (rdebug & RDEBUG_LIGHT )
				bu_log("\tpossible sample pt %d\n", k);

			lpt = &los->lsp->lt_sample_pts[k];

			VSUB2(dir, lpt->lp_pt, los->swp->sw_hit.hit_point);
			VUNITIZE(dir);
			VREVERSE(rdir, dir);


			/* if the surface normals of the light and hit point
			 * indicate that light could pass between the two
			 * points, then we have a good choice
			 *
			 * If the light point has no surface normal, then
			 * this is a general point usable from any angle
			 * so again we can shoot at this point
			 *
			 * We tolerance this down so that light points which
			 * are in the plane of the hit point are not candidates
			 * (since the light on the surface from such would be
			 * very small).  We also tolerance the normal on the
			 * light to the visibility ray so that points on the
			 * perimiter of the presented area of the light source
			 * are not chosen.  This helps avoid shooting at points
			 * on the light source which machine floating-point
			 * inaccuracies would cause the ray to miss.
			 */
#define COSINE89_99DEG 0.0001745329

			VisRayvsSurfN
			    = VDOT(los->swp->sw_hit.hit_normal, dir);
			VisRayvsLightN
			    = VDOT(lpt->lp_norm, rdir);

			if ( VisRayvsLightN > COSINE89_99DEG &&
			     ( VEQUAL(lpt->lp_norm, zero) ||
			       VisRayvsSurfN > COSINE89_99DEG ) ) {

				/* ok, we can shoot at this sample point */
				if (rdebug & RDEBUG_LIGHT ) 
					bu_log("\tPt %d selected... OK normal %g %g %g\n",
					       k, V3ARGS(lpt->lp_norm));

				flags[k] |= VF_SEEN;

				goto done;
			}
#undef COSINE89DEG
			if (rdebug & RDEBUG_LIGHT ) 
				bu_log("\tbackfacing\n");
			/* the sample point is backfacing to the location
			 * we want to test from
			 */
			flags[k] |= VF_BACKFACE;
		}

		/* if we get here, then everything is used or backfacing */

		if (rdebug & RDEBUG_LIGHT ) {
			bu_log("all light sample pts used.  trying to recycle\n");
		}

		tryagain = 0;
		for (k=0 ; k < los->lsp->lt_pt_count ; k++) {
			if (flags[k] & VF_SEEN ) {
				/* this one was used, we can re-use it */
				tryagain = 1; 
				flags[k] &= VF_BACKFACE;
			}
		}
		if (tryagain) {
			if (rdebug & RDEBUG_LIGHT ) {
				bu_log("recycling\n");
			}
			goto reusept;
		}
		/* at this point, we have no candidate points available to 
		 * shoot at
		 */
		if (rdebug & RDEBUG_LIGHT ) {
			bu_log("can't find point to shoot at\n");
		}
		return 0;
	done:
		/* we've got a point on the surface of the light to shoot at */
		VMOVE(shoot_pt, lpt->lp_pt);
		VSUB2(shoot_dir, shoot_pt, los->swp->sw_hit.hit_point);
		
	} else {

		if (rdebug & RDEBUG_LIGHT ) 
			bu_log("shooting at approximating sphere\n");
		/* We're going to shoot at a point on the apporximating
		 * sphere for the light source.  We pick a point on the 
		 * circle (presented area) for the light source from this
		 * angle.  This is done by picking random radius and angle 
		 * values on the disc.
		 */
		radius = los->lsp->lt_radius * 
		/*			drand48(); */
			fabs(bn_rand_half(los->ap->a_resource->re_randptr) 
			     * 2.0);
		angle =  M_PI * 2.0 * 
		/*			drand48(); */
			(bn_rand_half(los->ap->a_resource->re_randptr) + 0.5);

		y = radius * bn_tab_sin(angle);

		/* by adding 90 degrees to the angle, the sin of the new
		 * angle becomes the cosine of the old angle.  Thus we
		 * can use the sine table to compute the value, and avoid
		 * the expensive actual computation.  So the next 3 lines
		 * replace:
		 *		x = radius * cos(angle);
		 */
		cos_angle = M_PI_2 + angle;
		if (cos_angle > (2.0*M_PI)) cos_angle -= (2.0*M_PI);
		x = radius * bn_tab_sin(cos_angle);

		VJOIN2(shoot_pt, los->lsp->lt_pos, 
		       x, los->light_x,
		       y, los->light_y);

		if (rdebug & RDEBUG_LIGHT) {
			bu_log("light at (%g %g %g) radius %g\n", 
			       V3ARGS(los->lsp->lt_pos), 
			       los->lsp->lt_radius);

			bu_log("\tshooting at radius %g\n", radius);

			bu_log("\ttarget light point %g %g %g\n",
			       V3ARGS(shoot_pt));
		}
		VSUB2(shoot_dir, shoot_pt, los->swp->sw_hit.hit_point);

	}

	if (rdebug & RDEBUG_LIGHT) {
		VPRINT("shoot_dir", shoot_dir);
	}


	if (rdebug& RDEBUG_RAYPLOT) {
		point_t ray_endpt;

 /* Yelow -- light visibility ray */
		VADD2(ray_endpt, los->swp->sw_hit.hit_point, shoot_dir);
		bu_semaphore_acquire( BU_SEM_SYSCALL );
		pl_color(stdout, 200, 200, 0);
		pdv_3line(stdout, los->swp->sw_hit.hit_point, ray_endpt);
		bu_semaphore_release( BU_SEM_SYSCALL );
	}

	VUNITIZE( shoot_dir );


	/*
	 * See if ray from hit point to light lies within light beam
	 * Note: this is should always be true for infinite lights!
	 */
	if (-VDOT(shoot_dir, los->lsp->lt_aim) < los->lsp->lt_cosangle )  {
		/* dark (outside of light beam) */
		if (rdebug & RDEBUG_LIGHT)
			bu_log("point outside beam, obscured: %s\n",
			       los->lsp->lt_name);
		return 0;
	}


	if (!(los->lsp->lt_shadows) )  {
	       /* "fill light" in beam, don't care about shadows */
		if (rdebug & RDEBUG_LIGHT)
			bu_log("fill light, no shadow, visible: %s\n",
			       los->lsp->lt_name);
#if RT_MULTISPECTRAL
		/* XXX Need a power level for this! */
		bn_tabdata_constval( ((struct bn_tabdata *)los->inten), 1.0);
#else
		VSETALL( ((vectp_t)los->inten), 1 );
#endif

		return -1;
	}



	/*
	 *  Fire ray at light source to check for shadowing.
	 *  (This SHOULD actually return an energy spectrum).
	 *  Advance start point slightly off surface.
	 */
	sub_ap = *los->ap;			/* struct copy */
	RT_CK_AP(&sub_ap);

	VMOVE( sub_ap.a_ray.r_dir, shoot_dir );
	{
		register fastf_t f;
		f = los->ap->a_rt_i->rti_tol.dist;
		VJOIN1( sub_ap.a_ray.r_pt, los->swp->sw_hit.hit_point, f, 
			shoot_dir);
	}
	sub_ap.a_rbeam = los->ap->a_rbeam + 
		los->swp->sw_hit.hit_dist * 
		los->ap->a_diverge;
	sub_ap.a_diverge = los->ap->a_diverge;

	sub_ap.a_hit = light_hit;
	sub_ap.a_miss = light_miss;
	sub_ap.a_user = -1;		/* sanity */
	sub_ap.a_uptr = (genptr_t)los->lsp;	/* so we can tell.. */
	sub_ap.a_level = 0;
	/* Will need entry & exit pts, for filter glass ==> 2 */
	/* Continue going through air ==> negative */
	sub_ap.a_onehit = -2;

	VSETALL( sub_ap.a_color, 1 );	/* vis intens so far */
	sub_ap.a_purpose = los->lsp->lt_name;	/* name of light shot at */

	RT_CK_LIGHT((struct light_specific *)(sub_ap.a_uptr));
	RT_CK_AP(&sub_ap);

	if (rdebug & RDEBUG_LIGHT)
		bu_log("shooting level %d from %d\n",
		       sub_ap.a_level, __LINE__);
	shot_status = rt_shootray( &sub_ap );
	if (rdebug & RDEBUG_LIGHT)
		bu_log("shot_status: %d\n", shot_status);

	if (shot_status < 0) {
		if (los->lsp->lt_infinite) {
		}  else if (los->lsp->lt_pt_count > 0) {
			if (rdebug & RDEBUG_LIGHT) {
				bu_log("was pt %d\n (%g %g %g) normal %g %g %g\n", k,
				       V3ARGS(los->lsp->lt_sample_pts[k].lp_pt),
				       V3ARGS(los->lsp->lt_sample_pts[k].lp_norm) );
			}
		} else {
			if (rdebug & RDEBUG_LIGHT) {
				bu_log("was radius: %g of (%g) angle: %g\n",
				       radius, los->lsp->lt_radius, angle);

				bu_log("re-shooting\n");
			}
			goto retry;
		}
	}

	if (shot_status > 0 )  {
		/* light visible */
		if (rdebug & RDEBUG_LIGHT)
			bu_log("light visible: %s\n", los->lsp->lt_name);

#if RT_MULTISPECTRAL
		BN_CK_TABDATA(sub_ap.a_spectrum);
		if (*(los->inten) == BN_TABDATA_NULL) {
			*(los->inten) = sub_ap.a_spectrum;
		} else {
			BN_CK_TABDATA(*(los->inten));
			bn_tabdata_add(*(los->inten),
				       *(los->inten),
				       sub_ap.a_spectrum);

			bn_tabdata_free(sub_ap.a_spectrum);
		}
		sub_ap.a_spectrum = BN_TABDATA_NULL;
#else
		VMOVE( los->inten, sub_ap.a_color );
#endif
		return 1;
	}
	/* dark (light obscured) */
	if (rdebug & RDEBUG_LIGHT)
		bu_log("light obscured: %s\n", los->lsp->lt_name);

	return 0;
}

/*
 *			L I G H T _ O B S C U R A T I O N
 *
 *	Determine the visibility of each light source in the scene from a
 *	particular location.
 *	It is up to the caller to apply sw_lightfract[] to lp_color, etc.
 *
 *	Sets 
 *	swp:	sw_tolight[]
 *		sw_intensity[]  or msw_intensity[]
 *		sw_visible[]
 *		sw_lightfract[]
 *
 *	References
 *	ap:	a_resource
 *		a_rti_i->rti_tol
 *		a_rbeam
 *		a_diverge
 */
void
light_obs(struct application *ap, struct shadework *swp, int have)
{
	register struct light_specific *lsp;
	register int	i;
	register fastf_t *tl_p;
	int vis_ray;
	int tot_vis_rays;
	int visibility;
	struct light_obs_stuff los;
	static int rand_idx;
	char flags[MAX_LIGHT_SAMPLES];

	if (rdebug & RDEBUG_LIGHT )
		bu_log("computing Light obscuration: start\n");

	RT_CK_AP(ap);
	los.rand_idx = &rand_idx;
	los.ap = ap;
	los.swp = swp;

	/*
	 *  Determine light visibility
	 *
	 *  The sw_intensity field does NOT include the light's
	 *  emission spectrum (color), only path attenuation.
	 *  sw_intensity=(1,1,1) for no attenuation.
	 */
	tl_p = swp->sw_tolight;

	i = 0;
	for( BU_LIST_FOR( lsp, light_specific, &(LightHead.l) ) )  {
		RT_CK_LIGHT(lsp);

		if (rdebug & RDEBUG_LIGHT)
			bu_log("computing for light %d\n", i);
		swp->sw_lightfract[i] = 0.0;

		if (lsp->lt_infinite || lsp->lt_shadows == 0) tot_vis_rays = 1;
		else			tot_vis_rays = lsp->lt_shadows;

		los.lsp = lsp;
#if RT_MULTISPECTRAL
		if(swp->msw_intensity[i]) BN_CK_TABDATA(swp->msw_intensity[i]);
		los.inten = &swp->msw_intensity[i];
#else
		los.inten = &swp->sw_intensity[3*i];
#endif

		/* create a coordinate system about the light center
		 * with the hitpoint->light ray as one of the axes
		 */
		VSUB2(los.to_light_center, lsp->lt_pos, swp->sw_hit.hit_point);

		VUNITIZE(los.to_light_center);
		bn_vec_ortho( los.light_x, los.to_light_center);
		VCROSS(los.light_y, los.to_light_center, los.light_x);

		/*
		 *  If we have a normal, test against light direction
		 */
		if ((have & MFI_NORMAL) && (swp->sw_transmit <= 0) )  {
			if (VDOT(swp->sw_hit.hit_normal,
				 los.to_light_center)      < 0 ) {
				/* backfacing, opaque */
				if (rdebug & RDEBUG_LIGHT)
				    bu_log("norm backfacing, opaque surf:%s\n",
					   lsp->lt_name);
				continue;
			}
		}

		visibility = 0;
		memset(flags, 0, sizeof(flags));
		for (vis_ray = 0 ; vis_ray < tot_vis_rays ; vis_ray ++) {
			int lv;
			los.iter = vis_ray;

			if (rdebug & RDEBUG_LIGHT)
				bu_log("----------vis_ray %d---------\n",
				       vis_ray);

			switch (lv = light_vis(&los, flags)) {
			case 1:
				/* remember the last ray that hit */
				VMOVE(tl_p, los.to_light_center);
				visibility++;
				break;
			case -1:
				/* this is our clue to give up on
				 * this light source.  Probably an infinite
				 * point light source.
				 */
				VMOVE(tl_p, los.to_light_center);
				visibility = vis_ray = tot_vis_rays;
				break;
			case -2:
				visibility = 0;
				vis_ray = tot_vis_rays;
				break;
			case 0:	/* light not visible */
				if (rdebug & RDEBUG_LIGHT)
					bu_log("light not visible\n");
				break;
			default:
				bu_log("light_vis = %d\n", lv);
			}
		}
		if (visibility) {
			swp->sw_visible[i] = (char *)lsp;
			swp->sw_lightfract[i] =
				(fastf_t)visibility / (fastf_t)tot_vis_rays;
		} else {
			swp->sw_visible[i] = (char *)0;
		}

		/* Advance to next light */
		tl_p += 3;
		i++;
	}

	if (rdebug & RDEBUG_LIGHT ) bu_log("computing Light obscruration: end\n");
}

@


11.86
log
@change conf.h to a wrapped config.h
@
text
@d23 1
a23 1
static const char RCSsh_light[] = "@@(#)$Header: /cvs/brlcad/liboptical/sh_light.c,v 11.85 2004/04/05 07:43:37 morrison Exp $ (ARL)";
@


11.85
log
@merge of ansi-6-0-branch into HEAD
@
text
@d23 1
a23 1
static const char RCSsh_light[] = "@@(#)$Header$ (ARL)";
d26 5
a30 1
#include "conf.h"
@


11.84
log
@merge of windows-6-0-branch into head
@
text
@d73 5
a77 5
light_cvt_visible( sdp, name, base, value )
register const struct bu_structparse	*sdp;	/* structure description */
register const char			*name;	/* struct member name */
char					*base;	/* begining of structure */
const char				*value;	/* string containing value */
d101 5
a105 5
light_pt_set( sdp, name, base, value )
register const struct bu_structparse	*sdp;	/* structure description */
register const char			*name;	/* struct member name */
char					*base;	/* begining of structure */
const char				*value;	/* string containing value */
d177 3
a179 3
HIDDEN int	light_setup(), light_render();
HIDDEN void	light_print();
void		light_free();
d218 1
a218 5
HIDDEN void aim_set (sdp, name, base, value)
const struct bu_structparse *sdp;
const char *name;
const char *base;
char *value;
d239 1
a239 5
light_render( ap, pp, swp, dp )
struct application	*ap;
struct partition	*pp;
struct shadework	*swp;
char	*dp;
d743 1
a743 3
light_print( rp, dp )
register struct region *rp;
char	*dp;
d752 1
a752 2
light_free( cp )
char *cp;
d942 1
a942 1
light_cleanup()
a986 1
#ifndef WIN32
d988 1
a988 11
light_hit(ap, PartHeadp, finished_segs )
struct application *ap;
struct partition *PartHeadp;
struct seg *finished_segs;
#else
int
light_hit(
struct application *ap,
struct partition *PartHeadp,
struct seg *finished_segs)
#endif
d995 1
a995 1
	extern int	light_render();
a1340 5
#ifndef WIN32
int
light_miss(ap)
register struct application *ap;
#else
a1342 1
#endif
d1376 1
a1376 3
light_vis(los, flags)
struct light_obs_stuff *los;
char flags[MAX_LIGHT_SAMPLES];
d1724 1
a1724 4
light_obs(ap, swp, have)
struct application *ap;
struct shadework *swp;
int have;
@


11.83
log
@cannot be extern and static
@
text
@d23 1
a23 1
static const char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.82 2004/02/02 17:39:14 morrison Exp $ (ARL)";
d998 1
d1004 7
d1363 1
d1367 4
@


11.82
log
@update copyright to include span through 2003
@
text
@d23 1
a23 1
static const char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.81 2003/09/27 01:05:10 morrison Exp $ (ARL)";
d63 1
a63 1
RT_EXTERN(HIDDEN void	aim_set, (const struct bu_structparse *sdp, const char *name,
@


11.81
log
@mlib stub functions moved from rt back-end and are no longer extern; use the r_debug define
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1998 by the United States Army
d23 1
a23 1
static const char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.80 2003/08/27 19:29:40 justin Exp $ (ARL)";
@


11.81.2.1
log
@merge from HEAD
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1998-2004 by the United States Army
d23 1
a23 1
static const char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.82 2004/02/02 17:39:14 morrison Exp $ (ARL)";
@


11.81.2.2
log
@merge from head
@
text
@d23 1
a23 1
static const char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.83 2004/03/03 21:33:53 morrison Exp $ (ARL)";
d63 1
a63 1
RT_EXTERN(void	aim_set, (const struct bu_structparse *sdp, const char *name,
@


11.81.2.3
log
@merge from head
@
text
@d23 1
a23 1
static const char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.81.2.2 2004/03/10 13:20:29 erikg Exp $ (ARL)";
@


11.81.2.4
log
@merge from head
@
text
@d23 1
a23 1
static const char RCSsh_light[] = "@@(#)$Header$ (ARL)";
a997 1
#ifndef WIN32
a1002 7
#else
int
light_hit(
struct application *ap,
struct partition *PartHeadp,
struct seg *finished_segs)
#endif
a1354 1
#ifndef WIN32
a1357 4
#else
int
light_miss(register struct application *ap)
#endif
@


11.80
log
@Updated default lumens from 1000.0 to 1.0.
@
text
@d23 1
a23 1
static const char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.79 2003/08/27 19:17:51 justin Exp $ (ARL)";
d916 1
a916 1
	if (rt_verbosity & VERBOSE_LIGHTINFO) {
@


11.80.2.1
log
@enhancements to photon mapping for sphere invalidation, enhanced phong model
with better ambient light handling, added attenuation to light sources.
@
text
@d23 1
a23 1
static const char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.80 2003/08/27 19:29:40 justin Exp $ (ARL)";
a133 1
{"%d",	1, "attenuation",LIGHT_O(lt_attenuation),BU_STRUCTPARSE_FUNC_NULL },
a157 2
{"%d",	1, "t",		LIGHT_O(lt_attenuation),BU_STRUCTPARSE_FUNC_NULL },

a627 1
	lsp->lt_attenuation = 0;	/* light attenuates over distance */
@


11.80.2.2
log
@Fixed attenuation for light sources
@
text
@d23 1
a23 1
static const char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.80.2.1 2003/09/10 22:08:27 butler Exp $ (ARL)";
d159 1
a159 1
{"%d",	1, "atten",	LIGHT_O(lt_attenuation),BU_STRUCTPARSE_FUNC_NULL },
a636 4

	if (rdebug & RDEBUG_LIGHT ) {
	    bu_log("light parameters: \"%S\"\n", matparm);
	}
@


11.79
log
@The nuts and bolts of photon mapping.
@
text
@d23 1
a23 1
static const char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.77.2.3 2003/08/26 14:03:31 justin Exp $ (ARL)";
d621 1
a621 1
	lsp->lt_intensity = 1000.0;	/* Lumens */
@


11.78
log
@Light rays now take into account procedural shaders which vary the
transmission programatically.  Clouds should now have better shadows.
@
text
@d23 1
a23 1
static const char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.77 2003/04/16 13:35:17 jra Exp $ (ARL)";
d42 1
d280 3
a282 1
	VSCALE( swp->sw_color, lsp->lt_color, f );
d838 1
a838 1
		lsp->lt_intensity = 1000.0;
@


11.77
log
@light_vis() was retrying points on the light surface in an infinite loop.
Just needed "tryagain" to be initialized to zero
@
text
@d23 1
a23 1
static const char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.76 2003/04/07 17:54:08 jra Exp $ (ARL)";
d1014 1
d1224 3
d1228 3
a1230 1
	    (regp->reg_transmit == 0 /* XXX && Not procedural shader */) )  {
@


11.77.2.1
log
@light update with new default lumens
@
text
@d23 1
a23 1
static const char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.77 2003/04/16 13:35:17 jra Exp $ (ARL)";
d835 1
a835 1
		lsp->lt_intensity = 1.0;
@


11.77.2.2
log
@for photon mapping light doesn't get shaded
@
text
@d23 1
a23 1
static const char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.77.2.1 2003/08/12 22:53:40 justin Exp $ (ARL)";
a41 1
#include "photonmap.h"
d279 1
a279 3
	if (!PM_Activated) {
	  VSCALE( swp->sw_color, lsp->lt_color, f );
	}
@


11.77.2.3
log
@updated for merging
@
text
@d23 1
a23 1
static const char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.77.2.2 2003/08/15 04:19:01 justin Exp $ (ARL)";
a1016 1
	int 	is_proc;
a1225 3
	is_proc = ((struct mfuncs *)regp->reg_mfuncs)->mf_flags|MFF_PROC;


d1227 1
a1227 3
	    (regp->reg_transmit == 0 &&
	     ! is_proc /* procedural shader */) ) {

@


11.76
log
@light_setup() now returns code 2 for invisible lights. The new code means
do not delete the light right now, but put it on rt_i's "delete_regs" list
for processing later.

Also moved some debug prints into debug blocks
@
text
@d23 1
a23 1
static const char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.75 2003/01/31 21:45:37 jra Exp $ (ARL)";
d1497 1
@


11.75
log
@Default lights are now all white
@
text
@d23 1
a23 1
static const char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.74 2002/08/20 17:07:51 jra Exp $ (ARL)";
d737 1
a737 3
		lsp->lt_rp = REGION_NULL;
		/* Note that *dpp (reg_udata) is left null */
		return(0);	/* don't show light, destroy it */
d907 1
a907 2
		if (lsp->lt_visible && 
		    lsp->lt_shadows > 1 && 
d1359 6
a1364 4
	bu_log("light ray missed non-infinite, visible light source\n");
	bu_log("on pixel: %d %d\n", ap->a_x, ap->a_y);
	bu_log("ray: (%g %g %g) -> %g %g %g\n", V3ARGS(ap->a_ray.r_pt), V3ARGS(ap->a_ray.r_dir) );
	bu_log("a_level: %d\n", ap->a_level);
d1493 3
a1495 1
		bu_log("all light sample pts used.  trying to recycle\n");
d1505 3
a1507 1
			bu_log("recycling\n");
d1513 3
a1515 1
		bu_log("can't find point to shoot at\n");
d1665 5
a1669 3
			bu_log("was pt %d\n (%g %g %g) normal %g %g %g\n", k,
			       V3ARGS(los->lsp->lt_sample_pts[k].lp_pt),
			       V3ARGS(los->lsp->lt_sample_pts[k].lp_norm) );
d1671 3
a1673 2
			bu_log("was radius: %g of (%g) angle: %g\n",
			       radius, los->lsp->lt_radius, angle);
d1675 2
a1676 1
			bu_log("re-shooting\n");
@


11.74
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d23 1
a23 1
static const char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.72 2002/07/16 19:38:38 morrison Exp $ (ARL)";
d803 1
a803 1
			VSET( color,  1, .1, .1 );	/* Red-ish */
d809 1
a809 1
			VSET( color, .1, .1,  1 );	/* Blue-ish */
@


11.74.4.1
log
@Modifications (on a 6.0 source distribution) for initial port to windows (merged with sources close to 6.0.2)
@
text
@d23 1
a23 1
static const char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.74 2002/08/20 17:07:51 jra Exp $ (ARL)";
a997 1
#ifndef WIN32
a1002 7
#else
int
light_hit(
struct application *ap,
struct partition *PartHeadp,
struct seg *finished_segs)
#endif
a1348 1
#ifndef WIN32
a1351 4
#else
int
light_miss(register struct application *ap)
#endif
@


11.74.4.2
log
@sync to HEAD...
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1998-2004 by the United States Army
d23 1
a23 1
static const char RCSsh_light[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/liboptical/sh_light.c,v 11.74.4.1 2002/09/26 23:03:59 morrison Exp $ (ARL)";
a41 1
#include "photonmap.h"
d62 1
a62 1
RT_EXTERN(void	aim_set, (const struct bu_structparse *sdp, const char *name,
d279 1
a279 3
	if (!PM_Activated) {
	  VSCALE( swp->sw_color, lsp->lt_color, f );
	}
d618 1
a618 1
	lsp->lt_intensity = 1.0;	/* Lumens */
d737 3
a739 1
		return(2);	/* don't show light, destroy it later */
d803 1
a803 1
			VSET( color,  1, 1, 1 );
d809 1
a809 1
			VSET( color, 1, 1,  1 );
d837 1
a837 1
		lsp->lt_intensity = 1.0;
d909 2
a910 1
		if (lsp->lt_shadows > 1 && 
d916 1
a916 1
	if (R_DEBUG) {
a1024 1
	int 	is_proc;
a1233 3
	is_proc = ((struct mfuncs *)regp->reg_mfuncs)->mf_flags|MFF_PROC;


d1235 1
a1235 3
	    (regp->reg_transmit == 0 &&
	     ! is_proc /* procedural shader */) ) {

d1375 4
a1378 6
	if (rdebug & RDEBUG_LIGHT) {
		bu_log("light ray missed non-infinite, visible light source\n");
		bu_log("on pixel: %d %d\n", ap->a_x, ap->a_y);
		bu_log("ray: (%g %g %g) -> %g %g %g\n", V3ARGS(ap->a_ray.r_pt), V3ARGS(ap->a_ray.r_dir) );
		bu_log("a_level: %d\n", ap->a_level);
	}
d1507 1
a1507 3
		if (rdebug & RDEBUG_LIGHT ) {
			bu_log("all light sample pts used.  trying to recycle\n");
		}
a1508 1
		tryagain = 0;
d1517 1
a1517 3
			if (rdebug & RDEBUG_LIGHT ) {
				bu_log("recycling\n");
			}
d1523 1
a1523 3
		if (rdebug & RDEBUG_LIGHT ) {
			bu_log("can't find point to shoot at\n");
		}
d1673 3
a1675 5
			if (rdebug & RDEBUG_LIGHT) {
				bu_log("was pt %d\n (%g %g %g) normal %g %g %g\n", k,
				       V3ARGS(los->lsp->lt_sample_pts[k].lp_pt),
				       V3ARGS(los->lsp->lt_sample_pts[k].lp_norm) );
			}
d1677 2
a1678 3
			if (rdebug & RDEBUG_LIGHT) {
				bu_log("was radius: %g of (%g) angle: %g\n",
				       radius, los->lsp->lt_radius, angle);
d1680 1
a1680 2
				bu_log("re-shooting\n");
			}
@


11.74.2.1
log
@Initial ANSIfication
@
text
@d23 1
a23 1
static const char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.74 2002/08/20 17:07:51 jra Exp $ (ARL)";
d72 5
a76 5
light_cvt_visible(register const struct bu_structparse *sdp, register const char *name, char *base, const char *value)
                                    	     	/* structure description */
                   			      	/* struct member name */
    					      	/* begining of structure */
          				       	/* string containing value */
d100 5
a104 5
light_pt_set(register const struct bu_structparse *sdp, register const char *name, char *base, const char *value)
                                    	     	/* structure description */
                   			      	/* struct member name */
    					      	/* begining of structure */
          				       	/* string containing value */
d176 3
a178 3
HIDDEN int	light_setup(register struct region *rp, struct bu_vls *matparm, genptr_t *dpp, struct mfuncs *mfp, struct rt_i *rtip), light_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
HIDDEN void	light_print(register struct region *rp, char *dp);
void		light_free(char *cp);
d217 5
a221 1
HIDDEN void aim_set (const struct bu_structparse *sdp, const char *name, const char *base, char *value)
d242 5
a246 1
light_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
d750 3
a752 1
light_print(register struct region *rp, char *dp)
d761 2
a762 1
light_free(char *cp)
d953 1
a953 1
light_cleanup(void)
d999 4
a1002 1
light_hit(struct application *ap, struct partition *PartHeadp, struct seg *finished_segs)
d1009 1
a1009 1
	extern int	light_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
d1350 2
a1351 1
light_miss(register struct application *ap)
d1383 3
a1385 1
light_vis(struct light_obs_stuff *los, char *flags)
d1722 4
a1725 1
light_obs(struct application *ap, struct shadework *swp, int have)
@


11.74.2.2
log
@sync branch with HEAD
@
text
@d19 1
a19 1
 *	This software is Copyright (C) 1998-2004 by the United States Army
d23 1
a23 1
static const char RCSsh_light[] = "@@(#)$Header$ (ARL)";
a41 1
#include "photonmap.h"
d62 1
a62 1
RT_EXTERN(void	aim_set, (const struct bu_structparse *sdp, const char *name,
d271 1
a271 3
	if (!PM_Activated) {
	  VSCALE( swp->sw_color, lsp->lt_color, f );
	}
d610 1
a610 1
	lsp->lt_intensity = 1.0;	/* Lumens */
d729 3
a731 1
		return(2);	/* don't show light, destroy it later */
d792 1
a792 1
			VSET( color,  1, 1, 1 );
d798 1
a798 1
			VSET( color, 1, 1,  1 );
d826 1
a826 1
		lsp->lt_intensity = 1.0;
d898 2
a899 1
		if (lsp->lt_shadows > 1 && 
d905 1
a905 1
	if (R_DEBUG) {
a1002 1
	int 	is_proc;
a1211 3
	is_proc = ((struct mfuncs *)regp->reg_mfuncs)->mf_flags|MFF_PROC;


d1213 1
a1213 3
	    (regp->reg_transmit == 0 &&
	     ! is_proc /* procedural shader */) ) {

d1347 4
a1350 6
	if (rdebug & RDEBUG_LIGHT) {
		bu_log("light ray missed non-infinite, visible light source\n");
		bu_log("on pixel: %d %d\n", ap->a_x, ap->a_y);
		bu_log("ray: (%g %g %g) -> %g %g %g\n", V3ARGS(ap->a_ray.r_pt), V3ARGS(ap->a_ray.r_dir) );
		bu_log("a_level: %d\n", ap->a_level);
	}
d1477 1
a1477 3
		if (rdebug & RDEBUG_LIGHT ) {
			bu_log("all light sample pts used.  trying to recycle\n");
		}
a1478 1
		tryagain = 0;
d1487 1
a1487 3
			if (rdebug & RDEBUG_LIGHT ) {
				bu_log("recycling\n");
			}
d1493 1
a1493 3
		if (rdebug & RDEBUG_LIGHT ) {
			bu_log("can't find point to shoot at\n");
		}
d1643 3
a1645 5
			if (rdebug & RDEBUG_LIGHT) {
				bu_log("was pt %d\n (%g %g %g) normal %g %g %g\n", k,
				       V3ARGS(los->lsp->lt_sample_pts[k].lp_pt),
				       V3ARGS(los->lsp->lt_sample_pts[k].lp_norm) );
			}
d1647 2
a1648 3
			if (rdebug & RDEBUG_LIGHT) {
				bu_log("was radius: %g of (%g) angle: %g\n",
				       radius, los->lsp->lt_radius, angle);
d1650 1
a1650 2
				bu_log("re-shooting\n");
			}
@


11.73
log
@Converted from K&R to ANSI C - RFH
@
text
@d72 5
a76 5
light_cvt_visible(register const struct bu_structparse *sdp, register const char *name, char *base, const char *value)
                                    	     	/* structure description */
                   			      	/* struct member name */
    					      	/* begining of structure */
          				       	/* string containing value */
d100 5
a104 5
light_pt_set(register const struct bu_structparse *sdp, register const char *name, char *base, const char *value)
                                    	     	/* structure description */
                   			      	/* struct member name */
    					      	/* begining of structure */
          				       	/* string containing value */
d176 3
a178 3
HIDDEN int	light_setup(register struct region *rp, struct bu_vls *matparm, genptr_t *dpp, struct mfuncs *mfp, struct rt_i *rtip), light_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
HIDDEN void	light_print(register struct region *rp, char *dp);
void		light_free(char *cp);
d217 5
a221 1
HIDDEN void aim_set (const struct bu_structparse *sdp, const char *name, const char *base, char *value)
d242 5
a246 1
light_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
d750 3
a752 1
light_print(register struct region *rp, char *dp)
d761 2
a762 1
light_free(char *cp)
d953 1
a953 1
light_cleanup(void)
d999 4
a1002 1
light_hit(struct application *ap, struct partition *PartHeadp, struct seg *finished_segs)
d1009 1
a1009 1
	extern int	light_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
d1350 2
a1351 1
light_miss(register struct application *ap)
d1383 3
a1385 1
light_vis(struct light_obs_stuff *los, char *flags)
d1722 4
a1725 1
light_obs(struct application *ap, struct shadework *swp, int have)
@


11.72
log
@Moved the non-local-only header file (light.h) from rt/ into the header directory since it is used by multiple targets (liboptical, rt, etc)
@
text
@d23 1
a23 1
static const char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.71 2002/07/02 18:46:35 jra Exp $ (ARL)";
d72 5
a76 5
light_cvt_visible( sdp, name, base, value )
register const struct bu_structparse	*sdp;	/* structure description */
register const char			*name;	/* struct member name */
char					*base;	/* begining of structure */
const char				*value;	/* string containing value */
d100 5
a104 5
light_pt_set( sdp, name, base, value )
register const struct bu_structparse	*sdp;	/* structure description */
register const char			*name;	/* struct member name */
char					*base;	/* begining of structure */
const char				*value;	/* string containing value */
d176 3
a178 3
HIDDEN int	light_setup(), light_render();
HIDDEN void	light_print();
void		light_free();
d217 1
a217 5
HIDDEN void aim_set (sdp, name, base, value)
const struct bu_structparse *sdp;
const char *name;
const char *base;
char *value;
d238 1
a238 5
light_render( ap, pp, swp, dp )
struct application	*ap;
struct partition	*pp;
struct shadework	*swp;
char	*dp;
d742 1
a742 3
light_print( rp, dp )
register struct region *rp;
char	*dp;
d751 1
a751 2
light_free( cp )
char *cp;
d942 1
a942 1
light_cleanup()
d988 1
a988 4
light_hit(ap, PartHeadp, finished_segs )
struct application *ap;
struct partition *PartHeadp;
struct seg *finished_segs;
d995 1
a995 1
	extern int	light_render();
d1336 1
a1336 2
light_miss(ap)
register struct application *ap;
d1368 1
a1368 3
light_vis(los, flags)
struct light_obs_stuff *los;
char flags[MAX_LIGHT_SAMPLES];
d1705 1
a1705 4
light_obs(ap, swp, have)
struct application *ap;
struct shadework *swp;
int have;
@


11.71
log
@Debugging statement now in conditional
@
text
@d23 1
a23 1
static const char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.70 2002/06/11 19:48:14 butler Exp $ (ARL)";
d41 1
a41 1
#include "../rt/light.h"
@


11.70
log
@Fixed problem where light sample points on edge of light were missed due to
floating point fuzz errors.
@
text
@d23 1
a23 1
static const char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.69 2001/05/16 21:37:56 morrison Exp $ (ARL)";
d1825 3
a1827 2
			    bu_log("light not visible\n");
			    break;
d1829 1
a1829 1
			    bu_log("light_vis = %d\n", lv);
@


11.69
log
@PRODUCTION optimizations
@
text
@d23 1
a23 1
static const char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.68 2001/04/20 22:29:32 morrison Exp $ (ARL)";
d835 1
d1399 2
d1452 10
d1463 10
a1472 3
			if ( VDOT(los->swp->sw_hit.hit_normal, dir) > 0.0 &&
			     ( VEQUAL(lpt->lp_norm, zero) || 
			       VDOT(lpt->lp_norm, rdir) > 0.0 )		) {
d1483 1
d1799 1
d1806 1
a1806 1
			switch (light_vis(&los, flags)) {
d1824 5
@


11.68
log
@CONST to const
@
text
@d23 1
a23 1
static const char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.67 2001/03/19 22:19:52 butler Exp $ (ARL)";
d1018 1
a1018 1
	bzero(&sw, sizeof(sw));		/* make sure nothing nasty on the stack */
@


11.67
log
@patches to merge 5.3 into 6.0
@
text
@d23 1
a23 1
static const char RCSsh_light[] = "@@(#)$Header: /d/CVS/brlcad/liboptical/sh_light.c,v 11.66 2000/10/24 00:03:44 butler Exp $ (ARL)";
d49 1
a49 1
	  register CONST struct partition *pp,
d62 2
a63 2
RT_EXTERN(HIDDEN void	aim_set, (CONST struct bu_structparse *sdp, CONST char *name,
CONST char *base, char *value));
d73 2
a74 2
register CONST struct bu_structparse	*sdp;	/* structure description */
register CONST char			*name;	/* struct member name */
d76 1
a76 1
CONST char				*value;	/* string containing value */
d101 2
a102 2
register CONST struct bu_structparse	*sdp;	/* structure description */
register CONST char			*name;	/* struct member name */
d104 1
a104 1
CONST char				*value;	/* string containing value */
d173 1
a173 1
extern CONST struct bn_table	*spectrum;	/* from rttherm/viewtherm.c */
d218 3
a220 3
CONST struct bu_structparse *sdp;
CONST char *name;
CONST char *base;
d1007 1
a1007 1
	CONST struct light_specific	*lsp;
@


11.66
log
@changed "dir" to "target" to better reflect actual function
@
text
@d23 1
a23 1
static const char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.65 2000/10/20 18:51:58 mike Exp $ (ARL)";
a1364 1

@


11.65
log
@
Parallel protection for plotting
@
text
@d23 1
a23 1
static const char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.64 2000/10/19 19:19:45 butler Exp $ (ARL)";
d128 1
a128 1
{"%f",	3, "dir",	LIGHT_OA(lt_dir),	aim_set },
d147 3
a149 3
{"%f",	3, "dir",	LIGHT_OA(lt_dir),	aim_set },
{"%f",	3, "d",		LIGHT_OA(lt_dir),	aim_set },
{"%f",	3, "aim",	LIGHT_OA(lt_dir),	aim_set },
d224 3
a226 1

d681 1
a681 1
			VSUB2 (work, lsp->lt_dir, lsp->lt_pos);
@


11.64
log
@Changes to compile under RedHat 7.0
@
text
@d23 1
a23 1
static const char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.63 2000/10/19 03:04:11 cjohnson Exp $ (ARL)";
d1553 2
a1555 1
		VADD2(ray_endpt, los->swp->sw_hit.hit_point, shoot_dir);
d1557 1
@


11.63
log
@shadwork structures must be initalized to zero before use.
@
text
@d23 1
a23 1
static const char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.62 2000/10/17 23:46:10 butler Exp $ (ARL)";
d43 4
d697 5
a701 2
		rt_spect_reflectance_rgb( lsp->lt_spectrum, rp->reg_mater.ma_color );
		/* XXX Need to convert units of lumens (candela-sr) to ?? mw/sr?  Use any old numbers to get started. */
d787 3
a789 1

d817 1
d819 2
a820 1
		rt_spect_reflectance_rgb( lsp->lt_spectrum, color );
d822 1
@


11.62
log
@Patches to fix specular light when no shadows present
@
text
@d23 1
a23 1
static const char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.61 2000/08/31 01:03:43 mike Exp $ (ARL)";
d1004 1
@


11.61
log
@
variable "span" is used before its value is set
@
text
@d23 1
a23 1
static const char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.60 2000/08/29 00:20:40 butler Exp $ (ARL)";
d29 3
d1725 1
a1725 1
		if (lsp->lt_infinite )	tot_vis_rays = 1;
@


11.60
log
@Fixed problem with invisible light sources
@
text
@d23 1
a23 1
static const char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.59 2000/08/23 05:09:07 butler Exp $ (ARL)";
a549 1
		bu_log("span %g %g %g\n", V3ARGS(span));
d557 3
@


11.59
log
@Compilation warning messages eliminated
Light sample point parsing added
@
text
@d23 1
a23 1
static const char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.58 2000/08/20 01:33:44 butler Exp $ (ARL)";
a70 1
	int *p = (int *)(base+sdp->sp_offset);
d73 6
a86 2
	/* reconvert with optional units */
	*p = !*p;
d125 1
d718 3
@


11.58
log
@A better fix to the problem of being backwards compatible
@
text
@d23 1
a23 1
static const char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.57 2000/08/20 01:27:48 butler Exp $ (ARL)";
d86 27
d150 3
d1361 3
a1363 1
	double radius, angle, cos_angle, x, y; 
d1368 2
a1369 1
	int idx, k;
d1383 1
d1415 12
a1426 2
			if (VDOT(los->swp->sw_hit.hit_normal, dir) > 0.0 &&
			    VDOT(lpt->lp_norm, rdir) > 0.0) {
d1471 1
d1609 8
a1616 3
		bu_log("was radius: %g of (%g) angle: %g\n",
			radius, los->lsp->lt_radius, 
			angle);
d1618 3
a1620 2
		bu_log("re-shooting\n");
		goto retry;
@


11.57
log
@Eliminate compilation warnings, enhancements to sh_light.c
@
text
@d23 1
a23 1
static const char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.56 2000/08/20 00:44:47 butler Exp $ (ARL)";
d852 3
a854 1
		if (lsp->lt_visible && lsp->lt_pt_count < 1)
d860 2
a861 1
		bu_log("Lighting: Ambient = %d%%\n", (int)(AmbientIntensity*100));
@


11.56
log
@Misc commpilation changes and enhancements to light shader
@
text
@d23 1
a23 1
static const char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.55 2000/08/16 01:26:54 mike Exp $ (ARL)";
d494 1
a494 2
	vect_t step, span;
	double mul = 0.25;
a511 2
	/* get extent in X, Y, Z */
	VSUB2(span, tree_max, tree_min);
a519 1
<<<<<<< sh_light.c
d523 1
d525 1
a525 1
		bu_log("impossibly small light\n");
a528 6
=======
>>>>>>> 11.55
	/* get extent in X, Y, Z */
	VSUB2(span, tree_max, tree_min);

<<<<<<< sh_light.c
a529 11
#if 0
=======
	/* For benchmarking, leave lt_pt_count = 0 */
	if( !benchmark )  while ( lsp->lt_pt_count < 5 ) {
>>>>>>> 11.55
		VSCALE(step, span, mul);

		/* if there is no space occupied by the light source, then
		 * just give up.  Prevents infinite loops.
		 */
		if (step[X] <= 0.0 && step[Y] <= 0.0 && step[Z] <= 0.0) break;
a530 3
		shoot_grids(&ap, step, tree_min, tree_max);
		mul *= 0.5;
#else
a532 1
#endif
d1129 19
@


11.55
log
@
Honor benchmark flag, produce the same results as always.
@
text
@d23 1
a23 1
static const char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.54 2000/08/16 01:06:30 mike Exp $ (ARL)";
d254 1
a254 1
	struct partition *pp;
d262 20
d292 21
d322 3
d339 1
d352 1
d373 2
d395 2
d414 2
d420 60
d488 1
a488 1
light_gen_sample_pts(struct rt_i            *rtip,
d504 1
a504 1
	ap.a_rt_i = rtip;
d513 4
a516 1
	if (rdebug & RDEBUG_LIGHT )
d519 3
d523 8
d532 2
d537 4
d543 1
d553 4
d568 1
a568 1
			VJOIN1(p, lpt->lp_pt, 10.0, lpt->lp_norm);
d877 1
a877 1
			light_gen_sample_pts(ap->a_rt_i, lsp);
@


11.54
log
@
Changed hard-wired tolerance in light point selection,
so that moss.g doesn't fail to select points.
@
text
@d23 1
a23 1
static const char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.53 2000/08/16 00:55:37 mike Exp $ (ARL)";
d409 2
a410 1
	while ( lsp->lt_pt_count < 5 ) {
@


11.53
log
@
Added code to prevent infinite loop on moss.g
@
text
@d23 1
a23 1
static const char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.52 2000/08/15 02:06:38 mike Exp $ (ARL)";
d312 1
d314 1
a314 1
	if (step[Y] > 10.0 && step[X] > 10.0) {
d334 1
a334 1
	if (step[Z] > 10.0 && step[X] > 10.0) {
d353 1
a353 1
	if (step[Z] > 10.0 && step[Y] > 10.0) {
@


11.52
log
@
Variable 'span' was used before value was set.
@
text
@d23 1
a23 1
static const char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.51 2000/07/31 02:02:42 butler Exp $ (ARL)";
d309 1
a309 1
		bu_log("shoot_grids Z\n");
d384 2
d387 1
a387 1
		bu_log("light_gen_sample_pts\n");
a407 5
	/* if there is no space occupied by the light source, then
	 * just give up
	 */
	if (span[X] <= 0.0 && span[Y] <= 0.0 && span[Z] <= 0.0) return;

d410 6
@


11.51
log
@New approach to light sample points that gives points actually on the light.
@
text
@d23 1
a23 1
static char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.50 2000/07/25 16:40:38 butler Exp $ (ARL)";
d403 3
a409 3

	/* get extent in X, Y, Z */
	VSUB2(span, tree_max, tree_min);
@


11.50
log
@Changes to use rtprivate.h instead of ../rt/rdebug.h
@
text
@d23 1
a23 1
static char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.49 2000/04/13 13:34:38 mike Exp $ (ARL)";
d72 1
a72 1
	struct light_specific *lp = (struct light_specific *)base;
d76 1
a76 1
		lp->lt_visible = !lp->lt_invisible;
d79 1
a79 1
		lp->lt_invisible = !lp->lt_visible;
d148 22
d182 1
a182 2
	register struct light_specific *lp =
	(struct light_specific *)base;
d184 1
a184 1
	lp->lt_exaim = 1;
d205 1
a205 2
	register struct light_specific *lp =
	(struct light_specific *)dp;
d208 1
a208 1
	RT_CK_LIGHT(lp);
d215 1
a215 1
	if (VDOT( lp->lt_aim, swp->sw_hit.hit_normal) < lp->lt_cosangle )  {
d217 1
a217 1
		f *= lp->lt_fraction;
d220 1
a220 1
		f = (f+0.5) * lp->lt_fraction;
d233 1
a233 1
		bn_tabdata_scale( swp->msw_color, lp->lt_spectrum, f );
d236 1
a236 1
	VSCALE( swp->sw_color, lp->lt_color, f );
d242 193
d440 5
a444 6
light_setup( rp, matparm, dpp, mfp, rtip )
register struct region *rp;
struct bu_vls	*matparm;
genptr_t	*dpp;
struct mfuncs           *mfp;
struct rt_i             *rtip;  /* New since 4.4 release */
d446 1
a446 1
	register struct light_specific *lp;
d452 1
a452 1
	BU_GETSTRUCT( lp, light_specific );
d454 15
a468 13
	BU_LIST_MAGIC_SET( &(lp->l), LIGHT_MAGIC );
	lp->lt_intensity = 1000.0;	/* Lumens */
	lp->lt_fraction = -1.0;		/* Recomputed later */
	lp->lt_visible = 1;		/* explicitly modeled */
	lp->lt_invisible = 0;		/* explicitly modeled */
	lp->lt_shadows = 1;		/* by default, casts shadows */
	lp->lt_angle = 180;		/* spherical emission by default */
	lp->lt_exaim = 0;		/* use default aiming mechanism */
	lp->lt_infinite = 0;
	lp->lt_rp = rp;
	lp->lt_name = bu_strdup( rp->reg_name );
	if (bu_struct_parse( matparm, light_parse, (char *)lp ) < 0 )  {
		bu_free( (char *)lp, "light_specific" );
d472 2
a473 2
	if (lp->lt_angle > 180 )  lp->lt_angle = 180;
	lp->lt_cosangle = cos( (double) lp->lt_angle * 0.0174532925199433 );
d479 2
a480 2
		VMOVE( lp->lt_pos, stp->st_center );
		lp->lt_radius = stp->st_aradius;
d491 1
a491 1
			    lp->lt_name );
d494 2
a495 2
		VADD2SCALE( lp->lt_pos, min_rpp, max_rpp, 0.5 );
		VSUB2( rad, max_rpp, lp->lt_pos );
d499 1
a499 1
			lp->lt_radius = rad[X];
d501 3
a503 3
			lp->lt_radius = rad[Y];
		if (rad[Z] < lp->lt_radius )
			lp->lt_radius = rad[Z];
d517 2
a518 2
		if (lp->lt_exaim) {
			VSUB2 (work, lp->lt_dir, lp->lt_pos);
d522 2
a523 2
		MAT4X3VEC( lp->lt_aim, matp, work );
		VUNITIZE( lp->lt_aim );
d527 1
a527 1
	BN_GET_TABDATA(lp->lt_spectrum, spectrum);
d529 1
a529 1
		rt_spect_black_body( lp->lt_spectrum,
d536 1
a536 1
		rt_spect_reflectance_rgb( lp->lt_spectrum, rp->reg_mater.ma_color );
d538 2
a539 2
		bn_tabdata_scale( lp->lt_spectrum, lp->lt_spectrum,
			lp->lt_intensity * 0.001 ); /* XXX */
d542 1
a542 1
		bn_tabdata_constval( lp->lt_spectrum, 0.001 );
d546 1
a546 1
		VMOVE( lp->lt_color, rp->reg_mater.ma_color );
d548 1
a548 1
		VSETALL( lp->lt_color, 1 );
d552 2
a553 2
	VMOVE( lp->lt_vec, lp->lt_pos );
	f = MAGNITUDE( lp->lt_vec );
d556 1
a556 1
		VSET( lp->lt_vec, 0, 0, 1 );
d558 1
a558 1
		VSCALE( lp->lt_vec, lp->lt_vec, f );
d565 1
a565 1
	BU_LIST_INSERT( &(LightHead.l), &(lp->l) );
d567 2
a568 2
	if (lp->lt_invisible )  {
		lp->lt_rp = REGION_NULL;
d573 1
a573 1
	*dpp = (genptr_t)lp;	/* Associate lp with reg_udata */
d595 1
a595 2
	register struct light_specific *light =
	(struct light_specific *)cp;
d597 5
a601 5
	RT_CK_LIGHT(light);
	BU_LIST_DEQUEUE( &(light->l) );
	if (light->lt_name )  {
		bu_free( light->lt_name, "light name" );
		light->lt_name = (char *)0;
d603 2
a604 2
	light->l.magic = 0;	/* sanity */
	bu_free( (char *)light, "light_specific" );
d615 1
a615 1
	register struct light_specific *lp;
d645 2
a646 2
		BU_GETSTRUCT( lp, light_specific );
		lp->l.magic = LIGHT_MAGIC;
d648 9
a656 9
		BN_GET_TABDATA(lp->lt_spectrum, spectrum);
		rt_spect_reflectance_rgb( lp->lt_spectrum, color );
		bn_tabdata_scale( lp->lt_spectrum, lp->lt_spectrum, 1000.0 );
#else
		VMOVE( lp->lt_color, color );
#endif
		MAT4X3VEC( lp->lt_pos, v2m, temp );
		VMOVE( lp->lt_vec, lp->lt_pos );
		VUNITIZE( lp->lt_vec );
d659 1
a659 1
		lp->lt_name = bu_strdup(name);
d661 10
a670 10
		VSET( lp->lt_aim, 0, 0, -1 );	/* any direction: spherical */
		lp->lt_intensity = 1000.0;
		lp->lt_radius = 0.1;		/* mm, "point" source */
		lp->lt_visible = 0;		/* NOT explicitly modeled */
		lp->lt_invisible = 1;		/* NOT explicitly modeled */
		lp->lt_shadows = 0;		/* no shadows for speed */
		lp->lt_angle = 180;		/* spherical emission */
		lp->lt_cosangle = -1;		/* cos(180) */
		lp->lt_infinite = 0;
		lp->lt_rp = REGION_NULL;
d674 1
a674 1
		BU_LIST_INSERT( &(LightHead.l), &(lp->l) );
d694 1
a694 1
light_init()
d696 1
a696 1
	register struct light_specific *lp;
d703 3
a705 1
	for( BU_LIST_FOR( lp, light_specific, &(LightHead.l) ) )  {
d707 5
a711 5
		if (lp->lt_fraction > 0 )  continue;	/* overridden */
		if (lp->lt_intensity <= 0 )
			lp->lt_intensity = 1;		/* keep non-neg */
		if (lp->lt_intensity > inten )
			inten = lp->lt_intensity;
d719 3
a721 3
	for( BU_LIST_FOR( lp, light_specific, &(LightHead.l) ) )  {
		RT_CK_LIGHT(lp);
		if (lp->lt_fraction > 0 )  continue;	/* overridden */
d723 1
a723 1
		lp->lt_fraction = 1.0;	/* always use honest intensity values */
d725 1
a725 1
		lp->lt_fraction = lp->lt_intensity / inten;
d728 11
d742 2
a743 2
		for( BU_LIST_FOR( lp, light_specific, &(LightHead.l) ) )  {
			RT_CK_LIGHT(lp);
d745 3
a747 3
			    lp->lt_name,
			    lp->lt_pos[X], lp->lt_pos[Y], lp->lt_pos[Z],
			    lp->lt_aim[X], lp->lt_aim[Y], lp->lt_aim[Z] );
d749 6
a754 6
			    lp->lt_name,
			    lp->lt_visible ? "visible":"invisible",
			    lp->lt_shadows ? "casts shadows":"no shadows",
			    lp->lt_intensity,
			    (int)(lp->lt_fraction*100),
			    lp->lt_angle );
d777 1
a777 1
	register struct light_specific *lp, *zaplp;
d783 3
a785 3
	for( BU_LIST_FOR( lp, light_specific, &(LightHead.l) ) )  {
		RT_CK_LIGHT(lp);
		if (lp->lt_rp != REGION_NULL && lp->lt_visible )  {
d789 3
a791 3
		zaplp = lp;
		lp = BU_LIST_PREV( light_specific, &(lp->l) );
		light_free( (genptr_t)zaplp );
d830 1
a830 1
	CONST struct light_specific	*lp;
d851 2
a852 2
	lp = (struct light_specific *)(ap->a_uptr);
	RT_CK_LIGHT(lp);
d921 1
a921 1
		if (lp->lt_invisible || lp->lt_infinite )  {
d1000 1
a1000 1
	if (lp->lt_rp == regp )  {
d1012 1
a1012 1
	if (lp->lt_invisible && !(lp->lt_infinite) ) {
d1014 1
a1014 1
		VSUB2( tolight, lp->lt_pos, ap->a_ray.r_pt );
d1129 1
a1129 1
		    lp->lt_name,
d1137 1
a1137 1
	    lp->lt_name,
d1155 1
a1155 1
	struct light_specific *lp = (struct light_specific *)(ap->a_uptr);
d1157 2
a1158 2
	RT_CK_LIGHT(lp);
	if (lp->lt_invisible || lp->lt_infinite ) {
d1176 2
a1177 17
struct light_obs_stuff {
	struct application *ap;
	struct shadework *swp;
	struct light_specific *lp;
	int *rand_idx;

#if RT_MULTISPECTRAL
	struct bn_tabdata **inten;
#else
	fastf_t *inten;
#endif
	int iter;
	vect_t to_light_center;	/* coordinate system on light */
	vect_t light_x;
	vect_t light_y;
};

d1186 1
a1186 1
light_vis(los)
d1188 1
d1195 4
d1205 1
a1205 1
	if (los->lp->lt_infinite ) {
d1207 55
a1261 1
		VMOVE( shoot_dir, los->lp->lt_vec );
d1263 23
d1287 2
a1288 1

d1295 1
a1295 1
		radius = los->lp->lt_radius * 
d1316 4
d1322 3
a1324 2
			       V3ARGS(los->lp->lt_pos), 
			       los->lp->lt_radius);
d1326 3
d1330 1
a1330 3
		VJOIN2(shoot_pt, los->lp->lt_pos, 
		       x, los->light_x,
		       y, los->light_y);
a1331 1
		VSUB2(shoot_dir, shoot_pt, los->swp->sw_hit.hit_point);
d1348 1
a1348 2
	VUNITIZE( shoot_dir ); /* xxx We should just reuse to_light */

d1355 1
a1355 1
	if (-VDOT(shoot_dir, los->lp->lt_aim) < los->lp->lt_cosangle )  {
d1359 1
a1359 1
			       los->lp->lt_name);
d1364 1
a1364 1
	if (!(los->lp->lt_shadows) )  {
d1368 1
a1368 1
			       los->lp->lt_name);
d1404 1
a1404 1
	sub_ap.a_uptr = (genptr_t)los->lp;	/* so we can tell.. */
d1411 1
a1411 1
	sub_ap.a_purpose = los->lp->lt_name;	/* name of light shot at */
d1425 1
a1425 1
			radius, los->lp->lt_radius, 
d1435 1
a1435 1
			bu_log("light visible: %s\n", los->lp->lt_name);
d1457 1
a1457 1
		bu_log("light obscured: %s\n", los->lp->lt_name);
d1487 1
a1487 1
	register struct light_specific *lp;
d1495 1
d1515 2
a1516 2
	for( BU_LIST_FOR( lp, light_specific, &(LightHead.l) ) )  {
		RT_CK_LIGHT(lp);
d1522 2
a1523 2
		if (lp->lt_infinite )	tot_vis_rays = 1;
		else			tot_vis_rays = lp->lt_shadows;
d1525 1
a1525 1
		los.lp = lp;
d1536 1
a1536 1
		VSUB2(los.to_light_center, lp->lt_pos, swp->sw_hit.hit_point);
d1551 1
a1551 1
					   lp->lt_name);
d1557 1
d1561 5
a1565 1
			switch (light_vis(&los)) {
d1586 1
a1586 1
			swp->sw_visible[i] = (char *)lp;
@


11.49
log
@
Eliminated coredumping in multispectral mode
@
text
@d23 1
a23 1
static char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.48 2000/04/12 18:08:10 mike Exp $ (ARL)";
d36 2
a37 1
#include "../rt/rdebug.h"
d40 6
d400 1
a400 3
light_maker(num, v2m)
int	num;
mat_t	v2m;
d615 3
a634 1

d667 1
a667 1

d669 1
d686 3
d690 2
a721 1

d738 1
d770 1
d845 1
d847 1
a862 1

d879 3
d883 3
d894 1
d940 3
d947 1
a947 1
	return(0);			/* light_visible = 0 */
d982 1
d986 2
d1022 6
a1027 1

d1118 17
a1134 1
	if (rt_shootray( &sub_ap ) )  {
a1295 193



/*
 *			L I G H T _ V I S I B I L I T Y
 *
 *	Determine the visibility of each light source in the scene from a
 *	particular location.
 */
void
light_visibility(ap, swp, have)
struct application *ap;
struct shadework *swp;
int have;
{
	register struct light_specific *lp;
	register int	i;
#if !RT_MULTISPECTRAL
	register fastf_t *intensity;
#endif
	register fastf_t *tolight;
	register fastf_t f;
	struct application sub_ap;

	if (rdebug & RDEBUG_LIGHT ) bu_log("computing Light visibility: start\n");

	/*
	 *  Determine light visibility
	 *
	 *  The sw_intensity field does NOT include the light's
	 *  emission spectrum (color), only path attenuation.
	 *  sw_intensity=(1,1,1) for no attenuation.
	 */
	i = 0;
#if !RT_MULTISPECTRAL
	intensity = swp->sw_intensity;
#endif
	tolight = swp->sw_tolight;
	for( BU_LIST_FOR( lp, light_specific, &(LightHead.l) ) )  {
		RT_CK_LIGHT(lp);
		/* compute the light direction */
		if (lp->lt_infinite ) {
			/* Infinite lights are point sources, no fuzzy penumbra */
			VMOVE( tolight, lp->lt_vec );
		} else {
			VSUB2(tolight, lp->lt_pos,
			    swp->sw_hit.hit_point);
#if 1
			/*
			 *  Dither light pos for penumbra by +/- 0.5 light 
			 *  radius; this presently makes a cubical light 
			 *  source distribution.
			 */
			f = lp->lt_radius * 0.7;
			tolight[X] = lp->lt_pos[X] +
			    bn_rand_half(ap->a_resource->re_randptr)*f -
			    swp->sw_hit.hit_point[X];
			tolight[Y] = lp->lt_pos[Y] +
			    bn_rand_half(ap->a_resource->re_randptr)*f -
			    swp->sw_hit.hit_point[Y];
			tolight[Z] = lp->lt_pos[Z] +
			    bn_rand_half(ap->a_resource->re_randptr)*f -
			    swp->sw_hit.hit_point[Z];
#endif

		}

		/*
		 *  If we have a normal, test against light direction
		 */
		if ((have & MFI_NORMAL) && (swp->sw_transmit <= 0) )  {
			if (VDOT(swp->sw_hit.hit_normal,tolight) < 0 ) {
				/* backfacing, opaque */
				if (rdebug & RDEBUG_LIGHT)
					bu_log("normal backfacing, opaque surface: %s\n", lp->lt_name);
				swp->sw_visible[i] = (char *)0;
				goto next;
			}
		}

		if (rdebug& RDEBUG_RAYPLOT) {
			point_t ray_endpt;

			/* Yelow -- light visibility ray */
			pl_color(stdout, 200, 200, 0);
			VADD2(ray_endpt, swp->sw_hit.hit_point,
			    tolight);
			pdv_3line(stdout, swp->sw_hit.hit_point,
			    ray_endpt);
		}
		VUNITIZE( tolight );

		/*
		 * See if ray from hit point to light lies within light beam
		 * Note: this is should always be true for infinite lights!
		 */
		if (-VDOT(tolight, lp->lt_aim) < lp->lt_cosangle )  {
			/* dark (outside of light beam) */
			if (rdebug & RDEBUG_LIGHT)
				bu_log("point outside beam, obscured: %s\n", lp->lt_name);

			swp->sw_visible[i] = (char *)0;
			goto next;
		}
		if (!(lp->lt_shadows) )  {
			/* "fill light" in beam, don't care about shadows */
			if (rdebug & RDEBUG_LIGHT)
				bu_log("fill light, no shadow, visible: %s\n", lp->lt_name);
			swp->sw_visible[i] = (char *)lp;
#if RT_MULTISPECTRAL
			/* XXX Need a power level for this! */
			bn_tabdata_constval( swp->msw_intensity[i], 1.0 );
#else
			VSETALL( intensity, 1 );
#endif
			goto next;
		}

		/*
		 *  Fire ray at light source to check for shadowing.
		 *  (This SHOULD actually return an energy spectrum).
		 *  Advance start point slightly off surface.
		 */
		sub_ap = *ap;			/* struct copy */

		VMOVE( sub_ap.a_ray.r_dir, tolight );
		{
			register fastf_t f;
			f = ap->a_rt_i->rti_tol.dist;
			VJOIN1( sub_ap.a_ray.r_pt,
			    swp->sw_hit.hit_point,
			    f, tolight );
		}
		sub_ap.a_rbeam = ap->a_rbeam + swp->sw_hit.hit_dist * ap->a_diverge;
		sub_ap.a_diverge = ap->a_diverge;

		sub_ap.a_hit = light_hit;
		sub_ap.a_miss = light_miss;
		sub_ap.a_user = -1;		/* sanity */
		sub_ap.a_uptr = (genptr_t)lp;	/* so we can tell.. */
		sub_ap.a_level = 0;
		/* Will need entry & exit pts, for filter glass ==> 2 */
		/* Continue going through air ==> negative */
		sub_ap.a_onehit = -2;

		VSETALL( sub_ap.a_color, 1 );	/* vis intens so far */
		sub_ap.a_purpose = lp->lt_name;	/* name of light shot at */

		RT_CK_LIGHT((struct light_specific *)(sub_ap.a_uptr));


		if (rt_shootray( &sub_ap ) )  {
			/* light visible */
			if (rdebug & RDEBUG_LIGHT)
				bu_log("light visible: %s\n", lp->lt_name);
			swp->sw_visible[i] = (char *)lp;
#if RT_MULTISPECTRAL
			if (swp->msw_intensity[i] == BN_TABDATA_NULL) {
				swp->msw_intensity[i] = sub_ap.a_spectrum;
			} else {
				bu_bomb("Why are we multisampling?");

				bn_tabdata_add(swp->msw_intensity[i],
					       swp->msw_intensity[i],
					       sub_ap.a_spectrum);

				bn_tabdata_free(sub_ap.a_spectrum);
			}
			sub_ap.a_spectrum = BN_TABDATA_NULL;

#else
			VMOVE( intensity, sub_ap.a_color );
#endif
		} else {
			/* dark (light obscured) */
			if (rdebug & RDEBUG_LIGHT)
				bu_log("light obscured: %s\n", lp->lt_name);
			swp->sw_visible[i] = (char *)0;
		}
next:
		/* Advance to next light */
		i++;
#if RT_MULTISPECTRAL
		/* Release sub_ap? */
#else
		intensity += 3;
#endif
		tolight += 3;
	}

	if (rdebug & RDEBUG_LIGHT ) bu_log("computing Light visibility: end\n");
}

@


11.49.2.1
log
@Lee's fix for missing specular highlights
@
text
@d23 1
a23 1
static char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.49 2000/04/13 13:34:38 mike Exp $ (ARL)";
d1174 1
a1174 1
		if (lp->lt_infinite || lp->lt_shadows == 0) tot_vis_rays = 1;
@


11.49.2.2
log
@put some debug statements inside a "if( rdebug & RDEBUG_LIGHT )" in light_miss()
@
text
@d23 1
a23 1
static char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.49.2.1 2000/10/17 16:56:40 jra Exp $ (ARL)";
d916 2
a917 4
	if( rdebug & RDEBUG_LIGHT ) {
		bu_log("light ray missed non-infinite, visible light source\n");
		bu_log("on pixel: %d %d\n", ap->a_x, ap->a_y);
	}
@


11.48
log
@
Added error checking.
@
text
@d23 1
a23 1
static char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.47 2000/03/16 04:51:53 mike Exp $ (ARL)";
d931 5
a935 1
	void *inten;
d1092 2
a1093 2
		if (los->inten == BN_TABDATA_NULL) {
			los->inten = sub_ap.a_spectrum;
d1095 3
a1097 3
			BN_CK_TABDATA(los->inten);
			bn_tabdata_add(los->inten,
				       los->inten,
d1104 1
a1104 1
		VMOVE( ((vectp_t)los->inten), sub_ap.a_color );
d1179 2
a1180 2
		los.inten = (void *)&swp->msw_intensity[i];
		if(los.inten) BN_CK_TABDATA(los.inten);
d1182 1
a1182 1
		los.inten = (void *)&swp->sw_intensity[3*i];
@


11.47
log
@
Need M_PI for machines that don't provide it.
@
text
@d23 1
a23 1
static char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.46 2000/03/03 03:27:07 mike Exp $ (ARL)";
d1052 1
d1079 1
a1079 1

d1087 1
d1091 1
d1148 1
d1176 1
@


11.46
log
@
Fixed small typo in the code so that the blue 2nd light in the m35 benchmark
is again visible.
@
text
@d23 1
a23 1
static char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.45 2000/03/03 03:04:01 mike Exp $ (ARL)";
d38 5
@


11.45
log
@
sh_light.c/light_obs() applied the sw_lightfract scaling for the
multispectral case, but in the optical case it was applied in
sh_plastic.c/phong_render().  I made the multi-spectral code track the
optical code, and it's now consistent and much clearer.
@
text
@d23 1
a23 1
static char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.44 2000/02/23 03:34:47 butler Exp $ (ARL)";
d1168 1
a1168 1
		los.inten = (void *)&swp->sw_intensity[i];
@


11.44
log
@When running benchmark, always picks the center of the light approximating
sphere. This is to be compatible with previous benchmark images.
@
text
@d23 1
a23 1
static char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.43 2000/02/19 21:05:02 butler Exp $ (ARL)";
d497 3
d501 1
d1108 1
a1129 3
#if !RT_MULTISPECTRAL
	register fastf_t *intensity;
#endif
a1226 7
#if RT_MULTISPECTRAL
		/* Release sub_ap? */
		bn_tabdata_scale(swp->msw_intensity[i], swp->msw_intensity[i],
			swp->sw_lightfract[i]);
#else
		intensity += 3;
#endif
@


11.43
log
@Changes to support movement of CLAMP() macro into vmath.h
Altered "if( " statements to "if (" for readability.
@
text
@d23 1
a23 1
static char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.42 2000/02/18 04:39:05 butler Exp $ (ARL)";
d941 1
a941 1
	double radius, angle, x, y; 
d962 2
a963 1
			(bn_rand_half(los->ap->a_resource->re_randptr) + 0.5);
d968 13
a980 2
		x = radius * cos(angle);
		y = radius * sin(angle);
@


11.42
log
@Light now keeps both the visible and invisible flags.
camo now has different defaults for the noise scale.
@
text
@d23 1
a23 1
static char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.41 2000/02/17 21:03:44 butler Exp $ (ARL)";
d179 1
a179 1
	if( (f = -VDOT( swp->sw_hit.hit_normal, ap->a_ray.r_dir )*0.5) < 0 )
d183 1
a183 1
	if( VDOT( lp->lt_aim, swp->sw_hit.hit_normal) < lp->lt_cosangle )  {
d192 1
a192 1
	if( swp->sw_temperature > 0 )  {
d195 1
a195 1
		if( rdebug & RDEBUG_LIGHT )  {
d241 1
a241 1
	if( bu_struct_parse( matparm, light_parse, (char *)lp ) < 0 )  {
d246 1
a246 1
	if( lp->lt_angle > 180 )  lp->lt_angle = 180;
d250 1
a250 1
	if( rp->reg_treetop->tr_op == OP_SOLID )  {
d260 1
a260 1
		if( rt_bound_tree( rp->reg_treetop, min_rpp, max_rpp ) < 0 )
d263 1
a263 1
		if( max_rpp[X] >= INFINITY )  {
d272 1
a272 1
		if( rad[X] < rad[Y] )
d276 1
a276 1
		if( rad[Z] < lp->lt_radius )
d289 1
a289 1
		if( (matp = stp->st_matp) == (matp_t)0 )
d302 1
a302 1
	if( rp->reg_mater.ma_temperature > 0 )  {
d305 1
a305 1
		if( rdebug & RDEBUG_LIGHT )  {
d309 1
a309 1
	} else if( rp->reg_mater.ma_color_valid )  {
d319 1
a319 1
	if( rp->reg_mater.ma_color_valid )  {
d328 1
a328 1
	if( f < SQRT_SMALL_FASTF ) {
d336 1
a336 1
	if( BU_LIST_UNINITIALIZED( &(LightHead.l ) ) )  {
d341 1
a341 1
	if( lp->lt_invisible )  {
d374 1
a374 1
	if( light->lt_name )  {
d448 1
a448 1
		if( BU_LIST_UNINITIALIZED( &(LightHead.l ) ) )  {
d477 1
a477 1
	if( BU_LIST_UNINITIALIZED( &(LightHead.l ) ) )  {
d482 2
a483 2
		if( lp->lt_fraction > 0 )  continue;	/* overridden */
		if( lp->lt_intensity <= 0 )
d485 1
a485 1
		if( lp->lt_intensity > inten )
d496 1
a496 1
		if( lp->lt_fraction > 0 )  continue;	/* overridden */
d517 1
a517 1
	if( nlights > SW_NLIGHTS )  {
d539 1
a539 1
	if( BU_LIST_UNINITIALIZED( &(LightHead.l ) ) )  {
d545 1
a545 1
		if( lp->lt_rp != REGION_NULL && lp->lt_visible )  {
d634 1
a634 1
		if( pp->pt_regionp->reg_aircode != 0 )  {
d664 1
a664 1
		if( pp->pt_inhit->hit_dist >= ap->a_rt_i->rti_tol.dist )
d666 1
a666 1
		if( pp->pt_outhit->hit_dist >= ap->a_rt_i->rti_tol.dist*10 )
d669 1
a669 1
	if( pp == PartHeadp )  {
d673 1
a673 1
		if( lp->lt_invisible || lp->lt_infinite )  {
d684 1
a684 1
		if( air_sols_seen > 0 )  {
d751 1
a751 1
	if( lp->lt_rp == regp )  {
d763 1
a763 1
	if( lp->lt_invisible && !(lp->lt_infinite) ) {
d766 1
a766 1
		if( pp->pt_inhit->hit_dist >= MAGNITUDE(tolight) ) {
d779 1
a779 1
	if( pp->pt_outhit->hit_dist >= INFINITY ||
d795 1
a795 1
	if( ap->a_color[0] + ap->a_color[1] + ap->a_color[2] < 0.01 )  {
d830 1
a830 1
	if( filter_color[0] + filter_color[1] + filter_color[2] < 0.01 )  {
d865 5
a869 5
	if( ms_filter_color ) bn_tabdata_free( ms_filter_color );
	if( sw.msw_color )  bn_tabdata_free( sw.msw_color );
	if( sw.msw_basecolor ) bn_tabdata_free( sw.msw_basecolor );
	if( sub_ap.a_spectrum )  bn_tabdata_free( sub_ap.a_spectrum );
	if( rdebug & RDEBUG_LIGHT )  {
d878 1
a878 1
	if( rdebug & RDEBUG_LIGHT ) bu_log("light vis=%d %s (%4.2f, %4.2f, %4.2f) %s %s\n",
d901 1
a901 1
	if( lp->lt_invisible || lp->lt_infinite ) {
d903 1
a903 1
		if( rdebug & RDEBUG_LIGHT ) bu_log("light_miss vis=1\n");
d912 1
a912 1
	if( rdebug & RDEBUG_LIGHT ) bu_log("light_miss vis=0\n");
d945 1
a945 1
	if( rdebug & RDEBUG_LIGHT ) bu_log("light_vis\n");
d948 1
a948 1
	if( los->lp->lt_infinite ) {
d999 1
a999 1
	if( -VDOT(shoot_dir, los->lp->lt_aim) < los->lp->lt_cosangle )  {
d1008 1
a1008 1
	if( !(los->lp->lt_shadows) )  {
d1059 1
a1059 1
	if( rt_shootray( &sub_ap ) )  {
d1123 1
a1123 1
	if( rdebug & RDEBUG_LIGHT )
d1147 1
a1147 1
		if( lp->lt_infinite )	tot_vis_rays = 1;
d1169 1
a1169 1
		if( (have & MFI_NORMAL) && (swp->sw_transmit <= 0) )  {
d1224 1
a1224 1
	if( rdebug & RDEBUG_LIGHT ) bu_log("computing Light obscruration: end\n");
d1250 1
a1250 1
	if( rdebug & RDEBUG_LIGHT ) bu_log("computing Light visibility: start\n");
d1267 1
a1267 1
		if( lp->lt_infinite ) {
d1296 2
a1297 2
		if( (have & MFI_NORMAL) && (swp->sw_transmit <= 0) )  {
			if( VDOT(swp->sw_hit.hit_normal,tolight) < 0 ) {
d1322 1
a1322 1
		if( -VDOT(tolight, lp->lt_aim) < lp->lt_cosangle )  {
d1330 1
a1330 1
		if( !(lp->lt_shadows) )  {
d1377 1
a1377 1
		if( rt_shootray( &sub_ap ) )  {
d1416 1
a1416 1
	if( rdebug & RDEBUG_LIGHT ) bu_log("computing Light visibility: end\n");
@


11.41
log
@misc minor patches
@
text
@d23 1
a23 1
static char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.40 2000/02/09 22:36:30 butler Exp $ (ARL)";
d60 1
d62 8
d107 3
a109 3
{"%d",	1, "visible",	LIGHT_O(lt_visible),	BU_STRUCTPARSE_FUNC_NULL },
{"%d",  1, "invisible",	LIGHT_O(lt_visible),	light_cvt_visible },
{"%d",	1, "v",		LIGHT_O(lt_visible),	BU_STRUCTPARSE_FUNC_NULL },
d234 1
d341 1
a341 1
	if( ! lp->lt_visible )  {
d442 1
d545 1
a545 1
		if( lp->lt_rp != REGION_NULL && lp->lt_visible != 0 )  {
d673 1
a673 1
		if( (! lp->lt_visible) || lp->lt_infinite )  {
d763 1
a763 1
	if( (!lp->lt_visible) && !(lp->lt_infinite) ) {
d901 1
a901 1
	if( (!lp->lt_visible) || lp->lt_infinite ) {
d906 4
a918 1
	int have;
d929 7
a935 1

d1092 12
a1128 1
	los.have = have;
@


11.40
log
@Made to compile for libmultispectral
@
text
@d23 1
a23 1
static char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.39 2000/02/07 18:04:17 butler Exp $ (ARL)";
a887 1
	bu_log("miss\n");
@


11.39
log
@removed unused variables
@
text
@d23 1
a23 1
static char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.38 2000/02/03 06:34:45 butler Exp $ (ARL)";
d1046 2
a1047 2
		if (los->swp->msw_intensity[i] == BN_TABDATA_NULL) {
			los->swp->msw_intensity[i] = sub_ap.a_spectrum;
d1049 2
a1050 2
			bn_tabdata_add(los->swp->msw_intensity[i],
				       los->swp->msw_intensity[i],
d1185 2
a1186 1
		bn_tabdata_scale(swp->msw_intensity[i], swp->sw_lightfract[i]);
d1356 2
a1362 1
				bn_tabdata_scale(swp->msw_intensity[i], iter);
@


11.38
log
@Changes to the light visibility computation.  Now we allow multiple
light sample rays for each hit point.
@
text
@d23 1
a23 1
static char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.37 2000/01/22 01:39:56 mike Exp $ (ARL)";
a920 2
	fastf_t f;
	float t;
a921 1
	int tmp;
d1046 2
a1047 2
		if (swp->msw_intensity[i] == BN_TABDATA_NULL) {
			swp->msw_intensity[i] = sub_ap.a_spectrum;
d1049 2
a1050 2
			bn_tabdata_add(swp->msw_intensity[i],
				       swp->msw_intensity[i],
a1085 1
	register fastf_t f;
a1088 2
	vect_t light_tmp;
	int ret;
d1248 1
a1248 1
			f = lp->lt_radius * 0.9;
@


11.37
log
@
Allow RTTHERM light sources to be black-body emitters.
Temperature can be taken at prep time from the region,
and can also be set/modified by a shader stack (e.g. noise or texture).
@
text
@d23 1
a23 1
static char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.36 2000/01/20 22:51:53 butler Exp $ (ARL)";
d39 1
d46 30
d77 26
a102 8
	{"%f",	1, "inten",	LIGHT_O(lt_intensity),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "angle",	LIGHT_O(lt_angle),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "fract",	LIGHT_O(lt_fraction),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	3, "aim",	LIGHT_OA(lt_dir),	aim_set },
	{"%d",	1, "shadows",	LIGHT_O(lt_shadows),	BU_STRUCTPARSE_FUNC_NULL },
	{"%d",	1, "infinite",	LIGHT_O(lt_infinite),	BU_STRUCTPARSE_FUNC_NULL },
	{"%d",	1, "invisible",	LIGHT_O(lt_invisible),	BU_STRUCTPARSE_FUNC_NULL },
	{"",	0, (char *)0,	0,			BU_STRUCTPARSE_FUNC_NULL }
d224 1
a224 1
	lp->lt_invisible = 0;		/* explicitly modeled */
d331 1
a331 1
	if( lp->lt_invisible )  {
d349 1
a349 1
	bu_struct_print(rp->reg_name, light_parse, (char *)dp);
d431 1
a431 1
		lp->lt_invisible = 1;		/* NOT explicitly modeled */
d499 1
a499 1
			    lp->lt_invisible ? "invisible":"visible",
d534 1
a534 1
		if( lp->lt_rp != REGION_NULL && lp->lt_invisible == 0 )  {
d662 1
a662 1
		if( lp->lt_invisible || lp->lt_infinite )  {
d752 1
a752 1
	if( lp->lt_invisible && !(lp->lt_infinite) ) {
d888 1
d891 1
a891 1
	if( lp->lt_invisible || lp->lt_infinite ) {
d902 302
d1358 10
a1367 2
			BU_ASSERT( swp->msw_intensity[i] == BN_TABDATA_NULL );
			swp->msw_intensity[i] = sub_ap.a_spectrum;
d1369 1
d1392 2
@


11.36
log
@Fixed a bunch of indentation errors
@
text
@d23 1
a23 1
static char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.35 1999/12/30 05:49:27 butler Exp $ (ARL)";
d133 12
a144 1
	bn_tabdata_scale( swp->msw_color, lp->lt_spectrum, f );
d243 8
a250 1
	if( rp->reg_mater.ma_color_valid )  {
d252 3
d257 1
a257 1
		bn_tabdata_constval( lp->lt_spectrum, 1.0 );
a258 2
	/* XXX Need to convert units of lumens (candela-sr) to ?? mw/sr?  Use any old numbers to get started. */
	bn_tabdata_scale( lp->lt_spectrum, lp->lt_spectrum, lp->lt_intensity * 0.001 ); /* XXX */
@


11.35
log
@additions for -v flag to rt
@
text
@d23 1
a23 1
static char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.34 1999/12/04 01:22:39 mike Exp $ (ARL)";
d43 1
a43 1
			CONST char *base, char *value));
d56 1
a71 1

d76 1
d91 1
a91 1
		(struct light_specific *)base;
d115 1
a115 1
		(struct light_specific *)dp;
d195 1
a195 1
				lp->lt_name );
d224 2
a225 2
			}
		   else VSET( work, 0, 0, -1 );
d292 1
a292 1
		(struct light_specific *)cp;
d411 1
a411 1
/**	inten *= (1 + AmbientIntensity); **/
d426 3
a428 3
				lp->lt_name,
				lp->lt_pos[X], lp->lt_pos[Y], lp->lt_pos[Z],
				lp->lt_aim[X], lp->lt_aim[Y], lp->lt_aim[Z] );
d430 6
a435 6
				lp->lt_name,
				lp->lt_invisible ? "invisible":"visible",
				lp->lt_shadows ? "casts shadows":"no shadows",
				lp->lt_intensity,
				(int)(lp->lt_fraction*100),
				lp->lt_angle );
d579 1
a579 1
				sw.sw_transmit );
d612 3
a614 1
/* XXXXXXX This seems to happen with *every* light vis ray through air */
d636 1
a636 1
				pp->pt_outhit->hit_dist, ap->a_ray.r_dir);
d662 2
a663 2
			ap->a_x, ap->a_y,
			ap->a_rt_i->rti_tol.dist);
d703 1
a703 1
	    	bn_tabdata_constval( ap->a_spectrum, 0.0 );
d708 1
a708 1
	    	reason = "hit opaque object";
d717 1
a717 1
	    	/* Any light energy is "fully" attenuated by here */
d752 1
a752 1
	    	/* Any recursion won't be significant */
d792 4
a795 4
			light_visible,
			lp->lt_name,
			reason,
			regp ? regp->reg_name : "" );
d800 4
a803 4
		light_visible,
		lp->lt_name,
		V3ARGS(ap->a_color), reason,
		regp ? regp->reg_name : "" );
d845 2
a846 2
		register struct light_specific *lp;
		register int	i;
d848 1
a848 1
		register fastf_t *intensity;
d850 3
a852 3
		register fastf_t *tolight;
		register fastf_t f;
		struct application sub_ap;
d854 1
a854 1
		if( rdebug & RDEBUG_LIGHT ) bu_log("computing Light visibility: start\n");
d856 8
a863 8
		/*
		 *  Determine light visibility
		 *
		 *  The sw_intensity field does NOT include the light's
		 *  emission spectrum (color), only path attenuation.
		 *  sw_intensity=(1,1,1) for no attenuation.
		 */
		i = 0;
d865 1
a865 1
		intensity = swp->sw_intensity;
d867 10
a876 10
		tolight = swp->sw_tolight;
		for( BU_LIST_FOR( lp, light_specific, &(LightHead.l) ) )  {
			RT_CK_LIGHT(lp);
			/* compute the light direction */
			if( lp->lt_infinite ) {
				/* Infinite lights are point sources, no fuzzy penumbra */
				VMOVE( tolight, lp->lt_vec );
			} else {
				VSUB2(tolight, lp->lt_pos,
					swp->sw_hit.hit_point);
d878 15
a892 14
		/*
		 *  Dither light pos for penumbra by +/- 0.5 light radius;
		 *  this presently makes a cubical light source distribution.
		 */
		f = lp->lt_radius * 0.9;
		tolight[X] = lp->lt_pos[X] +
			bn_rand_half(ap->a_resource->re_randptr)*f -
			swp->sw_hit.hit_point[X];
		tolight[Y] = lp->lt_pos[Y] +
			bn_rand_half(ap->a_resource->re_randptr)*f -
			swp->sw_hit.hit_point[Y];
		tolight[Z] = lp->lt_pos[Z] +
			bn_rand_half(ap->a_resource->re_randptr)*f -
			swp->sw_hit.hit_point[Z];
d895 1
a895 1
			}
d897 6
a902 31
			/*
			 *  If we have a normal, test against light direction
			 */
			if( (have & MFI_NORMAL) && (swp->sw_transmit <= 0) )  {
				if( VDOT(swp->sw_hit.hit_normal,tolight) < 0 ) {
					/* backfacing, opaque */
					if (rdebug & RDEBUG_LIGHT)
						bu_log("normal backfacing, opaque surface: %s\n", lp->lt_name);
					swp->sw_visible[i] = (char *)0;
					goto next;
				}
			}
			
			if (rdebug& RDEBUG_RAYPLOT) {
				point_t ray_endpt;

				/* Yelow -- light visibility ray */
				pl_color(stdout, 200, 200, 0);
				VADD2(ray_endpt, swp->sw_hit.hit_point,
					tolight);
				pdv_3line(stdout, swp->sw_hit.hit_point,
					ray_endpt);
			}
			VUNITIZE( tolight );

			/*
			 * See if ray from hit point to light lies within light beam
			 * Note: this is should always be true for infinite lights!
			 */
			if( -VDOT(tolight, lp->lt_aim) < lp->lt_cosangle )  {
				/* dark (outside of light beam) */
d904 1
a904 2
					bu_log("point outside beam, obscured: %s\n", lp->lt_name);

d908 1
a908 13
			if( !(lp->lt_shadows) )  {
				/* "fill light" in beam, don't care about shadows */
				if (rdebug & RDEBUG_LIGHT)
					bu_log("fill light, no shadow, visible: %s\n", lp->lt_name);
				swp->sw_visible[i] = (char *)lp;
#if RT_MULTISPECTRAL
				/* XXX Need a power level for this! */
				bn_tabdata_constval( swp->msw_intensity[i], 1.0 );
#else
				VSETALL( intensity, 1 );
#endif
				goto next;
			}
d910 2
a911 6
			/*
			 *  Fire ray at light source to check for shadowing.
			 *  (This SHOULD actually return an energy spectrum).
			 *  Advance start point slightly off surface.
			 */
			sub_ap = *ap;			/* struct copy */
d913 8
a920 10
			VMOVE( sub_ap.a_ray.r_dir, tolight );
			{
				register fastf_t f;
				f = ap->a_rt_i->rti_tol.dist;
				VJOIN1( sub_ap.a_ray.r_pt,
					swp->sw_hit.hit_point,
					f, tolight );
			}
			sub_ap.a_rbeam = ap->a_rbeam + swp->sw_hit.hit_dist * ap->a_diverge;
			sub_ap.a_diverge = ap->a_diverge;
d922 17
a938 20
			sub_ap.a_hit = light_hit;
			sub_ap.a_miss = light_miss;
			sub_ap.a_user = -1;		/* sanity */
			sub_ap.a_uptr = (genptr_t)lp;	/* so we can tell.. */
			sub_ap.a_level = 0;
			/* Will need entry & exit pts, for filter glass ==> 2 */
			/* Continue going through air ==> negative */
			sub_ap.a_onehit = -2;

			VSETALL( sub_ap.a_color, 1 );	/* vis intens so far */
			sub_ap.a_purpose = lp->lt_name;	/* name of light shot at */

			RT_CK_LIGHT((struct light_specific *)(sub_ap.a_uptr));			


			if( rt_shootray( &sub_ap ) )  {
				/* light visible */
				if (rdebug & RDEBUG_LIGHT)
					bu_log("light visible: %s\n", lp->lt_name);
				swp->sw_visible[i] = (char *)lp;
d940 2
a941 3
				BU_ASSERT( swp->msw_intensity[i] == BN_TABDATA_NULL );
				swp->msw_intensity[i] = sub_ap.a_spectrum;
				sub_ap.a_spectrum = BN_TABDATA_NULL;
d943 1
a943 1
				VMOVE( intensity, sub_ap.a_color );
d945 54
a998 6
			} else {
				/* dark (light obscured) */
				if (rdebug & RDEBUG_LIGHT)
					bu_log("light obscured: %s\n", lp->lt_name);
				swp->sw_visible[i] = (char *)0;
			}
d1000 2
a1001 2
			/* Advance to next light */
			i++;
d1003 1
a1003 1
			/* Release sub_ap? */
d1005 1
a1005 1
			intensity += 3;
d1007 2
a1008 2
			tolight += 3;
		}
d1010 1
a1010 1
		if( rdebug & RDEBUG_LIGHT ) bu_log("computing Light visibility: end\n");
@


11.34
log
@
Mark light visibility rays as yellow/gold.
@
text
@d23 1
a23 1
static char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.33 1999/11/24 22:18:52 mike Exp $ (ARL)";
d419 17
a435 14
	bu_log("Lighting: Ambient = %d%%\n", (int)(AmbientIntensity*100));
	for( BU_LIST_FOR( lp, light_specific, &(LightHead.l) ) )  {
		RT_CK_LIGHT(lp);
		bu_log( "  %s: (%g, %g, %g), aimed at (%g, %g, %g)\n",
			lp->lt_name,
			lp->lt_pos[X], lp->lt_pos[Y], lp->lt_pos[Z],
			lp->lt_aim[X], lp->lt_aim[Y], lp->lt_aim[Z] );
		bu_log( "  %s: %s, %s, %g lumens (%d%%), halfang=%g\n",
			lp->lt_name,
			lp->lt_invisible ? "invisible":"visible",
			lp->lt_shadows ? "casts shadows":"no shadows",
			lp->lt_intensity,
			(int)(lp->lt_fraction*100),
			lp->lt_angle );
@


11.33
log
@
Removed obsolete include files
@
text
@d23 1
a23 1
static char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.32 1999/10/30 03:06:24 butler Exp $ (ARL)";
d906 2
a907 1
				pl_color(stdout, 200, 200, 200);
@


11.32
log
@Moved mathtab/rand_half from rt into libbn
Expanded structparse to include description and default
@
text
@d23 1
a23 1
static char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.31 1999/07/22 21:27:36 butler Exp $ (ARL)";
d32 1
a32 1
#include "rtlist.h"
@


11.31
log
@Put back light visibility ray dithering.
@
text
@d23 1
a23 1
static char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.30 1999/07/07 00:41:37 mike Exp $ (ARL)";
a35 1
#include "../rt/mathtab.h"
d878 1
a878 1
			rand_half(ap->a_resource->re_randptr)*f -
d881 1
a881 1
			rand_half(ap->a_resource->re_randptr)*f -
d884 1
a884 1
			rand_half(ap->a_resource->re_randptr)*f -
@


11.30
log
@
made hack value smaller.
@
text
@d23 1
a23 1
static char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.29 1999/07/02 22:20:41 mike Exp $ (ARL)";
d872 1
a872 1
#if 0
@


11.29
log
@
Removed dependence on compat4.h
@
text
@d23 1
a23 1
static char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.28 1999/07/01 20:08:46 mike Exp $ (ARL)";
d239 1
a239 1
	bn_tabdata_scale( lp->lt_spectrum, lp->lt_spectrum, lp->lt_intensity );
@


11.28
log
@
compat4
@
text
@d23 1
a23 1
static char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.27 1999/05/10 21:40:12 mike Exp $ (ARL)";
d47 3
a49 3
	{"%f",	1, "inten",	LIGHT_O(lt_intensity),	FUNC_NULL },
	{"%f",	1, "angle",	LIGHT_O(lt_angle),	FUNC_NULL },
	{"%f",	1, "fract",	LIGHT_O(lt_fraction),	FUNC_NULL },
d51 4
a54 4
	{"%d",	1, "shadows",	LIGHT_O(lt_shadows),	FUNC_NULL },
	{"%d",	1, "infinite",	LIGHT_O(lt_infinite),	FUNC_NULL },
	{"%d",	1, "invisible",	LIGHT_O(lt_invisible),	FUNC_NULL },
	{"",	0, (char *)0,	0,			FUNC_NULL }
@


11.27
log
@ma_override to ma_color_valid
@
text
@d23 1
a23 1
static char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.26 1998/12/16 03:51:03 mike Exp $ (ARL)";
d41 1
a41 1
#define LIGHT_OA(m)	offsetofarray(struct light_specific, m)
d148 1
a148 1
struct rt_vls	*matparm;
d158 2
a159 2
	RT_VLS_CHECK( matparm );
	GETSTRUCT( lp, light_specific );
d161 1
a161 1
	RT_LIST_MAGIC_SET( &(lp->l), LIGHT_MAGIC );
d170 1
a170 1
	lp->lt_name = rt_strdup( rp->reg_name );
d172 1
a172 1
		rt_free( (char *)lp, "light_specific" );
d194 1
a194 1
			rt_log("light_setup(%s) Infinitely large light sources not supported\n",
d220 1
a220 1
			matp = (matp_t)rt_identity;
d258 2
a259 2
	if( RT_LIST_UNINITIALIZED( &(LightHead.l ) ) )  {
		RT_LIST_INIT( &(LightHead.l) );
d261 1
a261 1
	RT_LIST_INSERT( &(LightHead.l), &(lp->l) );
d295 1
a295 1
	RT_LIST_DEQUEUE( &(light->l) );
d297 1
a297 1
		rt_free( light->lt_name, "light name" );
d301 1
a301 1
	rt_free( (char *)light, "light_specific" );
d344 1
a344 1
		GETSTRUCT( lp, light_specific );
d358 1
a358 1
		lp->lt_name = rt_strdup(name);
d369 2
a370 2
		if( RT_LIST_UNINITIALIZED( &(LightHead.l ) ) )  {
			RT_LIST_INIT( &(LightHead.l) );
d372 1
a372 1
		RT_LIST_INSERT( &(LightHead.l), &(lp->l) );
d398 2
a399 2
	if( RT_LIST_UNINITIALIZED( &(LightHead.l ) ) )  {
		RT_LIST_INIT( &(LightHead.l) );
d401 1
a401 1
	for( RT_LIST_FOR( lp, light_specific, &(LightHead.l) ) )  {
d415 1
a415 1
	for( RT_LIST_FOR( lp, light_specific, &(LightHead.l) ) )  {
d420 2
a421 2
	rt_log("Lighting: Ambient = %d%%\n", (int)(AmbientIntensity*100));
	for( RT_LIST_FOR( lp, light_specific, &(LightHead.l) ) )  {
d423 1
a423 1
		rt_log( "  %s: (%g, %g, %g), aimed at (%g, %g, %g)\n",
d427 1
a427 1
		rt_log( "  %s: %s, %s, %g lumens (%d%%), halfang=%g\n",
d436 1
a436 1
		rt_log("Number of lights limited to %d\n", SW_NLIGHTS);
d457 2
a458 2
	if( RT_LIST_UNINITIALIZED( &(LightHead.l ) ) )  {
		RT_LIST_INIT( &(LightHead.l) );
d461 1
a461 1
	for( RT_LIST_FOR( lp, light_specific, &(LightHead.l) ) )  {
d468 1
a468 1
		lp = RT_LIST_PREV( light_specific, &(lp->l) );
d524 1
a524 1
	RT_CK_LIST_HEAD(&finished_segs->l);
d656 1
a656 1
		rt_log("light_hit:  ERROR, nothing hit, sxy=%d,%d, dtol=%e\n",
d819 1
a819 1
		if( rdebug & RDEBUG_LIGHT ) rt_log("light_miss vis=1\n");
d824 1
a824 1
	if( rdebug & RDEBUG_LIGHT ) rt_log("light_miss vis=0\n");
d849 1
a849 1
		if( rdebug & RDEBUG_LIGHT ) rt_log("computing Light visibility: start\n");
d863 1
a863 1
		for( RT_LIST_FOR( lp, light_specific, &(LightHead.l) ) )  {
d1003 1
a1003 1
		if( rdebug & RDEBUG_LIGHT ) rt_log("computing Light visibility: end\n");
@


11.26
log
@rt_pr_tabdata() now bn_pr_tabdata()
@
text
@d23 1
a23 1
static char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.25 1998/12/12 07:23:05 mike Exp $ (ARL)";
d232 1
a232 1
	if( rp->reg_mater.ma_override )  {
d241 1
a241 1
	if( rp->reg_mater.ma_override )  {
@


11.25
log
@Converted from rt_tabdata to bn_tabdata
@
text
@d23 1
a23 1
static char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.24 1998/12/10 08:27:29 mike Exp $ (ARL)";
d791 1
a791 1
		rt_pr_tabdata("light spectrum", ap->a_spectrum);
@


11.24
log
@Oops, spelled routine names wrong
@
text
@d23 1
a23 1
static char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.23 1998/12/10 08:23:21 mike Exp $ (ARL)";
a35 3
#if RT_MULTISPECTRAL
# include "tabdata.h"
#endif
d62 1
a62 1
extern CONST struct rt_table	*spectrum;	/* from rttherm/viewtherm.c */
d133 1
a133 1
	rt_tabdata_scale( swp->msw_color, lp->lt_spectrum, f );
d231 1
a231 1
	RT_GET_TABDATA(lp->lt_spectrum, spectrum);
d236 1
a236 1
		rt_tabdata_constval( lp->lt_spectrum, 1.0 );
d239 1
a239 1
	rt_tabdata_scale( lp->lt_spectrum, lp->lt_spectrum, lp->lt_intensity );
d347 1
a347 1
		RT_GET_TABDATA(lp->lt_spectrum, spectrum);
d349 1
a349 1
		rt_tabdata_scale( lp->lt_spectrum, lp->lt_spectrum, 1000.0 );
d511 1
a511 1
	struct rt_tabdata	*ms_filter_color = RT_TABDATA_NULL;
d520 2
a521 2
	sub_ap.a_spectrum = RT_TABDATA_NULL;	/* sanity */
	RT_CK_TABDATA(ap->a_spectrum);
d530 3
a532 3
	ms_filter_color = rt_tabdata_get_constval( 1.0, spectrum );
	RT_GET_TABDATA( sw.msw_color, spectrum );
	RT_GET_TABDATA( sw.msw_basecolor, spectrum );
d563 2
a564 2
			rt_tabdata_constval( sw.msw_color, 1.0 );
			rt_tabdata_constval( sw.msw_basecolor, 1.0 );
d575 1
a575 1
			rt_tabdata_scale( ms_filter_color, ms_filter_color,
d594 1
a594 1
			rt_tabdata_copy( ap->a_spectrum, ms_filter_color );
d605 1
a605 1
			rt_tabdata_copy( ap->a_spectrum, ms_filter_color );
d627 1
a627 1
			sub_ap.a_spectrum = rt_tabdata_dup( ap->a_spectrum );
d638 1
a638 1
			rt_tabdata_copy( ap->a_spectrum, sub_ap.a_spectrum );
d669 1
a669 1
		rt_tabdata_copy( ap->a_spectrum, ms_filter_color );
d684 1
a684 1
			rt_tabdata_copy( ap->a_spectrum, ms_filter_color );
d698 1
a698 1
	    	rt_tabdata_constval( ap->a_spectrum, 0.0 );
d731 2
a732 2
	rt_tabdata_constval( sw.msw_color, 1.0 );
	rt_tabdata_constval( sw.msw_basecolor, 1.0 );
d742 1
a742 1
	rt_tabdata_scale( ms_filter_color, ms_filter_color, sw.sw_transmit );
d763 1
a763 1
	sub_ap.a_spectrum = rt_tabdata_dup( ap->a_spectrum );
d774 1
a774 1
	rt_tabdata_mul( ap->a_spectrum, sub_ap.a_spectrum, ms_filter_color );
d781 4
a784 4
	if( ms_filter_color ) rt_tabdata_free( ms_filter_color );
	if( sw.msw_color )  rt_tabdata_free( sw.msw_color );
	if( sw.msw_basecolor ) rt_tabdata_free( sw.msw_basecolor );
	if( sub_ap.a_spectrum )  rt_tabdata_free( sub_ap.a_spectrum );
d934 1
a934 1
				rt_tabdata_constval( swp->msw_intensity[i], 1.0 );
d980 3
a982 1
				rt_tabdata_copy( swp->msw_intensity[i], sub_ap.a_spectrum );
d995 3
a997 1
#if !RT_MULTISPECTRAL
@


11.23
log
@Added initial multispectral support
@
text
@d23 1
a23 1
static char RCSsh_light[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_light.c,v 11.22 1998/09/22 01:29:54 mike Exp $ (ARL)";
d242 1
a242 1
	rt_spect_scale( lp->lt_spectrum, lp->lt_spectrum, lp->lt_intensity );
d352 1
a352 1
		rt_spect_scale( lp->lt_spectrum, lp->lt_spectrum, 1000.0 );
d784 4
a787 4
	if( ms_filter_color ) rt_free_tabdata( ms_filter_color );
	if( sw.msw_color )  rt_free_tabdata( sw.msw_color );
	if( sw.msw_basecolor ) rt_free_tabdata( sw.msw_basecolor );
	if( sub_ap.a_spectrum )  rt_free_tabdata( sub_ap.a_spectrum );
@


11.22
log
@Moved optical shaders from rt/ to liboptical/
The only modifications involved moving and splitting
rt/material.h into h/shadefuncs.h and h/shadework.h,
and in changing the calling sequence to mlib_setup() in rt/material.c

Now the only shader function called directly by RT is
in liboptical/init.c: optical_shader_init().
It adds all the individual shaders to the "mfuncs" shader list.
@
text
@d23 1
a23 1
static char RCSsh_light[] = "@@(#)$Header$ (ARL)";
d36 3
d64 4
d135 3
d139 1
d233 11
d249 1
d349 5
d355 1
d490 2
d513 3
d517 1
d522 5
d532 5
d538 1
d565 4
d571 1
d576 5
a580 1
			/* Clouds don't yet attenuate differently based on freq */
d582 1
d596 3
d600 1
d607 3
d611 1
d629 3
d640 3
d646 1
d671 3
d675 1
d686 3
d690 1
d700 3
d704 1
d710 3
d721 1
d733 4
d739 1
d744 4
d756 1
d765 3
d776 3
d780 1
d783 14
d802 1
d845 4
a848 1
		register fastf_t *intensity, *tolight;
d862 1
d864 1
d935 4
d940 1
d982 3
d986 1
d996 1
d998 1
@


11.21
log
@Can't make "struct mfuncs" a CONST, because the forward link needs
to be filled in at runtime, and some compilers put CONST data into
read-only pages (like FreeBSD).
@
text
@d10 2
a11 3
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
d13 5
d19 2
a20 2
 *	This software is Copyright (C) 1987 by the United States Army.
 *	All rights reserved.
d23 1
a23 1
static char RCSlight[] = "@@(#)$Header: /c/CVS/brlcad/rt/sh_light.c,v 11.20 1998/03/26 08:06:43 mike Exp $ (BRL)";
d34 5
a38 4
#include "./material.h"
#include "./mathtab.h"
#include "./light.h"
#include "./rdebug.h"
@


11.20
log
@light_miss doesn't get partition pointer.
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 11.19 1998/01/13 11:45:36 mike Exp mike $ (BRL)";
d60 1
a60 1
CONST struct mfuncs light_mfuncs[] = {
@


11.19
log
@Added light name to visible/obscured debug messages
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 11.18 1998/01/13 10:42:10 mike Exp mike $ (BRL)";
d690 1
a690 1
light_miss(ap, PartHeadp)
a691 1
struct partition *PartHeadp;
@


11.18
log
@Added extra debug message
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 11.17 1997/12/31 09:01:40 mike Exp mike $ (BRL)";
d773 1
a773 1
						bu_log("backfacing, opaque\n");
d797 1
a797 1
					bu_log("outside beam\n");
d805 1
a805 1
					bu_log("fill light, no shadow\n");
d847 1
a847 1
					bu_log("light visible\n");
d853 1
a853 1
					bu_log("light obscured\n");
@


11.17
log
@Required magic number to be first in mfunc table,
consistent with all other BRL-CAD magic numbers.
Required magic number to be initialized at compile time.
Added code to check the magic numbers.
Made the xxx_mfunc arrays CONST, so they can't get trashed by
runtime runaway pointer problems.
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 11.16 1997/12/09 04:46:58 butler Exp mike $ (BRL)";
d726 1
a726 1
		if( rdebug & RDEBUG_LIGHT ) rt_log("computing Light visibility\n");
d862 2
@


11.16
log
@misc debugging and now plots light visibility rays if RDEBUG_RAYPLOT set
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /n/vapor/m/cad/rt/RCS/sh_light.c,v 11.15 1997/11/25 22:16:43 butler Exp butler $ (BRL)";
d60 2
a61 2
struct mfuncs light_mfuncs[] = {
	{"light",	0,		0,		MFI_NORMAL,	0,
d64 1
a64 1
	{(char *)0,	0,		0,		0,		0,
@


11.15
log
@updated all shaders so that _setup had mfp and rtip parameters
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 11.14 1997/03/04 05:46:36 mike Exp butler $ (BRL)";
d726 2
d772 2
d778 10
d796 3
d804 2
d817 1
d826 3
d846 2
d852 2
@


11.14
log
@Process invisible and infinite lights.
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 11.13 1997/02/27 04:38:09 mike Exp mike $ (BRL)";
d133 1
a133 1
light_setup( rp, matparm, dpp )
d137 2
@


11.13
log
@Clouds now cast shadows.
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 11.12 1997/02/14 09:22:36 mike Exp mike $ (BRL)";
d482 3
d531 7
a591 2
	lp = (struct light_specific *)(ap->a_uptr);
	RT_CK_LIGHT(lp);
d672 5
a676 3
	if( rdebug & RDEBUG_LIGHT ) rt_log("light %s vis=%d (%4.2f, %4.2f, %4.2f) %s\n",
		regp ? regp->reg_name : "-miss-",
		light_visible, V3ARGS(ap->a_color), reason );
d726 4
@


11.12
log
@Got air "container" solids to stop casting shadows,
but the clouds inside the air don't cast shadows yet.
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 11.11 1997/02/14 09:07:06 mike Exp mike $ (BRL)";
d470 1
a470 1
	register struct region	*regp;
d478 1
d482 2
d500 1
a500 1
			/* XXX Should be accumulating transmission through each */
d502 15
d528 7
a534 1
		if( air_sols_seen > 0 )  return 1;	/* light_visible = 1 */
d566 1
d575 3
a577 1
		return(0);		/* light_visible = 0 */
d585 1
a585 1
		VSETALL( ap->a_color, 1 );
d587 1
a587 1
		/* XXX Need to tally up air attenuation here */
d596 1
a596 1
			VSETALL( ap->a_color, 1 );
d598 1
a598 1
			/* XXX Need to tally up air attenuation here */
d608 1
d617 1
a620 2
	/* XXX Need to tally up air attenuation here */

d635 1
d637 1
a637 1
	VSCALE( filter_color, sw.sw_color, sw.sw_transmit );
d642 1
d662 1
d664 3
a666 1
	if( rdebug & RDEBUG_LIGHT ) rt_log("light %s vis=%d\n", regp->reg_name, light_visible);
@


11.11
log
@Additional butler comments.
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 11.10 1996/08/31 08:46:01 butler Exp butler $ (BRL)";
d477 1
d496 5
d510 2
a515 1

d560 1
d571 1
d592 1
d665 3
a667 1
 *	Determine the visibility of each light source in the scen from a
d763 3
a765 2
			/* Will need entry & exit pts, for filter glass */
			sub_ap.a_onehit = 2;
@


11.10
log
@bu_struct_print
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 11.9 1996/08/31 08:29:28 butler Exp butler $ (BRL)";
d507 2
d569 1
a569 1
	    regp->reg_transmit == 0 )  {
@


11.9
log
@bu_struct_parse
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 11.8 1996/08/30 00:08:21 butler Exp butler $ (BRL)";
d254 1
a254 1
	bu_structprint(rp->reg_name, light_parse, (char *)dp);
@


11.8
log
@structparse moved to libbu
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 11.7 1996/08/14 03:45:51 butler Exp butler $ (BRL)";
d71 1
a71 1
 *  This routine is called by bu_structparse() if the "aim"
d156 1
a156 1
	if( bu_structparse( matparm, light_parse, (char *)lp ) < 0 )  {
@


11.7
log
@shadework structure "sw_segs" field needed to be filled in before calling viewshade
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /n/vapor/m/cad/rt/RCS/sh_light.c,v 11.6 1996/07/24 17:07:38 jra Exp butler $ (BRL)";
d38 1
a38 1
RT_EXTERN(HIDDEN void	aim_set, (CONST struct structparse *sdp, CONST char *name,
d41 1
a41 1
struct structparse light_parse[] = {
d71 1
a71 1
 *  This routine is called by rt_structparse() if the "aim"
d76 1
a76 1
CONST struct structparse *sdp;
d156 1
a156 1
	if( rt_structparse( matparm, light_parse, (char *)lp ) < 0 )  {
d254 1
a254 1
	rt_structprint(rp->reg_name, light_parse, (char *)dp);
@


11.6
log
@Added "sw.sw_inputs = 0;" to light_hit().
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 11.5 1996/07/22 20:34:18 jra Exp $ (BRL)";
d464 1
a464 1
light_hit(ap, PartHeadp)
d467 1
d478 1
d591 1
@


11.5
log
@Minor Mods for IRIX 6.2
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 11.4 1996/05/09 03:24:58 butler Exp jra $ (BRL)";
d585 1
@


11.4
log
@moved light visibility calculations in from shade.c
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 11.3 1995/10/20 04:43:53 butler Exp butler $ (BRL)";
d530 2
a531 1
			return ( retval );
d639 1
d644 1
@


11.3
log
@edited mfuncs table to account for new "mf_flags" element in struct mfuncs.
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 11.2 1995/08/19 05:07:15 butler Exp butler $ (BRL)";
d31 1
d409 31
d462 2
d477 4
a480 1
	/*
d578 1
d628 1
d646 2
a647 7
 *			L I G H T _ C L E A N U P
 *
 *  Called from view_end().
 *  Take care of releasing storage for any lights which will not
 *  be cleaned up by mlib_free():
 *	implicitly created lights, because they have no associated region, and
 *	invisible lights, because their region was destroyed.
d650 4
a653 1
light_cleanup()
d655 67
a721 1
	register struct light_specific *lp, *zaplp;
d723 41
a763 9
	if( RT_LIST_UNINITIALIZED( &(LightHead.l ) ) )  {
		RT_LIST_INIT( &(LightHead.l) );
		return;
	}
	for( RT_LIST_FOR( lp, light_specific, &(LightHead.l) ) )  {
		RT_CK_LIGHT(lp);
		if( lp->lt_rp != REGION_NULL && lp->lt_invisible == 0 )  {
			/* Will be cleaned up by mlib_free() */
			continue;
a764 4
		zaplp = lp;
		lp = RT_LIST_PREV( light_specific, &(lp->l) );
		light_free( (genptr_t)zaplp );
	}
@


11.2
log
@cast viewshade to a void
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 11.1 1995/01/04 10:01:06 mike Rel4_4 butler $ (BRL)";
d60 1
a60 1
	{"light",	0,		0,		MFI_NORMAL,
d63 1
a63 1
	{(char *)0,	0,		0,
@


11.1
log
@Release_4.4
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 10.8 94/11/05 02:51:28 mike Exp $ (BRL)";
d552 1
a552 1
	viewshade( ap, pp, &sw );
@


10.8
log
@Irix 6, changed to a_uptr
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 10.7 94/10/31 23:15:16 mike Exp Locker: mike $ (BRL)";
@


10.7
log
@ANSI C nit.
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 10.6 94/10/31 23:11:26 mike Exp Locker: mike $ (BRL)";
d506 1
a506 1
	lp = (struct light_specific *)(ap->a_user);
d594 1
a594 1
	struct light_specific *lp = (struct light_specific *)(ap->a_user);
@


10.6
log
@Bill Laut's new way of aiming lights.
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 10.5 1994/08/11 02:22:48 gdurf Exp $ (BRL)";
d37 2
a38 1
HIDDEN int	aim_set (struct structparse *, char *, char *, char *);
@


10.5
log
@Added include of conf.h
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 10.4 1994/05/06 03:27:40 mike Exp gdurf $ (BRL)";
d35 1
d37 2
d43 1
d67 19
d150 1
d204 5
a208 1
		VSET( work, 0, 0, -1 );
@


10.4
log
@Fixed bug where pt_outhit->hit_point was not being calculated before used.
Sometimes, this would give signaling NaN's, which let me find it!
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 10.3 94/05/06 01:17:38 mike Exp Locker: mike $ (BRL)";
d21 2
@


10.3
log
@Changed to using new magic number checking routine.
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 10.2 94/05/05 23:00:41 mike Exp Locker: mike $ (BRL)";
d351 1
d357 1
d407 1
a407 1
	struct light_specific	*lp;
d432 1
d445 3
a447 1
			VMOVE(sub_ap.a_ray.r_pt, pp->pt_outhit->hit_point);
@


10.2
log
@Fixed problem with light visibility checking.
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 10.1 91/10/12 06:42:08 mike Rel4_0 Locker: mike $ (BRL)";
d82 2
d235 1
a235 1
	if( RT_LIST_MAGIC_WRONG( &(light->l), LIGHT_MAGIC ) )  rt_bomb("light_free magic");
d471 1
a471 1
	if( RT_LIST_MAGIC_WRONG( &(lp->l), LIGHT_MAGIC ) )  rt_bomb("light_hit magic");
d560 1
a560 1
	if( RT_LIST_MAGIC_WRONG( &(lp->l), LIGHT_MAGIC ) )  rt_bomb("light_miss magic");
d589 1
@


10.1
log
@Release_4.0
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /n/wolf/m/cad/rt/RCS/sh_light.c,v 9.21 91/09/18 14:01:22 butler Exp $ (BRL)";
d429 1
a429 1
		if (pp->pt_inhit->hit_dist <= 0.0) {
@


9.21
log
@Occasionally, the shadow ray will intersect the solid at the point where
the ray starts.  When this happens (inhit dist < 0 && outhit dist > 0)
we re-shoot the shadow ray starting at the outhit point of the previous ray.
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 9.20 91/08/30 03:49:53 mike Exp $ (BRL)";
@


9.20
log
@Need to check outhit distance too, so that heading through the solid
towards the light won't be missed either.
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 9.19 91/08/16 16:23:15 mike Exp $ (BRL)";
d428 31
@


9.19
log
@Added xy values to light_hit error message.
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 9.18 91/08/16 15:15:48 mike Exp $ (BRL)";
d415 4
d420 6
a425 2
	for( pp=PartHeadp->pt_forw; pp != PartHeadp; pp = pp->pt_forw )
		if( pp->pt_inhit->hit_dist >= ap->a_rt_i->rti_tol.dist )  break;
@


9.18
log
@Expanded diagnostics.
Changed ray advance distance from 0.0001 to rti_tol.dist
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 9.17 91/08/16 14:18:56 mike Exp $ (BRL)";
d420 3
a422 1
		rt_log("light_hit:  ERROR, nothing hit, vis=0, dtol=%e\n",ap->a_rt_i->rti_tol.dist);
@


9.17
log
@Made light_hit more robust, avoiding lights being shadowed by the
surface that the visibility ray was shot from.
Does not affect benchmark results, but seems like a good idea.
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 9.16 91/07/16 00:05:10 mike Exp $ (BRL)";
d419 3
a421 1
		rt_log("light_hit:  ERROR, nothing hit, vis=0\n");
d491 2
a492 2
		FAST fastf_t f;
		f = pp->pt_outhit->hit_dist+0.0001;
@


9.16
log
@Slightly more conservative handling of *dpp (reg_udata)
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 9.15 91/07/06 00:35:19 mike Exp $ (BRL)";
d376 2
d408 8
d417 1
a417 1
		if( pp->pt_outhit->hit_dist >= 0.0 )  break;
@


9.15
log
@ANSI structure initialization
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 9.14 91/06/30 03:02:49 mike Exp $ (BRL)";
a115 1
	*dpp = (genptr_t)lp;
d204 1
d208 1
@


9.14
log
@ANSI oops
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 9.13 91/06/14 08:25:32 mike Exp $ (BRL)";
d35 7
a41 7
	"%f",	1, "inten",	LIGHT_O(lt_intensity),	FUNC_NULL,
	"%f",	1, "angle",	LIGHT_O(lt_angle),	FUNC_NULL,
	"%f",	1, "fract",	LIGHT_O(lt_fraction),	FUNC_NULL,
	"%d",	1, "shadows",	LIGHT_O(lt_shadows),	FUNC_NULL,
	"%d",	1, "infinite",	LIGHT_O(lt_infinite),	FUNC_NULL,
	"%d",	1, "invisible",	LIGHT_O(lt_invisible),	FUNC_NULL,
	"",	0, (char *)0,	0,			FUNC_NULL
d53 2
a54 2
	"light",	0,		0,		MFI_NORMAL,
	light_setup,	light_render,	light_print,	light_free,
d56 2
a57 2
	(char *)0,	0,		0,
	0,		0,		0,		0
@


9.13
log
@Changed st_pathmat to st_matp
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 9.12 91/02/17 20:15:52 mike Exp $ (BRL)";
d176 1
a176 1
			matp = rt_identity;
@


9.12
log
@Check return code from rt_structparse()
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 9.11 91/01/05 03:09:11 mike Exp $ (BRL)";
d173 8
a180 3
	VSET( work, 0, 0, -1 );
	MAT4X3VEC( lp->lt_aim, stp->st_pathmat, work );
	VUNITIZE( lp->lt_aim );
@


9.11
log
@Converted to new format for fmt entry in structparse
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 9.10 90/12/12 16:35:05 butler Exp $ (BRL)";
d127 4
a130 1
	rt_structparse( matparm, light_parse, (char *)lp );
@


9.10
log
@modified to reflect changes in structparse format
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 9.9 90/12/08 08:58:08 butler Exp $ (BRL)";
d41 1
a41 1
	(char *)0, 0,(char *)0,	0,			FUNC_NULL
@


9.9
log
@changed material property parameter to be struct rt_vls
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 9.8 90/12/05 06:13:56 mike Exp $ (BRL)";
d35 7
a41 7
	"%f",	"inten",	LIGHT_O(lt_intensity),	FUNC_NULL,
	"%f",	"angle",	LIGHT_O(lt_angle),	FUNC_NULL,
	"%f",	"fract",	LIGHT_O(lt_fraction),	FUNC_NULL,
	"%d",	"shadows",	LIGHT_O(lt_shadows),	FUNC_NULL,
	"%d",	"infinite",	LIGHT_O(lt_infinite),	FUNC_NULL,
	"%d",	"invisible",	LIGHT_O(lt_invisible),	FUNC_NULL,
	(char *)0,(char *)0,	0,			FUNC_NULL
@


9.8
log
@Ooops, stray return statement.
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 9.7 90/11/14 14:46:06 mike Exp $ (BRL)";
d106 1
a106 1
char		*matparm;
d114 1
@


9.7
log
@If light list is unitialized, initialize it, before proceeding.
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 9.6 90/11/11 04:52:54 mike Exp $ (BRL)";
a322 1
		return;
@


9.6
log
@Invisible lights need special (non-mlib_free) cleanup.
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 9.5 90/11/10 19:36:29 mike Exp $ (BRL)";
d321 4
d520 4
@


9.5
log
@Modified light_specific structure to use rtlist.h macros.
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 9.4 90/11/02 03:16:40 mike Exp $ (BRL)";
d194 4
a197 2
	if( lp->lt_invisible )
		return(0);	/* don't show it */
d507 3
a509 1
 *  be cleaned up by mlib_free(), i.e., implicitly created lights.
d517 1
a517 1
		if( lp->lt_rp != REGION_NULL )  {
@


9.4
log
@Fixed error with freeing the light structure twice.
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 9.3 90/07/31 00:50:23 mike Exp $ (BRL)";
d26 1
d44 1
a44 1
struct light_specific *LightHeadp = LIGHT_NULL;		/* Linked list of lights */
d106 2
a107 2
char	*matparm;
char	**dpp;
d115 1
a115 1
	*dpp = (char *)lp;
d117 1
d146 1
a146 1
			rt_log("light_setup(%s) Infinite light sources not supported\n",
d152 8
a159 2
		/* XXX This radius is way too big */
		lp->lt_radius = MAGNITUDE( rad );
a177 5
	rt_log( "%s at (%g, %g, %g), aimed at (%g, %g, %g), angle=%g\n",
		lp->lt_name,
		lp->lt_pos[X], lp->lt_pos[Y], lp->lt_pos[Z],
		lp->lt_aim[X], lp->lt_aim[Y], lp->lt_aim[Z],
		lp->lt_angle );
d189 4
a192 2
	lp->lt_forw = LightHeadp;
	LightHeadp = lp;
d221 2
a222 23
	if( LightHeadp == LIGHT_NULL )  {
		rt_log("light_free(x%x), list is null\n", cp);
		return;
	}
	if( LightHeadp == light )  {
		LightHeadp = LightHeadp->lt_forw;
	} else {
		register struct light_specific *lp;	/* current light */
		register struct light_specific **llp;	/* last light lt_forw */

		llp = &LightHeadp;
		lp = LightHeadp;
		while( lp != LIGHT_NULL )  {
			if( lp == light )  {
				*llp = lp->lt_forw;
				goto found;
			}
			llp = &(lp->lt_forw);
			lp = lp->lt_forw;
		}
		rt_log("light_free:  unable to find light in list\n");
	}
found:
d227 1
d272 1
d290 4
a293 2
		lp->lt_forw = LightHeadp;
		LightHeadp = lp;
d316 1
a316 1
	register int	nlights = 0;
d319 1
a319 1
	for( lp = LightHeadp; lp; lp = lp->lt_forw )  {
d333 1
a333 1
	for( lp = LightHeadp; lp; lp = lp->lt_forw )  {
d337 14
d401 1
a487 1
	extern struct light_specific *LightHeadp;
d490 1
d493 1
a493 1
		return( 1 );
d495 25
a519 4
	if( LightHeadp )  {
		/* Explicit lights exist, somehow we missed (dither?) */
		VSETALL( ap->a_color, 0 );
		return(0);		/* light_visible = 0 */
a520 4
	/* No explicit light -- it's hard to hit */
	rt_log( "light: warning - invisible light not on list?!\n" );
	VSETALL( ap->a_color, 1 );
	return(1);			/* light_visible = 1 */
a521 3

/* Null function */
nullf() { return(0); }
@


9.3
log
@Fixed problem with light_free skipping over first light in list.
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: /m/cad/rt/RCS/sh_light.c,v 9.2 90/04/27 02:19:10 mike Exp $ (BRL)";
d213 2
d220 1
a220 1
	if( LightHeadp == (struct light_specific *)cp )  {
d229 1
a229 1
			if( lp == (struct light_specific *)cp )  {
d239 5
a243 3
	if( ((struct light_specific *)cp)->lt_name )
		rt_free( cp, "light name" );
	rt_free( cp, "light_specific" );
@


9.2
log
@Changed from using rt_rpp_tree to rt_bound_tree().
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: sh_light.c,v 9.1 89/05/19 05:59:33 mike Locked $ (BRL)";
d225 1
a225 1
		lp = LightHeadp->lt_forw;
@


9.1
log
@Release_3.5
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: sh_light.c,v 8.5 89/04/30 20:38:37 mike Exp $ (BRL)";
d136 2
a137 1
		vect_t	min_rpp, max_rpp, avg, rad;
d140 11
a150 7
		VSETALL( min_rpp,  INFINITY );
		VSETALL( max_rpp, -INFINITY );
		rt_rpp_tree( rp->reg_treetop, min_rpp, max_rpp );
		VADD2( avg, min_rpp, max_rpp );
		VSCALE( avg, avg, 0.5 );
		VMOVE( lp->lt_pos, avg );
		VSUB2( rad, max_rpp, avg );
@


8.5
log
@No longer depends on mathtab.h
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: sh_light.c,v 8.4 89/04/04 05:01:58 mike Locked $ (BRL)";
@


8.4
log
@Converted to new way of representing structure offsets.
@
text
@a0 1

d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: light.c,v 8.3 88/12/27 16:34:11 mike Locked $ (BRL)";
a27 1
#include "./mathtab.h"
@


8.3
log
@Converted matparse --> structparse
@
text
@d1 1
d20 1
a20 1
static char RCSlight[] = "@@(#)$Header: light.c,v 8.2 88/10/06 03:19:08 mike Locked $ (BRL)";
d33 1
d36 7
a42 7
	"%f",	"inten",	(stroff_t)&(LIGHT_NULL->lt_intensity),	FUNC_NULL,
	"%f",	"angle",	(stroff_t)&(LIGHT_NULL->lt_angle),	FUNC_NULL,
	"%f",	"fract",	(stroff_t)&(LIGHT_NULL->lt_fraction),	FUNC_NULL,
	"%d",	"shadows",	(stroff_t)&(LIGHT_NULL->lt_shadows),	FUNC_NULL,
	"%d",	"infinite",	(stroff_t)&(LIGHT_NULL->lt_infinite),	FUNC_NULL,
	"%d",	"invisible",	(stroff_t)&(LIGHT_NULL->lt_invisible),	FUNC_NULL,
	(char *)0,(char *)0,	(stroff_t)0,				FUNC_NULL
d126 1
a126 1
	rt_structparse( matparm, light_parse, (stroff_t)lp );
d200 1
a200 1
	rt_structprint(rp->reg_name, light_parse, (stroff_t)dp);
@


8.2
log
@Fixed bug which could cause 'regp' to be dereferenced without having
been initialized, in the error recovery case.
really Rel 3.0
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: light.c,v 8.1 88/10/05 00:32:44 mike Rel3_0 $ (BRL)";
d33 8
a40 8
struct matparse light_parse[] = {
	"inten",	(mp_off_ty)&(LIGHT_NULL->lt_intensity),	"%f",
	"angle",	(mp_off_ty)&(LIGHT_NULL->lt_angle),	"%f",
	"fract",	(mp_off_ty)&(LIGHT_NULL->lt_fraction),	"%f",
	"shadows",	(mp_off_ty)&(LIGHT_NULL->lt_shadows),	"%d",
	"infinite",	(mp_off_ty)&(LIGHT_NULL->lt_infinite),	"%d",
	"invisible",	(mp_off_ty)&(LIGHT_NULL->lt_invisible),	"%d",
	(char *)0,	(mp_off_ty)0,				(char *)0
d124 1
a124 1
	mlib_parse( matparm, light_parse, (mp_off_ty)lp );
d198 1
a198 1
	mlib_print(rp->reg_name, light_parse, (mp_off_ty)dp);
@


8.1
log
@Release_3.0
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: light.c,v 7.6 88/08/19 04:02:07 phil Exp $ (BRL)";
d383 2
a384 3
		rt_log("light_hit:  no hit out front?\n");
		light_visible = 0;
		goto out;
@


7.6
log
@no shadows on default lights (for speed)
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: light.c,v 7.5 88/06/21 00:56:01 phil Locked $ (BRL)";
@


7.5
log
@Implicit lights have become invisible lights.
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: light.c,v 7.4 88/05/14 02:28:11 mike Locked $ (BRL)";
d290 1
a290 1
		lp->lt_shadows = 1;		/* casts shadows */
@


7.4
log
@lint fixes
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: light.c,v 7.3 88/02/27 02:31:28 mike Locked $ (BRL)";
d39 1
a39 1
	"implicit",	(mp_off_ty)&(LIGHT_NULL->lt_implicit),	"%d",
d118 1
a118 1
	lp->lt_implicit = 0;		/* explicitly modeled */
d184 1
a184 1
	if( lp->lt_implicit )
d289 1
a289 1
		lp->lt_implicit = 1;		/* NOT explicitly modeled */
d397 2
a398 2
	/* or something futher away than a finite implicit light */
	if( lp->lt_implicit && !(lp->lt_infinite) ) {
d480 1
a480 1
	if( lp->lt_implicit || lp->lt_infinite ) {
d490 1
a490 1
	rt_log( "light: warning - implicit light not on list?!\n" );
@


7.3
log
@Changed implicit light radius from 10 to 0.1 mm.
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: light.c,v 7.2 88/01/26 05:39:53 mike Locked $ (BRL)";
d47 3
a49 2
HIDDEN int light_setup(), light_render(), light_print();
int light_free();
d94 1
d193 1
a193 1
HIDDEN int
d204 1
a204 1
int
d242 1
@


7.2
log
@infinite and implicit lights
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: light.c,v 7.1 87/11/02 23:53:53 phil Locked $ (BRL)";
d285 1
a285 1
		lp->lt_radius = 10.0;		/* 10 mm */
@


7.1
log
@Release 2.3
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: light.c,v 6.8 87/10/22 18:37:05 mike Exp $ (BRL)";
d36 1
d38 2
a39 1
	"fract",	(mp_off_ty)&(LIGHT_NULL->lt_fraction),	"%f",
d109 1
d116 1
a116 1
	lp->lt_explicit = 1;		/* explicitly modeled */
d119 2
d170 7
a176 1
	VUNITIZE( lp->lt_vec );
d182 3
d286 1
a286 1
		lp->lt_explicit = 0;		/* NOT explicitly modeled */
d290 2
d372 1
d386 3
a388 2
	/* Check to see if we hit a light source */
	if( ((struct mfuncs *)(regp->reg_mfuncs))->mf_render == light_render )  {
d394 11
d475 1
d477 4
d487 1
@


6.8
log
@Made default half-angle 180 degrees, instead of 90.
Spherical lights.
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: light.c,v 6.7 87/10/16 00:48:40 mike Locked $ (BRL)";
@


6.7
log
@Added setting and use of lt_name, for better multi-light debugging.
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: light.c,v 6.6 87/09/21 21:24:44 mike Locked $ (BRL)";
d115 1
a115 1
	lp->lt_angle = 90;		/* hemisphere emission by default */
@


6.6
log
@Added cosine shading to light sources
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: light.c,v 6.5 87/09/16 04:27:59 mike Exp $ (BRL)";
d116 1
d158 2
a159 1
	rt_log( "Light at (%g, %g, %g), aimed at (%g, %g, %g), angle=%g\n",
d216 2
d234 1
d265 3
@


6.5
log
@Looking at a directed light source now results in a reasonable
crescent shape -- the back side is half the intensity of the beam.
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: light.c,v 6.4 87/09/11 02:52:20 mike Locked $ (BRL)";
d60 6
d76 1
a76 1
	register fastf_t f, dot;
d78 4
d83 1
a83 1
	if( (dot= VDOT( lp->lt_aim, swp->sw_hit.hit_normal)) < lp->lt_cosangle )  {
d85 1
a85 1
		f = lp->lt_fraction * 0.5;
d88 1
a88 1
		f = lp->lt_fraction;
@


6.4
log
@Added new parameters to implicit light routine as well.
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: light.c,v 6.3 87/09/11 02:05:31 mike Locked $ (BRL)";
d49 1
a49 1
	"light",	0,		0,		0,
d72 2
a73 1
	if( (dot= -VDOT( ap->a_ray.r_dir, lp->lt_aim)) < lp->lt_cosangle )  {
@


6.3
log
@Added directional lights, and lights that don't cast shadows
for "fill lighting".
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: light.c,v 6.2 87/09/10 07:14:32 mike Locked $ (BRL)";
d249 2
d254 3
@


6.2
log
@Light visibility is now determined in viewshade();
supporting light hit&miss routines moved to light.c
plastic.c now merely implements Phong shading.
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: light.c,v 6.1 87/07/11 07:58:23 mike Locked $ (BRL)";
d35 2
d70 1
d72 8
a79 1
	VSCALE( swp->sw_color, lp->lt_color, lp->lt_fraction );
d94 2
d103 2
d107 3
a111 1
		register struct soltab *stp;
d118 1
d128 6
d135 6
d146 5
a150 1
	VPRINT( "Light at", lp->lt_pos );
@


6.1
log
@Release 2.0
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: light.c,v 5.4 87/06/27 06:46:04 phil Exp $ (BRL)";
d239 1
d243 2
a244 2
	int nlights = 0;
	fastf_t	inten = 0.0;
d264 5
d270 132
@


5.4
log
@rendering parameter changes
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: light.c,v 5.3 87/06/27 03:52:39 phil Locked $ (BRL)";
@


5.3
log
@ma_rgb -> ma_color, changed to new multi-light intensity scaling.
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: light.c,v 5.2 87/06/26 05:57:45 mike Locked $ (BRL)";
d60 1
a60 1
light_render( ap, pp, swp )
d64 1
d67 1
a67 1
		(struct light_specific *)pp->pt_regionp->reg_udata;
d78 1
a78 1
light_setup( rp )
d80 2
d86 1
a86 1
	rp->reg_udata = (char *)lp;
d91 1
a91 1
	mlib_parse( rp->reg_mater.ma_matparm, light_parse, (mp_off_ty)lp );
d132 1
a132 1
light_print( rp )
d134 1
d136 1
a136 1
	mlib_print(rp->reg_name, light_parse, (mp_off_ty)rp->reg_udata);
@


5.2
log
@Added struct shadework support, separated shaders from
reflect/refract code, allowed stacking of shaders.
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: light.c,v 5.1 87/06/24 22:14:22 mike Locked $ (BRL)";
d110 1
a110 3
		VSET( lp->lt_color, rp->reg_mater.ma_rgb[0]/255.,
			rp->reg_mater.ma_rgb[1]/255.,
			rp->reg_mater.ma_rgb[2]/255. );
d225 9
d246 2
a247 1
		inten += lp->lt_intensity;
@


5.1
log
@Release 1.24
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: light.c,v 1.4 87/05/31 04:35:16 mike Exp $ (BRL)";
d47 1
a47 1
	"light",	0,		0,
d60 4
a63 3
light_render( ap, pp )
register struct application *ap;
register struct partition *pp;
d68 1
a68 1
	VSCALE( ap->a_color, lp->lt_color, lp->lt_fraction );
@


1.4
log
@Changed to using a non-physical exposure calculation to get
better pictures.  Switching to energy will make this correct.
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: light.c,v 1.3 87/05/30 04:20:27 mike Exp $ (BRL)";
@


1.3
log
@Fixed bug in computing relative intensities of light source -vs-
ambient term.
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: light.c,v 1.2 87/03/23 23:48:33 mike Locked $ (BRL)";
d242 3
a244 1
	inten *= (1 + AmbientIntensity);
@


1.2
log
@Revised for new material property interface.
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: light.c,v 1.1 87/03/17 20:21:12 mike Exp $ (BRL)";
d236 2
d240 4
a243 1
	inten *= (1 - AmbientIntensity);
@


1.1
log
@Initial revision
@
text
@d19 1
a19 1
static char RCSlight[] = "@@(#)$Header: light.c,v 4.1 86/12/29 03:48:07 mike Rel1 $ (BRL)";
d43 2
d46 8
d59 1
d75 1
a75 1
int
a81 1
	rp->reg_ufunc = light_render;
a118 3
	if(rdebug&RDEBUG_MATERIAL)
		mlib_print(rp->reg_name, light_parse, (mp_off_ty)lp);

d124 44
@
