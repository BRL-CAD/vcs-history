head	11.22;
access;
symbols
	ansi-20040405-merged:11.18.2.2
	postmerge-20040405-ansi:11.20
	premerge-20040404-ansi:11.19
	postmerge-autoconf:11.19
	autoconf-freeze:11.18.10.2
	premerge-autoconf:11.19
	ansi-20040316-freeze:11.18.2.1
	postmerge-20040315-windows:11.19
	premerge-20040315-windows:11.19
	windows-20040315-freeze:11.18.4.1
	autoconf-20031203:11.18
	autoconf-20031202:11.18
	autoconf-branch:11.18.0.10
	phong-branch:11.18.0.8
	photonmap-branch:11.18.0.6
	rel-6-1-DP:11.18
	windows-branch:11.18.0.4
	rel-6-0-2:11.16
	ansi-branch:11.18.0.2
	rel-6-0-1-branch:11.16.0.2
	hartley-6-0-post:11.17
	hartley-6-0-pre:11.16
	rel-6-0-1:11.16
	rel-6-0:11.16
	rel-5-4:11.13
	offsite-5-3-pre:11.16
	rel-5-3:11.13
	rel-5-2:11.13
	rel-5-1-branch:11.13.0.2
	rel-5-1:11.13
	rel-5-0:11.11
	rel-5-0-beta:11.9
	rel-4-5:11.7
	ctj-4-5-post:11.5
	ctj-4-5-pre:11.5
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1;
locks; strict;
comment	@ * @;


11.22
date	2004.05.21.18.07.27;	author morrison;	state dead;
branches;
next	11.21;

11.21
date	2004.05.10.15.30.45;	author erikg;	state Exp;
branches;
next	11.20;

11.20
date	2004.04.05.07.43.37;	author morrison;	state Exp;
branches;
next	11.19;

11.19
date	2004.02.02.17.39.14;	author morrison;	state Exp;
branches;
next	11.18;

11.18
date	2002.08.20.17.07.51;	author jra;	state Exp;
branches
	11.18.2.1
	11.18.4.1
	11.18.10.1;
next	11.17;

11.17
date	2002.08.15.20.55.04;	author hartley;	state Exp;
branches;
next	11.16;

11.16
date	2000.10.19.19.19.45;	author butler;	state Exp;
branches;
next	11.15;

11.15
date	2000.08.20.01.27.48;	author butler;	state Exp;
branches;
next	11.14;

11.14
date	2000.07.25.16.40.38;	author butler;	state Exp;
branches;
next	11.13;

11.13
date	2000.02.19.21.05.02;	author butler;	state Exp;
branches;
next	11.12;

11.12
date	99.10.30.03.06.24;	author butler;	state Exp;
branches;
next	11.11;

11.11
date	99.07.02.22.20.41;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	99.07.01.20.08.47;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	98.09.22.01.29.55;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	98.06.30.22.54.18;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	97.12.31.09.01.40;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	97.11.25.22.16.43;	author butler;	state Exp;
branches;
next	11.5;

11.5
date	96.08.31.08.46.01;	author butler;	state Exp;
branches;
next	11.4;

11.4
date	96.08.31.08.29.28;	author butler;	state Exp;
branches;
next	11.3;

11.3
date	96.08.30.00.08.21;	author butler;	state Exp;
branches;
next	11.2;

11.2
date	95.10.20.04.43.53;	author butler;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.01.09;	author mike;	state Rel4_4;
branches;
next	10.3;

10.3
date	94.11.08.04.13.35;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	94.08.11.02.26.05;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.42.11;	author mike;	state Rel4_0;
branches;
next	9.6;

9.6
date	91.07.06.00.35.21;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	91.02.17.20.15.54;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	91.01.05.03.09.14;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	90.12.12.16.35.08;	author butler;	state Exp;
branches;
next	9.2;

9.2
date	90.12.08.08.58.12;	author butler;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.59.40;	author mike;	state Rel3_5;
branches;
next	1.2;

1.2
date	89.04.04.05.02.04;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	89.04.03.20.21.05;	author phil;	state Exp;
branches;
next	;

11.18.2.1
date	2002.09.19.18.01.25;	author morrison;	state Exp;
branches;
next	11.18.2.2;

11.18.2.2
date	2004.03.17.21.18.32;	author morrison;	state Exp;
branches;
next	;

11.18.4.1
date	2004.03.11.23.43.02;	author morrison;	state Exp;
branches;
next	;

11.18.10.1
date	2004.02.12.18.38.49;	author erikg;	state Exp;
branches;
next	11.18.10.2;

11.18.10.2
date	2004.03.15.14.07.13;	author erikg;	state Exp;
branches;
next	;


desc
@A shader for a collection of points (e.g. stars)
@


11.22
log
@moved to src/
@
text
@/*
 *			P O I N T S . C
 *
 *  Reads a file of u,v point locations and associated RGB color values.
 *  For each u,v texture mapping cell, this routine fills in the color
 *  of the "brightest" point contained in that cell (if any).
 *
 *  This routine was born in order to environment map the Yale Bright
 *  Star catalog data without under or over sampling the point sources.
 *  It was soon realized that making it "star" specific limited its
 *  usefulness.
 *
 *  Author -
 *	Phillip Dykstra
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1989-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/liboptical/sh_points.c,v 11.21 2004/05/10 15:30:45 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef HAVE_STRING_H
#include <string.h>
#endif
#include <math.h>
#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "fb.h"
#include "spm.h"
#include "shadefuncs.h"
#include "shadework.h"
#include "rtprivate.h"

#define PT_NAME_LEN 128
struct points_specific {
	char	pt_file[PT_NAME_LEN];	/* Filename */
	int	pt_size;	/* number of bins around equator */
	spm_map_t *pt_map;	/* stuff */
};
#define POINTS_NULL	((struct points_specific *)0)
#define POINTS_O(m)	offsetof(struct points_specific, m)

struct bu_structparse points_parse[] = {
	{"%s",	PT_NAME_LEN, "file", bu_offsetofarray(struct points_specific, pt_file),	BU_STRUCTPARSE_FUNC_NULL },
	{"%d",	1, "size",		POINTS_O(pt_size),	BU_STRUCTPARSE_FUNC_NULL },
	{"%d",	1, "w",			POINTS_O(pt_size),	BU_STRUCTPARSE_FUNC_NULL },
	{"",	0, (char *)0,		0,			BU_STRUCTPARSE_FUNC_NULL }
};

HIDDEN int	points_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip), points_render(struct application *ap, struct partition *partp, struct shadework *swp, char *dp);
HIDDEN void	points_print(register struct region *rp, char *dp), points_mfree(char *cp);

struct mfuncs points_mfuncs[] = {
	{MF_MAGIC,	"points",	0,		MFI_UV,		0,
	points_setup,	points_render,	points_print,	points_mfree },

	{0,		(char *)0,	0,		0,		0,
	0,		0,		0,		0 }
};

HIDDEN
struct points {
	fastf_t	u;			/* u location */
	fastf_t	v;			/* v location */
	vect_t	color;			/* color of point */
	struct points	*next;		/* next point in list */
};

/*
 *			P O I N T S _ S E T U P
 *
 *  Returns -
 *	<0	failed
 *	>0	success
 */
HIDDEN int
points_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip)
                           
             	         
    	      
                             
                                /* New since 4.4 release */
{
	register struct points_specific *ptp;
	char	buf[513];
	FILE	*fp;

	BU_CK_VLS( matparm );
	BU_GETSTRUCT( ptp, points_specific );
	*dpp = (char *)ptp;

	/* get or default shader parameters */
	ptp->pt_file[0] = '\0';
	ptp->pt_size = -1;
	if (bu_struct_parse( matparm, points_parse, (char *)ptp ) < 0 )  {
		bu_free( (char *)ptp, "points_specific" );
		return(-1);
	}
	if (ptp->pt_size < 0 )
		ptp->pt_size = 512;
	if (ptp->pt_file[0] == '\0' )
		strcpy( ptp->pt_file, "points.ascii" );

	/* create a spherical data structure to bin point lists into */
	if ((ptp->pt_map = spm_init( ptp->pt_size, sizeof(struct points) )) == SPM_NULL )
		goto fail;

	/* read in the data */
	if ((fp = fopen(ptp->pt_file, "r")) == NULL ) {
		bu_log("points_setup: can't open \"%s\"\n", ptp->pt_file);
		goto fail;
	}
	while( fgets(buf,512,fp) != NULL ) {
		double	u, v, mag;
		struct points	*headp, *pp;

		if (buf[0] == '#' )
			continue;		/* comment */

		pp = (struct points *)bu_calloc(1, sizeof(struct points), "point");
		sscanf( buf, "%lf%lf%lf", &u, &v, &mag );
		pp->u = u;
		pp->v = v;
		pp->color[0] = mag;
		pp->color[1] = mag;
		pp->color[2] = mag;

		/* find a home for it */
		headp = (struct points *)spm_get( ptp->pt_map, u, v );
		pp->next = headp->next;
		headp->next = pp;
	}
	(void)fclose(fp);

	return(1);
fail:
	bu_free( (char *)ptp, "points_specific" );
	return(-1);
}

/*
 *  			P O I N T S _ R E N D E R
 *  
 *  Given a u,v coordinate within the texture ( 0 <= u,v <= 1.0 ),
 *  and a "size" of the pixel being rendered (du, dv), fill in the
 *  color of the "brightest" point (if any) within that region.
 */
HIDDEN int
points_render(struct application *ap, struct partition *partp, struct shadework *swp, char *dp)
{
	register struct points_specific *ptp =
		(struct points_specific *)dp;
	register spm_map_t	*mapp;
	fastf_t	umin, umax, vmin, vmax;
	int	xmin, xmax, ymin, ymax;
	register int	x, y;
	register struct points	*pp;
	fastf_t	mag;

swp->sw_uv.uv_du = ap->a_diverge;
swp->sw_uv.uv_dv = ap->a_diverge;
	/*bu_log( "du,dv = %g %g\n", swp->sw_uv.uv_du, swp->sw_uv.uv_dv);*/

	/* compute and clip bounds in u,v space */
	umin = swp->sw_uv.uv_u - swp->sw_uv.uv_du;
	umax = swp->sw_uv.uv_u + swp->sw_uv.uv_du;
	vmin = swp->sw_uv.uv_v - swp->sw_uv.uv_dv;
	vmax = swp->sw_uv.uv_v + swp->sw_uv.uv_dv;
	if (umin < 0 )  umin = 0;
	if (vmin < 0 )  vmin = 0;
	if (umax > 1 )  umax = 1;
	if (vmax > 1 )  vmax = 1;

	mapp = ptp->pt_map;

	mag = 0;
	ymin = vmin * mapp->ny;
	ymax = vmax * mapp->ny;
	/* for each latitude band */
	for( y = ymin; y < ymax; y++ ) {
		xmin = umin * mapp->nx[y];
		xmax = umax * mapp->nx[y];
		/* for each bin spanned in that band */
		for( x = xmin; x < xmax; x++ ) {
			pp = (struct points *)&(mapp->xbin[y][x*mapp->elsize]);
			while( pp != NULL ) {
				if ( pp->u < umax && pp->u >= umin
				  && pp->v < vmax && pp->v >= vmin
				  && pp->color[0] > mag ) {
					mag = pp->color[0];
				}
				pp = pp->next;
			}
		}
	}

	/*bu_log( "points_render ([%g %g][%g %g]) = %g\n",
		umin, umax, vmin, vmax, mag );*/

	if (mag == 0 ) {
		VSET( swp->sw_color, 0, 0, 0 );
	} else {
		VSET( swp->sw_color, mag/255.0, mag/255.0, mag/255.0 );
	}

	return(1);
}

/*
 *			P O I N T S _ P R I N T
 */
HIDDEN void
points_print(register struct region *rp, char *dp)
{
	bu_struct_print("points_setup", points_parse, (char *)dp);
	/* Should be more here */
}

HIDDEN void
points_mfree(char *cp)
{
	/* XXX - free linked lists in every bin! */
	spm_free( (spm_map_t *)cp );
}
@


11.21
log
@change conf.h to a wrapped config.h
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/liboptical/sh_points.c,v 11.20 2004/04/05 07:43:37 morrison Exp $ (BRL)";
@


11.20
log
@merge of ansi-6-0-branch into HEAD
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d29 5
a33 1
#include "conf.h"
@


11.19
log
@update copyright to include span through 2003
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_points.c,v 11.18 2002/08/20 17:07:51 jra Exp $ (BRL)";
d61 2
a62 2
HIDDEN int	points_setup(), points_render();
HIDDEN void	points_print(), points_mfree();
d88 6
a93 6
points_setup( rp, matparm, dpp, mfp, rtip )
register struct region *rp;
struct bu_vls	*matparm;
char	**dpp;
struct mfuncs           *mfp;
struct rt_i             *rtip;  /* New since 4.4 release */
d160 1
a160 5
points_render( ap, partp, swp, dp )
struct application *ap;
struct partition *partp;
struct shadework	*swp;
char	*dp;
d224 1
a224 3
points_print( rp, dp )
register struct region *rp;
char	*dp;
d231 1
a231 2
points_mfree( cp )
char *cp;
@


11.18
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d22 1
a22 1
 *	This software is Copyright (C) 1989 by the United States Army.
d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_points.c,v 11.16 2000/10/19 19:19:45 butler Exp $ (BRL)";
@


11.18.4.1
log
@sync to HEAD...
@
text
@d22 1
a22 1
 *	This software is Copyright (C) 1989-2004 by the United States Army.
d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/liboptical/sh_points.c,v 11.19 2004/02/02 17:39:14 morrison Exp $ (BRL)";
@


11.18.10.1
log
@merge from HEAD
@
text
@d22 1
a22 1
 *	This software is Copyright (C) 1989-2004 by the United States Army.
d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_points.c,v 11.19 2004/02/02 17:39:14 morrison Exp $ (BRL)";
@


11.18.10.2
log
@merge from head
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_points.c,v 11.18.10.1 2004/02/12 18:38:49 erikg Exp $ (BRL)";
@


11.18.2.1
log
@Initial ANSIfication
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_points.c,v 11.18 2002/08/20 17:07:51 jra Exp $ (BRL)";
d61 2
a62 2
HIDDEN int	points_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip), points_render(struct application *ap, struct partition *partp, struct shadework *swp, char *dp);
HIDDEN void	points_print(register struct region *rp, char *dp), points_mfree(char *cp);
d88 6
a93 6
points_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip)
                           
             	         
    	      
                             
                                /* New since 4.4 release */
d160 5
a164 1
points_render(struct application *ap, struct partition *partp, struct shadework *swp, char *dp)
d228 3
a230 1
points_print(register struct region *rp, char *dp)
d237 2
a238 1
points_mfree(char *cp)
@


11.18.2.2
log
@sync branch with HEAD
@
text
@d22 1
a22 1
 *	This software is Copyright (C) 1989-2004 by the United States Army.
d26 1
a26 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.17
log
@Converted from K&R to ANSI C - RFH
@
text
@d61 2
a62 2
HIDDEN int	points_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip), points_render(struct application *ap, struct partition *partp, struct shadework *swp, char *dp);
HIDDEN void	points_print(register struct region *rp, char *dp), points_mfree(char *cp);
d88 6
a93 6
points_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip)
                           
             	         
    	      
                             
                                /* New since 4.4 release */
d160 5
a164 1
points_render(struct application *ap, struct partition *partp, struct shadework *swp, char *dp)
d228 3
a230 1
points_print(register struct region *rp, char *dp)
d237 2
a238 1
points_mfree(char *cp)
@


11.16
log
@Changes to compile under RedHat 7.0
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_points.c,v 11.15 2000/08/20 01:27:48 butler Exp $ (BRL)";
d61 2
a62 2
HIDDEN int	points_setup(), points_render();
HIDDEN void	points_print(), points_mfree();
d88 6
a93 6
points_setup( rp, matparm, dpp, mfp, rtip )
register struct region *rp;
struct bu_vls	*matparm;
char	**dpp;
struct mfuncs           *mfp;
struct rt_i             *rtip;  /* New since 4.4 release */
d160 1
a160 5
points_render( ap, partp, swp, dp )
struct application *ap;
struct partition *partp;
struct shadework	*swp;
char	*dp;
d224 1
a224 3
points_print( rp, dp )
register struct region *rp;
char	*dp;
d231 1
a231 2
points_mfree( cp )
char *cp;
@


11.15
log
@Eliminate compilation warnings, enhancements to sh_light.c
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_points.c,v 11.14 2000/07/25 16:40:38 butler Exp $ (BRL)";
d32 3
@


11.14
log
@Changes to use rtprivate.h instead of ../rt/rdebug.h
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_points.c,v 11.13 2000/02/19 21:05:02 butler Exp $ (BRL)";
@


11.13
log
@Changes to support movement of CLAMP() macro into vmath.h
Altered "if( " statements to "if (" for readability.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_points.c,v 11.12 1999/10/30 03:06:24 butler Exp $ (BRL)";
d40 1
a40 1
#include "../rt/rdebug.h"
@


11.12
log
@Moved mathtab/rand_half from rt into libbn
Expanded structparse to include description and default
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_points.c,v 11.11 1999/07/02 22:20:41 mike Exp $ (BRL)";
d103 1
a103 1
	if( bu_struct_parse( matparm, points_parse, (char *)ptp ) < 0 )  {
d107 1
a107 1
	if( ptp->pt_size < 0 )
d109 1
a109 1
	if( ptp->pt_file[0] == '\0' )
d113 1
a113 1
	if( (ptp->pt_map = spm_init( ptp->pt_size, sizeof(struct points) )) == SPM_NULL )
d117 1
a117 1
	if( (fp = fopen(ptp->pt_file, "r")) == NULL ) {
d125 1
a125 1
		if( buf[0] == '#' )
d181 4
a184 4
	if( umin < 0 )  umin = 0;
	if( vmin < 0 )  vmin = 0;
	if( umax > 1 )  umax = 1;
	if( vmax > 1 )  vmax = 1;
d199 1
a199 1
				if(  pp->u < umax && pp->u >= umin
d212 1
a212 1
	if( mag == 0 ) {
@


11.11
log
@
Removed dependence on compat4.h
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_points.c,v 11.10 1999/07/01 20:08:47 mike Exp $ (BRL)";
a39 1
#include "../rt/mathtab.h"
@


11.10
log
@
compat4
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/liboptical/sh_points.c,v 11.9 1998/09/22 01:29:55 mike Exp $ (BRL)";
d53 4
a56 4
	{"%s",	PT_NAME_LEN, "file", bu_offsetofarray(struct points_specific, pt_file),	FUNC_NULL },
	{"%d",	1, "size",		POINTS_O(pt_size),	FUNC_NULL },
	{"%d",	1, "w",			POINTS_O(pt_size),	FUNC_NULL },
	{"",	0, (char *)0,		0,			FUNC_NULL }
@


11.9
log
@Moved optical shaders from rt/ to liboptical/
The only modifications involved moving and splitting
rt/material.h into h/shadefuncs.h and h/shadework.h,
and in changing the calling sequence to mlib_setup() in rt/material.c

Now the only shader function called directly by RT is
in liboptical/init.c: optical_shader_init().
It adds all the individual shaders to the "mfuncs" shader list.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rt/sh_points.c,v 11.8 1998/06/30 22:54:18 mike Exp $ (BRL)";
d53 1
a53 1
	{"%s",	PT_NAME_LEN, "file", offsetofarray(struct points_specific, pt_file),	FUNC_NULL },
d88 1
a88 1
struct rt_vls	*matparm;
d97 2
a98 2
	RT_VLS_CHECK( matparm );
	GETSTRUCT( ptp, points_specific );
d105 1
a105 1
		rt_free( (char *)ptp, "points_specific" );
d119 1
a119 1
		rt_log("points_setup: can't open \"%s\"\n", ptp->pt_file);
d129 1
a129 1
		pp = (struct points *)rt_calloc(1, sizeof(struct points), "point");
d146 1
a146 1
	rt_free( (char *)ptp, "points_specific" );
d175 1
a175 1
	/*rt_log( "du,dv = %g %g\n", swp->sw_uv.uv_du, swp->sw_uv.uv_dv);*/
d210 1
a210 1
	/*rt_log( "points_render ([%g %g][%g %g]) = %g\n",
@


11.8
log
@Can't make "struct mfuncs" a CONST, because the forward link needs
to be filled in at runtime, and some compilers put CONST data into
read-only pages (like FreeBSD).
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/rt/sh_points.c,v 11.7 1997/12/31 09:01:40 mike Exp $ (BRL)";
d38 4
a41 3
#include "./material.h"
#include "./mathtab.h"
#include "./rdebug.h"
@


11.7
log
@Required magic number to be first in mfunc table,
consistent with all other BRL-CAD magic numbers.
Required magic number to be initialized at compile time.
Added code to check the magic numbers.
Made the xxx_mfunc arrays CONST, so they can't get trashed by
runtime runaway pointer problems.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_points.c,v 11.6 1997/11/25 22:16:43 butler Exp mike $ (BRL)";
d61 1
a61 1
CONST struct mfuncs points_mfuncs[] = {
@


11.6
log
@updated all shaders so that _setup had mfp and rtip parameters
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_points.c,v 11.5 1996/08/31 08:46:01 butler Exp butler $ (BRL)";
d61 2
a62 2
struct mfuncs points_mfuncs[] = {
	{"points",	0,		0,		MFI_UV,		0,
d65 1
a65 1
	{(char *)0,	0,		0,		0,		0,
@


11.5
log
@bu_struct_print
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_points.c,v 11.4 1996/08/31 08:29:28 butler Exp butler $ (BRL)";
d85 1
a85 1
points_setup( rp, matparm, dpp )
d89 2
@


11.4
log
@bu_struct_parse
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_points.c,v 11.3 1996/08/30 00:08:21 butler Exp butler $ (BRL)";
d227 1
a227 1
	bu_structprint("points_setup", points_parse, (char *)dp);
@


11.3
log
@structparse moved to libbu
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_points.c,v 11.2 1995/10/20 04:43:53 butler Exp butler $ (BRL)";
d101 1
a101 1
	if( bu_structparse( matparm, points_parse, (char *)ptp ) < 0 )  {
@


11.2
log
@edited mfuncs table to account for new "mf_flags" element in struct mfuncs.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_points.c,v 11.1 1995/01/04 10:01:09 mike Rel4_4 butler $ (BRL)";
d51 1
a51 1
struct structparse points_parse[] = {
d101 1
a101 1
	if( rt_structparse( matparm, points_parse, (char *)ptp ) < 0 )  {
d227 1
a227 1
	rt_structprint("points_setup", points_parse, (char *)dp);
@


11.1
log
@Release_4.4
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_points.c,v 10.3 94/11/08 04:13:35 mike Exp $ (BRL)";
d62 1
a62 1
	{"points",	0,		0,		MFI_UV,
d65 1
a65 1
	{(char *)0,	0,		0,		0,
@


10.3
log
@Irix 6
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_points.c,v 10.2 94/08/11 02:26:05 gdurf Exp Locker: mike $ (BRL)";
@


10.2
log
@Added include of conf.h
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_points.c,v 10.1 1991/10/12 06:42:11 mike Rel4_0 gdurf $ (BRL)";
a167 1
	register unsigned char	*cp;
@


10.1
log
@Release_4.0
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_points.c,v 9.6 91/07/06 00:35:21 mike Exp $ (BRL)";
d28 2
@


9.6
log
@ANSI structure initialization
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_points.c,v 9.5 91/02/17 20:15:54 mike Exp $ (BRL)";
@


9.5
log
@Check return code from rt_structparse()
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_points.c,v 9.4 91/01/05 03:09:14 mike Exp $ (BRL)";
d50 4
a53 4
	"%s",	PT_NAME_LEN, "file", offsetofarray(struct points_specific, pt_file),	FUNC_NULL,
	"%d",	1, "size",		POINTS_O(pt_size),	FUNC_NULL,
	"%d",	1, "w",			POINTS_O(pt_size),	FUNC_NULL,
	"",	0, (char *)0,		0,			FUNC_NULL
d60 2
a61 2
	"points",	0,		0,		MFI_UV,
	points_setup,	points_render,	points_print,	points_mfree,
d63 2
a64 2
	(char *)0,	0,		0,
	0,		0,		0,		0
@


9.4
log
@Converted to new format for fmt entry in structparse
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_points.c,v 9.3 90/12/12 16:35:08 butler Exp $ (BRL)";
d99 4
a102 1
	rt_structparse( matparm, points_parse, (char *)ptp );
@


9.3
log
@modified to reflect changes in structparse format
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_points.c,v 9.2 90/12/08 08:58:12 butler Exp $ (BRL)";
d53 1
a53 1
	(char *)0, 0, (char *)0,	0,			FUNC_NULL
@


9.2
log
@changed material property parameter to be struct rt_vls
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: /m/cad/rt/RCS/sh_points.c,v 9.1 89/05/19 05:59:40 mike Rel3_5 $ (BRL)";
d40 1
d42 1
a42 1
	char	pt_file[128];	/* Filename */
d50 4
a53 4
	"%s",	"file",		offsetofarray(struct points_specific, pt_file),	FUNC_NULL,
	"%d",	"size",		POINTS_O(pt_size),	FUNC_NULL,
	"%d",	"w",		POINTS_O(pt_size),	FUNC_NULL,
	(char *)0,(char *)0,	0,			FUNC_NULL
@


9.1
log
@Release_3.5
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: sh_points.c,v 1.2 89/04/04 05:02:04 mike Exp $ (BRL)";
d84 1
a84 1
char	*matparm;
d91 1
@


1.2
log
@Converted to new way of representing structure offsets.
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: points.c,v 1.1 89/04/03 20:21:05 mike Locked $ (BRL)";
@


1.1
log
@First cut.  Not debugged yet (need to fix divergence stuff)
@
text
@d26 1
a26 1
static char RCSid[] = "@@(#)$Header: points.c,v 1.1 88/12/27 16:35:08 phil Exp $ (BRL)";
d46 1
d49 4
a52 4
	"%s",	"file",		(stroff_t)(POINTS_NULL->pt_file),	FUNC_NULL,
	"%d",	"size",		(stroff_t)&(POINTS_NULL->pt_size),	FUNC_NULL,
	"%d",	"w",		(stroff_t)&(POINTS_NULL->pt_size),	FUNC_NULL,
	(char *)0,(char *)0,	(stroff_t)0,				FUNC_NULL
d97 1
a97 1
	rt_structparse( matparm, points_parse, (stroff_t)ptp );
d221 1
a221 1
	rt_structprint("points_setup", points_parse, (stroff_t)dp);
@
