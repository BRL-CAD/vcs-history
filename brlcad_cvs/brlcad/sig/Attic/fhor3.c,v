head	11.7;
access;
symbols
	ansi-20040405-merged:11.4.2.1
	postmerge-20040405-ansi:11.5
	premerge-20040404-ansi:11.4
	postmerge-autoconf:11.4
	autoconf-freeze:11.4
	premerge-autoconf:11.4
	postmerge-20040315-windows:11.4
	premerge-20040315-windows:11.4
	windows-20040315-freeze:11.4
	autoconf-20031203:11.4
	autoconf-20031202:11.4
	autoconf-branch:11.4.0.10
	phong-branch:11.4.0.8
	photonmap-branch:11.4.0.6
	rel-6-1-DP:11.4
	windows-branch:11.4.0.4
	rel-6-0-2:11.2
	ansi-branch:11.4.0.2
	rel-6-0-1-branch:11.2.0.2
	hartley-6-0-post:11.3
	hartley-6-0-pre:11.2
	rel-6-0-1:11.2
	rel-6-0:11.2
	rel-5-4:11.1
	offsite-5-3-pre:11.1
	rel-5-3:11.1
	rel-5-2:11.1
	rel-5-1-branch:11.1.0.2
	rel-5-1:11.1
	rel-5-0:11.1
	rel-5-0-beta:11.1
	rel-4-5:11.1
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.7
date	2004.05.21.16.45.05;	author morrison;	state dead;
branches;
next	11.6;

11.6
date	2004.05.10.15.30.50;	author erikg;	state Exp;
branches;
next	11.5;

11.5
date	2004.04.05.05.46.00;	author morrison;	state Exp;
branches;
next	11.4;

11.4
date	2002.08.20.17.08.43;	author jra;	state Exp;
branches
	11.4.2.1;
next	11.3;

11.3
date	2002.08.15.20.55.54;	author hartley;	state Exp;
branches;
next	11.2;

11.2
date	2001.08.10.21.22.45;	author morrison;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.19.14;	author mike;	state Rel4_4;
branches;
next	10.2;

10.2
date	94.08.23.18.16.51;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.51.09;	author mike;	state Rel4_0;
branches;
next	1.2;

1.2
date	91.07.02.02.15.56;	author butler;	state Exp;
branches;
next	1.1;

1.1
date	90.10.25.20.13.48;	author butler;	state Exp;
branches;
next	;

11.4.2.1
date	2002.09.19.18.02.24;	author morrison;	state Exp;
branches;
next	;


desc
@safety check in
@


11.7
log
@moved to src/sig/
@
text
@/*
 * Floating horizon 3D plotting routines.
 * THIS VERSION SKIPS INTERSECTIONS AND CHECKS POINTS DRAWN!!
 *
 * The terminology throughout is X across, Y up, Z toward you.
 *
 * Ref: "Procedural Elements for Computer Graphics,"
 *       D. F. Rogers.
 */
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include <stdio.h>
#include <math.h>		/* XXX - temp debug */
#include "machine.h"
#include "fb.h"

#define	MYMETHOD	on

#define	MAX(x,y)	(((x)>(y))?(x):(y))
#define	MIN(x,y)	(((x)<(y))?(x):(y))

#define	HSCREEN	1024	/* Max Horizontal screen resolution */
#define	VSCREEN	1024	/* Max Vertical screen resolution   */

#define	INVISIBLE	0
#define	ABOVE		1
#define	BELOW		-1

/* Max and Min horizon holders */
static	int	upper[HSCREEN], lower[HSCREEN];
static	int	Xleft, Yleft, Xright, Yright;		/* XXX */

FBIO	*fbp;	/* XXX - debug */

fhinit(void)
{
	int	i;

	Xleft = Yleft = Xright = Yright = -1;

	/* Set initial horizons */
	for( i = 0; i < HSCREEN; i++ ) {
		upper[ i ] = 0;
		lower[ i ] = VSCREEN;
	}
}

/*
 * Add another Z cut to the display.
 *  This one goes "behind" the last one.
 */
fhnewz(int *f, int num)
{
	int	x, y, Xprev, Yprev, Xi, Yi;
	int	Previously, Currently;

	/* Init previous X and Y values */
	Xprev = 0;
	Yprev = f[ 0 ];
	/* VIEWING XFORM */

	/* Fill left side */
	Efill( );
/*	Previously = fhvis( x, y );		/* <<< WHAT ARE X AND Y? */
	Previously = fhvis( Xprev, Yprev );		/* <<< WHAT ARE X AND Y? */

	/* Do each point in Z plane */
	for( x = 0; x < num; x++ ) {
		y = f[x];
		/* VIEWING XFORM */

		/* Check visibility and fill horizon */
		Currently = fhvis( x, y );
		if( Currently == Previously ) {
			if( Currently != INVISIBLE ) {
				/*
				 * Current and Previous point both
				 *  visible on same side of horizon.
				 */
				Draw( Xprev, Yprev, x, y );
			}
			/* else both invisible */
		} else {
			/*
			 * Visibility has changed.
			 * Draw line checking visibility along the way.
			 */
			Draw( Xprev, Yprev, x, y );
		} /* end changed visibility */

		/*
		 * Reset "previous" point values for next iteration.
		 */
		Previously = Currently;
		Xprev = x;
		Yprev = y;
	}

	/* Fill Right Side */
	Efill( );
}

/*
 * INTERNAL Visibility routine.
 *  Answers, Is Y visible at point X?
 *
 * Returns: 0 if invisible
 *	    1 if visible above upper horizon.
 *	   -1 if visible below lower horizon.
 */
fhvis(int x, int y)
{
	/* See if hidden behind horizons */
	if( y < upper[x] && y > lower[x] )
		return( INVISIBLE );

	if( y >= upper[x] )
		return( ABOVE );

	return( BELOW );
}

/*
 * INTERNAL Edge fill routine.
 * NOT DONE YET.
 */
Efill(void)
{
}

/*
 * Fill the upper and lower horizon arrays from x1 to x2
 *  with a line spanning (x1,y1) to (x2,y2).
 */
Horizon(int x1, int y1, int x2, int y2)
{
	int	xinc, x, y;
	double	slope;

	xinc = sign( x2 - x1 );
	if( xinc == 0 ) {
		/* Vertical line */
		upper[x2] = MAX( upper[x2], y2 );
		lower[x2] = MIN( lower[x2], y2 );
	} else {
		slope = (y2 - y1) / (x2 - x1);
		for( x = x1; x <= x2; x += xinc ) {
			y = slope * (x - x1) + y1;
			upper[x] = MAX( upper[x], y );
			lower[x] = MIN( lower[x], y );
		}
	}
}

/*
 * Find the intersection (xi,yi) between the line (x1,y1)->(x2,y2)
 *  and the horizon hor[].
 */
Intersect(int x1, int y1, int x2, int y2, int *hor, int *xi, int *yi)
{
	int	xinc, ysign, denom;
	int	slope;

/*
printf("Intersect( (%3d,%3d)->(%3d,%3d) & (%3d,%3d)->(%3d,%3d) ) = ", x1, y1, x2, y2, x1, hor[x1], x2, hor[x2] );
fflush( stdout );
*/
	xinc = sign( x2 - x1 );
	if( xinc == 0 ) {
		/* Vertical line */
		*xi = x2;
		*yi = hor[x2];
/*printf("(vert x2=%d) ", x2);*/
	} else {
#ifdef FOOBARBAZ
		denom = (hor[x2]-hor[x1])-(y2-y1);
		if( denom == 0 ) {
			/* same line! */
			*xi = x1;
		} else
			*xi = x1 + ((x2-x1)*(hor[x1]-y1))/denom;
		*yi = y1 + (*xi-x1)*((y2-y1)/(x2-x1)) + 0.5;
/*printf("(%3d,%3d)\n", *xi, *yi );*/
		return;
#endif FOOBARBAZ

		slope = (y2 - y1) / (x2 - x1);
		ysign = sign( y1 - hor[x1 + xinc] );
#ifdef MYMETHOD
		for( *xi = x1; *xi <= x2; *xi += xinc ) {
			*yi = y1 + (*xi-x1)*slope;	/* XXX */
			if( sign( *yi - hor[*xi + xinc] ) != ysign )
				break;
		}
		if( xinc == 1 && *xi > x2 ) *xi = x2;
		if( xinc == -1 && *xi < x2 ) *xi = x2;
#else
		*yi = y1;
		*xi = x1;
		while( sign( *yi - hor[*xi + xinc] ) == ysign ) {
			for( *xi = x1; *xi <= x2; *xi += xinc )
				*yi = *yi + slope;	/* XXX */
/*printf("[%3d,%3d]", *xi, *yi );*/
		}
		*xi = *xi + xinc;
#endif MYMETHOD
	}
/*printf("(%3d,%3d)\n", *xi, *yi );*/
}

sign(int i)
{
	if( i > 0 )
		return( 1 );
	else if( i < 0 )
		return( -1 );
	else
		return( 0 );
}

/*
 * DRAW - plot a line from (x1,y1) to (x2,y2)
 *  An integer Bresenham algorithm for any quadrant.
 */
Draw(int x1, int y1, int x2, int y2)
{
	int	x, y, deltx, delty, error, i;
	int	temp, s1, s2, interchange;
	static	RGBpixel white = { 255, 255, 255 };	/* XXX - debug */

/*printf("Draw (%d %d) -> (%d %d)\n", x1, y1, x2, y2 );*/
	x = x1;
	y = y1;
	deltx = (x2 > x1 ? x2 - x1 : x1 - x2);
	delty = (y2 > y1 ? y2 - y1 : y1 - y2);
	s1 = sign(x2 - x1);
	s2 = sign(y2 - y1);

	/* check for swap of deltx and delty */
	if( delty > deltx ) {
		temp = deltx;
		deltx = delty;
		delty = temp;
		interchange = 1;
	} else
		interchange = 0;

	/* init error term */
	error = 2 * delty - deltx;

	for( i = 0; i < deltx; i++ ) {
/*		plotxy( x, y );*/
/*		printf( "(%3d,%3d)\n", x, y );*/
		if( fhvis(x,y) ) {
			upper[x] = MAX( upper[x], y );
			lower[x] = MIN( lower[x], y );
			fb_write( fbp, x, y, white, 1 );
		}
		while( error >= 0 ) {
			if( interchange == 1 )
				x += s1;
			else
				y += s2;
			error -= 2 * deltx;
		}
		if( interchange == 1 )
			y += s2;
		else
			x += s1;
		error += 2 * delty;
	}
}

#ifdef SOMBRERO
int main()
{
	int	f[500];
	int	x, y, z;
	double	r;

	fhinit();

	fbp = fb_open( NULL, 512, 512 );
	/*fb_clear( fbp, PIXEL_NULL );*/

	/* Nearest to Farthest */
	for( z = 500; z > 0; z-- ) {
		/* Left to Right */
		for( x = 0; x < 500; x++ ) {
			r = (x - 250) * (x - 250) + (z - 250) * (z - 250);
			r = 0.10*sqrt( r ) + 0.00001;
			y = 250.0 * sin( r ) / r + 100.0 + (500-z)/3;
			f[x] = y;
/*			printf( "f[%3d] = %d\n", x, y );*/
		}
		fhnewz( f, 500 );
	}

	return 0;
}
#endif

static char usage[] = "\
Usage: fhor [width] < doubles\n";

int main(int argc, char **argv)
{
	double	inbuf[512];
	int	f[512];
	int	i, x, y, z;

	if( isatty(fileno(stdin)) ) {
		fprintf( stderr, usage );
		exit( 1 );
	}

	fhinit();

	fbp = fb_open( NULL, 0, 0 );
	/*fb_clear( fbp, PIXEL_NULL );*/

	bzero( f, 512*sizeof(*f) );
	fhnewz( f, 512 );

	/*
	 *  Nearest to Farthest
	 *  Here we reverse the sense of Z
	 *  (it now goes into the screen).
	 */
	z = 0;
	while( fread( inbuf, sizeof(*inbuf), 512, stdin ) > 0 ) {
		/* Left to Right */
		/*bzero( f, 512*sizeof(*f) );*/
		for( i = 0; i < 512; i++ ) {
			f[i] = 4*z;	/* up 4 for every z back */
		}
		for( i = 0; i < 512; i++ ) {
			x = i + 2*z;	/* right 2 for every z back */
			if( x >= 0 && x < 512 ) {
				f[x] += 128 * inbuf[i];
			}
			/*printf( "f[%3d] = %d\n", x, y );*/
		}
		fhnewz( f, 512 );
		z++;
	}

	return 0;
}
@


11.6
log
@change conf.h to a wrapped config.h
@
text
@@


11.5
log
@merge of ansi-6-0-branch into head
@
text
@d10 5
a14 1
#include "conf.h"
@


11.4
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d41 1
a41 1
fhinit()
d58 1
a58 2
fhnewz( f, num )
int	f[], num;
d117 1
a117 2
fhvis( x, y )
int x, y;
d133 1
a133 1
Efill()
d141 1
a141 2
Horizon( x1, y1, x2, y2 )
int	x1, y1, x2, y2;
d165 1
a165 4
Intersect( x1, y1, x2, y2, hor, xi, yi )
int	x1, y1, x2, y2;
int	hor[];
int	*xi, *yi;
d217 1
a217 2
sign( i )
int	i;
d231 1
a231 2
Draw( x1, y1, x2, y2 )
int	x1, y1, x2, y2;
d312 1
a312 3
int main( argc, argv )
int	argc;
char	**argv;
@


11.4.2.1
log
@Initial ANSIfication
@
text
@d41 1
a41 1
fhinit(void)
d58 2
a59 1
fhnewz(int *f, int num)
d118 2
a119 1
fhvis(int x, int y)
d135 1
a135 1
Efill(void)
d143 2
a144 1
Horizon(int x1, int y1, int x2, int y2)
d168 4
a171 1
Intersect(int x1, int y1, int x2, int y2, int *hor, int *xi, int *yi)
d223 2
a224 1
sign(int i)
d238 2
a239 1
Draw(int x1, int y1, int x2, int y2)
d320 3
a322 1
int main(int argc, char **argv)
@


11.3
log
@Converted from K&R to ANSI C - RFH
@
text
@d41 1
a41 1
fhinit(void)
d58 2
a59 1
fhnewz(int *f, int num)
d118 2
a119 1
fhvis(int x, int y)
d135 1
a135 1
Efill(void)
d143 2
a144 1
Horizon(int x1, int y1, int x2, int y2)
d168 4
a171 1
Intersect(int x1, int y1, int x2, int y2, int *hor, int *xi, int *yi)
d223 2
a224 1
sign(int i)
d238 2
a239 1
Draw(int x1, int y1, int x2, int y2)
d320 3
a322 1
int main(int argc, char **argv)
@


11.2
log
@added proper checking for string.h/strings.h
added int return type to main
added return 0 to main
@
text
@d41 1
a41 1
fhinit()
d58 1
a58 2
fhnewz( f, num )
int	f[], num;
d117 1
a117 2
fhvis( x, y )
int x, y;
d133 1
a133 1
Efill()
d141 1
a141 2
Horizon( x1, y1, x2, y2 )
int	x1, y1, x2, y2;
d165 1
a165 4
Intersect( x1, y1, x2, y2, hor, xi, yi )
int	x1, y1, x2, y2;
int	hor[];
int	*xi, *yi;
d217 1
a217 2
sign( i )
int	i;
d231 1
a231 2
Draw( x1, y1, x2, y2 )
int	x1, y1, x2, y2;
d312 1
a312 3
int main( argc, argv )
int	argc;
char	**argv;
@


11.1
log
@Release_4.4
@
text
@d12 6
d289 1
a289 1
main()
d312 2
d320 1
a320 1
main( argc, argv )
d363 2
@


10.2
log
@Added include of conf.h
@
text
@@


10.1
log
@Release_4.0
@
text
@d10 2
@


1.2
log
@Minor nits
@
text
@@


1.1
log
@Initial revision
@
text
@d12 2
a13 1
#include <brlcad/fb.h>		/* XXX - temp debug */
@
