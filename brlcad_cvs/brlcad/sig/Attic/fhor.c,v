head	11.11;
access;
symbols
	ansi-20040405-merged:11.8.2.1
	postmerge-20040405-ansi:11.9
	premerge-20040404-ansi:11.8
	postmerge-autoconf:11.8
	autoconf-freeze:11.8
	premerge-autoconf:11.8
	postmerge-20040315-windows:11.8
	premerge-20040315-windows:11.8
	windows-20040315-freeze:11.8
	autoconf-20031203:11.8
	autoconf-20031202:11.8
	autoconf-branch:11.8.0.10
	phong-branch:11.8.0.8
	photonmap-branch:11.8.0.6
	rel-6-1-DP:11.8
	windows-branch:11.8.0.4
	rel-6-0-2:11.6
	ansi-branch:11.8.0.2
	rel-6-0-1-branch:11.6.0.2
	hartley-6-0-post:11.7
	hartley-6-0-pre:11.6
	rel-6-0-1:11.6
	rel-6-0:11.6
	rel-5-4:11.3
	offsite-5-3-pre:11.3
	rel-5-3:11.3
	rel-5-2:11.3
	rel-5-1-branch:11.3.0.2
	rel-5-1:11.3
	rel-5-0:11.2
	rel-5-0-beta:11.2
	rel-4-5:11.2
	ctj-4-5-post:11.2
	ctj-4-5-pre:11.2
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.11
date	2004.05.21.16.45.05;	author morrison;	state dead;
branches;
next	11.10;

11.10
date	2004.05.10.15.30.50;	author erikg;	state Exp;
branches;
next	11.9;

11.9
date	2004.04.05.05.46.00;	author morrison;	state Exp;
branches;
next	11.8;

11.8
date	2002.08.20.17.08.43;	author jra;	state Exp;
branches
	11.8.2.1;
next	11.7;

11.7
date	2002.08.15.20.55.54;	author hartley;	state Exp;
branches;
next	11.6;

11.6
date	2001.10.12.18.39.59;	author butler;	state Exp;
branches;
next	11.5;

11.5
date	2001.08.21.18.33.55;	author jra;	state Exp;
branches;
next	11.4;

11.4
date	2001.08.10.21.22.45;	author morrison;	state Exp;
branches;
next	11.3;

11.3
date	2000.01.31.16.11.22;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	96.07.17.14.15.11;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.19.13;	author mike;	state Rel4_4;
branches;
next	10.5;

10.5
date	94.12.30.03.32.18;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	94.12.23.09.35.36;	author jra;	state Exp;
branches;
next	10.3;

10.3
date	94.10.19.22.05.20;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	94.08.23.18.16.30;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.51.08;	author mike;	state Rel4_0;
branches;
next	1.2;

1.2
date	91.07.02.02.15.54;	author butler;	state Exp;
branches;
next	1.1;

1.1
date	90.10.25.20.13.46;	author butler;	state Exp;
branches;
next	;

11.8.2.1
date	2002.09.19.18.02.24;	author morrison;	state Exp;
branches;
next	;


desc
@safety check in
@


11.11
log
@moved to src/sig/
@
text
@/*
 * Floating horizon 3D plotting routines.
 *
 * The terminology throughout is X across, Y up, Z toward you.
 *
 * Ref: "Procedural Elements for Computer Graphics,"
 *       D. F. Rogers.
 */
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <math.h>		/* XXX - temp debug */
#include "machine.h"
#include "fb.h"

#define	MYMETHOD	on

#define	MAX(x,y)	(((x)>(y))?(x):(y))
#define	MIN(x,y)	(((x)<(y))?(x):(y))

#define	HSCREEN	1024	/* Max Horizontal screen resolution */
#define	VSCREEN	1024	/* Max Vertical screen resolution   */

#define	INVISIBLE	0
#define	ABOVE		1
#define	BELOW		-1

/* Max and Min horizon holders */
static	int	upper[HSCREEN], lower[HSCREEN];

FBIO	*fbp;	/* XXX - debug */

void	Efill(void);
void	Horizon(int x1, int y1, int x2, int y2);
void	Intersect(int x1, int y1, int x2, int y2, int *hor, int *xi, int *yi);
void	Draw(int x1, int y1, int x2, int y2);
int	fhvis(int x, int y);
int	sign(int i);

void
fhinit(void)
{
	int	i;

	/* Set initial horizons */
	for( i = 0; i < HSCREEN; i++ ) {
		upper[ i ] = 0;
		lower[ i ] = VSCREEN;
	}
}

/*
 * Add another Z cut to the display.
 *  This one goes "behind" the last one.
 */
void
fhnewz(int *f, int num)
{
	int	x, y, Xprev, Yprev, Xi, Yi;
	int	Previously, Currently;

	/* Init previous X and Y values */
	Xprev = 0;
	Yprev = f[ 0 ];
	/* VIEWING XFORM */

	/* Fill left side */
	Efill( );
/*	Previously = fhvis( x, y );		<<< WHAT ARE X AND Y? */
	Previously = fhvis( Xprev, Yprev );		/* <<< WHAT ARE X AND Y? */

	/* Do each point in Z plane */
	for( x = 0; x < num; x++ ) {
		y = f[x];
		/* VIEWING XFORM */

		/* Check visibility and fill horizon */
		Currently = fhvis( x, y );
		if( Currently == Previously ) {
			if( Currently != INVISIBLE ) {
				/*
				 * Current and Previous point both
				 *  visible on same side of horizon.
				 */
				Draw( Xprev, Yprev, x, y );
				Horizon( Xprev, Yprev, x, y );
			}
			/* else both invisible */
		} else {
			/*
			 * Visibility has changed.
			 * Calculate intersection and fill horizon.
			 */
			switch( Currently ) {
			case INVISIBLE:
				if( Previously == ABOVE )
					Intersect( Xprev, Yprev, x, y, upper, &Xi, &Yi );
				else /* previously BELOW */
					Intersect( Xprev, Yprev, x, y, lower, &Xi, &Yi );
				Draw( Xprev, Yprev, Xi, Yi );
				Horizon( Xprev, Yprev, Xi, Yi );
				break;

			case ABOVE:
				if( Previously == INVISIBLE ) {
					Intersect( Xprev, Yprev, x, y, lower, &Xi, &Yi );
					Draw( Xi, Yi, x, y );
					Horizon( Xi, Yi, x, y );
				} else { /* previously BELOW */
					Intersect( Xprev, Yprev, x, y, lower, &Xi, &Yi );
					Draw( Xprev, Yprev, Xi, Yi );
					Horizon( Xprev, Yprev, Xi, Yi );
					Intersect( Xprev, Yprev, x, y, upper, &Xi, &Yi );
					Draw( Xi, Yi, x, y );
					Horizon( Xi, Yi, x, y );
				}
				break;

			case BELOW:
				if( Previously == INVISIBLE ) {
					Intersect( Xprev, Yprev, x, y, lower, &Xi, &Yi );
					Draw( Xi, Yi, x, y );
					Horizon( Xi, Yi, x, y );
				} else { /* previously ABOVE */
					Intersect( Xprev, Yprev, x, y, upper, &Xi, &Yi );
					Draw( Xprev, Yprev, Xi, Yi );
					Horizon( Xprev, Yprev, Xi, Yi );
					Intersect( Xprev, Yprev, x, y, lower, &Xi, &Yi );
					Draw( Xi, Yi, x, y );
					Horizon( Xi, Yi, x, y );
				}
				break;
			}
		} /* end changed visibility */

		/*
		 * Reset "previous" point values for next iteration.
		 */
		Previously = Currently;
		Xprev = x;
		Yprev = y;
	}

	/* Fill Right Side */
	Efill( );
}

/*
 * INTERNAL Visibility routine.
 *  Answers, Is Y visible at point X?
 *
 * Returns: 0 if invisible
 *	    1 if visible above upper horizon.
 *	   -1 if visible below lower horizon.
 */
int
fhvis(int x, int y)
{
	/* See if hidden behind horizons */
	if( y < upper[x] && y > lower[x] )
		return( INVISIBLE );

	if( y >= upper[x] )
		return( ABOVE );

	return( BELOW );
}

/*
 * INTERNAL Edge fill routine.
 * NOT DONE YET.
 */
void
Efill(void)
{
}

/*
 * Fill the upper and lower horizon arrays from x1 to x2
 *  with a line spanning (x1,y1) to (x2,y2).
 */
void
Horizon(int x1, int y1, int x2, int y2)
{
	int	xinc, x, y;
	double	slope;

	xinc = sign( x2 - x1 );
	if( xinc == 0 ) {
		/* Vertical line */
		upper[x2] = MAX( upper[x2], y2 );
		lower[x2] = MIN( lower[x2], y2 );
	} else {
		slope = (y2 - y1) / (x2 - x1);
		for( x = x1; x <= x2; x += xinc ) {
			y = slope * (x - x1) + y1;
			upper[x] = MAX( upper[x], y );
			lower[x] = MIN( lower[x], y );
		}
	}
}

/*
 * Find the intersection (xi,yi) between the line (x1,y1)->(x2,y2)
 *  and the horizon hor[].
 */
void
Intersect(int x1, int y1, int x2, int y2, int *hor, int *xi, int *yi)
{
	int	xinc, ysign;
	int	slope;

/*
printf("Intersect( (%3d,%3d)->(%3d,%3d) & (%3d,%3d)->(%3d,%3d) ) = ", x1, y1, x2, y2, x1, hor[x1], x2, hor[x2] );
fflush( stdout );
*/
	xinc = sign( x2 - x1 );
	if( xinc == 0 ) {
		/* Vertical line */
		*xi = x2;
		*yi = hor[x2];
/*printf("(vert x2=%d) ", x2);*/
	} else {
#ifdef FOOBARBAZ
		denom = (hor[x2]-hor[x1])-(y2-y1);
		if( denom == 0 ) {
			/* same line! */
			*xi = x1;
		} else
			*xi = x1 + ((x2-x1)*(hor[x1]-y1))/denom;
		*yi = y1 + (*xi-x1)*((y2-y1)/(x2-x1)) + 0.5;
/*printf("(%3d,%3d)\n", *xi, *yi );*/
		return;
#endif /* FOOBARBAZ */

		slope = (y2 - y1) / (x2 - x1);
		ysign = sign( y1 - hor[x1 + xinc] );
#ifdef MYMETHOD
		for( *xi = x1; *xi <= x2; *xi += xinc ) {
			*yi = y1 + (*xi-x1)*slope;	/* XXX */
			if( sign( *yi - hor[*xi + xinc] ) != ysign )
				break;
		}
		if( xinc == 1 && *xi > x2 ) *xi = x2;
		if( xinc == -1 && *xi < x2 ) *xi = x2;
#else
		*yi = y1;
		*xi = x1;
		while( sign( *yi - hor[*xi + xinc] ) == ysign ) {
			for( *xi = x1; *xi <= x2; *xi += xinc )
				*yi = *yi + slope;	/* XXX */
/*printf("[%3d,%3d]", *xi, *yi );*/
		}
		*xi = *xi + xinc;
#endif /* MYMETHOD */
	}
/*printf("(%3d,%3d)\n", *xi, *yi );*/
}

int
sign(int i)
{
	if( i > 0 )
		return( 1 );
	else if( i < 0 )
		return( -1 );
	else
		return( 0 );
}

/*
 * DRAW - plot a line from (x1,y1) to (x2,y2)
 *  An integer Bresenham algorithm for any quadrant.
 */
void
Draw(int x1, int y1, int x2, int y2)
{
	int	x, y, deltx, delty, error, i;
	int	temp, s1, s2, interchange;
	static	RGBpixel white = { 255, 255, 255 };	/* XXX - debug */

/*printf("Draw (%d %d) -> (%d %d)\n", x1, y1, x2, y2 );*/
	x = x1;
	y = y1;
	deltx = (x2 > x1 ? x2 - x1 : x1 - x2);
	delty = (y2 > y1 ? y2 - y1 : y1 - y2);
	s1 = sign(x2 - x1);
	s2 = sign(y2 - y1);

	/* check for swap of deltx and delty */
	if( delty > deltx ) {
		temp = deltx;
		deltx = delty;
		delty = temp;
		interchange = 1;
	} else
		interchange = 0;

	/* init error term */
	error = 2 * delty - deltx;

	for( i = 0; i < deltx; i++ ) {
/*		plotxy( x, y );*/
/*		printf( "(%3d,%3d)\n", x, y );*/
		fb_write( fbp, x, y, white, 1 );
		while( error >= 0 ) {
			if( interchange == 1 )
				x += s1;
			else
				y += s2;
			error -= 2 * deltx;
		}
		if( interchange == 1 )
			y += s2;
		else
			x += s1;
		error += 2 * delty;
	}
}

#ifdef SOMBRERO
int main()
{
	int	f[500];
	int	x, y, z;
	double	r;

	fhinit();

	fbp = fb_open( NULL, 512, 512 );
	fb_clear( fbp, PIXEL_NULL );

	/* Nearest to Farthest */
	for( z = 500; z > 0; z-- ) {
		/* Left to Right */
		for( x = 0; x < 500; x++ ) {
			r = (x - 250) * (x - 250) + (z - 250) * (z - 250);
			r = 0.10*sqrt( r ) + 0.00001;
			y = 250.0 * sin( r ) / r + 100.0 + (500-z)/3;
			f[x] = y;
/*			printf( "f[%3d] = %d\n", x, y );*/
		}
		fhnewz( f, 500 );
	}

	return 0;
}
#endif

static char usage[] = "\
Usage: fhor [width] < doubles\n";

int main(int argc, char **argv)
{
	double	inbuf[512];
	int	f[512];
	int	i, x, z;
	int	size = 512;

	if( argc > 1 ) {
		size = atoi( argv[1] );
	}

	if( isatty(fileno(stdin)) ) {
		fprintf( stderr, usage );
		exit( 1 );
	}

	fhinit();

	fbp = fb_open( NULL, 0, 0 );
	fb_clear( fbp, PIXEL_NULL );

	bzero( (char *)f, 512*sizeof(*f) );
	fhnewz( f, 512 );

	/*
	 *  Nearest to Farthest
	 *  Here we reverse the sense of Z
	 *  (it now goes into the screen).
	 */
	z = 0;
	while( fread( inbuf, sizeof(*inbuf), size, stdin ) != 0 ) {
		/* Left to Right */
		/*bzero( (char *)f, 512*sizeof(*f) );*/
		for( i = 0; i < 512; i++ ) {
			f[i] = 4*z;	/* up 4 for every z back */
		}
		for( i = 0; i < size; i++ ) {
			x = i + 2*z;	/* right 2 for every z back */
			if( x >= 0 && x < 512 ) {
				f[x] += 128 * inbuf[i];
			}
			/*printf( "f[%3d] = %d\n", x, y );*/
		}
		fhnewz( f, 512 );
		z++;
	}

	return 0;
}
@


11.10
log
@change conf.h to a wrapped config.h
@
text
@@


11.9
log
@merge of ansi-6-0-branch into head
@
text
@d9 5
a13 1
#include "conf.h"
@


11.8
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d41 6
a46 6
void	Efill();
void	Horizon();
void	Intersect();
void	Draw();
int	fhvis();
int	sign();
d49 1
a49 1
fhinit()
d65 1
a65 2
fhnewz( f, num )
int	f[], num;
d165 1
a165 2
fhvis( x, y )
int x, y;
d182 1
a182 1
Efill()
d191 1
a191 2
Horizon( x1, y1, x2, y2 )
int	x1, y1, x2, y2;
d216 1
a216 4
Intersect( x1, y1, x2, y2, hor, xi, yi )
int	x1, y1, x2, y2;
int	hor[];
int	*xi, *yi;
d269 1
a269 2
sign( i )
int	i;
d284 1
a284 2
Draw( x1, y1, x2, y2 )
int	x1, y1, x2, y2;
d361 1
a361 3
int main( argc, argv )
int	argc;
char	**argv;
@


11.8.2.1
log
@Initial ANSIfication
@
text
@d41 6
a46 6
void	Efill(void);
void	Horizon(int x1, int y1, int x2, int y2);
void	Intersect(int x1, int y1, int x2, int y2, int *hor, int *xi, int *yi);
void	Draw(int x1, int y1, int x2, int y2);
int	fhvis(int x, int y);
int	sign(int i);
d49 1
a49 1
fhinit(void)
d65 2
a66 1
fhnewz(int *f, int num)
d166 2
a167 1
fhvis(int x, int y)
d184 1
a184 1
Efill(void)
d193 2
a194 1
Horizon(int x1, int y1, int x2, int y2)
d219 4
a222 1
Intersect(int x1, int y1, int x2, int y2, int *hor, int *xi, int *yi)
d275 2
a276 1
sign(int i)
d291 2
a292 1
Draw(int x1, int y1, int x2, int y2)
d369 3
a371 1
int main(int argc, char **argv)
@


11.7
log
@Converted from K&R to ANSI C - RFH
@
text
@d41 6
a46 6
void	Efill(void);
void	Horizon(int x1, int y1, int x2, int y2);
void	Intersect(int x1, int y1, int x2, int y2, int *hor, int *xi, int *yi);
void	Draw(int x1, int y1, int x2, int y2);
int	fhvis(int x, int y);
int	sign(int i);
d49 1
a49 1
fhinit(void)
d65 2
a66 1
fhnewz(int *f, int num)
d166 2
a167 1
fhvis(int x, int y)
d184 1
a184 1
Efill(void)
d193 2
a194 1
Horizon(int x1, int y1, int x2, int y2)
d219 4
a222 1
Intersect(int x1, int y1, int x2, int y2, int *hor, int *xi, int *yi)
d275 2
a276 1
sign(int i)
d291 2
a292 1
Draw(int x1, int y1, int x2, int y2)
d369 3
a371 1
int main(int argc, char **argv)
@


11.6
log
@Misc compiler warnings fixed
@
text
@d41 6
a46 6
void	Efill();
void	Horizon();
void	Intersect();
void	Draw();
int	fhvis();
int	sign();
d49 1
a49 1
fhinit()
d65 1
a65 2
fhnewz( f, num )
int	f[], num;
d165 1
a165 2
fhvis( x, y )
int x, y;
d182 1
a182 1
Efill()
d191 1
a191 2
Horizon( x1, y1, x2, y2 )
int	x1, y1, x2, y2;
d216 1
a216 4
Intersect( x1, y1, x2, y2, hor, xi, yi )
int	x1, y1, x2, y2;
int	hor[];
int	*xi, *yi;
d269 1
a269 2
sign( i )
int	i;
d284 1
a284 2
Draw( x1, y1, x2, y2 )
int	x1, y1, x2, y2;
d361 1
a361 3
int main( argc, argv )
int	argc;
char	**argv;
@


11.5
log
@lint
@
text
@d165 1
@


11.4
log
@added proper checking for string.h/strings.h
added int return type to main
added return 0 to main
@
text
@d17 2
d45 2
d273 1
@


11.3
log
@Eliminated some unused variables
@
text
@d11 6
d332 1
a332 1
main()
d355 2
d363 1
a363 1
main( argc, argv )
d411 2
@


11.2
log
@Minor Mods for Irix 6.2
@
text
@a29 1
static	int	Xleft, Yleft, Xright, Yright;		/* XXX */
a42 2
	Xleft = Yleft = Xright = Yright = -1;

d213 1
a213 1
	int	xinc, ysign, denom;
d361 1
a361 1
	int	i, x, y, z;
@


11.1
log
@Release_4.4
@
text
@d34 6
d57 1
d175 1
d184 1
d210 1
d281 1
@


10.5
log
@DEC Alpha
@
text
@@


10.4
log
@Fixed a /* in a comment.
@
text
@d370 1
a370 1
	bzero( f, 512*sizeof(*f) );
d381 1
a381 1
		/*bzero( f, 512*sizeof(*f) );*/
@


10.3
log
@ANSI
@
text
@d64 1
a64 1
/*	Previously = fhvis( x, y );		/* <<< WHAT ARE X AND Y? */
@


10.2
log
@Added include of conf.h
@
text
@d379 1
a379 1
	while( fread( inbuf, sizeof(*inbuf), size, stdin ) > 0 ) {
@


10.1
log
@Release_4.0
@
text
@d9 2
@


1.2
log
@Minor nits
@
text
@@


1.1
log
@Initial revision
@
text
@d11 2
a12 1
#include <brlcad/fb.h>		/* XXX - temp debug */
d228 1
a228 1
#endif FOOBARBAZ
d249 1
a249 1
#endif MYMETHOD
@
