head	11.7;
access;
symbols
	ansi-20040405-merged:11.4.2.1
	postmerge-20040405-ansi:11.5
	premerge-20040404-ansi:11.4
	postmerge-autoconf:11.4
	autoconf-freeze:11.4
	premerge-autoconf:11.4
	postmerge-20040315-windows:11.4
	premerge-20040315-windows:11.4
	windows-20040315-freeze:11.4
	autoconf-20031203:11.4
	autoconf-20031202:11.4
	autoconf-branch:11.4.0.10
	phong-branch:11.4.0.8
	photonmap-branch:11.4.0.6
	rel-6-1-DP:11.4
	windows-branch:11.4.0.4
	rel-6-0-2:11.2
	ansi-branch:11.4.0.2
	rel-6-0-1-branch:11.2.0.4
	hartley-6-0-post:11.3
	hartley-6-0-pre:11.2
	rel-6-0-1:11.2
	rel-6-0:11.2
	rel-5-4:11.2
	offsite-5-3-pre:11.2
	rel-5-3:11.2
	rel-5-2:11.2
	rel-5-1-branch:11.2.0.2
	rel-5-1:11.2
	rel-5-0:11.2
	rel-5-0-beta:11.2
	rel-4-5:11.1
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1;
locks; strict;
comment	@ * @;


11.7
date	2004.05.21.14.57.51;	author morrison;	state dead;
branches;
next	11.6;

11.6
date	2004.05.10.15.30.50;	author erikg;	state Exp;
branches;
next	11.5;

11.5
date	2004.04.05.05.46.02;	author morrison;	state Exp;
branches;
next	11.4;

11.4
date	2002.08.20.17.09.02;	author jra;	state Exp;
branches
	11.4.2.1;
next	11.3;

11.3
date	2002.08.15.20.56.13;	author hartley;	state Exp;
branches;
next	11.2;

11.2
date	98.09.22.03.22.25;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.12.34;	author mike;	state Rel4_4;
branches;
next	10.2;

10.2
date	94.08.23.15.05.52;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.48.35;	author mike;	state Rel4_0;
branches;
next	9.3;

9.3
date	91.10.02.03.44.18;	author butler;	state Exp;
branches;
next	9.2;

9.2
date	91.04.23.01.13.25;	author butler;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.10.18;	author mike;	state Rel3_5;
branches;
next	1.3;

1.3
date	89.04.22.05.13.39;	author butler;	state Exp;
branches;
next	1.2;

1.2
date	89.04.21.00.42.13;	author butler;	state Exp;
branches;
next	1.1;

1.1
date	89.04.20.22.22.22;	author butler;	state Exp;
branches;
next	;

11.4.2.1
date	2002.09.19.18.02.40;	author morrison;	state Exp;
branches;
next	;


desc
@Counts and lists pixel values used in a PIX(5) format image
@


11.7
log
@moved to src/util/
@
text
@/*			P I X C O L O R S
 *
 *	Count the number of different pixel values in a PIX format image.
 *	If the "-v" option is selected, list each unique pixel value 
 *	to the standard output.
 *
 *	Author(s)
 *	Lee A. Butler	butler@@stsci.edu
 *
 *	Options
 *	v	list colors
 */
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>

#include "machine.h"
#include "externs.h"		/* For getopt */

/* declarations to support use of getopt() system call */
char *options = "v";
char verbose = 0;
char *progname = "(noname)";

#define PIXELS 1024
unsigned char pixbuf[BUFSIZ*3];

/* This grotesque array provides 1 bit for each of the 2^24 possible pixel
 * values.
 * The "NOBASE" comment below allows compilation on the Gould 9000 series
 * of computers.
 */
/*NOBASE*/
unsigned char vals[1L << (24-3)];

/*
 *	D O I T --- Main function of program
 */
void doit(FILE *fd)
{
	unsigned long pixel, count;
	int bytes;
	register int mask, i;
	register unsigned long k;


	count = 0;
	while ((bytes=fread(pixbuf, 3, PIXELS, fd)) > 0) {
		for (i=(bytes-1)*3 ; i >= 0 ; i -= 3) {
			pixel = pixbuf[i] + 
				(pixbuf[i+1] << 8) +
				(pixbuf[i+2] << 16);

			if ( ! ( vals[k=(pixel >> 3)] &
			    (mask=(1 << (pixel & 0x07))) ) ) {
				vals[k] |= (unsigned char)mask;
				++count;
			}
		}
	}
	(void) printf("%lu\n", count);
	if (verbose)
		for (i=0 ; i < 1<<24 ; ++i)
			if ( (vals[i>>3] & (1<<(i & 0x07))) )
				(void) printf("%3d %3d %3d\n",
					i & 0x0ff,
					(i >> 8) & 0x0ff,
					(i >> 16) & 0x0ff);
}

void usage(void)
{
	(void) fprintf(stderr, "Usage: %s [ -v ] < PIXfile\n", progname);
	exit(1);
}

/*
 *	M A I N
 *
 *	Perform miscelaneous tasks such as argument parsing and
 *	I/O setup and then call "doit" to perform the task at hand
 */
int main(int ac, char **av)
{
	int  c, isatty(int);
	progname = *av;
	
	/* Get # of options & turn all the option flags off
	 */

	/* Turn off getopt's error messages */
	opterr = 0;

	/* get all the option flags from the command line
	 */
	while ((c=getopt(ac,av,options)) != EOF) {
		if ( c == 'v' ) verbose = ! verbose;
		else usage();
	}


	if (optind < ac-1) {
		usage();
	} else if (optind == ac-1 ) {
		FILE *fd;
		if ((fd=fopen(av[optind], "r")) == (FILE *)NULL) {
			perror(av[optind]);
			exit(-1);
		} else doit(fd);
	} else if (optind >= ac) {
		if (isatty(fileno(stdin))) usage();
		doit(stdin);
	}
	
	return(0);
}
@


11.6
log
@change conf.h to a wrapped config.h
@
text
@@


11.5
log
@merge of ansi-6-0-branch into head
@
text
@d13 5
a17 1
#include "conf.h"
@


11.4
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d39 1
a39 2
void doit(fd)
FILE *fd;
d71 1
a71 1
void usage()
d83 1
a83 3
int main(ac,av)
int ac;
char *av[];
d85 1
a85 1
	int  c, isatty();
@


11.4.2.1
log
@Initial ANSIfication
@
text
@d39 2
a40 1
void doit(FILE *fd)
d72 1
a72 1
void usage(void)
d84 3
a86 1
int main(int ac, char **av)
d88 1
a88 1
	int  c, isatty(int);
@


11.3
log
@Converted from K&R to ANSI C - RFH
@
text
@d39 2
a40 1
void doit(FILE *fd)
d72 1
a72 1
void usage(void)
d84 3
a86 1
int main(int ac, char **av)
d88 1
a88 1
	int  c, isatty(int);
@


11.2
log
@Fixed printf args
@
text
@d39 1
a39 2
void doit(fd)
FILE *fd;
d71 1
a71 1
void usage()
d83 1
a83 3
int main(ac,av)
int ac;
char *av[];
d85 1
a85 1
	int  c, isatty();
@


11.1
log
@Release_4.4
@
text
@d62 1
a62 1
	(void) printf("%u\n", count);
@


10.2
log
@Factored ifdefs
@
text
@@


10.1
log
@Release_4.0
@
text
@d13 2
d16 3
a18 1
#include "externs.h"
a22 2
extern char *optarg;
extern int optind, opterr, getopt();
@


9.3
log
@added capability to specify image as command line option
@
text
@@


9.2
log
@fixed the -v option so that all the colors would be printed again.
@
text
@d37 2
a38 1
void doit()
d47 1
a47 1
	while ((bytes=fread(pixbuf, 3, PIXELS, stdin)) > 0) {
a86 1

a87 1
	if (isatty(fileno(stdin))) usage();
a101 1
	if (optind < ac) usage();
d103 13
a115 1
	doit();
@


9.1
log
@Release_3.5
@
text
@d61 6
a66 4
	for (i=0 ; i < sizeof(vals) ; ++i)
		if (vals[i >> 3] & (1 << (i & 0x07)) )
		(void) printf("%3d %3d %3d\n", i & 0x0ff,
			(i >> 8) & 0x0ff, (i >> 16) & 0x0ff);
@


1.3
log
@This version is more efficient, and contains some cleanups.
@
text
@@


1.2
log
@*** empty log message ***
@
text
@d14 1
d26 3
a28 2
/* This grotesque array provides 1 bit for every possible pixel value.
 * the "NOBASE" comment below allows compilation on the Gould 9000 series
d32 1
a32 1
unsigned char vals[2097152L];
a33 2
#define TEST(p)    (vals[(p)/8] & 1 << (p)%8)

d35 1
a35 1
 *    D O I T --- Main function of program
d39 19
a57 10
    unsigned long bytes, i, pixel, count;
    
    count = 0;
    while ((bytes=fread(pixbuf, 3, PIXELS, stdin)) > 0) {
	for (i = 0 ; i < bytes ; ++i) {
	    pixel = pixbuf[i*3] + (pixbuf[i*3+1] << 8) + (pixbuf[i*3+2] << 16);
	    if ( ! TEST(pixel) ) {
		vals[pixel/8] = vals[pixel/8] | 1 << pixel%8;
		++count;
	    }
d59 2
a60 3
    }
    (void) printf("%u\n", count);
    if (verbose)
d62 1
a62 1
	    if (TEST(i))
d64 1
a64 2
		    (i >> 8) & 0x0ff,
		    (i >> 16) & 0x0ff);
d69 2
a70 2
    (void) fprintf(stderr, "Usage: %s [ -v ] < PIXfile\n", progname, options);
    exit(1);
d74 1
a74 1
 *    M A I N
d76 2
a77 2
 *    Perform miscelaneous tasks such as argument parsing and
 *    I/O setup and then call "doit" to perform the task at hand
d79 1
a79 1
main(ac,av)
d83 1
a83 1
    int  c;
d85 5
a89 5
    progname = *av;
    if (isatty(fileno(stdin))) usage();
    
    /* Get # of options & turn all the option flags off
     */
d91 2
a92 2
    /* Turn off getopt's error messages */
    opterr = 0;
d94 6
a99 6
    /* get all the option flags from the command line
     */
    while ((c=getopt(ac,av,options)) != EOF) {
	if ( c == 'v' ) verbose = ! verbose;
	else usage();
    }
d101 1
a101 1
    if (optind < ac) usage();
d103 2
a104 1
    doit();
@


1.1
log
@Initial revision
@
text
@d25 5
a29 1
/* This grotesque array provides 1 bit for every possible pixel value */
d31 1
d51 2
a52 2
    printf("%u\n", count);
    if (optflags[offset(options, 'v')])
d55 1
a55 1
		printf("%3d %3d %3d\n", i & 0x0ff,
d76 1
a76 1
    int  c, optlen;
a82 1
    optlen = strlen(options);
a83 2
    for (c=0 ; c < optlen ; optflags[c++] = '\0');
    
@
