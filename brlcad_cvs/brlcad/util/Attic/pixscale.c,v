head	11.11;
access;
symbols
	ansi-20040405-merged:11.8.2.2
	postmerge-20040405-ansi:11.10
	premerge-20040404-ansi:11.9
	postmerge-autoconf:11.9
	autoconf-freeze:11.8.10.1
	premerge-autoconf:11.9
	postmerge-20040315-windows:11.9
	premerge-20040315-windows:11.9
	windows-20040315-freeze:11.8.4.1
	autoconf-20031203:11.8
	autoconf-20031202:11.8
	autoconf-branch:11.8.0.10
	phong-branch:11.8.0.8
	photonmap-branch:11.8.0.6
	rel-6-1-DP:11.8
	windows-branch:11.8.0.4
	rel-6-0-2:11.6
	ansi-branch:11.8.0.2
	rel-6-0-1-branch:11.6.0.2
	hartley-6-0-post:11.7
	hartley-6-0-pre:11.6
	rel-6-0-1:11.6
	rel-6-0:11.6
	rel-5-4:11.4
	offsite-5-3-pre:11.5
	rel-5-3:11.4
	rel-5-2:11.4
	rel-5-1-branch:11.4.0.2
	rel-5-1:11.4
	rel-5-0:11.3
	rel-5-0-beta:11.3
	rel-4-5:11.2
	ctj-4-5-post:11.2
	ctj-4-5-pre:11.2
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:5.1
	rel-1-24:5.1
	rel-1-20:4.2
	rel-1-10:4.1;
locks; strict;
comment	@ * @;


11.11
date	2004.05.21.14.57.56;	author morrison;	state dead;
branches;
next	11.10;

11.10
date	2004.04.05.05.46.02;	author morrison;	state Exp;
branches;
next	11.9;

11.9
date	2004.02.02.17.39.49;	author morrison;	state Exp;
branches;
next	11.8;

11.8
date	2002.08.20.17.09.03;	author jra;	state Exp;
branches
	11.8.2.1
	11.8.4.1
	11.8.10.1;
next	11.7;

11.7
date	2002.08.15.20.56.15;	author hartley;	state Exp;
branches;
next	11.6;

11.6
date	2001.08.10.20.57.07;	author butler;	state Exp;
branches;
next	11.5;

11.5
date	2000.09.01.03.23.59;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	2000.01.31.16.03.09;	author jra;	state Exp;
branches;
next	11.3;

11.3
date	99.01.21.21.22.42;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	97.05.19.17.15.00;	author butler;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.12.59;	author mike;	state Rel4_4;
branches;
next	10.3;

10.3
date	93.06.21.18.16.03;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	91.11.13.20.20.33;	author butler;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.48.54;	author mike;	state Rel4_0;
branches;
next	9.4;

9.4
date	91.10.11.11.22.22;	author butler;	state Exp;
branches;
next	9.3;

9.3
date	91.06.18.10.03.34;	author mmark;	state Exp;
branches;
next	9.2;

9.2
date	90.03.15.17.01.44;	author phil;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.10.49;	author mike;	state Rel3_5;
branches;
next	8.1;

8.1
date	88.10.05.00.43.14;	author mike;	state Rel3_0;
branches;
next	7.3;

7.3
date	88.09.26.22.47.33;	author phil;	state Exp;
branches;
next	7.2;

7.2
date	88.05.16.00.06.55;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.03.00.09.06;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.08.12.30;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.43.19;	author mike;	state Rel;
branches;
next	4.2;

4.2
date	87.02.13.00.46.00;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.13.51;	author mike;	state Rel1;
branches;
next	1.3;

1.3
date	86.11.25.01.12.49;	author phil;	state Exp;
branches;
next	1.2;

1.2
date	86.10.30.19.38.59;	author phil;	state Exp;
branches;
next	1.1;

1.1
date	86.09.23.18.39.50;	author phil;	state Exp;
branches;
next	;

11.8.2.1
date	2002.09.19.18.02.42;	author morrison;	state Exp;
branches;
next	11.8.2.2;

11.8.2.2
date	2004.03.17.21.23.32;	author morrison;	state Exp;
branches;
next	;

11.8.4.1
date	2004.03.11.23.52.34;	author morrison;	state Exp;
branches;
next	;

11.8.10.1
date	2004.02.12.19.43.11;	author erikg;	state Exp;
branches;
next	;


desc
@Scale a .pix file
@


11.11
log
@moved to src/util/
@
text
@/*
 *		P I X S C A L E . C
 *
 *  Scale an RGB pix file.
 *
 *  To scale up, we use bilinear interpolation.
 *  To scale down, we assume "square pixels" and preserve the
 *  amount of light energy per unit area.
 *
 *  This is a buffered version that can handle files of
 *  almost arbitrary size.
 *
 *  Note: This is a simple extension to bwcrop.  Improvements made
 *  there should be incorporated here.
 *
 *  Author -
 *	Phillip Dykstra
 * 	23 Sep 1986
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1986-2004 by the United States Army.
 *	All rights reserved.
 */
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

extern int	getopt(int, char *const *, const char *);
extern char	*optarg;
extern int	optind;

#define	MAXBUFBYTES	3*1024*1024	/* max bytes to malloc in buffer space */

unsigned char	*outbuf;
unsigned char	*buffer;
int	scanlen;			/* length of infile (and buffer) scanlines */
int	buflines;			/* Number of lines held in buffer */
int	buf_start = -1000;		/* First line in buffer */

int	bufy;				/* y coordinate in buffer */
FILE	*buffp;
static char	*file_name;

int	rflag = 0;
int	inx = 512;
int	iny = 512;
int	outx = 512;
int	outy = 512;

void	init_buffer(int scanlen), fill_buffer(int y), binterp(FILE *ofp, int ix, int iy, int ox, int oy), ninterp(FILE *ofp, int ix, int iy, int ox, int oy);

static	char usage[] = "\
Usage: pixscale [-h] [-r] [-s squareinsize] [-w inwidth] [-n inheight]\n\
	[-S squareoutsize] [-W outwidth] [-N outheight] [in.pix] > out.pix\n";

int
get_args(int argc, register char **argv)
{
	register int c;

	while ( (c = getopt( argc, argv, "rhs:w:n:S:W:N:" )) != EOF )  {
		switch( c )  {
		case 'r':
			/* pixel replication */
			rflag = 1;
			break;
		case 'h':
			/* high-res */
			inx = iny = 1024;
			break;
		case 'S':
			/* square size */
			outx = outy = atoi(optarg);
			break;
		case 's':
			/* square size */
			inx = iny = atoi(optarg);
			break;
		case 'W':
			outx = atoi(optarg);
			break;
		case 'w':
			inx = atoi(optarg);
			break;
		case 'N':
			outy = atoi(optarg);
			break;
		case 'n':
			iny = atoi(optarg);
			break;

		default:		/* '?' */
			return(0);
		}
	}

	/* XXX - backward compatability hack */
	if( optind+5 == argc ) {
		file_name = argv[optind++];
		if( (buffp = fopen(file_name, "r")) == NULL )  {
			(void)fprintf( stderr,
				"pixscale: cannot open \"%s\" for reading\n",
				file_name );
			return(0);
		}
		inx = atoi(argv[optind++]);
		iny = atoi(argv[optind++]);
		outx = atoi(argv[optind++]);
		outy = atoi(argv[optind++]);
		return(1);
	}
	if( optind >= argc )  {
		if( isatty(fileno(stdin)) )
			return(0);
		file_name = "-";
		buffp = stdin;
	} else {
		file_name = argv[optind];
		if( (buffp = fopen(file_name, "r")) == NULL )  {
			(void)fprintf( stderr,
				"pixscale: cannot open \"%s\" for reading\n",
				file_name );
			return(0);
		}
	}

	if ( argc > ++optind )
		(void)fprintf( stderr, "pixscale: excess argument(s) ignored\n" );

	return(1);		/* OK */
}

/****** THIS PROBABLY SHOULD BE ELSEWHERE *******/

/* ceiling and floor functions for positive numbers */
#define	CEILING(x)	(((x) > (int)(x)) ? (int)(x)+1 : (int)(x))
#define	FLOOR(x)	((int)(x))
#define	MIN(x,y)	(((x) > (y)) ? (y) : (x))

/*
 * Scale a file of pixels to a different size.
 *
 * To scale down we make a square pixel assumption.
 * We will preserve the amount of light energy per unit area.
 * To scale up we use bilinear interpolation.
 */
int
scale(FILE *ofp, int ix, int iy, int ox, int oy)
{
	int	i, j, k, l;
	double	pxlen, pylen;			/* # old pixels per new pixel */
	double	xstart, xend, ystart, yend;	/* edges of new pixel in old coordinates */
	double	xdist, ydist;			/* length of new pixel sides in old coord */
	double	sumr, sumg, sumb;
	unsigned char *op;

	if( ix == ox )
		pxlen = 1.0;
	else
		pxlen = (double)ix / (double)ox;
	if( iy == oy )
		pylen = 1.0;
	else
		pylen = (double)iy / (double)oy;
	if ( (pxlen < 1.0 && pylen > 1.0) || (pxlen > 1.0 && pylen < 1.0) ) {
		fprintf( stderr, "pixscale: can't stretch one way and compress another!\n" );
		return( -1 );
	}
	if( pxlen < 1.0 || pylen < 1.0 ) {
		if( rflag ) {
			/* nearest neighbor interpolate */
			ninterp( ofp, ix, iy, ox, oy );
		} else {
			/* bilinear interpolate */
			binterp( ofp, ix, iy, ox, oy );
		}
		return( 0 );
	}

	/* for each output pixel */
	for( j = 0; j < oy; j++ ) {
		ystart = j * pylen;
		yend = ystart + pylen;
		op = outbuf;
		for( i = 0; i < ox; i++ ) {
			xstart = i * pxlen;
			xend = xstart + pxlen;
			sumr = sumg = sumb = 0.0;
			/*
			 * For each pixel of the original falling
			 *  inside this new pixel.
			 */
			for( l = FLOOR(ystart); l < CEILING(yend); l++ ) {

				/* Make sure we have this row in the buffer */
				bufy = l - buf_start;
				if( bufy < 0 || bufy >= buflines ) {
					fill_buffer( l );
					bufy = l - buf_start;
				}

				/* Compute height of this row */
				if( (double)l < ystart )
					ydist = CEILING(ystart) - ystart;
				else
					ydist = MIN( 1.0, yend - (double)l );

				for( k = FLOOR(xstart); k < CEILING(xend); k++ ) {
					/* Compute width of column */
					if( (double)k < xstart )
						xdist = CEILING(xstart) - xstart;
					else
						xdist = MIN( 1.0, xend - (double)k );

					/* Add this pixels contribution */
					/* sum += old[l][k] * xdist * ydist; */
					sumr += buffer[bufy * scanlen + 3*k] * xdist * ydist;
					sumg += buffer[bufy * scanlen + 3*k+1] * xdist * ydist;
					sumb += buffer[bufy * scanlen + 3*k+2] * xdist * ydist;
				}
			}
			*op++ = (int)(sumr / (pxlen * pylen));
			*op++ = (int)(sumg / (pxlen * pylen));
			*op++ = (int)(sumb / (pxlen * pylen));
		}
		fwrite( outbuf, 3, ox, ofp );
	}
	return( 1 );
}

int
main(int argc, char **argv)
{
	int i;

	if ( !get_args( argc, argv ) || isatty(fileno(stdout)) )  {
		(void)fputs(usage, stderr);
		exit( 1 );
	}

	if( inx <= 0 || iny <= 0 || outx <= 0 || outy <= 0 ) {
		fprintf( stderr, "pixscale: bad size\n" );
		exit( 2 );
	}

	/* See how many lines we can buffer */
	scanlen = 3 * inx;
	init_buffer( scanlen );
	if (inx < outx) i = outx * 3;
	else i = inx * 3;

	if( (outbuf = malloc(i)) == NULL )
		exit( 4 );

	/* Here we go */
	i = scale( stdout, inx, iny, outx, outy );
	free( outbuf );
	free( buffer );
	return( 0 );
}

/*
 * Determine max number of lines to buffer.
 *  and malloc space for it.
 *  XXX - CHECK FILE SIZE
 */
void
init_buffer(int scanlen)
{
	int	max;

	/* See how many we could buffer */
	max = MAXBUFBYTES / scanlen;

	/*
	 * Do a max of 512.  We really should see how big
	 * the input file is to decide if we should buffer
	 * less than our max.
	 */
	if( max > 4096 ) max = 4096;

	buflines = max;
	buf_start = (-buflines);
	buffer = malloc( buflines * scanlen );
}

/*
 * Load the buffer with scan lines centered around
 * the given y coordinate.
 */
void
fill_buffer(int y)
{
	static int	file_pos = 0;

	buf_start = y - buflines/2;
	if( buf_start < 0 ) buf_start = 0;

	if( file_pos != buf_start * scanlen )  {
		if( fseek( buffp, buf_start * scanlen, 0 ) < 0 ) {
			fprintf( stderr, "pixscale: Can't seek to input pixel! y=%d\n", y );
			exit( 3 );
		}
		file_pos = buf_start * scanlen;
	}
	fread( buffer, scanlen, buflines, buffp );
	file_pos += buflines * scanlen;
}


/*
 * Bilinear Interpolate a file of pixels.
 *
 * This version preserves the outside pixels and interps inside only.
 */
void
binterp(FILE *ofp, int ix, int iy, int ox, int oy)
{
	int	i, j;
	double	x, y, dx, dy, mid1, mid2;
	double	xstep, ystep;
	register unsigned char *op, *up, *lp;

	xstep = (double)(ix - 1) / (double)ox - 1.0e-6;
	ystep = (double)(iy - 1) / (double)oy - 1.0e-6;

	/* For each output pixel */
	for( j = 0; j < oy; j++ ) {
		y = j * ystep;
		/*
		 * Make sure we have this row (and the one after it)
		 * in the buffer
		 */
		bufy = (int)y - buf_start;
		if( bufy < 0 || bufy >= buflines-1 ) {
			fill_buffer( (int)y );
			bufy = (int)y - buf_start;
		}

		op = outbuf;

		for( i = 0; i < ox; i++ ) {
			x = i * xstep;
			dx = x - (int)x;
			dy = y - (int)y;

			/* Note: (1-a)*foo + a*bar = foo + a*(bar-foo) */

			lp = &buffer[bufy*scanlen+(int)x*3];
			up = &buffer[(bufy+1)*scanlen+(int)x*3];

			/* Red */
			mid1 = lp[0] + dx * ((double)lp[3] - (double)lp[0]);
			mid2 = up[0] + dx * ((double)up[3] - (double)up[0]);
			*op++ = mid1 + dy * (mid2 - mid1);
			lp++; up++;

			/* Green */
			mid1 = lp[0] + dx * ((double)lp[3] - (double)lp[0]);
			mid2 = up[0] + dx * ((double)up[3] - (double)up[0]);
			*op++ = mid1 + dy * (mid2 - mid1);
			lp++; up++;

			/* Blue */
			mid1 = lp[0] + dx * ((double)lp[3] - (double)lp[0]);
			mid2 = up[0] + dx * ((double)up[3] - (double)up[0]);
			*op++ = mid1 + dy * (mid2 - mid1);
		}

		(void) fwrite( outbuf, 3, ox, ofp );
	}
}

/*
 * Nearest Neighbor Interpolate a file of pixels.
 *
 * This version preserves the outside pixels and interps inside only.
 */
void
ninterp(FILE *ofp, int ix, int iy, int ox, int oy)
{
	int	i, j;
	double	x, y;
	double	xstep, ystep;
	unsigned char *op, *lp;

	xstep = (double)(ix - 1) / (double)ox - 1.0e-6;
	ystep = (double)(iy - 1) / (double)oy - 1.0e-6;

	/* For each output pixel */
	for( j = 0; j < oy; j++ ) {
		y = j * ystep;
		/*
		 * Make sure we have this row (and the one after it)
		 * in the buffer
		 */
		bufy = (int)y - buf_start;
		if( bufy < 0 || bufy >= buflines-1 ) {
			fill_buffer( (int)y );
			bufy = (int)y - buf_start;
		}

		op = outbuf;

		for( i = 0; i < ox; i++ ) {
			x = i * xstep;
			lp = &buffer[bufy*scanlen+(int)x*3];
			*op++ = lp[0];
			*op++ = lp[1];
			*op++ = lp[2];
		}

		(void) fwrite( outbuf, 3, ox, ofp );
	}
}
@


11.10
log
@merge of ansi-6-0-branch into head
@
text
@@


11.9
log
@update copyright to include span through 2003
@
text
@d33 1
a33 1
extern int	getopt();
d55 1
a55 1
void	init_buffer(), fill_buffer(), binterp(), ninterp();
d62 1
a62 2
get_args( argc, argv )
register char **argv;
d153 1
a153 3
scale( ofp, ix, iy, ox, oy )
FILE	*ofp;
int	ix, iy, ox, oy;
d237 1
a237 2
main( argc, argv )
int argc; char **argv;
d273 1
a273 2
init_buffer( scanlen )
int scanlen;
d297 1
a297 2
fill_buffer( y )
int y;
d322 1
a322 3
binterp( ofp, ix, iy, ox, oy )
FILE	*ofp;
int	ix, iy, ox, oy;
d385 1
a385 3
ninterp( ofp, ix, iy, ox, oy )
FILE	*ofp;
int	ix, iy, ox, oy;
@


11.8
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d26 1
a26 1
 *	This software is Copyright (C) 1986 by the United States Army.
@


11.8.4.1
log
@sync to HEAD...
@
text
@d26 1
a26 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
@


11.8.10.1
log
@merge from HEAD
@
text
@d26 1
a26 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
@


11.8.2.1
log
@Initial ANSIfication
@
text
@d33 1
a33 1
extern int	getopt(int, char *const *, const char *);
d55 1
a55 1
void	init_buffer(int scanlen), fill_buffer(int y), binterp(FILE *ofp, int ix, int iy, int ox, int oy), ninterp(FILE *ofp, int ix, int iy, int ox, int oy);
d62 2
a63 1
get_args(int argc, register char **argv)
d154 3
a156 1
scale(FILE *ofp, int ix, int iy, int ox, int oy)
d240 2
a241 1
main(int argc, char **argv)
d277 2
a278 1
init_buffer(int scanlen)
d302 2
a303 1
fill_buffer(int y)
d328 3
a330 1
binterp(FILE *ofp, int ix, int iy, int ox, int oy)
d393 3
a395 1
ninterp(FILE *ofp, int ix, int iy, int ox, int oy)
@


11.8.2.2
log
@sync branch with HEAD
@
text
@d26 1
a26 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
@


11.7
log
@Converted from K&R to ANSI C - RFH
@
text
@d33 1
a33 1
extern int	getopt(int, char *const *, const char *);
d55 1
a55 1
void	init_buffer(int scanlen), fill_buffer(int y), binterp(FILE *ofp, int ix, int iy, int ox, int oy), ninterp(FILE *ofp, int ix, int iy, int ox, int oy);
d62 2
a63 1
get_args(int argc, register char **argv)
d154 3
a156 1
scale(FILE *ofp, int ix, int iy, int ox, int oy)
d240 2
a241 1
main(int argc, char **argv)
d277 2
a278 1
init_buffer(int scanlen)
d302 2
a303 1
fill_buffer(int y)
d328 3
a330 1
binterp(FILE *ofp, int ix, int iy, int ox, int oy)
d393 3
a395 1
ninterp(FILE *ofp, int ix, int iy, int ox, int oy)
@


11.6
log
@Misc compiler warnings eliminated
@
text
@d33 1
a33 1
extern int	getopt();
d55 1
a55 1
void	init_buffer(), fill_buffer(), binterp(), ninterp();
d62 1
a62 2
get_args( argc, argv )
register char **argv;
d153 1
a153 3
scale( ofp, ix, iy, ox, oy )
FILE	*ofp;
int	ix, iy, ox, oy;
d237 1
a237 2
main( argc, argv )
int argc; char **argv;
d273 1
a273 2
init_buffer( scanlen )
int scanlen;
d297 1
a297 2
fill_buffer( y )
int y;
d322 1
a322 3
binterp( ofp, ix, iy, ox, oy )
FILE	*ofp;
int	ix, iy, ox, oy;
d385 1
a385 3
ninterp( ofp, ix, iy, ox, oy )
FILE	*ofp;
int	ix, iy, ox, oy;
@


11.5
log
@
Lint fix
@
text
@d30 2
a35 1
extern unsigned char *malloc();
d61 1
a138 82
int
main( argc, argv )
int argc; char **argv;
{
	int i;

	if ( !get_args( argc, argv ) || isatty(fileno(stdout)) )  {
		(void)fputs(usage, stderr);
		exit( 1 );
	}

	if( inx <= 0 || iny <= 0 || outx <= 0 || outy <= 0 ) {
		fprintf( stderr, "pixscale: bad size\n" );
		exit( 2 );
	}

	/* See how many lines we can buffer */
	scanlen = 3 * inx;
	init_buffer( scanlen );
	if (inx < outx) i = outx * 3;
	else i = inx * 3;

	if( (outbuf = malloc(i)) == NULL )
		exit( 4 );

	/* Here we go */
	i = scale( stdout, inx, iny, outx, outy );
	free( outbuf );
	free( buffer );
	return( 0 );
}

/*
 * Determine max number of lines to buffer.
 *  and malloc space for it.
 *  XXX - CHECK FILE SIZE
 */
void
init_buffer( scanlen )
int scanlen;
{
	int	max;

	/* See how many we could buffer */
	max = MAXBUFBYTES / scanlen;

	/*
	 * Do a max of 512.  We really should see how big
	 * the input file is to decide if we should buffer
	 * less than our max.
	 */
	if( max > 4096 ) max = 4096;

	buflines = max;
	buf_start = (-buflines);
	buffer = malloc( buflines * scanlen );
}

/*
 * Load the buffer with scan lines centered around
 * the given y coordinate.
 */
void
fill_buffer( y )
int y;
{
	static int	file_pos = 0;

	buf_start = y - buflines/2;
	if( buf_start < 0 ) buf_start = 0;

	if( file_pos != buf_start * scanlen )  {
		if( fseek( buffp, buf_start * scanlen, 0 ) < 0 ) {
			fprintf( stderr, "pixscale: Can't seek to input pixel! y=%d\n", y );
			exit( 3 );
		}
		file_pos = buf_start * scanlen;
	}
	fread( buffer, scanlen, buflines, buffp );
	file_pos += buflines * scanlen;
}

d153 1
d238 83
@


11.4
log
@Eliminated some unused variables
@
text
@d137 1
@


11.3
log
@Needed to adjust initialization of buf_start according to buffer size.
@
text
@d393 1
a393 1
	double	x, y, dx, dy, mid1, mid2;
d395 1
a395 1
	unsigned char *op, *up, *lp;
@


11.2
log
@buffersize upped from 512 to 4096
@
text
@d190 1
@


11.1
log
@Release_4.4
@
text
@d187 1
a187 1
	if( max > 512 ) max = 512;
@


10.3
log
@If input from stdin is being processed sequentially, the fact that
we can't seek on pipes will no longer stop things from working properly.
@
text
@@


10.2
log
@made output buffer large enough to hold output
@
text
@d201 2
d206 6
a211 3
	if( fseek( buffp, buf_start * scanlen, 0 ) < 0 ) {
		fprintf( stderr, "pixscale: Can't seek to input pixel!\n" );
		exit( 3 );
d214 1
@


10.1
log
@Release_4.0
@
text
@d155 2
a156 2
	if (inx < outx) i = outx;
	else i = inx;
@


9.4
log
@changed to allocate output buffer the size of an output scanline
@
text
@@


9.3
log
@fixed synopsis
@
text
@d140 2
d155 4
a158 1
	if( (outbuf = malloc(scanlen)) == NULL )
d162 4
a165 1
	scale( stdout, inx, iny, outx, outy );
@


9.2
log
@Avoid the case where input x or y does not change, yet the
floating point division doesn't result in exactly 1.0.
@
text
@d57 1
a57 1
Usage: pixscale [-r] [-s squareinsize] [-w inwidth] [-n inheight]\n\
@


9.1
log
@Release_3.5
@
text
@d228 8
a235 2
	pxlen = (double)ix / (double)ox;
	pylen = (double)iy / (double)oy;
@


8.1
log
@Release_3.0
@
text
@@


7.3
log
@getopt, modern argument style, nearest neighbor interpolation
@
text
@@


7.2
log
@lint fixes
@
text
@d31 4
a34 1
unsigned char *malloc();
d36 1
a36 1
#define	MAXBUFBYTES	1024*1024	/* max bytes to malloc in buffer space */
d46 1
d48 5
a52 1
void	init_buffer(), fill_buffer(), binterp();
d54 1
a54 1
char	*Usage = "usage: pixscale infile.pix inx iny outx outy >out.pix\n";
d56 81
d140 2
a141 4
	int	inx, iny, outx, outy;

	if( argc != 6 ) {
		fprintf( stderr, Usage );
d144 1
a144 4
	inx = atoi( argv[2] );
	iny = atoi( argv[3] );
	outx = atoi( argv[4] );
	outy = atoi( argv[5] );
a149 5
	if( (buffp = fopen( argv[1], "r" )) == NULL ) {
		fprintf( stderr, "pixscale: can't open \"%s\"\n", argv[1] );
		exit( 3 );
	}

d196 4
a199 1
	fseek( buffp, buf_start * scanlen, 0 );
d235 7
a241 2
		/* bilinear interpolate */
		binterp( ofp, ix, iy, ox, oy );
d355 45
@


7.1
log
@Release 2.3
@
text
@d44 2
d86 1
d110 1
d214 1
@


6.1
log
@Release 2.0
@
text
@@


5.1
log
@Release 1.24
@
text
@@


4.2
log
@Release 1.20 -- First Formal Release
@
text
@@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@@


1.3
log
@optimized interpolation a bit
@
text
@@


1.2
log
@added size arg check, removed some lint.
@
text
@d4 1
a4 1
 * Scale an RGB pix file.
d6 3
a8 3
 * To scale up, we use bilinear interpolation.
 * To scale down, we assume "square pixels" and preserve the
 * amount of light energy per unit area.
d10 2
a11 2
 * This is a buffered version that can handle files of
 * almost arbitrary size.
d13 1
a13 1
 * Note: This is a simple extension to bwcrop.  Improvements made
d35 1
d72 2
d140 1
a140 1
	unsigned char outpixel;
d158 1
d196 3
a198 6
			outpixel = (int)(sumr / (pxlen * pylen));
			fwrite( &outpixel, sizeof(outpixel), 1, ofp );
			outpixel = (int)(sumg / (pxlen * pylen));
			fwrite( &outpixel, sizeof(outpixel), 1, ofp );
			outpixel = (int)(sumb / (pxlen * pylen));
			fwrite( &outpixel, sizeof(outpixel), 1, ofp );
d200 1
d217 1
a217 1
	unsigned char outpixel;
d235 2
d244 3
d248 4
a251 4
			mid1 = (1.0 - dx) * buffer[bufy*scanlen+(int)x*3] + dx * buffer[bufy*scanlen+(int)(x+1)*3];
			mid2 = (1.0 - dx) * buffer[(bufy+1)*scanlen+(int)x*3] + dx * buffer[(bufy+1)*scanlen+(int)(x+1)*3];
			outpixel = (1.0 - dy) * mid1 + dy * mid2;
			fwrite( &outpixel, sizeof(outpixel), 1, ofp );
d254 4
a257 4
			mid1 = (1.0 - dx) * buffer[bufy*scanlen+(int)x*3+1] + dx * buffer[bufy*scanlen+(int)(x+1)*3+1];
			mid2 = (1.0 - dx) * buffer[(bufy+1)*scanlen+(int)x*3+1] + dx * buffer[(bufy+1)*scanlen+(int)(x+1)*3+1];
			outpixel = (1.0 - dy) * mid1 + dy * mid2;
			fwrite( &outpixel, sizeof(outpixel), 1, ofp );
d260 3
a262 4
			mid1 = (1.0 - dx) * buffer[bufy*scanlen+(int)x*3+2] + dx * buffer[bufy*scanlen+(int)(x+1)*3+2];
			mid2 = (1.0 - dx) * buffer[(bufy+1)*scanlen+(int)x*3+2] + dx * buffer[(bufy+1)*scanlen+(int)(x+1)*3+2];
			outpixel = (1.0 - dy) * mid1 + dy * mid2;
			fwrite( &outpixel, sizeof(outpixel), 1, ofp );
d264 2
@


1.1
log
@Initial revision
@
text
@a47 1
	int	i, j;
a48 1
	unsigned char linebuf[512];
d58 4
d65 1
a65 1
		exit( 2 );
d73 1
a73 1
	scale( stdin, inx, iny, stdout, outx, outy );
a106 2
	int	i;

d128 2
a129 2
scale( ifp, ix, iy, ofp, ox, oy )
FILE *ifp, *ofp;
d147 1
a147 1
		binterp( ifp, ix, iy, ofp, ox, oy );
d208 2
a209 2
binterp( ifp, ix, iy, ofp, ox, oy )
FILE *ifp, *ofp;
@
