head	11.9;
access;
symbols
	ansi-20040405-merged:11.5.2.2
	postmerge-20040405-ansi:11.7
	premerge-20040404-ansi:11.6
	postmerge-autoconf:11.6
	autoconf-freeze:11.5.10.2
	premerge-autoconf:11.6
	postmerge-20040315-windows:11.6
	premerge-20040315-windows:11.6
	windows-20040315-freeze:11.5.4.1
	autoconf-20031203:11.5
	autoconf-20031202:11.5
	autoconf-branch:11.5.0.10
	phong-branch:11.5.0.8
	photonmap-branch:11.5.0.6
	rel-6-1-DP:11.5
	windows-branch:11.5.0.4
	rel-6-0-2:11.3
	ansi-branch:11.5.0.2
	rel-6-0-1-branch:11.3.0.2
	hartley-6-0-post:11.4
	hartley-6-0-pre:11.3
	rel-6-0-1:11.3
	rel-6-0:11.3
	rel-5-4:11.1
	offsite-5-3-pre:11.3
	rel-5-3:11.1
	rel-5-2:11.1
	rel-5-1-branch:11.1.0.2
	rel-5-1:11.1
	rel-5-0:11.1
	rel-5-0-beta:11.1
	rel-4-5:11.1
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:5.1
	rel-1-24:5.1;
locks; strict;
comment	@ * @;


11.9
date	2004.05.21.14.57.59;	author morrison;	state dead;
branches;
next	11.8;

11.8
date	2004.05.10.15.30.51;	author erikg;	state Exp;
branches;
next	11.7;

11.7
date	2004.04.05.05.46.02;	author morrison;	state Exp;
branches;
next	11.6;

11.6
date	2004.02.02.17.39.50;	author morrison;	state Exp;
branches;
next	11.5;

11.5
date	2002.08.20.17.09.05;	author jra;	state Exp;
branches
	11.5.2.1
	11.5.4.1
	11.5.10.1;
next	11.4;

11.4
date	2002.08.15.20.56.16;	author hartley;	state Exp;
branches;
next	11.3;

11.3
date	2000.09.01.03.24.02;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	2000.08.23.19.05.01;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.13.14;	author mike;	state Rel4_4;
branches;
next	10.5;

10.5
date	94.12.12.19.51.35;	author cjohnson;	state Exp;
branches;
next	10.4;

10.4
date	94.11.24.02.36.08;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	94.08.23.13.28.19;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	93.10.26.02.39.29;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.49.09;	author mike;	state Rel4_0;
branches;
next	9.9;

9.9
date	91.07.25.02.27.45;	author mike;	state Exp;
branches;
next	9.8;

9.8
date	91.02.09.00.55.52;	author mike;	state Exp;
branches;
next	9.7;

9.7
date	90.12.14.20.40.44;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	90.06.23.01.23.47;	author phil;	state Exp;
branches;
next	9.5;

9.5
date	90.06.22.04.37.03;	author phil;	state Exp;
branches;
next	9.4;

9.4
date	90.06.22.02.54.57;	author phil;	state Exp;
branches;
next	9.3;

9.3
date	90.06.22.02.44.27;	author phil;	state Exp;
branches;
next	9.2;

9.2
date	90.02.22.23.01.56;	author phil;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.11.16;	author mike;	state Rel3_5;
branches;
next	8.6;

8.6
date	89.04.29.00.10.06;	author mike;	state Exp;
branches;
next	8.5;

8.5
date	89.04.27.15.25.53;	author mike;	state Exp;
branches;
next	8.4;

8.4
date	89.04.24.08.21.12;	author phil;	state Exp;
branches;
next	8.3;

8.3
date	89.03.19.23.37.41;	author phil;	state Exp;
branches;
next	8.2;

8.2
date	89.02.27.01.01.25;	author phil;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.43.49;	author mike;	state Rel3_0;
branches;
next	7.17;

7.17
date	88.09.17.00.11.04;	author phil;	state Exp;
branches;
next	7.16;

7.16
date	88.09.10.00.04.36;	author phil;	state Exp;
branches;
next	7.15;

7.15
date	88.08.19.06.55.29;	author phil;	state Exp;
branches;
next	7.14;

7.14
date	88.08.19.04.51.05;	author phil;	state Exp;
branches;
next	7.13;

7.13
date	88.07.21.07.18.00;	author phil;	state Exp;
branches;
next	7.12;

7.12
date	88.07.21.04.23.20;	author phil;	state Exp;
branches;
next	7.11;

7.11
date	88.02.25.05.24.37;	author phil;	state Exp;
branches;
next	7.10;

7.10
date	88.02.20.07.13.17;	author phil;	state Exp;
branches;
next	7.9;

7.9
date	88.02.19.19.25.46;	author phil;	state Exp;
branches;
next	7.8;

7.8
date	88.02.11.04.36.02;	author mike;	state Exp;
branches;
next	7.7;

7.7
date	88.02.11.04.34.21;	author phil;	state Exp;
branches;
next	7.6;

7.6
date	88.02.05.06.47.42;	author phil;	state Exp;
branches;
next	7.5;

7.5
date	88.01.30.01.17.43;	author phil;	state Exp;
branches;
next	7.4;

7.4
date	88.01.29.22.11.10;	author phil;	state Exp;
branches;
next	7.3;

7.3
date	88.01.22.23.41.37;	author phil;	state Exp;
branches;
next	7.2;

7.2
date	88.01.19.23.45.57;	author phil;	state Exp;
branches;
next	7.1;

7.1
date	87.11.03.00.09.48;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.08.13.15;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.44.14;	author mike;	state Rel;
branches;
next	1.2;

1.2
date	87.06.19.23.45.12;	author phil;	state Exp;
branches;
next	1.1;

1.1
date	87.06.19.23.40.25;	author phil;	state Exp;
branches;
next	;

11.5.2.1
date	2002.09.19.18.02.44;	author morrison;	state Exp;
branches;
next	11.5.2.2;

11.5.2.2
date	2004.03.17.21.23.35;	author morrison;	state Exp;
branches;
next	;

11.5.4.1
date	2004.03.11.23.52.35;	author morrison;	state Exp;
branches;
next	;

11.5.10.1
date	2004.02.12.19.43.12;	author erikg;	state Exp;
branches;
next	11.5.10.2;

11.5.10.2
date	2004.03.15.14.08.20;	author erikg;	state Exp;
branches;
next	;


desc
@Iris 3D Unix-plot display
@


11.9
log
@moved to src/util/
@
text
@/*
 *			P L - S G I . C
 *
 *  SGI Iris 3-D Unix Plot display program.
 *
 *  Authors -
 *	Paul R. Stay
 *	Gary S. Moss
 *	Phillip Dykstra
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1986-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/util/pl-sgi.c,v 11.8 2004/05/10 15:30:51 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#include "machine.h"		/* to define "sgi" on ANSI compilers */
#include "externs.h"

#if HAS_SGIGL
# include "gl.h"
# include "device.h"
#   ifdef mips
	/* sgi 4-D */
#	include "gl/addrs.h"
#	include "gl/cg2vme.h"
#	include "gl/get.h"
#   else
	/* sgi 3-D */
#	include <get.h>
#	define XMAX170	645
#	define YMAX170	484
#   endif
#ifdef SPACEBALL
# include "gl/spaceball.h"
#endif

#define	HUGEVAL	1.0e10	/* for near/far clipping */

#define Min( x1, x2 )	((x1) < (x2) ? (x1) : (x2))
#define Max( x1, x2 )	((x1) > (x2) ? (x1) : (x2))
#define	PI		3.1415926535898
#define	DtoR(x)		((x)*PI/180.0)
#define	RtoD(x)		((x)*180.0/PI)

Matrix	*viewmat;	/* current viewing projection */
Matrix	viewortho;	/* ortho viewing projection */
Matrix	viewpersp;	/* perspective viewing projection */
Matrix	identmat;	/* identity */
Matrix	centermat;	/* center screen matrix */
Coord	viewsize;
Matrix	g_rot;		/* Global Rotations and Translations */
double	g_scal[3];	/* Global Scales */

char	*shellcmd = NULL;
int	shellexit = 0;	/* one shot shell command! */
int	ntsc = 0;	/* use NTSC display, for video recording */
int	axis = 0;	/* display coord axis */
int	info = 0;	/* output orientation info */
int	fullscreen = 0;	/* use a full screen window (if mex) */
short	thickness = 0;	/* line thickness */
int	file_input = 0;	/* !0 if input came from a disk file */
int	minobj = 1;	/* lowest active object number */
int	maxobj = 1;	/* next available object number */
int	cmap_mode = 1;	/* !0 if in color map mode, else RGBmode */
int	onebuffer = 0;	/* !0 if in single buffer mode, else double */
long	menu;
char	*menustring;

void	uplot();

/*
 *  Color Map:
 *  In doublebuffered mode, you only have 12 bits per pixel.
 *  These get mapped via a 4096 entry colormap [0..4095].
 *  MEX however steals:
 *    0 - 15	on the 3030 (first 8 are "known" colors)
 *    top 256	on the 4D "G" and "B" machines [3840..4095] are used
 *              to support simultaneous RGB and CMAP windows.
 *  Note: as of Release 3.1, 4Sight on the 4D's uses the bottom 32 colors.
 *    To quote makemap, the lowest eight colors are the eight standard
 *    Graphics Library colors (black, red, green, yellow, blue, magenta,
 *    cyan and white).  The next 23 [8..30] are a black to white gray ramp.
 *    The remaining 225 colors [31..255] are mapped as a 5*9*5 color cube.
 */
/* Map RGB onto 10x10x10 color cube, giving index in range 0..999 */
#ifdef mips
#define MAP_RESERVED	(256+8)		/* # slots reserved by MAX */
#else
#define MAP_RESERVED	16		/* # slots reserved by MEX */
#endif
#define COLOR_APPROX(r,g,b)	\
	((r/26)+ (g/26)*10 + (b/26)*100 + MAP_RESERVED)

get_args( argc, argv )
register char **argv;
{
	register int c;

	while ( (c = getopt( argc, argv, "aft:ns:S:1" )) != EOF )  {
		switch( c )  {
		case 'a':
			axis++;
			break;
		case 'f':
			fullscreen++;
			break;
		case 't':
			thickness = atoi(optarg);
			break;
		case 'n':
			ntsc = 1;
			break;
		case 's':
			shellcmd = optarg;
			break;
		case 'S':
			shellcmd = optarg;
			shellexit++;
			break;
		case '1':
			onebuffer++;
			break;
		default:		/* '?' */
			return(0);
		}
	}

	if( optind >= argc )  {
		if( isatty(fileno(stdin)) )
			return(0);
	}

	return(1);		/* OK */
}

static char usage[] = "\
Usage: pl-sgi [options] [-t thickness] [-{s|S} shellcmd] [file.plot]\n\
   -a   Display coordinate axis\n\
   -f   Full screen window\n\
   -n   NTSC video mode\n\
   -1   Single buffer\n\
";
#endif /* sgi */

int
main(int argc, char **argv)
{
#if HAS_SGIGL
	Coord	max[3], min[3];
	char	*file;
	FILE	*fp;

	if ( !get_args( argc, argv ) )  {
		(void)fputs(usage, stderr);
		exit( 1 );
	}

	/* In case if there is no space command */
	min[0] = min[1] = min[2] = -32768.0;
	max[0] = max[1] = max[2] = 32768.0;

	init_display();

	if( optind >= argc ) {
		makeobj( maxobj++ );
		uplot( stdin, max, min );
		closeobj();
	}
	while( optind < argc ) {
		file = argv[optind];
		if( (fp = fopen(file,"r")) == NULL ) {
			fprintf(stderr,"pl-sgi: can't open \"%s\"\n", file);
			exit( 3 );
		}
		file_input = 1;

		makeobj( maxobj++ );
		uplot( fp, max, min );
		closeobj();

		fclose( fp );
		optind++;
	}

	/* scale to the largest X, Y, or Z interval */
	viewsize = max[0] - min[0];
	viewsize = Max( viewsize, max[1] - min[1] );
	viewsize = Max( viewsize, max[2] - min[2] );
	viewsize /= 2.0;

	/* set up and save the viewing projection matrix */
	if( ismex() ) {
		if( fullscreen ) {
			/* Compensate for the rectangular display surface */
#ifdef mips
			ortho( -1.25*viewsize, 1.25*viewsize,
				-viewsize, viewsize, -HUGEVAL, HUGEVAL );
#else
			ortho( -1.33*viewsize, 1.33*viewsize,
				-viewsize, viewsize, -HUGEVAL, HUGEVAL );
#endif
		} else {
			ortho( -viewsize, viewsize, -viewsize, viewsize,
				-HUGEVAL, HUGEVAL );
		}
		getmatrix( viewortho );
		perspective( 900, 1.0, 0.01, 1.0e10 );
		/*polarview( 1.414, 0, 0, 0 );*/
		getmatrix( viewpersp );
	} else {
		/* Compensate for the rectangular display surface */
		ortho( -1.33*viewsize, 1.33*viewsize,
			-viewsize, viewsize, -HUGEVAL, HUGEVAL );
		getmatrix( viewortho );
		perspective( 900, 1.0, 0.01, 1.0e10 );
		/*polarview( 1.414, 0, 0, 0 );*/
		getmatrix( viewpersp );
	}
	viewmat = (Matrix *)viewortho;

	/* Make an identity matrix */
	identmat[0][0] = identmat[1][1] = identmat[2][2] = identmat[3][3] = 1.0;
	identmat[1][0] = identmat[1][2] = identmat[1][3] = 0.0;
	identmat[2][0] = identmat[0][1] = identmat[2][3] = 0.0;
	identmat[3][0] = identmat[3][1] = identmat[3][2] = 0.0;

	/* set up and save the initial rot/trans/scale matrix */
	loadmatrix( identmat );
	translate( -(max[0]+min[0])/2.0, -(max[1]+min[1])/2.0,
		-(max[2]+min[2])/2.0 );
	getmatrix( centermat );

	/* set up the command menu */
	menu = defpup( menustring );

	/* set up line thickness/styles */
	if( thickness > 0 )
		linewidth( thickness );
	deflinestyle( 1, 0x8888 );	/* dotted */
	deflinestyle( 2, 0xF8F8 );	/* longdashed */
	deflinestyle( 3, 0xE0E0 );	/* shortdashed */
	deflinestyle( 4, 0x4F4F );	/* dotdashed */

	view_loop();
	exit( 0 );
#else
	printf( "pl-sgi: this is an SGI Iris specific program\n" );
	exit( 1 );
#endif
}

#if HAS_SGIGL
/* 
 *	V I E W _ L O O P
 */

#define	ROTX	DIAL6
#define	ROTY	DIAL4
#define	ROTZ	DIAL2
#define	TRANX	DIAL7
#define	TRANY	DIAL5
#define	TRANZ	DIAL3
#define	ZOOM	DIAL1

#define	ORTHO	SW0
#define	PERSP	SW1
#undef RESET
#define	RESET	SW2

#define	BOTTOM	SW23
#define	TOP	SW24
#define	REAR	SW25
#define	V4545	SW26
#define	RIGHT	SW28
#define	FRONT	SW29
#define	LEFT	SW30
#define	V3525	SW31

#define	MENU_CENTER	1
#define	MENU_AXIS	2
#define	MENU_INFO	3
#define	MENU_SNAP	4
#define	MENU_SHELL	5
#define	MENU_EXIT	6
char *menustring = "Center|Axis|Info|DunnSnap|ShellCmd|Exit";

/*XXX - global because it is shared with the menu/mouse input function */
float	d_tran[3];	/* Delta Translations */

int	redisplay = 1;

process_input()
{
	Device	event;
	short	val;
	Coord	fval;
	long	menuval;
	Matrix	d_rot;		/* Delta Rotations */
	float	d_scal[3];	/* Delta Scales */
	int	done;
#ifdef SPACEBALL
	float	sbrx, sbry, sbrz;
	float	sbtx, sbty, sbtz;
	float	sbperiod;
	static float sbtransrate = 0.00001;
	static float sbrotrate = 0.000001;
#endif

	done = 0;
	/*if( qtest() )*/
	event = qread( &val );
	fval = val;
	/*printf("event %d: value %d\n", event, val);*/
	/* Ignore all zero val's? XXX */

	loadmatrix ( identmat );
	d_tran[0] = d_tran[1] = d_tran[2] = 0;
	d_scal[0] = d_scal[1] = d_scal[2] = 1;

	switch (event) {
#ifdef SPACEBALL
	case SBTX:
		/*printf("SBTX\n");*/
		sbtx = fval;
		break;
	case SBTY:
		sbty = fval;
		break;
	case SBTZ:
		sbtz = fval;
		break;
	case SBRX:
		sbrx = fval;
		break;
	case SBRY:
		sbry = fval;
		break;
	case SBRZ:
		sbrz = fval;
		break;
	case SBPERIOD:
		sbperiod = fval;
		d_tran[0] = sbperiod * sbtransrate * sbtx / g_scal[0];
		d_tran[1] = sbperiod * sbtransrate * sbty / g_scal[1];
		d_tran[2] = sbperiod * sbtransrate * sbtz / g_scal[2];
		rotarbaxis( sbperiod*sbrotrate, sbrx, sbry, sbrz, d_rot );
		loadmatrix( d_rot );
		redisplay = 1;
		break;
	case SBPICK:
		/* reset - clear out the global rot/trans matrix */
		loadmatrix( centermat );
		getmatrix( g_rot );
		loadmatrix( identmat );
		redisplay = 1;
		break;
#endif
	case ROTX:
		if( val ) {
			fval *= 10.0;
			rotate( (Angle) fval, 'x' );
			setvaluator(ROTX, 0, -360, 360);
			redisplay = 1;
		}
		break;
	case ROTY:
		if( val ) {
			fval *= 10.0;
			rotate( (Angle) fval, 'y' );
			setvaluator(ROTY, 0, -360, 360);
			redisplay = 1;
		}
		break;
	case ROTZ:
		if( val ) {
			fval *= 10.0;
			rotate( (Angle) fval, 'z' );
			setvaluator(ROTZ, 0, -360, 360);
			redisplay = 1;
		}
		break;
	case TRANX:
		if( val ) {
			fval *= viewsize / 300.0;
			d_tran[0] += fval / g_scal[0];
			setvaluator(TRANX, 0, -50, 50);
			redisplay = 1;
		}
		break;
	case TRANY:
		if( val ) {
			fval *= viewsize / 300.0;
			d_tran[1] += fval / g_scal[1];
			setvaluator(TRANY, 0, -50, 50);
			redisplay = 1;
		}
		break;
	case TRANZ:
		if( val ) {
			fval *= viewsize / 300.0;
			d_tran[2] += fval / g_scal[2];
			setvaluator(TRANZ, 0, -50, 50);
			redisplay = 1;
		}
		break;
	case ZOOM:
		if( val ) {
			fval = 1.0 + fval / 1100.0;
			d_scal[0] *= fval;
			d_scal[1] *= fval;
			d_scal[2] *= fval;
			setvaluator(ZOOM, 1, -1000, 1000);
			redisplay = 1;
		}
		break;
	case LEFTMOUSE:
		if( val ) {
			fval = 0.5;
			d_scal[0] *= fval;
			d_scal[1] *= fval;
			d_scal[2] *= fval;
			redisplay = 1;
		}
		break;
	case RIGHTMOUSE:
	/*case MIDDLEMOUSE:*/
		if( val ) {
			menuval = dopup( menu );
			if( menuval == MENU_EXIT )
				done = 1;
			else
				domenu( menuval );
		}
		break;
	case MIDDLEMOUSE:
	/*case RIGHTMOUSE:*/
		if( val ) {
			fval = 2.0;
			d_scal[0] *= fval;
			d_scal[1] *= fval;
			d_scal[2] *= fval;
			redisplay = 1;
		}
		break;
	case ORTHO:
		if( val ) {
			viewmat = (Matrix *)viewortho;
			redisplay = 1;
		}
		break;
	case PERSP:
		if( val ) {
			viewmat = (Matrix *)viewpersp;
			redisplay = 1;
		}
		break;
	case RESET:
		if( val ) {
			/* reset */
			loadmatrix( centermat );
			getmatrix( g_rot );
			loadmatrix( identmat );
			redisplay = 1;
		}
		break;
	case BOTTOM:
		if( val ) {
			setview( g_rot, 180, 0, 0 );
			redisplay = 1;
		}
		break;
	case TOP:
		if( val ) {
			setview( g_rot, 0, 0, 0 );
			redisplay = 1;
		}
		break;
	case REAR:
		if( val ) {
			setview( g_rot, 270, 0, 90 );
			redisplay = 1;
		}
		break;
	case V4545:
		if( val ) {
			setview( g_rot, 270+45, 0, 270-45 );
			redisplay = 1;
		}
		break;
	case RIGHT:
		if( val ) {
			setview( g_rot, 270, 0, 0 );
			redisplay = 1;
		}
		break;
	case FRONT:
		if( val ) {
			setview( g_rot, 270, 0, 270 );
			redisplay = 1;
		}
		break;
	case LEFT:
		if( val ) {
			setview( g_rot, 270, 0, 180 );
			redisplay = 1;
		}
		break;
	case V3525:
		if( val ) {
			setview( g_rot, 270+25, 0, 270-35 );
			redisplay = 1;
		}
		break;
	case ESCKEY:
		done = 1;
		break;
	}

	/*qreset();XXX*/
	getmatrix( d_rot );
	newview( g_rot, d_rot, d_tran, d_scal, viewmat );
	return( done );
}

view_loop()
{
	int	done = 0;
	int	o = 1;		/* object number */

	/* Initial translate/rotate/scale matrix */
	loadmatrix( centermat );
	getmatrix( g_rot );
	g_scal[0] = g_scal[1] = g_scal[2] = 1;

	/*depthcue(1);*/
	/*cursoff();XXX*/

	/*
	 *  Each time through this loop, g_rot holds the current
	 *  orientation matrix.  An identity matrix is placed
	 *  on the stack and acted on by device inputs.
	 *  After inputs, g_rot = oldm * stack.
	 *  The stack is then replaced by g_rot*viewmat for drawing.
	 */
	while( !done ) {

		if( redisplay ) {
			/* Setup current view */
			loadmatrix( *viewmat );
			scale( g_scal[0], g_scal[1], g_scal[2] );
			multmatrix( g_rot );

			/* draw the object(s) */
			cursoff();
			if( cmap_mode ) {
				color(BLACK);
			} else {
				RGBcolor(0,0,0);
			}
			clear();
			if( axis )
				draw_axis();
			/* draw all objects */
			for( o = minobj; o < maxobj; o++ ) {
				/* set the default drawing color to white */
				if( cmap_mode ) {
					if( ismex() )
						color( COLOR_APPROX(255,255,255) );
					else
						color( (255&0xf0)<<4 | (255&0xf0) | (255>>4) );
				} else {
					RGBcolor(255,255,255);
				}
				callobj( o );
			}
			if( !onebuffer )
				swapbuffers();
			if( shellcmd != NULL && shellexit ) {
				system(shellcmd);
				exit(0);
			}
			curson();
			if( info )
				print_info();
			redisplay = 0;
		}

		do {
			done = process_input();
		} while(qtest());
#ifdef SPACEBALL
		sbprompt();
#endif
		/* Check for more objects to be read */
		if( !file_input && !feof(stdin) /* && select()*/ ) {
			double	max[3], min[3];
			makeobj( maxobj++ );
			uplot( stdin, max, min );
			closeobj();
		}
	}
	/*depthcue( 0 );*/
	curson();
	greset();
	tpon();
	gexit();
}

/* Window Location */
#ifdef mips
#define WINDIM	1024
#define WIN_R	(1279-MARGIN)
#else
#define WINDIM	768
#define WIN_R	(1023-MARGIN)
#endif
#define MARGIN	4			/* # pixels margin to screen edge */
#define BANNER	20
#define WIN_L	(WIN_R-WINDIM)
#define WIN_B	MARGIN
#define WIN_T	(WINDIM-BANNER-MARGIN)

init_display()
{
	int	i;
	short	r, g, b;
	int map_size;		/* # of color map slots available */

	if( ismex() ) {
		if( fullscreen )  {
			prefposition( 0, XMAXSCREEN, 0, YMAXSCREEN );
		} else if( ntsc )  {
			prefposition( 0, XMAX170, 0, YMAX170 );
		} else {
			prefposition( WIN_L, WIN_R, WIN_B, WIN_T );
		}
		foreground();
		if( winopen( "UNIX plot display" ) == -1 ) {
			printf( "No more graphics ports available.\n" );
			return	1;
		}
		wintitle( "UNIX plot display" );
		winattach();

		if( ntsc )  {
			setmonitor(NTSC);
		}

		/* Free window of position constraint.			*/
		winconstraints();
		tpoff();
		if( !onebuffer )
			doublebuffer();
#ifdef mips
		if (getplanes() > 8) {
			RGBmode();
			cmap_mode = 0;
		}
#endif
		gconfig();

		/*
		 * Deal with the SGI hardware color map
		 * Note: on a 3030, MEX will make getplanes() return
		 *  10 on a 12 bit system (or double buffered 24).
		 *  On the 4D, it still returns 12.
		 */
		map_size = 1<<getplanes(); /* 10 or 12, depending on ismex() */
		map_size -= MAP_RESERVED;	/* MEX's share */
		if( map_size > 1000 )
			map_size = 1000;	/* all we are asking for */

		/* The first 8 entries of the colormap are "known" colors */
		mapcolor( 0, 000, 000, 000 );	/* BLACK */
		mapcolor( 1, 255, 000, 000 );	/* RED */
		mapcolor( 2, 000, 255, 000 );	/* GREEN */
		mapcolor( 3, 255, 255, 000 );	/* YELLOW */
		mapcolor( 4, 000, 000, 255 );	/* BLUE */
		mapcolor( 5, 255, 000, 255 );	/* MAGENTA */
		mapcolor( 6, 000, 255, 255 );	/* CYAN */
		mapcolor( 7, 255, 255, 255 );	/* WHITE */

		/* Use fixed color map with 10x10x10 color cube */
		for( i = 0; i < map_size; i++ ) {
			mapcolor( i+MAP_RESERVED,
				  (short)((i % 10) + 1) * 25,
				  (short)(((i / 10) % 10) + 1) * 25,
				  (short)((i / 100) + 1) * 25 );
		}
	} else {
		/* not mex => 3030 with 12 planes/buffer */
		ginit();
		tpoff();
		if( !onebuffer )
			doublebuffer();
		onemap();
		gconfig();

		for( b = 0; b < 16; b++ ) {
			for( g = 0; g < 16; g++ ) {
				for( r = 0; r < 16; r++ ) {
					mapcolor( b*256+g*16+r, r<<4, g<<4, b<<4 );
				}
			}
		}
		/* XXX - Hack for the cursor until the above code gets
		 * fixed to avoid the first 8 magic entries! */
		mapcolor( 1, 255, 000, 000 );	/* RED */
	}

	/* enable ESC to exit program */
	qdevice(ESCKEY);

	/* enable the mouse */
	qdevice(LEFTMOUSE);
	qdevice(MIDDLEMOUSE);
	qdevice(RIGHTMOUSE);

	/* enable all buttons */
	for( i = 0; i < 32; i++ )
		qdevice(i+SWBASE);

	/* enable all dials */
	for (i = DIAL0; i < DIAL8; i++) {
		qdevice(i);
	}
#ifdef SPACEBALL
        /* INIT Spaceball */
	qdevice(SBTX);
	qdevice(SBTY);
	qdevice(SBTZ);
	qdevice(SBRX);
	qdevice(SBRY);
	qdevice(SBRZ);
	qdevice(SBRZ);
	qdevice(SBPERIOD);
	qdevice(SBPICK);

	/* Put daemon in Spaceball mode */
	sbcommand("do Fdo enter_spaceball_mode");
#endif

	/*
	 * SGI Dials: 1024 steps per rev
	 *   -32768 .. 32767
	 */
	setvaluator(ROTX, 0, -360, 360);
	setvaluator(ROTY, 0, -360, 360);
	setvaluator(ROTZ, 0, -360, 360);
	setvaluator(TRANX, 0, -50, 50);
	setvaluator(TRANY, 0, -50, 50);
	setvaluator(TRANZ, 0, -50, 50);
	setvaluator(ZOOM, 1, -1000, 1000);
	noise( ROTX, 2 );
	noise( ROTY, 2 );
	noise( ROTZ, 2 );
	noise( TRANX, 2 );
	noise( TRANY, 2 );
	noise( TRANZ, 2 );
	noise( ZOOM, 5 );

	blanktime( 60 * 60 * 5L );	/* 5 minute blanking */

	return	0;
}


/*
 *  Iris 3-D Unix plot reader
 *
 *  UNIX-Plot integers are 16bit VAX order (little-endian) 2's complement.
 */
#define	geti(fp,x)	{ (x) = getc(fp); (x) |= (short)(getc(fp)<<8); }
#define	getb(fp)	(getc(fp))

void
uplot( fp, max, min )
FILE	*fp;
Coord	max[3], min[3];
{
	register int	c;
	int	x, y, z, x1, y1, z1, x2, y2, z2;
	int	r, g, b;
	long	l;
	char	str[180];
	double	d[8];
	int 	o;

	/* We have to keep the "current position" ourselves
	 * for the silly labels, since the SGI can't give
	 * us the graphics position inside an object!
	 */
	double	xp, yp, zp;

	xp = yp = zp = 0;
	while( (c = getc(fp)) != EOF ) {
		switch( c ) {
		/* One of a kind functions */
		case 'e':
			if( !file_input ) {
				/* remove any objects, start a new one */
				closeobj();
				for( o = minobj; o <= maxobj; o++ )
					delobj( o );
				minobj = maxobj;
				makeobj( maxobj );
			}
			break;
		case 'F':
			/* display everything up to here */
			if( !file_input )
				return;
			break;
		case 'f':
			get_string( fp, str );
			if( strcmp(str, "solid") == 0 )
				setlinestyle( 0 );
			else if( strcmp(str, "dotted") == 0 )
				setlinestyle( 1 );
			else if( strcmp(str, "longdashed") == 0 )
				setlinestyle( 2 );
			else if( strcmp(str, "shortdashed") == 0 )
				setlinestyle( 3 );
			else if( strcmp(str, "dotdashed") == 0 )
				setlinestyle( 4 );
			else {
				fprintf(stderr, "pl-sgi: unknown linestyle \"%s\"\n", str);
				setlinestyle( 0 );
			}
			break;
		case 't':
			get_string( fp, str );
			cmov( xp, yp, zp );	/* all that for this... */
			charstr( str );
			break;
		/* 2D integer */
		case 's':
			geti(fp,x1);
			geti(fp,y1);
			geti(fp,x2);
			geti(fp,y2);
			min[0] = x1; min[1] = y1;
			max[0] = x2; max[1] = y2;
			min[2] = -1.0; max[2] = 1.0;
			break;
		case 'p':
			geti(fp,x);
			geti(fp,y);
			pnti( x, y, 0 );
			xp = x; yp = y; zp = 0;
			break;
		case 'm':
			geti(fp,x);
			geti(fp,y);
			movei( x, y, 0 );
			xp = x; yp = y; zp = 0;
			break;
		case 'n':
			geti(fp,x);
			geti(fp,y);
			drawi( x, y, 0 );
			xp = x; yp = y; zp = 0;
			break;
		case 'l':
			geti(fp,x1);
			geti(fp,y1);
			geti(fp,x2);
			geti(fp,y2);
			movei( x1, y1, 0 );
			drawi( x2, y2, 0 );
			xp = x2; yp = y2; zp = 0;
			break;
		case 'c':
			geti(fp,x);
			geti(fp,y);
			geti(fp,r);
			circ( (double)x, (double)y, (double)r );
			xp = x; yp = y; zp = 0;
			break;
		case 'a':
			geti(fp,x);
			geti(fp,y);
			geti(fp,x1);
			geti(fp,y1);
			geti(fp,x2);
			geti(fp,y2);
			/* ARC XXX */
			break;
		/* 3D integer */
		case 'S':
			geti(fp,x1);
			geti(fp,y1);
			geti(fp,z1);
			geti(fp,x2);
			geti(fp,y2);
			geti(fp,z2);
			min[0] = x1; min[1] = y1; min[2] = z1;
			max[0] = x2; max[1] = y2; max[2] = z2;
			break;
		case 'P':
			geti(fp,x);
			geti(fp,y);
			geti(fp,z);
			pnti( x, y, z );
			xp = x; yp = y; zp = z;
			break;
		case 'M':
			geti(fp,x);
			geti(fp,y);
			geti(fp,z);
			movei( x, y, z );
			xp = x; yp = y; zp = z;
			break;
		case 'N':
			geti(fp,x);
			geti(fp,y);
			geti(fp,z);
			drawi( x, y, z );
			xp = x; yp = y; zp = z;
			break;
		case 'L':
			geti(fp,x1);
			geti(fp,y1);
			geti(fp,z1);
			geti(fp,x2);
			geti(fp,y2);
			geti(fp,z2);
			movei( x1, y1, z1 );
			drawi( x2, y2, z2 );
			xp = x2; yp = y2; zp = z2;
			break;
		case 'C':
			r = getb(fp);
			g = getb(fp);
			b = getb(fp);
			if( cmap_mode ) {
				if( ismex() )
					color( COLOR_APPROX(r,g,b) );
				else
					color( (b&0xf0)<<4 | (g&0xf0) | (r>>4) );
			} else {
				RGBcolor( (short)r, (short)g, (short)b );
			}
			break;
		/* 2D and 3D IEEE */
		case 'w':
			getieee( fp, d, 4 );
			min[0] = d[0]; min[1] = d[1]; min[2] = -1.0;
			max[0] = d[2]; max[1] = d[3]; max[2] = 1.0;
			break;
		case 'W':
			getieee( fp, d, 6 );
			min[0] = d[0]; min[1] = d[1]; min[2] = d[2];
			max[0] = d[3]; max[1] = d[4]; max[2] = d[5];
			break;
		case 'o':
			getieee( fp, d, 2 );
			xp = d[0]; yp = d[1]; zp = 0;
			move( xp, yp, 0.0 );
			break;
		case 'O':
			getieee( fp, d, 3 );
			xp = d[0]; yp = d[1]; zp = d[2];
			move( xp, yp, zp );
			break;
		case 'q':
			getieee( fp, d, 2 );
			xp = d[0]; yp = d[1]; zp = 0;
			draw( xp, yp, 0.0 );
			break;
		case 'Q':
			getieee( fp, d, 3 );
			xp = d[0]; yp = d[1]; zp = d[2];
			draw( xp, yp, zp );
			break;
		case 'x':
			getieee( fp, d, 2 );
			xp = d[0]; yp = d[1]; zp = 0;
			pnt( xp, yp, 0.0 );
			break;
		case 'X':
			getieee( fp, d, 3 );
			xp = d[0]; yp = d[1]; zp = d[2];
			pnt( d[0], d[1], d[2] );
			break;
		case 'v':
			getieee( fp, d, 4 );
			move( d[0], d[1], 0.0 );
			draw( d[2], d[3], 0.0 );
			xp = d[2]; yp = d[3]; zp = 0;
			break;
		case 'V':
			getieee( fp, d, 6 );
			move( d[0], d[1], d[2] );
			draw( d[3], d[4], d[5] );
			xp = d[3]; yp = d[4]; zp = d[5];
			break;
		case 'r':
			getieee( fp, d, 6 );
			/*XXX*/
			break;
		case 'i':
			getieee( fp, d, 3 );
			circ( d[0], d[1], d[2] );
			xp = d[0]; yp = d[1]; zp = d[2];
			break;
		default:
			fprintf( stderr, "pl-sgi: bad command '%c' (0x%02x)\n", c, c );
			break;
		}
	}
}

get_string( fp, s )
FILE	*fp;
char	*s;
{
	int	c;

	while( (c = getc(fp)) != '\n' && c != EOF )
		*s++ = c;
	*s = NULL;
}

getieee( fp, out, n )
FILE	*fp;
double	out[];
int	n;
{
	char	in[8*16];
	fread( in, 8, n, fp );
	ntohd( out, in, n );
}

setview( m, rx, ry, rz )
Matrix	m;
int	rx, ry, rz;
{
	/* Hmm... save translation and scale? */
	loadmatrix( centermat );
	getmatrix( m );
	loadmatrix( identmat );

	rotate( (Angle) rx*10, 'x' );
	rotate( (Angle) ry*10, 'y' );
	rotate( (Angle) rz*10, 'z' );
#ifdef never
	calpha = cos( alpha );
	cbeta = cos( beta );    
	cgamma = cos( ggamma ); 

	salpha = sin( alpha );
	sbeta = sin( beta ); 
	sgamma = sin( ggamma );
            
	mat[0] = cbeta * cgamma;
	mat[1] = -cbeta * sgamma;
	mat[2] = sbeta;

	mat[4] = salpha * sbeta * cgamma + calpha * sgamma;
	mat[5] = -salpha * sbeta * sgamma + calpha * cgamma;
	mat[6] = -salpha * cbeta;

	mat[8] = -calpha * sbeta * cgamma + salpha * sgamma;
	mat[9] = calpha * sbeta * sgamma + salpha * cgamma;
	mat[10] = calpha * cbeta;
#endif
}

newview( orient, rot, tran, scal, viewmat )
Matrix	orient, rot, viewmat;
float	tran[3], scal[3];
{
	/*
	 * combine new operations with old
	 *  orient = orient * scal * trans * rot * view
	 */
	g_scal[0] *= scal[0];
	g_scal[1] *= scal[1];
	g_scal[2] *= scal[2];
	loadmatrix( rot );
	translate( tran[0], tran[1], tran[2] );
	multmatrix( orient );
	getmatrix( orient );

	/* set up total viewing transformation */
	loadmatrix( viewmat );
	scale( g_scal[0], g_scal[1], g_scal[2] );
	multmatrix( orient );
}

print_info()
{
	double	xrot, yrot, zrot, cosyrot;

	/*
	 * This rotation decomposition fails when yrot is
	 * ~ +/- 90 degrees. [cos(yrot) ~= 0, divide by zero]
	 */
	yrot = asin(g_rot[2][0]);
	cosyrot = cos(yrot);
	zrot = asin(g_rot[1][0]/-cosyrot);
	xrot = asin(g_rot[2][1]/-cosyrot);

	printf( "rot:   %f %f %f\n", RtoD(xrot), RtoD(yrot), RtoD(zrot) );
	printf( "tran:  %f %f %f\n", g_rot[3][0], g_rot[3][1], g_rot[3][2] );
	printf( "scale: %f\n", g_scal[0] );
}

domenu( n )
int	n;
{
	long	left, bottom, winx_size, winy_size;
	long	x, y;
	double	fx, fy;
	int	ret;
#ifdef mips
	long	video;
#endif

	switch( n ) {
	case MENU_CENTER:
		x = getvaluator(CURSORX);
		y = getvaluator(CURSORY);
		getsize( &winx_size, &winy_size);
		getorigin( &left, &bottom );
		fx = 0.5 - (x - left) / (double)winx_size;
		fy = 0.5 - (y - bottom) / (double)winy_size;
		d_tran[0] += fx * 2.0 * viewsize / g_scal[0];
		d_tran[1] += fy * 2.0 * viewsize / g_scal[1];
		redisplay = 1;
		break;
	case MENU_AXIS:
		if( axis == 0 )
			axis = 1;
		else
			axis = 0;
		redisplay = 1;
		break;
	case MENU_INFO:
		if( info == 0 ) {
			info = 1;
			print_info();
		} else
			info = 0;
		break;
	case MENU_SNAP:
		cursoff();
#ifdef mips
		video = getvideo(DE_R1);
		setvideo( DE_R1, DER1_30HZ|DER1_UNBLANK );
#else
		system("Set30");
#endif
		ret = system("dunnsnap");
#ifdef mips
		setvideo( DE_R1, video );
#else
		system("Set60");
#endif
		curson();
		if( ret ) {
			fprintf( stderr, "pl-sgi: Snap failed. Out of film?\n" );
			ringbell();
		}
		break;
	case MENU_SHELL:
		if (shellcmd != NULL) {
			cursoff();
			system(shellcmd);
			curson();
		}
		break;
	case MENU_EXIT:
		break;
	}
}

draw_axis()
{
	int	p1, p2;

	p1 = 0.12 * viewsize / g_scal[0];
	p2 = 0.14 * viewsize / g_scal[0];

	if( cmap_mode ) {
		color( MAGENTA );
	} else {
		RGBcolor(255, 0, 255);
	}
	movei( 0, 0, 0 );
	drawi( p1, 0, 0 );
	cmovi( p2, 0, 0 );
	charstr( "x" );
	movei( 0, 0, 0 );
	drawi( 0, p1, 0 );
	cmovi( 0, p2, 0 );
	charstr( "y" );
	movei( 0, 0, 0 );
	drawi( 0, 0, p1 );
	cmovi( 0, 0, p2 );
	charstr( "z" );
	movei( 0, 0, 0 );	/* back to origin */
}
#endif /* sgi */
@


11.8
log
@change conf.h to a wrapped config.h
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/util/pl-sgi.c,v 11.7 2004/04/05 05:46:02 morrison Exp $ (BRL)";
@


11.7
log
@merge of ansi-6-0-branch into head
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d24 5
a28 1
#include "conf.h"
@


11.6
log
@update copyright to include span through 2003
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/pl-sgi.c,v 11.5 2002/08/20 17:09:05 jra Exp $ (BRL)";
d158 1
a158 3
main( argc, argv )
int	argc;
char	**argv;
@


11.5
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1986 by the United States Army.
d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/pl-sgi.c,v 11.3 2000/09/01 03:24:02 mike Exp $ (BRL)";
@


11.5.4.1
log
@sync to HEAD...
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/util/pl-sgi.c,v 11.6 2004/02/02 17:39:50 morrison Exp $ (BRL)";
@


11.5.10.1
log
@merge from HEAD
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/pl-sgi.c,v 11.6 2004/02/02 17:39:50 morrison Exp $ (BRL)";
@


11.5.10.2
log
@merge from head
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/pl-sgi.c,v 11.5.10.1 2004/02/12 19:43:12 erikg Exp $ (BRL)";
@


11.5.2.1
log
@Initial ANSIfication
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/pl-sgi.c,v 11.5 2002/08/20 17:09:05 jra Exp $ (BRL)";
d158 3
a160 1
main(int argc, char **argv)
@


11.5.2.2
log
@sync branch with HEAD
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d21 1
a21 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.4
log
@Converted from K&R to ANSI C - RFH
@
text
@d158 3
a160 1
main(int argc, char **argv)
@


11.3
log
@
Lint fix
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/pl-sgi.c,v 11.2 2000/08/23 19:05:01 mike Exp $ (BRL)";
d158 1
a158 3
main( argc, argv )
int	argc;
char	**argv;
@


11.2
log
@
const RCSid
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/pl-sgi.c,v 11.1 1995/01/04 10:13:14 mike Rel4_4 $ (BRL)";
d157 1
@


11.1
log
@Release_4.4
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/pl-sgi.c,v 10.5 94/12/12 19:51:35 cjohnson Exp $ (BRL)";
@


10.5
log
@Fixxed a typo.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/pl-sgi.c,v 10.4 1994/11/24 02:36:08 mike Exp cjohnson $ (BRL)";
@


10.4
log
@GL
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/pl-sgi.c,v 10.3 94/08/23 13:28:19 gdurf Exp Locker: mike $ (BRL)";
d265 1
a265 1
#if SGI_GL
@


10.3
log
@Added include of conf.h
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/pl-sgi.c,v 10.2 1993/10/26 02:39:29 mike Exp gdurf $ (BRL)";
d31 1
a31 1
#ifdef sgi
d161 1
a161 1
#ifdef sgi
d265 1
a265 1
#ifdef sgi
@


10.2
log
@STDC void func
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/pl-sgi.c,v 10.1 91/10/12 06:49:09 mike Rel4_0 Locker: mike $ (BRL)";
d23 2
@


10.1
log
@Release_4.0
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/pl-sgi.c,v 9.9 91/07/25 02:27:45 mike Exp $ (BRL)";
d27 1
a54 4
extern int	getopt();
extern char	*optarg;
extern int	optind;

d79 2
d787 1
@


9.9
log
@5d support
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/pl-sgi.c,v 9.8 91/02/09 00:55:52 mike Exp $ (BRL)";
@


9.8
log
@lint
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/pl-sgi.c,v 9.7 90/12/14 20:40:44 mike Exp $ (BRL)";
d26 1
@


9.7
log
@Moved up reserved color map entries, so it does not
smash (expanded again) 4Sight use.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/util/RCS/pl-sgi.c,v 9.6 90/06/23 01:23:47 phil Exp $ (BRL)";
d176 1
a176 1
		makeobj( maxobj );
d178 1
a178 1
		closeobj( maxobj++ );
d188 1
a188 1
		makeobj( maxobj );
d190 1
a190 1
		closeobj( maxobj++ );
d560 1
a560 1
			loadmatrix( viewmat );
d608 1
a608 1
			makeobj( maxobj );
d610 1
a610 1
			closeobj( maxobj++ );
d812 1
a812 1
				closeobj( maxobj );
@


9.6
log
@Avoid redraws on button/mouse up events, etc.  RGBmode on 4D's with
more than 8 bit planes.  Made "axis" scale invariant.  Made translates
viewsize invariant (same fix should be applied to spaceball).  Tweaked
the "info" output, but still needs code for yrot ~= +/- 90 deg.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/pl-sgi.c,v 9.5 90/06/22 04:37:03 phil Exp $ (BRL)";
d97 1
a97 1
#define MAP_RESERVED	32		/* # slots reserved by MAX */
@


9.5
log
@Added shell command options.
Made knob and spaceball translates scale invariant.
Improved the "feel" of the knobs a bit.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/pl-sgi.c,v 9.4 90/06/22 02:54:57 phil Exp $ (BRL)";
d76 2
d84 1
a84 1
 *  These get mapped via a 4096 entry colormap.
d87 2
a88 1
 *    top 256	on the 4D
d91 3
a93 3
 *    Graphics Library colors (black, red, green, blue, magenta, cyan,
 *    and white).  The next 23 (8 to 30) are a black to white gray ramp.
 *    The remaining 225 colors (31 to 255) are mapped as a 5*9*5 color cube.
d109 1
a109 1
	while ( (c = getopt( argc, argv, "aft:ns:S:" )) != EOF )  {
d130 3
d147 6
a152 1
Usage: pl-sgi [-a -f -n] [-t thickness] [-{s|S} shellcmd] [file.plot]\n";
d301 2
d359 1
d366 1
d370 6
a375 3
		fval *= 10.0;
		rotate( (Angle) fval, 'x' );
		setvaluator(ROTX, 0, -360, 360);
d378 6
a383 3
		fval *= 10.0;
		rotate( (Angle) fval, 'y' );
		setvaluator(ROTY, 0, -360, 360);
d386 6
a391 3
		fval *= 10.0;
		rotate( (Angle) fval, 'z' );
		setvaluator(ROTZ, 0, -360, 360);
d394 6
a399 3
		fval *= 0.30;
		d_tran[0] += fval / g_scal[0];
		setvaluator(TRANX, 0, -50, 50);
d402 6
a407 3
		fval *= 0.30;
		d_tran[1] += fval / g_scal[1];
		setvaluator(TRANY, 0, -50, 50);
d410 6
a415 3
		fval *= 0.30;
		d_tran[2] += fval / g_scal[2];
		setvaluator(TRANZ, 0, -50, 50);
d418 8
a425 5
		fval = 1.0 + fval / 1100.0;
		d_scal[0] *= fval;
		d_scal[1] *= fval;
		d_scal[2] *= fval;
		setvaluator(ZOOM, 1, -1000, 1000);
d428 7
a434 6
		if( val == 0 )
			break;
		fval = 0.5;
		d_scal[0] *= fval;
		d_scal[1] *= fval;
		d_scal[2] *= fval;
d438 7
a444 7
		if( val == 0 )
			break;
		menuval = dopup( menu );
		if( menuval == MENU_EXIT )
			done = 1;
		else
			domenu( menuval );
d448 7
a454 6
		if( val == 0 )
			break;
		fval = 2.0;
		d_scal[0] *= fval;
		d_scal[1] *= fval;
		d_scal[2] *= fval;
d457 4
a460 3
		if( val == 0 )
			break;
		viewmat = (Matrix *)viewortho;
d463 4
a466 3
		if( val == 0 )
			break;
		viewmat = (Matrix *)viewpersp;
d469 7
a475 6
		if( val == 0 )
			break;
		/* reset */
		loadmatrix( centermat );
		getmatrix( g_rot );
		loadmatrix( identmat );
d478 4
a481 2
		if( val != 0 )
		setview( g_rot, 180, 0, 0 );
d484 4
a487 2
		if( val != 0 )
		setview( g_rot, 0, 0, 0 );
d490 4
a493 2
		if( val != 0 )
		setview( g_rot, 270, 0, 90 );
d496 4
a499 2
		if( val != 0 )
		setview( g_rot, 270+45, 0, 270-45 );
d502 4
a505 2
		if( val != 0 )
		setview( g_rot, 270, 0, 0 );
d508 4
a511 2
		if( val != 0 )
		setview( g_rot, 270, 0, 270 );
d514 4
a517 2
		if( val != 0 )
		setview( g_rot, 270, 0, 180 );
d520 4
a523 2
		if( val != 0 )
		setview( g_rot, 270+25, 0, 270-35 );
a538 1
	int	redisplay = 1;
a558 2
			redisplay = 0;

d566 5
a570 1
			color(BLACK);
d577 8
a584 4
				if( ismex() )
					color( COLOR_APPROX(255,255,255) );
				else
					color( (255&0xf0)<<4 | (255&0xf0) | (255>>4) );
d587 2
a588 1
			swapbuffers();
d594 3
a604 2
		redisplay = 1;	/*XXX*/

d654 1
d663 9
a671 3
		doublebuffer();
		gconfig();	/* Must be called after singlebuffer().	*/
		winattach();
d691 1
a691 1
		mapcolor( 6, 000, 255, 000 );	/* CYAN */
d705 2
a706 1
		doublebuffer();
d946 8
a953 4
			if( ismex() )
				color( COLOR_APPROX(r,g,b) );
			else
				color( (b&0xf0)<<4 | (g&0xf0) | (r>>4) );
d1100 1
d1102 16
a1117 11
	if( info ) {
		double	xrot, yrot, zrot, cosyrot;
		printf( "(%f %f %f) scale %f\n",
			orient[3][0], orient[3][1], orient[3][2],
			g_scal[0] );
		yrot = asin(orient[2][0]);
		cosyrot = cos(yrot);
		zrot = asin(orient[1][0]/-cosyrot);
		xrot = asin(orient[2][1]/-cosyrot);
		printf( "rot: %f %f %f\n", RtoD(xrot), RtoD(yrot), RtoD(zrot) );
	}
d1141 1
d1148 1
d1151 1
a1151 1
		if( info == 0 )
d1153 2
a1154 1
		else
d1178 5
a1182 3
		cursoff();
		system(shellcmd);
		curson();
d1191 10
a1200 1
	color( MAGENTA );
d1202 2
a1203 2
	drawi( 10, 0, 0 );
	cmovi( 12, 0, 0 );
d1206 2
a1207 2
	drawi( 0, 10, 0 );
	cmovi( 0, 12, 0 );
d1210 2
a1211 2
	drawi( 0, 0, 10 );
	cmovi( 0, 0, 12 );
@


9.4
log
@New input structure - rolls entire event queue together before redisplay.
Names of global vs. delta rot/trans/scale have been "rationalized".
First cut at SPACEBALL support added (-DSPACEBALL).
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /d/phil/spaceball/RCS/pl-sgi.c,v 1.6 90/05/05 04:56:50 phil Exp $ (BRL)";
d66 2
d106 1
a106 1
	while ( (c = getopt( argc, argv, "aft:n" )) != EOF )  {
d120 7
d141 1
a141 1
Usage: pl-sgi [-a -f -n] [-t thickness] [file.plot]\n";
d283 3
a285 2
#define	MENU_EXIT	5
char *menustring = "Center|Axis|Info|DunnSnap|Exit";
d341 3
a343 3
		d_tran[0] = sbperiod * sbtransrate * sbtx;
		d_tran[1] = sbperiod * sbtransrate * sbty;
		d_tran[2] = sbperiod * sbtransrate * sbtz;
d355 1
a355 1
		fval *= 5.0;
d360 1
a360 1
		fval *= 5.0;
d365 1
a365 1
		fval *= 5.0;
d370 3
a372 8
		/* XXX PROBLEM - TRAN[XYZ] vary with zoom, i.e. it takes more
		 * knob twist to move a tiny object across the screen than
		 * a large one.  Also quantization courseness.
		 */
		/*fval *= viewsize/200.0;*/
		fval *= 0.50;
		d_tran[0] += fval;
		setvaluator(TRANX, 0, -10, 10);
d375 3
a377 4
		/*fval *= viewsize/200.0;*/
		fval *= 0.50;
		d_tran[1] += fval;
		setvaluator(TRANY, 0, -10, 10);
d380 3
a382 4
		/*fval *= viewsize/200.0;*/
		fval *= 0.50;
		d_tran[2] += fval;
		setvaluator(TRANZ, 0, -10, 10);
d525 5
a530 1
			swapbuffers();
d689 3
a691 3
	setvaluator(TRANX, 0, -10, 10);
	setvaluator(TRANY, 0, -10, 10);
	setvaluator(TRANZ, 0, -10, 10);
d693 6
a698 6
	noise( ROTX, 5 );
	noise( ROTY, 5 );
	noise( ROTZ, 5 );
	noise( TRANX, 5 );
	noise( TRANY, 5 );
	noise( TRANZ, 5 );
d1057 2
a1058 2
		d_tran[0] += fx * 2.0 * viewsize;
		d_tran[1] += fy * 2.0 * viewsize;
d1091 5
@


9.3
log
@Experimental rotation decomposition code.  Fails at critical angles.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /secad/phil/spaceball/RCS/pl-sgi.c,v 1.3 90/05/05 02:19:23 phil Exp $ (BRL)";
d41 3
d45 1
a45 1
#define	HUGE	1.0e10	/* for near/far clipping */
d63 2
a64 1
double	globalscale[3];
d188 1
a188 1
				-viewsize, viewsize, -HUGE, HUGE );
d191 1
a191 1
				-viewsize, viewsize, -HUGE, HUGE );
d195 1
a195 1
				-HUGE, HUGE );
d204 1
a204 1
			-viewsize, viewsize, -HUGE, HUGE );
d277 2
a278 2
/*XXX*/
float	tran[3];	/* xyz screen space translate */
d280 1
a280 1
view_loop()
a281 1
	Matrix	m;		/* our overall composite orientation matrix */
d284 1
a284 2
	int	end_it = 0;
	int	o = 1;
d286 10
a295 2
	Matrix	rot;		/* rotations for this pass thru the loop */
	float	scal[3];	/* scale */
d297 6
d304 178
d484 2
a485 4
	getmatrix( m );
	tran[0] = tran[1] = tran[2] = 0;
	scal[0] = scal[1] = scal[2] = 1;
	globalscale[0] = globalscale[1] = globalscale[2] = 1;
d491 1
a491 1
	 *  Each time through this loop, m holds the current
d494 2
a495 2
	 *  After inputs, m = oldm * stack.
	 *  The stack is then replaced by m*viewmat for drawing.
d497 1
a497 2
	while( 1 ) {
		Coord		fval;
d499 2
a500 3
		if( qtest() )
			event = qread( &val );
		fval = val;
d502 4
a505 3
		loadmatrix ( identmat );
		tran[0] = tran[1] = tran[2] = 0;
		scal[0] = scal[1] = scal[2] = 1;
a506 132
		switch (event) {
		case ROTX:
			fval *= 5.0;
			rotate( (Angle) fval, 'x' );
			setvaluator(ROTX, 0, -360, 360);
			break;
		case ROTY:
			fval *= 5.0;
			rotate( (Angle) fval, 'y' );
			setvaluator(ROTY, 0, -360, 360);
			break;
		case ROTZ:
			fval *= 5.0;
			rotate( (Angle) fval, 'z' );
			setvaluator(ROTZ, 0, -360, 360);
			break;
		case TRANX:
			fval *= viewsize/200.0;
			tran[0] += fval;
			/*translate( fval, 0.0, 0.0 );*/
			setvaluator(TRANX, 0, -10, 10);
			break;
		case TRANY:
			fval *= viewsize/200.0;
			tran[1] += fval;
			/*translate( 0.0, fval, 0.0 );*/
			setvaluator(TRANY, 0, -10, 10);
			break;
		case TRANZ:
			fval *= viewsize/200.0;
			tran[2] += fval;
			/*translate( 0.0, 0.0, fval );*/
			setvaluator(TRANZ, 0, -10, 10);
			break;
		case ZOOM:
			fval = 1.0 + fval / 1100.0;
			scal[0] *= fval;
			scal[1] *= fval;
			scal[2] *= fval;
			/*scale( fval, fval, fval );*/
			setvaluator(ZOOM, 1, -1000, 1000);
			break;
		case LEFTMOUSE:
			if( val == 0 )
				break;
			fval = 0.5;
			scal[0] *= fval;
			scal[1] *= fval;
			scal[2] *= fval;
			/*scale( fval, fval, fval );*/
			break;
		case RIGHTMOUSE:
		/*case MIDDLEMOUSE:*/
			if( val == 0 )
				break;
			menuval = dopup( menu );
			if( menuval == MENU_EXIT )
				end_it = 1;
			else
				domenu( menuval );
			break;
		case MIDDLEMOUSE:
		/*case RIGHTMOUSE:*/
			if( val == 0 )
				break;
			fval = 2.0;
			scal[0] *= fval;
			scal[1] *= fval;
			scal[2] *= fval;
			/*scale( fval, fval, fval );*/
			break;
		case ORTHO:
			if( val == 0 )
				break;
			viewmat = (Matrix *)viewortho;
			break;
		case PERSP:
			if( val == 0 )
				break;
			viewmat = (Matrix *)viewpersp;
			break;
		case RESET:
			if( val == 0 )
				break;
			/* reset */
			loadmatrix( centermat );
			getmatrix( m );
			loadmatrix( identmat );
			break;
		case BOTTOM:
			if( val != 0 )
			setview( m, 180, 0, 0 );
			break;
		case TOP:
			if( val != 0 )
			setview( m, 0, 0, 0 );
			break;
		case REAR:
			if( val != 0 )
			setview( m, 270, 0, 90 );
			break;
		case V4545:
			if( val != 0 )
			setview( m, 270+45, 0, 270-45 );
			break;
		case RIGHT:
			if( val != 0 )
			setview( m, 270, 0, 0 );
			break;
		case FRONT:
			if( val != 0 )
			setview( m, 270, 0, 270 );
			break;
		case LEFT:
			if( val != 0 )
			setview( m, 270, 0, 180 );
			break;
		case V3525:
			if( val != 0 )
			setview( m, 270+25, 0, 270-35 );
			break;
		}
		if (end_it == 1)
			break;

		if( event ) {
			event = 0;
			qreset();

			getmatrix( rot );
			newview( m, rot, tran, scal, viewmat );

d526 8
d643 3
d659 11
d671 4
d1005 3
a1007 3
	globalscale[0] *= scal[0];
	globalscale[1] *= scal[1];
	globalscale[2] *= scal[2];
d1015 1
a1015 1
	scale( globalscale[0], globalscale[1], globalscale[2] );
d1022 1
a1022 1
			globalscale[0] );
d1050 2
a1051 2
		tran[0] += fx * 2.0 * viewsize;
		tran[1] += fy * 2.0 * viewsize;
@


9.2
log
@Update current graphics position on 3D floating Point command
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/pl-sgi.c,v 9.1 89/05/19 06:11:16 mike Rel3_5 Locker: phil $ (BRL)";
d25 1
d46 3
d60 1
d293 1
d920 3
a924 1
	scale( scal[0], scal[1], scal[2] );
d930 1
d934 1
d937 6
a942 1
			orient[3][3] );
@


9.1
log
@Release_3.5
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: pl-sgi.c,v 8.6 89/04/29 00:10:06 mike Exp $ (BRL)";
d819 1
@


8.6
log
@Fixed to compile on the 3-D machines, although it has not been tested.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: pl-sgi.c,v 8.5 89/04/27 15:25:53 mike Locked $ (BRL)";
@


8.5
log
@Added -n flag for real-time NTSC plotting
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: pl-sgi.c,v 8.4 89/04/24 08:21:12 mike Locked $ (BRL)";
d29 11
a39 5
#  ifdef mips
#   include "gl/addrs.h"
#   include "gl/cg2vme.h"
#   include "gl/get.h"
#  endif
@


8.4
log
@On the 4D, change to 30Hz mode directly, rather than depending
on having Set30 and Set60 programs around.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: pl-sgi.c,v 8.3 89/03/19 23:37:41 phil Locked $ (BRL)";
d29 5
a33 4
#ifdef mips
# include "gl/addrs.h"
# include "gl/cg2vme.h"
#endif
d51 1
d89 1
a89 1
	while ( (c = getopt( argc, argv, "aft:" )) != EOF )  {
d100 3
d117 1
a117 1
Usage: pl-sgi [-a -f] [-t thickness] [file.plot]\n";
d491 1
a491 1
		if( fullscreen )
d493 3
a495 1
		else
d497 1
d504 5
@


8.3
log
@SGI strikes again (4Sight now reserves 32 colormap entries)
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: pl-sgi.c,v 8.2 89/02/27 01:01:25 phil Locked $ (BRL)";
d29 4
d238 1
d918 3
d947 4
d952 1
d954 3
d958 1
@


8.2
log
@#endif /* comment */
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: pl-sgi.c,v 8.1 88/10/05 00:43:49 phil Locked $ (BRL)";
d63 5
d70 3
d74 1
a504 3
#ifdef mips
		map_size = 1<<10;	/*XXX*/
#endif /* mips */
d506 2
@


8.1
log
@Release_3.0
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: pl-sgi.c,v 7.17 88/09/17 00:11:04 phil Exp $ (BRL)";
d100 1
a100 1
#endif sgi
d498 1
a498 1
#endif mips
d962 1
a962 1
#endif sgi
@


7.17
log
@removed paths from DunnSnap "system" commands to be non-brl specific
(at the risk of complaints due to deficient PATHs)
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: pl-sgi.c,v 7.16 88/09/10 00:04:36 phil Locked $ (BRL)";
@


7.16
log
@changed usage message to match pl-fb format
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: pl-sgi.c,v 7.15 88/08/19 06:55:29 phil Locked $ (BRL)";
d931 3
a933 3
		system("/usr/brl/bin/Set30");
		ret = system("/usr/brlcad/bin/dunnsnap");
		system("/usr/brl/bin/Set60");
@


7.15
log
@getopt, multiple input files, line styles and widths.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: pl-sgi.c,v 7.14 88/08/19 04:51:05 phil Locked $ (BRL)";
d99 1
a99 1
Usage: pl-sgi [-a -f] [-t #] [file.plot]\n";
@


7.14
log
@-f full screen mode, menu enhancement, dunnsnap hack
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: pl-sgi.c,v 7.13 88/07/21 07:18:00 phil Locked $ (BRL)";
d35 4
d49 2
d69 29
d99 1
a99 1
Usage: pl-sgi [-a] < unixplot\n";
d108 2
d111 2
a112 13
	while( argc > 1 ) {
		if( strcmp(argv[1],"-a") == 0 ) {
			axis++;
		} else if( strcmp(argv[1],"-f") == 0 ) {
			fullscreen++;
		} else
			break;
		argc--;
		argv++;
	}

	if( isatty(fileno(stdin)) ) {
		fprintf( stderr, usage );
d122 12
a133 8
	makeobj( maxobj );
	/* set the default drawing color to white */
	if( ismex() )
		color( COLOR_APPROX(255,255,255) );
	else
		color( (255&0xf0)<<4 | (255&0xf0) | (255>>4) );
	uplot( max, min );
	closeobj( maxobj++ );	/* it's for real now */
d135 8
d194 8
d423 7
a429 1
			for( o = minobj; o < maxobj; o++ )
d431 1
d437 1
a437 1
		if( !feof(stdin) /* && select()*/ ) {
d440 1
a440 1
			uplot( max, min );
d582 2
a583 2
#define	geti(x)	{ (x) = getchar(); (x) |= (short)(getchar()<<8); }
#define	getb()	(getchar())
d585 3
a587 2
uplot( max, min )
Coord max[3], min[3];
d604 1
a604 1
	while( (c = getchar()) != EOF ) {
d608 8
a615 11
			/* remove any objects, start a new one */
			closeobj( maxobj );
			for( o = minobj; o <= maxobj; o++ )
				delobj( o );
			minobj = maxobj;
			makeobj( maxobj );
			/* set the default drawing color */
			if( ismex() )
				color( COLOR_APPROX(255,255,255) );
			else
				color( (255&0xf0)<<4 | (255&0xf0) | (255>>4) );
d619 3
a621 1
			return;
d623 15
a637 1
			eat_string();
d640 1
a640 1
			get_string( str );
d646 4
a649 4
			geti(x1);
			geti(y1);
			geti(x2);
			geti(y2);
d655 2
a656 2
			geti(x);
			geti(y);
d661 2
a662 2
			geti(x);
			geti(y);
d667 2
a668 2
			geti(x);
			geti(y);
d673 4
a676 4
			geti(x1);
			geti(y1);
			geti(x2);
			geti(y2);
d682 3
a684 3
			geti(x);
			geti(y);
			geti(r);
d689 6
a694 6
			geti(x);
			geti(y);
			geti(x1);
			geti(y1);
			geti(x2);
			geti(y2);
d699 6
a704 6
			geti(x1);
			geti(y1);
			geti(z1);
			geti(x2);
			geti(y2);
			geti(z2);
d709 3
a711 3
			geti(x);
			geti(y);
			geti(z);
d716 3
a718 3
			geti(x);
			geti(y);
			geti(z);
d723 3
a725 3
			geti(x);
			geti(y);
			geti(z);
d730 6
a735 6
			geti(x1);
			geti(y1);
			geti(z1);
			geti(x2);
			geti(y2);
			geti(z2);
d741 3
a743 3
			r = getb();
			g = getb();
			b = getb();
d751 1
a751 1
			getieee( d, 4 );
d756 1
a756 1
			getieee( d, 6 );
d761 1
a761 1
			getieee( d, 2 );
d766 1
a766 1
			getieee( d, 3 );
d771 1
a771 1
			getieee( d, 2 );
d776 1
a776 1
			getieee( d, 3 );
d781 1
a781 1
			getieee( d, 2 );
d786 1
a786 1
			getieee( d, 3 );
d790 1
a790 1
			getieee( d, 4 );
d796 1
a796 1
			getieee( d, 6 );
d802 1
a802 1
			getieee( d, 6 );
d806 1
a806 1
			getieee( d, 3 );
d817 2
a818 9
eat_string()
{
	int	c;

	while( (c = getchar()) != '\n' && c != EOF )
		;
}

get_string( s )
d823 1
a823 1
	while( (c = getchar()) != '\n' && c != EOF )
d828 2
a829 1
getieee( out, n )
d834 1
a834 1
	fread( in, 8, n, stdin );
@


7.13
log
@working matrix code (finally!)
the 3030 colormap code needs work still
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: pl-sgi.c,v 7.12 88/07/21 04:23:20 phil Locked $ (BRL)";
d43 2
d48 1
d77 2
d113 13
a125 2
		ortho( -viewsize, viewsize, -viewsize, viewsize,
			-HUGE, HUGE );
d131 3
a133 3
		/* Try to make up for the rectangular display surface */
		ortho( -1.33*viewsize, 1.33*viewsize, -viewsize, viewsize,
			-HUGE, HUGE );
d154 1
a154 1
	menu = defpup( "Center|Axis|Exit" );
d190 7
d295 1
a295 1
			if( menuval == 3 )
a360 2
		event = 0;
		qreset();
d364 3
a366 2
		getmatrix( rot );
		newview( m, rot, tran, scal, viewmat );
d368 2
a369 10
		/* draw the object */
		cursoff();
		color(BLACK);
		clear();
		if( axis )
			draw_axis();
		for( o = minobj; o < maxobj; o++ )
			callobj( o );
		curson();
		swapbuffers();
d371 13
a383 1
		/* What was this select() ?? */
d419 4
a422 1
		prefposition( WIN_L, WIN_R, WIN_B, WIN_T );
d499 4
d781 1
d829 6
d843 1
d846 1
a846 2
	case 1:
		/* position */
d856 1
a856 2
	case 2:
		/* axis */
d862 18
a879 2
	case 3:
		/* quit */
@


7.12
log
@checkpoint: added center command - matrix operations need to be fixed
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: pl-sgi.c,v 7.11 88/02/25 05:24:37 phil Locked $ (BRL)";
d175 1
a175 2
float	tran[3];	/* x, y, z screen space translate */
float	scal[3];	/* pre-translate scale */
d179 1
a179 1
	Matrix	m, newm;
d185 2
d188 1
d213 2
d343 2
a344 4
#ifdef never
		/* combine new rot/trans with old */
		multmatrix( m );
		getmatrix( m );
a345 8
		/* set up total viewing transformation */
		loadmatrix( viewmat );
		multmatrix( m );
#else
		getmatrix( newm );
		newview( m, newm, viewmat, tran, scal );
#endif

d347 1
d354 1
d417 1
d430 5
a434 6
		for( i = 0; i < map_size-MAP_RESERVED; i++ ) {
			mapcolor( 	i+MAP_RESERVED,
					(short)((i % 10) + 1) * 25,
					(short)(((i / 10) % 10) + 1) * 25,
					(short)((i / 100) + 1) * 25
					);
d451 3
d485 2
d778 2
a779 2
newview( rotmat, rotdelta, viewmat, tran, scal )
Matrix	rotmat, rotdelta, viewmat;
d783 2
a784 2
	 * combine new rots with old
	 *  rotmat = rotmat * rotdela
d786 5
a790 3
	loadmatrix( rotdelta );
	multmatrix( rotmat );
	getmatrix( rotmat );
d794 1
a794 11
	/*
	 * mult m here rotates about view but translates along those
	 * rotated model axis.
	 */
	translate( tran[0], tran[1], tran[2] );
	scale( scal[0], scal[1], scal[2] );
	/*
	 * mult m here translates along view but rotates about about the
	 * translated axis.
	 */
	multmatrix( m );
@


7.11
log
@2D space command zscale
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: pl-sgi.c,v 7.10 88/02/20 07:13:17 phil Locked $ (BRL)";
d138 1
a138 1
	menu = defpup( "Axis|Exit" );
d174 4
a185 2
	float	tran[3];	/* x, y, z screen space translate */
	float	scal[3];	/* pre-translate scale */
d268 1
a268 1
			if( menuval == 2 )
a460 1
	tie(MIDDLEMOUSE, MOUSEX, MOUSEY);
d777 2
a778 2
newview( m, newm, viewmat, tran, scal )
Matrix	m, newm, viewmat;
d781 7
a787 3
	/* combine new rot/trans with old */
	multmatrix( m );
	getmatrix( m );
d791 4
a794 1
	/* mult m here rotates about view but translates along model */
d797 4
a800 1
	/* mult m here translates along view but rotates about model */
d807 4
d813 12
d830 2
a831 1
	case 2:
@


7.10
log
@added standard view buttons
fixed z axis reversal
crude beginnings of menu support
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: pl-sgi.c,v 7.8 88/02/11 04:36:02 phil Locked $ (BRL)";
d550 1
a550 1
			min[2] = -32768.0; max[2] = 32768.0;
@


7.9
log
@default drawing color of white on all new objects
larger window size on ifdef mips
2d floating window now has smaller z size (so autoscale works)
@
text
@d38 1
d45 1
d125 6
d132 1
a132 1
	ortho( -1.0, 1.0, -1.0, 1.0, -1.0, 1.0 );	/* ident on stack XXX */
d137 3
d141 1
d144 1
d161 13
d176 8
a183 6
	Matrix          m, ident;
	Device          event;
	short           val;
	int             end_it = 0;
	int 		o = 1;
	float		fval;
d188 2
a190 6
	/* Make an identity matrix */
	ident[0][0] = ident[1][1] = ident[2][2] = ident[3][3] = 1.0;
	ident[1][0] = ident[1][2] = ident[1][3] = 0.0;
	ident[2][0] = ident[0][1] = ident[2][3] = 0.0;
	ident[3][0] = ident[3][1] = ident[3][2] = 0.0;

d192 1
a192 1
	cursoff();
d208 1
a208 1
		loadmatrix ( ident );
d218 1
a218 1
			rotate( (Angle) -fval, 'y' );
d223 1
a223 1
			rotate( (Angle) -fval, 'z' );
d228 2
a229 1
			translate( fval, 0.0, 0.0 );
d234 2
a235 1
			translate( 0.0, fval, 0.0 );
d240 2
a241 1
			translate( 0.0, 0.0, fval );
d245 5
a249 2
			fval = 1.0 + fval / 500.0;
			scale( fval, fval, fval );
d256 4
a259 1
			scale( fval, fval, fval );
d261 2
a262 1
		case MIDDLEMOUSE:
d265 5
a269 1
			end_it = 1;
d271 2
a272 1
		case RIGHTMOUSE:
d276 4
a279 1
			scale( fval, fval, fval );
d281 1
a281 1
		case SW0:
d286 1
a286 1
		case SW1:
d291 1
a291 1
		case SW2:
d297 1
a297 1
			loadmatrix( ident );
d299 32
d337 1
d345 4
a393 1

d455 1
d459 1
d461 3
a463 3
	qdevice( SW0 );
	qdevice( SW1 );
	qdevice( SW2 );
d465 1
d484 2
d742 68
a809 1
draw_axis() {
@


7.8
log
@Minor hack to get things to compile.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: pl-sgi.c,v 7.6 88/02/05 06:47:42 phil Locked $ (BRL)";
d296 7
a303 1
#define WINDIM	768
d305 1
a305 2
#define WIN_L	(1024-WINDIM-MARGIN)
#define WIN_R	(1024-1-MARGIN)
a435 7
#ifdef never	/* what's the point? */
			l = getcolor();
			color( BLACK );
			clear();
			color( l );
#endif
			/*XXX*/
d442 5
d567 2
a568 2
			min[0] = d[0]; min[1] = d[1]; min[2] = -32768.0;
			max[0] = d[2]; max[1] = d[3]; max[2] = 32768.0;
@


7.7
log
@Intermediate form, trying to add "flush" capability.
@
text
@d280 2
a281 1
		if( !feof(stdin) && select() ) {
d418 2
@


7.6
log
@fixed colormap use under 4d mex
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: pl-sgi.c,v 7.5 88/01/30 01:17:43 phil Exp $ (BRL)";
d42 2
d89 1
a89 1
	makeobj( 1 );
d96 1
a96 1
	closeobj( 1 );
d154 1
a154 1
	int 		obj_num = 1;
d167 1
a167 1
/*	depthcue(1);*/
d276 2
a277 1
		callobj(obj_num);
d279 7
d428 1
d433 8
d442 3
@


7.5
log
@changed name from tiris to pl-sgi
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: pl-sgi.c,v 7.4 88/01/29 22:11:10 phil Locked $ (BRL)";
d43 13
d88 5
a92 1
	color( 3000 );
a145 13
#define MARGIN	4			/* # pixels margin to screen edge */
#define WINDIM	768
#define BANNER	20
#define WIN_L	(1024-WINDIM-MARGIN)
#define WIN_R	(1024-1-MARGIN)
#define WIN_B	MARGIN
#define WIN_T	(WINDIM-BANNER-MARGIN)

#define MAP_RESERVED	16		/* # slots reserved by MEX */
#define MAP_TOL		15		/* pixel delta across all channels */

static int map_size;			/* # of color map slots available */

d284 9
d297 1
d299 2
a300 2
	if( ismex() )
		{
d303 1
a303 2
		if( winopen( "UNIX plot display" ) == -1 )
			{
d306 1
a306 1
			}
d317 3
d322 4
a325 1
	
d337 1
a337 1
		for( i = 0; i < map_size-MAP_RESERVED; i++ )
d344 2
a345 2
	else
		{
d359 1
a359 1
		}
d392 1
a392 8
 */

/* Map RGB onto 10x10x10 color cube, giving index in range 0..999 */
#define MAP_RESERVED	16		/* # slots reserved by MEX */
#define COLOR_APPROX(r,g,b)	\
	((r/26)+ (g/26)*10 + (b/26)*100 + MAP_RESERVED)

/*
@


7.4
log
@added new IEEE floating point functions
@
text
@d2 1
a2 1
 *			T I R I S . C
d21 1
a21 1
static char RCSid[] = "@@(#)$Header: tiris.c,v 7.3 88/01/22 23:41:37 phil Exp $ (BRL)";
d44 1
a44 1
Usage: tiris [-a] < unixplot\n";
d112 1
a112 1
	printf( "tiris: this is an SGI Iris specific program\n" );
d586 1
a586 1
			fprintf( stderr, "tiris: bad command '%c' (0x%02x)\n", c, c );
@


7.3
log
@removed ortho z clipping, added optional coordinate axis
made left and right mouse be zoom out and in
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: tiris.c,v 7.2 88/01/19 23:45:57 phil Exp $ (BRL)";
d393 7
d401 1
d404 1
d411 18
d433 1
d439 1
d445 1
a446 3
		case 'c':
			/* CIRCLE! XXX */
			break;
d454 1
d456 6
a461 8
		case 's':
			geti(x1);
			geti(y1);
			geti(x2);
			geti(y2);
			min[0] = x1; min[1] = y1;
			max[0] = x2; max[1] = y2;
			min[2] = -32768.0; max[2] = 32768.0;
d472 10
a481 3
		case 'f':
		case 't':
			eat_string();
d483 7
d495 1
d502 1
a503 6
		case 'P':
			geti(x);
			geti(y);
			geti(z);
			pnti( x, y, z );
			break;
d513 1
a514 10
		case 'S':
			geti(x1);
			geti(y1);
			geti(z1);
			geti(x2);
			geti(y2);
			geti(z2);
			min[0] = x1; min[1] = y1; min[2] = z1;
			max[0] = x2; max[1] = y2; max[2] = z2;
			break;
d524 61
d586 1
a586 1
			fprintf( stderr, "uplot: unrecognized command '%c'\n", c );
d598 19
@


7.2
log
@Fixed 2D space command.  Added default space values.
Added perspective projection option.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: tiris.c,v 5.1 87/06/24 22:44:14 mike Rel $ (BRL)";
d30 2
d40 5
d47 3
a49 1
main()
d54 9
d64 1
a64 1
		fprintf( stderr, "Usage: tiris < unixplot\n" );
d88 1
a88 1
			-32768.0, 32768.0 );
d96 1
a96 1
			-32768.0, 32768.0 );
d164 8
a171 1
	while (1) {
d174 2
a175 2
		if (qtest())
			event = qread(&val);
d217 4
a220 4
		case SW3:
			loadmatrix( centermat );
			getmatrix( m );
			loadmatrix( ident );
d223 2
d227 6
d234 2
d239 2
d243 8
d268 2
d344 1
d510 17
@


7.1
log
@Release 2.3
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: tiris.c,v 6.1 87/07/11 08:13:15 mike Rel $ (BRL)";
d33 3
a35 1
Matrix	viewmat;	/* viewing projection */
d50 4
d71 4
d79 4
d84 1
a84 1
	getmatrix( viewmat );
d192 1
d201 1
a201 1
			obj_num = 1;
d204 1
a204 1
			obj_num = 2;
a205 3
		case SW2:
			obj_num = 3;
			break;
d385 3
a387 1
			ortho( (Coord)x1, (Coord)x2, (Coord)y1, (Coord)y2, -100.0, 100.0 );
@


6.1
log
@Release 2.0
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: tiris.c,v 5.1 87/06/24 22:44:14 mike Rel $ (BRL)";
@


5.1
log
@Release 1.24
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: tiris.c,v 1.2 87/06/19 23:45:12 phil Exp $ (BRL)";
@


1.2
log
@Invoked the #include hack of adding a SPACE after the # to keep make depend happy.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: tiris.c,v 1.1 87/06/19 23:40:25 phil Locked $ (BRL)";
@


1.1
log
@Initial revision
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d25 1
d27 2
a28 2
#include "gl.h"
#include "device.h"
@
