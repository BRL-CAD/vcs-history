head	11.11;
access;
symbols
	ansi-20040405-merged:11.7.2.2
	postmerge-20040405-ansi:11.9
	premerge-20040404-ansi:11.8
	postmerge-autoconf:11.8
	autoconf-freeze:11.7.10.2
	premerge-autoconf:11.8
	postmerge-20040315-windows:11.8
	premerge-20040315-windows:11.8
	windows-20040315-freeze:11.7.4.1
	autoconf-20031203:11.7
	autoconf-20031202:11.7
	autoconf-branch:11.7.0.10
	phong-branch:11.7.0.8
	photonmap-branch:11.7.0.6
	rel-6-1-DP:11.7
	windows-branch:11.7.0.4
	rel-6-0-2:11.5
	ansi-branch:11.7.0.2
	rel-6-0-1-branch:11.5.0.2
	hartley-6-0-post:11.6
	hartley-6-0-pre:11.5
	rel-6-0-1:11.5
	rel-6-0:11.5
	rel-5-4:11.2
	offsite-5-3-pre:11.4
	rel-5-3:11.2
	rel-5-2:11.2
	rel-5-1-branch:11.2.0.2
	rel-5-1:11.2
	rel-5-0:11.1
	rel-5-0-beta:11.1
	rel-4-5:11.1
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:5.1
	rel-1-24:5.1
	rel-1-20:4.2
	rel-1-10:4.1;
locks; strict;
comment	@ * @;


11.11
date	2004.05.21.14.57.57;	author morrison;	state dead;
branches;
next	11.10;

11.10
date	2004.05.10.15.30.51;	author erikg;	state Exp;
branches;
next	11.9;

11.9
date	2004.04.05.05.46.02;	author morrison;	state Exp;
branches;
next	11.8;

11.8
date	2004.02.02.17.39.50;	author morrison;	state Exp;
branches;
next	11.7;

11.7
date	2002.08.20.17.09.04;	author jra;	state Exp;
branches
	11.7.2.1
	11.7.4.1
	11.7.10.1;
next	11.6;

11.6
date	2002.08.15.20.56.16;	author hartley;	state Exp;
branches;
next	11.5;

11.5
date	2001.08.10.20.57.08;	author butler;	state Exp;
branches;
next	11.4;

11.4
date	2000.09.01.03.24.00;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	2000.08.23.19.04.58;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	2000.01.31.16.03.09;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.13.04;	author mike;	state Rel4_4;
branches;
next	10.3;

10.3
date	94.08.23.15.06.04;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	94.01.14.21.47.50;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.48.58;	author mike;	state Rel4_0;
branches;
next	9.1;

9.1
date	89.05.19.06.10.55;	author mike;	state Rel3_5;
branches;
next	8.1;

8.1
date	88.10.05.00.43.20;	author mike;	state Rel3_0;
branches;
next	7.2;

7.2
date	88.06.22.05.01.18;	author phil;	state Exp;
branches;
next	7.1;

7.1
date	87.11.03.00.09.15;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.08.12.39;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.43.31;	author mike;	state Rel;
branches;
next	4.2;

4.2
date	87.02.13.00.46.14;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.13.57;	author mike;	state Rel1;
branches;
next	1.7;

1.7
date	86.11.25.22.03.28;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	86.11.25.18.46.05;	author kermit;	state Exp;
branches;
next	1.5;

1.5
date	86.11.24.20.16.12;	author kermit;	state Exp;
branches;
next	1.4;

1.4
date	86.11.24.19.47.59;	author kermit;	state Exp;
branches;
next	1.3;

1.3
date	86.08.13.04.42.29;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	86.04.16.21.57.02;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	85.09.18.06.46.08;	author mike;	state Exp;
branches;
next	;

11.7.2.1
date	2002.09.19.18.02.43;	author morrison;	state Exp;
branches;
next	11.7.2.2;

11.7.2.2
date	2004.03.17.21.23.33;	author morrison;	state Exp;
branches;
next	;

11.7.4.1
date	2004.03.11.23.52.34;	author morrison;	state Exp;
branches;
next	;

11.7.10.1
date	2004.02.12.19.43.11;	author erikg;	state Exp;
branches;
next	11.7.10.2;

11.7.10.2
date	2004.03.15.14.08.19;	author erikg;	state Exp;
branches;
next	;


desc
@Program to slurp several .pix files into one image,
suitable for viewport animation.
@


11.11
log
@moved to src/util/
@
text
@/*
 *  			P I X T I L E . C
 *  
 *  Given multiple .pix files with ordinary lines of pixels,
 *  produce a single image with each image side-by-side,
 *  right to left, bottom to top on STDOUT.
 *
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1986-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/util/pixtile.c,v 11.10 2004/05/10 15:30:51 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"			/* For bzero */
#include "externs.h"			/* For getopt and malloc */

int file_width = 64;	/* width of input sub-images in pixels (64) */
int file_height = 64;	/* height of input sub-images in scanlines (64) */
int scr_width = 512;	/* number of output pixels/line (512, 1024) */
int scr_height = 512;	/* number of output lines (512, 1024) */
char *basename;		/* basename of input file(s) */
int framenumber = 0;	/* starting frame number (default is 0) */

char usage[] = "\
Usage: pixtile [-h] [-s squareinsize] [-w file_width] [-n file_height]\n\
	[-S squareoutsize] [-W out_width] [-N out_height]\n\
	[-o startframe] basename [file2 ... fileN] >file.pix\n";

/*
 *			M R E A D
 *
 * This function performs the function of a read(II) but will
 * call read(II) multiple times in order to get the requested
 * number of characters.  This can be necessary because pipes
 * and network connections don't deliver data with the same
 * grouping as it is written with.  Written by Robert S. Miles, BRL.
 */
int
mread(int fd, register char *bufp, int n)
{
	register int	count = 0;
	register int	nread;

	do {
		nread = read(fd, bufp, (unsigned)n-count);
		if(nread < 0)  {
			perror("buffer: mread");
			return(-1);
		}
		if(nread == 0)
			return((int)count);
		count += (unsigned)nread;
		bufp += nread;
	 } while(count < n);

	return((int)count);
}

/*
 *			G E T _ A R G S
 */
int
get_args(int argc, register char **argv)
{
	register int c;

	while ( (c = getopt( argc, argv, "hs:w:n:S:W:N:o:" )) != EOF )  {
		switch( c )  {
		case 'h':
			/* high-res */
			scr_height = scr_width = 1024;
			break;
		case 's':
			/* square input file size */
			file_height = file_width = atoi(optarg);
			break;
		case 'w':
			file_width = atoi(optarg);
			break;
		case 'n':
			file_height = atoi(optarg);
			break;
		case 'S':
			scr_height = scr_width = atoi(optarg);
			break;
		case 'W':
			scr_width = atoi(optarg);
			break;
		case 'N':
			scr_height = atoi(optarg);
			break;
		case 'o':
			framenumber = atoi(optarg);
			break;
		default:		/* '?' */
			return(0);	/* Bad */
		}
	}

	if( isatty(fileno(stdout)) )  {
		return(0);	/* Bad */
	}

	if( optind >= argc )  {
		fprintf(stderr, "pixtile: basename or filename(s) missing\n");
		return(0);	/* Bad */
	}

	return(1);		/* OK */
}

int
main(int argc, char **argv)
{
	register int i;
	char *obuf;
	int im_line;		/* number of images across output scanline */
	int im_high;		/* number of images (swaths) high */
	int scanbytes;		/* bytes per input line */
	int swathbytes;		/* bytes per swath of images */
	int image;		/* current sub-image number */
	int rel = 0;		/* Relative image # within swath */
	int maximage;		/* Maximum # of images that will fit */
	int islist = 0;		/* set if a list, zero if basename */
	int is_stream = 0;	/* set if input is stream on stdin */
	char name[256];

	if( !get_args( argc, argv ) )  {
		(void)fputs(usage, stderr);
		exit( 1);
	}

	if( optind+1 == argc )  {
		basename = argv[optind];
		islist = 0;
		if( basename[0] == '-' && basename[1] == '\0' )
			is_stream = 1;
	} else {
		islist = 1;
	}

	if( file_width < 1 ) {
		fprintf(stderr,"pixtile: width of %d out of range\n", file_width);
		exit(12);
	}

	scanbytes = file_width * 3;

	/* number of images across line */
	im_line = scr_width/file_width;

	/* number of images high */
	im_high = scr_height/file_height;

	/* One swath of images */
	swathbytes = scr_width * file_height * 3;

	maximage = im_line * im_high;

	if( (obuf = (char *)malloc( swathbytes )) == (char *)0 )  {
		(void)fprintf(stderr,"pixtile:  malloc %d failure\n", swathbytes );
		exit(10);
	}

	image = 0;
	while( image < maximage )  {
		bzero( obuf, swathbytes );
		/*
		 * Collect together one swath
		 */
		for( rel = 0; rel<im_line; rel++, image++, framenumber++ )  {
			int fd;

			if(image >= maximage )  {
				fprintf(stderr,"\npixtile: frame full\n");
				/* All swaths already written out */
				exit(0);
			}
			fprintf(stderr,"%d ", framenumber);  fflush(stdout);
			if( is_stream )  {
				fd = 0;		/* stdin */
			} else {
				if( islist )  {
					/* See if we read all the files */
					if( optind >= argc )
						goto done;
					strcpy(name, argv[optind++]);
				} else {
					sprintf(name,"%s.%d", basename, framenumber);
				}
				if( (fd=open(name,0))<0 )  {
					perror(name);
					goto done;
				}
			}
			/* Read in .pix file.  Bottom to top */
			for( i=0; i<file_height; i++ )  {
				register int j;

				/* virtual image l/r offset */
				j = (rel*file_width);

				/* select proper scanline within image */
				j += i*scr_width;

				if( mread( fd, &obuf[j*3], scanbytes ) != scanbytes )
					break;
			}
			if( fd > 0 )  close(fd);
		}
		(void)write( 1, obuf, swathbytes );
		rel = 0;	/* in case we fall through */
	}
done:
	/* Flush partial frame? */
	if( rel != 0 )
		(void)write( 1, obuf, swathbytes );
	fprintf(stderr,"\n");
	exit(0);
}

@


11.10
log
@change conf.h to a wrapped config.h
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/util/pixtile.c,v 11.9 2004/04/05 05:46:02 morrison Exp $ (BRL)";
@


11.9
log
@merge of ansi-6-0-branch into head
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d24 5
a28 1
#include "conf.h"
@


11.8
log
@update copyright to include span through 2003
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/pixtile.c,v 11.7 2002/08/20 17:09:04 jra Exp $ (BRL)";
d58 1
a58 4
mread(fd, bufp, n)
int	fd;
register char	*bufp;
int	n;
d82 1
a82 2
get_args( argc, argv )
register char **argv;
d132 1
a132 2
main( argc, argv )
char **argv;
@


11.7
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1986 by the United States Army.
d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/pixtile.c,v 11.5 2001/08/10 20:57:08 butler Exp $ (BRL)";
@


11.7.4.1
log
@sync to HEAD...
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/util/pixtile.c,v 11.8 2004/02/02 17:39:50 morrison Exp $ (BRL)";
@


11.7.10.1
log
@merge from HEAD
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/pixtile.c,v 11.8 2004/02/02 17:39:50 morrison Exp $ (BRL)";
@


11.7.10.2
log
@merge from head
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/pixtile.c,v 11.7.10.1 2004/02/12 19:43:11 erikg Exp $ (BRL)";
@


11.7.2.1
log
@Initial ANSIfication
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/pixtile.c,v 11.7 2002/08/20 17:09:04 jra Exp $ (BRL)";
d58 4
a61 1
mread(int fd, register char *bufp, int n)
d85 2
a86 1
get_args(int argc, register char **argv)
d136 2
a137 1
main(int argc, char **argv)
@


11.7.2.2
log
@sync branch with HEAD
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d21 1
a21 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.6
log
@Converted from K&R to ANSI C - RFH
@
text
@d58 4
a61 1
mread(int fd, register char *bufp, int n)
d85 2
a86 1
get_args(int argc, register char **argv)
d136 2
a137 1
main(int argc, char **argv)
@


11.5
log
@Misc compiler warnings eliminated
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/pixtile.c,v 11.4 2000/09/01 03:24:00 mike Exp $ (BRL)";
d58 1
a58 4
mread(fd, bufp, n)
int	fd;
register char	*bufp;
int	n;
d82 1
a82 2
get_args( argc, argv )
register char **argv;
d132 1
a132 2
main( argc, argv )
char **argv;
@


11.4
log
@
Lint fix
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/pixtile.c,v 11.3 2000/08/23 19:04:58 mike Exp $ (BRL)";
d27 5
d84 1
@


11.3
log
@
const RCSid
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/pixtile.c,v 11.2 2000/01/31 16:03:09 jra Exp $ (BRL)";
d129 1
@


11.2
log
@Eliminated some unused variables
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/pixtile.c,v 11.1 1995/01/04 10:13:04 mike Rel4_4 $ (BRL)";
@


11.1
log
@Release_4.4
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/pixtile.c,v 10.3 94/08/23 15:06:04 gdurf Exp $ (BRL)";
a188 1
			register char *out;
@


10.3
log
@Factored ifdefs
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/pixtile.c,v 10.2 1994/01/14 21:47:50 mike Exp gdurf $ (BRL)";
@


10.2
log
@Added ability to read image stream from stdin.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/pixtile.c,v 10.1 91/10/12 06:48:58 mike Rel4_0 Locker: mike $ (BRL)";
d24 2
d28 2
a29 9
#ifdef SYSV
#define bzero(p,cnt)	memset(p,'\0',cnt);
#endif

extern int	getopt();
extern char	*optarg;
extern int	optind;

extern char	*malloc();
@


10.1
log
@Release_4.0
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/pixtile.c,v 9.1 89/05/19 06:10:55 mike Rel3_5 $ (BRL)";
d48 36
d147 1
d158 2
d203 13
a215 3
			if( islist )  {
				/*See if we read all the files */
				if( optind >= argc )
d217 1
a217 3
				strcpy(name, argv[optind++]);
			} else {
				sprintf(name,"%s.%d", basename, framenumber);
a218 4
			if( (fd=open(name,0))<0 )  {
				perror(name);
				goto done;
			}
d229 1
a229 1
				if( read( fd, &obuf[j*3], scanbytes ) != scanbytes )
d232 1
a232 1
			close(fd);
d244 1
@


9.1
log
@Release_3.5
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: pixtile.c,v 8.1 88/10/05 00:43:20 mike Rel3_0 $ (BRL)";
@


8.1
log
@Release_3.0
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: pixtile.c,v 7.2 88/06/22 05:01:18 phil Exp $ (BRL)";
@


7.2
log
@fixed condition where an extra last row of frames could be written.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: pixtile.c,v 7.1 87/11/03 00:09:15 phil Locked $ (BRL)";
@


7.1
log
@Release 2.3
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: pixtile.c,v 6.1 87/07/11 08:12:39 mike Rel $ (BRL)";
d192 1
@


6.1
log
@Release 2.0
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: pixtile.c,v 5.1 87/06/24 22:43:31 mike Rel $ (BRL)";
@


5.1
log
@Release 1.24
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: pixtile.c,v 4.2 87/02/13 00:46:14 mike Exp $ (BRL)";
@


4.2
log
@Release 1.20 -- First Formal Release
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: pixtile.c,v 4.1 86/12/29 03:13:57 mike Rel1 $ (BRL)";
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: pixtile.c,v 1.7 86/11/25 22:03:28 mike Exp $ (BRL)";
@


1.7
log
@Improved handling of boundary conditions.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: pixtile.c,v 1.6 86/11/25 18:46:05 mike Locked $ (BRL)";
@


1.6
log
@Added several options including the
ability to use a list of files, as
well as use non-square files for
input and output.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: pixtile.c,v 1.5 86/11/24 20:16:12 kermit Locked $ (BRL)";
d57 1
a57 1
			scr_width = 1024;
d104 1
d108 1
a108 1
	int rel;		/* Relative image # within swath */
d111 1
a111 1
	char name[128];
d135 3
d141 1
a141 1
	maximage = im_line * (scr_height/file_height);
d158 1
a158 2
			fprintf(stderr,"%d ", framenumber);  fflush(stdout);
			if(image >= im_line*im_line )  {
d163 1
a163 1
			/* XXX */
d166 1
a166 1
				if( optind == argc )
a192 1
	/* NOTREACHED */
d194 4
a197 1
	(void)write( 1, obuf, swathbytes );
@


1.5
log
@This version goes bottom-to-top,
does dynamic allocation of swath buffer,
writes buffer after each swath to save memory
(also makes for better watching).
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: pixtile.c,v 1.5 86/11/24 20:06:34 kermit Locked $ (BRL)";
d26 3
a28 1
extern char *malloc();
d30 3
a32 5
int pix_line;		/* number of pixels/line (512, 1024) */
int scanbytes;		/* bytes per input line */
int w;			/* width of sub-images in pixels */
int im_line;		/* number of images across output scanline */
int image;		/* current sub-image number */
d34 1
a34 1
char usage[] = "Usage: pixtile [-h] basename width [startframe] >file.pix\n";
d36 62
d103 4
a106 3
	char *basename;
	int framenumber;
	int swathbytes;
d108 2
d112 3
a114 3
	if( argc < 2 || isatty(fileno(stdout)) )  {
		fprintf(stderr, "%s", usage);
		exit(12);
d117 6
a122 5
	if( strcmp( argv[1], "-h" ) == 0 )  {
		argc--; argv++;
		pix_line = 1024;
	}  else
		pix_line = 512;
d124 2
a125 4
	basename = argv[1];
	w = atoi( argv[2] );
	if( w < 1 ) {
		fprintf(stderr,"pixtile: width of %d out of range\n", w);
a127 3
	if( argc == 4 )
		framenumber = atoi(argv[3]);
	else	framenumber = 0;
d129 10
a138 3
	scanbytes = w * 3;
	im_line = pix_line/w;	/* number of images across line */
	swathbytes = pix_line * w * 3;	/* One swath of images */
d140 1
a140 1
		fprintf(stderr,"pixtile:  malloc %d failure\n", swathbytes );
d143 1
d145 2
a146 1
	while( 1 )  {
d160 9
a168 1
			sprintf(name,"%s.%d", basename, framenumber);
d174 1
a174 1
			for( i=0; i<w; i++ )  {
d178 1
a178 1
				j = (rel*w);
d181 1
a181 1
				j += i*pix_line;
@


1.4
log
@Added standard header.  This version places first image in
upper left corner.
@
text
@d6 1
a6 1
 *  right to left, top to bottom on STDOUT.
d21 1
a21 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d26 1
a26 1
char ibuf[512*3];		/* Input line */
a27 2
char obuf[3*1024*1024];		/* Output screen */

d40 1
d43 2
d60 2
a61 2
	if( w < 4 || w > 512 ) {
		printf("width of %d out of range\n", w);
d70 13
a82 3
	for( image=0; ; image++, framenumber++ )  {
		register char *out;
		int fd;
d84 14
a97 13
		fprintf(stderr,"%d ", framenumber);  fflush(stdout);
		if(image >= im_line*im_line )  {
			fprintf(stderr,"full\n");
			break;
		}
		sprintf(name,"%s.%d", basename, framenumber);
		if( (fd=open(name,0))<0 )  {
			perror(name);
			goto done;
		}
		/* Read in .pix file.  Bottom to top */
		for( i=0; i<w; i++ )  {
			register int j;
d99 2
a100 7
			/* Vertical position, recalling bottom-to-top */
			/* virtual image starting line*/
			/* First image goes in upper left corner of output,
			 * which is last part of output buffer. */
			/*   maxscanline     back up # of images */
			j = (pix_line) - (((image/im_line)+1)*w);
			j = j * pix_line;
d102 2
a103 2
			/* virtual image l/r offset */
			j += ((image%im_line)*w);
d105 4
a108 5
			/* select proper scanline within image */
			j += i*pix_line;

			if( read( fd, &obuf[j*3], scanbytes ) != scanbytes )
				break;
d110 1
a110 1
		close(fd);
d112 1
d114 2
a115 1
	(void)write( 1, obuf, pix_line*pix_line*3 );
@


1.3
log
@Cleanup for distribution
@
text
@d7 12
d20 4
d89 1
a89 1
			/* First image goes in upper right corner of output,
@


1.2
log
@Enlarged width to 512.  Useful for looking at pixdiff output.
@
text
@d2 1
a2 1
 *  			S L U R P . C
d6 1
a6 1
 *  right to left, top to bottom.
a9 2
#include "/vld/include/fb.h"

d12 1
a12 1
struct pixel obuf[1024*1024];		/* Output screen */
d20 2
d30 2
a31 2
	if( argc < 2 )  {
		printf("Usage: nslurp [-h] basename width [startframe]\n");
a50 5
	if( pix_line > 512 )
		fbsetsize(pix_line);
	if( fbopen( NULL, CREATE ) < 0 )
		exit(12);

d54 1
a54 3
		register char *in;
		register struct pixel *out;
		register int j;
d57 1
a57 1
		printf("%d ", framenumber);  fflush(stdout);
d59 1
a59 1
			printf("full\n");
d69 17
a85 10
			in = ibuf;
			out = &obuf[(
				/* virtual image start line*/
				((image/im_line)*w*pix_line) +
				/* virtual image l/r offset */
				((image%im_line)*w) +
				/* scanline */
				((w-i-1)*pix_line)
			)];
			if( read( fd, ibuf, scanbytes ) != scanbytes )
a86 6
			for( j=0; j<w; j++ )  {
				out->red = *in++;
				out->green = *in++;
				out->blue = *in++;
				(out++)->spare = 0;
			}
d91 1
a91 8
	printf("done\n");
	doit();
}

doit()
{

	fbwrite( 0, 0, obuf, pix_line*pix_line );
@


1.1
log
@Initial revision
@
text
@d10 1
a10 2
extern int ikhires;
extern int ikfd;
a12 1
char obuf[1024*1024*4];		/* Output screen */
d14 2
a36 1
		ikhires = 1;
d43 1
a43 1
	if( w < 4 || w > 256 ) {
d51 4
a54 3
	ikopen();
	load_map(1);		/* Standard map: linear */
	ikclear();
d59 2
a60 1
		register char *in, *out;
d77 1
a77 1
			out = &obuf[4*(
d88 4
a91 4
				*out++ = *in++;
				*out++ = *in++;
				*out++ = *in++;
				*out++ = 0;
a102 1
	register int i;
d104 1
a104 3
	(void)lseek(ikfd, 0L, 0);
	for( i=0; i < pix_line; i+=8 )
		write(ikfd, &obuf[i*pix_line*4], 8*pix_line*4 );
@
