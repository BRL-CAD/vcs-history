head	11.13;
access;
symbols
	ansi-20040405-merged:11.9.2.2
	postmerge-20040405-ansi:11.11
	premerge-20040404-ansi:11.10
	postmerge-autoconf:11.10
	autoconf-freeze:11.9.10.2
	premerge-autoconf:11.10
	postmerge-20040315-windows:11.10
	premerge-20040315-windows:11.10
	windows-20040315-freeze:11.9.4.1
	autoconf-20031203:11.9
	autoconf-20031202:11.9
	autoconf-branch:11.9.0.10
	phong-branch:11.9.0.8
	photonmap-branch:11.9.0.6
	rel-6-1-DP:11.9
	windows-branch:11.9.0.4
	rel-6-0-2:11.7
	ansi-branch:11.9.0.2
	rel-6-0-1-branch:11.7.0.2
	hartley-6-0-post:11.8
	hartley-6-0-pre:11.7
	rel-6-0-1:11.7
	rel-6-0:11.7
	rel-5-4:11.4
	offsite-5-3-pre:11.6
	rel-5-3:11.4
	rel-5-2:11.4
	rel-5-1-branch:11.4.0.2
	rel-5-1:11.4
	rel-5-0:11.3
	rel-5-0-beta:11.3;
locks; strict;
comment	@ * @;


11.13
date	2004.05.21.14.57.51;	author morrison;	state dead;
branches;
next	11.12;

11.12
date	2004.05.10.15.30.50;	author erikg;	state Exp;
branches;
next	11.11;

11.11
date	2004.04.05.05.46.02;	author morrison;	state Exp;
branches;
next	11.10;

11.10
date	2004.02.02.17.39.46;	author morrison;	state Exp;
branches;
next	11.9;

11.9
date	2002.08.20.17.09.02;	author jra;	state Exp;
branches
	11.9.2.1
	11.9.4.1
	11.9.10.1;
next	11.8;

11.8
date	2002.08.15.20.56.13;	author hartley;	state Exp;
branches;
next	11.7;

11.7
date	2001.08.10.20.57.07;	author butler;	state Exp;
branches;
next	11.6;

11.6
date	2000.12.19.13.33.44;	author pjt;	state Exp;
branches;
next	11.5;

11.5
date	2000.08.23.19.04.46;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	2000.01.31.16.03.09;	author jra;	state Exp;
branches;
next	11.3;

11.3
date	98.12.30.01.32.15;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	98.11.04.20.19.05;	author pjt;	state Exp;
branches;
next	11.1;

11.1
date	98.11.04.19.50.39;	author pjt;	state Exp;
branches;
next	;

11.9.2.1
date	2002.09.19.18.02.41;	author morrison;	state Exp;
branches;
next	11.9.2.2;

11.9.2.2
date	2004.03.17.21.23.29;	author morrison;	state Exp;
branches;
next	;

11.9.4.1
date	2004.03.11.23.52.32;	author morrison;	state Exp;
branches;
next	;

11.9.10.1
date	2004.02.12.19.43.10;	author erikg;	state Exp;
branches;
next	11.9.10.2;

11.9.10.2
date	2004.03.15.14.08.13;	author erikg;	state Exp;
branches;
next	;


desc
@@


11.13
log
@moved to src/util/
@
text
@/*
 *			P I X C O U N T . C
 *
 *	Sort the pixels of an input stream by color value.
 *
 *  Author -
 *	Paul J. Tanenbaum
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1998-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/util/pixcount.c,v 11.12 2004/05/10 15:30:50 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif


#include <stdio.h>
#include <math.h>
#include "machine.h"
#include "externs.h"		/* For getopt(), etc. */
#include "bu.h"
#include "redblack.h"

struct pixel
{
    long		p_magic;
    unsigned char	*p_color;
    int			p_count;
};
#define	PIXEL_NULL	((struct pixel *) 0)
#define	PIXEL_MAGIC	0x7078656c


/*
 *	Global variables
 */
int		pixel_size = 3;		/* Bytes/pixel */
FILE		*outfp = NULL;		/* output file */

static char usage[] = "\
Usage: 'pixcount [-# bytes_per_pixel]\n\
		 [infile.pix [outfile]]'\n";
#define OPT_STRING	"#:?"

static void print_usage (void)
{
    (void) bu_log("%s", usage);
}

/*
 *			     M K _ P I X E L ( )
 *
 */
struct pixel *mk_pixel (unsigned char *color)
{
    int			i;
    struct pixel	*pp;

    pp = (struct pixel *) bu_malloc(sizeof(struct pixel), "pixel");

    pp -> p_magic = PIXEL_MAGIC;
    pp -> p_color = (unsigned char *)
		bu_malloc(pixel_size * sizeof(unsigned char),
			"pixel color");
    for (i = 0; i < pixel_size; ++i)
	pp -> p_color[i] = color[i];
    pp -> p_count = 0;

    return (pp);
}

/*
 *			   F R E E _ P I X E L ( )
 *
 */
void free_pixel (struct pixel *pp)
{
    BU_CKMAG(pp, PIXEL_MAGIC, "pixel");
    bu_free((genptr_t) pp, "pixel");
}

/*
 *			  P R I N T _ P I X E L ( )
 *
 */
void print_pixel (void *p, int depth)
{
    int			i;
    struct pixel	*pp = (struct pixel *) p;

    BU_CKMAG(pp, PIXEL_MAGIC, "pixel");

    for (i = 0; i < pixel_size; ++i)
	fprintf(outfp, "%3d ", pp -> p_color[i]);
    fprintf(outfp, " %d\n", pp -> p_count);
}

/*
 *		C O M P A R E _ P I X E L S ( )
 *
 *	    The comparison callback for the red-black tree
 */
int compare_pixels (void *v1, void *v2)
{
    struct pixel	*p1 = (struct pixel *) v1;
    struct pixel	*p2 = (struct pixel *) v2;
    int			i;

    BU_CKMAG(p1, PIXEL_MAGIC, "pixel");
    BU_CKMAG(p2, PIXEL_MAGIC, "pixel");

    for (i = 0; i < pixel_size; ++i)
    {
	if (p1 -> p_color[i] < p2 -> p_color[i])
	    return (-1);
	else if (p1 -> p_color[i] > p2 -> p_color[i])
	    return (1);
    }
    return (0);
}

/*
 *			 L O O K U P _ P I X E L ( )
 */
struct pixel *lookup_pixel(bu_rb_tree *palette, char *color)
{
    int			rc;	/* Return code from bu_rb_insert() */
    struct pixel	*qpp;	/* The query */
    struct pixel	*pp;	/* Value to return */

#if 0
    bu_log("lookup_pixel( ");
    for (i = 0; i < pixel_size; ++i)
	bu_log("%3d ", color[i]);
    bu_log(")...");
#endif

    /*
     *	Prepare the palette query
     */
    qpp = mk_pixel(color);

    /*
     *	Perform the query by attempting an insertion...
     *	If the query succeeds (i.e., the insertion fails!),
     *	then we have our pixel.
     *	Otherwise, we must create a new pixel.
     */
    switch (rc = bu_rb_insert(palette, (void *) qpp))
    {
	case -1:
#if 0
	    bu_log(" already existed\n");
#endif
	    pp = (struct pixel *) bu_rb_curr1(palette);
	    free_pixel(qpp);
	    break;
	case 0:
#if 0
	    bu_log(" newly added\n");
#endif
	    pp = qpp;
	    break;
	default:
	    bu_log("bu_rb_insert() returns %d:  This should not happen\n", rc);
	    exit (1);
    }

    return (pp);
}

int
main (int argc, char **argv)
{
    bu_rb_tree		*palette;	/* Pixel palette */
    char		*inf_name;	/* name of input stream */
    char		*outf_name;	/*  "   "  output   "   */
    unsigned char	*buf;		/* the current input pixel */
    FILE		*infp = NULL;	/* input stream */
    int			ch;		/* current char in command line */
    struct pixel	*pp;

    extern int	optind;			/* index from getopt(3C) */
    extern char	*optarg;		/* argument from getopt(3C) */

    /*
     *	Process the command line
     */
    while ((ch = getopt(argc, argv, OPT_STRING)) != EOF)
	switch (ch)
	{
	    case '#':
		if (sscanf(optarg, "%d", &pixel_size) != 1)
		{
		    bu_log("Invalid pixel size: '%s'\n", optarg);
		    print_usage();
		    exit (1);
		}
		break;
	    case '?':
	    default:
		print_usage();
		exit (ch != '?');
	}
    switch (argc - optind)
    {
	case 0:
	    inf_name = "stdin";
	    infp = stdin;
	    /* Break intentionally missing */
	case 1:
	    outf_name = "stdout";
	    outfp = stdout;
	    /* Break intentionally missing */
	case 2:
	    break;
	default:
	    print_usage();
	    exit (1);
    }

    /*
     *	Open input and output files, as necessary
     */
    if (infp == NULL)
    {
	inf_name = argv[optind];
	if ((infp = fopen(inf_name, "r")) == NULL)
	{
	    bu_log ("Cannot open input file '%s'\n", inf_name);
	    exit (1);
	}
	if (outfp == NULL)
	{
	    outf_name = argv[++optind];
	    if ((outfp = fopen(outf_name, "w")) == NULL)
	    {
		bu_log ("Cannot open output file '%s'\n", outf_name);
		exit (1);
	    }
	}
    }

    /*
     *	Ensure that infp is kosher,
     */
    if (infp == stdin)
    {
	if (isatty(fileno(stdin)))
	{
	    bu_log("FATAL: pixcount reads only from file or pipe\n");
	    print_usage();
	    exit (1);
	}
    }

    palette = bu_rb_create1("Pixel palette", compare_pixels);
    bu_rb_uniq_on1(palette);

    /*
     *	Read the input stream into the palette
     */
    buf = (unsigned char *)
		bu_malloc(pixel_size * sizeof(unsigned char),
			"pixel buffer");
    while (fread((void *) buf, pixel_size * sizeof(unsigned char), 1, infp)
	    == 1)
    {
	pp = lookup_pixel(palette, buf);
	BU_CKMAG(pp, PIXEL_MAGIC, "pixel");

	++(pp -> p_count);
    }
    bu_free((genptr_t) buf, "pixel buffer");

    bu_rb_walk1(palette, print_pixel, INORDER);

    return 0;
}
@


11.12
log
@change conf.h to a wrapped config.h
@
text
@d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/util/pixcount.c,v 11.11 2004/04/05 05:46:02 morrison Exp $ (BRL)";
@


11.11
log
@merge of ansi-6-0-branch into head
@
text
@d18 1
a18 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d21 5
a25 1
#include "conf.h"
@


11.10
log
@update copyright to include span through 2003
@
text
@d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/pixcount.c,v 11.9 2002/08/20 17:09:02 jra Exp $ (BRL)";
d50 1
a50 1
static void print_usage ()
d59 1
a59 4
struct pixel *mk_pixel (color)

unsigned char	*color;

d81 1
a81 4
void free_pixel (pp)

struct pixel	*pp;

d91 1
a91 5
void print_pixel (p, depth)

void	*p;
int	depth;

d108 1
a108 5
int compare_pixels (v1, v2)

void	*v1;
void	*v2;

d130 1
a130 5
struct pixel *lookup_pixel(palette, color)

bu_rb_tree	*palette;
char	*color;

d178 1
a178 5
main (argc, argv)

int	argc;
char	*argv[];

@


11.9
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d14 1
a14 1
 *	This software is Copyright (C) 1998 by the United States Army.
d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/pixcount.c,v 11.7 2001/08/10 20:57:07 butler Exp $ (BRL)";
@


11.9.4.1
log
@sync to HEAD...
@
text
@d14 1
a14 1
 *	This software is Copyright (C) 1998-2004 by the United States Army.
d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/util/pixcount.c,v 11.10 2004/02/02 17:39:46 morrison Exp $ (BRL)";
@


11.9.10.1
log
@merge from HEAD
@
text
@d14 1
a14 1
 *	This software is Copyright (C) 1998-2004 by the United States Army.
d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/pixcount.c,v 11.10 2004/02/02 17:39:46 morrison Exp $ (BRL)";
@


11.9.10.2
log
@merge from head
@
text
@d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/pixcount.c,v 11.9.10.1 2004/02/12 19:43:10 erikg Exp $ (BRL)";
@


11.9.2.1
log
@Initial ANSIfication
@
text
@d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/pixcount.c,v 11.9 2002/08/20 17:09:02 jra Exp $ (BRL)";
d50 1
a50 1
static void print_usage (void)
d59 4
a62 1
struct pixel *mk_pixel (unsigned char *color)
d84 4
a87 1
void free_pixel (struct pixel *pp)
d97 5
a101 1
void print_pixel (void *p, int depth)
d118 5
a122 1
int compare_pixels (void *v1, void *v2)
d144 5
a148 1
struct pixel *lookup_pixel(bu_rb_tree *palette, char *color)
d196 5
a200 1
main (int argc, char **argv)
@


11.9.2.2
log
@sync branch with HEAD
@
text
@d14 1
a14 1
 *	This software is Copyright (C) 1998-2004 by the United States Army.
d18 1
a18 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.8
log
@Converted from K&R to ANSI C - RFH
@
text
@d50 1
a50 1
static void print_usage (void)
d59 4
a62 1
struct pixel *mk_pixel (unsigned char *color)
d84 4
a87 1
void free_pixel (struct pixel *pp)
d97 5
a101 1
void print_pixel (void *p, int depth)
d118 5
a122 1
int compare_pixels (void *v1, void *v2)
d144 5
a148 1
struct pixel *lookup_pixel(bu_rb_tree *palette, char *color)
d196 5
a200 1
main (int argc, char **argv)
@


11.7
log
@Misc compiler warnings eliminated
@
text
@d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/pixcount.c,v 11.6 2000/12/19 13:33:44 pjt Exp $ (BRL)";
d50 1
a50 1
static void print_usage ()
d59 1
a59 4
struct pixel *mk_pixel (color)

unsigned char	*color;

d81 1
a81 4
void free_pixel (pp)

struct pixel	*pp;

d91 1
a91 5
void print_pixel (p, depth)

void	*p;
int	depth;

d108 1
a108 5
int compare_pixels (v1, v2)

void	*v1;
void	*v2;

d130 1
a130 5
struct pixel *lookup_pixel(palette, color)

bu_rb_tree	*palette;
char	*color;

d178 1
a178 5
main (argc, argv)

int	argc;
char	*argv[];

@


11.6
log
@Fixed bug in behavior when an output file is specified on the command line.
@
text
@d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/pixcount.c,v 11.5 2000/08/23 19:04:46 mike Exp $ (BRL)";
d195 1
d304 2
@


11.5
log
@
const RCSid
@
text
@d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/pixcount.c,v 11.4 2000/01/31 16:03:09 jra Exp $ (BRL)";
d43 1
d47 1
a47 1
		 [infile.pix [outfile.pix]]'\n";
d109 2
a110 2
	printf("%3d ", pp -> p_color[i]);
    printf(" %d\n", pp -> p_count);
a205 1
    FILE		*outfp = NULL;	/* output   "   */
@


11.4
log
@Eliminated some unused variables
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/pixcount.c,v 11.3 1998/12/30 01:32:15 mike Exp $ (BRL)";
@


11.3
log
@Changed LibRedBlack names to have bu_ prefix.
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/pixcount.c,v 11.2 1998/11/04 20:19:05 pjt Exp $ (BRL)";
a151 1
    int			i;
@


11.2
log
@Count and report the frequency of the colors in an image
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/pixcount.c,v 11.1 1998/11/04 19:50:39 pjt Exp $ (BRL)";
d145 1
a145 1
rb_tree	*palette;
d149 1
a149 1
    int			rc;	/* Return code from rb_insert() */
d172 1
a172 1
    switch (rc = rb_insert(palette, (void *) qpp))
d178 1
a178 1
	    pp = (struct pixel *) rb_curr1(palette);
d188 1
a188 1
	    bu_log("rb_insert() returns %d:  This should not happen\n", rc);
d201 1
a201 1
    rb_tree		*palette;	/* Pixel palette */
d284 2
a285 2
    palette = rb_create1("Pixel palette", compare_pixels);
    rb_uniq_on1(palette);
d303 1
a303 1
    rb_walk1(palette, print_pixel, INORDER);
@


11.1
log
@*** empty log message ***
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/pixclump.c,v 1.3 1998/06/25 07:17:25 mike Exp $ (BRL)";
d27 1
d47 1
a47 1
#define OPT_STRING	"c:f:x:?"
d63 1
d69 5
a73 1
    vp -> p_color = color;
d88 1
a88 1
    BU_CKMAG(vp, PIXEL_MAGIC, "pixel");
d151 9
a159 1
    struct vertex	*pp;	/* Value to return */
d162 1
a162 1
     *	Prepare the dictionary query
d175 3
d182 3
d208 1
d278 1
a278 1
	    bu_log("FATAL: pixclump reads only from file or pipe\n");
@
