head	11.11;
access;
symbols
	ansi-20040405-merged:11.7.2.2
	postmerge-20040405-ansi:11.9
	premerge-20040404-ansi:11.8
	postmerge-autoconf:11.8
	autoconf-freeze:11.7.10.2
	premerge-autoconf:11.8
	postmerge-20040315-windows:11.8
	premerge-20040315-windows:11.8
	windows-20040315-freeze:11.7.4.1
	autoconf-20031203:11.7
	autoconf-20031202:11.7
	autoconf-branch:11.7.0.10
	phong-branch:11.7.0.8
	photonmap-branch:11.7.0.6
	rel-6-1-DP:11.7
	windows-branch:11.7.0.4
	rel-6-0-2:11.5
	ansi-branch:11.7.0.2
	rel-6-0-1-branch:11.5.0.2
	hartley-6-0-post:11.6
	hartley-6-0-pre:11.5
	rel-6-0-1:11.5
	rel-6-0:11.5
	rel-5-4:11.2
	offsite-5-3-pre:11.4
	rel-5-3:11.2
	rel-5-2:11.2
	rel-5-1-branch:11.2.0.2
	rel-5-1:11.2
	rel-5-0:11.1
	rel-5-0-beta:11.1
	rel-4-5:11.1
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:5.1
	rel-1-24:5.1
	rel-1-20:4.3;
locks; strict;
comment	@ * @;


11.11
date	2004.05.21.14.58.05;	author morrison;	state dead;
branches;
next	11.10;

11.10
date	2004.05.10.15.30.51;	author erikg;	state Exp;
branches;
next	11.9;

11.9
date	2004.04.05.05.46.03;	author morrison;	state Exp;
branches;
next	11.8;

11.8
date	2004.02.02.17.39.52;	author morrison;	state Exp;
branches;
next	11.7;

11.7
date	2002.08.20.17.09.06;	author jra;	state Exp;
branches
	11.7.2.1
	11.7.4.1
	11.7.10.1;
next	11.6;

11.6
date	2002.08.15.20.56.18;	author hartley;	state Exp;
branches;
next	11.5;

11.5
date	2001.08.10.20.57.08;	author butler;	state Exp;
branches;
next	11.4;

11.4
date	2000.09.01.03.24.06;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	2000.08.23.19.05.12;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	2000.01.31.16.03.10;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.13.30;	author mike;	state Rel4_4;
branches;
next	10.3;

10.3
date	94.08.23.15.06.12;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	92.03.16.21.54.21;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.49.24;	author mike;	state Rel4_0;
branches;
next	9.2;

9.2
date	89.10.18.16.44.42;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.11.45;	author mike;	state Rel3_5;
branches;
next	8.2;

8.2
date	89.02.24.13.00.42;	author cjohnson;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.44.36;	author mike;	state Rel3_0;
branches;
next	7.2;

7.2
date	88.09.22.02.45.10;	author phil;	state Exp;
branches;
next	7.1;

7.1
date	87.11.03.00.09.45;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.08.13.12;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.44.11;	author mike;	state Rel;
branches;
next	4.4;

4.4
date	87.05.28.01.34.58;	author mike;	state Exp;
branches;
next	4.3;

4.3
date	87.02.13.00.51.24;	author mike;	state Exp;
branches;
next	4.2;

4.2
date	87.01.13.16.57.53;	author phil;	state Exp;
branches;
next	4.1;

4.1
date	87.01.09.18.01.34;	author mike;	state Rel1;
branches;
next	1.1;

1.1
date	87.01.07.15.25.49;	author mike;	state Exp;
branches;
next	;

11.7.2.1
date	2002.09.19.18.02.46;	author morrison;	state Exp;
branches;
next	11.7.2.2;

11.7.2.2
date	2004.03.17.21.23.37;	author morrison;	state Exp;
branches;
next	;

11.7.4.1
date	2004.03.11.23.52.37;	author morrison;	state Exp;
branches;
next	;

11.7.10.1
date	2004.02.12.19.43.12;	author erikg;	state Exp;
branches;
next	11.7.10.2;

11.7.10.2
date	2004.03.15.14.08.21;	author erikg;	state Exp;
branches;
next	;


desc
@Program to convert Sun bitmap files (from screendump cmd)
into .bw or .pix files.
@


11.11
log
@moved to src/util/
@
text
@/*
 *			 S U N - P I X . C
 *
 *  Program to take Sun bitmap files created with Sun's ``screendump''
 *  command, and convert them to pix(5) format files.
 *
 *  Authors -
 *	Phillip Dykstra
 *	Michael John Muuss
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1986-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/util/sun-pix.c,v 11.10 2004/05/10 15:30:51 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>

#include "machine.h"
#include "externs.h"			/* For getopt */

/*
 * Description of Sun header for files containing raster images
 */
struct rasterfile {
	int	ras_magic;		/* magic number */
	int	ras_width;		/* width (pixels) of image */
	int	ras_height;		/* height (pixels) of image */
	int	ras_depth;		/* depth (1, 8, or 24 bits) of pixel */
	int	ras_length;		/* length (bytes) of image */
	int	ras_type;		/* type of file; see RT_* below */
	int	ras_maptype;		/* type of colormap; see RMT_* below */
	int	ras_maplength;		/* length (bytes) of following map */
	/* color map follows for ras_maplength bytes, followed by image */
} header;

char	inbuf[sizeof(struct rasterfile)];

#define	RAS_MAGIC	0x59a66a95

	/* Sun supported ras_type's */
#define RT_OLD		0	/* Raw pixrect image in 68000 byte order */
#define RT_STANDARD	1	/* Raw pixrect image in 68000 byte order */
#define RT_BYTE_ENCODED	2	/* Run-length compression of bytes */
#define RT_EXPERIMENTAL 0xffff	/* Reserved for testing */

	/* Sun registered ras_maptype's */
#define RMT_RAW		2
	/* Sun supported ras_maptype's */
#define RMT_NONE	0	/* ras_maplength is expected to be 0 */
#define RMT_EQUAL_RGB	1	/* red[ras_maplength/3],green[],blue[] */

/*
 * NOTES:
 * 	Each line of the image is rounded out to a multiple of 16 bits.
 *   This corresponds to the rounding convention used by the memory pixrect
 *   package (/usr/include/pixrect/memvar.h) of the SunWindows system.
 *	The ras_encoding field (always set to 0 by Sun's supported software)
 *   was renamed to ras_length in release 2.0.  As a result, rasterfiles
 *   of type 0 generated by the old software claim to have 0 length; for
 *   compatibility, code reading rasterfiles must be prepared to compute the
 *   true length from the width, height, and depth fields.
 */

int	pixout = 1;		/* 0 = bw(5) output, 1 = pix(5) output */
int	colorout = 0;
int	hflag;
int	inverted;
int	pure;			/* No Sun header */
int	verbose;
struct colors {
	unsigned char	CL_red;
	unsigned char	CL_green;
	unsigned char	CL_blue;
};
struct colors Cmap[256];

static char	*file_name;
static FILE	*fp;

char	usage[] = "\
Usage: sun-pix [-b -h -i -P -v -C] [sun.bitmap]\n";


#define NET_LONG_LEN	4	/* # bytes to network long */

unsigned long
getlong(char *msgp)
{
	register unsigned char *p = (unsigned char *) msgp;
	register unsigned long u;

	u = *p++; u <<= 8;
	u |= *p++; u <<= 8;
	u |= *p++; u <<= 8;
	return (u | *p);
}

int
get_args(int argc, register char **argv)
{
	register int c;

	while ( (c = getopt( argc, argv, "bhiPvC" )) != EOF )  {
		switch( c )  {
		case 'b':
			pixout = 0;	/* bw(5) */
			break;
		case 'C':
			colorout = 1;	/* output just the color map */
			break;
		case 'h':
			hflag = 1;	/* print header */
			break;
		case 'i':
			inverted = 1;
			break;
		case 'P':
			pure = 1;
			break;
		case 'v':
			verbose = 1;
			break;

		default:		/* '?' */
			return(0);
		}
	}

	if( optind >= argc )  {
		if( isatty(fileno(stdin)) )
			return(0);
		file_name = "-";
		fp = stdin;
	} else {
		file_name = argv[optind];
		if( (fp = fopen(file_name, "r")) == NULL )  {
			(void)fprintf( stderr,
				"sun-pix: cannot open \"%s\" for reading\n",
				file_name );
			return(0);
		}
	}

	if ( argc > ++optind )
		(void)fprintf( stderr, "sun-pix: excess argument(s) ignored\n" );

	return(1);		/* OK */
}


/*
 * Encode/decode functions for RT_BYTE_ENCODED images:
 *
 * The "run-length encoding" is of the form
 *
 *	<byte><byte>...<ESC><0>...<byte><ESC><count><byte>...
 *
 * where the counts are in the range 0..255 and the actual number of
 * instances of <byte> is <count>+1 (i.e. actual is 1..256). One- or
 * two-character sequences are left unencoded; three-or-more character
 * sequences are encoded as <ESC><count><byte>.  <ESC> is the character
 * code 128.  Each single <ESC> in the input data stream is encoded as
 * <ESC><0>, because the <count> in this scheme can never be 0 (actual
 * count can never be 1).  <ESC><ESC> is encoded as <ESC><1><ESC>. 
 *
 * This algorithm will fail (make the "compressed" data bigger than the
 * original data) only if the input stream contains an excessive number of
 * one- and two-character sequences of the <ESC> character.  
 */

#define ESCAPE		128

int
decoderead(unsigned char *buf, int size, int length, FILE *fp)
             	     
   		     		/* should be one! */
   		       		/* number of items to read */
    		    		/* input file pointer */
{
	static	int	repeat = -1;
	static	int	lastchar = 0;
	int		number_read;

	number_read = 0;

	if (size != 1) {
		fprintf(stderr,"decoderead: unable to process size = %d.\n",
			size);
		exit(1);
	}

	while (length) {
		if (repeat >= 0) {
			*buf = lastchar;
			--length;
			++buf;
			number_read++;
			--repeat;
		} else {
			lastchar = getc(fp);
			if (lastchar < 0) return(number_read);
			if (lastchar == ESCAPE) {
				repeat = getc(fp);
				if (repeat <0) return(number_read);
				if (repeat == 0) {
					*buf = ESCAPE;
					++buf;
					number_read++;
					--length;
					--repeat;
				} else {
					lastchar = getc(fp);
					if (lastchar < 0) return(number_read);
				}
			} else {
				*buf = lastchar;
				--length;
				++buf;
				++number_read;
			}
		}
	}
	return(number_read);
}

unsigned char bits[8] = { 128, 64, 32, 16, 8, 4, 2, 1 };

int
main(int argc, char **argv)
{
	register int	x;
	register int	off = 0;
	register int	on = 255;
	register int	width;			/* line width in bits */
	register int	scanbytes;		/* bytes/line (padded to 16 bits) */
	unsigned char	buf[4096];

	fp = stdin;
	if ( !get_args( argc, argv ) || (isatty(fileno(stdout)) && (hflag == 0)) ) {
		(void)fputs(usage, stderr);
		exit( 1 );
	}
	if( inverted ) {
		off = 255;
		on = 0;
	}

	if( !pure )  {
		register long nbits;

		fread( inbuf, sizeof(struct rasterfile), 1, fp );

		header.ras_magic = getlong( &inbuf[NET_LONG_LEN*0] );
		header.ras_width = getlong( &inbuf[NET_LONG_LEN*1] );
		header.ras_height = getlong( &inbuf[NET_LONG_LEN*2] );
		header.ras_depth = getlong( &inbuf[NET_LONG_LEN*3] );
		header.ras_length = getlong( &inbuf[NET_LONG_LEN*4] );
		header.ras_type = getlong( &inbuf[NET_LONG_LEN*5] );
		header.ras_maptype = getlong( &inbuf[NET_LONG_LEN*6] );
		header.ras_maplength = getlong( &inbuf[NET_LONG_LEN*7] );

		if( header.ras_magic != RAS_MAGIC )  {
			fprintf(stderr,
				"sun-pix: bad magic number, was x%x, s/b x%x\n",
				header.ras_magic, RAS_MAGIC );
			exit(1);
		}

		/* Width is rounded up to next multiple of 16 bits */
		nbits = header.ras_width * header.ras_depth;
		nbits = (nbits + 15) & ~15;
		header.ras_width = nbits / header.ras_depth;

		if(verbose)  {
			fprintf( stderr, 
				"ras_width = %d, ras_height = %d\nras_depth = %d, ras_length = %d\n",
				header.ras_width, header.ras_height,
				header.ras_depth, header.ras_length );
			fprintf( stderr,
				"ras_type = %d, ras_maptype = %d, ras_maplength = %d\n",
				header.ras_type,
				header.ras_maptype,
				header.ras_maplength );
		}
		if( hflag ) {
			printf( "-w%d -n%d\n", header.ras_width, header.ras_height );
			exit( 0 );
		}
	} else {
		/* "pure" bitmap */
		header.ras_type = RT_STANDARD;
		header.ras_depth = 1;
	}

	switch( header.ras_type )  {
	case RT_OLD:		/* ??? */
	case RT_BYTE_ENCODED:
	case RT_STANDARD:
		break;
	default:
		fprintf(stderr,"sun-pix:  Unable to process type %d images\n",
			header.ras_type );
		exit(1);
	}

	width = header.ras_width;
	x = 0;

	switch( header.ras_depth )  {
	case 1:
		/* 1-bit image */
		/*  Gobble colormap -- ought to know what to do with it */
		for( x=0; x<header.ras_maplength; x++)  {
			(void)getc(fp);
		}
		if (colorout) {
			fprintf(stdout,"%d\t%04x %04x %04x\n",off,off<<8,
			    off<<8,off<<8);
			fprintf(stdout,"%d\t%04x %04x %04x\n",on,on<<8,
			    on<<8,on<<8);
			break;
		}

		scanbytes = ((width + 15) & ~15L) / 8;
		while( (header.ras_type == RT_BYTE_ENCODED) ?
		    decoderead(buf, sizeof(*buf), scanbytes, fp) :
		    fread(buf, sizeof(*buf), scanbytes, fp) ) {
			for( x = 0; x < width; x++ ) {
				if( buf[x>>3] & bits[x&7] ) {
					putchar(on);
					if(pixout){putchar(on);putchar(on);}
				} else {
					putchar(off);
					if(pixout){putchar(off);putchar(off);}
				}
			}
		}
		break;
	case 8:
		/* 8-bit image */
		if (header.ras_maptype != RMT_EQUAL_RGB) {
			fprintf(stderr,"sun-pix:  unable to handle depth=8, maptype = %d.\n",
				header.ras_maptype);
			exit(1);
		}
		scanbytes = width;
		for (x = 0; x < header.ras_maplength/3; x++) {
			if (inverted) {
				Cmap[x].CL_red = 255-(unsigned char)getc(fp);
			} else {
				Cmap[x].CL_red = getc(fp);
			}
		}
		for (x = 0; x < header.ras_maplength/3; x++) {
			if (inverted) {
				Cmap[x].CL_green = 255-(unsigned char)getc(fp);
			} else {
				Cmap[x].CL_green = getc(fp);
			}
		}
		for (x = 0; x < header.ras_maplength/3; x++) {
			if (inverted) {
				Cmap[x].CL_blue = 255-(unsigned char) getc(fp);
			} else {
				Cmap[x].CL_blue = getc(fp);
			}
		}
		if (colorout) {
			for (x = 0; x <header.ras_maplength/3; x++) {
				fprintf(stdout,"%d\t%04x %04x %04x\n",
				    x, Cmap[x].CL_red<<8, Cmap[x].CL_green<<8,
				    Cmap[x].CL_blue<<8);
			}
			break;
		}

		while ((header.ras_type == RT_BYTE_ENCODED) ?
		    decoderead(buf, sizeof(*buf), scanbytes, fp):
		    fread(buf, sizeof(*buf), scanbytes, fp) ) {
			for (x=0; x < width; x++ ) {
				if (pixout) {
					putchar(Cmap[buf[x]].CL_red);
					putchar(Cmap[buf[x]].CL_green);
					putchar(Cmap[buf[x]].CL_blue);
				} else {
					putchar(buf[x]);
				}
			}
		}
		break;
	default:
		fprintf(stderr,"sun-pix:  unable to handle depth=%d\n",
			header.ras_depth );
		exit(1);
	}
	exit(0);
}
@


11.10
log
@change conf.h to a wrapped config.h
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/util/sun-pix.c,v 11.9 2004/04/05 05:46:03 morrison Exp $ (BRL)";
@


11.9
log
@merge of ansi-6-0-branch into head
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d24 5
a28 1
#include "conf.h"
@


11.8
log
@update copyright to include span through 2003
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/sun-pix.c,v 11.7 2002/08/20 17:09:06 jra Exp $ (BRL)";
d97 1
a97 2
getlong(msgp)
	char *msgp;
d109 1
a109 2
get_args( argc, argv )
register char **argv;
d184 5
a188 5
decoderead(buf,size,length,fp)
unsigned char	*buf;
int		size;		/* should be one! */
int		length;		/* number of items to read */
FILE		*fp;		/* input file pointer */
d239 1
a239 3
main( argc, argv )
int argc;
char **argv;
@


11.7
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1986 by the United States Army.
d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/sun-pix.c,v 11.5 2001/08/10 20:57:08 butler Exp $ (BRL)";
@


11.7.4.1
log
@sync to HEAD...
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/util/sun-pix.c,v 11.8 2004/02/02 17:39:52 morrison Exp $ (BRL)";
@


11.7.10.1
log
@merge from HEAD
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/sun-pix.c,v 11.8 2004/02/02 17:39:52 morrison Exp $ (BRL)";
@


11.7.10.2
log
@merge from head
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/sun-pix.c,v 11.7.10.1 2004/02/12 19:43:12 erikg Exp $ (BRL)";
@


11.7.2.1
log
@Initial ANSIfication
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/sun-pix.c,v 11.7 2002/08/20 17:09:06 jra Exp $ (BRL)";
d97 2
a98 1
getlong(char *msgp)
d110 2
a111 1
get_args(int argc, register char **argv)
d186 5
a190 5
decoderead(unsigned char *buf, int size, int length, FILE *fp)
             	     
   		     		/* should be one! */
   		       		/* number of items to read */
    		    		/* input file pointer */
d241 3
a243 1
main(int argc, char **argv)
@


11.7.2.2
log
@sync branch with HEAD
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d21 1
a21 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.6
log
@Converted from K&R to ANSI C - RFH
@
text
@d97 2
a98 1
getlong(char *msgp)
d110 2
a111 1
get_args(int argc, register char **argv)
d186 5
a190 5
decoderead(unsigned char *buf, int size, int length, FILE *fp)
             	     
   		     		/* should be one! */
   		       		/* number of items to read */
    		    		/* input file pointer */
d241 3
a243 1
main(int argc, char **argv)
@


11.5
log
@Misc compiler warnings eliminated
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/sun-pix.c,v 11.4 2000/09/01 03:24:06 mike Exp $ (BRL)";
d97 1
a97 2
getlong(msgp)
	char *msgp;
d109 1
a109 2
get_args( argc, argv )
register char **argv;
d184 5
a188 5
decoderead(buf,size,length,fp)
unsigned char	*buf;
int		size;		/* should be one! */
int		length;		/* number of items to read */
FILE		*fp;		/* input file pointer */
d239 1
a239 3
main( argc, argv )
int argc;
char **argv;
@


11.4
log
@
Lint fix
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/sun-pix.c,v 11.3 2000/08/23 19:05:12 mike Exp $ (BRL)";
d109 1
d163 75
a410 74
}
/*
 * Encode/decode functions for RT_BYTE_ENCODED images:
 *
 * The "run-length encoding" is of the form
 *
 *	<byte><byte>...<ESC><0>...<byte><ESC><count><byte>...
 *
 * where the counts are in the range 0..255 and the actual number of
 * instances of <byte> is <count>+1 (i.e. actual is 1..256). One- or
 * two-character sequences are left unencoded; three-or-more character
 * sequences are encoded as <ESC><count><byte>.  <ESC> is the character
 * code 128.  Each single <ESC> in the input data stream is encoded as
 * <ESC><0>, because the <count> in this scheme can never be 0 (actual
 * count can never be 1).  <ESC><ESC> is encoded as <ESC><1><ESC>. 
 *
 * This algorithm will fail (make the "compressed" data bigger than the
 * original data) only if the input stream contains an excessive number of
 * one- and two-character sequences of the <ESC> character.  
 */

#define ESCAPE		128

int
decoderead(buf,size,length,fp)
unsigned char	*buf;
int		size;		/* should be one! */
int		length;		/* number of items to read */
FILE		*fp;		/* input file pointer */
{
	static	int	repeat = -1;
	static	int	lastchar = 0;
	int		number_read;

	number_read = 0;

	if (size != 1) {
		fprintf(stderr,"decoderead: unable to process size = %d.\n",
			size);
		exit(1);
	}

	while (length) {
		if (repeat >= 0) {
			*buf = lastchar;
			--length;
			++buf;
			number_read++;
			--repeat;
		} else {
			lastchar = getc(fp);
			if (lastchar < 0) return(number_read);
			if (lastchar == ESCAPE) {
				repeat = getc(fp);
				if (repeat <0) return(number_read);
				if (repeat == 0) {
					*buf = ESCAPE;
					++buf;
					number_read++;
					--length;
					--repeat;
				} else {
					lastchar = getc(fp);
					if (lastchar < 0) return(number_read);
				}
			} else {
				*buf = lastchar;
				--length;
				++buf;
				++number_read;
			}
		}
	}
	return(number_read);
@


11.3
log
@
const RCSid
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/sun-pix.c,v 11.2 2000/01/31 16:03:10 jra Exp $ (BRL)";
d164 1
@


11.2
log
@Eliminated some unused variables
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/sun-pix.c,v 11.1 1995/01/04 10:13:30 mike Rel4_4 $ (BRL)";
@


11.1
log
@Release_4.4
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/sun-pix.c,v 10.3 94/08/23 15:06:12 gdurf Exp $ (BRL)";
a172 1
	register int	n;
d262 1
a262 1
		while( n = (header.ras_type == RT_BYTE_ENCODED) ?
d314 1
a314 1
		while (n = (header.ras_type == RT_BYTE_ENCODED) ?
@


10.3
log
@Factored ifdefs
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/sun-pix.c,v 10.2 1992/03/16 21:54:21 mike Exp gdurf $ (BRL)";
@


10.2
log
@IRIX 4.0.1
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/sun-pix.c,v 10.1 91/10/12 06:49:24 mike Rel4_0 Locker: mike $ (BRL)";
d24 2
d28 2
a29 3
extern int	getopt();
extern char	*optarg;
extern int	optind;
@


10.1
log
@Release_4.0
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/sun-pix.c,v 9.2 89/10/18 16:44:42 mike Exp $ (BRL)";
d87 1
a87 1
static FILE	*fp = stdin;
d175 1
@


9.2
log
@Changed to round up width to next 16 bit boundary,
as specification requires.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: sun-pix.c,v 9.1 89/05/19 06:11:45 mike Locked $ (BRL)";
@


9.1
log
@Release_3.5
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: sun-pix.c,v 8.2 89/02/24 13:00:42 cjohnson Exp $ (BRL)";
d185 2
d204 5
@


8.2
log
@Add processing for 8 bit rasters.  Handle run lenght encoded rasters.
Added code to dump a color map.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: sun-pix.c,v 8.1 88/10/05 00:44:36 mike Rel3_0 $ (BRL)";
@


8.1
log
@Release_3.0
@
text
@d2 1
a2 1
 *			S U N - P I X . C
d21 1
a21 1
static char RCSid[] = "@@(#)$Header: sun-pix.c,v 7.2 88/09/22 02:45:10 phil Exp $ (BRL)";
d74 1
d79 6
d90 1
a90 1
Usage: sun-pix [-b -h -i -P -v] [sun.bitmap]\n";
d113 1
a113 1
	while ( (c = getopt( argc, argv, "bhiPv" )) != EOF )  {
d118 3
d173 1
a173 1
	char	buf[4096];
d226 1
a234 5
	/*  Gobble colormap -- ought to know what to do with it */
	for( x=0; x<header.ras_maplength; x++)  {
		(void)getc(fp);
	}

a235 1
	scanbytes = ((width + 15) & ~15L) / 8;
d241 16
a256 1
		while( n = fread(buf, sizeof(*buf), scanbytes, fp) ) {
d268 52
d326 74
@


7.2
log
@changed one getchar() to getc(fp)
rewrote the main loop to handle padded bitmaps correctly.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: sun-pix.c,v 7.1 87/11/03 00:09:45 phil Locked $ (BRL)";
@


7.1
log
@Release 2.3
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: sun-pix.c,v 6.1 87/07/11 08:13:12 mike Rel $ (BRL)";
d150 3
d157 7
a163 1
	register int	i, c;
d169 4
d225 2
a226 2
	for( c=0; c<header.ras_maplength; c++)  {
		(void)getchar();
d229 4
d236 9
a244 20
		while( !feof(fp) ) {
			c = getc(fp);
			if( inverted ) {
				for( i = 0x80; i > 0; i >>= 1 )
					if( c & i ) {
						putchar( 0 );
						if(pixout){putchar(0);putchar(0);}
					} else {
						putchar( 255 );
						if(pixout){putchar(255);putchar(255);}
					}
			} else {
				for( i = 0x80; i > 0; i >>= 1 )
					if( c & i ) {
						putchar( 255 );
						if(pixout){putchar(255);putchar(255);}
					} else {
						putchar( 0 );
						if(pixout){putchar(0);putchar(0);}
					}
@


6.1
log
@Release 2.0
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: sun-pix.c,v 5.1 87/06/24 22:44:11 mike Rel $ (BRL)";
@


5.1
log
@Release 1.24
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: sun-pix.c,v 4.4 87/05/28 01:34:58 mike Exp $ (BRL)";
@


4.4
log
@Fixed to have -v flag for header dumping, and
to complain about image types it can not handle.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: sun-pix.c,v 4.3 87/02/13 00:51:24 mike Locked $ (BRL)";
@


4.3
log
@Release 1.20 -- First Formal Release
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: sun-pix.c,v 4.2 87/01/13 16:57:53 phil Exp $ (BRL)";
d77 1
d83 1
a83 1
Usage: sun-pix [-b -h -i -P] [sun.bitmap]\n";
d106 1
a106 1
	while ( (c = getopt( argc, argv, "bhiP" )) != EOF )  {
d120 3
d180 11
a190 4
#ifdef debug
		fprintf( stderr, "ras_width = %d, ras_height = %d, ras_depth = %d, ras_length = %d\n",
			header.ras_width, header.ras_height, header.ras_depth, header.ras_length );
#endif
d199 10
@


4.2
log
@allowed -h to print on tty (without stdout redirection)
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: sun-pix.c,v 4.1 87/01/09 18:01:34 phil Locked $ (BRL)";
@


4.1
log
@Changed to use getopt(), made byte order independent.
Release 1.15
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: sun-pix.c,v 1.1 87/01/07 15:25:49 mike Locked $ (BRL)";
d152 1
a152 1
	if ( !get_args( argc, argv ) || isatty(fileno(stdout)) )  {
@


1.1
log
@Initial revision
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d26 4
d31 1
a31 1
 * Description of header for files containing raster images
d44 3
a76 1
int	byteswap;		/* Need to byte swap */
d78 2
a79 1
FILE	*fp = stdin;
d84 62
d152 3
a154 16
	while( argc > 1 ) {
		if( strcmp( argv[1], "-b" ) == 0 )
			pixout = 0;
		else
		if( strcmp( argv[1], "-h" ) == 0 )
			hflag++;
		else
		if( strcmp( argv[1], "-i" ) == 0 )
			inverted++;
		else
		if( strcmp( argv[1], "-P" ) == 0 )
			pure++;
		else
			break;
		argc--;
		argv++;
d157 2
a158 9
	if( argc > 1 ) {
		if( (fp = fopen( argv[1], "r" )) == NULL ) {
			fprintf( stderr, "Can't open file\n" );
			exit( 1 );
		}
	} else if( isatty(fileno(stdin)) ) {
		fprintf( stderr, usage);
		exit( 2 );
	}
d160 8
a167 2
	if( !pure )
		fread( &header, sizeof(header), 1, fp );
d169 1
a169 2
	if( header.ras_magic != RAS_MAGIC )  {
		if( ntohl(header.ras_magic) != RAS_MAGIC )  {
d171 1
a171 1
				"bad magic number, was x%x, s/b x%x\n",
a174 6
		header.ras_width = ntohl(header.ras_width);
		header.ras_height = ntohl(header.ras_height);
		header.ras_depth = ntohl(header.ras_depth);
		header.ras_length = ntohl(header.ras_length);
		header.ras_maplength = ntohl(header.ras_maplength);
	}
d176 12
a187 7
/*
	fprintf( stderr, "ras_width = %d, ras_height = %d, ras_depth = %d, ras_length = %d\n",
		header.ras_width, header.ras_height, header.ras_depth, header.ras_length );
*/
	if( hflag ) {
		printf( "-w%d -n%d\n", header.ras_width, header.ras_height );
		exit( 0 );
d190 1
a190 1
	/*  Gobble colormap */
d195 24
a218 21
	/* For now, assume 1-bit image */
	while( !feof(fp) ) {
		c = getc(fp);
		if( inverted ) {
			for( i = 0x80; i > 0; i >>= 1 )
				if( c & i ) {
					putchar( 0 );
					if(pixout){putchar(0);putchar(0);}
				} else {
					putchar( 255 );
					if(pixout){putchar(255);putchar(255);}
				}
		} else {
			for( i = 0x80; i > 0; i >>= 1 )
				if( c & i ) {
					putchar( 255 );
					if(pixout){putchar(255);putchar(255);}
				} else {
					putchar( 0 );
					if(pixout){putchar(0);putchar(0);}
				}
d220 5
d226 1
@
