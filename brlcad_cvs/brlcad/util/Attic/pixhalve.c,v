head	11.15;
access;
symbols
	ansi-20040405-merged:11.11.2.2
	postmerge-20040405-ansi:11.13
	premerge-20040404-ansi:11.12
	postmerge-autoconf:11.12
	autoconf-freeze:11.11.10.2
	premerge-autoconf:11.12
	postmerge-20040315-windows:11.12
	premerge-20040315-windows:11.12
	windows-20040315-freeze:11.11.4.1
	autoconf-20031203:11.11
	autoconf-20031202:11.11
	autoconf-branch:11.11.0.10
	phong-branch:11.11.0.8
	photonmap-branch:11.11.0.6
	rel-6-1-DP:11.11
	windows-branch:11.11.0.4
	rel-6-0-2:11.9
	ansi-branch:11.11.0.2
	rel-6-0-1-branch:11.9.0.2
	hartley-6-0-post:11.10
	hartley-6-0-pre:11.9
	rel-6-0-1:11.9
	rel-6-0:11.9
	rel-5-4:11.6
	offsite-5-3-pre:11.8
	rel-5-3:11.6
	rel-5-2:11.6
	rel-5-1-branch:11.6.0.2
	rel-5-1:11.6
	rel-5-0:11.5
	rel-5-0-beta:11.5
	rel-4-5:11.5
	ctj-4-5-post:11.5
	ctj-4-5-pre:11.5
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.15
date	2004.05.21.14.57.53;	author morrison;	state dead;
branches;
next	11.14;

11.14
date	2004.05.10.15.30.51;	author erikg;	state Exp;
branches;
next	11.13;

11.13
date	2004.04.05.05.46.02;	author morrison;	state Exp;
branches;
next	11.12;

11.12
date	2004.02.02.17.39.46;	author morrison;	state Exp;
branches;
next	11.11;

11.11
date	2002.08.20.17.09.03;	author jra;	state Exp;
branches
	11.11.2.1
	11.11.4.1
	11.11.10.1;
next	11.10;

11.10
date	2002.08.15.20.56.13;	author hartley;	state Exp;
branches;
next	11.9;

11.9
date	2001.08.10.20.57.07;	author butler;	state Exp;
branches;
next	11.8;

11.8
date	2000.09.01.03.23.56;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	2000.08.23.19.04.51;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	2000.01.31.16.03.09;	author jra;	state Exp;
branches;
next	11.5;

11.5
date	96.12.13.15.05.51;	author jra;	state Exp;
branches;
next	11.4;

11.4
date	96.07.16.22.56.03;	author jra;	state Exp;
branches;
next	11.3;

11.3
date	95.12.15.05.33.52;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	95.12.15.04.45.16;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.12.45;	author mike;	state Rel4_4;
branches;
next	10.3;

10.3
date	94.08.23.15.05.57;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	92.05.07.23.38.49;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.48.41;	author mike;	state Rel4_0;
branches;
next	1.4;

1.4
date	91.07.22.22.30.29;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	90.11.03.14.36.28;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	90.11.02.10.18.56;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	90.11.02.09.55.03;	author mike;	state Exp;
branches;
next	;

11.11.2.1
date	2002.09.19.18.02.41;	author morrison;	state Exp;
branches;
next	11.11.2.2;

11.11.2.2
date	2004.03.17.21.23.30;	author morrison;	state Exp;
branches;
next	;

11.11.4.1
date	2004.03.11.23.52.32;	author morrison;	state Exp;
branches;
next	;

11.11.10.1
date	2004.02.12.19.43.11;	author erikg;	state Exp;
branches;
next	11.11.10.2;

11.11.10.2
date	2004.03.15.14.08.13;	author erikg;	state Exp;
branches;
next	;


desc
@Reduce .pix file to half it's original size, filtering with 5x5 kernel
@


11.15
log
@moved to src/util/
@
text
@/*
 *			P I X H A L V E . C
 *
 *  Reduce the resolution of a .pix file by one half in each direction,
 *  using a 5x5 pyramid filter.
 *
 *  As this tool is used primarily for preparing images for NTSC television,
 *  convert RGB to YUV, then apply different filter kernels;  use 3x3 for Y,
 *  5x5 for U and V.
 *
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1995-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/util/pixhalve.c,v 11.14 2004/05/10 15:30:51 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>

#include "machine.h"
#include <bu.h>
#include <vmath.h>
#include <bn.h>
#include "externs.h"		/* For getopt, etc */

static char	*file_name;
static FILE	*infp;

static int	fileinput = 0;		/* file or pipe on input? */
static int	autosize = 0;		/* !0 to autosize input */

static int	file_width = 512;	/* default input width */

static char usage[] = "\
Usage: pixhalve [-h] [-a]\n\
	[-s squaresize] [-w file_width] [-n file_height] [file.pix]\n";

void separate(register int *rop, register int *gop, register int *bop, register unsigned char *cp, int num);
void combine(register unsigned char *cp, register int *rip, register int *gip, register int *bip, int num);
void ripple(int **array, int num);
void filter3(int *op, int **lines, int num);
void filter5(int *op, int **lines, int num);

int
get_args(int argc, register char **argv)
{
	register int c;

	while ( (c = getopt( argc, argv, "ahs:w:n:" )) != EOF )  {
		switch( c )  {
		case 'a':
			autosize = 1;
			break;
		case 'h':
			/* high-res */
			file_width = 1024;
			autosize = 0;
			break;
		case 's':
			/* square file size */
			file_width = atoi(optarg);
			autosize = 0;
			break;
		case 'w':
			file_width = atoi(optarg);
			autosize = 0;
			break;
		case 'n':
			autosize = 0;
			break;

		default:		/* '?' */
			return(0);
		}
	}

	if( optind >= argc )  {
		if( isatty(fileno(stdin)) )
			return(0);
		file_name = "-";
		infp = stdin;
	} else {
		file_name = argv[optind];
		if( (infp = fopen(file_name, "r")) == NULL )  {
			perror(file_name);
			(void)fprintf( stderr,
				"pixhalve: cannot open \"%s\" for reading\n",
				file_name );
			return(0);
		}
		fileinput++;
	}

	if ( argc > ++optind )
		(void)fprintf( stderr, "pixhalve: excess argument(s) ignored\n" );

	return(1);		/* OK */
}

int	*rlines[5];
int	*glines[5];
int	*blines[5];

/*
 *			M A I N
 */
int
main(int argc, char **argv)
{
	char	*inbuf;
	char	*outbuf;
	int	*rout, *gout, *bout;
	int	out_width;
	int	i;
	int	eof_seen;

	if ( !get_args( argc, argv ) )  {
		(void)fputs(usage, stderr);
		exit( 1 );
	}

	/* autosize input? */
	if( fileinput && autosize ) {
		int	w, h;
		if( bn_common_file_size(&w, &h, file_name, 3) ) {
			file_width = w;
		} else {
			fprintf(stderr, "pixhalve: unable to autosize\n");
		}
	}
	out_width = file_width/2;

	/* Allocate 1-scanline input & output buffers */
	inbuf = malloc( 3*file_width+8 );
	outbuf = malloc( 3*(out_width+2)+8 );

	/* Allocate 5 integer arrays for each color */
	/* each width+2 elements wide */
	for( i=0; i<5; i++ )  {
		rlines[i] = (int *)calloc( (file_width+4)+1, sizeof(long) );
		glines[i] = (int *)calloc( (file_width+4)+1, sizeof(long) );
		blines[i] = (int *)calloc( (file_width+4)+1, sizeof(long) );
	}

	/* Allocate an integer array for each color, for output */
	rout = (int *)malloc( out_width * sizeof(long) + 8 );
	gout = (int *)malloc( out_width * sizeof(long) + 8 );
	bout = (int *)malloc( out_width * sizeof(long) + 8 );

	/*
	 *  Prime the pumps with 5 lines of image.
	 *  Repeat the bottom most line three times to generate a "fill"
	 *  line on the bottom.  This will have to be matched on the top.
	 */
	if( fread( inbuf, 3, file_width, infp ) != file_width )  {
		perror(file_name);
		fprintf(stderr, "pixhalve:  fread error\n");
		exit(1);
	}
	separate( &rlines[0][2], &glines[0][2], &blines[0][2], inbuf, file_width );
	separate( &rlines[1][2], &glines[1][2], &blines[1][2], inbuf, file_width );
	separate( &rlines[2][2], &glines[2][2], &blines[2][2], inbuf, file_width );
	for( i=3; i<5; i++ )  {
		if( fread( inbuf, 3, file_width, infp ) != file_width )  {
			perror(file_name);
			fprintf(stderr, "pixhalve:  fread error\n");
			exit(1);
		}
		separate( &rlines[i][2], &glines[i][2], &blines[i][2],
			inbuf, file_width );
	}

	eof_seen = 0;
	for(;;)  {
		filter3( rout, rlines, out_width );
		filter5( gout, glines, out_width );
		filter5( bout, blines, out_width );
		combine( outbuf, rout, gout, bout, out_width );
		if( fwrite( outbuf, 3, out_width, stdout ) != out_width )  {
			perror("stdout");
			exit(2);
		}

		/* Ripple down two scanlines, and acquire two more */
		if( fread( inbuf, 3, file_width, infp ) != file_width )  {
			if( eof_seen >= 2 )  break;
			/* EOF, repeat last line 2x for final output line */
			eof_seen++;
			/* Fall through */
		}
		ripple( rlines, 5 );
		ripple( glines, 5 );
		ripple( blines, 5 );
		separate( &rlines[4][2], &glines[4][2], &blines[4][2],
			inbuf, file_width );

		if( fread( inbuf, 3, file_width, infp ) != file_width )  {
			if( eof_seen >= 2 )  break;
			/* EOF, repeat last line 2x for final output line */
			eof_seen++;
			/* Fall through */
		}
		ripple( rlines, 5 );
		ripple( glines, 5 );
		ripple( blines, 5 );
		separate( &rlines[4][2], &glines[4][2], &blines[4][2],
			inbuf, file_width );
	}
	exit(0);
}

/*
 *			S E P A R A T E
 *
 *  Unpack RGB byte tripples into three separate arrays of integers.
 *  The first and last pixels are replicated twice, to handle border effects.
 *
 *  Updated version:  the outputs are Y U V values, not R G B.
 */
void
separate(register int *rop, register int *gop, register int *bop, register unsigned char *cp, int num)
            	     			/* Y */
            	     			/* U */
            	     			/* V */
                      	    
   		    
{
	register int 	i;
	register int	r, g, b;

	r = cp[0];
	g = cp[1];
	b = cp[2];

#define YCONV(_r, _g, _b)	(_r * 0.299 + _g * 0.587 + _b * 0.144 + 0.9)
#define UCONV(_r, _g, _b)	(_r * -0.1686 + _g * -0.3311 + _b * 0.4997 + 0.9)
#define VCONV(_r, _g, _b)	(_r * 0.4998 + _g * -0.4185 + _b * -0.0813 + 0.9)

	rop[-1] = rop[-2] = YCONV(r,g,b);
	gop[-1] = gop[-2] = UCONV(r,g,b);
	bop[-1] = bop[-2] = VCONV(r,g,b);

	for( i = num-1; i >= 0; i-- )  {
		r = cp[0];
		g = cp[1];
		b = cp[2];
		cp += 3;
		*rop++ = YCONV(r,g,b);
		*gop++ = UCONV(r,g,b);
		*bop++ = VCONV(r,g,b);
	}

	r = cp[-3];
	g = cp[-2];
	b = cp[-1];

	*rop++ = YCONV(r,g,b);
	*gop++ = UCONV(r,g,b);
	*bop++ = VCONV(r,g,b);

	*rop++ = YCONV(r,g,b);
	*gop++ = UCONV(r,g,b);
	*bop++ = VCONV(r,g,b);
}

/*
 *			C O M B I N E
 *
 *  Combine three separate arrays of integers into a buffer of
 *  RGB byte tripples
 */
void
combine(register unsigned char *cp, register int *rip, register int *gip, register int *bip, int num)
{
	register int 	i;

#define RCONV(_y, _u, _v)	(_y + 1.4026 * _v)
#define GCONV(_y, _u, _v)	(_y - 0.3444 * _u - 0.7144 * _v)
#define BCONV(_y, _u, _v)	(_y + 1.7730 * _u)

#define CLIP(_v)	( ((_v) <= 0) ? 0 : (((_v) >= 255) ? 255 : (_v)) )

	for( i = num-1; i >= 0; i-- )  {
		register int	y, u, v;
		register int	r, g, b;

		y = *rip++;
		u = *gip++;
		v = *bip++;

		r = RCONV(y,u,v);
		g = GCONV(y,u,v);
		b = BCONV(y,u,v);

		*cp++ = CLIP(r);
		*cp++ = CLIP(g);
		*cp++ = CLIP(b);
	}
}

/*
 *			R I P P L E
 *
 *  Ripple all the scanlines down by one.
 *
 *  Barrel shift all the pointers down, with [0] going back to the top.
 */
void
ripple(int **array, int num)
{
	register int	i;
	int		*temp;

	temp = array[0];
	for( i=0; i < num-1; i++ )
		array[i] = array[i+1];
	array[num-1] = temp;
}

/*
 *			F I L T E R 5
 *
 *  Apply a 5x5 image pyramid to the input scanline, taking every other
 *  input position to make an output.
 *
 *  Code is arranged so as to vectorize, on machines that can.
 */
void
filter5(int *op, int **lines, int num)
{
	register int	i;
	register int	*a, *b, *c, *d, *e;

	a = lines[0];
	b = lines[1];
	c = lines[2];
	d = lines[3];
	e = lines[4];

#ifdef VECTORIZE
	/* This version vectorizes */
#	include "noalias.h"
	for( i=0; i < num; i++ )  {
		j = i*2;
		op[i] = (
			  a[j+0] + 2*a[j+1] + 4*a[j+2] + 2*a[j+3] +   a[j+4] +
			2*b[j+0] + 4*b[j+1] + 8*b[j+2] + 4*b[j+3] + 2*b[j+4] +
			4*c[j+0] + 8*c[j+1] +16*c[j+2] + 8*c[j+3] + 4*c[j+4] +
			2*d[j+0] + 4*d[j+1] + 8*d[j+2] + 4*d[j+3] + 2*d[j+4] +
			  e[j+0] + 2*e[j+1] + 4*e[j+2] + 2*e[j+3] +   e[j+4]
			) / 100;
	}
#else
	/* This version is better for non-vectorizing machines */
	for( i=0; i < num; i++ )  {
		op[i] = (
			  a[0] + 2*a[1] + 4*a[2] + 2*a[3] +   a[4] +
			2*b[0] + 4*b[1] + 8*b[2] + 4*b[3] + 2*b[4] +
			4*c[0] + 8*c[1] +16*c[2] + 8*c[3] + 4*c[4] +
			2*d[0] + 4*d[1] + 8*d[2] + 4*d[3] + 2*d[4] +
			  e[0] + 2*e[1] + 4*e[2] + 2*e[3] +   e[4]
			) / 100;
		a += 2;
		b += 2;
		c += 2;
		d += 2;
		e += 2;
	}
#endif
}


/*
 *			F I L T E R 3
 *
 *  Apply a 3x3 image pyramid to the input scanline, taking every other
 *  input position to make an output.
 *
 *  The filter coefficients are positioned so as to align the center
 *  of the filter with the same center used in filter5().
 */
void
filter3(int *op, int **lines, int num)
{
	register int	i;
	register int	*b, *c, *d;

	b = lines[1];
	c = lines[2];
	d = lines[3];

#ifdef VECTORIZE
	/* This version vectorizes */
#	include "noalias.h"
	for( i=0; i < num; i++ )  {
		j = i*2;
		op[i] = (
			  b[j+1] + 2*b[j+2] +   b[j+3] +
			2*c[j+1] + 4*c[j+2] + 2*c[j+3] +
			  d[j+1] + 2*d[j+2] +   d[j+3]
			) / 16;
	}
#else
	/* This version is better for non-vectorizing machines */
	for( i=0; i < num; i++ )  {
		op[i] = (
			  b[1] + 2*b[2] +   b[3] +
			2*c[1] + 4*c[2] + 2*c[3] +
			  d[1] + 2*d[2] +   d[3]
			) / 16;
		b += 2;
		c += 2;
		d += 2;
	}
#endif
}
@


11.14
log
@change conf.h to a wrapped config.h
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/util/pixhalve.c,v 11.13 2004/04/05 05:46:02 morrison Exp $ (ARL)";
@


11.13
log
@merge of ansi-6-0-branch into head
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d31 5
a35 1
#include "conf.h"
@


11.12
log
@update copyright to include span through 2003
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/pixhalve.c,v 11.11 2002/08/20 17:09:03 jra Exp $ (ARL)";
d53 5
a57 1
void separate(), combine(), ripple(), filter5(), filter3();
d60 1
a60 2
get_args( argc, argv )
register char **argv;
d123 1
a123 3
main( argc, argv )
int	argc;
char	**argv;
d236 6
a241 6
separate( rop, gop, bop, cp, num )
register int	*rop;			/* Y */
register int	*gop;			/* U */
register int	*bop;			/* V */
register unsigned char	*cp;
int		num;
d288 1
a288 6
combine( cp, rip, gip, bip, num )
register unsigned char	*cp;
register int		*rip;
register int		*gip;
register int		*bip;
int			num;
d324 1
a324 3
ripple( array, num )
int	*array[];
int	num;
d344 1
a344 4
filter5( op, lines, num )
int	*op;
int	*lines[];
int	num;
d398 1
a398 4
filter3( op, lines, num )
int	*op;
int	*lines[];
int	num;
@


11.11
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d24 1
a24 1
 *	This software is Copyright (C) 1995 by the United States Army
d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/pixhalve.c,v 11.9 2001/08/10 20:57:07 butler Exp $ (ARL)";
@


11.11.4.1
log
@sync to HEAD...
@
text
@d24 1
a24 1
 *	This software is Copyright (C) 1995-2004 by the United States Army
d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/util/pixhalve.c,v 11.12 2004/02/02 17:39:46 morrison Exp $ (ARL)";
@


11.11.10.1
log
@merge from HEAD
@
text
@d24 1
a24 1
 *	This software is Copyright (C) 1995-2004 by the United States Army
d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/pixhalve.c,v 11.12 2004/02/02 17:39:46 morrison Exp $ (ARL)";
@


11.11.10.2
log
@merge from head
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/pixhalve.c,v 11.11.10.1 2004/02/12 19:43:11 erikg Exp $ (ARL)";
@


11.11.2.1
log
@Initial ANSIfication
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/pixhalve.c,v 11.11 2002/08/20 17:09:03 jra Exp $ (ARL)";
d53 1
a53 1
void separate(register int *rop, register int *gop, register int *bop, register unsigned char *cp, int num), combine(register unsigned char *cp, register int *rip, register int *gip, register int *bip, int num), ripple(int **array, int num), filter5(int *op, int **lines, int num), filter3(int *op, int **lines, int num);
d56 2
a57 1
get_args(int argc, register char **argv)
d120 3
a122 1
main(int argc, char **argv)
d235 6
a240 6
separate(register int *rop, register int *gop, register int *bop, register unsigned char *cp, int num)
            	     			/* Y */
            	     			/* U */
            	     			/* V */
                      	    
   		    
d287 6
a292 1
combine(register unsigned char *cp, register int *rip, register int *gip, register int *bip, int num)
d328 3
a330 1
ripple(int **array, int num)
d350 4
a353 1
filter5(int *op, int **lines, int num)
d407 4
a410 1
filter3(int *op, int **lines, int num)
@


11.11.2.2
log
@sync branch with HEAD
@
text
@d24 1
a24 1
 *	This software is Copyright (C) 1995-2004 by the United States Army
d28 1
a28 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
@


11.10
log
@Converted from K&R to ANSI C - RFH
@
text
@d53 1
a53 1
void separate(register int *rop, register int *gop, register int *bop, register unsigned char *cp, int num), combine(register unsigned char *cp, register int *rip, register int *gip, register int *bip, int num), ripple(int **array, int num), filter5(int *op, int **lines, int num), filter3(int *op, int **lines, int num);
d56 2
a57 1
get_args(int argc, register char **argv)
d120 3
a122 1
main(int argc, char **argv)
d235 6
a240 6
separate(register int *rop, register int *gop, register int *bop, register unsigned char *cp, int num)
            	     			/* Y */
            	     			/* U */
            	     			/* V */
                      	    
   		    
d287 6
a292 1
combine(register unsigned char *cp, register int *rip, register int *gip, register int *bip, int num)
d328 3
a330 1
ripple(int **array, int num)
d350 4
a353 1
filter5(int *op, int **lines, int num)
d407 4
a410 1
filter3(int *op, int **lines, int num)
@


11.9
log
@Misc compiler warnings eliminated
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/pixhalve.c,v 11.8 2000/09/01 03:23:56 mike Exp $ (ARL)";
d53 1
a53 1
void separate(), combine(), ripple(), filter5(), filter3();
d56 1
a56 2
get_args( argc, argv )
register char **argv;
d119 1
a119 3
main( argc, argv )
int	argc;
char	**argv;
d232 6
a237 6
separate( rop, gop, bop, cp, num )
register int	*rop;			/* Y */
register int	*gop;			/* U */
register int	*bop;			/* V */
register unsigned char	*cp;
int		num;
d284 1
a284 6
combine( cp, rip, gip, bip, num )
register unsigned char	*cp;
register int		*rip;
register int		*gip;
register int		*bip;
int			num;
d320 1
a320 3
ripple( array, num )
int	*array[];
int	num;
d340 1
a340 4
filter5( op, lines, num )
int	*op;
int	*lines[];
int	num;
d394 1
a394 4
filter3( op, lines, num )
int	*op;
int	*lines[];
int	num;
@


11.8
log
@
Lint fix
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/pixhalve.c,v 11.7 2000/08/23 19:04:51 mike Exp $ (ARL)";
d36 3
d55 1
@


11.7
log
@
const RCSid
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/pixhalve.c,v 11.6 2000/01/31 16:03:09 jra Exp $ (ARL)";
d115 1
@


11.6
log
@Eliminated some unused variables
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/pixhalve.c,v 11.5 1996/12/13 15:05:51 jra Exp $ (ARL)";
@


11.5
log
@Mods to account for asize routines now in libbn.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/pixhalve.c,v 11.4 1996/07/16 22:56:03 jra Exp jra $ (ARL)";
a44 1
static int	file_height = 512;	/* default input height */
d64 1
a64 1
			file_height = file_width = 1024;
d69 1
a69 1
			file_height = file_width = atoi(optarg);
a76 1
			file_height = atoi(optarg);
a135 1
			file_height = h;
a350 1
	register int	j;
a407 1
	register int	j;
@


11.4
log
@Minor mods for IRIX 6.2
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/pixhalve.c,v 11.3 1995/12/15 05:33:52 mike Exp jra $ (ARL)";
d136 1
a136 1
		if( fb_common_file_size(&w, &h, file_name, 3) ) {
@


11.3
log
@Converted to YUV, used 3x3 filter for Y.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
d51 2
d232 1
d284 1
d325 1
d347 1
d405 1
@


11.2
log
@Changed name of main filter to filter5
@
text
@d7 4
d15 2
a16 3
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
d18 5
d24 2
a25 2
 *	This software is Copyright (C) 1990 by the United States Army.
 *	All rights reserved.
d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/pixhalve.c,v 11.1 1995/01/04 10:12:45 mike Rel4_4 mike $ (BRL)";
d185 1
a185 1
		filter5( rout, rlines, out_width );
d227 2
d231 3
a233 3
register int	*rop;
register int	*gop;
register int	*bop;
d238 1
d240 3
a242 3
	rop[-1] = rop[-2] = cp[0];
	gop[-1] = gop[-2] = cp[1];
	bop[-1] = bop[-2] = cp[2];
d244 8
d253 7
a259 3
		*rop++ = *cp++;
		*gop++ = *cp++;
		*bop++ = *cp++;
d262 3
a264 3
	*rop++ = cp[-3];
	*gop++ = cp[-2];
	*bop++ = cp[-1];
d266 7
a272 3
	*rop++ = cp[-3];
	*gop++ = cp[-2];
	*bop++ = cp[-1];
d290 6
d297 14
a310 3
		*cp++ = *rip++;
		*cp++ = *gip++;
		*cp++ = *bip++;
d385 49
@


11.1
log
@Release_4.4
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/pixhalve.c,v 10.3 94/08/23 15:05:57 gdurf Exp $ (BRL)";
d177 3
a179 3
		filter( rout, rlines, out_width );
		filter( gout, glines, out_width );
		filter( bout, blines, out_width );
d291 1
a291 1
 *			F I L T E R
d298 1
a298 1
filter( op, lines, num )
@


10.3
log
@Factored ifdefs
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/pixhalve.c,v 10.2 1992/05/07 23:38:49 mike Exp gdurf $ (BRL)";
@


10.2
log
@Fixed bug observed by Chris Johnson, where leftmost and rightmost 2 pixels
were influenced by the 2 black "guard" pixels being used.
Now, the border pixel is replicated twice, and used as the guard pixels.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/pixhalve.c,v 10.1 91/10/12 06:48:41 mike Rel4_0 Locker: mike $ (BRL)";
d23 2
a25 1
#include "externs.h"
d27 2
a28 3
extern int	getopt();
extern char	*optarg;
extern int	optind;
d313 1
a313 1
#if !defined(vax) && !defined(gould) && !defined(sun)
@


10.1
log
@Release_4.0
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/pixhalve.c,v 1.4 91/07/22 22:30:29 mike Exp $ (BRL)";
d217 2
a218 1
 *  Unpack RGB byte tripples into three separate arrays of integers
d229 4
d238 8
@


1.4
log
@Fixed bug pointed out by Chris Johnson, whereby the output file
had two less scanlines than it should have.
This was corrected by replicating the first and last line in the
input file three times each.
(Rather than just using them once).
This produced the necessary two extra scanlines
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/pixhalve.c,v 1.3 90/11/03 14:36:28 mike Exp $ (BRL)";
@


1.3
log
@Added Phil's autosize code, on -a flag
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/pixhalve.c,v 1.2 90/11/02 10:18:56 mike Exp $ (BRL)";
d116 1
d152 14
a165 2
	/* Prime the pumps with the bottom 5 lines */
	for( i=0; i<5; i++ )  {
d175 1
d188 4
a191 1
			break;
d200 4
a203 1
			break;
a209 1

@


1.2
log
@Added pointer-notation version as well,
for those machines where the subscripts will not help at all.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/pixhalve.c,v 1.1 90/11/02 09:55:03 mike Exp $ (BRL)";
a42 2
#include "./asize.c"

d104 3
d125 1
a125 1
		if( image_size(file_name, 3, &w, &h) ) {
d128 2
d195 5
d216 6
d239 4
d258 8
a296 1
		j = i*2;
@


1.1
log
@Initial revision
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d171 1
a171 1
			exit(0);
d180 1
a180 1
			exit(0);
d189 1
d255 2
d268 18
@
