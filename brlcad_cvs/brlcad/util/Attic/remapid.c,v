head	1.30;
access;
symbols
	ansi-20040405-merged:1.26.2.2
	postmerge-20040405-ansi:1.28
	premerge-20040404-ansi:1.27
	postmerge-autoconf:1.27
	autoconf-freeze:1.26.10.2
	premerge-autoconf:1.27
	postmerge-20040315-windows:1.27
	premerge-20040315-windows:1.27
	windows-20040315-freeze:1.26.4.1
	autoconf-20031203:1.26
	autoconf-20031202:1.26
	autoconf-branch:1.26.0.10
	phong-branch:1.26.0.8
	photonmap-branch:1.26.0.6
	rel-6-1-DP:1.26
	windows-branch:1.26.0.4
	rel-6-0-2:1.24
	ansi-branch:1.26.0.2
	rel-6-0-1-branch:1.24.0.2
	hartley-6-0-post:1.25
	hartley-6-0-pre:1.24
	rel-6-0-1:1.24
	rel-6-0:1.24
	rel-5-4:1.17
	offsite-5-3-pre:1.21
	rel-5-3:1.17
	rel-5-2:1.17
	rel-5-1-branch:1.17.0.2
	rel-5-1:1.17
	rel-5-0:1.12
	rel-5-0-beta:1.12
	rel-4-5:1.8;
locks; strict;
comment	@ * @;


1.30
date	2004.05.21.14.58.03;	author morrison;	state dead;
branches;
next	1.29;

1.29
date	2004.05.10.15.30.51;	author erikg;	state Exp;
branches;
next	1.28;

1.28
date	2004.04.05.05.46.02;	author morrison;	state Exp;
branches;
next	1.27;

1.27
date	2004.02.02.17.39.52;	author morrison;	state Exp;
branches;
next	1.26;

1.26
date	2002.08.20.17.09.06;	author jra;	state Exp;
branches
	1.26.2.1
	1.26.4.1
	1.26.10.1;
next	1.25;

1.25
date	2002.08.15.20.56.18;	author hartley;	state Exp;
branches;
next	1.24;

1.24
date	2001.10.17.07.40.07;	author morrison;	state Exp;
branches;
next	1.23;

1.23
date	2001.08.10.20.57.08;	author butler;	state Exp;
branches;
next	1.22;

1.22
date	2001.04.05.19.36.10;	author morrison;	state Exp;
branches;
next	1.21;

1.21
date	2000.11.02.02.20.02;	author mike;	state Exp;
branches;
next	1.20;

1.20
date	2000.10.24.14.38.57;	author mike;	state Exp;
branches;
next	1.19;

1.19
date	2000.09.08.05.57.16;	author mike;	state Exp;
branches;
next	1.18;

1.18
date	2000.08.23.19.05.10;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	2000.05.24.02.34.28;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	2000.01.31.16.03.10;	author jra;	state Exp;
branches;
next	1.15;

1.15
date	99.12.29.23.23.37;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	99.11.29.18.16.15;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	99.10.05.21.01.12;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	99.01.15.06.18.10;	author butler;	state Exp;
branches;
next	1.11;

1.11
date	98.12.30.05.03.17;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	98.06.25.07.17.25;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	98.06.16.19.49.03;	author pjt;	state Exp;
branches;
next	1.8;

1.8
date	98.01.02.14.53.53;	author jra;	state Exp;
branches;
next	1.7;

1.7
date	97.12.22.16.53.55;	author pjt;	state Exp;
branches;
next	1.6;

1.6
date	97.12.22.16.32.27;	author pjt;	state Exp;
branches;
next	1.5;

1.5
date	97.12.22.15.23.03;	author pjt;	state Exp;
branches;
next	1.4;

1.4
date	97.12.19.20.29.58;	author pjt;	state Exp;
branches;
next	1.3;

1.3
date	97.12.19.19.15.06;	author pjt;	state Exp;
branches;
next	1.2;

1.2
date	97.12.19.19.00.34;	author pjt;	state Exp;
branches;
next	1.1;

1.1
date	97.12.19.17.13.58;	author pjt;	state Exp;
branches;
next	;

1.26.2.1
date	2002.09.19.18.02.45;	author morrison;	state Exp;
branches;
next	1.26.2.2;

1.26.2.2
date	2004.03.17.21.23.37;	author morrison;	state Exp;
branches;
next	;

1.26.4.1
date	2004.03.11.23.52.36;	author morrison;	state Exp;
branches;
next	;

1.26.10.1
date	2004.02.12.19.43.12;	author erikg;	state Exp;
branches;
next	1.26.10.2;

1.26.10.2
date	2004.03.15.14.08.21;	author erikg;	state Exp;
branches;
next	;


desc
@     Perform batch modifications of region_id's for BRL-CAD geometry
@


1.30
log
@moved to src/util/
@
text
@/*
 *			R E M A P I D . C
 *
 *	Perform batch modifications of region IDs for BRL-CAD
 *	(or TANKILL) geometry
 *
 *	The program reads a .g (or TANKILL) file and a spec file
 *	indicating which region IDs to change to which new values.
 *	For a .g file, the specified changes are made to that file;
 *	For a TANKILL file, a modified model is written to stdout.
 *
 *  Author -
 *	Paul J. Tanenbaum
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1997-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/util/remapid.c,v 1.29 2004/05/10 15:30:51 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif


#include <stdio.h>
#include <ctype.h>
#include "machine.h"
#include "externs.h"			/* for getopt() */
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "db.h"
#include "raytrace.h"
#include "redblack.h"

/*
 * ******************** Hack 
 */

BU_EXTERN(struct bu_file	*bu_fopen, (char *fname, char *type) );
BU_EXTERN(int			bu_fclose, (struct bu_file *bfp) );
BU_EXTERN(int			bu_fgetc, (struct bu_file *bfp) );
BU_EXTERN(void			bu_printfile, (struct bu_file *bfp) );

/* brlcad_path.c */
BU_EXTERN(int			bu_file_exists, (const char *path) );
BU_EXTERN(char			*bu_brlcad_path, (const char *rhs) );
/*
 *	General I/O for ASCII files: bu_file support
 */
struct bu_file  {
	long		file_magic;
	FILE		*file_ptr;	/* the actual file */
	char		*file_name;
	struct bu_vls	file_buf;	/* contents of current line */
	char		*file_bp;	/* pointer into current line */
	int		file_needline;	/* time to grab another line? */
	int		file_linenm;
	int		file_comment;	/* the comment character */
	int		file_buflen;	/* length of intact buffer */
};
typedef struct bu_file		BU_FILE;
#define BU_FILE_MAGIC		0x6275666c
#define BU_CK_FILE(_fp)		BU_CKMAG(_fp, BU_FILE_MAGIC, "bu_file")

#define bu_stdin		(&bu_iob[0])
extern BU_FILE			bu_iob[1];
#define BU_FILE_NO_COMMENT	-1


/*
 *			F I L E . C
 *
 *  General I/O for ASCII files
 *
 *  Author -
 *	Paul Tanenbaum
 *
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1997-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */
static const char RCSrtstring[] = "@@(#)$Header: /n/xoff/cvs/brlcad/util/remapid.c,v 1.29 2004/05/10 15:30:51 erikg Exp $ (BRL)";

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <ctype.h>
#ifdef HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#if defined(HAVE_STDARG_H)
# include <stdarg.h>
#endif

#include "machine.h"
#include "externs.h"
#include "bu.h"

/*
 *		XXX	Warning!	XXX
 *
 *	The following initialization of bu_stdin is essentially
 *	an inline version of bu_fopen() and bu_vls_init().  As such,
 *	it depends heavily on the definitions of struct bu_file and
 *	struct bu_vls in ../h/bu.h
 *
 *		XXX			XXX
 */
char	dmy_eos = '\0';
BU_FILE	bu_iob[1] = {
    {
	BU_FILE_MAGIC,
#if 0
	stdin,		/* this won't work on Linux, others */
#else
    	NULL,
#endif
	"stdin",
	{
	    BU_VLS_MAGIC, (char *) 0, 0, 0, 0
	},
	&dmy_eos, 1, 0, '#', -1
    }
};

/*
 *			B U _ F O P E N
 *
 */
BU_FILE *bu_fopen (register char *fname, register char *type)
{
    BU_FILE	*bfp;
    FILE	*fp;

    if ((fp = fopen(fname, type)) == NULL)
	return (NULL);

    bfp = (BU_FILE *) bu_malloc(sizeof(BU_FILE), "bu_file struct");

    bfp -> file_magic = BU_FILE_MAGIC;
    bfp -> file_ptr = fp;
    bfp -> file_name = fname;
    bu_vls_init(&(bfp -> file_buf));
    bfp -> file_bp = bu_vls_addr(&(bfp -> file_buf));
    bfp -> file_needline = 1;
    bfp -> file_linenm = 0;
    bfp -> file_comment = '#';
    bfp -> file_buflen = -1;

    return (bfp);
}

/*
 *			B U _ F C L O S E
 *
 *	Close the file and free the associated memory
 */
int bu_fclose (register BU_FILE *bfp)
{
    int	close_status;

    BU_CK_FILE(bfp);

    close_status = fclose(bfp -> file_ptr);

    if (bfp != bu_stdin)
    {
	bfp -> file_magic = 0;
	bfp -> file_ptr = NULL;
	bfp -> file_name = (char *) 0;
	bfp -> file_bp = (char *) 0;
	bu_vls_free(&(bfp -> file_buf));
	bu_free((genptr_t) bfp, "bu_file struct");
    }
    return (close_status);
}

/*
 *			B U _ F G E T C
 *
 */
int bu_fgetc (register BU_FILE *bfp)
{
    char	*cp = (char *)NULL;
    int		comment_char;	/* The comment character */
    int		strip_comments;	/* Should I strip comments? */

    BU_CK_FILE(bfp);

    strip_comments = isprint(comment_char = bfp -> file_comment);

    /*
     *	If buffer is empty, note that it's time for a new line of input
     */
    if ((*(bfp -> file_bp) == '\0') && ! (bfp -> file_needline))
    {
	bfp -> file_needline = 1;
	return ('\n');
    }

    /*
     *    If it's time to grab a line of input from the file, do so.
     */
    while (bfp -> file_needline)
    {
	bu_vls_trunc(&(bfp -> file_buf), 0);
	if (bu_vls_gets(&(bfp -> file_buf), bfp -> file_ptr) == -1)
	    return (EOF);
	bfp -> file_bp = bu_vls_addr(&(bfp -> file_buf));
	++(bfp -> file_linenm);
	if (bu_vls_strlen(&(bfp -> file_buf)) == 0)
	    continue;

	if (strip_comments)
	{
	    bfp -> file_buflen = -1;
	    for (cp = bfp -> file_bp; *cp != '\0'; ++cp)
		if (*cp == comment_char)
		{
		    bfp -> file_buflen = (bfp -> file_buf).vls_len;
		    bu_vls_trunc(&(bfp -> file_buf), cp - bfp -> file_bp);
		    break;
		}
	}
	if (cp == bfp -> file_bp)
	    return ('\n');
	bfp -> file_needline = 0;
    }
    
    return (*(bfp -> file_bp)++);
}

/*
 *			B U _ P R I N T F I L E
 *
 *	Diagnostic routine to print out the contents of a struct bu_file
 */
void bu_printfile (register BU_FILE *bfp)
{
    BU_CK_FILE(bfp);

    bu_log("File     '%s'...\n", bfp -> file_name);
    bu_log("  ptr      %x\n", bfp -> file_ptr);
    bu_log("  buf      '%s'\n", bu_vls_addr(&(bfp -> file_buf)));
    bu_log("  bp       %d", bfp -> file_bp - bu_vls_addr(&(bfp -> file_buf)));
    bu_log(": '%c' (%03o)\n", *(bfp -> file_bp), *(bfp -> file_bp));
    bu_log("  needline %d\n", bfp -> file_needline);
    bu_log("  linenm   %d\n", bfp -> file_linenm);
    bu_log("  comment  '%c' (%d)\n",
	bfp -> file_comment, bfp -> file_comment);
    bu_log("  buflen   %d\n", bfp -> file_buflen);
}

/*
 *			B U _ F I L E _ E R R
 *
 *	Print out a syntax error message about a BU_FILE
 */
void bu_file_err (register BU_FILE *bfp, register char *text1, register char *text2, register int cursor_pos)
{
    char		*cp;
    int			buflen;
    int			i;
    int			stripped_length;

    BU_CK_FILE(bfp);

    /*
     *	Show any trailing comments
     */
    if ((buflen = bfp -> file_buflen) > -1)
    {
	stripped_length = (bfp -> file_buf).vls_len;
	*(bu_vls_addr(&(bfp -> file_buf)) + stripped_length) =
	    bfp -> file_comment;
	(bfp -> file_buf).vls_len = buflen;
    }
    else
	stripped_length = -1;

    /*
     *	Print out the first line of the error message
     */
    if (text1 && (*text1 != '\0'))
	bu_log("%s: ", text1);
    bu_log("Error: file %s, line %d: %s\n",
	bfp -> file_name, bfp -> file_linenm, text2);
    bu_log("%s\n", bu_vls_addr(&(bfp -> file_buf)));

    /*
     *	Print out position-indicating arrow, if requested
     */
    if ((cursor_pos >= 0)
     && (cursor_pos < bu_vls_strlen(&(bfp -> file_buf))))
    {
	cp = bu_vls_addr(&(bfp -> file_buf));
	for (i = 0; i < cursor_pos; ++i)
	    if (*cp++ == '\t')
		bu_log("\t");
	    else
		bu_log("-");
	bu_log("^\n");
    }

    /*
     *	Hide the comments again
     */
    if (stripped_length > -1)
	bu_vls_trunc(&(bfp -> file_buf), stripped_length);
}

/*
 * ******************** Hack 
 */




bu_rb_tree		*assignment;	/* Remapping assignment */
struct db_i	*dbip;		/* Instance of BRL-CAD database */

/************************************************************************
 *									*
 *			The Algorithm					*
 *									*
 *									*
 *  The remapping assignment is read from a specification file		*
 *  containing commands, the grammar for which looks something like:	*
 *									*
 *	 command --> id_list ':' id					*
 *	 id_list --> id_block | id_block ',' id_list			*
 *	id_block --> id | id '-' id					*
 *	   id    --> [0-9]+						*
 *									*
 *  The semantics of a command is:  For every region in the database	*
 *  whose region ID appears in the id_list before the ':', change its	*
 *  region ID to the value appearing after the ':'.			*
 *									*
 *  Consider all the (current) region IDs in the id_list of any		*
 *  command.  For each one, the corresponding curr_id structure is	*
 *  looked up in the red-black tree (and created, if necessary).	*
 *  As they're found, the curr_id's are stored in a list, so that	*
 *  when their new ID is found at the end of the command, it can be	*
 *  recorded in each of them.  All this processing of the specification	*
 *  file is performed by the function read_spec().			*
 *									*
 *  After the specification file has been processed, we read through	*
 *  the entire database, find every region and its (current) region ID,	*
 *  and add the region to the list of regions currently sharing that	*
 *  ID.  This is done by the function db_init().			*
 *									*
 *  At that point, it's a simple matter for main() to perform an	*
 *  inorder traversal of the red-black tree, writing to the database	*
 *  all the new region IDs.						*
 *									*
 *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *  *
 *									*
 *			The Data Structures				*
 *									*
 *  assignment points to the red-black tree of curr_id structures,	*
 *  each of which records a region ID and all the regions in the	*
 *  database that currently sport that ID, in a remap_reg structure	*
 *  per region).							*
 *									*
 *									*
 *				        +-+				*
 *	       bu_rb_tree		        | |				*
 *				        +-+				*
 *				       /   \				*
 *				   +-+/     \+-+			*
 *				   | |       | |			*
 *				   +-+       +-+			*
 *				   / \       / \			*
 *				 +-+ +-+   +-+ +-+			*
 *	  curr_id structures	 | | | |   | | | |			*
 *	  			 +-+ +-+   +-+ +-+			*
 *				  |					*
 *				  | ...					*
 *				  |					*
 *	 			+---+   +---+   +---+   +---+		*
 *	 remap_reg structures	|   |-->|   |-->|   |-->|   |--+	*
 *				+---+   +---+   +---+   +---+  |	*
 *				  ^                            |	*
 *				  |                            |	*
 *				  +----------------------------+	*
 *									*
 ************************************************************************/

struct curr_id
{
    struct bu_list	l;		
    int			ci_id;		/* The region ID */
    struct bu_list	ci_regions;	/* Regions now holding this ID */
    int			ci_newid;	/* Replacement ID for the regions */
};
#define	ci_magic	l.magic
#define	CURR_ID_NULL	((struct curr_id *) 0)
#define	CURR_ID_MAGIC	0x63726964

struct remap_reg
{
    struct bu_list		l;
    char			*rr_name;
    struct directory		*rr_dp;
    struct rt_db_internal	*rr_ip;
};
#define	rr_magic	l.magic
#define	REMAP_REG_NULL	((struct remap_reg *) 0)
#define	REMAP_REG_MAGIC	0x726d7267

static int		debug = 0;

/************************************************************************
 *									*
 *	  Helper routines for manipulating the data structures		*
 *									*
 ************************************************************************/

/*
 *			     M K _ C U R R _ I D ( )
 *
 */
struct curr_id *mk_curr_id (int region_id)
{
    struct curr_id	*cip;

    cip = (struct curr_id *) bu_malloc(sizeof(struct curr_id), "curr_id");

    cip -> ci_magic = CURR_ID_MAGIC;
    cip -> ci_id = region_id;
    BU_LIST_INIT(&(cip -> ci_regions));
    cip -> ci_newid = region_id;

    return (cip);
}

/*
 *			  P R I N T _ C U R R _ I D ( )
 *
 */
void print_curr_id (void *v, int depth)
{
    struct curr_id	*cip = (struct curr_id *) v;
    struct remap_reg	*rp;

    BU_CKMAG(cip, CURR_ID_MAGIC, "curr_id");

    bu_log(" curr_id <x%x> %d %d...\n",
	cip, cip -> ci_id, cip -> ci_newid);
    for (BU_LIST_FOR(rp, remap_reg, &(cip -> ci_regions)))
    {
	BU_CKMAG(rp, REMAP_REG_MAGIC, "remap_reg");

	bu_log("  %s\n", rp -> rr_name);
    }
}

/*
 *		P R I N T _ N O N E M P T Y _ C U R R _ I D ( )
 *
 */
void print_nonempty_curr_id (void *v, int depth)
{
    struct curr_id	*cip = (struct curr_id *) v;
    struct remap_reg	*rp;

    BU_CKMAG(cip, CURR_ID_MAGIC, "curr_id");

    if (BU_LIST_NON_EMPTY(&(cip -> ci_regions)))
    {
	bu_log(" curr_id <x%x> %d %d...\n",
	    cip, cip -> ci_id, cip -> ci_newid);
	for (BU_LIST_FOR(rp, remap_reg, &(cip -> ci_regions)))
	{
	    BU_CKMAG(rp, REMAP_REG_MAGIC, "remap_reg");

	    bu_log("  %s\n", rp -> rr_name);
	}
    }
}

/*
 *		F R E E _ C U R R _ I D ( )
 *
 */
void free_curr_id (struct curr_id *cip)
{
    BU_CKMAG(cip, CURR_ID_MAGIC, "curr_id");
    bu_free((genptr_t) cip, "curr_id");
}

/*
 *		L O O K U P _ C U R R _ I D ( )
 *
 *	Scrounge for a particular region in the red-black tree.
 *	If it's not found there, add it to the tree.  In either
 *	event, return a pointer to it.
 */
struct curr_id *lookup_curr_id(int region_id)
{
    int			rc;	/* Return code from bu_rb_insert() */
    struct curr_id	*qcip;	/* The query */
    struct curr_id	*cip;	/* Value to return */

    /*
     *	Prepare the query
     */
    qcip = mk_curr_id(region_id);

    /*
     *	Perform the query by attempting an insertion...
     *	If the query succeeds (i.e., the insertion fails!),
     *	then we have our curr_id.
     *	Otherwise, we must create a new curr_id.
     */
    switch (rc = bu_rb_insert(assignment, (void *) qcip))
    {
	case -1:
	    cip = (struct curr_id *) bu_rb_curr1(assignment);
	    free_curr_id(qcip);
	    break;
	case 0:
	    cip = qcip;
	    break;
	default:
	    bu_log("bu_rb_insert() returns %d:  This should not happen\n", rc);
	    exit (1);
    }

    return (cip);
}

/*
 *		M K _ R E M A P _ R E G ( )
 *
 */
struct remap_reg *mk_remap_reg (char *region_name)
{
    struct remap_reg	*rp;

    rp = (struct remap_reg *) bu_malloc(sizeof(struct remap_reg), "remap_reg");

    rp -> rr_magic = REMAP_REG_MAGIC;

    rp -> rr_name = (char *) bu_malloc(strlen(region_name) + 1, "region name");
    strcpy(rp -> rr_name, region_name);

    rp -> rr_dp = DIR_NULL;
    rp -> rr_ip = (struct rt_db_internal *) 0;

    return (rp);
}

/*
 *		F R E E _ R E M A P _ R E G ( )
 *
 */
void free_remap_reg (struct remap_reg *rp)
{
    BU_CKMAG(rp, REMAP_REG_MAGIC, "remap_reg");
    bu_free((genptr_t) rp -> rr_name, "region name");
    bu_free((genptr_t) rp -> rr_ip, "rt_db_internal");
    bu_free((genptr_t) rp, "remap_reg");
}

/************************************************************************
 *									*
 *	  	The comparison callback for libredblack(3)		*
 *									*
 ************************************************************************/

/*
 *		C O M P A R E _ C U R R _ I D S ( )
 */
int compare_curr_ids (void *v1, void *v2)
{
    struct curr_id	*id1 = (struct curr_id *) v1;
    struct curr_id	*id2 = (struct curr_id *) v2;

    BU_CKMAG(id1, CURR_ID_MAGIC, "curr_id");
    BU_CKMAG(id2, CURR_ID_MAGIC, "curr_id");

    return (id1 -> ci_id  -  id2 -> ci_id);
}

/************************************************************************
 *									*
 *	  Routines for reading the specification file			*
 *									*
 ************************************************************************/

/*
 *			  R E A D _ I N T ( )
 */
int read_int (BU_FILE *sfp, int *ch, int *n)

       	     
   	    
   	   		/* The result */

{
    int	got_digit = 0;	/* Did we actually succeed in reading a number? */
    int	result;

    BU_CK_FILE(sfp);

    while (isspace(*ch))
	*ch = bu_fgetc(sfp);
    
    for (result = 0; isdigit(*ch); *ch = bu_fgetc(sfp))
    {
	got_digit = 1;
	result *= 10;
	result += *ch - '0';
    }

    if (got_digit)
    {
	*n = result;
	return (1);
    }
    else if (*ch == EOF)
	bu_file_err(sfp, "remapid",
	    "Encountered EOF while expecting an integer", -1);
    else
	bu_file_err(sfp, "remapid:read_int()",
	    "Encountered nondigit",
	(int)(    (sfp -> file_bp) - bu_vls_addr(&(sfp -> file_buf)) - 1));
    return (-1);
}

/*
 *			  R E A D _ B L O C K ( )
 */
int read_block (BU_FILE *sfp, int *ch, int *n1, int *n2)
{
    BU_CK_FILE(sfp);

    if (read_int(sfp, ch, n1) != 1)
	return (-1);

    while (isspace(*ch))
	*ch = bu_fgetc(sfp);
    switch (*ch)
    {
	case ',':
	case ':':
	    return (1);
	case '-':
	    *ch = bu_fgetc(sfp);
	    if (read_int(sfp, ch, n2) != 1)
		return (-1);
	    else
		return (2);
	default:
	    bu_file_err(sfp, "remapid:read_block()",
		"Syntax error",
	(int)(	(sfp -> file_bp) - bu_vls_addr(&(sfp -> file_buf)) - 1) );
	    return (-1);
    }
}

/*
 *			  R E A D _ S P E C ( )
 */
int read_spec (BU_FILE *sfp, char *sf_name)
{
    int			ch;
    int			i;
    int			num1, num2;
    int			newid;
    struct bu_list	cids;
    struct curr_id	*cip;

    if ((sfp == NULL) && ((sfp = bu_fopen(sf_name, "r")) == NULL))
    {
	bu_log("Cannot open specification file '%s'\n", sf_name);
	exit (1);
    }
    BU_CK_FILE(sfp);

    BU_LIST_INIT(&cids);

    for ( ; ; )
    {
	/*
	 *  Read in guy(s) to be assigned a particular new regionid
	 */
	for ( ; ; )
	{
	    while (isspace(ch = bu_fgetc(sfp)))
		;
	    if (ch == EOF)
		return (1);
	    switch (read_block(sfp, &ch, &num1, &num2))
	    {
		case 1:
		    cip = lookup_curr_id(num1);
		    BU_LIST_INSERT(&cids, &(cip -> l));
		    break;
		case 2:
		    if (num1 >= num2)
		    {
			bu_file_err(sfp, "remapid:read_spec()",
			    "Range out of order",
			(int)(    (sfp -> file_bp) - bu_vls_addr(&(sfp -> file_buf))
			    - 1) );
			exit (-1);
		    }
		    for (i = num1; i <= num2; ++i)
		    {
			cip = lookup_curr_id(i);
			BU_LIST_INSERT(&cids, &(cip -> l));
		    }
		    break;
		default:
		    return (-1);
	    }
	    while (isspace(ch))
		ch = bu_fgetc(sfp);

	    switch (ch)
	    {
		case ',':
		    continue;
		case ':':
		    ch = bu_fgetc(sfp);
		    if (read_int(sfp, &ch, &newid) != 1)
			return (-1);
		    break;
		default:
		    bu_file_err(sfp, "remapid:read_spec()",
			"Syntax error",
			(int)((sfp -> file_bp) - bu_vls_addr(&(sfp -> file_buf))
			- 1) );
		    exit (-1);
	    }
	    break;
	}

	/*
	 *	Tell each of these current regionids
	 *	about it's going to get the new regionid value
	 */
	while (BU_LIST_WHILE(cip, curr_id, &cids))
	{
	    cip -> ci_newid = newid;
	    BU_LIST_DEQUEUE(&(cip -> l));
	}
    }
}

/************************************************************************
 *									*
 *	  Routines for procesing the geometry databases			*
 *									*
 ************************************************************************/

void record_region (char *region_name, int region_id, struct directory *dp, struct rt_db_internal *ip)
{
    struct curr_id	*cip;
    struct remap_reg	*rp;

    cip = lookup_curr_id(region_id);
    rp = mk_remap_reg(region_name);
    rp -> rr_dp = dp;
    rp -> rr_ip = ip;
    BU_LIST_INSERT(&(cip -> ci_regions), &(rp -> l));
}

void db_init(char *db_name)
{
    int				i;
    struct directory		*dp;
    struct rt_comb_internal	*comb;
    struct rt_db_internal	*ip;

    if ((dbip = db_open(db_name, "r+w")) == DBI_NULL)
    {
	bu_log("Cannot open database file '%s'\n", db_name);
	exit (1);
    }
    db_dirbuild(dbip);

    for (i = 0; i < RT_DBNHASH; ++i)
	for (dp = dbip -> dbi_Head[i]; dp != DIR_NULL; dp = dp -> d_forw)
	{
	    if (!(dp -> d_flags & DIR_REGION))
		continue;
	    ip = (struct rt_db_internal *)
		bu_malloc(sizeof(struct rt_db_internal), "rt_db_internal");
	    if (rt_db_get_internal(ip, dp, dbip, (fastf_t *) NULL, &rt_uniresource) < 0)
	    {
		bu_log("remapid: rt_db_get_internal(%s) failed.  ",
		    dp -> d_namep);
		bu_log("This shouldn't happen\n");
		exit (1);
	    }
	    comb = (struct rt_comb_internal *) (ip -> idb_ptr);
	    RT_CK_COMB(comb);
	    record_region(dp -> d_namep, comb -> region_id, dp, ip);
	}
}

/*
 *		W R I T E _ A S S I G N M E N T ( )
 *
 */
void write_assignment (void *v, int depth)
{
    int				region_id;
    struct curr_id		*cip = (struct curr_id *) v;
    struct remap_reg		*rp;
    struct rt_comb_internal	*comb;

    BU_CKMAG(cip, CURR_ID_MAGIC, "curr_id");

    if (BU_LIST_NON_EMPTY(&(cip -> ci_regions)))
    {
	region_id = cip -> ci_newid;
	for (BU_LIST_FOR(rp, remap_reg, &(cip -> ci_regions)))
	{
	    BU_CKMAG(rp, REMAP_REG_MAGIC, "remap_reg");
	    RT_CK_DB_INTERNAL(rp -> rr_ip);

	    comb = (struct rt_comb_internal *) rp -> rr_ip -> idb_ptr;
	    RT_CK_COMB(comb);
	    comb -> region_id = region_id;
	    if (rt_db_put_internal(rp -> rr_dp, dbip, rp -> rr_ip, &rt_uniresource) < 0)
	    {
		bu_log("remapid: rt_db_put_internal(%s) failed.  ",
		    rp -> rr_dp -> d_namep);
		bu_log("This shouldn't happen\n");
		exit (1);
	    }
	}
    }
}

static void
tankill_reassign(char *db_name)
{
	FILE *fd_in;
	int vertex_count, id, surr_code;
	struct curr_id *id_map, *cip;

	/* open TANKILL model */
	if( (fd_in=fopen( db_name, "r" )) == NULL )
	{
		bu_log( "Cannot open TANKILL database (%s)\n", db_name );
		perror( "remapid" );
		bu_bomb( "Cannot open TANKILL database\n" );
	}

	/* make a 'curr_id' structure to feed to bu_rb_search */
	cip = mk_curr_id( 0 );

	/* filter TANKILL model, changing ids as we go */
	while( fscanf( fd_in, "%d %d %d", &vertex_count, &id, &surr_code ) != EOF )
	{
		int coord_no=0;
		int in_space=1;
		int ch;

		cip->ci_id = id;
		id_map = (struct curr_id *)bu_rb_search( assignment, 0, (void *)cip );
		if( !id_map )
			printf( "%d %d %d", vertex_count, id, surr_code );
		else
			printf( "%d %d %d", vertex_count, id_map->ci_newid, surr_code );

		/* just copy the rest of the component */
		while( coord_no < 3*vertex_count || !in_space )
		{
			ch = fgetc( fd_in );
			if( ch == EOF && coord_no < 3*vertex_count )
			{
				bu_log( "Unexpected EOF while processing ident %d\n", id );
				bu_bomb( "Unexpected EOF\n" );
			}

			if( isspace( ch ) )
				in_space = 1;
			else if( in_space )
			{
				in_space = 0;
				coord_no++;
			}
			putchar( ch );
		}
	}
}

/************************************************************************
 *									*
 *	  	And finally... the main program				*
 *									*
 ************************************************************************/

/*
 *			   P R I N T _ U S A G E ( )
 */
void print_usage (void)
{
#define OPT_STRING	"gt?"

    bu_log("Usage: 'remapid [-{g|t}] {file.g|file.tankill} [spec_file]'\n\
	%sNote: The '-g' option modifies file.g in place\n\
	%sthe '-t' option writes a modified file.tankill to stdout\n",
	"  ", "        ");
}

/*
 *                                M A I N ( )
 */
int
main (int argc, char **argv)
{
    char		*db_name;	/* Name of database */
    char		*sf_name = NULL;	/* Name of spec file */
    BU_FILE		*sfp = NULL;	/* Spec file */
    int			ch;		/* Command-line character */
    int			tankill = 0;	/* TANKILL format (vs. BRL-CAD)? */

    extern int	optind;			/* index from getopt(3C) */

    bu_stdin->file_ptr = stdin;		/* LINUX-required init */

    while ((ch = getopt(argc, argv, OPT_STRING)) != EOF)
	switch (ch)
	{
	    case 'g':
		tankill = 0;
		break;
	    case 't':
		tankill = 1;
		break;
	    case '?':
	    default:
		print_usage();
		exit (ch != '?');
		return(0);
	}

    switch (argc - optind)
    {
	case 1:
	    sf_name = "stdin";
	    sfp = bu_stdin;
	    /* Break intentionally missing */
	case 2:
	    break;
	default:
	    print_usage();
	    exit (1);
    }

	rt_init_resource( &rt_uniresource, 0, NULL );

    /*
     *	Open database and specification file, as necessary
     */
    db_name = argv[optind++];
    if (sfp == NULL)
	sf_name = argv[optind];

    /*
     *	Initialize the assignment
     */
    assignment = bu_rb_create1("Remapping assignment", compare_curr_ids);
    bu_rb_uniq_on1(assignment);

    /*
     *	Read in the specification for the reassignment
     */
    read_spec (sfp, sf_name);

    /*
     *	Make the specified reassignment
     */
    if( tankill )
	tankill_reassign( db_name );
    else
    {
	db_init(db_name);

	if (debug)
	    bu_rb_walk1(assignment, print_nonempty_curr_id, INORDER);
	else
	    bu_rb_walk1(assignment, write_assignment, INORDER);
    }
    return 0;
}
@


1.29
log
@change conf.h to a wrapped config.h
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/util/remapid.c,v 1.28 2004/04/05 05:46:02 morrison Exp $ (ARL)";
d104 1
a104 1
static const char RCSrtstring[] = "@@(#)$Header: /cvs/brlcad/util/remapid.c,v 1.28 2004/04/05 05:46:02 morrison Exp $ (BRL)";
@


1.28
log
@merge of ansi-6-0-branch into head
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d32 5
a36 1
#include "conf.h"
d104 6
a109 1
static const char RCSrtstring[] = "@@(#)$Header$ (BRL)";
a110 1
#include "conf.h"
@


1.27
log
@update copyright to include span through 2003
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/remapid.c,v 1.26 2002/08/20 17:09:06 jra Exp $ (ARL)";
d100 1
a100 1
static const char RCSrtstring[] = "@@(#)$Header: /c/CVS/brlcad/util/remapid.c,v 1.26 2002/08/20 17:09:06 jra Exp $ (BRL)";
d150 1
a150 5
BU_FILE *bu_fopen (fname, type)

register char	*fname;
register char	*type;

d178 1
a178 4
int bu_fclose (bfp)

register BU_FILE	*bfp;

d202 1
a202 4
int bu_fgetc (bfp)

register BU_FILE	*bfp;

d258 1
a258 4
void bu_printfile (bfp)

register BU_FILE	*bfp;

d279 1
a279 6
void bu_file_err (bfp, text1, text2, cursor_pos)

register BU_FILE	*bfp;
register char		*text1, *text2;
register int		cursor_pos;

d443 1
a443 4
struct curr_id *mk_curr_id (region_id)

int	region_id;

d461 1
a461 5
void print_curr_id (v, depth)

void	*v;
int	depth;

d482 1
a482 5
void print_nonempty_curr_id (v, depth)

void	*v;
int	depth;

d506 1
a506 4
void free_curr_id (cip)

struct curr_id	*cip;

d519 1
a519 4
struct curr_id *lookup_curr_id(region_id)

int	region_id;

d557 1
a557 4
struct remap_reg *mk_remap_reg (region_name)

char	*region_name;

d578 1
a578 4
void free_remap_reg (rp)

struct remap_reg	*rp;

d595 1
a595 5
int compare_curr_ids (v1, v2)

void	*v1;
void	*v2;

d615 1
a615 1
int read_int (sfp, ch, n)
d617 3
a619 3
BU_FILE	*sfp;
int	*ch;
int	*n;		/* The result */
d655 1
a655 6
int read_block (sfp, ch, n1, n2)

BU_FILE	*sfp;
int	*ch;
int	*n1, *n2;

d686 1
a686 5
int read_spec (sfp, sf_name)

BU_FILE	*sfp;
char	*sf_name;

d779 1
a779 7
void record_region (region_name, region_id, dp, ip)

char			*region_name;
int			region_id;
struct directory	*dp;
struct rt_db_internal	*ip;

d791 1
a791 4
void db_init(db_name)

char	*db_name;

d829 1
a829 5
void write_assignment (v, depth)

void	*v;
int	depth;

d861 1
a861 2
tankill_reassign( db_name )
char *db_name;
d923 1
a923 1
void print_usage ()
d937 1
a937 5
main (argc, argv)

int	argc;
char	*argv[];

@


1.26
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d25 1
a25 1
 *	This software is Copyright (C) 1997 by the United States Army
d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/remapid.c,v 1.24 2001/10/17 07:40:07 morrison Exp $ (ARL)";
d97 1
a97 1
 *	This software is Copyright (C) 1997 by the United States Army
d100 1
a100 1
static const char RCSrtstring[] = "@@(#)$Header: /c/CVS/brlcad/util/remapid.c,v 1.24 2001/10/17 07:40:07 morrison Exp $ (BRL)";
@


1.26.4.1
log
@sync to HEAD...
@
text
@d25 1
a25 1
 *	This software is Copyright (C) 1997-2004 by the United States Army
d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/util/remapid.c,v 1.27 2004/02/02 17:39:52 morrison Exp $ (ARL)";
d97 1
a97 1
 *	This software is Copyright (C) 1997-2004 by the United States Army
d100 1
a100 1
static const char RCSrtstring[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/util/remapid.c,v 1.27 2004/02/02 17:39:52 morrison Exp $ (BRL)";
@


1.26.10.1
log
@merge from HEAD
@
text
@d25 1
a25 1
 *	This software is Copyright (C) 1997-2004 by the United States Army
d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/remapid.c,v 1.27 2004/02/02 17:39:52 morrison Exp $ (ARL)";
d97 1
a97 1
 *	This software is Copyright (C) 1997-2004 by the United States Army
d100 1
a100 1
static const char RCSrtstring[] = "@@(#)$Header: /c/CVS/brlcad/util/remapid.c,v 1.27 2004/02/02 17:39:52 morrison Exp $ (BRL)";
@


1.26.10.2
log
@merge from head
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/remapid.c,v 1.26.10.1 2004/02/12 19:43:12 erikg Exp $ (ARL)";
d100 1
a100 1
static const char RCSrtstring[] = "@@(#)$Header: /c/CVS/brlcad/util/remapid.c,v 1.26.10.1 2004/02/12 19:43:12 erikg Exp $ (BRL)";
@


1.26.2.1
log
@Initial ANSIfication
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/remapid.c,v 1.26 2002/08/20 17:09:06 jra Exp $ (ARL)";
d100 1
a100 1
static const char RCSrtstring[] = "@@(#)$Header: /c/CVS/brlcad/util/remapid.c,v 1.26 2002/08/20 17:09:06 jra Exp $ (BRL)";
d150 5
a154 1
BU_FILE *bu_fopen (register char *fname, register char *type)
d182 4
a185 1
int bu_fclose (register BU_FILE *bfp)
d209 4
a212 1
int bu_fgetc (register BU_FILE *bfp)
d268 4
a271 1
void bu_printfile (register BU_FILE *bfp)
d292 6
a297 1
void bu_file_err (register BU_FILE *bfp, register char *text1, register char *text2, register int cursor_pos)
d461 4
a464 1
struct curr_id *mk_curr_id (int region_id)
d482 5
a486 1
void print_curr_id (void *v, int depth)
d507 5
a511 1
void print_nonempty_curr_id (void *v, int depth)
d535 4
a538 1
void free_curr_id (struct curr_id *cip)
d551 4
a554 1
struct curr_id *lookup_curr_id(int region_id)
d592 4
a595 1
struct remap_reg *mk_remap_reg (char *region_name)
d616 4
a619 1
void free_remap_reg (struct remap_reg *rp)
d636 5
a640 1
int compare_curr_ids (void *v1, void *v2)
d660 1
a660 1
int read_int (BU_FILE *sfp, int *ch, int *n)
d662 3
a664 3
       	     
   	    
   	   		/* The result */
d700 6
a705 1
int read_block (BU_FILE *sfp, int *ch, int *n1, int *n2)
d736 5
a740 1
int read_spec (BU_FILE *sfp, char *sf_name)
d833 7
a839 1
void record_region (char *region_name, int region_id, struct directory *dp, struct rt_db_internal *ip)
d851 4
a854 1
void db_init(char *db_name)
d892 5
a896 1
void write_assignment (void *v, int depth)
d928 2
a929 1
tankill_reassign(char *db_name)
d991 1
a991 1
void print_usage (void)
d1005 5
a1009 1
main (int argc, char **argv)
@


1.26.2.2
log
@sync branch with HEAD
@
text
@d25 1
a25 1
 *	This software is Copyright (C) 1997-2004 by the United States Army
d29 1
a29 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d97 1
a97 1
 *	This software is Copyright (C) 1997-2004 by the United States Army
d100 1
a100 1
static const char RCSrtstring[] = "@@(#)$Header$ (BRL)";
@


1.25
log
@Converted from K&R to ANSI C - RFH
@
text
@d150 5
a154 1
BU_FILE *bu_fopen (register char *fname, register char *type)
d182 4
a185 1
int bu_fclose (register BU_FILE *bfp)
d209 4
a212 1
int bu_fgetc (register BU_FILE *bfp)
d268 4
a271 1
void bu_printfile (register BU_FILE *bfp)
d292 6
a297 1
void bu_file_err (register BU_FILE *bfp, register char *text1, register char *text2, register int cursor_pos)
d461 4
a464 1
struct curr_id *mk_curr_id (int region_id)
d482 5
a486 1
void print_curr_id (void *v, int depth)
d507 5
a511 1
void print_nonempty_curr_id (void *v, int depth)
d535 4
a538 1
void free_curr_id (struct curr_id *cip)
d551 4
a554 1
struct curr_id *lookup_curr_id(int region_id)
d592 4
a595 1
struct remap_reg *mk_remap_reg (char *region_name)
d616 4
a619 1
void free_remap_reg (struct remap_reg *rp)
d636 5
a640 1
int compare_curr_ids (void *v1, void *v2)
d660 1
a660 1
int read_int (BU_FILE *sfp, int *ch, int *n)
d662 3
a664 3
       	     
   	    
   	   		/* The result */
d700 6
a705 1
int read_block (BU_FILE *sfp, int *ch, int *n1, int *n2)
d736 5
a740 1
int read_spec (BU_FILE *sfp, char *sf_name)
d833 7
a839 1
void record_region (char *region_name, int region_id, struct directory *dp, struct rt_db_internal *ip)
d851 4
a854 1
void db_init(char *db_name)
d892 5
a896 1
void write_assignment (void *v, int depth)
d928 2
a929 1
tankill_reassign(char *db_name)
d991 1
a991 1
void print_usage (void)
d1005 5
a1009 1
main (int argc, char **argv)
@


1.24
log
@Mac OS X warning and error fixes for non-production build
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/remapid.c,v 1.23 2001/08/10 20:57:08 butler Exp $ (ARL)";
d100 1
a100 1
static const char RCSrtstring[] = "@@(#)$Header: /c/CVS/brlcad/util/remapid.c,v 1.23 2001/08/10 20:57:08 butler Exp $ (BRL)";
d150 1
a150 5
BU_FILE *bu_fopen (fname, type)

register char	*fname;
register char	*type;

d178 1
a178 4
int bu_fclose (bfp)

register BU_FILE	*bfp;

d202 1
a202 4
int bu_fgetc (bfp)

register BU_FILE	*bfp;

d258 1
a258 4
void bu_printfile (bfp)

register BU_FILE	*bfp;

d279 1
a279 6
void bu_file_err (bfp, text1, text2, cursor_pos)

register BU_FILE	*bfp;
register char		*text1, *text2;
register int		cursor_pos;

d443 1
a443 4
struct curr_id *mk_curr_id (region_id)

int	region_id;

d461 1
a461 5
void print_curr_id (v, depth)

void	*v;
int	depth;

d482 1
a482 5
void print_nonempty_curr_id (v, depth)

void	*v;
int	depth;

d506 1
a506 4
void free_curr_id (cip)

struct curr_id	*cip;

d519 1
a519 4
struct curr_id *lookup_curr_id(region_id)

int	region_id;

d557 1
a557 4
struct remap_reg *mk_remap_reg (region_name)

char	*region_name;

d578 1
a578 4
void free_remap_reg (rp)

struct remap_reg	*rp;

d595 1
a595 5
int compare_curr_ids (v1, v2)

void	*v1;
void	*v2;

d615 1
a615 1
int read_int (sfp, ch, n)
d617 3
a619 3
BU_FILE	*sfp;
int	*ch;
int	*n;		/* The result */
d655 1
a655 6
int read_block (sfp, ch, n1, n2)

BU_FILE	*sfp;
int	*ch;
int	*n1, *n2;

d686 1
a686 5
int read_spec (sfp, sf_name)

BU_FILE	*sfp;
char	*sf_name;

d779 1
a779 7
void record_region (region_name, region_id, dp, ip)

char			*region_name;
int			region_id;
struct directory	*dp;
struct rt_db_internal	*ip;

d791 1
a791 4
void db_init(db_name)

char	*db_name;

d829 1
a829 5
void write_assignment (v, depth)

void	*v;
int	depth;

d861 1
a861 2
tankill_reassign( db_name )
char *db_name;
d923 1
a923 1
void print_usage ()
d937 1
a937 5
main (argc, argv)

int	argc;
char	*argv[];

@


1.23
log
@Misc compiler warnings eliminated
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/remapid.c,v 1.22 2001/04/05 19:36:10 morrison Exp $ (ARL)";
d100 1
a100 1
static const char RCSrtstring[] = "@@(#)$Header: /c/CVS/brlcad/util/remapid.c,v 1.22 2001/04/05 19:36:10 morrison Exp $ (BRL)";
a1017 1
    extern char	*optarg;		/* argument from getopt(3C) */
@


1.22
log
@updated SIGNED to signed
updated CONST to const
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/remapid.c,v 1.21 2000/11/02 02:20:02 mike Exp $ (ARL)";
d100 1
a100 1
static const char RCSrtstring[] = "@@(#)$Header: /c/CVS/brlcad/util/remapid.c,v 1.21 2000/11/02 02:20:02 mike Exp $ (BRL)";
d106 1
a106 1
#ifdef USE_STRING_H
d214 1
a214 1
    char	*cp;
d1012 1
a1012 1
    char		*sf_name;	/* Name of spec file */
@


1.21
log
@
db_dirbuild() handles v5
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/remapid.c,v 1.20 2000/10/24 14:38:57 mike Exp $ (ARL)";
d54 2
a55 2
BU_EXTERN(int			bu_file_exists, (CONST char *path) );
BU_EXTERN(char			*bu_brlcad_path, (CONST char *rhs) );
d100 1
a100 1
static const char RCSrtstring[] = "@@(#)$Header: /c/CVS/brlcad/util/remapid.c,v 1.20 2000/10/24 14:38:57 mike Exp $ (BRL)";
@


1.20
log
@
lint
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/remapid.c,v 1.19 2000/09/08 05:57:16 mike Exp $ (ARL)";
d100 1
a100 1
static const char RCSrtstring[] = "@@(#)$Header: /c/CVS/brlcad/util/remapid.c,v 1.19 2000/09/08 05:57:16 mike Exp $ (BRL)";
d866 1
a866 1
    db_scan(dbip, (int (*)()) db_diradd, 1, NULL);
@


1.19
log
@
Tree routines need resource pointer
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/remapid.c,v 1.18 2000/08/23 19:05:10 mike Exp $ (ARL)";
d100 1
a100 1
static const char RCSrtstring[] = "@@(#)$Header: /c/CVS/brlcad/util/remapid.c,v 1.18 2000/08/23 19:05:10 mike Exp $ (BRL)";
d1004 1
d1085 1
@


1.18
log
@
const RCSid
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/remapid.c,v 1.17 2000/05/24 02:34:28 mike Exp $ (ARL)";
d100 1
a100 1
static const char RCSrtstring[] = "@@(#)$Header: /c/CVS/brlcad/util/remapid.c,v 1.17 2000/05/24 02:34:28 mike Exp $ (BRL)";
d875 1
a875 1
	    if (rt_db_get_internal(ip, dp, dbip, (fastf_t *) NULL) < 0)
d916 1
a916 1
	    if (rt_db_put_internal(rp -> rr_dp, dbip, rp -> rr_ip) < 0)
d1049 2
@


1.17
log
@
Linux fix.
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/remapid.c,v 1.16 2000/01/31 16:03:10 jra Exp $ (ARL)";
d100 1
a100 1
static char RCSrtstring[] = "@@(#)$Header: /c/CVS/brlcad/util/remapid.c,v 1.16 2000/01/31 16:03:10 jra Exp $ (BRL)";
@


1.16
log
@Eliminated some unused variables
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/remapid.c,v 1.15 1999/12/29 23:23:37 mike Exp $ (ARL)";
d100 1
a100 1
static char RCSrtstring[] = "@@(#)$Header: /c/CVS/brlcad/util/remapid.c,v 1.15 1999/12/29 23:23:37 mike Exp $ (BRL)";
d133 2
a134 2
#if defined(stdin)
	stdin,
@


1.15
log
@
db_scan() got a client_data argument, which
db_diradd() needed to learn to ignore.
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/remapid.c,v 1.14 1999/11/29 18:16:15 mike Exp $ (ARL)";
d100 1
a100 1
static char RCSrtstring[] = "@@(#)$Header: /c/CVS/brlcad/util/remapid.c,v 1.14 1999/11/29 18:16:15 mike Exp $ (BRL)";
a1013 1
    int			i;
@


1.14
log
@
lint
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/remapid.c,v 1.13 1999/10/05 21:01:12 mike Exp $ (ARL)";
d100 1
a100 1
static char RCSrtstring[] = "@@(#)$Header: /c/CVS/brlcad/util/remapid.c,v 1.13 1999/10/05 21:01:12 mike Exp $ (BRL)";
d866 1
a866 1
    db_scan(dbip, (int (*)()) db_diradd, 1);
@


1.13
log
@
LINUX-inspired fix
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/remapid.c,v 1.12 1999/01/15 06:18:10 butler Exp $ (ARL)";
d100 1
a100 1
static char RCSrtstring[] = "@@(#)$Header: /c/CVS/brlcad/util/remapid.c,v 1.12 1999/01/15 06:18:10 butler Exp $ (BRL)";
d875 1
a875 1
	    if (rt_db_get_internal(ip, dp, dbip, (mat_t *) NULL) < 0)
@


1.12
log
@depricated BU_FILE support moved from libbu to this file since it's the only
thing that will ever use it.
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/remapid.c,v 1.11 1998/12/30 05:03:17 mike Exp $ (ARL)";
d100 1
a100 1
static char RCSrtstring[] = "@@(#)$Header: /c/CVS/brlcad/libbu/Attic/file.c,v 1.5 1999/01/12 15:58:02 pjt dead $ (BRL)";
d132 7
a138 1
	BU_FILE_MAGIC, stdin, "stdin",
d1019 2
@


1.11
log
@LibRedBlack is now in LIBBU
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/remapid.c,v 1.10 1998/06/25 07:17:25 mike Exp $ (ARL)";
d44 307
d687 1
a687 1
	    (sfp -> file_bp) - bu_vls_addr(&(sfp -> file_buf)) - 1);
d722 1
a722 1
		(sfp -> file_bp) - bu_vls_addr(&(sfp -> file_buf)) - 1);
d774 2
a775 2
			    (sfp -> file_bp) - bu_vls_addr(&(sfp -> file_buf))
			    - 1);
d802 2
a803 2
			(sfp -> file_bp) - bu_vls_addr(&(sfp -> file_buf))
			- 1);
@


1.10
log
@Mods for compiling on sun4
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/remapid.c,v 1.9 1998/06/16 19:49:03 pjt Exp $ (ARL)";
d44 1
a44 1
rb_tree		*assignment;	/* Remapping assignment */
d92 1
a92 1
 *	       rb_tree		        | |				*
d243 1
a243 1
    int			rc;	/* Return code from rb_insert() */
d258 1
a258 1
    switch (rc = rb_insert(assignment, (void *) qcip))
d261 1
a261 1
	    cip = (struct curr_id *) rb_curr1(assignment);
d268 1
a268 1
	    bu_log("rb_insert() returns %d:  This should not happen\n", rc);
d630 1
a630 1
	/* make a 'curr_id' structure to feed to rb_search */
d641 1
a641 1
		id_map = (struct curr_id *)rb_search( assignment, 0, (void *)cip );
d746 2
a747 2
    assignment = rb_create1("Remapping assignment", compare_curr_ids);
    rb_uniq_on1(assignment);
d764 1
a764 1
	    rb_walk1(assignment, print_nonempty_curr_id, INORDER);
d766 1
a766 1
	    rb_walk1(assignment, write_assignment, INORDER);
@


1.9
log
@Mostly cosmetic changes
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/remapid.c,v 1.8 1998/01/02 14:53:53 jra Exp $ (ARL)";
d678 1
a678 1
void print_usage (void)
@


1.8
log
@Added tankill option
@
text
@d4 2
a5 1
 *	Perform batch modifications of region IDs for BRL-CAD geometry
d7 4
a10 3
 *	The program reads a .g file and a spec file indicating which
 *	region IDs to change to which new values.  It makes the
 *	specified changes in the .g file.
d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/remapid.c,v 1.7 1997/12/22 16:53:55 pjt Exp jra $ (ARL)";
d682 4
a685 2
    bu_log("Usage: 'remapid [-{g|t}] [file.g|file.tankill] [spec_file]'\n\
	Note that the '-t' option sends the modified TANKILL model to stdout\n");
d754 3
d764 1
a764 1
		rb_walk1(assignment, print_nonempty_curr_id, INORDER);
d766 1
a766 1
		rb_walk1(assignment, write_assignment, INORDER);
@


1.7
log
@Added the -g option
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/remapid.c,v 1.6 1997/12/22 16:32:27 pjt Exp $ (ARL)";
d32 1
d514 1
a514 1
 *	  Routines for procesing the geometry database			*
d612 55
d680 2
a681 1
    bu_log("Usage: 'remapid [-{g|t}] file.g [spec_file]'\n");
a718 7
    if (tankill)
    {
	bu_log("Sorry, the TANKILL option is not yet implemented\n");
	print_usage();
	exit (1);
    }

d750 5
a754 1
    db_init(db_name);
d756 5
a760 4
    if (debug)
	rb_walk1(assignment, print_nonempty_curr_id, INORDER);
    else
	rb_walk1(assignment, write_assignment, INORDER);
@


1.6
log
@db_init() now mallocs memory for the struct rt_db_internal for each
region in the database
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/remapid.c,v 1.5 1997/12/22 15:23:03 pjt Exp pjt $ (ARL)";
d41 1
a41 1
rb_tree		*assignment;	/* Relabeling assignment */
d622 1
a622 1
#define OPT_STRING	"t?"
d624 1
a624 1
    bu_log("Usage: 'remapid [-t] file.g [spec_file]'\n");
d649 3
d662 7
d692 1
a692 1
    assignment = rb_create1("Relabeling assignment", compare_curr_ids);
@


1.5
log
@Rearranged some and added comments
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/remapid.c,v 1.4 1997/12/19 20:29:58 pjt Exp pjt $ (ARL)";
d307 1
d543 1
a543 1
    struct rt_db_internal	intern;
a544 2
    bu_log("db_init(%s)...\n", db_name);

d557 3
a559 1
	    if (rt_db_get_internal(&intern, dp, dbip, (mat_t *) NULL) < 0)
d566 1
a566 1
	    comb = (struct rt_comb_internal *) intern.idb_ptr;
d568 1
a568 1
	    record_region(dp -> d_namep, comb -> region_id, dp, &intern);
a591 2
	bu_log(" curr_id <x%x> %d %d...\n",
	    cip, cip -> ci_id, region_id);
d595 1
@


1.4
log
@. Implemented db_init() and write_assignment()
2. Added members rr_dp and rr_ip to struct remap_reg
3. Implemented print_nonempty_curr_id()
@
text
@d4 1
a4 1
 *	Perform batch modifications of region_id's for BRL-CAD geometry
d7 1
a7 1
 *	region_id's to change to which new values.  It makes the
d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/remapid.c,v 1.2 1997/12/19 19:00:34 pjt Exp pjt $ (ARL)";
a43 1

d46 31
a76 1
 *			The data structures				*
d78 31
d110 1
d113 4
a116 4
    struct bu_list	l;
    int			ci_id;
    struct bu_list	ci_regions;
    int			ci_newid;
d229 44
d310 6
a317 2
 *
 *	    The comparison callback for libredblack(3)
d336 1
a336 47
 *	  	Routines for manipulating the assignment		*
 *									*
 ************************************************************************/

/*
 *		L O O K U P _ C U R R _ I D ( )
 */
struct curr_id *lookup_curr_id(region_id)

int	region_id;

{
    int			rc;	/* Return code from rb_insert() */
    struct curr_id	*qcip;	/* The query */
    struct curr_id	*cip;	/* Value to return */

    /*
     *	Prepare the query
     */
    qcip = mk_curr_id(region_id);

    /*
     *	Perform the query by attempting an insertion...
     *	If the query succeeds (i.e., the insertion fails!),
     *	then we have our curr_id.
     *	Otherwise, we must create a new curr_id.
     */
    switch (rc = rb_insert(assignment, (void *) qcip))
    {
	case -1:
	    cip = (struct curr_id *) rb_curr1(assignment);
	    free_curr_id(qcip);
	    break;
	case 0:
	    cip = qcip;
	    break;
	default:
	    bu_log("rb_insert() returns %d:  This should not happen\n", rc);
	    exit (1);
    }

    return (cip);
}

/************************************************************************
 *									*
 *	  More or less vanilla-flavored stuff				*
d381 1
a381 1
 *			  R E A D _ R A N G E ( )
d383 1
a383 1
int read_range (sfp, ch, n1, n2)
d409 1
a409 1
	    bu_file_err(sfp, "remapid:read_range()",
d452 1
a452 1
	    switch (read_range(sfp, &ch, &num1, &num2))
d510 6
d611 5
a688 8

#if 0
    record_region("USA", 1776);
    record_region("Will", 7);
    record_region("Griff", 8);
    record_region("Jake", 11);
    record_region("Chad", 11);
#endif
@


1.3
log
@Implemented record_region()
@
text
@d35 4
d42 1
d44 1
d63 4
a66 2
    struct bu_list	l;
    char		*rr_name;
d72 1
a72 1
static int		debug = 1;
d127 28
d182 1
a182 1
    rp -> rr_name = (char *) bu_malloc(strlen(region_name), "region name");
d185 3
d402 1
d430 1
a430 1
		    break;
d447 1
a447 1
void record_region (region_name, region_id)
d449 4
a452 2
char	*region_name;
int	region_id;
d460 2
d465 78
d616 1
a616 3
    if (debug)
	rb_walk1(assignment, print_curr_id, INORDER);

d622 1
d624 2
d627 3
a629 4
    {
	bu_log(" . . . . . . . . . . .. .\n");
	rb_walk1(assignment, print_curr_id, INORDER);
    }
@


1.2
log
@1. Now successfully read and process the spec file
2. Ripped out lotsa cruft leftover from mst.c (was scavenged)
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/remapid.c,v 1.1 1997/12/19 17:13:58 pjt Exp pjt $ (ARL)";
a203 1
    bu_log("Looking up %d\n", region_id);
d395 4
a398 1
	bu_log("The guys to get mapped to %d\n", newid);
a401 1
	    print_curr_id(cip, 1);
a403 1
	bu_log("-------------------------\n");
d407 14
d496 12
@


1.1
log
@Initial revision
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/mst.c,v 1.6 1997/02/28 20:20:40 pjt Exp $ (ARL)";
d37 2
d44 1
a44 1
struct vertex
d46 4
a49 17
    long		v_magic;
    long		v_index;
    char		*v_label;
    int			v_civilized;
    struct bu_list	v_neighbors;
    struct bridge	*v_bridge;
};
#define	VERTEX_NULL	((struct vertex *) 0)
#define	VERTEX_MAGIC	0x6d737476

struct bridge
{
    long		b_magic;
    unsigned long	b_index;	/* automatically generated (unique) */
    double		b_weight;
    struct vertex	*b_vert_civ;
    struct vertex	*b_vert_unciv;
d51 3
a53 6
#define	BRIDGE_NULL	((struct bridge *) 0)
#define	BRIDGE_MAGIC	0x6d737462

static rb_tree		*prioq;		/* Priority queue of bridges */
#define	PRIOQ_INDEX	0
#define	PRIOQ_WEIGHT	1
d55 1
a55 1
struct neighbor
d58 1
a58 2
    struct vertex	*n_vertex;
    double		n_weight;
d60 3
a62 3
#define	n_magic		l.magic
#define	NEIGHBOR_NULL	((struct neighbor *) 0)
#define	NEIGHBOR_MAGIC	0x6d73746e
d73 1
a73 77
 *			     M K _ B R I D G E ( )
 *
 */
struct bridge *mk_bridge (vcp, vup, weight)

struct vertex	*vcp;
struct vertex	*vup;
double		weight;

{
    static unsigned long	next_index = 0;
    struct bridge		*bp;

    /*
     *	XXX Hope that unsigned long is sufficient to ensure
     *	uniqueness of bridge indices.
     */

    BU_CKMAG(vup, VERTEX_MAGIC, "vertex");

    bp = (struct bridge *) bu_malloc(sizeof(struct bridge), "bridge");

    bp -> b_magic = BRIDGE_MAGIC;
    bp -> b_index = ++next_index;
    bp -> b_weight = weight;
    bp -> b_vert_civ = vcp;
    bp -> b_vert_unciv = vup;

    return (bp);
}
#define	mk_init_bridge(vp)	(mk_bridge(VERTEX_NULL, (vp), 0.0))
#define	is_finite_bridge(bp)	((bp) -> b_vert_civ != VERTEX_NULL)
#define	is_infinite_bridge(bp)	((bp) -> b_vert_civ == VERTEX_NULL)

/*
 *			   F R E E _ B R I D G E ( )
 *
 *	N.B. - It is up to the calling routine to free
 *		the b_vert_civ and b_vert_unciv members of bp.
 */
void free_bridge (bp)

struct bridge	*bp;

{
    BU_CKMAG(bp, BRIDGE_MAGIC, "bridge");
    bu_free((genptr_t) bp, "bridge");
}

/*
 *			  P R I N T _ B R I D G E ( )
 *
 */
void print_bridge (bp)

struct bridge	*bp;

{
    BU_CKMAG(bp, BRIDGE_MAGIC, "bridge");

    bu_log(" bridge <x%x> %d... <x%x> and <x%x>, weight = %g\n",
	bp, bp -> b_index,
	bp -> b_vert_civ, bp -> b_vert_unciv, bp -> b_weight);
}

/*
 *			   P R I N T _ P R I O Q ( )
 */
#define	print_prioq()						\
{								\
    bu_log("----- The priority queue -----\n");			\
    rb_walk(prioq, PRIOQ_WEIGHT, print_bridge, INORDER);	\
    bu_log("------------------------------\n\n");		\
}

/*
 *			     M K _ V E R T E X ( )
d76 1
a76 1
struct vertex *mk_vertex (index, label)
d78 1
a78 2
long	index;
char	*label;
d81 1
a81 1
    struct vertex	*vp;
d83 1
a83 1
    vp = (struct vertex *) bu_malloc(sizeof(struct vertex), "vertex");
d85 4
a88 6
    vp -> v_magic = VERTEX_MAGIC;
    vp -> v_index = index;
    vp -> v_label = label;
    vp -> v_civilized = 0;
    BU_LIST_INIT(&(vp -> v_neighbors));
    vp -> v_bridge = mk_init_bridge(vp);
d90 1
a90 1
    return (vp);
d94 1
a94 1
 *			  P R I N T _ V E R T E X ( )
d97 1
a97 1
void print_vertex (v, depth)
d103 2
a104 2
    struct vertex	*vp = (struct vertex *) v;
    struct neighbor	*np;
d106 1
a106 1
    BU_CKMAG(vp, VERTEX_MAGIC, "vertex");
d108 3
a110 4
    bu_log(" vertex <x%x> %d '%s' %s...\n",
	vp, vp -> v_index, vp -> v_label,
	vp -> v_civilized ? "civilized" : "uncivilized");
    for (BU_LIST_FOR(np, neighbor, &(vp -> v_neighbors)))
d112 1
a112 2
	BU_CKMAG(np, NEIGHBOR_MAGIC, "neighbor");
	BU_CKMAG(np -> n_vertex, VERTEX_MAGIC, "vertex");
d114 1
a114 4
	bu_log("  is a neighbor <x%x> of vertex <x%x> %d '%s' at cost %g\n",
	    np, np -> n_vertex,
	    np -> n_vertex -> v_index, np -> n_vertex -> v_label,
	    np -> n_weight);
d119 1
a119 1
 *			   F R E E _ V E R T E X ( )
a120 1
 *	N.B. - This routine frees the v_bridge member of vp.
d122 1
a122 1
void free_vertex (vp)
d124 1
a124 1
struct vertex	*vp;
d127 2
a128 3
    BU_CKMAG(vp, VERTEX_MAGIC, "vertex");
    free_bridge(vp -> v_bridge);
    bu_free((genptr_t) vp, "vertex");
d132 1
a132 1
 *			   M K _ N E I G H B O R ( )
d135 1
a135 27
struct neighbor *mk_neighbor (vp, weight)

struct vertex	*vp;
double		weight;

{
    struct neighbor	*np;

    np = (struct neighbor *) bu_malloc(sizeof(struct neighbor), "neighbor");

    np -> n_magic = NEIGHBOR_MAGIC;
    np -> n_vertex = vp;
    np -> n_weight = weight;

    return (np);
}

/************************************************************************
 *									*
 *	    The comparison callbacks for libredblack(3)			*
 *									*
 ************************************************************************/

/*
 *		C O M P A R E _ V E R T E X _ I N D I C E S ( )
 */
int compare_vertex_indices (v1, v2)
d137 1
a137 2
void	*v1;
void	*v2;
d140 1
a140 13
    struct vertex	*vert1 = (struct vertex *) v1;
    struct vertex	*vert2 = (struct vertex *) v2;

    BU_CKMAG(vert1, VERTEX_MAGIC, "vertex");
    BU_CKMAG(vert2, VERTEX_MAGIC, "vertex");

    return (vert1 -> v_index  -  vert2 -> v_index);
}

/*
 *		 C O M P A R E _ V E R T E X _ L A B E L S ( )
 */
int compare_vertex_labels (v1, v2)
d142 1
a142 2
void	*v1;
void	*v2;
d144 1
a144 3
{
    struct vertex	*vert1 = (struct vertex *) v1;
    struct vertex	*vert2 = (struct vertex *) v2;
d146 2
a147 14
    BU_CKMAG(vert1, VERTEX_MAGIC, "vertex");
    BU_CKMAG(vert2, VERTEX_MAGIC, "vertex");
    if (vert1 -> v_label == '\0')
    {
	bu_log("compare_vertex_labels: null label in vertex <x%x> %d\n",
	    vert1, vert1 -> v_index);
	exit (1);
    }
    if (vert2 -> v_label == '\0')
    {
	bu_log("compare_vertex_labels: null label in vertex <x%x> %d\n",
	    vert2, vert2 -> v_index);
	exit (1);
    }
d149 1
a149 6
    if (*(vert1 -> v_label) < *(vert2 -> v_label))
	return -1;
    else if (*(vert1 -> v_label) > *(vert2 -> v_label))
	return 1;
    else
	return (strcmp(vert1 -> v_label, vert2 -> v_label));
d153 2
a154 1
 *		C O M P A R E _ B R I D G E _ W E I G H T S ( )
d156 1
a156 1
int compare_bridge_weights (v1, v2)
d158 1
a158 2
void	*v1;
void	*v2;
d161 3
a163 19
    double		delta;
    struct bridge	*b1 = (struct bridge *) v1;
    struct bridge	*b2 = (struct bridge *) v2;

    BU_CKMAG(b1, BRIDGE_MAGIC, "bridge");
    BU_CKMAG(b2, BRIDGE_MAGIC, "bridge");

    if (is_infinite_bridge(b1))
	if (is_infinite_bridge(b2))
	    return 0;
	else
	    return 1;
    else if (is_infinite_bridge(b2))
	return -1;

    delta = b1 -> b_weight  -  b2 -> b_weight;
    return ((delta <  0.0) ? -1 :
	    (delta == 0.0) ?  0 :
			      1);
d167 3
a169 1
 *		C O M P A R E _ B R I D G E _ I N D I C E S ( )
d171 1
a171 1
int compare_bridge_indices (v1, v2)
d177 2
a178 2
    struct bridge	*b1 = (struct bridge *) v1;
    struct bridge	*b2 = (struct bridge *) v2;
d180 2
a181 2
    BU_CKMAG(b1, BRIDGE_MAGIC, "bridge");
    BU_CKMAG(b2, BRIDGE_MAGIC, "bridge");
d183 1
a183 6
    if (b1 -> b_index < b2 -> b_index)
	return -1;
    else if (b1 -> b_index == b2 -> b_index)
	return 0;
    else
	return 1;
d188 1
a188 29
 *	    A similar comparison function				*
 *									*
 ************************************************************************/

/*
 *		       C O M P A R E _ W E I G H T S ( )
 */
#define	compare_weights(w1, w2)					\
(								\
    ((w1) <= 0.0) ?						\
    (								\
	((w2) <= 0.0) ?						\
	    0 :							\
	    1							\
    ) :								\
    (								\
	((w2) <= 0.0) ?						\
	    -1 :						\
	    ((w1) < (w2)) ?					\
		-1 :						\
		((w1) == (w2)) ?				\
		    0 :						\
		    1						\
    )								\
)

/************************************************************************
 *									*
 *	  Routines for manipulating the dictionary and priority queue	*
d193 1
a193 1
 *			 L O O K U P _ V E R T E X ( )
d195 1
a195 1
struct vertex *lookup_vertex(dict, index, label)
d197 1
a197 3
rb_tree	*dict;
long	index;
char	*label;
d201 2
a202 2
    struct vertex	*qvp;	/* The query */
    struct vertex	*vp;	/* Value to return */
d204 1
d206 1
a206 1
     *	Prepare the dictionary query
d208 1
a208 1
    qvp = mk_vertex(index, label);
d213 2
a214 2
     *	then we have our vertex.
     *	Otherwise, we must create a new vertex.
d216 1
a216 1
    switch (rc = rb_insert(dict, (void *) qvp))
d219 2
a220 2
	    vp = (struct vertex *) rb_curr1(dict);
	    free_vertex(qvp);
d223 1
a223 1
	    vp = qvp;
d230 1
a230 1
    return (vp);
a232 59
/*
 *			  A D D _ T O _ P R I O Q ( )
 *
 */
void add_to_prioq (v, depth)

void	*v;
int	depth;

{
    struct vertex	*vp = (struct vertex *) v;

    BU_CKMAG(vp, VERTEX_MAGIC, "vertex");
    BU_CKMAG(vp -> v_bridge, BRIDGE_MAGIC, "bridge");

    rb_insert(prioq, (void *) (vp -> v_bridge));
}

/*
 *			D E L _ F R O M _ P R I O Q ( )
 *
 */
void del_from_prioq (vp)

struct vertex	*vp;

{
    BU_CKMAG(vp, VERTEX_MAGIC, "vertex");
    BU_CKMAG(vp -> v_bridge, BRIDGE_MAGIC, "bridge");

    if (debug)
	bu_log("del_from_prioq(<x%x>... bridge <x%x> %d)\n",
	    vp, vp -> v_bridge, vp -> v_bridge -> b_index);
    if (rb_search(prioq, PRIOQ_INDEX, (void *) (vp -> v_bridge)) == NULL)
    {
	bu_log("del_from_prioq: Cannot find bridge <x%x>.", vp -> v_bridge);
	bu_log("  This should not happen\n");
	exit (1);
    }
    rb_delete(prioq, PRIOQ_INDEX);
}

/*
 *			   E X T R A C T _ M I N ( )
 *
 */
struct bridge *extract_min ()
{
    struct bridge	*bp;

    bp = (struct bridge *) rb_min(prioq, PRIOQ_WEIGHT);
    if (bp != BRIDGE_NULL)
    {
	BU_CKMAG(bp, BRIDGE_MAGIC, "bridge");
	rb_delete(prioq, PRIOQ_WEIGHT);
    }
    return (bp);
}

d235 1
a235 1
 *	  More or less vanilla-flavored stuff for MST			*
d324 6
a329 2
    int	ch;
    int	num1, num2;
d338 2
a339 1
    for ( ; ; )
d342 4
a345 5
	while (isspace(ch = bu_fgetc(sfp)))
	    ;
	if (ch == EOF)
	    return (1);
	switch (read_range(sfp, &ch, &num1, &num2))
d347 47
a393 8
	    case 1:
		printf("OK, I got a single number %d\n", num1);
		break;
	    case 2:
		printf("OK, I got a pair of numbers %d and %d\n", num1, num2);
		break;
	    default:
		return (-1);
a394 2
	while (isspace(ch))
	    ch = bu_fgetc(sfp);
d396 2
a397 1
	switch (ch)
d399 3
a401 13
	    case ',':
		continue;
	    case ':':
		ch = bu_fgetc(sfp);
		if (read_int(sfp, &ch, &num1) != 1)
		    return (-1);
		printf("OK, I got the last number %d\n\n", num1);
		break;
	    default:
		bu_file_err(sfp, "remapid:read_spec()",
		    "Syntax error",
		    (sfp -> file_bp) - bu_vls_addr(&(sfp -> file_buf)) - 1);
		break;
d403 1
a403 1
	break;
a425 3
    int		numeric;
    char	*label;

d431 1
a431 12
    int			tankill = 0;	/* Handle TANKILL format (vs. BRL-CAD)? */
    long		index[2];	/* Indices of edge endpoints */
    double		weight;		/* Edge weight */
    rb_tree		*dictionary;	/* Dictionary of vertices */
    struct bridge	*bp;		/* The current bridge */
    struct vertex	*up;		/* An uncivilized neighbor of vup */
    struct vertex	*vcp;		/* The civilized vertex of bp */
    struct vertex	*vup;		/* The uncvilized vertex of bp */
    struct vertex	*vertex[2];	/* The current edge */
    struct neighbor	*neighbor[2];	/* Their neighbors */
    struct neighbor	*np;		/* A neighbor of vup */
    int			(*po[2])();	/* Priority queue order functions */
a468 1
#if 0
d470 1
a470 1
     *	Initialize the dictionary
d472 2
a473 5
    dictionary = rb_create1("Dictionary of vertices",
		    numeric ? compare_vertex_indices
			    : compare_vertex_labels);
    rb_uniq_on1(dictionary);
#endif
d476 1
a476 1
     *	Read in the graph
a478 9
    exit (0);

    /*
     *	Initialize the priority queue
     */
    po[PRIOQ_INDEX] = compare_bridge_indices;
    po[PRIOQ_WEIGHT] = compare_bridge_weights;
    prioq = rb_create("Priority queue of bridges", 2, po);
    rb_walk1(dictionary, add_to_prioq, INORDER);
d481 1
a481 91
    {
	print_prioq();
	rb_walk1(dictionary, print_vertex, INORDER);
    }
    
    /*
     *	Grow a minimum spanning tree, using Prim's algorithm...
     *
     *	While there exists a min-weight bridge (to a vertex v) in the queue
     *	    Dequeue the bridge
     *	    If the weight is finite
     *	        Output the bridge
     *	    Mark v as civilized
     *	    For every uncivilized neighbor u of v
     *	        if uv is cheaper than u's current bridge
     *		    dequeue u's current bridge
     *		    enqueue bridge(uv)
     */
    weight = 0.0;
    while ((bp = extract_min()) != BRIDGE_NULL)
    {
	if (debug)
	{
	    bu_log("extracted min-weight bridge <x%x>, leaving...\n", bp);
	    print_prioq();
	}

	BU_CKMAG(bp, BRIDGE_MAGIC, "bridge");
	vcp = bp -> b_vert_civ;
	vup = bp -> b_vert_unciv;
	BU_CKMAG(vup, VERTEX_MAGIC, "vertex");

	if (is_finite_bridge(bp))
	{
	    BU_CKMAG(vcp, VERTEX_MAGIC, "vertex");
	    if (numeric)
		(void) printf("%d %d %g\n",
		    vcp -> v_index, vup -> v_index, bp -> b_weight);
	    else
		(void) printf("%s %s %g\n",
		    vcp -> v_label, vup -> v_label, bp -> b_weight);
	    weight += bp -> b_weight;
	}
	free_bridge(bp);
	vup -> v_civilized = 1;

	if (debug)
	{
	    bu_log("Looking for uncivilized neighbors of...\n");
	    print_vertex((void *) vup, 0);
	}
	while (BU_LIST_WHILE(np, neighbor, &(vup -> v_neighbors)))
	{
	    BU_CKMAG(np, NEIGHBOR_MAGIC, "neighbor");
	    up = np -> n_vertex;
	    BU_CKMAG(up, VERTEX_MAGIC, "vertex");

	    if (up -> v_civilized == 0)
	    {
		BU_CKMAG(up -> v_bridge, BRIDGE_MAGIC, "bridge");
		if (compare_weights(np -> n_weight,
				    up -> v_bridge -> b_weight) < 0)
		{
		    del_from_prioq(up);
		    if (debug)
		    {
			bu_log("After the deletion of bridge <x%x>...\n",
			    up -> v_bridge);
			print_prioq();
		    }
		    up -> v_bridge -> b_vert_civ = vup;
		    up -> v_bridge -> b_weight = np -> n_weight;
		    add_to_prioq((void *) up, 0);
		    if (debug)
		    {
			bu_log("Reduced bridge <x%x> weight to %g\n",
			    up -> v_bridge,
			    up -> v_bridge -> b_weight);
			print_prioq();
		    }
		}
		else if (debug)
		    bu_log("bridge <x%x>'s weight of %g stands up\n",
			    up -> v_bridge, up -> v_bridge -> b_weight);
	    }
	    else if (debug)
		bu_log("Skipping civilized neighbor <x%x>\n", up);
	    BU_LIST_DEQUEUE(&(np -> l));
	}
    }
    bu_log("MST weight: %g\n", weight);
@
