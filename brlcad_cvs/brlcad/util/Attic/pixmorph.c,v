head	1.18;
access;
symbols
	ansi-20040405-merged:1.14.2.2
	postmerge-20040405-ansi:1.16
	premerge-20040404-ansi:1.15
	postmerge-autoconf:1.15
	autoconf-freeze:1.14.10.1
	premerge-autoconf:1.15
	postmerge-20040315-windows:1.15
	premerge-20040315-windows:1.15
	windows-20040315-freeze:1.14.4.1
	autoconf-20031203:1.14
	autoconf-20031202:1.14
	autoconf-branch:1.14.0.10
	phong-branch:1.14.0.8
	photonmap-branch:1.14.0.6
	rel-6-1-DP:1.14
	windows-branch:1.14.0.4
	rel-6-0-2:1.12
	ansi-branch:1.14.0.2
	rel-6-0-1-branch:1.12.0.2
	hartley-6-0-post:1.13
	hartley-6-0-pre:1.12
	rel-6-0-1:1.12
	rel-6-0:1.12
	rel-5-4:1.10
	offsite-5-3-pre:1.12
	rel-5-3:1.10
	rel-5-2:1.10
	rel-5-1-branch:1.10.0.2
	rel-5-1:1.10
	rel-5-0:1.9
	rel-5-0-beta:1.8
	rel-4-5:1.6
	ctj-4-5-post:1.6
	ctj-4-5-pre:1.6;
locks; strict;
comment	@ * @;


1.18
date	2004.05.21.14.57.55;	author morrison;	state dead;
branches;
next	1.17;

1.17
date	2004.05.10.15.30.51;	author erikg;	state Exp;
branches;
next	1.16;

1.16
date	2004.04.05.05.46.02;	author morrison;	state Exp;
branches;
next	1.15;

1.15
date	2004.02.02.17.39.49;	author morrison;	state Exp;
branches;
next	1.14;

1.14
date	2002.08.20.17.09.03;	author jra;	state Exp;
branches
	1.14.2.1
	1.14.4.1
	1.14.10.1;
next	1.13;

1.13
date	2002.08.15.20.56.15;	author hartley;	state Exp;
branches;
next	1.12;

1.12
date	2000.09.01.17.29.38;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	2000.09.01.03.23.58;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	2000.01.31.16.03.09;	author jra;	state Exp;
branches;
next	1.9;

1.9
date	99.07.06.21.11.17;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	98.09.14.15.59.24;	author bparker;	state Exp;
branches;
next	1.7;

1.7
date	98.06.25.07.17.25;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	97.01.08.04.15.34;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	96.12.13.15.05.51;	author jra;	state Exp;
branches;
next	1.4;

1.4
date	96.08.19.13.41.54;	author jra;	state Exp;
branches;
next	1.3;

1.3
date	96.07.16.22.56.03;	author jra;	state Exp;
branches;
next	1.2;

1.2
date	96.01.10.17.26.06;	author gdurf;	state Exp;
branches;
next	1.1;

1.1
date	96.01.10.15.50.17;	author gdurf;	state Exp;
branches;
next	;

1.14.2.1
date	2002.09.19.18.02.42;	author morrison;	state Exp;
branches;
next	1.14.2.2;

1.14.2.2
date	2004.03.17.21.23.32;	author morrison;	state Exp;
branches;
next	;

1.14.4.1
date	2004.03.11.23.52.34;	author morrison;	state Exp;
branches;
next	;

1.14.10.1
date	2004.02.12.19.43.11;	author erikg;	state Exp;
branches;
next	;


desc
@BRL-CAD utility for morphing images.
@


1.18
log
@moved to src/util/
@
text
@/*
 *  			P I X M O R P H . C
 *
 *  Utility for morphing two BRL-CAD pix files.
 *  
 *  Author -
 *      Glenn Durfee
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *
 *  Distribution Notice -
 * 	Re-distribution of this software is restricted, as described in
 * 	your "Statement of Terms and Conditions for the Release of
 * 	The BRL-CAD Package" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1996-2004 by the United States Army.
 *      All rights reserved.
 *
 *  Description -
 *      Morphs two pix files.  Performs the morph according to the given line
 *      segment correspondence file and two values in [0,1]: the first,
 *      warpfrac, is a value which describes how far each image is warped;
 *      the second, dissolvefrac, specifies how much of a cross-dissolve
 *      is performed on the two resulting warped images to produce an
 *      output.  Typically, the user sets warpfrac = dissolvefrac.
 *      See the man page for more details.
 *      
 *  For details of the morph algorithm, see
 *        T. Beier and S. Neely.  Feature-Based Image Metamorphosis.  In
 *        "SIGGRAPH 1992 Computer Graphics Proceedings (volume 26 number 2)"
 *        (Chicago, July 26-31, 1992).
 */

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <math.h>

#include "machine.h"
#include "externs.h"			/* For malloc and getopt */
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "fb.h"

/* Adapted from an assignment for
 *    15-463 Advanced Computer Graphics
 *    Professor Paul Heckbert
 *    Carnegie Mellon University
 */

/* CBLEND is for interpolating characters.  Useful for dissolve. */
#define CBLEND(a, b, cfrac) (unsigned char)(((256-cfrac)*(int)(a)+\
					     cfrac*(int)(b))>>8)

/* DBLEND is for interpolating doubles.  Useful for warping. */
#define DBLEND(a, b, dfrac) ((1.0-dfrac)*(double)(a)+dfrac*(double)(b))

#define FIRST  0
#define MIDDLE 1
#define LAST   2

#define EPSILON 10e-8

/* Hopefully the distance between two pixels in the image will be less
   than the following value.  If not, cap it at this value in the
   computations.*/
#define MAXLEN 65536

/* gprof tells me that 73% of the time to execute was spent in those two
   pow() function calls.  So, we "memoize" a little bit, and don't call those
   pow()s for weights already calculated (they only depend on length and dist,
   which range from 0 to MAXLEN.)  Truncating them to integers changes things
   *very* little...trust me. */
double weightlookup[MAXLEN];

/* Basically, we throw *everything* that doesn't need to be recalculated
 * into this structure.  Makes things go faster later.
 * "oo" means "one over" -- floating point divides are much more expensive
 *                          than multiplies 
 */

struct ldata {
    double x1, y1, x2, y2;
    double xdelta, ydelta;
    double oolensq, oolen, len;
    double len_pb;
};

struct lineseg {
    struct ldata s[3];
};

/* 
 * cross_dissolve
 *
 * Takes the two given images "wa" and "wb", and cross-dissolves them by
 * "dissolvefrac", placing the resulting image in "morph".
 */

void
cross_dissolve(unsigned char *morph, unsigned char *wa, unsigned char *wb, int dissolvefrac, int numpixels)
{
    register int i;

    for (i = 0; i < numpixels; i++, morph += 3, wa += 3, wb += 3) {
	morph[RED] = CBLEND(wa[RED], wb[RED], dissolvefrac);
	morph[GRN] = CBLEND(wa[GRN], wb[GRN], dissolvefrac);
	morph[BLU] = CBLEND(wa[BLU], wb[BLU], dissolvefrac);
    }
}


/*
 * warp_image
 *
 * Takes the src image (which is either "FIRST" or "LAST", depending on the
 * value in "which"), and warps it in the appropriate manner (with bilinear
 * interpolation to avoid blockiness).
 */

void
warp_image(unsigned char *dest, unsigned char *src, struct lineseg *lines, int which, int width, int height, int numlines, double a, double b, double p)
{
    register int i, j, k, width3;
    struct lineseg *tlines;

    width3 = width*3;
    for (i = 0; i < height; i++) {
	fprintf(stderr, "line %d   \r", height-i);
	fflush(stderr);
	for (j = 0; j < width; j++, dest += 3) {
	    double dsum_x, dsum_y, weightsum, x_x, x_y, new_x, new_y,
	           frac_x, frac_y, newcolor;
	    int fin_x, fin_y, findex;
	    
	    x_x = (double)j;
	    x_y = (double)i;

	    weightsum = dsum_x = dsum_y = 0.0;
	    for (k = 0, tlines = lines; k < numlines; k++, tlines++) {
		register double x_minus_p_x, x_minus_p_y, u, v, x, y, weight,
 		                dist, tmpx, tmpy;
		register int l2;

		/* This is a fairly straightforward implementation of the
		   algorithm in Beier and Neely's paper.
		   We work only with vector components here... note that
		   Perpindicular((a,b)) = (b, -a). */
		
		x_minus_p_x = x_x - tlines->s[MIDDLE].x1;
		x_minus_p_y = x_y - tlines->s[MIDDLE].y1;

		u = x_minus_p_x * tlines->s[MIDDLE].xdelta +
		    x_minus_p_y * tlines->s[MIDDLE].ydelta;
		u *= tlines->s[MIDDLE].oolensq;

		v = x_minus_p_x * tlines->s[MIDDLE].ydelta -
		    x_minus_p_y * tlines->s[MIDDLE].xdelta;
		v *= tlines->s[MIDDLE].oolen;

		if (u < 0) {
		    tmpx = tlines->s[MIDDLE].x1 - x_x;
		    tmpy = tlines->s[MIDDLE].y1 - x_y;
		    dist = sqrt(tmpx*tmpx+tmpy*tmpy);
		} else if (u > 1) {
		    tmpx = tlines->s[MIDDLE].x2 - x_x;
		    tmpy = tlines->s[MIDDLE].y2 - x_y;
		    dist = sqrt(tmpx*tmpx+tmpy*tmpy);
		} else
		    dist = fabs(v);

		l2 = (int)dist;
		if (l2 > MAXLEN-1) l2 = MAXLEN-1;

		if (weightlookup[l2] > -0.5)
		    weight = weightlookup[l2];
		else
		    weight = weightlookup[l2] = pow(1.0 / (a + dist), b);

		weight *= tlines->s[MIDDLE].len_pb;

		x = tlines->s[which].x1 + u*tlines->s[which].xdelta +
		    v*tlines->s[which].oolen*tlines->s[which].ydelta - x_x;
		y = tlines->s[which].y1 + u*tlines->s[which].ydelta -
		    v*tlines->s[which].oolen*tlines->s[which].xdelta - x_y;

		dsum_x += x * weight;
		dsum_y += y * weight;
		weightsum += weight;
	    }

	    if (weightsum < EPSILON) {
		new_x = x_x;
		new_y = x_y;
	    } else {
		new_x = x_x + dsum_x / weightsum;
		new_y = x_y + dsum_y / weightsum;
	    }

	    if (new_x < 0.0) new_x = 0.0;
	    if (new_x > (double)width-1.01) new_x = (double)width-1.01;
	    if (new_y < 0.0) new_y = 0.0;
	    if (new_y > (double)height-1.01) new_y = (double)height-1.01;

	    fin_x = (int)(new_x+.5);
	    fin_y = (int)(new_y+.5);

	    /* The following should be unnecessary... */

	    if (fin_x < 0) fin_x = 0;
	    if (fin_y < 0) fin_y = 0;
	    if (fin_x > width-2) fin_x = width-2;
	    if (fin_y > height-2) fin_y = height-2;

	    /* End of unnecessary stuff. */

	    findex = 3*(fin_x + fin_y*width);

	    frac_x = new_x - (double)fin_x;
	    frac_y = new_y - (double)fin_y;

#define ICLAMP(d, a, b) (d < a ? (int)a : d > b ? (int)b : (int)d)

	    /* Bilinear interpolation.
	       It's the somewhat more expensive than it needs to be.
	       I'm going for clarity, here. */
	    
	    newcolor = ((1-frac_x)*(1-frac_y)*(double)src[findex+RED] +
			(1-frac_y)*frac_x*(double)src[findex+3+RED] +
			frac_y*frac_x*(double)src[findex+width3+3+RED] +
			frac_y*(1-frac_x)*(double)src[findex+width3+RED]);
	    dest[RED] = ICLAMP(newcolor, 0, 255);
	    
	    newcolor = ((1-frac_x)*(1-frac_y)*(double)src[findex+GRN] +
			     (1-frac_y)*frac_x*(double)src[findex+3+GRN] +
			     frac_y*frac_x*(double)src[findex+width3+3+GRN] +
			     frac_y*(1-frac_x)*(double)src[findex+width3+GRN]);
	    dest[GRN] = ICLAMP(newcolor, 0, 255);
	    
	    newcolor = ((1-frac_x)*(1-frac_y)*(double)src[findex+BLU] +
			     (1-frac_y)*frac_x*(double)src[findex+3+BLU] +
			     frac_y*frac_x*(double)src[findex+width3+3+BLU] +
			     frac_y*(1-frac_x)*(double)src[findex+width3+BLU]);
	    dest[BLU] = ICLAMP(newcolor, 0, 255);
	}
    }
}


/*
 * lines_read
 *
 * Fills up the lines array given by "lines" with the "numlines" many
 * line segment pairs from the given file.  Since the lines are in unit
 * square space, we multiply and stuff to get them to our space.
 * Furthermore, we calculate all of the useful information, including
 * interpolation, length, etc...
 */
 

int
lines_read(FILE *fp, int numlines, struct lineseg *lines, int width, int height, double warpfrac, double pb)
{
    register int i, j;
    double x1, y1, x2, y2, x3, y3, x4, y4;

    for (i = 0; i < numlines; i++, lines++) {
	if (fscanf(fp, "%lf %lf %lf %lf %lf %lf %lf %lf ",
		   &x1, &y1, &x2, &y2, &x3, &y3, &x4, &y4) < 4) {
	    fprintf(stderr, "pixmorph: lines_read: failure\n");
	    exit(1);
	}

	if ((fabs(x1-x2) < EPSILON && fabs(y1-y2) < EPSILON) ||
	    (fabs(x3-x4) < EPSILON && fabs(y3-y4) < EPSILON)) {
	    fprintf(stderr, "pixmorph: warning: zero-length line segment\n");
	    --numlines;
	    continue;
	}

	lines->s[FIRST].x1 = (double)width*x1;
	lines->s[FIRST].y1 = (double)height*y1;
	lines->s[FIRST].x2 = (double)width*x2;
	lines->s[FIRST].y2 = (double)height*y2;
	lines->s[LAST].x1 = (double)width*x3;	
	lines->s[LAST].y1 = (double)height*y3;
	lines->s[LAST].x2 = (double)width*x4;
	lines->s[LAST].y2 = (double)height*y4;

	/* Now, the other useful information. */

	lines->s[MIDDLE].x1 = DBLEND(lines->s[FIRST].x1,
				     lines->s[LAST].x1, warpfrac);
	lines->s[MIDDLE].y1 = DBLEND(lines->s[FIRST].y1,
				     lines->s[LAST].y1, warpfrac);
	lines->s[MIDDLE].x2 = DBLEND(lines->s[FIRST].x2,
				     lines->s[LAST].x2, warpfrac);
	lines->s[MIDDLE].y2 = DBLEND(lines->s[FIRST].y2,
				     lines->s[LAST].y2, warpfrac);

	for (j = 0; j < 3; j++) {
	    lines->s[j].xdelta = lines->s[j].x2 - lines->s[j].x1;
	    lines->s[j].ydelta = lines->s[j].y2 - lines->s[j].y1;
	    lines->s[j].oolensq = 1.0/(lines->s[j].xdelta*lines->s[j].xdelta +
				       lines->s[j].ydelta*lines->s[j].ydelta);
	    lines->s[j].oolen = sqrt(lines->s[j].oolensq);
	    lines->s[j].len = 1.0/lines->s[j].oolen;
	    lines->s[j].len_pb = pow(lines->s[j].len, pb);
	}
    }

    return numlines;
}

/*
 * lines_headerinfo
 *
 * Gets the useful header information from the given lines file.
 */

void
lines_headerinfo(FILE *fp, double *ap, double *bp, double *pp, int *np)
{
    if (fscanf(fp, "%lf %lf %lf %d ", ap, bp, pp, np) < 4) {
	fprintf(stderr, "pixmorph: cannot read header info in lines file\n");
	exit(1);
    }
}

int
get_args(int argc, char **argv, char **picAnamep, char **picBnamep, char **linesfilenamep, double *warpfracp, int *dissolvefracp, int *autosizep, int *widthp, int *heightp)
{
    register int c;

    *autosizep = 1;
    *widthp = *heightp = 0;

    while ((c = getopt(argc, argv, "w:n:")) != EOF) {
	switch (c) {
	case 'w':
	    *widthp = atoi(optarg);
	    *autosizep = 0;
	    break;
	case 'n':
	    *heightp = atoi(optarg);
	    *autosizep = 0;
	    break;
	default:
	    return 0;
	}
    }

    if (argc != optind+5)
	return 0;

    *picAnamep = argv[optind];
    *picBnamep = argv[optind+1];
    *linesfilenamep = argv[optind+2];
    *warpfracp = atof(argv[optind+3]);
    *dissolvefracp = (int)(255.0*atof(argv[optind+4])+0.5);

    return 1;
}

int
pix_readpixels(FILE *fp, int numpix, unsigned char *pixarray)
{
    return fread(pixarray, 3, numpix, fp);
}

int
pix_writepixels(int numpix, unsigned char *pixarray)
{
    return fwrite(pixarray, 3, numpix, stdout);
}
    
int
main(int argc, char **argv)
{
    char *picAname, *picBname, *linesfilename;
    FILE *picA, *picB, *linesfile;
    int pa_width = 0, pa_height = 0;
    int dissolvefrac;
    double warpfrac;
    unsigned char *pa, *pb, *wa, *wb, *morph;
    double a, b, p;
    int numlines;
    struct lineseg *lines;
    register int i;
    int autosize;
#if 0
    npsw = bu_avail_cpus();
    if (npsw > DEFAULT_PSW) npsw = DEFAULT_PSW;
#endif

    autosize = 1;
    pa_width = pa_height = 0;
    if (get_args(argc, argv, &picAname, &picBname, &linesfilename,
          &warpfrac, &dissolvefrac, &autosize, &pa_width, &pa_height) == 0
	|| isatty(fileno(stdout))) {
	fprintf(stderr,
		"usage: pixmorph [-w width] [-n height] picA.pix picB.pix linesfile warpfrac dissolvefrac > out.pix\n");
	return 1;
    }

    picA = fopen(picAname, "r");
    if (picA == NULL) {
	fprintf(stderr, "pixmorph: cannot open %s\n", picAname);
	return 1;
    }
    picB = fopen(picBname, "r");
    if (picB == NULL) {
	fprintf(stderr, "pixmorph: cannot open %s\n", picBname);
	return 1;
    }
    linesfile = fopen(linesfilename, "r");
    if (linesfile == NULL) {
	fprintf(stderr, "pixmorph: cannot open %s\n", linesfilename);
	return 1;
    }

    if (warpfrac < 0.0 || warpfrac > 1.0) {
	fprintf(stderr, "pixmorph: warpfrac must be between 0 and 1\n");
	return 1;
    }

    if (dissolvefrac < 0 || dissolvefrac > 255) {
	fprintf(stderr, "pixmorph: dissolvefrac must be between 0 and 1\n");
	return 1;
    }

    if (autosize) {
	if (bn_common_file_size(&pa_width, &pa_height, argv[1], 3) == 0) {
	    fprintf(stderr, "pixmorph: unable to autosize\n");
	    return 1;
	}
    } else {
	struct stat sb;

	if (stat(picAname, &sb) < 0) {
	    perror("pixmorph: unable to stat file:");
	    return 1;
	}
	
	if (pa_width > 0) {
	    pa_height = sb.st_size/(3*pa_width);
	    fprintf(stderr, "width = %d, size = %ld, so height = %d\n",
		   pa_width, (long)sb.st_size, pa_height);
	} else if (pa_height > 0) pa_width = sb.st_size/(3*pa_height);

	if (pa_width <= 0 || pa_height <= 0) {
	    fprintf(stderr, "pixmorph: Bogus image dimensions: %d %d\n",
		    pa_width, pa_height);
	    return 1;
	}
    }

    /* Allocate memory for our bag o' pixels. */
    
    pa = (unsigned char *)malloc(pa_width*pa_height*3);
    pb = (unsigned char *)malloc(pa_width*pa_height*3);
    wa = (unsigned char *)malloc(pa_width*pa_height*3);
    wb = (unsigned char *)malloc(pa_width*pa_height*3);
    morph = (unsigned char *)malloc(pa_width*pa_height*3);
    
    if (pa == NULL || pb == NULL || wa == NULL ||  wb == NULL ||
	morph == NULL) {
	fprintf(stderr, "pixmorph: memory allocation failure\n");
	return 1;
    }

    /* The following is our memoizing table for weight calculation. */
       
    for (i = 0; i < MAXLEN; i++)
	weightlookup[i] = -1.0;

    fprintf(stderr, "pixmorph: Reading images and lines file.\n");
    
    if (pix_readpixels(picA, pa_width*pa_height, pa) < pa_width*pa_height) {
	fprintf(stderr, "Error reading %d pixels from %s\n",
		pa_width*pa_height, picAname);
	return 1;
    }
    if (pix_readpixels(picB, pa_width*pa_height, pb) < pa_width*pa_height) {
	fprintf(stderr, "Error reading %d pixels from %s\n",
		pa_width*pa_height,  picBname);
	return 1;
    }
    fclose(picA);
    fclose(picB);

    /* Process the lines file. */
    
    lines_headerinfo(linesfile, &a, &b, &p, &numlines);
    lines = (struct lineseg *)malloc(numlines * sizeof(struct lineseg));
    numlines = lines_read(linesfile, numlines, lines,
			  pa_width, pa_height, warpfrac, p*b);
    fprintf(stderr, "pixmorph: %d line segments read\n", numlines);

    /* Warp the images */
    
    fprintf(stderr,
	    "pixmorph: Warping first image into first intermediate image.\n");
    warp_image(wa, pa, lines, FIRST, pa_width, pa_height, numlines, a, b, p);
    fprintf(stderr,
           "pixmorph: Warping second image into second intermediate image.\n");
    warp_image(wb, pb, lines, LAST, pa_width, pa_height, numlines, a, b, p);

    /* Do the dissolve */
    
    fprintf(stderr,
	    "pixmorph: Performing cross-dissolve between first and second\n");
    fprintf(stderr, "pixmorph: intermediate images.\n");
    cross_dissolve(morph, wa, wb, dissolvefrac, pa_width*pa_height);

    /* All done.  Write everything out to a file and quit. */

    pix_writepixels(pa_width*pa_height, morph);

    fprintf(stderr, "pixmorph: Morph complete.\n");

    /* System takes care of memory deallocation. */

    return 0;
}

    

    

    
    
@


1.17
log
@change conf.h to a wrapped config.h
@
text
@@


1.16
log
@merge of ansi-6-0-branch into head
@
text
@d38 5
a42 1
#include "conf.h"
@


1.15
log
@update copyright to include span through 2003
@
text
@d109 1
a109 3
cross_dissolve(morph, wa, wb, dissolvefrac, numpixels)
unsigned char *morph, *wa, *wb;
int dissolvefrac, numpixels;
d130 1
a130 5
warp_image(dest, src, lines, which, width, height, numlines, a, b, p)
unsigned char *dest, *src;
struct lineseg *lines;
int which, width, height, numlines;
double a, b, p;
d270 1
a270 5
lines_read(fp, numlines, lines, width, height, warpfrac, pb)
FILE *fp;
int numlines, width, height;
struct lineseg *lines;
double warpfrac, pb;
d330 1
a330 2
lines_headerinfo(fp, ap, bp, pp, np)
FILE *fp; double *ap; double *bp; double *pp; int *np;
d339 1
a339 7
get_args(argc, argv, picAnamep, picBnamep, linesfilenamep, warpfracp,
	 dissolvefracp, autosizep, widthp, heightp)
int argc;
char **argv;
char **picAnamep, **picBnamep, **linesfilenamep;
double *warpfracp;
int *dissolvefracp, *autosizep, *widthp, *heightp;
d374 1
a374 4
pix_readpixels(fp, numpix, pixarray)
FILE *fp;
int numpix;
unsigned char *pixarray;
d380 1
a380 3
pix_writepixels(numpix, pixarray)
int numpix;
unsigned char *pixarray;
d386 1
a386 3
main(argc, argv)
int argc;
char **argv;
@


1.14
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1996 by the United States Army.
@


1.14.4.1
log
@sync to HEAD...
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1996-2004 by the United States Army.
@


1.14.10.1
log
@merge from HEAD
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1996-2004 by the United States Army.
@


1.14.2.1
log
@Initial ANSIfication
@
text
@d109 3
a111 1
cross_dissolve(unsigned char *morph, unsigned char *wa, unsigned char *wb, int dissolvefrac, int numpixels)
d132 5
a136 1
warp_image(unsigned char *dest, unsigned char *src, struct lineseg *lines, int which, int width, int height, int numlines, double a, double b, double p)
d276 5
a280 1
lines_read(FILE *fp, int numlines, struct lineseg *lines, int width, int height, double warpfrac, double pb)
d340 2
a341 1
lines_headerinfo(FILE *fp, double *ap, double *bp, double *pp, int *np)
d350 7
a356 1
get_args(int argc, char **argv, char **picAnamep, char **picBnamep, char **linesfilenamep, double *warpfracp, int *dissolvefracp, int *autosizep, int *widthp, int *heightp)
d391 4
a394 1
pix_readpixels(FILE *fp, int numpix, unsigned char *pixarray)
d400 3
a402 1
pix_writepixels(int numpix, unsigned char *pixarray)
d408 3
a410 1
main(int argc, char **argv)
@


1.14.2.2
log
@sync branch with HEAD
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1996-2004 by the United States Army.
@


1.13
log
@Converted from K&R to ANSI C - RFH
@
text
@d109 3
a111 1
cross_dissolve(unsigned char *morph, unsigned char *wa, unsigned char *wb, int dissolvefrac, int numpixels)
d132 5
a136 1
warp_image(unsigned char *dest, unsigned char *src, struct lineseg *lines, int which, int width, int height, int numlines, double a, double b, double p)
d276 5
a280 1
lines_read(FILE *fp, int numlines, struct lineseg *lines, int width, int height, double warpfrac, double pb)
d340 2
a341 1
lines_headerinfo(FILE *fp, double *ap, double *bp, double *pp, int *np)
d350 7
a356 1
get_args(int argc, char **argv, char **picAnamep, char **picBnamep, char **linesfilenamep, double *warpfracp, int *dissolvefracp, int *autosizep, int *widthp, int *heightp)
d391 4
a394 1
pix_readpixels(FILE *fp, int numpix, unsigned char *pixarray)
d400 3
a402 1
pix_writepixels(int numpix, unsigned char *pixarray)
d408 3
a410 1
main(int argc, char **argv)
@


1.12
log
@
Lint
@
text
@d109 1
a109 3
cross_dissolve(morph, wa, wb, dissolvefrac, numpixels)
unsigned char *morph, *wa, *wb;
int dissolvefrac, numpixels;
d130 1
a130 5
warp_image(dest, src, lines, which, width, height, numlines, a, b, p)
unsigned char *dest, *src;
struct lineseg *lines;
int which, width, height, numlines;
double a, b, p;
d270 1
a270 5
lines_read(fp, numlines, lines, width, height, warpfrac, pb)
FILE *fp;
int numlines, width, height;
struct lineseg *lines;
double warpfrac, pb;
d330 1
a330 2
lines_headerinfo(fp, ap, bp, pp, np)
FILE *fp; double *ap; double *bp; double *pp; int *np;
d339 1
a339 7
get_args(argc, argv, picAnamep, picBnamep, linesfilenamep, warpfracp,
	 dissolvefracp, autosizep, widthp, heightp)
int argc;
char **argv;
char **picAnamep, **picBnamep, **linesfilenamep;
double *warpfracp;
int *dissolvefracp, *autosizep, *widthp, *heightp;
d374 1
a374 4
pix_readpixels(fp, numpix, pixarray)
FILE *fp;
int numpix;
unsigned char *pixarray;
d380 1
a380 3
pix_writepixels(numpix, pixarray)
int numpix;
unsigned char *pixarray;
d386 1
a386 3
main(argc, argv)
int argc;
char **argv;
@


1.11
log
@
Lint fix
@
text
@d236 1
a236 1
#define CLAMP(d, a, b) (d < a ? (int)a : d > b ? (int)b : (int)d)
d246 1
a246 1
	    dest[RED] = CLAMP(newcolor, 0, 255);
d252 1
a252 1
	    dest[GRN] = CLAMP(newcolor, 0, 255);
d258 1
a258 1
	    dest[BLU] = CLAMP(newcolor, 0, 255);
@


1.10
log
@Eliminated some unused variables
@
text
@d48 3
@


1.9
log
@
Lint, per bug #394
@
text
@d418 1
a418 1
    register int i, j;
@


1.8
log
@*- fix typos
@
text
@d477 1
a477 1
		   pa_width, sb.st_size, pa_height);
@


1.7
log
@Mods for compiling on sun4
@
text
@d476 1
a476 1
	    fprintf(stderr, "width = %d, size = %d, so height = %d\n",
@


1.6
log
@libbu
@
text
@d337 2
a338 1
lines_headerinfo(FILE *fp, double *ap, double *bp, double *pp, int *np)
@


1.5
log
@Mods to account for asize routines now in libbn.
@
text
@d420 1
a420 1
    npsw = rt_avail_cpus();
@


1.4
log
@Minor change as suggested by Glenn Durfee.
@
text
@d461 1
a461 1
	if (fb_common_file_size(&pa_width, &pa_height, argv[1], 3) == 0) {
@


1.3
log
@Minor mods for IRIX 6.2
@
text
@d525 1
a525 1
			  pa_width, pa_height, warpfrac, p);
@


1.2
log
@Converted from struct pixel * to unsigned char *
@
text
@d525 1
a525 1
			  pa_width, pa_height, warpfrac, p, b);
@


1.1
log
@Initial revision
@
text
@d3 2
d13 6
a18 1
 *  
d20 1
a20 1
 *	This software is Copyright (C) 1995 by the United States Army.
d22 14
d48 1
d50 5
a54 3
struct pixel {
    unsigned char r, g, b;
};
d69 3
a71 2
/* Hopefully the distance between two points in the image will be less
   than the following value. */
d107 1
a107 1
struct pixel *morph, *wa, *wb;
d112 4
a115 4
    for (i = 0; i < numpixels; i++, morph++, wa++, wb++) {
	morph->r = CBLEND(wa->r, wb->r, dissolvefrac);
	morph->g = CBLEND(wa->g, wb->g, dissolvefrac);
	morph->b = CBLEND(wa->b, wb->b, dissolvefrac);
d130 1
a130 1
struct pixel *dest, *src;
d135 1
a135 1
    register int i, j, k;
d138 1
d141 2
a142 2
	fflush(stdout);
	for (j = 0; j < width; j++, dest++) {
d228 1
a228 1
	    findex = fin_x + fin_y*width;
d239 5
a243 5
	    newcolor = ((1-frac_x)*(1-frac_y)*(double)src[findex].r +
			(1-frac_y)*frac_x*(double)src[findex+1].r +
			frac_y*frac_x*(double)src[findex+width+1].r +
			frac_y*(1-frac_x)*(double)src[findex+width].r);
	    dest->r = CLAMP(newcolor, 0, 255);
d245 5
a249 5
	    newcolor = ((1-frac_x)*(1-frac_y)*(double)src[findex].g +
			     (1-frac_y)*frac_x*(double)src[findex+1].g +
			     frac_y*frac_x*(double)src[findex+width+1].g +
			     frac_y*(1-frac_x)*(double)src[findex+width].g);
	    dest->g = CLAMP(newcolor, 0, 255);
d251 5
a255 6
	    newcolor = ((1-frac_x)*(1-frac_y)*(double)src[findex].b +
			     (1-frac_y)*frac_x*(double)src[findex+1].b +
			     frac_y*frac_x*(double)src[findex+width+1].b +
			     frac_y*(1-frac_x)*(double)src[findex+width].b);
	    dest->b = CLAMP(newcolor, 0, 255);

d285 1
a285 1
	    fprintf(stderr, "morph: lines_read: failure\n");
d291 1
a291 1
	    fprintf(stderr, "morph: warning: zero-length line segment\n");
d340 1
a340 1
	fprintf(stderr, "morph: cannot read header info in lines file\n");
d390 1
a390 1
struct pixel *pixarray;
d392 1
a392 1
    return fread((void *)pixarray, 3, numpix, fp);
d398 1
a398 1
struct pixel *pixarray;
d400 1
a400 1
    return fwrite((void *)pixarray, 3, numpix, stdout);
d413 1
a413 1
    struct pixel *pa, *pb, *wa, *wb, *morph;
a484 9
#if 0
    
#ifndef PARALLEL
    npsw = 1;
#endif

    if (npsw < 0) {
	npsw = rt_avail_cpus() + npsw;
    }
a485 5
    if (npsw > MAX_PSW) npsw = MAX_PSW;
    if (npsw > 1) {
	rt_g.rtg_paral
    
#endif
d488 5
a492 5
    pa = (struct pixel *)malloc(pa_width*pa_height*sizeof(struct pixel));
    pb = (struct pixel *)malloc(pa_width*pa_height*sizeof(struct pixel));
    wa = (struct pixel *)malloc(pa_width*pa_height*sizeof(struct pixel));
    wb = (struct pixel *)malloc(pa_width*pa_height*sizeof(struct pixel));
    morph = (struct pixel *)malloc(pa_width*pa_height*sizeof(struct pixel));
d500 1
a500 3
    /* The following is our memoizing table for weight calculation.
       I don't trust the "zeroness" of global data.
       Besides, we might have to put a zero in one of these. */
d549 2
@
