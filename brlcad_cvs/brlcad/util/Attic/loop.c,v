head	11.11;
access;
symbols
	ansi-20040405-merged:11.8.2.1
	postmerge-20040405-ansi:11.9
	premerge-20040404-ansi:11.8
	postmerge-autoconf:11.8
	autoconf-freeze:11.8
	premerge-autoconf:11.8
	postmerge-20040315-windows:11.8
	premerge-20040315-windows:11.8
	windows-20040315-freeze:11.8
	autoconf-20031203:11.8
	autoconf-20031202:11.8
	autoconf-branch:11.8.0.10
	phong-branch:11.8.0.8
	photonmap-branch:11.8.0.6
	rel-6-1-DP:11.8
	windows-branch:11.8.0.4
	rel-6-0-2:11.6
	ansi-branch:11.8.0.2
	rel-6-0-1-branch:11.6.0.2
	hartley-6-0-post:11.7
	hartley-6-0-pre:11.6
	rel-6-0-1:11.6
	rel-6-0:11.6
	rel-5-4:11.3
	offsite-5-3-pre:11.5
	rel-5-3:11.3
	rel-5-2:11.3
	rel-5-1-branch:11.3.0.2
	rel-5-1:11.3
	rel-5-0:11.3
	rel-5-0-beta:11.3
	rel-4-5:11.3
	ctj-4-5-post:11.2
	ctj-4-5-pre:11.2
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:5.1
	rel-1-24:5.1
	rel-1-20:4.2
	rel-1-10:4.1;
locks; strict;
comment	@ * @;


11.11
date	2004.05.21.14.57.41;	author morrison;	state dead;
branches;
next	11.10;

11.10
date	2004.05.10.15.30.50;	author erikg;	state Exp;
branches;
next	11.9;

11.9
date	2004.04.05.05.46.01;	author morrison;	state Exp;
branches;
next	11.8;

11.8
date	2002.08.20.17.08.58;	author jra;	state Exp;
branches
	11.8.2.1;
next	11.7;

11.7
date	2002.08.15.20.56.11;	author hartley;	state Exp;
branches;
next	11.6;

11.6
date	2001.08.10.20.57.06;	author butler;	state Exp;
branches;
next	11.5;

11.5
date	2000.09.01.03.23.49;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	2000.08.23.19.04.34;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	97.08.20.07.08.11;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	97.02.07.02.10.56;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.12.05;	author mike;	state Rel4_4;
branches;
next	10.3;

10.3
date	94.12.12.21.57.20;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	92.04.22.16.41.04;	author phil;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.48.16;	author mike;	state Rel4_0;
branches;
next	9.1;

9.1
date	89.05.19.06.09.34;	author mike;	state Rel3_5;
branches;
next	8.1;

8.1
date	88.10.05.00.42.05;	author mike;	state Rel3_0;
branches;
next	7.1;

7.1
date	87.11.03.00.07.51;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.08.11.06;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.39.15;	author mike;	state Rel;
branches;
next	4.2;

4.2
date	87.02.13.00.42.21;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.13.12;	author mike;	state Rel1;
branches;
next	1.3;

1.3
date	86.08.13.04.41.36;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	86.05.15.17.46.30;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	86.04.16.23.11.05;	author mike;	state Exp;
branches;
next	;

11.8.2.1
date	2002.09.19.18.02.37;	author morrison;	state Exp;
branches;
next	;


desc
@Generate integer sequences.
@


11.11
log
@moved to src/util/
@
text
@/*
 *			L O O P . C
 *
 *	Simple program to output integers or floats between 
 *	"start" and "finish", inclusive.  Default is an increment 
 *	of +1 if start < finish or -1 if start > finish.  User may 
 *	specify an alternate increment.  Also, user may left-pad 
 *	output integers with zeros.  There is no attempt to prevent 
 *	"infinite" loops.
 *
 *  Authors -
 *	John Grosh, Phil Dykstra, and Michael John Muuss
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Status -
 *	Public Domain, Distribution Unlimited.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/util/loop.c,v 11.10 2004/05/10 15:30:50 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include <math.h>

#include "machine.h"
#include "externs.h"

#define	INTEGER 0
#define	REAL	1

int
main(int argc, char **argv)
{
	register int	status = INTEGER;

	register int	i;
	register int 	start,  finish, incr;

	register double	d;
	register double	dstart, dfinish,dincr;

	if (argc < 3 || argc > 4) {
		fprintf(stderr, "Usage:  loop start finish [incr]\n");
		exit(9);
	}

	/* determine if any arguments are real */
	for (i = 1; i < argc; i++) {
		if (atof(argv[i]) != ((double)atoi(argv[i]))) {	
			status = REAL;
			break;
		}
	}

	if (status == REAL) {
		dstart  = atof(argv[1]);
		dfinish = atof(argv[2]);

		if (argc == 4)
			dincr = atof(argv[3]);
		else {
			if (dstart > dfinish)
				dincr = -1.0;
			else
				dincr =  1.0;
		}

		if (dincr >= 0.0)
			for (d = dstart; d <= dfinish; d += dincr)
				printf("%g\n", d);
		else 
			for (d = dstart; d >= dfinish; d += dincr)
				printf("%g\n", d);
	} else {
		/* print out integer output */
		char	*cp;
		char	fmt_string[50];

		int	field_width = 0;

		int	zeros      = 0;  /* leading zeros for output */
		int	zeros_arg1 = 0;  /* leading zeros in arg[1]  */
		int	zeros_arg2 = 0;  /* leading zeros in arg[2]  */
		int	zeros_arg3 = 0;  /* leading zeros in arg[3]  */

 		/* count leading leading zeros in argv[1] */
		for (cp = argv[1]; *cp == '0'; cp++)
			zeros_arg1++;
		if (*cp == '\0') 
			zeros_arg1--;

 		/* count leading leading zeros in argv[2] */
		for (cp = argv[2]; *cp == '0'; cp++)
			zeros_arg2++;
		if (*cp == '\0') 
			zeros_arg2--;

 		/* if argv[3] exists, count leading leading zeros */
		if (argc == 4 ) {
			for (cp = argv[3]; *cp == '0'; cp++)
				zeros_arg3++;
			if (*cp == '\0') 
				zeros_arg3--;
		}

		/* determine field width and leading zeros*/
		if (zeros_arg1 >= zeros_arg2 && zeros_arg1 >= zeros_arg3) {
			field_width = strlen(argv[1]);
			zeros       = zeros_arg1;
		} else if (zeros_arg2 >= zeros_arg1 && zeros_arg2 >= zeros_arg3) {
			field_width = strlen(argv[2]);
			zeros       = zeros_arg2;
		} else {
			field_width = strlen(argv[3]);
			zeros       = zeros_arg3;
		}

		/* printf format string fmt_string */
		if (zeros > 0) 
			sprintf(fmt_string,"%%0%dd\n",field_width); 
		else
			strcpy(fmt_string,"%d\n");

		start  = atoi(argv[1]);
		finish = atoi(argv[2]);

		if (argc == 4)
			incr = atoi(argv[3]);
		else {
			if (start > finish)
				incr = -1;
			else
				incr =  1;
		}

		if (incr >= 0)
			for (i = start; i <= finish; i += incr)
				printf(fmt_string, i);
		else 
			for (i = start; i >= finish; i += incr)
				printf(fmt_string, i);
	}
	exit(0);
}
@


11.10
log
@change conf.h to a wrapped config.h
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/util/loop.c,v 11.9 2004/04/05 05:46:01 morrison Exp $ (ARL)";
@


11.9
log
@merge of ansi-6-0-branch into head
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d25 5
a29 1
#include "conf.h"
@


11.8
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/loop.c,v 11.6 2001/08/10 20:57:06 butler Exp $ (ARL)";
d42 1
a42 3
main(argc, argv)
int	argc;
char	**argv;
@


11.8.2.1
log
@Initial ANSIfication
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/loop.c,v 11.8 2002/08/20 17:08:58 jra Exp $ (ARL)";
d42 3
a44 1
main(int argc, char **argv)
@


11.7
log
@Converted from K&R to ANSI C - RFH
@
text
@d42 3
a44 1
main(int argc, char **argv)
@


11.6
log
@Misc compiler warnings eliminated
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/loop.c,v 11.5 2000/09/01 03:23:49 mike Exp $ (ARL)";
d42 1
a42 3
main(argc, argv)
int	argc;
char	**argv;
@


11.5
log
@
Lint fix
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/loop.c,v 11.4 2000/08/23 19:04:34 mike Exp $ (ARL)";
d28 5
@


11.4
log
@
const RCSid
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/loop.c,v 11.3 1997/08/20 07:08:11 mike Exp $ (ARL)";
d36 1
@


11.3
log
@Lacking proper include file to define atof().
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/loop.c,v 11.2 1997/02/07 02:10:56 mike Exp mike $ (ARL)";
@


11.2
log
@Placed in public domain.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
d25 2
d30 3
d55 1
a55 1
		if (atof(argv[i]) != atoi(argv[i])) {	
@


11.1
log
@Release_4.4
@
text
@d11 1
a11 1
 *  Author -
d15 2
a16 3
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
d18 2
a19 3
 *  Copyright Notice -
 *	This software is Copyright (C) 1990 by the United States Army.
 *	All rights reserved.
a20 1

d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/loop.c,v 10.3 94/12/12 21:57:20 mike Exp $ (BRL)";
@


10.3
log
@Linux
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/loop.c,v 10.2 92/04/22 16:41:04 phil Exp Locker: mike $ (BRL)";
@


10.2
log
@John Grosh's greatly expanded loop - floating point; leading zeros.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: loop.c,v 9.1 89/05/19 06:09:34 mike Rel3_5 $ (BRL)";
d93 1
a93 1
		if (*cp == NULL) 
d99 1
a99 1
		if (*cp == NULL) 
d106 1
a106 1
			if (*cp == NULL) 
@


10.1
log
@Release_4.0
@
text
@d4 6
a9 4
 *	Simple program to output integers between "start" and "finish",
 *	inclusive.  Default is an increment of +1 if start < finish or
 *	-1 if start > finish.  User may specify an alternate increment.
 *	There is no attempt to prevent "infinite" loops.
d12 1
a12 1
 *	Michael John Muuss
d20 1
a20 1
 *	This software is Copyright (C) 1986 by the United States Army.
d23 1
d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/loop.c,v 9.1 89/05/19 06:09:34 mike Rel3_5 $ (BRL)";
d29 1
d31 3
d35 2
a36 1
char **argv;
d38 1
a38 2
	register int start, finish, incr;
	register int i;
d40 7
a46 1
	if( argc < 3 || argc > 4 )  {
a49 8
	start = atoi( argv[1] );
	finish = atoi( argv[2] );
	if( start > finish )
		incr = -1;
	else
		incr = 1;
	if( argc == 4 )
		incr = atoi( argv[3] );
d51 27
a77 3
	if( incr >= 0 )  {
		for( i=start; i<=finish; i += incr )
			printf("%d\n", i);
d79 67
a145 2
		for( i=start; i>=finish; i += incr )
			printf("%d\n", i);
d147 1
@


9.1
log
@Release_3.5
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: loop.c,v 8.1 88/10/05 00:42:05 mike Rel3_0 $ (BRL)";
@


8.1
log
@Release_3.0
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: loop.c,v 7.1 87/11/03 00:07:51 mike Rel $ (BRL)";
@


7.1
log
@Release 2.3
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: loop.c,v 6.1 87/07/11 08:11:06 mike Rel $ (BRL)";
@


6.1
log
@Release 2.0
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: loop.c,v 5.1 87/06/24 22:39:15 mike Rel $ (BRL)";
@


5.1
log
@Release 1.24
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: loop.c,v 4.2 87/02/13 00:42:21 mike Exp $ (BRL)";
@


4.2
log
@Release 1.20 -- First Formal Release
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: loop.c,v 4.1 86/12/29 03:13:12 mike Rel1 $ (BRL)";
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: loop.c,v 1.3 86/08/13 04:41:36 mike Exp $ (BRL)";
@


1.3
log
@Cleanup for distribution
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
@


1.2
log
@Added ability to go backwards
@
text
@d2 1
a2 1
 *			I B A R . C
d4 16
a19 1
 *  Integer count, by increment.
d21 3
d25 2
d34 1
a34 1
		printf("Usage:  ibar start finish [incr]\n");
d39 4
a42 1
	incr = 1;
d46 1
a46 1
	if( incr > 0 )  {
@


1.1
log
@Initial revision
@
text
@d1 6
d10 1
a10 1
	register int low, up, incr;
d14 1
a14 1
		printf("Usage:  ibar low upper [incr]\n");
d17 2
a18 2
	low = atoi( argv[1] );
	up = atoi( argv[2] );
d23 7
a29 2
	for( i=low; i<=up; i += incr )
		printf("%d\n", i);
@
