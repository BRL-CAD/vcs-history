head	11.10;
access;
symbols
	ansi-20040405-merged:11.6.2.2
	postmerge-20040405-ansi:11.8
	premerge-20040404-ansi:11.7
	postmerge-autoconf:11.7
	autoconf-freeze:11.6.10.1
	premerge-autoconf:11.7
	postmerge-20040315-windows:11.7
	premerge-20040315-windows:11.7
	windows-20040315-freeze:11.6.4.1
	autoconf-20031203:11.6
	autoconf-20031202:11.6
	autoconf-branch:11.6.0.10
	phong-branch:11.6.0.8
	photonmap-branch:11.6.0.6
	rel-6-1-DP:11.6
	windows-branch:11.6.0.4
	rel-6-0-2:11.4
	ansi-branch:11.6.0.2
	rel-6-0-1-branch:11.4.0.2
	hartley-6-0-post:11.5
	hartley-6-0-pre:11.4
	rel-6-0-1:11.4
	rel-6-0:11.4
	rel-5-4:11.2
	offsite-5-3-pre:11.2
	rel-5-3:11.2
	rel-5-2:11.2
	rel-5-1-branch:11.2.0.2
	rel-5-1:11.2
	rel-5-0:11.2
	rel-5-0-beta:11.2
	rel-4-5:11.2
	ctj-4-5-post:11.2
	ctj-4-5-pre:11.2
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1;
locks; strict;
comment	@ * @;


11.10
date	2004.05.21.14.57.48;	author morrison;	state dead;
branches;
next	11.9;

11.9
date	2004.05.10.15.30.50;	author erikg;	state Exp;
branches;
next	11.8;

11.8
date	2004.04.05.05.46.02;	author morrison;	state Exp;
branches;
next	11.7;

11.7
date	2004.02.02.17.39.45;	author morrison;	state Exp;
branches;
next	11.6;

11.6
date	2002.08.20.17.09.01;	author jra;	state Exp;
branches
	11.6.2.1
	11.6.4.1
	11.6.10.1;
next	11.5;

11.5
date	2002.08.15.20.56.12;	author hartley;	state Exp;
branches;
next	11.4;

11.4
date	2001.10.17.07.40.07;	author morrison;	state Exp;
branches;
next	11.3;

11.3
date	2001.08.10.20.57.06;	author butler;	state Exp;
branches;
next	11.2;

11.2
date	96.07.16.22.56.03;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.12.28;	author mike;	state Rel4_4;
branches;
next	10.2;

10.2
date	94.08.23.15.05.49;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.48.30;	author mike;	state Rel4_0;
branches;
next	9.2;

9.2
date	91.08.30.00.07.56;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.10.06;	author mike;	state Rel3_5;
branches;
next	1.7;

1.7
date	89.04.24.08.13.26;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	89.04.23.22.02.17;	author butler;	state Exp;
branches;
next	1.5;

1.5
date	89.04.23.17.18.10;	author butler;	state Exp;
branches;
next	1.4;

1.4
date	89.04.23.06.02.51;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	89.04.22.05.13.59;	author butler;	state Exp;
branches;
next	1.2;

1.2
date	89.04.21.00.42.42;	author butler;	state Exp;
branches;
next	1.1;

1.1
date	89.04.20.21.17.21;	author butler;	state Exp;
branches;
next	;

11.6.2.1
date	2002.09.19.18.02.40;	author morrison;	state Exp;
branches;
next	11.6.2.2;

11.6.2.2
date	2004.03.17.21.23.28;	author morrison;	state Exp;
branches;
next	;

11.6.4.1
date	2004.03.11.23.52.31;	author morrison;	state Exp;
branches;
next	;

11.6.10.1
date	2004.02.12.19.43.10;	author erikg;	state Exp;
branches;
next	;


desc
@converts 24 bit deep BRL PIX format files to 8 bit deep Sun Rasterfile format
@


11.10
log
@moved to src/util/
@
text
@/*			P I X - S U N
 *
 *	Program to take a BRLCAD PIX format image file and convert the
 *	image to a Sun Microsystems 8-bit deep color "rasterfile" format
 *	image.
 *
 *  Author -
 *	Lee A. Butler
 *
 *  Source -
 *      SECAD/VLD Computing Consortium, Bldg 394
 *      The U. S. Army Ballistic Research Laboratory
 *      Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *      This software is Copyright (C) 1986-2004 by the United States Army.
 *      All rights reserved.
 */
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <ctype.h>
#ifdef HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"
#include "externs.h"		/* For getopt and isatty */

/* declarations to support use of getopt() system call */
char *options = "hs:w:n:d";
char optflags[sizeof(options)];
char *progname = "(noname)";
int dither = 0;

#define MAPSIZE 256   /* Number of unique color values in Sun Colormap */
/* Description of header for files containing raster images */
struct rasterfile {
    long ras_magic;	/* magic number */
    int	 ras_width;	/* width (pixels) of image */
    int	 ras_height;	/* height (pixels) of image */
    int	 ras_depth;	/* depth (1, 8, or 24 bits) of pixel */
    int	 ras_length;	/* length (bytes) of image */
    int	 ras_type;	/* type of file; see RT_* below */
    int	 ras_maptype;	/* type of colormap; see RMT_* below */
    int	 ras_maplength;	/* length (bytes) of following map */
    /* color map follows for ras_maplength bytes, followed by image */
} ras = {
    0x59a66a95,	/* Magic Number */
    512,	/* default width */
    512,	/* default height */
    8,		/* bits per pixel */
    0,		/* length of image */
    1,		/* standard rasterfile format */
    1,		/* equal RGB color map */
    MAPSIZE*3	/* length (bytes) of RGB colormap */
};

/* The Sun Rasterfile Colormap
 * This colormap has a 6x6x6 color cube, plus 10 extra values for each of
 * the primary colors and the grey levels
 */
unsigned char redmap[MAPSIZE] = 
{ 0, 51,102,153,204,255,  0, 51,102,153,204,255,  0, 51,102,153,
204,255,  0, 51,102,153,204,255,  0, 51,102,153,204,255,  0, 51,
102,153,204,255,  0, 51,102,153,204,255,  0, 51,102,153,204,255,
  0, 51,102,153,204,255,  0, 51,102,153,204,255,  0, 51,102,153,
204,255,  0, 51,102,153,204,255,  0, 51,102,153,204,255,  0, 51,
102,153,204,255,  0, 51,102,153,204,255,  0, 51,102,153,204,255,
  0, 51,102,153,204,255,  0, 51,102,153,204,255,  0, 51,102,153,
204,255,  0, 51,102,153,204,255,  0, 51,102,153,204,255,  0, 51,
102,153,204,255,  0, 51,102,153,204,255,  0, 51,102,153,204,255,
  0, 51,102,153,204,255,  0, 51,102,153,204,255,  0, 51,102,153,
204,255,  0, 51,102,153,204,255,  0, 51,102,153,204,255,  0, 51,
102,153,204,255,  0, 51,102,153,204,255,  0, 51,102,153,204,255,
  0, 51,102,153,204,255,  0, 51,102,153,204,255,  0, 51,102,153,
204,255,  0, 51,102,153,204,255, 17, 34, 68, 85,119,136,170,187,
221,238,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0, 17, 34, 68, 85,119,136,170,187,221,238 };

unsigned char grnmap[MAPSIZE] = 
{ 0,  0,  0,  0,  0,  0, 51, 51, 51, 51, 51, 51,102,102,102,102,
102,102,153,153,153,153,153,153,204,204,204,204,204,204,255,255,
255,255,255,255,  0,  0,  0,  0,  0,  0, 51, 51, 51, 51, 51, 51,
102,102,102,102,102,102,153,153,153,153,153,153,204,204,204,204,
204,204,255,255,255,255,255,255,  0,  0,  0,  0,  0,  0, 51, 51,
 51, 51, 51, 51,102,102,102,102,102,102,153,153,153,153,153,153,
204,204,204,204,204,204,255,255,255,255,255,255,  0,  0,  0,  0,
  0,  0, 51, 51, 51, 51, 51, 51,102,102,102,102,102,102,153,153,
153,153,153,153,204,204,204,204,204,204,255,255,255,255,255,255,
  0,  0,  0,  0,  0,  0, 51, 51, 51, 51, 51, 51,102,102,102,102,
102,102,153,153,153,153,153,153,204,204,204,204,204,204,255,255,
255,255,255,255,  0,  0,  0,  0,  0,  0, 51, 51, 51, 51, 51, 51,
102,102,102,102,102,102,153,153,153,153,153,153,204,204,204,204,
204,204,255,255,255,255,255,255,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0, 17, 34, 68, 85,119,136,170,187,221,238,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0, 17, 34, 68, 85,119,136,170,187,221,238 };

unsigned char blumap[MAPSIZE] =
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51,
 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51,
 51, 51, 51, 51, 51, 51, 51, 51,102,102,102,102,102,102,102,102,
102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,
102,102,102,102,102,102,102,102,102,102,102,102,153,153,153,153,
153,153,153,153,153,153,153,153,153,153,153,153,153,153,153,153,
153,153,153,153,153,153,153,153,153,153,153,153,153,153,153,153,
204,204,204,204,204,204,204,204,204,204,204,204,204,204,204,204,
204,204,204,204,204,204,204,204,204,204,204,204,204,204,204,204,
204,204,204,204,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 17, 34, 68, 85,
119,136,170,187,221,238, 17, 34, 68, 85,119,136,170,187,221,238 };


/* indicies of the primary colors and grey values in the color map */
static unsigned char rvec[16] = { 0, 216, 217, 1, 218, 219, 2, 220, 221,
				3, 222, 223, 4, 224, 225, 5};
static unsigned char gvec[16] = {  0, 226, 227,  6, 228, 229, 12, 230,
				231,  18, 232, 233, 24, 234, 235, 30};
static unsigned char bvec[16] = {  0, 236, 237,  36, 238, 239,  72, 240,
				241, 108, 242, 243, 144, 244, 245, 180 };
static unsigned char nvec[16] = {  0, 246, 247,  43, 248, 249,  86, 250, 
				251, 129, 252, 253, 172, 254, 255, 215};

#define MAG1	51.0	/* magnitude of dither noise in color cube */
#define MAG2	8.0	/* magnitude of dither noise along primaries*/

#define DITHER(d, v, noise, mag) { \
	if ( (d = v + noise * mag) > 255) d=255; \
	else if (d < 0) d = 0; }

static double table[10] = {0.0, 0.1, -0.4, 0.2, -0.3, 0.3, -0.2, 0.4, -0.1, 0.5};
double *noise_ptr = table;
double *end_table = &table[10];
#define NOISE() (noise_ptr < end_table ? *noise_ptr++ : *(noise_ptr=table) )

/* convert 24 bit pixel into appropriate 8 bit pixel */
#define DITHERMAP(red, green, blue, i) {\
	register int _r, _g, _b; double dr, dg, db; \
	dr = NOISE(); DITHER(_r, red, dr, MAG1); _r = (_r+26) / 51; \
	dg = NOISE(); DITHER(_g, green, dg, MAG1); _g = (_g+26) / 51; \
	db = NOISE(); DITHER(_b, blue, db, MAG1); _b = (_b+26) / 51; \
	if (_r == _g) { \
		if (_r == _b) {		/* grey */ \
			DITHER(_r, red, dr, MAG2); \
			DITHER(_g, green, dg, MAG2); \
			DITHER(_b, blue, db, MAG2); \
			i = nvec[ ( (_r+_g+_b)/3) >> 4]; \
		} else if (_r == 0) {	/* all blue */ \
			DITHER(_r, red, dr, MAG2); \
			DITHER(_g, green, dg, MAG2); \
			DITHER(_b, blue, db, MAG2); \
			i = bvec[ _b >> 4]; \
		} else	/* color cube # */ \
			i = (unsigned char)(_r + _g * 6 + _b * 36); \
	} \
	else if (_g == _b && _g == 0) {	/* all red */ \
		DITHER(_r, red, dr, MAG2); \
		DITHER(_g, green, dg, MAG2); \
		DITHER(_b, blue, db, MAG2); \
		i = rvec[ _r >> 4]; \
	} else if (_r == _b && _r == 0) {	/* all green */ \
		DITHER(_r, red, dr, MAG2); \
		DITHER(_g, green, dg, MAG2); \
		DITHER(_b, blue, db, MAG2); \
		i = gvec[_g >> 4]; \
	} else	/* color cube # */ \
		i = (unsigned char)(_r + _g * 6 + _b * 36); }

#define REMAPIXEL(red, green, blue, i) {\
	register unsigned char _r, _g, _b; \
	_r = ((int)red+26)/51; _g = ((int)green+26)/51; _b = ((int)blue+26)/51; \
	if (_r == _g) { \
	    if (_r == _b) i = nvec[ ( ((int)red+(int)green+(int)blue) /3) >> 4]; /* grey */ \
	    else if (_r == 0)  i = bvec[blue/16];	   /* all blue */ \
	    else i = (unsigned char)(_r + _g * 6 + _b * 36);  /* cube # */ \
	} \
	else if (_g == _b && _g == 0) i = rvec[red/16];   /* all red */ \
	else if (_r == _b && _r == 0) i = gvec[green/16]; /* all green */ \
	else i = (unsigned char)(_r + _g * 6 + _b * 36);  /* color cube # */ \
}
/*
 *   D O I T --- convert stdin pix file to stdout rasterfile
 */
void doit(void)
{
    int i, cx, cy;
    unsigned char *pix, *rast;
    register unsigned char red, green, blue;

    if ( ((ras.ras_width/2)*2) != ras.ras_width ) {
	(void)fprintf(stderr, "%s: Cannot handle odd x dimension\n",progname);
	exit(1);
    }

    i = ras.ras_width * ras.ras_height;
    /* allocate buffer for the pix file */
    if ((pix=(unsigned char *)malloc(i*3)) == (unsigned char *)NULL) {
	(void)fprintf(stderr, "%s: cannot get memory for a %d x %d pix file\n",
		progname, ras.ras_width, ras.ras_height );
	exit(1);
    }

    if ((rast=(unsigned char *)malloc(i)) == (unsigned char *)NULL) {
	(void)fprintf(stderr, "%s: cannot get memory for a %d x %d pixrect\n",
		progname, ras.ras_width, ras.ras_height );
	exit(1);
    }

    /* load the pix file into memory (What's Virtual Memory for anyway?)
     * we reverse the order of the scan lines to compensate
     * for differences of origin location in rasterfiles vs. PIX files
     */
    for (i=ras.ras_height-1 ; i >= 0 ; i--)
	if (fread(&pix[i*ras.ras_width*3], ras.ras_width*3, 1, stdin) != 1) {
	 (void)fprintf(stderr, "%s: error reading %d x %d pix file scanline %d\n",
		progname, ras.ras_width, ras.ras_height, i);
	 exit(1);
	}

    /* convert 24 bit pixels to 8 bits, 
     * switching top to bottom to compensate for the different origin 
     * representations of PIX files and Sun pixrects
     */
    if (dither) {
	for(cy=0 ; cy < ras.ras_height ; cy++)
	    for(cx=0 ; cx < ras.ras_width ; cx++) {
		red = pix[(cx + cy * ras.ras_width)*3];
		green = pix[1 + (cx + cy * ras.ras_width)*3];
		blue = pix[2 + (cx + cy * ras.ras_width)*3];
		DITHERMAP(red, green, blue, rast[cx + cy * ras.ras_width]);
	    }
    }
    else {
	for(cy=0 ; cy < ras.ras_height ; cy++)
	    for(cx=0 ; cx < ras.ras_width ; cx++) {
		red = pix[(cx + cy * ras.ras_width)*3];
		green = pix[1 + (cx + cy * ras.ras_width)*3];
		blue = pix[2 + (cx + cy * ras.ras_width)*3];
		REMAPIXEL(red, green, blue, rast[cx + cy * ras.ras_width]);
	    }
    }

    /* now that we have the 8 bit pixels,
     *  we don't need the 24 bit pixels
     */
    free(pix);

    /* fill in miscelaneous rasterfile header fields */
    ras.ras_length = ras.ras_width * ras.ras_height;

    /* write the rasterfile header */
    if (fwrite(&ras, sizeof(ras), 1, stdout) != 1) {
	(void)fprintf(stderr, "%s: error writing rasterfile header to stdout\n", progname);
	exit(1);
    }

    /* write the colormap */
    if (fwrite(redmap, MAPSIZE, 1, stdout) != 1) {
	(void)fprintf(stderr, "%s: error writing colormap\n", progname);
	exit(1);
    }

    if (fwrite(grnmap, MAPSIZE, 1, stdout) != 1) {
	(void)fprintf(stderr, "%s: error writing colormap\n", progname);
	exit(1);
    }

    if (fwrite(blumap, MAPSIZE, 1, stdout) != 1) {
	(void)fprintf(stderr, "%s: error writing colormap\n", progname);
	exit(1);
    }

    /* write out the actual pixels */
    if (fwrite(rast, ras.ras_width, ras.ras_height, stdout) != ras.ras_height){
	(void)fprintf(stderr, "%s: error writing image\n", progname);
	exit(1);
    }
    free(rast);
}

void usage(void)
{

    (void)fprintf(stderr, "Usage: %s [-s squaresize] [-w width] [-n height] [ -d ]\n", progname);
    (void)fprintf(stderr, "\t< BRLpixfile > rasterfile\n");
    exit(1);
}

/*
 *   M A I N
 *
 *   Perform miscelaneous tasks such as argument parsing and
 *   I/O setup and then call "doit" to perform the task at hand
 */
int main(int ac, char **av)
{
    int	c, optlen;

    progname = *av;
    if (isatty(fileno(stdin))) usage();
    
    /* Get # of options & turn all the option flags off
    */
    optlen = strlen(options);

    for (c=0 ; c < optlen ; optflags[c++] = '\0');
    
    /* Turn off getopt's error messages */
    opterr = 0;

    /* get all the option flags from the command line
    */
    while ((c=getopt(ac,av,options)) != EOF)
	switch (c) {
	case 'd'    : dither = !dither; break;
	case 'w'    : ras.ras_width = atoi(optarg); break;
	case 'n'    : ras.ras_height = atoi(optarg); break;
	case 's'    : ras.ras_width = ras.ras_height = atoi(optarg); break;
	default     : usage(); break;
	}


    if (optind < ac) usage();

    doit();
    return (0);
}
@


11.9
log
@change conf.h to a wrapped config.h
@
text
@@


11.8
log
@merge of ansi-6-0-branch into head
@
text
@d19 5
a23 1
#include "conf.h"
@


11.7
log
@update copyright to include span through 2003
@
text
@d190 1
a190 1
void doit()
d287 1
a287 1
void usage()
d301 1
a301 3
int main(ac,av)
int ac;
char *av[];
@


11.6
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d16 1
a16 1
 *      This software is Copyright (C) 1986 by the United States Army.
@


11.6.4.1
log
@sync to HEAD...
@
text
@d16 1
a16 1
 *      This software is Copyright (C) 1986-2004 by the United States Army.
@


11.6.10.1
log
@merge from HEAD
@
text
@d16 1
a16 1
 *      This software is Copyright (C) 1986-2004 by the United States Army.
@


11.6.2.1
log
@Initial ANSIfication
@
text
@d190 1
a190 1
void doit(void)
d287 1
a287 1
void usage(void)
d301 3
a303 1
int main(int ac, char **av)
@


11.6.2.2
log
@sync branch with HEAD
@
text
@d16 1
a16 1
 *      This software is Copyright (C) 1986-2004 by the United States Army.
@


11.5
log
@Converted from K&R to ANSI C - RFH
@
text
@d190 1
a190 1
void doit(void)
d287 1
a287 1
void usage(void)
d301 3
a303 1
int main(int ac, char **av)
@


11.4
log
@Mac OS X warning and error fixes for non-production build
@
text
@d190 1
a190 1
void doit()
d287 1
a287 1
void usage()
d301 1
a301 3
int main(ac,av)
int ac;
char *av[];
@


11.3
log
@Misc compiler warnings eliminated
@
text
@d137 1
a137 1
double table[10] = {0.0, 0.1, -0.4, 0.2, -0.3, 0.3, -0.2, 0.4, -0.1, 0.5};
@


11.2
log
@Minor mods for IRIX 6.2
@
text
@d23 1
a23 1
#ifdef USE_STRING_H
@


11.1
log
@Release_4.4
@
text
@d144 1
a144 1
	register _r, _g, _b; double dr, dg, db; \
@


10.2
log
@Factored ifdefs
@
text
@@


10.1
log
@Release_4.0
@
text
@d19 2
d23 3
a25 1
#ifdef BSD
a26 2
#else
#include <string.h>
d29 3
a34 3
extern char *optarg;
extern int optind, opterr, getopt();
extern int isatty();
d193 1
a193 1
    unsigned char *pix, *rast, *malloc();
@


9.2
log
@Stardent ANSI lint
@
text
@@


9.1
log
@Release_3.5
@
text
@d175 1
a175 1
	_r = (red+26)/51; _g = (green+26)/51; _b = (blue+26)/51; \
d177 1
a177 1
	    if (_r == _b) i = nvec[ ( (red+green+blue) /3) >> 4]; /* grey */ \
@


1.7
log
@string.h -vs- strings.h
@
text
@@


1.6
log
@converted the multiple-if-statement macro MAP to in-line numeric computation
@
text
@d7 2
a8 2
 *   Author(s)
 *   Lee A. Butler
d21 1
d23 3
@


1.5
log
@Added support for color dithering with '-d' option. Could benefit from
further optimization.
@
text
@a126 9
/* map an 8 bit value into a "bin" on the color cube */
#define MAP(x, c) { \
	if (c < 26 ) x=0; \
	else if (c < 77 ) x=1; \
	else if (c < 128 ) x=2; \
	else if (c < 179 ) x=3; \
	else if (c < 230 ) x=4; \
	else x=5; }

d139 3
a141 3
	dr = NOISE(); DITHER(_r, red, dr, MAG1); MAP(_r, _r); \
	dg = NOISE(); DITHER(_g, green, dg, MAG1); MAP(_g, _g); \
	db = NOISE(); DITHER(_b, blue, db, MAG1); MAP(_b, _b); \
d171 1
a171 1
	MAP(_r, red); MAP(_g, green); MAP(_b, blue); \
@


1.4
log
@Fixed unsigned comparison problem.
@
text
@d30 1
d35 1
a35 1
    int	 ras_magic;	/* magic number */
d124 2
a125 3
#define DITHER(_v) { register int _t;\
	if ((_v = _t = _v + noise*mag) > 255) _v = 255; \
	else if (_t < 0) _v = 0; }
a126 2
#define MAG1	26.0	/* magnitude of dither noise in color cube */
#define MAG2	9.0	/* magnitude of dither noise along primaries*/
d136 9
d146 31
a176 7
void  remapixel(red, green, blue, i)
unsigned char red, green, blue, *i;
{
	int r, g, b;
	double dr, dg, db;	/* noise values */
	int	dither=0;
	float	noise, mag;
d178 11
a188 23
	if (dither) {
		DITHER(red);
		DITHER(green);
		DITHER(blue);
		MAP(r, red);
		MAP(g, green);
		MAP(b, blue);
	}
	else {
		MAP(r, red);
		MAP(g, green);
		MAP(b, blue);
	}

	if (r == g) {
	    if (r == b) /* grey */
		*i = nvec[ ( (red+green+blue) /3) >> 4];
	    else if (r == 0)  *i = bvec[blue/16];	   /* all blue */
	    else *i = (unsigned char)(r + g * 6 + b * 36);  /* color cube # */
	}
	else if (g == b && g == 0) *i = rvec[red/16];	   /* all red */
	else if (r == b && r == 0) *i = gvec[green/16]; 	   /* all green */
	else *i = (unsigned char)(r + g * 6 + b * 36);	   /* color cube # */
d233 18
a250 7
    for(cy=0 ; cy < ras.ras_height ; cy++)
	for(cx=0 ; cx < ras.ras_width ; cx++) {
	    red = pix[(cx + cy * ras.ras_width)*3];
	    green = pix[1 + (cx + cy * ras.ras_width)*3];
	    blue = pix[2 + (cx + cy * ras.ras_width)*3];
	    remapixel(red, green, blue, &rast[cx + cy * ras.ras_width]);
	}
d292 3
a294 1
    (void)fprintf(stderr, "Usage: %s [-s squaresize] [-w width] [-n height] < BRLpixfile > rasterfile\n", progname, options);
d326 1
@


1.3
log
@This version contains preliminary support for dithering.
@
text
@d123 3
a125 2
#define DITHER(_v) { \
	if ((_v += noise * mag) > 255) _v = 255; else if (_v < 0) _v = 0; }
@


1.2
log
@*** empty log message ***
@
text
@d20 2
d28 1
d59 16
a74 16
{ 0,051,102,153,204,255,000,051,102,153,204,255,000,051,102,153,
204,255,000,051,102,153,204,255,000,051,102,153,204,255,000,051,
102,153,204,255,000,051,102,153,204,255,000,051,102,153,204,255,
  0,051,102,153,204,255,000,051,102,153,204,255,000,051,102,153,
204,255,000,051,102,153,204,255,000,051,102,153,204,255,000,051,
102,153,204,255,000,051,102,153,204,255,000,051,102,153,204,255,
  0,051,102,153,204,255,000,051,102,153,204,255,000,051,102,153,
204,255,000,051,102,153,204,255,000,051,102,153,204,255,000,051,
102,153,204,255,000,051,102,153,204,255,000,051,102,153,204,255,
  0,051,102,153,204,255,000,051,102,153,204,255,000,051,102,153,
204,255,000,051,102,153,204,255,000,051,102,153,204,255,000,051,
102,153,204,255,000,051,102,153,204,255,000,051,102,153,204,255,
  0,051,102,153,204,255,000,051,102,153,204,255,000,051,102,153,
204,255,000,051,102,153,204,255,017,034,068,085,119,136,170,187,
221,238,000,000,000,000,000,000,000,000,000,000,000,000,000,000,
  0,000,000,000,000,000,017,034,068,085,119,136,170,187,221,238 };
d77 1
a77 1
{ 0,000,000,000,000,000,051,051,051,051,051,051,102,102,102,102,
d79 1
a79 1
255,255,255,255,000,000,000,000,000,000,051,051,051,051,051,051,
d81 4
a84 4
204,204,255,255,255,255,255,255,000,000,000,000,000,000,051,051,
 51,051,051,051,102,102,102,102,102,102,153,153,153,153,153,153,
204,204,204,204,204,204,255,255,255,255,255,255,000,000,000,000,
  0,000,051,051,051,051,051,051,102,102,102,102,102,102,153,153,
d86 1
a86 1
  0,000,000,000,000,000,051,051,051,051,051,051,102,102,102,102,
d88 1
a88 1
255,255,255,255,000,000,000,000,000,000,051,051,051,051,051,051,
d90 3
a92 3
204,204,255,255,255,255,255,255,000,000,000,000,000,000,000,000,
  0,000,017,034,068,085,119,136,170,187,221,238,000,000,000,000,
  0,000,000,000,000,000,017,034,068,085,119,136,170,187,221,238 };
d95 5
a99 5
{ 0,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,
  0,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,
  0,000,000,000,051,051,051,051,051,051,051,051,051,051,051,051,
 51,051,051,051,051,051,051,051,051,051,051,051,051,051,051,051,
 51,051,051,051,051,051,051,051,102,102,102,102,102,102,102,102,
d108 3
a110 3
255,255,255,255,255,255,255,255,000,000,000,000,000,000,000,000,
  0,000,000,000,000,000,000,000,000,000,000,000,017,034,068,085,
119,136,170,187,221,238,017,034,068,085,119,136,170,187,221,238 };
d123 5
d138 7
a144 11
#define REMAPIXEL(red, green, blue, i) { \
	MAP(r, red); MAP(g, green); MAP(b, blue); \
	if (r == g) { \
	    if (r == b) i = nvec[((red+green+blue)/3)/16]; /* grey */ \
	    else if (r == 0)  i = bvec[blue/16];	   /* all blue */ \
	    else i = (unsigned char)(r + g * 6 + b * 36);  /* color cube # */ \
	} \
	else if (g == b && g == 0) i = rvec[red/16];	   /* all red */ \
	else if (r == b && r == 0) i = gvec[green/16]; 	   /* all green */ \
	else i = (unsigned char)(r + g * 6 + b * 36);	   /* color cube # */ }
	
d146 24
d177 1
a177 1
    register unsigned char r, g, b, red, green, blue;
d218 1
a218 1
	    REMAPIXEL(red, green, blue, rast[cx + cy * ras.ras_width]);
d271 1
a271 1
main(ac,av)
d303 1
@


1.1
log
@Initial revision
@
text
@d5 1
a5 2
 *	image.  No color dithering is performed currently.  That will come
 *	later.
a17 1
 *
d133 3
a135 3
		if (r == b) i = nvec[((red+green+blue)/3)/16]; /* grey */ \
		else if (r == 0)  i = bvec[blue/16];	/* all blue */ \
		else i = (unsigned char)(r + g * 6 + b * 36); /* color cube # */ \
d137 3
a139 3
	else if (g == b && g == 0) i = rvec[red/16];	/* all red */ \
	else if (r == b && r == 0) i = gvec[green/16]; 	/* all green */ \
	else i = (unsigned char)(r + g * 6 + b * 36);	/* color cube # */ }
a230 12
/*   O F F S E T
 *
 *   return offset of character c in string s, or strlen(s) if c not in s
 */
int offset(s, c)
char s[], c;
{
    register unsigned int i=0;
    while (s[i] != '\0' && s[i] != c) i++;
    return(i);
}

d233 1
a233 1
    (void)fprintf(stderr, "Usage: %s [-s squaresize] [-w width] [-n height] < pixfile > rasterfile\n", progname, options);
a264 2
	case '?'    :
	case 'h'    : usage(); break;
d267 2
a268 7
	case 's'    : ras.ras_width = ras.ras_height = 
				atoi(optarg); break;
	default     : if (offset(options, c) != strlen(options))
			    optflags[offset(options, c)]++;
			else
			    usage();
			break;
@
