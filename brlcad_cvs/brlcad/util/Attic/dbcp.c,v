head	11.6;
access;
symbols
	ansi-20040405-merged:11.4
	postmerge-20040405-ansi:11.4
	premerge-20040404-ansi:11.4
	postmerge-autoconf:11.4
	autoconf-freeze:11.4
	premerge-autoconf:11.4
	postmerge-20040315-windows:11.4
	premerge-20040315-windows:11.4
	windows-20040315-freeze:11.4
	autoconf-20031203:11.4
	autoconf-20031202:11.4
	autoconf-branch:11.4.0.12
	phong-branch:11.4.0.10
	photonmap-branch:11.4.0.8
	rel-6-1-DP:11.4
	windows-branch:11.4.0.6
	rel-6-0-2:11.4
	ansi-branch:11.4.0.4
	rel-6-0-1-branch:11.4.0.2
	hartley-6-0-post:11.4
	hartley-6-0-pre:11.4
	rel-6-0-1:11.4
	rel-6-0:11.4
	rel-5-4:11.2
	offsite-5-3-pre:11.4
	rel-5-3:11.2
	rel-5-2:11.2
	rel-5-1-branch:11.2.0.2
	rel-5-1:11.2
	rel-5-0:11.2
	rel-5-0-beta:11.2
	rel-4-5:11.2
	ctj-4-5-post:11.2
	ctj-4-5-pre:11.2
	rel-4-4:11.1;
locks; strict;
comment	@ * @;


11.6
date	2004.05.21.14.57.38;	author morrison;	state dead;
branches;
next	11.5;

11.5
date	2004.05.10.15.30.50;	author erikg;	state Exp;
branches;
next	11.4;

11.4
date	2000.09.01.03.23.47;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	2000.08.23.19.04.28;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	96.07.16.22.56.03;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.11.53;	author mike;	state Rel4_4;
branches;
next	1.4;

1.4
date	94.08.23.15.05.37;	author gdurf;	state Exp;
branches;
next	1.3;

1.3
date	93.03.10.02.35.51;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	93.03.10.01.38.44;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	93.03.10.01.10.44;	author mike;	state Exp;
branches;
next	;


desc
@Double Buffered Copy Program, by Doug Kingston.
@


11.6
log
@moved to src/util/
@
text
@/*
 *			D B C P . C
 *
 *	Double-buffered copy program for UNIX
 *
 *	Usage:    dbcp {nblocks} < inputfile > outputfile
 *
 *  Author -
 *	Doug Kingston
 *  
 *  Source -
 *	Davis, Polk, and Wardwell
 *	Chase Manhattan Building
 *	New York, NY
 *  
 *  Distribution Status -
 *	Public Domain, Distribution Unlimitied.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/util/dbcp.c,v 11.5 2004/05/10 15:30:50 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <signal.h>
#include <errno.h>

#include "machine.h"
#include "externs.h"			/* For getopt and malloc and atoi */

int mread(int fd, char *bufp, int n );

#define	STOP	0170
#define	GO	0017

#define P_RD	0
#define P_WR	1

typedef int pipefds[2];

static int	pid;
static long	count;

static int	verbose;

static char	errbuf[BUFSIZ];

static char	usage[] = "\
Usage:  dbcp [-v] blocksize < input > output\n\
	(blocksize = number of 512 byte 'blocks' per record)\n";

void prs();

/*
 *			M A I N
 */
int
main(argc, argv)
int	argc;
char	**argv;
{
	register char	*buffer;
	register unsigned int	size;
	register unsigned int	nread;
	int	rfd;		/* pipe to read message from */
	int	wfd;		/* pipe to write message to */
	int	exitval=0;
	int	saverrno=0;
	int	waitcode;
	char	msgchar;
	pipefds par2chld, chld2par;
	int	c;

	while ( (c = getopt( argc, argv, "v" )) != EOF )  {
		switch( c )  {
		case 'v':
			verbose++;
			break;
		default:
			(void)fputs(usage, stderr);
			exit(1);
		}
	}

	if( optind >= argc )  {
		(void)fputs(usage, stderr);
		exit(2);
	}
	size = 512 * atoi(argv[optind]);

	setbuf (stderr, errbuf);
	if ((buffer = malloc(size)) == NULL) {
		fprintf(stderr, "dbcp: Insufficient buffer memory\n");
		exit (88);
	}
	if (pipe (par2chld) < 0 || pipe (chld2par) < 0) {
		perror ("dbcp: Can't pipe");
		exit (89);
	}

	/*
	 * Ignore SIGPIPE, which may occur sometimes when the parent
	 * goes to send a token to an already dead child on last buffer.
	 */
	(void)signal(SIGPIPE, SIG_IGN);

	switch (pid = fork()) {
	case -1:
		perror ("dbcp: Can't fork");
		exit (99);

	case 0:
		/*  Child  */
		close (par2chld[P_WR]);
		close (chld2par[P_RD]);
		wfd = chld2par[P_WR];
		rfd = par2chld[P_RD];
		msgchar = GO;		/* Prime the pump, so to speak */
		goto childstart;

	default:
		/*  Parent  */
		close (par2chld[P_RD]);
		close (chld2par[P_WR]);
		wfd = par2chld[P_WR];
		rfd = chld2par[P_RD];
		break;
	}

	exitval = 0;
	count = 0L;
	while (1) {
		if ((nread = mread (0, buffer, size)) != size) {
			saverrno = errno;
			msgchar = STOP;
		} else
			msgchar = GO;
		if(write (wfd, &msgchar, 1) != 1) {
			perror("dbcp: message send");
			prs("Can't send READ message\n");
		}
		if ((int)nread == (-1)) {
			errno = saverrno;
			perror ("input read");
			prs("read error on input\n");
			break;
		}
		if(nread == 0) {
			if(verbose) prs("EOF on input\n");
			break;
		}
		if(nread != size)
			prs("partial read (nread = %u)\n", nread);
		if (read(rfd, &msgchar, 1) != 1) {
			perror("dbcp: WRITE message error");
			exitval = 69;
			break;
		}
		if (msgchar == STOP) {
			prs("Got STOP WRITE with %u left\n", nread);
			break;
		} else if (msgchar != GO) {
			prs("Got bad WRITE message 0%o\n", msgchar&0377);
			exitval = 19;
			break;
		}
		if (write(1, buffer, nread) != nread) {
			perror("output write");
			msgchar = STOP;
		} else {
			count++;
			msgchar = GO;
		}
		if(verbose>1) prs("wrote %d\n", nread);
		if (nread != size)
			break;
childstart:
		if (write (wfd, &msgchar, 1) != 1) {
			perror("dbcp: message send");
			prs("Can't send WRITE message\n");
			break;
		}
		if (msgchar == STOP) {
			prs ("write error on output\n");
			break;
		}
		if (read(rfd, &msgchar, 1) != 1) {
			perror("dbcp: READ message error");
			exitval = 79;
			break;
		}
		if (msgchar == STOP) {
			if(verbose) prs("Got STOP READ\n");
			break;
		} else if (msgchar != GO) {
			prs("Got bad READ message 0%o\n", msgchar&0377);
			exitval = 39;
			break;
		}
	}

	if(verbose) prs ("%ld records copied\n", count);
	if(pid)
		while (wait(&waitcode) > 0);
	exit(exitval);
}

void
prs (fmt, a, b, c)
char	*fmt, *a, *b, *c;
{
	fprintf(stderr, "dbcp: (%s) ", pid ? "PARENT" : "CHILD");
	fprintf(stderr, fmt, a, b, c);
	fflush(stderr);
}

/*
 *			M R E A D
 *
 * This function performs the function of a read(II) but will
 * call read(II) multiple times in order to get the requested
 * number of characters.  This can be necessary because pipes
 * and network connections don't deliver data with the same
 * grouping as it is written with.  Written by Robert S. Miles, BRL.
 */
int
mread(fd, bufp, n)
int	fd;
register char	*bufp;
int	n;
{
	register int	count = 0;
	register int	nread;

	do {
		nread = read(fd, bufp, (unsigned)n-count);
		if(nread < 0)  {
			perror("dbcp: mread");
			return(-1);
		}
		if(nread == 0)
			return((int)count);
		count += (unsigned)nread;
		bufp += nread;
	 } while(count < n);

	return((int)count);
}
@


11.5
log
@change conf.h to a wrapped config.h
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/util/dbcp.c,v 11.4 2000/09/01 03:23:47 mike Exp $ (BRL)";
@


11.4
log
@
Lint fix
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/dbcp.c,v 11.3 2000/08/23 19:04:28 mike Exp $ (BRL)";
d23 5
a27 1
#include "conf.h"
@


11.3
log
@
const RCSid
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/dbcp.c,v 11.2 1996/07/16 22:56:03 jra Exp $ (BRL)";
d32 2
d58 2
a59 1
main (argc, argv)
d68 2
a69 2
	int	exitval;
	int	saverrno;
@


11.2
log
@Minor mods for IRIX 6.2
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/dbcp.c,v 11.1 1995/01/04 10:11:53 mike Rel4_4 jra $ (BRL)";
@


11.1
log
@Release_4.4
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/dbcp.c,v 1.4 94/08/23 15:05:37 gdurf Exp $ (BRL)";
d51 2
d206 1
@


1.4
log
@Factored ifdefs
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/dbcp.c,v 1.3 1993/03/10 02:35:51 mike Exp gdurf $ (BRL)";
@


1.3
log
@Ignore SIGPIPE, so that final token write won't be harmful.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/dbcp.c,v 1.2 93/03/10 01:38:44 mike Exp Locker: mike $ (BRL)";
d23 1
a23 2
#include	<stdio.h>
#include	<signal.h>
d25 3
a27 3
extern int	getopt();
extern char	*optarg;
extern int	optind;
d29 3
d35 4
a38 4
struct pipefds {
	int	p_rd;
	int	p_wr;
};
a46 3
extern char *malloc();
extern int errno;

d67 1
a67 1
	struct pipefds par2chld, chld2par;
d92 1
a92 1
	if (pipe (&par2chld) < 0 || pipe (&chld2par) < 0) {
d110 4
a113 4
		close (par2chld.p_wr);
		close (chld2par.p_rd);
		wfd = chld2par.p_wr;
		rfd = par2chld.p_rd;
d119 4
a122 4
		close (par2chld.p_rd);
		close (chld2par.p_wr);
		wfd = par2chld.p_wr;
		rfd = chld2par.p_rd;
@


1.2
log
@Added -v flag.
Added ability to read from pipes
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d24 1
d38 2
a39 2
int	pid;
long	count;
d41 1
a41 1
int	verbose;
d43 1
a43 1
char	errbuf[BUFSIZ];
d74 1
a74 1
			verbose = 1;
d98 6
d171 1
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 *	dbcp.c
d4 1
a4 1
 *	Double-buffered copy program for V7
d6 1
a6 1
 *	Doug Kingston @@ DPW
d8 10
a17 2
 *	Compile:  cc dbcp.c -o dbcp -i -O -7
 *	Usage:    dbcp {nblocks} < inputfile > outputfile
d19 3
d25 4
d40 2
d47 7
d65 1
d68 1
d70 9
a78 4
	if (argc != 2) {
		fprintf(stderr, "Usage:  %s blocksize < input > output\n", argv[0]);
		fprintf(stderr, "        (blocksize = number of 512 byte sectors)\n");
		exit(1);
a79 1
	size = 512 * atoi(argv[1]);
d81 6
d123 1
a123 1
		if ((nread = read (0, buffer, size)) != size) {
d139 1
a139 1
			prs("EOF on input\n");
d182 1
a182 1
			prs("Got STOP READ\n");
d191 1
a191 1
	prs ("%ld records copied\n", count);
d193 1
a193 1
		while (wait(&saverrno) > 0);	/* rip off saverrno */
d203 33
@
