head	11.12;
access;
symbols
	ansi-20040405-merged:11.8.2.2
	postmerge-20040405-ansi:11.10
	premerge-20040404-ansi:11.9
	postmerge-autoconf:11.9
	autoconf-freeze:11.8.10.2
	premerge-autoconf:11.9
	postmerge-20040315-windows:11.9
	premerge-20040315-windows:11.9
	windows-20040315-freeze:11.8.4.1
	autoconf-20031203:11.8
	autoconf-20031202:11.8
	autoconf-branch:11.8.0.10
	phong-branch:11.8.0.8
	photonmap-branch:11.8.0.6
	rel-6-1-DP:11.8
	windows-branch:11.8.0.4
	rel-6-0-2:11.6
	ansi-branch:11.8.0.2
	rel-6-0-1-branch:11.6.0.2
	hartley-6-0-post:11.7
	hartley-6-0-pre:11.6
	rel-6-0-1:11.6
	rel-6-0:11.6
	rel-5-4:11.3
	offsite-5-3-pre:11.5
	rel-5-3:11.3
	rel-5-2:11.3
	rel-5-1-branch:11.3.0.2
	rel-5-1:11.3
	rel-5-0:11.2
	rel-5-0-beta:11.2
	rel-4-5:11.2
	ctj-4-5-post:11.2
	ctj-4-5-pre:11.2
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.2
	rel-1-10:4.1;
locks; strict;
comment	@ * @;


11.12
date	2004.05.21.14.57.32;	author morrison;	state dead;
branches;
next	11.11;

11.11
date	2004.05.10.15.30.50;	author erikg;	state Exp;
branches;
next	11.10;

11.10
date	2004.04.05.05.46.01;	author morrison;	state Exp;
branches;
next	11.9;

11.9
date	2004.02.02.17.39.44;	author morrison;	state Exp;
branches;
next	11.8;

11.8
date	2002.08.20.17.08.54;	author jra;	state Exp;
branches
	11.8.2.1
	11.8.4.1
	11.8.10.1;
next	11.7;

11.7
date	2002.08.15.20.56.07;	author hartley;	state Exp;
branches;
next	11.6;

11.6
date	2001.08.07.20.43.34;	author butler;	state Exp;
branches;
next	11.5;

11.5
date	2000.09.01.03.23.44;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	2000.08.23.19.04.14;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	2000.01.31.16.03.07;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	96.07.16.22.56.03;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.11.30;	author mike;	state Rel4_4;
branches;
next	10.4;

10.4
date	94.12.30.01.20.24;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	94.12.23.08.45.26;	author jra;	state Exp;
branches;
next	10.2;

10.2
date	94.08.23.15.05.29;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.47.46;	author mike;	state Rel4_0;
branches;
next	9.3;

9.3
date	91.09.06.03.59.15;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	91.09.06.03.18.47;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.07.22;	author mike;	state Rel3_5;
branches;
next	8.3;

8.3
date	89.04.26.21.36.56;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	89.04.24.05.27.47;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.40.11;	author mike;	state Rel3_0;
branches;
next	7.2;

7.2
date	88.09.05.22.38.07;	author phil;	state Exp;
branches;
next	7.1;

7.1
date	87.11.03.00.04.53;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.08.08.26;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.36.07;	author mike;	state Rel;
branches;
next	4.2;

4.2
date	87.02.13.00.37.16;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.11.46;	author mike;	state Rel1;
branches;
next	1.7;

1.7
date	86.11.14.22.59.29;	author phil;	state Exp;
branches;
next	1.6;

1.6
date	86.11.11.01.07.55;	author phil;	state Exp;
branches;
next	1.5;

1.5
date	86.10.28.20.34.15;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	86.10.13.03.02.32;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	86.10.13.01.06.48;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	86.10.12.23.21.48;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	86.10.12.22.27.40;	author mike;	state Exp;
branches;
next	;

11.8.2.1
date	2002.09.19.18.02.34;	author morrison;	state Exp;
branches;
next	11.8.2.2;

11.8.2.2
date	2004.03.17.21.23.19;	author morrison;	state Exp;
branches;
next	;

11.8.4.1
date	2004.03.11.23.52.28;	author morrison;	state Exp;
branches;
next	;

11.8.10.1
date	2004.02.12.19.43.09;	author erikg;	state Exp;
branches;
next	11.8.10.2;

11.8.10.2
date	2004.03.15.14.08.11;	author erikg;	state Exp;
branches;
next	;


desc
@Program to convert a monochrome (.bw) format image
to an Imagen IMPRESS format file, suitable for sending
to an Imagen printer.
@


11.12
log
@moved to src/util/
@
text
@/* 
 *			B W - I M P . C
 *
 *  Authors -
 *	Douglas A. Gwyn
 *	Michael John Muuss
 *
 *  Borrows heavily from Steve Hawley's & Geoffrey Cooper's
 *  "traceconv" program.
 *
 *  Notes -
 *	The image is printed upside down to simplify the arithmetic,
 *	due to the organization of the input file.
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1986-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/util/bw-imp.c,v 11.11 2004/05/10 15:30:50 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <string.h>
#include "machine.h"
#include "externs.h"		/* For getopt */

typedef int bool;
#define true 1
#define false 0

static int	halftone[8][8] =	/* halftone pattern */
{
	{6,   7,   8,   9,  10,  11,  12,  13},
	{40,  42,  44,  46,  49,  51,  54,  14},
	{37, 112, 118, 124, 130, 137,  57,  15},
	{36, 106, 208, 219, 230, 145,  60,  16},
	{34, 101, 197, 254, 243, 152,  63,  17},
	{32,  96, 187, 178, 169, 160,  66,  18},
	{30,  91,  86,  82,  78,  74,  70,  19},
	{29,  27,  26,  25,  23,  22,  21,  20}
};

static int	dither[8][8] =		/* dither pattern */
{
	{6,  51,  14,  78,   8,  57,  16,  86},
	{118,  22, 178,  34, 130,  25, 197,  37},
	{18,  96,  10,  63,  20, 106,  12,  70},
	{219,  42, 145,  27, 243,  46, 160,  30},
	{9,  60,  17,  91,   7,  54,  15,  82},
	{137,  26, 208,  40, 124,  23, 187,  36},
	{21, 112,  13,  74,  19, 101,  11,  66},
	{254,  49, 169,  32, 230,  44, 152,  29}
};

static int	(*pattern)[8] = dither;	/* -> dither or halftone */

static FILE	*infp;			/* input file handle */
static char	*file_name = "-";	/* name of input file, for banner */

static int	height;			/* input height */
static int	width;			/* input width */

static int	thresh = -1;		/* Threshold */

static int	page_xoff = 150;	/* 150=0.5", 192=0.75" */
static int	page_yoff = 80;		/* 80=0.25", 544=1.75" */

#define MAXWIDTH	2600
long		swath[32][MAXWIDTH/32];	/* assumes long has 32 bits */
unsigned char	line[MAXWIDTH];		/* grey-scale input buffer */

static int	im_mag;			/* magnification (1, 2 or 4) */
static int	im_width;		/* image size (in Imagen dots) */
static int	im_wpatches;		/* # 32-bit patches width */
static int	im_hpatches;		/* # 32-bit patches height */

bool	get_args(int argc, register char **argv);
bool	im_close(void);
bool	im_header(void);
void	im_write(int y);

char usage[] = "\
Usage: bw-imp [-h -D] [-s squaresize] [-w width] [-n height]\n\
	[-X page_xoff] [-Y page_yoff] [-t thresh] [file.bw] > impress\n";

bool
get_args(int argc, register char **argv)
{
	register int	c;

	while ( (c = getopt( argc, argv, "hDs:n:w:t:X:Y:" )) != EOF )  {
		switch( c )  {
		case 'h':
			/* high-res */
			height = width = 1024;
			break;
		case 'D':
			/* halftone instead of dither */
			pattern = halftone;
			break;
		case 's':
			/* square size */
			height = width = atoi(optarg);
			break;
		case 'n':
			height = atoi(optarg);
			break;
		case 'w':
			width = atoi(optarg);
			break;
		case 't':
			thresh = atoi(optarg);
			break;
		case 'X':
			page_xoff = atoi(optarg);
			break;
		case 'Y':
			page_yoff = atoi(optarg);
			break;

		default:		/* '?' */
			return false;
		}
	}

	if( optind >= argc )  {
		if( isatty(fileno(stdin)) )
			return(false);
		file_name = "-";
		infp = stdin;
	} else {
		file_name = argv[optind];
		if( (infp = fopen(file_name, "r")) == NULL )  {
			(void)fprintf( stderr,
				"bw-imp: cannot open \"%s\" for reading\n",
				file_name );
			return false;
		}
	}

	if ( argc > ++optind )
		(void)fprintf( stderr, "bw-imp: excess argument(s) ignored\n" );

	return true;
}

int
main(int argc, char **argv)
{
	register int 	y;

	height = width = 512;		/* Defaults */

	if ( !get_args( argc, argv ) || isatty(fileno(stdout)) )  {
		(void)fputs(usage, stderr);
		return 1;
	}

	if( thresh >= 0 )  {
		/* Each pixel in gives one bit out, depending on thresh */
		im_mag = 1;
	} else {
		if( width > 512 )  im_mag = 2;
		else if( width > 256 )  im_mag = 4;
		else if( width > 128 )  im_mag = 8;
		else im_mag = 16;
	}
	im_width  = (width * im_mag) & (~31);
	im_wpatches = (im_width+31) / 32;
	im_hpatches = ((height * im_mag)+31) / 32;
	if( im_wpatches*32 > 2560 )  {
		fprintf(stderr,"bw-imp:  output %d too wide, limit is 2560\n",
			im_wpatches*32);
		return(1);
	}

	if ( !im_header() )
		return 1;

	for( y = 0; y < height; y += 32/im_mag )  {
		if( feof(infp) )
			return 1;
		im_write(y);
	}

	if ( !im_close() )
	    return 1;

	return 0;
}

bool
im_header(void)
{

	(void)printf( "@@document(language impress, prerasterization on, Name \"%s\")",
	file_name
	    );

	/* The margins need to be multiples of 16 (printer word align) */
	(void)putchar(205);		/* SET_HV_SYSTEM (whole page) */
	(void)putchar(0x54);
	(void)putchar(135);		/* SET_ABS_H (left margin) */
	(void)putchar((page_xoff>>8)&0xFF);
	(void)putchar(page_xoff&0xFF);
	(void)putchar(137);		/* SET_ABS_V (top margin) */
	(void)putchar((page_yoff>>8)&0xFF);
	(void)putchar(page_yoff&0xFF);
	(void)putchar(205);		/* SET_HV_SYSTEM (set origin) */
	(void)putchar(0x74);
	(void)putchar(206);		/* SET_ADV_DIRS (normal raster scan) */
	(void)putchar(0);
	(void)putchar(236);		/* SET_MAGNIFICATION */
	(void)putchar(0);		/* x 1 */
	(void)putchar(235);		/* BITMAP */
	(void)putchar(3);		/* opaque (store) */
	(void)putchar(im_wpatches);	/* hsize (# patches across) */
	(void)putchar(im_hpatches);	/* vsize (# patches down) */

	return true;
}

void
im_write(int y)
{
	int y1;

	/* Process one 32-bit high output swath */
	for ( y1 = 0; y1 < 32; y1 += im_mag )  {
		int x;

		/* Obtain a single line of 8-bit pixels */
		if( fread( line, 1, width, infp ) != width )  {
			bzero( (void *)line, width );
		}

		/* construct im_mag scans of Imagen swath */
		for ( x = 0; x < im_width; x += 32 )  {
			int my;

			for ( my = 0; my < im_mag; ++my )  {
				register long	b = 0L;	/* image bits */
				int x1;

				for ( x1 = 0; x1 < 32; x1 += im_mag )  {
					register int	level =
					    line[width-1-((x + x1) / im_mag)];
					register int mx;

					if( im_mag <= 1 )  {
						b <<= 1;
						if( level < thresh )
							b |= 1L;
						continue;
					}
					for ( mx = 0; mx < im_mag; ++mx )  {
						register int pgx, pgy;	/* page position */
						b <<= 1;

						/* Compute Dither */
						pgx = x + x1 + mx;
						pgy = y + y1 + my;
						/* ameliorate grid regularity */
						if( pattern == halftone &&
						    (pgy % 16) >= 8 )
							pgx += 4;

						if( level < pattern[pgx % 8][pgy % 8] )
							b |= 1L;
					}
				}
				swath[y1 + my][x / 32] = b;
			}
		}
	}

	/* output the swath */
	{
		register int xx, yy;
		for ( xx = 0; xx < im_wpatches; ++xx )  {
			for ( yy = 0; yy < 32; ++yy )  {
				register long	b = swath[yy][xx];
				register int c;

				c = (int)(b >> 24) & 0xFF; (void)putchar( c );
				c = (int)(b >> 16) & 0xFF; (void)putchar( c );
				c = (int)(b >>  8) & 0xFF; (void)putchar( c );
				c = (int)(b      ) & 0xFF; (void)putchar( c );
			}
		}
	}
}

bool
im_close(void)
{
/*	(void)putchar( 219 );		ENDPAGE */

	(void)fflush( stdout );
	return true;
}
@


11.11
log
@change conf.h to a wrapped config.h
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/util/bw-imp.c,v 11.10 2004/04/05 05:46:01 morrison Exp $ (BRL)";
@


11.10
log
@merge of ansi-6-0-branch into head
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d28 5
a32 1
#include "conf.h"
@


11.9
log
@update copyright to include span through 2003
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/bw-imp.c,v 11.8 2002/08/20 17:08:54 jra Exp $ (BRL)";
d85 4
a88 4
bool	get_args();
bool	im_close();
bool	im_header();
void	im_write();
d95 1
a95 2
get_args( argc, argv )
register char	**argv;
d156 1
a156 3
main( argc, argv )
int		argc;
char		*argv[];
d201 1
a201 1
im_header()
d232 1
a232 2
im_write(y)
int y;
d303 1
a303 1
im_close()
@


11.8
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d21 1
a21 1
 *	This software is Copyright (C) 1986 by the United States Army.
d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/bw-imp.c,v 11.6 2001/08/07 20:43:34 butler Exp $ (BRL)";
@


11.8.4.1
log
@sync to HEAD...
@
text
@d21 1
a21 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/util/bw-imp.c,v 11.9 2004/02/02 17:39:44 morrison Exp $ (BRL)";
@


11.8.10.1
log
@merge from HEAD
@
text
@d21 1
a21 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/bw-imp.c,v 11.9 2004/02/02 17:39:44 morrison Exp $ (BRL)";
@


11.8.10.2
log
@merge from head
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/bw-imp.c,v 11.8.10.1 2004/02/12 19:43:09 erikg Exp $ (BRL)";
@


11.8.2.1
log
@Initial ANSIfication
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/bw-imp.c,v 11.8 2002/08/20 17:08:54 jra Exp $ (BRL)";
d85 4
a88 4
bool	get_args(int argc, register char **argv);
bool	im_close(void);
bool	im_header(void);
void	im_write(int y);
d95 2
a96 1
get_args(int argc, register char **argv)
d157 3
a159 1
main(int argc, char **argv)
d204 1
a204 1
im_header(void)
d235 2
a236 1
im_write(int y)
d307 1
a307 1
im_close(void)
@


11.8.2.2
log
@sync branch with HEAD
@
text
@d21 1
a21 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d25 1
a25 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.7
log
@Converted from K&R to ANSI C - RFH
@
text
@d85 4
a88 4
bool	get_args(int argc, register char **argv);
bool	im_close(void);
bool	im_header(void);
void	im_write(int y);
d95 2
a96 1
get_args(int argc, register char **argv)
d157 3
a159 1
main(int argc, char **argv)
d204 1
a204 1
im_header(void)
d235 2
a236 1
im_write(int y)
d307 1
a307 1
im_close(void)
@


11.6
log
@Misc compilation warnings fixed
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/bw-imp.c,v 11.5 2000/09/01 03:23:44 mike Exp $ (BRL)";
d85 4
a88 4
bool	get_args();
bool	im_close();
bool	im_header();
void	im_write();
d95 1
a95 2
get_args( argc, argv )
register char	**argv;
d156 1
a156 3
main( argc, argv )
int		argc;
char		*argv[];
d201 1
a201 1
im_header()
d232 1
a232 2
im_write(y)
int y;
d303 1
a303 1
im_close()
@


11.5
log
@
Lint fix
@
text
@d1 1
a1 1
/*
d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/bw-imp.c,v 11.4 2000/08/23 19:04:14 mike Exp $ (BRL)";
d31 1
a31 1

d41 8
a48 8
	6,   7,   8,   9,  10,  11,  12,  13,
	40,  42,  44,  46,  49,  51,  54,  14,
	37, 112, 118, 124, 130, 137,  57,  15,
	36, 106, 208, 219, 230, 145,  60,  16,
	34, 101, 197, 254, 243, 152,  63,  17,
	32,  96, 187, 178, 169, 160,  66,  18,
	30,  91,  86,  82,  78,  74,  70,  19,
	29,  27,  26,  25,  23,  22,  21,  20
d53 8
a60 8
	6,  51,  14,  78,   8,  57,  16,  86,
	118,  22, 178,  34, 130,  25, 197,  37,
	18,  96,  10,  63,  20, 106,  12,  70,
	219,  42, 145,  27, 243,  46, 160,  30,
	9,  60,  17,  91,   7,  54,  15,  82,
	137,  26, 208,  40, 124,  23, 187,  36,
	21, 112,  13,  74,  19, 101,  11,  66,
	254,  49, 169,  32, 230,  44, 152,  29
d246 1
a246 1
			bzero( (char *)line, width );
@


11.4
log
@
const RCSid
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/bw-imp.c,v 11.3 2000/01/31 16:03:07 jra Exp $ (BRL)";
d156 1
@


11.3
log
@Eliminated some unused variables
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/bw-imp.c,v 11.2 1996/07/16 22:56:03 jra Exp $ (BRL)";
@


11.2
log
@Minor mods for IRIX 6.2
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/bw-imp.c,v 11.1 1995/01/04 10:11:30 mike Rel4_4 jra $ (BRL)";
a160 1
	int		flags;
@


11.1
log
@Release_4.4
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/bw-imp.c,v 10.4 94/12/30 01:20:24 mike Exp $ (BRL)";
d295 1
a295 1
				register c;
@


10.4
log
@DEC Alpha
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/bw-imp.c,v 10.3 94/12/23 08:45:26 jra Exp Locker: mike $ (BRL)";
@


10.3
log
@fixed /* within a comment.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/util/RCS/bw-imp.c,v 10.2 94/08/23 15:05:29 gdurf Exp Locker: jra $ (BRL)";
d246 1
a246 1
			bzero( line, width );
@


10.2
log
@Factored ifdefs
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/bw-imp.c,v 10.1 1991/10/12 06:47:46 mike Rel4_0 gdurf $ (BRL)";
d309 1
a309 1
/*	(void)putchar( 219 );		/* ENDPAGE */
@


10.1
log
@Release_4.0
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/bw-imp.c,v 9.3 91/09/06 03:59:15 mike Exp $ (BRL)";
d28 2
d31 3
a33 1
#include "externs.h"
a38 4
extern char	*optarg;
extern int	optind;
extern int	getopt();

a245 1
#ifdef BSD
a246 3
#else
			memset( line, '\0', width );
#endif
@


9.3
log
@Added -X page_xoff -Y page_yoff as command line options
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/bw-imp.c,v 9.2 91/09/06 03:18:47 mike Exp $ (BRL)";
@


9.2
log
@Adjusted for maximum print size of -w2240 -n3200
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/bw-imp.c,v 9.1 89/05/19 06:07:22 mike Rel3_5 $ (BRL)";
d73 3
d92 1
a92 1
	[-t thresh] [file.bw] > impress\n";
d100 1
a100 1
	while ( (c = getopt( argc, argv, "hDs:n:w:t:" )) != EOF )  {
d123 6
d215 2
a216 2
	(void)putchar(0);		/* 0,192 gave approx 3/4" margin */
	(void)putchar(150);		/* 1/2" margin */
d218 2
a219 2
	(void)putchar(0);		/* Was 2,32;  gave 1.75" top margin */
	(void)putchar(80);		/* 1/2" top margin */
@


9.1
log
@Release_3.5
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: bw-imp.c,v 8.3 89/04/26 21:36:56 mike Exp $ (BRL)";
d174 2
a175 1
		fprintf(stderr,"bw-imp:  output too wide\n");
d202 1
d206 2
a207 2
	(void)putchar(0);
	(void)putchar(192);
d209 2
a210 2
	(void)putchar(2);
	(void)putchar(32);
@


8.3
log
@Changing dither arrays from u_char to int makes things faster for
word-oriented machines.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: bw-imp.c,v 8.2 89/04/24 05:27:47 mike Locked $ (BRL)";
@


8.2
log
@Revised to greatly simplify the arg to putchar(), because
that expression will be expanded twice inline depending
on whether _flsbuf() is called or not.
This is to bypass an XMP UNICOS 4.0 cc bug.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: bw-imp.c,v 8.1 88/10/05 00:40:11 mike Locked $ (BRL)";
d39 1
a39 2
typedef unsigned char u_char;
static u_char	halftone[8][8] =	/* halftone pattern */
d51 1
a51 1
static u_char	dither[8][8] =		/* dither pattern */
d63 1
a63 1
static u_char	(*pattern)[8] = dither;	/* -> dither or halftone */
d284 4
a287 4
		register int x, y;
		for ( x = 0; x < im_wpatches; ++x )  {
			for ( y = 0; y < 32; ++y )  {
				register long	b = swath[y][x];
@


8.1
log
@Release_3.0
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: bw-impress.c,v 7.2 88/09/05 22:38:07 phil Exp $ (BRL)";
d28 2
a29 1
#include	<stdio.h>
a36 2

extern void	exit();
d289 1
d291 4
a294 4
				(void)putchar( (int)(b >> 24) & 0xFF );
				(void)putchar( (int)(b >> 16) & 0xFF );
				(void)putchar( (int)(b >> 8) & 0xFF );
				(void)putchar( (int)b & 0xFF );
@


7.2
log
@changed name bw-impress to bw-imp
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: bw-imp.c,v 7.1 87/11/03 00:04:53 phil Locked $ (BRL)";
@


7.1
log
@Release 2.3
@
text
@d2 1
a2 1
 *			B W - I M P R E S S . C
d25 1
a25 1
static char RCSid[] = "@@(#)$Header: bw-impress.c,v 6.1 87/07/11 08:08:26 mike Rel $ (BRL)";
d90 1
a90 1
Usage: bw-impress [-h -D] [-s squaresize] [-w width] [-n height]\n\
d137 1
a137 1
				"bw-impress: cannot open \"%s\" for reading\n",
d144 1
a144 1
		(void)fprintf( stderr, "bw-impress: excess argument(s) ignored\n" );
d176 1
a176 1
		fprintf(stderr,"bw-impress:  output too wide\n");
@


6.1
log
@Release 2.0
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: bw-impress.c,v 5.1 87/06/24 22:36:07 mike Rel $ (BRL)";
@


5.1
log
@Release 1.24
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: bw-impress.c,v 4.2 87/02/13 00:37:16 mike Exp $ (BRL)";
@


4.2
log
@Release 1.20 -- First Formal Release
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: bw-impress.c,v 4.1 86/12/29 03:11:46 mike Rel1 $ (BRL)";
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: bw-impress.c,v 1.7 86/11/14 22:59:29 phil Exp $ (BRL)";
@


1.7
log
@arg convention
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: bw-impress.c,v 1.6 86/11/11 01:07:55 phil Locked $ (BRL)";
@


1.6
log
@Added isatty check on stdout.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: bw-impress.c,v 1.5 86/10/28 20:34:15 phil Locked $ (BRL)";
d90 2
a91 2
Usage: bw-impress [-h -D] [-s squaresize] [-W width] [-H height]\n\
	[-t thresh] [file]\n";
d99 1
a99 1
	while ( (c = getopt( argc, argv, "hDs:H:W:t:" )) != EOF )  {
d113 1
a113 1
		case 'H':
d116 1
a116 1
		case 'W':
@


1.5
log
@improved register utilization in inner loop
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: bw-impress.c,v 1.4 86/10/13 03:02:32 mike Locked $ (BRL)";
d158 1
a158 1
	if ( !get_args( argc, argv ) )  {
@


1.4
log
@Non-rectangular images now works
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: bw-impress.c,v 1.3 86/10/13 01:06:48 mike Locked $ (BRL)";
d229 1
a229 4
	int x;
	register int y1;
	register int x1;
	register int mx, my;
d233 2
d246 2
d250 1
d255 1
d285 5
a289 3
	for ( x1 = 0; x1 < im_wpatches; ++x1 )  {
		for ( y1 = 0; y1 < 32; ++y1 )  {
			register long	b = swath[y1][x1];
d291 5
a295 4
			(void)putchar( (int)(b >> 24) & 0xFF );
			(void)putchar( (int)(b >> 16) & 0xFF );
			(void)putchar( (int)(b >> 8) & 0xFF );
			(void)putchar( (int)b & 0xFF );
@


1.3
log
@Working version with option processing
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: bw-impress.c,v 1.2 86/10/12 23:21:48 mike Locked $ (BRL)";
d75 3
a77 1
static long		swath[32][64];	/* assumes long has 32 bits */
a78 2
static unsigned char	line[4096];	/* grey-scale input buffer */

d89 3
a91 2
char usage[] = "Usage: bw-impress [-h] [-s squaresize] [-H height] [-W width]\n\
	[-t thresh] [-D] [file]\n";
d99 1
a99 1
	while ( (c = getopt( argc, argv, "hs:H:W:t:D" )) != EOF )  {
d105 4
a121 4
		case 'D':
			/* halftone instead of dither */
			pattern = halftone;
			break;
d169 2
a170 1
		else im_mag = 8;
d282 1
a282 1
	for ( x1 = 0; x1 < im_hpatches; ++x1 )  {
d297 1
a297 2
	/*	(void)putchar( 219 );		/* ENDPAGE */
	/*	(void)flush( stdout );	*/
d299 1
@


1.2
log
@Somewhat optimized, still interim form.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d67 2
a68 3
static char	*file_name = "-";	/* name of RLE file, for banner */
static int	rlesize = 512;		/* "screen" width: 512 or 1024 */
static int	thresh = 150;		/* Threshold */
d70 5
d77 1
a77 1
static unsigned char	line[1024];	/* grey-scale RLE scan */
d79 1
a79 1
static int	im_mag;			/* magnification (2 or 4) */
d81 2
a82 1
static int	im_patches;		/* # 32-bit patches needed */
d89 2
a91 40
main( argc, argv )
int		argc;
char		*argv[];
{
	register int 	y;
	int		flags;

#ifdef never
	if ( !get_args( argc, argv ) )
	{
		(void)fputs( "Usage: rle-im [-b (WB)] [-h] [file]\n", stderr );
		return 1;
	}
#endif

	rlesize = 512;
/**	rlesize = 1024;		/* high-resolution */

	im_mag = rlesize == 512 ? 4 : 2;
	im_width  = rlesize * im_mag;
	im_patches = im_width / 32;

	if ( !im_header() )
		return 1;

	for( y = 0; y < rlesize; y += 32/im_mag )  {
fprintf(stderr,"y=%d\n", y);
		if( feof(stdin) )
			return 1;
		im_write(y);
	}

	if ( !im_close() )
	    return 1;

	return 0;
}


#ifdef never
d98 5
a102 27
	/* Parse options. */

	while ( (c = getopt( argc, argv, "b:h" )) != EOF )
	    {
		switch( c )
		    {
		case 'b':		/* user-specified background */
			bgflag = true;

			switch( toupper( (int)optarg[0] ) )
			    {
			case 'W':	/* White */
				bgpixel.red = bgpixel.green = bgpixel.blue = 255;
				break;

			case 'B':	/* Black */
				bgpixel.red = bgpixel.green = bgpixel.blue = 0;
				break;

			default:
				(void)fprintf( stderr,
				"rle-im: background `%c' unknown\n",
				(int)optarg[0]
				    );
				bgflag = false;
				break;
			}
d104 15
a118 2

		case 'h':		/* halftone instead of dither */
d127 6
a132 3
	if ( argv[optind] == NULL )
	    file_name = "-";
	else	{
d134 1
a134 3

		if ( freopen( argv[optind], "r", stdin ) == NULL )
		    {
d136 2
a137 3
			"rle-im: cannot open \"%s\" for reading\n",
			argv[optind]
			    );
d143 1
a143 4
	    {
		(void)fprintf( stderr, "rle-im: too many arguments\n" );
		return false;
	}
a146 1
#endif
d148 6
d155 38
d217 2
a218 2
	(void)putchar(im_patches);	/* hsize (# patches across) */
	(void)putchar(im_patches);	/* vsize (# patches down) */
d227 3
a229 2
	int y1;
	register int x, x1;
d235 7
a241 2
		if( fread( line, 1, rlesize, stdin ) != rlesize )
			bzero( line, rlesize );
d250 1
a250 1
					    line[rlesize-1-((x + x1) / im_mag)];
d280 1
a280 1
	for ( x1 = 0; x1 < im_patches; ++x1 )  {
@


1.1
log
@Initial revision
@
text
@d2 22
a23 13
	rle-imagen -- convert RLE image file to imPRESS bitmap

	last edit:	86/10/05	D A Gwyn

	SCCS ID:	@@(#)rle-im.c	1.1

	Borrows heavily from Gary Moss's "rle-fb" utility and
	Steve Hawley's & Geoffrey Cooper's "traceconv" program.

	The image is printed upside down to simplify the arithmetic
	(necessary due to stupid RLE file format design).
*/

d25 1
a25 1
static char	SCCS_ID[] = "@@(#)rle-im.c	1.1";	/* string for "what" */
a27 1
#include	<ctype.h>
a29 2
/*#include	<std.h>*/

d69 1
d79 4
a82 5
static bool	get_args();
static bool	im_close();
static bool	im_dither();
static bool	im_header();
static bool	im_write();
a84 1

d89 1
a89 1
	register int	scan_ln;
d110 6
a115 1
	(void)im_write();
d125 1
a125 1
static bool
d195 1
a195 1
static bool
d225 3
a227 2
static bool
im_write()
a228 1
	int y;
d233 5
a237 10
	for( y = 0; y < rlesize; y += 32/im_mag )  {
fprintf(stderr,"y=%d\n", y);
		if( feof(stdin) )
			return 1;
		/* Process one 32-bit high output swath */
		for ( y1 = 0; y1 < 32; y1 += im_mag )
		{
			/* Obtain a single line of 8-bit pixels */
			if( fread( line, 1, rlesize, stdin ) != rlesize )
				bzero( line, rlesize );
d239 4
a242 5
			/* construct im_mag scans of Imagen swath */
			for ( x = 0; x < im_width; x += 32 )
				for ( my = 0; my < im_mag; ++my )
				{
					register long	b = 0L;	/* image bits */
d244 3
a246 4
					for ( x1 = 0; x1 < 32; x1 += im_mag )
					{
						register int	level =
						    line[rlesize-1-((x + x1) / im_mag)];
d248 9
a256 3
						for ( mx = 0; mx < im_mag; ++mx )
						{
							b <<= 1;
d258 10
a267 7
							if ( im_dither(	x + x1 + mx,
							y + y1 + my,
							level
							    )
								)
								    b |= 1L;
						}
a268 2

					swath[y1 + my][x / 32] = b;
d270 2
d273 1
d275 4
a278 5
		/* output the swath */
		for ( x1 = 0; x1 < im_patches; ++x1 )
			for ( y1 = 0; y1 < 32; ++y1 )
			{
				register long	b = swath[y1][x1];
d280 5
a284 5
				(void)putchar( (int)(b >> 24) & 0xFF );
				(void)putchar( (int)(b >> 16) & 0xFF );
				(void)putchar( (int)(b >> 8) & 0xFF );
				(void)putchar( (int)b & 0xFF );
			}
a285 2

	return true;
d288 1
a288 14

static bool
im_dither( x, y, level )
register int	x, y;		/* coords of page point position */
int		level;		/* grey level (0..255) */
{
	if ( pattern == halftone && y % 16 >= 8 )
	    x += 4;			/* ameliorate grid regularity */

	return (u_char)level < pattern[x % 8][y % 8];
}


static bool
@
