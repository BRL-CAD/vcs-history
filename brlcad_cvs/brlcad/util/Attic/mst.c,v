head	1.18;
access;
symbols
	ansi-20040405-merged:1.14.2.2
	postmerge-20040405-ansi:1.16
	premerge-20040404-ansi:1.15
	postmerge-autoconf:1.15
	autoconf-freeze:1.14.10.2
	premerge-autoconf:1.15
	postmerge-20040315-windows:1.15
	premerge-20040315-windows:1.15
	windows-20040315-freeze:1.14.4.1
	autoconf-20031203:1.14
	autoconf-20031202:1.14
	autoconf-branch:1.14.0.10
	phong-branch:1.14.0.8
	photonmap-branch:1.14.0.6
	rel-6-1-DP:1.14
	windows-branch:1.14.0.4
	rel-6-0-2:1.12
	ansi-branch:1.14.0.2
	rel-6-0-1-branch:1.12.0.2
	hartley-6-0-post:1.13
	hartley-6-0-pre:1.12
	rel-6-0-1:1.12
	rel-6-0:1.12
	rel-5-4:1.9
	offsite-5-3-pre:1.11
	rel-5-3:1.9
	rel-5-2:1.9
	rel-5-1-branch:1.9.0.2
	rel-5-1:1.9
	rel-5-0:1.9
	rel-5-0-beta:1.9
	rel-4-5:1.6
	ctj-4-5-post:1.6
	ctj-4-5-pre:1.6;
locks; strict;
comment	@ * @;


1.18
date	2004.05.21.14.57.43;	author morrison;	state dead;
branches;
next	1.17;

1.17
date	2004.05.10.15.30.50;	author erikg;	state Exp;
branches;
next	1.16;

1.16
date	2004.04.05.05.46.02;	author morrison;	state Exp;
branches;
next	1.15;

1.15
date	2004.02.02.17.39.45;	author morrison;	state Exp;
branches;
next	1.14;

1.14
date	2002.08.20.17.08.58;	author jra;	state Exp;
branches
	1.14.2.1
	1.14.4.1
	1.14.10.1;
next	1.13;

1.13
date	2002.08.15.20.56.11;	author hartley;	state Exp;
branches;
next	1.12;

1.12
date	2001.08.10.20.57.06;	author butler;	state Exp;
branches;
next	1.11;

1.11
date	2000.09.01.03.23.50;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	2000.08.23.19.04.35;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	98.12.30.05.00.59;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	98.09.14.15.59.23;	author bparker;	state Exp;
branches;
next	1.7;

1.7
date	98.06.25.07.17.25;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	97.02.28.20.20.40;	author pjt;	state Exp;
branches;
next	1.5;

1.5
date	96.11.27.20.25.08;	author pjt;	state Exp;
branches;
next	1.4;

1.4
date	96.11.27.19.09.11;	author pjt;	state Exp;
branches;
next	1.3;

1.3
date	96.11.27.17.36.51;	author pjt;	state Exp;
branches;
next	1.2;

1.2
date	96.11.26.21.21.07;	author pjt;	state Exp;
branches;
next	1.1;

1.1
date	96.11.26.16.43.44;	author pjt;	state Exp;
branches;
next	;

1.14.2.1
date	2002.09.19.18.02.37;	author morrison;	state Exp;
branches;
next	1.14.2.2;

1.14.2.2
date	2004.03.17.21.23.25;	author morrison;	state Exp;
branches;
next	;

1.14.4.1
date	2004.03.11.23.52.30;	author morrison;	state Exp;
branches;
next	;

1.14.10.1
date	2004.02.12.19.43.10;	author erikg;	state Exp;
branches;
next	1.14.10.2;

1.14.10.2
date	2004.03.15.14.08.12;	author erikg;	state Exp;
branches;
next	;


desc
@     Minimum Spanning Tree
@


1.18
log
@moved to src/util/
@
text
@/*
 *			M S T . C
 *
 *	Construct a minimum spanning tree using Prim's Algorithm
 *
 *	After reading in a graph, the program builds and maintains
 *	a priority queue of "bridges" between the gradually expanding
 *	MST and each of the vertices not yet in the MST.  In this
 *	context, vertices are classified as "civilized" (i.e. in the
 *	MST) and "uncivilized" (not yet in the MST).
 *
 *  Author -
 *	Paul J. Tanenbaum
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1996-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/util/mst.c,v 1.17 2004/05/10 15:30:50 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif


#include <stdio.h>
#ifdef HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include "machine.h"
#include "externs.h"			/* for getopt() */
#include "bu.h"
#include "redblack.h"

/************************************************************************
 *									*
 *			The data structures				*
 *									*
 ************************************************************************/
struct vertex
{
    long		v_magic;
    long		v_index;
    char		*v_label;
    int			v_civilized;
    struct bu_list	v_neighbors;
    struct bridge	*v_bridge;
};
#define	VERTEX_NULL	((struct vertex *) 0)
#define	VERTEX_MAGIC	0x6d737476

struct bridge
{
    long		b_magic;
    unsigned long	b_index;	/* automatically generated (unique) */
    double		b_weight;
    struct vertex	*b_vert_civ;
    struct vertex	*b_vert_unciv;
};
#define	BRIDGE_NULL	((struct bridge *) 0)
#define	BRIDGE_MAGIC	0x6d737462

static bu_rb_tree		*prioq;		/* Priority queue of bridges */
#define	PRIOQ_INDEX	0
#define	PRIOQ_WEIGHT	1

struct neighbor
{
    struct bu_list	l;
    struct vertex	*n_vertex;
    double		n_weight;
};
#define	n_magic		l.magic
#define	NEIGHBOR_NULL	((struct neighbor *) 0)
#define	NEIGHBOR_MAGIC	0x6d73746e

static int		debug = 1;

/************************************************************************
 *									*
 *	  Helper routines for manipulating the data structures		*
 *									*
 ************************************************************************/

/*
 *			     M K _ B R I D G E ( )
 *
 */
struct bridge *mk_bridge (struct vertex *vcp, struct vertex *vup, double weight)
{
    static unsigned long	next_index = 0;
    struct bridge		*bp;

    /*
     *	XXX Hope that unsigned long is sufficient to ensure
     *	uniqueness of bridge indices.
     */

    BU_CKMAG(vup, VERTEX_MAGIC, "vertex");

    bp = (struct bridge *) bu_malloc(sizeof(struct bridge), "bridge");

    bp -> b_magic = BRIDGE_MAGIC;
    bp -> b_index = ++next_index;
    bp -> b_weight = weight;
    bp -> b_vert_civ = vcp;
    bp -> b_vert_unciv = vup;

    return (bp);
}
#define	mk_init_bridge(vp)	(mk_bridge(VERTEX_NULL, (vp), 0.0))
#define	is_finite_bridge(bp)	((bp) -> b_vert_civ != VERTEX_NULL)
#define	is_infinite_bridge(bp)	((bp) -> b_vert_civ == VERTEX_NULL)

/*
 *			   F R E E _ B R I D G E ( )
 *
 *	N.B. - It is up to the calling routine to free
 *		the b_vert_civ and b_vert_unciv members of bp.
 */
void free_bridge (struct bridge *bp)
{
    BU_CKMAG(bp, BRIDGE_MAGIC, "bridge");
    bu_free((genptr_t) bp, "bridge");
}

/*
 *			  P R I N T _ B R I D G E ( )
 *
 */
void print_bridge (struct bridge *bp)
{
    BU_CKMAG(bp, BRIDGE_MAGIC, "bridge");

    bu_log(" bridge <x%x> %d... <x%x> and <x%x>, weight = %g\n",
	bp, bp -> b_index,
	bp -> b_vert_civ, bp -> b_vert_unciv, bp -> b_weight);
}

/*
 *			   P R I N T _ P R I O Q ( )
 */
#define	print_prioq()						\
{								\
    bu_log("----- The priority queue -----\n");			\
    bu_rb_walk(prioq, PRIOQ_WEIGHT, print_bridge, INORDER);	\
    bu_log("------------------------------\n\n");		\
}

/*
 *			     M K _ V E R T E X ( )
 *
 */
struct vertex *mk_vertex (long int index, char *label)
{
    struct vertex	*vp;

    vp = (struct vertex *) bu_malloc(sizeof(struct vertex), "vertex");

    vp -> v_magic = VERTEX_MAGIC;
    vp -> v_index = index;
    vp -> v_label = label;
    vp -> v_civilized = 0;
    BU_LIST_INIT(&(vp -> v_neighbors));
    vp -> v_bridge = mk_init_bridge(vp);

    return (vp);
}

/*
 *			  P R I N T _ V E R T E X ( )
 *
 */
void print_vertex (void *v, int depth)
{
    struct vertex	*vp = (struct vertex *) v;
    struct neighbor	*np;

    BU_CKMAG(vp, VERTEX_MAGIC, "vertex");

    bu_log(" vertex <x%x> %d '%s' %s...\n",
	vp, vp -> v_index, vp -> v_label,
	vp -> v_civilized ? "civilized" : "uncivilized");
    for (BU_LIST_FOR(np, neighbor, &(vp -> v_neighbors)))
    {
	BU_CKMAG(np, NEIGHBOR_MAGIC, "neighbor");
	BU_CKMAG(np -> n_vertex, VERTEX_MAGIC, "vertex");

	bu_log("  is a neighbor <x%x> of vertex <x%x> %d '%s' at cost %g\n",
	    np, np -> n_vertex,
	    np -> n_vertex -> v_index, np -> n_vertex -> v_label,
	    np -> n_weight);
    }
}

/*
 *			   F R E E _ V E R T E X ( )
 *
 *	N.B. - This routine frees the v_bridge member of vp.
 */
void free_vertex (struct vertex *vp)
{
    BU_CKMAG(vp, VERTEX_MAGIC, "vertex");
    free_bridge(vp -> v_bridge);
    bu_free((genptr_t) vp, "vertex");
}

/*
 *			   M K _ N E I G H B O R ( )
 *
 */
struct neighbor *mk_neighbor (struct vertex *vp, double weight)
{
    struct neighbor	*np;

    np = (struct neighbor *) bu_malloc(sizeof(struct neighbor), "neighbor");

    np -> n_magic = NEIGHBOR_MAGIC;
    np -> n_vertex = vp;
    np -> n_weight = weight;

    return (np);
}

/************************************************************************
 *									*
 *	    The comparison callbacks for libredblack(3)			*
 *									*
 ************************************************************************/

/*
 *		C O M P A R E _ V E R T E X _ I N D I C E S ( )
 */
int compare_vertex_indices (void *v1, void *v2)
{
    struct vertex	*vert1 = (struct vertex *) v1;
    struct vertex	*vert2 = (struct vertex *) v2;

    BU_CKMAG(vert1, VERTEX_MAGIC, "vertex");
    BU_CKMAG(vert2, VERTEX_MAGIC, "vertex");

    return (vert1 -> v_index  -  vert2 -> v_index);
}

/*
 *		 C O M P A R E _ V E R T E X _ L A B E L S ( )
 */
int compare_vertex_labels (void *v1, void *v2)
{
    struct vertex	*vert1 = (struct vertex *) v1;
    struct vertex	*vert2 = (struct vertex *) v2;

    BU_CKMAG(vert1, VERTEX_MAGIC, "vertex");
    BU_CKMAG(vert2, VERTEX_MAGIC, "vertex");
    if (vert1 -> v_label == '\0')
    {
	bu_log("compare_vertex_labels: null label in vertex <x%x> %d\n",
	    vert1, vert1 -> v_index);
	exit (1);
    }
    if (vert2 -> v_label == '\0')
    {
	bu_log("compare_vertex_labels: null label in vertex <x%x> %d\n",
	    vert2, vert2 -> v_index);
	exit (1);
    }

    if (*(vert1 -> v_label) < *(vert2 -> v_label))
	return -1;
    else if (*(vert1 -> v_label) > *(vert2 -> v_label))
	return 1;
    else
	return (strcmp(vert1 -> v_label, vert2 -> v_label));
}

/*
 *		C O M P A R E _ B R I D G E _ W E I G H T S ( )
 */
int compare_bridge_weights (void *v1, void *v2)
{
    double		delta;
    struct bridge	*b1 = (struct bridge *) v1;
    struct bridge	*b2 = (struct bridge *) v2;

    BU_CKMAG(b1, BRIDGE_MAGIC, "bridge");
    BU_CKMAG(b2, BRIDGE_MAGIC, "bridge");

    if (is_infinite_bridge(b1))
	if (is_infinite_bridge(b2))
	    return 0;
	else
	    return 1;
    else if (is_infinite_bridge(b2))
	return -1;

    delta = b1 -> b_weight  -  b2 -> b_weight;
    return ((delta <  0.0) ? -1 :
	    (delta == 0.0) ?  0 :
			      1);
}

/*
 *		C O M P A R E _ B R I D G E _ I N D I C E S ( )
 */
int compare_bridge_indices (void *v1, void *v2)
{
    struct bridge	*b1 = (struct bridge *) v1;
    struct bridge	*b2 = (struct bridge *) v2;

    BU_CKMAG(b1, BRIDGE_MAGIC, "bridge");
    BU_CKMAG(b2, BRIDGE_MAGIC, "bridge");

    if (b1 -> b_index < b2 -> b_index)
	return -1;
    else if (b1 -> b_index == b2 -> b_index)
	return 0;
    else
	return 1;
}

/************************************************************************
 *									*
 *	    A similar comparison function				*
 *									*
 ************************************************************************/

/*
 *		       C O M P A R E _ W E I G H T S ( )
 */
#define	compare_weights(w1, w2)					\
(								\
    ((w1) <= 0.0) ?						\
    (								\
	((w2) <= 0.0) ?						\
	    0 :							\
	    1							\
    ) :								\
    (								\
	((w2) <= 0.0) ?						\
	    -1 :						\
	    ((w1) < (w2)) ?					\
		-1 :						\
		((w1) == (w2)) ?				\
		    0 :						\
		    1						\
    )								\
)

/************************************************************************
 *									*
 *	  Routines for manipulating the dictionary and priority queue	*
 *									*
 ************************************************************************/

/*
 *			 L O O K U P _ V E R T E X ( )
 */
struct vertex *lookup_vertex(bu_rb_tree *dict, long int index, char *label)
{
    int			rc;	/* Return code from bu_rb_insert() */
    struct vertex	*qvp;	/* The query */
    struct vertex	*vp;	/* Value to return */

    /*
     *	Prepare the dictionary query
     */
    qvp = mk_vertex(index, label);

    /*
     *	Perform the query by attempting an insertion...
     *	If the query succeeds (i.e., the insertion fails!),
     *	then we have our vertex.
     *	Otherwise, we must create a new vertex.
     */
    switch (rc = bu_rb_insert(dict, (void *) qvp))
    {
	case -1:
	    vp = (struct vertex *) bu_rb_curr1(dict);
	    free_vertex(qvp);
	    break;
	case 0:
	    vp = qvp;
	    break;
	default:
	    bu_log("bu_rb_insert() returns %d:  This should not happen\n", rc);
	    exit (1);
    }

    return (vp);
}

/*
 *			  A D D _ T O _ P R I O Q ( )
 *
 */
void add_to_prioq (void *v, int depth)
{
    struct vertex	*vp = (struct vertex *) v;

    BU_CKMAG(vp, VERTEX_MAGIC, "vertex");
    BU_CKMAG(vp -> v_bridge, BRIDGE_MAGIC, "bridge");

    bu_rb_insert(prioq, (void *) (vp -> v_bridge));
}

/*
 *			D E L _ F R O M _ P R I O Q ( )
 *
 */
void del_from_prioq (struct vertex *vp)
{
    BU_CKMAG(vp, VERTEX_MAGIC, "vertex");
    BU_CKMAG(vp -> v_bridge, BRIDGE_MAGIC, "bridge");

    if (debug)
	bu_log("del_from_prioq(<x%x>... bridge <x%x> %d)\n",
	    vp, vp -> v_bridge, vp -> v_bridge -> b_index);
    if (bu_rb_search(prioq, PRIOQ_INDEX, (void *) (vp -> v_bridge)) == NULL)
    {
	bu_log("del_from_prioq: Cannot find bridge <x%x>.", vp -> v_bridge);
	bu_log("  This should not happen\n");
	exit (1);
    }
    bu_rb_delete(prioq, PRIOQ_INDEX);
}

/*
 *			   E X T R A C T _ M I N ( )
 *
 */
struct bridge *extract_min (void)
{
    struct bridge	*bp;

    bp = (struct bridge *) bu_rb_min(prioq, PRIOQ_WEIGHT);
    if (bp != BRIDGE_NULL)
    {
	BU_CKMAG(bp, BRIDGE_MAGIC, "bridge");
	bu_rb_delete(prioq, PRIOQ_WEIGHT);
    }
    return (bp);
}

/************************************************************************
 *									*
 *	  More or less vanilla-flavored stuff for MST			*
 *									*
 ************************************************************************/

/*
 *			      G E T _ E D G E ( )
 */
int get_edge (FILE *fp, long int *index, char **label, double *w, int numeric)

    	    
    	       		/* Indices of edge endpoints */
    	        	/* Labels of edge endpoints */
      	   		/* Weight */
   	        	/* Use indices instead of labels? */

{
    char		*bp;
    static int		line_nm = 0;
    struct bu_vls	buf;

    bu_vls_init_if_uninit(&buf);
    for ( ; ; )
    {
	++line_nm;
	bu_vls_trunc(&buf, 0);
	if (bu_vls_gets(&buf, fp) == -1)
	    return (0);
	bp = bu_vls_addr(&buf);
	while ((*bp == ' ') || (*bp == '\t'))
	    ++bp;
	if (*bp == '#')
	    continue;
	if (numeric)
	{
	    if (sscanf(bp, "%ld%ld%lg", &index[0], &index[1], w) != 3)
	    {
		bu_log("Illegal input on line %d: '%s'\n", line_nm, bp);
		return (-1);
	    }
	    else
	    {
		label[0] = label[1] = NULL;
		break;
	    }
	}
	else
	{
	    char	*bep;

	    for (bep = bp; (*++bep != ' ') && (*bep != '\t'); ++bep)
		if (*bep == '\0')
		{
		    bu_log("Illegal input on line %d: '%s'\n",
			line_nm, bu_vls_addr(&buf));
		    return (-1);
		}
	    *bep = '\0';
	    label[0] = bu_strdup(bp);

	    for (bp = bep + 1; (*bp == ' ') || (*bp == '\t'); ++bp)
		if (*bep == '\0')
		{
		    bu_log("Illegal input on line %d: '%s'\n",
			line_nm, bu_vls_addr(&buf));
		    return (-1);
		}
	    for (bep = bp; (*++bep != ' ') && (*bep != '\t'); ++bep)
		if (*bep == '\0')
		{
		    bu_log("Illegal input on line %d: '%s'\n",
			line_nm, bu_vls_addr(&buf));
		    return (-1);
		}
	    *bep = '\0';
	    label[1] = bu_strdup(bp);

	    if (sscanf(bep + 1, "%lg", w) != 1)
	    {
		bu_log("Illegal input on line %d: '%s'\n",
		    line_nm, bu_vls_addr(&buf));
		return (-1);
	    }
	    else
	    {
		index[0] = index[1] = -1;
		break;
	    }
	}
    }
    return (1);
}

/*
 *			   P R I N T _ U S A G E ( )
 */
void print_usage (void)
{
#define OPT_STRING	"n?"

    bu_log("Usage: 'mst [-n]'\n");
}

/*
 *                                M A I N ( )
 */
int
main (int argc, char **argv)
{
    char		*label[2];	/* Labels of edge endpoints */
    int			ch;		/* Command-line character */
    int			i;
    int			numeric = 0;	/* Use vertex indices (vs. labels)? */
    long		index[2];	/* Indices of edge endpoints */
    double		weight;		/* Edge weight */
    bu_rb_tree		*dictionary;	/* Dictionary of vertices */
    struct bridge	*bp;		/* The current bridge */
    struct vertex	*up;		/* An uncivilized neighbor of vup */
    struct vertex	*vcp;		/* The civilized vertex of bp */
    struct vertex	*vup;		/* The uncvilized vertex of bp */
    struct vertex	*vertex[2];	/* The current edge */
    struct neighbor	*neighbor[2];	/* Their neighbors */
    struct neighbor	*np;		/* A neighbor of vup */
    int			(*po[2])();	/* Priority queue order functions */

    while ((ch = getopt(argc, argv, OPT_STRING)) != EOF)
	switch (ch)
	{
	    case 'n':
		numeric = 1;
		break;
	    case '?':
	    default:
		print_usage();
		exit (ch != '?');
		return(0);
	}

    /*
     *	Initialize the dictionary
     */
    dictionary = bu_rb_create1("Dictionary of vertices",
		    numeric ? compare_vertex_indices
			    : compare_vertex_labels);
    bu_rb_uniq_on1(dictionary);

    /*
     *	Read in the graph
     */
    while (get_edge(stdin, index, label, &weight, numeric))
    {
	for (i = 0; i < 2; ++i)		/* For each end of the edge... */
	{
	    vertex[i] = lookup_vertex(dictionary, index[i], label[i]);
	    neighbor[i] = mk_neighbor(VERTEX_NULL, weight);
	    BU_LIST_INSERT(&(vertex[i] -> v_neighbors), &(neighbor[i] -> l));
	}
	neighbor[0] -> n_vertex = vertex[1];
	neighbor[1] -> n_vertex = vertex[0];
    }

    /*
     *	Initialize the priority queue
     */
    po[PRIOQ_INDEX] = compare_bridge_indices;
    po[PRIOQ_WEIGHT] = compare_bridge_weights;
    prioq = bu_rb_create("Priority queue of bridges", 2, po);
    bu_rb_walk1(dictionary, add_to_prioq, INORDER);

    if (debug)
    {
	print_prioq();
	bu_rb_walk1(dictionary, print_vertex, INORDER);
    }
    
    /*
     *	Grow a minimum spanning tree, using Prim's algorithm...
     *
     *	While there exists a min-weight bridge (to a vertex v) in the queue
     *	    Dequeue the bridge
     *	    If the weight is finite
     *	        Output the bridge
     *	    Mark v as civilized
     *	    For every uncivilized neighbor u of v
     *	        if uv is cheaper than u's current bridge
     *		    dequeue u's current bridge
     *		    enqueue bridge(uv)
     */
    weight = 0.0;
    while ((bp = extract_min()) != BRIDGE_NULL)
    {
	if (debug)
	{
	    bu_log("extracted min-weight bridge <x%x>, leaving...\n", bp);
	    print_prioq();
	}

	BU_CKMAG(bp, BRIDGE_MAGIC, "bridge");
	vcp = bp -> b_vert_civ;
	vup = bp -> b_vert_unciv;
	BU_CKMAG(vup, VERTEX_MAGIC, "vertex");

	if (is_finite_bridge(bp))
	{
	    BU_CKMAG(vcp, VERTEX_MAGIC, "vertex");
	    if (numeric)
		(void) printf("%ld %ld %g\n",
		    vcp -> v_index, vup -> v_index, bp -> b_weight);
	    else
		(void) printf("%s %s %g\n",
		    vcp -> v_label, vup -> v_label, bp -> b_weight);
	    weight += bp -> b_weight;
	}
	free_bridge(bp);
	vup -> v_civilized = 1;

	if (debug)
	{
	    bu_log("Looking for uncivilized neighbors of...\n");
	    print_vertex((void *) vup, 0);
	}
	while (BU_LIST_WHILE(np, neighbor, &(vup -> v_neighbors)))
	{
	    BU_CKMAG(np, NEIGHBOR_MAGIC, "neighbor");
	    up = np -> n_vertex;
	    BU_CKMAG(up, VERTEX_MAGIC, "vertex");

	    if (up -> v_civilized == 0)
	    {
		BU_CKMAG(up -> v_bridge, BRIDGE_MAGIC, "bridge");
		if (compare_weights(np -> n_weight,
				    up -> v_bridge -> b_weight) < 0)
		{
		    del_from_prioq(up);
		    if (debug)
		    {
			bu_log("After the deletion of bridge <x%x>...\n",
			    up -> v_bridge);
			print_prioq();
		    }
		    up -> v_bridge -> b_vert_civ = vup;
		    up -> v_bridge -> b_weight = np -> n_weight;
		    add_to_prioq((void *) up, 0);
		    if (debug)
		    {
			bu_log("Reduced bridge <x%x> weight to %g\n",
			    up -> v_bridge,
			    up -> v_bridge -> b_weight);
			print_prioq();
		    }
		}
		else if (debug)
		    bu_log("bridge <x%x>'s weight of %g stands up\n",
			    up -> v_bridge, up -> v_bridge -> b_weight);
	    }
	    else if (debug)
		bu_log("Skipping civilized neighbor <x%x>\n", up);
	    BU_LIST_DEQUEUE(&(np -> l));
	}
    }
    bu_log("MST weight: %g\n", weight);
    return 0;
}
@


1.17
log
@change conf.h to a wrapped config.h
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/util/mst.c,v 1.16 2004/04/05 05:46:02 morrison Exp $ (ARL)";
@


1.16
log
@merge of ansi-6-0-branch into head
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d32 5
a36 1
#include "conf.h"
@


1.15
log
@update copyright to include span through 2003
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/mst.c,v 1.14 2002/08/20 17:08:58 jra Exp $ (ARL)";
d98 1
a98 6
struct bridge *mk_bridge (vcp, vup, weight)

struct vertex	*vcp;
struct vertex	*vup;
double		weight;

d130 1
a130 4
void free_bridge (bp)

struct bridge	*bp;

d140 1
a140 4
void print_bridge (bp)

struct bridge	*bp;

d163 1
a163 5
struct vertex *mk_vertex (index, label)

long	index;
char	*label;

d183 1
a183 5
void print_vertex (v, depth)

void	*v;
int	depth;

d210 1
a210 4
void free_vertex (vp)

struct vertex	*vp;

d221 1
a221 5
struct neighbor *mk_neighbor (vp, weight)

struct vertex	*vp;
double		weight;

d243 1
a243 5
int compare_vertex_indices (v1, v2)

void	*v1;
void	*v2;

d257 1
a257 5
int compare_vertex_labels (v1, v2)

void	*v1;
void	*v2;

d288 1
a288 5
int compare_bridge_weights (v1, v2)

void	*v1;
void	*v2;

d314 1
a314 5
int compare_bridge_indices (v1, v2)

void	*v1;
void	*v2;

d367 1
a367 6
struct vertex *lookup_vertex(dict, index, label)

bu_rb_tree	*dict;
long	index;
char	*label;

d405 1
a405 5
void add_to_prioq (v, depth)

void	*v;
int	depth;

d419 1
a419 4
void del_from_prioq (vp)

struct vertex	*vp;

d440 1
a440 1
struct bridge *extract_min ()
d462 1
a462 1
int get_edge (fp, index, label, w, numeric)
d464 5
a468 5
FILE	*fp;
long	*index;		/* Indices of edge endpoints */
char	**label;	/* Labels of edge endpoints */
double	*w;		/* Weight */
int	numeric;	/* Use indices instead of labels? */
d550 1
a550 1
void print_usage ()
d561 1
a561 5
main (argc, argv)

int	argc;
char	*argv[];

@


1.14
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d25 1
a25 1
 *	This software is Copyright (C) 1996 by the United States Army
d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/mst.c,v 1.12 2001/08/10 20:57:06 butler Exp $ (ARL)";
@


1.14.4.1
log
@sync to HEAD...
@
text
@d25 1
a25 1
 *	This software is Copyright (C) 1996-2004 by the United States Army
d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/util/mst.c,v 1.15 2004/02/02 17:39:45 morrison Exp $ (ARL)";
@


1.14.10.1
log
@merge from HEAD
@
text
@d25 1
a25 1
 *	This software is Copyright (C) 1996-2004 by the United States Army
d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/mst.c,v 1.15 2004/02/02 17:39:45 morrison Exp $ (ARL)";
@


1.14.10.2
log
@merge from head
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/mst.c,v 1.14.10.1 2004/02/12 19:43:10 erikg Exp $ (ARL)";
@


1.14.2.1
log
@Initial ANSIfication
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/mst.c,v 1.14 2002/08/20 17:08:58 jra Exp $ (ARL)";
d98 6
a103 1
struct bridge *mk_bridge (struct vertex *vcp, struct vertex *vup, double weight)
d135 4
a138 1
void free_bridge (struct bridge *bp)
d148 4
a151 1
void print_bridge (struct bridge *bp)
d174 5
a178 1
struct vertex *mk_vertex (long int index, char *label)
d198 5
a202 1
void print_vertex (void *v, int depth)
d229 4
a232 1
void free_vertex (struct vertex *vp)
d243 5
a247 1
struct neighbor *mk_neighbor (struct vertex *vp, double weight)
d269 5
a273 1
int compare_vertex_indices (void *v1, void *v2)
d287 5
a291 1
int compare_vertex_labels (void *v1, void *v2)
d322 5
a326 1
int compare_bridge_weights (void *v1, void *v2)
d352 5
a356 1
int compare_bridge_indices (void *v1, void *v2)
d409 6
a414 1
struct vertex *lookup_vertex(bu_rb_tree *dict, long int index, char *label)
d452 5
a456 1
void add_to_prioq (void *v, int depth)
d470 4
a473 1
void del_from_prioq (struct vertex *vp)
d494 1
a494 1
struct bridge *extract_min (void)
d516 1
a516 1
int get_edge (FILE *fp, long int *index, char **label, double *w, int numeric)
d518 5
a522 5
    	    
    	       		/* Indices of edge endpoints */
    	        	/* Labels of edge endpoints */
      	   		/* Weight */
   	        	/* Use indices instead of labels? */
d604 1
a604 1
void print_usage (void)
d615 5
a619 1
main (int argc, char **argv)
@


1.14.2.2
log
@sync branch with HEAD
@
text
@d25 1
a25 1
 *	This software is Copyright (C) 1996-2004 by the United States Army
d29 1
a29 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
@


1.13
log
@Converted from K&R to ANSI C - RFH
@
text
@d98 6
a103 1
struct bridge *mk_bridge (struct vertex *vcp, struct vertex *vup, double weight)
d135 4
a138 1
void free_bridge (struct bridge *bp)
d148 4
a151 1
void print_bridge (struct bridge *bp)
d174 5
a178 1
struct vertex *mk_vertex (long int index, char *label)
d198 5
a202 1
void print_vertex (void *v, int depth)
d229 4
a232 1
void free_vertex (struct vertex *vp)
d243 5
a247 1
struct neighbor *mk_neighbor (struct vertex *vp, double weight)
d269 5
a273 1
int compare_vertex_indices (void *v1, void *v2)
d287 5
a291 1
int compare_vertex_labels (void *v1, void *v2)
d322 5
a326 1
int compare_bridge_weights (void *v1, void *v2)
d352 5
a356 1
int compare_bridge_indices (void *v1, void *v2)
d409 6
a414 1
struct vertex *lookup_vertex(bu_rb_tree *dict, long int index, char *label)
d452 5
a456 1
void add_to_prioq (void *v, int depth)
d470 4
a473 1
void del_from_prioq (struct vertex *vp)
d494 1
a494 1
struct bridge *extract_min (void)
d516 1
a516 1
int get_edge (FILE *fp, long int *index, char **label, double *w, int numeric)
d518 5
a522 5
    	    
    	       		/* Indices of edge endpoints */
    	        	/* Labels of edge endpoints */
      	   		/* Weight */
   	        	/* Use indices instead of labels? */
d604 1
a604 1
void print_usage (void)
d615 5
a619 1
main (int argc, char **argv)
@


1.12
log
@Misc compiler warnings eliminated
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/mst.c,v 1.11 2000/09/01 03:23:50 mike Exp $ (ARL)";
d98 1
a98 6
struct bridge *mk_bridge (vcp, vup, weight)

struct vertex	*vcp;
struct vertex	*vup;
double		weight;

d130 1
a130 4
void free_bridge (bp)

struct bridge	*bp;

d140 1
a140 4
void print_bridge (bp)

struct bridge	*bp;

d163 1
a163 5
struct vertex *mk_vertex (index, label)

long	index;
char	*label;

d183 1
a183 5
void print_vertex (v, depth)

void	*v;
int	depth;

d210 1
a210 4
void free_vertex (vp)

struct vertex	*vp;

d221 1
a221 5
struct neighbor *mk_neighbor (vp, weight)

struct vertex	*vp;
double		weight;

d243 1
a243 5
int compare_vertex_indices (v1, v2)

void	*v1;
void	*v2;

d257 1
a257 5
int compare_vertex_labels (v1, v2)

void	*v1;
void	*v2;

d288 1
a288 5
int compare_bridge_weights (v1, v2)

void	*v1;
void	*v2;

d314 1
a314 5
int compare_bridge_indices (v1, v2)

void	*v1;
void	*v2;

d367 1
a367 6
struct vertex *lookup_vertex(dict, index, label)

bu_rb_tree	*dict;
long	index;
char	*label;

d405 1
a405 5
void add_to_prioq (v, depth)

void	*v;
int	depth;

d419 1
a419 4
void del_from_prioq (vp)

struct vertex	*vp;

d440 1
a440 1
struct bridge *extract_min ()
d462 1
a462 1
int get_edge (fp, index, label, w, numeric)
d464 5
a468 5
FILE	*fp;
long	*index;		/* Indices of edge endpoints */
char	**label;	/* Labels of edge endpoints */
double	*w;		/* Weight */
int	numeric;	/* Use indices instead of labels? */
d550 1
a550 1
void print_usage ()
d561 1
a561 5
main (argc, argv)

int	argc;
char	*argv[];

@


1.11
log
@
Lint fix
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/mst.c,v 1.10 2000/08/23 19:04:35 mike Exp $ (ARL)";
d34 5
@


1.10
log
@
const RCSid
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/mst.c,v 1.9 1998/12/30 05:00:59 mike Exp $ (ARL)";
d609 1
d768 1
@


1.9
log
@LibRedBlack now lives in LIBBU
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/mst.c,v 1.8 1998/09/14 15:59:23 bparker Exp $ (ARL)";
@


1.8
log
@*- fix typos
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/mst.c,v 1.7 1998/06/25 07:17:25 mike Exp $ (ARL)";
d67 1
a67 1
static rb_tree		*prioq;		/* Priority queue of bridges */
d161 1
a161 1
    rb_walk(prioq, PRIOQ_WEIGHT, print_bridge, INORDER);	\
d406 1
a406 1
rb_tree	*dict;
d411 1
a411 1
    int			rc;	/* Return code from rb_insert() */
d426 1
a426 1
    switch (rc = rb_insert(dict, (void *) qvp))
d429 1
a429 1
	    vp = (struct vertex *) rb_curr1(dict);
d436 1
a436 1
	    bu_log("rb_insert() returns %d:  This should not happen\n", rc);
d458 1
a458 1
    rb_insert(prioq, (void *) (vp -> v_bridge));
d476 1
a476 1
    if (rb_search(prioq, PRIOQ_INDEX, (void *) (vp -> v_bridge)) == NULL)
d482 1
a482 1
    rb_delete(prioq, PRIOQ_INDEX);
d493 1
a493 1
    bp = (struct bridge *) rb_min(prioq, PRIOQ_WEIGHT);
d497 1
a497 1
	rb_delete(prioq, PRIOQ_WEIGHT);
d621 1
a621 1
    rb_tree		*dictionary;	/* Dictionary of vertices */
d647 1
a647 1
    dictionary = rb_create1("Dictionary of vertices",
d650 1
a650 1
    rb_uniq_on1(dictionary);
d672 2
a673 2
    prioq = rb_create("Priority queue of bridges", 2, po);
    rb_walk1(dictionary, add_to_prioq, INORDER);
d678 1
a678 1
	rb_walk1(dictionary, print_vertex, INORDER);
@


1.7
log
@Mods for compiling on sun4
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/mst.c,v 1.6 1997/02/28 20:20:40 pjt Exp $ (ARL)";
d712 1
a712 1
		(void) printf("%d %d %g\n",
@


1.6
log
@Added a pair of casts for function args
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/mst.c,v 1.5 1996/11/27 20:25:08 pjt Exp pjt $ (ARL)";
d599 1
a599 1
void print_usage (void)
@


1.5
log
@Default behavior is to read vertices as strings (v_label)
instead of ints (v_index).  Previous behavior is now attained
with the -n option
@
text
@d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/mst.c,v 1.3 1996/11/27 17:36:51 pjt Exp pjt $ (ARL)";
d725 1
a725 1
	    print_vertex(vup);
d748 1
a748 1
		    add_to_prioq(up);
@


1.4
log
@Cleaned up diagnostic prints, comment blocks, etc.
@
text
@d34 2
a35 1
#include <machine.h>
d41 1
a41 1
 *		The data structures					*
d48 1
d81 1
a81 1
static int		debug = 0;
d169 1
a169 1
struct vertex *mk_vertex (index)
d172 1
d181 1
d204 2
a205 2
    bu_log(" vertex %d <x%x> %s...\n",
	vp -> v_index, vp,
d212 4
a215 2
	bu_log("  is a neighbor <x%x> of vertex <x%x> %d at cost %g\n",
	    np, np -> n_vertex, np -> n_vertex -> v_index, np -> n_weight);
d262 1
a262 1
 *		      C O M P A R E _ V E R T I C E S ( )
d264 1
a264 1
int compare_vertices (v1, v2)
d280 35
d377 17
a393 16
{								\
    double	delta;						\
								\
    if ((w1) <= 0.0)						\
	if ((w2) <= 0.0)					\
	    return 0;						\
	else							\
	    return 1;						\
    else if ((w2) <= 0.0)					\
	return -1;						\
    								\
    delta = (w1) - (w2);					\
    return ((delta <  0.0) ? -1 :				\
	    (delta == 0.0) ?  0 :				\
			      1);				\
}
d404 1
a404 1
struct vertex *lookup_vertex(dict, index)
d408 1
d418 1
a418 1
    qvp = mk_vertex(index);
d511 1
a511 1
int get_edge (fp, index, w)
d515 1
d517 1
d536 1
a536 1
	if (sscanf(bp, "%ld%ld%lg", &index[0], &index[1], w) != 3)
d538 10
a547 2
	    bu_log("Illegal input on line %d: '%s'\n", line_nm, bp);
	    return (-1);
d550 42
a591 1
	    break;
d596 13
d615 2
d618 1
d631 13
d645 1
a645 1
     *	Initialize the dictionary and the priority queue
d647 3
a649 1
    dictionary = rb_create1("Dictionary of vertices", compare_vertices);
a650 4
    po[PRIOQ_INDEX] = compare_bridge_indices;
    po[PRIOQ_WEIGHT] = compare_bridge_weights;
    prioq = rb_create("Priority queue of bridges", 2, po);
    rb_walk1(dictionary, add_to_prioq, INORDER);
d655 1
a655 1
    while (get_edge(stdin, index, &weight))
d659 1
a659 1
	    vertex[i] = lookup_vertex(dictionary, index[i]);
d667 8
d711 6
a716 2
	    (void) printf("%d %d %g\n",
		vcp -> v_index, vup -> v_index, bp -> b_weight);
@


1.3
log
@Seems to work!
@
text
@d4 8
d29 1
a29 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/mst.c,v 1.2 1996/11/26 21:21:07 pjt Exp pjt $ (ARL)";
d79 2
d88 1
a88 1
 *			  M K _ B R I D G E ( )
d107 1
a107 2
    bu_log("mk_bridge(<x%x>, <x%x>, %g) assigning index %d\n",
	vcp, vup, weight, next_index + 1);
d123 1
a123 1
 *		   F R E E _ B R I D G E ( )
d138 1
a138 1
 *		     P R I N T _ B R I D G E ( )
d154 1
a154 1
 *		    P R I N T _ P R I O Q ( )
d164 1
a164 1
 *			M K _ V E R T E X ( )
d186 1
a186 1
 *		     P R I N T _ V E R T E X ( )
d214 1
a214 1
 *		   F R E E _ V E R T E X ( )
d229 1
a229 1
 *			  M K _ N E I G H B O R ( )
d256 1
a256 1
 *		C O M P A R E _ V E R T I C E S ( )
d274 1
a274 1
 *	    C O M P A R E _ B R I D G E _ W E I G H T S ( )
a290 3
	{
	    bu_log("compare_bridge_weights: <x%x> %d == <x%x> %d\n",
		b1, b1 -> b_index, b2, b2 -> b_index);
a291 1
	}
a292 3
	{
	    bu_log("compare_bridge_weights: <x%x> %d > <x%x> %d\n",
		b1, b1 -> b_index, b2, b2 -> b_index);
a293 1
	}
a294 3
    {
	bu_log("compare_bridge_weights: <x%x> %d < <x%x> %d\n",
		b1, b1 -> b_index, b2, b2 -> b_index);
a295 1
    }
a297 4
    bu_log("compare_bridge_weights: <x%x> %d %s <x%x> %d\n",
	b1, b1 -> b_index,
	((delta < 0.0) ? "<" : (delta == 0.0) ? "==" : ">"),
	b2, b2 -> b_index);
d304 1
a304 1
 *	    C O M P A R E _ B R I D G E _ I N D I C E S ( )
d326 5
a330 1
int compare_weights (w1, w2)
d332 19
a350 18
double	w1;
double	w2;

{
    double	delta;

    if (w1 <= 0.0)
	if (w2 <= 0.0)
	    return 0;
	else
	    return 1;
    else if (w2 <= 0.0)
	return -1;
    
    delta = w1 - w2;
    return ((delta <  0.0) ? -1 :
	    (delta == 0.0) ?  0 :
			      1);
d360 1
a360 1
 *			L O O K U P _ V E R T E X ( )
d401 1
a401 1
 *		     A D D _ T O _ P R I O Q ( )
d419 1
a419 1
 *		     D E L _ F R O M _ P R I O Q ( )
d430 3
a432 2
    bu_log("del_from_prioq(<x%x>... bridge <x%x> %d)\n",
	vp, vp -> v_bridge, vp -> v_bridge -> b_index);
d443 1
a443 1
 *		     E X T R A C T _ M I N ( )
d466 1
a466 1
 *			G E T _ E D G E ( )
d526 4
a544 7
    /*
     *	Initialize the priority queue
     */
    po[PRIOQ_INDEX] = compare_bridge_indices;
    po[PRIOQ_WEIGHT] = compare_bridge_weights;
    prioq = rb_create("Priority queue of bridges", 2, po);
    rb_walk1(dictionary, add_to_prioq, INORDER);
d546 5
a550 2
    print_prioq();
    rb_walk1(dictionary, print_vertex, INORDER);
d553 11
a563 2
     *	Grow a minimum spanning tree,
     *	using Prim's algorithm
d568 5
a572 2
	bu_log("We've extracted bridge <x%x>, which leaves...\n", bp);
	print_prioq();
a580 1
	    print_bridge(bp);
d582 1
a582 1
	    bu_log(" ...edge %d %d of weight %g\n",
d589 5
a593 2
	bu_log("Looking for uncivilized neighbors of...\n");
	print_vertex(vup);
a595 1
	    bu_log("np = <x%x>\n", np);
d607 6
a612 3
		    bu_log("After the deletion of bridge <x%x>...\n",
			up -> v_bridge);
		    print_prioq();
d616 7
a622 4
		    bu_log("Reduced bridge <x%x> weight to %g\n",
			up -> v_bridge,
			up -> v_bridge -> b_weight);
		    print_prioq();
d624 1
a624 1
		else
d628 1
a628 1
	    else
d633 1
a633 1
    bu_log(" ...overall weight: %g\n", weight);
a634 25

/*
 *	For each edge in the input stream
 *	    For each vertex of the edge
 *		Get its vertex structure
 *		    If vertex is not in the dictionary
 *			Create the vertex struc
 *			Record the vertex struc in the dictionary
 *		    Return the vertex struc
 *		Create a neighbor structure and install it
 *	    Record each vertex as the other's neighbor
 *
 *	For every vertex v
 *	    Enqueue an infinite-weight bridge to v
 *
 *	While there exists a min-weight bridge (to a vertex v) in the queue
 *	    Dequeue the bridge
 *	    If the weight is finite
 *	        Output the bridge
 *	    Mark v as civilized
 *	    For every uncivilized neighbor u of v
 *	        if uv is cheaper than u's current bridge
 *		    dequeue u's current bridge
 *		    enqueue bridge(uv)
 */
@


1.2
log
@COB 26 Nov
Overhauled to actually implement Prim's Algorithm
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/mst.c,v 1.1 1996/11/26 16:43:44 pjt Exp pjt $ (ARL)";
d49 1
d58 2
d88 7
a94 1
    struct bridge	*bp;
d96 3
d102 1
d129 26
d265 1
a265 1
 *	    C O M P A R E _ B R I D G E S ( )
d267 1
a267 1
int compare_bridges (v1, v2)
d282 3
d286 1
d288 3
d292 1
d294 3
d298 1
d301 52
a352 3
    return ((delta <  0) ? -1 :
	    (delta == 0) ?  0 :
			    1);
d395 1
a395 1
	    bu_log("rb_insert() returns %d:  This shouldn't happen\n", rc);
a428 1

d432 3
a434 1
    if (rb_search1(prioq, (void *) (vp -> v_bridge)) == NULL)
d440 1
a440 1
    rb_delete1(prioq);
d451 1
a451 1
    bp = (struct bridge *) rb_min(prioq, 0);
d455 1
a456 1
    rb_delete1(prioq);
d520 1
a541 1

d545 3
a547 1
    prioq = rb_create1("Priority queue of bridges", compare_bridges);
d549 3
d557 1
d560 3
d570 1
d572 1
a572 1
	    bu_log(" ...edge %d %d of weight %d\n",
d574 1
d579 3
a581 1
	for (BU_LIST_FOR(np, neighbor, &(vup -> v_neighbors)))
d583 1
d588 1
a588 1
	    if (up -> v_civilized)
d591 2
a592 1
		if (np -> n_weight < up -> v_bridge -> b_weight)
d595 3
d601 4
d606 3
d610 2
d615 1
@


1.1
log
@Initial revision
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
d39 3
a41 1
    struct bu_list	v_halfedges;
d46 1
a46 1
struct edge
d48 4
a51 3
    long		e_magic;
    struct halfedge	*e_half[2];	/* The edge's ends */
    double		e_weight;	/*  "    "    weight */
d53 2
a54 2
#define	EDGE_NULL	((struct edge *) 0)
#define	EDGE_MAGIC	0x6d737465
d56 3
a58 1
struct halfedge
d61 2
a62 14
    struct edge		*h_edge;	/* The parent edge */
    struct halfedge	*h_mate;	/* The other half of this edge */
    struct vertex	*h_vertex;	/* The vertex */
    struct vertex	*h_neighbor;	/* The adjacent vertex */
};
#define h_magic		l.magic
#define	HALFEDGE_NULL	((struct halfedge *) 0)
#define	HALFEDGE_MAGIC	0x6d737468

struct prioq_entry
{
    long		q_magic;
    struct halfedge	*q_hedge;	/* The (far half of the) edge */
    double		q_weight;	/*  "    "    weight */
d64 3
a66 2
#define	PRIOQENTRY_NULL	((struct prioq_entry *) 0)
#define	PRIOQENTRY_MAGIC	0x6d737471
d70 1
a70 1
 *	    The comparison callbacks for libredblack(3)			*
d75 2
a76 1
 *		C O M P A R E _ V E R T I C E S ( )
d78 1
a78 1
int compare_vertices (v1, v2)
d80 3
a82 2
void	*v1;
void	*v2;
d85 3
a87 2
    struct vertex	*vert1 = (struct vertex *) v1;
    struct vertex	*vert2 = (struct vertex *) v2;
d89 4
a92 2
    BU_CKMAG(vert1, VERTEX_MAGIC, "vertex");
    BU_CKMAG(vert2, VERTEX_MAGIC, "vertex");
d94 1
a94 1
    return (vert1 -> v_index  -  vert2 -> v_index);
d96 3
d101 4
a104 1
 *	    C O M P A R E _ P R I O Q _ E N T R I E S ( )
d106 1
a106 1
int compare_prioq_entries (v1, v2)
d108 1
a108 2
void	*v1;
void	*v2;
d111 2
a112 11
    double	delta;
    struct prioq_entry	*q1 = (struct prioq_entry *) v1;
    struct prioq_entry	*q2 = (struct prioq_entry *) v2;

    BU_CKMAG(q1, PRIOQENTRY_MAGIC, "priority-queue entry");
    BU_CKMAG(q2, PRIOQENTRY_MAGIC, "priority-queue entry");

    delta = q1 -> q_weight  -  q2 -> q_weight;
    return ((delta <  0) ? -1 :
	    (delta == 0) ?  0 :
			    1);
a114 6
/************************************************************************
 *									*
 *	  Helper routines for manipulating the data structures		*
 *									*
 ************************************************************************/

d119 4
a122 1
struct vertex *mk_vertex ()
d129 4
a132 1
    BU_LIST_INIT(&(vp -> v_halfedges));
d147 2
a148 5
    struct vertex	*vp = (struct vertex *) v;	/* The vertex */
    struct halfedge	*hp;			/* One of its edge ends */
    struct halfedge	*mp;			/* Its mate */
    struct vertex	*np;			/* The neighbor */
    struct edge		*ep;			/* The edge */
d152 4
a155 2
    bu_log(" vertex %d...\n", vp -> v_index);
    for (BU_LIST_FOR(hp, halfedge, &(vp -> v_halfedges)))
d157 2
a158 4
	BU_CKMAG(hp, HALFEDGE_MAGIC, "halfedge");

	ep = hp -> h_edge;
	BU_CKMAG(ep, EDGE_MAGIC, "edge");
d160 2
a161 8
	mp = hp -> h_mate;
	BU_CKMAG(mp, HALFEDGE_MAGIC, "halfedge");

	np = hp -> h_neighbor;
	BU_CKMAG(np, VERTEX_MAGIC, "vertex");

	bu_log("  shares edge <x%x> (<x%x>, <x%x>) with %d at cost %g\n",
	    ep, hp, mp, np -> v_index, ep -> e_weight);
d168 1
d176 1
d181 1
a181 1
 *			  M K _ E D G E ( )
d184 1
a184 3
struct edge *mk_edge ()
{
    struct edge	*ep;
d186 2
a187 6
    ep = (struct edge *) bu_malloc(sizeof(struct edge), "edge");

    ep -> e_magic = EDGE_MAGIC;

    return (ep);
}
a188 5
/*
 *			M K _ H A L F E D G E ( )
 *
 */
struct halfedge *mk_halfedge ()
d190 1
a190 1
    struct halfedge	*hp;
d192 1
a192 1
    hp = (struct halfedge *) bu_malloc(sizeof(struct halfedge), "halfedge");
d194 3
a196 2
    BU_LIST_INIT(&(hp -> l));
    hp -> h_magic = HALFEDGE_MAGIC;
d198 1
a198 1
    return (hp);
d201 6
d208 1
a208 2
 *		     P R I N T _ H A L F E D G E ( )
 *
d210 1
a210 1
void print_halfedge (hp)
d212 2
a213 1
struct halfedge	*hp;
d216 2
a217 1
    BU_CKMAG(hp, HALFEDGE_MAGIC, "halfedge");
d219 2
a220 6
    bu_log(" halfedge <x%x>...\n {\n", hp);
    bu_log("     edge   =   <x%x>...\n", hp -> h_edge);
    bu_log("     mate   =   <x%x>...\n", hp -> h_mate);
    bu_log("     vertex  =  <x%x>...\n", hp -> h_vertex);
    bu_log("     neighbor = <x%x>...\n }\n", hp -> h_neighbor);
}
d222 1
a222 14
/*
 *		    M K _ P R I O Q _ E N T R Y ( )
 *
 */
struct prioq_entry *mk_prioq_entry ()
{
    struct prioq_entry	*qp;

    qp = (struct prioq_entry *) bu_malloc(sizeof(struct prioq_entry),
					    "priority-queue entry");

    qp -> q_magic = PRIOQENTRY_MAGIC;

    return (qp);
d226 1
a226 1
 *			G E T _ E D G E ( )
d228 1
a228 1
int get_edge (fp, vertex, w)
d230 2
a231 3
FILE	*fp;
long	*vertex;		/* Indices of edge endpoints */
double	*w;			/* Weight */
d234 14
a247 4
    char		*bp;
    static int		line_nm = 0;
    struct edge		*ep;
    struct bu_vls	buf;
d249 4
a252 21
    bu_vls_init_if_uninit(&buf);
    for ( ; ; )
    {
	++line_nm;
	bu_vls_trunc(&buf, 0);
	if (bu_vls_gets(&buf, fp) == -1)
	    return (0);
	bp = bu_vls_addr(&buf);
	while ((*bp == ' ') || (*bp == '\t'))
	    ++bp;
	if (*bp == '#')
	    continue;
	if (sscanf(bp, "%ld%ld%lg", &vertex[0], &vertex[1], w) != 3)
	{
	    bu_log("Illegal input on line %d: '%s'\n", line_nm, bp);
	    return (-1);
	}
	else
	    break;
    }
    return (1);
d255 6
d277 1
a277 2
    qvp = mk_vertex();
    qvp-> v_index = index;
d303 2
a304 1
 *		E N Q U E U E _ H A L F E D G E ( )
d306 1
a306 1
int enqueue_halfedge (prioq, hp)
d308 2
a309 2
rb_tree		*prioq;
struct halfedge	*hp;
d312 1
a312 2
    int			rc;	/* Return code from rb_insert() */
    struct prioq_entry	*qp;	/* The queue entry */
d314 2
a315 7
    /*
     *	Prepare the queue query
     */
    qp = mk_prioq_entry();
    qp -> q_hedge = hp;
    BU_CKMAG(hp -> h_edge, EDGE_MAGIC, "edge");
    qp -> q_weight = hp -> h_edge -> e_weight;
d317 1
a317 8
    /*
     *	Perform the query by attempting an insertion...
     *	If the query succeeds (i.e., the insertion fails!),
     *	then we have our vertex.
     *	Otherwise, we must create a new vertex.
     */
    bu_log(" enqueueing halfedge <x%x>\n", hp);
    return (rb_insert(prioq, (void *) qp));
d321 2
a322 1
 *		D E Q U E U E _ H A L F E D G E ( )
d324 5
a328 1
struct halfedge *dequeue_halfedge (prioq)
d330 11
a340 1
rb_tree	*prioq;
d342 5
d348 1
a348 1
    struct prioq_entry	*qp;
d350 5
a354 2
    qp = (struct prioq_entry *) rb_min(prioq, 0);
    BU_CKMAG(qp, PRIOQENTRY_MAGIC, "priority-queue entry");
d356 1
a356 3
    bu_log(" dequeueing");
    print_halfedge(qp -> q_hedge);
    return (qp -> q_hedge);
d359 43
d409 1
a409 2
    int			n;		/* Number of vertices in the graph */
    long		vertex[2];	/* Indices of edge endpoints */
d412 7
a418 6
    rb_tree		*prioq;		/* Priority queue of edges */
    struct vertex	*vp;		/* The current vertex */
    struct vertex	*np;		/* The neighbor of vp */
    struct edge		*ep;
    struct halfedge	*hp;		/* The current half edge */
    struct halfedge	*mp;		/* The mate (other end) of hp */
a424 1
    prioq = rb_create1("Priority queue of edges", compare_prioq_entries);
d429 1
a429 1
    while (get_edge(stdin, vertex, &weight))
a430 1
	ep = mk_edge();
d433 3
a435 6
	    hp = mk_halfedge();
	    vp = lookup_vertex(dictionary, vertex[i]);
	    hp -> h_edge = ep;
	    hp -> h_vertex = vp;
	    ep -> e_half[i] = hp;
	    BU_LIST_INSERT(&(vp -> v_halfedges), &(hp -> l));
d437 2
a438 8
	ep -> e_half[0] -> h_mate = ep -> e_half[1];
	ep -> e_half[1] -> h_mate = ep -> e_half[0];
	ep -> e_half[0] -> h_neighbor = ep -> e_half[1] -> h_vertex;
	ep -> e_half[1] -> h_neighbor = ep -> e_half[0] -> h_vertex;
	bu_log("Got edge <x%x>, comprised of...\n", ep);
	print_halfedge(ep -> e_half[0]);
	print_halfedge(ep -> e_half[1]);
	ep -> e_weight = weight;
a439 1
    n = dictionary -> rbt_nm_nodes;
d442 1
a442 1
     *	Show us what you got
d444 2
a445 5
#if 1
    bu_log("Residual adjaceny lists\n");
    rb_walk1(dictionary, print_vertex, INORDER);
    bu_log("-----------------------\n");
#endif
d451 1
a451 1
    for (i = 1; i < n; ++i)
d453 6
a458 2
	bu_log("%d: vp is now <x%x> %d", i, vp, vp -> v_index);
	for (BU_LIST_FOR(hp, halfedge, &(vp -> v_halfedges)))
d460 3
a462 7
	    BU_CKMAG(hp, HALFEDGE_MAGIC, "halfedge");
	    mp = hp -> h_mate;
	    BU_CKMAG(mp, HALFEDGE_MAGIC, "halfedge");

	    enqueue_halfedge(prioq, hp);
	    bu_log("discarding halfedge <x%x>, mate of <x%x>\n", mp, hp);
	    BU_LIST_DEQUEUE(&(mp -> l));
d464 2
a465 2
	hp = dequeue_halfedge(prioq);
	BU_CKMAG(hp, HALFEDGE_MAGIC, "halfedge");
d467 19
a485 10
	np = hp -> h_neighbor;
	BU_CKMAG(np, VERTEX_MAGIC, "vertex");
	bu_log(" and np is <x%x> %d\n", np, np -> v_index);
	BU_CKMAG(hp -> h_edge, EDGE_MAGIC, "edge");

	printf("OK, we're adding edge <x%x> (%d,%d) of weight %g\n",
	    hp -> h_edge, vp -> v_index, np -> v_index,
	    hp -> h_edge -> e_weight);
	fflush(stdout);
	vp = np;
d490 1
a490 2
 *	For each edge on input
 *	    Create the edge struc
d497 15
a511 11
 *		Record the vertex in the edge's vertexlist
 *		Record the edge in the vertex's edgelist
 *	    Record the weight in the edge
 *
 *    Pick any vertex v
 *    While you haven't reached every vertex
 *	For each of v's edges
 *	    Add the edge to the priority queue
 *	    Delete edge from the other endpoint's edgelist
 *	Dequeue a min-weight edge
 *	Set v to the edge's not-yet-reached vertex
@
