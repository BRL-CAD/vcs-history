head	11.10;
access;
symbols
	ansi-20040405-merged:11.7.2.1
	postmerge-20040405-ansi:11.8
	premerge-20040404-ansi:11.7
	postmerge-autoconf:11.7
	autoconf-freeze:11.7
	premerge-autoconf:11.7
	postmerge-20040315-windows:11.7
	premerge-20040315-windows:11.7
	windows-20040315-freeze:11.7
	autoconf-20031203:11.7
	autoconf-20031202:11.7
	autoconf-branch:11.7.0.10
	phong-branch:11.7.0.8
	photonmap-branch:11.7.0.6
	rel-6-1-DP:11.7
	windows-branch:11.7.0.4
	rel-6-0-2:11.5
	ansi-branch:11.7.0.2
	rel-6-0-1-branch:11.5.0.2
	hartley-6-0-post:11.6
	hartley-6-0-pre:11.5
	rel-6-0-1:11.5
	rel-6-0:11.5
	rel-5-4:11.2
	offsite-5-3-pre:11.4
	rel-5-3:11.2
	rel-5-2:11.2
	rel-5-1-branch:11.2.0.2
	rel-5-1:11.2
	rel-5-0:11.2
	rel-5-0-beta:11.2
	rel-4-5:11.2
	ctj-4-5-post:11.2
	ctj-4-5-pre:11.2
	rel-4-4:11.1;
locks; strict;
comment	@ * @;


11.10
date	2004.05.21.14.57.55;	author morrison;	state dead;
branches;
next	11.9;

11.9
date	2004.05.10.15.30.51;	author erikg;	state Exp;
branches;
next	11.8;

11.8
date	2004.04.05.05.46.02;	author morrison;	state Exp;
branches;
next	11.7;

11.7
date	2002.08.20.17.09.03;	author jra;	state Exp;
branches
	11.7.2.1;
next	11.6;

11.6
date	2002.08.15.20.56.15;	author hartley;	state Exp;
branches;
next	11.5;

11.5
date	2001.08.10.20.57.07;	author butler;	state Exp;
branches;
next	11.4;

11.4
date	2000.09.01.03.23.58;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	2000.08.23.19.04.55;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	96.12.13.15.05.51;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.12.54;	author mike;	state Rel4_4;
branches;
next	1.7;

1.7
date	95.01.04.09.23.45;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	94.11.15.03.38.31;	author cjohnson;	state Exp;
branches;
next	1.5;

1.5
date	94.11.14.22.19.04;	author cjohnson;	state Exp;
branches;
next	1.4;

1.4
date	94.09.22.04.19.08;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	94.08.23.15.06.01;	author gdurf;	state Exp;
branches;
next	1.2;

1.2
date	92.11.19.15.28.19;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	92.11.19.15.16.19;	author mike;	state Exp;
branches;
next	;

11.7.2.1
date	2002.09.19.18.02.42;	author morrison;	state Exp;
branches;
next	;


desc
@Program to paste rectangles into pix files
@


11.10
log
@moved to src/util/
@
text
@/*
 *		P I X P A S T E . C
 *
 * pixpaste will insert an arbitrary pix file into another pixfile.
 * If the image being pasted does not fit within the destination file
 * then the excess is discarded.
 *
 *  Author -
 *	Christopher T. Johnson
 *	September 12, 1992
 *  
 *  Source -
 *	Paladin Software
 *	P.O. Box 187
 *	Aberdeen, MD	21001-0187
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1992 by Paladin Software
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/util/pixpaste.c,v 11.9 2004/05/10 15:30:51 erikg Exp $";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"
#include "externs.h"		/* For getopt and malloc */
#include "bu.h"
#include "vmath.h"
#include "bn.h"

static int	org_width = 512;	/* Default file sizes 512x512 */
static int	org_height = 512;
static int	paste_width = 512;
static int	paste_height = 512;
static int	base_x = 0;		/* Default to lower left corner */
static int	base_y = 0;
static int	Verbose = 0;

#if defined(SYSV)
static char	stdiobuf[4*1024*1024];
#endif
static FILE	*orig, *paste;
static char	*orig_name, *paste_name;
static int	paste_autosize = 0;
static int	orig_autosize = 0;
static int	paste_isfile = 0;
static int	orig_isfile = 0;
static int	num_bytes = 3;

static char usage[] = "\
pixpaste: Copyright (C) 1992 Paladin Software\n\
pixpaste: All rights reserved\n\
pixpaste: Usage: pixpaste [-v] [-h] [-H] [-a] [-A] [-# num_bytes]\n\
		 [-s orig_square_size] [-w orig_width] [-n orig_height]\n\
		 [-S paste_square_size] [-W paste_width] [-N paste_height]\n\
		 [-x horizontal] [-y vertical] orig_file paste_file\n\
	A '-' can be used to indicate stdin for orig_file or paste_file\n";

int
get_args(register int argc, register char **argv)
{
	register int c;

	while ( (c = getopt(argc, argv, "vahHs:w:n:S:W:N:x:y:#:" )) != EOF) {
		switch (c) {
		case 'v':
			Verbose = 1;
			break;
		case 'a':
			orig_autosize = 1;
			break;
		case 'A':
			paste_autosize = 1;
			break;
		case 'h':
			org_width = org_height = 1024;
			orig_autosize = 0;
			break;
		case 'H':
			paste_width = paste_height = 1024;
			paste_autosize = 0;
			break;
		case 's':
			org_width = org_height = atoi(optarg);
			orig_autosize = 0;
			break;
		case 'S':
			paste_width = paste_height = atoi(optarg);
			paste_autosize = 0;
			break;
		case 'w':
			org_width = atoi(optarg);
			orig_autosize = 0;
			break;
		case 'W':
			paste_width = atoi(optarg);
			paste_autosize = 0;
			break;
		case 'n':
			org_height = atoi(optarg);
			orig_autosize = 0;
			break;
		case 'N':
			paste_height = atoi(optarg);
			paste_autosize = 0;
			break;
		case 'x':
			base_x = atoi(optarg);
			break;
		case 'y':
			base_y = atoi(optarg);
			break;
		case '#':
			num_bytes = atoi(optarg);
			break;
		default:		/* '?' */
			return(0);
		}
	}
	if (optind >= argc ) {
		return(0);
	} else {
		orig_name = argv[optind];
		if (strcmp(orig_name,"-") == 0) {
			if (isatty(fileno(stdin))) return(0);
			orig = stdin;
		} else {
			if ((orig = fopen(orig_name, "r")) == NULL ) {
				perror(orig_name);
				(void)fprintf(stderr,
				    "pixpaste: cannot open \"%s\" for reading\n",
				    orig_name);
				return(0);
			}
			orig_isfile = 1;
		}
	}
	if (++optind >= argc ) {
		return(0);
	} else {
		paste_name = argv[optind];
		if (strcmp(paste_name, "-") == 0) {
			if (isatty(fileno(stdin))) return(0);
			paste = stdin;
			if (!orig_isfile) {
				(void)fprintf(stderr,
"pixpaste: The original file and paste file cannot both be stdin!.\n");
				return(0);
			}
		} else {
			if ((paste = fopen(paste_name, "r")) == NULL){
				perror(paste_name);
				(void)fprintf(stderr,
				"pixpaste: cannot open \"%s\" for reading",
				paste_name);
				return(0);
			}
			paste_isfile=1;
		}
	}
	return(1);	/* OK */
}

			
int
main(int argc, char **argv)
{
	unsigned char *origbuf, *pastebuf;
	unsigned char *buffer;
	register int i;
	int row, result;

	if (!get_args(argc,argv)) {
		(void)fprintf(stderr,"%s",usage);
		exit(1);
	}
	/* Should we autosize the original? */
	if (orig_isfile && orig_autosize) {
		int w,h;
		if (bn_common_file_size(&w, &h, orig_name, num_bytes)) {
			org_width = w;
			org_height = h;
		} else {
			(void) fprintf(stderr,
"pixpaste: unable to autosize \"%s\"\n",orig_name);
		}
	}

	/* Should we autosize the paste file? */
	if (paste_isfile && paste_autosize) {
		int w,h;
		if (bn_common_file_size(&w, &h, paste_name, num_bytes)) {
			paste_width = w;
			paste_height = h;
		} else {
			(void) fprintf(stderr,
"pixpaste: unable to autosize \"%s\"\n",paste_name);
		}
	}

#if defined( SYSV )
	(void) setvbuf(orig, stdiobuf, _IOFBF, sizeof(stdiobuf) );
#endif
/*
 * Spew some interesting info at the people...
 */
	if (Verbose) {
		(void) fprintf(stderr,"\
pixpaste: Copyright (C) 1992 Paladin Software\npixpaste: All rights reserved\n");
		(void) fprintf(stderr,"pixpaste: Original image %dx%d\n",
		    org_width, org_height);
		(void) fprintf(stderr,"pixpaste: Inserted image %dx%d\n",
		    paste_width, paste_height);
		(void) fprintf(stderr,"pixpaste: Inserted at %dx%d\n",
		    base_x, base_y);
	}

/*
 * Make a buffer will hold a single scan line of assuming a worst
 * case paste of 1 pixel of overlap.
 */
	if ((buffer = (unsigned char *)malloc((org_width+paste_width)*num_bytes)) == (unsigned char *)NULL ) {
		(void) fprintf(stderr, "pixpaste: Out of memory (malloc failed)\n");
		exit(2);
	}
/*
 * Set up the original buffer and the paste buffer.
 */
	if (base_x + paste_width < 0 ||
	    base_x >= org_width ||
	    base_y + paste_height < 0 ||
	    base_y >= org_height ) {
		if (Verbose) {
			(void)fprintf(stderr, "\
pixpaste: No overlap between paste and original image\n\
pixpaste: new image == original image.\n");
		}
		for (i=0; i<org_height; i++) {
			int E=0;
			result = fread(buffer, num_bytes, org_width, orig);
			if (result != org_width) {
				E=1;
				(void)fprintf(stderr,"pixpaste: original file is short.\n");
			}
			result = fwrite(buffer, num_bytes, result, stdout);
			if (!E && result != org_width) {
				perror("pixpaste: fwrite1");
				E=1;
			}
			if (E) break;
		}
		exit(0);
	}

	if (base_x < 0) {
		pastebuf = buffer;
		origbuf  = buffer - num_bytes*base_x;
	} else {
		pastebuf = buffer + num_bytes*base_x;
		origbuf  = buffer;
	}
/*
 * if the base_y scan line is below the bottom of the original
 * then we skip scan lines in the paste file.
 */
	if (base_y < 0) {
		row = base_y;
	} else {
		row = 0;
	}

	while (row < 0) {
		result = fread(pastebuf, num_bytes, paste_width, paste);
		if (result != paste_width) {
			(void)fprintf(stderr,"pixpaste: paste file is short.\n");
			row=0;
			paste_height=0;
		}
		row++;
	}
/*
 * While the current row is less than the base Y scan line move
 * scan lines from the original to stdout.
 */
	while (row < base_y) {
		result=fread(origbuf, num_bytes, org_width, orig);
		if (result != org_width) {
			(void)fprintf(stderr,"pixpaste: original image is short.\n");
			(void)fwrite(origbuf, num_bytes, result, stdout);
			exit(0);
		}
		result = fwrite(origbuf, num_bytes, org_width, stdout);
		if (result != org_width) {
			perror("pixpaste: fwrite2");
			exit(3);
		}
		row++;
	}
/*
 * Read a scan line from the original.  Read a scan line from the
 * paste. Output the composite. until paste_height is reached.
 * If EOF original STOP.  If EOF paste treat as if reached paste_height.
 */
	while (row < org_height && row < base_y+paste_height) {
		result=fread(origbuf, num_bytes, org_width, orig);
		if (result != org_width) {
			register int jj;
			for (jj=result; jj<num_bytes*org_width; jj++) {
				origbuf[jj]=0;
			}
		}
		result=fread(pastebuf, num_bytes, paste_width, paste);
		if (result != paste_width) {
			(void)fprintf(stderr,"pixpaste: paste image is short.\n");
			base_y = paste_height = 0;
		}
		result = fwrite(origbuf, num_bytes, org_width, stdout);
		if (result != org_width) {
			perror("pixpaste: fwrite3");
			exit(3);
		}
		row++;
	}
		
/*
 * Output the rest of the original file.
 */
	while (row < org_height) {
		result=fread(origbuf, num_bytes, org_width, orig);
		if (result != org_width) {
			register int jj;
			for (jj=result; jj<num_bytes*org_width; jj++) {
				origbuf[jj]=0;
			}
		}
		result = fwrite(origbuf, num_bytes, org_width, stdout);
		if (result != org_width) {
			perror("pixpaste: fwrite4");
			exit(3);
		}
		row++;
	}
	return(0);
}
@


11.9
log
@change conf.h to a wrapped config.h
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/util/pixpaste.c,v 11.8 2004/04/05 05:46:02 morrison Exp $";
@


11.8
log
@merge of ansi-6-0-branch into head
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header$";
d25 5
a29 1
#include "conf.h"
@


11.7
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/pixpaste.c,v 11.5 2001/08/10 20:57:07 butler Exp $";
d69 1
a69 3
get_args( argc, argv)
register int argc;
register char **argv;
d175 1
a175 2
main(argc, argv)
int argc; char **argv;
@


11.7.2.1
log
@Initial ANSIfication
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/pixpaste.c,v 11.7 2002/08/20 17:09:03 jra Exp $";
d69 3
a71 1
get_args(register int argc, register char **argv)
d177 2
a178 1
main(int argc, char **argv)
@


11.6
log
@Converted from K&R to ANSI C - RFH
@
text
@d69 3
a71 1
get_args(register int argc, register char **argv)
d177 2
a178 1
main(int argc, char **argv)
@


11.5
log
@Misc compiler warnings eliminated
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/pixpaste.c,v 11.4 2000/09/01 03:23:58 mike Exp $";
d69 1
a69 3
get_args( argc, argv)
register int argc;
register char **argv;
d175 1
a175 2
main(argc, argv)
int argc; char **argv;
@


11.4
log
@
Lint fix
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/pixpaste.c,v 11.3 2000/08/23 19:04:55 mike Exp $";
d28 5
d36 3
d68 1
@


11.3
log
@
const RCSid
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/pixpaste.c,v 11.2 1996/12/13 15:05:51 jra Exp $";
d167 1
@


11.2
log
@Mods to account for asize routines now in libbn.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/pixpaste.c,v 11.1 1995/01/04 10:12:54 mike Rel4_4 jra $";
@


11.1
log
@Release_4.4
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/pixpaste.c,v 1.7 95/01/04 09:23:45 mike Exp $";
d182 1
a182 1
		if (fb_common_file_size(&w, &h, orig_name, num_bytes)) {
d194 1
a194 1
		if (fb_common_file_size(&w, &h, paste_name, num_bytes)) {
@


1.7
log
@CTJ fix.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/util/RCS/pixpaste.c,v 1.6 1994/11/15 03:38:31 cjohnson Exp cjohnson $";
@


1.6
log
@Fixed a write to an input file.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/pixpaste.c,v 1.5 1994/11/14 22:19:04 cjohnson Exp cjohnson $";
d40 3
d203 3
@


1.5
log
@Fix a typo and add -# option
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/pixpaste.c,v 1.4 1994/09/22 04:19:08 mike Exp cjohnson $";
d241 1
a241 1
			result = fwrite(buffer, num_bytes, result, paste);
d243 1
a243 1
				perror("pixpaste: fwrite");
d290 1
a290 1
			perror("pixpaste: fwrite");
d315 1
a315 1
			perror("pixpaste: fwrite");
d334 1
a334 1
			perror("pixpaste: fwrite");
@


1.4
log
@Pointer problem.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/pixpaste.c,v 1.3 94/08/23 15:06:01 gdurf Exp Locker: mike $";
d46 1
d51 1
a51 1
pixpaste: Usage: pixpaste [-v] [-h] [-H] [-a] [-A]\n\
d63 1
a63 1
	while ( (c = getopt(argc, argv, "vahHs:w:n:S:W:N:x:y:" )) != EOF) {
d112 3
d179 1
a179 1
		if (fb_common_file_size(&w, &h, orig_name, 3)) {
d191 1
a191 1
		if (fb_common_file_size(&w, &h, paste_name, 3)) {
d206 1
a206 1
		(void) fprintf(stderr,"pixpaste: Original iamge %dx%d\n",
d218 1
a218 1
	if ((buffer = (unsigned char *)malloc((org_width+paste_width)*3)) == (unsigned char *)NULL ) {
d236 1
a236 1
			result = fread(buffer, 3, org_width, orig);
d241 1
a241 1
			result = fwrite(buffer, 3, result, paste);
d253 1
a253 1
		origbuf  = buffer - 3*base_x;
d255 1
a255 1
		pastebuf = buffer + 3*base_x;
d269 1
a269 1
		result = fread(pastebuf, 3, paste_width, paste);
d282 1
a282 1
		result=fread(origbuf, 3, org_width, orig);
d285 1
a285 1
			(void)fwrite(origbuf, 3, result, stdout);
d288 1
a288 1
		result = fwrite(origbuf, 3, org_width, stdout);
d301 1
a301 1
		result=fread(origbuf, 3, org_width, orig);
d303 4
a306 2
			(void)fprintf(stderr,"pixpaste: original image is short.\n");
			org_height = 0;
d308 1
a308 1
		result=fread(pastebuf, 3, paste_width, paste);
d313 1
a313 1
		result = fwrite(origbuf, 3, org_width, stdout);
d325 1
a325 1
		result=fread(origbuf, 3, org_width, orig);
d327 4
a330 3
			(void) fprintf(stderr,"pixpaste: original image is short.\n");
			(void)fwrite(origbuf,3,result,stdout);
			exit(0);
d332 1
a332 1
		result = fwrite(origbuf, 3, org_width, stdout);
@


1.3
log
@Factored ifdefs
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/pixpaste.c,v 1.2 1992/11/19 15:28:19 mike Exp gdurf $";
d214 1
a214 1
	if ((buffer = malloc((org_width+paste_width)*3)) == NULL ) {
@


1.2
log
@Added missing backslash
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/pixpaste.c,v 1.1 92/11/19 15:16:19 mike Exp Locker: mike $";
d25 2
d29 2
a30 3
extern int	getopt();
extern char	*optarg;
extern int	optind;
a31 1
unsigned char *malloc();
@


1.1
log
@Initial revision
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header:$";
d200 1
a200 1
		(void) fprintf(stderr,"
@
