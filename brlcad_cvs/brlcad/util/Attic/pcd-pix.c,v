head	11.15;
access;
symbols
	ansi-20040405-merged:11.12.2.1
	postmerge-20040405-ansi:11.13
	premerge-20040404-ansi:11.12
	postmerge-autoconf:11.12
	autoconf-freeze:11.12
	premerge-autoconf:11.12
	postmerge-20040315-windows:11.12
	premerge-20040315-windows:11.12
	windows-20040315-freeze:11.12
	autoconf-20031203:11.12
	autoconf-20031202:11.12
	autoconf-branch:11.12.0.10
	phong-branch:11.12.0.8
	photonmap-branch:11.12.0.6
	rel-6-1-DP:11.12
	windows-branch:11.12.0.4
	rel-6-0-2:11.10
	ansi-branch:11.12.0.2
	rel-6-0-1-branch:11.10.0.2
	hartley-6-0-post:11.11
	hartley-6-0-pre:11.10
	rel-6-0-1:11.10
	rel-6-0:11.10
	rel-5-4:11.5
	offsite-5-3-pre:11.7
	rel-5-3:11.5
	rel-5-2:11.5
	rel-5-1-branch:11.5.0.2
	rel-5-1:11.5
	rel-5-0:11.4
	rel-5-0-beta:11.4
	rel-4-5:11.3
	ctj-4-5-post:11.3
	ctj-4-5-pre:11.3
	rel-4-4:11.1;
locks; strict;
comment	@ * @;


11.15
date	2004.05.21.14.57.44;	author morrison;	state dead;
branches;
next	11.14;

11.14
date	2004.05.10.15.30.50;	author erikg;	state Exp;
branches;
next	11.13;

11.13
date	2004.04.05.05.46.02;	author morrison;	state Exp;
branches;
next	11.12;

11.12
date	2002.08.20.17.08.59;	author jra;	state Exp;
branches
	11.12.2.1;
next	11.11;

11.11
date	2002.08.15.20.56.11;	author hartley;	state Exp;
branches;
next	11.10;

11.10
date	2001.08.10.20.57.06;	author butler;	state Exp;
branches;
next	11.9;

11.9
date	2001.08.08.13.20.25;	author butler;	state Exp;
branches;
next	11.8;

11.8
date	2001.08.08.03.28.15;	author butler;	state Exp;
branches;
next	11.7;

11.7
date	2000.09.01.03.23.51;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	2000.08.23.19.04.36;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	99.12.30.04.16.37;	author butler;	state Exp;
branches;
next	11.4;

11.4
date	98.09.22.03.22.25;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	97.04.18.03.36.14;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	97.04.18.02.02.37;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.12.13;	author mike;	state Rel4_4;
branches;
next	1.18;

1.18
date	94.11.14.23.15.40;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	94.10.21.20.18.32;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	94.01.14.23.30.08;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	94.01.14.22.32.53;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	94.01.14.22.10.54;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	94.01.14.21.55.12;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	94.01.14.17.53.23;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	94.01.14.17.47.48;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	93.03.06.05.17.20;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	93.03.06.04.10.43;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	93.03.06.03.41.25;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	93.03.06.03.06.56;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	93.03.06.02.50.49;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	93.03.06.02.38.04;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	93.03.06.01.53.52;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	93.03.06.01.43.13;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	93.03.06.01.42.38;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	93.03.06.01.37.03;	author mike;	state Exp;
branches;
next	;

11.12.2.1
date	2002.09.19.18.02.38;	author morrison;	state Exp;
branches;
next	;


desc
@pcd-pix.c
@


11.15
log
@moved to src/util/
@
text
@/*
 *			P C D - P I X . C
 *
 *  Authors -
 *	Hadmut Danisch (original program pcdtoppm)
 *	Michael John Muuss (this adaptation)
 *  
 *  Distribution Status -
 *	Original work Copyright (c) 1992 by Hadmut Danisch.
 *	The modifications by Mike Muuss are Public Domain, Distribution Unlimited.
 *
 *  Based upon -
 *	hpcdtoppm (Hadmut's pcdtoppm) v0.3
 *
 *  Copyright (c) 1992 by Hadmut Danisch (danisch@@ira.uka.de).
 *  Permission to use and distribute this software and its
 *  documentation for noncommercial use and without fee is hereby granted,
 *  provided that the above copyright notice appear in all copies and that
 *  both that copyright notice and this permission notice appear in
 *  supporting documentation. It is not allowed to sell this software in 
 *  any way. This software is not public domain.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/util/pcd-pix.c,v 11.14 2004/05/10 15:30:50 erikg Exp $ (BRL)";
#endif

/* define DEBUG for some debugging informations, just remove the x from xDEBUG */
#define xDEBUG

/* define MELDUNG if you want to see what is happening and what takes time,
   just remove the x from xMeldung */
#define xMELDUNG

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif


#include <stdio.h>
#ifdef HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include <math.h>
#include "machine.h"
#include "externs.h"

#define own_BUsize (3*24*1024)

typedef unsigned char uBYTE;
typedef unsigned long dim;

#define BaseW ((dim)768)
#define BaseH ((dim)512)

#define SECSIZE 0x800



#define SeHead   2
#define L_Head   (1+SeHead)

#define SeBase16 18
#define L_Base16 (1+SeBase16)

#define SeBase4  72
#define L_Base4  (1+SeBase4)

#define SeBase   288
#define L_Base   (1+SeBase)


enum ERRORS { 
	E_NONE,E_READ,E_WRITE,E_INTERN,E_ARG,E_OPT,E_MEM,E_HUFF,
	    E_SEQ,E_SEQ1,E_SEQ2,E_SEQ3,E_SEQ4,E_SEQ5,E_SEQ6,E_SEQ7,E_POS,E_IMP,E_OVSKIP,
	    E_TAUTO,E_TCANT };

enum SIZES  { 
	S_UNSPEC,S_Base16,S_Base4,S_Base,S_4Base,S_16Base,S_Over };

/* Default taken when no size parameter given */
#define S_DEFAULT S_Base

struct _implane
{
	dim  mwidth,mheight,
	iwidth,iheight;
	uBYTE *im;
};
typedef struct _implane implane;

#define nullplane ((implane *) 0)


static enum ERRORS readplain(dim w, dim h, implane *l, implane *c1, implane *c2);
static void interpolate(implane *p);
static void halve(implane *p);
static void ycctorgb(dim w, dim h, implane *l, implane *c1, implane *c2);
#if 0
static void readlpt();
#endif
static void readhqt(dim w, dim h, int n);
static void decode(dim w, dim h, implane *f, implane *f1, implane *f2, int autosync);
static void druckeid(void);
static long Skip4Base(void);

static FILE *fin=0,*fout=0;
static char *pcdname=0;
static char nbuf[100];
static uBYTE sbuffer[SECSIZE];
static int do_bw;

/* Using preprocessor for inline-procs */
#ifdef DEBUG

static long bufpos;

#define SEEK(x) { if (fseek(fin,((x) * SECSIZE),0)) error(E_READ);\
                  fprintf(stderr,"S-Position %x\n",ftell(fin)); }
#define RPRINT  {fprintf(stderr,"R-Position %x\n",ftell(fin));}

#define READBUF   (bufpos=ftell(fin),fread(sbuffer,sizeof(sbuffer),1,fin))


#else

#define SEEK(x) { if (fseek(fin,((x) * SECSIZE),0)) error(E_READ);}
#define RPRINT
#define READBUF   fread(sbuffer,sizeof(sbuffer),1,fin)

#endif


#ifdef MELDUNG
#define melde(x) fprintf(stderr,x)
#else
#define melde(x)
#endif

#define EREADBUF {if(READBUF < (unsigned)1) error(E_READ);}

#define SKIP(n)  { if (fseek(fin,(n),1)) error(E_READ);}
#define SKIPr(n) { if (fseek(fin,(n),1)) return(E_READ);}

static int clipped_low=0;
static int clipped_high=0;
#define NORM(x) { if(x<0) {x=0; clipped_low++;} \
		else if (x>255) {x=255; clipped_high++;}}

static double lum_mul = 1.0;

static void error(enum ERRORS e)
{

	switch(e)
	{
	case E_NONE:   
		return;
	case E_IMP:    
		fprintf(stderr,"Sorry, Not yet implemented.\n"); 
		break;
	case E_READ:   
		fprintf(stderr,"Error while reading.\n"); 
		break;
	case E_WRITE:  
		fprintf(stderr,"Error while writing.\n"); 
		break;
	case E_INTERN: 
		fprintf(stderr,"Internal error.\n"); 
		break;
	case E_ARG:    
		fprintf(stderr,"Usage: pcd-pix [options] file.pcd\n");
		fprintf(stderr,"Options:	(file name may be just frame number)\n");
		fprintf(stderr,"     -x Overskip mode (tries to improve color quality.)\n");
		fprintf(stderr,"     -i Give some information from fileheader\n");
		fprintf(stderr,"     -b write .bw file instead of .pix\n");
		fprintf(stderr,"     -0 Extract thumbnails from Overview file\n");
		fprintf(stderr,"     -1 Extract  -w192  -n128 from Image file [Base/16]\n");
		fprintf(stderr,"     -2 Extract  -w384  -n256 from Image file [Base/4]\n");
		fprintf(stderr,"     -3 Extract  -w768  -n512 from Image file [Base].  Default size.\n");
		fprintf(stderr,"     -4 Extract -w1536 -n1024 from Image file [4Base]\n");
		fprintf(stderr,"     -5 Extract -w3072 -n2048 from Image file [16Base]\n");
		fprintf(stderr,"     -p Pipe output to pix-fb automaticly\n");
		fprintf(stderr,"     -l # Multiply luminance value by # (brighten dark photos) default=1\n");
		fprintf(stderr,"     -h Just print header dimensions\n");
		break;
	case E_OPT:    
		fprintf(stderr,"These Options are not allowed together.\n");
		break;
	case E_MEM:    
		fprintf(stderr,"Not enough memory !\n"); 
		break;
	case E_HUFF:   
		fprintf(stderr,"Error in Huffman-Code-Table\n"); 
		break;
	case E_SEQ:    
		fprintf(stderr,"Error in Huffman-Sequence\n"); 
		break;
	case E_SEQ1:   
		fprintf(stderr,"Error1 in Huffman-Sequence\n"); 
		break;
	case E_SEQ2:   
		fprintf(stderr,"Error2 in Huffman-Sequence\n"); 
		break;
	case E_SEQ3:   
		fprintf(stderr,"Error3 in Huffman-Sequence\n"); 
		break;
	case E_SEQ4:   
		fprintf(stderr,"Error4 in Huffman-Sequence\n"); 
		break;
	case E_SEQ5:   
		fprintf(stderr,"Error5 in Huffman-Sequence\n"); 
		break;
	case E_SEQ6:   
		fprintf(stderr,"Error6 in Huffman-Sequence\n"); 
		break;
	case E_SEQ7:   
		fprintf(stderr,"Error7 in Huffman-Sequence\n"); 
		break;
	case E_POS:    
		fprintf(stderr,"Error in file-position\n"); 
		break;
	case E_OVSKIP: 
		fprintf(stderr,"Can't read this resolution in overskip-mode\n"); 
		break;
	case E_TAUTO:  
		fprintf(stderr,"Can't determine the orientation in overview mode\n");
		break;
	case E_TCANT:  
		fprintf(stderr,"Sorry, can't determine orientation for this file.\n");
		fprintf(stderr,"Please give orientation parameters. \n");
		break;
	default:       
		fprintf(stderr,"Unknown error %d ???\n",e);
		break;
	}
	if(fin) fclose(fin);
	if(fout) fclose(fout);
	exit(9);
}

/*
 *			P L A N E A L L O C
 *
 *  Allocate memory for one YCC color plane.
 */
static void planealloc(implane *p, dim width, dim height)
{
	p->iwidth=p->iheight=0;
	p->mwidth=width;
	p->mheight=height;

	p->im = ( uBYTE * ) malloc  (width*height);
	if(!(p->im)) error(E_MEM);
}

/*
 *			M A I N
 */
int
main(int argc, char **argv)
         
            
#define ASKIP { argc--; argv ++;}
{
	int bildnr;
	char *opt;
	dim w=0,h=0;
	long cd_offset,cd_offhelp;
	int do_info,do_overskip;
	int	do_pixfb = 0;
	int	do_headeronly = 0;

	enum SIZES size=S_UNSPEC;
	enum ERRORS eret;
	implane Luma, Chroma1,Chroma2;

	do_info=do_overskip=do_bw=0;

	ASKIP;

	/* Argument processing */
	while((argc>0) && **argv=='-')
	{
		opt= (*argv)+1;
		ASKIP;

		if( strcmp(opt, "l") == 0 )  {
			opt= (*argv);
			ASKIP;
			lum_mul = atof(opt);
			continue;
		}

		if( strcmp(opt, "p") == 0 )  {
			if (!do_pixfb) do_pixfb=1;
			else error(E_ARG);
			continue;
		}

		if( strcmp(opt, "h") == 0 )  {
			if (!do_headeronly) do_headeronly=1;
			else error(E_ARG);
			continue;
		}

		if(!strcmp(opt,"i"))
		{ 
			if (!do_info) do_info=1;
			else error(E_ARG);
			continue;
		}

		if(!strcmp(opt,"x"))
		{ 
			if (!do_overskip) do_overskip=1;
			else error(E_ARG);
			continue;
		}


		if(!strcmp(opt,"b"))
		{ 
			if (!do_bw) do_bw=1;
			else error(E_ARG);
			continue;
		}




		if((!strcmp(opt,"Base/16")) || (!strcmp(opt,"1"))  || (!strcmp(opt,"128x192")))
		{ 
			if (size == S_UNSPEC) size = S_Base16;
			else error(E_ARG);
			continue;
		}
		if((!strcmp(opt,"Base/4" )) || (!strcmp(opt,"2"))  || (!strcmp(opt,"256x384")))
		{ 
			if (size == S_UNSPEC) size = S_Base4;
			else error(E_ARG);
			continue;
		}
		if((!strcmp(opt,"Base"   )) || (!strcmp(opt,"3"))  || (!strcmp(opt,"512x768")))
		{ 
			if (size == S_UNSPEC) size = S_Base;
			else error(E_ARG);
			continue;
		}
		if((!strcmp(opt,"4Base"  )) || (!strcmp(opt,"4"))  || (!strcmp(opt,"1024x1536")))
		{ 
			if (size == S_UNSPEC) size = S_4Base;
			else error(E_ARG);
			continue;
		}
		if((!strcmp(opt,"16Base" )) || (!strcmp(opt,"5"))  || (!strcmp(opt,"2048x3072")))
		{ 
			if (size == S_UNSPEC) size = S_16Base;
			else error(E_ARG);
			continue;
		}

		if((!strcmp(opt,"Overview" )) || (!strcmp(opt,"0"))  || (!strcmp(opt,"O")))
		{ 
			if (size == S_UNSPEC) size = S_Over;
			else error(E_ARG);
			continue;
		}

		fprintf(stderr,"Unknown option: -%s\n",opt);
		error(E_ARG);
	}




	if(size==S_UNSPEC) size=S_DEFAULT;

	if(argc<1) error(E_ARG);
	pcdname= *argv;
	ASKIP;

	if(argc>0) error(E_ARG);
	if(do_info && (size==S_Over)) error(E_OPT);
	if(do_overskip && (size != S_Base16) && (size != S_Base4) && (size != S_Base) && (size != S_4Base) ) error(E_OVSKIP);

	if(!(fin=fopen(pcdname,"r")))  {
		/* If name is frame number only, create name and go again */
		if( atoi(pcdname) > 0 )  {
			sprintf(nbuf, "img%4.4d.pcd", atoi(pcdname) );
			if(!(fin=fopen(nbuf,"r")))  {
				perror(nbuf);
				error(E_READ);
			}
		} else {
			perror(pcdname);
			error(E_READ);
		}
	}

	if(do_info)
	{ 
		SEEK(1);
		EREADBUF;
	}

	switch(size)  {
	case S_Base16: 
		w=BaseW/4;
		h=BaseH/4;
		break;
	case S_Base4:  
		w=BaseW/2;
		h=BaseH/2;
		break;
	case S_Base:   
		w=BaseW;
		h=BaseH;
		break;
	case S_4Base:  
		w=BaseW*2;
		h=BaseH*2;
		break;
	case S_16Base: 
		w=BaseW*4;
		h=BaseH*4;
		break;
	case S_Over:   
		w=BaseW/4;
		h=BaseH/4;
		break;
	default: 
		error(E_INTERN);
	}

	if( do_headeronly )  {
		printf("-w%ld -n%ld\n", w, h);
		exit(0);
	}

	if( do_pixfb )  {
		if( do_bw )
			sprintf(nbuf, "bw-fb -w%ld -n%ld", w, h);
		else
			sprintf(nbuf, "pix-fb -w%ld -n%ld", w, h);

		if( (fout = popen( nbuf, "w" )) == NULL )  {
			perror(nbuf);
			exit(42);
		}
	} else {
		fout = stdout;
	}

	if(do_info) druckeid();

	switch(size)
	{
	case S_Base16: 
		w=BaseW/4;
		h=BaseH/4;

		if(!do_overskip)
		{ 
			planealloc(&Luma   ,w,h);
			planealloc(&Chroma1,w,h);
			planealloc(&Chroma2,w,h);
			SEEK(L_Head+1);
			error(readplain(w,h,&Luma,&Chroma1,&Chroma2));
			interpolate(&Chroma1);
			interpolate(&Chroma2);
		}
		else
		{ 
			planealloc(&Luma   ,w,h);
			planealloc(&Chroma1,2*w,2*h);
			planealloc(&Chroma2,2*w,2*h);
			SEEK(L_Head+1);
			error(readplain(w,h,&Luma,nullplane,nullplane));
			SEEK(L_Head+L_Base16+1);
			error(readplain(2*w,2*h,nullplane,&Chroma1,&Chroma2));
		}

		ycctorgb(w,h,&Luma,&Chroma1,&Chroma2);
		break;

	case S_Base4:  
		w=BaseW/2;
		h=BaseH/2;

		if(!do_overskip)
		{ 
			planealloc(&Luma   ,w,h);
			planealloc(&Chroma1,w,h);
			planealloc(&Chroma2,w,h);
			SEEK(L_Head+L_Base16+1);
			error(readplain(w,h,&Luma,&Chroma1,&Chroma2));
			interpolate(&Chroma1);
			interpolate(&Chroma2);
		}
		else
		{ 
			planealloc(&Luma   ,w,h);
			planealloc(&Chroma1,2*w,2*h);
			planealloc(&Chroma2,2*w,2*h);
			SEEK(L_Head+L_Base16+1);
			error(readplain(w,h,&Luma,nullplane,nullplane));
			SEEK(L_Head+L_Base16+L_Base4+1);
			error(readplain(2*w,2*h,nullplane,&Chroma1,&Chroma2));
		}

		ycctorgb(w,h,&Luma,&Chroma1,&Chroma2);
		break;

	case S_Base:   
		w=BaseW;
		h=BaseH;

		if(!do_overskip)
		{ 
			planealloc(&Luma   ,w,h);
			planealloc(&Chroma1,w,h);
			planealloc(&Chroma2,w,h);
			SEEK(L_Head+L_Base16+L_Base4+1);
			error(readplain(w,h,&Luma,&Chroma1,&Chroma2));
			interpolate(&Chroma1);
			interpolate(&Chroma2);
		}
		else
		{ 
			planealloc(&Luma   ,  w,  h);
			planealloc(&Chroma1,2*w,2*h);
			planealloc(&Chroma2,2*w,2*h);
			SEEK(L_Head+L_Base16+L_Base4+1);
			error(readplain(w,h,&Luma,&Chroma1,&Chroma2));
			interpolate(&Chroma1);
			interpolate(&Chroma2);
			interpolate(&Chroma1);
			interpolate(&Chroma2);

			cd_offset=Skip4Base();
			SEEK(cd_offset+10);          
			EREADBUF;    
			cd_offhelp=(((long)sbuffer[2])<<8)|sbuffer[3];
			SEEK(cd_offset+12);          
			readhqt(w,h,3);
			SEEK(cd_offset+cd_offhelp);  
			decode(4*w,4*h,nullplane,&Chroma1,&Chroma2,1);

			halve(&Chroma1);
			halve(&Chroma2);
		}
		ycctorgb(w,h,&Luma,&Chroma1,&Chroma2);
		break;

	case S_4Base:  
		w=BaseW*2;
		h=BaseH*2;

		if(!do_overskip)
		{
			planealloc(&Luma,w,h);
			planealloc(&Chroma1,w,h);
			planealloc(&Chroma2,w,h);
			SEEK(L_Head+L_Base16+L_Base4+1);
			error(readplain(w/2,h/2,&Luma,&Chroma1,&Chroma2));
			interpolate(&Luma);
			interpolate(&Chroma1);
			interpolate(&Chroma1);
			interpolate(&Chroma2);
			interpolate(&Chroma2);

			cd_offset = L_Head + L_Base16 + L_Base4 + L_Base ;
			SEEK(cd_offset + 4);     
			readhqt(w,h,1);
			SEEK(cd_offset + 5);     
			decode(w,h,&Luma,nullplane,nullplane,0);
		}
		else
		{
			planealloc(&Luma,w,h);
			planealloc(&Chroma1,2*w,2*h);
			planealloc(&Chroma2,2*w,2*h);
			SEEK(L_Head+L_Base16+L_Base4+1);
			error(readplain(w/2,h/2,&Luma,&Chroma1,&Chroma2));
			interpolate(&Luma);
			interpolate(&Chroma1);
			interpolate(&Chroma1);
			interpolate(&Chroma2);
			interpolate(&Chroma2);

			cd_offset = L_Head + L_Base16 + L_Base4 + L_Base ;
			SEEK(cd_offset + 4);     
			readhqt(w,h,1);
			SEEK(cd_offset + 5);     
			decode(w,h,&Luma,nullplane,nullplane,0);

			cd_offset=ftell(fin);
			if(cd_offset % SECSIZE) error(E_POS);
			cd_offset/=SECSIZE;
			SEEK(cd_offset+10);          
			EREADBUF;    
			cd_offhelp=(((long)sbuffer[2])<<8)|sbuffer[3];
			SEEK(cd_offset+12);          
			readhqt(w,h,3);
			SEEK(cd_offset+cd_offhelp);  
			decode(2*w,2*h,nullplane,&Chroma1,&Chroma2,1);

		}
		ycctorgb(w,h,&Luma,&Chroma1,&Chroma2);
		break;

	case S_16Base: 
		w=BaseW*4;
		h=BaseH*4;
		planealloc(&Luma,w,h);
		planealloc(&Chroma1,w,h);
		planealloc(&Chroma2,w,h);

		SEEK(L_Head+L_Base16+L_Base4+1);
		error(readplain(w/4,h/4,&Luma,&Chroma1,&Chroma2));
		interpolate(&Luma);
		interpolate(&Chroma1);
		interpolate(&Chroma1);
		interpolate(&Chroma2);
		interpolate(&Chroma2);

		cd_offset = L_Head + L_Base16 + L_Base4 + L_Base ;
		SEEK(cd_offset + 4);       
		readhqt(w/2,h/2,1);
		SEEK(cd_offset + 5);       
		decode(w/2,h/2,&Luma,nullplane,nullplane,0);
		interpolate(&Luma);

		cd_offset=ftell(fin);
		if(cd_offset % SECSIZE) error(E_POS);
		cd_offset/=SECSIZE;

		SEEK(cd_offset+12);        
		readhqt(w,h,3);
		SEEK(cd_offset+14);        
		decode(w,h,&Luma,&Chroma1,&Chroma2,0);

		interpolate(&Chroma1);
		interpolate(&Chroma2);

		ycctorgb(w,h,&Luma,&Chroma1,&Chroma2);
		break;

	case S_Over:   
		w=BaseW/4;
		h=BaseH/4;

		planealloc(&Luma   ,w,h);
		planealloc(&Chroma1,w,h);
		planealloc(&Chroma2,w,h);

		for(bildnr=0;!feof(fin);bildnr++)
		{
			SEEK(5+SeBase16*bildnr);

			eret=readplain(w,h,&Luma,&Chroma1,&Chroma2);
			if(eret==E_READ) break;
			error(eret);

			interpolate(&Chroma1);
			interpolate(&Chroma2);

			/* Write this image to 'fout' */
			ycctorgb(w,h,&Luma,&Chroma1,&Chroma2);
		}
		break;

	default: 
		error(E_INTERN);
	}

	if( do_pixfb )  pclose(fout);

	if( clipped_low || clipped_high )  {
		fprintf(stderr, "pcd-pix: %d clipped low, %d clipped high\n",
			clipped_low, clipped_high );
	}

	return 0;
}
#undef ASKIP

/*
 *			R E A D P L A I N
 */
static enum ERRORS readplain(dim w, dim h, implane *l, implane *c1, implane *c2)
{
	dim i;
	uBYTE *pl=0,*pc1=0,*pc2=0;
	melde("readplain\n");

	if(l)
	{ 
		if ((l->mwidth<w) || (l->mheight<h) || (!l->im)) error(E_INTERN);
		l->iwidth=w;
		l->iheight=h;
		pl=l->im;
	}

	if(c1)
	{ 
		if ((c1->mwidth<w/2) || (c1->mheight<h/2) || (!c1->im)) error(E_INTERN);
		c1->iwidth=w/2;
		c1->iheight=h/2;
		pc1=c1->im;
	}

	if(c2)
	{ 
		if ((c2->mwidth<w/2) || (c2->mheight<h/2) || (!c2->im)) error(E_INTERN);
		c2->iwidth=w/2;
		c2->iheight=h/2;
		pc2=c2->im;
	}

	for(i=0;i<h/2;i++)
	{
		if(pl)
		{
			if(fread(pl,w,1,fin)<(unsigned)1) return(E_READ);
			pl+= l->mwidth;

			if(fread(pl,w,1,fin)<(unsigned)1) return(E_READ);
			pl+= l->mwidth;
		}
		else SKIPr(2*w);

		if(pc1)
		{ 
			if(fread(pc1,w/2,1,fin)<(unsigned)1) return(E_READ);
			pc1+= c1->mwidth;
		}
		else SKIPr(w/2);

		if(pc2)
		{ 
			if(fread(pc2,w/2,1,fin)<(unsigned)1) return(E_READ);
			pc2+= c2->mwidth;
		}
		else SKIPr(w/2);


	}
	RPRINT;
	return E_NONE;
}

/*
 *			I N T E R P O L A T E
 *
 *  Take in image where iwidth is half of mwidth,
 *  output image where iwidth has been doubled.  (Height too).
 */
static void interpolate(implane *p)
{
	dim w,h,x,y,yi;
	uBYTE *optr,*nptr,*uptr;

	melde("interpolate\n");
	if ((!p) || (!p->im)) error(E_INTERN);

	w=p->iwidth;
	h=p->iheight;

	if(p->mwidth  < 2*w ) error(E_INTERN);
	if(p->mheight < 2*h ) error(E_INTERN);

	p->iwidth=2*w;
	p->iheight=2*h;

	for(y=0;y<h;y++)
	{
		yi=h-1-y;
		optr=p->im+  yi*p->mwidth + (w-1);
		nptr=p->im+2*yi*p->mwidth + (2*w - 2);

		nptr[0]=nptr[1]=optr[0];

		for(x=1;x<w;x++)
		{ 
			optr--; 
			nptr-=2;
			nptr[0]=optr[0];
			nptr[1]=(((int)optr[0])+((int)optr[1])+1)>>1;
		}
	}

	for(y=0;y<h-1;y++)
	{
		optr=p->im + 2*y*p->mwidth;
		nptr=optr+p->mwidth;
		uptr=nptr+p->mwidth;

		for(x=0;x<w-1;x++)
		{
			nptr[0]=(((int)optr[0])+((int)uptr[0])+1)>>1;
			nptr[1]=(((int)optr[0])+((int)optr[2])+((int)uptr[0])+((int)uptr[2])+2)>>2;
			nptr+=2; 
			optr+=2; 
			uptr+=2;
		}
		*(nptr++)=(((int)*(optr++))+((int)*(uptr++))+1)>>1;
		*(nptr++)=(((int)*(optr++))+((int)*(uptr++))+1)>>1;
	}

	/* Duplicate the last line */
	optr=p->im + (2*h-2)*p->mwidth;
	nptr=p->im + (2*h-1)*p->mwidth;
	for(x=0;x<w;x++)
	{ 
		*(nptr++) = *(optr++);  
		*(nptr++) = *(optr++); 
	}
}

/*
 *			H A L V E
 *
 *  Image is shrunk by half, by discarding data values.
 */
static void halve(implane *p)
{
	dim w,h,x,y;
	uBYTE *optr,*nptr;

	melde("halve\n");
	if ((!p) || (!p->im)) error(E_INTERN);

	w=p->iwidth/=2;
	h=p->iheight/=2;


	for(y=0;y<h;y++)
	{
		nptr=(p->im) +   y*(p->mwidth);
		optr=(p->im) + 2*y*(p->mwidth);

		for(x=0;x<w;x++,nptr++,optr+=2)
		{ 
			*nptr = *optr;
		}
	}
}

#define BUinit {BUcount=0;BUptr=BUF;}
#define BUflush {fwrite(BUF,BUptr-BUF,1,fout);BUinit; }
#define BUwrite(r,g,b) {if(BUcount>=own_BUsize/3) BUflush; \
	*BUptr++ = r ; *BUptr++ = g ; *BUptr++ = b ; BUcount++;}
#define BUwrite1(r) {if(BUcount>=own_BUsize) BUflush; \
	*BUptr++ = r ; BUcount++;}

#define BitShift 12

/*
 *			Y C C T O R G B
 *
 *  Convert and output.
 *  If "do_bw" flag is set, just output luminance channel.
 */
static void ycctorgb(dim w, dim h, implane *l, implane *c1, implane *c2)
{
	int x,y;		/* not dim! */
	uBYTE *pl,*pc1,*pc2;
	long red,green,blue,i;
	long L;
	static int init=0;
	static long XL[256],XC1[256],XC2[256],XC1g[256],XC2g[256];
	static uBYTE BUF[own_BUsize];
	register uBYTE	*BUptr;
	int   BUcount;

	melde("ycctorgb\n");
	if((!l ) || ( l->iwidth != w ) || ( l->iheight != h) || (! l->im)) error(E_INTERN);
	if((!c1) || (c1->iwidth != w ) || (c1->iheight != h) || (!c1->im)) error(E_INTERN);
	if((!c2) || (c2->iwidth != w ) || (c2->iheight != h) || (!c2->im)) error(E_INTERN);


	if(!init)
	{
		init=1;
		for(i=0;i<256;i++)
		{  
			XL[i]= (5564 * i + 2048) * lum_mul;
			XC1[i]= 9085 * i - 1417185;
			XC2[i]= 7461 * i - 1022138;
			XC1g[i]= 274934 - 1762 * i;
			XC2g[i]= 520268 - 3798 * i;
		}
	}

	BUinit;
	if(do_bw)  {
		for( y=h-1; y >= 0; y-- )  {
			pl =  l->im + y *  l->mwidth;
			for(x=0;x<w;x++)  {
				L = XL[*pl++]>>BitShift;
				NORM(L);
				BUwrite1(L);
			}
		}
	} else {
		for( y=h-1; y >= 0; y-- )  {
			pl =  l->im + y *  l->mwidth;
			pc1= c1->im + y * c1->mwidth;
			pc2= c2->im + y * c2->mwidth;

			for(x=0;x<w;x++)  {
				L = XL[*pl];
				red  =(L + XC2[*pc2]               )>>BitShift;
				green=(L + XC1g[*pc1] + XC2g[*pc2] )>>BitShift;
				blue =(L + XC1[*pc1]               )>>BitShift;

				NORM(red);
				NORM(green);
				NORM(blue);

				BUwrite(red,green,blue);
				pl++;
				pc1++;
				pc2++;
			}
		}
	}
	BUflush;
}
#undef BitShift


struct ph1 
{
	char  id1[8];
	uBYTE ww1[14];
	char  id2[20];
	char  id3[4*16+4];
	short ww2;
	char  id4[20];
	uBYTE ww3[2*16+1];
	char  id5[4*16];
	uBYTE idx[11*16];
};


static void druckeid(void)
{
	struct ph1 *d;
	char ss[100];

	d=(struct ph1 *)sbuffer;

#define dr(feld,kennung)   \
     strncpy(ss,feld,sizeof(feld));\
     ss[sizeof(feld)]=0;\
     fprintf(stderr,"%s: %s \n",kennung,ss);

#define db(feld) fprintf(stderr,"--%d\n",sizeof(feld)); for(i=0;i<sizeof(feld);i+=2) \
  fprintf(stderr,"%4d %6d\n",i,(signed int)((((unsigned int)feld[i])<<8)|feld[i+1]));\
  fprintf(stderr,"\n");

	dr(d->id1,"Id1")
	    dr(d->id2,"Id2")
	    dr(d->id3,"Id3")
	    dr(d->id4,"Id4")
	    dr(d->id5,"Id5")

	/*
		db(d->ww1)
		db(d->ww3)
		db(d->idx)
	*/

#undef dr 
#undef db

}



#if 0
struct pcdword
{ 
	uBYTE high,low;
};

static int lpt[1024];

static void readlpt(w,h)
dim w,h;
{
	int i;
	struct pcdword *ptr;

	EREADBUF;

	ptr = (struct pcdword *)sbuffer;

	for(i=0;i<h/4;i++,ptr++)
	{
		lpt[i] = ((int)ptr->high)<<8 | ptr->low ;
	}



}
#endif


struct pcdquad { 
	uBYTE len,highseq,lowseq,key;
};
struct pcdhqt  { 
	uBYTE entries; 
	struct pcdquad entry[256];
};
struct myhqt { 
	unsigned long seq,mask,len; 
	uBYTE key; 
};


#define E ((unsigned long) 1)


static void readhqtsub(struct pcdhqt *source, struct myhqt *ziel, int *anzahl)
{
	int i;
	struct pcdquad *sub;
	struct myhqt *help;
	*anzahl=(source->entries)+1;

	for(i=0;i<*anzahl;i++)
	{
		sub = (struct pcdquad *)(((uBYTE *)source)+1+i*sizeof(*sub));
		help=ziel+i;

		help->seq = (((unsigned long) sub->highseq) << 24) |(((unsigned long) sub->lowseq) << 16);
		help->len = ((unsigned long) sub->len) +1;
		help->key = sub->key;

#ifdef DEBUGhuff
		fprintf(stderr," Anz: %d A1: %08x  A2: %08x X:%02x %02x %02x %02x Seq:  %08x   Laenge:  %d %d\n",
		    *anzahl,sbuffer,sub,((uBYTE *)sub)[0],((uBYTE *)sub)[1],((uBYTE *)sub)[2],((uBYTE *)sub)[3],
		    help->seq,help->len,sizeof(uBYTE));
#endif

		if(help->len > 16) error(E_HUFF);

		help->mask = ~ ( (E << (32-help->len)) -1);

	}
#ifdef DEBUG
	for(i=0;i<*anzahl;i++)
	{
		help=ziel+i;
		fprintf(stderr,"H: %3d  %08lx & %08lx (%2d) = %02x = %5d  %8x\n",
		    i, help->seq,help->mask,help->len,help->key,(signed char)help->key,
		    help->seq & (~help->mask));
	}
#endif

}

#undef E

static struct myhqt myhuff0[256],myhuff1[256],myhuff2[256];
static int          myhufflen0=0,myhufflen1=0,myhufflen2=0;

static void readhqt(dim w, dim h, int n)
{
	uBYTE *ptr;

	melde("readhqt\n");
	EREADBUF;
	ptr = sbuffer;

	readhqtsub((struct pcdhqt *)ptr,myhuff0,&myhufflen0);

	if(n<2) return;
	ptr+= 1 + 4* myhufflen0;
	readhqtsub((struct pcdhqt *)ptr,myhuff1,&myhufflen1);

	if(n<3) return;
	ptr+= 1 + 4* myhufflen1;
	readhqtsub((struct pcdhqt *)ptr,myhuff2,&myhufflen2);
}

/*
 *			D E C O D E
 *
 *  Read the input stream, decoding into the given buffer(s).
 */
static void decode(dim w, dim h, implane *f, implane *f1, implane *f2, int autosync)
{
	int i,htlen,sum;
	unsigned long maxwidth;
	register unsigned long sreg;
	unsigned int inh,n,zeile,segment,ident;
	struct myhqt *htptr,*hp;

	register uBYTE *nptr;
	uBYTE *lptr;

	melde("decode\n");
#define nextbuf  {  nptr=sbuffer;  EREADBUF; }
#define checkbuf { if (nptr >= sbuffer + sizeof(sbuffer)) nextbuf; }
#define shiftout(n){ sreg<<=n; inh-=n; \
                    while (inh<=24) \
                     {checkbuf; \
                      sreg |= ((unsigned long)(*(nptr++)))<<(24-inh);\
                      inh+=8;\
                     }\
                   }  
#define issync ((sreg & 0xffffff00) == 0xfffffe00) 
#define seeksync { while (!issync) shiftout(1);}


	if( f  && ((! f->im) || ( f->iheight < h  ) ||  (f->iwidth<w  ))) error(E_INTERN);
	if( f1 && ((!f1->im) || (f1->iheight < h/2) || (f1->iwidth<w/2))) error(E_INTERN);
	if( f2 && ((!f2->im) || (f2->iheight < h/2) || (f2->iwidth<w/2))) error(E_INTERN);

	htlen=sreg=maxwidth=0;
	htptr=0;
	nextbuf;
	inh=32;
	lptr=0;
	shiftout(16);
	shiftout(16);

	if(autosync) seeksync;

	n=0;
	for(;;)
	{
		if (issync)
		{
			shiftout(24);
			ident=sreg>>16;
			shiftout(16);

			zeile=(ident>>1) & 0x1fff;
			segment=ident>>14;

#ifdef DEBUG
			fprintf(stderr,"Ident %4x Zeile:  %6d  Segment %3d Pixels bisher: %5d   Position: %8lx\n",
			    ident,zeile,segment,n,bufpos);
#endif


			if(lptr && (n!=maxwidth)) error(E_SEQ1);
			n=0;

			if(zeile==h) {
				RPRINT; 
				return; 
			}
			if(zeile >h) error(E_SEQ2);

			switch(segment)
			{
			case 0: 
				if((!f) && autosync) {
					seeksync; 
					break;
				}
				if(!f) error(E_SEQ7);
				lptr=f->im + zeile*f->mwidth;
				maxwidth=f->iwidth;
				htlen=myhufflen0;
				htptr=myhuff0;
				break;

			case 2: 
				if((!f1) && autosync) {
					seeksync; 
					break;
				}
				if(!f1) error(E_SEQ7);
				lptr=f1->im + (zeile>>1)*f1->mwidth;
				maxwidth=f1->iwidth;
				htlen=myhufflen1;
				htptr=myhuff1;
				break;

			case 3: 
				if((!f2) && autosync) {
					seeksync; 
					break;
				}
				if(!f2) error(E_SEQ7);
				lptr=f2->im + (zeile>>1)*f2->mwidth;
				maxwidth=f2->iwidth;
				htlen=myhufflen2;
				htptr=myhuff2;
				break;

			default:
				error(E_SEQ3);
			}
		}
		else
		{
			register int	key;
			/*      if((!lptr) || (n>maxwidth)) error(E_SEQ4);*/
			if(!lptr)      error(E_SEQ6);
			if(n>maxwidth) error(E_SEQ4);
			for(i=0,hp=htptr;(i<htlen) && ((sreg & hp->mask)!= hp->seq); i++,hp++);
			if(i>=htlen) error(E_SEQ5);

			/* Ensure key is treated as signed byte */
			if( (key = hp->key) & 0x80 )
				key |= ((-1) & ~0x7F);
			sum=((int)(*lptr)) + key;
			/* NORM(sum); */
			if(sum<0) sum=0; else if (sum>255) sum=255;
			*(lptr++) = sum;

			n++;
			shiftout(hp->len);

		}

	}


#undef nextbuf  
#undef checkbuf 
#undef shiftout
#undef issync
#undef seeksync

}

static int testbegin(void)
{
	int i,j;
	for(i=j=0;i<32;i++)
		if(sbuffer[i]==0xff) j++;

	return (j>30);

}

static long Skip4Base(void)
{
	long cd_offset,cd_offhelp;

	cd_offset = L_Head + L_Base16 + L_Base4 + L_Base ;
	SEEK(cd_offset+3);
	EREADBUF;
	cd_offhelp = ( ((long)sbuffer[510]) << 8 ) | (sbuffer[511] + 1);

	cd_offset+=cd_offhelp;

	SEEK(cd_offset);
	EREADBUF;
	while(!testbegin())
	{
		cd_offset++;
		EREADBUF;
	}
	return cd_offset;
}
@


11.14
log
@change conf.h to a wrapped config.h
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/util/pcd-pix.c,v 11.13 2004/04/05 05:46:02 morrison Exp $ (BRL)";
@


11.13
log
@merge of ansi-6-0-branch into head
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d34 5
a38 1
#include "conf.h"
@


11.12
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/pcd-pix.c,v 11.10 2001/08/10 20:57:06 butler Exp $ (BRL)";
d92 4
a95 4
static enum ERRORS readplain();
static void interpolate();
static void halve();
static void ycctorgb();
d99 4
a102 4
static void readhqt();
static void decode();
static void druckeid();
static long Skip4Base();
d149 1
a149 2
static void error(e)
enum ERRORS e;
d244 1
a244 3
static void planealloc(p,width,height)
implane *p;
dim width,height;
d258 3
a260 3
main(argc,argv)
int argc;
char **argv;
d689 1
a689 3
static enum ERRORS readplain(w,h,l,c1,c2)
dim w,h;
implane *l,*c1,*c2;
d757 1
a757 2
static void interpolate(p)
implane *p;
d824 1
a824 2
static void halve(p)
implane *p;
d863 1
a863 3
static void ycctorgb(w,h,l,c1,c2)
dim w,h;
implane *l,*c1,*c2;
d946 1
a946 1
static void druckeid()
d1026 1
a1026 4
static void readhqtsub(source,ziel,anzahl)
struct pcdhqt *source;
struct myhqt *ziel;
int *anzahl;
d1070 1
a1070 3
static void readhqt(w,h,n)
dim w,h;
int n;
d1094 1
a1094 4
static void decode(w,h,f,f1,f2,autosync)
dim w,h;
implane *f,*f1,*f2;
int autosync;
d1235 1
a1235 1
static int testbegin()
d1245 1
a1245 1
static long Skip4Base()
@


11.12.2.1
log
@Initial ANSIfication
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/pcd-pix.c,v 11.12 2002/08/20 17:08:59 jra Exp $ (BRL)";
d92 4
a95 4
static enum ERRORS readplain(dim w, dim h, implane *l, implane *c1, implane *c2);
static void interpolate(implane *p);
static void halve(implane *p);
static void ycctorgb(dim w, dim h, implane *l, implane *c1, implane *c2);
d99 4
a102 4
static void readhqt(dim w, dim h, int n);
static void decode(dim w, dim h, implane *f, implane *f1, implane *f2, int autosync);
static void druckeid(void);
static long Skip4Base(void);
d149 2
a150 1
static void error(enum ERRORS e)
d245 3
a247 1
static void planealloc(implane *p, dim width, dim height)
d261 3
a263 3
main(int argc, char **argv)
         
            
d692 3
a694 1
static enum ERRORS readplain(dim w, dim h, implane *l, implane *c1, implane *c2)
d762 2
a763 1
static void interpolate(implane *p)
d830 2
a831 1
static void halve(implane *p)
d870 3
a872 1
static void ycctorgb(dim w, dim h, implane *l, implane *c1, implane *c2)
d955 1
a955 1
static void druckeid(void)
d1035 4
a1038 1
static void readhqtsub(struct pcdhqt *source, struct myhqt *ziel, int *anzahl)
d1082 3
a1084 1
static void readhqt(dim w, dim h, int n)
d1108 4
a1111 1
static void decode(dim w, dim h, implane *f, implane *f1, implane *f2, int autosync)
d1252 1
a1252 1
static int testbegin(void)
d1262 1
a1262 1
static long Skip4Base(void)
@


11.11
log
@Converted from K&R to ANSI C - RFH
@
text
@d92 4
a95 4
static enum ERRORS readplain(dim w, dim h, implane *l, implane *c1, implane *c2);
static void interpolate(implane *p);
static void halve(implane *p);
static void ycctorgb(dim w, dim h, implane *l, implane *c1, implane *c2);
d99 4
a102 4
static void readhqt(dim w, dim h, int n);
static void decode(dim w, dim h, implane *f, implane *f1, implane *f2, int autosync);
static void druckeid(void);
static long Skip4Base(void);
d149 2
a150 1
static void error(enum ERRORS e)
d245 3
a247 1
static void planealloc(implane *p, dim width, dim height)
d261 3
a263 3
main(int argc, char **argv)
         
            
d692 3
a694 1
static enum ERRORS readplain(dim w, dim h, implane *l, implane *c1, implane *c2)
d762 2
a763 1
static void interpolate(implane *p)
d830 2
a831 1
static void halve(implane *p)
d870 3
a872 1
static void ycctorgb(dim w, dim h, implane *l, implane *c1, implane *c2)
d955 1
a955 1
static void druckeid(void)
d1035 4
a1038 1
static void readhqtsub(struct pcdhqt *source, struct myhqt *ziel, int *anzahl)
d1082 3
a1084 1
static void readhqt(dim w, dim h, int n)
d1108 4
a1111 1
static void decode(dim w, dim h, implane *f, implane *f1, implane *f2, int autosync)
d1252 1
a1252 1
static int testbegin(void)
d1262 1
a1262 1
static long Skip4Base(void)
@


11.10
log
@Misc compiler warnings eliminated
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/pcd-pix.c,v 11.9 2001/08/08 13:20:25 butler Exp $ (BRL)";
d92 4
a95 4
static enum ERRORS readplain();
static void interpolate();
static void halve();
static void ycctorgb();
d99 4
a102 4
static void readhqt();
static void decode();
static void druckeid();
static long Skip4Base();
d149 1
a149 2
static void error(e)
enum ERRORS e;
d244 1
a244 3
static void planealloc(p,width,height)
implane *p;
dim width,height;
d258 3
a260 3
main(argc,argv)
int argc;
char **argv;
d689 1
a689 3
static enum ERRORS readplain(w,h,l,c1,c2)
dim w,h;
implane *l,*c1,*c2;
d757 1
a757 2
static void interpolate(p)
implane *p;
d824 1
a824 2
static void halve(p)
implane *p;
d863 1
a863 3
static void ycctorgb(w,h,l,c1,c2)
dim w,h;
implane *l,*c1,*c2;
d946 1
a946 1
static void druckeid()
d1026 1
a1026 4
static void readhqtsub(source,ziel,anzahl)
struct pcdhqt *source;
struct myhqt *ziel;
int *anzahl;
d1070 1
a1070 3
static void readhqt(w,h,n)
dim w,h;
int n;
d1094 1
a1094 4
static void decode(w,h,f,f1,f2,autosync)
dim w,h;
implane *f,*f1,*f2;
int autosync;
d1235 1
a1235 1
static int testbegin()
d1245 1
a1245 1
static long Skip4Base()
@


11.9
log
@Misc compiler warnings
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/pcd-pix.c,v 11.8 2001/08/08 03:28:15 butler Exp $ (BRL)";
d36 1
a36 1
#ifdef USE_STRING_H
@


11.8
log
@Misc compiler warnings eliminated
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/pcd-pix.c,v 11.7 2000/09/01 03:23:51 mike Exp $ (BRL)";
d1269 1
a1269 1
	cd_offhelp = ( ((long)sbuffer[510]) << 8 ) | sbuffer[511] + 1;
@


11.7
log
@
Lint fix
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/pcd-pix.c,v 11.6 2000/08/23 19:04:36 mike Exp $ (BRL)";
d1269 1
a1269 1
	cd_offhelp=(((long)sbuffer[510])<<8)|sbuffer[511] + 1;
@


11.6
log
@
const RCSid
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/pcd-pix.c,v 11.5 1999/12/30 04:16:37 butler Exp $ (BRL)";
d36 5
d268 1
a268 1
	dim w,h;
@


11.5
log
@Changed return type of main() to int just to make certain compliers happy.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/pcd-pix.c,v 11.4 1998/09/22 03:22:25 mike Exp $ (BRL)";
@


11.4
log
@Fixed printf args
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/util/pcd-pix.c,v 11.3 1997/04/18 03:36:14 mike Exp $ (BRL)";
d255 2
a256 1
void main(argc,argv)
d680 1
a680 1
	exit(0);
@


11.3
log
@Added -l flag to multiply luminance channel.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/pcd-pix.c,v 11.2 1997/04/18 02:02:37 mike Exp mike $ (BRL)";
d431 1
a431 1
		printf("-w%d -n%d\n", w, h);
d437 1
a437 1
			sprintf(nbuf, "bw-fb -w%d -n%d", w, h);
d439 1
a439 1
			sprintf(nbuf, "pix-fb -w%d -n%d", w, h);
@


11.2
log
@Added counts of pixels clipped.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/pcd-pix.c,v 11.1 1995/01/04 10:12:13 mike Rel4_4 mike $ (BRL)";
d36 1
d142 2
d177 1
d282 7
d889 1
a889 1
			XL[i]= 5564 * i + 2048;
@


11.1
log
@Release_4.4
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/pcd-pix.c,v 1.18 94/11/14 23:15:40 mike Exp $ (BRL)";
d136 4
a139 1
#define NORM(x) { if(x<0) x=0; else if (x>255) x=255;}
d663 5
d1215 2
a1216 1
			NORM(sum);
@


1.18
log
@Irix 6
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/RCS/pcd-pix.c,v 1.17 94/10/21 20:18:32 mike Exp Locker: mike $ (BRL)";
@


1.17
log
@Solaris
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/pcd-pix.c,v 1.16 94/01/14 23:30:08 mike Exp Locker: mike $ (BRL)";
d90 1
a90 1
static void writepicture();
d92 1
a931 1
	int i;
d965 1
d991 1
a991 1

@


1.16
log
@Fixed missing break in -4 case.

@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/pcd-pix.c,v 1.15 94/01/14 22:32:53 mike Exp Locker: mike $ (BRL)";
d34 1
d36 2
d130 1
a130 1
#define EREADBUF {if(READBUF < 1) error(E_READ);}
d702 1
a702 1
			if(fread(pl,w,1,fin)<1) return(E_READ);
d705 1
a705 1
			if(fread(pl,w,1,fin)<1) return(E_READ);
d712 1
a712 1
			if(fread(pc1,w/2,1,fin)<1) return(E_READ);
d719 1
a719 1
			if(fread(pc2,w/2,1,fin)<1) return(E_READ);
@


1.15
log
@Revamped the usage message.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/pcd-pix.c,v 1.14 94/01/14 22:10:54 mike Exp Locker: mike $ (BRL)";
d399 1
@


1.14
log
@Eliminated need for signed byte basic type.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /m/cad/util/pcd-pix.c,v 1.13 94/01/14 21:55:12 mike Exp Locker: mike $ (BRL)";
d161 5
a165 5
		fprintf(stderr,"     -1 Extract  -n128  -w192 from Image file [Base/16]\n");
		fprintf(stderr,"     -2 Extract  -n256  -w384 from Image file [Base/4]\n");
		fprintf(stderr,"     -3 Extract  -n512  -w768 from Image file [Base].  Default size.\n");
		fprintf(stderr,"     -4 Extract -n1024 -w1536 from Image file [4Base]\n");
		fprintf(stderr,"     -5 Extract -n2048 -w3072 from Image file [16Base]\n");
a167 1
		fprintf(stderr,"\n");
@


1.13
log
@Overview images are written as a stream on stdout, rather than
into separate files.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /d/mike/photocd/RCS/pcd-pix.c,v 1.12 94/01/14 17:53:23 mike Exp Locker: mike $ (BRL)";
a37 10

/*
** Important: sBYTE must be a signed byte type !!!
**
*/

#ifndef sBYTE
typedef   signed char sBYTE;
#endif

d1192 1
d1199 4
a1202 1
			sum=((int)(*lptr)) + ((sBYTE)hp->key);
@


1.12
log
@Took out stray printf
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /d/mike/photocd/RCS/pcd-pix.c,v 1.11 94/01/14 17:47:48 mike Exp Locker: mike $ (BRL)";
d655 1
a655 2
			sprintf(nbuf,"overview%04d",bildnr+1);
			if (!(fout=fopen(nbuf,"w"))) error(E_WRITE);
a656 1
			fclose(fout);
@


1.11
log
@Fixed usage message.
Added -h and -p flags.
Made -3 size be the default.
Added numeric-only names.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: /d/mike/photocd/RCS/pcd-pix.c,v 1.10 93/03/06 05:17:20 mike Exp Locker: mike $ (BRL)";
a432 1
		fprintf(stderr, "pcd-pix | %s\n", nbuf);
@


1.10
log
@Neatness
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d80 1
a80 1
#define S_DEFAULT S_Base16
d165 2
a166 3
		fprintf(stderr,"Error in Arguments !\n\n");
		fprintf(stderr,"Usage: hpcdtoppm [options] pcd-file [ppm-file]\n\n");
		fprintf(stderr,"Opts:\n");
d171 7
a177 6
		fprintf(stderr,"     -1 Extract  128x192  from Image file\n");
		fprintf(stderr,"     -2 Extract  256x384  from Image file\n");
		fprintf(stderr,"     -3 Extract  512x768  from Image file\n");
		fprintf(stderr,"     -4 Extract 1024x1536 from Image file\n");
		fprintf(stderr,"     -5 Extract 2048x3072 from Image file\n");
		fprintf(stderr,"                 -n  -w\n");
d265 2
d282 12
d374 13
a386 1
	if(!(fin=fopen(pcdname,"r"))) error(E_READ);
d394 48
a443 1
	fout = stdout;
d666 2
@


1.9
log
@Fixed problem with outtput
@
text
@a0 1
#define OWN_WRITE	1
d7 15
d23 3
a26 11

/* hpcdtoppm (Hadmut's pcdtoppm) v0.3
*  Copyright (c) 1992 by Hadmut Danisch (danisch@@ira.uka.de).
*  Permission to use and distribute this software and its
*  documentation for noncommercial use and without fee is hereby granted,
*  provided that the above copyright notice appear in all copies and that
*  both that copyright notice and this permission notice appear in
*  supporting documentation. It is not allowed to sell this software in 
*  any way. This software is not public domain.
*/

d36 1
a36 4
/* If the own routines are used, this is the size of the buffer in bytes.
   You can shrink if needed. */
#define own_BUsize 50000
/* (3*24*1024) */
d887 5
a891 5
	    /*
db(d->ww1)
db(d->ww3)
db(d->idx)
*/
d1023 2
a1024 1
	unsigned long sreg,maxwidth;
d1028 1
a1028 1
	uBYTE *nptr;
@


1.8
log
@Made buffer writing part of ycctorgb().
Added -b flag for writing .bw files.
@
text
@d780 1
a780 1
	dim x,y;
d811 1
a811 1
		for( y=h-1; y>=0; y-- )  {
d819 5
a823 1
	}
d825 5
a829 4
	for( y=h-1; y>=0; y-- )  {
		pl =  l->im + y *  l->mwidth;
		pc1= c1->im + y * c1->mwidth;
		pc2= c2->im + y * c2->mwidth;
d831 3
a833 5
		for(x=0;x<w;x++)  {
			L = XL[*pl];
			red  =(L + XC2[*pc2]               )>>BitShift;
			green=(L + XC1g[*pc1] + XC2g[*pc2] )>>BitShift;
			blue =(L + XC1[*pc1]               )>>BitShift;
d835 5
a839 8
			NORM(red);
			NORM(green);
			NORM(blue);

			BUwrite(red,green,blue);
			pl++;
			pc1++;
			pc2++;
@


1.7
log
@Limited memory use
@
text
@d33 1
d105 1
a105 1
static int keep_ycc;
d166 2
a167 3
		fprintf(stderr,"     -i Give some (buggy) informations from fileheader\n");
		fprintf(stderr,"     -ycc suppress ycc to rgb conversion \n");
		fprintf(stderr,"        (Experimentally, doesn't have deeper sense)\n\n");
d174 1
d267 1
a267 1
	do_info=do_overskip=keep_ycc=0;
d292 1
a292 1
		if(!strcmp(opt,"ycc"))
d294 1
a294 1
			if (!keep_ycc) keep_ycc=1;
d367 1
a395 5
		/* Now Luma holds red, Chroma1 hold green, Chroma2 holds blue */

		fout=stdout;
		writepicture(w,h,&Luma,&Chroma1,&Chroma2);

d422 1
a423 5
		/* Now Luma holds red, Chroma1 hold green, Chroma2 holds blue */

		fout=stdout;
		writepicture(w,h,&Luma,&Chroma1,&Chroma2);

a464 5
		/* Now Luma holds red, Chroma1 hold green, Chroma2 holds blue */

		fout=stdout;
		writepicture(w,h,&Luma,&Chroma1,&Chroma2);

a521 5
		/* Now Luma holds red, Chroma1 hold green, Chroma2 holds blue */

		fout=stdout;
		writepicture(w,h,&Luma,&Chroma1,&Chroma2);

a558 5
		/* Now Luma holds red, Chroma1 hold green, Chroma2 holds blue */

		fout=stdout;
		writepicture(w,h,&Luma,&Chroma1,&Chroma2);

a579 3
			ycctorgb(w,h,&Luma,&Chroma1,&Chroma2);
			/* Now Luma holds red, Chroma1 hold green, Chroma2 holds blue */

d582 2
a583 1
			writepicture(w,h,&Luma,&Chroma1,&Chroma2);
d595 3
d761 7
d773 2
a774 1
 *  Convert in place.
d786 3
a794 1
	if(keep_ycc) return;
d809 13
a821 3
	for(y=0;y<h;y++)
	{
		/* Converted values are at 0*y */
d826 1
a826 2
		for(x=0;x<w;x++)
		{
d836 4
a839 3
			*(pl++ )=red;
			*(pc1++)=green;
			*(pc2++)=blue;
d842 1
a844 29

static void writepicture(w,h,r,g,b)
dim w,h;
implane *r,*g,*b;
{
	dim x,y;
	register uBYTE *pr,*pg,*pb;
	static uBYTE BUF[own_BUsize],*BUptr;
	int   BUcount;

#define BUinit {BUcount=0;BUptr=BUF;}
#define BUflush {fwrite(BUF,BUcount*3,1,fout);BUinit; }
#define BUwrite(r,g,b) {if(BUcount>=own_BUsize/3) BUflush; *BUptr++ = r ; *BUptr++ = g ; *BUptr++ = b ; BUcount++;}


	melde("writepicture\n");
	if((!r) || (r->iwidth != w ) || (r->iheight != h) || (!r->im)) error(E_INTERN);
	if((!g) || (g->iwidth != w ) || (g->iheight != h) || (!g->im)) error(E_INTERN);
	if((!b) || (b->iwidth != w ) || (b->iheight != h) || (!b->im)) error(E_INTERN);

	BUinit;
	for( y=h-1; y>=0; y-- )  {
		pr= r->im + y * r->mwidth;
		pg= g->im + y * g->mwidth;
		pb= b->im + y * b->mwidth;
		for(x=0;x<w;x++) BUwrite(*pr++,*pg++,*pb++);
	}
	BUflush;
}
@


1.6
log
@Made memory allocation match quantity actually used.
@
text
@a234 3
 *  Twice as much memory is allocated, so that the interpolators have
 *  space to work in.
 *  (versus 8X more, in the original code)
d244 1
a244 1
	p->im = ( uBYTE * ) malloc  (width*height*2);
d683 6
a703 1

a706 1

a709 1
		/* XXX Old is at 0*y, new is at 1*y */
a749 1

d752 5
a774 1
		/* XXX old image is at 1*Y, new is at 0*Y */
d784 5
a865 1
	/* Output from 0*y */
d1038 5
@


1.5
log
@Eliminated ppmname. "clear" function
@
text
@d231 8
d247 1
a247 2
	/* XXX Really 8 bytes per pixel? */
	p->im = ( uBYTE * ) malloc  (width*height*sizeof(uBYTE));
a373 3
		planealloc(&Luma   ,w,h);
		planealloc(&Chroma1,w,h);
		planealloc(&Chroma2,w,h);
d377 3
d387 3
a395 1

a406 3
		planealloc(&Luma   ,w,h);
		planealloc(&Chroma1,w,h);
		planealloc(&Chroma2,w,h);
d410 3
d420 3
a484 3
		planealloc(&Luma,w,h);
		planealloc(&Chroma1,w,h);
		planealloc(&Chroma2,w,h);
d488 3
d507 3
@


1.4
log
@Removed turn options
@
text
@a96 1
static void clear();
d101 1
a101 1
static char *pcdname=0,*ppmname=0;
a137 3

#define xTRIF(x,u,o,a,b,c) ((x)<(u)? (a) : ( (x)>(o)?(c):(b)  ))
#define xNORM(x) x=TRIF(x,0,255,0,x,255)
a165 1
		fprintf(stderr,"     -d Show differential picture only \n\n");
d227 1
a227 1
	if(fout && ppmname) fclose(fout);
d256 1
a256 1
	int do_info,do_diff,do_overskip;
d262 1
a262 1
	do_info=do_diff=do_overskip=keep_ycc=0;
a278 9

		if(!strcmp(opt,"d"))
		{ 
			if (!do_diff) do_diff=1;
			else error(E_ARG);
			continue;
		}


a347 6
	if(argc>0)
	{
		ppmname= *argv;
		ASKIP;
	}

a348 1
	if((size==S_Over) && (!ppmname)) error(E_ARG);
a349 2
	if(do_overskip && do_diff) error(E_OPT);
	if(do_diff && (size != S_4Base) && (size != S_16Base)) error(E_OPT);
d390 1
a390 5
		if(!ppmname) fout=stdout;
		else
		{
			if (!(fout=fopen(ppmname,"w"))) error(E_WRITE);
		}
a401 2


d419 1
a419 5
		if(!ppmname) fout=stdout;
		else
		{
			if (!(fout=fopen(ppmname,"w"))) error(E_WRITE);
		}
d465 1
a465 5
		if(!ppmname) fout=stdout;
		else
		{
			if (!(fout=fopen(ppmname,"w"))) error(E_WRITE);
		}
a486 6
			if(do_diff) {
				clear(&Luma,128);
				clear(&Chroma1,156);
				clear(&Chroma2,137);
			}

d524 1
a524 5
		if(!ppmname) fout=stdout;
		else
		{
			if (!(fout=fopen(ppmname,"w"))) error(E_WRITE);
		}
a550 6
		if(do_diff) {
			clear(&Luma,128);
			clear(&Chroma1,156);
			clear(&Chroma2,137);
		}

d566 1
a566 5
		if(!ppmname) fout=stdout;
		else
		{
			if (!(fout=fopen(ppmname,"w"))) error(E_WRITE);
		}
d593 1
a593 1
			sprintf(nbuf,"%s%04d",ppmname,bildnr+1);
a602 3



a603 3



a606 5





a670 10










d694 1
d727 1
a727 1

a737 9









d756 1
a760 1

a761 1

a763 10










d799 1
a822 5





d843 2
a844 1
	for( y=h-1; y>+0; y-- )  {
a850 1
	if(ppmname) fclose(fout);
a1013 1

a1015 4




d1032 7
a1038 7
	#define shiftout(n){ sreg<<=n; inh-=n; \
                     while (inh<=24) \
                      {checkbuf; \
                       sreg |= ((unsigned long)(*(nptr++)))<<(24-inh);\
                       inh+=8;\
                      }\
                    }  
a1152 17




static void clear(l,n)
implane *l;
int n;
{ 
	dim x,y;
	uBYTE *ptr;

	ptr=l->im;
	for (x=0;x<l->mwidth;x++)
		for (y=0; y<l->mheight;y++)
			*(ptr++)=n;
}

@


1.3
log
@Beautified
@
text
@a20 6

/* define OWN_WRITE either here or by compiler-option if you don't want to use
   the pbmplus-routines for writing */
#define xOWN_WRITE


a27 4




a29 6
#ifndef OWN_WRITE

#include "ppm.h"

#else

a33 6
/* The header for the ppm-files */
#if PPM
#define PPM_Header "P6\n%d %d\n255\n"
#else
#define PPM_Header ""	/* for .pix file */
#endif
a34 3
#endif


a66 4




a71 3
enum TURNS  { 
	T_NONE,T_RIGHT,T_LEFT,T_AUTO };

a77 4




a106 3



a133 7







a143 4




a169 1
		fprintf(stderr,"     -s Apply simple sharpness-operator on the Luma-channel\n");
a170 4
		fprintf(stderr,"     -r Rotate clockwise for portraits\n");
		fprintf(stderr,"     -l Rotate counter-clockwise for portraits\n");
		fprintf(stderr,"     -a Try to find out orientation automatically.\n");
		fprintf(stderr,"        (Experimentally, please report if it doesn't work.)\n\n");
a235 8








d244 1
d249 3
a251 4




a262 1
	enum TURNS turn=T_NONE;
a276 21
		if(!strcmp(opt,"r"))
		{
			if (turn == T_NONE) turn=T_RIGHT;
			else error(E_ARG);
			continue;
		}

		if(!strcmp(opt,"l"))
		{
			if (turn == T_NONE) turn=T_LEFT;
			else error(E_ARG);
			continue;
		}

		if(!strcmp(opt,"a"))
		{
			if (turn == T_NONE) turn=T_AUTO;
			else error(E_ARG);
			continue;
		}

a373 1
	if((turn==T_AUTO)&&(size==S_Over)) error(E_TAUTO);
a374 4




d377 1
a377 1
	if(do_info || (turn==T_AUTO))
a382 18
	if(turn==T_AUTO)
	{
		switch(sbuffer[0xe02 & 0x7ff]&0x03)
		{
		case 0x00: 
			turn=T_NONE;  
			break;
		case 0x01: 
			turn=T_LEFT;  
			break;
		case 0x03: 
			turn=T_RIGHT; 
			break;
		default: 
			error(E_TCANT);
		}
	}

a384 4




d418 1
a418 1
		writepicture(w,h,&Luma,&Chroma1,&Chroma2,turn);
d453 1
a453 1
		writepicture(w,h,&Luma,&Chroma1,&Chroma2,turn);
d503 1
a503 1
		writepicture(w,h,&Luma,&Chroma1,&Chroma2,turn);
d572 1
a572 1
		writepicture(w,h,&Luma,&Chroma1,&Chroma2,turn);
d624 1
a624 1
		writepicture(w,h,&Luma,&Chroma1,&Chroma2,turn);
d652 1
a652 1
			writepicture(w,h,&Luma,&Chroma1,&Chroma2,turn);
d924 1
a924 1
static void writepicture(w,h,r,g,b,t)
a926 1
enum TURNS t;
a929 4
#ifndef OWN_WRITE
	pixel *pixrow;
	register pixel* pP;
#else
a936 1
#endif
d943 6
a948 133
	switch (t)
	{ 
	case T_NONE:
#ifndef OWN_WRITE
		ppm_writeppminit(fout,w,h,(pixval) 255, 0);
		pixrow = ppm_allocrow( w );
		for(y=0;y<h;y++)
		{
			pr= r->im + y * r->mwidth;
			pg= g->im + y * g->mwidth;
			pb= b->im + y * b->mwidth;

			for(pP= pixrow,x=0;x<w;x++)
			{
				PPM_ASSIGN(*pP,((int)*pr),((int)*pg),((int)*pb));
				pP++;  
				pr++;  
				pg++;  
				pb++;
			}
			ppm_writeppmrow( fout, pixrow, w, (pixval) 255, 0 );

		}
		pm_close(fout);
#else
		fprintf(fout,PPM_Header,w,h);
		BUinit;
		for(y=0;y<h;y++)
		{
			pr= r->im + y * r->mwidth;
			pg= g->im + y * g->mwidth;
			pb= b->im + y * b->mwidth;

			for(x=0;x<w;x++) BUwrite(*pr++,*pg++,*pb++);
		}
		BUflush;
		if(ppmname) fclose(fout);
#endif
		break;
	case T_RIGHT:
#ifndef OWN_WRITE
		ppm_writeppminit(fout,h,w,(pixval) 255, 0);
		pixrow = ppm_allocrow( h );

		for(y=0;y<w;y++)
		{
			pr= r->im + r->mwidth * ( r->iheight - 1) + y;
			pg= g->im + g->mwidth * ( g->iheight - 1) + y;
			pb= b->im + b->mwidth * ( b->iheight - 1) + y;

			for(pP= pixrow,x=0;x<h;x++)
			{
				PPM_ASSIGN(*pP,((int)*pr),((int)*pg),((int)*pb));
				pP++;	  
				pr-= r->mwidth;  
				pg-= g->mwidth;  
				pb-= b->mwidth;
			}
			ppm_writeppmrow( fout, pixrow, h, (pixval) 255, 0 );

		}
		pm_close(fout);
#else
		fprintf(fout,PPM_Header,h,w);
		BUinit;
		for(y=0;y<w;y++)
		{
			pr= r->im + r->mwidth * ( r->iheight - 1) + y;
			pg= g->im + g->mwidth * ( g->iheight - 1) + y;
			pb= b->im + b->mwidth * ( b->iheight - 1) + y;

			for(x=0;x<h;x++)
			{
				BUwrite(*pr,*pg,*pb);
				pr-= r->mwidth;  
				pg-= g->mwidth;  
				pb-= b->mwidth;
			}
		}
		BUflush;
		if(ppmname) fclose(fout);
#endif
		break;

	case T_LEFT:
#ifndef OWN_WRITE
		ppm_writeppminit(fout,h,w,(pixval) 255, 0);
		pixrow = ppm_allocrow( h );

		for(y=0;y<w;y++)
		{
			pr= r->im + r->iwidth - 1 - y;
			pg= g->im + g->iwidth - 1 - y;
			pb= b->im + b->iwidth - 1 - y;



			for(pP= pixrow,x=0;x<h;x++)
			{
				PPM_ASSIGN(*pP,((int)*pr),((int)*pg),((int)*pb));
				pP++;	  
				pr+= r->mwidth;  
				pg+= g->mwidth;  
				pb+= b->mwidth;
			}
			ppm_writeppmrow( fout, pixrow, h, (pixval) 255, 0 );

		}
		pm_close(fout);
#else
		fprintf(fout,PPM_Header,h,w);
		BUinit;
		for(y=0;y<w;y++)
		{
			pr= r->im + r->iwidth - 1 - y;
			pg= g->im + g->iwidth - 1 - y;
			pb= b->im + b->iwidth - 1 - y;

			for(x=0;x<h;x++)
			{
				BUwrite(*pr,*pg,*pb);
				pr+= r->mwidth;  
				pg+= g->mwidth;  
				pb+= b->mwidth;
			}
		}
		BUflush;
		if(ppmname) fclose(fout);

#endif
		break;
	default: 
		error(E_INTERN);
d950 2
a952 18


















@


1.2
log
@Removed sharpness operator
@
text
@d96 4
a99 3
enum ERRORS { E_NONE,E_READ,E_WRITE,E_INTERN,E_ARG,E_OPT,E_MEM,E_HUFF,
             E_SEQ,E_SEQ1,E_SEQ2,E_SEQ3,E_SEQ4,E_SEQ5,E_SEQ6,E_SEQ7,E_POS,E_IMP,E_OVSKIP,
             E_TAUTO,E_TCANT };
d101 2
a102 1
enum TURNS  { T_NONE,T_RIGHT,T_LEFT,T_AUTO };
d104 2
a105 1
enum SIZES  { S_UNSPEC,S_Base16,S_Base4,S_Base,S_4Base,S_16Base,S_Over };
d115 5
a119 4
 {dim  mwidth,mheight,
       iwidth,iheight;
  uBYTE *im;
 };
d195 2
a196 52
  enum ERRORS e;
 {
  
  switch(e)
   {case E_NONE:   return;
    case E_IMP:    fprintf(stderr,"Sorry, Not yet implemented.\n"); break;
    case E_READ:   fprintf(stderr,"Error while reading.\n"); break;
    case E_WRITE:  fprintf(stderr,"Error while writing.\n"); break;
    case E_INTERN: fprintf(stderr,"Internal error.\n"); break;
    case E_ARG:    fprintf(stderr,"Error in Arguments !\n\n"); 
                   fprintf(stderr,"Usage: hpcdtoppm [options] pcd-file [ppm-file]\n\n");
                   fprintf(stderr,"Opts:\n");
                   fprintf(stderr,"     -x Overskip mode (tries to improve color quality.)\n");
                   fprintf(stderr,"     -i Give some (buggy) informations from fileheader\n");
                   fprintf(stderr,"     -s Apply simple sharpness-operator on the Luma-channel\n");
                   fprintf(stderr,"     -d Show differential picture only \n\n");
                   fprintf(stderr,"     -r Rotate clockwise for portraits\n");
                   fprintf(stderr,"     -l Rotate counter-clockwise for portraits\n");
                   fprintf(stderr,"     -a Try to find out orientation automatically.\n");
                   fprintf(stderr,"        (Experimentally, please report if it doesn't work.)\n\n");
                   fprintf(stderr,"     -ycc suppress ycc to rgb conversion \n");
                   fprintf(stderr,"        (Experimentally, doesn't have deeper sense)\n\n");
                   fprintf(stderr,"     -0 Extract thumbnails from Overview file\n");
                   fprintf(stderr,"     -1 Extract  128x192  from Image file\n");
                   fprintf(stderr,"     -2 Extract  256x384  from Image file\n");
                   fprintf(stderr,"     -3 Extract  512x768  from Image file\n");
                   fprintf(stderr,"     -4 Extract 1024x1536 from Image file\n");
                   fprintf(stderr,"     -5 Extract 2048x3072 from Image file\n");
                   fprintf(stderr,"\n");
                   break;
    case E_OPT:    fprintf(stderr,"These Options are not allowed together.\n");break;
    case E_MEM:    fprintf(stderr,"Not enough memory !\n"); break;
    case E_HUFF:   fprintf(stderr,"Error in Huffman-Code-Table\n"); break;
    case E_SEQ:    fprintf(stderr,"Error in Huffman-Sequence\n"); break;
    case E_SEQ1:   fprintf(stderr,"Error1 in Huffman-Sequence\n"); break;
    case E_SEQ2:   fprintf(stderr,"Error2 in Huffman-Sequence\n"); break;
    case E_SEQ3:   fprintf(stderr,"Error3 in Huffman-Sequence\n"); break;
    case E_SEQ4:   fprintf(stderr,"Error4 in Huffman-Sequence\n"); break;
    case E_SEQ5:   fprintf(stderr,"Error5 in Huffman-Sequence\n"); break;
    case E_SEQ6:   fprintf(stderr,"Error6 in Huffman-Sequence\n"); break;
    case E_SEQ7:   fprintf(stderr,"Error7 in Huffman-Sequence\n"); break;
    case E_POS:    fprintf(stderr,"Error in file-position\n"); break;
    case E_OVSKIP: fprintf(stderr,"Can't read this resolution in overskip-mode\n"); break;
    case E_TAUTO:  fprintf(stderr,"Can't determine the orientation in overview mode\n");break;
    case E_TCANT:  fprintf(stderr,"Sorry, can't determine orientation for this file.\n");
                   fprintf(stderr,"Please give orientation parameters. \n");break;
    default:       fprintf(stderr,"Unknown error %d ???\n",e);break;
   }
  if(fin) fclose(fin);
  if(fout && ppmname) fclose(fout);
  exit(9);
 }
d198 92
d298 1
d300 6
a305 6
  implane *p;
  dim width,height;
 {
  p->iwidth=p->iheight=0;
  p->mwidth=width;
  p->mheight=height;
d307 3
a309 4
  p->im = ( uBYTE * ) malloc  (width*height*sizeof(uBYTE));
  if(!(p->im)) error(E_MEM);
 }
 
d314 1
d316 2
a317 2
  int argc;
  char **argv;
d319 6
a324 5
{int bildnr;
 char *opt;
 dim w,h;
 long cd_offset,cd_offhelp;
 int do_info,do_diff,do_overskip;
d326 4
a329 4
 enum TURNS turn=T_NONE;
 enum SIZES size=S_UNSPEC;
 enum ERRORS eret;
 implane Luma, Chroma1,Chroma2;
d331 1
a331 1
 do_info=do_diff=do_overskip=keep_ycc=0;
d333 1
a333 1
 ASKIP;
d336 4
a339 4
 while((argc>0) && **argv=='-')
  {
   opt= (*argv)+1;
   ASKIP;
d341 6
a346 5
   if(!strcmp(opt,"r"))
    {if (turn == T_NONE) turn=T_RIGHT;
     else error(E_ARG);
     continue;
    }
d348 6
a353 5
   if(!strcmp(opt,"l"))
    {if (turn == T_NONE) turn=T_LEFT;
     else error(E_ARG);
     continue;
    }
d355 6
a360 5
    if(!strcmp(opt,"a"))
    {if (turn == T_NONE) turn=T_AUTO;
     else error(E_ARG);
     continue;
    }
d362 6
a367 5
   if(!strcmp(opt,"i")) 
    { if (!do_info) do_info=1;
      else error(E_ARG);
      continue;
    }
d370 6
a375 5
   if(!strcmp(opt,"d")) 
    { if (!do_diff) do_diff=1;
      else error(E_ARG);
      continue;
    }
d378 6
a383 5
   if(!strcmp(opt,"x")) 
    { if (!do_overskip) do_overskip=1;
      else error(E_ARG);
      continue;
    }
d386 6
a391 5
   if(!strcmp(opt,"ycc")) 
    { if (!keep_ycc) keep_ycc=1;
      else error(E_ARG);
      continue;
    }
a394 26
   
   if((!strcmp(opt,"Base/16")) || (!strcmp(opt,"1"))  || (!strcmp(opt,"128x192")))
    { if (size == S_UNSPEC) size = S_Base16;
      else error(E_ARG);
      continue;
    }
   if((!strcmp(opt,"Base/4" )) || (!strcmp(opt,"2"))  || (!strcmp(opt,"256x384")))
    { if (size == S_UNSPEC) size = S_Base4;
      else error(E_ARG);
      continue;
    }
   if((!strcmp(opt,"Base"   )) || (!strcmp(opt,"3"))  || (!strcmp(opt,"512x768")))
    { if (size == S_UNSPEC) size = S_Base;
      else error(E_ARG);
      continue;
    }
   if((!strcmp(opt,"4Base"  )) || (!strcmp(opt,"4"))  || (!strcmp(opt,"1024x1536")))
    { if (size == S_UNSPEC) size = S_4Base;
      else error(E_ARG);
      continue;
    }
   if((!strcmp(opt,"16Base" )) || (!strcmp(opt,"5"))  || (!strcmp(opt,"2048x3072")))
    { if (size == S_UNSPEC) size = S_16Base;
      else error(E_ARG);
      continue;
    }
d396 30
a425 5
   if((!strcmp(opt,"Overview" )) || (!strcmp(opt,"0"))  || (!strcmp(opt,"O")))
    { if (size == S_UNSPEC) size = S_Over;
      else error(E_ARG);
      continue;
    }
d427 6
a432 3
  fprintf(stderr,"Unknown option: -%s\n",opt);
  error(E_ARG);
  }
d434 3
a439 1
  if(size==S_UNSPEC) size=S_DEFAULT;
d441 1
a441 3
  if(argc<1) error(E_ARG);
  pcdname= *argv;
  ASKIP;
d443 3
a445 13
  if(argc>0) 
   {ppmname= *argv;
    ASKIP;
   }
  
  if(argc>0) error(E_ARG);
  if((size==S_Over) && (!ppmname)) error(E_ARG);
  if(do_info && (size==S_Over)) error(E_OPT);
  if(do_overskip && do_diff) error(E_OPT);
  if(do_diff && (size != S_4Base) && (size != S_16Base)) error(E_OPT);
  if(do_overskip && (size != S_Base16) && (size != S_Base4) && (size != S_Base) && (size != S_4Base) ) error(E_OVSKIP);
  if((turn==T_AUTO)&&(size==S_Over)) error(E_TAUTO);
  
d447 5
d453 7
a461 1
  if(!(fin=fopen(pcdname,"r"))) error(E_READ);
a462 4
  if(do_info || (turn==T_AUTO)) 
   { SEEK(1);
     EREADBUF;
   }
a463 9
  if(turn==T_AUTO)
   {
    switch(sbuffer[0xe02 & 0x7ff]&0x03)
     {case 0x00: turn=T_NONE;  break;
      case 0x01: turn=T_LEFT;  break;
      case 0x03: turn=T_RIGHT; break;
      default: error(E_TCANT);
     }
   }
d465 1
a465 1
  if(do_info) druckeid();
d467 5
d473 17
d491 1
a493 7
  switch(size)
   {
    case S_Base16: w=BaseW/4;
                   h=BaseH/4;
                   planealloc(&Luma   ,w,h);
                   planealloc(&Chroma1,w,h);
                   planealloc(&Chroma2,w,h);
a494 13
                   if(!do_overskip)
                     { SEEK(L_Head+1);
                       error(readplain(w,h,&Luma,&Chroma1,&Chroma2));
                       interpolate(&Chroma1);
                       interpolate(&Chroma2);
                     }
                   else
                     { SEEK(L_Head+1);
                       error(readplain(w,h,&Luma,nullplane,nullplane));
                       SEEK(L_Head+L_Base16+1);
                       error(readplain(2*w,2*h,nullplane,&Chroma1,&Chroma2));
                     }
                    
a495 2
                   ycctorgb(w,h,&Luma,&Chroma1,&Chroma2);
                   /* Now Luma holds red, Chroma1 hold green, Chroma2 holds blue */
d497 8
a504 5
                   if(!ppmname) fout=stdout;
                   else
                    {if (!(fout=fopen(ppmname,"w"))) error(E_WRITE);
		    }
                   writepicture(w,h,&Luma,&Chroma1,&Chroma2,turn);
d506 14
a519 1
                   break;
a520 5
    case S_Base4:  w=BaseW/2;
                   h=BaseH/2;
                   planealloc(&Luma   ,w,h);
                   planealloc(&Chroma1,w,h);
                   planealloc(&Chroma2,w,h);
d522 2
d525 6
d532 1
a532 14
                  if(!do_overskip)
                     { SEEK(L_Head+L_Base16+1);
                       error(readplain(w,h,&Luma,&Chroma1,&Chroma2));
                       interpolate(&Chroma1);
                       interpolate(&Chroma2);
                     }
                   else
                     { SEEK(L_Head+L_Base16+1);
                       error(readplain(w,h,&Luma,nullplane,nullplane));
                       SEEK(L_Head+L_Base16+L_Base4+1); 
                       error(readplain(2*w,2*h,nullplane,&Chroma1,&Chroma2));
                     }
                   ycctorgb(w,h,&Luma,&Chroma1,&Chroma2);
                   /* Now Luma holds red, Chroma1 hold green, Chroma2 holds blue */
d534 6
a539 5
                   if(!ppmname) fout=stdout;
                   else
                    {if (!(fout=fopen(ppmname,"w"))) error(E_WRITE);
		    }
                   writepicture(w,h,&Luma,&Chroma1,&Chroma2,turn);
a540 1
                   break;
a541 2
    case S_Base:   w=BaseW;
                   h=BaseH;
d543 16
a558 19
                   if(!do_overskip)
                     { planealloc(&Luma   ,w,h);
                       planealloc(&Chroma1,w,h);
                       planealloc(&Chroma2,w,h);
                       SEEK(L_Head+L_Base16+L_Base4+1);
                       error(readplain(w,h,&Luma,&Chroma1,&Chroma2));
                       interpolate(&Chroma1);
                       interpolate(&Chroma2);
                     }
                   else
                     { planealloc(&Luma   ,  w,  h);
                       planealloc(&Chroma1,2*w,2*h);
                       planealloc(&Chroma2,2*w,2*h);
                       SEEK(L_Head+L_Base16+L_Base4+1);
                       error(readplain(w,h,&Luma,&Chroma1,&Chroma2));
                       interpolate(&Chroma1);
                       interpolate(&Chroma2);
                       interpolate(&Chroma1);
                       interpolate(&Chroma2);
d560 6
a565 4
                       cd_offset=Skip4Base();
                       SEEK(cd_offset+10);          EREADBUF;    cd_offhelp=(((long)sbuffer[2])<<8)|sbuffer[3];
                       SEEK(cd_offset+12);          readhqt(w,h,3);
                       SEEK(cd_offset+cd_offhelp);  decode(4*w,4*h,nullplane,&Chroma1,&Chroma2,1);
d567 1
a567 5
                       halve(&Chroma1);
                       halve(&Chroma2);
                     }
                   ycctorgb(w,h,&Luma,&Chroma1,&Chroma2);
                   /* Now Luma holds red, Chroma1 hold green, Chroma2 holds blue */
d569 3
a571 5
                   if(!ppmname) fout=stdout;
                   else
                    {if (!(fout=fopen(ppmname,"w"))) error(E_WRITE);
		    }
                   writepicture(w,h,&Luma,&Chroma1,&Chroma2,turn);
d573 21
a593 1
                   break;
d595 8
a602 5
    case S_4Base:  w=BaseW*2;
                   h=BaseH*2;
                   planealloc(&Luma,w,h);
                   planealloc(&Chroma1,w,h);
                   planealloc(&Chroma2,w,h);
d604 5
a608 8
                  if(!do_overskip)
                     {SEEK(L_Head+L_Base16+L_Base4+1);
                      error(readplain(w/2,h/2,&Luma,&Chroma1,&Chroma2));
                      interpolate(&Luma);
                      interpolate(&Chroma1);
                      interpolate(&Chroma1);
                      interpolate(&Chroma2);
                      interpolate(&Chroma2);
d610 6
a615 1
                      if(do_diff) {clear(&Luma,128);clear(&Chroma1,156);clear(&Chroma2,137);}
d617 1
a617 12
                      cd_offset = L_Head + L_Base16 + L_Base4 + L_Base ;
                      SEEK(cd_offset + 4);     readhqt(w,h,1);
                      SEEK(cd_offset + 5);     decode(w,h,&Luma,nullplane,nullplane,0);
                     }
                   else
                     {SEEK(L_Head+L_Base16+L_Base4+1);
                      error(readplain(w/2,h/2,&Luma,&Chroma1,&Chroma2));
                      interpolate(&Luma);
                      interpolate(&Chroma1);
                      interpolate(&Chroma1);
                      interpolate(&Chroma2);
                      interpolate(&Chroma2);
d619 6
a624 3
                      cd_offset = L_Head + L_Base16 + L_Base4 + L_Base ;
                      SEEK(cd_offset + 4);     readhqt(w,h,1);
                      SEEK(cd_offset + 5);     decode(w,h,&Luma,nullplane,nullplane,0);
d626 9
a634 8
                      cd_offset=ftell(fin);if(cd_offset % SECSIZE) error(E_POS);cd_offset/=SECSIZE;
                      SEEK(cd_offset+10);          EREADBUF;    cd_offhelp=(((long)sbuffer[2])<<8)|sbuffer[3];
                      SEEK(cd_offset+12);          readhqt(w,h,3);
                      SEEK(cd_offset+cd_offhelp);  decode(2*w,2*h,nullplane,&Chroma1,&Chroma2,1);
                     
                     }
                   ycctorgb(w,h,&Luma,&Chroma1,&Chroma2);
                   /* Now Luma holds red, Chroma1 hold green, Chroma2 holds blue */
d636 5
a640 5
                   if(!ppmname) fout=stdout;
                   else
                    {if (!(fout=fopen(ppmname,"w"))) error(E_WRITE);
		    }
                   writepicture(w,h,&Luma,&Chroma1,&Chroma2,turn);
d642 15
a656 1
                   break;
d658 5
a662 5
    case S_16Base: w=BaseW*4;
                   h=BaseH*4;
                   planealloc(&Luma,w,h);
                   planealloc(&Chroma1,w,h);
                   planealloc(&Chroma2,w,h);
d664 10
a673 7
                   SEEK(L_Head+L_Base16+L_Base4+1);
                   error(readplain(w/4,h/4,&Luma,&Chroma1,&Chroma2));
                   interpolate(&Luma);
                   interpolate(&Chroma1);
                   interpolate(&Chroma1);
                   interpolate(&Chroma2);
                   interpolate(&Chroma2);
d675 3
a677 4
                   cd_offset = L_Head + L_Base16 + L_Base4 + L_Base ;
                   SEEK(cd_offset + 4);       readhqt(w/2,h/2,1);
                   SEEK(cd_offset + 5);       decode(w/2,h/2,&Luma,nullplane,nullplane,0);
                   interpolate(&Luma);
d679 6
a684 1
                   if(do_diff) {clear(&Luma,128);clear(&Chroma1,156);clear(&Chroma2,137);}
d686 1
a686 1
                   cd_offset=ftell(fin);if(cd_offset % SECSIZE) error(E_POS);cd_offset/=SECSIZE;
d688 6
a693 2
                   SEEK(cd_offset+12);        readhqt(w,h,3);
                   SEEK(cd_offset+14);        decode(w,h,&Luma,&Chroma1,&Chroma2,0);
d695 7
a701 2
                   interpolate(&Chroma1);
                   interpolate(&Chroma2);
d703 6
a708 2
                   ycctorgb(w,h,&Luma,&Chroma1,&Chroma2);
                   /* Now Luma holds red, Chroma1 hold green, Chroma2 holds blue */
d710 5
a714 5
                   if(!ppmname) fout=stdout;
                   else
                    {if (!(fout=fopen(ppmname,"w"))) error(E_WRITE);
		    }
                   writepicture(w,h,&Luma,&Chroma1,&Chroma2,turn);
d716 3
a718 1
                   break;
d720 4
a723 6
    case S_Over:   w=BaseW/4;
                   h=BaseH/4;
             
                   planealloc(&Luma   ,w,h);
                   planealloc(&Chroma1,w,h);
                   planealloc(&Chroma2,w,h);
d725 2
a726 7
                   for(bildnr=0;!feof(fin);bildnr++)
		    {
		       SEEK(5+SeBase16*bildnr);
    
		       eret=readplain(w,h,&Luma,&Chroma1,&Chroma2);
                       if(eret==E_READ) break;
                       error(eret);
d728 2
a729 11
		       interpolate(&Chroma1);
		       interpolate(&Chroma2);
    
		       ycctorgb(w,h,&Luma,&Chroma1,&Chroma2);
		       /* Now Luma holds red, Chroma1 hold green, Chroma2 holds blue */
    
                       sprintf(nbuf,"%s%04d",ppmname,bildnr+1);
		       if (!(fout=fopen(nbuf,"w"))) error(E_WRITE);
		       writepicture(w,h,&Luma,&Chroma1,&Chroma2,turn);
		     }
                   break;
d731 6
a736 2
     default: error(E_INTERN); 
   }
d738 1
d740 3
d744 3
d748 3
a750 1
exit(0);
d752 3
d756 2
d759 20
d788 6
a793 5
  dim w,h;
  implane *l,*c1,*c2;
 {dim i;
  uBYTE *pl=0,*pc1=0,*pc2=0;
  melde("readplain\n");
d795 7
a801 6
  if(l)
   { if ((l->mwidth<w) || (l->mheight<h) || (!l->im)) error(E_INTERN);
     l->iwidth=w;
     l->iheight=h;
     pl=l->im;
   }
d803 7
a809 6
  if(c1)
   { if ((c1->mwidth<w/2) || (c1->mheight<h/2) || (!c1->im)) error(E_INTERN);
     c1->iwidth=w/2;
     c1->iheight=h/2;
     pc1=c1->im;
   }
d811 7
a817 6
  if(c2)
   { if ((c2->mwidth<w/2) || (c2->mheight<h/2) || (!c2->im)) error(E_INTERN);
     c2->iwidth=w/2;
     c2->iheight=h/2;
     pc2=c2->im;
   }
d819 6
a824 6
  for(i=0;i<h/2;i++)
   {
    if(pl)
     { 
       if(fread(pl,w,1,fin)<1) return(E_READ);
       pl+= l->mwidth;
d826 4
a829 16
       if(fread(pl,w,1,fin)<1) return(E_READ);
       pl+= l->mwidth;
     }
    else SKIPr(2*w);
     
    if(pc1)
     { if(fread(pc1,w/2,1,fin)<1) return(E_READ);
       pc1+= c1->mwidth;
     }
    else SKIPr(w/2);
     
    if(pc2)
     { if(fread(pc2,w/2,1,fin)<1) return(E_READ);
       pc2+= c2->mwidth;
     }
    else SKIPr(w/2);
d831 6
d838 6
a843 4
   }
  RPRINT;
  return E_NONE;
 }
d846 4
d859 2
d862 4
a865 3
  implane *p;
 {dim w,h,x,y,yi;
  uBYTE *optr,*nptr,*uptr;
d867 2
a868 2
  melde("interpolate\n");
  if ((!p) || (!p->im)) error(E_INTERN);
d870 2
a871 2
  w=p->iwidth;
  h=p->iheight;
d873 2
a874 2
  if(p->mwidth  < 2*w ) error(E_INTERN);
  if(p->mheight < 2*h ) error(E_INTERN);
d877 2
a878 2
  p->iwidth=2*w;
  p->iheight=2*h;
d881 5
a885 4
  for(y=0;y<h;y++)
   {yi=h-1-y;
    optr=p->im+  yi*p->mwidth + (w-1);
    nptr=p->im+2*yi*p->mwidth + (2*w - 2);
d887 1
a887 1
    nptr[0]=nptr[1]=optr[0];
d889 8
a896 6
    for(x=1;x<w;x++)
     { optr--; nptr-=2;
       nptr[0]=optr[0];
       nptr[1]=(((int)optr[0])+((int)optr[1])+1)>>1;
     }
    }
d898 5
a902 4
  for(y=0;y<h-1;y++)
   {optr=p->im + 2*y*p->mwidth;
    nptr=optr+p->mwidth;
    uptr=nptr+p->mwidth;
d904 11
a914 9
    for(x=0;x<w-1;x++)
     {
      nptr[0]=(((int)optr[0])+((int)uptr[0])+1)>>1;
      nptr[1]=(((int)optr[0])+((int)optr[2])+((int)uptr[0])+((int)uptr[2])+2)>>2;
      nptr+=2; optr+=2; uptr+=2;
     }
    *(nptr++)=(((int)*(optr++))+((int)*(uptr++))+1)>>1;
    *(nptr++)=(((int)*(optr++))+((int)*(uptr++))+1)>>1;
   }
d917 7
a923 4
  optr=p->im + (2*h-2)*p->mwidth;
  nptr=p->im + (2*h-1)*p->mwidth;
  for(x=0;x<w;x++)
   { *(nptr++) = *(optr++);  *(nptr++) = *(optr++); }
d925 1
a925 1
 }
d937 4
a940 3
  implane *p;
 {dim w,h,x,y;
  uBYTE *optr,*nptr;
d942 2
a943 2
  melde("halve\n");
  if ((!p) || (!p->im)) error(E_INTERN);
d945 2
a946 2
  w=p->iwidth/=2;      
  h=p->iheight/=2;     
d949 4
a952 4
  for(y=0;y<h;y++)
   {
    nptr=(p->im) +   y*(p->mwidth);
    optr=(p->im) + 2*y*(p->mwidth);
d954 4
a957 3
    for(x=0;x<w;x++,nptr++,optr+=2)
     { *nptr = *optr;
     }
d959 1
a959 1
   }
d961 1
a961 1
 }
d976 9
a984 8
  dim w,h;
  implane *l,*c1,*c2;
 {dim x,y;
  uBYTE *pl,*pc1,*pc2;
  long red,green,blue,i;
  long L;
  static int init=0;
  static long XL[256],XC1[256],XC2[256],XC1g[256],XC2g[256];
d986 4
a989 4
  melde("ycctorgb\n");
  if((!l ) || ( l->iwidth != w ) || ( l->iheight != h) || (! l->im)) error(E_INTERN);
  if((!c1) || (c1->iwidth != w ) || (c1->iheight != h) || (!c1->im)) error(E_INTERN);
  if((!c2) || (c2->iwidth != w ) || (c2->iheight != h) || (!c2->im)) error(E_INTERN);
d991 1
a991 1
  if(keep_ycc) return;
d993 12
a1004 10
  if(!init)
   {init=1;
    for(i=0;i<256;i++)
     {  XL[i]= 5564 * i + 2048;
       XC1[i]= 9085 * i - 1417185;
       XC2[i]= 7461 * i - 1022138;
      XC1g[i]= 274934 - 1762 * i;
      XC2g[i]= 520268 - 3798 * i; 
     }
   }
d1006 5
a1010 5
  for(y=0;y<h;y++)
   {
    pl =  l->im + y *  l->mwidth;
    pc1= c1->im + y * c1->mwidth;
    pc2= c2->im + y * c2->mwidth;
d1012 6
a1017 6
    for(x=0;x<w;x++)
     {
      L = XL[*pl]; 
      red  =(L + XC2[*pc2]               )>>BitShift;
      green=(L + XC1g[*pc1] + XC2g[*pc2] )>>BitShift; 
      blue =(L + XC1[*pc1]               )>>BitShift;
d1019 3
a1021 3
      NORM(red);
      NORM(green);
      NORM(blue);
d1023 6
a1028 6
      *(pl++ )=red; 
      *(pc1++)=green; 
      *(pc2++)=blue;
     }
   }
 }
d1037 6
a1042 5
  dim w,h;
  implane *r,*g,*b;
  enum TURNS t;
 {dim x,y;
  register uBYTE *pr,*pg,*pb;
d1044 2
a1045 2
  pixel *pixrow;
  register pixel* pP;
d1047 2
a1048 2
  static uBYTE BUF[own_BUsize],*BUptr;
  int   BUcount;
d1056 4
a1059 4
  melde("writepicture\n");
  if((!r) || (r->iwidth != w ) || (r->iheight != h) || (!r->im)) error(E_INTERN);
  if((!g) || (g->iwidth != w ) || (g->iheight != h) || (!g->im)) error(E_INTERN);
  if((!b) || (b->iwidth != w ) || (b->iheight != h) || (!b->im)) error(E_INTERN);
d1061 3
a1063 2
  switch (t)
   { case T_NONE:
d1065 20
a1084 17
              ppm_writeppminit(fout,w,h,(pixval) 255, 0);
              pixrow = ppm_allocrow( w );
	      for(y=0;y<h;y++)
	       {
		pr= r->im + y * r->mwidth;
		pg= g->im + y * g->mwidth;
		pb= b->im + y * b->mwidth;
	    
     		for(pP= pixrow,x=0;x<w;x++)
		 {
		  PPM_ASSIGN(*pP,((int)*pr),((int)*pg),((int)*pb));
		  pP++;  pr++;  pg++;  pb++;
		 }
		ppm_writeppmrow( fout, pixrow, w, (pixval) 255, 0 );
	    
	       }
	      pm_close(fout);
d1086 12
a1097 12
              fprintf(fout,PPM_Header,w,h);
              BUinit;
	      for(y=0;y<h;y++)
	       {
		pr= r->im + y * r->mwidth;
		pg= g->im + y * g->mwidth;
		pb= b->im + y * b->mwidth;
		
     		for(x=0;x<w;x++) BUwrite(*pr++,*pg++,*pb++);	    
	       }
              BUflush;
              if(ppmname) fclose(fout);
d1099 2
a1100 2
              break;
     case T_RIGHT:
d1102 2
a1103 2
              ppm_writeppminit(fout,h,w,(pixval) 255, 0);
              pixrow = ppm_allocrow( h );
d1105 18
a1122 15
	      for(y=0;y<w;y++)
	       {
		pr= r->im + r->mwidth * ( r->iheight - 1) + y;
		pg= g->im + g->mwidth * ( g->iheight - 1) + y;
		pb= b->im + b->mwidth * ( b->iheight - 1) + y;
	    
		for(pP= pixrow,x=0;x<h;x++)
		 {
		  PPM_ASSIGN(*pP,((int)*pr),((int)*pg),((int)*pb));
		  pP++;	  pr-= r->mwidth;  pg-= g->mwidth;  pb-= b->mwidth;
		 }
		ppm_writeppmrow( fout, pixrow, h, (pixval) 255, 0 );
	    
	       }
	      pm_close(fout);
d1124 18
a1141 15
              fprintf(fout,PPM_Header,h,w);
              BUinit;
	      for(y=0;y<w;y++)
	       {
		pr= r->im + r->mwidth * ( r->iheight - 1) + y;
		pg= g->im + g->mwidth * ( g->iheight - 1) + y;
		pb= b->im + b->mwidth * ( b->iheight - 1) + y;
		
     		for(x=0;x<h;x++) 
                {BUwrite(*pr,*pg,*pb);	
		 pr-= r->mwidth;  pg-= g->mwidth;  pb-= b->mwidth;
                }    
	       }
              BUflush;
              if(ppmname) fclose(fout);
d1143 1
a1143 1
              break;
d1145 1
a1145 1
      case T_LEFT:
d1147 2
a1148 2
              ppm_writeppminit(fout,h,w,(pixval) 255, 0);
              pixrow = ppm_allocrow( h );
d1150 20
a1169 17
	      for(y=0;y<w;y++)
	       {
		pr= r->im + r->iwidth - 1 - y;
		pg= g->im + g->iwidth - 1 - y;
		pb= b->im + b->iwidth - 1 - y;
	    
		
	    
		for(pP= pixrow,x=0;x<h;x++)
		 {
		  PPM_ASSIGN(*pP,((int)*pr),((int)*pg),((int)*pb));
		  pP++;	  pr+= r->mwidth;  pg+= g->mwidth;  pb+= b->mwidth;
		 }
		ppm_writeppmrow( fout, pixrow, h, (pixval) 255, 0 );
	    
	       }
	      pm_close(fout);
d1171 7
a1177 15
              fprintf(fout,PPM_Header,h,w);
              BUinit;
	      for(y=0;y<w;y++)
	       {
		pr= r->im + r->iwidth - 1 - y;
		pg= g->im + g->iwidth - 1 - y;
		pb= b->im + b->iwidth - 1 - y;
		
     		for(x=0;x<h;x++) 
                {BUwrite(*pr,*pg,*pb);	
		 pr+= r->mwidth;  pg+= g->mwidth;  pb+= b->mwidth;
                }    
	       }
              BUflush;
              if(ppmname) fclose(fout);
d1179 11
d1191 5
a1195 4
              break;
      default: error(E_INTERN);
    }
 }
d1217 11
a1227 10
 {char  id1[8];
  uBYTE ww1[14];
  char  id2[20];
  char  id3[4*16+4];
  short ww2;
  char  id4[20];
  uBYTE ww3[2*16+1];
  char  id5[4*16];
  uBYTE idx[11*16];
 } ;
d1231 4
a1234 3
{int i;
 struct ph1 *d;
 char ss[100];
d1236 1
a1236 1
 d=(struct ph1 *)sbuffer;
d1247 5
a1251 5
dr(d->id1,"Id1")
dr(d->id2,"Id2")
dr(d->id3,"Id3")
dr(d->id4,"Id4")
dr(d->id5,"Id5")
d1253 1
a1253 1
/*
d1267 3
a1269 2
 { uBYTE high,low;
 };
d1274 4
a1277 3
  dim w,h;
 {int i;
  struct pcdword *ptr;
d1279 1
a1279 1
  EREADBUF;
d1281 1
a1281 1
  ptr = (struct pcdword *)sbuffer;
d1283 4
a1286 3
  for(i=0;i<h/4;i++,ptr++)
   {lpt[i] = ((int)ptr->high)<<8 | ptr->low ;
   }
a1288 2
  
 }
d1290 1
a1292 3
struct pcdquad { uBYTE len,highseq,lowseq,key;};
struct pcdhqt  { uBYTE entries; struct pcdquad entry[256];};
struct myhqt { unsigned long seq,mask,len; uBYTE key; };
d1294 11
d1306 1
d1311 8
a1318 7
  struct pcdhqt *source;
  struct myhqt *ziel;
  int *anzahl;
 {int i;
  struct pcdquad *sub;
  struct myhqt *help;
  *anzahl=(source->entries)+1;
d1320 4
a1323 3
  for(i=0;i<*anzahl;i++)
   {sub = (struct pcdquad *)(((uBYTE *)source)+1+i*sizeof(*sub));
    help=ziel+i;
d1325 3
a1327 3
    help->seq = (((unsigned long) sub->highseq) << 24) |(((unsigned long) sub->lowseq) << 16);
    help->len = ((unsigned long) sub->len) +1;
    help->key = sub->key;
d1330 3
a1332 3
   fprintf(stderr," Anz: %d A1: %08x  A2: %08x X:%02x %02x %02x %02x Seq:  %08x   Laenge:  %d %d\n",
          *anzahl,sbuffer,sub,((uBYTE *)sub)[0],((uBYTE *)sub)[1],((uBYTE *)sub)[2],((uBYTE *)sub)[3],
          help->seq,help->len,sizeof(uBYTE));
d1335 1
a1335 1
    if(help->len > 16) error(E_HUFF);
d1337 1
a1337 1
    help->mask = ~ ( (E << (32-help->len)) -1); 
d1339 1
a1339 1
  }
d1341 7
a1347 6
  for(i=0;i<*anzahl;i++)
   {help=ziel+i;
    fprintf(stderr,"H: %3d  %08lx & %08lx (%2d) = %02x = %5d  %8x\n",
        i, help->seq,help->mask,help->len,help->key,(signed char)help->key,
        help->seq & (~help->mask));
   }
d1358 4
a1361 4
  dim w,h;
  int n;
 {
  uBYTE *ptr;
d1363 3
a1365 3
  melde("readhqt\n");
  EREADBUF;
  ptr = sbuffer;
d1367 1
a1367 1
  readhqtsub((struct pcdhqt *)ptr,myhuff0,&myhufflen0);
d1369 3
a1371 3
  if(n<2) return;
  ptr+= 1 + 4* myhufflen0;
  readhqtsub((struct pcdhqt *)ptr,myhuff1,&myhufflen1);
d1373 3
a1375 3
  if(n<3) return;
  ptr+= 1 + 4* myhufflen1;
  readhqtsub((struct pcdhqt *)ptr,myhuff2,&myhufflen2);
d1384 8
a1391 7
  dim w,h;
  implane *f,*f1,*f2;
  int autosync;
 {int i,htlen,sum;
  unsigned long sreg,maxwidth;
  unsigned int inh,n,zeile,segment,ident;
  struct myhqt *htptr,*hp;
d1393 2
a1394 2
  uBYTE *nptr;
  uBYTE *lptr;
d1396 1
a1396 1
  melde("decode\n");
d1399 1
a1399 1
#define shiftout(n){ sreg<<=n; inh-=n; \
d1410 3
a1412 3
  if( f  && ((! f->im) || ( f->iheight < h  ) ||  (f->iwidth<w  ))) error(E_INTERN);
  if( f1 && ((!f1->im) || (f1->iheight < h/2) || (f1->iwidth<w/2))) error(E_INTERN);
  if( f2 && ((!f2->im) || (f2->iheight < h/2) || (f2->iwidth<w/2))) error(E_INTERN);
d1414 7
a1420 7
  htlen=sreg=maxwidth=0;
  htptr=0;
  nextbuf;
  inh=32;
  lptr=0;
  shiftout(16);
  shiftout(16);
d1422 1
a1422 1
  if(autosync) seeksync;
d1424 8
a1431 7
  n=0;
  for(;;)
   {
    if (issync)
     {shiftout(24);
      ident=sreg>>16;
      shiftout(16);
d1433 2
a1434 2
      zeile=(ident>>1) & 0x1fff;
      segment=ident>>14;
d1437 2
a1438 2
      fprintf(stderr,"Ident %4x Zeile:  %6d  Segment %3d Pixels bisher: %5d   Position: %8lx\n",
          ident,zeile,segment,n,bufpos);
d1442 2
a1443 2
      if(lptr && (n!=maxwidth)) error(E_SEQ1);
      n=0;
d1445 5
a1449 2
      if(zeile==h) {RPRINT; return; }
      if(zeile >h) error(E_SEQ2);
d1451 13
a1463 9
      switch(segment)
       {
        case 0: if((!f) && autosync) {seeksync; break;}
                if(!f) error(E_SEQ7);
                lptr=f->im + zeile*f->mwidth;
                maxwidth=f->iwidth;
                htlen=myhufflen0;
                htptr=myhuff0;
                break;
d1465 11
a1475 15
        case 2: if((!f1) && autosync) {seeksync; break;}
                if(!f1) error(E_SEQ7);
                lptr=f1->im + (zeile>>1)*f1->mwidth;
                maxwidth=f1->iwidth;
                htlen=myhufflen1;
                htptr=myhuff1;
                break;
 
        case 3: if((!f2) && autosync) {seeksync; break;}
                if(!f2) error(E_SEQ7);
                lptr=f2->im + (zeile>>1)*f2->mwidth;
                maxwidth=f2->iwidth;
                htlen=myhufflen2;
                htptr=myhuff2;
                break;
d1477 11
a1487 10
        default:error(E_SEQ3);
	}
     }
    else
     {
/*      if((!lptr) || (n>maxwidth)) error(E_SEQ4);*/
      if(!lptr)      error(E_SEQ6);
      if(n>maxwidth) error(E_SEQ4);
      for(i=0,hp=htptr;(i<htlen) && ((sreg & hp->mask)!= hp->seq); i++,hp++);
      if(i>=htlen) error(E_SEQ5);
d1489 11
a1499 3
      sum=((int)(*lptr)) + ((sBYTE)hp->key);
      NORM(sum);
      *(lptr++) = sum;
d1501 3
a1503 2
      n++; 
      shiftout(hp->len);
d1505 2
a1506 1
     }
d1508 1
a1508 1
   }
d1510 1
d1512 1
d1519 1
a1519 1
 }
d1525 5
a1529 4
  implane *l;
  int n;
{ dim x,y;
  uBYTE *ptr;
d1531 4
a1534 4
  ptr=l->im;
  for (x=0;x<l->mwidth;x++)
    for (y=0; y<l->mheight;y++)
      *(ptr++)=n;
d1539 4
a1542 3
 {int i,j;
  for(i=j=0;i<32;i++)
    if(sbuffer[i]==0xff) j++;
d1544 1
a1544 3
  return (j>30);
  
 }
d1546 2
d1549 2
a1550 6
  {long cd_offset,cd_offhelp;
   
   cd_offset = L_Head + L_Base16 + L_Base4 + L_Base ;
   SEEK(cd_offset+3);          
   EREADBUF;    
   cd_offhelp=(((long)sbuffer[510])<<8)|sbuffer[511] + 1;
d1552 4
a1555 1
   cd_offset+=cd_offhelp;
d1557 11
a1567 8
   SEEK(cd_offset);
   EREADBUF;
   while(!testbegin())
    {cd_offset++;
     EREADBUF;
    }
   return cd_offset;
  }
@


1.1
log
@Initial revision
@
text
@a130 1
static void sharpit();
d137 1
a137 1
static int do_sharp,keep_ycc;
d283 1
a283 1
 do_info=do_diff=do_overskip=do_sharp=keep_ycc=0;
d287 1
a323 5
   if(!strcmp(opt,"s")) 
    { if (!do_sharp) do_sharp=1;
      else error(E_ARG);
      continue;
    }
a324 1

a852 1
  if(do_sharp) sharpit(l);
a1342 53



#define slen 3072

static void sharpit(l)
  implane *l;
 {int x,y,h,w,mw,akk;
  uBYTE f1[slen],f2[slen],*old,*akt,*ptr,*work,*help,*optr;

  if((!l) || (!l->im)) error(E_INTERN);
  if(l->iwidth > slen) error(E_INTERN);

  old=f1; akt=f2;
  h=l->iheight;
  w=l->iwidth;
  mw=l->mwidth;

  for(y=1;y<h-1;y++)
   {
    ptr=l->im+ y*mw;
    optr=ptr-mw;
    work=akt;

    *(work++)= *(ptr++);
    for(x=1;x<w-1;x++)
     {  akk = 5*((int)ptr[0])- ((int)ptr[1])  - ((int)ptr[-1]) 
                              - ((int)ptr[mw]) - ((int)ptr[-mw]);
        NORM(akk);
        *(work++)=akk;
        ptr++;
     }

    *(work++)= *(ptr++);

    if(y>1) bcopy(old,optr,w);
    help=old;old=akt;akt=help;
     
   }



  akt=optr+mw;
  for(x=0;x<w;x++)
    *(akt++) = *(old++);
 }


#undef slen




@
