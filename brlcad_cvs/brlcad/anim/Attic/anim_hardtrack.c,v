head	11.15;
access;
symbols
	ansi-20040405-merged:11.11.2.2
	postmerge-20040405-ansi:11.13
	premerge-20040404-ansi:11.12
	postmerge-autoconf:11.12
	autoconf-freeze:11.11.10.1
	premerge-autoconf:11.12
	ansi-20040316-freeze:11.11.2.1
	postmerge-20040315-windows:11.12
	premerge-20040315-windows:11.12
	windows-20040315-freeze:11.11.4.1
	autoconf-20031203:11.11
	autoconf-20031202:11.11
	autoconf-branch:11.11.0.10
	phong-branch:11.11.0.8
	photonmap-branch:11.11.0.6
	rel-6-1-DP:11.11
	windows-branch:11.11.0.4
	rel-6-0-2:11.9
	ansi-branch:11.11.0.2
	rel-6-0-1-branch:11.9.0.2
	hartley-6-0-post:11.10
	hartley-6-0-pre:11.9
	rel-6-0-1:11.9
	rel-6-0:11.9
	rel-5-4:11.8
	offsite-5-3-pre:11.8
	rel-5-3:11.8
	rel-5-2:11.8
	rel-5-1-branch:11.8.0.2
	rel-5-1:11.8
	rel-5-0:11.8
	rel-5-0-beta:11.7
	rel-4-5:11.7
	ctj-4-5-post:11.6
	ctj-4-5-pre:11.6
	rel-4-4:11.1;
locks; strict;
comment	@ * @;


11.15
date	2004.05.24.04.17.00;	author morrison;	state dead;
branches;
next	11.14;

11.14
date	2004.05.10.15.30.41;	author erikg;	state Exp;
branches;
next	11.13;

11.13
date	2004.04.05.07.50.19;	author morrison;	state Exp;
branches;
next	11.12;

11.12
date	2004.02.02.17.38.57;	author morrison;	state Exp;
branches;
next	11.11;

11.11
date	2002.08.20.17.07.18;	author jra;	state Exp;
branches
	11.11.2.1
	11.11.4.1
	11.11.10.1;
next	11.10;

11.10
date	2002.08.15.20.54.05;	author hartley;	state Exp;
branches;
next	11.9;

11.9
date	2001.08.21.18.55.18;	author jra;	state Exp;
branches;
next	11.8;

11.8
date	99.07.02.22.07.11;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	97.08.22.22.48.24;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	97.03.24.14.51.26;	author jra;	state Exp;
branches;
next	11.5;

11.5
date	96.07.31.20.22.27;	author cnuzman;	state Exp;
branches;
next	11.4;

11.4
date	96.07.30.01.05.51;	author cnuzman;	state Exp;
branches;
next	11.3;

11.3
date	96.06.28.22.00.56;	author cnuzman;	state Exp;
branches;
next	11.2;

11.2
date	95.07.10.23.34.25;	author cnuzman;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.33.59;	author mike;	state Rel4_4;
branches;
next	1.3;

1.3
date	94.09.23.14.32.17;	author stay;	state Exp;
branches;
next	1.2;

1.2
date	94.08.25.11.02.36;	author cnuzman;	state Exp;
branches;
next	1.1;

1.1
date	94.08.04.21.19.47;	author cnuzman;	state Exp;
branches;
next	;

11.11.2.1
date	2002.09.19.18.00.31;	author morrison;	state Exp;
branches;
next	11.11.2.2;

11.11.2.2
date	2004.03.17.21.15.47;	author morrison;	state Exp;
branches;
next	;

11.11.4.1
date	2004.03.11.23.40.24;	author morrison;	state Exp;
branches;
next	;

11.11.10.1
date	2004.02.12.19.40.39;	author erikg;	state Exp;
branches;
next	;


desc
@program to create animation scripts for a tracked vehicle with rigid wheels.
@


11.15
log
@moved to src/anim/
@
text
@/*			A N I M _ H A R D T R A C K . C
 *
 *  Animate the links and wheels of a tracked vehicle. It is assumed
 *  that the wheels do not translate with respect to the vehicle.
 *
 *  Author -
 *	Carl J. Nuzman
 *  
 *  Source -
 *      The U. S. Army Research Laboratory
 *      Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *      Re-distribution of this software is restricted, as described in
 *      your "Statement of Terms and Conditions for the Release of
 *      The BRL-CAD Pacakge" agreement.
 *
 *  Copyright Notice -
 *      This software is Copyright (C) 1993-2004 by the United States Army
 *      in all countries except the USA.  All rights reserved.
 */

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include "machine.h"
#include "vmath.h"
#include "bu.h"
#include "bn.h"
#include "anim.h"

#ifndef M_PI
#define M_PI	3.14159265358979323846
#endif

#ifndef M_PI_2
#define M_PI_2	(M_PI*0.5)
#endif

#define NW	num_wheels
#define NEXT(i)	(i+1)%NW
#define PREV(i)	(i+NW-1)%NW

#define TRACK_ANIM	0
#define TRACK_ARCED	1

typedef double *pdouble;

struct wheel {
vect_t		pos;	/* displacement of wheel from vehicle origin */
fastf_t		rad;	/* radius of wheel */
fastf_t		ang0;	/* angle where track meets wheel; 0 < a < 2pi */
fastf_t		ang1;	/* angle where track leaves wheel; 0 < a < 2pi */
fastf_t		arc;	/* arclength of contact between wheel and track */
};

struct track {
vect_t		pos0;	/* beginning point of track section */
vect_t		pos1;	/* end point of track section */
vect_t		dir;	/* unit vector: direction of track section */
fastf_t		len;	/* length of track section */
};

struct slope {
vect_t		dir;	/* vector from previous to current axle */
fastf_t		len;	/* length of vector described above */
};

struct all {
struct wheel 	w;	/* parameters describing the track around a wheel */
struct track	t;	/* track between this wheel and the previous wheel */
struct slope	s;	/* vector between this axle and the previous axle */
};

struct rlink {
vect_t		pos;	/* reverse of initial position */
fastf_t		ang;	/* initial angle */
};

/* external variables */
extern int bu_optind;
extern char *bu_optarg;

/* variables describing track geometry - used by main, trackprep, get_link */
struct all *x;
struct rlink *r;		/* reverse of initial locations of links */
int num_links, num_wheels;
fastf_t track_y, tracklen;

/* variables set by get_args */
int wheel_nindex;	/* argv[wheel_nindex] = wheelname*/
int link_nindex;	/* argv[link_nindex] = linkname*/
int print_wheel;	/* flag: do wheel animation */
int print_link;		/* flag: do link animation */
int print_mode;		/*  anim for rt or arced for mged */
int arced_frame;	/* which frame to arced */
int links_placed;	/* flag: links are initially on the track */
int axes, cent;		/* flags: alternate axes, centroid specified */
int steer;		/* flag: vehicle automatically steered */
int first_frame;	/* integer with which to begin numbering frames */
fastf_t radius;		/* common radius of all wheels */
fastf_t init_dist; 	/* initial distance of first link along track */
vect_t centroid, rcentroid;	/* alternate centroid and its reverse */
mat_t m_axes, m_rev_axes;	/* matrices to and from alternate axes */
char link_cmd[10];		/* default is "rarc" */
char wheel_cmd[10];		/* default is "lmul" */
int get_circumf;	/* flag: just return circumference of track */

int get_link(fastf_t *pos, fastf_t *angle_p, fastf_t dist);

int
main(int argc, char **argv)
{
	void anim_dir2mat(fastf_t *, const fastf_t *, const fastf_t *), anim_y_p_r2mat(fastf_t *, double, double, double), anim_add_trans(fastf_t *, const fastf_t *, const fastf_t *),anim_mat_print(FILE *, const fastf_t *, int);
	int get_args(int argc, char **argv), track_prep(void), val, frame, go, i, count;
	fastf_t y_rot, distance, yaw, pitch, roll;
	vect_t p1, p2, p3, dir, dir2, wheel_now, wheel_prev;
	vect_t zero, position, vdelta, temp, to_track, to_front;
	mat_t mat_v, wmat, mat_x;
	FILE *stream;
	int last_frame;

	VSETALL(zero,0.0);
	VSETALL(to_track,0.0);
	VSETALL(centroid,0.0);
	VSETALL(rcentroid,0.0);
	init_dist = y_rot = radius= 0.0;
	first_frame = num_wheels = steer = axes = cent = links_placed=0;
	num_wheels = num_links = last_frame = 0;
	MAT_IDN(mat_v);
	MAT_IDN(mat_x);
	MAT_IDN(wmat);
	MAT_IDN(m_axes);
	MAT_IDN(m_rev_axes);

	if (!get_args(argc,argv)){
		fprintf(stderr,"anim_hardtrack: argument error.");
		return(-1);
	}

	if (axes || cent ){ /* vehicle has own reference frame */
		anim_add_trans(m_axes,centroid,zero);
		anim_add_trans(m_rev_axes,zero,rcentroid);
	}

	/* get track information from specified file */

	if (!(stream = fopen(*(argv+bu_optind),"r"))){
		fprintf(stderr,"Anim_hardtrack: Could not open file %s.\n",*(argv+bu_optind));
		return(0);
	}
	num_wheels = -1;
	if (radius) {
		while (!feof(stream)) {
			fscanf(stream,"%*f %*f %*f");
			num_wheels++;
		}
	} else {
		while (!feof(stream)) {
			fscanf(stream,"%*f %*f %*f %*f");
			num_wheels++;
		}
	}
	rewind(stream);

	/*allocate memory for track information*/
	x = (struct all *) calloc(num_wheels,sizeof(struct all));
		/*read rest of track info */
	for (i=0;i<NW;i++){
		fscanf(stream,"%lf %lf %lf", temp, temp+1, temp+2);
		if (radius)
			x[i].w.rad = radius;
		else
			fscanf(stream,"%lf",& x[i].w.rad);
		MAT4X3PNT(x[i].w.pos,m_rev_axes,temp);
		if (i==0)
			track_y = x[0].w.pos[1];
		else
			x[i].w.pos[1] = track_y;
	}
	(void) fclose(stream);

	(void) track_prep();

	if (get_circumf) {
		printf("%.10g\n",tracklen);
		return(0);
	}

	/* initialize to_track */
	VSET(to_track, 0.0, track_y, 0.0);
	VSET(to_front,1.0,0.0,0.0);

	if ((!print_link)&&(!print_wheel)) {
		fprintf(stderr,"anim_hardtrack: no ouput requested. Use -l or -w.\n");
		exit(0);
	}
	/* main loop */
	distance = 0.0;
	if(!steer)
		frame = first_frame;
	else
		frame = first_frame-1; 
	for (val = 3; val > 2; frame++) {
		go = 1;
		/*p2 is current position. p3 is next;p1 is previous*/
		VMOVE(p1,p2);
		VMOVE(p2,p3);
		scanf("%*f");/*time stamp*/
		val = scanf("%lf %lf %lf", p3, p3+1, p3 + 2);
		if(!steer){
			scanf("%lf %lf %lf",&yaw,&pitch,&roll);
			anim_dy_p_r2mat(mat_v,yaw,pitch,roll);
			anim_add_trans(mat_v,p3,rcentroid);			
		}
		else { /* analyze positions for steering */
			/*get useful direction unit vectors*/
			if (frame == first_frame){ /* first frame*/
				VSUBUNIT(dir,p3,p2);
				VMOVE(dir2,dir);
			}
			else if (val < 3){ /*last frame*/
				VSUBUNIT(dir,p2,p1);
				VMOVE(dir2,dir);
			}
			else if (frame > first_frame){ /*normal*/
				VSUBUNIT(dir,p3,p1);
				VSUBUNIT(dir2,p2,p1);/*needed for vertical case*/
			}
			else go = 0;/*first time through loop;no p2*/
			
			/*create matrix which would move vehicle*/
			anim_dir2mat(mat_v,dir,dir2); 
			anim_add_trans(mat_v,p2,rcentroid); 
		}

		/*determine distance traveled*/
		VMOVE(wheel_prev,wheel_now);
		MAT4X3PNT(wheel_now,mat_v,to_track);
		if (frame > first_frame){  /* increment distance by distance moved */
			VSUB2(vdelta,wheel_now,wheel_prev);
			MAT3X3VEC(temp,mat_v,to_front);/*new front of vehicle*/
			distance += VDOT(temp,vdelta);/*portion of vdelta in line with track*/
		}

		if (go){
			if (print_mode==TRACK_ANIM) {
				printf("start %d;\nclean;\n", frame);
			} else if (print_mode==TRACK_ARCED) {
				if (frame != arced_frame) continue;
				last_frame = 1;
			}
			if (print_link) {
			        for (count=0;count<num_links;count++){
		        	        (void) get_link(position,&y_rot,distance+tracklen*count/num_links+init_dist);
					anim_y_p_r2mat(wmat,0.0,y_rot+r[count].ang,0.0);
			        	anim_add_trans(wmat,position,r[count].pos);
			        	if ((axes || cent) && links_placed){ /* link moved from vehicle coords */
				        	bn_mat_mul(mat_x,wmat,m_rev_axes);
			        		bn_mat_mul(wmat,m_axes,mat_x);
			        	}
			        	else if (axes || cent){ /* link moved to vehicle coords */
			        		MAT_MOVE(mat_x,wmat);
			        		bn_mat_mul(wmat,m_axes,mat_x);
			        	}
			        	if (print_mode==TRACK_ANIM) {
						printf("anim %s.%d matrix %s\n", *(argv+link_nindex),count,link_cmd);
			        		anim_mat_printf(stdout,wmat,"%.10g ","\n",";\n");
			        	} else if (print_mode==TRACK_ARCED) {
			        		printf("arced %s.%d matrix %s ", *(argv+link_nindex),count,link_cmd);
			        		anim_mat_printf(stdout,wmat,"%.10g ","","\n");
			        	}
				}
			}
			if (print_wheel){
				for (count = 0;count<num_wheels;count++){
					anim_y_p_r2mat(wmat,0.0,-distance/x[count].w.rad,0.0);
					VREVERSE(temp,x[count].w.pos);
					anim_add_trans(wmat,x[count].w.pos,temp);
			        	if (axes || cent){
				        	bn_mat_mul(mat_x,wmat,m_rev_axes);
			        		bn_mat_mul(wmat,m_axes,mat_x);
			        	}
			        	if (print_mode==TRACK_ANIM) {
						printf("anim %s.%d matrix %s\n",*(argv+wheel_nindex),count,wheel_cmd);
			        		anim_mat_printf(stdout,wmat,"%.10g ","\n",";\n");
			        	} else if (print_mode==TRACK_ARCED) {
						printf("arced %s.%d matrix %s ",*(argv+wheel_nindex),count,wheel_cmd);
			        		anim_mat_printf(stdout,wmat,"%.10g ","","\n");
			        	}
				}
			}
			if (print_mode==TRACK_ANIM)
				printf("end;\n");
		}
		if (last_frame) break;
	}
	return( 0 );
}


int track_prep(void)/*run once at the beginning to establish important track info*/
{
	int i;
	fastf_t phi, costheta, link_angle, arc_angle;
	vect_t difference, link_cent;

	/* first loop - get inter axle slopes and start/end angles */
	for (i=0;i<NW;i++){
		/*calculate current slope vector*/
		VSUB2(x[i].s.dir,x[i].w.pos,x[PREV(i)].w.pos);
		x[i].s.len = MAGNITUDE(x[i].s.dir);
		/*calculate end angle of previous wheel - atan2(y,x)*/
		phi = atan2(x[i].s.dir[2],x[i].s.dir[0]);/*absolute angle of slope*/
		costheta = (x[PREV(i)].w.rad - x[i].w.rad)/x[i].s.len;/*cosine of special angle*/
		x[PREV(i)].w.ang1 = phi +  acos(costheta);
		while (x[PREV(i)].w.ang1 < 0.0)
			x[PREV(i)].w.ang1 += 2.0*M_PI;
		x[i].w.ang0 = x[PREV(i)].w.ang1;
	}

	/* second loop - handle concavities */
        for (i=0;i<NW;i++){
                arc_angle = x[i].w.ang0 - x[i].w.ang1;
                while (arc_angle < 0.0)
                        arc_angle += 2.0*M_PI;
                if (arc_angle > M_PI) { /* concave */
                        x[i].w.ang0 = 0.5*(x[i].w.ang0 + x[i].w.ang1);
                        x[i].w.ang1 = x[i].w.ang0;
                        x[i].w.arc = 0.0;
                }
                else { /* convex - angles are already correct */
                        x[i].w.arc = arc_angle;
                }
        }

	/* third loop - calculate geometry of track segments */
	tracklen = 0.0;
	for (i=0;i<NW;i++){
		/*calculate endpoints of track segment*/
		x[i].t.pos1[0] = x[i].w.pos[0] + x[i].w.rad*cos(x[i].w.ang0);
		x[i].t.pos1[1] = x[i].w.pos[1];
		x[i].t.pos1[2] = x[i].w.pos[2] + x[i].w.rad*sin(x[i].w.ang0);
		x[i].t.pos0[0] = x[PREV(i)].w.pos[0] + x[PREV(i)].w.rad*cos(x[PREV(i)].w.ang1);
		x[i].t.pos0[1] = x[PREV(i)].w.pos[1];
		x[i].t.pos0[2] = x[PREV(i)].w.pos[2] + x[PREV(i)].w.rad*sin(x[PREV(i)].w.ang1);
		/*calculate length and direction*/
		VSUB2(difference,x[i].t.pos1,x[i].t.pos0);
		x[i].t.len = MAGNITUDE(difference);
		VSCALE((x[i].t.dir),difference,(1.0/x[i].t.len));

		/*calculate arclength and total track length*/
		tracklen += x[i].t.len;
		tracklen += x[i].w.arc*x[i].w.rad;
	}

	/* for a track with links already placed, get initial positions*/
	r = (struct rlink *) calloc(num_links, sizeof(struct rlink));
	if (links_placed)
		for (i=0;i<num_links;i++){
			get_link(link_cent,&link_angle,init_dist + tracklen*i/num_links);
			VREVERSE(r[i].pos,link_cent);
			r[i].ang = -link_angle;
		}
	return(0);
}

	
int get_link(fastf_t *pos, fastf_t *angle_p, fastf_t dist)
{
	int i;
	vect_t temp;
	while (dist >= tracklen) /*periodicize*/
		dist -= tracklen;
	while (dist < 0.0)
		dist += tracklen;
	for (i=0;i<NW;i++){
		if ( (dist  -= x[i].t.len) < 0 ){
			VSCALE(temp,(x[i].t.dir),dist);
			VADD2(pos,x[i].t.pos1,temp);
			*angle_p = atan2(x[i].t.dir[2],x[i].t.dir[0]);
			return(2*i);
		}
		if ((dist -= x[i].w.rad*x[i].w.arc) < 0){
			*angle_p = dist/x[i].w.rad;
			*angle_p = x[i].w.ang1 - *angle_p;/*from x-axis to link*/
			pos[0] = x[i].w.pos[0] + x[i].w.rad*cos(*angle_p);
			pos[1] = x[i].w.pos[1];
			pos[2] = x[i].w.pos[2] + x[i].w.rad*sin(*angle_p);
			*angle_p -= M_PI_2; /*angle of clockwise tangent to circle*/
			return(2*i+1);
		}
	}
	return -1;
}

#define OPT_STR "b:d:f:i:l:pr:w:sg:m:c"
int get_args(int argc, char **argv)
{
	fastf_t yaw, pch, rll;
	void anim_dx_y_z2mat(fastf_t *, double, double, double), anim_dz_y_x2mat(fastf_t *, double, double, double);
	int c, i;
	axes = cent = links_placed = print_wheel = print_link = 0;
	get_circumf = 0;
	print_mode = TRACK_ANIM;
	strcpy(link_cmd, "rarc");
	strcpy(wheel_cmd, "lmul");
        while ( (c=bu_getopt(argc,argv,OPT_STR)) != EOF) {
                i=0;
                switch(c){
                case 'b':
                	bu_optind -= 1;
                        sscanf(argv[bu_optind+(i++)],"%lf", &yaw );
                        sscanf(argv[bu_optind+(i++)],"%lf", &pch );
                        sscanf(argv[bu_optind+(i++)],"%lf", &rll );
			bu_optind += 3;
			anim_dx_y_z2mat(m_axes, rll, -pch, yaw);
			anim_dz_y_x2mat(m_rev_axes, -rll, pch, -yaw);
			axes = 1;
                        break;
                case 'd':
                        bu_optind -= 1;
                        sscanf(argv[bu_optind+(i++)],"%lf",centroid);
                        sscanf(argv[bu_optind+(i++)],"%lf",centroid+1);
                        sscanf(argv[bu_optind+(i++)],"%lf",centroid+2);
                        bu_optind += 3;
                        VREVERSE(rcentroid,centroid);
                	cent = 1;
                        break;
                case 'f':
                	sscanf(bu_optarg,"%d",&first_frame);
                        break;
                case 'i':
                	sscanf(bu_optarg,"%lf",&init_dist);
                	break;
                case 'p':
                	links_placed = 1;
                	break;
                case 'r':
                	sscanf(bu_optarg,"%lf",&radius);
                	break;
                case 'w':
                	wheel_nindex = bu_optind - 1;
                	/*sscanf(bu_optarg,"%s",wheel_name);*/
                	print_wheel = 1;
                        break;
                case 'l':
                	sscanf(bu_optarg,"%d", &num_links);
                	link_nindex = bu_optind;
                	bu_optind += 1;
                	print_link = 1;
                        break;
                case 's':
                	steer = 1;
                	break;
                case 'g':
                	sscanf(bu_optarg,"%d",&arced_frame);
                	print_mode = TRACK_ARCED;
                	break;
                case 'm':
                	switch (*bu_optarg) {
                	case 'l':
                		strncpy(link_cmd,argv[bu_optind], 10);
                		break;
                	case 'w':
                		strncpy(wheel_cmd,argv[bu_optind], 10);
                		break;
                	default:
                		fprintf(stderr,"Unknown option: -m%c\n",*bu_optarg);
                		return(0);
                	}
                	bu_optind += 1;
                	break;
                case 'c':
                	get_circumf = 1;
                	break;
                default:
                        fprintf(stderr,"Unknown option: -%c\n",c);
                        return(0);
                }
        }
        return(1);
}

void show_info(int which)/* for debugging - -1:track 0:both 1:link*/
          
{
	int i;
	if (which <=0){
		fprintf(stderr,"track length: %f\n",tracklen);
		fprintf(stderr,"link length: %f\n",tracklen/num_links);
		for (i=0;i<NW;i++){
			fprintf(stderr,"wheel %d: %f %f %f %f %f %f\n",i,x[i].w.pos[0],x[i].w.pos[1],x[i].w.pos[2],x[i].w.rad,x[i].w.ang1,x[i].w.arc);
			fprintf(stderr,"track %d: %f %f %f %f %f %f %f\n",i,x[i].t.pos1[0],x[i].t.pos1[1],x[i].t.pos1[2],x[i].t.dir[0],x[i].t.dir[1],x[i].t.dir[2],x[i].t.len);
			fprintf(stderr,"slope %d: %f %f %f %f\n",i,x[i].s.dir[0],x[i].s.dir[1],x[i].s.dir[2],x[i].s.len);
		}
	}
/*	if (which >= 0){
		fprintf(stderr,"%d %f %f %f %f\n",count,position[0],position[1],position[2],y_rot);
	}*/
}

@


11.14
log
@change conf.h to a wrapped config.h
@
text
@@


11.13
log
@merge of ansi-6-0-branch into HEAD
@
text
@d23 5
a27 1
#include "conf.h"
@


11.12
log
@update copyright to include span through 2003
@
text
@d118 1
a118 1
int get_link();
d121 1
a121 3
main(argc,argv)
int argc;
char **argv;
d123 2
a124 2
	void anim_dir2mat(), anim_y_p_r2mat(), anim_add_trans(),anim_mat_print();
	int get_args(), track_prep(), val, frame, go, i, count;
d311 1
a311 1
int track_prep()/*run once at the beginning to establish important track info*/
d378 1
a378 3
int get_link(pos,angle_p,dist) 
fastf_t *angle_p, dist;
vect_t pos;
d407 1
a407 3
int get_args(argc,argv)
int argc;
char **argv;
d410 1
a410 1
	void anim_dx_y_z2mat(), anim_dz_y_x2mat();
d494 2
a495 2
void show_info(which)/* for debugging - -1:track 0:both 1:link*/
int which;
@


11.11
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d19 1
a19 1
 *      This software is Copyright (C) 1993 by the United States Army
@


11.11.4.1
log
@sync to HEAD...
@
text
@d19 1
a19 1
 *      This software is Copyright (C) 1993-2004 by the United States Army
@


11.11.10.1
log
@merge from HEAD
@
text
@d19 1
a19 1
 *      This software is Copyright (C) 1993-2004 by the United States Army
@


11.11.2.1
log
@Initial ANSIfication
@
text
@d118 1
a118 1
int get_link(fastf_t *pos, fastf_t *angle_p, fastf_t dist);
d121 3
a123 1
main(int argc, char **argv)
d125 2
a126 2
	void anim_dir2mat(fastf_t *, const fastf_t *, const fastf_t *), anim_y_p_r2mat(fastf_t *, double, double, double), anim_add_trans(fastf_t *, const fastf_t *, const fastf_t *),anim_mat_print(FILE *, const fastf_t *, int);
	int get_args(int argc, char **argv), track_prep(void), val, frame, go, i, count;
d313 1
a313 1
int track_prep(void)/*run once at the beginning to establish important track info*/
d380 3
a382 1
int get_link(fastf_t *pos, fastf_t *angle_p, fastf_t dist)
d411 3
a413 1
int get_args(int argc, char **argv)
d416 1
a416 1
	void anim_dx_y_z2mat(fastf_t *, double, double, double), anim_dz_y_x2mat(fastf_t *, double, double, double);
d500 2
a501 2
void show_info(int which)/* for debugging - -1:track 0:both 1:link*/
          
@


11.11.2.2
log
@sync branch with HEAD
@
text
@d19 1
a19 1
 *      This software is Copyright (C) 1993-2004 by the United States Army
@


11.10
log
@Converted from K&R to ANSI C - RFH
@
text
@d118 1
a118 1
int get_link(fastf_t *pos, fastf_t *angle_p, fastf_t dist);
d121 3
a123 1
main(int argc, char **argv)
d125 2
a126 2
	void anim_dir2mat(fastf_t *, const fastf_t *, const fastf_t *), anim_y_p_r2mat(fastf_t *, double, double, double), anim_add_trans(fastf_t *, const fastf_t *, const fastf_t *),anim_mat_print(FILE *, const fastf_t *, int);
	int get_args(int argc, char **argv), track_prep(void), val, frame, go, i, count;
d313 1
a313 1
int track_prep(void)/*run once at the beginning to establish important track info*/
d380 3
a382 1
int get_link(fastf_t *pos, fastf_t *angle_p, fastf_t dist)
d411 3
a413 1
int get_args(int argc, char **argv)
d416 1
a416 1
	void anim_dx_y_z2mat(fastf_t *, double, double, double), anim_dz_y_x2mat(fastf_t *, double, double, double);
d500 2
a501 2
void show_info(int which)/* for debugging - -1:track 0:both 1:link*/
          
@


11.9
log
@lint
@
text
@d118 1
a118 1
int get_link();
d121 1
a121 3
main(argc,argv)
int argc;
char **argv;
d123 2
a124 2
	void anim_dir2mat(), anim_y_p_r2mat(), anim_add_trans(),anim_mat_print();
	int get_args(), track_prep(), val, frame, go, i, count;
d311 1
a311 1
int track_prep()/*run once at the beginning to establish important track info*/
d378 1
a378 3
int get_link(pos,angle_p,dist) 
fastf_t *angle_p, dist;
vect_t pos;
d407 1
a407 3
int get_args(argc,argv)
int argc;
char **argv;
d410 1
a410 1
	void anim_dx_y_z2mat(), anim_dz_y_x2mat();
d494 2
a495 2
void show_info(which)/* for debugging - -1:track 0:both 1:link*/
int which;
@


11.8
log
@
Eliminated dependence on compat4.h
@
text
@d24 7
d33 2
d37 2
d118 3
d126 1
a126 1
	int get_args(), get_link(), track_prep(), val, frame, go, i, count;
d166 1
a166 1
			fscanf(stream,"%*lf %*lf %*lf");
d171 1
a171 1
			fscanf(stream,"%*lf %*lf %*lf %*lf");
d309 1
@


11.7
log
@Made dependence on bu_getopt() explicit.
@
text
@d256 2
a257 2
				        	mat_mul(mat_x,wmat,m_rev_axes);
			        		mat_mul(wmat,m_axes,mat_x);
d261 1
a261 1
			        		mat_mul(wmat,m_axes,mat_x);
d278 2
a279 2
				        	mat_mul(mat_x,wmat,m_rev_axes);
			        		mat_mul(wmat,m_axes,mat_x);
@


11.6
log
@Mods for cahnge in caling sequence for anim_mat_print().
@
text
@d79 2
a80 2
extern int optind;
extern char *optarg;
d145 2
a146 2
	if (!(stream = fopen(*(argv+optind),"r"))){
		fprintf(stderr,"Anim_hardtrack: Could not open file %s.\n",*(argv+optind));
d408 1
a408 1
        while ( (c=getopt(argc,argv,OPT_STR)) != EOF) {
d412 5
a416 5
                	optind -= 1;
                        sscanf(argv[optind+(i++)],"%lf", &yaw );
                        sscanf(argv[optind+(i++)],"%lf", &pch );
                        sscanf(argv[optind+(i++)],"%lf", &rll );
			optind += 3;
d422 5
a426 5
                        optind -= 1;
                        sscanf(argv[optind+(i++)],"%lf",centroid);
                        sscanf(argv[optind+(i++)],"%lf",centroid+1);
                        sscanf(argv[optind+(i++)],"%lf",centroid+2);
                        optind += 3;
d431 1
a431 1
                	sscanf(optarg,"%d",&first_frame);
d434 1
a434 1
                	sscanf(optarg,"%lf",&init_dist);
d440 1
a440 1
                	sscanf(optarg,"%lf",&radius);
d443 2
a444 2
                	wheel_nindex = optind - 1;
                	/*sscanf(optarg,"%s",wheel_name);*/
d448 3
a450 3
                	sscanf(optarg,"%d", &num_links);
                	link_nindex = optind;
                	optind += 1;
d457 1
a457 1
                	sscanf(optarg,"%d",&arced_frame);
d461 1
a461 1
                	switch (*optarg) {
d463 1
a463 1
                		strncpy(link_cmd,argv[optind], 10);
d466 1
a466 1
                		strncpy(wheel_cmd,argv[optind], 10);
d469 1
a469 1
                		fprintf(stderr,"Unknown option: -m%c\n",*optarg);
d472 1
a472 1
                	optind += 1;
@


11.5
log
@added -g, -ml, -mw, -c, and fixed -i bug
@
text
@d265 1
a265 1
			        		anim_mat_printf(wmat,"%.10g ","\n",";\n");
d268 1
a268 1
			        		anim_mat_printf(wmat,"%.10g ","","\n");
d283 1
a283 1
			        		anim_mat_printf(wmat,"%.10g ","\n",";\n");
d286 1
a286 1
			        		anim_mat_printf(wmat,"%.10g ","","\n");
@


11.4
log
@simplified input, changed -p, -l options
@
text
@d41 4
d93 2
d103 3
d118 1
d126 1
a126 1
	num_wheels = num_links = 0;
d133 4
a136 2
	if (!get_args(argc,argv))
		fprintf(stderr,"Argument error.");
d182 5
d196 1
a196 1
	distance = init_dist;
d244 6
a249 1
			printf("start %d;\nclean;\n", frame);
d252 1
a252 1
		        	        (void) get_link(position,&y_rot,distance+tracklen*count/num_links);
d263 7
a269 2
					printf("anim %s.%d matrix lmul\n", *(argv+link_nindex),count);
			        	anim_mat_print(wmat,1);
d281 7
a287 2
					printf("anim %s.%d matrix lmul\n",*(argv+wheel_nindex),count);
					anim_mat_print(wmat,1);
d290 2
a291 1
			printf("end;\n");
d293 1
d395 1
a395 2
#define OPT_STR "b:d:f:i:l:pr:w:s"

d404 4
d455 21
@


11.3
log
@now reads wheel positions in world coordinates in the trackfile
(as opposed to vehicle coordinates)
@
text
@d85 2
a86 1
char wheel_name[40];	/* base name of wheels */
d88 1
d91 1
a91 1
int u_control;		/* flag: vehicle orientation specified by user */
d115 2
a116 1
	first_frame = num_wheels = u_control = axes = cent = links_placed=0;
d133 2
a134 2
	if (!(stream = fopen(*(argv+optind+1),"r"))){
		fprintf(stderr,"Anim_hardtrack: Could not open file %s.\n",*(argv+optind+1));
d137 14
a150 1
	fscanf(stream,"%d %d", &num_wheels, &num_links);
d174 4
d180 1
a180 1
	if(u_control)
d191 1
a191 1
		if(u_control){
d228 16
a243 14
		        for (count=0;count<num_links;count++){
	        	        (void) get_link(position,&y_rot,distance+tracklen*count/num_links);
				anim_y_p_r2mat(wmat,0.0,y_rot+r[count].ang,0.0);
		        	anim_add_trans(wmat,position,r[count].pos);
		        	if ((axes || cent) && links_placed){ /* link moved from vehicle coords */
			        	mat_mul(mat_x,wmat,m_rev_axes);
		        		mat_mul(wmat,m_axes,mat_x);
		        	}
		        	else if (axes || cent){ /* link moved to vehicle coords */
		        		MAT_MOVE(mat_x,wmat);
		        		mat_mul(wmat,m_axes,mat_x);
		        	}
				printf("anim %s.%d matrix lmul\n", *(argv+optind),count);
		        	anim_mat_print(wmat,1);
d254 1
a254 1
					printf("anim %s.%d matrix lmul\n",wheel_name,count);
d361 1
a361 1
#define OPT_STR "b:d:f:i:lr:w:u"
d370 1
a370 1
	axes = cent = links_placed = print_wheel = 0;
d399 1
a399 1
                case 'l':
d406 2
a407 1
                	sscanf(optarg,"%s",wheel_name);
d410 8
a417 2
                case 'u':
                	u_control = 1;
@


11.2
log
@updated anim.c routine names
@
text
@d134 2
a135 2
	fscanf(stream,"%d %d %lf", &num_wheels, &num_links, &track_y);
		/*allocate memory for track information*/
d139 1
a139 1
		fscanf(stream,"%lf %lf",x[i].w.pos,x[i].w.pos+2);
d144 5
a148 1
		x[i].w.pos[1] = track_y;
@


11.1
log
@Release_4.4
@
text
@d100 1
a100 1
	void dir2mat(), y_p_r2mat(), add_trans(),an_mat_print();
d124 2
a125 2
		add_trans(m_axes,centroid,zero);
		add_trans(m_rev_axes,zero,rcentroid);
d169 2
a170 2
			dy_p_r2mat(mat_v,yaw,pitch,roll);
			add_trans(mat_v,p3,rcentroid);			
d189 2
a190 2
			dir2mat(mat_v,dir,dir2); 
			add_trans(mat_v,p2,rcentroid); 
d206 2
a207 2
				y_p_r2mat(wmat,0.0,y_rot+r[count].ang,0.0);
		        	add_trans(wmat,position,r[count].pos);
d217 1
a217 1
		        	an_mat_print(wmat,1);
d221 1
a221 1
					y_p_r2mat(wmat,0.0,-distance/x[count].w.rad,0.0);
d223 1
a223 1
					add_trans(wmat,x[count].w.pos,temp);
d229 1
a229 1
					an_mat_print(wmat,1);
d342 1
a342 1
	void dx_y_z2mat(), dz_y_x2mat();
d354 2
a355 2
			dx_y_z2mat(m_axes, rll, -pch, yaw);
			dz_y_x2mat(m_rev_axes, -rll, pch, -yaw);
@


1.3
log
@fixed wrong declaration to calloc.
@
text
@@


1.2
log
@included conf.h
@
text
@a101 1
	char *calloc();
@


1.1
log
@Initial revision
@
text
@d23 1
a23 1

@
