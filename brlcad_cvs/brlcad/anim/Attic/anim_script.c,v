head	11.16;
access;
symbols
	ansi-20040405-merged:11.12.2.2
	postmerge-20040405-ansi:11.14
	premerge-20040404-ansi:11.13
	postmerge-autoconf:11.13
	autoconf-freeze:11.12.10.1
	premerge-autoconf:11.13
	ansi-20040316-freeze:11.12.2.1
	postmerge-20040315-windows:11.13
	premerge-20040315-windows:11.13
	windows-20040315-freeze:11.12.4.1
	autoconf-20031203:11.12
	autoconf-20031202:11.12
	autoconf-branch:11.12.0.10
	phong-branch:11.12.0.8
	photonmap-branch:11.12.0.6
	rel-6-1-DP:11.12
	windows-branch:11.12.0.4
	rel-6-0-2:11.10
	ansi-branch:11.12.0.2
	rel-6-0-1-branch:11.10.0.2
	hartley-6-0-post:11.11
	hartley-6-0-pre:11.10
	rel-6-0-1:11.10
	rel-6-0:11.10
	rel-5-4:11.9
	offsite-5-3-pre:11.9
	rel-5-3:11.9
	rel-5-2:11.9
	rel-5-1-branch:11.9.0.2
	rel-5-1:11.9
	rel-5-0:11.9
	rel-5-0-beta:11.8
	rel-4-5:11.8
	ctj-4-5-post:11.7
	ctj-4-5-pre:11.7
	rel-4-4:11.1;
locks; strict;
comment	@ * @;


11.16
date	2004.05.24.04.17.00;	author morrison;	state dead;
branches;
next	11.15;

11.15
date	2004.05.10.15.30.41;	author erikg;	state Exp;
branches;
next	11.14;

11.14
date	2004.04.05.07.50.19;	author morrison;	state Exp;
branches;
next	11.13;

11.13
date	2004.02.02.17.38.57;	author morrison;	state Exp;
branches;
next	11.12;

11.12
date	2002.08.20.17.07.18;	author jra;	state Exp;
branches
	11.12.2.1
	11.12.4.1
	11.12.10.1;
next	11.11;

11.11
date	2002.08.15.20.54.06;	author hartley;	state Exp;
branches;
next	11.10;

11.10
date	2001.08.21.19.16.15;	author jra;	state Exp;
branches;
next	11.9;

11.9
date	99.07.02.22.07.11;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	97.08.22.22.48.24;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	97.03.24.14.51.26;	author jra;	state Exp;
branches;
next	11.6;

11.6
date	96.08.14.00.05.38;	author cnuzman;	state Exp;
branches;
next	11.5;

11.5
date	96.08.01.21.37.48;	author cnuzman;	state Exp;
branches;
next	11.4;

11.4
date	96.07.30.21.14.27;	author cnuzman;	state Exp;
branches;
next	11.3;

11.3
date	96.06.24.17.23.44;	author cnuzman;	state Exp;
branches;
next	11.2;

11.2
date	95.07.10.23.36.17;	author cnuzman;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.34.06;	author mike;	state Rel4_4;
branches;
next	1.4;

1.4
date	94.08.25.10.22.45;	author cnuzman;	state Exp;
branches;
next	1.3;

1.3
date	94.08.24.13.55.58;	author cnuzman;	state Exp;
branches;
next	1.2;

1.2
date	94.08.24.13.10.06;	author cnuzman;	state Exp;
branches;
next	1.1;

1.1
date	94.08.04.19.47.03;	author cnuzman;	state Exp;
branches;
next	;

11.12.2.1
date	2002.09.19.18.00.31;	author morrison;	state Exp;
branches;
next	11.12.2.2;

11.12.2.2
date	2004.03.17.21.15.48;	author morrison;	state Exp;
branches;
next	;

11.12.4.1
date	2004.03.11.23.40.25;	author morrison;	state Exp;
branches;
next	;

11.12.10.1
date	2004.02.12.19.40.40;	author erikg;	state Exp;
branches;
next	;


desc
@general program tproduce a script from an animation table
@


11.16
log
@moved to src/anim/
@
text
@/*			A N I M _ S C R I P T . C
 *
 *	Turn an animation table into an animation script suitable for
 *  use by rt. Anim_script.c makes a script for one object at a time (or the
 *  virtual camera). Some of the available options include rotation
 *  only, translation only, automatic steering, and specifying reference
 *  coordinates.
 *	
 *  Author -
 *	Carl J. Nuzman
 *  
 *  Source -
 *      The U. S. Army Research Laboratory
 *      Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *      Re-distribution of this software is restricted, as described in
 *      your "Statement of Terms and Conditions for the Release of
 *      The BRL-CAD Pacakge" agreement.
 *
 *  Copyright Notice -
 *      This software is Copyright (C) 1993-2004 by the United States Army
 *      in all countries except the USA.  All rights reserved.
 */

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include <math.h>
#include <stdio.h>

#include "machine.h"
#include "vmath.h"
#include "bu.h"
#include "bn.h"
#include "anim.h"

#ifndef M_PI
#define M_PI	3.14159265358979323846
#endif

int		get_args(int argc, char **argv);
extern int	anim_steer_mat(fastf_t *, fastf_t *, int);
extern void	anim_quat2mat(fastf_t *, const fastf_t *);
extern void	anim_v_unpermute(fastf_t *);
extern void	anim_mat_print(FILE *, const fastf_t *, int);

extern int bu_optind;
extern char *bu_optarg;

 /* info from command line args */
int relative_a, relative_c, axes, translate, quaternion, rotate;/*flags*/
int steer, view, readview, permute; /* flags*/
int first_frame;
fastf_t  viewsize;
vect_t centroid, rcentroid, front;
mat_t m_axes, m_rev_axes; /* rotational analogue of centroid */
char mat_cmd[10];   /* default is lmul */

int
main(int argc, char **argv)
{
	void anim_dx_y_z2mat(fastf_t *, double, double, double), anim_add_trans(fastf_t *, const fastf_t *, const fastf_t *);
	fastf_t yaw, pitch, roll;
	vect_t point, zero;
	quat_t quat;
	mat_t a, m_x;
	int val, go, frame, last_steer;

	frame=last_steer=go=view=relative_a=relative_c=axes=0;
	VSETALL(centroid,0);
	VSETALL(rcentroid,0);
	VSETALL(front,0);
	VSETALL(point,0);
	VSETALL(zero,0);
	yaw = pitch = roll = 0.0;
	MAT_IDN(m_axes);
	MAT_IDN(m_rev_axes);
	MAT_IDN(a);	


	if (!get_args(argc,argv))
		fprintf(stderr,"anim_script: Get_args error\n");

	frame = (steer) ? first_frame -1 : first_frame;
	
	if (view && (viewsize > 0.0))
                printf("viewsize %.10g;\n", viewsize);


	while (1) {
		/* read one line of table */
		val = scanf("%*f"); /*ignore time */
                if (readview)
                        scanf("%lf",&viewsize);
		if(translate)
			val=scanf("%lf %lf %lf", point, point+1, point+2);
		if(rotate&&quaternion){
			val = scanf("%lf %lf %lf %lf", quat,quat+1,quat+2,quat+3);
			val -= 1;
		} else if (rotate) {
			val=scanf("%lf %lf %lf",&yaw,&pitch,&roll);
		}

		if (val < 3){ /* ie. scanf not completely successful */
			/* with steering option, must go extra loop after end of file */
			if (steer && !last_steer)
				last_steer = 1;
			else break;
		}

		/* calculate basic rotation matrix a */
		if (steer)
			go = anim_steer_mat(a,point,last_steer); /* warning: point changed by anim_steer_mat */
		else if (quaternion) {
			anim_quat2mat(a,quat);
			go = 1;
		} else {
			anim_dx_y_z2mat(a,roll,-pitch,yaw);/* make ypr matrix */
			go = 1;
		}

		/* if input orientation (presumably from quaternion) was
		 * designed to manipulate the view, first move the object
 		 * to the default object position */
		if (permute)
			anim_v_unpermute(a);

		/* make final matrix, including translation etc */
		if (axes){ /* add pre-rotation from original axes */
			bn_mat_mul(m_x,a,m_rev_axes); 
			MAT_MOVE(a,m_x);
		}
		anim_add_trans(a,point,rcentroid); /* add translation */
		if (axes && relative_a){ /* add post-rotation back to original axes */
			bn_mat_mul(m_x,m_axes,a);
			MAT_MOVE(a,m_x);
		}
		if (relative_c)
			anim_add_trans(a,centroid,zero); /* final translation */


		/* print one frame of script */
		if (go && view){
	                printf("start %d;\n", frame);
			printf("clean;\n");
			if (readview)
		                printf("viewsize %.10g;\n", viewsize);
	                printf("eye_pt %.10g %.10g %.10g;\n",a[3],a[7],a[11]);
			/* implicit anim_v_permute */
			printf("viewrot %.10g %.10g %.10g 0\n",-a[1],-a[5],-a[9]);
	                printf("%.10g %.10g %.10g 0\n", a[2], a[6], a[10]);
	                printf("%.10g %.10g %.10g 0\n", -a[0], -a[4],-a[8]);
	                printf("0 0 0 1;\n");
	                printf("end;\n");
		}
		else if (go){
			printf("start %d;\n", frame);
			printf("clean;\n");
			printf("anim %s matrix %s\n", *(argv+bu_optind), mat_cmd);
			anim_mat_print(stdout,a,1);
			printf("end;\n");
		}
		frame++;
	}
	return( 0 );
}

#define OPT_STR	"a:b:c:d:f:m:pqrstv:"

int get_args(int argc, char **argv)
{
	
	int c, i, yes;
	double yaw,pch,rll;
	void anim_dx_y_z2mat(fastf_t *, double, double, double), anim_dz_y_x2mat(fastf_t *, double, double, double);
	rotate = translate = 1; /* defaults */
	quaternion = permute = 0;
	strcpy(mat_cmd, "lmul");
	while ( (c=bu_getopt(argc,argv,OPT_STR)) != EOF) {
		i=0;
		switch(c){
		case 'a':
			bu_optind -= 1;
                        sscanf(argv[bu_optind+(i++)],"%lf", &yaw );
                        sscanf(argv[bu_optind+(i++)],"%lf", &pch );
                        sscanf(argv[bu_optind+(i++)],"%lf", &rll );
			bu_optind += 3;
			anim_dx_y_z2mat(m_axes, rll, -pch, yaw);
			anim_dz_y_x2mat(m_rev_axes, -rll, pch, -yaw);
			axes = 1;
			relative_a = 1;
                        break;
		case 'b':
			bu_optind -= 1;
                        sscanf(argv[bu_optind+(i++)],"%lf", &yaw );
                        sscanf(argv[bu_optind+(i++)],"%lf", &pch );
                        sscanf(argv[bu_optind+(i++)],"%lf", &rll );
			bu_optind += 3;
			anim_dx_y_z2mat(m_axes, rll, -pch, yaw);
			anim_dz_y_x2mat(m_rev_axes, -rll, pch, -yaw);
			axes = 1;
			relative_a = 0;
                        break;
		case 'c':
			bu_optind -= 1;
                        sscanf(argv[bu_optind+(i++)],"%lf",centroid);
                        sscanf(argv[bu_optind+(i++)],"%lf",centroid+1);
                        sscanf(argv[bu_optind+(i++)],"%lf",centroid+2);
			bu_optind += 3;
			VREVERSE(rcentroid,centroid);
			relative_c = 1;
                        break;
		case 'd':
			bu_optind -= 1;
                        sscanf(argv[bu_optind+(i++)],"%lf",centroid);
                        sscanf(argv[bu_optind+(i++)],"%lf",centroid+1);
                        sscanf(argv[bu_optind+(i++)],"%lf",centroid+2);
			bu_optind += 3;
			VREVERSE(rcentroid,centroid);
			relative_c = 0;
                        break;
		case 'f':
			sscanf(bu_optarg,"%d",&first_frame);
			break;
                case 'm':
               		strncpy(mat_cmd,bu_optarg, 10);
               		break;
		case 'p':
			permute = 1;
			break;
		case 'q':
			quaternion = 1;
			break;
		case 'r':
			rotate = 1;
			translate = 0;
			break;
		case 's':
			steer = 1;
			relative_a = 0;
			rotate = 0;
			translate = 1;
			break;
		case 't':
			translate = 1;
			rotate = 0;
			break;
		case 'v':
			yes = sscanf(bu_optarg,"%lf",&viewsize);
			if (!yes) viewsize = 0.0;
			if (viewsize < 0.0)
				readview = 1;
			view = 1;
			break;
		default:
			fprintf(stderr,"Unknown option: -%c\n",c);
			return(0);
		}
	}
	return(1);
}

@


11.15
log
@change conf.h to a wrapped config.h
@
text
@@


11.14
log
@merge of ansi-6-0-branch into HEAD
@
text
@d26 5
a30 1
#include "conf.h"
@


11.13
log
@update copyright to include span through 2003
@
text
@d47 5
a51 5
int		get_args();
extern int	anim_steer_mat();
extern void	anim_quat2mat();
extern void	anim_v_unpermute();
extern void	anim_mat_print();
d66 1
a66 3
main(argc,argv)
int argc;
char **argv;
d68 1
a68 1
	void anim_dx_y_z2mat(), anim_add_trans();
d176 1
a176 3
int get_args(argc,argv)
int argc;
char **argv;
d181 1
a181 1
	void anim_dx_y_z2mat(), anim_dz_y_x2mat();
@


11.12
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d22 1
a22 1
 *      This software is Copyright (C) 1993 by the United States Army
@


11.12.4.1
log
@sync to HEAD...
@
text
@d22 1
a22 1
 *      This software is Copyright (C) 1993-2004 by the United States Army
@


11.12.10.1
log
@merge from HEAD
@
text
@d22 1
a22 1
 *      This software is Copyright (C) 1993-2004 by the United States Army
@


11.12.2.1
log
@Initial ANSIfication
@
text
@d47 5
a51 5
int		get_args(int argc, char **argv);
extern int	anim_steer_mat(fastf_t *, fastf_t *, int);
extern void	anim_quat2mat(fastf_t *, const fastf_t *);
extern void	anim_v_unpermute(fastf_t *);
extern void	anim_mat_print(FILE *, const fastf_t *, int);
d66 3
a68 1
main(int argc, char **argv)
d70 1
a70 1
	void anim_dx_y_z2mat(fastf_t *, double, double, double), anim_add_trans(fastf_t *, const fastf_t *, const fastf_t *);
d178 3
a180 1
int get_args(int argc, char **argv)
d185 1
a185 1
	void anim_dx_y_z2mat(fastf_t *, double, double, double), anim_dz_y_x2mat(fastf_t *, double, double, double);
@


11.12.2.2
log
@sync branch with HEAD
@
text
@d22 1
a22 1
 *      This software is Copyright (C) 1993-2004 by the United States Army
@


11.11
log
@Converted from K&R to ANSI C - RFH
@
text
@d47 5
a51 5
int		get_args(int argc, char **argv);
extern int	anim_steer_mat(fastf_t *, fastf_t *, int);
extern void	anim_quat2mat(fastf_t *, const fastf_t *);
extern void	anim_v_unpermute(fastf_t *);
extern void	anim_mat_print(FILE *, const fastf_t *, int);
d66 3
a68 1
main(int argc, char **argv)
d70 1
a70 1
	void anim_dx_y_z2mat(fastf_t *, double, double, double), anim_add_trans(fastf_t *, const fastf_t *, const fastf_t *);
d178 3
a180 1
int get_args(int argc, char **argv)
d185 1
a185 1
	void anim_dx_y_z2mat(fastf_t *, double, double, double), anim_dz_y_x2mat(fastf_t *, double, double, double);
@


11.10
log
@lint
@
text
@d47 5
a51 5
int		get_args();
extern int	anim_steer_mat();
extern void	anim_quat2mat();
extern void	anim_v_unpermute();
extern void	anim_mat_print();
d66 1
a66 3
main(argc,argv)
int argc;
char **argv;
d68 1
a68 1
	void anim_dx_y_z2mat(), anim_add_trans();
d176 1
a176 3
int get_args(argc,argv)
int argc;
char **argv;
d181 1
a181 1
	void anim_dx_y_z2mat(), anim_dz_y_x2mat();
@


11.9
log
@
Eliminated dependence on compat4.h
@
text
@d28 6
d39 2
d47 6
d65 1
d173 1
a173 1

@


11.8
log
@Made dependence on bu_getopt() explicit.
@
text
@d123 1
a123 1
			mat_mul(m_x,a,m_rev_axes); 
d128 1
a128 1
			mat_mul(m_x,m_axes,a);
@


11.7
log
@Mods for cahnge in caling sequence for anim_mat_print().
@
text
@d39 2
a40 2
extern int optind;
extern char *optarg;
d152 1
a152 1
			printf("anim %s matrix %s\n", *(argv+optind), mat_cmd);
d174 1
a174 1
	while ( (c=getopt(argc,argv,OPT_STR)) != EOF) {
d178 5
a182 5
			optind -= 1;
                        sscanf(argv[optind+(i++)],"%lf", &yaw );
                        sscanf(argv[optind+(i++)],"%lf", &pch );
                        sscanf(argv[optind+(i++)],"%lf", &rll );
			optind += 3;
d189 5
a193 5
			optind -= 1;
                        sscanf(argv[optind+(i++)],"%lf", &yaw );
                        sscanf(argv[optind+(i++)],"%lf", &pch );
                        sscanf(argv[optind+(i++)],"%lf", &rll );
			optind += 3;
d200 5
a204 5
			optind -= 1;
                        sscanf(argv[optind+(i++)],"%lf",centroid);
                        sscanf(argv[optind+(i++)],"%lf",centroid+1);
                        sscanf(argv[optind+(i++)],"%lf",centroid+2);
			optind += 3;
d209 5
a213 5
			optind -= 1;
                        sscanf(argv[optind+(i++)],"%lf",centroid);
                        sscanf(argv[optind+(i++)],"%lf",centroid+1);
                        sscanf(argv[optind+(i++)],"%lf",centroid+2);
			optind += 3;
d218 1
a218 1
			sscanf(optarg,"%d",&first_frame);
d221 1
a221 1
               		strncpy(mat_cmd,optarg, 10);
d244 1
a244 1
			yes = sscanf(optarg,"%lf",&viewsize);
@


11.6
log
@added -m option
@
text
@d153 1
a153 1
			anim_mat_print(a,1);
@


11.5
log
@moved steer_mat into anim.c
@
text
@d49 1
d152 1
a152 1
			printf("anim %s matrix lmul\n", *(argv+optind));
d161 1
a161 1
#define OPT_STR	"a:b:c:d:f:pqrstv:"
d173 1
d220 3
@


11.4
log
@output formatting
@
text
@d42 1
a42 2
int last_steer, frame; /* used by steer_mat */
   /* info from command line args */
d59 1
a59 1
	int val, go;
d75 2
d105 1
a105 1
			go = steer_mat(a,point); /* warning: point changed by steer_mat */
d136 1
a136 1
	                printf("start %d;\n", first_frame + frame);
d149 1
a149 1
			printf("start %d;\n", first_frame + frame);
a232 1
			frame = -1;
a250 38
}

/*STEER_MAT - given the next frame's position, remember the value of
the previous frame's position and calculate a matrix which points the x-axis
in the direction defined by those two positions. Return new matrix, and the
remembered value of the current position, as arguments; return 1 as the 
normal value, and 0 when there is not yet information to remember.
*/
int steer_mat(mat,point)
mat_t  mat;
vect_t point;
{
	void anim_dir2mat(), anim_add_trans(), anim_view_rev();
	static vect_t p1, p2, p3;
	vect_t dir, dir2;
	static vect_t norm;

	VMOVE(p1,p2);
	VMOVE(p2,p3);
	VMOVE(p3,point);
	if (frame == 0){ /* first frame*/
		VSUBUNIT(dir,p3,p2);
		VSET(norm, 0.0, 1.0, 0.0);
	}
	else if (last_steer){ /*last frame*/
		VSUBUNIT(dir,p2,p1);
	}
	else if (frame > 0){ /*normal*/
		VSUBUNIT(dir,p3,p1);
	}
	else return(0); /* return signal 'don't print yet */

	anim_dirn2mat(mat,dir,norm); /* create basic rotation matrix */
	VSET(norm, mat[1], mat[5], 0.0); /* save for next time */

	VMOVE(point,p2); /* for main's purposes, the current point is p2 */

	return(1); /* return signal go 'ahead and print' */
@


11.3
log
@steering now uses anim_dirn2mat for robustness.
added quaternion input option -q and view permutation option -p
@
text
@d78 1
a78 1
                printf("viewsize %f;\n", viewsize);
d138 2
a139 2
		                printf("viewsize %f;\n", viewsize);
	                printf("eye_pt %f %f %f;\n",a[3],a[7],a[11]);
d141 3
a143 3
			printf("viewrot %f %f %f 0\n",-a[1],-a[5],-a[9]);
	                printf("%f %f %f 0\n", a[2], a[6], a[10]);
	                printf("%f %f %f 0\n", -a[0], -a[4],-a[8]);
@


11.2
log
@updated anim.c routine names
@
text
@d44 2
a45 1
int relative_a, relative_c, axes, translate, rotate, steer, view, readview; /* flags*/
d58 1
d75 1
a75 1
		fprintf(stderr,"anim_script: Get_args error");
d83 1
a83 1
		val = scanf("%*f%*[^-0123456789]"); /*ignore time and (if it exists) column of periods from tabinterp*/
d88 4
a91 1
		if(rotate)
d93 1
d105 4
a108 1
		else {
d113 6
d140 1
d159 1
a159 1
#define OPT_STR	"a:b:c:d:f:rstv:"
d166 1
a166 1
	int c, i;
d170 1
d217 6
d239 2
a240 1
			sscanf(optarg,"%lf",&viewsize);
d266 1
d273 1
a273 1
		VMOVE(dir2,dir);
a276 1
		VMOVE(dir2,dir);
a279 1
		VSUBUNIT(dir2,p2,p1);/*needed for vertical case*/
d283 3
a285 5
	anim_dir2mat(mat,dir,dir2); /* create basic rotation matrix */
/*	if (view){
		anim_view_rev(mat);
	}
*/
@


11.1
log
@Release_4.4
@
text
@d54 1
a54 1
	void dx_y_z2mat(), add_trans();
d100 1
a100 1
			dx_y_z2mat(a,roll,-pitch,yaw);/* make ypr matrix */
d109 1
a109 1
		add_trans(a,point,rcentroid); /* add translation */
d115 1
a115 1
			add_trans(a,centroid,zero); /* final translation */
d135 1
a135 1
			an_mat_print(a,1);
d152 1
a152 1
	void dx_y_z2mat(), dz_y_x2mat();
d163 2
a164 2
			dx_y_z2mat(m_axes, rll, -pch, yaw);
			dz_y_x2mat(m_rev_axes, -rll, pch, -yaw);
d174 2
a175 2
			dx_y_z2mat(m_axes, rll, -pch, yaw);
			dz_y_x2mat(m_rev_axes, -rll, pch, -yaw);
d239 1
a239 1
	void dir2mat(), add_trans(), view_rev();
d260 1
a260 1
	dir2mat(mat,dir,dir2); /* create basic rotation matrix */
d262 1
a262 1
		view_rev(mat);
@


1.4
log
@fixed clean command and included conf.h
@
text
@@


1.3
log
@changed rmul to lmul
@
text
@d26 2
d30 1
d121 1
a121 1
			printf("clean\n");
@


1.2
log
@added clean commands to output
@
text
@d131 1
a131 1
			printf("anim %s matrix rmul\n", *(argv+optind));
@


1.1
log
@Initial revision
@
text
@d118 1
d130 1
@
