head	11.14;
access;
symbols
	ansi-20040405-merged:11.10.2.2
	postmerge-20040405-ansi:11.12
	premerge-20040404-ansi:11.11
	postmerge-autoconf:11.11
	autoconf-freeze:11.10.10.1
	premerge-autoconf:11.11
	ansi-20040316-freeze:11.10.2.1
	postmerge-20040315-windows:11.11
	premerge-20040315-windows:11.11
	windows-20040315-freeze:11.10.4.1
	autoconf-20031203:11.10
	autoconf-20031202:11.10
	autoconf-branch:11.10.0.10
	phong-branch:11.10.0.8
	photonmap-branch:11.10.0.6
	rel-6-1-DP:11.10
	windows-branch:11.10.0.4
	rel-6-0-2:11.8
	ansi-branch:11.10.0.2
	rel-6-0-1-branch:11.8.0.2
	hartley-6-0-post:11.9
	hartley-6-0-pre:11.8
	rel-6-0-1:11.8
	rel-6-0:11.8
	rel-5-4:11.7
	offsite-5-3-pre:11.7
	rel-5-3:11.7
	rel-5-2:11.7
	rel-5-1-branch:11.7.0.2
	rel-5-1:11.7
	rel-5-0:11.6
	rel-5-0-beta:11.6
	rel-4-5:11.6
	ctj-4-5-post:11.4
	ctj-4-5-pre:11.4
	rel-4-4:11.1;
locks; strict;
comment	@ * @;


11.14
date	2004.05.24.04.17.00;	author morrison;	state dead;
branches;
next	11.13;

11.13
date	2004.05.10.15.30.41;	author erikg;	state Exp;
branches;
next	11.12;

11.12
date	2004.04.05.07.50.19;	author morrison;	state Exp;
branches;
next	11.11;

11.11
date	2004.02.02.17.38.57;	author morrison;	state Exp;
branches;
next	11.10;

11.10
date	2002.08.20.17.07.18;	author jra;	state Exp;
branches
	11.10.2.1
	11.10.4.1
	11.10.10.1;
next	11.9;

11.9
date	2002.08.15.20.54.05;	author hartley;	state Exp;
branches;
next	11.8;

11.8
date	2001.08.21.18.49.01;	author jra;	state Exp;
branches;
next	11.7;

11.7
date	99.12.30.19.02.07;	author jra;	state Exp;
branches;
next	11.6;

11.6
date	97.12.03.07.21.35;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	97.08.22.22.48.24;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	96.07.30.21.11.52;	author cnuzman;	state Exp;
branches;
next	11.3;

11.3
date	96.06.25.19.27.54;	author cnuzman;	state Exp;
branches;
next	11.2;

11.2
date	96.01.23.19.52.28;	author cnuzman;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.33.51;	author mike;	state Rel4_4;
branches;
next	1.4;

1.4
date	94.09.23.14.34.19;	author stay;	state Exp;
branches;
next	1.3;

1.3
date	94.08.25.11.01.25;	author cnuzman;	state Exp;
branches;
next	1.2;

1.2
date	94.08.12.17.01.59;	author cnuzman;	state Exp;
branches;
next	1.1;

1.1
date	94.08.04.21.47.12;	author cnuzman;	state Exp;
branches;
next	;

11.10.2.1
date	2002.09.19.18.00.31;	author morrison;	state Exp;
branches;
next	11.10.2.2;

11.10.2.2
date	2004.03.17.21.15.47;	author morrison;	state Exp;
branches;
next	;

11.10.4.1
date	2004.03.11.23.40.24;	author morrison;	state Exp;
branches;
next	;

11.10.10.1
date	2004.02.12.19.40.39;	author erikg;	state Exp;
branches;
next	;


desc
@filter to create animation tables for simulated flying motion
@


11.14
log
@moved to src/anim/
@
text
@/*			A N I M _ F L Y . C
 *
 *	Simulate flying motion, for an airplane or virtual camera.
 *
 *  This filter operates on animation tables. Given the desired position
 *  of the airplane in each frame, anim_fly produces a table including the
 *  plane's position and orientation. A "magic factor" should be supplied 
 *  to control the severity of banking. Looping behavior can be toggled 
 *  with another option.
 *
 * 
 *  Author -
 *	Carl J. Nuzman
 *  
 *  Source -
 *      The U. S. Army Research Laboratory
 *      Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *      Re-distribution of this software is restricted, as described in
 *      your "Statement of Terms and Conditions for the Release of
 *      The BRL-CAD Pacakge" agreement.
 *
 *  Copyright Notice -
 *      This software is Copyright (C) 1993-2004 by the United States Army
 *      in all countries except the USA.  All rights reserved.
 */

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <math.h>
#include <stdio.h>

#include "machine.h"
#include "externs.h"
#include "bu.h"
#include "vmath.h"
#include "anim.h" 

#ifndef M_PI
#define M_PI	3.14159265358979323846
#endif

#define MAXN	100

int estimate_f = 0;
fastf_t max_bank = 0;
fastf_t max_cross = 0;
int loop = 1;
int print_int = 1;
fastf_t magic_factor = 1.0;
fastf_t desired_step = 0.1;

int get_args(int argc, char **argv);

#define PREP	-1
#define START	0
#define MIDDLE	1
#define WANE	2
#define	END	3
#define STOP	4

int
main(int argc, char **argv)
{
	int count, status, num_read, enn, i, pp;
	fastf_t *points, *cur;
	fastf_t yaw, pch, rll, stepsize, first[4], second[4];
	fastf_t f_prm_0(fastf_t x0, fastf_t x1, fastf_t x2, fastf_t h), f_prm_1(fastf_t x0, fastf_t x1, fastf_t x2, fastf_t h), f_prm_2(fastf_t x0, fastf_t x1, fastf_t x2, fastf_t h);
	void get_orientation(fastf_t *p0, fastf_t *p1, fastf_t *p2, fastf_t (*function) (/* ??? */), fastf_t *p_yaw, fastf_t *p_pch, fastf_t *p_rll);	

	yaw = pch = rll = 0.0;

	if (!get_args(argc,argv))
		fprintf(stderr,"Anim_fly: Get_args error");

	/* read first two lines of table to determine the time step used */
	/* (a constant time step is assumed throughout the rest of the file)*/
	scanf("%lf %lf %lf %lf", first, first+1, first+2, first+3);
	scanf("%lf %lf %lf %lf", second, second+1, second+2, second+3);
	stepsize = second[0]-first[0];

	/* determine n, the number of points to store ahead and behind 
	 * the current point. 2n points are stored, minimum enn=2 */
	enn = (int) (desired_step/stepsize);
	if (enn>MAXN) enn=MAXN;	
	if (enn<1) enn=1;

	/* allocate storage */
	points = (fastf_t *) calloc((3*enn+1)*4, sizeof(fastf_t));

	/* read the first 3n points into the storage array*/
	VMOVEN(points+4, first, 4);
	VMOVEN(points+8, second, 4);
	num_read=4; /* in order to pass test if n=1 */
	for (cur=points+12; cur<points+(4*(3*enn+1)); cur+=4){
		num_read=scanf("%lf %lf %lf %lf", cur,cur+1,cur+2,cur+3);
	}
	if (num_read<4){
		fprintf(stderr,"Anim_fly: Not enough lines in input table.\n");
		fprintf(stderr,"Increase number of lines or reduce the minimum stepsize with -s.\n");
		fprintf(stderr,"Currently the minumum step size is %g seconds.\n",desired_step);
		exit(0);
	}

	max_cross = 0;
	count = 0;
	pp = 0;
	status = START;
	while (status != STOP) {
		switch (status) {
		case START: /* first n points */
			pp += 4;
			get_orientation(points+pp,points+pp+4*enn,points+pp+4*2*enn, f_prm_0, &yaw, &pch, &rll);
			if (!(count%print_int)&&!estimate_f) {
				printf("%.10g\t%.10g\t%.10g\t%.10g\t%.10g\t%.10g\t%.10g\n",points[pp+0],points[pp+1],points[pp+2],points[pp+3],yaw,pch,rll);
			}
			if (pp >= 4*enn)
				status=MIDDLE;
			break;
		case MIDDLE: /* middle points (at least one)*/
			for (i=0; i<3*enn*4; i++){
				VMOVEN(points+(4*i), points+(4*(i+1)), 4);
			}
			num_read=scanf("%lf %lf %lf %lf", points+(4*(3*enn)),points+(4*(3*enn)+1),points+(4*(3*enn)+2),points+(4*(3*enn)+3));
			if (num_read < 4) {
				pp = 0;
				status = WANE;
			}
			get_orientation(points,points+(4*enn),points+4*(2*enn), f_prm_1, &yaw, &pch, &rll);
			if (!(count%print_int)&&!estimate_f) {
				printf("%.10g\t%.10g\t%.10g\t%.10g\t%.10g\t%.10g\t%.10g\n",points[4*(enn)+0],points[4*(enn)+1],points[4*(enn)+2],points[4*(enn)+3],yaw,pch,rll);
			}
			break;
		case WANE: /* last n - 1 middle points */
			pp += 4;
			if (pp >= 4*enn){
				status = END;
				count--;
				pp = 0;
				break;
			}
			get_orientation(points+pp,points+pp+4*enn,points+pp+4*2*enn, f_prm_1, &yaw, &pch, &rll);
			if (!(count%print_int)&&!estimate_f) {
				printf("%.10g\t%.10g\t%.10g\t%.10g\t%.10g\t%.10g\t%.10g\n",points[4*(enn)+0+pp],points[4*(enn)+1+pp],points[4*(enn)+2+pp],points[4*(enn)+3+pp],yaw,pch,rll);
			}
			break;
		case END: /* last n points */
			get_orientation(points+pp,points+pp+4*enn,points+pp+4*2*enn, f_prm_2, &yaw, &pch, &rll);
			if (!(count%print_int)&&!estimate_f) {
				printf("%.10g\t%.10g\t%.10g\t%.10g\t%.10g\t%.10g\t%.10g\n",points[8*enn+pp+0],points[8*enn+pp+1],points[8*enn+pp+2],points[8*enn+pp+3],yaw,pch,rll);
			}
			pp += 4;
			if (pp >= 4*enn)
				status = STOP;
			break;
		}
		count++;


	}

	/* Return the factor needed to achieve the requested max_bank */
	if (estimate_f){
		if (max_cross < VDIVIDE_TOL) {
			printf("%.10g\n",0.0);
		} else {
			printf("%.10g\n", 1000.0 * max_bank/max_cross);
		}
	}
	return( 0 );
}

void
get_orientation(fastf_t *p0, fastf_t *p1, fastf_t *p2, fastf_t (*function) (/* ??? */), fastf_t *p_yaw, fastf_t *p_pch, fastf_t *p_rll)
{
	int i;
	fastf_t step,vel[3],accel[3];
	fastf_t f_double_prm(fastf_t x0, fastf_t x1, fastf_t x2, fastf_t h),xyz2yaw(fastf_t *d),xyz2pch(fastf_t *d),bank(fastf_t *acc, fastf_t *vel);

	static fastf_t last_yaw;
	static int not_first_time, upside_down;

	step = p2[0] - p1[0];
	for (i=1;i<4;i++) {
		vel[i-1] = (*function)(p0[i],p1[i],p2[i],step);
		accel[i-1] = f_double_prm(p0[i],p1[i],p2[i],step);
	}
	*p_yaw = xyz2yaw(vel);
	*p_pch = xyz2pch(vel);
	*p_rll = bank(accel,vel);

	if (fabs(*p_pch)==90.0) /* don't change yaw if velocity vertical */
		*p_yaw = last_yaw;

	/* avoid sudden yaw changes in vertical loops */
	if (not_first_time&&loop){
		if ((fabs(last_yaw - *p_yaw)<181.0)&&(fabs(last_yaw - *p_yaw)>179.0))
			upside_down = (upside_down) ? 0 : 1;
		if (upside_down)
			(*p_rll) += 180;
	}
	
	last_yaw = *p_yaw;
	not_first_time = 1;
}

/* determine the yaw of the given direction vector */
fastf_t	xyz2yaw(fastf_t *d)
{
	fastf_t yaw;
	yaw = RTOD*atan2(d[1],d[0]);
	if (yaw < 0.0) yaw += 360.0;
	return yaw;
}

/* determine the pitch of the given direction vector */
fastf_t	xyz2pch(fastf_t *d)
{
	fastf_t x;
	x = sqrt(d[0]*d[0] + d[1]*d[1]);
	return (RTOD*atan2(d[2],x));

}

/* given the 3-d velocity and acceleration of an imaginary aircraft,
    find the amount of bank the aircraft would need to undergo.
	Algorithm: the bank angle is proportional to the cross product
	of the horizontal velocity and horizontal acceleration, up to a 
	maximum bank of 90 degrees in either direction. */
fastf_t bank(fastf_t *acc, fastf_t *vel)
{
	fastf_t cross;

	cross = vel[1]*acc[0] - vel[0]*acc[1];

	if (estimate_f) {
		max_cross = ( fabs(cross) > max_cross) ? fabs(cross) : max_cross;
	}

	cross *= magic_factor;

	if (cross > 90) cross = 90;
	if (cross < -90) cross = -90;
	return cross;
}

/* given f(t), f(t+h), f(t+2h), and h, calculate f'(t) */
fastf_t f_prm_0(fastf_t x0, fastf_t x1, fastf_t x2, fastf_t h)
{
	return  -(3.0*x0 - 4.0*x1 + x2)/(2*h);
}

/* given f(t), f(t+h), f(t+2h), and h, calculate f'(t+h) */
fastf_t f_prm_1(fastf_t x0, fastf_t x1, fastf_t x2, fastf_t h)
{
	return (x2 - x0)/(2*h);
}

/* given f(t), f(t+h), f(t+2h), and h, calculate f'(t+2h) */
fastf_t f_prm_2(fastf_t x0, fastf_t x1, fastf_t x2, fastf_t h)
{
	return (x0 - 4.0*x1 + 3.0*x2)/(2*h);
}


/* given f(t), f(t+h), f(t+2*h),  and h, calculate f'' */
fastf_t f_double_prm(fastf_t x0, fastf_t x1, fastf_t x2, fastf_t h)
{
	return (x0 - 2.0*x1 + x2)/(h*h);
}


/* code to read command line arguments*/
#define OPT_STR "b:f:p:s:r"
int get_args(int argc, char **argv)
{
	int c;

	estimate_f = 0;
	while ( (c=bu_getopt(argc,argv,OPT_STR)) != EOF) {
		switch(c){
		case 'b':
			sscanf(bu_optarg,"%lf",&max_bank);
			estimate_f = 1;
			break;
		case 'f':
			sscanf(bu_optarg,"%lf",&magic_factor);
			magic_factor *= 0.001; /* to put factors in a more reasonable range */
			break;
		case 'p':
			sscanf(bu_optarg,"%d",&print_int);
			break;
		case 'r':
			loop = 0;
			break;
		case 's':
			sscanf(bu_optarg, "%lf", &desired_step);
			break;
		default:
			fprintf(stderr,"Unknown option: -%c\n",c);
			return(0);
		}
	}
	return(1);
}

@


11.13
log
@change conf.h to a wrapped config.h
@
text
@@


11.12
log
@merge of ansi-6-0-branch into HEAD
@
text
@d29 5
a33 1
#include "conf.h"
@


11.11
log
@update copyright to include span through 2003
@
text
@d54 1
a54 1
int get_args();
d64 1
a64 3
main(argc,argv)
int argc;
char **argv;
d69 2
a70 2
	fastf_t f_prm_0(), f_prm_1(), f_prm_2();
	void get_orientation();	
d175 1
a175 3
get_orientation(p0,p1,p2,function, p_yaw, p_pch, p_rll)
fastf_t p0[4],p1[4],p2[4], *p_yaw, *p_pch, *p_rll;
fastf_t (*function)();
d179 1
a179 1
	fastf_t f_double_prm(),xyz2yaw(),xyz2pch(),bank();
d209 1
a209 2
fastf_t	xyz2yaw(d)
fastf_t	d[3];
d218 1
a218 2
fastf_t	xyz2pch(d)
fastf_t	d[3];
d231 1
a231 2
fastf_t bank(acc,vel)
fastf_t acc[3],vel[3];
d249 1
a249 2
fastf_t f_prm_0(x0,x1,x2,h)
fastf_t x0,x1,x2,h;
d255 1
a255 2
fastf_t f_prm_1(x0,x1,x2,h)
fastf_t x0,x1,x2,h;
d261 1
a261 2
fastf_t f_prm_2(x0,x1,x2,h)
fastf_t x0,x1,x2,h;
d268 1
a268 2
fastf_t f_double_prm(x0,x1,x2,h)
fastf_t x0,x1,x2,h;
d276 1
a276 3
int get_args(argc,argv)
int argc;
char **argv;
@


11.10
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d25 1
a25 1
 *      This software is Copyright (C) 1993 by the United States Army
@


11.10.4.1
log
@sync to HEAD...
@
text
@d25 1
a25 1
 *      This software is Copyright (C) 1993-2004 by the United States Army
@


11.10.10.1
log
@merge from HEAD
@
text
@d25 1
a25 1
 *      This software is Copyright (C) 1993-2004 by the United States Army
@


11.10.2.1
log
@Initial ANSIfication
@
text
@d54 1
a54 1
int get_args(int argc, char **argv);
d64 3
a66 1
main(int argc, char **argv)
d71 2
a72 2
	fastf_t f_prm_0(fastf_t x0, fastf_t x1, fastf_t x2, fastf_t h), f_prm_1(fastf_t x0, fastf_t x1, fastf_t x2, fastf_t h), f_prm_2(fastf_t x0, fastf_t x1, fastf_t x2, fastf_t h);
	void get_orientation(fastf_t *p0, fastf_t *p1, fastf_t *p2, fastf_t (*function) (/* ??? */), fastf_t *p_yaw, fastf_t *p_pch, fastf_t *p_rll);	
d177 3
a179 1
get_orientation(fastf_t *p0, fastf_t *p1, fastf_t *p2, fastf_t (*function) (/* ??? */), fastf_t *p_yaw, fastf_t *p_pch, fastf_t *p_rll)
d183 1
a183 1
	fastf_t f_double_prm(fastf_t x0, fastf_t x1, fastf_t x2, fastf_t h),xyz2yaw(fastf_t *d),xyz2pch(fastf_t *d),bank(fastf_t *acc, fastf_t *vel);
d213 2
a214 1
fastf_t	xyz2yaw(fastf_t *d)
d223 2
a224 1
fastf_t	xyz2pch(fastf_t *d)
d237 2
a238 1
fastf_t bank(fastf_t *acc, fastf_t *vel)
d256 2
a257 1
fastf_t f_prm_0(fastf_t x0, fastf_t x1, fastf_t x2, fastf_t h)
d263 2
a264 1
fastf_t f_prm_1(fastf_t x0, fastf_t x1, fastf_t x2, fastf_t h)
d270 2
a271 1
fastf_t f_prm_2(fastf_t x0, fastf_t x1, fastf_t x2, fastf_t h)
d278 2
a279 1
fastf_t f_double_prm(fastf_t x0, fastf_t x1, fastf_t x2, fastf_t h)
d287 3
a289 1
int get_args(int argc, char **argv)
@


11.10.2.2
log
@sync branch with HEAD
@
text
@d25 1
a25 1
 *      This software is Copyright (C) 1993-2004 by the United States Army
@


11.9
log
@Converted from K&R to ANSI C - RFH
@
text
@d54 1
a54 1
int get_args(int argc, char **argv);
d64 3
a66 1
main(int argc, char **argv)
d71 2
a72 2
	fastf_t f_prm_0(fastf_t x0, fastf_t x1, fastf_t x2, fastf_t h), f_prm_1(fastf_t x0, fastf_t x1, fastf_t x2, fastf_t h), f_prm_2(fastf_t x0, fastf_t x1, fastf_t x2, fastf_t h);
	void get_orientation(fastf_t *p0, fastf_t *p1, fastf_t *p2, fastf_t (*function) (/* ??? */), fastf_t *p_yaw, fastf_t *p_pch, fastf_t *p_rll);	
d177 3
a179 1
get_orientation(fastf_t *p0, fastf_t *p1, fastf_t *p2, fastf_t (*function) (/* ??? */), fastf_t *p_yaw, fastf_t *p_pch, fastf_t *p_rll)
d183 1
a183 1
	fastf_t f_double_prm(fastf_t x0, fastf_t x1, fastf_t x2, fastf_t h),xyz2yaw(fastf_t *d),xyz2pch(fastf_t *d),bank(fastf_t *acc, fastf_t *vel);
d213 2
a214 1
fastf_t	xyz2yaw(fastf_t *d)
d223 2
a224 1
fastf_t	xyz2pch(fastf_t *d)
d237 2
a238 1
fastf_t bank(fastf_t *acc, fastf_t *vel)
d256 2
a257 1
fastf_t f_prm_0(fastf_t x0, fastf_t x1, fastf_t x2, fastf_t h)
d263 2
a264 1
fastf_t f_prm_1(fastf_t x0, fastf_t x1, fastf_t x2, fastf_t h)
d270 2
a271 1
fastf_t f_prm_2(fastf_t x0, fastf_t x1, fastf_t x2, fastf_t h)
d278 2
a279 1
fastf_t f_double_prm(fastf_t x0, fastf_t x1, fastf_t x2, fastf_t h)
d287 3
a289 1
int get_args(int argc, char **argv)
@


11.8
log
@lint
@
text
@d54 1
a54 1
int get_args();
d64 1
a64 3
main(argc,argv)
int argc;
char **argv;
d69 2
a70 2
	fastf_t f_prm_0(), f_prm_1(), f_prm_2();
	void get_orientation();	
d175 1
a175 3
get_orientation(p0,p1,p2,function, p_yaw, p_pch, p_rll)
fastf_t p0[4],p1[4],p2[4], *p_yaw, *p_pch, *p_rll;
fastf_t (*function)();
d179 1
a179 1
	fastf_t f_double_prm(),xyz2yaw(),xyz2pch(),bank();
d209 1
a209 2
fastf_t	xyz2yaw(d)
fastf_t	d[3];
d218 1
a218 2
fastf_t	xyz2pch(d)
fastf_t	d[3];
d231 1
a231 2
fastf_t bank(acc,vel)
fastf_t acc[3],vel[3];
d249 1
a249 2
fastf_t f_prm_0(x0,x1,x2,h)
fastf_t x0,x1,x2,h;
d255 1
a255 2
fastf_t f_prm_1(x0,x1,x2,h)
fastf_t x0,x1,x2,h;
d261 1
a261 2
fastf_t f_prm_2(x0,x1,x2,h)
fastf_t x0,x1,x2,h;
d268 1
a268 2
fastf_t f_double_prm(x0,x1,x2,h)
fastf_t x0,x1,x2,h;
d276 1
a276 3
int get_args(argc,argv)
int argc;
char **argv;
@


11.7
log
@Eliminated some unused variables
@
text
@d54 2
d63 1
d173 1
@


11.6
log
@Included proper header files.
@
text
@d65 1
a65 1
	int count, endcount, status, num_read, enn, i, pp;
d181 1
a181 1
	static fastf_t last_yaw, last_pch, last_rll;
a204 2
	last_pch = *p_pch;
	last_rll = *p_rll;
@


11.5
log
@Made dependence on bu_getopt() explicit.
@
text
@d30 1
d33 1
d35 2
a44 3

extern int bu_optind;
extern char *bu_optarg;
@


11.4
log
@?
@
text
@d42 2
a43 2
extern int optind;
extern char *optarg;
d291 1
a291 1
	while ( (c=getopt(argc,argv,OPT_STR)) != EOF) {
d294 1
a294 1
			sscanf(optarg,"%lf",&max_bank);
d298 1
a298 1
			sscanf(optarg,"%lf",&magic_factor);
d302 1
a302 1
			sscanf(optarg,"%d",&print_int);
d308 1
a308 1
			sscanf(optarg, "%lf", &desired_step);
@


11.3
log
@fixed bug which caused certain points to get skipped
@
text
@d68 1
d171 1
a171 1

@


11.2
log
@added -b option, which estimates and returns the necessary factor
to keep the bank angle below a specified limit
@
text
@d56 3
a58 2
#define	END	2
#define STOP	3
d64 1
a64 1
	int count, endcount, status, num_read, enn, i;
a82 1
	enn++;
d84 1
a84 1
	if (enn<2) enn=2;
d87 1
a87 1
	points = (fastf_t *) calloc(2*enn*4, sizeof(fastf_t));
d89 3
a91 3
	/* read the first 2n-1 points into the storage array*/
	VMOVEN(points, first, 4);
	VMOVEN(points+4, second, 4);
d93 1
a93 1
	for (cur=points+8; cur<points+(4*2*enn); cur+=4){
d97 3
a99 2
		fprintf(stderr,"Anim_fly: Not enough lines in input table./n");
		fprintf(stderr,"/tIncrease number of lines or reduce the desired stepsize with -s.\n");
d105 1
d108 12
a119 4

		/* read in one more point and shift all points down */
		if ((status != START)&&(status != END)) {
			for (i=0; i<2*enn-1; i++){
d122 1
a122 1
			num_read=scanf("%lf %lf %lf %lf", points+(4*(2*enn-1)),points+(4*(2*enn-1)+1),points+(4*(2*enn-1)+2),points+(4*(2*enn-1)+3));
d124 2
a125 2
				endcount = enn;
				status = END;
d127 1
a127 5
		}

		/* The first n points  - yaw pitch and roll will be constant*/
		if (status==START) { 
			get_orientation(points,points+(4*(enn-1)),points+(4*(2*enn-2)), f_prm_0, &yaw, &pch, &rll);
d129 10
a138 1
				printf("%f %f %f %f %f %f %f\n",points[4*count+0],points[4*count+1],points[4*count+2],points[4*count+3],yaw,pch,rll);
d140 1
a140 6
			if (count>=enn-1)
				status=MIDDLE;
		}
		/* all interior points */
		else if (status==MIDDLE) {/*do calculations for all middle points*/
			get_orientation(points,points+(4*(enn-1)),points+(4*(2*enn-2)), f_prm_1, &yaw, &pch, &rll);
d142 1
a142 1
				printf("%f %f %f %f %f %f %f\n",points[4*(enn-1)+0],points[4*(enn-1)+1],points[4*(enn-1)+2],points[4*(enn-1)+3],yaw,pch,rll);
d144 3
a146 4
		}
		/* last n-1 points - yaw pitch and roll will be constant */
		else if (status==END) { /*do calculations for the last point*/
			get_orientation(points,points+(4*(enn-1)),points+(4*(2*enn-2)), f_prm_2, &yaw, &pch, &rll);
d148 1
a148 1
				printf("%f %f %f %f %f %f %f\n",points[4*endcount+0],points[4*endcount+1],points[4*endcount+2],points[4*endcount+3],yaw,pch,rll);
d150 2
a151 1
			if (endcount>=2*enn-2)
d153 1
a153 1
			endcount++;
d163 1
a163 1
			printf("%f\n",0.0);
d165 1
a165 1
			printf("%f\n", 1000.0 * max_bank/max_cross);
@


11.1
log
@Release_4.4
@
text
@d45 3
d102 1
d122 1
a122 1
			if (!(count%print_int)) {
d131 1
a131 1
			if (!(count%print_int)) {
d138 1
a138 1
			if (!(count%print_int)) {
d149 9
d229 5
d235 1
d272 1
a272 1
#define OPT_STR "f:p:s:r"
d278 2
d282 4
@


1.4
log
@changed return to an exit(0), in main
@
text
@@


1.3
log
@inlcuded conf.h
@
text
@d96 1
a96 1
		return;
@


1.2
log
@added adaptive step size, to avoid numerical instability when input data
is given at a high number of frames per second.
@
text
@d29 1
@


1.1
log
@Initial revision
@
text
@d11 1
d39 2
d47 1
d59 3
a61 2
	int count, status, num_read;
	fastf_t point0[4],point1[4],point2[4],point3[4], yaw, pch, rll;
a63 4
	VSETALL(point0,0.0);
	VSETALL(point1,0.0);
	VSETALL(point2,0.0);
	VSETALL(point3,0.0);
d69 31
a99 3
	count = -2;
	status = PREP;
	num_read = 4;
a100 2
		/* check for end of file status */
		if (num_read < 4) status = END;
d102 10
a111 10
		/*wait twice to prime the pump before starting calculations*/
		if (!(count++)) status = START;

		/* read one line of the table into point3, storing
			previous values in point0, point1,  and point2. */
		if (status != END) {
			VMOVEN(point0,point1,4);
			VMOVEN(point1,point2,4);
			VMOVEN(point2,point3,4);
			num_read = scanf("%lf %lf %lf %lf", point3, point3+1, point3+2, point3+3);
d114 3
a116 2
		if (status==START) { /* do calculations for the first point*/
			get_orientation(point1,point2,point3, f_prm_0, &yaw, &pch, &rll);
d118 1
a118 1
				printf("%f %f %f %f %f %f %f\n",point1[0],point1[1],point1[2],point1[3],yaw,pch,rll);
d120 2
a121 1
			status = MIDDLE;
d123 1
d125 1
a125 1
			get_orientation(point0,point1,point2, f_prm_1, &yaw, &pch, &rll);
d127 1
a127 1
				printf("%f %f %f %f %f %f %f\n",point1[0],point1[1],point1[2],point1[3],yaw,pch,rll);
d130 1
d132 1
a132 1
			get_orientation(point0,point1,point2, f_prm_2, &yaw, &pch, &rll);
d134 1
a134 1
				printf("%f %f %f %f %f %f %f\n",point2[0],point2[1],point2[2],point2[3],yaw,pch,rll);
d136 3
a138 1
			status = STOP;
d140 3
d252 1
a252 1
#define OPT_STR "f:p:r"
d269 3
@
