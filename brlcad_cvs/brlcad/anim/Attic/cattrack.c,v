head	11.8;
access;
symbols
	ansi-20040405-merged:11.5.2.1
	postmerge-20040405-ansi:11.6
	premerge-20040404-ansi:11.5
	postmerge-autoconf:11.5
	autoconf-freeze:11.5
	premerge-autoconf:11.5
	ansi-20040316-freeze:11.5.2.1
	postmerge-20040315-windows:11.5
	premerge-20040315-windows:11.5
	windows-20040315-freeze:11.5
	autoconf-20031203:11.5
	autoconf-20031202:11.5
	autoconf-branch:11.5.0.10
	phong-branch:11.5.0.8
	photonmap-branch:11.5.0.6
	rel-6-1-DP:11.5
	windows-branch:11.5.0.4
	rel-6-0-2:11.3
	ansi-branch:11.5.0.2
	rel-6-0-1-branch:11.3.0.4
	hartley-6-0-post:11.4
	hartley-6-0-pre:11.3
	rel-6-0-1:11.3
	rel-6-0:11.3
	rel-5-4:11.3
	offsite-5-3-pre:11.3
	rel-5-3:11.3
	rel-5-2:11.3
	rel-5-1-branch:11.3.0.2
	rel-5-1:11.3
	rel-5-0:11.2
	rel-5-0-beta:11.2
	rel-4-5:11.2
	ctj-4-5-post:11.2
	ctj-4-5-pre:11.2
	rel-4-4:11.1;
locks; strict;
comment	@ * @;


11.8
date	2004.05.24.04.17.00;	author morrison;	state dead;
branches;
next	11.7;

11.7
date	2004.05.10.15.30.41;	author erikg;	state Exp;
branches;
next	11.6;

11.6
date	2004.04.05.07.50.19;	author morrison;	state Exp;
branches;
next	11.5;

11.5
date	2002.08.20.17.07.18;	author jra;	state Exp;
branches
	11.5.2.1;
next	11.4;

11.4
date	2002.08.15.20.54.06;	author hartley;	state Exp;
branches;
next	11.3;

11.3
date	99.12.30.19.08.37;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	96.07.15.13.36.48;	author cnuzman;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.34.13;	author mike;	state Rel4_4;
branches;
next	1.4;

1.4
date	94.08.25.11.07.25;	author cnuzman;	state Exp;
branches;
next	1.3;

1.3
date	94.08.05.18.07.06;	author cnuzman;	state Exp;
branches;
next	1.2;

1.2
date	94.07.11.14.27.05;	author cnuzman;	state Exp;
branches;
next	1.1;

1.1
date	94.06.30.11.46.32;	author cnuzman;	state Exp;
branches;
next	;

11.5.2.1
date	2002.09.19.18.00.32;	author morrison;	state Exp;
branches;
next	;


desc
@caternary curve routines used by ntrack.c
@


11.8
log
@moved to src/anim/
@
text
@/*			C A T T R A C K . C
 *
 *  Caternary curve routines used by anim_track.c
 *
 */

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif


#include <math.h>
#include <stdio.h>
#include "machine.h"
#include "vmath.h"
#include "anim.h"

#define MAX_REACHED	0
#define SOLVED		1

/* the total maximum number of lowest level iterations possible is
 *     T_MAX_ITS*MAX_OUT_ITS*2*MAX_ITS
 */
#define MAX_ITS		25
#define MAX_OUT_ITS	25
#define T_MAX_ITS	50

/* these tolerances are guessed at, except that it seems to be important
 * in elastic situations that T_TOL be significantly smaller than the others
 */
#define T_TOL		1.0e-14
#define G_TOL		1.0e-12
#define F_TOL		1.0e-12

/* HYPER_GET_X - get x value of a point which is a given distance along 
 * caternary curve. 
 * x(s) = arcsinh(a*s-sinh(a*c))/a + c
 * Left to calling routine to avoid dividing by zero.
 */
fastf_t hyper_get_x(fastf_t a, fastf_t c, fastf_t s, int d, int x, int cos_ang)
              	/* curve parameters */
          		/* arclength value  */
{
	fastf_t arg, asinh_arg;

	arg = a*s - sinh(a*c);
	asinh_arg = log(arg + sqrt(arg*arg + 1.0));

	return(asinh_arg/a + c);
}

/* HYPER_GET_S - calculate the arclength parameter of a caternary
 * curve corresponding to the given value of x.
 * s(x) = (sinh(a(x-c))+sinh(ac))/a 
 * Left to calling routime to avoid dividing by zero.
 */
fastf_t hyper_get_s(fastf_t a, fastf_t c, fastf_t x)
{
		return((sinh(a*(x-c))+sinh(a*c))/a);
}

/* HYPER_GET_Z - calculate point on the caternary curve:
 * z(x) = cosh(a*(x-c))/a + b
 * Left to calling routine to avoid dividing by zero.
 */
fastf_t hyper_get_z(fastf_t a, fastf_t b, fastf_t c, fastf_t x)
{
	fastf_t z;

	if (fabs(a)>VDIVIDE_TOL){
		z = cosh(a*(x-c))/a + b;
	} else {
		z = b;
	}
	return(z);
}

/* HYPER_GET_ANG - calculate angle corresponding to the slope of 
 * caternary curve.
 * z'(x) = sinh(a*(x-c))
 */
fastf_t hyper_get_ang(fastf_t a, fastf_t c, fastf_t x)
{
	fastf_t slope;

	slope = sinh(a*(x-c));
	return( atan2(slope, 1.0));
}

/* GET_CURVE - Find the constants a, b, and c such that the curve
 *  z = cosh(a*(x-c))/a + b
 * is tangent to circles of radii r0 and r1 located at
 * (x0,z0) and (x1,z1) and such that the curve has 
 * arclength delta_s between circles. Also find the angle where
 * the curve touches each circle. When called successively,
 * It uses the values of a,b, and c from the last call as a start.
 */
int getcurve(fastf_t *pa, fastf_t *pb, fastf_t *pc, fastf_t *pth0, fastf_t *pth1, fastf_t delta_s, fastf_t *p_zero, fastf_t *p_one, fastf_t r_zero, fastf_t r_one)
       	              	/* curve parameters */
                     	/* angle where curve contacts circle0,circle1 */
                	/* desired arclength */
                        /* radii of circle0 and circle1 */
                     	/* center of circle0 and circle1 */
{

	int status, i, solved;
	int ingetcurve(fastf_t *pa, fastf_t *pb, fastf_t *pc, fastf_t delta_s, fastf_t *p_zero, fastf_t *p_one);
	fastf_t theta_one, theta_zero, new_theta_zero, new_theta_one;
	fastf_t avg_theta_zero, avg_theta_one, arc_dist;
	fastf_t tang_ang, costheta;
	double stmp;
	vect_t q_zero, q_one, diff; 
	static fastf_t last_a, last_c, last_theta_one, last_theta_zero;
	static int called_before = 0;

	/*first calculate angle at which tangent line would contact circles*/
	VSUB2(diff,p_one,p_zero);
	tang_ang = atan2(diff[Z],diff[X]);
	costheta = (r_zero-r_one)/MAGNITUDE(diff);
	tang_ang += acos(costheta);

	if (!called_before){
		theta_one = tang_ang;
		theta_zero = tang_ang;
		(*pa) = 1.0;
		*pc = 0.5*(p_one[X]+p_zero[X]);
		called_before = 1;
	}
	else {
		theta_zero = last_theta_zero;
		theta_one = last_theta_one;
		*pa = last_a;
		*pc = last_c;
	}

	status = MAX_REACHED;
	for (i=0;i<T_MAX_ITS;i++){
		q_zero[X] = p_zero[X] + r_zero * cos(theta_zero);
		q_zero[Z] = p_zero[Z] + r_zero * sin(theta_zero);
		q_one[X] = p_one[X] + r_one * cos(theta_one);
		q_one[Z] = p_one[Z] + r_one * sin(theta_one);

		/* determine distance taken by arc*/
		arc_dist = r_zero * (tang_ang - theta_zero);
		arc_dist += r_one * (theta_one - tang_ang);

		ingetcurve(pa,pb,pc, delta_s-arc_dist, q_zero, q_one);

		solved = 0;
		/* refine theta_one */
		stmp = sinh( (*pa)*(q_zero[X]-(*pc)) );
		new_theta_zero = atan2(1.0,-stmp);
		avg_theta_zero = 0.5 * (theta_zero + new_theta_zero);
		if (fabs(theta_zero-avg_theta_zero)<T_TOL){
			solved++;
		}
		theta_zero = avg_theta_zero;

		/* refine theta_two */
		stmp = sinh( (*pa)*(q_one[X]-(*pc)) );
		new_theta_one = atan2(1.0,-stmp);
		avg_theta_one = 0.5 * (theta_one + new_theta_one);
		if (fabs(theta_one-avg_theta_one)<T_TOL){
			solved++;
		}
		theta_one = avg_theta_one;

		if (solved == 2){
			status = SOLVED;
			break;
		}
		
	}
	last_theta_zero = theta_zero;
	last_theta_one = theta_one;
	last_a = *pa;
	last_c = *pc;
	*pth0 = theta_zero;
	*pth1 = theta_one;
	return(status);
			
}

/* INGETCURVE - find constants a, b, and c, such that the curve
 *  z = cosh(a*(x-c))/a + b
 * passes through (x0,z0) and (x1,z1) and has arclength delta_s
 * Appropriate first guesses for a,b, and c should be given.
 */
int ingetcurve(fastf_t *pa, fastf_t *pb, fastf_t *pc, fastf_t delta_s, fastf_t *p_zero, fastf_t *p_one)
{
	int status, i, j, k;
	fastf_t adjust;
	fastf_t eff(fastf_t a, fastf_t c, fastf_t x0, fastf_t x1, fastf_t delta_s),gee(fastf_t a, fastf_t c, fastf_t x0, fastf_t x1, fastf_t delta_z);

	status = MAX_REACHED;
	i=0;
	while (i++<MAX_OUT_ITS){
		for (j=0;j<MAX_ITS;j++){
			adjust = eff(*pa,*pc,p_zero[X],p_one[X],delta_s);
			if ((*pa-adjust)<=0.0){
				*pa *= 0.5;
			}
			else {
				*pa -= adjust;
			}
			if (adjust<F_TOL){
				break;
			}
		}
		
		for (k=0;k<MAX_ITS;k++){
			adjust = gee(*pa,*pc,p_zero[X],p_one[X],(p_one[Z]-p_zero[Z]));
			*pc -= adjust;
			if (adjust<G_TOL){
				break;
			}
		}

		if ((j==0)&&(k==0)){
			status = SOLVED;
			break;
		}
	}
	*pb = p_zero[Z] - cosh( (*pa)*(p_zero[X]-(*pc)) )/(*pa);
	
	return(status);

}

/* find Newtonian adjustment for 'a', assuming 'c' fixed*/
fastf_t eff(fastf_t a, fastf_t c, fastf_t x0, fastf_t x1, fastf_t delta_s)
{
	double f,fprime;
	double arg0, arg1, sarg0, sarg1;

	arg0 = a*(x0-c);
	arg1 = a*(x1-c);

	sarg0 = sinh(arg0);
	sarg1 = sinh(arg1);

	f = a*(sarg1-sarg0 - a*delta_s);
	fprime = sarg0 - sarg1 - arg0*cosh(arg0) + arg1*cosh(arg1);

	if (fabs(fprime) > VDIVIDE_TOL)
		return(f/fprime);
	else if ((a*a) > VDIVIDE_TOL)
		return(f/(a*a));
	else if (fabs(a) > VDIVIDE_TOL)
		return(f/a);
	else
		return(f);
}

/* find Newtonian adjustment for c, assuming 'a' fixed*/
fastf_t gee(fastf_t a, fastf_t c, fastf_t x0, fastf_t x1, fastf_t delta_z)
{
	double g, gprime, arg0, arg1;

	arg0 = a*(x0-c);
	arg1 = a*(x1-c);

	g = cosh(arg1)-cosh(arg0) - a*delta_z;
	gprime = a*(sinh(arg0) - sinh(arg1));

	if (fabs(gprime) > VDIVIDE_TOL)
		return(g/gprime);
	else if (fabs(a) > VDIVIDE_TOL)
		return(g/a);
	else
		return(g);
}

@


11.7
log
@change conf.h to a wrapped config.h
@
text
@@


11.6
log
@merge of ansi-6-0-branch into HEAD
@
text
@d7 5
a11 1
#include "conf.h"
@


11.5
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d36 3
a38 3
fastf_t hyper_get_x(a,c, s, d, x, cos_ang)
fastf_t a, c; 	/* curve parameters */
fastf_t s;		/* arclength value  */
d53 1
a53 2
fastf_t hyper_get_s(a, c, x)
fastf_t a, c, x;
d62 1
a62 2
fastf_t hyper_get_z(a,b,c,x)
fastf_t a,b,c,x;
d78 1
a78 2
fastf_t hyper_get_ang(a,c,x)
fastf_t a,c,x;
d94 6
a99 6
int getcurve(pa,pb,pc,pth0,pth1,delta_s, p_zero, p_one, r_zero, r_one)
fastf_t	*pa, *pb, *pc;	/* curve parameters */
fastf_t *pth0, *pth1;	/* angle where curve contacts circle0,circle1 */
fastf_t delta_s;	/* desired arclength */
fastf_t r_zero, r_one;  /* radii of circle0 and circle1 */
vect_t p_zero, p_one;	/* center of circle0 and circle1 */
d103 1
a103 1
	int ingetcurve();
d185 1
a185 4
int ingetcurve(pa,pb,pc, delta_s, p_zero, p_one)
fastf_t	*pa, *pb, *pc;
fastf_t delta_s;
vect_t p_zero, p_one;
d189 1
a189 1
	fastf_t eff(),gee();
d227 1
a227 2
fastf_t eff(a,c,x0,x1,delta_s)
fastf_t a,c,x0,x1,delta_s;
d252 1
a252 2
fastf_t gee(a,c,x0,x1,delta_z)
fastf_t a,c,x0,x1,delta_z;
@


11.5.2.1
log
@Initial ANSIfication
@
text
@d36 3
a38 3
fastf_t hyper_get_x(fastf_t a, fastf_t c, fastf_t s, int d, int x, int cos_ang)
              	/* curve parameters */
          		/* arclength value  */
d53 2
a54 1
fastf_t hyper_get_s(fastf_t a, fastf_t c, fastf_t x)
d63 2
a64 1
fastf_t hyper_get_z(fastf_t a, fastf_t b, fastf_t c, fastf_t x)
d80 2
a81 1
fastf_t hyper_get_ang(fastf_t a, fastf_t c, fastf_t x)
d97 6
a102 6
int getcurve(fastf_t *pa, fastf_t *pb, fastf_t *pc, fastf_t *pth0, fastf_t *pth1, fastf_t delta_s, fastf_t *p_zero, fastf_t *p_one, fastf_t r_zero, fastf_t r_one)
       	              	/* curve parameters */
                     	/* angle where curve contacts circle0,circle1 */
                	/* desired arclength */
                        /* radii of circle0 and circle1 */
                     	/* center of circle0 and circle1 */
d106 1
a106 1
	int ingetcurve(fastf_t *pa, fastf_t *pb, fastf_t *pc, fastf_t delta_s, fastf_t *p_zero, fastf_t *p_one);
d188 4
a191 1
int ingetcurve(fastf_t *pa, fastf_t *pb, fastf_t *pc, fastf_t delta_s, fastf_t *p_zero, fastf_t *p_one)
d195 1
a195 1
	fastf_t eff(fastf_t a, fastf_t c, fastf_t x0, fastf_t x1, fastf_t delta_s),gee(fastf_t a, fastf_t c, fastf_t x0, fastf_t x1, fastf_t delta_z);
d233 2
a234 1
fastf_t eff(fastf_t a, fastf_t c, fastf_t x0, fastf_t x1, fastf_t delta_s)
d259 2
a260 1
fastf_t gee(fastf_t a, fastf_t c, fastf_t x0, fastf_t x1, fastf_t delta_z)
@


11.4
log
@Converted from K&R to ANSI C - RFH
@
text
@d36 3
a38 3
fastf_t hyper_get_x(fastf_t a, fastf_t c, fastf_t s, int d, int x, int cos_ang)
              	/* curve parameters */
          		/* arclength value  */
d53 2
a54 1
fastf_t hyper_get_s(fastf_t a, fastf_t c, fastf_t x)
d63 2
a64 1
fastf_t hyper_get_z(fastf_t a, fastf_t b, fastf_t c, fastf_t x)
d80 2
a81 1
fastf_t hyper_get_ang(fastf_t a, fastf_t c, fastf_t x)
d97 6
a102 6
int getcurve(fastf_t *pa, fastf_t *pb, fastf_t *pc, fastf_t *pth0, fastf_t *pth1, fastf_t delta_s, fastf_t *p_zero, fastf_t *p_one, fastf_t r_zero, fastf_t r_one)
       	              	/* curve parameters */
                     	/* angle where curve contacts circle0,circle1 */
                	/* desired arclength */
                        /* radii of circle0 and circle1 */
                     	/* center of circle0 and circle1 */
d106 1
a106 1
	int ingetcurve(fastf_t *pa, fastf_t *pb, fastf_t *pc, fastf_t delta_s, fastf_t *p_zero, fastf_t *p_one);
d188 4
a191 1
int ingetcurve(fastf_t *pa, fastf_t *pb, fastf_t *pc, fastf_t delta_s, fastf_t *p_zero, fastf_t *p_one)
d195 1
a195 1
	fastf_t eff(fastf_t a, fastf_t c, fastf_t x0, fastf_t x1, fastf_t delta_s),gee(fastf_t a, fastf_t c, fastf_t x0, fastf_t x1, fastf_t delta_z);
d233 2
a234 1
fastf_t eff(fastf_t a, fastf_t c, fastf_t x0, fastf_t x1, fastf_t delta_s)
d259 2
a260 1
fastf_t gee(fastf_t a, fastf_t c, fastf_t x0, fastf_t x1, fastf_t delta_z)
@


11.3
log
@Eliminated some unused variables
@
text
@d36 3
a38 3
fastf_t hyper_get_x(a,c, s, d, x, cos_ang)
fastf_t a, c; 	/* curve parameters */
fastf_t s;		/* arclength value  */
d53 1
a53 2
fastf_t hyper_get_s(a, c, x)
fastf_t a, c, x;
d62 1
a62 2
fastf_t hyper_get_z(a,b,c,x)
fastf_t a,b,c,x;
d78 1
a78 2
fastf_t hyper_get_ang(a,c,x)
fastf_t a,c,x;
d94 6
a99 6
int getcurve(pa,pb,pc,pth0,pth1,delta_s, p_zero, p_one, r_zero, r_one)
fastf_t	*pa, *pb, *pc;	/* curve parameters */
fastf_t *pth0, *pth1;	/* angle where curve contacts circle0,circle1 */
fastf_t delta_s;	/* desired arclength */
fastf_t r_zero, r_one;  /* radii of circle0 and circle1 */
vect_t p_zero, p_one;	/* center of circle0 and circle1 */
d103 1
a103 1
	int ingetcurve();
d185 1
a185 4
int ingetcurve(pa,pb,pc, delta_s, p_zero, p_one)
fastf_t	*pa, *pb, *pc;
fastf_t delta_s;
vect_t p_zero, p_one;
d189 1
a189 1
	fastf_t eff(),gee();
d227 1
a227 2
fastf_t eff(a,c,x0,x1,delta_s)
fastf_t a,c,x0,x1,delta_s;
d252 1
a252 2
fastf_t gee(a,c,x0,x1,delta_z)
fastf_t a,c,x0,x1,delta_z;
@


11.2
log
@minor bugs
@
text
@d112 1
a112 1
	static fastf_t last_a, last_b, last_c, last_theta_one, last_theta_zero;
d193 1
a193 1
	int status, f_status, g_status, i, j, k;
a199 1
		f_status = MAX_REACHED;
a208 1
				f_status = SOLVED;
a212 1
		g_status = MAX_REACHED;
a216 1
				g_status = SOLVED;
@


11.1
log
@Release_4.4
@
text
@d70 2
a71 1
		return(z);
d73 1
d226 1
a226 1
			status==SOLVED;
@


1.4
log
@included conf.h
@
text
@@


1.3
log
@changed ntrack to anim_track
@
text
@d7 1
@


1.2
log
@changed hyper_get routines to be simpler, with toleranceing in the calling
routines.
@
text
@d3 1
a3 1
 *  Caternary curve routines used by ntrack.c
@


1.1
log
@Initial revision
@
text
@d33 1
a33 2
 * If a is too small, uses linear approximation. The x argument and the
 * cos_ang  argument are for the linear approximation only.
d37 1
a37 4
fastf_t s;		/* arclength value at beginning of curve */
fastf_t d;		/* desired distance along curve */
fastf_t x;		/* x value of beginning of curve */
fastf_t cos_ang;	/* cosine of angle made by curve if linear */
d41 1
a41 1
	arg = a*(s+d) - sinh(a*c);
d43 2
a44 5
	if (a>VDIVIDE_TOL)
		return(asinh_arg/a + c);
	else { /* practically linear */
		return(x + d*cos_ang);
	}
d49 4
a52 2
 * s(x) = (sinh(a(x-c))+sinh(ac))/a */
int hyper_get_s(ps, a, c, x)
a53 1
double *ps;
d55 1
a55 7
	if (fabs(a)>VDIVIDE_TOL){
		*ps = (sinh(a*(x-c))+sinh(a*c))/a;
		return(0);
	}
	else {
		return(-1);
	}
d60 1
d67 4
a70 2
	z = cosh(a*(x-c))/a + b;
	return(z);
@
