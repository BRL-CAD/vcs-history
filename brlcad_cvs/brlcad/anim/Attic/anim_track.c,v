head	11.18;
access;
symbols
	ansi-20040405-merged:11.14.2.2
	postmerge-20040405-ansi:11.16
	premerge-20040404-ansi:11.15
	postmerge-autoconf:11.15
	autoconf-freeze:11.14.10.1
	premerge-autoconf:11.15
	ansi-20040316-freeze:11.14.2.1
	postmerge-20040315-windows:11.15
	premerge-20040315-windows:11.15
	windows-20040315-freeze:11.14.4.1
	autoconf-20031203:11.14
	autoconf-20031202:11.14
	autoconf-branch:11.14.0.10
	phong-branch:11.14.0.8
	photonmap-branch:11.14.0.6
	rel-6-1-DP:11.14
	windows-branch:11.14.0.4
	rel-6-0-2:11.12
	ansi-branch:11.14.0.2
	rel-6-0-1-branch:11.12.0.2
	hartley-6-0-post:11.13
	hartley-6-0-pre:11.12
	rel-6-0-1:11.12
	rel-6-0:11.12
	rel-5-4:11.11
	offsite-5-3-pre:11.11
	rel-5-3:11.11
	rel-5-2:11.11
	rel-5-1-branch:11.11.0.2
	rel-5-1:11.11
	rel-5-0:11.10
	rel-5-0-beta:11.9
	rel-4-5:11.9
	ctj-4-5-post:11.8
	ctj-4-5-pre:11.8
	rel-4-4:11.1;
locks; strict;
comment	@ * @;


11.18
date	2004.05.24.04.17.00;	author morrison;	state dead;
branches;
next	11.17;

11.17
date	2004.05.10.15.30.41;	author erikg;	state Exp;
branches;
next	11.16;

11.16
date	2004.04.05.07.50.19;	author morrison;	state Exp;
branches;
next	11.15;

11.15
date	2004.02.02.17.38.58;	author morrison;	state Exp;
branches;
next	11.14;

11.14
date	2002.08.20.17.07.18;	author jra;	state Exp;
branches
	11.14.2.1
	11.14.4.1
	11.14.10.1;
next	11.13;

11.13
date	2002.08.15.20.54.06;	author hartley;	state Exp;
branches;
next	11.12;

11.12
date	2001.08.21.20.39.41;	author jra;	state Exp;
branches;
next	11.11;

11.11
date	99.12.30.19.06.45;	author jra;	state Exp;
branches;
next	11.10;

11.10
date	99.07.02.22.07.12;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	97.08.22.22.48.24;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	97.03.24.14.51.26;	author jra;	state Exp;
branches;
next	11.7;

11.7
date	96.08.19.17.15.10;	author cnuzman;	state Exp;
branches;
next	11.6;

11.6
date	96.08.16.23.49.09;	author cnuzman;	state Exp;
branches;
next	11.5;

11.5
date	96.08.14.00.06.42;	author cnuzman;	state Exp;
branches;
next	11.4;

11.4
date	96.08.13.17.03.53;	author cnuzman;	state Exp;
branches;
next	11.3;

11.3
date	96.08.01.21.36.38;	author cnuzman;	state Exp;
branches;
next	11.2;

11.2
date	95.07.10.23.36.39;	author cnuzman;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.34.10;	author mike;	state Rel4_4;
branches;
next	1.4;

1.4
date	94.12.30.03.39.55;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	94.11.01.07.37.56;	author butler;	state Exp;
branches;
next	1.2;

1.2
date	94.08.25.11.05.53;	author cnuzman;	state Exp;
branches;
next	1.1;

1.1
date	94.08.04.21.06.39;	author cnuzman;	state Exp;
branches;
next	;

11.14.2.1
date	2002.09.19.18.00.32;	author morrison;	state Exp;
branches;
next	11.14.2.2;

11.14.2.2
date	2004.03.17.21.15.48;	author morrison;	state Exp;
branches;
next	;

11.14.4.1
date	2004.03.11.23.40.25;	author morrison;	state Exp;
branches;
next	;

11.14.10.1
date	2004.02.12.19.40.40;	author erikg;	state Exp;
branches;
next	;


desc
@program to create animation scripts for a tracked vehicle
@


11.18
log
@moved to src/anim/
@
text
@/*			A N I M _ T R A C K . C
 *
 *  Animate the links and wheels of a tracked vehicle. Handles tracks that
 *  change in shape during the animation.
 *
 *  Author -
 *	Carl J. Nuzman
 *  
 *  Source -
 *      The U. S. Army Research Laboratory
 *      Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *      Re-distribution of this software is restricted, as described in
 *      your "Statement of Terms and Conditions for the Release of
 *      The BRL-CAD Pacakge" agreement.
 *
 *  Copyright Notice -
 *      This software is Copyright (C) 1993-2004 by the United States Army
 *      in all countries except the USA.  All rights reserved.
 */

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include <math.h>
#include <stdio.h>
#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "raytrace.h"
#include "anim.h"

#ifndef M_PI
#define M_PI	3.14159265358979323846
#endif

#ifndef M_PI_2
#define M_PI_2	1.57079632679489661923
#endif

#define GIVEN		0
#define CALCULATED	1
#define STEERED		2

#define PRINT_ANIM	0
#define PRINT_ARCED	1

#define TRACK_MIN	0
#define TRACK_FIXED	1
#define TRACK_STRETCH	2
#define TRACK_ELASTIC	3

#define NW	num_wheels
#define NEXT(i)	(i+1)%NW
#define PREV(i)	(i+NW-1)%NW
typedef double *pdouble;

struct wheel {
vect_t		pos;	/* displacement of wheel from vehicle origin */
fastf_t		rad;	/* radius of wheel */
fastf_t		ang0;	/* angle where track meets wheel 0<a<2pi*/
fastf_t		ang1;	/* angle where track leaves wheel 0<a<p2i */
fastf_t		arc;	/* radian length of contact between wheel and track 0<a<pi*/
};

struct track {
vect_t		pos0;	/* beginning point of track section */
vect_t		pos1;	/* end of track section */
vect_t		dir;	/* unit vector:direction of track section ending here*/
fastf_t		len;	/* length of track section ending here*/
};

struct slope {
vect_t		dir;	/* vector from previous to current axle*/
fastf_t		len;	/* length of vector above*/
};

struct all {
struct wheel 	w;	/* parameters describing the track around a wheel */
struct track	t;	/* track between this wheel and the previous wheel */
struct slope	s;	/* vector between this axle and the previous axle */
};

/* external variables */
extern int bu_optind;
extern char *bu_optarg;

/* variables describing track geometry - used by main, trackprep, get_link*/
struct all *x;

fastf_t curve_a, curve_b, curve_c, s_start;
int num_links, num_wheels;
fastf_t track_y, tracklen, first_tracklen;

/* variables set by get_args */
int wheel_nindex;	/* argv[wheel_nindex] = wheelname*/
int link_nindex;	/* argv[link_nindex] = linkname*/
int print_wheel;	/* flag: do wheel animation */
int print_link;		/* flag: do link animation */
int print_mode;		/*  anim for rt or arced for mged */
int arced_frame;	/* which frame to arced */
int  axes, cent;	/* flags: alternate axes, centroid specified */
int dist_mode;		/* given, steered, or calculated  */
int  first_frame;	/* integer to begin numbering frames */
fastf_t init_dist;	/* initial distance of first link along track */
int one_radius;		/* flag: common radius specified */
fastf_t radius;		/* common radius of all wheels */
vect_t centroid, rcentroid;	/* alternate centroid and its reverse */
mat_t m_axes, m_rev_axes;	/* matrices to and from alternate axes */
char link_cmd[10];		/* default is "rarc" */
char wheel_cmd[10];		/* default is "lmul" */
int get_circumf;	/* flag: just return circumference of track */
int read_wheels;		/* flag: read new wheel positions each frame */
int len_mode;		/* mode for track_len */
int anti_strobe;	/* flag: take measures against strobing effect */

int
main(int argc, char **argv)
{
	void anim_y_p_r2mat(fastf_t *, double, double, double), anim_add_trans(fastf_t *, const fastf_t *, const fastf_t *), anim_mat_print(FILE *, const fastf_t *, int);
	int get_args(int argc, char **argv), get_link(fastf_t *pos, fastf_t *angle_p, fastf_t dist), track_prep(void), val, frame, i, count;
	int go;
	fastf_t y_rot, distance, yaw, pch, roll;
	vect_t cent_pos, wheel_now, wheel_prev;
	vect_t zero, position, vdelta, temp, to_track, to_front;
	mat_t wmat, mat_x;
	FILE *stream;
	struct wheel *wh;
	int last_steer, last_frame;
	int rndtabi=0;
	fastf_t halfpadlen, delta, prev_dist;

	VSETALL(zero,0.0);
	VSETALL(to_track,0.0);
	VSETALL(centroid,0.0);
	VSETALL(rcentroid,0.0);
	y_rot = 0.0;
	num_wheels = 0;
	last_steer = last_frame = 0;
	MAT_IDN(mat_x);
	MAT_IDN(wmat);
	MAT_IDN(m_axes);
	MAT_IDN(m_rev_axes);

	if (!get_args(argc,argv))
		fprintf(stderr,"Anim_track: Argument error.\n");

	if (axes || cent ){ /* vehicle has own reference frame */
		anim_add_trans(m_axes,centroid,zero);
		anim_add_trans(m_rev_axes,zero,rcentroid);
	}

	/* get track information from specified file */
	
	if (!(stream = fopen(*(argv+bu_optind),"r"))){
		fprintf(stderr,"Track: Could not open file %s.\n",*(argv+bu_optind));
		return(0);
	}
	num_wheels = -1;
	if (one_radius) {
		while (!feof(stream)) {
			fscanf(stream,"%*f %*f %*f");
			num_wheels++;
		}
	} else {
		while (!feof(stream)) {
			fscanf(stream,"%*f %*f %*f %*f");
			num_wheels++;
		}
	}
	rewind(stream);


	/*allocate memory for track information*/
	/* x: contains track geometry for the current frame */
	x = (struct all *) calloc(num_wheels,sizeof(struct all));
	/* wh: contains geometry of wheels in mged database */
	wh = (struct wheel *) calloc(num_wheels,sizeof(struct wheel));

	/*read original wheel positions*/
	for (i=0;i<NW;i++){
		fscanf(stream,"%lf %lf %lf", temp, temp+1, temp+2);
		if (one_radius)
			x[i].w.rad = radius;
		else
			fscanf(stream,"%lf",& x[i].w.rad);
		MAT4X3PNT(x[i].w.pos,m_rev_axes,temp);
		if (i==0)
			track_y = x[0].w.pos[1];
		else
			x[i].w.pos[1] = track_y;


		wh[i].pos[0] = x[i].w.pos[0];
		wh[i].pos[1] = x[i].w.pos[1];
		wh[i].pos[2] = x[i].w.pos[2];
		wh[i].rad = x[i].w.rad;
	}
	(void) fclose(stream);

	/* initialize to_track */
	VSET(to_track, 0.0, track_y, 0.0);
	VSET(to_front,1.0,0.0,0.0);

	if (get_circumf&& (!read_wheels)) {
		track_prep();
		printf("%.10g\n",tracklen);
		return(0);
	}
		

	if (dist_mode==STEERED) {
		/* prime the pumps */
		scanf("%*f");/*time*/
		val = scanf("%lf %lf %lf", cent_pos, cent_pos+1, cent_pos + 2);
		if (val < 3)
			return(0);
		go = anim_steer_mat(mat_x, cent_pos, 0);
		last_steer = 0;
	} else {
		go = 1;
	}

	if (anti_strobe) {
		BN_RANDSEED(rndtabi, 0);
	}

	/* main loop */
	prev_dist = distance = 0.0;
	frame = first_frame;
	for ( ; ; frame++) {
		if (dist_mode==GIVEN){
			scanf("%*f");/*time*/
			val = scanf("%lf",&distance);
			if (val < 1) {
				break;
			}
		}
		else if (dist_mode==CALCULATED){
			scanf("%*f");/*time*/
			scanf("%lf %lf %lf", cent_pos, cent_pos+1, cent_pos+2);
			val = scanf("%lf %lf %lf",&yaw,&pch,&roll);
			if (val < 3)
				break;
			anim_dy_p_r2mat(mat_x,yaw,pch,roll);
			anim_dy_p_r2mat(mat_x,yaw,pch,roll);
			anim_add_trans(mat_x,cent_pos,rcentroid);
		}

		if (read_wheels) {
			/* read in all wheel positions */
			for(i=0;i<NW;i++){
				val=scanf("%lf %lf",x[i].w.pos, x[i].w.pos + 2);
				if (val < 2) {
					break;
				}
			}
		}

		if (dist_mode==STEERED) {
			scanf("%*f");/*time*/
			val = scanf("%lf %lf %lf", cent_pos, cent_pos+1, cent_pos + 2);
			if (val < 3){
				if (last_steer)
					break;
				else
					last_steer = 1;
			}
			go = anim_steer_mat(mat_x, cent_pos, last_steer);
			anim_add_trans(mat_x,cent_pos,rcentroid);
		}
		
		/* call track_prep to calculate geometry of track */
		if ((frame==first_frame)||read_wheels) {
			if ((track_prep())==-1){
				fprintf(stderr,"Track: error in frame %d: track too short.\n",frame);
				break;
			}
			if (get_circumf) {
				printf("%d\t%.10g\n",frame,tracklen);
			}
		}



		if ((dist_mode==CALCULATED)||(dist_mode==STEERED)){ 
			/*determine distance traveled*/
			VMOVE(wheel_prev,wheel_now);
			MAT4X3PNT(wheel_now,mat_x,to_track);
			if (frame > first_frame){ /* increment distance by distance moved*/
				VSUB2(vdelta,wheel_now,wheel_prev);
				MAT3X3VEC(temp,mat_x,to_front);/*new front of vehicle*/
				distance += VDOT(temp,vdelta);/*portion of vdelta in line with track*/
			}
		}

		if (anti_strobe) {
			halfpadlen = 0.5 * tracklen/(fastf_t) num_links;
			delta = distance - prev_dist;
			prev_dist = distance;
			if ((delta >= halfpadlen)||(delta <= -halfpadlen)) {
				distance += BN_RANDOM(rndtabi) * 2.0* halfpadlen;
			}
		}

		if (go && (!get_circumf)) {
			if (print_mode==PRINT_ANIM) {
				printf("start %d;\nclean;\n", frame);
			} else if (print_mode==PRINT_ARCED) {
				if (frame != arced_frame) continue;
				last_frame = 1;
			}
			if (print_link) {
			        for (count=0;count<num_links;count++){
		        	        (void) get_link(position,&y_rot,distance+tracklen*count/num_links+init_dist);
					anim_y_p_r2mat(wmat,0.0,y_rot,0.0);
			        	anim_add_trans(wmat,position,zero);
			        	if (axes || cent){ /* link moved to vehicle coords */
			        		MAT_MOVE(mat_x,wmat);
			        		bn_mat_mul(wmat,m_axes,mat_x);
			        	}
			        	if (print_mode==PRINT_ANIM) {
						printf("anim %s%d matrix %s\n", *(argv+link_nindex),count,link_cmd);
			        		anim_mat_printf(stdout,wmat,"%.10g ","\n",";\n");
			        	} else if (print_mode==PRINT_ARCED) {
			        		printf("arced %s%d matrix %s ", *(argv+link_nindex),count,link_cmd);
			        		anim_mat_printf(stdout,wmat,"%.10g ","","\n");
			        	}
				}
			}
			if (print_wheel){
				for (count = 0;count<num_wheels;count++){
					anim_y_p_r2mat(wmat,0.0,-distance/wh[count].rad,0.0);
					VREVERSE(temp,wh[count].pos);
					anim_add_trans(wmat,x[count].w.pos,temp);
			        	if (axes || cent){
				        	bn_mat_mul(mat_x,wmat,m_rev_axes);
			        		bn_mat_mul(wmat,m_axes,mat_x);
			        	}
			        	if (print_mode==PRINT_ANIM) {
						printf("anim %s%d matrix %s\n",*(argv+wheel_nindex),count,wheel_cmd);
			        		anim_mat_printf(stdout,wmat,"%.10g ","\n",";\n");
			        	} else if (print_mode==PRINT_ARCED) {
						printf("arced %s%d matrix %s ",*(argv+wheel_nindex),count,wheel_cmd);
			        		anim_mat_printf(stdout,wmat,"%.10g ","","\n");
			        	}
				}
			}
			if (print_mode==PRINT_ANIM)
				printf("end;\n");
		}
		if (last_frame) break;
	}
	free(x);
	free(wh);
	return( 0 );
}

#define OPT_STR "sycuvb:d:f:i:r:p:w:g:m:l:a"

int get_args(int argc, char **argv)
{
	int c, i;
	fastf_t yaw, pch, rll;
	void anim_dx_y_z2mat(fastf_t *, double, double, double), anim_dz_y_x2mat(fastf_t *, double, double, double);
	/* defaults*/
	wheel_nindex = link_nindex = 0;
	axes = cent = print_wheel = print_link = 0;
	arced_frame = first_frame = 0;
	init_dist = radius = 0.0;
	one_radius = get_circumf = read_wheels = 0;
	strcpy(link_cmd, "rarc");
	strcpy(wheel_cmd, "lmul");
	print_mode = PRINT_ANIM;
	dist_mode = GIVEN;
	len_mode = TRACK_MIN;
	anti_strobe = 0;

        while ( (c=bu_getopt(argc,argv,OPT_STR)) != EOF) {
                i=0;
                switch(c){
                case 's':
                	dist_mode = STEERED;
                	break;
                case 'y':
                	dist_mode = CALCULATED;
                	break;
                case 'c':
                	get_circumf = 1;
                	break;
                case 'u':
                	dist_mode = GIVEN;
                	break;
                case 'v':
                	read_wheels = 1;
                	break;
                case 'b':
                	bu_optind -= 1;
                        sscanf(argv[bu_optind+(i++)],"%lf", &yaw );
                        sscanf(argv[bu_optind+(i++)],"%lf", &pch );
                        sscanf(argv[bu_optind+(i++)],"%lf", &rll );
			bu_optind += 3;
			anim_dx_y_z2mat(m_axes, rll, -pch, yaw);
			anim_dz_y_x2mat(m_rev_axes, -rll, pch, -yaw);
			axes = 1;
                        break;
                case 'd':
                        bu_optind -= 1;
                        sscanf(argv[bu_optind+(i++)],"%lf",centroid);
                        sscanf(argv[bu_optind+(i++)],"%lf",centroid+1);
                        sscanf(argv[bu_optind+(i++)],"%lf",centroid+2);
                        bu_optind += 3;
                        VREVERSE(rcentroid,centroid);
                	cent = 1;
                        break;
                case 'f':
                	sscanf(bu_optarg,"%d",&first_frame);
                        break;
                case 'i':
                	sscanf(bu_optarg,"%lf",&init_dist);
                	break;
                case 'r':
                	sscanf(bu_optarg,"%lf",&radius);
                	one_radius = 1;
                	break;
                case 'p':
                	sscanf(bu_optarg,"%d", &num_links);
                	link_nindex = bu_optind;
                	bu_optind += 1;
                	print_link = 1;
                        break;
                case 'w':
                	wheel_nindex = bu_optind - 1;
                	/*sscanf(bu_optarg,"%s",wheel_name);*/
                	print_wheel = 1;
                        break;
                case 'g':
                	sscanf(bu_optarg,"%d",&arced_frame);
                	print_mode = PRINT_ARCED;
                	break;
                case 'm':
                	switch (*bu_optarg) {
                	case 'p':
                		strncpy(link_cmd,argv[bu_optind], 10);
                		break;
                	case 'w':
                		strncpy(wheel_cmd,argv[bu_optind], 10);
                		break;
                	default:
                		fprintf(stderr,"Unknown option: -m%c\n",*bu_optarg);
                		return(0);
                	}
                	bu_optind += 1;
                	break;
                case 'l':
                	switch (*bu_optarg) {
                	case 'm':
                		len_mode = TRACK_MIN;
                		break;
                	case 'f':
                		len_mode = TRACK_FIXED;
	                	sscanf(argv[bu_optind],"%lf",&first_tracklen);
	                	tracklen = first_tracklen;
	                	bu_optind++;
                		break;
                	case 's':
	        		len_mode = TRACK_STRETCH;
	                	sscanf(argv[bu_optind],"%lf",&first_tracklen);
	                	tracklen = first_tracklen;
	                	bu_optind++;
                       		break;
                	case 'e':
                		len_mode = TRACK_ELASTIC;
	                	sscanf(argv[bu_optind],"%lf",&first_tracklen);
	                	tracklen = first_tracklen;
	                	bu_optind++;
                		break;
                	default:
                		fprintf(stderr,"Unknown option: -l%c\n",*bu_optarg);
                		return(0);
                	}
                	break;
                case 'a':
                	anti_strobe = 1;
                	break;
                default:
                        fprintf(stderr,"Unknown option: -%c\n",c);
                        return(0);
                }
        }
        return(1);
}

/* TRACK_PREP - Calculate the geometry of the track. Wheel positions and
 * radii should already exist in the x[i] structs. Track_prep fills in the
 * rest of the x[i] structs and also calculates values for curve_a, curve_b,
 * curve_c, and s_start, which describe the caternary segment
 * return values: 0 = GOOD
 * 		 -1 = BAD. Track too short to fit around wheels
 */
int track_prep(void)
{
	int i;
	fastf_t phi, costheta, arc_angle;
	fastf_t linearlen, hyperlen;
	vect_t difference;
	int getcurve(fastf_t *pa, fastf_t *pb, fastf_t *pc, fastf_t *pth0, fastf_t *pth1, fastf_t delta_s, fastf_t *p_zero, fastf_t *p_one, fastf_t r_zero, fastf_t r_one);
	fastf_t hyper_get_s(fastf_t a, fastf_t c, fastf_t x);

	/* first loop - get inter axle slopes and start/end angles */
	for (i=0;i<NW;i++){
		/*calculate current slope vector*/
		VSUB2(x[i].s.dir,x[i].w.pos,x[PREV(i)].w.pos);
		x[i].s.len = MAGNITUDE(x[i].s.dir);
		/*calculate end angle of previous wheel assuming all convex*/
		phi = atan2(x[i].s.dir[2],x[i].s.dir[0]);/*absolute angle of slope*/
		costheta = (x[PREV(i)].w.rad - x[i].w.rad)/x[i].s.len;/*cosine of special angle*/
		x[PREV(i)].w.ang1 = phi +  acos(costheta);
		while (x[PREV(i)].w.ang1 < 0.0)
			x[PREV(i)].w.ang1 += 2.0*M_PI;
		x[i].w.ang0 = x[PREV(i)].w.ang1;
	}
	/* second loop - handle concavities */
	for (i=0;i<NW;i++){
		arc_angle = x[i].w.ang0 - x[i].w.ang1;
		while (arc_angle < 0.0)
			arc_angle += 2.0*M_PI;
		if (arc_angle > M_PI) { /* concave */
			x[i].w.ang0 = 0.5*(x[i].w.ang0 + x[i].w.ang1);
			x[i].w.ang1 = x[i].w.ang0;
			x[i].w.arc = 0.0;
		}
		else { /* convex - angles are already correct */
			x[i].w.arc = arc_angle;
		}
	}
	
	/* third loop - calculate geometry of straight track segments */
	for (i=0;i<NW;i++){
		/*calculate endpoints of track segment*/
		x[i].t.pos1[0] = x[i].w.pos[0] + x[i].w.rad*cos(x[i].w.ang0);
		x[i].t.pos1[1] = x[i].w.pos[1];
		x[i].t.pos1[2] = x[i].w.pos[2] + x[i].w.rad*sin(x[i].w.ang0);
		x[i].t.pos0[0] = x[PREV(i)].w.pos[0] + x[PREV(i)].w.rad*cos(x[PREV(i)].w.ang1);
		x[i].t.pos0[1] = x[PREV(i)].w.pos[1];
		x[i].t.pos0[2] = x[PREV(i)].w.pos[2] + x[PREV(i)].w.rad*sin(x[PREV(i)].w.ang1);
		/*calculate length and direction of track segment*/
		VSUB2(difference,x[i].t.pos1,x[i].t.pos0);
		x[i].t.len = MAGNITUDE(difference);
		VSCALE((x[i].t.dir),difference,(1.0/x[i].t.len));
	}

	/* calculate total track length used so far*/
	linearlen = x[0].w.arc*x[0].w.rad;
	for (i=1;i<NW;i++){
		linearlen += x[i].t.len;
		linearlen += x[i].w.arc*x[i].w.rad;
	}

	if (len_mode==TRACK_MIN) {
		tracklen = linearlen + x[0].t.len;
		curve_a = 0.0;
		return(0); /* early return */
	}

	if (len_mode==TRACK_ELASTIC) {
		tracklen = first_tracklen;
	}
		
	/* calculate geometry of hyperbolic segment */
	hyperlen = tracklen - linearlen;
	if(hyperlen < x[0].t.len){ /* desired length of hyperbola less than straight line*/
		if((len_mode==TRACK_ELASTIC)||(len_mode==TRACK_STRETCH)){
			tracklen += (x[0].t.len-hyperlen);
			hyperlen = tracklen - linearlen;
		}
		else{
			return(-1);/*bad, track is too short*/
		}
	}

	getcurve(&curve_a,&curve_b,&curve_c,&(x[NW-1].w.ang1),&(x[0].w.ang0),hyperlen,x[NW-1].w.pos,x[0].w.pos,x[NW-1].w.rad,x[0].w.rad);

	/* re-evaluate zeroth track section in light of curve information */
	x[0].t.pos0[X] = x[NW-1].w.pos[X] + x[NW-1].w.rad * cos(x[NW-1].w.ang1);
	x[0].t.pos0[Z] = x[NW-1].w.pos[Z] + x[NW-1].w.rad * sin(x[NW-1].w.ang1);
	x[0].t.pos1[X] = x[0].w.pos[X] + x[0].w.rad * cos(x[0].w.ang0);
	x[0].t.pos1[Z] = x[0].w.pos[Z] + x[0].w.rad * sin(x[0].w.ang0);
	VSUB2(difference,x[0].t.pos1,x[0].t.pos0);
	x[0].t.len = MAGNITUDE(difference);
	VSCALE(x[0].t.dir,difference,(1.0/x[0].t.len));
		
	if (curve_a > VDIVIDE_TOL)
		s_start = hyper_get_s(curve_a, 0.0, x[0].t.pos0[X] - curve_c);
	
	x[0].w.arc = x[0].w.ang0 - x[0].w.ang1;
	if (x[0].w.arc<0.0)
		x[0].w.arc += 2.0*M_PI;
	x[NW-1].w.arc = x[NW-1].w.ang0 - x[NW-1].w.ang1;
	if (x[NW-1].w.arc<0.0)
		x[NW-1].w.arc += 2.0*M_PI;

	return(0); /*good*/
}

/* GET_LINK - Find the position and angle of a link which is a given
 * distance around the track, measured from the point where the caternary
 * section meets wheel.0.
 */
int get_link(fastf_t *pos, fastf_t *angle_p, fastf_t dist)
{
	int i;
	vect_t temp;
	fastf_t hyper_get_x(fastf_t a, fastf_t c, fastf_t s, int d, int x, int cos_ang), hyper_get_z(fastf_t a, fastf_t b, fastf_t c, fastf_t x), hyper_get_ang(fastf_t a, fastf_t c, fastf_t x);

	while (dist >= tracklen) /*periodicize*/
		dist -= tracklen;
	while (dist < 0.0)
		dist += tracklen;

	/* we want it to ignore the distance between wheel(n-1) and wheel(0)*/
	dist += x[0].t.len; 
	for (i=0;i<NW;i++){
		if ( (dist  -= x[i].t.len) < 0 ){
			VSCALE(temp,(x[i].t.dir),dist);
			VADD2(pos,x[i].t.pos1,temp);
			*angle_p = atan2(x[i].t.dir[2],x[i].t.dir[0]);
			return(2*i);
		}
		if ((dist -= x[i].w.rad*x[i].w.arc) < 0){
			*angle_p = dist/x[i].w.rad;
			*angle_p = x[i].w.ang1 - *angle_p;/*from x-axis to link*/
			pos[X] = x[i].w.pos[X] + x[i].w.rad*cos(*angle_p);
			pos[Y] = x[i].w.pos[Y];
			pos[Z] = x[i].w.pos[Z] + x[i].w.rad*sin(*angle_p);
			*angle_p -= M_PI_2; /*angle of clockwise tangent to circle*/
			return(2*i+1);
		}
	}

	/* caternary section */
	if ( curve_a > VDIVIDE_TOL){
		pos[X] = hyper_get_x(curve_a, 0.0, s_start+dist, 0, 0, 0);
		pos[Y] = x[0].w.pos[Y];
		pos[Z] = hyper_get_z(curve_a,curve_b,0.0, pos[X]);
		pos[X] += curve_c;
		*angle_p = hyper_get_ang(curve_a,curve_c, pos[X]);
	}
	else { /* practically linear */
		VSCALE(temp,(x[0].t.dir),dist);
		VADD2(pos,x[0].t.pos0,temp);
		*angle_p = atan2(x[0].t.dir[Z],x[0].t.dir[X]);
	}


	
	return -1;
}

void show_info(int which)/* for debugging - -1:track 0:both 1:link*/
          
{
	int i;
	if (which <=0){
		fprintf(stderr,"track length: %f\n",tracklen);
		fprintf(stderr,"link length: %f\n",tracklen/num_links);
		for (i=0;i<NW;i++){
			fprintf(stderr,"wheel %d: \n",i);
			fprintf(stderr," pos\t%f\t%f\t%f\t\n",x[i].w.pos[X],x[i].w.pos[Y],x[i].w.pos[Z]);
			fprintf(stderr," rad\t%f\tang0\t%f\tang1\t%f\tarc\t%f\n",x[i].w.rad,x[i].w.ang0,x[i].w.ang1,x[i].w.arc);

			fprintf(stderr,"track %d: \n",i);
			fprintf(stderr," pos0\t%f\t%f\tpos1\t%f\t%f\n",x[i].t.pos0[X],x[i].t.pos0[Z],x[i].t.pos1[X],x[i].t.pos1[Z]);
			fprintf(stderr," dir\t%f\t%f\t%f\tlen\t%f\n",x[i].t.dir[X],x[i].t.dir[Y],x[i].t.dir[Z],x[i].t.len);
			fprintf(stderr,"slope %d: %f %f %f %f\n",i,x[i].s.dir[0],x[i].s.dir[1],x[i].s.dir[2],x[i].s.len);
		}
	}
/*	if (which >= 0){
		fprintf(stderr,"%d %f %f %f %f\n",count,position[0],position[1],position[2],y_rot);
	}*/
}

@


11.17
log
@change conf.h to a wrapped config.h
@
text
@@


11.16
log
@merge of ansi-6-0-branch into HEAD
@
text
@d23 5
a27 1
#include "conf.h"
@


11.15
log
@update copyright to include span through 2003
@
text
@d124 1
a124 3
main(argc,argv)
int argc;
char **argv;
d126 2
a127 2
	void anim_y_p_r2mat(), anim_add_trans(), anim_mat_print();
	int get_args(), get_link(), track_prep(), val, frame, i, count;
d367 1
a367 3
int get_args(argc,argv)
int argc;
char **argv;
d371 1
a371 1
	void anim_dx_y_z2mat(), anim_dz_y_x2mat();
d507 1
a507 1
int track_prep()
d513 2
a514 2
	int getcurve();
	fastf_t hyper_get_s();
d616 1
a616 3
int get_link(pos,angle_p,dist)
fastf_t *angle_p, dist;
vect_t pos;
d620 1
a620 1
	fastf_t hyper_get_x(), hyper_get_z(), hyper_get_ang();
d649 1
a649 1
		pos[X] = hyper_get_x(curve_a, 0.0, s_start+dist);
d666 2
a667 2
void show_info(which)/* for debugging - -1:track 0:both 1:link*/
int which;
@


11.14
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d19 1
a19 1
 *      This software is Copyright (C) 1993 by the United States Army
@


11.14.4.1
log
@sync to HEAD...
@
text
@d19 1
a19 1
 *      This software is Copyright (C) 1993-2004 by the United States Army
@


11.14.10.1
log
@merge from HEAD
@
text
@d19 1
a19 1
 *      This software is Copyright (C) 1993-2004 by the United States Army
@


11.14.2.1
log
@Initial ANSIfication
@
text
@d124 3
a126 1
main(int argc, char **argv)
d128 2
a129 2
	void anim_y_p_r2mat(fastf_t *, double, double, double), anim_add_trans(fastf_t *, const fastf_t *, const fastf_t *), anim_mat_print(FILE *, const fastf_t *, int);
	int get_args(int argc, char **argv), get_link(fastf_t *pos, fastf_t *angle_p, fastf_t dist), track_prep(void), val, frame, i, count;
d369 3
a371 1
int get_args(int argc, char **argv)
d375 1
a375 1
	void anim_dx_y_z2mat(fastf_t *, double, double, double), anim_dz_y_x2mat(fastf_t *, double, double, double);
d511 1
a511 1
int track_prep(void)
d517 2
a518 2
	int getcurve(fastf_t *pa, fastf_t *pb, fastf_t *pc, fastf_t *pth0, fastf_t *pth1, fastf_t delta_s, fastf_t *p_zero, fastf_t *p_one, fastf_t r_zero, fastf_t r_one);
	fastf_t hyper_get_s(fastf_t a, fastf_t c, fastf_t x);
d620 3
a622 1
int get_link(fastf_t *pos, fastf_t *angle_p, fastf_t dist)
d626 1
a626 1
	fastf_t hyper_get_x(fastf_t a, fastf_t c, fastf_t s, int d, int x, int cos_ang), hyper_get_z(fastf_t a, fastf_t b, fastf_t c, fastf_t x), hyper_get_ang(fastf_t a, fastf_t c, fastf_t x);
d655 1
a655 1
		pos[X] = hyper_get_x(curve_a, 0.0, s_start+dist, 0, 0, 0);
d672 2
a673 2
void show_info(int which)/* for debugging - -1:track 0:both 1:link*/
          
@


11.14.2.2
log
@sync branch with HEAD
@
text
@d19 1
a19 1
 *      This software is Copyright (C) 1993-2004 by the United States Army
@


11.13
log
@Converted from K&R to ANSI C - RFH
@
text
@d124 3
a126 1
main(int argc, char **argv)
d128 2
a129 2
	void anim_y_p_r2mat(fastf_t *, double, double, double), anim_add_trans(fastf_t *, const fastf_t *, const fastf_t *), anim_mat_print(FILE *, const fastf_t *, int);
	int get_args(int argc, char **argv), get_link(fastf_t *pos, fastf_t *angle_p, fastf_t dist), track_prep(void), val, frame, i, count;
d369 3
a371 1
int get_args(int argc, char **argv)
d375 1
a375 1
	void anim_dx_y_z2mat(fastf_t *, double, double, double), anim_dz_y_x2mat(fastf_t *, double, double, double);
d511 1
a511 1
int track_prep(void)
d517 2
a518 2
	int getcurve(fastf_t *pa, fastf_t *pb, fastf_t *pc, fastf_t *pth0, fastf_t *pth1, fastf_t delta_s, fastf_t *p_zero, fastf_t *p_one, fastf_t r_zero, fastf_t r_one);
	fastf_t hyper_get_s(fastf_t a, fastf_t c, fastf_t x);
d620 3
a622 1
int get_link(fastf_t *pos, fastf_t *angle_p, fastf_t dist)
d626 1
a626 1
	fastf_t hyper_get_x(fastf_t a, fastf_t c, fastf_t s, int d, int x, int cos_ang), hyper_get_z(fastf_t a, fastf_t b, fastf_t c, fastf_t x), hyper_get_ang(fastf_t a, fastf_t c, fastf_t x);
d655 1
a655 1
		pos[X] = hyper_get_x(curve_a, 0.0, s_start+dist, 0, 0, 0);
d672 2
a673 2
void show_info(int which)/* for debugging - -1:track 0:both 1:link*/
          
@


11.12
log
@lint
@
text
@d124 1
a124 3
main(argc,argv)
int argc;
char **argv;
d126 2
a127 2
	void anim_y_p_r2mat(), anim_add_trans(), anim_mat_print();
	int get_args(), get_link(), track_prep(), val, frame, i, count;
d367 1
a367 3
int get_args(argc,argv)
int argc;
char **argv;
d371 1
a371 1
	void anim_dx_y_z2mat(), anim_dz_y_x2mat();
d507 1
a507 1
int track_prep()
d513 2
a514 2
	int getcurve();
	fastf_t hyper_get_s();
d616 1
a616 3
int get_link(pos,angle_p,dist)
fastf_t *angle_p, dist;
vect_t pos;
d620 1
a620 1
	fastf_t hyper_get_x(), hyper_get_z(), hyper_get_ang();
d649 1
a649 1
		pos[X] = hyper_get_x(curve_a, 0.0, s_start+dist);
d666 2
a667 2
void show_info(which)/* for debugging - -1:track 0:both 1:link*/
int which;
@


11.11
log
@Eliminated some unused variables
@
text
@d24 7
d123 1
d138 1
a138 1
	int rndtabi;
d170 1
a170 1
			fscanf(stream,"%*lf %*lf %*lf");
d175 1
a175 1
			fscanf(stream,"%*lf %*lf %*lf %*lf");
d364 1
@


11.10
log
@
Eliminated dependence on compat4.h
@
text
@d125 1
a125 1
	vect_t zero, position, vdelta, temp, to_track, to_front, norm;
d505 1
a505 1
	fastf_t phi, costheta, link_angle, hyper_start_x, arc_angle;
d507 1
a507 1
	vect_t start, difference, link_cent;
@


11.9
log
@Made dependence on bu_getopt() explicit.
@
text
@d225 1
a225 1
		RT_RANDSEED(rndtabi, 0);
d302 1
a302 1
				distance += RT_RANDOM(rndtabi) * 2.0* halfpadlen;
d320 1
a320 1
			        		mat_mul(wmat,m_axes,mat_x);
d337 2
a338 2
				        	mat_mul(mat_x,wmat,m_rev_axes);
			        		mat_mul(wmat,m_axes,mat_x);
@


11.8
log
@Mods for cahnge in caling sequence for anim_mat_print().
@
text
@d84 2
a85 2
extern int optind;
extern char *optarg;
d155 2
a156 2
	if (!(stream = fopen(*(argv+optind),"r"))){
		fprintf(stderr,"Track: Could not open file %s.\n",*(argv+optind));
d380 1
a380 1
        while ( (c=getopt(argc,argv,OPT_STR)) != EOF) {
d399 5
a403 5
                	optind -= 1;
                        sscanf(argv[optind+(i++)],"%lf", &yaw );
                        sscanf(argv[optind+(i++)],"%lf", &pch );
                        sscanf(argv[optind+(i++)],"%lf", &rll );
			optind += 3;
d409 5
a413 5
                        optind -= 1;
                        sscanf(argv[optind+(i++)],"%lf",centroid);
                        sscanf(argv[optind+(i++)],"%lf",centroid+1);
                        sscanf(argv[optind+(i++)],"%lf",centroid+2);
                        optind += 3;
d418 1
a418 1
                	sscanf(optarg,"%d",&first_frame);
d421 1
a421 1
                	sscanf(optarg,"%lf",&init_dist);
d424 1
a424 1
                	sscanf(optarg,"%lf",&radius);
d428 3
a430 3
                	sscanf(optarg,"%d", &num_links);
                	link_nindex = optind;
                	optind += 1;
d434 2
a435 2
                	wheel_nindex = optind - 1;
                	/*sscanf(optarg,"%s",wheel_name);*/
d439 1
a439 1
                	sscanf(optarg,"%d",&arced_frame);
d443 1
a443 1
                	switch (*optarg) {
d445 1
a445 1
                		strncpy(link_cmd,argv[optind], 10);
d448 1
a448 1
                		strncpy(wheel_cmd,argv[optind], 10);
d451 1
a451 1
                		fprintf(stderr,"Unknown option: -m%c\n",*optarg);
d454 1
a454 1
                	optind += 1;
d457 1
a457 1
                	switch (*optarg) {
d463 1
a463 1
	                	sscanf(argv[optind],"%lf",&first_tracklen);
d465 1
a465 1
	                	optind++;
d469 1
a469 1
	                	sscanf(argv[optind],"%lf",&first_tracklen);
d471 1
a471 1
	                	optind++;
d475 1
a475 1
	                	sscanf(argv[optind],"%lf",&first_tracklen);
d477 1
a477 1
	                	optind++;
d480 1
a480 1
                		fprintf(stderr,"Unknown option: -l%c\n",*optarg);
@


11.7
log
@removed "." from pad and wheel names
@
text
@d324 1
a324 1
			        		anim_mat_printf(wmat,"%.10g ","\n",";\n");
d327 1
a327 1
			        		anim_mat_printf(wmat,"%.10g ","","\n");
d342 1
a342 1
			        		anim_mat_printf(wmat,"%.10g ","\n",";\n");
d345 1
a345 1
			        		anim_mat_printf(wmat,"%.10g ","","\n");
@


11.6
log
@nit
@
text
@d323 1
a323 1
						printf("anim %s.%d matrix %s\n", *(argv+link_nindex),count,link_cmd);
d326 1
a326 1
			        		printf("arced %s.%d matrix %s ", *(argv+link_nindex),count,link_cmd);
d341 1
a341 1
						printf("anim %s.%d matrix %s\n",*(argv+wheel_nindex),count,wheel_cmd);
d344 1
a344 1
						printf("arced %s.%d matrix %s ",*(argv+wheel_nindex),count,wheel_cmd);
@


11.5
log
@changed -ml to -mp for consistency
@
text
@d235 1
a235 1
			if (val < 1)
d237 1
a237 1

@


11.4
log
@added -a anti-strobing option
@
text
@d444 1
a444 1
                	case 'l':
@


11.3
log
@major changes, combining anim_track and anim_hardtrack plus new features
@
text
@d29 1
d114 1
d130 2
d224 4
d229 1
a229 1
	distance = 0.0;
d297 9
d358 1
a358 1
#define OPT_STR "sycuvb:d:f:i:r:p:w:g:m:l:"
d378 1
d483 3
@


11.2
log
@updated anim.c routine names
@
text
@d41 1
d43 8
d88 1
d94 2
a95 1
char wheel_name[40];	/* base name of wheels */
d97 3
d101 1
a101 3
int  stretch;		/* flag: increase track length if needed */
int  elastic;		/* flag: increase track, but snap back to original size when possible */
int dist_mode;		/* 0 - distance is given; 1 - calculate distance */
d104 1
d108 5
d120 1
d123 1
a123 1
	vect_t zero, position, vdelta, temp, to_track, to_front;
d127 1
d133 3
a135 2
	radius = y_rot = init_dist = 0.0;
	first_frame = num_wheels = axes = cent = 0;
d151 2
a152 2
	if (!(stream = fopen(*(argv+optind+1),"r"))){
		fprintf(stderr,"Track: Could not open file %s.\n",*(argv+optind+1));
d155 14
a168 2
	fscanf(stream,"%d %d %lf %lf", &num_wheels, &num_links, &tracklen, &track_y);
	first_tracklen = tracklen;
d170 1
a170 1
		/*allocate memory for track information*/
d178 3
a180 3
		fscanf(stream,"%lf %lf",wh[i].pos,wh[i].pos+2);
		if (radius)
			wh[i].rad = radius;
d182 7
a188 2
			fscanf(stream,"%lf",&wh[i].rad);
		wh[i].pos[1] = track_y;
d190 4
a193 4
		x[i].w.pos[0] = wh[i].pos[0];
		x[i].w.pos[1] = wh[i].pos[1];
		x[i].w.pos[2] = wh[i].pos[2];
		x[i].w.rad = wh[i].rad;
d201 19
d221 1
a221 1
	distance = init_dist;
d223 6
a228 1
	for (val = 2; val > 1; frame++) {
a229 3
		scanf("%*f");/*time*/
		if (dist_mode==GIVEN){
			scanf("%lf",&distance);
d232 8
a239 2
			scanf("%lf %lf %lf", cent_pos, cent_pos+1, cent_pos + 2);/* tank position*/
			scanf("%lf %lf %lf",&yaw,&pch,&roll);/* tank orientation*/
d242 8
a249 4
		/* read in all wheel positions */
		for(i=0;i<NW;i++){
			val=scanf("%lf %lf",x[i].w.pos, x[i].w.pos + 2);
			if (val < 2) break;
a250 1
		if (val < 2) break;
d252 13
a264 1

d266 8
a273 3
		if ((track_prep())==-1){
			fprintf(stderr,"Track: error in frame %d: track too short.\n",frame);
			break;
d277 3
a279 3
		if (dist_mode==CALCULATED){ /*determine distance traveled*/
			anim_dy_p_r2mat(mat_x,yaw,pch,roll);
			anim_add_trans(mat_x,cent_pos,rcentroid);			
d289 42
a330 23
		printf("start %d;\nclean;\n", frame);
	        for (count=0;count<num_links;count++){
        	        (void) get_link(position,&y_rot,distance+tracklen*count/num_links);
			anim_y_p_r2mat(wmat,0.0,y_rot,0.0);
	        	anim_add_trans(wmat,position,zero);
	        	if (axes || cent){ /* link moved to vehicle coords */
	        		MAT_MOVE(mat_x,wmat);
	        		mat_mul(wmat,m_axes,mat_x);
	        	}
			printf("anim %s.%d matrix lmul\n", *(argv+optind),count);
	        	anim_mat_print(wmat,1);
		}
		if (print_wheel){
			for (count = 0;count<num_wheels;count++){
				anim_y_p_r2mat(wmat,0.0,-distance/wh[count].rad,0.0);
				VREVERSE(temp,wh[count].pos);
				anim_add_trans(wmat,x[count].w.pos,temp);
		        	if (axes || cent){
			        	mat_mul(mat_x,wmat,m_rev_axes);
		        		mat_mul(wmat,m_axes,mat_x);
		        	}
				printf("anim %s.%d matrix lmul\n",wheel_name,count);
				anim_mat_print(wmat,1);
d332 2
d335 1
a335 1
		printf("end;\n");
d341 1
a341 1
#define OPT_STR "b:d:cf:i:r:w:se"
d347 1
d350 9
a358 3
	int c, i;
	axes = cent = print_wheel = 0;
	stretch = elastic= 0;
d360 2
d365 15
a398 3
                case 'c':
                	dist_mode = CALCULATED;
                	break;
d407 1
d409 6
d416 2
a417 1
                	sscanf(optarg,"%s",wheel_name);
d420 17
a436 2
                case 's':
                	stretch = 1;
d438 27
a464 2
                case 'e':
                	elastic = 1;
d540 7
a546 2
	/* calculate geometry of hyperbolic segment */
	if(elastic){ /* restore track to original size */
d549 2
d553 1
a553 1
		if(stretch||elastic){
@


11.1
log
@Release_4.4
@
text
@d100 1
a100 1
	void y_p_r2mat(), add_trans(), an_mat_print();
d124 2
a125 2
		add_trans(m_axes,centroid,zero);
		add_trans(m_rev_axes,zero,rcentroid);
d193 2
a194 2
			dy_p_r2mat(mat_x,yaw,pch,roll);
			add_trans(mat_x,cent_pos,rcentroid);			
d207 2
a208 2
			y_p_r2mat(wmat,0.0,y_rot,0.0);
	        	add_trans(wmat,position,zero);
d214 1
a214 1
	        	an_mat_print(wmat,1);
d218 1
a218 1
				y_p_r2mat(wmat,0.0,-distance/wh[count].rad,0.0);
d220 1
a220 1
				add_trans(wmat,x[count].w.pos,temp);
d226 1
a226 1
				an_mat_print(wmat,1);
d242 1
a242 1
	void dx_y_z2mat(), dz_y_x2mat();
d256 2
a257 2
			dx_y_z2mat(m_axes, rll, -pch, yaw);
			dz_y_x2mat(m_rev_axes, -rll, pch, -yaw);
@


1.4
log
@DEC Alpha portability
@
text
@@


1.3
log
@changed calls to cfree() to calls to free()
@
text
@d27 1
a101 1
	char *calloc();
@


1.2
log
@included conf.h
@
text
@d231 2
a232 2
	cfree(x);
	cfree(wh);
@


1.1
log
@Initial revision
@
text
@d23 1
@
