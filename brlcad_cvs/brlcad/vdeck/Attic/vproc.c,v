head	11.5;
access;
symbols
	ansi-20040405-merged:11.4
	postmerge-20040405-ansi:11.4
	premerge-20040404-ansi:11.4
	postmerge-autoconf:11.4
	autoconf-freeze:11.4
	premerge-autoconf:11.4
	postmerge-20040315-windows:11.4
	premerge-20040315-windows:11.4
	windows-20040315-freeze:11.4
	autoconf-20031203:11.4
	autoconf-20031202:11.4
	autoconf-branch:11.4.0.12
	phong-branch:11.4.0.10
	photonmap-branch:11.4.0.8
	rel-6-1-DP:11.4
	windows-branch:11.4.0.6
	rel-6-0-2:11.4
	ansi-branch:11.4.0.4
	rel-6-0-1-branch:11.4.0.2
	hartley-6-0-post:11.4
	hartley-6-0-pre:11.4
	rel-6-0-1:11.4
	rel-6-0:11.4
	rel-5-4:11.1
	offsite-5-3-pre:11.2
	rel-5-3:11.1
	rel-5-2:11.1
	rel-5-1-branch:11.1.0.2
	rel-5-1:11.1
	rel-5-0:11.1
	rel-5-0-beta:11.1
	rel-4-5:11.1
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:9.6
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:5.1
	rel-1-24:5.1
	rel-1-20:4.2
	rel-1-10:4.1;
locks; strict;
comment	@ * @;


11.5
date	2004.05.21.13.49.18;	author morrison;	state dead;
branches;
next	11.4;

11.4
date	2001.08.10.18.45.16;	author jra;	state Exp;
branches;
next	11.3;

11.3
date	2001.04.02.21.38.39;	author morrison;	state Exp;
branches;
next	11.2;

11.2
date	2000.08.24.22.56.19;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.18.40;	author mike;	state Rel4_4;
branches;
next	9.6;

9.6
date	91.06.13.05.57.28;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	91.06.13.05.25.05;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	91.06.13.05.24.10;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	91.06.01.22.46.53;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	91.06.01.00.52.21;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.14.16;	author mike;	state Rel3_5;
branches;
next	8.1;

8.1
date	88.10.05.00.53.12;	author mike;	state Rel3_0;
branches;
next	7.1;

7.1
date	87.11.03.00.28.20;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.08.17.19;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.49.15;	author mike;	state Rel;
branches;
next	4.4;

4.4
date	87.03.30.09.16.01;	author moss;	state Exp;
branches;
next	4.3;

4.3
date	87.02.24.16.30.21;	author moss;	state Exp;
branches;
next	4.2;

4.2
date	87.02.13.00.55.30;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.02.53.28;	author mike;	state Rel1;
branches;
next	2.8;

2.8
date	86.08.13.09.21.40;	author mike;	state Exp;
branches;
next	2.7;

2.7
date	86.08.13.08.27.08;	author mike;	state Exp;
branches;
next	2.6;

2.6
date	86.08.13.08.26.45;	author mike;	state Exp;
branches
	2.6.1.1;
next	2.5;

2.5
date	86.08.13.08.26.20;	author mike;	state Exp;
branches;
next	2.4;

2.4
date	86.08.13.08.25.57;	author mike;	state Exp;
branches;
next	2.3;

2.3
date	86.08.13.08.25.39;	author mike;	state Exp;
branches;
next	2.2;

2.2
date	86.08.13.08.25.24;	author mike;	state Exp;
branches;
next	2.1;

2.1
date	86.08.13.08.25.11;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	86.08.13.08.24.56;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	86.08.13.08.24.40;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	86.08.13.08.24.22;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	86.08.13.08.24.05;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	86.08.13.08.23.51;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	86.08.13.08.23.34;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	86.08.13.08.23.19;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	86.08.13.08.23.01;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	86.08.13.08.22.42;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	86.08.13.08.22.33;	author mike;	state Exp;
branches;
next	;

2.6.1.1
date	86.08.13.09.19.08;	author mike;	state Exp;
branches;
next	;


desc
@@


11.5
log
@moved to src/vdeck/
@
text
@/*
	Author:		Gary S. Moss
			U. S. Army Ballistic Research Laboratory
			Aberdeen Proving Ground
			Maryland 21005-5066
			(301)278-6647 or AV-298-6647
*/
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/vdeck/vproc.c,v 11.4 2001/08/10 18:45:16 jra Exp $ (BRL)";
#endif
/*
	Procedures for vproc.c

	Section 1:  Commands
		3:  List Processing Routines
		4:  String Processing Routines
		5:  Input/Output Routines
		6:  Interrupt Handlers
	  
 */
#include <stdio.h>
#include <signal.h>
#include <math.h>
#include <setjmp.h>

#include "machine.h"
#include "vmath.h"
#include "rtstring.h"
#include "raytrace.h"
#include "./vextern.h"

#include "./std.h"

extern void	ewrite();


char		getarg();
void		quit(), abort_sig();
void		blank_fill();

/*
	Section 1:	C O M M A N D S

			deck()
			shell()
 */

/*	d e c k ( )
	make a COMGEOM deck for current list of objects

 */
deck( prefix )
register char *prefix;
{	
	register int	i;

	nns = nnr = 0;

	/* Create file for solid table.					*/
	if( prefix != 0 )
	{
		(void) strncpy( st_file, prefix, 73 );
		(void) strcat( st_file, ".st" );
	}
	else
		(void) strncpy( st_file, "solids", 7 );
	if( (solfd = creat( st_file, 0644 )) < 0 )
	{
		perror( st_file );
		exit( 10 );
	}


	/* Target units (a2,3x)						*/
	ewrite( solfd, rt_units_string(dbip->dbi_local2base), 2 );
	blank_fill( solfd, 3 );

	/* Title							*/
	if( dbip->dbi_title == NULL )
		ewrite( solfd, objfile, (unsigned) strlen( objfile ) );
	else
		ewrite( solfd, dbip->dbi_title, (unsigned) strlen( dbip->dbi_title ) );
	ewrite( solfd, LF, 1 );

	/* Save space for number of solids and regions.			*/
	savsol = lseek( solfd, 0L, 1 );
	blank_fill( solfd, 10 );
	ewrite( solfd, LF, 1 );

	/* Create file for region table.				*/
	if( prefix != 0 )
	{
		(void) strncpy( rt_file, prefix, 73 );
		(void) strcat( rt_file, ".rt" );
	}
	else
		(void) strncpy( rt_file, "regions", 8 );
	if( (regfd = creat( rt_file, 0644 )) < 0 )
	{
		perror( rt_file );
		exit( 10 );
	}

	/* create file for region ident table
	 */
	if( prefix != 0 )
	{
		(void) strncpy( id_file, prefix, 73 );
		(void) strcat( id_file, ".id" );
	}
	else
		(void) strncpy( id_file, "region_ids", 11 );
	if( (ridfd = creat( id_file, 0644 )) < 0 )
	{
		perror( id_file );
		exit( 10 );
	}
	itoa( -1, buff, 5 );
	ewrite( ridfd, buff, 5 );
	ewrite( ridfd, LF, 1 );

	/* Initialize matrices.						*/
	MAT_IDN( identity );

	/* Check integrity of list against directory and build card deck.	*/
	for( i = 0; i < curr_ct; i++ )
	{	
		struct directory	*dirp;
		if( (dirp = db_lookup( dbip, curr_list[i], LOOKUP_NOISY )) != DIR_NULL )  {
#if 1
			treewalk( curr_list[i] );
#else
			cgobj( dirp, 0, identity );
#endif
		}
	}
	/* Add number of solids and regions on second card.		*/
	(void) lseek( solfd, savsol, 0 );
	itoa( nns, buff, 5 );
	ewrite( solfd, buff, 5 );
	itoa( nnr, buff, 5 );
	ewrite( solfd, buff, 5 );

	/* Finish region id table.					*/
	ewrite( ridfd, LF, 1 );

	(void) printf( "====================================================\n" );
	(void) printf( "O U T P U T    F I L E S :\n\n" );
	(void) printf( "solid table = \"%s\"\n", st_file );
	(void) printf( "region table = \"%s\"\n", rt_file );
	(void) printf( "region identification table = \"%s\"\n", id_file );
	(void) close( solfd );
	(void) close( regfd );
	(void) close( ridfd );

	/* reset starting numbers for solids and regions
	 */
	delsol = delreg = 0;
	/* XXX should free soltab list */
}

/*	s h e l l ( )
	Execute shell command.
 */
int
shell( args )
char  *args[];
{
	register char	*from, *to;
	char		*argv[4], cmdbuf[MAXLN];
	int		pid, ret, status;
	register int	i;

	(void) signal( SIGINT, SIG_IGN );

	/* Build arg vector.						*/
	argv[0] = "Shell( deck )";
	argv[1] = "-c";
	to = argv[2] = cmdbuf;
	for( i = 1; i < arg_ct; i++ ) {
		from = args[i];
		if( (to + strlen( args[i] )) - argv[2] > MAXLN - 1 ) {
			(void) fprintf( stderr, "\ncommand line too long\n" );
			exit( 10 );
		}
		(void) printf( "%s ", args[i] );
		while( *from )
			*to++ = *from++;
		*to++ = ' ';
	}
	to[-1] = '\0';
	(void) printf( "\n" );
	argv[3] = 0;
	if( (pid = fork()) == -1 ) {
		perror( "shell()" );
		return( -1 );
	} else	if( pid == 0 ) { /*
				  * CHILD process - execs a shell command
					  */
		(void) signal( SIGINT, SIG_DFL );
		(void) execv( "/bin/sh", argv );
		perror( "/bin/sh -c" );
		exit( 99 );
	} else	/*
		 * PARENT process - waits for shell command
		 * to finish.
			 */
		do {
			if( (ret = wait( &status )) == -1 ) {
				perror( "wait( /bin/sh -c )" );
				break;
			}
		} while( ret != pid );
	return( 0 );
}

/*	t o c ( )
	Build a sorted list of names of all the objects accessable
	in the object file.
 */
void
toc()
{
	register struct directory *dp;
	register int		i;

	(void) printf( "Making the Table of Contents.\n" );
	(void) fflush( stdout );

	for( i = 0; i < RT_DBNHASH; i++ )  {
		for( dp = dbip->dbi_Head[i]; dp != DIR_NULL; dp=dp->d_forw )  {
			toc_list[ndir++] = dp->d_namep;
		}
	}
}

/*
	Section 3:	L I S T   P R O C E S S I N G   R O U T I N E S

			list_toc()
			col_prt()
			insert()
			delete()
*/

/*	l i s t _ t o c ( )
	List the table of contents.
 */
void
list_toc( args )
char	 *args[];
{	
	register int	i, j;
	(void) fflush( stdout );
	for( tmp_ct = 0, i = 1; args[i] != NULL; i++ )
	{
		for( j = 0; j < ndir; j++ )
		{
			if( match( args[i], toc_list[j] ) )
				tmp_list[tmp_ct++] = toc_list[j];
		}
	}
	if( i > 1 )
		(void) col_prt( tmp_list, tmp_ct );
	else
		(void) col_prt( toc_list, ndir );
	return;
}

#define NAMESIZE	16
#define MAX_COL	(NAMESIZE*5)
#define SEND_LN()	{\
			buf[column++] = '\n';\
			ewrite( 1, buf, (unsigned) column );\
			column = 0;\
			}

/*	c o l _ p r t ( )
	Print list of names in tabular columns.
 */
col_prt( list, ct )
register char	*list[];
register int	ct;
{	
	char		buf[MAX_COL+2];
	register int	i, column, spaces;

	for( i = 0, column = 0; i < ct; i++ )
	{
		if( column + strlen( list[i] ) > MAX_COL )
		{
			SEND_LN();
			i--;
		}
		else
		{
			(void) strcpy( &buf[column], list[i] );
			column += strlen( list[i] );
			spaces = NAMESIZE - (column % NAMESIZE );
			if( column + spaces < MAX_COL )
				for( ; spaces > 0; spaces-- )
					buf[column++] = ' ';
			else
				SEND_LN();
		}
	}
	SEND_LN();
	return	ct;
}

/*	i n s e r t ( )
	Insert each member of the table of contents 'toc_list' which
	matches one of the arguments into the current list 'curr_list'.
 */
int
insert(  args,	ct )
char		*args[];
register int	ct;
{	
	register int	i, j, nomatch;

	/* For each argument (does not include args[0]).			*/
	for( i = 1; i < ct; i++ )
	{ /* If object is in table of contents, insert in current list.	*/
		nomatch = YES;
		for( j = 0; j < ndir; j++ )
		{
			if( match( args[i], toc_list[j] ) )
			{
				nomatch = NO;
				/* Allocate storage for string.			*/
				curr_list[curr_ct++] = rt_strdup(toc_list[j]);
			}
		}
		if( nomatch )
			(void) fprintf( stderr,
			    "Object \"%s\" not found.\n", args[i] );
	}
	return	curr_ct;
}

/*	d e l e t e ( )
	delete all members of current list 'curr_list' which match
	one of the arguments
 */
int
delete(  args )
char	*args[];
{
	register int	i;
	register int	nomatch;

	/* for each object in arg list
	 */
	for( i = 1; i < arg_ct; i++ ) { 
		register int	j;
		nomatch = YES;

		/* traverse list to find string
		 */
		for( j = 0; j < curr_ct; )
			if( match( args[i], curr_list[j] ) )
			{	
				register int	k;

				nomatch = NO;
				rt_free( curr_list[j], "curr_list" );
				--curr_ct;
				/* starting from bottom of list,
				 * pull all entries up to fill up space
				 made by deletion
				 */
				for( k = j; k < curr_ct; k++ )
					curr_list[k] = curr_list[k+1];
			} 
			else	++j;
		if( nomatch )
			(void) fprintf( stderr,
			    "Object \"%s\" not found.\n",
			    args[i]
			    );
	}
	return( curr_ct );
}

/*
	Section 4:	S T R I N G   P R O C E S S I N G   R O U T I N E S

			itoa()
			check()
 */

/*	i t o a ( )
	Convert integer to ascii  wd format.
 */
itoa( n, s, w )
register
char	*s;
register
int   n,    w;
{
	int	 c, i, j, sign;

	if( (sign = n) < 0 )	n = -n;
	i = 0;
	do	
		s[i++] = n % 10 + '0';	
	while( (n /= 10) > 0 );
	if( sign < 0 )	s[i++] = '-';

	/* Blank fill array.					*/
	for( j = i; j < w; j++ )	s[j] = ' ';
	if( i > w ) {
		s[w-1] = (s[w]-1-'0')*10 + (s[w-1]-'0')  + 'A';
	}
	s[w] = '\0';

	/* Reverse the array.					*/
	for( i = 0, j = w - 1; i < j; i++, j-- ) {
		c    = s[i];
		s[i] = s[j];
		s[j] =    c;
	}
}

vls_blanks( v, n )
struct rt_vls	*v;
int		n;
{
	RT_VLS_CHECK(v);
	rt_vls_strncat( v, "                                                                                                                                ",
	    n);
}

/*
 *			V L S _ I T O A
 *
 *	Convert integer to ascii  wd format.
 */
vls_itoa( v, n, w )
struct rt_vls	*v;
register int	n;
register int	w;
{
	int	 c, i, j, sign;
	register char	*s;

	RT_VLS_CHECK(v);
	rt_vls_strncat( v, "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx", w);
	s = rt_vls_addr(v)+rt_vls_strlen(v)-w;

	if( (sign = n) < 0 )	n = -n;
	i = 0;
	do	
		s[i++] = n % 10 + '0';	
	while( (n /= 10) > 0 );
	if( sign < 0 )	s[i++] = '-';

	/* Blank fill array.					*/
	for( j = i; j < w; j++ )	s[j] = ' ';
	if( i > w ) {
		s[w-1] = (s[w]-1-'0')*10 + (s[w-1]-'0')  + 'A';
	}
	s[w] = '\0';

	/* Reverse the array.					*/
	for( i = 0, j = w - 1; i < j; i++, j-- ) {
		c    = s[i];
		s[i] = s[j];
		s[j] =    c;
	}
}

vls_ftoa_vec_cvt( v, vec, w, d )
struct rt_vls	*v;
vect_t		vec;
int		w;
int		d;
{
	vls_ftoa( v, vec[X]*dbip->dbi_base2local, w, d );
	vls_ftoa( v, vec[Y]*dbip->dbi_base2local, w, d );
	vls_ftoa( v, vec[Z]*dbip->dbi_base2local, w, d );
}

vls_ftoa_vec( v, vec, w, d )
struct rt_vls	*v;
vect_t		vec;
int		w;
int		d;
{
	vls_ftoa( v, vec[X], w, d );
	vls_ftoa( v, vec[Y], w, d );
	vls_ftoa( v, vec[Z], w, d );
}

vls_ftoa_cvt( v, f, w, d )
struct rt_vls	*v;
register double	f;
register int	w, d;
{
	vls_ftoa( v, f*dbip->dbi_base2local, w, d );
}

/*
 *			V L S _ F T O A
 *
 *	Convert float to ascii  w.df format.
 */
vls_ftoa( v, f, w, d )
struct rt_vls	*v;
register double	f;
register int	w, d;
{
	register char	*s;
	register int	c, i, j;
	long	n, sign;

	RT_VLS_CHECK(v);
	rt_vls_strncat( v, "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx", w);
	s = rt_vls_addr(v)+rt_vls_strlen(v)-w;

	if( w <= d + 2 )
	{
		(void) fprintf( stderr,
		    "ftoascii: incorrect format  need w.df  stop"
		    );
		exit( 10 );
	}
	for( i = 1; i <= d; i++ )
		f = f * 10.0;

	/* round up */
	if( f < 0.0 )
		f -= 0.5;
	else
		f += 0.5;
	n = f;
	if( (sign = n) < 0 )
		n = -n;
	i = 0;
	do	{
		s[i++] = n % 10 + '0';
		if( i == d )
			s[i++] = '.';
	}	while( (n /= 10) > 0 );

	/* Zero fill the d field if necessary.				*/
	if( i < d )
	{
		for( j = i; j < d; j++ )
			s[j] = '0';
		s[j++] = '.';
		i = j;
	}
	if( sign < 0 )
		s[i++] = '-';

	/* Blank fill rest of field.					*/
	for ( j = i; j < w; j++ )
		s[j] = ' ';
	if( i > w )
		(void) fprintf( stderr, "Ftoascii: field length too small\n" );
	s[w] = '\0';

	/* Reverse the array.						*/
	for( i = 0, j = w - 1; i < j; i++, j-- )
	{
		c    = s[i];
		s[i] = s[j];
		s[j] =    c;
	}
}

/*
	Section 5:	I / O   R O U T I N E S
 *
			getcmd()
			getarg()
			menu()
			blank_fill()
			bug()
			fbug()
 */

/*	g e t c m d ( )
	Return first character read from keyboard,
	copy command into args[0] and arguments into args[1]...args[n].
		
 */
char
getcmd( args, ct )
char		*args[];
register int	ct;
{
	/* Get arguments.						 */
	if( ct == 0 )
		while( --arg_ct >= 0 )
			rt_free( args[arg_ct], "args[arg_ct]" );
	for( arg_ct = ct; arg_ct < MAXARG - 1; ++arg_ct )
	{
		args[arg_ct] = rt_malloc( MAXLN, "getcmd buffer" );
		if( ! getarg( args[arg_ct] ) )
			break;
	}
	++arg_ct;
	args[arg_ct] = 0;

	/* Before returning to command interpreter,
	 * set up interrupt handler for commands...
	 * trap interrupts such that command is aborted cleanly and
	 * command line is restored rather than terminating program
	 */
	(void) signal( SIGINT, abort_sig );
	return	(args[0])[0];
}

/*	g e t a r g ( )
	Get a word of input into 'str',
	Return 0 if newline is encountered.
 	Return 1 otherwise.
 */
char
getarg( str )
register char	*str;
{
	do
	{
		*str = getchar();
		if( (int)(*str) == ' ' )
		{
			*str = '\0';
			return( 1 );
		}
		else
			++str;
	}	while( (int)(str[-1]) != EOF && (int)(str[-1]) != '\n' );
	if( (int)(str[-1]) == '\n' )
		--str;
	*str = '\0';
	return	0;
}

/*	m e n u ( )
	Display menu stored at address 'addr'.
 */
void
menu( addr )
char **addr;
{	
	register char	**sbuf = addr;
	while( *sbuf )
		(void) printf( "%s\n", *sbuf++ );
	(void) fflush( stdout );
	return;
}

/*	b l a n k _ f i l l ( )
	Write count blanks to fildes.
 */
void
blank_fill( fildes, count )
register int	fildes,	count;
{	
	register char	*blank_buf = BLANKS;
	ewrite( fildes, blank_buf, (unsigned) count );
	return;
}

/*
	Section 6:	I N T E R R U P T   H A N D L E R S
 *
			abort_sig()
			quit()
 */

/*	a b o r t ( )
	Abort command without terminating run (restore command prompt) and
	cleanup temporary files.
 */
/*ARGSUSED*/
void
abort_sig( sig )
{
	(void) signal( SIGINT, quit );	/* reset trap */

	/* goto command interpreter with environment restored.		*/
	longjmp( env, sig );
}

/*	q u i t ( )
	Terminate run.
 */
/*ARGSUSED*/
void
quit( sig )
{
	(void) fprintf( stdout, "quitting...\n" );
	exit( 0 );
}
@


11.4
log
@lint
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/vdeck/vproc.c,v 11.3 2001/04/02 21:38:39 morrison Exp $ (BRL)";
@


11.3
log
@Deprecated bn_mat_copy() for new performance version of MAT_COPY() macro in h/vmath.h.
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/vdeck/vproc.c,v 11.2 2000/08/24 22:56:19 mike Exp $ (BRL)";
d165 1
d315 1
d346 1
@


11.2
log
@
RCSid
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/vdeck/vproc.c,v 11.1 1995/01/04 10:18:40 mike Rel4_4 $ (BRL)";
d123 1
a123 1
	mat_idn( identity );
@


11.1
log
@Release_4.4
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/vdeck/RCS/vproc.c,v 9.6 91/06/13 05:57:28 mike Exp Locker: mike $ (BRL)";
@


9.6
log
@Trimmed out excess
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/vdeck/RCS/vproc.c,v 9.5 91/06/13 05:25:05 mike Exp $ (BRL)";
@


9.5
log
@CB
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/vdeck/RCS/vproc.c,v 9.4 91/06/13 05:24:10 mike Exp $ (BRL)";
d55 1
a55 1
	register int	i, j;
a123 1
	mat_idn( xform );
a223 1
	register char		*flags;
a318 1
	unsigned	bytect;
a386 1
			ftoascii()
a416 63
		c    = s[i];
		s[i] = s[j];
		s[j] =    c;
	}
}

/*	f t o a s c i i ( )
	Convert float to ascii  w.df format.
 */
ftoascii( f, s, w, d )
register char	   *s;
register int	w, d;
float	  	f;
{	
	register int	c, i, j;
	long	n, sign;

	if( w <= d + 2 )
	{
		(void) fprintf( stderr,
		    "ftoascii: incorrect format  need w.df  stop"
		    );
		exit( 10 );
	}
	for( i = 1; i <= d; i++ )
		f = f * 10.0;

	/* round up */
	if( f < 0.0 )
		f -= 0.5;
	else
		f += 0.5;
	n = f;
	if( (sign = n) < 0 )
		n = -n;
	i = 0;
	do	{
		s[i++] = n % 10 + '0';
		if( i == d )
			s[i++] = '.';
	}	while( (n /= 10) > 0 );

	/* Zero fill the d field if necessary.				*/
	if( i < d )
	{
		for( j = i; j < d; j++ )
			s[j] = '0';
		s[j++] = '.';
		i = j;
	}
	if( sign < 0 )
		s[i++] = '-';

	/* Blank fill rest of field.					*/
	for ( j = i; j < w; j++ )
		s[j] = ' ';
	if( i > w )
		(void) fprintf( stderr, "Ftoascii: field length too small\n" );
	s[w] = '\0';

	/* Reverse the array.						*/
	for( i = 0, j = w - 1; i < j; i++, j-- )
	{
@


9.4
log
@Now handles units conversion
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/vdeck/RCS/vproc.c,v 9.3 91/06/01 22:46:53 mike Exp $ (BRL)";
d54 3
a56 2
	{	register int	i, j;
	
d58 1
a58 1
	
d61 1
a61 1
		{
d64 1
a64 1
		}
d68 1
a68 1
		{
d71 1
a71 1
		}
d92 1
a92 1
		{
d95 1
a95 1
		}
d99 1
a99 1
		{
d102 1
a102 1
		}
d107 1
a107 1
		{
d110 1
a110 1
		}
d114 1
a114 1
		{
d117 1
a117 1
		}
d128 2
a129 1
		{	struct directory	*dirp;
d137 1
a137 1
		}
d161 1
a161 1
	}
d199 1
a199 1
				  */
d207 1
a207 1
		 */
d253 2
a254 1
	{	register int	i, j;
d257 2
a259 2
		for( j = 0; j < ndir; j++ )
			{
a261 1
			}
d263 1
d269 1
a269 1
	}
d285 3
a287 2
	{	char		buf[MAX_COL+2];
		register int	i, column, spaces;
d290 2
a292 2
		if( column + strlen( list[i] ) > MAX_COL )
			{
d295 1
a295 1
			}
d297 1
a297 1
			{
a305 1
			}
d307 1
d310 1
a310 1
	}
d319 3
a321 2
	{	register int	i, j, nomatch;
		unsigned	bytect;
d325 1
a325 1
		{ /* If object is in table of contents, insert in current list.	*/
d328 2
a330 2
			if( match( args[i], toc_list[j] ) )
				{
a333 1
				}
d335 1
d338 2
a339 2
				"Object \"%s\" not found.\n", args[i] );
		}
d341 1
a341 1
	}
d352 1
a352 1
	
d355 2
a356 1
	for( i = 1; i < arg_ct; i++ ) { register int	j;
d363 2
a364 1
			{	register int	k;			
d375 2
a376 1
			} else	++j;
d379 3
a381 3
					"Object \"%s\" not found.\n",
					args[i]
					);
d407 3
a409 1
	do	s[i++] = n % 10 + '0';	while( (n /= 10) > 0 );
d434 3
a436 2
	{	register int	c, i, j;
		long	n, sign;
d439 1
a439 1
		{
d441 2
a442 2
				"ftoascii: incorrect format  need w.df  stop"
				);
d444 1
a444 1
		}
d461 1
a461 2
		}
	while( (n /= 10) > 0 );
d465 1
a465 1
		{	
d470 1
a470 1
		}
d473 1
a473 1
	
d483 1
a483 1
		{
a486 1
		}
d488 1
d495 2
a496 1
	rt_vls_strncat( v, "                                                                                                                                ", n);
d518 3
a520 1
	do	s[i++] = n % 10 + '0';	while( (n /= 10) > 0 );
d587 1
a587 1
		{
d589 2
a590 2
				"ftoascii: incorrect format  need w.df  stop"
				);
d592 1
a592 1
		}
d609 1
a609 2
		}
	while( (n /= 10) > 0 );
d613 1
a613 1
		{	
d618 1
a618 1
		}
d621 1
a621 1
	
d631 1
a631 1
		{
d635 1
a635 1
		}
d658 1
a658 1
	{
d664 1
a664 1
		{
d668 1
a668 1
		}
d679 1
a679 1
	}
d689 2
a691 2
	do
		{
d694 1
a694 1
			{
d697 1
a697 1
			}
d700 1
a700 2
		}
	while( (int)(str[-1]) != EOF && (int)(str[-1]) != '\n' );
d705 1
a705 1
	}
d713 2
a714 1
	{	register char	**sbuf = addr;
d719 1
a719 1
	}
d727 2
a728 1
	{	register char	*blank_buf = BLANKS;
d731 1
a731 1
	}
d747 1
a747 1
	{
d752 1
a752 1
	}
d760 1
a760 1
	{
d763 1
a763 1
	}
@


9.3
log
@Moved #includes out of vextern.h into individual .c files
Trimmed out some unused variables.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/vdeck/RCS/vproc.c,v 9.2 91/06/01 00:52:21 mike Exp $ (BRL)";
d34 1
a34 1
extern void	eread(), ewrite();
d72 1
d74 1
a74 1
	ewrite( solfd, "mm", 2 );	/* XXX Need units here */
d531 3
a533 3
	vls_ftoa( v, vec[X]*unit_conversion, w, d );
	vls_ftoa( v, vec[Y]*unit_conversion, w, d );
	vls_ftoa( v, vec[Z]*unit_conversion, w, d );
d552 1
a552 1
	vls_ftoa( v, f*unit_conversion, w, d );
@


9.2
log
@Modernization beings
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/vdeck/RCS/vproc.c,v 9.1 89/05/19 06:14:16 mike Rel3_5 $ (BRL)";
d23 2
d26 2
a27 2

#include "./vextern.h"
d30 1
d56 1
a56 1
	nns = nnr = regflag = numrr = 0;
a57 3
	/* Rewind object file.						*/
	(void) lseek( objfd, 0L, 0 );

a119 18
	/* Create /tmp file for discrimination of files.		*/
	(void) strncpy( disc_file, mktemp( "/tmp/disXXXXXX" ), 15 );
	if( (idfd = creat( disc_file, 0644 )) < 0 )
		{
		perror( disc_file );
		exit( 10 );
		}
	rd_idfd = open( disc_file, 2 );

	/* Create /tmp file for storage of region names in the comgeom desc.	*/
	(void) strncpy( reg_file, mktemp( "/tmp/regXXXXXX" ), 15 );
	if( (rrfd = creat( reg_file, 0644 )) < 0 )
		{
		perror( reg_file );
		exit( 10 );
		}
	rd_rrfd = open( reg_file, 2 );

a144 30
 	/* Must go back and add regions as members of regions.		*/
	if( numrr > 0 )
		{
		for( i = 1; i <= numrr; i++ )
			{
			(void) lseek( rd_rrfd, 0L, 0 );   /* rewind */
			for( j = 1; j <= nnr; j++ )
				{
				/* Next region name in desc.		 */
				eread( rd_rrfd, name, NAMESIZE );
				if( strcmp( findrr[i].rr_name, name ) == 0 )
					{ /* Region number in desc is j add
						to regfd at rrpos[i]	*/
					(void) lseek( regfd, findrr[i].rr_pos, 0);
					itoa( j+delreg, buff, 4 );
					ewrite( regfd, buff, 4 );
					break;
					}
				}
			if( j > nnr )
				{
				(void) fprintf( stderr,
					"Region %s is member of a region ",
					findrr[i].rr_name );
				(void) fprintf( stderr,
					"but not in description.\n" );
				exit( 10 );
 				}
			}
		}
a152 6
	(void) unlink( disc_file );
	(void) close( idfd );
	(void) close( rd_idfd );
	(void) unlink( reg_file );
	(void) close( rrfd );
	(void) close( rd_rrfd );
d157 1
d267 1
a624 12
/*	c h e c k ( )
	Compares solids to see if have a new solid.
 */
check( a, b )
register char	*a, *b;
	{ 	register int	c = sizeof( struct deck_ident );
	while( c-- )
		if( *a++ != *b++ )
			return	0;   /* new solid */
	return	1;   /* match - old solid */
	}

d735 1
a735 16
	if( access( disc_file, 0 ) == 0 )
		{
		(void) unlink( disc_file );
		if( idfd > 0 )
			(void) close( idfd );
		if( rd_idfd > 0 )
			(void) close( rd_idfd );
		}
	if( access( reg_file, 0 ) == 0 )
		{
		(void) unlink( reg_file );
		if( rrfd > 0 )
			(void) close( rrfd );
		if( rd_rrfd > 0 )
			(void) close( rd_rrfd );
		}
@


9.1
log
@Release_3.5
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: vproc.c,v 8.1 88/10/05 00:53:12 mike Rel3_0 $ (BRL)";
a14 1
		2:  Object Directory Routines
d24 1
d26 2
d29 2
a31 1
extern void	mat_idn();
a32 1
#include "./std.h"
d34 1
a34 5
Directory	directory[NDIR];
static char	*db_title = NULL, *db_units = "  ";

char		*addname(), getarg();
Directory	*lookup(), *diradd();
d73 1
a73 1
	ewrite( solfd, db_units, 2 );
d77 1
a77 1
	if( db_title == NULL )
d80 1
a80 1
		ewrite( solfd, db_title, (unsigned) strlen( db_title ) );
d144 5
a148 2
		{	Directory	*dirp;
		if( (dirp = lookup( curr_list[i], NOISY )) != DIR_NULL )
d150 1
d152 1
a266 156
/*
	Section 2:	O B J E C T   D I R E C T O R Y   R O U T I N E S

			builddir()
			toc()
			diradd()
			addname()
 */

/*
			B U I L D D I R

 This routine reads through the 3d object file and
 builds a directory of the object names, to allow rapid
 named access to objects.
 */
builddir()
	{	register Directory *dirp;
	(void) printf( "Building the directory.\n" );
	(void) fflush( stdout );
	for(	dirp = directory, ndir = 0;
		ndir < NDIR
	    &&	(dirp->d_addr = lseek( objfd, 0L, 1 )) != -1
	    &&	read( objfd, (char *) &record, sizeof(record) ) == sizeof(record);
		dirp++, ndir++
		)
		{
		switch( record.u_id )
			{
		case ID_IDENT : /* Identification record.		*/
			{	static int	units_set_flag = false;
			ndir--;	/* Don't include in directory.		*/
			dirp--;
			if( db_title == NULL )
				{
				/* This must be the first ident record.	*/
				db_title = emalloc( strlen(record.i.i_title)+1 );
				(void) strcpy( db_title, record.i.i_title );
				}
			(void) fprintf( stdout, "%s\n", record.i.i_title );
			(void) fprintf( stdout,
					"GED database version (%s)\n",
					record.i.i_version
					);
			/* Ignore second ident records' units, unless
				previous were bogus or unspecified.
			 */
			if( ! units_set_flag )
				{
				/* NOTE : Default unit conversion factor (1.0)
					is set in 'vglobal.c'.
				 */
				switch( record.i.i_units )
					{
				case ID_NO_UNIT : /* unspecified	*/
					(void) printf( "No units specified.\n" );
					break;
				case ID_MM_UNIT	: /* milimeters		*/
					(void) printf( "Units = milimeters.\n" );
					unit_conversion = 1.0;
					units_set_flag = true;
					(void) strcpy( db_units, "mm" );
					break;
				case ID_CM_UNIT	: /* centimeters	*/
					(void) printf( "Units = centimeters.\n" );
					unit_conversion = 0.1;
					units_set_flag = true;
					(void) strcpy( db_units, "cm" );
					break;
				case ID_M_UNIT  : /* meters		*/
					(void) printf( "Units = meters.\n" );
					unit_conversion = 0.001;
					units_set_flag = true;
					(void) strcpy( db_units, "m " );
					break;
				case ID_IN_UNIT	: /* inches		*/
					(void) printf( "Units = inches.\n" );
					unit_conversion = 0.03937008;
					units_set_flag = true;
					(void) strcpy( db_units, "in" );
					break;
				case ID_FT_UNIT	: /* feet		*/
					(void) printf( "Units = feet.\n" );
					unit_conversion = 0.00328084;
					units_set_flag = true;
					(void) strcpy( db_units, "ft" );
					break;
				default :
					(void) fprintf( stderr,
							"Unknown units (%d)!\n",
							record.i.i_units
							);
					break;
					}
				break;
				}
			}
		case ID_FREE :  /* Free record -- ignore.		*/
		case ID_MATERIAL : /* Material database record -- ignore.	*/
			ndir--;
			dirp--;
			break;
		case ID_SOLID : /* Check for a deleted record.	 	*/
			if( record.s.s_name[0] == 0 )
				{
				ndir--;
				dirp--;
				}
			else
				dirp->d_namep = addname( record.s.s_name );
			break;
		case ID_ARS_A :  /* Check for a deleted record.		 */
			if( record.s.s_name[0] == 0 )
				{
				ndir--;
				dirp--;
				}
			else
				dirp->d_namep = addname( record.s.s_name );
			/*  Skip remaining B type records.		*/
			(void) lseek(	objfd,
					(long)(record.a.a_totlen * sizeof record),
					1
					);
			break;
		case ID_COMB :  /* Check for a deleted record.		 */
			if( record.c.c_name[0] == 0 )
				{
				ndir--;
				dirp--;
				}
			else
				dirp->d_namep = addname( record.c.c_name );
			/* Skip over remaining records.			 */
			(void) lseek(	objfd,
					(long)(record.c.c_length * sizeof(record)),
					1
					);
			break;
		default :
			(void) fprintf( stderr,
					"Builddir:  unknown record %c (0%o).\n",
					record.u_id,
					record.u_id
					);
			ndir--;
			dirp--;
			break;
			}
		}
	if( ndir == NDIR )
		(void) fprintf( stderr, "Too many objects in input\n" );
	(void) printf( "%d objects tallied\n", ndir );
	return;
	}

d273 5
a277 1
	{	register int		i;
d281 3
a283 32
	for( i = 0; i < ndir; i++ )
		toc_list[i] = directory[i].d_namep;
	return;
	}

/*	l o o k u p ( )
	This routine takes a name, and looks it up in the
	directory table.  If the name is present, a pointer to
	the directory struct element is returned, otherwise
	a -1 is returned.

	If the flag is NOISY, a print occurs, else only
	the return code indicates failure.
 */
Directory *
lookup( str, flag )
register char *str;
	{	register Directory	*dirp;
		register char		*np;
		static Directory	*ep;
		static int		i;
	ep = &directory[ndir];
	for( dirp = &directory[0]; dirp < ep; dirp++ )
		{
		np = dirp->d_namep;
		for( i = 0; i < NAMESIZE; i++ )
			{
			if( str[i] != *np )
				break;
			if( *np++ == 0 || i == 15 )
				return	dirp;
			}
a284 3
	if( flag == NOISY )
		(void) fprintf( stderr, "Lookup: could not find '%s'.\n", str );
	return	DIR_NULL;
d286 1
a287 42
/*	d i r a d d ( )
	Add an entry to the directory.
 */
Directory *
diradd( namep, laddr )
register char	*namep;
long		laddr;
	{	register Directory *dirp;

	if( ndir >= NDIR )
		{
		(void) fprintf( stderr, "Diradd:  no more dir structs.\n" );
		return	DIR_NULL;
		}
	dirp = &directory[ndir++];
	dirp->d_namep = addname( namep );
	dirp->d_addr = laddr;
	return	dirp;
	}

/*	a d d n a m e ( )
	Given a name, it puts the name in the name buffer, and
	returns a pointer to that string.
 */
char *
addname( cp )
register char	*cp;
	{	static char	*holder;
		register int	i;
	if( dir_last >= &dir_names[NDIR*10-NAMESIZE] )
		{
		(void) fprintf( stderr, "Addname:  out of name space.\n" );
		exit( 1 );
		}
	holder = dir_last;
	i = 0;
	while( *cp != 0 && i++ < NAMESIZE )
		*dir_last++ = *cp++;
	*dir_last++ = 0;
	return	holder;
	}

d379 1
a379 6
				bytect = strlen( toc_list[j] );
				curr_list[curr_ct] = emalloc( (int) ++bytect );
				/* Insert string at end of list.		*/
				(void) strcpy(	curr_list[curr_ct++],
						toc_list[j]
						);
d411 2
a412 1
				free( curr_list[j] );	--curr_ct;
d531 146
d713 1
a713 1
			free( args[arg_ct] );
d716 1
a716 1
		args[arg_ct] = emalloc( MAXLN );
@


8.1
log
@Release_3.0
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: vproc.c,v 7.1 87/11/03 00:28:20 mike Rel $ (BRL)";
@


7.1
log
@Release 2.3
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: vproc.c,v 6.1 87/07/11 08:17:19 mike Rel $ (BRL)";
@


6.1
log
@Release 2.0
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: vproc.c,v 5.1 87/06/24 22:49:15 mike Rel $ (BRL)";
@


5.1
log
@Release 1.24
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: vproc.c,v 4.4 87/03/30 09:16:01 moss Exp $ (BRL)";
@


4.4
log
@Changed permissions of output files to 0644 from 0666.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: vproc.c,v 4.3 87/02/24 16:30:21 moss Locked $ (BRL)";
@


4.3
log
@Fixed bug in col_prt() where "buf" was getting overrun, clobbering the
stack.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d68 1
a68 1
	if( (solfd = creat( st_file, 0666 )) < 0 )
d98 1
a98 1
	if( (regfd = creat( rt_file, 0666 )) < 0 )
d113 1
a113 1
	if( (ridfd = creat( id_file, 0666 )) < 0 )
d124 1
a124 1
	if( (idfd = creat( disc_file, 0666 )) < 0 )
d133 1
a133 1
	if( (rrfd = creat( reg_file, 0666 )) < 0 )
@


4.2
log
@Release 1.20 -- First Formal Release
@
text
@a1 5
	SCCS id:	@@(#) vproc.c	2.7
	Last edit: 	7/10/86 at 11:07:27
	Retrieved: 	8/13/86 at 08:27:02
	SCCS archive:	/m/cad/vdeck/RCS/s.vproc.c

d8 2
a9 3
#if ! defined( lint )
static
char	sccsTag[] = "@@(#) vproc.c	2.7	last edit 7/10/86 at 11:07:27";
d542 7
d555 1
a555 1
	{	char		buf[72];
d560 1
a560 3
		(void) strcpy( &buf[column], list[i] );
		column += strlen( list[i] );
		if( column > 56 )
d562 2
a563 3
			buf[column++] = '\n';
			ewrite( 1, buf, (unsigned) column );
			column = 0;
d567 8
a574 5
			for(	spaces = NAMESIZE - (column % NAMESIZE );
				spaces > 0;
				spaces--
				)
				buf[column++] = ' ';
d577 1
a577 3
	buf[column++] = '\n';
	ewrite( 1, buf, (unsigned) column );
	column = 0;
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@@


2.8
log
@SGI fixes
@
text
@@


2.7
log
@Swapped vectors for TEC and REC to appease GIFT. Linted code.
@
text
@d30 1
a30 2
#include <setjmp.h>
#include <std.h>
d32 1
d36 2
d306 2
a307 2
				db_title = emalloc( strlen(record.I.i_title)+1 );
				(void) strcpy( db_title, record.I.i_title );
d309 4
a312 3
			(void) printf( "%s\n", record.I.i_title );
			(void) printf(	"GED database version (%s)\n",
					record.I.i_version
d322 1
a322 1
				switch( record.I.i_units )
d360 1
a360 1
							record.I.i_units
d368 1
a368 1
		case ID_MATER : /* Material database record -- ignore.	*/
@


2.6
log
@Fixed buffer size in cgobj(), linted quite a bit.
@
text
@d2 3
a4 3
	SCCS id:	@@(#) vproc.c	2.6
	Last edit: 	12/20/85 at 19:04:33
	Retrieved: 	8/13/86 at 08:26:34
d15 1
a15 1
char	sccsTag[] = "@@(#) vproc.c	2.6	last edit 12/20/85 at 19:04:33";
d33 3
d42 1
d61 2
a62 3
	/* rewind object file
	 */
	lseek( objfd, 0L, 0 );
d64 10
a73 7
	/* create file for solid table
	 */
	if( prefix != 0 ) {
		strncpy( st_file, prefix, 73 );
		strcat( st_file, ".st" );
	} else	strncpy( st_file, "solids", 7 );
	if( (solfd = creat( st_file, 0666 )) < 0 ) {
d76 1
a76 1
	}
d79 1
a79 1
	write( solfd, db_units, 2 );
d84 1
a84 3
		{
		(void) write( solfd, objfile, (unsigned) strlen( objfile ) );
		}
d86 2
a87 4
		{
		(void) write( solfd, db_title, (unsigned) strlen( db_title ) );
		}
	(void) write( solfd, LF, 1 );
d89 1
a89 2
	/* save space for number of solids and regions
	 */
d92 1
a92 1
	(void) write( solfd, LF, 1 );
d123 2
a124 2
	(void) write( ridfd, buff, 5 );
	(void) write( ridfd, LF, 1 );
d157 1
a157 1
	(void) write( solfd, buff, 5 );
d159 1
a159 1
	(void) write( solfd, buff, 5 );
d162 1
a162 1
	(void) write( ridfd, LF, 1 );
d173 1
a173 1
				readF( rd_rrfd, name, NAMESIZE );
d179 1
a179 1
					(void) write( regfd, buff, 4 );
d202 1
a202 1
	unlink( disc_file );
d205 1
a205 1
	unlink( reg_file );
d225 1
a225 1
	signal( SIGINT, SIG_IGN );
d227 1
a227 2
	/* build arg vector
	 */
d234 1
a234 1
			fprintf( stderr, "\ncommand line too long\n" );
d251 2
a252 2
		signal( SIGINT, SIG_DFL );
		execv(	"/bin/sh", argv );
d291 1
a291 1
	    &&	readF( objfd, (char *) &record, sizeof(record) ) == sizeof(record);
d307 2
a308 3
			(void) fprintf( stdout, "%s\n", record.I.i_title );
			(void) fprintf( stdout,
					"GED database version (%s)\n",
d528 1
a528 3
{
	register int	i, j;

a534 1
				{
a535 1
				}
d539 1
a539 3
		{
		col_prt( tmp_list, tmp_ct );
		}
d541 1
a541 3
		{
		col_prt( toc_list, ndir );
		}
d543 1
a543 1
}
d549 4
a552 7
register
char	*list[];
register
int	ct;
	{
	char		buf[72];
	register int	i, column, spaces;
d561 1
a561 1
			(void) write( 1, buf, (unsigned) column );
d574 1
a574 1
	(void) write( 1, buf, (unsigned) column );
d645 4
a648 2
			fprintf( stderr,
				"Object \"%s\" not found.\n", args[i] );
d696 1
a696 2
register
char	    *s;
d698 3
a700 4
float	  f;
{
	int	c, i, j;
	long	n, sign;
d702 5
a706 3
	if( w <= d + 2 ) {
		fprintf( stderr,
			"ftoascii: incorrect format  need w.df  stop" );
d708 3
a710 2
	}
	for( i = 1; i <= d; i++ )	f = f * 10.0;
d713 4
a716 2
	if( f < 0.0 )	f -= 0.5;
	else		f += 0.5;
d718 2
a719 1
	if( (sign = n) < 0 )	n = -n;
d721 1
a721 1
	do {
d723 4
a726 2
		if( i == d )	s[i++] = '.';
	} while( (n /= 10) > 0 );
d728 5
a732 4
	/* zero fill the d field if necessary
	 */
	if( i < d ) {	
		for( j = i; j < d; j++ )	s[j] = '0';
d735 3
a737 2
	}
	if( sign < 0 )	s[i++] = '-';
d739 3
a741 3
	/* blank fill rest of field
	 */
	for ( j = i; j < w; j++ )	s[j] = ' ';
d743 1
a743 1
		fprintf( stderr, "Ftoascii: field length too small\n" );
d746 3
a748 3
	/* reverse the array
	 */
	for( i = 0, j = w - 1; i < j; i++, j-- ) {
d752 1
a753 1
}
d806 2
a807 2
	signal( SIGINT, abort_sig );
	return( (args[0])[0] );
d840 1
d843 6
a848 6
{
	register char	**sbuf = addr;
	
	while( *sbuf )	(void) printf( "%s\n", *sbuf++ );
	fflush( stdout );
}
d853 1
d857 2
a858 1
	return( write( fildes, blank_buf, (unsigned) count ) );
d879 1
a879 1
		unlink( disc_file );
d887 1
a887 1
		unlink( reg_file );
@


2.6.1.1
log
@SGI fixes
@
text
@d4 2
a5 2
	Retrieved: 	6/16/86 at 20:29:53
	SCCS archive:	/vld/src/vdeck/s.vproc.c
d30 2
a31 1

a32 3

#include "./std.h"

d304 2
a305 2
				db_title = emalloc( strlen(record.i.i_title)+1 );
				(void) strcpy( db_title, record.i.i_title );
d307 1
a307 1
			(void) fprintf( stdout, "%s\n", record.i.i_title );
d310 1
a310 1
					record.i.i_version
d320 1
a320 1
				switch( record.i.i_units )
d358 1
a358 1
							record.i.i_units
d366 1
a366 1
		case ID_MATERIAL : /* Material database record -- ignore.	*/
@


2.5
log
@Fixed default case in builddir switch, lost dp-- line.
@
text
@d2 4
a5 2
	@@(#) vproc.c			retrieved: 8/13/86 at 08:26:13,
	@@(#) version 2.5		last edit: 3/29/85 at 15:13:08.
d7 11
a17 3
	Written by Gary S. Moss.
	All rights reserved, Ballistic Research Laboratory.

d33 1
d35 1
d38 1
d52 2
a53 4
register
char *prefix;
{
	register int	i, j;
d79 1
a79 1
		write( solfd, objfile, strlen( objfile ) );
d83 1
a83 1
		write( solfd, db_title, strlen( db_title ) );
d85 1
a85 1
	write( solfd, LF, 1 );
d91 1
a91 1
	write( solfd, LF, 1 );
d93 10
a102 7
	/* create file for region table
	 */
	if( prefix != 0 ) {
		strncpy( rt_file, prefix, 73 );
		strcat( rt_file, ".rt" );
	} else	strncpy( rt_file, "regions", 8 );
	if( (regfd = creat( rt_file, 0666 )) < 0 ) {
d105 1
a105 1
	}
d109 9
a117 5
	if( prefix != 0 ) {
		strncpy( id_file, prefix, 73 );
		strcat( id_file, ".id" );
	} else	strncpy( id_file, "region_ids", 11 );
	if( (ridfd = creat( id_file, 0666 )) < 0 ) {
d120 1
a120 1
	}
d122 2
a123 2
	write( ridfd, buff, 5 );
	write( ridfd, LF, 1 );
d125 4
a128 4
	/* create /tmp file for discrimination of files
	 */
	strncpy( disc_file, mktemp( "/tmp/disXXXXXX" ), 15 );
	if( (idfd = creat( disc_file, 0666 )) < 0 ) {
d131 1
a131 1
	}
d134 4
a137 4
	/* create /tmp file for storage of region names in the comgeom desc
	 */
	strncpy( reg_file, mktemp( "/tmp/regXXXXXX" ), 15 );
	if( (rrfd = creat( reg_file, 0666 )) < 0 ) {
d140 1
a140 1
	}
d143 1
a143 2
	/* initialize matrices
	 */
d147 1
a147 3
	/* Check integrity of list against directory and build
	 * card deck.
	 */
d149 6
a154 6
		if( (dp = lookup( curr_list[i], NOISY )) != DIR_NULL )
			cgobj( dp, 0, identity );

	/* add number of solids and regions on second card
	 */
	lseek( solfd, savsol, 0 );
d156 1
a156 1
	write( solfd, buff, 5 );
d158 1
a158 1
	write( solfd, buff, 5 );
d160 2
a161 3
	/* finish region id table
	 */
	write( ridfd, LF, 1 );
d163 14
a176 15
 	/* must go back and add regions as members of regions
	 */
	if( numrr > 0 ) {
		for( i = 1; i <= numrr; i++ ) {
			lseek( rd_rrfd, 0L, 0 );   /* rewind */
			for( j = 1; j <= nnr; j++ ) {
				/* next region name in desc
				 */
				readF( rd_rrfd, name, 16 );
				if(	strcmp( findrr[i].rr_name, name )
					== 0)
				{	/* region number in desc is j
					 * add to regfd at rrpos[i]
					 */
					lseek( regfd, findrr[i].rr_pos, 0);
d178 1
a178 1
					write( regfd, buff, 4 );
d180 1
d182 3
a184 3
			}
			if( j > nnr ) {
				fprintf( stderr,
d187 1
a187 1
				fprintf( stderr,
d190 2
a191 1
 			}
d193 8
a200 9
	}
	prompt( "\n====================================================" );
	prompt( "\nO U T P U T    F I L E S :\n\n" );
	prompt( "solid table = \"%s\"\n", st_file );
	prompt( "region table = \"%s\"\n", rt_file );
	prompt( "region identification table = \"%s\"\n", id_file );
	close( solfd );
	close( regfd );
	close( ridfd );
d202 2
a203 2
	close( idfd );
	close( rd_idfd );
d205 2
a206 2
	close( rrfd );
	close( rd_rrfd );
d211 1
a211 1
}
d237 3
a239 2
		printf( "%s ", args[i] );
		while( *from )	*to++ = *from++;
d243 1
a243 1
	prompt( "\n" );
d285 1
a285 1
	{ register Directory *dp;
d288 8
a295 9

	dp = directory;
	while( 1 ) {
		dp->d_addr = lseek( objfd, 0L, 1 );
		if(	readF( objfd, &record, sizeof record )
			!= sizeof record
			)	
			break;
		if( ++ndir >= NDIR )
a296 5
			fprintf( stderr, "Too many objects in input\n" );
			break;
			}
		switch( record.u_id )
		{
d298 3
a300 3
		{ static int	units_set_flag = false;

			ndir--; dp--; /* Don't include in directory.	*/
d304 2
a305 13
				if(	(db_title =
					malloc( strlen( record.i.i_title )+1 )
					) == NULL
					)
					{
					(void) fprintf( stderr,
					"Builddir() :Malloc failed!\n"
							);
					}
				else
					{
					strcpy( db_title, record.i.i_title );
					}
d307 1
a307 1
			(void) fprintf( stdout, "%s\n", record.i.i_title );
d310 1
a310 1
					record.i.i_version
d312 4
a315 1
			if( units_set_flag )
a316 7
				;/* Ignore second ident records' units, unless
					previous were bogus or unspecified.
				  */
				}
			else
			switch( record.i.i_units )
				{
d320 2
d323 1
a323 3
					(void) fprintf( stdout,
						"No units specified.\n"
							);
d326 1
a326 3
					(void) fprintf( stdout,
						"Units = milimeters.\n"
							);
d329 1
a329 1
					strcpy( db_units, "mm" );
d332 1
a332 3
					(void) fprintf( stdout,
						"Units = centimeters.\n"
							);
d335 1
a335 1
					strcpy( db_units, "cm" );
d338 1
a338 3
					(void) fprintf( stdout,
							"Units = meters.\n"
							);
d341 1
a341 1
					strcpy( db_units, "m " );
d344 1
a344 3
					(void) fprintf( stdout,
							"Units = inches.\n"
							);
d347 1
a347 1
					strcpy( db_units, "in" );
d350 1
a350 3
					(void) fprintf( stdout,
							"Units = feet.\n"
							);
d353 1
a353 1
					strcpy( db_units, "ft" );
d358 1
a358 1
							record.i.i_units
d361 2
d364 1
a364 2
			break;
		}
d366 1
d368 1
a368 1
			dp--;
d371 2
a372 1
			if( record.s.s_name[0] == 0 )  {
d374 4
a377 3
				continue;
			}
			dp->d_namep = addname( record.s.s_name );
d380 2
a381 1
			if( record.s.s_name[0] == 0 )  {
d383 9
a391 9
				continue;
			}
			dp->d_namep = addname( record.s.s_name );

			/*  Skip remaining B type records.		 */
			lseek(	objfd,
				((long)record.a.a_totlen)
				* sizeof record,
				1 );
d394 2
a395 1
			if( record.c.c_name[0] == 0 )  {
d397 4
a400 3
				dp--;
			}  else	dp->d_namep = addname( record.c.c_name );

d402 4
a405 4
			lseek(	objfd,
				((long)record.c.c_length)
				* sizeof record,
				1 );
d408 5
a412 4
			fprintf( stderr,
				"Builddir:  unknown record %c (0%o).\n",
				record.u_id,
				record.u_id );
d414 1
a414 1
			dp--;
d416 1
d418 4
a421 1
		dp++;
a422 2
	prompt( "\n%d objects tallied\n", ndir );
}
d430 1
a430 3
	{
	register int		i;

a434 1
		{
a435 1
		}
d445 2
a446 2
 If the flag is NOISY, a print occurs, else only
 the return code indicates failure.
d451 4
a454 6
{
	register Directory *dp;
	register char *np;
	static Directory *ep;
	static int	i;

d456 10
a465 5
	for( dp = &directory[0]; dp < ep; dp++ )  {
		np = dp->d_namep;
		for( i = 0; i < 16; i++ ) {
			if( str[i] != *np )	break;
			if( *np++ == 0 || i == 15 )	return	dp;
a466 1
	}
d468 1
a468 1
		fprintf( stderr, "Lookup: could not find '%s'.\n", str );
d470 1
a470 1
}
d476 4
a479 5
diradd( name, laddr )
register char *name;
long laddr;
{
	register Directory *dp;
d481 3
a483 2
	if( ndir >= NDIR )  {
		fprintf( stderr, "Diradd:  no more dir structs.\n");
d485 5
a491 6
	dp = &directory[ndir++];
	dp->d_namep = addname( name );
	dp->d_addr = laddr;
	return( dp );
}

d498 6
a503 8
register
char	*cp;
{
	static char	*holder;
	register int	i;

	if( dir_last >= &dir_names[NDIR*10-16] )  {
		fprintf( stderr, "Addname:  out of name space.\n" );
d505 1
a505 1
	}
d508 2
a509 1
	while( *cp != 0 && i++ < 16 )	*dir_last++ = *cp++;
d512 1
a512 1
}
d568 1
a568 1
		strcpy( &buf[column], list[i] );
d573 1
a573 1
			write( 1, buf, column );
d578 1
a578 1
			for(	spaces = 16 - (column % 16 );
a581 1
				{
a582 1
				}
d586 1
a586 1
	write( 1, buf, column );
d596 1
a596 1
char	*args[];
d598 6
a603 11
{
	char		*malloc();
	register int	i, j, nomatch;
	unsigned	bytect;
	
	/* for each argument (does not include args[0])
	 */
	for( i = 1; i < ct; i++ ) {
		/* if object is in table of contents,
		 * insert in current list
		 */
d605 4
a608 2
		for( j = 0; j < ndir; j++ ) {
			if( match( args[i], toc_list[j] ) ) {
d610 1
a610 3

				/* allocate storage for string
				 */
d612 5
a616 5
				if(	(curr_list[curr_ct] =
					malloc( ++bytect )) == 0 )
				{
					perror( "malloc" );
					exit( 1 );
a617 5

				/* insert string at end of list
				 */
				strcpy(	curr_list[curr_ct++],
					toc_list[j] );
a618 1
		}
d620 1
a620 1
			fprintf( stderr,
d622 2
a624 2
	return( curr_ct );
}
d761 7
a767 4
register
char	*a, *b;
{
	register int	c = sizeof( struct deck_ident );
a768 4
	while( c-- )	if( *a++ != *b++ ) return( 0 );   /* new solid */
	return( 1 );   /* match - old solid */
}

a773 1
			pars_arg()
d786 4
a789 5
getcmd(  args, ct )
char	*args[];
register
int		ct;
{
d791 9
a799 5
	if( ct == 0 )	while( --arg_ct >= 0 )	free( args[arg_ct] );
	for( arg_ct = ct; arg_ct < MAXARG - 1; ++arg_ct ) {
		args[arg_ct] = malloc( MAXLN );
		if( !getarg( args[arg_ct] ) )	break;
	}
d808 1
a808 1
	signal( SIGINT, abort );
d810 1
a810 1
}
d818 1
a818 1
getarg(		 str )
d820 3
a822 2
{
	do {
d824 2
a825 1
		if( *str == ' ' ) {
a827 34
		} else	++str;
	} while( str[-1] != EOF && str[-1] != '\n' );
	if( str[-1] == '\n' )	--str;
	*str = '\0';
	return( 0 );
}

/*	p a r s _ a r g ( )
	Seperate words into seperate arguments.
 */
pars_arg( argvec,	ct )
char	 *argvec[];
register int		ct;
{
	char		buf[MAXLN];
	register char	*from, *to = buf;
	register int	i;

	for( i = 1; i < ct; i++ ) {
		from = argvec[i];
		while( *from != '\0' ) {
			if( *from != ' ' )	*to++ = *from++;
			else {
				*to = '\0';
				if( (arg_list[arg_ct] =
					malloc( strlen( buf ) + 1 ))
					== 0 ) {
					perror( "malloc()" );
					exit( 10 );
				}
				strcpy( arg_list[arg_ct], buf );
				to = buf;
				from++;
				arg_ct++;
d829 2
d832 5
a836 9
		*to = '\0';
		if( (arg_list[arg_ct] = malloc( strlen( buf ) + 1 )) == 0 )
		{
			perror( "malloc()" );
			exit( 10 );
		}
		strcpy( arg_list[arg_ct], buf );
		to = buf;
		++arg_ct;
a837 1
}
d847 1
a847 1
	while( *sbuf )	prompt( "%s\n", *sbuf++ );
d854 1
a854 1
blank_fill(	fildes,	count )
d856 3
a858 2
{
	register char	*blank_buf = BLANKS;
a859 3
	return( write( fildes, blank_buf, count ) );
}

d863 1
a863 1
			abort()
d871 7
a877 3
abort( sig ) {
	signal( SIGINT, quit );	/* reset trap */
	if( access( disc_file, 0 ) == 0 ) {
d879 7
a885 4
		if( idfd > 0 )		close( idfd );
		if( rd_idfd > 0 )	close( rd_idfd );
	}
	if( access( reg_file, 0 ) == 0 ) {
d887 7
a893 2
		if( rrfd > 0 )		close( rrfd );
		if( rd_rrfd > 0 )	close( rd_rrfd );
a895 5
	/* goto command interpreter with environment restored
	 */
	longjmp( env, sig );
}

d899 5
a903 2
quit( sig ) {
	fprintf( stderr, "quitting...\n" );
d905 1
a905 1
}
@


2.4
log
@Changed standard units to mm from inches.
@
text
@d2 2
a3 2
	@@(#) vproc.c			retrieved: 8/13/86 at 08:25:53,
	@@(#) version 2.4		last edit: 2/1/85 at 13:53:02.
d422 1
@


2.3
log
@Added support for new database format, ident and free records,
 and unit conversions.  Now puts title and units on first card.  Title 
version number and units are printed out when building the directory.
@
text
@d2 2
a3 2
	@@(#) vproc.c			retrieved: 8/13/86 at 08:25:34,
	@@(#) version 2.3		last edit: 1/31/85 at 14:59:56.
d335 1
a335 1
					unit_conversion = 25.4;
d343 1
a343 1
					unit_conversion = 2.54;
d351 1
a351 1
					unit_conversion = 0.0254;
d359 1
d367 1
a367 1
					unit_conversion = 0.0833333333;
@


2.2
log
@Fixed gift5 format.
@
text
@d2 15
a16 15
 *	@@(#) vproc.c			retrieved: 8/13/86 at 08:25:20,
 *	@@(#) version 2.2		last edit: 6/20/84 at 12:22:51.
 *
 *	Written by Gary S. Moss.
 *	All rights reserved, Ballistic Research Laboratory.
 *
 *	Procedures for vproc.c
 *
 *	Section 1:  Commands
 *		2:  Object Directory Routines
 *		3:  List Processing Routines
 *		4:  String Processing Routines
 *		5:  Input/Output Routines
 *		6:  Interrupt Handlers
 *	  
d21 1
d23 1
d28 4
a31 4
 *	Section 1:	C O M M A N D S
 *
 *			deck()
 *			shell()
d34 3
a36 3
/*	==== d e c k ( )
 *	make a COMGEOM deck for current list of objects
 *
d61 3
a63 2
	/* space for target units (a2,3x)				*/
	blank_fill( solfd, 5 );
d65 9
a73 3
	/* title
	 */
	write( solfd, objfile, strlen( objfile ) );
d199 2
a200 2
/*	==== s h e l l ( )
 *	Execute shell command.
d254 6
a259 6
 *	Section 2:	O B J E C T   D I R E C T O R Y   R O U T I N E S
 *
 *			builddir()
 *			toc()
 *			diradd()
 *			addname()
d263 5
a267 5
 *			B U I L D D I R
 *
 * This routine reads through the 3d object file and
 * builds a directory of the object names, to allow rapid
 * named access to objects.
d270 1
a270 1
{ register Directory *dp;
d274 1
a274 1
	dp = &directory[0];
d279 4
a282 2
		)	break;
		if( ++ndir >= NDIR )  {
d285 93
d379 5
a383 4
		switch( record.u_id ) {
		case SOLID:
			/* Check for a deleted record
			 */
d390 1
a390 3
		case ARS_A:
			/* Check for a deleted record
			 */
d397 1
a397 2
			/*  skip remaining B type recods
			 */
d403 1
a403 3
		case COMB:
			/* Check for a deleted record
			 */
d409 1
a409 2
			/* Skip over remaining records
			 */
d415 1
a415 1
		default:
d428 3
a430 3
/*	==== t o c ( )
 *	Build a sorted list of names of all the objects accessable
 *	in the object file.
d432 3
a434 2
toc() {
	static Directory	*dp, *ep;
a438 2
	dp = &directory[0];
	ep = &directory[ndir];
d440 6
a445 3
	for( i = 0; dp < ep; )	toc_list[i++] = (dp++)->d_namep;
	toc_ct = i;
}
d447 8
a454 8
/*	==== l o o k u p ( )
 *	This routine takes a name, and looks it up in the
 *	directory table.  If the name is present, a pointer to
 *	the directory struct element is returned, otherwise
 *	a -1 is returned.
 *
 * If the flag is NOISY, a print occurs, else only
 * the return code indicates failure.
d478 2
a479 2
/*	==== d i r a d d ( )
 *	Add an entry to the directory.
d499 3
a501 3
/*	==== a d d n a m e ( )
 *	Given a name, it puts the name in the name buffer, and
 *	returns a pointer to that string.
d523 1
a523 7
 *	Section 3:	L I S T   P R O C E S S I N G   R O U T I N E S
 *
 *			list_toc()
 *			col_prt()
 *			insert()
 *			delete()
 */
d525 8
a532 2
/*	==== l i s t _ t o c ( )
 *	List the table of contents.
d534 1
d540 5
a544 2
	for( tmp_ct = 0, i = 1; args[i] != 0; i++ )
		for( j = 0; j < toc_ct; j++ )
d546 1
d548 12
a559 2
	if( i > 1 )	col_prt( tmp_list, tmp_ct );
	else		col_prt( toc_list, toc_ct );
d562 2
a563 2
/*	==== c o l _ p r t ( )
 *	Print list of names in tabular columns.
d566 1
d570 1
a570 1
{
d572 1
a572 2
	register char	*lbuf = buf;
	register int	i, column = 0;
d574 3
a576 2
	for( i = 0; i < ct; i++ ) {
		strcpy( lbuf, list[i] );
d578 4
a581 5
		lbuf += strlen( list[i] );
		if( column > 56 ) {
			*lbuf++ = '\n';
			write( 1, buf, lbuf-buf );
			lbuf = buf;
d583 11
a593 3
		} else	{
			*lbuf++ = '\t';
			column += 8 - (column % 8 );
d595 4
a599 5
	*lbuf++ = '\n';
	write( 1, buf, lbuf-buf );
	lbuf = buf;
	return( ct );
}
d601 3
a603 3
/*	==== i n s e r t ( )
 *	Insert each member of the table of contents 'toc_list' which
 *	matches one of the arguments into the current list 'curr_list'.
d620 1
a620 1
		for( j = 0; j < toc_ct; j++ ) {
d647 3
a649 3
/*	==== d e l e t e ( )
 *	delete all members of current list 'curr_list' which match
 *	one of the arguments
d672 1
a672 1
				 * made by deletion
d685 1
a685 7
 *	Section 4:	S T R I N G   P R O C E S S I N G   R O U T I N E S
 *
 *			match()
 *			itoa()
 *			ftoascii()
 *			check()
 */
d687 3
a689 9
/*	==== m a t c h ( )
 *	if string matches pattern, return 1, else return 0
 *	special characters:
 *		*	Matches any string including the null string.
 *		?	Matches any single character.
 *		[...]	Matches any one of the characters enclosed.
 *		-	May be used inside brackets to specify range
 *			(i.e. str[1-58] matches str1, str2, ... str5, str8)
 *		\	Escapes special characters.
a690 32
match(	 pattern,  string )
register
char	*pattern, *string;
{
	do {	switch( *pattern ) {
		case '*': /*
			   * match any string including null string
			   */
			++pattern;
			do	if( match( pattern, string ) ) return( 1 );
			while( *string++ != '\0' );
			return( 0 );
			break;
		case '?': /*
			   * match any character
			   */
			if( *string == '\0' )	return( 0 );
			break;
		case '[': /*
			   * try to match one of the characters in brackets
			   */
			++pattern;
			while( *pattern != *string ) {
				if(	pattern[ 0] == '-'
				    &&	pattern[-1] != '\\'
				)	if(	pattern[-1] <= *string
					    &&	pattern[-1] != '['
					    &&	pattern[ 1] >= *string
					    &&	pattern[ 1] != ']'
					)	break;
				if( *++pattern == ']' )	return( 0 );
			}
d692 2
a693 22
			/* skip to next character after closing bracket
			 */
			while( *++pattern != ']' );
			break;
		case '\\': /*
			    * escape special character
			    */
			++pattern;
			/* WARNING: falls through to default case */
		default:  /*
			   * compare characters
			   */
			if( *pattern != *string )	return( 0 );
			break;
		}
		++string;
	} while( *pattern++ != '\0' );
	return( 1 );
}

/*	==== i t o a ( )
 *	Convert integer to ascii  wd format.
d723 2
a724 2
/*	==== f t o a s c i i ( )
 *	Convert float to ascii  w.df format.
d778 2
a779 2
/*	==== c h e c k ( )
 *	Compares solids to see if have a new solid.
d785 1
a785 1
	register int	c = sizeof( struct ident );
d792 1
a792 1
 *	Section 5:	I / O   R O U T I N E S
d794 7
a800 7
 *			getcmd()
 *			getarg()
 *			pars_arg()
 *			menu()
 *			blank_fill()
 *			bug()
 *			fbug()
d803 4
a806 4
/*	==== g e t c m d ( )
 *	Return first character read from keyboard,
 *	copy command into args[0] and arguments into args[1]...args[n].
 *		
d832 4
a835 4
/*	==== g e t a r g ( )
 *	Get a word of input into 'str',
 *	Return 0 if newline is encountered.
  *	Return 1 otherwise.
d853 2
a854 2
/*	==== p a r s _ a r g ( )
 *	Seperate words into seperate arguments.
d894 2
a895 2
/*	==== m e n u ( )
 *	Display menu stored at address 'addr'.
d906 2
a907 2
/*	==== b l a n k _ f i l l ( )
 *	Write count blanks to fildes.
d918 1
a918 1
 *	Section 6:	I N T E R R U P T   H A N D L E R S
d920 2
a921 2
 *			abort()
 *			quit()
d924 3
a926 3
/*	==== a b o r t ( )
 *	Abort command without terminating run (restore command prompt) and
 *	cleanup temporary files.
d946 2
a947 2
/*	==== q u i t ( )
 *	Terminate run.
@


2.1
log
@Just bumped version number to 2.1, no changes.
@
text
@d2 2
a3 2
 *	@@(#) vproc.c			retrieved: 8/13/86 at 08:25:07,
 *	@@(#) version 2.1		last edit: 6/1/84 at 14:05:19.
a95 3
	write( ridfd, LF, 1 );
	itoa( 0, buff, 10 );
	write( ridfd, buff, 10 );
@


1.10
log
@Upgraded to gift5 (gift(1V)) input specs.
@
text
@d2 2
a3 2
 *	@@(#) vproc.c			retrieved: 8/13/86 at 08:24:51,
 *	@@(#) version 1.10		last edit: 6/1/84 at 14:00:58.
@


1.9
log
@*** empty log message ***
@
text
@d2 2
a3 2
 *	@@(#) vproc.c			retrieved: 8/13/86 at 08:24:35,
 *	@@(#) version 1.9		last edit: 11/29/83 at 08:13:02.
d59 3
d70 1
a70 1
	blank_fill( solfd, 30 );
d134 4
a137 4
	itoa( nns, buff, 20 );
	write( solfd, buff, 20 );
	itoa( nnr, buff, 10 );
	write( solfd, buff, 10 );
@


1.8
log
@Solids over 999 use cvt compatible numbering scheme,
10 = 'A', 11 = 'B', ...
@
text
@d2 2
a3 2
 *	@@(#) vproc.c			retrieved: 8/13/86 at 08:24:17,
 *	@@(#) version 1.8		last edit: 10/28/83 at 17:36:30.
@


1.7
log
@*** empty log message ***
@
text
@d2 2
a3 2
 *	@@(#) vproc.c			retrieved: 8/13/86 at 08:24:02,
 *	@@(#) version 1.7		last edit: 10/11/83 at 10:57:48.
d649 1
a649 2
	/* blank fill array
	 */
d651 3
a653 2
	if( i > w )
		fprintf( stderr, "Itoa: field length too small.\n" );
d656 1
a656 2
	/* reverse the array
	 */
@


1.6
log
@*** empty log message ***
@
text
@d2 2
a3 2
 *	@@(#) vproc.c			retrieved: 8/13/86 at 08:23:47,
 *	@@(#) version 1.6		last edit: 10/11/83 at 10:02:55.
a20 3
#include "./ged_types.h"
#include "./3d.h"
#include "./vdeck.h"
d262 3
d337 2
@


1.5
log
@*** empty log message ***
@
text
@d2 2
a3 2
 *	@@(#) vproc.c			retrieved: 8/13/86 at 08:23:30,
 *	@@(#) version 1.5		last edit: 10/11/83 at 09:31:36.
d25 1
a25 1
char		*addname();
d838 1
a838 2
register
char *addr;
@


1.4
log
@*** empty log message ***
@
text
@d2 2
a3 2
 *	@@(#) vproc.c		retrieved 8/13/86 at 08:23:14,
 *	@@(#) version 1.4		  created 3/29/83 at 10:55:05.
d8 1
a8 1
 *	Proceedures for deck.c
d21 6
a26 4
#include "ged_types.h"
#include "3d.h"
#include "deck.h"
#include "deck_ext.h"
d128 1
a128 1
		if( (dp = lookup( curr_list[i], NOISY )) != -1 )
d367 1
a367 1
			if( *np++ == 0 || i == 15 )	return( dp );
d372 1
a372 1
	return( -1 );
d387 1
a387 1
		return( -1 );
d400 1
d416 1
a416 1
	return( holder );
a425 1
 *			sort()
a556 26
}

/*	==== s o r t ( )
 *	Sort a list of strings alphabetically stored at 'linebuf'.
 */
sort( linebuf,	items )
char *linebuf[];
register
int		items;
{
	register int	i;
	register int	change = YES;

	for( i = 0; i < items-1 && change == YES; i++ )
	{ register int	j;
	  register char	*p;
		change = NO;
		for( j = items-1; j > i; --j ) {
			if( strcmp( linebuf[j], linebuf[j-1] ) < 0 ) {
				p = linebuf[j];
				linebuf[j] = linebuf[j-1];
				linebuf[j-1] = p;
				change = YES;
			}
		}
	}
@


1.3
log
@EOF on stdin causes program to terminate normally, fixed setjmp() header reference.
@
text
@d2 2
a3 2
 *	@@(#) vproc.c		retrieved 8/13/86 at 08:22:56,
 *	@@(#) version 1.3		  created 2/24/83 at 13:10:04.
a339 1
	sort( toc_list, toc_ct );
@


1.2
log
@Removed terminal-independent stuff, added register variables and documentation.
@
text
@d2 2
a3 2
 *	@@(#) vproc.c		retrieved 8/13/86 at 08:22:38,
 *	@@(#) version 1.2		  created 2/23/83 at 14:48:39.
d20 1
d24 1
a24 1
#include "deck_proc.h"
d42 1
a42 1

d122 2
a123 2
	/* check integrity of list against directory and build
	 * card deck
d149 1
a149 1
				read( rd_rrfd, name, 16 );
d162 2
a163 1
				printf( "region %s is member of a region ",
d165 2
a166 1
				printf( ",but not in description\n" );
d171 5
a175 5
	printf( "\n====================================================" );
	printf( "\nO U T P U T    F I L E S :\n\n" );
	printf( "solid table = \"%s\"\n", st_file );
	printf( "region table = \"%s\"\n", rt_file );
	printf( "region identification table = \"%s\"\n", id_file );
d220 1
a220 1
	printf( "\n" );
d261 2
a262 3
builddir() {
	register Directory *dp;

d266 1
a266 1
		if(	read( objfd, &record, sizeof record )
d270 1
a270 1
			printf( "Too many objects in input\n" );
d315 2
a316 1
			printf(	"builddir:  unknown record %c (0%o)\n",
d324 1
a324 1
	printf( "\n%d objects tallied\n", ndir );
d369 2
a370 1
	if( flag == NOISY ) printf( "lookup: could not find '%s'\n", str );
d385 1
a385 1
		printf("diradd:  no more dir structs\n");
d407 1
a407 1
		fprintf( stderr, "addname:  out of name space\n" );
d515 2
a516 1
			printf( "object \"%s\" not found\n", args[i] );
d551 3
a553 2
		if( nomatch )	printf( "object \"%s\" not found\n",
					args[i] );
d675 2
a676 1
	if( i > w )	printf( "itoa: field length too small\n" );
d678 1
d701 2
a702 1
		printf( "ftoascii: incorrect format  need w.df  stop" );
d706 1
d730 2
a731 1
	if( i > w )	printf("ftoascii: field length too small\n");
d779 1
a779 2
	/* get arguments
	 */
d783 1
a783 1
		if( getarg( args[arg_ct] ) )	break;
d798 3
a800 1
 *	Get a word of input into 'str', return first character.
d806 2
a807 1
	while( (*str = getchar()) != EOF && *str != '\n' ) {
d810 1
a810 1
			return( 0 );
d812 2
a813 1
	}
d815 1
a815 1
	return( 1 );
d868 1
a868 1
	while( *sbuf )	printf( "%s\n", *sbuf++ );
@


1.1
log
@Initial revision
@
text
@d2 6
a7 1
 *	d e c k _ p r o c . c
a23 1
#include "tty.h"
d28 1
d32 1
a32 1
/*	==== D E C K ( )
d37 1
d40 1
a40 1
	int	i, j;
d188 2
a189 2
/*	==== S H E L L ( )
 *	execute shell command
d194 4
a197 3
	char	*argv[4], cmdbuf[MAXLN], *from, *to;
	int	pid, ret, status;
	int	i;
d324 1
a324 1
/*	==== T O C ( )
a328 3
	extern char	*toc_list[];
	extern int	toc_ct;
	
d340 1
a340 1
/*	==== L O O K U P ( )
d370 2
a371 2
/*	==== D I R A D D ( )
 *	Add an entry to the directory
d391 1
a391 1
/*	==== A D D N A M E ( )
d396 2
a397 1
register char *cp;
d399 2
a400 2
	static char *holder;
	register int i;
d423 2
a424 2
/*	==== L I S T _ T O C ( )
 *	list the table of contents
d439 2
a440 2
/*	==== C O L _ P R T
 *	print list of names in tabular columns
d444 1
d448 1
a448 1
	char		*lbuf = buf;
d471 3
a473 3
/*	==== I N S E R T ( )
 *	insert each member of the table of contents 'toc_list' which
 *	matches one of the arguments into the current list 'curr_list'
d477 1
a477 1
int		ct;
d479 3
a481 3
	char	*malloc();
	int	i, j, nomatch;
	unsigned bytect;
d516 1
a516 1
/*	==== D E L E T E ( )
d523 2
a524 2
	int	i, j, k;
	int	nomatch;
d528 1
a528 1
	for( i = 1; i < arg_ct; i++ ) {
d534 3
a536 1
			if( match( args[i], curr_list[j] ) ) {
d538 1
a538 2
				free( curr_list[j] );
				--curr_ct;
d552 2
a553 2
/*	==== S O R T ( )
 *	sort a list of strings alphabetically stored at 'linebuf'
d557 1
d560 2
a561 3
	char	*p;
	int	i, j;
	int	change = YES;
d563 3
a565 1
	for( i = 0; i < items-1 && change == YES; i++ ) {
d587 1
a587 1
/*	==== M A T C H ( )
d598 1
d650 2
a651 2
/*	==== I T O A ( )
 *	convert integer to ascii  wd format
d654 3
a656 1
char	 s[];
d680 2
a681 2
/*	==== F T O A S C I I ( )
 *	convert float to ascii  w.df format
d684 3
a686 2
char	     s[];
int		w, d;
d732 2
a733 2
/*	==== C H E C K ( )
 *	compares solids to see if have a new solid
d736 2
a737 1
register char	*a, *b;
d757 3
a759 3
/*	==== G E T C M D ( )
 *	return first character read from keyboard
 *	copy command into args[0] and arguments into args[1]...args[n]
d765 2
a766 1
int	ct;
d787 2
a788 2
/*	==== G E T A R G ( )
 *	get a word of input into 'str', return first character
d804 2
a805 2
/*	==== P A R S _ A R G ( )
 *	seperate words into seperate arguments
d809 1
a809 1
int			ct;
d811 3
a813 3
	char	buf[MAXLN];
	char	*from, *to = buf;
	int	i;
d845 2
a846 2
/*	==== M E N U ( )
 *	display menu stored at address 'addr';
d849 1
d852 1
a852 1
	char	**sbuf = addr;
d855 1
d858 2
a859 2
/*	==== B L A N K _ F I L L ( )
 *	write count blanks to fildes
d862 1
a862 1
int		fildes,	count;
d864 1
a864 1
	char	*blank_buf = BLANKS;
a868 24
/*	==== B U G ( )
 *	debug statements
 */
bug(	p0, p1, p2, p3, p4, p5, p6, p7, p8, p9 )
int	p0, p1, p2, p3, p4, p5, p6, p7, p8, p9;
{
	fprintf( stderr, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9 );
}

/*	==== F B U G ( )
 *	debug statements
 */
fbug(	control, f0, f1, f2, f3, f4, f5, f6, f7, f8, f9 )
int	control;
float	    f0, f1, f2, f3, f4, f5, f6, f7, f8, f9;
{
	fprintf( stderr, control, f0, f1, f2, f3, f4, f5, f6, f7, f8, f9 );
}

deadbug( control, f0, f1, f2, f3, f4, f5, f6, f7, f8, f9 )
int	 control;
float	    f0, f1, f2, f3, f4, f5, f6, f7, f8, f9;
{}

d876 3
a878 3
/*	==== A B O R T ( )
 *	abort command without terminating run (restore command prompt)
 *	cleanup /tmp files
d898 2
a899 2
/*	==== Q U I T ( )
 *	terminate run
@
