head	11.22;
access;
symbols
	ansi-20040405-merged:11.19.4.1
	postmerge-20040405-ansi:11.20
	premerge-20040404-ansi:11.20
	postmerge-autoconf:11.20
	autoconf-freeze:11.19.12.2
	premerge-autoconf:11.20
	postmerge-20040315-windows:11.20
	premerge-20040315-windows:11.20
	windows-20040315-freeze:11.19.6.4
	autoconf-20031203:11.19
	autoconf-20031202:11.19
	autoconf-branch:11.19.0.12
	phong-branch:11.19.0.10
	photonmap-branch:11.19.0.8
	rel-6-1-DP:11.19
	windows-branch:11.19.0.6
	rel-6-0-2:11.19
	ansi-branch:11.19.0.4
	rel-6-0-1-branch:11.19.0.2
	hartley-6-0-post:11.19
	hartley-6-0-pre:11.19
	rel-6-0-1:11.19
	rel-6-0:11.19
	rel-5-4:11.7.2.1
	offsite-5-3-pre:11.13
	rel-5-3:11.7
	rel-5-2:11.7
	rel-5-1-branch:11.7.0.2
	rel-5-1:11.7
	rel-5-0:11.5
	rel-5-0-beta:11.5
	rel-4-5:11.3
	ctj-4-5-post:11.3
	ctj-4-5-pre:11.3
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:5.1
	rel-1-24:5.1
	rel-1-20:4.2
	rel-1-10:4.1;
locks; strict;
comment	@ * @;


11.22
date	2004.05.21.13.49.18;	author morrison;	state dead;
branches;
next	11.21;

11.21
date	2004.05.10.15.30.51;	author erikg;	state Exp;
branches;
next	11.20;

11.20
date	2004.02.02.17.39.52;	author morrison;	state Exp;
branches;
next	11.19;

11.19
date	2001.11.05.21.20.08;	author morrison;	state Exp;
branches
	11.19.4.1
	11.19.6.1
	11.19.12.1;
next	11.18;

11.18
date	2001.11.01.22.01.23;	author bparker;	state Exp;
branches;
next	11.17;

11.17
date	2001.08.10.18.45.16;	author jra;	state Exp;
branches;
next	11.16;

11.16
date	2001.06.12.18.07.14;	author jra;	state Exp;
branches;
next	11.15;

11.15
date	2001.04.20.22.31.29;	author morrison;	state Exp;
branches;
next	11.14;

11.14
date	2001.04.02.21.38.39;	author morrison;	state Exp;
branches;
next	11.13;

11.13
date	2000.11.02.02.22.01;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	2000.09.09.04.34.34;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	2000.09.09.04.32.05;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	2000.09.08.05.57.17;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	2000.08.24.22.56.19;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	2000.06.29.19.08.54;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	2000.01.04.17.58.21;	author bparker;	state Exp;
branches
	11.7.2.1;
next	11.6;

11.6
date	99.12.29.23.23.45;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	98.09.14.15.59.26;	author bparker;	state Exp;
branches;
next	11.4;

11.4
date	98.08.28.13.40.10;	author jra;	state Exp;
branches;
next	11.3;

11.3
date	97.01.22.15.51.49;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	96.07.17.13.24.29;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.18.38;	author mike;	state Rel4_4;
branches;
next	10.10;

10.10
date	95.01.04.09.03.12;	author mike;	state Exp;
branches;
next	10.9;

10.9
date	94.12.23.09.32.23;	author jra;	state Exp;
branches;
next	10.8;

10.8
date	94.11.08.04.35.52;	author mike;	state Exp;
branches;
next	10.7;

10.7
date	94.08.23.14.54.26;	author gdurf;	state Exp;
branches;
next	10.6;

10.6
date	93.10.26.03.12.02;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	93.06.09.12.21.54;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	93.06.09.12.01.00;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	92.11.18.22.21.02;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	91.10.12.21.52.17;	author mike;	state Rel4_0a;
branches;
next	10.1;

10.1
date	91.10.12.06.50.33;	author mike;	state Rel4_0;
branches;
next	9.27;

9.27
date	91.08.30.21.44.55;	author mike;	state Exp;
branches;
next	9.26;

9.26
date	91.08.30.00.12.10;	author mike;	state Exp;
branches;
next	9.25;

9.25
date	91.07.16.00.29.55;	author mike;	state Exp;
branches;
next	9.24;

9.24
date	91.07.04.01.37.57;	author mike;	state Exp;
branches;
next	9.23;

9.23
date	91.07.02.04.23.07;	author mike;	state Exp;
branches;
next	9.22;

9.22
date	91.07.01.22.58.43;	author mike;	state Exp;
branches;
next	9.21;

9.21
date	91.06.14.07.13.11;	author mike;	state Exp;
branches;
next	9.20;

9.20
date	91.06.13.08.04.18;	author mike;	state Exp;
branches;
next	9.19;

9.19
date	91.06.13.07.12.39;	author mike;	state Exp;
branches;
next	9.18;

9.18
date	91.06.13.06.50.40;	author mike;	state Exp;
branches;
next	9.17;

9.17
date	91.06.13.06.35.35;	author mike;	state Exp;
branches;
next	9.16;

9.16
date	91.06.13.06.24.13;	author mike;	state Exp;
branches;
next	9.15;

9.15
date	91.06.13.06.15.29;	author mike;	state Exp;
branches;
next	9.14;

9.14
date	91.06.13.05.57.22;	author mike;	state Exp;
branches;
next	9.13;

9.13
date	91.06.13.05.24.02;	author mike;	state Exp;
branches;
next	9.12;

9.12
date	91.06.13.04.02.15;	author mike;	state Exp;
branches;
next	9.11;

9.11
date	91.06.13.03.59.48;	author mike;	state Exp;
branches;
next	9.10;

9.10
date	91.06.13.03.18.06;	author mike;	state Exp;
branches;
next	9.9;

9.9
date	91.06.13.02.46.46;	author mike;	state Exp;
branches;
next	9.8;

9.8
date	91.06.11.02.00.35;	author mike;	state Exp;
branches;
next	9.7;

9.7
date	91.06.01.22.46.51;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	91.06.01.22.17.48;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	91.06.01.22.01.04;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	91.06.01.21.16.12;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	91.06.01.20.34.47;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	91.06.01.00.52.19;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.14.10;	author mike;	state Rel3_5;
branches;
next	8.3;

8.3
date	89.05.07.23.40.37;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	89.04.24.08.28.42;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.53.06;	author mike;	state Rel3_0;
branches;
next	7.1;

7.1
date	87.11.03.00.28.08;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.08.17.05;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.48.58;	author mike;	state Rel;
branches;
next	4.4;

4.4
date	87.02.26.13.41.56;	author moss;	state Exp;
branches;
next	4.3;

4.3
date	87.02.25.09.36.28;	author moss;	state Exp;
branches;
next	4.2;

4.2
date	87.02.13.00.55.18;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.02.53.15;	author mike;	state Rel1;
branches;
next	2.17;

2.17
date	86.09.23.21.11.42;	author mike;	state Exp;
branches;
next	2.16;

2.16
date	86.08.13.09.17.32;	author mike;	state Exp;
branches;
next	2.15;

2.15
date	86.08.13.08.15.54;	author mike;	state Exp;
branches;
next	2.14;

2.14
date	86.08.13.08.15.29;	author mike;	state Exp;
branches;
next	2.13;

2.13
date	86.08.13.08.14.52;	author mike;	state Exp;
branches;
next	2.12;

2.12
date	86.08.13.08.14.19;	author mike;	state Exp;
branches
	2.12.1.1;
next	2.11;

2.11
date	86.08.13.08.13.51;	author mike;	state Exp;
branches;
next	2.10;

2.10
date	86.08.13.08.13.24;	author mike;	state Exp;
branches;
next	2.9;

2.9
date	86.08.13.08.12.56;	author mike;	state Exp;
branches;
next	2.8;

2.8
date	86.08.13.08.12.28;	author mike;	state Exp;
branches;
next	2.7;

2.7
date	86.08.13.08.12.05;	author mike;	state Exp;
branches;
next	2.6;

2.6
date	86.08.13.08.11.41;	author mike;	state Exp;
branches;
next	2.5;

2.5
date	86.08.13.08.11.13;	author mike;	state Exp;
branches;
next	2.4;

2.4
date	86.08.13.08.10.46;	author mike;	state Exp;
branches;
next	2.3;

2.3
date	86.08.13.08.10.19;	author mike;	state Exp;
branches;
next	2.2;

2.2
date	86.08.13.08.09.49;	author mike;	state Exp;
branches;
next	2.1;

2.1
date	86.08.13.08.09.24;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	86.08.13.08.08.56;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	86.08.13.08.08.30;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	86.08.13.08.08.03;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	86.08.13.08.07.41;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	86.08.13.08.07.12;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	86.08.13.08.06.45;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	86.08.13.08.06.23;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	86.08.13.08.06.02;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	86.08.13.08.05.44;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	86.08.13.08.05.25;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	86.08.13.08.05.06;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	86.08.13.08.04.45;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	86.08.13.08.04.24;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	86.08.13.08.03.53;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	86.08.13.08.03.42;	author mike;	state Exp;
branches;
next	;

2.12.1.1
date	86.08.13.09.14.10;	author mike;	state Exp;
branches;
next	;

11.7.2.1
date	2001.07.11.12.32.09;	author jra;	state Exp;
branches;
next	;

11.19.4.1
date	2004.03.17.21.23.39;	author morrison;	state Exp;
branches;
next	;

11.19.6.1
date	2004.03.11.23.52.42;	author morrison;	state Exp;
branches;
next	11.19.6.2;

11.19.6.2
date	2004.03.12.07.02.34;	author morrison;	state Exp;
branches;
next	11.19.6.3;

11.19.6.3
date	2004.03.12.07.03.37;	author morrison;	state Exp;
branches;
next	11.19.6.4;

11.19.6.4
date	2004.03.12.07.04.39;	author morrison;	state Exp;
branches;
next	;

11.19.12.1
date	2004.02.12.19.43.52;	author erikg;	state Exp;
branches;
next	11.19.12.2;

11.19.12.2
date	2004.03.15.14.08.23;	author erikg;	state Exp;
branches;
next	;


desc
@@


11.22
log
@moved to src/vdeck/
@
text
@/*
 *			V D E C K
 *
 *  Author -
 *	Gary S. Moss
 *	U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground
 *	Maryland 21005-5066
 *	(301)278-6647 or AV-298-6647
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1990-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/vdeck/vdeck.c,v 11.21 2004/05/10 15:30:51 erikg Exp $ (BRL)";
#endif

/*
	Derived from KARDS, written by Keith Applin.

	Generate a COM-GEOM card images suitable for input to gift5
	(also gift(1V)) from an mged(1V) target description.

	There are 3 files generated at a time, the Solid table, Region table,
	and Ident table, which when concatenated in that order, make a
	COM-GEOM deck.  The record formats in the order that they appear, are
	described below, and are strictly column oriented.

	Note that the Solid table begins with a Title and a Control card, the
	rest of the record types appear once for each object, that is, one
	Solid record for each Solid, one Region and one
  	Ident record for each Region as totaled on the Control card, however,
  	the Solid and Region records may span more than 1 card.

----------------------------------------------------------------------------
|File|Record  :             Contents              :       Format           |
|----|---------------------------------------------------------------------|
| 1  |Title   : target_units, title               : a2,3x,a60              |
|    |Control : #_of_solids, #_of_regions         : i5,i5                  |
|    |Solid   : sol_#,sol_type,params.,comment    : i5,a5,6f10.0,a10       |
|    | cont'  : sol_#,parameters,comment          : i5,5x,6f10.0,a10       |
|----|---------------------------------------------------------------------|
| 2  |Region  : reg_#,(op,[sol/reg]_#)*,comment   : i5,1x,9(a2,i5),1x,a10  |
|    | cont'  : reg_#,(op,[sol/reg]_#)*,comment   : i5,1x,9(a2,i5),1x,a10  |
|----|---------------------------------------------------------------------|
| 3  |Flag    : a -1 marks end of region table    : i5                     |
|    |Idents  : reg_#,ident,space,mat,%,descriptn : 5i5,5x,a50             |
|--------------------------------------------------------------------------|

 */
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <signal.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include <math.h>

#include "machine.h"
#include "vmath.h"
#include "externs.h"
#include "rtstring.h"
#include "raytrace.h"
#include "rtgeom.h"

#include "./vextern.h"

#include "../librt/debug.h"

int	debug = 0;

char	*cmd[] = {
	"",
	"C O M M A N D                  D E S C R I P T I O N",
	"",
	"deck [output file prefix]      Produce COM GEOM card deck.",
	"erase                          Erase current list of objects.",
	"insert [object[s]]             Add an object to current list.",
	"list [object[s]]               Display current list of selected objects.",
	"number [solid] [region]        Specify starting numbers for objects.",
	"quit                           Terminate run.",
	"remove [object[s]]             Remove an object from current list.",
	"sort                           Sort table of contents alphabetically.",
	"toc [object[s]]                Table of contents of solids database.",
	"! [shell command]              Execute a UNIX shell command.",
	"",
	"NOTE:",
	"First letter of command is sufficient, and all arguments are optional.",
	"Objects may be specified with string matching operators (*, [], -, ? or \\)",
	"as in the UNIX shell.",
	0
};

char	*usage[] = {
	"",
	"v d e c k ($Revision: 11.21 $)",
	"Make COMGEOM decks of objects from a \"mged\" file suitable as",
	"input to GIFT5 or gift(1V).",
	"",
	"Usage: vdeck file.g",
	"",
	0
};

/*  These arrays are now dynamically allocated by toc() */

char	**toc_list;		/* Sorted table of contents. */
char	**curr_list;		/* regions and solids to be processed. */
int	curr_ct = 0;
char	**tmp_list;		/* Temporary list of names */
int	tmp_ct = 0;

/* List of arguments from command line parser.				*/
char	*arg_list[MAXARG];
int	arg_ct = 0;

/* Structure used by setjmp() and longjmp() to save environment.	*/
jmp_buf	env;

/* File names and descriptors.						*/
char	*objfile;
FILE	*regfp;		
struct bu_vls	rt_vls;
struct bu_vls	st_vls;
struct bu_vls	id_vls;
char	*rt_file;
FILE	*solfp;		
char	*st_file;
FILE	*ridfp;		
char	*id_file;

/* Counters.								*/
int	nns;		/* Solids.					*/
int	nnr;		/* Regions not members of other regions.	*/
int	ndir;		/* Entries in directory.			*/

/* Miscellaneous globals leftover from Keith's KARDS code.		*/
int		delsol = 0, delreg = 0;
char		buff[30];
long		savsol;		/* File postion of # of solids & regions */

/* Structures.								*/
mat_t		identity;

extern void		menu();
extern void		quit();

char			getarg();
void			quit(), abort_sig();

char			getcmd();
void			prompt();

void			addarb();
void			addtgc();
void			addtor();
void			addhalf();
void			addarbn();
void			addell();
void			addars();
void			deck();
void			itoa();
void			vls_blanks();
void			vls_itoa();
void			vls_ftoa_vec_cvt();
void			vls_ftoa_vec();
void			vls_ftoa_cvt();
void			vls_ftoa();
extern int		parsArg();
extern int		insert();
extern int		col_prt();
extern int		match();
extern int		delete();
extern int		shell();
extern int		cgarbs();
extern int		redoarb();

RT_EXTERN(void ewrite, (FILE *fp, const char *buf, unsigned bytes) );
RT_EXTERN(void blank_fill, (FILE *fp, int count) );

/* Head of linked list of solids */
struct soltab	sol_hd;

struct db_i	*dbip;		/* Database instance ptr */


/*
 *			P R O M P T
 *
 *  Print a non-newline-terminate string, and flush stdout
 */
void
prompt( fmt )
char	*fmt;
{
	fputs( fmt, stdout );
	fflush(stdout);
}

/*
 *			S O R T F U N C
 *
 *	Comparison function for qsort().
 */
static int
sortFunc( a, b )
#if __STDC__
const void	*a;		/* The exact template expected by qsort */
const void	*b;
#else
const genptr_t	a;
const genptr_t	b;
#endif
{
	const char **lhs = (const char **)a;
	const char **rhs = (const char **)b;

	return( strcmp( *lhs, *rhs ) );
}

/*
 *			M A I N
 */
int
main( argc, argv )
char	*argv[];
{
	setbuf( stdout, rt_malloc( BUFSIZ, "stdout buffer" ) );
	RT_LIST_INIT( &(sol_hd.l) );

	bu_vls_init( &rt_vls );
	bu_vls_init( &st_vls );
	bu_vls_init( &id_vls );

	if( ! parsArg( argc, argv ) )
	{
		menu( usage );
		exit( 1 );
	}

	rt_init_resource( &rt_uniresource, 0, NULL );

	/* Build directory from object file.	 	*/
	if( db_dirbuild(dbip) < 0 )  {
		fprintf(stderr,"db_dirbuild() failure\n");
		exit(1);
	}

	toc();		/* Build table of contents from directory.	*/

#if 0
	rt_g.debug |= DEBUG_TREEWALK;
#endif

	/*      C o m m a n d   I n t e r p r e t e r			*/
	(void) setjmp( env );/* Point of re-entry from aborted command.	*/
	prompt( CMD_PROMPT );
	while( 1 )
	{
		/* Return to default interrupt handler after every command,
		 allows exit from program only while command interpreter
		 is waiting for input from keyboard.
		 */
		(void) signal( SIGINT, quit );

		switch( getcmd( arg_list, 0 ) )
		{
		case DECK :
			deck( arg_list[1] );
			break;
		case ERASE :
			while( curr_ct > 0 )
				rt_free( curr_list[--curr_ct], "curr_list[ct]" );
			break;
		case INSERT :
			if( arg_list[1] == 0 )
			{
				prompt( "enter object[s] to insert: " );
				(void) getcmd( arg_list, arg_ct );
			}
			(void) insert( arg_list, arg_ct );
			break;
		case LIST :
			{	
				register int	i;
				if( arg_list[1] == 0 )
				{
					(void) col_prt( curr_list, curr_ct );
					break;
				}
				for( tmp_ct = 0, i = 0; i < curr_ct; i++ )
					if( match( arg_list[1], curr_list[i] ) )
						tmp_list[tmp_ct++] = curr_list[i];
				(void) col_prt( tmp_list, tmp_ct );
				break;
			}
		case MENU :
			menu( cmd );
			prompt( PROMPT );
			continue;
		case NUMBER :
			if( arg_list[1] == 0 )
			{
				prompt( "enter number of 1st solid: " );
				(void) getcmd( arg_list, arg_ct );
				prompt( "enter number of 1st region: " );
				(void) getcmd( arg_list, arg_ct );
			}
			if( arg_list[1] )
				delsol = atoi( arg_list[1] ) - 1;
			if( arg_list[2] )
				delreg = atoi( arg_list[2] ) - 1;
			break;
		case REMOVE :
			if( arg_list[1] == 0 )
			{
				prompt( "enter object[s] to remove: " );
				(void) getcmd( arg_list, arg_ct );
			}
			(void) delete( arg_list );
			break;
		case RETURN :
			prompt( PROMPT );
			continue;
		case SHELL :
			if( arg_list[1] == 0 )
			{
				prompt( "enter shell command: " );
				(void) getcmd( arg_list, arg_ct );
			}
			(void) shell( arg_list );
			break;
		case SORT_TOC :
			qsort( (genptr_t)toc_list, (unsigned)ndir,
			    sizeof(char *), sortFunc );
			break;
		case TOC :
			list_toc( arg_list );
			break;
		case EOF :
		case QUIT :
			(void) printf( "quitting...\n" );
			goto out;
		default :
			(void) printf( "Invalid command\n" );
			prompt( PROMPT );
			continue;
		}
		prompt( CMD_PROMPT );
	}
out:
	exit( 0 );
}

/*
 *			F L A T T E N _ T R E E
 *
 *  This routine turns a union tree into a flat string.
 */
void
flatten_tree( vls, tp, op, neg )
struct rt_vls	*vls;
union tree	*tp;
char		*op;
int		neg;
{
	int	bit;

	RT_VLS_CHECK( vls );

	switch( tp->tr_op )  {

	case OP_NOP:
		rt_log("NOP\n");
		return;

	case OP_SOLID:
		bit = tp->tr_a.tu_stp->st_bit;
		if( bit < 10000 )  {
			/* Old way, just use negative number in I5 field */
			rt_vls_strncat( vls, op, 2 );
			if(neg) bit = -bit;
		} else {
			/* New way, due to Tom Sullivan of Sandia. */
			/* "or" becomes "nr", "  " becomes "nn" */
			if(neg)  {
				if( *op == ' ' )
					rt_vls_strncat( vls, "nn", 2 );
				else if( *op == 'o' && op[1] == 'r' )
					rt_vls_strncat( vls, "nr", 2 );
				else
					rt_vls_strncat( vls, "??", 2 );
			} else {
				rt_vls_strncat( vls, op, 2 );
			}
		}
		vls_itoa( vls, bit, 5 );
		/* tp->tr_a.tu_stp->st_name */
		return;

	case OP_REGION:
		rt_log("REGION 'stp'=x%x\n",
		    tp->tr_a.tu_stp );
		return;

	default:
		rt_log("Unknown op=x%x\n", tp->tr_op );
		return;

	case OP_UNION:
		flatten_tree( vls, tp->tr_b.tb_left, "or", neg );
		flatten_tree( vls, tp->tr_b.tb_right, "or", 0 );
		break;
	case OP_INTERSECT:
		flatten_tree( vls, tp->tr_b.tb_left, op, neg );
		flatten_tree( vls, tp->tr_b.tb_right, "  ", 0 );
		break;
	case OP_SUBTRACT:
		flatten_tree( vls, tp->tr_b.tb_left, op, neg );
		flatten_tree( vls, tp->tr_b.tb_right, "  ", 1 );
		break;
	}
}

/*
 *			R E G I O N _ E N D
 *
 *  This routine will be called by db_walk_tree() once all the
 *  solids in this region have been visited.
 */
union tree *region_end( tsp, pathp, curtree, client_data )
register struct db_tree_state	*tsp;
struct db_full_path	*pathp;
union tree		*curtree;
genptr_t		client_data;
{
	struct directory	*dp;
	char			*fullname;
	struct rt_vls		ident;
	struct rt_vls		reg;
	struct rt_vls		flat;
	char			obuf[128];
	char			*cp;
	int			left;
	int			length;
	struct directory	*regdp = DIR_NULL;
	int			i;
	int			first;

	RT_VLS_INIT( &ident );
	RT_VLS_INIT( &reg );
	RT_VLS_INIT( &flat );
	fullname = db_path_to_string(pathp);

	dp = DB_FULL_PATH_CUR_DIR(pathp);
	dp->d_uses++;		/* instance number */

	/* For name, find pointer to region combination */
	for( i=0; i < pathp->fp_len; i++ )  {
		regdp = pathp->fp_names[i];
		if( regdp->d_flags & DIR_REGION )  break;
	}

	nnr++;			/* Start new region */

	/* Print an indicator of our progress */
	if( debug )
		(void) printf( "%4d:%s\n", nnr+delreg, fullname );

	/*
	 *  Write the boolean formula into the region table.
	 */

	/* Convert boolean tree into string of 7-char chunks */
	if( curtree->tr_op == OP_NOP )  {
		rt_vls_strcat( &flat, "" );
	} else {
		/* Rewrite tree so that all unions are at tree top */
		db_non_union_push( curtree, &rt_uniresource );
		flatten_tree( &flat, curtree, "  ", 0 );
	}

	/* Output 9 of the 7-char chunks per region "card" */
	cp = rt_vls_addr( &flat );
	left = rt_vls_strlen( &flat );
	first = 1;

	do  {
		register char	*op;

		op = obuf;
		if( first )  {
			(void) sprintf( op, "%5d ", nnr+delreg );
			first = 0;
		} else {
			strncpy( op, "      ", 6 );
		}
		op += 6;

		if( left > 9*7 )  {
			strncpy( op, cp, 9*7 );
			cp += 9*7;
			op += 9*7;
			left -= 9*7;
		} else {
			strncpy( op, cp, left );
			op += left;
			while( left < 9*7 )  {
				*op++ = ' ';
				left++;
			}
			left = 0;
		}
		strcpy( op, regdp->d_namep );
		op += strlen(op);
		*op++ = '\n';
		*op = '\0';
		ewrite( regfp, obuf, strlen(obuf) );
	} while( left > 0 );

	/*
	 *  Write a record into the region ident table.
	 */
	vls_itoa( &ident, nnr+delreg, 5 );
	vls_itoa( &ident, tsp->ts_regionid, 5 );
	vls_itoa( &ident, tsp->ts_aircode, 5 );
	vls_itoa( &ident, tsp->ts_gmater, 5 );
	vls_itoa( &ident, tsp->ts_los, 5 );
	rt_vls_strcat( &ident, "     " );		/* 5 spaces */

	length = strlen( fullname );
	if( length > 50 )  {
		register char	*bp;

		bp = fullname + (length - 50);
		*bp = '*';
		rt_vls_strcat( &ident, bp );
	} else {
		/* Omit leading slash, for compat with old version */
		rt_vls_strcat( &ident, fullname+1 );
	}
	rt_vls_strcat( &ident, "\n" );
	rt_vls_fwrite( ridfp, &ident );

	rt_vls_free( &ident );
	rt_vls_free( &reg );
	rt_vls_free( &flat );
	rt_free( fullname, "fullname" );

	/*
	 *  Returned tree will be freed by caller.
	 *  To keep solid table available for seraching,
	 *  add this tree to a list of trees to be released once
	 *  everything is finished.
	 */
	/* XXX Should make list of "regions" (trees) here */
	return  (union tree *)0;
}

/*
 *			G E T T R E E _ L E A F
 *
 *  Re-use the librt "soltab" structures here, for our own purposes.
 */
union tree *gettree_leaf( tsp, pathp, ip, client_data )
struct db_tree_state	*tsp;
struct db_full_path	*pathp;
struct rt_db_internal	*ip;
genptr_t		client_data;
{
	register fastf_t	f;
	register struct soltab	*stp;
	union tree		*curtree;
	struct directory	*dp;
	struct rt_vls		sol;
	register int		i;
	register matp_t		mat;

	RT_VLS_INIT( &sol );

	RT_CK_DB_INTERNAL(ip);
	dp = DB_FULL_PATH_CUR_DIR(pathp);

	/* Determine if this matrix is an identity matrix */
	for( i=0; i<16; i++ )  {
		f = tsp->ts_mat[i] - rt_identity[i];
		if( !NEAR_ZERO(f, 0.0001) )
			break;
	}
	if( i < 16 )  {
		/* Not identity matrix */
		mat = tsp->ts_mat;
	} else {
		/* Identity matrix */
		mat = (matp_t)0;
	}

	/*
	 *  Check to see if this exact solid has already been processed.
	 *  Match on leaf name and matrix.
	 */
	for( RT_LIST_FOR( stp, soltab, &(sol_hd.l) ) )  {
		RT_CHECK_SOLTAB(stp);				/* debug */

		/* Leaf solids must be the same */
		if( dp != stp->st_dp )  continue;

		if( mat == (matp_t)0 )  {
			if( stp->st_matp == (matp_t)0 )  {
				if( debug )
					rt_log("rt_gettree_leaf:  %s re-referenced (ident)\n",
						dp->d_namep );
				goto found_it;
			}
			goto next_one;
		}
		if( stp->st_matp == (matp_t)0 )  goto next_one;

		for( i=0; i<16; i++ )  {
			f = mat[i] - stp->st_matp[i];
			if( !NEAR_ZERO(f, 0.0001) )
				goto next_one;
		}
		/* Success, we have a match! */
		if( debug )  {
			rt_log("rt_gettree_leaf:  %s re-referenced\n",
			    dp->d_namep );
		}
		goto found_it;
next_one: 
		;
	}

	GETSTRUCT(stp, soltab);
	stp->l.magic = RT_SOLTAB_MAGIC;
	stp->st_id = ip->idb_type;
	stp->st_dp = dp;
	if( mat )  {
		stp->st_matp = (matp_t)rt_malloc( sizeof(mat_t), "st_matp" );
		MAT_COPY( stp->st_matp, mat );
	} else {
		stp->st_matp = mat;
	}
	stp->st_specific = (genptr_t)0;

	/* init solid's maxima and minima */
	VSETALL( stp->st_max, -INFINITY );
	VSETALL( stp->st_min,  INFINITY );

	RT_CK_DB_INTERNAL( ip );

	if(debug)  {
		struct rt_vls	str;
		rt_vls_init( &str );
		/* verbose=1, mm2local=1.0 */
		if( ip->idb_meth->ft_describe( &str, ip, 1, 1.0, &rt_uniresource, dbip ) < 0 )  {
			rt_log("rt_gettree_leaf(%s):  solid describe failure\n",
			    dp->d_namep );
		}
		bu_log( "%s:  %s", dp->d_namep, rt_vls_addr( &str ) );
		bu_vls_free( &str );
	}

	/* For now, just link them all onto the same list */
	RT_LIST_INSERT( &(sol_hd.l), &(stp->l) );

	stp->st_bit = ++nns;

	/* Solid number is stp->st_bit + delsol */

	/* Process appropriate solid type.				*/
	switch( ip->idb_type )  {
	case ID_TOR:
		addtor( &sol, (struct rt_tor_internal *)ip->idb_ptr,
		    dp->d_namep, stp->st_bit+delsol );
		break;
	case ID_ARB8:
		addarb( &sol, (struct rt_arb_internal *)ip->idb_ptr,
		    dp->d_namep, stp->st_bit+delsol );
		break;
	case ID_ELL:
		addell( &sol, (struct rt_ell_internal *)ip->idb_ptr,
		    dp->d_namep, stp->st_bit+delsol );
		break;
	case ID_TGC:
		addtgc( &sol, (struct rt_tgc_internal *)ip->idb_ptr,
		    dp->d_namep, stp->st_bit+delsol );
		break;
	case ID_ARS:
		addars( &sol, (struct rt_ars_internal *)ip->idb_ptr,
		    dp->d_namep, stp->st_bit+delsol );
		break;
	case ID_HALF:
		addhalf( &sol, (struct rt_half_internal *)ip->idb_ptr,
		    dp->d_namep, stp->st_bit+delsol );
		break;
	case ID_ARBN:
		addarbn( &sol, (struct rt_arbn_internal *)ip->idb_ptr,
		    dp->d_namep, stp->st_bit+delsol );
		break;
	case ID_PIPE:
		/* XXX */
	default:
		(void) fprintf( stderr,
		    "vdeck: '%s' Primitive type %s has no corresponding COMGEOM primitive, skipping\n",
		    dp->d_namep, ip->idb_meth->ft_name );
		vls_itoa( &sol, stp->st_bit+delsol, 5 );
		rt_vls_strcat( &sol, ip->idb_meth->ft_name );
		vls_blanks( &sol, 5*10 );
		rt_vls_strcat( &sol, dp->d_namep );
		rt_vls_strcat( &sol, "\n");
		break;
	}

	rt_vls_fwrite( solfp, &sol );
	rt_vls_free( &sol );

found_it:
	GETUNION( curtree, tree );
	curtree->magic = RT_TREE_MAGIC;
	curtree->tr_op = OP_SOLID;
	curtree->tr_a.tu_stp = stp;
	curtree->tr_a.tu_regionp = (struct region *)0;

	return(curtree);
}

void
swap_vec( v1, v2 )
vect_t	v1, v2;
{
	vect_t	work;

	VMOVE( work, v1 );
	VMOVE( v1, v2 );
	VMOVE( v2, work );
}

void
swap_dbl( d1, d2 )
register double	*d1, *d2;
{	
	double	t;
	t = *d1;
	*d1 = *d2;
	*d2 = t;
	return;
}

/*
 *			A D D T O R
 *
 *  Process torus.
 */
void
addtor( v, gp, name, num )
struct rt_vls		*v;
struct rt_tor_internal	*gp;
char			*name;
int			num;
{
	RT_VLS_CHECK(v);
	RT_TOR_CK_MAGIC(gp);

	/* V, N, r1, r2 */
	vls_itoa( v, num, 5 );
	rt_vls_strcat( v, "tor  " );		/* 5 */
	vls_ftoa_vec_cvt( v, gp->v, 10, 4 );
	vls_ftoa_vec( v, gp->h, 10, 4 );
	rt_vls_strcat( v, name );
	rt_vls_strcat( v, "\n" );

	vls_itoa( v, num, 5 );
	vls_blanks( v, 5 );
	vls_ftoa_cvt( v, gp->r_a, 10, 4 );
	vls_ftoa_cvt( v, gp->r_h, 10, 4 );
	vls_blanks( v, 4*10 );
	rt_vls_strcat( v, name );
	rt_vls_strcat( v, "\n");
}

/*
 *			A D D H A L F
 */
void
addhalf( v, gp, name, num )
struct rt_vls		*v;
struct rt_half_internal	*gp;
char			*name;
int			num;
{
	RT_VLS_CHECK(v);
	RT_HALF_CK_MAGIC(gp);

	/* N, d */
	vls_itoa( v, num, 5 );
	rt_vls_strcat( v, "haf  " );		/* 5 */
	vls_ftoa_vec( v, gp->eqn, 10, 4 );
	vls_ftoa_cvt( v, -(gp->eqn[3]), 10, 4 );
	vls_blanks( v, 2*10 );
	rt_vls_strcat( v, name );
	rt_vls_strcat( v, "\n" );
}

/*
 *			A D D A R B N
 */
void
addarbn( v, gp, name, num )
struct rt_vls		*v;
struct rt_arbn_internal	*gp;
char			*name;
int			num;
{
	register int	i;

	RT_VLS_CHECK(v);
	RT_ARBN_CK_MAGIC(gp);

	/* nverts, nverts_index_nums, nplane_eqns, naz_el */
	vls_itoa( v, num, 5 );
	rt_vls_strcat( v, "arbn " );		/* 5 */
	vls_itoa( v, 0, 10 );			/* vertex points, 2/card */
	vls_itoa( v, 0, 10 );			/* vertex index #, 6/card */
	vls_itoa( v, gp->neqn, 10 );		/* plane eqn, 1/card */
	vls_itoa( v, 0, 10 );			/* az/el & index #, 2/card */
	vls_blanks( v, 20 );
	rt_vls_strcat( v, name );
	rt_vls_strcat( v, "\n" );

	for( i=0; i < gp->neqn; i++ )  {
		vls_itoa( v, num, 5 );
		vls_blanks( v, 5 );
		vls_ftoa_vec( v, gp->eqn[i], 10, 4 );
		vls_ftoa_cvt( v, gp->eqn[i][3], 10, 4 );
		vls_blanks( v, 2*10 );
		rt_vls_strcat( v, name );
		rt_vls_strcat( v, "\n" );
	}
}

static void
vls_solid_pts( v, pts, npts, name, num, kind )
struct rt_vls	*v;
const point_t	pts[];
const int	npts;
const char	*name;
const int	num;
const char	*kind;
{
	register int	i;

	for( i = 0; i < npts; )  {
		vls_itoa( v, num, 5 );
		if( i == 0 )
			rt_vls_strncat( v, kind, 5 );
		else
			rt_vls_strcat( v, "     " );
		vls_ftoa_vec_cvt( v, pts[i], 10, 4 );
		if( ++i < npts )  {
			vls_ftoa_vec_cvt( v, pts[i], 10, 4 );
		} else {
			vls_blanks( v, 3*10 );
		}
		i++;
		rt_vls_strcat( v, name );
		rt_vls_strcat( v, "\n");
	}
}

/*
 *			A D D A R B
 *
 *  Process generalized arb.
 */
void
addarb( v, gp, name, num )
struct rt_vls		*v;
struct rt_arb_internal	*gp;
char			*name;
int			num;
{
	register int	i;
	int	uniq_pts[8];
	int	samevecs[11];
	int	cgtype;
	point_t	pts[8];		/* GIFT-order points */

	/* Enter new arb code.						*/
	if( (i = cgarbs( &cgtype, gp, uniq_pts, samevecs, CONV_EPSILON )) == 0 ||
	    redoarb( pts, gp, uniq_pts, samevecs, i, cgtype ) == 0 )  {
		fprintf(stderr,"vdeck: addarb(%s): failure\n", name);
		vls_itoa( v, num, 5 );
		rt_vls_strncat( v, "arb??", 5 );
		vls_blanks( v, 6*10 );
		rt_vls_strcat( v, name );
		rt_vls_strcat( v, "\n");
		return;
	}

	/* Print the solid parameters.					*/
	switch( cgtype )  {
	case 8:
		vls_solid_pts( v, (const point_t *)pts, 8, name, num, "arb8 " );
		break;
	case 7:
		vls_solid_pts( v, (const point_t *)pts, 7, name, num, "arb7 " );
		break;
	case 6:
		VMOVE( pts[5], pts[6] );
		vls_solid_pts( v, (const point_t *)pts, 6, name, num, "arb6 " );
		break;
	case 5:
		vls_solid_pts( v, (const point_t *)pts, 5, name, num, "arb5 " );
		break;
	case 4:
		VMOVE( pts[3], pts[4] );
		vls_solid_pts( v, (const point_t *)pts, 4, name, num, "arb4 " );
		break;

		/* Currently, cgarbs() will not return RAW, BOX, or RPP */
	default:
		(void) fprintf( stderr, "addarb: Unknown arb cgtype=%d.\n",
		    cgtype );
		exit( 10 );
	}
}

#define GENELL	1
#define	ELL1	2
#define SPH	3

/*
 *			A D D E L L 
 *
 *	Process the general ellipsoid.
 */
void
addell( v, gp, name, num )
struct rt_vls		*v;
struct rt_ell_internal	*gp;
char			*name;
int			num;
{
	double	ma, mb, mc;
	int	cgtype;

	/* Check for ell1 or sph.					*/
	ma = MAGNITUDE( gp->a );
	mb = MAGNITUDE( gp->b );
	mc = MAGNITUDE( gp->c );
	if( fabs( ma-mb ) < CONV_EPSILON )  {
		/* vector A == vector B */
		cgtype = ELL1;
		/* SPH if vector B == vector C also */
		if( fabs( mb-mc ) < CONV_EPSILON )
			cgtype = SPH;
		else	/* switch A and C */
		{
			swap_vec( gp->a, gp->c );
			swap_dbl( &ma, &mc );
		}
	} else if( fabs( ma-mc ) < CONV_EPSILON ) {
		/* vector A == vector C */
		cgtype = ELL1;
		/* switch vector A and vector B */
		swap_vec( gp->a, gp->b );
		swap_dbl( &ma, &mb );
	} else if( fabs( mb-mc ) < CONV_EPSILON )
		cgtype = ELL1;
	else
		cgtype = GENELL;

	/* Print the solid parameters.					*/
	vls_itoa( v, num, 5 );
	switch( cgtype )  {
	case GENELL:
		rt_vls_strcat( v, "ellg " );		/* 5 */
		vls_ftoa_vec_cvt( v, gp->v, 10, 4 );
		vls_ftoa_vec_cvt( v, gp->a, 10, 4 );
		rt_vls_strcat( v, name );
		rt_vls_strcat( v, "\n" );

		vls_itoa( v, num, 5 );
		vls_blanks( v, 5 );
		vls_ftoa_vec_cvt( v, gp->b, 10, 4 );
		vls_ftoa_vec_cvt( v, gp->c, 10, 4 );
		rt_vls_strcat( v, name );
		rt_vls_strcat( v, "\n");
		break;
	case ELL1:
		rt_vls_strcat( v, "ell1 " );		/* 5 */
		vls_ftoa_vec_cvt( v, gp->v, 10, 4 );
		vls_ftoa_vec_cvt( v, gp->a, 10, 4 );
		rt_vls_strcat( v, name );
		rt_vls_strcat( v, "\n" );

		vls_itoa( v, num, 5 );
		vls_blanks( v, 5 );
		vls_ftoa_cvt( v, mb, 10, 4 );
		vls_blanks( v, 5*10 );
		rt_vls_strcat( v, name );
		rt_vls_strcat( v, "\n");
		break;
	case SPH:
		rt_vls_strcat( v, "sph  " );		/* 5 */
		vls_ftoa_vec_cvt( v, gp->v, 10, 4 );
		vls_ftoa_cvt( v, ma, 10, 4 );
		vls_blanks( v, 2*10 );
		rt_vls_strcat( v, name );
		rt_vls_strcat( v, "\n" );
		break;
	default:
		(void) fprintf( stderr,
		    "Error in type of ellipse (%d).\n",
		    cgtype
		    );
		exit( 10 );
	}
}

#define TGC	1
#define TEC	2
#define TRC	3
#define REC	4
#define RCC	5

/*
 *			A D D T G C
 *
 *	Process generalized truncated cone.
 */
void
addtgc( v, gp, name, num )
struct rt_vls		*v;
struct rt_tgc_internal	*gp;
char			*name;
int			num;
{
	vect_t	axb, cxd;
	double	ma, mb, mc, md, maxb, mcxd, mh;
	int	cgtype;

	/* Check for tec rec trc rcc.					*/
	cgtype = TGC;
	VCROSS( axb, gp->a, gp->b );
	VCROSS( cxd, gp->c, gp->d );

	ma = MAGNITUDE( gp->a );
	mb = MAGNITUDE( gp->b );
	mc = MAGNITUDE( gp->c );
	md = MAGNITUDE( gp->d );
	maxb = MAGNITUDE( axb );
	mcxd = MAGNITUDE( cxd );
	mh = MAGNITUDE( gp->h );

	if( ma <= 0.0 || mb <= 0.0 )  {
		fprintf(stderr, "addtgc(%s): ma=%e, mb=%e, skipping\n", name, ma, mb );
		return;
	}

	/* TEC if ratio top and bot vectors equal and base parallel to top.
	 */
	if( mc != 0.0 && md != 0.0 &&
	    fabs( (mb/md)-(ma/mc) ) < CONV_EPSILON &&
	    fabs( fabs(VDOT(axb,cxd)) - (maxb*mcxd) ) < CONV_EPSILON )  {
		cgtype = TEC;
	}

	/* Check for right cylinder.					*/
	if( fabs( fabs(VDOT(gp->h,axb)) - (mh*maxb) ) < CONV_EPSILON )  {
		if( fabs( ma-mb ) < CONV_EPSILON )  {
			if( fabs( ma-mc ) < CONV_EPSILON )
				cgtype = RCC;
			else
				cgtype = TRC;
		} else {
			/* elliptical */
			if( fabs( ma-mc ) < CONV_EPSILON )
				cgtype = REC;
		}
	}

	/* Insure that magnitude of A is greater than B, and magnitude of 
		C is greater than D for the GIFT code (boy, is THIS a shame).
		This need only be done for the elliptical REC and TEC types.
	 */
	if( (cgtype == REC || cgtype == TEC) && ma < mb )  {
		swap_vec( gp->a, gp->b );
		swap_dbl( &ma, &mb );
		swap_vec( gp->c, gp->d );
		swap_dbl( &mc, &md );
	}

	/* Print the solid parameters.					*/
	vls_itoa( v, num, 5 );
	switch( cgtype )  {
	case TGC:
		rt_vls_strcat( v, "tgc  " );		/* 5 */
		vls_ftoa_vec_cvt( v, gp->v, 10, 4 );
		vls_ftoa_vec_cvt( v, gp->h, 10, 4 );
		rt_vls_strcat( v, name );
		rt_vls_strcat( v, "\n" );

		vls_itoa( v, num, 5 );
		vls_blanks( v, 5 );
		vls_ftoa_vec_cvt( v, gp->a, 10, 4 );
		vls_ftoa_vec_cvt( v, gp->b, 10, 4 );
		rt_vls_strcat( v, name );
		rt_vls_strcat( v, "\n");

		vls_itoa( v, num, 5 );
		vls_blanks( v, 5 );
		vls_ftoa_cvt( v, mc, 10, 4 );
		vls_ftoa_cvt( v, md, 10, 4 );
		vls_blanks( v, 4*10 );
		rt_vls_strcat( v, name );
		rt_vls_strcat( v, "\n");
		break;
	case RCC:
		rt_vls_strcat( v, "rcc  " );		/* 5 */
		vls_ftoa_vec_cvt( v, gp->v, 10, 4 );
		vls_ftoa_vec_cvt( v, gp->h, 10, 4 );
		rt_vls_strcat( v, name );
		rt_vls_strcat( v, "\n" );

		vls_itoa( v, num, 5 );
		vls_blanks( v, 5 );
		vls_ftoa_cvt( v, ma, 10, 4 );
		vls_blanks( v, 5*10 );
		rt_vls_strcat( v, name );
		rt_vls_strcat( v, "\n");
		break;
	case TRC:
		rt_vls_strcat( v, "trc  " );		/* 5 */
		vls_ftoa_vec_cvt( v, gp->v, 10, 4 );
		vls_ftoa_vec_cvt( v, gp->h, 10, 4 );
		rt_vls_strcat( v, name );
		rt_vls_strcat( v, "\n" );

		vls_itoa( v, num, 5 );
		vls_blanks( v, 5 );
		vls_ftoa_cvt( v, ma, 10, 4 );
		vls_ftoa_cvt( v, mc, 10, 4 );
		vls_blanks( v, 4*10 );
		rt_vls_strcat( v, name );
		rt_vls_strcat( v, "\n");
		break;
	case TEC:
		rt_vls_strcat( v, "tec  " );		/* 5 */
		vls_ftoa_vec_cvt( v, gp->v, 10, 4 );
		vls_ftoa_vec_cvt( v, gp->h, 10, 4 );
		rt_vls_strcat( v, name );
		rt_vls_strcat( v, "\n" );

		vls_itoa( v, num, 5 );
		vls_blanks( v, 5 );
		vls_ftoa_vec_cvt( v, gp->a, 10, 4 );
		vls_ftoa_vec_cvt( v, gp->b, 10, 4 );
		rt_vls_strcat( v, name );
		rt_vls_strcat( v, "\n");

		vls_itoa( v, num, 5 );
		vls_blanks( v, 5 );
		vls_ftoa( v, ma/mc, 10, 4 );	/* dimensionless ratio */
		vls_blanks( v, 5*10 );
		rt_vls_strcat( v, name );
		rt_vls_strcat( v, "\n");
		break;
	case REC:
		rt_vls_strcat( v, "rec  " );		/* 5 */
		vls_ftoa_vec_cvt( v, gp->v, 10, 4 );
		vls_ftoa_vec_cvt( v, gp->h, 10, 4 );
		rt_vls_strcat( v, name );
		rt_vls_strcat( v, "\n" );

		vls_itoa( v, num, 5 );
		vls_blanks( v, 5 );
		vls_ftoa_vec_cvt( v, gp->a, 10, 4 );
		vls_ftoa_vec_cvt( v, gp->b, 10, 4 );
		rt_vls_strcat( v, name );
		rt_vls_strcat( v, "\n");
		break;
	default:
		(void) fprintf( stderr,
		    "Error in tgc type (%d).\n",
		    cgtype
		    );
		exit( 10 );
	}
}

/*
 *			A R S _ C U R V E _ O U T
 */
void
ars_curve_out( v, fp, todo, curveno, num )
struct rt_vls		*v;
fastf_t			*fp;
int			todo;
int			curveno;
int			num;
{
	while( todo > 0 )  {
		vls_itoa( v, num, 5 );
		vls_blanks( v, 5 );

		/* First point */
		vls_ftoa_vec_cvt( v, fp, 10, 4 );
		fp += 3;
		todo--;

		/* Second point */
		if( todo >= 1 )  {
			vls_ftoa_vec_cvt( v, fp, 10, 4 );
			fp += 3;
			todo--;
		} else {
			vls_blanks( v, 3*10 );
		}

		rt_vls_strcat( v, "curve " );
		vls_itoa( v, curveno, 3 );
		rt_vls_strcat( v, "\n" );
	}
}

/*
 *			A D D A R S
 *
 *	Process triangular surfaced polyhedron - ars.
 */
void
addars( v, gp, name, num )
struct rt_vls		*v;
struct rt_ars_internal	*gp;
char			*name;
int			num;
{
	register int	i;

	RT_ARS_CK_MAGIC(gp);

	vls_itoa( v, num, 5 );
	rt_vls_strcat( v, "ars  " );		/* 5 */
	vls_itoa( v, gp->ncurves, 10 );
	vls_itoa( v, gp->pts_per_curve, 10 );
	vls_blanks( v, 4*10 );
	rt_vls_strcat( v, name );
	rt_vls_strcat( v, "\n" );

	for( i=0; i < gp->ncurves; i++ )  {
		/* Output the points on this curve */
		ars_curve_out( v, gp->curves[i], gp->pts_per_curve, i, num );
	}
}

/*	e w r i t e
	Write with error checking.
 */
void
ewrite( fp, buf, bytes )
FILE		*fp;
const char	*buf;
unsigned	bytes;
{	
	if( bytes == 0 )  return;

	if( fwrite( buf, bytes, 1, fp ) != 1 )  {
		perror("write");
		(void)fprintf(stderr, "vdeck: write error\n");
		exit(2);
	}
}

/*
	Section 1:	C O M M A N D S

			deck()
			shell()
 */

/*	d e c k ( )
	make a COMGEOM deck for current list of objects

 */
void
deck( prefix )
register char *prefix;
{	
	nns = nnr = 0;

	/* Create file for solid table.					*/
	if( prefix != 0 )
	{
		(void) bu_vls_strcpy( &st_vls, prefix );
		(void) bu_vls_strcat( &st_vls, ".st" );
	}
	else
		(void) bu_vls_strcpy( &st_vls, "solids" );
	st_file = bu_vls_addr( &st_vls );
	if( (solfp = fopen( st_file, "w")) == NULL )  {
		perror( st_file );
		exit( 10 );
	}


	/* Target units (a2,3x)						*/
	ewrite( solfp, rt_units_string(dbip->dbi_local2base), 2 );
	blank_fill( solfp, 3 );

	/* Title							*/
	if( dbip->dbi_title == NULL )
		ewrite( solfp, objfile, (unsigned) strlen( objfile ) );
	else
		ewrite( solfp, dbip->dbi_title, (unsigned) strlen( dbip->dbi_title ) );
	ewrite( solfp, LF, 1 );

	/* Save space for number of solids and regions.			*/
	savsol = ftell( solfp );
	blank_fill( solfp, 10 );
	ewrite( solfp, LF, 1 );

	/* Create file for region table.				*/
	if( prefix != 0 )
	{
		(void) bu_vls_strcpy( &rt_vls, prefix );
		(void) bu_vls_strcat( &rt_vls, ".rt" );
	}
	else
		(void) bu_vls_strcpy( &rt_vls, "regions" );
	rt_file = bu_vls_addr( &rt_vls );
	if( (regfp = fopen( rt_file, "w" )) == NULL )  {
		perror( rt_file );
		exit( 10 );
	}

	/* create file for region ident table
	 */
	if( prefix != 0 )
	{
		(void) bu_vls_strcpy( &id_vls, prefix );
		(void) bu_vls_strcat( &id_vls, ".id" );
	}
	else
		(void) bu_vls_strcpy( &id_vls, "region_ids" );
	id_file = bu_vls_addr( &id_vls );
	if( (ridfp = fopen( id_file, "w" )) == NULL )  {
		perror( id_file );
		exit( 10 );
	}
	itoa( -1, buff, 5 );
	ewrite( ridfp, buff, 5 );
	ewrite( ridfp, LF, 1 );

	/* Initialize matrices.						*/
	MAT_IDN( identity );

	if( !sol_hd.l.magic )  RT_LIST_INIT( &sol_hd.l );

	/*  Build the whole card deck.	*/
	/*  '1' indicates one CPU.  This code isn't ready for parallelism */
	if( db_walk_tree( dbip, curr_ct, (const char **)curr_list,
	    1, &rt_initial_tree_state,
	    0, region_end, gettree_leaf, (genptr_t)NULL ) < 0 )  {
		fprintf(stderr,"Unable to treewalk any trees!\n");
	    	exit(11);
	}

	/* Go back, and add number of solids and regions on second card. */
	fseek( solfp, savsol, 0 );
	itoa( nns, buff, 5 );
	ewrite( solfp, buff, 5 );
	itoa( nnr, buff, 5 );
	ewrite( solfp, buff, 5 );

	/* Finish region id table.					*/
	ewrite( ridfp, LF, 1 );

	(void) printf( "====================================================\n" );
	(void) printf( "O U T P U T    F I L E S :\n\n" );
	(void) printf( "solid table = \"%s\"\n", st_file );
	(void) printf( "region table = \"%s\"\n", rt_file );
	(void) printf( "region identification table = \"%s\"\n", id_file );
	(void) fclose( solfp );
	(void) fclose( regfp );
	(void) fclose( ridfp );

	/* reset starting numbers for solids and regions
	 */
	delsol = delreg = 0;
	/* XXX should free soltab list */
}

/*	s h e l l ( )
	Execute shell command.
 */
int
shell( args )
char  *args[];
{
	register char	*from, *to;
	char		*argv[4], cmdbuf[MAXLN];
	int		pid, ret, status;
	register int	i;

	(void) signal( SIGINT, SIG_IGN );

	/* Build arg vector.						*/
	argv[0] = "Shell( deck )";
	argv[1] = "-c";
	to = argv[2] = cmdbuf;
	for( i = 1; i < arg_ct; i++ ) {
		from = args[i];
		if( (to + strlen( args[i] )) - argv[2] > MAXLN - 1 ) {
			(void) fprintf( stderr, "\ncommand line too long\n" );
			exit( 10 );
		}
		(void) printf( "%s ", args[i] );
		while( *from )
			*to++ = *from++;
		*to++ = ' ';
	}
	to[-1] = '\0';
	(void) printf( "\n" );
	argv[3] = 0;
	if( (pid = fork()) == -1 ) {
		perror( "shell()" );
		return( -1 );
	} else	if( pid == 0 ) { /*
				  * CHILD process - execs a shell command
					  */
		(void) signal( SIGINT, SIG_DFL );
		(void) execv( "/bin/sh", argv );
		perror( "/bin/sh -c" );
		exit( 99 );
	} else	/*
		 * PARENT process - waits for shell command
		 * to finish.
			 */
		do {
			if( (ret = wait( &status )) == -1 ) {
				perror( "wait( /bin/sh -c )" );
				break;
			}
		} while( ret != pid );
	return( 0 );
}

/*	t o c ( )
	Build a sorted list of names of all the objects accessable
	in the object file.
 */
void
toc()
{
	register struct directory *dp;
	register int		i;
	register int		count;

	/* Determine necessary table size */
	count = 0;
	for( i = 0; i < RT_DBNHASH; i++ )  {
		for( dp = dbip->dbi_Head[i]; dp != DIR_NULL; dp=dp->d_forw )  {
			count++;
		}
	}
	count += 1;		/* Safety */

	/* Allocate tables */
	toc_list = (char **)rt_malloc( count * sizeof(char *), "toc_list[]" );
	tmp_list = (char **)rt_malloc( count * sizeof(char *), "tmp_list[]" );
	curr_list = (char **)rt_malloc( count * sizeof(char *), "curr_list[]" );
	ndir = 0;

	/* Fill in toc_list[] */
	for( i = 0; i < RT_DBNHASH; i++ )  {
		for( dp = dbip->dbi_Head[i]; dp != DIR_NULL; dp=dp->d_forw )  {
			toc_list[ndir++] = dp->d_namep;
		}
	}
}

/*
	Section 3:	L I S T   P R O C E S S I N G   R O U T I N E S

			list_toc()
			col_prt()
			insert()
			delete()
*/

/*	l i s t _ t o c ( )
	List the table of contents.
 */
void
list_toc( args )
char	 *args[];
{	
	register int	i, j;
	(void) fflush( stdout );
	for( tmp_ct = 0, i = 1; args[i] != NULL; i++ )
	{
		for( j = 0; j < ndir; j++ )
		{
			if( match( args[i], toc_list[j] ) )
				tmp_list[tmp_ct++] = toc_list[j];
		}
	}
	if( i > 1 )
		(void) col_prt( tmp_list, tmp_ct );
	else
		(void) col_prt( toc_list, ndir );
	return;
}

#define NAMESIZE	16
#define MAX_COL	(NAMESIZE*5)
#define SEND_LN()	{\
			buf[column++] = '\n';\
			ewrite( stdout, buf, (unsigned) column );\
			column = 0;\
			}

/*	c o l _ p r t ( )
	Print list of names in tabular columns.
 */
int
col_prt( list, ct )
register char	*list[];
register int	ct;
{	
	char		buf[MAX_COL+2];
	register int	i, column, spaces;

	for( i = 0, column = 0; i < ct; i++ )
	{
		if( column + (int)strlen( list[i] ) > MAX_COL )
		{
			SEND_LN();
			i--;
		}
		else
		{
			(void) strcpy( &buf[column], list[i] );
			column += strlen( list[i] );
			spaces = NAMESIZE - (column % NAMESIZE );
			if( column + spaces < MAX_COL )
				for( ; spaces > 0; spaces-- )
					buf[column++] = ' ';
			else
				SEND_LN();
		}
	}
	SEND_LN();
	return	ct;
}

/*	i n s e r t ( )
	Insert each member of the table of contents 'toc_list' which
	matches one of the arguments into the current list 'curr_list'.
 */
int
insert(  args,	ct )
char		*args[];
register int	ct;
{	
	register int	i, j, nomatch;

	/* For each argument (does not include args[0]).			*/
	for( i = 1; i < ct; i++ )
	{ /* If object is in table of contents, insert in current list.	*/
		nomatch = YES;
		for( j = 0; j < ndir; j++ )
		{
			if( match( args[i], toc_list[j] ) )
			{
				nomatch = NO;
				/* Allocate storage for string.			*/
				curr_list[curr_ct++] = rt_strdup(toc_list[j]);
			}
		}
		if( nomatch )
			(void) fprintf( stderr,
			    "Object \"%s\" not found.\n", args[i] );
	}
	return	curr_ct;
}

/*	d e l e t e ( )
	delete all members of current list 'curr_list' which match
	one of the arguments
 */
int
delete(  args )
char	*args[];
{
	register int	i;
	register int	nomatch;

	/* for each object in arg list
	 */
	for( i = 1; i < arg_ct; i++ ) { 
		register int	j;
		nomatch = YES;

		/* traverse list to find string
		 */
		for( j = 0; j < curr_ct; )
			if( match( args[i], curr_list[j] ) )
			{	
				register int	k;

				nomatch = NO;
				rt_free( curr_list[j], "curr_list" );
				--curr_ct;
				/* starting from bottom of list,
				 * pull all entries up to fill up space
				 made by deletion
				 */
				for( k = j; k < curr_ct; k++ )
					curr_list[k] = curr_list[k+1];
			} 
			else	++j;
		if( nomatch )
			(void) fprintf( stderr,
			    "Object \"%s\" not found.\n",
			    args[i]
			    );
	}
	return( curr_ct );
}

/*
	Section 4:	S T R I N G   P R O C E S S I N G   R O U T I N E S

			itoa()
			check()
 */

/*	i t o a ( )
	Convert integer to ascii  wd format.
 */
void
itoa( n, s, w )
register
char	*s;
register
int   n,    w;
{
	int	 c, i, j, sign;

	if( (sign = n) < 0 )	n = -n;
	i = 0;
	do	
		s[i++] = n % 10 + '0';	
	while( (n /= 10) > 0 );
	if( sign < 0 )	s[i++] = '-';

	/* Blank fill array.					*/
	for( j = i; j < w; j++ )	s[j] = ' ';
	if( i > w ) {
		s[w-1] = (s[w]-1-'0')*10 + (s[w-1]-'0')  + 'A';
	}
	s[w] = '\0';

	/* Reverse the array.					*/
	for( i = 0, j = w - 1; i < j; i++, j-- ) {
		c    = s[i];
		s[i] = s[j];
		s[j] =    c;
	}
}

void
vls_blanks( v, n )
struct rt_vls	*v;
int		n;
{
	RT_VLS_CHECK(v);
	rt_vls_strncat( v, "                                                                                                                                ",
	    n);
}

/*
 *			V L S _ I T O A
 *
 *	Convert integer to ascii  wd format.
 */
void
vls_itoa( v, n, w )
struct rt_vls	*v;
register int	n;
register int	w;
{
	int	 c, i, j, sign;
	register char	*s;

	RT_VLS_CHECK(v);
	rt_vls_strncat( v, "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx", w);
	s = rt_vls_addr(v)+rt_vls_strlen(v)-w;

	if( (sign = n) < 0 )	n = -n;
	i = 0;
	do	
		s[i++] = n % 10 + '0';	
	while( (n /= 10) > 0 );
	if( sign < 0 )	s[i++] = '-';

	/* Blank fill array.					*/
	for( j = i; j < w; j++ )	s[j] = ' ';
	if( i > w ) {
		s[w-1] = (s[w]-1-'0')*10 + (s[w-1]-'0')  + 'A';
	}
	s[w] = '\0';

	/* Reverse the array.					*/
	for( i = 0, j = w - 1; i < j; i++, j-- ) {
		c    = s[i];
		s[i] = s[j];
		s[j] =    c;
	}
}

void
vls_ftoa_vec_cvt( v, vec, w, d )
struct rt_vls	*v;
vect_t		vec;
int		w;
int		d;
{
	vls_ftoa( v, vec[X]*dbip->dbi_base2local, w, d );
	vls_ftoa( v, vec[Y]*dbip->dbi_base2local, w, d );
	vls_ftoa( v, vec[Z]*dbip->dbi_base2local, w, d );
}

void
vls_ftoa_vec( v, vec, w, d )
struct rt_vls	*v;
vect_t		vec;
int		w;
int		d;
{
	vls_ftoa( v, vec[X], w, d );
	vls_ftoa( v, vec[Y], w, d );
	vls_ftoa( v, vec[Z], w, d );
}

void
vls_ftoa_cvt( v, f, w, d )
struct rt_vls	*v;
register double	f;
register int	w, d;
{
	vls_ftoa( v, f*dbip->dbi_base2local, w, d );
}

/*
 *			V L S _ F T O A
 *
 *	Convert float to ascii  w.df format.
 */
void
vls_ftoa( v, f, w, d )
struct rt_vls	*v;
register double	f;
register int	w, d;
{
	register char	*s;
	register int	c, i, j;
	long	n, sign;

	RT_VLS_CHECK(v);
	rt_vls_strncat( v, "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx", w);
	s = rt_vls_addr(v)+rt_vls_strlen(v)-w;

	if( w <= d + 2 )
	{
		(void) fprintf( stderr,
		    "ftoascii: incorrect format  need w.df  stop"
		    );
		exit( 10 );
	}
	for( i = 1; i <= d; i++ )
		f = f * 10.0;

	/* round up */
	if( f < 0.0 )
		f -= 0.5;
	else
		f += 0.5;
	n = f;
	if( (sign = n) < 0 )
		n = -n;
	i = 0;
	do	{
		s[i++] = n % 10 + '0';
		if( i == d )
			s[i++] = '.';
	}	while( (n /= 10) > 0 );

	/* Zero fill the d field if necessary.				*/
	if( i < d )
	{
		for( j = i; j < d; j++ )
			s[j] = '0';
		s[j++] = '.';
		i = j;
	}
	if( sign < 0 )
		s[i++] = '-';

	/* Blank fill rest of field.					*/
	for ( j = i; j < w; j++ )
		s[j] = ' ';
	if( i > w )
		(void) fprintf( stderr, "Ftoascii: field length too small\n" );
	s[w] = '\0';

	/* Reverse the array.						*/
	for( i = 0, j = w - 1; i < j; i++, j-- )
	{
		c    = s[i];
		s[i] = s[j];
		s[j] =    c;
	}
}

/*
	Section 5:	I / O   R O U T I N E S
 *
			getcmd()
			getarg()
			menu()
			blank_fill()
			bug()
			fbug()
 */

/*	g e t c m d ( )
	Return first character read from keyboard,
	copy command into args[0] and arguments into args[1]...args[n].
		
 */
char
getcmd( args, ct )
char		*args[];
register int	ct;
{
	/* Get arguments.						 */
	if( ct == 0 )
		while( --arg_ct >= 0 )
			rt_free( args[arg_ct], "args[arg_ct]" );
	for( arg_ct = ct; arg_ct < MAXARG - 1; ++arg_ct )
	{
		args[arg_ct] = rt_malloc( MAXLN, "getcmd buffer" );
		if( ! getarg( args[arg_ct] ) )
			break;
	}
	++arg_ct;
	args[arg_ct] = 0;

	/* Before returning to command interpreter,
	 * set up interrupt handler for commands...
	 * trap interrupts such that command is aborted cleanly and
	 * command line is restored rather than terminating program
	 */
	(void) signal( SIGINT, abort_sig );
	return	(args[0])[0];
}

/*	g e t a r g ( )
	Get a word of input into 'str',
	Return 0 if newline is encountered.
 	Return 1 otherwise.
 */
char
getarg( str )
register char	*str;
{
	do
	{
		*str = getchar();
		if( (int)(*str) == ' ' )
		{
			*str = '\0';
			return( 1 );
		}
		else
			++str;
	}	while( (int)(str[-1]) != EOF && (int)(str[-1]) != '\n' );
	if( (int)(str[-1]) == '\n' )
		--str;
	*str = '\0';
	return	0;
}

/*	m e n u ( )
	Display menu stored at address 'addr'.
 */
void
menu( addr )
char **addr;
{	
	register char	**sbuf = addr;
	while( *sbuf )
		(void) printf( "%s\n", *sbuf++ );
	(void) fflush( stdout );
	return;
}

/*	b l a n k _ f i l l ( )
	Write count blanks to fildes.
 */
void
blank_fill( fp, count )
FILE		*fp;
register int	count;
{	
	ewrite( fp, BLANKS, (unsigned) count );
}

/*
	Section 6:	I N T E R R U P T   H A N D L E R S
 *
			abort_sig()
			quit()
 */

/*	a b o r t ( )
	Abort command without terminating run (restore command prompt) and
	cleanup temporary files.
 */
/*ARGSUSED*/
void
abort_sig( sig )
{
	(void) signal( SIGINT, quit );	/* reset trap */

	/* goto command interpreter with environment restored.		*/
	longjmp( env, sig );
}

/*	q u i t ( )
	Terminate run.
 */
/*ARGSUSED*/
void
quit( sig )
{
	(void) fprintf( stdout, "quitting...\n" );
	exit( 0 );
}
@


11.21
log
@change conf.h to a wrapped config.h
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/vdeck/vdeck.c,v 11.20 2004/02/02 17:39:52 morrison Exp $ (BRL)";
d109 1
a109 1
	"v d e c k ($Revision: 11.20 $)",
@


11.20
log
@update copyright to include span through 2003
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/vdeck/vdeck.c,v 11.19 2001/11/05 21:20:08 morrison Exp $ (BRL)";
d57 5
a61 1
#include "conf.h"
d109 1
a109 1
	"v d e c k ($Revision: 11.19 $)",
@


11.19
log
@Solid to Primitive naming convention conversions
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1990 by the United States Army.
d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/vdeck/vdeck.c,v 11.18 2001/11/01 22:01:23 bparker Exp $ (BRL)";
d105 1
a105 1
	"v d e c k ($Revision: 11.18 $)",
@


11.19.4.1
log
@sync branch with HEAD
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d21 1
a21 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d105 1
a105 1
	"v d e c k ($Revision$)",
@


11.19.6.1
log
@sync to HEAD...
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/vdeck/vdeck.c,v 11.20 2004/02/02 17:39:52 morrison Exp $ (BRL)";
d105 1
a105 1
	"v d e c k ($Revision: 11.20 $)",
@


11.19.6.2
log
@join with HEAD
@
text
@@


11.19.6.3
log
@join with HEAD
@
text
@@


11.19.6.4
log
@join with HEAD
@
text
@@


11.19.12.1
log
@merge from HEAD
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/vdeck/vdeck.c,v 11.20 2004/02/02 17:39:52 morrison Exp $ (BRL)";
d105 1
a105 1
	"v d e c k ($Revision: 11.20 $)",
@


11.19.12.2
log
@merge from head
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/vdeck/vdeck.c,v 11.19.12.1 2004/02/12 19:43:52 erikg Exp $ (BRL)";
d105 1
a105 1
	"v d e c k ($Revision: 11.19.12.1 $)",
@


11.18
log
@*- add "struct db_i *" parameter to ft_describe function calls
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/vdeck/vdeck.c,v 11.17 2001/08/10 18:45:16 jra Exp $ (BRL)";
d105 1
a105 1
	"v d e c k ($Revision: 11.17 $)",
d714 1
a714 1
		    "vdeck: '%s' Solid type %s has no corresponding COMGEOM solid, skipping\n",
@


11.17
log
@lint
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/vdeck/vdeck.c,v 11.16 2001/06/12 18:07:14 jra Exp $ (BRL)";
d105 1
a105 1
	"v d e c k ($Revision: 11.16 $)",
d665 1
a665 1
		if( ip->idb_meth->ft_describe( &str, ip, 1, 1.0, &rt_uniresource ) < 0 )  {
@


11.16
log
@Fixed a buffer overflow problem by converting to VLS strings for file names
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/vdeck/vdeck.c,v 11.15 2001/04/20 22:31:29 morrison Exp $ (BRL)";
d105 1
a105 1
	"v d e c k ($Revision: 11.15 $)",
d178 8
@


11.15
log
@CONST to const
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/vdeck/vdeck.c,v 11.14 2001/04/02 21:38:39 morrison Exp $ (BRL)";
d105 1
a105 1
	"v d e c k ($Revision: 11.14 $)",
d132 4
a135 1
char	rt_file[15];
d137 1
a137 1
char	st_file[73];
d139 1
a139 1
char	id_file[73];
d232 4
d1297 2
a1298 2
		(void) strncpy( st_file, prefix, 73 );
		(void) strcat( st_file, ".st" );
d1301 2
a1302 1
		(void) strncpy( st_file, "solids", 7 );
d1328 2
a1329 2
		(void) strncpy( rt_file, prefix, 73 );
		(void) strcat( rt_file, ".rt" );
d1332 2
a1333 1
		(void) strncpy( rt_file, "regions", 8 );
d1343 2
a1344 2
		(void) strncpy( id_file, prefix, 73 );
		(void) strcat( id_file, ".id" );
d1347 2
a1348 1
		(void) strncpy( id_file, "region_ids", 11 );
@


11.14
log
@Deprecated bn_mat_copy() for new performance version of MAT_COPY() macro in h/vmath.h.
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/vdeck/vdeck.c,v 11.13 2000/11/02 02:22:01 mike Exp $ (BRL)";
d105 1
a105 1
	"v d e c k ($Revision: 11.13 $)",
d176 1
a176 1
RT_EXTERN(void ewrite, (FILE *fp, CONST char *buf, unsigned bytes) );
d206 2
a207 2
CONST void	*a;		/* The exact template expected by qsort */
CONST void	*b;
d209 2
a210 2
CONST genptr_t	a;
CONST genptr_t	b;
d213 2
a214 2
	CONST char **lhs = (CONST char **)a;
	CONST char **rhs = (CONST char **)b;
d839 5
a843 5
CONST point_t	pts[];
CONST int	npts;
CONST char	*name;
CONST int	num;
CONST char	*kind;
d898 1
a898 1
		vls_solid_pts( v, (CONST point_t *)pts, 8, name, num, "arb8 " );
d901 1
a901 1
		vls_solid_pts( v, (CONST point_t *)pts, 7, name, num, "arb7 " );
d905 1
a905 1
		vls_solid_pts( v, (CONST point_t *)pts, 6, name, num, "arb6 " );
d908 1
a908 1
		vls_solid_pts( v, (CONST point_t *)pts, 5, name, num, "arb5 " );
d912 1
a912 1
		vls_solid_pts( v, (CONST point_t *)pts, 4, name, num, "arb4 " );
d1258 1
a1258 1
CONST char	*buf;
d1354 1
a1354 1
	if( db_walk_tree( dbip, curr_ct, (CONST char **)curr_list,
@


11.13
log
@
db_dirbuild() handles v5
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/vdeck/vdeck.c,v 11.12 2000/09/09 04:34:34 mike Exp $ (BRL)";
d105 1
a105 1
	"v d e c k ($Revision: 11.12 $)",
d634 1
a634 1
		mat_copy( stp->st_matp, mat );
d1348 1
a1348 1
	mat_idn( identity );
@


11.12
log
@
Fixed lint
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/vdeck/vdeck.c,v 11.11 2000/09/09 04:32:05 mike Exp $ (BRL)";
d105 1
a105 1
	"v d e c k ($Revision: 11.11 $)",
d238 2
a239 2
	if( db_scan( dbip, (int (*)())db_diradd, 1, NULL ) < 0 )  {
		fprintf(stderr,"db_scan failure\n");
@


11.11
log
@
Struct db_tree_state finally got a magic number. Added resource argument
to ft_describe(), db_region_mat(), db_shader_mat(),
db_init_db_tree_state(), and db_path_to_mat().
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/vdeck/vdeck.c,v 11.10 2000/09/08 05:57:17 mike Exp $ (BRL)";
d105 1
a105 1
	"v d e c k ($Revision: 11.10 $)",
d222 1
d1389 1
d1519 1
d1554 1
d1585 1
@


11.10
log
@
Tree routines need resource pointer
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/vdeck/vdeck.c,v 11.9 2000/08/24 22:56:19 mike Exp $ (BRL)";
d105 1
a105 1
	"v d e c k ($Revision: 11.9 $)",
d649 1
a649 1
		if( ip->idb_meth->ft_describe( &str, ip, 1, 1.0 ) < 0 )  {
@


11.9
log
@
RCSid
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/vdeck/vdeck.c,v 11.8 2000/06/29 19:08:54 mike Exp $ (BRL)";
d105 1
a105 1
	"v d e c k ($Revision: 11.8 $)",
d234 2
d472 1
a472 1
		db_non_union_push( curtree );
@


11.8
log
@
New calling sequence for gettree_leaf
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/vdeck/vdeck.c,v 11.7 2000/01/04 17:58:21 bparker Exp $ (BRL)";
d105 1
a105 1
	"v d e c k ($Revision: 11.7 $)",
@


11.7
log
@*- add client_data to db_walk_tree
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/vdeck/vdeck.c,v 11.6 1999/12/29 23:23:45 mike Exp $ (BRL)";
d105 1
a105 1
	"v d e c k ($Revision: 11.6 $)",
d556 1
a556 1
union tree *gettree_leaf( tsp, pathp, ep, id, client_data )
d559 1
a559 2
struct rt_external	*ep;
int			id;
a565 1
	struct rt_db_internal	intern;
d572 1
a572 1
	RT_CK_EXTERNAL(ep);
d627 1
a627 1
	stp->st_id = id;
d641 1
a641 9
	RT_INIT_DB_INTERNAL(&intern);
	if( rt_functab[id].ft_import( &intern, ep, stp->st_matp ? stp->st_matp : rt_identity, tsp->ts_dbip ) < 0 )  {
		rt_log("rt_gettree_leaf(%s):  solid import failure\n", dp->d_namep );
		if( intern.idb_ptr )  rt_functab[id].ft_ifree( &intern );
		if( stp->st_matp )  rt_free( (char *)stp->st_matp, "st_matp");
		rt_free( (char *)stp, "struct soltab");
		return( TREE_NULL );		/* BAD */
	}
	RT_CK_DB_INTERNAL( &intern );
d647 1
a647 1
		if( rt_functab[id].ft_describe( &str, &intern, 1, 1.0 ) < 0 )  {
d651 2
a652 2
		rt_log( "%s:  %s", dp->d_namep, rt_vls_addr( &str ) );
		rt_vls_free( &str );
d663 1
a663 1
	switch( intern.idb_type )  {
d665 1
a665 1
		addtor( &sol, (struct rt_tor_internal *)intern.idb_ptr,
d669 1
a669 1
		addarb( &sol, (struct rt_arb_internal *)intern.idb_ptr,
d673 1
a673 1
		addell( &sol, (struct rt_ell_internal *)intern.idb_ptr,
d677 1
a677 1
		addtgc( &sol, (struct rt_tgc_internal *)intern.idb_ptr,
d681 1
a681 1
		addars( &sol, (struct rt_ars_internal *)intern.idb_ptr,
d685 1
a685 1
		addhalf( &sol, (struct rt_half_internal *)intern.idb_ptr,
d689 1
a689 1
		addarbn( &sol, (struct rt_arbn_internal *)intern.idb_ptr,
d697 1
a697 1
		    dp->d_namep, rt_functab[id].ft_name );
d699 1
a699 1
		rt_vls_strcat( &sol, rt_functab[id].ft_name );
a707 3

	/* Free storage for internal form */
	if( intern.idb_ptr )  rt_functab[id].ft_ifree( &intern );
@


11.7.2.1
log
@Backporting bug fixes for release 5.4
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/vdeck/vdeck.c,v 11.7 2000/01/04 17:58:21 bparker Exp $ (BRL)";
d105 1
a105 1
	"v d e c k ($Revision: 11.7 $)",
d131 2
a132 2
FILE	*regfp;
char	*rt_file;
d134 1
a134 1
char	*st_file;
d136 1
a136 4
char	*id_file;
struct bu_vls rt_vls;
struct bu_vls st_vls;
struct bu_vls id_vls;
a227 4
	bu_vls_init( &rt_vls );
	bu_vls_init( &st_vls );
	bu_vls_init( &id_vls );

d1300 2
a1301 2
		(void) bu_vls_strcpy( &st_vls, prefix );
		(void) bu_vls_strcat( &st_vls, ".st" );
d1304 1
a1304 2
		(void) bu_vls_strcpy( &st_vls, "solids" );
	st_file = bu_vls_addr( &st_vls );
d1330 2
a1331 2
		(void) bu_vls_strcpy( &rt_vls, prefix );
		(void) bu_vls_strcat( &rt_vls, ".rt" );
d1334 1
a1334 2
		(void) bu_vls_strcpy( &rt_vls, "regions" );
	rt_file = bu_vls_addr( &rt_vls );
d1344 2
a1345 2
		(void) bu_vls_strcpy( &id_vls, prefix );
		(void) bu_vls_strcat( &id_vls, ".id" );
d1348 1
a1348 2
		(void) bu_vls_strcpy( &id_vls, "region_ids" );
	id_file = bu_vls_addr( &id_vls );
@


11.6
log
@
db_scan() got a client_data argument, which
db_diradd() needed to learn to ignore.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/vdeck/vdeck.c,v 11.5 1998/09/14 15:59:26 bparker Exp $ (BRL)";
d105 1
a105 1
	"v d e c k ($Revision: 11.5 $)",
d422 1
a422 1
union tree *region_end( tsp, pathp, curtree )
d426 1
d556 1
a556 1
union tree *gettree_leaf( tsp, pathp, ep, id )
d561 1
d1366 1
a1366 1
	    0, region_end, gettree_leaf ) < 0 )  {
@


11.5
log
@*- fix typos
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/vdeck/vdeck.c,v 11.4 1998/08/28 13:40:10 jra Exp $ (BRL)";
d105 1
a105 1
	"v d e c k ($Revision: 11.4 $)",
d235 1
a235 1
	if( db_scan( dbip, (int (*)())db_diradd, 1 ) < 0 )  {
@


11.4
log
@an ft_import needed a dbip parameter.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/vdeck/vdeck.c,v 11.3 1997/01/22 15:51:49 jra Exp $ (BRL)";
d105 1
a105 1
	"v d e c k ($Revision: 11.3 $)",
d1060 1
a1060 1
		fprintf(stderr, "addtgc(%s): ma=%e, mb=%e, skipping\n", ma, mb );
@


11.3
log
@gettree_leaf was not setting magic number of returned union tree.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/vdeck/RCS/vdeck.c,v 11.2 1996/07/17 13:24:29 jra Exp jra $ (BRL)";
d105 1
a105 1
	"v d e c k ($Revision: 11.2 $)",
d642 1
a642 1
	if( rt_functab[id].ft_import( &intern, ep, stp->st_matp ? stp->st_matp : rt_identity ) < 0 )  {
@


11.2
log
@Minor Mods for IRIX 6.2
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/vdeck/RCS/vdeck.c,v 11.1 1995/01/04 10:18:38 mike Rel4_4 jra $ (BRL)";
d105 1
a105 1
	"v d e c k ($Revision: 11.1 $)",
d722 1
@


11.1
log
@Release_4.4
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/vdeck/RCS/vdeck.c,v 10.10 95/01/04 09:03:12 mike Exp $ (BRL)";
d105 1
a105 1
	"v d e c k ($Revision: 10.10 $)",
d162 13
d756 1
d786 1
d809 1
d939 1
d1234 1
d1288 1
d1638 1
d1669 1
d1684 1
d1719 1
d1731 1
d1743 1
d1757 1
@


10.10
log
@setjmp.h now included in raytrace.h.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/vdeck/RCS/vdeck.c,v 10.9 94/12/23 09:32:23 jra Exp Locker: mike $ (BRL)";
d105 1
a105 1
	"v d e c k ($Revision: 10.9 $)",
@


10.9
log
@Used cast id calls to vls_solid_pts to satisfy CRAY.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/vdeck/RCS/vdeck.c,v 10.8 94/11/08 04:35:52 mike Exp Locker: jra $ (BRL)";
a66 1
#include <setjmp.h>
d105 1
a105 1
	"v d e c k ($Revision: 10.8 $)",
@


10.8
log
@Irix 6
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/vdeck/RCS/vdeck.c,v 10.7 94/08/23 14:54:26 gdurf Exp Locker: mike $ (BRL)";
d106 1
a106 1
	"v d e c k ($Revision: 10.7 $)",
d832 1
d890 1
a890 1
		vls_solid_pts( v, pts, 8, name, num, "arb8 " );
d893 1
a893 1
		vls_solid_pts( v, pts, 7, name, num, "arb7 " );
d897 1
a897 1
		vls_solid_pts( v, pts, 6, name, num, "arb6 " );
d900 1
a900 1
		vls_solid_pts( v, pts, 5, name, num, "arb5 " );
d904 1
a904 1
		vls_solid_pts( v, pts, 4, name, num, "arb4 " );
@


10.7
log
@Factored ifdefs
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/vdeck/RCS/vdeck.c,v 10.6 1993/10/26 03:12:02 mike Exp gdurf $ (BRL)";
d106 1
a106 1
	"v d e c k ($Revision: 10.6 $)",
a1249 2
	int	bytes_written;

a1272 2
	register int	i;

@


10.6
log
@ANSI
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/vdeck/RCS/vdeck.c,v 10.5 93/06/09 12:21:54 mike Exp Locker: mike $ (BRL)";
d57 2
d61 3
a63 1
#ifdef BSD
a64 2
#else
#include <string.h>
d106 1
a106 1
	"v d e c k ($Revision: 10.5 $)",
@


10.5
log
@Squeeky clean definition of sortFunc(), to *precisely* match
the qsort() declaration.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/vdeck/RCS/vdeck.c,v 10.4 93/06/09 12:01:00 mike Exp Locker: mike $ (BRL)";
d104 1
a104 1
	"v d e c k ($Revision: 10.4 $)",
d159 3
d337 1
d859 1
d1015 1
@


10.4
log
@RT_LIST() is now RT_LIST_FOR()
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/vdeck/RCS/vdeck.c,v 10.3 92/11/18 22:21:02 mike Exp Locker: mike $ (BRL)";
d104 1
a104 1
	"v d e c k ($Revision: 10.3 $)",
d188 4
d194 1
@


10.3
log
@Added improvement suggeted by Tom Sullivan of Sandia to
permit solids with numbers > 9999 to be referenced by
a subtraction operation in the region table, by
substituting operator "nn#" for "  -#".
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/vdeck/RCS/vdeck.c,v 10.2 91/10/12 21:52:17 mike Rel4_0a Locker: mike $ (BRL)";
d104 1
a104 1
	"v d e c k ($Revision: 10.2 $)",
d570 1
a570 1
	for( RT_LIST( stp, soltab, &(sol_hd.l) ) )  {
@


10.2
log
@Minor bug
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/vdeck/RCS/vdeck.c,v 10.1 91/10/12 06:50:33 mike Rel4_0 Locker: mike $ (BRL)";
d104 1
a104 1
	"v d e c k ($Revision: 10.1 $)",
a161 2
static int sortFunc RT_ARGS((CONST genptr_t a, CONST genptr_t b));

a345 1
		rt_vls_strncat( vls, op, 2 );
d347 18
a364 1
		if(neg) bit = -bit;
@


10.1
log
@Release_4.0
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/vdeck/RCS/vdeck.c,v 9.27 91/08/30 21:44:55 mike Exp $ (BRL)";
d104 1
a104 1
	"v d e c k ($Revision: 9.27 $)",
a686 1
	curtree->tr_a.tu_name = db_path_to_string( pathp );
@


9.27
log
@Stardent ANSI C lint
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/vdeck/RCS/vdeck.c,v 9.26 91/08/30 00:12:10 mike Exp $ (BRL)";
d104 1
a104 1
	"v d e c k ($Revision: 9.26 $)",
@


9.26
log
@Stardent ANSI C
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/vdeck/RCS/vdeck.c,v 9.25 91/07/16 00:29:55 mike Exp $ (BRL)";
d104 1
a104 1
	"v d e c k ($Revision: 9.25 $)",
d1493 1
a1493 1
		if( column + strlen( list[i] ) > MAX_COL )
@


9.25
log
@GIFT HAF uses d consistent with dot product addition,
we presently use d of opposite sign
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/vdeck/RCS/vdeck.c,v 9.24 91/07/04 01:37:57 mike Exp $ (BRL)";
d104 1
a104 1
	"v d e c k ($Revision: 9.24 $)",
d1320 2
a1321 1
	if( db_walk_tree( dbip, curr_ct, curr_list, 1, &rt_initial_tree_state,
@


9.24
log
@Squeeky clean on qsort(), and still the XMP bitches.
SGI says nary a peep.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/vdeck/RCS/vdeck.c,v 9.23 91/07/02 04:23:07 mike Exp $ (BRL)";
d104 1
a104 1
	"v d e c k ($Revision: 9.23 $)",
d762 1
a762 1
	vls_ftoa_cvt( v, gp->eqn[3], 10, 4 );
@


9.23
log
@ANSI lint
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/vdeck/RCS/vdeck.c,v 9.22 91/07/01 22:58:43 mike Exp $ (BRL)";
d104 1
a104 1
	"v d e c k ($Revision: 9.22 $)",
d162 2
d190 2
a191 1
char	**a, **b;
d193 4
a196 1
	return( strcmp( *a, *b ) );
@


9.22
log
@Silenced SGI optimizer warning about infinite loops.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/vdeck/RCS/vdeck.c,v 9.21 91/06/14 07:13:11 mike Exp $ (BRL)";
d104 1
a104 1
	"v d e c k ($Revision: 9.21 $)",
d393 1
a393 1
	struct directory	*regdp;
@


9.21
log
@Changed st_pathmat to st_matp
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/vdeck/RCS/vdeck.c,v 9.20 91/06/13 08:04:18 mike Exp $ (BRL)";
d104 1
a104 1
	"v d e c k ($Revision: 9.20 $)",
d308 2
a309 2
			exit( 0 );
UNKNOWN :
d316 2
@


9.20
log
@lseek becomes fseek
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/vdeck/RCS/vdeck.c,v 9.19 91/06/13 07:12:39 mike Exp $ (BRL)";
d104 1
a104 1
	"v d e c k ($Revision: 9.19 $)",
d522 2
d530 14
d549 1
a549 1
		register int i;
d551 14
a564 6
		RT_CHECK_SOLTAB(stp);				/* debug */
		if(	dp->d_namep[0] != stp->st_name[0]  ||	/* speed */
		dp->d_namep[1] != stp->st_name[1]  ||	/* speed */
		strcmp( dp->d_namep, stp->st_name ) != 0
		    )
			continue;
d566 1
a566 1
			f = tsp->ts_mat[i] - stp->st_pathmat[i];
d584 6
a589 1
	mat_copy( stp->st_pathmat, tsp->ts_mat );
d597 1
a597 1
	if( rt_functab[id].ft_import( &intern, ep, stp->st_pathmat ) < 0 )  {
d600 1
@


9.19
log
@Memory leak fixed
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/vdeck/RCS/vdeck.c,v 9.18 91/06/13 06:50:40 mike Exp $ (BRL)";
d28 1
a28 1
	(also gift(1V)) from a vged(1V) target description.
d104 1
a104 1
	"v d e c k ($Revision: 9.18 $)",
d621 4
a626 2
	case ID_ARBN:
		/* XXX */
d730 36
d977 2
a978 6
	/* Tec if ratio top and bot vectors equal and base parallel to top.
	 */
	if( mc == 0.0 )  {
		(void) fprintf( stderr,
		    "Error in TGC, C vector has zero magnitude!\n"
		    );
d981 7
a987 5
	if( md == 0.0 )  {
		(void) fprintf( stderr,
		    "Error in TGC, D vector has zero magnitude!\n"
		    );
		return;
a988 4
	if(	fabs( (mb/md)-(ma/mc) ) < CONV_EPSILON
	    &&  fabs( fabs(VDOT(axb,cxd)) - (maxb*mcxd) ) < CONV_EPSILON
	    )
		cgtype = TEC;
d1241 1
a1241 1
	savsol = lseek( solfp, 0L, 1 );
d1289 1
a1289 1
	(void) lseek( solfp, savsol, 0 );
@


9.18
log
@Changed to use buffered STDIO
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/vdeck/RCS/vdeck.c,v 9.17 91/06/13 06:35:35 mike Exp $ (BRL)";
d104 1
a104 1
	"v d e c k ($Revision: 9.17 $)",
d488 1
a488 1
	ewrite( ridfp, rt_vls_addr(&ident), rt_vls_strlen(&ident) );
d637 2
a638 1
	ewrite( solfp, rt_vls_addr(&sol), rt_vls_strlen(&sol) );
@


9.17
log
@nits
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/vdeck/RCS/vdeck.c,v 9.16 91/06/13 06:24:13 mike Exp $ (BRL)";
d104 1
a104 1
	"v d e c k ($Revision: 9.16 $)",
d130 1
a130 1
int	regfd;		
d132 1
a132 1
int	solfd;		
d134 1
a134 1
int	ridfd;		
d150 1
a150 1
extern void		blank_fill(), menu();
a157 1
void			ewrite();
d159 3
d463 1
a463 1
		ewrite( regfd, obuf, strlen(obuf) );
d488 1
a488 1
	ewrite( ridfd, rt_vls_addr(&ident), rt_vls_strlen(&ident) );
d637 1
a637 1
	ewrite( solfd, rt_vls_addr(&sol), rt_vls_strlen(&sol) );
d1148 3
a1150 3
ewrite( fd, buf, bytes )
int		fd;
char		*buf;
d1154 8
a1161 7
	if( (bytes_written = write( fd, buf, bytes )) != (int) bytes )
		(void) fprintf( stderr,
		    "ERROR: Write of %d bytes returned %d\n",
		    (int)bytes,
		    bytes_written
		    );
	return;
d1190 1
a1190 2
	if( (solfd = creat( st_file, 0644 )) < 0 )
	{
d1197 2
a1198 2
	ewrite( solfd, rt_units_string(dbip->dbi_local2base), 2 );
	blank_fill( solfd, 3 );
d1202 1
a1202 1
		ewrite( solfd, objfile, (unsigned) strlen( objfile ) );
d1204 2
a1205 2
		ewrite( solfd, dbip->dbi_title, (unsigned) strlen( dbip->dbi_title ) );
	ewrite( solfd, LF, 1 );
d1208 3
a1210 3
	savsol = lseek( solfd, 0L, 1 );
	blank_fill( solfd, 10 );
	ewrite( solfd, LF, 1 );
d1220 1
a1220 2
	if( (regfd = creat( rt_file, 0644 )) < 0 )
	{
d1234 1
a1234 2
	if( (ridfd = creat( id_file, 0644 )) < 0 )
	{
d1239 2
a1240 2
	ewrite( ridfd, buff, 5 );
	ewrite( ridfd, LF, 1 );
d1256 1
a1256 1
	(void) lseek( solfd, savsol, 0 );
d1258 1
a1258 1
	ewrite( solfd, buff, 5 );
d1260 1
a1260 1
	ewrite( solfd, buff, 5 );
d1263 1
a1263 1
	ewrite( ridfd, LF, 1 );
d1270 3
a1272 3
	(void) close( solfd );
	(void) close( regfd );
	(void) close( ridfd );
d1405 1
a1405 1
			ewrite( 1, buf, (unsigned) column );\
d1790 3
a1792 2
blank_fill( fildes, count )
register int	fildes,	count;
d1794 1
a1794 3
	register char	*blank_buf = BLANKS;
	ewrite( fildes, blank_buf, (unsigned) count );
	return;
@


9.16
log
@Cleanup
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/vdeck/RCS/vdeck.c,v 9.15 91/06/13 06:15:29 mike Exp $ (BRL)";
d104 1
a104 1
	"v d e c k ($Revision: 9.15 $)",
d410 2
a411 1
	(void) printf( "%4d:%s\n", nnr+delreg, fullname );
d625 2
a626 2
		    "vdeck: '%s' Solid type has no corresponding COMGEOM soild, skipping\n",
		    rt_functab[id].ft_name );
a1343 3

	(void) printf( "Making the Table of Contents.\n" );
	(void) fflush( stdout );
@


9.15
log
@Absorbed vproc.c
Lists are now dynamically allocated
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/vdeck/RCS/vdeck.c,v 9.14 91/06/13 05:57:22 mike Exp $ (BRL)";
d104 1
a104 1
	"v d e c k ($Revision: 9.14 $)",
a648 3
/*
 *  Called from deck().
 */
a649 13
treewalk( str )
char	*str;
{
	if( !sol_hd.l.magic )  RT_LIST_INIT( &sol_hd.l );

	if( db_walk_tree( dbip, 1, &str, 1, &rt_initial_tree_state,
	    0, region_end, gettree_leaf ) < 0 )  {
		fprintf(stderr,"Unable to treewalk '%s'\n", str );
	}
}


void
d1244 8
a1251 11
	/* Check integrity of list against directory and build card deck.	*/
	for( i = 0; i < curr_ct; i++ )
	{	
		struct directory	*dirp;
		if( (dirp = db_lookup( dbip, curr_list[i], LOOKUP_NOISY )) != DIR_NULL )  {
#if 1
			treewalk( curr_list[i] );
#else
			cgobj( dirp, 0, identity );
#endif
		}
d1253 2
a1254 1
	/* Add number of solids and regions on second card.		*/
@


9.14
log
@Trimmed out excess
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/vdeck/RCS/vdeck.c,v 9.13 91/06/13 05:24:02 mike Exp $ (BRL)";
d104 1
a104 1
	"v d e c k ($Revision: 9.13 $)",
d113 1
a113 5
/* Units conversion factor from milimeters to whatever is specified in
	the ident record.  If nothing is specified, unity scaling is used.
	See 'db.h' for defined units and ident record definition.  This
	capability dates back to GED database version (v4).
 */
d115 2
a116 5
/* Sorted table of contents.						*/
char	*toc_list[NDIR];

/* List of regions and solids to be processed.				*/
char	*curr_list[NDIR];
d118 2
a124 4
/* Temporary list of names.						*/
char	*tmp_list[NDIR];
int	tmp_ct = 0;

d153 3
d1174 674
@


9.13
log
@Now handles units conversion
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/vdeck/RCS/vdeck.c,v 9.12 91/06/13 04:02:15 mike Exp $ (BRL)";
d104 1
a104 1
	"v d e c k ($Revision: 9.12 $)",
d157 1
a157 1
mat_t		xform, notrans, identity;
a523 1
	struct rt_tol		tol;
a845 1
	register int	i;
a939 1
	register int	i;
a940 1
	vect_t	work;
a1109 2
	register int	i;

d1176 1
a1176 1
		    bytes,
a1179 10
}

pr_dir( dirp )
struct directory	*dirp;
{
	(void) printf(	"dirp(0x%x)->d_namep=%s d_addr=%ld\n",
	    dirp, dirp->d_namep, dirp->d_addr
	    );
	(void) fflush( stdout );
	return	1;
@


9.12
log
@CB
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/vdeck/RCS/vdeck.c,v 9.11 91/06/13 03:59:48 mike Exp $ (BRL)";
d104 1
a104 1
	"v d e c k ($Revision: 9.11 $)",
a117 1
double	unit_conversion = 1.0;
d164 1
a164 1
void			eread(), ewrite();
d718 2
a719 2
	vls_ftoa( v, gp->r_a*unit_conversion, 10, 4 );
	vls_ftoa( v, gp->r_h*unit_conversion, 10, 4 );
a1166 21
}

/*	e r e a d ( )
	Read with error checking.
 */
void
eread( fd, buf, bytes )
int		fd;
char		*buf;
unsigned	bytes;
{	
	int	bytes_read;
	if(	(bytes_read = read( fd, buf, bytes )) != (int) bytes
	    &&	bytes_read != 0
	    )
		(void) fprintf( stderr,
		    "ERROR: Read of %d bytes returned %d\n",
		    bytes,
		    bytes_read
		    );
	return;
@


9.11
log
@Added ARS
@
text
@d2 18
a19 6
	Author:		Gary S. Moss
			U. S. Army Ballistic Research Laboratory
			Aberdeen Proving Ground
			Maryland 21005-5066
			(301)278-6647 or AV-298-6647
*/
d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/vdeck/RCS/vdeck.c,v 9.10 91/06/13 03:18:06 mike Exp $ (BRL)";
d81 20
a100 19
"",
"C O M M A N D                  D E S C R I P T I O N",
"",
"deck [output file prefix]      Produce COM GEOM card deck.",
"erase                          Erase current list of objects.",
"insert [object[s]]             Add an object to current list.",
"list [object[s]]               Display current list of selected objects.",
"number [solid] [region]        Specify starting numbers for objects.",
"quit                           Terminate run.",
"remove [object[s]]             Remove an object from current list.",
"sort                           Sort table of contents alphabetically.",
"toc [object[s]]                Table of contents of solids database.",
"! [shell command]              Execute a UNIX shell command.",
"",
"NOTE:",
"First letter of command is sufficient, and all arguments are optional.",
"Objects may be specified with string matching operators (*, [], -, ? or \\)",
"as in the UNIX shell.",
0 };
d103 9
a111 8
"",
"v d e c k ($Revision: 9.10 $)",
"Make COMGEOM decks of objects from a \"mged\" file suitable as",
"input to GIFT5 or gift(1V).",
"",
"Usage: vdeck file.g",
"",
0 };
d140 6
a145 3
int	regfd;		char	rt_file[15];
int	solfd;		char	st_file[73];
int	ridfd;		char	id_file[73];
d208 1
a208 1
		{
d211 1
a211 1
		}
d229 1
a229 1
		{
d237 1
a237 1
			{
d247 1
a247 1
				{
d250 1
a250 1
				}
d254 3
a256 2
			{	register int	i;
			if( arg_list[1] == 0 )
d258 7
a264 1
				(void) col_prt( curr_list, curr_ct );
a265 6
				}
			for( tmp_ct = 0, i = 0; i < curr_ct; i++ )
				if( match( arg_list[1], curr_list[i] ) )
					tmp_list[tmp_ct++] = curr_list[i];
			(void) col_prt( tmp_list, tmp_ct );
			break;
d273 1
a273 1
				{
d278 1
a278 1
				}
d286 1
a286 1
				{
d289 1
a289 1
				}
d297 1
a297 1
				{
d300 1
a300 1
				}
d305 1
a305 1
				sizeof(char *), sortFunc );
d314 1
a314 1
		UNKNOWN :
a317 2
			}
		prompt( CMD_PROMPT );		
d319 1
d321 1
d354 1
a354 1
			tp->tr_a.tu_stp );
d542 3
a544 3
			dp->d_namep[1] != stp->st_name[1]  ||	/* speed */
			strcmp( dp->d_namep, stp->st_name ) != 0
		)
d554 1
a554 1
				dp->d_namep );
d557 2
a558 1
next_one: ;
d572 1
a572 1
    	RT_INIT_DB_INTERNAL(&intern);
d575 1
a575 1
	    	if( intern.idb_ptr )  rt_functab[id].ft_ifree( &intern );
d587 1
a587 1
				dp->d_namep );
d604 1
a604 1
			dp->d_namep, stp->st_bit+delsol );
d608 1
a608 1
			dp->d_namep, stp->st_bit+delsol );
d612 1
a612 1
			dp->d_namep, stp->st_bit+delsol );
d616 1
a616 1
			dp->d_namep, stp->st_bit+delsol );
d620 1
a620 1
			dp->d_namep, stp->st_bit+delsol );
d624 1
a624 1
			dp->d_namep, stp->st_bit+delsol );
d632 2
a633 2
			"vdeck: '%s' Solid type has no corresponding COMGEOM soild, skipping\n",
			rt_functab[id].ft_name );
d645 1
a645 1
    	if( intern.idb_ptr )  rt_functab[id].ft_ifree( &intern );
d687 2
a688 1
	{	double	t;
d693 1
a693 1
	}
d804 1
a804 1
	
d825 1
a825 1
	/* Currently, cgarbs() will not return RAW, BOX, or RPP */
d828 1
a828 1
			cgtype );
d851 1
a851 1
	
d863 1
a863 1
			{
d866 1
a866 1
			}
d873 1
a873 1
	} else if( fabs( mb-mc ) < CONV_EPSILON ) 
d919 3
a921 3
				"Error in type of ellipse (%d).\n",
				cgtype
				);
d966 2
a967 2
				"Error in TGC, C vector has zero magnitude!\n"
				);
d972 2
a973 2
				"Error in TGC, D vector has zero magnitude!\n"
				);
d978 1
a978 1
		)
d1097 3
a1099 3
				"Error in tgc type (%d).\n",
				cgtype
				);
d1178 2
a1179 1
	{	int	bytes_read;
d1182 1
a1182 1
		)
d1184 4
a1187 4
				"ERROR: Read of %d bytes returned %d\n",
				bytes,
				bytes_read
				);
d1189 1
a1189 1
	}
d1199 2
a1200 1
	{	int	bytes_written;
d1203 4
a1206 4
				"ERROR: Write of %d bytes returned %d\n",
				bytes,
				bytes_written
				);
d1208 1
a1208 1
	}
d1212 1
a1212 1
	{
d1214 2
a1215 2
			dirp, dirp->d_namep, dirp->d_addr
			);
d1218 1
a1218 1
	}
@


9.10
log
@Added halfspace support
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/vdeck/RCS/vdeck.c,v 9.9 91/06/13 02:46:46 mike Exp $ (BRL)";
d91 1
a91 1
"v d e c k ($Revision: 9.9 $)",
d155 5
a159 2
/*	s o r t F u n c ( )
	Comparison function for qsort().
d161 13
d177 1
a177 1
	{
d179 1
a179 1
	}
d186 1
a186 1
	{
d306 3
a308 1
 *  XXX This is clearly not right, but should do simple test cases.
d600 1
a600 1
		addars( &sol, (struct rt_tgc_internal *)intern.idb_ptr,
a624 2
	/* ---------------- */

d817 4
a820 2
/*	a d d e l l ( )
	Process the general ellipsoid.
d912 4
a915 2
/*	a d d t g c ( )
	Process generalized truncated cone.
d1084 2
a1085 2
/*	a d d a r s ( )
	Process triangular surfaced polyhedron - ars.
d1087 2
a1088 1
addars( v, gp, name, num )
d1090 3
a1092 2
struct rt_tgc_internal	*gp;
char			*name;
d1095 1
a1095 6
#if 0
	char	buf[10];
	register int	i, vec;
	int	npt, npts, ncurves, ngrans, granule, totlen;
	float	work[3], vertex[3];
	hvect_t	v_work, v_workk;
d1097 3
a1099 4
	ngrans = rec->a.a_curlen;
	totlen = rec->a.a_totlen;
	npts = rec->a.a_n;
	ncurves = rec->a.a_m;
d1101 4
a1104 9
	/* Write ars header line in solid table.			*/
	ewrite( solfd, "ars  ", 5 );
	itoa( ncurves, buf, 10 );
	ewrite( solfd, buf, 10 );
	itoa( npts, buf, 10 );
	ewrite( solfd, buf, 10 );
	blank_fill( solfd, 40 );
	ewrite( solfd, rec->a.a_name, (unsigned) strlen( rec->a.a_name ) );
	ewrite( solfd, LF, 1 );
d1106 8
a1113 21
	/* Process the data one granule at a time.			*/
	for( granule = 1; granule <= totlen; granule++ )
		{
		/* Read a granule (ars extension record 'B').		*/
		eread( objfd, (char *) rec, sizeof record );
		/* Find number of points in this granule.		*/
		if( rec->b.b_ngranule == ngrans && (npt = npts % 8) != 0 )
			;
		else
			npt = 8;
		/* Operate on vertex.					*/
		if( granule == 1 )
			{
			vtoh_move( v_workk, &(rec->b.b_values[0]) );
			matXvec( v_work, xform, v_workk );
			htov_move( &(rec->b.b_values[0]), v_work );
			VMOVE( vertex, &(rec->b.b_values[0]) );
			vec = 1;
			}
		else
			vec = 0;
d1115 4
a1118 14
		/* Rest of vectors.					*/
		for( i = vec; i < npt; i++, vec++ )
			{
			vtoh_move( v_workk, &(rec->b.b_values[vec*3]) );
			matXvec( v_work, notrans, v_workk );
			htov_move( work, v_work );
			VADD2( &(rec->b.b_values[vec*3]), vertex, work );
			}

		/* Print the solid parameters.				*/
		parsp( npt, rec );
		}
	return;
#endif
d1121 4
a1124 3
#if 0
/*	p a r s p ( )
	Print npts points of an ars.
d1126 7
a1132 5
parsp( npts, rec )
register int	npts;
register Record	*rec;
	{ 	register int	i, j, k, jk;
		char		bufout[80];
d1134 1
a1134 1
	j = jk = 0;
d1136 7
a1142 6
	itoa( nns+delsol, &bufout[0], 5 );
	for( i = 5; i < 10; i++ )
		bufout[i] = ' ';
	(void) strncpy( &bufout[70], "curve ", 6 );
	itoa( rec->b.b_n, &bufout[76], 3 );
	bufout[79] = '\n';
d1144 3
a1146 26
	for( i = 0; i < npts*3; i += 3 )
		{ /* Write 3 points.  */
		for( k = i; k <= i+2; k++ )
			{
			++jk;
			rec->b.b_values[k] *= unit_conversion;
			ftoascii(	rec->b.b_values[k],
					&bufout[jk*10],
					10,
					4
					);
			}
		if( (++j & 01) == 0 )
			{ /* End of line. */
			bufout[70] = 'c';
			ewrite( solfd, bufout, 80 );
			jk = 0;
			}
		}
	if( (j & 01) == 1 )
		{ /* Finish off line. */
		for( k = 40; k < 70; k++ )
			bufout[k] = ' ';
		ewrite( solfd, bufout, 80 );
		}
	return;
d1148 1
a1148 16
#endif

#include <varargs.h>
/*	p r o m p t ( )							*/
/*VARARGS*/
void
prompt( fmt, va_alist )
char	*fmt;
va_dcl
	{	va_list		ap;
	va_start( ap );
	(void) _doprnt( fmt, ap, stdout );
	(void) fflush( stdout );
	va_end( ap );
	return;
	}
@


9.9
log
@Torus normal is now unit length
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/vdeck/RCS/vdeck.c,v 9.8 91/06/11 02:00:35 mike Exp $ (BRL)";
d91 1
a91 1
"v d e c k ($Revision: 9.8 $)",
a339 2
extern CONST struct db_tree_state	rt_initial_tree_state;

d391 1
a391 1
		/* XXX More may be needed */
a457 2
	/* ---------------- */

a558 3
	/* ---------------- */
	/* XXX output the solid */

d586 3
a588 1
		/* XXX */
d591 2
d688 22
@


9.8
log
@No longer depends on db.h
The region conversion seems to work!
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/vdeck/RCS/vdeck.c,v 9.7 91/06/01 22:46:51 mike Exp $ (BRL)";
d91 1
a91 1
"v d e c k ($Revision: 9.7 $)",
a672 2
	vect_t	norm;

a676 2
	VSCALE( norm, gp->h, 1/gp->r_h );

d680 1
a680 1
	vls_ftoa_vec( v, norm, 10, 4 );
@


9.7
log
@Moved #includes out of vextern.h into individual .c files
Trimmed out some unused variables.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/vdeck/RCS/vdeck.c,v 9.6 91/06/01 22:17:48 mike Exp $ (BRL)";
a56 1
#include "db.h"		/* XXX */
d64 2
d91 1
a91 1
"v d e c k ($Revision: 9.6 $)",
a141 1
Record		record;
d188 4
d326 1
a326 1
		flatten_tree( vls, tp->tr_b.tb_left, op, neg );
d340 1
a340 15
static CONST struct db_tree_state	initial_tree_state = {
	0,			/* ts_dbip */
	0,			/* ts_sofar */
	0, 0, 0, 0,		/* region, air, gmater, LOS */
	1.0, 1.0, 1.0,		/* color, RGB */
	0,			/* override */
	DB_INH_LOWER,		/* color inherit */
	DB_INH_LOWER,		/* mater inherit */
	"",			/* material name */
	"",			/* material params */
	1.0, 0.0, 0.0, 0.0,
	0.0, 1.0, 0.0, 0.0,
	0.0, 0.0, 1.0, 0.0,
	0.0, 0.0, 0.0, 1.0,
};
d364 1
d380 1
a380 1
	/* ---------------- */
a387 1
	nnr++;			/* Start new region */
d390 7
a396 1
	flatten_tree( &flat, curtree, "  ", 0 );
d401 1
a401 1
rt_log("flat tree='%s'\n", cp);
d407 6
a412 1
		(void) sprintf( op, "%5d ", nnr+delreg );
d417 1
d467 8
a474 2
	curtree->tr_a.tu_stp = 0;	/* XXX to keep solid table from evaporating */
	return curtree;
a494 1
	union record		rec;	/* XXX hack */
d520 1
a520 2
#if 0
		if( rt_g.debug & DEBUG_SOLIDS )
d523 1
a523 1
#endif
d548 1
a548 2
#if 0
	if(rt_g.debug&DEBUG_SOLIDS)  {
a558 1
#endif
a587 1
#if 0
d589 2
a590 1
		addars( &rec );
d592 4
a595 1
#endif
d634 1
a634 1
	if( db_walk_tree( dbip, 1, &str, 1, &initial_tree_state,
d782 4
d873 6
d1052 12
a1063 7
addars( rec )
register Record *rec;
	{	char	buf[10];
		register int	i, vec;
		int	npt, npts, ncurves, ngrans, granule, totlen;
		float	work[3], vertex[3];
		hvect_t	v_work, v_workk;
a1064 1
#if 0
d1118 1
a1118 50
#define MAX_PSP	60
/*	p s p ( )
	Print solid parameters  -  npts points or vectors.
 */
psp( npts, rec )
register int	npts;
register Record *rec;
	{	register int	i, j, k, jk;
		char		buf[MAX_PSP+1];
	j = jk = 0;
	for( i = 0; i < npts*3; i += 3 )
		{ /* Write 3 points.					*/
		for( k = i; k <= i+2; k++ )
			{
			rec->s.s_values[k] *= unit_conversion;
			ftoascii( rec->s.s_values[k], &buf[jk*10], 10, 4 );
			++jk;
			}

		if( (++j & 01) == 0 )
			{ /* End of line.				*/
			ewrite( solfd, buf, MAX_PSP );
			jk = 0;
			ewrite(	solfd,
				rec->s.s_name,
				(unsigned) strlen( rec->s.s_name )
				);
			ewrite( solfd, LF, 1 );
			if( i != (npts-1)*3 )
				{   /* new line */
				itoa( nns+delsol, buf, 5 );
				ewrite( solfd, buf, 5 );
				blank_fill( solfd, 5 );
				}
			}
		}	
	if( (j & 01) == 1 )
		{ /* Finish off rest of line.				*/
		for( k = 30; k <= MAX_PSP; k++ )
			buf[k] = ' ';
		ewrite( solfd, buf, MAX_PSP );
		ewrite(	solfd,
			rec->s.s_name,
			(unsigned) strlen( rec->s.s_name )
			);
		ewrite( solfd, LF, 1 );
		}
	return;
	}

d1164 1
@


9.6
log
@Eliminated old code,
absorbed global declarations.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/vdeck/RCS/vdeck.c,v 9.5 91/06/01 22:01:04 mike Exp $ (BRL)";
d52 3
d57 1
a58 1
#include "./vextern.h"
d60 1
a61 1
#include "raytrace.h"
d63 2
d90 1
a90 1
"v d e c k ($Revision$)",
d92 1
a92 1
"input to the Cyber GIFT5 or gift(1V).",
d94 1
a94 1
"Usage: vdeck {file}.vg",
d100 1
a100 1
	See '3d.h' for defined units and ident record definition.  This
d124 2
a125 2
int	objfd;		char	*objfile;
int	regfd;		char	reg_file[15];
a127 1
int	rrfd, rd_rrfd;	char	rt_file[73];
a131 1
int	numrr;		/* Regions.					*/
d135 3
a137 4
int		regflag, orflag, delsol = 0, delreg = 0;
int		isave;
char		operate, buff[30], name[16];
long		savsol;
a141 2
struct findrr	findrr[MAXRR];
char		dir_names[NDIR*10], *dir_last = dir_names;
a142 1

a144 1
char			regBuffer[BUFSIZ], *regBufPtr;
a149 11
#define endRegion( buff ) \
	     	(void) sprintf( regBufPtr, "%s\n", buff ); \
	    	ewrite( regfd, regBuffer, (unsigned) strlen( regBuffer ) ); \
	    	regBufPtr = regBuffer;

#define putSpaces( s, xx ) \
		{	register int ii; \
		for( ii = 0; ii < (xx); ii++ ) \
			*s++ = ' '; \
		}

a201 1
			regBufPtr = regBuffer;
a600 1
rt_log("solid='%s'\n", rt_vls_addr(&sol) );
@


9.5
log
@Absorbed vsort.c module
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/vdeck/RCS/vdeck.c,v 9.4 91/06/01 21:16:12 mike Exp $ (BRL)";
d60 1
d62 82
a646 470

#if 0
/*	c g o b j ( )
	Build deck for object pointed to by 'dirp'.
 *	Called from deck(), with pathpos=0 and old_xlate=identity.
 */
cgobj( dirp, pathpos, old_xlate )
register struct directory	*dirp;
int			pathpos;
matp_t			old_xlate;
	{
	register struct member	*mp;
	register char		*bp;
	Record			rec;
	struct directory	*nextdirp, *tdirp;
	static struct directory	*path[MAXPATH];
	mat_t			new_xlate;
	long			savepos, RgOffset;
	int			nparts;
	int			i, j;
	int			length;
	int			dchar = 0;
	int			nnt;
	static char		buf[MAXPATH*NAMESIZE];
	char			ars_name[NAMESIZE];

	/* Limit tree hierarchy to MAXPATH levels.			*/
	if( pathpos >= MAXPATH )
		{
		(void) fprintf( stderr, "Nesting exceeds %d levels\n", MAXPATH );
		for( i = 0; i < MAXPATH; i++ )
			(void) fprintf( stderr, "/%s", path[i]->d_namep );
		(void) fprintf( stderr, "\n" );
		return;
		}
	savepos = lseek( objfd, 0L, 1 );
	(void) lseek( objfd, dirp->d_addr, 0 );
	eread( objfd, (char *) &rec, sizeof rec );

	if( rec.u_id == ID_COMB )
		{ /* We have a group.					*/
		if( regflag > 0 )
			{
			/* Record is part of a region.			*/
			if( rec.c.c_flags != 'R' )
				{
				(void) fprintf( stderr,
	"Illegal combination, group '%s' is a member of a region (%s)",
						rec.c.c_name,
						buff
						);
				return;
				}
			if( operate == UNION )
				{
				(void) fprintf( stderr,
					"Region: %s is member of ",
					rec.c.c_name );
				(void) fprintf( stderr,
					"region %s with OR operation.\n",
					buff );
				return;
				}

			/* Check for end of line in region table.	*/
			if(	(isave % 9 ==  1 && isave >  1)
			    ||	(isave % 9 == -1 && isave < -1)
				)
				{
				endRegion( buff );
				putSpaces( regBufPtr, 6 );
				}
			(void) sprintf( regBufPtr, "rg%c", operate );
			regBufPtr += 3;
			RgOffset = (long)(regBufPtr - regBuffer);

			/* Check if this region is in desc yet		*/
			(void) lseek( rd_rrfd, 0L, 0 );
			for( j = 1; j <= nnr; j++ )
				{
				eread( rd_rrfd, name, (unsigned) NAMESIZE );
				if( strcmp( name, rec.c.c_name ) == 0 )
					{ /* Region is #j.		*/
					(void) sprintf( regBufPtr, "%4d", j+delreg );
					regBufPtr += 4;
					break;
					}
				}
			if( j > nnr )
				{   /* region not in desc yet */
				numrr++;
				if( numrr > MAXRR )
					{
					(void) fprintf( stderr,
						"More than %d regions.\n",
						MAXRR
						);
					exit( 10 );
					}

				/* Add to list of regions to look up.	*/
				findrr[numrr].rr_pos = lseek(	regfd,
								0L,
								1
								) + RgOffset;
				for( i = 0; i < NAMESIZE; i++ )
					findrr[numrr].rr_name[i] =
						   rec.c.c_name[i];
				putSpaces( regBufPtr, 4 );
				}
			/* Check for end of this region.		*/
			if( isave < 0 )
				{	int	n;
				isave = -isave;
				regflag = 0;
				n = 69 - (regBufPtr - regBuffer);
				putSpaces( regBufPtr, n );
				endRegion( buff );
				}
			(void) lseek( objfd, savepos, 0);
			return;
			}

		regflag = 0;
		nparts = rec.c.c_length;
		if( rec.c.c_flags == 'R')
			{ /* Record is region but not member of a region.	*/
			regflag = 1;
			nnr++;
			/* Dummy region.				*/
			if( nparts == 0 )
				regflag = 0;
			/* Save the region name.			*/
			(void) strncpy( buff, rec.c.c_name, NAMESIZE );
			/* Start new region.				*/
			(void) sprintf( regBufPtr, "%5d ", nnr+delreg );
			regBufPtr += 6;
			/* Check for dummy region.			*/
			if( nparts == 0 )
				{	int	n;
				n = 69 - (regBufPtr - regBuffer);
				putSpaces( regBufPtr, n );
				endRegion( "" );
				regflag = 0;
				}

			/* Add region to list of regions in desc.	*/
			(void) lseek( rrfd, 0L, 2 );
			ewrite( rrfd, rec.c.c_name, NAMESIZE );
			/* Check for any OR.				*/
			orflag = 0;
			if( nparts > 1 )
				{ /* First OR doesn't count, throw away
					first member.		 	*/
				eread( objfd, (char *) &rec, sizeof rec );
				for( i = 2; i <= nparts; i++ )
					{
					eread( objfd, (char *) &rec, sizeof rec );
					if( rec.M.m_relation == UNION )
						{
						orflag = 1;
						break;
						}
					}
				(void) lseek( objfd, dirp->d_addr, 0 );
				eread( objfd, (char *) &rec, sizeof rec );
				}
			/* Write region ident table.			*/
			itoa( nnr+delreg, buf, 5 );
			itoa( rec.c.c_regionid,	&buf[5], 5 );
			itoa( rec.c.c_aircode, &buf[10], 5 );
/* + */			itoa( rec.c.c_material, &buf[15], 5 );
/* + */			itoa( rec.c.c_los, &buf[20], 5 );
			ewrite( ridfd, buf, 25 );
			blank_fill( ridfd, 5 );
			bp = buf;
			length = strlen( rec.c.c_name );
			for( j = 0; j < pathpos; j++ )
				{
				(void) strncpy(	bp,
						path[j]->d_namep,
						strlen( path[j]->d_namep )
						);
				bp += strlen( path[j]->d_namep );
				*bp++ = '/';
				*bp = '\0';
				}
			length += bp - buf;
			if( length > 50 )
				{
				bp = buf + (length - 50);
				*bp = '*';
				ewrite(	ridfd,
					bp,
					(unsigned)(50 - strlen( rec.c.c_name ))
					);
				}
			else
				ewrite( ridfd, buf, (unsigned)(bp - buf) );
			ewrite(	ridfd,
				rec.c.c_name,
				(unsigned) strlen( rec.c.c_name )
				);
			ewrite( ridfd, LF, 1 );
			(void) printf( "%4d:", nnr+delreg );
			for( j = 0; j < pathpos; j++ )
				(void) printf( "/%s", path[j]->d_namep );
			(void) printf( "/%s\n", rec.c.c_name );
			}
		isave = 0;
		for( i = 1; i <= nparts; i++ )
			{
			if( ++isave == nparts )
				isave = -isave;
			eread( objfd, (char *) &rec, sizeof rec );
			mp = &rec.M;
 
			/* Save this operation.				*/
			operate = mp->m_relation;
 			path[pathpos] = dirp;
			if(	(nextdirp =
				db_lookup( mp->m_instname, NOISY )) == DIR_NULL
				)
				continue;
			mat_mul( new_xlate, old_xlate, mp->m_mat );

			/* Recursive call.				*/
			cgobj( nextdirp, pathpos+1, new_xlate );
			}
		(void) lseek( objfd, savepos, 0 );
		return;
		}

	/* N O T  a  C O M B I N A T I O N  record.			*/
	if( rec.u_id != ID_SOLID && rec.u_id != ID_ARS_A )
		{
		(void) fprintf( stderr,
				"Bad input: should have a 'S' or 'A' record, " );
		(void) fprintf( stderr,
				"but have '%c'.\n", rec.u_id );
		exit( 10 );
		}

	/* Now have proceeded down branch to a solid

		if regflag = 1  add this solid to present region
		if regflag = 0  solid not defined as part of a region
				make new region if scale != 0 
	
		if orflag = 1   this region has or's
		if orflag = 0   no
	*/
	if( old_xlate[15] < EPSILON )
		{ /* Do not add solid.		*/
		(void) lseek( objfd, savepos, 0 );
		return;
		}

	/* Fill ident struct.						*/
	mat_copy( d_ident.i_mat, old_xlate );
	(void) strncpy( d_ident.i_name, rec.s.s_name, NAMESIZE );
	(void) strncpy( ars_name, rec.s.s_name, NAMESIZE );
	
	/* Calculate first look discriminator for this solid.		*/
	dchar = 0;
	for( i = 0; i < NAMESIZE; i++ )
		{
		if( rec.s.s_name[i] == 0 )
			break;
		dchar += (rec.s.s_name[i] << (i&7));
		}

	/* Quick check if solid already in solid table.			*/
	nnt = 0;
	for( i = 0; i < nns; i++ )
		{
		if( dchar == discr[i] )
			{ /* Quick look match - check further.		*/
			(void) lseek( rd_idfd, (long)(i * sizeof d_ident), 0 );
			eread( rd_idfd, (char *) &idbuf, sizeof d_ident );
			d_ident.i_index = i + 1;
			if( check( (char *) &d_ident, (char *) &idbuf ) == 1 )
				{
				/* Really is an old solid.		*/
				nnt = i + 1;
				goto notnew;
				}
			/* False alarm - keep looking for quick look
				matches.
			 */
			}
		}

	/* New solid.							*/
	discr[nns] = dchar;
	nns++;
	d_ident.i_index = nns;

	if( nns > MAXSOL )
		{
		(void) fprintf( stderr,
				"\nNumber of solids (%d) greater than max (%d).\n",
				nns, MAXSOL
				);
		exit( 10 );
		}

	/* Write ident struct at end of idfd file.			*/
	(void) lseek( idfd, 0L, 2 );
	ewrite( idfd, (char *) &d_ident, sizeof d_ident );
	nnt = nns;

	/* Process this solid.						*/
	mat_copy( xform, old_xlate );
	mat_copy( notrans, xform );

	/* Notrans = homogeneous matrix with a zero translation vector.	*/
	notrans[3] = notrans[7] = notrans[11] = 0.0;

	/* Write solid #.						*/
	itoa( nnt+delsol, buf, 5 );
	ewrite( solfd, buf, 5 );

	/* Process appropriate solid type.				*/
	switch( rec.s.s_type )
		{
	case TOR :
		addtor( &rec );
		break;
	case GENARB8 :
		addarb( &rec );
		break;
	case GENELL :
		addell( &rec );
		break;
	case GENTGC :
		addtgc( &rec );
		break;
	case ARS :
		addars( &rec );
		break;
	default:
		(void) fprintf( stderr,
				"Solid type (%d) unknown.\n", rec.s.s_type
				);
		exit( 10 );
		}

notnew:	/* Sent here if solid already in solid table.			*/
	/* Finished with solid.						*/
	/* Put solid in present region if regflag == 1.			*/
	if( regflag == 1 )
		{
		/* isave = number of this solid in this region, if
			negative then is the last solid in this region.
		 */
		if(	(isave % 9 ==  1 && isave >  1)
		    ||	(isave % 9 == -1 && isave < -1)
			)
			{	int	n;
			/* New line.					*/
		    	n = 69 - (regBufPtr - regBuffer);
		    	putSpaces( regBufPtr, n );
		    	endRegion( buff );
			putSpaces( regBufPtr, 6 );
			}
		nnt += delsol;
		if( operate == '-' )	nnt = -nnt;
		if( orflag == 1 )
			{
			if( operate == UNION || isave == 1 )
				{
				(void) sprintf( regBufPtr, "or" );
				regBufPtr += 2;
				}
			else
				putSpaces( regBufPtr, 2 );
			}
		else
			putSpaces( regBufPtr, 2 );
		(void) sprintf( regBufPtr, "%5d", nnt );
		regBufPtr += 5;
		if( nnt < 0 )	nnt = -nnt;
		nnt -= delsol;
		if( isave < 0 )
			{	int	n; /* end this region */
			isave = -isave;
			regflag = 0;
			n = 69 - (regBufPtr - regBuffer);
			putSpaces( regBufPtr, n );
			endRegion( buff );
			}
		}
	else
	if( old_xlate[15] > EPSILON )
		{
		/* Solid not part of a region, make solid into region
			if scale > 0
		 */
		++nnr;
		(void) sprintf( regBufPtr, "%5d%8d", nnr+delreg, nnt+delsol );
		regBufPtr += 13;
		putSpaces( regBufPtr, 56 );
		(void) sprintf( regBufPtr, rec.s.s_name );
		regBufPtr += strlen( rec.s.s_name );
		itoa( nnr+delreg, buf, 5 );
		ewrite( ridfd, buf, 5 );

		/* Values for item, space, material and percentage are
			meaningless at this point.
		 */
		ewrite( ridfd, "    0", 5 );
		ewrite( ridfd, "    0", 5 );
		ewrite( ridfd, "    0", 5 );
		ewrite( ridfd, "    0", 5 );
		blank_fill( ridfd, 5 );
		(void) printf( "%4d:", nnr+delreg );
		bp = buf;
		length = strlen( rec.s.s_name );
		for( i = 0; i < pathpos; i++ )
			{
			(void) strncpy(	bp,
					path[i]->d_namep,
					strlen( path[i]->d_namep )
					);
			bp += strlen( path[i]->d_namep );
			*bp++ = '/';
			}
		length += bp - buf;
		if( length > 50 )
			{
			bp = buf + (length - 50);
			*bp = '*';
			ewrite(	ridfd,
				bp,
				(unsigned) (50 - strlen( rec.s.s_name ))
				);
			}
		else
			ewrite( ridfd, buf, (unsigned)(bp - buf) );

		if( rec.u_id == ID_ARS_B )
			{ /* Ars extension record.	*/
			(void) printf( "/%s\n", ars_name );
			ewrite(	ridfd,
				ars_name,
				(unsigned) strlen( ars_name )
				);
			}
		else
			{
			(void) printf( "/%s\n", rec.s.s_name );
			ewrite(	ridfd,
				rec.s.s_name,
				(unsigned) strlen( rec.s.s_name )
				);
			}
		ewrite( ridfd, LF, 1 );
		{	int	n;
		n = 69 - (regBufPtr - regBuffer);
		putSpaces( regBufPtr, n );
		endRegion( "" );
		}
		}
	if( isave < 0 )
		regflag = 0;
	(void) lseek( objfd, savepos, 0 );
	return;
	}
#endif
@


9.4
log
@Working trc too
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/vdeck/RCS/vdeck.c,v 9.3 91/06/01 20:34:47 mike Exp $ (BRL)";
d47 7
d85 10
d197 2
a198 1
			sort( toc_list, ndir );
@


9.3
log
@Modified to be more generally useful.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/vdeck/RCS/vdeck.c,v 9.2 91/06/01 00:52:19 mike Exp $ (BRL)";
a492 1
#if 0
d494 2
a495 1
		addtgc( &rec );
d497 1
d1249 1
a1249 1
addtgc( v, tgc, name, num )
d1251 1
a1251 1
struct rt_tgc_internal	*tgc;
d1259 1
a1259 1
	union record	*rec;	/* XXX */
d1262 8
a1269 7
	rec->s.s_cgtype = TGC;
	VCROSS( axb, SV2, SV3 );
	VCROSS( cxd, SV4, SV5 );
	ma = MAGNITUDE( SV2 );
	mb = MAGNITUDE( SV3 );
	mc = MAGNITUDE( SV4 );
	md = MAGNITUDE( SV5 );
d1272 1
a1272 1
	mh = MAGNITUDE( SV1 );
d1276 1
a1276 2
	if( mc == 0.0 )
		{
d1281 2
a1282 3
		}
	if( md == 0.0 )
		{
d1287 1
a1287 1
		}
d1291 1
a1291 1
		rec->s.s_cgtype = TEC;
d1294 2
a1295 4
	if( fabs( fabs(VDOT(SV1,axb)) - (mh*maxb) ) < CONV_EPSILON )
		{
		if( fabs( ma-mb ) < CONV_EPSILON )
			{
d1297 1
a1297 1
				rec->s.s_cgtype = RCC;
d1299 5
a1303 5
				rec->s.s_cgtype = TRC;
			}
		else    /* elliptical */
		if( fabs( ma-mc ) < CONV_EPSILON )
			rec->s.s_cgtype = REC;
d1305 1
d1311 6
a1316 10
	if( rec->s.s_cgtype == REC || rec->s.s_cgtype == TEC )
		{
		if( ma < mb )
			{
			swap_vec( SV2, SV3 );
			swap_dbl( &ma, &mb );
			swap_vec( SV4, SV5 );
			swap_dbl( &mc, &md );
			}
		}
d1319 2
a1320 2
	switch( rec->s.s_cgtype )
		{
d1322 20
a1341 6
		ewrite( solfd, "tgc  ", 5 );
		work[0] = mc;
		work[1] = md;
		work[2] = 0.0;
		VMOVE( SV4, work );
		psp( 5, rec );
d1344 12
a1355 5
		ewrite( solfd, "rcc  ", 5 );
		work[0] = ma;
		work[1] = work[2] = 0.0;
		VMOVE( SV2, work );
		psp( 3, rec );
d1358 13
a1370 6
		ewrite( solfd, "trc  ", 5 );
		work[0] = ma;
		work[1] = mc;
		work[2] = 0.0;
		VMOVE( SV2, work );
		psp( 3, rec );
d1373 19
a1391 9
		ewrite( solfd, "tec  ", 5 );
		/* This backwards conversion is to counteract an unnecessary
			conversion of this ratio in 'psp()'.  Sorry about
			that.
		 */
		work[0] = (ma / mc) / unit_conversion;
		work[1] = work[2] = 0.0;
		VMOVE( SV4, work );
		psp( 5, rec );
d1394 12
a1405 2
		ewrite( solfd, "rec  ", 5 );
		psp( 4, rec );
d1410 1
a1410 1
				rec->s.s_cgtype
d1413 1
a1413 2
		}
	return;
@


9.2
log
@Modernization beings
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/vdeck/RCS/vdeck.c,v 9.1 89/05/19 06:14:10 mike Rel3_5 $ (BRL)";
d78 3
a80 1
/*	m a i n ( )							*/
d285 2
d296 6
a329 2
			*op = '\n';
			ewrite( regfd, obuf, 6+9*7+1 );
d334 4
a337 2
			*op = '\n';
			ewrite( regfd, obuf, 6+left+1 );
a338 1
			break;
d340 5
d365 2
a366 1
		rt_vls_strcat( &ident, fullname );
d477 1
a477 2
	/* Write solid #.						*/
	vls_itoa( &sol, stp->st_bit+delsol, 5 );
d481 1
a481 1
	case ID_TOR :
d485 3
a487 2
	case GENARB8 :
		addarb( &rec );
d489 1
a489 1
	case ID_ELL :
d493 2
a494 1
	case GENTGC :
d497 1
a497 1
	case ARS :
d500 1
d503 9
a511 4
				"Solid type (%d) unknown.\n", rec.s.s_type
				);
		exit( 10 );
		}
d1038 4
a1041 2
/*	a d d t o r ( )
	Process torus.
d1043 1
a1043 1
addtor( v, tor, name, num )
d1045 1
a1045 1
struct rt_tor_internal	*tor;
d1052 1
a1052 1
	RT_TOR_CK_MAGIC(tor);
d1055 1
a1055 1
	VSCALE( norm, tor->h, 1/tor->r_h );
d1057 1
d1059 1
a1059 1
	vls_ftoa_vec_cvt( v, tor->v, 10, 4 );
d1066 2
a1067 2
	vls_ftoa( v, tor->r_a*unit_conversion, 10, 4 );
	vls_ftoa( v, tor->r_h*unit_conversion, 10, 4 );
d1073 9
a1081 15
/*	a d d a r b ( )
	Process generalized arb.
 */
addarb( rec )
register Record	*rec;
	{	register int	i;
		float	work[3], worc[3];
		hvect_t	v_work, v_workk;
		double	xmin, xmax, ymin, ymax, zmin, zmax;
		int	univecs[8], samevecs[11];
	
	/* Operate on vertex.						*/
	vtoh_move( v_workk, &(rec->s.s_values[0]) );
	matXvec( v_work, xform, v_workk );
	htov_move( &(rec->s.s_values[0]), v_work );
d1083 11
a1093 12
	/* Rest of vectors.						*/
	for( i = 3; i <= 21; i += 3 )
		{
		vtoh_move( v_workk, &(rec->s.s_values[i]) );
		matXvec( v_work, notrans, v_workk );
		htov_move( v_workk, v_work );

		/* Point notation.					*/
		VADD2(	&(rec->s.s_values[i]),
			&(rec->s.s_values[0]),
			v_workk
			);
d1095 5
d1101 17
d1119 10
a1128 3
	if( (i = cgarbs( rec, univecs, samevecs )) == 0 ) return;
	(void) redoarb( rec, univecs, samevecs, i );
	rec->s.s_cgtype *= -1;
d1131 3
a1133 5
	switch( rec->s.s_cgtype )
		{
	case ARB8 :
		ewrite( solfd, "arb8 ", 5 );
		psp( 8, rec );
d1135 2
a1136 3
	case ARB7 :
		ewrite( solfd, "arb7 ", 5 );
		psp( 7, rec );
d1138 3
a1140 4
	case ARB6 :
		ewrite( solfd, "arb6 ", 5 );
		VMOVE( SV5, SV6 );
		psp( 6, rec );
d1142 2
a1143 3
	case ARB5 :
		ewrite( solfd, "arb5 ", 5 );
		psp( 5, rec );
d1145 3
a1147 4
	case ARB4 :
		ewrite( solfd, "arb4 ", 5 );
		VMOVE( SV3, SV4 );
		psp( 4, rec );
d1149 5
a1153 38
	case RAW :
		ewrite( solfd, "raw  ", 5 );
		VSUB2( work, SV1, SV0 );
		VSUB2( SV1, SV3, SV0);		/* H */
		VMOVE( SV2, work);		/* W */
		VSUB2( SV3, SV4, SV0);		/* D */
		psp( 4, rec );
		break;
	case BOX :
		ewrite( solfd, "box  ", 5 );
		VSUB2( work, SV1, SV0 );
		VSUB2( SV1, SV3, SV0);		/* H */
		VMOVE( SV2, work);		/* W */
		VSUB2( SV3, SV4, SV0);		/* D */
		psp( 4, rec );
		break;
	case RPP :
		ewrite( solfd, "rpp  ", 5 );
		xmin = ymin = zmin = 100000000.0;
		xmax = ymax = zmax = -100000000.0;
		for( i = 0; i <= 21; i += 3 )
			{
			MINMAX(xmin, xmax, rec->s.s_values[i]);
			MINMAX(ymin, ymax, rec->s.s_values[i+1]);
			MINMAX(zmin, zmax, rec->s.s_values[i+2]);
			}
		work[0] = xmin;
		work[1] = xmax;
		work[2] = ymin;
		worc[0] = ymax;
		worc[1] = zmin;
		worc[2] = zmax;
		VMOVE( SV0, work );
		VMOVE( SV1, worc );
		psp( 2, rec );
		break;
	default :
		(void) fprintf( stderr, "Unknown arb (%d).\n", rec->s.s_cgtype );
a1154 2
		}
	return;
d1156 1
d1161 1
a1161 1
addell( v, ell, name, num )
d1163 1
a1163 1
struct rt_ell_internal	*ell;
d1172 3
a1174 3
	ma = MAGNITUDE( ell->a );
	mb = MAGNITUDE( ell->b );
	mc = MAGNITUDE( ell->c );
d1183 1
a1183 1
			swap_vec( ell->a, ell->c );
d1190 1
a1190 1
		swap_vec( ell->a, ell->b );
d1198 1
d1200 1
a1200 1
	case GENELL :
d1202 2
a1203 2
		vls_ftoa_vec_cvt( v, ell->v, 10, 4 );
		vls_ftoa_vec_cvt( v, ell->a, 10, 4 );
d1209 2
a1210 2
		vls_ftoa_vec_cvt( v, ell->b, 10, 4 );
		vls_ftoa_vec_cvt( v, ell->c, 10, 4 );
d1214 1
a1214 1
	case ELL1 :
d1216 2
a1217 2
		vls_ftoa_vec_cvt( v, ell->v, 10, 4 );
		vls_ftoa_vec_cvt( v, ell->a, 10, 4 );
d1228 1
a1228 1
	case SPH :
d1230 1
a1230 1
		vls_ftoa_vec_cvt( v, ell->v, 10, 4 );
d1236 1
a1236 1
	default :
d1326 1
a1326 1
	case TGC :
d1334 1
a1334 1
	case RCC :
d1341 1
a1341 1
	case TRC :
d1349 1
a1349 1
	case TEC :
d1360 1
a1360 1
	case REC :
d1364 1
a1364 1
	default :
d1385 1
d1436 2
a1437 1
	}
@


9.1
log
@Release_3.5
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: vdeck.c,v 8.3 89/05/07 23:40:37 mike Exp $ (BRL)";
d41 1
a41 1
|    |Idents  : reg_#,ident,space,mat,%,descriptn : 5i5,5x,a40             |
a43 4
	To compile,
	               $ make 
		   or  $ make install clobber

d49 3
d53 1
a53 1
extern Directory	*diradd();
a59 2
void			mat_copy(), mat_mul(), matXvec();
void			vtoh_move(), htov_move();
d73 5
d82 2
a83 1
	setbuf( stdout, emalloc( BUFSIZ ) );
d91 6
a96 1
	builddir();	/* Build directory from object file.	 	*/
d118 1
a118 1
				free( curr_list[--curr_ct] );
d196 329
d527 1
d530 1
a530 1
register Directory	*dirp;
d537 2
a538 2
	Directory		*nextdirp, *tdirp;
	static Directory	*path[MAXPATH];
d744 1
a744 1
				lookup( mp->m_instname, NOISY )) == DIR_NULL
a746 19
#if defined( BRANCH_NAMING )
			if( mp->m_brname[0] != 0 )
				{
				/* Create an alias.  First step towards
					full branch naming.  User is
					responsible for his branch names
				 	being unique.
				 */
				if(	(tdirp =
					lookup( mp->m_brname, NOISY ))
				     !=	DIR_NULL
					)
					/* Use existing alias.		*/
					nextdirp = tdirp;
				else
					nextdirp = diradd(mp->m_brname,
							nextdirp->d_addr );
				}
#endif
d992 1
d996 5
a1000 3
swap_vec( v1, v2, work )
register float	*v1, *v2, *work;
	{
d1004 1
a1004 2
	return;
	}
d1019 7
a1025 6
addtor( rec )
register Record	*rec;
	{	register int	i;
		float	work[3];
		double	rr1, rr2;
		hvect_t	v_work, v_workk;
d1027 2
a1028 1
	ewrite( solfd, "tor  ", 5 );
d1030 2
a1031 5
	/* Operate on vertex.						*/
	vtoh_move( v_workk, &(rec->s.s_values[0]) );
	matXvec( v_work, xform, v_workk );
	htov_move( &(rec->s.s_values[0]), v_work );
	VMOVE( &(rec->s.s_values[0]) , v_work );
d1033 5
a1037 9
	/* Rest of vectors.						*/
	for( i = 3; i <= 21; i += 3 )
		{
		vtoh_move( v_workk, &(rec->s.s_values[i]) );
		matXvec( v_work, notrans, v_workk );
		htov_move( &(rec->s.s_values[i]), v_work );
		}
	rr1 = MAGNITUDE( SV2 );	/* r1 */
	rr2 = MAGNITUDE( SV1 );	/* r2 */    
d1039 8
a1046 9
	/*  print solid parameters
	 */
	work[0] = rr1;
	work[1] = rr2;
	work[2] = 0.0;
	VMOVE( SV2, work );
	psp( 3, rec );
	return;
	}
d1154 9
a1162 6
addell( rec )
register Record	*rec;
	{	register int	i;
		float	work[3];
		hvect_t	v_work, v_workk;
		double	ma, mb, mc;
a1163 13
	/* Operate on vertex.						*/
	vtoh_move( v_workk, &(rec->s.s_values[0]) );
	matXvec( v_work, xform, v_workk);
	htov_move( &(rec->s.s_values[0]), v_work );

	/* Rest of vectors.						*/
	for( i = 3; i <= 9; i += 3 )
		{
		vtoh_move( v_workk, &(rec->s.s_values[i]) );
		matXvec( v_work, notrans, v_workk );
		htov_move( &(rec->s.s_values[i]), v_work );
		}

d1165 6
a1170 6
	ma = MAGNITUDE( SV1 );
	mb = MAGNITUDE( SV2 );
	mc = MAGNITUDE( SV3 );
	if( fabs( ma-mb ) < CONV_EPSILON )
		{ /* vector A == vector B */
		rec->s.s_cgtype = ELL1;
d1173 1
a1173 1
			rec->s.s_cgtype = SPH;
d1176 1
a1176 1
			swap_vec( SV1, SV3, work );
d1179 3
a1181 5
		}
	else
	if( fabs( ma-mc ) < CONV_EPSILON )
		{ /* vector A == vector C */
		rec->s.s_cgtype = ELL1;
d1183 1
a1183 1
		swap_vec( SV1, SV2, work );
d1185 2
a1186 1
		}
d1188 1
a1188 4
	if( fabs( mb-mc ) < CONV_EPSILON ) 
		rec->s.s_cgtype = ELL1;
	else
		rec->s.s_cgtype = GENELL;
d1191 1
a1191 2
	switch( rec->s.s_cgtype )
		{
d1193 12
a1204 2
		ewrite( solfd, "ellg ", 5 );
		psp( 4, rec );
d1207 12
a1218 5
		ewrite( solfd, "ell1 ", 5 );
		work[0] = mb;
		work[1] = work[2] = 0.0;
		VMOVE( SV2, work );
		psp( 3, rec );
d1221 6
a1226 5
		ewrite( solfd, "sph  ", 5 );
		work[0] = ma;
		work[1] = work[2] = 0.0;
		VMOVE( SV1, work );
		psp( 2, rec );
d1231 1
a1231 1
				rec->s.s_cgtype
a1233 2
		}
	return;
d1235 1
d1240 11
a1250 6
addtgc( rec )
register Record *rec;
	{	register int	i;
		float	work[3], axb[3], cxd[3];
		hvect_t	v_work, v_workk;
		double	ma, mb, mc, md, maxb, mcxd, mh;
a1251 12
	/* Operate on vertex.						*/
	vtoh_move( v_workk, &(rec->s.s_values[0]) );
	matXvec( v_work, xform, v_workk );
	htov_move( &(rec->s.s_values[0]), v_work );

	for( i = 3; i <= 15; i += 3 )
		{
		vtoh_move( v_workk, &(rec->s.s_values[i]) );
		matXvec( v_work, notrans, v_workk );
		htov_move( &(rec->s.s_values[i]), v_work );
		}

d1308 1
a1308 1
			swap_vec( SV2, SV3, work );
d1310 1
a1310 1
			swap_vec( SV4, SV5, work );
a1524 120
/*	m a t _ z e r o ( )
	Fill in the matrix "m" with zeros.
 */
void
mat_zero( m )
register matp_t	m;
	{	register int	i;
	for( i = 0; i < 16; i++ )
		*m++ = 0;
	return;
	}

/*	m a t _ i d n ( )
	Fill in the matrix "m" with an identity matrix.
 */
void
mat_idn( m )
register matp_t m;
	{
	mat_zero( m );
	m[0] = m[5] = m[10] = m[15] = 1;
	return;
	}

/*	m a t _ c o p y ( )
	Copy the matrix "im" into the matrix "om".
 */
void
mat_copy( om, im )
register matp_t om, im;
	{	register int	i;
	for( i = 0; i < 16; i++ )
		*om++ = *im++;
	return;
	}

/*	m a t _ m u l ( )
	Multiply matrix "im1" by "im2" and store the result in "om".
	NOTE:  This is different from multiplying "im2" by "im1" (most
	of the time!)
 */
void
mat_mul( om, im1, im2 )
register matp_t	om, im1, im2;
	{ 	register int em1;	/* Element subscript for im1.	*/
		register int em2;	/* Element subscript for im2.	*/
		register int el = 0;	/* Element subscript for om.	*/
	/* For each element in the output matrix... */
	for( ; el < 16; el++ )
		{	register int i;
		om[el] = 0;		/* Start with zero in output.	*/
		em1 = (el / 4) * 4;	/* Element at rt of row in im1.	*/
		em2 = el % 4;		/* Element at top of col in im2.*/
		for( i = 0; i < 4; i++ )
			{
			om[el] += im1[em1] * im2[em2];
			em1++;		/* Next row element in m1.	*/
			em2 += 4;	/* Next column element in m2.	*/
			}
		}
	return;
	}
/*	m a t X v e c ( )
	Multiply the vector "iv" by the matrix "im" and store the result
	in the vector "ov".
 */
void
matXvec( op, mp, vp )
register vectp_t	op;
register matp_t		mp;
register vectp_t	vp;
	{	register int io;	/* Position in output vector.	*/
		register int im = 0;	/* Position in input matrix.	*/
		register int iv;	/* Position in input vector.	*/
	/* Fill each element of output vector with.			*/
	for( io = 0; io < 4; io++ )
		{ /* Dot prod. of each row w/ each element of input vec.*/
		op[io] = 0.;
		for( iv = 0; iv < 4; iv++ )
			op[io] += mp[im++] * vp[iv];
		}
	return;
	}

/*	v t o h _ m o v e ( )						*/
void
vtoh_move( h, v)
register float	*h, *v;
	{
	*h++ = *v++;
	*h++ = *v++;
	*h++ = *v;
	*h++ = 1.0;
	return;
	}

/*	h t o v _ m o v e ( )						*/
void
htov_move( v, h )
register float	*v, *h;
	{	static double	inv;
	if( h[3] == 1.0 )
		{
		*v++ = *h++;
		*v++ = *h++;
		*v   = *h;
		}
	else
		{
		if( h[3] == 0.0 )
			inv = 1.0;
		else
			inv = 1.0 / h[3];
		*v++ = *h++ * inv;
		*v++ = *h++ * inv;
		*v = *h * inv;
		}
	return;
	}

d1579 1
a1579 1
Directory	*dirp;
a1585 13
	}

char *
emalloc( size )
int	size;
	{
		char		*ptr;
	if( (ptr = (char *)malloc( (unsigned) size )) == NULL )
		{
		(void) fprintf( stderr, "Malloc() failed!\n" );
		exit( 1 );
		}
	return	ptr;
@


8.3
log
@Fixed SCC complaint.

@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: vdeck.c,v 8.2 89/04/24 08:28:42 mike Locked $ (BRL)";
@


8.2
log
@Inline declaration for fabs() clashed with system definition
(w/prototype) on sgi 4D
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: vdeck.c,v 8.1 88/10/05 00:53:06 mike Locked $ (BRL)";
d1401 1
a1401 1
	{	extern char	*malloc();
d1403 1
a1403 1
	if( (ptr = malloc( (unsigned) size )) == NULL )
@


8.1
log
@Release_3.0
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: vdeck.c,v 7.1 87/11/03 00:28:08 mike Rel $ (BRL)";
d51 1
a54 2
extern double		fabs();
extern long		lseek();
@


7.1
log
@Release 2.3
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: vdeck.c,v 6.1 87/07/11 08:17:05 mike Rel $ (BRL)";
a1277 1

@


6.1
log
@Release 2.0
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: vdeck.c,v 5.1 87/06/24 22:48:58 mike Rel $ (BRL)";
@


5.1
log
@Release 1.24
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: vdeck.c,v 4.4 87/02/26 13:41:56 moss Exp $ (BRL)";
@


4.4
log
@Backed out revision 2.17 which had erroniously substituted 4-element vectors in transformation matrix
multiplies to 3-element vectors.  This caused translations to be lost.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: vdeck.c,v 4.3 87/02/25 09:36:28 moss Locked $ (BRL)";
@


4.3
log
@Extended buffer in "psp()" by 1 char, it was being overrun, clobbering the stack.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d62 2
a63 1
void			mat_copy(), mat_mul();
d704 1
a704 1
		vect_t	v_work, v_workk;
d709 4
a712 3
	VMOVE( v_workk, &(rec->s.s_values[0]) );
	MAT4X3VEC( v_work, xform, v_workk );
	VMOVE( &(rec->s.s_values[0]), v_work );
d715 6
a720 5
	for( i = 3; i <= 21; i += 3 )  {
		VMOVE( v_workk, &(rec->s.s_values[i]) );
		MAT4X3VEC( v_work, notrans, v_workk );
		VMOVE( &(rec->s.s_values[i]), v_work );
	}
d741 1
a741 1
		vect_t	v_work, v_workk;
d746 3
a748 3
	VMOVE( v_workk, &(rec->s.s_values[0]) );
	MAT4X3VEC( v_work, xform, v_workk );
	VMOVE( &(rec->s.s_values[0]), v_work );
d753 3
a755 3
		VMOVE( v_workk, &(rec->s.s_values[i]) );
		MAT4X3VEC( v_work, notrans, v_workk );
		VMOVE( v_workk, v_work );
d844 1
a844 1
		vect_t	v_work, v_workk;
d848 3
a850 3
	VMOVE( v_workk, &(rec->s.s_values[0]) );
	MAT4X3VEC( v_work, xform, v_workk);
	VMOVE( &(rec->s.s_values[0]), v_work );
d855 3
a857 3
		VMOVE( v_workk, &(rec->s.s_values[i]) );
		MAT4X3VEC( v_work, notrans, v_workk );
		VMOVE( &(rec->s.s_values[i]), v_work );
d928 1
a928 1
		vect_t	v_work, v_workk;
d932 3
a934 3
	VMOVE( v_workk, &(rec->s.s_values[0]) );
	MAT4X3VEC( v_work, xform, v_workk );
	VMOVE( &(rec->s.s_values[0]), v_work );
d938 3
a940 3
		VMOVE( v_workk, &(rec->s.s_values[i]) );
		MAT4X3VEC( v_work, notrans, v_workk );
		VMOVE( &(rec->s.s_values[i]), v_work );
d1066 1
a1066 1
		vect_t	v_work, v_workk;
d1096 3
a1098 3
			VMOVE( v_workk, &(rec->b.b_values[0]) );
			MAT4X3VEC( v_work, xform, v_workk );
			VMOVE( &(rec->b.b_values[0]), v_work );
d1108 3
a1110 3
			VMOVE( v_workk, &(rec->b.b_values[vec*3]) );
			MAT4X3VEC( v_work, notrans, v_workk );
			VMOVE( work, v_work );
a1120 1

d1275 58
@


4.2
log
@Release 1.20 -- First Formal Release
@
text
@a1 5
	SCCS id:	@@(#) vdeck.c	2.15
	Last edit: 	8/12/86 at 08:58:59
	Retrieved: 	8/13/86 at 08:15:47
	SCCS archive:	/m/cad/vdeck/RCS/s.vdeck.c

d8 2
a9 3
#if ! defined( lint )
static
char	sccsTag[] = "@@(#) vdeck.c	2.15	last edit 8/12/86 at 08:58:59";
d1117 2
d1126 1
a1126 1
		char		buf[60];
d1139 1
a1139 1
			ewrite( solfd, buf, 60 );
d1156 1
a1156 1
		for( k = 30; k <= 60; k++ )
d1158 1
a1158 1
		ewrite( solfd, buf, 60 );
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@@


2.17
log
@Eliminated htov_ stuff, using MAT4X3VECT now.
@
text
@@


2.16
log
@SGI fixes
@
text
@d68 1
a68 2
void			mat_copy(), mat_mul(), matXvec();
void			vtoh_move(), htov_move();
d714 3
a716 4
	vtoh_move( v_workk, &(rec->s.s_values[0]) );
	matXvec( v_work, xform, v_workk );
	htov_move( &(rec->s.s_values[0]), v_work );
	VMOVE( &(rec->s.s_values[0]) , v_work );
d719 5
a723 6
	for( i = 3; i <= 21; i += 3 )
		{
		vtoh_move( v_workk, &(rec->s.s_values[i]) );
		matXvec( v_work, notrans, v_workk );
		htov_move( &(rec->s.s_values[i]), v_work );
		}
d749 3
a751 3
	vtoh_move( v_workk, &(rec->s.s_values[0]) );
	matXvec( v_work, xform, v_workk );
	htov_move( &(rec->s.s_values[0]), v_work );
d756 3
a758 3
		vtoh_move( v_workk, &(rec->s.s_values[i]) );
		matXvec( v_work, notrans, v_workk );
		htov_move( v_workk, v_work );
d851 3
a853 3
	vtoh_move( v_workk, &(rec->s.s_values[0]) );
	matXvec( v_work, xform, v_workk);
	htov_move( &(rec->s.s_values[0]), v_work );
d858 3
a860 3
		vtoh_move( v_workk, &(rec->s.s_values[i]) );
		matXvec( v_work, notrans, v_workk );
		htov_move( &(rec->s.s_values[i]), v_work );
d935 3
a937 3
	vtoh_move( v_workk, &(rec->s.s_values[0]) );
	matXvec( v_work, xform, v_workk );
	htov_move( &(rec->s.s_values[0]), v_work );
d941 3
a943 3
		vtoh_move( v_workk, &(rec->s.s_values[i]) );
		matXvec( v_work, notrans, v_workk );
		htov_move( &(rec->s.s_values[i]), v_work );
d1099 3
a1101 3
			vtoh_move( v_workk, &(rec->b.b_values[0]) );
			matXvec( v_work, xform, v_workk );
			htov_move( &(rec->b.b_values[0]), v_work );
d1111 3
a1113 3
			vtoh_move( v_workk, &(rec->b.b_values[vec*3]) );
			matXvec( v_work, notrans, v_workk );
			htov_move( work, v_work );
a1276 58
		}
	return;
	}

/*	m a t X v e c ( )
	Multiply the vector "iv" by the matrix "im" and store the result
	in the vector "ov".
 */
void
matXvec( op, mp, vp )
register vectp_t	op;
register matp_t		mp;
register vectp_t	vp;
	{	register int io;	/* Position in output vector.	*/
		register int im = 0;	/* Position in input matrix.	*/
		register int iv;	/* Position in input vector.	*/
	/* Fill each element of output vector with.			*/
	for( io = 0; io < 4; io++ )
		{ /* Dot prod. of each row w/ each element of input vec.*/
		op[io] = 0.;
		for( iv = 0; iv < 4; iv++ )
			op[io] += mp[im++] * vp[iv];
		}
	return;
	}

/*	v t o h _ m o v e ( )						*/
void
vtoh_move( h, v)
register float	*h, *v;
	{
	*h++ = *v++;
	*h++ = *v++;
	*h++ = *v;
	*h++ = 1.0;
	return;
	}

/*	h t o v _ m o v e ( )						*/
void
htov_move( v, h )
register float	*v, *h;
	{	static double	inv;
	if( h[3] == 1.0 )
		{
		*v++ = *h++;
		*v++ = *h++;
		*v   = *h;
		}
	else
		{
		if( h[3] == 0.0 )
			inv = 1.0;
		else
			inv = 1.0 / h[3];
		*v++ = *h++ * inv;
		*v++ = *h++ * inv;
		*v = *h * inv;
@


2.15
log
@Remove lookup of branch names, we don't use them anymore.
@
text
@a56 1
#include <setjmp.h>
d58 1
d978 1
a978 1
	    &&  fabs( fabs(DOT(axb,cxd)) - (maxb*mcxd) ) < CONV_EPSILON
d983 1
a983 1
	if( fabs( fabs(DOT(SV1,axb)) - (mh*maxb) ) < CONV_EPSILON )
@


2.14
log
@Correcting magnitude of A > B fix.
@
text
@d2 3
a4 3
	SCCS id:	@@(#) vdeck.c	2.14
	Last edit: 	7/10/86 at 14:54:11
	Retrieved: 	8/13/86 at 08:15:21
d15 1
a15 1
char	sccsTag[] = "@@(#) vdeck.c	2.14	last edit 7/10/86 at 14:54:11";
d416 1
d434 1
@


2.13
log
@Swapped vectors for TEC and REC to appease GIFT. Linted code.
@
text
@d2 3
a4 3
	SCCS id:	@@(#) vdeck.c	2.13
	Last edit: 	7/10/86 at 11:07:04
	Retrieved: 	8/13/86 at 08:14:41
d15 1
a15 1
char	sccsTag[] = "@@(#) vdeck.c	2.13	last edit 7/10/86 at 11:07:04";
a1004 3
			}
		if( mc < md )
			{
@


2.12
log
@Fixed buffer size in cgobj(), linted quite a bit.
@
text
@d2 3
a4 3
	SCCS id:	@@(#) vdeck.c	2.12
	Last edit: 	12/20/85 at 19:03:57
	Retrieved: 	8/13/86 at 08:14:09
d15 1
a15 1
char	sccsTag[] = "@@(#) vdeck.c	2.12	last edit 12/20/85 at 19:03:57";
d62 4
a66 2
char			regBuffer[BUFSIZ], *regBufPtr;
extern void		quit();
d68 4
d74 1
a74 1
	    	(void) write( regfd, regBuffer, (unsigned) strlen( regBuffer ) ); \
d99 2
a100 2
	setjmp( env );	/* Point of re-entry from aborted command.	*/
	(void) printf( "%s", CMD_PROMPT );	
d107 1
a107 1
		signal( SIGINT, quit );
d122 2
a123 2
				(void) printf( "enter object[s] to insert: " );
				getcmd( arg_list, arg_ct );
d125 1
a125 1
			insert( arg_list, arg_ct );
d131 1
a131 1
				col_prt( curr_list, curr_ct );
d137 1
a137 1
			col_prt( tmp_list, tmp_ct );
d142 1
a142 1
			(void) printf( "%s", PROMPT );
d147 4
a150 4
				(void) printf( "enter number of 1st solid: " );
				getcmd( arg_list, arg_ct );
				(void) printf( "enter number of 1st region: " );
				getcmd( arg_list, arg_ct );
d160 2
a161 2
				(void) printf( "enter object[s] to remove: " );
				getcmd( arg_list, arg_ct );
d163 1
a163 1
			delete( arg_list );
d166 1
a166 1
			(void) printf( "%s", PROMPT );
d171 2
a172 2
				(void) printf( "enter shell command: " );
				getcmd( arg_list, arg_ct );
d174 1
a174 1
			shell( arg_list );
d187 2
a188 1
			(void) printf( "invalid command\n%s", PROMPT );
d191 1
a191 1
		(void) printf( "%s", CMD_PROMPT );		
d229 1
a229 1
	readF( objfd, (char *) &rec, sizeof rec );
d272 1
a272 1
				readF( rd_rrfd, name, (unsigned) NAMESIZE );
d340 1
a340 1
			(void) write( rrfd, rec.c.c_name, NAMESIZE );
d346 1
a346 1
				readF( objfd, (char *) &rec, sizeof rec );
d349 1
a349 1
					readF( objfd, (char *) &rec, sizeof rec );
d357 1
a357 1
				readF( objfd, (char *) &rec, sizeof rec );
d365 1
a365 1
			(void) write( ridfd, buf, 25 );
d384 4
a387 4
				(void) write(	ridfd,
						bp,
						(unsigned)(50 - strlen( rec.c.c_name ))
						);
d390 6
a395 6
				(void) write( ridfd, buf, (unsigned)(bp - buf) );
			(void) write(	ridfd,
					rec.c.c_name,
					(unsigned) strlen( rec.c.c_name )
					);
			(void) write( ridfd, LF, 1 );
d406 1
a406 1
			readF( objfd, (char *) &rec, sizeof rec );
d488 1
a488 1
			readF( rd_idfd, (char *) &idbuf, sizeof d_ident );
d518 1
a518 1
	(void) write( idfd, (char *) &d_ident, sizeof d_ident );
d526 1
a526 1
	notrans[3]  = notrans[7]  = notrans[11] = 0.0;
d530 1
a530 1
	(void) write( solfd, buf, 5 );
d615 1
a615 1
		(void) write( ridfd, buf, 5 );
d620 4
a623 4
		(void) write( ridfd, "    0", 5 );
		(void) write( ridfd, "    0", 5 );
		(void) write( ridfd, "    0", 5 );
		(void) write( ridfd, "    0", 5 );
d642 4
a645 4
			(void) write(	ridfd,
					bp,
					(unsigned) (50 - strlen( rec.s.s_name ))
					);
d648 1
a648 1
			(void) write( ridfd, buf, (unsigned)(bp - buf) );
d652 5
a656 5
			printf( "/%s\n", ars_name );
			(void) write(	ridfd,
					ars_name,
					(unsigned) strlen( ars_name )
					);
d660 5
a664 5
			printf( "/%s\n", rec.s.s_name );
			(void) write(	ridfd,
					rec.s.s_name,
					(unsigned) strlen( rec.s.s_name )
					);
d666 1
a666 1
		(void) write( ridfd, LF, 1 );
d679 21
d704 5
a708 7
register
Record *rec;
{
	int	i;
	float	work[3];
	float	rr1,rr2;
	vect_t	v_work, v_workk;
d710 1
a710 1
	write( solfd, "tor  ", 5 );
d712 1
a712 2
	/* operate on vertex
	 */
d718 3
a720 3
	/* rest of vectors
	 */
	for( i = 3; i <= 21; i += 3 ) {
d724 1
a724 1
	}
d736 1
a736 1
}
d742 6
a747 8
register
Record *rec;
{
	register int	i;
	float	work[3], worc[3];
	vect_t	v_work, v_workk;
	float	xmin, xmax, ymin, ymax, zmin, zmax;
	int	univecs[8], samevecs[11];
d755 2
a756 1
	for( i = 3; i <= 21; i += 3 ) {
d765 2
a766 2
		);
	}
d770 1
a770 1
	redoarb( rec, univecs, samevecs, i );
d774 4
a777 3
	switch( rec->s.s_cgtype ) {
	case ARB8:
		write( solfd, "arb8 ", 5 );
d780 2
a781 2
	case ARB7:
		write( solfd, "arb7 ", 5 );
d784 2
a785 2
	case ARB6:
		write( solfd, "arb6 ", 5 );
d789 2
a790 2
	case ARB5:
		write( solfd, "arb5 ", 5 );
d793 2
a794 2
	case ARB4:
		write( solfd, "arb4 ", 5 );
d798 2
a799 2
	case RAW:
		write( solfd, "raw  ", 5 );
d806 2
a807 2
	case BOX:
		write( solfd, "box  ", 5 );
d814 2
a815 2
	case RPP:
		write( solfd, "rpp  ", 5 );
d818 2
a819 1
		for(i=0; i<=21; i+=3) {
d823 1
a823 1
		}
d834 2
a835 2
	default:
		fprintf( stderr, "Unknown arb (%d).\n", rec->s.s_cgtype );
d837 2
a839 2
	return;
}
d845 7
a851 9
register
Record *rec;
{
	int	i;
	float	work[3];
	vect_t	v_work, v_workk;

	/* operate on vertex
	 */
d856 3
a858 3
	/* rest of vectors
	 */
	for( i = 3; i <= 9; i += 3 ) {
d862 1
a862 1
	}
d864 6
a869 4
	/* check for ell1 or sph
	 */
	if( fabs( MAGNITUDE(SV1) - MAGNITUDE(SV2) ) < CONV_EPSILON ) {
		/* vector A == vector B */
d872 1
a872 1
		if(fabs(MAGNITUDE(SV2) - MAGNITUDE(SV3)) < CONV_EPSILON)
d874 5
a878 5
		if(rec->s.s_cgtype != SPH) {
			/* switch A and C */
			VMOVE(work, SV1);
			VMOVE(SV1, SV3);
			VMOVE(SV3, work);
a879 2
	}

d881 2
a882 2
	if(fabs(MAGNITUDE(SV1) - MAGNITUDE(SV3)) < CONV_EPSILON) {
		/* vector A == vector C */
d885 3
a887 5
		VMOVE(work, SV1);
		VMOVE(SV1, SV2);
		VMOVE(SV2, work);
	}

d889 1
a889 1
	if(fabs(MAGNITUDE(SV2) - MAGNITUDE(SV3)) < CONV_EPSILON) 
a890 1

d894 5
a898 5
	/* print the solid parameters
	 */
	switch( rec->s.s_cgtype ) {
	case GENELL:
		write( solfd, "ellg ", 5 );
d901 3
a903 3
	case ELL1:
		write( solfd, "ell1 ", 5 );
		work[0] = MAGNITUDE( SV2 );
d908 3
a910 3
	case SPH:
		write( solfd, "sph  ", 5 );
		work[0] = MAGNITUDE( SV1 );
d915 5
a919 3
	default:
		fprintf( stderr,
			"Error in type of ellipse (%d).\n", rec->s.s_cgtype );
d921 2
a923 2
	return;
}
d929 5
a933 7
register
Record *rec;
{
	register int	i;
	float	work[3], axb[3], cxd[3];
	vect_t	v_work, v_workk;
	float	ma, mb, mc, md, maxb, mcxd, mh;
d935 1
a935 2
	/* operate on vertex
	 */
d940 2
a941 1
	for( i = 3; i <= 15; i += 3 ) {
d945 1
a945 1
	}
d947 1
a947 2
	/* check for tec rec trc rcc
	 */
d959 1
a959 1
	/* tec if ratio top and bot vectors equal and base parallel to top
d961 5
a965 2
	if( mc == 0.0 ) {
		fprintf( stderr, "Error in TGC, C vector has zero magnitude!\n" );
d967 6
a972 3
	}
	if( md == 0.0 ) {
		fprintf( stderr, "Error in TGC, D vector has zero magnitude!\n" );
d974 1
a974 1
	}
d980 1
a980 2
	/* check for right cylinder
	 */
d995 3
a997 1
	/* print the solid parameters
d999 17
a1015 1
	switch( rec->s.s_cgtype ) {
d1017 1
a1017 1
		write( solfd, "tgc  ", 5 );
d1025 1
a1025 1
		write( solfd, "rcc  ", 5 );
d1032 1
a1032 1
		write( solfd, "trc  ", 5 );
d1040 1
a1040 1
		write( solfd, "tec  ", 5 );
d1051 1
a1051 1
		write( solfd, "rec  ", 5 );
d1054 5
a1058 3
	default:
		fprintf( stderr,
			"Error in tgc type (%d).\n", rec->s.s_cgtype );
d1060 1
a1060 1
	}
d1068 6
a1073 8
register
Record *rec;
{
	char	buf[10];
	int	i, vec;
	int	npt, npts, ncurves, ngrans, granule, totlen;
	float	work[3], vertex[3];
	vect_t	v_work, v_workk;
d1081 1
a1081 1
	(void) write( solfd, "ars  ", 5 );
d1083 1
a1083 1
	(void) write( solfd, buf, 10 );
d1085 1
a1085 1
	(void) write( solfd, buf, 10 );
d1087 2
a1088 2
	(void) write( solfd, rec->a.a_name, (unsigned) strlen( rec->a.a_name ) );
	(void) write( solfd, LF, 1 );
d1094 1
a1094 1
		readF( objfd, (char *) rec, sizeof record );
d1147 1
a1147 1
			(void) write( solfd, buf, 60 );
d1149 5
a1153 5
			(void) write(	solfd,
					rec->s.s_name,
					(unsigned) strlen( rec->s.s_name )
					);
			(void) write( solfd, LF, 1 );
d1157 1
a1157 1
				(void) write( solfd, buf, 5 );
d1166 6
a1171 6
		(void) write( solfd, buf, 60 );
		(void) write(	solfd,
				rec->s.s_name,
				(unsigned) strlen( rec->s.s_name )
				);
		(void) write( solfd, LF, 1 );
d1179 5
a1183 8
parsp(	npts,	 rec )
register
int	npts;
register
Record	*rec;
{
	register int	i, j, k, jk;
	char		bufout[80];
d1188 3
a1190 2
	for( i = 5; i < 10; i++ )	bufout[i] = ' ';
	strncpy( &bufout[70], "curve ", 6 );
d1194 4
a1197 4
	for( i = 0; i < npts*3; i += 3 ) {
		/* write 3 points
		 */
		for( k = i; k <= i+2; k++ ) {
d1203 5
a1207 5
					4 );
		}
		if( (++j & 01) == 0 ) {
			/* end of line
			 */
d1209 1
a1209 1
			write( solfd, bufout, 80 );
d1211 1
d1213 7
a1221 9
	if( (j & 01) == 1 ) {
		/* finish off line
		 */
		for( k = 40; k < 70; k++ )	bufout[k] = ' ';
		write( solfd, bufout, 80 );
	}
	return;
}

d1225 8
a1232 4
mat_zero(	m )
register matp_t m;
{
	register int	i;
a1233 4
	/* Clear everything */
	for( i = 0; i < 16; i++ )	*m++ = 0;
}

d1237 2
a1238 1
mat_idn(	m )
d1240 1
a1240 1
{
d1243 2
a1244 1
}
d1249 2
a1250 1
mat_copy(	om, im )
d1252 5
a1256 2
{
	register int	i;
a1257 5
	/* Copy all elements.				*/
	for( i = 0; i< 16; i++ )	*om++ = *im++;
}


d1263 6
a1268 7
mat_mul(	om, im1, im2 )
register matp_t om, im1, im2;
{
	register int em1;	/* Element subscript for im1.	*/
	register int em2;	/* Element subscript for im2.	*/
	register int el = 0;	/* Element subscript for om.	*/

d1270 2
a1271 1
	for( ; el < 16; el++ ) { register int i;
d1275 2
a1276 1
		for( i = 0; i < 4; i++ ) {
d1280 1
d1282 1
a1283 1
}
d1289 1
d1291 9
a1299 13
register vectp_t op;
register matp_t  mp;
register vectp_t vp;
{
	register int io;	/* Position in output vector.	*/
	register int im = 0;	/* Position in input matrix.	*/
	register int iv;	/* Position in input vector.	*/

	/* fill each element of output vector with
	 */
	for( io = 0; io < 4; io++ ) {
		/* dot product of each row with each element of input vec
		 */
d1301 4
a1304 1
		for( iv = 0; iv < 4; iv++ ) op[io] += mp[im++] * vp[iv];
a1305 1
}
d1307 5
a1311 5
/*	v t o h _ m o v e ( )
 */
vtoh_move(	h, v)
register float *h,*v;
{
d1315 3
a1317 2
	*h++ = 1.;
}
d1319 7
a1325 7
/*	h t o v _ m o v e ( )
 */
htov_move(	v, h )
register float *v,*h;
{	static float inv;

	if( h[3] == 1. ) {
d1329 7
a1335 3
	} else {
		if( h[3] == 0. )	inv = 1.;
		else			inv = 1. / h[3];
d1339 2
a1341 1
}
d1358 2
a1359 2
/*	r e a d F ( )
	Read with error checking and debugging.
d1361 2
a1362 1
readF( fd, buf, bytes )
d1364 1
a1364 1
char   		*buf;
d1366 3
a1368 3
	{	register int	bytesRead;
	if(	(bytesRead = read( fd, buf, bytes )) != (int) bytes
	   &&	bytesRead != 0
d1373 1
a1373 1
				bytesRead
d1375 1
a1375 1
	return	bytesRead;
d1378 18
d1399 1
a1399 2
	(void) fprintf( stdout,
			"dirp(0x%x)->d_namep=%s d_addr=%ld\n",
@


2.12.1.1
log
@SGI fixes
@
text
@d4 2
a5 2
	Retrieved: 	6/16/86 at 20:29:44
	SCCS archive:	/vld/src/vdeck/s.vdeck.c
d57 1
a58 1

d950 1
a950 1
	    &&  fabs( fabs(VDOT(axb,cxd)) - (maxb*mcxd) ) < CONV_EPSILON
d956 1
a956 1
	if( fabs( fabs(VDOT(SV1,axb)) - (mh*maxb) ) < CONV_EPSILON )
@


2.11
log
@Increased maximum path depth to 12.
@
text
@d2 3
a4 3
	SCCS id:	@@(#) vdeck.c	2.11
	Last edit: 	8/6/85 at 12:16:32
	Retrieved: 	8/13/86 at 08:13:43
d10 4
a13 3
			Maryland 21005
			(301)278-6647 or AV-283-6647
 */
d15 2
a16 1
char	sccsTag[] = "@@(#) vdeck.c	2.11	last edit 8/6/85 at 12:16:32";
a61 1
int			quit(), abort();
d64 6
a69 3
#define endRegion( buff )     	sprintf( regBufPtr, "%s\n", buff );\
			    	write( regfd, regBuffer, strlen( regBuffer ) );\
			    	regBufPtr = regBuffer;
d71 5
a75 3
#define putSpaces( s, xx ) {	register int i;\
				for( i = 0; i < (xx); i++ ) *s++ = ' ';\
			  }
d77 5
a81 5
/*	m a i n ( )
 */
main( argc, argv )	char	*argv[];
{
	setbuf( stdout, malloc( BUFSIZ ) );
d83 2
a84 1
	if( ! parsArg( argc, argv ) ) {
d87 1
a87 1
	}
d94 3
a96 2
	prompt( "%s", CMD_PROMPT );	
	while( 1 ) {
d103 3
a105 2
		switch( getcmd( arg_list, 0 ) ) {
		case DECK:
d109 3
a111 2
		case ERASE:
			while( curr_ct > 0 ) free( curr_list[--curr_ct] );
d113 4
a116 3
		case INSERT:
			if( arg_list[1] == 0 ) {
				prompt( "enter object[s] to insert: " );
d118 1
a118 1
			}
d121 4
a124 3
		case LIST:
		{	register int	i;
			if( arg_list[1] == 0 ) {
d127 1
a127 1
			}
d133 2
a134 2
		}
		case MENU:
d136 1
a136 1
			prompt( "%s", PROMPT );
d138 4
a141 3
		case NUMBER:
			if( arg_list[1] == 0 ) {
				prompt( "enter number of 1st solid: " );
d143 1
a143 1
				prompt( "enter number of 1st region: " );
d145 5
a149 3
			}
			if( arg_list[1] ) delsol = atoi( arg_list[1] ) - 1;
			if( arg_list[2] ) delreg = atoi( arg_list[2] ) - 1;
d151 4
a154 3
		case REMOVE:
			if( arg_list[1] == 0 ) {
				prompt( "enter object[s] to remove: " );
d156 1
a156 1
			}
d159 2
a160 2
		case RETURN:
			prompt( "%s", PROMPT );
d162 4
a165 3
		case SHELL:
			if( arg_list[1] == 0 ) {
				prompt( "enter shell command: " );
d167 1
a167 1
			}
d170 1
a170 1
		case SORT_TOC:
d173 1
a173 1
		case TOC:
d176 3
a178 3
		case EOF:
		case QUIT:
			prompt( "quitting...\n" );
d180 2
a181 2
		UNKNOWN:
			prompt( "invalid command\n%s", PROMPT );
d183 2
a185 1
		prompt( "%s", CMD_PROMPT );		
a186 1
}
d189 1
a189 1
	Build deck for object pointed to by 'dp'.
d191 5
a195 6
cgobj(	   dp, pathpos, old_xlate )
register
Directory *dp;
int	pathpos;
matp_t	old_xlate;
{
d197 4
a200 2
	Record		rec;
	Directory	*nextdp, *tdp;
d202 8
a209 8
	long	savepos, RgOffset;
	int	nparts;
	int	i, j;
	int	length;
	int	dchar = 0;
	int	nnt;
	char	buf[80], *bp;
	char	ars_name[16];
d212 3
a214 2
	if( pathpos >= MAXPATH ) {
		fprintf( stderr, "Nesting exceeds %d levels\n", MAXPATH );
d216 2
a217 2
			fprintf( stderr, "/%s", path[i]->d_namep );
		fprintf( stderr, "\n" );
d219 1
a219 1
	}
d221 2
a222 2
	lseek( objfd, dp->d_addr, 0 );
	readF( objfd, &rec, sizeof rec );
d224 5
a228 4
	if( rec.u_id == ID_COMB )  { /* We have a group.		*/
		if( regflag > 0 ) {
			/* record is part of a region
			 */
d238 3
a240 2
			if( operate == UNION ) {
				fprintf( stderr,
d243 1
a243 1
				fprintf( stderr,
d247 1
a247 1
			}
d251 3
a253 2
			    ||	(isave % 9 == -1 && isave < -1) )
			{
d256 2
a257 2
			}
			sprintf( regBufPtr, "rg%c", operate );
d262 7
a268 6
			lseek( rd_rrfd, 0L, 0 );
			for( j = 1; j <= nnr; j++ ) {
				readF( rd_rrfd, name, 16 );
				if( strcmp( name, rec.c.c_name ) == 0 ) {
					/* Region is #j.		*/
					sprintf( regBufPtr, "%4d", j+delreg );
d271 1
d273 2
a274 2
			}
			if( j > nnr ) {   /* region not in desc yet */
d276 3
a278 2
				if( numrr > MAXRR ) {
					fprintf( stderr,
d280 2
a281 1
						MAXRR );
d283 1
a283 1
				}
d290 1
a290 1
				for( i = 0; i < 16; i++ )
d294 1
a294 2
			}

d296 2
a297 1
			if( isave < 0 ) { int	n;
d303 3
a306 3
			lseek( objfd, savepos, 0);
			return;
		}
d310 2
a311 2
		if( rec.c.c_flags == 'R') {
			/* Record is region but not member of a region.	*/
d314 3
a316 4

			/* dummy region */
			if( nparts == 0 )	regflag = 0;

d318 1
a318 2
			strncpy( buff, rec.c.c_name, 16 );

d320 1
a320 1
			sprintf( regBufPtr, "%5d ", nnr+delreg );
a321 1

d323 2
a324 1
			if( nparts == 0 ) { int	n;
d329 1
a329 1
			}
d332 2
a333 3
			lseek( rrfd, 0L, 2 );
			write( rrfd, rec.c.c_name, 16 );

d336 9
a344 8
			if( nparts > 1 ) {
				/* First OR doesn't count, throw away
					first member.
				 */
				readF( objfd, &rec, sizeof rec );
				for( i = 2; i <= nparts; i++ ) {
					readF( objfd, &rec, sizeof rec );
					if( rec.M.m_relation == UNION ) {
d347 1
d349 2
a351 4
				lseek( objfd, dp->d_addr, 0 );
				readF( objfd, &rec, sizeof rec );
			}

d358 2
a359 2
			write(	ridfd,		buf,	  25 );
			blank_fill( ridfd,		  5 );
d362 3
a364 2
			for( j = 0; j < pathpos; j++ ) {
				strncpy(	bp,
d367 1
a367 1
				);
d370 2
a371 1
			}
d373 2
a374 1
			if( length > 50 ) {
d377 13
a389 11
				write(	ridfd,
					bp,
					50 - strlen( rec.c.c_name )
				);
			} else	write( ridfd, buf, bp - buf );
			write(	ridfd,
				rec.c.c_name,
				strlen( rec.c.c_name )
			);
			write( ridfd, LF, 1 );
			printf( "\nREGION %4d    ", nnr+delreg );
d391 3
a393 3
				printf( "/%s", path[j]->d_namep );
			prompt( "/%s", rec.c.c_name );
		}
d395 5
a399 3
		for( i = 1; i <= nparts; i++ )  {
			if( ++isave == nparts )	isave = -isave;
			readF( objfd, &rec, sizeof rec );
d404 4
a407 4
 
			path[pathpos] = dp;
			if(	(nextdp =
				lookup( mp->m_instname, NOISY )) == DIR_NULL )
d409 2
a410 1
			if( mp->m_brname[0] != 0 )  {
d416 2
a417 2
				if(	(tdp =
					lookup( mp->m_brname, QUIET ))
d421 5
a425 4
					nextdp = tdp;
				else	nextdp = diradd(mp->m_brname,
							nextdp->d_addr );
			}
d428 5
a432 3
			/* Recursive call
			 */
			cgobj( nextdp, pathpos+1, new_xlate );
a433 3
		lseek( objfd, savepos, 0 );
		return;
	}
d436 6
a441 5
	if( rec.u_id != ID_SOLID && rec.u_id != ID_ARS_A ) {
		fprintf( stderr,
			"Bad input: should have a 'S' or 'A' record, " );
		fprintf( stderr,
			"but have '%c'.\n", rec.u_id );
d443 1
a443 1
	}
d446 1
a446 1
	
d456 1
a456 1
		lseek( objfd, savepos, 0 );
d462 2
a463 2
	strncpy( d_ident.i_name, rec.s.s_name, 16 );
	strncpy(     ars_name, rec.s.s_name, 16 );
d467 4
a470 2
	for( i = 0; i < 16; i++ ) {
		if( rec.s.s_name[i] == 0 )	break;
d472 1
a472 1
	}
d476 6
a481 5
	for( i = 0; i < nns; i++ ) {
		if( dchar == discr[i] ) {
			/* Quick look match - check further.		*/
			lseek( rd_idfd, ((long)i) * sizeof d_ident, 0);
			readF( rd_idfd, &idbuf, sizeof d_ident );
d483 2
a484 1
			if( check( &d_ident, &idbuf ) == 1 ) {
d488 1
a488 1
			}
d492 1
a493 1
	}
d500 6
a505 4
	if( nns > MAXSOL ) {
		fprintf( stderr,
			"\nNumber of solids (%d) greater than max (%d).\n",
			nns, MAXSOL );
d507 1
a507 1
	}
d510 2
a511 2
	lseek( idfd, 0L, 2 );
	write( idfd, &d_ident, sizeof d_ident );
d523 1
a523 1
	write( solfd, buf, 5 );
d526 2
a527 1
	switch( rec.s.s_type ) {
d544 3
a546 2
		fprintf( stderr,
			"Solid type (%d) unknown.\n", rec.s.s_type );
d548 1
a548 1
	}
d553 2
a554 1
	if( regflag == 1 ) {
d559 3
a561 1
		    ||	(isave % 9 == -1 && isave < -1) ) { int	n;
d567 1
a567 1
		}
d570 5
a574 3
		if( orflag == 1 ) {
			if( operate == UNION || isave == 1 ) {
				sprintf( regBufPtr, "or" );
d576 2
a577 1
			} else
d579 4
a582 2
		} else		putSpaces( regBufPtr, 2 );
		sprintf( regBufPtr, "%5d", nnt );
d586 2
a587 1
		if( isave < 0 ) {  int	n; /* end this region */
d593 1
d595 3
a597 1
	} else if( old_xlate[15] > EPSILON ) {
d602 1
a602 1
		sprintf( regBufPtr, "%5d%8d", nnr+delreg, nnt+delsol );
d605 1
a605 1
		sprintf( regBufPtr, rec.s.s_name );
d608 1
a608 1
		write( ridfd, buf, 5 );
d618 1
a618 1
		printf( "\nREGION %4d    ", nnr+delreg );
d621 3
a623 2
		for( i = 0; i < pathpos; i++ ) {
			strncpy(	bp,
d626 1
a626 1
			);
d629 1
a629 1
		}
d631 2
a632 1
		if( length > 50 ) {
d635 7
a641 5
			write(	ridfd,
				bp,
				50 - strlen( rec.s.s_name )
			);
		} else	write( ridfd, buf, bp - buf );
d643 21
a663 9
		if( rec.u_id == ID_ARS_B ) { /* Ars extension record.	*/
			prompt( "/%s", ars_name );
			write( ridfd, ars_name, strlen( ars_name ) );
		} else	{
			prompt( "/%s", rec.s.s_name );
			write(	ridfd,
				rec.s.s_name,
				strlen( rec.s.s_name )
			);
a664 5
		write( ridfd, LF, 1 );
		{ int	n;
			n = 69 - (regBufPtr - regBuffer);
			putSpaces( regBufPtr, n );
			endRegion( "" );
d666 4
a670 4
	if( isave < 0 )	regflag = 0;
	lseek( objfd, savepos, 0 );
	return;
}
d1037 2
a1038 3
	/* write ars header line in solid table
	 */
	write( solfd, "ars  ", 5 );
d1040 1
a1040 1
	write( solfd, buf, 10 );
d1042 1
a1042 1
	write( solfd, buf, 10 );
d1044 2
a1045 2
	write( solfd, rec->a.a_name, strlen( rec->a.a_name ) );
	write( solfd, LF, 1 );
d1047 13
a1059 15
	/* process the data one granule at a time
	 */
	for( granule = 1; granule <= totlen; granule++ ) {
		/* read a granule (ars extension record 'B')
		 */
		readF( objfd, rec, sizeof record );

		/* find number of points in this granule
		 */
		if( rec->b.b_ngranule == ngrans && (npt = npts % 8) != 0 );
		else				  npt = 8;

		/* operate on vertex
		 */
		if( granule == 1 ) {
d1065 3
a1067 1
		} else	vec = 0;
d1069 3
a1071 3
		/* rest of vectors
		 */
		for( i = vec; i < npt; i++, vec++ ) {
d1076 1
a1076 1
		}
d1078 1
a1078 2
		/* print the solid parameters
		 */
d1080 2
a1082 2
	return;
}
d1087 5
a1091 9
psp(	npts,  rec )
register
int	npts;
register
Record *rec;
{
	register int	i, j, k, jk;
	char		buf[60];

d1093 4
a1096 3
	for( i = 0; i < npts*3; i += 3 )  {
		/* Write 3 points.					*/
		for( k = i; k <= i+2; k++ ) {
d1100 1
a1100 1
		}
d1102 3
a1104 4
		if( (++j & 01) == 0 ) {
			/* end of line
			 */
			write( solfd, buf, 60 );
d1106 7
a1112 6
			write(	solfd,
				rec->s.s_name,
				strlen( rec->s.s_name )
			);
			write( solfd, LF, 1 );
			if( i != (npts-1)*3 ) {   /* new line */
d1114 1
a1114 1
				write( solfd, buf, 5 );
d1116 1
d1118 11
d1130 1
a1130 6
	}	
	if( (j & 01) == 1 ) {   /* finish off rest of line */
		for( k = 30; k <= 60; k++ )	buf[k] = ' ';
		write( solfd, buf, 60 );
		write( solfd, rec->s.s_name, strlen( rec->s.s_name ) );
		write( solfd, LF, 1 );
a1131 2
	return;
}
d1295 14
a1308 10
/*	p r o m p t ( )
	Flush stdout after the printf.
 */
#ifndef prompt
prompt( a0, a1, a2, a3, a4, a5, a6, a7, a8, a9 )
{
	printf( a0, a1, a2, a3, a4, a5, a6, a7, a8, a9 );
	fflush( stdout );
}
#endif
d1313 14
a1326 10
readF(	fd, buf, bytes )
int	fd,	 bytes;
char	   *buf;
{ register int	bytesRead;
	if( (bytesRead = read( fd, buf, bytes )) != bytes ) {
		;
#ifdef debug
	fprintf( stderr, "Read failed! Only %d bytes read.\n",
				bytesRead );
#endif
d1328 24
a1351 2
	return( bytesRead );
}
@


2.10
log
@Fixed unit_conversion in TEC case.
@
text
@d2 3
a4 3
	SCCS id:	@@(#) vdeck.c	2.10
	Last edit: 	3/25/85 at 11:13:27
	Retrieved: 	8/13/86 at 08:13:14
d14 1
a14 1
char	sccsTag[] = "@@(#) vdeck.c	2.10	last edit 3/25/85 at 11:13:27";
d193 4
a196 4
	/* Limit tree hierarchy to 8 levels.				*/
	if( pathpos >= 8 ) {
		fprintf( stderr, "Nesting exceeds 8 levels\n" );
		for( i = 0; i < 8; i++ )
@


2.9
log
@Loosened up epsilon value in discriminating between solid types 
in vproc.c and cgarbs.c .
@
text
@d2 3
a4 3
	SCCS id:	@@(#) vdeck.c	2.9
	Last edit: 	3/18/85 at 14:25:28
	Retrieved: 	8/13/86 at 08:12:49
d14 1
a14 1
char	sccsTag[] = "@@(#) vdeck.c	2.9	last edit 3/18/85 at 14:25:28";
d935 5
a939 1
		work[0] = ma / mc;
@


2.8
log
@Added support for new database format, ident and free records,
 and unit conversions.  Now puts title and units on first card.  Title 
version number and units are printed out when building the directory.
@
text
@d2 3
a4 3
	SCCS id:	@@(#) vdeck.c	2.8
	Last edit: 	1/31/85 at 14:59:28
	Retrieved: 	8/13/86 at 08:12:21
d14 1
a14 1
char	sccsTag[] = "@@(#) vdeck.c	2.8	last edit 1/31/85 at 14:59:28";
a56 1

d422 2
a423 1
	if( old_xlate[15] < .0001 ) { /* Do not add solid.		*/
d426 1
a426 1
	}
d545 1
a545 1
	} else if( old_xlate[15] > 0.0001 ) {
d779 1
a779 1
	if( fabs( MAGNITUDE(SV1) - MAGNITUDE(SV2) ) < .0001 ) {
d783 1
a783 1
		if(fabs(MAGNITUDE(SV2) - MAGNITUDE(SV3)) < .0001)
d794 1
a794 1
	if(fabs(MAGNITUDE(SV1) - MAGNITUDE(SV3)) < .0001) {
d804 1
a804 1
	if(fabs(MAGNITUDE(SV2) - MAGNITUDE(SV3)) < .0001) 
d886 4
a889 3
	if(	fabs( (mb/md)-(ma/mc) ) < .0001
	    &&  fabs( fabs(DOT(axb,cxd)) - (maxb*mcxd) ) < .0001
	)	rec->s.s_cgtype = TEC;
d893 13
a905 7
	if( fabs( fabs(DOT(SV1,axb)) - (mh*maxb) ) < .0001 ) {
		if( fabs( ma-mb ) < .0001 ) {
			if( fabs( ma-mc ) < .0001 )	rec->s.s_cgtype = RCC;
			else				rec->s.s_cgtype = TRC;
		} else    /* elliptical */
		if( fabs( ma-mc ) < .0001 )		rec->s.s_cgtype = REC;
	}
@


2.7
log
@Fixed rg[op] line formating, associated with using the strlen() 
function on non-terminated regBuffer[].  Added trap for groups within regions.
@
text
@d2 10
a11 10
 *	SCCS id:	@@(#) vdeck.c	2.7
 *	Last edit: 	12/11/84 at 14:20:06
 *	Retrieved: 	8/13/86 at 08:11:57
 *	SCCS archive:	/m/cad/vdeck/RCS/s.vdeck.c
 *
 *	Author:		Gary S. Moss
 *			U. S. Army Ballistic Research Laboratory
 *			Aberdeen Proving Ground
 *			Maryland 21005
 *			(301)278-6647 or AV-283-6647
d14 1
a14 1
char	sccsTag[] = "@@(#) vdeck.c	2.7	last edit 12/11/84 at 14:20:06";
d17 35
a51 35
 *	Derived from KARDS, written by Keith Applin.
 *
 *	Generate a COM-GEOM card images suitable for input to gift5
 *	(also gift(1V)) from a vged(1V) target description.
 *
 *      There are 3 files generated at a time, the Solid table, Region table,
 *      and Ident table, which when concatenated in that order, make a
 *	COM-GEOM deck.  The record formats in the order that they appear, are
 *	described below, and are strictly column oriented.
 *
 *      Note that the Solid table begins with a Title and a Control card, the
 *	rest of the record types appear once for each object, that is, one
 *	Solid record for each Solid, one Region and one
 *      Ident record for each Region as totaled on the Control card, however,
 *      the Solid and Region records may span more than 1 card.
 *
 * ---------------------------------------------------------------------------
 * File|Record  :             Contents              :       Format           |
 * ----|---------------------------------------------------------------------|
 *  1  |Title   : target_units, title               : a2,3x,a60              |
 *     |Control : #_of_solids, #_of_regions         : i5,i5                  |
 *     |Solid   : sol_#,sol_type,params.,comment    : i5,a5,6f10.0,a10       |
 *     | cont'  : sol_#,parameters,comment          : i5,5x,6f10.0,a10       |
 * ----|---------------------------------------------------------------------|
 *  2  |Region  : reg_#,(op,[sol/reg]_#)*,comment   : i5,1x,9(a2,i5),1x,a10  |
 *     | cont'  : reg_#,(op,[sol/reg]_#)*,comment   : i5,1x,9(a2,i5),1x,a10  |
 * ----|---------------------------------------------------------------------|
 *  3  |Flag    : a -1 marks end of region table    : i5                     |
 *     |Idents  : reg_#,ident,space,mat,%,descriptn : 5i5,5x,a40             |
 * --------------------------------------------------------------------------|
 *
 *	To compile,
 *	               $ make 
 *		   or  $ make install clobber
 *
d72 1
a72 1
/*	==== m a i n ( )
d86 1
a86 2
	/* C o m m a n d   I n t e r p r e t e r
	 */
d91 2
a92 2
		 * allows exit from program only while command interpreter
		 * is waiting for input from keyboard.
d155 1
a155 1
			sort( toc_list, toc_ct );
d172 2
a173 2
/*	==== c g o b j ( )
 *	Build deck for object pointed to by 'dp'.
d206 1
a206 1
	if( rec.u_id == COMB )  { /* We have a group.			*/
d229 1
a229 2
			/* check for end of line in region table
			 */
d240 1
a240 2
			/* check if this region is in desc yet
			 */
d260 1
a260 2
				/* add to list of regions to look up later
				 */
d271 1
a271 2
			/* check for end of this region
			 */
d286 1
a286 2
			/* record is a region but not member of a region
			 */
d290 1
a290 2
			/* dummy region
			 */
d293 1
a293 2
			/* save the region name
			 */
d296 1
a296 2
			/* start new region
			 */
d300 1
a300 2
			/* check for dummy region
			 */
d308 1
a308 2
			/* add region to list of regions in desc
			 */
d312 1
a312 2
			/* check for any OR
			 */
d315 2
a316 2
				/* first OR doesn't count, throw away
				 * first member
d330 1
a330 2
			/* write region ident table
			 */
d373 1
a373 2
			/* save this operation
			 */
d381 4
a384 4
				/* Create an alias.
				 * First step towards full branch naming.
				 * User is responsible for his branch names
				 * being unique.
d390 1
a390 2
					/* use existing alias
					 */
d405 2
a406 3
	/* N O T  a  C O M B I N A T I O N  record
	 */
	if( rec.u_id != SOLID && rec.u_id != ARS_A ) {
d414 10
a423 10
	/* now have proceeded down branch to a solid
	 *
	 * if regflag = 1  add this solid to present region
         * if regflag = 0  solid not defined as part of a region
	 *		   make new region if scale != 0 
	 *
	 * if orflag = 1   this region has or's
	 * if orflag = 0   none
	 */
	if( old_xlate[15] < .0001 ) {     /* do not add solid */
d428 3
a430 4
	/* fill ident struct
	 */
	mat_copy( ident.i_mat, old_xlate );
	strncpy( ident.i_name, rec.s.s_name, 16 );
d433 1
a433 2
	/* calculate first look discriminator for this solid
	 */
d440 1
a440 2
	/* quick check if solid already in solid table
	 */
d444 6
a449 8
			/* quick look match - check further
			 */
			lseek( rd_idfd, ((long)i) * sizeof ident, 0);
			readF( rd_idfd, &idbuf, sizeof ident );
			ident.i_index = i + 1;
			if( check( &ident, &idbuf ) == 1 ) {
				/*really is an old solid
				 */
d453 3
a455 2
			/* false alarm - keep looking for
			 * quick look matches */
d459 1
a459 2
	/* new solid
	 */
d462 1
a462 1
	ident.i_index = nns;
d471 1
a471 2
	/* write ident struct at end of idfd file
	 */
d473 1
a473 1
	write( idfd, &ident, sizeof ident );
d476 1
a476 2
	/* process this solid
	 */
d480 1
a480 2
	/* notrans = homogeneous matrix with a zero translation vector
	 */
d510 3
a512 6
notnew:	/* sent here if solid already in solid table
	 */
	/* finished with solid
	 */
	/* put solid in present region if regflag == 1
	 */
d514 3
a516 2
		/* isave = number of this solid in this region
		 * if negative then is the last solid in this region */
d546 2
a547 2
		/* solid not part of a region
		 * make solid into region if scale > 0
d559 1
a559 1
		 * meaningless at this point.
d587 1
a587 2
		if( rec.u_id == ARS_B ) {	/* ars extension record
						 */
d609 2
a610 2
/*	==== p s p ( )
 *	Print solid parameters  -  npts points or vectors.
a611 46
psp(	npts,  rec )
register
int	npts;
register
Record *rec;
{
	register int	i, j, k, jk;
	char		buf[60];

	j = jk = 0;
	for( i = 0; i < npts*3; i += 3 )  {
		/* Write 3 points.					*/
		for( k = i; k <= i+2; k++ ) {
			ftoascii( rec->s.s_values[k], &buf[jk*10], 10, 4 );
			++jk;
		}

		if( (++j & 01) == 0 ) {
			/* end of line
			 */
			write( solfd, buf, 60 );
			jk = 0;
			write(	solfd,
				rec->s.s_name,
				strlen( rec->s.s_name )
			);
			write( solfd, LF, 1 );
			if( i != (npts-1)*3 ) {   /* new line */
				itoa( nns+delsol, buf, 5 );
				write( solfd, buf, 5 );
				blank_fill( solfd, 5 );
			}
		}
	}	
	if( (j & 01) == 1 ) {   /* finish off rest of line */
		for( k = 30; k <= 60; k++ )	buf[k] = ' ';
		write( solfd, buf, 60 );
		write( solfd, rec->s.s_name, strlen( rec->s.s_name ) );
		write( solfd, LF, 1 );
	}
	return;
}

/*	==== a d d t o r ( )
 *	Process torus.
 */
d650 2
a651 2
/*	==== a d d a r b ( )
 *	Process generalized arb.
d752 2
a753 2
/*	==== a d d e l l ( )
 *	Process the general ellipsoid.
d839 2
a840 2
/*	==== a d d t g c ( )
 *	Process generalized truncated cone.
d945 2
a946 2
/*	==== a d d a r s ( )
 *	Process triangular surfaced polyhedron - ars.
d1012 2
a1013 2
/*	==== p a r s p ( )
 *	Print npts points of an ars.
d1015 47
d1084 1
d1108 2
a1109 2
/*	==== m a t _ z e r o ( )
 *	Fill in the matrix "m" with zeros.
d1121 1
a1121 1
 *	Fill in the matrix "m" with an identity matrix.
d1130 2
a1131 2
/*	==== m a t _ c o p y ( )
 *	Copy the matrix "im" into the matrix "om".
d1143 4
a1146 4
/*	==== m a t _ m u l ( )
 *	Multiply matrix "im1" by "im2" and store the result in "om".
 *	NOTE:  This is different from multiplying "im2" by "im1" (most
 *	of the time!)
d1168 3
a1170 3
/*	==== m a t X v e c ( )
 *	Multiply the vector "iv" by the matrix "im" and store the result
 *	in the vector "ov".
d1191 1
a1191 1
/*	==== v t o h _ m o v e ( )
d1202 1
a1202 1
/*	==== h t o v _ m o v e ( )
d1221 2
a1222 2
/*	==== p r o m p t ( )
 *	Flush stdout after the printf.
d1232 2
a1233 2
/*	==== r e a d F ( )
 *	Read with error checking and debugging.
@


2.6
log
@Fixed addtor() was missing vtoh and htovmoves.
@
text
@d2 3
a4 3
 *	SCCS id:	@@(#) vdeck.c	2.6
 *	Last edit: 	11/29/84 at 12:32:28
 *	Retrieved: 	8/13/86 at 08:11:32
d14 1
a14 1
char	sccsTag[] = "@@(#) vdeck.c	2.6	last edit 11/29/84 at 12:32:28";
d68 2
a69 2
#define putSpaces( s, n ) {	register int i;\
				for( i = 0; i < (n); i++ ) *s++ = ' ';\
d211 9
d280 1
a280 1
				n = 69 - strlen( regBuffer );
d312 1
a312 1
				n = 69 - strlen( regBuffer );
a415 11
#ifdef NEVER_FOO
		/* check for end of this region
		 */
		if( isave < 0 ) { int	n;
			isave = -isave;
			regflag = 0;
			n = 69 - strlen( regBuffer );
			putSpaces( regBufPtr, n );
			endRegion( buff );
		}
#endif NEVER_FOO
d546 1
a546 1
		    	n = 69 - strlen( regBuffer );
d567 1
a567 1
			n = 69 - strlen( regBuffer );
d626 1
a626 1
			n = 69 - strlen( regBuffer );
@


2.5
log
@Switched matrix transform multiplication to be old transformation 
on the left and current transformation on the right.
@
text
@d2 3
a4 3
 *	SCCS id:	@@(#) vdeck.c	2.5
 *	Last edit: 	10/16/84 at 14:25:42
 *	Retrieved: 	8/13/86 at 08:11:03
d14 1
a14 1
char	sccsTag[] = "@@(#) vdeck.c	2.5	last edit 10/16/84 at 14:25:42";
d694 1
a694 1
	vect_t	v_work;
d700 3
a702 1
	matXvec( v_work, xform, &(rec->s.s_values[0]) );
d708 3
a710 2
		matXvec( v_work, notrans, &(rec->s.s_values[i]) );
		VMOVE( &(rec->s.s_values[i]), v_work );
@


2.4
log
@Removed block of text #ifdef NEVER_FOO which checked for end 
of region in the group part.
@
text
@d2 3
a4 3
 *	SCCS id:	@@(#) vdeck.c	2.4
 *	Last edit: 	9/17/84 at 07:56:50
 *	Retrieved: 	8/13/86 at 08:10:37
d14 1
a14 1
char	sccsTag[] = "@@(#) vdeck.c	2.4	last edit 9/17/84 at 07:56:50";
d401 1
a401 1
			mat_mul( new_xlate, mp->m_mat, old_xlate );
@


2.3
log
@Fixed bug in rg+- flags.
@
text
@d2 3
a4 3
 *	SCCS id:	@@(#) vdeck.c	2.3
 *	Last edit: 	7/11/84 at 15:38:55
 *	Retrieved: 	8/13/86 at 08:10:10
d14 1
a14 1
char	sccsTag[] = "@@(#) vdeck.c	2.3	last edit 7/11/84 at 15:38:55";
d407 1
d417 1
@


2.2
log
@Fixed gift5 format.
@
text
@d2 3
a4 3
 *	SCCS id:	@@(#) vdeck.c	2.2
 *	Last edit: 	6/20/84 at 12:22:26
 *	Retrieved: 	8/13/86 at 08:09:39
d14 1
a14 1
char	sccsTag[] = "@@(#) vdeck.c	2.2	last edit 6/20/84 at 12:22:26";
d186 1
a186 1
	long	savepos;
d231 1
d258 2
a259 1
								1 );
@


2.1
log
@Just bumped version number to 2.1, no changes.
@
text
@d2 3
a4 3
 *	SCCS id:	@@(#) vdeck.c	2.1
 *	Last edit: 	6/1/84 at 14:04:56
 *	Retrieved: 	8/13/86 at 08:09:17
d14 1
a14 1
char	sccsTag[] = "@@(#) vdeck.c	2.1	last edit 6/1/84 at 14:04:56";
d38 2
a39 2
 *     |Solid   : sol_#,sol_type,params.,comment    : a5,a3,a2,6f10.0,a10    |
 *     | cont'  : sol_#,parameters,comment          : a5,5x,   6f10.0,a10    |
d41 2
a42 2
 *  2  |Region  : reg_#,(op,reg_#),comment          : i5,1x,9(a2,i5),1x,a10  |
 *     | cont'  : reg_#,(op,reg_#),comment          : i5,1x,9(a2,i5),1x,a10  |
d44 2
a45 1
 *  3  |Idents  : number,item,space,mat,            : 5i5,5x,a40             |
d580 9
a588 5
		itoa( item, &buf[5], 5 );
		itoa( space, &buf[10], 5 );
		itoa( 1, &buf[15], 5 );
		itoa( 100, &buf[20], 5 );
		write( ridfd, buf, 25 );
@


1.15
log
@Upgraded to gift5 (gift(1V)) input specs.
@
text
@d2 3
a4 3
 *	SCCS id:	@@(#) vdeck.c	1.15
 *	Last edit: 	6/1/84 at 14:00:14
 *	Retrieved: 	8/13/86 at 08:08:48
d14 1
a14 1
char	sccsTag[] = "@@(#) vdeck.c	1.15	last edit 6/1/84 at 14:00:14";
@


1.14
log
@Addtgc() check for divide by Zero.
@
text
@d2 3
a4 3
 *	SCCS id:	@@(#) vdeck.c	1.14
 *	Last edit: 	1/12/84 at 10:18:04
 *	Retrieved: 	8/13/86 at 08:08:21
d14 1
a14 1
char	sccsTag[] = "@@(#) vdeck.c	1.14	last edit 1/12/84 at 10:18:04";
d19 32
a50 1
 *	To compile	make all
d332 7
a338 5
			itoa(	nnr+delreg,	buf,	  10 );
			itoa(	rec.c.c_regionid,	&buf[10], 10 );
			itoa(	rec.c.c_aircode,	&buf[20], 10 );
			write(	ridfd,		buf,	  30 );
			blank_fill( ridfd,		  10 );
d350 2
a351 2
			if( length > 34 ) {
				bp = buf + (length - 34);
d355 1
a355 1
					34 - strlen( rec.c.c_name )
d505 2
a506 2
	itoa( nnt+delsol, buf, 3 );
	write( solfd, buf, 3 );
d578 7
a584 5
		itoa( nnr+delreg, buf,	  10 );
		itoa(	item,	&buf[10], 10 );
		itoa(	space,	&buf[20], 10 );
		write(	ridfd,	buf,	  30 );
		blank_fill( ridfd, 10 );
d597 2
a598 2
		if( length > 34 ) {
			bp = buf + (length - 34);
d602 1
a602 1
				34 - strlen( rec.s.s_name )
d660 3
a662 3
				itoa( nns+delsol, buf, 3 );
				write( solfd, buf, 3 );
				blank_fill( solfd, 7 );
d687 1
a687 1
	write( solfd, "tor    ", 7 );
d752 1
a752 1
		write( solfd, "arb8   ", 7 );
d756 1
a756 1
		write( solfd, "arb7   ", 7 );
d760 1
a760 1
		write( solfd, "arb6   ", 7 );
d765 1
a765 1
		write( solfd, "arb5   ", 7 );
d769 1
a769 1
		write( solfd, "arb4   ", 7 );
d774 1
a774 1
		write( solfd, "raw    ", 7 );
d782 1
a782 1
		write( solfd, "box    ", 7 );
d790 1
a790 1
		write( solfd, "rpp    ", 7 );
d877 1
a877 1
		write( solfd, "ellg   ", 7 );
d881 1
a881 1
		write( solfd, "ell1   ", 7 );
d888 1
a888 1
		write( solfd, "sph    ", 7 );
d967 1
a967 1
		write( solfd, "tgc    ", 7 );
d975 1
a975 1
		write( solfd, "rcc    ", 7 );
d982 1
a982 1
		write( solfd, "trc    ", 7 );
d990 1
a990 1
		write( solfd, "tec    ", 7 );
d997 1
a997 1
		write( solfd, "rec    ", 7 );
d1028 1
a1028 1
	write( solfd, "ars    ", 7 );
d1089 2
a1090 2
	itoa( nns+delsol, &bufout[0], 3 );
	for( i = 3; i < 10; i++ )	bufout[i] = ' ';
@


1.13
log
@Rather than merely reseting regflag after recursive call, 
must check for end of region first and if so, also finish off region table.
@
text
@d2 3
a4 3
 *	SCCS id:	@@(#) vdeck.c	1.13
 *	Last edit: 	11/29/83 at 11:23:43
 *	Retrieved: 	8/13/86 at 08:07:56
d14 1
a14 1
char	sccsTag[] = "@@(#) vdeck.c	1.13	last edit 11/29/83 at 11:23:43";
d906 8
d933 2
a934 2
		work[0] = MAGNITUDE( SV4 );
		work[1] = MAGNITUDE( SV5 );
d941 1
a941 1
		work[0] = MAGNITUDE( SV2 );
d948 2
a949 2
		work[0] = MAGNITUDE( SV2 );
		work[1] = MAGNITUDE( SV4 );
d956 1
a956 1
		work[0] = MAGNITUDE( SV2) / MAGNITUDE( SV4 );
@


1.12
log
@Fixed problem of regflag not being reset after recursive call 
of cgobj().
@
text
@d2 3
a4 3
 *	SCCS id:	@@(#) vdeck.c	1.12
 *	Last edit: 	11/29/83 at 10:41:36
 *	Retrieved: 	8/13/86 at 08:07:32
d14 1
a14 1
char	sccsTag[] = "@@(#) vdeck.c	1.12	last edit 11/29/83 at 10:41:36";
d186 1
a186 1
				exit( 10 );
d371 9
a380 1
		regflag = 0;
@


1.11
log
@Fixed alignment of region names in region table.
@
text
@d2 3
a4 3
 *	SCCS id:	@@(#) vdeck.c	1.11
 *	Last edit: 	11/16/83 at 14:32:59
 *	Retrieved: 	8/13/86 at 08:07:02
d14 1
a14 1
char	sccsTag[] = "@@(#) vdeck.c	1.11	last edit 11/16/83 at 14:32:59";
d372 1
@


1.10
log
@Solids over 999 use cvt compatible numbering scheme,
10 = 'A', 11 = 'B', ...
@
text
@d2 4
a5 2
 *	@@(#) vdeck.c			retrieved: 8/13/86 at 08:06:38,
 *	@@(#) version 1.10		last edit: 10/28/83 at 17:36:12.
d7 10
a16 8
 *	Written by Gary S. Moss.
 *	All rights reserved, Ballistic Research Laboratory.
 *
 *	Generates interactively, a COMGEOM deck of objects from "vged"
 *	file.
 *
 *	Written by	Gary S. Moss
 *
d31 4
d36 4
d67 1
d194 2
a195 3
				write( regfd, buff, strlen( buff ) );
				write( regfd, LF, 1 );
				blank_fill( regfd, 6 );
d197 2
a198 2
			buf[0] = 'r';	buf[1] = 'g';	buf[2] = operate;
			write( regfd, buf, 3 );
d207 2
a208 2
					itoa( j+delreg, buf, 4 );
					write( regfd, buf, 4 );
d229 1
a229 1
				blank_fill( regfd, 4 );
d234 1
a234 1
			if( isave < 0 ) {
d237 3
a239 4
				if( (j = isave % 9) > 0 )
					blank_fill( regfd, 7*(9-j) );
				write( regfd, buff, strlen( buff ) );
				write( regfd, LF, 1 );
d263 2
a264 3
			itoa( nnr+delreg, buf, 5 );
			write( regfd, buf, 5 );
			blank_fill( regfd, 1 );
d268 4
a271 2
			if( nparts == 0 ) {
				write( regfd, LF, 1 );
d499 1
a499 1
		    ||	(isave % 9 == -1 && isave < -1) ) {
d501 4
a504 3
			write( regfd, buff, strlen( buff ) );
			write( regfd, LF, 1 );
			blank_fill( regfd, 6 );
a505 1
		buf[0] = ' ';	buf[1] = ' ';
d510 7
a516 7
				buf[0] = 'o';
				buf[1] = 'r';
			}
		}
		write( regfd, buf, 2 );
		itoa( nnt, buf, 5 );
		write( regfd, buf, 5 );
d519 1
a519 1
		if( isave < 0 ) {   /* end this region */
d522 3
a524 4
			if( (j = isave % 9) > 0 )
				blank_fill( regfd, 7*(9-j) );
			write( regfd, buff, strlen( buff ) );
			write( regfd, LF, 1 );
d531 5
a535 5
		itoa(	nnr+delreg, buf,     5 );
		itoa(	nnt+delsol, &buf[5], 8 );
		write(	regfd,	    buf,    13 );
		blank_fill( regfd, 56 );
		write( regfd, rec.s.s_name, strlen( rec.s.s_name ) );
d574 5
a578 1
		write( regfd, LF, 1 );
@


1.9
log
@*** empty log message ***
@
text
@d2 2
a3 2
 *	@@(#) vdeck.c			retrieved: 8/13/86 at 08:06:17,
 *	@@(#) version 1.9		last edit: 10/11/83 at 10:57:24.
d194 1
a194 2
					/* region is #j
					 */
d450 1
a450 2
	/* write solid #
	 */
d454 1
a454 2
	/* process appropriate solid type
	 */
d488 1
a488 2
			/* new line
			 */
d584 1
a584 2
		/* write 3 points
		 */
@


1.8
log
@*** empty log message ***
@
text
@d2 2
a3 2
 *	@@(#) vdeck.c			retrieved: 8/13/86 at 08:05:57,
 *	@@(#) version 1.8		last edit: 10/11/83 at 09:31:19.
a19 3
#include "./ged_types.h"
#include "./3d.h"
#include "./vdeck.h"
d21 1
a31 1
	if( argc < 2 ) { menu( usage );	exit( 1 ); }
d34 1
a34 4
	/* open  G E D  data base object file
	 */
	if( (objfd = open( argv[1], 0 )) < 0 )  {
		perror( argv[1] );
d36 3
a38 2
		exit( 10 );
	} else	objfile = argv[1];
a40 6

	if( argc > 1 )
	{	/* Add objects from command line to current list.	*/
		pars_arg( argv, argc );
		insert( arg_list, arg_ct );
	}
@


1.7
log
@*** empty log message ***
@
text
@d2 2
a3 2
 *	@@(#) vdeck.c		retrieved 8/13/86 at 08:05:39,
 *	@@(#) version 1.7		  created 6/14/83 at 08:51:37.
d8 2
a9 2
 *	Generates interactively, a COMGEOM deck of objects from GED data
 *	base file.
d20 9
a28 4
#include "ged_types.h"
#include "3d.h"
#include "deck.h"
#include "deck_glob.h"
a29 29
char	*cmd[] = {
"",
"C O M M A N D                  D E S C R I P T I O N",
"",
"deck [output file prefix]      Produce COM GEOM card deck.",
"erase                          Erase current list of objects.",
"insert [object[s]]             Add an object to current list.",
"list [object[s]]               Display current list of selected objects.",
"number [solid] [region]        Specify starting numbers for objects.",
"quit                           Terminate run.",
"remove [object[s]]             Remove an object from current list.",
"sort                           Sort table of contents alphabetically.",
"toc [object[s]]                Table of contents of solids database.",
"! [shell command]              Execute a UNIX shell command.",
"",
"NOTE:",
"First letter of command is sufficient, and all arguments are optional.",
"Objects may be specified with string matching operators (*, [], -, ? or \\)",
"as in the UNIX shell.",
0 };

char	*usage[] = {
"",
"d e c k ====",
"Make COMGEOM decks of objects from a GED data base file",
"Usage:  deck {file}.g [{obj1} {obj2} ... {objn}]",
"",
0 };

d148 1
a148 1
	register struct members	*mp;
d347 1
a347 1
				lookup( mp->m_instname, NOISY )) == -1 )
d356 3
a358 2
					lookup( mp->m_brname, QUIET )) !=
					-1 )
d704 1
a704 1
	rec->s.s_num *= -1;
d707 1
a707 1
	switch( rec->s.s_num ) {
d766 1
a766 1
		fprintf( stderr, "Unknown arb (%d).\n", rec->s.s_num );
d801 1
a801 1
		rec->s.s_num = ELL1;
d804 2
a805 2
			rec->s.s_num = SPH;
		if(rec->s.s_num != SPH) {
d816 1
a816 1
		rec->s.s_num = ELL1;
d825 1
a825 1
		rec->s.s_num = ELL1;
d828 1
a828 1
		rec->s.s_num = GENELL;
d832 1
a832 1
	switch( rec->s.s_num ) {
d853 1
a853 1
			"Error in type of ellipse (%d).\n", rec->s.s_num );
d885 1
a885 1
	rec->s.s_num = TGC;
d900 1
a900 1
	)	rec->s.s_num = TEC;
d906 2
a907 2
			if( fabs( ma-mc ) < .0001 )	rec->s.s_num = RCC;
			else				rec->s.s_num = TRC;
d909 1
a909 1
		if( fabs( ma-mc ) < .0001 )		rec->s.s_num = REC;
d914 1
a914 1
	switch( rec->s.s_num ) {
d951 1
a951 1
			"Error in tgc type (%d).\n", rec->s.s_num );
@


1.6
log
@Added Sort command instead of sorting toc automatically.
@
text
@d2 2
a3 2
 *	@@(#) vdeck.c		retrieved 8/13/86 at 08:05:20,
 *	@@(#) version 1.6		  created 3/29/83 at 10:53:50.
d569 2
a570 1
		j = strlen( rec.s.s_name );
d572 1
a572 2
			if( j += strlen( path[i]->d_namep ) < 38 )
				write(	ridfd,
d574 4
a577 4
					strlen( path[i]->d_namep ) );
			write( ridfd, "/", 1 );
			printf( "/%s", path[i]->d_namep );
			j++;
d579 10
a588 1
		
@


1.5
log
@Fixed Addarb, Addell, and Addtgc.
@
text
@d2 2
a3 2
 *	@@(#) vdeck.c		retrieved 8/13/86 at 08:05:00,
 *	@@(#) version 1.5		  created 2/25/83 at 13:39:41.
d29 10
a38 9
"deck [output file prefix]      produce COM GEOM card deck",
"erase                          erase current list of objects",
"insert [object[s]]             add an object to current list",
"list [object[s]]               display current list of selected objects",
"number [solid] [region]        specify starting numbers for objects",
"quit                           terminate run",
"remove [object[s]]             remove an object from current list",
"toc [object[s]]                table of contents of solids database",
"! [shell command]              execute a UNIX shell command",
d145 3
d695 1
d697 1
a697 6
	if( rec->s.s_type == GENARB8 )	/*** KLUDGE ****/
		if( rec->s.s_num > 0 )	rec->s.s_num = ARB8;
		else			rec->s.s_num *= -1;

	/* operate on vertex
	 */
d702 1
a702 2
	/* rest of vectors
	 */
d708 1
a708 2
		/* point notation
		 */
d715 4
d720 1
a720 2
	/* print the solid parameters
	 */
@


1.4
log
@*** empty log message ***
@
text
@d2 2
a3 2
 *	@@(#) vdeck.c		retrieved 8/13/86 at 08:04:41,
 *	@@(#) version 1.4		  created 2/25/83 at 13:33:18.
d690 2
a691 1

@


1.3
log
@EOF on stdin causes program to terminate normally, fixed setjmp() header reference.
@
text
@d2 2
a3 2
 *	@@(#) vdeck.c		retrieved 8/13/86 at 08:04:19,
 *	@@(#) version 1.3		  created 2/24/83 at 13:07:51.
d760 13
a772 6
		work[0] = rec->s.s_values[18];	/* xmin */
		work[1] = rec->s.s_values[0];	/* xmax */
		work[2] = rec->s.s_values[1];	/* ymin */
		worc[0] = rec->s.s_values[19];	/* ymax */
		worc[1] = rec->s.s_values[2];	/* zmin */
		worc[2] = rec->s.s_values[20];	/* zmax */
d811 13
a823 1
	rec->s.s_num = GENELL;
d825 3
a827 3
	/* ell1 if mag B = mag C
	 */
	if( fabs( MAGNITUDE( SV2 ) - MAGNITUDE( SV3 ) ) < .0001 )
d829 5
a833 7
		
	/* sph if ell1 and mag A = mag B
	 */
	if(	rec->s.s_num == ELL1
	    &&	fabs( MAGNITUDE( SV1 ) - MAGNITUDE( SV2 ) ) < .0001
	)
		rec->s.s_num = SPH;
d835 7
d911 1
a911 1
	    &&	fabs( DOT( axb, cxd )) < .0001
d916 1
a916 1
	if( fabs( DOT( SV1, axb )) < .0001 ) {
@


1.2
log
@Removed terminal-independent stuff, added register variables and documentation.
@
text
@d2 2
a3 2
 *	@@(#) vdeck.c		retrieved 8/13/86 at 08:03:47,
 *	@@(#) version 1.2		  created 2/23/83 at 14:47:47.
d19 1
a66 1
	
d68 4
a71 5
	
	toc();	/* Traverse directory and build table of contents.	*/
	
	/* Add solids listed on command line to current list.		*/
	if( argc > 1 ) {
d147 1
d191 1
a191 1
	read( objfd, &rec, sizeof rec );
d223 1
a223 1
				read( rd_rrfd, name, 16 );
d307 1
a307 1
				read( objfd, &rec, sizeof rec );
d309 1
a309 1
					read( objfd, &rec, sizeof rec );
d316 1
a316 1
				read( objfd, &rec, sizeof rec );
d358 1
a358 1
			read( objfd, &rec, sizeof rec );
d440 1
a440 1
			read( rd_idfd, &idbuf, sizeof ident );
d854 1
a854 1
	int	i;
d979 1
a979 1
		read( objfd, rec, sizeof record );
d1176 1
d1181 18
@


1.1
log
@Initial revision
@
text
@d2 6
a7 1
 *	d e c k . c
a12 4
 *	All rights reserved:
 *				Ballistic Research Laboratory
 *				Aberdeen Proving Ground, Md.  21005
 *
a22 1
#include "tty.h"
d24 1
a24 1
static char	*cmd[] = {
d44 1
a44 1
static char	*usage[] = {
d46 1
a46 1
"D E C K ====",
d48 1
a48 1
"Usage:  deck file [{obj1} {obj2} ... {objn}]",
d52 1
a52 2
/*	==== M A I N ( )
 *	
d54 1
a54 3
main(	argc,	 argv )
int	argc;
char		*argv[];
d56 2
a57 1
	int	i;
a58 6
	/* no file name given
	 */
	if( argc < 2 ) { menu( usage );	exit( 10 ); }

	delsol = delreg = 0;		

d67 1
a67 3
	/* build directory from object file
	 */
	builddir();
d69 1
a69 3
	/* traverse directory and build table of contents
	 */
	toc();
d71 1
a71 6
	/* get terminal type for clearing screen
	 */
	if( (term = getenv( "TERM" )) )	printf( "TERM=%s\n", term );	

	/* add solids listed on command line to current list
	 */
d77 1
a77 1
	/* point of re-entry from aborted command
d79 2
a80 5
	setjmp( env );

	/* C O M M A N D   I N T E R P R E T E R
	 */
	printf( "%s", CMD_PROMPT );	
d82 1
a82 1
		/* return to default interrupt handler after every command,
d84 1
a84 1
		 * is waiting for input from keyboard
d97 1
a97 1
				printf( "enter object[s] to insert: " );
d103 1
d113 1
d116 1
a116 1
			printf( "%s", PROMPT );
d120 1
a120 1
				printf( "enter number of 1st solid: " );
d122 1
a122 1
				printf( "enter number of 1st region: " );
d130 1
a130 1
				printf( "enter object[s] to remove: " );
d136 1
a136 1
			printf( "%s", PROMPT );
d140 1
a140 1
				printf( "enter shell command: " );
a142 1
			new_screen( term );
d149 1
a149 1
			printf( "quitting...\n" );
d152 1
a152 1
			printf( "invalid command\n%s", PROMPT );
d155 1
a155 1
		printf( "%s", CMD_PROMPT );		
d159 2
a160 2
/*	==== C G O B J ( )
 *	build deck for object pointed to by 'dp'
d162 2
a163 1
cgobj( dp, pathpos, old_xlate )
d181 1
d183 4
a186 3
		printf( "nesting exceeds 8 levels\n" );
		for( i = 0; i < 8; i++ ) printf( "/%s", path[i]->d_namep );
		printf( "\n" );
d193 1
a193 3
	/* C O M B I N A T I O N  record
	 */
	if( rec.u_id == COMB )  {
d198 2
a199 1
				printf( "region: %s is member of ",
d201 2
a202 1
				printf( "region: %s with OR operation\n",
d235 2
a236 1
					printf( "more than %d regions\n",
d345 4
a348 1
			write( ridfd, rec.c.c_name, strlen( rec.c.c_name ) );
d353 1
a353 1
			printf( "/%s", rec.c.c_name );
d397 4
a400 2
		printf( "bad input: should have a 'S' or 'A' record " );
		printf( "but have '%c'\n", rec.u_id );
d460 2
a461 1
		printf("\n\nnumber of solids (%d) greater than max (%d)\n",
d505 2
a506 1
		printf( "cgobj: solid type (%d) unknown\n", rec.s.s_type );
d578 1
a578 1
			printf( "/%s", ars_name );
d581 5
a585 2
			printf( "/%s", rec.s.s_name );
			write( ridfd, rec.s.s_name, strlen( rec.s.s_name ) );
d595 2
a596 2
/*	==== P S P ( )
 *	print solid parameters  -  npts points or vectors
d599 1
d601 1
d604 2
a605 2
	int	i, j, k, jk;
	char	buf[60];
d621 4
a624 1
			write( solfd, rec->s.s_name, strlen( rec->s.s_name ) );
d642 2
a643 2
/*	==== A D D T O R ( )
 *	process torus
d646 1
d680 2
a681 2
/*	==== A D D A R B ( )
 *	process generalized arb
d684 1
d710 4
a713 1
		VADD2( &(rec->s.s_values[i]), &(rec->s.s_values[0]), v_workk );
d771 1
a771 1
		fprintf( stderr, "unknown arb (%d)\n", rec->s.s_num );
d777 2
a778 2
/*	==== A D D E L L ( )
 *	process the general ellipsoid
d781 1
d840 2
a841 2
		fprintf( stderr, "error in type of ellipse (%d)\n",
			rec->s.s_num );
d847 2
a848 2
/*	==== A D D T G C ( )
 *	process generalized truncated cone
d851 1
d938 2
a939 1
		fprintf( stderr, "error in tgc type (%d)\n", rec->s.s_num );
d945 2
a946 2
/*	==== A D D A R S ( )
 *	process triangular surfaced polyhedron - ars
d949 1
d1012 2
a1013 2
/*	==== P A R S P ( )
 *	print npts points of an ars
d1016 1
d1018 1
d1021 2
a1022 2
	int	i, j, k, jk;
	char	bufout[80];
d1060 1
a1060 1
/*	==== M A T _ Z E R O ( )
d1072 1
a1072 1
/*	M A T _ I D N ( )
d1082 1
a1082 1
/*	==== M A T _ C O P Y ( )
d1088 1
a1088 1
	register int i = 0;
d1090 2
a1091 2
	/* Copy all elements */
	for( ; i< 16; i++ )	*om++ = *im++;
d1095 1
a1095 1
/*	==== M A T _ M U L ( )
d1103 3
a1105 4
	register int em1;		/* Element subscript for im1 */
	register int em2;		/* Element subscript for im2 */
	register int el = 0;		/* Element subscript for om */
	register int i;			/* For counting */
d1108 4
a1111 6
	for( ; el < 16; el++ ) {

		om[el] = 0;		/* Start with zero in output */
		em1 = (el / 4) * 4;	/* Element at rt of row in im1 */
		em2 = el % 4;		/* Element at top of col in im2 */

d1114 2
a1115 3

			em1++;		/* Next row element in m1 */
			em2 += 4;	/* Next column element in m2 */
d1120 1
a1120 2

/*	==== M A T   X   V E C ( )
d1129 3
a1131 3
	register int io;		/* Position in output vector */
	register int im = 0;		/* Position in input matrix */
	register int iv;		/* Position in input vector */
d1143 1
a1143 2
/*	==== V T O H _ M O V E ( )
 *
d1154 1
a1154 2
/*	==== H T O V _ M O V E ( )
 *
d1158 1
a1158 2
{
	static float inv;
d1164 1
a1164 2
	}
	else {
d1171 9
@
