head	11.6;
access;
symbols
	ansi-20040405-merged:11.3.4.1
	postmerge-20040405-ansi:11.4
	premerge-20040404-ansi:11.4
	postmerge-autoconf:11.4
	autoconf-freeze:11.3.12.2
	premerge-autoconf:11.4
	postmerge-20040315-windows:11.4
	premerge-20040315-windows:11.4
	windows-20040315-freeze:11.3.6.4
	autoconf-20031203:11.3
	autoconf-20031202:11.3
	autoconf-branch:11.3.0.12
	phong-branch:11.3.0.10
	photonmap-branch:11.3.0.8
	rel-6-1-DP:11.3
	windows-branch:11.3.0.6
	rel-6-0-2:11.3
	ansi-branch:11.3.0.4
	rel-6-0-1-branch:11.3.0.2
	hartley-6-0-post:11.3
	hartley-6-0-pre:11.3
	rel-6-0-1:11.3
	rel-6-0:11.3
	rel-5-4:11.1
	offsite-5-3-pre:11.2
	rel-5-3:11.1
	rel-5-2:11.1
	rel-5-1-branch:11.1.0.2
	rel-5-1:11.1
	rel-5-0:11.1
	rel-5-0-beta:11.1
	rel-4-5:11.1
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:5.1
	rel-1-24:5.1
	rel-1-20:4.2
	rel-1-10:4.1;
locks; strict;
comment	@ * @;


11.6
date	2004.05.21.13.49.17;	author morrison;	state dead;
branches;
next	11.5;

11.5
date	2004.05.10.15.30.51;	author erikg;	state Exp;
branches;
next	11.4;

11.4
date	2004.02.02.17.39.52;	author morrison;	state Exp;
branches;
next	11.3;

11.3
date	2001.04.20.22.31.29;	author morrison;	state Exp;
branches
	11.3.4.1
	11.3.6.1
	11.3.12.1;
next	11.2;

11.2
date	2000.08.24.22.56.19;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.18.35;	author mike;	state Rel4_4;
branches;
next	10.2;

10.2
date	94.08.23.14.51.12;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.50.30;	author mike;	state Rel4_0;
branches;
next	9.3;

9.3
date	91.06.01.20.34.35;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	91.06.01.18.33.40;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.14.05;	author mike;	state Rel3_5;
branches;
next	8.1;

8.1
date	88.10.05.00.52.58;	author mike;	state Rel3_0;
branches;
next	7.1;

7.1
date	87.11.03.00.27.58;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.08.16.54;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.48.47;	author mike;	state Rel;
branches;
next	4.2;

4.2
date	87.02.13.00.55.04;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.02.53.03;	author mike;	state Rel1;
branches;
next	2.5;

2.5
date	86.08.13.08.00.54;	author mike;	state Exp;
branches;
next	2.4;

2.4
date	86.08.13.08.00.41;	author mike;	state Exp;
branches;
next	2.3;

2.3
date	86.08.13.08.00.27;	author mike;	state Exp;
branches;
next	2.2;

2.2
date	86.08.13.08.00.15;	author mike;	state Exp;
branches;
next	2.1;

2.1
date	86.08.13.08.00.07;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	86.08.13.07.59.56;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	86.08.13.07.59.46;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	86.08.13.07.59.36;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	86.08.13.07.59.26;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	86.08.13.07.59.18;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	86.08.13.07.59.06;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	86.08.13.07.58.57;	author mike;	state Exp;
branches;
next	;

11.3.4.1
date	2004.03.17.21.23.38;	author morrison;	state Exp;
branches;
next	;

11.3.6.1
date	2004.03.11.23.52.42;	author morrison;	state Exp;
branches;
next	11.3.6.2;

11.3.6.2
date	2004.03.12.07.02.34;	author morrison;	state Exp;
branches;
next	11.3.6.3;

11.3.6.3
date	2004.03.12.07.03.37;	author morrison;	state Exp;
branches;
next	11.3.6.4;

11.3.6.4
date	2004.03.12.07.04.39;	author morrison;	state Exp;
branches;
next	;

11.3.12.1
date	2004.02.12.19.43.51;	author erikg;	state Exp;
branches;
next	11.3.12.2;

11.3.12.2
date	2004.03.15.14.08.22;	author erikg;	state Exp;
branches;
next	;


desc
@@


11.6
log
@moved to src/vdeck/
@
text
@/*
 *			C G A R B S . C
 *
 *  Routines to take a generalized ARB in 8-point form,
 *  determine which points are equivalent,
 *  decide which GIFT special-case solid fits this case,
 *  and convert the point list into GIFT format.
 *
 *  Author -
 *	Keith Applin
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1990-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/vdeck/cgarbs.c,v 11.5 2004/05/10 15:30:51 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "rtgeom.h"

#define YES	1
#define NO	0

/*
 *			C G A R B S
 *
 *  Determines COMGEOM arb type of a general arb.
 *
 *  Returns -
 *	> 0	number of unique points, and updated *cgtype
 *	  0	error
 */
int
cgarbs( cgtype, gp, uniq, svec, dist_tol )
int			*cgtype;
const struct rt_arb_internal	*gp;
int			uniq[8];	/* array of unique pt subscripts */
int			svec[11];	/* array of like pt subscripts */
const double		dist_tol;	/* distance tolerance */
{
	register int	i, j;
	int		numuniq, unique, done;
	int		si;

	done = NO;		/* done checking for like vectors */

	svec[0] = svec[1] = 0;
	si = 2;

	for(i=0; i<7; i++) {
		unique = YES;
		if(done == NO)
			svec[si] = i;
		for(j=i+1; j<8; j++) {
			if( VAPPROXEQUAL( gp->pt[i], gp->pt[j], dist_tol ) )  {
				if( done == NO ) svec[++si] = j;
				unique = NO;
			}
		}
		if( unique == NO ) {  	/* point i not unique */
			if( si > 2 && si < 6 ) {
				svec[0] = si - 1;
				if(si == 5 && svec[5] >= 6)
					done = YES;
				si = 6;
			}
			if( si > 6 ) {
				svec[1] = si - 5;
				done = YES;
			}
		}
	}
	if( si > 2 && si < 6 )
		svec[0] = si - 1;
	if( si > 6 )
		svec[1] = si - 5;
	for(i=1; i<=svec[1]; i++)
		svec[svec[0]+1+i] = svec[5+i];
	for(i=svec[0]+svec[1]+2; i<11; i++)
		svec[i] = -1;

	/* find the unique points */
	numuniq = 0;
	for(j=0; j<8; j++) {
		unique = YES;
		for(i=2; i<svec[0]+svec[1]+2; i++) {
			if( j == svec[i] ) {
				unique = NO;
				break;
			}
		}
		if( unique == YES )
			uniq[numuniq++] = j;
	}

	/* put comgeom solid typpe into s_cgtype */
	switch( numuniq ) {
	case 8:
		*cgtype = 8;  /* ARB8 */
		break;
	case 6:
		*cgtype = 7;	/* ARB7 */
		break;
	case 4:
		if(svec[0] == 2)
			*cgtype = 6;	/* ARB6 */
		else
			*cgtype = 5;	/* ARB5 */
		break;
	case 2:
		*cgtype = 4;	/* ARB4 */
		break;
	default:
		(void) fprintf( stderr,
		    "cgarbs: bad number of unique vectors (%d)\n",
		    numuniq );
		return(0);
	}
	return( numuniq );
}

/*
 *			A R B _ M V
 *
 *  Permute the points as directed.
 */
static void
arb_mv( pts, gp, p0, p1, p2, p3, p4, p5, p6, p7 )
register point_t	pts[8];
register const struct rt_arb_internal	*gp;
const int		p0, p1, p2, p3, p4, p5, p6, p7;
{	
	RT_ARB_CK_MAGIC(gp);
	VMOVE( pts[0], gp->pt[p0] );
	VMOVE( pts[1], gp->pt[p1] );
	VMOVE( pts[2], gp->pt[p2] );
	VMOVE( pts[3], gp->pt[p3] );
	VMOVE( pts[4], gp->pt[p4] );
	VMOVE( pts[5], gp->pt[p5] );
	VMOVE( pts[6], gp->pt[p6] );
	VMOVE( pts[7], gp->pt[p7] );
}

/*
 *			R E D O A R B
 *
 *  Rearranges arbs to be GIFT compatible
 *  The input in "gp" is not modified.
 *  The first "numvec" entires of "pts" are the GIFT format of arb "cgtype".
 *
 *  Returns -
 *	1	OK
 *	0	error
 */
int
redoarb( pts, gp, uniq, svec, numvec, cgtype )
point_t		pts[8];
const struct rt_arb_internal	*gp;
int		uniq[8];
int		svec[11];
const int	numvec;
const int	cgtype;
{
	register int	i, j;
	int		prod;

	/* For all the cases that don't require shuffling, duplicate first */
	for( i=0; i<8; i++ )  {
		VMOVE( pts[i], gp->pt[i] );
	}

	/* cgtype indicates which kind of ARB it is */
	switch( cgtype ) {
	case 8:
		break;

	case 7:
		/* arb7 vectors: 0 1 2 3 4 5 6 4 */
		switch( svec[2] ) {
		case 0:			/* 0 = 1, 3, or 4 */
			if(svec[3] == 1)	arb_mv(pts,gp,4,7,6,5,1,4,3,1);
			if(svec[3] == 3)	arb_mv(pts,gp,4,5,6,7,0,1,2,0);
			if(svec[3] == 4)	arb_mv(pts,gp,1,2,6,5,0,3,7,0);
			break;
		case 1:			/* 1 = 2 or 5 */
			if(svec[3] == 2)	arb_mv(pts,gp,0,4,7,3,1,5,6,1);
			if(svec[3] == 5)	arb_mv(pts,gp,0,3,7,4,1,2,6,1);
			break;
		case 2:			/* 2 = 3 or 6 */
			if(svec[3] == 3)	arb_mv(pts,gp,6,5,4,7,2,1,0,2);
			if(svec[3] == 6)	arb_mv(pts,gp,3,0,4,7,2,1,5,2);
			break;
		case 3:			/* 3 = 7 */
			arb_mv(pts,gp,2,1,5,6,3,0,4,3);
			break;
		case 4:			/* 4 = 5 */
			/* if 4 = 7  do nothing */
			if(svec[3] == 5)	arb_mv(pts,gp,1,2,3,0,5,6,7,5);
			break;
		case 5:			/* 5 = 6 */
			arb_mv(pts,gp,2,3,0,1,6,7,4,6);
			break;
		case 6:			/* 6 = 7 */
			arb_mv(pts,gp,3,0,1,2,7,4,5,7);
			break;
		default:
			(void) fprintf( stderr, "redoarb: bad arb7\n" );
			return( 0 );
		}
		break;
		/* end of ARB7 case */
	case 6:
		/* arb6 vectors:  0 1 2 3 4 4 6 6 */
		prod = 1;
		for(i=0; i<numvec; i++)
			prod = prod * (uniq[i] + 1);
		switch( prod ) {
		case 24:	/* 0123 unique */
			/* 4=7 and 5=6  OR  4=5 and 6=7 */
			if(svec[3] == 7)	arb_mv(pts,gp,3,0,1,2,4,4,5,5);
			else	arb_mv(pts,gp,0,1,2,3,4,4,6,6);
			break;
		case 1680:	/* 4567 unique */
			/* 0=3 and 1=2  OR  0=1 and 2=3 */
			if(svec[3] == 3)	arb_mv(pts,gp,7,4,5,6,0,0,1,1);
			else	arb_mv(pts,gp,4,5,6,7,0,0,2,2);
			break;
		case 160:	/* 0473 unique */
			/* 1=2 and 5=6  OR  1=5 and 2=6 */
			if(svec[3] == 2)	arb_mv(pts,gp,0,3,7,4,1,1,5,5);
			else	arb_mv(pts,gp,4,0,3,7,1,1,2,2);
			break;
		case 672:	/* 3267 unique */
			/* 0=1 and 4=5  OR  0=4 and 1=5 */
			if(svec[3] == 1)	arb_mv(pts,gp,3,2,6,7,0,0,4,4);
			else	arb_mv(pts,gp,7,3,2,6,0,0,1,1);
			break;
		case 252:	/* 1256 unique */
			/* 0=3 and 4=7  OR 0=4 and 3=7 */
			if(svec[3] == 3)	arb_mv(pts,gp,1,2,6,5,0,0,4,4);
			else	arb_mv(pts,gp,5,1,2,6,0,0,3,3);
			break;
		case 60:	/* 0154 unique */
			/* 2=3 and 6=7  OR  2=6 and 3=7 */
			if(svec[3] == 3)	arb_mv(pts,gp,0,1,5,4,2,2,6,6);
			else	arb_mv(pts,gp,5,1,0,4,2,2,3,3);
			break;
		default:
			(void) fprintf( stderr,"redoarb: bad arb6\n");
			return( 0 );
		}
		break;
		/* end of ARB6 case */
	case 5:
		/* arb5 vectors:  0 1 2 3 4 4 4 4 */
		prod = 1;
		for(i=2; i<6; i++)
			prod = prod * (svec[i] + 1);
		switch( prod ) {
		case 24:	/* 0=1=2=3 */
			arb_mv(pts,gp,4,5,6,7,0,0,0,0);
			break;
		case 1680:	/* 4=5=6=7 */
			/* do nothing */
			break;
		case 160:	/* 0=3=4=7 */
			arb_mv(pts,gp,1,2,6,5,0,0,0,0);
			break;
		case 672:	/* 2=3=7=6 */
			arb_mv(pts,gp,0,1,5,4,2,2,2,2);
			break;
		case 252:	/* 1=2=5=6 */
			arb_mv(pts,gp,0,3,7,4,1,1,1,1);
			break;
		case 60:	/* 0=1=5=4 */
			arb_mv(pts,gp,3,2,6,7,0,0,0,0);
			break;
		default:
			(void) fprintf( stderr,"redoarb: bad arb5\n" );
			return( 0 );
		}
		break;
		/* end of ARB5 case */
	case 4:
		/* arb4 vectors:  0 1 2 0 4 4 4 4 */
		j = svec[6];
		if( svec[0] == 2 )	j = svec[4];
		arb_mv(pts,gp,uniq[0],uniq[1],svec[2],uniq[0],j,j,j,j);
		break;
	default:
		(void) fprintf( stderr,
		    "redoarb: unknown arb type (%d)\n", cgtype );
		return( 0 );
	}
	return( 1 );
}
@


11.5
log
@change conf.h to a wrapped config.h
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/vdeck/cgarbs.c,v 11.4 2004/02/02 17:39:52 morrison Exp $ (BRL)";
@


11.4
log
@update copyright to include span through 2003
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/vdeck/cgarbs.c,v 11.3 2001/04/20 22:31:29 morrison Exp $ (BRL)";
d25 5
a29 1
#include "conf.h"
@


11.3
log
@CONST to const
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1990 by the United States Army.
d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/vdeck/cgarbs.c,v 11.2 2000/08/24 22:56:19 mike Exp $ (BRL)";
@


11.3.4.1
log
@sync branch with HEAD
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d22 1
a22 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.3.6.1
log
@sync to HEAD...
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/vdeck/cgarbs.c,v 11.4 2004/02/02 17:39:52 morrison Exp $ (BRL)";
@


11.3.6.2
log
@join with HEAD
@
text
@@


11.3.6.3
log
@join with HEAD
@
text
@@


11.3.6.4
log
@join with HEAD
@
text
@@


11.3.12.1
log
@merge from HEAD
@
text
@d18 1
a18 1
 *	This software is Copyright (C) 1990-2004 by the United States Army.
d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/vdeck/cgarbs.c,v 11.4 2004/02/02 17:39:52 morrison Exp $ (BRL)";
@


11.3.12.2
log
@merge from head
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/vdeck/cgarbs.c,v 11.3.12.1 2004/02/12 19:43:51 erikg Exp $ (BRL)";
@


11.2
log
@
RCSid
@
text
@d22 1
a22 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/vdeck/cgarbs.c,v 11.1 1995/01/04 10:18:35 mike Rel4_4 $ (BRL)";
d49 1
a49 1
CONST struct rt_arb_internal	*gp;
d52 1
a52 1
CONST double		dist_tol;	/* distance tolerance */
d143 2
a144 2
register CONST struct rt_arb_internal	*gp;
CONST int		p0, p1, p2, p3, p4, p5, p6, p7;
d171 1
a171 1
CONST struct rt_arb_internal	*gp;
d174 2
a175 2
CONST int	numvec;
CONST int	cgtype;
@


11.1
log
@Release_4.4
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/vdeck/RCS/cgarbs.c,v 10.2 94/08/23 14:51:12 gdurf Exp $ (BRL)";
@


10.2
log
@Added include of conf.h
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/vdeck/RCS/cgarbs.c,v 10.1 1991/10/12 06:50:30 mike Rel4_0 gdurf $ (BRL)";
@


10.1
log
@Release_4.0
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /m/cad/vdeck/RCS/cgarbs.c,v 9.3 91/06/01 20:34:35 mike Exp $ (BRL)";
d24 2
@


9.3
log
@Modified to be more generally useful.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
@


9.2
log
@Beautified
@
text
@d2 22
a23 2
	@@(#) cgarbs.c			retrieved: 8/13/86 at 08:00:50,
	@@(#) version 2.5		last edit: 7/10/86 at 11:07:42., G S Moss.
a24 2
	Written by Keith Applin.
 */
d26 5
a30 1
#include "./vextern.h"
d32 11
a42 1
/* C G A R B S :   determines COMGEOM arb types from GED general arbs
d44 7
a50 4
cgarbs( rec, uvec, svec )
register Record *rec;
int uvec[];	/* array of unique points */
int svec[];	/* array of like points */
d53 1
a53 1
	int		numuvec, unique, done;
d66 1
a66 4
			if(	compar(	&(rec->s.s_values[i*3]),
			    &(rec->s.s_values[j*3])
			    ) == YES
			    ) {
d92 1
d94 1
a94 1
	numuvec = 0;
d104 1
a104 1
			uvec[numuvec++] = j;
d108 1
a108 1
	switch( numuvec ) {
d110 1
a110 1
		rec->s.s_cgtype = -8;  /* ARB8 */
d113 1
a113 1
		rec->s.s_cgtype = -7;	/* ARB7 */
d116 4
a119 2
		if(svec[0] == 2)	rec->s.s_cgtype = -6;	/* ARB6 */
		else	rec->s.s_cgtype = -5;	/* ARB5 */
d122 1
a122 1
		rec->s.s_cgtype = -4;	/* ARB4 */
d126 2
a127 3
		    "solid: %s  bad number of unique vectors (%d)\n",
		    rec->s.s_name,numuvec
		    );
d130 1
a130 1
	return( numuvec );
d133 4
a136 1
/*  R E D O A R B :   rearranges arbs to be GIFT compatible
d138 36
a173 4
redoarb( rec, uvec, svec, numvec )
register
Record  *rec;
int uvec[], svec[], numvec;
d176 1
a176 1
	int		prod, cgtype;
d178 6
a183 1
	cgtype = rec->s.s_cgtype * -1;
d185 1
a185 1
	case ARB8:
d187 3
a189 1
	case ARB7:	/* arb7 vectors: 0 1 2 3 4 5 6 4 */
d192 3
a194 3
			if(svec[3] == 1)	move(rec,4,7,6,5,1,4,3,1);
			if(svec[3] == 3)	move(rec,4,5,6,7,0,1,2,0);
			if(svec[3] == 4)	move(rec,1,2,6,5,0,3,7,0);
d197 2
a198 2
			if(svec[3] == 2)	move(rec,0,4,7,3,1,5,6,1);
			if(svec[3] == 5)	move(rec,0,3,7,4,1,2,6,1);
d201 2
a202 2
			if(svec[3] == 3)	move(rec,6,5,4,7,2,1,0,2);
			if(svec[3] == 6)	move(rec,3,0,4,7,2,1,5,2);
d205 1
a205 1
			move(rec,2,1,5,6,3,0,4,3);
d209 1
a209 1
			if(svec[3] == 5)	move(rec,1,2,3,0,5,6,7,5);
d212 1
a212 1
			move(rec,2,3,0,1,6,7,4,6);
d215 1
a215 1
			move(rec,3,0,1,2,7,4,5,7);
d218 1
a218 1
			(void) fprintf( stderr, "%s: bad arb7\n", rec->s.s_name );
d223 2
a224 1
	case ARB6:	/* arb6 vectors:  0 1 2 3 4 4 6 6 */
d227 1
a227 1
			prod = prod * (uvec[i] + 1);
d231 2
a232 2
			if(svec[3] == 7)	move(rec,3,0,1,2,4,4,5,5);
			else	move(rec,0,1,2,3,4,4,6,6);
d236 2
a237 2
			if(svec[3] == 3)	move(rec,7,4,5,6,0,0,1,1);
			else	move(rec,4,5,6,7,0,0,2,2);
d241 2
a242 2
			if(svec[3] == 2)	move(rec,0,3,7,4,1,1,5,5);
			else	move(rec,4,0,3,7,1,1,2,2);
d246 2
a247 2
			if(svec[3] == 1)	move(rec,3,2,6,7,0,0,4,4);
			else	move(rec,7,3,2,6,0,0,1,1);
d251 2
a252 2
			if(svec[3] == 3)	move(rec,1,2,6,5,0,0,4,4);
			else	move(rec,5,1,2,6,0,0,3,3);
d256 2
a257 2
			if(svec[3] == 3)	move(rec,0,1,5,4,2,2,6,6);
			else	move(rec,5,1,0,4,2,2,3,3);
d260 1
a260 1
			(void) fprintf( stderr,"%s: bad arb6\n", rec->s.s_name);
d265 2
a266 1
	case ARB5:	/* arb5 vectors:  0 1 2 3 4 4 4 4 */
d272 1
a272 1
			move(rec,4,5,6,7,0,0,0,0);
d278 1
a278 1
			move(rec,1,2,6,5,0,0,0,0);
d281 1
a281 1
			move(rec,0,1,5,4,2,2,2,2);
d284 1
a284 1
			move(rec,0,3,7,4,1,1,1,1);
d287 1
a287 1
			move(rec,3,2,6,7,0,0,0,0);
d290 1
a290 1
			(void) fprintf( stderr,"%s: bad arb5\n", rec->s.s_name);
d295 2
a296 1
	case ARB4:	/* arb4 vectors:  0 1 2 0 4 4 4 4 */
d299 1
a299 1
		move(rec,uvec[0],uvec[1],svec[2],uvec[0],j,j,j,j);
d303 1
a303 3
		    "solid %s: unknown arb type (%d)\n",
		    rec->s.s_name,rec->s.s_cgtype
		    );
a306 41
}

move( rec, p0, p1, p2, p3, p4, p5, p6, p7 )
register Record	*rec;
int		p0, p1, p2, p3, p4, p5, p6, p7;
{	
	register int	i, j;
	int		pts[8];
	float		copy[24];
	pts[0] = p0 * 3;
	pts[1] = p1 * 3;
	pts[2] = p2 * 3;
	pts[3] = p3 * 3;
	pts[4] = p4 * 3;
	pts[5] = p5 * 3;
	pts[6] = p6 * 3;
	pts[7] = p7 * 3;

	/* Copy of the record.						*/
	for( i = 0; i <= 21; i += 3 )
	{
		VMOVE( &copy[i], &(rec->s.s_values[i]) );
	}
	for( i = 0; i < 8; i++ )
	{
		j = pts[i];
		VMOVE( &(rec->s.s_values[i*3]), &copy[j] );
	}
	return;
}

compar( x, y )
register float *x, *y;
{	
	register int i;
	for( i = 0; i < 3; i++ )
	{
		if( fabs( *x++ - *y++ ) > CONV_EPSILON )
			return	0;   /* Different */
	}
	return	1;  /* Same */
@


9.1
log
@Release_3.5
@
text
@d32 3
a34 3
					&(rec->s.s_values[j*3])
				) == YES
			) {
d52 1
a52 1
	if( si > 2 && si < 6 ) 
d84 1
a84 1
		else			rec->s.s_cgtype = -5;	/* ARB5 */
d91 3
a93 3
				"solid: %s  bad number of unique vectors (%d)\n",
				rec->s.s_name,numuvec
				);
d132 1
a132 1
					/* if 4 = 7  do nothing */
d145 1
a145 1
		break;  
d153 1
a153 1
				/* 4=7 and 5=6  OR  4=5 and 6=7 */
d155 1
a155 1
			else			move(rec,0,1,2,3,4,4,6,6);
d158 1
a158 1
				/* 0=3 and 1=2  OR  0=1 and 2=3 */
d160 1
a160 1
			else			move(rec,4,5,6,7,0,0,2,2);
d163 1
a163 1
				/* 1=2 and 5=6  OR  1=5 and 2=6 */
d165 1
a165 1
			else			move(rec,4,0,3,7,1,1,2,2);
d168 1
a168 1
				/* 0=1 and 4=5  OR  0=4 and 1=5 */
d170 1
a170 1
			else			move(rec,7,3,2,6,0,0,1,1);
d173 1
a173 1
				/* 0=3 and 4=7  OR 0=4 and 3=7 */
d175 1
a175 1
			else			move(rec,5,1,2,6,0,0,3,3);
d178 1
a178 1
				/* 2=3 and 6=7  OR  2=6 and 3=7 */
d180 1
a180 1
			else			move(rec,5,1,0,4,2,2,3,3);
d197 1
a197 1
				/* do nothing */
d224 3
a226 3
				"solid %s: unknown arb type (%d)\n",
				rec->s.s_name,rec->s.s_cgtype
				);
d235 4
a238 3
	{	register int	i, j;
		int		pts[8];
		float		copy[24];
d250 1
a250 1
		{
d252 1
a252 1
		}
d254 1
a254 1
		{
d257 1
a257 1
		}
d259 1
a259 1
	}
d263 2
a264 1
	{	register int i;
d266 1
a266 1
		{
d269 1
a269 1
		}
d271 1
a271 1
	}
@


8.1
log
@Release_3.0
@
text
@@


7.1
log
@Release 2.3
@
text
@@


6.1
log
@Release 2.0
@
text
@@


5.1
log
@Release 1.24
@
text
@@


4.2
log
@Release 1.20 -- First Formal Release
@
text
@@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@@


2.5
log
@Swapped vectors for TEC and REC to appease GIFT. Linted code.
@
text
@@


2.4
log
@Fixed buffer size in cgobj(), linted quite a bit.
@
text
@d2 2
a3 2
	@@(#) cgarbs.c			retrieved: 8/13/86 at 08:00:38,
	@@(#) version 2.4		last edit: 12/20/85 at 19:04:27., G S Moss.
d7 1
d90 4
a93 2
		printf("solid: %s  bad number of unique vectors (%d)\n",
			rec->s.s_name,numuvec);
d142 1
a142 1
			printf("%s: bad arb7\n", rec->s.s_name);
d183 1
a183 1
			printf("%s: bad arb6\n", rec->s.s_name);
d212 1
a212 1
			printf("%s: bad arb5\n", rec->s.s_name);
d223 4
a226 2
		printf("solid %s: unknown arb type (%d)\n",
				rec->s.s_name,rec->s.s_cgtype);
d232 6
a237 10
move(	rec, p0, p1, p2, p3, p4, p5, p6, p7 )
register
Record *rec;
int p0, p1, p2, p3, p4, p5, p6, p7;
{

	register int	i, j;
	int		pts[8];
	float		copy[24];

d247 3
a249 2
	/* Copy of the record.				*/
	for( i = 0; i <= 21; i += 3 ) {
d251 3
a253 2
	}
	for( i = 0; i < 8; i++ ) {
d256 2
a258 2
	return;
}
d261 4
a264 5
register
float *x,*y;
{
	register int i;
	for( i = 0; i < 3; i++ ) {
d266 3
a268 1
			return( 0 );   /* Different */
a269 2
	return( 1 );  /* Same */
}
@


2.3
log
@Loosened up epsilon value in discriminating between solid types 
in vproc.c and cgarbs.c .
@
text
@d2 4
a5 4
 *	@@(#) cgarbs.c			retrieved: 8/13/86 at 08:00:24,
 *	@@(#) version 2.3		last edit: 3/18/85 at 14:25:24., G S Moss.
 *
 *	Written by Keith Applin.
d12 1
a12 2
register
Record *rec;
a91 1
		break;
a104 3
	float		testm;
	float		vec[3];
	int		nleg1, nleg2, nleg3;
d108 1
a108 83
	case ARB8: /* New stuff Mar 29, 1983.				*/
#ifdef 0 /* THIS CODE DOES NOT WORK ====================================*/
	fprintf( stderr,
	"redoarb():ERROR this statement should not be reached!\n" );
	exit( 1 );
		/* Convert to vector notation to check for BOX and RPP.	*/
		vectors( rec );

		/* ARB8 is a BOX if all following true:
		 *   1.  vectors [3],[9],[12] mutually perpendicular
		 *   2.  |[15]-[3]|  == |[12]|
		 *   3.  |[6]-[3]|   == |[9]|
		 *   4.  |[18]-[15]| == |[9]|
		 *   5.  |[21]-[12]| == |[9]|
		 */

		/* Test condition 1.					*/
		if(	fabs(	DOT(	&(rec->s.s_values[3]),
					&(rec->s.s_values[9])
				)) > .0001
		    ||	fabs(	DOT(	&(rec->s.s_values[9]),
					&(rec->s.s_values[12])
				)) > .0001
		) { 
			points( rec );
			break;
		}

		/* Test condition 2.					*/
		testm = MAGNITUDE( &(rec->s.s_values[12]) );
		VSUB2(vec, &(rec->s.s_values[15]), &(rec->s.s_values[3]) );
		if( fabs( MAGNITUDE( vec ) - testm ) > .0001 ) {
			points( rec );
			break;
		}
		testm = MAGNITUDE( &(rec->s.s_values[9]) );

		/* Test condition 3.					*/
		VSUB2( vec, &(rec->s.s_values[6]), &(rec->s.s_values[3]) );
		if( fabs( MAGNITUDE( vec ) - testm ) > .0001 ) {
			points( rec );
			break;
		}

		/* Test condition 4.					*/
		VSUB2(	vec,
			&(rec->s.s_values[18]),
			&(rec->s.s_values[15])
		);
		if( fabs( MAGNITUDE( vec ) - testm ) > .0001 ) {
			points( rec );
			break;
		}

		/* Test condition 5.					*/
		VSUB2(	vec,
			&(rec->s.s_values[21]),
			&(rec->s.s_values[12])
		);
		if( fabs( MAGNITUDE( vec ) - testm ) > .0001 ) {
			points( rec );
			break;
		}

		/* Have a BOX.						*/
		rec->s.s_cgtype = -2;

		/* Check for RPP.					*/
		nleg1 = nleg2 = nleg3 = 0;
		for( i = 0; i < 3; i++ ) {
			if( fabs( rec->s.s_values[3+i] ) < .0001 )
				nleg1++;
			if( fabs( rec->s.s_values[9+i] ) < .0001 )
				nleg2++;
			if( fabs( rec->s.s_values[12+i] ) < .0001 )
				nleg3++;
		}
		if( nleg1 == 2 && nleg2 == 2 && nleg3 == 2 )
			rec->s.s_cgtype = -1;	/* RPP */

		/* Back to point notation.				*/
		points( rec );
#endif
a140 1
			break;
a181 1
			break;
a210 1
			break;
a222 1
		break;
a266 30
}

vectors(rec)
register
Record *rec;
{
	register int	i;

	for( i = 3; i <= 21; i += 3 ) {
		VSUB2(	&(rec->s.s_values[i]),
			&(rec->s.s_values[i]),
			&(rec->s.s_values[0])
		);
	}
	return;
}

points( rec )
register
Record *rec;
{
	register int	i;

	for( i = 3; i <= 21; i += 3 ) {
		VADD2(	&(rec->s.s_values[i]),
			&(rec->s.s_values[i]),
			&(rec->s.s_values[0])
		);
	}
	return;
@


2.2
log
@Added support for new database format, ident and free records,
 and unit conversions.  Now puts title and units on first card.  Title 
version number and units are printed out when building the directory.
@
text
@d2 2
a3 2
 *	@@(#) cgarbs.c			retrieved: 8/13/86 at 08:00:14,
 *	@@(#) version 2.2		last edit: 1/31/85 at 14:59:52., G S Moss.
d354 1
a354 1
		if( fabs( *x++ - *y++ ) > .0001 )
@


2.1
log
@Just bumped version number to 2.1, no changes.
@
text
@d2 2
a3 2
 *	@@(#) cgarbs.c			retrieved: 8/13/86 at 08:00:06,
 *	@@(#) version 2.1		last edit: 6/1/84 at 14:04:40., G S Moss.
@


1.7
log
@*** empty log message ***
@
text
@d2 2
a3 2
 *	@@(#) cgarbs.c			retrieved: 8/13/86 at 07:59:54,
 *	@@(#) version 1.7		last edit: 10/11/83 at 10:57:16., G S Moss.
@


1.6
log
@*** empty log message ***
@
text
@d2 2
a3 2
 *	@@(#) cgarbs.c			retrieved: 8/13/86 at 07:59:43,
 *	@@(#) version 1.6		last edit: 10/11/83 at 10:02:36., G S Moss.
d7 1
a7 4
#include "./ged_types.h"
#include "./3d.h"
#include "./vdeck.h"
extern double	fabs();
@


1.5
log
@ifdeffed out the ARB8 case in redoarb() until its fixed.
@
text
@d2 2
a3 2
 *	@@(#) cgarbs.c			retrieved 8/13/86 at 07:59:34,
 *	@@(#) version 1.5		  created 7/19/83 at 10:58:32.
a5 1
 *	All rights reserved, Ballistic Research Laboratory.
d7 3
a9 3
#include "ged_types.h"
#include "3d.h"
#include "./deck.h"
d77 1
a77 1
	/* put comgeom solid typpe into s_num */
d80 1
a80 1
		rec->s.s_num = -8;  /* ARB8 */
d83 1
a83 1
		rec->s.s_num = -7;	/* ARB7 */
d86 2
a87 2
		if(svec[0] == 2)	rec->s.s_num = -6;	/* ARB6 */
		else			rec->s.s_num = -5;	/* ARB5 */
d90 1
a90 1
		rec->s.s_num = -4;	/* ARB4 */
d114 1
a114 1
	cgtype = rec->s.s_num * -1;
d181 1
a181 1
		rec->s.s_num = -2;
d194 1
a194 1
			rec->s.s_num = -1;	/* RPP */
d314 1
a314 1
				rec->s.s_name,rec->s.s_num);
@


1.4
log
@Added arb8 case in redoarb().
@
text
@d2 2
a3 2
 *	@@(#) cgarbs.c			retrieved 8/13/86 at 07:59:24,
 *	@@(#) version 1.4		  created 3/29/83 at 10:53:12.
d118 4
d199 1
@


1.3
log
@Presented area calculation and plotting of bounding polygon installed.
Works on some views, probably needs the tolerance adjusted.
@
text
@d2 2
a3 2
 *	@@(#) cgarbs.c			retrieved 8/13/86 at 07:59:15,
 *	@@(#) version 1.3		  created 3/23/83 at 12:37:46.
d10 1
a10 1
#include "./view.h"
d111 3
d117 78
a194 1
	case ARB8:		/* do nothing */
@


1.2
log
@Added presented area calculations.
@
text
@d2 2
a3 2
 *	@@(#) cgarbs.c			retrieved 8/13/86 at 07:59:01,
 *	@@(#) version 1.2		  created 3/16/83 at 15:37:13.
d11 1
d35 5
a39 3
			if(compar((rec->s.s_values[i*3]), (rec->s.s_values[j*3])) == YES) {
				if( done == NO )
					svec[++si] = j;
d266 1
@


1.1
log
@Initial revision
@
text
@d2 2
a3 2
 *	@@(#) cgarbs.c			retrieved 8/13/86 at 07:58:54,
 *	@@(#) version 1.1		  created 3/15/83 at 08:28:12.
d116 3
a118 3
			if(svec[3] == 1)	move(&rec,4,7,6,5,1,4,3,1);
			if(svec[3] == 3)	move(&rec,4,5,6,7,0,1,2,0);
			if(svec[3] == 4)	move(&rec,1,2,6,5,0,3,7,0);
d121 2
a122 2
			if(svec[3] == 2)	move(&rec,0,4,7,3,1,5,6,1);
			if(svec[3] == 5)	move(&rec,0,3,7,4,1,2,6,1);
d125 2
a126 2
			if(svec[3] == 3)	move(&rec,6,5,4,7,2,1,0,2);
			if(svec[3] == 6)	move(&rec,3,0,4,7,2,1,5,2);
d129 1
a129 1
			move(&rec,2,1,5,6,3,0,4,3);
d133 1
a133 1
			if(svec[3] == 5)	move(&rec,1,2,3,0,5,6,7,5);
d136 1
a136 1
			move(&rec,2,3,0,1,6,7,4,6);
d139 1
a139 1
			move(&rec,3,0,1,2,7,4,5,7);
d155 2
a156 2
			if(svec[3] == 7)	move(&rec,3,0,1,2,4,4,5,5);
			else			move(&rec,0,1,2,3,4,4,6,6);
d160 2
a161 2
			if(svec[3] == 3)	move(&rec,7,4,5,6,0,0,1,1);
			else			move(&rec,4,5,6,7,0,0,2,2);
d165 2
a166 2
			if(svec[3] == 2)	move(&rec,0,3,7,4,1,1,5,5);
			else			move(&rec,4,0,3,7,1,1,2,2);
d170 2
a171 2
			if(svec[3] == 1)	move(&rec,3,2,6,7,0,0,4,4);
			else			move(&rec,7,3,2,6,0,0,1,1);
d175 2
a176 2
			if(svec[3] == 3)	move(&rec,1,2,6,5,0,0,4,4);
			else			move(&rec,5,1,2,6,0,0,3,3);
d180 2
a181 2
			if(svec[3] == 3)	move(&rec,0,1,5,4,2,2,6,6);
			else			move(&rec,5,1,0,4,2,2,3,3);
d196 1
a196 1
			move(&rec,4,5,6,7,0,0,0,0);
d202 1
a202 1
			move(&rec,1,2,6,5,0,0,0,0);
d205 1
a205 1
			move(&rec,0,1,5,4,2,2,2,2);
d208 1
a208 1
			move(&rec,0,3,7,4,1,1,1,1);
d211 1
a211 1
			move(&rec,3,2,6,7,0,0,0,0);
d223 1
a223 1
		move(&rec,uvec[0],uvec[1],svec[2],uvec[0],j,j,j,j);
@
