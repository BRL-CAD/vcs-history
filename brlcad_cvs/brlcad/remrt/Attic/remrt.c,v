head	11.39;
access;
symbols
	ansi-20040405-merged:11.34.2.3
	postmerge-20040405-ansi:11.37
	premerge-20040404-ansi:11.36
	postmerge-autoconf:11.36
	autoconf-freeze:11.35.2.3
	premerge-autoconf:11.36
	postmerge-20040315-windows:11.36
	premerge-20040315-windows:11.36
	windows-20040315-freeze:11.34.4.1
	autoconf-20031203:11.35
	autoconf-20031202:11.35
	autoconf-branch:11.35.0.2
	phong-branch:11.34.0.8
	photonmap-branch:11.34.0.6
	rel-6-1-DP:11.34
	windows-branch:11.34.0.4
	rel-6-0-2:11.32
	ansi-branch:11.34.0.2
	rel-6-0-1-branch:11.32.0.2
	hartley-6-0-post:11.33
	hartley-6-0-pre:11.32
	rel-6-0-1:11.32
	rel-6-0:11.32
	rel-5-4:11.21.2.1
	offsite-5-3-pre:11.23
	rel-5-3:11.21
	rel-5-2:11.21
	rel-5-1-branch:11.21.0.2
	rel-5-1:11.21
	rel-5-0:11.18
	rel-5-0-beta:11.18
	rel-4-5:11.14
	ctj-4-5-post:11.13
	ctj-4-5-pre:11.13
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:1.17
	rel-2-0:1.14
	rel-1-24:1.14
	rel-1-20:1.13
	rel-1-10:1.13
	CMD:9.37;
locks; strict;
comment	@ * @;


11.39
date	2004.05.21.17.33.31;	author morrison;	state dead;
branches;
next	11.38;

11.38
date	2004.05.10.15.30.49;	author erikg;	state Exp;
branches;
next	11.37;

11.37
date	2004.04.05.05.45.58;	author morrison;	state Exp;
branches;
next	11.36;

11.36
date	2004.02.02.17.39.38;	author morrison;	state Exp;
branches;
next	11.35;

11.35
date	2003.09.27.00.59.22;	author morrison;	state Exp;
branches
	11.35.2.1;
next	11.34;

11.34
date	2002.08.20.17.08.37;	author jra;	state Exp;
branches
	11.34.2.1
	11.34.4.1;
next	11.33;

11.33
date	2002.08.15.20.55.49;	author hartley;	state Exp;
branches;
next	11.32;

11.32
date	2001.10.24.00.50.02;	author morrison;	state Exp;
branches;
next	11.31;

11.31
date	2001.10.17.07.40.06;	author morrison;	state Exp;
branches;
next	11.30;

11.30
date	2001.08.11.13.18.07;	author butler;	state Exp;
branches;
next	11.29;

11.29
date	2001.07.19.23.45.29;	author morrison;	state Exp;
branches;
next	11.28;

11.28
date	2001.07.19.18.02.08;	author bparker;	state Exp;
branches;
next	11.27;

11.27
date	2001.07.10.22.54.06;	author morrison;	state Exp;
branches;
next	11.26;

11.26
date	2001.05.17.20.06.01;	author morrison;	state Exp;
branches;
next	11.25;

11.25
date	2001.05.16.21.38.14;	author morrison;	state Exp;
branches;
next	11.24;

11.24
date	2001.04.20.22.31.18;	author morrison;	state Exp;
branches;
next	11.23;

11.23
date	2000.08.25.01.37.18;	author mike;	state Exp;
branches;
next	11.22;

11.22
date	2000.08.24.22.23.25;	author mike;	state Exp;
branches;
next	11.21;

11.21
date	2000.05.19.12.34.48;	author jra;	state Exp;
branches
	11.21.2.1;
next	11.20;

11.20
date	2000.01.31.15.12.12;	author jra;	state Exp;
branches;
next	11.19;

11.19
date	99.12.30.05.49.09;	author butler;	state Exp;
branches;
next	11.18;

11.18
date	98.09.14.15.59.22;	author bparker;	state Exp;
branches;
next	11.17;

11.17
date	98.08.21.19.59.35;	author mike;	state Exp;
branches;
next	11.16;

11.16
date	98.03.24.01.22.57;	author mike;	state Exp;
branches;
next	11.15;

11.15
date	98.03.24.01.04.17;	author mike;	state Exp;
branches;
next	11.14;

11.14
date	97.12.04.01.59.42;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	97.01.04.03.24.30;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	96.07.15.17.40.50;	author jra;	state Exp;
branches;
next	11.11;

11.11
date	95.10.12.18.49.36;	author cjohnson;	state Exp;
branches;
next	11.10;

11.10
date	95.07.18.03.08.23;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	95.07.14.02.59.45;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	95.07.14.00.40.51;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	95.07.14.00.17.37;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	95.07.14.00.12.55;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	95.03.23.02.43.17;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	95.03.17.23.56.38;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	95.03.01.03.49.01;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	95.03.01.03.44.26;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.03.59;	author mike;	state Rel4_4;
branches;
next	10.20;

10.20
date	95.01.04.09.06.00;	author mike;	state Exp;
branches;
next	10.19;

10.19
date	94.12.30.15.30.03;	author stay;	state Exp;
branches;
next	10.18;

10.18
date	94.12.30.01.14.37;	author mike;	state Exp;
branches;
next	10.17;

10.17
date	94.11.05.03.31.22;	author mike;	state Exp;
branches;
next	10.16;

10.16
date	94.10.17.17.20.27;	author mike;	state Exp;
branches;
next	10.15;

10.15
date	94.09.23.18.56.19;	author mike;	state Exp;
branches;
next	10.14;

10.14
date	94.08.12.21.09.28;	author gdurf;	state Exp;
branches;
next	10.13;

10.13
date	94.05.07.22.12.20;	author mike;	state Exp;
branches;
next	10.12;

10.12
date	94.05.06.04.07.09;	author mike;	state Exp;
branches;
next	10.11;

10.11
date	94.05.06.03.52.50;	author mike;	state Exp;
branches;
next	10.10;

10.10
date	94.05.06.03.42.47;	author mike;	state Exp;
branches;
next	10.9;

10.9
date	94.05.06.01.31.33;	author mike;	state Exp;
branches;
next	10.8;

10.8
date	94.05.05.20.48.06;	author mike;	state Exp;
branches;
next	10.7;

10.7
date	94.02.10.03.59.41;	author cjohnson;	state Exp;
branches;
next	10.6;

10.6
date	94.01.14.20.53.26;	author cjohnson;	state Exp;
branches;
next	10.5;

10.5
date	93.10.26.00.35.40;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	93.09.28.02.39.22;	author cjohnson;	state Exp;
branches;
next	10.3;

10.3
date	93.09.25.04.40.50;	author cjohnson;	state Exp;
branches;
next	10.2;

10.2
date	93.09.25.01.11.07;	author cjohnson;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.42.33;	author mike;	state Rel4_0;
branches;
next	9.44;

9.44
date	91.08.31.03.03.22;	author mike;	state Exp;
branches;
next	9.43;

9.43
date	91.08.30.03.55.35;	author mike;	state Exp;
branches;
next	9.42;

9.42
date	91.07.19.01.18.00;	author mike;	state Exp;
branches;
next	9.41;

9.41
date	91.07.19.01.09.21;	author mike;	state Exp;
branches;
next	9.40;

9.40
date	91.07.06.01.57.52;	author mike;	state Exp;
branches;
next	9.39;

9.39
date	91.07.01.22.42.44;	author mike;	state Exp;
branches;
next	9.38;

9.38
date	91.06.28.00.26.06;	author cjohnson;	state Exp;
branches;
next	9.37;

9.37
date	91.06.28.00.22.27;	author cjohnson;	state Exp;
branches;
next	9.36;

9.36
date	91.01.27.12.41.38;	author cjohnson;	state Exp;
branches;
next	9.35;

9.35
date	91.01.27.10.52.04;	author cjohnson;	state Exp;
branches;
next	9.34;

9.34
date	91.01.12.08.47.34;	author mike;	state Exp;
branches;
next	9.33;

9.33
date	90.12.13.16.16.05;	author mike;	state Exp;
branches;
next	9.32;

9.32
date	90.12.08.04.45.57;	author mike;	state Exp;
branches;
next	9.31;

9.31
date	90.12.08.01.14.10;	author mike;	state Exp;
branches;
next	9.30;

9.30
date	90.12.05.19.16.38;	author mike;	state Exp;
branches;
next	9.29;

9.29
date	90.12.03.15.32.55;	author mike;	state Exp;
branches;
next	9.28;

9.28
date	90.11.27.22.04.11;	author mike;	state Exp;
branches;
next	9.27;

9.27
date	90.11.22.07.27.14;	author mike;	state Exp;
branches;
next	9.26;

9.26
date	90.11.22.06.47.27;	author mike;	state Exp;
branches;
next	9.25;

9.25
date	90.11.22.06.29.32;	author mike;	state Exp;
branches;
next	9.24;

9.24
date	90.11.22.03.52.13;	author mike;	state Exp;
branches;
next	9.23;

9.23
date	90.11.21.06.37.45;	author mike;	state Exp;
branches;
next	9.22;

9.22
date	90.11.16.00.33.38;	author mike;	state Exp;
branches;
next	9.21;

9.21
date	90.11.15.23.45.10;	author mike;	state Exp;
branches;
next	9.20;

9.20
date	90.11.11.02.38.38;	author mike;	state Exp;
branches;
next	9.19;

9.19
date	90.11.11.02.34.03;	author cjohnson;	state Exp;
branches;
next	9.18;

9.18
date	90.10.16.11.22.12;	author mike;	state Exp;
branches;
next	9.17;

9.17
date	89.11.24.23.00.49;	author mike;	state Exp;
branches;
next	9.16;

9.16
date	89.11.23.00.49.09;	author mike;	state Exp;
branches;
next	9.15;

9.15
date	89.11.23.00.38.36;	author mike;	state Exp;
branches;
next	9.14;

9.14
date	89.11.22.23.10.55;	author mike;	state Exp;
branches;
next	9.13;

9.13
date	89.11.22.22.44.00;	author mike;	state Exp;
branches;
next	9.12;

9.12
date	89.11.22.22.20.39;	author mike;	state Exp;
branches;
next	9.11;

9.11
date	89.11.17.20.49.00;	author cjohnson;	state Exp;
branches;
next	9.10;

9.10
date	89.11.17.00.13.46;	author mike;	state Exp;
branches;
next	9.9;

9.9
date	89.11.16.23.40.06;	author mike;	state Exp;
branches;
next	9.8;

9.8
date	89.11.16.21.40.59;	author mike;	state Exp;
branches;
next	9.7;

9.7
date	89.11.15.03.40.13;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	89.11.15.02.55.27;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	89.11.15.02.48.34;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	89.11.14.19.05.20;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	89.08.23.03.27.11;	author phil;	state Exp;
branches;
next	9.2;

9.2
date	89.06.19.22.56.18;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.00.22;	author mike;	state Rel3_5;
branches;
next	8.49;

8.49
date	89.05.12.20.20.49;	author mike;	state Exp;
branches;
next	8.48;

8.48
date	89.04.22.05.08.15;	author mike;	state Exp;
branches;
next	8.47;

8.47
date	89.04.04.04.53.07;	author mike;	state Exp;
branches;
next	8.46;

8.46
date	89.03.20.02.51.00;	author mike;	state Exp;
branches;
next	8.45;

8.45
date	89.03.19.23.18.32;	author mike;	state Exp;
branches;
next	8.44;

8.44
date	89.03.16.02.02.16;	author mike;	state Exp;
branches;
next	8.43;

8.43
date	89.03.16.01.18.28;	author mike;	state Exp;
branches;
next	8.42;

8.42
date	89.03.16.00.44.21;	author mike;	state Exp;
branches;
next	8.41;

8.41
date	89.03.16.00.11.53;	author mike;	state Exp;
branches;
next	8.40;

8.40
date	89.03.15.22.39.06;	author mike;	state Exp;
branches;
next	8.39;

8.39
date	89.03.15.20.30.27;	author mike;	state Exp;
branches;
next	8.38;

8.38
date	89.03.11.23.27.35;	author mike;	state Exp;
branches;
next	8.37;

8.37
date	89.03.10.05.05.03;	author mike;	state Exp;
branches;
next	8.36;

8.36
date	89.03.08.22.59.04;	author mike;	state Exp;
branches;
next	8.35;

8.35
date	89.03.08.22.40.58;	author mike;	state Exp;
branches;
next	8.34;

8.34
date	89.03.04.04.09.18;	author mike;	state Exp;
branches;
next	8.33;

8.33
date	89.03.04.03.11.02;	author mike;	state Exp;
branches;
next	8.32;

8.32
date	89.02.14.06.35.40;	author mike;	state Exp;
branches;
next	8.31;

8.31
date	89.02.14.05.00.50;	author mike;	state Exp;
branches;
next	8.30;

8.30
date	89.02.14.00.43.52;	author mike;	state Exp;
branches;
next	8.29;

8.29
date	89.02.13.07.46.30;	author mike;	state Exp;
branches;
next	8.28;

8.28
date	89.02.13.06.21.40;	author mike;	state Exp;
branches;
next	8.27;

8.27
date	89.02.11.04.50.04;	author mike;	state Exp;
branches;
next	8.26;

8.26
date	89.02.11.03.30.21;	author mike;	state Exp;
branches;
next	8.25;

8.25
date	89.02.10.06.13.19;	author mike;	state Exp;
branches;
next	8.24;

8.24
date	89.02.10.05.47.46;	author mike;	state Exp;
branches;
next	8.23;

8.23
date	89.02.10.05.33.38;	author mike;	state Exp;
branches;
next	8.22;

8.22
date	89.02.10.05.12.22;	author mike;	state Exp;
branches;
next	8.21;

8.21
date	89.02.10.04.33.32;	author mike;	state Exp;
branches;
next	8.20;

8.20
date	89.02.10.03.57.46;	author mike;	state Exp;
branches;
next	8.19;

8.19
date	89.02.10.03.07.54;	author mike;	state Exp;
branches;
next	8.18;

8.18
date	89.01.27.00.53.58;	author mike;	state Exp;
branches;
next	8.17;

8.17
date	89.01.26.22.52.04;	author mike;	state Exp;
branches;
next	8.16;

8.16
date	89.01.26.21.55.31;	author mike;	state Exp;
branches;
next	8.15;

8.15
date	89.01.26.21.45.59;	author mike;	state Exp;
branches;
next	8.14;

8.14
date	89.01.26.09.08.41;	author mike;	state Exp;
branches;
next	8.13;

8.13
date	89.01.26.08.41.36;	author mike;	state Exp;
branches;
next	8.12;

8.12
date	89.01.26.05.57.14;	author mike;	state Exp;
branches;
next	8.11;

8.11
date	89.01.26.04.52.57;	author mike;	state Exp;
branches;
next	8.10;

8.10
date	89.01.25.05.41.57;	author mike;	state Exp;
branches;
next	8.9;

8.9
date	89.01.25.04.08.12;	author mike;	state Exp;
branches;
next	8.8;

8.8
date	89.01.25.01.44.22;	author mike;	state Exp;
branches;
next	8.7;

8.7
date	89.01.25.01.33.57;	author mike;	state Exp;
branches;
next	8.6;

8.6
date	89.01.20.06.46.37;	author mike;	state Exp;
branches;
next	8.5;

8.5
date	89.01.20.06.15.42;	author mike;	state Exp;
branches;
next	8.4;

8.4
date	89.01.20.04.35.54;	author mike;	state Exp;
branches;
next	8.3;

8.3
date	89.01.20.03.17.22;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	89.01.20.01.24.46;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.33.56;	author mike;	state Rel3_0;
branches;
next	1.19;

1.19
date	88.09.17.07.05.36;	author mike;	state Exp;
branches;
next	1.18;

1.18
date	88.03.02.04.11.40;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	87.11.02.15.44.35;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	87.08.10.07.11.22;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	87.08.10.02.19.18;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	87.04.10.08.11.48;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	86.10.29.02.23.00;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	86.10.27.22.22.03;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	86.10.27.04.18.55;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	86.10.27.01.06.59;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	86.10.27.00.57.27;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	86.10.26.23.43.16;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	86.10.26.22.26.58;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	86.10.26.20.14.53;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	86.10.26.19.50.56;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	86.10.26.18.56.16;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	86.10.26.16.12.31;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	86.07.30.03.49.23;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	86.07.22.04.58.59;	author mike;	state Exp;
branches;
next	;

11.21.2.1
date	2001.07.11.12.32.08;	author jra;	state Exp;
branches;
next	;

11.34.2.1
date	2002.09.19.18.02.14;	author morrison;	state Exp;
branches;
next	11.34.2.2;

11.34.2.2
date	2003.02.14.19.35.21;	author morrison;	state Exp;
branches;
next	11.34.2.3;

11.34.2.3
date	2004.03.17.21.22.56;	author morrison;	state Exp;
branches;
next	;

11.34.4.1
date	2004.03.11.23.48.00;	author morrison;	state Exp;
branches;
next	;

11.35.2.1
date	2004.01.02.16.16.03;	author erikg;	state Exp;
branches;
next	11.35.2.2;

11.35.2.2
date	2004.02.12.19.40.28;	author erikg;	state Exp;
branches;
next	11.35.2.3;

11.35.2.3
date	2004.03.15.14.08.06;	author erikg;	state Exp;
branches;
next	;


desc
@Control program for distributed ray tracing
@


11.39
log
@moved to src/remrt/
@
text
@/*
 *  			R E M R T . C
 *  
 *  Controller for network ray-tracing
 *  Operating as both a network client and server,
 *  starts remote invocations of "rtsrv" via "rsh", then
 *  handles incomming connections offering cycles,
 *  accepting input (solicited and unsolicited) via the pkg.c routines,
 *  and storing the results in files and/or a framebuffer.
 *
 *  Author -
 *	Michael John Muuss
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1989-2004 by the United States Army.
 *	All rights reserved.
 */
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/remrt/remrt.c,v 11.38 2004/05/10 15:30:49 erikg Exp $ (BRL)";

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <ctype.h>
#include <signal.h>
#include <errno.h>
#include <math.h>

#include <netdb.h>

#ifdef USE_STRING_H
# include <string.h>
#else
# include <strings.h>
#endif

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <netinet/in.h>


/*
 *  The situation with sys/time.h and time.h is crazy.
 *  We need sys/time.h for struct timeval,
 *  and time.h for struct tm.
 *
 *  on BSD (and SGI 4D), sys/time.h includes time.h,
 *  on the XMP (UNICOS 3 & 4), time.h includes sys/time.h,
 *  on the Cray-2, there is no automatic including.
 *
 *  Note that on many SYSV machines, the Cakefile has to set BSD
 */
#if BSD && !SYSV
#  include <time.h>
#  include <sys/time.h>		/* sometimes includes <time.h> */
#else
#  if CRAY1 && !__STDC__
#	include <time.h>	/* includes <sys/time.h> */
#  else
#	include <sys/time.h>
#	include <time.h>
#  endif
#endif

#include "machine.h"
#include "externs.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "raytrace.h"
#include "fb.h"
#include "pkg.h"
#include "rtprivate.h"
#include "../librt/debug.h"

#include "./protocol.h"
#include "./ihost.h"

#ifndef HAVE_VFORK
# define vfork	fork
#endif

/* Needed to satisfy the reference created by including ../rt/opt.o */
struct command_tab rt_cmdtab[] = {
	{(char *)0, (char *)0, (char *)0,
		0,		0, 0}	/* END */
};

struct frame {
	struct frame	*fr_forw;
	struct frame	*fr_back;
	int		fr_magic;	/* magic number */
	long		fr_number;	/* frame number */
	long		fr_server;	/* server number assigned. */
	char		*fr_filename;	/* name of output file */
	int		fr_tempfile;	/* if !0, output file is temporary */
	/* options */
	int		fr_width;	/* frame width (pixels) */
	int		fr_height;	/* frame height (pixels) */
	struct bu_list	fr_todo;	/* work still to be done */
	/* Timings */
	struct timeval	fr_start;	/* start time */
	struct timeval	fr_end;		/* end time */
	long		fr_nrays;	/* rays fired so far */
	double		fr_cpu;		/* CPU seconds used so far */
	/* Current view */
	struct bu_vls	fr_cmd;		/* RT options & command string */
	int		fr_needgettree; /* Do we need a gettree message */
	struct bu_vls	fr_after_cmd;	/* local commands, after frame done */
};

/*
 *  In order to preserve asynchrony, each server is marched through
 *  a series of state transitions.
 *  Each transition is triggered by some event being satisfied.
 *  The valid state transition sequences are:
 *
 *  If a "transient" server shows up, just to send in one command:
 *
 *	Original	New		Event
 *	--------	-----		-----
 *	UNUSED		NEW		connection rcvd
 *	NEW		CLOSING		ph_cmd pkg rcvd.
 *	CLOSING		UNUSED		next schedule() pass closes conn.
 *
 *  If a "permanent" server shows up:
 *
 *	Original	New		Event
 *	--------	-----		-----
 *	UNUSED		NEW		connection rcvd
 *	NEW		VERSOK		ph_version pkg rcvd.
 *					Optionally send loglvl & "cd" cmds.
 *	VERSOK		DOING_DIRBUILD	MSG_DIRBUILD sent
 *	DOING_DIRBUILD	READY		MSG_DIRBUILD_REPLY rcvd
 *
 * --	READY		DOING_GETTREES	new frame:  send_gettrees(), send_matrix()
 *	DOING_GETTREES	READY		MSG_GETTREES_REPLY rcvd
 *
 * --	READY		READY		call send_do_lines(),
 *					receive ph_pixels pkg.
 *
 * --	READY		CLOSING		drop_server called.  Requeue work.
 *	CLOSING		UNUSED		next schedule() pass closes conn.
 *
 * XXX need to split sending of db name & the treetops.
 * XXX treetops need to be resent at start of each frame.
 * XXX should probably re-vamp send_matrix routine.
 */
#define NFD 32
#ifdef FD_SETSIZE
#define MAXSERVERS	FD_SETSIZE
#else
#define MAXSERVERS	NFD		/* No relay function yet */
#endif


struct servers {
	struct pkg_conn	*sr_pc;		/* PKC_NULL means slot not in use */
	struct bu_list	sr_work;
	struct ihost	*sr_host;	/* description of this host */
	int		sr_lump;	/* # lines to send at once */
	int		sr_state;	/* Server state, SRST_xxx */
#define SRST_UNUSED		0	/* unused slot */
#define SRST_NEW		1	/* connected, awaiting vers check */
#define SRST_VERSOK		2	/* version OK, no model loaded yet */
#define SRST_DOING_DIRBUILD	3	/* doing dirbuild, awaiting response */
#define SRST_NEED_TREE		4	/* need our first gettree */
#define SRST_READY		5	/* loaded, ready */
#define SRST_RESTART		6	/* about to restart */
#define SRST_CLOSING		7	/* Needs to be closed */
#define SRST_DOING_GETTREES	8	/* doing gettrees */
	struct frame	*sr_curframe;	/* ptr to current frame */
	/* Timings */
	struct timeval	sr_sendtime;	/* time of last sending */
	double		sr_l_elapsed;	/* last: elapsed_sec */
	double		sr_l_el_rate;	/* last: pix/elapsed_sec */
	double		sr_w_elapsed;	/* weighted avg: pix/elapsed_sec */
	double		sr_w_rays;	/* weighted avg: rays/elapsed_sec */
	double		sr_s_elapsed;	/* sum of pix/elapsed_sec */
	double		sr_sq_elapsed;	/* sum of pix/elapsed_sec squared */
	double		sr_l_cpu;	/* cpu_sec for last scanline */
	double		sr_s_cpu;	/* sum of all cpu times */
	double		sr_s_pix;	/* sum of all pixels */
	double		sr_s_e;		/* sum of all elapsed seconds */
	double		sr_s_sq_cpu;	/* sum of cpu times squared */
	double		sr_s_sq_pix;	/* sum of pixels squared */
	double		sr_s_sq_e;	/* sum of all elapsed seceonds squared */
	int		sr_nsamp;	/* number of samples summed over */
	double		sr_prep_cpu;	/* sum of cpu time for preps */
	double		sr_l_percent;	/* last: percent of CPU */
} servers[MAXSERVERS];

void		read_rc_file(void);
void		check_input(int waittime);
void		addclient(struct pkg_conn *pc);
void		start_servers(struct timeval *nowp);
void		eat_script(FILE *fp);
void		interactive_cmd(FILE *fp);
void		prep_frame(register struct frame *fr);
void		frame_is_done(register struct frame *fr);
void		destroy_frame(register struct frame *fr);
void		schedule(struct timeval *nowp);
void		list_remove(register struct bu_list *lhp, int a, int b);
void		write_fb(unsigned char *pp, struct frame *fr, int a, int b);
void		repaint_fb(register struct frame *fr);
void		size_display(register struct frame *fr);
void		send_dirbuild(register struct servers *sp);
void		send_gettrees(struct servers *sp, register struct frame *fr);
void		send_restart(register struct servers *sp);
void		send_loglvl(register struct servers *sp);
void		send_matrix(struct servers *sp, register struct frame *fr);
void		send_to_lines();
void		pr_list(register struct bu_list *lhp);
void		mathtab_constant(void);
void		add_host(struct ihost *ihp);
void		host_helper(FILE *fp);
void		start_helper(void);
void		build_start_cmd(int argc, char **argv, int startc);
void		drop_server(register struct servers *sp, char *why);
void		send_do_lines(register struct servers *sp, int start, int stop, int framenum);
void		do_work(int auto_start);
void		source(FILE *fp);


FBIO *fbp = FBIO_NULL;		/* Current framebuffer ptr */
int cur_fbwidth;		/* current fb width */
int fbwidth;			/* fb width  - S command */
int fbheight;			/* fb height - S command */

int running = 0;		/* actually working on it */
int detached = 0;		/* continue after EOF */

/*
 * Package Handlers.
 */
void	ph_default(register struct pkg_conn *pc, char *buf);	/* foobar message handler */
void	ph_pixels(register struct pkg_conn *pc, char *buf);
void	ph_print(register struct pkg_conn *pc, char *buf);
void	ph_dirbuild_reply(register struct pkg_conn *pc, char *buf);
void	ph_gettrees_reply(register struct pkg_conn *pc, char *buf);
void	ph_version(register struct pkg_conn *pc, char *buf);
void	ph_cmd(register struct pkg_conn *pc, char *buf);
struct pkg_switch pkgswitch[] = {
	{ MSG_DIRBUILD_REPLY,	ph_dirbuild_reply,	"Dirbuild ACK" },
	{ MSG_GETTREES_REPLY,	ph_gettrees_reply,	"gettrees ACK" },
	{ MSG_MATRIX,	ph_default,	"Set Matrix" },
	{ MSG_LINES,	ph_default,	"Compute lines" },
	{ MSG_END,	ph_default,	"End" },
	{ MSG_PIXELS,	ph_pixels,	"Pixels" },
	{ MSG_PRINT,	ph_print,	"Log Message" },
	{ MSG_VERSION,	ph_version,	"Protocol version check" },
	{ MSG_CMD,	ph_cmd,		"Run one command" },
	{ 0,		0,		(char *)0 }
};

fd_set clients;
int print_on = 1;
char *frame_script = NULL;

int save_overlaps=0;

/* -- */

/*
 *			L I S T
 *
 *  Macros to manage lists of pixel spans.
 *  The span is inclusive, from start up to and including stop.
 */
struct list {
	struct bu_list	l;
	struct frame	*li_frame;
	int		li_start;
	int		li_stop;
};

struct bu_list 		FreeList;

#define LIST_NULL	((struct list*)0)
#define LIST_MAGIC	0x4c494c49

#define GET_LIST(p)	if( BU_LIST_IS_EMPTY( &FreeList ) )  { \
				BU_GETSTRUCT((p), list); \
				(p)->l.magic = LIST_MAGIC; \
			} else { \
				(p) = BU_LIST_FIRST(list, &FreeList); \
				BU_LIST_DEQUEUE(&(p)->l); \
			}

#define FREE_LIST(p)	{ BU_LIST_APPEND( &FreeList, &(p)->l ); }

/* -- */

struct frame FrameHead;
struct frame *FreeFrame;
#define FRAME_NULL	((struct frame *)0)
#define FRAME_MAGIC	0xbafe12ce

#define CHECK_FRAME(_p)	CHECK_IT(_p, fr_magic, FRAME_MAGIC, "frame pointer")

#define CHECK_IT(_q,_el,_magic,_str)	\
	if( !(_q) )  { \
		bu_log("NULL %s in %s line %d\n", _str, __FILE__, __LINE__ ); \
		abort(); \
	} else if( (_q)->_el != _magic )  { \
		bu_log("ERROR %s=x%x magic was=x%x s/b=x%x in %s line %d\n", \
			_str, (_q), (_q)->_el, _magic, __FILE__, __LINE__ ); \
		abort(); \
	}


/*
 *  Macros to manage lists of frames
 */

#define GET_FRAME(p)	{ \
		if( ((p)=FreeFrame) == FRAME_NULL ) {\
			BU_GETSTRUCT(p, frame); \
		} else { \
			FreeFrame = (p)->fr_forw; (p)->fr_forw = FRAME_NULL; \
		} \
		memset( (char *)(p), 0, sizeof(struct frame) ); \
		(p)->fr_magic = FRAME_MAGIC; \
		bu_vls_init( &(p)->fr_cmd ); \
		bu_vls_init( &(p)->fr_after_cmd ); \
	}
#define FREE_FRAME(p)	{ \
	bu_vls_free( &(p)->fr_cmd ); \
	bu_vls_free( &(p)->fr_after_cmd ); \
	(p)->fr_forw = FreeFrame; FreeFrame = (p); }

/* Insert "new" partition in front of "old" frame element */
#define INSERT_FRAME(new,old)	{ \
	(new)->fr_back = (old)->fr_back; \
	(old)->fr_back = (new); \
	(new)->fr_forw = (old); \
	(new)->fr_back->fr_forw = (new);  }

/* Append "new" partition after "old" frame element */
#define APPEND_FRAME(new,old)	{ \
	(new)->fr_forw = (old)->fr_forw; \
	(new)->fr_back = (old); \
	(old)->fr_forw = (new); \
	(new)->fr_forw->fr_back = (new);  }

/* Dequeue "cur" frame element from doubly-linked list */
#define DEQUEUE_FRAME(cur)	{ \
	(cur)->fr_forw->fr_back = (cur)->fr_back; \
	(cur)->fr_back->fr_forw = (cur)->fr_forw;  }

/* --- */
#define SERVERS_NULL	((struct servers *)0)

/* variables shared with viewing model */
extern double	AmbientIntensity;
extern double	azimuth, elevation;
extern int	lightmodel;
int		use_air = 0;

/* variables shared with worker() */
extern int	hypersample;
extern unsigned int	jitter;
extern fastf_t	rt_perspective;
extern fastf_t	aspect;
extern fastf_t	eye_backoff;
extern int	width;
extern int	height;

/* variables shared with do.c */
extern int	matflag;
extern int	interactive;
extern int	benchmark;
int		rt_verbosity = -1;
extern char	*outputfile;		/* output file name */
extern int	desiredframe;
extern int	finalframe;

extern fastf_t	rt_dist_tol;		/* Value for rti_tol.dist */
extern fastf_t	rt_perp_tol;		/* Value for rti_tol.perp */
extern char	*framebuffer;

extern struct rt_g	rt_g;

extern struct command_tab cmd_tab[];	/* given at end */

char	file_basename[128];	/* contains last component of file name */
char	file_fullname[128];	/* contains full file name */
char	object_list[512];	/* contains list of "MGED" objects */

FILE	*helper_fp;		/* pipe to rexec helper process */

char		*our_hostname;

int	tcp_listen_fd;
extern int	pkg_permport;	/* libpkg/pkg_permserver() listen port */

int		rem_debug;		/* dispatcher debugging flag */

extern int	version[];	/* From vers.c */
#define	OPT_FRAME	0	/* Free for all */
#define OPT_LOAD	1	/* 10% per server per frame */
#define OPT_MOVIE	2	/* one server per frame */
int	work_allocate_method = OPT_MOVIE;
char *allocate_method[] = {
	"Frame",
	"Load Avaraging",
	"One per Frame"};


int init_fb(char *name);
int create_outputfilename( struct frame *fr );
int cd_frames( int argc, char **argv );
int cd_stat( int argc, char **argv );
int is_hackers_night( struct timeval *tv );
int is_night( struct timeval *tv );
int task_server( struct servers *sp, struct frame *fr, struct timeval *nowp );
int server_q_len( struct servers *sp );
int cd_stop( int argc, char **argv );


/*
 *			T V S U B
 */
void
tvsub(struct timeval *tdiff, struct timeval *t1, struct timeval *t0)
{

	tdiff->tv_sec = t1->tv_sec - t0->tv_sec;
	tdiff->tv_usec = t1->tv_usec - t0->tv_usec;
	if (tdiff->tv_usec < 0)
		tdiff->tv_sec--, tdiff->tv_usec += 1000000;
}

/*
 *			T V D I F F
 *
 *  Return t1 - t0, as a floating-point number of seconds.
 */
double
tvdiff(struct timeval *t1, struct timeval *t0)
{
	return( (t1->tv_sec - t0->tv_sec) +
		(t1->tv_usec - t0->tv_usec) / 1000000. );
}

/*
 *			S T A M P
 *
 *  Return a string suitable for use as a timestamp.
 *  Mostly for stamping log messages with.
 */
char *
stamp(void)
{
	static char	buf[128];
	time_t		now;
	struct tm	*tmp;

	(void)time( &now );
	tmp = localtime( &now );
	sprintf( buf, "%2.2d/%2.2d %2.2d:%2.2d:%2.2d",
		tmp->tm_mon+1, tmp->tm_mday,
		tmp->tm_hour, tmp->tm_min, tmp->tm_sec );

	return(buf);
}

/*
 *			S T A T E _ T O _ S T R I N G
 *
 *  Return a pointer to a string, generally less than 8 bytes,
 *  that describes this state.
 */
char *
state_to_string(int state)
{
	static char	buf[128];

	switch( state )  {
	case SRST_UNUSED:
		return "[unused]";
	case SRST_NEW:
		return("..New..");
	case SRST_VERSOK:
		return("Vers_OK");
	case SRST_DOING_DIRBUILD:
		return("DoDirbld");
	case SRST_NEED_TREE:
		return("NeedTree");
	case SRST_READY:
		return(" Ready");
	case SRST_RESTART:
		return("Restart");
	case SRST_CLOSING:
		return("Closing");
	case SRST_DOING_GETTREES:
		return("GetTrees");
	}
	sprintf(buf, "UNKNOWN_x%x", state);
	return(buf);
}

/*
 *			S T A T E C H A N G E
 */
void
statechange(register struct servers *sp, int newstate)
{
	if( rem_debug )  {
		bu_log("%s %s %s --> %s\n",
			stamp(),
			sp->sr_host->ht_name,
			state_to_string(sp->sr_state),
			state_to_string(newstate) );
	}
	sp->sr_state = newstate;
}

/*
 *			M A I N
 */
int
main(int argc, char **argv)
{
	register struct servers *sp;
	register int i, done;

	/* Random inits */
	our_hostname = get_our_hostname();
	fprintf(stderr,"%s %s %s\n", stamp(), our_hostname, (char *)(version+5) );
	fflush(stderr);

	width = height = 512;			/* same size as RT */

	start_helper();

	BU_LIST_INIT( &FreeList );
	FrameHead.fr_forw = FrameHead.fr_back = &FrameHead;
	for( sp = &servers[0]; sp < &servers[MAXSERVERS]; sp++ )  {
		BU_LIST_INIT( &sp->sr_work );
		sp->sr_pc = PKC_NULL;
		sp->sr_curframe = FRAME_NULL;
	}

	/* Listen for our PKG connections */
	if( (tcp_listen_fd = pkg_permserver("rtsrv", "tcp", 8, bu_log)) < 0 )  {
		int	i;
		char	num[8];
		/* Do it by the numbers */
		for(i=0; i<10; i++ )  {
			sprintf( num, "%d", 4446+i );
			if( (tcp_listen_fd = pkg_permserver(num, "tcp", 8, bu_log)) < 0 )
				continue;
			break;
		}
		if( i >= 10 )  {
			bu_log("Unable to find a port to listen on\n");
			exit(1);
		}
	}
	/* Now, pkg_permport has tcp port number */

	(void)signal( SIGPIPE, SIG_IGN );

	if( argc <= 1 )  {
		(void)signal( SIGINT, SIG_IGN );
		bu_log("%s Interactive REMRT on %s\n", stamp(), our_hostname );
		bu_log("%s Listening at port %d\n", stamp(), pkg_permport);
		FD_ZERO(&clients);
		FD_SET(fileno(stdin), &clients);

		/* Read .remrtrc file to acquire server info */
		read_rc_file();

		/* Go until no more clients */
/* Aargh.  We really need a FD_ISZERO macro. */
		for( i = 0, done = 1; i < FD_SETSIZE; i++)
			if (FD_ISSET(i, &clients)) { done = 0; break; }
		while( !done ) {
			for( i = 0, done = 1; i < FD_SETSIZE; i++)
				if (FD_ISSET(i, &clients)) { done = 0; break; }
			do_work(0);	/* no auto starting of servers */
		}
		/*
		 * Might want to see if any work remains, and if so,
		 * record it somewhere
		 */
		bu_log("%s Out of clients\n", stamp());
	} else {
		bu_log("%s Automatic REMRT on %s\n", stamp(), our_hostname );
		bu_log("%s Listening at port %d, reading script on stdin\n",
			stamp(), pkg_permport);
		FD_ZERO(&clients);

		/* parse command line args for sizes, etc */
		finalframe = -1;
		if( !get_args( argc, argv ) )  {
			fprintf(stderr,"remrt:  bad arg list\n");
			exit(1);
		}
		if (interactive) work_allocate_method = OPT_FRAME;

		/* take note of database name and treetops */
		if( bu_optind+2 > argc )  {
			fprintf(stderr,"remrt:  insufficient args\n");
			exit(2);
		}
		build_start_cmd( argc, argv, bu_optind );

		/* Read .remrtrc file to acquire servers */
		read_rc_file();

		/* Collect up results of arg parsing */
		/* automatic: outputfile, width, height */
		if( framebuffer || outputfile == (char *)0 )  {
			init_fb(framebuffer);
		}

		/* Build queue of work to be done */
		if( !matflag )  {
			struct frame	*fr;
			char	buf[128];
			/* if not -M, queue off single az/el frame */
			GET_FRAME(fr);
			prep_frame(fr);
			sprintf(buf, "ae %g %g;", azimuth, elevation);
			bu_vls_strcat( &fr->fr_cmd, buf);
			if( create_outputfilename( fr ) < 0 )  {
				FREE_FRAME(fr);
			} else {
				APPEND_FRAME( fr, FrameHead.fr_back );
			}
		} else {
			/* if -M, read RT script from stdin */
			FD_ZERO(&clients);
			eat_script( stdin );
		}
		if(rem_debug>1) cd_frames( 0, (char **)0 );

		/* Compute until no work remains */
		running = 1;
		do_work(1);		/* auto start servers */
		bu_log("%s Task accomplished\n", stamp() );
	}
	return(0);			/* exit(0); */
}

/*
 *			D O _ W O R K
 */
void
do_work(int auto_start)
{
	struct timeval	now;
	int		prev_serv;	/* previous # of connected servers */
	int		cur_serv;	/* current # of connected servers */
	register struct servers	*sp;

	/* Compute until no work remains */
	prev_serv = 0;

	if( FrameHead.fr_forw == &FrameHead )  {
		check_input( 30 );	/* delay up to 30 secs */
	}

	while( FrameHead.fr_forw != &FrameHead )  {
		if( auto_start )  {
			(void)gettimeofday( &now, (struct timezone *)0 );
			start_servers( &now );
		} else {
/* Aargh.  We really need a FD_ISZERO macro. */
			int done, i;
			for( i = 0, done = 1; i < FD_SETSIZE; i++)
				if (FD_ISSET(i, &clients)) { done = 0; break; }
			if (done) break;
		}

		check_input( 30 );	/* delay up to 30 secs */

		(void)gettimeofday( &now, (struct timezone *)0 );
		schedule( &now );

		/* Count servers */
		cur_serv = 0;
		for( sp = &servers[0]; sp < &servers[MAXSERVERS]; sp++ )  {
			if( sp->sr_pc == PKC_NULL )  continue;
			cur_serv++;
		}
		if( cur_serv == 0 && prev_serv > cur_serv )  {
			bu_log("%s *** All servers down\n", stamp() );
			fflush(stdout);
		}
		prev_serv = cur_serv;
	}
}

/*
 *			R E A D _ R C _ F I L E
 *
 *  Read a .remrt file.  While this file can contain any valid commands,
 *  the intention is primarily to permit "automatic" registration of
 *  server hosts via "host" commands.
 */
void
read_rc_file(void)
{
	FILE	*fp;
	char	*home;
	char	path[128];

	if( (fp = fopen(".remrtrc", "r")) != NULL )  {
		source(fp);
		fclose(fp);
		return;
	}

	if( (home = getenv("HOME")) != NULL )  {
		sprintf( path, "%s/.remrtrc", home );
		if( (fp = fopen( path, "r" )) != NULL )  {
			source(fp);
			fclose(fp);
			return;
		}
	}
}

/*
 *			C H E C K _ I N P U T
 */
void
check_input(int waittime)
{
	static fd_set	ifdset;
	register int	i;
	register struct pkg_conn *pc;
	static struct timeval tv;
	register int	val;

	/* First, handle any packages waiting in internal buffers */
	for( i=0; i<MAXSERVERS; i++ )  {
		pc = servers[i].sr_pc;
		if( pc == PKC_NULL )  continue;
		if( (val = pkg_process(pc)) < 0 )
			drop_server( &servers[i], "pkg_process() error" );
	}

	/* Second, hang in select() waiting for something to happen */
	tv.tv_sec = waittime;
	tv.tv_usec = 0;

	FD_MOVE(&ifdset, &clients);	/* ibits = clients */
	FD_SET(tcp_listen_fd, &ifdset);	/* ibits |= tcp_listen_fd */
	val = select(32, &ifdset, (fd_set *)0, (fd_set *)0, &tv);
	if( val < 0 )  {
		perror("select");
		return;
	}
	if( val==0 )  {
		/* At this point, ibits==0 */
		if(rem_debug>1) bu_log("%s select timed out after %d seconds\n", stamp(), waittime);
		return;
	}

	/* Third, accept any pending connections */
	if( FD_ISSET(tcp_listen_fd, &ifdset) )  {
		pc = pkg_getclient(tcp_listen_fd, pkgswitch, bu_log, 1);
		if( pc != PKC_NULL && pc != PKC_ERROR )
			addclient(pc);
		FD_CLR( tcp_listen_fd, &ifdset );
	}

	/* Fourth, get any new traffic off the network into libpkg buffers */
	for( i=0; i<MAXSERVERS; i++ )  {
		register struct pkg_conn *pc;

		if( !feof(stdin) && i == fileno(stdin) )  continue;
		if( !FD_ISSET(i, &ifdset) )  continue;
		pc = servers[i].sr_pc;
		if( pc == PKC_NULL )  continue;
		val = pkg_suckin(pc);
		if( val < 0 ) {
			drop_server( &servers[i], "pkg_suckin() error" );
		} else if( val == 0 )  {
			drop_server( &servers[i], "EOF" );
		}
		FD_CLR( i, &ifdset );
	}

	/* Fifth, handle any new packages now waiting in internal buffers */
	for( i=0; i<MAXSERVERS; i++ )  {
		pc = servers[i].sr_pc;
		if( pc == PKC_NULL )  continue;
		if( pkg_process(pc) < 0 )
			drop_server( &servers[i], "pkg_process() error" );
	}

	/* Finally, handle any command input (This can recurse via "read") */
	if( waittime>0 &&
	    !feof(stdin) &&
	    FD_ISSET( fileno(stdin), &ifdset ) )  {
		interactive_cmd(stdin);
	}
}

/*
 *			A D D C L I E N T
 */
void
addclient(struct pkg_conn *pc)
{
	register struct servers *sp;
	register struct frame	*fr;
	struct ihost	*ihp;
	int		on = 1;
	auto int	fromlen;
	struct sockaddr_in from;
	int fd;

	fd = pc->pkc_fd;

	fromlen = sizeof (from);

	if (getpeername(fd, (struct sockaddr *)&from, &fromlen) < 0) {
		perror("getpeername");
		close(fd);
		return;
	}
	if (setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, (const char *)&on, sizeof (on)) < 0)
		perror("setsockopt (SO_KEEPALIVE)");

	if( (ihp = host_lookup_by_addr( &from, 1 )) == IHOST_NULL )  {
		/* Disaster */
		bu_log("abandoning this unknown server!!\n");
		close( fd );
		/* Maybe free the pkg struct? */
		return;
	}
	if( rem_debug )  bu_log("%s addclient(%s)\n", stamp(), ihp->ht_name);

	FD_SET( fd, &clients );

	sp = &servers[fd];
	memset( (char *)sp, 0, sizeof(*sp) );
	sp->sr_pc = pc;
	BU_LIST_INIT( &sp->sr_work );
	sp->sr_curframe = FRAME_NULL;
	sp->sr_lump = 32;
	sp->sr_host = ihp;
	statechange(sp, SRST_NEW);

	/* Clear any frame state that may remain from an earlier server */
	for( fr = FrameHead.fr_forw; fr != &FrameHead; fr = fr->fr_forw)  {
		CHECK_FRAME(fr);
	}
}

/*
 *			D R O P _ S E R V E R
 *
 *  Note that final connection closeout is handled in schedule(),
 *  to prevent recursion problems.
 */
void
drop_server(register struct servers *sp, char *why)
{
	register struct list	*lp;
	register struct pkg_conn *pc;
	register struct frame	*fr;
	int fd;
	int	oldstate;

	if( sp == SERVERS_NULL || sp->sr_host == IHOST_NULL )  {
		bu_log("drop_server(x%x), sr_host=0\n", sp);
		return;
	}
	oldstate = sp->sr_state;
	statechange(sp, SRST_CLOSING);
	sp->sr_curframe = FRAME_NULL;

	/* Only remark on servers that got out of "NEW" state.
	 * This keeps the one-shot commands from blathering here.
	 */
	if( oldstate != SRST_NEW )  {
		bu_log("%s dropping %s (%s)\n",
			 stamp(), sp->sr_host->ht_name, why);
	}

	pc = sp->sr_pc;
	if( pc == PKC_NULL )  {
		bu_log("drop_server(x%x), sr_pc=0\n", sp);
		return;
	}

	/* Clear the bits from "clients" now, to prevent further select()s */
	fd = pc->pkc_fd;
	if( fd <= 3 || fd >= MAXSERVERS )  {
		bu_log("drop_server: fd=%d is unreasonable, forget it!\n", fd);
		return;
	}
	FD_CLR(sp->sr_pc->pkc_fd, &clients);

	if( oldstate != SRST_READY && oldstate != SRST_NEED_TREE )  return;

	/* Need to requeue any work that was in progress */
	while( BU_LIST_WHILE( lp, list, &sp->sr_work ) )  {
		fr = lp->li_frame;
		CHECK_FRAME(fr);
		BU_LIST_DEQUEUE( &lp->l );
		bu_log("%s requeueing fr%d %d..%d\n",
			stamp(),
			fr->fr_number,
			lp->li_start, lp->li_stop);
		/* Stick it at the head */
		BU_LIST_APPEND( &fr->fr_todo, &lp->l );
	}
}

/*
 *			S T A R T _ S E R V E R S
 *
 *  Scan the ihost table.  For all eligible hosts that don't
 *  presently have a server running, try to start a server.
 */
#define SERVER_CHECK_INTERVAL	(10*60)		/* seconds */
struct timeval	last_server_check_time;

void
start_servers(struct timeval *nowp)
{
	register struct ihost	*ihp;
	register struct servers	*sp;
	int	hackers_night;
	int	night;
	int	add;

	if( file_fullname[0] == '\0' )  return;

	if( tvdiff( nowp, &last_server_check_time ) < SERVER_CHECK_INTERVAL )
		return;

	/* Before seeking, note current (brief) status */
	cd_stat( 0, (char **)0 );

	bu_log("%s Seeking servers to start\n", stamp() );
	hackers_night = is_hackers_night( nowp );
	night = is_night( nowp );
	for( BU_LIST_FOR( ihp, ihost, &HostHead ) )  {
		CK_IHOST(ihp);

		/* Skip hosts which are not eligible for add/drop */
		add = 1;
		switch( ihp->ht_when )  {
		case HT_ALWAYS:
			break;
		case HT_NIGHT:
			if( night )
				add = 1;
			else
				add = 0;
			break;
		case HT_HACKNIGHT:
			if( hackers_night )
				add = 1;
			else
				add = 0;
			break;
		case HT_RS:
			if (ihp->ht_rs_wait-- <= 0) {
				add = 1;
			} else {
				add = 0;
			}
			break;
		default:
		case HT_PASSIVE:
		case HT_PASSRS:
			continue;
		}

		/* See if this host is already in contact as a server */
		for( sp = &servers[0]; sp < &servers[MAXSERVERS]; sp++ )  {
			if( sp->sr_pc == PKC_NULL )  continue;
			if( sp->sr_host != ihp )  continue;

			/* This host is a server */
			if( add == 0 )  {
				/* Drop this host -- out of time range */
				bu_log("%s Auto dropping %s:  out of time range\n",
					stamp(),
					ihp->ht_name );
				drop_server( sp, "outside time-of-day limits for this server" );
			} else {
				/* Host already serving, do nothing more */
			}
			goto next_host;
		}

		/* This host is not presently in contact */
		if( add && !(ihp->ht_flags & HT_HOLD))  {
			bu_log("%s Auto adding %s\n", stamp(), ihp->ht_name);
			add_host( ihp );
		}

next_host:	continue;
	}
	last_server_check_time = *nowp;		/* struct copy */
}

/*
 *			I S _ N I G H T
 *
 *  Indicate whether the given time is "night", ie, off-peak time.
 *  The simple algorithm used here does not take into account
 *  using machines in another time zone, nor is it nice to
 *  machines used by hackers who stay up late.
 */
int
is_night( struct timeval *tv )
{
	struct tm	*tp;
	time_t		sec;

	sec  = tv->tv_sec;

	tp = localtime( &sec );

	/* Sunday(0) and Saturday(6) are "night" */
	if( tp->tm_wday == 0 || tp->tm_wday == 6 )  return(1);
	if( tp->tm_hour < 8 || tp->tm_hour >= 18 )  return(1);
	return(0);
}

/*
 *			I S _ H A C K E R S _ N I G H T
 *
 *  Indicate whether the given time is "night", ie, off-peak time,
 *  for a computer hacker, who stays up late.
 *  The simple algorithm used here does not take into account
 *  using machines in another time zone.
 */
int
is_hackers_night( struct timeval *tv )
{
	struct tm	*tp;
	time_t		sec;

	sec = tv->tv_sec;
	tp = localtime( &sec );

	/* Sunday(0) and Saturday(6) are "night" */
	if( tp->tm_wday == 0 || tp->tm_wday == 6 )  return(1);
	/* Hacking tends to run from 1300 to midnight, and on to 0400 */
	if( tp->tm_hour >= 4 && tp->tm_hour <= 12 )  return(1);
	return(0);
}

/*
 *			E A T _ S C R I P T
 *
 *  The general layout of an RT animation script is:
 *
 *	a once-only prelude that may give viewsize, etc.
 *
 *	the body between start & end commands
 *
 *	a trailer that follows the end command, before the next
 *	start command.  While this *might* include more changes
 *	of viewsize, etc, in actual practice, if it exists at all,
 *	it contains shell escapes, e.g., to compress the frame just
 *	finished.  As such, it should be performed locally, after
 *	the frame is done.
 *
 *  The caller is responsible for fopen()ing and fclose()ing the file.
 */
void
eat_script(FILE *fp)
{
	char		*buf;
	char		*ebuf;
	char		*nsbuf;
	int		argc;
	char		*argv[64];
	struct bu_vls	prelude;
	struct bu_vls	body;
	struct bu_vls	finish;
	int		frame = 0;
	struct frame	*fr;

	bu_log("%s Starting to scan animation script\n", stamp() );

	bu_vls_init( &prelude );
	bu_vls_init( &body );
	bu_vls_init( &finish );

	/* Once only, collect up any prelude */
	while( (buf = rt_read_cmd( fp )) != (char *)0 )  {
		if( strncmp( buf, "start", 5 ) == 0 )  break;

		bu_vls_strcat( &prelude, buf );
		bu_vls_strcat( &prelude, ";" );
		rt_free( buf, "prelude line" );
	}
	if( buf == (char *)0 )  {
		bu_log("unexpected EOF while reading script for first frame 'start'\n");
		bu_vls_free( &prelude );
		return;
	}

	/* A "start" command has been seen, and is saved in buf[] */
	while( !feof(fp) )  {
		int needtree;
		needtree = 0;
		/* Gobble until "end" keyword seen */
		while( (ebuf = rt_read_cmd( fp )) != (char *)0 )  {
			if( strncmp( ebuf, "end", 3 ) == 0 )  {
				rt_free( ebuf, "end line" );
				break;
			}
			if( strncmp( ebuf, "clean", 5 ) == 0 ) {
				needtree=1;
			}
			if( strncmp( ebuf, "tree", 4 ) == 0 ) {
				needtree=1;
			}
			bu_vls_strcat( &body, ebuf );
			bu_vls_strcat( &body, ";" );
			rt_free( ebuf, "script body line" );
		}
		if( ebuf == (char *)0 )  {
			bu_log("unexpected EOF while reading script for frame %d\n", frame);
			break;
		}

		/* Gobble trailer until next "start" keyword seen */
		while( (nsbuf = rt_read_cmd( fp )) != (char *)0 )  {
			if( strncmp( nsbuf, "start", 5 ) == 0 )  {
				break;
			}
			bu_vls_strcat( &finish, nsbuf );
			bu_vls_strcat( &finish, ";" );
			rt_free( nsbuf, "script trailer line" );
		}

		/* buf[] has saved "start" line in it */
		argc = rt_split_cmd( argv, 64, buf );
		if( argc < 2 )  {
			bu_log("bad 'start' line\n");
			rt_free( buf, "bad start line" );
			goto out;
		}
		frame = atoi( argv[1] );
		if( frame < desiredframe )  {
			bu_vls_free( &body );
			goto bad;
		}
		if( finalframe >= 0 && frame > finalframe ) {
			bu_vls_free( &body );
			goto bad;
		}
		/* Might see if frame file exists 444 mode, then skip also */
		GET_FRAME(fr);
		fr->fr_number = frame;
		fr->fr_needgettree = needtree;
		prep_frame(fr);
		bu_vls_vlscat( &fr->fr_cmd, &prelude );
		bu_vls_vlscatzap( &fr->fr_cmd, &body );
		bu_vls_vlscatzap( &fr->fr_after_cmd, &finish );
		if( create_outputfilename( fr ) < 0 )  {
			FREE_FRAME(fr);
		} else {
			APPEND_FRAME( fr, FrameHead.fr_back );
		}
bad:
		rt_free( buf, "command line" );
		buf = nsbuf;
		nsbuf = (char *)0;
	}
out:	
	bu_vls_free( &prelude );
	bu_vls_free( &body );
	bu_vls_free( &finish );

	/* For a few hundred frames, it all can take a little while */
	bu_log("%s Animation script loaded\n", stamp() );
}

/*
 *  			S T R I N G 2 I N T
 *  
 *  Convert a string to an integer.
 *  A leading "0x" implies HEX.
 *  If needed, octal might be done, but it seems unwise...
 *
 *  For general conversion, this is pretty feeble.  Is more needed?
 */
int
string2int(register char *str)
{
	auto int ret;
	int cnt;

	ret = 0;
	if( str[0] == '0' && str[1] == 'x' )
		cnt = sscanf( str+2, "%x", (unsigned int *)&ret );
	else
		cnt = sscanf( str, "%d", &ret );
	if( cnt != 1 )
		bu_log("string2int(%s) = %d?\n", str, ret );
	return(ret);
}

/*
 *			G E T _ S E R V E R _ B Y _ N A M E
 */
struct servers *
get_server_by_name(char *str)
{
	register struct servers *sp;
	struct ihost	*ihp;

	if( isdigit( *str ) )  {
		int	i;
		i = atoi( str );
		if( i < 0 || i >= MAXSERVERS )  return( SERVERS_NULL );
		return( &servers[i] );
	}

	if( (ihp = host_lookup_by_name( str, 0 )) == IHOST_NULL )
		return( SERVERS_NULL );

	for( sp = &servers[0]; sp < &servers[MAXSERVERS]; sp++ )  {
		if( sp->sr_pc == PKC_NULL )  continue;
		if( sp->sr_host == ihp )  return(sp);
	}
	return( SERVERS_NULL );
}

/*
 *			I N T E R A C T I V E _ C M D
 */
void
interactive_cmd(FILE *fp)
{
	char buf[BUFSIZ];
	register char *pos;
	register int i;

	pos = buf;

	/* Get first line */
	*pos = '\0';
	(void)fgets( pos, sizeof(buf), fp );
	i = strlen(buf);

	/* If continued, get more */
	while( pos[i-1]=='\n' && pos[i-2]=='\\' )  {
		pos += i-2;	/* zap NL and backslash */
		*pos = '\0';
		bu_log("-> "); (void)fflush(stderr);
		(void)fgets( pos, sizeof(buf)-strlen(buf), fp );
		i = strlen(pos);
	}

	if( feof(fp) ) {
		register struct servers *sp;

		if( fp != stdin )  return;

		/* Eof on stdin */
		FD_CLR( fileno(fp), &clients );

		/* We might want to wait if something is running? */
		for( sp = &servers[0]; sp < &servers[MAXSERVERS]; sp++ )  {
			if( sp->sr_pc == PKC_NULL )  continue;
			if( !running )
				drop_server(sp, "EOF on Stdin" );
			else
				send_restart(sp);
		}
		/* The rest happens when the connections close */
		return;
	}
	if( (i=strlen(buf)) <= 0 )  return;

	/* Feeble allowance for comments */
	if( buf[0] == '#' )  return;

	(void)rt_do_cmd( (struct rt_i *)0, buf, cmd_tab );
}

/*
 *			P R E P _ F R A M E
 *
 * Fill in frame structure after reading MAT
 *  fr_number must have been set by caller.
 */
void
prep_frame(register struct frame *fr)
{
	register struct list *lp;
	char buf[BUFSIZ];

	CHECK_FRAME(fr);

	/* Get local buffer for image */
	fr->fr_width = width;
	fr->fr_height = height;

	bu_vls_trunc( &fr->fr_cmd, 0 );	/* Start fresh */
	sprintf(buf, "opt -w%d -n%d -H%d -p%g -U%d -J%x -A%g -l%d -E%g -x%x -X%x -T%e/%e",
		fr->fr_width, fr->fr_height,
		hypersample, rt_perspective,
		use_air, jitter,
		AmbientIntensity, lightmodel,
		eye_backoff,
		RT_G_DEBUG, rdebug,
		rt_dist_tol, rt_perp_tol
	);
	bu_vls_strcat( &fr->fr_cmd, buf );
	if( interactive )  bu_vls_strcat( &fr->fr_cmd, " -I");
	if( benchmark )  bu_vls_strcat( &fr->fr_cmd, " -B");
	if( aspect != 1.0 )  {
		sprintf(buf, " -V%g", aspect);
		bu_vls_strcat( &fr->fr_cmd, buf );
	}
	bu_vls_strcat( &fr->fr_cmd, ";" );

	fr->fr_start.tv_sec = fr->fr_end.tv_sec = 0;
	fr->fr_start.tv_usec = fr->fr_end.tv_usec = 0;
	fr->fr_nrays = 0;
	fr->fr_cpu = 0.0;

	/* Build work list */
	BU_LIST_INIT( &fr->fr_todo );
	GET_LIST(lp);
	lp->li_frame = fr;
	lp->li_start = 0;
	lp->li_stop = fr->fr_width*fr->fr_height-1;	/* last pixel # */
	BU_LIST_INSERT( &fr->fr_todo, &lp->l );
}

/*
 *			D O _ A _ F R A M E
 */
void
do_a_frame(void)
{
	register struct frame *fr;
	if( running )  {
		bu_log("already running, please wait or STOP\n");
		return;
	}
	if( file_fullname[0] == '\0' )  {
		bu_log("need LOAD before GO\n");
		return;
	}
	if( (fr = FrameHead.fr_forw) == &FrameHead )  {
		bu_log("No frames to do!\n");
		return;
	}
	CHECK_FRAME(fr);
	running = 1;
}

/*
 *			S C A N _ F R A M E _ F O R _ F I N I S H E D _ P I X E L S
 *
 *  The .pix file for this frame already has some pixels stored in it
 *  from some earlier, aborted run.
 *  view_pixel() is always careful to write (0,0,1) or some other
 *  non-zero tripple in all rendered pixels.
 *  Therefore, if a (0,0,0) tripple is found in the file, it is
 *  part of some span which was not yet rendered.
 *
 *  At the outset, the frame is assumed to be entirely un-rendered.
 *  For each span of rendered pixels discovered, remove them from the
 *  list of work to be done.
 *
 *  Returns -
 *	-1	on file I/O error
 *	 0	on success
 */
int
scan_frame_for_finished_pixels(register struct frame *fr)
{
	register FILE	*fp;
	char		pbuf[8];
	register int	pno;	/* index of next unread pixel */
	int		nspans = 0;
	int		npix = 0;

	CHECK_FRAME(fr);

	bu_log("%s Scanning %s for non-black pixels\n", stamp(),
		fr->fr_filename );
	if( (fp = fopen( fr->fr_filename, "r" )) == NULL )  {
		perror( fr->fr_filename );
		return(-1);
	}

	pno = 0;
	while( !feof( fp ) )  {
		register int	first, last;

		/* Read and skip over any black pixels */
		if( (int)fread( pbuf, 3, 1, fp ) < 1 )  break;
		pno++;
		if( pbuf[0] == 0 && pbuf[1] == 0 && pbuf[2] == 0 )
			continue;

		/*
		 *  Found a non-black pixel at position 'pno-1'.
		 *  See how many more follow,
		 *  and delete the batch of them from the work queue.
		 */
		first = last = pno-1;

		while( !feof( fp ) )  {
			/* Read and skip over non-black pixels */
			if( (int)fread( pbuf, 3, 1, fp ) < 1 )  break;
			pno++;
			if( pbuf[0] == 0 && pbuf[1] == 0 && pbuf[2] == 0 )
				break;		/* black pixel */
			/* non-black */
			last = pno-1;
		}
		bu_log("%s Deleting non-black pixel range %d to %d inclusive\n",
			stamp(),
			first, last );
		list_remove( &(fr->fr_todo), first, last );
		nspans++;
		npix += last-first+1;
	}
	bu_log("%s Scanning %s complete, %d non-black spans, %d non-black pixels\n",
		stamp(), fr->fr_filename, nspans, npix );
	return 0;
}

/*
 *			C R E A T E _ O U T P U T F I L E N A M E
 *
 *  Build and save the file name.
 *  If the file will not be able to be written,
 *  signal error here.
 *
 *  Returns -
 *	-1	error, drop this frame
 *	 0	OK
 */
int
create_outputfilename( struct frame *fr )
{
	char	name[512];
	struct stat	sb;
	int		fd;

	CHECK_FRAME(fr);

	/* Always create a file name to write into */
	if( outputfile )  {
		sprintf( name, "%s.%ld", outputfile, fr->fr_number );
		fr->fr_tempfile = 0;
	} else {
		sprintf( name, "remrt.pix.%ld", fr->fr_number );
		fr->fr_tempfile = 1;
	}
	fr->fr_filename = bu_strdup( name );

	/*
	 *  There are several cases:
	 *	file does not exist, create it
	 *	file exists, is not writable -- skip this frame
	 *	file exists, is writable -- eliminate all non-black pixels
	 *		from work-to-do queue
	 */
	if( access( fr->fr_filename, 0 ) < 0 )  {
		/* File does not yet exist */
		if( (fd = creat( fr->fr_filename, 0644 )) < 0 )  {
			/* Unable to create new file */
			perror( fr->fr_filename );
			return( -1 );		/* skip this frame */
		}
		(void)close(fd);
		return(0);			/* OK */
	}
	/* The file exists */
	if( access( fr->fr_filename, 2 ) < 0 )  {
		/* File exists, and is not writable, skip this frame */
		perror( fr->fr_filename );
		return( -1 );			/* skip this frame */
	}
	/* The file exists and is writable */
	if( stat( fr->fr_filename, &sb ) >= 0 && sb.st_size > 0 )  {
		/* The file has existing contents, dequeue all non-black
		 * pixels.
		 */
		if( scan_frame_for_finished_pixels( fr ) < 0 )
			return -1;
	}
	return(0);				/* OK */
}

/*
 *			F R A M E _ I S _ D O N E
 */
void
frame_is_done(register struct frame *fr)
{
	double	delta;

	CHECK_FRAME(fr);

	(void)gettimeofday( &fr->fr_end, (struct timezone *)0 );
	delta = tvdiff( &fr->fr_end, &fr->fr_start);
	if( delta < 0.0001 )  delta=0.0001;
	bu_log("%s Frame %ld DONE: %g elapsed sec, %d rays/%g cpu sec\n",
		stamp(),
		fr->fr_number,
		delta,
		fr->fr_nrays,
		fr->fr_cpu );
	bu_log("%s  RTFM=%g rays/sec (%g rays/cpu sec)\n",
		stamp(),
		fr->fr_nrays/delta,
		fr->fr_nrays/fr->fr_cpu );

	/* Do any after-frame commands */
	if( bu_vls_strlen( &fr->fr_after_cmd ) > 0 )  {
		bu_log("running after_cmd='%s'\n",
			bu_vls_addr(&fr->fr_after_cmd) );
		(void)rt_do_cmd( (struct rt_i *)0,
			bu_vls_addr(&fr->fr_after_cmd), cmd_tab );
	}

	/* Run global end-of-frame script from 'EOFrame' in .remrtrc file */
	if (frame_script) {
		char *cmd;
		cmd = malloc(strlen(frame_script) + strlen(fr->fr_filename) +
		    20); /* spaces and frame number */
		(void) sprintf(cmd,"%s %s %ld",frame_script,fr->fr_filename,
		    fr->fr_number);
		if(rem_debug) bu_log("%s %s\n", stamp(), cmd);
		(void) system(cmd);
		(void) free(cmd);
	}

	/* Final processing of output file */
	if( fr->fr_tempfile )  {
		/* Unlink temp file -- it is in framebuffer */
		if( unlink( fr->fr_filename ) < 0 )
			perror( fr->fr_filename );
	} else {
		/* Write-protect file, to prevent re-computation */
		if( chmod( fr->fr_filename, 0444 ) < 0 )
			perror( fr->fr_filename );
	}

	/* Forget all about this frame */
	destroy_frame( fr );
}

/*
 *			D E S T R O Y _ F R A M E
 */
void
destroy_frame(register struct frame *fr)
{
	register struct list	*lp;
	register struct servers	*sp;

	CHECK_FRAME(fr);

	/*
	 *  Need to remove any pending work.
	 *  What about work already assigned that will dribble in?
	 */
	while( BU_LIST_WHILE( lp, list, &fr->fr_todo ) )  {
		BU_LIST_DEQUEUE( &lp->l );
		FREE_LIST(lp);
	}

	if( fr->fr_filename )  {
		rt_free( fr->fr_filename, "filename" );
		fr->fr_filename = (char *)0;
	}
	for (sp = &servers[0]; sp<&servers[MAXSERVERS]; sp++) {
		if (sp->sr_pc == PKC_NULL) continue;
		if (sp->sr_curframe == fr) {
			sp->sr_curframe = FRAME_NULL;
		}
	}
	DEQUEUE_FRAME(fr);
	FREE_FRAME(fr);
}

/*
 *			T H I S _ F R A M E _ D O N E
 *
 *  All work on this frame is done when there is no more work to be sent out,
 *  and none of the servers have outstanding assignments for this frame.
 *
 *  Returns -
 *	 0	not done
 *	!0	all done
 */
int
this_frame_done(register struct frame *fr)
{
	register struct servers	*sp;
	register struct list	*lp;

	CHECK_FRAME(fr);

	if( BU_LIST_NON_EMPTY( &fr->fr_todo ) )
		return(1);		/* more work still to be sent */

	for( sp = &servers[0]; sp < &servers[MAXSERVERS]; sp++ )  {
		if( sp->sr_pc == PKC_NULL )  continue;
		for( BU_LIST_FOR( lp, list, &sp->sr_work ) )  {
			if( fr != lp->li_frame )  continue;
			return(0);		/* nope, still more work */
		}
	}
	return(1);			/* All done */
}

/*
 *			A L L _ S E R V E R S _ I D L E
 *
 *  Returns -
 *	!0	All servers are idle
 *	 0	Some servers still busy
 */
int
all_servers_idle(void)
{
	register struct servers	*sp;

	for( sp = &servers[0]; sp < &servers[MAXSERVERS]; sp++ )  {
		if( sp->sr_pc == PKC_NULL )  continue;
		if( sp->sr_state != SRST_READY && 
		    sp->sr_state != SRST_NEED_TREE )  continue;
		if( BU_LIST_IS_EMPTY( &sp->sr_work ) )  continue;
		return(0);		/* nope, still more work */
	}
	return(1);			/* All done */
}

/*
 *			A L L _ D O N E
 *
 *  All work is done when there is no more work to be sent out,
 *  and there is no more work pending in any of the servers.
 *
 *  Returns -
 *	 0	not done
 *	!0	all done
 */
int
all_done(void)
{
	register struct frame	*fr;

	for( fr = FrameHead.fr_forw; fr != &FrameHead; fr = fr->fr_forw)  {
		CHECK_FRAME(fr);
		if( BU_LIST_IS_EMPTY( &fr->fr_todo ) )
			continue;
		return(0);		/* nope, still more work */
	}

	if( all_servers_idle() )
		return(1);		/* All done */

	return(0);			/* nope, still more work */
}

/*
 *			S C H E D U L E
 *
 *  This routine is called by the main loop, after each batch of PKGs
 *  have arrived.
 *
 *  If there is work to do, and a free server, send work.
 *  One assignment will be given to each free server.  If there are
 *  servers that do not have a proper number of assignments (to ensure
 *  good pipelining), then additional passes will be made, untill all
 *  servers have a proper number of assignments.
 *
 *  There could be some difficulties with the linked lists changing
 *  while in an unsolicited pkg receive that happens when a pkg send
 *  operation is performed under here.  scheduler_going flag is
 *  insurance against unintended recursion, which should be enough.
 *
 *  When done, we leave the last finished frame around for attach/release.
 */
void
schedule(struct timeval *nowp)
{
	register struct servers *sp;
	register struct frame *fr;
	register struct frame *fr2;
	int		another_pass;
	int		nxt_frame=0;
	static int	scheduler_going = 0;	/* recursion protection */
	int		ret;

	if( scheduler_going )  {
		/* recursion protection */
		return;
	}
	scheduler_going = 1;

	if( file_fullname[0] == '\0' )  goto out;

	/* Handle various state transitions */
	for( sp = &servers[0]; sp < &servers[MAXSERVERS]; sp++ )  {
		if( sp->sr_pc == PKC_NULL )  continue;

		switch( sp->sr_state )  {
		case SRST_VERSOK:
			/* advance this server to SRST_DOING_DIRBUILD */
			send_loglvl(sp);

			/* An error may have caused connection to drop */
			if( sp->sr_pc != PKC_NULL )
				send_dirbuild(sp);
			break;

		case SRST_CLOSING:
			/* Handle final closing */
			if(rem_debug>1) bu_log("%s Final close on %s\n", stamp(), sp->sr_host->ht_name);
			FD_CLR( sp->sr_pc->pkc_fd, &clients );
			pkg_close(sp->sr_pc);

			sp->sr_pc = PKC_NULL;
			statechange(sp, SRST_UNUSED);
			sp->sr_host = IHOST_NULL;

			break;
		}
	}

	/* Look for finished frames */
	fr = FrameHead.fr_forw;
	while( fr && fr != &FrameHead )  {
		CHECK_FRAME(fr);
		if( BU_LIST_NON_EMPTY( &fr->fr_todo ) )
			goto next_frame;	/* unassigned work remains */

		if( this_frame_done( fr ) )  {
			/* No servers are still working on this frame */
			fr2 = fr->fr_forw;
			frame_is_done( fr );	/* will dequeue */
			fr = fr2;
			continue;
		}
next_frame: ;
		fr = fr->fr_forw;
	}

	if( !running )  goto out;
	if( all_done() )  {
		running = 0;
		bu_log("%s All work done!\n", stamp() );
		if( detached )  exit(0);
		goto out;
	}

	/* Keep assigning work until all servers are fully loaded */
top:
	for( fr = FrameHead.fr_forw; fr != &FrameHead; fr = fr->fr_forw)  {
		CHECK_FRAME(fr);
		nxt_frame=0;
		do {
			another_pass = 0;
			if( BU_LIST_IS_EMPTY( &fr->fr_todo ) )
				break;	/* none waiting here */

			/*
			 *  This loop attempts to make one assignment to
			 *  each of the workers, before looping back to
			 *  make additional assignments.
			 *  This should keep all workers evenly "stoked".
			 */
			for( sp = &servers[0]; sp < &servers[MAXSERVERS]; sp++ )  {
				if( sp->sr_pc == PKC_NULL )  continue;

				if( (ret = task_server(sp,fr,nowp)) < 0 )  {
					/* fr is no longer valid */
					goto top;
				} else if (ret == 2) {
					/* This frame is assigned, move on */
					nxt_frame=1;
					break;
				} else if (ret == 3) {
					/* we have a server that wants to move on */
					nxt_frame = 2;
				} else if( ret > 0 )  {
					another_pass++;
				}
			}
		/* while servers still hungry for work */
		} while( !nxt_frame && another_pass > 0 );
	}
	if (nxt_frame == 1 && work_allocate_method > 0) {
		bu_log("%s Change work allocation method (%s to %s)\n",
		    stamp(), allocate_method[work_allocate_method],
		    allocate_method[work_allocate_method-1]);
		work_allocate_method--;
		goto top;
	}
	/* No work remains to be assigned, or servers are stuffed full */
out:
	scheduler_going = 0;
	return;
}

#define MIN_ASSIGNMENT_TIME	5		/* desired seconds/result */
#define TARDY_SERVER_INTERVAL	(9*60)		/* max seconds of silence */
#define N_SERVER_ASSIGNMENTS	3		/* desired # of assignments */

/*
 *			N U M B E R _ O F _ R E A D Y _ S E R V E R S
 *
 *  Returns the number of servers that are ready (or busy) with
 *  computing frames.
 */
int
number_of_ready_servers(void)
{
	register struct servers	*sp;
	register int		count = 0;

	for( sp = &servers[0]; sp < &servers[MAXSERVERS]; sp++ )  {
		if( sp->sr_pc == PKC_NULL )  continue;
		if( sp->sr_state == SRST_READY ||
		    sp->sr_state == SRST_DOING_GETTREES )
			count++;
	}
	return  count;
}

/*
 *			A S S I G N M E N T _ T I M E
 *
 *  Determine how many seconds of work should be assigned to
 *  a worker, given the current configuration of workers.
 *  One overall goal is to keep the dispatcher (us) from
 *  having to process more than one response every two seconds,
 *  to ensure adequate processing power will be available to
 *  handle the LOG messages, starting new servers, writing
 *  results to the disk and/or framebuffer, etc.
 */
int
assignment_time(void)
{
	int	sec;

	sec = 2 * number_of_ready_servers();
	if( sec < MIN_ASSIGNMENT_TIME )
		return  MIN_ASSIGNMENT_TIME;
	return  sec;
}

/*
 *			T A S K _ S E R V E R
 *
 *  If this server is ready, and has fewer than N_SERVER_ASSIGNMENTS,
 *  dispatch one unit of work to it.
 *  The return code indicates if the server is sated or not.
 *
 *  Returns -
 *	-1	when 'fr' is no longer valid
 *	0	when this server winds up with a full workload
 *	1	when this server needs additional work
 */
int
task_server( struct servers *sp, struct frame *fr, struct timeval *nowp )
{
	register struct list	*lp;
	int			a, b;
	int			lump;
	int			maxlump;

	if( sp->sr_pc == PKC_NULL )  return(0);

	if( sp->sr_state != SRST_READY && sp->sr_state != SRST_NEED_TREE )
		return(0);	/* not running yet */

	CHECK_FRAME(fr);

	/* Sanity check */
	if( fr->fr_filename == (char *)0 ||
	    fr->fr_filename[0] == '\0' )  {
		bu_log("task_server: fr %d: null filename!\n",
			fr->fr_number);
		destroy_frame( fr );	/* will dequeue */
		return(-1);		/* restart scan */
	}

	/*
	 *  Check for tardy server.
	 *  The assignments are estimated to take about MIN_ASSIGNMENT_TIME
	 *  seconds, so waiting many minutes is unreasonable.
	 *  However, if the picture "suddenly" became very complex,
	 *  or a system got very busy,
	 *  the estimate could be quite low.
	 *  This mechanism exists mostly to protect against servers that
	 *  go into "black hole" mode while REMRT is running unattended.
	 */
	if( server_q_len(sp) > 0 &&
	    sp->sr_sendtime.tv_sec > 0 && 
	    tvdiff( nowp, &sp->sr_sendtime ) > TARDY_SERVER_INTERVAL )  {
		bu_log("%s %s: *TARDY*\n", stamp(), sp->sr_host->ht_name);
		drop_server( sp, "tardy" );
		return(0);	/* not worth giving another assignment */
	}

	if( server_q_len(sp) >= N_SERVER_ASSIGNMENTS )
		return(0);	/* plenty busy */

	if( BU_LIST_IS_EMPTY( &fr->fr_todo ) )  {
		/*  No more work to assign in this frame,
		 *  on next pass, caller should advance to next frame.
		 */
		return(1);	/* need more work */
	}

	/*
	 *  Send the server the necessary view information about this frame,
	 *  if the server is not currently working on this frame.
	 *  Note that the "next" frame may be a frame that the server
	 *  has worked on before (perhaps due to work requeued when
	 *  a tardy server was dropped), yet we still must re-send the
	 *  viewpoint.
	 */
	if( sp->sr_curframe != fr )  {
		if (sp->sr_curframe != FRAME_NULL ) return 3;
		if (work_allocate_method==OPT_MOVIE) {
			register struct servers *csp;
			for (csp = &servers[0]; csp < &servers[MAXSERVERS]; csp++ ){
				if (csp->sr_curframe == fr) return 2;
			}
		} else if (work_allocate_method==OPT_LOAD) {
			return 2;	/* need more work */
		}
		sp->sr_curframe = fr;
		send_matrix( sp, fr );
		if (fr->fr_needgettree || sp->sr_state == SRST_NEED_TREE) {
			send_gettrees( sp, fr );
			/* Now in state SRST_DOING_GETTREES */
			return 1;	/* need more work */
		}
	}

	/* Special handling for the first assignment of each frame */
	if( fr->fr_start.tv_sec == 0 )  {
		/* Note when actual work on this frame was started */
		(void)gettimeofday( &fr->fr_start, (struct timezone *)0 );
	}

	/*
	 *  Make this assignment size based on weighted average of
	 *  past behavior.  Using pixels/elapsed_sec metric takes into
	 *  account:
	 *	remote processor speed
	 *	remote processor load
	 *	available network bandwidth & load
	 *	local processing delays
	 */
	/* Base new assignment on desired result rate & measured speed */
	lump = assignment_time() * sp->sr_w_elapsed;

	/* If for an interactive demo, limit assignment to 1 scanline */
	if( interactive && lump > fr->fr_width )  lump = fr->fr_width;

	/* If each frame has a dedicated server, make lumps big */
	if( work_allocate_method == OPT_MOVIE )  {
		lump = fr->fr_width * 2;	/* 2 scanlines at a wack */
	} else {
		/* Limit growth in assignment size to 2X each assignment */
		if( lump > 2*sp->sr_lump )  lump = 2*sp->sr_lump;
	}
	/* Provide some bounds checking */
	if( lump < 32 )  lump = 32;
	else if( lump > REMRT_MAX_PIXELS ) lump = REMRT_MAX_PIXELS;

	/*
	 * Besides the hard limit for lump size, try and keep the 
	 * lump size to 1/32 of the total image.
	 * With the old way, 640x480 = 307200 / (32*1024) = 9.375 or a little
	 * less than 1/9th of the total image.  And it was not uncommon
	 * for the server to be given three lumps that size or 1/3 of the
	 * image. 
	 */
	maxlump = fr->fr_height / 32;
	if (maxlump < 1) maxlump = 1;
	maxlump *= fr->fr_width;
	if (lump > maxlump) lump=maxlump;
	sp->sr_lump = lump;

	lp = BU_LIST_FIRST( list, &fr->fr_todo );
	a = lp->li_start;
	b = a+sp->sr_lump-1;	/* work increment */
	if( b >= lp->li_stop )  {
		b = lp->li_stop;
		sp->sr_lump = b-a+1;	/* Indicate short assignment */
		BU_LIST_DEQUEUE( &lp->l );
		FREE_LIST( lp );
		lp = LIST_NULL;
	} else
		lp->li_start = b+1;

	/* Record newly allocated pixel range */
	GET_LIST(lp);
	lp->li_frame = fr;
	lp->li_start = a;
	lp->li_stop = b;
	BU_LIST_INSERT( &sp->sr_work, &lp->l );
	send_do_lines( sp, a, b, fr->fr_number );

	/* See if server will need more assignments */
	if( server_q_len(sp) < N_SERVER_ASSIGNMENTS )
		return(1);
	return(0);
}

/*
 *			S E R V E R _ Q _ L E N
 *
 *  Report number of assignments that a server has
 */
int
server_q_len( struct servers *sp )
{
	register struct list	*lp;
	register int		count;

	count = 0;
	for( BU_LIST_FOR( lp, list, &sp->sr_work ) )  {
		count++;
	}
	return(count);
}

/*
 *			R E A D _ M A T R I X
 *
 *  Read an old-style matrix.
 *
 *  Returns -
 *	 1	OK
 *	 0	EOF, no matrix read.
 *	-1	error, unable to read matrix.
 */
int
read_matrix(register FILE *fp, register struct frame *fr)
{
	register int i;
	char number[128];
	char	cmd[128];

	CHECK_FRAME(fr);

	/* Visible part is from -1 to +1 in view space */
	if( fscanf( fp, "%s", number ) != 1 )  goto eof;
	sprintf( cmd, "viewsize %s; eye_pt ", number );
	bu_vls_strcat( &(fr->fr_cmd), cmd );

	for( i=0; i<3; i++ )  {
		if( fscanf( fp, "%s", number ) != 1 )  goto out;
		sprintf( cmd, "%s ", number );
		bu_vls_strcat( &fr->fr_cmd, cmd );
	}

	sprintf( cmd, "; viewrot " );
	bu_vls_strcat( &fr->fr_cmd, cmd );

	for( i=0; i < 16; i++ )  {
		if( fscanf( fp, "%s", number ) != 1 )  goto out;
		sprintf( cmd, "%s ", number );
		bu_vls_strcat( &fr->fr_cmd, cmd );
	}
	bu_vls_strcat( &fr->fr_cmd, "; ");

	if( feof(fp) ) {
eof:
		bu_log("read_matrix: EOF on old style frame file.\n");
		return(-1);
	}
	return(0);			/* OK */
out:
	bu_log("read_matrix:  unable to parse old style entry\n");
	return(-1);
}

/*
 *			P H _ D E F A U L T
 */
void
ph_default(register struct pkg_conn *pc, char *buf)
{
	register int i;

	for( i=0; pc->pkc_switch[i].pks_handler != NULL; i++ )  {
		if( pc->pkc_switch[i].pks_type == pc->pkc_type )  break;
	}
	bu_log("ctl: unable to handle %s message: len %d",
		pc->pkc_switch[i].pks_title, pc->pkc_len);
	*buf = '*';
	(void)free(buf);
}

/*
 *			P H _ D I R B U I L D _ R E P L Y
 *
 *  The server answers our MSG_DIRBUILD with various prints, etc,
 *  and then responds with a MSG_DIRBUILD_REPLY in return, which indicates
 *  that he is ready to accept work now.
 */
void
ph_dirbuild_reply(register struct pkg_conn *pc, char *buf)
{
	register struct servers *sp;

	sp = &servers[pc->pkc_fd];
	bu_log("%s %s dirbuild OK (%s)\n",
		stamp(),
		sp->sr_host->ht_name,
		buf );
	if(buf) (void)free(buf);
	if( sp->sr_pc != pc )  {
		bu_log("unexpected MSG_DIRBUILD_REPLY from fd %d\n", pc->pkc_fd);
		return;
	}
	if( sp->sr_state != SRST_DOING_DIRBUILD )  {
		bu_log("MSG_DIRBUILD_REPLY in state %d?\n", sp->sr_state);
		drop_server( sp, "wrong state" );
		return;
	}
	statechange(sp, SRST_NEED_TREE);
}

/*
 *			P H _ G E T T R E E S _ R E P L Y
 *
 *  The server answers our MSG_GETTREES with various prints, etc,
 *  and then responds with a MSG_GETTREES_REPLY in return, which indicates
 *  that he is ready to accept work now.
 */
void
ph_gettrees_reply(register struct pkg_conn *pc, char *buf)
{
	register struct servers *sp;

	sp = &servers[pc->pkc_fd];
	bu_log("%s %s gettrees OK (%s)\n",
		stamp(),
		sp->sr_host->ht_name,
		buf );
	if(buf) (void)free(buf);
	if( sp->sr_pc != pc )  {
		bu_log("unexpected MSG_GETTREES_REPLY from fd %d\n", pc->pkc_fd);
		return;
	}
	if( sp->sr_state != SRST_DOING_GETTREES )  {
		bu_log("MSG_GETTREES_REPLY in state %s?\n",
			state_to_string(sp->sr_state) );
		drop_server( sp, "wrong state" );
		return;
	}
	statechange(sp, SRST_READY);
}

/*
 *			P H _ P R I N T
 */
void
ph_print(register struct pkg_conn *pc, char *buf)
{
	if(print_on)  {
		bu_log("%s %s: %s",
			stamp(),
			servers[pc->pkc_fd].sr_host->ht_name,
			buf );
		if( buf[strlen(buf)-1] != '\n' )
			bu_log("\n");
	}
	if(buf) (void)free(buf);
}

/*
 *			P H _ V E R S I O N
 */
void
ph_version(register struct pkg_conn *pc, char *buf)
{
	register struct servers	*sp;

	sp = &servers[pc->pkc_fd];
	if( strcmp( PROTOCOL_VERSION, buf ) != 0 )  {
		bu_log("ERROR %s: protocol version mis-match\n",
			sp->sr_host->ht_name);
		bu_log("  local='%s'\n", PROTOCOL_VERSION );
		bu_log(" remote='%s'\n", buf );
		drop_server( sp, "version mismatch" );
	} else {
		if( sp->sr_state != SRST_NEW )  {
			bu_log("NOTE %s:  VERSION message unexpected\n",
				sp->sr_host->ht_name);
		}
		statechange(sp, SRST_VERSOK);
	}
	if(buf) (void)free(buf);
}

/*
 *			P H _ C M D
 */
void
ph_cmd(register struct pkg_conn *pc, char *buf)
{
	register struct servers	*sp;

	sp = &servers[pc->pkc_fd];
	bu_log("%s %s: cmd '%s'\n", stamp(), sp->sr_host->ht_name, buf );
	(void)rt_do_cmd( (struct rt_i *)0, buf, cmd_tab );
	if(buf) (void)free(buf);
	drop_server( sp, "one-shot command" );
}

/*
 *			P H _ P I X E L S
 *
 *  When a scanline is received from a server, file it away.
 */
void
ph_pixels(register struct pkg_conn *pc, char *buf)
{
	register int		i;
	register struct servers	*sp;
	register struct frame	*fr;
	register struct list	*lp;
	struct line_info	info;
	struct timeval		tvnow;
	int			npix;
	int			fd;
	int			cnt;
	struct	bu_external	ext;

	(void)gettimeofday( &tvnow, (struct timezone *)0 );

	sp = &servers[pc->pkc_fd];
	if( sp->sr_state != SRST_READY && sp->sr_state != SRST_NEED_TREE &&
	    sp->sr_state != SRST_DOING_GETTREES )  {
		bu_log("%s Ignoring MSG_PIXELS from %s\n",
			stamp(), sp->sr_host->ht_name);
		goto out;
	}

	/* XXX Is this measuring the processing time for
	 * XXX one assignment, or for the whole pipeline of N_SERVER_ASSIGNMENTS
	 * XXX worth of assignments?  It looks like the latter.
	 */

	/*
	 *  If the elapsed time is less than MIN_ELAPSED_TIME, the package
	 *  was probably waiting in either the kernel's or libraries
	 *  input buffer.  Don't use these statistics.
	 */
#define MIN_ELAPSED_TIME	0.02
	if( (sp->sr_l_elapsed = tvdiff( &tvnow, &sp->sr_sendtime )) < MIN_ELAPSED_TIME )
		sp->sr_l_elapsed = MIN_ELAPSED_TIME;

	/* Consider the next assignment to have been sent "now" */
	(void)gettimeofday( &sp->sr_sendtime, (struct timezone *)0 );
	bu_struct_wrap_buf(&ext, (genptr_t) buf);

	i = bu_struct_import( (genptr_t)&info, desc_line_info, &ext );
	if( i < 0 )  {
		bu_log("bu_struct_import error, %d\n", i);
		drop_server( sp, "bu_struct_import error" );
		goto out;
	}
	if( rem_debug )  {
		bu_log("%s %s %d/%d..%d, ray=%d, cpu=%.2g, el=%g\n",
			stamp(),
			sp->sr_host->ht_name,
			info.li_frame, info.li_startpix, info.li_endpix,
			info.li_nrays, info.li_cpusec, sp->sr_l_elapsed );
	}

	if( BU_LIST_IS_EMPTY( &sp->sr_work ) )  {
		bu_log("%s responded with pixels when none were assigned!\n",
			sp->sr_host->ht_name );
		drop_server( sp, "server responded, no assignment" );
		goto out;
	}

	/*
	 *  Here we require that the server return results in the
	 *  same order that they were assigned.
	 *  If the reply deviates in any way from the assignment,
	 *  then the server is dropped.
	 */
	lp = BU_LIST_FIRST( list, &sp->sr_work );
	fr = lp->li_frame;
	CHECK_FRAME(fr);

	if( info.li_frame != fr->fr_number )  {
		bu_log("%s: frame number mismatch, got=%d, assigned=%d\n",
			sp->sr_host->ht_name,
			info.li_frame, fr->fr_number );
		drop_server( sp, "frame number mismatch" );
		goto out;
	}
	if( info.li_startpix != lp->li_start ||
	    info.li_endpix != lp->li_stop )  {
		bu_log("%s:  assignment mismatch, sent %d..%d, got %d..%d\n",
			sp->sr_host->ht_name,
	    		lp->li_start, lp->li_stop,
	    		info.li_startpix, info.li_endpix );
	    	drop_server( sp, "pixel assignment mismatch");
	    	goto out;
	}

	if( info.li_startpix < 0 ||
	    info.li_endpix >= fr->fr_width*fr->fr_height )  {
		bu_log("pixel numbers out of range\n");
		drop_server( sp, "pixel out of range" );
		goto out;
	}

	/* Stash pixels in bottom-to-top .pix order */
	npix = info.li_endpix - info.li_startpix + 1;
	i = npix*3;
	if( pc->pkc_len - ext.ext_nbytes < i )  {
		bu_log("short scanline, s/b=%d, was=%d\n",
			i, pc->pkc_len - ext.ext_nbytes );
		i = pc->pkc_len - ext.ext_nbytes;
		drop_server( sp, "short scanline" );
		goto out;
	}
	/* Write pixels into file */
	/* Later, can implement FD cache here */
	if( (fd = open( fr->fr_filename, 2 )) < 0 )  {
		perror( fr->fr_filename );
		/* The bad fd will trigger a write error, below */
	} else if( lseek( fd, info.li_startpix*3L, 0 ) < 0 )  {
		perror( fr->fr_filename );
		(void)close(fd);	/* prevent write */
		fd = -1;
		/* The bad fd will trigger a write error, below */
	}
	if( (cnt = write( fd, buf+ext.ext_nbytes, i )) != i )  {
		perror( fr->fr_filename );
		bu_log("write s/b %d, got %d\n", i, cnt );
		/*
		 *  Generally, a write error is caused by lack of disk space.
		 *  In any case, it is indicative of bad problems.
		 *  Stop assigning new work.
		 */
		/* XXX should re-queue this assignment */
		bu_log("%s disk write error, preparing graceful STOP\n", stamp() );
		cd_stop( 0, (char **)0 );

		/* Dropping the (innocent) server will requeue the work */
		drop_server( sp, "disk write error" );

		/* Return, as if nothing had happened. */
		(void)close(fd);
		goto out;
	}
	(void)close(fd);

	/* If display attached, also draw it */
	if( fbp != FBIO_NULL )  {
		write_fb( buf + ext.ext_nbytes, fr,
			info.li_startpix, info.li_endpix+1 );
	}

	/*
	 *  Stash the statistics that came back.
	 *  Only perform weighted averages if elapsed times are reasonable.
	 */
	fr->fr_nrays += info.li_nrays;
	fr->fr_cpu += info.li_cpusec;
	sp->sr_l_percent = info.li_percent;
	if( sp->sr_l_elapsed > MIN_ELAPSED_TIME )  {
		double	blend1;	/* fraction of historical value to use */
		double	blend2;	/* fraction of new value to use */

		if( sp->sr_w_elapsed < MIN_ELAPSED_TIME )  {
			/*
			 *  The weighted average so far is much too small.
			 *  Ignore the historical value, and
			 *  use this sample to try and get a good initial
			 *  estimate.
			 */
			blend1 = 0.1;
		} else if( sp->sr_l_elapsed > assignment_time() )  {
			/*
			 *  Took longer than expected, put more weight on
			 *  this sample, and less on the historical values.
			 */
			blend1 = 0.5;
		} else {
			/*
			 *  Took less time than expected, don't get excited.
			 *  Place more emphasis on historical values.
			 */
			blend1 = 0.8;
		}
		blend2 = 1 - blend1;

		sp->sr_l_el_rate = npix / sp->sr_l_elapsed;
		sp->sr_w_elapsed = blend1 * sp->sr_w_elapsed +
				blend2 * sp->sr_l_el_rate;
		sp->sr_w_rays = blend1 * sp->sr_w_rays +
				blend2 * (info.li_nrays/sp->sr_l_elapsed);
		sp->sr_l_cpu = info.li_cpusec;
		sp->sr_s_cpu += info.li_cpusec;
		sp->sr_s_elapsed += sp->sr_l_el_rate;
		sp->sr_sq_elapsed += sp->sr_l_el_rate * sp->sr_l_el_rate;
		sp->sr_nsamp++;
	}

	/* Remove from work list */
	list_remove( &(sp->sr_work), info.li_startpix, info.li_endpix );

/*
 * Check to see if this host is load limited.  If the host is loaded
 * limited check to see if it is time to drop this server.
 */
	if (sp->sr_host->ht_when == HT_RS ||
	    sp->sr_host->ht_when == HT_PASSRS) {
		if(sp->sr_host->ht_rs >= info.li_nrays / sp->sr_l_elapsed) {
			if (++sp->sr_host->ht_rs_miss > 60 ) {
				sp->sr_host->ht_rs_miss = 0;
				sp->sr_host->ht_rs_wait = 3;
				drop_server(sp, "rays/second low");
			}
		} else {
			sp->sr_host->ht_rs_miss /= 2;
		}
	}
out:
	if(buf) (void)free(buf);
}

/*
 *			L I S T _ R E M O V E
 *
 * Given pointer to head of list of ranges, remove the range that's done
 */
void
list_remove(register struct bu_list *lhp, int a, int b)
{
	register struct list *lp;

	for( BU_LIST_FOR( lp, list, lhp ) )  {
		if( lp->li_start == a )  {
			if( lp->li_stop == b )  {
				BU_LIST_DEQUEUE(&lp->l);
				FREE_LIST(lp);
				return;
			}
			lp->li_start = b+1;
			return;
		}
		if( lp->li_stop == b )  {
			lp->li_stop = a-1;
			return;
		}
		if( a > lp->li_stop )  continue;
		if( b < lp->li_start ) continue;
		/* Need to split range into two ranges */
		/* (start..a-1) and (b+1..stop) */
		{
			register struct list *lp2;
			bu_log("splitting range into (%d %d) (%d %d)\n",
				lp->li_start, a-1,
				b+1, lp->li_stop);
			GET_LIST(lp2);
			lp2->li_frame = lp->li_frame;
			lp2->li_start = b+1;
			lp2->li_stop = lp->li_stop;
			lp->li_stop = a-1;
			BU_LIST_APPEND( &lp->l, &lp2->l );
			return;
		}
	}
}

/*
 *			W R I T E _ F B
 *
 *  Buffer 'pp' contains pixels numbered 'a' through (not including) 'b'.
 *  Write them out, clipping them to the current screen.
 */
void
write_fb(unsigned char *pp, struct frame *fr, int a, int b)
{
	register int	x, y;	/* screen coordinates of pixel 'a' */
	int	offset;		/* pixel offset beyond 'pp' */
	int	pixels_todo;	/* # of pixels in buffer to be written */
	int	write_len;	/* # of pixels to write on this scanline */
	int	len_to_eol;	/* # of pixels from 'a' to end of scanline */

	CHECK_FRAME(fr);

	size_display(fr);

	x = a % fr->fr_width;
	y = (a / fr->fr_width) % fr->fr_height;
	pixels_todo = b - a;

	/* Simple case -- use multiple scanline writes */
	if( fr->fr_width == fb_getwidth(fbp) )  {
		fb_write( fbp, x, y,
			pp, pixels_todo );
		return;
	}

	/*
	 *  Hard case -- clip drawn region to the framebuffer.
	 *  The image may be larger than the framebuffer, in which
	 *  case the excess is discarded.
	 *  The image may be smaller than the actual framebuffer size,
	 *  in which case libfb is probably providing zooming.
	 */
	offset = 0;
	while( pixels_todo > 0 )  {
		if( fr->fr_width < fb_getwidth(fbp) )  {
			/* zoomed case */
			write_len = fr->fr_width - x;
		} else {
			/* clipping case */
			write_len = fb_getwidth(fbp) - x;
		}
		len_to_eol = fr->fr_width - x;
		if( write_len > pixels_todo )  write_len = pixels_todo;
		if( write_len > 0 )
			fb_write( fbp, x, y, pp+offset, write_len );
		offset += len_to_eol*3;
		y = (y+1) % fr->fr_height;
		x = 0;
		pixels_todo -= len_to_eol;
	}
}

/*
 *		R E P A I N T _ F B
 *
 *  Repaint the frame buffer from the stored file.
 *  Sort of a cheap "pix-fb", built in.
 */
void
repaint_fb(register struct frame *fr)
{
	register int	y;
	unsigned char	*line;
	int		nby;
	FILE		*fp;
	int		w;
	int		cnt;

	if( fbp == FBIO_NULL ) return;
	CHECK_FRAME(fr);
	size_display(fr);

	if( fr->fr_filename == (char *)0 )  return;

	/* Draw the accumulated image */
	nby = 3*fr->fr_width;
	line = (unsigned char *)rt_malloc( nby, "scanline" );
	if( (fp = fopen( fr->fr_filename, "r" )) == NULL )  {
		perror( fr->fr_filename );
		rt_free( (char *)line, "scanline" );
		return;
	}
	w = fr->fr_width;
	if( w > fb_getwidth(fbp) )  w = fb_getwidth(fbp);

	for( y=0; y < fr->fr_height; y++ )  {
		cnt = fread( (char *)line, nby, 1, fp );
		/* Write out even partial results, then quit */
		fb_write( fbp, 0, y, line, w );
		if( cnt != 1 )  break;
	}
	rt_free( (char *)line, "scanline" );
}

/*
 *			I N I T _ F B
 */
int
init_fb(char *name)
{
	register int xx, yy;

	if( fbp != FBIO_NULL )  fb_close(fbp);

	xx = fbwidth;
	yy = fbheight;
	if( xx <= 0 )
		xx = width;
	if( yy <= 0 )
		yy = height;

	while( xx < width )
		xx <<= 1;
	while( yy < height )
		yy <<= 1;
	if( (fbp = fb_open( name?name:framebuffer, xx, yy )) == FBIO_NULL )  {
		bu_log("fb_open %d,%d failed\n", xx, yy);
		return(-1);
	}
	/* New way:  center, zoom */
	fb_view( fbp, xx/2, yy/2,
		fb_getwidth(fbp)/xx, fb_getheight(fbp)/yy );

	cur_fbwidth = 0;
	return(0);
}

/*
 *			S I Z E _ D I S P L A Y
 */
void
size_display(register struct frame *fr)
{
	CHECK_FRAME(fr);
	if( cur_fbwidth == fr->fr_width )
		return;
	if( fbp == FBIO_NULL )
		return;
	if( fr->fr_width > fb_getwidth(fbp) )  {
		bu_log("Warning:  fb not big enough for %d pixels, display truncated\n", fr->fr_width );
		cur_fbwidth = fr->fr_width;
		fb_view( fbp, fb_getwidth(fbp)/2, fb_getheight(fbp)/2, 1, 1 );
		return;
	}
	cur_fbwidth = fr->fr_width;

	/* Center, zoom */
	fb_view( fbp,
		fr->fr_width/2, fr->fr_height/2,
		fb_getwidth(fbp)/fr->fr_width,
		fb_getheight(fbp)/fr->fr_height );
}

/*
 *			S E N D _ D I R B U I L D
 */
void
send_dirbuild(register struct servers *sp)
{
	register struct ihost	*ihp;

	if( sp->sr_pc == PKC_NULL )  return;
	if( file_fullname[0] == '\0' || sp->sr_state != SRST_VERSOK )  return;

	ihp = sp->sr_host;
	switch( ihp->ht_where )  {
	case HT_CD:
		if( rem_debug > 1 )  bu_log("%s MSG_CD %s\n", stamp(), ihp->ht_path);
		if( pkg_send( MSG_CD, ihp->ht_path, strlen(ihp->ht_path)+1, sp->sr_pc ) < 0 )
			drop_server(sp, "MSG_CD send error");
		break;
	case HT_CONVERT:
		/* Conversion into current dir was done when server was started */
		break;
	default:
		bu_log("send_dirbuild: ht_where=%d unimplemented\n", ihp->ht_where);
		drop_server(sp, "bad ht_where");
		return;
	}

	if( rem_debug > 1 )  bu_log("%s MSG_DIRBUILD %s\n", stamp(), file_basename);
	if( pkg_send( MSG_DIRBUILD, file_basename, strlen(file_basename)+1,
	    sp->sr_pc ) < 0
	)  {
		drop_server(sp, "MSG_DIRBUILD pkg_send error");
		return;
	}
	statechange(sp, SRST_DOING_DIRBUILD);
}

/*
 *			S E N D _ R E S T A R T
 */
void
send_restart(register struct servers *sp)
{
	if( sp->sr_pc == PKC_NULL )  return;

	if( pkg_send( MSG_RESTART, "", 0, sp->sr_pc ) < 0 )
		drop_server(sp, "MSG_RESTART pkg_send error");
	statechange(sp, SRST_RESTART);
}

/*
 *			S E N D _ L O G L V L
 */
void
send_loglvl(register struct servers *sp)
{
	if( sp->sr_pc == PKC_NULL )  return;

	if( pkg_send( MSG_LOGLVL, print_on?"1":"0", 2, sp->sr_pc ) < 0 )
		drop_server(sp, "MSG_LOGLVL pkg_send error");
}

/*
 *			S E N D _ M A T R I X
 *
 *  Send current options, and the view matrix information.
 */
void
send_matrix(struct servers *sp, register struct frame *fr)
{
	CHECK_FRAME(fr);
	if( sp->sr_pc == PKC_NULL )  return;
	if( pkg_send( MSG_MATRIX,
	    bu_vls_addr(&fr->fr_cmd), bu_vls_strlen(&fr->fr_cmd)+1, sp->sr_pc
	    ) < 0 )
		drop_server(sp, "MSG_MATRIX pkg_send error");
}

/*
 *			S E N D _ G E T T R E E S
 *
 *  Send args for rt_gettrees.
 */
void
send_gettrees(struct servers *sp, register struct frame *fr)
{
	CHECK_FRAME(fr);
	if( sp->sr_pc == PKC_NULL )  return;
	if( pkg_send( MSG_GETTREES,
	    object_list, strlen(object_list)+1, sp->sr_pc
	    ) < 0 )  {
		drop_server(sp, "MSG_GETTREES pkg_send error");
		return;
	}
	statechange(sp, SRST_DOING_GETTREES);
}

/*
 *			S E N D _ D O _ L I N E S
 */
void
send_do_lines(register struct servers *sp, int start, int stop, int framenum)
{
	char obuf[128];

	if( sp->sr_pc == PKC_NULL )  return;

	sprintf( obuf, "%d %d %d", start, stop, framenum );
	if( pkg_send( MSG_LINES, obuf, strlen(obuf)+1, sp->sr_pc ) < 0 )
		drop_server(sp, "MSG_LINES pkg_send error");

	(void)gettimeofday( &sp->sr_sendtime, (struct timezone *)0 );
}

/*
 *			P R _ L I S T
 */
void
pr_list(register struct bu_list *lhp)
{
	register struct list *lp;

	for( BU_LIST_FOR( lp, list, lhp ) )  {
		if( lp->li_frame == 0 )  {
			bu_log("\t%d..%d frame *NULL*??\n",
			lp->li_start, lp->li_stop );
		} else {
			bu_log("\t%d..%d frame %d\n",
				lp->li_start, lp->li_stop,
				lp->li_frame->fr_number );
		}
	}
}

void
mathtab_constant(void)
{
	/* Called on -B (benchmark) flag, by get_args() */
}

/*
 *			A D D _ H O S T
 *
 *  There are two message formats:
 *	HT_CD		host, port, rem_dir
 *	HT_CONVERT	host, port, rem_dir, loc_db, rem_db
 */
void
add_host(struct ihost *ihp)
{
	if (ihp->ht_flags & HT_HOLD) return;	/* Not allowed to use */
	/* Send message to helper process */
	switch( ihp->ht_where )  {
	case HT_CD:
		fprintf( helper_fp,
			"%s %d %s\n",
			ihp->ht_name, pkg_permport, ihp->ht_path );
		break;
	case HT_CONVERT:
		if( file_fullname[0] == '\0' )  {
			bu_log("unable to add CONVERT host %s until database given\n",
				ihp->ht_name);
			return;
		}
		fprintf( helper_fp,
			"%s %d %s %s %s\n",
			ihp->ht_name, pkg_permport, ihp->ht_path,
			file_fullname, file_basename );
		break;
	default:
		bu_log("add_host:  ht_where=%d?\n", ihp->ht_where );
		break;
	}
	fflush( helper_fp );

	/* Wait briefly to try and catch the incomming connection,
	 * in case there are several of these spawned in a row.
	 */
	check_input(1);
}

#ifdef sgi
#	define RSH	"/usr/bsd/rsh"
#endif
#if CRAY || m68k
/*	m68k: Need this for MAC II under AUX as well */
#	define RSH	"/usr/bin/remsh"
#endif
#ifndef RSH
#	define RSH	"/usr/ucb/rsh"
#endif

/*
 *			H O S T _ H E L P E R
 *
 *  This loop runs in the child process of the real REMRT, and is directed
 *  to initiate contact with new hosts via a one-way pipe from the parent.
 *  In some cases, starting RTSRV on the indicated host is sufficient;
 *  in other cases, the portable version of the database needs to be
 *  sent first.
 *
 *  For now, a limitation is that the local and remote databases are
 *  given the same name.  If relative path names are used, this should
 *  not be a problem, but this could be changed later.
 */
void
host_helper(FILE *fp)
{
	char	line[512];
	char	cmd[128];
	char	host[128];
	char	loc_db[128];
	char	rem_db[128];
	char	rem_dir[128];
	int	port;
	int	cnt;
	int	i;
	int	pid;

	while(1)  {
		line[0] = '\0';
		(void)fgets( line, sizeof(line), fp );
		if( feof(fp) )  break;

		loc_db[0] = '\0';
		rem_db[0] = '\0';
		rem_dir[0] = '\0';
		cnt = sscanf( line, "%s %d %s %s %s",
			host, &port, rem_dir, loc_db, rem_db );
		if( cnt != 3 && cnt != 5 )  {
			bu_log("host_helper: cnt=%d, aborting\n", cnt);
			break;
		}

		if( cnt == 3 )  {
			sprintf(cmd,
				"cd %s; rtsrv %s %d",
				rem_dir, our_hostname, port );
			if(rem_debug)  {
				bu_log("%s %s\n", stamp(), cmd);
				fflush(stdout);
			}

			pid = fork();
			if( pid == 0 )  {
				/* 1st level child */
				(void)close(0);
				for(i=3; i<40; i++)  (void)close(i);
				if( vfork() == 0 )  {
					/* worker Child */

					/* First, try direct exec. */
					execl(
						RSH,
						"rsh", host,
						"-n", cmd, 0 );

					/* Second, try $PATH exec */
					execlp(
						"rsh",
						"rsh", host,
						"-n", cmd, 0 );
					perror("rsh execl");
					_exit(0);
				}
				_exit(0);
			} else if( pid < 0 ) {
				perror("fork");
			} else {
				(void)wait(0);
			}
		} else {
			sprintf(cmd,
			 "g2asc<%s|%s %s \"cd %s; asc2g>%s; rtsrv %s %d\"",
				loc_db,
				RSH, host,
				rem_dir, rem_db,
				our_hostname, port );
			if(rem_debug)  {
				bu_log("%s %s\n", stamp(), cmd);
				fflush(stdout);
			}

			pid = fork();
			if( pid == 0 )  {
				/* 1st level child */
				(void)close(0);
				for(i=3; i<40; i++)  (void)close(i);

				if( vfork() == 0 )  {
					/* worker Child */
					execl("/bin/sh", "remrt_sh", 
						"-c", cmd, 0);
					perror("/bin/sh");
					_exit(0);
				}
				_exit(0);
			} else if( pid < 0 ) {
				perror("fork");
			} else {
				(void)wait(0);
			}
		}
	}
}

/*
 *			S T A R T _ H E L P E R
 */
void
start_helper(void)
{
	int	fds[2];
	int	pid;

	if( pipe(fds) < 0 )  {
		perror("pipe");
		exit(1);
	}

	pid = fork();
	if( pid == 0 )  {
		/* Child process */
		FILE	*fp;

		(void)close(fds[1]);
		if( (fp = fdopen( fds[0], "r" )) == (FILE *)NULL )  {
			perror("fdopen");
			exit(3);
		}
		host_helper( fp );
		/* No more commands from parent */
		exit(0);
	} else if( pid < 0 )  {
		perror("fork");
		exit(2);
	}
	/* Parent process */
	if( (helper_fp = fdopen( fds[1], "w" )) == (FILE *)NULL )  {
		perror("fdopen");
		exit(4);
	}
	(void)close(fds[0]);
}

/*
 *			B U I L D _ S T A R T _ C M D
 */
void
build_start_cmd(int argc, char **argv, int startc)
{
	register char	*cp;
	register int	i;
	int		len;

	if( startc+2 > argc )  {
		bu_log("build_start_cmd:  need file and at least one object\n");
		file_fullname[0] = '\0';
		return;
	}

	strncpy( file_fullname, argv[startc], sizeof(file_fullname) );

	/* Save last component of file name */
	if( (cp = strrchr( argv[startc], '/' )) != (char *)0 )  {
		(void)strncpy( file_basename, cp+1, sizeof(file_basename) );
	} else {
		(void)strncpy( file_basename, argv[startc], sizeof(file_basename) );
	}

	/* Build new object_list[] string */
	cp = object_list;
	for( i=startc+1; i < argc; i++ )  {
		if( i > startc+1 )  *cp++ = ' ';
		len = strlen( argv[i] );
		bcopy( argv[i], cp, len );
		cp += len;
	}
	*cp++ = '\0';
}

/*** Commands ***/

int
cd_load(int argc, char **argv)
{
	register struct servers *sp;

	if( running )  {
		bu_log("Can't load while running!!\n");
		return -1;
	}

	/* Really ought to reset here, too */
	if(file_fullname[0] != '\0' )  {
		bu_log("Was loaded with %s, restarting all\n", file_fullname);
		for( sp = &servers[0]; sp < &servers[MAXSERVERS]; sp++ )  {
			if( sp->sr_pc == PKC_NULL )  continue;
			send_restart( sp );
		}
	}

	build_start_cmd( argc, argv, 1 );
	return 0;
}

/*
 *			C D _ D E B U G
 *
 *  Set/toggle the local (dispatcher) debugging flag
 */
int
cd_debug(int argc, char **argv)
{
	if( argc <= 1 )  {
		rem_debug = !rem_debug;
	} else {
		sscanf( argv[1], "%x", (unsigned int *)&rem_debug );
	}
	bu_log("%s Dispatcher debug=x%x\n", stamp(), rem_debug );
	return 0;
}

/*
 *			C D _ R D E B U G
 *
 *  Send a string to the command processor on all the remote workers.
 *  Typically this would be of the form "opt -x42;"
 */
int
cd_rdebug(int argc, char **argv)
{
	register struct servers *sp;
	int		len;
	struct bu_vls	cmd;

	bu_vls_init( &cmd );
	bu_vls_strcpy( &cmd, "opt " );
	bu_vls_strcat( &cmd, argv[1] );
	len = bu_vls_strlen( &cmd )+1;
	for( sp = &servers[0]; sp < &servers[MAXSERVERS]; sp++ )  {
		if( sp->sr_pc == PKC_NULL )  continue;
		if( pkg_send( MSG_OPTIONS, bu_vls_addr(&cmd), len, sp->sr_pc) < 0 )
			drop_server(sp, "MSG_OPTIONS pkg_send error");
	}
	return 0;
}

int
cd_f(int argc, char **argv)
{

	width = height = atoi( argv[1] );
	if( width < 4 || width > 16*1024 )
		width = 64;
	bu_log("width=%d, height=%d, takes effect after next MAT\n",
		width, height);
	return 0;
}

int
cd_S(int argc, char **argv)
{
	fbwidth = fbheight = atoi( argv[1] );
	if( fbwidth < 4 || fbwidth > 16*1024 )
		fbwidth = 512;
	if( fbheight < 4 || fbheight > 16*1024 )
		fbheight = 512;
	bu_log("fb width=%d, height=%d, takes effect after next attach\n",
		fbwidth, fbheight);
	return 0;
}

int
cd_N(int argc, char **argv)
{
	fbheight = atoi( argv[1] );
	if( fbheight < 4 || fbheight > 16*1024 )
		fbheight = 512;
	bu_log("fb height=%d, takes effect after next attach\n",
		fbheight);
	return 0;
}

int
cd_hyper(int argc, char **argv)
{
	hypersample = atoi( argv[1] );
	bu_log("hypersample=%d, takes effect after next MAT\n", hypersample);
	return 0;
}

int
cd_bench(int argc, char **argv)
{
	benchmark = atoi( argv[1] );
	bu_log("Benchmark flag=%d, takes effect after next MAT\n", benchmark);
	return 0;
}

int
cd_persp(int argc, char **argv)
{
	rt_perspective = atof( argv[1] );
	if( rt_perspective < 0.0 )  rt_perspective = 0.0;
	bu_log("perspective angle=%g, takes effect after next MAT\n", rt_perspective);
	return 0;
}

int
cd_read(int argc, char **argv)
{
	register FILE *fp;

	if( (fp = fopen(argv[1], "r")) == NULL )  {
		perror(argv[1]);
		return -1;
	}
	source(fp);
	fclose(fp);
	bu_log("%s 'read' command done\n", stamp());
	return 0;
}

void
source(FILE *fp)
{
	while( !feof(fp) )  {
		/* do one command from file */
		interactive_cmd(fp);
		/* Without delay, see if anything came in */
		check_input(0);
	}
}

int
cd_detach(int argc, char **argv)
{
	detached = 1;
	FD_CLR( fileno(stdin), &clients);	/* drop stdin */
	close(0);
	return 0;
}

int
cd_file(int argc, char **argv)
{
	if(outputfile)  rt_free(outputfile, "outputfile");
	outputfile = bu_strdup( argv[1] );
	return 0;
}

/*
 *			C D _ M A T
 *
 *  Read one specific matrix from an old-format eyepoint file.
 */
int
cd_mat(int argc, char **argv)
{
	register FILE *fp;
	register struct frame *fr;
	int	i;

	GET_FRAME(fr);
	if( argc >= 3 )  {
		fr->fr_number = atoi(argv[2]);
	} else {
		fr->fr_number = 0;
	}
	prep_frame(fr);

	if( (fp = fopen(argv[1], "r")) == NULL )  {
		perror(argv[1]);
		return -1;
	}

	/* Find the one desired frame */
	for( i=fr->fr_number; i>=0; i-- )  {
		if(read_matrix( fp, fr ) <= 0 )  {
			bu_log("mat: failure\n");
			fclose(fp);
			return -1;
		}
	}
	fclose(fp);

	if( create_outputfilename( fr ) < 0 )  {
		FREE_FRAME(fr);
	} else {
		APPEND_FRAME( fr, FrameHead.fr_back );
	}
	return 0;
}

int
cd_movie(int argc, char **argv)
{
	register FILE	*fp;
	register struct frame	*fr;
	struct frame		dummy_frame;
	int		a,b;
	int		i;

	/* movie mat a b */
	if( running )  {
		bu_log("already running, please wait\n");
		return -1;
	}
	if( file_fullname[0] == '\0' )  {
		bu_log("need LOAD before MOVIE\n");
		return -1;
	}
	a = atoi( argv[2] );
	b = atoi( argv[3] );
	if( (fp = fopen(argv[1], "r")) == NULL )  {
		perror(argv[1]);
		return -1;
	}
	/* Skip over unwanted beginning frames */
	for( i=0; i<a; i++ )  {
		if(read_matrix( fp, &dummy_frame ) <= 0 )  {
			bu_log("movie:  error in old style frame list\n");
			fclose(fp);
			return -1;
		}
	}
	for( i=a; i<b; i++ )  {
		int	ret;
		GET_FRAME(fr);
		fr->fr_number = i;
		prep_frame(fr);
		if( (ret=read_matrix( fp, fr )) < 0 )  {
			bu_log("movie:  frame %d bad\n", i);
			fclose(fp);
			return -1;
		}
		if( ret == 0 )  break;			/* EOF */
		if( create_outputfilename( fr ) < 0 )  {
			FREE_FRAME(fr);
		} else {
			APPEND_FRAME( fr, FrameHead.fr_back );
		}
	}
	fclose(fp);
	bu_log("Movie ready\n");
	return 0;
}

int
cd_add(int argc, char **argv)
{
	register int i;
	struct ihost	*ihp;

	for( i=1; i<argc; i++ )  {
		if( (ihp = host_lookup_by_name( argv[i], 0 )) != IHOST_NULL )  {
			add_host( ihp );
		}
	}
	return 0;
}

int
cd_drop(int argc, char **argv)
{
	register struct servers *sp;

	sp = get_server_by_name( argv[1] );
	if( sp == SERVERS_NULL || sp->sr_pc == PKC_NULL )  return -1;
	drop_server(sp, "drop command issued");
	return 0;
}

int
cd_hold(int argc, char **argv)
{
	register struct servers *sp;
	register struct ihost *ihp;

	ihp = host_lookup_by_name( argv[1], 0);
	if (ihp == IHOST_NULL) return -1;
	ihp->ht_flags |= HT_HOLD;

	sp = get_server_by_name( argv[1] );
	if ( sp == SERVERS_NULL || sp->sr_pc == PKC_NULL) return -1;
	drop_server(sp, "hold command issued");
	return 0;
}

int
cd_resume(int argc, char **argv)
{
	struct ihost	*ihp;

	ihp = host_lookup_by_name( argv[1], 0);
	if (ihp == IHOST_NULL ) return -1;
	ihp->ht_flags &= ~HT_HOLD;
	add_host( ihp );
	return 0;
}

int
cd_allocate(int argc, char **argv)
{
	if (strcmp(argv[1], "frame") == 0) {
		work_allocate_method = OPT_FRAME;
	} else if ( strcmp(argv[1], "movie") == 0 ) {
		work_allocate_method = OPT_MOVIE;
	} else if ( strcmp(argv[1], "load") == 0 ) {
		work_allocate_method = OPT_LOAD;
	} else {
		bu_log("%s Bad allocateby type '%s'\n", stamp(), argv[1]);
		return( -1 );
	}

	return( 0 );
}
		
int
cd_restart(int argc, char **argv)
{
	register struct servers *sp;

	if( argc <= 1 )  {
		/* Restart all */
		bu_log("%s Restarting all\n", stamp() );
		for( sp = &servers[0]; sp < &servers[MAXSERVERS]; sp++ )  {
			if( sp->sr_pc == PKC_NULL )  continue;
			send_restart( sp );
		}
		return -1;
	}
	sp = get_server_by_name( argv[1] );
	if( sp == SERVERS_NULL || sp->sr_pc == PKC_NULL )  return -1;
	send_restart( sp );
	/* The real action takes place when he closes the conn */
	return 0;
}

int
cd_stop( int argc, char **argv )
{
	bu_log("%s No more scanlines being scheduled, done soon\n", stamp() );
	running = 0;
	return 0;
}

int
cd_reset(int argc, char **argv)
{
	register struct frame *fr;

	if( running )  {
		bu_log("must STOP before RESET!\n");
		return -1;
	}
	do {
		fr = FrameHead.fr_forw;
		CHECK_FRAME(fr);
		destroy_frame( fr );
	} while( FrameHead.fr_forw != &FrameHead );
	return 0;
}

int
cd_attach(int argc, char **argv)
{
	register struct frame *fr;
	char		*name;

	if( argc <= 1 )  {
		name = (char *)0;
	} else {
		name = argv[1];
	}
	if( init_fb(name) < 0 )  return -1;
	if( fbp == FBIO_NULL ) return -1;
	if( (fr = FrameHead.fr_forw) == &FrameHead )  return -1;
	CHECK_FRAME(fr);

	repaint_fb( fr );
	return 0;
}

int
cd_release(int argc, char **argv)
{
	if(fbp != FBIO_NULL) fb_close(fbp);
	fbp = FBIO_NULL;
	return 0;
}


/*
 *			C D _ F R A M E S
 *
 *  Sumarize frames waiting
 *	Usage: frames [-v]
 */
int
cd_frames( int argc, char **argv )
{
	register struct frame *fr;

	bu_log("%s Frames waiting:\n", stamp() );
	for(fr=FrameHead.fr_forw; fr != &FrameHead; fr=fr->fr_forw) {
		CHECK_FRAME(fr);
		bu_log("%5d\twidth=%d, height=%d\n",
			fr->fr_number,
			fr->fr_width, fr->fr_height );

		if( argc <= 1 )  continue;
		if( fr->fr_filename )  {
			bu_log("\tfile=%s%s\n",
				fr->fr_filename,
				fr->fr_tempfile ? " **TEMPORARY**" : "" );
		}
		bu_log("\tnrays = %d, cpu sec=%g\n", fr->fr_nrays, fr->fr_cpu);
		pr_list( &(fr->fr_todo) );
		bu_log("\tcmd=%s\n", bu_vls_addr(&fr->fr_cmd) );
		bu_log("\tafter_cmd=%s\n", bu_vls_addr(&fr->fr_after_cmd) );
	}
	return 0;
}

int
cd_memprint(int argc, char **argv)
{
	if (strcmp(argv[1],"on")==0) {
		rt_g.debug |= (DEBUG_MEM|DEBUG_MEM_FULL);
	} else if (strcmp(argv[1], "off") == 0) {
		rt_g.debug &= ~(DEBUG_MEM|DEBUG_MEM_FULL);
	} else {
		bu_prmem("memprint command");
	}
	return 0;
}

/*
 *			C D _ S T A T
 *
 *  Brief version
 */
int
cd_stat( int argc, char **argv )
{
	register struct servers *sp;
    	int	frame;
	char	*s;
	char	buf[48];
	char	*state;

	s = stamp();

	/* Print work assignments */
	if(interactive) bu_log("%s Interactive mode\n", s);
	bu_log("%s Worker assignment interval=%d seconds:\n",
		s, assignment_time() );
	bu_log("   Server   Last  Last   Average  Cur   Machine\n");
	bu_log("    State   Lump Elapsed pix/sec Frame   Name \n");
	bu_log("  -------- ----- ------- ------- ----- -------------\n");
	for( sp = &servers[0]; sp < &servers[MAXSERVERS]; sp++ )  {
		if( sp->sr_pc == PKC_NULL )  continue;

		/* Ignore one-shot command interfaces */
		if( sp->sr_state == SRST_NEW )  continue;

		if( sp->sr_curframe != FRAME_NULL )  {
			CHECK_FRAME(sp->sr_curframe);
			frame = sp->sr_curframe->fr_number;
		}  else  {
			frame = -1;
		}

		if( sp->sr_state != SRST_READY )  {
			state = state_to_string(sp->sr_state);
		}  else  {
			sprintf( buf, "Running%d",
				server_q_len(sp) );
			state = buf;
		}
		bu_log("  %8s %5d %7g %7g %5d %s\n",
			state,
			sp->sr_lump,
			sp->sr_l_elapsed,
			sp->sr_w_elapsed,
			frame,
			sp->sr_host->ht_name );
	}
	return 0;
}

/*
 *			C D _ S T A T U S
 *
 *  Full status version
 */
int
cd_status(int argc, char **argv)
{
	register struct servers *sp;
    	int	num;
	char	*s;

	s = stamp();

	if( file_fullname[0] == '\0' )  {
		bu_log("No model loaded yet\n");
	} else {
		bu_log("\n%s %s\n",
			s,
			running ? "RUNNING" : "Halted" );
		bu_log("%s %s objects=%s\n",
			s, file_fullname, object_list );
	}

	if( fbp != FBIO_NULL )
		bu_log("%s Framebuffer is %s\n", s, fbp->if_name);
	else
		bu_log("%s No framebuffer\n", s );
	if( outputfile )
		bu_log("%s Output file: %s.###\n", s, outputfile );
	bu_log("%s Printing of remote messages is %s\n",
		s, print_on?"ON":"Off" );
    	bu_log("%s Listening at %s, port %d\n",
		s, our_hostname, pkg_permport);

	/* Print work assignments */
	bu_log("%s Worker assignment interval=%d seconds:\n",
		s, assignment_time() );
	for( sp = &servers[0]; sp < &servers[MAXSERVERS]; sp++ )  {
		if( sp->sr_pc == PKC_NULL )  continue;
		bu_log("  %2d  %s %s",
			sp->sr_pc->pkc_fd, sp->sr_host->ht_name,
			state_to_string(sp->sr_state) );
		if( sp->sr_curframe != FRAME_NULL )  {
			CHECK_FRAME(sp->sr_curframe);
			bu_log(" frame %d, assignments=%d\n",
				sp->sr_curframe->fr_number,
				server_q_len(sp) );
		}  else  {
			bu_log("\n");
		}
		num = sp->sr_nsamp<=0 ? 1 : sp->sr_nsamp;
		bu_log("\tlast:  elapsed=%g, cpu=%g, lump=%d\n",
			sp->sr_l_elapsed,
			sp->sr_l_cpu,
			sp->sr_lump );
		bu_log("\t avg:  elapsed=%gp/s, cpu=%g, weighted=%gp/s\n",
			(sp->sr_s_elapsed/num),
			sp->sr_s_cpu/num,
			sp->sr_w_elapsed);
		bu_log("\t r/s:  weighted=%gr/s missed = %d\n",
			sp->sr_w_rays,
			sp->sr_host->ht_rs_miss );

		if( rem_debug )
			pr_list( &(sp->sr_work) );
	}
	return 0;
}

int
cd_clear(int argc, char **argv)
{
	if( fbp == FBIO_NULL )  return -1;
	fb_clear( fbp, PIXEL_NULL );
	cur_fbwidth = 0;
	return 0;
}

int
cd_print(int argc, char **argv)
{
	register struct servers *sp;

	if( argc > 1 )
		print_on = atoi(argv[1]);
	else
		print_on = !print_on;	/* toggle */

	for( sp = &servers[0]; sp < &servers[MAXSERVERS]; sp++ )  {
		if( sp->sr_pc == PKC_NULL )  continue;
		send_loglvl( sp );
	}
	bu_log("%s Printing of remote messages is %s\n",
		stamp(),
		print_on?"ON":"Off" );
	return 0;
}

int
cd_go(int argc, char **argv)
{
	do_a_frame();
	return 0;
}

int
cd_wait(int argc, char **argv)
{
	struct timeval	now;

	FD_CLR( fileno(stdin), &clients );
	if( running )  {
		/*
		 *  When running, WAIT command waits for all
		 *  outstanding frames to be completed.
		 */
/* Aargh.  We really need a FD_ISZERO macro. */
		int done = 0, i;
		while( !done && FrameHead.fr_forw != &FrameHead )  {
			for (i = 0, done = 1; i < FD_SETSIZE; i++)
				if (FD_ISSET(i, &clients)) { done = 0; break; }
			check_input( 30 );	/* delay up to 30 secs */

			(void)gettimeofday( &now, (struct timezone *)0 );
			schedule( &now );
		}
	} else {
		/*
		 *  When stopped, WAIT command waits for all
		 *  servers to finish their assignments.
		 */
		while( !all_servers_idle() )  {
			bu_log("%s Stopped, waiting for servers to become idle\n", stamp() );
			check_input( 30 );	/* delay up to 30 secs */
		}
		bu_log("%s All servers idle\n", stamp() );
	}
	FD_SET( fileno(stdin), &clients );
	return 0;
}

int
cd_help(int argc, char **argv)
{
	register struct command_tab	*tp;

	for( tp = cmd_tab; tp->ct_cmd != (char *)0; tp++ )  {
		bu_log("%s %s\t\t%s\n",
			tp->ct_cmd, tp->ct_parms,
			tp->ct_comment );
	}
	return 0;
}

/*
 * host name always|night|passive cd|convert path
 */
int
cd_host(int argc, char **argv)
{
	register struct ihost	*ihp;
	int argpoint = 1;

	if( argc < 5 )  {
		bu_log("%s Registered Host Table:\n", stamp() );
		for( BU_LIST_FOR( ihp, ihost, &HostHead ) )  {
			CK_IHOST(ihp);
			bu_log("  %s 0x%x ", ihp->ht_name, ihp->ht_flags);
			switch(ihp->ht_when)  {
			case HT_ALWAYS:
				bu_log("always ");
				break;
			case HT_NIGHT:
				bu_log("night ");
				break;
			case HT_HACKNIGHT:
				bu_log("hacknight ");
				break;
			case HT_PASSIVE:
				bu_log("passive ");
				break;
			case HT_RS:
				bu_log("r/s %d ",ihp->ht_rs);
				break;
			case HT_PASSRS:
				bu_log("passive r/s %d ",ihp->ht_rs);
				break;
			default:
				bu_log("?when? ");
				break;
			}
			switch(ihp->ht_where)  {
			case HT_CD:
				bu_log("cd %s\n", ihp->ht_path);
				break;
			case HT_CONVERT:
				bu_log("convert %s\n", ihp->ht_path);
				break;
			default:
				bu_log("?where?\n");
				break;
			}
		}
		return 0;
	}

	if( (ihp = host_lookup_by_name( argv[argpoint++], 1 )) == IHOST_NULL )
		return -1;

	/* When */
	if( strcmp( argv[argpoint], "always" ) == 0 ) {
		ihp->ht_when = HT_ALWAYS;
	} else if( strcmp( argv[argpoint], "night" ) == 0 )  {
		ihp->ht_when = HT_NIGHT;
	} else if( strcmp( argv[argpoint], "hacknight" ) == 0 )  {
		ihp->ht_when = HT_HACKNIGHT;
	} else if( strcmp( argv[argpoint], "passive" ) == 0 )  {
		ihp->ht_when = HT_PASSIVE;
	} else if( strcmp( argv[argpoint], "rs" ) == 0 ) {
		ihp->ht_when = HT_RS;
	} else if ( strcmp( argv[argpoint], "passrs" ) == 0 ) {
		ihp->ht_when = HT_PASSRS;
	} else {
		bu_log("unknown 'when' string '%s'\n", argv[argpoint]);
	}
	++argpoint;
	if (ihp->ht_when == HT_RS ||
	    ihp->ht_when == HT_PASSRS) {
		ihp->ht_rs_miss = 0;
		ihp->ht_rs_wait = 0;
		ihp->ht_rs = 500;
		if ( isdigit(*argv[argpoint])) {
			ihp->ht_rs = atoi(argv[argpoint++]);
		}
	    }

	/* Where */
	if( strcmp( argv[argpoint], "cd" ) == 0 )  {
		ihp->ht_where = HT_CD;
		ihp->ht_path = bu_strdup( argv[argpoint+1] );
	} else if( strcmp( argv[argpoint], "convert" ) == 0 )  {
		ihp->ht_where = HT_CONVERT;
		ihp->ht_path = bu_strdup( argv[argpoint+1] );
	} else if (strcmp( argv[argpoint], "use" ) == 0 ) {
		ihp->ht_where = HT_USE;
		ihp->ht_path = bu_strdup( argv[argpoint+1]);
	} else {
		bu_log("unknown 'where' string '%s'\n", argv[argpoint] );
	}
	return 0;
}

/*
 *			C D _ E X I T
 */
int
cd_exit(int argc, char **argv)
{
	exit(0);
	/*NOTREACHED*/
}

/* 		C D _ F R A M E
 *
 * Entry:
 *	argc	argument count
 *	argv	argument list
 *
 * Exit:
 *	frame_script is set to the shell script to execute.
 *
 */
int
cd_EOFrame(int argc, char **argv)
{
	if (frame_script) {
		(void) free(frame_script);
		frame_script = (char *)0;
	}

	if (strcmp(argv[1], "off") != 0 ) {
		frame_script = bu_strdup(argv[1]);
	}
	return 0;
}

struct command_tab cmd_tab[] = {
	{"load",	"file obj(s)",	"specify database and treetops",
		cd_load,	3, 99},
	{"read", "file",		"source a command file",
		cd_read,	2, 2},
	{"file", "name",		"base name for storing frames",
		cd_file,	2, 2},
	{"mat", "file [frame]",	"read one matrix from file",
		cd_mat,		2, 3},
	{"movie", "file start_frame end_frame",	"read movie",
		cd_movie,	4, 4},
	{"add", "host(s)",	"attach to hosts",
		cd_add,		2, 99},
	{"drop", "host",		"drop first instance of 'host'",
		cd_drop,	2, 2},
	{"hold", "host",		"Hold a host from processing",
		cd_hold,	2, 2},
	{"resume","host",	"resume a host processing",
		cd_resume,	2, 2},
	{"allocteby", "allocateby", "Work allocation method",
		cd_allocate,	2, 2},
	{"restart", "[host]",	"restart one or all hosts",
		cd_restart,	1, 2},
	{"go", "",		"start scheduling frames",
		cd_go,		1, 1},
	{"stop", "",		"stop scheduling work",
		cd_stop,	1, 1},
	{"reset", "",		"purge frame list of all work",
		cd_reset,	1, 1},
	{"frames", "[-v]",	"summarize waiting frames",
		cd_frames,	1, 2},
	{"stat", "",		"brief worker status",
		cd_stat,	1, 1},
	{"status", "",		"full worker status",
		cd_status,	1, 1},
	{"detach", "",		"detatch from interactive keyboard",
		cd_detach,	1, 1},
	{"host", "name always|night|passive|rs[ rays/sec]|passrs[ rays/sec] cd|convert path", "register server host",
		cd_host,	1, 6},
	{"wait", "",		"wait for current work assignment to finish",
		cd_wait,	1, 1},
	{"exit", "",		"terminate remrt",
		cd_exit,	1, 1},
	{"EOFrame", "EOFrame command|'off'", "Run command/script on dispatcher at End Of Frame",
		cd_EOFrame,	2, 2},
	/* FRAME BUFFER */
	{"attach", "[fb]",	"attach to frame buffer",
		cd_attach,	1, 2},
	{"release", "",		"release frame buffer",
		cd_release,	1, 1},
	{"clear", "",		"clear framebuffer",
		cd_clear,	1, 1},
	{"S", "square_size",	"set square frame buffer size",
		cd_S,		2, 2},
	{"N", "square_height",	"set height of frame buffer",
		cd_N,		2, 2},
	/* FLAGS */
	{"debug", "[hex_flags]",	"set local debugging flag bits",
		cd_debug,	1, 2},
	{"rdebug", "options",	"set remote debugging via 'opt' command",
		cd_rdebug,	2, 2},
	{"f", "square_size",	"set square frame size",
		cd_f,		2, 2},
	{"s", "square_size",	"set square frame size",
		cd_f,		2, 2},
	{"-H", "hypersample",	"set number of hypersamples/pixel",
		cd_hyper,	2, 2},
	{"-B", "0|1",		"set benchmark flag",
		cd_bench,	2, 2},
	{"p", "angle",		"set perspective angle (degrees) 0=ortho",
		cd_persp,	2, 2},
	{"print", "[0|1]",	"set/toggle remote message printing",
		cd_print,	1, 2},
	{"memprint", "on|off|NULL",	"debug dump of memory usage",
		cd_memprint,	1, 2},
	/* HELP */
	{"?", "",		"help",
		cd_help,	1, 1},
	{(char *)0, (char *)0, (char *)0,
		0,		0, 0}	/* END */
};

#ifdef CRAY2
gettimeofday( tvp, tzp )
struct timeval	*tvp;
struct timezone	*tzp;
{
	tvp->tv_sec = time( (long *)0 );
	tvp->tv_usec = 0;
}
#endif
@


11.38
log
@change conf.h to a wrapped config.h
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/remrt/remrt.c,v 11.37 2004/04/05 05:45:58 morrison Exp $ (BRL)";
@


11.37
log
@merge of ansi-6-0-branch into head
@
text
@d23 6
a28 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
a29 1
#include "conf.h"
@


11.36
log
@update copyright to include span through 2003
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/remrt/remrt.c,v 11.35 2003/09/27 00:59:22 morrison Exp $ (BRL)";
a32 4
#ifdef BSD
#  define __BSDbackup BSD
#  undef BSD
#endif
a33 4
#ifdef __BSDbackup
#  define BSD __BSDbackup
#  undef __BSDbackup
#endif
d94 123
a216 19
void		read_rc_file();
void		check_input();
void		addclient();
void		start_servers();
void		eat_script();
void		interactive_cmd();
void		prep_frame();
void		frame_is_done();
void		destroy_frame();
void		schedule();
void		list_remove();
void		write_fb();
void		repaint_fb();
void		size_display();
void		send_dirbuild();
void		send_gettrees();
void		send_restart();
void		send_loglvl();
void		send_matrix();
d218 10
a227 10
void		pr_list();
void		mathtab_constant();
void		add_host();
void		host_helper();
void		start_helper();
void		build_start_cmd();
void		drop_server();
void		send_do_lines();
void		do_work();
void		source();
d241 7
a247 7
void	ph_default();	/* foobar message handler */
void	ph_pixels();
void	ph_print();
void	ph_dirbuild_reply();
void	ph_gettrees_reply();
void	ph_version();
void	ph_cmd();
a266 7
#define NFD 32
#ifdef FD_SETSIZE
#define MAXSERVERS	FD_SETSIZE
#else
#define MAXSERVERS	NFD		/* No relay function yet */
#endif

a298 22
struct frame {
	struct frame	*fr_forw;
	struct frame	*fr_back;
	int		fr_magic;	/* magic number */
	long		fr_number;	/* frame number */
	long		fr_server;	/* server number assigned. */
	char		*fr_filename;	/* name of output file */
	int		fr_tempfile;	/* if !0, output file is temporary */
	/* options */
	int		fr_width;	/* frame width (pixels) */
	int		fr_height;	/* frame height (pixels) */
	struct bu_list	fr_todo;	/* work still to be done */
	/* Timings */
	struct timeval	fr_start;	/* start time */
	struct timeval	fr_end;		/* end time */
	long		fr_nrays;	/* rays fired so far */
	double		fr_cpu;		/* CPU seconds used so far */
	/* Current view */
	struct bu_vls	fr_cmd;		/* RT options & command string */
	int		fr_needgettree; /* Do we need a gettree message */
	struct bu_vls	fr_after_cmd;	/* local commands, after frame done */
};
a356 74

/*
 *  In order to preserve asynchrony, each server is marched through
 *  a series of state transitions.
 *  Each transition is triggered by some event being satisfied.
 *  The valid state transition sequences are:
 *
 *  If a "transient" server shows up, just to send in one command:
 *
 *	Original	New		Event
 *	--------	-----		-----
 *	UNUSED		NEW		connection rcvd
 *	NEW		CLOSING		ph_cmd pkg rcvd.
 *	CLOSING		UNUSED		next schedule() pass closes conn.
 *
 *  If a "permanent" server shows up:
 *
 *	Original	New		Event
 *	--------	-----		-----
 *	UNUSED		NEW		connection rcvd
 *	NEW		VERSOK		ph_version pkg rcvd.
 *					Optionally send loglvl & "cd" cmds.
 *	VERSOK		DOING_DIRBUILD	MSG_DIRBUILD sent
 *	DOING_DIRBUILD	READY		MSG_DIRBUILD_REPLY rcvd
 *
 * --	READY		DOING_GETTREES	new frame:  send_gettrees(), send_matrix()
 *	DOING_GETTREES	READY		MSG_GETTREES_REPLY rcvd
 *
 * --	READY		READY		call send_do_lines(),
 *					receive ph_pixels pkg.
 *
 * --	READY		CLOSING		drop_server called.  Requeue work.
 *	CLOSING		UNUSED		next schedule() pass closes conn.
 *
 * XXX need to split sending of db name & the treetops.
 * XXX treetops need to be resent at start of each frame.
 * XXX should probably re-vamp send_matrix routine.
 */

struct servers {
	struct pkg_conn	*sr_pc;		/* PKC_NULL means slot not in use */
	struct bu_list	sr_work;
	struct ihost	*sr_host;	/* description of this host */
	int		sr_lump;	/* # lines to send at once */
	int		sr_state;	/* Server state, SRST_xxx */
#define SRST_UNUSED		0	/* unused slot */
#define SRST_NEW		1	/* connected, awaiting vers check */
#define SRST_VERSOK		2	/* version OK, no model loaded yet */
#define SRST_DOING_DIRBUILD	3	/* doing dirbuild, awaiting response */
#define SRST_NEED_TREE		4	/* need our first gettree */
#define SRST_READY		5	/* loaded, ready */
#define SRST_RESTART		6	/* about to restart */
#define SRST_CLOSING		7	/* Needs to be closed */
#define SRST_DOING_GETTREES	8	/* doing gettrees */
	struct frame	*sr_curframe;	/* ptr to current frame */
	/* Timings */
	struct timeval	sr_sendtime;	/* time of last sending */
	double		sr_l_elapsed;	/* last: elapsed_sec */
	double		sr_l_el_rate;	/* last: pix/elapsed_sec */
	double		sr_w_elapsed;	/* weighted avg: pix/elapsed_sec */
	double		sr_w_rays;	/* weighted avg: rays/elapsed_sec */
	double		sr_s_elapsed;	/* sum of pix/elapsed_sec */
	double		sr_sq_elapsed;	/* sum of pix/elapsed_sec squared */
	double		sr_l_cpu;	/* cpu_sec for last scanline */
	double		sr_s_cpu;	/* sum of all cpu times */
	double		sr_s_pix;	/* sum of all pixels */
	double		sr_s_e;		/* sum of all elapsed seconds */
	double		sr_s_sq_cpu;	/* sum of cpu times squared */
	double		sr_s_sq_pix;	/* sum of pixels squared */
	double		sr_s_sq_e;	/* sum of all elapsed seceonds squared */
	int		sr_nsamp;	/* number of samples summed over */
	double		sr_prep_cpu;	/* sum of cpu time for preps */
	double		sr_l_percent;	/* last: percent of CPU */
} servers[MAXSERVERS];
d430 1
a430 2
tvsub(tdiff, t1, t0)
struct timeval *tdiff, *t1, *t0;
d445 1
a445 2
tvdiff(t1, t0)
struct timeval	*t1, *t0;
d458 1
a458 1
stamp()
d480 1
a480 2
state_to_string( state )
int	state;
d512 1
a512 3
statechange( sp, newstate )
register struct servers *sp;
int	newstate;
d528 1
a528 3
main(argc, argv)
int	argc;
char	**argv;
d657 1
a657 2
do_work(auto_start)
int	auto_start;
d710 1
a710 1
read_rc_file()
d736 1
a736 2
check_input(waittime)
int waittime;
d814 1
a814 2
addclient(pc)
struct pkg_conn *pc;
d869 1
a869 3
drop_server(sp, why)
register struct servers	*sp;
char	*why;
d933 1
a933 2
start_servers( nowp )
struct timeval	*nowp;
d1081 1
a1081 2
eat_script( fp )
FILE	*fp;
d1202 1
a1202 2
string2int(str)
register char *str;
d1221 1
a1221 2
get_server_by_name( str )
char *str;
d1247 1
a1247 2
interactive_cmd(fp)
FILE *fp;
d1303 1
a1303 2
prep_frame(fr)
register struct frame *fr;
d1351 1
a1351 1
do_a_frame()
d1389 1
a1389 2
scan_frame_for_finished_pixels( fr )
register struct frame	*fr;
d1512 1
a1512 2
frame_is_done(fr)
register struct frame *fr;
d1571 1
a1571 2
destroy_frame( fr )
register struct frame	*fr;
d1612 1
a1612 2
this_frame_done( fr )
register struct frame	*fr;
d1640 1
a1640 1
all_servers_idle()
d1665 1
a1665 1
all_done()
d1702 1
a1702 2
schedule( nowp )
struct timeval	*nowp;
d1834 1
a1834 1
number_of_ready_servers()
d1860 1
a1860 1
assignment_time()
d2062 1
a2062 3
read_matrix( fp, fr )
register FILE *fp;
register struct frame *fr;
d2106 1
a2106 3
ph_default(pc, buf)
register struct pkg_conn *pc;
char *buf;
d2127 1
a2127 3
ph_dirbuild_reply(pc, buf)
register struct pkg_conn *pc;
char *buf;
d2157 1
a2157 3
ph_gettrees_reply(pc, buf)
register struct pkg_conn *pc;
char *buf;
d2184 1
a2184 3
ph_print(pc, buf)
register struct pkg_conn *pc;
char *buf;
d2201 1
a2201 3
ph_version(pc, buf)
register struct pkg_conn *pc;
char	*buf;
d2226 1
a2226 3
ph_cmd(pc, buf)
register struct pkg_conn *pc;
char	*buf;
d2243 1
a2243 3
ph_pixels(pc, buf)
register struct pkg_conn *pc;
char *buf;
d2462 1
a2462 3
list_remove( lhp, a, b )
register struct bu_list *lhp;
int		a, b;
d2507 1
a2507 5
write_fb( pp, fr, a, b )
unsigned char 	*pp;
struct frame	*fr;
int		a;
int		b;
d2564 1
a2564 2
repaint_fb( fr )
register struct frame *fr;
d2636 1
a2636 2
size_display(fr)
register struct frame	*fr;
d2662 1
a2662 2
send_dirbuild(sp)
register struct servers *sp;
d2699 1
a2699 2
send_restart(sp)
register struct servers *sp;
d2712 1
a2712 2
send_loglvl(sp)
register struct servers *sp;
d2726 1
a2726 3
send_matrix(sp, fr)
struct servers *sp;
register struct frame *fr;
d2742 1
a2742 3
send_gettrees(sp, fr)
struct servers		*sp;
register struct frame	*fr;
d2759 1
a2759 5
send_do_lines( sp, start, stop, framenum )
register struct servers *sp;
int		start;
int		stop;
int		framenum;
d2776 1
a2776 2
pr_list( lhp )
register struct bu_list *lhp;
d2793 1
a2793 1
mathtab_constant()
d2806 1
a2806 2
add_host( ihp )
struct ihost	*ihp;
d2864 1
a2864 2
host_helper(fp)
FILE	*fp;
d2968 1
a2968 1
start_helper()
d3007 1
a3007 4
build_start_cmd( argc, argv, startc )
int	argc;
char	**argv;
int	startc;
d3042 1
a3042 3
cd_load( argc, argv )
int	argc;
char	**argv;
d3070 1
a3070 3
cd_debug( argc, argv )
int	argc;
char	**argv;
d3088 1
a3088 3
cd_rdebug( argc, argv )
int	argc;
char	**argv;
d3107 1
a3107 3
cd_f( argc, argv )
int	argc;
char	**argv;
d3119 1
a3119 3
cd_S( argc, argv )
int	argc;
char	**argv;
d3132 1
a3132 3
cd_N( argc, argv )
int	argc;
char	**argv;
d3143 1
a3143 3
cd_hyper( argc, argv )
int	argc;
char	**argv;
d3151 1
a3151 3
cd_bench( argc, argv )
int	argc;
char	**argv;
d3159 1
a3159 3
cd_persp( argc, argv )
int	argc;
char	**argv;
d3168 1
a3168 3
cd_read( argc, argv )
int	argc;
char	**argv;
d3183 1
a3183 2
source(fp)
FILE	*fp;
d3194 1
a3194 3
cd_detach( argc, argv )
int	argc;
char	**argv;
d3203 1
a3203 3
cd_file( argc, argv )
int	argc;
char	**argv;
d3216 1
a3216 3
cd_mat( argc, argv )
int	argc;
char	**argv;
d3254 1
a3254 3
cd_movie( argc, argv )
int	argc;
char	**argv;
d3308 1
a3308 3
cd_add( argc, argv )
int	argc;
char	**argv;
d3322 1
a3322 3
cd_drop( argc, argv )
int	argc;
char	**argv;
d3333 1
a3333 3
cd_hold( argc, argv )
int	argc;
char	**argv;
d3349 1
a3349 3
cd_resume( argc, argv )
int	argc;
char	**argv;
d3361 1
a3361 3
cd_allocate( argc, argv )
int argc;
char **argv;
d3378 1
a3378 3
cd_restart( argc, argv )
int	argc;
char	**argv;
d3407 1
a3407 3
cd_reset( argc, argv )
int	argc;
char	**argv;
d3424 1
a3424 3
cd_attach( argc, argv )
int	argc;
char	**argv;
d3444 1
a3444 3
cd_release( argc, argv )
int	argc;
char	**argv;
d3485 1
a3485 3
cd_memprint( argc, argv)
int	argc;
char	**argv;
d3557 1
a3557 3
cd_status( argc, argv )
int	argc;
char	**argv;
d3622 1
a3622 3
cd_clear( argc, argv )
int	argc;
char	**argv;
d3631 1
a3631 3
cd_print( argc, argv )
int	argc;
char	**argv;
d3651 1
a3651 3
cd_go( argc, argv )
int	argc;
char	**argv;
d3658 1
a3658 3
cd_wait( argc, argv )
int	argc;
char	**argv;
d3694 1
a3694 3
cd_help( argc, argv )
int	argc;
char	**argv;
d3710 1
a3710 3
cd_host( argc, argv )
int	argc;
char	**argv;
d3808 1
a3808 3
cd_exit( argc, argv )
int	argc;
char	**argv;
d3825 1
a3825 3
cd_EOFrame( argc, argv )
int	argc;
char	**argv;
@


11.35
log
@removed rdebug int since liboptical provides it now
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1989 by the United States Army.
d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/remrt/remrt.c,v 11.34 2002/08/20 17:08:37 jra Exp $ (BRL)";
@


11.35.2.1
log
@more explicit testing on HAVE pp var
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/remrt/remrt.c,v 11.35 2003/09/27 00:59:22 morrison Exp $ (BRL)";
d92 1
a92 1
#if !defined(HAVE_VFORK) || HAVE_VFORK==0
@


11.35.2.2
log
@merge from HEAD
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1989-2004 by the United States Army.
d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/remrt/remrt.c,v 11.36 2004/02/02 17:39:38 morrison Exp $ (BRL)";
@


11.35.2.3
log
@merge from head
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/remrt/remrt.c,v 11.35.2.2 2004/02/12 19:40:28 erikg Exp $ (BRL)";
d92 1
a92 1
#ifndef HAVE_VFORK
@


11.34
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/remrt/remrt.c,v 11.32 2001/10/24 00:50:02 morrison Exp $ (BRL)";
a384 1
int		rdebug;
@


11.34.4.1
log
@sync to HEAD...
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1989-2004 by the United States Army.
d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/remrt/remrt.c,v 11.36 2004/02/02 17:39:38 morrison Exp $ (BRL)";
d385 1
@


11.34.2.1
log
@Initial ANSIfication
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/remrt/remrt.c,v 11.34 2002/08/20 17:08:37 jra Exp $ (BRL)";
d102 19
a120 123
struct frame {
	struct frame	*fr_forw;
	struct frame	*fr_back;
	int		fr_magic;	/* magic number */
	long		fr_number;	/* frame number */
	long		fr_server;	/* server number assigned. */
	char		*fr_filename;	/* name of output file */
	int		fr_tempfile;	/* if !0, output file is temporary */
	/* options */
	int		fr_width;	/* frame width (pixels) */
	int		fr_height;	/* frame height (pixels) */
	struct bu_list	fr_todo;	/* work still to be done */
	/* Timings */
	struct timeval	fr_start;	/* start time */
	struct timeval	fr_end;		/* end time */
	long		fr_nrays;	/* rays fired so far */
	double		fr_cpu;		/* CPU seconds used so far */
	/* Current view */
	struct bu_vls	fr_cmd;		/* RT options & command string */
	int		fr_needgettree; /* Do we need a gettree message */
	struct bu_vls	fr_after_cmd;	/* local commands, after frame done */
};

/*
 *  In order to preserve asynchrony, each server is marched through
 *  a series of state transitions.
 *  Each transition is triggered by some event being satisfied.
 *  The valid state transition sequences are:
 *
 *  If a "transient" server shows up, just to send in one command:
 *
 *	Original	New		Event
 *	--------	-----		-----
 *	UNUSED		NEW		connection rcvd
 *	NEW		CLOSING		ph_cmd pkg rcvd.
 *	CLOSING		UNUSED		next schedule() pass closes conn.
 *
 *  If a "permanent" server shows up:
 *
 *	Original	New		Event
 *	--------	-----		-----
 *	UNUSED		NEW		connection rcvd
 *	NEW		VERSOK		ph_version pkg rcvd.
 *					Optionally send loglvl & "cd" cmds.
 *	VERSOK		DOING_DIRBUILD	MSG_DIRBUILD sent
 *	DOING_DIRBUILD	READY		MSG_DIRBUILD_REPLY rcvd
 *
 * --	READY		DOING_GETTREES	new frame:  send_gettrees(), send_matrix()
 *	DOING_GETTREES	READY		MSG_GETTREES_REPLY rcvd
 *
 * --	READY		READY		call send_do_lines(),
 *					receive ph_pixels pkg.
 *
 * --	READY		CLOSING		drop_server called.  Requeue work.
 *	CLOSING		UNUSED		next schedule() pass closes conn.
 *
 * XXX need to split sending of db name & the treetops.
 * XXX treetops need to be resent at start of each frame.
 * XXX should probably re-vamp send_matrix routine.
 */
#define NFD 32
#ifdef FD_SETSIZE
#define MAXSERVERS	FD_SETSIZE
#else
#define MAXSERVERS	NFD		/* No relay function yet */
#endif


struct servers {
	struct pkg_conn	*sr_pc;		/* PKC_NULL means slot not in use */
	struct bu_list	sr_work;
	struct ihost	*sr_host;	/* description of this host */
	int		sr_lump;	/* # lines to send at once */
	int		sr_state;	/* Server state, SRST_xxx */
#define SRST_UNUSED		0	/* unused slot */
#define SRST_NEW		1	/* connected, awaiting vers check */
#define SRST_VERSOK		2	/* version OK, no model loaded yet */
#define SRST_DOING_DIRBUILD	3	/* doing dirbuild, awaiting response */
#define SRST_NEED_TREE		4	/* need our first gettree */
#define SRST_READY		5	/* loaded, ready */
#define SRST_RESTART		6	/* about to restart */
#define SRST_CLOSING		7	/* Needs to be closed */
#define SRST_DOING_GETTREES	8	/* doing gettrees */
	struct frame	*sr_curframe;	/* ptr to current frame */
	/* Timings */
	struct timeval	sr_sendtime;	/* time of last sending */
	double		sr_l_elapsed;	/* last: elapsed_sec */
	double		sr_l_el_rate;	/* last: pix/elapsed_sec */
	double		sr_w_elapsed;	/* weighted avg: pix/elapsed_sec */
	double		sr_w_rays;	/* weighted avg: rays/elapsed_sec */
	double		sr_s_elapsed;	/* sum of pix/elapsed_sec */
	double		sr_sq_elapsed;	/* sum of pix/elapsed_sec squared */
	double		sr_l_cpu;	/* cpu_sec for last scanline */
	double		sr_s_cpu;	/* sum of all cpu times */
	double		sr_s_pix;	/* sum of all pixels */
	double		sr_s_e;		/* sum of all elapsed seconds */
	double		sr_s_sq_cpu;	/* sum of cpu times squared */
	double		sr_s_sq_pix;	/* sum of pixels squared */
	double		sr_s_sq_e;	/* sum of all elapsed seceonds squared */
	int		sr_nsamp;	/* number of samples summed over */
	double		sr_prep_cpu;	/* sum of cpu time for preps */
	double		sr_l_percent;	/* last: percent of CPU */
} servers[MAXSERVERS];

void		read_rc_file(void);
void		check_input(int waittime);
void		addclient(struct pkg_conn *pc);
void		start_servers(struct timeval *nowp);
void		eat_script(FILE *fp);
void		interactive_cmd(FILE *fp);
void		prep_frame(register struct frame *fr);
void		frame_is_done(register struct frame *fr);
void		destroy_frame(register struct frame *fr);
void		schedule(struct timeval *nowp);
void		list_remove(register struct bu_list *lhp, int a, int b);
void		write_fb(unsigned char *pp, struct frame *fr, int a, int b);
void		repaint_fb(register struct frame *fr);
void		size_display(register struct frame *fr);
void		send_dirbuild(register struct servers *sp);
void		send_gettrees(struct servers *sp, register struct frame *fr);
void		send_restart(register struct servers *sp);
void		send_loglvl(register struct servers *sp);
void		send_matrix(struct servers *sp, register struct frame *fr);
d122 10
a131 10
void		pr_list(register struct bu_list *lhp);
void		mathtab_constant(void);
void		add_host(struct ihost *ihp);
void		host_helper(FILE *fp);
void		start_helper(void);
void		build_start_cmd(int argc, char **argv, int startc);
void		drop_server(register struct servers *sp, char *why);
void		send_do_lines(register struct servers *sp, int start, int stop, int framenum);
void		do_work(int auto_start);
void		source(FILE *fp);
d145 7
a151 7
void	ph_default(register struct pkg_conn *pc, char *buf);	/* foobar message handler */
void	ph_pixels(register struct pkg_conn *pc, char *buf);
void	ph_print(register struct pkg_conn *pc, char *buf);
void	ph_dirbuild_reply(register struct pkg_conn *pc, char *buf);
void	ph_gettrees_reply(register struct pkg_conn *pc, char *buf);
void	ph_version(register struct pkg_conn *pc, char *buf);
void	ph_cmd(register struct pkg_conn *pc, char *buf);
d171 7
d210 22
d290 74
d438 2
a439 1
tvsub(struct timeval *tdiff, struct timeval *t1, struct timeval *t0)
d454 2
a455 1
tvdiff(struct timeval *t1, struct timeval *t0)
d468 1
a468 1
stamp(void)
d490 2
a491 1
state_to_string(int state)
d523 3
a525 1
statechange(register struct servers *sp, int newstate)
d541 3
a543 1
main(int argc, char **argv)
d672 2
a673 1
do_work(int auto_start)
d726 1
a726 1
read_rc_file(void)
d752 2
a753 1
check_input(int waittime)
d831 2
a832 1
addclient(struct pkg_conn *pc)
d887 3
a889 1
drop_server(register struct servers *sp, char *why)
d953 2
a954 1
start_servers(struct timeval *nowp)
d1102 2
a1103 1
eat_script(FILE *fp)
d1224 2
a1225 1
string2int(register char *str)
d1244 2
a1245 1
get_server_by_name(char *str)
d1271 2
a1272 1
interactive_cmd(FILE *fp)
d1328 2
a1329 1
prep_frame(register struct frame *fr)
d1377 1
a1377 1
do_a_frame(void)
d1415 2
a1416 1
scan_frame_for_finished_pixels(register struct frame *fr)
d1539 2
a1540 1
frame_is_done(register struct frame *fr)
d1599 2
a1600 1
destroy_frame(register struct frame *fr)
d1641 2
a1642 1
this_frame_done(register struct frame *fr)
d1670 1
a1670 1
all_servers_idle(void)
d1695 1
a1695 1
all_done(void)
d1732 2
a1733 1
schedule(struct timeval *nowp)
d1865 1
a1865 1
number_of_ready_servers(void)
d1891 1
a1891 1
assignment_time(void)
d2093 3
a2095 1
read_matrix(register FILE *fp, register struct frame *fr)
d2139 3
a2141 1
ph_default(register struct pkg_conn *pc, char *buf)
d2162 3
a2164 1
ph_dirbuild_reply(register struct pkg_conn *pc, char *buf)
d2194 3
a2196 1
ph_gettrees_reply(register struct pkg_conn *pc, char *buf)
d2223 3
a2225 1
ph_print(register struct pkg_conn *pc, char *buf)
d2242 3
a2244 1
ph_version(register struct pkg_conn *pc, char *buf)
d2269 3
a2271 1
ph_cmd(register struct pkg_conn *pc, char *buf)
d2288 3
a2290 1
ph_pixels(register struct pkg_conn *pc, char *buf)
d2509 3
a2511 1
list_remove(register struct bu_list *lhp, int a, int b)
d2556 5
a2560 1
write_fb(unsigned char *pp, struct frame *fr, int a, int b)
d2617 2
a2618 1
repaint_fb(register struct frame *fr)
d2690 2
a2691 1
size_display(register struct frame *fr)
d2717 2
a2718 1
send_dirbuild(register struct servers *sp)
d2755 2
a2756 1
send_restart(register struct servers *sp)
d2769 2
a2770 1
send_loglvl(register struct servers *sp)
d2784 3
a2786 1
send_matrix(struct servers *sp, register struct frame *fr)
d2802 3
a2804 1
send_gettrees(struct servers *sp, register struct frame *fr)
d2821 5
a2825 1
send_do_lines(register struct servers *sp, int start, int stop, int framenum)
d2842 2
a2843 1
pr_list(register struct bu_list *lhp)
d2860 1
a2860 1
mathtab_constant(void)
d2873 2
a2874 1
add_host(struct ihost *ihp)
d2932 2
a2933 1
host_helper(FILE *fp)
d3037 1
a3037 1
start_helper(void)
d3076 4
a3079 1
build_start_cmd(int argc, char **argv, int startc)
d3114 3
a3116 1
cd_load(int argc, char **argv)
d3144 3
a3146 1
cd_debug(int argc, char **argv)
d3164 3
a3166 1
cd_rdebug(int argc, char **argv)
d3185 3
a3187 1
cd_f(int argc, char **argv)
d3199 3
a3201 1
cd_S(int argc, char **argv)
d3214 3
a3216 1
cd_N(int argc, char **argv)
d3227 3
a3229 1
cd_hyper(int argc, char **argv)
d3237 3
a3239 1
cd_bench(int argc, char **argv)
d3247 3
a3249 1
cd_persp(int argc, char **argv)
d3258 3
a3260 1
cd_read(int argc, char **argv)
d3275 2
a3276 1
source(FILE *fp)
d3287 3
a3289 1
cd_detach(int argc, char **argv)
d3298 3
a3300 1
cd_file(int argc, char **argv)
d3313 3
a3315 1
cd_mat(int argc, char **argv)
d3353 3
a3355 1
cd_movie(int argc, char **argv)
d3409 3
a3411 1
cd_add(int argc, char **argv)
d3425 3
a3427 1
cd_drop(int argc, char **argv)
d3438 3
a3440 1
cd_hold(int argc, char **argv)
d3456 3
a3458 1
cd_resume(int argc, char **argv)
d3470 3
a3472 1
cd_allocate(int argc, char **argv)
d3489 3
a3491 1
cd_restart(int argc, char **argv)
d3520 3
a3522 1
cd_reset(int argc, char **argv)
d3539 3
a3541 1
cd_attach(int argc, char **argv)
d3561 3
a3563 1
cd_release(int argc, char **argv)
d3604 3
a3606 1
cd_memprint(int argc, char **argv)
d3678 3
a3680 1
cd_status(int argc, char **argv)
d3745 3
a3747 1
cd_clear(int argc, char **argv)
d3756 3
a3758 1
cd_print(int argc, char **argv)
d3778 3
a3780 1
cd_go(int argc, char **argv)
d3787 3
a3789 1
cd_wait(int argc, char **argv)
d3825 3
a3827 1
cd_help(int argc, char **argv)
d3843 3
a3845 1
cd_host(int argc, char **argv)
d3943 3
a3945 1
cd_exit(int argc, char **argv)
d3962 3
a3964 1
cd_EOFrame(int argc, char **argv)
@


11.34.2.2
log
@removed the os x BSD temp undefine blocks
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/remrt/remrt.c,v 11.34.2.1 2002/09/19 18:02:14 morrison Exp $ (BRL)";
d33 4
d38 4
@


11.34.2.3
log
@sync branch with HEAD
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1989-2004 by the United States Army.
d23 1
a23 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d378 1
@


11.33
log
@Converted from K&R to ANSI C - RFH
@
text
@d102 19
a120 123
struct frame {
	struct frame	*fr_forw;
	struct frame	*fr_back;
	int		fr_magic;	/* magic number */
	long		fr_number;	/* frame number */
	long		fr_server;	/* server number assigned. */
	char		*fr_filename;	/* name of output file */
	int		fr_tempfile;	/* if !0, output file is temporary */
	/* options */
	int		fr_width;	/* frame width (pixels) */
	int		fr_height;	/* frame height (pixels) */
	struct bu_list	fr_todo;	/* work still to be done */
	/* Timings */
	struct timeval	fr_start;	/* start time */
	struct timeval	fr_end;		/* end time */
	long		fr_nrays;	/* rays fired so far */
	double		fr_cpu;		/* CPU seconds used so far */
	/* Current view */
	struct bu_vls	fr_cmd;		/* RT options & command string */
	int		fr_needgettree; /* Do we need a gettree message */
	struct bu_vls	fr_after_cmd;	/* local commands, after frame done */
};

/*
 *  In order to preserve asynchrony, each server is marched through
 *  a series of state transitions.
 *  Each transition is triggered by some event being satisfied.
 *  The valid state transition sequences are:
 *
 *  If a "transient" server shows up, just to send in one command:
 *
 *	Original	New		Event
 *	--------	-----		-----
 *	UNUSED		NEW		connection rcvd
 *	NEW		CLOSING		ph_cmd pkg rcvd.
 *	CLOSING		UNUSED		next schedule() pass closes conn.
 *
 *  If a "permanent" server shows up:
 *
 *	Original	New		Event
 *	--------	-----		-----
 *	UNUSED		NEW		connection rcvd
 *	NEW		VERSOK		ph_version pkg rcvd.
 *					Optionally send loglvl & "cd" cmds.
 *	VERSOK		DOING_DIRBUILD	MSG_DIRBUILD sent
 *	DOING_DIRBUILD	READY		MSG_DIRBUILD_REPLY rcvd
 *
 * --	READY		DOING_GETTREES	new frame:  send_gettrees(), send_matrix()
 *	DOING_GETTREES	READY		MSG_GETTREES_REPLY rcvd
 *
 * --	READY		READY		call send_do_lines(),
 *					receive ph_pixels pkg.
 *
 * --	READY		CLOSING		drop_server called.  Requeue work.
 *	CLOSING		UNUSED		next schedule() pass closes conn.
 *
 * XXX need to split sending of db name & the treetops.
 * XXX treetops need to be resent at start of each frame.
 * XXX should probably re-vamp send_matrix routine.
 */
#define NFD 32
#ifdef FD_SETSIZE
#define MAXSERVERS	FD_SETSIZE
#else
#define MAXSERVERS	NFD		/* No relay function yet */
#endif


struct servers {
	struct pkg_conn	*sr_pc;		/* PKC_NULL means slot not in use */
	struct bu_list	sr_work;
	struct ihost	*sr_host;	/* description of this host */
	int		sr_lump;	/* # lines to send at once */
	int		sr_state;	/* Server state, SRST_xxx */
#define SRST_UNUSED		0	/* unused slot */
#define SRST_NEW		1	/* connected, awaiting vers check */
#define SRST_VERSOK		2	/* version OK, no model loaded yet */
#define SRST_DOING_DIRBUILD	3	/* doing dirbuild, awaiting response */
#define SRST_NEED_TREE		4	/* need our first gettree */
#define SRST_READY		5	/* loaded, ready */
#define SRST_RESTART		6	/* about to restart */
#define SRST_CLOSING		7	/* Needs to be closed */
#define SRST_DOING_GETTREES	8	/* doing gettrees */
	struct frame	*sr_curframe;	/* ptr to current frame */
	/* Timings */
	struct timeval	sr_sendtime;	/* time of last sending */
	double		sr_l_elapsed;	/* last: elapsed_sec */
	double		sr_l_el_rate;	/* last: pix/elapsed_sec */
	double		sr_w_elapsed;	/* weighted avg: pix/elapsed_sec */
	double		sr_w_rays;	/* weighted avg: rays/elapsed_sec */
	double		sr_s_elapsed;	/* sum of pix/elapsed_sec */
	double		sr_sq_elapsed;	/* sum of pix/elapsed_sec squared */
	double		sr_l_cpu;	/* cpu_sec for last scanline */
	double		sr_s_cpu;	/* sum of all cpu times */
	double		sr_s_pix;	/* sum of all pixels */
	double		sr_s_e;		/* sum of all elapsed seconds */
	double		sr_s_sq_cpu;	/* sum of cpu times squared */
	double		sr_s_sq_pix;	/* sum of pixels squared */
	double		sr_s_sq_e;	/* sum of all elapsed seceonds squared */
	int		sr_nsamp;	/* number of samples summed over */
	double		sr_prep_cpu;	/* sum of cpu time for preps */
	double		sr_l_percent;	/* last: percent of CPU */
} servers[MAXSERVERS];

void		read_rc_file(void);
void		check_input(int waittime);
void		addclient(struct pkg_conn *pc);
void		start_servers(struct timeval *nowp);
void		eat_script(FILE *fp);
void		interactive_cmd(FILE *fp);
void		prep_frame(register struct frame *fr);
void		frame_is_done(register struct frame *fr);
void		destroy_frame(register struct frame *fr);
void		schedule(struct timeval *nowp);
void		list_remove(register struct bu_list *lhp, int a, int b);
void		write_fb(unsigned char *pp, struct frame *fr, int a, int b);
void		repaint_fb(register struct frame *fr);
void		size_display(register struct frame *fr);
void		send_dirbuild(register struct servers *sp);
void		send_gettrees(struct servers *sp, register struct frame *fr);
void		send_restart(register struct servers *sp);
void		send_loglvl(register struct servers *sp);
void		send_matrix(struct servers *sp, register struct frame *fr);
d122 10
a131 10
void		pr_list(register struct bu_list *lhp);
void		mathtab_constant(void);
void		add_host(struct ihost *ihp);
void		host_helper(FILE *fp);
void		start_helper(void);
void		build_start_cmd(int argc, char **argv, int startc);
void		drop_server(register struct servers *sp, char *why);
void		send_do_lines(register struct servers *sp, int start, int stop, int framenum);
void		do_work(int auto_start);
void		source(FILE *fp);
d145 7
a151 7
void	ph_default(register struct pkg_conn *pc, char *buf);	/* foobar message handler */
void	ph_pixels(register struct pkg_conn *pc, char *buf);
void	ph_print(register struct pkg_conn *pc, char *buf);
void	ph_dirbuild_reply(register struct pkg_conn *pc, char *buf);
void	ph_gettrees_reply(register struct pkg_conn *pc, char *buf);
void	ph_version(register struct pkg_conn *pc, char *buf);
void	ph_cmd(register struct pkg_conn *pc, char *buf);
d171 7
d210 22
d290 74
d438 2
a439 1
tvsub(struct timeval *tdiff, struct timeval *t1, struct timeval *t0)
d454 2
a455 1
tvdiff(struct timeval *t1, struct timeval *t0)
d468 1
a468 1
stamp(void)
d490 2
a491 1
state_to_string(int state)
d523 3
a525 1
statechange(register struct servers *sp, int newstate)
d541 3
a543 1
main(int argc, char **argv)
d672 2
a673 1
do_work(int auto_start)
d726 1
a726 1
read_rc_file(void)
d752 2
a753 1
check_input(int waittime)
d831 2
a832 1
addclient(struct pkg_conn *pc)
d887 3
a889 1
drop_server(register struct servers *sp, char *why)
d953 2
a954 1
start_servers(struct timeval *nowp)
d1102 2
a1103 1
eat_script(FILE *fp)
d1224 2
a1225 1
string2int(register char *str)
d1244 2
a1245 1
get_server_by_name(char *str)
d1271 2
a1272 1
interactive_cmd(FILE *fp)
d1328 2
a1329 1
prep_frame(register struct frame *fr)
d1377 1
a1377 1
do_a_frame(void)
d1415 2
a1416 1
scan_frame_for_finished_pixels(register struct frame *fr)
d1539 2
a1540 1
frame_is_done(register struct frame *fr)
d1599 2
a1600 1
destroy_frame(register struct frame *fr)
d1641 2
a1642 1
this_frame_done(register struct frame *fr)
d1670 1
a1670 1
all_servers_idle(void)
d1695 1
a1695 1
all_done(void)
d1732 2
a1733 1
schedule(struct timeval *nowp)
d1865 1
a1865 1
number_of_ready_servers(void)
d1891 1
a1891 1
assignment_time(void)
d2093 3
a2095 1
read_matrix(register FILE *fp, register struct frame *fr)
d2139 3
a2141 1
ph_default(register struct pkg_conn *pc, char *buf)
d2162 3
a2164 1
ph_dirbuild_reply(register struct pkg_conn *pc, char *buf)
d2194 3
a2196 1
ph_gettrees_reply(register struct pkg_conn *pc, char *buf)
d2223 3
a2225 1
ph_print(register struct pkg_conn *pc, char *buf)
d2242 3
a2244 1
ph_version(register struct pkg_conn *pc, char *buf)
d2269 3
a2271 1
ph_cmd(register struct pkg_conn *pc, char *buf)
d2288 3
a2290 1
ph_pixels(register struct pkg_conn *pc, char *buf)
d2509 3
a2511 1
list_remove(register struct bu_list *lhp, int a, int b)
d2556 5
a2560 1
write_fb(unsigned char *pp, struct frame *fr, int a, int b)
d2617 2
a2618 1
repaint_fb(register struct frame *fr)
d2690 2
a2691 1
size_display(register struct frame *fr)
d2717 2
a2718 1
send_dirbuild(register struct servers *sp)
d2755 2
a2756 1
send_restart(register struct servers *sp)
d2769 2
a2770 1
send_loglvl(register struct servers *sp)
d2784 3
a2786 1
send_matrix(struct servers *sp, register struct frame *fr)
d2802 3
a2804 1
send_gettrees(struct servers *sp, register struct frame *fr)
d2821 5
a2825 1
send_do_lines(register struct servers *sp, int start, int stop, int framenum)
d2842 2
a2843 1
pr_list(register struct bu_list *lhp)
d2860 1
a2860 1
mathtab_constant(void)
d2873 2
a2874 1
add_host(struct ihost *ihp)
d2932 2
a2933 1
host_helper(FILE *fp)
d3037 1
a3037 1
start_helper(void)
d3076 4
a3079 1
build_start_cmd(int argc, char **argv, int startc)
d3114 3
a3116 1
cd_load(int argc, char **argv)
d3144 3
a3146 1
cd_debug(int argc, char **argv)
d3164 3
a3166 1
cd_rdebug(int argc, char **argv)
d3185 3
a3187 1
cd_f(int argc, char **argv)
d3199 3
a3201 1
cd_S(int argc, char **argv)
d3214 3
a3216 1
cd_N(int argc, char **argv)
d3227 3
a3229 1
cd_hyper(int argc, char **argv)
d3237 3
a3239 1
cd_bench(int argc, char **argv)
d3247 3
a3249 1
cd_persp(int argc, char **argv)
d3258 3
a3260 1
cd_read(int argc, char **argv)
d3275 2
a3276 1
source(FILE *fp)
d3287 3
a3289 1
cd_detach(int argc, char **argv)
d3298 3
a3300 1
cd_file(int argc, char **argv)
d3313 3
a3315 1
cd_mat(int argc, char **argv)
d3353 3
a3355 1
cd_movie(int argc, char **argv)
d3409 3
a3411 1
cd_add(int argc, char **argv)
d3425 3
a3427 1
cd_drop(int argc, char **argv)
d3438 3
a3440 1
cd_hold(int argc, char **argv)
d3456 3
a3458 1
cd_resume(int argc, char **argv)
d3470 3
a3472 1
cd_allocate(int argc, char **argv)
d3489 3
a3491 1
cd_restart(int argc, char **argv)
d3520 3
a3522 1
cd_reset(int argc, char **argv)
d3539 3
a3541 1
cd_attach(int argc, char **argv)
d3561 3
a3563 1
cd_release(int argc, char **argv)
d3604 3
a3606 1
cd_memprint(int argc, char **argv)
d3678 3
a3680 1
cd_status(int argc, char **argv)
d3745 3
a3747 1
cd_clear(int argc, char **argv)
d3756 3
a3758 1
cd_print(int argc, char **argv)
d3778 3
a3780 1
cd_go(int argc, char **argv)
d3787 3
a3789 1
cd_wait(int argc, char **argv)
d3825 3
a3827 1
cd_help(int argc, char **argv)
d3843 3
a3845 1
cd_host(int argc, char **argv)
d3943 3
a3945 1
cd_exit(int argc, char **argv)
d3962 3
a3964 1
cd_EOFrame(int argc, char **argv)
@


11.32
log
@*** empty log message ***
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/remrt/remrt.c,v 11.31 2001/10/17 07:40:06 morrison Exp $ (BRL)";
d102 123
a224 19
void		read_rc_file();
void		check_input();
void		addclient();
void		start_servers();
void		eat_script();
void		interactive_cmd();
void		prep_frame();
void		frame_is_done();
void		destroy_frame();
void		schedule();
void		list_remove();
void		write_fb();
void		repaint_fb();
void		size_display();
void		send_dirbuild();
void		send_gettrees();
void		send_restart();
void		send_loglvl();
void		send_matrix();
d226 10
a235 10
void		pr_list();
void		mathtab_constant();
void		add_host();
void		host_helper();
void		start_helper();
void		build_start_cmd();
void		drop_server();
void		send_do_lines();
void		do_work();
void		source();
d249 7
a255 7
void	ph_default();	/* foobar message handler */
void	ph_pixels();
void	ph_print();
void	ph_dirbuild_reply();
void	ph_gettrees_reply();
void	ph_version();
void	ph_cmd();
a274 7
#define NFD 32
#ifdef FD_SETSIZE
#define MAXSERVERS	FD_SETSIZE
#else
#define MAXSERVERS	NFD		/* No relay function yet */
#endif

a306 22
struct frame {
	struct frame	*fr_forw;
	struct frame	*fr_back;
	int		fr_magic;	/* magic number */
	long		fr_number;	/* frame number */
	long		fr_server;	/* server number assigned. */
	char		*fr_filename;	/* name of output file */
	int		fr_tempfile;	/* if !0, output file is temporary */
	/* options */
	int		fr_width;	/* frame width (pixels) */
	int		fr_height;	/* frame height (pixels) */
	struct bu_list	fr_todo;	/* work still to be done */
	/* Timings */
	struct timeval	fr_start;	/* start time */
	struct timeval	fr_end;		/* end time */
	long		fr_nrays;	/* rays fired so far */
	double		fr_cpu;		/* CPU seconds used so far */
	/* Current view */
	struct bu_vls	fr_cmd;		/* RT options & command string */
	int		fr_needgettree; /* Do we need a gettree message */
	struct bu_vls	fr_after_cmd;	/* local commands, after frame done */
};
a364 74

/*
 *  In order to preserve asynchrony, each server is marched through
 *  a series of state transitions.
 *  Each transition is triggered by some event being satisfied.
 *  The valid state transition sequences are:
 *
 *  If a "transient" server shows up, just to send in one command:
 *
 *	Original	New		Event
 *	--------	-----		-----
 *	UNUSED		NEW		connection rcvd
 *	NEW		CLOSING		ph_cmd pkg rcvd.
 *	CLOSING		UNUSED		next schedule() pass closes conn.
 *
 *  If a "permanent" server shows up:
 *
 *	Original	New		Event
 *	--------	-----		-----
 *	UNUSED		NEW		connection rcvd
 *	NEW		VERSOK		ph_version pkg rcvd.
 *					Optionally send loglvl & "cd" cmds.
 *	VERSOK		DOING_DIRBUILD	MSG_DIRBUILD sent
 *	DOING_DIRBUILD	READY		MSG_DIRBUILD_REPLY rcvd
 *
 * --	READY		DOING_GETTREES	new frame:  send_gettrees(), send_matrix()
 *	DOING_GETTREES	READY		MSG_GETTREES_REPLY rcvd
 *
 * --	READY		READY		call send_do_lines(),
 *					receive ph_pixels pkg.
 *
 * --	READY		CLOSING		drop_server called.  Requeue work.
 *	CLOSING		UNUSED		next schedule() pass closes conn.
 *
 * XXX need to split sending of db name & the treetops.
 * XXX treetops need to be resent at start of each frame.
 * XXX should probably re-vamp send_matrix routine.
 */

struct servers {
	struct pkg_conn	*sr_pc;		/* PKC_NULL means slot not in use */
	struct bu_list	sr_work;
	struct ihost	*sr_host;	/* description of this host */
	int		sr_lump;	/* # lines to send at once */
	int		sr_state;	/* Server state, SRST_xxx */
#define SRST_UNUSED		0	/* unused slot */
#define SRST_NEW		1	/* connected, awaiting vers check */
#define SRST_VERSOK		2	/* version OK, no model loaded yet */
#define SRST_DOING_DIRBUILD	3	/* doing dirbuild, awaiting response */
#define SRST_NEED_TREE		4	/* need our first gettree */
#define SRST_READY		5	/* loaded, ready */
#define SRST_RESTART		6	/* about to restart */
#define SRST_CLOSING		7	/* Needs to be closed */
#define SRST_DOING_GETTREES	8	/* doing gettrees */
	struct frame	*sr_curframe;	/* ptr to current frame */
	/* Timings */
	struct timeval	sr_sendtime;	/* time of last sending */
	double		sr_l_elapsed;	/* last: elapsed_sec */
	double		sr_l_el_rate;	/* last: pix/elapsed_sec */
	double		sr_w_elapsed;	/* weighted avg: pix/elapsed_sec */
	double		sr_w_rays;	/* weighted avg: rays/elapsed_sec */
	double		sr_s_elapsed;	/* sum of pix/elapsed_sec */
	double		sr_sq_elapsed;	/* sum of pix/elapsed_sec squared */
	double		sr_l_cpu;	/* cpu_sec for last scanline */
	double		sr_s_cpu;	/* sum of all cpu times */
	double		sr_s_pix;	/* sum of all pixels */
	double		sr_s_e;		/* sum of all elapsed seconds */
	double		sr_s_sq_cpu;	/* sum of cpu times squared */
	double		sr_s_sq_pix;	/* sum of pixels squared */
	double		sr_s_sq_e;	/* sum of all elapsed seceonds squared */
	int		sr_nsamp;	/* number of samples summed over */
	double		sr_prep_cpu;	/* sum of cpu time for preps */
	double		sr_l_percent;	/* last: percent of CPU */
} servers[MAXSERVERS];
d439 1
a439 2
tvsub(tdiff, t1, t0)
struct timeval *tdiff, *t1, *t0;
d454 1
a454 2
tvdiff(t1, t0)
struct timeval	*t1, *t0;
d467 1
a467 1
stamp()
d489 1
a489 2
state_to_string( state )
int	state;
d521 1
a521 3
statechange( sp, newstate )
register struct servers *sp;
int	newstate;
d537 1
a537 3
main(argc, argv)
int	argc;
char	**argv;
d666 1
a666 2
do_work(auto_start)
int	auto_start;
d719 1
a719 1
read_rc_file()
d745 1
a745 2
check_input(waittime)
int waittime;
d823 1
a823 2
addclient(pc)
struct pkg_conn *pc;
d878 1
a878 3
drop_server(sp, why)
register struct servers	*sp;
char	*why;
d942 1
a942 2
start_servers( nowp )
struct timeval	*nowp;
d1090 1
a1090 2
eat_script( fp )
FILE	*fp;
d1211 1
a1211 2
string2int(str)
register char *str;
d1230 1
a1230 2
get_server_by_name( str )
char *str;
d1256 1
a1256 2
interactive_cmd(fp)
FILE *fp;
d1312 1
a1312 2
prep_frame(fr)
register struct frame *fr;
d1360 1
a1360 1
do_a_frame()
d1398 1
a1398 2
scan_frame_for_finished_pixels( fr )
register struct frame	*fr;
d1521 1
a1521 2
frame_is_done(fr)
register struct frame *fr;
d1580 1
a1580 2
destroy_frame( fr )
register struct frame	*fr;
d1621 1
a1621 2
this_frame_done( fr )
register struct frame	*fr;
d1649 1
a1649 1
all_servers_idle()
d1674 1
a1674 1
all_done()
d1711 1
a1711 2
schedule( nowp )
struct timeval	*nowp;
d1843 1
a1843 1
number_of_ready_servers()
d1869 1
a1869 1
assignment_time()
d2071 1
a2071 3
read_matrix( fp, fr )
register FILE *fp;
register struct frame *fr;
d2115 1
a2115 3
ph_default(pc, buf)
register struct pkg_conn *pc;
char *buf;
d2136 1
a2136 3
ph_dirbuild_reply(pc, buf)
register struct pkg_conn *pc;
char *buf;
d2166 1
a2166 3
ph_gettrees_reply(pc, buf)
register struct pkg_conn *pc;
char *buf;
d2193 1
a2193 3
ph_print(pc, buf)
register struct pkg_conn *pc;
char *buf;
d2210 1
a2210 3
ph_version(pc, buf)
register struct pkg_conn *pc;
char	*buf;
d2235 1
a2235 3
ph_cmd(pc, buf)
register struct pkg_conn *pc;
char	*buf;
d2252 1
a2252 3
ph_pixels(pc, buf)
register struct pkg_conn *pc;
char *buf;
d2471 1
a2471 3
list_remove( lhp, a, b )
register struct bu_list *lhp;
int		a, b;
d2516 1
a2516 5
write_fb( pp, fr, a, b )
unsigned char 	*pp;
struct frame	*fr;
int		a;
int		b;
d2573 1
a2573 2
repaint_fb( fr )
register struct frame *fr;
d2645 1
a2645 2
size_display(fr)
register struct frame	*fr;
d2671 1
a2671 2
send_dirbuild(sp)
register struct servers *sp;
d2708 1
a2708 2
send_restart(sp)
register struct servers *sp;
d2721 1
a2721 2
send_loglvl(sp)
register struct servers *sp;
d2735 1
a2735 3
send_matrix(sp, fr)
struct servers *sp;
register struct frame *fr;
d2751 1
a2751 3
send_gettrees(sp, fr)
struct servers		*sp;
register struct frame	*fr;
d2768 1
a2768 5
send_do_lines( sp, start, stop, framenum )
register struct servers *sp;
int		start;
int		stop;
int		framenum;
d2785 1
a2785 2
pr_list( lhp )
register struct bu_list *lhp;
d2802 1
a2802 1
mathtab_constant()
d2815 1
a2815 2
add_host( ihp )
struct ihost	*ihp;
d2873 1
a2873 2
host_helper(fp)
FILE	*fp;
d2977 1
a2977 1
start_helper()
d3016 1
a3016 4
build_start_cmd( argc, argv, startc )
int	argc;
char	**argv;
int	startc;
d3051 1
a3051 3
cd_load( argc, argv )
int	argc;
char	**argv;
d3079 1
a3079 3
cd_debug( argc, argv )
int	argc;
char	**argv;
d3097 1
a3097 3
cd_rdebug( argc, argv )
int	argc;
char	**argv;
d3116 1
a3116 3
cd_f( argc, argv )
int	argc;
char	**argv;
d3128 1
a3128 3
cd_S( argc, argv )
int	argc;
char	**argv;
d3141 1
a3141 3
cd_N( argc, argv )
int	argc;
char	**argv;
d3152 1
a3152 3
cd_hyper( argc, argv )
int	argc;
char	**argv;
d3160 1
a3160 3
cd_bench( argc, argv )
int	argc;
char	**argv;
d3168 1
a3168 3
cd_persp( argc, argv )
int	argc;
char	**argv;
d3177 1
a3177 3
cd_read( argc, argv )
int	argc;
char	**argv;
d3192 1
a3192 2
source(fp)
FILE	*fp;
d3203 1
a3203 3
cd_detach( argc, argv )
int	argc;
char	**argv;
d3212 1
a3212 3
cd_file( argc, argv )
int	argc;
char	**argv;
d3225 1
a3225 3
cd_mat( argc, argv )
int	argc;
char	**argv;
d3263 1
a3263 3
cd_movie( argc, argv )
int	argc;
char	**argv;
d3317 1
a3317 3
cd_add( argc, argv )
int	argc;
char	**argv;
d3331 1
a3331 3
cd_drop( argc, argv )
int	argc;
char	**argv;
d3342 1
a3342 3
cd_hold( argc, argv )
int	argc;
char	**argv;
d3358 1
a3358 3
cd_resume( argc, argv )
int	argc;
char	**argv;
d3370 1
a3370 3
cd_allocate( argc, argv )
int argc;
char **argv;
d3387 1
a3387 3
cd_restart( argc, argv )
int	argc;
char	**argv;
d3416 1
a3416 3
cd_reset( argc, argv )
int	argc;
char	**argv;
d3433 1
a3433 3
cd_attach( argc, argv )
int	argc;
char	**argv;
d3453 1
a3453 3
cd_release( argc, argv )
int	argc;
char	**argv;
d3494 1
a3494 3
cd_memprint( argc, argv)
int	argc;
char	**argv;
d3566 1
a3566 3
cd_status( argc, argv )
int	argc;
char	**argv;
d3631 1
a3631 3
cd_clear( argc, argv )
int	argc;
char	**argv;
d3640 1
a3640 3
cd_print( argc, argv )
int	argc;
char	**argv;
d3660 1
a3660 3
cd_go( argc, argv )
int	argc;
char	**argv;
d3667 1
a3667 3
cd_wait( argc, argv )
int	argc;
char	**argv;
d3703 1
a3703 3
cd_help( argc, argv )
int	argc;
char	**argv;
d3719 1
a3719 3
cd_host( argc, argv )
int	argc;
char	**argv;
d3817 1
a3817 3
cd_exit( argc, argv )
int	argc;
char	**argv;
d3834 1
a3834 3
cd_EOFrame( argc, argv )
int	argc;
char	**argv;
@


11.31
log
@Mac OS X warning and error fixes for non-production build
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/remrt/remrt.c,v 11.30 2001/08/11 13:18:07 butler Exp $ (BRL)";
a38 1
#  undef BSD
@


11.30
log
@misc compiler warning changes
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/remrt/remrt.c,v 11.29 2001/07/19 23:45:29 morrison Exp $ (BRL)";
d31 6
d38 6
a43 1
#include <math.h>
d54 1
@


11.29
log
@removed socklen_t cast from getpeername() call (sgi doesn't use socklen_t)
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/remrt/remrt.c,v 11.28 2001/07/19 18:02:08 bparker Exp $ (BRL)";
d363 1
a363 1
extern int	jitter;
@


11.28
log
@*- mods to specially compile on sgi
 (i.e. this fixes a bug that prevented compiling on sgi)
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/remrt/remrt.c,v 11.27 2001/07/10 22:54:06 morrison Exp $ (BRL)";
d834 1
a834 1
#if defined(sgi)
a835 3
#else
	if (getpeername(fd, (struct sockaddr *)&from, (socklen_t *)&fromlen) < 0) {
#endif
@


11.27
log
@fixed linux "feature" with 7.1 where sys/time.h no longer includes time.h (and hence time and struct tm were not defined causing an Error).
also made -pedantic happy
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/remrt/remrt.c,v 11.26 2001/05/17 20:06:01 morrison Exp $ (BRL)";
d834 3
d838 1
@


11.26
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/remrt/remrt.c,v 11.25 2001/05/16 21:38:14 morrison Exp $ (BRL)";
d56 2
a57 1
#  include <sys/time.h>		/* includes <time.h> */
d834 1
a834 1
	if (getpeername(fd, (struct sockaddr *)&from, &fromlen) < 0) {
d1220 1
a1220 1
		cnt = sscanf( str+2, "%x", &ret );
d3139 1
a3139 1
		sscanf( argv[1], "%x", &rem_debug );
@


11.25
log
@PRODUCTION optimizations
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/remrt/remrt.c,v 11.24 2001/04/20 22:31:18 morrison Exp $ (BRL)";
d1334 1
a1334 1
		rt_g.debug, rdebug,
@


11.24
log
@CONST to const
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/remrt/remrt.c,v 11.23 2000/08/25 01:37:18 mike Exp $ (BRL)";
d248 1
a248 1
		bzero( (char *)(p), sizeof(struct frame) ); \
d853 1
a853 1
	bzero( (char *)sp, sizeof(*sp) );
@


11.23
log
@
lint
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/remrt/remrt.c,v 11.22 2000/08/24 22:23:25 mike Exp $ (BRL)";
d838 1
a838 1
	if (setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, (CONST char *)&on, sizeof (on)) < 0)
@


11.22
log
@
Fixed lint
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/remrt/remrt.c,v 11.21 2000/05/19 12:34:48 jra Exp $ (BRL)";
d1726 1
a1726 1
	int		nxt_frame;
@


11.21
log
@Added "save_overlaps" variable (used by do.c)
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/remrt/remrt.c,v 11.20 2000/01/31 15:12:12 jra Exp $ (BRL)";
d67 2
d70 1
a70 2
#include "rtstring.h"
#include "rtlist.h"
d74 1
a74 1
#include "externs.h"
d86 2
a87 2
	(char *)0, (char *)0, (char *)0,
		0,		0, 0	/* END */
d121 1
d410 12
d1031 1
a1031 2
is_night( tv )
struct timeval	*tv;
d1055 1
a1055 2
is_hackers_night( tv )
struct timeval	*tv;
d1470 1
a1470 2
create_outputfilename( fr )
register struct frame	*fr;
d1811 1
a1811 1
				if( (ret = task_server(fr,sp,nowp)) < 0 )  {
d1901 1
a1901 4
task_server( fr, sp, nowp )
register struct servers	*sp;
register struct frame	*fr;
struct timeval		*nowp;
d2057 1
a2057 2
server_q_len( sp )
register struct servers	*sp;
d2644 1
a2644 2
init_fb(name)
char *name;
d3130 1
d3150 1
d3171 1
d3185 1
d3200 1
d3213 1
d3223 1
d3233 1
d3244 1
d3273 1
d3284 1
d3299 1
d3339 1
d3395 1
d3411 1
d3424 1
d3442 1
d3475 1
a3475 1

d3498 2
a3499 3
cd_stop( argc, argv )
int	argc;
char	**argv;
d3506 1
d3525 1
d3547 1
d3564 2
a3565 3
cd_frames( argc, argv )
int	argc;
char	**argv;
d3590 1
d3610 2
a3611 3
cd_stat( argc, argv )
int	argc;
char	**argv;
d3664 1
d3731 1
d3742 1
d3764 1
d3773 1
d3811 1
d3829 1
d3929 1
d3948 1
d3965 44
a4008 44
	"load",	"file obj(s)",	"specify database and treetops",
		cd_load,	3, 99,
	"read", "file",		"source a command file",
		cd_read,	2, 2,
	"file", "name",		"base name for storing frames",
		cd_file,	2, 2,
	"mat", "file [frame]",	"read one matrix from file",
		cd_mat,		2, 3,
	"movie", "file start_frame end_frame",	"read movie",
		cd_movie,	4, 4,
	"add", "host(s)",	"attach to hosts",
		cd_add,		2, 99,
	"drop", "host",		"drop first instance of 'host'",
		cd_drop,	2, 2,
	"hold", "host",		"Hold a host from processing",
		cd_hold,	2, 2,
	"resume","host",	"resume a host processing",
		cd_resume,	2, 2,
	"allocteby", "allocateby", "Work allocation method",
		cd_allocate,	2, 2,
	"restart", "[host]",	"restart one or all hosts",
		cd_restart,	1, 2,
	"go", "",		"start scheduling frames",
		cd_go,		1, 1,
	"stop", "",		"stop scheduling work",
		cd_stop,	1, 1,
	"reset", "",		"purge frame list of all work",
		cd_reset,	1, 1,
	"frames", "[-v]",	"summarize waiting frames",
		cd_frames,	1, 2,
	"stat", "",		"brief worker status",
		cd_stat,	1, 1,
	"status", "",		"full worker status",
		cd_status,	1, 1,
	"detach", "",		"detatch from interactive keyboard",
		cd_detach,	1, 1,
	"host", "name always|night|passive|rs[ rays/sec]|passrs[ rays/sec] cd|convert path", "register server host",
		cd_host,	1, 6,
	"wait", "",		"wait for current work assignment to finish",
		cd_wait,	1, 1,
	"exit", "",		"terminate remrt",
		cd_exit,	1, 1,
	"EOFrame", "EOFrame command|'off'", "Run command/script on dispatcher at End Of Frame",
		cd_EOFrame,	2, 2,
d4010 10
a4019 10
	"attach", "[fb]",	"attach to frame buffer",
		cd_attach,	1, 2,
	"release", "",		"release frame buffer",
		cd_release,	1, 1,
	"clear", "",		"clear framebuffer",
		cd_clear,	1, 1,
	"S", "square_size",	"set square frame buffer size",
		cd_S,		2, 2,
	"N", "square_height",	"set height of frame buffer",
		cd_N,		2, 2,
d4021 18
a4038 18
	"debug", "[hex_flags]",	"set local debugging flag bits",
		cd_debug,	1, 2,
	"rdebug", "options",	"set remote debugging via 'opt' command",
		cd_rdebug,	2, 2,
	"f", "square_size",	"set square frame size",
		cd_f,		2, 2,
	"s", "square_size",	"set square frame size",
		cd_f,		2, 2,
	"-H", "hypersample",	"set number of hypersamples/pixel",
		cd_hyper,	2, 2,
	"-B", "0|1",		"set benchmark flag",
		cd_bench,	2, 2,
	"p", "angle",		"set perspective angle (degrees) 0=ortho",
		cd_persp,	2, 2,
	"print", "[0|1]",	"set/toggle remote message printing",
		cd_print,	1, 2,
	"memprint", "on|off|NULL",	"debug dump of memory usage",
		cd_memprint,	1, 2,
d4040 4
a4043 4
	"?", "",		"help",
		cd_help,	1, 1,
	(char *)0, (char *)0, (char *)0,
		0,		0, 0	/* END */
@


11.21.2.1
log
@Backporting bug fixes for release 5.4
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/remrt/remrt.c,v 11.21 2000/05/19 12:34:48 jra Exp $ (BRL)";
a63 4
#endif

#ifdef linux
#	include <time.h>
@


11.20
log
@Eliminated an unused variable
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/remrt/remrt.c,v 11.19 1999/12/30 05:49:09 butler Exp $ (BRL)";
d154 2
@


11.19
log
@additions for -v flag to rt
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/remrt/remrt.c,v 11.18 1998/09/14 15:59:22 bparker Exp $ (BRL)";
d862 1
a862 1
	register struct list	*lhp, *lp;
@


11.18
log
@*- fix typos
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/remrt/remrt.c,v 11.17 1998/08/21 19:59:35 mike Exp $ (BRL)";
d370 1
@


11.17
log
@Don't exect a system-wide remrtrc file, use the one in the home directory
and current directory instead.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/remrt/remrt.c,v 11.16 1998/03/24 01:22:57 mike Exp $ (BRL)";
d521 1
a521 1
	fprintf(stderr,"%s %s %s\n", stamp(), our_hostname, version+5 );
d1466 1
a1466 1
		sprintf( name, "%s.%d", outputfile, fr->fr_number );
d1469 1
a1469 1
		sprintf( name, "remrt.pix.%d", fr->fr_number );
d1522 1
a1522 1
	bu_log("%s Frame %d DONE: %g elapsed sec, %d rays/%g cpu sec\n",
d1546 1
a1546 1
		(void) sprintf(cmd,"%s %s %d",frame_script,fr->fr_filename,
@


11.16
log
@rt/opt.c was changed to use bu_getopt, needed to change references
here from optind to bu_optind.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/remrt.c,v 11.15 1998/03/24 01:04:17 mike Exp mike $ (BRL)";
a715 6
	}

	if( (fp = fopen("/usr/brlcad/etc/.remrtrc", "r")) != NULL )  {
		source(fp);
		fclose(fp);
		return;
@


11.15
log
@Added logging of server state changes when debugging is enabled.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/remrt.c,v 11.14 1997/12/04 01:59:42 mike Exp mike $ (BRL)";
d595 1
a595 1
		if( optind+2 > argc )  {
d599 1
a599 1
		build_start_cmd( argc, argv, optind );
@


11.14
log
@pointless comparison of unsigned integer with zero
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/remrt.c,v 11.13 1997/01/04 03:24:30 mike Exp mike $ (BRL)";
d467 2
d474 1
a474 1
		return("DirBuild");
d476 1
a476 1
		return("WaitTree");
d491 18
a844 1
	sp->sr_state = SRST_NEW;
d848 1
d878 1
a878 1
	sp->sr_state = SRST_CLOSING;
d1751 1
a1751 1
			sp->sr_state = SRST_UNUSED;
d2166 1
a2166 1
	sp->sr_state = SRST_NEED_TREE;
d2199 1
a2199 1
	sp->sr_state = SRST_READY;
d2243 1
a2243 1
		sp->sr_state = SRST_VERSOK;
d2712 1
d2725 1
d2732 1
a2732 1
	sp->sr_state = SRST_DOING_DIRBUILD;
d2746 1
a2746 1
	sp->sr_state = SRST_RESTART;
d2798 1
a2798 1
	sp->sr_state = SRST_DOING_GETTREES;
@


11.13
log
@libbu/libbn
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/remrt.c,v 11.12 1996/07/15 17:40:50 jra Exp mike $ (BRL)";
a778 1
	    fileno(stdin) >= 0 &&
@


11.12
log
@Minor mods for IRIX 6.2
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/remrt.c,v 11.11 1995/10/12 18:49:36 cjohnson Exp jra $ (BRL)";
d171 1
a171 1
	struct rt_list	l;
d177 1
a177 1
struct rt_list 		FreeList;
d182 2
a183 2
#define GET_LIST(p)	if( RT_LIST_IS_EMPTY( &FreeList ) )  { \
				GETSTRUCT((p), list); \
d186 2
a187 2
				(p) = RT_LIST_FIRST(list, &FreeList); \
				RT_LIST_DEQUEUE(&(p)->l); \
d190 1
a190 1
#define FREE_LIST(p)	{ RT_LIST_APPEND( &FreeList, &(p)->l ); }
d205 1
a205 1
	struct rt_list	fr_todo;	/* work still to be done */
d212 1
a212 1
	struct rt_vls	fr_cmd;		/* RT options & command string */
d214 1
a214 1
	struct rt_vls	fr_after_cmd;	/* local commands, after frame done */
d225 1
a225 1
		rt_log("NULL %s in %s line %d\n", _str, __FILE__, __LINE__ ); \
d228 1
a228 1
		rt_log("ERROR %s=x%x magic was=x%x s/b=x%x in %s line %d\n", \
d240 1
a240 1
			GETSTRUCT(p, frame); \
d246 2
a247 2
		rt_vls_init( &(p)->fr_cmd ); \
		rt_vls_init( &(p)->fr_after_cmd ); \
d250 2
a251 2
	rt_vls_free( &(p)->fr_cmd ); \
	rt_vls_free( &(p)->fr_after_cmd ); \
d315 1
a315 1
	struct rt_list	sr_work;
d508 1
a508 1
	RT_LIST_INIT( &FreeList );
d511 1
a511 1
		RT_LIST_INIT( &sp->sr_work );
d517 1
a517 1
	if( (tcp_listen_fd = pkg_permserver("rtsrv", "tcp", 8, rt_log)) < 0 )  {
d523 1
a523 1
			if( (tcp_listen_fd = pkg_permserver(num, "tcp", 8, rt_log)) < 0 )
d528 1
a528 1
			rt_log("Unable to find a port to listen on\n");
d538 2
a539 2
		rt_log("%s Interactive REMRT on %s\n", stamp(), our_hostname );
		rt_log("%s Listening at port %d\n", stamp(), pkg_permport);
d559 1
a559 1
		rt_log("%s Out of clients\n", stamp());
d561 2
a562 2
		rt_log("%s Automatic REMRT on %s\n", stamp(), our_hostname );
		rt_log("%s Listening at port %d, reading script on stdin\n",
d598 1
a598 1
			rt_vls_strcat( &fr->fr_cmd, buf);
d614 1
a614 1
		rt_log("%s Task accomplished\n", stamp() );
d662 1
a662 1
			rt_log("%s *** All servers down\n", stamp() );
d739 1
a739 1
		if(rem_debug>1) rt_log("%s select timed out after %d seconds\n", stamp(), waittime);
d745 1
a745 1
		pc = pkg_getclient(tcp_listen_fd, pkgswitch, rt_log, 1);
d813 1
a813 1
		rt_log("abandoning this unknown server!!\n");
d818 1
a818 1
	if( rem_debug )  rt_log("%s addclient(%s)\n", stamp(), ihp->ht_name);
d825 1
a825 1
	RT_LIST_INIT( &sp->sr_work );
d855 1
a855 1
		rt_log("drop_server(x%x), sr_host=0\n", sp);
d866 1
a866 1
		rt_log("%s dropping %s (%s)\n",
d872 1
a872 1
		rt_log("drop_server(x%x), sr_pc=0\n", sp);
d879 1
a879 1
		rt_log("drop_server: fd=%d is unreasonable, forget it!\n", fd);
d887 1
a887 1
	while( RT_LIST_WHILE( lp, list, &sp->sr_work ) )  {
d890 2
a891 2
		RT_LIST_DEQUEUE( &lp->l );
		rt_log("%s requeueing fr%d %d..%d\n",
d896 1
a896 1
		RT_LIST_APPEND( &fr->fr_todo, &lp->l );
d927 1
a927 1
	rt_log("%s Seeking servers to start\n", stamp() );
d930 1
a930 1
	for( RT_LIST_FOR( ihp, ihost, &HostHead ) )  {
d971 1
a971 1
				rt_log("%s Auto dropping %s:  out of time range\n",
d983 1
a983 1
			rt_log("%s Auto adding %s\n", stamp(), ihp->ht_name);
d1069 3
a1071 3
	struct rt_vls	prelude;
	struct rt_vls	body;
	struct rt_vls	finish;
d1075 1
a1075 1
	rt_log("%s Starting to scan animation script\n", stamp() );
d1077 3
a1079 3
	rt_vls_init( &prelude );
	rt_vls_init( &body );
	rt_vls_init( &finish );
d1085 2
a1086 2
		rt_vls_strcat( &prelude, buf );
		rt_vls_strcat( &prelude, ";" );
d1090 2
a1091 2
		rt_log("unexpected EOF while reading script for first frame 'start'\n");
		rt_vls_free( &prelude );
d1111 2
a1112 2
			rt_vls_strcat( &body, ebuf );
			rt_vls_strcat( &body, ";" );
d1116 1
a1116 1
			rt_log("unexpected EOF while reading script for frame %d\n", frame);
d1125 2
a1126 2
			rt_vls_strcat( &finish, nsbuf );
			rt_vls_strcat( &finish, ";" );
d1133 1
a1133 1
			rt_log("bad 'start' line\n");
d1139 1
a1139 1
			rt_vls_free( &body );
d1143 1
a1143 1
			rt_vls_free( &body );
d1151 3
a1153 3
		rt_vls_vlscat( &fr->fr_cmd, &prelude );
		rt_vls_vlscatzap( &fr->fr_cmd, &body );
		rt_vls_vlscatzap( &fr->fr_after_cmd, &finish );
d1165 3
a1167 3
	rt_vls_free( &prelude );
	rt_vls_free( &body );
	rt_vls_free( &finish );
d1170 1
a1170 1
	rt_log("%s Animation script loaded\n", stamp() );
d1195 1
a1195 1
		rt_log("string2int(%s) = %d?\n", str, ret );
d1248 1
a1248 1
		rt_log("-> "); (void)fflush(stderr);
d1299 1
a1299 1
	rt_vls_trunc( &fr->fr_cmd, 0 );	/* Start fresh */
d1309 3
a1311 3
	rt_vls_strcat( &fr->fr_cmd, buf );
	if( interactive )  rt_vls_strcat( &fr->fr_cmd, " -I");
	if( benchmark )  rt_vls_strcat( &fr->fr_cmd, " -B");
d1314 1
a1314 1
		rt_vls_strcat( &fr->fr_cmd, buf );
d1316 1
a1316 1
	rt_vls_strcat( &fr->fr_cmd, ";" );
d1324 1
a1324 1
	RT_LIST_INIT( &fr->fr_todo );
d1329 1
a1329 1
	RT_LIST_INSERT( &fr->fr_todo, &lp->l );
d1340 1
a1340 1
		rt_log("already running, please wait or STOP\n");
d1344 1
a1344 1
		rt_log("need LOAD before GO\n");
d1348 1
a1348 1
		rt_log("No frames to do!\n");
d1385 1
a1385 1
	rt_log("%s Scanning %s for non-black pixels\n", stamp(),
d1418 1
a1418 1
		rt_log("%s Deleting non-black pixel range %d to %d inclusive\n",
d1425 1
a1425 1
	rt_log("%s Scanning %s complete, %d non-black spans, %d non-black pixels\n",
d1459 1
a1459 1
	fr->fr_filename = rt_strdup( name );
d1509 1
a1509 1
	rt_log("%s Frame %d DONE: %g elapsed sec, %d rays/%g cpu sec\n",
d1515 1
a1515 1
	rt_log("%s  RTFM=%g rays/sec (%g rays/cpu sec)\n",
d1521 3
a1523 3
	if( rt_vls_strlen( &fr->fr_after_cmd ) > 0 )  {
		rt_log("running after_cmd='%s'\n",
			RT_VLS_ADDR(&fr->fr_after_cmd) );
d1525 1
a1525 1
			RT_VLS_ADDR(&fr->fr_after_cmd), cmd_tab );
d1535 1
a1535 1
		if(rem_debug) rt_log("%s %s\n", stamp(), cmd);
d1571 2
a1572 2
	while( RT_LIST_WHILE( lp, list, &fr->fr_todo ) )  {
		RT_LIST_DEQUEUE( &lp->l );
d1609 1
a1609 1
	if( RT_LIST_NON_EMPTY( &fr->fr_todo ) )
d1614 1
a1614 1
		for( RT_LIST_FOR( lp, list, &sp->sr_work ) )  {
d1638 1
a1638 1
		if( RT_LIST_IS_EMPTY( &sp->sr_work ) )  continue;
d1661 1
a1661 1
		if( RT_LIST_IS_EMPTY( &fr->fr_todo ) )
d1727 1
a1727 1
			if(rem_debug>1) rt_log("%s Final close on %s\n", stamp(), sp->sr_host->ht_name);
d1743 1
a1743 1
		if( RT_LIST_NON_EMPTY( &fr->fr_todo ) )
d1760 1
a1760 1
		rt_log("%s All work done!\n", stamp() );
d1772 1
a1772 1
			if( RT_LIST_IS_EMPTY( &fr->fr_todo ) )
d1802 1
a1802 1
		rt_log("%s Change work allocation method (%s to %s)\n",
d1894 1
a1894 1
		rt_log("task_server: fr %d: null filename!\n",
d1913 1
a1913 1
		rt_log("%s %s: *TARDY*\n", stamp(), sp->sr_host->ht_name);
d1921 1
a1921 1
	if( RT_LIST_IS_EMPTY( &fr->fr_todo ) )  {
d2001 1
a2001 1
	lp = RT_LIST_FIRST( list, &fr->fr_todo );
d2007 1
a2007 1
		RT_LIST_DEQUEUE( &lp->l );
d2018 1
a2018 1
	RT_LIST_INSERT( &sp->sr_work, &lp->l );
d2040 1
a2040 1
	for( RT_LIST_FOR( lp, list, &sp->sr_work ) )  {
d2070 1
a2070 1
	rt_vls_strcat( &(fr->fr_cmd), cmd );
d2075 1
a2075 1
		rt_vls_strcat( &fr->fr_cmd, cmd );
d2079 1
a2079 1
	rt_vls_strcat( &fr->fr_cmd, cmd );
d2084 1
a2084 1
		rt_vls_strcat( &fr->fr_cmd, cmd );
d2086 1
a2086 1
	rt_vls_strcat( &fr->fr_cmd, "; ");
d2090 1
a2090 1
		rt_log("read_matrix: EOF on old style frame file.\n");
d2095 1
a2095 1
	rt_log("read_matrix:  unable to parse old style entry\n");
d2112 1
a2112 1
	rt_log("ctl: unable to handle %s message: len %d",
d2133 1
a2133 1
	rt_log("%s %s dirbuild OK (%s)\n",
d2139 1
a2139 1
		rt_log("unexpected MSG_DIRBUILD_REPLY from fd %d\n", pc->pkc_fd);
d2143 1
a2143 1
		rt_log("MSG_DIRBUILD_REPLY in state %d?\n", sp->sr_state);
d2165 1
a2165 1
	rt_log("%s %s gettrees OK (%s)\n",
d2171 1
a2171 1
		rt_log("unexpected MSG_GETTREES_REPLY from fd %d\n", pc->pkc_fd);
d2175 1
a2175 1
		rt_log("MSG_GETTREES_REPLY in state %s?\n",
d2192 1
a2192 1
		rt_log("%s %s: %s",
d2197 1
a2197 1
			rt_log("\n");
d2214 1
a2214 1
		rt_log("ERROR %s: protocol version mis-match\n",
d2216 2
a2217 2
		rt_log("  local='%s'\n", PROTOCOL_VERSION );
		rt_log(" remote='%s'\n", buf );
d2221 1
a2221 1
			rt_log("NOTE %s:  VERSION message unexpected\n",
d2240 1
a2240 1
	rt_log("%s %s: cmd '%s'\n", stamp(), sp->sr_host->ht_name, buf );
d2265 1
a2265 1
	struct	rt_external	ext;
d2272 1
a2272 1
		rt_log("%s Ignoring MSG_PIXELS from %s\n",
d2293 1
a2293 1
	rt_struct_buf(&ext, (genptr_t) buf);
d2295 1
a2295 1
	i = rt_struct_import( (genptr_t)&info, desc_line_info, &ext );
d2297 2
a2298 2
		rt_log("rt_struct_import error, %d\n", i);
		drop_server( sp, "rt_struct_import error" );
d2302 1
a2302 1
		rt_log("%s %s %d/%d..%d, ray=%d, cpu=%.2g, el=%g\n",
d2309 2
a2310 2
	if( RT_LIST_IS_EMPTY( &sp->sr_work ) )  {
		rt_log("%s responded with pixels when none were assigned!\n",
d2322 1
a2322 1
	lp = RT_LIST_FIRST( list, &sp->sr_work );
d2327 1
a2327 1
		rt_log("%s: frame number mismatch, got=%d, assigned=%d\n",
d2335 1
a2335 1
		rt_log("%s:  assignment mismatch, sent %d..%d, got %d..%d\n",
d2345 1
a2345 1
		rt_log("pixel numbers out of range\n");
d2354 1
a2354 1
		rt_log("short scanline, s/b=%d, was=%d\n",
d2373 1
a2373 1
		rt_log("write s/b %d, got %d\n", i, cnt );
d2380 1
a2380 1
		rt_log("%s disk write error, preparing graceful STOP\n", stamp() );
d2474 1
a2474 1
register struct rt_list *lhp;
d2479 1
a2479 1
	for( RT_LIST_FOR( lp, list, lhp ) )  {
d2482 1
a2482 1
				RT_LIST_DEQUEUE(&lp->l);
d2499 1
a2499 1
			rt_log("splitting range into (%d %d) (%d %d)\n",
d2507 1
a2507 1
			RT_LIST_APPEND( &lp->l, &lp2->l );
d2640 1
a2640 1
		rt_log("fb_open %d,%d failed\n", xx, yy);
d2664 1
a2664 1
		rt_log("Warning:  fb not big enough for %d pixels, display truncated\n", fr->fr_width );
d2700 1
a2700 1
		rt_log("send_dirbuild: ht_where=%d unimplemented\n", ihp->ht_where);
d2754 1
a2754 1
	    RT_VLS_ADDR(&fr->fr_cmd), rt_vls_strlen(&fr->fr_cmd)+1, sp->sr_pc
d2806 1
a2806 1
register struct rt_list *lhp;
d2810 1
a2810 1
	for( RT_LIST_FOR( lp, list, lhp ) )  {
d2812 1
a2812 1
			rt_log("\t%d..%d frame *NULL*??\n",
d2815 1
a2815 1
			rt_log("\t%d..%d frame %d\n",
d2849 1
a2849 1
			rt_log("unable to add CONVERT host %s until database given\n",
d2859 1
a2859 1
		rt_log("add_host:  ht_where=%d?\n", ihp->ht_where );
d2920 1
a2920 1
			rt_log("host_helper: cnt=%d, aborting\n", cnt);
d2929 1
a2929 1
				rt_log("%s %s\n", stamp(), cmd);
d2969 1
a2969 1
				rt_log("%s %s\n", stamp(), cmd);
d3049 1
a3049 1
		rt_log("build_start_cmd:  need file and at least one object\n");
d3084 1
a3084 1
		rt_log("Can't load while running!!\n");
d3090 1
a3090 1
		rt_log("Was loaded with %s, restarting all\n", file_fullname);
d3115 1
a3115 1
	rt_log("%s Dispatcher debug=x%x\n", stamp(), rem_debug );
d3131 1
a3131 1
	struct rt_vls	cmd;
d3133 4
a3136 4
	rt_vls_init( &cmd );
	rt_vls_strcpy( &cmd, "opt " );
	rt_vls_strcat( &cmd, argv[1] );
	len = rt_vls_strlen( &cmd )+1;
d3139 1
a3139 1
		if( pkg_send( MSG_OPTIONS, RT_VLS_ADDR(&cmd), len, sp->sr_pc) < 0 )
d3153 1
a3153 1
	rt_log("width=%d, height=%d, takes effect after next MAT\n",
d3167 1
a3167 1
	rt_log("fb width=%d, height=%d, takes effect after next attach\n",
d3179 1
a3179 1
	rt_log("fb height=%d, takes effect after next attach\n",
d3189 1
a3189 1
	rt_log("hypersample=%d, takes effect after next MAT\n", hypersample);
d3198 1
a3198 1
	rt_log("Benchmark flag=%d, takes effect after next MAT\n", benchmark);
d3208 1
a3208 1
	rt_log("perspective angle=%g, takes effect after next MAT\n", rt_perspective);
d3224 1
a3224 1
	rt_log("%s 'read' command done\n", stamp());
d3255 1
a3255 1
	outputfile = rt_strdup( argv[1] );
d3288 1
a3288 1
			rt_log("mat: failure\n");
d3315 1
a3315 1
		rt_log("already running, please wait\n");
d3319 1
a3319 1
		rt_log("need LOAD before MOVIE\n");
d3331 1
a3331 1
			rt_log("movie:  error in old style frame list\n");
d3342 1
a3342 1
			rt_log("movie:  frame %d bad\n", i);
d3354 1
a3354 1
	rt_log("Movie ready\n");
d3427 1
a3427 1
		rt_log("%s Bad allocateby type '%s'\n", stamp(), argv[1]);
d3443 1
a3443 1
		rt_log("%s Restarting all\n", stamp() );
d3461 1
a3461 1
	rt_log("%s No more scanlines being scheduled, done soon\n", stamp() );
d3473 1
a3473 1
		rt_log("must STOP before RESET!\n");
d3527 1
a3527 1
	rt_log("%s Frames waiting:\n", stamp() );
d3530 1
a3530 1
		rt_log("%5d\twidth=%d, height=%d\n",
d3536 1
a3536 1
			rt_log("\tfile=%s%s\n",
d3540 1
a3540 1
		rt_log("\tnrays = %d, cpu sec=%g\n", fr->fr_nrays, fr->fr_cpu);
d3542 2
a3543 2
		rt_log("\tcmd=%s\n", RT_VLS_ADDR(&fr->fr_cmd) );
		rt_log("\tafter_cmd=%s\n", RT_VLS_ADDR(&fr->fr_after_cmd) );
d3557 1
a3557 1
		rt_prmem("memprint command");
d3580 2
a3581 2
	if(interactive) rt_log("%s Interactive mode\n", s);
	rt_log("%s Worker assignment interval=%d seconds:\n",
d3583 3
a3585 3
	rt_log("   Server   Last  Last   Average  Cur   Machine\n");
	rt_log("    State   Lump Elapsed pix/sec Frame   Name \n");
	rt_log("  -------- ----- ------- ------- ----- -------------\n");
d3606 1
a3606 1
		rt_log("  %8s %5d %7g %7g %5d %s\n",
d3633 1
a3633 1
		rt_log("No model loaded yet\n");
d3635 1
a3635 1
		rt_log("\n%s %s\n",
d3638 1
a3638 1
		rt_log("%s %s objects=%s\n",
d3643 1
a3643 1
		rt_log("%s Framebuffer is %s\n", s, fbp->if_name);
d3645 1
a3645 1
		rt_log("%s No framebuffer\n", s );
d3647 2
a3648 2
		rt_log("%s Output file: %s.###\n", s, outputfile );
	rt_log("%s Printing of remote messages is %s\n",
d3650 1
a3650 1
    	rt_log("%s Listening at %s, port %d\n",
d3654 1
a3654 1
	rt_log("%s Worker assignment interval=%d seconds:\n",
d3658 1
a3658 1
		rt_log("  %2d  %s %s",
d3663 1
a3663 1
			rt_log(" frame %d, assignments=%d\n",
d3667 1
a3667 1
			rt_log("\n");
d3670 1
a3670 1
		rt_log("\tlast:  elapsed=%g, cpu=%g, lump=%d\n",
d3674 1
a3674 1
		rt_log("\t avg:  elapsed=%gp/s, cpu=%g, weighted=%gp/s\n",
d3678 1
a3678 1
		rt_log("\t r/s:  weighted=%gr/s missed = %d\n",
d3713 1
a3713 1
	rt_log("%s Printing of remote messages is %s\n",
d3755 1
a3755 1
			rt_log("%s Stopped, waiting for servers to become idle\n", stamp() );
d3758 1
a3758 1
		rt_log("%s All servers idle\n", stamp() );
d3771 1
a3771 1
		rt_log("%s %s\t\t%s\n",
d3789 2
a3790 2
		rt_log("%s Registered Host Table:\n", stamp() );
		for( RT_LIST_FOR( ihp, ihost, &HostHead ) )  {
d3792 1
a3792 1
			rt_log("  %s 0x%x ", ihp->ht_name, ihp->ht_flags);
d3795 1
a3795 1
				rt_log("always ");
d3798 1
a3798 1
				rt_log("night ");
d3801 1
a3801 1
				rt_log("hacknight ");
d3804 1
a3804 1
				rt_log("passive ");
d3807 1
a3807 1
				rt_log("r/s %d ",ihp->ht_rs);
d3810 1
a3810 1
				rt_log("passive r/s %d ",ihp->ht_rs);
d3813 1
a3813 1
				rt_log("?when? ");
d3818 1
a3818 1
				rt_log("cd %s\n", ihp->ht_path);
d3821 1
a3821 1
				rt_log("convert %s\n", ihp->ht_path);
d3824 1
a3824 1
				rt_log("?where?\n");
d3848 1
a3848 1
		rt_log("unknown 'when' string '%s'\n", argv[argpoint]);
d3864 1
a3864 1
		ihp->ht_path = rt_strdup( argv[argpoint+1] );
d3867 1
a3867 1
		ihp->ht_path = rt_strdup( argv[argpoint+1] );
d3870 1
a3870 1
		ihp->ht_path = rt_strdup( argv[argpoint+1]);
d3872 1
a3872 1
		rt_log("unknown 'where' string '%s'\n", argv[argpoint] );
d3908 1
a3908 1
		frame_script = rt_strdup(argv[1]);
@


11.11
log
@make sure -x gets sent on opt as -x and not as -X.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/remrt.c,v 11.10 1995/07/18 03:08:23 mike Exp cjohnson $ (BRL)";
d117 2
a119 1

d622 1
d3228 1
d3414 2
d3428 1
d3430 2
@


11.10
log
@Oops.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/remrt.c,v 11.9 1995/07/14 02:59:45 mike Exp mike $ (BRL)";
d1304 1
a1304 1
		rdebug, rt_g.debug,
@


11.9
log
@Converted "struct list" to using rtlist.h,
brought header file inboard.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/remrt.c,v 11.8 1995/07/14 00:40:51 mike Exp mike $ (BRL)";
d2320 1
@


11.8
log
@Split out ihost routines from remrt.c into ihost.[ch]
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/remrt.c,v 11.7 1995/07/14 00:17:37 mike Exp mike $ (BRL)";
a75 1
#include "./list.h"
d161 1
a161 1
struct list *FreeList;
d163 28
d204 1
a204 1
	struct list	fr_todo;	/* work still to be done */
d314 1
a314 1
	struct list	sr_work;
d507 1
d510 1
a510 1
		sp->sr_work.li_forw = sp->sr_work.li_back = &sp->sr_work;
d823 1
a823 1
	sp->sr_work.li_forw = sp->sr_work.li_back = &(sp->sr_work);
d885 1
a885 2
	lhp = &(sp->sr_work);
	while( (lp = lhp->li_forw) != lhp )  {
d888 1
a888 1
		DEQUEUE_LIST( lp );
d893 2
a894 1
		APPEND_LIST( lp, &(fr->fr_todo) );
d1322 1
a1322 1
	fr->fr_todo.li_forw = fr->fr_todo.li_back = &(fr->fr_todo);
d1327 1
a1327 1
	APPEND_LIST( lp, fr->fr_todo.li_back );
d1569 2
a1570 2
	while( (lp = fr->fr_todo.li_forw) != &(fr->fr_todo) )  {
		DEQUEUE_LIST( lp );
d1603 1
a1603 1
	register struct list	*lhp, *lp;
d1607 1
a1607 1
	if( fr->fr_todo.li_forw != &(fr->fr_todo) )
d1612 1
a1612 2
		lhp = &(sp->sr_work);
		for( lp = lhp->li_forw; lp != lhp; lp=lp->li_forw )  {
d1636 1
a1636 1
		if( sp->sr_work.li_forw == &(sp->sr_work) )  continue;
d1659 1
a1659 1
		if( fr->fr_todo.li_forw == &(fr->fr_todo) )
d1741 1
a1741 1
		if( fr->fr_todo.li_forw != &(fr->fr_todo) )
d1770 1
a1770 1
			if( fr->fr_todo.li_forw == &(fr->fr_todo) )
d1919 1
a1919 1
	if( (lp = fr->fr_todo.li_forw) == &(fr->fr_todo) )  {
d1999 1
d2005 1
a2005 1
		DEQUEUE_LIST( lp );
d2016 1
a2016 1
	APPEND_LIST( lp, sp->sr_work.li_back );
d2038 1
a2038 1
	for( lp = sp->sr_work.li_forw; lp != &(sp->sr_work); lp = lp->li_forw )  {
d2307 1
a2307 1
	if( (lp = sp->sr_work.li_forw) == &(sp->sr_work) )  {
d2471 1
a2471 1
register struct list *lhp;
d2476 1
a2476 1
	for( lp=lhp->li_forw; lp != lhp; lp=lp->li_forw )  {
d2479 1
a2479 1
				DEQUEUE_LIST(lp);
d2500 1
a2500 1
			*lp2 = *lp;	/* struct copy li_frame, etc */
d2504 1
a2504 1
			APPEND_LIST( lp2, lp );
d2803 1
a2803 1
register struct list *lhp;
d2807 1
a2807 1
	for( lp = lhp->li_forw; lp != lhp; lp = lp->li_forw  )  {
@


11.7
log
@Eliminated ancient Cray hack.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/remrt.c,v 11.6 1995/07/14 00:12:55 mike Exp mike $ (BRL)";
d78 1
a321 31
/* Internal Host table */
struct ihost {
	char		*ht_name;	/* Official name of host */
	int		ht_flags;	/* Control info about this host */
#define HT_HOLD		0x1
	int		ht_when;	/* When to use this host */
#define HT_ALWAYS	1		/* Always try to use this one */
#define HT_NIGHT	2		/* Only use at night */
#define HT_PASSIVE	3		/* May call in, never initiated */
#define HT_RS		4		/* While rays/second > ht_rs */
#define HT_PASSRS	5		/* passive rays/second */
#define HT_HACKNIGHT	6		/* Only use during "hackers night" */
	int		ht_rs;		/* rays/second level */
	int		ht_rs_miss;	/* number of consecutive misses */
	int		ht_rs_wait;	/* # of auto adds to wait before */
					/* restarting this server */
	int		ht_where;	/* Where to find database */
#define HT_CD		1		/* cd to ht_path first */
#define HT_CONVERT	2		/* cd to ht_path, asc2g database */
#define HT_USE		3		/* cd to ht_path, use asc database */
					/* best of cd and convert */
	char		*ht_path;	/* remote directory to run in */
	struct ihost	*ht_next;
};
struct ihost		*HostHead;
#define IHOST_NULL	((struct ihost *)0)
struct ihost		*host_lookup_by_name();
struct ihost		*host_lookup_by_addr();
struct ihost		*host_lookup_by_hostent();
struct ihost		*make_default_host();

a358 1
char	ourname[512];
d360 2
d472 2
a473 17
	/*
	 * There is a problem in some hosts that gethostname() will only
	 * return the host name and *not* the fully qualified host name
	 * with domain name.
	 *
	 * gethostbyname() will return a host table (nameserver) entry
	 * where h_name is the "offical name", i.e. fully qualified.
	 * Therefore the following piece of code.
	 */
	{
		char temp[512];
		struct hostent *hp;
		gethostname(temp, sizeof(temp));
		hp = gethostbyname(temp);
		strcpy(ourname, hp->h_name);
	}
	fprintf(stderr,"%s %s %s\n", stamp(), ourname, version+5 );
d509 1
a509 1
		rt_log("%s Interactive REMRT on %s\n", stamp(), ourname );
d532 1
a532 1
		rt_log("%s Automatic REMRT on %s\n", stamp(), ourname );
d900 2
a901 1
	for( ihp = HostHead; ihp != IHOST_NULL; ihp = ihp->ht_next )  {
d2896 1
a2896 1
				rem_dir, ourname, port );
d2936 1
a2936 1
				ourname, port );
a3042 134
/*
 *			H O S T _ L O O K U P _ B Y _ H O S T E N T
 *
 *  We have a hostent structure, of which, the only thing of interest is
 *  the host name.  Go from name to address back to name, to get formal name.
 *
 *  Used by host_lookup_by_addr, too.
 */
struct ihost *
host_lookup_by_hostent( addr, enter )
struct hostent	*addr;
int		enter;
{
	register struct ihost	*ihp;

	if( !(addr == gethostbyname(addr->h_name)) )
		return IHOST_NULL;
	if( !(addr == gethostbyaddr(addr->h_addr_list[0],
	    sizeof(struct in_addr), addr->h_addrtype)) )
		return IHOST_NULL;
	/* Now addr->h_name points to the "formal" name of the host */

	/* Search list for existing instance */
	for( ihp = HostHead; ihp != IHOST_NULL; ihp = ihp->ht_next )  {
		if( strcmp( ihp->ht_name, addr->h_name ) != 0 )
			continue;
		return( ihp );
	}
	if( enter == 0 )
		return( IHOST_NULL );

	/* If not found and enter==1, enter in host table w/defaults */
	/* Note: gethostbyxxx() routines keep stuff in a static buffer */
	return( make_default_host( addr->h_name ) );
}

/*
 *			M A K E _ D E F A U L T _ H O S T
 *
 *  Add a new host entry to the list of known hosts, with
 *  default parameters.
 *  This routine is used to handle unexpected volunteers.
 */
struct ihost *
make_default_host( name )
char	*name;
{
	register struct ihost	*ihp;

	GETSTRUCT( ihp, ihost );

	/* Make private copy of host name -- callers have static buffers */
	ihp->ht_name = rt_strdup( name );

	/* Default host parameters */
	ihp->ht_flags = 0x0;
	ihp->ht_when = HT_PASSIVE;
	ihp->ht_where = HT_CONVERT;
	ihp->ht_path = "/tmp";

	/* Add to linked list of known hosts */
	ihp->ht_next = HostHead;
	HostHead = ihp;
	return(ihp);
}

/*
 *			H O S T _ L O O K U P _ B Y _ A D D R
 */
struct ihost *
host_lookup_by_addr( from, enter )
struct sockaddr_in	*from;
int	enter;
{
	register struct ihost	*ihp;
	struct hostent	*addr;
	unsigned long	addr_tmp;
	char		name[64];

	addr_tmp = from->sin_addr.s_addr;
	addr = gethostbyaddr( (char *)&from->sin_addr, sizeof (struct in_addr),
		from->sin_family);
	if( addr != NULL )
		return( host_lookup_by_hostent( addr, enter ) );

	/* Host name is not known */
	addr_tmp = ntohl(addr_tmp);
	sprintf( name, "%d.%d.%d.%d",
		(addr_tmp>>24) & 0xff,
		(addr_tmp>>16) & 0xff,
		(addr_tmp>> 8) & 0xff,
		(addr_tmp    ) & 0xff );
	if( enter == 0 )  {
		rt_log("%s: unknown host\n");
		return( IHOST_NULL );
	}

	/* See if this host has been previously entered by number */
	for( ihp = HostHead; ihp != IHOST_NULL; ihp = ihp->ht_next )  {
		if( strcmp( ihp->ht_name, name ) == 0 )
			return( ihp );
	}

	/* Create a new hostent structure */
	return( make_default_host( name ) );
}

/*
 *			H O S T _ L O O K U P _ B Y _ N A M E
 */
struct ihost *
host_lookup_by_name( name, enter )
char	*name;
int	enter;
{
	struct sockaddr_in	sockhim;
	struct hostent		*addr;

	/* Determine name to be found */
	if( isdigit( *name ) )  {
		/* Numeric */
		sockhim.sin_family = AF_INET;
		sockhim.sin_addr.s_addr = inet_addr(name);
		return( host_lookup_by_addr( &sockhim, enter ) );
	} else {
		addr = gethostbyname(name);
	}
	if( addr == NULL )  {
		rt_log("%s:  bad host\n", name);
		return( IHOST_NULL );
	}
	return( host_lookup_by_hostent( addr, enter ) );
}

d3614 1
a3614 1
		s, ourname, pkg_permport);
d3753 2
a3754 1
		for( ihp = HostHead; ihp != IHOST_NULL; ihp=ihp->ht_next )  {
@


11.6
log
@Moved rt_struct_buf() to librt/inout.c
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/remrt/RCS/remrt.c,v 11.5 1995/03/23 02:43:17 mike Exp $ (BRL)";
a3164 5
#if CRAY && OLDTCP
	addr_tmp = from->sin_addr;
	addr = gethostbyaddr(&addr_tmp, sizeof (struct in_addr),
		from->sin_family);
#else
a3167 1
#endif
a3207 3
#if CRAY && OLDTCP
		sockhim.sin_addr = inet_addr(name);
#else
a3208 1
#endif
@


11.5
log
@Broke out scan_frame_for_finished_pixels() as a separate function.
Changed display of sr_lump on short assignments.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/remrt/RCS/remrt.c,v 11.4 1995/03/17 23:56:38 mike Exp mike $ (BRL)";
d2306 1
a2306 1
	rt_struct_buf(&ext, (genptr_t) buf, pc->pkc_len);
a4152 36
/* XXX ---  This should be part of inout.c */

#define	RT_GETPUT_MAGIC_1	0x15cb
#define RT_GETPUT_MAGIC_2	0xbc51
int
rt_struct_buf( ext, buf )
struct rt_external *ext;
genptr_t buf;
{
	register long i, len;

	RT_INIT_EXTERNAL(ext);
	ext->ext_buf = buf;
	i = (((unsigned char *)(ext->ext_buf))[0] << 8) |
	     ((unsigned char *)(ext->ext_buf))[1];
	len = (((unsigned char *)(ext->ext_buf))[2] << 24) |
	      (((unsigned char *)(ext->ext_buf))[3] << 16) |
	      (((unsigned char *)(ext->ext_buf))[4] <<  8) |
	       ((unsigned char *)(ext->ext_buf))[5];
	if ( i != RT_GETPUT_MAGIC_1) {
		rt_log("ERROR: bad getput buffer header x%x, s/b x%x, was %s(x%x), file %s, line %d\n",
		    ext->ext_buf, RT_GETPUT_MAGIC_1,
		    rt_identify_magic( i), i, __FILE__, __LINE__);
		rt_bomb("bad getput buffer");
	}
	ext->ext_nbytes = len;
	i = (((unsigned char *)(ext->ext_buf))[len-2] <<8) | 
	     ((unsigned char *)(ext->ext_buf))[len-1];
	if ( i != RT_GETPUT_MAGIC_2) {
		rt_log("ERROR: bad getput buffer x%x, s/b x%x, was %s(x%x), file %s, line %s\n",
		    ext->ext_buf, RT_GETPUT_MAGIC_2,
		    rt_identify_magic( i), i, __FILE__, __LINE__);
		rt_bomb("Bad getput buffer");
	}
	return(1);
}
@


11.4
log
@For movie mode, made lumps big enough to be worthwhile for
a parallel processor.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/remrt/RCS/remrt.c,v 11.3 1995/03/01 03:49:01 mike Exp mike $ (BRL)";
d1369 75
d1454 1
d1502 2
a1503 44
		register FILE	*fp;
		char		pbuf[4];
		register int	pno;	/* index of next unread pixel */

		rt_log("%s Scanning %s for non-black pixels\n", stamp(),
			fr->fr_filename );
		if( (fp = fopen( fr->fr_filename, "r" )) == NULL )  {
			perror( fr->fr_filename );
			return(-1);
		}

		pno = 0;
		while( !feof( fp ) )  {
			register int	first, last;

			/* Read and skip over any black pixels */
			if( (int)fread( pbuf, 3, 1, fp ) < 1 )  break;
			pno++;
			if( pbuf[0] == 0 && pbuf[1] == 0 && pbuf[2] == 0 )
				continue;

			/*
			 *  Found a non-black pixel.
			 *  See how many more follow,
			 *  and delete the batch of them from the work queue.
			 */
			first = last = pno-1;

			while( !feof( fp ) )  {
				/* Read and skip over non-black pixels */
				if( (int)fread( pbuf, 3, 1, fp ) < 1 )  break;
				pno++;
				if( pbuf[0] == 0 && pbuf[1] == 0 && pbuf[2] == 0 )
					break;		/* black pixel */
				/* non-black */
				last = pno-1;
			}
			rt_log("%s Deleting non-black pixel range %d to %d inclusive\n",
				stamp(),
				first, last );
			list_remove( &(fr->fr_todo), first, last );
		}

		rt_log("%s Scanning complete\n", stamp() );
d2019 1
@


11.3
log
@Added support for -T argument.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/remrt.c,v 11.2 95/03/01 03:44:26 mike Exp Locker: mike $ (BRL)";
d1952 1
d1955 8
a1962 2
	/* Limit growth in assignment size to 2X each assignment */
	if( lump > 2*sp->sr_lump )  lump = 2*sp->sr_lump;
@


11.2
log
@Mods by Chris Johnson so that "trees" command is only sent if this
is more than just an eyepoint animation.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/remrt/RCS/remrt.c,v 11.1 1995/01/04 10:03:59 mike Rel4_4 cjohnson $ (BRL)";
a372 1
extern char	*framebuffer;
d376 4
d1313 1
a1313 1
	sprintf(buf, "opt -w%d -n%d -H%d -p%g -U%d -J%x -A%g -l%d -E%g -x%x -X%x",
d1319 3
a1321 1
		rdebug, rt_g.debug );
@


11.1
log
@Release_4.4
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/remrt.c,v 10.20 95/01/04 09:06:00 mike Exp $ (BRL)";
d184 1
d294 5
a298 4
#define SRST_READY		4	/* loaded, ready */
#define SRST_RESTART		5	/* about to restart */
#define SRST_CLOSING		6	/* Needs to be closed */
#define SRST_DOING_GETTREES	7	/* doing gettrees */
d471 2
d895 1
a895 1
	if( oldstate != SRST_READY )  return;
d1107 2
d1115 6
d1159 1
d1611 2
a1612 1
		if( sp->sr_state != SRST_READY )  continue;
d1861 1
a1861 1
	if( sp->sr_state != SRST_READY )
d1923 5
a1927 4
		/* XXX should see if this is necessary... */
		send_gettrees( sp, fr );
		/* Now in state SRST_DOING_GETTREES */
		return 1;	/* need more work */
d2113 1
a2113 1
	sp->sr_state = SRST_READY;
d2236 1
a2236 1
	if( sp->sr_state != SRST_READY &&
@


10.20
log
@A space got in the wrong place.
Bugged old non-ANSI compilers, like VGR.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/remrt.c,v 10.19 94/12/30 15:30:03 stay Exp Locker: mike $ (BRL)";
@


10.19
log
@fixed three initialization space problems for older compilers
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/remrt.c,v 10.18 94/12/30 01:14:37 mike Exp Locker: stay $ (BRL)";
d1901 1
a1901 1
			for (csp =& servers[0]; csp < &servers[MAXSERVERS]; csp++ ){
@


10.18
log
@DEC Alpha
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/remrt.c,v 10.17 94/11/05 03:31:22 mike Exp Locker: mike $ (BRL)";
d575 1
a575 1
		finalframe=-1;
d1541 1
a1541 1
	for (sp=&servers[0]; sp<&servers[MAXSERVERS]; sp++) {
d1901 1
a1901 1
			for (csp=&servers[0]; csp < &servers[MAXSERVERS]; csp++ ){
@


10.17
log
@Irix 6
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/remrt.c,v 10.16 94/10/17 17:20:27 mike Exp Locker: mike $ (BRL)";
d214 1
a214 1
		bzero( (p), sizeof(struct frame) ); \
@


10.16
log
@Eliminated Solaris warnings
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/remrt.c,v 10.15 94/09/23 18:56:19 mike Exp Locker: mike $ (BRL)";
d438 1
a438 1
	long		now;
a439 1
	register char	*cp;
d1011 1
a1011 1
	long		sec = tv->tv_sec;
d1013 2
d1036 1
a1036 1
	long		sec = tv->tv_sec;
d1038 1
a1617 1
	register struct servers	*sp;
a2635 1
	char	cmd[512];
a3613 1
	register int	i;
@


10.15
log
@notreached
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/remrt.c,v 10.14 94/08/12 21:09:28 gdurf Exp Locker: mike $ (BRL)";
d811 1
a811 1
	if (getpeername(fd, &from, &fromlen) < 0) {
d816 1
a816 1
	if (setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &on, sizeof (on)) < 0)
d3109 1
a3109 1
	addr = gethostbyaddr(&from->sin_addr, sizeof (struct in_addr),
@


10.14
log
@Converted select() arguments to fd_set
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/remrt.c,v 10.13 1994/05/07 22:12:20 mike Exp gdurf $ (BRL)";
a3973 1
	return 0;
@


10.13
log
@Enroles hosts into table by their formal names.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/remrt.c,v 10.12 94/05/06 04:07:09 mike Exp $ (BRL)";
d25 2
a27 1
#define _BSD_TYPES		/* Needed for IRIX 5.0.1 */
d33 1
a33 1
#ifdef SYSV
d79 1
a79 1
#ifdef SYSV
d150 1
a150 1
int clients;
d155 3
d159 1
d492 1
d549 2
a550 1
		clients = (1<<fileno(stdin));
d556 6
a561 1
		while( clients )  {
d573 1
a573 1
		clients = 0;
d615 1
a615 1
			clients = 0;
d651 5
a655 1
			if( clients == 0 )  break;
d720 1
a720 1
	static long	ibits;
d727 1
a727 1
	for( i=0; i<NFD; i++ )  {
d738 3
a740 2
	ibits = clients|(1<<tcp_listen_fd);
	val = select(32, (char *)&ibits, (char *)0, (char *)0, &tv);
d752 1
a752 1
	if( ibits & (1<<tcp_listen_fd) )  {
d756 1
a756 1
		ibits &= ~(1<<tcp_listen_fd);
d760 1
a760 1
	for( i=0; i<NFD; i++ )  {
d764 1
a764 1
		if( !(ibits&(1<<i)) )  continue;
d773 1
a773 1
		ibits &= ~(1<<i);
d777 1
a777 1
	for( i=0; i<NFD; i++ )  {
d788 1
a788 1
	    (ibits & (1<<(fileno(stdin)))) )  {
d828 1
a828 1
	clients |= 1<<fd;
d886 1
a886 1
	if( fd <= 3 || fd >= NFD )  {
d890 1
a890 1
	clients &= ~(1<<sp->sr_pc->pkc_fd);
d1254 1
a1254 1
		clients &= ~(1<<fileno(fp));
d1688 1
a1688 1
			clients &= ~(1<<sp->sr_pc->pkc_fd);
d3338 1
a3338 1
	clients &= ~(1<<0);	/* drop stdin */
d3822 1
a3822 1
	clients &= ~(1<<fileno(stdin));
d3828 5
a3832 1
		while( clients && FrameHead.fr_forw != &FrameHead )  {
d3849 1
a3849 1
	clients |= 1<<fileno(stdin);
@


10.12
log
@Get better initial estimates of speed.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/remrt.c,v 10.11 94/05/06 03:52:50 mike Exp Locker: mike $ (BRL)";
d3009 5
d3021 7
@


10.11
log
@Changed MIN_ELAPSED_TIME to a smaller value, to reflect today's faster CPUs.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/remrt.c,v 10.10 94/05/06 03:42:47 mike Exp $ (BRL)";
d2210 5
d2341 9
a2349 1
		if( sp->sr_l_elapsed > assignment_time() )  {
@


10.10
log
@Try to send along debugging bits
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/remrt.c,v 10.9 94/05/06 01:31:33 mike Exp Locker: mike $ (BRL)";
d2215 1
a2215 1
#define MIN_ELAPSED_TIME	0.1
@


10.9
log
@Don't unlink temp file until framedone script is run.
Print out the "after_cmd" before running it, in case it produces crazy
error messages.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/remrt.c,v 10.8 94/05/05 20:48:06 mike Exp Locker: mike $ (BRL)";
d1278 1
a1278 1
	sprintf(buf, "opt -w%d -n%d -H%d -p%g -U%d -J%x -A%g -l%d -E%g",
d1283 2
a1284 1
		eye_backoff );
@


10.8
log
@Fixed code to handle images larger than the framebuffer.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/remrt.c,v 10.7 94/02/10 03:59:41 cjohnson Exp Locker: mike $ (BRL)";
d1463 2
d1469 13
d1492 1
a1492 12

	/* Run any end-of-frame script */
	if (frame_script) {
		char *cmd;
		cmd = malloc(strlen(frame_script) + strlen(fr->fr_filename) +
		    20); /* spaces and frame number */
		(void) sprintf(cmd,"%s %s %d",frame_script,fr->fr_filename,
		    fr->fr_number);
		if(rem_debug) rt_log("%s %s\n", stamp(), cmd);
		(void) system(cmd);
		(void) free(cmd);
	}
@


10.7
log
@Add a new option to the scheduler to spread servers over as
many frames as posible to get the best return on preptime.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/remrt.c,v 10.6 1994/01/14 20:53:26 cjohnson Exp cjohnson $ (BRL)";
d2481 1
a2481 1
		offset += len_to_eol;
d2580 1
d2585 4
a2588 1
	fb_zoom( fbp, fb_getwidth(fbp)/fr->fr_width,
a2589 2
	/* center the view */
	fb_window( fbp, fr->fr_width/2, fr->fr_height/2 );
@


10.6
log
@Change the default for final frame from 0 to infinity.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/remrt.c,v 10.5 1993/10/26 00:35:40 mike Exp cjohnson $ (BRL)";
d165 1
d303 5
d309 1
d387 8
d569 1
d851 1
a1476 1
	destroy_frame( fr );
d1489 1
d1500 1
d1517 6
d1637 1
d1707 1
d1725 7
d1736 2
a1737 1
		} while( another_pass > 0 );
d1739 7
d1820 1
d1875 9
d1889 1
a1889 1
		return(1);	/* need more work */
d1915 14
a1928 1
	else if( lump > REMRT_MAX_PIXELS )  lump = REMRT_MAX_PIXELS;
d3458 15
d3920 1
d3968 2
@


10.5
log
@Added return 0; statements to please the ANSI compiler.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/remrt.c,v 10.4 93/09/28 02:39:22 cjohnson Exp Locker: mike $ (BRL)";
d549 1
d1104 1
a1104 1
		if( frame > finalframe ) {
@


10.4
log
@Fix memory leak.  Add memory debug ability.
Add a couple of casts to make gcc (stdc) happy.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/remrt.c,v 10.3 1993/09/25 04:40:50 cjohnson Exp $ (BRL)";
d26 1
d1292 1
d3056 1
d3065 1
a3065 1
		return;
d3078 1
d3096 1
d3122 1
d3135 1
d3149 1
d3161 1
d3170 1
d3179 1
d3189 1
d3200 1
a3200 1
		return;
d3205 1
d3226 1
d3235 1
d3261 1
a3261 1
		return;
d3269 1
a3269 1
			return;
d3279 1
d3295 1
a3295 1
		return;
d3299 1
a3299 1
		return;
d3305 1
a3305 1
		return;
d3312 1
a3312 1
			return;
d3323 1
a3323 1
			return;
d3334 1
d3349 1
d3359 1
a3359 1
	if( sp == SERVERS_NULL || sp->sr_pc == PKC_NULL )  return;
d3361 1
d3372 1
a3372 1
	if (ihp == IHOST_NULL) return;
d3376 1
a3376 1
	if ( sp == SERVERS_NULL || sp->sr_pc == PKC_NULL) return;
d3378 1
d3380 1
d3388 1
a3388 1
	if (ihp == IHOST_NULL ) return;
d3391 1
d3393 1
d3407 1
a3407 1
		return;
d3410 1
a3410 1
	if( sp == SERVERS_NULL || sp->sr_pc == PKC_NULL )  return;
d3413 1
d3422 1
d3433 1
a3433 1
		return;
d3440 1
d3455 3
a3457 3
	if( init_fb(name) < 0 )  return;
	if( fbp == FBIO_NULL ) return;
	if( (fr = FrameHead.fr_forw) == &FrameHead )  return;
d3461 1
d3470 1
d3505 1
d3519 1
d3521 1
d3574 1
d3645 1
d3652 1
a3652 1
	if( fbp == FBIO_NULL )  return;
d3655 1
d3676 1
d3684 1
d3717 1
d3731 1
d3783 1
a3783 1
		return;
d3786 2
a3787 1
	if( (ihp = host_lookup_by_name( argv[argpoint++], 1 )) == IHOST_NULL )  return;
d3829 1
d3840 1
d3865 1
@


10.3
log
@Change debug to rem_debug for aux library namespace overlap.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/remrt.c,v 10.2 1993/09/25 01:11:07 cjohnson Exp cjohnson $ (BRL)";
d72 1
d371 1
a371 1
char	ourname[128];
d473 17
a489 2
	gethostname( ourname, sizeof(ourname) );
	fprintf(stderr,"%s %s\n", stamp(), version+5 );
d2330 1
d2449 1
d2862 1
a2862 1
		if( (fp = fdopen( fds[0], "r" )) == NULL )  {
d2874 1
a2874 1
	if( (helper_fp = fdopen( fds[1], "w" )) == NULL )  {
d3479 12
d3897 2
@


10.2
log
@Added check for final frame.
Remove references to RGBpixel
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/remrt.c,v 10.1 1991/10/12 06:42:33 mike Rel4_0 cjohnson $ (BRL)";
d375 1
a375 1
int		debug;		/* dispatcher debugging flag */
d572 1
a572 1
		if(debug>1) cd_frames( 0, (char **)0 );
d696 1
a696 1
		if(debug>1) rt_log("%s select timed out after %d seconds\n", stamp(), waittime);
d775 1
a775 1
	if( debug )  rt_log("%s addclient(%s)\n", stamp(), ihp->ht_name);
d1450 1
a1450 1
		if(debug) rt_log("%s %s\n", stamp(), cmd);
d1621 1
a1621 1
			if(debug>1) rt_log("%s Final close on %s\n", stamp(), sp->sr_host->ht_name);
d2141 1
a2141 1
	if( debug )  {
d2756 1
a2756 1
			if(debug)  {
d2796 1
a2796 1
			if(debug)  {
d3069 1
a3069 1
		debug = !debug;
d3071 1
a3071 1
		sscanf( argv[1], "%x", &debug );
d3073 1
a3073 1
	rt_log("%s Dispatcher debug=x%x\n", stamp(), debug );
d3580 1
a3580 1
		if( debug )
@


10.1
log
@Release_4.0
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/remrt.c,v 9.44 91/08/31 03:03:22 mike Exp $ (BRL)";
d359 1
d1086 4
d2351 1
a2351 1
RGBpixel	*pp;
d2415 1
a2415 1
	char		*line;
d2429 1
a2429 1
	line = rt_malloc( nby, "scanline" );
d2438 1
a2438 1
		cnt = fread( line, nby, 1, fp );
d2443 1
a2443 1
	rt_free( line, "scanline" );
@


9.44
log
@Stardent ANSI C
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/remrt.c,v 9.43 91/08/30 03:55:35 mike Exp $ (BRL)";
@


9.43
log
@strchr taken care of in machine.h
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/remrt.c,v 9.42 91/07/19 01:18:00 mike Exp $ (BRL)";
d1363 1
a1363 1
			if( fread( pbuf, 3, 1, fp ) < 1 )  break;
d1377 1
a1377 1
				if( fread( pbuf, 3, 1, fp ) < 1 )  break;
@


9.42
log
@Oops, needed to do it in 2 places.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/remrt.c,v 9.41 91/07/19 01:09:21 mike Exp $ (BRL)";
a71 5

#if !defined(SYSV) && BSD < 44
# define strchr(s, c)	index(s, c)
# define strrchr(s, c)	rindex(s, c)
#endif
@


9.41
log
@IBM nit
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/remrt.c,v 9.40 91/07/06 01:57:52 mike Exp $ (BRL)";
d987 1
d989 1
a989 1
	tp = localtime( &tv->tv_sec );
@


9.40
log
@On old BSD systems, map index() to strchr().
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/remrt/RCS/remrt.c,v 9.39 91/07/01 22:42:44 mike Exp $ (BRL)";
d964 1
d966 1
a966 1
	tp = localtime( &tv->tv_sec );
@


9.39
log
@Modified to satisfy rt_cmdtab[] reference from ../rt/do.o
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/remrt.c,v 9.38 91/06/28 00:26:06 cjohnson Exp $ (BRL)";
a34 2
# define strchr(s, c)	index(s, c)
# define strrchr(s, c)	rindex(s, c)
d72 5
@


9.38
log
@This is a back track to 9.36 keeping the "command" command
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/remrt.c,v 9.36 91/01/27 12:41:38 cjohnson Exp $ (BRL)";
d81 6
@


9.37
log
@Add "command" which is used to define the rtsrv command to use
when remshelling the remote machine.
@
text
@a119 1
char *CommandName = NULL;
a510 5
		if (CommandName == NULL) {
			CommandName = rt_malloc(10, "command name");
			strcpy(CommandName, "rtsrv");
		}

a541 5
		if (CommandName == NULL) {
			CommandName = rt_malloc(10, "command name");
			strcpy(CommandName, "rtsrv");
		}

d2661 2
a2662 2
			"%s %s %d %s\n",
			ihp->ht_name, CommandName, pkg_permport, ihp->ht_path );
d2671 2
a2672 2
			"%s %s %d %s %s %s\n",
			ihp->ht_name, CommandName, pkg_permport, ihp->ht_path,
a2720 1
	char	rem_cmd[128];
d2734 3
a2736 4
		rem_cmd[0] = '\0';
		cnt = sscanf( line, "%s %s %d %s %s %s",
			host, rem_cmd, &port, rem_dir, loc_db, rem_db );
		if( cnt != 4 && cnt != 6 )  {
d2741 1
a2741 1
		if( cnt == 4 )  {
d2743 2
a2744 2
				"cd %s; %s %s %d",
				rem_dir, rem_cmd, ourname, port );
d2780 1
a2780 1
			 "g2asc<%s|%s %s \"cd %s; asc2g>%s; %s %s %d\"",
d2784 1
a2784 1
				rem_cmd, ourname, port );
a3024 9
cd_cmdname( argc, argv)
int argc;
char **argv;
{
	if (CommandName != NULL) rt_free(CommandName, "command name");
	CommandName = rt_malloc(strlen(argv[1])+5, "command name");
	strcpy( CommandName, argv[1]);
}

a3784 5
struct command_tab rt_cmdtab[] = {
	(char *)0, (char *)0, (char *)0,
		0,		0,0	/* END */
};

a3785 2
	"cmd_name", "name",	"set the name of the server program",
		cd_cmdname,	2, 2,
@


9.36
log
@Add hold resume commands.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/remrt.c,v 9.35 91/01/27 10:52:04 cjohnson Exp $ (BRL)";
d120 1
d512 5
d548 5
d2672 2
a2673 2
			"%s %d %s\n",
			ihp->ht_name, pkg_permport, ihp->ht_path );
d2682 2
a2683 2
			"%s %d %s %s %s\n",
			ihp->ht_name, pkg_permport, ihp->ht_path,
d2732 1
d2746 4
a2749 3
		cnt = sscanf( line, "%s %d %s %s %s",
			host, &port, rem_dir, loc_db, rem_db );
		if( cnt != 3 && cnt != 5 )  {
d2754 1
a2754 1
		if( cnt == 3 )  {
d2756 2
a2757 2
				"cd %s; rtsrv %s %d",
				rem_dir, ourname, port );
d2793 1
a2793 1
			 "g2asc<%s|%s %s \"cd %s; asc2g>%s; rtsrv %s %d\"",
d2797 1
a2797 1
				ourname, port );
d3038 9
d3807 5
d3813 2
@


9.35
log
@Change over to the new opaque style of import/export structures.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/remrt.c,v 9.34 91/01/12 08:47:34 mike Exp $ (BRL)";
d304 2
d932 1
a932 1
		if( add )  {
d2656 1
d2934 1
d3299 1
a3299 1
		if( (ihp = host_lookup_by_name( argv[i], 1 )) != IHOST_NULL )  {
d3316 26
d3668 1
a3668 1
			rt_log("  %s ", ihp->ht_name);
d3800 4
@


9.34
log
@externs.h
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/remrt.c,v 9.33 90/12/13 16:16:05 mike Exp $ (BRL)";
d2097 1
d2120 1
d2122 3
a2124 3
	i = rt_struct_import( (char *)&info, desc_line_info, buf );
	if( i < 0 || i != info.li_len )  {
		rt_log("rt_struct_import error, %d, %d\n", i, info.li_len);
d2179 1
a2179 1
	if( pc->pkc_len - info.li_len < i )  {
d2181 2
a2182 2
			i, pc->pkc_len - info.li_len );
		i = pc->pkc_len - info.li_len;
d2197 1
a2197 1
	if( (cnt = write( fd, buf+info.li_len, i )) != i )  {
d2220 1
a2220 1
		write_fb( buf + info.li_len, fr,
d3838 36
@


9.33
log
@Changed to display version string.
fb_zoom & fb_window now performed by fb_view
If in interactive mode, limit assignment to 1 scanline.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/remrt.c,v 9.32 90/12/08 04:45:57 mike Exp $ (BRL)";
a76 5

extern int	getopt();
extern char	*optarg;
extern int	optind;
extern char	*getenv();
@


9.32
log
@inout headers are now in raytrace.h
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/remrt.c,v 9.31 90/12/08 01:14:10 mike Exp $ (BRL)";
d375 2
d471 1
a471 1
	fprintf(stderr,"%s %s\n", stamp(), RCSid+13);
d1234 1
a1234 1
	rt_vls_free( &fr->fr_cmd );	/* Start fresh */
d1831 2
d2462 3
a2464 3
	/* ALERT:  The library wants zoom before window! */
	fb_zoom( fbp, fb_getwidth(fbp)/xx, fb_getheight(fbp)/yy );
	fb_window( fbp, xx/2, yy/2 );
a2465 1
	fb_wmap( fbp, COLORMAP_NULL );	/* Standard map: linear */
d3441 1
@


9.31
log
@ANSI C nit
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/remrt.c,v 9.30 90/12/05 19:16:38 mike Exp $ (BRL)";
a75 1
#include "./inout.h"
d2121 1
a2121 1
	i = struct_import( (char *)&info, desc_line_info, buf );
d2123 2
a2124 2
		rt_log("struct_import error, %d, %d\n", i, info.li_len);
		drop_server( sp, "struct_import error" );
@


9.30
log
@Fixed so that if output is to framebuffer,
the temporary .pix file(s) are removed as each frame is finished.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/remrt.c,v 9.29 90/12/03 15:32:55 mike Exp $ (BRL)";
d85 2
a86 2
#define vfork	fork
#endif SYSV
@


9.29
log
@Added "Hacknight" option -- for hackers night
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/remrt.c,v 9.28 90/11/27 22:04:11 mike Exp $ (BRL)";
d166 1
d470 1
a470 1
	fprintf(stderr,"%s: %s\n", ourname, RCSid+13);
d506 2
a507 2
		rt_log("%s Interactive REMRT\n", stamp() );
		rt_log("Listening at port %d\n", pkg_permport);
d523 3
a525 3
		rt_log("%s Automatic REMRT\n", stamp());
		rt_log("Listening at port %d, reading script on stdin\n",
			pkg_permport);
d877 3
d1308 1
d1311 1
a1415 4
	/* Write-protect file, to prevent re-computation */
	if( chmod( fr->fr_filename, 0444 ) < 0 )
		perror( fr->fr_filename );

d1422 10
d1467 4
d3392 1
d3404 2
a3405 2
		rt_log("%5d\t", fr->fr_number);
		rt_log("width=%d, height=%d\n",
a3406 1
		if( fr->fr_filename )  rt_log("\tfile=%s\n", fr->fr_filename );
d3408 6
d3778 2
a3779 2
	"frames", "",		"summarize waiting frames",
		cd_frames,	1, 1,
@


9.28
log
@Added logging to start and end of eat_script(),
because on long scripts, it can take a long time.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/remrt.c,v 9.27 90/11/22 07:27:14 mike Exp $ (BRL)";
d315 1
d867 1
d877 1
d892 6
d963 23
d3624 3
d3662 2
@


9.27
log
@Changed RT_VLS_INIT to rt_vls_init.
More fancyness for "stat" command.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/remrt.c,v 9.26 90/11/22 06:47:27 mike Exp $ (BRL)";
d986 2
d1066 3
@


9.26
log
@Added rate-of-change limiting to assignment size,
to prevent really rapid growth in assignment size.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/remrt.c,v 9.25 90/11/22 06:29:32 mike Exp $ (BRL)";
d209 2
a210 2
		RT_VLS_INIT( &(p)->fr_cmd ); \
		RT_VLS_INIT( &(p)->fr_after_cmd ); \
d986 3
a988 3
	RT_VLS_INIT( &prelude );
	RT_VLS_INIT( &body );
	RT_VLS_INIT( &finish );
d1378 4
a1381 2
	(void)rt_do_cmd( (struct rt_i *)0,
		RT_VLS_ADDR(&fr->fr_after_cmd), cmd_tab );
d3023 1
a3023 1
	RT_VLS_INIT( &cmd );
d3374 2
d3398 7
d3406 1
a3406 1
			state_to_string(sp->sr_state),
@


9.25
log
@Made output of "stat" command slightly more pretty.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/remrt.c,v 9.24 90/11/22 03:52:13 mike Exp $ (BRL)";
d813 7
a819 1
	rt_log("%s dropping %s (%s)\n", stamp(), sp->sr_host->ht_name, why);
d1695 1
d1773 8
a1780 3
	sp->sr_lump = assignment_time() * sp->sr_w_elapsed;
	if( sp->sr_lump < 32 )  sp->sr_lump = 32;
	if( sp->sr_lump > REMRT_MAX_PIXELS )  sp->sr_lump = REMRT_MAX_PIXELS;
@


9.24
log
@Now, protocol.h has a define for the maximum number of pixels
that can be assigned.
Introduced new scheduling algorithm, to reduce load on
dispatcher with large numbers of worker CPUs.
Made "stat" command be brief 1-line status report on workers;
"status" gives full status.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/remrt.c,v 9.23 90/11/21 06:37:45 mike Exp $ (BRL)";
d3368 1
@


9.23
log
@Changed protocol to send DIRBUILD and GETTREES as separate operations.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/remrt.c,v 9.22 90/11/16 00:33:38 mike Exp $ (BRL)";
d426 3
d438 1
a438 1
		return("New");
d442 1
a442 1
		return("Doing_DIRBUILD");
d444 1
a444 1
		return("READY");
d446 1
a446 1
		return("--about to restart--");
d448 1
a448 1
		return("*closing*");
d450 1
a450 1
		return("Doing_GETTREES");
d452 1
a452 1
	sprintf(buf, "Unknown_state_x%x", state);
d1041 1
a1041 1
		rt_vls_vlscatzap( &fr->fr_cmd, &prelude );
a1044 2
			rt_log("'%s': unable to create file\n",
				fr->fr_filename);
d1054 4
a1057 1
out:	;
d1622 1
a1622 1
#define ASSIGNMENT_TIME		5		/* desired seconds/result */
a1624 1
#define MAX_LUMP		(8*1024)	/* max pixels/assignment */
d1627 43
d1708 1
a1708 1
	 *  The assignments are estimated to take only ASSIGNMENT_TIME
d1759 1
a1759 1
	 *  past behavior.  Using rays/elapsed_sec metric takes into
d1766 1
a1766 1
	sp->sr_lump = ASSIGNMENT_TIME * sp->sr_w_elapsed;
d1768 1
a1768 1
	if( sp->sr_lump > MAX_LUMP )  sp->sr_lump = MAX_LUMP;
d2168 1
a2168 1
		if( sp->sr_l_elapsed > ASSIGNMENT_TIME )  {
d3349 43
d3393 2
d3428 2
a3429 1
	rt_log("%s Servers:\n", s);
d3692 3
a3694 1
	"stat", "",		"server status",
@


9.22
log
@Added comments about state transition behavior.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/remrt.c,v 9.21 90/11/15 23:45:10 mike Exp $ (BRL)";
d102 2
a103 1
void		send_start();
d132 2
a133 1
void	ph_start();
d137 2
a138 1
	{ MSG_START,	ph_start,	"Startup ACK" },
d259 2
a260 2
 *	VERSOK		LOADING		send "start" command.
 *	LOADING		READY		ph_start pkg rcvd.
d262 2
a263 1
 * --	READY		READY		new frame:  call send_matrix()
a273 1
 * XXX LOADING --> NEEDFRAME, NEEDFRAME --> READY
d282 8
a289 7
#define SRST_UNUSED	0		/* unused slot */
#define SRST_NEW	1		/* connected, awaiting vers check */
#define SRST_VERSOK	2		/* version OK, no model loaded yet */
#define SRST_LOADING	3		/* loading, awaiting ready response */
#define SRST_READY	4		/* loaded, ready */
#define SRST_RESTART	5		/* about to restart */
#define SRST_CLOSING	6		/* Needs to be closed */
d425 29
d1258 1
a1258 2
		sprintf( name, "/usr/tmp/remrt%d.pix", getpid() );
		(void)unlink(name);	/* remove any previous one */
d1537 1
a1537 1
			/* advance this server to SRST_LOADING */
d1542 1
a1542 1
				send_start(sp);
d1699 4
d1840 1
a1840 1
 *			P H _ S T A R T
d1842 2
a1843 2
 *  The server answers our MSG_START with various prints, etc,
 *  and then responds with a MSG_START in return, which indicates
d1847 1
a1847 1
ph_start(pc, buf)
d1854 7
a1860 7
	if( strcmp( PROTOCOL_VERSION, buf ) != 0 )  {
		rt_log("ERROR %s: protocol version mis-match\n",
			sp->sr_host->ht_name);
		rt_log(" local='%s'\n", PROTOCOL_VERSION );
		rt_log("remote='%s'\n", buf );
		drop_server( sp, "protocol mis-match" );
		if(buf) (void)free(buf);
d1863 27
d1892 1
a1892 1
		rt_log("unexpected MSG_START from fd %d\n", pc->pkc_fd);
d1895 3
a1897 2
	if( sp->sr_state != SRST_LOADING )  {
		rt_log("MSG_START in state %d?\n", sp->sr_state);
d1917 2
d1990 3
a1992 2
	if( sp->sr_state != SRST_READY )  {
		rt_log("%s Ignoring package from %s\n",
d2381 1
a2381 1
 *			S E N D _ S T A R T
d2384 1
a2384 1
send_start(sp)
a2397 1
		sprintf( cmd, "%s %s", file_basename, object_list );
d2400 1
a2400 2
		/* Conversion was done when server was started */
		sprintf( cmd, "%s %s", file_basename, object_list );
d2403 1
a2403 1
		rt_log("send_start: ht_where=%d unimplemented\n", ihp->ht_where);
d2408 7
a2414 3
	if( pkg_send( MSG_START, cmd, strlen(cmd)+1, sp->sr_pc ) < 0 )
		drop_server(sp, "MSG_START pkg_send error");
	sp->sr_state = SRST_LOADING;
d2463 21
d3302 3
d3315 1
a3315 1
	if( file_fullname[0] == '\0' )
d3317 2
a3318 2
	else
		rt_log("\n%s %s %s %s\n",
d3320 4
a3323 2
			running ? "RUNNING" : "loaded",
			file_fullname, object_list );
d3340 3
a3342 17
		rt_log("  %2d  %s ", sp->sr_pc->pkc_fd, sp->sr_host->ht_name );
		switch( sp->sr_state )  {
		case SRST_NEW:
			rt_log("New"); break;
		case SRST_VERSOK:
			rt_log("Vers_OK"); break;
		case SRST_LOADING:
			rt_log("(Loading)"); break;
		case SRST_READY:
			rt_log("READY"); break;
		case SRST_RESTART:
			rt_log("--about to restart--"); break;
		case SRST_CLOSING:
			rt_log("*closing*"); break;
		default:
			rt_log("Unknown"); break;
		}
@


9.21
log
@Improved parsing of new-style animation scripts.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/remrt.c,v 9.20 90/11/11 02:38:38 mike Exp $ (BRL)";
d235 38
d801 2
a802 1
		rt_log("requeueing fr%d %d..%d\n",
@


9.20
log
@Prompted VLS string package to full, separate standing.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/remrt.c,v 9.18 90/10/16 11:22:12 mike Exp $ (BRL)";
a75 1
#include "./remrt.h"
d155 2
d174 1
d194 41
d874 15
d894 6
a899 4
	char	*buf;
	char	*ebuf;
	int	argc;
	char	*argv[64];
d901 2
a902 2
	struct rt_vls	prelude;
	int	frame;
d906 4
d911 1
a911 6
		if( strncmp( buf, "start", 5 ) != 0 )  {
			rt_vls_strcat( &prelude, buf );
			rt_vls_strcat( &prelude, ";" );
			rt_free( buf, "prelude line" );
			continue;
		}
d913 12
a925 1
		RT_VLS_INIT( &body );
d933 1
a933 1
			rt_free( ebuf, "script line" );
d935 4
d940 11
a950 1
		/* buf has saved "start" line in it */
d968 1
d970 2
d978 2
a981 2
	/* Doing an fclose here can result in a server showing up on fd 0 */
	/* fclose(fp); */
d1186 1
a1186 1
		sprintf( name, "/usr/tmp/remrt%d", getpid() );
d1296 4
d3169 1
@


9.19
log
@Fixed debugging
@
text
@d68 2
a116 1
/* ----- */
a117 99
struct vls  {
	long	vls_magic;
	char	*vls_str;
	int	vls_len;	/* Length, not counting the null */
	int	vls_max;
};
#define VLS_MAGIC		0x89333bbb

#define	VLS_STRLEN(vp)		((vp)->vls_len)

/*
 *			V L S _ I N I T
 *
 *  Used to initialize strings for which storage has already been obtained.
 */
void
vls_init( vp )
register struct vls	*vp;
{
	vp->vls_str = (char *)0;
	vp->vls_len = vp->vls_max = 0;
}

/*
 *			V L S _ T R U N C
 *
 *  Truncate string to at most 'len' characters.
 *  Truncating to length 0 releases the memory used for the string buffer.
 */
void
vls_trunc( vp, len )
register struct vls	*vp;
{
	if( vp->vls_len <= len )  return;
	if( len <= 0 )  {
		/* Release string storage */
		rt_free( vp->vls_str, "vls_trunc" );
		vp->vls_len = 0;
		vp->vls_str = (char *)0;
		return;
	}
	vp->vls_len = len;
}

/*
 *			V L S _ S T R C A T
 *
 *  Concatenate a new string onto the end of the existing vls string.
 */
void
vls_strcat( vp, s )
register struct vls	*vp;
char		*s;
{
	register int	len;

	if( (len = strlen(s)) <= 0 )  return;
	if( vp->vls_len <= 0 )  {
		vp->vls_str = rt_malloc( vp->vls_max = len*4, "vls initial" );
		vp->vls_len = 0;
	}
	if( vp->vls_len + len >= vp->vls_max )  {
		vp->vls_max = (vp->vls_max + len) * 2;
		vp->vls_str = rt_realloc( vp->vls_str, vp->vls_max, "vls" );
	}
	bcopy( s, vp->vls_str + vp->vls_len, len+1 );	/* include null */
	vp->vls_len += len;
}

/*
 *			V L S _ V L S C A T
 *
 *  Concatenate a new vls string onto the end of an existing vls string.
 *  The storage of the source string is not affected.
 */
void
vls_vlscat( dest, src )
register struct vls	*dest, *src;
{
	if( src->vls_len <= 0 )  return;
	vls_strcat( dest, src->vls_str );
}

/*
 *			V L S _ V L S C A T Z A P
 *
 *  Concatenate a new vls string onto the end of an existing vls string.
 *  The storage of the source string is released (zapped).
 */
void
vls_vlscatzap( dest, src )
register struct vls	*dest, *src;
{
	if( src->vls_len <= 0 )  return;
	vls_strcat( dest, src->vls_str );
	vls_trunc( src, 0 );
}


d172 1
a172 1
	struct vls	fr_cmd;		/* RT options & command string */
d439 1
a439 1
			vls_strcat( &fr->fr_cmd, buf);
d840 2
a841 2
	struct vls	body;
	struct vls	prelude;
d845 1
a845 1
	vls_init( &prelude );
d848 2
a849 2
			vls_strcat( &prelude, buf );
			vls_strcat( &prelude, ";" );
d855 1
a855 1
		vls_init( &body );
d861 2
a862 2
			vls_strcat( &body, ebuf );
			vls_strcat( &body, ";" );
d875 1
a875 1
			rt_free( body.vls_str, "script" );
d882 2
a883 2
		vls_vlscatzap( &fr->fr_cmd, &prelude );
		vls_vlscatzap( &fr->fr_cmd, &body );
d1023 1
a1023 1
	vls_trunc( &fr->fr_cmd, 0 );	/* Start fresh */
d1030 3
a1032 3
	vls_strcat( &fr->fr_cmd, buf );
	if( interactive )  vls_strcat( &fr->fr_cmd, " -I");
	if( benchmark )  vls_strcat( &fr->fr_cmd, " -B");
d1035 1
a1035 1
		vls_strcat( &fr->fr_cmd, buf );
d1037 1
a1037 1
	vls_strcat( &fr->fr_cmd, ";" );
d1625 1
a1625 1
	vls_strcat( &(fr->fr_cmd), cmd );
d1630 1
a1630 1
		vls_strcat( &fr->fr_cmd, cmd );
d1634 1
a1634 1
	vls_strcat( &fr->fr_cmd, cmd );
d1639 1
a1639 1
		vls_strcat( &fr->fr_cmd, cmd );
d1641 1
a1641 1
	vls_strcat( &fr->fr_cmd, "; ");
d2258 1
a2258 1
	    fr->fr_cmd.vls_str, VLS_STRLEN(&fr->fr_cmd)+1, sp->sr_pc
d2740 2
a2741 2
	int	len;
	char	rd_buffer[80];		/* Should be tied to argv[1] len XXX */
d2743 4
a2746 4

	strcpy(rd_buffer, "opt ");
	strcat(rd_buffer, argv[1]);
	len = strlen(rd_buffer)+1;
d2749 1
a2749 1
		if( pkg_send( MSG_OPTIONS, rd_buffer, len, sp->sr_pc) < 0 )
d3077 1
a3077 1
		rt_log("\tcmd=%s\n", fr->fr_cmd.vls_str );
@


9.18
log
@Improvements to VLS package
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/remrt.c,v 9.17 89/11/24 23:00:49 mike Exp $ (BRL)";
d2839 1
d2841 4
a2844 1
	len = strlen(argv[1])+1;
d2847 1
a2847 1
		if( pkg_send( MSG_OPTIONS, argv[1], len, sp->sr_pc) < 0 )
@


9.17
log
@Added more error handling to deal with write errors to the picture files.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 9.16 89/11/23 00:49:09 mike Locked $ (BRL)";
d115 2
d118 1
d120 1
a120 1
	int	vls_cur;	/* Length, not counting the null */
d123 1
d125 7
a135 1
	vp->vls_cur = vp->vls_max = 0;
d137 1
d140 6
d147 1
a147 1
vls_cat( vp, s )
d149 20
d173 2
a174 2
	len = strlen(s);
	if( vp->vls_cur <= 0 )  {
d176 1
a176 1
		vp->vls_cur = 0;
d178 1
a178 1
	if( vp->vls_cur + len >= vp->vls_max )  {
d182 2
a183 2
	bcopy( s, vp->vls_str + vp->vls_cur, len+1 );
	vp->vls_cur += len;
d186 6
d193 2
a194 2
vls_2cat( op, ip )
register struct vls	*op, *ip;
d196 2
a197 3
	vls_cat( op, ip->vls_str );
	rt_free( ip->vls_str, "vls_2cat input vls_str" );
	vls_init( ip );
d200 16
d537 1
a537 1
			vls_cat( &fr->fr_cmd, buf);
d946 2
a947 2
			vls_cat( &prelude, buf );
			vls_cat( &prelude, ";" );
d959 2
a960 2
			vls_cat( &body, ebuf );
			vls_cat( &body, ";" );
d980 2
a981 6
		if( prelude.vls_cur > 0 )  {
			vls_2cat( &fr->fr_cmd, &prelude );
		}
		if( body.vls_cur > 0 )  {
			vls_2cat( &fr->fr_cmd, &body );
		}
d1121 1
a1121 1
	fr->fr_cmd.vls_cur = 0;	/* free existing? */
d1128 3
a1130 3
	vls_cat( &fr->fr_cmd, buf );
	if( interactive )  vls_cat( &fr->fr_cmd, " -I");
	if( benchmark )  vls_cat( &fr->fr_cmd, " -B");
d1133 1
a1133 1
		vls_cat( &fr->fr_cmd, buf );
d1135 1
a1135 1
	vls_cat( &fr->fr_cmd, ";" );
d1723 1
a1723 1
	vls_cat( &(fr->fr_cmd), cmd );
d1728 1
a1728 1
		vls_cat( &fr->fr_cmd, cmd );
d1732 1
a1732 1
	vls_cat( &fr->fr_cmd, cmd );
d1737 1
a1737 1
		vls_cat( &fr->fr_cmd, cmd );
d1739 1
a1739 1
	vls_cat( &fr->fr_cmd, "; ");
d2356 1
a2356 1
	    fr->fr_cmd.vls_str, fr->fr_cmd.vls_cur+1, sp->sr_pc
@


9.16
log
@Use different blending values, depending on whether the server went
faster or slower than expected.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 9.15 89/11/23 00:38:36 mike Locked $ (BRL)";
d490 1
a490 1
		if(debug) cd_frames( 0, (char **)0 );
d1763 1
a1763 1
		rt_log("%s %s:%s",
d1863 1
a1863 1
		rt_log("%s %s:fr=%d, %d..%d, ry=%d, cpu=%g, el=%g\n",
d1924 2
a1925 3
		/* XXX Now what? Drop frame? */
	}
	if( lseek( fd, info.li_startpix*3L, 0 ) < 0 )  {
a1926 1
		/* Again, now what? */
d1928 2
d1932 1
a1932 1
		perror("write");
d1934 15
a1948 1
		/* Again, now what? */
@


9.15
log
@Added timestamp function stamp(),
changed all common calls to rt_log() to timestamp their messages.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 9.14 89/11/22 23:10:55 mike Locked $ (BRL)";
d1952 18
d1971 4
a1974 5
#define BLEND	0.8
		sp->sr_w_elapsed = BLEND * sp->sr_w_elapsed +
			(1.0-BLEND) * sp->sr_l_el_rate;
		sp->sr_w_rays = BLEND * sp->sr_w_rays +
			(1.0-BLEND) * (info.li_nrays/sp->sr_l_elapsed);
@


9.14
log
@Ignore weighted timing on packages that were probably buffered.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 9.13 89/11/22 22:44:00 mike Locked $ (BRL)";
d357 23
d427 2
a428 1
		rt_log("Interactive REMRT listening at port %d\n", pkg_permport);
d442 1
a442 1
		rt_log("remrt out of clients\n");
d444 2
a445 1
		rt_log("Automatic REMRT listening at port %d, reading script on stdin\n",
d495 1
a495 1
		rt_log("remrt:  task accomplished\n");
d538 1
a538 2
			rt_log("remrt:  Notice:  all servers down at %s\n",
				ctime( &(now.tv_sec) ) );
d614 1
a614 1
		if(debug>1) rt_log("select timed out after %d seconds\n", waittime);
d693 1
a693 1
	if( debug )  rt_log("addclient(%s)\n", ihp->ht_name);
d736 1
a736 1
	rt_log("dropping %s (%s)\n", sp->sr_host->ht_name, why);
d790 1
a790 1
	rt_log("seeking servers to start\n");
d826 2
a827 1
				rt_log("auto dropping %s:  out of time range\n",
d838 1
a838 1
			rt_log("auto adding %s\n", ihp->ht_name);
d1180 1
a1180 1
		rt_log("Scanning %s for non-black pixels\n",
d1213 2
a1214 1
			rt_log("deleting non-black pixel range %d to %d inclusive\n",
d1219 1
a1219 1
		rt_log("Scanning complete\n");
d1238 2
a1239 1
	rt_log("frame %d DONE: %g elapsed sec, %d rays/%g cpu sec\n",
d1244 2
a1245 1
	rt_log("  RTFM=%g rays/sec (%g rays/cpu sec)\n",
d1262 1
a1262 1
		if(debug) printf("script %s\n", cmd);
d1429 1
a1429 1
			if(debug>1) rt_log("final close on %s\n", sp->sr_host->ht_name);
d1462 1
a1462 1
		rt_log("remrt:  All work done!\n");
d1555 1
a1555 1
		rt_log("%s: *TARDY*\n", sp->sr_host->ht_name);
d1762 6
a1767 2
	if(print_on)
		rt_log("%s:%s", servers[pc->pkc_fd].sr_host->ht_name, buf );
d1809 1
a1809 1
	rt_log("%s: cmd '%s'\n", sp->sr_host->ht_name, buf );
d1839 2
a1840 1
		rt_log("ignoring package from %s\n", sp->sr_host->ht_name);
d1863 2
a1864 1
		rt_log("%s:fr=%d, %d..%d, ry=%d, cpu=%g, el=%g\n",
d2423 4
a2426 2
			if(debug)
				rt_log("%s\n", cmd); fflush(stdout);
d2463 4
a2466 2
			if(debug)
				rt_log("%s\n", cmd); fflush(stdout);
d2739 1
a2739 1
	rt_log("dispatcher debug=x%x\n", debug );
d2836 1
a2836 1
	rt_log("read file done\n");
d2997 1
a2997 1
		rt_log("restarting all\n");
d3014 1
a3014 1
	rt_log("no more scanlines being scheduled, done soon\n");
d3063 6
d3076 1
a3076 2
	/* Sumarize frames waiting */
	rt_log("Frames waiting:\n");
d3096 1
d3098 2
d3103 2
a3104 1
		rt_log("\n%s %s %s\n",
d3109 1
a3109 1
		rt_log("Framebuffer is %s\n", fbp->if_name);
d3111 1
a3111 1
		rt_log("No framebuffer\n");
d3113 5
a3117 4
		rt_log("Output file: %s.###\n", outputfile );
	rt_log("Printing of remote messages is %s\n",
		print_on?"ON":"Off" );
    	rt_log("Listening at %s, port %d\n", ourname, pkg_permport);
d3120 1
a3120 1
	rt_log("Servers:\n");
d3190 2
a3191 1
	rt_log("Printing of remote messages is %s\n",
d3226 1
a3226 1
			rt_log("Stopped, waiting for servers to become idle\n");
d3229 1
a3229 1
		rt_log("All servers idle\n");
d3258 1
a3258 1
		rt_log("Registered Host Table:\n");
@


9.13
log
@Eliminated fr_servinit[] array and sr_index.
Which frame a server is currently prepped for is determined entirely
by sr_curframe.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 9.12 89/11/22 22:20:39 mike Locked $ (BRL)";
d1811 8
a1818 2
	if( (sp->sr_l_elapsed = tvdiff( &tvnow, &sp->sr_sendtime )) < 0.1 )
		sp->sr_l_elapsed = 0.1;
d1820 3
d1910 4
a1913 1
	/* Stash the statistics that came back */
d1916 3
a1918 1
	sp->sr_l_el_rate = npix / sp->sr_l_elapsed;
d1920 10
a1929 11
	sp->sr_w_elapsed = BLEND * sp->sr_w_elapsed +
		(1.0-BLEND) * sp->sr_l_el_rate;
	sp->sr_w_rays = BLEND * sp->sr_w_rays +
		(1.0-BLEND) * (info.li_nrays/sp->sr_l_elapsed);
	sp->sr_sendtime = tvnow;		/* struct copy */
	sp->sr_l_cpu = info.li_cpusec;
	sp->sr_s_cpu += info.li_cpusec;
	sp->sr_s_elapsed += sp->sr_l_el_rate;
	sp->sr_sq_elapsed += sp->sr_l_el_rate * sp->sr_l_el_rate;
	sp->sr_nsamp++;
	sp->sr_l_percent = info.li_percent;
@


9.12
log
@Added in Chris' EOFframe support
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 9.11 89/11/17 20:49:00 mike Locked $ (BRL)";
a212 1
	char		fr_servinit[MAXSERVERS]; /* sent server options & matrix? */
a245 1
	int		sr_index;	/* fr_servinit[] index */
a679 1
	sp->sr_index = fd;
a684 1
		fr->fr_servinit[sp->sr_index] = 0;
a1057 2
	bzero( fr->fr_servinit, sizeof(fr->fr_servinit) );

a1406 1
			sp->sr_index = -1;
d1543 6
a1548 2
	 *  Provide info about this frame, if this is the first assignment
	 *  of work from this frame to this server.
d1550 2
a1551 1
	if( fr->fr_servinit[sp->sr_index] == 0 )  {
a1552 2
		fr->fr_servinit[sp->sr_index] = 1;
		sp->sr_curframe = fr;
a3028 4
		rt_log("\tservinit: ");
		for( i=0; i<MAXSERVERS; i++ )
			rt_log("%d", fr->fr_servinit[i]);
		rt_log("\n");
d3062 1
a3062 1
		rt_log("  %2d  %s ", sp->sr_index, sp->sr_host->ht_name );
@


9.11
log
@Added weighted rays/second traking to the server structures.
added rays/second load checking (drop server is r/s is to low)
added rs[ rays/sec] and passrs[ rays/sec] analagies for always
and passive r/s limited servers.
Added N command to set height of a frame buffer.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 9.10 89/11/17 00:13:46 mike Exp $ (BRL)";
d189 1
d1232 12
d3284 3
d3294 24
d3353 2
d3362 4
a3374 4
	"S", "square_size",	"set square frame buffer size",
		cd_S,		2, 2,
	"N", "square_height",	"set height of frame buffer",
		cd_N,		2, 2,
@


9.10
log
@Added "exit" command.
Expanded definition of "wait" command.
If processing is stopped, then waits for results from servers to
come in.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 9.9 89/11/16 23:40:06 mike Locked $ (BRL)";
d252 1
d269 6
d278 2
d784 7
d793 1
d1899 2
d1912 16
d2100 1
a2100 1
	while( yy < width )
d2103 1
a2103 1
		rt_log("fb_open %d,%d failed\n", width, height);
d2107 2
a2108 2
	fb_zoom( fbp, fb_getwidth(fbp)/width, fb_getheight(fbp)/height );
	fb_window( fbp, width/2, height/2 );
d2728 11
d3090 4
a3093 1
			sp->sr_w_elapsed );
d3162 1
d3188 1
d3204 6
d3229 1
a3229 1
	if( (ihp = host_lookup_by_name( argv[1], 1 )) == IHOST_NULL )  return;
d3232 1
a3232 1
	if( strcmp( argv[2], "always" ) == 0 ) {
d3234 1
a3234 1
	} else if( strcmp( argv[2], "night" ) == 0 )  {
d3236 1
a3236 1
	} else if( strcmp( argv[2], "passive" ) == 0 )  {
d3238 4
d3243 1
a3243 1
		rt_log("unknown 'when' string '%s'\n", argv[2]);
d3245 10
d3257 1
a3257 1
	if( strcmp( argv[3], "cd" ) == 0 )  {
d3259 2
a3260 2
		ihp->ht_path = rt_strdup( argv[4] );
	} else if( strcmp( argv[3], "convert" ) == 0 )  {
d3262 4
a3265 1
		ihp->ht_path = rt_strdup( argv[4] );
d3267 1
a3267 1
		rt_log("unknown 'where' string '%s'\n", argv[3] );
d3307 2
a3308 2
	"host", "name always|night|passive cd|convert path", "register server host",
		cd_host,	1, 5,
d3331 2
@


9.9
log
@host_lookup_by_addr() now checks to see if a dotted quad
has been entered before, rather than continuously
creating more entries.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 9.8 89/11/16 21:40:59 mike Locked $ (BRL)";
d1274 21
d1317 4
a1320 6
	for( sp = &servers[0]; sp < &servers[MAXSERVERS]; sp++ )  {
		if( sp->sr_pc == PKC_NULL )  continue;
		if( sp->sr_work.li_forw == &(sp->sr_work) )  continue;
		return(0);		/* nope, still more work */
	}
	return(1);			/* All done */
d3093 7
a3099 2
	while( running && clients && FrameHead.fr_forw != &FrameHead )  {
		check_input( 30 );	/* delay up to 30 secs */
d3101 12
a3112 2
		(void)gettimeofday( &now, (struct timezone *)0 );
		schedule( &now );
d3197 7
d3237 2
@


9.8
log
@This version does proper error checking on pixel reply packages.
"mat" and "movie" commands should be more robust in the face of
having parsing problems or unexpected EOFs on frame file.
Fixed CHECK_FRAME() check in "reset" command.
[All problems identified by Chris Johnson]
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 9.7 89/11/15 03:40:13 mike Locked $ (BRL)";
d375 15
a389 3
	if( (tcp_listen_fd = pkg_permserver("rtsrv", "tcp", 8, rt_log)) < 0 &&
	    (tcp_listen_fd = pkg_permserver("4446", "tcp", 8, rt_log)) < 0 )
		exit(1);
d704 2
d713 2
d720 1
a720 1
	sp->sr_state = SRST_CLOSING;
d1358 1
a1358 1
			if(debug) rt_log("final close on %s\n", sp->sr_host->ht_name);
d2258 2
a2259 1
#ifdef CRAY2
d2313 2
a2314 3
#if 0
			rt_log("%s\n", cmd); fflush(stdout);
#endif
d2323 2
d2329 2
d2351 2
a2352 3
#if 0
			rt_log("%s\n", cmd); fflush(stdout);
#endif
d2508 3
d2516 1
d2545 7
a2551 1
	/* Print up a hostent structure */
d2555 3
@


9.7
log
@Added a new "closing" state, so that if the decision is made to drop
a server in the middle of several back-to-back packages, all the
state of the package library isn't yanked out from under it while
deeply recursed.
This prevents REMRT from dumping core when the XMP blasts us with
a batch of crappy packages.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 9.6 89/11/15 02:55:27 mike Locked $ (BRL)";
d1528 1
a1528 1
	APPEND_LIST( lp, &(sp->sr_work) );
d1558 7
d1578 1
a1578 1
	if( fscanf( fp, "%s", number ) != 1 )  goto out;
d1599 2
a1600 2
out:
		rt_log("EOF on frame file.\n");
d1604 3
d1735 1
d1756 1
d1766 4
a1769 4
	/* XXX this is bogus -- assignments may have moved on to subsequent
	 * frames.  Need to search frame list */
	if( (fr = sp->sr_curframe) == FRAME_NULL )  {
		rt_log("%s: no current frame, discarding\n");
d1772 8
a1781 1
	/* Don't be so trusting... */
d1783 2
a1784 1
		rt_log("frame number mismatch, claimed=%d, actual=%d\n",
d1789 10
d1820 1
a1820 1
		/* Now what? Drop frame? */
d2738 5
a2742 1
		if(read_matrix( fp, fr ) < 0 ) break;
d2780 5
a2784 1
		if(read_matrix( fp, &dummy_frame ) < 0 ) break;
d2787 1
d2791 6
a2796 1
		if(read_matrix( fp, fr ) < 0 ) break;
d2872 1
a2873 1
		fr = FrameHead.fr_forw;
@


9.6
log
@Changed debug level on print
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 9.5 89/11/15 02:48:34 mike Locked $ (BRL)";
d244 1
d672 3
d704 1
a704 1
	clients &= ~(1<<fd);
a705 8
	sp->sr_pc = PKC_NULL;
	sp->sr_state = SRST_UNUSED;
	sp->sr_index = -1;
	sp->sr_host = IHOST_NULL;

	/* After most server state has been zapped, close PKG connection */
	pkg_close(pc);

d1326 1
a1326 1
	/* Kick off any new servers */
a1328 1
		if( sp->sr_state != SRST_VERSOK )  continue;
d1330 4
a1333 2
		/* advance this server to SRST_LOADING */
		send_loglvl(sp);
d1335 18
a1352 3
		/* An error may have caused connection to drop */
		if( sp->sr_pc == PKC_NULL )  continue;
		send_start(sp);
d1734 5
d2928 2
@


9.5
log
@Added magic numbers to the frame structure,
plus some code to check them.
Changed from pkg_get() to pkg_process() and pkg_suckin().
Added explanation string to drop_server().
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 9.4 89/11/14 19:05:20 mike Locked $ (BRL)";
d569 1
a569 1
		if(debug) rt_log("select timed out after %d seconds\n", waittime);
@


9.4
log
@Added code to scan incomplete frames, deleting any non-black pixels
that were already computed.
This provides "checkpoint restart" down to the pixel level;
previously, checkpoints were established only at the frame level.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 9.3 89/08/23 03:27:11 mike Locked $ (BRL)";
d198 2
a199 1
	int		fr_number;	/* frame number */
d217 1
d219 13
d370 1
d545 1
d547 1
d549 9
d562 2
a563 2
	i=select(32, (char *)&ibits, (char *)0, (char *)0, &tv);
	if( i < 0 )  {
d567 7
a573 1
	/* First, accept any pending connections */
a574 1
		register struct pkg_conn *pc;
d580 2
a581 1
	/* Second, give priority to getting traffic off the network */
a585 1
		if( i == tcp_listen_fd )  continue;
d588 7
a594 2
		if( pkg_get(pc) < 0 )
			drop_server( &servers[i] );
d597 9
d648 1
d664 1
d673 1
a673 1
drop_server(sp)
d675 1
d688 1
a688 1
	rt_log("dropping %s\n", sp->sr_host->ht_name);
d716 1
d778 1
a778 1
				drop_server( sp );
d982 1
a982 1
				drop_server(sp);
d1001 1
d1010 2
d1066 1
d1088 2
d1183 2
d1213 2
d1245 2
d1278 1
d1346 1
d1372 1
d1433 2
d1458 1
a1458 1
		drop_server( sp );
d1556 2
d1626 1
a1626 1
		drop_server( sp );
d1637 1
a1637 1
		drop_server( sp );
d1672 1
a1672 1
		drop_server( sp );
d1697 1
a1697 1
	drop_server( sp );
d1743 1
d1749 1
a1749 1
		drop_server( sp );
d1755 1
a1755 1
		drop_server( sp );
d1766 1
a1766 1
		drop_server( sp );
d1879 2
d1939 1
d2002 2
a2003 2
size_display(fp)
register struct frame	*fp;
d2005 2
a2006 1
	if( cur_fbwidth == fp->fr_width )
d2010 3
a2012 3
	if( fp->fr_width > fb_getwidth(fbp) )  {
		rt_log("Warning:  fb not big enough for %d pixels, display truncated\n", fp->fr_width );
		cur_fbwidth = fp->fr_width;
d2015 1
a2015 1
	cur_fbwidth = fp->fr_width;
d2017 2
a2018 2
	fb_zoom( fbp, fb_getwidth(fbp)/fp->fr_width,
		fb_getheight(fbp)/fp->fr_height );
d2020 1
a2020 1
	fb_window( fbp, fp->fr_width/2, fp->fr_height/2 );
d2040 1
a2040 1
			drop_server(sp);
d2049 1
a2049 1
		drop_server(sp);
d2054 1
a2054 1
		drop_server(sp);
d2068 1
a2068 1
		drop_server(sp);
d2082 1
a2082 1
		drop_server(sp);
d2095 1
d2100 1
a2100 1
		drop_server(sp);
d2107 1
a2107 1
send_do_lines( sp, start, stop, fr )
d2111 1
a2111 1
int		fr;
d2117 1
a2117 1
	sprintf( obuf, "%d %d %d", start, stop, fr );
d2119 1
a2119 1
		drop_server(sp);
d2566 1
a2566 1
			drop_server(sp);
a2676 2
	prep_frame(fr);

d2682 2
d2733 1
a2734 1
		fr->fr_number = i;
d2768 1
a2768 1
	drop_server(sp);
d2811 1
d2832 1
d2855 1
d2915 1
@


9.3
log
@added 'S' command to set fb size independent of image size
added 's' as an alias of 'f' (the old rt size parameter)
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 9.2 89/06/19 22:56:18 phil Locked $ (BRL)";
a1069 1
XXX
d1071 5
a1075 1
		rt_log("...need to scan %s for non-black pixels (deferred)\n",
d1077 37
d1780 1
d2059 8
a2066 3
		rt_log("\t%d..%d frame %d\n",
			lp->li_start, lp->li_stop,
			lp->li_frame->fr_number );
@


9.2
log
@xmp STDC fix
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 9.1 89/05/19 06:00:22 mike Locked $ (BRL)";
d160 2
d1860 7
a1866 8
#if 1
	/* Large-screen version, for demonstrations */
	xx = yy = 1024;
#else
	/* one-to-one version */
	xx = width;
	yy = height;
#endif
d2461 13
d2990 4
@


9.1
log
@Release_3.5
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 8.49 89/05/12 20:20:49 mike Exp $ (BRL)";
d58 1
a58 1
#  if CRAY1
@


8.49
log
@Unicos 5.0 is no longer broken.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 8.48 89/04/22 05:08:15 mike Locked $ (BRL)";
@


8.48
log
@Corrected for silly situation with time.h and sys/time.h
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 8.47 89/04/04 04:53:07 mike Locked $ (BRL)";
d2329 1
a2329 1
#ifdef CRAY
d2369 1
a2369 1
#ifdef CRAY
@


8.47
log
@Converted to new way of doing structure offsets.
Changed external declarations of system functions to use externs.h
Fixed bug with "attach" command (arg to fb_open)
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 8.46 89/03/20 02:51:00 mike Locked $ (BRL)";
d43 21
a63 5
#if !defined(CRAY1)
# include <sys/time.h>		/* for struct timeval */
#endif
#if !defined(sun)
# include <time.h>
@


8.46
log
@Made gratitutous "frame" command conditional on internal debugging.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 8.45 89/03/19 23:18:32 mike Locked $ (BRL)";
d55 1
a281 2
extern char *malloc();

d433 5
d1598 1
a1598 1
	i = struct_import( (stroff_t)&info, desc_line_info, buf );
d1854 1
a1854 1
	if( (fbp = fb_open( framebuffer, xx, yy )) == FBIO_NULL )  {
@


8.45
log
@Added 1k screen size (compile time option),
fixed writing to screen when framebuffer is zoomed,
fixed one minor memory leak.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 8.44 89/03/16 02:02:16 mike Locked $ (BRL)";
d411 1
a411 1
		cd_frames( 0, (char **)0 );
@


8.44
log
@Added code to detect when all servers have gone away,
and remark on it.
Useful for Lee when he examines his log files.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 8.43 89/03/16 01:18:28 mike Exp $ (BRL)";
d1748 2
a1749 2
	x = a % fb_getwidth(fbp);
	y = (a / fb_getwidth(fbp)) % fb_getheight(fbp);
d1752 1
a1752 1
	/* Simple case */
d1759 7
a1765 1
	/* Hard case -- clip drawn region to the framebuffer */
d1768 7
a1774 1
		write_len = fb_getwidth(fbp) - x;
d1780 1
a1780 2
		a += len_to_eol;
		y = (y+1) % fb_getheight(fbp);
d1824 1
d1834 2
d1837 14
a1850 1
	if( (fbp = fb_open( name, width, height )) == FBIO_NULL )  {
d1854 4
@


8.43
log
@Moved debug --> rdebug (remote debug),
added new "debug" command to toggle dispatcher printing of results.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 8.42 89/03/16 00:44:21 mike Locked $ (BRL)";
a323 1
	struct timeval	now;
d356 3
a358 5
		while(clients)  {
			check_input( 30 );	/* delay up to 30 secs */

			(void)gettimeofday( &now, (struct timezone *)0 );
			schedule( &now );
d360 5
a364 3
		/* Might want to see if any work remains, and if so,
		 * record it somewhere */
		rt_log("REMRT out of clients\n");
d415 21
a435 1
		while( FrameHead.fr_forw != &FrameHead )  {
d438 3
a440 1
			check_input( 30 );	/* delay up to 30 secs */
d442 10
a451 2
			(void)gettimeofday( &now, (struct timezone *)0 );
			schedule( &now );
d453 6
a458 1
		rt_log("REMRT:  task accomplished\n");
a459 1
	return(0);			/* exit(0); */
d1238 1
a1238 1
		rt_log("REMRT:  All work done!\n");
@


8.42
log
@added printing of RCSid to startup.
Changed checking for whether output file already exists and is not
writable.  Now checks when frame description is read, rather than
when first assignment is made.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 8.41 89/03/16 00:11:53 mike Locked $ (BRL)";
d44 1
a44 1
#include <sys/time.h>		/* for struct timeval */
d47 1
a47 1
#include <time.h>
d286 2
d1566 6
a1571 6
#if 0
	rt_log("%s:fr=%d, %d..%d, ry=%d, cpu=%g, el=%g\n",
		sp->sr_host->ht_name,
		info.li_frame, info.li_startpix, info.li_endpix,
	info.li_nrays, info.li_cpusec, sp->sr_l_elapsed );
#endif
d2326 5
d2335 18
d2637 1
a2637 1
		if( fr->fr_filename )  rt_log(" %s\n", fr->fr_filename );
d2640 1
a2640 1
		rt_log("       servinit: ");
d2642 1
a2642 1
			rt_log("%d ", fr->fr_servinit[i]);
d2645 1
a2645 1
		rt_log("cmd=%s\n", fr->fr_cmd.vls_str );
d2709 2
a2710 4
		/* May want to print this only on debugging flag */
#if 0
		pr_list( &(sp->sr_work) );
#endif
d2886 4
a2889 2
	"debug", "options",	"set remote debugging flags",
		cd_debug,	2, 2,
@


8.41
log
@Fixed core dumping problem.
@
text
@d20 1
a20 1
 *	This software is Copyright (C) 1985 by the United States Army.
d23 1
a23 3
#ifndef lint
static char RCSid[] = "@@(#)$Header: remrt.c,v 8.40 89/03/15 22:39:06 mike Locked $ (BRL)";
#endif
d326 2
a327 1
	width = height = 64;
d329 2
d400 5
a404 2
			create_outputfilename( fr );
			APPEND_FRAME( fr, FrameHead.fr_back );
d770 5
a774 2
		create_outputfilename( fr );
		APPEND_FRAME( fr, FrameHead.fr_back );
d961 8
d974 2
a984 1
}
a985 24
/*
 *			F R A M E _ S T A R T
 *
 *  This code is called just before the first time work is to be
 *  assigned from this frame, to a server.
 *  In some cases, the caller will be told to skip this frame.
 *
 *  Returns -
 *	 0	OK
 *	-1	drop this frame
 */
int
frame_start(fr)
register struct frame	*fr;
{
	struct stat	sb;
	int		fd;

	if( fr->fr_filename == (char *)0 ||
	    fr->fr_filename[0] == '\0' )  {
	    	rt_log("frame_start(%d):  null filename!\n",fr->fr_number);
	    	return(-1);
	}

d1001 1
a1001 1
		goto begin;
d1013 1
a1013 1
xxx
d1018 1
a1018 5

begin:
	/* Note when actual work on this frame was started */
	(void)gettimeofday( &fr->fr_start, (struct timezone *)0 );
	return(0);			/* this frame is OK */
d1271 9
d1320 2
a1321 5
		if( frame_start( fr ) < 0 )  {
			/* Skip this frame after all */
			destroy_frame( fr );	/* will dequeue */
			return(-1);		/* restart scan */
		}
d1418 1
a1418 2
	create_outputfilename( fr );
	return(0);	/* OK */
d2419 5
d2444 3
a2446 1
	for( i=fr->fr_number; i>=0; i-- )
d2448 1
d2451 5
a2455 1
	APPEND_FRAME( fr, FrameHead.fr_back );
d2484 1
a2484 1
	for( i=0; i<a; i++ )
d2486 1
d2492 5
a2496 1
		APPEND_FRAME( fr, FrameHead.fr_back );
@


8.40
log
@Added handling for all the useful RT options, to export them
to the servers.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 8.39 89/03/15 20:30:27 mike Locked $ (BRL)";
d1172 1
d1221 1
a1222 4
		if( fr == FRAME_NULL )  {
			rt_log("fr=NULL, aborting\n");
			abort();
		}
d1228 6
d1237 6
a1242 1
				another_pass += task_server( fr, sp, nowp );
d1265 1
d1325 2
a1326 2
			frame_is_done( fr );	/* will dequeue */
			return(1);		/* need more work */
@


8.39
log
@lint-like fixes.
Now possible to change "outputfile" between frames and still
have the right thing happen -- fr_filename is used to hold
the file name intended for each frame now.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 8.38 89/03/11 23:27:35 mike Locked $ (BRL)";
d98 1
d248 12
a259 1
/* RT Options */
d262 2
a263 1
extern int	hypersample;
d265 1
a265 1
extern double	rt_perspective;
a267 1
int		use_air = 0;
a269 1
extern double	azimuth, elevation;
d364 2
a365 1
		rt_log("Automatic REMRT listening at port %d\n", pkg_permport);
d900 1
a900 2
	if( benchmark )  vls_cat( &fr->fr_cmd, "opt -B;" );
	sprintf(buf, "opt -w%d -n%d -H%d -p%g;",
d902 4
a905 1
		hypersample, rt_perspective );
d907 7
@


8.38
log
@XMP fix
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 8.37 89/03/10 05:05:03 mike Locked $ (BRL)";
d72 27
d253 1
a253 1
int		benchmark = 0;
d307 1
a311 1
	register int i;
d387 1
d408 1
a408 1
	exit(0);
d418 1
d450 1
d454 2
a455 3
	static long ibits, obits, ebits;
	register struct list *lp;
	register int i;
d499 1
a506 1
	int		options = 0;
d551 1
d611 1
d698 1
d754 1
d820 1
a824 1
	char obuf[256];
d876 1
d932 18
d960 1
a963 1
	char		name[512];
d967 4
a970 6
	/* Always create a file name to write into */
	if( outputfile )  {
		sprintf( name, "%s.%d", outputfile, fr->fr_number );
	} else {
		sprintf( name, "/usr/tmp/remrt%d", getpid() );
		(void)unlink(name);	/* remove any previous one */
a971 1
	fr->fr_filename = rt_strdup( name );
d1015 1
a1018 1
	char	name[256];
a1019 2
	int	fd;
	int	cnt;
d1043 1
d1142 1
a1147 1
	int		servers_going;		/* # servers still going */
d1238 1
d1341 1
d1358 1
d1393 1
d1629 1
d1632 1
d1674 1
d1722 1
d1776 1
d1800 1
d1835 1
d1849 1
d1864 1
d1879 1
d1882 3
d1900 1
d1913 1
d1926 1
d1983 1
d2082 1
a2086 1
	int	i;
d2121 1
d2391 1
a2392 1
	rt_log("frames will be recorded in %s.###\n", outputfile);
@


8.37
log
@Added error checking.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 8.36 89/03/08 22:59:04 mike Locked $ (BRL)";
d33 3
a35 1
#ifdef BSD
a38 2
#else
# include <string.h>
@


8.36
log
@Added SUNOS 3.4 #ifdef
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 8.35 89/03/08 22:40:58 mike Locked $ (BRL)";
d302 1
a302 1
	    (tcp_listen_fd = pkg_permserver("20210", "tcp", 8, rt_log)) < 0 )
d1127 1
a1127 1
	while( fr != &FrameHead )  {
d1152 4
@


8.35
log
@Changed from using errlog to rt_log
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 8.34 89/03/04 04:09:18 mike Locked $ (BRL)";
a31 1
#include <time.h>
d45 1
a45 1
#ifndef CRAY1
d47 3
@


8.34
log
@Added "wait" command for interactive mode.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 8.33 89/03/04 03:11:02 mike Locked $ (BRL)";
a248 13
 *			E R R L O G
 *
 *  Log an error from the pkg library
 */
/* VARARGS */
void
errlog( str, a, b, c, d, e, f, g, h )
char *str;
{
	(void)fprintf( stderr, str, a, b, c, d, e, f, g, h );
}

/*
d299 2
a300 2
	if( (tcp_listen_fd = pkg_permserver("rtsrv", "tcp", 8, errlog)) < 0 &&
	    (tcp_listen_fd = pkg_permserver("20210", "tcp", 8, errlog)) < 0 )
d308 1
a308 1
		printf("Interactive REMRT listening at port %d\n", pkg_permport);
d322 1
a322 1
		printf("REMRT out of clients\n");
d324 1
a324 1
		printf("Automatic REMRT listening at port %d\n", pkg_permport);
d376 1
a376 1
		printf("REMRT:  task accomplished\n");
d439 1
a439 1
		pc = pkg_getclient(tcp_listen_fd, pkgswitch, errlog, 1);
d493 1
a493 1
		printf("abandoning this unknown server!!\n");
d530 1
a530 1
		printf("drop_server(x%x), sr_host=0\n", sp);
d534 1
a534 1
	printf("dropping %s\n", sp->sr_host->ht_name);
d538 1
a538 1
		printf("drop_server(x%x), sr_pc=0\n", sp);
d543 1
a543 1
		printf("drop_server: fd=%d is unreasonable, forget it!\n", fd);
d563 1
a563 1
		printf("requeueing fr%d %d..%d\n",
d592 1
a592 1
	printf("seeking servers to start\n");
d620 1
a620 1
				printf("auto dropping %s:  out of time range\n",
d631 1
a631 1
			printf("auto adding %s\n", ihp->ht_name);
d701 1
a701 1
			printf("bad 'start' line\n");
d751 1
a751 1
		printf("string2int(%s) = %d?\n", str, ret );
d804 1
a804 1
		printf("-> "); (void)fflush(stdout);
d881 1
a881 1
		printf("already running, please wait or STOP\n");
d885 1
a885 1
		printf("need LOAD before GO\n");
d889 1
a889 1
		printf("No frames to do!\n");
d951 1
a951 1
		printf("...need to scan %s for non-black pixels (deferred)\n",
d975 1
a975 1
	printf("frame %d DONE: %g elapsed sec, %d rays/%g cpu sec\n",
d980 1
a980 1
	printf("  RTFM=%g rays/sec (%g rays/cpu sec)\n",
d1143 1
a1143 1
		printf("REMRT:  All work done!\n");
d1210 1
a1210 1
		printf("%s: *TARDY*\n", sp->sr_host->ht_name);
d1333 1
a1333 1
		printf("EOF on frame file.\n");
d1352 1
a1352 1
	errlog("ctl: unable to handle %s message: len %d",
d1374 1
a1374 1
		printf("ERROR %s: protocol version mis-match\n",
d1376 2
a1377 2
		printf(" local='%s'\n", PROTOCOL_VERSION );
		printf("remote='%s'\n", buf );
d1384 1
a1384 1
		printf("unexpected MSG_START from fd %d\n", pc->pkc_fd);
d1388 1
a1388 1
		printf("MSG_START in state %d?\n", sp->sr_state);
d1404 1
a1404 1
		printf("%s:%s", servers[pc->pkc_fd].sr_host->ht_name, buf );
d1420 1
a1420 1
		printf("ERROR %s: protocol version mis-match\n",
d1422 2
a1423 2
		printf("  local='%s'\n", PROTOCOL_VERSION );
		printf(" remote='%s'\n", buf );
d1427 1
a1427 1
			printf("NOTE %s:  VERSION message unexpected\n",
d1446 1
a1446 1
	printf("%s: cmd '%s'\n", sp->sr_host->ht_name, buf );
d1479 1
a1479 1
		fprintf(stderr,"struct_import error, %d, %d\n", i, info.li_len);
d1483 1
a1483 1
	printf("%s:fr=%d, %d..%d, ry=%d, cpu=%g, el=%g\n",
d1492 1
a1492 1
		printf("%s: no current frame, discarding\n");
d1498 1
a1498 1
		printf("frame number mismatch, claimed=%d, actual=%d\n",
d1505 1
a1505 1
		printf("pixel numbers out of range\n");
d1514 1
a1514 1
		fprintf(stderr,"short scanline, s/b=%d, was=%d\n",
d1533 1
a1533 1
		printf("write s/b %d, got %d\n", i, cnt );
d1595 1
a1595 1
			printf("splitting range into (%d %d) (%d %d)\n",
d1703 1
a1703 1
		printf("fb_open %d,%d failed\n", width, height);
d1722 1
a1722 1
		printf("Warning:  fb not big enough for %d pixels, display truncated\n", fp->fr_width );
d1758 1
a1758 1
		printf("send_start: ht_where=%d unimplemented\n", ihp->ht_where);
d1835 1
a1835 1
		printf("\t%d..%d frame %d\n",
d1865 1
a1865 1
			printf("unable to add CONVERT host %s until database given\n",
d1875 1
a1875 1
		printf("add_host:  ht_where=%d?\n", ihp->ht_where );
d1934 1
a1934 1
			printf("host_helper: cnt=%d, aborting\n", cnt);
d1943 1
a1943 1
			printf("%s\n", cmd); fflush(stdout);
d1978 1
a1978 1
			printf("%s\n", cmd); fflush(stdout);
d2056 1
a2056 1
		printf("build_start_cmd:  need file and at least one object\n");
d2163 1
a2163 1
		printf("%s: unknown host\n");
d2193 1
a2193 1
		printf("%s:  bad host\n", name);
d2208 1
a2208 1
		printf("Can't load while running!!\n");
d2214 1
a2214 1
		printf("Was loaded with %s, restarting all\n", file_fullname);
d2247 1
a2247 1
	printf("width=%d, height=%d, takes effect after next MAT\n",
d2256 1
a2256 1
	printf("hypersample=%d, takes effect after next MAT\n", hypersample);
d2264 1
a2264 1
	printf("Benchmark flag=%d, takes effect after next MAT\n", benchmark);
d2273 1
a2273 1
	printf("perspective angle=%g, takes effect after next MAT\n", rt_perspective);
d2288 1
a2288 1
	printf("read file done\n");
d2316 1
a2316 1
	printf("frames will be recorded in %s.###\n", outputfile);
d2358 1
a2358 1
		printf("already running, please wait\n");
d2362 1
a2362 1
		printf("need LOAD before MOVIE\n");
d2382 1
a2382 1
	printf("Movie ready\n");
d2418 1
a2418 1
		printf("restarting all\n");
d2435 1
a2435 1
	printf("no more scanlines being scheduled, done soon\n");
d2446 1
a2446 1
		printf("must STOP before RESET!\n");
d2490 1
a2490 1
	printf("Frames waiting:\n");
d2492 2
a2493 2
		printf("%5d\t", fr->fr_number);
		printf("width=%d, height=%d\n",
d2495 1
a2495 1
		if( fr->fr_filename )  printf(" %s\n", fr->fr_filename );
d2497 2
a2498 2
		printf("\tnrays = %d, cpu sec=%g\n", fr->fr_nrays, fr->fr_cpu);
		printf("       servinit: ");
d2500 2
a2501 2
			printf("%d ", fr->fr_servinit[i]);
		printf("\n");
d2503 1
a2503 1
		printf("cmd=%s\n", fr->fr_cmd.vls_str );
d2515 1
a2515 1
		printf("No model loaded yet\n");
d2517 1
a2517 1
		printf("\n%s %s %s\n",
d2522 1
a2522 1
		printf("Framebuffer is %s\n", fbp->if_name);
d2524 1
a2524 1
		printf("No framebuffer\n");
d2526 2
a2527 2
		printf("Output file: %s.###\n", outputfile );
	printf("Printing of remote messages is %s\n",
d2529 1
a2529 1
    	printf("Listening at %s, port %d\n", ourname, pkg_permport);
d2532 1
a2532 1
	printf("Servers:\n");
d2535 1
a2535 1
		printf("  %2d  %s ", sp->sr_index, sp->sr_host->ht_name );
d2538 1
a2538 1
			printf("New"); break;
d2540 1
a2540 1
			printf("Vers_OK"); break;
d2542 1
a2542 1
			printf("(Loading)"); break;
d2544 1
a2544 1
			printf("READY"); break;
d2546 1
a2546 1
			printf("--about to restart--"); break;
d2548 1
a2548 1
			printf("Unknown"); break;
d2551 1
a2551 1
			printf(" frame %d, assignments=%d\n",
d2555 1
a2555 1
			printf("\n");
d2558 1
a2558 1
		printf("\tlast:  elapsed=%g, cpu=%g, lump=%d\n",
d2562 1
a2562 1
		printf("\t avg:  elapsed=%gp/s, cpu=%g, weighted=%gp/s\n",
d2598 1
a2598 1
	printf("Printing of remote messages is %s\n",
d2632 1
a2632 1
		printf("%s %s\t\t%s\n",
d2648 1
a2648 1
		printf("Registered Host Table:\n");
d2650 1
a2650 1
			printf("  %s ", ihp->ht_name);
d2653 1
a2653 1
				printf("always ");
d2656 1
a2656 1
				printf("night ");
d2659 1
a2659 1
				printf("passive ");
d2662 1
a2662 1
				printf("?when? ");
d2667 1
a2667 1
				printf("cd %s\n", ihp->ht_path);
d2670 1
a2670 1
				printf("convert %s\n", ihp->ht_path);
d2673 1
a2673 1
				printf("?where?\n");
d2690 1
a2690 1
		printf("unknown 'when' string '%s'\n", argv[2]);
d2701 1
a2701 1
		printf("unknown 'where' string '%s'\n", argv[3] );
@


8.33
log
@#if 0'ed the per assignement printf().
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 8.32 89/02/14 06:35:40 mike Locked $ (BRL)";
d322 1
a322 1
		clients = (1<<0);
a338 1
		clients = (1<<0);	/* for testing only */
d1955 1
d1957 1
d1990 3
a1992 1
printf("%s\n", cmd); fflush(stdout);
d2622 16
d2749 2
@


8.32
log
@Minor changes for Cray2
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 8.31 89/02/14 05:00:50 mike Locked $ (BRL)";
d1496 6
a1501 4
printf("%s:fr=%d, %d..%d, ry=%d, cpu=%g, el=%g\n",
sp->sr_host->ht_name,
info.li_frame, info.li_startpix, info.li_endpix,
info.li_nrays, info.li_cpusec, sp->sr_l_elapsed );
d1956 1
a1956 1
printf("%s\n", cmd); fflush(stdout);
@


8.31
log
@Some common functionality moved into little subroutines.
Servers that do not respond to their assignments in a long time
are now automaticly declared tardy, and dropped.
Images are no longer buffered in memory -- they go directly to
disk now.  So far, this does not seem to be a performance problem.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 8.30 89/02/14 00:43:52 mike Locked $ (BRL)";
d46 1
a46 1
#ifndef CRAY
d1900 5
a1904 1
#else
d2754 10
@


8.30
log
@Changed to avoid symbol "sin", which conflicts with math library.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 8.29 89/02/13 07:46:30 mike Locked $ (BRL)";
d43 1
d152 1
a155 1
	char		*fr_picture;	/* ptr to picture buffer */
d297 1
d329 3
a331 1
			schedule();
d383 2
a384 1
			start_servers();
d386 3
a388 1
			schedule();
d486 1
d525 4
a528 1
	printf("%s: ACCEPT\n", sp->sr_host->ht_name );
d541 1
d547 1
d570 2
a575 2
		fr->fr_servinit[sp->sr_index] = 0;

a580 2
		printf("ToDo:\n");
		pr_list(&(fr->fr_todo));
d593 2
a594 1
start_servers()
a597 1
	struct timeval	now;
d603 1
a603 2
	(void)gettimeofday( &now, (struct timezone *)0 );
	if( tvdiff( &now, &last_server_check_time ) < SERVER_CHECK_INTERVAL )
d607 1
a607 1
	night = is_night( &now );
d651 1
a651 1
	last_server_check_time = now;		/* struct copy */
a871 2
	if( fr->fr_picture )  free(fr->fr_picture);
	fr->fr_picture = (char *)0;
d910 66
d998 54
a1051 13
	if( outputfile )  {
		sprintf(name, "%s.%d", outputfile, fr->fr_number);
		cnt = fr->fr_width*fr->fr_height*3;
		if( (fd = creat(name, 0444)) > 0 )  {
			printf("Writing..."); fflush(stdout);
			if( write( fd, fr->fr_picture, cnt ) != cnt ) {
				perror(name);
				exit(3);
			} else
				printf(" %s\n", name);
			close(fd);
		} else {
			perror(name);
d1054 23
a1076 3
	if( fr->fr_picture )  {
		free(fr->fr_picture);
		fr->fr_picture = (char *)0;
d1078 7
d1106 2
a1107 1
schedule()
a1137 1
	servers_going = 0;
d1143 6
a1148 7
		for( sp = &servers[0]; sp < &servers[MAXSERVERS]; sp++ )  {
			if( sp->sr_pc == PKC_NULL )  continue;
			if( sp->sr_curframe != fr )  continue;
			if( sp->sr_work.li_forw != &(sp->sr_work) )  {
				servers_going++;
				goto next_frame;
			}
a1149 9

		/* No servers are still working on this frame */
		fr2 = fr->fr_forw;
		DEQUEUE_FRAME(fr);
		frame_is_done( fr );
		FREE_FRAME(fr);
		fr = fr2;
		continue;

d1153 3
a1155 5
	if( running == 0 || FrameHead.fr_forw == &FrameHead )  {
		/* No more work to send out */
		if( servers_going > 0 )
			goto out;
		/* Nothing to do, and nobody still working */
d1172 1
a1172 1
				another_pass += task_server( fr, sp );
d1176 1
a1176 1
	/* No work remains to be assigned */
d1182 5
d1198 1
a1198 1
task_server( fr, sp )
d1201 1
d1211 18
a1228 1
#define N_SERVER_ASSIGNMENTS	3
d1236 1
a1236 1
		return(1);
d1239 4
a1242 1
	/* Provide info about this frame, if this is first assignment in it */
d1249 18
a1266 2
#define MAX_LUMP		(8*1024)
#define ASSIGNMENT_TIME		5	/* desired seconds between results */
a1286 3
	if( fr->fr_start.tv_sec == 0 )  {
		(void)gettimeofday( &fr->fr_start, (struct timezone *)0 );
	}
d1403 2
a1406 1
	printf("%s READY FOR WORK\n", sp->sr_host->ht_name);
d1476 3
a1478 4
	int line;
	register int i;
	register struct servers *sp;
	register struct frame *fr;
d1482 2
a1487 1
	fr = sp->sr_curframe;
d1493 2
a1494 2
		fprintf(stderr,"struct_inport error, %d, %d\n", i, info.li_len);
		return;
d1496 1
a1496 1
fprintf(stderr,"%s:fr=%d, %d..%d, ry=%d, cpu=%g, el=%g\n",
d1501 7
a1511 1
bad:
d1513 1
a1513 2
		if(buf) (void)free(buf);
		return;
d1518 2
a1519 1
		goto bad;
d1522 1
a1522 13
	/* Stash pixels in memory in bottom-to-top .pix order */
	if( fr->fr_picture == (char *)0 )  {
		i = fr->fr_width*fr->fr_height*3+3;
		printf("allocating %d bytes for image\n", i);
		fr->fr_picture = malloc( i );
		if( fr->fr_picture == (char *)0 )  {
			fprintf(stdout, "ph_pixels: malloc(%d) error\n",i);
			fprintf(stderr, "ph_pixels: malloc(%d) error\n",i);
			abort();
			exit(19);
		}
		bzero( fr->fr_picture, i );
	}
d1529 2
a1530 1
		/* Should re-queue missing pixels, if this is a problem */
d1532 17
a1548 1
	bcopy( buf+info.li_len, fr->fr_picture + info.li_startpix*3, i );
a1554 1
	if(buf) (void)free(buf);
d1573 3
d1668 39
d1763 1
a1763 1
		sprintf( cmd, "%s %s", file_fullname, object_list );
a2447 1
	register struct list *lp;
d2453 4
a2456 12
	for( fr = FrameHead.fr_forw; fr != &FrameHead; fr=fr->fr_forw )  {
		if( fr->fr_picture )  free(fr->fr_picture);
		fr->fr_picture = (char *)0;
		/* Need to remove any pending work,
		 * work already assigned will dribble in.
		 */
		while( (lp = fr->fr_todo.li_forw) != &(fr->fr_todo) )  {
			DEQUEUE_LIST( lp );
			FREE_LIST(lp);
		}
		/* We will leave cleanups to schedule() */
	}
a2463 1
	register int	i;
d2472 1
a2472 1

d2475 1
a2475 7
	/* Draw the accumulated image */
	if( fr->fr_picture == (char *)0 )  return;
	size_display(fr);
	if( fbp == FBIO_NULL ) return;

	/* Trim to what can be drawn */
	write_fb( fr->fr_picture, fr, 0, fr->fr_height*fr->fr_width );
d2499 2
a2500 2
		if( fr->fr_picture )  printf(" (Pic)");
		printf("\n");
@


8.29
log
@Got HT_CONVERT machines to work.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 8.28 89/02/13 06:21:40 mike Locked $ (BRL)";
d1958 1
a1958 1
	struct sockaddr_in	sin;
d1964 1
a1964 1
		sin.sin_family = AF_INET;
d1966 1
a1966 1
		sin.sin_addr = inet_addr(name);
d1968 1
a1968 1
		sin.sin_addr.s_addr = inet_addr(name);
d1970 1
a1970 1
		return( host_lookup_by_addr( &sin, enter ) );
@


8.28
log
@Added CMD and VERSION messages, expanded state machine slightly,
made scheduling part of main loop (eliminating potential recursion).
Improved error checking and robustness in selected parts.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 8.27 89/02/11 04:50:04 mike Locked $ (BRL)";
a234 1
char	start_cmd[512];		/* contains file name & objects */
d236 2
d590 2
d890 1
a890 1
	if( start_cmd[0] == '\0' )  {
d979 1
a979 1
	if( start_cmd[0] == '\0' )  goto out;
d1326 2
a1327 1
fprintf(stderr,"PIXELS fr=%d, pix=%d..%d, rays=%d, cpu=%g, el=%g\n",
d1531 1
d1534 1
a1534 1
	if( start_cmd[0] == '\0' || sp->sr_state != SRST_VERSOK )  return;
d1541 1
d1545 1
d1553 1
a1553 1
	if( pkg_send( MSG_START, start_cmd, strlen(start_cmd)+1, sp->sr_pc ) < 0 )
a1596 1
	printf("sent matrix to %s\n", sp->sr_host->ht_name);
d1641 1
a1641 1
 *	HT_CONVERT	host, port, rem_dir, db
d1654 5
d1660 3
a1662 2
			"%s %d %s %s\n",
			ihp->ht_name, pkg_permport, ihp->ht_path, file_basename );
d1701 2
a1702 1
	char	db[128];
d1714 2
a1715 1
		db[0] = '\0';
d1717 3
a1719 3
		cnt = sscanf( line, "%s %d %s %s",
			host, &port, rem_dir, db );
		if( cnt != 3 && cnt != 4 )  {
d1756 2
a1757 2
			 "g2asc<%s|%s %s -n \"cd %s; asc2g>%s; rtsrv %s %d\"",
				db,
d1759 1
a1759 1
				rem_dir, db,
d1839 1
a1839 1
		start_cmd[0] = '\0';
d1843 2
d1852 4
a1855 4
	/* Build new start_cmd[] string */
	cp = start_cmd;
	for( i=startc; i < argc; i++ )  {
		if( i > startc )  *cp++ = ' ';
d1907 2
a1908 2
	ihp->ht_where = HT_CD;
	ihp->ht_path = ".";
a1959 1
	unsigned long		addr_tmp;
d1966 1
a1966 3
		addr_tmp = sin.sin_addr = inet_addr(name);
		addr = gethostbyaddr( &addr_tmp, sizeof(struct in_addr),
			sin.sin_family );
a1968 2
		addr = gethostbyaddr( &sin.sin_addr, sizeof(struct in_addr),
			sin.sin_family );
d1970 1
d1995 2
a1996 2
	if(start_cmd[0] != '\0' )  {
		printf("Was loaded with %s, restarting all\n", start_cmd);
d2143 1
a2143 1
	if( start_cmd[0] == '\0' )  {
d2312 1
a2312 1
	if( start_cmd[0] == '\0' )
d2315 1
a2315 1
		printf("\n%s %s\n",
d2317 1
a2317 1
			start_cmd );
@


8.27
log
@Added some suspicion to replies from servers.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 8.26 89/02/11 03:30:21 mike Locked $ (BRL)";
d34 7
d125 2
d128 9
a136 7
	{ MSG_START, ph_start, "Startup ACK" },
	{ MSG_MATRIX, ph_default, "Set Matrix" },
	{ MSG_LINES, ph_default, "Compute lines" },
	{ MSG_END, ph_default, "End" },
	{ MSG_PIXELS, ph_pixels, "Pixels" },
	{ MSG_PRINT, ph_print, "Log Message" },
	{ 0, 0, (char *)0 }
d174 7
a180 5
	int		sr_started;
#define SRST_NEW	1		/* connected, no model loaded yet */
#define SRST_LOADING	2		/* loading, awaiting ready response */
#define SRST_READY	3		/* loaded, ready */
#define SRST_RESTART	4		/* about to restart */
d207 1
a207 1
	char		*ht_path;
d215 1
d235 2
a236 1
char	start_cmd[256];		/* contains file name & objects */
d239 1
a239 1
char	ourname[64];
d249 1
a249 1
 *  Log an error.  We supply the newline, and route to user.
a255 2
	char buf[256];		/* a generous output line */

d326 1
d380 1
d459 1
a459 1
			dropclient(pc);
d510 1
a510 1
	sp->sr_started = SRST_NEW;
a516 5

	if( start_cmd[0] != '\0' )  {
		send_start(sp);
		send_loglvl(sp);
	}
d520 1
a520 1
 *			D R O P C L I E N T
d522 2
a523 2
dropclient(pc)
register struct pkg_conn *pc;
d525 3
a527 3
	register struct list *lhp, *lp;
	register struct servers *sp;
	register struct frame *fr;
d530 11
a541 2
	sp = &servers[fd];
	printf("REMRT closing fd %d %s\n", fd, sp->sr_host->ht_name);
d543 1
a543 1
		printf("That's unreasonable, forget it!\n");
a545 1
	pkg_close(pc);
d547 1
d549 3
d553 4
a556 1
	/* Need to remove any work in progress, and re-schedule */
a569 1
	if(running) schedule();
d586 2
d594 1
d597 2
a598 1
		/* Skip hosts which are not eligible */
d603 5
a607 3
			if( is_night( &now ) )  break;
			printf("bypassing %s:  not night\n", ihp->ht_name);
			continue;
d613 1
d616 12
a627 1
			if( sp->sr_host == ihp )  goto next_host;
a628 2
		/* This host is not busy, and is eligible */
		add_host( ihp->ht_name );
d630 6
d822 1
a822 1
				dropclient(sp->sr_pc);
a895 1
	schedule();
d945 3
a976 1
	servers_going = 0;
d978 13
d992 1
d1029 1
a1029 1
	/* Keep assigning work until all servers are sated */
d1067 1
a1067 5
	if( sp->sr_started == SRST_NEW )  {
		/*  advance this server to state 1 (loading) */
		send_start(sp);
		return(0);
	}
d1069 1
a1069 1
	if( sp->sr_started != SRST_READY )
d1220 1
a1220 1
		dropclient( pc );
d1229 2
a1230 2
	if( sp->sr_started != SRST_LOADING )  {
		printf("MSG_START in state %d?\n", sp->sr_started);
d1232 1
a1232 1
	sp->sr_started = SRST_READY;
a1233 1
	if(running) schedule();
d1250 44
d1332 1
a1332 1
		dropclient( pc );
a1388 4

	/* May be a recursive invocation;  but this is not a problem */
	if( running )
		schedule();
d1528 2
a1529 1
	if( start_cmd[0] == '\0' || sp->sr_started != SRST_NEW )  return;
d1535 1
a1535 1
			dropclient(sp->sr_pc);
d1538 2
d1541 2
a1542 2
		printf("conversion of database is unimplemented\n");
		dropclient(sp->sr_pc);
d1547 2
a1548 2
		dropclient(sp->sr_pc);
	sp->sr_started = SRST_LOADING;
d1557 2
d1560 2
a1561 2
		dropclient(sp->sr_pc);
	sp->sr_started = SRST_RESTART;
d1570 2
d1573 1
a1573 1
		dropclient(sp->sr_pc);
d1585 1
a1585 1

d1589 1
a1589 1
		dropclient(sp->sr_pc);
d1600 3
d1605 1
a1605 1
		dropclient(sp->sr_pc);
d1630 9
a1638 2
add_host( host )
char	*host;
d1641 15
a1655 1
	fprintf( helper_fp, "%s %d ", host, pkg_permport );
d1664 21
a1684 1
start_helper()
d1686 8
a1693 1
	int	fds[2];
a1694 1
	int	i;
d1696 4
a1699 4
	if( pipe(fds) < 0 )  {
		perror("pipe");
		exit(1);
	}
d1701 7
a1707 11
	pid = fork();
	if( pid == 0 )  {
		/* Child process */
		FILE	*fp;
		char	host[128];
		int	port;

		(void)close(fds[1]);
		if( (fp = fdopen( fds[0], "r" )) == NULL )  {
			perror("fdopen");
			exit(3);
a1708 2
		while( !feof(fp) )  {
			char cmd[128];
d1710 1
a1710 3
			if( fscanf( fp, "%s %d", host, &port ) != 2 )
				break;
			/* */
d1712 6
a1717 3
				"rtsrv %s %d",
				ourname, port );
			if( fork() == 0 )  {
d1724 1
a1724 5
#ifdef sgi
						"/usr/bsd/rsh",
#else
						"/usr/ucb/rsh",
#endif
d1735 2
d1740 8
d1749 19
d1769 28
d1811 3
d1823 13
d1847 3
d1867 17
d1886 2
a1887 4
	/* Duplicate those fields of interst -- 
	 * gethostbyxxx() routines keep stuff in a static buffer
	 */
	ihp->ht_name = rt_strdup( addr->h_name );
d1894 1
d1907 1
d1918 12
a1929 8
	if( addr == NULL )  {
		/* Potentially, print up a hostent structure here */
		addr_tmp = ntohl(addr_tmp);
		printf("%d.%d.%d.%d: unknown host\n",
			(addr_tmp>>24) & 0xff,
			(addr_tmp>>16) & 0xff,
			(addr_tmp>> 8) & 0xff,
			(addr_tmp    ) & 0xff );
d1932 3
a1934 1
	return( host_lookup_by_hostent( addr, enter ) );
a1991 7

	/* Start any idle servers */
	for( sp = &servers[0]; sp < &servers[MAXSERVERS]; sp++ )  {
		if( sp->sr_pc == PKC_NULL )  continue;
		if( sp->sr_started != SRST_NEW )  continue;
		send_start(sp);
	}
d2004 2
a2005 1
		(void)pkg_send( MSG_OPTIONS, argv[1], len, sp->sr_pc);
d2160 1
d2163 3
a2165 1
		add_host( argv[i] );
d2177 1
a2177 1
	dropclient(sp->sr_pc);
d2322 1
a2322 1
		switch( sp->sr_started )  {
d2324 3
a2326 1
			printf("Idle"); break;
d2330 1
a2330 1
			printf("Ready"); break;
d2420 1
a2420 1
			printf("%s ", ihp->ht_name);
@


8.26
log
@Fixed for running on the Cray
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 8.25 89/02/10 06:13:19 mike Exp $ (BRL)";
d923 1
a923 1
		printf("note: recurion prevented in schedule()\n");
d1226 15
@


8.25
log
@Only ignore sigint on interactive sessions.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 8.24 89/02/10 05:47:46 mike Locked $ (BRL)";
a35 1
#include <sys/time.h>		/* for struct timeval */
d38 3
d204 2
a205 2
int		width = 64;
int		height = 64;
d212 2
a213 2
char		*outputfile;		/* output file name */
char		*framebuffer;
d215 1
a215 1
int		desiredframe;
d217 1
a217 1
struct rt_g	rt_g;
d285 1
d1659 2
a1662 1
#endif
d1665 1
d1686 1
d1693 1
a1693 1
		sin.sin_addr = inet_addr(name);
@


8.24
log
@Belatedly took care of perspective becomming rt_perspective
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 8.23 89/02/10 05:33:38 mike Locked $ (BRL)";
a298 1
	(void)signal( SIGINT, SIG_IGN );
d301 1
@


8.23
log
@Added "CD" host initialization support
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 8.22 89/02/10 05:12:22 mike Locked $ (BRL)";
d206 1
a206 1
double		perspective = 0;
d807 1
a807 1
		hypersample, perspective );
d1783 3
a1785 3
	perspective = atof( argv[1] );
	if( perspective < 0.0 )  perspective = 0.0;
	printf("perspective angle=%g, takes effect after next MAT\n", perspective);
@


8.22
log
@Improved statistics
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 8.21 89/02/10 04:33:32 mike Locked $ (BRL)";
d1412 2
d1415 13
@


8.21
log
@the chore of sending a task to a server has been moved into a subroutine.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 8.20 89/02/10 03:57:46 mike Locked $ (BRL)";
d171 4
a174 4
	double		sr_l_el_rate;	/* last: elapsed_sec/pixel */
	double		sr_w_elapsed;	/* weighted avg: elapsed_sec/pixel */
	double		sr_s_elapsed;	/* sum of elapsed_sec/pixel */
	double		sr_sq_elapsed;	/* sum of elapsed_sec/pixel squared */
d1032 1
a1032 1
	sp->sr_lump = ASSIGNMENT_TIME / sp->sr_w_elapsed;
d1212 2
a1213 1
	sp->sr_l_elapsed = tvdiff( &tvnow, &sp->sr_sendtime );
d1257 4
a1260 2
	sp->sr_l_el_rate = sp->sr_l_elapsed / npix;
	sp->sr_w_elapsed = 0.9 * sp->sr_w_elapsed + 0.1 * sp->sr_l_el_rate;
a1413 1
	printf("Sending start to %s\n", sp->sr_host->ht_name);
d2058 5
a2062 3
		if( sp->sr_curframe != FRAME_NULL )
			printf(" frame %d\n", sp->sr_curframe->fr_number);
		else
d2064 1
d2066 1
a2066 1
		printf("\tlast:  elapsed=%g, cpu=%g\n",
d2068 4
a2071 3
			sp->sr_l_cpu );
		printf("\t avg:  elapsed=%gp/s, cpu=%g, weighted=%g, clump=%d\n",
			1.0/(sp->sr_s_elapsed/num),
d2073 1
a2073 2
			sp->sr_w_elapsed,
			sp->sr_lump );
d2075 2
d2078 1
@


8.20
log
@Now dispatches assignments > one scanline in width.
Minor twiddling on statistics
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 8.19 89/02/10 03:07:54 mike Locked $ (BRL)";
a911 1
	register struct list *lp;
a913 1
	int a,b;
a915 1
	int		len;
d931 1
a931 1
		if( (lp = fr->fr_todo.li_forw) != &(fr->fr_todo) )
d965 1
a965 1
	/* Find first piece of work */
d967 4
a970 2
		if( fr->fr_todo.li_forw == &(fr->fr_todo) )
			continue;	/* none waiting here */
d972 4
a975 11
		/*
		 *  Look for a server with fewer than N_SERVER_ASSIGNMENTS
		 *  outstanding assignments.   Dispatch 1 unit of work to it.
		 */
		another_pass = 0;
		for( sp = &servers[0]; sp < &servers[MAXSERVERS]; sp++ )  {
			if( sp->sr_pc == PKC_NULL )  continue;
			if( sp->sr_started == SRST_NEW )  {
				/*  advance to state 1 (loading) */
				send_start(sp);
				continue;
d977 35
a1011 3
			if( sp->sr_started != SRST_READY )
				continue;	/* not running yet */
			len = server_q_len( sp );
d1013 2
a1014 2
			if( len >= N_SERVER_ASSIGNMENTS )
				continue;	/* plenty busy */
d1016 6
a1021 3
			/* See if server will need more than 1 assignment */
			if( len < N_SERVER_ASSIGNMENTS-1 )
				another_pass = 1;
d1023 6
a1028 5
			if( fr->fr_servinit[sp->sr_index] == 0 )  {
				send_matrix( sp, fr );
				fr->fr_servinit[sp->sr_index] = 1;
				sp->sr_curframe = fr;
			}
d1032 3
a1034 3
			sp->sr_lump = ASSIGNMENT_TIME / sp->sr_w_elapsed;
			if( sp->sr_lump < 32 )  sp->sr_lump = 32;
			if( sp->sr_lump > MAX_LUMP )  sp->sr_lump = MAX_LUMP;
d1036 9
a1044 7
			if( (lp = fr->fr_todo.li_forw) == &(fr->fr_todo) )  {
				/*  No more work to assign in this frame,
				 *  on next pass, will advance to next frame.
				 */
				another_pass = 1;
				break;
			}
d1046 10
a1055 9
			a = lp->li_start;
			b = a+sp->sr_lump-1;	/* work increment */
			if( b >= lp->li_stop )  {
				b = lp->li_stop;
				DEQUEUE_LIST( lp );
				FREE_LIST( lp );
				lp = LIST_NULL;
			} else
				lp->li_start = b+1;
d1057 4
a1060 23
			printf("fr%d %d..%d -> %s\n", fr->fr_number,
				a, b, sp->sr_host->ht_name);

			/* Record newly allocated pixel range */
			GET_LIST(lp);
			lp->li_frame = fr;
			lp->li_start = a;
			lp->li_stop = b;
			APPEND_LIST( lp, &(sp->sr_work) );
			if( fr->fr_start.tv_sec == 0 )  {
				(void)gettimeofday( &fr->fr_start, (struct timezone *)0 );
			}
			send_do_lines( sp, a, b, fr->fr_number );
		}
		if( another_pass == 0 )  {
			/* all servers have full assignments */
			goto out;
		}
	}
	/* No work remains to be assigned */
out:
	scheduler_going = 0;
	return;
d1212 1
d1219 1
a1219 1
fprintf(stderr,"PIXELS fr=%d, pix=%d..%d, rays=%d, cpu=%g\n",
d1221 1
a1221 1
info.li_nrays, info.li_cpusec );
a1255 1
	sp->sr_l_elapsed = tvdiff( &tvnow, &sp->sr_sendtime );
@


8.19
log
@scheduler() now hands out multiple assignments, in a round-robbin
manner, to provide pipelining of request/compute/respose.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 8.18 89/01/27 00:53:58 mike Locked $ (BRL)";
d170 6
a175 5
	double		sr_l_elapsed;	/* last: elapsed sec/pixel */
	double		sr_w_elapsed;	/* weighted avg: elapsed sec/pixel */
	double		sr_s_elapsed;	/* sum of elapsed sec/pixel */
	double		sr_sq_elapsed;	/* sum of elapsed sec/pixel squared */
	double		sr_l_cpu;	/* cpu sec for last scanline */
a216 2
extern double	atof();

d1002 1
d1006 1
a1006 1
			if( sp->sr_lump > fr->fr_width )  sp->sr_lump = fr->fr_width;
d1243 3
a1245 2
	sp->sr_l_elapsed = tvdiff( &tvnow, &sp->sr_sendtime ) / npix;
	sp->sr_w_elapsed = 0.9 * sp->sr_w_elapsed + 0.1 * sp->sr_l_elapsed;
d1249 2
a1250 2
	sp->sr_s_elapsed += sp->sr_l_elapsed;
	sp->sr_sq_elapsed += sp->sr_l_elapsed * sp->sr_l_elapsed;
d2052 2
a2053 2
		printf("\t avg:  elapsed=%g, cpu=%g, weighted=%g, clump=%d\n",
			sp->sr_s_elapsed/num,
@


8.18
log
@Changed to permit assignment of pixel clumps,
rather than being forced to assign by scanline.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 8.17 89/01/26 22:52:04 mike Locked $ (BRL)";
d898 11
a908 1
 *  If there is work to do, and a free server, send work
d917 1
a917 1
	int going;			/* number of servers still going */
d919 3
d923 5
a927 2
	if( start_cmd[0] == '\0' )  return;
	going = 0;
d929 3
d936 1
a936 1
			goto next_frame;	/* still work to be done */
d942 1
a942 1
				going++;
d947 1
a947 2
		/* This server has just completed a frame */
		sp->sr_curframe = FRAME_NULL;
d960 2
a961 2
		if( going > 0 )
			return;
d966 1
a966 1
		return;
a969 1
	if( !running )  return;
d971 1
a971 2
top:
		if( (lp = fr->fr_todo.li_forw) == &(fr->fr_todo) )
d975 2
a976 2
		 *  Look for a server with fewer than XXX outstanding
		 *  assignments to dispatch work to
d978 1
d988 4
a991 2
			if( sp->sr_work.li_forw != &(sp->sr_work) )
				continue;	/* busy */
d993 4
d1003 1
a1003 1
#define ASSIGNMENT_TIME		5	/* seconds */
d1008 8
a1038 1
			goto top;
d1040 4
a1043 1
		if( sp >= &servers[MAXSERVERS] )  return;	/* no free servers */
d1045 4
d1052 18
d1255 3
a1257 1
	if( running && sp->sr_work.li_forw == &(sp->sr_work) )
d1519 1
a1519 1
				"cd cad/remrt; rtsrv %s %d",
@


8.17
log
@Additional exec
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 8.16 89/01/26 21:55:31 mike Locked $ (BRL)";
d170 4
a173 4
	double		sr_l_elapsed;	/* elapsed sec for last scanline */
	double		sr_w_elapsed;	/* weighted average of elapsed times */
	double		sr_s_elapsed;	/* sum of all elapsed times */
	double		sr_sq_elapsed;	/* sum of all elapsed times squared */
d176 2
a177 1
	int		sr_nlines;	/* number of lines summed over */
d495 1
a495 1
	sp->sr_lump = 3;
d825 1
a825 1
	lp->li_stop = fr->fr_height-1;	/* last scanline # */
d980 5
d998 1
a998 1
			/* Record newly allocated scanlines */
d1007 1
a1007 1
			send_do_lines( sp, a, b );
d1139 1
d1151 3
a1153 1
fprintf(stderr,"PIXELS y=%d, rays=%d, cpu=%g\n", info.li_y, info.li_nrays, info.li_cpusec );
d1168 2
a1169 1
	i = fr->fr_width*3;
d1174 1
d1176 1
a1176 1
	bcopy( buf+info.li_len, fr->fr_picture + info.li_y*fr->fr_width*3, i );
d1181 1
a1181 2
			info.li_y*fr->fr_width + 0,
			info.li_y*fr->fr_width + i/3 );
d1188 1
a1188 1
	sp->sr_l_elapsed = tvdiff( &tvnow, &sp->sr_sendtime );
d1195 2
a1196 1
	sp->sr_nlines++;
d1199 1
a1199 1
	list_remove( &(sp->sr_work), info.li_y );
d1207 1
a1207 1
 * Given pointer to head of list of ranges, remove the item that's done
d1209 1
a1209 1
list_remove( lhp, line )
d1213 1
d1215 2
a1216 2
		if( lp->li_start == line )  {
			if( lp->li_stop == line )  {
d1220 1
a1220 1
			lp->li_start++;
d1223 2
a1224 2
		if( lp->li_stop == line )  {
			lp->li_stop--;
d1227 2
a1228 2
		if( line > lp->li_stop )  continue;
		if( line < lp->li_start ) continue;
d1230 1
a1230 1
		/* (start..line-1) and (line+1..stop) */
d1233 3
a1235 1
			printf("splitting range into %d %d %d\n", lp->li_start, line, lp->li_stop);
d1237 1
a1237 1
			lp2->li_start = line+1;
d1239 1
a1239 1
			lp->li_stop = line-1;
d1388 1
a1388 1
send_do_lines( sp, start, stop )
d1392 1
a1392 1
	sprintf( obuf, "%d %d", start, stop );
d1990 1
a1990 1
		num = sp->sr_nlines<=0 ? 1 : sp->sr_nlines;
@


8.16
log
@Centralized handling of .remrtrc files
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 8.14 89/01/26 09:08:41 mike Locked $ (BRL)";
d1464 5
a1468 1
					perror("execl");
@


8.15
log
@Centralized all writing to the framebuffer & clipping
into a single routine.
@
text
@d305 3
a314 2
		FILE	*fp;

d333 1
a333 3
		if( (fp = fopen(".remrtrc", "r")) == NULL )  {
			char	*home;
			char	path[128];
a334 10
			if( (home = getenv("HOME")) == NULL )
				home = "/usr/brlcad/etc";
			sprintf( path, "%s/.remrtrc", home );
			fp = fopen( path, "r" );
		}
		if( fp != NULL )  {
			source(fp);
			fclose(fp);
		}

d367 35
@


8.14
log
@Added checking for protocol version
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 8.13 89/01/26 08:41:36 mike Locked $ (BRL)";
d412 1
a412 1
		if( i == fileno(stdin) )  continue;
d1145 3
a1147 9
		int maxx;
		maxx = i/3;
		if( maxx > fb_getwidth(fbp) )  {
			maxx = fb_getwidth(fbp);
			fprintf(stderr,"clipping fb scanline to %d\n", maxx);
		}
		size_display(fr);
		fb_write( fbp, 0, info.li_y%fb_getheight(fbp),
			buf+info.li_len, maxx );
d1209 47
a1849 1
	int		maxx;
d1867 1
a1867 8
	maxx = fr->fr_width;
	if( maxx > fb_getwidth(fbp) )
		maxx = fb_getwidth(fbp);
	for( i=0; i<fr->fr_height; i++ )  {
		fb_write( fbp, 0, i%fb_getheight(fbp),
			fr->fr_picture + i*fr->fr_width*3,
			maxx );
	}
d1952 1
a1952 1
		printf("\t avg:  elapsed=%g, weighted=%g, cpu=%g clump=%d\n",
d1954 1
a1955 1
			sp->sr_s_cpu/num,
@


8.13
log
@Added ability to read new-style RT scripts.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 8.12 89/01/26 05:57:14 mike Locked $ (BRL)";
a46 1
#include "./rtsrv.h"
d1058 9
@


8.12
log
@Can now automaticly start servers from ihost table
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 8.11 89/01/26 04:52:57 mike Locked $ (BRL)";
d67 9
d77 1
a77 1
struct vls	*vp;
d80 1
a80 1
	int	len;
d95 9
d212 1
d326 4
d349 3
a351 1
		if( framebuffer )  init_fb(framebuffer);
d364 3
a366 1
			/* if -M, start reading RT script */
d368 1
d410 1
a410 1
	for( i=3; i<NFD; i++ )  {
d412 3
d419 1
d422 4
a425 1
	if( waittime>0 && (ibits & (1<<(fileno(stdin)))) )  {
d589 67
@


8.11
log
@Added internal host table
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 8.10 89/01/25 05:41:57 mike Locked $ (BRL)";
d32 1
d63 1
a63 1
	int	vls_cur;
d78 1
a78 1
	if( vp->vls_cur + len > vp->vls_max )  {
d165 1
a165 1
	struct hostent	ht_host;	/* All details of this host */
d279 1
d281 1
d286 7
a341 2
		/* Attempt to start some servers */

d343 6
a349 8

	while(clients)  {
		(void)signal( SIGINT, SIG_IGN );
		check_input( 30 );	/* delay 30 secs */
	}
	/* Might want to see if any work remains, and if so,
	 * record it somewhere */
	printf("REMRT out of clients\n");
d440 1
a440 1
	printf("%s: ACCEPT\n", sp->sr_host->ht_host.h_name );
d461 1
a461 1
	printf("REMRT closing fd %d %s\n", fd, sp->sr_host->ht_host.h_name);
d488 69
a642 1
		close( tcp_listen_fd ); tcp_listen_fd = -1;
d865 1
a865 1
				a, b, sp->sr_host->ht_host.h_name);
d966 1
a966 1
	printf("%s READY FOR WORK\n", sp->sr_host->ht_host.h_name);
d979 1
a979 1
		printf("%s:%s", servers[pc->pkc_fd].sr_host->ht_host.h_name, buf );
d1152 1
a1152 1
	printf("Sending model info to %s\n", sp->sr_host->ht_host.h_name);
d1175 1
a1175 1
	if( pkg_send( MSG_LOGLVL, print_on?"1":"0", 1, sp->sr_pc ) < 0 )
d1189 3
a1191 1
	if( pkg_send( MSG_MATRIX, fr->fr_cmd.vls_str, fr->fr_cmd.vls_cur, sp->sr_pc ) < 0 )
d1193 1
a1193 1
	printf("sent matrix to %s\n", sp->sr_host->ht_host.h_name);
d1230 13
d1341 1
a1341 1
		if( strcmp( ihp->ht_host.h_name, addr->h_name ) != 0 )
a1349 1
	ihp->ht_host = *addr;		/* struct copy */
d1351 5
d1624 1
a1624 4
		fprintf( helper_fp, "%s %d ",
			argv[i], pkg_permport );
		fflush( helper_fp );
		check_input(1);		/* get connections */
d1788 1
a1788 1
		printf("  %2d  %s ", sp->sr_index, sp->sr_host->ht_host.h_name );
d1879 1
a1879 1
			printf("%s ", ihp->ht_host.h_name);
@


8.10
log
@Added options to MATRIX message, all in one.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 8.9 89/01/25 04:08:12 mike Locked $ (BRL)";
d51 5
a122 3
	int		fr_hyper;	/* hypersampling */
	int		fr_benchmark;	/* Benchmark flag */
	double		fr_perspective;	/* perspective angle */
d131 1
a131 1
	struct vls	fr_cmd;		/* RT command string */
d141 1
a148 2
	long		sr_addr;	/* NET order inet addr */
	char		sr_name[64];	/* host name */
d162 19
d190 3
d203 1
a203 2
char	ourname[32];
char	out_file[256];		/* output file name */
d284 2
d288 1
a294 2
		/* Collect up results of arg parsing */
		/* Most importantly, -o, -F */
d297 2
d300 3
d304 15
d320 8
a327 1
			/* if not -M, start off single az/el frame */
d331 4
d396 4
a399 1
	int on = 1, options = 0, fromlen;
a400 1
	register struct hostent *hp;
a401 1
	unsigned long addr_tmp;
d414 8
d432 1
a432 14
#ifdef CRAY
	sp->sr_addr = from.sin_addr;
	hp = gethostbyaddr(&(sp->sr_addr), sizeof (struct in_addr),
		from.sin_family);
#else
	sp->sr_addr = from.sin_addr.s_addr;
	hp = gethostbyaddr(&from.sin_addr, sizeof (struct in_addr),
		from.sin_family);
#endif
	if (hp == 0) {
		sprintf( sp->sr_name, "x%x", ntohl(sp->sr_addr) );
	} else {
		strncpy( sp->sr_name, hp->h_name, sizeof(sp->sr_name) );
	}
d434 1
a434 1
	printf("%s: ACCEPT\n", sp->sr_name );
d455 1
a455 1
	printf("REMRT closing fd %d %s\n", fd, sp->sr_name);
a507 23
 *			H O S T 2 A D D R
 */
long
host2addr(str)
char *str;
{
	if( str[0] == '0' || atoi(str) > 0 )  {
		/* Numeric */
		register int i;
		if( (i=inet_addr(str)) != 0 )
			return(i);
		return(string2int(str));
	} else {
		register struct hostent *addr;
		long i;
		if ((addr=gethostbyname(str)) == NULL)
			return(0);
		bcopy(addr->h_addr,(char*)&i, sizeof(long));
		return(i);
	}
}

/*
a513 1
	register long i;
d515 1
d518 1
d523 4
a526 1
	i = host2addr(str);
d529 1
a529 1
		if( sp->sr_addr == i )  return(sp);
d598 1
d603 8
a610 3
	fr->fr_perspective = perspective;
	fr->fr_hyper = hypersample;
	fr->fr_benchmark = benchmark;
d674 2
a675 2
	if( out_file[0] != '\0' )  {
		sprintf(name, "%s.%d", out_file, fr->fr_number);
d791 1
a791 1
				a, b, sp->sr_name);
d892 1
a892 1
	printf("%s READY FOR WORK\n", sp->sr_name);
d905 1
a905 1
		printf("%s:%s", servers[pc->pkc_fd].sr_name, buf );
a1075 1
	printf("Sending model info to %s\n", sp->sr_name);
d1077 2
a1113 1
	char buf[BUFSIZ];
a1114 6
	sprintf(buf, "opt %s -w%d -n%d -H%d -p%f;",
		fr->fr_benchmark ? "-B" : "",
		fr->fr_width, fr->fr_height,
		fr->fr_hyper, fr->fr_perspective );
	vls_cat( &fr->fr_cmd, buf );

d1117 1
a1117 1
	printf("sent matrix to %s\n", sp->sr_name);
d1184 3
a1186 3
				"rsh %s -n 'cd cad/remrt; rtsrv %s %d'",
				host, ourname, port );
			if( vfork() == 0 )  {
d1192 9
a1200 1
					system( cmd );
d1223 109
a1338 3
	register char	*cp;
	register int	i;
	int		len;
d1354 1
a1354 9
	/* Build new start_cmd[] string */
	cp = start_cmd;
	for( i=1; i < argc; i++ )  {
		if( i > 1 )  *cp++ = ' ';
		len = strlen( argv[i] );
		bcopy( argv[i], cp, len );
		cp += len;
	}
	*cp++ = '\0';
d1425 8
a1438 2
	fclose(fp);
	printf("read file done\n");
d1454 2
a1455 2
	strncpy( out_file, argv[1], sizeof(out_file) );
	printf("frames will be recorded in %s.###\n", out_file);
d1467 1
a1481 1
	prep_frame(fr);
d1515 1
a1517 1
		prep_frame(fr);
d1656 2
a1657 4
		printf("width=%d, height=%d, perspective angle=%f\n",
			fr->fr_width, fr->fr_height, fr->fr_perspective );
		printf("\thypersample = %d, ", fr->fr_hyper);
		printf("benchmark = %d, ", fr->fr_benchmark);
d1688 2
a1689 2
	if( out_file[0] != '\0' )
		printf("Output file: %s.###\n", out_file );
d1698 1
a1698 1
		printf("  %2d  %s ", sp->sr_index, sp->sr_name );
d1777 67
d1873 2
@


8.9
log
@1)  Switched to using rt command parsing routines.
2)  Changed protocol to send view matrix stuff as new-style
    RT command script text.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 8.8 89/01/25 01:44:22 mike Locked $ (BRL)";
a95 1
	{ MSG_OPTIONS, ph_default, "Set options" },
d1078 1
a1078 1
	sprintf(buf, "%s -w%d -n%d -H%d -p%f",
d1082 1
a1082 3

	if( pkg_send( MSG_OPTIONS, buf, strlen(buf)+1, sp->sr_pc ) < 0 )
		dropclient(sp->sr_pc);
@


8.8
log
@Now link with librt
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 8.7 89/01/25 01:33:57 mike Locked $ (BRL)";
d32 1
d55 25
a106 4
#define MAXARGS 48
char *cmd_args[MAXARGS];
int numargs;

d130 1
a130 3
	double		fr_viewsize;
	double		fr_eye_model[3];
	double		fr_mat[16];
d145 1
d176 1
a176 2
/* START */
char	start_cmd[256];	/* contains file name & objects */
d178 2
d556 1
a556 370
	if( strncmp( buf, "load ", 5 ) == 0 )  {
		register struct servers *sp;
		if( running )  {
			printf("Can't load while running!!\n");
			return;
		}
		/* Really ought to reset here, too */
		if(start_cmd[0] != '\0' )  {
			printf("Was loaded with %s, restarting all\n", start_cmd);
			strncpy( start_cmd, &buf[5], strlen(&buf[5])-1 );
			for( sp = &servers[0]; sp < &servers[MAXSERVERS]; sp++ )  {
				if( sp->sr_pc == PKC_NULL )  continue;
				send_restart( sp );
			}
			return;
		}
		strncpy( start_cmd, &buf[5], strlen(&buf[5])-1 );
		/* Start any idle servers */
 		for( sp = &servers[0]; sp < &servers[MAXSERVERS]; sp++ )  {
			if( sp->sr_pc == PKC_NULL )  continue;
			if( sp->sr_started != SRST_NEW )  continue;
			send_start(sp);
		}
		return;
	}

	/* Chop up line */
	if( parse_cmd( buf ) > 0 ) return;	/* was nop */

	if( strcmp( cmd_args[0], "debug" ) == 0 )  {
		register struct servers *sp;
		char rbuf[64];

		sprintf(rbuf, "-x%s", cmd_args[1] );
		for( sp = &servers[0]; sp < &servers[MAXSERVERS]; sp++ )  {
			if( sp->sr_pc == PKC_NULL )  continue;
			(void)pkg_send( MSG_OPTIONS, rbuf, strlen(buf)+1, sp->sr_pc);
		}
		return;
	}
	if( strcmp( cmd_args[0], "f" ) == 0 )  {
		width = height = atoi( cmd_args[1] );
		if( width < 4 || width > 16*1024 )
			width = 64;
		printf("width=%d, height=%d, takes effect after next MAT\n", width, height);
		return;
	}
	if( strcmp( cmd_args[0], "-H" ) == 0 )  {
		hypersample = atoi( cmd_args[1] );
		printf("hypersample=%d, takes effect after next MAT\n", hypersample);
		return;
	}
	if( strcmp( cmd_args[0], "-B" ) == 0 )  {
		benchmark = 1;
		printf("Benchmark flag=%d, takes effect after next MAT\n", benchmark);
		return;
	}
	if( strcmp( cmd_args[0], "p" ) == 0 )  {
		perspective = atof( cmd_args[1] );
		printf("perspective angle=%g, takes effect after next MAT\n", perspective);
		return;
	}
	if( strcmp( cmd_args[0], "read" ) == 0 )  {
		register FILE *fp;

		if( numargs < 2 )  return;
		if( (fp = fopen(cmd_args[1], "r")) == NULL )  {
			perror(cmd_args[1]);
			return;
		}
		while( !feof(fp) )  {
			/* do one command from file */
			interactive_cmd(fp);
			/* Without delay, see if anything came in */
			check_input(0);
		}
		fclose(fp);
		printf("read file done\n");
		return;
	}
	if( strcmp( cmd_args[0], "detach" ) == 0 )  {
		detached = 1;
		clients &= ~(1<<0);	/* drop stdin */
		close(0);
		return;
	}
	if( strcmp( cmd_args[0], "file" ) == 0 )  {
		if( numargs < 2 )  return;
		strncpy( out_file, cmd_args[1], sizeof(out_file) );
		printf("frames will be recorded in %s.###\n", out_file);
		return;
	}
	if( strcmp( cmd_args[0], "mat" ) == 0 )  {
		register FILE *fp;
		register struct frame *fr;

		GET_FRAME(fr);

		if( numargs >= 3 )  {
			fr->fr_number = atoi(cmd_args[2]);
		} else {
			fr->fr_number = 0;
		}
		if( (fp = fopen(cmd_args[1], "r")) == NULL )  {
			perror(cmd_args[1]);
			return;
		}
		for( i=fr->fr_number; i>=0; i-- )
			if(read_matrix( fp, fr ) < 0 ) break;
		fclose(fp);

		prep_frame(fr);
		APPEND_FRAME( fr, FrameHead.fr_back );
		return;
	}
	if( strcmp( cmd_args[0], "movie" ) == 0 )  {
		register FILE *fp;
		register struct frame *fr;
		struct frame dummy_frame;
		int a,b;

		/* movie mat a b */
		if( numargs < 4 )  {
			printf("usage:  movie matfile startframe endframe\n");
			return;
		}
		if( running )  {
			printf("already running, please wait\n");
			return;
		}
		if( start_cmd[0] == '\0' )  {
			printf("need LOAD before MOVIE\n");
			return;
		}
		a = atoi( cmd_args[2] );
		b = atoi( cmd_args[3] );
		if( (fp = fopen(cmd_args[1], "r")) == NULL )  {
			perror(cmd_args[1]);
			return;
		}
		/* Skip over unwanted beginning frames */
		for( i=0; i<a; i++ )
			if(read_matrix( fp, &dummy_frame ) < 0 ) break;
		for( i=a; i<b; i++ )  {
			GET_FRAME(fr);
			fr->fr_number = i;
			if(read_matrix( fp, fr ) < 0 ) break;
			prep_frame(fr);
			APPEND_FRAME( fr, FrameHead.fr_back );
		}
		fclose(fp);
		printf("Movie ready\n");
		return;
	}
	if( strcmp( cmd_args[0], "add" ) == 0 )  {
		for( i=1; i<numargs; i++ )  {
			fprintf( helper_fp, "%s %d ",
				cmd_args[i], pkg_permport );
			fflush( helper_fp );
			check_input(1);		/* get connections */
		}
		return;
	}
	if( strcmp( cmd_args[0], "drop" ) == 0 )  {
		register struct servers *sp;
		if( numargs <= 1 )  return;
		sp = get_server_by_name( cmd_args[1] );
		if( sp == SERVERS_NULL || sp->sr_pc == PKC_NULL )  return;
		dropclient(sp->sr_pc);
		return;
	}
	if( strcmp( cmd_args[0], "restart" ) == 0 )  {
		register struct servers *sp;
		if( numargs <= 1 )  {
			/* Restart all */
			printf("restarting all\n");
			for( sp = &servers[0]; sp < &servers[MAXSERVERS]; sp++ )  {
				if( sp->sr_pc == PKC_NULL )  continue;
				send_restart( sp );
			}
			return;
		}
		sp = get_server_by_name( cmd_args[1] );
		if( sp == SERVERS_NULL || sp->sr_pc == PKC_NULL )  return;
		send_restart( sp );
		/* The real action takes place when he closes the conn */
		return;
	}
	if( strcmp( cmd_args[0], "stop" ) == 0 )  {
		printf("no more scanlines being scheduled, done soon\n");
		running = 0;
		return;
	}
	if( strcmp( cmd_args[0], "reset" ) == 0 )  {
		register struct frame *fr;
		register struct list *lp;

		if( running )  {
			printf("must STOP before RESET!\n");
			return;
		}
		for( fr = FrameHead.fr_forw; fr != &FrameHead; fr=fr->fr_forw )  {
			if( fr->fr_picture )  free(fr->fr_picture);
			fr->fr_picture = (char *)0;
			/* Need to remove any pending work,
			 * work already assigned will dribble in.
			 */
			while( (lp = fr->fr_todo.li_forw) != &(fr->fr_todo) )  {
				DEQUEUE_LIST( lp );
				FREE_LIST(lp);
			}
			/* We will leave cleanups to schedule() */
		}
		return;
	}
	if( strcmp( cmd_args[0], "attach" ) == 0 )  {
		register struct frame *fr;
		int maxx;

		if( init_fb(cmd_args[1]) < 0 )  return;

		if( (fr = FrameHead.fr_forw) == &FrameHead )  return;

		/* Draw the accumulated image */
		if( fr->fr_picture == (char *)0 )  return;
		size_display(fr);
		if( fbp == FBIO_NULL ) return;
		/* Trim to what can be drawn */
		maxx = fr->fr_width;
		if( maxx > fb_getwidth(fbp) )
			maxx = fb_getwidth(fbp);
		for( i=0; i<fr->fr_height; i++ )  {
			fb_write( fbp, 0, i%fb_getheight(fbp),
				fr->fr_picture + i*fr->fr_width*3,
				maxx );
		}
		return;
	}
	if( strcmp( cmd_args[0], "release" ) == 0 )  {
		if(fbp != FBIO_NULL) fb_close(fbp);
		fbp = FBIO_NULL;
		return;
	}
	if( strcmp( cmd_args[0], "frames" ) == 0 )  {
		register struct frame *fr;

		/* Sumarize frames waiting */
		printf("Frames waiting:\n");
		for(fr=FrameHead.fr_forw; fr != &FrameHead; fr=fr->fr_forw) {
			printf("%5d\t", fr->fr_number);
			printf("width=%d, height=%d, perspective angle=%f, ",
				fr->fr_width, fr->fr_height, fr->fr_perspective );
			printf("viewsize = %f\n", fr->fr_viewsize);
			printf("\thypersample = %d, ", fr->fr_hyper);
			printf("benchmark = %d, ", fr->fr_benchmark);
			if( fr->fr_picture )  printf(" (Pic)");
			printf("\n");
			printf("\tnrays = %d, cpu sec=%g\n", fr->fr_nrays, fr->fr_cpu);
			printf("       servinit: ");
			for( i=0; i<MAXSERVERS; i++ )
				printf("%d ", fr->fr_servinit[i]);
			printf("\n");
			pr_list( &(fr->fr_todo) );
		}
		return;
	}
	if( strcmp( cmd_args[0], "stat" ) == 0 ||
	    strcmp( cmd_args[0], "status" ) == 0 )  {
		register struct servers *sp;
	    	int	num;

		if( start_cmd[0] == '\0' )
			printf("No model loaded yet\n");
		else
			printf("\n%s %s\n",
				running ? "RUNNING" : "loaded",
				start_cmd );

		if( fbp != FBIO_NULL )
			printf("Framebuffer is %s\n", fbp->if_name);
		else
			printf("No framebuffer\n");
		if( out_file[0] != '\0' )
			printf("Output file: %s.###\n", out_file );
		printf("Printing of remote messages is %s\n",
			print_on?"ON":"Off" );
	    	printf("Listening at %s, port %d\n", ourname, pkg_permport);

		/* Print work assignments */
		printf("Servers:\n");
		for( sp = &servers[0]; sp < &servers[MAXSERVERS]; sp++ )  {
			if( sp->sr_pc == PKC_NULL )  continue;
			printf("  %2d  %s ", sp->sr_index, sp->sr_name );
			switch( sp->sr_started )  {
			case SRST_NEW:
				printf("Idle"); break;
			case SRST_LOADING:
				printf("(Loading)"); break;
			case SRST_READY:
				printf("Ready"); break;
			default:
				printf("Unknown"); break;
			}
			if( sp->sr_curframe != FRAME_NULL )
				printf(" frame %d\n", sp->sr_curframe->fr_number);
			else
				printf("\n");
			num = sp->sr_nlines<=0 ? 1 : sp->sr_nlines;
			printf("\tlast:  elapsed=%g, cpu=%g\n",
				sp->sr_l_elapsed,
				sp->sr_l_cpu );
			printf("\t avg:  elapsed=%g, weighted=%g, cpu=%g clump=%d\n",
				sp->sr_s_elapsed/num,
				sp->sr_w_elapsed,
				sp->sr_s_cpu/num,
				sp->sr_lump );

			pr_list( &(sp->sr_work) );
		}
		return;
	}
	if( strcmp( cmd_args[0], "clear" ) == 0 )  {
		if( fbp == FBIO_NULL )  return;
		fb_clear( fbp, PIXEL_NULL );
		cur_fbwidth = 0;
		return;
	}
	if( strcmp( cmd_args[0], "print" ) == 0 )  {
		register struct servers *sp;
		if( numargs > 1 )
			print_on = atoi(cmd_args[1]);
		else
			print_on = !print_on;	/* toggle */
		for( sp = &servers[0]; sp < &servers[MAXSERVERS]; sp++ )  {
			if( sp->sr_pc == PKC_NULL )  continue;
			send_loglvl( sp );
		}
		printf("Printing of remote messages is %s\n",
			print_on?"ON":"Off" );
		return;
	}
	if( strcmp( cmd_args[0], "go" ) == 0 )  {
		do_a_frame();
		return;
	}
	if( strcmp( cmd_args[0], "?" ) == 0 )  {
		printf("load db.g trees\n");
		printf("f #		set width&height\n");
		printf("p #		set perspective angle (0=ortho)\n");
		printf("-H #		set hypersampling\n");
		printf("-B		set benchmark flag\n");
		printf("read script\n");
		printf("mat file	load matrix from file\n");
		printf("movie file a b\n");
		printf("file name	store frames in file\n");
		printf("add host\n");
		printf("drop host\n");
		printf("restart host\n");
		printf("attach		re-attach to display\n");
		printf("release		release display (continue running)\n");
		printf("detach		stop reading stdin\n");
		printf("stat		show server status\n");
		printf("frames		show frame status\n");
		printf("clear		clear screen\n");
		printf("print [0|1]	enable remote logging\n");
		printf("go		start processing\n");
		printf("stop		cease processing\n");
		printf("reset		zap work queues\n");
	}
	printf("%s: Unknown command, ? for help\n", cmd_args[0]);
d616 44
a670 2
	int fd, cnt;
	char name[256];
d672 1
a672 1
	double	delta;
d678 2
a679 1
	for( fr = FrameHead.fr_forw; fr != &FrameHead; fr = fr->fr_forw )  {
d681 2
a682 1
			continue;	/* still work to be done */
a690 12
		/* Frame has just been completed */
		(void)gettimeofday( &fr->fr_end, (struct timezone *)0 );
		delta = tvdiff( &fr->fr_end, &fr->fr_start);
		if( delta < 0.0001 )  delta=0.0001;
		printf("frame %d DONE: %g elapsed sec, %d rays/%g cpu sec\n",
			fr->fr_number,
			delta,
			fr->fr_nrays,
			fr->fr_cpu );
		printf("  RTFM=%g rays/sec (%g rays/cpu sec)\n",
			fr->fr_nrays/delta,
			fr->fr_nrays/fr->fr_cpu );
d692 1
a692 17
		if( out_file[0] != '\0' )  {
			sprintf(name, "%s.%d", out_file, fr->fr_number);
			cnt = fr->fr_width*fr->fr_height*3;
			if( (fd = creat(name, 0444)) > 0 )  {
				printf("Writing..."); fflush(stdout);
				if( write( fd, fr->fr_picture, cnt ) != cnt ) {
					perror(name);
					exit(3);
				} else
					printf(" %s\n", name);
				close(fd);
			} else {
				perror(name);
			}
		}
		if( fr->fr_picture )  free(fr->fr_picture);
		fr->fr_picture = (char *)0;
d694 7
a700 8
		{
			register struct frame *fr2;
			fr2 = fr->fr_forw;
			DEQUEUE_FRAME(fr);
			FREE_FRAME(fr);
			fr = fr2->fr_back;
			continue;
		}
d702 1
d723 2
a724 1
		 * Look for a free server to dispatch work to
d782 1
d786 12
a797 7
	fr->fr_viewsize = atof(number);
	if( fscanf( fp, "%s", number ) != 1 )  goto out;
	fr->fr_eye_model[0] = atof(number);
	if( fscanf( fp, "%s", number ) != 1 )  goto out;
	fr->fr_eye_model[1] = atof(number);
	if( fscanf( fp, "%s", number ) != 1 )  goto out;
	fr->fr_eye_model[2] = atof(number);
d799 3
a801 3
		if( fscanf( fp, "%s", number ) != 1 )
			goto out;
		fr->fr_mat[i] = atof(number);
d803 2
a813 48
 *			P A R S E _ C M D
 */
parse_cmd( line )
char *line;
{
	register char *lp;
	register char *lp1;

	numargs = 0;
	lp = &line[0];
	cmd_args[0] = &line[0];

	if( *lp=='\0' || *lp == '\n' )
		return(1);		/* NOP */

	/* Handle "!" shell escape char so the shell can parse the line */
	if( *lp == '!' )  {
		(void)system( &line[1] );
		(void)printf("!\n");
		return(1);		/* Don't process command line! */
	}

	/* In case first character is not "white space" */
	if( (*lp != ' ') && (*lp != '\t') && (*lp != '\0') )
		numargs++;		/* holds # of args */

	for( lp = &line[0]; *lp != '\0'; lp++ )  {
		if( (*lp == ' ') || (*lp == '\t') || (*lp == '\n') )  {
			*lp = '\0';
			lp1 = lp + 1;
			if( (*lp1 != ' ') && (*lp1 != '\t') &&
			    (*lp1 != '\n') && (*lp1 != '\0') )  {
				if( numargs >= MAXARGS )  {
					(void)printf("More than %d arguments, excess flushed\n", MAXARGS);
					cmd_args[MAXARGS] = (char *)0;
					return(0);
				}
				cmd_args[numargs++] = lp1;
			}
		}
		/* Finally, a non-space char */
	}
	/* Null terminate pointer array */
	cmd_args[numargs] = (char *)0;
	return(0);
}

/*
d1055 1
d1087 1
a1087 23
	sprintf( buf,
		"%f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f",
		fr->fr_viewsize,
		fr->fr_eye_model[0],
		fr->fr_eye_model[1],
		fr->fr_eye_model[2],
		(fr->fr_mat[0]),
		(fr->fr_mat[1]),
		(fr->fr_mat[2]),
		(fr->fr_mat[3]),
		(fr->fr_mat[4]),
		(fr->fr_mat[5]),
		(fr->fr_mat[6]),
		(fr->fr_mat[7]),
		(fr->fr_mat[8]),
		(fr->fr_mat[9]),
		(fr->fr_mat[10]),
		(fr->fr_mat[11]),
		(fr->fr_mat[12]),
		(fr->fr_mat[13]),
		(fr->fr_mat[14]),
		(fr->fr_mat[15]) );
	if( pkg_send( MSG_MATRIX, buf, strlen(buf)+1, sp->sr_pc ) < 0 )
d1186 508
@


8.7
log
@Changed to use "helper" (child) process to handle setting up
new network connections.  This leaves parent free to handle
work dispatching, and prevents having the (potentially large)
parent have to fork().
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 8.6 89/01/20 06:46:37 mike Locked $ (BRL)";
d38 3
d151 1
a151 2
/* struct rt_g	rt_g; */
int	rt_g[128];		/* fool the loader */
@


8.6
log
@Began adding support for non-interactive use.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 8.5 89/01/20 06:15:42 mike Locked $ (BRL)";
d138 1
a138 1
/* Options */
d156 1
d219 3
a686 1
		char cmd[128];
d688 3
a690 17
			/* XXX should use rexecd! */
			sprintf(cmd,
				"rsh %s -n 'cd cad/remrt; rtsrv %s %d'",
				cmd_args[i], ourname, pkg_permport );
			if( vfork() == 0 )  {
				/* 1st level child */
				(void)close(0);
				for(i=3; i<40; i++)  (void)close(i);
				if( vfork() == 0 )  {
					/* worker Child */
					system( cmd );
					_exit(0);
				}
				_exit(0);
			} else {
				(void)wait(0);
			}
a692 1
		printf("add finished\n");
d1513 61
@


8.5
log
@moved list declaration and macros to list.h
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 8.4 89/01/20 04:35:54 mike Locked $ (BRL)";
d139 12
a150 4
int	npts = 64;
int	hypersample = 0;
double	perspective = 0;
int	benchmark = 0;
a228 1
	printf("REMRT listening\n");
a229 1
	clients = (1<<0);
d231 25
d304 1
a304 1
		interactive(stdin);
d477 1
a477 1
 *			I N T E R A C T I V E
d479 1
a479 1
interactive(fp)
d569 4
a572 4
		npts = atoi( cmd_args[1] );
		if( npts < 4 || npts > 8*1024 )
			npts = 64;
		printf("npts=%d, takes effect after next MAT\n", npts);
d587 1
a587 1
		printf("perspective angle=%f, takes effect after next MAT\n", perspective);
d600 1
a600 1
			interactive(fp);
d891 1
a891 1
		printf("f #		set npts\n");
d927 2
a928 1
	fr->fr_width = fr->fr_height = npts;
d1013 3
a1015 3
		printf("  RTFMc=%g rays/s RTFMe=%g rays/sec\n",
			fr->fr_nrays/fr->fr_cpu,
			fr->fr_nrays/delta );
a1380 2
	int res = 512;

d1382 2
a1383 3
	while( npts > res )  res <<= 1;
	if( (fbp = fb_open( name, res, res )) == FBIO_NULL )  {
		printf("fb_open %d failed\n", res);
d1520 5
@


8.4
log
@Added lots of timing stuff.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 8.3 89/01/20 03:17:22 mike Locked $ (BRL)";
d41 1
a84 8
/* Lists */
struct list {
	struct list	*li_forw;
	struct list	*li_back;
	struct frame	*li_frame;
	int		li_start;
	int		li_stop;
};
d1071 1
a1071 1
			if( a == 0 )  {
@


8.3
log
@Added some bullet-proofing
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 8.2 89/01/20 01:24:46 mike Locked $ (BRL)";
d98 1
a100 4
	char		*fr_picture;	/* ptr to picture buffer */
	struct list	fr_todo;	/* work still to be done */
	long		fr_start;	/* start time */
	long		fr_end;		/* end time */
d104 7
d124 1
a124 1
	int		sr_speed;	/* # lines to send at once */
d131 1
a131 1
	char		sr_name[32];	/* host name */
d133 9
d179 27
d311 1
d316 1
a316 1
	sp->sr_speed = 3;
d769 1
a769 1
			printf(" %4d  ", fr->fr_number);
d776 3
a778 1
			printf("\n       servinit: ");
d789 1
d827 10
d911 5
d962 1
d980 4
a983 2
		fr->fr_end = time(0);
		printf("frame %d DONE in %d seconds\n",
d985 7
a991 1
			fr->fr_end - fr->fr_start);
d1060 1
a1060 1
			b = a+sp->sr_speed-1;	/* work increment */
d1078 3
a1080 2
			if( a == 0 )
				fr->fr_start = time(0);
d1243 1
d1245 2
d1293 10
a1302 1
	/* li_nrays, li_cpusec */
d1481 2
@


8.2
log
@Changed for non-square images, switched to struct_import()
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 8.1 88/10/05 00:33:56 mike Locked $ (BRL)";
d762 1
d1183 1
d1199 5
a1203 1
	if( pc->pkc_len-info.li_len < i )  i = pc->pkc_len-info.li_len;
d1210 1
a1210 1
		if( maxx > fb_getwidth(fbp) )
d1212 2
@


8.1
log
@Release_3.0
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 1.19 88/09/17 07:05:36 mike Exp $ (BRL)";
d43 2
d51 1
a51 1
int cur_fbsize;			/* current fb size */
d98 2
a99 1
	int		fr_size;	/* frame size (pixels) */
d106 1
a106 1
	double		fr_zoomout;	/* perspective */
d135 1
a135 1
double	zoomout = 0;
d169 2
a170 1
int argc; char **argv;
d521 2
a522 2
		zoomout = atof( cmd_args[1] );
		printf("zoomount=%f, takes effect after next MAT\n", zoomout);
d622 1
a622 1
				"rsh %s 'hostname; cd cad/remrt; rtsrv %s %d;uptime'",
d704 1
a704 1
		size_display(fr->fr_size);
d707 1
a707 1
		maxx = fr->fr_size;
d710 3
a712 3
		for( i=0; i<fr->fr_size; i++ )  {
			fb_write( fbp, 0, i%fb_getwidth(fbp),
				fr->fr_picture + i*fr->fr_size*3,
d729 2
a730 2
			printf("size=%d, zoomout=%f, ",
				fr->fr_size, fr->fr_zoomout );
d789 1
a789 1
		cur_fbsize = 0;
d813 1
a813 1
		printf("p #		set zoomout\n");
d848 2
a849 2
	fr->fr_size = npts;
	fr->fr_zoomout = zoomout;
d861 1
a861 1
	lp->li_stop = fr->fr_size-1;	/* last scanline # */
d925 1
a925 1
			cnt = fr->fr_size*fr->fr_size*3;
d1172 1
d1177 5
a1181 1
	line = ((buf[1]&0xFF)<<8) | (buf[0]&0xFF);
d1185 1
a1185 1
		i = fr->fr_size*fr->fr_size*3+3;
d1196 3
a1198 3
	i = fr->fr_size*3;
	if( pc->pkc_len-2 < i )  i = pc->pkc_len-2;
	bcopy( buf+2, fr->fr_picture + line*fr->fr_size*3, i );
d1206 3
a1208 2
		size_display(fr->fr_size);
		fb_write( fbp, 0, line%fb_getheight(fbp), buf+2, maxx );
d1212 3
d1216 1
a1216 1
	list_remove( &(sp->sr_work), line );
d1276 1
a1276 1
	cur_fbsize = 0;
d1283 2
a1284 2
size_display(n)
register int n;
d1286 1
a1286 1
	if( cur_fbsize == n )
d1290 3
a1292 3
	if( n > fb_getwidth(fbp) )  {
		printf("Warning:  fb not big enough for %d pixels, display truncated\n", n );
		cur_fbsize = n;
d1295 1
a1295 1
	cur_fbsize = n;
d1297 4
a1300 2
	fb_zoom( fbp, fb_getwidth(fbp)/n, fb_getheight(fbp)/n );
	fb_window( fbp, n/2, n/2 );		/* center of view */
d1347 5
a1351 9
	if( fr->fr_zoomout > 0 )  {
		sprintf(buf, "%s -f%d -H%d -p%f",
			fr->fr_benchmark ? "-B" : "",
			fr->fr_size, fr->fr_hyper, fr->fr_zoomout );
	}  else  {
		sprintf(buf, "%s -f%d -H%d",
			fr->fr_benchmark ? "-B" : "",
			fr->fr_size, fr->fr_hyper );
	}
@


1.19
log
@Minor modernizations to track RT.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 1.18 88/03/02 04:11:40 mike Locked $ (BRL)";
@


1.18
log
@Added "status" as alias for "stat"
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 1.17 87/11/02 15:44:35 mike Locked $ (BRL)";
d57 4
a60 4
int ph_default();	/* foobar message handler */
int ph_pixels();
int ph_print();
int ph_start();
d145 1
d180 2
a181 1
	if( (tcp_listen_fd = pkg_permserver("rtsrv", "tcp", 8, errlog)) < 0 )
d183 1
d273 1
a273 1
#ifdef cray
d281 1
a281 1
#endif cray
d616 1
d618 2
a619 2
				"rsh %s 'hostname; cd cad/remrt; rtsrv %s;uptime'",
				cmd_args[i], ourname );
d1097 1
d1120 1
d1144 1
d1159 1
@


1.17
log
@Added hypersample and benchmark flags
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 1.16 87/08/10 07:11:22 mike Locked $ (BRL)";
d735 2
a736 1
	if( strcmp( cmd_args[0], "stat" ) == 0 )  {
@


1.16
log
@Added Benchmark flag
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 1.15 87/08/10 02:19:18 mike Locked $ (BRL)";
d841 2
@


1.15
log
@Working version.  Modified to send options & matrix at the start of
each new frame.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 1.14 87/04/10 08:11:48 mike Exp $ (BRL)";
d102 1
d133 1
d503 1
a503 1
	if( strcmp( cmd_args[0], "h" ) == 0 )  {
d508 5
d723 3
a725 2
			printf("viewsize = %f, ", fr->fr_viewsize);
			printf("hypersample = %d", fr->fr_hyper);
d805 2
a806 1
		printf("h #		set hypersampling\n");
d1322 2
a1323 1
		sprintf(buf, "-f%d -h%d -p%f",
d1326 3
a1328 1
		sprintf(buf, "-f%d -h%d", fr->fr_size, fr->fr_hyper );
@


1.14
log
@Upgraded for current version of rt
@
text
@a0 4
/***
****remaining bug:  when rolling from one frame to another,
****a new matrix and options pkg need to be sent!
****/
d24 1
a24 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 1.13 86/10/29 02:23:00 mike Locked $ (BRL)";
d28 1
d80 1
d107 1
d114 1
a114 1
	struct pkg_conn	*sr_pc;	/* PKC_NULL means slot not in use */
d118 3
a120 3
#define SRST_NEW	1	/* connected, no model loaded yet */
#define SRST_LOADING	2	/* loading, awaiting ready response */
#define SRST_READY	3	/* loaded, ready */
d124 2
a125 1
} servers[NFD];
d129 4
a132 4
int npts = 64;
int hypersample = 0;
double zoomout = 0;
extern double atof();
d135 1
a135 1
char start_cmd[256];	/* contains file name & objects */
d137 2
a138 2
char ourname[32];
char out_file[256];		/* output file name */
d142 1
a142 1
int tcp_listen_fd;
d171 1
a171 1
	for( sp = &servers[0]; sp < &servers[NFD]; sp++ )  {
d193 3
d235 3
d267 1
d291 3
d299 1
d316 3
d321 1
a321 1
			lp->li_frame->fr_number,
d323 1
a323 1
		APPEND_LIST( lp, &(lp->li_frame->fr_todo) );
d325 1
a325 1
		pr_list(&(lp->li_frame->fr_todo));
d378 4
d389 3
a391 3
	if( *str == '#' )  {
		i = atoi( str+1 );
		if( i < 0 || i > NFD )  return( SERVERS_NULL );
d395 1
a395 1
	for( sp = &servers[0]; sp < &servers[NFD]; sp++ )  {
d402 3
d439 1
a439 1
		for( sp = &servers[0]; sp < &servers[NFD]; sp++ )  {
d464 1
a464 1
			for( sp = &servers[0]; sp < &servers[NFD]; sp++ )  {
d472 1
a472 1
 		for( sp = &servers[0]; sp < &servers[NFD]; sp++ )  {
d488 1
a488 1
		for( sp = &servers[0]; sp < &servers[NFD]; sp++ )  {
d640 1
a640 1
			for( sp = &servers[0]; sp < &servers[NFD]; sp++ )  {
d713 1
a713 1
			printf(" %d  ", fr->fr_number);
d719 3
d748 1
a748 1
		for( sp = &servers[0]; sp < &servers[NFD]; sp++ )  {
d750 1
a750 1
			printf("  %s ", sp->sr_name );
d753 1
a753 1
				printf("IDLE\n"); break;
d755 1
a755 1
				printf("(Loading)\n"); break;
d757 1
a757 1
				printf("READY\n"); break;
d759 1
a759 1
				printf("Unknown\n"); break;
d761 4
d781 1
a781 1
		for( sp = &servers[0]; sp < &servers[NFD]; sp++ )  {
d819 5
a823 1
/* Fill in frame structure after reading MAT */
d834 1
d845 3
d868 2
d890 1
a890 1
		for( sp = &servers[0]; sp < &servers[NFD]; sp++ )  {
d952 1
a952 1
		for( sp = &servers[0]; sp < &servers[NFD]; sp++ )  {
d964 6
d982 1
a982 4
			if( sp->sr_curframe != fr )  {
				sp->sr_curframe = fr;
				send_matrix(sp);
			}
d994 1
a994 1
		if( sp >= &servers[NFD] )  return;	/* no free servers */
d998 3
d1030 3
d1078 3
d1123 3
d1135 5
d1157 1
d1188 5
a1192 1
/* Given pointer to head of list of ranges, remove the item that's done */
d1227 3
d1246 4
d1268 3
d1281 3
d1291 3
d1301 6
a1306 1
send_matrix(sp)
d1308 1
a1310 1
	register struct frame *fr;
a1311 2
	fr = sp->sr_curframe;
	if( fr->fr_viewsize <= 0 )  return;
a1317 1

d1345 1
d1347 4
d1360 3
@


1.13
log
@bug noted for later treatment
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 1.12 86/10/27 22:22:03 mike Locked $ (BRL)";
d47 4
d177 1
a177 1
	if( (tcp_listen_fd = pkg_initserver("rtsrv", 8, errlog)) < 0 )
d240 1
d261 5
d269 1
@


1.12
log
@one last 1st quadrant issue
@
text
@d1 4
d28 1
a28 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 1.11 86/10/27 04:18:55 mike Locked $ (BRL)";
@


1.11
log
@Fixed null pointer problem.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 1.10 86/10/27 01:06:59 mike Locked $ (BRL)";
d661 1
a661 1
				fr->fr_picture + (fr->fr_size-i-1)*fr->fr_size*3,
@


1.10
log
@Make file writing 1st quadrant, too.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 1.9 86/10/27 00:57:27 mike Locked $ (BRL)";
d734 4
a737 1
		print_on = atoi(cmd_args[1]);
@


1.9
log
@for images biger than screen size, reduce y modulo screensize,
rather than truncating.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 1.8 86/10/26 23:43:16 mike Locked $ (BRL)";
d1092 1
a1092 2
	bcopy( buf+2, fr->fr_picture + 
		(fr->fr_size-line-1)*fr->fr_size*3, i );
@


1.8
log
@fixes
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 1.7 86/10/26 22:26:58 mike Locked $ (BRL)";
d645 1
a645 1
		int maxx, maxy;
d656 1
a656 1
		maxx = maxy = fr->fr_size;
d659 2
a660 4
		if( maxy > fb_getheight(fbp) )
			maxy = fb_getheight(fbp);
		for( i=0; i<maxy; i++ )  {
			fb_write( fbp, 0, i,
d1096 1
a1096 1
	if( fbp != FBIO_NULL && line < fb_getheight(fbp) )  {
d1102 1
a1102 1
		fb_write( fbp, 0, line, buf+2, maxx );
@


1.7
log
@Fixed matrix reading, added vfork(), which is important
when running big images.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 1.6 86/10/26 20:14:53 mike Locked $ (BRL)";
d645 1
d654 12
a665 4
		for( i=0; i<fr->fr_size; i++ )
			draw_pixline( fr->fr_picture + 
				(fr->fr_size-i-1)*fr->fr_size*3,
				fr->fr_size*3, i );
d1098 5
a1102 1
	if( fbp != FBIO_NULL )  {
d1104 1
a1104 1
		draw_pixline( buf+2, i, line );
a1113 11
/* We now depend on the fact the the libfb RGBpixel is the format
 * used internally by this routine.
 */
draw_pixline( cp, bytes, line )
register char *cp;
register int bytes;
int line;
{
	fb_write( fbp, 0, line, cp, bytes/3 );
}

d1173 2
a1174 3
		printf("current fb not big enough for %d pixels, releasing\n", n );
		fb_close(fbp);
		fbp = FBIO_NULL;
@


1.6
log
@chagned prints
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 1.5 86/10/26 19:50:56 mike Locked $ (BRL)";
d447 11
d460 1
a460 1
		if( npts < 1 || npts > 1024 )
d573 1
a573 1
			if( fork() == 0 )  {
d577 1
a577 1
				if( fork() == 0 )  {
d580 1
a580 1
					exit(0);
d582 1
a582 1
				exit(0);
d936 3
d940 13
a952 22
	fscanf(fp, "%f %f %f %f", &(fr->fr_viewsize),
		&(fr->fr_eye_model[0]),
		&(fr->fr_eye_model[1]),
		&(fr->fr_eye_model[2]) );
	fscanf(fp,
		"%f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f",
		&(fr->fr_mat[0]),
		&(fr->fr_mat[1]),
		&(fr->fr_mat[2]),
		&(fr->fr_mat[3]),
		&(fr->fr_mat[4]),
		&(fr->fr_mat[5]),
		&(fr->fr_mat[6]),
		&(fr->fr_mat[7]),
		&(fr->fr_mat[8]),
		&(fr->fr_mat[9]),
		&(fr->fr_mat[10]),
		&(fr->fr_mat[11]),
		&(fr->fr_mat[12]),
		&(fr->fr_mat[13]),
		&(fr->fr_mat[14]),
		&(fr->fr_mat[15]) );
d954 1
d1076 2
a1077 2
			fprintf(stdout,"ph_pixels: malloc error\n");
			fprintf(stderr,"ph_pixels: malloc error\n");
@


1.5
log
@Working version.
Chagned to not open framebuffer on startup.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: remrt.c,v 1.4 86/10/26 18:56:16 mike Locked $ (BRL)";
d171 1
a171 1
	printf("CTL listening\n");
d176 1
d181 1
a181 1
	printf("CTL out of clients\n");
d278 1
a278 1
	printf("CTL closing fd %d %s\n", fd, sp->sr_name);
d863 1
a863 1
		printf("CTL:  All work done!\n");
@


1.4
log
@typos
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: ctl.c,v 1.3 86/10/26 16:12:31 mike Locked $ (BRL)";
a174 2
	(void)init_fb( (char *)0 );	/* take default */

d679 4
@


1.3
log
@Converted to new libfb, RGBpixels, etc.
@
text
@d2 1
a2 1
 *  			C T L . C
d5 5
a9 3
 *  Operating as a network server, handles incomming
 *  connections, accepting input, and returning output,
 *  both solicited and unsolicited, via the pkg.c routines.
d24 1
a24 1
static char RCSid[] = "@@(#)$Header: ctl.c,v 1.2 86/07/30 03:49:23 mike Exp $ (BRL)";
d41 1
a41 1
#include "./ctl.h"
@


1.2
log
@Hypersampling
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: ctl.c,v 1.1 86/07/22 04:58:59 mike Exp $ (BRL)";
d35 1
a36 2
#include "rtsrv.h"
#include "ctl.h"
d38 2
a39 3
extern int ikfd;		/* defined in iklib.o */
extern int ikhires;		/* defined in iklib.o */
int ik_cur_size;		/* current fb size */
d41 3
d54 1
a54 1
struct pkg_switch pkg_switch[] = {
d61 2
a62 1
	{ MSG_PRINT, ph_print, "Log Message" }
a63 1
int pkg_swlen = sizeof(pkg_switch)/sizeof(struct pkg_switch);
d134 18
d167 1
a167 1
	if( (tcp_listen_fd = pkg_initserver("rtsrv", 8)) < 0 )
d173 1
a173 1
	init_fb();
d204 2
a205 1
		if( (pc = pkg_getclient(tcp_listen_fd,1)) != PKC_NULL )
d210 1
a210 1
	for( i=4; i<NFD; i++ )  {
d218 1
a218 1
	if( waittime>0 && (ibits & (1<<0)) )  {
d561 13
a573 1
			system( cmd );
a632 5
		if( ikfd > 0 )  {
			printf("already attached\n");
			return;
		}
		init_fb();
d634 2
d648 2
a649 2
		close(ikfd);
		ikfd = -1;
d704 3
a706 3
		if( ikfd < 0 )  return;
		ikclear();
		ik_cur_size = 0;
a994 15
/*
 *			E R R L O G
 *
 *  Log an error.  We supply the newline, and route to user.
 */
/* VARARGS */
void
errlog( str, a, b, c, d, e, f, g, h )
char *str;
{
	char buf[256];		/* a generous output line */

	(void)fprintf( stderr, str, a, b, c, d, e, f, g, h );
}

d1001 2
a1002 2
	for( i=0; i<pkg_swlen; i++ )  {
		if( pkg_switch[i].pks_type == pc->pkc_type )  break;
d1004 2
a1005 2
	errlog("CTL unable to handle %s message: len %d",
		pkg_switch[i].pks_title, pc->pkc_len);
d1078 1
a1078 1
	if( ikfd > 0 )  {
d1090 3
d1098 1
a1098 13
	static char pixels[1024*4];
	register char *pp;
	register int i;

	pp = pixels;
	for( i=bytes; i > 0; i -= 3 )  {
		/* R G B */
		*pp++ = *cp++;
		*pp++ = *cp++;
		*pp++ = *cp++;
		*pp++ = 0;
	}
	clustwrite( pixels, line, bytes/3 );
d1136 3
a1138 2

init_fb()
d1140 1
a1140 6
	/* Output directly to Ikonas */
	ik_cur_size = 0;
	if( npts > 512 )
		ikhires = 1;
	else
		ikhires = 0;
d1142 9
a1150 2
	ikopen();
	load_map(1);		/* Standard map: linear */
d1155 1
a1155 1
	if( ik_cur_size == n )
d1157 9
a1165 1
	ik_cur_size = n;
d1167 2
a1168 19
	if( n <= 32 )  {
		ikzoom( 15, 15 );	/* 1 pixel gives 16 */
		ikwindow( (0)*4, 4063+31 );
	} else if( n <= 50 )  {
		ikzoom( 9, 9 );		/* 1 pixel gives 10 */
		ikwindow( (0)*4, 4063+31 );
	} else if( n <= 64 )  {
		ikzoom( 7, 7 );		/* 1 pixel gives 8 */
		ikwindow( (0)*4, 4063+29 );
	} else if( n <= 128 )  {
		ikzoom( 3, 3 );		/* 1 pixel gives 4 */
		ikwindow( (0)*4, 4063+25 );
	} else if ( n <= 256 )  {
		ikzoom( 1, 1 );		/* 1 pixel gives 2 */
		ikwindow( (0)*4, 4063+17 );
	} else if ( n <= 512 )  {
		ikzoom( 0, 0 );		/* 1 pixel gives 1 */
		ikwindow( (0)*4, 4063+11 );
	}
@


1.1
log
@Initial revision
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d92 2
a93 1
	double		fr_zoomout;
d119 1
d242 1
a242 1
	if( start_cmd[0] != '\0' )
d244 2
d433 5
d586 2
d632 2
a633 1
			printf("viewsize = %f", fr->fr_viewsize);
d681 1
d683 4
d699 1
d1189 7
d1204 6
a1209 4
	if( fr->fr_zoomout > 0 )
		sprintf(buf, "-f%d -p%f", fr->fr_size, fr->fr_zoomout );
	else
		sprintf(buf, "-f%d", fr->fr_size );
@
