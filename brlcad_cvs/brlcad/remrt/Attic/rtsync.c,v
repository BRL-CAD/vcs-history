head	1.58;
access;
symbols
	rel-4-5:1.39
	ctj-4-5-post:1.23
	ctj-4-5-pre:1.23;
locks; strict;
comment	@ * @;


1.58
date	98.11.10.04.54.44;	author mike;	state dead;
branches;
next	1.57;

1.57
date	98.06.03.06.00.46;	author mike;	state Exp;
branches;
next	1.56;

1.56
date	98.05.28.04.03.15;	author mike;	state Exp;
branches;
next	1.55;

1.55
date	98.05.22.20.07.32;	author mike;	state Exp;
branches;
next	1.54;

1.54
date	98.04.29.06.08.21;	author mike;	state Exp;
branches;
next	1.53;

1.53
date	98.04.29.06.02.05;	author mike;	state Exp;
branches;
next	1.52;

1.52
date	98.04.29.06.01.12;	author mike;	state Exp;
branches;
next	1.51;

1.51
date	98.04.29.05.42.31;	author mike;	state Exp;
branches;
next	1.50;

1.50
date	98.04.29.04.35.58;	author mike;	state Exp;
branches;
next	1.49;

1.49
date	98.04.28.06.57.48;	author mike;	state Exp;
branches;
next	1.48;

1.48
date	98.04.28.06.40.36;	author mike;	state Exp;
branches;
next	1.47;

1.47
date	98.04.28.06.22.57;	author mike;	state Exp;
branches;
next	1.46;

1.46
date	98.04.28.06.06.13;	author mike;	state Exp;
branches;
next	1.45;

1.45
date	98.04.28.04.59.15;	author mike;	state Exp;
branches;
next	1.44;

1.44
date	98.04.28.04.25.54;	author mike;	state Exp;
branches;
next	1.43;

1.43
date	98.04.28.03.43.19;	author mike;	state Exp;
branches;
next	1.42;

1.42
date	98.04.28.00.44.35;	author mike;	state Exp;
branches;
next	1.41;

1.41
date	98.03.17.05.27.15;	author mike;	state Exp;
branches;
next	1.40;

1.40
date	98.03.17.03.29.57;	author mike;	state Exp;
branches;
next	1.39;

1.39
date	97.12.31.09.07.04;	author mike;	state Exp;
branches;
next	1.38;

1.38
date	97.12.23.10.20.58;	author mike;	state Exp;
branches;
next	1.37;

1.37
date	97.12.23.09.46.27;	author mike;	state Exp;
branches;
next	1.36;

1.36
date	97.08.26.05.55.00;	author mike;	state Exp;
branches;
next	1.35;

1.35
date	97.08.26.04.24.41;	author mike;	state Exp;
branches;
next	1.34;

1.34
date	97.08.26.03.47.32;	author mike;	state Exp;
branches;
next	1.33;

1.33
date	97.08.22.23.01.04;	author mike;	state Exp;
branches;
next	1.32;

1.32
date	97.08.21.03.25.28;	author mike;	state Exp;
branches;
next	1.31;

1.31
date	97.08.21.00.57.07;	author mike;	state Exp;
branches;
next	1.30;

1.30
date	97.08.21.00.11.12;	author mike;	state Exp;
branches;
next	1.29;

1.29
date	97.08.19.05.00.30;	author mike;	state Exp;
branches;
next	1.28;

1.28
date	97.07.01.22.00.05;	author mike;	state Exp;
branches;
next	1.27;

1.27
date	97.06.26.01.13.35;	author mike;	state Exp;
branches;
next	1.26;

1.26
date	97.06.25.02.39.09;	author mike;	state Exp;
branches;
next	1.25;

1.25
date	97.06.25.00.09.26;	author mike;	state Exp;
branches;
next	1.24;

1.24
date	97.06.23.04.58.07;	author mike;	state Exp;
branches;
next	1.23;

1.23
date	97.05.28.03.31.45;	author mike;	state Exp;
branches;
next	1.22;

1.22
date	97.03.07.02.52.42;	author mike;	state Exp;
branches;
next	1.21;

1.21
date	97.03.06.09.39.10;	author mike;	state Exp;
branches;
next	1.20;

1.20
date	97.03.06.09.08.27;	author mike;	state Exp;
branches;
next	1.19;

1.19
date	97.03.06.06.03.27;	author mike;	state Exp;
branches;
next	1.18;

1.18
date	97.03.06.05.03.24;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	97.03.05.09.45.49;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	97.03.05.07.46.20;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	97.03.05.07.30.22;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	97.01.07.04.05.37;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	97.01.04.05.12.09;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	97.01.04.03.24.30;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	96.12.31.17.03.36;	author jra;	state Exp;
branches;
next	1.10;

1.10
date	96.12.31.17.01.43;	author jra;	state Exp;
branches;
next	1.9;

1.9
date	95.08.24.03.56.41;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	95.08.24.03.16.46;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	95.08.23.02.05.30;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	95.08.22.22.02.07;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	95.07.18.03.01.18;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	95.07.15.07.52.47;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	95.07.15.07.11.33;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	95.07.15.06.11.12;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	95.07.15.02.34.12;	author mike;	state Exp;
branches;
next	;


desc
@Real-time ray-tracer master synchronization program.
@


1.58
log
@Moved real-time ray-tracer over into "SWISS" directory
@
text
@/*
 *			R T S Y N C . C
 *
 *  Main program to tightly synchronize a network distributed array of
 *  processors.  Interfaces with MGED via the VRMGR protocol,
 *  and with RTNODE.
 *
 *  The heart of the "real time ray-tracing" project.
 *
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1995 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */
#ifndef lint
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/remrt/rtsync.c,v 1.57 1998/06/03 06:00:46 mike Exp mike $ (ARL)";
#endif

#include "conf.h"

#include <stdio.h>
#include <ctype.h>
#include <signal.h>
#include <errno.h>
#include <netdb.h>
#include <math.h>
#ifdef USE_STRING_H
# include <string.h>
#else
# include <strings.h>
#endif

#include <sys/stat.h>
#include <sys/socket.h>
#include <netinet/in.h>

/*
 *  The situation with sys/time.h and time.h is crazy.
 *  We need sys/time.h for struct timeval,
 *  and time.h for struct tm.
 *
 *  on BSD (and SGI 4D), sys/time.h includes time.h,
 *  on the XMP (UNICOS 3 & 4), time.h includes sys/time.h,
 *  on the Cray-2, there is no automatic including.
 *
 *  Note that on many SYSV machines, the Cakefile has to set BSD
 */
#if BSD && !SYSV
#  include <sys/time.h>		/* includes <time.h> */
#else
#  if CRAY1 && !__STDC__
#	include <time.h>	/* includes <sys/time.h> */
#  else
#	include <sys/time.h>
#	include <time.h>
#  endif
#endif

#include "machine.h"
#include "vmath.h"
#include "rtstring.h"
#include "rtlist.h"
#include "raytrace.h"
#include "pkg.h"
#include "fb.h"
#include "tcl.h"
#include "tk.h"
#include "externs.h"

#include "./ihost.h"

extern int	pkg_permport;	/* libpkg/pkg_permserver() listen port */

/*
 *  Package Handlers for the VRMGR protocol
 */
#define VRMSG_ROLE	1	/* from MGED: Identify role of machine */
#define VRMSG_CMD	2	/* to MGED: Command to process */
#define VRMSG_EVENT	3	/* from MGED: device event */
#define VRMSG_POV	4	/* from MGED: point of view info */
#define VRMSG_VLIST	5	/* transfer binary vlist block */
#define VRMSG_CMD_REPLY	6	/* from MGED: reply to VRMSG_CMD */

void	ph_default();	/* foobar message handler */
void	vrmgr_ph_role();
void	vrmgr_ph_event();
void	vrmgr_ph_pov();
static struct pkg_switch vrmgr_pkgswitch[] = {
	{ VRMSG_ROLE,		vrmgr_ph_role,	"Declare role" },
	{ VRMSG_CMD,		ph_default,	"to MGED:  command" },
	{ VRMSG_EVENT,		vrmgr_ph_event,	"MGED device event" },
	{ VRMSG_POV,		vrmgr_ph_pov,	"MGED point of view" },
	{ VRMSG_VLIST,		ph_default,	"binary vlist block" },
	{ 0,			0,		(char *)0 }
};

int			vrmgr_listen_fd;	/* for new connections */
struct pkg_conn		*vrmgr_pc;		/* connection to VRMGR */
struct ihost		*vrmgr_ihost;		/* host of vrmgr_pc */
char			*pending_pov;		/* pending new POV */
char			*last_pov;		/* last POV sent */
int			print_on = 1;

/*
 *  Package handlers for the RTSYNC protocol.
 *  Numbered differently, to prevent confusion with other PKG protocols.
 */
#define RTSYNCMSG_PRINT	 999	/* StoM:  Diagnostic message */
#define RTSYNCMSG_ALIVE	1001	/* StoM:  protocol version, # of processors */
#define RTSYNCMSG_OPENFB 1002	/* both:  width height framebuffer */
#define RTSYNCMSG_DIRBUILD 1003	/* both:  database */
#define RTSYNCMSG_GETTREES 1004	/* both:  treetop(s) */
#define RTSYNCMSG_CMD	1006	/* MtoS:  Any Tcl command */
#define RTSYNCMSG_POV	1007	/* MtoS:  pov, min_res, start&end lines */
#define RTSYNCMSG_HALT	1008	/* MtoS:  abandon frame & xmit, NOW */
#define RTSYNCMSG_DONE	1009	/* StoM:  halt=0/1, res, elapsed, etc... */

void	rtsync_ph_alive();
void	rtsync_ph_openfb();
void	rtsync_ph_dirbuild();
void	rtsync_ph_gettrees();
void	rtsync_ph_done();
void	ph_print();
static struct pkg_switch rtsync_pkgswitch[] = {
	{ RTSYNCMSG_DONE,	rtsync_ph_done, "RTNODE assignment done" },
	{ RTSYNCMSG_ALIVE,	rtsync_ph_alive, "RTNODE is alive" },
	{ RTSYNCMSG_OPENFB,	rtsync_ph_openfb, "RTNODE open(ed) fb" },
	{ RTSYNCMSG_DIRBUILD,	rtsync_ph_dirbuild, "RTNODE dirbuilt/built" },
	{ RTSYNCMSG_GETTREES,	rtsync_ph_gettrees, "RTNODE prep(ed) db" },
	{ RTSYNCMSG_POV,	ph_default,	"POV" },
	{ RTSYNCMSG_HALT,	ph_default,	"HALT" },
	{ RTSYNCMSG_CMD,	ph_default,	"CMD" },
	{ RTSYNCMSG_PRINT,	ph_print,	"Log Message" },
	{ 0,			0,		(char *)0 }
};

int			rtsync_listen_fd;	/* for new connections */

#define STATE_NEWBORN	0		/* No packages received yet */
#define STATE_ALIVE	1		/* ALIVE pkg recv'd */
#define STATE_OPENFB	2		/* OPENFB ack pkg received */
#define STATE_DIRBUILT	3		/* DIRBUILD ack pkg received */
#define STATE_PREPPED	4		/* GETTREES ack pkg received */
CONST char *states[] = {
	"NEWBORN",
	"ALIVE",
	"OPENFB",
	"DIRBUILT",
	"PREPPED",
	"n+1"
};

/*
 *			R T N O D E
 *
 *  One per compute server host.
 */
struct rtnode {
	int		fd;
	struct pkg_conn	*pkg;
	struct ihost	*host;
	int		state;
	int		ncpus;		/* Ready when > 0, for now */
	int		busy;		/* !0 -> still working */
	int		lump;		/* # of lines in last assignment */
	int		finish_order;	/* 1st in the race? */
	struct timeval	time_start;	/* elapsed time of last assignment (sec) */
	fastf_t		time_delta;
	fastf_t		i_lps;		/* instantaneous # lines per sec */
	fastf_t		w_lps;		/* weighted # lines per sec */
	int		pr_percent;	/* reprojection pixel percentage */
	fastf_t		pr_time;	/* elapsed time for reprojection (ms) */
	fastf_t		rt_time;	/* elapsed time for ray-tracing (ms) */
	fastf_t		fb_time;	/* elapsed time for fb_write() (ms) */
	fastf_t		ck_time;	/* elapsed time for fb sync check (ms) */
};
#define MAX_NODES	32
struct rtnode	rtnodes[MAX_NODES];

/* Timing data */
int		finish_position;
struct timeval	frame_start;
struct timeval	t_assigned;
struct timeval	t_1st_done;
struct timeval	t_last_done;
struct timeval	t_all_done;

/* Cooked values in ms from this past frame */
fastf_t		ms_assigned;
int		ms_1st_done;
int		ms_all_done;
int		ms_flush;
int		ms_total;
fastf_t		sec_since_last;

fastf_t		ms_rt_min;		/* ms it took fastest ray-tracer */
fastf_t		ms_rt_max;		/* ms it took slowest ray-tracer */

fastf_t		ms_total_min;		/* ms it took fastest worker */
fastf_t		ms_total_max;

fastf_t		average_mbps = 0;	/* mbps */
fastf_t		burst_mbps = 0;		/* mbps -- a lower bound */
int		network_overhead = 0;	/* integer percentage */
char		last_host_done[32];	/* short ident of last host done */
double		variation;		/* slowest -vs- fastest */

static fd_set	select_list;			/* master copy */
static int	max_fd;

static	FBIO	*fbp;
static	char	*framebuffer;
static	int	width = 0;		/* use default size */
static	int	height = 0;
int		debug = 0;

/* Variables linked to Tcl/Tk */

Tcl_Interp	*interp = NULL;
Tk_Window	tkwin;

CONST char	*database;
struct bu_vls	treetops;
double		blend1 = 0.8;		/* weight to give older timing data */
int		update_status_every_frame = 0;
int		debugimage = 0;

char		*node_search_path;


BU_EXTERN(void dispatcher, (ClientData clientData));
void	new_rtnode();
void	drop_rtnode();
void	setup_socket();
char	*stamp();

BU_EXTERN(int cmd_drop_rtnode, (ClientData clientData, Tcl_Interp *interp, int argc, char **argv));


static char usage[] = "\
Usage:  rtsync [-d#] [-h] [-S squaresize] [-W width] [-N height] [-F framebuffer]\n\
	model.g treetop(s)\n\
";

/*
 *			G E T _ A R G S
 */
get_args( argc, argv )
register char **argv;
{
	register int c;

	while ( (c = getopt( argc, argv, "d:hF:s:w:n:S:W:N:" )) != EOF )  {
		switch( c )  {
		case 'd':
			debug = atoi(optarg);
			break;
		case 'h':
			/* high-res */
			height = width = 1024;
			break;
		case 'F':
			framebuffer = optarg;
			break;
		case 's':
		case 'S':
			height = width = atoi(optarg);
			break;
		case 'w':
		case 'W':
			width = atoi(optarg);
			break;
		case 'n':
		case 'N':
			height = atoi(optarg);
			break;

		default:		/* '?' */
			return(0);
		}
	}

	return(1);		/* OK */
}

/*
 *			T V D I F F
 *
 *  Return t1 - t0, as a floating-point number of seconds.
 */
double
tvdiff(t1, t0)
struct timeval	*t1, *t0;
{
	return( (t1->tv_sec - t0->tv_sec) +
		(t1->tv_usec - t0->tv_usec) / 1000000. );
}

/*
 *			L I S T _ R T N O D E S
 *
 *  Give list of valid rtnode structure indices
 */
int
list_rtnodes( clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
	int	i;

	for( i=0; i < MAX_NODES; i++ )  {
		char	buf[32];

		if( rtnodes[i].fd <= 0 )  continue;
		sprintf(buf, "%d", i);
		Tcl_AppendResult(interp, " ", buf, NULL);
	}
	return TCL_OK;
}

/*
 *			G E T _ R T N O D E
 *
 *  Print status of a given rtnode structure, for TCL script consumption.
 */
int
get_rtnode( clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
	int	i;
	struct bu_vls	str;
	CONST char	*message;

	if( argc != 2 )  {
		Tcl_AppendResult(interp, "Usage: get_rtnode ###\n", NULL);
		return TCL_ERROR;
	}
	i = atoi(argv[1]);
	if( i < 0 || i >= MAX_NODES )  {
		/* Use this as a signal to generate a title. */
		Tcl_AppendResult(interp,
			"##: CP ord i_lps w_lps lump tot=pr/rt/fb/ck state", NULL);
		return TCL_OK;
	}
	if( rtnodes[i].fd <= 0 )  {
		Tcl_AppendResult(interp, "get_rtnode ",
			argv[1], " index not assigned\n", NULL);
		return TCL_ERROR;
	}

	if( rtnodes[i].state == STATE_PREPPED )
		message = rtnodes[i].busy ? "BUSY" : "wait";
	else
		message = states[rtnodes[i].state];

	bu_vls_init(&str);
	bu_vls_printf(&str,
		"%2.2d: %2.2d %2.2d %5.5d %5.5d %4.4d %d=%d/%d/%d/%d %s %s",
		i,
		rtnodes[i].ncpus,
		rtnodes[i].finish_order,
		(int)rtnodes[i].i_lps,
		(int)rtnodes[i].w_lps,
		rtnodes[i].lump,
		(int)(rtnodes[i].time_delta * 1000),
		(int)rtnodes[i].pr_time,
		(int)rtnodes[i].rt_time,
		(int)rtnodes[i].fb_time,
		(int)rtnodes[i].ck_time,
		message,
		rtnodes[i].host->ht_name
		);
	Tcl_AppendResult(interp, bu_vls_addr(&str), NULL);
	bu_vls_free(&str);
	return TCL_OK;
}

/*
 *			N O D E _ S E N D
 *
 *  Arrange to send a string to ALL rtnode processes,
 *  for them to run as a TCL command.
 */
int
node_send( clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
	struct bu_vls	cmd;
	int		i;

	if( argc < 2 )  {
		Tcl_AppendResult(interp, "Usage: node_send command(s)\n", NULL);
		return TCL_ERROR;
	}

	bu_vls_init(&cmd);
	bu_vls_from_argv( &cmd, argc-1, argv+1 );

	bu_log("node_send: %s\n", bu_vls_addr(&cmd));

	for( i = MAX_NODES-1; i >= 0; i-- )  {
		if( rtnodes[i].fd <= 0 )  continue;
		if( rtnodes[i].ncpus <= 0 )  continue;
		if( pkg_send_vls( RTSYNCMSG_CMD, &cmd, rtnodes[i].pkg ) < 0 )  {
			drop_rtnode(i);
			continue;
		}
	}
	bu_vls_free(&cmd);
	return TCL_OK;
}

/*
 *			O N E _ N O D E _ S E N D
 *
 *  Arrange to send a string to one specific rtnode process,
 *  for it to run as a TCL command.
 *  Used primarily for debugging, or adjusting number of processors.
 */
int
one_node_send( clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
	struct bu_vls	cmd;
	int		node;

	if( argc < 3 )  {
		Tcl_AppendResult(interp, "Usage: one_node_send node# command(s)\n", NULL);
		return TCL_ERROR;
	}

	if( (node = get_rtnode_by_name(argv[1])) < 0 )  {
		Tcl_AppendResult(interp, "one_node_send ", argv[1],
			": bad node specification\n", NULL);
		return TCL_ERROR;
	}
	if( !rtnodes[node].host || !rtnodes[node].pkg ) {
		Tcl_AppendResult(interp, "one_node_send ", argv[1],
			": NULL host or pkg pointer?\n", NULL);
		return TCL_ERROR;
	}

	bu_vls_init(&cmd);
	bu_vls_from_argv( &cmd, argc-2, argv+2 );

	bu_log("one_node_send(%s) %s\n",
		rtnodes[node].host->ht_name,
		bu_vls_addr(&cmd));

	if( pkg_send_vls( RTSYNCMSG_CMD, &cmd, rtnodes[node].pkg ) < 0 )  {
		Tcl_AppendResult(interp, "pkg_send to ", argv[1], " failed.\n", NULL);
		drop_rtnode(node);
	}
	bu_vls_free(&cmd);
	return TCL_OK;
}

/*
 *			V R M G R _ H O S T N A M E
 *
 *  Returns name of VRMGR host, or null string if none.
 */
int
vrmgr_hostname( clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
	if( vrmgr_pc )  {
		Tcl_AppendResult(interp, vrmgr_ihost->ht_name, (char *)NULL);
	}
	return TCL_OK;
}

/*
 *			V R M G R _ S E N D
 *
 *  Arrange to send a string to the VRMGR process
 *  for it to run as a TCL command.
 */
int
vrmgr_send( clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
	struct bu_vls	cmd;
	char		*reply;
	int		i;

	if( argc < 2 )  {
		Tcl_AppendResult(interp, "Usage: vrmgr_send command(s)\n", NULL);
		return TCL_ERROR;
	}

	if( !vrmgr_pc )  {
		Tcl_AppendResult(interp, "vrmgr is not presently connected\n", NULL);
		return TCL_ERROR;
	}

	bu_vls_init(&cmd);
	bu_vls_from_argv( &cmd, argc-1, argv+1 );
	bu_vls_putc( &cmd, '\n');

	if( pkg_send_vls( VRMSG_CMD, &cmd, vrmgr_pc ) < 0 )  {
		pkg_close(vrmgr_pc);
		vrmgr_pc = 0;
		Tcl_AppendResult(interp, "Error writing to vrmgr\n", NULL);
		bu_vls_free(&cmd);
		return TCL_ERROR;
	}
	bu_vls_free(&cmd);

	reply = pkg_bwaitfor( VRMSG_CMD_REPLY, vrmgr_pc );
	if( !reply )  {
		Tcl_AppendResult(interp, "Error reading reply from vrmgr\n", NULL);
		return TCL_ERROR;
	}

	/* Bring across result string from other side, as our result. */
	Tcl_AppendResult( interp, reply+1, NULL );
	if( reply[0] == 'Y' )  {
		(void)free(reply);
		return TCL_OK;
	}
	(void)free(reply);
	return TCL_ERROR;
}

/*
 *			A L L _ S E N D
 *
 *  Arrange to send a string to ALL rtnode processes,
 *  and over the VGMGR link to MGED.
 *
 *  This exists as a built-in primarily to keep down the amount of traffic
 *  that Dynamic Geometry clients need to "send" to us.
 */
int
all_send( clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
	if( argc < 2 )  {
		Tcl_AppendResult(interp, "Usage: all_send command(s)\n", NULL);
		return TCL_ERROR;
	}

	(void)node_send( clientData, interp, argc, argv );
	return vrmgr_send( clientData, interp, argc, argv );
}

/*
 *			R E P R E P
 *
 *  Make all the nodes re-prep.
 */
int
reprep( clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
	int		i;
	struct bu_vls	cmd;

	if( argc != 1 )  {
		Tcl_AppendResult(interp, "Usage: reprep\n", NULL);
		return TCL_ERROR;
	}

	bu_vls_init(&cmd);
	bu_vls_strcpy( &cmd, "rt_clean");

	bu_log("reprep\n");

	for( i = MAX_NODES-1; i >= 0; i-- )  {
		if( rtnodes[i].fd <= 0 )  continue;
		if( rtnodes[i].ncpus <= 0 )  continue;
		if( rtnodes[i].state != STATE_PREPPED )  {
			Tcl_AppendResult(interp, "reprep: host ",
				rtnodes[i].host->ht_name,
				" is in state ",
				states[rtnodes[i].state],
				"\n", NULL);
			drop_rtnode(i);
			continue;
		}
		/* change back to STATE_DIRBUILT and send GETTREES commands */
		if( change_state( i, STATE_PREPPED, STATE_DIRBUILT ) < 0 )  {
			drop_rtnode(i);
			continue;
		}

		/* Receipt of GETTREES will automatically "clean" previous model first */
		if( pkg_send_vls( RTSYNCMSG_GETTREES, &treetops,
		     rtnodes[i].pkg ) < 0 )  {
			drop_rtnode(i);
		     	continue;
		}
	}
	return TCL_OK;
}

/*
 *			R E F R E S H
 *
 *  If there isn't a pending POV message, cause the last POV to be
 *  re-ray-traced.
 *  Used primarily when GUI is changing viewing parameters but POV
 *  isn't changing.
 */
int
refresh( clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
	if( pending_pov )  return TCL_OK;
	if( last_pov )  {
		pending_pov = bu_strdup( last_pov );
		return TCL_OK;
	}
	Tcl_AppendResult(interp, "refresh:  no last_pov, ignored\n", NULL);
	return TCL_ERROR;
}

/*
 *			G E T _ S T A T S
 *  Arg -
 *	-2	Get summary line rtsync stats, like what's printed per frame.
 *	-1	Get overall rtsync time-breakdown stats, in ms.
 *	0..n	Get rtnode-specific stats for indicated node.
 */
int
get_stats( clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
	int		i;
	struct bu_vls	str;

	if( argc != 2 )  {
		Tcl_AppendResult(interp, "Usage: get_stats #\n", NULL);
		return TCL_ERROR;
	}
	i = atoi(argv[1]);
	if( i >= MAX_NODES )  {
		Tcl_AppendResult(interp, "get_stats ", argv[1], " out of range\n", NULL);
		return TCL_ERROR;
	}

	if( i < 0 )  switch(i) {
	case -1:
		bu_vls_init(&str);
		/* All values reported in ms */
		bu_vls_printf(&str,
			"lag %.1f asgn %.1f 1st %d all %d flush %d total %d",
			sec_since_last * 1000,
			ms_assigned,
			ms_1st_done,
			ms_all_done,
			ms_flush,
			ms_total
		    );
		Tcl_AppendResult(interp, bu_vls_addr(&str), NULL);
		bu_vls_free(&str);
		return TCL_OK;
	case -2:
		bu_vls_init(&str);
		/* All values reported in ms */
		bu_vls_printf(&str,
			"rt_min %.1f rt_max %.1f tot_min %.1f tot_max %.1f",
			ms_rt_min,
			ms_rt_max,
			ms_total_min,
			ms_total_max
		    );
		Tcl_AppendResult(interp, bu_vls_addr(&str), NULL);
		bu_vls_free(&str);
		return TCL_OK;
	case -3:
		bu_vls_init(&str);
		/* All values reported in ms */
		bu_vls_printf(&str,
			"mbps %.1f net%% %d var %.1f last %s",
			burst_mbps,
			network_overhead,
			variation,
			last_host_done
		    );
		Tcl_AppendResult(interp, bu_vls_addr(&str), NULL);
		bu_vls_free(&str);
		return TCL_OK;
	case -4:
		bu_vls_init(&str);
		bu_vls_printf(&str,
			"rtsync %s vrmgr %s fb %s",
			get_our_hostname(),
			vrmgr_pc ? vrmgr_ihost->ht_name : "{NIL}",
			framebuffer );
		Tcl_AppendResult(interp, bu_vls_addr(&str), NULL);
		bu_vls_free(&str);
		return TCL_OK;
	case -5:
		bu_vls_init(&str);
		bu_vls_strcat(&str, database);
		bu_vls_putc(&str, ' ');
		bu_vls_vlscat(&str, &treetops);
		Tcl_AppendResult(interp, bu_vls_addr(&str), NULL);
		bu_vls_free(&str);
		return TCL_OK;
	default:
		bu_vls_free(&str);
		Tcl_AppendResult(interp, "get_stats ", argv[1], " out of range\n", NULL);
		return TCL_ERROR;
	}
	if( rtnodes[i].fd <= 0 )  {
		Tcl_AppendResult(interp, "get_stats ",
			argv[1], " index not assigned\n", NULL);
		return TCL_ERROR;
	}
	if( rtnodes[i].state != STATE_PREPPED )  {
		Tcl_AppendResult(interp, "get_stats ",
			argv[1], " not prepped yet\n", NULL);
		return TCL_ERROR;
	}

	/* Report on the indicated node */
	bu_vls_init(&str);
	bu_vls_printf(&str,
		"total %g rt %g fb %g ck %g",
		rtnodes[i].time_delta * 1000,
		rtnodes[i].rt_time,
		rtnodes[i].fb_time,
		rtnodes[i].ck_time
	    );
	Tcl_AppendResult(interp, bu_vls_addr(&str), NULL);
	bu_vls_free(&str);
	return TCL_OK;
}

/**********************************************************************/

/*
 *			S T D I N _ E V E N T _ H A N D L E R
 *
 *  Read Tcl commands from a "tty" file descriptor.
 *  Called from the TCL/Tk event handler
 */
void
stdin_event_handler(clientData, mask)
ClientData	clientData;	/* fd */
int		mask;
{
	char	buf[511+1];
	int	fd;
	int	got;

	fd = (int)clientData;

	got = read(fd, buf, 511);
	if( got >= 0 && got < 511 )  buf[got] = '\0';
	else	buf[0] = '\0';

	if( got <= 0 )  {
		bu_log("EOF on stdin\n");
		Tcl_DeleteFileHandler( fd );
		return;
	}

	/* Do something here.  Eventually, feed off to Tcl interp. */
	if( Tcl_Eval( interp, buf ) == TCL_OK )  {
		bu_log("%s\n", interp->result);

		Tcl_DoWhenIdle( dispatcher, (ClientData)0 );
	} else {
		bu_log("ERROR %s\n", interp->result);
	}
}

/*
 *			P K G _ E V E N T _ H A N D L E R
 *
 *  Generic event handler to read from a LIBPKG connection.
 *  Called from the TCL/Tk event handler
 */
void
pkg_event_handler(clientData, mask)
ClientData	clientData;	/* *pc */
int		mask;
{
	struct pkg_conn	*pc;
	int	val;

	pc = (struct pkg_conn *)clientData;

	val = pkg_suckin(pc);
	if( val < 0 ) {
		bu_log("pkg_suckin() error\n");
	} else if( val == 0 )  {
		bu_log("EOF on pkg connection\n");
	}
	if( val <= 0 )  {
		Tcl_DeleteFileHandler( pc->pkc_fd );
		pkg_close(pc);
		return;
	}
	if( pkg_process( pc ) < 0 )
		bu_log("pc:  pkg_process error encountered\n");

	Tcl_DoWhenIdle( dispatcher, (ClientData)0 );
}

/*
 *			V R M G R _ E V E N T _ H A N D L E R
 *
 *  Event handler to read VRMGR commands from a LIBPKG connection.
 *  Called from the TCL/Tk event handler.
 */
void
vrmgr_event_handler(clientData, mask)
ClientData	clientData;	/* *pc */
int		mask;
{
	struct pkg_conn	*pc;
	int	val;

	pc = (struct pkg_conn *)clientData;

	val = pkg_suckin(pc);
	if( val < 0 ) {
		bu_log("vrmgr: pkg_suckin() error\n");
	} else if( val == 0 )  {
		bu_log("vrmgr: EOF on pkg connection\n");
	}
	if( val <= 0 )  {
		Tcl_DeleteFileHandler( pc->pkc_fd );
		pkg_close(pc);
		vrmgr_pc = 0;
		vrmgr_ihost = IHOST_NULL;
		return;
	}
	if( pkg_process( pc ) < 0 )
		bu_log("vrmgr:  pkg_process error encountered\n");

	Tcl_DoWhenIdle( dispatcher, (ClientData)0 );
}

/*
 *			R T N O D E _ E V E N T _ H A N D L E R
 *
 *  Read from a LIBPKG connection associated with an rtnode.
 *  Called from the TCL/Tk event handler
 */
void
rtnode_event_handler(clientData, mask)
ClientData	clientData;	/* subscript to rtnodes[] */
int		mask;
{
	int	i;

	i = (int)clientData;
	if( rtnodes[i].fd == 0 )  {
		bu_log("rtnode_event_handler(%d) no fd?\n", i);
		return;
	}
	if( pkg_process( rtnodes[i].pkg ) < 0 ) {
		bu_log("pkg_process error encountered (1)\n");
	}
	if( pkg_suckin( rtnodes[i].pkg ) <= 0 )  {
		/* Probably EOF */
		drop_rtnode( i );
		return;
	}
	if( pkg_process( rtnodes[i].pkg ) < 0 ) {
		bu_log("pkg_process error encountered (2)\n");
	}

	Tcl_DoWhenIdle( dispatcher, (ClientData)0 );
}

/*
 *			F B _ E V E N T _ H A N D L E R
 */
void
fb_event_handler(clientData, mask)
ClientData	clientData;	/* FBIO * */
int		mask;
{
	FBIO	*fbp;
bu_log("fb_event_handler() called\n");

	fbp = (FBIO *)clientData;
	fb_poll(fbp);

	Tcl_DoWhenIdle( dispatcher, (ClientData)0 );
}

/*
 *			V R M G R _ L I S T E N _ H A N D L E R
 */
void
vrmgr_listen_handler(clientData, mask)
ClientData	clientData;	/* fd */
int		mask;
{

	/* Accept any new VRMGR connections.  Only one at a time is permitted. */
	if( vrmgr_pc )  {
		bu_log("New VRMGR connection received with one still active, dropping old one.\n");
		Tcl_DeleteFileHandler( vrmgr_pc->pkc_fd );
		pkg_close( vrmgr_pc );
		vrmgr_pc = 0;
		vrmgr_ihost = IHOST_NULL;
	}
	vrmgr_pc = pkg_getclient( vrmgr_listen_fd, vrmgr_pkgswitch, bu_log, 0 );
	vrmgr_ihost = host_lookup_of_fd(vrmgr_pc->pkc_fd);
	if( vrmgr_ihost == IHOST_NULL )  {
		bu_log("Unable to get hostname of VRMGR, abandoning it\n");
		pkg_close( vrmgr_pc );
		vrmgr_pc = 0;
	} else {
		bu_log("%s VRMGR link with %s, fd=%d\n",
			stamp(),
			vrmgr_ihost->ht_name, vrmgr_pc->pkc_fd);
		Tcl_CreateFileHandler(
			vrmgr_pc->pkc_fd,
			TCL_READABLE|TCL_EXCEPTION, vrmgr_event_handler,
			(ClientData)vrmgr_pc );
		FD_SET(vrmgr_pc->pkc_fd, &select_list);
		if( vrmgr_pc->pkc_fd > max_fd )  max_fd = vrmgr_pc->pkc_fd;
		setup_socket( vrmgr_pc->pkc_fd );
	}

	Tcl_DoWhenIdle( dispatcher, (ClientData)0 );
}

/*
 *			R T S Y N C _ L I S T E N _ H A N D L E R
 */
void
rtsync_listen_handler(clientData, mask)
ClientData	clientData;	/* fd */
int		mask;
{
	new_rtnode( pkg_getclient( (int)clientData,
		rtsync_pkgswitch, bu_log, 0 ) );

	Tcl_DoWhenIdle( dispatcher, (ClientData)0 );
}

/**********************************************************************/

/*
 *			M A I N
 */
main(argc, argv)
int	argc;
char	*argv[];
{
	width = height = 256;	/* keep it modest, by default */

	if ( !get_args( argc, argv ) ) {
		(void)fputs(usage, stderr);
		exit( 1 );
	}

	if( optind >= argc )  {
		fprintf(stderr,"rtsync:  MGED database not specified\n");
		(void)fputs(usage, stderr);
		exit(1);
	}
	database = argv[optind++];
	if( optind >= argc )  {
		fprintf(stderr,"rtsync:  tree top(s) not specified\n");
		(void)fputs(usage, stderr);
		exit(1);
	}

	bu_vls_init( &treetops );
	bu_vls_from_argv( &treetops, argc - optind, argv+optind );
	bu_log("DB: %s %s\n", database, bu_vls_addr(&treetops) );

	BU_LIST_INIT( &rt_g.rtg_vlfree );

	/* Initialize the Tcl interpreter */
	interp = Tcl_CreateInterp();

	/* This runs the init.tcl script */
	if( Tcl_Init(interp) == TCL_ERROR )
		bu_log("Tcl_Init error %s\n", interp->result);
	bu_tcl_setup(interp);
	bn_tcl_setup(interp);
	rt_tcl_setup(interp);
	Tcl_SetVar(interp, "cpu_count", "0", TCL_GLOBAL_ONLY );
	/* Don't allow unknown commands to be fed to the shell */
	Tcl_SetVar( interp, "tcl_interactive", "0", TCL_GLOBAL_ONLY );

	Tcl_LinkVar( interp, "framebuffer", (char *)&framebuffer, TCL_LINK_STRING | TCL_LINK_READ_ONLY );
	Tcl_LinkVar( interp, "database", (char *)&database, TCL_LINK_STRING | TCL_LINK_READ_ONLY );
	Tcl_LinkVar( interp, "debug", (char *)&debug, TCL_LINK_INT );
	Tcl_LinkVar( interp, "debugimage", (char *)&debugimage, TCL_LINK_INT );
	Tcl_LinkVar( interp, "update_status_every_frame", (char *)&update_status_every_frame, TCL_LINK_INT );
	Tcl_LinkVar( interp, "blend1", (char *)&blend1, TCL_LINK_DOUBLE );

	/* This string may be supplemented by the Tcl runtime */
	Tcl_LinkVar( interp, "node_search_path", (char *)&node_search_path, TCL_LINK_STRING );
	Tcl_SetVar( interp, "node_search_path",
"/m/cad /m/cad/db /n/vapor/m/cad /n/vapor/m/cad/db \
~mike ~mike/db ~mike/cad/db ~butler ~butler/cad/db \
/home/army/mike/SGI/cad /var/tmp /tmp",
		TCL_GLOBAL_ONLY );

	/* This runs the tk.tcl script */
	if(Tk_Init(interp) == TCL_ERROR)  bu_bomb("Try setting TK_LIBRARY environment variable\n");
	if((tkwin = Tk_MainWindow(interp)) == NULL)
		bu_bomb("Tk_MainWindow failed\n");
	/* Don't insist on a click to position the window, just make it */
	(void)Tcl_Eval( interp, "wm geometry . =+1+1");

	/* Incorporate built-in commands.  BEFORE running script. */
	(void)Tcl_CreateCommand(interp, "all_send", all_send,
		(ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);
	(void)Tcl_CreateCommand(interp, "vrmgr_hostname", vrmgr_hostname,
		(ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);
	(void)Tcl_CreateCommand(interp, "vrmgr_send", vrmgr_send,
		(ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);
	(void)Tcl_CreateCommand(interp, "node_send", node_send,
		(ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);
	(void)Tcl_CreateCommand(interp, "one_node_send", one_node_send,
		(ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);
	(void)Tcl_CreateCommand(interp, "reprep", reprep,
		(ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);
	(void)Tcl_CreateCommand(interp, "refresh", refresh,
		(ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);
	(void)Tcl_CreateCommand(interp, "get_stats", get_stats,
		(ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);
	(void)Tcl_CreateCommand(interp, "list_rtnodes", list_rtnodes,
		(ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);
	(void)Tcl_CreateCommand(interp, "get_rtnode", get_rtnode,
		(ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);
	(void)Tcl_CreateCommand(interp, "drop_rtnode", cmd_drop_rtnode,
		(ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);

	/* Let main window pop up before running script */
	while( Tcl_DoOneEvent(TCL_DONT_WAIT) != 0 ) ;
# if 0
	(void)Tcl_Eval( interp, "wm withdraw .");
# endif
	if( Tcl_EvalFile( interp, "/m/cad/remrt/rtsync.tcl" ) != TCL_OK )  {
		bu_log("%s\n",
			Tcl_GetVar(interp,"errorInfo", TCL_GLOBAL_ONLY) );
		bu_log("\n*** rtsync.tcl Startup Script Aborted ***\n\n");
	}

	/* Accept commands on stdin */
	if( isatty(fileno(stdin)) )  {
		Tcl_CreateFileHandler(
			fileno(stdin),
			TCL_READABLE|TCL_EXCEPTION, stdin_event_handler,
			(ClientData)fileno(stdin) );
		bu_log("rtsync accepting commands on stdin\n");
	}


	/* Connect up with framebuffer, for control & size purposes */
	if( !framebuffer )  framebuffer = getenv("FB_FILE");
	if( !framebuffer )  rt_bomb("rtsync:  No -F and $FB_FILE not set\n");
	if( (fbp = fb_open(framebuffer, width, height)) == FBIO_NULL )
		exit(1);

	if( width <= 0 || fb_getwidth(fbp) < width )
		width = fb_getwidth(fbp);
	if( height <= 0 || fb_getheight(fbp) < height )
		height = fb_getheight(fbp);

	{
		unsigned char	flash[4];
		flash[0] = 224;
		flash[1] = 255;
		flash[2] = 224;
		(void)fb_clear(fbp, flash);
		(void)fb_flush(fbp);
	}

	/* Listen for VRMGR Master PKG connections from MGED */
	if( (vrmgr_listen_fd = pkg_permserver("5555", "tcp", 8, bu_log)) < 0 )  {
		bu_log("Unable to listen on 5555\n");
		exit(1);
	}
	Tcl_CreateFileHandler(
		vrmgr_listen_fd,
		TCL_READABLE|TCL_EXCEPTION, vrmgr_listen_handler,
		(ClientData)vrmgr_listen_fd);

	/* Listen for our RTSYNC client's PKG connections */
	if( (rtsync_listen_fd = pkg_permserver("rtsrv", "tcp", 8, bu_log)) < 0 )  {
		int	i;
		char	num[8];
		/* Do it by the numbers */
		for(i=0; i<10; i++ )  {
			sprintf( num, "%d", 4446+i );
			if( (rtsync_listen_fd = pkg_permserver(num, "tcp", 8, bu_log)) < 0 )
				continue;
			break;
		}
		if( i >= 10 )  {
			bu_log("Unable to find a port to listen on\n");
			exit(1);
		}
	}
	Tcl_CreateFileHandler(
		rtsync_listen_fd,
		TCL_READABLE|TCL_EXCEPTION, rtsync_listen_handler,
		(ClientData)rtsync_listen_fd);
	/* Now, pkg_permport has tcp port number */
	bu_log("%s RTSYNC listening on %s port %d\n",
		stamp(),
		get_our_hostname(),
		pkg_permport);

	(void)signal( SIGPIPE, SIG_IGN );

	if( fbp && fbp->if_selfd > 0 )  {
		Tcl_CreateFileHandler(
			fbp->if_selfd,
			TCL_READABLE|TCL_EXCEPTION, fb_event_handler,
			(ClientData)fbp );
	}

	Tcl_DoWhenIdle( dispatcher, (ClientData)0 );

	for(;;)  {
		Tcl_DoOneEvent(0);
	}
}

/*
 *			D I S P A T C H E R
 *
 *  Where all the work gets sent out.
 *  
 *  This is only called once and then evaporates;
 *  the event-handlers are responsible for queueing up more when
 *  something might have happened, with:
 *	Tcl_DoWhenIdle( dispatcher, (ClientData)0 );
 */
void
dispatcher(clientData)
ClientData clientData;
{
	register int	i;
	int		cpu_count = 0;
	int		start_line;
	int		lowest_index = 0;
	char		buf[32];
	double		total_lps;
	int		nlines;

	if( !pending_pov )  return;

	cpu_count = 0;
	for( i = MAX_NODES-1; i >= 0; i-- )  {
		if( rtnodes[i].fd <= 0 )  continue;
		if( rtnodes[i].state != STATE_PREPPED )  continue;
		if( rtnodes[i].ncpus <= 0 )  continue;
		if( rtnodes[i].busy )  return;	/* Still working on last one */
		cpu_count += rtnodes[i].ncpus;
		lowest_index = i;
	}
	if( debug )  {
		bu_log("%s dispatcher() has %d cpus\n", stamp(), cpu_count);
	}
	sprintf(buf, "%d", cpu_count);
	Tcl_SetVar(interp, "cpu_count", buf, TCL_GLOBAL_ONLY );
	if( cpu_count <= 0 )  return;

	/* Record starting time for this frame */
	(void)gettimeofday( &frame_start, (struct timezone *)NULL );
	finish_position = 0;

	/* Determine how long it's been since end of last frame */
	sec_since_last = tvdiff( &frame_start, &t_all_done );

	/* Keep track of the POV used for this assignment.  For refresh. */
	if( last_pov )  {
		bu_free( last_pov, "last POV pkg" );
		last_pov = NULL;
	}
	last_pov = pending_pov;
	pending_pov = NULL;

	/* We have some CPUS! Parcel up 'height' scanlines. */
	/*
	 *  First, tally up the measurements of the weighted lines/sec
	 *  to determine total compute capability.
	 */
	total_lps = 0;
	for( i = MAX_NODES-1; i >= 0; i-- )  {
		if( rtnodes[i].fd <= 0 )  continue;
		if( rtnodes[i].state != STATE_PREPPED )  continue;
		total_lps += rtnodes[i].w_lps;
	}

	/* Second, allocate work as a fraction of that capability */
	nlines = 0;
	for( i = MAX_NODES-1; i >= 0; i-- )  {
		if( rtnodes[i].fd <= 0 )  continue;
		if( rtnodes[i].state != STATE_PREPPED )  continue;
		rtnodes[i].lump = (int)ceil(height * rtnodes[i].w_lps / total_lps);
		nlines += rtnodes[i].lump;
	}
	if( nlines < height )  bu_log("ERROR: nlines=%d, height=%d\n", nlines, height);

	/* Third, actually dispatch the work */
	start_line = 0;
	for( i = MAX_NODES-1; i >= 0; i-- )  {
		int	end_line;
		struct bu_vls	msg;

		if( start_line >= height )  break;
		if( rtnodes[i].fd <= 0 )  continue;
		if( rtnodes[i].state != STATE_PREPPED )  continue;

		end_line = start_line + rtnodes[i].lump-1;
		if( end_line > height-1 )  end_line = height-1;

		bu_vls_init( &msg );
		bu_vls_printf( &msg, "%d %d %d %s\n",
			256,
			start_line, end_line,
			last_pov+4 );
		if( pkg_send_vls( RTSYNCMSG_POV, &msg, rtnodes[i].pkg ) < 0 )  {
			drop_rtnode( i );
			bu_vls_free(&msg);
			continue;	/* Don't update start_line */
		}
		(void)gettimeofday( &rtnodes[i].time_start, (struct timezone *)NULL );
		if( debug )
			bu_log("%s sending %d..%d to %s\n", stamp(), start_line, end_line, rtnodes[i].host->ht_name);

		bu_vls_free(&msg);
		rtnodes[i].busy = 1;
		start_line = end_line + 1;
	}
	/* Record time that all assignments went out */
	(void)gettimeofday( &t_assigned, (struct timezone *)NULL );
}

/*
 *			N E W _ R T N O D E
 */
void
new_rtnode(pcp)
struct pkg_conn	*pcp;
{
	register int	i;
	struct ihost	*host;

	if( pcp == PKC_ERROR )
		return;

	if( !(host = host_lookup_of_fd(pcp->pkc_fd)) )  {
		bu_log("%s Unable to get host name of new connection, dropping\n", stamp() );
		pkg_close(pcp);
		return;
	}
	bu_log("%s Connection from %s\n", stamp(), host->ht_name);

	/* Make this scan go low-to-high, so that new machines get
	 * added in on the bottom.
	 * Since new work is allocated bottom-to-top, it makes sure
	 * new machines get a change to have their speed measured.
	 */
	for( i=0; i < MAX_NODES; i++ )  {
		if( rtnodes[i].fd != 0 )  continue;
		/* Found an available slot */
		bzero( (char *)&rtnodes[i], sizeof(rtnodes[0]) );
		rtnodes[i].state = STATE_NEWBORN;
		rtnodes[i].pkg = pcp;
		rtnodes[i].fd = pcp->pkc_fd;
		FD_SET(pcp->pkc_fd, &select_list);
		if( pcp->pkc_fd > max_fd )  max_fd = pcp->pkc_fd;
		setup_socket( pcp->pkc_fd );
		rtnodes[i].host = host;
		Tcl_CreateFileHandler(
			pcp->pkc_fd,
			TCL_READABLE|TCL_EXCEPTION, rtnode_event_handler,
			(ClientData)i );
		return;
	}
	bu_log("rtsync: too many rtnode clients.  My cup runneth over!\n");
	pkg_close(pcp);
}

/*
 *			D R O P _ R T N O D E
 */
void
drop_rtnode( sub )
int	sub;
{
	bu_log("%s Dropping %s\n", stamp(), rtnodes[sub].host->ht_name);

	if( rtnodes[sub].pkg != PKC_NULL )  {
		Tcl_DeleteFileHandler( rtnodes[sub].pkg->pkc_fd );
		pkg_close( rtnodes[sub].pkg );
		rtnodes[sub].pkg = PKC_NULL;
	}
	if( rtnodes[sub].fd != 0 )  {
		FD_CLR( rtnodes[sub].fd, &select_list );
		(void)close( rtnodes[sub].fd );
		rtnodes[sub].fd = 0;
	}

	Tcl_Eval( interp, "update_cpu_status" );
}

/*
 *			G E T _ R T N O D E _ B Y _ N A M E
 *
 *  Accepts hostname, or numeric table index.
 */
int
get_rtnode_by_name( str )
char *str;
{
	struct ihost	*ihp;
	int		i;

	if( isdigit( *str ) )  {
		int	i;
		i = atoi( str );
		if( i < 0 || i >= MAX_NODES )  return -1;
		if( rtnodes[i].fd <= 0 )  return -4;
		return i;
	}

	if( (ihp = host_lookup_by_name( str, 0 )) == IHOST_NULL )
		return -2;

	for( i = MAX_NODES-1; i >= 0; i-- )  {
		if( rtnodes[i].fd <= 0 )  continue;
		if( rtnodes[i].host == ihp )  return i;
	}
	return -3;
}

/*
 *			C M D  _ D R O P _ R T N O D E
 */
int
cmd_drop_rtnode( clientData, interp, argc, argv )
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
	int	node;

	if( argc != 2 )  {
		Tcl_AppendResult(interp, "Usage: drop_rtnode hostname\n        drop_rtnode slot#\n", NULL);
		return TCL_ERROR;
	}
	node = get_rtnode_by_name( argv[1] );
	if( node < 0 )  {
		Tcl_AppendResult(interp, "drop_rtnode ", argv[1],
			": server not found\n");
		return TCL_ERROR;
	}
	drop_rtnode(node);
	return TCL_OK;
}

/*
 *			S E T U P _ S O C K E T
 */
void
setup_socket(fd)
int	fd;
{
	int	on = 1;

#if defined(SO_KEEPALIVE)
	if( setsockopt( fd, SOL_SOCKET, SO_KEEPALIVE, (char *)&on, sizeof(on)) < 0 ) {
		perror( "setsockopt (SO_KEEPALIVE)");
	}
#endif
#if defined(SO_RCVBUF)
	/* try to set our buffers up larger */
	{
		int	m, n;
		int	val;
		int	size;

		for( size = 256; size > 16; size /= 2 )  {
			val = size * 1024;
			m = setsockopt( fd, SOL_SOCKET, SO_RCVBUF,
				(char *)&val, sizeof(val) );
			val = size * 1024;
			n = setsockopt( fd, SOL_SOCKET, SO_SNDBUF,
				(char *)&val, sizeof(val) );
			if( m >= 0 && n >= 0 )  break;
		}
		if( m < 0 || n < 0 )  perror("rtsync setsockopt()");
	}
#endif
}

/*
 *			C H A N G E _ S T A T E
 */
int
change_state( i, old, new )
int	i;
int	old;
int	new;
{
	bu_log("%s %s %s --> %s\n", stamp(),
		rtnodes[i].host->ht_name,
		states[rtnodes[i].state], states[new] );
	if( rtnodes[i].state != old )  {
		bu_log("%s was in state %s, should have been %s, dropping\n",
			rtnodes[i].host->ht_name,
			states[rtnodes[i].state], states[old] );
		drop_rtnode(i);
		return -1;
	}
	rtnodes[i].state = new;

	Tcl_Eval( interp, "update_cpu_status" );

	return 0;
}

/*
 *			V R M G R _ P H _ R O L E
 *
 *  The ROLE package should be the first thing that MGED says to
 *  the VRMGR (i.e. to us).
 *  There is no need to strictly check the protocol;
 *  if we get a ROLE package, it better be of type "master".
 *  If no ROLE package is sent, no big deal.
 */
void
vrmgr_ph_role(pc, buf)
register struct pkg_conn *pc;
char			*buf;
{
#define MAXARGS 32
	char		*argv[MAXARGS];
	int		argc;

	bu_log("%s VRMGR host %s, role %s\n",
		stamp(),
		vrmgr_ihost->ht_name, buf);

	argc = rt_split_cmd( argv, MAXARGS, buf );
	if( argc < 1 )  {
		bu_log("bad role command\n");
	}

	if( strcmp( argv[0], "master" ) != 0 )  {
		bu_log("ERROR %s: bad role '%s', dropping vrmgr\n",
			vrmgr_ihost->ht_name, buf );
		FD_CLR(vrmgr_pc->pkc_fd, &select_list);
		pkg_close( vrmgr_pc );
		vrmgr_pc = 0;
		vrmgr_ihost = 0;
	}

	Tcl_Eval( interp, "update_cpu_status" );

	if(buf) (void)free(buf);
}

/*
 *			V R M G R _ P H _ E V E N T
 *
 *  These are from slave MGEDs for relay to the master MGED.
 *  We don't expect any of these.
 */
void
vrmgr_ph_event(pc, buf)
register struct pkg_conn *pc;
char			*buf;
{
	register struct servers	*sp;

	bu_log("%s VRMGR unexpectely got event '%s'", stamp(), buf );
	if( buf )  free(buf);
}

/*
 *			V R M G R _ P H _ P O V
 *
 *  Accept a new point-of-view from the MGED master.
 *  If there is an existing POV which has not yet been rendered,
 *  drop it, and use the new one instead, to catch up.
 *
 *  We retain the buffer from LIBPKG until the POV is processed.
 */
void
vrmgr_ph_pov(pc, buf)
register struct pkg_conn *pc;
char			*buf;
{
	if( debug )  bu_log("%s %s\n", stamp(), buf);
	if( pending_pov )  free(pending_pov);
	pending_pov = buf;
}

/*
 *			P H _ D E F A U L T
 */
void
ph_default(pc, buf)
register struct pkg_conn *pc;
char *buf;
{
	register int i;

	for( i=0; pc->pkc_switch[i].pks_handler != NULL; i++ )  {
		if( pc->pkc_switch[i].pks_type == pc->pkc_type )  break;
	}
	bu_log("rtsync: unable to handle %s message: len %d",
		pc->pkc_switch[i].pks_title, pc->pkc_len);
	*buf = '*';
	if( buf )  free(buf);
}

/*
 *			R T S Y N C _ P H _ A L I V E
 */
void
rtsync_ph_alive(pc, buf)
register struct pkg_conn *pc;
char			*buf;
{
	register int	i;
	int		ncpu;
	struct bu_vls	cmd;

	ncpu = atoi(buf);
	if( buf )  free(buf);

	for( i = MAX_NODES-1; i >= 0; i-- )  {
		if( rtnodes[i].pkg != pc )  continue;

		/* Found it */
		bu_log("%s %s ALIVE %d cpus\n", stamp(),
			rtnodes[i].host->ht_name,
			ncpu );

		rtnodes[i].ncpus = ncpu;

		if( change_state( i, STATE_NEWBORN, STATE_ALIVE ) < 0 )
			return;

		bu_vls_init( &cmd );

		/* Send across some initial state, via TCL commands. */
		bu_vls_printf( &cmd, "set node_search_path {%s}\n",
			node_search_path );
		if( pkg_send_vls( RTSYNCMSG_CMD, &cmd, rtnodes[i].pkg ) < 0 )  {
			drop_rtnode(i);
			continue;
		}

		/* Now try to get framebuffer open.  Reply message advances state, later. */
		bu_vls_trunc( &cmd, 0 );
		bu_vls_printf( &cmd, "%d %d %s", width, height, framebuffer );

		if( pkg_send_vls( RTSYNCMSG_OPENFB, &cmd, rtnodes[i].pkg ) < 0 )  {
			bu_vls_free( &cmd );
			drop_rtnode(i);
		     	return;
		}
		bu_vls_free( &cmd );
		return;
	}
	rt_bomb("ALIVE Message received from phantom pkg?\n");
}

/*
 *			R T S Y N C _ P H _ O P E N F B
 */
void
rtsync_ph_openfb(pc, buf)
register struct pkg_conn *pc;
char			*buf;
{
	register int	i;
	int		ncpu;

	if( buf )  free(buf);

	for( i = MAX_NODES-1; i >= 0; i-- )  {
		if( rtnodes[i].pkg != pc )  continue;

		/* Found it */
		if( change_state( i, STATE_ALIVE, STATE_OPENFB ) < 0 )
			return;

		if( pkg_send( RTSYNCMSG_DIRBUILD, database, strlen(database)+1,
		     rtnodes[i].pkg ) < 0 )  {
			drop_rtnode(i);
		     	return;
		}
		return;
	}
	rt_bomb("OPENFB Message received from phantom pkg?\n");
}

/*
 *			R T S Y N C _ P H _ D I R B U I L D
 *
 *  Reply contains database title string.
 */
void
rtsync_ph_dirbuild(pc, buf)
register struct pkg_conn *pc;
char			*buf;
{
	register int	i;
	int		ncpu;

	for( i = MAX_NODES-1; i >= 0; i-- )  {
		if( rtnodes[i].pkg != pc )  continue;

		/* Found it */
		bu_log("%s %s %s\n", stamp(),
			rtnodes[i].host->ht_name, buf );
		if( buf )  free(buf);

		if( change_state( i, STATE_OPENFB, STATE_DIRBUILT ) < 0 )
			return;

		if( pkg_send_vls( RTSYNCMSG_GETTREES, &treetops,
		     rtnodes[i].pkg ) < 0 )  {
			drop_rtnode(i);
		     	return;
		}
		return;
	}
	rt_bomb("DIRBUILD Message received from phantom pkg?\n");
}

/*
 *			R T S Y N C _ P H _ G E T T R E E S
 *
 *  Reply contains name of first treetop.
 */
void
rtsync_ph_gettrees(pc, buf)
register struct pkg_conn *pc;
char			*buf;
{
	register int	i;
	int		ncpu;

	for( i = MAX_NODES-1; i >= 0; i-- )  {
		if( rtnodes[i].pkg != pc )  continue;

		/* Found it */
		bu_log("%s %s %s\n", stamp(),
			rtnodes[i].host->ht_name, buf );
		if( buf )  free(buf);

		if( change_state( i, STATE_DIRBUILT, STATE_PREPPED ) < 0 )
			return;

		/* Initialize some key variables */
		rtnodes[i].busy = 0;
		rtnodes[i].lump = 0;
		rtnodes[i].w_lps = 1;

		/* No more dialog, next pkg will be a POV */

		return;
	}
	rt_bomb("GETTREES Message received from phantom pkg?\n");
}

/*
 *			R T S Y N C _ P H _ D O N E
 *
 *  This message indicates that RTNODE has successfully sent
 *  all it's pixels to the screen.
 */
void
rtsync_ph_done(pc, buf)
register struct pkg_conn *pc;
char			*buf;
{
	register int	i;
	struct timeval	time_end;
	double		interval;
	double		blend2;
	int		new_npsw;
	double		t1, t2, t3, t4;
	int		nfields;
	int		sched_update = 0;
	int		last_i;
	int		reproj_percent;
	long		total_bits;
	double		ms_nonnet_min, ms_nonnet_max;

	blend2 = 1 - blend1;	/* blend1 may change via Tcl interface */

	for( i = MAX_NODES-1; i >= 0; i-- )  {
		if( rtnodes[i].pkg != pc )  continue;

		/* Found it */
		(void)gettimeofday( &time_end, (struct timezone *)NULL );
		interval = tvdiff( &time_end, &rtnodes[i].time_start );
		if( interval <= 0 )  interval = 999;
		rtnodes[i].i_lps = rtnodes[i].lump / interval;
		rtnodes[i].w_lps = blend1 * rtnodes[i].w_lps +
				   blend2 * rtnodes[i].i_lps;
		rtnodes[i].time_delta = interval;

		rtnodes[i].finish_order = ++finish_position;
		if( finish_position == 1 )  {
			t_1st_done = time_end;	/* struct copy */
		}

		new_npsw = -1;
		t1 = t2 = t3 = -1;
		nfields = sscanf(buf, "%d %lf %lf %lf %lf %d",
			&new_npsw, &t1, &t2, &t3, &t4, &reproj_percent );

		if( nfields < 1 )  {
			bu_log(" %s %s reply message had insufficient (%d) fields\n",
				stamp(), rtnodes[i].host->ht_name,
				nfields);
		}

		if( nfields >= 1 && rtnodes[i].ncpus != new_npsw )  {
			bu_log(" %s %s NCPUs changed from %d to %d\n",
				stamp(), rtnodes[i].host->ht_name,
				rtnodes[i].ncpus, new_npsw);
			rtnodes[i].ncpus = new_npsw;
			sched_update = 1;
		}

		rtnodes[i].pr_time = t1;
		rtnodes[i].rt_time = t2;
		rtnodes[i].fb_time = t3;
		rtnodes[i].ck_time = t4;
		rtnodes[i].pr_percent = reproj_percent;

		if( debug )  {
			bu_log("%s DONE %s (%g ms) rt=%g fb=%g ck=%g buf=%s\n",
				stamp(),
				rtnodes[i].host->ht_name,
				interval * 1000.0,
				t1, t2, t3, buf
				);
		}
		rtnodes[i].busy = 0;
		last_i = i;
		if( buf )  free(buf);
		goto check_others;
	}
	rt_bomb("DONE Message received from phantom pkg?\n");

check_others:
	for( i = MAX_NODES-1; i >= 0; i-- )  {
		if( rtnodes[i].fd <= 0 )  continue;
		if( rtnodes[i].state != STATE_PREPPED )  continue;
		if( rtnodes[i].ncpus <= 0 )  continue;
		if( rtnodes[i].busy )  return;	/* Still working on last one */
	}

	/*
	 *  Frame is entirely done, this was the last assignemnt outstanding.
	 */
	strncpy( last_host_done, rtnodes[last_i].host->ht_name, 6 );
	last_host_done[6] = '\0';
	
	/* Record time that final assignment came back */
	(void)gettimeofday( &t_last_done, (struct timezone *)NULL );

	/* This frame is now done, flush to screen */
	fb_flush(fbp);
	(void)gettimeofday( &t_all_done, (struct timezone *)NULL );

	/* Compute total time for this frame */
	ms_assigned = tvdiff( &t_assigned, &frame_start ) * 1000;
	ms_1st_done = tvdiff( &t_1st_done, &frame_start ) * 1000;
	ms_all_done = tvdiff( &t_last_done, &frame_start ) * 1000;
	ms_flush = tvdiff( &t_all_done, &t_last_done ) * 1000;
	interval = tvdiff( &t_all_done, &frame_start );
	if( interval <= 0 )  interval = 999;
	ms_total = interval * 1000;

	/* Find max and min of ray-tracing time */
	ms_rt_min =  9999999;
	ms_rt_max = -9999999;
	ms_nonnet_min =  9999999;
	ms_nonnet_max = -9999999;
	ms_total_min =  9999999;
	ms_total_max = -9999999;
	for( i = MAX_NODES-1; i >= 0; i-- )  {
		double		rtt;
		double		tot;
		double		nonnet;

		if( rtnodes[i].state != STATE_PREPPED )  continue;
		if( rtnodes[i].ncpus <= 0 )  continue;

		rtt = rtnodes[i].rt_time;
		if( rtt < ms_rt_min )  ms_rt_min = rtt;
		if( rtt > ms_rt_max )  ms_rt_max = rtt;

		nonnet = rtt + rtnodes[i].pr_time;
		if( nonnet < ms_nonnet_min )  ms_nonnet_min = nonnet;
		if( nonnet > ms_nonnet_max )  ms_nonnet_max = nonnet;

		tot = rtnodes[i].time_delta * 1000;
if( tot <= 0 )  bu_log("tot = %e for %s\n", tot, rtnodes[i].host->ht_name);
		if( tot < ms_total_min )  ms_total_min = tot;
		if( tot > ms_total_max )  ms_total_max = tot;
	}

	/* Calculate network bandwidth consumed in non-raytracing time */
	total_bits = width * height * 3 * 8;
	if( debugimage )  total_bits *= 2;
	average_mbps = total_bits / interval / 1000000.0;
	/* burst_mbps is still too low; it's a lower bound. */
	burst_mbps = total_bits / (interval - ms_rt_min/1000) / 1000000.0;

	/* Calculate "network overhead" as % of total time */
	network_overhead = (int)(((double)ms_total - ms_nonnet_max) /
		(double)ms_total * 100);

	/* Calculate assignment duration variation. 1X is optimum. */
	variation = ms_total_max / ms_total_min;

	bu_log("%s%6d ms, %5.1f Mbps, %4.1f fps, %2d%%net %.1fx %s%s\n",
		stamp(),
		ms_total,
		burst_mbps,
		1.0/interval,
		network_overhead,
		variation,
		variation >= 2 ? "***> " : "",
		last_host_done
	    );

	/* Trigger TCL code to auto-update cpu status window on major changes */
	if( sched_update || update_status_every_frame )
		Tcl_Eval( interp, "update_cpu_status" );
}

/*
 *			S T A M P
 *
 *  Return a string suitable for use as a timestamp.
 *  Mostly for stamping log messages with.
 */
char *
stamp()
{
	static char	buf[128];
	time_t		now;
	struct tm	*tmp;
	register char	*cp;

	(void)time( &now );
	tmp = localtime( &now );
	sprintf( buf, "%2.2d/%2.2d %2.2d:%2.2d:%2.2d",
		tmp->tm_mon+1, tmp->tm_mday,
		tmp->tm_hour, tmp->tm_min, tmp->tm_sec );

	return(buf);
}

/*
 *			P H _ P R I N T
 */
void
ph_print(pc, buf)
register struct pkg_conn *pc;
char *buf;
{
	if(print_on)  {
		struct ihost	*ihp = host_lookup_of_fd(pc->pkc_fd);

		bu_log("%s %s: %s",
			stamp(),
			ihp ? ihp->ht_name : "NONAME",
			buf );
		if( buf[strlen(buf)-1] != '\n' )
			bu_log("\n");
	}
	if(buf) (void)free(buf);
}
@


1.57
log
@Fixed computation of network_overhead.
Added check for odd compiler bug.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsync.c,v 1.56 1998/05/28 04:03:15 mike Exp mike $ (ARL)";
@


1.56
log
@~/mike isn't very useful.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsync.c,v 1.55 1998/05/22 20:07:32 mike Exp mike $ (ARL)";
d1738 1
d1832 2
d1839 1
d1848 4
d1853 1
d1866 2
a1867 1
	network_overhead = (int)(((double)ms_total - ms_rt_max) / (double)ms_total * 100);
@


1.55
log
@Time the reprojection phase.
Account for bandwidth of debugimage
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsync.c,v 1.54 1998/04/29 06:08:21 mike Exp mike $ (ARL)";
d1041 1
a1041 1
~/mike ~mike/cad/db ~/butler ~butler/cad/db \
@


1.54
log
@extra comma
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsync.c,v 1.53 1998/04/29 06:02:05 mike Exp mike $ (ARL)";
d182 2
d237 1
d358 1
a358 1
			"##: CP ord i_lps w_lps lump tot/rt/fb/ck state", NULL);
d374 1
a374 1
		"%2.2d: %2.2d %2.2d %5.5d %5.5d %4.4d %d=%d/%d/%d %s %s",
d382 1
d1033 1
d1732 1
a1732 1
	double		t1, t2, t3;
d1736 1
d1760 2
a1761 2
		nfields = sscanf(buf, "%d %lf %lf %lf",
			&new_npsw, &t1, &t2, &t3 );
d1777 5
a1781 3
		rtnodes[i].rt_time = t1;
		rtnodes[i].fb_time = t2;
		rtnodes[i].ck_time = t3;
d1851 1
@


1.53
log
@Corrected arg ordering in printf.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsync.c,v 1.52 1998/04/29 06:01:12 mike Exp mike $ (ARL)";
d703 1
a703 1
			ms_total_max,
@


1.52
log
@Added 5th line of status
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsync.c,v 1.51 1998/04/29 05:42:31 mike Exp mike $ (ARL)";
d700 2
a703 2
			ms_rt_min,
			ms_rt_max
@


1.51
log
@Added marker for very slow hosts.
Added Tcl interface to permit a status update on every frame.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsync.c,v 1.50 1998/04/29 04:35:58 mike Exp mike $ (ARL)";
d215 1
a657 1
 * XXX -3:  rtsync HOST fb $FB_FILE vrmgr $HOST db DATABASE
d699 14
a712 1
			"mbps %.1f net%% %d rt_min %.1f rt_max %.1f last %s",
d715 1
a715 2
			ms_rt_min,
			ms_rt_max,
d721 1
a721 1
	case -3:
d731 1
a731 1
	case -4:
a1731 1
	double		variation;
@


1.50
log
@Further timing and statistics improvements
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsync.c,v 1.49 1998/04/28 06:57:48 mike Exp mike $ (ARL)";
d233 1
d1017 1
d1842 1
a1842 1
	bu_log("%s%6d ms, %5.1f Mbps, %4.1f fps, %2d%%net %d/%d %.1fX %s\n",
a1847 1
		(int)ms_total_min, (int)ms_total_max,
d1849 1
d1854 1
a1854 1
	if( sched_update )
@


1.49
log
@Calculate interval between frame dispatching
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsync.c,v 1.48 1998/04/28 06:40:36 mike Exp mike $ (ARL)";
d194 1
d197 2
a198 2
/* Cooked values in ms */
int		ms_assigned;
d203 1
a203 1
fastf_t		sec_between_frames;
d208 8
d232 1
d650 106
d1013 1
d1016 1
d1048 2
d1089 9
d1195 1
a1195 1
	sec_between_frames = tvdiff( &frame_start, &t_all_done );
d1711 1
a1711 1
	double		blend1, blend2;
a1716 1
	char		nbuf[32];
d1718 1
a1718 3
	fastf_t		average_mbps;
	fastf_t		burst_mbps;	/* a lower bound only */
	int		network_overhead;
d1720 1
a1720 2
	blend1 = 0.8;
	blend2 = 1 - blend1;
d1788 2
a1789 2
	strncpy( nbuf, rtnodes[last_i].host->ht_name, 6 );
	nbuf[6] = '\0';
d1792 1
a1792 1
	(void)gettimeofday( &t_all_done, (struct timezone *)NULL );
d1796 1
d1799 5
a1803 2
	(void)gettimeofday( &time_end, (struct timezone *)NULL );
	interval = tvdiff( &time_end, &frame_start );
a1805 4
	ms_assigned = tvdiff( &t_assigned, &frame_start ) * 1000;
	ms_1st_done = tvdiff( &t_1st_done, &frame_start ) * 1000;
	ms_all_done = tvdiff( &t_all_done, &frame_start ) * 1000;
	ms_flush = tvdiff( &time_end, &t_all_done ) * 1000;
d1810 2
d1813 3
a1815 2
		register int	rtt;
		if( rtnodes[i].pkg != pc )  continue;
d1818 2
a1819 1
		rtt = (int)rtnodes[i].rt_time;
d1822 4
d1837 4
a1840 1
	bu_log("%s%6d ms, %5.1f Mbps, %4.1f fps, %2d%%net %d/%d %s\n",
d1846 3
a1848 2
		ms_1st_done, ms_all_done,
		nbuf
@


1.48
log
@Calculate "network overhead".
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsync.c,v 1.47 1998/04/28 06:22:57 mike Exp mike $ (ARL)";
d202 1
d283 13
d1065 3
a1568 13
 *			T V D I F F
 *
 *  Return t1 - t0, as a floating-point number of seconds.
 */
double
tvdiff(t1, t0)
struct timeval	*t1, *t0;
{
	return( (t1->tv_sec - t0->tv_sec) +
		(t1->tv_usec - t0->tv_usec) / 1000000. );
}

/*
d1711 2
a1712 1
		nbuf );
@


1.47
log
@Changed to computing burst Mbps
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsync.c,v 1.46 1998/04/28 06:06:13 mike Exp mike $ (ARL)";
d1585 1
a1585 1
	int		total_bits;
d1588 1
d1691 1
d1697 4
a1700 1
	bu_log("%s%6d ms, %5.1f Mbps, %4.1f fps, %d/%d %s\n",
d1705 1
@


1.46
log
@Print out name of slowest machine for each frame.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsync.c,v 1.45 1998/04/28 04:59:15 mike Exp mike $ (ARL)";
d203 3
d1585 3
d1677 19
a1695 1
	bu_log("%s%6d ms, %5.1f Mbps, %4.1f fps, %d/%d/%d/%d %s\n",
d1698 1
a1698 1
		width * height * 3 * 8 / interval / 1000000.0,
d1700 1
a1700 1
		ms_assigned, ms_1st_done, ms_all_done, ms_flush,
@


1.45
log
@Statistics format improvements
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsync.c,v 1.44 1998/04/28 04:25:54 mike Exp mike $ (ARL)";
d1563 3
d1580 2
d1635 1
d1648 6
d1671 1
a1671 1
	bu_log("%s %6d ms, %6.1f Mbps, %6.1f fps, %d/%d/%d/%d\n",
d1676 2
a1677 1
		ms_assigned, ms_1st_done, ms_all_done, ms_flush );
@


1.44
log
@More statistics
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsync.c,v 1.43 1998/04/28 03:43:19 mike Exp mike $ (ARL)";
d178 1
a178 1
	struct timeval	time_start;
d182 3
a184 3
	fastf_t		rt_time;	/* elapsed time for ray-tracing */
	fastf_t		fb_time;	/* elapsed time for fb_write() */
	fastf_t		ck_time;	/* elapsed time for fb sync check */
d326 1
a326 1
			"##: CP ord i_lps w_lps lump rt/fb/ck state", NULL);
d341 2
a342 1
	bu_vls_printf(&str, "%2.2d: %2.2d %2.2d %5.5d %5.5d %4.4d %d/%d/%d %s %s",
d349 1
a1653 6
	bu_log("%s Complete in %6d ms, %6.2g Mbps (%6.2g fps)\n",
		stamp(),
		ms_total,
		width * height * 3 * 8 / interval / 1000000.0,
		1.0/interval );

d1658 6
a1663 1
	bu_log("\tassignment=%d 1st_done=%d, all_done=%d, flush=%d ms\n",
@


1.43
log
@Collecting more timing data, both internally and from RTNODE.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsync.c,v 1.42 1998/04/28 00:44:35 mike Exp mike $ (ARL)";
d196 7
d316 1
d326 1
a326 1
			"##: CP ord i_lps w_lps lump busy state", NULL);
d334 6
d341 1
a341 1
	bu_vls_printf(&str, "%2.2d: %2.2d %2.2d %5.5d %5.5d %4.4d %s %9s %s %d/%d/%d",
a347 4
		rtnodes[i].busy ? "BUSY" : "wait",
		rtnodes[i].state == STATE_PREPPED ? "ok" :
			states[rtnodes[i].state],
		rtnodes[i].host->ht_name,
d350 3
a352 1
		(int)rtnodes[i].ck_time
d1651 2
a1652 1
	bu_log("%s Complete in %5g sec, %4g Mbps (%4g fps)\n",
d1654 1
a1654 1
		interval,
d1657 7
a1663 6
	bu_log("\tassignment=%g 1st_done=%g, all_done=%g, flush=%g ms\n",
		tvdiff( &t_assigned, &frame_start ) * 1000,
		tvdiff( &t_1st_done, &frame_start ) * 1000,
		tvdiff( &t_all_done, &frame_start ) * 1000,
		tvdiff( &time_end, &t_all_done ) * 1000
		);
@


1.42
log
@Improved error message
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsync.c,v 1.41 1998/03/17 05:27:15 mike Exp mike $ (ARL)";
d177 1
d182 3
d189 7
a214 1
struct timeval	frame_start;
d318 1
a318 1
			"##: CP i_lps w_lps lump busy state", NULL);
d327 1
a327 1
	bu_vls_printf(&str, "%2.2d: %2.2d %5.5g %5.5g %4.4d %s %9s %s",
d330 3
a332 2
		rtnodes[i].i_lps,
		rtnodes[i].w_lps,
d337 5
a341 1
		rtnodes[i].host->ht_name );
d434 18
d867 1
d887 2
d1032 1
d1095 2
d1279 3
d1320 3
a1526 2
		Tcl_Eval( interp, "update_cpu_status" );

d1559 4
d1579 18
a1596 2
		if( rtnodes[i].ncpus != atoi(buf) )  {
			bu_log(" %s %s NCPUs changed from %d to %s\n",
d1598 3
a1600 3
				rtnodes[i].ncpus, buf);
			rtnodes[i].ncpus = atoi(buf);
			Tcl_Eval( interp, "update_cpu_status" );
d1603 4
d1608 2
a1609 1
			bu_log("%s DONE %s (%g ms)\n", stamp(),
d1611 2
a1612 1
				interval * 1000.0
d1628 4
d1644 10
@


1.41
log
@drop connection in more sensible order.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsync.c,v 1.40 1998/03/17 03:29:57 mike Exp mike $ (ARL)";
d878 1
a878 1
		bu_log("\n*** Startup Script Aborted ***\n\n");
@


1.40
log
@Tcl_CreateFileHandler and Tcl_DeleteFileHandler
changed from Tcl 7 to Tcl 8.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsync.c,v 1.39 1997/12/31 09:07:04 mike Exp mike $ (ARL)";
d1116 1
d1122 1
a1122 1
		close( rtnodes[sub].fd );
a1124 1
	Tcl_DeleteFileHandler( rtnodes[sub].pkg->pkc_fd );
@


1.39
log
@Now sends the directory search path, as a Tcl command, before
attempting to open the framebuffer and then open the database.
The path is in a Tcl variable so that the GUI can change it (someday).
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsync.c,v 1.38 1997/12/23 10:20:58 mike Exp mike $ (ARL)";
a180 1
	Tcl_File	tcl_file;	/* Tcl's name for this fd */
d601 1
a601 1
		Tcl_DeleteFileHandler( Tcl_GetFile(clientData, TCL_UNIX_FD) );
d638 1
a638 2
		Tcl_DeleteFileHandler(
			Tcl_GetFile((ClientData)pc->pkc_fd, TCL_UNIX_FD) );
d671 1
a671 2
		Tcl_DeleteFileHandler(
			Tcl_GetFile((ClientData)pc->pkc_fd, TCL_UNIX_FD) );
d745 1
a745 2
		Tcl_DeleteFileHandler(
			Tcl_GetFile((ClientData)vrmgr_pc->pkc_fd, TCL_UNIX_FD) );
d761 1
a761 1
			Tcl_GetFile((ClientData)vrmgr_pc->pkc_fd, TCL_UNIX_FD),
d884 1
a884 1
			Tcl_GetFile((ClientData)fileno(stdin), TCL_UNIX_FD),
d908 1
a908 1
		Tcl_GetFile((ClientData)vrmgr_listen_fd, TCL_UNIX_FD),
d929 1
a929 1
		Tcl_GetFile((ClientData)rtsync_listen_fd, TCL_UNIX_FD),
d942 1
a942 1
			Tcl_GetFile((ClientData)fbp->if_selfd, TCL_UNIX_FD),
d1096 2
a1097 3
		rtnodes[i].tcl_file = 
			Tcl_GetFile((ClientData)pcp->pkc_fd, TCL_UNIX_FD);
		Tcl_CreateFileHandler( rtnodes[i].tcl_file,
d1124 1
a1124 1
	Tcl_DeleteFileHandler( rtnodes[sub].tcl_file );
@


1.38
log
@Now have "all_send" command which goes to all raytracers AND
over the VRMGR link to MGED.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsync.c,v 1.37 1997/12/23 09:46:27 mike Exp mike $ (ARL)";
d203 2
d839 8
d1130 2
d1370 11
@


1.37
log
@Added support to read reply that MGED now sends back
in response to Tcl vrmgr_send commands,
and use that as the Tcl return from vrmgr_send.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsync.c,v 1.36 1997/08/26 05:55:00 mike Exp mike $ (ARL)";
d474 25
d845 2
@


1.36
log
@Added call to bu_tcl_setup()
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsync.c,v 1.35 1997/08/26 04:24:41 mike Exp mike $ (ARL)";
d93 1
d431 1
d456 15
a470 1
	return TCL_OK;
@


1.35
log
@Added code to sense change in number of CPUs being used.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsync.c,v 1.34 1997/08/26 03:47:32 mike Exp mike $ (ARL)";
d787 1
@


1.34
log
@Added one_node_send command, and GUI support to use it to change
number of CPUs being used.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsync.c,v 1.33 1997/08/22 23:01:04 mike Exp mike $ (ARL)";
d1469 8
@


1.33
log
@Make sure latecommers get a chance at running.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsync.c,v 1.32 1997/08/21 03:25:28 mike Exp mike $ (ARL)";
d333 1
a333 1
 *  Arrange to send a string to all rtnode processes,
d369 48
d807 2
d1080 2
d1094 1
@


1.32
log
@Added drop_rtnode command
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsync.c,v 1.31 1997/08/21 00:57:07 mike Exp mike $ (ARL)";
d980 6
a985 1
	for( i = MAX_NODES-1; i >= 0; i-- )  {
@


1.31
log
@Don't just dispatch work based upon # of CPUs, dispatch based
upon measured performance.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsync.c,v 1.30 1997/08/21 00:11:12 mike Exp mike $ (ARL)";
d210 1
d212 1
d306 1
a306 1
			"CP i_lps w_lps lump busy state", NULL);
d315 2
a316 1
	bu_vls_printf(&str, "%2.2d %5.5g %5.5g %4.4d %s %9s %s",
d322 2
a323 1
		states[rtnodes[i].state],
d767 2
d874 1
d918 1
d923 1
d925 1
d937 2
a938 6
		if( i <= lowest_index )  {
			end_line = height-1;
		} else {
			end_line = start_line + rtnodes[i].lump-1;
			if( end_line > height-1 )  end_line = height-1;
		}
d1024 53
d1361 2
@


1.30
log
@Added Tcl interfaces for list_rtnodes and get_rtnode
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsync.c,v 1.29 1997/08/19 05:00:30 mike Exp mike $ (ARL)";
d174 2
a175 1
	int		busy;		/* !0 -> # lines assigned */
d178 2
a179 1
	fastf_t		lps;		/* # scanlines per second */
d302 4
a305 3
		Tcl_AppendResult(interp, "get_rtnode ",
			argv[1], " is out of range\n", NULL);
		return TCL_ERROR;
d313 1
a313 1
	bu_vls_printf(&str, "%2d %4g %s %9s %s",
d315 3
a317 1
		rtnodes[i].lps,
d750 1
a750 12
	/* Let main window pop up before running script */
	while( Tcl_DoOneEvent(TCL_DONT_WAIT) != 0 ) ;
# if 0
	(void)Tcl_Eval( interp, "wm withdraw .");
# endif
	if( Tcl_EvalFile( interp, "/m/cad/remrt/rtsync.tcl" ) != TCL_OK )  {
		bu_log("%s\n",
			Tcl_GetVar(interp,"errorInfo", TCL_GLOBAL_ONLY) );
		bu_log("\n*** Startup Script Aborted ***\n\n");
	}

	/* Incorporate built-in commands */
d764 11
d867 1
d898 20
a917 1
	/* Have some CPUS! Parcel up 'height' scanlines. */
a920 1
		int	count;
d930 1
a930 3
			count = (int)ceil( ((double)rtnodes[i].ncpus) /
				cpu_count * height );
			end_line = start_line + count;
d944 1
d949 1
a950 2
		rtnodes[i].busy = 1;
		(void)gettimeofday( &rtnodes[i].time_start, (struct timezone *)NULL );
d1298 5
d1334 1
d1336 3
d1346 3
a1348 1
		rtnodes[i].lps = rtnodes[i].busy / interval;
@


1.29
log
@Missing arg.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsync.c,v 1.28 1997/07/01 22:00:05 mike Exp mike $ (ARL)";
d256 66
d764 4
@


1.28
log
@Perform timing on a per-node basis.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsync.c,v 1.27 1997/06/26 01:13:35 mike Exp mike $ (ARL)";
d858 1
a858 1
		gettimeofday( &rtnodes[i].time_start );
@


1.27
log
@Linked to "database" name.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsync.c,v 1.26 1997/06/25 02:39:09 mike Exp mike $ (ARL)";
a82 2
#define pkg_send_vls(type,vlsp,pkg)	pkg_send( (type), bu_vls_addr((vlsp)), bu_vls_strlen((vlsp))+1, (pkg) )

d174 4
a177 1
	int		busy;
d200 1
a200 1
struct timeval	time_start;
d812 1
a812 1
	(void)gettimeofday( &time_start, (struct timezone *)NULL );
d858 1
d1243 1
a1243 1
		interval = tvdiff( &time_end, &time_start );
d1245 2
d1272 1
a1272 1
	interval = tvdiff( &time_end, &time_start );
d1274 1
a1274 1
	bu_log("%s Complete in %g sec, %g Kbps (%g fps)\n",
d1277 1
a1277 1
		width * height * 3 * 8 / interval / 1000.0,
@


1.26
log
@Oops, forgot NULL at end of AppendResult list.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsync.c,v 1.25 1997/06/25 00:09:26 mike Exp $ (ARL)";
d668 2
@


1.25
log
@Added 'refresh' command.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsync.c,v 1.24 1997/06/23 04:58:07 mike Exp mike $ (ARL)";
d406 1
a406 1
	Tcl_AppendResult(interp, "refresh:  no last_pov, ignored\n");
@


1.24
log
@At several fps, can't afford too much printing on the terminal.
Dropped it down to one line per frame, by default.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsync.c,v 1.23 1997/05/28 03:31:45 mike Exp mike $ (ARL)";
d113 1
d338 1
d386 24
d694 2
d811 8
d843 1
a843 1
			pending_pov+4 );
a855 3

	free( pending_pov );
	pending_pov = NULL;
@


1.23
log
@Improved logging, including Kbps.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsync.c,v 1.22 1997/03/07 02:52:42 mike Exp mike $ (ARL)";
d773 3
a775 1
	bu_log("%s dispatcher() has %d cpus\n", stamp(), cpu_count);
d1209 6
a1214 4
		bu_log("%s DONE %s (%g ms)\n", stamp(),
			rtnodes[i].host->ht_name,
			interval * 1000.0
			);
@


1.22
log
@Provide automatic window placement, save a click getting started.
Print full error trace on error in .rc file.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsync.c,v 1.21 1997/03/06 09:39:10 mike Exp mike $ (ARL)";
d811 2
a812 1
		bu_log("%s sending %d..%d to %s\n", stamp(), start_line, end_line, rtnodes[i].host->ht_name);
d1203 8
a1210 1
		bu_log("%s DONE %s\n", stamp(), rtnodes[i].host->ht_name );
d1231 1
a1231 1
	bu_log("%s Frame complete in %g seconds (%g fps)\n",
d1233 3
a1235 1
		interval, 1.0/interval );
@


1.21
log
@Working version
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsync.c,v 1.20 1997/03/06 09:08:27 mike Exp mike $ (ARL)";
d647 2
d655 5
a659 2
	if( Tcl_EvalFile( interp, "/m/cad/remrt/rtsync.tcl" ) != TCL_OK )
		bu_log("ERROR %s\n*** Script aborted\n", interp->result);
@


1.20
log
@Added more internal Tcl commands for communicating with
rtnode processes and our vrmgr controller.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsync.c,v 1.19 1997/03/06 06:03:27 mike Exp mike $ (ARL)";
d190 2
a399 1
bu_log("stdin_event_handler() called\n");
a435 1
bu_log("pkg_event_handler() called\n");
a469 1
bu_log("vrmgr_event_handler() called\n");
a550 1
bu_log("vrmgr_listen_handler() called\n");
a590 1
bu_log("rtsync_listen_handler() called\n");
d639 1
d752 1
a752 1
	int		ncpu = 0;
d755 1
d759 1
d765 1
a765 1
		ncpu += rtnodes[i].ncpus;
d768 4
a771 2
	bu_log("%s dispatcher() has %d cpus\n", stamp(), ncpu);
	if( ncpu <= 0 )  return;
d790 2
a791 1
			count = (int)ceil( ((double)rtnodes[i].ncpus) / ncpu * height );
@


1.19
log
@Eliminated old method of handling events.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsync.c,v 1.18 1997/03/06 05:03:24 mike Exp mike $ (ARL)";
d252 133
a505 1
bu_log("rtnode_event_handler() called\n");
d600 2
d609 2
d658 8
a756 1
bu_log("dispatcher() called\n");
@


1.18
log
@This version seems to be working.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsync.c,v 1.17 1997/03/05 09:45:49 mike Exp mike $ (ARL)";
a580 6
#if 0
	Tcl_CreateFileHandler(
		Tcl_GetFile((ClientData)STDIN_FILENO, TCL_UNIX_FD),
		TCL_READABLE|TCL_EXCEPTION, stdin_input,
		(ClientData)STDIN_FILENO);
#endif
a589 16
#if 0
	/* Establish select_list and maxfd, to poll critical fd's */
	FD_ZERO(&select_list);
	FD_SET(vrmgr_listen_fd, &select_list);
	FD_SET(rtsync_listen_fd, &select_list);
	max_fd = vrmgr_listen_fd;
	if( rtsync_listen_fd > max_fd )  max_fd = rtsync_listen_fd;

	if( fbp->if_selfd > 0 )  {
		FD_SET(fbp->if_selfd, &select_list);
		if( fbp->if_selfd > max_fd )  max_fd = fbp->if_selfd;
	}

	/*
	 *  Main loop
	 */
a590 90
		fd_set infds;
		struct timeval tv;
		register int	i;

		infds = select_list;	/* struct copy */

		tv.tv_sec = 3L;
		tv.tv_usec = 0L;
		if( (select( max_fd+1, &infds, (fd_set *)0, (fd_set *)0, 
			     &tv )) == 0 ) {
			/* printf("select timeout\n"); */
			if(fbp) fb_poll(fbp);
			dispatcher( (ClientData)0 );
			continue;
		}
#if 0
		printf("infds = x%x, select_list=x%x\n", infds.fds_bits[0], select_list.fds_bits[0] );
#endif
		/* Handle any events from the framebuffer */
		if (fbp && fbp->if_selfd > 0 && FD_ISSET(fbp->if_selfd, &infds))
			fb_poll(fbp);

		/* Accept any new VRMGR connections.  Only one at a time is permitted. */
		if( vrmgr_listen_fd > 0 && FD_ISSET(vrmgr_listen_fd, &infds))  {
			if( vrmgr_pc )  {
				bu_log("New VRMGR connection received with one still active, dropping old one.\n");
				FD_CLR(vrmgr_pc->pkc_fd, &select_list);
				pkg_close( vrmgr_pc );
				vrmgr_pc = 0;
				vrmgr_ihost = IHOST_NULL;
			}
			vrmgr_pc = pkg_getclient( vrmgr_listen_fd, vrmgr_pkgswitch, bu_log, 0 );
			vrmgr_ihost = host_lookup_of_fd(vrmgr_pc->pkc_fd);
			if( vrmgr_ihost == IHOST_NULL )  {
				bu_log("Unable to get hostname of VRMGR, abandoning it\n");
				FD_CLR(vrmgr_pc->pkc_fd, &select_list);
				pkg_close( vrmgr_pc );
				vrmgr_pc = 0;
			} else {
				bu_log("%s VRMGR link with %s, fd=%d\n",
					stamp(),
					vrmgr_ihost->ht_name, vrmgr_pc->pkc_fd);
				FD_SET(vrmgr_pc->pkc_fd, &select_list);
				if( vrmgr_pc->pkc_fd > max_fd )  max_fd = vrmgr_pc->pkc_fd;
				setup_socket( vrmgr_pc->pkc_fd );
			}
		}

		/* Accept any new RTNODE connections */
		if( rtsync_listen_fd > 0 && FD_ISSET(rtsync_listen_fd, &infds))  {
			new_rtnode( pkg_getclient( rtsync_listen_fd, rtsync_pkgswitch, bu_log, 0 ) );
		}

		/* Process arrivals from VRMGR link */
		if( vrmgr_pc && FD_ISSET(vrmgr_pc->pkc_fd, &infds) )  {
			if( pkg_suckin( vrmgr_pc ) <= 0 )  {
				/* Probably an EOF */
				FD_CLR(vrmgr_pc->pkc_fd, &select_list);
				pkg_close( vrmgr_pc );
				vrmgr_pc = 0;
				vrmgr_ihost = IHOST_NULL;
			} else {
				if( pkg_process( vrmgr_pc ) < 0 )
					bu_log("VRMGR pkg_process error\n");
			}
		}

		/* Process arrivals from existing rtnodes */
		for( i = MAX_NODES-1; i >= 0; i-- )  {
			if( rtnodes[i].fd == 0 )  continue;
			if( pkg_process( rtnodes[i].pkg ) < 0 ) {
				bu_log("pkg_process error encountered (1)\n");
			}
			if( ! FD_ISSET( rtnodes[i].fd, &infds ) )  continue;
			if( pkg_suckin( rtnodes[i].pkg ) <= 0 )  {
				/* Probably EOF */
				drop_rtnode( i );
				continue;
			}
			if( pkg_process( rtnodes[i].pkg ) < 0 ) {
				bu_log("pkg_process error encountered (2)\n");
			}
		}

		/* Dispatch work */
		dispatcher( (ClientData)0 );

	}
#else
	for(;;)  {
a591 1
bu_log("Tcl_DoOneEvent() returned\n");
a592 1
#endif
@


1.17
log
@Converted to Tcl event handlers.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsync.c,v 1.16 1997/03/05 07:46:20 mike Exp mike $ (ARL)";
d252 38
d302 1
d320 2
d337 1
d357 2
d373 1
d391 2
d404 1
d408 2
d420 2
d449 2
d461 1
d464 2
d506 2
a508 1
#if 0
d513 3
a517 1
	(void)Tcl_EvalFile( interp, ".rtsyncrc" );
d519 2
a520 1
#endif
d522 10
d702 4
a705 1
	for(;;)  Tcl_DoOneEvent(0);
d714 4
d727 1
a727 2

	Tcl_DoWhenIdle( dispatcher, (ClientData)0 );
@


1.16
log
@Tcl initialized
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsync.c,v 1.15 1997/03/05 07:30:22 mike Exp mike $ (ARL)";
d78 1
d176 1
d191 1
d198 1
d207 1
d252 160
d443 1
d450 11
d477 4
d498 4
d510 16
d554 1
a554 1
			dispatcher();
d627 1
a627 1
		dispatcher();
d630 3
d637 3
d641 3
a643 2
int
dispatcher()
d650 1
a650 1
	if( !pending_pov )  return 0;
d652 2
d658 1
a658 1
		if( rtnodes[i].busy )  return 0;	/* Still working on last one */
d663 1
a663 1
	if( ncpu <= 0 )  return 0;
a705 1
	return 0;
d739 5
d768 1
@


1.15
log
@Added CMD package type.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsync.c,v 1.14 1997/01/07 04:05:37 mike Exp mike $ (ARL)";
d77 1
d188 2
d275 8
@


1.14
log
@Added debug flag, to track pov arrivals.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsync.c,v 1.13 1997/01/04 05:12:09 mike Exp mike $ (ARL)";
d122 1
d141 1
@


1.13
log
@Allow using partial framebuffers
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsync.c,v 1.12 1997/01/04 03:24:30 mike Exp mike $ (ARL)";
d183 1
d197 1
a197 1
Usage:  rtsync [-h] [-S squaresize] [-W width] [-N height] [-F framebuffer]\n\
d208 1
a208 1
	while ( (c = getopt( argc, argv, "hF:s:w:n:S:W:N:" )) != EOF )  {
d210 3
d670 1
@


1.12
log
@libbu/libbn
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsync.c,v 1.11 1996/12/31 17:03:36 jra Exp mike $ (ARL)";
d273 4
a276 2
	width = fb_getwidth(fbp);
	height = fb_getheight(fbp);
@


1.11
log
@Minor mod for Solaris.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsync.c,v 1.10 1996/12/31 17:01:43 jra Exp jra $ (ARL)";
d81 1
a81 1
#define pkg_send_vls(type,vlsp,pkg)	pkg_send( (type), rt_vls_addr((vlsp)), rt_vls_strlen((vlsp))+1, (pkg) )
d185 1
a185 1
struct rt_vls	treetops;
d261 3
a263 3
	rt_vls_init( &treetops );
	rt_vls_from_argv( &treetops, argc - optind, argv+optind );
	rt_log("DB: %s %s\n", database, rt_vls_addr(&treetops) );
d265 1
a265 1
	RT_LIST_INIT( &rt_g.rtg_vlfree );
d277 2
a278 2
	if( (vrmgr_listen_fd = pkg_permserver("5555", "tcp", 8, rt_log)) < 0 )  {
		rt_log("Unable to listen on 5555\n");
d283 1
a283 1
	if( (rtsync_listen_fd = pkg_permserver("rtsrv", "tcp", 8, rt_log)) < 0 )  {
d289 1
a289 1
			if( (rtsync_listen_fd = pkg_permserver(num, "tcp", 8, rt_log)) < 0 )
d294 1
a294 1
			rt_log("Unable to find a port to listen on\n");
d299 1
a299 1
	rt_log("%s RTSYNC listening on %s port %d\n",
d347 1
a347 1
				rt_log("New VRMGR connection received with one still active, dropping old one.\n");
d353 1
a353 1
			vrmgr_pc = pkg_getclient( vrmgr_listen_fd, vrmgr_pkgswitch, rt_log, 0 );
d356 1
a356 1
				rt_log("Unable to get hostname of VRMGR, abandoning it\n");
d361 1
a361 1
				rt_log("%s VRMGR link with %s, fd=%d\n",
d372 1
a372 1
			new_rtnode( pkg_getclient( rtsync_listen_fd, rtsync_pkgswitch, rt_log, 0 ) );
d385 1
a385 1
					rt_log("VRMGR pkg_process error\n");
d393 1
a393 1
				rt_log("pkg_process error encountered (1)\n");
d402 1
a402 1
				rt_log("pkg_process error encountered (2)\n");
d433 1
a433 1
	rt_log("%s dispatcher() has %d cpus\n", stamp(), ncpu);
d444 1
a444 1
		struct rt_vls	msg;
d458 2
a459 2
		rt_vls_init( &msg );
		rt_vls_printf( &msg, "%d %d %d %s\n",
d465 1
a465 1
			rt_vls_free(&msg);
d468 1
a468 1
		rt_log("%s sending %d..%d to %s\n", stamp(), start_line, end_line, rtnodes[i].host->ht_name);
d470 1
a470 1
		rt_vls_free(&msg);
d494 1
a494 1
		rt_log("%s Unable to get host name of new connection, dropping\n", stamp() );
d498 1
a498 1
	rt_log("%s Connection from %s\n", stamp(), host->ht_name);
d513 1
a513 1
	rt_log("rtsync: too many rtnode clients.  My cup runneth over!\n");
d524 1
a524 1
	rt_log("%s Dropping %s\n", stamp(), rtnodes[sub].host->ht_name);
d581 1
a581 1
	rt_log("%s %s %s --> %s\n", stamp(),
d585 1
a585 1
		rt_log("%s was in state %s, should have been %s, dropping\n",
d613 1
a613 1
	rt_log("%s VRMGR host %s, role %s\n",
d619 1
a619 1
		rt_log("bad role command\n");
d623 1
a623 1
		rt_log("ERROR %s: bad role '%s', dropping vrmgr\n",
d646 1
a646 1
	rt_log("%s VRMGR unexpectely got event '%s'", stamp(), buf );
d681 1
a681 1
	rt_log("rtsync: unable to handle %s message: len %d",
d697 1
a697 1
	struct rt_vls	cmd;
d706 1
a706 1
		rt_log("%s %s ALIVE %d cpus\n", stamp(),
d715 2
a716 2
		rt_vls_init( &cmd );
		rt_vls_printf( &cmd, "%d %d %s", width, height, framebuffer );
d719 1
a719 1
			rt_vls_free( &cmd );
d723 1
a723 1
		rt_vls_free( &cmd );
d776 1
a776 1
		rt_log("%s %s %s\n", stamp(),
d810 1
a810 1
		rt_log("%s %s %s\n", stamp(),
d853 1
a853 1
		rt_log("%s DONE %s\n", stamp(), rtnodes[i].host->ht_name );
d874 1
a874 1
	rt_log("%s Frame complete in %g seconds (%g fps)\n",
d913 1
a913 1
		rt_log("%s %s: %s",
d918 1
a918 1
			rt_log("\n");
@


1.10
log
@Mike's changes.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsync.c,v 1.9 1995/08/24 03:56:41 mike Exp mike $ (ARL)";
d547 1
a547 1
	if( setsockopt( fd, SOL_SOCKET, SO_KEEPALIVE, &on, sizeof(on)) < 0 ) {
@


1.9
log
@More conservative about hosts with bad DNS entries.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsync.c,v 1.8 1995/08/24 03:16:46 mike Exp mike $ (ARL)";
d187 2
d436 3
d825 13
d846 2
d869 8
@


1.8
log
@Upgraded to use messages for specifying framebuffer, database,
and treetops.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/remrt/RCS/rtsync.c,v 1.7 1995/08/23 02:05:30 mike Exp mike $ (ARL)";
d483 1
d488 7
d505 1
a505 3
		rtnodes[i].host = host_lookup_of_fd(pcp->pkc_fd);

		rt_log("%s Connection from %s\n", stamp(), rtnodes[i].host->ht_name);
@


1.7
log
@Using /dev/sgid for double-buffer simulation,
flush data through to FBSERV.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsync.c,v 1.6 1995/08/22 22:02:07 mike Exp mike $ (ARL)";
d81 2
d119 3
d127 3
d133 1
d135 3
a139 1
	{ RTSYNCMSG_DONE,	rtsync_ph_done, "RTNODE assignment done" },
d146 14
d169 1
d184 3
a230 2
	if( argc > optind )
		return(0);	/* print usage */
d247 16
d266 2
d425 1
d443 1
a443 1
		if( rtnodes[i].ncpus <= 0 )  continue;
d458 1
a458 1
		if( pkg_send( RTSYNCMSG_POV, rt_vls_addr(&msg), rt_vls_strlen(&msg)+1, rtnodes[i].pkg ) < 0 )  {
d490 2
d562 23
d686 1
d689 1
d695 3
a697 2
		rt_log("%s ALIVE %d cpus, %s\n", stamp(),
			ncpu, rtnodes[i].host->ht_name );
d700 13
a712 1
		if( buf )  free(buf);
d719 95
d837 1
@


1.6
log
@Don't hardcode framebuffer.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/remrt/RCS/rtsync.c,v 1.5 1995/07/18 03:01:18 mike Exp mike $ (ARL)";
d649 1
a649 1
		return;
d652 9
@


1.5
log
@Irix 6.0.1
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsync.c,v 1.4 1995/07/15 07:52:47 mike Exp mike $ (ARL)";
d154 1
a154 1
static	char	*framebuffer = "vj:0";
@


1.4
log
@Keep track of CPU busy status.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsync.c,v 1.3 1995/07/15 07:11:33 mike Exp mike $ (ARL)";
d664 1
a664 1
	long		now;
@


1.3
log
@This version actually works, a bit.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsync.c,v 1.2 1995/07/15 06:11:12 mike Exp mike $ (ARL)";
d145 1
a372 1
	static int	sent_one = 0;
a376 1
	if( sent_one )  return 0;
d381 1
d421 1
d426 1
a581 1
rt_log("%s %s\n", stamp(), buf);
d640 1
a640 1
	struct ihost	*ihp;
d642 10
a651 4
	rt_log("It's done! %s\n", buf);
	ihp = host_lookup_of_fd( pc->pkc_fd );
	if(ihp) rt_log("  %s is done\n", ihp->ht_name );
	if( buf )  free(buf);
@


1.2
log
@It compiles, and does basic stuff properly.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsync.c,v 1.1 1995/07/15 02:34:12 mike Exp mike $ (ARL)";
d280 1
a280 1
		tv.tv_sec = 60L;
d286 1
d380 1
a380 1
		if( rtnodes[i].fd != 0 )  continue;
d385 1
d396 1
a396 1
		if( rtnodes[i].fd != 0 )  continue;
d448 2
a449 1
rt_log("%s Connection from %s\n", stamp(), rtnodes[i].host->ht_name);
d463 1
a611 1
	struct rtnode	*np;
d624 1
a624 1
		np->ncpus = ncpu;
d626 1
@


1.1
log
@Initial revision
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
d109 1
d115 1
d122 2
d126 4
d136 3
d144 1
d225 3
d284 1
a284 1
			printf("select timeout\n");
d288 3
a290 1
printf("infds = x%x, select_list=x%x\n", infds.fds_bits[0], select_list.fds_bits[0] );
d356 4
d364 62
d445 2
d608 27
d637 1
a637 1
	rt_log("It's alive!\n");
d639 1
a639 1
	if(ihp) rt_log("  %s is alive\n", ihp->ht_name );
d664 21
@
