head	1.23;
access;
symbols
	rel-4-5:1.22;
locks; strict;
comment	@ * @;


1.23
date	98.11.10.04.54.44;	author mike;	state dead;
branches;
next	1.22;

1.22
date	97.12.31.09.06.05;	author mike;	state Exp;
branches;
next	1.21;

1.21
date	97.12.04.03.20.01;	author mike;	state Exp;
branches;
next	1.20;

1.20
date	97.12.04.02.45.41;	author mike;	state Exp;
branches;
next	1.19;

1.19
date	97.12.04.02.35.21;	author mike;	state Exp;
branches;
next	1.18;

1.18
date	97.12.03.08.00.13;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	97.11.21.19.56.03;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	97.11.21.19.40.09;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	97.11.21.19.35.17;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	97.11.21.04.52.20;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	97.08.22.23.08.12;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	97.08.22.22.04.35;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	97.08.19.07.00.47;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	97.08.19.06.36.32;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	97.08.19.04.44.23;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	97.07.30.05.46.13;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	97.07.30.04.58.55;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	97.07.29.22.49.51;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	97.07.29.04.55.59;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	97.07.29.04.28.31;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	97.07.23.22.47.35;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	97.07.02.00.25.20;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	97.07.01.21.57.35;	author mike;	state Exp;
branches;
next	;


desc
@Program to monitor processor availability for REMRT type applications
@


1.23
log
@Moved real-time ray-tracer over into "SWISS" directory
@
text
@/*
 *			R T M O N . C
 *
 *  Remote ray-tracer system monitoring program.
 *  Hang around indefinitely to answer questions about available hardware,
 *  system load, raw processor speed, etc.,
 *  and initiate a server process when requested.
 *
 *  To simplify the hurdles of getting through the various
 *  telnet/rlogin/Kerberos/Secure-ID/SSH hurdles at different sites,
 *  so that a simple Tcl script stands a chance of getting servers started.
 *
 *  For security reasons, this program should not use Tcl (or any other
 *  interpreter.  However, output should be Tcl-friendly pure ASCII strings.
 *  This precludes use of LIBPKG on the connections.
 *
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Status -
 *	Public Domain, Distribution Unlimited.
 */
#ifndef lint
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/remrt/rtmon.c,v 1.22 1997/12/31 09:06:05 mike Exp mike $ (ARL)";
#endif


#include "conf.h"

#include <stdio.h>
#include <ctype.h>
#include <signal.h>
#include <fcntl.h>
#include <pwd.h>
#include <errno.h>
#include <netdb.h>
#include <math.h>
#ifdef USE_STRING_H
# include <string.h>
#else
# include <strings.h>
#endif

#include <sys/stat.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/wait.h>

/*
 *  The situation with sys/time.h and time.h is crazy.
 *  We need sys/time.h for struct timeval,
 *  and time.h for struct tm.
 *
 *  on BSD (and SGI 4D), sys/time.h includes time.h,
 *  on the XMP (UNICOS 3 & 4), time.h includes sys/time.h,
 *  on the Cray-2, there is no automatic including.
 *
 *  Note that on many SYSV machines, the Cakefile has to set BSD
 */
#if BSD && !SYSV
#  include <sys/time.h>		/* includes <time.h> */
#else
#  if CRAY1 && !__STDC__
#	include <time.h>	/* includes <sys/time.h> */
#  else
#	include <sys/time.h>
#	include <time.h>
#  endif
#endif

#include "machine.h"
#include "vmath.h"
#include "bu.h"
#include "externs.h"

#include "./ihost.h"

int		debug = 0;

char		*our_hostname;
char		*machinetype;

int		listenfd;

FILE		*ifp;
FILE		*ofp;

char		*start_dir;
int		main_argc;
char		**main_argv;

static char	usage[] = "\
Usage:  rtmon [-d#]\n\
";

/*
 *			B U _ G E T _ 1 C P U _ S P E E D
 */
#if defined(IRIX)
# include <sys/utsname.h>
#endif
#define CPU_SPEED_FILE	"./1cpu.speeds"
fastf_t
bu_get_1cpu_speed()
{
#if defined(IRIX)
	struct utsname	ut;

# if 0
	if( uname(&ut) >= 0 )  {
		/* Key on type of CPU board, e.g. IP6 */
		return lookup( CPU_SPEED_FILE, ut.machine );
	}
# endif
	FILE	*fp;
	double	d;
	/* File format:  scale-factor TAB #Mhz SPACE IP99 */
	if( (fp = popen("grep \"`hinv | head -1 | cut '-d ' -f 2,4`\" 1cpu.speeds", "r")) != NULL )  {
		d = 0.9876;
		if( fscanf( fp, "%lf", &d ) != 1 )
			return 1.0;
		fclose(fp);
		return d;
	}
#endif
	return 1.0;
}

/*
 *			G E T _ M A C H I N E T Y P E
 */
void
get_machinetype()
{
	FILE	*fp;
	struct bu_vls	str;

	if( (fp = popen( "PATH=/usr/brlcad/bin:$PATH; machinetype.sh -m", "r" )) == NULL )  {
		machinetype = "???error:popen";
		return;
	}
	bu_vls_init( &str );
	if( bu_vls_gets( &str, fp ) <= 0 )  {
		machinetype = "???error:EOF";
		fclose(fp);
		return;
	}
	bu_vls_trimspace( &str );
	machinetype = bu_vls_strgrab( &str );
	bu_vls_free( &str );
}

/*
 *			S E N D _ S T A T U S
 */
void
send_status(fd)
int	fd;
{
	struct bu_vls	str;

	bu_vls_init(&str);

	bu_vls_printf( &str, "host %s", our_hostname );
	bu_vls_printf( &str, " type %s", machinetype );
	bu_vls_printf( &str, " ncpu %d", bu_avail_cpus() );
	bu_vls_printf( &str, " pub %d", bu_get_public_cpus() );
	bu_vls_printf( &str, " load %g", bu_get_load_average() );
	bu_vls_printf( &str, " realt %d", bu_set_realtime() );
#if 0
	/* Don't really need this, just a curiosity number */
	bu_vls_printf( &str, " 1cpu_speed %g", bu_get_1cpu_speed() );
#endif

	bu_vls_putc( &str, '\n' );

	(void)write( fd, bu_vls_addr(&str), bu_vls_strlen(&str) );
	bu_vls_free( &str );
}

char bbin[128] = "/";		/* will be ~user/bbin/bin */

char *prog_paths[] = {
	".",
	"/m/cad/.remrt.%s",
	"/n/vapor/m/cad/.remrt.%s",
	"/m/cad/.remrt.6d",
	"/n/vapor/m/cad/.remrt.6d",
	"/usr/brlcad/bin",
	bbin,
	NULL
};

/*
 *			R U N _ R T N O D E
 */
void
run_prog(fd, argc, argv, program)
int	fd;
int	argc;
char	**argv;
char	*program;	/* name of program to run */
{
	char **pp;
	struct bu_vls	path;

	bu_vls_init(&path);

	argv[0] = program;

	/* Set up environment variables appropriately */
	if( access( "/m/cad/libtcl/library/init.tcl", R_OK ) == 0 )  {
		putenv( "TCL_LIBRARY=/m/cad/libtcl/library" );
		putenv( "TK_LIBRARY=/m/cad/libtk/library" );
/* fprintf(stderr, "/m/cad/libtcl/library/init.tcl\n" ); */
	} else if( access( "/n/vapor/m/cad/libtcl/library/init.tcl", R_OK ) == 0 )  {
		putenv( "TCL_LIBRARY=/n/vapor/m/cad/libtcl/library" );
		putenv( "TK_LIBRARY=/n/vapor/m/cad/libtk/library" );
/* fprintf(stderr, "/n/vapor/m/cad/libtcl/library/init.tcl\n" ); */
	} else {
		putenv( "TCL_LIBRARY=/usr/brlcad/libtcl/library" );
		putenv( "TK_LIBRARY=/usr/brlcad/libtk/library" );
	}
	/* XXX else /usr/brlcad/tcl/init.tcl? */

	for( pp = prog_paths; *pp != NULL; pp++ )  {
		int	stat;
		int	pid;

		bu_vls_trunc( &path, 0 );
		bu_vls_printf( &path, *pp, machinetype );
		bu_vls_putc( &path, '/' );
		bu_vls_strcat( &path, program );
		if( access( bu_vls_addr(&path), X_OK ) )  continue;

		/* Reap any prior dead children.  Sanity */
#if defined(IRIX)
		(void)wait3( &stat, WNOHANG, NULL );
#else
		/* Solaris, and perhaps others */
		(void)waitpid( (pid_t)-1, &stat, WNOHANG );
#endif

		if( (pid = fork()) == 0 )  {
			/* Child process */
			close(fd);
			for(fd=0; fd<=32; fd++) (void)close(fd);
			if( open("/dev/null", 0) < 0 ) perror("/dev/null fd0");
			if( open("/dev/null", 1) < 0 ) perror("/dev/null fd1");
			if( open("/dev/null", 1) < 0 ) perror("/dev/null fd2");
			(void)execv( bu_vls_addr(&path), argv );
			/* If execv() succeeds, there is no return and
			 * Process will be reaped in wait3() in main(),
			 * else failure will be reaped below.
			 */
			exit(42);
		}
		sleep(1);	/* Give exec enough time to fail */
#if defined(IRIX)
		if( wait3( &stat, WNOHANG, NULL ) == pid )
#else
		if( waitpid( (pid_t)-1, &stat, WNOHANG ) == pid )
#endif
		{
			/* It died. */
			/* Be robust in the face of 'wrong architecture' errors. */
			if( WIFEXITED(stat) )  {
				if( WEXITSTATUS(stat) == 42 )   {
					continue;	/* Try another path */
				}
				if( WEXITSTATUS(stat) == 0 )  {
					/* normal exit, probably detatched */
					goto ok;
				}
			}
			bu_vls_putc(&path, ' ');
			bu_vls_from_argv(&path, argc, argv );
			fprintf(ofp, "FAIL %s died with status=x%x\n",
				bu_vls_addr(&path), stat);
			fflush(ofp);
			bu_vls_free(&path);
			return;
		}

ok:
		bu_vls_putc(&path, ' ');
		bu_vls_from_argv(&path, argc, argv );
		fprintf(ofp, "OK %s\n", bu_vls_addr(&path) );
		fflush(ofp);
		bu_vls_free(&path);
		return;
	}
	fprintf(ofp, "FAIL Unable to find executable %s.\n", program);
	fflush(ofp);
	bu_vls_free(&path);
}

/*
 *			S E R V E R _ P R O C E S S
 *
 *  Manage all conversation on one connection.
 *  There will be a separate process for each open connection.
 *  Each command will be acknowledged by a single line response.
 *  For security reasons, this does NOT want to be done via TCL.
 */
void
server_process(fd)
int	fd;
{
	struct bu_vls	str;
	int		argc;
#define MAX_ARGS	50
	char	*argv[MAX_ARGS+2];
	struct ihost	*him;

	ifp = fdopen( fd, "r" );
	ofp = fdopen( fd, "w" );
	bu_setlinebuf( ifp );
	bu_setlinebuf( ofp );

	our_hostname = get_our_hostname();	/* ihost.c */

	/* First step, ensure access from proper machine.
	 * XXX For now, just use DNS.  Later, require a "user" command.
	 */
	if( (him = host_lookup_of_fd(fd)) == IHOST_NULL )  {
		fprintf( ofp, "FAIL unable to obtain your hostname\n");
		exit(0);
	}
	if( strcmp( &him->ht_name[strlen(him->ht_name)-4], ".mil" ) != 0 )  {
		fprintf( ofp, "FAIL connection from unauthorized host %s\n",
			him->ht_name);
		exit(0);
	}

	/* Determine machine type */
	get_machinetype();

	/* Main loop:  process commands. */
	bu_vls_init(&str);
	while( !feof(ifp ) )  {
		bu_vls_trunc( &str, 0 );
		if( bu_vls_gets( &str, ifp ) < 0 )  break;

		argc = bu_argv_from_string( argv, MAX_ARGS, bu_vls_addr(&str) );

		if( strcmp( argv[0], "status" ) == 0 )  {
			send_status(fd);
			continue;
		}
		if( strcmp( argv[0], "rtnode" ) == 0 )  {
			run_prog(fd, argc, argv, "rtnode");
			continue;
		}
		if( strcmp( argv[0], "rtsrv" ) == 0 )  {
			run_prog(fd, argc, argv, "rtsrv");
			continue;
		}
		if( strcmp( argv[0], "restart" ) == 0 )  {
			kill( getppid(), SIGUSR1 );
			fprintf( ofp, "OK restart signal sent\n");
			exit(0);
		}
		if( strcmp( argv[0], "quit" ) == 0 )
			exit(0);
		fprintf( ofp, "ERROR Unknown command: %s\n", bu_vls_addr(&str) );
	}

	close(fd);
	exit(0);
}

/*
 *			G E T _ A R G S
 */
get_args( argc, argv )
register char **argv;
{
	register int c;

	while ( (c = getopt( argc, argv, "d:" )) != EOF )  {
		switch( c )  {
		case 'd':
			debug = atoi(optarg);
			break;
		default:		/* '?' */
			return(0);
		}
	}

	return(1);		/* OK */
}

/*
 *			B E C O M E _ U S E R
 *
 *  Returns -
 *	1	Didn't work, but nothing we can do about it.
 *	0	OK
 *	-1	Failure to find user name.
 */
int
become_user( name )
CONST char	*name;
{
	struct passwd	*pw;

	if( getuid() != 0 )  return 1;

	setpwent();
	if( (pw = getpwnam(name)) == NULL )  return -1;
	setgid(pw->pw_gid);
	setuid(pw->pw_uid);
	if( getuid() != pw->pw_uid )  {
		fprintf(stderr, "rtmon: wanted %d, got %d?\n", pw->pw_uid, getuid() );
		if( getuid() == 0 )  return -1;
		return 1;
	}
	sprintf(bbin, "%s/bbin/bin", pw->pw_dir );
	return 0;
}

/*
 *			R E S T A R T _ S I G N A L
 *
 *  Have main process re-exec itself, if possible.
 */
void
restart_signal(foo)
int	foo;
{
	char	buf[32];

	/* Re-establish handler, in case restart does not work */
	(void)signal( SIGUSR1, restart_signal );

	sprintf( buf, "%d", atoi(main_argv[1])+1 );

	/* If argv[0] has full path, use it */
	if( access( main_argv[0], X_OK ) == 0 )  {
		execl( main_argv[0], main_argv[0], buf, NULL );
		perror(main_argv[0]);
	}
	/* Prepare to start a new daemon in a child process, close listen */
	(void)close(listenfd);

	/* Try to find our executable in one of the usual places. */
	run_prog( 2, main_argc, main_argv, "rtmon" );

	/* If that doesn't work either, just die. */
	fprintf(stderr, "rtmon: unable to reload, aborting.\n");
	exit(1);
}

/*
 *			M A I N
 */
main(argc, argv)
int	argc;
char	*argv[];
{
	struct sockaddr_in sinme;
	register struct servent *sp;
	struct	sockaddr *addr;			/* UNIX or INET addr */
	int	addrlen;			/* length of address */
	int	on = 1;

	main_argc = argc;
	main_argv = argv;

	if ( !get_args( argc, argv ) ) {
		(void)fputs(usage, stderr);
		exit( 1 );
	}

	close(0);	/* shut stdin */

	setuid(0);	/* in case we're only set-uid */

	/* Set real-time scheduler priority.  May need root privs. */
	bu_set_realtime();

	/* Drop down to normal user privs */
	if( become_user( "cmike" ) != 0 )  {
		if( become_user( "mike" ) != 0 )  {
			/* Failsafe to prevent running as root */
			setgid(42);
			setuid(53);
			if(getuid()==0) exit(42);
		}
	}

	/* Find current directory */
	if( (start_dir = getcwd(NULL,4096-8)) == NULL )  {
		perror("getcwd");
		start_dir = ".";
	}

	/* Accept restart signals */
	(void)signal( SIGUSR1, restart_signal );

	/* Hang a listen */
	bzero((char *)&sinme, sizeof(sinme));

	/* Determine port for service */
	sinme.sin_port = htons((unsigned short) 5353 );
	sinme.sin_family = AF_INET;
	addr = (struct sockaddr *) &sinme;
	addrlen = sizeof(struct sockaddr_in);

	if( (listenfd = socket(addr->sa_family, SOCK_STREAM, 0)) < 0 )  {
		perror( "rtmon: socket" );
		return -2;
	}

	if( addr->sa_family == AF_INET ) {
		if( setsockopt( listenfd, SOL_SOCKET, SO_REUSEADDR,
		    (char *)&on, sizeof(on) ) < 0 )  {
			perror( "rtmon: setsockopt SO_REUSEADDR" );
		}
	}

	if( bind(listenfd, addr, addrlen) < 0 )  {
		perror( "rtmon: bind" );
		close(listenfd);
		return -2;
	}

	if( fcntl(listenfd, F_SETFD, FD_CLOEXEC ) < 0 )  {
		perror("rtmon: FD_CLOEXEC");
		/* Keep going */
	}

	if( listen(listenfd, 5) < 0 )  {
		perror( "rtmon: listen" );
		close(listenfd);
		return -2;
	}

	/*
	 *  For each new connection, fork a new exclusive server process.
	 *  Assume nothing about the state of the system here,
	 *  as this may be a very long-running (days, weeks) process.
	 *  Even the formal hostname may change in that period.
	 */
await:
	for(;;)  {
		struct timeval	tv;
		fd_set	fds;
		int	stat;
		int	val;

		/* Reap any dead children */
#if defined(IRIX)
		(void)wait3( &stat, WNOHANG, NULL );
#else
		/* Solaris, and perhaps others */
		(void)waitpid( (pid_t)-1, &stat, WNOHANG );
#endif

		FD_ZERO(&fds);
		FD_SET(listenfd, &fds);
		/* Hang in select() waiting for something to happen */
		tv.tv_sec = 10*60;	/* 10 minutes */
		tv.tv_usec = 0;

		val = select(32, &fds, (fd_set *)0, (fd_set *)0, &tv);
		if( val < 0 )  {
			perror("rtmon: select");
			return -4;
		}
		if( val==0 )  {
			/* At this point, ibits==0 */
			/* Select timed out */
			continue;
		}

		/* Accept any pending connections */
		if( FD_ISSET(listenfd, &fds) )  {
			auto struct sockaddr_in from;
			int s2;
			auto int fromlen = sizeof (from);
			int	pid;

			do  {
				s2 = accept(listenfd, (struct sockaddr *)&from, &fromlen);
				if (s2 < 0) {
					if(errno == EINTR)
						continue;
					perror("rtmon: accept" );
					goto await;
				}
			}  while( s2 < 0);

			if( (pid = fork()) == 0 )  {
				/* Child process */
				server_process(s2);
				exit(0);
			} else if( pid < 0 )  {
				perror("rtmon: fork");
			}
			close(s2);
		}
	}
}
@


1.22
log
@The "find" command didn't belong in this daemon, and
has been removed.  It's now a runtime function of RTNODE.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtmon.c,v 1.21 1997/12/04 03:20:01 mike Exp mike $ (ARL)";
@


1.21
log
@Made perror conditional, added MSRC path.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtmon.c,v 1.20 1997/12/04 02:45:41 mike Exp mike $ (ARL)";
a301 66
char *find_paths[] = {
	"start_dir",		/* replaced at runtime */
	"/m/cad",
	"/n/vapor/m/cad",
	"/vld/mike",
	"/vld/butler",
	"/r/mike",
	"/home/army/mike/SGI/cad",
	NULL
};

/*
 *			F I N D
 *
 *  Given a partial path specification (e.g. ../.db.6d/moss.g) of a file,
 *  rummage around and try to find it in likely places,
 *  and change into its directory, so that
 *  texture maps and stuff from the same directory will all be found.
 *  A nasty huristic, and fairly ARL-specific, but necessary.
 */
void
find(fd, argc, argv)
int	fd;
int	argc;
char	**argv;
{
	char	**pp;
	char	*slash;

	if( argc != 2 )  {
		fprintf(ofp, "FAIL Usage: find filename\n");
		fflush(ofp);
		return;
	}

	find_paths[0] = start_dir;

	for( pp = find_paths; *pp != NULL; pp++ )  {
		if( chdir(*pp) < 0 )  {
			if(debug)  perror(*pp);
			continue;
		}
		if( access( argv[1], R_OK ) )  continue;

		/* OK, the path looks good, now get into the directory */
		if( (slash = strrchr( argv[1], '/' )) != NULL )  {
			*slash = '\0';
			if( chdir( argv[1] ) < 0 )  {
				perror(argv[1]);
				fprintf(ofp, "FAIL Unable to cd %s after cd %s\n", argv[1], *pp);
				fflush(ofp);
				return;
			}
			fprintf(ofp, "OK %s/%s %s\n", *pp, argv[1], slash+1 );
			fflush(ofp);
			return;
		}

		fprintf(ofp, "OK %s %s\n", *pp, argv[1] );
		fflush(ofp);
		return;
	}
	fprintf(ofp, "FAIL Unable to locate file %s\n", argv[1]);
	fflush(ofp);
}

d359 2
a360 2
		if( strcmp( argv[0], "find" ) == 0 )  {
			find(fd, argc, argv);
@


1.20
log
@Don't need to include IRIX64 6.4 header of <sched.h> here,
only in libbu
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtmon.c,v 1.19 1997/12/04 02:35:21 mike Exp mike $ (ARL)";
d309 1
d341 1
a341 1
			perror(*pp);
@


1.19
log
@When run from /etc/rc2.d, the path to machinetype.sh is not known.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtmon.c,v 1.18 1997/12/03 08:00:13 mike Exp mike $ (ARL)";
a74 5
#if IRIX >= 6
# include <sched.h>
struct sched_param param;
#endif

d113 1
a113 1
#if 0
d118 1
a118 1
#endif
@


1.18
log
@Check for tcl library.
Also check for ~user/bbin/bin
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtmon.c,v 1.17 1997/11/21 19:56:03 mike Exp mike $ (ARL)";
d147 2
a148 2
	if( (fp = popen( "machinetype.sh -m", "r" )) == NULL )  {
		machinetype = "???1";
d153 1
a153 1
		machinetype = "???2";
d157 1
@


1.17
log
@Improve hopes of being able to restart
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtmon.c,v 1.16 1997/11/21 19:40:09 mike Exp mike $ (ARL)";
d189 2
d198 1
d220 1
a220 1
	if( access( "/m/cad/libtcl/library/.", X_OK ) == 0 )  {
d223 2
a224 1
	} else if( access( "/n/vapor/m/cad/libtcl/library/.", X_OK ) == 0 )  {
d227 1
d232 1
d492 1
@


1.16
log
@Shortened hostname to "host".
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtmon.c,v 1.15 1997/11/21 19:35:17 mike Exp mike $ (ARL)";
d92 2
d510 3
d516 3
a518 3
	/* If that doesn't work either, just go back to what we were doing. */
	fprintf(stderr, "rtmon: unable to reload, continuing.\n");
	return;
a531 1
	int	listenfd;
@


1.15
log
@Use machinetype.sh to determine server's CPU type, and thus
to find "best" binary to run.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtmon.c,v 1.14 1997/11/21 04:52:20 mike Exp mike $ (ARL)";
d170 1
a170 1
	bu_vls_printf( &str, "hostname %s", our_hostname );
@


1.14
log
@Updated for new machine types
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtmon.c,v 1.13 1997/08/22 23:08:12 mike Exp mike $ (ARL)";
d90 1
d137 23
d171 1
d173 1
a173 1
	bu_vls_printf( &str, " pub_cpu %d", bu_get_public_cpus() );
d187 1
a187 1
CONST char *prog_paths[] = {
d189 2
a190 6
	"/m/cad/.remrt.m4i64",
	"/n/vapor/m/cad/.remrt.m4i64",
	"/m/cad/.remrt.m3i62",
	"/n/vapor/m/cad/.remrt.m3i62",
	"/m/cad/.remrt.7d",
	"/n/vapor/m/cad/.remrt.7d",
d207 1
a207 1
	CONST char **pp;
d230 2
a231 1
		bu_vls_strcpy( &path, *pp );
d400 3
@


1.13
log
@Port to Solaris
Fixed argc bug on 'find' command.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtmon.c,v 1.12 1997/08/22 22:04:35 mike Exp mike $ (ARL)";
d164 6
a169 2
	"/m/cad/.remrt.8d",
	"/n/vapor/m/cad/.remrt.8d",
@


1.12
log
@Don't bother with 1cpu_speed
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtmon.c,v 1.11 1997/08/19 07:00:47 mike Exp mike $ (ARL)";
d211 1
d213 4
d233 6
a238 1
		if( wait3( &stat, WNOHANG, NULL ) == pid )  {
d292 1
a292 1
find(fd, argv)
d294 1
d300 6
d392 1
a392 1
			find(fd, argv);
d587 1
d589 4
@


1.11
log
@Start child procs with /dev/null for fd 0,1,2.
Otherwise, first open will get fd0!
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtmon.c,v 1.10 1997/08/19 06:36:32 mike Exp $ (ARL)";
d151 2
d154 1
@


1.10
log
@Improved error handling.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtmon.c,v 1.9 1997/08/19 04:44:23 mike Exp mike $ (ARL)";
d213 4
@


1.9
log
@Ensure use by authorized hosts only.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtmon.c,v 1.8 1997/07/30 05:46:13 mike Exp mike $ (ARL)";
d95 1
d173 1
a173 1
run_prog(fd, argv, program)
d175 1
d224 8
a231 2
			if( WIFEXITED(stat) && WEXITSTATUS(stat) == 42 )   {
				continue;	/* Try another path */
d233 4
a236 2
			fprintf(ofp, "FAIL %s/%s died with status=x%x\n",
				bu_vls_addr(&path), program, stat);
d242 3
d326 1
d357 1
a357 1
		(void)bu_argv_from_string( argv, MAX_ARGS, bu_vls_addr(&str) );
d364 1
a364 1
			run_prog(fd, argv, "rtnode");
d456 1
a456 1
	run_prog( 2, main_argv, "rtmon" );
d477 1
@


1.8
log
@Added code to tell the difference between not being
able to exec the binary (wrong architecture) and
having it die young.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtmon.c,v 1.7 1997/07/30 04:58:55 mike Exp mike $ (ARL)";
a144 2
	our_hostname = get_our_hostname();	/* ihost.c */

d315 1
d322 16
@


1.7
log
@Added restart capability, added UID handling
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtmon.c,v 1.6 1997/07/29 22:49:51 mike Exp mike $ (ARL)";
d199 3
d207 4
a210 1
		if( fork() == 0 )  {
d214 4
a217 3
			perror("execv");
			/* If execv() succeeds, there is no return */
			/* Process will be reaped in wait3() in main() */
d220 14
d236 1
d239 1
a239 1
	fprintf(ofp, "FAIL Unable to locate %s executable\n", program);
d241 1
@


1.6
log
@Now reports 1cpu_speed
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtmon.c,v 1.5 1997/07/29 04:55:59 mike Exp mike $ (ARL)";
d37 2
d95 1
d160 1
a160 1
CONST char *rtnode_paths[] = {
d174 1
a174 1
run_rtnode(fd, argv)
d177 1
d184 1
a184 1
	argv[0] = "rtnode";
d198 1
a198 1
	for( pp = rtnode_paths; *pp != NULL; pp++ )  {
d200 2
a201 1
		bu_vls_strcat( &path, "/rtnode" );
d217 1
a217 1
	fprintf(ofp, "FAIL Unable to locate rtnode executable\n");
d312 1
a312 1
			run_rtnode(fd, argv);
d319 5
d355 57
d425 2
d434 2
d439 9
a447 4
	/* XXX Drop down to normal user privs */
	/* If "cmike" in /etc/passwd", use that, else use "mike" */
	setgid(42);
	setuid(53);
d455 3
d483 5
@


1.5
log
@Now has ability to "find" files, and chdir to their directory.
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtmon.c,v 1.4 1997/07/29 04:28:31 mike Exp mike $ (ARL)";
d117 10
@


1.4
log
@Added exec capability
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtmon.c,v 1.3 1997/07/23 22:47:35 mike Exp mike $ (ARL)";
d92 2
d158 1
d161 1
a161 1
run_rtnode(fd, cmd)
d163 1
a163 1
struct bu_vls	*cmd;
a166 2
#define MAX_ARGS	50
	char	*argv[MAX_ARGS+2];
a169 1
	(void)bu_argv_from_string( argv, MAX_ARGS, bu_vls_addr(cmd) );
d206 10
d217 48
d270 1
d277 2
d290 3
a292 1
		if( strncmp( bu_vls_addr(&str), "status", 6 ) == 0 )  {
d296 2
a297 2
		if( strncmp( bu_vls_addr(&str), "rtnode", 6 ) == 0 )  {
			run_rtnode(fd, &str);
d300 5
a304 1
		if( strncmp( bu_vls_addr(&str), "quit", 4 ) == 0 )
d362 6
@


1.3
log
@Added quit command
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtmon.c,v 1.2 1997/07/02 00:25:20 mike Exp mike $ (ARL)";
d89 3
d145 10
d156 51
d211 1
a217 2
	FILE		*ifp;
	FILE		*ofp;
d231 4
@


1.2
log
@Beginnings of commandline processing
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtmon.c,v 1.1 1997/07/01 21:57:35 mike Exp mike $ (ARL)";
d170 2
@


1.1
log
@Initial revision
@
text
@d28 1
a28 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
d94 1
a94 8
 *			B U _ S E T _ R E A L T I M E
 *
 *  If possible, mark this process for real-time scheduler priority.
 *  Will often need root privs.
 *
 *  Returns -
 *	1	realtime priority obtained
 *	0	running with non-realtime scheduler behavior
d96 6
a101 2
int
bu_set_realtime()
d103 2
a104 3
#	if IRIX >= 6
	{
		int	policy;
d106 4
a109 15
		if( (policy = sched_getscheduler(0)) >= 0 )  {
			if( policy == SCHED_RR )
				return 1;
		}

		sched_getparam( 0, &param );

		if ( sched_setscheduler( 0,
			SCHED_RR,		/* policy */
			&param
		    ) >= 0 )  {
		    	return 1;		/* realtime */
		}
	 	perror("bu_set_realtime(): sched_setscheduler");
		/* Fall through to return 0 */
d111 3
a113 2
#	endif
	return 0;
d117 1
a117 4
 *			S E R V E R _ P R O C E S S
 *
 *  Manage all conversation on one connection.
 *  There will be a separate process for each open connection.
d120 1
a120 1
server_process(fd)
d130 1
a130 7
	bu_vls_printf( &str, " ncpu %d realt %d",
		bu_avail_cpus(),
		bu_set_realtime()
		);

#if 0
	bu_vls_printf( &str, " load %ld", bu_get_load_average() );
d132 3
a134 1
#endif
d139 34
d219 1
a219 1
	/* Set real-time scheduler priority */
d221 5
@
