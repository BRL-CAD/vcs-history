head	1.65;
access;
symbols
	rel-4-5:1.50
	ctj-4-5-post:1.26
	ctj-4-5-pre:1.26;
locks; strict;
comment	@ * @;


1.65
date	98.11.10.04.54.44;	author mike;	state dead;
branches;
next	1.64;

1.64
date	98.10.29.01.55.27;	author jra;	state Exp;
branches;
next	1.63;

1.63
date	98.09.22.00.30.18;	author mike;	state Exp;
branches;
next	1.62;

1.62
date	98.06.25.07.28.06;	author mike;	state Exp;
branches;
next	1.61;

1.61
date	98.06.09.02.28.35;	author mike;	state Exp;
branches;
next	1.60;

1.60
date	98.05.22.20.07.32;	author mike;	state Exp;
branches;
next	1.59;

1.59
date	98.05.22.19.48.31;	author mike;	state Exp;
branches;
next	1.58;

1.58
date	98.05.22.05.48.14;	author mike;	state Exp;
branches;
next	1.57;

1.57
date	98.05.22.04.56.12;	author mike;	state Exp;
branches;
next	1.56;

1.56
date	98.05.19.02.05.44;	author mike;	state Exp;
branches;
next	1.55;

1.55
date	98.05.13.02.54.37;	author mike;	state Exp;
branches;
next	1.54;

1.54
date	98.05.12.22.51.14;	author mike;	state Exp;
branches;
next	1.53;

1.53
date	98.04.29.06.05.31;	author mike;	state Exp;
branches;
next	1.52;

1.52
date	98.04.28.04.35.32;	author mike;	state Exp;
branches;
next	1.51;

1.51
date	98.04.28.02.13.15;	author mike;	state Exp;
branches;
next	1.50;

1.50
date	97.12.31.09.09.51;	author mike;	state Exp;
branches;
next	1.49;

1.49
date	97.12.31.05.54.37;	author mike;	state Exp;
branches;
next	1.48;

1.48
date	97.12.16.08.10.29;	author mike;	state Exp;
branches;
next	1.47;

1.47
date	97.12.16.07.48.29;	author mike;	state Exp;
branches;
next	1.46;

1.46
date	97.12.16.00.50.01;	author mike;	state Exp;
branches;
next	1.45;

1.45
date	97.12.16.00.29.26;	author mike;	state Exp;
branches;
next	1.44;

1.44
date	97.11.22.04.06.31;	author mike;	state Exp;
branches;
next	1.43;

1.43
date	97.11.20.23.03.36;	author mike;	state Exp;
branches;
next	1.42;

1.42
date	97.11.18.07.01.14;	author mike;	state Exp;
branches;
next	1.41;

1.41
date	97.11.17.19.11.17;	author mike;	state Exp;
branches;
next	1.40;

1.40
date	97.11.14.02.47.41;	author mike;	state Exp;
branches;
next	1.39;

1.39
date	97.08.26.07.04.34;	author mike;	state Exp;
branches;
next	1.38;

1.38
date	97.08.26.05.55.00;	author mike;	state Exp;
branches;
next	1.37;

1.37
date	97.08.26.04.26.05;	author mike;	state Exp;
branches;
next	1.36;

1.36
date	97.08.21.00.58.54;	author mike;	state Exp;
branches;
next	1.35;

1.35
date	97.08.20.22.35.11;	author mike;	state Exp;
branches;
next	1.34;

1.34
date	97.08.20.07.14.54;	author mike;	state Exp;
branches;
next	1.33;

1.33
date	97.08.19.07.01.18;	author mike;	state Exp;
branches;
next	1.32;

1.32
date	97.07.01.23.38.04;	author mike;	state Exp;
branches;
next	1.31;

1.31
date	97.07.01.21.57.11;	author mike;	state Exp;
branches;
next	1.30;

1.30
date	97.06.26.00.52.22;	author mike;	state Exp;
branches;
next	1.29;

1.29
date	97.06.25.02.41.35;	author mike;	state Exp;
branches;
next	1.28;

1.28
date	97.06.23.04.57.43;	author mike;	state Exp;
branches;
next	1.27;

1.27
date	97.06.13.23.28.16;	author mike;	state Exp;
branches;
next	1.26;

1.26
date	97.05.28.04.39.06;	author mike;	state Exp;
branches;
next	1.25;

1.25
date	97.05.28.03.31.15;	author mike;	state Exp;
branches;
next	1.24;

1.24
date	97.05.27.21.22.07;	author mike;	state Exp;
branches;
next	1.23;

1.23
date	97.05.20.17.04.26;	author mike;	state Exp;
branches;
next	1.22;

1.22
date	97.03.07.10.50.31;	author mike;	state Exp;
branches;
next	1.21;

1.21
date	97.03.06.10.09.38;	author mike;	state Exp;
branches;
next	1.20;

1.20
date	97.03.06.09.08.03;	author mike;	state Exp;
branches;
next	1.19;

1.19
date	97.03.05.07.30.22;	author mike;	state Exp;
branches;
next	1.18;

1.18
date	97.03.05.07.20.23;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	97.03.05.06.59.10;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	97.01.08.02.26.07;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	97.01.07.04.05.21;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	97.01.04.05.17.14;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	97.01.04.05.02.13;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	97.01.04.03.35.40;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	97.01.04.03.24.30;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	96.08.27.05.30.45;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	96.08.27.05.27.19;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	95.08.24.03.57.00;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	95.08.24.03.16.46;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	95.08.24.01.44.54;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	95.08.23.02.05.30;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	95.08.23.01.27.14;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	95.07.15.07.52.19;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	95.07.15.07.11.42;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	95.07.15.06.11.32;	author mike;	state Exp;
branches;
next	;


desc
@Per-node compute server process for real-time ray-tracer project.
@


1.65
log
@Moved real-time ray-tracer over into "SWISS" directory
@
text
@/*
 *			R T N O D E . C
 *
 *  The per-node ray-tracing engine for the real-time ray-tracing project.
 *
 *  Author -
 *	Michael John Muuss
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1995 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */
#ifndef lint
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/remrt/rtnode.c,v 1.64 1998/10/29 01:55:27 jra Exp mike $ (ARL)";
#endif

#include "conf.h"

#if IRIX == 4
#define _BSD_COMPAT	1
#endif

#include <stdio.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#ifdef HAVE_STDARG_H
# include <stdarg.h>
#else
# include <varargs.h>
#endif

#include <sys/time.h>

#ifndef SYSV
# include <sys/ioctl.h>
# include <sys/resource.h>
#endif

#ifdef HAVE_SYS_SOCKET_H
# include <sys/socket.h>
#endif

#include <signal.h>

#undef	VMIN
#include "machine.h"
#include "vmath.h"
#include "rtlist.h"
#include "bu.h"
#include "externs.h"
#include "raytrace.h"
#include "pkg.h"
#include "fb.h"
#include "tcl.h"

#include "../librt/debug.h"
#include "../rt/mathtab.h"
#include "../rt/ext.h"
#include "../rt/rdebug.h"

#ifndef R_OK
#define R_OK	0x04
#endif

/***** Variables shared with viewing model *** */
FBIO		*fbp = FBIO_NULL;	/* Framebuffer handle */
FILE		*outfp = NULL;		/* optional pixel output file */
mat_t		view2model;
mat_t		model2view;
/***** end of sharing with viewing model *****/

/* Variables imported from view.c */
extern int	ibackground[3];			/* integer 0..255 version */
extern int	inonbackground[3];		/* integer non-background */

extern void grid_setup();
extern void worker();

/***** variables shared with worker() ******/
struct application ap;
vect_t		left_eye_delta;
/***** end variables shared with worker() *****/

/***** variables shared with do.c *****/
char		*beginptr = NULL;	/* sbrk() at start of program */
/***** end variables shared with do.c *****/

/* Variables shared within mainline pieces */
extern fastf_t	rt_dist_tol;		/* Value for rti_tol.dist */
extern fastf_t	rt_perp_tol;		/* Value for rti_tol.perp */
int		rdebug = 0;		/* RT program debugging (not library) */

/* State flags */
static int	seen_dirbuild = 0;
static int	seen_gettrees = 0;
static int	seen_matrix = 0;

static char	*title_file = NULL;	/* name of file and first object */
static char	*title_obj = NULL;

#define MAX_WIDTH	(16*1024)

static int	nlines_line;		/* how many scanlines worth in red_line */
static unsigned char	*red_line;
static unsigned char	*grn_line;
static unsigned char	*blu_line;
extern int	curframe;		/* shared with do.c */

static int	avail_cpus = 0;		/* # of cpus avail on this system */
static int	max_cpus = 0;		/* max # cpus for use, <= avail_cpus */

Tcl_Interp	*interp = NULL;

char		*node_search_path = NULL; /* Filled in by Tcl command */

int		print_on = 1;

/*
 *  Package handlers for the RTSYNC protocol.
 *  Numbered differently, to prevent confusion with other PKG protocols.
 */
#define RTSYNCMSG_PRINT	 999	/* StoM:  Diagnostic message */
#define RTSYNCMSG_ALIVE	1001	/* StoM:  protocol version, # of processors */
#define RTSYNCMSG_OPENFB 1002	/* both:  width height framebuffer */
#define RTSYNCMSG_DIRBUILD 1003	/* both:  database */
#define RTSYNCMSG_GETTREES 1004	/* both:  treetop(s) */
#define RTSYNCMSG_CMD	1006	/* MtoS:  Any Tcl command */
#define RTSYNCMSG_POV	1007	/* MtoS:  pov, min_res, start&end lines */
#define RTSYNCMSG_HALT	1008	/* MtoS:  abandon frame & xmit, NOW */
#define RTSYNCMSG_DONE	1009	/* StoM:  halt=0/1, res, elapsed, etc... */

void	ph_default();
void	rtsync_ph_pov();
void	rtsync_ph_openfb();
void	rtsync_ph_dirbuild();
void	rtsync_ph_gettrees();
void	rtsync_ph_halt();
void	rtsync_ph_cmd();
static struct pkg_switch rtsync_pkgswitch[] = {
	{ RTSYNCMSG_POV,	rtsync_ph_pov, "POV" },
	{ RTSYNCMSG_ALIVE,	ph_default,	"ALIVE" },
	{ RTSYNCMSG_HALT,	rtsync_ph_halt, "HALT" },
	{ RTSYNCMSG_CMD,	rtsync_ph_cmd, "CMD" },
	{ RTSYNCMSG_OPENFB,	rtsync_ph_openfb, "RTNODE open(ed) fb" },
	{ RTSYNCMSG_GETTREES,	rtsync_ph_gettrees, "RTNODE prep(ed) db" },
	{ RTSYNCMSG_DIRBUILD,	rtsync_ph_dirbuild, "RTNODE dirbuilt/built" },
	{ RTSYNCMSG_DONE,	ph_default,	"DONE" },
	{ RTSYNCMSG_PRINT,	ph_default,	"Log Message" },
	{ 0,			0,		(char *)0 }
};

struct pkg_conn *pcsrv = (struct pkg_conn *)NULL; /* PKG connection to server */
char		*control_host = NULL;		/* name of host running controller */
char		*tcp_port = NULL;		/* TCP port on control_host */

int	debug = 0;		/* 0=off, 1=debug, 2=verbose */

int	debugimage = 0;
int	test_fb_speed = 0;
char	*framebuffer_name = NULL;

CONST char srv_usage[] = "Usage: rtnode [-d] control-host tcp-port [cmd]\n";

/*
 *			C M D _ G E T _ P T R
 *
 *  Returns an appropriately-formatted string that can later be reinterpreted
 *  (using atol() and a cast) as a a pointer.
 */

int
cmd_get_ptr(clientData, interp, argc, argv)
ClientData	clientData;
Tcl_Interp     *interp;
int		argc;
char	      **argv;
{
	char buf[128];

	sprintf( buf, "%ld", (long)(*((void **)clientData)) );
	Tcl_AppendResult( interp, buf, (char *)NULL );
	return TCL_OK;
}

/*
 *			M A I N
 */
int
main(argc, argv)
int argc;
char **argv;
{
	register int	n;
	double		load = 0;

fprintf(stderr,
"main: pcsrv=x%lx, control_host=x%lx, tcp_port=x%lx\n",
pcsrv, control_host, tcp_port);
	use_air = 1;	/* air & clouds are generally desired */
	if( argc < 2 )  {
		fprintf(stderr, srv_usage);
		exit(1);
	}
	while( argv[1][0] == '-' )  {
		if( strcmp( argv[1], "-d" ) == 0 )  {
			debug++;
		} else if( strcmp( argv[1], "-x" ) == 0 )  {
			sscanf( argv[2], "%x", &rt_g.debug );
			argc--; argv++;
		} else if( strcmp( argv[1], "-X" ) == 0 )  {
			sscanf( argv[2], "%x", &rdebug );
			argc--; argv++;
		} else if( strcmp( argv[1], "-U" ) == 0 )  {
			sscanf( argv[2], "%d", &use_air );
			argc--; argv++;
		} else {
			fprintf(stderr, srv_usage);
			exit(3);
		}
		argc--; argv++;
	}
	if( argc != 3 && argc != 4 )  {
		fprintf(stderr, srv_usage);
		exit(2);
	}

	control_host = argv[1];
	tcp_port = argv[2];

	/* Note that the LIBPKG error logger can not be
	 * "bu_log", as that can cause bu_log to be entered recursively.
	 * Given the special version of bu_log in use here,
	 * that will result in a deadlock in bu_semaphore_acquire(res_syscall)!
	 *  libpkg will default to stderr via pkg_errlog(), which is fine.
	 */
	pcsrv = pkg_open( control_host, tcp_port, "tcp", "", "",
		rtsync_pkgswitch, NULL );
	if( pcsrv == PKC_ERROR )  {
		fprintf(stderr, "rtnode: unable to contact %s, port %s\n",
			control_host, tcp_port);
		exit(1);
	}

	if( argc == 4 )  {
#if 0
		/* Slip one command to dispatcher */
		(void)pkg_send( MSG_CMD, argv[3], strlen(argv[3])+1, pcsrv );

		/* Prevent chasing the package with an immediate TCP close */
		sleep(1);

#endif
		pkg_close( pcsrv );
		exit(0);
	}

	if( pcsrv->pkc_fd <= 2 )  bu_log("ERROR pcsrv->pkc_fd = %d\n", pcsrv->pkc_fd);

#if BSD == 43
	{
		int	val = 32767;
		n = setsockopt( pcsrv->pkc_fd, SOL_SOCKET,
			SO_SNDBUF, (char *)&val, sizeof(val) );
		if( n < 0 )  perror("setsockopt: SO_SNDBUF");
	}
#endif

	if( !debug )  {
		/* A fresh process */
		if (fork())
			exit(0);

		/* Go into our own process group */
		n = getpid();

		/* SysV uses setpgrp with no args and it can't fail */
#if (defined(__STDC__) || defined(SYSV)) && !defined(_BSD_COMPAT)
		if( setpgid( n, n ) < 0 )
			perror("setpgid");
#else
		if( setpgrp( n, n ) < 0 )
			perror("setpgrp");
#endif

		/* Deal with CPU limits on "those kinds" of systems */
		if( bu_cpulimit_get() > 0 )  {
			bu_cpulimit_set( 9999999 );
		}

		/* Close off the world */
		fclose(stdin);
		fclose(stdout);
		fclose(stderr);

		(void)close(0);
		(void)close(1);
		(void)close(2);

		/* For stdio & perror safety, reopen 0,1,2 */
		(void)open("/dev/null", 0);	/* to fd 0 */
		(void)dup(0);			/* to fd 1 */
		(void)dup(0);			/* to fd 2 */

#ifndef SYSV
		n = open("/dev/tty", 2);
		if (n >= 0) {
			(void)ioctl(n, TIOCNOTTY, 0);
			(void)close(n);
		}
#endif
	}

	/*
	 *  Now that the fork() has been done, it is safe to initialize
	 *  the parallel processing support.
	 */

	beginptr = (char *) sbrk(0);

	avail_cpus = bu_avail_cpus();
	max_cpus = bu_get_public_cpus();

	if( bu_set_realtime() )  {
		/* We have realtime priority, use all but one CPU */
		/* (To leave time for OS to handle NFS, ILMI, etc.) */
		max_cpus = avail_cpus-1;
	} else {
		/*
		 *  Non-realtime sched., we compete with everybody else.
		 *  As our duty-cycle is less than 50%,
		 *  try to use 'em all for those moments we want to compute.
		 *  User can interactively decrement if he wants.
		 */
		if( avail_cpus < 8 )
			max_cpus = avail_cpus;
		else if( avail_cpus < 16 )
			max_cpus = avail_cpus - 1;
		else if( avail_cpus < 32 )
			max_cpus = avail_cpus - 2;
		else if( avail_cpus < 48 )
			max_cpus = avail_cpus - 3;
		else
			max_cpus = avail_cpus - 4;
	}

	/* Need to set rtg_parallel non_zero here for RES_INIT to work */
	npsw = max_cpus;
	if( npsw > 1 )  {
		rt_g.rtg_parallel = 1;
	} else
		rt_g.rtg_parallel = 0;
	bu_semaphore_init( RT_SEM_LAST );

	load = bu_get_load_average();
	bu_log("load average = %f, using %d of %d cpus\n",
		load,
		npsw, avail_cpus );
	if( npsw <= 0 )  {
		pkg_close(pcsrv);
		exit(0);
	}

	/*
	 *  Initialize all the per-CPU memory resources.
	 *  Go for the max, as TCL interface may change npsw as we run,
	 *  up or down.
	 */
	for( n=0; n < MAX_PSW; n++ )  {
		rt_init_resource( &resource[n], n );
		rand_init( resource[n].re_randptr, n );
	}

	/* Initialize the Tcl interpreter */
	interp = Tcl_CreateInterp();
	/* This runs the init.tcl script */
bu_log("before Tcl_Init\n");
	if( Tcl_Init(interp) == TCL_ERROR )  {
		bu_log("Tcl_Init error %s\n", interp->result);
		bu_bomb("rtnode: Unable to initialize TCL.  Run 'new_tk'?\n");
	}
bu_log("after Tcl_Init\n");
	bu_tcl_setup(interp);
	bn_tcl_setup(interp);
	rt_tcl_setup(interp);
	sh_tcl_setup(interp);
	/* Don't allow unknown commands to be fed to the shell */
	Tcl_SetVar( interp, "tcl_interactive", "0", TCL_GLOBAL_ONLY );

	Tcl_LinkVar(interp, "test_fb_speed", (char *)&test_fb_speed, TCL_LINK_INT);
	Tcl_LinkVar(interp, "debugimage", (char *)&debugimage, TCL_LINK_INT);
	Tcl_LinkVar(interp, "fullfloat_mode", (char *)&fullfloat_mode, TCL_LINK_INT);
	Tcl_LinkVar(interp, "reproject_mode", (char *)&reproject_mode, TCL_LINK_INT);
	Tcl_LinkVar(interp, "curframe", (char *)&curframe, TCL_LINK_INT);
	Tcl_LinkVar(interp, "print_on", (char *)&print_on, TCL_LINK_INT);
	Tcl_LinkVar(interp, "npsw", (char *)&npsw, TCL_LINK_INT);
	Tcl_LinkVar(interp, "node_search_path", (char *)&node_search_path, TCL_LINK_STRING );

	/* Send our version string */
#define PROTOCOL_VERSION	"Version1.0"
	{
		char buf[512];
		sprintf(buf, "%d %s", npsw, PROTOCOL_VERSION );
		if( pkg_send( RTSYNCMSG_ALIVE, buf, strlen(buf)+1, pcsrv ) < 0 )  {
			fprintf(stderr,"pkg_send RTSYNCMSG_ALIVE error\n");
			exit(1);
		}
	}
	if( debug&2 )  fprintf(stderr, "PROTOCOL_VERSION='%s'\n", PROTOCOL_VERSION );


	for(;;)  {
		register struct pkg_queue	*lp;
		fd_set ifds;
		struct timeval tv;

		/* First, process any packages in library buffers */
		if( pkg_process( pcsrv ) < 0 )  {
			bu_log("pkg_get error\n");
			break;
		}

		/* Second, see if any input to read */
		FD_ZERO(&ifds);
		FD_SET(pcsrv->pkc_fd, &ifds);
		tv.tv_sec = 5;
		tv.tv_usec = 0L;

		/* XXX fbp */

		if( select(pcsrv->pkc_fd+1, &ifds, (fd_set *)0, (fd_set *)0,
			&tv ) != 0 )  {
			n = pkg_suckin(pcsrv);
			if( n < 0 )  {
				bu_log("pkg_suckin error\n");
				break;
			} else if( n == 0 )  {
				/* EOF detected */
				break;
			} else {
				/* All is well */
			}
		}

		/* Third, process any new packages in library buffers */
		if( pkg_process( pcsrv ) < 0 )  {
			bu_log("pkg_get error\n");
			break;
		}

		/* Finally, more work may have just arrived, check our list */
	}
}


void
ph_restart(pc, buf)
register struct pkg_conn *pc;
char *buf;
{

	if(debug)fprintf(stderr,"ph_restart %s\n", buf);
	bu_log("Restarting\n");
	pkg_close(pcsrv);
	execlp( "rtnode", "rtnode", control_host, tcp_port, (char *)0);
	perror("rtnode");
	exit(1);
}

/* -------------------- */

void
rtsync_timeout(foo)
int	foo;
{
	bu_log("rtnode: fb_open(%s) timeout -- unable to open remote framebuffer.\n",
		framebuffer_name ? framebuffer_name : "NULL" );
	bu_bomb("rtnode: Ensure BRL-CAD Release 5.0 fbserv is running. Aborting.\n");
}

/*
 *			R T S Y N C _ P H _ O P E N F B
 *
 *  Format:  width, height, framebuffer
 */
void
rtsync_ph_openfb(pc, buf)
register struct pkg_conn *pc;
char			*buf;
{
	char	*hp;
	int	w, h;

	if( debug )  fprintf(stderr, "rtsync_ph_openfb: %s\n", buf );

	hp = strchr(buf, ' ');
	*hp++ = '\0';
	framebuffer_name = strchr(hp, ' ');
	*framebuffer_name++ = '\0';

	w = atoi(buf);
	h = atoi(hp);

	if( debug )  fprintf(stderr, "rtsync_ph_openfb: %d %d %s\n",
		w, h, framebuffer_name );

	(void)signal( SIGALRM, rtsync_timeout );
	alarm(7);
	if( (fbp = fb_open( framebuffer_name, w, h ) ) == 0 )  {
		bu_log("rtnode: fb_open(%s, %d, %d) failed\n", framebuffer_name, w, h );
		exit(1);
	}
	alarm(0);

	if( w <= 0 || fb_getwidth(fbp) < w )
		width = fb_getwidth(fbp);
	else
		width = w;
	if( h <= 0 || fb_getheight(fbp) < h )
		height = fb_getheight(fbp);
	else
		height = h;

	if( pkg_send( RTSYNCMSG_OPENFB, NULL, 0,
	    pcsrv ) < 0 )
		fprintf(stderr,"RTSYNCMSG_OPENFB reply error\n");

	/* Build test-pattern scanlines, sized to fit */
	nlines_line = 512;
	red_line = (unsigned char *)bu_calloc( nlines_line*(width+1), 3, "red_line" );
	grn_line = (unsigned char *)bu_calloc( nlines_line*(width+1), 3, "grn_line" );
	blu_line = (unsigned char *)bu_calloc( nlines_line*(width+1), 3, "blu_line" );
	for( w = width*nlines_line-1; w >= 0; w-- )  {
		red_line[w*3+0] = 255;
		grn_line[w*3+1] = 255;
		blu_line[w*3+2] = 255;
	}

	/* Do NOT free 'buf', it contains *framebuffer_name string */
}

/*
 *			R T S Y N C _ P H _ D I R B U I L D
 *
 *  The only formal argument is the name of the database file,
 *  which may be a full or partial path specification.
 *
 *	path_dir / arg_dir / arg_file.
 *
 *  Implicit argument:  The Tcl list variable named "node_search_path",
 *  which will have been set by an earlier RTSYNCMSG_CMD transaction.
 *
 *  Make the current directory be the directory of the actual database
 *  before opening it.
 */
void
rtsync_ph_dirbuild(pc, buf)
register struct pkg_conn *pc;
char *buf;
{
	struct rt_i *rtip;
	char		*arg_dir;
	char		*arg_file;
	char		*slash;
	char		**path_argv;
	int		path_argc;
	struct bu_vls	path;
	Tcl_DString	str;
	int		i;

	if( debug )  fprintf(stderr, "rtsync_ph_dirbuild: %s\n", buf );

	if( seen_dirbuild )  {
		bu_log("rtsync_ph_dirbuild:  MSG_DIRBUILD already seen, ignored\n");
		(void)free(buf);
		return;
	}

	if( (slash = strrchr( buf, '/' )) != NULL )  {
		*slash = '\0';
		arg_dir = buf;
		arg_file = slash+1;
	} else {
		arg_dir = "";
		arg_file = buf;
	}

	/* Process each path possibility, in turn */
	if( Tcl_SplitList( interp, node_search_path, &path_argc, &path_argv) != TCL_OK )
		rt_bomb("Tcl_SplitList failure on node_search_path\n");

	Tcl_DStringInit( &str );
	bu_vls_init( &path );
	for( i=0; i<path_argc; i++ )  {
		char *elem;

		bu_vls_trunc( &path, 0 );		
		elem = Tcl_TildeSubst( interp, path_argv[i], &str );
		if( elem == NULL )  {
			bu_log("Tcl_TildeSubst() failed on %s\n", path_argv[i]);
			continue;
		}
		bu_vls_printf( &path, "%s/%s", elem, arg_dir );
		Tcl_DStringFree(&str);		/* done with 'elem' */

		if( chdir(bu_vls_addr(&path)) < 0 )  {
			if(debug)  perror(bu_vls_addr(&path));
			continue;
		}

		/* Got to the directory, see if file is there.  (Full path) */
		bu_vls_printf( &path, "/%s", arg_file );

		if( access( bu_vls_addr(&path), R_OK ) )  {
			if(debug)  perror(bu_vls_addr(&path));
			continue;
		}

		/* Success */
		goto ok;

	}
	rt_bomb("Unable to locate geometry database\n");
ok:
	free( (char *)path_argv);

	title_file = bu_vls_strgrab(&path);
	bu_log("%s\n", title_file);

	/*
	 *  Build in-memory directory (table of contents) of GED database.
	 */
	if( (rtip=rt_dirbuild( title_file, NULL, 0 )) == RTI_NULL )  {
		bu_log("rtsync_ph_dirbuild:  rt_dirbuild(%s) failure\n", title_file);
		exit(2);
	}
	ap.a_rt_i = rtip;
	seen_dirbuild = 1;

	if( pkg_send( RTSYNCMSG_DIRBUILD,
	    rtip->rti_dbip->dbi_title, strlen(rtip->rti_dbip->dbi_title)+1, pcsrv ) < 0 )
		fprintf(stderr,"RTSYNCMSG_DIRBUILD reply error\n");

	(void)Tcl_CreateCommand(interp, "get_dbip", cmd_get_ptr,
		(ClientData)&ap.a_rt_i->rti_dbip, (Tcl_CmdDeleteProc *)NULL);
	(void)Tcl_CreateCommand(interp, "get_rtip", cmd_get_ptr,
		(ClientData)&ap.a_rt_i, (Tcl_CmdDeleteProc *)NULL);

	{
		struct bu_vls	cmd;
		bu_vls_init(&cmd);
		bu_vls_strcpy(&cmd, "wdb_open .inmem inmem [get_dbip]]");
		/* Tcl interpreter will write nulls into cmd string */
		if( Tcl_Eval(interp, bu_vls_addr(&cmd) ) != TCL_OK )  {
			bu_log("%s\n%s\n",
		    		interp->result,
				Tcl_GetVar(interp,"errorInfo", TCL_GLOBAL_ONLY) );
		}
		bu_vls_free(&cmd);
	}
	free( (char *)buf);
}

/*
 *			R T S Y N C _ P H _ G E T T R E E S
 *
 *  Each word in the command buffer is the name of a treetop.
 */
void
rtsync_ph_gettrees(pc, buf)
register struct pkg_conn *pc;
char *buf;
{
#define MAXARGS 1024
	char	*argv[MAXARGS+1];
	int	argc;
	struct rt_i *rtip = ap.a_rt_i;

	RT_CK_RTI(rtip);

	if( debug )  fprintf(stderr, "rtsync_ph_gettrees: %s\n", buf );

	/* Copy values from command line options into rtip */
	rtip->useair = use_air;
	rtip->rti_space_partition = space_partition;
	rtip->rti_nu_gfactor = nu_gfactor;
	if( rt_dist_tol > 0 )  {
		rtip->rti_tol.dist = rt_dist_tol;
		rtip->rti_tol.dist_sq = rt_dist_tol * rt_dist_tol;
	}
	if( rt_perp_tol > 0 )  {
		rtip->rti_tol.perp = rt_perp_tol;
		rtip->rti_tol.para = 1 - rt_perp_tol;
	}

	if( (argc = rt_split_cmd( argv, MAXARGS, buf )) <= 0 )  {
		/* No words in input */
		(void)free(buf);
		return;
	}
	title_obj = bu_strdup(argv[0]);

	if( rtip->needprep == 0 )  {
		/* First clean up after the end of the previous frame */
		if(debug)bu_log("Cleaning previous model\n");
		/* Allow lighting model to clean up (e.g. lights, materials, etc) */
		view_cleanup( rtip );
		rt_clean(rtip);
		if(rdebug&RDEBUG_RTMEM_END)
			bu_prmem( "After rt_clean" );
	}

	/* Load the desired portion of the model */
	if( rt_gettrees(rtip, argc, (CONST char **)argv, npsw) < 0 )
		fprintf(stderr,"rt_gettrees(%s) FAILED\n", argv[0]);

	/* In case it changed from startup time via an OPT command */
	if( npsw > 1 )  {
		rt_g.rtg_parallel = 1;
	} else
		rt_g.rtg_parallel = 0;

	beginptr = (char *) sbrk(0);

	seen_gettrees = 1;
	(void)free(buf);

	/*
	 * Initialize application -- do mlib_init().
	 */
	(void)view_init( &ap, title_file, title_obj, 0 );

	do_prep( rtip );

	if( rtip->nsolids <= 0 )  {
		bu_log("ph_matrix: No solids remain after prep.\n");
		exit(3);
	}

	/* Acknowledge that we are ready */
	if( pkg_send( RTSYNCMSG_GETTREES,
	    title_obj, strlen(title_obj)+1, pcsrv ) < 0 )
		fprintf(stderr,"RTSYNCMSG_GETTREES reply error\n");
}

/*
 *			R T S Y N C _ P H _ P O V
 *
 *
 *  Format:  min_res, start_line, end_line, pov...
 */
void
rtsync_ph_pov(pc, buf)
register struct pkg_conn *pc;
char			*buf;
{
	register struct rt_i *rtip = ap.a_rt_i;
	char	*argv_buf[MAXARGS+1];
	char	**argv = argv_buf;
	int	argc;
	int	min_res;
	int	start_line;
	int	end_line;
	quat_t	orient;
	mat_t	toViewcenter;
	fastf_t	viewscale;
	point_t	viewcenter_model;
	point_t	eye_screen;
	int	saved_print_on = print_on;
	char	obuf[128];
	double	pr_elapsed_time;	/* reprojection */
	double	rt_elapsed_time;
	double	fb_elapsed_time;
	double	ck_elapsed_time;
	int	reproj_percent = 0;

	RT_CK_RTI(rtip);

	if( debug )  fprintf(stderr, "rtsync_ph_pov: %s\n", buf );

	if( (argc = rt_split_cmd( argv_buf, MAXARGS, buf )) <= 0 )  {
		/* No words in input */
		bu_log("Null POV command\n");
		(void)free(buf);
		return;
	}

	/* Start options in a known state */
	AmbientIntensity = 0.4;
	hypersample = 0;
	jitter = 0;
	eye_backoff = 1.414;
	aspect = 1;
	stereo = 0;
#if 0
	width = height = 0;
	cell_width = cell_height = 0;
	lightmodel = 0;
	incr_mode = 0;
	rt_dist_tol = 0;
	rt_perp_tol = 0;

	process_cmd( buf );
#endif

	min_res = atoi(argv[0]);
	start_line = atoi(argv[1]);
	end_line = atoi(argv[2]);

	VSET( viewcenter_model, atof(argv[3]), atof(argv[4]), atof(argv[5]) );
	VSET( orient, atof(argv[6]), atof(argv[7]), atof(argv[8]) );
	orient[3] = atof(argv[9]);
	viewscale = atof(argv[10]);
	/* 11...13 for eye_pos_screen[] */
	if( argc <= 14 )  {
		static int first = 1;
		if(first)  {
			bu_log("rtnode: old format POV message received, no perspective\n");
			first = 0;
		}
		rt_perspective = 0;
	} else {
		rt_perspective = atof(argv[14]);
	}
	if( rt_perspective < 0 || rt_perspective > 179 )  rt_perspective = 0;

	curframe++;

	viewsize = 2 * viewscale;
	bn_mat_idn( Viewrotscale );
	quat_quat2mat( Viewrotscale, orient );

	bn_mat_idn( toViewcenter );
	MAT_DELTAS_VEC_NEG( toViewcenter, viewcenter_model );
	bn_mat_mul( model2view, Viewrotscale, toViewcenter );
	Viewrotscale[15] = viewscale;
	model2view[15] = viewscale;
	bn_mat_inv( view2model, model2view );

	VSET( eye_screen, 0, 0, 1 );
	MAT4X3PNT( eye_model, view2model, eye_screen );

	seen_matrix = 1;

	grid_setup();

	/* initialize lighting, set buf_mode=BUFMODE_DYNAMIC */
	rt_prep_timer();
	fullfloat_mode = 1;	/* sets buf_mode=BUFMODE_FULLFLOAT */
	print_on = 0;		/* Disable bu_log ! */
	view_2init( &ap );
	print_on = saved_print_on;	/* re-enable bu_log */
	(void)rt_get_timer( (struct bu_vls *)NULL, &pr_elapsed_time  );

	if( reproj_cur > 0 && reproj_max > 0 )
		reproj_percent = (int)(((double)reproj_cur)/reproj_max*100);

	rtip->nshots = 0;
	rtip->nmiss_model = 0;
	rtip->nmiss_tree = 0;
	rtip->nmiss_solid = 0;
	rtip->nmiss = 0;
	rtip->nhits = 0;
	rtip->rti_nrays = 0;

	rt_prep_timer();

	if( test_fb_speed )  {
		unsigned char	*buf;
		int	y;

		rt_elapsed_time = 0;

		/* Write out colored lines. */
		switch( curframe%3 )  {
		case 0:
			buf = red_line;
			break;
		case 1:
			buf = grn_line;
			break;
		case 2:
			buf = blu_line;
			break;
		}
		for( y=start_line; y <= end_line; )  {
			int	todo;
			todo = end_line - y + 1;
			if( todo > nlines_line )  todo = nlines_line;
			fb_writerect( fbp, 0, y, width, todo, buf );
			y += todo;
		}
	} else {
		if( reproject_mode != 2 )
			do_run( start_line*width, end_line*width+width-1 );
		(void)rt_get_timer( (struct bu_vls *)NULL, &rt_elapsed_time  );
		rt_prep_timer();

		if( fullfloat_mode )  {
			unsigned char		*bigbuf;
			register unsigned char	*op;
			register struct floatpixel	*fp;
			register int	npix;
			int		nlines;

			nlines = end_line-start_line+1;
			npix = nlines*width;
			bigbuf = (unsigned char *)bu_malloc( npix*3,
				"bigbuf[] full image buffer");
			op = bigbuf;
			fp = &curr_float_frame[start_line*width];
#if 0
bu_log("frame=%d, rgb=%d/%d/%d, dist=%g, pt=(%g,%g,%g)\n",
fp->ff_frame, fp->ff_color[0], fp->ff_color[1], fp->ff_color[2],
fp->ff_dist, V3ARGS(fp->ff_hitpt) );
#endif
			for( ; npix > 0; fp++,npix-- )  {
				if( fp->ff_frame < 0 && fp->ff_dist > -INFINITY )  {
					/* orange: Pixel not valid */
					*op++ = 50;
					*op++ = 50;
					*op++ = 0;
				} else {
					*op++ = fp->ff_color[0];
					*op++ = fp->ff_color[1];
					*op++ = fp->ff_color[2];
				}
			}
			npix = fb_writerect( fbp, 0, start_line,
				width, nlines, bigbuf );
			if( npix < 0 )  rt_bomb("rtnode: fb_writerect() error\n");

			/* For debugging -- form image to the right in fb */
			if(debugimage) {
				op = bigbuf;
				fp = &curr_float_frame[start_line*width];
				for( ; npix > 0; fp++,npix-- )  {
					register int val;
					if( fp->ff_dist <= -INFINITY )  {
						/* Red = missed */
						*op++ = 200;
						*op++ = 0;
						*op++ = 0;
					} else if( fp->ff_frame < 0 )  {
						/* Dull red = not valid */
						*op++ = 0;
						*op++ = 100;
						*op++ = 0;
					} else if( fp->ff_frame != curframe )  {
						/* Green = reprojected */
						*op++ = 0;
						*op++ = 200;
						*op++ = 0;
					} else {
						/* Blue = freshly computed */
						*op++ = 0;
						*op++ = 0;
						*op++ = 200;
					}
				}
				npix = fb_writerect( fbp, width, start_line,
					width, nlines, bigbuf );
				if( npix < 0 )  rt_bomb("rtnode: fb_writerect() error\n");
			}

			bu_free( (char *)bigbuf, "bigbuf[] full image buffer");
		}
		view_end(&ap);
	}

	(void)rt_get_timer( (struct bu_vls *)NULL, &fb_elapsed_time  );
	rt_prep_timer();

	/*
	 *  Ensure all scanlines have made it to display server,
	 *  by requesting a cheap LIBFB service which requires a reply.
	 */
	{
		int	xcent, ycent, xzoom, yzoom;
		(void)fb_getview( fbp, &xcent, &ycent, &xzoom, &yzoom );
	}

	(void)rt_get_timer( (struct bu_vls *)NULL, &ck_elapsed_time  );

	if(debug) bu_log("done!\n");

	/* Build up reply message */
	sprintf(obuf, "%d %g %g %g %g %d",
		npsw,
		pr_elapsed_time * 1000,
		rt_elapsed_time * 1000,
		fb_elapsed_time * 1000,
		ck_elapsed_time * 1000,
		reproj_percent );
	if( pkg_send( RTSYNCMSG_DONE, obuf, strlen(obuf)+1, pcsrv ) < 0 )  {
		fprintf(stderr,"pkg_send RTSYNCMSG_DONE failed\n");
		exit(12);
	}

	/* Signal done */

	free(buf);
}

/*
 *			P H _ H A L T
 */
void
rtsync_ph_halt(pc, buf)
register struct pkg_conn *pc;
char			*buf;
{
	free(buf);
}

/*
 *			P H _ C M D
 *
 *  Run the buffer as a Tcl script.  There is no return,
 *  except for a log message on error.
 */
void
rtsync_ph_cmd(pc, buf)
register struct pkg_conn *pc;
char			*buf;
{
	if( Tcl_Eval(interp, buf) != TCL_OK )  {
		bu_log("%s\n",
			Tcl_GetVar(interp,"errorInfo", TCL_GLOBAL_ONLY) );
	} else {
		if(interp->result[1] != '\0' )
			bu_log("%s\n", interp->result);	/* may be noisy */
	}
	free(buf);
}


/*
 *			R T L O G
 *
 *  Log an error.
 *  This version buffers a full line, to save network traffic.
 */
#if (__STDC__ && !apollo)
void
bu_log( char *fmt, ... )
{
	va_list ap;
	char buf[512];		/* a generous output line.  Must be AUTO, else non-PARALLEL. */

	if( print_on == 0 )  return;
	bu_semaphore_acquire( BU_SEM_SYSCALL );
	va_start( ap, fmt );
	(void)vsprintf( buf, fmt, ap );
	va_end(ap);

	if( pcsrv == PKC_NULL || pcsrv == PKC_ERROR )  {
		fprintf(stderr, "%s", buf);
		goto out;
	}
	if(debug) fprintf(stderr, "%s", buf);
	if( pkg_send( RTSYNCMSG_PRINT, buf, strlen(buf)+1, pcsrv ) < 0 )  {
		fprintf(stderr,"pkg_send RTSYNCMSG_PRINT failed\n");
		exit(12);
	}
out:
	bu_semaphore_release( BU_SEM_SYSCALL );
}
#else /* __STDC__ */

#if defined(sgi) && !defined(mips)
# define _sgi3d	1
#endif

#if (defined(BSD) && !defined(_sgi3d)) || defined(mips) || defined(CRAY2)
/*
 *  			B U _ L O G
 *  
 *  Replacement for the LIBBU routine.
 *  Log an RT library event using the Berkeley _doprnt() routine.
 */
/* VARARGS */
void
bu_log(va_alist)
va_dcl
{
	va_list		ap;
	char		*fmt;
	char		buf[512];
	FILE		strbuf;

	if( print_on == 0 )  return;

	bu_semaphore_acquire( BU_SEM_SYSCALL );		/* lock */
	va_start(ap);
	fmt = va_arg(ap,char *);
#if defined(mips) || (defined(alliant) && defined(i860))
	(void) vsprintf( buf, fmt, ap );
#else
	strbuf._flag = _IOWRT|_IOSTRG;
#if defined(sun)
	strbuf._ptr = (unsigned char *)buf;
#else
	strbuf._ptr = buf
#endif
	strbuf._cnt = sizeof(buf);
	(void) _doprnt( fmt, ap, &strbuf );
	putc( '\0', &strbuf );
#endif
	va_end(ap);

	if(debug) fprintf(stderr, "%s", buf);
	if( pcsrv == PKC_NULL || pcsrv == PKC_ERROR )  {
		fprintf(stderr, "%s", buf);
		goto out;
	}
	if( pkg_send( RTSYNCMSG_PRINT, buf, strlen(buf)+1, pcsrv ) < 0 )  {
		fprintf(stderr,"pkg_send RTSYNCRTSYNCMSG_PRINT failed\n");
		exit(12);
	}
out:
	bu_semaphore_release( BU_SEM_SYSCALL );		/* unlock */
}
#else
/* VARARGS */
void
bu_log( str, a, b, c, d, e, f, g, h )
char	*str;
int	a, b, c, d, e, f, g, h;
{
	char	buf[512];		/* a generous output line */

	if( print_on == 0 )  return;
	bu_semaphore_acquire( BU_SEM_SYSCALL );
	(void)sprintf( buf, str, a, b, c, d, e, f, g, h );
	if( pcsrv == PKC_NULL || pcsrv == PKC_ERROR )  {
		fprintf(stderr, "%s", buf);
		goto out;
	}
	if(debug) fprintf(stderr, "%s", buf);
	if( pkg_send( RTSYNCRTSYNCMSG_PRINT, buf, strlen(buf)+1, pcsrv ) < 0 )  {
		fprintf(stderr,"pkg_send RTSYNCRTSYNCMSG_PRINT failed\n");
		exit(12);
	}
out:
	bu_semaphore_release( BU_SEM_SYSCALL );
}
#endif /* not BSD */
#endif /* not __STDC__ */


/*
 *			B U _ B O M B
 *  
 *  Replacement for LIBBU routine of same name.
 */
void
bu_bomb(str)
CONST char *str;
{
	char	*bomb = "RTSRV terminated by rt_bomb()\n";

	if( pkg_send( RTSYNCMSG_PRINT, str, strlen(str)+1, pcsrv ) < 0 )  {
		fprintf(stderr,"rt_bomb RTSYNCMSG_PRINT failed\n");
	}
	if( pkg_send( RTSYNCMSG_PRINT, bomb, strlen(bomb)+1, pcsrv ) < 0 )  {
		fprintf(stderr,"rt_bomb RTSYNCMSG_PRINT failed\n");
	}

	if(debug)  fprintf(stderr,"\n%s\n", str);
	fflush(stderr);
	if( rt_g.debug || rt_g.NMG_debug || bu_debug || debug )
		abort();	/* should dump */
	exit(12);
}


/*
 *			P H _ D E F A U L T
 */
void
ph_default(pc, buf)
register struct pkg_conn *pc;
char *buf;
{
	register int i;

	for( i=0; pc->pkc_switch[i].pks_handler != NULL; i++ )  {
		if( pc->pkc_switch[i].pks_type == pc->pkc_type )  break;
	}
	bu_log("ctl: unable to handle %s message: len %d",
		pc->pkc_switch[i].pks_title, pc->pkc_len);
	*buf = '*';
	(void)free(buf);
}
@


1.64
log
@Added definition of R_OK.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/remrt/rtnode.c,v 1.63 1998/09/22 00:30:18 mike Exp $ (ARL)";
@


1.63
log
@Don't need material.h
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/remrt/rtnode.c,v 1.62 1998/06/25 07:28:06 mike Exp $ (ARL)";
d72 4
@


1.62
log
@Port to sun4
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/remrt/rtnode.c,v 1.61 1998/06/09 02:28:35 mike Exp $ (ARL)";
a69 1
#include "../rt/material.h"
@


1.61
log
@If pixel is invalid, write orange.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtnode.c,v 1.60 1998/05/22 20:07:32 mike Exp mike $ (ARL)";
d538 3
a540 3
	red_line = bu_calloc( nlines_line*(width+1), 3, "red_line" );
	grn_line = bu_calloc( nlines_line*(width+1), 3, "grn_line" );
	blu_line = bu_calloc( nlines_line*(width+1), 3, "blu_line" );
d1114 1
a1114 1
	strbuf._cnt = sizeof(buf)-(cp-buf);
d1125 1
a1125 1
	if( pkg_send( RTSYNCRTSYNCMSG_PRINT, buf, strlen(buf)+1, pcsrv ) < 0 )  {
@


1.60
log
@Time the reprojection phase.
Account for bandwidth of debugimage
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtnode.c,v 1.59 1998/05/22 19:48:31 mike Exp mike $ (ARL)";
d926 10
a935 3
				*op++ = fp->ff_color[0];
				*op++ = fp->ff_color[1];
				*op++ = fp->ff_color[2];
@


1.59
log
@Made debugimage a run-time flag
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtnode.c,v 1.58 1998/05/22 05:48:14 mike Exp mike $ (ARL)";
d779 1
d856 1
d861 1
d989 1
a989 1
	sprintf(obuf, "%d %g %g %g %d",
d991 1
@


1.58
log
@Added dull red for not valid.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtnode.c,v 1.57 1998/05/22 04:56:12 mike Exp mike $ (ARL)";
d167 1
d399 1
d930 28
a957 26
/* Pure debugging -- form image to the right in fb */
{
			op = bigbuf;
			fp = &curr_float_frame[start_line*width];
			for( ; npix > 0; fp++,npix-- )  {
				register int val;
				if( fp->ff_dist <= -INFINITY )  {
					/* Red = missed */
					*op++ = 200;
					*op++ = 0;
					*op++ = 0;
				} else if( fp->ff_frame < 0 )  {
					/* Dull red = not valid */
					*op++ = 0;
					*op++ = 100;
					*op++ = 0;
				} else if( fp->ff_frame != curframe )  {
					/* Green = reprojected */
					*op++ = 0;
					*op++ = 200;
					*op++ = 0;
				} else {
					/* Blue = freshly computed */
					*op++ = 0;
					*op++ = 0;
					*op++ = 200;
d959 3
d963 1
a963 4
			npix = fb_writerect( fbp, width, start_line,
				width, nlines, bigbuf );
			if( npix < 0 )  rt_bomb("rtnode: fb_writerect() error\n");
}
@


1.57
log
@Support for reproject_mode 2:  reproject without re-raytracing.
Added debug image in rhs of fb
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtnode.c,v 1.56 1998/05/19 02:05:44 mike Exp $ (ARL)";
d938 5
@


1.56
log
@Stray printf
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtnode.c,v 1.55 1998/05/13 02:54:37 mike Exp $ (ARL)";
d897 2
a898 1
		do_run( start_line*width, end_line*width+width-1 );
d928 27
@


1.55
log
@Added computation of reproj_percent, sent it back to rtsync
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtnode.c,v 1.54 1998/05/12 22:51:14 mike Exp mike $ (ARL)";
a859 1
bu_log("reproj_percent %d%%\n", reproj_percent);
@


1.54
log
@Initial reprojection support.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtnode.c,v 1.53 1998/04/29 06:05:31 mike Exp mike $ (ARL)";
d780 1
d858 3
a860 1
bu_log("Reprojected %d of %d pixels from previous frame\n", reproj_cur, reproj_max);
d950 1
a950 1
	sprintf(obuf, "%d %g %g %g",
d954 2
a955 1
		ck_elapsed_time * 1000 );
@


1.53
log
@Be slightly less piggy.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtnode.c,v 1.52 1998/04/28 04:35:32 mike Exp mike $ (ARL)";
a83 8
extern int	fullfloat_mode;
struct floatpixel {
	double	ff_dist;		/* range to ff_hitpt[], <-INFINITY for miss */
	float	ff_hitpt[3];
	char	ff_color[3];
};
extern struct floatpixel	*curr_float_frame;
extern struct floatpixel	*prev_float_frame;
d398 2
d853 1
a853 1
	print_on = 0;
d855 3
a857 1
	print_on = saved_print_on;
d912 5
@


1.52
log
@Changed policy for allocating initial number of CPUs.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtnode.c,v 1.51 1998/04/28 02:13:15 mike Exp mike $ (ARL)";
d345 1
a345 1
		 *  Non-realtime, we compete with everybody else.
d350 10
a359 1
		max_cpus = avail_cpus;
@


1.51
log
@Modified to collect additional timing.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtnode.c,v 1.50 1997/12/31 09:09:51 mike Exp mike $ (ARL)";
d341 1
d344 7
a350 12
		/* Be nice on loaded machines */
		if( (debug&1) == 0 )  {
			int	iload;

			load = bu_get_load_average();
			iload = (int)(load + 0.5);	/* round up */
			max_cpus -= iload;
			if( max_cpus <= 0 )  {
				bu_log("This machine is overloaded, load=%g, aborting.\n", load);
				exit(9);
			}
		}
d361 1
d365 1
a365 1
	if( max_cpus <= 0 )  {
d372 2
a373 1
	 *  Go for the max, as TCL interface may change npsw as we run.
@


1.50
log
@Crack and process a search path,
to get us into the proper directory.
So that we can find texturemap files, etc.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtnode.c,v 1.49 1997/12/31 05:54:37 mike Exp mike $ (ARL)";
d775 4
a778 1
	char	obuf[32];
d864 2
d870 2
d892 2
a894 2
		do_run( start_line*width, end_line*width+width-1 );
		(void)rt_read_timer( (char *)0, 0 );
d922 3
d934 2
d939 5
a943 1
	sprintf(obuf, "%d", npsw);
@


1.49
log
@the ph_cd() handler wasn't used anywhere.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtnode.c,v 1.48 1997/12/16 08:10:29 mike Exp mike $ (ARL)";
d131 3
a133 1
int print_on = 1;
d402 1
d550 10
a559 1
 *  The only argument is the name of the database file.
a565 2
#define MAXARGS 1024
	char	*argv[MAXARGS+1];
d567 8
d578 2
a579 2
	if( (rt_split_cmd( argv, MAXARGS, buf )) <= 0 )  {
		/* No words in input */
d584 43
a626 4
	if( seen_dirbuild )  {
		bu_log("rtsync_ph_dirbuild:  MSG_DIRBUILD already seen, ignored\n");
		(void)free(buf);
		return;
d628 3
d632 2
a633 1
	title_file = bu_strdup(argv[0]);
d635 3
a637 1
	/* Build directory of GED database */
d666 1
@


1.48
log
@Can't use static buffers in parallel code.
When there is lots of screaming via bu_log(), the buffer overflows.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtnode.c,v 1.47 1997/12/16 07:48:29 mike Exp mike $ (ARL)";
a456 14


void
ph_cd(pc, buf)
register struct pkg_conn *pc;
char *buf;
{
	if(debug)fprintf(stderr,"ph_cd %s\n", buf);
	if( chdir( buf ) < 0 )  {
		bu_log("ph_cd: chdir(%s) failure\n", buf);
		exit(1);
	}
	(void)free(buf);
}
@


1.47
log
@Initialize all resource structures, as the count can change at runtime.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtnode.c,v 1.46 1997/12/16 00:50:01 mike Exp mike $ (ARL)";
d932 1
a932 2
	static char buf[512];		/* a generous output line */
	static char *cp = buf+1;
d937 1
a937 1
	(void)vsprintf( cp, fmt, ap );
a939 3
	while( *cp++ )  ;		/* leaves one beyond null */
	if( cp[-2] != '\n' )
		goto out;
d941 1
a941 1
		fprintf(stderr, "%s", buf+1);
d944 2
a945 2
	if(debug) fprintf(stderr, "%s", buf+1);
	if( pkg_send( RTSYNCMSG_PRINT, buf+1, strlen(buf+1)+1, pcsrv ) < 0 )  {
a948 1
	cp = buf+1;
d972 1
a972 2
	static char	buf[512];
	static char	*cp;
a975 1
	if( cp == (char *)0 )  cp = buf+1;
d981 1
a981 1
	(void) vsprintf( cp, fmt, ap );
d985 1
a985 1
	strbuf._ptr = (unsigned char *)cp;
d987 1
a987 1
	strbuf._ptr = cp;
d995 1
a995 4
	if(debug) fprintf(stderr, "%s", buf+1);
	while( *cp++ )  ;		/* leaves one beyond null */
	if( cp[-2] != '\n' )
		goto out;
d997 1
a997 1
		fprintf(stderr, "%s", buf+1);
d1000 1
a1000 1
	if( pkg_send( RTSYNCRTSYNCMSG_PRINT, buf+1, strlen(buf+1)+1, pcsrv ) < 0 )  {
a1003 1
	cp = buf+1;
d1014 1
a1014 2
	static char buf[512];		/* a generous output line */
	static char *cp = buf+1;
d1018 1
a1018 4
	(void)sprintf( cp, str, a, b, c, d, e, f, g, h );
	while( *cp++ )  ;		/* leaves one beyond null */
	if( cp[-2] != '\n' )
		goto out;
d1020 1
a1020 1
		fprintf(stderr, "%s", buf+1);
d1023 2
a1024 2
	if(debug) fprintf(stderr, "%s", buf+1);
	if( pkg_send( RTSYNCRTSYNCMSG_PRINT, buf+1, strlen(buf+1)+1, pcsrv ) < 0 )  {
a1027 1
	cp = buf+1;
@


1.46
log
@Changed to use new symbol RT_SEM_LAST
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtnode.c,v 1.45 1997/12/16 00:29:26 mike Exp mike $ (ARL)";
d375 1
a375 1
	for( n=0; n < avail_cpus; n++ )  {
@


1.45
log
@Converted to bu_semaphore_acquire()
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtnode.c,v 1.44 1997/11/22 04:06:31 mike Exp mike $ (ARL)";
d361 1
a361 1
	bu_semaphore_init( BU_SEM_LAST );
@


1.44
log
@Initialized more variables to zero, in hopes of appeasing
Irix64 Irix6.4 -mips4 systems.  Without much luck so far.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtnode.c,v 1.43 1997/11/20 23:03:36 mike Exp mike $ (ARL)";
d247 1
a247 1
	 * that will result in a deadlock in RES_ACQUIRE(res_syscall)!
d361 1
a361 6
	RES_INIT( &rt_g.res_syscall );
	RES_INIT( &rt_g.res_worker );
	RES_INIT( &rt_g.res_stats );
	RES_INIT( &rt_g.res_results );
	RES_INIT( &rt_g.res_model );
	/* DO NOT USE bu_log() before this point! */
d936 1
a936 1
	RES_ACQUIRE( &rt_g.res_syscall );
d955 1
a955 1
	RES_RELEASE( &rt_g.res_syscall );
d984 1
a984 1
	RES_ACQUIRE( &rt_g.res_syscall );		/* lock */
d1016 1
a1016 1
	RES_RELEASE( &rt_g.res_syscall );		/* unlock */
d1029 1
a1029 1
	RES_ACQUIRE( &rt_g.res_syscall );
d1045 1
a1045 1
	RES_RELEASE( &rt_g.res_syscall );
@


1.43
log
@Defer view_end() until after current image buffer is displaye.d
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtnode.c,v 1.42 1997/11/18 07:01:14 mike Exp $ (ARL)";
d102 1
a102 1
char		*beginptr;		/* sbrk() at start of program */
d108 1
a108 1
int		rdebug;			/* RT program debugging (not library) */
d111 3
a113 3
static int	seen_dirbuild;
static int	seen_gettrees;
static int	seen_matrix;
d115 2
a116 1
static char *title_file, *title_obj;	/* name of file and first object */
d126 2
a127 2
static int	avail_cpus;		/* # of cpus avail on this system */
static int	max_cpus;		/* max # cpus for use, <= avail_cpus */
d167 3
a169 3
struct pkg_conn *pcsrv;		/* PKG connection to server */
char		*control_host;	/* name of host running controller */
char		*tcp_port;	/* TCP port on control_host */
d171 1
a171 1
int debug = 0;		/* 0=off, 1=debug, 2=verbose */
d173 2
a174 2
int test_fb_speed = 0;
char	*framebuffer_name;
d176 1
a176 1
char srv_usage[] = "Usage: rtnode [-d] control-host tcp-port [cmd]\n";
d210 3
@


1.42
log
@New BUFMODE_FULLFLOAT support, matches new rt/view.c
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtnode.c,v 1.41 1997/11/17 19:11:17 mike Exp mike $ (ARL)";
a838 1
		view_end(&ap);
d863 1
@


1.41
log
@Improved commenting.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtnode.c,v 1.40 1997/11/14 02:47:41 mike Exp mike $ (ARL)";
d81 12
d799 1
d840 24
@


1.40
log
@Initialize two additional rti_ fields.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtnode.c,v 1.39 1997/08/26 07:04:34 mike Exp mike $ (ARL)";
d673 1
a673 2
	 * initialize application -- it will allocate 1 line and
	 * set buf_mode=1, as well as do mlib_init().
d786 1
a786 1
	/* initialize lighting */
@


1.39
log
@Eliminated per-frame memory leak by moving rt_init_resource()
out of worker() and into mainline.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtnode.c,v 1.38 1997/08/26 05:55:00 mike Exp $ (ARL)";
d629 2
@


1.38
log
@Added call to bu_tcl_setup()
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtnode.c,v 1.37 1997/08/26 04:26:05 mike Exp mike $ (ARL)";
d69 1
d358 9
@


1.37
log
@Added code to report how many cpus were used for this frame.
npsw can now be changed via Tcl commands.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtnode.c,v 1.36 1997/08/21 00:58:54 mike Exp mike $ (ARL)";
d368 1
@


1.36
log
@Be a little nicer.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtnode.c,v 1.35 1997/08/20 22:35:11 mike Exp mike $ (ARL)";
d374 5
a594 4

	Tcl_LinkVar(interp, "test_fb_speed", (char *)&test_fb_speed, TCL_LINK_INT);
	Tcl_LinkVar(interp, "curframe", (char *)&curframe, TCL_LINK_INT);
	Tcl_LinkVar(interp, "print_on", (char *)&print_on, TCL_LINK_INT);
d702 1
d828 3
a830 1
	if( pkg_send( RTSYNCMSG_DONE, "1", 2, pcsrv ) < 0 )  {
@


1.35
log
@On machines with realtime privs available, use every CPU.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtnode.c,v 1.34 1997/08/20 07:14:54 mike Exp mike $ (ARL)";
d321 2
a322 2
		/* We have realtime priority, use every CPU */
		max_cpus = avail_cpus;
@


1.34
log
@Added Tcl_LinkVar to "print_on" variable, to allow rtsync to
control error printing.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtnode.c,v 1.33 1997/08/19 07:01:18 mike Exp mike $ (ARL)";
d320 7
a326 3
	/* Be nice on loaded machines */
	if( (debug&1) == 0 )  {
		int	iload;
d328 7
a334 6
		load = bu_get_load_average();
		iload = (int)(load + 0.5);	/* round up */
		max_cpus -= iload;
		if( max_cpus <= 0 )  {
			bu_log("This machine is overloaded, load=%g, aborting.\n", load);
			exit(9);
@


1.33
log
@Sanity check for not getting fd0
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtnode.c,v 1.32 1997/07/01 23:38:04 mike Exp mike $ (ARL)";
d588 1
@


1.32
log
@Moved bu_get_* routines to libbu/parallel.c
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtnode.c,v 1.31 1997/07/01 21:57:11 mike Exp mike $ (ARL)";
d253 2
@


1.31
log
@Started to split out new LIBBU routines
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtnode.c,v 1.30 1997/06/26 00:52:22 mike Exp mike $ (ARL)";
a162 57

/*
 *			B U _ G E T _ L O A D _ A V E R A G E
 */
fastf_t
bu_get_load_average()
{
	FILE	*fp;
	double	load = -1.0;

	fp = popen("PATH=/bin:/usr/bin:/usr/ucb:/usr/bsd; export PATH; uptime|sed -e 's/.*average: //' -e 's/,.*//' ", "r");
	if( !fp )
		return -1.0;

	fscanf( fp, "%lf", &load );
	fclose(fp);

	while( wait(NULL) != -1 )  ;	/* NIL */
	return load;
}

/*
 *			B U _ G E T _ P U B L I C _ C P U S
 */
#define PUBLIC_CPUS1	"/var/tmp/public_cpus"
#define PUBLIC_CPUS2	"/usr/tmp/public_cpus"
int
bu_get_public_cpus()
{
	FILE	*fp;
	int	avail_cpus;
	int	public_cpus = 1;

	avail_cpus = bu_avail_cpus();

	if( (fp = fopen(PUBLIC_CPUS1, "r")) != NULL ||
	    (fp = fopen(PUBLIC_CPUS2, "r")) != NULL
	)  {
		(void)fscanf( fp, "%d", &public_cpus );
		fclose(fp);
		if( public_cpus < 0 )  public_cpus = avail_cpus + public_cpus;
		if( public_cpus > avail_cpus )  public_cpus = avail_cpus;
		return public_cpus;
	}

	(void)unlink(PUBLIC_CPUS1);
	(void)unlink(PUBLIC_CPUS2);
	if( (fp = fopen(PUBLIC_CPUS1, "w")) != NULL ||
	    (fp = fopen(PUBLIC_CPUS2, "w")) != NULL
	)  {
		fprintf(fp, "%d\n", avail_cpus);
		fclose(fp);
		(void)chmod(PUBLIC_CPUS1, 0666);
		(void)chmod(PUBLIC_CPUS2, 0666);
	}
	return avail_cpus;
}
@


1.30
log
@Release memory for the scanlines at end of frame.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtnode.c,v 1.29 1997/06/25 02:41:35 mike Exp mike $ (ARL)";
d165 57
a250 1
	FILE		*fp;
d372 2
a373 15
#define PUBLIC_CPUS	"/usr/tmp/public_cpus"
	max_cpus = avail_cpus = bu_avail_cpus();
	if( (fp = fopen(PUBLIC_CPUS, "r")) != NULL )  {
		(void)fscanf( fp, "%d", &max_cpus );
		fclose(fp);
		if( max_cpus < 0 )  max_cpus = avail_cpus + max_cpus;
		if( max_cpus > avail_cpus )  max_cpus = avail_cpus;
	} else {
		(void)unlink(PUBLIC_CPUS);
		if( (fp = fopen(PUBLIC_CPUS, "w")) != NULL )  {
			fprintf(fp, "%d\n", avail_cpus);
			fclose(fp);
			(void)chmod(PUBLIC_CPUS, 0666);
		}
	}
d377 1
a377 14
		FILE	*fp;
		fp = popen("PATH=/bin:/usr/ucb:/usr/bsd; export PATH; uptime|sed -e 's/.*average: //' -e 's/,.*//' ", "r");
		if( fp )  {
			int	iload;

			fscanf( fp, "%lf", &load );
			fclose(fp);

			iload = (int)(load + 0.5);	/* round up */
			max_cpus -= iload;
			if( max_cpus <= 0 )  {
				bu_log("This machine is overloaded, load=%g, aborting.\n", load);
				exit(9);
			}
d379 6
a384 1
			while( wait(NULL) != -1 )  ;	/* NIL */
@


1.29
log
@Added debugging to bracket problem on Array computer
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtnode.c,v 1.28 1997/06/23 04:57:43 mike Exp mike $ (ARL)";
d826 1
@


1.28
log
@New semantics for wdb_open, [get_dbip], etc.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtnode.c,v 1.27 1997/06/13 23:28:16 mike Exp mike $ (ARL)";
d377 1
d382 1
@


1.27
log
@Tcl_LinkVar() can't link to (void*) on 64-bit machines, only to ints.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtnode.c,v 1.26 1997/05/28 04:39:06 mike Exp mike $ (ARL)";
d165 21
d586 4
a589 9

	/* Can't use Tcl_LinkVar, it doesn't have a (void*) or (long) type */
	{
		char	str[64];
		sprintf(str, "%ld", (long)ap.a_rt_i->rti_dbip );
		Tcl_SetVar(interp, "dbip", str, TCL_GLOBAL_ONLY);
		sprintf(str, "%ld", (long)ap.a_rt_i );
		Tcl_SetVar(interp, "rtip", str, TCL_GLOBAL_ONLY);
	}
d594 1
a594 1
		bu_vls_strcpy(&cmd, "set wdbp [wdb_open .inmem inmem $dbip]");
@


1.26
log
@Found IRIX64 problem
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtnode.c,v 1.25 1997/05/28 03:31:15 mike Exp mike $ (ARL)";
d107 3
a109 3
static char	*red_line;
static char	*grn_line;
static char	*blu_line;
d565 9
a573 3
/* XXXX BUG:  On IRIX64, int=32, but these pointers are 64-bits wide! (long)  No TCL_LINK_LONG or TCL_LINK_PTR */
	Tcl_LinkVar(interp, "dbip", (char *)&ap.a_rt_i->rti_dbip, TCL_LINK_INT|TCL_LINK_READ_ONLY);
	Tcl_LinkVar(interp, "rtip", (char *)&ap.a_rt_i, TCL_LINK_INT|TCL_LINK_READ_ONLY);
@


1.25
log
@Include air.
Handle read-only consts.
Link up "curframe" variable.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtnode.c,v 1.24 1997/05/27 21:22:07 mike Exp mike $ (ARL)";
d565 1
d570 3
a572 1
		static char cmd[] = "set wdbp [wdb_open .inmem inmem $dbip]";
d574 1
a574 1
		if( Tcl_Eval(interp, cmd ) != TCL_OK )  {
d579 1
d776 1
a776 1
		char	*buf;
@


1.24
log
@Improved framebuffer handling
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtnode.c,v 1.23 1997/05/20 17:04:26 mike Exp mike $ (ARL)";
d110 1
a110 1
static char	framenum;
d176 1
d568 8
a575 5
	if( Tcl_Eval(interp,
	    "set wdbp [wdb_open .inmem inmem $dbip]" ) != TCL_OK )  {
		bu_log("%s\n%s\n",
	    		interp->result,
			Tcl_GetVar(interp,"errorInfo", TCL_GLOBAL_ONLY) );
d579 1
d738 2
d776 1
a776 1
		switch( (framenum++)%3 )  {
@


1.23
log
@Added net bandwidth debug test
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtnode.c,v 1.22 1997/03/07 10:50:31 mike Exp mike $ (ARL)";
d160 1
d355 1
a355 1
	if( Tcl_Init(interp) == TCL_ERROR )
d357 2
d456 3
a458 1
	bu_bomb("rtnode: unable to open remote framebuffer.  Ensure BRL-CAD Release 5.0 fbserv is running. Aborting.\n");
d471 1
a471 1
	char	*hp, *fb;
d478 2
a479 2
	fb = strchr(hp, ' ');
	*fb++ = '\0';
d485 1
a485 1
		w, h, fb );
d489 2
a490 2
	if( (fbp = fb_open( fb, w, h ) ) == 0 )  {
		bu_log("rtnode: fb_open(%s, %d, %d) failed\n", fb, w, h );
d518 2
@


1.22
log
@Added wdb_open call, improved error logging of Tcl commands.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtnode.c,v 1.21 1997/03/06 10:09:38 mike Exp $ (ARL)";
d106 6
d159 2
d502 11
d566 2
d757 28
a784 4

	rt_prep_timer();
	do_run( start_line*width, end_line*width+width-1 );
	(void)rt_read_timer( (char *)0, 0 );
@


1.21
log
@Eliminiated view_end() call; it isn't appropriate for RTNODE.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtnode.c,v 1.20 1997/03/06 09:08:03 mike Exp mike $ (ARL)";
d540 7
d784 7
a790 4
	if( Tcl_Eval(interp, buf) != TCL_OK )
		bu_log("rtnode Tcl_Eval error: %s\n", interp->result );
	else
		bu_log("%s\n", interp->result);	/* may be noisy */
@


1.20
log
@Link up with more Tcl stuff.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtnode.c,v 1.19 1997/03/05 07:30:22 mike Exp mike $ (ARL)";
d582 1
a582 1
		view_end( &ap );
@


1.19
log
@Added CMD package type.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtnode.c,v 1.18 1997/03/05 07:20:23 mike Exp mike $ (ARL)";
d350 3
d537 3
@


1.18
log
@Added initialization of Tcl.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtnode.c,v 1.17 1997/03/05 06:59:10 mike Exp mike $ (ARL)";
d122 1
d133 1
d138 1
d749 3
a751 1

d757 19
@


1.17
log
@Debug bits.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtnode.c,v 1.16 1997/01/08 02:26:07 mike Exp mike $ (ARL)";
d66 1
d109 2
d339 8
@


1.16
log
@Eliminated compiler warning.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtnode.c,v 1.15 1997/01/07 04:05:21 mike Exp mike $ (ARL)";
d296 1
a296 1
	{
d347 1
a347 1
	if( debug )  fprintf(stderr, "PROTOCOL_VERSION='%s'\n", PROTOCOL_VERSION );
@


1.15
log
@Added fb_open timeout.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtnode.c,v 1.14 1997/01/04 05:17:14 mike Exp mike $ (ARL)";
d425 2
a426 1
rtsync_timeout()
@


1.14
log
@Allow rtsync to specify portion of framebuffer to use.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtnode.c,v 1.13 1997/01/04 05:02:13 mike Exp mike $ (ARL)";
d55 2
d424 6
d456 2
d462 1
@


1.13
log
@Now accomodates old POV messages.
Doesn't stretch image on non-square framebuffers.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtnode.c,v 1.12 1997/01/04 03:35:40 mike Exp mike $ (ARL)";
d433 1
d442 2
a443 2
	if( debug )  fprintf(stderr, "rtsync_ph_openfb: %s %d %d\n",
		fb, atoi(buf), atoi(hp) );
d445 5
a449 2
	if( (fbp = fb_open( fb, atoi(buf), atoi(hp) ) ) == 0 )  {
		bu_log("rtnode: fb_open(%s, %s, %s) failed\n", fb, buf, hp );
d453 9
a647 4

	width = fb_getwidth(fbp);
	height = fb_getheight(fbp);
	if( width > height )  width = height; /* prevent stretching due to 1280x1024 */
@


1.12
log
@Fixed load average printing problem
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtnode.c,v 1.11 1997/01/04 03:24:30 mike Exp mike $ (ARL)";
d638 1
d640 15
a654 9
	argc -= 2;
	argv += 2;

	VSET( viewcenter_model, atof(argv[1]), atof(argv[2]), atof(argv[3]) );
	VSET( orient, atof(argv[4]), atof(argv[5]), atof(argv[6]) );
	orient[3] = atof(argv[7]);
	viewscale = atof(argv[8]);
	/* 9...11 for eye_pos_screen[] */
	rt_perspective = atof(argv[12]);
@


1.11
log
@libbu/libbn
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtnode.c,v 1.10 1996/08/27 05:30:45 mike Exp mike $ (ARL)";
d327 1
a327 1
	bu_log("load average = %d, using %d of %d cpus\n",
@


1.10
log
@libbu
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtnode.c,v 1.9 1996/08/27 05:27:19 mike Exp mike $ (ARL)";
d190 2
a191 2
	 * "rt_log", as that can cause rt_log to be entered recursively.
	 * Given the special version of rt_log in use here,
d243 2
a244 2
		if( rt_cpuget() > 0 )  {
			rt_cpuset( 9999999 );
d278 1
a278 1
	max_cpus = avail_cpus = rt_avail_cpus();
d306 1
a306 1
				rt_log("This machine is overloaded, load=%g, aborting.\n", load);
d325 1
a325 1
	/* DO NOT USE rt_log() before this point! */
d327 1
a327 1
	rt_log("load average = %d, using %d of %d cpus\n",
d355 1
a355 1
			rt_log("pkg_get error\n");
d371 1
a371 1
				rt_log("pkg_suckin error\n");
d383 1
a383 1
			rt_log("pkg_get error\n");
d400 1
a400 1
		rt_log("ph_cd: chdir(%s) failure\n", buf);
d413 1
a413 1
	rt_log("Restarting\n");
d445 1
a445 1
		rt_log("rtnode: fb_open(%s, %s, %s) failed\n", fb, buf, hp );
d477 1
a477 1
		rt_log("rtsync_ph_dirbuild:  MSG_DIRBUILD already seen, ignored\n");
d482 1
a482 1
	title_file = rt_strdup(argv[0]);
d486 1
a486 1
		rt_log("rtsync_ph_dirbuild:  rt_dirbuild(%s) failure\n", title_file);
d532 1
a532 1
	title_obj = rt_strdup(argv[0]);
d536 1
a536 1
		if(debug)rt_log("Cleaning previous model\n");
d541 1
a541 1
			rt_prmem( "After rt_clean" );
d568 1
a568 1
		rt_log("ph_matrix: No solids remain after prep.\n");
d609 1
a609 1
		rt_log("Null POV command\n");
d651 1
a651 1
	mat_idn( Viewrotscale );
d654 1
a654 1
	mat_idn( toViewcenter );
d656 1
a656 1
	mat_mul( model2view, Viewrotscale, toViewcenter );
d659 1
a659 1
	mat_inv( view2model, model2view );
d695 1
a695 1
	if(debug) rt_log("done!\n");
d724 1
a724 1
rt_log( char *fmt, ... )
d885 1
a885 1
	rt_log("ctl: unable to handle %s message: len %d",
@


1.9
log
@Added use_air support
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtnode.c,v 1.8 1995/08/24 03:57:00 mike Exp mike $ (ARL)";
d59 1
a59 1
#include "rtstring.h"
d760 1
a760 1
 *  			R T _ L O G
d762 1
d767 1
a767 1
rt_log(va_alist)
d816 1
a816 1
rt_log( str, a, b, c, d, e, f, g, h )
d847 1
a847 1
 *			R T _ B O M B
d849 1
a849 1
 *  Abort the RT library
d852 2
a853 2
rt_bomb(str)
char *str;
d866 1
a866 1
	if( rt_g.debug || rt_g.NMG_debug || debug )
@


1.8
log
@Clean up stray children from popen().
Tidy up load average message.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtnode.c,v 1.7 1995/08/24 03:16:46 mike Exp mike $ (ARL)";
d172 3
d590 2
a591 1
	char	*argv[MAXARGS+1];
d607 1
a607 1
	if( (argc = rt_split_cmd( argv, MAXARGS, buf )) <= 0 )  {
a617 1
	rt_perspective = 0;
a620 1
	use_air = 0;
d639 10
a648 4
	VSET( viewcenter_model, atof(argv[3]), atof(argv[4]), atof(argv[5]) );
	VSET( orient, atof(argv[6]), atof(argv[7]), atof(argv[8]) );
	orient[3] = atof(argv[9]);
	viewscale = atof(argv[10]);
@


1.7
log
@Upgraded to use messages for specifying framebuffer, database,
and treetops.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtnode.c,v 1.6 1995/08/24 01:44:54 mike Exp mike $ (ARL)";
d157 1
a294 1
			double	load = 0;
d296 1
a297 1
			rt_log("Load average = %g\n", load);
d303 1
a303 1
				rt_log("This machine is overloaded, aborting.\n");
d306 2
d324 2
a325 1
	rt_log("using %d of %d cpus\n",
@


1.6
log
@Be aware of load averages.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/remrt/RCS/rtnode.c,v 1.5 1995/08/23 02:05:30 mike Exp mike $ (ARL)";
d33 5
a93 2
static char idbuf[132];			/* First ID record info */

d114 3
d123 3
d128 1
a129 1
	{ RTSYNCMSG_POV,	rtsync_ph_pov, "POV" },
d131 3
a138 3
void	ph_gettrees();
void	ph_dirbuild();

a211 5
	if( (fbp = fb_open( NULL, 0, 0 ) ) == 0 )  {
		fprintf(stderr,"rtnode: fb_open() failed\n");
		exit(1);
	}

d300 1
a300 1
			iload = (int)(load + 0.9);	/* round up */
a328 4
	/* XXX Hack -- do this before ALIVE message */
	ph_dirbuild( 0, rt_strdup("moss.g") );
	ph_gettrees( 0, rt_strdup("all.g") );

d414 2
d417 1
a417 1
 *			P H _ D I R B U I L D
d419 32
d454 1
a454 1
ph_dirbuild(pc, buf)
d462 1
a462 1
	if( debug )  fprintf(stderr, "ph_dirbuild: %s\n", buf );
d471 1
a471 1
		rt_log("ph_dirbuild:  MSG_DIRBUILD already seen, ignored\n");
d479 2
a480 2
	if( (rtip=rt_dirbuild( title_file, idbuf, sizeof(idbuf) )) == RTI_NULL )  {
		rt_log("ph_dirbuild:  rt_dirbuild(%s) failure\n", title_file);
d486 3
a488 5
#if 0
	if( pkg_send( MSG_DIRBUILD_REPLY,
	    idbuf, strlen(idbuf)+1, pcsrv ) < 0 )
		fprintf(stderr,"MSG_DIRBUILD_REPLY error\n");
#endif
d492 1
a492 1
 *			P H _ G E T T R E E S
d497 1
a497 1
ph_gettrees(pc, buf)
d508 1
a508 1
	if( debug )  fprintf(stderr, "ph_gettrees: %s\n", buf );
a565 1
#if 0
d567 1
a567 1
	if( pkg_send( MSG_GETTREES_REPLY,
d569 1
a569 2
		fprintf(stderr,"MSG_START error\n");
#endif
a571 2
/* -------------------- */

d598 1
a598 1
	if( debug )  fprintf(stderr, "ph_pov: %s\n", buf );
@


1.5
log
@Using /dev/sgid for double-buffer simulation,
flush data through to FBSERV.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/remrt/RCS/rtnode.c,v 1.4 1995/08/23 01:27:14 mike Exp mike $ (ARL)";
d282 20
@


1.4
log
@Don't hardware VJ
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtnode.c,v 1.3 1995/07/15 07:52:19 mike Exp mike $ (ARL)";
d626 9
@


1.3
log
@Send DONE message.
Supress printing durring view_init()
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtnode.c,v 1.2 1995/07/15 07:11:42 mike Exp mike $ (ARL)";
d203 1
a203 1
	if( (fbp = fb_open( "vj:0", 0, 0 ) ) == 0 )  {
@


1.2
log
@This version actually works, a bit.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtnode.c,v 1.1 1995/07/15 06:11:32 mike Exp mike $ (ARL)";
d546 1
a585 1
	/* XXX NOT eye_model */
a589 2
VPRINT("viewcenter_model", viewcenter_model);
HPRINT("orient", orient);
a591 1
rt_log("viewsize = %g\n", viewsize);
d610 1
d612 1
d627 6
a632 1
	rt_log("done!\n");
@


1.1
log
@Initial revision
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
d541 1
a542 2
	mat_t	Viewrot;
	quat_t	orient;
d544 2
d582 5
a586 1
	VSET( eye_model, atof(argv[3]), atof(argv[4]), atof(argv[5]) );
d590 2
d593 5
d599 5
a603 5
	mat_idn( Viewrot );
	MAT_DELTAS_VEC_NEG( toViewcenter, eye_model );
	quat_quat2mat( Viewrot, orient );
	Viewrot[15] = viewscale;
	mat_mul( model2view, Viewrot, toViewcenter );
d605 3
d627 2
@
