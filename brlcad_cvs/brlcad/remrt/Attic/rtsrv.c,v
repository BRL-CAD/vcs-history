head	11.36;
access;
symbols
	ansi-20040405-merged:11.31.2.2
	postmerge-20040405-ansi:11.34
	premerge-20040404-ansi:11.33
	postmerge-autoconf:11.33
	autoconf-freeze:11.31.10.3
	premerge-autoconf:11.33
	postmerge-20040315-windows:11.33
	premerge-20040315-windows:11.33
	windows-20040315-freeze:11.31.4.1
	autoconf-20031203:11.31.10.1
	autoconf-20031202:11.31
	autoconf-branch:11.31.0.10
	phong-branch:11.31.0.8
	photonmap-branch:11.31.0.6
	rel-6-1-DP:11.31
	windows-branch:11.31.0.4
	rel-6-0-2:11.29
	ansi-branch:11.31.0.2
	rel-6-0-1-branch:11.29.0.2
	hartley-6-0-post:11.30
	hartley-6-0-pre:11.29
	rel-6-0-1:11.29
	rel-6-0:11.29
	rel-5-4:11.21
	offsite-5-3-pre:11.25
	rel-5-3:11.21
	rel-5-2:11.21
	rel-5-1-branch:11.21.0.2
	rel-5-1:11.21
	rel-5-0:11.15
	rel-5-0-beta:11.15
	rel-4-5:11.12
	ctj-4-5-post:11.6
	ctj-4-5-pre:11.6
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:1.21
	rel-2-0:1.17
	rel-1-24:1.17
	rel-1-20:1.16
	rel-1-10:1.16;
locks; strict;
comment	@ * @;


11.36
date	2004.05.21.17.33.31;	author morrison;	state dead;
branches;
next	11.35;

11.35
date	2004.05.10.15.30.49;	author erikg;	state Exp;
branches;
next	11.34;

11.34
date	2004.04.05.05.45.58;	author morrison;	state Exp;
branches;
next	11.33;

11.33
date	2004.02.02.17.39.38;	author morrison;	state Exp;
branches;
next	11.32;

11.32
date	2003.10.31.13.50.07;	author jra;	state Exp;
branches;
next	11.31;

11.31
date	2002.08.20.17.08.37;	author jra;	state Exp;
branches
	11.31.2.1
	11.31.4.1
	11.31.10.1;
next	11.30;

11.30
date	2002.08.15.20.55.49;	author hartley;	state Exp;
branches;
next	11.29;

11.29
date	2001.08.11.13.18.07;	author butler;	state Exp;
branches;
next	11.28;

11.28
date	2001.05.17.20.06.01;	author morrison;	state Exp;
branches;
next	11.27;

11.27
date	2001.05.16.21.38.15;	author morrison;	state Exp;
branches;
next	11.26;

11.26
date	2001.04.20.22.31.18;	author morrison;	state Exp;
branches;
next	11.25;

11.25
date	2000.10.24.19.36.14;	author mike;	state Exp;
branches;
next	11.24;

11.24
date	2000.09.07.20.10.35;	author mike;	state Exp;
branches;
next	11.23;

11.23
date	2000.08.24.22.23.57;	author mike;	state Exp;
branches;
next	11.22;

11.22
date	2000.07.25.17.29.43;	author butler;	state Exp;
branches;
next	11.21;

11.21
date	2000.05.19.12.34.48;	author jra;	state Exp;
branches;
next	11.20;

11.20
date	2000.03.15.22.52.55;	author mike;	state Exp;
branches;
next	11.19;

11.19
date	2000.03.09.21.52.04;	author mike;	state Exp;
branches;
next	11.18;

11.18
date	2000.01.31.15.14.31;	author jra;	state Exp;
branches;
next	11.17;

11.17
date	99.12.30.05.49.09;	author butler;	state Exp;
branches;
next	11.16;

11.16
date	99.10.30.03.06.26;	author butler;	state Exp;
branches;
next	11.15;

11.15
date	98.12.28.21.54.57;	author mike;	state Exp;
branches;
next	11.14;

11.14
date	98.09.22.00.30.18;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	98.06.25.07.28.06;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	97.12.16.08.10.29;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	97.12.16.07.48.29;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	97.12.16.00.50.01;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	97.12.16.00.29.26;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	97.08.26.07.04.34;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	97.07.01.23.39.47;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	97.01.04.03.24.30;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	96.08.27.05.32.36;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	96.07.15.17.40.50;	author jra;	state Exp;
branches;
next	11.3;

11.3
date	95.07.14.02.32.01;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	95.03.01.03.57.15;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.04.03;	author mike;	state Rel4_4;
branches;
next	10.13;

10.13
date	94.12.30.01.18.56;	author mike;	state Exp;
branches;
next	10.12;

10.12
date	94.12.21.16.53.37;	author mike;	state Exp;
branches;
next	10.11;

10.11
date	94.12.21.14.54.05;	author stay;	state Exp;
branches;
next	10.10;

10.10
date	94.12.21.14.49.44;	author stay;	state Exp;
branches;
next	10.9;

10.9
date	94.11.24.02.12.35;	author mike;	state Exp;
branches;
next	10.8;

10.8
date	94.11.05.03.35.04;	author mike;	state Exp;
branches;
next	10.7;

10.7
date	94.08.25.17.51.06;	author gdurf;	state Exp;
branches;
next	10.6;

10.6
date	94.08.23.17.43.54;	author gdurf;	state Exp;
branches;
next	10.5;

10.5
date	94.08.12.21.09.09;	author gdurf;	state Exp;
branches;
next	10.4;

10.4
date	94.08.11.18.59.49;	author gdurf;	state Exp;
branches;
next	10.3;

10.3
date	94.05.06.03.43.55;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	93.10.26.00.36.30;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.42.36;	author mike;	state Rel4_0;
branches;
next	9.24;

9.24
date	91.08.31.03.07.36;	author mike;	state Exp;
branches;
next	9.23;

9.23
date	91.07.19.03.00.38;	author mike;	state Exp;
branches;
next	9.22;

9.22
date	91.07.01.22.37.41;	author mike;	state Exp;
branches;
next	9.21;

9.21
date	91.02.06.16.06.46;	author mike;	state Exp;
branches;
next	9.20;

9.20
date	91.02.06.15.36.50;	author mike;	state Exp;
branches;
next	9.19;

9.19
date	91.01.27.10.53.27;	author cjohnson;	state Exp;
branches;
next	9.18;

9.18
date	91.01.24.16.21.48;	author mike;	state Exp;
branches;
next	9.17;

9.17
date	90.12.08.04.46.11;	author mike;	state Exp;
branches;
next	9.16;

9.16
date	90.11.24.01.29.43;	author mike;	state Exp;
branches;
next	9.15;

9.15
date	90.11.24.00.29.06;	author mike;	state Exp;
branches;
next	9.14;

9.14
date	90.11.22.05.36.37;	author mike;	state Exp;
branches;
next	9.13;

9.13
date	90.11.22.03.53.46;	author mike;	state Exp;
branches;
next	9.12;

9.12
date	90.11.21.06.35.37;	author mike;	state Exp;
branches;
next	9.11;

9.11
date	90.11.15.23.45.50;	author mike;	state Exp;
branches;
next	9.10;

9.10
date	90.10.16.11.21.19;	author mike;	state Exp;
branches;
next	9.9;

9.9
date	90.06.06.22.59.09;	author mike;	state Exp;
branches;
next	9.8;

9.8
date	90.02.09.04.54.39;	author mike;	state Exp;
branches;
next	9.7;

9.7
date	89.11.23.05.07.49;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	89.11.23.00.06.19;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	89.11.22.22.51.35;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	89.11.16.23.35.26;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	89.11.15.02.50.10;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	89.10.23.01.45.25;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.00.30;	author mike;	state Rel3_5;
branches;
next	8.26;

8.26
date	89.04.30.21.43.45;	author mike;	state Exp;
branches;
next	8.25;

8.25
date	89.04.22.04.55.02;	author mike;	state Exp;
branches;
next	8.24;

8.24
date	89.04.04.04.52.43;	author mike;	state Exp;
branches;
next	8.23;

8.23
date	89.03.15.22.56.37;	author mike;	state Exp;
branches;
next	8.22;

8.22
date	89.03.15.20.02.08;	author mike;	state Exp;
branches;
next	8.21;

8.21
date	89.02.14.05.35.10;	author mike;	state Exp;
branches;
next	8.20;

8.20
date	89.02.14.04.25.45;	author mike;	state Exp;
branches;
next	8.19;

8.19
date	89.02.13.06.12.41;	author mike;	state Exp;
branches;
next	8.18;

8.18
date	89.02.13.05.57.12;	author mike;	state Exp;
branches;
next	8.17;

8.17
date	89.02.11.04.49.08;	author mike;	state Exp;
branches;
next	8.16;

8.16
date	89.02.10.23.48.06;	author mike;	state Exp;
branches;
next	8.15;

8.15
date	89.02.10.05.47.05;	author mike;	state Exp;
branches;
next	8.14;

8.14
date	89.02.10.05.33.10;	author mike;	state Exp;
branches;
next	8.13;

8.13
date	89.02.10.05.13.54;	author mike;	state Exp;
branches;
next	8.12;

8.12
date	89.02.10.02.47.28;	author mike;	state Exp;
branches;
next	8.11;

8.11
date	89.01.27.00.54.04;	author mike;	state Exp;
branches;
next	8.10;

8.10
date	89.01.26.22.52.19;	author mike;	state Exp;
branches;
next	8.9;

8.9
date	89.01.26.09.08.51;	author mike;	state Exp;
branches;
next	8.8;

8.8
date	89.01.26.08.42.52;	author mike;	state Exp;
branches;
next	8.7;

8.7
date	89.01.25.05.42.39;	author mike;	state Exp;
branches;
next	8.6;

8.6
date	89.01.25.04.09.01;	author mike;	state Exp;
branches;
next	8.5;

8.5
date	89.01.25.03.12.23;	author mike;	state Exp;
branches;
next	8.4;

8.4
date	89.01.20.06.13.23;	author mike;	state Exp;
branches;
next	8.3;

8.3
date	89.01.20.03.18.08;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	89.01.20.01.24.17;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.34.01;	author mike;	state Rel3_0;
branches;
next	1.25;

1.25
date	88.09.21.04.47.06;	author mike;	state Exp;
branches;
next	1.24;

1.24
date	88.09.17.07.06.02;	author mike;	state Exp;
branches;
next	1.23;

1.23
date	88.03.02.00.17.59;	author mike;	state Exp;
branches;
next	1.22;

1.22
date	88.03.01.21.03.57;	author mike;	state Exp;
branches;
next	1.21;

1.21
date	87.11.02.15.45.47;	author mike;	state Exp;
branches;
next	1.20;

1.20
date	87.08.10.07.11.41;	author mike;	state Exp;
branches;
next	1.19;

1.19
date	87.08.10.02.20.00;	author mike;	state Exp;
branches;
next	1.18;

1.18
date	87.08.10.00.18.16;	author mike;	state Exp;
branches;
next	1.17;

1.17
date	87.04.10.08.12.13;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	86.10.29.02.23.22;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	86.10.29.02.06.05;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	86.10.29.02.03.13;	author mike;	state Exp;
branches;
next	1.13;

1.13
date	86.10.29.01.31.12;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	86.10.28.23.42.49;	author mike;	state Exp;
branches;
next	1.11;

1.11
date	86.10.28.15.28.17;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	86.10.27.22.22.21;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	86.10.27.04.07.14;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	86.10.26.23.43.30;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	86.10.26.22.49.50;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	86.10.26.20.08.52;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	86.10.26.19.51.21;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	86.10.26.18.56.32;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	86.07.30.03.49.50;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	86.07.30.01.37.37;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	86.07.22.04.59.11;	author mike;	state Exp;
branches;
next	;

11.31.2.1
date	2002.09.19.18.02.14;	author morrison;	state Exp;
branches;
next	11.31.2.2;

11.31.2.2
date	2004.03.17.21.22.56;	author morrison;	state Exp;
branches;
next	;

11.31.4.1
date	2004.03.11.23.48.00;	author morrison;	state Exp;
branches;
next	;

11.31.10.1
date	2003.12.03.17.56.00;	author erikg;	state Exp;
branches;
next	11.31.10.2;

11.31.10.2
date	2004.02.12.19.40.28;	author erikg;	state Exp;
branches;
next	11.31.10.3;

11.31.10.3
date	2004.03.15.14.08.06;	author erikg;	state Exp;
branches;
next	;


desc
@Server program for distributed ray tracing
@


11.36
log
@moved to src/remrt/
@
text
@/*
 *			R T S R V . C
 *
 *  Remote Ray Tracing service program, using RT library.
 *
 *  Author -
 *	Michael John Muuss
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1985-2004 by the United States Army.
 *	All rights reserved.
 */
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/remrt/rtsrv.c,v 11.35 2004/05/10 15:30:49 erikg Exp $ (BRL)";

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#if IRIX == 4
#define _BSD_COMPAT	1
#endif

#include <stdio.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#ifdef HAVE_STDARG_H
# include <stdarg.h>
#else
# include <varargs.h>
#endif

#include <sys/time.h>

#ifndef SYSV
# include <sys/ioctl.h>
# include <sys/resource.h>
#endif

#ifdef HAVE_SYS_SOCKET_H
# include <sys/socket.h>
#endif

#undef	VMIN
#include "machine.h"
#include "externs.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "raytrace.h"
#include "pkg.h"
#include "fb.h"

#include "../librt/debug.h"
#include "../rt/ext.h"
#include "rtprivate.h"

#include "./protocol.h"

struct bu_list	WorkHead;

struct pkg_queue {
	struct bu_list	l;
	unsigned short	type;
	char		*buf;
};

/***** Variables shared with viewing model *** */
FBIO		*fbp = FBIO_NULL;	/* Framebuffer handle */
FILE		*outfp = NULL;		/* optional pixel output file */
mat_t		view2model;
mat_t		model2view;
int		srv_startpix;		/* offset for view_pixel */
int		srv_scanlen = REMRT_MAX_PIXELS;	/* max assignment */
char		*scanbuf;
/***** end of sharing with viewing model *****/

extern void grid_setup();
extern void worker();

/***** variables shared with worker() ******/
struct application ap;
vect_t		left_eye_delta;
int		report_progress;	/* !0 = user wants progress report */
/***** end variables shared with worker() *****/

/***** variables shared with do.c *****/
char		*beginptr;		/* sbrk() at start of program */
/***** end variables shared with do.c *****/

/* Variables shared within mainline pieces */
extern fastf_t	rt_dist_tol;		/* Value for rti_tol.dist */
extern fastf_t	rt_perp_tol;		/* Value for rti_tol.perp */
extern int	rdebug;			/* RT program debugging (not library) */
int		rt_verbosity = -1;
static char idbuf[132];			/* First ID record info */

/* State flags */
static int	seen_dirbuild;
static int	seen_gettrees;
static int	seen_matrix;

static char *title_file, *title_obj;	/* name of file and first object */

#define MAX_WIDTH	(16*1024)

static int	avail_cpus;		/* # of cpus avail on this system */
static int	max_cpus;		/* max # cpus for use, <= avail_cpus */

int	save_overlaps=0;

/*
 * Package Handlers.
 */
void	ph_unexp(register struct pkg_conn *pc, char *buf);	/* foobar message handler */
void	ph_enqueue(register struct pkg_conn *pc, char *buf);	/* Addes message to linked list */
void	ph_dirbuild(register struct pkg_conn *pc, char *buf);
void	ph_gettrees(register struct pkg_conn *pc, char *buf);
void	ph_matrix(register struct pkg_conn *pc, char *buf);
void	ph_options(register struct pkg_conn *pc, char *buf);
void	ph_lines(struct pkg_conn *pc, char *buf);
void	ph_end(register struct pkg_conn *pc, char *buf);
void	ph_restart(register struct pkg_conn *pc, char *buf);
void	ph_loglvl(register struct pkg_conn *pc, char *buf);
void	ph_cd(register struct pkg_conn *pc, char *buf);

void	prepare(void);

struct pkg_switch pkgswitch[] = {
	{ MSG_DIRBUILD,	ph_dirbuild,	"DirBuild" },
	{ MSG_GETTREES,	ph_enqueue,	"Get Trees" },
	{ MSG_MATRIX,	ph_enqueue,	"Set Matrix" },
	{ MSG_OPTIONS,	ph_enqueue,	"Options" },
	{ MSG_LINES,	ph_enqueue,	"Compute lines" },
	{ MSG_END,	ph_end,		"End" },
	{ MSG_PRINT,	ph_unexp,	"Log Message" },
	{ MSG_LOGLVL,	ph_loglvl,	"Change log level" },
	{ MSG_RESTART,	ph_restart,	"Restart" },
	{ MSG_CD,	ph_cd,		"Change Dir" },
	{ 0,		0,		(char *)0 }
};

struct pkg_conn *pcsrv;		/* PKG connection to server */
char		*control_host;	/* name of host running controller */
char		*tcp_port;	/* TCP port on control_host */

int debug = 0;		/* 0=off, 1=debug, 2=verbose */

char srv_usage[] = "Usage: rtsrv [-d] control-host tcp-port [cmd]\n";

/*
 *			M A I N
 */
int
main(int argc, char **argv)
{
	register int	n;

	if( argc < 2 )  {
		fprintf(stderr, srv_usage);
		exit(1);
	}
	while( argv[1][0] == '-' )  {
		if( strcmp( argv[1], "-d" ) == 0 )  {
			debug++;
		} else if( strcmp( argv[1], "-x" ) == 0 )  {
			sscanf( argv[2], "%x", (unsigned int *)&rt_g.debug );
			argc--; argv++;
		} else if( strcmp( argv[1], "-X" ) == 0 )  {
			sscanf( argv[2], "%x", (unsigned int *)&rdebug );
			argc--; argv++;
		} else {
			fprintf(stderr, srv_usage);
			exit(3);
		}
		argc--; argv++;
	}
	if( argc != 3 && argc != 4 )  {
		fprintf(stderr, srv_usage);
		exit(2);
	}

	control_host = argv[1];
	tcp_port = argv[2];

	/* Note that the LIBPKG error logger can not be
	 * "bu_log", as that can cause bu_log to be entered recursively.
	 * Given the special version of bu_log in use here,
	 * that will result in a deadlock in bu_semaphore_acquire(res_syscall)!
	 *  libpkg will default to stderr via pkg_errlog(), which is fine.
	 */
	pcsrv = pkg_open( control_host, tcp_port, "tcp", "", "",
		pkgswitch, NULL );
	if( pcsrv == PKC_ERROR )  {
		fprintf(stderr, "rtsrv: unable to contact %s, port %s\n",
			control_host, tcp_port);
		exit(1);
	}

	if( argc == 4 )  {
		/* Slip one command to dispatcher */
		(void)pkg_send( MSG_CMD, argv[3], strlen(argv[3])+1, pcsrv );

		/* Prevent chasing the package with an immediate TCP close */
		sleep(1);

		pkg_close( pcsrv );
		exit(0);
	}

#if BSD == 43
	{
		int	val = 32767;
		n = setsockopt( pcsrv->pkc_fd, SOL_SOCKET,
			SO_SNDBUF, (char *)&val, sizeof(val) );
		if( n < 0 )  perror("setsockopt: SO_SNDBUF");
	}
#endif

	if( !debug )  {
		/* A fresh process */
		if (fork())
			exit(0);

		/* Go into our own process group */
		n = getpid();

		/* SysV uses setpgrp with no args and it can't fail */
#if (defined(__STDC__) || defined(SYSV)) && !defined(_BSD_COMPAT)
		if( setpgid( n, n ) < 0 )
			perror("setpgid");
#else
		if( setpgrp( n, n ) < 0 )
			perror("setpgrp");
#endif

		/* Deal with CPU limits on "those kinds" of systems */
		if( bu_cpulimit_get() > 0 )  {
			bu_cpulimit_set( 9999999 );
		}

		/*
		 *  Unless controller process has specificially said
		 *  that this is an interactive session, eg, for a demo,
		 *  drop to the lowest sensible priority.
		 */
		if( !interactive )  {
#ifdef CRAY
			bu_nice_set(6);		/* highest "free" priority */
#else
			bu_nice_set(19);		/* lowest priority */
#endif
		}

		/* Close off the world */
		fclose(stdin);
		fclose(stdout);
		fclose(stderr);

		(void)close(0);
		(void)close(1);
		(void)close(2);

		/* For stdio & perror safety, reopen 0,1,2 */
		(void)open("/dev/null", 0);	/* to fd 0 */
		(void)dup(0);			/* to fd 1 */
		(void)dup(0);			/* to fd 2 */

#ifndef SYSV
		n = open("/dev/tty", 2);
		if (n >= 0) {
			(void)ioctl(n, TIOCNOTTY, 0);
			(void)close(n);
		}
#endif
	}

	/* Send our version string */
	if( pkg_send( MSG_VERSION,
	    PROTOCOL_VERSION, strlen(PROTOCOL_VERSION)+1, pcsrv ) < 0 )  {
		fprintf(stderr,"pkg_send MSG_VERSION error\n");
		exit(1);
	}
	if( debug )  fprintf(stderr, "PROTOCOL_VERSION='%s'\n", PROTOCOL_VERSION );

	/*
	 *  Now that the fork() has been done, it is safe to initialize
	 *  the parallel processing support.
	 */

	beginptr = (char *) sbrk(0);

	avail_cpus = bu_avail_cpus();
	max_cpus = bu_get_public_cpus();

	/* Need to set rtg_parallel non_zero here for RES_INIT to work */
	npsw = max_cpus;
	if( npsw > 1 )  {
		rt_g.rtg_parallel = 1;
	} else
		rt_g.rtg_parallel = 0;
	bu_semaphore_init( RT_SEM_LAST );

	bu_log("using %d of %d cpus\n",
		npsw, avail_cpus );
	if( max_cpus <= 0 )  {
		pkg_close(pcsrv);
		exit(0);
	}

	/*
	 *  Initialize the non-parallel memory resource.
	 *  The parallel guys are initialized after the rt_dirbuild().
	 */
	rt_init_resource( &rt_uniresource, MAX_PSW, NULL );
	bn_rand_init( rt_uniresource.re_randptr, MAX_PSW );

	BU_LIST_INIT( &WorkHead );

	for(;;)  {
		register struct pkg_queue	*lp;
		fd_set ifds;
		struct timeval tv;

		/* First, process any packages in library buffers */
		if( pkg_process( pcsrv ) < 0 )  {
			bu_log("pkg_get error\n");
			break;
		}

		/* Second, see if any input to read */
		FD_ZERO(&ifds);
		FD_SET(pcsrv->pkc_fd, &ifds);
		tv.tv_sec = BU_LIST_NON_EMPTY( &WorkHead ) ? 0L : 9999L;
		tv.tv_usec = 0L;

		if( select(pcsrv->pkc_fd+1, &ifds, (fd_set *)0, (fd_set *)0,
			&tv ) != 0 )  {
			n = pkg_suckin(pcsrv);
			if( n < 0 )  {
				bu_log("pkg_suckin error\n");
				break;
			} else if( n == 0 )  {
				/* EOF detected */
				break;
			} else {
				/* All is well */
			}
		}

		/* Third, process any new packages in library buffers */
		if( pkg_process( pcsrv ) < 0 )  {
			bu_log("pkg_get error\n");
			break;
		}

		/* Finally, more work may have just arrived, check our list */
		if( BU_LIST_NON_EMPTY( &WorkHead ) )  {
			lp = BU_LIST_FIRST( pkg_queue, &WorkHead );
			BU_LIST_DEQUEUE( &lp->l );
			switch( lp->type )  {
			case MSG_MATRIX:
				ph_matrix( (struct pkg_conn *)0, lp->buf );
				break;
			case MSG_LINES:
				ph_lines( (struct pkg_conn *)0, lp->buf );
				break;
			case MSG_OPTIONS:
				ph_options( (struct pkg_conn *)0, lp->buf );
				break;
			case MSG_GETTREES:
				ph_gettrees( (struct pkg_conn *)0, lp->buf );
				break;
			default:
				bu_log("bad list element, type=%d\n", lp->type );
				exit(33);
			}
			rt_free( (char *)lp, "struct pkg_queue" );
		}
	}

	return(0);		/* exit(0) */
}

/*
 *			P H _ E N Q U E U E
 *
 *  Generic routine to add a newly arrived PKG to a linked list,
 *  for later processing.
 *  Note that the buffer will be freed when the list element is processed.
 *  Presently used for MATRIX and LINES messages.
 */
void
ph_enqueue(register struct pkg_conn *pc, char *buf)
{
	register struct pkg_queue	*lp;

	if( debug )  fprintf(stderr, "ph_enqueue: %s\n", buf );

	BU_GETSTRUCT( lp, pkg_queue );
	lp->type = pc->pkc_type;
	lp->buf = buf;
	BU_LIST_INSERT( &WorkHead, &lp->l );
}

void
ph_cd(register struct pkg_conn *pc, char *buf)
{
	if(debug)fprintf(stderr,"ph_cd %s\n", buf);
	if( chdir( buf ) < 0 )  {
		bu_log("ph_cd: chdir(%s) failure\n", buf);
		exit(1);
	}
	(void)free(buf);
}

void
ph_restart(register struct pkg_conn *pc, char *buf)
{

	if(debug)fprintf(stderr,"ph_restart %s\n", buf);
	bu_log("Restarting\n");
	pkg_close(pcsrv);
	execlp( "rtsrv", "rtsrv", control_host, tcp_port, (char *)0);
	perror("rtsrv");
	exit(1);
}

/*
 *			P H _ D I R B U I L D
 *
 *  The only argument is the name of the database file.
 */
void
ph_dirbuild(register struct pkg_conn *pc, char *buf)
{
#define MAXARGS 1024
	char	*argv[MAXARGS+1];
	struct rt_i *rtip;
	int	n;

	if( debug )  fprintf(stderr, "ph_dirbuild: %s\n", buf );

	if( (rt_split_cmd( argv, MAXARGS, buf )) <= 0 )  {
		/* No words in input */
		(void)free(buf);
		return;
	}

	if( seen_dirbuild )  {
		bu_log("ph_dirbuild:  MSG_DIRBUILD already seen, ignored\n");
		(void)free(buf);
		return;
	}

	title_file = bu_strdup(argv[0]);

	/* Build directory of GED database */
	if( (rtip=rt_dirbuild( title_file, idbuf, sizeof(idbuf) )) == RTI_NULL )  {
		bu_log("ph_dirbuild:  rt_dirbuild(%s) failure\n", title_file);
		exit(2);
	}
	ap.a_rt_i = rtip;
	seen_dirbuild = 1;

	/*
	 *  Initialize all the per-CPU memory resources.
	 *  Go for the max, as TCL interface may change npsw as we run.
	 */
	for( n=0; n < MAX_PSW; n++ )  {
		rt_init_resource( &resource[n], n, rtip );
		bn_rand_init( resource[n].re_randptr, n );
	}

	if( pkg_send( MSG_DIRBUILD_REPLY,
	    idbuf, strlen(idbuf)+1, pcsrv ) < 0 )
		fprintf(stderr,"MSG_DIRBUILD_REPLY error\n");
}

/*
 *			P H _ G E T T R E E S
 *
 *  Each word in the command buffer is the name of a treetop.
 */
void
ph_gettrees(register struct pkg_conn *pc, char *buf)
{
#define MAXARGS 1024
	char	*argv[MAXARGS+1];
	int	argc;
	struct rt_i *rtip = ap.a_rt_i;

	RT_CK_RTI(rtip);

	if( debug )  fprintf(stderr, "ph_gettrees: %s\n", buf );

	/* Copy values from command line options into rtip */
	rtip->useair = use_air;
	if( rt_dist_tol > 0 )  {
		rtip->rti_tol.dist = rt_dist_tol;
		rtip->rti_tol.dist_sq = rt_dist_tol * rt_dist_tol;
	}
	if( rt_perp_tol > 0 )  {
		rtip->rti_tol.perp = rt_perp_tol;
		rtip->rti_tol.para = 1 - rt_perp_tol;
	}

	if( (argc = rt_split_cmd( argv, MAXARGS, buf )) <= 0 )  {
		/* No words in input */
		(void)free(buf);
		return;
	}
	title_obj = bu_strdup(argv[0]);

	if( rtip->needprep == 0 )  {
		/* First clean up after the end of the previous frame */
		if(debug)bu_log("Cleaning previous model\n");
		view_end( &ap );
		view_cleanup( rtip );
		rt_clean(rtip);
		if(rdebug&RDEBUG_RTMEM_END)
			bu_prmem( "After rt_clean" );
	}

	/* Load the desired portion of the model */
	if( rt_gettrees(rtip, argc, (const char **)argv, npsw) < 0 )
		fprintf(stderr,"rt_gettrees(%s) FAILED\n", argv[0]);

	/* In case it changed from startup time via an OPT command */
	if( npsw > 1 )  {
		rt_g.rtg_parallel = 1;
	} else
		rt_g.rtg_parallel = 0;

	beginptr = (char *) sbrk(0);

	seen_gettrees = 1;
	(void)free(buf);

	prepare();

	/* Acknowledge that we are ready */
	if( pkg_send( MSG_GETTREES_REPLY,
	    title_obj, strlen(title_obj)+1, pcsrv ) < 0 )
		fprintf(stderr,"MSG_START error\n");
}

/*
 *			P R O C E S S _ C M D
 */
void
process_cmd(char *buf)
{
	register char	*cp;
	register char	*sp;
	register char	*ep;
	int		len;
	extern struct command_tab rt_cmdtab[];	/* from do.c */

	/* Parse the string */
	len = strlen(buf);
	ep = buf+len;
	sp = buf;
	cp = buf;
	while( sp < ep )  {
		/* Find next semi-colon */
		while( *cp && *cp != ';' )  cp++;
		*cp++ = '\0';
		/* Process this command */
		if( debug )  bu_log("process_cmd '%s'\n", sp);
		if( rt_do_cmd( ap.a_rt_i, sp, rt_cmdtab ) < 0 )  {
			bu_log("process_cmd: error on '%s'\n", sp );
			exit(1);
		}
		sp = cp;
	}
}

void
ph_options(register struct pkg_conn *pc, char *buf)
{

	if( debug )  fprintf(stderr, "ph_options: %s\n", buf );

	process_cmd( buf );

	/* Just in case command processed was "opt -P" */
	if( npsw < 0 )  {
		/* Negative number means "all but" npsw */
		npsw = max_cpus + npsw;
	}
	if( npsw > MAX_PSW )  npsw = MAX_PSW;

	if( width <= 0 || height <= 0 )  {
		bu_log("ph_options:  width=%d, height=%d\n", width, height);
		exit(3);
	}
	(void)free(buf);
}

void
ph_matrix(register struct pkg_conn *pc, char *buf)
{
#ifndef NO_MAGIC_CHECKING
	register struct rt_i *rtip = ap.a_rt_i;

	RT_CK_RTI(rtip);
#endif

	if( debug )  fprintf(stderr, "ph_matrix: %s\n", buf );

	/* Start options in a known state */
	AmbientIntensity = 0.4;
	hypersample = 0;
	jitter = 0;
	rt_perspective = 0;
	eye_backoff = 1.414;
	aspect = 1;
	stereo = 0;
	use_air = 0;
	width = height = 0;
	cell_width = cell_height = 0;
	lightmodel = 0;
	incr_mode = 0;
	rt_dist_tol = 0;
	rt_perp_tol = 0;

	process_cmd( buf );
	free(buf);

	seen_matrix = 1;
}

void
prepare(void)
{
	register struct rt_i *rtip = ap.a_rt_i;

	RT_CK_RTI(rtip);

	if( debug )  fprintf(stderr, "prepare()\n");

	/*
	 * initialize application -- it will allocate 1 line and
	 * set buf_mode=1, as well as do mlib_init().
	 */
	(void)view_init( &ap, title_file, title_obj, 0 );

	do_prep( rtip );

	if( rtip->nsolids <= 0 )  {
		bu_log("ph_matrix: No solids remain after prep.\n");
		exit(3);
	}

	grid_setup();

	/* initialize lighting */
	view_2init( &ap );

	rtip->nshots = 0;
	rtip->nmiss_model = 0;
	rtip->nmiss_tree = 0;
	rtip->nmiss_solid = 0;
	rtip->nmiss = 0;
	rtip->nhits = 0;
	rtip->rti_nrays = 0;

}

/* 
 *			P H _ L I N E S
 *
 *
 *  Process pixels from 'a' to 'b' inclusive.
 *  The results are sent back all at once.
 *  Limitation:  may not do more than 'width' pixels at once,
 *  because that is the size of the buffer (for now).
 */
void
ph_lines(struct pkg_conn *pc, char *buf)
{
	auto int		a,b, fr;
	struct line_info	info;
	register struct rt_i	*rtip = ap.a_rt_i;
	struct	bu_external	ext;

	RT_CK_RTI(rtip);

	if( debug > 1 )  fprintf(stderr, "ph_lines: %s\n", buf );
	if( !seen_gettrees )  {
		bu_log("ph_lines:  no MSG_GETTREES yet\n");
		return;
	}
	if( !seen_matrix )  {
		bu_log("ph_lines:  no MSG_MATRIX yet\n");
		return;
	}

	a=0;
	b=0;
	fr=0;
	if( sscanf( buf, "%d %d %d", &a, &b, &fr ) != 3 )  {
		bu_log("ph_lines:  %s conversion error\n", buf );
		exit(2);
	}

	srv_startpix = a;		/* buffer un-offset for view_pixel */
	if( b-a+1 > srv_scanlen )  b = a + srv_scanlen - 1;

	rtip->rti_nrays = 0;
	info.li_startpix = a;
	info.li_endpix = b;
	info.li_frame = fr;

	rt_prep_timer();
	do_run( a, b );
	info.li_nrays = rtip->rti_nrays;
	info.li_cpusec = rt_read_timer( (char *)0, 0 );
	info.li_percent = 42.0;	/* for now */

	if (!bu_struct_export( &ext, (genptr_t)&info, desc_line_info ) ) {
		bu_log("ph_lines: bu_struct_export failure\n");
		exit(98);
	}

	if(debug)  {
		fprintf(stderr,"PIXELS fr=%d pix=%d..%d, rays=%d, cpu=%g\n",
			info.li_frame,
			info.li_startpix, info.li_endpix,
			info.li_nrays, info.li_cpusec);
	}
	if( pkg_2send( MSG_PIXELS, ext.ext_buf, ext.ext_nbytes, scanbuf, (b-a+1)*3, pcsrv ) < 0 )  {
		fprintf(stderr,"MSG_PIXELS send error\n");
		db_free_external(&ext);
	}

	db_free_external(&ext);
}

int print_on = 1;

void
ph_loglvl(register struct pkg_conn *pc, char *buf)
{
	if(debug) fprintf(stderr, "ph_loglvl %s\n", buf);
	if( buf[0] == '0' )
		print_on = 0;
	else	print_on = 1;
	(void)free(buf);
}

/**** Other replacement routines from libbu/log.c ****/
int	bu_log_indent_cur_level = 0; /* formerly rt_g.rtg_logindent */
/*
 *			B U _ L O G _ I N D E N T _ D E L T A
 *
 *  Change indentation level by indicated number of characters.
 *  Call with a large negative number to cancel all indentation.
 */
void
bu_log_indent_delta(int delta)
{
	if( (bu_log_indent_cur_level += delta) < 0 )
		bu_log_indent_cur_level = 0;
}

/*
 *			B U _ L O G _ I N D E N T _ V L S
 *
 *  For multi-line vls generators, honor logindent level like bu_log() does,
 *  and prefix the proper number of spaces.
 *  Should be called at the front of each new line.
 */
void
bu_log_indent_vls(struct bu_vls *v)
{
	bu_vls_spaces( v, bu_log_indent_cur_level );
}


/*
 *			B U _ L O G
 *
 *  Log an error.
 *  This version buffers a full line, to save network traffic.
 */
#if (__STDC__ && !apollo)
void
bu_log( char *fmt, ... )
{
	va_list ap;
	char buf[512];		/* a generous output line.  Must be AUTO, else non-PARALLEL. */

	if( print_on == 0 )  return;
	bu_semaphore_acquire( BU_SEM_SYSCALL );
	va_start( ap, fmt );
	(void)vsprintf( buf, fmt, ap );
	va_end(ap);

	if( pcsrv == PKC_NULL || pcsrv == PKC_ERROR )  {
		fprintf(stderr, "%s", buf);
		goto out;
	}
	if(debug) fprintf(stderr, "%s", buf);
	if( pkg_send( MSG_PRINT, buf, strlen(buf)+1, pcsrv ) < 0 )  {
		fprintf(stderr,"pkg_send MSG_PRINT failed\n");
		exit(12);
	}
out:
	bu_semaphore_release( BU_SEM_SYSCALL );
}
#else /* __STDC__ */

#if defined(sgi) && !defined(mips)
# define _sgi3d	1
#endif

#if (defined(BSD) && !defined(_sgi3d)) || defined(mips) || defined(CRAY2)
/*
 *  			R T _ L O G
 *  
 *  Log an RT library event using the Berkeley _doprnt() routine.
 */
/* VARARGS */
void
bu_log(va_alist)
va_dcl
{
	va_list		ap;
	char		*fmt;
	char		buf[512];
	FILE		strbuf;
	static char	*cp;			/* NON-PARALLEL */

	if( print_on == 0 )  return;
	if( cp == (char *)0 )  cp = buf;

	bu_semaphore_acquire( BU_SEM_SYSCALL );		/* lock */
	va_start(ap);
	fmt = va_arg(ap,char *);
#if defined(mips) || (defined(alliant) && defined(i860))
	(void) vsprintf( cp, fmt, ap );
#else
	strbuf._flag = _IOWRT|_IOSTRG;
#if defined(sun)
	strbuf._ptr = (unsigned char *)cp;
#else
	strbuf._ptr = cp;
#endif
	strbuf._cnt = sizeof(buf)-(cp-buf);
	(void) _doprnt( fmt, ap, &strbuf );
	putc( '\0', &strbuf );
#endif
	va_end(ap);

	if(debug) fprintf(stderr, "%s", buf);
	while( *cp++ )  ;		/* leaves one beyond null */
	if( cp[-2] != '\n' )
		goto out;
	if( pcsrv == PKC_NULL || pcsrv == PKC_ERROR )  {
		fprintf(stderr, "%s", buf);
		goto out;
	}
	if( pkg_send( MSG_PRINT, buf, strlen(buf)+1, pcsrv ) < 0 )  {
		fprintf(stderr,"pkg_send MSG_PRINT failed\n");
		exit(12);
	}
	cp = buf;
out:
	bu_semaphore_release( BU_SEM_SYSCALL );		/* unlock */
}
#else
/* VARARGS */
void
bu_log( str, a, b, c, d, e, f, g, h )
char	*str;
int	a, b, c, d, e, f, g, h;
{
	char	buf[512];		/* a generous output line */

	if( print_on == 0 )  return;
	bu_semaphore_acquire( BU_SEM_SYSCALL );
	(void)sprintf( buf, str, a, b, c, d, e, f, g, h );

	if( pcsrv == PKC_NULL || pcsrv == PKC_ERROR )  {
		fprintf(stderr, "%s", buf);
		goto out;
	}
	if(debug) fprintf(stderr, "%s", buf);
	if( pkg_send( MSG_PRINT, buf, strlen(buf)+1, pcsrv ) < 0 )  {
		fprintf(stderr,"pkg_send MSG_PRINT failed\n");
		exit(12);
	}
out:
	bu_semaphore_release( BU_SEM_SYSCALL );
}
#endif /* not BSD */
#endif /* not __STDC__ */


/*
 *			B U _ B O M B
 *  
 *  Replacement for the LIBBU routine of the same name.
 */
int		bu_setjmp_valid = 0;	/* !0 = bu_jmpbuf is valid */
jmp_buf		bu_jmpbuf;		/* for BU_SETJMP() */

void
bu_bomb(const char *str)
{
	char	*bomb = "RTSRV terminated by rt_bomb()\n";

	if( pkg_send( MSG_PRINT, str, strlen(str)+1, pcsrv ) < 0 )  {
		fprintf(stderr,"rt_bomb MSG_PRINT failed\n");
	}
	if( pkg_send( MSG_PRINT, bomb, strlen(bomb)+1, pcsrv ) < 0 )  {
		fprintf(stderr,"rt_bomb MSG_PRINT failed\n");
	}

	if(debug)  fprintf(stderr,"\n%s\n", str);
	fflush(stderr);
	if( RT_G_DEBUG || rt_g.NMG_debug || bu_debug || debug )
		abort();	/* should dump */
	exit(12);
}

void
ph_unexp(register struct pkg_conn *pc, char *buf)
{
	register int i;

	if(debug) fprintf(stderr, "ph_unexp %s\n", buf);

	for( i=0; pc->pkc_switch[i].pks_handler != NULL; i++ )  {
		if( pc->pkc_switch[i].pks_type == pc->pkc_type )  break;
	}
	bu_log("ph_unexp: unable to handle %s message: len %d",
		pc->pkc_switch[i].pks_title, pc->pkc_len);
	*buf = '*';
	(void)free(buf);
}

/*
 *			P H _ E N D
 */
void
ph_end(register struct pkg_conn *pc, char *buf)
{
	if( debug )  fprintf(stderr, "ph_end\n");
	pkg_close(pcsrv);
	exit(0);
}

/*
 *			P H _ P R I N T
 */
void
ph_print(register struct pkg_conn *pc, char *buf)
{
	fprintf(stderr,"msg: %s\n", buf);
	(void)free(buf);
}

/* Stub for do.c */
void
memory_summary(void)
{
}
@


11.35
log
@change conf.h to a wrapped config.h
@
text
@d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/remrt/rtsrv.c,v 11.34 2004/04/05 05:45:58 morrison Exp $ (BRL)";
@


11.34
log
@merge of ansi-6-0-branch into head
@
text
@d18 6
a23 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
a24 1
#include "conf.h"
@


11.33
log
@update copyright to include span through 2003
@
text
@d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/remrt/rtsrv.c,v 11.32 2003/10/31 13:50:07 jra Exp $ (BRL)";
d120 11
a130 11
void	ph_unexp();	/* foobar message handler */
void	ph_enqueue();	/* Addes message to linked list */
void	ph_dirbuild();
void	ph_gettrees();
void	ph_matrix();
void	ph_options();
void	ph_lines();
void	ph_end();
void	ph_restart();
void	ph_loglvl();
void	ph_cd();
d132 1
a132 1
void	prepare();
d160 1
a160 3
main(argc, argv)
int argc;
char **argv;
d399 1
a399 3
ph_enqueue(pc, buf)
register struct pkg_conn *pc;
char	*buf;
d412 1
a412 3
ph_cd(pc, buf)
register struct pkg_conn *pc;
char *buf;
d423 1
a423 3
ph_restart(pc, buf)
register struct pkg_conn *pc;
char *buf;
d440 1
a440 3
ph_dirbuild(pc, buf)
register struct pkg_conn *pc;
char *buf;
d491 1
a491 3
ph_gettrees(pc, buf)
register struct pkg_conn *pc;
char *buf;
d557 1
a557 2
process_cmd( buf )
char	*buf;
d585 1
a585 3
ph_options( pc, buf )
register struct pkg_conn *pc;
char	*buf;
d607 1
a607 3
ph_matrix(pc, buf)
register struct pkg_conn *pc;
char *buf;
d640 1
a640 1
prepare()
d686 1
a686 3
ph_lines(pc, buf)
struct pkg_conn *pc;
char *buf;
d749 1
a749 3
ph_loglvl(pc, buf)
register struct pkg_conn *pc;
char *buf;
d767 1
a767 2
bu_log_indent_delta( delta )
int	delta;
d781 1
a781 2
bu_log_indent_vls( v )
struct bu_vls	*v;
d916 1
a916 2
bu_bomb(str)
const char *str;
d935 1
a935 3
ph_unexp(pc, buf)
register struct pkg_conn *pc;
char *buf;
d954 1
a954 3
ph_end(pc, buf)
register struct pkg_conn *pc;
char *buf;
d965 1
a965 3
ph_print(pc, buf)
register struct pkg_conn *pc;
char *buf;
d973 1
a973 1
memory_summary()
@


11.32
log
@rdebug variable needed to be "external int" to agree with move
of the variable to liboptical.
@
text
@d15 1
a15 1
 *	This software is Copyright (C) 1985 by the United States Army.
d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/remrt/rtsrv.c,v 11.31 2002/08/20 17:08:37 jra Exp $ (BRL)";
@


11.31
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/remrt/rtsrv.c,v 11.29 2001/08/11 13:18:07 butler Exp $ (BRL)";
d99 1
a99 1
int		rdebug;			/* RT program debugging (not library) */
@


11.31.4.1
log
@sync to HEAD...
@
text
@d15 1
a15 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/remrt/rtsrv.c,v 11.33 2004/02/02 17:39:38 morrison Exp $ (BRL)";
d99 1
a99 1
extern int	rdebug;			/* RT program debugging (not library) */
@


11.31.10.1
log
@updates from HEAD
@
text
@d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/remrt/rtsrv.c,v 11.32 2003/10/31 13:50:07 jra Exp $ (BRL)";
d99 1
a99 1
extern int	rdebug;			/* RT program debugging (not library) */
@


11.31.10.2
log
@merge from HEAD
@
text
@d15 1
a15 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/remrt/rtsrv.c,v 11.33 2004/02/02 17:39:38 morrison Exp $ (BRL)";
@


11.31.10.3
log
@merge from head
@
text
@d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/remrt/rtsrv.c,v 11.31.10.2 2004/02/12 19:40:28 erikg Exp $ (BRL)";
@


11.31.2.1
log
@Initial ANSIfication
@
text
@d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/remrt/rtsrv.c,v 11.31 2002/08/20 17:08:37 jra Exp $ (BRL)";
d120 11
a130 11
void	ph_unexp(register struct pkg_conn *pc, char *buf);	/* foobar message handler */
void	ph_enqueue(register struct pkg_conn *pc, char *buf);	/* Addes message to linked list */
void	ph_dirbuild(register struct pkg_conn *pc, char *buf);
void	ph_gettrees(register struct pkg_conn *pc, char *buf);
void	ph_matrix(register struct pkg_conn *pc, char *buf);
void	ph_options(register struct pkg_conn *pc, char *buf);
void	ph_lines(struct pkg_conn *pc, char *buf);
void	ph_end(register struct pkg_conn *pc, char *buf);
void	ph_restart(register struct pkg_conn *pc, char *buf);
void	ph_loglvl(register struct pkg_conn *pc, char *buf);
void	ph_cd(register struct pkg_conn *pc, char *buf);
d132 1
a132 1
void	prepare(void);
d160 3
a162 1
main(int argc, char **argv)
d401 3
a403 1
ph_enqueue(register struct pkg_conn *pc, char *buf)
d416 3
a418 1
ph_cd(register struct pkg_conn *pc, char *buf)
d429 3
a431 1
ph_restart(register struct pkg_conn *pc, char *buf)
d448 3
a450 1
ph_dirbuild(register struct pkg_conn *pc, char *buf)
d501 3
a503 1
ph_gettrees(register struct pkg_conn *pc, char *buf)
d569 2
a570 1
process_cmd(char *buf)
d598 3
a600 1
ph_options(register struct pkg_conn *pc, char *buf)
d622 3
a624 1
ph_matrix(register struct pkg_conn *pc, char *buf)
d657 1
a657 1
prepare(void)
d703 3
a705 1
ph_lines(struct pkg_conn *pc, char *buf)
d768 3
a770 1
ph_loglvl(register struct pkg_conn *pc, char *buf)
d788 2
a789 1
bu_log_indent_delta(int delta)
d803 2
a804 1
bu_log_indent_vls(struct bu_vls *v)
d939 2
a940 1
bu_bomb(const char *str)
d959 3
a961 1
ph_unexp(register struct pkg_conn *pc, char *buf)
d980 3
a982 1
ph_end(register struct pkg_conn *pc, char *buf)
d993 3
a995 1
ph_print(register struct pkg_conn *pc, char *buf)
d1003 1
a1003 1
memory_summary(void)
@


11.31.2.2
log
@sync branch with HEAD
@
text
@d15 1
a15 1
 *	This software is Copyright (C) 1985-2004 by the United States Army.
d18 1
a18 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d99 1
a99 1
extern int	rdebug;			/* RT program debugging (not library) */
@


11.30
log
@Converted from K&R to ANSI C - RFH
@
text
@d120 11
a130 11
void	ph_unexp(register struct pkg_conn *pc, char *buf);	/* foobar message handler */
void	ph_enqueue(register struct pkg_conn *pc, char *buf);	/* Addes message to linked list */
void	ph_dirbuild(register struct pkg_conn *pc, char *buf);
void	ph_gettrees(register struct pkg_conn *pc, char *buf);
void	ph_matrix(register struct pkg_conn *pc, char *buf);
void	ph_options(register struct pkg_conn *pc, char *buf);
void	ph_lines(struct pkg_conn *pc, char *buf);
void	ph_end(register struct pkg_conn *pc, char *buf);
void	ph_restart(register struct pkg_conn *pc, char *buf);
void	ph_loglvl(register struct pkg_conn *pc, char *buf);
void	ph_cd(register struct pkg_conn *pc, char *buf);
d132 1
a132 1
void	prepare(void);
d160 3
a162 1
main(int argc, char **argv)
d401 3
a403 1
ph_enqueue(register struct pkg_conn *pc, char *buf)
d416 3
a418 1
ph_cd(register struct pkg_conn *pc, char *buf)
d429 3
a431 1
ph_restart(register struct pkg_conn *pc, char *buf)
d448 3
a450 1
ph_dirbuild(register struct pkg_conn *pc, char *buf)
d501 3
a503 1
ph_gettrees(register struct pkg_conn *pc, char *buf)
d569 2
a570 1
process_cmd(char *buf)
d598 3
a600 1
ph_options(register struct pkg_conn *pc, char *buf)
d622 3
a624 1
ph_matrix(register struct pkg_conn *pc, char *buf)
d657 1
a657 1
prepare(void)
d703 3
a705 1
ph_lines(struct pkg_conn *pc, char *buf)
d768 3
a770 1
ph_loglvl(register struct pkg_conn *pc, char *buf)
d788 2
a789 1
bu_log_indent_delta(int delta)
d803 2
a804 1
bu_log_indent_vls(struct bu_vls *v)
d939 2
a940 1
bu_bomb(const char *str)
d959 3
a961 1
ph_unexp(register struct pkg_conn *pc, char *buf)
d980 3
a982 1
ph_end(register struct pkg_conn *pc, char *buf)
d993 3
a995 1
ph_print(register struct pkg_conn *pc, char *buf)
d1003 1
a1003 1
memory_summary(void)
@


11.29
log
@misc compiler warning changes
@
text
@d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/remrt/rtsrv.c,v 11.28 2001/05/17 20:06:01 morrison Exp $ (BRL)";
d120 11
a130 11
void	ph_unexp();	/* foobar message handler */
void	ph_enqueue();	/* Addes message to linked list */
void	ph_dirbuild();
void	ph_gettrees();
void	ph_matrix();
void	ph_options();
void	ph_lines();
void	ph_end();
void	ph_restart();
void	ph_loglvl();
void	ph_cd();
d132 1
a132 1
void	prepare();
d160 1
a160 3
main(argc, argv)
int argc;
char **argv;
d399 1
a399 3
ph_enqueue(pc, buf)
register struct pkg_conn *pc;
char	*buf;
d412 1
a412 3
ph_cd(pc, buf)
register struct pkg_conn *pc;
char *buf;
d423 1
a423 3
ph_restart(pc, buf)
register struct pkg_conn *pc;
char *buf;
d440 1
a440 3
ph_dirbuild(pc, buf)
register struct pkg_conn *pc;
char *buf;
d491 1
a491 3
ph_gettrees(pc, buf)
register struct pkg_conn *pc;
char *buf;
d557 1
a557 2
process_cmd( buf )
char	*buf;
d585 1
a585 3
ph_options( pc, buf )
register struct pkg_conn *pc;
char	*buf;
d607 1
a607 3
ph_matrix(pc, buf)
register struct pkg_conn *pc;
char *buf;
d640 1
a640 1
prepare()
d686 1
a686 3
ph_lines(pc, buf)
struct pkg_conn *pc;
char *buf;
d749 1
a749 3
ph_loglvl(pc, buf)
register struct pkg_conn *pc;
char *buf;
d767 1
a767 2
bu_log_indent_delta( delta )
int	delta;
d781 1
a781 2
bu_log_indent_vls( v )
struct bu_vls	*v;
d916 1
a916 2
bu_bomb(str)
const char *str;
d935 1
a935 3
ph_unexp(pc, buf)
register struct pkg_conn *pc;
char *buf;
d954 1
a954 3
ph_end(pc, buf)
register struct pkg_conn *pc;
char *buf;
d965 1
a965 3
ph_print(pc, buf)
register struct pkg_conn *pc;
char *buf;
d973 1
a973 1
memory_summary()
@


11.28
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/remrt/rtsrv.c,v 11.27 2001/05/16 21:38:15 morrison Exp $ (BRL)";
d174 1
a174 1
			sscanf( argv[2], "%x", &rt_g.debug );
d177 1
a177 1
			sscanf( argv[2], "%x", &rdebug );
@


11.27
log
@PRODUCTION optimizations
@
text
@d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/remrt/rtsrv.c,v 11.26 2001/04/20 22:31:18 morrison Exp $ (BRL)";
d953 1
a953 1
	if( rt_g.debug || rt_g.NMG_debug || bu_debug || debug )
@


11.26
log
@CONST to const
@
text
@d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/remrt/rtsrv.c,v 11.25 2000/10/24 19:36:14 mike Exp $ (BRL)";
d626 1
d630 1
@


11.25
log
@
Header file sequencing.
@
text
@d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/remrt/rtsrv.c,v 11.24 2000/09/07 20:10:35 mike Exp $ (BRL)";
d543 1
a543 1
	if( rt_gettrees(rtip, argc, (CONST char **)argv, npsw) < 0 )
d938 1
a938 1
CONST char *str;
@


11.24
log
@
Added stub for do.c
@
text
@d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/remrt/rtsrv.c,v 11.23 2000/08/24 22:23:57 mike Exp $ (BRL)";
d27 5
d51 2
d54 1
a54 3
#include "rtlist.h"
#include "rtstring.h"
#include "externs.h"
@


11.23
log
@
RCSid
@
text
@d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/remrt/rtsrv.c,v 11.22 2000/07/25 17:29:43 butler Exp $ (BRL)";
d314 2
a315 2
	 *  Initialize all the per-CPU memory resources.
	 *  Go for the max, as TCL interface may change npsw as we run.
d317 2
a318 4
	for( n=0; n < MAX_PSW; n++ )  {
		rt_init_resource( &resource[n], n );
		bn_rand_init( resource[n].re_randptr, n );
	}
d450 1
d476 9
d992 6
@


11.22
log
@../rt/rdebug.h became rtprivate.h
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/remrt/rtsrv.c,v 11.21 2000/05/19 12:34:48 jra Exp $ (BRL)";
@


11.21
log
@Added "save_overlaps" variable (used by do.c)
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/remrt/rtsrv.c,v 11.20 2000/03/15 22:52:55 mike Exp $ (BRL)";
d56 1
a56 1
#include "../rt/rdebug.h"
@


11.20
log
@
Since we replace bu_bomb(), need to replace the variables too.
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/remrt/rtsrv.c,v 11.19 2000/03/09 21:52:04 mike Exp $ (BRL)";
d109 2
@


11.19
log
@
Added new variable.
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/remrt/rtsrv.c,v 11.18 2000/01/31 15:14:31 jra Exp $ (BRL)";
d918 3
@


11.18
log
@Eliminated an unused variable
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/remrt/rtsrv.c,v 11.17 1999/12/30 05:49:09 butler Exp $ (BRL)";
d84 1
@


11.17
log
@additions for -v flag to rt
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/remrt/rtsrv.c,v 11.16 1999/10/30 03:06:26 butler Exp $ (BRL)";
a156 1
	FILE		*fp;
@


11.16
log
@Moved mathtab/rand_half from rt into libbn
Expanded structparse to include description and default
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/remrt/rtsrv.c,v 11.15 1998/12/28 21:54:57 mike Exp $ (BRL)";
d94 1
a94 1

@


11.15
log
@Core functionality of libbu/log.c requires implementing two more routines.
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/remrt/rtsrv.c,v 11.14 1998/09/22 00:30:18 mike Exp $ (BRL)";
a54 1
#include "../rt/mathtab.h"
d317 1
a317 1
		rand_init( resource[n].re_randptr, n );
@


11.14
log
@Don't need material.h
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/remrt/rtsrv.c,v 11.13 1998/06/25 07:28:06 mike Exp $ (BRL)";
d762 31
@


11.13
log
@Port to sun4
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/remrt/rtsrv.c,v 11.12 1997/12/16 08:10:29 mike Exp $ (BRL)";
a55 1
#include "../rt/material.h"
@


11.12
log
@Can't use static buffers in parallel code.
When there is lots of screaming via bu_log(), the buffer overflows.
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsrv.c,v 11.11 1997/12/16 07:48:29 mike Exp mike $ (BRL)";
d816 1
@


11.11
log
@Initialize all resource structures, as the count can change at runtime.
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsrv.c,v 11.10 1997/12/16 00:50:01 mike Exp mike $ (BRL)";
d775 1
a775 2
	static char buf[512];		/* a generous output line */
	static char *cp = buf+1;
d780 1
a780 1
	(void)vsprintf( cp, fmt, ap );
a782 3
	while( *cp++ )  ;		/* leaves one beyond null */
	if( cp[-2] != '\n' )
		goto out;
d784 1
a784 1
		fprintf(stderr, "%s", buf+1);
d787 2
a788 2
	if(debug) fprintf(stderr, "%s", buf+1);
	if( pkg_send( MSG_PRINT, buf+1, strlen(buf+1)+1, pcsrv ) < 0 )  {
a791 1
	cp = buf+1;
d814 1
a814 2
	static char	buf[512];
	static char	*cp;
d818 1
a818 1
	if( cp == (char *)0 )  cp = buf+1;
d838 1
a838 1
	if(debug) fprintf(stderr, "%s", buf+1);
d843 1
a843 1
		fprintf(stderr, "%s", buf+1);
d846 1
a846 1
	if( pkg_send( MSG_PRINT, buf+1, strlen(buf+1)+1, pcsrv ) < 0 )  {
d850 1
a850 1
	cp = buf+1;
d861 1
a861 2
	static char buf[512];		/* a generous output line */
	static char *cp = buf+1;
d865 2
a866 4
	(void)sprintf( cp, str, a, b, c, d, e, f, g, h );
	while( *cp++ )  ;		/* leaves one beyond null */
	if( cp[-2] != '\n' )
		goto out;
d868 1
a868 1
		fprintf(stderr, "%s", buf+1);
d871 2
a872 2
	if(debug) fprintf(stderr, "%s", buf+1);
	if( pkg_send( MSG_PRINT, buf+1, strlen(buf+1)+1, pcsrv ) < 0 )  {
a875 1
	cp = buf+1;
@


11.10
log
@Changed to use new symbol RT_SEM_LAST
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsrv.c,v 11.9 1997/12/16 00:29:26 mike Exp mike $ (BRL)";
d317 1
a317 1
	for( n=0; n < avail_cpus; n++ )  {
@


11.9
log
@Converted to bu_semaphore_acquire()
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsrv.c,v 11.8 1997/08/26 07:04:34 mike Exp mike $ (BRL)";
d304 1
a304 1
	bu_semaphore_init( BU_SEM_LAST );
@


11.8
log
@Eliminated per-frame memory leak by moving rt_init_resource()
out of worker() and into mainline.
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsrv.c,v 11.7 1997/07/01 23:39:47 mike Exp $ (BRL)";
d191 1
a191 1
	 * that will result in a deadlock in RES_ACQUIRE(res_syscall)!
d304 1
a304 6
	RES_INIT( &rt_g.res_syscall );
	RES_INIT( &rt_g.res_worker );
	RES_INIT( &rt_g.res_stats );
	RES_INIT( &rt_g.res_results );
	RES_INIT( &rt_g.res_model );
	/* DO NOT USE bu_log() before this point! */
d779 1
a779 1
	RES_ACQUIRE( &rt_g.res_syscall );
d798 1
a798 1
	RES_RELEASE( &rt_g.res_syscall );
d826 1
a826 1
	RES_ACQUIRE( &rt_g.res_syscall );		/* lock */
d858 1
a858 1
	RES_RELEASE( &rt_g.res_syscall );		/* unlock */
d871 1
a871 1
	RES_ACQUIRE( &rt_g.res_syscall );
d887 1
a887 1
	RES_RELEASE( &rt_g.res_syscall );
@


11.7
log
@Use new libbu routine
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsrv.c,v 11.6 1997/01/04 03:24:30 mike Exp mike $ (BRL)";
d55 1
d316 9
@


11.6
log
@libbu/libbn
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsrv.c,v 11.5 1996/08/27 05:32:36 mike Exp mike $ (BRL)";
d294 2
a295 15
#define PUBLIC_CPUS	"/usr/tmp/public_cpus"
	max_cpus = avail_cpus = bu_avail_cpus();
	if( (fp = fopen(PUBLIC_CPUS, "r")) != NULL )  {
		(void)fscanf( fp, "%d", &max_cpus );
		fclose(fp);
		if( max_cpus < 0 )  max_cpus = avail_cpus + max_cpus;
		if( max_cpus > avail_cpus )  max_cpus = avail_cpus;
	} else {
		(void)unlink(PUBLIC_CPUS);
		if( (fp = fopen(PUBLIC_CPUS, "w")) != NULL )  {
			fprintf(fp, "%d\n", avail_cpus);
			fclose(fp);
			(void)chmod(PUBLIC_CPUS, 0666);
		}
	}
@


11.5
log
@libbu
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsrv.c,v 11.4 1996/07/15 17:40:50 jra Exp mike $ (BRL)";
d61 1
a61 1
struct rt_list	WorkHead;
d64 1
a64 1
	struct rt_list	l;
d188 2
a189 2
	 * "rt_log", as that can cause rt_log to be entered recursively.
	 * Given the special version of rt_log in use here,
d239 2
a240 2
		if( rt_cpuget() > 0 )  {
			rt_cpuset( 9999999 );
d250 1
a250 1
			rt_pri_set(6);		/* highest "free" priority */
d252 1
a252 1
			rt_pri_set(19);		/* lowest priority */
d295 1
a295 1
	max_cpus = avail_cpus = rt_avail_cpus();
d321 1
a321 1
	/* DO NOT USE rt_log() before this point! */
d323 1
a323 1
	rt_log("using %d of %d cpus\n",
d330 1
a330 1
	RT_LIST_INIT( &WorkHead );
d339 1
a339 1
			rt_log("pkg_get error\n");
d346 1
a346 1
		tv.tv_sec = RT_LIST_NON_EMPTY( &WorkHead ) ? 0L : 9999L;
d353 1
a353 1
				rt_log("pkg_suckin error\n");
d365 1
a365 1
			rt_log("pkg_get error\n");
d370 3
a372 3
		if( RT_LIST_NON_EMPTY( &WorkHead ) )  {
			lp = RT_LIST_FIRST( pkg_queue, &WorkHead );
			RT_LIST_DEQUEUE( &lp->l );
d387 1
a387 1
				rt_log("bad list element, type=%d\n", lp->type );
d414 1
a414 1
	GETSTRUCT( lp, pkg_queue );
d417 1
a417 1
	RT_LIST_INSERT( &WorkHead, &lp->l );
d427 1
a427 1
		rt_log("ph_cd: chdir(%s) failure\n", buf);
d440 1
a440 1
	rt_log("Restarting\n");
d470 1
a470 1
		rt_log("ph_dirbuild:  MSG_DIRBUILD already seen, ignored\n");
d475 1
a475 1
	title_file = rt_strdup(argv[0]);
d479 1
a479 1
		rt_log("ph_dirbuild:  rt_dirbuild(%s) failure\n", title_file);
d525 1
a525 1
	title_obj = rt_strdup(argv[0]);
d529 1
a529 1
		if(debug)rt_log("Cleaning previous model\n");
d534 1
a534 1
			rt_prmem( "After rt_clean" );
d583 1
a583 1
		if( debug )  rt_log("process_cmd '%s'\n", sp);
d585 1
a585 1
			rt_log("process_cmd: error on '%s'\n", sp );
d610 1
a610 1
		rt_log("ph_options:  width=%d, height=%d\n", width, height);
d667 1
a667 1
		rt_log("ph_matrix: No solids remain after prep.\n");
d703 1
a703 1
	struct	rt_external	ext;
d709 1
a709 1
		rt_log("ph_lines:  no MSG_GETTREES yet\n");
d713 1
a713 1
		rt_log("ph_lines:  no MSG_MATRIX yet\n");
d721 1
a721 1
		rt_log("ph_lines:  %s conversion error\n", buf );
d739 2
a740 2
	if (!rt_struct_export( &ext, (genptr_t)&info, desc_line_info ) ) {
		rt_log("ph_lines: rt_struct_export failure\n");
d938 1
a938 1
	rt_log("ph_unexp: unable to handle %s message: len %d",
@


11.4
log
@Minor mods for IRIX 6.2
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsrv.c,v 11.3 1995/07/14 02:32:01 mike Exp jra $ (BRL)";
d773 1
a773 1
 *			R T L O G
d780 1
a780 1
rt_log( char *fmt, ... )
d822 1
a822 1
rt_log(va_alist)
d871 1
a871 1
rt_log( str, a, b, c, d, e, f, g, h )
d902 1
a902 1
 *			R T _ B O M B
d904 1
a904 1
 *  Abort the RT library
d907 2
a908 2
rt_bomb(str)
char *str;
d921 1
a921 1
	if( rt_g.debug || rt_g.NMG_debug || debug )
@


11.3
log
@Changed from abusing list.h to new structure pkg_queue,
based upon rt_list stuff.
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsrv.c,v 11.2 1995/03/01 03:57:15 mike Exp mike $ (BRL)";
d124 3
d649 1
@


11.2
log
@Added support for -T command, calculation tolerances.
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsrv.c,v 11.1 95/01/04 10:04:03 mike Rel4_4 Locker: mike $ (BRL)";
a58 1
#include "./list.h"
d61 1
a61 2
struct list	*FreeList;
struct list	WorkHead;
d63 6
d327 1
a327 1
	WorkHead.li_forw = WorkHead.li_back = &WorkHead;
d330 1
a330 1
		register struct list	*lp;
d343 1
a343 1
		tv.tv_sec = WorkHead.li_forw != &WorkHead ? 0L : 9999L;
d367 4
a370 4
		if( (lp = WorkHead.li_forw) != &WorkHead )  {

			DEQUEUE_LIST( lp );
			switch( lp->li_start )  {
d372 1
a372 1
				ph_matrix( (struct pkg_conn *)0, (char *)lp->li_stop );
d375 1
a375 1
				ph_lines( (struct pkg_conn *)0, (char *)lp->li_stop );
d378 1
a378 1
				ph_options( (struct pkg_conn *)0, (char *)lp->li_stop );
d381 1
a381 1
				ph_gettrees( (struct pkg_conn *)0, (char *)lp->li_stop );
d384 1
a384 1
				rt_log("bad list element %d\n", lp->li_start );
d387 1
a387 1
			FREE_LIST( lp );
d407 1
a407 1
	register struct list	*lp;
d411 4
a414 5
	/* XXX This should be a different structure, based on rtlist.h */
	GET_LIST( lp );
	lp->li_start = (long)pc->pkc_type;
	lp->li_stop = (long)buf;
	APPEND_LIST( lp, WorkHead.li_back );
@


11.1
log
@Release_4.4
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsrv.c,v 10.13 94/12/30 01:18:56 mike Exp $ (BRL)";
d88 2
d503 11
d634 2
@


10.13
log
@setpgrp() has a new name in POSIX land.
DEC Alpha
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsrv.c,v 10.12 94/12/21 16:53:37 mike Exp Locker: mike $ (BRL)";
@


10.12
log
@Closed bug 254
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsrv.c,v 10.11 94/12/21 14:54:05 stay Exp Locker: mike $ (BRL)";
d221 3
a223 2
#if defined(SYSV) && !defined(_BSD_COMPAT)
		setpgrp();
@


10.11
log
@fixed a missed sbrk call
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsrv.c,v 10.10 94/12/21 14:49:44 stay Exp Locker: stay $ (BRL)";
d219 5
a223 2
/* SysV uses setprgrp with no args and it can't fail */
#ifndef SYSV
a225 2
#else
		setpgrp();
@


10.10
log
@fixed sbrk for (char *) cast to beginptr
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsrv.c,v 10.9 94/11/24 02:12:35 mike Exp Locker: stay $ (BRL)";
d526 1
a526 1
	beginptr = sbrk(0);
@


10.9
log
@Fix from Tim Smith for Bug #211
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsrv.c,v 10.8 94/11/05 03:35:04 mike Exp Locker: mike $ (BRL)";
d281 1
a281 1
	beginptr = sbrk(0);
@


10.8
log
@Irix 6
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsrv.c,v 10.7 94/08/25 17:51:06 gdurf Exp Locker: mike $ (BRL)";
d219 2
d223 3
@


10.7
log
@Removed bsdselect
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsrv.c,v 10.6 1994/08/23 17:43:54 gdurf Exp gdurf $ (BRL)";
a89 1
static char outbuf[132];
a148 1
	auto int	ibits;
d398 1
d400 2
a401 2
	lp->li_start = (int)pc->pkc_type;
	lp->li_stop = (int)buf;
a443 1
	int	argc;
a444 1
	register int i;
d448 1
a448 1
	if( (argc = rt_split_cmd( argv, MAXARGS, buf )) <= 0 )  {
a673 1
	int	len;
a709 1
	len = 0;
@


10.6
log
@Added provisions for Irix4
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsrv.c,v 10.5 1994/08/12 21:09:09 gdurf Exp gdurf $ (BRL)";
d33 2
a36 1
# include <sys/time.h>
d320 2
d330 7
a336 6
		ibits = 1 << pcsrv->pkc_fd;
		/* Use library routine from libsysv */
		ibits = bsdselect( ibits, 
			WorkHead.li_forw != &WorkHead ? 0 : 9999,
			0 );
		if( ibits )  {
@


10.5
log
@Factored some ifdefs
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsrv.c,v 10.4 1994/08/11 18:59:49 gdurf Exp gdurf $ (BRL)";
d22 4
a59 2

extern char	*sbrk();
@


10.4
log
@Changes by mike
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsrv.c,v 10.3 94/05/06 03:43:55 mike Exp Locker: mike $ (BRL)";
d20 2
d23 1
a23 2
#define _BSD_TYPES		/* Needed for IRIX 5.0.1 */
#if __STDC__
d35 1
a35 2
#if BSD == 43
# include <sys/types.h>
@


10.3
log
@If debugging, dump core in rt_bomb().
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsrv.c,v 10.2 93/10/26 00:36:30 mike Exp Locker: mike $ (BRL)";
d154 13
a166 1
	if( strcmp( argv[1], "-d" ) == 0 )  {
a167 1
		debug++;
d487 2
d499 1
d501 2
d504 2
d594 2
d622 2
d673 2
@


10.2
log
@IRIX 5.0.1
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsrv.c,v 10.1 91/10/12 06:42:36 mike Rel4_0 Locker: mike $ (BRL)";
d867 1
a867 1
	if( rt_g.debug || rt_g.NMG_debug )
@


10.1
log
@Release_4.0
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsrv.c,v 9.24 91/08/31 03:07:36 mike Exp $ (BRL)";
d21 1
@


9.24
log
@Stardent pointed out amusing typo, it's pkg_conn, not pkg_comm.
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsrv.c,v 9.23 91/07/19 03:00:38 mike Exp $ (BRL)";
@


9.23
log
@Added special detection of SGI 3d
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsrv.c,v 9.22 91/07/01 22:37:41 mike Exp $ (BRL)";
d343 1
a343 1
				ph_matrix( (struct pkg_comm *)0, (char *)lp->li_stop );
d346 1
a346 1
				ph_lines( (struct pkg_comm *)0, (char *)lp->li_stop );
d349 1
a349 1
				ph_options( (struct pkg_comm *)0, (char *)lp->li_stop );
d352 1
a352 1
				ph_gettrees( (struct pkg_comm *)0, (char *)lp->li_stop );
d390 1
a390 1
register struct pkg_comm *pc;
d403 1
a403 1
register struct pkg_comm *pc;
d422 1
a422 1
register struct pkg_comm *pc;
d467 1
a467 1
register struct pkg_comm *pc;
d490 1
a490 2
#define npsw 1		/* XXXXXXXXX Temp. disable parallel prep, it may be buggy XXXXX -M */
	if( rt_gettrees(rtip, argc, argv, npsw) < 0 )
a491 1
#undef npsw
d546 1
a546 1
register struct pkg_comm *pc;
d570 1
a570 1
register struct pkg_comm *pc;
d642 1
a642 1
struct pkg_comm *pc;
@


9.22
log
@Eliminated use of rti_headsolid, which no longer exists.
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsrv.c,v 9.21 91/02/06 16:06:46 mike Exp $ (BRL)";
d757 5
a761 1
#if defined(BSD) || defined(mips) || defined(CRAY2)
@


9.21
log
@Oops, /usr/tmp/public_cpus
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsrv.c,v 9.20 91/02/06 15:36:50 mike Exp $ (BRL)";
d613 1
a613 1
	if( RT_LIST_IS_EMPTY( &rtip->rti_headsolid ) )  {
@


9.20
log
@Added /tmp/public_cpus file, to limit CPU use
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsrv.c,v 9.19 91/01/27 10:53:27 cjohnson Exp $ (BRL)";
d265 1
a265 1
#define PUBLIC_CPUS	"/tmp/public_cpus"
@


9.19
log
@Change over to the new opaque style of import/export structures.
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsrv.c,v 9.18 91/01/24 16:21:48 mike Exp $ (BRL)";
d98 3
d147 1
d265 16
d282 1
a282 1
	npsw = rt_avail_cpus();
d294 6
a299 1
	if( npsw > 1 )  rt_log("%d processors\n", npsw );
d559 1
a559 1
		npsw = rt_avail_cpus() + npsw;
@


9.18
log
@Allowed negative values for "opt -P", to mean "all but N" cpus.
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsrv.c,v 9.17 90/12/08 04:46:11 mike Exp $ (BRL)";
d626 1
a626 1
	char	*cp;
d661 1
a661 2
	cp = rt_struct_export( &len, (char *)&info, desc_line_info );
	if( cp == (char *)0 )  {
d672 1
a672 1
	if( pkg_2send( MSG_PIXELS, cp, len, scanbuf, (b-a+1)*3, pcsrv ) < 0 )  {
d674 1
a674 1
		(void)free(cp);
d677 1
a677 1
	(void)free(buf);
@


9.17
log
@inout headers are now in raytrace.h
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsrv.c,v 9.16 90/11/24 01:29:43 mike Exp $ (BRL)";
d42 2
d47 1
d56 2
a60 3
extern char	*sbrk();
extern double atof();

a262 4
#ifdef CRAY
	/* The Cray does not have any way to know how many CPUs it has */
	npsw = MAX_PSW;
#endif
d530 7
@


9.16
log
@Minor Sun nit.
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsrv.c,v 9.15 90/11/24 00:29:06 mike Exp $ (BRL)";
a50 1
#include "./inout.h"
d656 1
a656 1
	cp = struct_export( &len, (char *)&info, desc_line_info );
d658 1
a658 1
		rt_log("ph_lines: struct_export failure\n");
@


9.15
log
@Oops, typo in sprintf() fakeout.  Thats _IOWRT !
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsrv.c,v 9.14 90/11/22 05:36:37 mike Exp $ (BRL)";
d756 3
d760 1
@


9.14
log
@Improved on special copy of rt_log.
Uses vsprintf rather than _doprnt on MIPS and Alliant FX/2800
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsrv.c,v 9.13 90/11/22 03:53:46 mike Exp $ (BRL)";
d755 1
a755 1
	strbuf._flag = _IOWRD|_IOSTRG;
@


9.13
log
@Now, protocol.h has a define for the maximum number of pixels
that can be assigned.
Fixed bug with leaving a single CPU spinning when dispatcher
vanishes abruptly.  Was due to the libpkg error handler being
pointed to rt_log().  rt_log() would call pkg_suckin(), which
would go to the error handler (rt_log), which would deadlock
in RES_ACQUIRE, due to the recursion.
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsrv.c,v 9.12 90/11/21 06:35:37 mike Exp $ (BRL)";
d748 6
a753 5
#if defined(mips)
	strbuf._file = 20;	/* _NFILE, flags as not a file */
	strbuf._flag = 0;
	strbuf._ptr = cp;
	strbuf._cnt = sizeof(buf)-(cp-buf);
a757 4
#endif
	RES_ACQUIRE( &rt_g.res_syscall );		/* lock */
	va_start(ap);
	fmt = va_arg(ap,char *);
d760 1
@


9.12
log
@Changed protocol to send DIRBUILD and GETTREES as separate operations.
Also added SGI 4D hacks for local copy of rt_log(), so it works.
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsrv.c,v 9.11 90/11/15 23:45:50 mike Exp $ (BRL)";
d66 1
a66 1
int		srv_scanlen = 8*1024;	/* max assignment */
a156 18
	beginptr = sbrk(0);

	/* Need to set rtg_parallel non_zero here for RES_INIT to work */
	npsw = rt_avail_cpus();
#ifdef CRAY
	/* The Cray does not have any way to know how many CPUs it has */
	npsw = MAX_PSW;
#endif
	if( npsw > 1 )  {
		rt_g.rtg_parallel = 1;
	} else
		rt_g.rtg_parallel = 0;
	RES_INIT( &rt_g.res_syscall );
	RES_INIT( &rt_g.res_worker );
	RES_INIT( &rt_g.res_stats );
	RES_INIT( &rt_g.res_results );
	RES_INIT( &rt_g.res_model );

d159 7
d167 1
a167 1
		pkgswitch, rt_log );
d253 26
d473 1
a473 1
	/* In case it changed from startup time */
a475 1
		rt_log("%d processors\n", npsw );
d812 26
@


9.11
log
@Switched to rt_gettrees(), to enable parallel prepping.
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsrv.c,v 9.10 90/10/16 11:21:19 mike Exp $ (BRL)";
d88 4
a91 1
static int seen_start, seen_matrix;	/* state flags */
d102 2
a103 1
void	ph_start();
d112 2
a113 1
	{ MSG_START,	ph_start,	"Startup" },
d314 3
d378 5
d384 1
a384 1
ph_start(pc, buf)
d394 1
a394 1
	if( debug )  fprintf(stderr, "ph_start: %s\n", buf );
d402 2
a403 2
	if( argc < 2 )  {
		rt_log("ph_start:  no objects? %s\n", buf);
a406 5
	if( seen_start )  {
		rt_log("ph_start:  start already seen, ignored\n");
		(void)free(buf);
		return;
	}
a408 1
	title_obj = rt_strdup(argv[1]);
a409 2
	rt_prep_timer();		/* Start timing preparations */

d412 1
a412 1
		rt_log("ph_start:  rt_dirbuild(%s) failure\n", title_file);
d416 1
a416 1
	rt_log( "db title:  %s\n", idbuf);
d418 34
d454 2
a455 2
	if( rt_gettrees(rtip, argc-1, argv+1, npsw) < 0 )
		fprintf(stderr,"rt_gettrees(%s) FAILED\n", argv[1]);
d461 1
a461 1
		rt_log("ph_start:  running with %d processors\n", npsw );
d467 1
a467 1
	seen_start = 1;
d470 2
d473 2
a474 2
	if( pkg_send( MSG_START,
	    PROTOCOL_VERSION, strlen(PROTOCOL_VERSION)+1, pcsrv ) < 0 )
d478 3
d553 9
a587 1
	seen_matrix = 1;
d611 2
a612 2
	if( !seen_start )  {
		rt_log("ph_lines:  no start yet\n");
d616 1
a616 1
		rt_log("ph_lines:  no matrix yet\n");
d683 1
a683 1
#if __STDC__
d694 1
a694 1
	(void)vfprintf( stderr, fmt, ap );
d705 2
a706 1
	if( pkg_send( MSG_PRINT, buf+1, strlen(buf+1)+1, pcsrv ) < 0 )
d708 1
d713 26
d740 28
d788 2
a789 1
	if( pkg_send( MSG_PRINT, buf+1, strlen(buf+1)+1, pcsrv ) < 0 )
d791 1
d796 1
@


9.10
log
@Changed to rtlist.h
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsrv.c,v 9.9 90/06/06 22:59:09 mike Exp $ (BRL)";
d375 3
a377 3
#define MAXARGS 48
	char	*cmd_args[MAXARGS+1];
	int	numargs;
d383 1
a383 1
	if( (numargs = rt_split_cmd( cmd_args, MAXARGS, buf )) <= 0 )  {
d389 1
a389 1
	if( numargs < 2 )  {
d400 2
a401 2
	title_file = rt_strdup(cmd_args[0]);
	title_obj = rt_strdup(cmd_args[1]);
d414 4
a417 3
	for( i=1; i<numargs; i++ )  {
		(void)rt_gettree(rtip, cmd_args[i]);
	}
d457 1
@


9.9
log
@Removed rt_bomb() redefinition
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: /m/cad/remrt/RCS/rtsrv.c,v 9.8 90/02/09 04:54:39 mike Exp $ (BRL)";
d41 1
d515 1
a515 1
	if( rtip->HeadSolid == SOLTAB_NULL )  {
@


9.8
log
@Added declaration of scanbuf
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: rtsrv.c,v 9.7 89/11/23 05:07:49 mike Locked $ (BRL)";
a683 8
void
rt_bomb(str)
char *str;
{
	rt_log("rtsrv:  Fatal Error %s, aborting\n", str);
	abort();	/* should dump */
	exit(12);
}
@


9.7
log
@Initialized some more variables.
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: rtsrv.c,v 9.6 89/11/23 00:06:19 mike Locked $ (BRL)";
d66 1
@


9.6
log
@Improved some rt_log() messages.
Changed from internal parse_cmd() subroutine to rt_split_cmd().
When debugging, print slightly more information now.
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: rtsrv.c,v 9.5 89/11/22 22:51:35 mike Locked $ (BRL)";
d489 1
d496 5
a500 2
	width = 0;
	height = 0;
@


9.5
log
@Prevent chasing a command package with an immediate close.
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: rtsrv.c,v 9.4 89/11/16 23:35:26 mike Locked $ (BRL)";
a117 4
#define MAXARGS 48
char *cmd_args[MAXARGS];
int numargs;

d155 1
d252 1
a252 1
		fprintf(stderr,"MSG_VERSION error\n");
d255 1
d348 1
a348 1
		rt_log("chdir(%s) failure\n", buf);
d373 3
d380 3
a382 1
	if( parse_cmd( buf ) > 0 )  {
d384 1
a384 1
		return;	/* was nop */
d386 1
d405 1
a405 1
		rt_log("rt:  rt_dirbuild(%s) failure\n", title_file);
d419 1
a419 1
		rt_log("rtsrv:  running with %d processors\n", npsw );
d435 1
a435 2
ph_options( pc, buf )
register struct pkg_comm *pc;
a443 2
	if( debug )  fprintf(stderr, "ph_options: %s\n", buf );

d455 1
a455 1
			rt_log("error on '%s'\n", sp );
d460 1
d462 10
d498 2
a499 3
	/* Simulate arrival of options message */
	ph_options( pc, buf );
	buf = (char *)0;
d510 1
a510 1
		rt_log("rt: No solids remain after prep.\n");
d585 1
a585 1
		rt_log("struct_export failure\n");
d683 1
a683 1
	rt_log("rt:  Fatal Error %s, aborting\n", str);
d695 2
d700 1
a700 1
	rt_log("rtsrv: unable to handle %s message: len %d",
a728 42
}

/*
 *			P A R S E _ C M D
 */
int
parse_cmd( line )
char *line;
{
	register char *lp;
	register char *lp1;

	numargs = 0;
	lp = &line[0];
	cmd_args[0] = &line[0];

	if( *lp=='\0' || *lp == '\n' )
		return(1);		/* NOP */

	/* In case first character is not "white space" */
	if( (*lp != ' ') && (*lp != '\t') && (*lp != '\0') )
		numargs++;		/* holds # of args */

	for( lp = &line[0]; *lp != '\0'; lp++ )  {
		if( (*lp == ' ') || (*lp == '\t') || (*lp == '\n') )  {
			*lp = '\0';
			lp1 = lp + 1;
			if( (*lp1 != ' ') && (*lp1 != '\t') &&
			    (*lp1 != '\n') && (*lp1 != '\0') )  {
				if( numargs >= MAXARGS )  {
					rt_log("More than %d args, excess flushed\n", MAXARGS);
					cmd_args[MAXARGS] = (char *)0;
					return(0);
				}
				cmd_args[numargs++] = lp1;
			}
		}
		/* Finally, a non-space char */
	}
	/* Null terminate pointer array */
	cmd_args[numargs] = (char *)0;
	return(0);
@


9.4
log
@ph_options messages are queued by ph_enqueue now,
same as matrix and pixel request packages.
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: rtsrv.c,v 9.3 89/11/15 02:50:10 mike Locked $ (BRL)";
d184 5
@


9.3
log
@Changed from pkg_get() to pkg_process() and pkg_suckin().
Added another RES_INIT
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: rtsrv.c,v 9.2 89/10/23 01:45:25 mike Locked $ (BRL)";
d108 1
a108 1
	{ MSG_OPTIONS,	ph_options,	"Options" },
d301 3
d456 1
a456 1
		rt_log("ph_matrix:  width=%d, height=%d\n", width, height);
@


9.2
log
@Eliminated setting of pkg_nochecking.  This was a very bad idea,
and caused server hangs.
The need for this should have gone away with the
implementation of the new buffering system.
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: rtsrv.c,v 9.1 89/05/19 06:00:30 mike Locked $ (BRL)";
d169 1
d259 7
d272 3
a274 1
			if( pkg_get(pcsrv) < 0 )
d276 6
d284 7
a290 1
		/* More work may have just arrived, check queue */
@


9.1
log
@Release_3.5
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: rtsrv.c,v 8.26 89/04/30 21:43:45 mike Exp $ (BRL)";
a94 1
extern int pkg_nochecking;
a169 1
	pkg_nochecking = 1;
@


8.26
log
@mathtab.h no longer required.
Added use of ../rt/ext.h, eliminated now redundant extern declarations.
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: rtsrv.c,v 8.25 89/04/22 04:55:02 mike Locked $ (BRL)";
@


8.25
log
@rt_log() the STDC way
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: rtsrv.c,v 8.24 89/04/04 04:52:43 mike Exp $ (BRL)";
d46 1
a46 1
#include "../rt/mathtab.h"
a61 4
extern int	hex_out;		/* Binary or Hex .pix output file */
extern double	AmbientIntensity;	/* Ambient light intensity */
extern double	azimuth, elevation;
extern int	lightmodel;		/* Select lighting model */
a63 1
extern int	use_air;		/* Handling of air in librt */
a72 1
extern int	stereo;			/* stereo viewing */
a73 18
extern int	hypersample;		/* number of extra rays to fire */
extern int	jitter;			/* jitter ray starting positions */
extern double	rt_perspective;		/* perspective view -vs- parallel */
extern fastf_t	aspect;			/* aspect ratio Y/X */
extern vect_t	dx_model;		/* view delta-X as model-space vect */
extern vect_t	dy_model;		/* view delta-Y as model-space vect */
extern point_t	eye_model;		/* model-space location of eye */
extern fastf_t	eye_backoff;		/* dist from eye to center */
extern int	width;			/* # of pixels in X */
extern int	height;			/* # of lines in Y */
extern mat_t	Viewrotscale;
extern fastf_t	viewsize;
extern char	*scanbuf;		/* For optional output buffering */
extern int	incr_mode;		/* !0 for incremental resolution */
extern int	incr_level;		/* current incremental level */
extern int	incr_nlevel;		/* number of levels */
extern int	npsw;			/* number of worker PSWs to run */
extern struct resource	resource[MAX_PSW];	/* memory resources */
a76 4
extern int	pix_start;		/* pixel to start at */
extern int	pix_end;		/* pixel to end at */
extern int	nobjs;			/* Number of cmd-line treetops */
extern char	**objtab;		/* array of treetop strings */
a77 5
extern int	matflag;		/* read matrix from stdin */
extern int	desiredframe;		/* frame to start at */
extern int	curframe;		/* current frame number */
extern char	*outputfile;		/* name of base of output file */
extern int	interactive;		/* human is watching results */
@


8.24
log
@Converted to new way of doing stucture offsets
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: rtsrv.c,v 8.23 89/03/15 22:56:37 mike Locked $ (BRL)";
d21 5
d617 29
d672 1
a672 1

@


8.23
log
@Changed to honor interactive flag.
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: rtsrv.c,v 8.22 89/03/15 20:02:08 mike Locked $ (BRL)";
d572 1
a572 1
	cp = struct_export( &len, (stroff_t)&info, desc_line_info );
@


8.22
log
@lint-like cleanups
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: rtsrv.c,v 8.21 89/02/14 05:35:10 mike Locked $ (BRL)";
d239 7
d247 1
a247 1
		rt_pri_set(6);		/* highest "free" priority */
d249 1
a249 1
		rt_pri_set(19);		/* lowest priority */
d251 1
@


8.21
log
@Added handling for CPU limits.
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: rtsrv.c,v 8.20 89/02/14 04:25:45 mike Locked $ (BRL)";
d162 1
d265 1
a265 1
#endif SYSV
d309 1
a309 1
	exit(0);
a352 1
	register int i;
a463 1
	register int i;
d525 1
a525 2
	register struct list	*lp;
	auto int	a,b, fr;
a529 1
	int	pix_offset;
d607 2
a608 1
char *str;
d656 3
d669 3
d681 4
@


8.20
log
@Changed to use rt_avail_cpus()
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: rtsrv.c,v 8.19 89/02/13 06:12:41 mike Locked $ (BRL)";
d234 4
@


8.19
log
@On 4.3BSD machines, increased SO_SNDBUF significantly.
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: rtsrv.c,v 8.18 89/02/13 05:57:12 mike Locked $ (BRL)";
a183 1

d185 2
d188 1
@


8.18
log
@Added special version message to ease the handling of the state
machine in REMRT.
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: rtsrv.c,v 8.17 89/02/11 04:49:08 mike Locked $ (BRL)";
d28 5
d212 9
@


8.17
log
@Changed to use nice librt subroutine for changing priorities.
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: rtsrv.c,v 8.16 89/02/10 23:48:06 mike Locked $ (BRL)";
d152 1
a152 1
char srv_usage[] = "Usage: rtsrv [-d] control-host tcp-port\n";
d172 1
a172 1
	if( argc != 3 )  {
d201 7
d245 7
@


8.16
log
@Now works on SGI.
More conservative FD closing (for SGI 4d bug).
Uses bsdselect() rather than raw select().
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: rtsrv.c,v 8.15 89/02/10 05:47:05 mike Locked $ (BRL)";
d211 4
a214 2
#ifndef SYSV
		(void)setpriority( PRIO_PROCESS, getpid(), 20 );
@


8.15
log
@Use maximum number of processors available.
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: rtsrv.c,v 8.14 89/02/10 05:33:10 mike Locked $ (BRL)";
a20 3
#include <sys/ioctl.h>
#include <sys/time.h>
#include <sys/resource.h>
d22 6
a161 1
	struct timeval	nowait;
d202 13
d220 5
a224 3
		for( n=0; n < 20; n++ )
			if( n != pcsrv->pkc_fd )
				(void)close(n);
d228 1
d231 3
a233 3
		if (n > 0) {
			ioctl(n, TIOCNOTTY, 0);
			close(n);
a235 13

		/* A fresh process */
		if (fork())
			exit(0);

		/* Go into our own process group */
		n = getpid();
		if( setpgrp( n, n ) < 0 )
			perror("setpgrp");

#ifndef SYSV
		(void)setpriority( PRIO_PROCESS, getpid(), 20 );
#endif
a238 2
	nowait.tv_sec = 0;
	nowait.tv_usec = 0;
d244 4
a247 8
		n = select(32, (char *)&ibits, (char *)0, (char *)0,
			WorkHead.li_forw != &WorkHead ? 
				&nowait : (struct timeval *)0 );
		if( n < 0 )  {
			perror("select");
			rt_log("select failure\n");
			exit(9);
		}
@


8.14
log
@Added "CD" message support
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: rtsrv.c,v 8.13 89/02/10 05:13:54 mike Locked $ (BRL)";
d179 1
@


8.13
log
@Converted to match improvements in rt/view.c to handle multi-line
buffers.
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: rtsrv.c,v 8.12 89/02/10 02:47:28 mike Locked $ (BRL)";
d125 1
d127 10
a136 9
	{ MSG_START, ph_start, "Startup" },
	{ MSG_MATRIX, ph_enqueue, "Set Matrix" },
	{ MSG_OPTIONS, ph_options, "Options" },
	{ MSG_LINES, ph_enqueue, "Compute lines" },
	{ MSG_END, ph_end, "End" },
	{ MSG_PRINT, ph_unexp, "Log Message" },
	{ MSG_LOGLVL, ph_loglvl, "Change log level" },
	{ MSG_RESTART, ph_restart, "Restart" },
	{ 0, 0, (char *)0 }
d296 13
@


8.12
log
@Eliminated use of dup2() for SysV
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: rtsrv.c,v 8.11 89/01/27 00:54:04 mike Locked $ (BRL)";
d56 2
d501 3
a526 9
	}
	if( (pix_offset = a % width) != 0 )  {
		/* Temporary hack to repair damage done by rt/view.c */
		char	newbuf[4096*3];
		int	pix_len;		/* len of 1st part */
		pix_len = width-pix_offset;
		bcopy( scanbuf+pix_offset*3, newbuf, pix_len*3 );
		bcopy( scanbuf, newbuf+pix_len*3, pix_offset*3 );
		bcopy( newbuf, scanbuf, width*3 );
@


8.11
log
@Changed to permit assignment of pixel clumps,
rather than being forced to assign by scanline.
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: rtsrv.c,v 8.10 89/01/26 22:52:19 mike Locked $ (BRL)";
d203 3
a205 3
		(void)open("/dev/null", 0);
		(void)dup2(0, 1);
		(void)dup2(0, 2);
@


8.10
log
@Now able to queue arbitrary pkg messages.
For now, matrix and lines.
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: rtsrv.c,v 8.9 89/01/26 09:08:51 mike Locked $ (BRL)";
a227 2
	rt_log("%s\n", RCSid+13 );

d462 5
a466 1
 *  Compute some pixels.
d474 6
a479 1
	auto int	a,b;
d493 2
a494 1
	if( sscanf( buf, "%d %d", &a, &b ) != 2 )  {
d499 4
a502 1
	do_work( a, b );
d504 5
a508 2
	(void)free(buf);
}
d510 6
a515 13
/*
 *			D O _ W O R K
 *
 *  Process scanlines from 'a' to 'b', inclusive, sending each back
 *  as soon as it's done.
 */
do_work(a, b)
{
	struct line_info	info;
	register struct rt_i	*rtip = ap.a_rt_i;
	register int	y;
	int	len;
	char	*cp;
d517 17
a533 25
	if(debug) fprintf(stderr,"do_work %d %d\n", a, b);

	for( y = a; y <= b; y++)  {

		rtip->rti_nrays = 0;
		rt_prep_timer();

		do_run( y*width + 0, y*width + width - 1 );

		info.li_y = y;
		info.li_nrays = rtip->rti_nrays;
		info.li_cpusec = rt_read_timer( (char *)0, 0 );
		info.li_realsec = 0;	/* real time */

		len = 0;
		cp = struct_export( &len, (stroff_t)&info, desc_line_info );
		if( cp == (char *)0 )  {
			rt_log("struct_export failure\n");
			break;
		}

		if(debug)fprintf(stderr,"PIXELS y=%d, rays=%d, cpu=%g\n", info.li_y, info.li_nrays, info.li_cpusec);
		if( pkg_2send( MSG_PIXELS, cp, len,
			scanbuf, width*3, pcsrv ) < 0 )
			fprintf(stderr,"MSG_PIXELS send error\n");
d536 2
@


8.9
log
@Added checking for protocol version
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: rtsrv.c,v 8.8 89/01/26 08:42:52 mike Locked $ (BRL)";
d115 1
d125 1
a125 1
	{ MSG_MATRIX, ph_matrix, "Set Matrix" },
d127 1
a127 1
	{ MSG_LINES, ph_lines, "Compute lines" },
d235 2
d250 17
a266 3
		/* More work may have just arrived, recheck queue */
		if( WorkHead.li_forw != &WorkHead )  {
			do_work();
d273 8
d282 15
d464 1
a464 1
 *  Queue a request for some pixels.
d472 1
a472 1
	auto int a,b;
d491 1
a491 4
	GET_LIST( lp );
	lp->li_start = a;
	lp->li_stop = b;
	APPEND_LIST( lp, WorkHead.li_back );
d502 1
a502 1
do_work()
a503 1
	register struct list	*lp;
d510 1
a510 2
	if( (lp = WorkHead.li_forw) == &WorkHead )
		return;
d512 1
a512 2
	DEQUEUE_LIST( lp );
	if(debug) fprintf(stderr,"do_work %d %d\n", lp->li_start, lp->li_stop);
a513 2
	for( y = lp->li_start; y <= lp->li_stop; y++)  {

a536 2

	FREE_LIST( lp );
@


8.8
log
@Corrected empty-list test
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: rtsrv.c,v 8.7 89/01/25 05:42:39 mike Exp $ (BRL)";
a36 1
#include "./rtsrv.h"
d326 2
a327 1
	if( pkg_send( MSG_START, "", 0, pcsrv ) < 0 )
d490 1
@


8.7
log
@MATRIX message has normal options as well.
The OPTIONS message can be used to run any RT command, optionally.
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: rtsrv.c,v 8.6 89/01/25 04:09:01 mike Locked $ (BRL)";
d237 1
a237 1
			WorkHead.li_forw != LIST_NULL ? 
d249 1
a249 1
		if( WorkHead.li_forw != LIST_NULL )  {
@


8.6
log
@Changed protocol to rcv matrix as RT style command script.
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: rtsrv.c,v 8.5 89/01/25 03:12:23 mike Locked $ (BRL)";
d126 1
a126 1
	{ MSG_OPTIONS, ph_options, "Set options" },
d196 4
a272 39
ph_options(pc, buf)
register struct pkg_comm *pc;
char *buf;
{
	register char *cp;
	register int i;
	int	argc;
	char	*argv[64];

	if( debug )  fprintf(stderr,"ph_options: %s\n", buf);
	/* Start options in a known state */
	hypersample = 0;
	jitter = 0;
	rt_perspective = 0;
	eye_backoff = 1.414;
	aspect = 1;
	stereo = 0;
	width = 0;
	height = 0;

	argv[0] = "program_name";
	if( (argc = rt_split_cmd( &argv[1], 64-1, buf )+1) <= 1 )  {
		rt_log("rt_split_cmd error\n");
		exit(1);
	}

	if( get_args( argc, argv ) <= 0 )  {
		rt_log("get_args error\n");
		exit(2);
	}

	if( width <= 0 || height <= 0 )  {
		rt_log("ph_options:  width=%d, height=%d\n", width, height);
		exit(3);
	}
	(void)free(buf);
}

void
d332 1
a332 1
ph_matrix(pc, buf)
d334 1
a334 1
char *buf;
d336 1
a336 3
	register int i;
	register char *cp = buf;
	register struct rt_i *rtip = ap.a_rt_i;
d340 1
d342 1
a342 1
	if( debug )  fprintf(stderr, "ph_matrix: %s\n", buf );
d344 1
a344 14
#if 0
	/* Visible part is from -1 to +1 in view space */
	viewsize = atof(cp);
	while( *cp && *cp++ != ' ') ;
	eye_model[X] = atof(cp);
	while( *cp && *cp++ != ' ') ;
	eye_model[Y] = atof(cp);
	while( *cp && *cp++ != ' ') ;
	eye_model[Z] = atof(cp);
	for( i=0; i < 16; i++ )  {
		while( *cp && *cp++ != ' ') ;
		Viewrotscale[i] = atof(cp);
	}
#else
a349 1
		extern struct command_tab rt_cmdtab[];	/* from do.c */
d354 1
a354 1
		if( rt_do_cmd( rtip, sp, rt_cmdtab ) < 0 )  {
a359 1
#endif
d361 31
a418 1
	(void)free(buf);
@


8.5
log
@Added print of RCSid.
@
text
@d18 1
a18 1
static char RCSid[] = "@@(#)$Header: rtsrv.c,v 8.4 89/01/20 06:13:23 mike Locked $ (BRL)";
d374 3
d379 2
d393 18
@


8.4
log
@Added select() poll, queue of work assignments.
First step in conquering new assignment latency.
@
text
@d18 1
a18 3
#ifndef lint
static char RCSid[] = "@@(#)$Header: rtsrv.c,v 8.3 89/01/20 03:18:08 mike Locked $ (BRL)";
#endif
a172 3
#ifdef CRAY1
	npsw = 1;			/* >1 on GOS crashes system */
#endif
d224 2
a225 4
/**
	while( pkg_block(pcsrv) >= 0 )
		;
**/
@


8.3
log
@Changed to take advantage of rt/opt.c, and
rt/do.c do_prep() functions, rather than duplicating code here.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: rtsrv.c,v 8.2 89/01/20 01:24:17 mike Locked $ (BRL)";
d38 1
d43 3
d156 3
a158 1
	register int n;
d229 1
d232 25
d429 1
a429 2
 *  Process scanlines from 'a' to 'b', inclusive, sending each back
 *  as soon as it's done.
d436 1
a436 1
	register int y;
a437 2
	int	i;
	register struct rt_i *rtip = ap.a_rt_i;
d456 4
a459 4
	for( y = a; y <= b; y++)  {
		struct line_info	info;
		int	len;
		char	*cp;
d461 26
d509 2
a510 1
	(void)free(buf);
@


8.2
log
@Switched to using struct_export().
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: rtsrv.c,v 8.1 88/10/05 00:34:01 mike Locked $ (BRL)";
d48 4
a51 4
int		hex_out = 0;		/* Binary or Hex .pix output file */
double		AmbientIntensity = 0.4;	/* Ambient light intensity */
double		azimuth, elevation;
int		lightmodel;		/* Select lighting model */
d54 1
d62 1
a62 1
int		stereo = 0;	/* stereo viewing */
d64 18
a81 20
int		hypersample=0;	/* number of extra rays to fire */
int		jitter=0;		/* jitter ray starting positions */
int		rt_perspective=0;	/* perspective view -vs- parallel */
fastf_t		persp_angle = 90;	/* prespective angle (degrees X) */
fastf_t		aspect = 1;		/* aspect ratio Y/X */
vect_t		dx_model;	/* view delta-X as model-space vector */
vect_t		dy_model;	/* view delta-Y as model-space vector */
point_t		eye_model;	/* model-space location of eye */
fastf_t         eye_backoff = 1.414;	/* dist from eye to center */
int		width;			/* # of pixels in X */
int		height;			/* # of lines in Y */
mat_t		Viewrotscale;
fastf_t		viewsize=0;
fastf_t		zoomout=1;	/* >0 zoom out, 0..1 zoom in */
char		*scanbuf;	/* For optional output buffering */
int		incr_mode;		/* !0 for incremental resolution */
int		incr_level;		/* current incremental level */
int		incr_nlevel;		/* number of levels */
int		npsw = MAX_PSW;		/* number of worker PSWs to run */
struct resource	resource[MAX_PSW];	/* memory resources */
d85 4
a88 4
int		pix_start = -1;		/* pixel to start at */
int		pix_end;		/* pixel to end at */
int		nobjs;			/* Number of cmd-line treetops */
char		**objtab;		/* array of treetop strings */
d90 5
a94 5
int		matflag = 0;		/* read matrix from stdin */
int		desiredframe = 0;	/* frame to start at */
int		curframe = 0;		/* current frame number */
char		*outputfile = (char *)0;/* name of base of output file */
int		interactive = 0;	/* human is watching results */
d250 2
a257 1
	persp_angle = 90;
d264 5
a268 6
	cp = buf;
	while( *cp )  {
		if( *cp != '-' )  {
			cp++;
			continue;
		}
d270 4
a273 31
		switch( cp[1] )  {
		case 'I':
			interactive = 1;
			break;
		case 'S':
			stereo = 1;
			break;
		case 'J':
			jitter = atoi( &cp[2] );
			break;
		case 'H':
			hypersample = atoi( &cp[2] );
			if( hypersample > 0 )
				jitter = 1;
			break;
		case 'A':
			AmbientIntensity = atof( &cp[2] );
			break;
		case 'x':
			sscanf( &cp[2], "%x", &rt_g.debug );
			rt_log("rt_g.debug=x%x\n", rt_g.debug);
			break;
		case 's':
			/* Square size -- fall through */
		case 'f':
			/* "Fast" -- just a few pixels.  Or, arg's worth */
			i = atoi( &cp[2] );
			if( i < 2 || i > 8*1024 )
				rt_log("square size %d out of range\n", i);
			else
				width = height = i;
d275 3
a277 50
			break;
		case 'n':
			i = atoi( &cp[2] );
			if( i < 2 || i > MAX_WIDTH )
				rt_log("height=%d out of range\n", i);
			else
				height = i;
			break;
		case 'w':
			i = atoi( &cp[2] );
			if( i < 2 || i > MAX_WIDTH )
				rt_log("width=%d out of range\n", i);
			else
				width = i;
			break;

		case 'l':
			/* Select lighting model # */
			lightmodel = atoi( &cp[2] );
			break;
		case 'p':
			rt_perspective = 1;
			persp_angle = atof( &cp[2] );
			if( persp_angle < 1 )  persp_angle = 90;
			if( persp_angle > 179 )  persp_angle = 90;
			break;
		case 'E':
			eye_backoff = atof( &cp[2] );
			break;
		case 'P':
			/* Number of parallel workers */
			npsw = atoi( &cp[2] );
			if( npsw < 1 || npsw > MAX_PSW )  {
				rt_log("npsw out of range 1..%d\n", MAX_PSW);
				npsw = 1;
			}
			break;
		case 'B':
			/*  Remove all intentional random effects
			 *  (dither, etc) for benchmarking.
			 */
			mathtab_constant();
			break;
		default:
			rt_log("rtsrv: Option '%c' unknown\n", cp[1]);
			break;
		}
		while( *cp && *cp++ != ' ' )
			;
		while( *cp == ' ' )  cp++;
d370 1
a370 3
	/* This code from do.c/do_frame() */
	if( rtip->needprep )  {
		register struct region *regp;
a371 35
		rt_prep_timer();
		rt_prep(rtip);

		/* Initialize the material library for all regions */
		for( regp=rtip->HeadRegion; regp != REGION_NULL; regp=regp->reg_forw )  {
			if( mlib_setup( regp ) < 0 )  {
				rt_log("mlib_setup failure on %s\n", regp->reg_name);
			} else {
				if(rdebug&RDEBUG_MATERIAL)
					((struct mfuncs *)(regp->reg_mfuncs))->
						mf_print( regp, regp->reg_udata );
				/* Perhaps this should be a function? */
			}
		}
		(void)rt_read_timer( outbuf, sizeof(outbuf) );
		rt_log( "PREP: %s\n", outbuf );
	}

	if( rt_g.rtg_parallel && resource[0].re_seg == SEG_NULL )  {
		register int x;
		/* 
		 *  Get dynamic memory to keep from having to call
		 *  malloc(), because the portability of doing sbrk()
		 *  sys-calls when running in parallel mode is unknown.
		 */
		for( x=0; x<npsw; x++ )  {
			rt_get_seg(&resource[x]);
			rt_get_pt(rtip, &resource[x]);
			rt_get_bitv(rtip, &resource[x]);
		}
		rt_log("Additional dynamic memory used=%d. bytes\n",
			sbrk(0)-beginptr );
		beginptr = sbrk(0);
	}

d407 2
d432 3
d438 5
a442 3
		info.li_nrays = 0;
		info.li_cpusec = 0.0;
		cp = struct_export( desc_line_info, (stroff_t)&info, &len );
d448 1
@


8.1
log
@Release_3.0
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: rtsrv.c,v 1.25 88/09/21 04:47:06 mike Exp $ (BRL)";
d39 2
d538 3
a540 1
		char rbuf[4];
d544 10
a553 3
		rbuf[0] = y&0xFF;
		rbuf[1] = (y>>8);
		if( pkg_2send( MSG_PIXELS, rbuf, 2,
d556 1
@


1.25
log
@Make sure VMIN from vmath.h beats one from ioctl.h
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: rtsrv.c,v 1.24 88/09/17 07:06:02 mike Locked $ (BRL)";
@


1.24
log
@Minor modernizations to track RT.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: rtsrv.c,v 1.23 88/03/02 00:17:59 mike Locked $ (BRL)";
d27 1
@


1.23
log
@Fixed parallel code, fixed bug in rt_log() trying to log to broken
connections.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: rtsrv.c,v 1.22 88/03/01 21:03:57 mike Locked $ (BRL)";
d61 1
d105 1
a105 1
#define MAX_WIDTH	(8*1024)
d111 8
a118 8
int ph_unexp();	/* foobar message handler */
int ph_start();
int ph_matrix();
int ph_options();
int ph_lines();
int ph_end();
int ph_restart();
int ph_loglvl();
d136 2
a137 1
char *control_host;	/* name of host running controller */
d141 1
a141 1
char srv_usage[] = "Usage: rtsrv [-d] control-host\n";
d160 1
a160 1
	if( argc != 2 )  {
d169 1
a169 1
#endif cray
d183 2
a184 1
	pcsrv = pkg_open( control_host, "rtsrv", "tcp", "", "",
d186 3
a188 4
	if( pcsrv == PKC_ERROR &&
	    (pcsrv = pkg_open( control_host, "4446", "tcp", "", "",
	    pkgswitch, rt_log )) == PKC_ERROR )  {
		fprintf(stderr, "unable to contact %s\n", control_host);
d226 1
d236 1
a236 1
	execlp( "rtsrv", "rtsrv", control_host, (char *)0);
d241 1
d252 1
d275 3
d280 2
d354 1
d413 1
d509 1
d549 2
d603 1
d619 1
d629 1
@


1.22
log
@Updated to compile with current RT.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: rtsrv.c,v 1.21 87/11/02 15:45:47 mike Locked $ (BRL)";
d165 1
a165 1
#ifdef cray
d169 5
d385 1
d567 1
a567 1
	if( pcsrv == PKC_NULL )  {
@


1.21
log
@Fixed option handling
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: rtsrv.c,v 1.20 87/08/10 07:11:41 mike Locked $ (BRL)";
d61 3
a63 1
int		perspective=0;	/* perspective view -vs- parallel view */
d67 1
d74 3
a76 1
int		parallel=0;		/* Trying to use multi CPUs */
d91 1
d243 4
a246 1
	perspective = 0;
d259 3
d306 4
a309 4
			perspective = 1;
			if( cp[2] != '\0' )
				zoomout = atof( &cp[2] );
			if( zoomout <= 0 )  zoomout = 1;
d311 3
d329 1
a329 1
			rt_log("Option '%c' unknown\n", cp[1]);
d380 5
a384 4
	if( npsw > 1 )
		parallel = 1;
	if( parallel )
		rt_log("running with %d processors\n", npsw );
d446 1
a446 1
	if( parallel && resource[0].re_seg == SEG_NULL )  {
@


1.20
log
@Added Benchmark flag
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: rtsrv.c,v 1.19 87/08/10 02:20:00 mike Locked $ (BRL)";
d244 4
a247 1
		if( *cp != '-' )  continue;
@


1.19
log
@Working version.  Modified to send options & matrix at the start of
each new frame.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: rtsrv.c,v 1.18 87/08/10 00:18:16 mike Locked $ (BRL)";
d243 3
a245 1
	while( *cp == '-' )  {
d250 1
a250 1
		case 'h':
d303 6
@


1.18
log
@This version works with CAD Distribution 2.0
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: rtsrv.c,v 1.17 87/04/10 08:12:13 mike Locked $ (BRL)";
d365 2
a366 1
	pkg_send( MSG_START, "", 0, pcsrv );
d391 6
a440 5

	/* initialize application -- it will allocate 1 line & set buf_mode=1 */
	/* width XXXX */
	(void)view_init( &ap, title_file, title_obj, 0 );

d495 3
a497 2
		pkg_2send( MSG_PIXELS, rbuf, 2,
			scanbuf, width*3, pcsrv );
d538 1
@


1.17
log
@Upgraded for current version of rt
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: rtsrv.c,v 1.16 86/10/29 02:23:22 mike Locked $ (BRL)";
d33 2
d65 2
a66 1
int		npts;		/* # of points to shoot: x,y */
d71 1
d77 2
d96 4
d131 1
a131 1
int debug = 0;
d150 1
a150 1
		debug = 1;
d219 1
d232 1
d234 1
a234 1
	if( debug )  rt_log("ph_options: %s\n", buf);
d238 3
d245 3
d258 2
d262 6
a267 4
			npts = atoi( &cp[2] );
			if( npts < 2 || npts > 8*1024 )  {
				npts = 50;
			}
d269 15
d297 4
a316 1
	char *title_file, *title_obj;	/* name of file and first object */
d320 1
a320 1
	if( debug )  rt_log( "ph_start: %s\n", buf );
d336 2
a337 2
	title_file = cmd_args[0];
	title_obj = cmd_args[1];
a348 5
	/* initialize application -- bogus scanbuf size */
	(void)view_init( &ap, title_file, title_obj, 32, 0 );
	if( scanbuf )  rt_free(scanbuf);
	scanbuf = rt_malloc( 32*1024*3, "scanbuf" );	/* XXX */

d354 5
a358 3
#ifdef PARALLEL
	rt_log("PARALLEL: npsw=%d\n", npsw );
#endif
d376 1
a376 1
	if( debug )  rt_log( "ph_matrix: %s\n", buf );
d390 1
d403 2
a404 1
					regp->reg_mfuncs->mf_print( regp );
d412 17
d434 5
d469 1
a469 1
	if( debug )  rt_log( "ph_lines: %s\n", buf );
d489 1
a489 1
		do_run( y*npts + 0, y*npts + npts - 1 );
d494 1
a494 1
			scanbuf, npts*3, pcsrv );
d504 1
d570 1
a570 1
	if( debug )  rt_log( "ph_end\n");
d579 1
a579 1
	printf("msg: %s\n", buf);
@


1.16
log
@Improved debugging.
@
text
@d2 1
a2 1
 *			R T S R V
d4 1
a4 1
 *  Ray Tracing service program, using RT library.
d19 1
a19 1
static char RCSid[] = "@@(#)$Header: rtsrv.c,v 1.15 86/10/29 02:06:05 mike Locked $ (BRL)";
d31 1
d33 1
d37 1
d41 8
a48 6
double AmbientIntensity = 0.4;	/* Ambient light intensity */
double azimuth, elevation;
int lightmodel;		/* Select lighting model */
mat_t view2model;
mat_t model2view;
int hex_out;
d53 1
a54 1
int	nworkers;
d56 15
a70 14
int	stereo = 0;	/* stereo viewing */
vect_t left_eye_delta;
int	hypersample=0;	/* number of extra rays to fire */
int	perspective=0;	/* perspective view -vs- parallel view */
vect_t	dx_model;	/* view delta-X as model-space vector */
vect_t	dy_model;	/* view delta-Y as model-space vector */
point_t	eye_model;	/* model-space location of eye */
point_t	viewbase_model;	/* model-space location of viewplane corner */
int npts;	/* # of points to shoot: x,y */
mat_t Viewrotscale;
mat_t toEye;
fastf_t viewsize;
fastf_t	zoomout=1;	/* >0 zoom out, 0..1 zoom in */
/***** end variables shared with worker() */
d72 9
a80 1
char scanbuf[8*1024*3];		/* generous scan line */
d83 2
a84 1
int npsw = MAX_PSW;
d86 1
a86 1
static char idbuf[132];		/* First ID record info */
d147 11
d160 2
a161 1
	pcsrv = pkg_open( control_host, "rtsrv", pkgswitch, rt_log );
d163 2
a164 1
	    (pcsrv = pkg_open( control_host, "4446", pkgswitch, rt_log )) == PKC_ERROR )  {
d176 1
d182 1
d193 1
d195 1
d200 1
d238 1
a238 1
			rt_log("debug=x%x\n", rt_g.debug);
a278 1
	register struct region *regp;
a298 8
	RES_INIT( &rt_g.res_pt );
	RES_INIT( &rt_g.res_seg );
	RES_INIT( &rt_g.res_malloc );
	RES_INIT( &rt_g.res_bitv );
	RES_INIT( &rt_g.res_printf );
	RES_INIT( &rt_g.res_worker );
	RES_INIT( &rt_g.res_stats );

d309 4
a312 3
	(void)rt_read_timer( outbuf, sizeof(outbuf) );
	rt_log("DB TOC: %s\n", outbuf);
	rt_prep_timer();
a317 3
	(void)rt_read_timer( outbuf, sizeof(outbuf) );
	rt_log("DB WALK: %s\n", outbuf);
	rt_prep_timer();
a318 21
	/* Allow library to prepare itself */
	rt_prep(rtip);

	/* Initialize the material library for all regions */
	for( regp=rtip->HeadRegion; regp != REGION_NULL; regp=regp->reg_forw )  {
		if( mlib_setup( regp ) == 0 )  {
			rt_log("mlib_setup failure\n");
		}
	}

	/* initialize application (claim output to file) */
	view_init( &ap, title_file, title_obj, npts, 1 );

	(void)rt_read_timer( outbuf, sizeof(outbuf) );
	rt_log( "PREP: %s\n", outbuf );

	if( rt_i.HeadSolid == SOLTAB_NULL )  {
		rt_log("rt: No solids remain after prep.\n");
		exit(3);
	}

a319 11
	/* Get enough dynamic memory to keep from making malloc sbrk() */
	for( i=0; i<npsw; i++ )  {
		rt_get_pt();
		rt_get_seg();
		rt_get_bitv();
	}
#ifdef HEP
	/* This isn't useful with the Caltech malloc() in most systems */
	rt_free( rt_malloc( (20+npsw)*8192, "worker prefetch"), "worker");
#endif

a320 4
#ifdef HEP
	for( i=0; i<npsw; i++ )  {
		Dcreate( worker );
	}
d322 1
a322 2
	rt_log("initial memory use=%d.\n",sbrk(0) );
#endif
d337 1
d353 25
a377 1
rt_log("npts=%d\n", npts);
d381 1
a381 1
	view_2init( &ap, -1 );
d383 8
d408 1
d464 1
a464 1
	RES_ACQUIRE( &rt_g.res_malloc );
d477 1
a477 1
	RES_RELEASE( &rt_g.res_malloc );
a557 49

fb_open( name, w, h )
char *name;
{
	return(0);
}

fb_close()
{
	return(0);
}

#ifdef cray
#ifndef PARALLEL
LOCKASGN(p)
{
}
LOCKON(p)
{
}
LOCKOFF(p)
{
}
#endif
#endif

#ifdef sgi
/* Horrible bug in 3.3.1 and 3.4 -- hypot ruins stack! */
double
hypot(a,b)
double a,b;
{
	extern double sqrt();
	return(sqrt(a*a+b*b));
}
#endif

#ifdef alliant
RES_ACQUIRE(p)
register int *p;
{
#ifdef PARALLEL
	asm("loop:");
	while( *p )  ;
	asm("	tas	a5@@");
	asm("	bne	loop");
#endif
}
#endif alliant
@


1.15
log
@usage name conflict with view.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: rtsrv.c,v 1.14 86/10/29 02:03:13 mike Locked $ (BRL)";
d106 2
a117 1
	int debug = 0;
d189 1
d248 1
d353 1
d489 1
@


1.14
log
@Cleaned up option parsing, parallel init.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: rtsrv.c,v 1.13 86/10/29 01:31:12 mike Locked $ (BRL)";
d106 1
a106 1
char usage[] = "Usage: rtsrv [-d] control-host\n";
d119 1
a119 1
		fprintf(stderr, usage);
d127 1
a127 1
		fprintf(stderr, usage);
@


1.13
log
@PSW stuff moved to worker and machine.h, not needed here.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: rtsrv.c,v 1.12 86/10/28 23:42:49 mike Locked $ (BRL)";
d106 1
d118 2
a119 2
	if( argc < 2 || argc > 3 )  {
		fprintf(stderr, "Usage: rtsrv [-d] control-host\n");
d126 4
d268 3
a270 1
	RES_INIT( &rt_g.res_printf );	/* HACK: used by worker */
d327 2
a328 1
	rt_log("PARALLEL: %d workers\n", npsw );
a329 1
#ifdef HEP
d331 1
a332 5
#ifdef cray
		taskcontrol[i].tsk_len = 3;
		taskcontrol[i].tsk_value = i;
#endif
	}
d363 1
@


1.12
log
@Modified for use with same worker.c as rt.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: rtsrv.c,v 1.11 86/10/28 15:28:17 mike Locked $ (BRL)";
a63 15

#ifdef PARALLEL
#ifdef cray
#define MAX_PSW		4
struct taskcontrol {
	int	tsk_len;
	int	tsk_id;
	int	tsk_value;
} taskcontrol[MAX_PSW];
#endif

#ifdef alliant
#define MAX_PSW	8
#endif
#endif
a67 3
#ifndef MAX_PSW
#define MAX_PSW 1
#endif
@


1.11
log
@Working parallel version.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: rtsrv.c,v 1.10 86/10/27 22:22:21 mike Locked $ (BRL)";
a59 2
int cur_pixel;		/* current pixel number, 0..last_pixel */
int last_pixel;		/* last pixel number */
a391 5
 *
 *  Don't use registers in this function.  At least on the Alliant,
 *  register context is NOT preserved when exiting the parallel mode,
 *  because the serial portion executes on some arbitrary processor,
 *  not necessarily the one that serial execution started on.
d397 1
a397 1
	auto int x,y;
d419 1
a419 34
		cur_pixel = y*npts + 0;
		last_pixel = cur_pixel + npts - 1;
#ifdef PARALLEL
		nworkers = 0;
#ifdef cray
		/* Create any extra worker tasks */

		for( x=0; x<npsw; x++ ) {
			TSKSTART( &taskcontrol[x], worker );
		}
		/* Wait for them to finish */
		for( x=0; x<npsw; x++ )  {
			TSKWAIT( &taskcontrol[x] );
		}
#endif
#ifdef alliant
		{
			asm("	movl		_npsw,d0");
			asm("	subql		#1,d0");
			asm("	cstart		d0");
			asm("super_loop:");
			worker();
			asm("	crepeat		super_loop");
		}
#endif
		x = 0;
		while( nworkers > 0 )  x++;
		if( x > 0 )  rt_log("y=%d: termination took %d extra loops\n", y, x);
#else
		/*
		 * Simple serial case -- one CPU does all the work.
		 */
		worker();
#endif
@


1.10
log
@Added debugging (-d) flag.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: rtsrv.c,v 1.9 86/10/27 04:07:14 mike Locked $ (BRL)";
d49 1
d389 11
d401 1
a401 1
register struct pkg_comm *pc;
d404 2
a405 2
	register int x,y;
	int a,b;
d429 1
d432 1
a446 1
			asm("	cawait		cs1,#0");
a447 1
			asm("	cadvance	cs1");
d451 3
d455 3
a457 1
		/* Simple serial case */
@


1.9
log
@Fixes for running on Alliants.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: rtsrv.c,v 1.8 86/10/26 23:43:30 mike Locked $ (BRL)";
d134 1
d136 2
a137 2
	if( argc != 2 )  {
		fprintf(stderr, "Usage: rtsrv control-host\n");
d140 4
d153 13
a165 11
	for( n=0; n < 20; n++ )
		if( n != pcsrv->pkc_fd )
			(void)close(n);
	(void)open("/dev/null", 0);
	(void)dup2(0, 1);
	(void)dup2(0, 2);
	n = open("/dev/tty", 2);
	if (n > 0) {
		ioctl(n, TIOCNOTTY, 0);
		close(n);
	}
d167 3
a169 3
	/* A fresh process */
	if (fork())
		exit(0);
d171 4
a174 4
	/* Go into our own process group */
	n = getpid();
	if( setpgrp( n, n ) < 0 )
		perror("setpgrp");
d176 2
a177 1
	(void)setpriority( PRIO_PROCESS, getpid(), 20 );
d415 1
a415 1
		last_pixel = cur_pixel + npts;
d429 3
a431 1
			asm("	cstart	_npsw");
d433 4
a436 4
				asm("	cawait	cs1,#0");
				asm("	cadvance	cs1");
				worker();
			asm("	crepeat	super_loop");
d619 1
a619 1
#endif
@


1.8
log
@fixes
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: rtsrv.c,v 1.7 86/10/26 22:49:50 mike Locked $ (BRL)";
d97 1
d140 1
d270 5
a274 4
	RES_RELEASE( &res_pt );
	RES_RELEASE( &res_seg );
	RES_RELEASE( &res_malloc );
	RES_RELEASE( &res_bitv );
d321 1
a321 1
	for( x=0; x<npsw; x++ )  {
d326 2
d329 1
d331 2
a332 2
	fprintf(stderr,"PARALLEL: %d workers\n", npsw );
	for( x=0; x<npsw; x++ )  {
d337 2
a338 2
		taskcontrol[x].tsk_len = 3;
		taskcontrol[x].tsk_value = x;
d341 1
a341 1
	fprintf(stderr,"initial memory use=%d.\n",sbrk(0) );
d355 2
a356 1
	static vect_t temp;
d359 10
a368 24
	if( sscanf( buf,
		"%e %e %e %e %e %e %e %e %e %e %e %e %e %e %e %e %e %e %e %e",
		&viewsize,
		&eye_model[X],
		&eye_model[Y],
		&eye_model[Z],
		&Viewrotscale[0], 
		&Viewrotscale[1], 
		&Viewrotscale[2], 
		&Viewrotscale[3], 
		&Viewrotscale[4], 
		&Viewrotscale[5], 
		&Viewrotscale[6], 
		&Viewrotscale[7], 
		&Viewrotscale[8], 
		&Viewrotscale[9], 
		&Viewrotscale[10], 
		&Viewrotscale[11], 
		&Viewrotscale[12], 
		&Viewrotscale[13], 
		&Viewrotscale[14], 
		&Viewrotscale[15] ) != 20 )  {
		rt_log("matrix: scanf failure\n");
		exit(2);
d468 1
d472 1
a472 1
		return;
d475 1
a475 1
		return;
d480 2
a597 1
#ifdef PARALLEL
a598 1

d602 1
d607 1
a608 1
#endif
@


1.7
log
@pkg_open return fixed
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: rtsrv.c,v 1.6 86/10/26 20:08:52 mike Locked $ (BRL)";
d212 1
a212 1
			if( npts < 2 || npts > 1024 )  {
@


1.6
log
@Initial parallel version.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: rtsrv.c,v 1.5 86/10/26 19:51:21 mike Locked $ (BRL)";
d84 3
d140 3
a142 2
	if( (pcsrv = pkg_open( control_host, "rtsrv", pkgswitch, rt_log )) == 0 &&
	    (pcsrv = pkg_open( control_host, "4446", pkgswitch, rt_log )) == 0 )  {
d613 2
@


1.5
log
@Working version.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: rtsrv.c,v 1.4 86/10/26 18:56:32 mike Locked $ (BRL)";
d85 1
a85 1
int npsw;
d312 22
d411 25
a435 1
		worker();	/* fills scanbuf */
d571 37
@


1.4
log
@Converted to new way of doing things,
with separated worker().
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: rtsrv.c,v 1.3 86/07/30 03:49:50 mike Exp $ (BRL)";
d385 1
a385 1
		char buf[4];
d391 3
a393 3
		buf[0] = y&0xFF;
		buf[1] = (y>>8);
		pkg_2send( MSG_PIXELS, buf, 2,
d426 2
a427 2
	while( *cp++ )  ;		/* leave at null */
	if( cp[-1] != '\n' )
@


1.3
log
@Hypersampling
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: rtsrv.c,v 1.2 86/07/30 01:37:37 mike Exp $ (BRL)";
d26 5
a30 3
#include "../h/machine.h"
#include "../h/vmath.h"
#include "../h/raytrace.h"
a31 2
#include "pkg.h"
#include "rtsrv.h"
d33 2
d43 1
d46 19
a64 11
/***** variables shared with worker() */
static int	hypersample=0;	/* number of extra rays to fire */
static int	perspective=0;	/* perspective view -vs- parallel view */
static vect_t	dx_model;	/* view delta-X as model-space vector */
static vect_t	dy_model;	/* view delta-Y as model-space vector */
static point_t	eye_model;	/* model-space location of eye */
static point_t	viewbase_model;	/* model-space location of viewplane corner */
static int npts;	/* # of points to shoot: x,y */
int npsw = 1;		/* HEP: number of worker PSWs to run */
void worker();
int work_word;		/* semaphored (x<<16)|y */
d66 14
a79 3
#define LINENO_WIDTH	2
/* We don't know exactly how much we will need */
char scanbuf[(8*1024*3) + LINENO_WIDTH + 8];/* scan line, line # as header */
d82 2
d85 1
a85 2
static struct application ap;
static float	zoomout=1;	/* >0 zoom out, 0..1 zoom in */
a87 3
static mat_t Viewrotscale;
static mat_t toEye;
static fastf_t viewsize;
d102 1
a102 1
struct pkg_switch pkg_switch[] = {
d110 2
a111 1
	{ MSG_RESTART, ph_restart, "Restart" }
a112 1
int pkg_swlen = sizeof(pkg_switch)/sizeof(struct pkg_switch);
d137 2
a138 2
	if( (pcsrv = pkg_open( control_host, "rtsrv" )) == 0 &&
	    (pcsrv = pkg_open( control_host, "4446" )) == 0 )  {
d352 1
a352 8
	/* model2view takes us to eye_model location & orientation */
	mat_idn( toEye );
	toEye[MDX] = -eye_model[X];
	toEye[MDY] = -eye_model[Y];
	toEye[MDZ] = -eye_model[Z];
	Viewrotscale[15] = 0.5*viewsize;	/* Viewscale */
	mat_mul( model2view, Viewrotscale, toEye );
	mat_inv( view2model, model2view );
a353 26
	/* Chop -1.0..+1.0 range into npts parts */
	VSET( temp, 2.0/npts, 0, 0 );
	MAT4X3VEC( dx_model, view2model, temp );
	VSET( temp, 0, 2.0/npts, 0 );
	MAT4X3VEC( dy_model, view2model, temp );

	/* "Upper left" corner of viewing plane */
	if( perspective )  {
		VSET( temp, -1, -1, -zoomout );	/* viewing plane */
		/*
		 * Divergance is (0.5 * viewsize / npts) mm at
		 * a ray distance of (viewsize * zoomout) mm.
		 */
		ap.a_diverge = (0.5 / npts) / zoomout;
		ap.a_rbeam = 0;
	}  else  {
		VSET( temp, 0, 0, -1 );
		MAT4X3VEC( ap.a_ray.r_dir, view2model, temp );
		VUNITIZE( ap.a_ray.r_dir );

		VSET( temp, -1, -1, 0 );	/* eye plane */
		ap.a_rbeam = 0.5 * viewsize / npts;
		ap.a_diverge = 0;
	}
	MAT4X3PNT( viewbase_model, view2model, temp );

d385 1
a385 10
		for( x = 0; x < npts; x++)  {
			work_word = (x<<16) | y;
			worker( &ap );
		}
		scanbuf[0] = y&0xFF;
		scanbuf[1] = (y>>8);
		pkg_send( MSG_PIXELS, scanbuf, LINENO_WIDTH+npts*3, pcsrv );
	}
	(void)free(buf);
}
d387 3
a389 15
/*
 *  			W O R K E R
 *  
 *  Compute one pixel, and store it.
 */
void
worker( ap )
register struct application *ap;
{
	LOCAL struct application a;
	LOCAL vect_t tempdir;
	LOCAL vect_t colorsum;
	register char *pixelp;
	register int r,g,b;
	register int com;
d391 4
a394 61
	a.a_onehit = 1;
	{
		com = work_word;
		a.a_x = (com>>16)&0xFFFF;
		a.a_y = (com&0xFFFF);
		a.a_hit = ap->a_hit;
		a.a_miss = ap->a_miss;
		a.a_rt_i = ap->a_rt_i;
		a.a_rbeam = ap->a_rbeam;
		a.a_diverge = ap->a_diverge;
		a.a_rbeam = ap->a_rbeam;
		a.a_diverge = ap->a_diverge;
		VSETALL( colorsum, 0 );
		for( com=0; com<=hypersample; com++ )  {
			if( hypersample )  {
				FAST fastf_t dx, dy;
				dx = a.a_x + rand_half();
				dy = (npts-a.a_y-1) + rand_half();
				VJOIN2( a.a_ray.r_pt, viewbase_model,
					dx, dx_model, dy, dy_model );
			}  else  {
				register int yy = npts-a.a_y-1;
				VJOIN2( a.a_ray.r_pt, viewbase_model,
					a.a_x, dx_model,
					yy, dy_model );
			}
			if( perspective )  {
				VSUB2( a.a_ray.r_dir,
					a.a_ray.r_pt, eye_model );
				VUNITIZE( a.a_ray.r_dir );
				VMOVE( a.a_ray.r_pt, eye_model );
			} else {
			 	VMOVE( a.a_ray.r_dir, ap->a_ray.r_dir );
			}

			a.a_level = 0;		/* recursion level */
			rt_shootray( &a );
			VADD2( colorsum, colorsum, a.a_color );
		}
		if( hypersample )  {
			FAST fastf_t f;
			f = 1.0 / (hypersample+1);
			VSCALE( a.a_color, colorsum, f );
		}
		pixelp = scanbuf+LINENO_WIDTH+(a.a_x*3);
		r = a.a_color[0]*255.;
		g = a.a_color[1]*255.;
		b = a.a_color[2]*255.;
		/* Truncate glints, etc */
		if( r > 255 )  r=255;
		if( g > 255 )  g=255;
		if( b > 255 )  b=255;
		if( r<0 || g<0 || b<0 )  {
			rt_log("Negative RGB %d,%d,%d\n", r, g, b );
			r = 0x80;
			g = 0xFF;
			b = 0x80;
		}
		*pixelp++ = r ;
		*pixelp++ = g ;
		*pixelp++ = b ;
d396 1
d429 4
d453 2
a454 2
	for( i=0; i<pkg_swlen; i++ )  {
		if( pkg_switch[i].pks_type == pc->pkc_type )  break;
d457 1
a457 1
		pkg_switch[i].pks_title, pc->pkc_len);
d513 11
@


1.2
log
@Buffering version which knows about the print_on flag.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: rtsrv.c,v 1.1 86/07/22 04:59:11 mike Exp $ (BRL)";
d44 1
d169 1
d175 3
d224 1
d274 7
d350 6
d362 2
d420 1
d433 30
a462 10
		VJOIN2( a.a_ray.r_pt, viewbase_model,
			a.a_x, dx_model, 
			(npts-a.a_y-1), dy_model );
		if( perspective )  {
			VSUB2( a.a_ray.r_dir,
				a.a_ray.r_pt, eye_model );
			VUNITIZE( a.a_ray.r_dir );
			VMOVE( a.a_ray.r_pt, eye_model );
		} else {
		 	VMOVE( a.a_ray.r_dir, ap->a_ray.r_dir );
d464 5
a468 4

		a.a_level = 0;		/* recursion level */
		rt_shootray( &a );

@


1.1
log
@Initial revision
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: rt.c,v 2.13 85/11/20 17:06:15 mike Exp $ (BRL)";
d80 1
d88 1
d446 11
d461 1
d468 2
a469 1
	char buf[256];		/* a generous output line */
d471 6
a476 2
	(void)sprintf( buf, str, a, b, c, d, e, f, g, h );
	if( pkg_send( MSG_PRINT, buf, strlen(buf)+1, pcsrv ) < 0 )
d478 1
d480 1
@
