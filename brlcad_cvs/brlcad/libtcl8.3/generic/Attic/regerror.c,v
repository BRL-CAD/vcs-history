head	1.4;
access;
symbols
	ansi-20040316-freeze:1.3
	rel-6-1-DP:1.3
	rel-6-0-2:1.3
	rel-6-0-1-branch:1.3.0.2
	hartley-6-0-post:1.3
	hartley-6-0-pre:1.3
	rel-6-0-1:1.3
	rel-6-0:1.3
	rel-5-4:1.1.1.1
	offsite-5-3-pre:1.1.1.1
	rel-5-3:1.1.1.1
	rel-5-1-branch:1.1.1.1.0.2
	windows-6-0-branch:1.3.0.6
	ansi-6-0-branch:1.3.0.4
	tcl8-3:1.1.1.1
	scriptics:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2003.03.13.19.09.54;	author jra;	state dead;
branches;
next	1.3;

1.3
date	2001.07.03.01.30.01;	author butler;	state Exp;
branches
	1.3.4.1
	1.3.6.1;
next	1.2;

1.2
date	2001.04.20.22.30.08;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2000.12.06.21.33.20;	author bparker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.12.06.21.33.20;	author bparker;	state Exp;
branches;
next	;

1.3.4.1
date	2004.03.17.07.14.18;	author morrison;	state dead;
branches;
next	;

1.3.6.1
date	2004.03.11.23.44.09;	author morrison;	state dead;
branches;
next	;


desc
@@


1.4
log
@*** empty log message ***
@
text
@/*
 * regerror - error-code expansion
 *
 * Copyright (c) 1998, 1999 Henry Spencer.  All rights reserved.
 * 
 * Development of this software was funded, in part, by Cray Research Inc.,
 * UUNET Communications Services Inc., Sun Microsystems Inc., and Scriptics
 * Corporation, none of whom are responsible for the results.  The author
 * thanks all of them. 
 * 
 * Redistribution and use in source and binary forms -- with or without
 * modification -- are permitted for any purpose, provided that
 * redistributions in source form retain this entire copyright notice and
 * indicate the origin and nature of any modifications.
 * 
 * I'd appreciate being given credit for this package in the documentation
 * of software which uses it, but that is not a requirement.
 * 
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
 * HENRY SPENCER BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include "regguts.h"

/* unknown-error explanation */
static char unk[] = "*** unknown regex error code 0x%x ***";

/* struct to map among codes, code names, and explanations */
static struct rerr {
	int code;
	char *name;
	char *explain;
} rerrs[] = {
	/* the actual table is built from regex.h */
#	include "regerrs.h"
	{ -1,	"",	"oops" },	/* explanation special-cased in code */
};

/*
 - regerror - the interface to error numbers
 */
/* ARGSUSED */
size_t				/* actual space needed (including NUL) */
regerror(errcode, preg, errbuf, errbuf_size)
int errcode;			/* error code, or REG_ATOI or REG_ITOA */
const regex_t *preg;		/* associated regex_t (unused at present) */
char *errbuf;			/* result buffer (unless errbuf_size==0) */
size_t errbuf_size;		/* available space in errbuf, can be 0 */
{
	struct rerr *r;
	char *msg;
	char convbuf[sizeof(unk)+50];	/* 50 = plenty for int */
	size_t len;
	int icode;

	switch (errcode) {
	case REG_ATOI:		/* convert name to number */
		for (r = rerrs; r->code >= 0; r++)
			if (strcmp(r->name, errbuf) == 0)
				break;
		sprintf(convbuf, "%d", r->code);	/* -1 for unknown */
		msg = convbuf;
		break;
	case REG_ITOA:		/* convert number to name */
		icode = atoi(errbuf);	/* not our problem if this fails */
		for (r = rerrs; r->code >= 0; r++)
			if (r->code == icode)
				break;
		if (r->code >= 0)
			msg = r->name;
		else {			/* unknown; tell him the number */
			sprintf(convbuf, "REG_%u", (unsigned)icode);
			msg = convbuf;
		}
		break;
	default:		/* a real, normal error code */
		for (r = rerrs; r->code >= 0; r++)
			if (r->code == errcode)
				break;
		if (r->code >= 0)
			msg = r->explain;
		else {			/* unknown; say so */
			sprintf(convbuf, unk, errcode);
			msg = convbuf;
		}
		break;
	}

	len = strlen(msg) + 1;		/* space needed, including NUL */
	if (errbuf_size > 0) {
		if (errbuf_size > len)
			strcpy(errbuf, msg);
		else {			/* truncate to fit */
			strncpy(errbuf, msg, errbuf_size-1);
			errbuf[errbuf_size-1] = '\0';
		}
	}

	return len;
}

@


1.3
log
@forcing the timestamps.
@
text
@@


1.3.4.1
log
@sync branch with HEAD
@
text
@@


1.3.6.1
log
@sync to HEAD...
@
text
@@


1.2
log
@CONST to const
@
text
@d110 1
@


1.1
log
@Initial revision
@
text
@d55 1
a55 1
CONST regex_t *preg;		/* associated regex_t (unused at present) */
@


1.1.1.1
log
@Import tcl8.3
@
text
@@
