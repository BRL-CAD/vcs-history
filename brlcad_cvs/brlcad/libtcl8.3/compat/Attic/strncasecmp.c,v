head	1.3;
access;
symbols
	ansi-20040316-freeze:1.2
	rel-6-1-DP:1.2
	rel-6-0-2:1.2
	rel-6-0-1-branch:1.2.0.2
	hartley-6-0-post:1.2
	hartley-6-0-pre:1.2
	rel-6-0-1:1.2
	rel-6-0:1.2
	rel-5-4:1.1.1.1
	offsite-5-3-pre:1.1.1.1
	rel-5-3:1.1.1.1
	rel-5-1-branch:1.1.1.1.0.2
	windows-6-0-branch:1.2.0.6
	ansi-6-0-branch:1.2.0.4
	tcl8-3:1.1.1.1
	scriptics:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2003.03.13.19.09.31;	author jra;	state dead;
branches;
next	1.2;

1.2
date	2001.04.20.22.30.04;	author morrison;	state Exp;
branches
	1.2.4.1
	1.2.6.1;
next	1.1;

1.1
date	2000.12.06.21.33.21;	author bparker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.12.06.21.33.21;	author bparker;	state Exp;
branches;
next	;

1.2.4.1
date	2004.03.17.07.14.05;	author morrison;	state dead;
branches;
next	;

1.2.6.1
date	2004.03.11.23.44.03;	author morrison;	state dead;
branches;
next	;


desc
@@


1.3
log
@*** empty log message ***
@
text
@/* 
 * strncasecmp.c --
 *
 *	Source code for the "strncasecmp" library routine.
 *
 * Copyright (c) 1988-1993 The Regents of the University of California.
 * Copyright (c) 1995-1996 Sun Microsystems, Inc.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @@(#) $Id: strncasecmp.c,v 1.2 2001/04/20 22:30:04 morrison Exp $
 */

#include "tclPort.h"

/*
 * This array is designed for mapping upper and lower case letter
 * together for a case independent comparison.  The mappings are
 * based upon ASCII character sequences.
 */

static unsigned char charmap[] = {
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
    0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
    0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
    0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
    0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
    0x40, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
    0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
    0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
    0x78, 0x79, 0x7a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
    0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
    0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
    0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
    0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
    0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,
    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
    0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,
    0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,
    0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
    0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,
    0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,
    0xc0, 0xe1, 0xe2, 0xe3, 0xe4, 0xc5, 0xe6, 0xe7,
    0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,
    0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,
    0xf8, 0xf9, 0xfa, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,
    0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7,
    0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,
    0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,
    0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff,
};

/*
 * Here are the prototypes just in case they are not included
 * in tclPort.h.
 */
int		strncasecmp _ANSI_ARGS_((const char *s1,
			    const char *s2, size_t n));

int		strcasecmp _ANSI_ARGS_((const char *s1,
			    const char *s2));

/*
 *----------------------------------------------------------------------
 *
 * strcasecmp --
 *
 *	Compares two strings, ignoring case differences.
 *
 * Results:
 *	Compares two null-terminated strings s1 and s2, returning -1, 0,
 *	or 1 if s1 is lexicographically less than, equal to, or greater
 *	than s2.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
strcasecmp(s1, s2)
    const char *s1;			/* First string. */
    const char *s2;			/* Second string. */
{
    unsigned char u1, u2;

    for ( ; ; s1++, s2++) {
	u1 = (unsigned char) *s1;
	u2 = (unsigned char) *s2;
	if ((u1 == '\0') || (charmap[u1] != charmap[u2])) {
	    break;
	}
    }
    return charmap[u1] - charmap[u2];
}

/*
 *----------------------------------------------------------------------
 *
 * strncasecmp --
 *
 *	Compares two strings, ignoring case differences.
 *
 * Results:
 *	Compares up to length chars of s1 and s2, returning -1, 0, or 1
 *	if s1 is lexicographically less than, equal to, or greater
 *	than s2 over those characters.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
strncasecmp(s1, s2, length)
    const char *s1;		/* First string. */
    const char *s2;		/* Second string. */
    size_t length;		/* Maximum number of characters to compare
				 * (stop earlier if the end of either string
				 * is reached). */
{
    unsigned char u1, u2;

    for (; length != 0; length--, s1++, s2++) {
	u1 = (unsigned char) *s1;
	u2 = (unsigned char) *s2;
	if (charmap[u1] != charmap[u2]) {
	    return charmap[u1] - charmap[u2];
	}
	if (u1 == '\0') {
	    return 0;
	}
    }
    return 0;
}
@


1.2
log
@CONST to const
@
text
@d12 1
a12 1
 * RCS: @@(#) $Id: strncasecmp.c,v 1.1.1.1 2000/12/06 21:33:21 bparker Exp $
@


1.2.4.1
log
@sync branch with HEAD
@
text
@d12 1
a12 1
 * RCS: @@(#) $Id: strncasecmp.c,v 1.2 2001/04/20 22:30:04 morrison Exp $
@


1.2.6.1
log
@sync to HEAD...
@
text
@d12 1
a12 1
 * RCS: @@(#) $Id: strncasecmp.c,v 1.2 2001/04/20 22:30:04 morrison Exp $
@


1.1
log
@Initial revision
@
text
@d12 1
a12 1
 * RCS: @@(#) $Id: strncasecmp.c,v 1.2 1998/09/14 18:39:45 stanton Exp $
d62 2
a63 2
int		strncasecmp _ANSI_ARGS_((CONST char *s1,
			    CONST char *s2, size_t n));
d65 2
a66 2
int		strcasecmp _ANSI_ARGS_((CONST char *s1,
			    CONST char *s2));
d88 2
a89 2
    CONST char *s1;			/* First string. */
    CONST char *s2;			/* Second string. */
d123 2
a124 2
    CONST char *s1;		/* First string. */
    CONST char *s2;		/* Second string. */
@


1.1.1.1
log
@Import tcl8.3
@
text
@@
