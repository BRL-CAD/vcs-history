head	11.3;
access;
symbols
	ansi-20040405-merged:11.1.6.1
	postmerge-20040405-ansi:11.2
	premerge-20040404-ansi:11.2
	postmerge-autoconf:11.2
	autoconf-freeze:11.1.14.2
	premerge-autoconf:11.2
	ansi-20040316-freeze:11.1
	postmerge-20040315-windows:11.2
	premerge-20040315-windows:11.2
	windows-20040315-freeze:11.1.8.1
	autoconf-20031203:11.1
	autoconf-20031202:11.1
	autoconf-branch:11.1.0.14
	phong-branch:11.1.0.12
	photonmap-branch:11.1.0.10
	rel-6-1-DP:11.1
	windows-branch:11.1.0.8
	rel-6-0-2:11.1
	ansi-branch:11.1.0.6
	rel-6-0-1-branch:11.1.0.4
	hartley-6-0-post:11.1
	hartley-6-0-pre:11.1
	rel-6-0-1:11.1
	rel-6-0:11.1
	rel-5-4:11.1
	offsite-5-3-pre:11.1
	rel-5-3:11.1
	rel-5-2:11.1
	rel-5-1-branch:11.1.0.2
	rel-5-1:11.1
	rel-5-0:11.1
	rel-5-0-beta:11.1
	rel-4-5:11.1
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:1.6
	rel-3-5:1.6
	rel-3-0:1.6
	rel-2-3:1.6
	rel-2-0:1.6
	rel-1-24:1.6
	rel-1-20:1.6
	rel-1-10:1.6;
locks; strict;
comment	@ * @;


11.3
date	2004.05.21.18.07.25;	author morrison;	state dead;
branches;
next	11.2;

11.2
date	2004.02.02.17.39.12;	author morrison;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.53.03;	author mike;	state Rel4_4;
branches
	11.1.6.1
	11.1.8.1
	11.1.14.1;
next	1.6;

1.6
date	86.11.17.20.22.53;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	86.11.15.06.16.41;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	86.11.15.05.55.45;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	86.11.15.05.37.08;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	86.11.15.02.43.39;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	86.11.14.23.14.16;	author moss;	state Exp;
branches;
next	;

11.1.6.1
date	2004.03.17.21.17.02;	author morrison;	state Exp;
branches;
next	;

11.1.8.1
date	2004.03.11.23.42.07;	author morrison;	state Exp;
branches;
next	;

11.1.14.1
date	2004.02.12.19.48.12;	author erikg;	state Exp;
branches;
next	11.1.14.2;

11.1.14.2
date	2004.03.15.14.06.20;	author erikg;	state Exp;
branches;
next	;


desc
@SGI interface that operates in 12-bit mode,
suitable for use in windows under MEX.
@


11.3
log
@moved to src/
@
text
@/*
 *			I F _ S G I W . C
 *
 *  SGI window (MEX) oriented interface, which operates in 12-bit mode.
 *
 *  Authors -
 *	Paul R. Stay
 *	Gary S. Moss
 *	Mike J. Muuss
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1986-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/libfb/if_sgiw.c,v 11.2 2004/02/02 17:39:12 morrison Exp $ (BRL)";
#endif

#include <stdio.h>
#include <ctype.h>
#include <gl.h>
#include <gl2/immed.h>
#undef RED

#include "fb.h"
#include "./fblocal.h"

#define Abs( x_ )	((x_) < 0 ? -(x_) : (x_))

#define MARGIN	4			/* # pixels margin to screen edge */
#define BANNER	18			/* Size of MEX title banner */
#define WIN_L	(1024-ifp->if_width-MARGIN)
#define WIN_R	(1024-MARGIN)
#define WIN_B	MARGIN
#define WIN_T	(ifp->if_height+MARGIN)

#define MAP_RESERVED	16		/* # slots reserved by MEX */
#define MAP_SIZE	1024		/* # slots available, incl reserved */
#define MAP_TOL		28		/* pixel delta across all channels */
/* TOL of 28 gives good rendering of the dragon picture without running out */

/*
 *  Defines for dealing with SGI Graphics Engine Pipeline
 */
union gepipe {
	short	s;
	long	l;
	float	f;
};

/**#define MC_68010 xx	/* not a turbo */
#ifdef MC_68010
#define GEPIPE	((union gepipe *)0X00FD5000)
#define GE	0x00FD5000
#else
#define GEPIPE	((union gepipe *)0X60001000)
#define GE	0x60001000
#endif
#define GEP_END(_p)	((union gepipe *)(((char *)(_p))-0x1000))	/* 68000 efficient 0xFd4000 */
#define CMOV2S(_p,_x,_y) { \
		(_p)->l = 0x0008001A; \
		(_p)->s = 0x0912; \
		(_p)->s = (_x); \
		(_p)->s = (_y); \
		GEP_END(hole)->s = (0xFF<<8)|8; \
		}

/* These globals need to be in the FBIO structure.			*/
static int		xzoom = 1, yzoom = 1;
static int		special_zoom = 0;

static Cursor	cursor =
	{
#include "./sgicursor.h"
	};
_LOCAL_ int	sgw_dopen(),
		sgw_dclose(),
		sgw_dreset(),
		sgw_dclear(),
		sgw_bread(),
		sgw_bwrite(),
		sgw_cmread(),
		sgw_cmwrite(),
		sgw_viewport_set(),
		sgw_window_set(),
		sgw_zoom_set(),
		sgw_curs_set(),
		sgw_cmemory_addr(),
		sgw_cscreen_addr();

/* This is the ONLY thing that we "export" */
FBIO sgiw_interface =
		{
		sgw_dopen,
		sgw_dclose,
		sgw_dreset,
		sgw_dclear,
		sgw_bread,
		sgw_bwrite,
		fb_null,
		fb_null,
		sgw_viewport_set,
		fb_null,
		sgw_zoom_set,
		sgw_curs_set,
		sgw_cmemory_addr,
		fb_null,
		"Silicon Graphics IRIS, in 12-bit mode, for windows",
		1024,			/* max width */
		768,			/* max height */
		"/dev/sgiw",
		512,			/* current/default width  */
		512,			/* current/default height */
		-1,			/* file descriptor */
		PIXEL_NULL,		/* page_base */
		PIXEL_NULL,		/* page_curp */
		PIXEL_NULL,		/* page_endp */
		-1,			/* page_no */
		0,			/* pdirty */
		0L,			/* page_curpos */
		0L,			/* page_pixels */
		0			/* debug */
		};


_LOCAL_ int _sgw_cmap_flag;

_LOCAL_ ColorMap _sgw_cmap;

static RGBpixel	rgb_table[MAP_SIZE];
static int	rgb_ct = MAP_RESERVED;

/*
 *			g e t _ C o l o r _ I n d e x
 */
Colorindex
get_Color_Index( pixelp )
register RGBpixel	*pixelp;
{
	register int		i;
	int			best = 7;
	register RGBpixel	*sp;
	static int		groused = 0;
	register int		min_diff = 128;

	/* Find best fit in existing table */
	best = 0;
	for( i = 0, sp = rgb_table; i < rgb_ct; sp++, i++ ) {
		register int	diff;
		register int	d;

		d = ((int)((*pixelp)[RED])) - ((int)(*sp)[RED]);
		if( (diff = Abs(d)) >= min_diff )
			continue;
		d = ((int)((*pixelp)[GRN])) - ((int)(*sp)[GRN]);
		if( (diff += Abs(d)) >= min_diff )
			continue;
		d = ((int)((*pixelp)[BLU])) - ((int)(*sp)[BLU]);
		if( (diff += Abs(d)) >= min_diff )
			continue;

		/* [i]'th element is the best so far... */
		if( (min_diff = diff) <= 2 )  {
			/* Great match */
			return( (Colorindex)i );
		}
		best = i;
	}

	/* Match found to within tolerance? */
	if( min_diff < MAP_TOL ) 
		return	(Colorindex)best;

	/* Allocate new entry in color table if there's room.		*/
	if( i < MAP_SIZE )  {
		COPYRGB( rgb_table[rgb_ct], *pixelp);
		mapcolor(	(Colorindex)rgb_ct,
				(short) (*pixelp)[RED],
				(short) (*pixelp)[GRN],
				(short) (*pixelp)[BLU]
				);
		return	(Colorindex)(rgb_ct++);
	}

	/* No room to add, use best we found */
	if( !groused )  {
		groused = 1;
		fb_log( "Color table now full, will use closest matches.\n" );
	}
	return	(Colorindex)best;
}

#define SET(i,r,g,b)	{ \
	rgb_table[i][RED] = r; \
	rgb_table[i][GRN] = g; \
	rgb_table[i][BLU] = b; }

#define if_mode		u1.l		/* Local flag for mode */

_LOCAL_ int
sgw_dopen( ifp, file, width, height )
FBIO	*ifp;
char	*file;
int	width, height;
{	register Colorindex i;

	if( file != NULL )  {
		register char *cp;
		/* "/dev/sgiw###" gives optional mode */
		for( cp = file; *cp != NULL && !isdigit(*cp); cp++ ) ;
		sscanf( cp, "%d", &ifp->if_mode );
	}
	if ( width > ifp->if_max_width - 2 * MARGIN) 
		width = ifp->if_max_width - 2 * MARGIN;

	if ( height > ifp->if_max_height - 2 * MARGIN - BANNER)
		height = ifp->if_max_height - 2 * MARGIN - BANNER;

	ifp->if_width = width;
	ifp->if_height = height;
	
	if( ismex() )
		{
#if 0
		prefposition( WIN_L, WIN_R, WIN_B, WIN_T );
		foreground();
		if( (ifp->if_fd = winopen( "Frame buffer" )) == -1 )
			{
			fb_log( "No more graphics ports available.\n" );
			return	-1;
			}
		wintitle( "frame buffer" );
#endif
		}
	else
		ginit();

	/* The first 8 entries of the colormap are "known" colors */
	SET( 0, 000, 000, 000 );	/* BLACK */
	SET( 1, 255, 000, 000 );	/* RED */
	SET( 2, 000, 255, 000 );	/* GREEN */
	SET( 3, 255, 255, 000 );	/* YELLOW */
	SET( 4, 000, 000, 255 );	/* BLUE */
	SET( 5, 255, 000, 255 );	/* MAGENTA */
	SET( 6, 000, 255, 000 );	/* CYAN */
	SET( 7, 255, 255, 255 );	/* WHITE */

	/* Mode 0 builds color map on the fly */
	if( ifp->if_mode )
		{
		/* Mode 1 uses fixed color map */
		for( i = 0; i < MAP_SIZE-MAP_RESERVED; i++ )
			mapcolor( 	i+MAP_RESERVED,
					(short)((i % 10) + 1) * 25,
					(short)(((i / 10) % 10) + 1) * 25,
					(short)((i / 100) + 1) * 25
					);
		}

	singlebuffer();
	gconfig();		/* Must be called after singlebuffer().	*/

	/* Build a linear "colormap" in case he wants to read it */
	sgw_cmwrite( ifp, COLORMAP_NULL );
	/* Setup default cursor.					*/
	defcursor( 1, cursor );
	curorigin( 1, 0, 0 );
	return	0;
}

_LOCAL_ int
sgw_dclose( ifp )
FBIO	*ifp;
{
	if( ismex() )
		; /* winclose( ifp->if_fd ); */
	else
		{
		greset();
		gexit();
		}
/** 	fb_log( "%d color table entries used.\n", rgb_ct );  **/
	return	0;	
}

_LOCAL_ int
sgw_dreset( ifp )
FBIO	*ifp;
{
	ginit();
	singlebuffer();
	gconfig();

	color(BLACK);
	clear();
	return	0;	
}

_LOCAL_ int
sgw_dclear( ifp, pp )
FBIO	*ifp;
RGBpixel	*pp;
{
	if ( pp != RGBPIXEL_NULL)
		color( get_Color_Index( pp ) );
	else
		color( BLACK );
	writemask( 0x3FF );
	clear();
	return	0;	
}

_LOCAL_ int
sgw_bread( ifp, x, y, pixelp, count )
FBIO	*ifp;
register int	x, y;
register RGBpixel	*pixelp;
int	count;
{	register union gepipe *hole = GEPIPE;
	short scan_count;
	Colorindex colors[1025];
	register int i;

	x *= xzoom;
	while( count > 0 )
		{	register short	ypos = y*yzoom;
		if ( count >= ifp->if_width )
			scan_count = ifp->if_width;
		else
			scan_count = count;
		if( (xzoom == 1 && yzoom == 1) || special_zoom )
			{ /* No pixel replication, so read scan of pixels. */
			CMOV2S( hole, x, ypos );
			readpixels( scan_count, colors );
			}
		else
			{ /* We are sampling from rectangles
				(replicated pixels). */
			for( i = 0; i < scan_count; i++ )
				{
				CMOV2S( hole, x, ypos );
				x += xzoom;
				readpixels( 1, &colors[i] );
				}
			}
		for( i = 0; i < scan_count; i++, pixelp++) 
			{
			if( ifp->if_mode )
				{
				colors[i] -= MAP_RESERVED;
				(*pixelp)[RED] =   (colors[i] % 10 + 1) * 25;
				colors[i] /= 10;
				(*pixelp)[GRN] = (colors[i] % 10 + 1) * 25;
				colors[i] /= 10;
				(*pixelp)[BLU] =  (colors[i] % 10 + 1) * 25;
				}
			else
				{
				register int	ci = colors[i];
				if( ci < rgb_ct )
					{
					COPYRGB( *pixelp, rgb_table[ci]);
					}
				else
					(*pixelp)[RED] = (*pixelp)[GRN] = (*pixelp)[BLU] = 0;
				}
			}
		count -= scan_count;
		x = 0;
		y++;
	}
	return	0;	
}

_LOCAL_ int
sgw_bwrite( ifp, x, y, pixelp, count )
FBIO	*ifp;
register int	x, y;
register RGBpixel	*pixelp;
int	count;
	{	register union gepipe *hole = GEPIPE;
		short scan_count;
		register int i;

	writemask( 0x3FF );
	x *= xzoom;
	while( count > 0 )
		{	register short	ypos = y*yzoom;
		if ( count >= ifp->if_width )
			scan_count = ifp->if_width;
		else
			scan_count = count;
		if( (xzoom == 1 && yzoom == 1) || special_zoom )
			{	register Colorindex	colori;
			CMOV2S( hole, x, ypos );
			for( i = scan_count; i > 0; )
				{	register int	chunk;
				if( i <= 127 )
					chunk = i;
				else
					chunk = 127;
				hole->s = (chunk<<8)|8; /* GEpassthru */
				hole->s = 0xD;		 /* FBCdrawpixels */
				i -= chunk;
				for( ; chunk > 0; chunk--, pixelp++ )
					{
					if( ifp->if_mode )
						{
						colori =  MAP_RESERVED +
							((*pixelp)[RED]/26);
						colori += ((*pixelp)[GRN]/26) * 10;
						colori += ((*pixelp)[BLU]/26) * 100;
						}
					else
						colori = get_Color_Index( pixelp );
					hole->s = colori;
					}
				}
			GEP_END(hole)->s = (0xFF<<8)|8;	/* im_last_passthru(0) */
			}
		else
			for( i = 0; i < scan_count; i++, pixelp++ )
				{	register Colorindex	col;
					register Coord	r = x + xzoom - 1,
							t = ypos + yzoom - 1;
				CMOV2S( hole, x, ypos );
				if( ifp->if_mode )
					{
					col =  MAP_RESERVED +
						((*pixelp)[RED]/26);
					col += ((*pixelp)[GRN]/26) * 10;
					col += ((*pixelp)[BLU]/26) * 100;
					}
				else
					col = get_Color_Index( pixelp );

				color( col );
				im_rectf( (Coord)x, (Coord)ypos, r, t );
				x += xzoom;
				}
		count -= scan_count;
		x = 0;
		y++;
		}
	return	0;
	}

_LOCAL_ int
sgw_viewport_set( ifp, left, top, right, bottom )
FBIO	*ifp;
int	left, top, right, bottom;
{
#if 0
	viewport(	(Screencoord) left,
			(Screencoord) right,
			(Screencoord) top,
			(Screencoord) (bottom * fb2iris_scale)
			);
#endif
	return	0;
}

_LOCAL_ int
sgw_cmread( ifp, cmp )
FBIO	*ifp;
register ColorMap	*cmp;
{
	register int i;

	/* Just parrot back the stored colormap */
	for( i = 0; i < 255; i++)
	{
		cmp->cm_red[i] = _sgw_cmap.cm_red[i]<<8;
		cmp->cm_green[i] = _sgw_cmap.cm_green[i]<<8;
		cmp->cm_blue[i] = _sgw_cmap.cm_blue[i]<<8;
	}
	return	0;
}

_LOCAL_ int
sgw_cmwrite( ifp, cmp )
FBIO	*ifp;
register ColorMap	*cmp;
{
	register int i;

	if ( cmp == COLORMAP_NULL)  {
		for( i = 0; i < 255; i++)  {
			_sgw_cmap.cm_red[i] = i;
			_sgw_cmap.cm_green[i] = i;
			_sgw_cmap.cm_blue[i] = i;
		}
		_sgw_cmap_flag = FALSE;
		return	0;
	}
	
	for(i = 0; i < 255; i++)  {
		_sgw_cmap.cm_red[i] = cmp -> cm_red[i]>>8;
		_sgw_cmap.cm_green[i] = cmp-> cm_green[i]>>8; 
		_sgw_cmap.cm_blue[i] = cmp-> cm_blue[i]>>8;

	}
	_sgw_cmap_flag = TRUE;
	return	0;
}

_LOCAL_ int
sgw_zoom_set( ifp, x, y )
FBIO	*ifp;
int	x, y;
	{
	if( x == 0 )  x = 1;
	if( y == 0 )  y = 1;
	if( x < 0 || y < 0 )
		{
		special_zoom = 1;
		x = y = 1;
		}
	else
		special_zoom = 0;
	xzoom = x;
	yzoom = y;
	return	0;
	}

_LOCAL_ int
sgw_curs_set( ifp, bits, xbits, ybits, xorig, yorig )
FBIO	*ifp;
unsigned char	*bits;
int		xbits, ybits;
int		xorig, yorig;
	{	register int	y;
		register int	xbytes;
		Cursor		newcursor;
	/* Check size of cursor.					*/
	if( xbits < 0 )
		return	-1;
	if( xbits > 16 )
		xbits = 16;
	if( ybits < 0 )
		return	-1;
	if( ybits > 16 )
		ybits = 16;
	if( (xbytes = xbits / 8) * 8 != xbits )
		xbytes++;
	for( y = 0; y < ybits; y++ )
		{
		newcursor[y] = bits[(y*xbytes)+0] << 8 & 0xFF00;
		if( xbytes == 2 )
			newcursor[y] |= bits[(y*xbytes)+1] & 0x00FF;
		}
	defcursor( 1, newcursor );
	curorigin( 1, (short) xorig, (short) yorig );
	return	0;
	}

_LOCAL_ int
sgw_cmemory_addr( ifp, mode, x, y )
FBIO	*ifp;
int	mode;
int	x, y;
	{	static Colorindex	cursor_color = YELLOW;
			/* Color and bitmask ignored under MEX.	*/
	if( ! mode )
		{
		cursoff();
		setcursor( 0, 1, 0x2000 );
		return	0;
		}
	x *= xzoom;
	y *= yzoom;
	curson();
	setcursor( 1, cursor_color, 0x2000 );
	setvaluator( MOUSEX, x + WIN_L, 0, 1023 );
	setvaluator( MOUSEY, y + WIN_B, 0, 1023 );
	return	0;
	}
@


11.2
log
@update copyright to include span through 2003
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_sgiw.c,v 11.1 1995/01/04 09:53:03 mike Rel4_4 $ (BRL)";
@


11.1
log
@Release_4.4
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1986 by the United States Army.
d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_sgiw.c,v 1.6 86/11/17 20:22:53 mike Exp $ (BRL)";
@


11.1.6.1
log
@sync branch with HEAD
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d21 1
a21 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.1.8.1
log
@sync to HEAD...
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/libfb/if_sgiw.c,v 11.2 2004/02/02 17:39:12 morrison Exp $ (BRL)";
@


11.1.14.1
log
@merge from HEAD
@
text
@d17 1
a17 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_sgiw.c,v 11.2 2004/02/02 17:39:12 morrison Exp $ (BRL)";
@


11.1.14.2
log
@merge from head
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_sgiw.c,v 11.1.14.1 2004/02/12 19:48:12 erikg Exp $ (BRL)";
@


1.6
log
@Moss's fixes to mode1 (premapped) display,
and addition of cursor support.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: if_sgiw.c,v 1.5 86/11/15 06:16:41 mike Exp $ (BRL)";
@


1.5
log
@Added if_mode processing of /dev/sgiw## style opens.
Mode 0 (default) is best-fit dynamic colormap.
Mode 1 is preallocated map.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: if_sgiw.c,v 1.4 86/11/15 05:55:45 mike Locked $ (BRL)";
d42 1
a42 1
#define MAP_RESERVED	32		/* # slots reserved by MEX */
d92 1
a92 1
		sgw_cinit_bitmap(),
d110 1
a110 1
		sgw_cinit_bitmap,
d229 1
d238 1
d257 2
a258 2
		for( i = MAP_RESERVED; i < MAP_SIZE; i++ )
			mapcolor( 	i,
d270 3
a272 1

d355 1
d414 2
a415 1
						colori =  ((*pixelp)[RED]/26);
d430 1
a430 1
							t = ypos - yzoom + 1;
d434 2
a435 1
					col =  ((*pixelp)[RED]/26);
d532 1
a532 1
sgw_cinit_bitmap( ifp, bitmap )
d534 25
a558 5
long	bitmap[32];
	{	register int	i;
	for( i = 0; i < 16; i++ )
		cursor[i] = bitmap[15-i] & 0xFFFF;
	defcursor( 1, cursor );
d567 1
a567 3
	{	register int		xpos, ypos;
		register union gepipe *hole = GEPIPE;
		static Colorindex	cursor_color = YELLOW;
@


1.4
log
@More refinements.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: if_sgiw.c,v 1.1 86/11/14 23:14:16 moss Exp $ (BRL)";
d25 1
d203 2
d212 6
d251 12
a262 8
#if MAP_PREALLOCATED
	for( i = MAP_RESERVED; i < MAP_SIZE; i++ )
		mapcolor( 	i,
				(short)((i % 10) + 1) * 25,
				(short)(((i / 10) % 10) + 1) * 25,
				(short)((i / 100) + 1) * 25
				);
#endif
d349 1
a349 9
#if MAP_PREALLOCATED
			(*pixelp)[RED] =   (colors[i] % 10 + 1) * 25;
			colors[i] /= 10;
			(*pixelp)[GRN] = (colors[i] % 10 + 1) * 25;
			colors[i] /= 10;
			(*pixelp)[BLU] =  (colors[i] % 10 + 1) * 25;
#else
				register int	ci = colors[i];
			if( ci < rgb_ct )
d351 5
a355 1
				COPYRGB( *pixelp, rgb_table[ci]);
d358 9
a366 2
				(*pixelp)[RED] = (*pixelp)[GRN] = (*pixelp)[BLU] = 0;
#endif
d407 8
a414 7
#if MAP_PREALLOCATED
					colori =  ((*pixelp)[RED]/26);
					colori += ((*pixelp)[GRN]/26) * 10;
					colori += ((*pixelp)[BLU]/26) * 100;
#else
					colori = get_Color_Index( pixelp );
#endif
d426 9
a434 7
#if MAP_PREALLOCATED
				col =  ((*pixelp)[RED]/26);
				col += ((*pixelp)[GRN]/26) * 10;
				col += ((*pixelp)[BLU]/26) * 100;
#else
				col = get_Color_Index( pixelp );
#endif
@


1.3
log
@Improved version.
@
text
@d2 17
a18 15
  Authors -
	Paul R. Stay
	Gary S. Moss
	Mike J. Muuss

  Source -
	SECAD/VLD Computing Consortium, Bldg 394
	The U. S. Army Ballistic Research Laboratory
	Aberdeen Proving Ground, Maryland  21005-5066
  
  Copyright Notice -
	This software is Copyright (C) 1986 by the United States Army.
	All rights reserved.

	$Header: if_sgiw.c,v 1.2 86/11/15 02:43:39 mike Locked $ (BRL)
d21 1
a21 1
static char RCSid[] = "@@(#)$Header: if_sgiw.c,v 1.2 86/11/15 02:43:39 mike Locked $ (BRL)";
d35 1
d212 2
a213 2
	if ( height > ifp->if_max_height - 2 * MARGIN - 20)
		height = ifp->if_max_height - 2 * MARGIN - 20;	/* MEX bar */
d309 1
a309 1
	Colorindex colors[1024];
d319 1
a319 1
		if( xzoom == 1 && yzoom == 1 || special_zoom )
d368 1
d377 1
a377 1
		if( xzoom == 1 && yzoom == 1 || special_zoom )
d406 1
a406 3
					register Coord	l = x,
							b = ypos,
							r = x + xzoom - 1,
d417 1
a417 1
				im_rectf( l, b, r, t );
d491 2
@


1.2
log
@Somewhat working version, converted to RGBpixel, 1st quadrant,
useable with MEX.
Some difficulty with best color chosing.
@
text
@d16 1
a16 1
	$Header: if_sgiw.c,v 1.1 86/11/14 23:14:16 moss Exp $ (BRL)
d19 1
a19 1
static char RCSid[] = "@@(#)$Header: if_sgiw.c,v 1.1 86/11/14 23:14:16 moss Exp $ (BRL)";
a30 4
#define WIN_L	(1023-511-4)
#define WIN_R	(1023-4)
#define WIN_B	4
#define WIN_T	(511+4)
d32 5
a36 3
#define MAP_RESERVED	16			/* # slots reserved */
#define MAP_SIZE	(1024-MAP_RESERVED)	/* # slots available */
#define MAP_TOL		8			/* pixel delta */
d38 5
d132 1
a132 1
static int	rgb_ct = 0;
d134 3
a136 7
#define Map_Close( pp, qq ) \
	( \
	((dp = (pp)[RED]-(qq)[RED]) > -MAP_TOL && dp < MAP_TOL ) \
     && ((dp = (pp)[GRN]-(qq)[GRN]) > -MAP_TOL && dp < MAP_TOL ) \
     &&	((dp = (pp)[BLU]-(qq)[BLU]) > -MAP_TOL && dp < MAP_TOL ) \
	)

d140 6
a145 4
	{	register int	i;
		int	best;
		register RGBpixel	*sp;
		static int	groused = 0;
d147 1
a147 26
	/* Find match in color table if one exists.			*/
	for( i = 0, sp = rgb_table; i < rgb_ct; sp++, i++ )
		{	register int	dp;
		if( Map_Close( *pixelp, *sp ) )
			{
			/* Found close match.				*/
			return	(Colorindex)(i + MAP_RESERVED);
			}
		}
	/* Allocate new entry in color table if there's room.		*/
	if( i < MAP_SIZE )
		{
		COPYRGB( rgb_table[i], *pixelp);
		rgb_ct++;
		mapcolor(	(Colorindex)(i + MAP_RESERVED),
				(short) (*pixelp)[RED],
				(short) (*pixelp)[GRN],
				(short) (*pixelp)[BLU]
				);
		return	(Colorindex)(i + MAP_RESERVED);
		}
	/* Find closest match in color table.				*/
	if( !groused )  {
		groused = 1;
		fb_log( "Color table now full, will use closest matches.\n" );
	}
d149 5
a153 5
	for( i = 0, sp = rgb_table; i < MAP_SIZE; sp++, i++ )
		{	register int	diff;
			register int	d;
			register int	min_diff = 256;
		d = ((int)(*pixelp[RED])) - ((int)(*sp)[RED]);
d156 1
a156 1
		d = ((int)(*pixelp[GRN])) - ((int)(*sp)[GRN]);
d159 1
a159 1
		d = ((int)(*pixelp[BLU])) - ((int)(*sp)[BLU]);
d162 1
d164 4
a167 1
		min_diff = diff;
a168 2
		}
	return	(Colorindex)(best + MAP_RESERVED);
d171 28
d205 9
d217 1
a217 1
		prefposition( 1023-511-4, 1023-4, 4, 511+4 );
d219 1
a219 1
		if( (ifp->if_fd = winopen( "framebuffer" )) == -1 )
d228 11
d240 2
a241 2
	for( i = 0; i < MAP_SIZE; i++ )
		mapcolor( 	i+MAP_RESERVED,
a252 8
	if ( width > ifp->if_max_width) 
		width = ifp->if_max_width;

	if ( height > ifp->if_max_height) 
		height = ifp->if_max_height;

	ifp->if_width = width;
	ifp->if_height = height;
a333 1
			colors[i] -= MAP_RESERVED;
d340 2
a341 2
				register int	ci = colors[i] - MAP_RESERVED;
			if( ci >= 0 && ci < rgb_ct )
d388 1
a388 1
					colori =  ((*pixelp)[RED]/26) + MAP_RESERVED;
d408 1
a408 1
				col =  ((*pixelp)[RED]/26) + MAP_RESERVED;
@


1.1
log
@Initial revision
@
text
@d16 1
a16 1
	$Header: if_sgi.c,v 1.6 86/10/03 22:59:08 mike Exp $ (BRL)
d19 1
a19 1
static char RCSid[] = "@@(#)$Header: if_sgi.c,v 1.6 86/10/03 22:59:08 mike Exp $ (BRL)";
d25 2
d29 1
d36 3
a38 3
#define MAP_SIZE	1016
#define MAP_RESERVED	8
#define MAP_TOL		5
d74 14
a87 14
_LOCAL_ int	sgi_dopen(),
		sgi_dclose(),
		sgi_dreset(),
		sgi_dclear(),
		sgi_bread(),
		sgi_bwrite(),
		sgi_cmread(),
		sgi_cmwrite(),
		sgi_viewport_set(),
		sgi_window_set(),
		sgi_zoom_set(),
		sgi_cinit_bitmap(),
		sgi_cmemory_addr(),
		sgi_cscreen_addr();
d90 1
a90 1
FBIO sgi_interface =
d92 6
a97 6
		sgi_dopen,
		sgi_dclose,
		sgi_dreset,
		sgi_dclear,
		sgi_bread,
		sgi_bwrite,
d100 1
a100 1
		sgi_viewport_set,
d102 3
a104 3
		sgi_zoom_set,
		sgi_cinit_bitmap,
		sgi_cmemory_addr,
d109 1
a109 1
		"sgiw",
d117 1
a117 1
		0,			/* page_ref */
d119 2
a120 2
		0L,			/* page_bytes */
		0L			/* page_pixels */
d124 1
a124 1
_LOCAL_ int _sgi_cmap_flag;
d126 1
a126 1
_LOCAL_ ColorMap _sgi_cmap;
d128 1
a128 1
static Pixel	rgb_table[MAP_SIZE];
d133 3
a135 3
	((dp = (pp)->red-(qq)->red)     > -MAP_TOL && dp < MAP_TOL ) \
     && ((dp = (pp)->green-(qq)->green) > -MAP_TOL && dp < MAP_TOL ) \
     &&	((dp = (pp)->blue-(qq)->blue)   > -MAP_TOL && dp < MAP_TOL ) \
d140 6
a145 4
register Pixel	*pixelp;
	{	register int	i, ct = rgb_ct;
		register int	best;
		register Pixel	*sp;
d147 1
a147 1
	for( i = 0, sp = rgb_table; i < ct; sp++, i++ )
d149 2
a150 1
		if( Map_Close( pixelp, sp ) )
d153 1
d158 1
a158 1
		rgb_table[i] = *pixelp;
d161 3
a163 3
				(short) pixelp->red,
				(short) pixelp->green,
				(short) pixelp->blue
d168 21
a188 11
	fb_log( "Color table full, using closest match.\n" );
	for( i = 0; i < MAP_SIZE; i++ )
		{	register int	diff, min_diff = 768;
		diff =	Abs( pixelp->red - rgb_table[i].red ) +
			Abs( pixelp->green - rgb_table[i].green ) +
			Abs( pixelp->blue - rgb_table[i].blue );
		if( diff < min_diff )
			{
			min_diff = diff;
			best = i;
			}
d194 1
a194 1
sgi_dopen( ifp, file, width, height )
a201 1
/*
a209 1
*/
d225 1
a225 1
	sgi_cmwrite( ifp, COLORMAP_NULL );
d239 1
a239 1
sgi_dclose( ifp )
d249 1
a249 1
	fb_log( "%d color table entries used.\n", rgb_ct );
d254 1
a254 1
sgi_dreset( ifp )
d267 1
a267 1
sgi_dclear( ifp, pp )
d269 1
a269 1
Pixel	*pp;
d271 2
a272 2
	if ( pp != NULL)
		RGBcolor((short) pp->red, (short)pp->green, (short)pp->blue);
d274 1
a274 1
		RGBcolor( (short) 0, (short) 0, (short) 0);
d281 1
a281 1
sgi_bread( ifp, x, y, pixelp, count )
d284 1
a284 1
register Pixel	*pixelp;
d293 1
a293 1
		{	register short	ypos = (ifp->if_height-1) - y*yzoom;
d317 1
a317 1
			pixelp->red =   (colors[i] % 10 + 1) * 25;
d319 1
a319 1
			pixelp->green = (colors[i] % 10 + 1) * 25;
d321 1
a321 1
			pixelp->blue =  (colors[i] % 10 + 1) * 25;
d325 3
a327 1
				*pixelp = rgb_table[ci];
d329 1
a329 1
				pixelp->red = pixelp->green = pixelp->blue = 0;
d340 1
a340 1
sgi_bwrite( ifp, x, y, pixelp, count )
d343 1
a343 1
register Pixel	*pixelp;
d351 1
a351 1
		{	register short	ypos = (ifp->if_height-1) - y*yzoom;
d371 3
a373 3
					colori =  (pixelp->red/26) + MAP_RESERVED;
					colori += (pixelp->green/26) * 10;
					colori += (pixelp->blue/26) * 100;
d391 3
a393 3
				col =  (pixelp->red/26) + MAP_RESERVED;
				col += (pixelp->green/26) * 10;
				col += (pixelp->blue/26) * 100;
d409 1
a409 1
sgi_viewport_set( ifp, left, top, right, bottom )
d424 1
a424 1
sgi_cmread( ifp, cmp )
d433 3
a435 3
		cmp->cm_red[i] = _sgi_cmap.cm_red[i]<<8;
		cmp->cm_green[i] = _sgi_cmap.cm_green[i]<<8;
		cmp->cm_blue[i] = _sgi_cmap.cm_blue[i]<<8;
d441 1
a441 1
sgi_cmwrite( ifp, cmp )
d449 3
a451 3
			_sgi_cmap.cm_red[i] = i;
			_sgi_cmap.cm_green[i] = i;
			_sgi_cmap.cm_blue[i] = i;
d453 1
a453 1
		_sgi_cmap_flag = FALSE;
d458 3
a460 3
		_sgi_cmap.cm_red[i] = cmp -> cm_red[i]>>8;
		_sgi_cmap.cm_green[i] = cmp-> cm_green[i]>>8; 
		_sgi_cmap.cm_blue[i] = cmp-> cm_blue[i]>>8;
d463 1
a463 1
	_sgi_cmap_flag = TRUE;
d468 1
a468 1
sgi_zoom_set( ifp, x, y )
d485 1
a485 1
sgi_cinit_bitmap( ifp, bitmap )
d496 1
a496 1
sgi_cmemory_addr( ifp, mode, x, y )
d511 1
a511 1
	y = (ifp->if_height-1) - y*yzoom;
@
