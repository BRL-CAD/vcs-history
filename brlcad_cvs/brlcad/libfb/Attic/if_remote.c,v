head	11.10;
access;
symbols
	ansi-20040405-merged:11.6.2.2
	postmerge-20040405-ansi:11.8
	premerge-20040404-ansi:11.7
	postmerge-autoconf:11.7
	autoconf-freeze:11.6.10.2
	premerge-autoconf:11.7
	ansi-20040316-freeze:11.6.2.1
	postmerge-20040315-windows:11.7
	premerge-20040315-windows:11.7
	windows-20040315-freeze:11.6.4.1
	autoconf-20031203:11.6
	autoconf-20031202:11.6
	autoconf-branch:11.6.0.10
	phong-branch:11.6.0.8
	photonmap-branch:11.6.0.6
	rel-6-1-DP:11.6
	windows-branch:11.6.0.4
	rel-6-0-2:11.4
	ansi-branch:11.6.0.2
	rel-6-0-1-branch:11.4.0.2
	hartley-6-0-post:11.5
	hartley-6-0-pre:11.4
	rel-6-0-1:11.4
	rel-6-0:11.4
	rel-5-4:11.2
	offsite-5-3-pre:11.3
	rel-5-3:11.2
	rel-5-2:11.2
	rel-5-1-branch:11.2.0.2
	rel-5-1:11.2
	rel-5-0:11.2
	rel-5-0-beta:11.2
	rel-4-5:11.1
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:9.12
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:6.1
	rel-1-24:5.1
	rel-1-20:4.2
	rel-1-10:4.1;
locks; strict;
comment	@ * @;


11.10
date	2004.05.21.18.07.25;	author morrison;	state dead;
branches;
next	11.9;

11.9
date	2004.05.10.15.30.45;	author erikg;	state Exp;
branches;
next	11.8;

11.8
date	2004.04.05.07.44.42;	author morrison;	state Exp;
branches;
next	11.7;

11.7
date	2004.02.02.17.39.12;	author morrison;	state Exp;
branches;
next	11.6;

11.6
date	2002.08.20.17.07.47;	author jra;	state Exp;
branches
	11.6.2.1
	11.6.4.1
	11.6.10.1;
next	11.5;

11.5
date	2002.08.15.20.55.01;	author hartley;	state Exp;
branches;
next	11.4;

11.4
date	2001.04.20.22.29.14;	author morrison;	state Exp;
branches;
next	11.3;

11.3
date	2000.07.12.01.33.31;	author cjohnson;	state Exp;
branches;
next	11.2;

11.2
date	98.06.27.04.29.17;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.52.59;	author mike;	state Rel4_4;
branches;
next	9.20;

9.20
date	94.12.27.21.55.34;	author mike;	state Exp;
branches;
next	9.19;

9.19
date	94.12.27.21.36.46;	author mike;	state Exp;
branches;
next	9.18;

9.18
date	94.11.04.05.01.33;	author mike;	state Exp;
branches;
next	9.17;

9.17
date	94.08.12.20.25.35;	author gdurf;	state Exp;
branches;
next	9.16;

9.16
date	94.08.09.12.58.12;	author gdurf;	state Exp;
branches;
next	9.15;

9.15
date	93.10.22.20.22.00;	author mike;	state Exp;
branches;
next	9.14;

9.14
date	93.09.25.08.44.01;	author mike;	state Exp;
branches;
next	9.13;

9.13
date	93.07.20.22.24.35;	author mike;	state Exp;
branches;
next	9.12;

9.12
date	91.07.26.22.41.09;	author mike;	state Exp;
branches
	9.12.1.1;
next	9.11;

9.11
date	91.07.18.16.34.06;	author mike;	state Exp;
branches;
next	9.10;

9.10
date	91.06.12.21.13.19;	author mike;	state Exp;
branches;
next	9.9;

9.9
date	91.01.10.22.17.02;	author mike;	state Exp;
branches;
next	9.8;

9.8
date	91.01.08.23.33.41;	author mike;	state Exp;
branches;
next	9.7;

9.7
date	91.01.04.23.01.06;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	91.01.04.22.52.30;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	90.12.19.05.00.28;	author phil;	state Exp;
branches;
next	9.4;

9.4
date	90.12.11.22.54.00;	author phil;	state Exp;
branches;
next	9.3;

9.3
date	89.10.21.01.53.46;	author phil;	state Exp;
branches;
next	9.2;

9.2
date	89.09.01.01.59.43;	author phil;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.48.03;	author mike;	state Rel3_5;
branches;
next	8.5;

8.5
date	89.05.17.20.50.51;	author mike;	state Exp;
branches;
next	8.4;

8.4
date	89.03.04.01.28.54;	author mike;	state Exp;
branches;
next	8.3;

8.3
date	89.03.03.05.54.38;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	89.03.01.00.22.21;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.27.41;	author mike;	state Rel3_0;
branches;
next	7.4;

7.4
date	88.09.09.23.32.50;	author phil;	state Exp;
branches;
next	7.3;

7.3
date	88.05.15.20.35.36;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	88.05.13.21.38.51;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.26.46;	author mike;	state Rel;
branches;
next	6.2;

6.2
date	87.09.16.20.18.51;	author mike;	state Exp;
branches;
next	6.1;

6.1
date	87.07.11.07.51.35;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.21.51.39;	author mike;	state Rel;
branches;
next	4.2;

4.2
date	87.02.12.22.06.39;	author mike;	state Exp;
branches;
next	4.1;

4.1
date	86.12.29.03.42.53;	author mike;	state Rel1;
branches;
next	1.22;

1.22
date	86.12.19.02.01.41;	author phil;	state Exp;
branches;
next	1.21;

1.21
date	86.11.18.10.22.52;	author mike;	state Exp;
branches;
next	1.20;

1.20
date	86.11.13.21.32.40;	author phil;	state Exp;
branches;
next	1.19;

1.19
date	86.10.29.04.51.02;	author phil;	state Exp;
branches;
next	1.18;

1.18
date	86.10.29.01.35.33;	author phil;	state Exp;
branches;
next	1.17;

1.17
date	86.10.29.01.20.12;	author mike;	state Exp;
branches;
next	1.16;

1.16
date	86.10.28.17.53.16;	author phil;	state Exp;
branches;
next	1.15;

1.15
date	86.10.28.15.33.15;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	86.10.25.10.54.31;	author phil;	state Exp;
branches;
next	1.13;

1.13
date	86.10.24.04.51.55;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	86.10.24.04.24.08;	author phil;	state Exp;
branches;
next	1.11;

1.11
date	86.10.24.03.25.59;	author mike;	state Exp;
branches;
next	1.10;

1.10
date	86.10.24.01.59.48;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	86.10.24.01.53.09;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	86.10.24.01.22.50;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	86.10.24.00.58.06;	author phil;	state Exp;
branches;
next	1.6;

1.6
date	86.10.23.20.52.59;	author phil;	state Exp;
branches;
next	1.5;

1.5
date	86.10.22.20.34.07;	author phil;	state Exp;
branches;
next	1.4;

1.4
date	86.10.22.03.41.41;	author phil;	state Exp;
branches;
next	1.3;

1.3
date	86.10.14.22.41.40;	author phil;	state Exp;
branches;
next	1.2;

1.2
date	86.10.10.23.54.29;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	86.10.02.02.18.17;	author mike;	state Exp;
branches;
next	;

9.12.1.1
date	91.10.12.06.32.35;	author cjohnson;	state Exp;
branches;
next	;

11.6.2.1
date	2002.09.19.18.01.19;	author morrison;	state Exp;
branches;
next	11.6.2.2;

11.6.2.2
date	2004.03.17.21.17.02;	author morrison;	state Exp;
branches;
next	;

11.6.4.1
date	2004.03.11.23.42.07;	author morrison;	state Exp;
branches;
next	;

11.6.10.1
date	2004.02.12.19.48.12;	author erikg;	state Exp;
branches;
next	11.6.10.2;

11.6.10.2
date	2004.03.15.14.06.20;	author erikg;	state Exp;
branches;
next	;


desc
@FB to TCP-network remote display server
@


11.10
log
@moved to src/
@
text
@/*
 *		I F _ R E M O T E . C
 *
 *  Remote libfb interface.
 *
 *  Duplicates the functions in libfb via communication
 *  with a remote server (fbserv).
 *
 *  Note that internal errors are returned as -2 and below, because
 *  most remote errors (unpacked by fbgetlong) will be -1
 *  (although they could be anything).
 *
 *  Authors -
 *	Phillip Dykstra
 *	Gary S. Moss
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1986-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/libfb/if_remote.c,v 11.9 2004/05/10 15:30:45 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef HAVE_WRITEV
#include <sys/uio.h>		/* for struct iovec */
#endif

#include <netinet/in.h>		/* for htons(), etc */

#ifdef HAVE_SYS_SOCKET_H
# include <sys/socket.h>
#endif

#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"
#include "externs.h"
#include "pkg.h"
#include "./pkgtypes.h"
#include "fb.h"
#include "./fblocal.h"

#define NET_LONG_LEN	4	/* # bytes to network long */

#define MAX_HOSTNAME	128
#define	PCP(ptr)	((struct pkg_conn *)((ptr)->u1.p))
#define	PCPL(ptr)	((ptr)->u1.p)	/* left hand side version */

/* Package Handlers. */
static void	pkgerror(struct pkg_conn *pcpp, char *buf);	/* error message handler */
static struct pkg_switch pkgswitch[] = {
	{ MSG_ERROR, pkgerror, "Error Message" },
	{ 0, NULL, NULL }
};

_LOCAL_ int	rem_open(register FBIO *ifp, register char *file, int width, int height),
		rem_close(FBIO *ifp),
		rem_clear(FBIO *ifp, unsigned char *bgpp),
		rem_read(register FBIO *ifp, int x, int y, unsigned char *pixelp, int num),
		rem_write(register FBIO *ifp, int x, int y, const unsigned char *pixelp, int num),
		rem_rmap(register FBIO *ifp, register ColorMap *cmap),
		rem_wmap(register FBIO *ifp, register ColorMap *cmap),
		rem_view(FBIO *ifp, int xcenter, int ycenter, int xzoom, int yzoom),
		rem_getview(FBIO *ifp, int *xcenter, int *ycenter, int *xzoom, int *yzoom),
		rem_cursor(FBIO *ifp, int mode, int x, int y),
		rem_getcursor(FBIO *ifp, int *mode, int *x, int *y),
		rem_setcursor(FBIO *ifp, const unsigned char *bits, int xbits, int ybits, int xorig, int yorig),
		rem_readrect(FBIO *ifp, int xmin, int ymin, int width, int height, unsigned char *pp),
		rem_writerect(FBIO *ifp, int xmin, int ymin, int width, int height, const unsigned char *pp),
		rem_bwreadrect(FBIO *ifp, int xmin, int ymin, int width, int height, unsigned char *pp),
		rem_bwwriterect(FBIO *ifp, int xmin, int ymin, int width, int height, const unsigned char *pp),
		rem_poll(FBIO *ifp),
		rem_flush(FBIO *ifp),
		rem_free(FBIO *ifp),
		rem_help(FBIO *ifp);

FBIO remote_interface = {
	0,
	rem_open,
	rem_close,
	rem_clear,
	rem_read,
	rem_write,
	rem_rmap,
	rem_wmap,
	rem_view,
	rem_getview,
	rem_setcursor,
	rem_cursor,
	rem_getcursor,
	rem_readrect,
	rem_writerect,
	rem_bwreadrect,
	rem_bwwriterect,
	rem_poll,
	rem_flush,
	rem_free,
	rem_help,
	"Remote Device Interface",	/* should be filled in	*/
	1024,				/* " */
	1024,				/* " */
	"host:[dev]",
	512,
	512,
	-1,				/* select fd */
	-1,
	1, 1,				/* zoom */
	256, 256,			/* window center */
	0, 0, 0,			/* cursor */
	PIXEL_NULL,
	PIXEL_NULL,
	PIXEL_NULL,
	-1,
	0,
	0L,
	0L,
	0
};

void	pkg_queue(), flush_queue();

/* from getput.c */
extern unsigned short fbgetshort(char *msgp);
extern unsigned long fbgetlong(char *msgp);
extern char *fbputshort(register short unsigned int s, register char *msgp), *fbputlong(register long unsigned int l, register char *msgp);

/* True if the non-null string s is all digits */
static int
numeric(register char *s)
{
	if( s == (char *)0 || *s == 0 )
		return	0;

	while( *s ) {
		if( *s < '0' || *s > '9' )
			return	0;
		s++;
	}

	return	1;
}

/*
 *  Break up a file specification into its component parts.
 *  We try to be infinitely flexible here which makes this complicated.
 *  Handle any of the following:
 *
 *	File			Host		Port		Dev
 *	0			localhost	0		NULL
 *	0:[dev]			localhost	0		dev
 *	:0			localhost	0		NULL
 *	host:[dev]		host		remotefb	dev
 *	host:0			host		0		NULL
 *	host:0:[dev]		host		0		dev
 *
 *  Return -1 on error, else 0.
 */
int
parse_file(char *file, char *host, int *portp, char *device)
           	/* input file spec */
           	/* host part */
            	/* port number */
             	/* device part */
{
	int	port;
	char	prefix[256];
	char	*rest;
	char	*dev;
	char	*colon;

	if( numeric(file) ) {
		/* 0 */
		port = atoi(file);
		strcpy( host, "localhost" );
		dev = "";
		goto done;
	}
	if( (colon = strchr(file, ':')) != NULL ) {
		strncpy( prefix, file, colon-file );
		prefix[colon-file] = '\0';
		rest = colon+1;
		if( numeric(prefix) ) {
			/* 0:[dev] */
			port = atoi(prefix);
			strcpy( host, "localhost" );
			dev = rest;
			goto done;
		} else {
			/* :[dev] or host:[dev] */
			strcpy( host, prefix );
			if( numeric(rest) ) {
				/* :0 or host:0 */
				port = atoi(rest);
				dev = "";
				goto done;
			} else {
				/* check for [host]:0:[dev] */
				if( (colon = strchr(rest, ':')) != NULL ) {
					strncpy( prefix, rest, colon-rest );
					prefix[colon-rest] = '\0';
					if( numeric(prefix) ) {
						port = atoi(prefix);
						dev = colon+1;
						goto done;
					} else {
						/* No port given! */
						dev = rest;
						port = 5558;	/*XXX*/
						goto done;
					}
				} else {
					/* No port given */
					dev = rest;
					port = 5558;		/*XXX*/
					goto done;
				}
			}
		}
	}
	/* bad file spec */
	return	-1;

done:
	/* Default hostname */
	if( strlen(host) == 0 ) {
		strcpy( host, "localhost" );
	}
	/* Magic port number mapping */
	if( port < 0 )
		return	-1;
	if( port < 1024 )
		port += 5559;
	/*
	 * In the spirit of X, let "unix" be an alias for the "localhost".
	 * Eventually this may invoke UNIX Domain PKG (if we can figure
	 * out what to do about socket pathnames).
	 */
	if( strcmp(host,"unix") == 0 )
		strcpy( host, "localhost" );

	/* copy out port and device */
	*portp = port;
	strcpy( device, dev );

	return( 0 );
}

/*
 * Open a connection to the remotefb.
 * We send NET_LONG_LEN bytes of mode, NET_LONG_LEN bytes of size, then the
 *  devname (or NULL if default).
 */
_LOCAL_ int
rem_open(register FBIO *ifp, register char *file, int width, int height)
{
	register int	i;
	struct pkg_conn *pc;
	char	buf[128];
	char	hostname[MAX_HOSTNAME];
	char	portname[MAX_HOSTNAME];
	char	device[MAX_HOSTNAME];
	int	port;

	FB_CK_FBIO(ifp);

	hostname[0] = '\0';
	portname[0] = '\0';
	port = 0;

	if( file == NULL || parse_file(file, hostname, &port, device) < 0 ) {
		/* too wild for our tastes */
		fb_log( "rem_open: bad device name \"%s\"\n",
			file == NULL ? "(null)" : file );
		return	-2;
	}
	/*printf("hostname = \"%s\", port = %d, device = \"%s\"\n", hostname, port, device );*/

	if( port != 5558 ) {
		sprintf(portname, "%d", port);
		if( (pc = pkg_open( hostname, portname, 0, 0, 0, pkgswitch, fb_log )) == PKC_ERROR ) {
			fb_log(	"rem_open: can't connect to fb server on host \"%s\", port \"%s\".\n",
				hostname, portname );
			return	-3;
		}
	} else
	if( (pc = pkg_open( hostname, "remotefb", 0, 0, 0, pkgswitch, fb_log )) == PKC_ERROR &&
	    (pc = pkg_open( hostname, "5558", 0, 0, 0, pkgswitch, fb_log )) == PKC_ERROR ) {
		fb_log(	"rem_open: can't connect to remotefb server on host \"%s\".\n",
			hostname );
		return	-4;
	}
	PCPL(ifp) = (char *)pc;			/* stash in u1 */
	ifp->if_fd = pc->pkc_fd;		/* unused */

#ifdef HAVE_SYS_SOCKET_H
	{
		int	n;
		int	val;
		val = 32767;
		n = setsockopt( pc->pkc_fd, SOL_SOCKET,
			SO_SNDBUF, (char *)&val, sizeof(val) );
		if( n < 0 )  perror("setsockopt: SO_SNDBUF");

		val = 32767;
		n = setsockopt( pc->pkc_fd, SOL_SOCKET,
			SO_RCVBUF, (char *)&val, sizeof(val) );
		if( n < 0 )  perror("setsockopt: SO_RCVBUF");
	}
#endif

	(void)fbputlong( width, &buf[0*NET_LONG_LEN] );
	(void)fbputlong( height, &buf[1*NET_LONG_LEN] );
	(void) strcpy( &buf[2*NET_LONG_LEN], device );
	i = strlen(device)+2*NET_LONG_LEN;
	if( pkg_send( MSG_FBOPEN, buf, i, pc ) != i )
		return	-5;

	/* return code, max_width, max_height, width, height as longs */
	if( pkg_waitfor( MSG_RETURN, buf, sizeof(buf), pc ) < 5*NET_LONG_LEN )
		return	-6;
	ifp->if_max_width = fbgetlong( &buf[1*NET_LONG_LEN] );
	ifp->if_max_height = fbgetlong( &buf[2*NET_LONG_LEN] );
	ifp->if_width = fbgetlong( &buf[3*NET_LONG_LEN] );
	ifp->if_height = fbgetlong( &buf[4*NET_LONG_LEN] );
	if( fbgetlong( &buf[0*NET_LONG_LEN] ) != 0 )
		return	-7;		/* fail */
	return( 0 );			/* OK */
}

_LOCAL_ int
rem_close(FBIO *ifp)
{
	char	buf[NET_LONG_LEN+1];

	/* send a close package to remote */
	if( pkg_send( MSG_FBCLOSE, (char *)0, 0, PCP(ifp) ) < 0 )
		return	-2;
	/*
	 *  When if_4d with a "linger mode" window gets it's fb_close()
	 *  call here, it closes down the network file descriptor,
	 *  and so the PKG connection is terminated at this point.
	 *  If there was no transmission error noted in the pkg_send() above,
	 *  but the pkg_waitfor() here gets an error, clean up and
	 *  declare this a successful close() operation.
	 */
	if( pkg_waitfor( MSG_RETURN, buf, NET_LONG_LEN, PCP(ifp) ) < 1*NET_LONG_LEN )  {
		pkg_close( PCP(ifp) );
		return	0;
	}
	pkg_close( PCP(ifp) );
	return( fbgetlong( &buf[0*NET_LONG_LEN] ) );
}

_LOCAL_ int
rem_free(FBIO *ifp)
{
	char	buf[NET_LONG_LEN+1];

	/* send a free package to remote */
	if( pkg_send( MSG_FBFREE, (char *)0, 0, PCP(ifp) ) < 0 )
		return	-2;
	if( pkg_waitfor( MSG_RETURN, buf, NET_LONG_LEN, PCP(ifp) ) < 1*NET_LONG_LEN )
		return	-3;
	pkg_close( PCP(ifp) );
	return( fbgetlong( &buf[0*NET_LONG_LEN] ) );
}

_LOCAL_ int
rem_clear(FBIO *ifp, unsigned char *bgpp)
{
	char	buf[NET_LONG_LEN+1];

	/* send a clear package to remote */
	if( bgpp == PIXEL_NULL )  {
		buf[0] = buf[1] = buf[2] = 0;	/* black */
	} else {
		buf[0] = (bgpp)[RED];
		buf[1] = (bgpp)[GRN];
		buf[2] = (bgpp)[BLU];
	}
	if( pkg_send( MSG_FBCLEAR, buf, 3, PCP(ifp) ) < 3 )
		return	-2;
	if( pkg_waitfor( MSG_RETURN, buf, NET_LONG_LEN, PCP(ifp) ) < 1*NET_LONG_LEN )
		return	-3;
	return( fbgetlong( buf ) );
}

/*
 *  Send as longs:  x, y, num
 */
_LOCAL_ int
rem_read(register FBIO *ifp, int x, int y, unsigned char *pixelp, int num)
{
	int	ret;
	char	buf[3*NET_LONG_LEN+1];

	if( num <= 0 )
		return(0);
	/* Send Read Command */
	(void)fbputlong( x, &buf[0*NET_LONG_LEN] );
	(void)fbputlong( y, &buf[1*NET_LONG_LEN] );
	(void)fbputlong( num, &buf[2*NET_LONG_LEN] );
	if( pkg_send( MSG_FBREAD, buf, 3*NET_LONG_LEN, PCP(ifp) ) < 3*NET_LONG_LEN )
		return	-2;

	/* Get response;  0 len means failure */
	ret = pkg_waitfor( MSG_RETURN, (char *)pixelp,
		num*sizeof(RGBpixel), PCP(ifp) );
	if( ret <= 0 )  {
		fb_log( "rem_read: read %d at <%d,%d> failed, ret=%d.\n",
			num, x, y, ret );
		return	-3;
	}
	return( ret/sizeof(RGBpixel) );
}

/*
 * As longs, x, y, num
 */
_LOCAL_ int
rem_write(register FBIO *ifp, int x, int y, const unsigned char *pixelp, int num)
{
	int	ret;
	char	buf[3*NET_LONG_LEN+1];

	if( num <= 0 )  return	num;

	/* Send Write Command */
	(void)fbputlong( x, &buf[0*NET_LONG_LEN] );
	(void)fbputlong( y, &buf[1*NET_LONG_LEN] );
	(void)fbputlong( num, &buf[2*NET_LONG_LEN] );
	ret = pkg_2send( MSG_FBWRITE+MSG_NORETURN,
		buf, 3*NET_LONG_LEN,
		(char *)pixelp, num*sizeof(RGBpixel),
		PCP(ifp) );
	ret -= 3*NET_LONG_LEN;
	if( ret < 0 )
		return	-1;	/* Error from libpkg */
	return	ret/sizeof(RGBpixel);
	/* No reading an error return package, sacrificed for speed. */
}

/*
 *			R E M _ R E A D R E C T
 */
_LOCAL_ int
rem_readrect(FBIO *ifp, int xmin, int ymin, int width, int height, unsigned char *pp)
{
	int	num;
	int	ret;
	char	buf[4*NET_LONG_LEN+1];

	num = width*height;
	if( num <= 0 )
		return(0);
	/* Send Read Command */
	(void)fbputlong( xmin, &buf[0*NET_LONG_LEN] );
	(void)fbputlong( ymin, &buf[1*NET_LONG_LEN] );
	(void)fbputlong( width, &buf[2*NET_LONG_LEN] );
	(void)fbputlong( height, &buf[3*NET_LONG_LEN] );
	if( pkg_send( MSG_FBREADRECT, buf, 4*NET_LONG_LEN, PCP(ifp) ) < 4*NET_LONG_LEN )
		return	-2;

	/* Get response;  0 len means failure */
	ret = pkg_waitfor( MSG_RETURN, (char *)pp,
			num*sizeof(RGBpixel), PCP(ifp) );
	if( ret <= 0 )  {
		fb_log( "rem_rectread: read %d at <%d,%d> failed, ret=%d.\n",
			num, xmin, ymin, ret );
		return	-3;
	}
	return( ret/sizeof(RGBpixel) );
}

/*
 *			R E M _ W R I T E R E C T
 */
_LOCAL_ int
rem_writerect(FBIO *ifp, int xmin, int ymin, int width, int height, const unsigned char *pp)
{
	int	num;
	int	ret;
	char	buf[4*NET_LONG_LEN+1];

	num = width*height;
	if( num <= 0 )
		return(0);

	/* Send Write Command */
	(void)fbputlong( xmin, &buf[0*NET_LONG_LEN] );
	(void)fbputlong( ymin, &buf[1*NET_LONG_LEN] );
	(void)fbputlong( width, &buf[2*NET_LONG_LEN] );
	(void)fbputlong( height, &buf[3*NET_LONG_LEN] );
	ret = pkg_2send( MSG_FBWRITERECT+MSG_NORETURN,
		buf, 4*NET_LONG_LEN,
		(char *)pp, num*sizeof(RGBpixel),
		PCP(ifp) );
	ret -= 4*NET_LONG_LEN;
	if( ret < 0 )
		return	-4;	/* Error from libpkg */
	return	ret/sizeof(RGBpixel);
	/* No reading an error return package, sacrificed for speed. */
}

/*
 *			R E M _ B W R E A D R E C T
 *
 *  Issue:  Determining if other end has support for this yet.
 */
_LOCAL_ int
rem_bwreadrect(FBIO *ifp, int xmin, int ymin, int width, int height, unsigned char *pp)
{
	int	num;
	int	ret;
	char	buf[4*NET_LONG_LEN+1];

	num = width*height;
	if( num <= 0 )
		return(0);
	/* Send Read Command */
	(void)fbputlong( xmin, &buf[0*NET_LONG_LEN] );
	(void)fbputlong( ymin, &buf[1*NET_LONG_LEN] );
	(void)fbputlong( width, &buf[2*NET_LONG_LEN] );
	(void)fbputlong( height, &buf[3*NET_LONG_LEN] );
	if( pkg_send( MSG_FBBWREADRECT, buf, 4*NET_LONG_LEN, PCP(ifp) ) < 4*NET_LONG_LEN )
		return	-2;

	/* Get response;  0 len means failure */
	ret = pkg_waitfor( MSG_RETURN, (char *)pp, num, PCP(ifp) );
	if( ret <= 0 )  {
		fb_log( "rem_bwrectread: read %d at <%d,%d> failed, ret=%d.\n",
			num, xmin, ymin, ret );
		return	-3;
	}
	return ret;
}

/*
 *			R E M _ B W W R I T E R E C T
 */
_LOCAL_ int
rem_bwwriterect(FBIO *ifp, int xmin, int ymin, int width, int height, const unsigned char *pp)
{
	int	num;
	int	ret;
	char	buf[4*NET_LONG_LEN+1];

	num = width*height;
	if( num <= 0 )
		return(0);

	/* Send Write Command */
	(void)fbputlong( xmin, &buf[0*NET_LONG_LEN] );
	(void)fbputlong( ymin, &buf[1*NET_LONG_LEN] );
	(void)fbputlong( width, &buf[2*NET_LONG_LEN] );
	(void)fbputlong( height, &buf[3*NET_LONG_LEN] );
	ret = pkg_2send( MSG_FBBWWRITERECT+MSG_NORETURN,
		buf, 4*NET_LONG_LEN,
		(char *)pp, num,
		PCP(ifp) );
	ret -= 4*NET_LONG_LEN;
	if( ret < 0 )
		return	-4;	/* Error from libpkg */
	return	ret;
	/* No reading an error return package, sacrificed for speed. */
}

/*
 *  32-bit longs: mode, x, y
 */
_LOCAL_ int
rem_cursor(FBIO *ifp, int mode, int x, int y)
{
	char	buf[3*NET_LONG_LEN+1];

	/* Send Command */
	(void)fbputlong( mode, &buf[0*NET_LONG_LEN] );
	(void)fbputlong( x, &buf[1*NET_LONG_LEN] );
	(void)fbputlong( y, &buf[2*NET_LONG_LEN] );
	if( pkg_send( MSG_FBCURSOR, buf, 3*NET_LONG_LEN, PCP(ifp) ) < 3*NET_LONG_LEN )
		return	-2;
	if( pkg_waitfor( MSG_RETURN, buf, NET_LONG_LEN, PCP(ifp) ) < 1*NET_LONG_LEN )
		return	-3;
	return( fbgetlong( buf ) );
}

/*
 */
_LOCAL_ int
rem_getcursor(FBIO *ifp, int *mode, int *x, int *y)
{
	char	buf[4*NET_LONG_LEN+1];

	/* Send Command */
	if( pkg_send( MSG_FBGETCURSOR, (char *)0, 0, PCP(ifp) ) < 0 )
		return	-2;

	/* return code, xcenter, ycenter, xzoom, yzoom as longs */
	if( pkg_waitfor( MSG_RETURN, buf, sizeof(buf), PCP(ifp) ) < 4*NET_LONG_LEN )
		return	-3;
	*mode = fbgetlong( &buf[1*NET_LONG_LEN] );
	*x = fbgetlong( &buf[2*NET_LONG_LEN] );
	*y = fbgetlong( &buf[3*NET_LONG_LEN] );
	if( fbgetlong( &buf[0*NET_LONG_LEN] ) != 0 )
		return	-4;		/* fail */
	return( 0 );			/* OK */
}

/*
 *			R E M _ S E T C U R S O R
 *
 *  Program the "shape" of the cursor.
 *
 *  bits[] has xbits*ybits bits in it, rounded up to next largest byte.
 *
 *  Do not confuse this routine with the old fb_scursor() call.
 */
_LOCAL_ int
rem_setcursor(FBIO *ifp, const unsigned char *bits, int xbits, int ybits, int xorig, int yorig)
{
	char	buf[4*NET_LONG_LEN+1];
	int	ret;

	(void)fbputlong( xbits, &buf[0*NET_LONG_LEN] );
	(void)fbputlong( ybits, &buf[1*NET_LONG_LEN] );
	(void)fbputlong( xorig, &buf[2*NET_LONG_LEN] );
	(void)fbputlong( yorig, &buf[3*NET_LONG_LEN] );

	ret = pkg_2send( MSG_FBSETCURSOR+MSG_NORETURN,
		buf, 4*NET_LONG_LEN,
		(char *)bits, (xbits*ybits+7)>>3,
		PCP(ifp) );
	ret -= 4*NET_LONG_LEN;
	if( ret < 0 )
		return	-1;	/* Error from libpkg */

#if 0
	if( pkg_waitfor( MSG_RETURN, buf, NET_LONG_LEN, PCP(ifp) ) < 1*NET_LONG_LEN )
		return	-2;
	return( fbgetlong( buf ) );
#else
	/* Since this call got somehow overlooked until Release 4.3,
	 * older 'fbserv' programs won't have support for this request.
	 * Rather than dooming LGT users to endless frustration,
	 * simply launch off the request and tell our caller that all is well.
	 * LGT never actually checks the return code of this routine anyway.
	 */
	return 0;
#endif
}

/*
 */
_LOCAL_ int
rem_view(FBIO *ifp, int xcenter, int ycenter, int xzoom, int yzoom)
{
	char	buf[4*NET_LONG_LEN+1];

	/* Send Command */
	(void)fbputlong( xcenter, &buf[0*NET_LONG_LEN] );
	(void)fbputlong( ycenter, &buf[1*NET_LONG_LEN] );
	(void)fbputlong( xzoom, &buf[2*NET_LONG_LEN] );
	(void)fbputlong( yzoom, &buf[3*NET_LONG_LEN] );
	if( pkg_send( MSG_FBVIEW, buf, 4*NET_LONG_LEN, PCP(ifp) ) < 4*NET_LONG_LEN )
		return	-2;
	if( pkg_waitfor( MSG_RETURN, buf, NET_LONG_LEN, PCP(ifp) ) < 1*NET_LONG_LEN )
		return	-3;
	return( fbgetlong( buf ) );
}

/*
 */
_LOCAL_ int
rem_getview(FBIO *ifp, int *xcenter, int *ycenter, int *xzoom, int *yzoom)
{
	char	buf[5*NET_LONG_LEN+1];

	/* Send Command */
	if( pkg_send( MSG_FBGETVIEW, (char *)0, 0, PCP(ifp) ) < 0 )
		return	-2;

	/* return code, xcenter, ycenter, xzoom, yzoom as longs */
	if( pkg_waitfor( MSG_RETURN, buf, sizeof(buf), PCP(ifp) ) < 5*NET_LONG_LEN )
		return	-3;
	*xcenter = fbgetlong( &buf[1*NET_LONG_LEN] );
	*ycenter = fbgetlong( &buf[2*NET_LONG_LEN] );
	*xzoom = fbgetlong( &buf[3*NET_LONG_LEN] );
	*yzoom = fbgetlong( &buf[4*NET_LONG_LEN] );
	if( fbgetlong( &buf[0*NET_LONG_LEN] ) != 0 )
		return	-4;		/* fail */
	return( 0 );			/* OK */
}

#define REM_CMAP_BYTES	(256*3*2)

_LOCAL_ int
rem_rmap(register FBIO *ifp, register ColorMap *cmap)
{
	register int	i;
	char	buf[NET_LONG_LEN+1];
	char	cm[REM_CMAP_BYTES+4];

	if( pkg_send( MSG_FBRMAP, (char *)0, 0, PCP(ifp) ) < 0 )
		return	-2;
	if( pkg_waitfor( MSG_DATA, cm, REM_CMAP_BYTES, PCP(ifp) ) < REM_CMAP_BYTES )
		return	-3;
	for( i = 0; i < 256; i++ ) {
		cmap->cm_red[i] = fbgetshort( cm+2*(0+i) );
		cmap->cm_green[i] = fbgetshort( cm+2*(256+i) );
		cmap->cm_blue[i] = fbgetshort( cm+2*(512+i) );
	}
	if( pkg_waitfor( MSG_RETURN, buf, NET_LONG_LEN, PCP(ifp) ) < 1*NET_LONG_LEN )
		return	-4;
	return( fbgetlong( &buf[0*NET_LONG_LEN] ) );
}

_LOCAL_ int
rem_wmap(register FBIO *ifp, register ColorMap *cmap)
{
	register int	i;
	char	buf[NET_LONG_LEN+1];
	char	cm[REM_CMAP_BYTES+4];

	if( cmap == COLORMAP_NULL ) {
		if( pkg_send( MSG_FBWMAP, (char *)0, 0, PCP(ifp) ) < 0 )
			return	-2;
	} else {
		for( i = 0; i < 256; i++ ) {
			(void)fbputshort( cmap->cm_red[i], cm+2*(0+i) );
			(void)fbputshort( cmap->cm_green[i], cm+2*(256+i) );
			(void)fbputshort( cmap->cm_blue[i], cm+2*(512+i) );
		}
		if( pkg_send( MSG_FBWMAP, cm, REM_CMAP_BYTES, PCP(ifp) ) < REM_CMAP_BYTES )
			return	-3;
	}
	if( pkg_waitfor( MSG_RETURN, buf, NET_LONG_LEN, PCP(ifp) ) < 1*NET_LONG_LEN )
		return	-4;
	return( fbgetlong( &buf[0*NET_LONG_LEN] ) );
}

/*
 *  Poll tells the remote end to handle input events.
 *  There is no need to wait for a reply (FLUSH can be
 *  used for synchronization.
 *  In fact, we may not want to send polls at all....
 */
_LOCAL_ int
rem_poll(FBIO *ifp)
{
	/* send a poll package to remote */
	if( pkg_send( MSG_FBPOLL, (char *)0, 0, PCP(ifp) ) < 0 )
		return	-1;
	return( 0 );
}

_LOCAL_ int
rem_flush(FBIO *ifp)
{
	char	buf[NET_LONG_LEN+1];

	/* send a flush package to remote */
	if( pkg_send( MSG_FBFLUSH, (char *)0, 0, PCP(ifp) ) < 0 )
		return	-2;
	if( pkg_waitfor( MSG_RETURN, buf, NET_LONG_LEN, PCP(ifp) ) < 1*NET_LONG_LEN )
		return	-3;
	return( fbgetlong( &buf[0*NET_LONG_LEN] ) );
}

/*
 *			R E M _ H E L P
 */
_LOCAL_ int
rem_help(FBIO *ifp)
{
	char	buf[1*NET_LONG_LEN+1];

	fb_log( "Remote Interface:\n" );

	/* Send Command */
	(void)fbputlong( 0L, &buf[0*NET_LONG_LEN] );
	if( pkg_send( MSG_FBHELP, buf, 1*NET_LONG_LEN, PCP(ifp) ) < 1*NET_LONG_LEN )
		return	-2;
	if( pkg_waitfor( MSG_RETURN, buf, NET_LONG_LEN, PCP(ifp) ) < 1*NET_LONG_LEN )
		return	-3;
	return( fbgetlong( &buf[0*NET_LONG_LEN] ) );
}

/*
 *			P K G E R R O R
 *
 *  This is where we come on asynchronous error or log messages.
 *  We are counting on the remote machine now to prefix his own
 *  name to messages, so we don't touch them ourselves.
 */
static void
pkgerror(struct pkg_conn *pcpp, char *buf)
{
	fb_log( "%s", buf );
	free(buf);
}
@


11.9
log
@change conf.h to a wrapped config.h
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/libfb/if_remote.c,v 11.8 2004/04/05 07:44:42 morrison Exp $ (BRL)";
@


11.8
log
@merge of ansi-6-0-branch into HEAD
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d30 5
a34 1
#include "conf.h"
@


11.7
log
@update copyright to include span through 2003
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_remote.c,v 11.6 2002/08/20 17:07:47 jra Exp $ (BRL)";
d63 1
a63 1
static void	pkgerror();	/* error message handler */
d69 20
a88 20
_LOCAL_ int	rem_open(),
		rem_close(),
		rem_clear(),
		rem_read(),
		rem_write(),
		rem_rmap(),
		rem_wmap(),
		rem_view(),
		rem_getview(),
		rem_cursor(),
		rem_getcursor(),
		rem_setcursor(),
		rem_readrect(),
		rem_writerect(),
		rem_bwreadrect(),
		rem_bwwriterect(),
		rem_poll(),
		rem_flush(),
		rem_free(),
		rem_help();
d136 3
a138 3
extern unsigned short fbgetshort();
extern unsigned long fbgetlong();
extern char *fbputshort(), *fbputlong();
d142 1
a142 2
numeric( s )
register char *s;
d172 5
a176 5
parse_file( file, host, portp, device )
char *file;	/* input file spec */
char *host;	/* host part */
int  *portp;	/* port number */
char *device;	/* device part */
d267 1
a267 4
rem_open( ifp, file, width, height )
register FBIO	*ifp;
register char	*file;
int	width, height;
d344 1
a344 2
rem_close( ifp )
FBIO	*ifp;
d368 1
a368 2
rem_free( ifp )
FBIO	*ifp;
d382 1
a382 3
rem_clear( ifp, bgpp )
FBIO	*ifp;
unsigned char	*bgpp;
d405 1
a405 5
rem_read( ifp, x, y, pixelp, num )
register FBIO	*ifp;
int		x, y;
unsigned char	*pixelp;
int		num;
d434 1
a434 5
rem_write( ifp, x, y, pixelp, num )
register FBIO	*ifp;
int		x, y;
const unsigned char	*pixelp;
int		num;
d460 1
a460 5
rem_readrect( ifp, xmin, ymin, width, height, pp )
FBIO	*ifp;
int	xmin, ymin;
int	width, height;
unsigned char	*pp;
d492 1
a492 5
rem_writerect( ifp, xmin, ymin, width, height, pp )
FBIO	*ifp;
int	xmin, ymin;
int	width, height;
const unsigned char	*pp;
d524 1
a524 5
rem_bwreadrect( ifp, xmin, ymin, width, height, pp )
FBIO	*ifp;
int	xmin, ymin;
int	width, height;
unsigned char	*pp;
d555 1
a555 5
rem_bwwriterect( ifp, xmin, ymin, width, height, pp )
FBIO	*ifp;
int	xmin, ymin;
int	width, height;
const unsigned char	*pp;
d585 1
a585 4
rem_cursor( ifp, mode, x, y )
FBIO	*ifp;
int	mode;
int	x, y;
d603 1
a603 4
rem_getcursor( ifp, mode, x, y )
FBIO	*ifp;
int	*mode;
int	*x, *y;
d632 1
a632 5
rem_setcursor( ifp, bits, xbits, ybits, xorig, yorig )
FBIO	*ifp;
const unsigned char	*bits;
int		xbits, ybits;
int		xorig, yorig;
d668 1
a668 4
rem_view( ifp, xcenter, ycenter, xzoom, yzoom )
FBIO	*ifp;
int	xcenter, ycenter;
int	xzoom, yzoom;
d687 1
a687 4
rem_getview( ifp, xcenter, ycenter, xzoom, yzoom )
FBIO	*ifp;
int	*xcenter, *ycenter;
int	*xzoom, *yzoom;
d710 1
a710 3
rem_rmap( ifp, cmap )
register FBIO		*ifp;
register ColorMap	*cmap;
d731 1
a731 3
rem_wmap( ifp, cmap )
register FBIO		*ifp;
register ColorMap	*cmap;
d761 1
a761 2
rem_poll( ifp )
FBIO	*ifp;
d770 1
a770 2
rem_flush( ifp )
FBIO	*ifp;
d786 1
a786 2
rem_help( ifp )
FBIO	*ifp;
d809 1
a809 3
pkgerror(pcpp, buf)
struct pkg_conn *pcpp;
char *buf;
@


11.6
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d23 1
a23 1
 *	This software is Copyright (C) 1986 by the United States Army.
d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_remote.c,v 11.4 2001/04/20 22:29:14 morrison Exp $ (BRL)";
@


11.6.4.1
log
@sync to HEAD...
@
text
@d23 1
a23 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/libfb/if_remote.c,v 11.7 2004/02/02 17:39:12 morrison Exp $ (BRL)";
@


11.6.10.1
log
@merge from HEAD
@
text
@d23 1
a23 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_remote.c,v 11.7 2004/02/02 17:39:12 morrison Exp $ (BRL)";
@


11.6.10.2
log
@merge from head
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_remote.c,v 11.6.10.1 2004/02/12 19:48:12 erikg Exp $ (BRL)";
@


11.6.2.1
log
@Initial ANSIfication
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_remote.c,v 11.6 2002/08/20 17:07:47 jra Exp $ (BRL)";
d63 1
a63 1
static void	pkgerror(struct pkg_conn *pcpp, char *buf);	/* error message handler */
d69 20
a88 20
_LOCAL_ int	rem_open(register FBIO *ifp, register char *file, int width, int height),
		rem_close(FBIO *ifp),
		rem_clear(FBIO *ifp, unsigned char *bgpp),
		rem_read(register FBIO *ifp, int x, int y, unsigned char *pixelp, int num),
		rem_write(register FBIO *ifp, int x, int y, const unsigned char *pixelp, int num),
		rem_rmap(register FBIO *ifp, register ColorMap *cmap),
		rem_wmap(register FBIO *ifp, register ColorMap *cmap),
		rem_view(FBIO *ifp, int xcenter, int ycenter, int xzoom, int yzoom),
		rem_getview(FBIO *ifp, int *xcenter, int *ycenter, int *xzoom, int *yzoom),
		rem_cursor(FBIO *ifp, int mode, int x, int y),
		rem_getcursor(FBIO *ifp, int *mode, int *x, int *y),
		rem_setcursor(FBIO *ifp, const unsigned char *bits, int xbits, int ybits, int xorig, int yorig),
		rem_readrect(FBIO *ifp, int xmin, int ymin, int width, int height, unsigned char *pp),
		rem_writerect(FBIO *ifp, int xmin, int ymin, int width, int height, const unsigned char *pp),
		rem_bwreadrect(FBIO *ifp, int xmin, int ymin, int width, int height, unsigned char *pp),
		rem_bwwriterect(FBIO *ifp, int xmin, int ymin, int width, int height, const unsigned char *pp),
		rem_poll(FBIO *ifp),
		rem_flush(FBIO *ifp),
		rem_free(FBIO *ifp),
		rem_help(FBIO *ifp);
d136 3
a138 3
extern unsigned short fbgetshort(char *msgp);
extern unsigned long fbgetlong(char *msgp);
extern char *fbputshort(register short unsigned int s, register char *msgp), *fbputlong(register long unsigned int l, register char *msgp);
d142 2
a143 1
numeric(register char *s)
d173 5
a177 5
parse_file(char *file, char *host, int *portp, char *device)
           	/* input file spec */
           	/* host part */
            	/* port number */
             	/* device part */
d268 4
a271 1
rem_open(register FBIO *ifp, register char *file, int width, int height)
d348 2
a349 1
rem_close(FBIO *ifp)
d373 2
a374 1
rem_free(FBIO *ifp)
d388 3
a390 1
rem_clear(FBIO *ifp, unsigned char *bgpp)
d413 5
a417 1
rem_read(register FBIO *ifp, int x, int y, unsigned char *pixelp, int num)
d446 5
a450 1
rem_write(register FBIO *ifp, int x, int y, const unsigned char *pixelp, int num)
d476 5
a480 1
rem_readrect(FBIO *ifp, int xmin, int ymin, int width, int height, unsigned char *pp)
d512 5
a516 1
rem_writerect(FBIO *ifp, int xmin, int ymin, int width, int height, const unsigned char *pp)
d548 5
a552 1
rem_bwreadrect(FBIO *ifp, int xmin, int ymin, int width, int height, unsigned char *pp)
d583 5
a587 1
rem_bwwriterect(FBIO *ifp, int xmin, int ymin, int width, int height, const unsigned char *pp)
d617 4
a620 1
rem_cursor(FBIO *ifp, int mode, int x, int y)
d638 4
a641 1
rem_getcursor(FBIO *ifp, int *mode, int *x, int *y)
d670 5
a674 1
rem_setcursor(FBIO *ifp, const unsigned char *bits, int xbits, int ybits, int xorig, int yorig)
d710 4
a713 1
rem_view(FBIO *ifp, int xcenter, int ycenter, int xzoom, int yzoom)
d732 4
a735 1
rem_getview(FBIO *ifp, int *xcenter, int *ycenter, int *xzoom, int *yzoom)
d758 3
a760 1
rem_rmap(register FBIO *ifp, register ColorMap *cmap)
d781 3
a783 1
rem_wmap(register FBIO *ifp, register ColorMap *cmap)
d813 2
a814 1
rem_poll(FBIO *ifp)
d823 2
a824 1
rem_flush(FBIO *ifp)
d840 2
a841 1
rem_help(FBIO *ifp)
d864 3
a866 1
pkgerror(struct pkg_conn *pcpp, char *buf)
@


11.6.2.2
log
@sync branch with HEAD
@
text
@d23 1
a23 1
 *	This software is Copyright (C) 1986-2004 by the United States Army.
d27 1
a27 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.5
log
@Converted from K&R to ANSI C - RFH
@
text
@d63 1
a63 1
static void	pkgerror(struct pkg_conn *pcpp, char *buf);	/* error message handler */
d69 20
a88 20
_LOCAL_ int	rem_open(register FBIO *ifp, register char *file, int width, int height),
		rem_close(FBIO *ifp),
		rem_clear(FBIO *ifp, unsigned char *bgpp),
		rem_read(register FBIO *ifp, int x, int y, unsigned char *pixelp, int num),
		rem_write(register FBIO *ifp, int x, int y, const unsigned char *pixelp, int num),
		rem_rmap(register FBIO *ifp, register ColorMap *cmap),
		rem_wmap(register FBIO *ifp, register ColorMap *cmap),
		rem_view(FBIO *ifp, int xcenter, int ycenter, int xzoom, int yzoom),
		rem_getview(FBIO *ifp, int *xcenter, int *ycenter, int *xzoom, int *yzoom),
		rem_cursor(FBIO *ifp, int mode, int x, int y),
		rem_getcursor(FBIO *ifp, int *mode, int *x, int *y),
		rem_setcursor(FBIO *ifp, const unsigned char *bits, int xbits, int ybits, int xorig, int yorig),
		rem_readrect(FBIO *ifp, int xmin, int ymin, int width, int height, unsigned char *pp),
		rem_writerect(FBIO *ifp, int xmin, int ymin, int width, int height, const unsigned char *pp),
		rem_bwreadrect(FBIO *ifp, int xmin, int ymin, int width, int height, unsigned char *pp),
		rem_bwwriterect(FBIO *ifp, int xmin, int ymin, int width, int height, const unsigned char *pp),
		rem_poll(FBIO *ifp),
		rem_flush(FBIO *ifp),
		rem_free(FBIO *ifp),
		rem_help(FBIO *ifp);
d136 3
a138 3
extern unsigned short fbgetshort(char *msgp);
extern unsigned long fbgetlong(char *msgp);
extern char *fbputshort(register short unsigned int s, register char *msgp), *fbputlong(register long unsigned int l, register char *msgp);
d142 2
a143 1
numeric(register char *s)
d173 5
a177 5
parse_file(char *file, char *host, int *portp, char *device)
           	/* input file spec */
           	/* host part */
            	/* port number */
             	/* device part */
d268 4
a271 1
rem_open(register FBIO *ifp, register char *file, int width, int height)
d348 2
a349 1
rem_close(FBIO *ifp)
d373 2
a374 1
rem_free(FBIO *ifp)
d388 3
a390 1
rem_clear(FBIO *ifp, unsigned char *bgpp)
d413 5
a417 1
rem_read(register FBIO *ifp, int x, int y, unsigned char *pixelp, int num)
d446 5
a450 1
rem_write(register FBIO *ifp, int x, int y, const unsigned char *pixelp, int num)
d476 5
a480 1
rem_readrect(FBIO *ifp, int xmin, int ymin, int width, int height, unsigned char *pp)
d512 5
a516 1
rem_writerect(FBIO *ifp, int xmin, int ymin, int width, int height, const unsigned char *pp)
d548 5
a552 1
rem_bwreadrect(FBIO *ifp, int xmin, int ymin, int width, int height, unsigned char *pp)
d583 5
a587 1
rem_bwwriterect(FBIO *ifp, int xmin, int ymin, int width, int height, const unsigned char *pp)
d617 4
a620 1
rem_cursor(FBIO *ifp, int mode, int x, int y)
d638 4
a641 1
rem_getcursor(FBIO *ifp, int *mode, int *x, int *y)
d670 5
a674 1
rem_setcursor(FBIO *ifp, const unsigned char *bits, int xbits, int ybits, int xorig, int yorig)
d710 4
a713 1
rem_view(FBIO *ifp, int xcenter, int ycenter, int xzoom, int yzoom)
d732 4
a735 1
rem_getview(FBIO *ifp, int *xcenter, int *ycenter, int *xzoom, int *yzoom)
d758 3
a760 1
rem_rmap(register FBIO *ifp, register ColorMap *cmap)
d781 3
a783 1
rem_wmap(register FBIO *ifp, register ColorMap *cmap)
d813 2
a814 1
rem_poll(FBIO *ifp)
d823 2
a824 1
rem_flush(FBIO *ifp)
d840 2
a841 1
rem_help(FBIO *ifp)
d864 3
a866 1
pkgerror(struct pkg_conn *pcpp, char *buf)
@


11.4
log
@CONST to const
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_remote.c,v 11.3 2000/07/12 01:33:31 cjohnson Exp $ (BRL)";
d63 1
a63 1
static void	pkgerror();	/* error message handler */
d69 20
a88 20
_LOCAL_ int	rem_open(),
		rem_close(),
		rem_clear(),
		rem_read(),
		rem_write(),
		rem_rmap(),
		rem_wmap(),
		rem_view(),
		rem_getview(),
		rem_cursor(),
		rem_getcursor(),
		rem_setcursor(),
		rem_readrect(),
		rem_writerect(),
		rem_bwreadrect(),
		rem_bwwriterect(),
		rem_poll(),
		rem_flush(),
		rem_free(),
		rem_help();
d136 3
a138 3
extern unsigned short fbgetshort();
extern unsigned long fbgetlong();
extern char *fbputshort(), *fbputlong();
d142 1
a142 2
numeric( s )
register char *s;
d172 5
a176 5
parse_file( file, host, portp, device )
char *file;	/* input file spec */
char *host;	/* host part */
int  *portp;	/* port number */
char *device;	/* device part */
d267 1
a267 4
rem_open( ifp, file, width, height )
register FBIO	*ifp;
register char	*file;
int	width, height;
d344 1
a344 2
rem_close( ifp )
FBIO	*ifp;
d368 1
a368 2
rem_free( ifp )
FBIO	*ifp;
d382 1
a382 3
rem_clear( ifp, bgpp )
FBIO	*ifp;
unsigned char	*bgpp;
d405 1
a405 5
rem_read( ifp, x, y, pixelp, num )
register FBIO	*ifp;
int		x, y;
unsigned char	*pixelp;
int		num;
d434 1
a434 5
rem_write( ifp, x, y, pixelp, num )
register FBIO	*ifp;
int		x, y;
const unsigned char	*pixelp;
int		num;
d460 1
a460 5
rem_readrect( ifp, xmin, ymin, width, height, pp )
FBIO	*ifp;
int	xmin, ymin;
int	width, height;
unsigned char	*pp;
d492 1
a492 5
rem_writerect( ifp, xmin, ymin, width, height, pp )
FBIO	*ifp;
int	xmin, ymin;
int	width, height;
const unsigned char	*pp;
d524 1
a524 5
rem_bwreadrect( ifp, xmin, ymin, width, height, pp )
FBIO	*ifp;
int	xmin, ymin;
int	width, height;
unsigned char	*pp;
d555 1
a555 5
rem_bwwriterect( ifp, xmin, ymin, width, height, pp )
FBIO	*ifp;
int	xmin, ymin;
int	width, height;
const unsigned char	*pp;
d585 1
a585 4
rem_cursor( ifp, mode, x, y )
FBIO	*ifp;
int	mode;
int	x, y;
d603 1
a603 4
rem_getcursor( ifp, mode, x, y )
FBIO	*ifp;
int	*mode;
int	*x, *y;
d632 1
a632 5
rem_setcursor( ifp, bits, xbits, ybits, xorig, yorig )
FBIO	*ifp;
const unsigned char	*bits;
int		xbits, ybits;
int		xorig, yorig;
d668 1
a668 4
rem_view( ifp, xcenter, ycenter, xzoom, yzoom )
FBIO	*ifp;
int	xcenter, ycenter;
int	xzoom, yzoom;
d687 1
a687 4
rem_getview( ifp, xcenter, ycenter, xzoom, yzoom )
FBIO	*ifp;
int	*xcenter, *ycenter;
int	*xzoom, *yzoom;
d710 1
a710 3
rem_rmap( ifp, cmap )
register FBIO		*ifp;
register ColorMap	*cmap;
d731 1
a731 3
rem_wmap( ifp, cmap )
register FBIO		*ifp;
register ColorMap	*cmap;
d761 1
a761 2
rem_poll( ifp )
FBIO	*ifp;
d770 1
a770 2
rem_flush( ifp )
FBIO	*ifp;
d786 1
a786 2
rem_help( ifp )
FBIO	*ifp;
d809 1
a809 3
pkgerror(pcpp, buf)
struct pkg_conn *pcpp;
char *buf;
@


11.3
log
@LINT from gcc -Wall.  Including some mods to h/pkg.h
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_remote.c,v 11.2 1998/06/27 04:29:17 mike Exp $ (BRL)";
d449 1
a449 1
CONST unsigned char	*pixelp;
d516 1
a516 1
CONST unsigned char	*pp;
d587 1
a587 1
CONST unsigned char	*pp;
d672 1
a672 1
CONST unsigned char	*bits;
@


11.2
log
@Additions to LIBFB interface and remote framebuffer protocol to
read and write monochrome rectangles.
Particularly important for sending thermal images at high speed.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_remote.c,v 11.1 1995/01/04 09:52:59 mike Rel4_4 $ (BRL)";
d172 1
@


11.1
log
@Release_4.4
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_remote.c,v 9.20 94/12/27 21:55:34 mike Exp $ (BRL)";
d83 2
d106 2
d538 71
@


9.20
log
@Oops, calculated cursor array size wrong.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_remote.c,v 9.19 94/12/27 21:36:46 mike Exp $ (BRL)";
@


9.19
log
@Added support for rem_setcursor().
Bug #65.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_remote.c,v 9.18 94/11/04 05:01:33 mike Exp Locker: mike $ (BRL)";
d610 1
a610 1
		(char *)bits, (xbits+ybits+7)>>3,
@


9.18
log
@Irix 6
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_remote.c,v 9.17 94/08/12 20:25:35 gdurf Exp Locker: mike $ (BRL)";
d585 7
d600 2
d603 26
a628 3
	/* XXX For some reason, we don't implement this over the net? */
	fb_log("rem_setcursor() unimplemented\n");
	return -1;
@


9.17
log
@Added includes
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_remote.c,v 9.16 1994/08/09 12:58:12 gdurf Exp gdurf $ (BRL)";
a77 2
		rem_window(),		/* OLD */
		rem_zoom(),		/* OLD */
a129 1
static	struct pkg_conn *pcp;
a644 36
}

/*
 *  OLD XXX
 */
_LOCAL_ int
rem_window( ifp, x, y )
FBIO	*ifp;
int	x, y;
{
	char	buf[3*NET_LONG_LEN+1];
	
	/* Send Command */
	(void)fbputlong( x, &buf[0*NET_LONG_LEN] );
	(void)fbputlong( y, &buf[1*NET_LONG_LEN] );
	pkg_send( MSG_FBWINDOW, buf, 2*NET_LONG_LEN, PCP(ifp) );
	pkg_waitfor( MSG_RETURN, buf, NET_LONG_LEN, PCP(ifp) );
	return( fbgetlong( buf ) );
}

/*
 *  OLD XXX
 */
_LOCAL_ int
rem_zoom( ifp, x, y )
FBIO	*ifp;
int	x, y;
{
	char	buf[3*NET_LONG_LEN+1];

	/* Send Command */
	(void)fbputlong( x, &buf[0*NET_LONG_LEN] );
	(void)fbputlong( y, &buf[1*NET_LONG_LEN] );
	pkg_send( MSG_FBZOOM, buf, 2*NET_LONG_LEN, PCP(ifp) );
	pkg_waitfor( MSG_RETURN, buf, NET_LONG_LEN, PCP(ifp) );
	return( fbgetlong( &buf[0*NET_LONG_LEN] ) );
@


9.16
log
@Factored ifdefs
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_remote.c,v 9.15 1993/10/22 20:22:00 mike Exp gdurf $ (BRL)";
d33 1
a33 3
#ifdef BSD
#define _BSD_TYPES		/* Needed for IRIX 5.0.1 */
#include <sys/types.h>
d35 2
a37 1
#endif
d39 1
a39 1
#if BSD >= 43
d310 1
a310 1
#if BSD >= 43
@


9.15
log
@IRIX 5 hack
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_remote.c,v 9.14 93/09/25 08:44:01 mike Exp Locker: mike $ (BRL)";
d30 2
a32 1

d44 3
a46 1
#ifdef BSD
a47 2
#else
#include <string.h>
@


9.14
log
@Converted to new fb.h
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_remote.c,v 9.13 93/07/20 22:24:35 mike Exp Locker: mike $ (BRL)";
d33 1
@


9.13
log
@For some reason, does not implement fb_setcursor().
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_remote.c,v 9.12 91/07/26 22:41:09 mike Exp Locker: mike $ (BRL)";
d387 1
a387 1
RGBpixel	*bgpp;
d395 3
a397 3
		buf[0] = (*bgpp)[RED];
		buf[1] = (*bgpp)[GRN];
		buf[2] = (*bgpp)[BLU];
d413 1
a413 1
RGBpixel	*pixelp;
d446 1
a446 1
RGBpixel	*pixelp;
d477 1
a477 1
RGBpixel	*pp;
d513 1
a513 1
RGBpixel	*pp;
d591 1
a591 1
unsigned char	*bits;
@


9.12
log
@Added if_magic field, and FB_CK_FBIO() macro, to allow checking
FBIO pointers
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_remote.c,v 9.11 91/07/18 16:34:06 mike Exp $ (BRL)";
d81 1
d100 1
a100 1
	fb_null,			/* fb_setcursor */
d584 15
@


9.12.1.1
log
@Add compressed message types.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_remote.c,v 9.12 91/07/26 22:41:09 mike Exp Locker: cjohnson $ (BRL)";
a72 2
		rem_cmp_read(),
		rem_cmp_write(),
a82 2
		rem_cmp_readrect(),
		rem_cmp_writerect(),
a127 40
FBIO remote_compressed = {
	0,
	rem_open,
	rem_close,
	rem_clear,
	rem_cmp_read,
	rem_cmp_write,
	rem_rmap,
	rem_wmap,
	rem_view,
	rem_getview,
	fb_null,			/* fb_setcursor */
	rem_cursor,
	rem_getcursor,
	rem_cmp_readrect,
	rem_cmp_writerect,
	rem_poll,
	rem_flush,
	rem_free,
	rem_help,
	"Remote Compressed Device Interface",	/* should be filled in	*/
	1024,				/* " */
	1024,				/* " */
	"host -c:[dev]",
	512,
	512,
	-1,				/* select fd */
	-1,
	1, 1,				/* zoom */
	256, 256,			/* window center */
	0, 0, 0,			/* cursor */
	PIXEL_NULL,
	PIXEL_NULL,
	PIXEL_NULL,
	-1,
	0,
	0L,
	0L,
	0
};
a466 13
/*
 *  Send as longs:  x, y, num
 */
_LOCAL_ int
rem_cmp_read( ifp, x, y, pixelp, num )
register FBIO	*ifp;
int		x, y;
RGBpixel	*pixelp;
int		num;
{
	int	ret;
	char	buf[3*NET_LONG_LEN+1];
	char	*inbuf;
a467 26
	if( num <= 0 )
		return(0);
	inbuf = malloc(num*sizeof(RGBpixel));
	if (!inbuf) {
		return rem_read(ifp, x, y, pixlp, num);
	}
	/* Send Read Command */
	(void)fbputlong( x, &buf[0*NET_LONG_LEN] );
	(void)fbputlong( y, &buf[1*NET_LONG_LEN] );
	(void)fbputlong( num, &buf[2*NET_LONG_LEN] );
	if( pkg_send( MSG_FBCMPREAD, buf, 3*NET_LONG_LEN, PCP(ifp) ) < 3*NET_LONG_LEN )
		return	-2;

	/* Get response;  0 len means failure */
	ret = pkg_waitfor( MSG_RETURN, inbuf,
		num*sizeof(RGBpixel), PCP(ifp) );
	if( ret <= 0 )  {
		fb_log( "rem_cmp_read: read %d at <%d,%d> failed, ret=%d.\n",
			num, x, y, ret );
		return	-3;
	}
	ret = uncompress((char *) pixelp, inbuf, num);
	free(inbuf);
	return( ret/sizeof(RGBpixel) );
}

a468 40
 * As longs, x, y, num
 */
_LOCAL_ int
rem_cmp_write( ifp, x, y, pixelp, num )
register FBIO	*ifp;
int		x, y;
RGBpixel	*pixelp;
int		num;
{
	int	ret, length;
	char	buf[3*NET_LONG_LEN+1];
	char	*outbuf;

	if( num <= 0 )  return	num;
	outbuf = malloc(num * sizeof(RGBpixel);
	if (!outbuf) {
		return rem_write( ifp, x, y, pixelp, num);
	}

	/* Send Write Command */
	(void)fbputlong( x, &buf[0*NET_LONG_LEN] );
	(void)fbputlong( y, &buf[1*NET_LONG_LEN] );
	(void)fbputlong( num, &buf[2*NET_LONG_LEN] );

	length = compress(outbuf, (char *) pixelp, num);
	ret = pkg_2send( MSG_FBCMPWRITE+MSG_NORETURN,
		buf, 3*NET_LONG_LEN,
		outbuf, length,
		PCP(ifp) );

	free(outbuf);

	ret -= 3*NET_LONG_LEN;
	if( ret < length )
		return	-1;	/* Error from libpkg */
	return	num;
	/* No reading an error return package, sacrificed for speed. */
}

/*
a508 69
FBIO	*ifp;
int	xmin, ymin;
int	width, height;
RGBpixel	*pp;
{
	int	num;
	int	ret;
	char	buf[4*NET_LONG_LEN+1];

	num = width*height;
	if( num <= 0 )
		return(0);

	/* Send Write Command */
	(void)fbputlong( xmin, &buf[0*NET_LONG_LEN] );
	(void)fbputlong( ymin, &buf[1*NET_LONG_LEN] );
	(void)fbputlong( width, &buf[2*NET_LONG_LEN] );
	(void)fbputlong( height, &buf[3*NET_LONG_LEN] );
	ret = pkg_2send( MSG_FBWRITERECT+MSG_NORETURN,
		buf, 4*NET_LONG_LEN,
		(char *)pp, num*sizeof(RGBpixel),
		PCP(ifp) );
	ret -= 4*NET_LONG_LEN;
	if( ret < 0 )
		return	-4;	/* Error from libpkg */
	return	ret/sizeof(RGBpixel);
	/* No reading an error return package, sacrificed for speed. */
}
/*
 *			R E M _ R E A D R E C T
 */
_LOCAL_ int
rem_cmp_readrect( ifp, xmin, ymin, width, height, pp )
FBIO	*ifp;
int	xmin, ymin;
int	width, height;
RGBpixel	*pp;
{
	int	num;
	int	ret;
	char	buf[4*NET_LONG_LEN+1];

	num = width*height;
	if( num <= 0 )
		return(0);
	/* Send Read Command */
	(void)fbputlong( xmin, &buf[0*NET_LONG_LEN] );
	(void)fbputlong( ymin, &buf[1*NET_LONG_LEN] );
	(void)fbputlong( width, &buf[2*NET_LONG_LEN] );
	(void)fbputlong( height, &buf[3*NET_LONG_LEN] );
	if( pkg_send( MSG_FBREADRECT, buf, 4*NET_LONG_LEN, PCP(ifp) ) < 4*NET_LONG_LEN )
		return	-2;

	/* Get response;  0 len means failure */
	ret = pkg_waitfor( MSG_RETURN, (char *)pp,
			num*sizeof(RGBpixel), PCP(ifp) );
	if( ret <= 0 )  {
		fb_log( "rem_rectread: read %d at <%d,%d> failed, ret=%d.\n",
			num, xmin, ymin, ret );
		return	-3;
	}
	return( ret/sizeof(RGBpixel) );
}

/*
 *			R E M _ W R I T E R E C T
 */
_LOCAL_ int
rem_cmp_writerect( ifp, xmin, ymin, width, height, pp )
@


9.11
log
@lint
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_remote.c,v 9.10 91/06/12 21:13:19 mike Exp $ (BRL)";
d89 1
d276 2
@


9.10
log
@lint
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_remote.c,v 9.9 91/01/10 22:17:02 mike Exp $ (BRL)";
d189 1
a189 1
		prefix[colon-file] = NULL;
d209 1
a209 1
					prefix[colon-rest] = NULL;
d276 2
a277 2
	hostname[0] = NULL;
	portname[0] = NULL;
@


9.9
log
@Added some {}'s.  They should not have been necessary.  SGI compiler
bug?
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_remote.c,v 9.8 91/01/08 23:33:41 mike Exp $ (BRL)";
d48 2
@


9.8
log
@Added a special case for errors in the midst of a rem_close operation.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_remote.c,v 9.7 91/01/04 23:01:06 mike Exp $ (BRL)";
d698 1
a698 1
	if( cmap == COLORMAP_NULL )
d701 1
a701 1
	else {
@


9.7
log
@Increased receive buffer, too.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_remote.c,v 9.6 91/01/04 22:52:30 mike Exp $ (BRL)";
d347 12
a358 2
	if( pkg_waitfor( MSG_RETURN, buf, NET_LONG_LEN, PCP(ifp) ) < 1*NET_LONG_LEN )
		return	-3;
@


9.6
log
@Much more vigorous checking of error returns.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_remote.c,v 9.5 90/12/19 05:00:28 phil Exp $ (BRL)";
d306 2
a307 1
		int	val = 32767;
d311 5
@


9.5
log
@Added new extensions to the protocol
@
text
@d9 4
d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_remote.c,v 9.4 90/12/11 22:54:00 phil Exp $ (BRL)";
d144 1
a144 1
			return 0;
d148 1
a148 1
	return 1;
d228 1
a228 1
	return -1;
d237 1
a237 1
		return -1;
d282 1
a282 1
		return	-1;
d291 1
a291 1
			return	-1;
d298 1
a298 1
		return	-1;
d316 3
a318 1
	pkg_send( MSG_FBOPEN, buf, strlen(device)+2*NET_LONG_LEN, pc );
d321 2
a322 1
	pkg_waitfor( MSG_RETURN, buf, sizeof(buf), pc );
d328 1
a328 1
		return(-1);		/* fail */
d339 4
a342 2
	pkg_send( MSG_FBCLOSE, (char *)0, 0, PCP(ifp) );
	pkg_waitfor( MSG_RETURN, buf, NET_LONG_LEN, PCP(ifp) );
d354 4
a357 2
	pkg_send( MSG_FBFREE, (char *)0, 0, PCP(ifp) );
	pkg_waitfor( MSG_RETURN, buf, NET_LONG_LEN, PCP(ifp) );
d377 4
a380 2
	pkg_send( MSG_FBCLEAR, buf, 3, PCP(ifp) );
	pkg_waitfor( MSG_RETURN, buf, NET_LONG_LEN, PCP(ifp) );
d403 2
a404 1
	pkg_send( MSG_FBREAD, buf, 3*NET_LONG_LEN, PCP(ifp) );
d407 6
a412 6
	pkg_waitfor( MSG_RETURN, (char *)pixelp,
			num*sizeof(RGBpixel), PCP(ifp) );
	if( (ret=PCP(ifp)->pkc_len) == 0 )  {
		fb_log( "rem_read: read %d at <%d,%d> failed.\n",
			num, x, y );
		return(-1);
d430 2
d436 1
a436 1
	pkg_2send( MSG_FBWRITE+MSG_NORETURN,
d440 5
a444 2

	return	num;	/* No error return, sacrificed for speed. */
d469 2
a470 1
	pkg_send( MSG_FBREADRECT, buf, 4*NET_LONG_LEN, PCP(ifp) );
d473 1
a473 1
	pkg_waitfor( MSG_RETURN, (char *)pp,
d475 4
a478 4
	if( (ret=PCP(ifp)->pkc_len) == 0 )  {
		fb_log( "rem_rectread: read %d at <%d,%d> failed.\n",
			num, xmin, ymin );
		return(-1);
d506 1
a506 1
	pkg_2send( MSG_FBWRITERECT+MSG_NORETURN,
d510 5
a514 2

	return(num);	/* No error return, sacrificed for speed. */
d532 4
a535 2
	pkg_send( MSG_FBCURSOR, buf, 3*NET_LONG_LEN, PCP(ifp) );
	pkg_waitfor( MSG_RETURN, buf, NET_LONG_LEN, PCP(ifp) );
d550 2
a551 1
	pkg_send( MSG_FBGETCURSOR, (char *)0, 0, PCP(ifp) );
d554 2
a555 1
	pkg_waitfor( MSG_RETURN, buf, sizeof(buf), PCP(ifp) );
d560 1
a560 1
		return(-1);		/* fail */
d579 4
a582 2
	pkg_send( MSG_FBVIEW, buf, 4*NET_LONG_LEN, PCP(ifp) );
	pkg_waitfor( MSG_RETURN, buf, NET_LONG_LEN, PCP(ifp) );
d597 2
a598 1
	pkg_send( MSG_FBGETVIEW, (char *)0, 0, PCP(ifp) );
d601 2
a602 1
	pkg_waitfor( MSG_RETURN, buf, sizeof(buf), PCP(ifp) );
d608 1
a608 1
		return(-1);		/* fail */
d659 4
a662 2
	pkg_send( MSG_FBRMAP, (char *)0, 0, PCP(ifp) );
	pkg_waitfor( MSG_DATA, cm, REM_CMAP_BYTES, PCP(ifp) );
d668 2
a669 1
	pkg_waitfor( MSG_RETURN, buf, NET_LONG_LEN, PCP(ifp) );
d683 2
a684 1
		pkg_send( MSG_FBWMAP, (char *)0, 0, PCP(ifp) );
d691 2
a692 1
		pkg_send( MSG_FBWMAP, cm, REM_CMAP_BYTES, PCP(ifp) );
d694 2
a695 1
	pkg_waitfor( MSG_RETURN, buf, NET_LONG_LEN, PCP(ifp) );
d710 2
a711 1
	pkg_send( MSG_FBPOLL, (char *)0, 0, PCP(ifp) );
d722 4
a725 2
	pkg_send( MSG_FBFLUSH, (char *)0, 0, PCP(ifp) );
	pkg_waitfor( MSG_RETURN, buf, NET_LONG_LEN, PCP(ifp) );
d742 4
a745 2
	pkg_send( MSG_FBHELP, buf, 1*NET_LONG_LEN, PCP(ifp) );
	pkg_waitfor( MSG_RETURN, buf, NET_LONG_LEN, PCP(ifp) );
@


9.4
log
@if_ struct changes.  See fb.h.  This version fakes the view, getview
and getcursor routines, and punts on poll().
@
text
@d7 1
a7 1
 *  with a remote server (rfbd).
d23 1
a23 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_remote.c,v 9.3 89/10/21 01:53:46 phil Exp $ (BRL)";
d311 1
a311 1
	(void) strcpy( &buf[8], device );
a503 2
	
	fb_sim_cursor(ifp, mode, x, y);	/*XXX*/
d522 13
a534 2
	/* XXX */
	return	fb_sim_getcursor(ifp, mode, x, y);
d545 10
a554 4
	/* XXX */
	fb_sim_view(ifp, xcenter, ycenter, xzoom, yzoom);
	rem_window(ifp, xcenter, ycenter);
	rem_zoom(ifp, xzoom, yzoom);
d565 14
a578 2
	/* XXX */
	return fb_sim_getview(ifp, xcenter, ycenter, xzoom, yzoom);
d582 1
a582 1
 *	x,y
d600 1
a600 1
 *	x,y
d662 6
d672 3
a674 1
	/* XXX */
@


9.3
log
@pointers to null strings, not null pointers to strings...
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: if_remote.c,v 9.2 89/09/01 01:59:43 phil Locked $ (BRL)";
d69 4
a72 2
		rem_window(),
		rem_zoom(),
d74 1
a74 1
		rem_scursor(),
d77 1
a84 1
	fb_null,			/* fb_reset */
d90 2
a91 3
	fb_null,			/* fb_viewport */
	rem_window,
	rem_zoom,
d94 1
a94 1
	rem_scursor,
d97 1
d107 1
d109 3
d505 2
a516 1
 *  32-bit longs: mode, x, y
d519 1
a519 1
rem_scursor( ifp, mode, x, y )
d521 2
a522 2
int	mode;
int	x, y;
d524 2
a525 9
	char	buf[3*NET_LONG_LEN+1];
	
	/* Send Command */
	(void)fbputlong( mode, &buf[0*NET_LONG_LEN] );
	(void)fbputlong( x, &buf[1*NET_LONG_LEN] );
	(void)fbputlong( y, &buf[2*NET_LONG_LEN] );
	pkg_send( MSG_FBSCURSOR, buf, 3*NET_LONG_LEN, PCP(ifp) );
	pkg_waitfor( MSG_RETURN, buf, NET_LONG_LEN, PCP(ifp) );
	return( fbgetlong( buf ) );
d529 26
d633 7
@


9.2
log
@fb_flush and fb_free.  Name change cleanup.  Implemented fb_scursor.
Amazing remote host/port/device parsing.
@
text
@d23 1
a23 1
static char RCSid[] = "@@(#)$Header: if_remote.c,v 9.1 89/05/19 05:48:03 phil Locked $ (BRL)";
d172 1
a172 1
		dev = NULL;
d191 1
a191 1
				dev = NULL;
@


9.1
log
@Release_3.5
@
text
@a20 2
 *
 *	$Header: if_remote.c,v 8.5 89/05/17 20:50:51 mike Exp $ (BRL)
d23 1
a23 1
static char RCSid[] = "@@(#)$Header: if_remote.c,v 8.5 89/05/17 20:50:51 mike Exp $ (BRL)";
d62 11
a72 10
_LOCAL_ int	rem_dopen(),
		rem_dclose(),
		rem_dclear(),
		rem_bread(),
		rem_bwrite(),
		rem_cmread(),
		rem_cmwrite(),
		rem_window_set(),
		rem_zoom_set(),
		rem_cmemory_addr(),
d75 2
d79 36
a114 35
FBIO remote_interface =
		{
		rem_dopen,
		rem_dclose,
		fb_null,			/* reset		*/
		rem_dclear,
		rem_bread,
		rem_bwrite,
		rem_cmread,
		rem_cmwrite,
		fb_null,			/* viewport_set		*/
		rem_window_set,
		rem_zoom_set,
		fb_null,			/* curs_set		*/
		rem_cmemory_addr,
		fb_null,			/* cursor_move_screen_addr */
		rem_readrect,
		rem_writerect,
		rem_help,
		"Remote Device Interface",	/* should be filled in	*/
		1024,				/* " */
		1024,				/* " */
		"host:[dev]",
		512,
		512,
		-1,
		PIXEL_NULL,
		PIXEL_NULL,
		PIXEL_NULL,
		-1,
		0,
		0L,
		0L,
		0
		};
d124 17
d142 104
d251 1
a251 1
rem_dopen( ifp, devicename, width, height )
d253 1
a253 1
register char	*devicename;
a258 1
	char	*file;
d260 3
d264 8
a271 3
	if( devicename == NULL || (file = strchr( devicename, ':' )) == NULL ) {
		fb_log( "rem_dopen: bad device name \"%s\"\n",
			devicename == NULL ? "(null)" : devicename );
d274 10
a283 3
	for( i = 0; devicename[i] != ':' && i < MAX_HOSTNAME; i++ )
		hostname[i] = devicename[i];
	hostname[i] = '\0';
d286 1
a286 1
		fb_log(	"remote_open: can't connect to remotefb server on host \"%s\".\n",
d305 2
a306 2
	(void) strcpy( &buf[8], file + 1 );
	pkg_send( MSG_FBOPEN, buf, strlen(devicename)+2*NET_LONG_LEN, pc );
d320 1
a320 1
rem_dclose( ifp )
d333 1
a333 1
rem_dclear( ifp, bgpp )
d335 13
d369 1
a369 1
rem_bread( ifp, x, y, pixelp, num )
d390 1
a390 1
		fb_log( "rem_bread: read %d at <%d,%d> failed.\n",
d401 1
a401 1
rem_bwrite( ifp, x, y, pixelp, num )
d492 1
a492 1
rem_cmemory_addr( ifp, mode, x, y )
d509 20
d532 1
a532 1
rem_window_set( ifp, x, y )
d550 1
a550 1
rem_zoom_set( ifp, x, y )
d567 1
a567 1
rem_cmread( ifp, cmap )
d587 1
a587 1
rem_cmwrite( ifp, cmap )
d605 12
@


8.5
log
@Eliminated variable pcp hiding.
@
text
@d22 1
a22 1
 *	$Header: if_remote.c,v 8.4 89/03/04 01:28:54 mike Locked $ (BRL)
d25 1
a25 1
static char RCSid[] = "@@(#)$Header: if_remote.c,v 8.4 89/03/04 01:28:54 mike Locked $ (BRL)";
@


8.4
log
@The Alliant had some problems with rem_cmread.
Moving things into registers and adding extra cushion on
stack auto arrays (which are NOT being over-run on other machines)
seemed to "fix" ti.
@
text
@d22 1
a22 1
 *	$Header: if_remote.c,v 8.3 89/03/03 05:54:38 mike Locked $ (BRL)
d25 1
a25 1
static char RCSid[] = "@@(#)$Header: if_remote.c,v 8.3 89/03/03 05:54:38 mike Locked $ (BRL)";
d465 2
a466 2
pkgerror(pcp, buf)
struct pkg_conn *pcp;
@


8.3
log
@Added support for fb_readrect() and fb_writerect().
@
text
@d22 1
a22 1
 *	$Header: if_remote.c,v 8.2 89/03/01 00:22:21 mike Locked $ (BRL)
d25 1
a25 1
static char RCSid[] = "@@(#)$Header: if_remote.c,v 8.2 89/03/01 00:22:21 mike Locked $ (BRL)";
d394 2
d398 1
a398 1
FBIO			*ifp;
d403 1
a403 1
	char	cm[256*2*3];
d406 1
a406 1
	pkg_waitfor( MSG_DATA, cm, sizeof(cm), PCP(ifp) );
d418 2
a419 2
FBIO	*ifp;
ColorMap	*cmap;
d421 1
a421 1
	int	i;
d423 1
a423 1
	char	cm[256*2*3];
d433 1
a433 1
		pkg_send( MSG_FBWMAP, cm, sizeof(cm), PCP(ifp) );
@


8.2
log
@Added extra buffering on output, when permitted.
@
text
@d22 1
a22 1
 *	$Header: if_remote.c,v 8.1 88/10/05 00:27:41 mike Locked $ (BRL)
d25 1
a25 1
static char RCSid[] = "@@(#)$Header: if_remote.c,v 8.1 88/10/05 00:27:41 mike Locked $ (BRL)";
d74 2
d94 2
a268 5
#ifdef NEVER
	pkg_waitfor( MSG_RETURN, buf, NET_LONG_LEN, PCP(ifp) );
	ret = fbgetlong( buf );
	return(ret);
#endif
d273 66
d437 3
a439 1

d456 2
@


8.1
log
@Release_3.0
@
text
@d22 1
a22 1
 *	$Header: if_remote.c,v 7.4 88/09/09 23:32:50 phil Exp $ (BRL)
d25 1
a25 1
static char RCSid[] = "@@(#)$Header: if_remote.c,v 7.4 88/09/09 23:32:50 phil Exp $ (BRL)";
d36 4
d151 10
@


7.4
log
@fbhelp function
remote host now appends his name (we no longer append remote:)
@
text
@d22 1
a22 1
 *	$Header: if_remote.c,v 7.3 88/05/15 20:35:36 phil Locked $ (BRL)
d25 1
a25 1
static char RCSid[] = "@@(#)$Header: if_remote.c,v 7.3 88/05/15 20:35:36 phil Locked $ (BRL)";
@


7.3
log
@lint fix
@
text
@d22 1
a22 1
 *	$Header: if_remote.c,v 7.2 88/05/13 21:38:51 mike Locked $ (BRL)
d25 1
a25 1
static char RCSid[] = "@@(#)$Header: if_remote.c,v 7.2 88/05/13 21:38:51 mike Locked $ (BRL)";
d69 2
a70 1
		rem_cmemory_addr();
d88 1
d92 1
a92 1
		"*remote*",
d358 16
d375 3
a377 2
 * This is where we come on
 * asynchronous error messages.
d384 1
a384 1
	fb_log( "remote: %s", buf );
@


7.2
log
@lint fix
@
text
@d22 1
a22 1
 *	$Header: if_remote.c,v 7.1 87/11/02 23:26:46 mike Locked $ (BRL)
d25 1
a25 1
static char RCSid[] = "@@(#)$Header: if_remote.c,v 7.1 87/11/02 23:26:46 mike Locked $ (BRL)";
d54 1
a54 1
static int pkgerror();	/* error message handler */
d360 1
a360 1
static int
a366 1
	return	0;	/* Declared as integer function in pkg_switch. */
@


7.1
log
@Release 2.3
@
text
@d22 1
a22 1
 *	$Header: if_remote.c,v 6.2 87/09/16 20:18:51 mike Exp $ (BRL)
d25 1
a25 1
static char RCSid[] = "@@(#)$Header: if_remote.c,v 6.2 87/09/16 20:18:51 mike Exp $ (BRL)";
d366 1
a366 1
	(void)free(buf);
@


6.2
log
@Converted color map read/write operationsto be done in machine independent manner.
@
text
@d22 1
a22 1
 *	$Header: if_remote.c,v 6.1 87/07/11 07:51:35 mike Locked $ (BRL)
d25 1
a25 1
static char RCSid[] = "@@(#)$Header: if_remote.c,v 6.1 87/07/11 07:51:35 mike Locked $ (BRL)";
@


6.1
log
@Release 2.0
@
text
@d22 1
a22 1
 *	$Header: if_remote.c,v 5.1 87/06/24 21:51:39 mike Rel $ (BRL)
d25 1
a25 1
static char RCSid[] = "@@(#)$Header: if_remote.c,v 5.1 87/06/24 21:51:39 mike Rel $ (BRL)";
d315 2
a316 2
FBIO	*ifp;
ColorMap	*cmap;
d318 1
a318 1
	int	i;
d320 1
a320 1
	ColorMap cm;
d323 1
a323 1
	pkg_waitfor( MSG_DATA, (char *)&cm, sizeof(cm), PCP(ifp) );
d325 3
a327 3
		cmap->cm_red[i] = fbgetshort( &cm.cm_red[i] );
		cmap->cm_green[i] = fbgetshort( &cm.cm_green[i] );
		cmap->cm_blue[i] = fbgetshort( &cm.cm_blue[i] );
d340 1
a340 1
	ColorMap cm;
d346 3
a348 3
			(void)fbputshort( cmap->cm_red[i], &cm.cm_red[i] );
			(void)fbputshort( cmap->cm_green[i], &cm.cm_green[i] );
			(void)fbputshort( cmap->cm_blue[i], &cm.cm_blue[i] );
d350 1
a350 1
		pkg_send( MSG_FBWMAP, (char *)&cm, sizeof(cm), PCP(ifp) );
@


5.1
log
@Release 1.24
@
text
@d22 1
a22 1
 *	$Header: if_remote.c,v 4.2 87/02/12 22:06:39 mike Exp $ (BRL)
d25 1
a25 1
static char RCSid[] = "@@(#)$Header: if_remote.c,v 4.2 87/02/12 22:06:39 mike Exp $ (BRL)";
@


4.2
log
@Release 1.20 -- First Formal Release
@
text
@d22 1
a22 1
 *	$Header: if_remote.c,v 4.1 86/12/29 03:42:53 mike Rel1 $ (BRL)
d25 1
a25 1
static char RCSid[] = "@@(#)$Header: if_remote.c,v 4.1 86/12/29 03:42:53 mike Rel1 $ (BRL)";
@


4.1
log
@BRL CAD Distribution Release 1.10
@
text
@d22 1
a22 1
 *	$Header: if_remote.c,v 1.22 86/12/19 02:01:41 phil Exp $ (BRL)
d25 1
a25 1
static char RCSid[] = "@@(#)$Header: if_remote.c,v 1.22 86/12/19 02:01:41 phil Exp $ (BRL)";
@


1.22
log
@changed for new pkg_open param list
@
text
@d22 1
a22 1
 *	$Header: if_remote.c,v 1.21 86/11/18 10:22:52 phil Locked $ (BRL)
d25 1
a25 1
static char RCSid[] = "@@(#)$Header: if_remote.c,v 1.21 86/11/18 10:22:52 phil Locked $ (BRL)";
@


1.21
log
@Changed service name to "remotefb"
@
text
@d22 1
a22 1
 *	$Header: if_remote.c,v 1.20 86/11/13 21:32:40 mike Locked $ (BRL)
d25 1
a25 1
static char RCSid[] = "@@(#)$Header: if_remote.c,v 1.20 86/11/13 21:32:40 mike Locked $ (BRL)";
d137 2
a138 2
	if( (pc = pkg_open( hostname, "remotefb", pkgswitch, fb_log )) == PKC_ERROR &&
	    (pc = pkg_open( hostname, "5558", pkgswitch, fb_log )) == PKC_ERROR ) {
@


1.20
log
@curs_set name change.
@
text
@d22 1
a22 1
 *	$Header: if_remote.c,v 1.19 86/10/29 04:51:02 phil Locked $ (BRL)
d25 1
a25 1
static char RCSid[] = "@@(#)$Header: if_remote.c,v 1.19 86/10/29 04:51:02 phil Locked $ (BRL)";
d113 1
a113 1
 * Open a connection to the remote libfb.
d137 1
a137 1
	if( (pc = pkg_open( hostname, "mfb", pkgswitch, fb_log )) == PKC_ERROR &&
d139 1
a139 1
		fb_log(	"remote_open: can't connect to libfb server on host \"%s\".\n",
@


1.19
log
@network order colormaps
@
text
@d22 1
a22 1
 *	$Header: if_remote.c,v 1.18 86/10/29 01:35:33 phil Locked $ (BRL)
d25 1
a25 1
static char RCSid[] = "@@(#)$Header: if_remote.c,v 1.18 86/10/29 01:35:33 phil Locked $ (BRL)";
d84 1
a84 1
		fb_null,			/* cursor_init_bitmap	*/
@


1.18
log
@removed pbytes
@
text
@d22 1
a22 1
 *	$Header: if_remote.c,v 1.17 86/10/29 01:20:12 phil Locked $ (BRL)
d25 1
a25 1
static char RCSid[] = "@@(#)$Header: if_remote.c,v 1.17 86/10/29 01:20:12 phil Locked $ (BRL)";
a312 1
/* XXX -- need to convert to network shorts! */
d318 1
d320 1
d323 6
a328 1
	pkg_waitfor( MSG_DATA, (char *)cmap, sizeof(*cmap), PCP(ifp) );
d338 1
d340 1
d344 8
a351 2
	else
		pkg_send( MSG_FBWMAP, (char *)cmap, sizeof(*cmap), PCP(ifp) );
@


1.17
log
@-1 vs. unsigned return of fbgetlong
@
text
@d22 1
a22 1
 *	$Header: if_remote.c,v 1.16 86/10/28 17:53:16 mike Locked $ (BRL)
d25 1
a25 1
static char RCSid[] = "@@(#)$Header: if_remote.c,v 1.16 86/10/28 17:53:16 mike Locked $ (BRL)";
a98 1
		0L,
@


1.16
log
@added if_debug
@
text
@d22 1
a22 1
 *	$Header: if_remote.c,v 1.15 86/10/28 15:33:15 phil Locked $ (BRL)
d25 1
a25 1
static char RCSid[] = "@@(#)$Header: if_remote.c,v 1.15 86/10/28 15:33:15 phil Locked $ (BRL)";
d158 3
a160 1
	return( fbgetlong( &buf[0*NET_LONG_LEN] ) );
@


1.15
log
@Added numeric case for mfb service.
@
text
@d22 1
a22 1
 *	$Header: if_remote.c,v 1.14 86/10/25 10:54:31 phil Exp $ (BRL)
d25 1
a25 1
static char RCSid[] = "@@(#)$Header: if_remote.c,v 1.14 86/10/25 10:54:31 phil Exp $ (BRL)";
d101 2
a102 1
		0L
@


1.14
log
@RGBpixel conversion
@
text
@d22 1
a22 1
 *	$Header: if_remote.c,v 1.13 86/10/24 04:51:55 phil Locked $ (BRL)
d25 1
a25 1
static char RCSid[] = "@@(#)$Header: if_remote.c,v 1.13 86/10/24 04:51:55 phil Locked $ (BRL)";
d137 3
a139 2
	if( (pc = pkg_open( hostname, "mfb", pkgswitch, fb_log )) == PKC_ERROR ) {
		fb_log(	"rem_dopen: can't connect to host \"%s\".\n",
@


1.13
log
@Changed to use pkg_2send for bwrite.
@
text
@d22 1
a22 1
 *	$Header: if_remote.c,v 1.12 86/10/24 04:24:08 mike Locked $ (BRL)
d25 1
a25 1
static char RCSid[] = "@@(#)$Header: if_remote.c,v 1.12 86/10/24 04:24:08 mike Locked $ (BRL)";
d47 3
a49 2
#define MAX_PIXELS_NET	1024
#define MAX_HOSTNAME	32
d114 1
a114 1
 * We send 4 bytes of mode, 4 bytes of size, then the
d130 1
a130 1
		fb_log( "remote_dopen: bad device name \"%s\"\n",
d138 1
a138 1
		fb_log(	"remote_dopen: can't connect to host \"%s\".\n",
d145 2
a146 2
	(void)fbputlong( width, &buf[0] );
	(void)fbputlong( height, &buf[4] );
d148 1
a148 1
	pkg_send( MSG_FBOPEN, buf, strlen(devicename)+8, pc );
d152 5
a156 5
	ifp->if_max_width = fbgetlong( &buf[1*4] );
	ifp->if_max_height = fbgetlong( &buf[2*4] );
	ifp->if_width = fbgetlong( &buf[3*4] );
	ifp->if_height = fbgetlong( &buf[4*4] );
	return( fbgetlong( &buf[0*4] ) );
d163 1
a163 1
	char	buf[4+1];
d166 2
a167 2
	pkg_send( MSG_FBCLOSE, 0L, 0L, PCP(ifp) );
	pkg_waitfor( MSG_RETURN, buf, 4, PCP(ifp) );
d169 1
a169 1
	return( fbgetlong( buf ) );
d175 1
a175 1
Pixel	*bgpp;
d177 1
a177 1
	char	buf[4+1];
d183 3
a185 3
		buf[0] = bgpp->red;
		buf[1] = bgpp->green;
		buf[2] = bgpp->blue;
d188 1
a188 1
	pkg_waitfor( MSG_RETURN, buf, 4, PCP(ifp) );
d197 4
a200 4
FBIO	*ifp;
int	x, y;
Pixel	*pixelp;
int	num;
d203 4
a206 2
	char	buf[3*4+1];

d208 4
a211 4
	(void)fbputlong( x, &buf[0] );
	(void)fbputlong( y, &buf[4] );
	(void)fbputlong( num, &buf[8] );
	pkg_send( MSG_FBREAD, buf, 3*4, PCP(ifp) );
d213 9
a221 10
	/* Get return first, to see how much data there is */
	pkg_waitfor( MSG_RETURN, buf, 4, PCP(ifp) );
	ret = fbgetlong( buf );

	/* Get Data */
	if( ret > 0 )
		pkg_waitfor( MSG_DATA, (char *) pixelp,	num*4, PCP(ifp) );
	else if( ret < 0 )
		fb_log( "remote_bread: read at <%d,%d> failed.\n", x, y );
	return	ret;
d229 4
a232 4
FBIO	*ifp;
int	x, y;
Pixel	*pixelp;
int	num;
d235 1
a235 1
	char	buf[3*4+1];
d238 3
a240 3
	(void)fbputlong( x, &buf[0] );
	(void)fbputlong( y, &buf[4] );
	(void)fbputlong( num, &buf[8] );
d242 2
a243 2
		buf, 3*4,
		(char *)pixelp, num*4,
d247 1
a247 1
	pkg_waitfor( MSG_RETURN, buf, 4, PCP(ifp) );
d263 1
a263 1
	char	buf[3*4+1];
d266 5
a270 5
	(void)fbputlong( mode, &buf[0] );
	(void)fbputlong( x, &buf[4] );
	(void)fbputlong( y, &buf[8] );
	pkg_send( MSG_FBCURSOR, buf, 3*4, PCP(ifp) );
	pkg_waitfor( MSG_RETURN, buf, 4, PCP(ifp) );
d282 1
a282 1
	char	buf[3*4+1];
d285 4
a288 4
	(void)fbputlong( x, &buf[0] );
	(void)fbputlong( y, &buf[4] );
	pkg_send( MSG_FBWINDOW, buf, 2*4, PCP(ifp) );
	pkg_waitfor( MSG_RETURN, buf, 4, PCP(ifp) );
d300 1
a300 1
	char	buf[3*4+1];
d303 5
a307 5
	(void)fbputlong( x, &buf[0] );
	(void)fbputlong( y, &buf[4] );
	pkg_send( MSG_FBZOOM, buf, 2*4, PCP(ifp) );
	pkg_waitfor( MSG_RETURN, buf, 4, PCP(ifp) );
	return( fbgetlong( buf ) );
d316 1
a316 1
	char	buf[4+1];
d318 4
a321 4
	pkg_send( MSG_FBRMAP, 0, 0, PCP(ifp) );
	pkg_waitfor( MSG_DATA, cmap, sizeof(*cmap), PCP(ifp) );
	pkg_waitfor( MSG_RETURN, buf, 4, PCP(ifp) );
	return( fbgetlong(buf) );
d329 1
a329 1
	char	buf[4+1];
d332 1
a332 1
		pkg_send( MSG_FBWMAP, 0, 0, PCP(ifp) );
d334 3
a336 3
		pkg_send( MSG_FBWMAP, cmap, sizeof(*cmap), PCP(ifp) );
	pkg_waitfor( MSG_RETURN, buf, 4, PCP(ifp) );
	return( fbgetlong(buf) );
@


1.12
log
@read/write return codes, pkg_stream for writes.
removed old queueing code.
@
text
@d22 1
a22 1
 *	$Header: if_remote.c,v 1.11 86/10/24 03:25:59 phil Locked $ (BRL)
d25 1
a25 1
static char RCSid[] = "@@(#)$Header: if_remote.c,v 1.11 86/10/24 03:25:59 phil Locked $ (BRL)";
d239 4
a242 1
	pkg_stream( MSG_FBWRITE+MSG_NORETURN, buf, 3*4, PCP(ifp) );
a243 2
	/* Send DATA */
	pkg_stream( MSG_DATA, (char *)pixelp, num*4, PCP(ifp) );
d308 1
@


1.11
log
@Returns from open expanded, color parameter to setbackground added.
@
text
@d22 1
a22 1
 *	$Header: if_remote.c,v 1.10 86/10/24 01:59:48 mike Locked $ (BRL)
d25 1
a25 1
static char RCSid[] = "@@(#)$Header: if_remote.c,v 1.10 86/10/24 01:59:48 mike Locked $ (BRL)";
d215 1
a215 1
	if( ret == 0 )
d217 1
a217 1
	else
d239 1
a239 1
	pkg_send( MSG_FBWRITE+MSG_NORETURN, buf, 3*4, PCP(ifp) );
d242 1
a242 1
	pkg_send( MSG_DATA, (char *)pixelp, num*4, PCP(ifp) );
d248 1
a248 1
	return	0;	/* No error return, sacrificed for speed.	*/
a347 131
#ifdef NEVER
/***** Experimental Queueing routines *****/

/*
 *  Format of the message header as it is transmitted over the network
 *  connection.  Internet network order is used.
 */
typedef struct mypkg_header {
	unsigned short	pkg_magic;		/* Ident */
	unsigned short	pkg_type;		/* Message Type */
	long		pkg_len;		/* Byte count of remainder */
	long		pkg_data;		/* start of data */
} mypkg_header;

#define	MAXQUEUE	128	/* Largest packet we will queue */
#define	QUEUELEN	16	/* max entries in queue */

struct iovec queue[QUEUELEN];
int q_len = 0;

/*
 *	P K G _ Q U E U E
 *
 * NB: I am ignoring the fd!
 */
static void
pkg_queue( ifp, type, buf, len, pcp )
FBIO	*ifp;
int	type, len;
char	*buf;
struct	pkg_conn *pcp;
{
	mypkg_header	*pkg;

	if( q_len >= QUEUELEN || len > MAXQUEUE )
		flush_queue( ifp );
	if( len > MAXQUEUE ) {
		/* fb_log( "Too big to queue\n" ); */
		pkg_send( type, buf, len, pcp );
		return;
	}
/* fb_log( "Queueing packet\n" ); */

	/* Construct a packet */
	pkg = (mypkg_header *)malloc( sizeof(mypkg_header) + len - 4 );
	pkg->pkg_magic = htons(PKG_MAGIC);
	pkg->pkg_type = htons(type);	/* should see if it's a valid type */
	pkg->pkg_len = htonl(len);
	bcopy( buf, &pkg->pkg_data, len );

	/* Link it in */
	queue[q_len].iov_base = (char *)pkg;	
	queue[q_len].iov_len = sizeof(mypkg_header) + len - 4;
	q_len++;
	return;
}

/*
 *	F L U S H _ Q U E U E 
 *
 * If there are packages on the queue, send them.
 */
static void
flush_queue( ifp )
FBIO	*ifp;
{
	int	i;

	if( q_len == 0 )
		return;
	/* fb_log( "Flushing queued data\n" ); */
	raw_pkg_send( &queue[0], q_len, PCP(ifp) );

	/* Free bufs */
	for( i = 0; i < q_len; i++ )
		free( queue[i].iov_base );
	q_len = 0;
	return;
}

#define PKG_CK(p)	{if(p==PKC_NULL||p->pkc_magic!=PKG_MAGIC) {\
			fprintf(stderr,"pkg: bad pointer x%x\n",p);abort();}}

/*
 *  			R A W _ P K G _ S E N D
 *
 *  Send an iovec list of "raw packets", i.e. user is responsible
 *   for putting on magic headers, network byte order, etc.
 *
 *  Note that the whole message should be transmitted by
 *  TCP with only one TCP_PUSH at the end, due to the use of writev().
 *
 *  Returns number of bytes of user data actually sent.
 */
int
raw_pkg_send( buf, len, pc )
struct iovec buf[];
int len;
register struct pkg_conn *pc;
{
	long bits;
	register int i;
	int start;

	PKG_CK(pc);
	if( len < 0 )  len=0;

	do  {
		/* Finish any partially read message */
		if( pc->pkc_left > 0 )
			if( pkg_block(pc) < 0 )
				return(-1);
	} while( pc->pkc_left > 0 );

	/*
	 * TODO:  set this FD to NONBIO.  If not all output got sent,
	 * loop in select() waiting for capacity to go out, and
	 * reading input as well.  Prevents deadlocking.
	 */
	start = 0;
	while( len > 0 ) {
		if( (i = writev( pc->pkc_fd, &buf[start], (len>8?8:len) )) < 0 )  {
			fb_log( "pkg_send: writev failed.\n" );
			return(-1);
		}
		len -= 8;
		start += 8;
	}
	return(len);
}
#endif NEVER
@


1.10
log
@Changed get/put long/short to have "fb" prefix on names,
to avoid conflicts with name server routines.
@
text
@d22 1
a22 1
 *	$Header: if_remote.c,v 1.9 86/10/24 01:53:09 mike Locked $ (BRL)
d25 1
a25 1
static char RCSid[] = "@@(#)$Header: if_remote.c,v 1.9 86/10/24 01:53:09 mike Locked $ (BRL)";
d142 1
a142 3
	ifp->if_fd = pc->pkc_fd;
	ifp->if_width = width;
	ifp->if_height = height;
d144 2
a145 2
	(void)fbputlong( ifp->if_width, &buf[0] );
	(void)fbputlong( ifp->if_height, &buf[4] );
d149 7
a155 3
	/* XXX - need to get the size back! */
	pkg_waitfor( MSG_RETURN, buf, 4, pc );
	return( fbgetlong( buf ) );
a177 1
	/* XXX - need to send background color */
d179 8
a186 1
	pkg_send( MSG_FBCLEAR, 0L, 0L, PCP(ifp) );
@


1.9
log
@Fixed rem_open() routine to check PKC_ERROR.
@
text
@d22 1
a22 1
 *	$Header: if_remote.c,v 1.8 86/10/24 01:22:50 mike Locked $ (BRL)
d25 1
a25 1
static char RCSid[] = "@@(#)$Header: if_remote.c,v 1.8 86/10/24 01:22:50 mike Locked $ (BRL)";
d107 3
a109 3
extern unsigned short getshort();
extern unsigned long getlong();
extern char *putshort(), *putlong();
d146 2
a147 2
	(void)putlong( ifp->if_width, &buf[0] );
	(void)putlong( ifp->if_height, &buf[4] );
d153 1
a153 1
	return( getlong( buf ) );
d166 1
a166 1
	return( getlong( buf ) );
d180 1
a180 1
	return( getlong( buf ) );
d197 3
a199 3
	(void)putlong( x, &buf[0] );
	(void)putlong( y, &buf[4] );
	(void)putlong( num, &buf[8] );
d204 1
a204 1
	ret = getlong( buf );
d228 3
a230 3
	(void)putlong( x, &buf[0] );
	(void)putlong( y, &buf[4] );
	(void)putlong( num, &buf[8] );
d237 1
a237 1
	ret = getlong( buf );
d255 3
a257 3
	(void)putlong( mode, &buf[0] );
	(void)putlong( x, &buf[4] );
	(void)putlong( y, &buf[8] );
d260 1
a260 1
	return( getlong( buf ) );
d274 2
a275 2
	(void)putlong( x, &buf[0] );
	(void)putlong( y, &buf[4] );
d278 1
a278 1
	return( getlong( buf ) );
d292 2
a293 2
	(void)putlong( x, &buf[0] );
	(void)putlong( y, &buf[4] );
d296 1
a296 1
	return( getlong( buf ) );
d309 1
a309 1
	return( getlong(buf) );
d324 1
a324 1
	return( getlong(buf) );
@


1.8
log
@First pass at conversion to getlong/putlong.
@
text
@d22 1
a22 1
 *	$Header: if_remote.c,v 1.7 86/10/24 00:58:06 mike Locked $ (BRL)
d25 1
a25 1
static char RCSid[] = "@@(#)$Header: if_remote.c,v 1.7 86/10/24 00:58:06 mike Locked $ (BRL)";
d123 1
d129 1
a129 1
		fb_log( "remote_dopen : bad device name \"%s\"\n",
d136 2
a137 2
	if( (PCPL(ifp) = (char *)pkg_open( hostname, "mfb", pkgswitch, fb_log )) < 0 ) {
		fb_log(	"remote_dopen : can't connect to host \"%s\".\n",
d141 2
a142 1
	ifp->if_fd = PCP(ifp)->pkc_fd;
d149 1
a149 1
	pkg_send( MSG_FBOPEN, buf, strlen(devicename)+8, PCP(ifp) );
d152 1
a152 1
	pkg_waitfor( MSG_RETURN, buf, 4, PCP(ifp) );
d210 1
a210 1
		fb_log( "remote_bread : read at <%d,%d> failed.\n", x, y );
d462 1
a462 1
			fb_log( "pkg_send : write failed.\n" );
@


1.7
log
@Changed to use new buffered pkg routines.
Some minor cleanups.
@
text
@d22 1
a22 1
 *	$Header: if_remote.c,v 1.6 86/10/23 20:52:59 phil Locked $ (BRL)
d25 1
a25 1
static char RCSid[] = "@@(#)$Header: if_remote.c,v 1.6 86/10/23 20:52:59 phil Locked $ (BRL)";
d106 5
d123 1
a123 1
	char	buf[24];
a125 2
	long	*lp;
	int	ret;
a142 3
	lp = (long *)&buf[0];
	*lp++ = htonl( ifp->if_width );
	*lp = htonl( ifp->if_height );
d144 2
d150 2
a151 2
	pkg_waitfor( MSG_RETURN, &ret, 4, PCP(ifp) );
	return	ntohl( ret );
d158 1
a158 1
	int	ret;
d162 1
a162 1
	pkg_waitfor( MSG_RETURN, &ret, 4, PCP(ifp) );
d164 1
a164 1
	return	ntohl( ret );
d172 1
a172 1
	int	ret;
d177 2
a178 2
	pkg_waitfor( MSG_RETURN, &ret, 4, PCP(ifp) );
	return	ntohl( ret );
d181 3
d192 1
a192 5
	struct	{
		int	x;
		int	y;
		int	num;
	} cmd;
d195 4
a198 4
	cmd.x = htonl( x );
	cmd.y = htonl( y );
	cmd.num = htonl( num );
	pkg_send( MSG_FBREAD, &cmd, sizeof(cmd), PCP(ifp) );
d201 2
a202 2
	pkg_waitfor( MSG_RETURN, &ret, 4, PCP(ifp) );
	ret = ntohl( ret );
d212 3
d223 1
a223 5
	struct	{
		int	x;
		int	y;
		int	num;
	} cmd;
d226 4
a229 4
	cmd.x = htonl( x );
	cmd.y = htonl( y );
	cmd.num = htonl( num );
	pkg_send( MSG_FBWRITE+MSG_NORETURN, &cmd, sizeof(cmd), PCP(ifp) );
d234 3
a236 2
	pkg_waitfor( MSG_RETURN, &ret, 4, PCP(ifp) );
	return	ntohl( ret );
d241 3
d250 1
a250 6
	int	ret;
	struct	{
		int	mode;
		int	x;
		int	y;
	} cmd;
d253 6
a258 6
	cmd.mode = htonl( mode );
	cmd.x = htonl( x );
	cmd.y = htonl( y );
	pkg_send( MSG_FBCURSOR, &cmd, sizeof(cmd), PCP(ifp) );
	pkg_waitfor( MSG_RETURN, &ret, 4, PCP(ifp) );
	return	ntohl( ret );
d261 3
d269 1
a269 5
	int	ret;
	struct	{
		int	x;
		int	y;
	} cmd;
d272 5
a276 5
	cmd.x = htonl( x );
	cmd.y = htonl( y );
	pkg_send( MSG_FBWINDOW, &cmd, sizeof(cmd), PCP(ifp) );
	pkg_waitfor( MSG_RETURN, &ret, 4, PCP(ifp) );
	return	ntohl( ret );
d279 3
d287 1
a287 5
	int	ret;
	struct	{
		int	x;
		int	y;
	} cmd;
d290 5
a294 5
	cmd.x = htonl( x );
	cmd.y = htonl( y );
	pkg_send( MSG_FBZOOM, &cmd, sizeof(cmd), PCP(ifp) );
	pkg_waitfor( MSG_RETURN, &ret, 4, PCP(ifp) );
	return	ntohl( ret );
d302 1
a302 1
	int	ret;
d306 2
a307 2
	pkg_waitfor( MSG_RETURN, &ret, 4, PCP(ifp) );
	return	ntohl( ret );
d315 1
a315 1
	int	ret;
d321 2
a322 2
	pkg_waitfor( MSG_RETURN, &ret, 4, PCP(ifp) );
	return	ntohl( ret );
@


1.6
log
@Flexname name changes.
@
text
@d22 1
a22 1
 *	$Header: if_remote.c,v 1.5 86/10/22 20:34:07 phil Locked $ (BRL)
d25 1
a25 1
static char RCSid[] = "@@(#)$Header: if_remote.c,v 1.5 86/10/22 20:34:07 phil Locked $ (BRL)";
a33 1
#include <netdb.h>		/* for gethostbyname() stuff */
d49 2
a50 1
#define	PCP(p)	((struct pkg_conn *)p->if_pbase)
d118 5
a122 8
	char		buf[24];
	char		*file;
	char		hostname[MAX_HOSTNAME];
	char		official_hostname[MAX_HOSTNAME];
	long		*lp;
	int		ret;
	struct hostent	*hostentry;
	extern struct hostent	*gethostbyname();
d132 2
a133 2
	if( (hostentry = gethostbyname( hostname )) == NULL ) {
		fb_log(	"remote_dopen : host not found \"%s\".\n",
a136 6
	(void) strncpy( official_hostname, hostentry->h_name, MAX_HOSTNAME );
	if( (PCP(ifp) = pkg_open( official_hostname, "mossfb", pkgswitch, fb_log )) < 0 ) {
		fb_log(	"remote_dopen : can't connect to host \"%s\".\n",
			official_hostname );
		return	-1;
	}
d214 3
a216 3
int		x, y;
Pixel		*pixelp;
int		num;
d229 1
a229 1
	pkg_queue( ifp,	MSG_FBWRITE+MSG_NORETURN, &cmd,	sizeof(cmd), PCP(ifp) );
d232 1
a232 1
	pkg_queue( ifp,	MSG_DATA, (char *) pixelp, num*4, PCP(ifp) );
d341 1
a341 1

d471 1
@


1.5
log
@New PKG error function handling.
@
text
@d22 1
a22 1
 *	$Header: if_remote.c,v 1.4 86/10/22 03:41:41 phil Locked $ (BRL)
d25 1
a25 1
static char RCSid[] = "@@(#)$Header: if_remote.c,v 1.4 86/10/22 03:41:41 phil Locked $ (BRL)";
d59 10
a68 10
_LOCAL_ int	remote_device_open(),
		remote_device_close(),
		remote_device_clear(),
		remote_buffer_read(),
		remote_buffer_write(),
		remote_colormap_read(),
		remote_colormap_write(),
		remote_window_set(),
		remote_zoom_set(),
		remote_cmemory_addr();
d72 2
a73 2
		remote_device_open,
		remote_device_close,
d75 5
a79 5
		remote_device_clear,
		remote_buffer_read,
		remote_buffer_write,
		remote_colormap_read,
		remote_colormap_write,
d81 2
a82 2
		remote_window_set,
		remote_zoom_set,
d84 1
a84 1
		remote_cmemory_addr,
d112 1
a112 1
remote_device_open( ifp, devicename, width, height )
d128 1
a128 1
		fb_log( "remote_device_open : bad device name \"%s\"\n",
d136 1
a136 1
		fb_log(	"remote_device_open : host not found \"%s\".\n",
d142 1
a142 1
		fb_log(	"remote_device_open : can't connect to host \"%s\".\n",
d162 1
a162 1
remote_device_close( ifp )
d175 1
a175 1
remote_device_clear( ifp, bgpp )
d189 1
a189 1
remote_buffer_read( ifp, x, y, pixelp, num )
d216 1
a216 1
		fb_log( "remote_buffer_read : read at <%d,%d> failed.\n", x, y );
d221 1
a221 1
remote_buffer_write( ifp, x, y, pixelp, num )
d250 1
a250 1
remote_cmemory_addr( ifp, mode, x, y )
d272 1
a272 1
remote_window_set( ifp, x, y )
d291 1
a291 1
remote_zoom_set( ifp, x, y )
d310 1
a310 1
remote_colormap_read( ifp, cmap )
d323 1
a323 1
remote_colormap_write( ifp, cmap )
@


1.4
log
@Changed to use new pkg library.
@
text
@d22 1
a22 1
 *	$Header: if_remote.c,v 1.3 86/10/14 22:41:40 phil Locked $ (BRL)
d25 1
a25 1
static char RCSid[] = "@@(#)$Header: if_remote.c,v 1.3 86/10/14 22:41:40 phil Locked $ (BRL)";
d53 1
a53 1
extern int pkgerror();	/* foobar message handler */
d141 1
a141 1
	if( (PCP(ifp) = pkg_open( official_hostname, "mossfb", pkgswitch )) < 0 ) {
a157 3
	ret = ntohl( ret );
	if( ret < 0 )
		fb_log( "remote_device_open : device \"%s\" busy.\n", devicename );
d338 2
a339 2
 * Called from pkgswitch.c, this is where we come on
 * error messages.
d341 3
a343 3
int
pkgerror(type, buf, length)
int type, length;
d346 3
a348 5
	/* Dangerous, but such is life */
	buf[length] = '\0';

	fb_log( "PKGFOO: Type %d, \"%s\"\n", type, buf );
	return	0; /* Declared as integer function in pkg_switch.	*/
@


1.3
log
@cb'd it.
@
text
@d22 1
a22 1
 *	$Header: if_remote.c,v 1.2 86/10/10 23:54:29 phil Locked $ (BRL)
d25 1
a25 1
static char RCSid[] = "@@(#)$Header: if_remote.c,v 1.2 86/10/10 23:54:29 phil Locked $ (BRL)";
d43 1
a43 1
#include "./pkg.h"
d50 1
d52 7
d74 1
a74 1
		fb_null,				/* reset		*/
d80 1
a80 1
		fb_null,				/* viewport_set		*/
d83 1
a83 1
		fb_null,				/* cursor_init_bitmap	*/
d85 1
a85 1
		fb_null,				/* cursor_move_screen_addr */
d104 1
d141 1
a141 1
	if( (ifp->if_fd = pkg_open( official_hostname, "mossfb" )) < 0 ) {
d146 1
d154 1
a154 1
	pkg_send( MSG_FBOPEN, buf, strlen(devicename)+8, ifp->if_fd );
d157 1
a157 1
	pkg_waitfor( MSG_RETURN, &ret, 4, ifp->if_fd );
d171 3
a173 3
	pkg_send( MSG_CLOSE, 0L, 0L, ifp->if_fd );
	pkg_waitfor( MSG_RETURN, &ret, 4, ifp->if_fd );
	pkg_close( ifp->if_fd );
d186 2
a187 2
	pkg_send( MSG_FBCLEAR, 0L, 0L, ifp->if_fd );
	pkg_waitfor( MSG_RETURN, &ret, 4, ifp->if_fd );
d209 1
a209 1
	pkg_send( MSG_FBREAD, &cmd, sizeof(cmd), ifp->if_fd );
d212 1
a212 1
	pkg_waitfor( MSG_RETURN, &ret, 4, ifp->if_fd );
d217 1
a217 1
		pkg_waitfor( MSG_DATA, (char *) pixelp,	num*4, ifp->if_fd );
d241 1
a241 1
	pkg_queue( ifp,	MSG_FBWRITE+MSG_NORETURN, &cmd,	sizeof(cmd), ifp->if_fd );
d244 1
a244 1
	pkg_queue( ifp,	MSG_DATA, (char *) pixelp, num*4, ifp->if_fd );
d246 1
a246 1
	pkg_waitfor( MSG_RETURN, &ret, 4, ifp->if_fd );
d269 2
a270 2
	pkg_send( MSG_FBCURSOR, &cmd, sizeof(cmd), ifp->if_fd );
	pkg_waitfor( MSG_RETURN, &ret, 4, ifp->if_fd );
d288 2
a289 2
	pkg_send( MSG_FBWINDOW, &cmd, sizeof(cmd), ifp->if_fd );
	pkg_waitfor( MSG_RETURN, &ret, 4, ifp->if_fd );
d307 2
a308 2
	pkg_send( MSG_FBZOOM, &cmd, sizeof(cmd), ifp->if_fd );
	pkg_waitfor( MSG_RETURN, &ret, 4, ifp->if_fd );
d319 3
a321 3
	pkg_send( MSG_FBRMAP, 0, 0, ifp->if_fd );
	pkg_waitfor( MSG_DATA, cmap, sizeof(*cmap), ifp->if_fd );
	pkg_waitfor( MSG_RETURN, &ret, 4, ifp->if_fd );
d333 1
a333 1
		pkg_send( MSG_FBWMAP, 0, 0, ifp->if_fd );
d335 2
a336 2
		pkg_send( MSG_FBWMAP, cmap, sizeof(*cmap), ifp->if_fd );
	pkg_waitfor( MSG_RETURN, &ret, 4, ifp->if_fd );
d362 1
a362 2
#define PKG_MAGIC	0x41FE
typedef struct pkg_header {
d367 1
a367 1
} pkg_header;
d381 1
a381 1
pkg_queue( ifp, type, buf, len, fd )
d383 1
a383 1
int	type, len, fd;
d385 1
d387 1
a387 1
	pkg_header	*pkg;
d393 1
a393 1
		pkg_send( type, buf, len, fd );
d399 1
a399 1
	pkg = (pkg_header *)malloc( sizeof(pkg_header) + len - 4 );
d407 1
a407 1
	queue[q_len].iov_len = sizeof(pkg_header) + len - 4;
d426 1
a426 1
	raw_pkg_send( &queue[0], q_len, ifp->if_fd );
d433 51
@


1.2
log
@string.h -vs- strings.h
@
text
@d2 21
a22 21
		I F _ R E M O T E . C

  Remote libfb interface.

  Duplicates the functions in libfb via communication
  with a remote server (rlibfb).

  Authors -
	Phillip Dykstra
	Gary S. Moss

  Source -
	SECAD/VLD Computing Consortium, Bldg 394
	The U. S. Army Ballistic Research Laboratory
	Aberdeen Proving Ground, Maryland  21005-5066
  
  Copyright Notice -
	This software is Copyright (C) 1986 by the United States Army.
	All rights reserved.

	$Header: if_remote.c,v 1.1 86/10/02 02:18:17 mike Locked $ (BRL)
d25 1
a25 1
static char RCSid[] = "@@(#)$Header: if_remote.c,v 1.1 86/10/02 02:18:17 mike Locked $ (BRL)";
d107 12
a118 11
	{	register int	i;
		char		buf[24];
		char		*file;
		char		hostname[MAX_HOSTNAME];
		char		official_hostname[MAX_HOSTNAME];
		long		*lp;
		int		ret;
		struct hostent	*hostentry;
		extern struct hostent	*gethostbyname();
	if( devicename == NULL || (file = strchr( devicename, ':' )) == NULL )
		{
d120 1
a120 2
			devicename == NULL ? "(null)" : devicename
			);
d122 1
a122 1
		}
d126 1
a126 2
	if( (hostentry = gethostbyname( hostname )) == NULL )
		{
d128 1
a128 2
			hostname
			);
d130 1
a130 1
		}
d132 1
a132 2
	if( (ifp->if_fd = pkg_open( official_hostname, "mossfb" )) < 0 )
		{
d134 1
a134 2
			official_hostname
			);
d136 1
a136 1
		}
d152 1
a152 1
	}
d157 3
a159 1
	{	int	ret;
d165 1
a165 1
	}
d171 3
a173 1
	{	int	ret;
d179 1
a179 1
	}
d184 11
a194 9
int		x, y;
Pixel		*pixelp;
int		num;
	{	int	ret;
		struct	{
			int	x;
			int	y;
			int	num;
		} cmd;
d211 1
a211 1
	}
d219 8
a226 6
	{	int	ret;
		struct	{
			int	x;
			int	y;
			int	num;
		} cmd;
d240 1
a240 1
	}
d245 9
a253 8
int		mode;
int		x, y;
	{	int	ret;
		struct	{
			int	mode;
			int	x;
			int	y;
		} cmd;
d262 1
a262 1
	}
d267 7
a273 6
int		x, y;
	{	int	ret;
		struct	{
			int	x;
			int	y;
		} cmd;
d281 1
a281 1
	}
d286 7
a292 6
int		x, y;
	{	int	ret;
		struct	{
			int	x;
			int	y;
		} cmd;
d300 1
a300 1
	}
d306 3
a308 1
	{	int	ret;
d313 1
a313 1
	}
d319 3
a321 1
	{	int	ret;
d328 1
a328 1
	}
d330 4
a333 1
/* XXX - shouldn't be global */
d335 1
a335 1
pkgfoo(type, buf, length)
d374 5
a378 3
int		type, len, fd;
char		*buf;
	{	pkg_header	*pkg;
d381 1
a381 2
	if( len > MAXQUEUE )
		{
d385 1
a385 1
		}
d400 1
a400 1
	}
d410 3
a412 1
	{	int	i;
d423 1
a423 1
	}
@


1.1
log
@Initial revision
@
text
@d22 1
a22 1
	$Header$ (BRL)
d25 1
a25 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d29 2
d35 5
d41 2
@
