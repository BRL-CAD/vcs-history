head	11.9;
access;
symbols
	ansi-20040405-merged:11.6.4.1
	postmerge-20040405-ansi:11.7
	premerge-20040404-ansi:11.7
	postmerge-autoconf:11.7
	autoconf-freeze:11.6.12.2
	premerge-autoconf:11.7
	ansi-20040316-freeze:11.6
	postmerge-20040315-windows:11.7
	premerge-20040315-windows:11.7
	windows-20040315-freeze:11.6.6.1
	autoconf-20031203:11.6
	autoconf-20031202:11.6
	autoconf-branch:11.6.0.12
	phong-branch:11.6.0.10
	photonmap-branch:11.6.0.8
	rel-6-1-DP:11.6
	windows-branch:11.6.0.6
	rel-6-0-2:11.6
	ansi-branch:11.6.0.4
	rel-6-0-1-branch:11.6.0.2
	hartley-6-0-post:11.6
	hartley-6-0-pre:11.6
	rel-6-0-1:11.6
	rel-6-0:11.6
	rel-5-4:11.5
	offsite-5-3-pre:11.5
	rel-5-3:11.5
	rel-5-2:11.5
	rel-5-1-branch:11.5.0.2
	rel-5-1:11.5
	rel-5-0:11.5
	rel-5-0-beta:11.5
	rel-4-5:11.4
	ctj-4-5-post:11.2
	ctj-4-5-pre:11.2
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1;
locks; strict;
comment	@ * @;


11.9
date	2004.05.21.18.07.24;	author morrison;	state dead;
branches;
next	11.8;

11.8
date	2004.05.10.15.30.44;	author erikg;	state Exp;
branches;
next	11.7;

11.7
date	2004.02.02.17.39.12;	author morrison;	state Exp;
branches;
next	11.6;

11.6
date	2001.04.20.22.29.12;	author morrison;	state Exp;
branches
	11.6.4.1
	11.6.6.1
	11.6.12.1;
next	11.5;

11.5
date	98.06.27.04.29.15;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	98.01.22.19.43.43;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	97.12.04.00.47.07;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	96.08.27.06.25.01;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.52.37;	author mike;	state Rel4_4;
branches;
next	10.11;

10.11
date	94.12.30.06.28.36;	author mike;	state Exp;
branches;
next	10.10;

10.10
date	94.11.18.18.31.19;	author mike;	state Exp;
branches;
next	10.9;

10.9
date	94.11.04.05.06.44;	author mike;	state Exp;
branches;
next	10.8;

10.8
date	94.08.12.20.23.33;	author gdurf;	state Exp;
branches;
next	10.7;

10.7
date	94.08.09.12.57.03;	author gdurf;	state Exp;
branches;
next	10.6;

10.6
date	93.10.22.20.23.25;	author mike;	state Exp;
branches;
next	10.5;

10.5
date	93.09.25.10.55.28;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	93.09.25.09.11.47;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	92.06.18.14.26.27;	author stay;	state Exp;
branches;
next	10.2;

10.2
date	92.04.15.19.41.45;	author mike;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.37.17;	author mike;	state Rel4_0;
branches;
next	9.24;

9.24
date	91.10.12.02.25.01;	author mike;	state Exp;
branches;
next	9.23;

9.23
date	91.10.11.23.10.39;	author mike;	state Exp;
branches;
next	9.22;

9.22
date	91.10.11.22.55.05;	author mike;	state Exp;
branches;
next	9.21;

9.21
date	91.07.26.23.12.31;	author mike;	state Exp;
branches;
next	9.20;

9.20
date	91.07.26.22.40.52;	author mike;	state Exp;
branches;
next	9.19;

9.19
date	91.07.05.14.50.15;	author stay;	state Exp;
branches;
next	9.18;

9.18
date	91.07.04.02.58.47;	author mike;	state Exp;
branches;
next	9.17;

9.17
date	91.07.04.02.27.32;	author mike;	state Exp;
branches;
next	9.16;

9.16
date	91.07.04.02.24.30;	author stay;	state Exp;
branches;
next	9.15;

9.15
date	91.06.19.16.09.20;	author stay;	state Exp;
branches;
next	9.14;

9.14
date	91.06.18.18.57.18;	author butler;	state Exp;
branches;
next	9.13;

9.13
date	91.01.28.20.34.58;	author butler;	state Exp;
branches;
next	9.12;

9.12
date	91.01.08.22.52.10;	author mike;	state Exp;
branches;
next	9.11;

9.11
date	91.01.05.01.37.03;	author mike;	state Exp;
branches;
next	9.10;

9.10
date	90.12.19.06.31.31;	author mike;	state Exp;
branches;
next	9.9;

9.9
date	90.12.19.05.12.38;	author mike;	state Exp;
branches;
next	9.8;

9.8
date	90.12.19.05.00.09;	author phil;	state Exp;
branches;
next	9.7;

9.7
date	90.12.11.22.47.13;	author phil;	state Exp;
branches;
next	9.6;

9.6
date	90.11.04.07.03.34;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	90.11.03.15.51.54;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	89.12.01.21.42.38;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	89.10.21.01.50.38;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	89.09.01.01.34.19;	author phil;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.47.39;	author mike;	state Rel3_5;
branches;
next	8.27;

8.27
date	89.05.17.20.52.20;	author mike;	state Exp;
branches;
next	8.26;

8.26
date	89.05.16.13.22.25;	author stay;	state Exp;
branches;
next	8.25;

8.25
date	89.05.08.14.30.37;	author stay;	state Exp;
branches;
next	8.24;

8.24
date	89.05.07.23.11.55;	author mike;	state Exp;
branches;
next	8.23;

8.23
date	89.05.07.21.11.21;	author mike;	state Exp;
branches;
next	8.22;

8.22
date	89.05.04.17.31.29;	author stay;	state Exp;
branches;
next	8.21;

8.21
date	89.05.04.16.53.58;	author stay;	state Exp;
branches;
next	8.20;

8.20
date	89.05.04.05.01.31;	author phil;	state Exp;
branches;
next	8.19;

8.19
date	89.03.19.19.56.27;	author mike;	state Exp;
branches;
next	8.18;

8.18
date	89.03.19.19.10.34;	author mike;	state Exp;
branches;
next	8.17;

8.17
date	89.03.19.17.51.51;	author mike;	state Exp;
branches;
next	8.16;

8.16
date	89.03.17.19.18.48;	author mike;	state Exp;
branches;
next	8.15;

8.15
date	89.03.17.18.10.28;	author mike;	state Exp;
branches;
next	8.14;

8.14
date	89.03.17.13.39.06;	author mike;	state Exp;
branches;
next	8.13;

8.13
date	89.03.15.23.09.29;	author mike;	state Exp;
branches;
next	8.12;

8.12
date	89.03.03.05.52.05;	author mike;	state Exp;
branches;
next	8.11;

8.11
date	89.03.03.04.09.53;	author mike;	state Exp;
branches;
next	8.10;

8.10
date	89.03.01.03.38.04;	author mike;	state Exp;
branches;
next	8.9;

8.9
date	89.03.01.03.20.33;	author mike;	state Exp;
branches;
next	8.8;

8.8
date	89.03.01.03.07.35;	author mike;	state Exp;
branches;
next	8.7;

8.7
date	89.02.26.05.35.20;	author mike;	state Exp;
branches;
next	8.6;

8.6
date	89.01.24.05.52.16;	author mike;	state Exp;
branches;
next	8.5;

8.5
date	88.12.29.00.02.31;	author mike;	state Exp;
branches;
next	8.4;

8.4
date	88.12.28.00.06.00;	author mike;	state Exp;
branches;
next	8.3;

8.3
date	88.12.27.22.28.31;	author mike;	state Exp;
branches;
next	8.2;

8.2
date	88.11.02.17.13.42;	author mike;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.27.34;	author mike;	state Rel3_0;
branches;
next	1.2;

1.2
date	88.09.21.00.14.56;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	88.09.09.17.37.42;	author stay;	state Exp;
branches;
next	;

11.6.4.1
date	2004.03.17.21.17.00;	author morrison;	state Exp;
branches;
next	;

11.6.6.1
date	2004.03.11.23.42.07;	author morrison;	state Exp;
branches;
next	;

11.6.12.1
date	2004.02.12.19.48.12;	author erikg;	state Exp;
branches;
next	11.6.12.2;

11.6.12.2
date	2004.03.15.14.06.19;	author erikg;	state Exp;
branches;
next	;


desc
@Silicon Graphics 4d with GRAPHICS TURBO system
@


11.9
log
@moved to src/
@
text
@/*
 *			I F _ 4 D . C
 *
 *  BRL-CAD Frame Buffer Library interface for SGI Iris-4D
 *  running the IRIX32 operating system with the GL graphics library.
 *  Support for the 3030/2400 series ("Iris-3D") is in if_sgi.c
 *  However, both are called /dev/sgi
 *  Support for OpenGL is found in if_ogl.c
 *
 *  In order to use a large chunck of memory with the shared memory 
 *  system it is necessary to increase the shmmax and shmall paramaters
 *  of the system. You can do this by changing the defaults in the
 *  /usr/sysgen/master.d/shm to
 *
 * 	#define SHMMAX	5131072
 *	#define SHMALL	4000
 *
 *  and rebooting your system twice.
 *
 *  Refer to the SGI Users Manuals when reconfiguring your kernel.
 *
 *  There are several different Frame Buffer modes supported.
 *  Set your environment FB_FILE to the appropriate type.
 *  (see the modeflag definitions below).
 *	/dev/sgi[options]
 *
 *  Authors -
 *	Michael John Muuss
 *	Paul R. Stay
 *	Gary S. Moss
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1989-2004 by the United States Army.
 *	All rights reserved.
 *
 */
#ifndef lint
static char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/libfb/if_4d.c,v 11.8 2004/05/10 15:30:44 erikg Exp $ (BRL)";
#endif

#define class	inv_class	/* Map Irix 4 name into Irix 5 name */
#define type	inv_type	/* Map Irix 4 name into Irix 5 name */

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <ctype.h>
#include <gl.h>
#include <get.h>
#include <device.h>
#include <sys/invent.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <signal.h>
#include <errno.h>
#undef RED
#include <gl/addrs.h>
#include <gl/cg2vme.h>

#include "machine.h"
#include "externs.h"
#include "fb.h"
#include "./fblocal.h"

extern inventory_t	*getinvent();

static Cursor	nilcursor;	/* to make it go away -- all bits off */
static Cursor	cursor =  {
#include "./sgicursor.h"
 };

/*
 *  One global state variable to record number of different windows
 *  that *this process* has opened.
 *  Needed to prevent re-running ginit(), and avoiding prefposition().
 */
static int	sgi_nwindows = 0;

/* Internal routines */
_LOCAL_ void	sgi_cminit();
#ifdef USE_PROTOTYPES
_LOCAL_ void	gt_zbuf_to_screen(FBIO	*ifp, int one_y);
#else
_LOCAL_ void	gt_zbuf_to_screen();
#endif
_LOCAL_ void	fake_rectwrite();
_LOCAL_ void	sgi_clipper();

/* Exported routines */
_LOCAL_ int	sgi_open(),
		sgi_close(),
		sgi_clear(),
		sgi_read(),
		sgi_write(),
		sgi_rmap(),
		sgi_wmap(),
		sgi_view(),
		sgi_getview(),
		sgi_setcursor(),
		sgi_cursor(),
		sgi_writerect(),
		sgi_poll(),
		sgi_free(),
		sgi_flush(),
		sgi_help();

/* This is the ONLY thing that we "export" */
FBIO sgi_interface =
		{
		0,
		sgi_open,
		sgi_close,
		sgi_clear,
		sgi_read,
		sgi_write,
		sgi_rmap,
		sgi_wmap,
		sgi_view,
		sgi_getview,
		sgi_setcursor,
		sgi_cursor,
		fb_sim_getcursor,
		fb_sim_readrect,
		sgi_writerect,
		fb_sim_bwreadrect,
		fb_sim_bwwriterect,
		sgi_poll,		/* handle events */
		sgi_flush,		/* flush */
		sgi_free,		/* free*/
		sgi_help,
		"Silicon Graphics Iris '4D'",
		XMAXSCREEN+1,		/* max width */
		YMAXSCREEN+1,		/* max height */
		"/dev/sgi",
		512,			/* current/default width  */
		512,			/* current/default height */
		-1,			/* select fd */
		-1,			/* file descriptor */
		1, 1,			/* zoom */
		256, 256,		/* window */
		0, 0, 0,		/* cursor */
		PIXEL_NULL,		/* page_base */
		PIXEL_NULL,		/* page_curp */
		PIXEL_NULL,		/* page_endp */
		-1,			/* page_no */
		0,			/* page_ref */
		0L,			/* page_curpos */
		0L,			/* page_pixels */
		0			/* debug */
		};


_LOCAL_ void	sgi_inqueue();
static int	is_linear_cmap();

/*
 *  Structure of color map in shared memory region.
 *  Has exactly the same format as the SGI hardware "gammaramp" map
 *  Note that only the lower 8 bits are significant.
 */
struct sgi_cmap {
	short	cmr[256];
	short	cmg[256];
	short	cmb[256];
};

/*
 *  This is the format of the buffer for lrectwrite(),
 *  and thus defines the format of the in-memory framebuffer copy.
 */
struct sgi_pixel {
	unsigned char alpha;	/* this will always be zero */
	unsigned char blue;
	unsigned char green;
	unsigned char red;
};

/*
 *  Per window state information, overflow area.
 *  Too much for just the if_u[1-6] area now.
 */
struct sgiinfo {
	short	mi_curs_on;
	short	mi_cmap_flag;
	int	mi_shmid;
	int	mi_memwidth;		/* width of scanline in if_mem */
	long	mi_der1;		/* Saved DE_R1 */
	short	mi_xoff;		/* X viewport offset, rel. window */
	short	mi_yoff;		/* Y viewport offset, rel. window */
	short	mi_is_gt;		/* !0 when using GT hardware */
	int	mi_pid;			/* for multi-cpu check */
	int	mi_parent;		/* PID of linger-mode process */
	struct sgi_pixel mi_scanline[XMAXSCREEN+1];	/* one scanline */
	int	mi_doublebuffer;	/* 0=singlebuffer 1=doublebuffer */
};
#define	SGI(ptr)	((struct sgiinfo *)((ptr)->u1.p))
#define	SGIL(ptr)	((ptr)->u1.p)		/* left hand side version */
#define if_mem		u2.p			/* shared memory pointer */
#define if_cmap		u3.p			/* color map in shared memory */
#define CMR(x)		((struct sgi_cmap *)((x)->if_cmap))->cmr
#define CMG(x)		((struct sgi_cmap *)((x)->if_cmap))->cmg
#define CMB(x)		((struct sgi_cmap *)((x)->if_cmap))->cmb
#define if_zoomflag	u4.l			/* zoom > 1 */
#define if_mode		u5.l			/* see MODE_* defines */

#define MARGIN	4			/* # pixels margin to screen edge */
#define BANNER	18			/* Size of MEX title banner */
#define WIN_L	(ifp->if_max_width - ifp->if_width-MARGIN)
#define WIN_R	(ifp->if_max_width - 1 - MARGIN)
#define WIN_B	MARGIN
#define WIN_T	(ifp->if_height - 1 + MARGIN)

/*
 *  The mode has several independent bits:
 *	SHARED -vs- MALLOC'ed memory for the image
 *	TRANSIENT -vs- LINGERING windows
 *	Windowed -vs- Centered Full screen
 *	Default Hz -vs- 30hz monitor mode
 *	NTSC -vs- normal monitor mode
 */
#define MODE_1MASK	(1<<0)
#define MODE_1SHARED	(0<<0)		/* Use Shared memory */
#define MODE_1MALLOC	(1<<0)		/* Use malloc memory */

#define MODE_2MASK	(1<<1)
#define MODE_2TRANSIENT	(0<<1)
#define MODE_2LINGERING (1<<1)

#define MODE_3MASK	(1<<2)
#define MODE_3WINDOW	(0<<2)
#define MODE_3FULLSCR	(1<<2)

#define MODE_4MASK	(1<<3)
#define MODE_4HZDEF	(0<<3)
#define MODE_4HZ30	(1<<3)

#define MODE_5MASK	(1<<4)
#define MODE_5NORMAL	(0<<4)
#define MODE_5NTSC	(1<<4)

#define MODE_6MASK	(1<<5)
#define MODE_6NORMAL	(0<<5)
#define MODE_6EXTSYNC	(1<<5)

#define MODE_7MASK	(1<<6)
#define MODE_7NORMAL	(0<<6)
#define MODE_7SWCMAP	(1<<6)

#define MODE_8MASK	(1<<7)
#define MODE_8NORMAL	(0<<7)
#define MODE_8NOGT	(1<<7)

#define MODE_9MASK	(1<<8)
#define MODE_9NORMAL	(0<<8)
#define MODE_9SINGLEBUF	(1<<8)

#define MODE_10MASK	(1<<9)
#define MODE_10NORMAL	(0<<9)
#define MODE_10SYNC_ON_GREEN	(1<<9)

#define MODE_12MASK	(1<<11)
#define MODE_12NORMAL	(0<<11)
#define MODE_12DELAY_WRITES_TILL_FLUSH	(1<<11)

#define MODE_15MASK	(1<<14)
#define MODE_15NORMAL	(0<<14)
#define MODE_15ZAP	(1<<14)

static struct modeflags {
	char	c;
	long	mask;
	long	value;
	char	*help;
} modeflags[] = {
	{ 'p',	MODE_1MASK, MODE_1MALLOC,
		"Private memory - else shared" },
	{ 'l',	MODE_2MASK, MODE_2LINGERING,
		"Lingering window - else transient" },
	{ 'f',	MODE_3MASK, MODE_3FULLSCR,
		"Full centered screen - else windowed" },
	{ 't',	MODE_4MASK, MODE_4HZ30,
		"Thirty Hz (e.g. Dunn) - else 60 Hz" },
	{ 'n',	MODE_5MASK, MODE_5NTSC,
		"NTSC - else normal video.  GENLOCK board activated if present." },
	{ 'g',	MODE_10MASK, MODE_10SYNC_ON_GREEN,
		"For NTSC & 30Hz, put sync on Green - else use 4th connector" },
	{ 'e',	MODE_6MASK, MODE_6EXTSYNC,
		"External sync - else internal.  Requires CG2 board." },
	{ 'c',	MODE_7MASK, MODE_7SWCMAP,
		"Perform software colormap - else use hardware colormap on whole screen" },
	{ 'G',	MODE_8MASK, MODE_8NOGT,
		"Don't use GT & Z-buffer hardware, if present (debug)" },
	{ 's',	MODE_9MASK, MODE_9SINGLEBUF,
		"On GT, single buffer, don't double buffer" },
	{ 'D',	MODE_12DELAY_WRITES_TILL_FLUSH, MODE_12DELAY_WRITES_TILL_FLUSH,
		"Don't update screen until fb_flush() is called.  (Double buffer sim)" },
	{ 'z',	MODE_15MASK, MODE_15ZAP,
		"Zap (free) shared memory.  Can also be done with fbfree command" },
	{ '\0', 0, 0, "" }
};

/* Clipping structure, for zoom/pan operations on non-GT systems */
struct sgi_clip {
	int	xmin;
	int	xmax;
	int	ymin;
	int	ymax;
	int	xscroff;
	int	yscroff;
	int	xscrpad;
	int	yscrpad;
};

/************************************************************************/
/************************************************************************/
/************************************************************************/
/******************* Shared Memory Support ******************************/
/************************************************************************/
/************************************************************************/
/************************************************************************/

/*
 *			S G I _ G E T M E M
 *
 *  Because there is no hardware zoom or pan, we need to repaint the
 *  screen (with big pixels) to implement these operations.
 *  This means that the actual "contents" of the frame buffer need
 *  to be stored somewhere else.  If possible, we allocate a shared
 *  memory segment to contain that image.  This has several advantages,
 *  the most important being that when operating the display in 12-bit
 *  output mode, pixel-readbacks still give the full 24-bits of color.
 *  System V shared memory persists until explicitly killed, so this
 *  also means that in MEX mode, the previous contents of the frame
 *  buffer still exist, and can be again accessed, even though the
 *  MEX windows are transient, per-process.
 * 
 *  There are a few oddities, however.  The worst is that System V will
 *  not allow the break (see sbrk(2)) to be set above a shared memory
 *  segment, and shmat(2) does not seem to allow the selection of any
 *  reasonable memory address (like 6 Mbytes up) for the shared memory.
 *  In the initial version of this routine, that prevented subsequent
 *  calls to malloc() from succeeding, quite a drawback.  The work-around
 *  used here is to increase the current break to a large value,
 *  attach to the shared memory, and then return the break to it's
 *  original value.  This should allow most reasonable requests for
 *  memory to be satisfied.  In special cases, the values used here
 *  might need to be increased.
 */
_LOCAL_ int
sgi_getmem( ifp )
FBIO	*ifp;
{
#define SHMEM_KEY	42
	int	pixsize;
	int	size;
	int	i;
	char	*old_brk;
	char	*new_brk;
	char	*sp;
	int	new = 0;

	if( sizeof(struct sgi_pixel) != sizeof(long) )  {
		fb_log("Warning, sgi_pixel=%d, long=%d bytes\n",
			sizeof(struct sgi_pixel), sizeof(long) );
	}
	errno = 0;

	if( (ifp->if_mode & MODE_1MASK) == MODE_1MALLOC )  {
		/*
		 *  In this mode, only malloc as much memory as is needed.
		 */
		SGI(ifp)->mi_memwidth = ifp->if_width;
		pixsize = ifp->if_height * ifp->if_width * sizeof(struct sgi_pixel);
		size = pixsize + sizeof(struct sgi_cmap);

		sp = malloc( size );
		if( sp == 0 )  {
			fb_log("sgi_getmem: frame buffer memory malloc failed\n");
			goto fail;
		}
		new = 1;
		goto success;
	}

	/* The shared memory section never changes size */
	SGI(ifp)->mi_memwidth = ifp->if_max_width;

	/*
	 *  On Irix 5 with Indigo EXPRESS graphics,
	 *  lrectwrite() runs off the end!
	 *  So, provide a pad area of 2 scanlines.
	 *  (1 line is enough, but this avoids risk of damage to colormap table.)
	 */
	pixsize = (ifp->if_max_height+2) * ifp->if_max_width *
		sizeof(struct sgi_pixel);

	size = pixsize + sizeof(struct sgi_cmap);
	size = (size + getpagesize()-1) & ~(getpagesize()-1);

	/* First try to attach to an existing one */
	if( (SGI(ifp)->mi_shmid = shmget( SHMEM_KEY, size, 0 )) < 0 )  {
		/* No existing one, create a new one */
		if( (SGI(ifp)->mi_shmid = shmget(
		    SHMEM_KEY, size, IPC_CREAT|0666 )) < 0 )  {
			fb_log("sgi_getmem: shmget failed, errno=%d\n", errno);
			goto fail;
		}
		new = 1;
	}

#if IRIX < 5
	/* Move up the existing break, to leave room for later malloc()s */
	old_brk = sbrk(0);
	new_brk = (char *)(6 * (XMAXSCREEN+1) * 1024L);
	if( new_brk <= old_brk )
		new_brk = old_brk + (XMAXSCREEN+1) * 1024;
	new_brk = (char *)((((long)new_brk) + getpagesize()-1) & ~(getpagesize()-1));
	if( brk( new_brk ) < 0 )  {
		fb_log("sgi_getmem: new brk(x%x) failure, errno=%d\n", new_brk, errno);
		goto fail;
	}

	/* Open the segment Read/Write, near the current break */
	if( (sp = shmat( SGI(ifp)->mi_shmid, 0, 0 )) == (char *)(-1L) )  {
		fb_log("sgi_getmem: shmat returned x%x, errno=%d\n", sp, errno );
		goto fail;
	}

	/* Restore the old break */
	if( brk( old_brk ) < 0 )  {
		fb_log("sgi_getmem: restore brk(x%x) failure, errno=%d\n", old_brk, errno);
		/* Take the memory and run */
	}
#else
	/* Open the segment Read/Write */
	/* On Irix 5, this gets mapped in at a high address, no problem. */
	if( (sp = shmat( SGI(ifp)->mi_shmid, 0, 0 )) == (char *)(-1L) )  {
		fb_log("sgi_getmem: shmat returned x%x, errno=%d\n", sp, errno );
		goto fail;
	}
#endif

success:
	ifp->if_mem = sp;
	ifp->if_cmap = sp + pixsize;	/* cmap at end of area */
	i = CMB(ifp)[255];		/* try to deref last word */
	CMB(ifp)[255] = i;

	/* Provide non-black colormap on creation of new shared mem */
	if(new)
		sgi_cminit( ifp );
	return(0);
fail:
	fb_log("sgi_getmem:  Unable to attach to shared memory.\nConsult comment in cad/libfb/if_4d.c for details\n");
	if( (sp = malloc( size )) == NULL )  {
		fb_log("sgi_getmem:  malloc failure\n");
		return(-1);
	}
	new = 1;
	goto success;
}

/*
 *			S G I _ Z A P M E M
 */
void
sgi_zapmem()
{
	int shmid;
	int i;

	if( (shmid = shmget( SHMEM_KEY, 0, 0 )) < 0 )  {
		fb_log("sgi_zapmem shmget failed, errno=%d\n", errno);
		return;
	}

	i = shmctl( shmid, IPC_RMID, 0 );
	if( i < 0 )  {
		fb_log("sgi_zapmem shmctl failed, errno=%d\n", errno);
		return;
	}
	fb_log("if_sgi: shared memory released\n");
}

/************************************************************************/

/*
 *			S G I _ X M I T _ S C A N L I N E S
 *
 *  Given the current window center, and the current zoom,
 *  transmit scanlines from the shared memory buffer.
 *
 *  On a non-GT, this routine copies scanlines from shared memory
 *  directly to the screen (window).  Zooming is done here.
 *
 *  On a GT machine, this routine copies scanlines from shared memory
 *  into the Z-buffer.
 *  The full image is stored in the Z-buffer.
 *  A separate routine is used to update some portion of the
 *  window from the Z-buffer copy, permitting high-speed pan and zoom.
 *
 *  Note that lrectwrite() addresses are relative to the pixel coordinates of
 *  the window, not the current viewport, as you might expect!
 *
 *  Normally, xbase=0 and npix = if_width.  For transmissions of
 *  less than one scanline, these may be different.
 */
_LOCAL_ void
sgi_xmit_scanlines( ifp, ybase, nlines, xbase, npix )
register FBIO	*ifp;
int		ybase;
int		nlines;
int		xbase;
int		npix;
{
	register int	y;
	register int	n;
	struct sgi_clip	clip;
	int		sw_cmap;	/* !0 => needs software color map */
	int		sw_zoom;	/* !0 => needs software zoom/pan */

	if( nlines > 1 )  {
		xbase = 0;
		npix = ifp->if_width;
	}

	winset(ifp->if_fd);

	if( SGI(ifp)->mi_is_gt )  {
		/* Enable writing pixels into the Z buffer */
		/* Always send full unzoomed image into Z buffer */
		rectzoom( 1.0, 1.0 );
		zbuffer(FALSE);
		zdraw(TRUE);
		backbuffer(FALSE);
		frontbuffer(FALSE);

		clip.xmin = clip.ymin = 0;
		clip.xscroff = clip.yscroff = 0;
		clip.xmax = ifp->if_width-1;
		clip.ymax = ifp->if_height-1;

		sw_zoom = 0;
	} else {
		/* Single buffered, direct to screen */
		if( ifp->if_zoomflag )  {
			sw_zoom = 1;
		} else {
			sw_zoom = 0;
		}
		if( ifp->if_xcenter != ifp->if_width/2 ||
		    ifp->if_ycenter != ifp->if_height/2 )  {
		    	sw_zoom = 1;
		}
		sgi_clipper( ifp, &clip );
	}

	if( (ifp->if_mode & MODE_7MASK) == MODE_7SWCMAP  &&
	    SGI(ifp)->mi_cmap_flag )  {
	    	sw_cmap = 1;
	} else {
		sw_cmap = 0;
	}

	/* Simplest case, nothing fancy */
	y = ybase;
	if( !sw_zoom && !sw_cmap )  {
		if( nlines == 1 )  {
			/*
			 *  Only a single line is being written,
			 *  and perhaps only part of the line width.
			 *  Just send it off.
			 */
			if( SGI(ifp)->mi_is_gt)
				lrectwrite(
					SGI(ifp)->mi_xoff+xbase,
					SGI(ifp)->mi_yoff+y,
					SGI(ifp)->mi_xoff+xbase+npix-1,
					SGI(ifp)->mi_yoff+y, 
					(unsigned long *) &ifp->if_mem[
					    (y*SGI(ifp)->mi_memwidth+xbase)*
					    sizeof(struct sgi_pixel)] );
			else
				fake_rectwrite(
					xbase,
					y,
					xbase+npix-1,
					y,
					&ifp->if_mem[(y*SGI(ifp)->mi_memwidth+xbase)*
					    sizeof(struct sgi_pixel)] );
			return;
		}
		/*
		 *  If lrectwrite() is asked to write scanlines wider
		 *  than a certain amount, it uses a sys-write call,
		 *  otherwise, it sends the pixels via programmed I/O.
		 *  Thus, if the width being sent is more than this
		 *  threshold, it is better just to make one call to
		 *  lrectwrite, and let the DMA send more data.
		 *  But, if a thin vertical strip of pixels is being
		 *  written, it makes more sense to call lrectwrite
		 *  once for each scanline, and the the PIO zap it off.
		 *  Alas, SGI never documents the threshold value;
		 *  the one here is pure guesswork.
		 *  Also note that on a VGX machine this might be
		 *  better accomplished with pixmode(PM_STRIDE,wds/scanline),
		 *  but no earlier models have this subroutine, sigh.
		 */
		if( npix > 32 && ifp->if_width == SGI(ifp)->mi_memwidth)  {
			/* Multiple line case, wide lines, matching sizes,
			 * send full lines
			 */
			if( SGI(ifp)->mi_is_gt)
				lrectwrite(
					SGI(ifp)->mi_xoff+0,
					SGI(ifp)->mi_yoff+y,
					SGI(ifp)->mi_xoff+0+ifp->if_width-1,
					SGI(ifp)->mi_yoff+y+nlines-1,
					(unsigned long *) &ifp->if_mem[
						(y*SGI(ifp)->mi_memwidth)*
						sizeof(struct sgi_pixel)] );
			else
				fake_rectwrite(
					0,
					y,
					0+ifp->if_width-1,
					y+nlines-1,
					&ifp->if_mem[(y*SGI(ifp)->mi_memwidth)*
					    sizeof(struct sgi_pixel)] );
			return;
		}
		/* Narrow width lines case */
		for( n=nlines; n>0; n--, y++ )  {
			/*
			 *  GTX is limited to about 1000 lrectwrites/sec,
			 *  when sending wide spans,
			 *  due to the fact that 1-scanline lrectwrites
			 *  are done with DMA.  The sys-call & interrupt
			 *  processing burns 60% of the CPU in sys-time!
			 */
			if( SGI(ifp)->mi_is_gt )
				lrectwrite(
					SGI(ifp)->mi_xoff+xbase,
					SGI(ifp)->mi_yoff+y,
					SGI(ifp)->mi_xoff+xbase+npix-1,
					SGI(ifp)->mi_yoff+y,
					(unsigned long *) &ifp->if_mem[
						(y*SGI(ifp)->mi_memwidth+xbase)*
						sizeof(struct sgi_pixel)] );
			else
				fake_rectwrite(
					xbase,
					y,
					xbase+npix-1,
					y,
					&ifp->if_mem[(y*SGI(ifp)->mi_memwidth+xbase)*
					    sizeof(struct sgi_pixel)] );
			xbase = 0;
			npix = ifp->if_width;
		}
		return;
	}

	if( !sw_zoom && sw_cmap )  {
		register int	x;
		register struct sgi_pixel	*sgip;
		register struct sgi_pixel	*op;

		/* Perform software color mapping into temp scanline */
		op = SGI(ifp)->mi_scanline;
		for( n=nlines; n>0; n--, y++ )  {
			sgip = (struct sgi_pixel *)&ifp->if_mem[
				(y*SGI(ifp)->mi_memwidth)*
				sizeof(struct sgi_pixel) ];
			for( x=ifp->if_width-1; x>=0; x-- )  {
				op[x].red   = CMR(ifp)[sgip[x].red];
				op[x].green = CMG(ifp)[sgip[x].green];
				op[x].blue  = CMB(ifp)[sgip[x].blue];
			}
			if( SGI(ifp)->mi_is_gt )		
				lrectwrite(
					SGI(ifp)->mi_xoff+0,
					SGI(ifp)->mi_yoff+y,
					SGI(ifp)->mi_xoff+0+ifp->if_width-1,
					SGI(ifp)->mi_yoff+y,
					(unsigned long *) op );
			else
				fake_rectwrite(
					0,
					y,
					0+ifp->if_width-1,
					y,
					op );
		}
		return;
	}

	/*
	 *  All code below is to handle software zooming on non-GT machines.
	 */

	/* Blank out area left of image */
	RGBcolor( 0, 0, 0 );
	if( clip.xscroff > 0 )  rectfs(
		0,
		0,
		(Scoord) clip.xscroff-1,
		(Scoord) ifp->if_height-1 );

	/* Blank out area below image */
	if( clip.yscroff > 0 )  rectfs(
		0,
		0,
		(Scoord) ifp->if_width-1,
		(Scoord) clip.yscroff-1 );

	/* Blank out area right of image */
	if( clip.xscrpad > 0 )  rectfs(
		(Scoord) ifp->if_width-clip.xscrpad-1,
		0,
		(Scoord) ifp->if_width-1,
		(Scoord) ifp->if_height-1 );

	/* Blank out area above image */
	if( clip.yscrpad > 0 )  rectfs(
		0,
		(Scoord) ifp->if_height-clip.yscrpad-1,
		(Scoord) ifp->if_width-1,
		(Scoord) ifp->if_height-1 );

	/* Output pixels in zoomed condition */
	{
		register int	rep;
		register int	yscr;
		register int	xscrmin, xscrmax;
		register struct sgi_pixel	*sgip, *op;

		/*
		 *  From memory starting at (xmin, ymin) to
		 *  screen starting at (xscroff, yscroff).
		 *  Memory addresses increment by 1.
		 *  Screen addresses increment by mi_?zoom.
		 */
		yscr = SGI(ifp)->mi_yoff + clip.yscroff + y * ifp->if_yzoom;
		xscrmin = SGI(ifp)->mi_xoff+clip.xscroff;
		xscrmax = SGI(ifp)->mi_xoff+ifp->if_width-1-clip.xscrpad;
		for( n=nlines; n>0; n--, y++ )  {
			register int	x;

			if( y < clip.ymin )  continue;
			if( y > clip.ymax )  continue;

			/* widen this line */
			sgip = (struct sgi_pixel *)&ifp->if_mem[
				(y*SGI(ifp)->mi_memwidth+clip.xmin)*
				sizeof(struct sgi_pixel)];
			op = SGI(ifp)->mi_scanline;
			for( x=clip.xmin; x<=clip.xmax; x++ )  {
				for( rep=0; rep<ifp->if_xzoom; rep++ )  {
					*op++ = *sgip;	/* struct copy */
				}
				sgip++;
				}
			if( sw_cmap )  {
				x=(clip.xmax-clip.xmin)*ifp->if_xzoom;
				op = SGI(ifp)->mi_scanline;
				for( ; x>=0; x-- )  {
					op[x].red   = CMR(ifp)[op[x].red];
					op[x].green = CMG(ifp)[op[x].green];
					op[x].blue  = CMB(ifp)[op[x].blue];
				}
			}
			/* X direction replication is handled above,
			 * Y direction replication is done by this loop.
			 */
			for( rep=0; rep<ifp->if_yzoom; rep++ )  {
				if( SGI(ifp)->mi_is_gt )
					lrectwrite(
						xscrmin, yscr,
						xscrmax, yscr,
						(unsigned long *) 
							SGI(ifp)->mi_scanline );
				else
					fake_rectwrite(
						xscrmin - SGI(ifp)->mi_xoff,
						yscr - SGI(ifp)->mi_yoff,
						xscrmax - SGI(ifp)->mi_xoff,
						yscr - SGI(ifp)->mi_yoff,
						SGI(ifp)->mi_scanline );
				yscr++;
			}
		}
		return;
	}
}

/*
 *			S I G K I D
 */
static void sigkid()
{
	exit(0);
}

/************************************************************************/
/************************************************************************/
/************************************************************************/
/************** Routines to implement the libfb interface ***************/
/************************************************************************/
/************************************************************************/
/************************************************************************/

/*
 *			S G I _ O P E N
 */
_LOCAL_ int
sgi_open( ifp, file, width, height )
FBIO	*ifp;
char	*file;
int	width, height;
{
	int	f;
	int	status;
	static char	title[128];
	int		mode;
	inventory_t	*inv;

	FB_CK_FBIO(ifp);

	/*
	 *  First, attempt to determine operating mode for this open,
	 *  based upon the "unit number" or flags.
	 *  file = "/dev/sgi###"
	 *  The default mode is zero.
	 */
	mode = 0;

	if( file != NULL )  {
		register char *cp;
		char	modebuf[80];
		char	*mp;
		int	alpha;
		struct	modeflags *mfp;

		if( strncmp(file, "/dev/sgi", 8) ) {
			/* How did this happen?? */
			mode = 0;
		} else {
			/* Parse the options */
			alpha = 0;
			mp = &modebuf[0];
			cp = &file[8];
			while( *cp != '\0' && !isspace(*cp) ) {
				*mp++ = *cp;	/* copy it to buffer */
				if( isdigit(*cp) ) {
					cp++;
					continue;
				}
				alpha++;
				for( mfp = modeflags; mfp->c != '\0'; mfp++ ) {
					if( mfp->c == *cp ) {
						mode = (mode&~mfp->mask)|mfp->value;
						break;
					}
				}
				if( mfp->c == '\0' && *cp != '-' ) {
					fb_log( "if_4d: unknown option '%c' ignored\n", *cp );
				}
				cp++;
			}
			*mp = '\0';
			if( !alpha )
				mode = atoi( modebuf );
		}

		if( (mode & MODE_15MASK) == MODE_15ZAP ) {
			/* Only task: Attempt to release shared memory segment */
			sgi_zapmem();
			return(-1);
		}
	}
	ifp->if_mode = mode;

	/*
	 *  Allocate extension memory section,
	 *  addressed by SGI(ifp)->mi_xxx
	 */
	if( (SGIL(ifp) = (char *)calloc( 1, sizeof(struct sgiinfo) )) == NULL )  {
		fb_log("sgi_open:  sgiinfo malloc failed\n");
		return(-1);
	}
	SGI(ifp)->mi_shmid = -1;	/* indicate no shared memory */

	/* the Silicon Graphics Library Window management routines
	 * use shared memory. This causes lots of problems when you
	 * want to pass a window structure to a child process.
	 * One hack to get around this is to immediately fork
	 * and create a child process and sleep until the child
	 * sends a kill signal to the parent process. (in FBCLOSE)
	 * This allows us to use the traditional fb utility programs 
	 * as well as allow the frame buffer window to remain around
	 * until killed by the menu subsystem.
    	 */
	if( (ifp->if_mode & MODE_2MASK) == MODE_2LINGERING )  {
		/* save parent pid for later signalling */
		SGI(ifp)->mi_parent = getpid();

		signal( SIGUSR1, sigkid);

		if( (f = fork()) > 0 )  {
			/* Parent process */
			int k;
			for(k=0; k< 20; k++)  {
				(void) close(k);
			}

			/*
			 *  Wait until the child dies, of whatever cause,
			 *  or until the child kills us.
			 *  Pretty vicious, this computer society.
			 */
			while( (k = wait(&status)) != -1 && k != f )
				/* NULL */ ;

			exit(0);
			/* NOTREACHED */
		} else if( f < 0 )  {
			fb_log("sgi_open:  linger-mode fork failure\n");
			return(-1);
		}
		/* Child Process falls through */
	}

	/*
	 *  Take inventory of the hardware
	 */
	while( (inv = getinvent()) != (inventory_t *)0 )  {
		if( inv->class != INV_GRAPHICS )  continue;
		switch( inv->type )  {
		case INV_GMDEV:
			SGI(ifp)->mi_is_gt = 1;
			break;
		case INV_GR2:
			SGI(ifp)->mi_is_gt = 1;
			break;
		}
	}
	endinvent();		/* frees internal inventory memory */
	if( (ifp->if_mode & MODE_8MASK) == MODE_8NOGT )  {
		SGI(ifp)->mi_is_gt = 0;
	}

	if( (ifp->if_mode & MODE_5MASK) == MODE_5NTSC )  {
		/* NTSC, see below */
		ifp->if_width = ifp->if_max_width = XMAX170+1;	/* 646 */
		ifp->if_height = ifp->if_max_height = YMAX170+1; /* 485 */
	} else if( (ifp->if_mode & MODE_3MASK) == MODE_3FULLSCR )  {
		/* Bump default size up to full screen, since we have it all */
		ifp->if_width = XMAXSCREEN+1;		/* 1280 */
		ifp->if_height = YMAXSCREEN+1;		/* 1024 */
	}

	if( width <= 0 )
		width = ifp->if_width;
	if( height <= 0 )
		height = ifp->if_height;
	if ( width > ifp->if_max_width )
		width = ifp->if_max_width;
	if ( height > ifp->if_max_height)
		height = ifp->if_max_height;

	ifp->if_width = width;
	ifp->if_height = height;

#if 0
	blanktime(0);
#endif
	foreground();		/* Direct focus here, don't detach */

	if( (ifp->if_mode & MODE_5MASK) == MODE_5NTSC )  {
		noborder();
#if defined(__sgi) && defined(__mips)
		/* Deal with Irix 4.0 bug:  (+2,+21) offset due to title */
		prefposition( 0-2, XMAX170-2, 0+21, YMAX170+21 );
#else
		prefposition( 0, XMAX170, 0, YMAX170 );
#endif
		SGI(ifp)->mi_curs_on = 0;	/* cursoff() happens below */
	} else if( (ifp->if_mode & MODE_3MASK) == MODE_3WINDOW )  {
		if( sgi_nwindows == 0 ) {
			prefposition( WIN_L, WIN_R, WIN_B, WIN_T );
		} else {
			prefsize( (long)width, (long)height );
		}
		SGI(ifp)->mi_curs_on = 1;	/* Mex usually has it on */
	}  else  {
		/* MODE_3MASK == MODE_3FULLSCR */
		noborder();
#if defined(__sgi) && defined(__mips)
		/* Deal with Irix 4.0 bug:  (+2,+21) offset due to title */
		prefposition( 0-2, XMAXSCREEN-2, 0+21, YMAXSCREEN+21 );
#else
		prefposition( 0, XMAXSCREEN, 0, YMAXSCREEN );
#endif
		SGI(ifp)->mi_curs_on = 0;	/* cursoff() happens below */
	}

	/*
	 *  This is where the window constraints specified above
	 *  are bound to a new window.  The return code is
	 *  the "graphics id" that identifies this window.
	 *  winset(gr_id) is used to select a window for drawing in.
	 */
	if( (ifp->if_fd = winopen( "Frame buffer" )) == -1 )  {
		fb_log( "winopen() failed, no more windows available.\n" );
		return(-1);
	}
	sgi_nwindows++;		/* track # of simultaneous windows */

	/*  Establish operating mode (Hz, GENLOCK).
	 *  The assumption is that the device is always in the
	 *  "normal" mode to start with.  The mode will only
	 *  be saved and restored when 30Hz operation is specified;
	 *  on GENLOCK operation, valid NTSC sync pulses must be present
	 *  for downstream equipment;  user should run "Set60" when done.
	 */
	if( (ifp->if_mode & MODE_4MASK) == MODE_4HZ30 )  {
		SGI(ifp)->mi_der1 = getvideo(DE_R1);
		if( (ifp->if_mode & MODE_10MASK) == MODE_10SYNC_ON_GREEN )  {
			/* 3-wire */
			setvideo( DE_R1, DER1_30HZ|DER1_UNBLANK|DER1_SYNCG );
		} else {
			/* 4-wire RS-343 */
			setvideo( DE_R1, DER1_30HZ|DER1_UNBLANK);
		}
	} else if( (ifp->if_mode & MODE_5MASK) == MODE_5NTSC )  {
		int	new_der1;

		SGI(ifp)->mi_der1 = getvideo(DE_R1);
		if( (SGI(ifp)->mi_der1 & DER1_VMASK) == DER1_170 )  {
			/* 
			 *  Current mode is DE3 board internal NTSC sync.
			 *  Doing a setmonitor(NTSC) again will cause the
			 *  sync generator to drop out for a moment.
			 *  So, in this case, do nothing.
			 */
		} else if( getvideo(CG_MODE) != -1 )  {
		    	/*
			 *  Optional CG2 GENLOCK board is installed.
			 *
			 *  Mode 2:  Internal sync generator is used.
			 *
			 *  Note that the stability of the sync generator
			 *  on the GENLOCK board is *worse* than the sync
			 *  generator on the regular DE3 board.  The GENLOCK
			 *  version "twitches" every second or so.
			 *
			 *  Mode 3:  Output is locked to incoming
			 *  NTSC composite video picture
		    	 *  for sync and chroma (on "REM IN" connector).
		    	 *  Color subcarrier is phase and amplitude locked to
		    	 *  incomming color burst.
		    	 *  The blue LSB has no effect on video overlay.
			 *
			 *  Note that the generated composite NTSC output
			 *  (on "VID OUT" connector) is often a problem,
			 *  since it has a DC offset of +0.3V to the base
			 *  of the sync pulse, while other studio eqiupment
			 *  often expects the blanking level to be at
			 *  exactly 0.0V, with sync at -0.3V.
			 *  In this case, the black leves are ruined.
			 *  Also, the inboard encoder chip isn't very good.
			 *  Therefore, it is necessary to use an outboard
			 *  RS-170 to NTSC encoder to get useful results.
		    	 */
			if( (ifp->if_mode & MODE_6MASK) == MODE_6EXTSYNC )  {
				/* external sync via GENLOCK board REM IN */
			    	setvideo(CG_MODE, CG2_M_MODE3);
				new_der1 = DER1_G_170;
			} else {
				/* internal sync */
				/* Just use DE3 sync generator.
				 * For this case, GENLOCK board does nothing!
				 * Equiv to setmonitor(NTSC);
				 */
				new_der1 = DER1_170;
			}
		} else {
			/*
			 *  No genlock board is installed, produce RS-170
			 *  video at NTSC rates with separate sync,
			 *  and hope that they have an outboard NTSC
			 *  encoder device.  Equiv to setmonitor(NTSC);
			 */
			new_der1 = DER1_170;
		}
		if( (ifp->if_mode & MODE_10MASK) == MODE_10SYNC_ON_GREEN )
			new_der1 |= DER1_SYNCG;
		setvideo( DE_R1, new_der1|DER1_UNBLANK );
	}

	/* Build a descriptive window title bar */
	(void)sprintf( title, "BRL libfb /dev/sgi %s, %s",
		((ifp->if_mode & MODE_2MASK) == MODE_2TRANSIENT) ?
			"Transient Win" :
			"Lingering Win",
		((ifp->if_mode & MODE_1MASK) == MODE_1MALLOC) ?
			"Private Mem" :
			"Shared Mem" );
	wintitle( title );
	
	/*
	 *  Set the operating mode for the newly created window.
	 */
	if( (ifp->if_mode & MODE_12MASK) == MODE_12DELAY_WRITES_TILL_FLUSH )
		SGI(ifp)->mi_is_gt = 0;
	if( SGI(ifp)->mi_is_gt )  {
		if( (ifp->if_mode & MODE_9MASK) == MODE_9SINGLEBUF )  {
			singlebuffer();
			SGI(ifp)->mi_doublebuffer = 0;
		} else {
			doublebuffer();
			SGI(ifp)->mi_doublebuffer = 1;
		}
	} else {
		singlebuffer();
		SGI(ifp)->mi_doublebuffer = 0;
	}
	RGBmode();
	gconfig();	/* Must be called after singlebuffer() & RGBmode() */

	/* Clean out images that might remain from windows underneath */
	RGBcolor( (short)0, (short)0, (short)0 );
	clear();
	if( SGI(ifp)->mi_doublebuffer == 1 )  {
		swapbuffers();
		clear();
	}

	/*
	 *  Must initialize these window state variables BEFORE calling
	 *  "sgi_getmem", because this function can indirectly trigger
	 *  a call to "gt_zbuf_to_screen" (when initializing shared memory
	 *  after a reboot).
	 */
	ifp->if_zoomflag = 0;
	ifp->if_xzoom = 1;	/* for zoom fakeout */
	ifp->if_yzoom = 1;	/* for zoom fakeout */
	ifp->if_xcenter = width/2;
	ifp->if_ycenter = height/2;
	SGI(ifp)->mi_xoff = 0;
	SGI(ifp)->mi_yoff = 0;
	SGI(ifp)->mi_pid = getpid();

	/*
	 *  In full screen mode, center the image on the screen.
	 *  For the SGI machines, this is done via mi_xoff, rather
	 *  than with viewport/ortho2 calls, because lrectwrite()
	 *  uses window-relative, NOT viewport-relative addresses.
	 */
	if( (ifp->if_mode & MODE_3MASK) == MODE_3FULLSCR )  {
		int	xleft, ybot;

		xleft = (ifp->if_max_width)/2 - ifp->if_width/2;
		ybot = (ifp->if_max_height)/2 - ifp->if_height/2;
		/* These may be necessary for cursor aiming? */
		viewport( xleft, xleft + ifp->if_width,
			  ybot, ybot + ifp->if_height );
		ortho2( (Coord)0, (Coord)ifp->if_width,
			(Coord)0, (Coord)ifp->if_height );
		/* The real secret:  used to modify args to lrectwrite() */
		SGI(ifp)->mi_xoff = xleft;
		SGI(ifp)->mi_yoff = ybot;
		/* set input focus to current window, so that
		 * we can manipulate the cursor icon */
		winattach();
	}

	/* Attach to shared memory, potentially with a screen repaint */
	if( sgi_getmem(ifp) < 0 )
		return(-1);

	/* Must call "is_linear_cmap" AFTER "sgi_getmem" which allocates
		space for the color map.				*/
	SGI(ifp)->mi_cmap_flag = !is_linear_cmap(ifp);
	if( (ifp->if_mode & MODE_7MASK) != MODE_7SWCMAP  &&
	    SGI(ifp)->mi_cmap_flag )  {
		/* Send color map to hardware -- affects whole screen */
		gammaramp( CMR(ifp), CMG(ifp), CMB(ifp) );
	}

	/* Setup default cursor.					*/
	defcursor( 1, cursor );
	defcursor( 2, nilcursor );
	curorigin( 1, 0, 0 );
	drawmode( CURSORDRAW );
	mapcolor( 1, 255, 0, 0 );
	drawmode( NORMALDRAW );
	setcursor(1, 1, 0);

	if( SGI(ifp)->mi_curs_on == 0 )  {
		setcursor( 2, 1, 0 );		/* nilcursor */
		cursoff();
	}

	/*
	 *  Display the existing contents of the memory segment.
	 *  Make no assumptions about the state of the window.
	 */
	if( (ifp->if_mode & MODE_12MASK) != MODE_12DELAY_WRITES_TILL_FLUSH )  {
		sgi_xmit_scanlines( ifp, 0, ifp->if_height, 0, ifp->if_width );
		if( SGI(ifp)->mi_is_gt )  {
			gt_zbuf_to_screen( ifp, -1 );
		}
	}

	/* Make the file descriptor available for selecting on */
	ifp->if_selfd = qgetfd();
	if( ifp->if_selfd < 0 )
		ifp->if_selfd = -1;	/* in case of errors */

	return	0;
}

/*
 *			S G I _ F I N A L _ C L O S E
 *
 *  Handle the real work of restoring the state of the hardware and
 *  closing the window.
 */
_LOCAL_ int
sgi_final_close( ifp )
FBIO	*ifp;
{
#if 0
	/*
	 *  User is finally done with the frame buffer,
	 *  return control to our caller (who may have more to do).
	 *  set a 20 minute screensave blanking when fb is closed.
	 *  We have no way of knowing if there are other libfb windows
	 *  still open.
	 */
#if 0
	blanktime( (long) 67 * 60 * 20L );
#else
	/*
	 *  Set an 8 minute screensaver blanking, which will light up
	 *  the screen again if it was dark, and will protect it otherwise.
	 *  The 4D has a hardware botch limiting the time to 2**15 frames.
	 */
	blanktime( (long) 32767L );
#endif
#endif

	/* Restore initial operation mode, if this was 30Hz */
	if( (ifp->if_mode & MODE_4MASK) == MODE_4HZ30 )
		setvideo( DE_R1, SGI(ifp)->mi_der1 );

	/*
	 *  Note that for the MODE_5NTSC mode, the monitor will
	 *  be left in NTSC mode until the user issues a "Set60"
	 *  command.  This is vitally necessary because the Lyon-
	 *  Lamb and VTR equipment need a stedy source of NTSC sync
	 *  pulses while in the process of laying down frames.
	 */

	/* Always leave cursor on when done */
	if( SGI(ifp)->mi_curs_on == 0 )  {
		setcursor( 0, 1, 0 );		/* system default cursor */
		curson();
	}

	winclose( ifp->if_fd );		/* close window */

	if( SGIL(ifp) != NULL ) {
		/* free up memory associated with image */
		if( SGI(ifp)->mi_shmid != -1 ) {
			/* detach from shared memory */
			if( shmdt( ifp->if_mem ) == -1 ) {
				fb_log("sgi_close shmdt failed, errno=%d\n", errno);
				return -1;
			}
		} else {
			/* free private memory */
			(void)free( ifp->if_mem );
		}
		/* free state information */
		(void)free( (char *)SGIL(ifp) );
		SGIL(ifp) = NULL;
	}

	sgi_nwindows--;
	return(0);
}

/*
 *			S G I _ P O L L
 *
 *  Handle input events.
 */
_LOCAL_ int
sgi_poll( ifp )
FBIO	*ifp;
{
	while( qtest() )
		sgi_inqueue(ifp);
	return 0;
}

/*
 *			S G I _ F R E E
 *
 *  Free shared memory resources, and close.
 */
_LOCAL_ int
sgi_free( ifp )
FBIO	*ifp;
{
	int	ret;

	/* Close the framebuffer */
	ret = sgi_final_close( ifp );

	if( (ifp->if_mode & MODE_1MASK) == MODE_1SHARED ) {
		/* If shared mem, release the shared memory segment */
		sgi_zapmem();
	}
	return ret;
}

/*
 *			S G I _ C L O S E
 *
 */
_LOCAL_ int
sgi_close( ifp )
FBIO	*ifp;
{
	int menu, menuval, dev;
	short val;
	FILE *fp = NULL;

	winset(ifp->if_fd);

	sgi_flush(ifp);

	if( sgi_nwindows > 1 ||
	    (ifp->if_mode & MODE_2MASK) == MODE_2TRANSIENT )
		return sgi_final_close( ifp );

	/*
	 *  LINGER mode.  Don't return to caller until user mouses "close"
	 *  menu item.  This may delay final processing in the calling
	 *  function for some time, but the assumption is that the user
	 *  wishes to compare this image with others.
	 *
	 *  Since we plan to linger here, long after our invoker
	 *  expected us to be gone, be certain that no file descriptors
	 *  remain open to associate us with pipelines, network
	 *  connections, etc., that were ALREADY ESTABLISHED before
	 *  the point that fb_open() was called.
	 *
	 *  The simple for i=0..20 loop will not work, because that
	 *  smashes some window-manager files.  Therefore, we content
	 *  ourselves with eliminating stdin, stdout, and stderr,
	 *  (fd 0,1,2), in the hopes that this will successfully
	 *  terminate any pipes or network connections.  In the case
	 *  of calls from rfbd, in normal (non -d) mode, it gets the
	 *  network connection on stdin/stdout, so this is adequate.
	 */
	fclose( stdin );
	fclose( stdout );
	fclose( stderr );

	/* Ignore likely signals, perhaps in the background,
	 * from other typing at the keyboard
	 */
	(void)signal( SIGHUP, SIG_IGN );
	(void)signal( SIGINT, SIG_IGN );
	(void)signal( SIGQUIT, SIG_IGN );
	(void)signal( SIGALRM, SIG_IGN );

	/* Line up at the "complaints window", just in case... */
	fp = fopen("/dev/console", "w");

	kill(SGI(ifp)->mi_parent, SIGUSR1);	/* zap the lurking parent */

	menu = defpup("close");
	qdevice(RIGHTMOUSE);
	qdevice(REDRAW);
	
	while(1)  {
		val = 0;
		dev = qread( &val );
		switch( dev )  {

		case NULLDEV:
			/* don't process a null device */
			break;

		case RIGHTMOUSE:
			menuval = dopup( menu );
			if (menuval == 1 )
				goto out;
			break;

		case REDRAW:
			reshapeviewport();
			sgi_xmit_scanlines(ifp, 0, ifp->if_height,
				0, ifp->if_width);
			if( SGI(ifp)->mi_is_gt )  {
				gt_zbuf_to_screen(ifp, -1);
			}
			break;

		case INPUTCHANGE:
		case CURSORX:
		case CURSORY:
			/* We don't need to do anything about these */
			break;

		case QREADERROR:
			/* These are fatal errors, bail out */
			if( fp ) fprintf(fp,"libfb/sgi_close: qreaderror, aborting\n");
			goto out;

		default:
			/*
			 *  There is a tendency for infinite loops
			 *  here.  With only a few qdevice() attachments
			 *  done above, there shouldn't be too many
			 *  unexpected things.  But, lots show up.
			 *  At least this gives visibility.
			 */
			if( fp ) fprintf(fp,"libfb/sgi_close: qread %d, val %d\r\n", dev, val );
			break;
		}
	}
out:
	if( fp ) fclose(fp);		/* close our "complaints window" */

	return sgi_final_close( ifp );
}

/*
 *			S G I _ C L E A R
 */
_LOCAL_ int
sgi_clear( ifp, pp )
FBIO	*ifp;
register unsigned char	*pp;
{
	struct sgi_pixel	bg;
	register struct sgi_pixel	*sgip;
	register int	cnt;
	register int	y;

	winset(ifp->if_fd);

	if( qtest() )
		sgi_inqueue(ifp);

	if ( pp != RGBPIXEL_NULL)  {
		bg.alpha = 0;
		bg.red   = (pp)[RED];
		bg.green = (pp)[GRN];
		bg.blue  = (pp)[BLU];
		RGBcolor((short)((pp)[RED]), (short)((pp)[GRN]), (short)((pp)[BLU]));
	} else {
		bg.alpha = 0;
		bg.red   = 0;
		bg.green = 0;
		bg.blue  = 0;
		RGBcolor( (short) 0, (short) 0, (short) 0);
	}

	/* Flood rectangle in shared memory */
	for( y=0; y < ifp->if_height; y++ )  {
		sgip = (struct sgi_pixel *)&ifp->if_mem[
		    (y*SGI(ifp)->mi_memwidth+0)*sizeof(struct sgi_pixel) ];
		for( cnt=ifp->if_width-1; cnt >= 0; cnt-- )  {
			*sgip++ = bg;	/* struct copy */
		}
	}

	if( SGI(ifp)->mi_is_gt )  {
		sgi_xmit_scanlines( ifp, 0, ifp->if_height,
			0, ifp->if_width );
		gt_zbuf_to_screen(ifp, -1);
	} else {
		clear();
	}
	return(0);
}

/*
 *			S G I _ V I E W
 */
_LOCAL_ int
sgi_view( ifp, xcenter, ycenter, xzoom, yzoom )
FBIO	*ifp;
int	xcenter, ycenter;
int	xzoom, yzoom;
{

	winset(ifp->if_fd);

	if( qtest() )
		sgi_inqueue(ifp);

	if( xzoom < 1 ) xzoom = 1;
	if( yzoom < 1 ) yzoom = 1;
	if( ifp->if_xcenter == xcenter && ifp->if_ycenter == ycenter
	  && ifp->if_xzoom == xzoom && ifp->if_yzoom == yzoom )
		return(0);

	if( xcenter < 0 || xcenter >= ifp->if_width )
		return(-1);
	if( ycenter < 0 || ycenter >= ifp->if_height )
		return(-1);
	if( xzoom >= ifp->if_width || yzoom >= ifp->if_height )
		return(-1);

	ifp->if_xcenter = xcenter;
	ifp->if_ycenter = ycenter;
	ifp->if_xzoom = xzoom;
	ifp->if_yzoom = yzoom;

	if( ifp->if_xzoom > 1 || ifp->if_yzoom > 1 )
		ifp->if_zoomflag = 1;
	else	ifp->if_zoomflag = 0;

	if( SGI(ifp)->mi_is_gt )  {
		/* Transmitting the Zbuffer is all that is needed */
		gt_zbuf_to_screen( ifp, -1 );
	} else {
		sgi_xmit_scanlines( ifp, 0, ifp->if_height, 0, ifp->if_width );
	}
	return(0);
}

/*
 *			S G I _ G E T V I E W
 */
_LOCAL_ int
sgi_getview( ifp, xcenter, ycenter, xzoom, yzoom )
FBIO	*ifp;
int	*xcenter, *ycenter;
int	*xzoom, *yzoom;
{

	winset(ifp->if_fd);

	if( qtest() )
		sgi_inqueue(ifp);

	*xcenter = ifp->if_xcenter;
	*ycenter = ifp->if_ycenter;
	*xzoom = ifp->if_xzoom;
	*yzoom = ifp->if_yzoom;

	return(0);
}

/*
 *			S G I _ R E A D
 *
 *  Makes no reference to the graphics library at all.
 *  Data is copied from the memory segment.
 */
_LOCAL_ int
sgi_read( ifp, x, y, pixelp, count )
FBIO	*ifp;
int	x, y;
unsigned char	*pixelp;
int	count;
{
	register short		scan_count;	/* # pix on this scanline */
	register unsigned char	*cp;
	int			ret;
	register unsigned int	n;
	register struct sgi_pixel	*sgip;

	if( x < 0 || x >= ifp->if_width ||
	    y < 0 || y >= ifp->if_height)
		return(-1);

	ret = 0;
	cp = (unsigned char *)(pixelp);

	while( count )  {
		if( y >= ifp->if_height )
			break;

		if ( count >= ifp->if_width-x )
			scan_count = ifp->if_width-x;
		else
			scan_count = count;

		sgip = (struct sgi_pixel *)&ifp->if_mem[
		    (y*SGI(ifp)->mi_memwidth+x)*sizeof(struct sgi_pixel) ];

		n = scan_count;
		while( n )  {
			cp[RED] = sgip->red;
			cp[GRN] = sgip->green;
			cp[BLU] = sgip->blue;
			sgip++;
			cp += 3;
			n--;
		}
		ret += scan_count;
		count -= scan_count;
		x = 0;
		/* Advance upwards */
		if( ++y >= ifp->if_height )
			break;
	}
	return(ret);
}

/*
 *			S G I _ W R I T E
 *
 *  The task of this routine is to reformat the pixels into
 *  SGI internal form, and then arrange to have them sent to
 *  the screen separately.
 */
_LOCAL_ int
sgi_write( ifp, xstart, ystart, pixelp, count )
register FBIO	*ifp;
int		xstart;
int		ystart;
const unsigned char	*pixelp;
int		count;
{
	register short		scan_count;	/* # pix on this scanline */
	register unsigned char	*cp;
	int			ret;
	int			ybase;
	register int		pix_count;	/* # pixels to send */
	register int		x;
	register int		y;

	/* lrectwrite dies on 0 count */
	if( (pix_count = count) == 0 )
		return 0;	/* OK, no pixels transferred */
	if( pix_count < 0 )
		return -1;	/* ERROR */

	x = xstart;
	ybase = y = ystart;

	if( x < 0 || x >= ifp->if_width ||
	    y < 0 || y >= ifp->if_height)
		return(-1);

	ret = 0;
	cp = (unsigned char *)(pixelp);

	while( pix_count )  {
		register unsigned int n;
		register struct sgi_pixel	*sgip;

		if( y >= ifp->if_height )
			break;

		if ( pix_count >= ifp->if_width-x )
			scan_count = ifp->if_width-x;
		else
			scan_count = pix_count;

		sgip = (struct sgi_pixel *)&ifp->if_mem[
		    (y*SGI(ifp)->mi_memwidth+x)*sizeof(struct sgi_pixel) ];

		n = scan_count;
		if( (n & 3) != 0 )  {
			/* This code uses 60% of all CPU time */
			while( n )  {
				/* alpha channel is always zero */
				sgip->red   = cp[RED];
				sgip->green = cp[GRN];
				sgip->blue  = cp[BLU];
				sgip++;
				cp += 3;
				n--;
			}
		} else {
			while( n )  {
				/* alpha channel is always zero */
				sgip[0].red   = cp[RED+0*3];
				sgip[0].green = cp[GRN+0*3];
				sgip[0].blue  = cp[BLU+0*3];
				sgip[1].red   = cp[RED+1*3];
				sgip[1].green = cp[GRN+1*3];
				sgip[1].blue  = cp[BLU+1*3];
				sgip[2].red   = cp[RED+2*3];
				sgip[2].green = cp[GRN+2*3];
				sgip[2].blue  = cp[BLU+2*3];
				sgip[3].red   = cp[RED+3*3];
				sgip[3].green = cp[GRN+3*3];
				sgip[3].blue  = cp[BLU+3*3];
				sgip += 4;
				cp += 3*4;
				n -= 4;
			}
		}
		ret += scan_count;
		pix_count -= scan_count;
		x = 0;
		if( ++y >= ifp->if_height )
			break;
	}

	/*
	 * Handle events after updating the memory, and
	 * before updating the screen
	 */
	winset(ifp->if_fd);

	if( qtest() )
		sgi_inqueue(ifp);

	if( (ifp->if_mode & MODE_12MASK) == MODE_12DELAY_WRITES_TILL_FLUSH )
		return ret;

	if( xstart + count <= ifp->if_width  )  {
		/* "Fast path" case for writes of less than one scanline */
		if( SGI(ifp)->mi_doublebuffer )  {
			singlebuffer();
			SGI(ifp)->mi_doublebuffer = 0;
			gconfig();
		}
		sgi_xmit_scanlines( ifp, ybase, 1, xstart, count );
		if( SGI(ifp)->mi_is_gt )  {
			/* repaint one scanline from Z buffer */
			gt_zbuf_to_screen( ifp, ybase );
		}
	} else {
		/* Normal case -- multi-pixel write */
		sgi_xmit_scanlines( ifp, ybase, y-ybase, 0, ifp->if_width );
		if( SGI(ifp)->mi_is_gt )  {
			/* repaint whole screen from Z buffer */
			gt_zbuf_to_screen( ifp, -1 );
		}
	}
	return(ret);
}

/*
 *			S G I _ W R I T E R E C T
 *
 *  The task of this routine is to reformat the pixels into
 *  SGI internal form, and then arrange to have them sent to
 *  the screen separately.
 */
_LOCAL_ int
sgi_writerect( ifp, xmin, ymin, width, height, pp )
FBIO		*ifp;
int		xmin, ymin;
int		width, height;
const unsigned char	*pp;
{
	register int		x;
	register int		y;
	register unsigned char	*cp;
	register struct sgi_pixel	*sgip;

	if( width <= 0 || height <= 0 )
		return(0);
	if( xmin < 0 || xmin+width > ifp->if_width ||
	    ymin < 0 || ymin+height > ifp->if_height )
		return(-1);

	cp = (unsigned char *)(pp);
	for( y = ymin; y < ymin+height; y++ )  {
		sgip = (struct sgi_pixel *)&ifp->if_mem[
		    (y*SGI(ifp)->mi_memwidth+xmin)*sizeof(struct sgi_pixel) ];
		for( x = xmin; x < xmin+width; x++ )  {
			/* alpha channel is always zero */
			sgip->red   = cp[RED];
			sgip->green = cp[GRN];
			sgip->blue  = cp[BLU];
			sgip++;
			cp += 3;
		}
	}

	/*
	 * Handle events after updating the memory, and
	 * before updating the screen
	 */
	winset(ifp->if_fd);

	if( qtest() )
		sgi_inqueue(ifp);

	if( (ifp->if_mode & MODE_12MASK) != MODE_12DELAY_WRITES_TILL_FLUSH )  {
		sgi_xmit_scanlines( ifp, ymin, height, 0, ifp->if_width );
		if( SGI(ifp)->mi_is_gt )  {
			/* repaint screen from Z buffer */
			gt_zbuf_to_screen( ifp, -1 );
		}
	}
	return(width*height);
}

/*
 *			S G I _ R M A P
 *
 *  Make no access to the graphics system at all.
 */
_LOCAL_ int
sgi_rmap( ifp, cmp )
register FBIO	*ifp;
register ColorMap	*cmp;
{
	register int i;

	/* Just parrot back the stored colormap */
	for( i = 0; i < 256; i++)  {
		cmp->cm_red[i]   = CMR(ifp)[i]<<8;
		cmp->cm_green[i] = CMG(ifp)[i]<<8;
		cmp->cm_blue[i]  = CMB(ifp)[i]<<8;
	}
	return(0);
}

/*
 *			I S _ L I N E A R _ C M A P
 *
 *  Check for a color map being linear in R, G, and B.
 *  Returns 1 for linear map, 0 for non-linear map
 *  (ie, non-identity map).
 */
static int
is_linear_cmap(ifp)
register FBIO	*ifp;
{
	register int i;

	for( i=0; i<256; i++ )  {
		if( CMR(ifp)[i] != i )  return(0);
		if( CMG(ifp)[i] != i )  return(0);
		if( CMB(ifp)[i] != i )  return(0);
	}
	return(1);
}

/*
 *			S G I _ C M I N I T
 */
_LOCAL_ void
sgi_cminit( ifp )
register FBIO	*ifp;
{
	register int	i;

	for( i = 0; i < 256; i++)  {
		CMR(ifp)[i] = i;
		CMG(ifp)[i] = i;
		CMB(ifp)[i] = i;
	}
}

/*
 *			 S G I _ W M A P
 */
_LOCAL_ int
sgi_wmap( ifp, cmp )
register FBIO	*ifp;
register const ColorMap	*cmp;
{
	register int	i;
	int		prev;	/* !0 = previous cmap was non-linear */

	winset(ifp->if_fd);

	if( qtest() )
		sgi_inqueue(ifp);

	prev = SGI(ifp)->mi_cmap_flag;
	if ( cmp == COLORMAP_NULL)  {
		sgi_cminit( ifp );
	} else {
		for(i = 0; i < 256; i++)  {
			CMR(ifp)[i] = cmp-> cm_red[i]>>8;
			CMG(ifp)[i] = cmp-> cm_green[i]>>8; 
			CMB(ifp)[i] = cmp-> cm_blue[i]>>8;
		}
	}
	SGI(ifp)->mi_cmap_flag = !is_linear_cmap(ifp);

	if( (ifp->if_mode & MODE_7MASK) == MODE_7SWCMAP )  {
		if( SGI(ifp)->mi_cmap_flag == 0 && prev == 0 )  return(0);
		/* Software color mapping, trigger a repaint */
		sgi_xmit_scanlines( ifp, 0, ifp->if_height, 0, ifp->if_width );
		if( SGI(ifp)->mi_is_gt )  {
			gt_zbuf_to_screen( ifp, -1 );
		}
	} else {
		/* Send color map to hardware -- affects whole screen */
		gammaramp( CMR(ifp), CMG(ifp), CMB(ifp) );
	}
	return(0);
}

/*
 *			S G I _ S E T C U R S O R
 */
_LOCAL_ int
sgi_setcursor( ifp, bits, xbits, ybits, xorig, yorig )
FBIO	*ifp;
const unsigned char	*bits;
int		xbits, ybits;
int		xorig, yorig;
{
	register int	y;
	register int	xbytes;
	Cursor		newcursor;

	winset(ifp->if_fd);

	if( qtest() )
		sgi_inqueue(ifp);

	/* Check size of cursor.					*/
	if( xbits < 0 )
		return	-1;
	if( xbits > 16 )
		xbits = 16;
	if( ybits < 0 )
		return	-1;
	if( ybits > 16 )
		ybits = 16;
	if( (xbytes = xbits / 8) * 8 != xbits )
		xbytes++;
	for( y = 0; y < ybits; y++ )  {
		newcursor[y] = bits[(y*xbytes)+0] << 8 & 0xFF00;
		if( xbytes == 2 )
			newcursor[y] |= bits[(y*xbytes)+1] & 0x00FF;
	}
	defcursor( 1, newcursor );
	curorigin( 1, (short) xorig, (short) yorig );
	setcursor( 1, 0, 0 );
	return	0;
}

/*
 *			S G I _ C U R S O R
 */
_LOCAL_ int
sgi_cursor( ifp, mode, x, y )
FBIO	*ifp;
int	mode;
int	x, y;
{
	short	xmin, ymin;
	register short	i;
	short	xwidth;
	long left, bottom, x_size, y_size;

	winset(ifp->if_fd);

	if( qtest() )
		sgi_inqueue(ifp);

	fb_sim_cursor(ifp, mode, x, y);

	SGI(ifp)->mi_curs_on = mode;
	if( ! mode )  {
		setcursor( 2, 1, 0 );		/* nilcursor */
		cursoff();
		return	0;
	}
	xwidth = ifp->if_width/ifp->if_xzoom;
	i = xwidth/2;
	xmin = ifp->if_xcenter - i;
	i = (ifp->if_height/2)/ifp->if_yzoom;
	ymin = ifp->if_ycenter - i;
	x -= xmin;
	y -= ymin;
	x *= ifp->if_xzoom;
	y *= ifp->if_yzoom;
	setcursor( 1, 1, 0 );			/* our cursor */
	curson();
	getsize(&x_size, &y_size);
	getorigin( &left, &bottom );

/*	RGBcursor( 1, 255, 255, 0, 0xFF, 0xFF, 0xFF ); */
	setvaluator( MOUSEX, x+left, 0, XMAXSCREEN );
	setvaluator( MOUSEY, y+bottom, 0, YMAXSCREEN );

	return	0;
}


/*
 *			S G I _ I N Q U E U E
 *
 *  Called when a qtest() indicates that there is a window event.
 *  Process all events, so that we don't loop on recursion to sgw_bwrite.
 */
_LOCAL_ void
sgi_inqueue(ifp)
register FBIO *ifp;
{
	short val;
	int redraw = 0;
	register int ev;

	winset(ifp->if_fd);

	while( qtest() )  {
		switch( ev = qread(&val) )  {
		case REDRAW:
			/* should check val -vs- ifp->if_fd !! */
			redraw = 1;
			break;
		case INPUTCHANGE:
			break;
		case MODECHANGE:
			/* This could be bad news.  Should we re-write
			 * the color map? */
			fb_log("sgi_inqueue:  modechange?\n");
			break;
		case MOUSEX :
		case MOUSEY :
		case KEYBD :
			break;
		default:
			fb_log("sgi_inqueue:  event %d unknown\n", ev);
			break;
		}
	}
	/*
	 * Now that all the events have been removed from the input
	 * queue, handle any actions that need to be done.
	 */
	if( redraw )  {
		reshapeviewport();
		sgi_xmit_scanlines( ifp, 0, ifp->if_height, 0, ifp->if_width );
		if( SGI(ifp)->mi_is_gt )  {
			gt_zbuf_to_screen( ifp, -1 );
		}
		redraw = 0;
	}
}

/*
 *			S G I _ H E L P
 */
_LOCAL_ int
sgi_help( ifp )
FBIO	*ifp;
{
	struct	modeflags *mfp;

	fb_log( "Description: %s\n", ifp->if_type );
	fb_log( "Device: %s\n", ifp->if_name );
	fb_log( "Max width height: %d %d\n",
		ifp->if_max_width,
		ifp->if_max_height );
	fb_log( "Default width height: %d %d\n",
		ifp->if_width,
		ifp->if_height );
	fb_log( "Usage: /dev/sgi[option letters]\n" );
	for( mfp = modeflags; mfp->c != '\0'; mfp++ ) {
		fb_log( "%c  %c   %s\n",
			((ifp->if_mode & mfp->mask) == mfp->value) ? 'Y' : ' ',
			mfp->c, mfp->help );
	}

	fb_log( "\nCurrent internal state:\n");
	fb_log( "	mi_doublebuffer=%d\n", SGI(ifp)->mi_doublebuffer );
	fb_log( "	mi_cmap_flag=%d\n", SGI(ifp)->mi_cmap_flag );
	fb_log( "	mi_is_gt=%d\n", SGI(ifp)->mi_is_gt );

	return(0);
}

/*
 *			S G I _ F L U S H
 *
 *  When simulating a double-buffered display, don't send any updated
 *  pixels to the screen until explicitly flushed.
 */
_LOCAL_ int
sgi_flush( ifp )
FBIO	*ifp;
{
	if( (ifp->if_mode & MODE_12MASK) != MODE_12DELAY_WRITES_TILL_FLUSH )
		return 0;

	winset(ifp->if_fd);

	/* Send entire in-memory buffer to the screen, all at once */
	sgi_xmit_scanlines( ifp, 0, ifp->if_height, 0, ifp->if_width );
	if( SGI(ifp)->mi_is_gt )  {
		/* repaint screen from Z buffer */
		gt_zbuf_to_screen( ifp, -1 );
	}
	return 0;
}

/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************** Special Support for the GT ******************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/

/*
 *			G T _ Z B U F _ T O _ S C R E E N
 *
 *  The parameter "one_y" is set to -1 to repaint the entire screen,
 *  or to the Y coordinate of the single scanline to be repainted.
 */
_LOCAL_ void
gt_zbuf_to_screen( ifp, one_y )
register FBIO	*ifp;
int		one_y;
{
	struct sgi_clip	clip;

	winset(ifp->if_fd);

	zbuffer(FALSE);
	readsource(SRC_ZBUFFER);	/* source for rectcopy() */
	zdraw(FALSE);
	/* dest for rectcopy() */
	if( SGI(ifp)->mi_doublebuffer )  {
 		backbuffer(TRUE);
		frontbuffer(FALSE);
	} else {
		backbuffer(FALSE);
		frontbuffer(TRUE);
	}

	sgi_clipper( ifp, &clip );
	if( SGI(ifp)->mi_doublebuffer == 0 && one_y >= 0 )  {
		/* Do only one scanline, not entire image */
		if( one_y < clip.ymin || one_y > clip.ymax )
			return;
		/* This scanline is in bounds */
		clip.yscroff += (one_y - clip.ymin) * ifp->if_yzoom;
		clip.ymin = clip.ymax = one_y;
	}

	/* rectzoom only works on GT and PI machines */
	rectzoom( (double) ifp->if_xzoom, (double) ifp->if_yzoom);

	if( SGI(ifp)->mi_doublebuffer )  {
		/*
		 *  This clear could be somewhat of a performance problem,
		 *  but it prevents having crud on the borders when
		 *  panning the image.
		 *  In singlebuffer mode, don't take the performance hit.
		 *  (Filling with black & repainting is disturbing)
		 *  (Should just black out the borders instead).
		 */
		cpack(0x00000000);	/* clear to black first */
		clear();		/* takes ~1 frame time */
	}

	/* All coordinates are window-relative, not viewport-relative */
	rectcopy(
		clip.xmin+SGI(ifp)->mi_xoff,
		clip.ymin+SGI(ifp)->mi_yoff,
		clip.xmax+SGI(ifp)->mi_xoff,
		clip.ymax+SGI(ifp)->mi_yoff,
		clip.xscroff+SGI(ifp)->mi_xoff,
		clip.yscroff+SGI(ifp)->mi_yoff );

	if( SGI(ifp)->mi_doublebuffer )  {
	 	swapbuffers();
	}
	rectzoom( 1.0, 1.0 );
}

/*
 *			S G I _ C L I P P E R
 *
 *  The image coordinates of the lower left pixel in view are:
 *	(xmin, ymin)
 *  The screen coordinates of the lower left pixle in view are:
 *	(xscroff, yscroff)
 */
_LOCAL_ void
sgi_clipper( ifp, clp )
register FBIO	*ifp;
register struct sgi_clip	*clp;
{
	register int	i;

	clp->xscroff = clp->yscroff = 0;
	clp->xscrpad = clp->yscrpad = 0;

	i = (ifp->if_width/2)/ifp->if_xzoom;
	clp->xmin = ifp->if_xcenter - i;
	clp->xmax = ifp->if_xcenter + i - 1;

	i = (ifp->if_height/2)/ifp->if_yzoom;
	clp->ymin = ifp->if_ycenter - i;
	clp->ymax = ifp->if_ycenter + i - 1;

	if( clp->xmin < 0 )  {
		clp->xscroff = -(clp->xmin * ifp->if_xzoom);
		clp->xmin = 0;
	}
	if( clp->ymin < 0 )  {
		clp->yscroff = -(clp->ymin * ifp->if_yzoom);
		clp->ymin = 0;
	}

	if( clp->xmax > ifp->if_width-1 )  {
		clp->xscrpad = (clp->xmax - (ifp->if_width-1)) * ifp->if_xzoom;
		clp->xmax = ifp->if_width-1;
	}

	if( clp->ymax > ifp->if_height-1 )  {
		clp->yscrpad = (clp->ymax - (ifp->if_height-1)) * ifp->if_yzoom;
		clp->ymax = ifp->if_height-1;
	}
}

/*
 *			F A K E _ L R E C T W R I T E
 *
 * fake_rectwrite is necessary as lrectwrite is not yet supported
 * for non-GT hardware in IRIX version 3.1 or earlier. There is
 * however, a stub in the library which states that lrectwrite is not yet
 * available for these systems. To allow us to still use
 * shared libraries and have the same executables across the
 * 4D series of workstations, if the system does not contain
 * the GT hardware upgrade then this fake routine is used.
 *
 * Note that the real lrectwrite() subroutine operates in the pixel
 * coordinates of the WINDOW, not the current viewport.
 * To simplify things, this fake_rectwrite() subroutine operates in
 * the coordinates of the VIEWPORT, because cmov2i() and writeRGB() do.
 * Having the callers convert to window, and then to convert back in here,
 * is more inefficient than is necessary.  However, this required the
 * calling sequences to be somewhat altered -vs- the lrectwrite() replaced.
 */
_LOCAL_ void
fake_rectwrite( x1, y1, x2, y2, pixels)
short	x1, y1;
short	x2, y2;
register struct sgi_pixel * pixels;
{
	register struct sgi_pixel * p;
	register short	n;
	register short	scan;
	register short	i;
	static unsigned char Red_pixels[1280];
	static unsigned char Green_pixels[1280];
	static unsigned char Blue_pixels[1280];

	p = pixels;
	n = x2  - x1 + 1;
	for( scan = y1; scan <= y2; scan++)  {
		for ( i = 0; i < n; i++)  {
			Red_pixels[i] =   p->red;
			Green_pixels[i] = p->green;
			Blue_pixels[i] =  p->blue;
			p++;
		}
	
		cmov2i( x1, scan);
		writeRGB( n, Red_pixels, Green_pixels, Blue_pixels);
	}
}
@


11.8
log
@change conf.h to a wrapped config.h
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /cvs/brlcad/libfb/if_4d.c,v 11.7 2004/02/02 17:39:12 morrison Exp $ (BRL)";
@


11.7
log
@update copyright to include span through 2003
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_4d.c,v 11.6 2001/04/20 22:29:12 morrison Exp $ (BRL)";
d49 5
a53 1
#include "conf.h"
@


11.6
log
@CONST to const
@
text
@d38 1
a38 1
 *	This software is Copyright (C) 1989 by the United States Army.
d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_4d.c,v 11.5 1998/06/27 04:29:15 mike Exp $ (BRL)";
@


11.6.4.1
log
@sync branch with HEAD
@
text
@d38 1
a38 1
 *	This software is Copyright (C) 1989-2004 by the United States Army.
d43 1
a43 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.6.6.1
log
@sync to HEAD...
@
text
@d38 1
a38 1
 *	This software is Copyright (C) 1989-2004 by the United States Army.
d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/libfb/if_4d.c,v 11.7 2004/02/02 17:39:12 morrison Exp $ (BRL)";
@


11.6.12.1
log
@merge from HEAD
@
text
@d38 1
a38 1
 *	This software is Copyright (C) 1989-2004 by the United States Army.
d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_4d.c,v 11.7 2004/02/02 17:39:12 morrison Exp $ (BRL)";
@


11.6.12.2
log
@merge from head
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_4d.c,v 11.6.12.1 2004/02/12 19:48:12 erikg Exp $ (BRL)";
@


11.5
log
@Additions to LIBFB interface and remote framebuffer protocol to
read and write monochrome rectangles.
Particularly important for sending thermal images at high speed.
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_4d.c,v 11.4 1998/01/22 19:43:43 mike Exp $ (BRL)";
d1639 1
a1639 1
CONST unsigned char	*pixelp;
d1767 1
a1767 1
CONST unsigned char	*pp;
d1877 1
a1877 1
register CONST ColorMap	*cmp;
d1919 1
a1919 1
CONST unsigned char	*bits;
@


11.4
log
@Changed to harmonize with /dev/ogl.
/dev/sgiD implements delayed flush to screen, for double-buffer sim.
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_4d.c,v 11.3 1997/12/04 00:47:07 mike Exp mike $ (BRL)";
d130 2
@


11.3
log
@Declared void functions properly, for Irix 6.2
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_4d.c,v 11.2 1996/08/27 06:25:01 mike Exp mike $ (BRL)";
d264 3
a266 3
#define MODE_11MASK	(1<<10)
#define MODE_11NORMAL	(0<<10)
#define MODE_11DELAY_WRITES_TILL_FLUSH	(1<<10)
d298 1
a298 1
	{ 'd',	MODE_11DELAY_WRITES_TILL_FLUSH, MODE_11DELAY_WRITES_TILL_FLUSH,
d1118 1
a1118 1
	if( (ifp->if_mode & MODE_11MASK) == MODE_11DELAY_WRITES_TILL_FLUSH )
d1213 1
a1213 1
	if( (ifp->if_mode & MODE_11MASK) != MODE_11DELAY_WRITES_TILL_FLUSH )  {
d1727 1
a1727 1
	if( (ifp->if_mode & MODE_11MASK) == MODE_11DELAY_WRITES_TILL_FLUSH )
d1801 1
a1801 1
	if( (ifp->if_mode & MODE_11MASK) != MODE_11DELAY_WRITES_TILL_FLUSH )  {
d2095 1
a2095 1
	if( (ifp->if_mode & MODE_11MASK) != MODE_11DELAY_WRITES_TILL_FLUSH )
@


11.2
log
@Improvements
@
text
@d4 2
a5 2
 *  BRL Frame Buffer Library interface for SGI Iris-4D, and
 *  SGI Iris-4D with Graphics Turbo.
d7 2
a8 1
 *  However, all are called /dev/sgi
d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_4d.c,v 11.1 1995/01/04 09:52:37 mike Rel4_4 mike $ (BRL)";
d91 2
d2193 1
d2250 1
@


11.1
log
@Release_4.4
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_4d.c,v 10.11 94/12/30 06:28:36 mike Exp $ (BRL)";
d106 1
d128 1
a128 1
		fb_null,		/* flush */
a183 1
	int	mi_rgb_ct;
d261 4
d295 2
d1115 2
d1210 5
a1214 3
	sgi_xmit_scanlines( ifp, 0, ifp->if_height, 0, ifp->if_width );
	if( SGI(ifp)->mi_is_gt )  {
		gt_zbuf_to_screen( ifp, -1 );
d1345 2
d1724 3
d1798 6
a1803 4
	sgi_xmit_scanlines( ifp, ymin, height, 0, ifp->if_width );
	if( SGI(ifp)->mi_is_gt )  {
		/* repaint screen from Z buffer */
		gt_zbuf_to_screen( ifp, -1 );
d2069 3
a2071 1
		fb_log( "   %c   %s\n", mfp->c, mfp->help );
d2074 5
d2082 23
@


10.11
log
@Don't fiddle with user's blanktime() setting.
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_4d.c,v 10.10 94/11/18 18:31:19 mike Exp Locker: mike $ (BRL)";
@


10.10
log
@         *  On Irix 5 with Indigo EXPRESS graphics,
         *  lrectwrite() runs off the end!
         *  So, provide a pad area of 2 scanlines.
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_4d.c,v 10.9 94/11/04 05:06:44 mike Exp Locker: mike $ (BRL)";
d969 1
d971 1
d1225 1
d1242 1
@


10.9
log
@Irix 6
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_4d.c,v 10.8 94/08/12 20:23:33 gdurf Exp Locker: mike $ (BRL)";
d356 4
d381 8
a388 1
	pixsize = ifp->if_max_height * ifp->if_max_width *
d390 1
d392 1
a392 1
	size = (size + 4096-1) & ~(4096-1);
d405 1
d411 1
a411 1
	new_brk = (char *)((((long)new_brk) + 4096-1) & ~(4096-1));
d428 8
@


10.8
log
@Cleaned up includes and externs
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_4d.c,v 10.7 1994/08/09 12:57:03 gdurf Exp gdurf $ (BRL)";
a151 1
_LOCAL_ Colorindex get_Color_Index();
d395 1
a395 1
	new_brk = (char *)(6 * (XMAXSCREEN+1) * 1024);
d398 1
a398 1
	new_brk = (char *)((((int)new_brk) + 4096-1) & ~(4096-1));
d405 1
a405 1
	if( (sp = shmat( SGI(ifp)->mi_shmid, 0, 0 )) == (char *)(-1) )  {
a794 2
	int x_pos, y_pos;	/* Lower corner of viewport */
	register int i;
a796 1
	int 	g_status;
d1272 1
d1304 1
a1304 1
	int menu, menuval, dev, f;
a1305 1
	int k;
a1543 1
	int			ybase;
a1545 2

	ybase = y;
@


10.7
log
@Factored ifdefs
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_4d.c,v 10.6 1993/10/22 20:23:25 mike Exp gdurf $ (BRL)";
a54 2
#define _BSD_TYPES		/* Needed for IRIX 5.0.1 */
#include <sys/types.h>
d59 1
d64 2
a67 6

extern char	*sbrk();
/* extern char	*malloc(); */
extern int	errno;
/* extern char	*shmat(); */
extern int	brk();
@


10.6
log
@IRIX 5.0.1 hack
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_4d.c,v 10.5 93/09/25 10:55:28 mike Exp Locker: mike $ (BRL)";
d48 2
d90 1
a90 1
#if __STDC__
@


10.5
log
@IRIX 5 changes
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/libfb/RCS/if_4d.c,v 10.5 1993/09/25 14:52:41 mike Exp $ (BRL)";
d53 1
@


10.4
log
@Converted to new fb.h
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_4d.c,v 10.3 92/06/18 14:26:27 stay Exp Locker: mike $ (BRL)";
d45 3
d88 1
a88 1
_LOCAL_ int	gt_zbuf_to_screen(FBIO	*ifp, int one_y);
d90 1
a90 1
_LOCAL_ int	gt_zbuf_to_screen();
d484 1
a484 1
_LOCAL_ int
d2057 1
a2057 1
_LOCAL_ int
@


10.3
log
@added support for the indigo with Elan graphics
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_4d.c,v 10.2 92/04/15 19:41:45 mike Exp Locker: stay $ (BRL)";
d1417 1
a1417 1
register RGBpixel	*pp;
d1431 4
a1434 4
		bg.red   = (*pp)[RED];
		bg.green = (*pp)[GRN];
		bg.blue  = (*pp)[BLU];
		RGBcolor((short)((*pp)[RED]), (short)((*pp)[GRN]), (short)((*pp)[BLU]));
d1541 1
a1541 1
RGBpixel	*pixelp;
d1603 1
a1603 1
RGBpixel	*pixelp;
d1728 1
a1728 1
RGBpixel	*pp;
d1836 1
a1836 1
register ColorMap	*cmp;
d1878 1
a1878 1
unsigned char	*bits;
@


10.2
log
@Irix 4.0.1 contains the fix for Irix 4.0.0 shared memory bug.
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_4d.c,v 10.1 91/10/12 06:37:17 mike Rel4_0 Locker: mike $ (BRL)";
d917 3
@


10.1
log
@Release_4.0
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_4d.c,v 9.24 91/10/12 02:25:01 mike Exp $ (BRL)";
a857 4
#if defined(__sgi) && defined(__mips)
	/* XXX On Irix 4.0, something goes wrong with shared memory.  Hack */
	mode |= MODE_1MALLOC;
#endif
@


9.24
log
@Modified for Irix 4.0, to handle problems in full screen mode
(both for NTSC and Dunn camera).
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_4d.c,v 9.23 91/10/11 23:10:39 mike Exp $ (BRL)";
@


9.23
log
@Modified so that fbhelp will report limits based on
current operating mode.
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_4d.c,v 9.22 91/10/11 22:55:05 mike Exp Locker: mike $ (BRL)";
d934 4
d956 5
d962 1
d973 5
d979 1
@


9.22
log
@Broke out sync-on-green as separate mode.
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_4d.c,v 9.21 91/07/26 23:12:31 mike Exp Locker: mike $ (BRL)";
d2008 1
a2008 1
	fb_log( "Description: %s\n", sgi_interface.if_type );
d2011 2
a2012 2
		sgi_interface.if_max_width,
		sgi_interface.if_max_height );
d2014 3
a2016 3
		sgi_interface.if_width,
		sgi_interface.if_height );
	fb_log( "Usage: /dev/sgi[options]\n" );
@


9.21
log
@On Irix 4.0, shared memory does not seem to work.
Added a horrible hack, to force always use private memory on Irix 4.0
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_4d.c,v 9.20 91/07/26 22:40:52 mike Exp $ (BRL)";
d219 1
a219 1
 *	Genlock NTSC -vs- normal monitor mode
d239 1
a239 1
#define MODE_5GENLOCK	(1<<4)
d257 4
d279 4
a282 2
	{ 'n',	MODE_5MASK, MODE_5GENLOCK,
		"NTSC+GENLOCK - else normal video" },
d284 1
a284 1
		"External sync - else internal" },
d292 1
a292 1
		"Zap (free) shared memory" },
d801 1
a801 1
	int	mode;
d930 1
a930 1
	if( (ifp->if_mode & MODE_5MASK) == MODE_5GENLOCK )  {
d951 1
a951 1
	if( (ifp->if_mode & MODE_5MASK) == MODE_5GENLOCK )  {
d988 10
a997 2
		setvideo( DE_R1, DER1_30HZ|DER1_UNBLANK);	/* 4-wire RS-343 */
	} else if( (ifp->if_mode & MODE_5MASK) == MODE_5GENLOCK )  {
d1038 1
a1038 1
			    	setvideo(DE_R1, DER1_G_170|DER1_UNBLANK );
a1040 5
#ifdef GENLOCK_SYNC
				/* GENLOCK sync, found to be highly unstable */
			    	setvideo(CG_MODE, CG2_M_MODE2);
			    	setvideo(DE_R1, DER1_G_170|DER1_UNBLANK );
#else
d1045 1
a1045 2
				setvideo(DE_R1, DER1_170|DER1_UNBLANK);
#endif
d1054 1
a1054 1
			setvideo(DE_R1, DER1_170|DER1_UNBLANK);
d1056 3
d1062 1
a1062 5
	(void)sprintf( title, "BRL libfb /dev/sgi%d%s %s, %s",
		ifp->if_mode,
		((ifp->if_mode & MODE_4MASK) == MODE_4HZ30) ?
			" 30Hz" :
			"",
d1213 1
a1213 1
	 *  Note that for the MODE_5GENLOCK mode, the monitor will
@


9.20
log
@Added if_magic field, and FB_CK_FBIO() macro, to allow checking
FBIO pointers
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_4d.c,v 9.19 91/07/05 14:50:15 stay Exp $ (BRL)";
d413 2
a414 1
	i = ifp->if_cmap->cmb[255];	/* try to deref last word */
d852 4
a856 32

#ifdef IF_4D_AUTO_POSTSCRIPT
	/*
	 *  Now that the mode has been determined,
	 *  ensure that the graphics system is running.
	 *  XXX Note that ps_open_PostScript is not in the
	 *  XXX shared libgl, so this can't be done in an
	 *  XXX SGI processor-independent way.  Sigh.
	 */
	if( !(g_status = ps_open_PostScript()) )  {
		char * grcond = "/etc/gl/grcond";
		char * newshome = "/usr/brlcad/etc";		/* XXX */

		f = fork();
		if( f < 0 )  {
			perror("fork");
			return(-1);		/* error */
		}
		if( f == 0 )  {
			/* Child */
			chdir( newshome );
			execl( grcond, (char *) 0 );
			perror( grcond );
			_exit(1);
			/* NOTREACHED */
		}
		/* Parent */
		while( !(g_status = ps_open_PostScript()) )  {
			sleep(1);
		}
	}
#endif
@


9.19
log
@added a case statement for NULLDEV processing which
causes lotsof events in cypress from generating window
events each time the mouse is moved into the window. 
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_4d.c,v 9.18 91/07/04 02:58:47 mike Exp $ (BRL)";
d110 1
d413 1
d796 2
@


9.18
log
@ANSI compiler needs to know that the routine will be local.
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_4d.c,v 9.17 91/07/04 02:27:32 mike Exp $ (BRL)";
d1363 4
@


9.17
log
@psio.h no longer needed -- we don't do PostScript any more,
and this file does not exist in IRIX 4.0
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_4d.c,v 9.16 91/07/04 02:24:30 stay Exp $ (BRL)";
d84 5
@


9.16
log
@Went back to traditional (working) libfb window semantics.
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/libfb/RCS/if_4d.c,v 9.12 91/01/08 22:52:10 mike Exp $ (BRL)";
a49 1
#include <psio.h>
@


9.15
log
@removed postscript support from if_4d since
sgi will no longer support NeWS.
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_4d.c,v 9.14 91/06/18 18:57:18 butler Exp $ (BRL)";
a46 1
#include <math.h>
d50 1
a251 4
#define MODE_10MASK	(1<<9)
#define MODE_10NORMAL	(0<<9)
#define MODE_10WIDGET	(1<<9)

a296 1

d539 2
a540 2
					SGI(ifp)->mi_yoff+y,
					(unsigned long *)&ifp->if_mem[
d542 1
a542 2
					    sizeof(struct sgi_pixel)]
				);
d579 3
a581 2
					(unsigned long *)&ifp->if_mem[(y*SGI(ifp)->mi_memwidth)*
					    sizeof(struct sgi_pixel)] );
d607 3
a609 2
					(unsigned long *)&ifp->if_mem[(y*SGI(ifp)->mi_memwidth+xbase)*
					    sizeof(struct sgi_pixel)] );
d646 1
a646 1
					(unsigned long *)op );
d741 2
a742 2
						(unsigned long *)
						    SGI(ifp)->mi_scanline );
d845 1
d847 31
a1183 6
	qdevice(RIGHTMOUSE);
	qdevice(LEFTMOUSE);
	tie(LEFTMOUSE, MOUSEX, MOUSEY);
	qdevice(MIDDLEMOUSE);
	tie(MIDDLEMOUSE, MOUSEX, MOUSEY);

a1237 1

a1306 6
	static long	win_lx, win_ly;
	static long	win_hx, win_hy;
	static int 	mousex;
	static int 	mousey;
	static int	pending_middlemouse = 0;
	static int	pending_leftmouse = 0;
d1351 3
a1353 1
	menu = defpup("framebuffer %t|close|reset view");
a1355 1

a1357 1

a1363 3
			if (menuval == 2)
				sgi_view(ifp, ifp->if_width/2,
					ifp->if_height/2, 1, 1);
a1364 38
		case MIDDLEMOUSE:
			/* will also get MOUSEX and MOUSEY so we remember
			 * this event until MOUSEY
			 */
			if (val) {
				pending_middlemouse = 1;
				getorigin( &win_lx, &win_ly );
				getsize( &win_hx, &win_hy );
			}
			break;
		case LEFTMOUSE:
			/* will also get MOUSEX and MOUSEY so we remember
			 * this event until MOUSEY
			 */
			if (val == 1) {
				pending_leftmouse = 1;
				getorigin( &win_lx, &win_ly );
				getsize( &win_hx, &win_hy );
			}
			break;
		case MOUSEX:
			mousex = val - win_lx;
			break;
		case MOUSEY:
			mousey = val - win_ly;
			if (pending_middlemouse) {
				pending_middlemouse = !pending_middlemouse;
				mousex = (mousex - ifp->if_width/2)
						/ ifp->if_xzoom;
				mousey = (mousey - ifp->if_height/2)
						/ ifp->if_xzoom;
				sgi_view(ifp,
					ifp->if_xcenter + mousex,
					ifp->if_ycenter + mousey,
					ifp->if_xzoom, ifp->if_yzoom);
			} else if (pending_leftmouse) {
				pending_leftmouse = !pending_leftmouse;
				mousex = (mousex * 32) / win_hx;
a1365 5
				sgi_view(ifp,
					ifp->if_xcenter, ifp->if_ycenter,
					mousex, mousex);
			}
			break;
d1490 1
a1490 2
	else	
		ifp->if_zoomflag = 0;
a1497 1

a1967 8
	static long	win_lx, win_ly;
	static long	win_hx, win_hy;
	static int 	mousex;
	static int 	mousey;
	static int	pending_middlemouse = 0;
	static int	pending_leftmouse = 0;
	static int	menu = 0;
	int menuval = 0;
a1968 3
	if (!menu)
		menu = defpup("framebuffer %t|<close>|reset view");

d1984 2
a1985 52
		case RIGHTMOUSE:
			menuval = dopup( menu );
			if (menuval == 2)
				sgi_view(ifp, ifp->if_width/2,
					ifp->if_height/2, 1, 1);
			break;
		case MIDDLEMOUSE:
			/* will also get MOUSEX and MOUSEY so we remember
			 * this event until MOUSEY
			 */
			if (val) {
				pending_middlemouse = 1;
				getorigin( &win_lx, &win_ly );
				getsize( &win_hx, &win_hy );
			}
			break;
		case LEFTMOUSE:
			/* will also get MOUSEX and MOUSEY so we remember
			 * this event until MOUSEY
			 */
			if (val == 1) {
				pending_leftmouse = 1;
				getorigin( &win_lx, &win_ly );
				getsize( &win_hx, &win_hy );
			}
			break;
		case MOUSEX:
			mousex = val - win_lx;
			break;
		case MOUSEY:
			mousey = val - win_ly;
			if (pending_middlemouse) {
				pending_middlemouse = !pending_middlemouse;
				mousex = (mousex - ifp->if_width/2)
						/ ifp->if_xzoom;
				mousey = (mousey - ifp->if_height/2)
						/ ifp->if_xzoom;
				sgi_view(ifp,
					ifp->if_xcenter + mousex,
					ifp->if_ycenter + mousey,
					ifp->if_xzoom, ifp->if_yzoom);
				redraw = 1;
			} else if (pending_leftmouse) {
				pending_leftmouse = !pending_leftmouse;
				mousex = (mousex * 32) / win_hx;

				sgi_view(ifp,
					ifp->if_xcenter, ifp->if_ycenter,
					mousex, mousex);
				redraw = 1;
			}
			break;
@


9.14
log
@more support for pan&zoom in framebuffer
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/libfb/RCS/if_4d.c,v 9.13 91/01/28 20:34:58 butler Exp $ (BRL)";
a50 1
#include <psio.h>
a847 32

#ifdef IF_4D_AUTO_POSTSCRIPT
	/*
	 *  Now that the mode has been determined,
	 *  ensure that the graphics system is running.
	 *  XXX Note that ps_open_PostScript is not in the
	 *  XXX shared libgl, so this can't be done in an
	 *  XXX SGI processor-independent way.  Sigh.
	 */
	if( !(g_status = ps_open_PostScript()) )  {
		char * grcond = "/etc/gl/grcond";
		char * newshome = "/usr/brlcad/etc";		/* XXX */

		f = fork();
		if( f < 0 )  {
			perror("fork");
			return(-1);		/* error */
		}
		if( f == 0 )  {
			/* Child */
			chdir( newshome );
			execl( grcond, (char *) 0 );
			perror( grcond );
			_exit(1);
			/* NOTREACHED */
		}
		/* Parent */
		while( !(g_status = ps_open_PostScript()) )  {
			sleep(1);
		}
	}
#endif
@


9.13
log
@modifications to make the type-checking happier.
added hack to allow pan & zoom on a lingering framebuffer via left & middle
mouse button clicks in display window.
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_4d.c,v 9.12 91/01/08 22:52:10 mike Exp $ (BRL)";
d1189 6
d1319 6
a1324 6
	long	win_lx, win_ly;
	long	win_hx, win_hy;
	int 	mousex;
	int 	mousey;
	int	pending_middlemouse;
	int	pending_leftmouse;
a1369 6
	qdevice(RIGHTMOUSE);
	qdevice(LEFTMOUSE);
	tie(LEFTMOUSE, MOUSEX, MOUSEY);
	qdevice(MIDDLEMOUSE);
	tie(MIDDLEMOUSE, MOUSEX, MOUSEY);
	qdevice(REDRAW);
d1410 1
a1411 1
				mousey = val - win_ly;
d1423 2
d1427 1
a1427 1
					mousex/16, mousex/16);
d2034 8
d2043 3
d2061 52
a2112 2
		case MOUSEX :
		case MOUSEY :
@


9.12
log
@Oops, can only lrectwrite() a rectangle when rectangles have the
same width.  Grump.
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_4d.c,v 9.11 91/01/05 01:37:03 mike Exp $ (BRL)";
d47 1
d65 1
a65 1
extern char	*malloc();
d67 1
a67 1
extern char	*shmat();
d157 3
a159 3
	unsigned short	cmr[256];
	unsigned short	cmg[256];
	unsigned short	cmb[256];
d253 4
d302 1
d546 4
a549 2
					&ifp->if_mem[(y*SGI(ifp)->mi_memwidth+xbase)*
					    sizeof(struct sgi_pixel)] );
d586 1
a586 1
					&ifp->if_mem[(y*SGI(ifp)->mi_memwidth)*
d613 1
a613 1
					&ifp->if_mem[(y*SGI(ifp)->mi_memwidth+xbase)*
d651 1
a651 1
					op );
d746 2
a747 1
						SGI(ifp)->mi_scanline );
d765 1
a765 1
static int sigkid()
d1243 1
d1309 2
a1310 1
	int menu, menuval, val, dev, f;
d1313 6
d1363 1
a1363 1
	menu = defpup("close");
d1365 4
d1372 1
d1375 1
d1382 3
d1386 42
a1427 1

d1552 2
a1553 1
	else	ifp->if_zoomflag = 0;
d1561 1
@


9.11
log
@Changed the logic for sending scanlines, somewhat.
There is still a big performance lossage in here, somewhere.
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_4d.c,v 9.10 90/12/19 06:31:31 mike Exp $ (BRL)";
d568 4
a571 2
		if( npix > 32 )  {
			/* Multiple line case, wide lines, send full lines */
d915 1
@


9.10
log
@Eliminated multi-processor bug checking.
Parallel graphics works fine in IRIX 3.3.1
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_4d.c,v 9.9 90/12/19 05:12:38 mike Exp $ (BRL)";
d528 23
a550 40
		if( ifp->if_width == SGI(ifp)->mi_memwidth )  {
			if( nlines == 1 )  {
				/* This is the partial-line case */
				if( SGI(ifp)->mi_is_gt)
					lrectwrite(
						SGI(ifp)->mi_xoff+xbase,
						SGI(ifp)->mi_yoff+y,
						SGI(ifp)->mi_xoff+xbase+npix-1,
						SGI(ifp)->mi_yoff+y,
						&ifp->if_mem[(y*SGI(ifp)->mi_memwidth+xbase)*
						    sizeof(struct sgi_pixel)] );
				else
					fake_rectwrite(
						xbase,
						y,
						xbase+npix-1,
						y,
						&ifp->if_mem[(y*SGI(ifp)->mi_memwidth+xbase)*
						    sizeof(struct sgi_pixel)] );
				return;
			} else {
				/* Multiple line case, do full lines */
				if( SGI(ifp)->mi_is_gt)
					lrectwrite(
						SGI(ifp)->mi_xoff+0,
						SGI(ifp)->mi_yoff+y,
						SGI(ifp)->mi_xoff+0+ifp->if_width-1,
						SGI(ifp)->mi_yoff+y+nlines-1,
						&ifp->if_mem[(y*SGI(ifp)->mi_memwidth)*
						    sizeof(struct sgi_pixel)] );
				else
					fake_rectwrite(
						0,
						y,
						0+ifp->if_width-1,
						y+nlines-1,
						&ifp->if_mem[(y*SGI(ifp)->mi_memwidth)*
						    sizeof(struct sgi_pixel)] );
				return;
			}
d552 37
d592 1
@


9.9
log
@Fixed error in bounds checking
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_4d.c,v 9.8 90/12/19 05:00:09 phil Exp $ (BRL)";
a1278 1
	if(sgi_mpfail(ifp, "close", 0)) return(-1);
a1387 1
	if(sgi_mpfail(ifp, "clear", 0)) return(-1);
a1435 1
	if(sgi_mpfail(ifp, "view", ycenter)) return(-1);
a1481 1
	if(sgi_mpfail(ifp, "getview", ycenter)) return(-1);
a1651 1
	if(sgi_mpfail(ifp, "write", y)) return(-1);
a1722 1
	if(sgi_mpfail(ifp, "writerect", y)) return(-1);
a1804 1
	if(sgi_mpfail(ifp, "wmap", 0)) return(-1);
a1849 1
	if(sgi_mpfail(ifp, "setcursor", yorig)) return(-1);
a1890 1
	if(sgi_mpfail(ifp, "cursor", y)) return(-1);
a2123 45

/*
 *			S G I _ M P F A I L
 *
 *  The IRIX 3.1 version of the Graphics Library (libgl) will HANG
 *  the machine if it is used from a child process (thread) in a multi-tasking
 *  process.  If this condition exists, express our displeasure,
 *  and prevent any attempt to access the graphics library routines.
 *
 *  Returns -
 *	 0	OK
 *	-1	Failure
 */
static int
sgi_mpfail(ifp, str, y)
FBIO	*ifp;
char	*str;
int	y;
{
	static int	count = 0;

	if( SGI(ifp)->mi_pid == getpid() )
		return(0);		/* OK */

	if( count == 0 )  {
		count = 1;
		fb_log("A multi-tasking program has attempted to display graphics\n");
		fb_log("from a child thread.  The SGI-provided GL library is not\n");
		fb_log("presently capable of performing this operation, and no\n");
		fb_log("recovery is possible.  Please call the SGI hotline, and\n");
		fb_log("voice your displeasure about companies that build multi-\n");
		fb_log("processor graphics systems which can't display graphics\n");
		fb_log("from all processors, simultaneously.  This problem is claimed\n");
		fb_log("by SGI to be fixed in the October-1989 IRIX release.\n");

		if( (ifp->if_mode & MODE_1MASK) == MODE_1SHARED )  {
			fb_log("If it is any consolation, the shared memory segment\n");
			fb_log("is being correctly updated and contains your image,\n");
			fb_log("which 'fb-pix' can save into a disk file.\n");
		}
	}
	fb_log("libfb/sgi_%s mp error y=%d\n", str, y);
	return(-1);			/* BAD */
}

@


9.8
log
@Fixed typo.
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_4d.c,v 9.7 90/12/11 22:47:13 phil Exp $ (BRL)";
d1521 2
a1522 2
	if( x < 0 || x > ifp->if_width ||
	    y < 0 || y > ifp->if_height)
d1591 2
a1592 2
	if( x < 0 || x > ifp->if_width ||
	    y < 0 || y > ifp->if_height)
@


9.7
log
@if_ struct changes.  See fb.h.  Cleaned up function names.
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_4d.c,v 9.6 90/11/04 07:03:34 mike Exp $ (BRL)";
d1493 1
a1493 1
	*xzoom = ifp->if_yzoom;
@


9.6
log
@Fixed bug with being unable to return to linear color map if:
(a) shared memory is not working [kernel mis-configured], and
(b) hardware gammaramp is in use.
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_4d.c,v 9.5 90/11/03 15:51:54 mike Exp $ (BRL)";
a82 2
extern int	fb_sim_readrect();

d87 11
a97 12
_LOCAL_ int	sgi_dopen(),
		sgi_dclose(),
		sgi_dclear(),
		sgi_bread(),
		sgi_bwrite(),
		sgi_cmread(),
		sgi_cmwrite(),
		sgi_viewport_set(),
		sgi_window_set(),
		sgi_zoom_set(),
		sgi_curs_set(),
		sgi_cmemory_addr(),
d99 1
d106 12
a117 14
		sgi_dopen,
		sgi_dclose,
		fb_null,		/* reset? */
		sgi_dclear,
		sgi_bread,
		sgi_bwrite,
		sgi_cmread,
		sgi_cmwrite,
		sgi_viewport_set,
		sgi_window_set,
		sgi_zoom_set,
		sgi_curs_set,
		sgi_cmemory_addr,
		fb_null,		/* cscreen_addr */
d120 1
d130 1
d132 3
a177 4
	short	mi_xzoom;
	short	mi_yzoom;
	short	mi_xcenter;
	short	mi_ycenter;
d511 2
a512 2
		if( SGI(ifp)->mi_xcenter != ifp->if_width/2 ||
		    SGI(ifp)->mi_ycenter != ifp->if_height/2 )  {
d678 1
a678 1
		yscr = SGI(ifp)->mi_yoff + clip.yscroff + y * SGI(ifp)->mi_yzoom;
d693 1
a693 1
				for( rep=0; rep<SGI(ifp)->mi_xzoom; rep++ )  {
d699 1
a699 1
				x=(clip.xmax-clip.xmin)*SGI(ifp)->mi_xzoom;
d710 1
a710 1
			for( rep=0; rep<SGI(ifp)->mi_yzoom; rep++ )  {
d747 1
a747 1
 *			S G I _ D O P E N
d750 1
a750 1
sgi_dopen( ifp, file, width, height )
d855 1
a855 1
		fb_log("sgi_dopen:  sgiinfo malloc failed\n");
d893 1
a893 1
			fb_log("sgi_dopen:  linger-mode fork failure\n");
d1088 4
a1091 4
	SGI(ifp)->mi_xzoom = 1;	/* for zoom fakeout */
	SGI(ifp)->mi_yzoom = 1;	/* for zoom fakeout */
	SGI(ifp)->mi_xcenter = width/2;
	SGI(ifp)->mi_ycenter = height/2;
d1156 5
d1217 1
a1217 1
				fb_log("sgi_dclose shmdt failed, errno=%d\n", errno);
d1234 13
d1268 1
a1268 1
 *			S G I _ D C L O S E
d1272 1
a1272 1
sgi_dclose( ifp )
d1355 1
a1355 1
			if( fp ) fprintf(fp,"libfb/sgi_dclose: qreaderror, aborting\n");
d1366 1
a1366 1
			if( fp ) fprintf(fp,"libfb/sgi_dclose: qread %d, val %d\r\n", dev, val );
d1377 1
a1377 1
 *			S G I _ D C L E A R
d1380 1
a1380 1
sgi_dclear( ifp, pp )
d1429 1
a1429 1
 *			S G I _ W I N D O W _ S E T
d1432 1
a1432 1
sgi_window_set( ifp, x, y )
d1434 2
a1435 1
int	x, y;
d1438 1
a1438 1
	if(sgi_mpfail(ifp, "window_set", y)) return(-1);
d1444 4
a1447 1
	if( SGI(ifp)->mi_xcenter == x && SGI(ifp)->mi_ycenter == y )
d1449 2
a1450 1
	if( x < 0 || x >= ifp->if_width )
d1452 1
a1452 1
	if( y < 0 || y >= ifp->if_height )
d1454 12
a1465 2
	SGI(ifp)->mi_xcenter = x;
	SGI(ifp)->mi_ycenter = y;
d1476 1
a1476 1
 *			S G I _ Z O O M _ S E T
d1479 1
a1479 1
sgi_zoom_set( ifp, x, y )
d1481 2
a1482 1
int	x, y;
d1485 1
a1485 1
	if(sgi_mpfail(ifp, "zoom_set", y)) return(-1);
d1491 4
a1494 6
	if( x < 1 ) x = 1;
	if( y < 1 ) y = 1;
	if( SGI(ifp)->mi_xzoom == x && SGI(ifp)->mi_yzoom == y )
		return(0);
	if( x >= ifp->if_width || y >= ifp->if_height )
		return(-1);
a1495 13
	SGI(ifp)->mi_xzoom = x;
	SGI(ifp)->mi_yzoom = y;

	if( SGI(ifp)->mi_xzoom > 1 || SGI(ifp)->mi_yzoom > 1 )
		ifp->if_zoomflag = 1;
	else	ifp->if_zoomflag = 0;

	if( SGI(ifp)->mi_is_gt ) {
		/* Transmitting the Zbuffer is all that is needed */
		gt_zbuf_to_screen( ifp, -1 );
	} else {
		sgi_xmit_scanlines( ifp, 0, ifp->if_height, 0, ifp->if_width );
	}
d1500 1
a1500 1
 *			S G I _ B R E A D
d1506 1
a1506 1
sgi_bread( ifp, x, y, pixelp, count )
d1560 1
a1560 1
 *			S G I _ B W R I T E
d1567 1
a1567 1
sgi_bwrite( ifp, xstart, ystart, pixelp, count )
d1656 1
a1656 1
	if(sgi_mpfail(ifp, "bwrite", y)) return(-1);
d1743 1
a1743 12
 *			S G I _ V I E W P O R T _ S E T
 */
_LOCAL_ int
sgi_viewport_set( ifp, left, top, right, bottom )
FBIO	*ifp;
int	left, top, right, bottom;
{
	return(0);
}

/*
 *			S G I _ C M R E A D
d1748 1
a1748 1
sgi_cmread( ifp, cmp )
d1801 1
a1801 1
 *			 S G I _ C M W R I T E
d1804 1
a1804 1
sgi_cmwrite( ifp, cmp )
d1811 1
a1811 1
	if(sgi_mpfail(ifp, "cmwrite", 0)) return(-1);
d1844 1
a1844 1
 *			S G I _ C U R S _ S E T
d1847 1
a1847 1
sgi_curs_set( ifp, bits, xbits, ybits, xorig, yorig )
d1857 1
a1857 1
	if(sgi_mpfail(ifp, "curs_set", yorig)) return(-1);
d1886 1
a1886 1
 *			S G I _ C M E M O R Y _ A D D R
d1889 1
a1889 1
sgi_cmemory_addr( ifp, mode, x, y )
d1899 1
a1899 1
	if(sgi_mpfail(ifp, "cmemory_addr", y)) return(-1);
d1905 2
d1913 1
a1913 1
	xwidth = ifp->if_width/SGI(ifp)->mi_xzoom;
d1915 3
a1917 3
	xmin = SGI(ifp)->mi_xcenter - i;
	i = (ifp->if_height/2)/SGI(ifp)->mi_yzoom;
	ymin = SGI(ifp)->mi_ycenter - i;
d1920 2
a1921 2
	x *= SGI(ifp)->mi_xzoom;
	y *= SGI(ifp)->mi_yzoom;
d2054 1
a2054 1
		clip.yscroff += (one_y - clip.ymin) * SGI(ifp)->mi_yzoom;
d2059 1
a2059 1
	rectzoom( (double) SGI(ifp)->mi_xzoom, (double) SGI(ifp)->mi_yzoom);
d2106 3
a2108 3
	i = (ifp->if_width/2)/SGI(ifp)->mi_xzoom;
	clp->xmin = SGI(ifp)->mi_xcenter - i;
	clp->xmax = SGI(ifp)->mi_xcenter + i - 1;
d2110 3
a2112 3
	i = (ifp->if_height/2)/SGI(ifp)->mi_yzoom;
	clp->ymin = SGI(ifp)->mi_ycenter - i;
	clp->ymax = SGI(ifp)->mi_ycenter + i - 1;
d2115 1
a2115 1
		clp->xscroff = -(clp->xmin * SGI(ifp)->mi_xzoom);
d2119 1
a2119 1
		clp->yscroff = -(clp->ymin * SGI(ifp)->mi_yzoom);
d2124 1
a2124 1
		clp->xscrpad = (clp->xmax - (ifp->if_width-1)) * SGI(ifp)->mi_xzoom;
d2129 1
a2129 1
		clp->yscrpad = (clp->ymax - (ifp->if_height-1)) * SGI(ifp)->mi_yzoom;
@


9.5
log
@Changed from !defined(SGI4D_Rel2) to defined(IF_4D_AUTO_POSTSCRIPT)
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_4d.c,v 9.4 89/12/01 21:42:38 mike Exp $ (BRL)";
a1822 1
	if( SGI(ifp)->mi_cmap_flag == 0 && prev == 0 )  return(0);
d1825 1
@


9.4
log
@only free shared memory in shared mode....
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: if_4d.c,v 9.3 89/10/21 01:50:38 mike Locked $ (BRL)";
d821 1
a821 1
#ifndef SGI4D_Rel2
d825 3
@


9.3
log
@Added sgi_free(), to release shared memory.
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: if_4d.c,v 9.2 89/09/01 01:34:19 mike Locked $ (BRL)";
d1242 4
a1245 2
	/* Zap memory after closing the framebuffer */
	sgi_zapmem();
@


9.2
log
@fb_flush and fb_free (yet to be implemented).   static modeflags.
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: if_4d.c,v 9.1 89/05/19 05:47:39 phil Locked $ (BRL)";
d102 1
d125 1
a125 1
		sgi_dclose,		/* free - XXX */
d1160 88
d1264 1
a1264 1
		goto out;
a1350 38
	/*
	 *  User is finally done with the frame buffer,
	 *  return control to our caller (who may have more to do).
	 *  set a 20 minute screensave blanking when fb is closed.
	 *  We have no way of knowing if there are other libfb windows
	 *  still open.
	 */
#if 0
	blanktime( (long) 67 * 60 * 20L );
#else
	/*
	 *  Set an 8 minute screensaver blanking, which will light up
	 *  the screen again if it was dark, and will protect it otherwise.
	 *  The 4D has a hardware botch limiting the time to 2**15 frames.
	 */
	blanktime( (long) 32767L );
#endif

	/* Restore initial operation mode, if this was 30Hz */
	if( (ifp->if_mode & MODE_4MASK) == MODE_4HZ30 )
		setvideo( DE_R1, SGI(ifp)->mi_der1 );

	/*
	 *  Note that for the MODE_5GENLOCK mode, the monitor will
	 *  be left in NTSC mode until the user issues a "Set60"
	 *  command.  This is vitally necessary because the Lyon-
	 *  Lamb and VTR equipment need a stedy source of NTSC sync
	 *  pulses while in the process of laying down frames.
	 */

	/* Always leave cursor on when done */
	if( SGI(ifp)->mi_curs_on == 0 )  {
		setcursor( 0, 1, 0 );		/* system default cursor */
		curson();
	}

	winclose( ifp->if_fd );		/* close window */

d1353 1
a1353 19
	if( SGIL(ifp) != NULL ) {
		/* free up memory associated with image */
		if( SGI(ifp)->mi_shmid != -1 ) {
			/* detach from shared memory */
			if( shmdt( ifp->if_mem ) == -1 ) {
				fb_log("sgi_dclose shmdt failed, errno=%d\n", errno);
				return -1;
			}
		} else {
			/* free private memory */
			(void)free( ifp->if_mem );
		}
		/* free state information */
		(void)free( (char *)SGIL(ifp) );
		SGIL(ifp) = NULL;
	}

	sgi_nwindows--;
	return(0);
@


9.1
log
@Release_3.5
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: if_4d.c,v 8.27 89/05/17 20:52:20 mike Exp $ (BRL)";
d123 2
d258 1
a258 1
struct modeflags {
@


8.27
log
@Variable pix_count was used before initialized.
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: if_4d.c,v 8.26 89/05/16 13:22:25 mike Locked $ (BRL)";
@


8.26
log
@*** empty log message ***
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: if_4d.c,v 8.25 89/05/08 14:30:37 stay Locked $ (BRL)";
d1526 3
a1528 2
	if( pix_count == 0 )			/* lrectwrite dies on 0 count */
		return 0;
d1530 1
a1530 1
		return -1;
a1533 1
	pix_count = count;
@


8.25
log
@Deleted the call in sgi_dclose for gexit() since
if physically disconnects the graphics library from 
the NeWS server thus not allowing multiple open and closes
for frame buffer images.
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: if_4d.c,v 8.24 89/05/07 23:11:55 stay Locked $ (BRL)";
d1525 5
@


8.24
log
@Fixed lrectwrite() emulation for non-GT displays.
fake_rectwrite() does NOT have quite the same semantics
as lrectwrite(), to simplify the emulation.
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: /n/spark/m/cad/libfb/RCS/if_4d.c,v 8.23 89/05/07 21:11:21 mike Exp $ (BRL)";
d1297 1
a1297 3
	if( sgi_nwindows <= 1 )  {
		gexit();		/* mandatory finish */
	}
@


8.23
log
@Minor editing of comments.
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: /n/spark/m/cad/libfb/RCS/if_4d.c,v 8.22 89/05/04 17:31:29 stay Exp $ (BRL)";
d541 4
a544 4
						SGI(ifp)->mi_xoff+xbase,
						SGI(ifp)->mi_yoff+y,
						SGI(ifp)->mi_xoff+xbase+npix-1,
						SGI(ifp)->mi_yoff+y,
d560 4
a563 4
						SGI(ifp)->mi_xoff+0,
						SGI(ifp)->mi_yoff+y,
						SGI(ifp)->mi_xoff+0+ifp->if_width-1,
						SGI(ifp)->mi_yoff+y+nlines-1,
d586 4
a589 4
					SGI(ifp)->mi_xoff+xbase,
					SGI(ifp)->mi_yoff+y,
					SGI(ifp)->mi_xoff+xbase+npix-1,
					SGI(ifp)->mi_yoff+y,
d623 4
a626 4
					SGI(ifp)->mi_xoff+0,
					SGI(ifp)->mi_yoff+y,
					SGI(ifp)->mi_xoff+0+ifp->if_width-1,
					SGI(ifp)->mi_yoff+y,
d718 4
a721 2
						xscrmin, yscr,
						xscrmax, yscr,
d2139 8
a2146 2
 * This routine will eventually go away as
 * IRIX 3.2 will implement lrectwrite the same as below.
a2147 5

static unsigned char Red_pixels[1280];
static unsigned char Green_pixels[1280];
static unsigned char Blue_pixels[1280];

d2154 6
a2159 1
	short n, scan, i;
a2161 1
 
@


8.22
log
@changed the 1024 staic red, green, blue arrays
to 1280 for full screen writes.
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: if_4d.c,v 8.21 89/05/04 16:53:58 stay Locked $ (BRL)";
a565 1

d2127 7
a2133 4
/* fake_rectwrite is necessary as lrectwrite is not yet supported
 * for non GT hardware in IRIX version 3.1 or earlier. There is
 * however, a stub in the library which states that this yet yet
 * available for these systems. To allow us to  still use
d2135 4
a2138 4
 * 4D series of workstations if the system does not contain
 * the GT hardware upgrade than use this fake routine until 
 * a later release.  This routine will eventually go away as
 * IRIX 3.2 will basicly implement lrectwrite the same as below 
d2146 2
a2147 1
short x1,y1, x2, y2;
d2156 2
a2157 4
	for( scan = y1; scan <= y2; scan++)
	{
		for ( i = 0; i < n; i++)
		{
a2167 1

@


8.21
log
@add in a fake_rectwrite routine so that we
can still use shared libraries and thus
have the same executables. lrectwrite
is not supported on non GT hardware platforms.
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: if_4d.c,v 8.20 89/05/04 05:01:31 phil Exp $ (BRL)";
d2139 3
a2141 3
static unsigned char Red_pixels[1024];
static unsigned char Green_pixels[1024];
static unsigned char Blue_pixels[1024];
@


8.20
log
@free private memory or release shared memory segment on close
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: if_4d.c,v 8.19 89/03/19 19:56:27 phil Locked $ (BRL)";
d531 16
a546 7
				lrectwrite(
					SGI(ifp)->mi_xoff+xbase,
					SGI(ifp)->mi_yoff+y,
					SGI(ifp)->mi_xoff+xbase+npix-1,
					SGI(ifp)->mi_yoff+y,
					&ifp->if_mem[(y*SGI(ifp)->mi_memwidth+xbase)*
					    sizeof(struct sgi_pixel)] );
d550 17
a566 7
				lrectwrite(
					SGI(ifp)->mi_xoff+0,
					SGI(ifp)->mi_yoff+y,
					SGI(ifp)->mi_xoff+0+ifp->if_width-1,
					SGI(ifp)->mi_yoff+y+nlines-1,
					&ifp->if_mem[(y*SGI(ifp)->mi_memwidth)*
					    sizeof(struct sgi_pixel)] );
d577 16
a592 7
			lrectwrite(
				SGI(ifp)->mi_xoff+xbase,
				SGI(ifp)->mi_yoff+y,
				SGI(ifp)->mi_xoff+xbase+npix-1,
				SGI(ifp)->mi_yoff+y,
				&ifp->if_mem[(y*SGI(ifp)->mi_memwidth+xbase)*
				    sizeof(struct sgi_pixel)] );
d615 14
a628 6
			lrectwrite(
				SGI(ifp)->mi_xoff+0,
				SGI(ifp)->mi_yoff+y,
				SGI(ifp)->mi_xoff+0+ifp->if_width-1,
				SGI(ifp)->mi_yoff+y,
				op );
d712 10
a721 4
				lrectwrite(
					xscrmin, yscr,
					xscrmax, yscr,
					SGI(ifp)->mi_scanline );
d2126 42
@


8.19
log
@Attempted to fix the zoomed cases (both GT and non)
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: if_4d.c,v 8.18 89/03/19 19:10:34 mike Locked $ (BRL)";
d812 1
d1257 1
a1257 1
	if( fp )  fclose(fp);
d1259 16
a1274 2
	if( SGIL(ifp) != NULL )
		(void)free( (char *)SGI(ifp) );
@


8.18
log
@GT code has been optimized (somewhat) for single pixel (and sub-scanline)
operations.
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: if_4d.c,v 8.17 89/03/19 17:51:51 mike Locked $ (BRL)";
d643 1
a643 1
		yscr = SGI(ifp)->mi_yoff + y + clip.yscroff;
d1946 1
a1946 1
		clip.yscroff += one_y - clip.ymin;
@


8.17
log
@First round of optimization for single-pixel writes.
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: if_4d.c,v 8.16 89/03/17 19:18:48 mike Locked $ (BRL)";
d540 1
a540 1
				/* Multiple line case */
d563 1
a563 1
				&ifp->if_mem[(y*SGI(ifp)->mi_memwidth)*
d1106 1
a1106 1
		gt_zbuf_to_screen( ifp );
d1188 1
a1188 1
				gt_zbuf_to_screen(ifp);
d1310 1
a1310 1
		gt_zbuf_to_screen(ifp);
d1342 1
a1342 1
		gt_zbuf_to_screen( ifp );
d1380 1
a1380 1
		gt_zbuf_to_screen( ifp );
a1547 1
			fb_log("switching to single buffer\n");
d1553 4
d1560 4
a1564 4
	if( SGI(ifp)->mi_is_gt )  {
		/* repaint screen from Z buffer */
		gt_zbuf_to_screen( ifp );
	}
d1620 1
a1620 1
		gt_zbuf_to_screen( ifp );
d1728 1
a1728 1
			gt_zbuf_to_screen( ifp );
d1873 1
a1873 1
			gt_zbuf_to_screen( ifp );
d1916 2
d1920 1
a1920 1
gt_zbuf_to_screen( ifp )
d1922 1
d1941 8
d1959 2
@


8.16
log
@Added "s" single buffer flag, as a potential performance enhancer
on the GT machines.
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: /n/spark/m/cad/libfb/RCS/if_4d.c,v 8.15 89/03/17 18:10:28 mike Exp $ (BRL)";
d464 3
d469 1
a469 1
sgi_xmit_scanlines( ifp, ybase, nlines )
d473 2
d482 5
d529 21
a549 8
			lrectwrite(
				SGI(ifp)->mi_xoff+0,
				SGI(ifp)->mi_yoff+y,
				SGI(ifp)->mi_xoff+0+ifp->if_width-1,
				SGI(ifp)->mi_yoff+y+nlines-1,
				&ifp->if_mem[(y*SGI(ifp)->mi_memwidth)*
				    sizeof(struct sgi_pixel)] );
			return;
d552 6
d559 1
a559 1
				SGI(ifp)->mi_xoff+0,
d561 1
a561 1
				SGI(ifp)->mi_xoff+0+ifp->if_width-1,
d565 2
a566 5
			/*  XXX big performance hit here.
			 *  GTX is limited to about 1000 lrectwrites/sec,
			 *  due to some library synchronization mechanism
			 *  that burns 60% of the CPU in sys-time. ?!?!
			 */
d662 1
a662 1
			}
d1104 1
a1104 1
	sgi_xmit_scanlines( ifp, 0, ifp->if_height );
d1185 2
a1186 1
			sgi_xmit_scanlines(ifp, 0, ifp->if_height);
d1308 2
a1309 1
		sgi_xmit_scanlines( ifp, 0, ifp->if_height );
d1344 1
a1344 1
		sgi_xmit_scanlines( ifp, 0, ifp->if_height );
d1382 1
a1382 1
		sgi_xmit_scanlines( ifp, 0, ifp->if_height );
d1455 1
a1455 1
sgi_bwrite( ifp, x, y, pixelp, count )
d1457 2
a1458 1
register int	x, y;
d1460 1
a1460 1
register int	count;
d1466 3
d1470 3
a1472 1
	ybase = y;
d1481 1
a1481 1
	while( count )  {
d1488 1
a1488 1
		if ( count >= ifp->if_width-x )
d1491 1
a1491 1
			scan_count = count;
d1529 1
a1529 1
		count -= scan_count;
d1545 13
a1557 1
	sgi_xmit_scanlines( ifp, ybase, y-ybase );
d1614 1
a1614 1
	sgi_xmit_scanlines( ifp, ymin, height );
d1723 1
a1723 1
		sgi_xmit_scanlines( ifp, 0, ifp->if_height );
d1868 1
a1868 1
		sgi_xmit_scanlines( ifp, 0, ifp->if_height );
@


8.15
log
@A fix for the non-lingering linger-mode windows,
plus one extra error check.
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: /n/spark/m/cad/libfb/RCS/if_4d.c,v 8.14 89/03/17 13:39:06 mike Exp $ (BRL)";
d189 1
d248 4
d278 2
d986 7
a992 1
		doublebuffer();
d995 1
d1003 1
a1003 1
	if( SGI(ifp)->mi_is_gt )  {
d1879 8
a1886 2
	backbuffer(TRUE);		/* dest for rectcopy() */
	frontbuffer(FALSE);
d1893 10
a1902 7
	/*
	 *  This clear could be somewhat of a performance problem,
	 *  but it prevents having crud on the borders when
	 *  panning the image.
	 */
	cpack(0x00000000);	/* clear to black first */
	clear();		/* takes ~1 frame time */
d1913 3
a1915 1
 	swapbuffers();	 
@


8.14
log
@Fixed bug with linger mode
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: if_4d.c,v 8.13 89/03/15 23:09:29 mike Locked $ (BRL)";
d796 2
a797 1
		if(((f = fork()) != 0 ) && ( f != -1))   {
d812 3
d816 1
d1087 1
a1087 1
	if( sgi_nwindows > 0 ||
@


8.13
log
@Changed to enable one program to open multiple framebuffers onto
the SGI screen.  Each framebuffer ends up being a separate window,
with separate state.  "linger" mode is not advised for this style use.
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: /n/spark/m/cad/libfb/RCS/if_4d.c,v 8.12 89/03/03 05:52:05 mike Exp $ (BRL)";
d771 9
a811 5
	}

	if( (SGIL(ifp) = (char *)calloc( 1, sizeof(struct sgiinfo) )) == NULL )  {
		fb_log("sgi_dopen:  sgiinfo malloc failed\n");
		return(-1);
@


8.12
log
@Added sgi_writerect(), to speed up drawing of vertical lines.
Performance problem still exists in SGI's lrectwrite(),
and has been noted.
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: if_4d.c,v 8.11 89/03/03 04:09:53 mike Locked $ (BRL)";
d76 7
d124 1
a124 1
		"SiliconGraphics Iris '4D'",
d158 11
d187 2
a277 15
static int fb_parent;

/*
 *  This is the format of the buffer for lrectwrite(),
 *  and thus defines the format of the in-memory framebuffer copy.
 */
struct sgi_pixel {
	unsigned char alpha;	/* this will always be zero */
	unsigned char blue;
	unsigned char green;
	unsigned char red;
};

static struct sgi_pixel	one_scan[XMAXSCREEN+1];	/* one scanline */

d470 2
d541 1
d544 1
d550 3
a552 3
				one_scan[x].red   = CMR(ifp)[sgip[x].red];
				one_scan[x].green = CMG(ifp)[sgip[x].green];
				one_scan[x].blue  = CMB(ifp)[sgip[x].blue];
d559 1
a559 1
				one_scan );
d623 1
a623 1
			op = one_scan;
d632 1
d634 3
a636 3
					one_scan[x].red   = CMR(ifp)[one_scan[x].red];
					one_scan[x].green = CMG(ifp)[one_scan[x].green];
					one_scan[x].blue  = CMB(ifp)[one_scan[x].blue];
d646 1
a646 1
					one_scan );
d782 2
a783 1
		fb_parent = getpid();		/* save parent pid */
d851 5
a855 1
		prefposition( WIN_L, WIN_R, WIN_B, WIN_T );
d863 9
a871 4
	if( (ifp->if_fd = winopen( "Frame buffer" )) == -1 )
	{
		fb_log( "No more graphics ports available.\n" );
		return	-1;
d873 1
d966 3
a968 4
	/* Free window of position constraint.		*/
	prefsize( (long)ifp->if_width, (long)ifp->if_height );
	winconstraints();

d975 1
a975 1
	gconfig();	/* Must be called after singlebuffer().	*/
d977 1
a977 1
	/* Need to clean out images from windows below */
d1051 7
a1057 6
	if( (ifp->if_mode & MODE_1MASK) == MODE_1SHARED )  {
		/* Display the existing contents of shared memory */
		sgi_xmit_scanlines( ifp, 0, ifp->if_height );
		if( SGI(ifp)->mi_is_gt )  {
			gt_zbuf_to_screen( ifp );
		}
d1059 1
d1075 2
a1076 1
	if( SGI(ifp)->mi_pid != getpid() )  {fb_log("libfb/sgi call from wrong process!\n");return(-1);}
d1078 2
a1079 1
	if( (ifp->if_mode & MODE_2MASK) == MODE_2TRANSIENT )
d1117 1
a1117 1
	kill(fb_parent, SIGUSR1);	/* zap the lurking parent */
d1202 4
a1205 1
	gexit();			/* mandatory finish */
d1210 2
d1228 2
a1229 1
	if( SGI(ifp)->mi_pid != getpid() )  {fb_log("libfb/sgi call from wrong process!\n");return(-1);}
d1275 2
a1276 1
	if( SGI(ifp)->mi_pid != getpid() )  {fb_log("libfb/sgi call from wrong process!\n");return(-1);}
d1307 2
a1308 1
	if( SGI(ifp)->mi_pid != getpid() )  {fb_log("libfb/sgi call from wrong process!\n");return(-1);}
d1338 3
d1482 2
a1483 1
	if( SGI(ifp)->mi_pid != getpid() )  {fb_log("libfb/sgi call from wrong process!\n");return(-1);}
d1539 2
a1540 1
	if( SGI(ifp)->mi_pid != getpid() )  {fb_log("libfb/sgi call from wrong process!\n");return(-1);}
d1566 2
d1633 2
a1634 1
	if( SGI(ifp)->mi_pid != getpid() )  {fb_log("libfb/sgi call from wrong process!\n");return(-1);}
d1679 2
a1680 1
	if( SGI(ifp)->mi_pid != getpid() )  {fb_log("libfb/sgi call from wrong process!\n");return(-1);}
d1721 2
a1722 1
	if( SGI(ifp)->mi_pid != getpid() )  {fb_log("libfb/sgi call from wrong process!\n");return(-1);}
d1769 2
d1774 1
a1848 7
	register short xmin, xmax;
	register short ymin, ymax;
	register short	i;
	short		xscroff, yscroff;
	register unsigned char *ip;
	short		y;
	short		xwidth;
d1851 2
d1864 5
a1869 1
	/* XXX why is this done -- could be performance problem */
d1928 44
@


8.11
log
@rect version
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: if_4d.c,v 8.10 89/03/01 03:38:04 mike Locked $ (BRL)";
d76 1
a76 1
extern int	fb_sim_readrect(), fb_sim_writerect();
a77 1

d94 1
d115 1
a115 1
		fb_sim_writerect,
d117 1
a117 1
		"Silicon Graphics Iris '4D'",
d522 5
d1461 56
d1797 1
a1797 1
 *			G T _ Z B U F
d1826 1
a1826 1
	clear();
@


8.10
log
@Name changed to if_4d.c
@
text
@d42 1
a42 1
static char RCSid[] = "@@(#)$Header: if_gt.c,v 8.9 89/03/01 03:20:33 mike Locked $ (BRL)";
d76 3
d114 2
@


8.9
log
@Fixed software zoom w/ software colormap case.
@
text
@a2 1
 *			I F _ G T . C
d7 1
a7 1
 *  However, both are called /dev/sgi
d17 1
a17 1
 *  refer to the Users Manuals to reconfigure your kernel..
d19 2
d37 1
a37 1
 *	This software is Copyright (C) 1986 by the United States Army.
d42 1
a42 1
static char RCSid[] = "@@(#)$Header: if_gt.c,v 8.8 89/03/01 03:07:35 mike Locked $ (BRL)";
a94 4
#if 1
#define sgi_interface	gt_interface
FBIO gt_interface =
#else
a95 1
#endif
@


8.8
log
@Re-did software zooming (for non-GT machines) to work right.
@
text
@d41 1
a41 1
static char RCSid[] = "@@(#)$Header: if_gt.c,v 8.7 89/02/26 05:35:20 mike Locked $ (BRL)";
d616 2
a617 1
				for( x=(clip.xmax-clip.xmin); x>=0; x-- )  {
@


8.7
log
@Total overhaul to create a version that will work on all 4D systems
without need of compile-time flags.
Things that still need work:
Zoom/pan on non-GT machines.
Changes to max size of shared memory.
@
text
@d41 1
a41 1
static char RCSid[] = "@@(#)$Header: if_4d.c,v 8.4 89/01/04 08:25:22 mike Locked $ (BRL)";
d167 1
d353 2
a354 3
	pixsize = ifp->if_max_height * ifp->if_max_width * sizeof(struct sgi_pixel);
/*** XXX hack hack hack */
pixsize = ifp->if_max_height * ifp->if_max_width * sizeof(RGBpixel);
a481 2
			rectzoom( (double) SGI(ifp)->mi_xzoom, 
				  (double) SGI(ifp)->mi_yzoom);
a483 1
			rectzoom( 1.0, 1.0 );
d496 2
d549 3
a551 3
	if( !sw_zoom )  {
		fb_log("sgi_xmit_scanlines:  unexpected !sw_zoom\n");
	}
d582 3
a584 3
	/* Output pixels */
	if( sw_zoom && !sw_cmap )  {
		register int	yrep;
d586 2
d589 9
a597 1
		yscr = y + clip.yscroff;
d599 2
d602 1
a602 21
			if( y > clip.ymax )  break;
			/* X direction replication is handled by HW */
			for( yrep=0; yrep < SGI(ifp)->mi_yzoom; yrep++, yscr++ )  {
				lrectwrite(
				SGI(ifp)->mi_xoff+0+clip.xscroff,
				SGI(ifp)->mi_yoff+yscr,
				SGI(ifp)->mi_xoff+0+ifp->if_width-1-clip.xscrpad,
				SGI(ifp)->mi_yoff+yscr,
				&ifp->if_mem[(y*SGI(ifp)->mi_memwidth+clip.xmin)*
				    sizeof(struct sgi_pixel)] );
			}
		}
		return;
	}
	if( sw_zoom && sw_cmap )  {
		/* Hardest case */
		fb_log("too hard to zoom and cmap at the same time\n");
		return;
	}
	fb_log("sgi_xmit_scanlines:  unexpected case\n");
}
d604 8
a611 72
#if 0
_LOCAL_ int
OLDsgi_xmit_scanlines( ifp )
register FBIO	*ifp;
{
	register short i;
	register unsigned char *ip;
	short y;
	short xwidth;
	static RGBpixel black = { 0, 0, 0 };
	struct sgi_clip	clip;
	im_setup;			/* declares GE & Windowstate vars */

	xwidth = ifp->if_width/SGI(ifp)->mi_xzoom;
	sgi_clipper( ifp, &clip );

	RGBcolor( 0, 0, 0 );
	/* Blank out area left of image.			*/
	if( clip.xscroff > 0 )
		rectfs(
				0, 0,
				(Scoord) clip.xscroff-1, (Scoord) ifp->if_height-1,
				(RGBpixel *) black
				);
	/* Blank out area below image.			*/
	if( clip.yscroff > 0 )
		rectfs(
				0, 0,
				(Scoord) ifp->if_width-1, (Scoord) clip.yscroff-1,
				(RGBpixel *) black
				);
	/* Blank out area right of image.			*/
	if( clip.xscrpad > 0 )
		rectfs(
				(Scoord) ifp->if_width-clip.xscrpad,
				0,
				(Scoord) ifp->if_width-1,
				(Scoord) ifp->if_height-1,
				(RGBpixel *) black
				);
	/* Blank out area above image.			*/
	if( clip.yscrpad > 0 )
		rectfs(
				0,
				(Scoord) ifp->if_height-clip.yscrpad,
				(Scoord) ifp->if_width-1,
				(Scoord) ifp->if_height-1,
				(RGBpixel *) black
				);

	/*
	 *  First, the Zoomed case
	 */
	if( ifp->if_zoomflag )  {
		register Scoord l, b, r, t;

		for( y = clip.ymin; y <= clip.ymax; y++ )  {
			ip = (unsigned char *)
				&ifp->if_mem[(y*SGI(ifp)->mi_memwidth+clip.xmin)*sizeof(RGBpixel)];

			l = clip.xscroff;
			b = clip.yscroff + (y-clip.ymin)*SGI(ifp)->mi_yzoom;
			t = b + SGI(ifp)->mi_yzoom - 1;
			if ( SGI(ifp)->mi_cmap_flag == FALSE )  {
				for( i=xwidth; i > 0; i--)  
				{
					/* XXX could this be im_RGBcolor? */
 					RGBcolor( ip[RED], ip[GRN], ip[BLU]);
					r = l + SGI(ifp)->mi_xzoom - 1;
					im_rectfs( l, b, r, t );
					l = r + 1;
					ip += sizeof(RGBpixel);
d613 1
a613 12
			} else {
				for( i=xwidth; i > 0; i--)  
				{
				    	RGBcolor( CMR(ifp)[ip[RED]], 
						CMG(ifp)[ip[GRN]], 
						CMB(ifp)[ip[BLU]] );

					r = l + SGI(ifp)->mi_xzoom - 1;
					im_rectfs( l, b, r, t );
					l = r + 1;
					ip += sizeof(RGBpixel);
				}
d615 5
a619 31
			continue;
		}
		goto out;
	}

	/*
	 *  The non-zoomed case
	 */
	for( y = clip.ymin; y <= clip.ymax; y++ )  {
		register long amount, n;

		ip = (unsigned char *)
			&ifp->if_mem[(y*SGI(ifp)->mi_memwidth+clip.xmin)*sizeof(RGBpixel)];

		im_cmov2s(clip.xscroff, clip.yscroff +( y - clip.ymin) );

		if ( SGI(ifp)->mi_cmap_flag == FALSE )  {
			n = xwidth;

			while( n > 0 )  {
				amount = n > 30 ? 30 : n;

				im_passthru( amount + amount + amount + 2);
				im_outshort( FBCRGBdrawpixels);
				im_outshort( amount );
				
				n -= amount;
				while( --amount != -1 )  {
					im_outshort( *ip++ );
					im_outshort( *ip++ );
					im_outshort( *ip++ );
a620 1
				amount = amount;
d622 9
a630 18
			GEWAIT;
		} else {
			n = xwidth;

			while( n > 0 )  {
				amount = n > 30 ? 30 : n;

				im_passthru( amount + amount + amount + 2);
				im_outshort( FBCRGBdrawpixels);
				im_outshort( amount );
				
				n -= amount;
				while( --amount != -1 )  {
					im_outshort( CMR(ifp)[*ip++] );
					im_outshort( CMG(ifp)[*ip++] );
					im_outshort( CMB(ifp)[*ip++] );
				}
				amount = amount;
a631 1
			GEWAIT;
d633 1
a634 12
	/*
	 *  Releasing the pipe has been moved outside the main scanline
	 *  loop, to prevent the kernel from switching windows
	 *  from scanline to scanline as several windows repaint.
	 *  Kernel pre-emption still happens, but much less often.
	 */
	im_freepipe;
	GEWAIT;

	/* The common final section */
out:
	;
a635 1
#endif
d645 8
a806 1
if( SGI(ifp)->mi_is_gt ) fb_log("Using GT hardware\n");
d971 1
d1046 2
d1189 2
a1190 1
	register int		cnt;
d1192 2
d1211 7
a1217 4
	/* Slightly simplistic -- runover to right border */
	sgip = (struct sgi_pixel *)ifp->if_mem;
	for( cnt=SGI(ifp)->mi_memwidth*ifp->if_height-1; cnt > 0; cnt-- )  {
		*sgip++ = bg;	/* struct copy */
d1237 3
d1268 3
a1315 4
	/* Handle events promptly */
	if( qtest() )
		sgi_inqueue(ifp);

d1440 2
a1460 2
	if( qtest() )
		sgi_inqueue(ifp);
a1473 3
	if( qtest() )
		sgi_inqueue(ifp);

d1531 2
d1576 2
d1617 2
d1758 1
d1775 1
d1780 5
@


8.6
log
@Full screen mode now works.
Several potential performance areas have been marked.
@
text
@a0 2
#undef _LOCAL_
#define _LOCAL_ /**/
d2 1
d5 2
a6 1
 *  BRL Frame Buffer Library interface for SGI Iris-4D with Graphics Turbo.
d8 1
a8 2
 *  Support for the 4D's  without the Graphics turbos is in if_4d.c
 *  However, all are called /dev/sgi
d20 4
a23 3
 *  There are different Frame Buffer types supported on the 4D/60T or 4D/70
 *  set your environment FB_FILE to the appropriate Frame buffer type.
 *  See the "fbhelp" table, at the end of this module.
d26 1
a27 1
 *	Michael John Muuss
d41 1
a41 1
static char RCSid[] = "@@(#)$Header: if_gt.c,v 8.5 88/12/29 00:02:31 mike Locked $ (BRL)";
d47 1
d49 1
a49 2
#include <gl/addrs.h>
#include <gl/cg2vme.h>
d51 1
a54 1
#include <psio.h>
d56 3
d62 5
a66 1
#define BZERO(p,cnt)	memset(p,'\0',cnt)
d68 1
a68 5
extern char *sbrk();
extern char *malloc();
extern int errno;
extern char *shmat();
extern int brk();
d71 1
a71 2
static Cursor	cursor =
	{
d73 1
a73 1
	};
d75 2
a76 14
_LOCAL_ int	gt_dopen(),
		gt_dclose(),
		gt_dclear(),
		gt_bread(),
		gt_bwrite(),
		gt_cmread(),
		gt_cmwrite(),
		gt_viewport_set(),
		gt_window_set(),
		gt_zoom_set(),
		gt_curs_set(),
		gt_cmemory_addr(),
		gt_cscreen_addr(),
		gt_help();
d78 15
d94 2
d97 3
d101 2
a102 2
		gt_dopen,
		gt_dclose,
d104 10
a113 10
		gt_dclear,
		gt_bread,
		gt_bwrite,
		gt_cmread,
		gt_cmwrite,
		gt_viewport_set,
		gt_window_set,
		gt_zoom_set,
		gt_curs_set,
		gt_cmemory_addr,
d115 2
a116 2
		gt_help,
		"SGI 4D/GT",
d135 1
a135 1
_LOCAL_ void	mpw_inqueue();
d138 9
a146 4
struct gt_cmap {
	unsigned char	cmr[256];
	unsigned char	cmg[256];
	unsigned char	cmb[256];
a148 1

d150 1
a150 1
 *  Per MIPS (window or device) state information
d153 1
a153 2

struct gtinfo {
d166 1
d168 2
a169 2
#define	GT(ptr)	((struct gtinfo *)((ptr)->u1.p))
#define	GTL(ptr)	((ptr)->u1.p)		/* left hand side version */
d172 3
a174 3
#define CMR(x)		((struct gt_cmap *)((x)->if_cmap))->cmr
#define CMG(x)		((struct gt_cmap *)((x)->if_cmap))->cmg
#define CMB(x)		((struct gt_cmap *)((x)->if_cmap))->cmb
a184 2
static int map_size;			/* # of color map slots available */

d189 1
a189 1
 *	Windowed vs FullScreen
d217 8
d239 1
a239 1
	{ 'f',	MODE_3MASK, MODE_3FULLSCR, 
d247 4
d256 1
a256 1
static RGBpixel	rgb_table[4096];
d258 5
a262 1
struct gt_pix {
d269 1
a269 1
struct gt_pix gt_scan[1280];	/* Maximum length of a scan line */
d271 11
a281 1
static int fb_parent;
d283 8
d292 1
a292 1
 *			M I P S _ G E T M E M
d319 1
a319 1
gt_getmem( ifp )
a330 2


d337 3
a339 3
		GT(ifp)->mi_memwidth = ifp->if_width;
		pixsize = ifp->if_height * ifp->if_width * sizeof(RGBpixel);
		size = pixsize + sizeof(struct gt_cmap);
d343 1
a343 1
			fb_log("gt_getmem: frame buffer memory malloc failed\n");
d346 2
a347 6

		ifp->if_mem = sp;
		ifp->if_cmap = sp + pixsize;	/* cmap at end of area */

		gt_cmwrite( ifp, COLORMAP_NULL );
		return(0);
d351 5
a355 3
	GT(ifp)->mi_memwidth = ifp->if_max_width;
	pixsize = ifp->if_max_height * ifp->if_max_width * sizeof(RGBpixel);
	size = pixsize + sizeof(struct gt_cmap);
d359 1
a359 1
	if( (GT(ifp)->mi_shmid = shmget( SHMEM_KEY, size, 0 )) < 0 )  {
d361 1
a361 1
		if( (GT(ifp)->mi_shmid = shmget(
d363 1
a363 1
			fb_log("gt_getmem: shmget failed, errno=%d\n", errno);
d376 1
a376 1
		fb_log("gt_getmem: new brk(x%x) failure, errno=%d\n", new_brk, errno);
d381 2
a382 2
	if( (sp = shmat( GT(ifp)->mi_shmid, 0, 0 )) == (char *)(-1) )  {
		fb_log("gt_getmem: shmat returned x%x, errno=%d\n", sp, errno );
d388 1
a388 1
		fb_log("gt_getmem: restore brk(x%x) failure, errno=%d\n", old_brk, errno);
d398 1
a398 1
		gt_cmwrite( ifp, COLORMAP_NULL );
d401 1
a401 1
	fb_log("gt_getmem:  Unable to attach to shared memory.\nConsult comment in cad/libfb/if_gt.c for details\n");
d403 1
a403 1
		fb_log("gt_getmem:  malloc failure\n");
d411 1
a411 1
 *			M I P S _ Z A P M E M
d414 1
a414 1
gt_zapmem()
d420 1
a420 1
		fb_log("gt_zapmem shmget failed, errno=%d\n", errno);
d426 1
a426 1
		fb_log("gt_zapmem shmctl failed, errno=%d\n", errno);
d429 1
a429 1
	fb_log("if_mips: shared memory released\n");
d432 2
d435 1
a435 1
 *			M I P S _ R E P A I N T
d438 13
a450 2
 *  repaint the screen from the shared memory buffer,
 *  which stores RGB pixels.
d453 1
a453 1
gt_repaint( ifp )
d455 2
d458 160
a617 2
	register short xmin, xmax;
	register short ymin, ymax;
a618 1
	short xscroff, yscroff;
d622 3
d626 2
d629 33
a661 3
	readsource(SRC_ZBUFFER);	/* source for rectcopy() */
	backbuffer(TRUE);		/* dest for rectcopy() */
	frontbuffer(FALSE);
d663 5
a667 1
	xscroff = yscroff = 0;
d669 3
a671 1
	i = (ifp->if_width/2)/GT(ifp)->mi_yzoom;
d673 19
a691 2
	xmin = GT(ifp)->mi_xcenter - i;
	xmax = GT(ifp)->mi_xcenter + i - 1;
d693 10
a702 1
	i = (ifp->if_height/2)/GT(ifp)->mi_yzoom;
d704 5
a708 2
	ymin = GT(ifp)->mi_ycenter - i;
	ymax = GT(ifp)->mi_ycenter + i - 1;
d710 2
a711 8
	if( xmin < 0 )  {
		xscroff = -xmin * GT(ifp)->mi_xzoom;
		xmin = 0;
	}
	if( ymin < 0 )  {
		yscroff = -ymin * GT(ifp)->mi_yzoom;
		ymin = 0;
	}
d713 1
a713 3
	if( xmax > ifp->if_width-1 )  {
		xmax = ifp->if_width-1;
	}
d715 2
a716 3
	if( ymax > ifp->if_height-1 )  {
		ymax = ifp->if_height-1;
	}
d718 2
a719 4
	if( ifp->if_zoomflag )  {
		rectzoom( (double) GT(ifp)->mi_xzoom, 
			  (double) GT(ifp)->mi_yzoom);
	} 
d721 15
a735 2
	cpack(0x00000000);	/* clear to black first */
	clear();
d737 2
a738 4
	/* All coordinates are window-relative, not viewport-relative */
	rectcopy( xmin+GT(ifp)->mi_xoff, ymin+GT(ifp)->mi_yoff,
		xmax+GT(ifp)->mi_xoff, ymax+GT(ifp)->mi_yoff,
		xscroff+GT(ifp)->mi_xoff, yscroff+GT(ifp)->mi_yoff );
d740 23
a762 1
 	swapbuffers();	 
d764 3
a766 2
	if( ifp->if_zoomflag ) 	/* Must set this back to 1.0 for zbuffer */
		rectzoom(1.0, 1.0);
d768 1
d779 1
a779 1
 *			M I P S _ D O P E N
d782 1
a782 1
gt_dopen( ifp, file, width, height )
d789 1
a789 1
	int f;
d794 1
a801 1

d806 4
a809 4
		char modebuf[80];
		char *mp;
		int alpha;
		struct modeflags *mfp;
a810 1
		
d833 1
a833 1
					fb_log( "if_gt: unknown option '%c' ignored\n", *cp );
d844 1
a844 1
			gt_zapmem();
a846 4

		/* Pick off just the mode bits of interest here */
		mode &= (MODE_1MASK | MODE_2MASK | MODE_3MASK | MODE_4MASK | 
			MODE_5MASK | MODE_6MASK);
d850 1
d877 1
a888 1

a889 1

d912 2
a913 2
	if( (GTL(ifp) = (char *)calloc( 1, sizeof(struct gtinfo) )) == NULL )  {
		fb_log("gt_dopen:  gtinfo malloc failed\n");
d917 17
d953 1
d957 1
a957 1
		GT(ifp)->mi_curs_on = 0;	/* cursoff() happens below */
d960 1
a960 1
		GT(ifp)->mi_curs_on = 1;	/* Mex usually has it on */
d964 1
a964 1
		GT(ifp)->mi_curs_on = 0;	/* cursoff() happens below */
a966 1
	foreground();		/* Direct focus here, don't detach */
d981 1
a981 1
		GT(ifp)->mi_der1 = getvideo(DE_R1);
d984 2
a985 2
		GT(ifp)->mi_der1 = getvideo(DE_R1);
		if( (GT(ifp)->mi_der1 & DER1_VMASK) == DER1_170 )  {
d994 1
a994 1
			 *  Optional CG2 GENLOCK boark is installed.
a1061 1

d1068 5
d1074 1
a1074 2
	doublebuffer();
	gconfig();	/* Must be called after doublebuffer().	*/
d1079 4
a1082 2
	swapbuffers();
	clear();
d1084 6
a1089 4
	/* Must initialize these window state variables BEFORE calling
		"gt_getmem", because this function can indirectly trigger
		a call to "gt_repaint" (when initializing shared memory
		after a reboot).					*/
d1091 6
a1096 6
	GT(ifp)->mi_xzoom = 1;	/* for zoom fakeout */
	GT(ifp)->mi_yzoom = 1;	/* for zoom fakeout */
	GT(ifp)->mi_xcenter = width/2;
	GT(ifp)->mi_ycenter = height/2;
	GT(ifp)->mi_xoff = 0;
	GT(ifp)->mi_yoff = 0;
d1100 1
a1100 1
	 *  For the GT machines, this is done via mi_xoff, rather
d1115 2
a1116 2
		GT(ifp)->mi_xoff = xleft;
		GT(ifp)->mi_yoff = ybot;
d1123 1
a1123 1
	if( gt_getmem(ifp) < 0 )
d1126 1
a1126 1
	/* Must call "is_linear_cmap" AFTER "gt_getmem" which allocates
d1128 6
a1133 1
	GT(ifp)->mi_cmap_flag = !is_linear_cmap(ifp);
d1144 1
a1144 1
	if( GT(ifp)->mi_curs_on == 0 )  {
d1149 6
a1154 6
	/* The screen has no useful state.  Restore it as it was before */
	/* Smarter deferral logic needed */
	if( (ifp->if_mode & MODE_1MASK) == MODE_1SHARED )
	{
		gt_zbuffer(ifp);	/* Write into the z buffer first */
		gt_repaint( ifp );	/* repaint the screen */
a1155 5

	readsource(SRC_ZBUFFER);
	backbuffer(TRUE);
	frontbuffer(FALSE);

d1160 1
a1160 1
 *			M I P S _ D C L O S E
d1164 1
a1164 1
gt_dclose( ifp )
a1193 1

d1198 8
d1228 4
a1231 2
			gt_zbuffer(ifp);
			gt_repaint(ifp);
d1242 1
a1242 1
			if( fp ) fprintf(fp,"libfb/gt_dclose: qreaderror, aborting\n");
d1253 1
a1253 1
			if( fp ) fprintf(fp,"libfb/gt_dclose: qread %d, val %d\r\n", dev, val );
d1278 1
a1278 1
		setvideo( DE_R1, GT(ifp)->mi_der1 );
d1280 8
d1289 1
a1289 1
	if( GT(ifp)->mi_curs_on == 0 )  {
d1297 2
a1298 2
	if( GTL(ifp) != NULL )
		(void)free( (char *)GT(ifp) );
d1303 1
a1303 1
 *			M I P S _ D C L E A R
d1306 1
a1306 1
gt_dclear( ifp, pp )
d1310 3
d1315 1
a1315 1
		mpw_inqueue(ifp);
d1318 4
a1321 10
		register char *op = ifp->if_mem;
		register int cnt;

		/* Slightly simplistic -- runover to right border */
		for( cnt=GT(ifp)->mi_memwidth*ifp->if_height-1; cnt > 0; cnt-- )  {
			*op++ = (*pp)[RED];
			*op++ = (*pp)[GRN];
			*op++ = (*pp)[BLU];
		}

d1324 4
a1328 1
		BZERO( ifp->if_mem, GT(ifp)->mi_memwidth*ifp->if_height*sizeof(RGBpixel) );
d1330 13
a1342 3
	gt_zbuffer(ifp);
	gt_repaint(ifp);
	clear();
d1347 1
a1347 1
 *			M I P S _ W I N D O W _ S E T
d1350 1
a1350 1
gt_window_set( ifp, x, y )
d1355 1
a1355 1
		mpw_inqueue(ifp);
d1357 1
a1357 1
	if( GT(ifp)->mi_xcenter == x && GT(ifp)->mi_ycenter == y )
d1363 8
a1370 3
	GT(ifp)->mi_xcenter = x;
	GT(ifp)->mi_ycenter = y;
	gt_repaint( ifp );
d1375 1
a1375 1
 *			M I P S _ Z O O M _ S E T
d1378 1
a1378 1
gt_zoom_set( ifp, x, y )
d1383 1
a1383 1
		mpw_inqueue(ifp);
d1387 1
a1387 1
	if( GT(ifp)->mi_xzoom == x && GT(ifp)->mi_yzoom == y )
d1392 2
a1393 2
	GT(ifp)->mi_xzoom = x;
	GT(ifp)->mi_yzoom = y;
d1395 1
a1395 1
	if( GT(ifp)->mi_xzoom > 1 || GT(ifp)->mi_yzoom > 1 )
d1399 6
a1404 1
	gt_repaint( ifp );
d1409 1
a1409 1
 *			M I P S _ B R E A D
d1412 1
a1412 1
gt_bread( ifp, x, y, pixelp, count )
d1415 1
a1415 1
register RGBpixel	*pixelp;
d1418 6
a1423 4
	register short scan_count;
	short xpos, ypos;
	register char *ip;
	int ret;
d1425 3
d1429 1
a1429 1
		mpw_inqueue(ifp);
d1432 1
a1432 1
	    y < 0 || y > ifp->if_height )
d1434 1
d1436 1
a1436 2
	xpos = x;
	ypos = y;
d1438 3
a1440 2
	while( count > 0 )  {
		ip = &ifp->if_mem[(ypos*GT(ifp)->mi_memwidth+xpos)*sizeof(RGBpixel)];
d1442 3
a1444 3
		if ( count >= ifp->if_width-xpos )  {
			scan_count = ifp->if_width-xpos;
		} else	{
d1446 12
d1459 1
a1459 3
		memcpy( *pixelp, ip, scan_count*sizeof(RGBpixel) );

		pixelp += scan_count;
d1461 1
a1461 2
		ret += scan_count;
		xpos = 0;
d1463 1
a1463 1
		if( ++ypos >= ifp->if_height )
d1470 5
a1474 1
 *			M I P S _ B W R I T E
d1477 1
a1477 1
gt_bwrite( ifp, xmem, ymem, pixelp, count )
d1479 2
a1480 2
register int	xmem, ymem;
RGBpixel *pixelp;
d1483 4
a1486 4
	register short scan_count;	/* # pixels on this scanline */
	register unsigned char *cp;
	int xscr, yscr;
	int ret;
d1488 1
a1488 2
	if( qtest() )
		mpw_inqueue(ifp);
d1490 2
a1491 2
	if( xmem < 0 || xmem > ifp->if_width ||
	    ymem < 0 || ymem > ifp->if_height)
a1494 1

d1497 1
a1497 13
	zdraw(TRUE);
	if ( !ifp->if_zoomflag )
	{
		backbuffer(TRUE);
		frontbuffer(TRUE);/* ??? could this be a performance problem??? */
		/* This seems to force lrectwrite to send 3 copies */
	} else {
		backbuffer(FALSE);
		frontbuffer(FALSE);
	}

	while( count )  
	{
d1499 1
d1501 1
a1501 1
		if( ymem >= ifp->if_height )
d1504 2
a1505 2
		if ( count >= ifp->if_width-xmem )
			scan_count = ifp->if_width-xmem;
d1509 2
a1510 4
		/* Move original pixels to shared memory buffer */
		memcpy( (char *)&ifp->if_mem[
		    (ymem*GT(ifp)->mi_memwidth+xmem)*sizeof(RGBpixel)],
		    cp, scan_count*sizeof(RGBpixel) );
d1512 3
a1514 39
		if ( GT(ifp)->mi_cmap_flag == FALSE )  {
			register struct gt_pix * ip = &gt_scan[0];

			n = scan_count;
			if( (n & 3) != 0 )  {
				/* This code uses 60% of all CPU time */
				while( n )  {
					/* alpha channel is always zero */
					ip->red   = cp[RED];
					ip->green = cp[GRN];
					ip->blue  = cp[BLU];
					ip++;
					cp += 3;
					n--;
				}
			} else {
				while( n )  {
					/* alpha channel is always zero */
					ip[0].red   = cp[RED+0*3];
					ip[0].green = cp[GRN+0*3];
					ip[0].blue  = cp[BLU+0*3];
					ip[1].red   = cp[RED+1*3];
					ip[1].green = cp[GRN+1*3];
					ip[1].blue  = cp[BLU+1*3];
					ip[2].red   = cp[RED+2*3];
					ip[2].green = cp[GRN+2*3];
					ip[2].blue  = cp[BLU+2*3];
					ip[3].red   = cp[RED+3*3];
					ip[3].green = cp[GRN+3*3];
					ip[3].blue  = cp[BLU+3*3];
					ip += 4;
					cp += 3*4;
					n -= 4;
				}
			}
		} else {
			register struct gt_pix * ip = &gt_scan[0];

			n = scan_count;
d1517 4
a1520 3
				ip->red = CMR(ifp)[cp[0]];
				ip->green = CMG(ifp)[cp[1]];
				ip->blue = CMB(ifp)[cp[2]];
a1521 1
				ip++;
d1524 19
a1543 5

		/* Addresses are relative to window, not current viewport! */
		lrectwrite( xmem+GT(ifp)->mi_xoff, ymem+GT(ifp)->mi_yoff,
			xmem+GT(ifp)->mi_xoff+scan_count, ymem+GT(ifp)->mi_yoff,
			gt_scan);
d1546 3
a1548 2
		xmem = 0;
		ymem++;
d1551 6
a1556 3
	zdraw(FALSE);
	frontbuffer(FALSE);
	backbuffer(TRUE);
d1558 4
a1561 4
	if ( ifp->if_zoomflag )
	{
		/* When zoomed, this causes the whole screen to repaint */
		gt_repaint( ifp );
a1562 1

d1567 1
a1567 1
 *			M I P S _ V I E W P O R T _ S E T
d1570 1
a1570 1
gt_viewport_set( ifp, left, top, right, bottom )
d1575 1
a1575 8
		mpw_inqueue(ifp);
#if 0
	viewport(	(Screencoord) left,
			(Screencoord) right,
			(Screencoord) top,
			(Screencoord) (bottom * fb2iris_scale)
			);
#endif
d1580 1
a1580 1
 *			M I P S _ C M R E A D
d1583 1
a1583 1
gt_cmread( ifp, cmp )
d1590 1
a1590 1
		mpw_inqueue(ifp);
d1593 2
a1594 3
	for( i = 0; i < 256; i++)
	{
		cmp->cm_red[i] = CMR(ifp)[i]<<8;
d1596 1
a1596 1
		cmp->cm_blue[i] = CMB(ifp)[i]<<8;
d1623 1
a1623 1
 *			 M I P S _ C M W R I T E
d1625 16
d1642 1
a1642 1
gt_cmwrite( ifp, cmp )
d1646 2
a1647 1
	register int i;
d1650 1
a1650 1
		mpw_inqueue(ifp);
d1652 1
d1654 6
a1659 4
		for( i = 0; i < 256; i++)  {
			CMR(ifp)[i] = i;
			CMG(ifp)[i] = i;
			CMB(ifp)[i] = i;
a1660 6
		if( GT(ifp)->mi_cmap_flag ) {
			GT(ifp)->mi_cmap_flag = FALSE;
			gt_repaint( ifp );
		}
		GT(ifp)->mi_cmap_flag = FALSE;
		return(0);
d1662 2
a1663 5
	
	for(i = 0; i < 256; i++)  {
		CMR(ifp)[i] = cmp-> cm_red[i]>>8;
		CMG(ifp)[i] = cmp-> cm_green[i]>>8; 
		CMB(ifp)[i] = cmp-> cm_blue[i]>>8;
d1665 9
a1674 6
	GT(ifp)->mi_cmap_flag = !is_linear_cmap(ifp);

	gt_zbuffer(ifp);

	gt_repaint( ifp );

d1679 1
a1679 1
 *			M I P S _ C U R S _ S E T
d1682 1
a1682 1
gt_curs_set( ifp, bits, xbits, ybits, xorig, yorig )
d1693 1
a1693 1
		mpw_inqueue(ifp);
d1718 1
a1718 1
 *			M I P S _ C M E M O R Y _ A D D R
d1721 1
a1721 1
gt_cmemory_addr( ifp, mode, x, y )
d1732 1
a1732 1
		mpw_inqueue(ifp);
d1734 1
a1734 1
	GT(ifp)->mi_curs_on = mode;
d1740 1
a1740 1
	xwidth = ifp->if_width/GT(ifp)->mi_xzoom;
d1742 3
a1744 3
	xmin = GT(ifp)->mi_xcenter - i;
	i = (ifp->if_height/2)/GT(ifp)->mi_yzoom;
	ymin = GT(ifp)->mi_ycenter - i;
d1747 2
a1748 2
	x *= GT(ifp)->mi_xzoom;
	y *= GT(ifp)->mi_yzoom;
d1763 1
a1763 1
 *			M P W _ I N Q U E U E
d1766 1
a1766 1
 *  Process all events, so that we don't loop on recursion to gt_bwrite.
d1769 1
a1769 1
mpw_inqueue(ifp)
d1786 1
a1786 1
			fb_log("mpw_inqueue:  modechange?\n");
d1793 1
a1793 1
			fb_log("mpw_inqueue:  event %d unknown\n", ev);
a1796 1

d1803 4
a1806 2
		gt_zbuffer(ifp);
		gt_repaint( ifp );
d1811 6
a1816 2
gt_zbuffer(ifp)		/* update the Z_buffer from memory */
FBIO * ifp;
d1818 1
a1818 4
	register unsigned char * op;
	register struct gt_pix * mp;
	register int i,j;
	register unsigned int s_offset;
d1820 12
a1831 1
	s_offset = GT(ifp)->mi_memwidth * sizeof( RGBpixel );
d1833 29
a1861 2
	zbuffer(TRUE);
	zclear();
d1863 4
a1866 3
	
	zdraw(TRUE);
	backbuffer(FALSE);
d1868 1
a1868 3
	for( i = 0; i < ifp->if_height; i++)
	{
		op = (unsigned char *) &ifp->if_mem[ i * s_offset];
d1870 1
a1870 1
		mp = &gt_scan[0];
d1872 14
a1885 22
		for( j = 0; j < ifp->if_width; j++)
		{
			if( GT(ifp)->mi_cmap_flag == FALSE)
			{
				mp->red =  *op++;
				mp->green = *op++;
				mp->blue = *op++;
				mp++;
			} else
			{
				mp->red =  CMR(ifp)[*op++];
				mp->green = CMG(ifp)[*op++];
				mp->blue = CMB(ifp)[*op++];
				mp++;
			}
		}
		/* Addresses are relative to window, not current viewport! */
		lrectwrite( GT(ifp)->mi_xoff+0, i+GT(ifp)->mi_yoff,
			GT(ifp)->mi_xoff+ifp->if_width-1, i+GT(ifp)->mi_yoff,
			gt_scan);
	}
	zdraw(FALSE);
d1888 6
a1893 3
_LOCAL_ int
gt_help( ifp )
FBIO	*ifp;
d1895 1
a1895 1
	struct	modeflags *mfp;
d1897 14
a1910 11
	fb_log( "Description: %s\n", gt_interface.if_type );
	fb_log( "Device: %s\n", ifp->if_name );
	fb_log( "Maximum width height: %d %d\n",
		ifp->if_max_width,
		ifp->if_max_height );
	fb_log( "Default width height: %d %d\n",
		ifp->if_width,
		ifp->if_height );
	fb_log( "Usage: /dev/sgi[options]\n" );
	for( mfp = modeflags; mfp->c != '\0'; mfp++ ) {
		fb_log( "   %c   %s\n", mfp->c, mfp->help );
d1912 4
d1917 9
a1925 1
	return(0);
@


8.5
log
@Fixed handling when shmget fails
@
text
@d21 3
a23 6
 *  There are 4 different Frame Buffer types supported on the 4D/60T or 4D/70
 *  set your environment FB_FILE to the appropriate Frame buffer type
 *	/dev/sgi0 	Transient window private memory
 *	/dev/sgi1	Transient window shared memory ( default )
 *	/dev/sgi2	Lingering window private memory
 *	/dev/sgi3	Lingering window shared memory
d41 1
a41 1
static char RCSid[] = "@@(#)$Header: if_gt.c,v 8.4 88/12/28 00:06:00 mike Locked $ (BRL)";
d151 2
d359 1
a359 1
	fb_log("gt_getmem:  Unable to attach to shared memory.\nConsult comment in cad/libfb/if_4d.c for details\n");
d451 4
a454 1
	rectcopy( xmin, ymin, xmax, ymax, xscroff, yscroff);
d526 1
a526 1
					fb_log( "if_4d: unknown option '%c' ignored\n", *cp );
d641 1
a751 3
			/* Need to clean out images from windows below */
			/* This hack is necessary until windows persist from
			 * process to process */
d753 23
a775 2
	/* In full screen mode, center the image on the
	 * usable part of the screen, either high-res, or NTSC
d779 1
d782 1
d787 3
d795 1
a795 10
	/* Must initialize these window state variables BEFORE calling
		"gt_getmem", because this function can indirectly trigger
		a call to "gt_repaint" (when initializing shared memory
		after a reboot).					*/
	ifp->if_zoomflag = 0;
	GT(ifp)->mi_xzoom = 1;	/* for zoom fakeout */
	GT(ifp)->mi_yzoom = 1;	/* for zoom fakeout */
	GT(ifp)->mi_xcenter = width/2;
	GT(ifp)->mi_ycenter = height/2;

a1116 2


d1120 3
a1122 3
		frontbuffer(TRUE);
	} else
	{
d1194 4
a1197 1
		lrectwrite(xmem,ymem, xmem+scan_count, ymem, gt_scan);
d1210 1
d1411 1
a1411 1
 *  Process all events, so that we don't loop on recursion to sgw_bwrite.
d1494 4
a1497 1
		lrectwrite(0,i, ifp->if_width-1, i, gt_scan);
@


8.4
log
@Loop unrolling for a minor performance win.
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: if_gt.c,v 8.3 88/12/27 22:28:31 mike Locked $ (BRL)";
d351 1
d365 2
a366 2
	ifp->if_mem = sp;
	return(0);
@


8.3
log
@Improved debugging/help message,
Increased speed of pixel to shared-memory-buffer copy,
and pixel to lrectwrite() format conversion copy.
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: if_gt.c,v 8.2 88/11/02 17:13:42 mike Exp $ (BRL)";
a1112 1
		register struct gt_pix * ip;
a1114 2
		ip = &gt_scan[0];

d1129 2
d1132 30
a1161 8
			while( n  )  {
				/* alpha channel is always zero */
				ip->red = cp[0];
				ip->green = cp[1];
				ip->blue = cp[2];
				cp += 3;
				ip++;
				n--;
d1164 2
@


8.2
log
@Added DER1_UNBLANK, which is now necessary.
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: if_gt.c,v 8.1 88/10/05 00:27:34 mike Locked $ (BRL)";
d109 1
a109 1
		"SGI 4D60/GT",
a219 2
#ifdef never				
	/* doesn't work quite right yet... */
a221 1
#endif
d236 1
a236 1
	unsigned char alpha;
d410 2
a411 2
	readsource(SRC_ZBUFFER);
	backbuffer(TRUE);
d752 15
d911 1
d913 8
a1083 1
	register unsigned char *op;
d1126 4
a1129 2
		op = (unsigned char *)&ifp->if_mem[
			(ymem*GT(ifp)->mi_memwidth+xmem)*sizeof(RGBpixel)];
d1131 1
a1131 2
		if ( GT(ifp)->mi_cmap_flag == FALSE )  
		{
d1133 6
a1138 6
			while( n  )
			{
				ip->alpha = 0;
				ip->red = *op++ = *cp++;
				ip->green = *op++ = *cp++;
				ip->blue = *op++ = *cp++;
d1142 1
a1142 3
		} 
		else 
		{
d1144 6
a1149 6
			while( n )
			{
				ip->alpha = 0;
				ip->red = CMR(ifp)[*op++ = *cp++];
				ip->green = CMG(ifp)[*op++ = *cp++];
				ip->blue = CMB(ifp)[*op++ = *cp++];
d1464 3
a1466 3
	fb_log( "Max width height: %d %d\n",
		gt_interface.if_max_width,
		gt_interface.if_max_height );
d1468 2
a1469 2
		gt_interface.if_width,
		gt_interface.if_height );
@


8.1
log
@Release_3.0
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: if_gt.c,v 1.2 88/09/21 00:14:56 mike Exp $ (BRL)";
d661 1
a661 1
		setvideo( DE_R1, DER1_30HZ);	/* 4-wire RS-343 */
d703 1
a703 1
			    	setvideo(DE_R1, DER1_G_170 );
d709 1
a709 1
			    	setvideo(DE_R1, DER1_G_170 );
d715 1
a715 1
				setvideo(DE_R1, DER1_170);
d725 1
a725 1
			setvideo(DE_R1, DER1_170);
@


1.2
log
@Made slight improvements to code which starts the NeWS stuff.
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: if_gt.c,v 1.1 88/09/09 17:37:42 mike Locked $ (BRL)";
@


1.1
log
@Initial revision
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: if_4d.c,v 1.9 88/05/20 15:06:10 stay Exp $ (BRL)";
a486 27
	g_status = ps_open_PostScript();

	if( !g_status )
	{
		int f;
		char * grcond = "/etc/gl/grcond";
		char * newshome = "/usr/brlcad/etc";

		if(((f = fork()) != 0) && ( f != -1))
		{
			goto news_out;			
		} else
		{
			chdir( newshome );
			execl( grcond, (char *) 0 );
		}
news_out:
		g_status = ps_open_PostScript();

		while( !g_status )
		{
			sleep(3);
			g_status = ps_open_PostScript();
		}
	}


d546 27
@
