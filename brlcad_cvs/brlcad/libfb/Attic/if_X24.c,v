head	11.46;
access;
symbols
	ansi-20040405-merged:11.41.2.1
	postmerge-20040405-ansi:11.43
	premerge-20040404-ansi:11.43
	postmerge-autoconf:11.43
	autoconf-freeze:11.43
	premerge-autoconf:11.43
	ansi-20040316-freeze:11.41
	postmerge-20040315-windows:11.43
	premerge-20040315-windows:11.43
	windows-20040315-freeze:11.41.4.1
	autoconf-20031203:11.43
	autoconf-20031202:11.43
	autoconf-branch:11.43.0.6
	phong-branch:11.43.0.4
	photonmap-branch:11.43.0.2
	rel-6-1-DP:11.41
	windows-branch:11.41.0.4
	rel-6-0-2:11.39
	ansi-branch:11.41.0.2
	rel-6-0-1-branch:11.39.0.2
	hartley-6-0-post:11.40
	hartley-6-0-pre:11.39
	rel-6-0-1:11.39
	rel-6-0:11.38
	rel-5-4:11.31.2.3
	offsite-5-3-pre:11.36
	rel-5-3:11.31.2.3
	rel-5-2:11.31.2.1
	rel-5-1-branch:11.31.0.2
	rel-5-1:11.31
	rel-5-0:11.24
	rel-5-0-beta:11.21
	rel-4-5:11.12
	ctj-4-5-post:11.2
	ctj-4-5-pre:11.2
	rel-4-4:11.1;
locks; strict;
comment	@ * @;


11.46
date	2004.05.21.18.07.24;	author morrison;	state dead;
branches;
next	11.45;

11.45
date	2004.05.10.15.30.44;	author erikg;	state Exp;
branches;
next	11.44;

11.44
date	2004.05.10.15.25.27;	author morrison;	state Exp;
branches;
next	11.43;

11.43
date	2003.06.25.20.11.34;	author justin;	state Exp;
branches;
next	11.42;

11.42
date	2003.04.18.21.18.21;	author jra;	state Exp;
branches;
next	11.41;

11.41
date	2002.08.20.17.07.46;	author jra;	state Exp;
branches
	11.41.2.1
	11.41.4.1;
next	11.40;

11.40
date	2002.08.15.20.55.00;	author hartley;	state Exp;
branches;
next	11.39;

11.39
date	2002.08.09.13.32.47;	author jra;	state Exp;
branches;
next	11.38;

11.38
date	2001.10.12.21.34.29;	author bparker;	state Exp;
branches;
next	11.37;

11.37
date	2001.04.20.22.29.14;	author morrison;	state Exp;
branches;
next	11.36;

11.36
date	2001.02.26.19.09.49;	author bparker;	state Exp;
branches;
next	11.35;

11.35
date	2001.01.25.17.54.48;	author bparker;	state Exp;
branches;
next	11.34;

11.34
date	2000.08.18.02.38.56;	author mike;	state Exp;
branches;
next	11.33;

11.33
date	2000.07.25.17.49.50;	author butler;	state Exp;
branches;
next	11.32;

11.32
date	2000.07.12.01.33.30;	author cjohnson;	state Exp;
branches;
next	11.31;

11.31
date	2000.05.10.02.14.50;	author cjohnson;	state Exp;
branches
	11.31.2.1;
next	11.30;

11.30
date	2000.05.10.01.36.32;	author cjohnson;	state Exp;
branches;
next	11.29;

11.29
date	2000.05.05.21.45.38;	author bparker;	state Exp;
branches;
next	11.28;

11.28
date	2000.03.02.02.37.18;	author cjohnson;	state Exp;
branches;
next	11.27;

11.27
date	99.12.29.20.36.00;	author jra;	state Exp;
branches;
next	11.26;

11.26
date	99.12.17.16.32.21;	author bparker;	state Exp;
branches;
next	11.25;

11.25
date	99.11.02.14.16.16;	author bparker;	state Exp;
branches;
next	11.24;

11.24
date	99.07.08.04.25.08;	author cjohnson;	state Exp;
branches;
next	11.23;

11.23
date	99.07.08.04.03.02;	author cjohnson;	state Exp;
branches;
next	11.22;

11.22
date	99.06.03.18.24.51;	author jra;	state Exp;
branches;
next	11.21;

11.21
date	99.04.26.19.10.47;	author bparker;	state Exp;
branches;
next	11.20;

11.20
date	99.04.13.21.55.56;	author bparker;	state Exp;
branches;
next	11.19;

11.19
date	99.04.13.13.34.36;	author bparker;	state Exp;
branches;
next	11.18;

11.18
date	99.04.12.21.49.06;	author bparker;	state Exp;
branches;
next	11.17;

11.17
date	99.02.08.22.23.30;	author mike;	state Exp;
branches;
next	11.16;

11.16
date	99.01.04.13.48.44;	author jra;	state Exp;
branches;
next	11.15;

11.15
date	98.09.22.02.13.55;	author mike;	state Exp;
branches;
next	11.14;

11.14
date	98.09.14.15.59.15;	author bparker;	state Exp;
branches;
next	11.13;

11.13
date	98.06.27.04.29.15;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	98.01.20.20.03.00;	author bparker;	state Exp;
branches;
next	11.11;

11.11
date	98.01.05.20.25.22;	author bparker;	state Exp;
branches;
next	11.10;

11.10
date	97.10.07.05.11.09;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	97.10.07.04.53.24;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	97.10.07.04.39.51;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	97.10.07.04.36.07;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	97.10.07.04.04.16;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	97.10.07.03.18.45;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	97.10.06.19.47.16;	author bparker;	state Exp;
branches;
next	11.3;

11.3
date	97.09.23.21.36.30;	author bparker;	state Exp;
branches;
next	11.2;

11.2
date	96.08.26.23.14.32;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.52.44;	author mike;	state Rel4_4;
branches;
next	1.16;

1.16
date	94.12.30.04.45.09;	author mike;	state Exp;
branches;
next	1.15;

1.15
date	94.12.30.04.43.09;	author mike;	state Exp;
branches;
next	1.14;

1.14
date	94.12.22.22.42.57;	author stay;	state Exp;
branches;
next	1.13;

1.13
date	94.12.22.00.46.13;	author mike;	state Exp;
branches;
next	1.12;

1.12
date	94.12.15.16.27.16;	author jra;	state Exp;
branches;
next	1.11;

1.11
date	94.12.09.08.57.57;	author jra;	state Exp;
branches;
next	1.10;

1.10
date	94.12.07.21.36.54;	author mike;	state Exp;
branches;
next	1.9;

1.9
date	94.12.01.19.36.09;	author mike;	state Exp;
branches;
next	1.8;

1.8
date	94.12.01.19.31.53;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	94.11.24.00.35.26;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	94.11.24.00.18.16;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	94.11.19.00.30.00;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	94.11.18.23.20.27;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	94.11.18.22.42.44;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	94.11.08.05.20.05;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	94.11.08.05.17.26;	author mike;	state Exp;
branches;
next	;

11.31.2.1
date	2000.08.18.13.51.14;	author jra;	state Exp;
branches;
next	11.31.2.2;

11.31.2.2
date	2001.01.25.17.48.04;	author bparker;	state Exp;
branches;
next	11.31.2.3;

11.31.2.3
date	2001.02.26.19.07.37;	author bparker;	state Exp;
branches;
next	;

11.41.2.1
date	2004.03.17.21.17.00;	author morrison;	state Exp;
branches;
next	;

11.41.4.1
date	2004.03.11.23.42.07;	author morrison;	state Exp;
branches;
next	;


desc
@24-bit framebuffer support
@


11.46
log
@moved to src/
@
text
@/*
 *			I F _ X 2 4 . C
 *
 *  X Window System (X11) libfb interface, supporting 24-, 8-, and 1-bit
 *  displays.
 *
 *  Authors -
 *	Christopher J. Jackson, Sun
 *	Timothy G. Smith, Sun
 *	Michael John Muuss, ARL
 *
 *  Source -
 *	Sun Microsystems, Inc.
 *	Southern Area Special Projects Group
 *	6716 Alexander Bell Drive, Suite 200
 *	Columbia, MD 21046
 *  
 *  Copyright Notice -
 *	Copyright (c) 1994 Sun Microsystems, Inc. - All Rights Reserved.
 *
 *	Permission is hereby granted, without written agreement and without
 *	license or royalty fees, to use, copy, modify, and distribute this
 *	software and its documentation for any purpose, provided that the
 *	above copyright notice and the following two paragraphs appear in
 *	all copies of this software.
 *
 *	IN NO EVENT SHALL SUN MICROSYSTEMS INC. BE LIABLE TO ANY PARTY FOR
 *	DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING
 *	OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF SUN
 *	MICROSYSTEMS INC. HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *	SUN MICROSYSTEMS INC. SPECIFICALLY DISCLAIMS ANY WARRANTIES,
 *	INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 *	AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER
 *	IS ON AN "AS IS" BASIS, AND SUN MICROSYSTEMS INC. HAS NO OBLIGATION TO
 *	PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 *
 *  Acknowledgements -
 *	This software is loosely based on the original if_X.c by
 *	Phillip Dykstra of BRL, which was Copyright 1988, US Army.
 */

#define X_DBG	0
#define UPD_DBG 0
#define BLIT_DBG 0
#define EVENT_DBG 0
#define BLIT_DBG_PIX 0

/* Print a debug message on first time into a piece of code */
#if 0
# define DEBUG1(str)	{static int before=1; if(before) {write(2,str, strlen(str)); before=0;} }
#else
# define DEBUG1(str)	/*NIL*/
#endif

#ifndef lint
static const char sccsid[] = "@@(#)if_X24.c version 1.40 (22 Nov 1994)";
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/libfb/if_X24.c,v 11.45 2004/05/10 15:30:44 erikg Exp $ (ARL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <errno.h>
#include <stdio.h>
#include <errno.h>
#include <unistd.h>
#include <sys/types.h>

#if defined(USE_SYS_TIME_H)
# include <sys/time.h>
#endif
#include <time.h>
#ifdef HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include <errno.h>

#include "machine.h"
#include "fb.h"
#include "externs.h"
#include "./fblocal.h"

#ifdef HAVE_SYS_MMAN_H
#  include <unistd.h>
#  include <sys/mman.h>
#  include <fcntl.h>
#  define CAN_LINGER 1
#  undef HAVE_SYS_SHM_H		/* Don't use both ways, mmap is preferred. */
# else
#  ifdef HAVE_SYS_SHM_H
#	include <sys/ipc.h>
#	include <sys/shm.h>
#	define	CAN_LINGER 1
#  endif
#endif

#include <X11/X.h>
#ifdef HAVE_XOSDEFS_H
#include <X11/Xfuncproto.h>
#include <X11/Xosdefs.h>
#endif
#if defined(linux)
#	undef	X_NOT_STDC_ENV
#	undef	X_NOT_POSIX
#endif
#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <X11/Xatom.h>

#include <ctype.h>

#define SHMEM_KEY	42

int X24_refresh();
int X24_close_existing();
int X24_open_existing();
int _X24_open_existing();

static int	X24_open(),
		X24_close(),
		X24_clear(),
		X24_read(),
		X24_write(),
		X24_rmap(),
		X24_wmap(),
		X24_view(),
		X24_getview(),
		X24_setcursor(),
		X24_cursor(),
		X24_getcursor(),
		X24_readrect(),
		X24_writerect(),
		X24_poll(),
		X24_flush(),
		X24_free(),
		X24_help();

static int	X24_getmem();
static void	X24_zapmem();
static void	X24_destroy();
static void	X24_blit();
static void	X24_updstate();

static	int	linger();
static	int	xsetup();
static	void	print_display_info();	/* debug */
static	void	X24_createColorCube();
static	void	X24_createColorTables();

static void X24_handle_event FB_ARGS((FBIO *ifp, XEvent *event));
void X24_configureWindow FB_ARGS((FBIO *ifp, int width, int height));

/* This is the ONLY thing that we normally "export" */
FBIO X24_interface =  {
	0,			/* magic number slot	*/
	X24_open,		/* open device		*/
	X24_close,		/* close device		*/
	X24_clear,		/* clear device		*/
	X24_read,		/* read	pixels		*/
	X24_write,		/* write pixels		*/
	X24_rmap,		/* read colormap	*/
	X24_wmap,		/* write colormap	*/
	X24_view,		/* set view		*/
	X24_getview,		/* get view		*/
	X24_setcursor,		/* define cursor	*/
	X24_cursor,		/* set cursor		*/
	X24_getcursor,		/* get cursor		*/
	X24_readrect,		/* read rectangle	*/
	X24_writerect,		/* write rectangle	*/
	fb_sim_bwreadrect,
	fb_sim_bwwriterect,
	X24_poll,		/* process events	*/
	X24_flush,		/* flush output		*/
	X24_free,		/* free resources	*/
	X24_help,		/* help message		*/
	"24 bit X Window System (X11)",	/* device description	*/
	2048,			/* max width		*/
	2048,			/* max height		*/
	"/dev/X",		/* short device name	*/
	512,			/* default/current width  */
	512,			/* default/current height */
	-1,			/* select file desc	*/
	-1,			/* file descriptor	*/
	1, 1,			/* zoom			*/
	256, 256,		/* window center	*/
	0, 0, 0,		/* cursor		*/
	PIXEL_NULL,		/* page_base		*/
	PIXEL_NULL,		/* page_curp		*/
	PIXEL_NULL,		/* page_endp		*/
	-1,			/* page_no		*/
	0,			/* page_dirty		*/
	0L,			/* page_curpos		*/
	0L,			/* page_pixels		*/
	0			/* debug		*/
};


/*
 * Per window state information.
 */
struct	xinfo {
	Display		*xi_dpy;	/* Display and Screen(s) info */
	Window		xi_win;		/* Window ID */
	int		xi_screen;	/* Our screen selection */
	Visual		*xi_visual;	/* Our visual selection */
	XVisualInfo	xi_visinfo;	/* Visual Info */
	int		xi_depth;	/* Depth of our window */
	GC		xi_gc;		/* current graphics context */
	GC		xi_cgc;		/* graphics context for clipping */
	Region		xi_reg;		/* Valid displayed region */
	int		xi_usereg;	/* Flag determining whether or not to use regions */
	Colormap	xi_cmap;	/* Colormap */
	XImage		*xi_image;	/* XImage (size of screen) */
	Window		xi_cwinp;	/* Cursor's Parent Window ID */
	Window		xi_cwin;	/* Cursor Window ID */
	unsigned long	xi_wp;		/* White pixel */
	unsigned long	xi_bp;		/* Black pixel */

	/*
	 * Pixel buffer usage:
	 *
	 * xi_mem is the actual data received from the user.  It's stored
	 * in 24-bit RGB format, in image-space coordinates.
	 *
	 * xi_pix is the panned, zoomed, and possibly colormapped output
	 * image.  It's stored in whatever X11 format makes sense for our
	 * Visual, in X11-space coordinates.  This is the buffer backing
	 * xi_image.
	 *
	 */

	unsigned char	*xi_mem;	/* 24-bit backing store */
	unsigned char	*xi_pix;	/* X Image buffer */

#ifdef HAVE_SYS_SHM_H
	int		xi_shmid;	/* Sys V shared mem id */
#endif

	unsigned long	xi_mode;	/* 0,1,2 */
	unsigned long	xi_flags;

	ColorMap 	*xi_rgb_cmap;	/* User's libfb colormap */
	unsigned char	*xi_redmap;	/* Fake colormap for non-DirectColor */
	unsigned char	*xi_blumap;	/* Fake colormap for non-DirectColor */
	unsigned char	*xi_grnmap;	/* Fake colormap for non-DirectColor */

	unsigned char	*xi_ccredtbl;	/* Lookup table for red component */
	unsigned char	*xi_ccgrntbl;	/* Lookup table for green component */
	unsigned char	*xi_ccblutbl;	/* Lookup table for blue component */

	unsigned char	*xi_andtbl;	/* Lookup table for 1-bit dithering */
	unsigned char	*xi_ortbl;	/* Lookup table for 1-bit dithering */

	int		xi_ncolors;	/* Number of colors in colorcube */
	int		xi_base;	/* Base color in colorcube */

	/* The following values are in Image Pixels */

	int		xi_iwidth;	/* Width of user's whole image */
	int		xi_iheight;	/* Height of user's whole image */

	int		xi_ilf;		/* Image coordinate of LLHC image */
	int		xi_ibt;		/*  pixel */
	int		xi_irt;		/* Image coordinate of URHC image */
	int		xi_itp;		/*  pixel */

	/* The following values are in X Pixels */

	int		xi_ilf_w;	/* Width of leftmost image pixels */
	int		xi_irt_w;	/* Width of rightmost image pixels */
	int		xi_ibt_h;	/* Height of bottommost image pixels */
	int		xi_itp_h;	/* Height of topmost image pixels */

	int		xi_xwidth;	/* Width of X window */
	int		xi_xheight;	/* Height of X window */

	int		xi_xlf;		/* X-coord of leftmost pixels */
	int		xi_xrt;		/* X-coord of rightmost pixels */
	int		xi_xtp;		/* Y-coord of topmost pixels */
	int		xi_xbt;		/* Y-coord of bottomost pixels */
};
#define	XI(ptr) ((struct xinfo *)((ptr)->u1.p))
#define	XI_SET(ptr, val) ((ptr)->u1.p) = (char *) val;


/* Flags in xi_flags */

#define FLG_VMASK       0x07	/* Visual mask */
				/* Note: values below are in preference order*/
#define FLG_VD24        0x01	/* 24-bit DirectColor */
#define FLG_VT24        0x02	/* 24-bit TrueColor */
#define FLG_VD16        0x03	/* 16-bit DirectColor */
#define FLG_VT16        0x04	/* 16-bit TrueColor */
#define FLG_VP8         0x05	/* 8-bit PseudoColor */
#define FLG_VS8         0x06	/* 8-bit StaticGray */
#define FLG_VG8		0x07	/* 8-bit GrayScale */
#define FLG_VS1         0x08	/* 1-bit StaticGray */

#define FLG_LINCMAP	0x10	/* We're using a linear colormap */
#define FLG_XCMAP	0x20	/* The X server can do colormapping for us */
#define FLG_INIT	0x40	/* Display is fully initialized */

/* Mode flags for open */

#define MODE1_MASK	(1<<1)
#define MODE1_TRANSIENT	(0<<1)
#define MODE1_LINGERING (1<<1)

#define MODEV_MASK	(7<<1)

#define MODE10_MASK	(1<<10)
#define MODE10_MALLOC	(0<<10)
#define MODE10_SHARED	(1<<10)

#define MODE11_MASK	(1<<11)
#define MODE11_NORMAL	(0<<11)
#define MODE11_ZAP	(1<<11)

static struct modeflags {
	char		c;
	unsigned long	mask;
	unsigned long	value;
	char		*help;
} modeflags[] = {
	{ 'l',	MODE1_MASK, MODE1_LINGERING,
		"Lingering window - else transient" },
	{ 's',  MODE10_MASK, MODE10_SHARED,
		"Use shared memory backing store" },
	{ 'z',	MODE11_MASK, MODE11_ZAP,
		"Zap (free) shared memory" },
	{ 'D',	MODEV_MASK, FLG_VD24 << 1,
		"Select 24-bit DirectColor display if available" },
	{ 'T',	MODEV_MASK, FLG_VT24 << 1,
		"Select 24-bit TrueColor display if available" },
	{ 'P',	MODEV_MASK, FLG_VP8 << 1,
		"Select 8-bit PseudoColor display if available" },
	{ 'S',	MODEV_MASK, FLG_VS8 << 1,
		"Select 8-bit StaticGray display if available" },
	{ 'G',	MODEV_MASK, FLG_VG8 << 1,
		"Select 8-bit GrayScale display if available" },
	{ 'M',	MODEV_MASK, FLG_VS1 << 1,
		"Select 1-bit StaticGray display if available" },
	{ '\0', 0, 0, "" }
};

/* Flags for X24_blit's flags argument */

#define	BLIT_DISP	0x1	/* Write bits to screen */
#define BLIT_PZ		0x2	/* This is a pan or zoom */
#define BLIT_RESIZE	0x4	/* We just resized (screen empty) */

#define BS_NAME	"/tmp/X24_fb"

/* Elements of 6x9x4 colorcube */

static unsigned char reds[] = { 0, 51, 102, 153, 204, 255 };
static unsigned char grns[] = { 0, 32, 64, 96, 128, 159, 191, 223, 255 };
static unsigned char blus[] = { 0, 85, 170, 255 };

/* Dither masks */

static float dmsk881[] = { 
0.705882, 0.956863, 0.235294, 0.486275, 0.737255, 0.988235, 0.203922, 0.454902,
0.172549, 0.423529, 0.674510, 0.925490, 0.141176, 0.392157, 0.643137, 0.894118,
0.580392, 0.831373, 0.109804, 0.360784, 0.611765, 0.862745, 0.078431, 0.329412,
0.047059, 0.298039, 0.549020, 0.800000, 0.015686, 0.266667, 0.517647, 0.768628,
0.721569, 0.972549, 0.188235, 0.439216, 0.690196, 0.941177, 0.219608, 0.470588,
0.125490, 0.376471, 0.627451, 0.878431, 0.156863, 0.407843, 0.658824, 0.909804,
0.596078, 0.847059, 0.062745, 0.313726, 0.564706, 0.815686, 0.094118, 0.345098,
0.000000, 0.250980, 0.501961, 0.752941, 0.031373, 0.282353, 0.533333, 0.784314
};

static float dmsk883[] = { 
0.784314, 0.533333, 0.282353, 0.031373, 0.752941, 0.501961, 0.250980, 0.000000,
0.345098, 0.094118, 0.815686, 0.564706, 0.313726, 0.062745, 0.847059, 0.596078,
0.909804, 0.658824, 0.407843, 0.156863, 0.878431, 0.627451, 0.376471, 0.125490,
0.470588, 0.219608, 0.941177, 0.690196, 0.439216, 0.188235, 0.972549, 0.721569,
0.768628, 0.517647, 0.266667, 0.015686, 0.800000, 0.549020, 0.298039, 0.047059,
0.329412, 0.078431, 0.862745, 0.611765, 0.360784, 0.109804, 0.831373, 0.580392,
0.894118, 0.643137, 0.392157, 0.141176, 0.925490, 0.674510, 0.423529, 0.172549,
0.454902, 0.203922, 0.988235, 0.737255, 0.486275, 0.235294, 0.956863, 0.705882,

0.988235, 0.737255, 0.486275, 0.235294, 0.956863, 0.705882, 0.454902, 0.203922,
0.392157, 0.141176, 0.925490, 0.674510, 0.423529, 0.172549, 0.894118, 0.643137,
0.862745, 0.611765, 0.360784, 0.109804, 0.831373, 0.580392, 0.329412, 0.078431,
0.266667, 0.015686, 0.800000, 0.549020, 0.298039, 0.047059, 0.768628, 0.517647,
0.941177, 0.690196, 0.439216, 0.188235, 0.972549, 0.721569, 0.470588, 0.219608,
0.407843, 0.156863, 0.878431, 0.627451, 0.376471, 0.125490, 0.909804, 0.658824,
0.815686, 0.564706, 0.313726, 0.062745, 0.847059, 0.596078, 0.345098, 0.094118,
0.282353, 0.031373, 0.752941, 0.501961, 0.250980, 0.000000, 0.784314, 0.533333,
 
0.000000, 0.250980, 0.501961, 0.752941, 0.031373, 0.282353, 0.533333, 0.784314,
0.596078, 0.847059, 0.062745, 0.313726, 0.564706, 0.815686, 0.094118, 0.345098,
0.125490, 0.376471, 0.627451, 0.878431, 0.156863, 0.407843, 0.658824, 0.909804,
0.721569, 0.972549, 0.188235, 0.439216, 0.690196, 0.941177, 0.219608, 0.470588,
0.047059, 0.298039, 0.549020, 0.800000, 0.015686, 0.266667, 0.517647, 0.768628,
0.580392, 0.831373, 0.109804, 0.360784, 0.611765, 0.862745, 0.078431, 0.329412,
0.172549, 0.423529, 0.674510, 0.925490, 0.141176, 0.392157, 0.643137, 0.894118,
0.705882, 0.956863, 0.235294, 0.486275, 0.737255, 0.988235, 0.203922, 0.454902
};

/* Luminance factor tables (filled in in xsetup()) */

static int lumdone = 0;		/* Nonzero if tables valid */
static unsigned long rlumtbl[256];
static unsigned long glumtbl[256];
static unsigned long blumtbl[256];


/*
 *			X 2 4 _ O P E N
 */
static int
X24_open(ifp, file, width, height)
FBIO	*ifp;
char	*file;
int	width, height;
{
	struct xinfo *xi;

	unsigned long mode;			/* local copy */
	int getmem_stat;

#if X_DBG
printf("X24_open(ifp:0x%x, file:%s width:%d, height:%d): entered.\n",
       ifp, file, width, height);
#endif
	FB_CK_FBIO(ifp);

	mode = 0;
	
	/*
	 *  First, attempt to determine operating mode for this open,
	 *  based upon the "unit number" or flags.
	 *  file = "/dev/X###"
	 *  The default mode is zero.
	 */
	if (file != NULL)  {
		register char *cp;
		char	modebuf[80];
		char	*mp;
		int	alpha;
		struct	modeflags *mfp;

		if (strncmp(file, ifp->if_name, strlen(ifp->if_name))) {
			/* How did this happen?? */
			mode = 0;
		}
		else {
			/* Parse the options */
			alpha = 0;
			mp = &modebuf[0];
			cp = &file[sizeof("/dev/X")-1];
			while(*cp != '\0' && !isspace(*cp)) {
				*mp++ = *cp;	/* copy it to buffer */
				if (isdigit(*cp)) {
					cp++;
					continue;
				}
				alpha++;
				for(mfp = modeflags; mfp->c != '\0'; mfp++) {
					if (mfp->c == *cp) {
						mode = (mode&~mfp->mask)|mfp->value;
						break;
					}
				}
				if (mfp->c == '\0' && *cp != '-') {
					fb_log("if_X24: unknown option '%c' ignored\n", *cp);
				}
				cp++;
			}
			*mp = '\0';
			if (!alpha)
				mode = atoi(modebuf);
		}
	}

	/* Just zap the shared memory and exit */
	if ((mode & MODE11_MASK) == MODE11_ZAP) {
		/* Only task: Attempt to release shared memory segment */
		X24_zapmem();
		return(-1);
	}

	if (width <= 0)
		width = ifp->if_width;
	if (height <= 0)
		height = ifp->if_height;
	if (width > ifp->if_max_width) 
		width = ifp->if_max_width;
	if (height > ifp->if_max_height) 
		height = ifp->if_max_height;

	ifp->if_width = width;
	ifp->if_height = height;

	ifp->if_xzoom = 1;
	ifp->if_yzoom = 1;
	ifp->if_xcenter = width/2;
	ifp->if_ycenter = height/2;

	/* create a struct of state information */
	if ((xi = (struct xinfo *) calloc(1, sizeof(struct xinfo))) == NULL) {
		fb_log("X24_open: xinfo malloc failed\n");
		return(-1);
	}
	XI_SET(ifp, xi);

	xi->xi_mode = mode;
	xi->xi_iwidth = width;
	xi->xi_iheight = height;

	/* Allocate backing store (shared memory or local) */

	if ((getmem_stat = X24_getmem(ifp)) == -1) {
		X24_destroy(xi);
		return (-1);
	}

	/* Set up an X window, graphics context, etc. */

	if (xsetup(ifp, width, height) < 0) {
		X24_destroy(xi);
		return(-1);
	}

	/* Update state for blits */

	X24_updstate(ifp);

	/* Make the Display connection available for selecting on */
	ifp->if_selfd = ConnectionNumber(xi->xi_dpy);

	/* If we already have data, display it */

	if (getmem_stat == 0) {
		X24_wmap(ifp, xi->xi_rgb_cmap);
		X24_blit(ifp, 0, 0, xi->xi_iwidth, xi->xi_iheight, BLIT_DISP);
	} else {
		/* Set up default linear colormap */
		X24_wmap(ifp, NULL);
	}

	/* Mark display ready */

	xi->xi_flags |= FLG_INIT;


	return(0);
}

int
X24_open_existing(ifp, argc, argv)
FBIO *ifp;
int argc;
char **argv;
{
  Display *dpy;
  Window win;
  Window cwinp;
  Colormap cmap;
  XVisualInfo *vip;
  int width;
  int height;
  GC gc;

  if(argc != 9)
    return -1;

  if(sscanf(argv[1], "%lu", (unsigned long *)&dpy) != 1)
     return -1;

  if(sscanf(argv[2], "%lu", (unsigned long *)&win) != 1)
    return -1;

  if(sscanf(argv[3], "%lu", (unsigned long *)&cwinp) != 1)
    return -1;

  if(sscanf(argv[4], "%lu", (unsigned long *)&cmap) != 1)
    return -1;

  if(sscanf(argv[5], "%lu", (unsigned long *)&vip) != 1)
    return -1;

  if(sscanf(argv[6], "%d", &width) != 1)
    return -1;

  if(sscanf(argv[7], "%d", &height) != 1)
    return -1;

  if(sscanf(argv[8], "%lu", (unsigned long *)&gc) != 1)
    return -1;

  return _X24_open_existing(ifp, dpy, win, cwinp, cmap, vip, width, height, gc);
}

int
_X24_open_existing(ifp, dpy, win, cwinp, cmap, vip, width, height, gc)
FBIO *ifp;
Display *dpy;
Window win;
Window cwinp;
Colormap cmap;
XVisualInfo *vip;
int width;
int height;
GC gc;
{
  struct xinfo *xi;
#if 0
  XRectangle rect;
#endif
  int getmem_stat;

  ifp->if_width = width;
  ifp->if_height = height;

  ifp->if_xzoom = 1;
  ifp->if_yzoom = 1;

  ifp->if_xcenter = width/2;
  ifp->if_ycenter = height/2;

  /* create a struct of state information */
  if ((xi = (struct xinfo *)calloc(1, sizeof(struct xinfo))) == NULL) {
    fb_log("X24_open: xinfo malloc failed\n");
    return -1;
  }
  XI_SET(ifp, xi);

  /* X setup */
  xi->xi_xwidth = width;
  xi->xi_xheight = height;
  xi->xi_dpy = dpy;
  xi->xi_screen = DefaultScreen(xi->xi_dpy);

  xi->xi_visinfo = *vip;		/* struct copy */
  xi->xi_visual = vip->visual;
  xi->xi_depth = vip->depth;
  xi->xi_cmap = cmap;
  xi->xi_win = win;
  xi->xi_cwinp = cwinp;

  /*XXX For now use same GC for both */
  xi->xi_gc = gc;
  xi->xi_cgc = gc;


  switch (vip->class) {
  case TrueColor:
    if (vip->depth >= 24) {
      xi->xi_mode = FLG_VT24 << 1;
      xi->xi_flags = FLG_VT24;
      xi->xi_wp = 0xFFFFFF;
      xi->xi_bp = 0x000000;
    } else if (vip->depth >= 16) {
      xi->xi_mode = FLG_VT16 << 1;
      xi->xi_flags = FLG_VT16;
      xi->xi_wp = 0xFFFFFF;
      xi->xi_bp = 0x000000;
    } else {
      xi->xi_mode = FLG_VS1 << 1;
      xi->xi_flags = FLG_VS1;
      xi->xi_wp = 0x0;
      xi->xi_bp = 0x1;
    }

    break;
  case DirectColor:
    if (vip->depth >= 24) {
      xi->xi_mode = FLG_VD24 << 1;
      xi->xi_flags = FLG_VD24 | FLG_XCMAP;
      xi->xi_wp = 0xFFFFFF;
      xi->xi_bp = 0x000000;
    } else if (vip->depth >= 16) {
      xi->xi_mode = FLG_VD16 << 1;
      xi->xi_flags = FLG_VD16 | FLG_XCMAP;
      xi->xi_wp = 0xFFFFFF;
      xi->xi_bp = 0x000000;
    } else {
      xi->xi_mode = FLG_VS1 << 1;
      xi->xi_flags = FLG_VS1 | FLG_XCMAP;
      xi->xi_wp = 0x0;
      xi->xi_bp = 0x1;
    }

    break;
  case PseudoColor:
    if (vip->depth >= 8) {
      xi->xi_mode = FLG_VP8 << 1;
      xi->xi_flags = FLG_VP8 | FLG_XCMAP;

      xi->xi_ncolors = sizeof (reds) * sizeof (blus) * sizeof (grns);
      xi->xi_base = 255 - xi->xi_ncolors;
      xi->xi_bp = xi->xi_base;
      xi->xi_wp = xi->xi_base + xi->xi_ncolors - 1;

      X24_createColorTables(xi);
    } else {
      xi->xi_mode = FLG_VS1 << 1;
      xi->xi_flags = FLG_VS1 | FLG_XCMAP;
      xi->xi_wp = 0x0;
      xi->xi_bp = 0x1;
    }

    break;
  default:
    xi->xi_mode = FLG_VS1 << 1;
    xi->xi_flags = FLG_VS1 | FLG_XCMAP;
    xi->xi_wp = 0x0;
    xi->xi_bp = 0x1;

    break;
  }

  if (!(xi->xi_flags & FLG_XCMAP)) {
	  xi->xi_redmap = (unsigned char *)malloc(256);
	  xi->xi_grnmap = (unsigned char *)malloc(256);
	  xi->xi_blumap = (unsigned char *)malloc(256);

	  if (!xi->xi_redmap || !xi->xi_grnmap || !xi->xi_blumap) {
		  fb_log("if_X24: Can't allocate colormap memory\n");
		  return (-1);
	  }
  }

  xi->xi_iwidth = width;
  xi->xi_iheight = height;

  /* Allocate backing store (shared memory or local) */
  if ((getmem_stat = X24_getmem(ifp)) == -1) {
	  free((char *)xi);
	  return -1;
  }

#if 0
  /* Initialize the valid region */
  xi->xi_reg = XCreateRegion();
  rect.x = 0;
  rect.y = 0;
  rect.width = xi->xi_xwidth;
  rect.height = xi->xi_xheight;
  XUnionRectWithRegion(&rect, xi->xi_reg, xi->xi_reg);
#else
  /* We're not using Region's */
  xi->xi_reg = (Region)0;
  xi->xi_usereg = 0;
#endif

  /* this will be reallocated in the call to X24_configureWindow */
  if ((xi->xi_pix = (unsigned char *) calloc(1, 1)) == NULL) {
    fb_log("X24_open: calloc failed\n");
    return -1;
  }

  /* this will be destroyed in the call to X24_configureWindow */
  xi->xi_image = XCreateImage(xi->xi_dpy,
			      xi->xi_visual, xi->xi_depth, ZPixmap, 0,
			      (char *) xi->xi_pix, 1, 1, 8, 0);

  /* Update state for blits */
  X24_updstate(ifp);

  /* Make the Display connection available for selecting on */
  ifp->if_selfd = ConnectionNumber(xi->xi_dpy);

  if (getmem_stat == 0) {
	  X24_wmap(ifp, xi->xi_rgb_cmap);
	  X24_blit(ifp, 0, 0, xi->xi_iwidth, xi->xi_iheight, BLIT_DISP);
  } else {
	  /* Set up default linear colormap */
	  X24_wmap(ifp, NULL);
  }

  /* Mark display ready */
  xi->xi_flags |= FLG_INIT;

  /* force reconfiguration */
  xi->xi_xwidth = 0;
  xi->xi_xheight = 0;
  X24_configureWindow(ifp, width, height);

  return 0;
}

static int
X24_close(ifp)
FBIO	*ifp;
{
	struct xinfo *xi = XI(ifp);

	XFlush(xi->xi_dpy);
	if ((xi->xi_mode & MODE1_MASK) == MODE1_LINGERING) {
		if (linger(ifp))
			return(0);	/* parent leaves the display */
	}

	X24_destroy(xi);

	return (0);
}

int
X24_close_existing(ifp)
FBIO    *ifp;
{
  struct xinfo *xi = XI(ifp);

  if (xi->xi_image)
    XDestroyImage(xi->xi_image);

  if (xi->xi_reg)
    XDestroyRegion(xi->xi_reg);

  if (xi->xi_ccredtbl)
    free(xi->xi_ccredtbl);
  if (xi->xi_ccgrntbl)
    free(xi->xi_ccgrntbl);
  if (xi->xi_ccblutbl)
    free(xi->xi_ccblutbl);

  free((char *)xi);

  return (0);
}

static void
X24_destroy(xi)
struct xinfo *xi;
{
	if (xi) {
		if (xi->xi_rgb_cmap &&
		    (xi->xi_mode & MODE10_MASK) == MODE10_MALLOC)
			free(xi->xi_rgb_cmap);

		if (xi->xi_redmap)
			free(xi->xi_redmap);
		if (xi->xi_grnmap)
			free(xi->xi_grnmap);
		if (xi->xi_blumap)
			free(xi->xi_blumap);
		if (xi->xi_ccredtbl)
			free(xi->xi_ccredtbl);
		if (xi->xi_ccgrntbl)
			free(xi->xi_ccgrntbl);
		if (xi->xi_ccblutbl)
			free(xi->xi_ccblutbl);
		if (xi->xi_andtbl)
			free(xi->xi_andtbl);
		if (xi->xi_ortbl)
			free(xi->xi_ortbl);

		if (xi->xi_dpy) {
			if (xi->xi_cgc)
				XFreeGC(xi->xi_dpy, xi->xi_cgc);

			if (xi->xi_gc)
				XFreeGC(xi->xi_dpy, xi->xi_gc);

			if (xi->xi_image)
				XDestroyImage(xi->xi_image);

			if (xi->xi_reg)
				XDestroyRegion(xi->xi_reg);

			XCloseDisplay(xi->xi_dpy);
		}

		free((char *) xi);
	}
}

static int
X24_clear(ifp, pp)
FBIO	*ifp;
unsigned char	*pp;
{
  struct xinfo *xi = XI(ifp);

  int red, grn, blu;
  int npix;
  int n;
  unsigned char *cp;

#if X_DBG
  printf("X24_clear(ifp:0x%x, pp:0x%x) pixel = (%d, %d, %d): entered.\n",
	 ifp, pp, pp[RED], pp[GRN], pp[BLU]);
#endif

  if(pp == (unsigned char *)NULL){
    red = grn = blu = 0;
  }else{
    red = pp[RED];
    grn = pp[GRN];
    blu = pp[BLU];
  }

  /* Clear the backing store */
  npix = xi->xi_iwidth * xi->xi_xheight;

  if(red == grn && red == blu){
    memset(xi->xi_mem, red, npix*3);
  }else{
    cp = xi->xi_mem;
    n = npix;
    while(n--){
      *cp++ = red;
      *cp++ = grn;
      *cp++ = blu;
    }
  }

  X24_blit(ifp, 0, 0, xi->xi_iwidth, xi->xi_iheight,
	   BLIT_DISP | BLIT_PZ);

  return(0);
}


static int
X24_read(ifp, x, y, pixelp, count)
FBIO	*ifp;
int	x, y;
unsigned char	*pixelp;
int	count;
{
	struct xinfo *xi = XI(ifp);
	int maxcount;

	/* check origin bounds */
	if (x < 0 || x >= xi->xi_iwidth || y < 0 || y >= xi->xi_iheight)
		return	-1;

	/* clip read length */
	maxcount = xi->xi_iwidth * (xi->xi_iheight - y) - x;
	if (count > maxcount)
		count = maxcount;

	memcpy(pixelp, &(xi->xi_mem[(y*xi->xi_iwidth+x)*sizeof(RGBpixel)]),
		count*sizeof(RGBpixel));
	return (count);
}


static int
X24_write(ifp, x, y, pixelp, count)
FBIO	*ifp;
int	x, y;
const unsigned char	*pixelp;
int	count;
{
	struct xinfo *xi = XI(ifp);

	int	maxcount;

#if X_DBG
printf("X24_write(ifp:0x%x, x:%d, y:%d, pixelp:0x%x, count:%d) entered.\n",
	ifp, x, y, pixelp, count);
#endif

	/* Check origin bounds */
	if (x < 0 || x >= xi->xi_iwidth || y < 0 || y >= xi->xi_iheight)
		return	-1;

	/* Clip write length */
	maxcount = xi->xi_iwidth * (xi->xi_iheight - y) - x;
	if (count > maxcount)
		count = maxcount;

	/* Save it in 24bit backing store */

	memcpy(&(xi->xi_mem[(y*xi->xi_iwidth+x)*sizeof(RGBpixel)]),
	      pixelp, count*sizeof(RGBpixel));

	/* Get the bits to the screen */

	if (x + count <= xi->xi_iwidth)
		X24_blit(ifp, x, y, count, 1, BLIT_DISP);
	else {
		int ylines;
		int tcount;

		tcount = count - (xi->xi_iwidth - x);
		ylines = 1 + (tcount + xi->xi_iwidth - 1) / xi->xi_iwidth;

		X24_blit(ifp, 0, y, xi->xi_iwidth, ylines, BLIT_DISP);
	}

	return(count);
}

static int
X24_rmap(ifp, cmp)
FBIO	*ifp;
ColorMap	*cmp;
{
	struct xinfo *xi = XI(ifp);

#if X_DBG
printf("X24_rmap(ifp:0x%x, cmp:0x%x) entered.\n",
	ifp, cmp);
#endif

	memcpy(cmp, xi->xi_rgb_cmap, sizeof (ColorMap));

	return(0);
}

static int
X24_wmap(ifp, cmp)
FBIO	*ifp;
const ColorMap	*cmp;
{
	struct xinfo *xi = XI(ifp);
	ColorMap *map = xi->xi_rgb_cmap;
	int waslincmap;

#if X_DBG
printf("X24_wmap(ifp:0x%x, cmp:0x%x) entered.\n",
	ifp, cmp);
#endif

	/* Did we have a linear colormap before this call? */

	waslincmap = xi->xi_flags & FLG_LINCMAP;

	/* Clear linear colormap flag, since it may be changing */

	xi->xi_flags &= ~FLG_LINCMAP;

	/* Copy in or generate colormap */

	if (cmp) {
		if (cmp != map)
			memcpy(map, cmp, sizeof (ColorMap));
	} else {
		fb_make_linear_cmap(map);
		xi->xi_flags |= FLG_LINCMAP;
	}

	/* Decide if this colormap is linear */

	if (!(xi->xi_flags & FLG_LINCMAP)) {
		int i;
		int nonlin = 0;

		for (i = 0; i < 256; i++)
			if (map->cm_red[i] >> 8 != i ||
			    map->cm_green[i] >> 8 != i ||
			    map->cm_blue[i] >> 8 != i) {
				nonlin = 1;
				break;
			}

		if (!nonlin)
			xi->xi_flags |= FLG_LINCMAP;
	}
	
	/*
	 * If it was linear before, and they're making it linear again,
	 * there's nothing to do.
	 */
	if (waslincmap && xi->xi_flags & FLG_LINCMAP)
		return (0);

	if (xi->xi_flags & FLG_XCMAP) {
		XColor cells[256];
		int i;
		
		/* Copy into the server's colormap. */

		for (i = 0; i < 256; i++) {
			cells[i].pixel = (i << 16) | (i << 8) | i;
			cells[i].red = map->cm_red[i];
			cells[i].green = map->cm_green[i];
			cells[i].blue = map->cm_blue[i];
			cells[i].flags = DoRed | DoGreen | DoBlue;
		}

		XStoreColors(xi->xi_dpy, xi->xi_cmap, cells, 256);
	} else {
		int i;
		unsigned char *red = xi->xi_redmap;
		unsigned char *grn = xi->xi_grnmap;
		unsigned char *blu = xi->xi_blumap;

		/* Copy into our fake colormap arrays. */

		for (i = 0; i < 256; i++) {
			red[i] = map->cm_red[i] >> 8;
			grn[i] = map->cm_green[i] >> 8;
			blu[i] = map->cm_blue[i] >> 8;
		}

		/*
		 * If we're initialized, redraw the screen to make changes
		 * take effect.
		 */

		if (xi->xi_flags & FLG_INIT)
			X24_blit(ifp, 0, 0, xi->xi_iwidth, xi->xi_iheight,
				BLIT_DISP);
	}

	return(0);
}

static int
X24_view(ifp, xcenter, ycenter, xzoom, yzoom)
FBIO	*ifp;
int	xcenter, ycenter;
int	xzoom, yzoom;
{
	struct xinfo *xi = XI(ifp);


#if X_DBG
printf("X24_view(ifp:0x%x, xcenter:%d, ycenter:%d, xzoom:%d, yzoom:%d) entered.\n",
	ifp, xcenter, ycenter, xzoom, yzoom);
#endif

	/* bypass if no change */
	if (ifp->if_xcenter == xcenter && ifp->if_ycenter == ycenter
	 && ifp->if_xzoom == xcenter && ifp->if_yzoom == ycenter)
		return	0;
	/* check bounds */
	if (xcenter < 0 || xcenter >= xi->xi_iwidth
	 || ycenter < 0 || ycenter >= xi->xi_iheight)
		return	-1;
	if (xzoom <= 0 || xzoom >= xi->xi_iwidth/2
	 || yzoom <= 0 || yzoom >= xi->xi_iheight/2)
		return	-1;

	ifp->if_xcenter = xcenter;
	ifp->if_ycenter = ycenter;
	ifp->if_xzoom = xzoom;
	ifp->if_yzoom = yzoom;

	X24_updstate(ifp);
	X24_blit(ifp, 0, 0, xi->xi_iwidth, xi->xi_iheight,
		BLIT_DISP | BLIT_PZ);

	return	0;
}

static int
X24_getview(ifp, xcenter, ycenter, xzoom, yzoom)
FBIO	*ifp;
int	*xcenter, *ycenter;
int	*xzoom, *yzoom;
{

#if X_DBG
printf("X24_getview(ifp:0x%x, xcenter:0x%x, ycenter:0x%x, xzoom:0x%x, yzoom:0x%x) entered.\n",
	ifp, xcenter, ycenter, xzoom, yzoom);
#endif

	*xcenter = ifp->if_xcenter;
	*ycenter = ifp->if_ycenter;
	*xzoom = ifp->if_xzoom;
	*yzoom = ifp->if_yzoom;

	return(0);
}

/*ARGSUSED*/
static int
X24_setcursor(ifp, bits, xbits, ybits, xorig, yorig)
FBIO	*ifp;
const unsigned char *bits;
int	xbits, ybits;
int	xorig, yorig;
{

#if X_DBG
printf("X24_setcursor(ifp:0x%x, bits:%u, xbits:%d, ybits:%d, xorig:%d, yorig:%d) entered.\n",
	ifp, bits, xbits, ybits, xorig, yorig);
#endif

	return(0);
}

static int
X24_cursor(ifp, mode, x, y)
FBIO	*ifp;
int	mode;
int	x, y;
{
  struct xinfo *xi = XI(ifp);

#if X_DBG
  printf("X24_cursor(ifp:0x%x, mode:%d, x:%d, y:%d) entered.\n",
	 ifp, mode, x, y);
#endif

  if (mode) {
    register int xx, xy;
    register int delta;

    /* If we don't have a cursor, create it */
    if (!xi->xi_cwin) {
      XSetWindowAttributes xswa;

      xswa.background_pixel = xi->xi_bp;
      xswa.border_pixel = xi->xi_wp;
      xswa.colormap = xi->xi_cmap;
      xswa.save_under = True;

      xi->xi_cwin = XCreateWindow(xi->xi_dpy, xi->xi_cwinp,
				     0, 0, 4, 4, 2, xi->xi_depth, InputOutput,
				     xi->xi_visual, CWBackPixel | CWBorderPixel |
				     CWSaveUnder | CWColormap, &xswa);
    }

    delta = ifp->if_width/ifp->if_xzoom/2;
    xx = x - (ifp->if_xcenter - delta);
    xx *= ifp->if_xzoom;
    xx += ifp->if_xzoom/2;  /* center cursor */

    delta = ifp->if_height/ifp->if_yzoom/2;
    xy = y - (ifp->if_ycenter - delta);
    xy *= ifp->if_yzoom;
    xy += ifp->if_yzoom/2;  /* center cursor */
    xy = xi->xi_xheight - xy;

    /* Move cursor into place; make it visible if it isn't */
    XMoveWindow(xi->xi_dpy, xi->xi_cwin, xx - 4, xy - 4);

    if (!ifp->if_cursmode)
      XMapRaised(xi->xi_dpy, xi->xi_cwin);
  } else {
    /* If we have a cursor and it's visible, hide it */
    if (xi->xi_cwin && ifp->if_cursmode)
      XUnmapWindow(xi->xi_dpy, xi->xi_cwin);
  }

  /* Without this flush, cursor movement is sluggish */
  XFlush(xi->xi_dpy);

  /* Update position of cursor */
  ifp->if_cursmode = mode;
  ifp->if_xcurs = x;
  ifp->if_ycurs = y;

  return(0);
}

static int
X24_getcursor(ifp, mode, x, y)
FBIO	*ifp;
int	*mode;
int	*x, *y;
{

#if X_DBG
printf("X24_getcursor(ifp:0x%x, mode:%d, x:0x%x, y:0x%x) entered.\n",
	ifp, mode, x, y);
#endif

	fb_sim_getcursor(ifp, mode, x, y);

	return(0);
}

static int
X24_readrect(ifp, xmin, ymin, width, height, pp)
FBIO	*ifp;
int	xmin, ymin;
int	width, height;
unsigned char	*pp;
{
	struct xinfo *xi = XI(ifp);


#if X_DBG
printf("X24_readrect(ifp:0x%x, xmin:%d, ymin:%d, width:%d, height:%d, pp:0x%x) entered.\n",
	ifp, xmin, ymin, width, height, pp);
#endif
	/* Clip arguments */

	if (xmin < 0)
		xmin = 0;
	if (ymin < 0)
		ymin = 0;
	if (xmin + width > xi->xi_iwidth)
		width = xi->xi_iwidth - xmin;
	if (ymin + height > xi->xi_iheight)
		height = xi->xi_iheight - ymin;

	/* Do copy to backing store */

	if (xmin == 0 && width == xi->xi_iwidth) {
		/* We can do it all in one copy */

		memcpy(pp, &(xi->xi_mem[ymin * xi->xi_iwidth *
			sizeof (RGBpixel)]),
			width * height * sizeof (RGBpixel));
	} else {
		/* Need to do individual lines */

		int ht = height;
		unsigned char *p = &(xi->xi_mem[(ymin * xi->xi_iwidth + xmin) *
			sizeof (RGBpixel)]);

		while (ht--) {
			memcpy(pp, p, width * sizeof (RGBpixel));
			p += xi->xi_iwidth * sizeof (RGBpixel);
			pp += width * sizeof (RGBpixel);
		}
	}

	return (width * height);
}

static int
X24_writerect(ifp, xmin, ymin, width, height, pp)
FBIO	*ifp;
int	xmin, ymin;
int	width, height;
const unsigned char	*pp;
{
	struct xinfo *xi = XI(ifp);

#if X_DBG
printf("X24_writerect(ifp:0x%x, xmin:%d, ymin:%d, width:%d, height:%d, pp:0x%x) entered.\n",
	ifp, xmin, ymin, width, height, pp);
#endif

	/* Clip arguments */

	if (xmin < 0)
		xmin = 0;
	if (ymin < 0)
		ymin = 0;
	if (xmin + width > xi->xi_iwidth)
		width = xi->xi_iwidth - xmin;
	if (ymin + height > xi->xi_iheight)
		height = xi->xi_iheight - ymin;

	/* Do copy to backing store */

	if (xmin == 0 && width == xi->xi_iwidth) {
		/* We can do it all in one copy */

		memcpy(&(xi->xi_mem[ymin * xi->xi_iwidth * sizeof (RGBpixel)]),
			pp, width * height * sizeof (RGBpixel));
	} else {
		/* Need to do individual lines */

		int ht = height;
		unsigned char *p = &(xi->xi_mem[(ymin * xi->xi_iwidth + xmin) *
			sizeof (RGBpixel)]);

		while (ht--) {
			memcpy(p, pp, width * sizeof (RGBpixel));
			p += xi->xi_iwidth * sizeof (RGBpixel);
			pp += width * sizeof (RGBpixel);
		}
	}

	/* Flush to screen */

	X24_blit(ifp, xmin, ymin, width, height, BLIT_DISP);

	return (width * height);
}

static int
X24_poll(ifp)
FBIO	*ifp;
{
	struct xinfo *xi = XI(ifp);

	XEvent	event;

#if 0
printf("X24_poll(ifp:0x%x) entered\n", ifp);
#endif

	/* Check for and dispatch event */
	while (XCheckMaskEvent(xi->xi_dpy, ~NoEventMask, &event))
	  X24_handle_event(ifp, &event);

	return(0);
}

static int
X24_flush(ifp)
FBIO	*ifp;
{
	struct xinfo *xi = XI(ifp);


#if X_DBG
printf("X24_flush(ifp:0x%x) entered\n", ifp);
#endif

	XFlush(xi->xi_dpy);
	return(0);
}

static int
X24_free(ifp)
FBIO	*ifp;
{

#if X_DBG
printf("X24_free(ifp:0x%x) entered\n", ifp);
#endif

	return(0);
}

static int
X24_help(ifp)
FBIO	*ifp;
{
	struct xinfo *xi = XI(ifp);
	struct	modeflags *mfp;

#if X_DBG
printf("X24_help(ifp:0x%x) entered\n", ifp);
#endif

	fb_log("Description: %s\n", X24_interface.if_type);
	fb_log("Device: %s\n", ifp->if_name);
	fb_log("Max width/height: %d %d\n",
		X24_interface.if_max_width,
		X24_interface.if_max_height);
	fb_log("Default width/height: %d %d\n",
		X24_interface.if_width,
		X24_interface.if_height);
	fb_log("Usage: /dev/X[options]\n");
	for(mfp = modeflags; mfp->c != '\0'; mfp++) {
		fb_log("   %c   %s\n", mfp->c, mfp->help);
	}

	fb_log( "\nCurrent internal state:\n");
	fb_log( "	xi_depth=%d\n", xi->xi_depth );
	fb_log( "	xi_mode=%d\n", xi->xi_mode );
	fb_log( "	xi_flags=%d\n", xi->xi_flags );
	fb_log( "	xi_xwidth=%d\n", xi->xi_xwidth );
	fb_log( "	xi_xheight=%d\n", xi->xi_xheight );

	fb_log("X11 Visual:\n");
	fb_log( "	class=%d\n", xi->xi_visinfo.class );

	switch(xi->xi_visinfo.class) {
	case DirectColor:
		fb_log("\tDirectColor: Alterable RGB maps, pixel RGB subfield indicies\n");
		fb_log("\tRGB Masks: 0x%x 0x%x 0x%x\n", xi->xi_visinfo.red_mask,
		       xi->xi_visinfo.green_mask, xi->xi_visinfo.blue_mask);
		break;
	case TrueColor:
		fb_log("\tTrueColor: Fixed RGB maps, pixel RGB subfield indicies\n");
		fb_log("\tRGB Masks: 0x%x 0x%x 0x%x\n", xi->xi_visinfo.red_mask,
		       xi->xi_visinfo.green_mask, xi->xi_visinfo.blue_mask);
		break;
	case PseudoColor:
		fb_log("\tPseudoColor: Alterable RGB maps, single index\n");
		break;
	case StaticColor:
		fb_log("\tStaticColor: Fixed RGB maps, single index\n");
		break;
	case GrayScale:
		fb_log("\tGrayScale: Alterable map (R=G=B), single index\n");
		break;
	case StaticGray:
		fb_log("\tStaticGray: Fixed map (R=G=B), single index\n");
		break;
	default:
		fb_log("\tUnknown visual class %d\n",
		       xi->xi_visinfo.class);
		break;
	}
	fb_log("\tColormap Size: %d\n", xi->xi_visinfo.colormap_size);
	fb_log("\tBits per RGB: %d\n", xi->xi_visinfo.bits_per_rgb);
	fb_log("\tscreen: %d\n", xi->xi_visinfo.screen);
	fb_log("\tdepth (total bits per pixel): %d\n", xi->xi_visinfo.depth);
	if( xi->xi_visinfo.depth < 24 )
		fb_log("\tWARNING: unable to obtain full 24-bits of color, image will be quantized.\n");

	return(0);
}

/*
  Create 6x9x4 color cube.
*/
static void
X24_createColorCube(xi)
struct xinfo *xi;
{
  int i;
  int redmul, grnmul;
  unsigned long pixels[256], pmask[1], pixel[1];
  XColor colors[256];

  /*
   * Color cube is in RGB order
   */
  grnmul = sizeof (blus);
  redmul = sizeof (blus) * sizeof (grns);

  XAllocColorCells(xi->xi_dpy, xi->xi_cmap, 1, pmask, 0, pixels,
		   xi->xi_base + xi->xi_ncolors);

  for (pixel[0] = 0; pixel[0] < xi->xi_base; pixel[0]++) {
    XFreeColors(xi->xi_dpy, xi->xi_cmap, pixel, 1, 0);
  }

  /* Fill the colormap and the colorcube */
  for (i = 0; i < xi->xi_ncolors; i++) {
    colors[i].red = reds[i / redmul] << 8;
    colors[i].green = grns[(i % redmul) / grnmul] << 8;
    colors[i].blue = blus[i % grnmul] << 8;
    colors[i].flags = DoRed | DoGreen | DoBlue;
    colors[i].pixel = xi->xi_base + i;
  }

  XStoreColors(xi->xi_dpy, xi->xi_cmap, colors, xi->xi_ncolors);
}

/*
  Create fast lookup tables for dithering
*/
static void
X24_createColorTables(xi)
struct xinfo *xi;
{
  int i, j, idx;
  int redmul, grnmul;

  grnmul = sizeof (blus);
  redmul = sizeof (blus) * sizeof (grns);

  xi->xi_ccredtbl = (unsigned char *)malloc(64 * 256);
  xi->xi_ccgrntbl = (unsigned char *)malloc(64 * 256);
  xi->xi_ccblutbl = (unsigned char *)malloc(64 * 256);

  for (i = 0; i < 256; i++) {
    int redval, grnval, bluval;
    int redtbl, grntbl, blutbl;
    int reditbl, grnitbl, bluitbl;

    idx = i / (256 / (sizeof (reds) - 1));
    reditbl = redtbl = idx * redmul;
    if (idx < (sizeof (reds) - 1))
      reditbl += redmul;
    redval = reds[idx];
			
    idx = i / (256 / (sizeof (grns) - 1));
    grnitbl = grntbl = idx * grnmul;
    if (idx < (sizeof (grns) - 1))
      grnitbl += grnmul;
    grnval = grns[idx];
			
    idx = i / (256 / (sizeof (blus) - 1));
    bluitbl = blutbl = idx;
    if (idx < (sizeof (blus) - 1))
      bluitbl++;
    bluval = blus[idx];
			
    for (j = 0; j < 64; j++) {
      if (i - redval > (256 / (sizeof (reds) - 1)) *
	  dmsk883[128+j])
	xi->xi_ccredtbl[(i << 6) + j] = reditbl;
      else
	xi->xi_ccredtbl[(i << 6) + j] = redtbl;

      if (i - grnval > (256 / (sizeof (grns) - 1)) *
	  dmsk883[64+j])
	xi->xi_ccgrntbl[(i << 6) + j] = grnitbl;
      else
	xi->xi_ccgrntbl[(i << 6) + j] = grntbl;

      if (i - bluval > (256 / (sizeof (blus) - 1)) *
	  dmsk883[j])
	xi->xi_ccblutbl[(i << 6) + j] = bluitbl;
      else
	xi->xi_ccblutbl[(i << 6) + j] = blutbl;
    }
  }
}

static
int
xsetup(ifp, width, height)
FBIO	*ifp;
int	width, height;
{
	struct xinfo *xi = XI(ifp);

	XGCValues	gcv;
	XSizeHints	xsh;		/* part of the "standard" props */
	XWMHints	xwmh;		/* size guidelines for window mngr */
	XSetWindowAttributes xswa;
	XRectangle rect;
	char		*xname;

#if X_DBG
printf("xsetup(ifp:0x%x, width:%d, height:%d) entered\n", ifp, width, height);
#endif

	/* Save these in state structure */

	xi->xi_xwidth = width;
	xi->xi_xheight = height;

	/* Open the display - use the env variable DISPLAY */
	xname = XDisplayName(NULL);
	/* Attempt one level of fallback, esp. for fbserv daemon */
	if( !xname || *xname == '\0' )  xname = ":0";

	if ((xi->xi_dpy = XOpenDisplay(xname)) == NULL) {
		fb_log("if_X: Can't open X display \"%s\"\n", xname);
		return	-1;
	}

#if 0
	print_display_info(xi->xi_dpy);
#endif

	/* Use the screen we connected to */
	xi->xi_screen = DefaultScreen(xi->xi_dpy);

	/*
	 * Here we try to get the best possible visual that's no better than the
	 * one that the user asked for.  Note that each case falls through to
	 * the next.
	 */

	switch ((xi->xi_mode & MODEV_MASK) >> 1)
	{
	default:
	case FLG_VD24:
		if (XMatchVisualInfo(xi->xi_dpy, xi->xi_screen, 24, DirectColor,
		    &xi->xi_visinfo)) {
			xi->xi_flags |= FLG_XCMAP | FLG_VD24;
			break;
		}
		/*FALLTHROUGH*/
	case FLG_VT24:
		if (XMatchVisualInfo(xi->xi_dpy, xi->xi_screen, 24, TrueColor,
		    &xi->xi_visinfo)) {
			xi->xi_flags |= FLG_VT24;
			break;
		}
		/*FALLTHROUGH*/
	case FLG_VD16:
		if (XMatchVisualInfo(xi->xi_dpy, xi->xi_screen, 16, DirectColor,
		    &xi->xi_visinfo)) {
			xi->xi_flags |= FLG_XCMAP | FLG_VD16;
			break;
		}
		/*FALLTHROUGH*/
	case FLG_VT16:
		if (XMatchVisualInfo(xi->xi_dpy, xi->xi_screen, 16, TrueColor,
		    &xi->xi_visinfo)) {
			xi->xi_flags |= FLG_VT16;
			break;
		}
		/*FALLTHROUGH*/
	case FLG_VP8:
		if (XMatchVisualInfo(xi->xi_dpy, xi->xi_screen, 8, PseudoColor,
		    &xi->xi_visinfo)) {
			xi->xi_flags |= FLG_VP8;
			break;
		}
		/*FALLTHROUGH*/
	case FLG_VS8:
		if (XMatchVisualInfo(xi->xi_dpy, xi->xi_screen, 8, StaticGray,
		    &xi->xi_visinfo)) {
			xi->xi_flags |= FLG_VS8;
			break;
		}
		/*FALLTHROUGH*/
	case FLG_VG8:
		if (XMatchVisualInfo(xi->xi_dpy, xi->xi_screen, 8, GrayScale,
		    &xi->xi_visinfo)) {
			xi->xi_flags |= FLG_VG8;
			break;
		}
		/*FALLTHROUGH*/
	case FLG_VS1:
		if (XMatchVisualInfo(xi->xi_dpy, xi->xi_screen, 1, StaticGray,
		    &xi->xi_visinfo)) {
			xi->xi_flags |= FLG_VS1;
			break;
		}
		/*FALLTHROUGH*/
		fb_log("if_X24: Can't get supported Visual on X display \"%s\"\n",
		       XDisplayName(NULL));
		print_display_info(xi->xi_dpy);
		return (-1);
	}

	xi->xi_visual = xi->xi_visinfo.visual;
	xi->xi_depth = xi->xi_visinfo.depth;

	/* Set up colormaps, white/black pixels */

	switch (xi->xi_flags & FLG_VMASK)
	{
	case FLG_VD24:
		xi->xi_cmap = XCreateColormap(xi->xi_dpy, RootWindow(xi->xi_dpy,
			xi->xi_screen), xi->xi_visual, AllocAll);
		xi->xi_wp = 0xFFFFFF;
		xi->xi_bp = 0x000000;
		break;

	case FLG_VT24:
		/*
		 * We need this colormap, even though we're not really going to
		 * use it, because if we don't specify a colormap when we
		 * create the window (thus getting the default), and the
		 * default visual is not 24-bit, the window create will fail.
		 */

		xi->xi_cmap = XCreateColormap(xi->xi_dpy, RootWindow(xi->xi_dpy,
			xi->xi_screen), xi->xi_visual, AllocNone);
		xi->xi_wp = 0xFFFFFF;
		xi->xi_bp = 0x000000;
		break;

	case FLG_VD16:
		xi->xi_cmap = XCreateColormap(xi->xi_dpy, RootWindow(xi->xi_dpy,
			xi->xi_screen), xi->xi_visual, AllocAll);
		xi->xi_wp = 0xFFFFFF;
		xi->xi_bp = 0x000000;
		break;

	case FLG_VT16:
		/*
		 * We need this colormap, even though we're not really going to
		 * use it, because if we don't specify a colormap when we
		 * create the window (thus getting the default), and the
		 * default visual is not 24-bit, the window create will fail.
		 */

		xi->xi_cmap = XCreateColormap(xi->xi_dpy, RootWindow(xi->xi_dpy,
			xi->xi_screen), xi->xi_visual, AllocNone);
		xi->xi_wp = 0xFFFFFF;
		xi->xi_bp = 0x000000;
		break;

	case FLG_VP8:
	{
		xi->xi_cmap = XCreateColormap(xi->xi_dpy, RootWindow(xi->xi_dpy,
			xi->xi_screen), xi->xi_visual, AllocNone);

		xi->xi_ncolors = sizeof (reds) * sizeof (blus) * sizeof (grns);
		xi->xi_base = 255 - xi->xi_ncolors;

		/* Create color cube */
		X24_createColorCube(xi);

		/* Create fast lookup tables for dithering */
		X24_createColorTables(xi);

		/* Do white/black pixels */
		xi->xi_bp = xi->xi_base;
		xi->xi_wp = xi->xi_base + xi->xi_ncolors - 1;

		break;
	}

	case FLG_VS8:
		/*
		 * We need this colormap, even though we're not really going to
		 * use it, because if we don't specify a colormap when we
		 * create the window (thus getting the default), and the
		 * default visual is not 8-bit, the window create will fail.
		 */

		xi->xi_cmap = XCreateColormap(xi->xi_dpy, RootWindow(xi->xi_dpy,
			xi->xi_screen), xi->xi_visual, AllocNone);
		xi->xi_wp = 0xFF;
		xi->xi_bp = 0x00;
		break;

	case FLG_VG8:
	{
		/*
		 * We're being a little lazy here by just taking over the
		 * entire colormap and writing a linear ramp to it.  If we
		 * didn't take the whole thing we might be able to avoid a
		 * little colormap flashing, but then we'd need separate
		 * display code for GrayScale and StaticGray and I'm just not
		 * sure it's worth it.
		 */

		int	i;
		XColor	colors[256];

		xi->xi_cmap = XCreateColormap(xi->xi_dpy, RootWindow(xi->xi_dpy,
			xi->xi_screen), xi->xi_visual, AllocAll);

		/* Fill the colormap and the colorcube */

		for (i = 0; i < 255; i++) {
			colors[i].red = i << 8;
			colors[i].green = i << 8;
			colors[i].blue = i << 8;
			colors[i].flags = DoRed | DoGreen | DoBlue;
			colors[i].pixel = i;
		}

		XStoreColors(xi->xi_dpy, xi->xi_cmap, colors, 256);

		/* Do white/black pixels */

		xi->xi_bp = 0x00;
		xi->xi_wp = 0xFF;
		break;
	}
	case FLG_VS1:
	{
		int i, j, x, didx;

		/*
		 * We need this colormap, even though we're not really going to
		 * use it, because if we don't specify a colormap when we
		 * create the window (thus getting the default), and the
		 * default visual is not 1-bit, the window create will fail.
		 */

		xi->xi_cmap = XCreateColormap(xi->xi_dpy, RootWindow(xi->xi_dpy,
			xi->xi_screen), xi->xi_visual, AllocNone);

		/* Create fast lookup tables for dithering */

		xi->xi_andtbl = (unsigned char *)malloc(64 * 256);
		xi->xi_ortbl = (unsigned char *)malloc(64 * 256);

		for (i = 0; i < 256; i++)
			for (j = 0; j < 64; j++) {
				didx = j;
				x = 7 - (j & 0x7);

				if (i > (256.0 * dmsk881[didx])) {
					xi->xi_andtbl[(i << 6) + j] = 0xFF;
					xi->xi_ortbl[(i << 6) + j] = 1 << x;
				}
				else {
					xi->xi_andtbl[(i << 6) + j] = ~(1 << x);
					xi->xi_ortbl[(i << 6) + j] = 0;
				}
			}

		xi->xi_wp = 0x0;
		xi->xi_bp = 0x1;
		break;
	}
	}

	/* Create fake colormaps if the X server won't do it for us */

	if (!(xi->xi_flags & FLG_XCMAP)) {
		xi->xi_redmap = (unsigned char *)malloc(256);
		xi->xi_grnmap = (unsigned char *)malloc(256);
		xi->xi_blumap = (unsigned char *)malloc(256);

		if (!xi->xi_redmap || !xi->xi_grnmap || !xi->xi_blumap) {
			fb_log("if_X24: Can't allocate colormap memory\n");
			return (-1);
		}
	}

	/*
	 * Fill in XSetWindowAttributes struct for XCreateWindow.
	 */
	xswa.event_mask = ExposureMask | ButtonPressMask | StructureNotifyMask;
	xswa.background_pixel = xi->xi_bp;
	xswa.border_pixel = xi->xi_wp;
	xswa.bit_gravity = ForgetGravity;
#ifdef X_DBG
	xswa.backing_store = NotUseful;
#else
	xswa.backing_store = Always;
#endif
	xswa.colormap = xi->xi_cmap;

#if X_DBG
printf("Creating window\n");
#endif

	xi->xi_win = XCreateWindow(xi->xi_dpy, RootWindow(xi->xi_dpy,
		xi->xi_screen), 0, 0, width, height, 3, xi->xi_depth,
		InputOutput, xi->xi_visual, CWEventMask | CWBackPixel |
		    CWBorderPixel | CWBitGravity | CWBackingStore | CWColormap,
		&xswa);
	xi->xi_cwinp = xi->xi_win;

	if (xi->xi_win == 0) {
		fb_log("if_X: Can't create window\n");
		return	-1;
	}

	/* Tell window manager about colormap */

	XSetWindowColormap(xi->xi_dpy, xi->xi_win, xi->xi_cmap);

	/*
	 * Fill in XSizeHints struct to inform window
	 * manager about initial size and location.
	 */
	xsh.flags = PPosition | PSize | PMinSize | PMaxSize;
	xsh.width = width;
	xsh.max_width = ifp->if_max_width;
	xsh.min_width = 0;
	xsh.height = height;
	xsh.max_height = ifp->if_max_height;
	xsh.min_height = 0;
	xsh.x = xsh.y = 0;

	/* Set standard properties for Window Managers */

	XSetStandardProperties(xi->xi_dpy, xi->xi_win,
		"Frame buffer",		/* window name */
		"Frame buffer",		/* icon name */
		None,			/* icon pixmap */
		NULL, 0,		/* command (argv, argc) */
		&xsh);			/* size hints */

	xwmh.input = False;		/* no terminal input? */
	xwmh.initial_state = NormalState;
	xwmh.flags = InputHint | StateHint;
	XSetWMHints(xi->xi_dpy, xi->xi_win, &xwmh);

	/* Create a Graphics Context for drawing */

	gcv.foreground = xi->xi_wp;
	gcv.background = xi->xi_bp;
	xi->xi_gc = XCreateGC(xi->xi_dpy, xi->xi_win,
		GCForeground | GCBackground, &gcv);

	/* Create a Graphics Context for clipping */

	gcv.foreground = xi->xi_bp;
	gcv.background = xi->xi_bp;
	xi->xi_cgc = XCreateGC(xi->xi_dpy, xi->xi_win,
		GCForeground | GCBackground, &gcv);

	/* Initialize the valid region */
	xi->xi_usereg = 1;
	xi->xi_reg = XCreateRegion();
	rect.x = 0;
	rect.y = 0;
	rect.width = xi->xi_xwidth;
	rect.height = xi->xi_xheight;
	XUnionRectWithRegion(&rect, xi->xi_reg, xi->xi_reg);

	/* Map window to screen */

	XMapWindow(xi->xi_dpy, xi->xi_win);
	XFlush(xi->xi_dpy);

	/* Allocate image buffer, and make our X11 Image */

	switch (xi->xi_flags & FLG_VMASK)
	{
	case FLG_VD24:
	case FLG_VT24:
	  if ((xi->xi_pix = (unsigned char *) calloc(sizeof(unsigned int),
						     width*height)) == NULL) {
			fb_log("X24_open: pix32 malloc failed\n");
			return(-1);
		}

		xi->xi_image = XCreateImage(xi->xi_dpy,
			xi->xi_visual, xi->xi_depth, ZPixmap, 0,
			(char *) xi->xi_pix, width, height,
			 sizeof(unsigned int) * 8, 0);
		break;

	case FLG_VD16:
	case FLG_VT16:
	  if ((xi->xi_pix = (unsigned char *) calloc(2, width*height)) == NULL) {
			fb_log("X24_open: pix32 malloc failed\n");
			return(-1);
		}

		xi->xi_image = XCreateImage(xi->xi_dpy,
			xi->xi_visual, xi->xi_depth, ZPixmap, 0,
			(char *) xi->xi_pix, width, height,
			16, 0);
		break;

	case FLG_VP8:
	case FLG_VS8:
	case FLG_VG8:
		if ((xi->xi_pix = (unsigned char *) calloc(sizeof(char),
							   width*height)) == NULL) {
			fb_log("X24_open: pix8 malloc failed\n");
			return(-1);
		}
		memset(xi->xi_pix, xi->xi_bp, width*height);

		xi->xi_image = XCreateImage(xi->xi_dpy,
			xi->xi_visual, xi->xi_depth, ZPixmap, 0,
			(char *) xi->xi_pix, width, height, 8, 0);
		break;

	case FLG_VS1:
		xi->xi_image = XCreateImage(xi->xi_dpy,
			xi->xi_visual, xi->xi_depth, XYBitmap, 0,
			NULL, width, height, 32, 0);

		if ((xi->xi_pix = (unsigned char *) calloc(sizeof(char),
							   xi->xi_image->bytes_per_line * height)) == NULL) {
			fb_log("X24_open: pix1 malloc failed\n");
			return(-1);
		}
		xi->xi_image->data = (char *) xi->xi_pix;
		xi->xi_image->byte_order = MSBFirst;
		xi->xi_image->bitmap_bit_order = MSBFirst;

		memset(xi->xi_pix, 0, xi->xi_image->bytes_per_line *
		    height);
		break;
	}

	/* Calculate luminance tables if we need them */

	switch (xi->xi_flags & FLG_VMASK)
	{
	case FLG_VG8:
	case FLG_VS1:
		if (!lumdone) {
			int i;
			for (i = 0; i < 256; i++) {
				rlumtbl[i] = i * 5016388;
				glumtbl[i] = i * 9848226;
				blumtbl[i] = i * 1912603;
			}
			lumdone = 1;
		}
	}

	return (0);
}

static int alive = 1;

static int
linger(ifp)
FBIO	*ifp;
{
	struct xinfo *xi = XI(ifp);
	XEvent	event;

	if (fork() != 0)
		return (1);	/* release the parent */

	while(alive) {
		XNextEvent(xi->xi_dpy, &event);
		X24_handle_event(ifp, &event);
	}
	return (0);
}


static void
X24_handle_event(ifp, event)
FBIO *ifp;
XEvent *event;
{
  struct xinfo *xi = XI(ifp);

  switch((int)event->type){
  case Expose:
    {
      XExposeEvent *expose = (XExposeEvent *)event;
      int ex1, ey1, ex2, ey2;

#if EVENT_DBG
      printf("expose event x= %d y= %d width= %d height= %d\n",
	     expose->x, expose->y, expose->width, expose->height);
#endif

      ex1 = expose->x;
      ey1 = expose->y;
      ex2 = ex1 + expose->width - 1;
      ey2 = ey1 + expose->height - 1;

      /* Clip to outline of valid bits in window */
      if (ex1 < xi->xi_xlf)
	ex1 = xi->xi_xlf;
      if (ex2 > xi->xi_xrt)
	ex2 = xi->xi_xrt;
      if (ey1 < xi->xi_xtp)
	ey1 = xi->xi_xtp;
      if (ey2 > xi->xi_xbt)
	ey2 = xi->xi_xbt;

#if EVENT_DBG
      printf("expose limits (%d, %d) to (%d, %d)\n",
	     xi->xi_xlf, xi->xi_xtp, xi->xi_xrt, xi->xi_xbt);
      printf("clipped expose (%d, %d) to (%d, %d)\n",
	     ex1, ey1, ex2, ey2);
#endif

      if (ex2 >= ex1 && ey2 >= ey1)
	XPutImage(xi->xi_dpy, xi->xi_win, xi->xi_gc,
		  xi->xi_image, ex1, ey1, ex1,
		  ey1, ex2 - ex1 + 1, ey2 - ey1 + 1);
      break;
    }
  case ButtonPress:
    {
      int button = (int) event->xbutton.button;
      if (button == Button1) {
	/* Check for single button mouse remap.
	 * ctrl-1 => 2
	 * meta-1 => 3
	 */
	if (event->xbutton.state & ControlMask)
	  button = Button2;
	else if (event->xbutton.state & Mod1Mask)
	  button = Button3;
      }

      switch(button){
      case Button1:
	break;
      case Button2:
	{
	  int	x, sy;
	  int	ix, isy;
	  unsigned char	*cp;

	  x = event->xbutton.x;
	  sy = xi->xi_xheight - event->xbutton.y - 1;

	  x -= xi->xi_xlf;
	  sy -= xi->xi_xheight - xi->xi_xbt - 1;
	  if(x < 0 || sy < 0){
	    fb_log("No RGB (outside image) 1\n");
	    break;
	  }

	  if (x < xi->xi_ilf_w)
	    ix = xi->xi_ilf;
	  else
	    ix = xi->xi_ilf + (x - xi->xi_ilf_w + ifp->if_xzoom - 1) / ifp->if_xzoom;

	  if (sy < xi->xi_ibt_h)
	    isy = xi->xi_ibt;
	  else
	    isy = xi->xi_ibt + (sy - xi->xi_ibt_h + ifp->if_yzoom - 1) / ifp->if_yzoom;

	  if(ix >= xi->xi_iwidth || isy >= xi->xi_iheight){
	    fb_log("No RGB (outside image) 2\n");
	    break;
	  }

	  cp = &(xi->xi_mem[(isy*xi->xi_iwidth + ix)*3]);
	  fb_log("At image (%d, %d), real RGB=(%3d %3d %3d)\n",
		 ix, isy, cp[RED], cp[GRN], cp[BLU]);

	  break;
	}
      case Button3:
	alive = 0;
	break;
      }
      break;
    }
  case ConfigureNotify:
    {
      XConfigureEvent *conf = (XConfigureEvent *)event;

      if(conf->width == xi->xi_xwidth &&
	 conf->height == xi->xi_xheight)
	return;

#if EVENT_DBG
      printf("configure, oldht %d oldwid %d newht %d newwid %d\n",
	     xi->xi_xheight, xi->xi_xwidth, conf->height,
	     conf->width);
#endif

      X24_configureWindow(ifp, conf->width, conf->height);

      /*
       * Blit backing store to image buffer (we'll blit to screen
       * when we get the expose event)
       */
      X24_blit(ifp, 0, 0, xi->xi_iwidth, xi->xi_iheight, BLIT_RESIZE);
      break;
    }
  default:
    break;
  }

  return;
}

void
X24_configureWindow(ifp, width, height)
FBIO *ifp;
int width, height;
{
  struct xinfo *xi = XI(ifp);
  XRectangle rect;

  if(width == xi->xi_xwidth &&
     height == xi->xi_xheight)
    return;

  ifp->if_width = ifp->if_max_width = width;
  ifp->if_height = ifp->if_max_height = height;

  xi->xi_xwidth = xi->xi_iwidth = width;
  xi->xi_xheight = xi->xi_iheight = height;

  ifp->if_xcenter = width/2;
  ifp->if_ycenter = height/2;

  /* redo region */
  if (xi->xi_usereg) {
	  XDestroyRegion(xi->xi_reg);
	  xi->xi_reg = XCreateRegion();
	  rect.x = 0;
	  rect.y = 0;
	  rect.width = xi->xi_xwidth;
	  rect.height = xi->xi_xheight;
	  XUnionRectWithRegion(&rect, xi->xi_reg, xi->xi_reg);
  }

  X24_updstate(ifp);

  switch(xi->xi_flags & FLG_VMASK){
  case FLG_VD24:
  case FLG_VT24:
    /* Destroy old image struct and image buffer */
    XDestroyImage(xi->xi_image);

    /* Make new buffer and new image */
    if ((xi->xi_pix = (unsigned char *)calloc(sizeof(unsigned int),
					      xi->xi_xwidth*xi->xi_xheight)) == NULL) {
      fb_log("X24: pix32 malloc failed in resize!\n");
      return;
    }

    xi->xi_image = XCreateImage(xi->xi_dpy, xi->xi_visual,
				xi->xi_depth, ZPixmap, 0, (char *) xi->xi_pix,
				xi->xi_xwidth, xi->xi_xheight,
				sizeof (unsigned int) * 8, 0);

    break;
  case FLG_VD16:
  case FLG_VT16:
    /* Destroy old image struct and image buffer */
    XDestroyImage(xi->xi_image);

    /* Make new buffer and new image */
    if ((xi->xi_pix = (unsigned char *)calloc( 2, xi->xi_xwidth*xi->xi_xheight)) == NULL) {
      fb_log("X24: pix32 malloc failed in resize!\n");
      return;
    }

    xi->xi_image = XCreateImage(xi->xi_dpy, xi->xi_visual,
				xi->xi_depth, ZPixmap, 0, (char *) xi->xi_pix,
				xi->xi_xwidth, xi->xi_xheight,
				16, 0);

    break;
  case FLG_VP8:
  case FLG_VS8:
  case FLG_VG8:
    /* Destroy old image struct and image buffers */
    XDestroyImage(xi->xi_image);

    /* Make new buffers and new image */
    if ((xi->xi_pix = (unsigned char *)calloc(sizeof(char),
					      xi->xi_xwidth * xi->xi_xheight)) == NULL) {
      fb_log("X24: pix8 malloc failed in resize!\n");
      return;
    }

    xi->xi_image = XCreateImage(xi->xi_dpy, xi->xi_visual,
				xi->xi_depth, ZPixmap, 0, (char *) xi->xi_pix,
				xi->xi_xwidth, xi->xi_xheight, 8, 0);
    break;
  case FLG_VS1:
    /* Destroy old image struct and image buffers */
    XDestroyImage(xi->xi_image);

    /* Make new buffers and new image */
    xi->xi_image = XCreateImage(xi->xi_dpy,
				xi->xi_visual, xi->xi_depth, XYBitmap, 0,
				NULL, xi->xi_xwidth, xi->xi_xheight, 32, 0);

    if ((xi->xi_pix = (unsigned char *)calloc(sizeof(char),
					      xi->xi_image->bytes_per_line * xi->xi_xheight)) == NULL) {
      fb_log("X24: pix1 malloc failed in resize!\n");
      return;
    }

    xi->xi_image->data = (char *) xi->xi_pix;
    xi->xi_image->byte_order = MSBFirst;
    xi->xi_image->bitmap_bit_order = MSBFirst;

    break;
  }

}

/*
 *  A given Display (i.e. Server) can have any number of Screens.
 *  Each Screen can support one or more Visual types.
 *  unix:0.1.2 => host:display.screen.visual
 *  Typically the screen and visual default to 0 by being omitted.
 */
static void
print_display_info(dpy)
Display *dpy;
{
	int	i;
	int	screen;
	Visual	*visual;
	XVisualInfo *vp;
	int	num;
	Window	win = DefaultRootWindow(dpy);
	XStandardColormap cmap;

	printf("Server \"%s\", release %d\n",
		ServerVendor(dpy), VendorRelease(dpy));

	/* How many screens? */
	screen = DefaultScreen(dpy);
	printf("%d Screen(s), we connected to screen %d\n",
		ScreenCount(dpy), screen);

	/* How many visuals? */
	vp = XGetVisualInfo(dpy, VisualNoMask, NULL, &num);
	printf("%d Visual(s)\n", num);

	printf("ImageByteOrder: %s\n",
		ImageByteOrder(dpy) == MSBFirst ? "MSBFirst" : "LSBFirst");
	printf("BitmapBitOrder: %s\n",
		BitmapBitOrder(dpy) == MSBFirst ? "MSBFirst" : "LSBFirst");
	printf("BitmapUnit: %d\n", BitmapUnit(dpy));
	printf("BitmapPad: %d\n", BitmapPad(dpy));

	printf("==== Screen %d ====\n", screen);
	printf("%d x %d pixels, %d x %d mm, (%.2f x %.2f dpi)\n",
		DisplayWidth(dpy,screen), DisplayHeight(dpy,screen),
		DisplayWidthMM(dpy,screen), DisplayHeightMM(dpy,screen),
		DisplayWidth(dpy,screen)*25.4/DisplayWidthMM(dpy,screen),
		DisplayHeight(dpy,screen)*25.4/DisplayHeightMM(dpy,screen));
	printf("%d DisplayPlanes (other Visuals, if any, may vary)\n",
		DisplayPlanes(dpy,screen));
	printf("%d DisplayCells\n", DisplayCells(dpy,screen));
	printf("BlackPixel = %lu\n", BlackPixel(dpy,screen));
	printf("WhitePixel = %lu\n", WhitePixel(dpy,screen));
	printf("Save Unders: %s\n",
		DoesSaveUnders(ScreenOfDisplay(dpy,screen)) ? "True" : "False");
	i = DoesBackingStore(ScreenOfDisplay(dpy,screen));
	printf("Backing Store: %s\n", i == WhenMapped ? "WhenMapped" :
		(i == Always ? "Always" : "NotUseful"));
	printf("Installed Colormaps: min %d, max %d\n",
		MinCmapsOfScreen(ScreenOfDisplay(dpy,screen)),
		MaxCmapsOfScreen(ScreenOfDisplay(dpy,screen)));
	printf("DefaultColormap: 0x%lx\n", DefaultColormap(dpy,screen));


	for (i = 0; i < num; i++) {

		visual = vp[i].visual;

		printf("---- Visual 0x%lx (%d)----\n", (unsigned long int)visual, i);

		printf("screen: %d\n", vp[i].screen);
		printf("depth : %d\n", vp[i].depth);

		switch(visual->class) {
		case DirectColor:
			printf("DirectColor: Alterable RGB maps, pixel RGB subfield indicies\n");
			printf("RGB Masks: 0x%lx 0x%lx 0x%lx\n", visual->red_mask,
			       visual->green_mask, visual->blue_mask);
			break;
		case TrueColor:
			printf("TrueColor: Fixed RGB maps, pixel RGB subfield indicies\n");
			printf("RGB Masks: 0x%lx 0x%lx 0x%lx\n", visual->red_mask,
			       visual->green_mask, visual->blue_mask);
			break;
		case PseudoColor:
			printf("PseudoColor: Alterable RGB maps, single index\n");
			break;
		case StaticColor:
			printf("StaticColor: Fixed RGB maps, single index\n");
			break;
		case GrayScale:
			printf("GrayScale: Alterable map (R=G=B), single index\n");
			break;
		case StaticGray:
			printf("StaticGray: Fixed map (R=G=B), single index\n");
			break;
			default:
			printf("Unknown visual class %d\n",
			       visual->class);
			break;
		}
		printf("Map Entries: %d\n", visual->map_entries);
		printf("Bits per RGB: %d\n", visual->bits_per_rgb);
	}
	XFree((char *) vp);



	printf("==== Standard Colormaps ====\n");
	if (XGetStandardColormap(dpy, win, &cmap, XA_RGB_BEST_MAP)) {
		printf("XA_RGB_BEST_MAP    - Yes (0x%lx)\n", cmap.colormap);
		printf("R[0..%lu] * %lu + G[0..%lu] * %lu  + B[0..%lu] * %lu + %lu\n",
			cmap.red_max, cmap.red_mult, cmap.green_max, cmap.green_mult,
			cmap.blue_max, cmap.blue_mult, cmap.base_pixel);
	} else
		printf("XA_RGB_BEST_MAP    - No\n");
	if (XGetStandardColormap(dpy, win, &cmap, XA_RGB_DEFAULT_MAP)) {
		printf("XA_RGB_DEFAULT_MAP - Yes (0x%lx)\n", cmap.colormap);
		printf("R[0..%lu] * %lu + G[0..%lu] * %lu  + B[0..%lu] * %lu + %lu\n",
			cmap.red_max, cmap.red_mult, cmap.green_max, cmap.green_mult,
			cmap.blue_max, cmap.blue_mult, cmap.base_pixel);
	} else
		printf("XA_RGB_DEFAULT_MAP - No\n");
	if (XGetStandardColormap(dpy, win, &cmap, XA_RGB_GRAY_MAP)) {
		printf("XA_RGB_GRAY_MAP    - Yes (0x%lx)\n", cmap.colormap);
		printf("R[0..%lu] * %lu + %lu\n",
			cmap.red_max, cmap.red_mult, cmap.base_pixel);
	} else
		printf("XA_RGB_GRAY_MAP    - No\n");
}


/*
 * Allocate backing store for two reaons.  First, if we are running on a
 * truecolor display then the colormaps are not modifiable and colormap
 * ops have to be simulated by manipulating the pixel values.  Second, X
 * does not provide a means to zoom or pan so zooming and panning must
 * also be simulated by manipulating the pixel values.  In order to
 * preserve the semantics of libfb which say that reads will read back
 * the original image, it is necessary to allocate backing store.  This
 * code tries to allocate a System V shared memory segment for backing
 * store.  System V shared memory persists until explicitly killed, so
 * this also means that under X, the previous contents of the frame
 * buffer still exist, and can be accessed again, even though the
 * windows are transient, per-process.
 */
static int
X24_getmem(ifp)
FBIO	*ifp;
{
	struct xinfo *xi = XI(ifp);

	char	*mem = NULL;
	int	pixsize;
	int	size;
	int	new = 0;

	pixsize = ifp->if_max_height * ifp->if_max_width * sizeof(RGBpixel);
	size = pixsize + sizeof (*xi->xi_rgb_cmap);

	/*
	 * get shared mem segment, creating it if it does not exist
	 */
	switch (xi->xi_mode & MODE10_MASK)
	{
	case MODE10_SHARED:
	{
		/* First try to attach to an existing shared memory */

#ifdef HAVE_SYS_MMAN_H
		int fd;

		if ((fd = open(BS_NAME, O_RDWR | O_CREAT, 0666)) < 0)
			fb_log("X24_getmem: can't create fb file, using \
private memory instead, errno %d\n", errno);
		else if (ftruncate(fd, size) < 0)
			fb_log("X24_getmem: can't ftruncate fb file, using \
private memory instead, errno %d\n", errno);
		else if ((mem = mmap(NULL, size, PROT_READ |
			PROT_WRITE, MAP_SHARED, fd, 0)) == (char *) -1)
				fb_log("X24_getmem: can't mmap fb file, \
using private memory instead, errno %d\n", errno);
		else {
			close(fd);
			break;
		}

		/* Change it to local */
		xi->xi_mode = (xi->xi_mode & ~MODE10_MASK) | MODE10_MALLOC;
#endif
#ifdef HAVE_SYS_SHM_H
		if ((xi->xi_shmid = shmget(SHMEM_KEY, size, 0)) < 0) {
			/* No existing one, create a new one */
			xi->xi_shmid = shmget(SHMEM_KEY, size, IPC_CREAT|0666);
			new = 1;
		}

		if (xi->xi_shmid < 0) {
			fb_log("X24_getmem: can't shmget shared memory, using \
private memory instead, errno %d\n", errno);
		}
		else
		{
			/* Open the segment Read/Write */
			if ((mem = (char *)shmat(xi->xi_shmid, 0, 0)) != (char *)-1L)
				break;
			else
				fb_log("X24_getmem: can't shmat shared memory, \
using private memory instead, errno %d\n", errno);
		}

		/* Change it to local */
		xi->xi_mode = (xi->xi_mode & ~MODE10_MASK) | MODE10_MALLOC;
#endif

#ifndef CAN_LINGER
		/* Change it to local */
		xi->xi_mode = (xi->xi_mode & ~MODE10_MASK) | MODE10_MALLOC;
#endif

		/*FALLTHROUGH*/

	}
	case MODE10_MALLOC:

		if ((mem = malloc(size)) == 0) {
			fb_log("if_X24: Unable to allocate %d bytes of backing \
store\n  Run shell command 'limit datasize unlmited' and try again.\n", size);
			return (-1);
		}
		new = 1;
		break;
	}

	xi->xi_rgb_cmap = (ColorMap *) mem;
	xi->xi_mem = (unsigned char *) mem + sizeof (*xi->xi_rgb_cmap);

	/* Clear memory frame buffer to black */
	if (new) {
		memset(mem, 0, size);
	}

	return (new);
}

/*
 *			X 2 4 _ Z A P M E M
 */
static void
X24_zapmem()
{
#ifndef HAVE_SYS_MMAN_H
 	int	shmid;
	int	i;
#endif

#ifdef HAVE_SYS_MMAN_H
	unlink(BS_NAME);
#endif
#ifdef HAVE_SYS_SHM_H
	if ((shmid = shmget(SHMEM_KEY, 0, 0)) < 0) {
		fb_log("X24_zapmem shmget failed, errno=%d\n", errno);
		return;
	}

	i = shmctl(shmid, IPC_RMID, 0);
	if (i < 0) {
		fb_log("X24_zapmem shmctl failed, errno=%d\n", errno);
		return;
	}
#endif
#ifdef CAN_LINGER
	fb_log("if_X24: shared memory released\n");
#endif
	return;
}

static void
X24_updstate(ifp)
FBIO	*ifp;
{
	struct xinfo *xi = XI(ifp);

	int xwp, ywp;		/* Size of X window in image pixels */
	int xrp, yrp;		/* Leftover X pixels */

	int tp_h, bt_h;		/* Height of top/bottom image pixel slots */
	int lf_w, rt_w;		/* Width of left/right image pixel slots */

	int want, avail;	/* Wanted/available image pixels */

#if UPD_DBG
printf("upd: x %dx%d i %dx%d z %d,%d ctr (%d, %d)\n",
	xi->xi_xwidth, xi->xi_xheight,
	xi->xi_iwidth, xi->xi_iheight,
	ifp->if_xzoom, ifp->if_yzoom,
	ifp->if_xcenter, ifp->if_ycenter);
#endif

	/*
	 * Set ?wp to the number of whole zoomed image pixels we could display
	 * in the X window.
	 */
	xwp = xi->xi_xwidth / ifp->if_xzoom;
	ywp = xi->xi_xheight / ifp->if_yzoom;

	/*
	 * Set ?rp to the number of leftover X pixels we have, after displaying
	 * wp whole zoomed image pixels.
	 */
	xrp = xi->xi_xwidth % ifp->if_xzoom;
	yrp = xi->xi_xheight % ifp->if_yzoom;

	/*
	 * Force ?wp to be the same as the window width (mod 2).  This
	 * keeps the image from jumping around when using large zoom factors.
	 */

	if (xwp && (xwp ^ xi->xi_xwidth) & 1) {
		xwp--;
		xrp += ifp->if_xzoom;
	}

	if (ywp && (ywp ^ xi->xi_xheight) & 1) {
		ywp--;
		yrp += ifp->if_yzoom;
	}

	/*
	 * Now we calculate the height/width of the outermost image pixel slots.
	 * If we've got any leftover X pixels, we'll make truncated slots
	 * out of them; if not, the outermost ones end up full size.  We'll
	 * adjust ?wp to be the number of full and truncated slots available.
	 */
	switch (xrp)
	{
	case 0:
		lf_w = ifp->if_xzoom;
		rt_w = ifp->if_xzoom;
		break;
		
	case 1:
		lf_w = 1;
		rt_w = ifp->if_xzoom;
		xwp += 1;
		break;

	default:
		lf_w = xrp / 2;
		rt_w = xrp - lf_w;
		xwp += 2;
		break;
	}

	switch (yrp)
	{
	case 0:
		tp_h = ifp->if_yzoom;
		bt_h = ifp->if_yzoom;
		break;
		
	case 1:
		tp_h = 1;
		bt_h = ifp->if_yzoom;
		ywp += 1;
		break;

	default:
		tp_h = yrp / 2;
		bt_h = yrp - tp_h;
		ywp += 2;
		break;
	}

	/*
	 * We've now divided our X window up into image pixel slots as follows:
	 * - All slots are xzoom by yzoom X pixels in size, except:
	 *     slots in the top row are tp_h X pixels high
	 *     slots in the bottom row are bt_h X pixels high
	 *     slots in the left column are lf_w X pixels wide
	 *     slots in the right column are rt_w X pixels wide
	 * - The window is xwp by ywp slots in size.
	 */

	/*
	 * We can think of xcenter as being "number of pixels we'd like
	 * displayed on the left half of the screen".  We have xwp/2 pixels
	 * available on the left half.  We use this information to calculate
	 * the remaining parameters as noted.
	 */

	want = ifp->if_xcenter;
	avail = xwp/2;
	if (want >= avail)
	{
		/*
		 * Just enough or too many pixels to display.  We'll be
		 * butted up against the left edge, so
		 *  - the leftmost X pixels will have an x coordinate of 0;
		 *  - the leftmost column of image pixels will be as wide as the
		 *    leftmost column of image pixel slots; and
		 *  - the leftmost image pixel displayed will have an x
		 *    coordinate equal to the number of pixels that didn't fit.
		 */

		xi->xi_xlf = 0;
		xi->xi_ilf_w = lf_w;
		xi->xi_ilf = want - avail;
	} else {
		/*
		 * Not enough image pixels to fill the area.  We'll be
		 * offset from the left edge, so
		 *  - the leftmost X pixels will have an x coordinate equal
		 *    to the number of pixels taken up by the unused image
		 *    pixel slots;
		 *  - the leftmost column of image pixels will be as wide as the
		 *    xzoom width; and
		 *  - the leftmost image pixel displayed will have a zero
		 *    x coordinate.
		 */

		xi->xi_xlf = lf_w + (avail - want - 1) * ifp->if_xzoom;
		xi->xi_ilf_w = ifp->if_xzoom;
		xi->xi_ilf = 0;
	}

	/* Calculation for bottom edge. */

	want = ifp->if_ycenter;
	avail = ywp/2;
	if (want >= avail)
	{
		/*
		 * Just enough or too many pixels to display.  We'll be
		 * butted up against the bottom edge, so
		 *  - the bottommost X pixels will have a y coordinate
		 *    equal to the window height minus 1;
		 *  - the bottommost row of image pixels will be as tall as the
		 *    bottommost row of image pixel slots; and
		 *  - the bottommost image pixel displayed will have a y
		 *    coordinate equal to the number of pixels that didn't fit.
		 */

		xi->xi_xbt = xi->xi_xheight - 1;
		xi->xi_ibt_h = bt_h;
		xi->xi_ibt = want - avail;
	} else {
		/*
		 * Not enough image pixels to fill the area.  We'll be
		 * offset from the bottom edge, so
		 *  - the bottommost X pixels will have a y coordinate equal
		 *    to the window height, less the space taken up by the
		 *    unused image pixel slots, minus 1;
		 *  - the bottom row of image pixels will be as tall as the
		 *    yzoom width; and
		 *  - the bottommost image pixel displayed will have a zero
		 *    y coordinate.
		 */

		xi->xi_xbt = xi->xi_xheight - (bt_h + (avail - want - 1) *
			ifp->if_yzoom) - 1;
		xi->xi_ibt_h = ifp->if_yzoom;
		xi->xi_ibt = 0;
	}

	/* Calculation for right edge. */

	want = xi->xi_iwidth - ifp->if_xcenter;
	avail =  xwp - xwp/2;
	if (want >= avail)
	{
		/*
		 * Just enough or too many pixels to display.  We'll be
		 * butted up against the right edge, so
		 *  - the rightmost X pixels will have an x coordinate equal
		 *    to the window width minus 1;
		 *  - the rightmost column of image pixels will be as wide as
		 *    the rightmost column of image pixel slots; and
		 *  - the rightmost image pixel displayed will have an x
		 *    coordinate equal to the center plus the number of pixels
		 *    that fit, minus 1.
		 */

		xi->xi_xrt = xi->xi_xwidth - 1;
		xi->xi_irt_w = rt_w;
		xi->xi_irt = ifp->if_xcenter + avail - 1;
	} else {
		/*
		 * Not enough image pixels to fill the area.  We'll be
		 * offset from the right edge, so
		 *  - the rightmost X pixels will have an x coordinate equal
		 *    to the window width, less the space taken up by the
		 *    unused image pixel slots, minus 1;
		 *  - the rightmost column of image pixels will be as wide as
		 *    the xzoom width; and
		 *  - the rightmost image pixel displayed will have an x
		 *    coordinate equal to the width of the image minus 1.
		 */

		xi->xi_xrt = xi->xi_xwidth - (rt_w + (avail - want - 1) *
			ifp->if_xzoom) - 1;
		xi->xi_irt_w = ifp->if_xzoom;
		xi->xi_irt = xi->xi_iwidth - 1;
	}

	/* Calculation for top edge. */

	want = xi->xi_iheight - ifp->if_ycenter;
	avail = ywp - ywp/2;
	if (want >= avail)
	{
		/*
		 * Just enough or too many pixels to display.  We'll be
		 * butted up against the top edge, so
		 *  - the topmost X pixels will have a y coordinate of 0;
		 *  - the topmost row of image pixels will be as tall as
		 *    the topmost row of image pixel slots; and
		 *  - the topmost image pixel displayed will have a y
		 *    coordinate equal to the center plus the number of pixels
		 *    that fit, minus 1.
		 */

		xi->xi_xtp = 0;
		xi->xi_itp_h = tp_h;
		xi->xi_itp = ifp->if_ycenter + avail - 1;
	} else {
		/*
		 * Not enough image pixels to fill the area.  We'll be
		 * offset from the top edge, so
		 *  - the topmost X pixels will have a y coordinate equal
		 *    to the space taken up by the unused image pixel slots;
		 *  - the topmost row of image pixels will be as tall as
		 *    the yzoom height; and
		 *  - the topmost image pixel displayed will have a y
		 *    coordinate equal to the height of the image minus 1.
		 */

		xi->xi_xtp = tp_h + (avail - want - 1) * ifp->if_yzoom;
		xi->xi_itp_h = ifp->if_yzoom;
		xi->xi_itp = xi->xi_iheight - 1;
	}

#if UPD_DBG
printf("upd: off (%d, %d) 1 (%d, %d) 2 (%d, %d) wd (%d, %d) ht (%d, %d)\n",
	xi->xi_xlf, xi->xi_xtp, xi->xi_ilf, xi->xi_ibt,
	xi->xi_irt, xi->xi_itp, xi->xi_ilf_w, xi->xi_irt_w,
	xi->xi_ibt_h, xi->xi_itp_h);
#endif
}

/*	X 2 4 _ b l i t
 *
 * This routine is called when ever the framebuffer is updated OR when
 * there is an expose event generated by the X server.
 *
 * The X server world is confusing because XDR is NOT done for client
 * or server, thus leaving each client responsable for getting a 
 * X pixel map prepared in the correct lay out.
 *
 * There are something like 18 different visuals and 2 endians that
 * we need to deal with 1-bit, 2-bit, 4-bit and 8-bit monochrome
 * 8-bit CLUT, 8-bit True Color, 8-bit Direct Color
 * 15-bit Pseudo Color, 15-bit True Color, 15-bit Direct color
 * 16-bit Pseudo Color, 16-bit True Color, 16-bit Direct Color
 * 24-bit Pseudo, True and Direct
 * and finally 32-bit Pseudo, True and Direct colors.
 *
 * For the 1-8 bit case we do some dithering and get an image up as best
 * we can.
 * for the >8 bit cases we need to do a bit more.
 *
 * Our input is always in RGB (24 bit) order in memory so there is nothing
 * fancy we need to do there.
 *
 * For output, the X server tells us, in an opaque object that we are
 * not suppose to peek into, where the RGB components go in a BIG endian
 * bit vector and how many bits per component.  Using this information we
 * construct masks and shift counts for each component.  This information
 * is later used to construct a bit vector in a register.  This register
 * is then clocked out as bytes in the correct ordering.
 */

static void
X24_blit(ifp, x1, y1, w, h, flags)
FBIO	*ifp;
int x1, y1, w, h;	/* Rectangle of changed bits (image space coord.) */
int flags;		/* BLIT_xxx flags */
{
	struct xinfo *xi = XI(ifp);

	int x2 = x1 + w - 1;	/* Convert to rectangle corners */
	int y2 = y1 + h - 1;

	int x1wd, x2wd, y1ht, y2ht;
	int x, y;
	int ox, oy;
	int xdel, ydel;
	int xwd, xht;

	/*
	 * Newish code, discover masks and shifts for each of RGB
	 *
	 * The Masks are right justified, we just shift them up 6 bits
	 * in the long to give us some room on the low end.  We'll correct
	 * this out later.
	 */
	unsigned int a_pixel;

	unsigned long test_mask;
	unsigned long a_mask;

	int red_shift, green_shift, blue_shift;
	unsigned int mask_red = xi->xi_image->red_mask << 6;
	unsigned int mask_green = xi->xi_image->green_mask << 6;
	unsigned int mask_blue = xi->xi_image->blue_mask << 6;
	int i;

	/*
	 * Now that we know the mask, we shift a bit left, one bit at a time
	 * until it overlaps the mask.  This tells us how far we have to 
	 * shift our pixel to get it under the bit mask.
	 */
	a_mask = mask_red;
	test_mask = 1;
	for (i=0; i<sizeof(unsigned long)*8;i++) {
		if (test_mask & a_mask) break;
		test_mask = test_mask << 1;
	}
	for (;i<sizeof(unsigned long)*8;i++) {
		if (!(test_mask & a_mask)) break;
		test_mask = test_mask << 1;
	}
	red_shift = i-8;

	a_mask = mask_green;
	test_mask = 1;
	for (i=0; i<sizeof(unsigned long)*8;i++) {
		if (test_mask & a_mask) break;
		test_mask = test_mask << 1;
	}
	for (;i<sizeof(unsigned long)*8;i++) {
		if (!(test_mask & a_mask)) break;
		test_mask = test_mask << 1;
	}
	green_shift = i-8;

	a_mask = mask_blue;
	test_mask = 1;
	for (i=0; i<sizeof(unsigned long)*8;i++) {
		if (test_mask & a_mask) break;
		test_mask = test_mask << 1;
	}
	for (;i<sizeof(unsigned long)*8;i++) {
		if (!(test_mask & a_mask)) break;
		test_mask =test_mask << 1;
	}
	blue_shift = i-8;

#if BLIT_DBG
printf("blit: enter %dx%d at (%d, %d), disp (%d, %d) to (%d, %d)  flags %d\n",
	w, h, x1, y1, xi->xi_ilf, xi->xi_ibt, xi->xi_irt, xi->xi_itp, flags);
#endif

	/*
	 * If the changed rectangle is outside the displayed one, there's
	 * nothing to do
	 */

	if (x1 > xi->xi_irt ||
	    x2 < xi->xi_ilf ||
	    y1 > xi->xi_itp ||
	    y2 < xi->xi_ibt)
		return;

	/*
	 * Clamp to actual displayed portion of image
	 */
	if (x1 < xi->xi_ilf) x1 = xi->xi_ilf;
	if (x2 > xi->xi_irt) x2 = xi->xi_irt;
	if (y1 < xi->xi_ibt) y1 = xi->xi_ibt;
	if (y2 > xi->xi_itp) y2 = xi->xi_itp;

	/*
	 * Figure out sizes of outermost image pixels
	 */
	x1wd = (x1 == xi->xi_ilf) ? xi->xi_ilf_w : ifp->if_xzoom;
	x2wd = (x2 == xi->xi_irt) ? xi->xi_irt_w : ifp->if_xzoom;
	y1ht = (y1 == xi->xi_ibt) ? xi->xi_ibt_h : ifp->if_yzoom;
	y2ht = (y2 == xi->xi_itp) ? xi->xi_itp_h : ifp->if_yzoom;

#if BLIT_DBG
printf("blit: postclip (%d, %d) to (%d, %d) wds (%d, %d) hts (%d, %d)\n",
	x1, y1, x2, y2, x1wd, x2wd, y1ht, y2ht);
#endif

	/* Compute ox: offset from left edge of window to left pixel */

	xdel = x1 - xi->xi_ilf;
	if (xdel)
		ox = x1wd + ((xdel - 1) * ifp->if_xzoom) + xi->xi_xlf;
	else
		ox = xi->xi_xlf;


	/* Compute oy: offset from top edge of window to bottom pixel */

	ydel = y1 - xi->xi_ibt;
	if (ydel)
		oy = xi->xi_xbt - (y1ht + ((ydel - 1) * ifp->if_yzoom));
	else
		oy = xi->xi_xbt;


	/* Figure out size of changed area on screen in X pixels */

	if (x2 == x1)
		xwd = x1wd;
	else
		xwd = x1wd + x2wd + ifp->if_xzoom * (x2 - x1 - 1);

	if (y2 == y1)
		xht = y1ht;
	else
		xht = y1ht + y2ht + ifp->if_yzoom * (y2 - y1 - 1);

#if BLIT_DBG
printf("blit: output to (%d, %d)\n", ox, oy);
printf("blit: xi_flags & FLG_VMASK = 0x%x\n", xi->xi_flags & FLG_VMASK );
#endif

	/*
	 * Set pointers to start of source and destination areas; note that
	 * we're going from lower to higher image coordinates, so irgb
	 * increases, but since images are in quadrant I and X uses quadrant
	 * IV, opix _decreases_.
	 */

	switch (xi->xi_flags & FLG_VMASK)
	{
	case FLG_VD24:
	case FLG_VT24:
	case FLG_VD16:
	case FLG_VT16:
	{
		unsigned char *irgb;
		unsigned char *opix;
		unsigned char *red = xi->xi_redmap;
		unsigned char *grn = xi->xi_grnmap;
		unsigned char *blu = xi->xi_blumap;

		/*
		 * Calculate the beginning of the line where we are going
		 * to be outputing pixels.
		 */
		opix = &(xi->xi_pix[oy * xi->xi_image->bytes_per_line + ox *
			(xi->xi_image->bits_per_pixel/8)]);

#if BLIT_DBG_PIX
		if (opix < xi->xi_pix) {
			bu_log("X24_blit: about to clobber memory 1\n");
			bu_log("\topix - Ox%lx\txi->xi_pix - 0x%lx\n", opix, xi->xi_pix);
			break;
		}
#endif
		/*
		 * Our source of pixels in packed RGB order
		 */
		irgb = &(xi->xi_mem[(y1 * xi->xi_iwidth + x1) * sizeof
			(RGBpixel)]);

		/* General case, zooming in effect */

		for (y = y1; y <= y2; y++) {
			unsigned char *line_irgb;
			unsigned char *p;
			unsigned char *holdit;
			int pyht;

#if BLIT_DBG_PIX
			if (opix < xi->xi_pix) {
				bu_log("X24_blit: about to clobber memory 2\n");
				bu_log("\topix - Ox%lx\txi->xi_pix - 0x%lx\n", opix, xi->xi_pix);
				break;
			}
#endif

			/* Calculate the number of lines needed */
			/*
			 * If we are zoomed, then it is possable that not
			 * all of that zoomed pixel will be showned.  
			 * y1ht is the number of lines allocated for the
			 * bottom most line.  y2ht is the number of lines
			 * for the top most line.  if_yzoom is for everything
			 * else.
			 */
			if (y == y1) {
				pyht = y1ht;
			} else if (y==y2) {
				pyht = y2ht;
			} else {
				pyht = ifp->if_yzoom;
			}

			/* Save pointer to start of line */

			line_irgb = irgb;
			p = (unsigned char *)opix;

			/* For the first line, convert/copy pixels */

			for (x = x1; x <= x2; x++) {
				int pxwd;

				/* Calculate # pixels needed */
				/* See comment above for more info */

				if (x == x1)
					pxwd = x1wd;
				else if (x == x2)
					pxwd = x2wd;
				else
					pxwd = ifp->if_xzoom;

				/*
				 * Construct a pixel with the color components 
				 * in the right places as described by the
				 * X servers red, green and blue masks.
				 */
				if (xi->xi_flags & (FLG_XCMAP | FLG_LINCMAP))  {
					a_pixel  = (line_irgb[RED] << red_shift) & mask_red;
					a_pixel |= (line_irgb[GRN] << green_shift) & mask_green;
					a_pixel |= (line_irgb[BLU] << blue_shift) & mask_blue;
				} else {
					a_pixel  = (red[line_irgb[RED]] << red_shift) & mask_red;
					a_pixel |= (grn[line_irgb[GRN]] << green_shift) & mask_green;
					a_pixel |= (blu[line_irgb[BLU]] << blue_shift) & mask_blue;
				}
				/* take out the safety put in above. */
				a_pixel = a_pixel >> 6;

				/*
				 * Now we clock out that pixel according to
				 * the number of bytes AND the byte ordering
				 *
				 * A slightly faster version would unroll
				 * these loops into a number of different
				 * loops.
				 *
				 * The while loop on the inside causes pixel
				 * replication for when we are zoomed.
				 */
				if( ImageByteOrder(xi->xi_dpy) == MSBFirst )  {
					if (xi->xi_image->bits_per_pixel == 16) {
						while (pxwd--)   {
							*p++ = (a_pixel >> 8) & 0xff;
							*p++ = a_pixel & 0xff;
						}
					} else if (xi->xi_image->bits_per_pixel == 24) {
						while (pxwd--)   {
							*p++ = (a_pixel >> 16) & 0xff;
							*p++ = (a_pixel >> 8) & 0xff;
							*p++ = a_pixel & 0xff;
						}
					} else if (xi->xi_image->bits_per_pixel == 32) {
						while (pxwd--) {
							*p++ = (a_pixel >> 24) & 0xff;
							*p++ = (a_pixel >> 16) & 0xff;
							*p++ = (a_pixel >> 8) & 0xff;
							*p++ = a_pixel & 0xff;
						}
					}

				} else { /* LSB order */
					if (xi->xi_image->bits_per_pixel == 16) {
						while (pxwd--)   {
							*p++ = a_pixel & 0xff;
							*p++ = (a_pixel >> 8) & 0xff;
						}
					} else if (xi->xi_image->bits_per_pixel == 24) {
						while (pxwd--)   {
							*p++ = a_pixel & 0xff;
							*p++ = (a_pixel >> 8) & 0xff;
							*p++ = (a_pixel >> 16) & 0xff;
						}
					} else if (xi->xi_image->bits_per_pixel == 32) {
						while (pxwd--) {
							*p++ = a_pixel & 0xff;
							*p++ = (a_pixel >> 8) & 0xff;
							*p++ = (a_pixel >> 16) & 0xff;
							*p++ = (a_pixel >> 24) & 0xff;
						}
					}

				}
				/*
				 * Move to the next input line.
				 */
				line_irgb += sizeof (RGBpixel);
			}
			/*
			 * Remember where we put all those bytes.
			 */
			holdit = (unsigned char *)opix;

			/*
			 * If we are zoomed, we need to duplicate all
			 * that work from above, or we can just copy
			 * that one line to N others.
			 */
			while (pyht-- > 1) {
				unsigned char *src;

				/*
				 * move to the beginning of the next
				 * line up in the X server.
				 */
				opix -= xi->xi_image->bytes_per_line;
				p = (unsigned char *)opix;

#if BLIT_DBG_PIX
				if (opix < xi->xi_pix) {
					bu_log("X24_blit: about to clobber memory 3\n");
					bu_log("\topix - Ox%lx\txi->xi_pix - 0x%lx\n", opix, xi->xi_pix);
					break;
				}
#endif
				/*
				 * Go to the place where we stored pixels
				 * on the first line output.
				 */
				src = (unsigned char *)holdit;
				/*
				 * and copy that line to where we are now.
				 */
				memcpy(p, src, xi->xi_image->bytes_per_line);
			}
			/*
			 * And again, move to the beginning of the next
			 * line up in the X server.
			 */
			opix -= xi->xi_image->bytes_per_line;

			irgb += xi->xi_iwidth * sizeof(RGBpixel);
		}
		break;
	}

	case FLG_VP8:
	{
		int dmx = ox & 0x7;
		int dmy = (oy & 0x7) << 3;

		unsigned int r, g, b;
		unsigned char *red = xi->xi_redmap;
		unsigned char *grn = xi->xi_grnmap;
		unsigned char *blu = xi->xi_blumap;

		unsigned char *ip = &(xi->xi_mem[(y1 * xi->xi_iwidth + x1) *
			sizeof (RGBpixel)]);
		unsigned char *op = (unsigned char *) &xi->xi_pix[oy *
			xi->xi_xwidth + ox];


		if (ifp->if_xzoom == 1 && ifp->if_yzoom == 1) {
			/* Special case if no zooming */

			int j, k;

			for (j = y2 - y1 + 1; j; j--) {
				unsigned char *lip;
				unsigned char *lop;

				lip = ip;
				lop = op;

				/* For each line, convert/copy pixels */

				if (xi->xi_flags & (FLG_XCMAP | FLG_LINCMAP))
					for (k = x2 - x1 + 1; k; k--) {
						r = lip[RED];
						g = lip[GRN];
						b = lip[BLU];

						*lop++ = xi->xi_base +
							xi->xi_ccredtbl[(r << 6) + dmx + dmy] +
							xi->xi_ccgrntbl[(g << 6) + dmx + dmy] +
							xi->xi_ccblutbl[(b << 6) + dmx + dmy];

						dmx = (dmx + 1) & 0x7;
						lip += sizeof (RGBpixel);
					}
				else
					for (k = x2 - x1 + 1; k; k--) {
						r = red[lip[RED]];
						g = grn[lip[GRN]];
						b = blu[lip[BLU]];

						*lop++ = xi->xi_base +
							xi->xi_ccredtbl[(r << 6) + dmx + dmy] +
							xi->xi_ccgrntbl[(g << 6) + dmx + dmy] +
							xi->xi_ccblutbl[(b << 6) + dmx + dmy];

						dmx = (dmx + 1) & 0x7;
						lip += sizeof (RGBpixel);
					}

				ip += xi->xi_iwidth * sizeof (RGBpixel);
				op -= xi->xi_image->bytes_per_line;
				dmx = ox & 0x7;
				dmy = (dmy + 0x38) & 0x38;
			}
		} else {
			/* General case */

			for (y = y1; y <= y2; y++) {
				int pyht;
				unsigned char *lip;
				unsigned char *lop;

				/* Calculate # lines needed */

				if (y == y1)
					pyht = y1ht;
				else if (y == y2)
					pyht = y2ht;
				else
					pyht = ifp->if_yzoom;

				/* For each line, convert/copy pixels */

				while (pyht--)
				{
					lip = ip;
					lop = op;

					if (xi->xi_flags & (FLG_XCMAP | FLG_LINCMAP))
						for (x = x1; x <= x2; x++) {
							int pxwd;

							/* Calculate # pixels needed */

							if (x == x1)
								pxwd = x1wd;
							else if (x == x2)
								pxwd = x2wd;
							else
								pxwd = ifp->if_xzoom;

							r = lip[RED];
							g = lip[GRN];
							b = lip[BLU];

							while (pxwd--)
							{
								*lop++ = xi->xi_base +
									xi->xi_ccredtbl[(r << 6) + dmx + dmy] +
									xi->xi_ccgrntbl[(g << 6) + dmx + dmy] +
									xi->xi_ccblutbl[(b << 6) + dmx + dmy];

								dmx = (dmx + 1) & 0x7;
							}

							lip += sizeof (RGBpixel);
						}
					else
						for (x = x1; x <= x2; x++) {
							int pxwd;

							/* Calculate # pixels needed */

							if (x == x1)
								pxwd = x1wd;
							else if (x == x2)
								pxwd = x2wd;
							else
								pxwd = ifp->if_xzoom;

							r = red[lip[RED]];
							g = grn[lip[GRN]];
							b = blu[lip[BLU]];

							while (pxwd--)
							{
								*lop++ = xi->xi_base +
									xi->xi_ccredtbl[(r << 6) + dmx + dmy] +
									xi->xi_ccgrntbl[(g << 6) + dmx + dmy] +
									xi->xi_ccblutbl[(b << 6) + dmx + dmy];

								dmx = (dmx + 1) & 0x7;
							}

							lip += sizeof (RGBpixel);
						}

					op -= xi->xi_image->bytes_per_line;
					dmx = ox & 0x7;
					dmy = (dmy + 0x38) & 0x38;
				}
				ip += xi->xi_iwidth * sizeof (RGBpixel);
			}
		}
		break;
	}

	case FLG_VS8:
	case FLG_VG8:
	{
		unsigned int r, g, b;
		unsigned char *red = xi->xi_redmap;
		unsigned char *grn = xi->xi_grnmap;
		unsigned char *blu = xi->xi_blumap;

		unsigned char *ip = &(xi->xi_mem[(y1 * xi->xi_iwidth + x1) *
			sizeof (RGBpixel)]);
		unsigned char *op = (unsigned char *) &xi->xi_pix[oy *
			xi->xi_xwidth + ox];

		if (ifp->if_xzoom == 1 && ifp->if_yzoom == 1) {
			/* Special case if no zooming */

			int j, k;

			for (j = y2 - y1 + 1; j; j--) {
				unsigned char *lip;
				unsigned char *lop;

				lip = ip;
				lop = op;

				/* For each line, convert/copy pixels */

				if (xi->xi_flags & (FLG_XCMAP | FLG_LINCMAP))
					for (k = x2 - x1 + 1; k; k--) {
						r = lip[RED];
						g = lip[GRN];
						b = lip[BLU];

						*lop++ = (rlumtbl[r] +
							glumtbl[g] +
							blumtbl[b] +
							8388608) >> 24;
						lip += sizeof (RGBpixel);
					}
				else
					for (k = x2 - x1 + 1; k; k--) {
						r = red[lip[RED]];
						g = grn[lip[GRN]];
						b = blu[lip[BLU]];

						*lop++ = (rlumtbl[r] +
							glumtbl[g] +
							blumtbl[b] +
							8388608) >> 24;
						lip += sizeof (RGBpixel);
					}

				ip += xi->xi_iwidth * sizeof (RGBpixel);
				op -= xi->xi_xwidth;
			}
		} else {
			/* General case */

			for (y = y1; y <= y2; y++) {
				int pyht;
				int copied;
				unsigned char *lip;
				unsigned char pix, *lop, *prev_line;

				/* Calculate # lines needed */

				if (y == y1)
					pyht = y1ht;
				else if (y == y2)
					pyht = y2ht;
				else
					pyht = ifp->if_yzoom;


				/* Save pointer to start of line */

				lip = ip;
				prev_line = lop = op;

				/* For the first line, convert/copy pixels */

				if (xi->xi_flags & (FLG_XCMAP | FLG_LINCMAP))
					for (x = x1; x <= x2; x++) {
							int pxwd;

						/* Calculate # pixels needed */

						if (x == x1)
							pxwd = x1wd;
						else if (x == x2)
							pxwd = x2wd;
						else
							pxwd = ifp->if_xzoom;

						/* Get/convert pixel */

						r = lip[RED];
						g = lip[GRN];
						b = lip[BLU];

						pix = (rlumtbl[r] +
							glumtbl[g] +
							blumtbl[b] +
							8388608) >> 24;

						lip += sizeof (RGBpixel);

						/* Make as many copies as needed */

						while (pxwd--)
							*lop++ = pix;
					}
				else
					for (x = x1; x <= x2; x++) {
						int pxwd;

						/* Calculate # pixels needed */

						if (x == x1)
							pxwd = x1wd;
						else if (x == x2)
							pxwd = x2wd;
						else
							pxwd = ifp->if_xzoom;

						/* Get/convert pixel */

						r = red[lip[RED]];
						g = grn[lip[GRN]];
						b = blu[lip[BLU]];

						pix = (rlumtbl[r] +
							glumtbl[g] +
							blumtbl[b] +
							8388608) >> 24;

						lip += sizeof (RGBpixel);

						/* Make as many copies as needed */

						while (pxwd--)
							*lop++ = pix;
					}

				copied = lop - op;

				ip += xi->xi_iwidth * sizeof (RGBpixel);
				op -= xi->xi_xwidth;

				/* Copy remaining output lines from 1st output line */

				pyht--;
				while (pyht--) {
					memcpy(op, prev_line, copied);
					op -= xi->xi_xwidth;
				}
			}
		}
		break;
	}

	case FLG_VS1:
	{
		int dmx = ox & 0x7;
		int dmy = (oy & 0x7) << 3;

		unsigned int r, g, b;
		unsigned char *red = xi->xi_redmap;
		unsigned char *grn = xi->xi_grnmap;
		unsigned char *blu = xi->xi_blumap;

		unsigned char *ip = &(xi->xi_mem[(y1 * xi->xi_iwidth + x1) *
			sizeof (RGBpixel)]);
		unsigned char *op = (unsigned char *) &xi->xi_pix[oy *
			xi->xi_image->bytes_per_line + ox / 8];


		if (ifp->if_xzoom == 1 && ifp->if_yzoom == 1) {
			/* Special case if no zooming */

			int j, k;

			for (j = y2 - y1 + 1; j; j--) {
				unsigned char *lip;
				unsigned char *lop;
				unsigned char loppix;
				unsigned int lum;

				lip = ip;
				lop = op;
				loppix = *lop;

				/* For each line, convert/copy pixels */

				if (xi->xi_flags & (FLG_XCMAP | FLG_LINCMAP))
					for (k = x2 - x1 + 1; k; k--) {
						r = lip[RED];
						g = lip[GRN];
						b = lip[BLU];

						lum = (rlumtbl[r] +
							glumtbl[g] +
							blumtbl[b] +
							8388608) >> 24;

						loppix = (loppix &
							xi->xi_andtbl[(lum << 6)
								+ dmx + dmy]) |
							xi->xi_ortbl[(lum << 6)
								+ dmx + dmy];

						dmx = (dmx + 1) & 0x7;
						if (!dmx) {
							*lop = loppix;
							lop++;
						}

						lip += sizeof (RGBpixel);
					}
				else
					for (k = x2 - x1 + 1; k; k--) {
						r = lip[RED];
						g = lip[GRN];
						b = lip[BLU];

						lum = (rlumtbl[red[r]] +
							glumtbl[grn[g]] +
							blumtbl[blu[b]] +
							8388608) >> 24;

						loppix = (loppix &
							xi->xi_andtbl[(lum << 6)
								+ dmx + dmy]) |
							xi->xi_ortbl[(lum << 6)
								+ dmx + dmy];

						dmx = (dmx + 1) & 0x7;
						if (!dmx) {
							*lop = loppix;
							lop++;
						}

						lip += sizeof (RGBpixel);
					}

				if (dmx)
					*lop = loppix;
				ip += xi->xi_iwidth * sizeof (RGBpixel);
				op -= xi->xi_image->bytes_per_line;
				dmx = ox & 0x7;
				dmy = (dmy + 0x38) & 0x38;
			}
		} else {
			/* General case */

			for (y = y1; y <= y2; y++) {
				int pyht;
				unsigned char *lip;
				unsigned char *lop;
				unsigned char loppix;
				unsigned int lum;

				/* Calculate # lines needed */

				if (y == y1)
					pyht = y1ht;
				else if (y == y2)
					pyht = y2ht;
				else
					pyht = ifp->if_yzoom;

				/* For each line, convert/copy pixels */

				while (pyht--)
				{
					lip = ip;
					lop = op;
					loppix = *lop;

					if (xi->xi_flags & (FLG_XCMAP | FLG_LINCMAP))
						for (x = x1; x <= x2; x++) {
							int pxwd;

							/* Calculate # pixels needed */

							if (x == x1)
								pxwd = x1wd;
							else if (x == x2)
								pxwd = x2wd;
							else
								pxwd = ifp->if_xzoom;

							r = lip[RED];
							g = lip[GRN];
							b = lip[BLU];

							lum = (rlumtbl[r] +
								glumtbl[g] +
								blumtbl[b] +
								8388608) >> 24;

							while (pxwd--)
							{
								loppix = (loppix &
								xi->xi_andtbl[(lum << 6)
									+ dmx + dmy]) |
								xi->xi_ortbl[(lum << 6)
									+ dmx + dmy];

								dmx = (dmx + 1) & 0x7;
								if (!dmx) {
									*lop = loppix;
									lop++;
								}
							}

							lip += sizeof (RGBpixel);
						}
					else
						for (x = x1; x <= x2; x++) {
							int pxwd;

							/* Calculate # pixels needed */

							if (x == x1)
								pxwd = x1wd;
							else if (x == x2)
								pxwd = x2wd;
							else
								pxwd = ifp->if_xzoom;

							r = lip[RED];
							g = lip[GRN];
							b = lip[BLU];

							lum = (rlumtbl[red[r]] +
								glumtbl[grn[g]] +
								blumtbl[blu[b]] +
								8388608) >> 24;

							while (pxwd--)
							{
								loppix = (loppix &
								xi->xi_andtbl[(lum << 6)
									+ dmx + dmy]) |
								xi->xi_ortbl[(lum << 6)
									+ dmx + dmy];

								dmx = (dmx + 1) & 0x7;
								if (!dmx) {
									*lop = loppix;
									lop++;
								}
							}

							lip += sizeof (RGBpixel);
						}

					if (dmx)
						*lop = loppix;
					op -= xi->xi_image->bytes_per_line;
					dmx = ox & 0x7;
					dmy = (dmy + 0x38) & 0x38;
				}
				ip += xi->xi_iwidth * sizeof (RGBpixel);
			}
		}
		break;
	}
	}

	/* Blit out changed image */

	if (flags & BLIT_DISP) {
		XPutImage(xi->xi_dpy, xi->xi_win, xi->xi_gc, xi->xi_image,
			ox, oy - xht + 1, ox, oy - xht + 1, xwd, xht);
#if BLIT_DBG
printf("blit: PutImage of %dx%d to (%d, %d)\n", xwd, xht, ox, oy - xht + 1);
#endif
	}

	/* If we changed the valid region, make a new one. */

	if (xi->xi_usereg && (flags & (BLIT_PZ | BLIT_RESIZE)))
	{
		XRectangle rect;
		Region Nreg = XCreateRegion();

		rect.x = ox;
		rect.y = oy - xht + 1;
		rect.width = xwd;
		rect.height = xht;
		XUnionRectWithRegion(&rect, Nreg, Nreg);

		if (flags & BLIT_PZ) {
			/* If we're panning/zooming, clear out old image. */

			Region Creg = XCreateRegion();

			XSubtractRegion(xi->xi_reg, Nreg, Creg);

			if (!XEmptyRegion(Creg))
			{
				XSetRegion(xi->xi_dpy, xi->xi_cgc, Creg);

				XFillRectangle(xi->xi_dpy, xi->xi_win,
					xi->xi_cgc, 0, 0, xi->xi_xwidth,
					xi->xi_xheight);
			}
			XDestroyRegion(Creg);

		}
		XDestroyRegion(xi->xi_reg);
		xi->xi_reg = Nreg;
	}

	if (flags & BLIT_DISP)
		XFlush(xi->xi_dpy);
}

int
X24_refresh(ifp, x, y, w, h)
FBIO *ifp;
int x, y, w, h;
{
  if(w < 0){
    w = -w;
    x -= w;
  }

  if(h < 0){
    h = -h;
    y -= h;
  }

  X24_blit(ifp, x, y, w, h, BLIT_DISP);

  return 0;
}
@


11.45
log
@change conf.h to a wrapped config.h
@
text
@d58 1
a58 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/libfb/if_X24.c,v 11.44 2004/05/10 15:25:27 morrison Exp $ (ARL)";
@


11.44
log
@Bob Parker's view modifications, png framebuffer support, shaded drawing mode
@
text
@d58 1
a58 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_X24.c,v 11.43 2003/06/25 20:11:34 justin Exp $ (ARL)";
d61 5
a65 1
#include "conf.h"
@


11.43
log
@missing an include for errno.h so that compilation will work on redhat 9.0.
@
text
@d58 1
a58 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_X24.c,v 11.42 2003/04/18 21:18:21 jra Exp $ (ARL)";
d65 1
@


11.42
log
@Needed to include <errno.h>
@
text
@d58 1
a58 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_X24.c,v 11.41 2002/08/20 17:07:46 jra Exp $ (ARL)";
d63 1
@


11.41
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d58 1
a58 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_X24.c,v 11.39 2002/08/09 13:32:47 jra Exp $ (ARL)";
d76 2
@


11.41.2.1
log
@sync branch with HEAD
@
text
@d58 1
a58 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
a62 1
#include <errno.h>
a75 2

#include <errno.h>
@


11.41.4.1
log
@sync to HEAD...
@
text
@d58 1
a58 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/libfb/if_X24.c,v 11.43 2003/06/25 20:11:34 justin Exp $ (ARL)";
a62 1
#include <errno.h>
a75 2

#include <errno.h>
@


11.40
log
@Converted from K&R to ANSI C - RFH
@
text
@d58 1
a58 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_X24.c,v 11.38 2001/10/12 21:34:29 bparker Exp $ (ARL)";
d3238 1
a3238 3
				for (x=xi->xi_image->bytes_per_line;x>=0;x--) {
					*p++ = *src++;
				}
@


11.39
log
@Committing Sean's Mac fix for X24_blit() (pixel-per-pixel copy changed to memcpy)
@
text
@d3238 3
a3240 1
				memcpy(p, src, xi->xi_image->bytes_per_line);
@


11.38
log
@*- mods so that MGED's framebuffer will work
   properly with fbgamma.
@
text
@d58 1
a58 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_X24.c,v 11.37 2001/04/20 22:29:14 morrison Exp $ (ARL)";
d3238 1
a3238 3
				for (x=xi->xi_image->bytes_per_line;x>=0;x--) {
					*p++ = *src++;
				}
@


11.37
log
@CONST to const
@
text
@d58 1
a58 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_X24.c,v 11.36 2001/02/26 19:09:49 bparker Exp $ (ARL)";
d612 1
d647 1
d652 1
a652 1
      xi->xi_flags = FLG_VT24 | FLG_XCMAP;
d657 1
a657 1
      xi->xi_flags = FLG_VT16 | FLG_XCMAP;
d662 1
a662 1
      xi->xi_flags = FLG_VS1 | FLG_XCMAP;
d715 11
d730 3
a732 3
  if ((X24_getmem(ifp)) == -1) {
    free((char *)xi);
    return -1;
d765 8
@


11.36
log
@*- mods to _X24_open_existing() to take an extra
   parameter (i.e. cwinp - cursor window's parent) to
   be used when creating a cursor window. This fixes a
   bug when using fbpoint with one of MGED's geometry/fbserv
   windows.
@
text
@d58 1
a58 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_X24.c,v 11.35 2001/01/25 17:54:48 bparker Exp $ (ARL)";
d927 1
a927 1
CONST unsigned char	*pixelp;
d990 1
a990 1
CONST ColorMap	*cmp;
d1148 1
a1148 1
CONST unsigned char *bits;
d1298 1
a1298 1
CONST unsigned char	*pp;
@


11.35
log
@*- add xi_usereg member to "struct xinfo" and use it to determine
   whether or not X11 Region's will be used. This fixes a bug that
   shows up in MGED when an image whose size does not evenly divide
   into the window size is raytraced into the display manager window
@
text
@d58 1
a58 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_X24.c,v 11.34 2000/08/18 02:38:56 mike Exp $ (ARL)";
d213 2
a214 1
	Window		xi_curswin;	/* Cursor Window ID */
d559 1
d566 1
a566 1
  if(argc != 8)
d575 1
a575 1
  if(sscanf(argv[3], "%lu", (unsigned long *)&cmap) != 1)
d578 1
a578 1
  if(sscanf(argv[4], "%lu", (unsigned long *)&vip) != 1)
d581 1
a581 1
  if(sscanf(argv[5], "%d", &width) != 1)
d584 1
a584 1
  if(sscanf(argv[6], "%d", &height) != 1)
d587 1
a587 1
  if(sscanf(argv[7], "%lu", (unsigned long *)&gc) != 1)
d590 4
a593 1
  return _X24_open_existing(ifp, dpy, win, cmap, vip, width, height, gc);
d597 1
a597 1
_X24_open_existing(ifp, dpy, win, cmap, vip, width, height, gc)
d601 1
d640 1
d1179 1
a1179 1
    if (!xi->xi_curswin) {
d1187 1
a1187 1
      xi->xi_curswin = XCreateWindow(xi->xi_dpy, xi->xi_win,
d1205 1
a1205 1
    XMoveWindow(xi->xi_dpy, xi->xi_curswin, xx - 4, xy - 4);
d1208 1
a1208 1
      XMapRaised(xi->xi_dpy, xi->xi_curswin);
d1211 2
a1212 2
    if (xi->xi_curswin && ifp->if_cursmode)
      XUnmapWindow(xi->xi_dpy, xi->xi_curswin);
d1870 1
a3775 1

@


11.34
log
@
Added reasonable default for DISPLAY.
Particularly useful for fbserv when run from inetd as a daemon.
@
text
@d58 1
a58 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_X24.c,v 11.33 2000/07/25 17:49:50 butler Exp $ (ARL)";
d210 1
d603 1
d605 1
d715 1
d723 5
d1915 1
a1915 1

d2191 9
a2199 7
  XDestroyRegion(xi->xi_reg);
  xi->xi_reg = XCreateRegion();
  rect.x = 0;
  rect.y = 0;
  rect.width = xi->xi_xwidth;
  rect.height = xi->xi_xheight;
  XUnionRectWithRegion(&rect, xi->xi_reg, xi->xi_reg);
d3764 1
a3764 1
	if (flags & (BLIT_PZ | BLIT_RESIZE))
@


11.33
log
@Added include of unistd.h to get warning-free compile
@
text
@d58 1
a58 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_X24.c,v 11.32 2000/07/12 01:33:30 cjohnson Exp $ (ARL)";
d1560 1
d1572 6
a1577 3
	if ((xi->xi_dpy = XOpenDisplay(NULL)) == NULL) {
		fb_log("if_X: Can't open X display \"%s\"\n",
			XDisplayName(NULL));
@


11.32
log
@LINT from gcc -Wall.  Including some mods to h/pkg.h
@
text
@d58 1
a58 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_X24.c,v 11.31 2000/05/10 02:14:50 cjohnson Exp $ (ARL)";
d64 1
@


11.31
log
@Add the comments I promised Bob I'd put in.
@
text
@d57 2
a58 2
static char sccsid[] = "@@(#)if_X24.c version 1.40 (22 Nov 1994)";
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_X24.c,v 11.30 2000/05/10 01:36:32 cjohnson Exp $ (ARL)";
d70 5
d1547 1
d2327 1
a2327 1
		printf("---- Visual 0x%lx (%d)----\n", visual, i);
@


11.31.2.1
log
@Updated to latest revision
@
text
@d57 2
a58 2
static const char sccsid[] = "@@(#)if_X24.c version 1.40 (22 Nov 1994)";
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_X24.c,v 11.34 2000/08/18 02:38:56 mike Exp $ (ARL)";
a63 1
#include <unistd.h>
a69 5
#ifdef HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
a1541 1
int
a1552 1
	char		*xname;
d1564 3
a1566 6
	xname = XDisplayName(NULL);
	/* Attempt one level of fallback, esp. for fbserv daemon */
	if( !xname || *xname == '\0' )  xname = ":0";

	if ((xi->xi_dpy = XOpenDisplay(xname)) == NULL) {
		fb_log("if_X: Can't open X display \"%s\"\n", xname);
d2321 1
a2321 1
		printf("---- Visual 0x%lx (%d)----\n", (unsigned long int)visual, i);
@


11.31.2.2
log
@*- add xi_usereg member to "struct xinfo" and use it to determine
   whether or not X11 Region's will be used. This fixes a bug that
   shows up in MGED when an image whose size does not evenly divide
   into the window size is raytraced into the display manager window
@
text
@d58 1
a58 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_X24.c,v 11.31.2.1 2000/08/18 13:51:14 jra Exp $ (ARL)";
a209 1
	int		xi_usereg;	/* Flag determining whether or not to use regions */
a601 1
#if 0
a602 1
#endif
a711 1
#if 0
a718 5
#else
  /* We're not using Region's */
  xi->xi_reg = (Region)0;
  xi->xi_usereg = 0;
#endif
d1906 1
a1906 1
	xi->xi_usereg = 1;
d2182 7
a2188 9
  if (xi->xi_usereg) {
	  XDestroyRegion(xi->xi_reg);
	  xi->xi_reg = XCreateRegion();
	  rect.x = 0;
	  rect.y = 0;
	  rect.width = xi->xi_xwidth;
	  rect.height = xi->xi_xheight;
	  XUnionRectWithRegion(&rect, xi->xi_reg, xi->xi_reg);
  }
d3753 1
a3753 1
	if (xi->xi_usereg && (flags & (BLIT_PZ | BLIT_RESIZE)))
d3757 1
@


11.31.2.3
log
@*- mods to _X24_open_existing() to take an extra
   parameter (i.e. cwinp - cursor window's parent) to
   be used when creating a cursor window.
   This fixes a bug when using fbpoint with one of MGED's
   geometry/fbserv windows
@
text
@d58 1
a58 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_X24.c,v 11.31.2.2 2001/01/25 17:48:04 bparker Exp $ (ARL)";
d213 1
a213 2
	Window		xi_cwinp;	/* Cursor's Parent Window ID */
	Window		xi_cwin;	/* Cursor Window ID */
a557 1
  Window cwinp;
d564 1
a564 1
  if(argc != 9)
d573 1
a573 1
  if(sscanf(argv[3], "%lu", (unsigned long *)&cwinp) != 1)
d576 1
a576 1
  if(sscanf(argv[4], "%lu", (unsigned long *)&cmap) != 1)
d579 1
a579 1
  if(sscanf(argv[5], "%lu", (unsigned long *)&vip) != 1)
d582 1
a582 1
  if(sscanf(argv[6], "%d", &width) != 1)
d585 1
a585 1
  if(sscanf(argv[7], "%d", &height) != 1)
d588 1
a588 4
  if(sscanf(argv[8], "%lu", (unsigned long *)&gc) != 1)
    return -1;

  return _X24_open_existing(ifp, dpy, win, cwinp, cmap, vip, width, height, gc);
d592 1
a592 1
_X24_open_existing(ifp, dpy, win, cwinp, cmap, vip, width, height, gc)
a595 1
Window cwinp;
a633 1
  xi->xi_cwinp = cwinp;
d1172 1
a1172 1
    if (!xi->xi_cwin) {
d1180 1
a1180 1
      xi->xi_cwin = XCreateWindow(xi->xi_dpy, xi->xi_cwinp,
d1198 1
a1198 1
    XMoveWindow(xi->xi_dpy, xi->xi_cwin, xx - 4, xy - 4);
d1201 1
a1201 1
      XMapRaised(xi->xi_dpy, xi->xi_cwin);
d1204 2
a1205 2
    if (xi->xi_cwin && ifp->if_cursmode)
      XUnmapWindow(xi->xi_dpy, xi->xi_cwin);
a1862 1
	xi->xi_cwinp = xi->xi_win;
@


11.30
log
@An off by one error that Bob Parker discovered.  One of three paths was
bad.
@
text
@d58 1
a58 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_X24.c,v 11.29 2000/05/05 21:45:38 bparker Exp $ (ARL)";
d2803 32
d2854 4
d2870 5
d3003 4
d3017 3
a3019 1

d3040 8
d3064 1
a3064 1
					int pxwd;
d3067 1
d3076 5
a3080 1
				/* Make as many copies as needed */
d3090 1
d3093 11
d3147 3
d3156 6
d3165 4
d3179 4
a3182 1

d3184 3
d3191 4
@


11.29
log
@*- temporary code that identifies a problem
   in X24_blit
@
text
@d58 1
a58 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_X24.c,v 11.28 2000/03/02 02:37:18 cjohnson Exp $ (ARL)";
d2939 1
a2939 1
printf("blit: xi_flags & FLG_VMASK = x%x\n", xi->xi_flags & FLG_VMASK );
d2998 1
a2998 1
				pyht = ifp->if_yzoom-1;
d3081 1
a3081 2
			opix -= xi->xi_image->bytes_per_line;
			while (pyht--) {
d3083 2
a3098 1
				opix -= xi->xi_image->bytes_per_line;
d3100 1
@


11.28
log
@It helps if you put ALL the lines of code in there.  Duh.  I left out
the row duplication code.
@
text
@d47 1
d58 1
a58 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_X24.c,v 11.27 1999/12/29 20:36:00 jra Exp $ (ARL)";
d2965 8
d2984 8
d3085 9
@


11.27
log
@Eliminated some unused variables
@
text
@d57 1
a57 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_X24.c,v 11.26 1999/12/17 16:32:21 bparker Exp $ (ARL)";
d2972 11
d3060 15
a3075 1
			opix -= xi->xi_image->bytes_per_line;
@


11.26
log
@*- the XXX_open_existing routines are no longer hidden
@
text
@d57 1
a57 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_X24.c,v 11.25 1999/11/02 14:16:16 bparker Exp $ (ARL)";
a594 1
  int getmem_stat;
d700 1
a700 1
  if ((getmem_stat = X24_getmem(ifp)) == -1) {
a1552 2
	XVisualInfo	visinfo;	/* Visual we'll use */

a2969 2
			int pyht;
			int copied;
a2970 1
			unsigned char *prev_line;
a2972 10
			/* Calculate # lines needed */

			if (y == y1)
				pyht = y1ht;
			else if (y == y2)
				pyht = y2ht;
			else
				pyht = ifp->if_yzoom;


a2975 1
			prev_line = opix;
a3048 1
			copied = p - (unsigned char *)opix;	/* bytes */
@


11.25
log
@*- mods to _X24_open_existing to
   better initialize things
@
text
@d57 1
a57 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_X24.c,v 11.24 1999/07/08 04:25:08 cjohnson Exp $ (ARL)";
d109 1
a109 1
static int _X24_open_existing();
d583 1
a583 1
static int
@


11.24
log
@Bad things happen when you shift << with a negative number.  Use the
assumption that there are at least 8 bits of pad at the top of the integer
so we never shift negative.
@
text
@d57 1
a57 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_X24.c,v 11.23 1999/07/08 04:03:02 cjohnson Exp $ (ARL)";
d139 2
d614 16
d635 2
d640 2
d645 2
d654 2
d659 2
d664 2
d673 7
d683 2
d691 2
a705 18
  /* X setup */
  xi->xi_xwidth = width;
  xi->xi_xheight = height;
  xi->xi_dpy = dpy;
  xi->xi_screen = DefaultScreen(xi->xi_dpy);

  xi->xi_visinfo = *vip;		/* struct copy */
  xi->xi_visual = vip->visual;
  xi->xi_depth = vip->depth;
  xi->xi_cmap = cmap;
  xi->xi_wp = 0xFFFFFF;
  xi->xi_bp = 0x000000;
  xi->xi_win = win;

  /*XXX For now use same GC for both */
  xi->xi_gc = gc;
  xi->xi_cgc = gc;

d771 7
d1442 98
a1700 5
		unsigned long pixels[256], pmask[1], pixel[1];
		int	i, j, idx;
		int	redmul, grnmul;
		XColor	colors[256];

a1703 3
		/*
		 * Colorcube is in RGB order
		 */
a1705 21
		grnmul = sizeof (blus);
		redmul = sizeof (blus) * sizeof (grns);


		XAllocColorCells(xi->xi_dpy, xi->xi_cmap, 1, pmask, 0, pixels,
			xi->xi_base + xi->xi_ncolors);

		for (pixel[0] = 0; pixel[0] < xi->xi_base; pixel[0]++) {
			XFreeColors(xi->xi_dpy, xi->xi_cmap, pixel, 1, 0);
		}

		/* Fill the colormap and the colorcube */

		for (i = 0; i < xi->xi_ncolors; i++) {

			colors[i].red = reds[i / redmul] << 8;
			colors[i].green = grns[(i % redmul) / grnmul] << 8;
			colors[i].blue = blus[i % grnmul] << 8;
			colors[i].flags = DoRed | DoGreen | DoBlue;
			colors[i].pixel = xi->xi_base + i;
		}
d1707 2
a1708 1
		XStoreColors(xi->xi_dpy, xi->xi_cmap, colors, xi->xi_ncolors);
d1711 1
a1711 49

		xi->xi_ccredtbl = (unsigned char *)malloc(64 * 256);
		xi->xi_ccgrntbl = (unsigned char *)malloc(64 * 256);
		xi->xi_ccblutbl = (unsigned char *)malloc(64 * 256);

		for (i = 0; i < 256; i++)
		{
			int redval, grnval, bluval;
			int redtbl, grntbl, blutbl;
			int reditbl, grnitbl, bluitbl;

			idx = i / (256 / (sizeof (reds) - 1));
			reditbl = redtbl = idx * redmul;
			if (idx < (sizeof (reds) - 1))
				reditbl += redmul;
			redval = reds[idx];
			
			idx = i / (256 / (sizeof (grns) - 1));
			grnitbl = grntbl = idx * grnmul;
			if (idx < (sizeof (grns) - 1))
				grnitbl += grnmul;
			grnval = grns[idx];
			
			idx = i / (256 / (sizeof (blus) - 1));
			bluitbl = blutbl = idx;
			if (idx < (sizeof (blus) - 1))
				bluitbl++;
			bluval = blus[idx];
			
			for (j = 0; j < 64; j++) {
				if (i - redval > (256 / (sizeof (reds) - 1)) *
				    dmsk883[128+j])
					xi->xi_ccredtbl[(i << 6) + j] = reditbl;
				else
					xi->xi_ccredtbl[(i << 6) + j] = redtbl;

				if (i - grnval > (256 / (sizeof (grns) - 1)) *
				    dmsk883[64+j])
					xi->xi_ccgrntbl[(i << 6) + j] = grnitbl;
				else
					xi->xi_ccgrntbl[(i << 6) + j] = grntbl;

				if (i - bluval > (256 / (sizeof (blus) - 1)) *
				    dmsk883[j])
					xi->xi_ccblutbl[(i << 6) + j] = bluitbl;
				else
					xi->xi_ccblutbl[(i << 6) + j] = blutbl;
			}
		}
a1713 1

@


11.23
log
@The great slow down of x24_blit().  The code was made more robust at the
expense of speed.
@
text
@d57 1
a57 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_X24.c,v 11.22 1999/06/03 18:24:51 jra Exp $ (ARL)";
d2780 3
d2785 1
a2785 1
	a_mask = xi->xi_visual->red_mask;
d2797 1
a2797 1
	a_mask = xi->xi_visual->green_mask;
d2809 1
a2809 1
	a_mask = xi->xi_visual->blue_mask;
d2960 3
a2962 3
					a_pixel  = (line_irgb[RED] << red_shift) & xi->xi_visual->red_mask;
					a_pixel |= (line_irgb[GRN] << green_shift) & xi->xi_visual->green_mask;
					a_pixel |= (line_irgb[BLU] << blue_shift) & xi->xi_visual->blue_mask;
d2964 3
a2966 3
					a_pixel  = (red[line_irgb[RED]] << red_shift) & xi->xi_visual->red_mask;
					a_pixel |= (grn[line_irgb[GRN]] << green_shift) & xi->xi_visual->green_mask;
					a_pixel |= (blu[line_irgb[BLU]] << blue_shift) & xi->xi_visual->blue_mask;
d2968 1
@


11.22
log
@Needed an "include <ctype.h>"
@
text
@d57 1
a57 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_X24.c,v 11.21 1999/04/26 19:10:47 bparker Exp $ (ARL)";
d2771 47
d2901 2
d2905 4
a2908 1
		unsigned int *opix;
d2910 2
a2911 2
		opix = (unsigned int *)&(xi->xi_pix[(oy * xi->xi_xwidth +
			ox) * sizeof(unsigned int)]);
d2916 1
a2916 2
		if (ifp->if_xzoom == 1 && ifp->if_yzoom == 1) {
			/* Special case if no zooming */
d2918 15
a2932 1
			int j, k;
a2933 3
			for (j = y2 - y1 + 1; j; j--) {
				unsigned char *line_irgb;
				unsigned char *p;
d2935 1
a2935 2
				line_irgb = irgb;
				p = (unsigned char *)opix;
d2937 3
a2939 1
				/* For each line, convert/copy pixels */
d2941 1
a2941 94
				if (xi->xi_flags & (FLG_XCMAP | FLG_LINCMAP))  {
					if( ImageByteOrder(xi->xi_dpy) == MSBFirst )  {
						if( xi->xi_visual->red_mask & 0xFF)  {
							DEBUG1("FB1a\n")
							for (k = x2 - x1 + 1; k; k--) {
								*p++ = 0;
								*p++ = line_irgb[BLU];
								*p++ = line_irgb[GRN];
								*p++ = line_irgb[RED];
								line_irgb += sizeof (RGBpixel);
							}
						} else {
							DEBUG1("FB1b\n")
							for (k = x2 - x1 + 1; k; k--) {
								*p++ = 0;
								*p++ = line_irgb[RED];
								*p++ = line_irgb[GRN];
								*p++ = line_irgb[BLU];
								line_irgb += sizeof (RGBpixel);
							}
						}
					} else {
						if( xi->xi_visual->red_mask & 0xFF)  {
							DEBUG1("FB1c\n")
							for (k = x2 - x1 + 1; k; k--) {
								*p++ = line_irgb[RED];
								*p++ = line_irgb[GRN];
								*p++ = line_irgb[BLU];
								*p++ = 0;
								line_irgb += sizeof (RGBpixel);
							}
						} else {
							DEBUG1("FB1d\n")
							for (k = x2 - x1 + 1; k; k--) {
								*p++ = line_irgb[BLU];
								*p++ = line_irgb[GRN];
								*p++ = line_irgb[RED];
								*p++ = 0;
								line_irgb += sizeof (RGBpixel);
							}
						}
					}
				} else {
					unsigned char *red = xi->xi_redmap;
					unsigned char *grn = xi->xi_grnmap;
					unsigned char *blu = xi->xi_blumap;

					if( ImageByteOrder(xi->xi_dpy) == MSBFirst )  {
						if( xi->xi_visual->red_mask & 0xFF)  {
							DEBUG1("FB2a\n")
							for (k = x2 - x1 + 1; k; k--) {
								*p++ = 0;
								*p++ = blu[line_irgb[BLU]];
								*p++ = grn[line_irgb[GRN]];
								*p++ = red[line_irgb[RED]];
								line_irgb += sizeof (RGBpixel);
							}
						} else {
							DEBUG1("FB2b\n")
							for (k = x2 - x1 + 1; k; k--) {
								*p++ = 0;
								*p++ = red[line_irgb[RED]];
								*p++ = grn[line_irgb[GRN]];
								*p++ = blu[line_irgb[BLU]];
								line_irgb += sizeof (RGBpixel);
							}
						}
					} else {
						if( xi->xi_visual->red_mask & 0xFF)  {
							DEBUG1("FB2c\n")
							for (k = x2 - x1 + 1; k; k--) {
								*p++ = red[line_irgb[RED]];
								*p++ = grn[line_irgb[GRN]];
								*p++ = blu[line_irgb[BLU]];
								*p++ = 0;
								line_irgb += sizeof (RGBpixel);
							}
						} else {
							DEBUG1("FB2d\n")
							for (k = x2 - x1 + 1; k; k--) {
								*p++ = blu[line_irgb[BLU]];
								*p++ = grn[line_irgb[GRN]];
								*p++ = red[line_irgb[RED]];
								*p++ = 0;
								line_irgb += sizeof (RGBpixel);
							}
						}
					}
				}
				irgb += xi->xi_iwidth * sizeof (RGBpixel);
				opix -= xi->xi_xwidth;
			}
		} else {
			/* General case, zooming in effect */
d2943 2
a2944 15
			for (y = y1; y <= y2; y++) {
				int pyht;
				int copied;
				unsigned char *line_irgb;
				unsigned int  *prev_line;
				unsigned char *p;

				/* Calculate # lines needed */

				if (y == y1)
					pyht = y1ht;
				else if (y == y2)
					pyht = y2ht;
				else
					pyht = ifp->if_yzoom;
d2946 1
d2948 6
a2953 7
				/* Save pointer to start of line */

				line_irgb = irgb;
				prev_line = opix;
				p = (unsigned char *)opix;

				/* For the first line, convert/copy pixels */
d2955 1
d2957 3
a2959 52
					for (x = x1; x <= x2; x++) {
							int pxwd;

						/* Calculate # pixels needed */

						if (x == x1)
							pxwd = x1wd;
						else if (x == x2)
							pxwd = x2wd;
						else
							pxwd = ifp->if_xzoom;

						/* Make as many copies as needed */
						if( ImageByteOrder(xi->xi_dpy) == MSBFirst )  {
							if( xi->xi_visual->red_mask & 0xFF)  {
								DEBUG1("FB3a\n")
								while (pxwd--)   {
									*p++ = 0;
									*p++ = line_irgb[BLU];
									*p++ = line_irgb[GRN];
									*p++ = line_irgb[RED];
								}
							} else {
								DEBUG1("FB3b\n")
								while (pxwd--)   {
									*p++ = 0;
									*p++ = line_irgb[RED];
									*p++ = line_irgb[GRN];
									*p++ = line_irgb[BLU];
								}
							}
						} else {
							if( xi->xi_visual->red_mask & 0xFF)  {
								DEBUG1("FB3c\n")
								while (pxwd--)   {
									*p++ = line_irgb[RED];
									*p++ = line_irgb[GRN];
									*p++ = line_irgb[BLU];
									*p++ = 0;
								}
							} else {
								DEBUG1("FB3d\n")
								while (pxwd--)   {
									*p++ = line_irgb[BLU];
									*p++ = line_irgb[GRN];
									*p++ = line_irgb[RED];
									*p++ = 0;
								}
							}
						}
						line_irgb += sizeof (RGBpixel);
					}
d2961 3
a2963 57
					unsigned char *red = xi->xi_redmap;
					unsigned char *grn = xi->xi_grnmap;
					unsigned char *blu = xi->xi_blumap;

					for (x = x1; x <= x2; x++) {
						int pxwd;

						/* Calculate # pixels needed */

						if (x == x1)
							pxwd = x1wd;
						else if (x == x2)
							pxwd = x2wd;
						else
							pxwd = ifp->if_xzoom;


						/* Make as many copies as needed */
						if( ImageByteOrder(xi->xi_dpy) == MSBFirst )  {
							if( xi->xi_visual->red_mask & 0xFF)  {
								DEBUG1("FB4a\n")
								while (pxwd--)  {
									*p++ = 0;
									*p++ = blu[line_irgb[BLU]];
									*p++ = grn[line_irgb[GRN]];
									*p++ = red[line_irgb[RED]];
								}
							} else {
								DEBUG1("FB4b\n")
								while (pxwd--)  {
									*p++ = 0;
									*p++ = red[line_irgb[RED]];
									*p++ = grn[line_irgb[GRN]];
									*p++ = blu[line_irgb[BLU]];
								}
							}
						} else {
							if( xi->xi_visual->red_mask & 0xFF)  {
								DEBUG1("FB4c\n")
								while (pxwd--)  {
									*p++ = red[line_irgb[RED]];
									*p++ = grn[line_irgb[GRN]];
									*p++ = blu[line_irgb[BLU]];
									*p++ = 0;
								}
							} else {
								DEBUG1("FB4d\n")
								while (pxwd--)  {
									*p++ = blu[line_irgb[BLU]];
									*p++ = grn[line_irgb[GRN]];
									*p++ = red[line_irgb[RED]];
									*p++ = 0;
								}
							}
						}
						line_irgb += sizeof (RGBpixel);
					}
a2964 4
				copied = p - (unsigned char *)opix;	/* bytes */

				irgb += xi->xi_iwidth * sizeof (RGBpixel);
				opix -= xi->xi_xwidth;
d2966 5
a2970 52
				/* Copy remaining output lines from 1st output line */

				pyht--;
				while (pyht--) {
					memcpy(opix, prev_line, copied);
					opix -= xi->xi_xwidth;
				}
			}
		}
		break;
	}

	case FLG_VD16:
	case FLG_VT16:
	{
		unsigned char *irgb;
		unsigned char *opix;

		opix = (unsigned char *)&(xi->xi_pix[(oy * xi->xi_xwidth + ox) * 2]);

		irgb = &(xi->xi_mem[(y1 * xi->xi_iwidth + x1) * sizeof(RGBpixel)]);

		if (ifp->if_xzoom == 1 && ifp->if_yzoom == 1) {
			/* Special case if no zooming */

			int j, k;

			for (j = y2 - y1 + 1; j; j--) {
				unsigned char *line_irgb;
				unsigned char *p;

				line_irgb = irgb;
				p = (unsigned char *)opix;

				/* For each line, convert/copy pixels */

				if (xi->xi_flags & (FLG_XCMAP | FLG_LINCMAP))  {
					if( ImageByteOrder(xi->xi_dpy) == MSBFirst )  {
						if( xi->xi_visual->red_mask & 0xFF)  {
							DEBUG1("FB1a\n")
							for (k = x2 - x1 + 1; k; k--) {
		 						*p++ = (line_irgb[BLU]>>3) | ((line_irgb[GRN]>>2)<<5);
								*p++ = (line_irgb[GRN]>>5) | ((line_irgb[RED]>>3)<<3);
								line_irgb += sizeof (RGBpixel);
							}
						} else {
							DEBUG1("FB1b\n")
							for (k = x2 - x1 + 1; k; k--) {
								*p++ = (line_irgb[RED]>>3) | ((line_irgb[GRN]>>2)<<5);
								*p++ = (line_irgb[GRN]>>5) | ((line_irgb[BLU]>>3)<<5);
								line_irgb += sizeof (RGBpixel);
							}
d2972 5
a2976 15
					} else {
						if( xi->xi_visual->red_mask & 0xFF)  {
							DEBUG1("FB1c\n")
							for (k = x2 - x1 + 1; k; k--) {
								*p++ = (line_irgb[RED]>>3) | ((line_irgb[GRN]>>2)<<5);
								*p++ = (line_irgb[GRN]>>5) | ((line_irgb[BLU]>>3)<<5);
								line_irgb += sizeof (RGBpixel);
							}
						} else {
							DEBUG1("FB1d 16 bit\n")
							for (k = x2 - x1 + 1; k; k--) {
		 						*p++ = (line_irgb[BLU]>>3) | ((line_irgb[GRN]>>2)<<5);
								*p++ = (line_irgb[GRN]>>5) | ((line_irgb[RED]>>3)<<3);
								line_irgb += sizeof (RGBpixel);
							}
d2978 6
a2983 37
					}
				} else {
					unsigned char *red = xi->xi_redmap;
					unsigned char *grn = xi->xi_grnmap;
					unsigned char *blu = xi->xi_blumap;

					if( ImageByteOrder(xi->xi_dpy) == MSBFirst )  {
						if( xi->xi_visual->red_mask & 0xFF)  {
							DEBUG1("FB2a\n")
							for (k = x2 - x1 + 1; k; k--) {
		 						*p++ = (blu[line_irgb[BLU]]>>3) | ((grn[line_irgb[GRN]]>>2)<<5);
								*p++ = (grn[line_irgb[GRN]]>>5) | ((red[line_irgb[RED]]>>3)<<3);
								line_irgb += sizeof (RGBpixel);
							}
						} else {
							DEBUG1("FB2b\n")
							for (k = x2 - x1 + 1; k; k--) {
								*p++ = (red[line_irgb[RED]]>>3) | ((grn[line_irgb[GRN]]>>2)<<5);
								*p++ = (grn[line_irgb[GRN]]>>5) | ((blu[line_irgb[BLU]]>>3)<<5);
								line_irgb += sizeof (RGBpixel);
							}
						}
					} else {
						if( xi->xi_visual->red_mask & 0xFF)  {
							DEBUG1("FB2c\n")
							for (k = x2 - x1 + 1; k; k--) {
								*p++ = (red[line_irgb[RED]]>>3) | ((grn[line_irgb[GRN]]>>2)<<5);
								*p++ = (grn[line_irgb[GRN]]>>5) | ((blu[line_irgb[BLU]]>>3)<<5);
								line_irgb += sizeof (RGBpixel);
							}
						} else {
							DEBUG1("FB2d\n")
							for (k = x2 - x1 + 1; k; k--) {
		 						*p++ = (blu[line_irgb[BLU]]>>3) | ((grn[line_irgb[GRN]]>>2)<<5);
								*p++ = (grn[line_irgb[GRN]]>>5) | ((red[line_irgb[RED]]>>3)<<3);
								line_irgb += sizeof (RGBpixel);
							}
a2985 6
				}
				irgb += xi->xi_iwidth * sizeof (RGBpixel);
				opix -= xi->xi_xwidth * 2;
			}
		} else {
			/* General case, zooming in effect */
d2987 11
a2997 67
			for (y = y1; y <= y2; y++) {
				int pyht;
				int copied;
				unsigned char *line_irgb;
				unsigned char  *prev_line;
				unsigned char *p;

				/* Calculate # lines needed */

				if (y == y1)
					pyht = y1ht;
				else if (y == y2)
					pyht = y2ht;
				else
					pyht = ifp->if_yzoom;


				/* Save pointer to start of line */

				line_irgb = irgb;
				prev_line = opix;
				p = (unsigned char *)opix;

				/* For the first line, convert/copy pixels */

				if (xi->xi_flags & (FLG_XCMAP | FLG_LINCMAP))  {
					for (x = x1; x <= x2; x++) {
							int pxwd;

						/* Calculate # pixels needed */

						if (x == x1)
							pxwd = x1wd;
						else if (x == x2)
							pxwd = x2wd;
						else
							pxwd = ifp->if_xzoom;

						/* Make as many copies as needed */
						if( ImageByteOrder(xi->xi_dpy) == MSBFirst )  {
							if( xi->xi_visual->red_mask & 0xFF)  {
								DEBUG1("FB3a\n")
								while (pxwd--)   {
			 						*p++ = (line_irgb[BLU]>>3) | ((line_irgb[GRN]>>2)<<5);
									*p++ = (line_irgb[GRN]>>5) | ((line_irgb[RED]>>3)<<3);
								}
							} else {
								DEBUG1("FB3b\n")
								while (pxwd--)   {
									*p++ = (line_irgb[RED]>>3) | ((line_irgb[GRN]>>2)<<5);
									*p++ = (line_irgb[GRN]>>5) | ((line_irgb[BLU]>>3)<<5);
								}
							}
						} else {
							if( xi->xi_visual->red_mask & 0xFF)  {
								DEBUG1("FB3c\n")
								while (pxwd--)   {
									*p++ = (line_irgb[RED]>>3) | ((line_irgb[GRN]>>2)<<5);
									*p++ = (line_irgb[GRN]>>5) | ((line_irgb[BLU]>>3)<<5);
								}
							} else {
								DEBUG1("FB3d\n")
								while (pxwd--)   {
			 						*p++ = (line_irgb[BLU]>>3) | ((line_irgb[GRN]>>2)<<5);
									*p++ = (line_irgb[GRN]>>5) | ((line_irgb[RED]>>3)<<3);
								}
							}
d2999 6
a3004 49
						line_irgb += sizeof (RGBpixel);
					}
				} else {
					unsigned char *red = xi->xi_redmap;
					unsigned char *grn = xi->xi_grnmap;
					unsigned char *blu = xi->xi_blumap;

					for (x = x1; x <= x2; x++) {
						int pxwd;

						/* Calculate # pixels needed */

						if (x == x1)
							pxwd = x1wd;
						else if (x == x2)
							pxwd = x2wd;
						else
							pxwd = ifp->if_xzoom;


						/* Make as many copies as needed */
						if( ImageByteOrder(xi->xi_dpy) == MSBFirst )  {
							if( xi->xi_visual->red_mask & 0xFF)  {
								DEBUG1("FB4a\n")
								while (pxwd--)  {
			 						*p++ = (blu[line_irgb[BLU]]>>3) | ((grn[line_irgb[GRN]]>>2)<<5);
									*p++ = (grn[line_irgb[GRN]]>>5) | ((red[line_irgb[RED]]>>3)<<3);
								}
							} else {
								DEBUG1("FB4b\n")
								while (pxwd--)  {
									*p++ = (red[line_irgb[RED]]>>3) | ((grn[line_irgb[GRN]]>>2)<<5);
									*p++ = (grn[line_irgb[GRN]]>>5) | ((blu[line_irgb[BLU]]>>3)<<5);
								}
							}
						} else {
							if( xi->xi_visual->red_mask & 0xFF)  {
								DEBUG1("FB4c\n")
								while (pxwd--)  {
									*p++ = (red[line_irgb[RED]]>>3) | ((grn[line_irgb[GRN]]>>2)<<5);
									*p++ = (grn[line_irgb[GRN]]>>5) | ((blu[line_irgb[BLU]]>>3)<<5);
								}
							} else {
								DEBUG1("FB4d\n")
								while (pxwd--)  {
			 						*p++ = (blu[line_irgb[BLU]]>>3) | ((grn[line_irgb[GRN]]>>2)<<5);
									*p++ = (grn[line_irgb[GRN]]>>5) | ((red[line_irgb[RED]]>>3)<<3);
								}
							}
a3005 1
						line_irgb += sizeof (RGBpixel);
a3006 7
				}
				copied = p - (unsigned char *)opix;	/* bytes */

				irgb += xi->xi_iwidth * sizeof (RGBpixel);
				opix -= xi->xi_xwidth * 2;

				/* Copy remaining output lines from 1st output line */
a3007 4
				pyht--;
				while (pyht--) {
					memcpy(opix, prev_line, copied);
					opix -= xi->xi_xwidth * 2;
d3009 1
d3011 3
@


11.21
log
@*- mods to _X24_open_existing() to force reconfiguration
*- some cleanup
@
text
@d57 1
a57 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_X24.c,v 11.20 1999/04/13 21:55:56 bparker Exp $ (ARL)";
d101 2
@


11.20
log
@*- more mods to _X24_open_existing
@
text
@d57 1
a57 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_X24.c,v 11.19 1999/04/13 13:34:36 bparker Exp $ (ARL)";
d689 3
a691 4
  /* Allocate image buffer, and make our X11 Image */
  if ((xi->xi_pix = (unsigned char *) calloc(sizeof(unsigned int),
					     width*height)) == NULL) {
    fb_log("X24_open: pix32 malloc failed\n");
d695 1
d698 1
a698 2
			      (char *) xi->xi_pix, width, height,
			      sizeof(unsigned int) * 8, 0);
a705 11
#if 0
  /* If we already have data, display it */
  if (getmem_stat == 0) {
    X24_wmap(ifp, xi->xi_rgb_cmap);
    X24_blit(ifp, 0, 0, xi->xi_iwidth, xi->xi_iheight, BLIT_DISP);
  } else {
    /* Set up default linear colormap */
    X24_wmap(ifp, NULL);
  }
#endif

d708 5
@


11.19
log
@*- fixed typo
@
text
@d57 1
a57 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_X24.c,v 11.18 1999/04/12 21:49:06 bparker Exp $ (ARL)";
d610 9
a618 20
  if (vip->class == TrueColor) {
      if (vip->depth >= 24)
	  xi->xi_mode = FLG_VT24 << 1;
      else if (vip->depth >= 16)
	  xi->xi_mode = FLG_VT16 << 1;
      else
	  xi->xi_mode = FLG_VS1 << 1;
  } else if (vip->class == DirectColor) {
      if (vip->depth >= 24)
	  xi->xi_mode = FLG_VD24 << 1;
      else if (vip->depth >= 16)
	  xi->xi_mode = FLG_VD16 << 1;
      else
	  xi->xi_mode = FLG_VS1 << 1;
  } else if (vip->class == PseudoColor) {
      if (vip->depth >= 8)
	  xi->xi_mode = FLG_VP8 << 1;
      else
	  xi->xi_mode = FLG_VS1 << 1;
  } else
d620 2
d623 31
a668 6
#if 0
  /*XXX For now assume 24-bit TrueColor */
  xi->xi_flags = FLG_VT24 | FLG_XCMAP;
#else
  xi->xi_flags = FLG_VT16 | FLG_XCMAP;
#endif
@


11.18
log
@*- modified _X24_open_existing() to better set xi_mode (visual info)
@
text
@d57 1
a57 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_X24.c,v 11.17 1999/02/08 22:23:30 mike Exp $ (ARL)";
d617 1
a617 1
  } else if (vip->class = DirectColor) {
d624 1
a624 1
  } else if (vip->class = PseudoColor) {
@


11.17
log
@
Added info about XVisual to fb_help().
@
text
@d57 1
a57 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_X24.c,v 11.16 1999/01/04 13:48:44 jra Exp $ (ARL)";
d610 22
a631 2
  /*XXX For now assume 24-bit TrueColor */
  xi->xi_mode = FLG_VT24 << 1;
d647 2
d650 3
@


11.16
log
@Added support for 16 bit depth X displays.
@
text
@d57 1
a57 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_X24.c,v 11.15 1998/09/22 02:13:55 mike Exp $ (ARL)";
d194 1
d628 1
d1308 1
d1327 46
d1426 1
a1426 1
		    &visinfo)) {
d1433 1
a1433 1
		    &visinfo)) {
d1440 1
a1440 1
		    &visinfo)) {
d1447 1
a1447 1
		    &visinfo)) {
d1454 1
a1454 1
		    &visinfo)) {
d1461 1
a1461 1
		    &visinfo)) {
d1468 1
a1468 1
		    &visinfo)) {
d1475 1
a1475 1
		    &visinfo)) {
d1486 2
a1487 2
	xi->xi_visual = visinfo.visual;
	xi->xi_depth = visinfo.depth;
@


11.15
log
@Fixed problem with "default:" clause of a switch() being inside an
interior code block of another "case:" statement.
@
text
@d57 1
a57 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_X24.c,v 11.14 1998/09/14 15:59:15 bparker Exp $ (ARL)";
d277 6
a282 4
#define FLG_VP8         0x03	/* 8-bit PseudoColor */
#define FLG_VS8         0x04	/* 8-bit StaticGray */
#define FLG_VG8		0x05	/* 8-bit GrayScale */
#define FLG_VS1         0x06	/* 1-bit StaticGray */
d1389 14
d1465 21
d1792 13
d2066 17
d2755 1
d3036 241
@


11.14
log
@*- fix typos
@
text
@d57 1
a57 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_X24.c,v 11.13 1998/06/27 04:29:15 mike Exp $ (ARL)";
a1955 1
    default:
d1958 2
@


11.13
log
@Additions to LIBFB interface and remote framebuffer protocol to
read and write monochrome rectangles.
Particularly important for sending thermal images at high speed.
@
text
@d57 1
a57 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libfb/if_X24.c,v 11.12 1998/01/20 20:03:00 bparker Exp $ (ARL)";
d2102 2
a2103 2
	printf("BlackPixel = %d\n", BlackPixel(dpy,screen));
	printf("WhitePixel = %d\n", WhitePixel(dpy,screen));
d2112 1
a2112 1
	printf("DefaultColormap: 0x%x\n", DefaultColormap(dpy,screen));
d2119 1
a2119 1
		printf("---- Visual 0x%x (%d)----\n", visual, i);
d2127 1
a2127 1
			printf("RGB Masks: 0x%x 0x%x 0x%x\n", visual->red_mask,
d2132 1
a2132 1
			printf("RGB Masks: 0x%x 0x%x 0x%x\n", visual->red_mask,
d2161 2
a2162 2
		printf("XA_RGB_BEST_MAP    - Yes (0x%x)\n", cmap.colormap);
		printf("R[0..%d] * %d + G[0..%d] * %d  + B[0..%d] * %d + %d\n",
d2168 2
a2169 2
		printf("XA_RGB_DEFAULT_MAP - Yes (0x%x)\n", cmap.colormap);
		printf("R[0..%d] * %d + G[0..%d] * %d  + B[0..%d] * %d + %d\n",
d2175 2
a2176 2
		printf("XA_RGB_GRAY_MAP    - Yes (0x%x)\n", cmap.colormap);
		printf("R[0..%d] * %d + %d\n",
@


11.12
log
@more mods to allow use of FBIO with existing resources
@
text
@d57 1
a57 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_X24.c,v 11.11 1998/01/05 20:25:22 bparker Exp bparker $ (ARL)";
d158 2
@


11.11
log
@*- code to use existing resources (i.e. X window, colormap, visual, grapics context etc.)
	within FBIO
*- mods to X24_cursor
@
text
@d57 1
a57 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_X24.c,v 11.10 1997/10/07 05:11:09 mike Exp bparker $ (ARL)";
a101 1

d104 2
d138 2
a139 2
static void	handle_event FB_ARGS((FBIO *ifp, XEvent *event));

d599 1
a599 1
  if ((xi = (struct xinfo *) calloc(1, sizeof(struct xinfo))) == NULL) {
d707 2
d762 1
a762 1
	struct xinfo *xi = XI(ifp);
d764 4
a767 4
	int red, grn, blu;
	int npix;
	int n;
	unsigned char *cp;
d770 2
a771 2
printf("X24_clear(ifp:0x%x, pp:0x%x) pixel = (%d, %d, %d): entered.\n",
	ifp, pp, pp[RED], pp[GRN], pp[BLU]);
d774 7
a780 3
	red = pp[RED];
	grn = pp[GRN];
	blu = pp[BLU];
d782 2
a783 1
	/* Clear the backing store */
d785 11
a795 1
	npix = xi->xi_iwidth * xi->xi_xheight;
d797 2
a798 13
	if (pp == (unsigned char *) NULL) {
		memset(xi->xi_mem, 0, npix*3);
	} else if (red == grn && red == blu) {
		memset(xi->xi_mem, red, npix*3);
	} else {
		cp = xi->xi_mem;
		n = npix;
		while (n--) {
			*cp++ = red;
			*cp++ = grn;
			*cp++ = blu;
		}
	}
d800 1
a800 4
	X24_blit(ifp, 0, 0, xi->xi_iwidth, xi->xi_iheight,
		BLIT_DISP | BLIT_PZ);

	return(0);
d1266 1
a1266 1
	    handle_event(ifp, &event);
d1756 2
a1757 2
		if ((xi->xi_pix =
		    (unsigned char *) malloc(width*height)) == NULL) {
d1773 2
a1774 3
		if ((xi->xi_pix =
		    (unsigned char *) malloc(xi->xi_image->bytes_per_line *
		    height)) == NULL) {
d1821 1
a1821 1
		handle_event(ifp, &event);
d1828 2
a1829 2
handle_event(ifp, event)
FBIO	*ifp;
d1832 1
a1832 2
	struct xinfo *xi = XI(ifp);

d1834 5
a1838 3
	switch((int) event->type) {
	case Expose: {
		XExposeEvent	*expose = (XExposeEvent *) event;
a1839 2
		int ex1, ey1, ex2, ey2;

d1841 2
a1842 2
printf("expose event x= %d y= %d width= %d height= %d\n",
	expose->x, expose->y, expose->width, expose->height);
d1845 14
a1858 15
		ex1 = expose->x;
		ey1 = expose->y;
		ex2 = ex1 + expose->width - 1;
		ey2 = ey1 + expose->height - 1;

		/* Clip to outline of valid bits in window */

		if (ex1 < xi->xi_xlf)
			ex1 = xi->xi_xlf;
		if (ex2 > xi->xi_xrt)
			ex2 = xi->xi_xrt;
		if (ey1 < xi->xi_xtp)
			ey1 = xi->xi_xtp;
		if (ey2 > xi->xi_xbt)
			ey2 = xi->xi_xbt;
d1861 4
a1864 4
printf("expose limits (%d, %d) to (%d, %d)\n",
	xi->xi_xlf, xi->xi_xtp, xi->xi_xrt, xi->xi_xbt);
printf("clipped expose (%d, %d) to (%d, %d)\n",
	ex1, ey1, ex2, ey2);
d1867 69
a1935 6
		if (ex2 >= ex1 && ey2 >= ey1)
			XPutImage(xi->xi_dpy, xi->xi_win, xi->xi_gc,
				xi->xi_image, ex1, ey1, ex1,
				ey1, ex2 - ex1 + 1, ey2 - ey1 + 1);
		break;
	}
d1937 3
a1939 12
	case ButtonPress: {
		int button = (int) event->xbutton.button;
		if (button == Button1) {
			/* Check for single button mouse remap.
			 * ctrl-1 => 2
			 * meta-1 => 3
			 */
			if (event->xbutton.state & ControlMask)
				button = Button2;
			else if (event->xbutton.state & Mod1Mask)
				button = Button3;
		}
d1941 5
a1945 3
		switch(button) {
		case Button1:
			break;
d1947 11
a1957 15
		case Button2: {
			int	x, sy;
			int	ix, isy;
			unsigned char	*cp;

			x = event->xbutton.x;
			sy = xi->xi_xheight - event->xbutton.y - 1;

			x -= xi->xi_xlf;
			sy -= xi->xi_xheight - xi->xi_xbt - 1;
			if (x < 0 || sy < 0)
			{
				fb_log("No RGB (outside image) 1\n");
				break;
			}
d1959 2
a1960 6
			if (x < xi->xi_ilf_w)
				ix = xi->xi_ilf;
			else
				ix = xi->xi_ilf + 
					(x - xi->xi_ilf_w + ifp->if_xzoom - 1) /
					ifp->if_xzoom;
d1962 7
a1968 6
			if (sy < xi->xi_ibt_h)
				isy = xi->xi_ibt;
			else
				isy = xi->xi_ibt + 
					(sy - xi->xi_ibt_h + ifp->if_yzoom -
						1) / ifp->if_yzoom;
d1970 3
a1972 5
			if (ix >= xi->xi_iwidth || isy >= xi->xi_iheight)
			{
				fb_log("No RGB (outside image) 2\n");
				break;
			}
d1974 2
a1975 3
			cp = &(xi->xi_mem[(isy*xi->xi_iwidth + ix)*3]);
			fb_log("At image (%d, %d), real RGB=(%3d %3d %3d)\n",
				ix, isy, cp[RED], cp[GRN], cp[BLU]);
d1977 2
a1978 2
			break;
		}
d1980 2
a1981 6
		case Button3:
			alive = 0;
			break;
		}
		break;
	}
d1983 8
a1990 2
	case ConfigureNotify: {
		XConfigureEvent *conf = (XConfigureEvent *) event;
d1992 1
d1994 5
a1998 3
		if (conf->height == xi->xi_xheight &&
		    conf->width == xi->xi_xwidth)
			return;
d2000 6
a2005 10
#if EVENT_DBG
printf("configure, oldht %d oldwid %d newht %d newwid %d\n",
	xi->xi_xheight, xi->xi_xwidth, conf->height,
	conf->width);
#endif

		xi->xi_xheight = conf->height;
		xi->xi_xwidth = conf->width;

		X24_updstate(ifp);
d2007 1
a2007 18
		switch (xi->xi_flags & FLG_VMASK)
		{
		case FLG_VD24:
		case FLG_VT24:
			/* Destroy old image struct and image buffer */

			XDestroyImage(xi->xi_image);

			/* Make new buffer and new image */

			if ((xi->xi_pix = (unsigned char *)
			     calloc(sizeof (unsigned int),
				    xi->xi_xwidth*xi->xi_xheight)) == NULL) {
			  fb_log("X24: pix32 malloc failed in resize!\n");
			  return;
			}

			xi->xi_image = XCreateImage(xi->xi_dpy, xi->xi_visual,
d2012 6
a2017 1
			break;
d2019 6
a2024 15
		case FLG_VP8:
		case FLG_VS8:
		case FLG_VG8:
			/* Destroy old image struct and image buffers */

			XDestroyImage(xi->xi_image);

			/* Make new buffers and new image */

			if ((xi->xi_pix =
			    (unsigned char *) malloc(xi->xi_xwidth *
			    xi->xi_xheight)) == NULL) {
				fb_log("X24: pix8 malloc failed in resize!\n");
				return;
			}
d2026 1
a2026 1
			xi->xi_image = XCreateImage(xi->xi_dpy, xi->xi_visual,
d2029 4
a2032 4
			break;

		case FLG_VS1:
			/* Destroy old image struct and image buffers */
d2034 2
a2035 5
			XDestroyImage(xi->xi_image);

			/* Make new buffers and new image */

			xi->xi_image = XCreateImage(xi->xi_dpy,
d2039 5
a2043 9
			if ((xi->xi_pix = (unsigned char *)
			    malloc(xi->xi_image->bytes_per_line *
			    xi->xi_xheight)) == NULL) {
				fb_log("X24: pix1 malloc failed in resize!\n");
				return;
			}
			xi->xi_image->data = (char *) xi->xi_pix;
			xi->xi_image->byte_order = MSBFirst;
			xi->xi_image->bitmap_bit_order = MSBFirst;
d2045 3
a2047 2
			break;
		}
d2049 2
a2050 11
		/*
		 * Blit backing store to image buffer (we'll blit to screen
		 * when we get the expose event)
		 */

		X24_blit(ifp, 0, 0, xi->xi_iwidth, xi->xi_iheight, BLIT_RESIZE);
	}

	default:
		break;
	}
a2051 1
	return;
a2053 2


d3547 20
@


11.10
log
@Finished version.  Debug printing has been compiled out, but is still present
in the source code if needed again.
@
text
@d57 1
a57 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_X24.c,v 11.9 1997/10/07 04:53:24 mike Exp mike $ (ARL)";
d105 3
d532 144
d693 15
d1069 1
a1069 1
	struct xinfo *xi = XI(ifp);
d1072 2
a1073 2
printf("X24_cursor(ifp:0x%x, mode:%d, x:%d, y:%d) entered.\n",
	ifp, mode, x, y);
d1076 48
a1123 52
	if (mode) {
		int xdel, ydel;
		int xx, xy;

		/* If we don't have a cursor, create it */

		if (!xi->xi_curswin) {
			XSetWindowAttributes xswa;

			xswa.background_pixel = xi->xi_bp;
			xswa.border_pixel = xi->xi_wp;
			xswa.colormap = xi->xi_cmap;
			xswa.save_under = True;

			xi->xi_curswin = XCreateWindow(xi->xi_dpy, xi->xi_win,
				0, 0, 4, 4, 2, xi->xi_depth, InputOutput,
				xi->xi_visual, CWBackPixel | CWBorderPixel |
					CWSaveUnder | CWColormap, &xswa);
		}

		/* Don't try to move cursor outside displayed pixels */

		if (x < xi->xi_ilf)
			x = xi->xi_ilf;
		if (x > xi->xi_irt)
			x = xi->xi_irt;
		if (y < xi->xi_ibt)
			y = xi->xi_ibt;
		if (y > xi->xi_itp)
			y = xi->xi_itp;

		/* Compute xx: x coordinate of middle of selected pixel */

		xdel = x - xi->xi_ilf;
		if (xdel)
			xx = xi->xi_xlf + xi->xi_ilf_w +
				((xdel - 1) * ifp->if_xzoom) +
				ifp->if_xzoom / 2 - 1;
		else
			xx = xi->xi_xlf + xi->xi_ilf_w - ifp->if_xzoom / 2 - 1;

		/* Compute xy: y coordinate of middle of selected pixel */

		ydel = y - xi->xi_ibt;
		if (ydel)
			xy = xi->xi_xbt - (xi->xi_ibt_h +
				((ydel - 1) * ifp->if_yzoom)) -
				(ifp->if_yzoom / 2) - 1;
		else
			xy = xi->xi_xbt - xi->xi_ibt_h + ifp->if_yzoom / 2 - 1;

		/* Move cursor into place; make it visible if it isn't */
d1125 1
a1125 22
		XMoveWindow(xi->xi_dpy, xi->xi_curswin, xx - 4, xy - 4);

		if (!ifp->if_cursmode)
			XMapRaised(xi->xi_dpy, xi->xi_curswin);
	} else {
		/* If we have a cursor and it's visible, hide it */

		if (xi->xi_curswin && ifp->if_cursmode)
			XUnmapWindow(xi->xi_dpy, xi->xi_curswin);
	}

	/* Without this flush, cursor movement is sluggish */

	XFlush(xi->xi_dpy);

	/* Update position of cursor */

	ifp->if_cursmode = mode;
	ifp->if_xcurs = x;
	ifp->if_ycurs = y;

	return(0);
@


11.9
log
@Performance optimization
@
text
@d8 3
a10 2
 *	Christopher J. Jackson
 *	Timothy G. Smith
d48 7
d57 1
a57 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_X24.c,v 11.8 1997/10/07 04:39:51 mike Exp mike $ (ARL)";
d386 4
d2579 1
a2579 1
{static int before=1; if(before) {write(2,"FB1a\n", 5); before=0;} }
d2588 1
a2588 1
{static int before=1; if(before) {write(2,"FB1b\n", 5); before=0;} }
d2599 1
a2599 1
{static int before=1; if(before) {write(2,"FB1c\n", 5); before=0;} }
d2608 1
a2608 1
{static int before=1; if(before) {write(2,"FB1d\n", 5); before=0;} }
d2625 1
a2625 1
{static int before=1; if(before) {write(2,"FB2a\n", 5); before=0;} }
d2634 1
a2634 1
{static int before=1; if(before) {write(2,"FB2b\n", 5); before=0;} }
d2645 1
a2645 1
{static int before=1; if(before) {write(2,"FB2c\n", 5); before=0;} }
d2654 1
a2654 1
{static int before=1; if(before) {write(2,"FB2d\n", 5); before=0;} }
d2712 1
a2712 1
{static int before=1; if(before) {write(2,"FB3a\n", 5); before=0;} }
d2720 1
a2720 1
{static int before=1; if(before) {write(2,"FB3b\n", 5); before=0;} }
d2730 1
a2730 1
{static int before=1; if(before) {write(2,"FB3c\n", 5); before=0;} }
d2738 1
a2738 1
{static int before=1; if(before) {write(2,"FB3d\n", 5); before=0;} }
d2770 1
a2770 1
{static int before=1; if(before) {write(2,"FB4a\n", 5); before=0;} }
d2778 1
a2778 1
{static int before=1; if(before) {write(2,"FB4b\n", 5); before=0;} }
d2788 1
a2788 1
{static int before=1; if(before) {write(2,"FB4c\n", 5); before=0;} }
d2796 1
a2796 1
{static int before=1; if(before) {write(2,"FB4d\n", 5); before=0;} }
@


11.8
log
@Minor addition of curly brackets.
Still has debug prints
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_X24.c,v 11.7 1997/10/07 04:36:07 mike Exp mike $ (ARL)";
d2565 2
a2566 3
					for (k = x2 - x1 + 1; k; k--) {
						if( ImageByteOrder(xi->xi_dpy) == MSBFirst )  {
							if( xi->xi_visual->red_mask & 0xFF)  {
d2568 1
d2573 3
a2575 1
							} else {
d2577 1
d2582 1
d2584 3
a2586 2
						} else {
							if( xi->xi_visual->red_mask & 0xFF)  {
d2588 1
d2593 3
a2595 1
							} else {
d2597 1
d2602 1
a2604 1
						line_irgb += sizeof (RGBpixel);
d2611 2
a2612 3
					for (k = x2 - x1 + 1; k; k--) {
						if( ImageByteOrder(xi->xi_dpy) == MSBFirst )  {
							if( xi->xi_visual->red_mask & 0xFF)  {
d2614 1
d2619 3
a2621 1
							} else {
d2623 1
d2628 1
d2630 3
a2632 2
						} else {
							if( xi->xi_visual->red_mask & 0xFF)  {
d2634 1
d2639 3
a2641 1
							} else {
d2643 1
d2648 1
a2650 1
						line_irgb += sizeof (RGBpixel);
d2698 2
a2699 4
						while (pxwd--)   {
							/* Get/convert pixel */
							if( ImageByteOrder(xi->xi_dpy) == MSBFirst )  {
								if( xi->xi_visual->red_mask & 0xFF)  {
d2701 1
d2706 2
a2707 1
								} else {
d2709 1
d2715 3
a2717 2
							} else {
								if( xi->xi_visual->red_mask & 0xFF)  {
d2719 1
d2724 2
a2725 1
								} else {
d2727 1
d2756 2
a2757 4
						while (pxwd--)  {
							/* Get/convert pixel */
							if( ImageByteOrder(xi->xi_dpy) == MSBFirst )  {
								if( xi->xi_visual->red_mask & 0xFF)  {
d2759 1
d2764 2
a2765 1
								} else {
d2767 1
d2773 3
a2775 2
							} else {
								if( xi->xi_visual->red_mask & 0xFF)  {
d2777 1
d2782 2
a2783 1
								} else {
d2785 1
@


11.7
log
@Seemingly, a fully working version, but still with debug prints installed.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_X24.c,v 11.6 1997/10/07 04:04:16 mike Exp mike $ (ARL)";
a2558 4
				unsigned char *red = xi->xi_redmap;
				unsigned char *grn = xi->xi_grnmap;
				unsigned char *blu = xi->xi_blumap;

d2564 1
a2564 1
				if (xi->xi_flags & (FLG_XCMAP | FLG_LINCMAP))
d2597 5
a2601 1
				else
d2634 1
a2634 1

a2647 4
				unsigned char *red = xi->xi_redmap;
				unsigned char *grn = xi->xi_grnmap;
				unsigned char *blu = xi->xi_blumap;

d2666 1
a2666 1
				if (xi->xi_flags & (FLG_XCMAP | FLG_LINCMAP))
d2714 5
a2718 1
				else
d2767 1
a2767 1

@


11.6
log
@Incremental progress.  Now supports both variations of ImageByteOrder and red_mask
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_X24.c,v 11.5 1997/10/07 03:18:45 mike Exp mike $ (ARL)";
d2570 2
a2571 2
if( ImageByteOrder(xi->xi_dpy) == MSBFirst )  {
	if( xi->xi_visual->red_mask & 0xFF)  {
d2573 5
a2577 5
						*p++ = 0;
						*p++ = line_irgb[BLU];
						*p++ = line_irgb[GRN];
						*p++ = line_irgb[RED];
	} else {
d2579 7
a2585 7
						*p++ = 0;
						*p++ = line_irgb[RED];
						*p++ = line_irgb[GRN];
						*p++ = line_irgb[BLU];
	}
} else {
	if( xi->xi_visual->red_mask & 0xFF)  {
d2587 5
a2591 5
						*p++ = line_irgb[RED];
						*p++ = line_irgb[GRN];
						*p++ = line_irgb[BLU];
						*p++ = 0;
	} else {
d2593 6
a2598 6
						*p++ = line_irgb[BLU];
						*p++ = line_irgb[GRN];
						*p++ = line_irgb[RED];
						*p++ = 0;
	}
}
d2603 2
a2604 1
if( ImageByteOrder(xi->xi_dpy) == MSBFirst )  {
d2606 5
a2610 5
						*p++ = 0;
						*p++ = blu[line_irgb[BLU]];
						*p++ = grn[line_irgb[GRN]];
						*p++ = red[line_irgb[RED]];
} else {
d2612 20
a2631 5
						*p++ = blu[line_irgb[BLU]];
						*p++ = grn[line_irgb[GRN]];
						*p++ = red[line_irgb[RED]];
						*p++ = 0;
}
a2683 1

d2686 2
a2687 1
if( ImageByteOrder(xi->xi_dpy) == MSBFirst )  {
d2689 5
a2693 5
						*p++ = 0;
						*p++ = line_irgb[BLU];
						*p++ = line_irgb[GRN];
						*p++ = line_irgb[RED];
} else {
d2695 21
a2715 5
						*p++ = line_irgb[BLU];
						*p++ = line_irgb[GRN];
						*p++ = line_irgb[RED];
						*p++ = 0;
}
a2716 1
						}
d2734 3
a2736 3

						/* Get/convert pixel */
if( ImageByteOrder(xi->xi_dpy) == MSBFirst )  {
d2738 5
a2742 5
						*p++ = 0;
						*p++ = blu[line_irgb[BLU]];
						*p++ = grn[line_irgb[GRN]];
						*p++ = red[line_irgb[RED]];
} else {
d2744 21
a2764 6
						*p++ = blu[line_irgb[BLU]];
						*p++ = grn[line_irgb[GRN]];
						*p++ = red[line_irgb[RED]];
						*p++ = 0;
}

a2765 1
						}
@


11.5
log
@This version works on Indigo2 and Linux, but does not work
with new O2 workstations!
Also contains debug prints.
Safety checkpoint.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_X24.c,v 11.4 1997/10/06 19:47:16 bparker Exp mike $ (ARL)";
d2571 1
d2577 7
d2585 8
a2592 1
{static int before=1; if(before) {write(2,"FB1b\n", 5); before=0;} }
d2597 1
@


11.4
log
@test
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_X24.c,v 11.3 1997/09/23 21:36:30 bparker Exp bparker $ (ARL)";
d2557 1
a2557 1
				unsigned int *line_opix;
d2564 1
a2564 1
				line_opix = opix;
d2570 13
a2582 11
#if 1
						*line_opix++ =
							(line_irgb[RED] << 16) |
							(line_irgb[GRN] << 8) |
							 line_irgb[BLU];
#else
						*line_opix++ =
							(line_irgb[BLU] << 16) |
							(line_irgb[GRN] << 8) |
							 line_irgb[RED];
#endif
d2587 13
a2599 11
#if 1
						*line_opix++ =
							(blu[line_irgb[RED]] << 16) |
							(grn[line_irgb[GRN]] << 8) |
							 red[line_irgb[BLU]];
#else
						*line_opix++ =
							(blu[line_irgb[BLU]] << 16) |
							(grn[line_irgb[GRN]] << 8) |
							 red[line_irgb[RED]];
#endif
d2607 1
a2607 1
			/* General case */
d2613 2
a2614 1
				unsigned int pix, *line_opix, *prev_line;
d2633 2
a2634 1
				prev_line = line_opix = opix;
d2651 1
a2651 10
						/* Get/convert pixel */
#if 1
						pix = (line_irgb[RED] << 16) |
							(line_irgb[GRN] << 8) |
							line_irgb[BLU];
#else
						pix = (line_irgb[BLU] << 16) |
							(line_irgb[GRN] << 8) |
							line_irgb[RED];
#endif
d2653 15
d2669 1
a2669 5

						/* Make as many copies as needed */

						while (pxwd--)
							*line_opix++ = pix;
d2684 4
d2689 13
a2701 9
#if 1
						pix = (blu[line_irgb[RED]] << 16) |
							(grn[line_irgb[GRN]] << 8) |
							red[line_irgb[BLU]];
#else
						pix = (blu[line_irgb[BLU]] << 16) |
							(grn[line_irgb[GRN]] << 8) |
							red[line_irgb[RED]];
#endif
d2704 1
a2704 5

						/* Make as many copies as needed */

						while (pxwd--)
							*line_opix++ = pix;
d2707 1
a2707 1
				copied = line_opix - opix;
d2716 1
a2716 1
					memcpy(opix, prev_line, 4 * copied);
@


11.3
log
@*** empty log message ***
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_X24.c,v 11.2 1996/08/26 23:14:32 mike Exp bparker $ (ARL)";
d2570 1
d2572 5
d2580 1
d2585 1
d2587 5
d2595 1
d2646 5
a2650 1

d2654 1
d2677 5
a2681 1

d2685 1
@


11.2
log
@Made malloc() error message a bit more useful.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_X24.c,v 11.1 1995/01/04 09:52:44 mike Rel4_4 mike $ (ARL)";
d396 1
a396 1

d1588 2
a1589 2
		if ((xi->xi_pix = (unsigned char *) calloc(4, width*height)) ==
		    NULL) {
d1596 2
a1597 1
			(char *) xi->xi_pix, width, height, 32, 0);
d1821 4
a1824 3
			    calloc(4, xi->xi_xwidth*xi->xi_xheight)) == NULL) {
				fb_log("X24: pix32 malloc failed in resize!\n");
				return;
d1829 2
a1830 1
				xi->xi_xwidth, xi->xi_xheight, 32, 0);
d2542 1
a2542 1
		unsigned long *opix;
d2544 3
a2546 2
		opix = (unsigned long *) &(xi->xi_pix[(oy * xi->xi_xwidth +
			ox) * sizeof (unsigned long)]);
d2557 2
a2558 1
				unsigned long *line_opix;
d2595 2
a2596 1
				unsigned long pix, *line_opix, *prev_line;
@


11.1
log
@Release_4.4
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_X24.c,v 1.16 94/12/30 04:45:09 mike Exp $ (ARL)";
d2115 1
a2115 1
store\n", size);
@


1.16
log
@Prefer mmap() over shm().
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_X24.c,v 1.15 94/12/30 04:43:09 mike Exp Locker: mike $ (ARL)";
@


1.15
log
@Changed John's symbols to hAVE_SYS_MMAN_H and HAVE_SYS_SHM_H,
to be consistent with existing symbol usage in h/conf.h.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_X24.c,v 1.14 94/12/22 22:42:57 stay Exp Locker: mike $ (ARL)";
d72 1
@


1.14
log
@Fixed the author line
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/libfb/RCS/if_X24.c,v 1.13 1994/12/22 00:46:13 mike Exp stay $ (ARL)";
d67 11
a77 5
#ifdef HAVE_MMAP
#include <unistd.h>
#include <sys/mman.h>
#include <fcntl.h>
#define CAN_LINGER 1
a79 6
#ifdef HAVE_SHM
#include <sys/ipc.h>
#include <sys/shm.h>
#define	CAN_LINGER 1
#endif

d205 1
a205 1
#ifdef HAVE_SHM
d2056 1
a2056 1
#ifdef HAVE_MMAP
d2077 1
a2077 1
#ifdef HAVE_SHM
d2138 1
a2138 1
#ifndef HAVE_MMAP
d2143 1
a2143 1
#ifdef HAVE_MMAP
d2146 1
a2146 1
#ifdef HAVE_SHM
@


1.13
log
@Changed to HAVE_XOSDEFS_H
@
text
@d8 1
a8 1
 *	Christopher Jackson
d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_X24.c,v 1.12 94/12/15 16:27:16 jra Exp Locker: mike $ (ARL)";
@


1.12
log
@X11/Xfuncproto.h and X11/Xosdefs.h are not available on CRAY2.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_X24.c,v 1.11 94/12/09 08:57:57 jra Exp Locker: jra $ (ARL)";
d81 1
a81 1
#ifndef CRAY2	/* Not available on CRAY2 */
d84 1
a84 1
#endif  /* CRAY2 */
@


1.11
log
@mods for CRAY machines.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/libfb/RCS/if_X24.c,v 1.10 94/12/07 21:36:54 mike Exp Locker: jra $ (ARL)";
d81 1
d84 1
@


1.10
log
@Linux port.
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_X24.c,v 1.9 94/12/01 19:36:09 mike Exp Locker: mike $ (ARL)";
d71 4
a74 1
#else
d77 1
d203 1
a203 1
#ifndef HAVE_MMAP
d2074 2
a2075 1
#else
d2100 5
d2143 2
a2144 1
#else
d2156 1
d2158 1
@


1.9
log
@ANSI clean
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_X24.c,v 1.8 94/12/01 19:31:53 mike Exp Locker: mike $ (ARL)";
d76 7
@


1.8
log
@Minor mods to enable compilation on non-ANSI machines, like SunOS 4
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
a363 8
static double dtime()
{
	struct timeval tv;

	gettimeofday(&tv, NULL);
	return ((double) tv.tv_sec + (double) tv.tv_usec / 1000000.0);
}

d386 1
a386 1
	 *  file = "/dev/X24###"
a843 1
	struct xinfo *xi = XI(ifp);
a844 1

a865 1
	struct xinfo *xi = XI(ifp);
a970 1
	struct xinfo *xi = XI(ifp);
a1122 1
	struct xinfo *xi = XI(ifp);
a1123 1

a1134 2
	struct xinfo *xi = XI(ifp);

d1149 1
a1149 1
	fb_log("Usage: /dev/X24[options]\n");
a1245 1
	case -1:
d1248 1
@


1.7
log
@Fixed double-free problem.
@
text
@d49 1
d52 2
d57 5
a61 1
#include "conf.h"
d112 1
a112 1
static void	handle_event(FBIO *ifp, XEvent *event);
d1337 3
a1339 3
		xi->xi_ccredtbl = malloc(64 * 256);
		xi->xi_ccgrntbl = malloc(64 * 256);
		xi->xi_ccblutbl = malloc(64 * 256);
d1459 2
a1460 2
		xi->xi_andtbl = malloc(64 * 256);
		xi->xi_ortbl = malloc(64 * 256);
d1486 3
a1488 3
		xi->xi_redmap = malloc(256);
		xi->xi_grnmap = malloc(256);
		xi->xi_blumap = malloc(256);
d2093 1
a2093 1
			if ((mem = shmat(xi->xi_shmid, 0, 0)) != (void *)-1L)
@


1.6
log
@Latest code from Tim.
@
text
@a1257 1
		XCloseDisplay(xi->xi_dpy);
a1484 1
			XCloseDisplay(xi->xi_dpy);
@


1.5
log
@Got rid of a few extra debug prints.
@
text
@d4 2
a5 1
 *  24 bit X Window System (X11) libfb interface.
a41 9
/*
 To do:

- Support little-endian X servers and hosts properly
- Provide real cursor support
- Arrange for HAVE_MMAP to be defined by build

*/

a46 2
#define HAVE_MMAP 1

d48 1
a48 2
static char sccsid[] = "@@(#)if_X24.c version 1.19 (03 Nov 1994)";
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_X24.c,v 1.4 94/11/18 23:20:27 mike Exp Locker: mike $ (ARL)";
d71 1
a71 1
#include <X11/Xatom.h>		/* for XA_RGB_BEST_MAP */
a103 1
static	void	slowrect();
a104 3
static unsigned long
		X24_pixel();

d159 1
d166 2
d169 12
a180 2
	unsigned char	*xi_xpixbuf;	/* 32 bit per pixel X Image buffer */
	unsigned char	*xi_mem;	/* 24bit backing store */
d182 4
d187 1
d189 3
a191 2
	int		xi_mode;	/* 0,1,2 */
	int		xi_flags;
d193 3
a195 3
	unsigned char	*xi_redmap;	/* Fake colormap for TrueColor */
	unsigned char	*xi_blumap;	/* Fake colormap for TrueColor */
	unsigned char	*xi_grnmap;	/* Fake colormap for TrueColor */
d197 10
d236 17
d257 2
d268 4
a271 4
	char	c;
	long	mask;
	long	value;
	char	*help;
d279 12
d294 1
a294 3
#define FLG_LINCMAP	0x1	/* We're using a linear colormap */
#define FLG_XCMAP	0x2	/* The X server can do colormapping for us */
#define FLG_INIT	0x4	/* Display is fully initialized */
d302 55
a361 1

a371 2
	int ret;
	int mode;			/* local copy */
d373 3
d387 1
a387 1
	 *  file = "/dev/X###"
a399 3
#if X_DBG
printf("X24_open(ifp:0x%x, file:%s): if_name:%s, mismatch.\n", file, ifp->if_name);
#endif
a429 4
#if X_DBG
printf("X24_open() mode:0x%x\n", mode);
#endif

d467 1
a467 10
	switch (X24_getmem(ifp))
	{
	case 0:		/* Allocated, shared memory was there already */
		X24_blit(ifp, 0, 0, xi->xi_iwidth, xi->xi_iheight, 0);
		break;

	case 1:		/* Allocated, shared memory is new */
		break;

	case -1:	/* Failed */
a469 1
		break;
d474 1
a474 5
	if ((ret = xsetup(ifp, width, height)) < 0) {
#if X_DBG
		fb_log("if_X24: Can't get 24 bit Visual on X display \"%s\"\n",
		       XDisplayName(NULL));
#endif
a477 4
	if (ret == 0 )  {
		/* xsetup unable to get 24-bit visual. */
		extern FBIO X_interface;	/* from if_X.c */
		char	*nametemp;
a478 38
#if X_DBG
		fb_log("if_X24: Can't get 24 bit Visual on X display \"%s\", trying 8/1-bit code\n",
		       XDisplayName(NULL));
#endif
		X24_destroy(xi);

		/* Let if_X take a crack at it */
		nametemp = ifp->if_name;
		*ifp = X_interface;	/* struct copy */
		ifp->if_name = nametemp;
		ifp->if_magic = FB_MAGIC;

		return X_interface.if_open( ifp, nametemp, width, height );
		/*
		 * Because function ptrs in 'ifp' were changed,
		 * no further calls will be made on if_X24.c.
		 */
	}

	/* Allocate the image buffer */

	if ((xi->xi_xpixbuf = (unsigned char *) calloc(4, width*height)) ==
	    NULL) {
		fb_log("X24_open: xpixbuf malloc failed\n");
		X24_destroy(xi);
		return(-1);
	}

	/*
	 *  Create an Image structure.
	 *  The image is our client resident copy which we
	 *  can get/put from/to a server resident Pixmap or
	 *  Window (i.e. a "Drawable").
	 */
	xi->xi_image = XCreateImage(xi->xi_dpy,
		xi->xi_visual, 24, ZPixmap, 0,
		(char *) xi->xi_xpixbuf, width, height, 32, 0);

d486 10
d500 1
a509 4
#if X_DBG
printf("X24_close(ifp:0x%x): entered.\n", ifp);
#endif

a525 3
		if (xi->xi_xpixbuf)
			free(xi->xi_xpixbuf);

d536 10
d554 1
a554 2
			if (xi->xi_image) {
				xi->xi_image->data = NULL;
a555 1
			}
a578 3
	XSetWindowAttributes attr;
	XGCValues gcv;

d606 2
a607 1
	/* Clear the X image */
a608 36
	npix = xi->xi_xwidth * xi->xi_xheight;

	if (pp == (unsigned char *) NULL ||
		(!red && !grn && !blu)) {
		memset(xi->xi_xpixbuf, 0, npix*4);
	} else {
		unsigned long *lp = (unsigned long *) xi->xi_xpixbuf;
		unsigned long pix;

		/*
		 * XXX non-portable hack.  We know the byte order here.
		 * We should probably use the masks and such from the
		 * Visual.
		 */

		pix = X24_pixel(ifp, red, grn, blu);

		n = npix;
		while (n--)
			*lp++ = pix;
	}

	/* Clear the actual window by setting the background and clearing it */

	attr.background_pixel = X24_pixel(ifp, red, grn, blu);

	XChangeWindowAttributes(xi->xi_dpy, xi->xi_win, CWBackPixel,
		&attr);

	XClearWindow(xi->xi_dpy, xi->xi_win);

	/* Set background color in the clear GC too */

	gcv.foreground = attr.background_pixel;
	XChangeGC(xi->xi_dpy, xi->xi_cgc, GCForeground, &gcv);

d726 4
a729 3
	if (cmp)
		memcpy(map, cmp, sizeof (ColorMap));
	else {
d861 1
d892 3
a894 1
	fb_sim_cursor(ifp, mode, x, y);
d896 70
a1165 8
/*
 *			X S E T U P
 *
 *  Returns -
 *	1	OK, using 24-bit X support in this file
 *	0	OK, except couldn't get 24-bit visual.
 *	-1	fatal error
 */
d1205 3
a1207 3
	 * We need a 24-bit Visual.  First we try for DirectColor, since then
	 * the X server can do colormapping for us; if not, we try for
	 * TrueColor.  If we can't get either we bomb.
d1210 50
a1259 8
	if (XMatchVisualInfo(xi->xi_dpy, xi->xi_screen, 24, DirectColor,
	    &visinfo)) {
		xi->xi_flags |= FLG_XCMAP;
	} else if (XMatchVisualInfo(xi->xi_dpy, xi->xi_screen, 24, TrueColor,
	    &visinfo)) {
		/* Nothing to do */
	} else {
		return 0;	/* unable to get 24-bit visual */
d1261 1
d1263 1
d1265 1
a1265 1
	/* Set up colormap, if possible */
d1267 3
a1269 1
	if (xi->xi_flags & FLG_XCMAP) {
d1272 5
a1276 1
	} else {
d1278 4
a1281 4
		 * We need this, even though we're not going to use it,
		 * because if we don't specify a colormap when we create the
		 * window (thus getting the default), and the default visual
		 * is not 24-bit, the window create will fail.
d1286 3
d1290 190
a1490 4
	/* Set up default linear colormap */

	X24_wmap(ifp, NULL);

d1495 2
a1496 2
	xswa.background_pixel = X24_pixel(ifp, 0, 0, 0);
	xswa.border_pixel = X24_pixel(ifp, 255, 255, 255);
d1510 3
a1512 3
		xi->xi_screen), 0, 0, width, height, 3, 24, InputOutput,
		xi->xi_visual, CWEventMask | CWBackPixel | CWBorderPixel |
		    CWBitGravity | CWBackingStore | CWColormap,
d1553 2
a1554 2
	gcv.foreground = X24_pixel(ifp, 255, 255, 255);
	gcv.background = X24_pixel(ifp, 0, 0, 0);
d1560 2
a1561 2
	gcv.foreground = X24_pixel(ifp, 0, 0, 0);
	gcv.background = X24_pixel(ifp, 0, 0, 0);
d1579 1
d1581 68
a1648 1
	return 1;	/* OK, using if_X24 */
d1661 1
a1661 1
		return 1;	/* release the parent */
a1662 4
#if X_DBG
printf("X24 linger(ifp:0x%x): entered.\n", ifp);
#endif

d1667 1
d1806 5
a1810 1
		/* Destroy old image struct and image buffer */
d1812 1
a1812 1
		XDestroyImage(xi->xi_image);
d1814 1
a1814 1
		/* Make new buffer and new image */
d1816 55
a1870 4
		if ((xi->xi_xpixbuf = (unsigned char *)
		    calloc(4, xi->xi_xwidth*xi->xi_xheight)) == NULL) {
			fb_log("X24_open: xpixbuf malloc failed in resize!\n");
			return;
a1872 4
		xi->xi_image = XCreateImage(xi->xi_dpy, xi->xi_visual, 24,
			ZPixmap, 0, (char *) xi->xi_xpixbuf, xi->xi_xwidth,
			xi->xi_xheight, 32, 0);

d1902 1
a1902 1
	Visual	*visual, *DefaultVisual;
a1948 2
	DefaultVisual = DefaultVisual(dpy,screen);

d2088 1
a2088 1
			if ((mem = shmat(xi->xi_shmid, 0, 0)) != (void *)-1)
d2130 1
d2133 1
a2134 1

a2152 15
static unsigned long
X24_pixel(ifp, r, g, b)
FBIO	*ifp;
int	r, g, b;
{
	struct xinfo *xi = XI(ifp);

	if (xi->xi_flags & FLG_XCMAP)
		return ((b << 16) | (g << 8) | r);
	else
		return ((xi->xi_blumap[b] << 16) |
			(xi->xi_grnmap[g] << 8) |
			xi->xi_redmap[r]);
}

a2442 3
	unsigned char *irgb;
	unsigned long *opix;

d2484 1
a2484 1
		ox = x1wd + (xdel - 1 * ifp->if_xzoom) + xi->xi_xlf;
d2493 1
a2493 1
		oy = xi->xi_xbt - (y1ht + (ydel - 1 * ifp->if_yzoom));
d2497 13
d2521 7
a2527 3
	opix = (unsigned long *) &(xi->xi_xpixbuf[(oy * xi->xi_xwidth + ox) *
		sizeof (unsigned long)]);
	irgb = &(xi->xi_mem[(y1 * xi->xi_iwidth + x1) * sizeof (RGBpixel)]);
d2529 4
a2532 2
	if (ifp->if_xzoom == 1 && ifp->if_yzoom == 1) {
		/* Special case if no zooming */
d2534 2
a2535 1
		int j, k;
d2537 1
a2537 6
		for (j = y2 - y1 + 1; j; j--) {
			unsigned char *line_irgb;
			unsigned long *line_opix;
			unsigned char *red = xi->xi_redmap;
			unsigned char *grn = xi->xi_grnmap;
			unsigned char *blu = xi->xi_blumap;
d2539 6
a2544 2
			line_irgb = irgb;
			line_opix = opix;
d2546 2
a2547 1
			/* For each line, convert/copy pixels */
d2549 1
a2549 16
			if (xi->xi_flags & (FLG_XCMAP | FLG_LINCMAP))
				for (k = x2 - x1 + 1; k; k--) {
					*line_opix++ =
						(line_irgb[BLU] << 16) |
						(line_irgb[GRN] << 8) |
						 line_irgb[RED];
					line_irgb += 3;
				}
			else
				for (k = x2 - x1 + 1; k; k--) {
					*line_opix++ =
						(blu[line_irgb[BLU]] << 16) |
						(grn[line_irgb[GRN]] << 8) |
						 red[line_irgb[RED]];
					line_irgb += 3;
				}
d2551 16
a2566 5
			irgb += xi->xi_iwidth * 3;
			opix -= xi->xi_xwidth;
		}
	} else {
		/* General case */
d2568 5
a2572 8
		for (y = y1; y <= y2; y++) {
			int pyht;
			int copied;
			unsigned char *line_irgb;
			unsigned long pix, *line_opix, *prev_line;
			unsigned char *red = xi->xi_redmap;
			unsigned char *grn = xi->xi_grnmap;
			unsigned char *blu = xi->xi_blumap;
d2574 8
a2581 1
			/* Calculate # lines needed */
d2583 1
a2583 6
			if (y == y1)
				pyht = y1ht;
			else if (y == y2)
				pyht = y2ht;
			else
				pyht = ifp->if_yzoom;
d2585 6
a2591 1
			/* Save pointer to start of line */
d2593 1
a2593 2
			line_irgb = irgb;
			prev_line = line_opix = opix;
d2595 2
a2596 1
			/* For the first line, convert/copy pixels */
d2598 1
a2598 3
			if (xi->xi_flags & (FLG_XCMAP | FLG_LINCMAP))
				for (x = x1; x <= x2; x++) {
					int pxwd;
d2600 3
a2602 1
					/* Calculate # pixels needed */
d2604 1
a2604 6
					if (x == x1)
						pxwd = x1wd;
					else if (x == x2)
						pxwd = x2wd;
					else
						pxwd = ifp->if_xzoom;
d2606 6
a2611 1
					/* Get/convert pixel */
d2613 1
a2613 3
					pix = (line_irgb[BLU] << 16) |
						(line_irgb[GRN] << 8) |
						line_irgb[RED];
d2615 3
a2617 1
					line_irgb += 3;
d2619 1
a2619 1
					/* Make as many copies as needed */
d2621 43
a2663 2
					while (pxwd--)
						*line_opix++ = pix;
d2665 4
a2668 3
			else
				for (x = x1; x <= x2; x++) {
					int pxwd;
d2670 4
a2673 1
					/* Calculate # pixels needed */
d2675 112
a2786 4
					if (x == x1)
						pxwd = x1wd;
					else if (x == x2)
						pxwd = x2wd;
d2788 2
a2789 1
						pxwd = ifp->if_xzoom;
d2791 1
a2791 1
					/* Get/convert pixel */
d2793 6
a2798 3
					pix = (blu[line_irgb[BLU]] << 16) |
						(grn[line_irgb[GRN]] << 8) |
						red[line_irgb[RED]];
d2800 3
a2802 1
					line_irgb += 3;
d2804 6
a2809 1
					/* Make as many copies as needed */
d2811 9
a2819 2
					while (pxwd--)
						*line_opix++ = pix;
d2821 5
d2827 7
a2833 1
			copied = line_opix - opix;
d2835 4
a2838 2
			irgb += xi->xi_iwidth * 3;
			opix -= xi->xi_xwidth;
d2840 2
a2841 1
			/* Copy remaining output lines from 1st output line */
d2843 38
a2880 4
			pyht--;
			while (pyht--) {
				memcpy(opix, prev_line, 4 * copied);
				opix -= xi->xi_xwidth;
d2882 102
d2985 1
d2988 4
d2993 4
a2996 1
	/* Figure out size of changed area on screen in X pixels */
d2998 4
a3001 4
	if (x2 == x1)
		xwd = x1wd;
	else
		xwd = x1wd + x2wd + ifp->if_xzoom * (x2 - x1 - 1);
d3003 194
a3196 4
	if (y2 == y1)
		xht = y1ht;
	else
		xht = y1ht + y2ht + ifp->if_yzoom * (y2 - y1 - 1);
@


1.4
log
@Fixed bug with size not tracking open request.
@
text
@d59 1
a59 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_X24.c,v 1.3 94/11/18 22:42:44 mike Exp Locker: mike $ (ARL)";
d394 1
d397 1
d406 1
d409 1
@


1.3
log
@Got linger mode to work.
Added automatic fallback to old if_X.c module when 24-bit not available.
@
text
@d50 1
a50 1
#define X_DBG	1
d53 1
a53 1
#define EVENT_DBG 1
d59 1
a59 1
static char RCSid[] = "@@(#)$Header: /m/cad/libfb/RCS/if_X24.c,v 1.2 94/11/08 05:20:05 mike Exp Locker: mike $ (ARL)";
d354 3
@


1.2
log
@Irix 4 nits
@
text
@d50 1
a50 1
#define X_DBG	0
d53 1
a53 1
#define EVENT_DBG 0
d59 1
a59 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
d147 1
a147 1
	"/dev/X24",		/* short device name	*/
d275 1
a275 1

d289 1
a289 1
	 *  file = "/dev/X24###"
d302 3
d310 1
a310 1
			cp = &file[8];
d335 4
d390 3
a392 1
	if (xsetup(ifp, width, height) < 0) {
d396 4
d401 17
d457 4
d1076 8
d1135 1
a1135 4
		fb_log("if_X24: Can't get 24 bit Visual on X display \"%s\"\n",
		       XDisplayName(NULL));
		XCloseDisplay(xi->xi_dpy);
		return (-1);
d1259 1
a1259 1
	return (0);
d1273 4
@


1.1
log
@Initial revision
@
text
@d59 1
d259 1
a259 1
double dtime()
d263 1
a263 1
	gettimeofday(&tv);
@
